# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 13 1a			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		.buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			 
001c			include "firmware.asm" 
001c			  
001c			; main constants (used here and in firmware)  
001c			  
001c			; TODO have page 0 of storage as bios  
001c			  
001c			Device_A: equ 0h  
001c			Device_B: equ 040h          ; Sound  
001c			  
001c			if BASE_KEV  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_SC114  
001c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			; TODO fixup for CPM  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			Device_D: equ 0c0h             ; Keyboard and LCD  
001c			  
001c			; Odd specific debug points for testing hardware dev  
001c			  
001c			DEBUG_SOUND: equ 1  
001c			DEBUG_STK_FAULT: equ 0  
001c			DEBUG_INPUT: equ 0     ; Debug input entry code  
001c			DEBUG_KEYCINWAIT: equ 0  
001c			DEBUG_KEYCIN: equ 0  
001c			DEBUG_KEY: equ 0  
001c			DEBUG_KEY_MATRIX: equ 0  
001c			DEBUG_STORECF: equ 0  
001c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
001c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
001c			DEBUG_SPI: equ 0    ; low level spi tests  
001c			  
001c			; Enable many break points  
001c			  
001c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
001c			DEBUG_FORTH_JP: equ 0    ; 4  
001c			DEBUG_FORTH_MALLOC: equ 0  
001c			DEBUG_FORTH_MALLOC_INT: equ 0  
001c			DEBUG_FORTH_DOT: equ 0  
001c			DEBUG_FORTH_DOT_WAIT: equ 0  
001c			DEBUG_FORTH_MATHS: equ 0  
001c			DEBUG_FORTH_TOK: equ 0    ; 4  
001c			DEBUG_FORTH_PARSE: equ 0    ; 3  
001c			DEBUG_FORTH: equ 0  ;2  
001c			DEBUG_FORTH_WORDS: equ 1   ; 1  
001c			DEBUG_FORTH_PUSH: equ 1   ; 1  
001c			DEBUG_FORTH_UWORD: equ 1   ; 1  
001c			  
001c			; Enable key point breakpoints  
001c			  
001c			DEBUG_FORTH_DOT_KEY: equ 0  
001c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
001c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
001c			  
001c			; Debug stack imbalances  
001c			  
001c			ON: equ 1  
001c			OFF: equ 0  
001c			  
001c			DEBUG_STACK_IMB: equ 0  
001c			STACK_IMB_STORE: equ 20  
001c			  
001c			; House keeping and protections  
001c			  
001c			DEBUG_FORTH_STACK_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
001c			FORTH_ENABLE_FREE: equ 0  
001c			FORTH_ENABLE_MALLOCFREE: equ 1  
001c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
001c			FORTH_ENABLE_FLOATMATH: equ 0  
001c			  
001c			  
001c			CALLMONITOR: macro  
001c				call break_point_state  
001c				endm  
001c			  
001c			MALLOC_1: equ 1        ; from dk88   
001c			MALLOC_2: equ 0           ; broke  
001c			MALLOC_3: equ 0           ; really broke  
001c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
001c			  
001c			if BASE_KEV   
001c			stacksize: equ 256  
001c			  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 512  
001c			endif  
001c			if BASE_SC114  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			;if STORAGE_SE == 0  
001c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
001c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
001c			;endif  
001c			  
001c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
001c			  
001c			STORE_0_AUTORUN: equ $20  
001c			  
001c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
001c			  
001c			STORE_0_AUTOFILE: equ $21  
001c			STORE_0_BANKRUN: equ $23  
001c			STORE_0_FILERUN: equ $24  
001c			  
001c			; Block 0 offsets for settings  
001c			  
001c			; if set then skip prompt for start up and accept all  
001c			  
001c			STORE_0_QUICKSTART: equ $25  
001c			  
001c			; Blocks where directory table is held  
001c			  
001c			; Reducing the number of entries increases the max file size  
001c			  
001c			;STORE_DIR_START: equ 1  
001c			;STORE_DIR_END: equ 33  
001c			  
001c			; Blocks from where file data is stored  
001c			  
001c			;STORE_DATA_START: equ STORE_DIR_END + 1  
001c			  
001c			; Block indicators (<32 are data files)  
001c			  
001c			;STORE_BLOCK_CFG: equ $8f       ; config block  
001c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
001c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
001c			;STORE_BLOCK_FREE: equ $85       ; data block free  
001c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
001c			  
001c			  
001c			  
001c			; Directory entry flags  
001c			  
001c			;STORE_DIR_FREE: equ 0  
001c			;STORE_DIR_FILE:  equ 1  
001c			  
001c			; Structure offsets to directory entries  
001c			;STORE_DE_FLAG: equ 0  
001c			;STORE_DE_MAXEXT: equ 1  
001c			;STORE_DE_FILENAME: equ 2  
001c			  
001c			; Structure offsets to block 0  
001c			  
001c			;STORE_BK0_ISFOR: equ 1  
001c			;STORE_BK0_LABEL: equ 3  
001c			  
001c			; memory allocation   
001c			  
001c			chk_stund: equ tos+2           ; underflow check word  
001c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
001c			  
001c			; keyscan table needs rows x cols buffer  
001c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
001c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
001c			  
001c			keyscan_table_row1: equ chk_stovr -key_cols-1  
001c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
001c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
001c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
001c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
001c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
001c			keyscan_scancol: equ keyscan_table-key_cols  
001c			;keyscan_table_len: equ key_rows*key_cols  
001c			;keybufptr: equ keyscan_table - 2  
001c			;keysymbol: equ keybufptr - 1  
001c			key_held: equ keyscan_scancol-1	; currently held  
001c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
001c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
001c			key_fa: equ key_repeat_ct -1 ;  
001c			key_fb: equ key_fa -1 ;  
001c			key_fc: equ key_fb -1 ;  
001c			key_fd: equ key_fc -1 ;  
001c			key_face_held: equ key_fd - 1   
001c			  
001c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
001c			  
001c			hardware_config: equ key_face_held - 10  
001c			  
001c			; hardware config switches  
001c			; TODO add bitmasks on includes for hardware  
001c			; high byte for expansion ids  
001c			;     0000 0000  no card inserted  
001c			;     0000 0001  storage card inserted  
001c			;     0000 0010  spi sd card active  
001c			  
001c			;       
001c			; low byte:  
001c			;     0000 0001   4x4 keypad  
001c			;     0000 0010   full keyboard  
001c			;     0000 0011   spi/ext keyboard  
001c			;     0000 0100   20x4 lcd  
001c			;     0000 1000   40x4 lcd  
001c			;     0000 1100   spi/ext display  
001c			;     0001 0000   ide interface available  
001c			  
001c			hardware_word: equ hardware_config - 2  
001c			  
001c			; debug marker - optional display of debug point on the debug screens  
001c			  
001c			debug_mark: equ hardware_word - 4  
001c			  
001c			; input_str vars  
001c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
001c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
001c			input_size: equ input_start -1  ; number of chars  
001c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
001c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
001c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
001c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
001c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
001c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
001c			input_len: equ input_cur_onoff - 5 ; length of current input  
001c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
001c			  
001c			CUR_BLINK_RATE: equ 15  
001c			  
001c			key_actual_pressed: equ input_cursor - 1   
001c			key_symbol: equ key_actual_pressed - 1   
001c			key_shift: equ key_symbol - 1   
001c			  
001c			; Display allocation  
001c			  
001c			;display_rows: equ 4     ; move out to mini and mega files  
001c			;display_cols: equ 20  
001c			  
001c			display_fb_len: equ display_rows*display_cols  
001c			  
001c			; primary frame buffer     
001c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
001c			; working frame buffers  
001c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
001c			display_fb3: equ  display_fb1-display_fb_len - 1  
001c			display_fb2: equ  display_fb3-display_fb_len - 1  
001c			;  
001c			; pointer to active frame buffer  
001c			display_fb_active: equ display_fb2 - 2  
001c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
001c			display_write_tmp: equ display_lcde1e2 - 2  
001c			  
001c			  
001c			;  
001c			  
001c			;; can load into de directory  
001c			cursor_col: equ display_write_tmp-1  
001c			cursor_row: equ cursor_col-1  
001c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
001c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
001c			  
001c			; maths vars  
001c			  
001c			LFSRSeed: equ cursor_shape -20   
001c			randData: equ LFSRSeed - 2  
001c			xrandc: equ randData - 2  
001c			stackstore: equ xrandc - 2  
001c			seed1: equ  stackstore -2   
001c			seed2: equ seed1 - 2  
001c			  
001c			; cf storage vars  
001c			  
001c			iErrorNum:  equ seed2-1         ;Error number  
001c			iErrorReg:  equ iErrorNum -1              ;Error register  
001c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
001c			  
001c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
001c			  
001c			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
001c			  
001c			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
001c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
001c			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
001c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
001c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
001c			store_tmpid: equ store_tmp3 - 1		; page temp id  
001c			store_tmpext: equ store_tmpid - 1		; file extent temp  
001c			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
001c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
001c			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
001c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
001c			;  
001c			; spi vars  
001c			  
001c			  
001c			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
001c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
001c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
001c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
001c			spi_device_id: equ spi_device - 1    ; human readable bank number  
001c			  
001c			;;;;; forth cli params  
001c			  
001c			; TODO use a different frame buffer for forth???  
001c			  
001c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
001c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
001c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
001c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
001c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
001c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
001c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
001c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
001c			  
001c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
001c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
001c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
001c			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
001c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
001c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
001c			  
001c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
001c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
001c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
001c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
001c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
001c			  
001c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
001c			  
001c			; os/forth token vars  
001c			  
001c			os_last_cmd: equ os_var_array-255  
001c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
001c			os_current_i: equ os_cli_cmd-2  
001c			os_cur_ptr: equ os_current_i-2  
001c			os_word_scratch: equ os_cur_ptr-30  
001c			os_tok_len: equ os_word_scratch - 2  
001c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
001c			os_tok_malloc: equ os_tok_ptr - 2  
001c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
001c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
001c			execscratch: equ os_input-255        ; exec cmd eval buffer  
001c			scratch: equ execscratch-255  
001c			  
001c			  
001c			; temp locations for new word processing to save on adding more   
001c			  
001c			os_new_malloc: equ scratch-2  
001c			os_new_parse_len: equ os_new_malloc - 2  
001c			os_new_word_len: equ os_new_parse_len - 2  
001c			os_new_work_ptr: equ os_new_word_len - 2  
001c			os_new_src_ptr: equ os_new_work_ptr - 2  
001c			os_new_exec: equ os_new_src_ptr - 2  
001c			os_new_exec_ptr: equ os_new_exec - 2  
001c			  
001c			; resume memory alloocations....  
001c			  
001c			os_view_disable: equ os_new_exec_ptr - 1  
001c			os_view_af: equ os_view_disable - 2  
001c			os_view_hl: equ os_view_af -2  
001c			os_view_de: equ os_view_hl - 2  
001c			os_view_bc: equ os_view_de - 2  
001c			  
001c			; stack checksum word  
001c			if DEBUG_STACK_IMB  
001c				curframe: equ  os_view_de - 5  
001c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
001c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			else  
001c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			endif  
001c			  
001c			; with data stack could see memory filled with junk. need some memory management   
001c			; malloc and free entry points added  
001c			  
001c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
001c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			;heap_end: equ free_list-1  ; Starting address of heap  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			heap_end: equ chk_word-1  ; Starting address of heap  
001c			  
001c			  
001c			;if BASE_KEV   
001c			;heap_start: equ 0800eh  ; Starting address of heap  
001c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;heap_start: equ baseram+15  ; Starting address of heap  
001c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;endif  
001c			  
001c			  
001c			;;;;  
001c			  
001c			  
001c			; change below to point to last memory alloc above  
001c			topusermem:  equ   heap_start  
001c			  
001c			;if BASE_KEV   
001c			;baseusermem: equ 08000h  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;;aseusermem:     equ    12  
001c			;baseusermem:     equ    prompt  
001c			;;baseusermem:     equ    endofcode  
001c			;endif  
001c			  
001c			  
001c			; **********************************************************************  
001c			; **  Constants  
001c			; **********************************************************************  
001c			  
001c			; Constants used by this code module  
001c			kDataReg:   EQU Device_D           ;PIO port A data register  
001c			kContReg:   EQU Device_D+2           ;PIO port A control register  
001c			  
001c			  
001c			portbdata:  equ Device_D+1    ; port b data  
001c			portbctl:   equ Device_D+3    ; port b control  
001c			  
001c			  
001c			;KEY_SHIFT:   equ 5  
001c			;KEY_SYMBOLSHIFT:  equ 6  
001c			  
001c			KEY_SHIFTLOCK: equ 4  
001c			  
001c			  
001c			KEY_UP: equ 5  
001c			KEY_NEXTWORD: equ 6  
001c			KEY_PREVWORD: equ 7  
001c			KEY_BS: equ 8  
001c			KEY_TAB:  equ 9  
001c			KEY_DOWN: equ 10  
001c			KEY_LEFT: equ 11  
001c			KEY_RIGHT: equ 12  
001c			KEY_CR:   equ 13  
001c			KEY_HOME: equ 14  
001c			KEY_END: equ 15  
001c			  
001c			KEY_F1: equ 16  
001c			KEY_F2: equ 17  
001c			KEY_F3: equ 18  
001c			KEY_F4: equ 19  
001c			  
001c			KEY_F5: equ 20  
001c			KEY_F6: equ 21  
001c			KEY_F7: equ 22  
001c			KEY_F8: equ 23  
001c			  
001c			KEY_F9: equ 24  
001c			KEY_F10: equ 25  
001c			KEY_F11: equ 26  
001c			KEY_F12: equ 27  
001c			  
001c			;if DEBUG_KEY  
001c			;	KEY_MATRIX_NO_PRESS: equ '.'  
001c			;	KEY_SHIFT:   equ '.'  
001c			;	KEY_SYMBOLSHIFT:  equ '.'  
001c			;else  
001c				KEY_SHIFT:   equ '~'  
001c				KEY_SYMBOLSHIFT:  equ '~'  
001c				KEY_MATRIX_NO_PRESS: equ '~'  
001c			;endi  
001c			  
001c			  
001c			  
001c			  
001c			; Macro to make adding debug marks easier  
001c			  
001c			DMARK: macro str  
001c				push af  
001c				ld a, (.dmark)  
001c				ld (debug_mark),a  
001c				ld a, (.dmark+1)  
001c				ld (debug_mark+1),a  
001c				ld a, (.dmark+2)  
001c				ld (debug_mark+2),a  
001c				jr .pastdmark  
001c			.dmark: db str  
001c			.pastdmark: pop af  
001c			  
001c			endm  
001c			  
001c			  
001c			; macro to detect for stack imbalances  
001c			  
001c			include "stackimbal.asm"  
001c			; Macro and code to detect stock imbalances 
001c			 
001c			SPPUSH: equ 0 
001c			 
001c			; Add a stack frame which can be checked before return 
001c			 
001c			STACKFRAME: macro onoff frame1 frame2 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c						exx 
001c			 
001c						ld de, frame1 
001c						ld a, d 
001c						ld hl, curframe 
001c						call hexout 
001c						ld a, e 
001c						ld hl, curframe+2 
001c						call hexout 
001c			  
001c						ld hl, frame1 
001c						push hl 
001c						ld hl, frame2 
001c						push hl 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			endm 
001c			 
001c			STACKFRAMECHK: macro onoff frame1 frame2 
001c			 
001c					 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						exx 
001c						; check stack frame SP 
001c			 
001c						ld hl, frame2 
001c						pop de   ; frame2 
001c			 
001c						call cmp16 
001c						jr nz, .spnosame 
001c						 
001c			 
001c						ld hl, frame1 
001c						pop de   ; frame1 
001c			 
001c						call cmp16 
001c						jr z, .spfrsame 
001c			 
001c						.spnosame: call showsperror 
001c			 
001c						.spfrsame: nop 
001c			 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			 
001c			 
001c			endm 
001c			 
001c			 
001c			; for a sub routine, wrap SP collection and comparisons 
001c			 
001c			; Usage: 
001c			; 
001c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
001c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
001c			 
001c			SAVESP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c			 
001c						ld (store_sp+(storeword*4)), sp 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			CHECKSP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c			 
001c						; save SP after last save 
001c				 
001c						ld (store_sp+(storeword*4)+2), sp 
001c			 
001c						push hl 
001c						ld hl, store_sp+(storeword*4) 
001c						call check_stack_sp  
001c						pop hl 
001c			 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			if DEBUG_STACK_IMB 
001c			 
001c			check_stack_sp: 
001c					push de 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					push de 
001c			 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					pop hl 
001c			 
001c			 
001c					; check to see if the same 
001c			 
001c					call cmp16 
001c					jr z, .spsame 
001c			 
001c					; not same 
001c			 
001c					call showsperror 
001c			.spsame: 
001c			 
001c					pop de 
001c			 
001c					ret 
001c			 
001c			.sperr:  db "Stack imbalance",0 
001c			 
001c			 
001c			showsperror: 
001c			 
001c			 
001c				push hl 
001c				push af 
001c				push de 
001c				call clear_display 
001c				ld de, .sperr 
001c				ld a,0 
001c			;	ld de,os_word_scratch 
001c				call str_at_display 
001c				ld a, display_row_1+17 
001c				ld de, debug_mark 
001c				call str_at_display 
001c				ld a, 0 
001c				ld (curframe+4),a 
001c				ld hl, curframe 
001c				ld de, os_word_scratch 
001c				ld a, display_row_4 
001c				call str_at_display 
001c				call update_display 
001c				;call break_point_state 
001c				call cin_wait 
001c			 
001c				ld a, ' ' 
001c				ld (os_view_disable), a 
001c				pop de	 
001c				pop af 
001c				pop hl 
001c				CALLMONITOR 
001c				ret 
001c			 
001c			endif 
001c			 
001c			 
001c			 
001c			; eof 
# End of file stackimbal.asm
001c			  
001c			;TODO macro to calc col and row offset into screen  
001c			  
001c			  
001c			  
001c			hardware_init:  
001c			  
001c				  
001c			  
001c					;ld a, 0  
001c					;ld (hardware_diag), a  
001c			  
001c					; clear all the buffers  
001c			  
001c 21 f9 fd				ld hl, display_fb1  
001f 22 55 fd				ld (display_fb_active), hl  
0022			  
0022 cd bf 0b				call clear_display  
0025			  
0025 21 57 fd				ld hl, display_fb2  
0028 22 55 fd				ld (display_fb_active), hl  
002b			  
002b cd bf 0b				call clear_display  
002e			  
002e					; init primary frame buffer area  
002e 21 4a fe				ld hl, display_fb0  
0031 22 55 fd				ld (display_fb_active), hl  
0034			  
0034 cd bf 0b				call clear_display  
0037			  
0037			  
0037 cd 88 67				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
003a			  
003a cd d1 68			call key_init  
003d cd b8 01			call storage_init  
0040			  
0040				; setup malloc functions  
0040			  
0040				if MALLOC_1  
0040 cd 96 12				call  heap_init  
0043				endif  
0043				if MALLOC_4  
0043					call  heap_init  
0043				endif  
0043			  
0043				; init sound hardware if present  
0043			  
0043				if SOUND_ENABLE  
0043					call sound_init  
0043				endif  
0043			  
0043				; lcd test sequence  
0043					  
0043 cd e2 0b			call update_display  
0046 cd 3c 0b			call delay1s  
0049 3e 2b			ld a,'+'  
004b cd c4 0b			call fill_display  
004e cd e2 0b			call update_display  
0051 cd 3c 0b			call delay1s  
0054 3e 2a			ld a,'*'  
0056 cd c4 0b			call fill_display  
0059 cd e2 0b			call update_display  
005c cd 3c 0b			call delay1s  
005f 3e 2d			ld a,'-'  
0061 cd c4 0b			call fill_display  
0064 cd e2 0b			call update_display  
0067 cd 3c 0b			call delay1s  
006a			  
006a			; boot splash screen  
006a			if display_cols == 20	  
006a 3e 00		        ld a, display_row_1    
006c			else  
006c			        ld a, display_row_1 +10   
006c			endif  
006c 11 46 19			ld de, prom_bootmsg  
006f cd d2 0b			call str_at_display  
0072 cd e2 0b			call update_display  
0075			  
0075			  
0075 cd 3c 0b			call delay1s  
0078 cd 3c 0b			call delay1s  
007b			if display_cols == 20	  
007b 3e 2a		            LD   A, display_row_3+2  
007d			else  
007d			            LD   A, display_row_3+12  
007d			endif  
007d 11 5b 19			ld de, prom_bootmsg1  
0080 cd d2 0b			call str_at_display  
0083 cd e2 0b			call update_display  
0086 cd 3c 0b			call delay1s  
0089 cd 3c 0b			call delay1s  
008c			  
008c			;	ld a, display_row_4+3  
008c			;	ld de, bootmsg2  
008c			;	call str_at_display  
008c			;	call update_display  
008c			;	call delay1s  
008c			;	call delay1s  
008c			  
008c			; debug mark setup  
008c			  
008c 3e 5f		ld a, '_'  
008e 32 b4 fe		ld (debug_mark),a  
0091 32 b5 fe		ld (debug_mark+1),a  
0094 32 b6 fe		ld (debug_mark+2),a  
0097 3e 00		ld a,0  
0099 32 b7 fe		ld (debug_mark+3),a  
009c			  
009c c9					ret  
009d			  
009d			  
009d			;bootmsg2:	db "Firmware v0.1",0  
009d			  
009d			; a 4x20 lcd  
009d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
009d			  
009d			;if display_cols == 20  
009d			;	include "firmware_lcd_4x20.asm"  
009d			;endif  
009d			  
009d			;if display_cols == 40  
009d			;	include "firmware_lcd_4x40.asm"  
009d			;endif  
009d			  
009d			;  
009d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
009d			; TODO abstract the bit bang video out interface for dual display  
009d			; TODO wire video out to tx pin on rc2014 bus  
009d			  
009d			; must supply cin, and cin_wait for low level hardware abstraction   
009d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
009d			; test scancode  
009d			  
009d			;;;;;  
009d			;;;  
009d			; Moved out to mini and maxi versions  
009d			;  
009d			; include "firmware_key_4x4.asm"  
009d			; using existing 4 wire x 4 resistor array for input  
009d			;include "firmware_key_4x10.asm"  
009d			; need to mod the board for 5 rows due to resistor array  
009d			;include "firmware_key_5x10.asm"  
009d			  
009d			; storage hardware interface  
009d			  
009d			; use microchip serial eeprom for storage  
009d			  
009d			  
009d			if STORAGE_SE  
009d				include "firmware_spi.asm"  
009d			; my spi protocol (used by storage) 
009d			 
009d			; SPI pins 
009d			 
009d			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
009d			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
009d			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
009d			 
009d			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
009d			; chip pin 4 gnd 
009d			 
009d			 
009d			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
009d			SPI_CE1: equ 1      ;    port a1 pin 14  
009d			SPI_CE2: equ 2      ;    port a2 pin pin 13 
009d			SPI_CE3: equ 3      ; port    a3 pin pin 12 
009d			SPI_CE4: equ 4      ; port a4     pin 10 
009d			 
009d			; active low AND masks 
009d			 
009d			;SPI_CE0_MASK: equ    255-1 
009d			;SPI_CE1_MASK: equ   255-2 
009d			;SPI_CE2_MASK: equ   255-4 
009d			;SPI_CE3_MASK: equ   255-8 
009d			;SPI_CE4_MASK: equ   255-16 
009d			SPI_CE_HIGH:  equ 255 
009d			 
009d			 
009d			 
009d			 
009d			; TODO store port id for spi device ie dev c 
009d			; TODO store pin for SO 
009d			; TODO store pin for SI 
009d			; TODO store pin for SCLK 
009d			 
009d			; 
009d			 
009d			; ensure that spi bus is in a stable state with default pins  
009d			 
009d			se_stable_spi:   
009d			 
009d				 ; set DI high, CE high , SCLK low 
009d				;ld a, SPI_DI | SPI_CE0 
009d 3e 07			ld a, SPI_DI  
009f cd 73 01			call spi_ce_high 
00a2 d3 80			 out (storage_adata),a 
00a4 32 c6 fc			ld (spi_portbyte),a 
00a7			 
00a7				if DEBUG_SPI 
00a7					push hl 
00a7					ld l, a 
00a7					DMARK "SPI" 
00a7					CALLMONITOR 
00a7					pop hl 
00a7				endif 
00a7 c9				ret 
00a8			 
00a8			; byte to send in a 
00a8			 
00a8			spi_send_byte: 
00a8				; save byte to send for bit mask shift out 
00a8 4f			        ld c,a 
00a9 3a c6 fc			ld a,(spi_portbyte) 
00ac				  
00ac				; clock out	each bit of the byte msb first 
00ac			 
00ac 06 08			ld b, 8 
00ae			.ssb1: 
00ae				; clear so bit  
00ae cb bf			res SPI_DI, a 
00b0 cb 11			rl c 
00b2				; if bit 7 is set then carry is set 
00b2 30 02			jr nc, .ssb2 
00b4 cb ff			set SPI_DI,a 
00b6			.ssb2:  ; output bit to ensure it is stable 
00b6 d3 80			out (storage_adata),a 
00b8 00				nop 
00b9				; clock bit high 
00b9 cb ef			set SPI_SCLK,a 
00bb d3 80			out (storage_adata),a 
00bd 00				nop 
00be				; then low 
00be cb af			res SPI_SCLK,a 
00c0 d3 80			out (storage_adata),a 
00c2 00				nop 
00c3 10 e9			djnz .ssb1 
00c5			 
00c5 32 c6 fc			ld (spi_portbyte),a 
00c8 c9				ret 
00c9			 
00c9			; TODO low level get byte into A on spi 
00c9			 
00c9			spi_read_byte:  
00c9			 
00c9				; save byte to send for bit mask shift out 
00c9 0e 00		    ld c,0 
00cb 3a c6 fc			ld a,(spi_portbyte) 
00ce				  
00ce				; clock out	each bit of the byte msb first 
00ce			 
00ce			 
00ce				; clock bit high 
00ce cb ef			set SPI_SCLK,a 
00d0 d3 80			out (storage_adata),a 
00d2 00				nop 
00d3			 
00d3			    ; read DO  
00d3			 
00d3 cb f9		    set 7,c 
00d5 db 80			in a,(storage_adata) 
00d7 cb 77		    bit SPI_DO,a 
00d9 20 02		    jr nz, .b7 
00db cb b9		    res 7,c 
00dd			.b7: 
00dd				; then low 
00dd cb af			res SPI_SCLK,a 
00df d3 80			out (storage_adata),a 
00e1 00				nop 
00e2			     
00e2			 
00e2				; clock bit high 
00e2 cb ef			set SPI_SCLK,a 
00e4 d3 80			out (storage_adata),a 
00e6 00				nop 
00e7			 
00e7			    ; read DO  
00e7			 
00e7 cb f1		    set 6,c 
00e9 db 80			in a,(storage_adata) 
00eb cb 77		    bit SPI_DO,a 
00ed 20 02		    jr nz, .b6 
00ef cb b1		    res 6,c 
00f1			.b6: 
00f1				; then low 
00f1 cb af			res SPI_SCLK,a 
00f3 d3 80			out (storage_adata),a 
00f5 00				nop 
00f6			 
00f6				; clock bit high 
00f6 cb ef			set SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb			 
00fb			 
00fb			    ; read DO  
00fb			 
00fb cb e9		    set 5,c 
00fd db 80			in a,(storage_adata) 
00ff cb 77		    bit SPI_DO,a 
0101 20 02		    jr nz, .b5 
0103 cb a9		    res 5,c 
0105			.b5: 
0105				; then low 
0105 cb af			res SPI_SCLK,a 
0107 d3 80			out (storage_adata),a 
0109 00				nop 
010a				; clock bit high 
010a cb ef			set SPI_SCLK,a 
010c d3 80			out (storage_adata),a 
010e 00				nop 
010f			 
010f			    ; read DO  
010f			 
010f cb e1		    set 4,c 
0111 db 80			in a,(storage_adata) 
0113 cb 77		    bit SPI_DO,a 
0115 20 02		    jr nz, .b4 
0117 cb a1		    res 4,c 
0119			.b4: 
0119				; then low 
0119 cb af			res SPI_SCLK,a 
011b d3 80			out (storage_adata),a 
011d 00				nop 
011e				; clock bit high 
011e cb ef			set SPI_SCLK,a 
0120 d3 80			out (storage_adata),a 
0122 00				nop 
0123			 
0123			    ; read DO  
0123			 
0123 cb d9		    set 3,c 
0125 db 80			in a,(storage_adata) 
0127 cb 77		    bit SPI_DO,a 
0129 20 02		    jr nz, .b3 
012b cb 99		    res 3,c 
012d			.b3: 
012d				; then low 
012d cb af			res SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137			 
0137			    ; read DO  
0137			 
0137 cb d1		    set 2,c 
0139 db 80			in a,(storage_adata) 
013b cb 77		    bit SPI_DO,a 
013d 20 02		    jr nz, .b2 
013f cb 91		    res 2,c 
0141			.b2: 
0141				; then low 
0141 cb af			res SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146				; clock bit high 
0146 cb ef			set SPI_SCLK,a 
0148 d3 80			out (storage_adata),a 
014a 00				nop 
014b			 
014b			    ; read DO  
014b			 
014b cb c9		    set 1,c 
014d db 80			in a,(storage_adata) 
014f cb 77		    bit SPI_DO,a 
0151 20 02		    jr nz, .b1 
0153 cb 89		    res 1,c 
0155			.b1: 
0155				; then low 
0155 cb af			res SPI_SCLK,a 
0157 d3 80			out (storage_adata),a 
0159 00				nop 
015a				; clock bit high 
015a cb ef			set SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f			 
015f			    ; read DO  
015f			 
015f cb c1		    set 0,c 
0161 db 80			in a,(storage_adata) 
0163 cb 77		    bit SPI_DO,a 
0165 20 02		    jr nz, .b0 
0167 cb 81		    res 0,c 
0169			.b0: 
0169				; then low 
0169 cb af			res SPI_SCLK,a 
016b d3 80			out (storage_adata),a 
016d 00				nop 
016e			 
016e			 
016e 32 c6 fc			ld (spi_portbyte),a 
0171			 
0171			    ; return byte 
0171 79			    ld a,c 
0172			 
0172			 
0172 c9				ret 
0173			 
0173			 
0173			 
0173			spi_ce_high: 
0173			 
0173				if DEBUG_SPI_HARD_CE0 
0173			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0173					ret 
0173			 
0173				endif 
0173			 
0173			 
0173 f5				push af 
0174			 
0174				; send direct ce to port b 
0174 3e ff			ld a, 255 
0176 d3 81			out (storage_bdata), a 
0178			 
0178 f1				pop af 
0179			 
0179				; for port a that shares with spi lines AND the mask 
0179			  
0179				if DEBUG_SPI 
0179					push hl 
0179					ld h, a 
0179				endif 
0179			;	ld c, SPI_CE_HIGH 
0179			;	and c 
0179 cb c7			set SPI_CE0, a 
017b cb cf			set SPI_CE1, a 
017d cb d7			set SPI_CE2, a 
017f cb df			set SPI_CE3, a 
0181 cb e7			set SPI_CE4, a 
0183			 
0183				if DEBUG_SPI 
0183					ld l, a 
0183					DMARK "CEh" 
0183					CALLMONITOR 
0183					pop hl 
0183				endif 
0183 c9				ret 
0184			 
0184			 
0184			spi_ce_low: 
0184			 
0184				if DEBUG_SPI_HARD_CE0 
0184			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0184					ret 
0184			 
0184				endif 
0184			 
0184 c5				push bc 
0185 f5				push af 
0186			 
0186				; send direct ce to port b 
0186 3a c8 fc			ld a, (spi_cartdev) 
0189 d3 81			out (storage_bdata), a 
018b			 
018b			 
018b			 
018b				; for port a that shares with spi lines AND the mask 
018b			 
018b 3a c5 fc			ld a, (spi_device)  
018e 4f				ld c, a 
018f			 
018f f1				pop af 
0190			 
0190				; detect CEx 
0190			 
0190				if DEBUG_SPI 
0190					push hl 
0190					ld h, a 
0190				endif 
0190			 
0190 cb 41			bit SPI_CE0, c 
0192 20 04			jr nz, .cel1 
0194 cb 87			res SPI_CE0, a 
0196 18 1e			jr .celn 
0198			.cel1: 
0198 cb 49			bit SPI_CE1, c 
019a 20 04			jr nz, .cel2 
019c cb 8f			res SPI_CE1, a 
019e 18 16			jr .celn 
01a0			.cel2: 
01a0 cb 51			bit SPI_CE2, c 
01a2 20 04			jr nz, .cel3 
01a4 cb 97			res SPI_CE2, a 
01a6 18 0e			jr .celn 
01a8			.cel3: 
01a8 cb 59			bit SPI_CE3, c 
01aa 20 04			jr nz, .cel4 
01ac cb 9f			res SPI_CE3, a 
01ae 18 06			jr .celn 
01b0			.cel4: 
01b0 cb 61			bit SPI_CE4, c 
01b2 20 02			jr nz, .celn 
01b4 cb a7			res SPI_CE4, a 
01b6			.celn: 
01b6			 
01b6			 
01b6			 
01b6			;	add c 
01b6			 
01b6				if DEBUG_SPI 
01b6					ld l, a 
01b6					DMARK "CEl" 
01b6					CALLMONITOR 
01b6					pop hl 
01b6				endif 
01b6 c1				pop bc 
01b7 c9				ret 
01b8			 
01b8			 
01b8			 
01b8			; eof 
01b8			 
01b8			 
01b8			 
01b8			 
01b8			 
# End of file firmware_spi.asm
01b8				include "firmware_seeprom.asm"  
01b8			; 
01b8			; persisent storage interface via microchip serial eeprom 
01b8			 
01b8			; port a pio 2 
01b8			; pa 7 - si 
01b8			; pa 6 - sclk  
01b8			; pa 5 - so 
01b8			; pa 4 - cs 
01b8			; pa 3 - cs 
01b8			; pa 2 - cs 
01b8			; pa 1 - cs 
01b8			; pa 0 - cs 
01b8			; 
01b8			; TODO get block 
01b8			; TODO save block 
01b8			; TODO load file 
01b8			; TODO save file 
01b8			; TODO get dir  
01b8			 
01b8			;  
01b8			storage_adata: equ Device_C    ; device c port a - onboard storage 
01b8			storage_actl: equ Device_C+2     ; device c port a 
01b8			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01b8			storage_bctl: equ Device_C+3     ; device c port b 
01b8			 
01b8			 
01b8			; TODO move these to hardware driver file 
01b8			 
01b8			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01b8			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01b8			; storage bank file system format 
01b8			; 
01b8			; first page of bank: 
01b8			; 	addr 0 - status check 
01b8			;       addr 1 - write protect flag 
01b8			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01b8			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01b8			;         TODO see if scanning whole of for available next file id is fast enough 
01b8			;	addr 4 > zero term string of bank label 
01b8			; 
01b8			;        
01b8			;  
01b8			; first page of any file: 
01b8			;      byte 0 - file id  
01b8			;      byte 1-17 - fixed file name  
01b8			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01b8			; 
01b8			; other pages of any file: 
01b8			;      byte 0 - file id 
01b8			;      byte 1> - file data 
01b8			; 
01b8			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01b8			;  
01b8			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01b8			 
01b8			 
01b8			;storage_so_bit: 5 
01b8			;storage_si_bit: 7 
01b8			;storage_sclk_bit: 6 
01b8			  
01b8			 
01b8			; init storage pio 
01b8			 
01b8			storage_init: 
01b8			 
01b8 3e cf		            LD   A, 11001111b 
01ba d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01bc 3e 00		            LD   A, 00000000b 
01be cb f7			set SPI_DO,a 
01c0			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01c0 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01c2			 
01c2 3e cf		            LD   A, 11001111b 
01c4 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01c6 3e 00		            LD   A, 00000000b 
01c8 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01ca			 
01ca				; set all external spi devices off 
01ca 3e 00			ld a, 0 
01cc 32 c5 fc			ld (spi_device), a 
01cf 32 c8 fc			ld (spi_cartdev), a 
01d2			 
01d2					; ensure the spi bus is in a default stable state 
01d2 cd 9d 00				call se_stable_spi 
01d5			 
01d5			; TODO scan spi bus and gather which storage banks are present 
01d5			 
01d5			; populate store_bank_active  
01d5			; for each ce line activate and attempt to write first byte of bank and read back 
01d5			; if zero is returned then bank is empty 
01d5			;   
01d5			; 
01d5			 
01d5					; init file extent cache to save on slow reads 
01d5			 
01d5			;	ld hl, store_filecache 
01d5			;	ld de, 0 
01d5			;	ld hl,(de)	 
01d5			 
01d5			 
01d5 c9			    ret 
01d6			 
01d6			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01d6			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01d6			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01d6			 
01d6			; INSTRUCTION SET 
01d6			; READ 0000 0011 Read data from memory array beginning at selected address 
01d6			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01d6			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01d6			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01d6			; RDSR 0000 0101 Read STATUS register 
01d6			; WRSR 0000 0001 Write STATUS register 
01d6			; PE 0100 0010 Page Erase – erase one page in memory array 
01d6			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01d6			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01d6			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01d6			 
01d6			; TODO send byte steam for page without setting the address for every single byte 
01d6			; TODO read byte  
01d6			 
01d6			; byte in a 
01d6			; address in hl  
01d6			se_writebyte: 
01d6			        
01d6			    ;   ld c, a 
01d6 f5			        push af 
01d7 e5			        push hl 
01d8			 
01d8			    ; initi write mode 
01d8			    ; 
01d8			    ;CS low 
01d8			 
01d8 3a c6 fc		       ld a,(spi_portbyte) 
01db cd 84 01			call spi_ce_low 
01de			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01de d3 80		       out (storage_adata),a 
01e0 32 c6 fc		       ld (spi_portbyte), a 
01e3			 
01e3			    ;clock out wren instruction 
01e3			 
01e3 3e 06		    ld a, store_wren_ins 
01e5 cd a8 00		    call spi_send_byte  
01e8			 
01e8			    ;cs high to enable write latch 
01e8			 
01e8 3a c6 fc		       ld a,(spi_portbyte) 
01eb cd 73 01			call spi_ce_high 
01ee			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ee d3 80		       out (storage_adata),a 
01f0 32 c6 fc		       ld (spi_portbyte), a 
01f3			 
01f3 00				nop 
01f4			    ; 
01f4			    ; intial write data 
01f4			    ; 
01f4			    ; cs low 
01f4			     
01f4 3a c6 fc		       ld a,(spi_portbyte) 
01f7 cd 84 01			call spi_ce_low 
01fa			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01fa d3 80		       out (storage_adata),a 
01fc 32 c6 fc		       ld (spi_portbyte), a 
01ff			 
01ff			    ; clock out write instruction 
01ff			     
01ff 3e 02		    ld a, store_write_ins  
0201 cd a8 00		    call spi_send_byte  
0204			 
0204			    ; clock out address (depending on address size) 
0204			     
0204 e1			    pop hl 
0205 7c			    ld a,h    ; address out msb first 
0206 cd a8 00		    call spi_send_byte  
0209 7d			    ld a,l 
020a cd a8 00		    call spi_send_byte  
020d			 
020d			    ; clock out byte(s) for page 
020d			 
020d f1			    pop af 
020e cd a8 00		    call spi_send_byte  
0211			 
0211			    ; end write with ce high 
0211 3a c6 fc		       ld a,(spi_portbyte) 
0214			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0214 cd 73 01			call spi_ce_high 
0217 d3 80		       out (storage_adata),a 
0219 32 c6 fc		       ld (spi_portbyte), a 
021c			 
021c				; pause for internal write cycle 
021c 3e 0a			ld a, 10 
021e cd 21 0b			call aDelayInMS 
0221 c9			    ret 
0222			 
0222			; buffer to write in de 
0222			; address in hl  
0222			se_writepage: 
0222			        
0222			    ;   ld c, a 
0222 d5				push de 
0223 e5			        push hl 
0224			 
0224			    ; initi write mode 
0224			    ; 
0224			    ;CS low 
0224			 
0224 3a c6 fc		       ld a,(spi_portbyte) 
0227 cd 84 01			call spi_ce_low 
022a			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
022a d3 80		       out (storage_adata),a 
022c 32 c6 fc		       ld (spi_portbyte), a 
022f			 
022f			    ;clock out wren instruction 
022f			 
022f 3e 06		    ld a, store_wren_ins 
0231 cd a8 00		    call spi_send_byte  
0234			 
0234			    ;cs high to enable write latch 
0234			 
0234 3a c6 fc		       ld a,(spi_portbyte) 
0237 cd 73 01			call spi_ce_high 
023a			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
023a d3 80		       out (storage_adata),a 
023c 32 c6 fc		       ld (spi_portbyte), a 
023f			 
023f 00				nop 
0240			    ; 
0240			    ; intial write data 
0240			    ; 
0240			    ; cs low 
0240			     
0240 3a c6 fc		       ld a,(spi_portbyte) 
0243			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0243 cd 84 01			call spi_ce_low 
0246 d3 80		       out (storage_adata),a 
0248 32 c6 fc		       ld (spi_portbyte), a 
024b			 
024b			    ; clock out write instruction 
024b			     
024b 3e 02		    ld a, store_write_ins  
024d cd a8 00		    call spi_send_byte  
0250			 
0250			    ; clock out address (depending on address size) 
0250			     
0250 e1			    pop hl 
0251 7c			    ld a,h    ; address out msb first 
0252 cd a8 00		    call spi_send_byte  
0255 7d			    ld a,l 
0256 cd a8 00		    call spi_send_byte  
0259			 
0259			    ; clock out byte(s) for page 
0259			 
0259 e1				pop hl 
025a 06 40			ld b, STORE_BLOCK_PHY 
025c			.bytewrite: 
025c			 
025c 7e				ld a,(hl) 
025d e5			    push hl 
025e c5				push bc 
025f cd a8 00		    call spi_send_byte  
0262 c1				pop bc 
0263 e1				pop hl 
0264			 
0264			    ; end write with ce high 
0264 3a c6 fc		       ld a,(spi_portbyte) 
0267 cd 73 01			call spi_ce_high 
026a			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
026a d3 80		       out (storage_adata),a 
026c 32 c6 fc		       ld (spi_portbyte), a 
026f			 
026f 23				inc hl 
0270 10 ea			djnz .bytewrite 
0272			 
0272				; pause for internal write cycle 
0272 3e 64			ld a, 100 
0274 cd 21 0b			call aDelayInMS 
0277 c9			    ret 
0278			; returns byte in a 
0278			; address in hl  
0278			se_readbyte: 
0278 d5				push de 
0279 c5				push bc 
027a			 
027a			    ;   ld c, a 
027a e5			        push hl 
027b			 
027b			    ; initi write mode 
027b			    ; 
027b			    ;CS low 
027b			 
027b 3a c6 fc		       ld a,(spi_portbyte) 
027e cd 84 01			call spi_ce_low 
0281			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0281 d3 80		       out (storage_adata),a 
0283 32 c6 fc		       ld (spi_portbyte), a 
0286			 
0286			    ;clock out wren instruction 
0286			 
0286 3e 03		    ld a, store_read_ins 
0288 cd a8 00		    call spi_send_byte  
028b			 
028b			 
028b			    ; clock out address (depending on address size) 
028b			     
028b e1			    pop hl 
028c 7c			    ld a,h    ; address out msb first 
028d cd a8 00		    call spi_send_byte  
0290 7d			    ld a,l 
0291 cd a8 00		    call spi_send_byte  
0294			 
0294			    ; clock in byte(s) for page 
0294			 
0294 cd c9 00		    call spi_read_byte  
0297 f5				push af 
0298			 
0298			    ; end write with ce high 
0298 3a c6 fc		       ld a,(spi_portbyte) 
029b			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
029b cd 73 01			call spi_ce_high 
029e d3 80		       out (storage_adata),a 
02a0 32 c6 fc		       ld (spi_portbyte), a 
02a3			 
02a3 f1				pop af 
02a4			 
02a4 c1				pop bc 
02a5 d1				pop de 
02a6			 
02a6 c9			    ret 
02a7			 
02a7			if DEBUG_STORESE 
02a7			 
02a7			storageput:  
02a7			 
02a7			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02a7			 
02a7 21 5c f4			ld hl,scratch+2 
02aa cd aa 11			call get_word_hl 
02ad			 
02ad				; stuff it here for the moment as it will be overwritten later anyway 
02ad			 
02ad 22 7d f7			ld (os_cur_ptr),hl	 
02b0			 
02b0			 
02b0			; get pointer to start of string 
02b0			 
02b0 21 61 f4			ld hl, scratch+7 
02b3			 
02b3			; loop writing char of string to eeprom 
02b3			 
02b3 7e			.writestr:	ld a,(hl) 
02b4 fe 00				cp 0 
02b6 28 12				jr z, .wsdone		; done writing 
02b8 e5					push hl 
02b9 2a 7d f7				ld hl,(os_cur_ptr) 
02bc cd d6 01				call se_writebyte 
02bf			 
02bf 2a 7d f7				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02c2 23					inc hl 
02c3 22 7d f7				ld (os_cur_ptr),hl 
02c6			 
02c6					; restore string pointer and get next char 
02c6			 
02c6 e1					pop hl 
02c7 23					inc hl 
02c8 18 e9				jr .writestr 
02ca			 
02ca			 
02ca			 
02ca			.wsdone: 
02ca			 
02ca			 
02ca			; when done load first page into a buffer  
02ca			 
02ca 21 00 80				ld hl,08000h		; start in ram 
02cd 22 7d f7				ld (os_cur_ptr),hl 
02d0 21 00 00				ld hl, 0		 ; start of page 
02d3 22 82 f4				ld (scratch+40),hl	; hang on to it 
02d6			 
02d6 06 80				ld b, 128		; actually get more then one page 
02d8 c5			.wsload:	push bc 
02d9 2a 82 f4				ld hl,(scratch+40) 
02dc e5					push hl 
02dd cd 78 02				call se_readbyte 
02e0			 
02e0					; a now as the byte 
02e0			 
02e0 2a 7d f7				ld hl,(os_cur_ptr) 
02e3 77					ld (hl),a 
02e4					; inc next buffer area 
02e4 23					inc hl 
02e5 22 7d f7				ld (os_cur_ptr),hl 
02e8			 
02e8					; get eeprom position, inc and save for next round 
02e8 e1					pop hl		 
02e9 23					inc hl 
02ea 22 82 f4				ld (scratch+40),hl 
02ed c1					pop bc 
02ee 10 e8				djnz .wsload 
02f0			 
02f0			; set 'd' pointer to start of buffer 
02f0			 
02f0 21 00 80				ld hl,08000h 
02f3 22 7d f7				ld (os_cur_ptr),hl 
02f6			 
02f6			 
02f6 c9			ret 
02f7			 
02f7			 
02f7 c9			storageread: ret 
02f8			 
02f8			 
02f8			 
02f8			 
02f8			 
02f8			 
02f8			endif 
02f8			 
02f8			 
02f8			 
# End of file firmware_seeprom.asm
02f8			else  
02f8			   ; create some stubs for the labels  
02f8			se_readbyte: ret  
02f8			se_writebyte: ret  
02f8			storage_init: ret  
02f8			  
02f8			endif  
02f8			  
02f8			; use cf card for storage - throwing timeout errors. Hardware or software?????  
02f8			;include "firmware_cf.asm"  
02f8			  
02f8			; load up high level storage hardward abstractions  
02f8			include "firmware_storage.asm"  
02f8			 
02f8			; persisent storage hardware abstraction layer  
02f8			 
02f8			 
02f8			 
02f8			; Block 0 on storage is a config state 
02f8			 
02f8			 
02f8			 
02f8			; TODO add read phy block and write phy block functions 
02f8			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
02f8			 
02f8			; Abstraction layer  
02f8			 
02f8			; Logocial block size is same size as physical size - using tape concept 
02f8			 
02f8			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
02f8			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
02f8			 
02f8			 
02f8			 
02f8			; Filesystem layout (Logical layout) 
02f8			; 
02f8			; Block 0 - Bank config  
02f8			; 
02f8			;      Byte - 0 file id counter 
02f8			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02f8			;      Byte - 3-20 zero terminated bank label 
02f8			; 
02f8			; Block 1 > File storage 
02f8			; 
02f8			;      Byte 0 file id    - block 0 file details 
02f8			;      Byte 1 block id - block 0 is file  
02f8			;            Byte 2-15 - File name 
02f8			; 
02f8			;       - to end of block data 
02f8			; 
02f8			 
02f8			; Get ID for the file named in pointer held HL 
02f8			; Returns ID in HL = 255 if no file found 
02f8			 
02f8			storage_getid: 
02f8			 
02f8 22 dd fc			ld (store_tmp1), hl 
02fb			 
02fb				if DEBUG_STORESE 
02fb					DMARK "SGI" 
02fb f5				push af  
02fc 3a 10 03			ld a, (.dmark)  
02ff 32 b4 fe			ld (debug_mark),a  
0302 3a 11 03			ld a, (.dmark+1)  
0305 32 b5 fe			ld (debug_mark+1),a  
0308 3a 12 03			ld a, (.dmark+2)  
030b 32 b6 fe			ld (debug_mark+2),a  
030e 18 03			jr .pastdmark  
0310 ..			.dmark: db "SGI"  
0313 f1			.pastdmark: pop af  
0314			endm  
# End of macro DMARK
0314					CALLMONITOR 
0314 cd 70 17			call break_point_state  
0317				endm  
# End of macro CALLMONITOR
0317				endif 
0317				; get block 0 and set counter for number of files to scan 
0317			 
0317 cd 82 04			call storage_get_block_0 
031a			 
031a 3a df fc			ld a, (store_page) 
031d 47				ld b, a 
031e			 
031e				; get extent 0 of each file id 
031e			 
031e				if DEBUG_STORESE 
031e					DMARK "SGc" 
031e f5				push af  
031f 3a 33 03			ld a, (.dmark)  
0322 32 b4 fe			ld (debug_mark),a  
0325 3a 34 03			ld a, (.dmark+1)  
0328 32 b5 fe			ld (debug_mark+1),a  
032b 3a 35 03			ld a, (.dmark+2)  
032e 32 b6 fe			ld (debug_mark+2),a  
0331 18 03			jr .pastdmark  
0333 ..			.dmark: db "SGc"  
0336 f1			.pastdmark: pop af  
0337			endm  
# End of macro DMARK
0337					CALLMONITOR 
0337 cd 70 17			call break_point_state  
033a				endm  
# End of macro CALLMONITOR
033a				endif 
033a 60			.getloop:	ld h, b 
033b 2e 00				ld l, 0 
033d c5					push bc 
033e			 
033e 11 df fc				ld de, store_page 
0341				if DEBUG_STORESE 
0341					DMARK "SGr" 
0341 f5				push af  
0342 3a 56 03			ld a, (.dmark)  
0345 32 b4 fe			ld (debug_mark),a  
0348 3a 57 03			ld a, (.dmark+1)  
034b 32 b5 fe			ld (debug_mark+1),a  
034e 3a 58 03			ld a, (.dmark+2)  
0351 32 b6 fe			ld (debug_mark+2),a  
0354 18 03			jr .pastdmark  
0356 ..			.dmark: db "SGr"  
0359 f1			.pastdmark: pop af  
035a			endm  
# End of macro DMARK
035a					CALLMONITOR 
035a cd 70 17			call break_point_state  
035d				endm  
# End of macro CALLMONITOR
035d				endif 
035d cd 2a 09				call storage_read 
0360 cd 1c 0e				call ishlzero 
0363 28 2d				jr z, .gap 
0365					 
0365					; have a file name read. Is it one we want. 
0365			 
0365 2a dd fc				ld hl, (store_tmp1) 
0368 11 e2 fc				ld de, store_page+3   ; file name 
036b			 
036b				if DEBUG_STORESE 
036b					DMARK "SGc" 
036b f5				push af  
036c 3a 80 03			ld a, (.dmark)  
036f 32 b4 fe			ld (debug_mark),a  
0372 3a 81 03			ld a, (.dmark+1)  
0375 32 b5 fe			ld (debug_mark+1),a  
0378 3a 82 03			ld a, (.dmark+2)  
037b 32 b6 fe			ld (debug_mark+2),a  
037e 18 03			jr .pastdmark  
0380 ..			.dmark: db "SGc"  
0383 f1			.pastdmark: pop af  
0384			endm  
# End of macro DMARK
0384					CALLMONITOR 
0384 cd 70 17			call break_point_state  
0387				endm  
# End of macro CALLMONITOR
0387				endif 
0387 cd 89 12				call strcmp 
038a 20 06				jr nz, .gap   ; not this one 
038c			 
038c c1				        pop bc 
038d			 
038d 26 00				ld h, 0 
038f 68					ld l, b 
0390 18 22				jr .getdone 
0392						 
0392			 
0392			 
0392			 
0392			.gap: 
0392				if DEBUG_STORESE 
0392					DMARK "SGg" 
0392 f5				push af  
0393 3a a7 03			ld a, (.dmark)  
0396 32 b4 fe			ld (debug_mark),a  
0399 3a a8 03			ld a, (.dmark+1)  
039c 32 b5 fe			ld (debug_mark+1),a  
039f 3a a9 03			ld a, (.dmark+2)  
03a2 32 b6 fe			ld (debug_mark+2),a  
03a5 18 03			jr .pastdmark  
03a7 ..			.dmark: db "SGg"  
03aa f1			.pastdmark: pop af  
03ab			endm  
# End of macro DMARK
03ab					CALLMONITOR 
03ab cd 70 17			call break_point_state  
03ae				endm  
# End of macro CALLMONITOR
03ae				endif 
03ae			 
03ae c1					pop bc 
03af 10 89				djnz .getloop 
03b1 21 ff 00				ld hl, 255 
03b4			.getdone: 
03b4			 
03b4				if DEBUG_STORESE 
03b4					DMARK "SGe" 
03b4 f5				push af  
03b5 3a c9 03			ld a, (.dmark)  
03b8 32 b4 fe			ld (debug_mark),a  
03bb 3a ca 03			ld a, (.dmark+1)  
03be 32 b5 fe			ld (debug_mark+1),a  
03c1 3a cb 03			ld a, (.dmark+2)  
03c4 32 b6 fe			ld (debug_mark+2),a  
03c7 18 03			jr .pastdmark  
03c9 ..			.dmark: db "SGe"  
03cc f1			.pastdmark: pop af  
03cd			endm  
# End of macro DMARK
03cd					CALLMONITOR 
03cd cd 70 17			call break_point_state  
03d0				endm  
# End of macro CALLMONITOR
03d0				endif 
03d0			 
03d0 c9				ret 
03d1			 
03d1			 
03d1			 
03d1			 
03d1			 
03d1			 
03d1			 
03d1			 
03d1			; Read Block 
03d1			; ---------- 
03d1			; 
03d1			; With current bank 
03d1			;  
03d1			; Get block number to read 
03d1			; Load physical blocks starting at start block into buffer 
03d1			 
03d1			; de points to buffer to use 
03d1			; hl holds logical block number  
03d1			 
03d1			storage_read_block: 
03d1			 
03d1				; TODO bank selection 
03d1			 
03d1				; for each of the physical blocks read it into the buffer 
03d1 06 40			ld b, STORE_BLOCK_PHY 
03d3			 
03d3				if DEBUG_STORESE 
03d3 d5					push de 
03d4				endif 
03d4				 
03d4			.rl1:    
03d4			 
03d4				; read physical block at hl into de 
03d4			        ; increment hl and de to next read position on exit 
03d4			 
03d4 e5				push hl 
03d5 d5				push de	 
03d6 c5				push bc 
03d7			;	if DEBUG_STORESE 
03d7			;		push af 
03d7			;		ld a, 'R' 
03d7			;		ld (debug_mark),a 
03d7			;		pop af 
03d7			;		CALLMONITOR 
03d7			;	endif 
03d7 cd 78 02			call se_readbyte 
03da			;	if DEBUG_STORESE 
03da			;		ld a,(spi_portbyte) 
03da			;		ld l, a 
03da			;		push af 
03da			;		ld a, '1' 
03da			;		ld (debug_mark),a 
03da			;		pop af 
03da			;		CALLMONITOR 
03da			;	endif 
03da c1				pop bc 
03db d1				pop de 
03dc e1				pop hl 
03dd 12				ld (de),a 
03de 23				inc hl 
03df 13				inc de 
03e0			 
03e0			;	if DEBUG_STORESE 
03e0			;		push af 
03e0			;		ld a, 'r' 
03e0			;		ld (debug_mark),a 
03e0			;		pop af 
03e0			;		CALLMONITOR 
03e0			;	endif 
03e0			 
03e0 10 f2			djnz .rl1 
03e2			 
03e2				if DEBUG_STORESE 
03e2					DMARK "SRB" 
03e2 f5				push af  
03e3 3a f7 03			ld a, (.dmark)  
03e6 32 b4 fe			ld (debug_mark),a  
03e9 3a f8 03			ld a, (.dmark+1)  
03ec 32 b5 fe			ld (debug_mark+1),a  
03ef 3a f9 03			ld a, (.dmark+2)  
03f2 32 b6 fe			ld (debug_mark+2),a  
03f5 18 03			jr .pastdmark  
03f7 ..			.dmark: db "SRB"  
03fa f1			.pastdmark: pop af  
03fb			endm  
# End of macro DMARK
03fb d1					pop de 
03fc			; 
03fc			;		push af 
03fc			;		ld a, 'R' 
03fc			;		ld (debug_mark),a 
03fc			;		pop af 
03fc					CALLMONITOR 
03fc cd 70 17			call break_point_state  
03ff				endm  
# End of macro CALLMONITOR
03ff				endif 
03ff c9				ret	 
0400				 
0400			 
0400			; File Size 
0400			; --------- 
0400			; 
0400			;   hl file id 
0400			; 
0400			;  returns in hl the number of blocks 
0400			 
0400			storage_file_size: 
0400 5d				ld e, l 
0401 16 00			ld d, 0 
0403 21 40 00			ld hl, STORE_BLOCK_PHY 
0406					if DEBUG_FORTH_WORDS 
0406						DMARK "SIZ" 
0406 f5				push af  
0407 3a 1b 04			ld a, (.dmark)  
040a 32 b4 fe			ld (debug_mark),a  
040d 3a 1c 04			ld a, (.dmark+1)  
0410 32 b5 fe			ld (debug_mark+1),a  
0413 3a 1d 04			ld a, (.dmark+2)  
0416 32 b6 fe			ld (debug_mark+2),a  
0419 18 03			jr .pastdmark  
041b ..			.dmark: db "SIZ"  
041e f1			.pastdmark: pop af  
041f			endm  
# End of macro DMARK
041f						CALLMONITOR 
041f cd 70 17			call break_point_state  
0422				endm  
# End of macro CALLMONITOR
0422					endif 
0422 cd 04 07			call storage_findnextid 
0425			 
0425 cd 1c 0e			call ishlzero 
0428			;	ld a, l 
0428			;	add h 
0428			;	cp 0 
0428 c8				ret z			; block not found so EOF 
0429			 
0429 11 df fc			ld de, store_page 
042c cd d1 03			call storage_read_block 
042f			 
042f 3a e1 fc			ld a, (store_page+2)	 ; get extent count 
0432 6f				ld l, a 
0433 26 00			ld h, 0 
0435 c9			 	ret 
0436			 
0436			 
0436			; Write Block 
0436			; ----------- 
0436			; 
0436			; With current bank 
0436			;  
0436			; Get block number to write 
0436			; Write physical blocks starting at start block from buffer 
0436			  
0436			storage_write_block: 
0436				; TODO bank selection 
0436			 
0436				; for each of the physical blocks read it into the buffer 
0436 06 40			ld b, STORE_BLOCK_PHY 
0438			 
0438				if DEBUG_STORESE 
0438					DMARK "SWB" 
0438 f5				push af  
0439 3a 4d 04			ld a, (.dmark)  
043c 32 b4 fe			ld (debug_mark),a  
043f 3a 4e 04			ld a, (.dmark+1)  
0442 32 b5 fe			ld (debug_mark+1),a  
0445 3a 4f 04			ld a, (.dmark+2)  
0448 32 b6 fe			ld (debug_mark+2),a  
044b 18 03			jr .pastdmark  
044d ..			.dmark: db "SWB"  
0450 f1			.pastdmark: pop af  
0451			endm  
# End of macro DMARK
0451			 
0451					;push af 
0451					;ld a, 'W' 
0451					;ld (debug_mark),a 
0451					;pop af 
0451					CALLMONITOR 
0451 cd 70 17			call break_point_state  
0454				endm  
# End of macro CALLMONITOR
0454				endif 
0454			 
0454			; might not be working 
0454			;	call se_writepage 
0454			 
0454			;	ret 
0454			; 
0454			 
0454			 
0454			 
0454			.wl1:    
0454			 
0454				; read physical block at hl into de 
0454			        ; increment hl and de to next read position on exit 
0454			 
0454 e5				push hl 
0455 d5				push de	 
0456 c5				push bc 
0457 1a				ld a,(de) 
0458				;if DEBUG_STORESE 
0458			;		push af 
0458			;		ld a, 'W' 
0458			;		ld (debug_mark),a 
0458			;		pop af 
0458			;		CALLMONITOR 
0458			;	endif 
0458 cd d6 01			call se_writebyte 
045b			;	call delay250ms 
045b 00				nop 
045c 00				nop 
045d 00				nop 
045e			;	if DEBUG_STORESE 
045e			;		push af 
045e			;		ld a, 'w' 
045e			;		ld (debug_mark),a 
045e			;		pop af 
045e			;		CALLMONITOR 
045e			;	endif 
045e c1				pop bc 
045f d1				pop de 
0460 e1				pop hl 
0461 23				inc hl 
0462 13				inc de 
0463			 
0463			 
0463 10 ef			djnz .wl1 
0465			 
0465				if DEBUG_STORESE 
0465					DMARK "SW2" 
0465 f5				push af  
0466 3a 7a 04			ld a, (.dmark)  
0469 32 b4 fe			ld (debug_mark),a  
046c 3a 7b 04			ld a, (.dmark+1)  
046f 32 b5 fe			ld (debug_mark+1),a  
0472 3a 7c 04			ld a, (.dmark+2)  
0475 32 b6 fe			ld (debug_mark+2),a  
0478 18 03			jr .pastdmark  
047a ..			.dmark: db "SW2"  
047d f1			.pastdmark: pop af  
047e			endm  
# End of macro DMARK
047e			 
047e					;push af 
047e					;ld a, 'W' 
047e					;ld (debug_mark),a 
047e					;pop af 
047e					CALLMONITOR 
047e cd 70 17			call break_point_state  
0481				endm  
# End of macro CALLMONITOR
0481				endif 
0481 c9				ret	 
0482			 
0482			; Init bank 
0482			; --------- 
0482			; 
0482			; With current bank 
0482			; 
0482			; Setup block 0 config 
0482			;     Set 0 file id counter 
0482			;     Set formatted byte pattern 
0482			;     Zero out bank label 
0482			;      
0482			; For every logical block write 0-1 byte as null 
0482			 
0482			storage_get_block_0: 
0482			 
0482				; TODO check presence 
0482			 
0482				; get block 0 config 
0482			 
0482 21 00 00			ld hl, 0 
0485 11 df fc			ld de, store_page 
0488 cd d1 03			call storage_read_block 
048b			 
048b				if DEBUG_STORESE 
048b					DMARK "SB0" 
048b f5				push af  
048c 3a a0 04			ld a, (.dmark)  
048f 32 b4 fe			ld (debug_mark),a  
0492 3a a1 04			ld a, (.dmark+1)  
0495 32 b5 fe			ld (debug_mark+1),a  
0498 3a a2 04			ld a, (.dmark+2)  
049b 32 b6 fe			ld (debug_mark+2),a  
049e 18 03			jr .pastdmark  
04a0 ..			.dmark: db "SB0"  
04a3 f1			.pastdmark: pop af  
04a4			endm  
# End of macro DMARK
04a4 11 df fc				ld de, store_page 
04a7			;		push af 
04a7			;		ld a, 'i' 
04a7			;		ld (debug_mark),a 
04a7			;		pop af 
04a7					CALLMONITOR 
04a7 cd 70 17			call break_point_state  
04aa				endm  
# End of macro CALLMONITOR
04aa				endif 
04aa			 
04aa				; is this area formatted? 
04aa			 
04aa			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04aa 2a e0 fc			ld hl, (store_page+1) 
04ad 3e 80			ld a,0x80 
04af bd				cp l 
04b0 20 22			jr nz, .ininotformatted 
04b2				; do a double check 
04b2 3e 27			ld a, 0x27 
04b4 bc				cp h 
04b5 20 1d			jr nz, .ininotformatted 
04b7			 
04b7				; formatted then 
04b7			 
04b7				if DEBUG_STORESE 
04b7					DMARK "SB1" 
04b7 f5				push af  
04b8 3a cc 04			ld a, (.dmark)  
04bb 32 b4 fe			ld (debug_mark),a  
04be 3a cd 04			ld a, (.dmark+1)  
04c1 32 b5 fe			ld (debug_mark+1),a  
04c4 3a ce 04			ld a, (.dmark+2)  
04c7 32 b6 fe			ld (debug_mark+2),a  
04ca 18 03			jr .pastdmark  
04cc ..			.dmark: db "SB1"  
04cf f1			.pastdmark: pop af  
04d0			endm  
# End of macro DMARK
04d0					;push af 
04d0					;ld a, 'I' 
04d0					;ld (debug_mark),a 
04d0					;pop af 
04d0					CALLMONITOR 
04d0 cd 70 17			call break_point_state  
04d3				endm  
# End of macro CALLMONITOR
04d3				endif 
04d3 c9				ret 
04d4			 
04d4			.ininotformatted: 
04d4				; bank not formatted so poke various bits to make sure 
04d4			 
04d4				if DEBUG_STORESE 
04d4					DMARK "SB2" 
04d4 f5				push af  
04d5 3a e9 04			ld a, (.dmark)  
04d8 32 b4 fe			ld (debug_mark),a  
04db 3a ea 04			ld a, (.dmark+1)  
04de 32 b5 fe			ld (debug_mark+1),a  
04e1 3a eb 04			ld a, (.dmark+2)  
04e4 32 b6 fe			ld (debug_mark+2),a  
04e7 18 03			jr .pastdmark  
04e9 ..			.dmark: db "SB2"  
04ec f1			.pastdmark: pop af  
04ed			endm  
# End of macro DMARK
04ed					;push af 
04ed					;ld a, 'f' 
04ed					;ld (debug_mark),a 
04ed					;pop af 
04ed					CALLMONITOR 
04ed cd 70 17			call break_point_state  
04f0				endm  
# End of macro CALLMONITOR
04f0				endif 
04f0			 
04f0 cd ff 0a			call storage_clear_page 
04f3			 
04f3 21 df fc			ld hl, store_page 
04f6 3e 00			ld a, 0 
04f8				 
04f8 77				ld (hl),a   ; reset file counter 
04f9			 
04f9 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04fc 22 e0 fc		 	ld (store_page+1), hl	 
04ff			 
04ff				; set default label 
04ff			 
04ff 21 9b 05			ld hl, .defaultbanklabl 
0502 11 e2 fc		 	ld de, store_page+3 
0505 01 0f 00			ld bc, 15 
0508 ed b0			ldir 
050a			 
050a				; Append the current bank id 
050a 21 eb fc			ld hl, store_page+3+9 
050d 3a c4 fc			ld a, (spi_device_id) 
0510 77				ld (hl), a 
0511			 
0511				; save default page 0 
0511			 
0511 21 00 00			ld hl, 0 
0514 11 df fc			ld de, store_page 
0517				if DEBUG_STORESE 
0517					DMARK "SB3" 
0517 f5				push af  
0518 3a 2c 05			ld a, (.dmark)  
051b 32 b4 fe			ld (debug_mark),a  
051e 3a 2d 05			ld a, (.dmark+1)  
0521 32 b5 fe			ld (debug_mark+1),a  
0524 3a 2e 05			ld a, (.dmark+2)  
0527 32 b6 fe			ld (debug_mark+2),a  
052a 18 03			jr .pastdmark  
052c ..			.dmark: db "SB3"  
052f f1			.pastdmark: pop af  
0530			endm  
# End of macro DMARK
0530			;		push af 
0530			;		ld a, 'F' 
0530			;		ld (debug_mark),a 
0530			;		pop af 
0530					CALLMONITOR 
0530 cd 70 17			call break_point_state  
0533				endm  
# End of macro CALLMONITOR
0533				endif 
0533 cd 36 04			call storage_write_block 
0536				if DEBUG_STORESE 
0536					DMARK "SB4" 
0536 f5				push af  
0537 3a 4b 05			ld a, (.dmark)  
053a 32 b4 fe			ld (debug_mark),a  
053d 3a 4c 05			ld a, (.dmark+1)  
0540 32 b5 fe			ld (debug_mark+1),a  
0543 3a 4d 05			ld a, (.dmark+2)  
0546 32 b6 fe			ld (debug_mark+2),a  
0549 18 03			jr .pastdmark  
054b ..			.dmark: db "SB4"  
054e f1			.pastdmark: pop af  
054f			endm  
# End of macro DMARK
054f			;		push af 
054f			;		ld a, '>' 
054f			;		ld (debug_mark),a 
054f			;		pop af 
054f					CALLMONITOR 
054f cd 70 17			call break_point_state  
0552				endm  
# End of macro CALLMONITOR
0552				endif 
0552			 
0552 00				nop 
0553 00				nop 
0554 00				nop 
0555			 
0555				; now set 0 in every page to mark as a free block 
0555			 
0555 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0557 21 40 00			ld hl, STORE_BLOCK_PHY 
055a			 
055a 3e 00		.setmark1:   	ld a,0 
055c e5					push hl 
055d c5					push bc 
055e cd d6 01				call se_writebyte 
0561 3e 0a			ld a, 10 
0563 cd 21 0b			call aDelayInMS 
0566 23				inc hl 
0567 cd d6 01				call se_writebyte 
056a 3e 0a			ld a, 10 
056c cd 21 0b			call aDelayInMS 
056f 2b				dec hl 
0570 c1					pop bc 
0571 e1					pop hl 
0572 3e 40				ld a, STORE_BLOCK_PHY 
0574 cd f3 0d				call addatohl 
0577 10 e1				djnz .setmark1 
0579			 
0579 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
057b 3e 00		.setmark2:   	ld a,0 
057d e5					push hl 
057e c5					push bc 
057f cd d6 01				call se_writebyte 
0582 3e 0a			ld a, 10 
0584 cd 21 0b			call aDelayInMS 
0587 23				inc hl 
0588 cd d6 01				call se_writebyte 
058b 3e 0a			ld a, 10 
058d cd 21 0b			call aDelayInMS 
0590 2b				dec hl 
0591 c1					pop bc 
0592 e1					pop hl 
0593 3e 40				ld a, STORE_BLOCK_PHY 
0595 cd f3 0d				call addatohl 
0598 10 e1				djnz .setmark2 
059a			 
059a					 
059a			 
059a			 
059a c9				ret 
059b			 
059b			 
059b			 
059b			 
059b .. 00		.defaultbanklabl:   db "BankLabel_",0 
05a6			 
05a6			 
05a6			 
05a6			; Label Bank 
05a6			; ---------- 
05a6			; 
05a6			; With current bank 
05a6			; Read block 0 
05a6			; Set label 
05a6			; Write block 0 
05a6			 
05a6			; label str pointer in hl 
05a6			 
05a6			storage_label:     
05a6			 
05a6				if DEBUG_STORESE 
05a6					DMARK "LBL" 
05a6 f5				push af  
05a7 3a bb 05			ld a, (.dmark)  
05aa 32 b4 fe			ld (debug_mark),a  
05ad 3a bc 05			ld a, (.dmark+1)  
05b0 32 b5 fe			ld (debug_mark+1),a  
05b3 3a bd 05			ld a, (.dmark+2)  
05b6 32 b6 fe			ld (debug_mark+2),a  
05b9 18 03			jr .pastdmark  
05bb ..			.dmark: db "LBL"  
05be f1			.pastdmark: pop af  
05bf			endm  
# End of macro DMARK
05bf					CALLMONITOR 
05bf cd 70 17			call break_point_state  
05c2				endm  
# End of macro CALLMONITOR
05c2				endif 
05c2			 
05c2 e5				push hl 
05c3			 
05c3 cd 82 04			call storage_get_block_0 
05c6			 
05c6				; set default label 
05c6			 
05c6 e1				pop hl 
05c7			 
05c7 11 e2 fc		 	ld de, store_page+3 
05ca 01 0f 00			ld bc, 15 
05cd				if DEBUG_STORESE 
05cd					DMARK "LB3" 
05cd f5				push af  
05ce 3a e2 05			ld a, (.dmark)  
05d1 32 b4 fe			ld (debug_mark),a  
05d4 3a e3 05			ld a, (.dmark+1)  
05d7 32 b5 fe			ld (debug_mark+1),a  
05da 3a e4 05			ld a, (.dmark+2)  
05dd 32 b6 fe			ld (debug_mark+2),a  
05e0 18 03			jr .pastdmark  
05e2 ..			.dmark: db "LB3"  
05e5 f1			.pastdmark: pop af  
05e6			endm  
# End of macro DMARK
05e6					CALLMONITOR 
05e6 cd 70 17			call break_point_state  
05e9				endm  
# End of macro CALLMONITOR
05e9				endif 
05e9 ed b0			ldir 
05eb				; save default page 0 
05eb			 
05eb 21 00 00			ld hl, 0 
05ee 11 df fc			ld de, store_page 
05f1				if DEBUG_STORESE 
05f1					DMARK "LBW" 
05f1 f5				push af  
05f2 3a 06 06			ld a, (.dmark)  
05f5 32 b4 fe			ld (debug_mark),a  
05f8 3a 07 06			ld a, (.dmark+1)  
05fb 32 b5 fe			ld (debug_mark+1),a  
05fe 3a 08 06			ld a, (.dmark+2)  
0601 32 b6 fe			ld (debug_mark+2),a  
0604 18 03			jr .pastdmark  
0606 ..			.dmark: db "LBW"  
0609 f1			.pastdmark: pop af  
060a			endm  
# End of macro DMARK
060a					CALLMONITOR 
060a cd 70 17			call break_point_state  
060d				endm  
# End of macro CALLMONITOR
060d				endif 
060d cd 36 04			call storage_write_block 
0610			 
0610 c9				ret 
0611			 
0611			 
0611			 
0611			; Read Block 0 - Config 
0611			; --------------------- 
0611			; 
0611			; With current bank 
0611			; Call presence test 
0611			;    If not present format/init bank  
0611			; Read block 0  
0611			;  
0611			 
0611			 
0611			; Dir 
0611			; --- 
0611			; 
0611			; With current bank 
0611			; Load Block 0 Config 
0611			; Get max file id number 
0611			; For each logical block 
0611			;    Read block read byte 2 
0611			;      if first block of file 
0611			;         Display file name 
0611			;         Display type flags for file 
0611			;        
0611			 
0611			; moving to words as this requires stack control 
0611			 
0611			 
0611			; Delete File 
0611			; ----------- 
0611			; 
0611			; With current bank 
0611			; 
0611			; Load Block 0 Config 
0611			; Get max file id number 
0611			; For each logical block 
0611			;    Read block file id 
0611			;      If first block of file and dont have file id 
0611			;         if file to delete 
0611			;         Save file id 
0611			;         Null file id 
0611			;         Write this block back 
0611			;      If file id is one saved 
0611			;         Null file id 
0611			;         Write this block back 
0611			 
0611			 
0611			.se_done: 
0611 e1				pop hl 
0612 c9				ret 
0613			 
0613			storage_erase: 
0613			 
0613				; hl contains the file id 
0613			 
0613 5d				ld e, l 
0614 16 00			ld d, 0 
0616 21 40 00			ld hl, STORE_BLOCK_PHY 
0619					if DEBUG_FORTH_WORDS 
0619						DMARK "ERA" 
0619 f5				push af  
061a 3a 2e 06			ld a, (.dmark)  
061d 32 b4 fe			ld (debug_mark),a  
0620 3a 2f 06			ld a, (.dmark+1)  
0623 32 b5 fe			ld (debug_mark+1),a  
0626 3a 30 06			ld a, (.dmark+2)  
0629 32 b6 fe			ld (debug_mark+2),a  
062c 18 03			jr .pastdmark  
062e ..			.dmark: db "ERA"  
0631 f1			.pastdmark: pop af  
0632			endm  
# End of macro DMARK
0632						CALLMONITOR 
0632 cd 70 17			call break_point_state  
0635				endm  
# End of macro CALLMONITOR
0635					endif 
0635 cd 04 07			call storage_findnextid 
0638 cd 1c 0e			call ishlzero 
063b c8				ret z 
063c			 
063c e5				push hl 
063d			 
063d				; TODO check file not found 
063d			 
063d 11 df fc			ld de, store_page 
0640 cd d1 03			call storage_read_block 
0643			 
0643 cd 1c 0e			call ishlzero 
0646 ca 11 06			jp z,.se_done 
0649			 
0649					if DEBUG_FORTH_WORDS 
0649						DMARK "ER1" 
0649 f5				push af  
064a 3a 5e 06			ld a, (.dmark)  
064d 32 b4 fe			ld (debug_mark),a  
0650 3a 5f 06			ld a, (.dmark+1)  
0653 32 b5 fe			ld (debug_mark+1),a  
0656 3a 60 06			ld a, (.dmark+2)  
0659 32 b6 fe			ld (debug_mark+2),a  
065c 18 03			jr .pastdmark  
065e ..			.dmark: db "ER1"  
0661 f1			.pastdmark: pop af  
0662			endm  
# End of macro DMARK
0662						CALLMONITOR 
0662 cd 70 17			call break_point_state  
0665				endm  
# End of macro CALLMONITOR
0665					endif 
0665 3a df fc			ld a, (store_page)	; get file id 
0668 32 d8 fc			ld (store_tmpid), a 
066b			 
066b 3a e1 fc			ld a, (store_page+2)    ; get count of extends 
066e 32 d7 fc			ld (store_tmpext), a 
0671			 
0671				; wipe file header 
0671			 
0671 e1				pop hl 
0672 3e 00			ld a, 0 
0674 32 df fc			ld (store_page), a 
0677 32 e0 fc			ld (store_page+1),a 
067a 11 df fc			ld de, store_page 
067d					if DEBUG_FORTH_WORDS 
067d						DMARK "ER2" 
067d f5				push af  
067e 3a 92 06			ld a, (.dmark)  
0681 32 b4 fe			ld (debug_mark),a  
0684 3a 93 06			ld a, (.dmark+1)  
0687 32 b5 fe			ld (debug_mark+1),a  
068a 3a 94 06			ld a, (.dmark+2)  
068d 32 b6 fe			ld (debug_mark+2),a  
0690 18 03			jr .pastdmark  
0692 ..			.dmark: db "ER2"  
0695 f1			.pastdmark: pop af  
0696			endm  
# End of macro DMARK
0696						CALLMONITOR 
0696 cd 70 17			call break_point_state  
0699				endm  
# End of macro CALLMONITOR
0699					endif 
0699 cd 36 04			call storage_write_block 
069c			 
069c			 
069c				; wipe file extents 
069c			 
069c 3a d7 fc			ld a, (store_tmpext) 
069f 47				ld b, a 
06a0			 
06a0			.eraext:	  
06a0 c5				push bc 
06a1			 
06a1 21 40 00			ld hl, STORE_BLOCK_PHY 
06a4 3a d8 fc			ld a,(store_tmpid) 
06a7 5f				ld e, a 
06a8 50				ld d, b	 
06a9					if DEBUG_FORTH_WORDS 
06a9						DMARK "ER3" 
06a9 f5				push af  
06aa 3a be 06			ld a, (.dmark)  
06ad 32 b4 fe			ld (debug_mark),a  
06b0 3a bf 06			ld a, (.dmark+1)  
06b3 32 b5 fe			ld (debug_mark+1),a  
06b6 3a c0 06			ld a, (.dmark+2)  
06b9 32 b6 fe			ld (debug_mark+2),a  
06bc 18 03			jr .pastdmark  
06be ..			.dmark: db "ER3"  
06c1 f1			.pastdmark: pop af  
06c2			endm  
# End of macro DMARK
06c2						CALLMONITOR 
06c2 cd 70 17			call break_point_state  
06c5				endm  
# End of macro CALLMONITOR
06c5					endif 
06c5 cd 04 07			call storage_findnextid 
06c8 cd 1c 0e			call ishlzero 
06cb ca 11 06			jp z,.se_done 
06ce			 
06ce e5				push hl 
06cf 11 df fc			ld de, store_page 
06d2 cd d1 03			call storage_read_block 
06d5			 
06d5				; free block	 
06d5			 
06d5 3e 00			ld a, 0 
06d7 32 df fc			ld (store_page), a 
06da 32 e0 fc			ld (store_page+1),a 
06dd 11 df fc			ld de, store_page 
06e0 e1				pop hl 
06e1					if DEBUG_FORTH_WORDS 
06e1						DMARK "ER4" 
06e1 f5				push af  
06e2 3a f6 06			ld a, (.dmark)  
06e5 32 b4 fe			ld (debug_mark),a  
06e8 3a f7 06			ld a, (.dmark+1)  
06eb 32 b5 fe			ld (debug_mark+1),a  
06ee 3a f8 06			ld a, (.dmark+2)  
06f1 32 b6 fe			ld (debug_mark+2),a  
06f4 18 03			jr .pastdmark  
06f6 ..			.dmark: db "ER4"  
06f9 f1			.pastdmark: pop af  
06fa			endm  
# End of macro DMARK
06fa						CALLMONITOR 
06fa cd 70 17			call break_point_state  
06fd				endm  
# End of macro CALLMONITOR
06fd					endif 
06fd cd 36 04			call storage_write_block 
0700			 
0700 c1				pop bc 
0701 10 9d			djnz .eraext 
0703			 
0703 c9				ret 
0704			 
0704			 
0704			; Find Free Block 
0704			; --------------- 
0704			; 
0704			; With current bank 
0704			;  
0704			; From given starting logical block 
0704			;    Read block  
0704			;    If no file id 
0704			;         Return block id 
0704			 
0704			 
0704			; hl starting page number 
0704			; hl contains free page number or zero if no pages free 
0704			; e contains the file id to locate 
0704			; d contains the block number 
0704			 
0704			; TODO change to find file id and use zero for free block 
0704			 
0704			storage_findnextid: 
0704			 
0704				; now locate first 0 page to mark as a free block 
0704			 
0704 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0706			;	ld hl, STORE_BLOCK_PHY 
0706			 
0706					if DEBUG_FORTH_WORDS 
0706					DMARK "FNI" 
0706 f5				push af  
0707 3a 1b 07			ld a, (.dmark)  
070a 32 b4 fe			ld (debug_mark),a  
070d 3a 1c 07			ld a, (.dmark+1)  
0710 32 b5 fe			ld (debug_mark+1),a  
0713 3a 1d 07			ld a, (.dmark+2)  
0716 32 b6 fe			ld (debug_mark+2),a  
0719 18 03			jr .pastdmark  
071b ..			.dmark: db "FNI"  
071e f1			.pastdmark: pop af  
071f			endm  
# End of macro DMARK
071f						CALLMONITOR 
071f cd 70 17			call break_point_state  
0722				endm  
# End of macro CALLMONITOR
0722					endif 
0722			.ff1:   	 
0722 e5					push hl 
0723 c5					push bc 
0724 d5					push de 
0725 cd 78 02				call se_readbyte 
0728 5f					ld e,a 
0729 23					inc hl 
072a cd 78 02				call se_readbyte 
072d 57					ld d, a 
072e e1					pop hl 
072f e5					push hl 
0730 cd 11 0e				call cmp16 
0733 28 49				jr z, .fffound 
0735			 
0735 d1					pop de 
0736 c1					pop bc 
0737 e1					pop hl 
0738			 
0738					; is found? 
0738					;cp e 
0738					;ret z 
0738			 
0738 3e 40				ld a, STORE_BLOCK_PHY 
073a cd f3 0d				call addatohl 
073d 10 e3				djnz .ff1 
073f			 
073f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0741			.ff2:   	 
0741			 
0741 e5					push hl 
0742 c5					push bc 
0743 d5					push de 
0744 cd 78 02				call se_readbyte 
0747 5f					ld e,a 
0748 23					inc hl 
0749 cd 78 02				call se_readbyte 
074c 57					ld d, a 
074d			 
074d e1					pop hl 
074e e5					push hl 
074f cd 11 0e				call cmp16 
0752 28 2a				jr z, .fffound 
0754			 
0754 d1					pop de 
0755 c1					pop bc 
0756 e1					pop hl 
0757					; is found? 
0757					;cp e 
0757					;ret z 
0757			 
0757 3e 40				ld a, STORE_BLOCK_PHY 
0759 cd f3 0d				call addatohl 
075c 10 e3				djnz .ff2 
075e			 
075e			 
075e					if DEBUG_FORTH_WORDS 
075e					DMARK "FN-" 
075e f5				push af  
075f 3a 73 07			ld a, (.dmark)  
0762 32 b4 fe			ld (debug_mark),a  
0765 3a 74 07			ld a, (.dmark+1)  
0768 32 b5 fe			ld (debug_mark+1),a  
076b 3a 75 07			ld a, (.dmark+2)  
076e 32 b6 fe			ld (debug_mark+2),a  
0771 18 03			jr .pastdmark  
0773 ..			.dmark: db "FN-"  
0776 f1			.pastdmark: pop af  
0777			endm  
# End of macro DMARK
0777					;	push af 
0777					;	ld a, 'n' 
0777					;	ld (debug_mark),a 
0777					;	pop af 
0777						CALLMONITOR 
0777 cd 70 17			call break_point_state  
077a				endm  
# End of macro CALLMONITOR
077a					endif 
077a				; no free marks! 
077a 21 00 00				ld hl, 0 
077d c9				ret 
077e			.fffound: 
077e				 
077e			 
077e d1					pop de 
077f c1					pop bc 
0780 e1					pop hl 
0781					if DEBUG_FORTH_WORDS 
0781					DMARK "FNF" 
0781 f5				push af  
0782 3a 96 07			ld a, (.dmark)  
0785 32 b4 fe			ld (debug_mark),a  
0788 3a 97 07			ld a, (.dmark+1)  
078b 32 b5 fe			ld (debug_mark+1),a  
078e 3a 98 07			ld a, (.dmark+2)  
0791 32 b6 fe			ld (debug_mark+2),a  
0794 18 03			jr .pastdmark  
0796 ..			.dmark: db "FNF"  
0799 f1			.pastdmark: pop af  
079a			endm  
# End of macro DMARK
079a					;	push af 
079a					;	ld a, 'n' 
079a					;	ld (debug_mark),a 
079a					;	pop af 
079a						CALLMONITOR 
079a cd 70 17			call break_point_state  
079d				endm  
# End of macro CALLMONITOR
079d					endif 
079d c9				ret 
079e			 
079e			 
079e			 
079e			; Free Space 
079e			; ---------- 
079e			; 
079e			; With current bank 
079e			; 
079e			; Set block count to zero 
079e			; Starting with first logical block 
079e			;      Find free block  
079e			;      If block id given, increment block count 
079e			; 
079e			;  
079e			 
079e			 
079e			; hl contains count of free blocks 
079e			 
079e			storage_freeblocks: 
079e			 
079e				; now locate first 0 page to mark as a free block 
079e			 
079e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07a0 21 40 00			ld hl, STORE_BLOCK_PHY 
07a3 11 00 00			ld de, 0 
07a6			 
07a6			.fb1:   	 
07a6 e5					push hl 
07a7 c5					push bc 
07a8 d5					push de 
07a9 cd 78 02				call se_readbyte 
07ac d1					pop de 
07ad c1					pop bc 
07ae e1					pop hl 
07af			 
07af					; is free? 
07af fe 00				cp 0 
07b1 20 01				jr nz, .ff1cont 
07b3 13					inc de 
07b4			 
07b4			.ff1cont: 
07b4			 
07b4			 
07b4 3e 40				ld a, STORE_BLOCK_PHY 
07b6 cd f3 0d				call addatohl 
07b9 10 eb				djnz .fb1 
07bb			 
07bb 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07bd			.fb2:   	 
07bd e5					push hl 
07be c5					push bc 
07bf d5					push de 
07c0 cd 78 02				call se_readbyte 
07c3 d1					pop de 
07c4 c1					pop bc 
07c5 e1					pop hl 
07c6			 
07c6					; is free? 
07c6 fe 00				cp 0 
07c8 20 01				jr nz, .ff2cont 
07ca 13					inc de 
07cb			 
07cb			.ff2cont: 
07cb			 
07cb 3e 40				ld a, STORE_BLOCK_PHY 
07cd cd f3 0d				call addatohl 
07d0 10 eb				djnz .fb2 
07d2			 
07d2 eb				ex de, hl 
07d3 c9				ret 
07d4			 
07d4			; Get File ID 
07d4			; ----------- 
07d4			; 
07d4			; With current bank 
07d4			;  
07d4			; Load Block 0 Config 
07d4			; Get max file id number 
07d4			; For each logical block 
07d4			;    Read block file id 
07d4			;      If first block of file and dont have file id 
07d4			;         if file get id and exit 
07d4			 
07d4			 
07d4			 
07d4			 
07d4			; Create File 
07d4			; ----------- 
07d4			; 
07d4			; With current bank  
07d4			; Load Block 0 Config 
07d4			; Get max file id number 
07d4			; Increment file id number 
07d4			; Save Config 
07d4			; Find free block 
07d4			; Set buffer with file name and file id 
07d4			; Write buffer to free block  
07d4			 
07d4			 
07d4			; hl point to file name 
07d4			; hl returns file id 
07d4			 
07d4			; file format: 
07d4			; byte 0 - file id 
07d4			; byte 1 - extent number 
07d4			; byte 2-> data 
07d4			 
07d4			; format for extent number 0: 
07d4			; 
07d4			; byte 0 - file id 
07d4			; byte 1 - extent 0 
07d4			; byte 2 - extent count 
07d4			; byte 3 -> file name and meta data 
07d4			 
07d4			 
07d4			storage_create: 
07d4				if DEBUG_STORESE 
07d4					DMARK "SCR" 
07d4 f5				push af  
07d5 3a e9 07			ld a, (.dmark)  
07d8 32 b4 fe			ld (debug_mark),a  
07db 3a ea 07			ld a, (.dmark+1)  
07de 32 b5 fe			ld (debug_mark+1),a  
07e1 3a eb 07			ld a, (.dmark+2)  
07e4 32 b6 fe			ld (debug_mark+2),a  
07e7 18 03			jr .pastdmark  
07e9 ..			.dmark: db "SCR"  
07ec f1			.pastdmark: pop af  
07ed			endm  
# End of macro DMARK
07ed					CALLMONITOR 
07ed cd 70 17			call break_point_state  
07f0				endm  
# End of macro CALLMONITOR
07f0				endif 
07f0			 
07f0 e5				push hl		; save file name pointer 
07f1			 
07f1 cd 82 04			call storage_get_block_0 
07f4			 
07f4 3a df fc			ld a,(store_page)	; get current file id 
07f7 3c				inc a 
07f8 32 df fc			ld (store_page),a 
07fb				 
07fb 32 d8 fc			ld (store_tmpid),a			; save id 
07fe			 
07fe 21 00 00			ld hl, 0 
0801 11 df fc			ld de, store_page 
0804				if DEBUG_STORESE 
0804					DMARK "SCw" 
0804 f5				push af  
0805 3a 19 08			ld a, (.dmark)  
0808 32 b4 fe			ld (debug_mark),a  
080b 3a 1a 08			ld a, (.dmark+1)  
080e 32 b5 fe			ld (debug_mark+1),a  
0811 3a 1b 08			ld a, (.dmark+2)  
0814 32 b6 fe			ld (debug_mark+2),a  
0817 18 03			jr .pastdmark  
0819 ..			.dmark: db "SCw"  
081c f1			.pastdmark: pop af  
081d			endm  
# End of macro DMARK
081d					CALLMONITOR 
081d cd 70 17			call break_point_state  
0820				endm  
# End of macro CALLMONITOR
0820				endif 
0820 cd 36 04			call storage_write_block	 ; save update 
0823			 
0823				if DEBUG_STORESE 
0823 11 df fc				ld de, store_page 
0826					DMARK "SCC" 
0826 f5				push af  
0827 3a 3b 08			ld a, (.dmark)  
082a 32 b4 fe			ld (debug_mark),a  
082d 3a 3c 08			ld a, (.dmark+1)  
0830 32 b5 fe			ld (debug_mark+1),a  
0833 3a 3d 08			ld a, (.dmark+2)  
0836 32 b6 fe			ld (debug_mark+2),a  
0839 18 03			jr .pastdmark  
083b ..			.dmark: db "SCC"  
083e f1			.pastdmark: pop af  
083f			endm  
# End of macro DMARK
083f					CALLMONITOR 
083f cd 70 17			call break_point_state  
0842				endm  
# End of macro CALLMONITOR
0842				endif 
0842				;  
0842				 
0842 21 40 00			ld hl, STORE_BLOCK_PHY 
0845 11 00 00			ld de, 0 
0848 cd 04 07			call storage_findnextid 
084b			 
084b 22 c9 fc			ld (store_tmppageid), hl    ; save page to use  
084e			 
084e				; TODO detect 0 = no spare blocks 
084e			 
084e				; hl now contains the free page to use for the file header page 
084e			 
084e				if DEBUG_STORESE 
084e				DMARK "SCF" 
084e f5				push af  
084f 3a 63 08			ld a, (.dmark)  
0852 32 b4 fe			ld (debug_mark),a  
0855 3a 64 08			ld a, (.dmark+1)  
0858 32 b5 fe			ld (debug_mark+1),a  
085b 3a 65 08			ld a, (.dmark+2)  
085e 32 b6 fe			ld (debug_mark+2),a  
0861 18 03			jr .pastdmark  
0863 ..			.dmark: db "SCF"  
0866 f1			.pastdmark: pop af  
0867			endm  
# End of macro DMARK
0867					CALLMONITOR 
0867 cd 70 17			call break_point_state  
086a				endm  
# End of macro CALLMONITOR
086a				endif 
086a			 
086a 22 c9 fc			ld (store_tmppageid), hl 
086d				 
086d 3a d8 fc			ld a,(store_tmpid)    ; get file id 
0870			;	ld a, (store_filecache)			; save to cache 
0870			 
0870 32 df fc			ld (store_page),a    ; set page id 
0873 3e 00			ld a, 0			 ; extent 0 is file header 
0875 32 e0 fc			ld (store_page+1), a   ; set file extent 
0878			 
0878 32 e1 fc			ld (store_page+2), a   ; extent count for the file 
087b			 
087b			;	inc hl 		; init block 0 of file 
087b			;	inc hl   		; skip file and extent id 
087b			 ;       ld a, 0 
087b			;	ld (hl),a 
087b			;	ld a, (store_filecache+1)  	; save to cache 
087b			 
087b			;	inc hl    ; file name 
087b				 
087b				 
087b 11 e2 fc			ld de, store_page+3    ; get buffer for term string to use as file name 
087e				if DEBUG_STORESE 
087e					DMARK "SCc" 
087e f5				push af  
087f 3a 93 08			ld a, (.dmark)  
0882 32 b4 fe			ld (debug_mark),a  
0885 3a 94 08			ld a, (.dmark+1)  
0888 32 b5 fe			ld (debug_mark+1),a  
088b 3a 95 08			ld a, (.dmark+2)  
088e 32 b6 fe			ld (debug_mark+2),a  
0891 18 03			jr .pastdmark  
0893 ..			.dmark: db "SCc"  
0896 f1			.pastdmark: pop af  
0897			endm  
# End of macro DMARK
0897					CALLMONITOR 
0897 cd 70 17			call break_point_state  
089a				endm  
# End of macro CALLMONITOR
089a				endif 
089a e1				pop hl    ; get zero term string 
089b e5				push hl 
089c 3e 00			ld a, 0 
089e cd 5c 12			call strlent 
08a1 23				inc hl   ; cover zero term 
08a2 06 00			ld b,0 
08a4 4d				ld c,l 
08a5 e1				pop hl 
08a6				;ex de, hl 
08a6				if DEBUG_STORESE 
08a6					DMARK "SCa" 
08a6 f5				push af  
08a7 3a bb 08			ld a, (.dmark)  
08aa 32 b4 fe			ld (debug_mark),a  
08ad 3a bc 08			ld a, (.dmark+1)  
08b0 32 b5 fe			ld (debug_mark+1),a  
08b3 3a bd 08			ld a, (.dmark+2)  
08b6 32 b6 fe			ld (debug_mark+2),a  
08b9 18 03			jr .pastdmark  
08bb ..			.dmark: db "SCa"  
08be f1			.pastdmark: pop af  
08bf			endm  
# End of macro DMARK
08bf					;push af 
08bf					;ld a, 'a' 
08bf					;ld (debug_mark),a 
08bf					;pop af 
08bf					CALLMONITOR 
08bf cd 70 17			call break_point_state  
08c2				endm  
# End of macro CALLMONITOR
08c2				endif 
08c2 ed b0			ldir    ; copy zero term string 
08c4				if DEBUG_STORESE 
08c4					DMARK "SCA" 
08c4 f5				push af  
08c5 3a d9 08			ld a, (.dmark)  
08c8 32 b4 fe			ld (debug_mark),a  
08cb 3a da 08			ld a, (.dmark+1)  
08ce 32 b5 fe			ld (debug_mark+1),a  
08d1 3a db 08			ld a, (.dmark+2)  
08d4 32 b6 fe			ld (debug_mark+2),a  
08d7 18 03			jr .pastdmark  
08d9 ..			.dmark: db "SCA"  
08dc f1			.pastdmark: pop af  
08dd			endm  
# End of macro DMARK
08dd					CALLMONITOR 
08dd cd 70 17			call break_point_state  
08e0				endm  
# End of macro CALLMONITOR
08e0				endif 
08e0			 
08e0				; write file header page 
08e0			 
08e0 2a c9 fc			ld hl,(store_tmppageid) 
08e3 11 df fc			ld de, store_page 
08e6				if DEBUG_STORESE 
08e6					DMARK "SCb" 
08e6 f5				push af  
08e7 3a fb 08			ld a, (.dmark)  
08ea 32 b4 fe			ld (debug_mark),a  
08ed 3a fc 08			ld a, (.dmark+1)  
08f0 32 b5 fe			ld (debug_mark+1),a  
08f3 3a fd 08			ld a, (.dmark+2)  
08f6 32 b6 fe			ld (debug_mark+2),a  
08f9 18 03			jr .pastdmark  
08fb ..			.dmark: db "SCb"  
08fe f1			.pastdmark: pop af  
08ff			endm  
# End of macro DMARK
08ff					;push af 
08ff					;ld a, 'b' 
08ff					;ld (debug_mark),a 
08ff					;pop af 
08ff					CALLMONITOR 
08ff cd 70 17			call break_point_state  
0902				endm  
# End of macro CALLMONITOR
0902				endif 
0902 cd 36 04			call storage_write_block 
0905			 
0905 3a d8 fc			ld a, (store_tmpid) 
0908 6f				ld l, a 
0909 26 00			ld h,0 
090b				if DEBUG_STORESE 
090b					DMARK "SCz" 
090b f5				push af  
090c 3a 20 09			ld a, (.dmark)  
090f 32 b4 fe			ld (debug_mark),a  
0912 3a 21 09			ld a, (.dmark+1)  
0915 32 b5 fe			ld (debug_mark+1),a  
0918 3a 22 09			ld a, (.dmark+2)  
091b 32 b6 fe			ld (debug_mark+2),a  
091e 18 03			jr .pastdmark  
0920 ..			.dmark: db "SCz"  
0923 f1			.pastdmark: pop af  
0924			endm  
# End of macro DMARK
0924					CALLMONITOR 
0924 cd 70 17			call break_point_state  
0927				endm  
# End of macro CALLMONITOR
0927				endif 
0927 c9				ret 
0928				 
0928			 
0928			 
0928			; 
0928			; Read File 
0928			; 
0928			; h - file id to locate 
0928			; l - extent to locate 
0928			; de - pointer to string to read into 
0928			; 
0928			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0928			 
0928			.sr_fail: 
0928 d1				pop de 
0929 c9				ret 
092a			 
092a			storage_read: 
092a d5				push de 
092b			 
092b			; TODO BUG the above push is it popped before the RET Z? 
092b			 
092b			; TODO how to handle multiple part blocks 
092b			 
092b				; locate file extent to read 
092b			 
092b 5c				ld e, h 
092c 55				ld d, l 
092d 21 40 00			ld hl, STORE_BLOCK_PHY 
0930				if DEBUG_STORESE 
0930					DMARK "SRE" 
0930 f5				push af  
0931 3a 45 09			ld a, (.dmark)  
0934 32 b4 fe			ld (debug_mark),a  
0937 3a 46 09			ld a, (.dmark+1)  
093a 32 b5 fe			ld (debug_mark+1),a  
093d 3a 47 09			ld a, (.dmark+2)  
0940 32 b6 fe			ld (debug_mark+2),a  
0943 18 03			jr .pastdmark  
0945 ..			.dmark: db "SRE"  
0948 f1			.pastdmark: pop af  
0949			endm  
# End of macro DMARK
0949					CALLMONITOR 
0949 cd 70 17			call break_point_state  
094c				endm  
# End of macro CALLMONITOR
094c				endif 
094c cd 04 07			call storage_findnextid 
094f			 
094f				if DEBUG_STORESE 
094f					DMARK "SRf" 
094f f5				push af  
0950 3a 64 09			ld a, (.dmark)  
0953 32 b4 fe			ld (debug_mark),a  
0956 3a 65 09			ld a, (.dmark+1)  
0959 32 b5 fe			ld (debug_mark+1),a  
095c 3a 66 09			ld a, (.dmark+2)  
095f 32 b6 fe			ld (debug_mark+2),a  
0962 18 03			jr .pastdmark  
0964 ..			.dmark: db "SRf"  
0967 f1			.pastdmark: pop af  
0968			endm  
# End of macro DMARK
0968					CALLMONITOR 
0968 cd 70 17			call break_point_state  
096b				endm  
# End of macro CALLMONITOR
096b				endif 
096b cd 1c 0e			call ishlzero 
096e			;	ld a, l 
096e			;	add h 
096e			;	cp 0 
096e 28 b8			jr z,.sr_fail			; block not found so EOF 
0970			 
0970				; hl contains page number to load 
0970 d1				pop de   ; get storage 
0971 d5				push de 
0972				if DEBUG_STORESE 
0972					DMARK "SRg" 
0972 f5				push af  
0973 3a 87 09			ld a, (.dmark)  
0976 32 b4 fe			ld (debug_mark),a  
0979 3a 88 09			ld a, (.dmark+1)  
097c 32 b5 fe			ld (debug_mark+1),a  
097f 3a 89 09			ld a, (.dmark+2)  
0982 32 b6 fe			ld (debug_mark+2),a  
0985 18 03			jr .pastdmark  
0987 ..			.dmark: db "SRg"  
098a f1			.pastdmark: pop af  
098b			endm  
# End of macro DMARK
098b					CALLMONITOR 
098b cd 70 17			call break_point_state  
098e				endm  
# End of macro CALLMONITOR
098e				endif 
098e cd d1 03			call storage_read_block 
0991			 
0991			 
0991			; TODO if block has no zeros then need to read next block  
0991			 
0991			 
0991					 
0991 e1				pop hl 		 ; return start of data to show as not EOF 
0992 23				inc hl   ; past file id 
0993 23				inc hl   ; past ext 
0994				if DEBUG_STORESE 
0994					DMARK "SRe" 
0994 f5				push af  
0995 3a a9 09			ld a, (.dmark)  
0998 32 b4 fe			ld (debug_mark),a  
099b 3a aa 09			ld a, (.dmark+1)  
099e 32 b5 fe			ld (debug_mark+1),a  
09a1 3a ab 09			ld a, (.dmark+2)  
09a4 32 b6 fe			ld (debug_mark+2),a  
09a7 18 03			jr .pastdmark  
09a9 ..			.dmark: db "SRe"  
09ac f1			.pastdmark: pop af  
09ad			endm  
# End of macro DMARK
09ad					CALLMONITOR 
09ad cd 70 17			call break_point_state  
09b0				endm  
# End of macro CALLMONITOR
09b0				endif 
09b0 c9					ret 
09b1			 
09b1			 
09b1			 
09b1			; 
09b1			; Append File 
09b1			; 
09b1			; hl - file id to locate 
09b1			; de - pointer to (multi block) string to write 
09b1			 
09b1			.sa_notfound: 
09b1 d1				pop de 
09b2 c9				ret 
09b3			 
09b3			 
09b3			storage_append: 
09b3				; hl -  file id to append to 
09b3				; de - string to append 
09b3			 
09b3 d5				push de 
09b4				 
09b4				if DEBUG_STORESE 
09b4					DMARK "AP1" 
09b4 f5				push af  
09b5 3a c9 09			ld a, (.dmark)  
09b8 32 b4 fe			ld (debug_mark),a  
09bb 3a ca 09			ld a, (.dmark+1)  
09be 32 b5 fe			ld (debug_mark+1),a  
09c1 3a cb 09			ld a, (.dmark+2)  
09c4 32 b6 fe			ld (debug_mark+2),a  
09c7 18 03			jr .pastdmark  
09c9 ..			.dmark: db "AP1"  
09cc f1			.pastdmark: pop af  
09cd			endm  
# End of macro DMARK
09cd					CALLMONITOR 
09cd cd 70 17			call break_point_state  
09d0				endm  
# End of macro CALLMONITOR
09d0				endif 
09d0			 
09d0 7d				ld a, l 
09d1 32 d8 fc			ld (store_tmpid), a 
09d4			 
09d4				; get file header  
09d4			 
09d4 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
09d6 3a d8 fc			ld a, (store_tmpid) 
09d9 5f				ld e, a 
09da			 
09da 21 40 00				ld hl, STORE_BLOCK_PHY 
09dd cd 04 07				call storage_findnextid 
09e0			 
09e0 cd 1c 0e			call ishlzero 
09e3 28 cc			jr z, .sa_notfound 
09e5			 
09e5 22 c9 fc			ld (store_tmppageid), hl 
09e8			 
09e8				; TODO handle file id not found 
09e8			 
09e8				if DEBUG_STORESE 
09e8					DMARK "AP2" 
09e8 f5				push af  
09e9 3a fd 09			ld a, (.dmark)  
09ec 32 b4 fe			ld (debug_mark),a  
09ef 3a fe 09			ld a, (.dmark+1)  
09f2 32 b5 fe			ld (debug_mark+1),a  
09f5 3a ff 09			ld a, (.dmark+2)  
09f8 32 b6 fe			ld (debug_mark+2),a  
09fb 18 03			jr .pastdmark  
09fd ..			.dmark: db "AP2"  
0a00 f1			.pastdmark: pop af  
0a01			endm  
# End of macro DMARK
0a01					CALLMONITOR 
0a01 cd 70 17			call break_point_state  
0a04				endm  
# End of macro CALLMONITOR
0a04				endif 
0a04			 
0a04				; update file extent count 
0a04			 
0a04 11 df fc			ld de, store_page 
0a07			 
0a07 cd d1 03			call storage_read_block 
0a0a			 
0a0a				if DEBUG_STORESE 
0a0a					DMARK "AP3" 
0a0a f5				push af  
0a0b 3a 1f 0a			ld a, (.dmark)  
0a0e 32 b4 fe			ld (debug_mark),a  
0a11 3a 20 0a			ld a, (.dmark+1)  
0a14 32 b5 fe			ld (debug_mark+1),a  
0a17 3a 21 0a			ld a, (.dmark+2)  
0a1a 32 b6 fe			ld (debug_mark+2),a  
0a1d 18 03			jr .pastdmark  
0a1f ..			.dmark: db "AP3"  
0a22 f1			.pastdmark: pop af  
0a23			endm  
# End of macro DMARK
0a23					CALLMONITOR 
0a23 cd 70 17			call break_point_state  
0a26				endm  
# End of macro CALLMONITOR
0a26				endif 
0a26			;	ld (store_tmppageid), hl 
0a26			 
0a26 3a e1 fc			ld a, (store_page+2) 
0a29 3c				inc a 
0a2a 32 e1 fc			ld (store_page+2), a 
0a2d 32 d7 fc			ld (store_tmpext), a 
0a30				 
0a30				if DEBUG_STORESE 
0a30					DMARK "AP3" 
0a30 f5				push af  
0a31 3a 45 0a			ld a, (.dmark)  
0a34 32 b4 fe			ld (debug_mark),a  
0a37 3a 46 0a			ld a, (.dmark+1)  
0a3a 32 b5 fe			ld (debug_mark+1),a  
0a3d 3a 47 0a			ld a, (.dmark+2)  
0a40 32 b6 fe			ld (debug_mark+2),a  
0a43 18 03			jr .pastdmark  
0a45 ..			.dmark: db "AP3"  
0a48 f1			.pastdmark: pop af  
0a49			endm  
# End of macro DMARK
0a49					CALLMONITOR 
0a49 cd 70 17			call break_point_state  
0a4c				endm  
# End of macro CALLMONITOR
0a4c				endif 
0a4c 2a c9 fc			ld hl, (store_tmppageid) 
0a4f 11 df fc			ld de, store_page 
0a52 cd 36 04			call storage_write_block 
0a55			 
0a55				; find free block 
0a55			 
0a55 11 00 00			ld de, 0			 ; file extent to locate 
0a58			 
0a58 21 40 00				ld hl, STORE_BLOCK_PHY 
0a5b cd 04 07				call storage_findnextid 
0a5e cd 1c 0e			call ishlzero 
0a61 ca b1 09			jp z, .sa_notfound 
0a64			 
0a64					; TODO handle no space left 
0a64					 
0a64 22 c9 fc				ld (store_tmppageid), hl 
0a67			 
0a67				if DEBUG_STORESE 
0a67					DMARK "AP4" 
0a67 f5				push af  
0a68 3a 7c 0a			ld a, (.dmark)  
0a6b 32 b4 fe			ld (debug_mark),a  
0a6e 3a 7d 0a			ld a, (.dmark+1)  
0a71 32 b5 fe			ld (debug_mark+1),a  
0a74 3a 7e 0a			ld a, (.dmark+2)  
0a77 32 b6 fe			ld (debug_mark+2),a  
0a7a 18 03			jr .pastdmark  
0a7c ..			.dmark: db "AP4"  
0a7f f1			.pastdmark: pop af  
0a80			endm  
# End of macro DMARK
0a80					CALLMONITOR 
0a80 cd 70 17			call break_point_state  
0a83				endm  
# End of macro CALLMONITOR
0a83				endif 
0a83					; init the buffer with zeros so we can id if the buffer is full or not 
0a83			 
0a83 e5					push hl 
0a84 c5					push bc 
0a85			 
0a85 21 df fc				ld hl, store_page 
0a88 06 40				ld b, STORE_BLOCK_PHY 
0a8a 3e 00				ld a, 0 
0a8c 77			.zeroblock:	ld (hl), a 
0a8d 23					inc hl 
0a8e 10 fc				djnz .zeroblock 
0a90			 
0a90 c1					pop bc 
0a91 e1					pop hl 
0a92			 
0a92					; construct block 
0a92			 
0a92 3a d8 fc				ld a, (store_tmpid) 
0a95 32 df fc				ld (store_page), a   ; file id 
0a98 3a d7 fc				ld a, (store_tmpext)   ; extent for this block 
0a9b 32 e0 fc				ld (store_page+1), a 
0a9e			 
0a9e e1					pop hl    ; get string to write 
0a9f 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0aa1 11 e1 fc				ld de, store_page+2 
0aa4			 
0aa4				if DEBUG_STORESE 
0aa4					DMARK "AP5" 
0aa4 f5				push af  
0aa5 3a b9 0a			ld a, (.dmark)  
0aa8 32 b4 fe			ld (debug_mark),a  
0aab 3a ba 0a			ld a, (.dmark+1)  
0aae 32 b5 fe			ld (debug_mark+1),a  
0ab1 3a bb 0a			ld a, (.dmark+2)  
0ab4 32 b6 fe			ld (debug_mark+2),a  
0ab7 18 03			jr .pastdmark  
0ab9 ..			.dmark: db "AP5"  
0abc f1			.pastdmark: pop af  
0abd			endm  
# End of macro DMARK
0abd					CALLMONITOR 
0abd cd 70 17			call break_point_state  
0ac0				endm  
# End of macro CALLMONITOR
0ac0				endif 
0ac0			 
0ac0			 
0ac0			 
0ac0					; fill buffer with data until end of string or full block 
0ac0			 
0ac0 7e			.appd:		ld a, (hl) 
0ac1 12					ld (de), a 
0ac2 fe 00				cp 0 
0ac4 28 04				jr z, .appdone 
0ac6 23					inc hl 
0ac7 13					inc de 
0ac8 10 f6				djnz .appd 
0aca			 
0aca e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0acb f5					push af   		; save last byte dumped 
0acc			 
0acc			 
0acc 2a c9 fc			ld hl, (store_tmppageid) 
0acf 11 df fc			ld de, store_page 
0ad2				if DEBUG_STORESE 
0ad2					DMARK "AP6" 
0ad2 f5				push af  
0ad3 3a e7 0a			ld a, (.dmark)  
0ad6 32 b4 fe			ld (debug_mark),a  
0ad9 3a e8 0a			ld a, (.dmark+1)  
0adc 32 b5 fe			ld (debug_mark+1),a  
0adf 3a e9 0a			ld a, (.dmark+2)  
0ae2 32 b6 fe			ld (debug_mark+2),a  
0ae5 18 03			jr .pastdmark  
0ae7 ..			.dmark: db "AP6"  
0aea f1			.pastdmark: pop af  
0aeb			endm  
# End of macro DMARK
0aeb					CALLMONITOR 
0aeb cd 70 17			call break_point_state  
0aee				endm  
# End of macro CALLMONITOR
0aee				endif 
0aee cd 36 04				call storage_write_block 
0af1			 
0af1			 
0af1				; was that a full block of data written? 
0af1				; any more to write out? 
0af1			 
0af1				; if yes then set vars and jump to start of function again 
0af1			 
0af1 f1					pop af 
0af2 d1					pop de 
0af3			 
0af3 fe 00				cp 0		 ; no, string was fully written 
0af5 c8					ret z 
0af6			 
0af6					; setup vars for next cycle 
0af6			 
0af6 3a d8 fc				ld a, (store_tmpid) 
0af9 6f					ld l, a 
0afa 26 00				ld h, 0 
0afc			 
0afc c3 b3 09			 	jp storage_append	 ; yes, need to write out some more 
0aff			 
0aff			 
0aff			 
0aff			 
0aff			 
0aff			 
0aff			 
0aff			if DEBUG_STORECF 
0aff			storageput:	 
0aff					ret 
0aff			storageread: 
0aff					ld hl, store_page 
0aff					ld b, 200 
0aff					ld a,0 
0aff			.src:		ld (hl),a 
0aff					inc hl 
0aff					djnz .src 
0aff					 
0aff			 
0aff					ld de, 0 
0aff					ld bc, 1 
0aff					ld hl, store_page 
0aff					call cfRead 
0aff			 
0aff				call cfGetError 
0aff				ld hl,scratch 
0aff				call hexout 
0aff				ld hl, scratch+2 
0aff				ld a, 0 
0aff				ld (hl),a 
0aff				ld de, scratch 
0aff				ld a,display_row_1 
0aff				call str_at_display 
0aff				call update_display 
0aff			 
0aff					ld hl, store_page 
0aff					ld (os_cur_ptr),hl 
0aff			 
0aff					ret 
0aff			endif 
0aff			 
0aff			 
0aff			; Clear out the main buffer store (used to remove junk before writing a new block) 
0aff			 
0aff			storage_clear_page: 
0aff e5				push hl 
0b00 d5				push de 
0b01 c5				push bc 
0b02 21 df fc			ld hl, store_page 
0b05 3e 00			ld a, 0 
0b07 77				ld (hl), a 
0b08			 
0b08 11 e0 fc			ld de, store_page+1 
0b0b 01 40 00			ld bc, STORE_BLOCK_PHY 
0b0e			 
0b0e ed b0			ldir 
0b10				 
0b10 c1				pop bc 
0b11 d1				pop de 
0b12 e1				pop hl 
0b13 c9				ret 
0b14			 
0b14			; eof 
# End of file firmware_storage.asm
0b14			  
0b14			; support routines for above hardware abstraction layer  
0b14			  
0b14			include "firmware_general.asm"        ; general support functions  
0b14			 
0b14			; word look up 
0b14			 
0b14			; in 
0b14			; a is the index 
0b14			; hl is pointer start of array 
0b14			; 
0b14			; returns 
0b14			; hl to the word 
0b14			; 
0b14			 
0b14			table_lookup:  
0b14 d5					push de 
0b15 eb					ex de, hl 
0b16			 
0b16 6f					ld l, a 
0b17 26 00				ld h, 0 
0b19 29					add hl, hl 
0b1a 19					add hl, de 
0b1b 7e					ld a, (hl) 
0b1c 23					inc hl 
0b1d 66					ld h,(hl) 
0b1e 6f					ld l, a 
0b1f			 
0b1f d1					pop de 
0b20 c9					ret 
0b21			 
0b21			; Delay loops 
0b21			 
0b21			 
0b21			 
0b21			aDelayInMS: 
0b21 c5				push bc 
0b22 47				ld b,a 
0b23			msdelay: 
0b23 c5				push bc 
0b24				 
0b24			 
0b24 01 41 00			ld bc,041h 
0b27 cd 3f 0b			call delayloop 
0b2a c1				pop bc 
0b2b 05				dec b 
0b2c 20 f5			jr nz,msdelay 
0b2e			 
0b2e			;if CPU_CLOCK_8MHZ 
0b2e			;msdelay8: 
0b2e			;	push bc 
0b2e			;	 
0b2e			; 
0b2e			;	ld bc,041h 
0b2e			;	call delayloop 
0b2e			;	pop bc 
0b2e			;	dec b 
0b2e			;	jr nz,msdelay8 
0b2e			;endif 
0b2e			 
0b2e			 
0b2e c1				pop bc 
0b2f c9				ret 
0b30			 
0b30			 
0b30			delay250ms: 
0b30				;push de 
0b30 01 00 40			ld bc, 04000h 
0b33 c3 3f 0b			jp delayloop 
0b36			delay500ms: 
0b36				;push de 
0b36 01 00 80			ld bc, 08000h 
0b39 c3 3f 0b			jp delayloop 
0b3c			delay1s: 
0b3c				;push bc 
0b3c			   ; Clobbers A, d and e 
0b3c 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0b3f			delayloop: 
0b3f c5			    push bc 
0b40			 
0b40			if BASE_CPM 
0b40				ld bc, CPM_DELAY_TUNE 
0b40			.cpmloop: 
0b40				push bc 
0b40			 
0b40			endif 
0b40			 
0b40			 
0b40			 
0b40			delayloopi: 
0b40			;	push bc 
0b40			;.dl: 
0b40 cb 47		    bit     0,a    	; 8 
0b42 cb 47		    bit     0,a    	; 8 
0b44 cb 47		    bit     0,a    	; 8 
0b46 e6 ff		    and     255  	; 7 
0b48 0b			    dec     bc      	; 6 
0b49 79			    ld      a,c     	; 4 
0b4a b0			    or      b     	; 4 
0b4b c2 40 0b		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b4e			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b4e				;pop de 
0b4e			;pop bc 
0b4e			 
0b4e			if BASE_CPM 
0b4e				pop bc 
0b4e				 
0b4e			    dec     bc      	; 6 
0b4e			    ld      a,c     	; 4 
0b4e			    or      b     	; 4 
0b4e			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b4e				 
0b4e			 
0b4e			endif 
0b4e			;if CPU_CLOCK_8MHZ 
0b4e			;    pop bc 
0b4e			;    push bc 
0b4e			;.dl8: 
0b4e			;    bit     0,a    	; 8 
0b4e			;    bit     0,a    	; 8 
0b4e			;    bit     0,a    	; 8 
0b4e			;    and     255  	; 7 
0b4e			;    dec     bc      	; 6 
0b4e			;    ld      a,c     	; 4 
0b4e			;    or      b     	; 4 
0b4e			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b4e			;endif 
0b4e			 
0b4e			;if CPU_CLOCK_10MHZ 
0b4e			;    pop bc 
0b4e			;    push bc 
0b4e			;.dl8: 
0b4e			;    bit     0,a    	; 8 
0b4e			;    bit     0,a    	; 8 
0b4e			;    bit     0,a    	; 8 
0b4e			;    and     255  	; 7 
0b4e			;    dec     bc      	; 6 
0b4e			;    ld      a,c     	; 4 
0b4e			;    or      b     	; 4 
0b4e			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b4e			;endif 
0b4e c1			    pop bc 
0b4f			 
0b4f c9				ret 
0b50			 
0b50			 
0b50			 
0b50			; eof 
# End of file firmware_general.asm
0b50			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b50			; display routines that use the physical hardware abstraction layer 
0b50			 
0b50			 
0b50			; information window 
0b50			 
0b50			; pass hl with 1st string to display 
0b50			; pass de with 2nd string to display 
0b50			 
0b50			info_panel: 
0b50 e5				push hl 
0b51			 
0b51 2a 55 fd			ld hl, (display_fb_active) 
0b54 e5				push hl    ; future de destination 
0b55 21 4a fe				ld hl, display_fb0 
0b58 22 55 fd				ld (display_fb_active), hl 
0b5b			 
0b5b			;	call clear_display 
0b5b			 
0b5b				if BASE_CPM 
0b5b				ld a, '.' 
0b5b				else 
0b5b 3e a5			ld a, 165 
0b5d				endif 
0b5d cd c4 0b			call fill_display 
0b60			 
0b60			 
0b60 3e 2d			ld a, display_row_3 + 5 
0b62 cd d2 0b			call str_at_display 
0b65			 
0b65 e1				pop hl 
0b66 d1				pop de 
0b67			 
0b67 e5				push hl 
0b68			 
0b68			 
0b68 3e 19			ld a, display_row_2 + 5 
0b6a cd d2 0b			call str_at_display 
0b6d			 
0b6d			 
0b6d cd e2 0b			call update_display 
0b70 cd 56 1d			call next_page_prompt 
0b73 cd bf 0b			call clear_display 
0b76			 
0b76				 
0b76 21 f9 fd				ld hl, display_fb1 
0b79 22 55 fd				ld (display_fb_active), hl 
0b7c cd e2 0b			call update_display 
0b7f			 
0b7f e1				pop hl 
0b80			 
0b80 c9				ret 
0b81			 
0b81			 
0b81			 
0b81			 
0b81			; TODO windowing? 
0b81			 
0b81			; TODO scroll line up 
0b81			 
0b81			scroll_up: 
0b81			 
0b81 e5				push hl 
0b82 d5				push de 
0b83 c5				push bc 
0b84			 
0b84				; get frame buffer  
0b84			 
0b84 2a 55 fd			ld hl, (display_fb_active) 
0b87 e5				push hl    ; future de destination 
0b88			 
0b88 11 14 00			ld  de, display_cols 
0b8b 19				add hl, de 
0b8c			 
0b8c d1				pop de 
0b8d			 
0b8d				;ex de, hl 
0b8d 01 4f 00			ld bc, display_fb_len -1  
0b90			;if DEBUG_FORTH_WORDS 
0b90			;	DMARK "SCL" 
0b90			;	CALLMONITOR 
0b90			;endif	 
0b90 ed b0			ldir 
0b92			 
0b92				; wipe bottom row 
0b92			 
0b92			 
0b92 2a 55 fd			ld hl, (display_fb_active) 
0b95 11 50 00			ld de, display_cols*display_rows 
0b98 19				add hl, de 
0b99 06 14			ld b, display_cols 
0b9b 3e 20			ld a, ' ' 
0b9d			.scwipe: 
0b9d 77				ld (hl), a 
0b9e 2b				dec hl 
0b9f 10 fc			djnz .scwipe 
0ba1			 
0ba1				;pop hl 
0ba1			 
0ba1 c1				pop bc 
0ba2 d1				pop de 
0ba3 e1				pop hl 
0ba4			 
0ba4 c9				ret 
0ba5			 
0ba5			 
0ba5			;scroll_upo: 
0ba5			;	ld de, display_row_1 
0ba5			 ;	ld hl, display_row_2 
0ba5			;	ld bc, display_cols 
0ba5			;	ldir 
0ba5			;	ld de, display_row_2 
0ba5			 ;	ld hl, display_row_3 
0ba5			;	ld bc, display_cols 
0ba5			;	ldir 
0ba5			;	ld de, display_row_3 
0ba5			 ;	ld hl, display_row_4 
0ba5			;	ld bc, display_cols 
0ba5			;	ldir 
0ba5			 
0ba5			; TODO clear row 4 
0ba5			 
0ba5			;	ret 
0ba5			 
0ba5				 
0ba5			scroll_down: 
0ba5			 
0ba5 e5				push hl 
0ba6 d5				push de 
0ba7 c5				push bc 
0ba8			 
0ba8				; get frame buffer  
0ba8			 
0ba8 2a 55 fd			ld hl, (display_fb_active) 
0bab			 
0bab 11 4f 00			ld de, display_fb_len - 1 
0bae 19				add hl, de 
0baf			 
0baf e5			push hl    ; future de destination 
0bb0			 
0bb0 11 14 00			ld  de, display_cols 
0bb3 ed 52			sbc hl, de 
0bb5			 
0bb5			 
0bb5 d1				pop de 
0bb6			 
0bb6			;	ex de, hl 
0bb6 01 4f 00			ld bc, display_fb_len -1  
0bb9			 
0bb9			 
0bb9				 
0bb9			 
0bb9 ed b0			ldir 
0bbb			 
0bbb				; wipe bottom row 
0bbb			 
0bbb			 
0bbb			;	ld hl, (display_fb_active) 
0bbb			;;	ld de, display_cols*display_rows 
0bbb			;;	add hl, de 
0bbb			;	ld b, display_cols 
0bbb			;	ld a, ' ' 
0bbb			;.scwiped: 
0bbb			;	ld (hl), a 
0bbb			;	dec hl 
0bbb			;	djnz .scwiped 
0bbb			 
0bbb				;pop hl 
0bbb			 
0bbb c1				pop bc 
0bbc d1				pop de 
0bbd e1				pop hl 
0bbe			 
0bbe c9				ret 
0bbf			;scroll_down: 
0bbf			;	ld de, display_row_4 
0bbf			;	ld hl, display_row_3 
0bbf			;	ld bc, display_cols 
0bbf			;	ldir 
0bbf			;	ld de, display_row_3 
0bbf			; 	ld hl, display_row_2 
0bbf			;	ld bc, display_cols 
0bbf			;	ldir 
0bbf			;	ld de, display_row_2 
0bbf			;	ld hl, display_row_1 
0bbf			;	ld bc, display_cols 
0bbf			;	ldir 
0bbf			;;; TODO clear row 1 
0bbf			;	ret 
0bbf			 
0bbf			 
0bbf			 
0bbf			 
0bbf			 
0bbf			; clear active frame buffer 
0bbf			 
0bbf			clear_display: 
0bbf 3e 20			ld a, ' ' 
0bc1 c3 c4 0b			jp fill_display 
0bc4			 
0bc4			; fill active frame buffer with a char in A 
0bc4			 
0bc4			fill_display: 
0bc4 06 50			ld b,display_fb_len 
0bc6 2a 55 fd			ld hl, (display_fb_active) 
0bc9 77			.fd1:	ld (hl),a 
0bca 23				inc hl 
0bcb 10 fc			djnz .fd1 
0bcd 23				inc hl 
0bce 3e 00			ld a,0 
0bd0 77				ld (hl),a 
0bd1			 
0bd1			 
0bd1 c9				ret 
0bd2			; Write string (DE) at pos (A) to active frame buffer 
0bd2			 
0bd2 2a 55 fd		str_at_display:    ld hl,(display_fb_active) 
0bd5 06 00					ld b,0 
0bd7 4f					ld c,a 
0bd8 09					add hl,bc 
0bd9 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bda b7			            OR   A              ;Null terminator? 
0bdb c8			            RET  Z              ;Yes, so finished 
0bdc 77					ld (hl),a 
0bdd 23				inc hl 
0bde 13			            INC  DE             ;Point to next character 
0bdf 18 f8		            JR   .sad1     ;Repeat 
0be1 c9					ret 
0be2			 
0be2			; using current frame buffer write to physical display 
0be2			 
0be2			update_display: 
0be2 e5				push hl 
0be3 2a 55 fd			ld hl, (display_fb_active) 
0be6 cd a7 67			call write_display 
0be9 e1				pop hl 
0bea c9				ret 
0beb			 
0beb			; TODO scrolling 
0beb			 
0beb			 
0beb			; move cursor right one char 
0beb			cursor_right: 
0beb			 
0beb				; TODO shift right 
0beb				; TODO if beyond max col 
0beb				; TODO       cursor_next_line 
0beb			 
0beb c9				ret 
0bec			 
0bec			 
0bec			cursor_next_line: 
0bec				; TODO first char 
0bec				; TODO line down 
0bec				; TODO if past last row 
0bec				; TODO    scroll up 
0bec			 
0bec c9				ret 
0bed			 
0bed			cursor_left: 
0bed				; TODO shift left 
0bed				; TODO if beyond left  
0bed				; TODO     cursor prev line 
0bed				 
0bed c9				ret 
0bee			 
0bee			cursor_prev_line: 
0bee				; TODO last char 
0bee				; TODO line up 
0bee				; TODO if past first row 
0bee				; TODO   scroll down 
0bee			 
0bee c9				ret 
0bef			 
0bef			 
0bef			cout: 
0bef				; A - char 
0bef c9				ret 
0bf0			 
0bf0			 
0bf0			; Display a menu and allow item selection (optional toggle items) 
0bf0			; 
0bf0			; format: 
0bf0			; hl pointer to word array with zero term for items 
0bf0			; e.g.    db item1 
0bf0			;         db .... 
0bf0			;         db 0 
0bf0			; 
0bf0			; a = starting menu item  
0bf0			; 
0bf0			; de = pointer item toggle array   (todo) 
0bf0			; 
0bf0			; returns item selected in a 1-... 
0bf0			; returns 0 if back button pressed 
0bf0			; 
0bf0			; NOTE: Uses system frame buffer to display 
0bf0			; 
0bf0			; LEFT, Q = go back 
0bf0			; RIGHT, SPACE, CR = select 
0bf0			; UP, A - Up 
0bf0			; DOWN, Z - Down 
0bf0			 
0bf0			 
0bf0			 
0bf0			 
0bf0			 
0bf0			menu: 
0bf0			 
0bf0					; keep array pointer 
0bf0			 
0bf0 22 dd fc				ld (store_tmp1), hl 
0bf3 32 db fc				ld (store_tmp2), a 
0bf6			 
0bf6					; check for key bounce 
0bf6			 
0bf6			if BASE_KEV 
0bf6			 
0bf6 cd 5c 69		.mbounce:	call cin 
0bf9 fe 00				cp 0 
0bfb 20 f9				jr nz, .mbounce 
0bfd			endif 
0bfd					; for ease use ex 
0bfd			 
0bfd					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bfd 21 4a fe				ld hl, display_fb0 
0c00 22 55 fd				ld (display_fb_active), hl 
0c03			 
0c03 cd bf 0b		.mloop:		call clear_display 
0c06 cd e2 0b				call update_display 
0c09			 
0c09					; draw selection id '>' at 1 
0c09			 
0c09					; init start of list display 
0c09			 
0c09 3e 05				ld a, 5 
0c0b 32 d9 fc				ld (store_tmp3), a   ; display row count 
0c0e 3a db fc				ld a,( store_tmp2) 
0c11 32 dc fc				ld (store_tmp2+1), a   ; display item count 
0c14			 
0c14					 
0c14			.mitem:	 
0c14			 
0c14			 
0c14 3a dc fc				ld a,(store_tmp2+1) 
0c17 6f					ld l, a 
0c18 26 00				ld h, 0 
0c1a 29					add hl, hl 
0c1b ed 5b dd fc			ld de, (store_tmp1) 
0c1f 19					add hl, de 
0c20 7e					ld a, (hl) 
0c21 23					inc hl 
0c22 66					ld h,(hl) 
0c23 6f					ld l, a 
0c24			 
0c24 cd 1c 0e				call ishlzero 
0c27 28 1a				jr z, .mdone 
0c29			 
0c29 eb					ex de, hl 
0c2a 3a d9 fc				ld a, (store_tmp3) 
0c2d cd d2 0b				call str_at_display 
0c30					 
0c30			 
0c30					; next item 
0c30 3a dc fc				ld a, (store_tmp2+1) 
0c33 3c					inc a 
0c34 32 dc fc				ld (store_tmp2+1), a   ; display item count 
0c37			 
0c37			 		; next row 
0c37			 
0c37 3a d9 fc				ld a, (store_tmp3) 
0c3a c6 14				add display_cols 
0c3c 32 d9 fc				ld (store_tmp3), a 
0c3f			 
0c3f					; at end of screen? 
0c3f			 
0c3f fe 10				cp display_rows*4 
0c41 20 d1				jr nz, .mitem 
0c43			 
0c43			 
0c43			.mdone: 
0c43 cd 1c 0e				call ishlzero 
0c46 28 08				jr z, .nodn 
0c48			 
0c48 3e 3c				ld a, display_row_4 
0c4a 11 c9 0c				ld de, .mdown 
0c4d cd d2 0b				call str_at_display 
0c50			 
0c50					; draw options to fill the screens with active item on line 1 
0c50					; if current option is 2 or more then display ^ in top 
0c50			 
0c50 3a db fc		.nodn:		ld a, (store_tmp2) 
0c53 fe 00				cp 0 
0c55 28 08				jr z, .noup 
0c57			 
0c57 3e 00				ld a, 0 
0c59 11 c7 0c				ld de, .mup 
0c5c cd d2 0b				call str_at_display 
0c5f			 
0c5f 3e 02		.noup:		ld a, 2 
0c61 11 c5 0c				ld de, .msel 
0c64 cd d2 0b				call str_at_display 
0c67			 
0c67					; if current option + 1 is not null then display V in bottom 
0c67					; get key 
0c67 cd e2 0b				call update_display 
0c6a			 
0c6a			 
0c6a					; handle key 
0c6a			 
0c6a cd 4b 69				call cin_wait 
0c6d			 
0c6d fe 05				cp KEY_UP 
0c6f 28 2b				jr z, .mgoup 
0c71 fe 61				cp 'a' 
0c73 28 27				jr z, .mgoup 
0c75 fe 0a				cp KEY_DOWN 
0c77 28 32				jr z, .mgod 
0c79 fe 7a				cp 'z' 
0c7b 28 2e				jr z, .mgod 
0c7d fe 20				cp ' ' 
0c7f 28 34				jr z, .goend 
0c81 fe 0c				cp KEY_RIGHT 
0c83 28 30				jr z, .goend 
0c85 fe 0d				cp KEY_CR 
0c87 28 2c				jr z, .goend 
0c89 fe 71				cp 'q' 
0c8b 28 0b				jr z, .goback 
0c8d			 
0c8d fe 0b				cp KEY_LEFT 
0c8f 28 07				jr z, .goback 
0c91 fe 08				cp KEY_BS 
0c93 28 03				jr z, .goback 
0c95 c3 03 0c				jp .mloop 
0c98			 
0c98			.goback: 
0c98 3e 00			ld a, 0 
0c9a 18 1d			jr .goend2 
0c9c			 
0c9c				; move up one 
0c9c			.mgoup: 
0c9c 3a db fc				ld a, (store_tmp2) 
0c9f fe 00				cp 0 
0ca1 ca 03 0c				jp z, .mloop 
0ca4 3d					dec a 
0ca5 32 db fc				ld (store_tmp2), a 
0ca8 c3 03 0c				jp .mloop 
0cab			 
0cab				; move down one 
0cab			.mgod: 
0cab 3a db fc				ld a, (store_tmp2) 
0cae 3c					inc a 
0caf 32 db fc				ld (store_tmp2), a 
0cb2 c3 03 0c				jp .mloop 
0cb5			 
0cb5			 
0cb5			.goend: 
0cb5					; get selected item number 
0cb5			 
0cb5 3a db fc				ld a, (store_tmp2) 
0cb8 3c					inc a 
0cb9			 
0cb9			.goend2: 
0cb9 f5					push af 
0cba			 
0cba					; restore active fb 
0cba					; TODO BUG assumes fb1 
0cba			 
0cba 21 f9 fd				ld hl, display_fb1 
0cbd 22 55 fd				ld (display_fb_active), hl 
0cc0			 
0cc0					; restore main regs 
0cc0			 
0cc0			 
0cc0 cd e2 0b				call update_display 
0cc3			 
0cc3 f1					pop af 
0cc4			 
0cc4 c9				ret 
0cc5			 
0cc5 .. 00		.msel:   db ">",0 
0cc7 .. 00		.mup:   db "^",0 
0cc9 .. 00		.mdown:   db "v",0 
0ccb			 
0ccb			 
0ccb			; eof 
0ccb			 
# End of file firmware_display.asm
0ccb			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ccb			; random number generators 
0ccb			 
0ccb			 
0ccb			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ccb			 
0ccb			 
0ccb			;-----> Generate a random number 
0ccb			; output a=answer 0<=a<=255 
0ccb			; all registers are preserved except: af 
0ccb			random: 
0ccb e5			        push    hl 
0ccc d5			        push    de 
0ccd 2a 37 fd		        ld      hl,(randData) 
0cd0 ed 5f		        ld      a,r 
0cd2 57			        ld      d,a 
0cd3 5e			        ld      e,(hl) 
0cd4 19			        add     hl,de 
0cd5 85			        add     a,l 
0cd6 ac			        xor     h 
0cd7 22 37 fd		        ld      (randData),hl 
0cda d1			        pop     de 
0cdb e1			        pop     hl 
0cdc c9			        ret 
0cdd			 
0cdd			 
0cdd			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cdd			 
0cdd			 
0cdd			 
0cdd			;------LFSR------ 
0cdd			;James Montelongo 
0cdd			;optimized by Spencer Putt 
0cdd			;out: 
0cdd			; a = 8 bit random number 
0cdd			RandLFSR: 
0cdd 21 3d fd		        ld hl,LFSRSeed+4 
0ce0 5e			        ld e,(hl) 
0ce1 23			        inc hl 
0ce2 56			        ld d,(hl) 
0ce3 23			        inc hl 
0ce4 4e			        ld c,(hl) 
0ce5 23			        inc hl 
0ce6 7e			        ld a,(hl) 
0ce7 47			        ld b,a 
0ce8 cb 13		        rl e  
0cea cb 12			rl d 
0cec cb 11		        rl c  
0cee 17				rla 
0cef cb 13		        rl e  
0cf1 cb 12			rl d 
0cf3 cb 11		        rl c  
0cf5 17				rla 
0cf6 cb 13		        rl e  
0cf8 cb 12			rl d 
0cfa cb 11		        rl c  
0cfc 17				rla 
0cfd 67			        ld h,a 
0cfe cb 13		        rl e  
0d00 cb 12			rl d 
0d02 cb 11		        rl c  
0d04 17				rla 
0d05 a8			        xor b 
0d06 cb 13		        rl e  
0d08 cb 12			rl d 
0d0a ac			        xor h 
0d0b a9			        xor c 
0d0c aa			        xor d 
0d0d 21 3f fd		        ld hl,LFSRSeed+6 
0d10 11 40 fd		        ld de,LFSRSeed+7 
0d13 01 07 00		        ld bc,7 
0d16 ed b8		        lddr 
0d18 12			        ld (de),a 
0d19 c9			        ret 
0d1a			 
0d1a			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d1a			 
0d1a			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d1a			 
0d1a			 
0d1a			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d1a			 
0d1a			prng16: 
0d1a			;Inputs: 
0d1a			;   (seed1) contains a 16-bit seed value 
0d1a			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d1a			;Outputs: 
0d1a			;   HL is the result 
0d1a			;   BC is the result of the LCG, so not that great of quality 
0d1a			;   DE is preserved 
0d1a			;Destroys: 
0d1a			;   AF 
0d1a			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d1a			;160cc 
0d1a			;26 bytes 
0d1a 2a 31 fd		    ld hl,(seed1) 
0d1d 44			    ld b,h 
0d1e 4d			    ld c,l 
0d1f 29			    add hl,hl 
0d20 29			    add hl,hl 
0d21 2c			    inc l 
0d22 09			    add hl,bc 
0d23 22 31 fd		    ld (seed1),hl 
0d26 2a 2f fd		    ld hl,(seed2) 
0d29 29			    add hl,hl 
0d2a 9f			    sbc a,a 
0d2b e6 2d		    and %00101101 
0d2d ad			    xor l 
0d2e 6f			    ld l,a 
0d2f 22 2f fd		    ld (seed2),hl 
0d32 09			    add hl,bc 
0d33 c9			    ret 
0d34			 
0d34			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d34			 
0d34			rand32: 
0d34			;Inputs: 
0d34			;   (seed1_0) holds the lower 16 bits of the first seed 
0d34			;   (seed1_1) holds the upper 16 bits of the first seed 
0d34			;   (seed2_0) holds the lower 16 bits of the second seed 
0d34			;   (seed2_1) holds the upper 16 bits of the second seed 
0d34			;   **NOTE: seed2 must be non-zero 
0d34			;Outputs: 
0d34			;   HL is the result 
0d34			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d34			;Destroys: 
0d34			;   AF 
0d34			;Tested and passes all CAcert tests 
0d34			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d34			;it has a period of 18,446,744,069,414,584,320 
0d34			;roughly 18.4 quintillion. 
0d34			;LFSR taps: 0,2,6,7  = 11000101 
0d34			;291cc 
0d34			;seed1_0=$+1 
0d34			;    ld hl,12345 
0d34			;seed1_1=$+1 
0d34			;    ld de,6789 
0d34			;    ld b,h 
0d34			;    ld c,l 
0d34			;    add hl,hl \ rl e \ rl d 
0d34			;    add hl,hl \ rl e \ rl d 
0d34			;    inc l 
0d34			;    add hl,bc 
0d34			;    ld (seed1_0),hl 
0d34			;    ld hl,(seed1_1) 
0d34			;    adc hl,de 
0d34			;    ld (seed1_1),hl 
0d34			;    ex de,hl 
0d34			;seed2_0=$+1 
0d34			;    ld hl,9876 
0d34			;seed2_1=$+1 
0d34			;    ld bc,54321 
0d34			;    add hl,hl \ rl c \ rl b 
0d34			;    ld (seed2_1),bc 
0d34			;    sbc a,a 
0d34			;    and %11000101 
0d34			;    xor l 
0d34			;    ld l,a 
0d34			;    ld (seed2_0),hl 
0d34			;    ex de,hl 
0d34			;    add hl,bc 
0d34			;    ret 
0d34			; 
0d34			 
0d34			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d34			; 20 bytes, 86 cycles (excluding ret) 
0d34			 
0d34			; returns   hl = pseudorandom number 
0d34			; corrupts   a 
0d34			 
0d34			; generates 16-bit pseudorandom numbers with a period of 65535 
0d34			; using the xorshift method: 
0d34			 
0d34			; hl ^= hl << 7 
0d34			; hl ^= hl >> 9 
0d34			; hl ^= hl << 8 
0d34			 
0d34			; some alternative shift triplets which also perform well are: 
0d34			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d34			 
0d34			;  org 32768 
0d34			 
0d34			xrnd: 
0d34 2a 35 fd		  ld hl,(xrandc)       ; seed must not be 0 
0d37 3e 00		  ld a,0 
0d39 bd			  cp l 
0d3a 20 02		  jr nz, .xrnd1 
0d3c 2e 01		  ld l, 1 
0d3e			.xrnd1: 
0d3e			 
0d3e 7c			  ld a,h 
0d3f 1f			  rra 
0d40 7d			  ld a,l 
0d41 1f			  rra 
0d42 ac			  xor h 
0d43 67			  ld h,a 
0d44 7d			  ld a,l 
0d45 1f			  rra 
0d46 7c			  ld a,h 
0d47 1f			  rra 
0d48 ad			  xor l 
0d49 6f			  ld l,a 
0d4a ac			  xor h 
0d4b 67			  ld h,a 
0d4c			 
0d4c 22 35 fd		  ld (xrandc),hl 
0d4f			 
0d4f c9			  ret 
0d50			;  
0d50			 
0d50			 
0d50			;;;; int maths 
0d50			 
0d50			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d50			; Divide 16-bit values (with 16-bit result) 
0d50			; In: Divide BC by divider DE 
0d50			; Out: BC = result, HL = rest 
0d50			; 
0d50			Div16: 
0d50 21 00 00		    ld hl,0 
0d53 78			    ld a,b 
0d54 06 08		    ld b,8 
0d56			Div16_Loop1: 
0d56 17			    rla 
0d57 ed 6a		    adc hl,hl 
0d59 ed 52		    sbc hl,de 
0d5b 30 01		    jr nc,Div16_NoAdd1 
0d5d 19			    add hl,de 
0d5e			Div16_NoAdd1: 
0d5e 10 f6		    djnz Div16_Loop1 
0d60 17			    rla 
0d61 2f			    cpl 
0d62 47			    ld b,a 
0d63 79			    ld a,c 
0d64 48			    ld c,b 
0d65 06 08		    ld b,8 
0d67			Div16_Loop2: 
0d67 17			    rla 
0d68 ed 6a		    adc hl,hl 
0d6a ed 52		    sbc hl,de 
0d6c 30 01		    jr nc,Div16_NoAdd2 
0d6e 19			    add hl,de 
0d6f			Div16_NoAdd2: 
0d6f 10 f6		    djnz Div16_Loop2 
0d71 17			    rla 
0d72 2f			    cpl 
0d73 41			    ld b,c 
0d74 4f			    ld c,a 
0d75 c9			ret 
0d76			 
0d76			 
0d76			;http://z80-heaven.wikidot.com/math 
0d76			; 
0d76			;Inputs: 
0d76			;     DE and A are factors 
0d76			;Outputs: 
0d76			;     A is not changed 
0d76			;     B is 0 
0d76			;     C is not changed 
0d76			;     DE is not changed 
0d76			;     HL is the product 
0d76			;Time: 
0d76			;     342+6x 
0d76			; 
0d76			Mult16: 
0d76			 
0d76 06 08		     ld b,8          ;7           7 
0d78 21 00 00		     ld hl,0         ;10         10 
0d7b 29			       add hl,hl     ;11*8       88 
0d7c 07			       rlca          ;4*8        32 
0d7d 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d7f 19			         add hl,de   ;--         -- 
0d80 10 f9		       djnz $-5      ;13*7+8     99 
0d82 c9			ret 
0d83			 
0d83			; 
0d83			; Square root of 16-bit value 
0d83			; In:  HL = value 
0d83			; Out:  D = result (rounded down) 
0d83			; 
0d83			;Sqr16: 
0d83			;    ld de,#0040 
0d83			;    ld a,l 
0d83			;    ld l,h 
0d83			;    ld h,d 
0d83			;    or a 
0d83			;    ld b,8 
0d83			;Sqr16_Loop: 
0d83			;    sbc hl,de 
0d83			;    jr nc,Sqr16_Skip 
0d83			;    add hl,de 
0d83			;Sqr16_Skip: 
0d83			;    ccf 
0d83			;    rl d 
0d83			;    add a,a 
0d83			;    adc hl,hl 
0d83			;    add a,a 
0d83			;    adc hl,hl 
0d83			;    djnz Sqr16_Loop 
0d83			;    ret 
0d83			; 
0d83			; 
0d83			; Divide 8-bit values 
0d83			; In: Divide E by divider C 
0d83			; Out: A = result, B = rest 
0d83			; 
0d83			Div8: 
0d83 af			    xor a 
0d84 06 08		    ld b,8 
0d86			Div8_Loop: 
0d86 cb 13		    rl e 
0d88 17			    rla 
0d89 91			    sub c 
0d8a 30 01		    jr nc,Div8_NoAdd 
0d8c 81			    add a,c 
0d8d			Div8_NoAdd: 
0d8d 10 f7		    djnz Div8_Loop 
0d8f 47			    ld b,a 
0d90 7b			    ld a,e 
0d91 17			    rla 
0d92 2f			    cpl 
0d93 c9			    ret 
0d94			 
0d94			; 
0d94			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d94			; In: Multiply A with DE 
0d94			; Out: HL = result 
0d94			; 
0d94			Mult12U: 
0d94 2e 00		    ld l,0 
0d96 87			    add a,a 
0d97 30 01		    jr nc,Mult12U_NoAdd0 
0d99 19			    add hl,de 
0d9a			Mult12U_NoAdd0: 
0d9a 29			    add hl,hl 
0d9b 87			    add a,a 
0d9c 30 01		    jr nc,Mult12U_NoAdd1 
0d9e 19			    add hl,de 
0d9f			Mult12U_NoAdd1: 
0d9f 29			    add hl,hl 
0da0 87			    add a,a 
0da1 30 01		    jr nc,Mult12U_NoAdd2 
0da3 19			    add hl,de 
0da4			Mult12U_NoAdd2: 
0da4 29			    add hl,hl 
0da5 87			    add a,a 
0da6 30 01		    jr nc,Mult12U_NoAdd3 
0da8 19			    add hl,de 
0da9			Mult12U_NoAdd3: 
0da9 29			    add hl,hl 
0daa 87			    add a,a 
0dab 30 01		    jr nc,Mult12U_NoAdd4 
0dad 19			    add hl,de 
0dae			Mult12U_NoAdd4: 
0dae 29			    add hl,hl 
0daf 87			    add a,a 
0db0 30 01		    jr nc,Mult12U_NoAdd5 
0db2 19			    add hl,de 
0db3			Mult12U_NoAdd5: 
0db3 29			    add hl,hl 
0db4 87			    add a,a 
0db5 30 01		    jr nc,Mult12U_NoAdd6 
0db7 19			    add hl,de 
0db8			Mult12U_NoAdd6: 
0db8 29			    add hl,hl 
0db9 87			    add a,a 
0dba d0			    ret nc 
0dbb 19			    add hl,de 
0dbc c9			    ret 
0dbd			 
0dbd			; 
0dbd			; Multiply 8-bit value with a 16-bit value (right rotating) 
0dbd			; In: Multiply A with DE 
0dbd			;      Put lowest value in A for most efficient calculation 
0dbd			; Out: HL = result 
0dbd			; 
0dbd			Mult12R: 
0dbd 21 00 00		    ld hl,0 
0dc0			Mult12R_Loop: 
0dc0 cb 3f		    srl a 
0dc2 30 01		    jr nc,Mult12R_NoAdd 
0dc4 19			    add hl,de 
0dc5			Mult12R_NoAdd: 
0dc5 cb 23		    sla e 
0dc7 cb 12		    rl d 
0dc9 b7			    or a 
0dca c2 c0 0d		    jp nz,Mult12R_Loop 
0dcd c9			    ret 
0dce			 
0dce			; 
0dce			; Multiply 16-bit values (with 32-bit result) 
0dce			; In: Multiply BC with DE 
0dce			; Out: BCHL = result 
0dce			; 
0dce			Mult32: 
0dce 79			    ld a,c 
0dcf 48			    ld c,b 
0dd0 21 00 00		    ld hl,0 
0dd3 06 10		    ld b,16 
0dd5			Mult32_Loop: 
0dd5 29			    add hl,hl 
0dd6 17			    rla 
0dd7 cb 11		    rl c 
0dd9 30 07		    jr nc,Mult32_NoAdd 
0ddb 19			    add hl,de 
0ddc ce 00		    adc a,0 
0dde d2 e2 0d		    jp nc,Mult32_NoAdd 
0de1 0c			    inc c 
0de2			Mult32_NoAdd: 
0de2 10 f1		    djnz Mult32_Loop 
0de4 41			    ld b,c 
0de5 4f			    ld c,a 
0de6 c9			    ret 
0de7			 
0de7			 
0de7			 
0de7			; 
0de7			; Multiply 8-bit values 
0de7			; In:  Multiply H with E 
0de7			; Out: HL = result 
0de7			; 
0de7			Mult8: 
0de7 16 00		    ld d,0 
0de9 6a			    ld l,d 
0dea 06 08		    ld b,8 
0dec			Mult8_Loop: 
0dec 29			    add hl,hl 
0ded 30 01		    jr nc,Mult8_NoAdd 
0def 19			    add hl,de 
0df0			Mult8_NoAdd: 
0df0 10 fa		    djnz Mult8_Loop 
0df2 c9			    ret 
0df3			 
0df3			 
0df3			 
0df3			 
0df3			 
0df3			 
0df3			 
0df3			 
0df3			;;http://z80-heaven.wikidot.com/math 
0df3			;;This divides DE by BC, storing the result in DE, remainder in HL 
0df3			; 
0df3			;DE_Div_BC:          ;1281-2x, x is at most 16 
0df3			;     ld a,16        ;7 
0df3			;     ld hl,0        ;10 
0df3			;     jp $+5         ;10 
0df3			;.DivLoop: 
0df3			;       add hl,bc    ;-- 
0df3			;       dec a        ;64 
0df3			;       jr z,.DivLoopEnd        ;86 
0df3			; 
0df3			;       sla e        ;128 
0df3			;       rl d         ;128 
0df3			;       adc hl,hl    ;240 
0df3			;       sbc hl,bc    ;240 
0df3			;       jr nc,.DivLoop ;23|21 
0df3			;       inc e        ;-- 
0df3			;       jp .DivLoop+1 
0df3			; 
0df3			;.DivLoopEnd: 
0df3			 
0df3			;HL_Div_C: 
0df3			;Inputs: 
0df3			;     HL is the numerator 
0df3			;     C is the denominator 
0df3			;Outputs: 
0df3			;     A is the remainder 
0df3			;     B is 0 
0df3			;     C is not changed 
0df3			;     DE is not changed 
0df3			;     HL is the quotient 
0df3			; 
0df3			;       ld b,16 
0df3			;       xor a 
0df3			;         add hl,hl 
0df3			;         rla 
0df3			;         cp c 
0df3			;         jr c,$+4 
0df3			;           inc l 
0df3			;           sub c 
0df3			;         djnz $-7 
0df3			 
0df3			; https://plutiedev.com/z80-add-8bit-to-16bit 
0df3			 
0df3			addatohl: 
0df3 85			    add   a, l    ; A = A+L 
0df4 6f			    ld    l, a    ; L = A+L 
0df5 8c			    adc   a, h    ; A = A+L+H+carry 
0df6 95			    sub   l       ; A = H+carry 
0df7 67			    ld    h, a    ; H = H+carry 
0df8 c9			ret 
0df9			 
0df9			addatode: 
0df9 83			    add   a, e    ; A = A+L 
0dfa 5f			    ld    e, a    ; L = A+L 
0dfb 8a			    adc   a, d    ; A = A+L+H+carry 
0dfc 93			    sub   e       ; A = H+carry 
0dfd 57			    ld    d, a    ; H = H+carry 
0dfe c9			ret 
0dff			 
0dff			 
0dff			addatobc: 
0dff 81			    add   a, c    ; A = A+L 
0e00 4f			    ld    c, a    ; L = A+L 
0e01 88			    adc   a, b    ; A = A+L+H+carry 
0e02 91			    sub   c       ; A = H+carry 
0e03 47			    ld    b, a    ; H = H+carry 
0e04 c9			ret 
0e05			 
0e05			subafromhl: 
0e05			   ; If A=0 do nothing 
0e05			    ; Otherwise flip A's sign. Since 
0e05			    ; the upper byte becomes -1, also 
0e05			    ; substract 1 from H. 
0e05 ed 44		    neg 
0e07 ca 10 0e		    jp    z, Skip 
0e0a 25			    dec   h 
0e0b			     
0e0b			    ; Now add the low byte as usual 
0e0b			    ; Two's complement takes care of 
0e0b			    ; ensuring the result is correct 
0e0b 85			    add   a, l 
0e0c 6f			    ld    l, a 
0e0d 8c			    adc   a, h 
0e0e 95			    sub   l 
0e0f 67			    ld    h, a 
0e10			Skip: 
0e10 c9				ret 
0e11			 
0e11			 
0e11			; compare hl and de 
0e11			; returns:  
0e11			; if hl = de, z=1, s=0, c0=0 
0e11			; if hl > de, z=0, s=0, c=0 
0e11			; if hl < de, z=0, s=1, c=1 
0e11			cmp16:	 
0e11 b7				or a 
0e12 ed 52			sbc hl,de 
0e14 e0				ret po 
0e15 7c				ld a,h 
0e16 1f				rra 
0e17 ee 40			xor 01000000B 
0e19 37				scf 
0e1a 8f				adc a,a 
0e1b c9				ret 
0e1c			 
0e1c			 
0e1c			; test if hl contains zero   - A is destroyed 
0e1c			 
0e1c			ishlzero:    
0e1c b7				or a     ; reset flags 
0e1d 7c				ld a, h 
0e1e b5				or l        	 
0e1f			 
0e1f c9				ret 
0e20			 
0e20			 
0e20			 
0e20			 
0e20			if FORTH_ENABLE_FLOATMATH 
0e20			;include "float/bbcmath.z80" 
0e20			include "float/lpfpcalc.asm" 
0e20			endif 
0e20			 
0e20			 
0e20			; eof 
0e20			 
# End of file firmware_maths.asm
0e20			include "firmware_strings.asm"   ; string handling  
0e20			 
0e20			 
0e20			; TODO string len 
0e20			; input text string, end on cr with zero term 
0e20			; a offset into frame buffer to start prompt 
0e20			; d is max length 
0e20			; e is display size TODO 
0e20			; c is current cursor position 
0e20			; hl is ptr to where string will be stored 
0e20			 
0e20			 
0e20			; TODO check limit of buffer for new inserts 
0e20			; TODO check insert does not push beyond buffer 
0e20			; TODO scroll in a limited display area 
0e20			; TODO scroll whole screen on page wrap 
0e20			 
0e20			 
0e20			; TODO handle KEY_PREVWORD 
0e20			; TODO handle KEY_NEXTWORD 
0e20			; TODO handle KEY_HOME 
0e20			; TODO handle KEY_END 
0e20			; TODO use LCD cursor? 
0e20			 
0e20 32 ad fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0e23 81					add c 
0e24 32 ab fe				ld (input_at_cursor),a	; save draw pos of cursor 
0e27 22 b0 fe				ld (input_start), hl     ; save ptr to buffer 
0e2a 79					ld a, c 
0e2b cd f3 0d				call addatohl 
0e2e 22 b2 fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0e31 7a					ld a,d 
0e32 32 af fe			        ld (input_size), a       ; save length of input area 
0e35 79					ld a, c 
0e36 32 9e fe				ld (input_cursor),a      ; init cursor start position  
0e39 7b					ld a,e 
0e3a 32 ae fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e3d					 
0e3d					 
0e3d			 
0e3d			;		ld a,(input_ptr) 
0e3d			;		ld (input_under_cursor),a 	; save what is under the cursor 
0e3d			 
0e3d			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e3d					; init cursor shape if not set by the cin routines 
0e3d 21 4d fd				ld hl, cursor_shape 
0e40 3e ff				ld a, 255 
0e42 77					ld (hl), a 
0e43 23					inc hl 
0e44 3e 00				ld a, 0 
0e46 77					ld (hl), a 
0e47			 
0e47 3e 0f				ld a, CUR_BLINK_RATE 
0e49 32 a9 fe				ld (input_cur_flash), a 
0e4c 3e 01				ld a, 1 
0e4e 32 a8 fe				ld (input_cur_onoff),a 
0e51			 
0e51			;	if DEBUG_INPUT 
0e51			;		push af 
0e51			;		ld a, 'I' 
0e51			;		ld (debug_mark),a 
0e51			;		pop af 
0e51			;		CALLMONITOR 
0e51			;	endif 
0e51			.is1:		; main entry loop 
0e51			 
0e51			 
0e51			 
0e51					; pause 1ms 
0e51			 
0e51 3e 01				ld a, 1 
0e53 cd 21 0b				call aDelayInMS 
0e56			 
0e56					; dec flash counter 
0e56 3a a9 fe				ld a, (input_cur_flash) 
0e59 3d					dec a 
0e5a 32 a9 fe				ld (input_cur_flash), a 
0e5d fe 00				cp 0 
0e5f 20 0d				jr nz, .nochgstate 
0e61			 
0e61			 
0e61					; change state 
0e61 3a a8 fe				ld a,(input_cur_onoff) 
0e64 ed 44				neg 
0e66 32 a8 fe				ld (input_cur_onoff),a 
0e69			 
0e69			 
0e69					; reset on change of state 
0e69 3e 0f				ld a, CUR_BLINK_RATE 
0e6b 32 a9 fe				ld (input_cur_flash), a 
0e6e			 
0e6e			.nochgstate: 
0e6e					 
0e6e					 
0e6e			 
0e6e					; display cursor  
0e6e			 
0e6e			;		ld hl, (input_start) 
0e6e			;		ld a, (input_cursor) 
0e6e			;		call addatohl 
0e6e			 
0e6e					; get char under cursor and replace with cursor 
0e6e 2a b2 fe		ld hl, (input_ptr) 
0e71			;		ld a, (hl) 
0e71			;		ld (input_under_cursor),a 
0e71			;		ld a, '_' 
0e71			;		ld (hl), a 
0e71			 
0e71					; display string 
0e71			 
0e71 ed 5b b0 fe			ld de, (input_start) 
0e75 3a ad fe				ld a, (input_at_pos) 
0e78 cd d2 0b				call str_at_display 
0e7b			;	        call update_display 
0e7b			 
0e7b					; find place to put the cursor 
0e7b			;		add h 
0e7b			;		ld l, display_row_1 
0e7b			;		sub l 
0e7b			; (input_at_pos) 
0e7b					;ld c, a 
0e7b			;		ld a, (input_cursor) 
0e7b			;		ld l, (input_at_pos) 
0e7b			;		;ld b, h 
0e7b			;		add l 
0e7b			;		ld (input_at_cursor),a 
0e7b					;ld l,h 
0e7b			 
0e7b			;		ld h, 0 
0e7b			;		ld l,(input_at_pos) 
0e7b			;		ld a, (input_cursor) 
0e7b			;		call addatohl 
0e7b			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0e7b			;		call subafromhl 
0e7b			;		ld a,l 
0e7b			;		ld (input_at_cursor), a 
0e7b			 
0e7b				if DEBUG_INPUT 
0e7b					ld a, (hardware_diag) 
0e7b					cp 0 
0e7b					jr z, .skip_input_diag 
0e7b			 
0e7b					ld a,(input_at_pos) 
0e7b					ld hl, LFSRSeed 
0e7b					call hexout 
0e7b					ld a, (input_cursor) 
0e7b					ld hl, LFSRSeed+2 
0e7b					call hexout 
0e7b					ld a,(input_at_cursor) 
0e7b					ld hl, LFSRSeed+4 
0e7b					call hexout 
0e7b			 
0e7b					ld a,(input_cur_onoff) 
0e7b					ld hl, LFSRSeed+6 
0e7b					call hexout 
0e7b			 
0e7b					ld a,(input_cur_flash) 
0e7b					ld hl, LFSRSeed+8 
0e7b					call hexout 
0e7b			 
0e7b					ld a,(input_len) 
0e7b					ld hl, LFSRSeed+10 
0e7b					call hexout 
0e7b					ld hl, LFSRSeed+12 
0e7b					ld a, 0 
0e7b					ld (hl),a 
0e7b					ld a, display_row_4 
0e7b					ld de, LFSRSeed 
0e7b					call str_at_display 
0e7b					.skip_input_diag: 
0e7b				endif 
0e7b			 
0e7b					; decide on if we are showing the cursor this time round 
0e7b			 
0e7b 3a a8 fe				ld a, (input_cur_onoff) 
0e7e fe ff				cp 255 
0e80 28 13				jr z, .skipcur 
0e82			 
0e82			 
0e82 3a ab fe				ld a,(input_at_cursor) 
0e85 11 4d fd				ld de, cursor_shape 
0e88 cd d2 0b				call str_at_display 
0e8b			 
0e8b					; save length of current input string 
0e8b 2a b0 fe				ld hl, (input_start) 
0e8e cd 51 12				call strlenz 
0e91 7d					ld a,l 
0e92 32 a3 fe				ld (input_len),a 
0e95			 
0e95			.skipcur: 
0e95			 
0e95 cd e2 0b			        call update_display 
0e98					 
0e98			 
0e98			 
0e98					; wait 
0e98				 
0e98					; TODO loop without wait to flash the cursor and char under cursor	 
0e98 cd 5c 69				call cin    ; _wait 
0e9b			 
0e9b fe 00				cp 0 
0e9d ca 51 0e				jp z, .is1 
0ea0			 
0ea0					; get ptr to char to input into 
0ea0			 
0ea0 4f					ld c,a 
0ea1 2a b0 fe				ld hl, (input_start) 
0ea4 3a 9e fe				ld a, (input_cursor) 
0ea7 cd f3 0d				call addatohl 
0eaa 22 b2 fe				ld (input_ptr), hl 
0ead 79					ld a,c 
0eae			 
0eae					; replace char under cursor 
0eae			 
0eae			;		ld hl, (input_ptr) 
0eae			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0eae			;		ld (hl), a 
0eae			 
0eae			;	if DEBUG_INPUT 
0eae			;		push af 
0eae			;		ld a, 'i' 
0eae			;		ld (debug_mark),a 
0eae			;		pop af 
0eae			;		CALLMONITOR 
0eae			;	endif 
0eae fe 0e				cp KEY_HOME 
0eb0 20 0e				jr nz, .iske 
0eb2			 
0eb2 3a ad fe				ld a, (input_at_pos) 
0eb5 32 ab fe				ld (input_at_cursor),a 
0eb8 3e 00				ld a, 0 
0eba 32 9e fe				ld (input_cursor), a 
0ebd c3 51 0e				jp .is1 
0ec0					 
0ec0 fe 0f		.iske:		cp KEY_END 
0ec2 20 03				jr nz, .isknw 
0ec4 c3 51 0e				jp .is1 
0ec7			 
0ec7 fe 06		.isknw:		cp KEY_NEXTWORD 
0ec9 20 1b				jr nz, .iskpw 
0ecb			 
0ecb 2a b2 fe		.isknwm:	ld hl, (input_ptr) 
0ece 7e					ld a,(hl)	 
0ecf fe 00				cp 0 
0ed1 ca 51 0e				jp z, .is1    ; end of string 
0ed4 fe 20				cp ' ' 
0ed6 ca 51 0e				jp z, .is1    ; end of word 
0ed9 23					inc hl 
0eda 22 b2 fe				ld (input_ptr), hl 
0edd 3a ab fe				ld a, (input_at_cursor) 
0ee0 3c					inc a 
0ee1 32 ab fe				ld (input_at_cursor), a 
0ee4 18 e5				jr .isknwm 
0ee6			 
0ee6 fe 07		.iskpw:		cp KEY_PREVWORD 
0ee8 20 1b				jr nz, .iskl 
0eea			.iskpwm:	 
0eea 2a b2 fe				ld hl, (input_ptr) 
0eed 7e					ld a,(hl)	 
0eee fe 00				cp 0  
0ef0 ca 51 0e				jp z, .is1    ; end of string 
0ef3 fe 20				cp ' ' 
0ef5 ca 51 0e				jp z, .is1    ; end of word 
0ef8 2b					dec hl 
0ef9 22 b2 fe				ld (input_ptr), hl 
0efc 3a ab fe				ld a, (input_at_cursor) 
0eff 3d					dec a 
0f00 32 ab fe				ld (input_at_cursor), a 
0f03 18 e5				jr .iskpwm 
0f05			 
0f05			 
0f05 fe 0b		.iskl:		cp KEY_LEFT 
0f07 20 27				jr nz, .isk1 
0f09			 
0f09 3a 9e fe				ld a, (input_cursor) 
0f0c			 
0f0c fe 00				cp 0 
0f0e ca 51 0e				jp z, .is1 		; at start of line to ignore  
0f11			 
0f11 3d					dec  a 		; TODO check underflow 
0f12 32 9e fe				ld (input_cursor), a 
0f15			 
0f15 2a b2 fe				ld hl, (input_ptr) 
0f18 2b					dec hl 
0f19 22 b2 fe				ld (input_ptr), hl 
0f1c					 
0f1c 3a ab fe				ld a, (input_at_cursor) 
0f1f 3d					dec a 
0f20 32 ab fe				ld (input_at_cursor), a 
0f23			 
0f23 3e 01				ld a, 1		; show cursor moving 
0f25 32 a8 fe				ld (input_cur_onoff),a 
0f28 3e 0f				ld a, CUR_BLINK_RATE 
0f2a 32 a9 fe				ld (input_cur_flash), a 
0f2d			 
0f2d c3 51 0e				jp .is1 
0f30			 
0f30 fe 0c		.isk1:		cp KEY_RIGHT 
0f32 20 2a				jr nz, .isk2 
0f34			 
0f34 3a a3 fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0f37 5f					ld e,a 
0f38 3a 9e fe				ld a, (input_cursor) 
0f3b bb					cp e 
0f3c ca 51 0e				jp z, .is1		; at the end of string so dont go right 
0f3f			 
0f3f 3c					inc  a 		; TODO check overflow 
0f40 32 9e fe				ld (input_cursor), a 
0f43			 
0f43 3a ab fe				ld a, (input_at_cursor) 
0f46 3c					inc a 
0f47 32 ab fe				ld (input_at_cursor), a 
0f4a			 
0f4a 2a b2 fe				ld hl, (input_ptr) 
0f4d 23					inc hl 
0f4e 22 b2 fe				ld (input_ptr), hl 
0f51			 
0f51 3e 01				ld a, 1		; show cursor moving 
0f53 32 a8 fe				ld (input_cur_onoff),a 
0f56 3e 0f				ld a, CUR_BLINK_RATE 
0f58 32 a9 fe				ld (input_cur_flash), a 
0f5b			 
0f5b c3 51 0e				jp .is1 
0f5e			 
0f5e fe 05		.isk2:		cp KEY_UP 
0f60			 
0f60 20 26				jr nz, .isk3 
0f62			 
0f62					; swap last command with the current on 
0f62			 
0f62					; move cursor to start of string 
0f62 2a b0 fe				ld hl, (input_start) 
0f65 22 b2 fe				ld (input_ptr), hl 
0f68			 
0f68 3a ad fe				ld a, (input_at_pos) 
0f6b 32 ab fe				ld (input_at_cursor), a 
0f6e			 
0f6e 3e 00				ld a, 0 
0f70 32 9e fe				ld (input_cursor), a 
0f73					 
0f73					; swap input and last command buffers 
0f73			 
0f73 21 81 f7				ld hl, os_cli_cmd 
0f76 11 80 f8				ld de, os_last_cmd 
0f79 06 ff				ld b, 255 
0f7b 7e			.swap1:		ld a, (hl) 
0f7c 4f					ld c,a 
0f7d 1a					ld a, (de) 
0f7e 77					ld (hl), a 
0f7f 79					ld a,c 
0f80 12					ld (de),a 
0f81 23					inc hl 
0f82 13					inc de 
0f83 10 f6				djnz .swap1 
0f85			 
0f85			 
0f85			 
0f85			 
0f85			 
0f85 c3 51 0e				jp .is1 
0f88			 
0f88 fe 08		.isk3:		cp KEY_BS 
0f8a 20 3c				jr nz, .isk4 
0f8c			 
0f8c 3a 9e fe				ld a, (input_cursor) 
0f8f			 
0f8f fe 00				cp 0 
0f91 ca 51 0e				jp z, .is1 		; at start of line to ignore  
0f94			 
0f94 3d					dec  a 		; TODO check underflow 
0f95 32 9e fe				ld (input_cursor), a 
0f98			 
0f98					; hl is source 
0f98					; de needs to be source - 1 
0f98			 
0f98			;		ld a, 0 
0f98			;		dec hl 
0f98			;		ld (hl), a 
0f98			 
0f98 2a b2 fe				ld hl, (input_ptr) 
0f9b 2b					dec hl 
0f9c 22 b2 fe				ld (input_ptr), hl 
0f9f			 
0f9f					; shift all data 
0f9f			 
0f9f e5					push hl 
0fa0 23					inc hl 
0fa1 d1					pop de 
0fa2 3a a3 fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0fa5 4f					ld c,a 
0fa6 06 00				ld b,0 
0fa8 ed b0				ldir  
0faa			 
0faa			 
0faa			 
0faa			 
0faa 3a ab fe				ld a, (input_at_cursor) 
0fad 3d					dec a 
0fae 32 ab fe				ld (input_at_cursor), a 
0fb1			 
0fb1			 
0fb1 3e 01				ld a, 1		; show cursor moving 
0fb3 32 a8 fe				ld (input_cur_onoff),a 
0fb6 3e 0f				ld a, CUR_BLINK_RATE 
0fb8 32 a9 fe				ld (input_cur_flash), a 
0fbb			 
0fbb					; remove char 
0fbb 3a ab fe				ld a, (input_at_cursor) 
0fbe 3c					inc a 
0fbf 11 49 10				ld de,.iblank 
0fc2 cd d2 0b				call str_at_display 
0fc5			 
0fc5 c3 51 0e				jp .is1 
0fc8			 
0fc8 fe 0d		.isk4:		cp KEY_CR 
0fca 28 6c				jr z, .endinput 
0fcc			 
0fcc					; else add the key press to the end 
0fcc			 
0fcc 4f					ld c, a			; save key pressed 
0fcd			 
0fcd 7e					ld a,(hl)		; get what is currently under char 
0fce			 
0fce fe 00				cp 0			; we are at the end of the string 
0fd0 20 2f				jr nz, .onchar 
0fd2					 
0fd2					; add a char to the end of the string 
0fd2				 
0fd2 71					ld (hl),c 
0fd3 23					inc hl 
0fd4			;		ld a,' ' 
0fd4			;		ld (hl),a 
0fd4			;		inc hl 
0fd4 3e 00				ld a,0 
0fd6 77					ld (hl),a 
0fd7 2b					dec hl 
0fd8			 
0fd8 3a 9e fe				ld a, (input_cursor) 
0fdb 3c					inc a				; TODO check max string length and scroll  
0fdc 32 9e fe				ld (input_cursor), a		; inc cursor pos 
0fdf							 
0fdf 3a ab fe				ld a, (input_at_cursor) 
0fe2 3c					inc a 
0fe3 32 ab fe				ld (input_at_cursor), a 
0fe6			 
0fe6 2a b2 fe				ld hl, (input_ptr) 
0fe9 23					inc hl 
0fea 22 b2 fe				ld (input_ptr), hl 
0fed			 
0fed 2a b2 fe				ld hl, (input_ptr) 
0ff0 23					inc hl 
0ff1 22 b2 fe				ld (input_ptr), hl 
0ff4			;	if DEBUG_INPUT 
0ff4			;		push af 
0ff4			;		ld a, '+' 
0ff4			;		ld (debug_mark),a 
0ff4			;		pop af 
0ff4			;		CALLMONITOR 
0ff4			;	endif 
0ff4 3e 01				ld a, 1		; show cursor moving 
0ff6 32 a8 fe				ld (input_cur_onoff),a 
0ff9 3e 0f				ld a, CUR_BLINK_RATE 
0ffb 32 a9 fe				ld (input_cur_flash), a 
0ffe c3 51 0e				jp .is1 
1001					 
1001			 
1001			 
1001					; if on a char then insert 
1001			.onchar: 
1001			 
1001					; TODO over flow check: make sure insert does not blow out buffer 
1001			 
1001					; need to do some maths to use lddr 
1001			 
1001 e5					push hl   ; save char pos 
1002 c5					push bc 
1003			 
1003 2a b0 fe				ld hl, (input_start) 
1006 3a a3 fe				ld a, (input_len) 
1009 cd f3 0d				call addatohl  		; end of string 
100c 23					inc hl 
100d 23					inc hl		; past zero term 
100e e5					push hl 
100f 23					inc hl 
1010 e5					push hl  
1011			 
1011								; start and end of lddr set, now how much to move? 
1011			 
1011							 
1011 3a 9e fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
1014 47					ld b,a 
1015 3a a3 fe				ld a,(input_len) 
1018 5f					ld e,a 
1019 90					sub b 
101a 3c					inc a		;?? 
101b 3c					inc a		;?? 
101c 3c					inc a		;?? 
101d			 
101d 06 00				ld b,0 
101f 4f					ld c,a 
1020			 
1020				if DEBUG_INPUT 
1020					push af 
1020					ld a, 'i' 
1020					ld (debug_mark),a 
1020					pop af 
1020			;		CALLMONITOR 
1020				endif 
1020 d1					pop de 
1021 e1					pop hl 
1022				if DEBUG_INPUT 
1022					push af 
1022					ld a, 'I' 
1022					ld (debug_mark),a 
1022					pop af 
1022			;		CALLMONITOR 
1022				endif 
1022 ed b8				lddr 
1024				 
1024			 
1024			 
1024					; TODO have a key for insert/overwrite mode???? 
1024 c1					pop bc 
1025 e1					pop hl 
1026 71					ld (hl), c		; otherwise overwrite current char 
1027					 
1027			 
1027			 
1027			 
1027 3a 9e fe				ld a, (input_cursor) 
102a 3c					inc  a 		; TODO check overflow 
102b 32 9e fe				ld (input_cursor), a 
102e			 
102e 3a ab fe				ld a, (input_at_cursor) 
1031 3c					inc a 
1032 32 ab fe				ld (input_at_cursor), a 
1035			 
1035 c3 51 0e				jp .is1 
1038			 
1038			.endinput:	; TODO look for end of string 
1038			 
1038					; add trailing space for end of token 
1038			 
1038 2a b0 fe				ld hl, (input_start) 
103b 3a a3 fe				ld a,(input_len) 
103e cd f3 0d				call addatohl 
1041 3e 20				ld a, ' ' 
1043 77					ld (hl),a 
1044					; TODO eof of parse marker 
1044			 
1044 23					inc hl 
1045 3e 00				ld a, 0 
1047 77					ld (hl),a 
1048			 
1048			 
1048 c9					ret 
1049			 
1049 .. 00		.iblank: db " ",0 
104b			 
104b			 
104b 32 ad fe		input_str_prev:	ld (input_at_pos), a 
104e 22 b0 fe				ld (input_start), hl 
1051 3e 01				ld a,1			; add cursor 
1053 77					ld (hl),a 
1054 23					inc hl 
1055 3e 00				ld a,0 
1057 77					ld (hl),a 
1058 22 b2 fe				ld (input_ptr), hl 
105b 7a					ld a,d 
105c 32 af fe				ld (input_size), a 
105f 3e 00				ld a,0 
1061 32 9e fe				ld (input_cursor),a 
1064			.instr1:	 
1064			 
1064					; TODO do block cursor 
1064					; TODO switch cursor depending on the modifer key 
1064			 
1064					; update cursor shape change on key hold 
1064			 
1064 2a b2 fe				ld hl, (input_ptr) 
1067 2b					dec hl 
1068 3a 4d fd				ld a,(cursor_shape) 
106b 77					ld (hl), a 
106c			 
106c					; display entered text 
106c 3a ad fe				ld a,(input_at_pos) 
106f cd 7a 68		            	CALL fLCD_Pos       ;Position cursor to location in A 
1072 ed 5b b0 fe	            	LD   de, (input_start) 
1076 cd 82 68		            	CALL fLCD_Str       ;Display string pointed to by DE 
1079			 
1079 cd 5c 69				call cin 
107c fe 00				cp 0 
107e 28 e4				jr z, .instr1 
1080			 
1080					; proecess keyboard controls first 
1080			 
1080 2a b2 fe				ld hl,(input_ptr) 
1083			 
1083 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1085 28 5a				jr z, .instrcr 
1087			 
1087 fe 08				cp KEY_BS 	; back space 
1089 20 0f				jr nz, .instr2 
108b					; process back space 
108b			 
108b					; TODO stop back space if at start of string 
108b 2b					dec hl 
108c 2b					dec hl ; to over write cursor 
108d 3a 4d fd				ld a,(cursor_shape) 
1090					;ld a,0 
1090 77					ld (hl),a 
1091 23					inc hl 
1092 3e 20				ld a," " 
1094 77					ld (hl),a 
1095 22 b2 fe				ld (input_ptr),hl 
1098					 
1098			 
1098 18 ca				jr .instr1 
109a			 
109a fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
109c 20 06				jr nz, .instr3 
109e 2b					dec hl 
109f 22 b2 fe				ld (input_ptr),hl 
10a2 18 c0				jr .instr1 
10a4				 
10a4 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
10a6 20 06				jr nz, .instr4 
10a8 23					inc hl 
10a9 22 b2 fe				ld (input_ptr),hl 
10ac 18 b6				jr .instr1 
10ae			 
10ae fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
10b0 20 06				jr nz, .instr5 
10b2 2b					dec hl 
10b3 22 b2 fe				ld (input_ptr),hl 
10b6 18 ac				jr .instr1 
10b8			 
10b8 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
10ba 20 06				jr nz, .instr6 
10bc 2b					dec hl 
10bd 22 b2 fe				ld (input_ptr),hl 
10c0 18 a2				jr .instr1 
10c2 fe 05		.instr6:        cp KEY_UP      ; recall last command 
10c4 20 0b				jr nz, .instrnew 
10c6			 
10c6 21 5a f4			ld hl, scratch 
10c9 11 80 f8			ld de, os_last_cmd 
10cc cd ea 10			call strcpy 
10cf 18 93				jr .instr1 
10d1			 
10d1			 
10d1			.instrnew:	; no special key pressed to see if we have room to store it 
10d1			 
10d1					; TODO do string size test 
10d1			 
10d1 2b					dec hl ; to over write cursor 
10d2 77					ld (hl),a 
10d3 23					inc hl 
10d4 3a 4d fd				ld a,(cursor_shape) 
10d7 77					ld (hl),a 
10d8 23					inc hl 
10d9 3e 00				ld a,0 
10db 77					ld (hl),a 
10dc			 
10dc 22 b2 fe				ld (input_ptr),hl 
10df					 
10df 18 83				jr .instr1 
10e1 2b			.instrcr:	dec hl		; remove cursor 
10e2 3e 20				ld a,' '	; TODO add a trailing space for safety 
10e4 77					ld (hl),a 
10e5 23					inc hl 
10e6 3e 00				ld a,0 
10e8 77					ld (hl),a 
10e9			 
10e9			 
10e9					; if at end of line scroll up    
10e9					; TODO detecting only end of line 4 for scroll up  
10e9			 
10e9					;ld   
10e9			 
10e9 c9					ret 
10ea			 
10ea			 
10ea			; strcpy hl = dest, de source 
10ea			 
10ea 1a			strcpy:   LD   A, (DE)        ;Get character from string 
10eb b7			            OR   A              ;Null terminator? 
10ec c8			            RET  Z              ;Yes, so finished 
10ed 1a					ld a,(de) 
10ee 77					ld (hl),a 
10ef 13			            INC  DE             ;Point to next character 
10f0 23					inc hl 
10f1 18 f7		            JR   strcpy       ;Repeat 
10f3 c9					ret 
10f4			 
10f4			 
10f4			; TODO string_at  
10f4			; pass string which starts with lcd offset address and then null term string 
10f4			 
10f4			; TODO string to dec 
10f4			; TODO string to hex 
10f4			; TODO byte to string hex 
10f4			; TODO byte to string dec 
10f4			 
10f4			 
10f4			 
10f4			; from z80uartmonitor 
10f4			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10f4			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
10f4			; pass hl for where to put the text 
10f4			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10f4 c5			hexout:	PUSH BC 
10f5 f5					PUSH AF 
10f6 47					LD B, A 
10f7					; Upper nybble 
10f7 cb 3f				SRL A 
10f9 cb 3f				SRL A 
10fb cb 3f				SRL A 
10fd cb 3f				SRL A 
10ff cd 0f 11				CALL tohex 
1102 77					ld (hl),a 
1103 23					inc hl	 
1104					 
1104					; Lower nybble 
1104 78					LD A, B 
1105 e6 0f				AND 0FH 
1107 cd 0f 11				CALL tohex 
110a 77					ld (hl),a 
110b 23					inc hl	 
110c					 
110c f1					POP AF 
110d c1					POP BC 
110e c9					RET 
110f					 
110f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
110f			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
110f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
110f			tohex: 
110f e5					PUSH HL 
1110 d5					PUSH DE 
1111 16 00				LD D, 0 
1113 5f					LD E, A 
1114 21 1c 11				LD HL, .DATA 
1117 19					ADD HL, DE 
1118 7e					LD A, (HL) 
1119 d1					POP DE 
111a e1					POP HL 
111b c9					RET 
111c			 
111c			.DATA: 
111c 30					DEFB	30h	; 0 
111d 31					DEFB	31h	; 1 
111e 32					DEFB	32h	; 2 
111f 33					DEFB	33h	; 3 
1120 34					DEFB	34h	; 4 
1121 35					DEFB	35h	; 5 
1122 36					DEFB	36h	; 6 
1123 37					DEFB	37h	; 7 
1124 38					DEFB	38h	; 8 
1125 39					DEFB	39h	; 9 
1126 41					DEFB	41h	; A 
1127 42					DEFB	42h	; B 
1128 43					DEFB	43h	; C 
1129 44					DEFB	44h	; D 
112a 45					DEFB	45h	; E 
112b 46					DEFB	46h	; F 
112c			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
112c			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
112c			;;    subtract $30, if result > 9 then subtract $7 more 
112c			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
112c			atohex: 
112c d6 30				SUB $30 
112e fe 0a				CP 10 
1130 f8					RET M		; If result negative it was 0-9 so we're done 
1131 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1133 c9					RET		 
1134			 
1134			 
1134			 
1134			 
1134			; Get 2 ASCII characters as hex byte from pointer in hl 
1134			 
1134			BYTERD: 
1134 16 00			LD	D,00h		;Set up 
1136 cd 3e 11			CALL	HEXCON		;Get byte and convert to hex 
1139 87				ADD	A,A		;First nibble so 
113a 87				ADD	A,A		;multiply by 16 
113b 87				ADD	A,A		; 
113c 87				ADD	A,A		; 
113d 57				LD	D,A		;Save hi nibble in D 
113e			HEXCON: 
113e 7e				ld a, (hl)		;Get next chr 
113f 23				inc hl 
1140 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1142 fe 0a			CP	00Ah		;Is it 0-9 ? 
1144 38 02			JR	C,NALPHA	;If so miss next bit 
1146 d6 07			SUB	007h		;Else convert alpha 
1148			NALPHA: 
1148 b2				OR	D		;Add hi nibble back 
1149 c9				RET			; 
114a			 
114a			 
114a			; 
114a			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
114a			; Since the routines get_byte and therefore get_nibble are called, only valid 
114a			; characters (0-9a-f) are accepted. 
114a			; 
114a			;get_word        push    af 
114a			;                call    get_byte        ; Get the upper byte 
114a			;                ld      h, a 
114a			;                call    get_byte        ; Get the lower byte 
114a			;                ld      l, a 
114a			;                pop     af 
114a			;                ret 
114a			; 
114a			; Get a byte in hexadecimal notation. The result is returned in A. Since 
114a			; the routine get_nibble is used only valid characters are accepted - the  
114a			; input routine only accepts characters 0-9a-f. 
114a			; 
114a c5			get_byte:        push    bc              ; Save contents of B (and C) 
114b 7e					ld a,(hl) 
114c 23					inc hl 
114d cd 72 11		                call    nibble2val      ; Get upper nibble 
1150 cb 07		                rlc     a 
1152 cb 07		                rlc     a 
1154 cb 07		                rlc     a 
1156 cb 07		                rlc     a 
1158 47			                ld      b, a            ; Save upper four bits 
1159 7e					ld a,(hl) 
115a cd 72 11		                call    nibble2val      ; Get lower nibble 
115d b0			                or      b               ; Combine both nibbles 
115e c1			                pop     bc              ; Restore B (and C) 
115f c9			                ret 
1160			; 
1160			; Get a hexadecimal digit from the serial line. This routine blocks until 
1160			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1160			; to the serial line interface. The lower 4 bits of A contain the value of  
1160			; that particular digit. 
1160			; 
1160			;get_nibble      ld a,(hl)           ; Read a character 
1160			;                call    to_upper        ; Convert to upper case 
1160			;                call    is_hex          ; Was it a hex digit? 
1160			;                jr      nc, get_nibble  ; No, get another character 
1160			 ;               call    nibble2val      ; Convert nibble to value 
1160			 ;               call    print_nibble 
1160			 ;               ret 
1160			; 
1160			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1160			; A valid hexadecimal digit is denoted by a set C flag. 
1160			; 
1160			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1160			;                ret     nc              ; Yes 
1160			;                cp      '0'             ; Less than '0'? 
1160			;                jr      nc, is_hex_1    ; No, continue 
1160			;                ccf                     ; Complement carry (i.e. clear it) 
1160			;                ret 
1160			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1160			;                ret     c               ; Yes 
1160			;                cp      'A'             ; Less than 'A'? 
1160			;                jr      nc, is_hex_2    ; No, continue 
1160			;                ccf                     ; Yes - clear carry and return 
1160			;                ret 
1160			;is_hex_2        scf                     ; Set carry 
1160			;                ret 
1160			; 
1160			; Convert a single character contained in A to upper case: 
1160			; 
1160 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1162 d8			                ret     c 
1163 fe 7b		                cp      'z' + 1         ; > 'z'? 
1165 d0			                ret     nc              ; Nothing to do, either 
1166 e6 5f		                and     $5f             ; Convert to upper case 
1168 c9			                ret 
1169			 
1169			 
1169			to_lower: 
1169			 
1169			   ; if char is in [A-Z] make it lower case 
1169			 
1169			   ; enter : a = char 
1169			   ; exit  : a = lower case char 
1169			   ; uses  : af 
1169			 
1169 fe 41		   cp 'A' 
116b d8			   ret c 
116c			    
116c fe 5b		   cp 'Z'+1 
116e d0			   ret nc 
116f			    
116f f6 20		   or $20 
1171 c9			   ret 
1172			 
1172			; 
1172			; Expects a hexadecimal digit (upper case!) in A and returns the 
1172			; corresponding value in A. 
1172			; 
1172 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1174 38 02		                jr      c, nibble2val_1 ; Yes 
1176 d6 07		                sub     7               ; Adjust for A-F 
1178 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
117a e6 0f		                and     $f              ; Only return lower 4 bits 
117c c9			                ret 
117d			; 
117d			; Print_nibble prints a single hex nibble which is contained in the lower  
117d			; four bits of A: 
117d			; 
117d			;print_nibble    push    af              ; We won't destroy the contents of A 
117d			;                and     $f              ; Just in case... 
117d			;                add     a, '0'             ; If we have a digit we are done here. 
117d			;                cp      '9' + 1         ; Is the result > 9? 
117d			;                jr      c, print_nibble_1 
117d			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
117d			;print_nibble_1  call    putc            ; Print the nibble and 
117d			;                pop     af              ; restore the original value of A 
117d			;                ret 
117d			;; 
117d			;; Send a CR/LF pair: 
117d			; 
117d			;crlf            push    af 
117d			;                ld      a, cr 
117d			;                call    putc 
117d			;                ld      a, lf 
117d			;                call    putc 
117d			;                pop     af 
117d			;                ret 
117d			; 
117d			; Print_word prints the four hex digits of a word to the serial line. The  
117d			; word is expected to be in HL. 
117d			; 
117d			;print_word      push    hl 
117d			;                push    af 
117d			;                ld      a, h 
117d			;                call    print_byte 
117d			;                ld      a, l 
117d			;                call    print_byte 
117d			;                pop     af 
117d			;                pop     hl 
117d			;                ret 
117d			; 
117d			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
117d			; The byte to be printed is expected to be in A. 
117d			; 
117d			;print_byte      push    af              ; Save the contents of the registers 
117d			;                push    bc 
117d			;                ld      b, a 
117d			;                rrca 
117d			;                rrca 
117d			;                rrca 
117d			;                rrca 
117d			;                call    print_nibble    ; Print high nibble 
117d			;                ld      a, b 
117d			;                call    print_nibble    ; Print low nibble 
117d			;                pop     bc              ; Restore original register contents 
117d			;                pop     af 
117d			;                ret 
117d			 
117d			 
117d			 
117d			 
117d			 
117d			fourehexhl:  
117d 7e				ld a,(hl) 
117e cd 2c 11			call atohex 
1181 cb 3f				SRL A 
1183 cb 3f				SRL A 
1185 cb 3f				SRL A 
1187 cb 3f				SRL A 
1189 47				ld b, a 
118a 23				inc hl 
118b 7e				ld a,(hl) 
118c 23				inc hl 
118d cd 2c 11			call atohex 
1190 80				add b 
1191 57				ld d,a 
1192 7e				ld a,(hl) 
1193 cd 2c 11			call atohex 
1196 cb 3f				SRL A 
1198 cb 3f				SRL A 
119a cb 3f				SRL A 
119c cb 3f				SRL A 
119e 47				ld b, a 
119f 23				inc hl 
11a0 7e				ld a,(hl) 
11a1 23				inc hl 
11a2 cd 2c 11			call atohex 
11a5 80				add b 
11a6 5f				ld e, a 
11a7 d5				push de 
11a8 e1				pop hl 
11a9 c9				ret 
11aa			 
11aa			; pass hl. returns z set if the byte at hl is a digit 
11aa			;isdigithl:  
11aa			;	push bc 
11aa			;	ld a,(hl) 
11aa			;	cp ':' 
11aa			;	jr nc, .isdf 		; > 
11aa			;	cp '0' 
11aa			;	jr c, .isdf		; < 
11aa			; 
11aa			;	; TODO find a better way to set z 
11aa			; 
11aa			;	ld b,a 
11aa			;	cp b 
11aa			;	pop bc 
11aa			;	ret 
11aa			; 
11aa			;.isdf:	; not digit so clear z 
11aa			; 
11aa			;	; TODO find a better way to unset z 
11aa			; 
11aa			;	ld b,a 
11aa			;	inc b 
11aa			;	cp b 
11aa			; 
11aa			;	pop bc 
11aa			;	ret 
11aa				 
11aa				 
11aa			 
11aa			 
11aa			; pass hl as the four byte address to load 
11aa			 
11aa			get_word_hl:  
11aa e5				push hl 
11ab cd 4a 11			call get_byte 
11ae				 
11ae 47				ld b, a 
11af			 
11af e1				pop hl 
11b0 23				inc hl 
11b1 23				inc hl 
11b2			 
11b2			; TODO not able to handle a-f  
11b2 7e				ld a,(hl) 
11b3			;	;cp ':' 
11b3			;	cp 'g' 
11b3			;	jr nc, .single_byte_hl 		; > 
11b3			;	cp 'G' 
11b3			;	jr nc, .single_byte_hl 		; > 
11b3			;	cp '0' 
11b3			;	jr c, .single_byte_hl		; < 
11b3			 
11b3				;call isdigithl 
11b3 fe 00			cp 0 
11b5 28 06			jr z, .single_byte_hl 
11b7			 
11b7			.getwhln:   ; hex word so get next byte 
11b7			 
11b7 cd 4a 11			call get_byte 
11ba 6f				ld l, a 
11bb 60				ld h,b 
11bc c9				ret 
11bd 68			.single_byte_hl:   ld l,b 
11be 26 00				ld h,0 
11c0 c9					ret 
11c1			 
11c1			 
11c1			 
11c1			 
11c1 21 f5 1a			ld hl,asc+1 
11c4			;	ld a, (hl) 
11c4			;	call nibble2val 
11c4 cd 4a 11			call get_byte 
11c7			 
11c7			;	call fourehexhl 
11c7 32 8e f4			ld (scratch+52),a 
11ca				 
11ca 21 8c f4			ld hl,scratch+50 
11cd 22 7d f7			ld (os_cur_ptr),hl 
11d0			 
11d0 c9				ret 
11d1			 
11d1			 
11d1			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
11d1			 
11d1			; Decimal Unsigned Version 
11d1			 
11d1			;Number in a to decimal ASCII 
11d1			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
11d1			;Example: display a=56 as "056" 
11d1			;input: a = number 
11d1			;Output: a=0,value of a in the screen 
11d1			;destroys af,bc (don't know about hl and de) 
11d1			DispAToASCII: 
11d1 0e 9c			ld	c,-100 
11d3 cd dd 11			call	.Na1 
11d6 0e f6			ld	c,-10 
11d8 cd dd 11			call	.Na1 
11db 0e ff			ld	c,-1 
11dd 06 2f		.Na1:	ld	b,'0'-1 
11df 04			.Na2:	inc	b 
11e0 81				add	a,c 
11e1 38 fc			jr	c,.Na2 
11e3 91				sub	c		;works as add 100/10/1 
11e4 f5				push af		;safer than ld c,a 
11e5 78				ld	a,b		;char is in b 
11e6			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
11e6 f1				pop af		;safer than ld a,c 
11e7 c9				ret 
11e8			 
11e8			; Decimal Signed Version 
11e8			 
11e8			; DispA 
11e8			; -------------------------------------------------------------- 
11e8			; Converts a signed integer value to a zero-terminated ASCII 
11e8			; string representative of that value (using radix 10). 
11e8			; -------------------------------------------------------------- 
11e8			; INPUTS: 
11e8			;     HL     Value to convert (two's complement integer). 
11e8			;     DE     Base address of string destination. (pointer). 
11e8			; -------------------------------------------------------------- 
11e8			; OUTPUTS: 
11e8			;     None 
11e8			; -------------------------------------------------------------- 
11e8			; REGISTERS/MEMORY DESTROYED 
11e8			; AF HL 
11e8			; -------------------------------------------------------------- 
11e8			 
11e8			;DispHLToASCII: 
11e8			;   push    de 
11e8			;   push    bc 
11e8			; 
11e8			;; Detect sign of HL. 
11e8			;    bit    7, h 
11e8			;    jr     z, ._DoConvert 
11e8			; 
11e8			;; HL is negative. Output '-' to string and negate HL. 
11e8			;    ld     a, '-' 
11e8			;    ld     (de), a 
11e8			;    inc    de 
11e8			; 
11e8			;; Negate HL (using two's complement) 
11e8			;    xor    a 
11e8			;    sub    l 
11e8			;    ld     l, a 
11e8			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
11e8			;    sbc    a, h 
11e8			;    ld     h, a 
11e8			; 
11e8			;; Convert HL to digit characters 
11e8			;._DoConvert: 
11e8			;    ld     b, 0     ; B will count character length of number 
11e8			;-   ld     a, 10 
11e8			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
11e8			;    push   af 
11e8			;    inc    b 
11e8			;    ld     a, h 
11e8			;    or     l 
11e8			;    jr     nz, - 
11e8			; 
11e8			;; Retrieve digits from stack 
11e8			;-   pop    af 
11e8			;    or     $30 
11e8			;    ld     (de), a 
11e8			;    inc    de 
11e8			;    djnz   - 
11e8			; 
11e8			;; Terminate string with NULL 
11e8			;    xor    a 
11e8			;    ld     (de), a 
11e8			; 
11e8			;    pop    bc 
11e8			;    pop    de 
11e8			;    ret 
11e8			 
11e8			;Comments 
11e8			; 
11e8			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
11e8			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
11e8			;    Note that the output string will not be fixed-width. 
11e8			; 
11e8			;Example Usage 
11e8			; 
11e8			;    ld    hl, -1004 
11e8			;    ld    de, OP1 
11e8			;    call  DispA 
11e8			;    ld    hl, OP1 
11e8			;    syscall  PutS 
11e8			 
11e8			 
11e8			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11e8			 
11e8			 
11e8			;Converts an ASCII string to an unsigned 16-bit integer 
11e8			;Quits when it reaches a non-decimal digit 
11e8			 
11e8			string_to_uint16: 
11e8			atoui_16: 
11e8			;Input: 
11e8			;     DE points to the string 
11e8			;Outputs: 
11e8			;     HL is the result 
11e8			;     A is the 8-bit value of the number 
11e8			;     DE points to the byte after the number 
11e8			;Destroys: 
11e8			;     BC 
11e8			;       if the string is non-empty, BC is HL/10 
11e8			;Size:  24 bytes 
11e8			;Speed: 42+d(104+{0,9}) 
11e8			;       d is the number of digits in the number 
11e8			;       max is 640 cycles for a 5 digit number 
11e8			;Assuming no leading zeros: 
11e8			;1 digit:  146cc 
11e8			;2 digit:  250cc 
11e8			;3 digit:  354cc or 363cc (avg: 354.126cc) 
11e8			;4 digit:  458cc or 467cc (avg: 458.27cc) 
11e8			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
11e8			;avg: 544.81158447265625cc (544+13297/16384) 
11e8			;=============================================================== 
11e8 21 00 00		  ld hl,0 
11eb			.u16a: 
11eb 1a			  ld a,(de) 
11ec d6 30		  sub 30h 
11ee fe 0a		  cp 10 
11f0 d0			  ret nc 
11f1 13			  inc de 
11f2 44			  ld b,h 
11f3 4d			  ld c,l 
11f4 29			  add hl,hl 
11f5 29			  add hl,hl 
11f6 09			  add hl,bc 
11f7 29			  add hl,hl 
11f8 85			  add a,l 
11f9 6f			  ld l,a 
11fa 30 ef		  jr nc,.u16a 
11fc 24			  inc h 
11fd c3 eb 11		  jp .u16a 
1200			 
1200			 
1200			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1200			 
1200			;written by Zeda 
1200			;Converts a 16-bit unsigned integer to an ASCII string. 
1200			 
1200			uitoa_16: 
1200			;Input: 
1200			;   DE is the number to convert 
1200			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1200			;Output: 
1200			;   HL points to the null-terminated ASCII string 
1200			;      NOTE: This isn't necessarily the same as the input HL. 
1200 d5			  push de 
1201 c5			  push bc 
1202 f5			  push af 
1203 eb			  ex de,hl 
1204			 
1204 01 f0 d8		  ld bc,-10000 
1207 3e 2f		  ld a,'0'-1 
1209 3c			  inc a 
120a 09			  add hl,bc  
120b 38 fc		   jr c,$-2 
120d 12			  ld (de),a 
120e 13			  inc de 
120f			 
120f 01 e8 03		  ld bc,1000 
1212 3e 3a		  ld a,'9'+1 
1214 3d			  dec a  
1215 09			  add hl,bc  
1216 30 fc		   jr nc,$-2 
1218 12			  ld (de),a 
1219 13			  inc de 
121a			 
121a 01 9c ff		  ld bc,-100 
121d 3e 2f		  ld a,'0'-1 
121f 3c			  inc a  
1220 09			  add hl,bc  
1221 38 fc		   jr c,$-2 
1223 12			  ld (de),a 
1224 13			  inc de 
1225			 
1225 7d			  ld a,l 
1226 26 3a		  ld h,'9'+1 
1228 25			  dec h  
1229 c6 0a		  add a,10  
122b 30 fb		   jr nc,$-3 
122d c6 30		  add a,'0' 
122f eb			  ex de,hl 
1230 72			  ld (hl),d 
1231 23			  inc hl 
1232 77			  ld (hl),a 
1233 23			  inc hl 
1234 36 00		  ld (hl),0 
1236			 
1236			;Now strip the leading zeros 
1236 0e fa		  ld c,-6 
1238 09			  add hl,bc 
1239 3e 30		  ld a,'0' 
123b 23			  inc hl  
123c be			  cp (hl)  
123d 28 fc		  jr z,$-2 
123f			 
123f			;Make sure that the string is non-empty! 
123f 7e			  ld a,(hl) 
1240 b7			  or a 
1241 20 01		  jr nz,.atoub 
1243 2b			  dec hl 
1244			.atoub: 
1244			 
1244 f1			  pop af 
1245 c1			  pop bc 
1246 d1			  pop de 
1247 c9			  ret 
1248			 
1248			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1248			 
1248			toUpper: 
1248			;A is the char. 
1248			;If A is a lowercase letter, this sets it to the matching uppercase 
1248			;18cc or 30cc or 41cc 
1248			;avg: 26.75cc 
1248 fe 61		  cp 'a' 
124a d8			  ret c 
124b fe 7b		  cp 'z'+1 
124d d0			  ret nc 
124e d6 20		  sub 'a'-'A' 
1250 c9			  ret 
1251			 
1251			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1251			 
1251			; String Length 
1251			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1251			 
1251			; Get the length of the null-terminated string starting at $8000 hl 
1251			;    LD     HL, $8000 
1251			 
1251			strlenz: 
1251			 
1251 af			    XOR    A               ; Zero is the value we are looking for. 
1252 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1253 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1254			                           ; 65, 536 bytes (the entire addressable memory space). 
1254 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1256			 
1256			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1256 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1257 6f			    LD     L, A             ; number of bytes 
1258 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
125a 2b			    DEC    HL              ; Compensate for null. 
125b c9				ret 
125c			 
125c			; Get the length of the A terminated string starting at $8000 hl 
125c			;    LD     HL, $8000 
125c			 
125c			strlent: 
125c			 
125c			                  ; A is the value we are looking for. 
125c 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
125e 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1260			                           ; 65, 536 bytes (the entire addressable memory space). 
1260 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1262			 
1262			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1262 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1264 2e 00		    LD     L, 0             ; number of bytes 
1266 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1268 2b			    DEC    HL              ; Compensate for null. 
1269 c9				ret 
126a			 
126a			 
126a			;Comparing Strings 
126a			 
126a			;IN    HL     Address of string1. 
126a			;      DE     Address of string2. 
126a			 
126a			; doc given but wrong??? 
126a			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
126a			;      carry  Set if string1 > string2, reset if string1 <= string2. 
126a			; tested 
126a			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
126a			 
126a			strcmp_old: 
126a e5			    PUSH   HL 
126b d5			    PUSH   DE 
126c			 
126c 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
126d be			    CP     (HL)            ; (want to minimize work). 
126e 38 01		    JR     C, Str1IsBigger 
1270 7e			    LD     A, (HL) 
1271			 
1271			Str1IsBigger: 
1271 4f			    LD     C, A             ; Put length in BC 
1272 06 00		    LD     B, 0 
1274 13			    INC    DE              ; Increment pointers to meat of string. 
1275 23			    INC    HL 
1276			 
1276			CmpLoop: 
1276 1a			    LD     A, (DE)          ; Compare bytes. 
1277 ed a1		    CPI 
1279 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
127b 13			    INC    DE              ; Update pointer. 
127c ea 76 12		    JP     PE, CmpLoop 
127f			 
127f d1			    POP    DE 
1280 e1			    POP    HL 
1281 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1282 be			    CP     (HL) 
1283 c9			    RET 
1284			 
1284			NoMatch: 
1284 2b			    DEC    HL 
1285 be			    CP     (HL)            ; Compare again to affect carry. 
1286 d1			    POP    DE 
1287 e1			    POP    HL 
1288 c9			    RET 
1289			 
1289			;; test strmp 
1289			; 
1289			;ld de, .str1 
1289			;ld hl, .str2 
1289			;call strcmp 
1289			;jr z, .z1 
1289			;;this 
1289			;	if DEBUG_FORTH_WORDS 
1289			;		DMARK "NZ1" 
1289			;		CALLMONITOR 
1289			;	endif 
1289			;.z1: 
1289			; 
1289			;	if DEBUG_FORTH_WORDS 
1289			;		DMARK "ZZ1" 
1289			;		CALLMONITOR 
1289			;	endif 
1289			; 
1289			;ld de, .str1 
1289			;ld hl, .str1 
1289			;call strcmp 
1289			;jr z, .z2 
1289			;;this 
1289			;	if DEBUG_FORTH_WORDS 
1289			;		DMARK "NZ2" 
1289			;		CALLMONITOR 
1289			;	endif 
1289			;.z2: 
1289			; 
1289			;	if DEBUG_FORTH_WORDS 
1289			;		DMARK "ZZ2" 
1289			;		CALLMONITOR 
1289			;	endif 
1289			; 
1289			;ld de, .str1 
1289			;ld hl, .str2 
1289			;call strcmp 
1289			;jr c, .c1 
1289			; 
1289			;	if DEBUG_FORTH_WORDS 
1289			;		DMARK "Nc1" 
1289			;		CALLMONITOR 
1289			;	endif 
1289			;.c1: 
1289			;;this 
1289			;	if DEBUG_FORTH_WORDS 
1289			;		DMARK "cc1" 
1289			;		CALLMONITOR 
1289			;	endif 
1289			; 
1289			;ld de, .str1 
1289			;ld hl, .str1 
1289			;call strcmp 
1289			;jr c, .c2 
1289			;;this 
1289			;	if DEBUG_FORTH_WORDS 
1289			;		DMARK "Nc2" 
1289			;		CALLMONITOR 
1289			;	endif 
1289			;.c2: 
1289			; 
1289			;	if DEBUG_FORTH_WORDS 
1289			;		DMARK "cc2" 
1289			;		CALLMONITOR 
1289			;	endif 
1289			;	NEXTW 
1289			;.str1:   db "string1",0 
1289			;.str2:   db "string2",0 
1289			 
1289			; only care about direct match or not 
1289			; hl and de strings 
1289			; zero set if the same 
1289			 
1289			strcmp: 
1289 1a				ld a, (de) 
128a be				cp (hl) 
128b 28 02			jr z, .ssame 
128d b7				or a 
128e c9				ret 
128f			 
128f			.ssame:  
128f fe 00			cp 0 
1291 c8				ret z 
1292			 
1292 23				inc hl 
1293 13				inc de 
1294 18 f3			jr strcmp 
1296				 
1296				 
1296			 
1296			 
1296			 
1296			 
1296			; eof 
1296			 
1296			 
1296			 
1296			 
1296			 
1296			 
# End of file firmware_strings.asm
1296			include "firmware_memory.asm"   ; malloc and free  
1296			 
1296			if DEBUG_FORTH_MALLOC_HIGH 
1296			.mallocsize: db "Wants malloc >256",0 
1296			.mallocasize: db "MALLOC gives >256",0 
1296			.malloczero: db "MALLOC gives zero",0 
1296			 
1296			malloc_guard_zerolen: 
1296				push hl 
1296				push de 
1296				push af 
1296			 
1296				ld de, 0 
1296			        call cmp16 
1296				jr nz, .lowalloz 
1296			 
1296				push hl 
1296				push de 
1296					ld hl, display_fb0 
1296					ld (display_fb_active), hl 
1296				call clear_display 
1296				ld a, 0 
1296				ld de, .malloczero 
1296				call str_at_display 
1296				call update_display 
1296				call delay1s 
1296				call delay1s 
1296				ld a, 0 
1296				ld (os_view_disable), a 
1296			 
1296				pop de 
1296				pop hl 
1296			 
1296				 
1296			 
1296				CALLMONITOR 
1296			.lowalloz: 
1296			 
1296			 
1296				pop af 
1296				pop de 
1296				pop hl 
1296			ret 
1296			 
1296			malloc_guard_entry: 
1296				push hl 
1296				push de 
1296				push af 
1296			 
1296			 	or a      ;clear carry flag 
1296				push hl 
1296				ld de, 255 
1296				sbc hl, de 
1296				jr c, .lowalloc 
1296			 
1296				push de 
1296					ld hl, display_fb0 
1296					ld (display_fb_active), hl 
1296				call clear_display 
1296				ld a, 0 
1296				ld de, .mallocsize 
1296				call str_at_display 
1296				call update_display 
1296				call delay1s 
1296				call delay1s 
1296				ld a, 0 
1296				ld (os_view_disable), a 
1296			 
1296				pop de 
1296				pop hl 
1296			 
1296				 
1296			 
1296				CALLMONITOR 
1296				jr .lowdone 
1296			.lowalloc: 
1296			 
1296			 
1296				pop hl 
1296			.lowdone:	pop af 
1296				pop de 
1296				pop hl 
1296			ret 
1296			 
1296			malloc_guard_exit: 
1296				push hl 
1296				push de 
1296				push af 
1296			 
1296			 	or a      ;clear carry flag 
1296				push hl 
1296				ld de, 255 
1296				sbc hl, de 
1296				jr c, .lowallocx 
1296			 
1296				push de 
1296					ld hl, display_fb0 
1296					ld (display_fb_active), hl 
1296				call clear_display 
1296				ld a, 0 
1296				ld de, .mallocasize 
1296				call str_at_display 
1296				call update_display 
1296				call delay1s 
1296				call delay1s 
1296				ld a, 0 
1296				ld (os_view_disable), a 
1296				pop de 
1296				pop hl 
1296			 
1296				CALLMONITOR 
1296				jr .lowdonex 
1296			.lowallocx: 
1296			 
1296				pop hl 
1296			.lowdonex:	pop af 
1296				pop de 
1296				pop hl 
1296			ret 
1296			endif 
1296			 
1296			if MALLOC_2 
1296			; Z80 Malloc and Free Functions 
1296			 
1296			; Malloc Function: 
1296			; Input: 
1296			;   HL: Size of block to allocate 
1296			; Output: 
1296			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1296			 
1296			malloc: 
1296				 
1296			if DEBUG_FORTH_MALLOC_HIGH 
1296			call malloc_guard_entry 
1296			endif 
1296			 
1296			 
1296			 
1296			 
1296					if DEBUG_FORTH_MALLOC 
1296						DMARK "mal" 
1296						CALLMONITOR 
1296					endif 
1296			    push af            ; Save AF register 
1296			    ld a, l            ; Load low byte of size into A 
1296			    or h               ; Check if size is zero 
1296			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1296			 
1296			    ; Allocate memory 
1296			    ld hl, (heap_start) ; Load start of heap into HL 
1296					if DEBUG_FORTH_MALLOC 
1296						DMARK "ma1" 
1296						CALLMONITOR 
1296					endif 
1296			    call malloc_internal ; Call internal malloc function 
1296			    pop af             ; Restore AF register 
1296			if DEBUG_FORTH_MALLOC_HIGH 
1296			call malloc_guard_exit 
1296			call malloc_guard_zerolen 
1296			endif 
1296			    ret                ; Return 
1296			 
1296			; Free Function: 
1296			; Input: 
1296			;   HL: Pointer to memory block to free 
1296			; Output: 
1296			;   None 
1296			 
1296			free: 
1296			    push af            ; Save AF register 
1296			    ld a, l            ; Load low byte of pointer into A 
1296			    or h               ; Check if pointer is NULL 
1296			    jp z, free_exit    ; If pointer is NULL, exit 
1296			 
1296			    ; Free memory 
1296			    ld hl, (heap_start) ; Load start of heap into HL 
1296			    call free_internal  ; Call internal free function 
1296			    pop af             ; Restore AF register 
1296			    ret                ; Return 
1296			 
1296			; Internal Malloc Function: 
1296			; Input: 
1296			;   HL: Size of block to allocate 
1296			; Output: 
1296			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1296			 
1296			malloc_internal: 
1296			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1296			    add hl, bc         ; Add management overhead to requested size 
1296			    ex de, hl          ; Save total size in DE, and keep it in HL 
1296					if DEBUG_FORTH_MALLOC 
1296						DMARK "ma2" 
1296						CALLMONITOR 
1296					endif 
1296			 
1296			    ; Search for free memory block 
1296			    ld de, (heap_end)  ; Load end of heap into DE 
1296			    ld bc, 0           ; Initialize counter 
1296			 
1296					if DEBUG_FORTH_MALLOC 
1296						DMARK "ma2" 
1296						CALLMONITOR 
1296					endif 
1296			malloc_search_loop: 
1296			    ; Check if current block is free 
1296			    ld a, (hl)         ; Load current block's status (free or used) 
1296			    cp 0               ; Compare with zero (free) 
1296			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1296			 
1296			    ; Check if current block is large enough 
1296			    ld a, (hl+1)       ; Load high byte of block size 
1296			    cp l               ; Compare with low byte of requested size 
1296			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1296			 
1296			    ld a, (hl+2)       ; Load low byte of block size 
1296			    cp h               ; Compare with high byte of requested size 
1296			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1296			 
1296			    ; Mark block as used 
1296			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1296			 
1296			    ; Calculate remaining space in block 
1296			    ld bc, 0           ; Clear BC 
1296			    add hl, bc         ; Increment HL to point to start of data block 
1296			    add hl, de         ; HL = HL + DE (total size) 
1296			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1296			    add hl, bc         ; Add management overhead to start of data block 
1296			 
1296			    ; Save pointer to allocated block in HL 
1296			if DEBUG_FORTH_MALLOC_HIGH 
1296						DMARK "ma5" 
1296			call malloc_guard_exit 
1296			call malloc_guard_zerolen 
1296			endif 
1296			    ret 
1296			 
1296			malloc_skip_block_check: 
1296			    ; Move to the next block 
1296			    ld bc, 3           ; Size of management overhead 
1296			    add hl, bc         ; Move to the next block 
1296			    inc de             ; Increment counter 
1296			 
1296			    ; Check if we have reached the end of heap 
1296			    ld a, e            ; Load low byte of heap end address 
1296			    cp (hl)            ; Compare with low byte of current address 
1296			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1296			    ld a, d            ; Load high byte of heap end address 
1296			    cp 0               ; Check if it's zero (end of memory) 
1296			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1296			 
1296			    ; If we reached here, allocation failed 
1296			    xor a              ; Set result to NULL 
1296			if DEBUG_FORTH_MALLOC_HIGH 
1296						DMARK "ma6" 
1296			call malloc_guard_exit 
1296			call malloc_guard_zerolen 
1296			endif 
1296			    ret 
1296			malloc_exit: 
1296			if DEBUG_FORTH_MALLOC_HIGH 
1296						DMARK "ma7" 
1296			call malloc_guard_exit 
1296			call malloc_guard_zerolen 
1296			endif 
1296			    ret 
1296			 
1296			; Internal Free Function: 
1296			; Input: 
1296			;   HL: Pointer to memory block to free 
1296			; Output: 
1296			;   None 
1296			 
1296			free_internal: 
1296			    ld de, (heap_start) ; Load start of heap into DE 
1296			    ld bc, 0            ; Initialize counter 
1296			 
1296			free_search_loop: 
1296			    ; Check if current block contains the pointer 
1296			    ld a, l             ; Load low byte of pointer 
1296			    cp (hl+1)           ; Compare with high byte of current block's address 
1296			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1296			    ld a, h             ; Load high byte of pointer 
1296			    cp (hl+2)           ; Compare with low byte of current block's address 
1296			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1296			 
1296			    ; Mark block as free 
1296			    ld (hl), 0          ; Set status byte to indicate free block 
1296			    ret                 ; Return 
1296			 
1296			free_skip_block_check: 
1296			    ; Move to the next block 
1296			    ld bc, 3            ; Size of management overhead 
1296			    add hl, bc          ; Move to the next block 
1296			    inc de              ; Increment counter 
1296			 
1296			    ; Check if we have reached the end of heap 
1296			    ld a, e             ; Load low byte of heap end address 
1296			    cp (hl)             ; Compare with low byte of current address 
1296			    jr nz, free_search_loop  ; If not equal, continue searching 
1296			    ld a, d             ; Load high byte of heap end address 
1296			    cp 0                ; Check if it's zero (end of memory) 
1296			    jr nz, free_search_loop  ; If not zero, continue searching 
1296			 
1296			    ; If we reached here, pointer is not found in heap 
1296			    ret 
1296			 
1296			free_exit: 
1296			    ret                 ; Return 
1296			 
1296			; Define heap start and end addresses 
1296			;heap_start:    .dw 0xC000   ; Start of heap 
1296			;heap_end:      .dw 0xE000   ; End of heap 
1296			 
1296			endif 
1296			 
1296			 
1296			if MALLOC_1 
1296			 
1296			 
1296			 
1296			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1296			 
1296			;moved to firmware.asm 
1296			;heap_start        .equ  0x9000      ; Starting address of heap 
1296			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1296			 
1296			;      .org 0 
1296			;      jp    main 
1296			 
1296			 
1296			;      .org  0x100 
1296			;main: 
1296			;      ld    HL, 0x8100 
1296			;      ld    SP, HL 
1296			; 
1296			;      call  heap_init 
1296			; 
1296			;      ; Make some allocations 
1296			;      ld    HL, 12 
1296			;      call  malloc            ; Allocates 0x9004 
1296			; 
1296			;      ld    HL, 12 
1296			;      call  malloc            ; Allocates 0x9014 
1296			; 
1296			;      ld    HL, 12 
1296			;      call  malloc            ; Allocates 0x9024 
1296			; 
1296			;      ; Free some allocations 
1296			;      ld    HL, 0x9014 
1296			;      call  free 
1296			; 
1296			;      ld    HL, 0x9004 
1296			;      call  free 
1296			; 
1296			;      ld    HL, 0x9024 
1296			;      call  free 
1296			; 
1296			; 
1296			;      halt 
1296			 
1296			 
1296			;------------------------------------------------------------------------------ 
1296			;     heap_init                                                               : 
1296			;                                                                             : 
1296			; Description                                                                 : 
1296			;     Initialise the heap and make it ready for malloc and free operations.   : 
1296			;                                                                             : 
1296			;     The heap is maintained as a linked list, starting with an initial       : 
1296			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1296			;     the first free block in the heap. Each block then points to the next    : 
1296			;     free block within the heap, and the free list ends at the first block   : 
1296			;     with a null pointer to the next free block.                             : 
1296			;                                                                             : 
1296			; Parameters                                                                  : 
1296			;     Inputs are compile-time only. Two defines which specify the starting    : 
1296			;     address of the heap and its size are required, along with a memory      : 
1296			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1296			;     principally stores a pointer to the first free block in the heap.       : 
1296			;                                                                             : 
1296			; Returns                                                                     : 
1296			;     Nothing                                                                 : 
1296			;------------------------------------------------------------------------------ 
1296			heap_init: 
1296 e5			      push  HL 
1297			 
1297			      ; Initialise free list struct 
1297 21 0e 80		      ld    HL, heap_start 
129a 22 0a 80		      ld    (free_list), HL 
129d 21 00 00		      ld    HL, 0 
12a0 22 0c 80		      ld    (free_list+2), HL 
12a3			 
12a3			      ; Insert first free block at bottom of heap, consumes entire heap 
12a3 21 0a 80		      ld    HL, heap_start+heap_size-4 
12a6 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
12a9 21 fc ff		      ld    HL, heap_size-4 
12ac 22 10 80		      ld    (heap_start+2), HL      ; Block size 
12af			 
12af			      ; Insert end of free list block at top of heap - two null words will 
12af			      ; terminate the free list 
12af 21 00 00		      ld    HL, 0 
12b2 22 0c 80		      ld    (heap_start+heap_size-2), HL 
12b5 22 0a 80		      ld    (heap_start+heap_size-4), HL 
12b8			 
12b8 e1			      pop   HL 
12b9			 
12b9 c9			      ret 
12ba			 
12ba			 
12ba			;------------------------------------------------------------------------------ 
12ba			;     malloc                                                                  : 
12ba			;                                                                             : 
12ba			; Description                                                                 : 
12ba			;     Allocates the wanted space from the heap and returns the address of the : 
12ba			;     first useable byte of the allocation.                                   : 
12ba			;                                                                             : 
12ba			;     Allocations can happen in one of two ways:                              : 
12ba			;                                                                             : 
12ba			;     1. A free block may be found which is the exact size wanted. In this    : 
12ba			;        case the block is removed from the free list and retuedn to the      : 
12ba			;        caller.                                                              : 
12ba			;     2. A free block may be found which is larger than the size wanted. In   : 
12ba			;        this case, the larger block is split into two. The first portion of  : 
12ba			;        this block will become the requested space by the malloc call and    : 
12ba			;        is returned to the caller. The second portion becomes a new free     : 
12ba			;        block, and the free list is adjusted to maintain continuity via this : 
12ba			;        newly created block.                                                 : 
12ba			;                                                                             : 
12ba			;     malloc does not set any initial value in the allocated space, the       : 
12ba			;     caller is required to do this as required.                              : 
12ba			;                                                                             : 
12ba			;     This implementation of malloc uses the stack exclusively, and is        : 
12ba			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12ba			;     advisable to disable interrupts before calling malloc, and recommended  : 
12ba			;     to avoid the use of malloc inside ISRs in general.                      : 
12ba			;                                                                             : 
12ba			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12ba			;                                                                             : 
12ba			; Parameters                                                                  : 
12ba			;     HL  Number of bytes wanted                                              : 
12ba			;                                                                             : 
12ba			; Returns                                                                     : 
12ba			;     HL  Address of the first useable byte of the allocation                 : 
12ba			;                                                                             : 
12ba			; Flags                                                                       : 
12ba			;     Z   Set if the allocation did not succeed, clear otherwise              : 
12ba			;                                                                             : 
12ba			; Stack frame                                                                 : 
12ba			;       |             |                                                       : 
12ba			;       +-------------+                                                       : 
12ba			;       |     BC      |                                                       : 
12ba			;       +-------------+                                                       : 
12ba			;       |     DE      |                                                       : 
12ba			;       +-------------+                                                       : 
12ba			;       |     IX      |                                                       : 
12ba			;       +-------------+                                                       : 
12ba			;       |  prev_free  |                                                       : 
12ba			;   +4  +-------------+                                                       : 
12ba			;       |  this_free  |                                                       : 
12ba			;   +2  +-------------+                                                       : 
12ba			;       |  next_free  |                                                       : 
12ba			;   +0  +-------------+                                                       : 
12ba			;       |             |                                                       : 
12ba			;                                                                             : 
12ba			;------------------------------------------------------------------------------ 
12ba			 
12ba			 
12ba			;malloc: 
12ba			; 
12ba			;	SAVESP ON 1 
12ba			; 
12ba			;	call malloc_code 
12ba			; 
12ba			;	CHECKSP ON 1 
12ba			;	ret 
12ba			 
12ba			 
12ba			malloc: 
12ba c5			      push  BC 
12bb d5			      push  DE 
12bc dd e5		      push  IX 
12be			if DEBUG_FORTH_MALLOC_HIGH 
12be			call malloc_guard_entry 
12be			endif 
12be			 
12be					if DEBUG_FORTH_MALLOC 
12be						DMARK "mal" 
12be						CALLMONITOR 
12be					endif 
12be 7c			      ld    A, H                    ; Exit if no space requested 
12bf b5			      or    L 
12c0 ca 7f 13		      jp    Z, malloc_early_exit 
12c3			 
12c3			;inc hl 
12c3			;inc hl 
12c3			;inc hl 
12c3			; 
12c3			;inc hl 
12c3			;inc hl 
12c3			;inc hl 
12c3			;inc hl 
12c3			;inc hl 
12c3			;inc hl 
12c3			;inc hl 
12c3			;inc hl 
12c3			;inc hl 
12c3			 
12c3			 
12c3			 
12c3			 
12c3					if DEBUG_FORTH_MALLOC 
12c3						DMARK "maA" 
12c3						CALLMONITOR 
12c3					endif 
12c3			      ; Set up stack frame 
12c3 eb			      ex    DE, HL 
12c4 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
12c7 39			      add   HL, SP 
12c8 f9			      ld    SP, HL 
12c9 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12cd dd 39		      add   IX, SP 
12cf			 
12cf			      ; Setup initial state 
12cf 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
12d2 19			      add   HL, DE 
12d3			 
12d3 44			      ld    B, H                    ; Move want to BC 
12d4 4d			      ld    C, L 
12d5			 
12d5 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
12d8 dd 75 04		      ld    (IX+4), L 
12db dd 74 05		      ld    (IX+5), H 
12de			 
12de 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
12df 23			      inc   HL 
12e0 56			      ld    D, (HL) 
12e1 dd 73 02		      ld    (IX+2), E 
12e4 dd 72 03		      ld    (IX+3), D 
12e7 eb			      ex    DE, HL                  ; this_free ptr into HL 
12e8			 
12e8					if DEBUG_FORTH_MALLOC 
12e8						DMARK "maB" 
12e8						CALLMONITOR 
12e8					endif 
12e8			      ; Loop through free block list to find some space 
12e8			malloc_find_space: 
12e8 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
12e9 23			      inc   HL 
12ea 56			      ld    D, (HL) 
12eb			 
12eb 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
12ec b3			      or    E 
12ed ca 79 13		      jp    Z, malloc_no_space 
12f0			 
12f0 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
12f3 dd 72 01		      ld    (IX+1), D 
12f6			 
12f6			      ; Does this block have enough space to make the allocation? 
12f6 23			      inc   HL                      ; Load free block size into DE 
12f7 5e			      ld    E, (HL) 
12f8 23			      inc   HL 
12f9 56			      ld    D, (HL) 
12fa			 
12fa eb			      ex    DE, HL                  ; Check size of block against want 
12fb b7			      or    A                       ; Ensure carry flag clear 
12fc ed 42		      sbc   HL, BC 
12fe e5			      push  HL                      ; Store the result for later (new block size) 
12ff			 
12ff ca 4e 13		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1302 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1304			 
1304			      ; this_free block is not big enough, setup ptrs to test next free block 
1304 e1			      pop   HL                      ; Discard previous result 
1305			 
1305 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1308 dd 66 03		      ld    H, (IX+3) 
130b dd 75 04		      ld    (IX+4), L 
130e dd 74 05		      ld    (IX+5), H 
1311			 
1311 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1314 dd 66 01		      ld    H, (IX+1) 
1317 dd 75 02		      ld    (IX+2), L 
131a dd 74 03		      ld    (IX+3), H 
131d			 
131d					if DEBUG_FORTH_MALLOC 
131d						DMARK "MA>" 
131d						CALLMONITOR 
131d					endif 
131d 18 c9		      jr    malloc_find_space 
131f			 
131f			      ; split a bigger block into two - requested size and remaining size 
131f			malloc_alloc_split: 
131f					if DEBUG_FORTH_MALLOC 
131f						DMARK "MAs" 
131f						CALLMONITOR 
131f					endif 
131f eb			      ex    DE, HL                  ; Calculate address of new free block 
1320 2b			      dec   HL 
1321 2b			      dec   HL 
1322 2b			      dec   HL 
1323 09			      add   HL, BC 
1324			 
1324			      ; Create a new block and point it at next_free 
1324 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1327 dd 56 01		      ld    D, (IX+1) 
132a			 
132a 73			      ld    (HL), E                 ; Store next_free ptr into new block 
132b 23			      inc   HL 
132c 72			      ld    (HL), D 
132d			 
132d d1			      pop   DE                      ; Store size of new block into new block 
132e 23			      inc   HL 
132f 73			      ld    (HL), E 
1330 23			      inc   HL 
1331 72			      ld    (HL), D 
1332			 
1332			      ; Update this_free ptr to point to new block 
1332 2b			      dec   HL 
1333 2b			      dec   HL 
1334 2b			      dec   HL 
1335			 
1335 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1338 dd 56 03		      ld    D, (IX+3) 
133b			 
133b dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
133e dd 74 03		      ld    (IX+3), H 
1341			 
1341			      ; Modify this_free block to be allocation 
1341 eb			      ex    DE, HL 
1342 af			      xor   A                       ; Null the next block ptr of allocated block 
1343 77			      ld    (HL), A 
1344 23			      inc   HL 
1345 77			      ld    (HL), A 
1346			 
1346 23			      inc   HL                      ; Store want size into allocated block 
1347 71			      ld    (HL), C 
1348 23			      inc   HL 
1349 70			      ld    (HL), B 
134a 23			      inc   HL 
134b e5			      push  HL                      ; Address of allocation to return 
134c			 
134c 18 19		      jr    malloc_update_links 
134e			 
134e			malloc_alloc_fit: 
134e e1			      pop   HL                      ; Dont need new block size, want is exact fit 
134f			 
134f					if DEBUG_FORTH_MALLOC 
134f						DMARK "MAf" 
134f						CALLMONITOR 
134f					endif 
134f			      ; Modify this_free block to be allocation 
134f eb			      ex    DE, HL 
1350 2b			      dec   HL 
1351 2b			      dec   HL 
1352 2b			      dec   HL 
1353			 
1353 af			      xor   A                       ; Null the next block ptr of allocated block 
1354 77			      ld    (HL), A 
1355 23			      inc   HL 
1356 77			      ld    (HL), A 
1357			 
1357 23			      inc   HL                      ; Store address of allocation to return 
1358 23			      inc   HL 
1359 23			      inc   HL 
135a e5			      push  HL 
135b			 
135b			      ; Copy next_free ptr to this_free, remove allocated block from free list 
135b dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
135e dd 66 01		      ld    H, (IX+1) 
1361			 
1361 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1364 dd 74 03		      ld    (IX+3), H 
1367			 
1367			 
1367			malloc_update_links: 
1367			      ; Update prev_free ptr to point to this_free 
1367 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
136a dd 66 05		      ld    H, (IX+5) 
136d			 
136d dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1370 dd 56 03		      ld    D, (IX+3) 
1373			 
1373 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1374 23			      inc   HL 
1375 72			      ld    (HL), D 
1376			 
1376					if DEBUG_FORTH_MALLOC 
1376						DMARK "Mul" 
1376						CALLMONITOR 
1376					endif 
1376			      ; Clear the Z flag to indicate successful allocation 
1376 7a			      ld    A, D 
1377 b3			      or    E 
1378			 
1378 d1			      pop   DE                      ; Address of allocation 
1379					if DEBUG_FORTH_MALLOC 
1379						DMARK "MAu" 
1379						CALLMONITOR 
1379					endif 
1379			 
1379			malloc_no_space: 
1379 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
137c 39			      add   HL, SP 
137d f9			      ld    SP, HL 
137e			 
137e eb			      ex    DE, HL                  ; Alloc addr into HL for return 
137f					if DEBUG_FORTH_MALLOC 
137f						DMARK "MAN" 
137f						CALLMONITOR 
137f					endif 
137f			 
137f			malloc_early_exit: 
137f					if DEBUG_FORTH_MALLOC 
137f						DMARK "MAx" 
137f						CALLMONITOR 
137f					endif 
137f dd e1		      pop   IX 
1381 d1			      pop   DE 
1382 c1			      pop   BC 
1383			 
1383			if DEBUG_FORTH_MALLOC_HIGH 
1383			call malloc_guard_exit 
1383			call malloc_guard_zerolen 
1383			endif 
1383 c9			      ret 
1384			 
1384			 
1384			;------------------------------------------------------------------------------ 
1384			;     free                                                                    : 
1384			;                                                                             : 
1384			; Description                                                                 : 
1384			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1384			;     returned by malloc, otherwise the behaviour is undefined.               : 
1384			;                                                                             : 
1384			;     Where possible, directly adjacent free blocks will be merged together   : 
1384			;     into larger blocks to help ensure that the heap does not become         : 
1384			;     excessively fragmented.                                                 : 
1384			;                                                                             : 
1384			;     free does not clear or set any other value into the freed space, and    : 
1384			;     therefore its contents may be visible through subsequent malloc's. The  : 
1384			;     caller should clear the freed space as required.                        : 
1384			;                                                                             : 
1384			;     This implementation of free uses the stack exclusively, and is          : 
1384			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1384			;     advisable to disable interrupts before calling free, and recommended    : 
1384			;     to avoid the use of free inside ISRs in general.                        : 
1384			;                                                                             : 
1384			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1384			;                                                                             : 
1384			; Parameters                                                                  : 
1384			;     HL  Pointer to address of first byte of allocation to be freed          : 
1384			;                                                                             : 
1384			; Returns                                                                     : 
1384			;     Nothing                                                                 : 
1384			;                                                                             : 
1384			; Stack frame                                                                 : 
1384			;       |             |                                                       : 
1384			;       +-------------+                                                       : 
1384			;       |     BC      |                                                       : 
1384			;       +-------------+                                                       : 
1384			;       |     DE      |                                                       : 
1384			;       +-------------+                                                       : 
1384			;       |     IX      |                                                       : 
1384			;       +-------------+                                                       : 
1384			;       |  prev_free  |                                                       : 
1384			;   +2  +-------------+                                                       : 
1384			;       |  next_free  |                                                       : 
1384			;   +0  +-------------+                                                       : 
1384			;       |             |                                                       : 
1384			;                                                                             : 
1384			;------------------------------------------------------------------------------ 
1384			free: 
1384 c5			      push  BC 
1385 d5			      push  DE 
1386 dd e5		      push  IX 
1388			 
1388 7c			      ld    A, H                    ; Exit if ptr is null 
1389 b5			      or    L 
138a ca 4e 14		      jp    Z, free_early_exit 
138d			 
138d			      ; Set up stack frame 
138d eb			      ex    DE, HL 
138e 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1391 39			      add   HL, SP 
1392 f9			      ld    SP, HL 
1393 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1397 dd 39		      add   IX, SP 
1399			 
1399			      ; The address in HL points to the start of the useable allocated space, 
1399			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1399			      ; address of the block itself. 
1399 eb			      ex    DE, HL 
139a 11 fc ff		      ld    DE, -4 
139d 19			      add   HL, DE 
139e			 
139e			      ; An allocated block must have a null next block pointer in it 
139e 7e			      ld    A, (HL) 
139f 23			      inc   HL 
13a0 b6			      or    (HL) 
13a1 c2 49 14		      jp    NZ, free_done 
13a4			 
13a4 2b			      dec   HL 
13a5			 
13a5 44			      ld    B, H                    ; Copy HL to BC 
13a6 4d			      ld    C, L 
13a7			 
13a7			      ; Loop through the free list to find the first block with an address 
13a7			      ; higher than the block being freed 
13a7 21 0a 80		      ld    HL, free_list 
13aa			 
13aa			free_find_higher_block: 
13aa 5e			      ld    E, (HL)                 ; Load next ptr from free block 
13ab 23			      inc   HL 
13ac 56			      ld    D, (HL) 
13ad 2b			      dec   HL 
13ae			 
13ae dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
13b1 dd 72 01		      ld    (IX+1), D 
13b4 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
13b7 dd 74 03		      ld    (IX+3), H 
13ba			 
13ba 78			      ld    A, B                    ; Check if DE is greater than BC 
13bb ba			      cp    D                       ; Compare MSB first 
13bc 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
13be 30 04		      jr    NC, free_find_higher_block_skip 
13c0 79			      ld    A, C 
13c1 bb			      cp    E                       ; Then compare LSB 
13c2 38 08		      jr    C, free_found_higher_block 
13c4			 
13c4			free_find_higher_block_skip: 
13c4 7a			      ld    A, D                    ; Reached the end of the free list? 
13c5 b3			      or    E 
13c6 ca 49 14		      jp    Z, free_done 
13c9			 
13c9 eb			      ex    DE, HL 
13ca			 
13ca 18 de		      jr    free_find_higher_block 
13cc			 
13cc			free_found_higher_block: 
13cc			      ; Insert freed block between prev and next free blocks 
13cc 71			      ld    (HL), C                 ; Point prev free block to freed block 
13cd 23			      inc   HL 
13ce 70			      ld    (HL), B 
13cf			 
13cf 60			      ld    H, B                    ; Point freed block at next free block 
13d0 69			      ld    L, C 
13d1 73			      ld    (HL), E 
13d2 23			      inc   HL 
13d3 72			      ld    (HL), D 
13d4			 
13d4			      ; Check if the freed block is adjacent to the next free block 
13d4 23			      inc   HL                      ; Load size of freed block into HL 
13d5 5e			      ld    E, (HL) 
13d6 23			      inc   HL 
13d7 56			      ld    D, (HL) 
13d8 eb			      ex    DE, HL 
13d9			 
13d9 09			      add   HL, BC                  ; Add addr of freed block and its size 
13da			 
13da dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
13dd dd 56 01		      ld    D, (IX+1) 
13e0			 
13e0 b7			      or    A                       ; Clear the carry flag 
13e1 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
13e3 20 22		      jr    NZ, free_check_adjacent_to_prev 
13e5			 
13e5			      ; Freed block is adjacent to next, merge into one bigger block 
13e5 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
13e6 5e			      ld    E, (HL) 
13e7 23			      inc   HL 
13e8 56			      ld    D, (HL) 
13e9 e5			      push  HL                      ; Save ptr to next block for later 
13ea			 
13ea 60			      ld    H, B                    ; Store ptr from next block into freed block 
13eb 69			      ld    L, C 
13ec 73			      ld    (HL), E 
13ed 23			      inc   HL 
13ee 72			      ld    (HL), D 
13ef			 
13ef e1			      pop   HL                      ; Restore ptr to next block 
13f0 23			      inc   HL                      ; Load size of next block into DE 
13f1 5e			      ld    E, (HL) 
13f2 23			      inc   HL 
13f3 56			      ld    D, (HL) 
13f4 d5			      push  DE                      ; Save next block size for later 
13f5			 
13f5 60			      ld    H, B                    ; Load size of freed block into HL 
13f6 69			      ld    L, C 
13f7 23			      inc   HL 
13f8 23			      inc   HL 
13f9 5e			      ld    E, (HL) 
13fa 23			      inc   HL 
13fb 56			      ld    D, (HL) 
13fc eb			      ex    DE, HL 
13fd			 
13fd d1			      pop   DE                      ; Restore size of next block 
13fe 19			      add   HL, DE                  ; Add sizes of both blocks 
13ff eb			      ex    DE, HL 
1400			 
1400 60			      ld    H, B                    ; Store new bigger size into freed block 
1401 69			      ld    L, C 
1402 23			      inc   HL 
1403 23			      inc   HL 
1404 73			      ld    (HL), E 
1405 23			      inc   HL 
1406 72			      ld    (HL), D 
1407			 
1407			free_check_adjacent_to_prev: 
1407			      ; Check if the freed block is adjacent to the prev free block 
1407 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
140a dd 66 03		      ld    H, (IX+3) 
140d			 
140d 23			      inc   HL                      ; Size of prev free block into DE 
140e 23			      inc   HL 
140f 5e			      ld    E, (HL) 
1410 23			      inc   HL 
1411 56			      ld    D, (HL) 
1412 2b			      dec   HL 
1413 2b			      dec   HL 
1414 2b			      dec   HL 
1415			 
1415 19			      add   HL, DE                  ; Add prev block addr and size 
1416			 
1416 b7			      or    A                       ; Clear the carry flag 
1417 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1419 20 2e		      jr    NZ, free_done 
141b			 
141b			      ; Freed block is adjacent to prev, merge into one bigger block 
141b 60			      ld    H, B                    ; Load next ptr from freed block into DE 
141c 69			      ld    L, C 
141d 5e			      ld    E, (HL) 
141e 23			      inc   HL 
141f 56			      ld    D, (HL) 
1420 e5			      push  HL                      ; Save freed block ptr for later 
1421			 
1421 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1424 dd 66 03		      ld    H, (IX+3) 
1427 73			      ld    (HL), E 
1428 23			      inc   HL 
1429 72			      ld    (HL), D 
142a			 
142a e1			      pop   HL                      ; Restore freed block ptr 
142b 23			      inc   HL                      ; Load size of freed block into DE 
142c 5e			      ld    E, (HL) 
142d 23			      inc   HL 
142e 56			      ld    D, (HL) 
142f d5			      push  DE                      ; Save freed block size for later 
1430			 
1430 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1433 dd 66 03		      ld    H, (IX+3) 
1436 23			      inc   HL 
1437 23			      inc   HL 
1438 5e			      ld    E, (HL) 
1439 23			      inc   HL 
143a 56			      ld    D, (HL) 
143b			 
143b e1			      pop   HL                      ; Add sizes of both blocks 
143c 19			      add   HL, DE 
143d eb			      ex    DE, HL 
143e			 
143e dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1441 dd 66 03		      ld    H, (IX+3) 
1444 23			      inc   HL 
1445 23			      inc   HL 
1446 73			      ld    (HL), E 
1447 23			      inc   HL 
1448 72			      ld    (HL), D 
1449			 
1449			free_done: 
1449 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
144c 39			      add   HL, SP 
144d f9			      ld    SP, HL 
144e			 
144e			free_early_exit: 
144e dd e1		      pop   IX 
1450 d1			      pop   DE 
1451 c1			      pop   BC 
1452			 
1452 c9			      ret 
1453			 
1453			; moved to firmware.asm 
1453			; 
1453			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1453			;                  .dw   0 
1453			 
1453			 
1453			endif 
1453			 
1453			 
1453			if MALLOC_3 
1453			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1453			;heap_start        .equ  0x9000      ; Starting address of heap 
1453			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1453			; 
1453			 ;     .org 0 
1453			  ;    jp    main 
1453			; 
1453			; 
1453			 ;     .org  0x100 
1453			;main: 
1453			 ;     ld    HL, 0x8100 
1453			  ;    ld    SP, HL 
1453			; 
1453			;      call  heap_init 
1453			 
1453			      ; Make some allocations 
1453			;      ld    HL, 12 
1453			;      call  malloc            ; Allocates 0x9004 
1453			; 
1453			 ;     ld    HL, 12 
1453			;      call  malloc            ; Allocates 0x9014 
1453			 
1453			;      ld    HL, 12 
1453			;      call  malloc            ; Allocates 0x9024 
1453			 
1453			      ; Free some allocations 
1453			;      ld    HL, 0x9014 
1453			;      call  free 
1453			 
1453			;      ld    HL, 0x9004 
1453			;      call  free 
1453			; 
1453			;      ld    HL, 0x9024 
1453			;      call  free 
1453			 
1453			 
1453			 ;     halt 
1453			 
1453			 
1453			;------------------------------------------------------------------------------ 
1453			;     heap_init                                                               : 
1453			;                                                                             : 
1453			; Description                                                                 : 
1453			;     Initialise the heap and make it ready for malloc and free operations.   : 
1453			;                                                                             : 
1453			;     The heap is maintained as a linked list, starting with an initial       : 
1453			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1453			;     the first free block in the heap. Each block then points to the next    : 
1453			;     free block within the heap, and the free list ends at the first block   : 
1453			;     with a null pointer to the next free block.                             : 
1453			;                                                                             : 
1453			; Parameters                                                                  : 
1453			;     Inputs are compile-time only. Two defines which specify the starting    : 
1453			;     address of the heap and its size are required, along with a memory      : 
1453			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1453			;     principally stores a pointer to the first free block in the heap.       : 
1453			;                                                                             : 
1453			; Returns                                                                     : 
1453			;     Nothing                                                                 : 
1453			;------------------------------------------------------------------------------ 
1453			heap_init: 
1453			      push  HL 
1453			 
1453			      ; Initialise free list struct 
1453			      ld    HL, heap_start 
1453			      ld    (free_list), HL 
1453			      ld    HL, 0 
1453			      ld    (free_list+2), HL 
1453			 
1453			      ; Insert first free block at bottom of heap, consumes entire heap 
1453			      ld    HL, heap_start+heap_size-4 
1453			      ld    (heap_start), HL        ; Next block (end of free list) 
1453			      ld    HL, heap_size-4 
1453			      ld    (heap_start+2), HL      ; Block size 
1453			 
1453			      ; Insert end of free list block at top of heap - two null words will 
1453			      ; terminate the free list 
1453			      ld    HL, 0 
1453			      ld    (heap_start+heap_size-2), HL 
1453			      ld    (heap_start+heap_size-4), HL 
1453			 
1453			      pop   HL 
1453			 
1453			      ret 
1453			 
1453			 
1453			;------------------------------------------------------------------------------ 
1453			;     malloc                                                                  : 
1453			;                                                                             : 
1453			; Description                                                                 : 
1453			;     Allocates the wanted space from the heap and returns the address of the : 
1453			;     first useable byte of the allocation.                                   : 
1453			;                                                                             : 
1453			;     Allocations can happen in one of two ways:                              : 
1453			;                                                                             : 
1453			;     1. A free block may be found which is the exact size wanted. In this    : 
1453			;        case the block is removed from the free list and retuedn to the      : 
1453			;        caller.                                                              : 
1453			;     2. A free block may be found which is larger than the size wanted. In   : 
1453			;        this case, the larger block is split into two. The first portion of  : 
1453			;        this block will become the requested space by the malloc call and    : 
1453			;        is returned to the caller. The second portion becomes a new free     : 
1453			;        block, and the free list is adjusted to maintain continuity via this : 
1453			;        newly created block.                                                 : 
1453			;                                                                             : 
1453			;     malloc does not set any initial value in the allocated space, the       : 
1453			;     caller is required to do this as required.                              : 
1453			;                                                                             : 
1453			;     This implementation of malloc uses the stack exclusively, and is        : 
1453			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1453			;     advisable to disable interrupts before calling malloc, and recommended  : 
1453			;     to avoid the use of malloc inside ISRs in general.                      : 
1453			;                                                                             : 
1453			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1453			;                                                                             : 
1453			; Parameters                                                                  : 
1453			;     HL  Number of bytes wanted                                              : 
1453			;                                                                             : 
1453			; Returns                                                                     : 
1453			;     HL  Address of the first useable byte of the allocation                 : 
1453			;                                                                             : 
1453			; Flags                                                                       : 
1453			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1453			;                                                                             : 
1453			; Stack frame                                                                 : 
1453			;       |             |                                                       : 
1453			;       +-------------+                                                       : 
1453			;       |     BC      |                                                       : 
1453			;       +-------------+                                                       : 
1453			;       |     DE      |                                                       : 
1453			;       +-------------+                                                       : 
1453			;       |     IX      |                                                       : 
1453			;       +-------------+                                                       : 
1453			;       |  prev_free  |                                                       : 
1453			;   +4  +-------------+                                                       : 
1453			;       |  this_free  |                                                       : 
1453			;   +2  +-------------+                                                       : 
1453			;       |  next_free  |                                                       : 
1453			;   +0  +-------------+                                                       : 
1453			;       |             |                                                       : 
1453			;                                                                             : 
1453			;------------------------------------------------------------------------------ 
1453			malloc: 
1453			      push  BC 
1453			      push  DE 
1453			      push  IX 
1453			 
1453			      ld    A, H                    ; Exit if no space requested 
1453			      or    L 
1453			      jp    Z, malloc_early_exit 
1453			 
1453			      ; Set up stack frame 
1453			      ex    DE, HL 
1453			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1453			      add   HL, SP 
1453			      ld    SP, HL 
1453			      ld    IX, 0                   ; Use IX as a frame pointer 
1453			      add   IX, SP 
1453			 
1453			      ; Setup initial state 
1453			      ld    HL, 4                   ; want must also include space used by block struct 
1453			      add   HL, DE 
1453			 
1453			      ld    B, H                    ; Move want to BC 
1453			      ld    C, L 
1453			 
1453			      ld    HL, free_list           ; Store prev_free ptr to stack 
1453			      ld    (IX+4), L 
1453			      ld    (IX+5), H 
1453			 
1453			      ld    E, (HL)                 ; Store this_free ptr to stack 
1453			      inc   HL 
1453			      ld    D, (HL) 
1453			      ld    (IX+2), E 
1453			      ld    (IX+3), D 
1453			      ex    DE, HL                  ; this_free ptr into HL 
1453			 
1453			      ; Loop through free block list to find some space 
1453			malloc_find_space: 
1453			      ld    E, (HL)                 ; Load next_free ptr into DE 
1453			      inc   HL 
1453			      ld    D, (HL) 
1453			 
1453			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1453			      or    E 
1453			      jp    Z, malloc_no_space 
1453			 
1453			      ld    (IX+0), E               ; Store next_free ptr to stack 
1453			      ld    (IX+1), D 
1453			 
1453			      ; Does this block have enough space to make the allocation? 
1453			      inc   HL                      ; Load free block size into DE 
1453			      ld    E, (HL) 
1453			      inc   HL 
1453			      ld    D, (HL) 
1453			 
1453			      ex    DE, HL                  ; Check size of block against want 
1453			      or    A                       ; Ensure carry flag clear 
1453			      sbc   HL, BC 
1453			      push  HL                      ; Store the result for later (new block size) 
1453			 
1453			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1453			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1453			 
1453			      ; this_free block is not big enough, setup ptrs to test next free block 
1453			      pop   HL                      ; Discard previous result 
1453			 
1453			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1453			      ld    H, (IX+3) 
1453			      ld    (IX+4), L 
1453			      ld    (IX+5), H 
1453			 
1453			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1453			      ld    H, (IX+1) 
1453			      ld    (IX+2), L 
1453			      ld    (IX+3), H 
1453			 
1453			      jr    malloc_find_space 
1453			 
1453			      ; split a bigger block into two - requested size and remaining size 
1453			malloc_alloc_split: 
1453			      ex    DE, HL                  ; Calculate address of new free block 
1453			      dec   HL 
1453			      dec   HL 
1453			      dec   HL 
1453			      add   HL, BC 
1453			 
1453			      ; Create a new block and point it at next_free 
1453			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1453			      ld    D, (IX+1) 
1453			 
1453			      ld    (HL), E                 ; Store next_free ptr into new block 
1453			      inc   HL 
1453			      ld    (HL), D 
1453			 
1453			      pop   DE                      ; Store size of new block into new block 
1453			      inc   HL 
1453			      ld    (HL), E 
1453			      inc   HL 
1453			      ld    (HL), D 
1453			 
1453			      ; Update this_free ptr to point to new block 
1453			      dec   HL 
1453			      dec   HL 
1453			      dec   HL 
1453			 
1453			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1453			      ld    D, (IX+3) 
1453			 
1453			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1453			      ld    (IX+3), H 
1453			 
1453			      ; Modify this_free block to be allocation 
1453			      ex    DE, HL 
1453			      xor   A                       ; Null the next block ptr of allocated block 
1453			      ld    (HL), A 
1453			      inc   HL 
1453			      ld    (HL), A 
1453			 
1453			      inc   HL                      ; Store want size into allocated block 
1453			      ld    (HL), C 
1453			      inc   HL 
1453			      ld    (HL), B 
1453			      inc   HL 
1453			      push  HL                      ; Address of allocation to return 
1453			 
1453			      jr    malloc_update_links 
1453			 
1453			malloc_alloc_fit: 
1453			      pop   HL                      ; Dont need new block size, want is exact fit 
1453			 
1453			      ; Modify this_free block to be allocation 
1453			      ex    DE, HL 
1453			      dec   HL 
1453			      dec   HL 
1453			      dec   HL 
1453			 
1453			      xor   A                       ; Null the next block ptr of allocated block 
1453			      ld    (HL), A 
1453			      inc   HL 
1453			      ld    (HL), A 
1453			 
1453			      inc   HL                      ; Store address of allocation to return 
1453			      inc   HL 
1453			      inc   HL 
1453			      push  HL 
1453			 
1453			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1453			      ld    L, (IX+0)               ; next_free to HL 
1453			      ld    H, (IX+1) 
1453			 
1453			      ld    (IX+2), L               ; HL to this_free 
1453			      ld    (IX+3), H 
1453			 
1453			 
1453			malloc_update_links: 
1453			      ; Update prev_free ptr to point to this_free 
1453			      ld    L, (IX+4)               ; prev_free ptr to HL 
1453			      ld    H, (IX+5) 
1453			 
1453			      ld    E, (IX+2)               ; this_free ptr to DE 
1453			      ld    D, (IX+3) 
1453			 
1453			      ld    (HL), E                 ; this_free ptr into prev_free 
1453			      inc   HL 
1453			      ld    (HL), D 
1453			 
1453			      ; Clear the Z flag to indicate successful allocation 
1453			      ld    A, D 
1453			      or    E 
1453			 
1453			      pop   DE                      ; Address of allocation 
1453			 
1453			malloc_no_space: 
1453			      ld    HL, 6                   ; Clean up stack frame 
1453			      add   HL, SP 
1453			      ld    SP, HL 
1453			 
1453			      ex    DE, HL                  ; Alloc addr into HL for return 
1453			 
1453			malloc_early_exit: 
1453			      pop   IX 
1453			      pop   DE 
1453			      pop   BC 
1453			 
1453			      ret 
1453			 
1453			 
1453			;------------------------------------------------------------------------------ 
1453			;     free                                                                    : 
1453			;                                                                             : 
1453			; Description                                                                 : 
1453			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1453			;     returned by malloc, otherwise the behaviour is undefined.               : 
1453			;                                                                             : 
1453			;     Where possible, directly adjacent free blocks will be merged together   : 
1453			;     into larger blocks to help ensure that the heap does not become         : 
1453			;     excessively fragmented.                                                 : 
1453			;                                                                             : 
1453			;     free does not clear or set any other value into the freed space, and    : 
1453			;     therefore its contents may be visible through subsequent malloc's. The  : 
1453			;     caller should clear the freed space as required.                        : 
1453			;                                                                             : 
1453			;     This implementation of free uses the stack exclusively, and is          : 
1453			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1453			;     advisable to disable interrupts before calling free, and recommended    : 
1453			;     to avoid the use of free inside ISRs in general.                        : 
1453			;                                                                             : 
1453			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1453			;                                                                             : 
1453			; Parameters                                                                  : 
1453			;     HL  Pointer to address of first byte of allocation to be freed          : 
1453			;                                                                             : 
1453			; Returns                                                                     : 
1453			;     Nothing                                                                 : 
1453			;                                                                             : 
1453			; Stack frame                                                                 : 
1453			;       |             |                                                       : 
1453			;       +-------------+                                                       : 
1453			;       |     BC      |                                                       : 
1453			;       +-------------+                                                       : 
1453			;       |     DE      |                                                       : 
1453			;       +-------------+                                                       : 
1453			;       |     IX      |                                                       : 
1453			;       +-------------+                                                       : 
1453			;       |  prev_free  |                                                       : 
1453			;   +2  +-------------+                                                       : 
1453			;       |  next_free  |                                                       : 
1453			;   +0  +-------------+                                                       : 
1453			;       |             |                                                       : 
1453			;                                                                             : 
1453			;------------------------------------------------------------------------------ 
1453			free: 
1453			      push  BC 
1453			      push  DE 
1453			      push  IX 
1453			 
1453			      ld    A, H                    ; Exit if ptr is null 
1453			      or    L 
1453			      jp    Z, free_early_exit 
1453			 
1453			      ; Set up stack frame 
1453			      ex    DE, HL 
1453			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1453			      add   HL, SP 
1453			      ld    SP, HL 
1453			      ld    IX, 0                   ; Use IX as a frame pointer 
1453			      add   IX, SP 
1453			 
1453			      ; The address in HL points to the start of the useable allocated space, 
1453			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1453			      ; address of the block itself. 
1453			      ex    DE, HL 
1453			      ld    DE, -4 
1453			      add   HL, DE 
1453			 
1453			      ; An allocated block must have a null next block pointer in it 
1453			      ld    A, (HL) 
1453			      inc   HL 
1453			      or    (HL) 
1453			      jp    NZ, free_done 
1453			 
1453			      dec   HL 
1453			 
1453			      ld    B, H                    ; Copy HL to BC 
1453			      ld    C, L 
1453			 
1453			      ; Loop through the free list to find the first block with an address 
1453			      ; higher than the block being freed 
1453			      ld    HL, free_list 
1453			 
1453			free_find_higher_block: 
1453			      ld    E, (HL)                 ; Load next ptr from free block 
1453			      inc   HL 
1453			      ld    D, (HL) 
1453			      dec   HL 
1453			 
1453			      ld    (IX+0), E               ; Save ptr to next free block 
1453			      ld    (IX+1), D 
1453			      ld    (IX+2), L               ; Save ptr to prev free block 
1453			      ld    (IX+3), H 
1453			 
1453			      ld    A, B                    ; Check if DE is greater than BC 
1453			      cp    D                       ; Compare MSB first 
1453			      jr    Z, $+4                  ; MSB the same, compare LSB 
1453			      jr    NC, free_find_higher_block_skip 
1453			      ld    A, C 
1453			      cp    E                       ; Then compare LSB 
1453			      jr    C, free_found_higher_block 
1453			 
1453			free_find_higher_block_skip: 
1453			      ld    A, D                    ; Reached the end of the free list? 
1453			      or    E 
1453			      jp    Z, free_done 
1453			 
1453			      ex    DE, HL 
1453			 
1453			      jr    free_find_higher_block 
1453			 
1453			free_found_higher_block: 
1453			      ; Insert freed block between prev and next free blocks 
1453			      ld    (HL), C                 ; Point prev free block to freed block 
1453			      inc   HL 
1453			      ld    (HL), B 
1453			 
1453			      ld    H, B                    ; Point freed block at next free block 
1453			      ld    L, C 
1453			      ld    (HL), E 
1453			      inc   HL 
1453			      ld    (HL), D 
1453			 
1453			      ; Check if the freed block is adjacent to the next free block 
1453			      inc   HL                      ; Load size of freed block into HL 
1453			      ld    E, (HL) 
1453			      inc   HL 
1453			      ld    D, (HL) 
1453			      ex    DE, HL 
1453			 
1453			      add   HL, BC                  ; Add addr of freed block and its size 
1453			 
1453			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1453			      ld    D, (IX+1) 
1453			 
1453			      or    A                       ; Clear the carry flag 
1453			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1453			      jr    NZ, free_check_adjacent_to_prev 
1453			 
1453			      ; Freed block is adjacent to next, merge into one bigger block 
1453			      ex    DE, HL                  ; Load next ptr from next block into DE 
1453			      ld    E, (HL) 
1453			      inc   HL 
1453			      ld    D, (HL) 
1453			      push  HL                      ; Save ptr to next block for later 
1453			 
1453			      ld    H, B                    ; Store ptr from next block into freed block 
1453			      ld    L, C 
1453			      ld    (HL), E 
1453			      inc   HL 
1453			      ld    (HL), D 
1453			 
1453			      pop   HL                      ; Restore ptr to next block 
1453			      inc   HL                      ; Load size of next block into DE 
1453			      ld    E, (HL) 
1453			      inc   HL 
1453			      ld    D, (HL) 
1453			      push  DE                      ; Save next block size for later 
1453			 
1453			      ld    H, B                    ; Load size of freed block into HL 
1453			      ld    L, C 
1453			      inc   HL 
1453			      inc   HL 
1453			      ld    E, (HL) 
1453			      inc   HL 
1453			      ld    D, (HL) 
1453			      ex    DE, HL 
1453			 
1453			      pop   DE                      ; Restore size of next block 
1453			      add   HL, DE                  ; Add sizes of both blocks 
1453			      ex    DE, HL 
1453			 
1453			      ld    H, B                    ; Store new bigger size into freed block 
1453			      ld    L, C 
1453			      inc   HL 
1453			      inc   HL 
1453			      ld    (HL), E 
1453			      inc   HL 
1453			      ld    (HL), D 
1453			 
1453			free_check_adjacent_to_prev: 
1453			      ; Check if the freed block is adjacent to the prev free block 
1453			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1453			      ld    H, (IX+3) 
1453			 
1453			      inc   HL                      ; Size of prev free block into DE 
1453			      inc   HL 
1453			      ld    E, (HL) 
1453			      inc   HL 
1453			      ld    D, (HL) 
1453			      dec   HL 
1453			      dec   HL 
1453			      dec   HL 
1453			 
1453			      add   HL, DE                  ; Add prev block addr and size 
1453			 
1453			      or    A                       ; Clear the carry flag 
1453			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1453			      jr    NZ, free_done 
1453			 
1453			      ; Freed block is adjacent to prev, merge into one bigger block 
1453			      ld    H, B                    ; Load next ptr from freed block into DE 
1453			      ld    L, C 
1453			      ld    E, (HL) 
1453			      inc   HL 
1453			      ld    D, (HL) 
1453			      push  HL                      ; Save freed block ptr for later 
1453			 
1453			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1453			      ld    H, (IX+3) 
1453			      ld    (HL), E 
1453			      inc   HL 
1453			      ld    (HL), D 
1453			 
1453			      pop   HL                      ; Restore freed block ptr 
1453			      inc   HL                      ; Load size of freed block into DE 
1453			      ld    E, (HL) 
1453			      inc   HL 
1453			      ld    D, (HL) 
1453			      push  DE                      ; Save freed block size for later 
1453			 
1453			      ld    L, (IX+2)               ; Load size of prev block into DE 
1453			      ld    H, (IX+3) 
1453			      inc   HL 
1453			      inc   HL 
1453			      ld    E, (HL) 
1453			      inc   HL 
1453			      ld    D, (HL) 
1453			 
1453			      pop   HL                      ; Add sizes of both blocks 
1453			      add   HL, DE 
1453			      ex    DE, HL 
1453			 
1453			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1453			      ld    H, (IX+3) 
1453			      inc   HL 
1453			      inc   HL 
1453			      ld    (HL), E 
1453			      inc   HL 
1453			      ld    (HL), D 
1453			 
1453			free_done: 
1453			      ld    HL, 4                   ; Clean up stack frame 
1453			      add   HL, SP 
1453			      ld    SP, HL 
1453			 
1453			free_early_exit: 
1453			      pop   IX 
1453			      pop   DE 
1453			      pop   BC 
1453			 
1453			      ret 
1453			 
1453			 
1453			;      .org 0x8000 
1453			; 
1453			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1453			 ;                 .dw   0 
1453			 
1453			endif 
1453			 
1453			 
1453			if MALLOC_4 
1453			 
1453			; My memory allocation code. Very very simple.... 
1453			; allocate space under 250 chars 
1453			 
1453			heap_init: 
1453				; init start of heap as zero 
1453				;  
1453			 
1453				ld hl, heap_start 
1453				ld a, 0 
1453				ld (hl), a      ; empty block 
1453				inc hl 
1453				ld a, 0 
1453				ld (hl), a      ; length of block 
1453				; write end of list 
1453				inc hl 
1453				ld a,(hl) 
1453				inc hl 
1453				ld a,(hl) 
1453				 
1453			 
1453				; init some malloc vars 
1453			 
1453				ld hl, 0 
1453				ld (free_list), hl       ; store last malloc location 
1453			 
1453				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1453				ld a, 0 
1453				ld (hl), a 
1453			 
1453			 
1453				ld hl, heap_start 
1453				;  
1453				  
1453				ret 
1453			 
1453			 
1453			;    free block marker 
1453			;    requested size  
1453			;    pointer to next block 
1453			;    .... 
1453			;    next block marker 
1453			 
1453			 
1453			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1453			; 
1453			 
1453			 
1453			malloc:  
1453				push de 
1453				push bc 
1453				push af 
1453			 
1453				; hl space required 
1453				 
1453				ld c, l    ; hold space   (TODO only a max of 255) 
1453			 
1453			;	inc c     ; TODO BUG need to fix memory leak on push str 
1453			;	inc c 
1453			;	inc c 
1453			;	inc c 
1453			;	inc c 
1453			;	inc c 
1453			;	inc c 
1453			 
1453			 
1453			 
1453				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1453			 
1453				ld a, (free_list+3) 
1453				cp 0 
1453				jr z, .contheap 
1453			 
1453				ld hl, (free_list)     ; get last alloc 
1453					if DEBUG_FORTH_MALLOC_INT 
1453						DMARK "mrs" 
1453						CALLMONITOR 
1453					endif 
1453				jr .startalloc 
1453			 
1453			.contheap: 
1453				ld hl, heap_start 
1453			 
1453			.startalloc: 
1453			 
1453					if DEBUG_FORTH_MALLOC_INT 
1453						DMARK "mym" 
1453						CALLMONITOR 
1453					endif 
1453			.findblock: 
1453					if DEBUG_FORTH_MALLOC_INT 
1453						DMARK "mmf" 
1453						CALLMONITOR 
1453					endif 
1453			 
1453				ld a,(hl)  
1453				; if byte is zero then clear to use 
1453			 
1453				cp 0 
1453				jr z, .foundemptyblock 
1453			 
1453				; if byte is not clear 
1453				;     then byte is offset to next block 
1453			 
1453				inc hl 
1453				ld a, (hl) ; get size 
1453			.nextblock:	inc hl 
1453					ld e, (hl) 
1453					inc hl 
1453					ld d, (hl) 
1453					ex de, hl 
1453			;	inc hl  ; move past the store space 
1453			;	inc hl  ; move past zero index  
1453			 
1453				; TODO detect no more space 
1453			 
1453				push hl 
1453				ld de, heap_end 
1453				call cmp16 
1453				pop hl 
1453				jr nc, .nospace 
1453			 
1453				jr .findblock 
1453			 
1453			.nospace: ld hl, 0 
1453				jp .exit 
1453			 
1453			 
1453			.foundemptyblock:	 
1453					if DEBUG_FORTH_MALLOC_INT 
1453						DMARK "mme" 
1453						CALLMONITOR 
1453					endif 
1453			 
1453			; TODO has block enough space if reusing??? 
1453			 
1453				;  
1453			 
1453			; see if this block has been previously used 
1453				inc hl 
1453				ld a, (hl) 
1453				dec hl 
1453				cp 0 
1453				jr z, .newblock 
1453			 
1453					if DEBUG_FORTH_MALLOC_INT 
1453						DMARK "meR" 
1453						CALLMONITOR 
1453					endif 
1453			 
1453			; no reusing previously allocated block 
1453			 
1453			; is it smaller than previously used? 
1453				 
1453				inc hl    ; move to size 
1453				ld a, c 
1453				sub (hl)        ; we want c < (hl) 
1453				dec hl    ; move back to marker 
1453			        jr z, .findblock 
1453			 
1453				; update with the new size which should be lower 
1453			 
1453			        ;inc  hl   ; negate next move. move back to size  
1453			 
1453			.newblock: 
1453				; need to be at marker here 
1453			 
1453					if DEBUG_FORTH_MALLOC_INT 
1453						DMARK "meN" 
1453						CALLMONITOR 
1453					endif 
1453			 
1453			 
1453				ld a, c 
1453			 
1453				ld (free_list+3), a	 ; flag resume from last malloc  
1453				ld (free_list), hl    ; save out last location 
1453			 
1453			 
1453				;inc a     ; space for length byte 
1453				ld (hl), a     ; save block in use marker 
1453			 
1453				inc hl   ; move to space marker 
1453				ld (hl), a    ; save new space 
1453			 
1453				inc hl   ; move to start of allocated area 
1453				 
1453			;	push hl     ; save where we are - 1  
1453			 
1453			;	inc hl  ; move past zero index  
1453				; skip space to set down new marker 
1453			 
1453				; provide some extra space for now 
1453			 
1453				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1453				inc a 
1453				inc a 
1453			 
1453				push hl   ; save where we are in the node block 
1453			 
1453				call addatohl 
1453			 
1453				; write linked list point 
1453			 
1453				pop de     ; get our node position 
1453				ex de, hl 
1453			 
1453				ld (hl), e 
1453				inc hl 
1453				ld (hl), d 
1453			 
1453				inc hl 
1453			 
1453				; now at start of allocated data so save pointer 
1453			 
1453				push hl 
1453			 
1453				; jump to position of next node and setup empty header in DE 
1453			 
1453				ex de, hl 
1453			 
1453			;	inc hl ; move past end of block 
1453			 
1453				ld a, 0 
1453				ld (hl), a   ; empty marker 
1453				inc hl 
1453				ld (hl), a   ; size 
1453				inc hl  
1453				ld (hl), a   ; ptr 
1453				inc hl 
1453				ld (hl), a   ; ptr 
1453			 
1453			 
1453				pop hl 
1453			 
1453					if DEBUG_FORTH_MALLOC_INT 
1453						DMARK "mmr" 
1453						CALLMONITOR 
1453					endif 
1453			 
1453			.exit: 
1453				pop af 
1453				pop bc 
1453				pop de  
1453				ret 
1453			 
1453			 
1453			 
1453			 
1453			free:  
1453				push hl 
1453				push af 
1453				; get address in hl 
1453			 
1453					if DEBUG_FORTH_MALLOC_INT 
1453						DMARK "fre" 
1453						CALLMONITOR 
1453					endif 
1453				; data is at hl - move to block count 
1453				dec hl 
1453				dec hl    ; get past pointer 
1453				dec hl 
1453			 
1453				ld a, (hl)    ; need this for a validation check 
1453			 
1453				dec hl    ; move to block marker 
1453			 
1453				; now check that the block count and block marker are the same  
1453			        ; this checks that we are on a malloc node and not random memory 
1453			        ; OK a faint chance this could be a problem but rare - famous last words! 
1453			 
1453				ld c, a 
1453				ld a, (hl)    
1453			 
1453				cp c 
1453				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1453			 
1453				; yes good chance we are on a malloc node 
1453			 
1453				ld a, 0      
1453				ld (hl), a   ; mark as free 
1453			 
1453				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1453			 
1453			.freeignore:  
1453			 
1453				pop af 
1453				pop hl 
1453			 
1453				ret 
1453			 
1453			 
1453			 
1453			endif 
1453			 
1453			; eof 
# End of file firmware_memory.asm
1453			  
1453			; device C  
1453			if SOUND_ENABLE  
1453				include "firmware_sound.asm"  
1453			endif  
1453			  
1453			include "firmware_diags.asm"  
1453			; Hardware diags menu 
1453			 
1453			 
1453			config: 
1453			 
1453 3e 00			ld a, 0 
1455 21 83 14			ld hl, .configmn 
1458 cd f0 0b			call menu 
145b			 
145b fe 00			cp 0 
145d c8				ret z 
145e			 
145e fe 01			cp 1 
1460 cc 5c 15			call z, .savetostore 
1463			 
1463 fe 02			cp 2 
1465 cc aa 14			call z, .selautoload 
1468 fe 03			cp 3 
146a cc 93 14			call z, .disautoload 
146d fe 04			cp 4 
146f cc 5a 15			call z, .selbank 
1472 fe 05			cp 5 
1474 cc 37 16			call z, .debug_tog 
1477 fe 06			cp 6 
1479 cc 7a 17			call z, .bpsgo 
147c fe 07			cp 7 
147e cc 5d 16			call z, hardware_diags 
1481			 
1481 18 d0			jr config 
1483			 
1483			.configmn: 
1483 6b 19			dw prom_c3 
1485 82 19			dw prom_c2 
1487 97 19			dw prom_c2a 
1489 ad 19			dw prom_c2b 
148b			;	dw prom_c4 
148b ca 19			dw prom_m4 
148d e5 19			dw prom_m4b 
148f ed 19			dw prom_c1 
1491 00 00			dw 0 
1493				 
1493			 
1493			 
1493			 
1493			.disautoload: 
1493				if STORAGE_SE 
1493 3e fe			ld a, $fe      ; bit 0 clear 
1495 32 c5 fc			ld (spi_device), a 
1498			 
1498 cd 82 04			call storage_get_block_0 
149b			 
149b 3e 00			ld a, 0 
149d 32 00 fd			ld (store_page+STORE_0_AUTOFILE), a 
14a0			 
14a0 21 00 00				ld hl, 0 
14a3 11 df fc				ld de, store_page 
14a6 cd 36 04			call storage_write_block	 ; save update 
14a9				else 
14a9			 
14a9				ld hl, prom_notav 
14a9				ld de, prom_empty 
14a9				call info_panel 
14a9				endif 
14a9			 
14a9			 
14a9 c9				ret 
14aa			 
14aa			 
14aa			 
14aa			; Select auto start 
14aa			 
14aa			.selautoload: 
14aa			 
14aa				 
14aa				if STORAGE_SE 
14aa			 
14aa cd 81 15				call config_dir 
14ad 21 5a f4			        ld hl, scratch 
14b0 3e 00				ld a, 0 
14b2 cd f0 0b				call menu 
14b5			 
14b5 fe 00				cp 0 
14b7 c8					ret z 
14b8			 
14b8 3d					dec a 
14b9			 
14b9			 
14b9					; locate menu option 
14b9			 
14b9 21 5a f4				ld hl, scratch 
14bc cd 14 0b				call table_lookup 
14bf			 
14bf					if DEBUG_FORTH_WORDS 
14bf						DMARK "ALl" 
14bf f5				push af  
14c0 3a d4 14			ld a, (.dmark)  
14c3 32 b4 fe			ld (debug_mark),a  
14c6 3a d5 14			ld a, (.dmark+1)  
14c9 32 b5 fe			ld (debug_mark+1),a  
14cc 3a d6 14			ld a, (.dmark+2)  
14cf 32 b6 fe			ld (debug_mark+2),a  
14d2 18 03			jr .pastdmark  
14d4 ..			.dmark: db "ALl"  
14d7 f1			.pastdmark: pop af  
14d8			endm  
# End of macro DMARK
14d8						CALLMONITOR 
14d8 cd 70 17			call break_point_state  
14db				endm  
# End of macro CALLMONITOR
14db					endif 
14db					; with the pointer to the menu it, the byte following the zero term is the file id 
14db			 
14db 3e 00				ld a, 0 
14dd 01 32 00				ld bc, 50   ; max of bytes to look at 
14e0 ed b1				cpir  
14e2			 
14e2					if DEBUG_FORTH_WORDS 
14e2						DMARK "ALb" 
14e2 f5				push af  
14e3 3a f7 14			ld a, (.dmark)  
14e6 32 b4 fe			ld (debug_mark),a  
14e9 3a f8 14			ld a, (.dmark+1)  
14ec 32 b5 fe			ld (debug_mark+1),a  
14ef 3a f9 14			ld a, (.dmark+2)  
14f2 32 b6 fe			ld (debug_mark+2),a  
14f5 18 03			jr .pastdmark  
14f7 ..			.dmark: db "ALb"  
14fa f1			.pastdmark: pop af  
14fb			endm  
# End of macro DMARK
14fb						CALLMONITOR 
14fb cd 70 17			call break_point_state  
14fe				endm  
# End of macro CALLMONITOR
14fe					endif 
14fe					;inc hl 
14fe			 
14fe 7e					ld a, (hl)   ; file id 
14ff					 
14ff				        ; save bank and file ids 
14ff			 
14ff f5					push af 
1500			 
1500			; TODO need to save to block 0 on bank 1	 
1500			 
1500 cd 82 04				call storage_get_block_0 
1503			 
1503					if DEBUG_FORTH_WORDS 
1503						DMARK "AL0" 
1503 f5				push af  
1504 3a 18 15			ld a, (.dmark)  
1507 32 b4 fe			ld (debug_mark),a  
150a 3a 19 15			ld a, (.dmark+1)  
150d 32 b5 fe			ld (debug_mark+1),a  
1510 3a 1a 15			ld a, (.dmark+2)  
1513 32 b6 fe			ld (debug_mark+2),a  
1516 18 03			jr .pastdmark  
1518 ..			.dmark: db "AL0"  
151b f1			.pastdmark: pop af  
151c			endm  
# End of macro DMARK
151c						CALLMONITOR 
151c cd 70 17			call break_point_state  
151f				endm  
# End of macro CALLMONITOR
151f					endif 
151f f1					pop af 
1520			 
1520 32 03 fd				ld (store_page+STORE_0_FILERUN),a 
1523					 
1523					; save bank id 
1523			 
1523 3a c5 fc				ld a,(spi_device) 
1526 32 02 fd				ld (store_page+STORE_0_BANKRUN),a 
1529			 
1529					; enable auto run of store file 
1529			 
1529 3e 01				ld a, 1 
152b 32 00 fd				ld (store_page+STORE_0_AUTOFILE),a 
152e			 
152e					; save buffer 
152e			 
152e 21 00 00				ld hl, 0 
1531 11 df fc				ld de, store_page 
1534					if DEBUG_FORTH_WORDS 
1534						DMARK "ALw" 
1534 f5				push af  
1535 3a 49 15			ld a, (.dmark)  
1538 32 b4 fe			ld (debug_mark),a  
153b 3a 4a 15			ld a, (.dmark+1)  
153e 32 b5 fe			ld (debug_mark+1),a  
1541 3a 4b 15			ld a, (.dmark+2)  
1544 32 b6 fe			ld (debug_mark+2),a  
1547 18 03			jr .pastdmark  
1549 ..			.dmark: db "ALw"  
154c f1			.pastdmark: pop af  
154d			endm  
# End of macro DMARK
154d						CALLMONITOR 
154d cd 70 17			call break_point_state  
1550				endm  
# End of macro CALLMONITOR
1550					endif 
1550 cd 36 04			call storage_write_block	 ; save update 
1553			  
1553			 
1553			 
1553			 
1553 21 5a f4				ld hl, scratch 
1556 cd 6e 15				call config_fdir 
1559			 
1559				else 
1559			 
1559				ld hl, prom_notav 
1559				ld de, prom_empty 
1559				call info_panel 
1559			 
1559				endif 
1559 c9				ret 
155a			 
155a			 
155a			 
155a			; Select storage bank 
155a			 
155a			.selbank: 
155a			 
155a				if STORAGE_SE 
155a				else 
155a			 
155a				ld hl, prom_notav 
155a				ld de, prom_empty 
155a				call info_panel 
155a				endif 
155a				 
155a c9				ret 
155b			 
155b			if STORAGE_SE 
155b			 
155b			.config_ldir:   
155b				; Load storage bank labels into menu array 
155b			 
155b				 
155b			 
155b			 
155b c9				ret 
155c			 
155c			 
155c			endif 
155c			 
155c			 
155c			; Save user words to storage 
155c			 
155c			.savetostore: 
155c			 
155c				if STORAGE_SE 
155c			 
155c cd 81 15				call config_dir 
155f 21 5a f4			        ld hl, scratch 
1562 3e 00				ld a, 0 
1564 cd f0 0b				call menu 
1567					 
1567 21 5a f4				ld hl, scratch 
156a cd 6e 15				call config_fdir 
156d			 
156d				else 
156d			 
156d				ld hl, prom_notav 
156d				ld de, prom_empty 
156d				call info_panel 
156d			 
156d				endif 
156d			 
156d c9				ret 
156e			 
156e			 
156e			 
156e			if STORAGE_SE 
156e			 
156e			config_fdir: 
156e				; using the scratch dir go through and release the memory allocated for each string 
156e				 
156e 21 5a f4			ld hl, scratch 
1571 5e			.cfdir:	ld e,(hl) 
1572 23				inc hl 
1573 56				ld d,(hl) 
1574 23				inc hl 
1575			 
1575 eb				ex de, hl 
1576 cd 1c 0e			call ishlzero 
1579 c8				ret z     ; return on null pointer 
157a cd 84 13			call free 
157d eb				ex de, hl 
157e 18 f1			jr .cfdir 
1580			 
1580			 
1580 c9				ret 
1581			 
1581			 
1581			config_dir: 
1581			 
1581				; for the config menus that need to build a directory of storage call this routine 
1581				; it will construct a menu in scratch to pass to menu 
1581			 
1581				; open storage device 
1581			 
1581				; execute DIR to build a list of files and their ids into scratch in menu format 
1581				; once the menu has finished then will need to call config_fdir to release the strings 
1581				 
1581				; c = number items 
1581			 
1581				 
1581 cd 82 04			call storage_get_block_0 
1584			 
1584 21 df fc			ld hl, store_page     ; get current id count 
1587 46				ld b, (hl) 
1588 0e 00			ld c, 0    ; count of files   
158a			 
158a			 
158a 21 5a f4			ld hl, scratch 
158d 22 db fc			ld (store_tmp2), hl    ; location to poke strings 
1590			 
1590				; check for empty drive 
1590			 
1590 3e 00			ld a, 0 
1592 b8				cp b 
1593 ca 2d 16			jp z, .dirdone 
1596			 
1596				 
1596					if DEBUG_FORTH_WORDS 
1596						DMARK "Cdc" 
1596 f5				push af  
1597 3a ab 15			ld a, (.dmark)  
159a 32 b4 fe			ld (debug_mark),a  
159d 3a ac 15			ld a, (.dmark+1)  
15a0 32 b5 fe			ld (debug_mark+1),a  
15a3 3a ad 15			ld a, (.dmark+2)  
15a6 32 b6 fe			ld (debug_mark+2),a  
15a9 18 03			jr .pastdmark  
15ab ..			.dmark: db "Cdc"  
15ae f1			.pastdmark: pop af  
15af			endm  
# End of macro DMARK
15af						CALLMONITOR 
15af cd 70 17			call break_point_state  
15b2				endm  
# End of macro CALLMONITOR
15b2					endif 
15b2			 
15b2			 
15b2			.diritem:	 
15b2 c5				push bc 
15b3				; for each of the current ids do a search for them and if found push to stack 
15b3			 
15b3 21 40 00				ld hl, STORE_BLOCK_PHY 
15b6 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
15b8 58					ld e,b 
15b9			 
15b9 cd 04 07				call storage_findnextid 
15bc			 
15bc			 
15bc					; if found hl will be non zero 
15bc			 
15bc cd 1c 0e				call ishlzero 
15bf 28 69				jr z, .dirnotfound 
15c1			 
15c1					; increase count 
15c1			 
15c1 c1					pop bc	 
15c2 0c					inc c 
15c3 c5					push bc 
15c4					 
15c4			 
15c4					; get file header and push the file name 
15c4			 
15c4 11 df fc				ld de, store_page 
15c7 cd d1 03				call storage_read_block 
15ca			 
15ca					; push file id to stack 
15ca				 
15ca 3a df fc				ld a, (store_page) 
15cd 26 00				ld h, 0 
15cf 6f					ld l, a 
15d0			 
15d0					;call forth_push_numhl 
15d0					; TODO store id 
15d0			 
15d0 e5					push hl 
15d1			 
15d1					; push extent count to stack  
15d1				 
15d1 21 e2 fc				ld hl, store_page+3 
15d4			 
15d4					; get file name length 
15d4			 
15d4 cd 51 12				call strlenz   
15d7			 
15d7 23					inc hl   ; cover zero term 
15d8 23					inc hl  ; stick the id at the end of the area 
15d9			 
15d9 e5					push hl 
15da c1					pop bc    ; move length to bc 
15db			 
15db cd ba 12				call malloc 
15de			 
15de					; TODO save malloc area to scratch 
15de			 
15de eb					ex de, hl 
15df 2a db fc				ld hl, (store_tmp2) 
15e2 73					ld (hl), e 
15e3 23					inc hl 
15e4 72					ld (hl), d 
15e5 23					inc hl 
15e6 22 db fc				ld (store_tmp2), hl 
15e9			 
15e9					 
15e9			 
15e9					;pop hl   ; get source 
15e9			;		ex de, hl    ; swap aronund	 
15e9			 
15e9 21 e2 fc				ld hl, store_page+3 
15ec					if DEBUG_FORTH_WORDS 
15ec						DMARK "CFd" 
15ec f5				push af  
15ed 3a 01 16			ld a, (.dmark)  
15f0 32 b4 fe			ld (debug_mark),a  
15f3 3a 02 16			ld a, (.dmark+1)  
15f6 32 b5 fe			ld (debug_mark+1),a  
15f9 3a 03 16			ld a, (.dmark+2)  
15fc 32 b6 fe			ld (debug_mark+2),a  
15ff 18 03			jr .pastdmark  
1601 ..			.dmark: db "CFd"  
1604 f1			.pastdmark: pop af  
1605			endm  
# End of macro DMARK
1605						CALLMONITOR 
1605 cd 70 17			call break_point_state  
1608				endm  
# End of macro CALLMONITOR
1608					endif 
1608 ed b0				ldir 
160a			 
160a					; de is past string, move back one and store id 
160a					 
160a 1b					dec de 
160b			 
160b					; store file id 
160b			 
160b e1					pop hl 
160c eb					ex de,hl 
160d 73					ld (hl), e 
160e			 
160e					if DEBUG_FORTH_WORDS 
160e						DMARK "Cdi" 
160e f5				push af  
160f 3a 23 16			ld a, (.dmark)  
1612 32 b4 fe			ld (debug_mark),a  
1615 3a 24 16			ld a, (.dmark+1)  
1618 32 b5 fe			ld (debug_mark+1),a  
161b 3a 25 16			ld a, (.dmark+2)  
161e 32 b6 fe			ld (debug_mark+2),a  
1621 18 03			jr .pastdmark  
1623 ..			.dmark: db "Cdi"  
1626 f1			.pastdmark: pop af  
1627			endm  
# End of macro DMARK
1627						CALLMONITOR 
1627 cd 70 17			call break_point_state  
162a				endm  
# End of macro CALLMONITOR
162a					endif 
162a					 
162a			.dirnotfound: 
162a c1					pop bc     
162b 10 85				djnz .diritem 
162d				 
162d			.dirdone:	 
162d			 
162d 3e 00				ld a, 0 
162f 2a db fc				ld hl, (store_tmp2) 
1632 77					ld (hl), a 
1633 23					inc hl 
1634 77					ld (hl), a 
1635 23					inc hl 
1636					; push a count of the dir items found 
1636			 
1636			;		ld h, 0 
1636			;		ld l, c 
1636			 
1636 c9				ret 
1637			 
1637			endif 
1637			 
1637			 
1637			; Settings 
1637			; Run  
1637			 
1637			 
1637			 
1637			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1637			;;hd_menu2:   db "        2: Editor",0   
1637			;hd_menu2:   db "        2: Editor       6: Menu",0   
1637			;hd_menu3:   db "        3: Storage",0 
1637			;hd_menu4:   db "0=quit  4: Debug",0 
1637			;hd_don:     db "ON",0 
1637			;hd_doff:     db "OFF",0 
1637			; 
1637			; 
1637			; 
1637			;hardware_diags_old:       
1637			; 
1637			;.diagmenu: 
1637			;	call clear_display 
1637			;	ld a, display_row_1 
1637			;	ld de, hd_menu1 
1637			;	call str_at_display 
1637			; 
1637			;	ld a, display_row_2 
1637			;	ld de, hd_menu2 
1637			;	call str_at_display 
1637			; 
1637			;	ld a, display_row_3 
1637			;	ld de, hd_menu3 
1637			;	call str_at_display 
1637			; 
1637			;	ld a,  display_row_4 
1637			;	ld de, hd_menu4 
1637			;	call str_at_display 
1637			; 
1637			;	; display debug state 
1637			; 
1637			;	ld de, hd_don 
1637			;	ld a, (os_view_disable) 
1637			;	cp 0 
1637			;	jr z, .distog 
1637			;	ld de, hd_doff 
1637			;.distog: ld a, display_row_4+17 
1637			;	call str_at_display 
1637			; 
1637			;	call update_display 
1637			; 
1637			;	call cin_wait 
1637			; 
1637			; 
1637			; 
1637			;	cp '4' 
1637			;	jr nz, .diagn1 
1637			; 
1637			;	; debug toggle 
1637			; 
1637			;	ld a, (os_view_disable) 
1637			;	ld b, '*' 
1637			;	cp 0 
1637			;	jr z, .debtog 
1637			;	ld b, 0 
1637			;.debtog:	 
1637			;	ld a,b 
1637			;	ld (os_view_disable),a 
1637			; 
1637			;.diagn1: cp '0' 
1637			;	 ret z 
1637			; 
1637			;;	cp '1' 
1637			;;       jp z, matrix	 
1637			;;   TODO keyboard matrix test 
1637			; 
1637			;	cp '2' 
1637			;	jp z, .diagedit 
1637			; 
1637			;;	cp '6' 
1637			;;	jp z, .menutest 
1637			;;if ENABLE_BASIC 
1637			;;	cp '6' 
1637			;;	jp z, basic 
1637			;;endif 
1637			 ; 
1637			;	jp .diagmenu 
1637			; 
1637			; 
1637			;	ret 
1637			 
1637			 
1637			.debug_tog: 
1637 21 7e 16			ld hl, .menudebug 
163a				 
163a 3a 4b f4			ld a, (os_view_disable) 
163d fe 2a			cp '*' 
163f 20 04			jr nz,.tdon  
1641 3e 01			ld a, 1 
1643 18 02			jr .tog1 
1645 3e 00		.tdon: ld a, 0 
1647			 
1647			.tog1: 
1647 cd f0 0b			call menu 
164a fe 00			cp 0 
164c c8				ret z 
164d fe 01			cp 1    ; disable debug 
164f 28 04			jr z, .dtog0 
1651 3e 2a			ld a, '*' 
1653 18 02			jr .dtogset 
1655 3e 00		.dtog0: ld a, 0 
1657 32 4b f4		.dtogset:  ld (os_view_disable), a 
165a c3 37 16			jp .debug_tog 
165d			 
165d			 
165d			hardware_diags:       
165d			 
165d			.diagm: 
165d 21 70 16			ld hl, .menuitems 
1660 3e 00			ld a, 0 
1662 cd f0 0b			call menu 
1665			 
1665 fe 00		         cp 0 
1667 c8				 ret z 
1668			 
1668 fe 02			cp 2 
166a ca c9 16			jp z, .diagedit 
166d			 
166d			;	cp '6' 
166d			;	jp z, .menutest 
166d			;if ENABLE_BASIC 
166d			;	cp '6' 
166d			;	jp z, basic 
166d			;endif 
166d			  
166d c3 5d 16			jp .diagm 
1670			 
1670				 
1670 84 16		.menuitems:   	dw .m1 
1672 8f 16				dw .m2 
1674 96 16				dw .m3 
1676 9e 16				dw .m5 
1678 a4 16				dw .m5a 
167a ad 16				dw .m5b 
167c 00 00				dw 0 
167e			 
167e			.menudebug: 
167e b6 16				dw .m6 
1680 bf 16				dw .m7 
1682 00 00				dw 0 
1684			 
1684 .. 00		.m1:   db "Key Matrix",0 
168f .. 00		.m2:   db "Editor",0 
1696 .. 00		.m3:   db "Storage",0 
169e .. 00		.m5:   db "Sound",0 
16a4 .. 00		.m5a:  db "RAM Test",0 
16ad .. 00		.m5b:  db "LCD Test",0 
16b6			 
16b6 .. 00		.m6:   db "Debug ON",0 
16bf .. 00		.m7:   db "Debug OFF",0 
16c9			 
16c9			; debug editor 
16c9			 
16c9			.diagedit: 
16c9			 
16c9 21 5a f4			ld hl, scratch 
16cc			;	ld bc, 250 
16cc			;	ldir 
16cc				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
16cc 3e 00			ld a, 0 
16ce 77				ld (hl), a 
16cf 23				inc hl 
16d0 77				ld (hl), a 
16d1 23				inc hl 
16d2 77				ld (hl), a 
16d3			 
16d3 cd bf 0b		        call clear_display 
16d6 cd e2 0b			call update_display 
16d9				;ld a, 1 
16d9				;ld (hardware_diag), a 
16d9			.diloop: 
16d9 3e 00			ld a, display_row_1 
16db 0e 00			ld c, 0 
16dd 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
16df 1e 28			ld e, 40 
16e1			 
16e1 21 5a f4			ld hl, scratch	 
16e4 cd 20 0e			call input_str 
16e7			 
16e7 3e 14			ld a, display_row_2 
16e9 11 5a f4			ld de, scratch 
16ec cd d2 0b			call str_at_display 
16ef cd e2 0b			call update_display 
16f2			 
16f2 c3 d9 16			jp .diloop 
16f5			 
16f5			 
16f5			; pass word in hl 
16f5			; a has display location 
16f5			display_word_at: 
16f5 f5				push af 
16f6 e5				push hl 
16f7 7c				ld a,h 
16f8 21 5f f7			ld hl, os_word_scratch 
16fb cd f4 10			call hexout 
16fe e1				pop hl 
16ff 7d				ld a,l 
1700 21 61 f7			ld hl, os_word_scratch+2 
1703 cd f4 10			call hexout 
1706 21 63 f7			ld hl, os_word_scratch+4 
1709 3e 00			ld a,0 
170b 77				ld (hl),a 
170c 11 5f f7			ld de,os_word_scratch 
170f f1				pop af 
1710 cd d2 0b				call str_at_display 
1713 c9				ret 
1714			 
1714			display_ptr_state: 
1714			 
1714				; to restore afterwards 
1714			 
1714 d5				push de 
1715 c5				push bc 
1716 e5				push hl 
1717 f5				push af 
1718			 
1718				; for use in here 
1718			 
1718			;	push bc 
1718			;	push de 
1718			;	push hl 
1718			;	push af 
1718			 
1718 cd bf 0b			call clear_display 
171b			 
171b 11 ee 18			ld de, .ptrstate 
171e 3e 00			ld a, display_row_1 
1720 cd d2 0b			call str_at_display 
1723			 
1723				; display debug step 
1723			 
1723			 
1723 11 b4 fe			ld de, debug_mark 
1726 3e 12			ld a, display_row_1+display_cols-2 
1728 cd d2 0b			call str_at_display 
172b			 
172b				; display a 
172b 11 f8 18			ld de, .ptrcliptr 
172e 3e 14			ld a, display_row_2 
1730 cd d2 0b			call str_at_display 
1733			 
1733 f1				pop af 
1734 2a a5 fc			ld hl,(cli_ptr) 
1737 3e 1c			ld a, display_row_2+8 
1739 cd f5 16			call display_word_at 
173c			 
173c			 
173c				; display hl 
173c			 
173c			 
173c 11 00 19			ld de, .ptrclioptr 
173f 3e 1e			ld a, display_row_2+10 
1741 cd d2 0b			call str_at_display 
1744			; 
1744			;	pop hl 
1744 3e 21			ld a, display_row_2+13 
1746 2a a3 fc			ld hl,(cli_origptr) 
1749 cd f5 16			call display_word_at 
174c			; 
174c			;	 
174c			;	; display de 
174c			 
174c			;	ld de, .regstatede 
174c			;	ld a, display_row_3 
174c			;	call str_at_display 
174c			 
174c			;	pop de 
174c			;	ld h,d 
174c			;	ld l, e 
174c			;	ld a, display_row_3+3 
174c			;	call display_word_at 
174c			 
174c			 
174c				; display bc 
174c			 
174c			;	ld de, .regstatebc 
174c			;	ld a, display_row_3+10 
174c			;	call str_at_display 
174c			 
174c			;	pop bc 
174c			;	ld h,b 
174c			;	ld l, c 
174c			;	ld a, display_row_3+13 
174c			;	call display_word_at 
174c			 
174c			 
174c				; display dsp 
174c			 
174c			;	ld de, .regstatedsp 
174c			;	ld a, display_row_4 
174c			;	call str_at_display 
174c			 
174c				 
174c			;	ld hl,(cli_data_sp) 
174c			;	ld a, display_row_4+4 
174c			;	call display_word_at 
174c			 
174c				; display rsp 
174c			 
174c 11 2f 19			ld de, .regstatersp 
174f 3e 46			ld a, display_row_4+10 
1751 cd d2 0b			call str_at_display 
1754			 
1754				 
1754 2a 8b fc			ld hl,(cli_ret_sp) 
1757 3e 4a			ld a, display_row_4+14 
1759 cd f5 16			call display_word_at 
175c			 
175c cd e2 0b			call update_display 
175f			 
175f cd 3c 0b			call delay1s 
1762 cd 3c 0b			call delay1s 
1765 cd 3c 0b			call delay1s 
1768			 
1768			 
1768 cd 56 1d			call next_page_prompt 
176b			 
176b				; restore  
176b			 
176b f1				pop af 
176c e1				pop hl 
176d c1				pop bc 
176e d1				pop de 
176f c9				ret 
1770			 
1770			break_point_state: 
1770 f5				push af 
1771			 
1771				; see if disabled 
1771			 
1771 3a 4b f4			ld a, (os_view_disable) 
1774 fe 2a			cp '*' 
1776 20 02			jr nz, .bpsgo 
1778 f1				pop af 
1779 c9				ret 
177a			 
177a			.bpsgo: 
177a f1				pop af 
177b f5				push af 
177c 22 47 f4			ld (os_view_hl), hl 
177f ed 53 45 f4		ld (os_view_de), de 
1783 ed 43 43 f4		ld (os_view_bc), bc 
1787 e5				push hl 
1788 6f				ld l, a 
1789 26 00			ld h, 0 
178b 22 49 f4			ld (os_view_af),hl 
178e			 
178e 21 4a fe				ld hl, display_fb0 
1791 22 55 fd				ld (display_fb_active), hl 
1794 e1				pop hl	 
1795			 
1795 3e 31			ld a, '1' 
1797 fe 2a		.bps1:  cp '*' 
1799 20 03			jr nz, .bps1b 
179b 32 4b f4			ld (os_view_disable),a 
179e fe 31		.bps1b:  cp '1' 
17a0 20 14			jr nz, .bps2 
17a2			 
17a2				; display reg 
17a2			 
17a2				 
17a2			 
17a2 3a 49 f4			ld a, (os_view_af) 
17a5 2a 47 f4			ld hl, (os_view_hl) 
17a8 ed 5b 45 f4		ld de, (os_view_de) 
17ac ed 4b 43 f4		ld bc, (os_view_bc) 
17b0 cd 4a 18			call display_reg_state 
17b3 c3 36 18			jp .bpschk 
17b6			 
17b6 fe 32		.bps2:  cp '2' 
17b8 20 08			jr nz, .bps3 
17ba				 
17ba				; display hl 
17ba 2a 47 f4			ld hl, (os_view_hl) 
17bd cd 34 19			call display_dump_at_hl 
17c0			 
17c0 18 74			jr .bpschk 
17c2			 
17c2 fe 33		.bps3:  cp '3' 
17c4 20 08			jr nz, .bps4 
17c6			 
17c6			        ; display de 
17c6 2a 45 f4			ld hl, (os_view_de) 
17c9 cd 34 19			call display_dump_at_hl 
17cc			 
17cc 18 68			jr .bpschk 
17ce fe 34		.bps4:  cp '4' 
17d0 20 08			jr nz, .bps5 
17d2			 
17d2			        ; display bc 
17d2 2a 43 f4			ld hl, (os_view_bc) 
17d5 cd 34 19			call display_dump_at_hl 
17d8			 
17d8 18 5c			jr .bpschk 
17da fe 35		.bps5:  cp '5' 
17dc 20 08		        jr nz, .bps7 
17de			 
17de				; display cur ptr 
17de 2a a5 fc			ld hl, (cli_ptr) 
17e1 cd 34 19			call display_dump_at_hl 
17e4			 
17e4 18 50			jr .bpschk 
17e6 fe 36		.bps7:  cp '6' 
17e8 20 08			jr nz, .bps8b 
17ea				 
17ea				; display cur orig ptr 
17ea 2a a3 fc			ld hl, (cli_origptr) 
17ed cd 34 19			call display_dump_at_hl 
17f0 18 44			jr .bpschk 
17f2 fe 37		.bps8b:  cp '7' 
17f4 20 08			jr nz, .bps9 
17f6				 
17f6				; display dsp 
17f6 2a 87 fc			ld hl, (cli_data_sp) 
17f9 cd 34 19			call display_dump_at_hl 
17fc			 
17fc 18 38			jr .bpschk 
17fe fe 39		.bps9:  cp '9' 
1800 20 05			jr nz, .bps8c 
1802				 
1802				; display SP 
1802			;	ld hl, sp 
1802 cd 34 19			call display_dump_at_hl 
1805			 
1805 18 2f			jr .bpschk 
1807 fe 38		.bps8c:  cp '8' 
1809 20 08			jr nz, .bps8d 
180b				 
180b				; display rsp 
180b 2a 8b fc			ld hl, (cli_ret_sp) 
180e cd 34 19			call display_dump_at_hl 
1811			 
1811 18 23			jr .bpschk 
1813 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1815 20 05			jr nz, .bps8 
1817 cd 4c 1b			call monitor 
181a			 
181a 18 1a			jr .bpschk 
181c fe 30		.bps8:  cp '0' 
181e 20 16			jr nz, .bpschk 
1820			 
1820 21 f9 fd				ld hl, display_fb1 
1823 22 55 fd				ld (display_fb_active), hl 
1826 cd e2 0b				call update_display 
1829			 
1829				;ld a, (os_view_af) 
1829 2a 47 f4			ld hl, (os_view_hl) 
182c ed 5b 45 f4		ld de, (os_view_de) 
1830 ed 4b 43 f4		ld bc, (os_view_bc) 
1834 f1				pop af 
1835 c9				ret 
1836			 
1836			.bpschk:   
1836 cd 3c 0b			call delay1s 
1839 3e 4f		ld a,display_row_4 + display_cols - 1 
183b 11 54 1d		        ld de, endprg 
183e cd d2 0b			call str_at_display 
1841 cd e2 0b			call update_display 
1844 cd 4b 69			call cin_wait 
1847			 
1847 c3 97 17			jp .bps1 
184a			 
184a			 
184a			display_reg_state: 
184a			 
184a				; to restore afterwards 
184a			 
184a d5				push de 
184b c5				push bc 
184c e5				push hl 
184d f5				push af 
184e			 
184e				; for use in here 
184e			 
184e c5				push bc 
184f d5				push de 
1850 e5				push hl 
1851 f5				push af 
1852			 
1852 cd bf 0b			call clear_display 
1855			 
1855 11 0a 19			ld de, .regstate 
1858 3e 00			ld a, display_row_1 
185a cd d2 0b			call str_at_display 
185d			 
185d				; display debug step 
185d			 
185d			 
185d 11 b4 fe			ld de, debug_mark 
1860 3e 11			ld a, display_row_1+display_cols-3 
1862 cd d2 0b			call str_at_display 
1865			 
1865				; display a 
1865 11 26 19			ld de, .regstatea 
1868 3e 14			ld a, display_row_2 
186a cd d2 0b			call str_at_display 
186d			 
186d e1				pop hl 
186e			;	ld h,0 
186e			;	ld l, a 
186e 3e 17			ld a, display_row_2+3 
1870 cd f5 16			call display_word_at 
1873			 
1873			 
1873				; display hl 
1873			 
1873			 
1873 11 1a 19			ld de, .regstatehl 
1876 3e 1e			ld a, display_row_2+10 
1878 cd d2 0b			call str_at_display 
187b			 
187b e1				pop hl 
187c 3e 21			ld a, display_row_2+13 
187e cd f5 16			call display_word_at 
1881			 
1881				 
1881				; display de 
1881			 
1881 11 1e 19			ld de, .regstatede 
1884 3e 28			ld a, display_row_3 
1886 cd d2 0b			call str_at_display 
1889			 
1889 e1				pop hl 
188a			;	ld h,d 
188a			;	ld l, e 
188a 3e 2b			ld a, display_row_3+3 
188c cd f5 16			call display_word_at 
188f			 
188f			 
188f				; display bc 
188f			 
188f 11 22 19			ld de, .regstatebc 
1892 3e 32			ld a, display_row_3+10 
1894 cd d2 0b			call str_at_display 
1897			 
1897 e1				pop hl 
1898			;	ld h,b 
1898			;	ld l, c 
1898 3e 35			ld a, display_row_3+13 
189a cd f5 16			call display_word_at 
189d			 
189d			 
189d				; display dsp 
189d			 
189d 11 2a 19			ld de, .regstatedsp 
18a0 3e 3c			ld a, display_row_4 
18a2 cd d2 0b			call str_at_display 
18a5			 
18a5				 
18a5 2a 87 fc			ld hl,(cli_data_sp) 
18a8 3e 40			ld a, display_row_4+4 
18aa cd f5 16			call display_word_at 
18ad			 
18ad				; display rsp 
18ad			 
18ad 11 2f 19			ld de, .regstatersp 
18b0 3e 46			ld a, display_row_4+10 
18b2 cd d2 0b			call str_at_display 
18b5			 
18b5				 
18b5 2a 8b fc			ld hl,(cli_ret_sp) 
18b8 3e 4a			ld a, display_row_4+14 
18ba cd f5 16			call display_word_at 
18bd			 
18bd cd e2 0b			call update_display 
18c0			 
18c0			;	call delay1s 
18c0			;	call delay1s 
18c0			;	call delay1s 
18c0			 
18c0			 
18c0			;	call next_page_prompt 
18c0			 
18c0				; restore  
18c0			 
18c0 f1				pop af 
18c1 e1				pop hl 
18c2 c1				pop bc 
18c3 d1				pop de 
18c4 c9				ret 
18c5			 
18c5 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
18d9 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
18ee .. 00		.ptrstate:	db "Ptr State",0 
18f8 .. 00		.ptrcliptr:     db "cli_ptr",0 
1900 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
190a .. 00		.regstate:	db "Reg State (1/0)",0 
191a .. 00		.regstatehl:	db "HL:",0 
191e .. 00		.regstatede:	db "DE:",0 
1922 .. 00		.regstatebc:	db "BC:",0 
1926 .. 00		.regstatea:	db "A :",0 
192a .. 00		.regstatedsp:	db "DSP:",0 
192f .. 00		.regstatersp:	db "RSP:",0 
1934			 
1934			display_dump_at_hl: 
1934 e5				push hl 
1935 d5				push de 
1936 c5				push bc 
1937 f5				push af 
1938			 
1938 22 7d f7			ld (os_cur_ptr),hl	 
193b cd bf 0b			call clear_display 
193e cd 5e 1c			call dumpcont 
1941			;	call delay1s 
1941			;	call next_page_prompt 
1941			 
1941			 
1941 f1				pop af 
1942 c1				pop bc 
1943 d1				pop de 
1944 e1				pop hl 
1945 c9				ret 
1946			 
1946			;if ENABLE_BASIC 
1946			;	include "nascombasic.asm" 
1946			;	basic: 
1946			;	include "forth/FORTH.ASM" 
1946			;endif 
1946			 
1946			; eof 
1946			 
1946			 
# End of file firmware_diags.asm
1946			  
1946			include "firmware_prompts.asm"  
1946			; Prompts  
1946			 
1946			; boot messages 
1946			 
1946 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
195b .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
196b			 
196b			 
196b			; config menus 
196b			 
196b .. 00		prom_c3: db "Add Dictionary To File",0 
1982 .. 00		prom_c2: db "Select Autoload File",0 
1997 .. 00		prom_c2a: db "Disable Autoload File", 0 
19ad .. 00		prom_c2b: db "Select Storage Bank",0 
19c1 .. 00		prom_c4: db "Settings",0 
19ca .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
19e5 .. 00		prom_m4b:   db "Monitor",0 
19ed .. 00		prom_c1: db "Hardware Diags",0 
19fc			 
19fc			 
19fc .. 00		prom_notav:    db "Feature not available",0 
1a12 .. 00		prom_empty:    db "",0 
1a13			 
1a13			; eof 
1a13			 
# End of file firmware_prompts.asm
1a13			  
1a13			  
1a13			; eof  
1a13			  
# End of file firmware.asm
1a13			 
1a13			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1a13			;if BASE_KEV  
1a13			;baseram: equ 08000h 
1a13			;endif 
1a13			 
1a13			;if BASE_SC114 
1a13			;baseram:     equ    endofcode 
1a13			;endif 
1a13			 
1a13			 
1a13			; start system 
1a13			 
1a13			coldstart: 
1a13				; set sp 
1a13				; di/ei 
1a13			 
1a13 f3				di 
1a14 31 fd ff			ld sp, tos 
1a17			;	ei 
1a17			 
1a17			 
1a17				; disable breakpoint by default 
1a17			 
1a17 3e 2a			ld a,'*' 
1a19 32 4b f4			ld (os_view_disable),a 
1a1c			 
1a1c				; init hardware 
1a1c			 
1a1c				; init keyboard and screen hardware 
1a1c			 
1a1c cd 1c 00			call hardware_init 
1a1f			 
1a1f			 
1a1f cd 3c 0b			call delay1s 
1a22 3e 30			ld a, display_row_3+8 
1a24 11 03 00			ld de, .buildtime 
1a27 cd d2 0b			call str_at_display 
1a2a cd e2 0b			call update_display 
1a2d			 
1a2d cd 3c 0b			call delay1s 
1a30			 
1a30				; detect if any keys are held down to enable breakpoints at start up 
1a30			 
1a30 cd 5c 69			call cin  
1a33 fe 00			cp 0 
1a35 28 03			jr z, .nokeys 
1a37			 
1a37				;call hardware_diags 
1a37 cd 53 14			call config 
1a3a			 
1a3a			;	ld de, .bpen 
1a3a			;	ld a, display_row_4 
1a3a			;	call str_at_display 
1a3a			;	call update_display 
1a3a			; 
1a3a			;	ld a,0 
1a3a			;	ld (os_view_disable),a 
1a3a			; 
1a3a			;.bpwait: 
1a3a			;	call cin 
1a3a			;	cp 0 
1a3a			;	jr z, .bpwait 
1a3a			;	jr .nokeys 
1a3a			; 
1a3a			; 
1a3a			;.bpen:  db "Break points enabled!",0 
1a3a			 
1a3a			 
1a3a			 
1a3a			 
1a3a			 
1a3a			 
1a3a			.nokeys: 
1a3a			 
1a3a			 
1a3a				 
1a3a			 
1a3a			;jp  testkey 
1a3a			 
1a3a			;call storage_get_block_0 
1a3a			; 
1a3a			;ld hl, 0 
1a3a			;ld de, store_page 
1a3a			;call storage_read_block 
1a3a			 
1a3a				 
1a3a			;ld hl, 10 
1a3a			;ld de, store_page 
1a3a			;call storage_read_block 
1a3a			 
1a3a			 
1a3a			 
1a3a			 
1a3a			 
1a3a			;stop:	nop 
1a3a			;	jp stop 
1a3a			 
1a3a			 
1a3a			 
1a3a			main: 
1a3a cd bf 0b			call clear_display 
1a3d cd e2 0b			call update_display 
1a40			 
1a40			 
1a40			 
1a40			;	call testlcd 
1a40			 
1a40			 
1a40			 
1a40 cd 1c 21			call forth_init 
1a43			 
1a43			 
1a43			warmstart: 
1a43 cd f2 20			call forth_warmstart 
1a46			 
1a46				; run startup word load 
1a46			        ; TODO prevent this running at warmstart after crash  
1a46			 
1a46				if STARTUP_ENABLE 
1a46					if STORAGE_SE 
1a46 cd 8d 66					call forth_autoload 
1a49					endif 
1a49 cd 9c 63				call forth_startup 
1a4c			 
1a4c			 
1a4c				endif 
1a4c			 
1a4c				; show free memory after boot 
1a4c 11 e6 1a			ld de, freeram 
1a4f 3e 00			ld a, display_row_1 
1a51 cd d2 0b			call str_at_display 
1a54			 
1a54			; Or use heap_size word???? 
1a54 21 40 f4			ld hl, heap_end 
1a57 11 0e 80			ld de, heap_start 
1a5a ed 52			sbc hl, de 
1a5c e5				push hl 
1a5d 7c				ld a,h	         	 
1a5e 21 5f f7			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1a61 cd f4 10			call hexout 
1a64 e1			   	pop hl 
1a65			 
1a65 7d				ld a,l 
1a66 21 61 f7			ld hl, os_word_scratch+2 
1a69 cd f4 10			call hexout 
1a6c 21 63 f7			ld hl, os_word_scratch+4 
1a6f 3e 00			ld a, 0 
1a71 77				ld (hl),a 
1a72 11 5f f7			ld de, os_word_scratch 
1a75 3e 0d			ld a, display_row_1 + 13 
1a77 cd d2 0b			call str_at_display 
1a7a cd e2 0b			call update_display 
1a7d			 
1a7d			 
1a7d				;call demo 
1a7d			 
1a7d			 
1a7d				; init scratch input area for cli commands 
1a7d			 
1a7d 21 81 f7			ld hl, os_cli_cmd 
1a80 3e 00			ld a,0 
1a82 77				ld (hl),a 
1a83 23				inc hl 
1a84 77				ld (hl),a 
1a85			 
1a85 3e 00			ld a,0 
1a87 32 80 f8			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1a8a			 
1a8a 32 7d f7			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1a8d 32 7e f7			ld (os_cur_ptr+1),a	 
1a90			 
1a90 32 5f f7			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1a93 32 60 f7			ld (os_word_scratch+1),a	 
1a96				 
1a96			 
1a96				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1a96 21 81 f7			ld hl, os_cli_cmd 
1a99			 
1a99 3e 00			ld a, 0		 ; init cli input 
1a9b 77				ld (hl), a 
1a9c 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1a9e			cli: 
1a9e				; show cli prompt 
1a9e				;push af 
1a9e				;ld a, 0 
1a9e				;ld de, prompt 
1a9e				;call str_at_display 
1a9e			 
1a9e				;call update_display 
1a9e				;pop af 
1a9e				;inc a 
1a9e				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1a9e 0e 00			ld c, 0 
1aa0 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1aa2 1e 28			ld e, 40 
1aa4			 
1aa4 21 81 f7			ld hl, os_cli_cmd 
1aa7			 
1aa7				STACKFRAME OFF $fefe $9f9f 
1aa7				if DEBUG_STACK_IMB 
1aa7					if OFF 
1aa7						exx 
1aa7						ld de, $fefe 
1aa7						ld a, d 
1aa7						ld hl, curframe 
1aa7						call hexout 
1aa7						ld a, e 
1aa7						ld hl, curframe+2 
1aa7						call hexout 
1aa7						ld hl, $fefe 
1aa7						push hl 
1aa7						ld hl, $9f9f 
1aa7						push hl 
1aa7						exx 
1aa7					endif 
1aa7				endif 
1aa7			endm 
# End of macro STACKFRAME
1aa7			 
1aa7 cd 20 0e			call input_str 
1aaa			 
1aaa				STACKFRAMECHK OFF $fefe $9f9f 
1aaa				if DEBUG_STACK_IMB 
1aaa					if OFF 
1aaa						exx 
1aaa						ld hl, $9f9f 
1aaa						pop de   ; $9f9f 
1aaa						call cmp16 
1aaa						jr nz, .spnosame 
1aaa						ld hl, $fefe 
1aaa						pop de   ; $fefe 
1aaa						call cmp16 
1aaa						jr z, .spfrsame 
1aaa						.spnosame: call showsperror 
1aaa						.spfrsame: nop 
1aaa						exx 
1aaa					endif 
1aaa				endif 
1aaa			endm 
# End of macro STACKFRAMECHK
1aaa			 
1aaa				; copy input to last command 
1aaa			 
1aaa 21 81 f7			ld hl, os_cli_cmd 
1aad 11 80 f8			ld de, os_last_cmd 
1ab0 01 ff 00			ld bc, 255 
1ab3 ed b0			ldir 
1ab5			 
1ab5				; wipe current buffer 
1ab5			 
1ab5			;	ld a, 0 
1ab5			;	ld hl, os_cli_cmd 
1ab5			;	ld de, os_cli_cmd+1 
1ab5			;	ld bc, 254 
1ab5			;	ldir 
1ab5				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1ab5			;	call strcpy 
1ab5			;	ld a, 0 
1ab5			;	ld (hl), a 
1ab5			;	inc hl 
1ab5			;	ld (hl), a 
1ab5			;	inc hl 
1ab5			;	ld (hl), a 
1ab5			 
1ab5				; switch frame buffer to program  
1ab5			 
1ab5 21 f9 fd				ld hl, display_fb1 
1ab8 22 55 fd				ld (display_fb_active), hl 
1abb			 
1abb			;	nop 
1abb				STACKFRAME ON $fbfe $8f9f 
1abb				if DEBUG_STACK_IMB 
1abb					if ON 
1abb						exx 
1abb						ld de, $fbfe 
1abb						ld a, d 
1abb						ld hl, curframe 
1abb						call hexout 
1abb						ld a, e 
1abb						ld hl, curframe+2 
1abb						call hexout 
1abb						ld hl, $fbfe 
1abb						push hl 
1abb						ld hl, $8f9f 
1abb						push hl 
1abb						exx 
1abb					endif 
1abb				endif 
1abb			endm 
# End of macro STACKFRAME
1abb				; first time into the parser so pass over the current scratch pad 
1abb 21 81 f7			ld hl,os_cli_cmd 
1abe				; tokenise the entered statement(s) in HL 
1abe cd 95 21			call forthparse 
1ac1			        ; exec forth statements in top of return stack 
1ac1 cd d5 21			call forthexec 
1ac4				;call forthexec_cleanup 
1ac4			;	call parsenext 
1ac4			 
1ac4				STACKFRAMECHK ON $fbfe $8f9f 
1ac4				if DEBUG_STACK_IMB 
1ac4					if ON 
1ac4						exx 
1ac4						ld hl, $8f9f 
1ac4						pop de   ; $8f9f 
1ac4						call cmp16 
1ac4						jr nz, .spnosame 
1ac4						ld hl, $fbfe 
1ac4						pop de   ; $fbfe 
1ac4						call cmp16 
1ac4						jr z, .spfrsame 
1ac4						.spnosame: call showsperror 
1ac4						.spfrsame: nop 
1ac4						exx 
1ac4					endif 
1ac4				endif 
1ac4			endm 
# End of macro STACKFRAMECHK
1ac4				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1ac4			 
1ac4 3e 3c			ld a, display_row_4 
1ac6 11 f8 1a			ld de, endprog 
1ac9			 
1ac9 cd e2 0b			call update_display		 
1acc			 
1acc cd 56 1d			call next_page_prompt 
1acf			 
1acf				; switch frame buffer to cli 
1acf			 
1acf 21 4a fe				ld hl, display_fb0 
1ad2 22 55 fd				ld (display_fb_active), hl 
1ad5			 
1ad5			 
1ad5 cd bf 0b		        call clear_display 
1ad8 cd e2 0b			call update_display		 
1adb			 
1adb 21 81 f7			ld hl, os_cli_cmd 
1ade			 
1ade 3e 00			ld a, 0		 ; init cli input 
1ae0 77				ld (hl), a 
1ae1			 
1ae1				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1ae1			 
1ae1				; now on last line 
1ae1			 
1ae1				; TODO scroll screen up 
1ae1			 
1ae1				; TODO instead just clear screen and place at top of screen 
1ae1			 
1ae1			;	ld a, 0 
1ae1			;	ld (f_cursor_ptr),a 
1ae1			 
1ae1				;call clear_display 
1ae1				;call update_display 
1ae1			 
1ae1				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ae1 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ae3 c3 9e 1a			jp cli 
1ae6			 
1ae6 .. 00		freeram: db "Free bytes: $",0 
1af4 ..			asc: db "1A2F" 
1af8 .. 00		endprog: db "End prog...",0 
1b04			 
1b04			testenter2:   
1b04 21 8c f4			ld hl,scratch+50 
1b07 22 7d f7			ld (os_cur_ptr),hl 
1b0a c3 9e 1a			jp cli 
1b0d			 
1b0d			testenter:  
1b0d			 
1b0d 21 f4 1a			ld hl,asc 
1b10			;	ld a,(hl) 
1b10			;	call nibble2val 
1b10 cd 4a 11			call get_byte 
1b13			 
1b13			 
1b13			;	ld a,(hl) 
1b13			;	call atohex 
1b13			 
1b13			;	call fourehexhl 
1b13 32 8c f4			ld (scratch+50),a 
1b16			 
1b16			 
1b16			 
1b16 21 f6 1a			ld hl,asc+2 
1b19			;	ld a, (hl) 
1b19			;	call nibble2val 
1b19 cd 4a 11			call get_byte 
1b1c			 
1b1c			;	call fourehexhl 
1b1c 32 8e f4			ld (scratch+52),a 
1b1f				 
1b1f 21 8c f4			ld hl,scratch+50 
1b22 22 7d f7			ld (os_cur_ptr),hl 
1b25 c3 9e 1a			jp cli 
1b28			 
1b28			enter:	 
1b28 3a 5e f4			ld a,(scratch+4) 
1b2b fe 00			cp 0 
1b2d 28 0c			jr z, .entercont 
1b2f				; no, not a null term line so has an address to work out.... 
1b2f			 
1b2f 21 5c f4			ld hl,scratch+2 
1b32 cd aa 11			call get_word_hl 
1b35			 
1b35 22 7d f7			ld (os_cur_ptr),hl	 
1b38 c3 9e 1a			jp cli 
1b3b			 
1b3b			 
1b3b			.entercont:  
1b3b			 
1b3b 21 5c f4			ld hl, scratch+2 
1b3e cd 4a 11			call get_byte 
1b41			 
1b41 2a 7d f7		   	ld hl,(os_cur_ptr) 
1b44 77					ld (hl),a 
1b45 23					inc hl 
1b46 22 7d f7				ld (os_cur_ptr),hl 
1b49				 
1b49			; get byte  
1b49			 
1b49			 
1b49 c3 9e 1a			jp cli 
1b4c			 
1b4c			 
1b4c			; basic monitor support 
1b4c			 
1b4c			monitor: 
1b4c				;  
1b4c cd bf 0b			call clear_display 
1b4f 3e 00			ld a, 0 
1b51 11 99 1b			ld de, .monprompt 
1b54 cd d2 0b			call str_at_display 
1b57 cd e2 0b			call update_display 
1b5a			 
1b5a				; get a monitor command 
1b5a			 
1b5a 0e 00			ld c, 0     ; entry at top left 
1b5c 16 64			ld d, 100   ; max buffer size 
1b5e 1e 0f			ld e, 15    ; input scroll area 
1b60 3e 00			ld a, 0     ; init string 
1b62 21 58 f6			ld hl, os_input 
1b65 77				ld (hl), a 
1b66 23				inc hl 
1b67 77				ld (hl), a 
1b68 21 58 f6			ld hl, os_input 
1b6b 3e 01			ld a, 1     ; init string 
1b6d cd 20 0e			call input_str 
1b70			 
1b70 cd bf 0b		        call clear_display 
1b73 cd e2 0b			call update_display		 
1b76			 
1b76 3a 58 f6			ld a, (os_input) 
1b79 cd 48 12			call toUpper 
1b7c fe 48		        cp 'H' 
1b7e 28 6f		        jr z, .monhelp 
1b80 fe 44			cp 'D'		; dump 
1b82 ca 10 1c			jp z, .mondump	 
1b85 fe 43			cp 'C'		; dump 
1b87 ca 2a 1c			jp z, .moncdump	 
1b8a fe 4d			cp 'M'		; dump 
1b8c ca 9b 1b			jp z, .moneditstart 
1b8f fe 55			cp 'U'		; dump 
1b91 28 14			jr z, .monedit	 
1b93 fe 51			cp 'Q'		; dump 
1b95 c8				ret z	 
1b96			 
1b96			 
1b96				; TODO "S" to access symbol by name and not need the address 
1b96				; TODO "F" to find a string in memory 
1b96			 
1b96 c3 4c 1b			jp monitor 
1b99			 
1b99 .. 00		.monprompt: db ">", 0 
1b9b			 
1b9b			.moneditstart: 
1b9b				; get starting address 
1b9b			 
1b9b 21 5a f6			ld hl,os_input+2 
1b9e cd aa 11			call get_word_hl 
1ba1			 
1ba1 22 7d f7			ld (os_cur_ptr),hl	 
1ba4			 
1ba4 c3 4c 1b			jp monitor 
1ba7			 
1ba7			.monedit: 
1ba7				; get byte to load 
1ba7			 
1ba7 21 5a f6			ld hl,os_input+2 
1baa cd 4a 11			call get_byte 
1bad			 
1bad				; get address to update 
1bad 2a 7d f7			ld hl, (os_cur_ptr) 
1bb0			 
1bb0				; update byte 
1bb0			 
1bb0 77				ld (hl), a 
1bb1			 
1bb1				; move to next address and save it 
1bb1			 
1bb1 23				inc hl 
1bb2 22 7d f7			ld (os_cur_ptr),hl	 
1bb5			 
1bb5 c3 4c 1b			jp monitor 
1bb8			 
1bb8			 
1bb8 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1bcc .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1be8 .. 00		.monhelptext3:  db "Q-Quit",0 
1bef			        
1bef			.monhelp: 
1bef 3e 00			ld a, display_row_1 
1bf1 11 b8 1b		        ld de, .monhelptext1 
1bf4			 
1bf4 cd d2 0b			call str_at_display 
1bf7 3e 14			ld a, display_row_2 
1bf9 11 cc 1b		        ld de, .monhelptext2 
1bfc					 
1bfc cd d2 0b			call str_at_display 
1bff 3e 28			ld a, display_row_3 
1c01 11 e8 1b		        ld de, .monhelptext3 
1c04					 
1c04 cd d2 0b			call str_at_display 
1c07 cd e2 0b			call update_display		 
1c0a			 
1c0a cd 56 1d			call next_page_prompt 
1c0d c3 4c 1b			jp monitor 
1c10			 
1c10			.mondump:    
1c10 21 5a f6			ld hl,os_input+2 
1c13 cd aa 11			call get_word_hl 
1c16			 
1c16 22 7d f7			ld (os_cur_ptr),hl	 
1c19 cd 5e 1c			call dumpcont 
1c1c 3e 3c			ld a, display_row_4 
1c1e 11 f8 1a			ld de, endprog 
1c21			 
1c21 cd e2 0b			call update_display		 
1c24			 
1c24 cd 56 1d			call next_page_prompt 
1c27 c3 4c 1b			jp monitor 
1c2a			.moncdump: 
1c2a cd 5e 1c			call dumpcont 
1c2d 3e 3c			ld a, display_row_4 
1c2f 11 f8 1a			ld de, endprog 
1c32			 
1c32 cd e2 0b			call update_display		 
1c35			 
1c35 cd 56 1d			call next_page_prompt 
1c38 c3 4c 1b			jp monitor 
1c3b			 
1c3b			 
1c3b			; TODO symbol access  
1c3b			 
1c3b			.symbols:     ;; A list of symbols that can be called up  
1c3b 4a fe			dw display_fb0 
1c3d .. 00			db "fb0",0  
1c41 df fc		     	dw store_page 
1c43 .. 00			db "store_page",0 
1c4e			 
1c4e			 
1c4e			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1c4e			 
1c4e 3a 5b f4			ld a,(scratch+1) 
1c51 fe 00			cp 0 
1c53 28 09			jr z, dumpcont 
1c55			 
1c55				; no, not a null term line so has an address to work out.... 
1c55			 
1c55 21 5c f4			ld hl,scratch+2 
1c58 cd aa 11			call get_word_hl 
1c5b			 
1c5b 22 7d f7			ld (os_cur_ptr),hl	 
1c5e			 
1c5e			 
1c5e			 
1c5e			dumpcont: 
1c5e			 
1c5e				; dump bytes at ptr 
1c5e			 
1c5e			 
1c5e 3e 00			ld a, display_row_1 
1c60 2a 55 fd			ld hl, (display_fb_active) 
1c63 cd f3 0d			call addatohl 
1c66 cd 8e 1c			call .dumpbyterow 
1c69			 
1c69 3e 14			ld a, display_row_2 
1c6b 2a 55 fd			ld hl, (display_fb_active) 
1c6e cd f3 0d			call addatohl 
1c71 cd 8e 1c			call .dumpbyterow 
1c74			 
1c74			 
1c74 3e 28			ld a, display_row_3 
1c76 2a 55 fd			ld hl, (display_fb_active) 
1c79 cd f3 0d			call addatohl 
1c7c cd 8e 1c			call .dumpbyterow 
1c7f			 
1c7f 3e 3c			ld a, display_row_4 
1c81 2a 55 fd			ld hl, (display_fb_active) 
1c84 cd f3 0d			call addatohl 
1c87 cd 8e 1c			call .dumpbyterow 
1c8a			 
1c8a cd e2 0b			call update_display 
1c8d			;		jp cli 
1c8d c9				ret 
1c8e			 
1c8e			.dumpbyterow: 
1c8e			 
1c8e				;push af 
1c8e			 
1c8e e5				push hl 
1c8f			 
1c8f				; calc where to poke the ascii 
1c8f			if display_cols == 20 
1c8f 3e 10			ld a, 16 
1c91			else 
1c91				ld a, 31 
1c91			endif 
1c91			 
1c91 cd f3 0d			call addatohl 
1c94 22 5f f7			ld (os_word_scratch),hl  		; save pos for later 
1c97			 
1c97			 
1c97			; display decoding address 
1c97 2a 7d f7		   	ld hl,(os_cur_ptr) 
1c9a			 
1c9a 7c				ld a,h 
1c9b e1				pop hl 
1c9c e5				push hl 
1c9d			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1c9d cd f4 10			call hexout 
1ca0 2a 7d f7		   	ld hl,(os_cur_ptr) 
1ca3			 
1ca3 7d				ld a,l 
1ca4 e1				pop hl 
1ca5 23				inc hl 
1ca6 23				inc hl 
1ca7 e5				push hl 
1ca8			;	ld hl, os_word_scratch+2 
1ca8 cd f4 10			call hexout 
1cab e1				pop hl 
1cac 23				inc hl 
1cad 23				inc hl 
1cae				;ld hl, os_word_scratch+4 
1cae 3e 3a			ld a, ':' 
1cb0 77				ld (hl),a 
1cb1 23				inc hl 
1cb2				;ld a, 0 
1cb2				;ld (hl),a 
1cb2				;ld de, os_word_scratch 
1cb2				;pop af 
1cb2				;push af 
1cb2			;		ld a, display_row_2 
1cb2			;		call str_at_display 
1cb2			;		call update_display 
1cb2			 
1cb2			 
1cb2			;pop af 
1cb2			;	add 5 
1cb2			 
1cb2			if display_cols == 20 
1cb2 06 04			ld b, 4 
1cb4			else 
1cb4				ld b, 8 
1cb4			endif	 
1cb4			 
1cb4			.dumpbyte: 
1cb4 c5				push bc 
1cb5 e5				push hl 
1cb6			 
1cb6			 
1cb6 2a 7d f7		   	ld hl,(os_cur_ptr) 
1cb9 7e					ld a,(hl) 
1cba			 
1cba					; poke the ascii to display 
1cba 2a 5f f7				ld hl,(os_word_scratch) 
1cbd 77					ld (hl),a 
1cbe 23					inc hl 
1cbf 22 5f f7				ld (os_word_scratch),hl 
1cc2			 
1cc2					 
1cc2			 
1cc2			 
1cc2 e1					pop hl 
1cc3 e5					push hl 
1cc4			 
1cc4 cd f4 10				call hexout 
1cc7			 
1cc7					 
1cc7 2a 7d f7		   	ld hl,(os_cur_ptr) 
1cca 23				inc hl 
1ccb 22 7d f7		   	ld (os_cur_ptr),hl 
1cce			 
1cce e1					pop hl 
1ccf 23					inc hl 
1cd0 23					inc hl 
1cd1 23					inc hl 
1cd2			 
1cd2			 
1cd2			 
1cd2					;ld a,0 
1cd2					;ld (os_word_scratch+2),a 
1cd2					;pop af 
1cd2					;push af 
1cd2			 
1cd2					;ld de, os_word_scratch 
1cd2					;call str_at_display 
1cd2			;		call update_display 
1cd2			;		pop af 
1cd2 c1					pop bc 
1cd3 c6 03				add 3 
1cd5 10 dd			djnz .dumpbyte 
1cd7			 
1cd7				 
1cd7			 
1cd7 c9				ret 
1cd8			 
1cd8			jump:	 
1cd8			 
1cd8 21 5c f4			ld hl,scratch+2 
1cdb cd aa 11			call get_word_hl 
1cde				;ld hl,(scratch+2) 
1cde				;call fourehexhl 
1cde			 
1cde 22 7d f7			ld (os_cur_ptr),hl	 
1ce1			 
1ce1 e9				jp (hl) 
1ce2			 
1ce2			 
1ce2			 
1ce2			; TODO implement a basic monitor mode to start with 
1ce2			 
1ce2			 
1ce2			 
1ce2			 
1ce2			 
1ce2			 
1ce2			 
1ce2			 
1ce2			 
1ce2			; testing and demo code during development 
1ce2			 
1ce2			 
1ce2 .. 00		str1: db "Enter some text...",0 
1cf5 .. 00		clear: db "                    ",0 
1d0a			 
1d0a			demo: 
1d0a			 
1d0a			 
1d0a			 
1d0a			;	call update_display 
1d0a			 
1d0a				; init scratch input area for testing 
1d0a 21 5a f4			ld hl, scratch	 
1d0d 3e 00			ld a,0 
1d0f 77				ld (hl),a 
1d10			 
1d10			 
1d10 3e 14		            LD   A, display_row_2 
1d12			;            CALL fLCD_Pos       ;Position cursor to location in A 
1d12 11 e2 1c		            LD   DE, str1 
1d15 cd d2 0b			call str_at_display 
1d18			 
1d18			;            CALL fLCD_Str       ;Display string pointed to by DE 
1d18			cloop:	 
1d18 3e 28		            LD   A, display_row_3 
1d1a			;            CALL fLCD_Pos       ;Position cursor to location in A 
1d1a 11 f5 1c		            LD   DE, clear 
1d1d			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1d1d cd d2 0b				call str_at_display 
1d20 3e 3c			ld a, display_row_4 
1d22 11 52 1d			ld de, prompt 
1d25			 
1d25 cd d2 0b				call str_at_display 
1d28 cd e2 0b			call update_display 
1d2b			 
1d2b 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1d2d 16 0a			ld d, 10 
1d2f 21 5a f4			ld hl, scratch	 
1d32 cd 20 0e			call input_str 
1d35			 
1d35			;	call clear_display 
1d35			;'	call update_display 
1d35			 
1d35 3e 00		            LD   A, display_row_1 
1d37			;            CALL fLCD_Pos       ;Position cursor to location in A 
1d37 11 f5 1c		            LD   DE, clear 
1d3a cd d2 0b				call str_at_display 
1d3d			;            CALL fLCD_Str       ;Display string pointed to by DE 
1d3d 3e 00		            LD   A, display_row_1 
1d3f			;            CALL fLCD_Pos       ;Position cursor to location in A 
1d3f 11 5a f4		            LD   DE, scratch 
1d42			;            CALL fLCD_Str       ;Display string pointed to by DE 
1d42 cd d2 0b				call str_at_display 
1d45 cd e2 0b			call update_display 
1d48			 
1d48 3e 00				ld a,0 
1d4a 21 5a f4			ld hl, scratch 
1d4d 77				ld (hl),a 
1d4e			 
1d4e 00				nop 
1d4f c3 18 1d			jp cloop 
1d52			 
1d52			 
1d52			 
1d52			; OS Prompt 
1d52			 
1d52 .. 00		prompt: db ">",0 
1d54 .. 00		endprg: db "?",0 
1d56			 
1d56			 
1d56			; handy next page prompt 
1d56			next_page_prompt: 
1d56 e5				push hl 
1d57 d5				push de 
1d58 f5				push af 
1d59 c5				push bc 
1d5a			 
1d5a 3e 4f			ld a,display_row_4 + display_cols - 1 
1d5c 11 54 1d		        ld de, endprg 
1d5f cd d2 0b			call str_at_display 
1d62 cd e2 0b			call update_display 
1d65 cd 4b 69			call cin_wait 
1d68 c1				pop bc 
1d69 f1				pop af 
1d6a d1				pop de 
1d6b e1				pop hl 
1d6c			 
1d6c			 
1d6c c9				ret 
1d6d			 
1d6d			 
1d6d			; forth parser 
1d6d			 
1d6d			; My forth kernel 
1d6d			include "forth_kernel.asm" 
1d6d			; 
1d6d			; kernel to the forth OS 
1d6d			 
1d6d			DS_TYPE_STR: equ 1     ; string type 
1d6d			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1d6d			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1d6d			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1d6d			 
1d6d			FORTH_PARSEV1: equ 0 
1d6d			FORTH_PARSEV2: equ 0 
1d6d			FORTH_PARSEV3: equ 0 
1d6d			FORTH_PARSEV4: equ 0 
1d6d			FORTH_PARSEV5: equ 1 
1d6d			 
1d6d			;if FORTH_PARSEV5 
1d6d			;	FORTH_END_BUFFER: equ 0 
1d6d			;else 
1d6d			FORTH_END_BUFFER: equ 127 
1d6d			;endif 
1d6d			 
1d6d			FORTH_TRUE: equ 1 
1d6d			FORTH_FALSE: equ 0 
1d6d			 
1d6d			if FORTH_PARSEV4 
1d6d			include "forth_stackops.asm" 
1d6d			endif 
1d6d			 
1d6d			if FORTH_PARSEV5 
1d6d			include "forth_stackopsv5.asm" 
1d6d			 
1d6d			; Stack operations for v5 parser on wards 
1d6d			; * DATA stack 
1d6d			; * LOOP stack 
1d6d			; * RETURN stack 
1d6d			 
1d6d			 
1d6d			 
1d6d			FORTH_CHK_DSP_UNDER: macro 
1d6d				push hl 
1d6d				push de 
1d6d				ld hl,(cli_data_sp) 
1d6d				ld de, cli_data_stack 
1d6d				call cmp16 
1d6d				jp c, fault_dsp_under 
1d6d				pop de 
1d6d				pop hl 
1d6d				endm 
1d6d			 
1d6d			 
1d6d			FORTH_CHK_RSP_UNDER: macro 
1d6d				push hl 
1d6d				push de 
1d6d				ld hl,(cli_ret_sp) 
1d6d				ld de, cli_ret_stack 
1d6d				call cmp16 
1d6d				jp c, fault_rsp_under 
1d6d				pop de 
1d6d				pop hl 
1d6d				endm 
1d6d			 
1d6d			FORTH_CHK_LOOP_UNDER: macro 
1d6d				push hl 
1d6d				push de 
1d6d				ld hl,(cli_loop_sp) 
1d6d				ld de, cli_loop_stack 
1d6d				call cmp16 
1d6d				jp c, fault_loop_under 
1d6d				pop de 
1d6d				pop hl 
1d6d				endm 
1d6d			 
1d6d			FORTH_ERR_TOS_NOTSTR: macro 
1d6d				; TOSO might need more for checks when used 
1d6d				push af 
1d6d				ld a,(hl) 
1d6d				cp DS_TYPE_STR 
1d6d				jp nz, type_faultn   
1d6d				pop af 
1d6d				endm 
1d6d			 
1d6d			FORTH_ERR_TOS_NOTNUM: macro 
1d6d				push af 
1d6d				ld a,(hl) 
1d6d				cp DS_TYPE_INUM 
1d6d				jp nz, type_faultn   
1d6d				pop af 
1d6d				endm 
1d6d			 
1d6d			 
1d6d			; increase data stack pointer and save hl to it 
1d6d				 
1d6d			FORTH_DSP_NEXT: macro 
1d6d				call macro_forth_dsp_next 
1d6d				endm 
1d6d			 
1d6d			 
1d6d			macro_forth_dsp_next: 
1d6d				if DEBUG_FORTH_STACK_GUARD 
1d6d cd 66 64				call check_stacks 
1d70				endif 
1d70 e5				push hl 
1d71 d5				push de 
1d72 eb				ex de,hl 
1d73 2a 87 fc			ld hl,(cli_data_sp) 
1d76 23				inc hl 
1d77 23				inc hl 
1d78			 
1d78			; PARSEV5 
1d78 23				inc hl 
1d79 22 87 fc			ld (cli_data_sp),hl 
1d7c 73				ld (hl), e 
1d7d 23				inc hl 
1d7e 72				ld (hl), d 
1d7f d1				pop de 
1d80 e1				pop hl 
1d81				if DEBUG_FORTH_STACK_GUARD 
1d81 cd 66 64				call check_stacks 
1d84				endif 
1d84 c9				ret 
1d85			 
1d85			 
1d85			; increase ret stack pointer and save hl to it 
1d85				 
1d85			FORTH_RSP_NEXT: macro 
1d85				call macro_forth_rsp_next 
1d85				endm 
1d85			 
1d85			macro_forth_rsp_next: 
1d85				if DEBUG_FORTH_STACK_GUARD 
1d85 cd 66 64				call check_stacks 
1d88				endif 
1d88 e5				push hl 
1d89 d5				push de 
1d8a eb				ex de,hl 
1d8b 2a 8b fc			ld hl,(cli_ret_sp) 
1d8e 23				inc hl 
1d8f 23				inc hl 
1d90 22 8b fc			ld (cli_ret_sp),hl 
1d93 73				ld (hl), e 
1d94 23				inc hl 
1d95 72				ld (hl), d 
1d96 d1				pop de 
1d97 e1				pop hl 
1d98				if DEBUG_FORTH_STACK_GUARD 
1d98 cd 66 64				call check_stacks 
1d9b				endif 
1d9b c9				ret 
1d9c			 
1d9c			; get current ret stack pointer and save to hl  
1d9c				 
1d9c			FORTH_RSP_TOS: macro 
1d9c				call macro_forth_rsp_tos 
1d9c				endm 
1d9c			 
1d9c			macro_forth_rsp_tos: 
1d9c				;push de 
1d9c 2a 8b fc			ld hl,(cli_ret_sp) 
1d9f cd d7 1d			call loadhlptrtohl 
1da2				;ld e, (hl) 
1da2				;inc hl 
1da2				;ld d, (hl) 
1da2				;ex de, hl 
1da2					if DEBUG_FORTH_WORDS 
1da2			;			DMARK "RST" 
1da2						CALLMONITOR 
1da2 cd 70 17			call break_point_state  
1da5				endm  
# End of macro CALLMONITOR
1da5					endif 
1da5				;pop de 
1da5 c9				ret 
1da6			 
1da6			; pop ret stack pointer 
1da6				 
1da6			FORTH_RSP_POP: macro 
1da6				call macro_forth_rsp_pop 
1da6				endm 
1da6			 
1da6			 
1da6			macro_forth_rsp_pop: 
1da6				if DEBUG_FORTH_STACK_GUARD 
1da6			;		DMARK "RPP" 
1da6 cd 66 64				call check_stacks 
1da9					FORTH_CHK_RSP_UNDER 
1da9 e5				push hl 
1daa d5				push de 
1dab 2a 8b fc			ld hl,(cli_ret_sp) 
1dae 11 45 fc			ld de, cli_ret_stack 
1db1 cd 11 0e			call cmp16 
1db4 da 7a 65			jp c, fault_rsp_under 
1db7 d1				pop de 
1db8 e1				pop hl 
1db9				endm 
# End of macro FORTH_CHK_RSP_UNDER
1db9				endif 
1db9 e5				push hl 
1dba 2a 8b fc			ld hl,(cli_ret_sp) 
1dbd			 
1dbd			 
1dbd				if FORTH_ENABLE_FREE 
1dbd			 
1dbd					; get pointer 
1dbd			 
1dbd					push de 
1dbd					push hl 
1dbd			 
1dbd					ld e, (hl) 
1dbd					inc hl 
1dbd					ld d, (hl) 
1dbd			 
1dbd					ex de, hl 
1dbd					call free 
1dbd			 
1dbd					pop hl 
1dbd					pop de 
1dbd			 
1dbd			 
1dbd				endif 
1dbd			 
1dbd			 
1dbd 2b				dec hl 
1dbe 2b				dec hl 
1dbf 22 8b fc			ld (cli_ret_sp), hl 
1dc2				; do stack underflow checks 
1dc2 e1				pop hl 
1dc3				if DEBUG_FORTH_STACK_GUARD 
1dc3 cd 66 64				call check_stacks 
1dc6					FORTH_CHK_RSP_UNDER 
1dc6 e5				push hl 
1dc7 d5				push de 
1dc8 2a 8b fc			ld hl,(cli_ret_sp) 
1dcb 11 45 fc			ld de, cli_ret_stack 
1dce cd 11 0e			call cmp16 
1dd1 da 7a 65			jp c, fault_rsp_under 
1dd4 d1				pop de 
1dd5 e1				pop hl 
1dd6				endm 
# End of macro FORTH_CHK_RSP_UNDER
1dd6				endif 
1dd6 c9				ret 
1dd7			 
1dd7			 
1dd7			 
1dd7			; routine to load word pointed to by hl into hl 
1dd7			 
1dd7			loadhlptrtohl: 
1dd7			 
1dd7 d5				push de 
1dd8 5e				ld e, (hl) 
1dd9 23				inc hl 
1dda 56				ld d, (hl) 
1ddb eb				ex de, hl 
1ddc d1				pop de 
1ddd			 
1ddd c9				ret 
1dde			 
1dde			 
1dde			 
1dde			 
1dde			 
1dde			; push a number held in HL onto the data stack 
1dde			; entry point for pushing a value when already in hl used in function above 
1dde			 
1dde			forth_push_numhl: 
1dde			 
1dde e5				push hl    ; save value to push 
1ddf			 
1ddf			if DEBUG_FORTH_PUSH 
1ddf				; see if disabled 
1ddf			 
1ddf			 
1ddf f5				push af 
1de0 3a 4b f4			ld a, (os_view_disable) 
1de3 fe 2a			cp '*' 
1de5 28 34			jr z, .pskip2 
1de7 e5				push hl 
1de8 e5			push hl 
1de9 cd bf 0b			call clear_display 
1dec e1			pop hl 
1ded 7c				ld a,h 
1dee 21 5f f7			ld hl, os_word_scratch 
1df1 cd f4 10			call hexout 
1df4 e1				pop hl 
1df5 7d				ld a,l 
1df6 21 61 f7			ld hl, os_word_scratch+2 
1df9 cd f4 10			call hexout 
1dfc			 
1dfc 21 63 f7			ld hl, os_word_scratch+4 
1dff 3e 00			ld a,0 
1e01 77				ld (hl),a 
1e02 11 5f f7			ld de,os_word_scratch 
1e05 3e 14				ld a, display_row_2 
1e07 cd d2 0b				call str_at_display 
1e0a 11 45 53			ld de, .push_num 
1e0d 3e 00			ld a, display_row_1 
1e0f			 
1e0f cd d2 0b				call str_at_display 
1e12			 
1e12			 
1e12 cd e2 0b			call update_display 
1e15 cd 3c 0b			call delay1s 
1e18 cd 3c 0b			call delay1s 
1e1b			.pskip2:  
1e1b			 
1e1b f1				pop af 
1e1c			endif	 
1e1c			 
1e1c			 
1e1c				FORTH_DSP_NEXT 
1e1c cd 6d 1d			call macro_forth_dsp_next 
1e1f				endm 
# End of macro FORTH_DSP_NEXT
1e1f			 
1e1f 2a 87 fc			ld hl, (cli_data_sp) 
1e22			 
1e22				; save item type 
1e22 3e 02			ld a,  DS_TYPE_INUM 
1e24 77				ld (hl), a 
1e25 23				inc hl 
1e26			 
1e26				; get word off stack 
1e26 d1				pop de 
1e27 7b				ld a,e 
1e28 77				ld (hl), a 
1e29 23				inc hl 
1e2a 7a				ld a,d 
1e2b 77				ld (hl), a 
1e2c			 
1e2c			if DEBUG_FORTH_PUSH 
1e2c 2b				dec hl 
1e2d 2b				dec hl 
1e2e 2b				dec hl 
1e2f						DMARK "PH5" 
1e2f f5				push af  
1e30 3a 44 1e			ld a, (.dmark)  
1e33 32 b4 fe			ld (debug_mark),a  
1e36 3a 45 1e			ld a, (.dmark+1)  
1e39 32 b5 fe			ld (debug_mark+1),a  
1e3c 3a 46 1e			ld a, (.dmark+2)  
1e3f 32 b6 fe			ld (debug_mark+2),a  
1e42 18 03			jr .pastdmark  
1e44 ..			.dmark: db "PH5"  
1e47 f1			.pastdmark: pop af  
1e48			endm  
# End of macro DMARK
1e48				CALLMONITOR 
1e48 cd 70 17			call break_point_state  
1e4b				endm  
# End of macro CALLMONITOR
1e4b			endif	 
1e4b			 
1e4b c9				ret 
1e4c			 
1e4c			 
1e4c			; Push a string to stack pointed to by hl 
1e4c			 
1e4c			forth_push_str: 
1e4c			 
1e4c			if DEBUG_FORTH_PUSH 
1e4c						DMARK "PSQ" 
1e4c f5				push af  
1e4d 3a 61 1e			ld a, (.dmark)  
1e50 32 b4 fe			ld (debug_mark),a  
1e53 3a 62 1e			ld a, (.dmark+1)  
1e56 32 b5 fe			ld (debug_mark+1),a  
1e59 3a 63 1e			ld a, (.dmark+2)  
1e5c 32 b6 fe			ld (debug_mark+2),a  
1e5f 18 03			jr .pastdmark  
1e61 ..			.dmark: db "PSQ"  
1e64 f1			.pastdmark: pop af  
1e65			endm  
# End of macro DMARK
1e65				CALLMONITOR 
1e65 cd 70 17			call break_point_state  
1e68				endm  
# End of macro CALLMONITOR
1e68			endif	 
1e68			    
1e68 e5				push hl 
1e69 e5				push hl 
1e6a			 
1e6a			;	ld a, 0   ; find end of string 
1e6a cd 51 12			call strlenz 
1e6d			if DEBUG_FORTH_PUSH 
1e6d						DMARK "PQ2" 
1e6d f5				push af  
1e6e 3a 82 1e			ld a, (.dmark)  
1e71 32 b4 fe			ld (debug_mark),a  
1e74 3a 83 1e			ld a, (.dmark+1)  
1e77 32 b5 fe			ld (debug_mark+1),a  
1e7a 3a 84 1e			ld a, (.dmark+2)  
1e7d 32 b6 fe			ld (debug_mark+2),a  
1e80 18 03			jr .pastdmark  
1e82 ..			.dmark: db "PQ2"  
1e85 f1			.pastdmark: pop af  
1e86			endm  
# End of macro DMARK
1e86				CALLMONITOR 
1e86 cd 70 17			call break_point_state  
1e89				endm  
# End of macro CALLMONITOR
1e89			endif	 
1e89 eb				ex de, hl 
1e8a e1				pop hl   ; get ptr to start of string 
1e8b			if DEBUG_FORTH_PUSH 
1e8b						DMARK "PQ3" 
1e8b f5				push af  
1e8c 3a a0 1e			ld a, (.dmark)  
1e8f 32 b4 fe			ld (debug_mark),a  
1e92 3a a1 1e			ld a, (.dmark+1)  
1e95 32 b5 fe			ld (debug_mark+1),a  
1e98 3a a2 1e			ld a, (.dmark+2)  
1e9b 32 b6 fe			ld (debug_mark+2),a  
1e9e 18 03			jr .pastdmark  
1ea0 ..			.dmark: db "PQ3"  
1ea3 f1			.pastdmark: pop af  
1ea4			endm  
# End of macro DMARK
1ea4				CALLMONITOR 
1ea4 cd 70 17			call break_point_state  
1ea7				endm  
# End of macro CALLMONITOR
1ea7			endif	 
1ea7 19				add hl,de 
1ea8			if DEBUG_FORTH_PUSH 
1ea8						DMARK "PQE" 
1ea8 f5				push af  
1ea9 3a bd 1e			ld a, (.dmark)  
1eac 32 b4 fe			ld (debug_mark),a  
1eaf 3a be 1e			ld a, (.dmark+1)  
1eb2 32 b5 fe			ld (debug_mark+1),a  
1eb5 3a bf 1e			ld a, (.dmark+2)  
1eb8 32 b6 fe			ld (debug_mark+2),a  
1ebb 18 03			jr .pastdmark  
1ebd ..			.dmark: db "PQE"  
1ec0 f1			.pastdmark: pop af  
1ec1			endm  
# End of macro DMARK
1ec1				CALLMONITOR 
1ec1 cd 70 17			call break_point_state  
1ec4				endm  
# End of macro CALLMONITOR
1ec4			endif	 
1ec4			 
1ec4 2b				dec hl    ; see if there is an optional trailing double quote 
1ec5 7e				ld a,(hl) 
1ec6 fe 22			cp '"' 
1ec8 20 03			jr nz, .strnoq 
1eca 3e 00			ld a, 0      ; get rid of double quote 
1ecc 77				ld (hl), a 
1ecd 23			.strnoq: inc hl 
1ece			 
1ece 3e 00			ld a, 0 
1ed0 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1ed1			 
1ed1 13				inc de ; add one for the type string 
1ed2 13				inc de ; add one for null term??? 
1ed3			 
1ed3				; tos is get string pointer again 
1ed3				; de contains space to allocate 
1ed3				 
1ed3 d5				push de 
1ed4			 
1ed4 eb				ex de, hl 
1ed5			 
1ed5				;push af 
1ed5			 
1ed5			if DEBUG_FORTH_PUSH 
1ed5						DMARK "PHm" 
1ed5 f5				push af  
1ed6 3a ea 1e			ld a, (.dmark)  
1ed9 32 b4 fe			ld (debug_mark),a  
1edc 3a eb 1e			ld a, (.dmark+1)  
1edf 32 b5 fe			ld (debug_mark+1),a  
1ee2 3a ec 1e			ld a, (.dmark+2)  
1ee5 32 b6 fe			ld (debug_mark+2),a  
1ee8 18 03			jr .pastdmark  
1eea ..			.dmark: db "PHm"  
1eed f1			.pastdmark: pop af  
1eee			endm  
# End of macro DMARK
1eee				CALLMONITOR 
1eee cd 70 17			call break_point_state  
1ef1				endm  
# End of macro CALLMONITOR
1ef1			endif	 
1ef1 cd ba 12			call malloc	; on ret hl now contains allocated memory 
1ef4				if DEBUG_FORTH_MALLOC_GUARD 
1ef4 cc 9d 53				call z,malloc_error 
1ef7				endif 
1ef7			 
1ef7				 
1ef7 c1				pop bc    ; get length 
1ef8 d1				pop de   ;  get string start    
1ef9			 
1ef9				; hl has destination from malloc 
1ef9			 
1ef9 eb				ex de, hl    ; prep for ldir 
1efa			 
1efa d5				push de   ; save malloc area for DSP later 
1efb				;push hl   ; save malloc area for DSP later 
1efb			 
1efb			if DEBUG_FORTH_PUSH 
1efb						DMARK "PHc" 
1efb f5				push af  
1efc 3a 10 1f			ld a, (.dmark)  
1eff 32 b4 fe			ld (debug_mark),a  
1f02 3a 11 1f			ld a, (.dmark+1)  
1f05 32 b5 fe			ld (debug_mark+1),a  
1f08 3a 12 1f			ld a, (.dmark+2)  
1f0b 32 b6 fe			ld (debug_mark+2),a  
1f0e 18 03			jr .pastdmark  
1f10 ..			.dmark: db "PHc"  
1f13 f1			.pastdmark: pop af  
1f14			endm  
# End of macro DMARK
1f14				CALLMONITOR 
1f14 cd 70 17			call break_point_state  
1f17				endm  
# End of macro CALLMONITOR
1f17			endif	 
1f17			 
1f17			 
1f17 ed b0			ldir 
1f19			 
1f19			 
1f19				; push malloc to data stack     macro?????  
1f19			 
1f19				FORTH_DSP_NEXT 
1f19 cd 6d 1d			call macro_forth_dsp_next 
1f1c				endm 
# End of macro FORTH_DSP_NEXT
1f1c			 
1f1c				; save value and type 
1f1c			 
1f1c 2a 87 fc			ld hl, (cli_data_sp) 
1f1f			 
1f1f				; save item type 
1f1f 3e 01			ld a,  DS_TYPE_STR 
1f21 77				ld (hl), a 
1f22 23				inc hl 
1f23			 
1f23				; get malloc word off stack 
1f23 d1				pop de 
1f24 73				ld (hl), e 
1f25 23				inc hl 
1f26 72				ld (hl), d 
1f27			 
1f27			 
1f27			 
1f27			if DEBUG_FORTH_PUSH 
1f27 2a 87 fc			ld hl, (cli_data_sp) 
1f2a						DMARK "PHS" 
1f2a f5				push af  
1f2b 3a 3f 1f			ld a, (.dmark)  
1f2e 32 b4 fe			ld (debug_mark),a  
1f31 3a 40 1f			ld a, (.dmark+1)  
1f34 32 b5 fe			ld (debug_mark+1),a  
1f37 3a 41 1f			ld a, (.dmark+2)  
1f3a 32 b6 fe			ld (debug_mark+2),a  
1f3d 18 03			jr .pastdmark  
1f3f ..			.dmark: db "PHS"  
1f42 f1			.pastdmark: pop af  
1f43			endm  
# End of macro DMARK
1f43				CALLMONITOR 
1f43 cd 70 17			call break_point_state  
1f46				endm  
# End of macro CALLMONITOR
1f46			;	ex de,hl 
1f46			endif	 
1f46				; in case of spaces, skip the ptr past the copied string 
1f46				;pop af 
1f46				;ld (cli_origptr),hl 
1f46			 
1f46 c9				ret 
1f47			 
1f47			 
1f47			 
1f47			; TODO ascii push input onto stack given hl to start of input 
1f47			 
1f47			; identify type 
1f47			; if starts with a " then a string 
1f47			; otherwise it is a number 
1f47			;  
1f47			; if a string 
1f47			;     scan for ending " to get length of string to malloc for + 1 
1f47			;     malloc 
1f47			;     put pointer to string on stack first byte flags as string 
1f47			; 
1f47			; else a number 
1f47			;    look for number format identifier 
1f47			;    $xx hex 
1f47			;    %xxxxx bin 
1f47			;    xxxxx decimal 
1f47			;    convert number to 16bit word.  
1f47			;    malloc word + 1 with flag to identiy as num 
1f47			;    put pointer to number on stack 
1f47			;   
1f47			;  
1f47			  
1f47			forth_apush: 
1f47				; kernel push 
1f47			 
1f47			if DEBUG_FORTH_PUSH 
1f47						DMARK "PSH" 
1f47 f5				push af  
1f48 3a 5c 1f			ld a, (.dmark)  
1f4b 32 b4 fe			ld (debug_mark),a  
1f4e 3a 5d 1f			ld a, (.dmark+1)  
1f51 32 b5 fe			ld (debug_mark+1),a  
1f54 3a 5e 1f			ld a, (.dmark+2)  
1f57 32 b6 fe			ld (debug_mark+2),a  
1f5a 18 03			jr .pastdmark  
1f5c ..			.dmark: db "PSH"  
1f5f f1			.pastdmark: pop af  
1f60			endm  
# End of macro DMARK
1f60				CALLMONITOR 
1f60 cd 70 17			call break_point_state  
1f63				endm  
# End of macro CALLMONITOR
1f63			endif	 
1f63				; identify input type 
1f63			 
1f63 7e				ld a,(hl) 
1f64 fe 22			cp '"' 
1f66 28 0a			jr z, .fapstr 
1f68 fe 24			cp '$' 
1f6a ca 92 1f			jp z, .faphex 
1f6d fe 25			cp '%' 
1f6f ca 7a 1f			jp z, .fapbin 
1f72			;	cp 'b' 
1f72			;	jp z, .fabin 
1f72				; else decimal 
1f72			 
1f72				; TODO do decimal conversion 
1f72				; decimal is stored as a 16bit word 
1f72			 
1f72				; by default everything is a string if type is not detected 
1f72			.fapstr: ; 
1f72 fe 22			cp '"' 
1f74 20 01			jr nz, .strnoqu 
1f76 23				inc hl 
1f77			.strnoqu: 
1f77 c3 4c 1e			jp forth_push_str 
1f7a			 
1f7a			 
1f7a			 
1f7a			.fapbin:    ; push a binary string.  
1f7a 11 00 00			ld de, 0   ; hold a 16bit value 
1f7d			 
1f7d 23			.fapbinshift:	inc hl  
1f7e 7e				ld a,(hl) 
1f7f fe 00			cp 0     ; done scanning  
1f81 28 0b			jr z, .fapbdone  	; got it in HL so push  
1f83			 
1f83				; left shift de 
1f83 eb				ex de, hl	 
1f84 29				add hl, hl 
1f85			 
1f85				; is 1 
1f85 fe 31			cp '1' 
1f87 20 02			jr nz, .binzero 
1f89 cb 4d			bit 1, l 
1f8b			.binzero: 
1f8b eb				ex de, hl	 ; save current de 
1f8c 18 ef			jr .fapbinshift 
1f8e			 
1f8e			.fapbdone: 
1f8e eb				ex de, hl 
1f8f c3 de 1d			jp forth_push_numhl 
1f92			 
1f92			 
1f92			.faphex:   ; hex is always stored as a 16bit word 
1f92				; skip number prefix 
1f92 23				inc hl 
1f93				; turn ascii into number 
1f93 cd aa 11			call get_word_hl	; ret 16bit word in hl 
1f96			 
1f96 c3 de 1d			jp forth_push_numhl 
1f99			 
1f99 00				 nop 
1f9a			 
1f9a			.fabin:   ; TODO bin conversion 
1f9a			 
1f9a			 
1f9a c9				ret 
1f9b			 
1f9b			 
1f9b			; get either a string ptr or a 16bit word from the data stack 
1f9b			 
1f9b			FORTH_DSP: macro 
1f9b				call macro_forth_dsp 
1f9b				endm 
1f9b			 
1f9b			macro_forth_dsp: 
1f9b				; data stack pointer points to current word on tos 
1f9b			 
1f9b 2a 87 fc			ld hl,(cli_data_sp) 
1f9e			 
1f9e				if DEBUG_FORTH_PUSH 
1f9e						DMARK "DSP" 
1f9e f5				push af  
1f9f 3a b3 1f			ld a, (.dmark)  
1fa2 32 b4 fe			ld (debug_mark),a  
1fa5 3a b4 1f			ld a, (.dmark+1)  
1fa8 32 b5 fe			ld (debug_mark+1),a  
1fab 3a b5 1f			ld a, (.dmark+2)  
1fae 32 b6 fe			ld (debug_mark+2),a  
1fb1 18 03			jr .pastdmark  
1fb3 ..			.dmark: db "DSP"  
1fb6 f1			.pastdmark: pop af  
1fb7			endm  
# End of macro DMARK
1fb7			 
1fb7 cd d2 53				call display_data_sp 
1fba				;call break_point_state 
1fba				;rst 030h 
1fba				CALLMONITOR 
1fba cd 70 17			call break_point_state  
1fbd				endm  
# End of macro CALLMONITOR
1fbd				endif 
1fbd			 
1fbd c9				ret 
1fbe			 
1fbe			; return hl to start of value on stack 
1fbe			 
1fbe			FORTH_DSP_VALUE: macro 
1fbe				call macro_forth_dsp_value 
1fbe				endm 
1fbe			 
1fbe			macro_forth_dsp_value: 
1fbe			 
1fbe				FORTH_DSP 
1fbe cd 9b 1f			call macro_forth_dsp 
1fc1				endm 
# End of macro FORTH_DSP
1fc1			 
1fc1 d5				push de 
1fc2			 
1fc2 23				inc hl ; skip type 
1fc3			 
1fc3 5e				ld e, (hl) 
1fc4 23				inc hl 
1fc5 56				ld d, (hl) 
1fc6 eb				ex de,hl  
1fc7			 
1fc7 d1				pop de 
1fc8			 
1fc8 c9				ret 
1fc9			 
1fc9			; return hl to start of value to second item on stack 
1fc9			 
1fc9			FORTH_DSP_VALUEM1: macro 
1fc9				call macro_forth_dsp_value_m1 
1fc9				endm 
1fc9			 
1fc9			macro_forth_dsp_value_m1: 
1fc9			 
1fc9				FORTH_DSP 
1fc9 cd 9b 1f			call macro_forth_dsp 
1fcc				endm 
# End of macro FORTH_DSP
1fcc			 
1fcc 2b				dec hl 
1fcd 2b				dec hl 
1fce			;	dec hl 
1fce			 
1fce d5				push de 
1fcf			 
1fcf 5e				ld e, (hl) 
1fd0 23				inc hl 
1fd1 56				ld d, (hl) 
1fd2 eb				ex de,hl  
1fd3			 
1fd3 d1				pop de 
1fd4			 
1fd4 c9				ret 
1fd5			 
1fd5				 
1fd5			 
1fd5			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1fd5			 
1fd5			FORTH_DSP_POP: macro 
1fd5				call macro_forth_dsp_pop 
1fd5				endm 
1fd5			 
1fd5			 
1fd5			; get the tos data type 
1fd5			 
1fd5			FORTH_DSP_TYPE:   macro 
1fd5			 
1fd5				;FORTH_DSP_VALUE 
1fd5				FORTH_DSP 
1fd5				 
1fd5				; hl points to value 
1fd5				; check type 
1fd5			 
1fd5				ld a,(hl) 
1fd5			 
1fd5				endm 
1fd5			 
1fd5			; load the tos value into hl 
1fd5			 
1fd5			 
1fd5			FORTH_DSP_VALUEHL:  macro 
1fd5				call macro_dsp_valuehl 
1fd5				endm 
1fd5			 
1fd5			 
1fd5			 
1fd5			macro_dsp_valuehl: 
1fd5				FORTH_DSP_VALUE 
1fd5 cd be 1f			call macro_forth_dsp_value 
1fd8				endm 
# End of macro FORTH_DSP_VALUE
1fd8			 
1fd8				;FORTH_ERR_TOS_NOTNUM 
1fd8			 
1fd8				;inc hl   ; skip type id 
1fd8			 
1fd8			;	push de 
1fd8			; 
1fd8			;	ld e, (hl) 
1fd8			;	inc hl 
1fd8			;	ld d, (hl) 
1fd8			;	ex de,hl  
1fd8			 
1fd8			;	pop de 
1fd8			 
1fd8				if DEBUG_FORTH_PUSH 
1fd8						DMARK "DVL" 
1fd8 f5				push af  
1fd9 3a ed 1f			ld a, (.dmark)  
1fdc 32 b4 fe			ld (debug_mark),a  
1fdf 3a ee 1f			ld a, (.dmark+1)  
1fe2 32 b5 fe			ld (debug_mark+1),a  
1fe5 3a ef 1f			ld a, (.dmark+2)  
1fe8 32 b6 fe			ld (debug_mark+2),a  
1feb 18 03			jr .pastdmark  
1fed ..			.dmark: db "DVL"  
1ff0 f1			.pastdmark: pop af  
1ff1			endm  
# End of macro DMARK
1ff1				CALLMONITOR 
1ff1 cd 70 17			call break_point_state  
1ff4				endm  
# End of macro CALLMONITOR
1ff4				endif 
1ff4 c9				ret 
1ff5			 
1ff5			forth_apushstrhl:      
1ff5				; push of string requires use of cli_origptr 
1ff5				; bodge use 
1ff5			 
1ff5				; get current cli_origptr, save, update with temp pointer  
1ff5 ed 5b a3 fc		ld de, (cli_origptr) 
1ff9 22 a3 fc			ld (cli_origptr), hl 
1ffc d5				push de 
1ffd cd 47 1f			call forth_apush 
2000 d1				pop de 
2001 ed 53 a3 fc		ld (cli_origptr), de 
2005 c9			        ret	 
2006			 
2006			 
2006			; increase loop stack pointer and save hl to it 
2006				 
2006			FORTH_LOOP_NEXT: macro 
2006				call macro_forth_loop_next 
2006				;nop 
2006				endm 
2006			 
2006			macro_forth_loop_next: 
2006				if DEBUG_FORTH_STACK_GUARD 
2006 cd 66 64				call check_stacks 
2009				endif 
2009 e5				push hl 
200a d5				push de 
200b eb				ex de,hl 
200c 2a 89 fc			ld hl,(cli_loop_sp) 
200f 23				inc hl 
2010 23				inc hl 
2011					if DEBUG_FORTH_WORDS 
2011						DMARK "LNX" 
2011 f5				push af  
2012 3a 26 20			ld a, (.dmark)  
2015 32 b4 fe			ld (debug_mark),a  
2018 3a 27 20			ld a, (.dmark+1)  
201b 32 b5 fe			ld (debug_mark+1),a  
201e 3a 28 20			ld a, (.dmark+2)  
2021 32 b6 fe			ld (debug_mark+2),a  
2024 18 03			jr .pastdmark  
2026 ..			.dmark: db "LNX"  
2029 f1			.pastdmark: pop af  
202a			endm  
# End of macro DMARK
202a						CALLMONITOR 
202a cd 70 17			call break_point_state  
202d				endm  
# End of macro CALLMONITOR
202d					endif 
202d 22 89 fc			ld (cli_loop_sp),hl 
2030 73				ld (hl), e 
2031 23				inc hl 
2032 72				ld (hl), d 
2033 d1				pop de    ; been reversed so save a swap on restore 
2034 e1				pop hl 
2035				if DEBUG_FORTH_STACK_GUARD 
2035 cd 66 64				call check_stacks 
2038				endif 
2038 c9				ret 
2039			 
2039			; get current ret stack pointer and save to hl  
2039				 
2039			FORTH_LOOP_TOS: macro 
2039				call macro_forth_loop_tos 
2039				endm 
2039			 
2039			macro_forth_loop_tos: 
2039 d5				push de 
203a 2a 89 fc			ld hl,(cli_loop_sp) 
203d 5e				ld e, (hl) 
203e 23				inc hl 
203f 56				ld d, (hl) 
2040 eb				ex de, hl 
2041 d1				pop de 
2042 c9				ret 
2043			 
2043			; pop loop stack pointer 
2043				 
2043			FORTH_LOOP_POP: macro 
2043				call macro_forth_loop_pop 
2043				endm 
2043			 
2043			 
2043			macro_forth_loop_pop: 
2043				if DEBUG_FORTH_STACK_GUARD 
2043					DMARK "LPP" 
2043 f5				push af  
2044 3a 58 20			ld a, (.dmark)  
2047 32 b4 fe			ld (debug_mark),a  
204a 3a 59 20			ld a, (.dmark+1)  
204d 32 b5 fe			ld (debug_mark+1),a  
2050 3a 5a 20			ld a, (.dmark+2)  
2053 32 b6 fe			ld (debug_mark+2),a  
2056 18 03			jr .pastdmark  
2058 ..			.dmark: db "LPP"  
205b f1			.pastdmark: pop af  
205c			endm  
# End of macro DMARK
205c cd 66 64				call check_stacks 
205f					FORTH_CHK_LOOP_UNDER 
205f e5				push hl 
2060 d5				push de 
2061 2a 89 fc			ld hl,(cli_loop_sp) 
2064 11 c3 fb			ld de, cli_loop_stack 
2067 cd 11 0e			call cmp16 
206a da 80 65			jp c, fault_loop_under 
206d d1				pop de 
206e e1				pop hl 
206f				endm 
# End of macro FORTH_CHK_LOOP_UNDER
206f				endif 
206f e5				push hl 
2070 2a 89 fc			ld hl,(cli_loop_sp) 
2073 2b				dec hl 
2074 2b				dec hl 
2075 22 89 fc			ld (cli_loop_sp), hl 
2078				; TODO do stack underflow checks 
2078 e1				pop hl 
2079				if DEBUG_FORTH_STACK_GUARD 
2079 cd 66 64				call check_stacks 
207c					FORTH_CHK_LOOP_UNDER 
207c e5				push hl 
207d d5				push de 
207e 2a 89 fc			ld hl,(cli_loop_sp) 
2081 11 c3 fb			ld de, cli_loop_stack 
2084 cd 11 0e			call cmp16 
2087 da 80 65			jp c, fault_loop_under 
208a d1				pop de 
208b e1				pop hl 
208c				endm 
# End of macro FORTH_CHK_LOOP_UNDER
208c				endif 
208c c9				ret 
208d			 
208d			macro_forth_dsp_pop: 
208d			 
208d e5				push hl 
208e			 
208e				; release malloc data 
208e			 
208e				if DEBUG_FORTH_STACK_GUARD 
208e cd 66 64				call check_stacks 
2091					FORTH_CHK_DSP_UNDER 
2091 e5				push hl 
2092 d5				push de 
2093 2a 87 fc			ld hl,(cli_data_sp) 
2096 11 c1 f9			ld de, cli_data_stack 
2099 cd 11 0e			call cmp16 
209c da 74 65			jp c, fault_dsp_under 
209f d1				pop de 
20a0 e1				pop hl 
20a1				endm 
# End of macro FORTH_CHK_DSP_UNDER
20a1				endif 
20a1				;ld hl,(cli_data_sp) 
20a1			if DEBUG_FORTH_DOT 
20a1				DMARK "DPP" 
20a1				CALLMONITOR 
20a1			endif	 
20a1			 
20a1			 
20a1			if FORTH_ENABLE_DSPPOPFREE 
20a1			 
20a1				FORTH_DSP 
20a1 cd 9b 1f			call macro_forth_dsp 
20a4				endm 
# End of macro FORTH_DSP
20a4			 
20a4 7e				ld a, (hl) 
20a5 fe 01			cp DS_TYPE_STR 
20a7 20 07			jr nz, .skippopfree 
20a9			 
20a9				FORTH_DSP_VALUEHL 
20a9 cd d5 1f			call macro_dsp_valuehl 
20ac				endm 
# End of macro FORTH_DSP_VALUEHL
20ac 00				nop 
20ad			if DEBUG_FORTH_DOT 
20ad				DMARK "DPf" 
20ad				CALLMONITOR 
20ad			endif	 
20ad cd 84 13			call free 
20b0			.skippopfree: 
20b0				 
20b0			 
20b0			endif 
20b0			 
20b0			if DEBUG_FORTH_DOT_KEY 
20b0				DMARK "DP2" 
20b0				CALLMONITOR 
20b0			endif	 
20b0			 
20b0				; move pointer down 
20b0			 
20b0 2a 87 fc			ld hl,(cli_data_sp) 
20b3 2b				dec hl 
20b4 2b				dec hl 
20b5			; PARSEV5 
20b5 2b				dec hl 
20b6 22 87 fc			ld (cli_data_sp), hl 
20b9			 
20b9				if DEBUG_FORTH_STACK_GUARD 
20b9 cd 66 64				call check_stacks 
20bc					FORTH_CHK_DSP_UNDER 
20bc e5				push hl 
20bd d5				push de 
20be 2a 87 fc			ld hl,(cli_data_sp) 
20c1 11 c1 f9			ld de, cli_data_stack 
20c4 cd 11 0e			call cmp16 
20c7 da 74 65			jp c, fault_dsp_under 
20ca d1				pop de 
20cb e1				pop hl 
20cc				endm 
# End of macro FORTH_CHK_DSP_UNDER
20cc				endif 
20cc			 
20cc e1				pop hl 
20cd			 
20cd c9				ret 
20ce			 
20ce			getwordathl: 
20ce				; hl points to an address 
20ce				; load hl with the word at that address 
20ce			 
20ce d5				push de 
20cf			 
20cf 5e				ld e, (hl) 
20d0 23				inc hl 
20d1 56				ld d, (hl) 
20d2 eb				ex de, hl 
20d3			 
20d3 d1				pop de 
20d4 c9				ret 
20d5			 
20d5			 
20d5			 
20d5			 
20d5			 
20d5			; eof 
20d5			 
# End of file forth_stackopsv5.asm
20d5			endif 
20d5			 
20d5			user_word_eol:  
20d5				; hl contains the pointer to where to create a linked list item from the end 
20d5				; of the user dict to continue on at the system word dict 
20d5				 
20d5				; poke the stub of the word list linked list to repoint to rom words 
20d5			 
20d5				; stub format 
20d5				; db   word id 
20d5				; dw    link to next word 
20d5			        ; db char length of token 
20d5				; db string + 0 term 
20d5				; db exec code....  
20d5			 
20d5 3e 00			ld a, WORD_SYS_ROOT     ; root word 
20d7 77				ld (hl), a		; word id 
20d8 23				inc hl 
20d9			 
20d9 11 9f 22			ld de, sysdict 
20dc 73				ld (hl), e		; next word link ie system dict 
20dd 23				inc hl 
20de 72				ld (hl), d		; next word link ie system dict 
20df 23				inc hl	 
20e0			 
20e0			;	ld (hl), sysdict		; next word link ie system dict 
20e0			;	inc hl 
20e0			;	inc hl 
20e0			 
20e0			;	inc hl 
20e0			;	inc hl 
20e0			 
20e0 3e 02			ld a, 2			; word length is 0 
20e2 77				ld (hl), a	 
20e3 23				inc hl 
20e4			 
20e4 3e 7e			ld a, '~'			; word length is 0 
20e6 77				ld (hl), a	 
20e7 23				inc hl 
20e8 3e 00			ld a, 0			; save empty word 
20ea 77				ld (hl), a 
20eb			 
20eb c9				ret 
20ec			 
20ec				 
20ec			 
20ec			forthexec_cleanup: 
20ec				FORTH_RSP_POP 
20ec cd a6 1d			call macro_forth_rsp_pop 
20ef				endm 
# End of macro FORTH_RSP_POP
20ef c9				ret 
20f0			 
20f0			forth_call_hl: 
20f0				; taking hl 
20f0 e5				push hl 
20f1 c9				ret 
20f2			 
20f2			; this is called to reset Forth system but keep existing uwords etc 
20f2			 
20f2			forth_warmstart: 
20f2				; setup stack over/under flow checks 
20f2				if DEBUG_FORTH_STACK_GUARD 
20f2 cd 4c 64				call chk_stk_init 
20f5				endif 
20f5			 
20f5				; init stack pointers  - * these stacks go upwards *  
20f5 21 45 fc			ld hl, cli_ret_stack 
20f8 22 8b fc			ld (cli_ret_sp), hl	 
20fb				; set bottom of stack 
20fb 3e 00			ld a,0 
20fd 77				ld (hl),a 
20fe 23				inc hl 
20ff 77				ld (hl),a 
2100			 
2100 21 c1 f9			ld hl, cli_data_stack 
2103 22 87 fc			ld (cli_data_sp), hl	 
2106				; set bottom of stack 
2106 3e 00			ld a,0 
2108 77				ld (hl),a 
2109 23				inc hl 
210a 77				ld (hl),a 
210b			 
210b 21 c3 fb			ld hl, cli_loop_stack 
210e 22 89 fc			ld (cli_loop_sp), hl	 
2111				; set bottom of stack 
2111 3e 00			ld a,0 
2113 77				ld (hl),a 
2114 23				inc hl 
2115 77				ld (hl),a 
2116			 
2116				; init extent of current open file 
2116			 
2116 3e 00			ld a, 0 
2118 32 d6 fc			ld (store_openext), a 
211b			 
211b c9				ret 
211c			 
211c			 
211c			; Cold Start - this is called to setup the whole Forth system 
211c			 
211c			forth_init: 
211c			 
211c				; setup stack over/under flow checks 
211c			 
211c			;	if DEBUG_FORTH_STACK_GUARD 
211c			;		call chk_stk_init 
211c			;	endif 
211c			 
211c				; enable auto display updates (slow.....) 
211c			 
211c 3e 01			ld a, 1 
211e 32 a1 fc			ld (cli_autodisplay), a 
2121			 
2121			 
2121			 
2121				; show start up screen 
2121			 
2121 cd bf 0b			call clear_display 
2124			 
2124 3e 00			ld a,0 
2126 32 c3 fc			ld (f_cursor_ptr), a 
2129			 
2129				; set start of word list in start of ram - for use when creating user words 
2129			 
2129 21 00 80			ld hl, baseram 
212c 22 57 f7			ld (os_last_new_uword), hl 
212f cd d5 20			call user_word_eol 
2132				 
2132			;		call display_data_sp 
2132			;		call next_page_prompt 
2132			 
2132			 
2132			 
2132			 
2132 c9				ret 
2133			 
2133 .. 00		.bootforth: db " Forth Kernel Init ",0 
2147			 
2147			; TODO push to stack 
2147			 
2147			;  
2147			 
2147			if FORTH_PARSEV2 
2147			 
2147			 
2147				include "forth_parserv2.asm" 
2147			 
2147			endif 
2147			 
2147			 
2147			; parse cli version 1 
2147			 
2147			if FORTH_PARSEV1 
2147			 
2147			 
2147			 
2147			      include "forth_parserv1.asm" 
2147			endif 
2147				 
2147			if FORTH_PARSEV3 
2147			 
2147			 
2147			 
2147			      include "forth_parserv3.asm" 
2147				include "forth_wordsv3.asm" 
2147			endif 
2147			 
2147			if FORTH_PARSEV4 
2147			 
2147			 
2147			 
2147			      include "forth_parserv4.asm" 
2147				include "forth_wordsv4.asm" 
2147			endif 
2147			 
2147			if FORTH_PARSEV5 
2147			 
2147			 
2147			 
2147			      include "forth_parserv5.asm" 
2147			 
2147			 
2147			; A better parser without using malloc and string copies all over the place.  
2147			; Exec in situ should be faster 
2147			 
2147			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2147			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2147			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2147			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2147			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2147			WORD_SYS_END: equ 0   ; Opcode for all user words 
2147			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2147			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2147			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2147			 
2147			; Core word preamble macro 
2147			 
2147			CWHEAD:   macro nxtword opcode lit len opflags 
2147				db WORD_SYS_CORE+opcode             
2147				; internal op code number 
2147				dw nxtword            
2147				; link to next dict word block 
2147				db len + 1 
2147				; literal length of dict word inc zero term 
2147				db lit,0              
2147				; literal dict word 
2147			        ; TODO db opflags        
2147				endm 
2147			 
2147			 
2147			NEXTW: macro  
2147				jp macro_next 
2147				endm 
2147			 
2147			macro_next: 
2147			if DEBUG_FORTH_PARSE_KEY 
2147				DMARK "NXT" 
2147				CALLMONITOR 
2147			endif	 
2147			;	inc hl  ; skip token null term  
2147 ed 4b a5 fc		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
214b ed 5b a3 fc		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
214f 2a 5b f7			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2152			if DEBUG_FORTH_PARSE_KEY 
2152				DMARK "}AA" 
2152				CALLMONITOR 
2152			endif	 
2152 c3 55 22			jp execnext 
2155				;jp exec1 
2155			       
2155			 
2155			 
2155			; Another go at the parser to compile  
2155			 
2155			 
2155			; TODO rework parser to change all of the string words to byte tokens 
2155			; TODO do a search for  
2155			 
2155			; TODO first run normal parser to zero term sections 
2155			; TODO for each word do a token look up to get the op code 
2155			; TODO need some means to flag to the exec that this is a byte code form    
2155			 
2155			 
2155			forthcompile: 
2155			 
2155			; 
2155			; line parse: 
2155			;       parse raw input buffer 
2155			;       tokenise the words 
2155			;       malloc new copy (for looping etc) 
2155			;       copy to malloc + current pc in line to start of string and add line term 
2155			;       save on new rsp 
2155			; 
2155			 
2155			; hl to point to the line to tokenise 
2155			 
2155			;	push hl 
2155 22 5b f7			ld (os_tok_ptr), hl  ; save ptr to string 
2158			 
2158			;	ld a,0		; string term on input 
2158			;	call strlent 
2158			 
2158			;	ld (os_tok_len), hl	 ; save string length 
2158			 
2158			;if DEBUG_FORTH_TOK 
2158			;	ex de,hl		 
2158			;endif 
2158			 
2158			;	pop hl 		; get back string pointer 
2158			 
2158			if DEBUG_FORTH_TOK 
2158						DMARK "TOc" 
2158				CALLMONITOR 
2158			endif 
2158 7e			.cptoken2:    ld a,(hl) 
2159 23				inc hl 
215a fe 7f			cp FORTH_END_BUFFER 
215c 28 29			jr z, .cptokendone2 
215e fe 00			cp 0 
2160 28 25			jr z, .cptokendone2 
2162 fe 22			cp '"' 
2164 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2166 fe 20			cp ' ' 
2168 20 ee			jr nz,  .cptoken2 
216a			 
216a			; TODO consume comments held between ( and ) 
216a			 
216a				; we have a space so change to zero term for dict match later 
216a 2b				dec hl 
216b 3e 00			ld a,0 
216d 77				ld (hl), a 
216e 23				inc hl 
216f 18 e7			jr .cptoken2 
2171				 
2171			 
2171			.cptokenstr2: 
2171				; skip all white space until either eol (because forgot to term) or end double quote 
2171			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2171				;inc hl ; skip current double quote 
2171 7e				ld a,(hl) 
2172 23				inc hl 
2173 fe 22			cp '"' 
2175 28 e1			jr z, .cptoken2 
2177 fe 7f			cp FORTH_END_BUFFER 
2179 28 0c			jr z, .cptokendone2 
217b fe 00			cp 0 
217d 28 08			jr z, .cptokendone2 
217f fe 20			cp ' ' 
2181 28 02			jr z, .cptmp2 
2183 18 ec			jr .cptokenstr2 
2185			 
2185			.cptmp2:	; we have a space so change to zero term for dict match later 
2185				;dec hl 
2185				;ld a,"-"	; TODO remove this when working 
2185				;ld (hl), a 
2185				;inc hl 
2185 18 ea			jr .cptokenstr2 
2187			 
2187			.cptokendone2: 
2187				;inc hl 
2187 3e 7f			ld a, FORTH_END_BUFFER 
2189 77				ld (hl),a 
218a 23				inc hl 
218b 3e 21			ld a, '!' 
218d 77				ld (hl),a 
218e			 
218e 2a 5b f7			ld hl,(os_tok_ptr) 
2191			         
2191			if DEBUG_FORTH_TOK 
2191						DMARK "Tc1" 
2191				CALLMONITOR 
2191			endif 
2191			 
2191				; push exec string to top of return stack 
2191				FORTH_RSP_NEXT 
2191 cd 85 1d			call macro_forth_rsp_next 
2194				endm 
# End of macro FORTH_RSP_NEXT
2194 c9				ret 
2195			 
2195			; Another go at the parser need to simplify the process 
2195			 
2195			forthparse: 
2195			 
2195			; 
2195			; line parse: 
2195			;       parse raw input buffer 
2195			;       tokenise the words 
2195			;       malloc new copy (for looping etc) 
2195			;       copy to malloc + current pc in line to start of string and add line term 
2195			;       save on new rsp 
2195			; 
2195			 
2195			; hl to point to the line to tokenise 
2195			 
2195			;	push hl 
2195 22 5b f7			ld (os_tok_ptr), hl  ; save ptr to string 
2198			 
2198			;	ld a,0		; string term on input 
2198			;	call strlent 
2198			 
2198			;	ld (os_tok_len), hl	 ; save string length 
2198			 
2198			;if DEBUG_FORTH_TOK 
2198			;	ex de,hl		 
2198			;endif 
2198			 
2198			;	pop hl 		; get back string pointer 
2198			 
2198			if DEBUG_FORTH_TOK 
2198						DMARK "TOK" 
2198				CALLMONITOR 
2198			endif 
2198 7e			.ptoken2:    ld a,(hl) 
2199 23				inc hl 
219a fe 7f			cp FORTH_END_BUFFER 
219c 28 29			jr z, .ptokendone2 
219e fe 00			cp 0 
21a0 28 25			jr z, .ptokendone2 
21a2 fe 22			cp '"' 
21a4 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
21a6 fe 20			cp ' ' 
21a8 20 ee			jr nz,  .ptoken2 
21aa			 
21aa			; TODO consume comments held between ( and ) 
21aa			 
21aa				; we have a space so change to zero term for dict match later 
21aa 2b				dec hl 
21ab 3e 00			ld a,0 
21ad 77				ld (hl), a 
21ae 23				inc hl 
21af 18 e7			jr .ptoken2 
21b1				 
21b1			 
21b1			.ptokenstr2: 
21b1				; skip all white space until either eol (because forgot to term) or end double quote 
21b1			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
21b1				;inc hl ; skip current double quote 
21b1 7e				ld a,(hl) 
21b2 23				inc hl 
21b3 fe 22			cp '"' 
21b5 28 e1			jr z, .ptoken2 
21b7 fe 7f			cp FORTH_END_BUFFER 
21b9 28 0c			jr z, .ptokendone2 
21bb fe 00			cp 0 
21bd 28 08			jr z, .ptokendone2 
21bf fe 20			cp ' ' 
21c1 28 02			jr z, .ptmp2 
21c3 18 ec			jr .ptokenstr2 
21c5			 
21c5			.ptmp2:	; we have a space so change to zero term for dict match later 
21c5				;dec hl 
21c5				;ld a,"-"	; TODO remove this when working 
21c5				;ld (hl), a 
21c5				;inc hl 
21c5 18 ea			jr .ptokenstr2 
21c7			 
21c7			.ptokendone2: 
21c7				;inc hl 
21c7 3e 7f			ld a, FORTH_END_BUFFER 
21c9 77				ld (hl),a 
21ca 23				inc hl 
21cb 3e 21			ld a, '!' 
21cd 77				ld (hl),a 
21ce			 
21ce 2a 5b f7			ld hl,(os_tok_ptr) 
21d1			         
21d1			if DEBUG_FORTH_TOK 
21d1						DMARK "TK1" 
21d1				CALLMONITOR 
21d1			endif 
21d1			 
21d1				; push exec string to top of return stack 
21d1				FORTH_RSP_NEXT 
21d1 cd 85 1d			call macro_forth_rsp_next 
21d4				endm 
# End of macro FORTH_RSP_NEXT
21d4 c9				ret 
21d5			 
21d5			; 
21d5			;	; malloc size + buffer pointer + if is loop flag 
21d5			;	ld hl,(os_tok_len) 		 ; get string length 
21d5			; 
21d5			;	ld a,l 
21d5			; 
21d5			;	cp 0			; we dont want to use a null string 
21d5			;	ret z 
21d5			; 
21d5			;;	add 3    ; prefix malloc with buffer for current word ptr 
21d5			; 
21d5			;	add 5     ; TODO when certain not over writing memory remove 
21d5			; 
21d5			;		 
21d5			; 
21d5			;if DEBUG_FORTH_TOK 
21d5			;			DMARK "TKE" 
21d5			;	CALLMONITOR 
21d5			;endif 
21d5			; 
21d5			;	ld l,a 
21d5			;	ld h,0 
21d5			;;	push hl   ; save required space for the copy later 
21d5			;	call malloc 
21d5			;if DEBUG_FORTH_TOK 
21d5			;			DMARK "TKM" 
21d5			;	CALLMONITOR 
21d5			;endif 
21d5			;	if DEBUG_FORTH_MALLOC_GUARD 
21d5			;		push af 
21d5			;		call ishlzero 
21d5			;;		ld a, l 
21d5			;;		add h 
21d5			;;		cp 0 
21d5			;		pop af 
21d5			;		 
21d5			;		call z,malloc_error 
21d5			;	endif 
21d5			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
21d5			; 
21d5			; 
21d5			;if DEBUG_FORTH_TOK 
21d5			;			DMARK "TKR" 
21d5			;	CALLMONITOR 
21d5			;endif 
21d5			; 
21d5			;	FORTH_RSP_NEXT 
21d5			; 
21d5			;	;inc hl	 ; go past current buffer pointer 
21d5			;	;inc hl 
21d5			;	;inc hl   ; and past if loop flag 
21d5			;		; TODO Need to set flag  
21d5			; 
21d5			;	 
21d5			;	 
21d5			;	ex de,hl	; malloc is dest 
21d5			;	ld hl, (os_tok_len) 
21d5			;;	pop bc 
21d5			;	ld c, l                
21d5			;	ld b,0 
21d5			;	ld hl, (os_tok_ptr) 
21d5			; 
21d5			;if DEBUG_FORTH_TOK 
21d5			;			DMARK "TKT" 
21d5			;	CALLMONITOR 
21d5			;endif 
21d5			; 
21d5			;	; do str cpy 
21d5			; 
21d5			;	ldir      ; copy byte in hl to de 
21d5			; 
21d5			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
21d5			; 
21d5			;if DEBUG_FORTH_TOK 
21d5			; 
21d5			;			DMARK "TKY" 
21d5			;	CALLMONITOR 
21d5			;endif 
21d5			;	;ld a,0 
21d5			;	;ld a,FORTH_END_BUFFER 
21d5			;	ex de, hl 
21d5			;	;dec hl			 ; go back over the space delim at the end of word 
21d5			;	;ld (hl),a 
21d5			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
21d5			;	ld a,FORTH_END_BUFFER 
21d5			;	ld (hl),a 
21d5			;	inc hl 
21d5			;	ld a,FORTH_END_BUFFER 
21d5			;	ld (hl),a 
21d5			; 
21d5			;	; init the malloc area data 
21d5			;	; set pc for in current area 
21d5			;	;ld hl, (os_tok_malloc) 
21d5			;	;inc hl 
21d5			;	;inc hl 
21d5			;	;inc hl 
21d5			;	;ex de,hl 
21d5			;	;ld hl, (os_tok_malloc) 
21d5			;	;ld (hl),e 
21d5			;	;inc hl 
21d5			;	;ld (hl),d 
21d5			; 
21d5			; 
21d5			;	ld hl,(os_tok_malloc) 
21d5			;if DEBUG_FORTH_PARSE_KEY 
21d5			;			DMARK "TKU" 
21d5			;	CALLMONITOR 
21d5			;endif 
21d5			; 
21d5			;	ret 
21d5			 
21d5			forthexec: 
21d5			 
21d5			; line exec: 
21d5			; forth parser 
21d5			 
21d5			; 
21d5			;       get current exec line on rsp 
21d5			 
21d5				FORTH_RSP_TOS 
21d5 cd 9c 1d			call macro_forth_rsp_tos 
21d8				endm 
# End of macro FORTH_RSP_TOS
21d8			 
21d8			;       restore current pc - hl points to malloc of data 
21d8			 
21d8				;ld e, (hl) 
21d8				;inc hl 
21d8				;ld d, (hl) 
21d8				;ex de,hl 
21d8			 
21d8			 
21d8			exec1: 
21d8 22 5b f7			ld (os_tok_ptr), hl 
21db			 
21db				; copy our PC to working vars  
21db 22 a5 fc			ld (cli_ptr), hl 
21de 22 a3 fc			ld (cli_origptr), hl 
21e1			 
21e1 7e				ld a,(hl) 
21e2 fe 7f			cp FORTH_END_BUFFER 
21e4 c8				ret z 
21e5			 
21e5				; skip any nulls 
21e5			 
21e5 fe 00			cp 0 
21e7 20 03			jr nz, .execword 
21e9 23				inc hl 
21ea 18 ec			jr exec1 
21ec			 
21ec			 
21ec			.execword: 
21ec			 
21ec			 
21ec			 
21ec			if DEBUG_FORTH_PARSE_KEY 
21ec						DMARK "KYQ" 
21ec				CALLMONITOR 
21ec			endif 
21ec			;       while at start of word: 
21ec			; get start of dict (in user area first) 
21ec			 
21ec 21 00 80		ld hl, baseram 
21ef			;ld hl, sysdict 
21ef 22 a7 fc		ld (cli_nextword),hl 
21f2			;           match word at pc 
21f2			;           exec word 
21f2			;           or push to dsp 
21f2			;           forward to next token 
21f2			;           if line term pop rsp and exit 
21f2			;        
21f2			 
21f2			if DEBUG_FORTH_PARSE_KEY 
21f2						DMARK "KYq" 
21f2				CALLMONITOR 
21f2			endif 
21f2			 
21f2			; 
21f2			; word comp 
21f2			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
21f2			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
21f2			;    move to start of word  
21f2			;    compare word to cli_token 
21f2			 
21f2			.execpnword:	; HL at start of a word in the dictionary to check 
21f2			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
21f2			;	ld (cli_ptr), hl 
21f2			 
21f2 2a a7 fc			ld hl,(cli_nextword) 
21f5			 
21f5 cd 98 22			call forth_tok_next 
21f8			; tok next start here 
21f8			;	; TODO skip compiled symbol for now 
21f8			;	inc hl 
21f8			; 
21f8			;	; save pointer to next word 
21f8			; 
21f8			;	; hl now points to the address of the next word pointer  
21f8			;	ld e, (hl) 
21f8			;	inc hl 
21f8			;	ld d, (hl) 
21f8			;	inc l 
21f8			; 
21f8			;	ex de,hl 
21f8			;if DEBUG_FORTH_PARSE_NEXTWORD 
21f8			;	push bc 
21f8			;	ld bc, (cli_nextword) 
21f8			;			DMARK "NXW" 
21f8			;	CALLMONITOR 
21f8			;	pop bc 
21f8			;endif 
21f8			; tok next end here 
21f8 22 a7 fc			ld (cli_nextword), hl     ; save for next check if no match on this word 
21fb eb				ex de, hl 
21fc			 
21fc			 
21fc				; save the pointer of the current token - 1 to check against 
21fc				 
21fc 22 ab fc			ld (cli_token), hl   
21ff				; TODO maybe remove below save if no debug 
21ff				; save token string ptr for any debug later 
21ff 23				inc hl  
2200 22 ad fc			ld (cli_origtoken), hl 
2203 2b				dec hl 
2204				; save pointer to the start of the next dictionay word 
2204 7e				ld a,(hl)   ; get string length 
2205 47				ld b,a 
2206			.execpnwordinc:  
2206 23				inc hl 
2207 10 fd			djnz .execpnwordinc 
2209 22 a9 fc			ld (cli_execword), hl      ; save start of this words code 
220c			 
220c				; now check the word token against the string being parsed 
220c			 
220c 2a ab fc			ld hl,(cli_token) 
220f 23				inc hl     ; skip string length (use zero term instead to end) 
2210 22 ab fc			ld (cli_token), hl 
2213			 
2213			if DEBUG_FORTH_PARSE_KEY 
2213						DMARK "KY2" 
2213			endif 
2213			if DEBUG_FORTH_PARSE_EXEC 
2213				; see if disabled 
2213			 
2213				ld a, (os_view_disable) 
2213				cp '*' 
2213				jr z, .skip 
2213			 
2213				push hl 
2213				push hl 
2213				call clear_display 
2213				ld de, .compword 
2213				ld a, display_row_1 
2213				call str_at_display 
2213				pop de 
2213				ld a, display_row_2 
2213				call str_at_display 
2213				ld hl,(cli_ptr) 
2213				ld a,(hl) 
2213			        ld hl, os_word_scratch 
2213				ld (hl),a 
2213				ld a,0 
2213				inc hl 
2213				ld (hl),a 	 
2213				ld de, os_word_scratch 
2213				ld a, display_row_2+10 
2213				call str_at_display 
2213				call update_display 
2213				ld a, 100 
2213				call aDelayInMS 
2213				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2213				call delay250ms 
2213				endif 
2213				pop hl 
2213			.skip:  
2213			endif	 
2213			.execpnchar:    ; compare char between token and string to parse 
2213			 
2213			if DEBUG_FORTH_PARSE_KEY 
2213						DMARK "Ky3" 
2213			endif 
2213			if DEBUG_FORTH_PARSE_EXEC 
2213				; see if disabled 
2213			 
2213				ld a, (os_view_disable) 
2213				cp '*' 
2213				jr z, .skip2 
2213			 
2213			;	call clear_display 
2213			ld hl,(cli_token) 
2213			ld a,(hl) 
2213			ld (os_word_scratch),a 
2213				ld hl,(cli_ptr) 
2213			ld a,(hl) 
2213				ld (os_word_scratch+1),a 
2213				ld a,0 
2213				ld (os_word_scratch+2),a 
2213				ld de,os_word_scratch 
2213				ld a,display_row_4 
2213				call str_at_display 
2213				call update_display 
2213			.skip2:  
2213			endif 
2213 2a ab fc			ld hl,(cli_token) 
2216 7e				ld a, (hl)	 ; char in word token 
2217 23				inc hl 		; move to next char 
2218 22 ab fc			ld (cli_token), hl ; and save it 
221b 47				ld b,a 
221c			 
221c 2a a5 fc			ld hl,(cli_ptr) ;	get the char from the string to parse 
221f 7e				ld a,(hl) 
2220 23				inc hl 
2221 22 a5 fc			ld (cli_ptr), hl		; move to next char 
2224 cd 48 12			call toUpper 		; make sure the input string matches case 
2227			 
2227			if DEBUG_FORTH_PARSE 
2227			endif 
2227			 
2227				; input stream end of token is a space so get rid of it 
2227			 
2227			;	cp ' ' 
2227			;	jr nz, .pnskipspace 
2227			; 
2227			;	ld a, 0		; make same term as word token term 
2227			; 
2227			;.pnskipspace: 
2227			 
2227			if DEBUG_FORTH_PARSE_KEY 
2227						DMARK "KY7" 
2227			endif 
2227 b8				cp b 
2228 c2 3e 22			jp nz, .execpnskipword	 ; no match so move to next word 
222b				 
222b			;    if same 
222b			;       scan for string terms 0 for token and 32 for input 
222b			 
222b				 
222b			if DEBUG_FORTH_PARSE_KEY 
222b						DMARK "KY8" 
222b			endif 
222b			 
222b 80				add b			 
222c fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
222e							; TODO need to make sure last word in zero term string is accounted for 
222e 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2230			 
2230			 
2230				; at end of both strings so both are exact match 
2230			 
2230			;       skip ptr for next word 
2230			 
2230 2a a5 fc			ld hl,(cli_ptr) 	; at input string term 
2233 23				inc hl			 ; at next char 
2234 22 a5 fc			ld (cli_ptr), hl     ; save for next round of the parser 
2237 22 a3 fc			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
223a				 
223a				 
223a			if DEBUG_FORTH_PARSE_KEY 
223a						DMARK "KY3" 
223a			endif 
223a			 
223a			 
223a			 
223a			;       exec code block 
223a			if DEBUG_FORTH_JP 
223a				call clear_display 
223a				call update_display 
223a				call delay1s 
223a				ld hl, (cli_execword)     ; save for next check if no match on this word 
223a				ld a,h 
223a				ld hl, os_word_scratch 
223a				call hexout 
223a				ld hl, (cli_execword)     ; save for next check if no match on this word 
223a				ld a,l 
223a				ld hl, os_word_scratch+2 
223a				call hexout 
223a				ld hl, os_word_scratch+4 
223a				ld a,0 
223a				ld (hl),a 
223a				ld de,os_word_scratch 
223a				call str_at_display 
223a					ld a, display_row_2 
223a					call str_at_display 
223a				ld de, (cli_origtoken) 
223a				ld a, display_row_1+10 
223a					call str_at_display 
223a			 
223a				ld a,display_row_1 
223a				ld de, .foundword 
223a				ld a, display_row_3 
223a				call str_at_display 
223a				call update_display 
223a				call delay1s 
223a				call delay1s 
223a				call delay1s 
223a			endif 
223a			 
223a			if DEBUG_FORTH_PARSE_KEY 
223a						DMARK "KYj" 
223a			endif 
223a				; TODO save the word pointer in this exec 
223a			 
223a 2a a9 fc			ld hl,(cli_execword) 
223d e9				jp (hl) 
223e			 
223e			 
223e			;    if not same 
223e			;	scan for zero term 
223e			;	get ptr for next word 
223e			;	goto word comp 
223e			 
223e			.execpnskipword:	; get pointer to next word 
223e 2a a7 fc			ld hl,(cli_nextword) 
2241			 
2241 7e				ld a,(hl) 
2242 fe 00			cp WORD_SYS_END 
2244			;	cp 0 
2244 28 09			jr z, .execendofdict			 ; at end of words 
2246			 
2246			if DEBUG_FORTH_PARSE_KEY 
2246						DMARK "KY4" 
2246			endif 
2246			if DEBUG_FORTH_PARSE_EXEC 
2246			 
2246				; see if disabled 
2246			 
2246				ld a, (os_view_disable) 
2246				cp '*' 
2246				jr z, .noskip 
2246			 
2246			 
2246				ld de, .nowordfound 
2246				ld a, display_row_3 
2246				call str_at_display 
2246				call update_display 
2246				ld a, 100 
2246				call aDelayInMS 
2246				 
2246				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2246					call delay250ms 
2246				endif 
2246			.noskip:  
2246			 
2246			endif	 
2246			 
2246 2a a3 fc			ld hl,(cli_origptr) 
2249 22 a5 fc			ld (cli_ptr),hl 
224c			 
224c			if DEBUG_FORTH_PARSE_KEY 
224c						DMARK "KY5" 
224c			endif 
224c c3 f2 21			jp .execpnword			; else go to next word 
224f			 
224f			.execendofdict:  
224f			 
224f			if DEBUG_FORTH_PARSE_KEY 
224f						DMARK "KYe" 
224f			endif 
224f			if DEBUG_FORTH_PARSE_EXEC 
224f				; see if disabled 
224f			 
224f				ld a, (os_view_disable) 
224f				cp '*' 
224f				jr z, .ispskip 
224f			 
224f				call clear_display 
224f				call update_display 
224f				call delay1s 
224f				ld de, (cli_origptr) 
224f				ld a, display_row_1 
224f				call str_at_display 
224f				 
224f				ld de, .enddict 
224f				ld a, display_row_3 
224f				call str_at_display 
224f				call update_display 
224f				ld a, 100 
224f				call aDelayInMS 
224f				if DEBUG_FORTH_PARSE_EXEC_SLOW 
224f				call delay1s 
224f				call delay1s 
224f				call delay1s 
224f				endif 
224f			.ispskip:  
224f				 
224f			endif	 
224f			 
224f			 
224f			 
224f				; if the word is not a keyword then must be a literal so push it to stack 
224f			 
224f			; push token to stack to end of word 
224f			 
224f				STACKFRAME ON $1efe $2f9f 
224f				if DEBUG_STACK_IMB 
224f					if ON 
224f						exx 
224f						ld de, $1efe 
224f						ld a, d 
224f						ld hl, curframe 
224f						call hexout 
224f						ld a, e 
224f						ld hl, curframe+2 
224f						call hexout 
224f						ld hl, $1efe 
224f						push hl 
224f						ld hl, $2f9f 
224f						push hl 
224f						exx 
224f					endif 
224f				endif 
224f			endm 
# End of macro STACKFRAME
224f			 
224f 2a 5b f7		ld hl,(os_tok_ptr) 
2252 cd 47 1f		call forth_apush 
2255			 
2255				STACKFRAMECHK ON $1efe $2f9f 
2255				if DEBUG_STACK_IMB 
2255					if ON 
2255						exx 
2255						ld hl, $2f9f 
2255						pop de   ; $2f9f 
2255						call cmp16 
2255						jr nz, .spnosame 
2255						ld hl, $1efe 
2255						pop de   ; $1efe 
2255						call cmp16 
2255						jr z, .spfrsame 
2255						.spnosame: call showsperror 
2255						.spfrsame: nop 
2255						exx 
2255					endif 
2255				endif 
2255			endm 
# End of macro STACKFRAMECHK
2255			 
2255			execnext: 
2255			 
2255			if DEBUG_FORTH_PARSE_KEY 
2255						DMARK "KY>" 
2255			endif 
2255			; move past token to next word 
2255			 
2255 2a 5b f7		ld hl, (os_tok_ptr) 
2258 3e 00		ld a, 0 
225a 01 ff 00		ld bc, 255     ; input buffer size 
225d ed b1		cpir 
225f			 
225f			if DEBUG_FORTH_PARSE_KEY 
225f						DMARK "KY!" 
225f				CALLMONITOR 
225f			endif	 
225f			; TODO this might place hl on the null, so will need to forward on??? 
225f			;inc hl   ; see if this gets onto the next item 
225f			 
225f			 
225f			; TODO pass a pointer to the buffer to push 
225f			; TODO call function to push 
225f			 
225f			; look for end of input 
225f			 
225f			;inc hl 
225f			;ld a,(hl) 
225f			;cp FORTH_END_BUFFER 
225f			;ret z 
225f			 
225f			 
225f c3 d8 21		jp exec1 
2262			 
2262			 
2262			 
2262			 
2262			 
2262			 
2262			 
2262			 
2262			 
2262			findnexttok: 
2262			 
2262				; hl is pointer to move 
2262				; de is the token to locate 
2262			 
2262					if DEBUG_FORTH 
2262						DMARK "NTK" 
2262						CALLMONITOR 
2262					endif 
2262 d5				push de 
2263			 
2263			.fnt1:	 
2263				; find first char of token to locate 
2263			 
2263 1a				ld a, (de) 
2264 4f				ld c,a 
2265 7e				ld a,(hl) 
2266 cd 48 12			call toUpper 
2269					if DEBUG_FORTH 
2269						DMARK "NT1" 
2269						CALLMONITOR 
2269					endif 
2269 b9				cp c 
226a			 
226a 28 03			jr z, .fnt2cmpmorefirst	 
226c			 
226c				; first char not found move to next char 
226c			 
226c 23				inc hl 
226d 18 f4			jr .fnt1 
226f			 
226f			.fnt2cmpmorefirst:	 
226f				; first char of token found.  
226f			 
226f e5				push hl     ; save start of token just in case it is the right one 
2270 d9				exx 
2271 e1				pop hl        ; save it to hl' 
2272 d9				exx 
2273			 
2273			 
2273			.fnt2cmpmore:	 
2273				; compare the rest 
2273				 
2273 23				inc hl 
2274 13				inc de 
2275				 
2275 1a				ld a, (de) 
2276 4f				ld c,a 
2277 7e				ld a,(hl) 
2278 cd 48 12			call toUpper 
227b			 
227b					if DEBUG_FORTH 
227b						DMARK "NT2" 
227b						CALLMONITOR 
227b					endif 
227b				; c has the token to find char 
227b				; a has the mem to scan char 
227b			 
227b b9				cp c 
227c 28 04			jr z,.fntmatch1 
227e			 
227e				; they are not the same 
227e			 
227e					if DEBUG_FORTH 
227e						DMARK "NT3" 
227e						CALLMONITOR 
227e					endif 
227e d1				pop de	; reset de token to look for 
227f d5				push de 
2280 18 e1			jr .fnt1 
2282				 
2282			.fntmatch1: 
2282			 
2282				; is the same char a null which means we might have a full hit? 
2282					if DEBUG_FORTH 
2282						DMARK "NT4" 
2282						CALLMONITOR 
2282					endif 
2282			 
2282 fe 00			cp 0 
2284 28 0b			jr z, .fntmatchyes 
2286			 
2286				; are we at the end of the token to find? 
2286			 
2286					if DEBUG_FORTH 
2286						DMARK "NT5" 
2286						CALLMONITOR 
2286					endif 
2286 3e 00			ld a, 0 
2288 b9				cp c 
2289			 
2289 c2 73 22			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
228c			 
228c					if DEBUG_FORTH 
228c						DMARK "NT6" 
228c						CALLMONITOR 
228c					endif 
228c				; token to find is exhusted but no match to stream 
228c			 
228c				; restore tok pointer and continue on 
228c d1				pop de 
228d d5				push de 
228e c3 63 22			jp .fnt1 
2291			 
2291			 
2291			.fntmatchyes: 
2291			 
2291				; hl now contains the end of the found token 
2291			 
2291				; get rid of saved token pointer to find 
2291			 
2291 d1				pop de 
2292			 
2292					if DEBUG_FORTH 
2292						DMARK "NT9" 
2292						CALLMONITOR 
2292					endif 
2292			 
2292				; hl will be on the null term so forward on 
2292			 
2292				; get back the saved start of the token 
2292			 
2292 d9				exx 
2293 e5				push hl     ; save start of token just in case it is the right one 
2294 d9				exx 
2295 e1				pop hl        ; save it to hl 
2296			 
2296 c9				ret 
2297			 
2297			 
2297			; LIST needs to find a specific token   
2297			; FORGET needs to find a spefici token 
2297			 
2297			; SAVE needs to find all tokens by flag 
2297			; WORDS just needs to scan through all  by flag 
2297			; UWORDS needs to scan through all by flag 
2297			 
2297			 
2297			; given hl as pointer to start of dict look up string 
2297			; return hl as pointer to start of word block 
2297			; or 0 if not found 
2297			 
2297			forth_find_tok: 
2297 c9				ret 
2298			 
2298			; given hl as pointer to dict structure 
2298			; move to the next dict block structure 
2298			 
2298			forth_tok_next: 
2298				; hl now points to the address of the next word pointer  
2298				; TODO skip compiled symbol for now 
2298			;	push de 
2298 23				inc hl 
2299 5e				ld e, (hl) 
229a 23				inc hl 
229b 56				ld d, (hl) 
229c 23				inc hl 
229d			 
229d eb				ex de,hl 
229e			if DEBUG_FORTH_PARSE_NEXTWORD 
229e				push bc 
229e				ld bc, (cli_nextword) 
229e						DMARK "NXW" 
229e				CALLMONITOR 
229e				pop bc 
229e			endif 
229e			;	pop de	 
229e c9				ret 
229f			 
229f			 
229f			 
229f			; eof 
# End of file forth_parserv5.asm
229f				include "forth_wordsv4.asm" 
229f			 
229f			; the core word dictionary v4 
229f			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
229f			 
229f			; this is a linked list for each of the system words used 
229f			; user defined words will follow the same format but will be in ram 
229f			 
229f			 
229f			; 
229f			; 
229f			; define linked list: 
229f			; 
229f			; 1. compiled byte op code 
229f			; 2. len of text word 
229f			; 3. text word 
229f			; 4. ptr to next dictionary word 
229f			; 5. asm, calls etc for the word 
229f			; 
229f			;  if 1 == 0 then last word in dict  
229f			;   
229f			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
229f			;  
229f			;  
229f			; create basic standard set of words 
229f			; 
229f			;  
229f			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
229f			; 2DUP 2DROP 2SWAP  
229f			; @ C@ - get byte  
229f			; ! C! - store byte 
229f			; 0< true if less than zero 
229f			; 0= true if zero 
229f			; < >  
229f			; = true if same 
229f			; variables 
229f			 
229f			 
229f			; Hardware specific words I may need 
229f			; 
229f			; IN OUT  
229f			; calls to key util functions 
229f			; calls to hardward abstraction stuff 
229f			; easy control of frame buffers and lcd i/o 
229f			; keyboard  
229f			 
229f			 
229f			;DICT: macro 
229f			; op_code, len, word, next 
229f			;    word: 
229f			;    db op_code 
229f			;    ds word zero term 
229f			;    dw next 
229f			;    endm 
229f			 
229f			 
229f			 
229f			 
229f			; op code 1 is a flag for user define words which are to be handled differently 
229f			 
229f			 
229f			; 
229f			; 
229f			;    TODO on entry to a word this should be the expected environment 
229f			;    hl - tos value if number then held, if string this is the ptr 
229f			;    de -  
229f			 
229f			 
229f			; opcode ranges 
229f			; 0 - end of word dict 
229f			; 255 - user define words 
229f			 
229f			sysdict: 
229f			include "forth_opcodes.asm" 
229f			; op codes for forth keywords 
229f			; free to use code 0  
229f				OPCODE_HEAP: equ  1 
229f				OPCODE_EXEC: equ 2 
229f				OPCODE_DUP: equ 3 
229f				OPCODE_SWAP: equ 4 
229f				OPCODE_COLN: equ 5 
229f				OPCODE_SCOLN: equ 6 
229f				OPCODE_DROP: equ 7 
229f				OPCODE_DUP2: equ 8 
229f				OPCODE_DROP2: equ 9 
229f				OPCODE_SWAP2: equ 10 
229f				OPCODE_AT: equ 11 
229f				OPCODE_CAT: equ 12 
229f				OPCODE_BANG: equ 13 
229f				OPCODE_CBANG: equ 14 
229f				OPCODE_SCALL: equ 15 
229f				OPCODE_DEPTH: equ 16 
229f				OPCODE_OVER: equ 17 
229f				OPCODE_PAUSE: equ 18 
229f				OPCODE_PAUSES: equ 19 
229f				OPCODE_ROT: equ 20 
229f			;free to reuse	OPCODE_WORDS: equ 21 
229f			        OPCODE_NOT: equ 21 
229f				OPCODE_UWORDS: equ 22 
229f				OPCODE_BP: equ 23 
229f				OPCODE_MONITOR: equ 24  
229f				OPCODE_MALLOC: equ 25 
229f				OPCODE_FREE: equ 26 
229f				OPCODE_LIST: equ 27 
229f				OPCODE_FORGET: equ 28 
229f				OPCODE_NOP: equ 29 
229f				OPCODE_COMO: equ 30 
229f				OPCODE_COMC: equ 31 
229f			;free to reuse	OPCODE_ENDCORE: equ 32 
229f				OPCODE_AFTERSOUND: equ 33 
229f				OPCODE_GP2: equ 34 
229f				OPCODE_GP3: equ 35 
229f				OPCODE_GP4: equ 36 
229f				OPCODE_SIN: equ 37 
229f				OPCODE_SOUT: equ 38 
229f				OPCODE_SPIO: equ 39 
229f				OPCODE_SPICEH: equ 40 
229f				OPCODE_SPIOb: equ 41 
229f				OPCODE_SPII: equ 42 
229f				OPCODE_SESEL: equ 43 
229f				OPCODE_CARTDEV: equ 44 
229f			; free to reuse	OPCODE_ENDDEVICE: equ 45 
229f				OPCODE_FB: equ 46 
229f				OPCODE_EMIT: equ 47 
229f				OPCODE_DOTH: equ 48 
229f				OPCODE_DOTF: equ 49 
229f				OPCODE_DOT: equ 50 
229f				OPCODE_CLS: equ 51 
229f				OPCODE_DRAW: equ 52 
229f				OPCODE_DUMP: equ 53 
229f				OPCODE_CDUMP: equ 54 
229f				OPCODE_DAT: equ 55 
229f				OPCODE_HOME: equ 56 
229f				OPCODE_SPACE: equ 57 
229f				OPCODE_SPACES: equ 58 
229f				OPCODE_SCROLL: equ 59 
229f				OPCODE_ATQ: equ 60 
229f				OPCODE_AUTODSP: equ 61 
229f				OPCODE_MENU: equ 62 
229f			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
229f				OPCODE_THEN: equ 64 
229f				OPCODE_ELSE: equ 65 
229f				OPCODE_DO: equ 66 
229f				OPCODE_LOOP: equ 67 
229f				OPCODE_I: equ 68 
229f				OPCODE_DLOOP: equ 69  
229f				OPCODE_REPEAT: equ 70  
229f				OPCODE_UNTIL: equ 71 
229f				OPCODE_ENDFLOW: equ 72 
229f				OPCODE_WAITK: equ 73 
229f				OPCODE_ACCEPT: equ 74 
229f				OPCODE_EDIT: equ 75 
229f			;free to reuse	OPCODE_ENDKEY: equ 76 
229f				OPCODE_LZERO: equ 77 
229f				OPCODE_TZERO: equ 78 
229f				OPCODE_LESS: equ 79 
229f				OPCODE_GT: equ 80 
229f				OPCODE_EQUAL: equ 81  
229f			;free to reuse	OPCODE_ENDLOGIC: equ 82 
229f				OPCODE_NEG: equ 83 
229f				OPCODE_DIV: equ 84 
229f				OPCODE_MUL: equ 85 
229f				OPCODE_MIN: equ 86 
229f				OPCODE_MAX: equ 87 
229f				OPCODE_RND16: equ 88 
229f				OPCODE_RND8: equ 89 
229f				OPCODE_RND: equ 90 
229f			;free to reuse	OPCODE_ENDMATHS: equ 91  
229f				OPCODE_BYNAME: equ 92 
229f				OPCODE_DIR: equ 93 
229f				OPCODE_SAVE: equ 94 
229f				OPCODE_LOAD: equ 95 
229f				OPCODE_BSAVE: equ 96 
229f				OPCODE_BLOAD: equ 97 
229f				OPCODE_SEO: equ 98  
229f				OPCODE_SEI: equ 99 
229f				OPCODE_SFREE: equ 100 
229f				OPCODE_SIZE: equ 101 
229f				OPCODE_CREATE: equ 102 
229f				OPCODE_APPEND: equ 103 
229f				OPCODE_SDEL: equ 104 
229f				OPCODE_OPEN: equ 105 
229f				OPCODE_READ: equ 106 
229f				OPCODE_EOF: equ 106 
229f				OPCODE_FORMAT: equ 107 
229f				OPCODE_LABEL: equ 108 
229f				OPCODE_LABELS: equ 109 
229f			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
229f				OPCODE_UPPER: equ 111 
229f				OPCODE_LOWER: equ 112 
229f				OPCODE_SUBSTR: equ 113 
229f				OPCODE_LEFT: equ 114 
229f				OPCODE_RIGHT: equ 115 
229f				OPCODE_STR2NUM: equ 116 
229f				OPCODE_NUM2STR: equ 117 
229f				OPCODE_CONCAT: equ 118 
229f				OPCODE_FIND: equ 119 
229f				OPCODE_LEN: equ 120 
229f				OPCODE_CHAR: equ 121 
229f			; free to reuse	OPCODE_STRLEN: equ 122 
229f			; free to reuse	OPCODE_ENDSTR: equ 123 
229f				OPCODE_V0S: equ 124 
229f				OPCODE_V0Q: equ 125 
229f				OPCODE_V1S: equ 126 
229f				OPCODE_V1Q: equ 127 
229f				OPCODE_V2S: equ 128 
229f				OPCODE_V2Q: equ 129 
229f				OPCODE_V3S: equ 130 
229f				OPCODE_V3Q: equ 131 
229f			;free to reuse	OPCODE_END: equ 132 
229f				OPCODE_ZDUP: equ 133 
229f			 
229f			; eof 
# End of file forth_opcodes.asm
229f			 
229f			include "forth_words_core.asm" 
229f			 
229f			; | ## Core Words 
229f			 
229f			;if MALLOC_4 
229f			 
229f			.HEAP: 
229f				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
229f 15				db WORD_SYS_CORE+OPCODE_HEAP             
22a0 de 22			dw .EXEC            
22a2 05				db 4 + 1 
22a3 .. 00			db "HEAP",0              
22a8				endm 
# End of macro CWHEAD
22a8			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
22a8			; | | u1 - Current number of bytes in the heap 
22a8			; | | u2 - Remaining bytes left on the heap 
22a8			; | |  
22a8			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
22a8			 
22a8			 
22a8					if DEBUG_FORTH_WORDS_KEY 
22a8						DMARK "HEP" 
22a8 f5				push af  
22a9 3a bd 22			ld a, (.dmark)  
22ac 32 b4 fe			ld (debug_mark),a  
22af 3a be 22			ld a, (.dmark+1)  
22b2 32 b5 fe			ld (debug_mark+1),a  
22b5 3a bf 22			ld a, (.dmark+2)  
22b8 32 b6 fe			ld (debug_mark+2),a  
22bb 18 03			jr .pastdmark  
22bd ..			.dmark: db "HEP"  
22c0 f1			.pastdmark: pop af  
22c1			endm  
# End of macro DMARK
22c1						CALLMONITOR 
22c1 cd 70 17			call break_point_state  
22c4				endm  
# End of macro CALLMONITOR
22c4					endif 
22c4 2a 0a 80				ld hl, (free_list )      
22c7 11 0e 80				ld de, heap_start 
22ca			 
22ca ed 52				sbc hl, de  
22cc			 
22cc cd de 1d				call forth_push_numhl 
22cf			 
22cf			 
22cf ed 5b 0a 80			ld de, (free_list )      
22d3 21 40 f4				ld hl, heap_end 
22d6			 
22d6 ed 52				sbc hl, de 
22d8			 
22d8 cd de 1d				call forth_push_numhl 
22db					 
22db			 
22db					 
22db			 
22db			 
22db			 
22db					NEXTW 
22db c3 47 21			jp macro_next 
22de				endm 
# End of macro NEXTW
22de			;endif 
22de			 
22de			.EXEC: 
22de			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
22de			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
22de			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
22de			;; > > 
22de			;; > >   
22de			;	STACKFRAME OFF $5efe $5f9f 
22de			; 
22de			;		if DEBUG_FORTH_WORDS_KEY 
22de			;			DMARK "EXE" 
22de			;			CALLMONITOR 
22de			;		endif 
22de			; 
22de			;	FORTH_DSP_VALUEHL 
22de			; 
22de			;	FORTH_DSP_POP 
22de			; 
22de			;		if DEBUG_FORTH_WORDS 
22de			;			DMARK "EX1" 
22de			;			CALLMONITOR 
22de			;		endif 
22de			;;	ld e,(hl) 
22de			;;	inc hl 
22de			;;	ld d,(hl) 
22de			;;	ex de,hl 
22de			; 
22de			;;		if DEBUG_FORTH_WORDS 
22de			;;			DMARK "EX2" 
22de			;;			CALLMONITOR 
22de			;;		endif 
22de			;	push hl 
22de			; 
22de			;	;ld a, 0 
22de			;	;ld a, FORTH_END_BUFFER 
22de			;	call strlenz 
22de			;	inc hl   ; include zero term to copy 
22de			;	inc hl   ; include term 
22de			;	inc hl   ; include term 
22de			;	ld b,0 
22de			;	ld c,l 
22de			;	pop hl 
22de			;	ld de, execscratch 
22de			;		if DEBUG_FORTH_WORDS 
22de			;			DMARK "EX3" 
22de			;			CALLMONITOR 
22de			;		endif 
22de			;	ldir 
22de			; 
22de			; 
22de			;	ld hl, execscratch 
22de			; 
22de			;		if DEBUG_FORTH_WORDS 
22de			;			DMARK "EXe" 
22de			;			CALLMONITOR 
22de			;		endif 
22de			; 
22de			;	call forthparse 
22de			;	call forthexec 
22de			;;	call forthexec_cleanup 
22de			;;	call forthparse 
22de			;;	call forthexec 
22de			; 
22de			;	STACKFRAMECHK OFF $5efe $5f9f 
22de			; 
22de			;	; an immediate word so no need to process any more words 
22de			;	ret 
22de			;	NEXTW 
22de			 
22de			; dead code - old version  
22de			;	FORTH_RSP_NEXT 
22de			 
22de			;  
22de			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
22de			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
22de			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
22de			;	push hl 
22de			;	push de 
22de			;	push bc 
22de			; 
22de			; 
22de			;		if DEBUG_FORTH_WORDS_KEY 
22de			;			DMARK "EXR" 
22de			;			CALLMONITOR 
22de			;		endif 
22de			; 
22de			; 
22de			; 
22de			;	;v5 FORTH_DSP_VALUE 
22de			;	FORTH_DSP_VALUEHL 
22de			; 
22de			;	; TODO do string type checks 
22de			; 
22de			;;v5	inc hl   ; skip type 
22de			; 
22de			;	push hl  ; source code  
22de			;		if DEBUG_FORTH_WORDS 
22de			;			DMARK "EX1" 
22de			;			CALLMONITOR 
22de			;		endif 
22de			;	ld a, 0 
22de			;	call strlent 
22de			; 
22de			;	inc hl 
22de			;	inc hl 
22de			;	inc hl 
22de			;	inc hl 
22de			; 
22de			;	push hl    ; size 
22de			; 
22de			;		if DEBUG_FORTH_WORDS 
22de			;			DMARK "EX2" 
22de			;			CALLMONITOR 
22de			;		endif 
22de			;	call malloc 
22de			; 
22de			;	ex de, hl    ; de now contains malloc area 
22de			;	pop bc   	; get byte count 
22de			;	pop hl      ; get string to copy 
22de			; 
22de			;	push de     ; save malloc for free later 
22de			; 
22de			;		if DEBUG_FORTH_WORDS 
22de			;			DMARK "EX3" 
22de			;			CALLMONITOR 
22de			;		endif 
22de			;	ldir       ; duplicate string 
22de			; 
22de			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
22de			;	 
22de			;	; TODO fix the parse would be better than this...  
22de			;	ex de, hl 
22de			;	dec hl 
22de			;	ld a, 0 
22de			;	ld (hl), a 
22de			;	dec hl 
22de			;	ld a, ' ' 
22de			;	ld (hl), a 
22de			;	dec hl 
22de			;	ld (hl), a 
22de			; 
22de			;	dec hl 
22de			;	ld (hl), a 
22de			; 
22de			; 
22de			;	FORTH_DSP_POP  
22de			; 
22de			;	pop hl     
22de			;	push hl    ; save malloc area 
22de			; 
22de			;		if DEBUG_FORTH_WORDS 
22de			;			DMARK "EX4" 
22de			;			CALLMONITOR 
22de			;		endif 
22de			; 
22de			;	call forthparse 
22de			;	call forthexec 
22de			;	 
22de			;	pop hl 
22de			;	if DEBUG_FORTH_WORDS 
22de			;		DMARK "EX5" 
22de			;		CALLMONITOR 
22de			;	endif 
22de			; 
22de			;	if FORTH_ENABLE_FREE 
22de			;	call free 
22de			;	endif 
22de			; 
22de			;	if DEBUG_FORTH_WORDS 
22de			;		DMARK "EX6" 
22de			;		CALLMONITOR 
22de			;	endif 
22de			; 
22de			;	pop bc 
22de			;	pop de 
22de			;	pop hl 
22de			;;	FORTH_RSP_POP	  
22de			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
22de			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
22de			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
22de			; 
22de			;	if DEBUG_FORTH_WORDS 
22de			;		DMARK "EX7" 
22de			;		CALLMONITOR 
22de			;	endif 
22de			;	NEXTW 
22de			 
22de			;.STKEXEC: 
22de			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
22de			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
22de			; 
22de			; 
22de			;		if DEBUG_FORTH_WORDS_KEY 
22de			;			DMARK "STX" 
22de			;			CALLMONITOR 
22de			;		endif 
22de			; 
22de			;	FORTH_DSP_VALUEHL 
22de			; 
22de			;	ld (store_tmp1), hl    ; count 
22de			; 
22de			;	FORTH_DSP_POP 
22de			;.stkexec1: 
22de			;	ld hl, (store_tmp1)   ; count 
22de			;	ld a, 0 
22de			;	cp l 
22de			;	ret z 
22de			; 
22de			;	dec hl 
22de			;	ld (store_tmp1), hl    ; count 
22de			;	 
22de			;	FORTH_DSP_VALUEHL 
22de			;	push hl 
22de			;	 
22de			;		if DEBUG_FORTH_WORDS 
22de			;			DMARK "EXp" 
22de			;			CALLMONITOR 
22de			;		endif 
22de			;	FORTH_DSP_POP 
22de			; 
22de			;	call strlenz 
22de			;	inc hl   ; include zero term to copy 
22de			;	inc hl   ; include zero term to copy 
22de			;	inc hl   ; include zero term to copy 
22de			;	ld b,0 
22de			;	ld c,l 
22de			;	pop hl 
22de			;	ld de, execscratch 
22de			;		if DEBUG_FORTH_WORDS 
22de			;			DMARK "EX3" 
22de			;			CALLMONITOR 
22de			;		endif 
22de			;	ldir 
22de			; 
22de			; 
22de			;	ld hl, execscratch 
22de			; 
22de			;		if DEBUG_FORTH_WORDS 
22de			;			DMARK "EXP" 
22de			;			CALLMONITOR 
22de			;		endif 
22de			; 
22de			;	call forthparse 
22de			;	ld hl, execscratch 
22de			;		if DEBUG_FORTH_WORDS 
22de			;			DMARK "EXx" 
22de			;			CALLMONITOR 
22de			;		endif 
22de			;	call forthexec 
22de			; 
22de			;	jp .stkexec1 
22de			; 
22de			;	ret 
22de			 
22de			 
22de			.DUP: 
22de				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
22de 17				db WORD_SYS_CORE+OPCODE_DUP             
22df 54 23			dw .ZDUP            
22e1 04				db 3 + 1 
22e2 .. 00			db "DUP",0              
22e6				endm 
# End of macro CWHEAD
22e6			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
22e6			 
22e6					if DEBUG_FORTH_WORDS_KEY 
22e6						DMARK "DUP" 
22e6 f5				push af  
22e7 3a fb 22			ld a, (.dmark)  
22ea 32 b4 fe			ld (debug_mark),a  
22ed 3a fc 22			ld a, (.dmark+1)  
22f0 32 b5 fe			ld (debug_mark+1),a  
22f3 3a fd 22			ld a, (.dmark+2)  
22f6 32 b6 fe			ld (debug_mark+2),a  
22f9 18 03			jr .pastdmark  
22fb ..			.dmark: db "DUP"  
22fe f1			.pastdmark: pop af  
22ff			endm  
# End of macro DMARK
22ff						CALLMONITOR 
22ff cd 70 17			call break_point_state  
2302				endm  
# End of macro CALLMONITOR
2302					endif 
2302			 
2302					FORTH_DSP 
2302 cd 9b 1f			call macro_forth_dsp 
2305				endm 
# End of macro FORTH_DSP
2305			 
2305 7e					ld a, (HL) 
2306 fe 01				cp DS_TYPE_STR 
2308 20 25				jr nz, .dupinum 
230a			 
230a					; push another string 
230a			 
230a					FORTH_DSP_VALUEHL     		 
230a cd d5 1f			call macro_dsp_valuehl 
230d				endm 
# End of macro FORTH_DSP_VALUEHL
230d			 
230d				if DEBUG_FORTH_WORDS 
230d					DMARK "DUs" 
230d f5				push af  
230e 3a 22 23			ld a, (.dmark)  
2311 32 b4 fe			ld (debug_mark),a  
2314 3a 23 23			ld a, (.dmark+1)  
2317 32 b5 fe			ld (debug_mark+1),a  
231a 3a 24 23			ld a, (.dmark+2)  
231d 32 b6 fe			ld (debug_mark+2),a  
2320 18 03			jr .pastdmark  
2322 ..			.dmark: db "DUs"  
2325 f1			.pastdmark: pop af  
2326			endm  
# End of macro DMARK
2326					CALLMONITOR 
2326 cd 70 17			call break_point_state  
2329				endm  
# End of macro CALLMONITOR
2329				endif 
2329 cd 4c 1e				call forth_push_str 
232c			 
232c					NEXTW 
232c c3 47 21			jp macro_next 
232f				endm 
# End of macro NEXTW
232f			 
232f			 
232f			.dupinum: 
232f					 
232f			 
232f			 
232f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
232f cd d5 1f			call macro_dsp_valuehl 
2332				endm 
# End of macro FORTH_DSP_VALUEHL
2332			 
2332				; TODO add floating point number detection 
2332			 
2332				if DEBUG_FORTH_WORDS 
2332					DMARK "DUi" 
2332 f5				push af  
2333 3a 47 23			ld a, (.dmark)  
2336 32 b4 fe			ld (debug_mark),a  
2339 3a 48 23			ld a, (.dmark+1)  
233c 32 b5 fe			ld (debug_mark+1),a  
233f 3a 49 23			ld a, (.dmark+2)  
2342 32 b6 fe			ld (debug_mark+2),a  
2345 18 03			jr .pastdmark  
2347 ..			.dmark: db "DUi"  
234a f1			.pastdmark: pop af  
234b			endm  
# End of macro DMARK
234b					CALLMONITOR 
234b cd 70 17			call break_point_state  
234e				endm  
# End of macro CALLMONITOR
234e				endif 
234e			 
234e cd de 1d				call forth_push_numhl 
2351					NEXTW 
2351 c3 47 21			jp macro_next 
2354				endm 
# End of macro NEXTW
2354			.ZDUP: 
2354				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2354 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2355 8c 23			dw .SWAP            
2357 05				db 4 + 1 
2358 .. 00			db "?DUP",0              
235d				endm 
# End of macro CWHEAD
235d			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
235d			 
235d					if DEBUG_FORTH_WORDS_KEY 
235d						DMARK "qDU" 
235d f5				push af  
235e 3a 72 23			ld a, (.dmark)  
2361 32 b4 fe			ld (debug_mark),a  
2364 3a 73 23			ld a, (.dmark+1)  
2367 32 b5 fe			ld (debug_mark+1),a  
236a 3a 74 23			ld a, (.dmark+2)  
236d 32 b6 fe			ld (debug_mark+2),a  
2370 18 03			jr .pastdmark  
2372 ..			.dmark: db "qDU"  
2375 f1			.pastdmark: pop af  
2376			endm  
# End of macro DMARK
2376						CALLMONITOR 
2376 cd 70 17			call break_point_state  
2379				endm  
# End of macro CALLMONITOR
2379					endif 
2379					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2379 cd d5 1f			call macro_dsp_valuehl 
237c				endm 
# End of macro FORTH_DSP_VALUEHL
237c			 
237c e5					push hl 
237d			 
237d					; is it a zero? 
237d			 
237d 3e 00				ld a, 0 
237f 84					add h 
2380 85					add l 
2381			 
2381 e1					pop hl 
2382			 
2382 fe 00				cp 0 
2384 28 03				jr z, .dup2orig 
2386			 
2386			 
2386 cd de 1d				call forth_push_numhl 
2389			 
2389			 
2389				; TODO add floating point number detection 
2389			 
2389			.dup2orig: 
2389			 
2389					NEXTW 
2389 c3 47 21			jp macro_next 
238c				endm 
# End of macro NEXTW
238c			.SWAP: 
238c				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
238c 18				db WORD_SYS_CORE+OPCODE_SWAP             
238d cb 23			dw .COLN            
238f 05				db 4 + 1 
2390 .. 00			db "SWAP",0              
2395				endm 
# End of macro CWHEAD
2395			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2395					if DEBUG_FORTH_WORDS_KEY 
2395						DMARK "SWP" 
2395 f5				push af  
2396 3a aa 23			ld a, (.dmark)  
2399 32 b4 fe			ld (debug_mark),a  
239c 3a ab 23			ld a, (.dmark+1)  
239f 32 b5 fe			ld (debug_mark+1),a  
23a2 3a ac 23			ld a, (.dmark+2)  
23a5 32 b6 fe			ld (debug_mark+2),a  
23a8 18 03			jr .pastdmark  
23aa ..			.dmark: db "SWP"  
23ad f1			.pastdmark: pop af  
23ae			endm  
# End of macro DMARK
23ae						CALLMONITOR 
23ae cd 70 17			call break_point_state  
23b1				endm  
# End of macro CALLMONITOR
23b1					endif 
23b1			 
23b1					FORTH_DSP_VALUEHL 
23b1 cd d5 1f			call macro_dsp_valuehl 
23b4				endm 
# End of macro FORTH_DSP_VALUEHL
23b4 e5					push hl     ; w2 
23b5			 
23b5					FORTH_DSP_POP 
23b5 cd 8d 20			call macro_forth_dsp_pop 
23b8				endm 
# End of macro FORTH_DSP_POP
23b8			 
23b8					FORTH_DSP_VALUEHL 
23b8 cd d5 1f			call macro_dsp_valuehl 
23bb				endm 
# End of macro FORTH_DSP_VALUEHL
23bb			 
23bb					FORTH_DSP_POP 
23bb cd 8d 20			call macro_forth_dsp_pop 
23be				endm 
# End of macro FORTH_DSP_POP
23be			 
23be d1					pop de     ; w2	, hl = w1 
23bf			 
23bf eb					ex de, hl 
23c0 d5					push de 
23c1			 
23c1 cd de 1d				call forth_push_numhl 
23c4			 
23c4 e1					pop hl 
23c5			 
23c5 cd de 1d				call forth_push_numhl 
23c8					 
23c8			 
23c8					NEXTW 
23c8 c3 47 21			jp macro_next 
23cb				endm 
# End of macro NEXTW
23cb			.COLN: 
23cb				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
23cb 19				db WORD_SYS_CORE+OPCODE_COLN             
23cc 57 25			dw .SCOLN            
23ce 02				db 1 + 1 
23cf .. 00			db ":",0              
23d1				endm 
# End of macro CWHEAD
23d1			; | : ( -- )         Create new word | DONE 
23d1			 
23d1					if DEBUG_FORTH_WORDS_KEY 
23d1						DMARK "CLN" 
23d1 f5				push af  
23d2 3a e6 23			ld a, (.dmark)  
23d5 32 b4 fe			ld (debug_mark),a  
23d8 3a e7 23			ld a, (.dmark+1)  
23db 32 b5 fe			ld (debug_mark+1),a  
23de 3a e8 23			ld a, (.dmark+2)  
23e1 32 b6 fe			ld (debug_mark+2),a  
23e4 18 03			jr .pastdmark  
23e6 ..			.dmark: db "CLN"  
23e9 f1			.pastdmark: pop af  
23ea			endm  
# End of macro DMARK
23ea						CALLMONITOR 
23ea cd 70 17			call break_point_state  
23ed				endm  
# End of macro CALLMONITOR
23ed					endif 
23ed				STACKFRAME OFF $8efe $989f 
23ed				if DEBUG_STACK_IMB 
23ed					if OFF 
23ed						exx 
23ed						ld de, $8efe 
23ed						ld a, d 
23ed						ld hl, curframe 
23ed						call hexout 
23ed						ld a, e 
23ed						ld hl, curframe+2 
23ed						call hexout 
23ed						ld hl, $8efe 
23ed						push hl 
23ed						ld hl, $989f 
23ed						push hl 
23ed						exx 
23ed					endif 
23ed				endif 
23ed			endm 
# End of macro STACKFRAME
23ed				; get parser buffer length  of new word 
23ed			 
23ed				 
23ed			 
23ed					; move tok past this to start of name defintition 
23ed					; TODO get word to define 
23ed					; TODO Move past word token 
23ed					; TODO get length of string up to the ';' 
23ed			 
23ed 2a 5b f7			ld hl, (os_tok_ptr) 
23f0 23				inc hl 
23f1 23				inc hl 
23f2			 
23f2 3e 3b			ld a, ';' 
23f4 cd 5c 12			call strlent 
23f7			 
23f7 7d				ld a,l 
23f8 32 56 f4			ld (os_new_parse_len), a 
23fb			 
23fb			 
23fb			if DEBUG_FORTH_UWORD 
23fb ed 5b 5b f7		ld de, (os_tok_ptr) 
23ff						DMARK ":01" 
23ff f5				push af  
2400 3a 14 24			ld a, (.dmark)  
2403 32 b4 fe			ld (debug_mark),a  
2406 3a 15 24			ld a, (.dmark+1)  
2409 32 b5 fe			ld (debug_mark+1),a  
240c 3a 16 24			ld a, (.dmark+2)  
240f 32 b6 fe			ld (debug_mark+2),a  
2412 18 03			jr .pastdmark  
2414 ..			.dmark: db ":01"  
2417 f1			.pastdmark: pop af  
2418			endm  
# End of macro DMARK
2418				CALLMONITOR 
2418 cd 70 17			call break_point_state  
241b				endm  
# End of macro CALLMONITOR
241b			endif 
241b			 
241b			; 
241b			;  new word memory layout: 
241b			;  
241b			;    : adg 6666 ;  
241b			; 
241b			;    db   1     ; user defined word  
241b 23				inc hl    
241c			;    dw   sysdict 
241c 23				inc hl 
241d 23				inc hl 
241e			;    db <word len>+1 (for null) 
241e 23				inc hl 
241f			;    db .... <word> 
241f			; 
241f			 
241f 23				inc hl    ; some extras for the word preamble before the above 
2420 23				inc hl 
2421 23				inc hl 
2422 23				inc hl 
2423 23				inc hl 
2424 23				inc hl 
2425 23				inc hl  
2426 23				inc hl 
2427 23				inc hl 
2428 23				inc hl 
2429 23				inc hl 
242a 23				inc hl 
242b 23				inc hl 
242c 23				inc hl     ; TODO how many do we really need?     maybe only 6 
242d			;       exec word buffer 
242d			;	<ptr word>   
242d 23				inc hl 
242e 23				inc hl 
242f			;       <word list><null term> 7F final term 
242f			 
242f			 
242f			if DEBUG_FORTH_UWORD 
242f						DMARK ":02" 
242f f5				push af  
2430 3a 44 24			ld a, (.dmark)  
2433 32 b4 fe			ld (debug_mark),a  
2436 3a 45 24			ld a, (.dmark+1)  
2439 32 b5 fe			ld (debug_mark+1),a  
243c 3a 46 24			ld a, (.dmark+2)  
243f 32 b6 fe			ld (debug_mark+2),a  
2442 18 03			jr .pastdmark  
2444 ..			.dmark: db ":02"  
2447 f1			.pastdmark: pop af  
2448			endm  
# End of macro DMARK
2448				CALLMONITOR 
2448 cd 70 17			call break_point_state  
244b				endm  
# End of macro CALLMONITOR
244b			endif 
244b			 
244b				 
244b					; malloc the size 
244b			 
244b cd ba 12				call malloc 
244e 22 58 f4				ld (os_new_malloc), hl     ; save malloc start 
2451			 
2451			;    db   1     ; user defined word  
2451 3e 01				ld a, WORD_SYS_UWORD  
2453 77					ld (hl), a 
2454				 
2454 23				inc hl    
2455			;    dw   sysdict 
2455 11 9f 22			ld de, sysdict       ; continue on with the scan to the system dict 
2458 73				ld (hl), e 
2459 23				inc hl 
245a 72				ld (hl), d 
245b 23				inc hl 
245c			 
245c			 
245c			;    Setup dict word 
245c			 
245c 23				inc hl 
245d 22 52 f4			ld (os_new_work_ptr), hl     ; save start of dict word  
2460			 
2460				; 1. get length of dict word 
2460			 
2460			 
2460 2a 5b f7			ld hl, (os_tok_ptr) 
2463 23				inc hl 
2464 23				inc hl    ; position to start of dict word 
2465 3e 00			ld a, 0 
2467 cd 5c 12			call strlent 
246a			 
246a			 
246a 23				inc hl    ; to include null??? 
246b			 
246b				; write length of dict word 
246b			 
246b ed 5b 52 f4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
246f 1b				dec de 
2470 eb				ex de, hl 
2471 73				ld (hl), e 
2472 eb				ex de, hl 
2473			 
2473				 
2473			 
2473				; copy  
2473 4d				ld c, l 
2474 06 00			ld b, 0 
2476 ed 5b 52 f4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
247a 2a 5b f7			ld hl, (os_tok_ptr) 
247d 23				inc hl 
247e 23				inc hl    ; position to start of dict word 
247f				 
247f			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
247f				 
247f				; TODO need to convert word to upper case 
247f			 
247f			ucasetok:	 
247f 7e				ld a,(hl) 
2480 cd 48 12			call toUpper 
2483 77				ld (hl),a 
2484 ed a0			ldi 
2486 f2 7f 24		 	jp p, ucasetok 
2489			 
2489			 
2489			 
2489				; de now points to start of where the word body code should be placed 
2489 ed 53 52 f4		ld (os_new_work_ptr), de 
248d				; hl now points to the words to throw at forthexec which needs to be copied 
248d 22 50 f4			ld (os_new_src_ptr), hl 
2490			 
2490				; TODO add 'call to forthexec' 
2490			 
2490			if DEBUG_FORTH_UWORD 
2490 c5				push bc 
2491 ed 4b 58 f4		ld bc, (os_new_malloc) 
2495						DMARK ":0x" 
2495 f5				push af  
2496 3a aa 24			ld a, (.dmark)  
2499 32 b4 fe			ld (debug_mark),a  
249c 3a ab 24			ld a, (.dmark+1)  
249f 32 b5 fe			ld (debug_mark+1),a  
24a2 3a ac 24			ld a, (.dmark+2)  
24a5 32 b6 fe			ld (debug_mark+2),a  
24a8 18 03			jr .pastdmark  
24aa ..			.dmark: db ":0x"  
24ad f1			.pastdmark: pop af  
24ae			endm  
# End of macro DMARK
24ae				CALLMONITOR 
24ae cd 70 17			call break_point_state  
24b1				endm  
# End of macro CALLMONITOR
24b1 c1				pop bc 
24b2			endif 
24b2			 
24b2			 
24b2				; create word preamble which should be: 
24b2			 
24b2			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
24b2			 
24b2				;    ld hl, <word code> 
24b2				;    jp user_exec 
24b2			        ;    <word code bytes> 
24b2			 
24b2			 
24b2			;	inc de     ; TODO ??? or are we already past the word's null 
24b2 eb				ex de, hl 
24b3			 
24b3 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
24b5			 
24b5 23				inc hl 
24b6 22 4c f4			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
24b9 23				inc hl 
24ba			 
24ba 23				inc hl 
24bb 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
24bd			 
24bd 01 cb 52			ld bc, user_exec 
24c0 23				inc hl 
24c1 71				ld (hl), c     ; poke address of user_exec 
24c2 23				inc hl 
24c3 70				ld (hl), b     
24c4			 ; 
24c4			;	inc hl 
24c4			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
24c4			; 
24c4			; 
24c4			;	ld bc, macro_forth_rsp_next 
24c4			;	inc hl 
24c4			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
24c4			;	inc hl 
24c4			;	ld (hl), b     
24c4			 ; 
24c4			;	inc hl 
24c4			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
24c4			; 
24c4			; 
24c4			;	inc hl 
24c4			;	ld bc, forthexec 
24c4			;	ld (hl), c     ; poke address of forthexec 
24c4			;	inc hl 
24c4			;	ld (hl), b      
24c4			; 
24c4			;	inc hl 
24c4			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
24c4			; 
24c4			;	ld bc, user_dict_next 
24c4			;	inc hl 
24c4			;	ld (hl), c     ; poke address of forthexec 
24c4			;	inc hl 
24c4			;	ld (hl), b      
24c4			 
24c4				; hl is now where we need to copy the word byte data to save this 
24c4			 
24c4 23				inc hl 
24c5 22 4e f4			ld (os_new_exec), hl 
24c8				 
24c8				; copy definition 
24c8			 
24c8 eb				ex de, hl 
24c9			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
24c9			;	inc de    ; skip the PC for this parse 
24c9 3a 56 f4			ld a, (os_new_parse_len) 
24cc 4f				ld c, a 
24cd 06 00			ld b, 0 
24cf ed b0			ldir		 ; copy defintion 
24d1			 
24d1			 
24d1				; poke the address of where the new word bytes live for forthexec 
24d1			 
24d1 2a 4c f4			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
24d4			 
24d4 ed 5b 4e f4		ld de, (os_new_exec)      
24d8				 
24d8 73				ld (hl), e 
24d9 23				inc hl 
24da 72				ld (hl), d 
24db			 
24db					; TODO copy last user dict word next link to this word 
24db					; TODO update last user dict word to point to this word 
24db			; 
24db			; hl f923 de 812a ; bc 811a 
24db			 
24db			if DEBUG_FORTH_UWORD 
24db c5				push bc 
24dc ed 4b 58 f4		ld bc, (os_new_malloc) 
24e0						DMARK ":0A" 
24e0 f5				push af  
24e1 3a f5 24			ld a, (.dmark)  
24e4 32 b4 fe			ld (debug_mark),a  
24e7 3a f6 24			ld a, (.dmark+1)  
24ea 32 b5 fe			ld (debug_mark+1),a  
24ed 3a f7 24			ld a, (.dmark+2)  
24f0 32 b6 fe			ld (debug_mark+2),a  
24f3 18 03			jr .pastdmark  
24f5 ..			.dmark: db ":0A"  
24f8 f1			.pastdmark: pop af  
24f9			endm  
# End of macro DMARK
24f9				CALLMONITOR 
24f9 cd 70 17			call break_point_state  
24fc				endm  
# End of macro CALLMONITOR
24fc c1				pop bc 
24fd			endif 
24fd			if DEBUG_FORTH_UWORD 
24fd c5				push bc 
24fe ed 4b 58 f4		ld bc, (os_new_malloc) 
2502 03				inc bc 
2503 03				inc bc 
2504 03				inc bc 
2505 03				inc bc 
2506 03				inc bc 
2507 03				inc bc 
2508 03				inc bc 
2509 03				inc bc 
250a			 
250a						DMARK ":0B" 
250a f5				push af  
250b 3a 1f 25			ld a, (.dmark)  
250e 32 b4 fe			ld (debug_mark),a  
2511 3a 20 25			ld a, (.dmark+1)  
2514 32 b5 fe			ld (debug_mark+1),a  
2517 3a 21 25			ld a, (.dmark+2)  
251a 32 b6 fe			ld (debug_mark+2),a  
251d 18 03			jr .pastdmark  
251f ..			.dmark: db ":0B"  
2522 f1			.pastdmark: pop af  
2523			endm  
# End of macro DMARK
2523				CALLMONITOR 
2523 cd 70 17			call break_point_state  
2526				endm  
# End of macro CALLMONITOR
2526 c1				pop bc 
2527			endif 
2527			 
2527			; update word dict linked list for new word 
2527			 
2527			 
2527 2a 57 f7		ld hl, (os_last_new_uword)		; get the start of the last added uword 
252a 23			inc hl     ; move to next work linked list ptr 
252b			 
252b ed 5b 58 f4	ld de, (os_new_malloc)		 ; new next word 
252f 73			ld (hl), e 
2530 23			inc hl 
2531 72			ld (hl), d 
2532			 
2532			if DEBUG_FORTH_UWORD 
2532 ed 4b 57 f7		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2536			endif 
2536			 
2536 ed 53 57 f7	ld (os_last_new_uword), de      ; update last new uword ptr 
253a			 
253a			 
253a			if DEBUG_FORTH_UWORD 
253a						DMARK ":0+" 
253a f5				push af  
253b 3a 4f 25			ld a, (.dmark)  
253e 32 b4 fe			ld (debug_mark),a  
2541 3a 50 25			ld a, (.dmark+1)  
2544 32 b5 fe			ld (debug_mark+1),a  
2547 3a 51 25			ld a, (.dmark+2)  
254a 32 b6 fe			ld (debug_mark+2),a  
254d 18 03			jr .pastdmark  
254f ..			.dmark: db ":0+"  
2552 f1			.pastdmark: pop af  
2553			endm  
# End of macro DMARK
2553				CALLMONITOR 
2553 cd 70 17			call break_point_state  
2556				endm  
# End of macro CALLMONITOR
2556			endif 
2556			 
2556				STACKFRAMECHK OFF $8efe $989f 
2556				if DEBUG_STACK_IMB 
2556					if OFF 
2556						exx 
2556						ld hl, $989f 
2556						pop de   ; $989f 
2556						call cmp16 
2556						jr nz, .spnosame 
2556						ld hl, $8efe 
2556						pop de   ; $8efe 
2556						call cmp16 
2556						jr z, .spfrsame 
2556						.spnosame: call showsperror 
2556						.spfrsame: nop 
2556						exx 
2556					endif 
2556				endif 
2556			endm 
# End of macro STACKFRAMECHK
2556			 
2556 c9			ret    ; dont process any remaining parser tokens as they form new word 
2557			 
2557			 
2557			 
2557			 
2557			;		NEXT 
2557			.SCOLN: 
2557			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2557 06				db OPCODE_SCOLN 
2558 a3 25			dw .DROP 
255a 02				db 2 
255b .. 00			db ";",0           
255d			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
255d					if DEBUG_FORTH_WORDS_KEY 
255d						DMARK "SCN" 
255d f5				push af  
255e 3a 72 25			ld a, (.dmark)  
2561 32 b4 fe			ld (debug_mark),a  
2564 3a 73 25			ld a, (.dmark+1)  
2567 32 b5 fe			ld (debug_mark+1),a  
256a 3a 74 25			ld a, (.dmark+2)  
256d 32 b6 fe			ld (debug_mark+2),a  
2570 18 03			jr .pastdmark  
2572 ..			.dmark: db "SCN"  
2575 f1			.pastdmark: pop af  
2576			endm  
# End of macro DMARK
2576						CALLMONITOR 
2576 cd 70 17			call break_point_state  
2579				endm  
# End of macro CALLMONITOR
2579					endif 
2579					FORTH_RSP_TOS 
2579 cd 9c 1d			call macro_forth_rsp_tos 
257c				endm 
# End of macro FORTH_RSP_TOS
257c e5					push hl 
257d					FORTH_RSP_POP 
257d cd a6 1d			call macro_forth_rsp_pop 
2580				endm 
# End of macro FORTH_RSP_POP
2580 e1					pop hl 
2581			;		ex de,hl 
2581 22 5b f7				ld (os_tok_ptr),hl 
2584			 
2584			if DEBUG_FORTH_UWORD 
2584						DMARK "SCL" 
2584 f5				push af  
2585 3a 99 25			ld a, (.dmark)  
2588 32 b4 fe			ld (debug_mark),a  
258b 3a 9a 25			ld a, (.dmark+1)  
258e 32 b5 fe			ld (debug_mark+1),a  
2591 3a 9b 25			ld a, (.dmark+2)  
2594 32 b6 fe			ld (debug_mark+2),a  
2597 18 03			jr .pastdmark  
2599 ..			.dmark: db "SCL"  
259c f1			.pastdmark: pop af  
259d			endm  
# End of macro DMARK
259d				CALLMONITOR 
259d cd 70 17			call break_point_state  
25a0				endm  
# End of macro CALLMONITOR
25a0			endif 
25a0					NEXTW 
25a0 c3 47 21			jp macro_next 
25a3				endm 
# End of macro NEXTW
25a3			 
25a3			.DROP: 
25a3				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
25a3 1b				db WORD_SYS_CORE+OPCODE_DROP             
25a4 ce 25			dw .DUP2            
25a6 05				db 4 + 1 
25a7 .. 00			db "DROP",0              
25ac				endm 
# End of macro CWHEAD
25ac			; | DROP ( w -- )   drop the TOS item   | DONE 
25ac					if DEBUG_FORTH_WORDS_KEY 
25ac						DMARK "DRP" 
25ac f5				push af  
25ad 3a c1 25			ld a, (.dmark)  
25b0 32 b4 fe			ld (debug_mark),a  
25b3 3a c2 25			ld a, (.dmark+1)  
25b6 32 b5 fe			ld (debug_mark+1),a  
25b9 3a c3 25			ld a, (.dmark+2)  
25bc 32 b6 fe			ld (debug_mark+2),a  
25bf 18 03			jr .pastdmark  
25c1 ..			.dmark: db "DRP"  
25c4 f1			.pastdmark: pop af  
25c5			endm  
# End of macro DMARK
25c5						CALLMONITOR 
25c5 cd 70 17			call break_point_state  
25c8				endm  
# End of macro CALLMONITOR
25c8					endif 
25c8					FORTH_DSP_POP 
25c8 cd 8d 20			call macro_forth_dsp_pop 
25cb				endm 
# End of macro FORTH_DSP_POP
25cb					NEXTW 
25cb c3 47 21			jp macro_next 
25ce				endm 
# End of macro NEXTW
25ce			.DUP2: 
25ce				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
25ce 1c				db WORD_SYS_CORE+OPCODE_DUP2             
25cf 13 26			dw .DROP2            
25d1 05				db 4 + 1 
25d2 .. 00			db "2DUP",0              
25d7				endm 
# End of macro CWHEAD
25d7			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
25d7					if DEBUG_FORTH_WORDS_KEY 
25d7						DMARK "2DU" 
25d7 f5				push af  
25d8 3a ec 25			ld a, (.dmark)  
25db 32 b4 fe			ld (debug_mark),a  
25de 3a ed 25			ld a, (.dmark+1)  
25e1 32 b5 fe			ld (debug_mark+1),a  
25e4 3a ee 25			ld a, (.dmark+2)  
25e7 32 b6 fe			ld (debug_mark+2),a  
25ea 18 03			jr .pastdmark  
25ec ..			.dmark: db "2DU"  
25ef f1			.pastdmark: pop af  
25f0			endm  
# End of macro DMARK
25f0						CALLMONITOR 
25f0 cd 70 17			call break_point_state  
25f3				endm  
# End of macro CALLMONITOR
25f3					endif 
25f3					FORTH_DSP_VALUEHL 
25f3 cd d5 1f			call macro_dsp_valuehl 
25f6				endm 
# End of macro FORTH_DSP_VALUEHL
25f6 e5					push hl      ; 2 
25f7			 
25f7					FORTH_DSP_POP 
25f7 cd 8d 20			call macro_forth_dsp_pop 
25fa				endm 
# End of macro FORTH_DSP_POP
25fa					 
25fa					FORTH_DSP_VALUEHL 
25fa cd d5 1f			call macro_dsp_valuehl 
25fd				endm 
# End of macro FORTH_DSP_VALUEHL
25fd			;		push hl      ; 1 
25fd			 
25fd					FORTH_DSP_POP 
25fd cd 8d 20			call macro_forth_dsp_pop 
2600				endm 
# End of macro FORTH_DSP_POP
2600			 
2600			;		pop hl       ; 1 
2600 d1					pop de       ; 2 
2601			 
2601 cd de 1d				call forth_push_numhl 
2604 eb					ex de, hl 
2605 cd de 1d				call forth_push_numhl 
2608			 
2608					 
2608 eb					ex de, hl 
2609			 
2609 cd de 1d				call forth_push_numhl 
260c eb					ex de, hl 
260d cd de 1d				call forth_push_numhl 
2610			 
2610			 
2610					NEXTW 
2610 c3 47 21			jp macro_next 
2613				endm 
# End of macro NEXTW
2613			.DROP2: 
2613				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2613 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2614 42 26			dw .SWAP2            
2616 06				db 5 + 1 
2617 .. 00			db "2DROP",0              
261d				endm 
# End of macro CWHEAD
261d			; | 2DROP ( w w -- )    Double drop | DONE 
261d					if DEBUG_FORTH_WORDS_KEY 
261d						DMARK "2DR" 
261d f5				push af  
261e 3a 32 26			ld a, (.dmark)  
2621 32 b4 fe			ld (debug_mark),a  
2624 3a 33 26			ld a, (.dmark+1)  
2627 32 b5 fe			ld (debug_mark+1),a  
262a 3a 34 26			ld a, (.dmark+2)  
262d 32 b6 fe			ld (debug_mark+2),a  
2630 18 03			jr .pastdmark  
2632 ..			.dmark: db "2DR"  
2635 f1			.pastdmark: pop af  
2636			endm  
# End of macro DMARK
2636						CALLMONITOR 
2636 cd 70 17			call break_point_state  
2639				endm  
# End of macro CALLMONITOR
2639					endif 
2639					FORTH_DSP_POP 
2639 cd 8d 20			call macro_forth_dsp_pop 
263c				endm 
# End of macro FORTH_DSP_POP
263c					FORTH_DSP_POP 
263c cd 8d 20			call macro_forth_dsp_pop 
263f				endm 
# End of macro FORTH_DSP_POP
263f					NEXTW 
263f c3 47 21			jp macro_next 
2642				endm 
# End of macro NEXTW
2642			.SWAP2: 
2642				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2642 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2643 6b 26			dw .AT            
2645 06				db 5 + 1 
2646 .. 00			db "2SWAP",0              
264c				endm 
# End of macro CWHEAD
264c			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
264c					if DEBUG_FORTH_WORDS_KEY 
264c						DMARK "2SW" 
264c f5				push af  
264d 3a 61 26			ld a, (.dmark)  
2650 32 b4 fe			ld (debug_mark),a  
2653 3a 62 26			ld a, (.dmark+1)  
2656 32 b5 fe			ld (debug_mark+1),a  
2659 3a 63 26			ld a, (.dmark+2)  
265c 32 b6 fe			ld (debug_mark+2),a  
265f 18 03			jr .pastdmark  
2661 ..			.dmark: db "2SW"  
2664 f1			.pastdmark: pop af  
2665			endm  
# End of macro DMARK
2665						CALLMONITOR 
2665 cd 70 17			call break_point_state  
2668				endm  
# End of macro CALLMONITOR
2668					endif 
2668					NEXTW 
2668 c3 47 21			jp macro_next 
266b				endm 
# End of macro NEXTW
266b			.AT: 
266b				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
266b 1f				db WORD_SYS_CORE+OPCODE_AT             
266c 9d 26			dw .CAT            
266e 02				db 1 + 1 
266f .. 00			db "@",0              
2671				endm 
# End of macro CWHEAD
2671			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2671			 
2671					if DEBUG_FORTH_WORDS_KEY 
2671						DMARK "AT." 
2671 f5				push af  
2672 3a 86 26			ld a, (.dmark)  
2675 32 b4 fe			ld (debug_mark),a  
2678 3a 87 26			ld a, (.dmark+1)  
267b 32 b5 fe			ld (debug_mark+1),a  
267e 3a 88 26			ld a, (.dmark+2)  
2681 32 b6 fe			ld (debug_mark+2),a  
2684 18 03			jr .pastdmark  
2686 ..			.dmark: db "AT."  
2689 f1			.pastdmark: pop af  
268a			endm  
# End of macro DMARK
268a						CALLMONITOR 
268a cd 70 17			call break_point_state  
268d				endm  
# End of macro CALLMONITOR
268d					endif 
268d			.getbyteat:	 
268d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
268d cd d5 1f			call macro_dsp_valuehl 
2690				endm 
# End of macro FORTH_DSP_VALUEHL
2690					 
2690			;		push hl 
2690				 
2690					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2690 cd 8d 20			call macro_forth_dsp_pop 
2693				endm 
# End of macro FORTH_DSP_POP
2693			 
2693			;		pop hl 
2693			 
2693 7e					ld a, (hl) 
2694			 
2694 6f					ld l, a 
2695 26 00				ld h, 0 
2697 cd de 1d				call forth_push_numhl 
269a			 
269a					NEXTW 
269a c3 47 21			jp macro_next 
269d				endm 
# End of macro NEXTW
269d			.CAT: 
269d				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
269d 20				db WORD_SYS_CORE+OPCODE_CAT             
269e c6 26			dw .BANG            
26a0 03				db 2 + 1 
26a1 .. 00			db "C@",0              
26a4				endm 
# End of macro CWHEAD
26a4			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
26a4					if DEBUG_FORTH_WORDS_KEY 
26a4						DMARK "CAA" 
26a4 f5				push af  
26a5 3a b9 26			ld a, (.dmark)  
26a8 32 b4 fe			ld (debug_mark),a  
26ab 3a ba 26			ld a, (.dmark+1)  
26ae 32 b5 fe			ld (debug_mark+1),a  
26b1 3a bb 26			ld a, (.dmark+2)  
26b4 32 b6 fe			ld (debug_mark+2),a  
26b7 18 03			jr .pastdmark  
26b9 ..			.dmark: db "CAA"  
26bc f1			.pastdmark: pop af  
26bd			endm  
# End of macro DMARK
26bd						CALLMONITOR 
26bd cd 70 17			call break_point_state  
26c0				endm  
# End of macro CALLMONITOR
26c0					endif 
26c0 c3 8d 26				jp .getbyteat 
26c3					NEXTW 
26c3 c3 47 21			jp macro_next 
26c6				endm 
# End of macro NEXTW
26c6			.BANG: 
26c6				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
26c6 21				db WORD_SYS_CORE+OPCODE_BANG             
26c7 fc 26			dw .CBANG            
26c9 02				db 1 + 1 
26ca .. 00			db "!",0              
26cc				endm 
# End of macro CWHEAD
26cc			; | ! ( x w -- ) Store x at address w      | DONE 
26cc					if DEBUG_FORTH_WORDS_KEY 
26cc						DMARK "BNG" 
26cc f5				push af  
26cd 3a e1 26			ld a, (.dmark)  
26d0 32 b4 fe			ld (debug_mark),a  
26d3 3a e2 26			ld a, (.dmark+1)  
26d6 32 b5 fe			ld (debug_mark+1),a  
26d9 3a e3 26			ld a, (.dmark+2)  
26dc 32 b6 fe			ld (debug_mark+2),a  
26df 18 03			jr .pastdmark  
26e1 ..			.dmark: db "BNG"  
26e4 f1			.pastdmark: pop af  
26e5			endm  
# End of macro DMARK
26e5						CALLMONITOR 
26e5 cd 70 17			call break_point_state  
26e8				endm  
# End of macro CALLMONITOR
26e8					endif 
26e8			 
26e8			.storebyteat:		 
26e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26e8 cd d5 1f			call macro_dsp_valuehl 
26eb				endm 
# End of macro FORTH_DSP_VALUEHL
26eb					 
26eb e5					push hl 
26ec				 
26ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26ec cd 8d 20			call macro_forth_dsp_pop 
26ef				endm 
# End of macro FORTH_DSP_POP
26ef			 
26ef					; get byte to poke 
26ef			 
26ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26ef cd d5 1f			call macro_dsp_valuehl 
26f2				endm 
# End of macro FORTH_DSP_VALUEHL
26f2 e5					push hl 
26f3			 
26f3			 
26f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26f3 cd 8d 20			call macro_forth_dsp_pop 
26f6				endm 
# End of macro FORTH_DSP_POP
26f6			 
26f6			 
26f6 d1					pop de 
26f7 e1					pop hl 
26f8			 
26f8 73					ld (hl),e 
26f9			 
26f9			 
26f9					NEXTW 
26f9 c3 47 21			jp macro_next 
26fc				endm 
# End of macro NEXTW
26fc			.CBANG: 
26fc				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
26fc 22				db WORD_SYS_CORE+OPCODE_CBANG             
26fd 25 27			dw .SCALL            
26ff 03				db 2 + 1 
2700 .. 00			db "C!",0              
2703				endm 
# End of macro CWHEAD
2703			; | C!  ( x w -- ) Store x at address w  | DONE 
2703					if DEBUG_FORTH_WORDS_KEY 
2703						DMARK "CBA" 
2703 f5				push af  
2704 3a 18 27			ld a, (.dmark)  
2707 32 b4 fe			ld (debug_mark),a  
270a 3a 19 27			ld a, (.dmark+1)  
270d 32 b5 fe			ld (debug_mark+1),a  
2710 3a 1a 27			ld a, (.dmark+2)  
2713 32 b6 fe			ld (debug_mark+2),a  
2716 18 03			jr .pastdmark  
2718 ..			.dmark: db "CBA"  
271b f1			.pastdmark: pop af  
271c			endm  
# End of macro DMARK
271c						CALLMONITOR 
271c cd 70 17			call break_point_state  
271f				endm  
# End of macro CALLMONITOR
271f					endif 
271f c3 e8 26				jp .storebyteat 
2722					NEXTW 
2722 c3 47 21			jp macro_next 
2725				endm 
# End of macro NEXTW
2725			.SCALL: 
2725				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2725 23				db WORD_SYS_CORE+OPCODE_SCALL             
2726 59 27			dw .DEPTH            
2728 05				db 4 + 1 
2729 .. 00			db "CALL",0              
272e				endm 
# End of macro CWHEAD
272e			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
272e					if DEBUG_FORTH_WORDS_KEY 
272e						DMARK "CLL" 
272e f5				push af  
272f 3a 43 27			ld a, (.dmark)  
2732 32 b4 fe			ld (debug_mark),a  
2735 3a 44 27			ld a, (.dmark+1)  
2738 32 b5 fe			ld (debug_mark+1),a  
273b 3a 45 27			ld a, (.dmark+2)  
273e 32 b6 fe			ld (debug_mark+2),a  
2741 18 03			jr .pastdmark  
2743 ..			.dmark: db "CLL"  
2746 f1			.pastdmark: pop af  
2747			endm  
# End of macro DMARK
2747						CALLMONITOR 
2747 cd 70 17			call break_point_state  
274a				endm  
# End of macro CALLMONITOR
274a					endif 
274a			 
274a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
274a cd d5 1f			call macro_dsp_valuehl 
274d				endm 
# End of macro FORTH_DSP_VALUEHL
274d			 
274d			;		push hl 
274d			 
274d					; destroy value TOS 
274d			 
274d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
274d cd 8d 20			call macro_forth_dsp_pop 
2750				endm 
# End of macro FORTH_DSP_POP
2750			 
2750						 
2750			;		pop hl 
2750			 
2750					; how to do a call with hl???? save SP? 
2750 cd f0 20				call forth_call_hl 
2753			 
2753			 
2753					; TODO push value back onto stack for another op etc 
2753			 
2753 cd de 1d				call forth_push_numhl 
2756					NEXTW 
2756 c3 47 21			jp macro_next 
2759				endm 
# End of macro NEXTW
2759			.DEPTH: 
2759				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2759 24				db WORD_SYS_CORE+OPCODE_DEPTH             
275a 96 27			dw .OVER            
275c 06				db 5 + 1 
275d .. 00			db "DEPTH",0              
2763				endm 
# End of macro CWHEAD
2763			; | DEPTH ( -- u ) Push count of stack | DONE 
2763					; take current TOS and remove from base value div by two to get count 
2763					if DEBUG_FORTH_WORDS_KEY 
2763						DMARK "DEP" 
2763 f5				push af  
2764 3a 78 27			ld a, (.dmark)  
2767 32 b4 fe			ld (debug_mark),a  
276a 3a 79 27			ld a, (.dmark+1)  
276d 32 b5 fe			ld (debug_mark+1),a  
2770 3a 7a 27			ld a, (.dmark+2)  
2773 32 b6 fe			ld (debug_mark+2),a  
2776 18 03			jr .pastdmark  
2778 ..			.dmark: db "DEP"  
277b f1			.pastdmark: pop af  
277c			endm  
# End of macro DMARK
277c						CALLMONITOR 
277c cd 70 17			call break_point_state  
277f				endm  
# End of macro CALLMONITOR
277f					endif 
277f			 
277f			 
277f 2a 87 fc			ld hl, (cli_data_sp) 
2782 11 c1 f9			ld de, cli_data_stack 
2785 ed 52			sbc hl,de 
2787				 
2787				; div by size of stack item 
2787			 
2787 5d				ld e,l 
2788 0e 03			ld c, 3 
278a cd 83 0d			call Div8 
278d			 
278d 6f				ld l,a 
278e 26 00			ld h,0 
2790			 
2790				;srl h 
2790				;rr l 
2790			 
2790 cd de 1d				call forth_push_numhl 
2793					NEXTW 
2793 c3 47 21			jp macro_next 
2796				endm 
# End of macro NEXTW
2796			.OVER: 
2796				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2796 42				db WORD_SYS_CORE+46             
2797 dd 27			dw .PAUSE            
2799 05				db 4 + 1 
279a .. 00			db "OVER",0              
279f				endm 
# End of macro CWHEAD
279f			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
279f					if DEBUG_FORTH_WORDS_KEY 
279f						DMARK "OVR" 
279f f5				push af  
27a0 3a b4 27			ld a, (.dmark)  
27a3 32 b4 fe			ld (debug_mark),a  
27a6 3a b5 27			ld a, (.dmark+1)  
27a9 32 b5 fe			ld (debug_mark+1),a  
27ac 3a b6 27			ld a, (.dmark+2)  
27af 32 b6 fe			ld (debug_mark+2),a  
27b2 18 03			jr .pastdmark  
27b4 ..			.dmark: db "OVR"  
27b7 f1			.pastdmark: pop af  
27b8			endm  
# End of macro DMARK
27b8						CALLMONITOR 
27b8 cd 70 17			call break_point_state  
27bb				endm  
# End of macro CALLMONITOR
27bb					endif 
27bb			 
27bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27bb cd d5 1f			call macro_dsp_valuehl 
27be				endm 
# End of macro FORTH_DSP_VALUEHL
27be e5					push hl    ; n2 
27bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27bf cd 8d 20			call macro_forth_dsp_pop 
27c2				endm 
# End of macro FORTH_DSP_POP
27c2			 
27c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27c2 cd d5 1f			call macro_dsp_valuehl 
27c5				endm 
# End of macro FORTH_DSP_VALUEHL
27c5 e5					push hl    ; n1 
27c6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27c6 cd 8d 20			call macro_forth_dsp_pop 
27c9				endm 
# End of macro FORTH_DSP_POP
27c9			 
27c9 d1					pop de     ; n1 
27ca e1					pop hl     ; n2 
27cb			 
27cb d5					push de 
27cc e5					push hl 
27cd d5					push de 
27ce			 
27ce					; push back  
27ce			 
27ce e1					pop hl 
27cf cd de 1d				call forth_push_numhl 
27d2 e1					pop hl 
27d3 cd de 1d				call forth_push_numhl 
27d6 e1					pop hl 
27d7 cd de 1d				call forth_push_numhl 
27da					NEXTW 
27da c3 47 21			jp macro_next 
27dd				endm 
# End of macro NEXTW
27dd			 
27dd			.PAUSE: 
27dd				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
27dd 43				db WORD_SYS_CORE+47             
27de 12 28			dw .PAUSES            
27e0 08				db 7 + 1 
27e1 .. 00			db "PAUSEMS",0              
27e9				endm 
# End of macro CWHEAD
27e9			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
27e9					if DEBUG_FORTH_WORDS_KEY 
27e9						DMARK "PMS" 
27e9 f5				push af  
27ea 3a fe 27			ld a, (.dmark)  
27ed 32 b4 fe			ld (debug_mark),a  
27f0 3a ff 27			ld a, (.dmark+1)  
27f3 32 b5 fe			ld (debug_mark+1),a  
27f6 3a 00 28			ld a, (.dmark+2)  
27f9 32 b6 fe			ld (debug_mark+2),a  
27fc 18 03			jr .pastdmark  
27fe ..			.dmark: db "PMS"  
2801 f1			.pastdmark: pop af  
2802			endm  
# End of macro DMARK
2802						CALLMONITOR 
2802 cd 70 17			call break_point_state  
2805				endm  
# End of macro CALLMONITOR
2805					endif 
2805					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2805 cd d5 1f			call macro_dsp_valuehl 
2808				endm 
# End of macro FORTH_DSP_VALUEHL
2808			;		push hl    ; n2 
2808					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2808 cd 8d 20			call macro_forth_dsp_pop 
280b				endm 
# End of macro FORTH_DSP_POP
280b			;		pop hl 
280b			 
280b 7d					ld a, l 
280c cd 21 0b				call aDelayInMS 
280f				       NEXTW 
280f c3 47 21			jp macro_next 
2812				endm 
# End of macro NEXTW
2812			.PAUSES:  
2812				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2812 44				db WORD_SYS_CORE+48             
2813 81 28			dw .ROT            
2815 06				db 5 + 1 
2816 .. 00			db "PAUSE",0              
281c				endm 
# End of macro CWHEAD
281c			; | PAUSE ( n -- )  Pause for n seconds | DONE 
281c					if DEBUG_FORTH_WORDS_KEY 
281c						DMARK "PAU" 
281c f5				push af  
281d 3a 31 28			ld a, (.dmark)  
2820 32 b4 fe			ld (debug_mark),a  
2823 3a 32 28			ld a, (.dmark+1)  
2826 32 b5 fe			ld (debug_mark+1),a  
2829 3a 33 28			ld a, (.dmark+2)  
282c 32 b6 fe			ld (debug_mark+2),a  
282f 18 03			jr .pastdmark  
2831 ..			.dmark: db "PAU"  
2834 f1			.pastdmark: pop af  
2835			endm  
# End of macro DMARK
2835						CALLMONITOR 
2835 cd 70 17			call break_point_state  
2838				endm  
# End of macro CALLMONITOR
2838					endif 
2838					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2838 cd d5 1f			call macro_dsp_valuehl 
283b				endm 
# End of macro FORTH_DSP_VALUEHL
283b			;		push hl    ; n2 
283b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
283b cd 8d 20			call macro_forth_dsp_pop 
283e				endm 
# End of macro FORTH_DSP_POP
283e			;		pop hl 
283e 45					ld b, l 
283f					if DEBUG_FORTH_WORDS 
283f						DMARK "PAU" 
283f f5				push af  
2840 3a 54 28			ld a, (.dmark)  
2843 32 b4 fe			ld (debug_mark),a  
2846 3a 55 28			ld a, (.dmark+1)  
2849 32 b5 fe			ld (debug_mark+1),a  
284c 3a 56 28			ld a, (.dmark+2)  
284f 32 b6 fe			ld (debug_mark+2),a  
2852 18 03			jr .pastdmark  
2854 ..			.dmark: db "PAU"  
2857 f1			.pastdmark: pop af  
2858			endm  
# End of macro DMARK
2858						CALLMONITOR 
2858 cd 70 17			call break_point_state  
285b				endm  
# End of macro CALLMONITOR
285b					endif 
285b c5			.pauses1:	push bc 
285c cd 3c 0b				call delay1s 
285f c1					pop bc 
2860					if DEBUG_FORTH_WORDS 
2860						DMARK "PA1" 
2860 f5				push af  
2861 3a 75 28			ld a, (.dmark)  
2864 32 b4 fe			ld (debug_mark),a  
2867 3a 76 28			ld a, (.dmark+1)  
286a 32 b5 fe			ld (debug_mark+1),a  
286d 3a 77 28			ld a, (.dmark+2)  
2870 32 b6 fe			ld (debug_mark+2),a  
2873 18 03			jr .pastdmark  
2875 ..			.dmark: db "PA1"  
2878 f1			.pastdmark: pop af  
2879			endm  
# End of macro DMARK
2879						CALLMONITOR 
2879 cd 70 17			call break_point_state  
287c				endm  
# End of macro CALLMONITOR
287c					endif 
287c 10 dd				djnz .pauses1 
287e			 
287e				       NEXTW 
287e c3 47 21			jp macro_next 
2881				endm 
# End of macro NEXTW
2881			.ROT: 
2881				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2881 45				db WORD_SYS_CORE+49             
2882 cf 28			dw .UWORDS            
2884 04				db 3 + 1 
2885 .. 00			db "ROT",0              
2889				endm 
# End of macro CWHEAD
2889			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2889					if DEBUG_FORTH_WORDS_KEY 
2889						DMARK "ROT" 
2889 f5				push af  
288a 3a 9e 28			ld a, (.dmark)  
288d 32 b4 fe			ld (debug_mark),a  
2890 3a 9f 28			ld a, (.dmark+1)  
2893 32 b5 fe			ld (debug_mark+1),a  
2896 3a a0 28			ld a, (.dmark+2)  
2899 32 b6 fe			ld (debug_mark+2),a  
289c 18 03			jr .pastdmark  
289e ..			.dmark: db "ROT"  
28a1 f1			.pastdmark: pop af  
28a2			endm  
# End of macro DMARK
28a2						CALLMONITOR 
28a2 cd 70 17			call break_point_state  
28a5				endm  
# End of macro CALLMONITOR
28a5					endif 
28a5			 
28a5					FORTH_DSP_VALUEHL 
28a5 cd d5 1f			call macro_dsp_valuehl 
28a8				endm 
# End of macro FORTH_DSP_VALUEHL
28a8 e5					push hl    ; u3  
28a9			 
28a9					FORTH_DSP_POP 
28a9 cd 8d 20			call macro_forth_dsp_pop 
28ac				endm 
# End of macro FORTH_DSP_POP
28ac			   
28ac					FORTH_DSP_VALUEHL 
28ac cd d5 1f			call macro_dsp_valuehl 
28af				endm 
# End of macro FORTH_DSP_VALUEHL
28af e5					push hl     ; u2 
28b0			 
28b0					FORTH_DSP_POP 
28b0 cd 8d 20			call macro_forth_dsp_pop 
28b3				endm 
# End of macro FORTH_DSP_POP
28b3			 
28b3					FORTH_DSP_VALUEHL 
28b3 cd d5 1f			call macro_dsp_valuehl 
28b6				endm 
# End of macro FORTH_DSP_VALUEHL
28b6 e5					push hl     ; u1 
28b7			 
28b7					FORTH_DSP_POP 
28b7 cd 8d 20			call macro_forth_dsp_pop 
28ba				endm 
# End of macro FORTH_DSP_POP
28ba			 
28ba c1					pop bc      ; u1 
28bb e1					pop hl      ; u2 
28bc d1					pop de      ; u3 
28bd			 
28bd			 
28bd c5					push bc 
28be d5					push de 
28bf e5					push hl 
28c0			 
28c0			 
28c0 e1					pop hl 
28c1 cd de 1d				call forth_push_numhl 
28c4			 
28c4 e1					pop hl 
28c5 cd de 1d				call forth_push_numhl 
28c8			 
28c8 e1					pop hl 
28c9 cd de 1d				call forth_push_numhl 
28cc					 
28cc			 
28cc			 
28cc			 
28cc			 
28cc			 
28cc				       NEXTW 
28cc c3 47 21			jp macro_next 
28cf				endm 
# End of macro NEXTW
28cf			 
28cf			.UWORDS: 
28cf				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
28cf 50				db WORD_SYS_CORE+60             
28d0 91 29			dw .BP            
28d2 07				db 6 + 1 
28d3 .. 00			db "UWORDS",0              
28da				endm 
# End of macro CWHEAD
28da			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
28da			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
28da			; | | Following the count are the individual words. 
28da			; | | 
28da			; | | e.g. UWORDS 
28da			; | | BOX DIRLIST 2 
28da			; | |  
28da			; | | Can be used to save the words to storage via: 
28da			; | | UWORDS $01 DO $01 APPEND LOOP 
28da				if DEBUG_FORTH_WORDS_KEY 
28da					DMARK "UWR" 
28da f5				push af  
28db 3a ef 28			ld a, (.dmark)  
28de 32 b4 fe			ld (debug_mark),a  
28e1 3a f0 28			ld a, (.dmark+1)  
28e4 32 b5 fe			ld (debug_mark+1),a  
28e7 3a f1 28			ld a, (.dmark+2)  
28ea 32 b6 fe			ld (debug_mark+2),a  
28ed 18 03			jr .pastdmark  
28ef ..			.dmark: db "UWR"  
28f2 f1			.pastdmark: pop af  
28f3			endm  
# End of macro DMARK
28f3					CALLMONITOR 
28f3 cd 70 17			call break_point_state  
28f6				endm  
# End of macro CALLMONITOR
28f6				endif 
28f6 21 00 80				ld hl, baseram 
28f9					;ld hl, baseusermem 
28f9 01 00 00				ld bc, 0    ; start a counter 
28fc			 
28fc				; skip dict stub 
28fc			 
28fc cd 98 22				call forth_tok_next 
28ff			 
28ff			 
28ff			; while we have words to look for 
28ff			 
28ff 7e			.douscan:	ld a, (hl)      
2900				if DEBUG_FORTH_WORDS 
2900					DMARK "UWs" 
2900 f5				push af  
2901 3a 15 29			ld a, (.dmark)  
2904 32 b4 fe			ld (debug_mark),a  
2907 3a 16 29			ld a, (.dmark+1)  
290a 32 b5 fe			ld (debug_mark+1),a  
290d 3a 17 29			ld a, (.dmark+2)  
2910 32 b6 fe			ld (debug_mark+2),a  
2913 18 03			jr .pastdmark  
2915 ..			.dmark: db "UWs"  
2918 f1			.pastdmark: pop af  
2919			endm  
# End of macro DMARK
2919					CALLMONITOR 
2919 cd 70 17			call break_point_state  
291c				endm  
# End of macro CALLMONITOR
291c				endif 
291c fe 00				cp WORD_SYS_END 
291e 28 4d				jr z, .udone 
2920 fe 01				cp WORD_SYS_UWORD 
2922 20 44				jr nz, .nuword 
2924			 
2924				if DEBUG_FORTH_WORDS 
2924					DMARK "UWu" 
2924 f5				push af  
2925 3a 39 29			ld a, (.dmark)  
2928 32 b4 fe			ld (debug_mark),a  
292b 3a 3a 29			ld a, (.dmark+1)  
292e 32 b5 fe			ld (debug_mark+1),a  
2931 3a 3b 29			ld a, (.dmark+2)  
2934 32 b6 fe			ld (debug_mark+2),a  
2937 18 03			jr .pastdmark  
2939 ..			.dmark: db "UWu"  
293c f1			.pastdmark: pop af  
293d			endm  
# End of macro DMARK
293d					CALLMONITOR 
293d cd 70 17			call break_point_state  
2940				endm  
# End of macro CALLMONITOR
2940				endif 
2940					; we have a uword so push its name to the stack 
2940			 
2940 e5				   	push hl  ; save so we can move to next dict block 
2941			 
2941					; skip opcode 
2941 23					inc hl  
2942					; skip next ptr 
2942 23					inc hl  
2943 23					inc hl 
2944					; skip len 
2944 23					inc hl 
2945				if DEBUG_FORTH_WORDS 
2945					DMARK "UWt" 
2945 f5				push af  
2946 3a 5a 29			ld a, (.dmark)  
2949 32 b4 fe			ld (debug_mark),a  
294c 3a 5b 29			ld a, (.dmark+1)  
294f 32 b5 fe			ld (debug_mark+1),a  
2952 3a 5c 29			ld a, (.dmark+2)  
2955 32 b6 fe			ld (debug_mark+2),a  
2958 18 03			jr .pastdmark  
295a ..			.dmark: db "UWt"  
295d f1			.pastdmark: pop af  
295e			endm  
# End of macro DMARK
295e					CALLMONITOR 
295e cd 70 17			call break_point_state  
2961				endm  
# End of macro CALLMONITOR
2961				endif 
2961 03					inc bc 
2962			 
2962 c5					push bc 
2963 cd 4c 1e				call forth_push_str 
2966 c1					pop bc 
2967			 
2967 e1					pop hl 	 
2968			 
2968 cd 98 22		.nuword:	call forth_tok_next 
296b 18 92				jr .douscan  
296d			 
296d			.udone:		 ; push count of uwords found 
296d c5					push bc 
296e e1					pop hl 
296f			 
296f				if DEBUG_FORTH_WORDS 
296f					DMARK "UWc" 
296f f5				push af  
2970 3a 84 29			ld a, (.dmark)  
2973 32 b4 fe			ld (debug_mark),a  
2976 3a 85 29			ld a, (.dmark+1)  
2979 32 b5 fe			ld (debug_mark+1),a  
297c 3a 86 29			ld a, (.dmark+2)  
297f 32 b6 fe			ld (debug_mark+2),a  
2982 18 03			jr .pastdmark  
2984 ..			.dmark: db "UWc"  
2987 f1			.pastdmark: pop af  
2988			endm  
# End of macro DMARK
2988					CALLMONITOR 
2988 cd 70 17			call break_point_state  
298b				endm  
# End of macro CALLMONITOR
298b				endif 
298b cd de 1d				call forth_push_numhl 
298e			 
298e			 
298e				       NEXTW 
298e c3 47 21			jp macro_next 
2991				endm 
# End of macro NEXTW
2991			 
2991			.BP: 
2991				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2991 54				db WORD_SYS_CORE+64             
2992 c7 29			dw .MONITOR            
2994 03				db 2 + 1 
2995 .. 00			db "BP",0              
2998				endm 
# End of macro CWHEAD
2998			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2998			; | | $00 Will enable the break points within specific code paths 
2998			; | | $01 Will disable break points 
2998			; | |  
2998			; | | By default break points are off. Either the above can be used to enable them 
2998			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2998			; | | and on release of the pressed key a message will be disaplayed to notify 
2998			; | | that break points are enabled. Pressing any key will then continue boot process. 
2998					; get byte count 
2998					if DEBUG_FORTH_WORDS_KEY 
2998						DMARK "BP." 
2998 f5				push af  
2999 3a ad 29			ld a, (.dmark)  
299c 32 b4 fe			ld (debug_mark),a  
299f 3a ae 29			ld a, (.dmark+1)  
29a2 32 b5 fe			ld (debug_mark+1),a  
29a5 3a af 29			ld a, (.dmark+2)  
29a8 32 b6 fe			ld (debug_mark+2),a  
29ab 18 03			jr .pastdmark  
29ad ..			.dmark: db "BP."  
29b0 f1			.pastdmark: pop af  
29b1			endm  
# End of macro DMARK
29b1						CALLMONITOR 
29b1 cd 70 17			call break_point_state  
29b4				endm  
# End of macro CALLMONITOR
29b4					endif 
29b4			 
29b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29b4 cd d5 1f			call macro_dsp_valuehl 
29b7				endm 
# End of macro FORTH_DSP_VALUEHL
29b7			 
29b7			;		push hl 
29b7			 
29b7					; destroy value TOS 
29b7			 
29b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29b7 cd 8d 20			call macro_forth_dsp_pop 
29ba				endm 
# End of macro FORTH_DSP_POP
29ba			 
29ba			;		pop hl 
29ba			 
29ba 3e 00				ld a,0 
29bc bd					cp l 
29bd 28 02				jr z, .bpset 
29bf 3e 2a				ld a, '*' 
29c1			 
29c1 32 4b f4		.bpset:		ld (os_view_disable), a 
29c4			 
29c4			 
29c4					NEXTW 
29c4 c3 47 21			jp macro_next 
29c7				endm 
# End of macro NEXTW
29c7			 
29c7			 
29c7			.MONITOR: 
29c7				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
29c7 55				db WORD_SYS_CORE+65             
29c8 fa 29			dw .MALLOC            
29ca 08				db 7 + 1 
29cb .. 00			db "MONITOR",0              
29d3				endm 
# End of macro CWHEAD
29d3			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
29d3			; | | At start the current various registers will be displayed with contents. 
29d3			; | | Top right corner will show the most recent debug marker seen. 
29d3			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
29d3			; | | and the return stack pointer (RSP). 
29d3			; | | Pressing: 
29d3			; | |    1 - Initial screen 
29d3			; | |    2 - Display a data dump of HL 
29d3			; | |    3 - Display a data dump of DE 
29d3			; | |    4 - Display a data dump of BC 
29d3			; | |    5 - Display a data dump of HL 
29d3			; | |    6 - Display a data dump of DSP 
29d3			; | |    7 - Display a data dump of RSP 
29d3			; | |    8 - Display a data dump of what is at DSP 
29d3			; | |    9 - Display a data dump of what is at RSP 
29d3			; | |    0 - Exit monitor and continue running. This will also enable break points 
29d3			; | |    * - Disable break points 
29d3			; | |    # - Enter traditional monitor mode 
29d3			; | | 
29d3			; | | Monitor Mode 
29d3			; | | ------------ 
29d3			; | | A prompt of '>' will be shown for various commands: 
29d3			; | |    D xxxx - Display a data dump starting from hex address xxxx 
29d3			; | |    C - Continue display a data dump from the last set address 
29d3			; | |    M xxxx - Set start of memory edit at address xx 
29d3			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
29d3			; | |    Q - Return to previous 
29d3					if DEBUG_FORTH_WORDS_KEY 
29d3						DMARK "MON" 
29d3 f5				push af  
29d4 3a e8 29			ld a, (.dmark)  
29d7 32 b4 fe			ld (debug_mark),a  
29da 3a e9 29			ld a, (.dmark+1)  
29dd 32 b5 fe			ld (debug_mark+1),a  
29e0 3a ea 29			ld a, (.dmark+2)  
29e3 32 b6 fe			ld (debug_mark+2),a  
29e6 18 03			jr .pastdmark  
29e8 ..			.dmark: db "MON"  
29eb f1			.pastdmark: pop af  
29ec			endm  
# End of macro DMARK
29ec						CALLMONITOR 
29ec cd 70 17			call break_point_state  
29ef				endm  
# End of macro CALLMONITOR
29ef					endif 
29ef 3e 00				ld a, 0 
29f1 32 4b f4				ld (os_view_disable), a 
29f4			 
29f4					CALLMONITOR 
29f4 cd 70 17			call break_point_state  
29f7				endm  
# End of macro CALLMONITOR
29f7			 
29f7			;	call monitor 
29f7			 
29f7					NEXTW 
29f7 c3 47 21			jp macro_next 
29fa				endm 
# End of macro NEXTW
29fa			 
29fa			 
29fa			.MALLOC: 
29fa				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
29fa 56				db WORD_SYS_CORE+66             
29fb 23 2a			dw .MALLOC2            
29fd 06				db 5 + 1 
29fe .. 00			db "ALLOT",0              
2a04				endm 
# End of macro CWHEAD
2a04			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2a04					if DEBUG_FORTH_WORDS_KEY 
2a04						DMARK "ALL" 
2a04 f5				push af  
2a05 3a 19 2a			ld a, (.dmark)  
2a08 32 b4 fe			ld (debug_mark),a  
2a0b 3a 1a 2a			ld a, (.dmark+1)  
2a0e 32 b5 fe			ld (debug_mark+1),a  
2a11 3a 1b 2a			ld a, (.dmark+2)  
2a14 32 b6 fe			ld (debug_mark+2),a  
2a17 18 03			jr .pastdmark  
2a19 ..			.dmark: db "ALL"  
2a1c f1			.pastdmark: pop af  
2a1d			endm  
# End of macro DMARK
2a1d						CALLMONITOR 
2a1d cd 70 17			call break_point_state  
2a20				endm  
# End of macro CALLMONITOR
2a20					endif 
2a20 c3 4a 2a				jp .mallocc 
2a23			.MALLOC2: 
2a23				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2a23 56				db WORD_SYS_CORE+66             
2a24 61 2a			dw .FREE            
2a26 07				db 6 + 1 
2a27 .. 00			db "MALLOC",0              
2a2e				endm 
# End of macro CWHEAD
2a2e			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2a2e					; get byte count 
2a2e					if DEBUG_FORTH_WORDS_KEY 
2a2e						DMARK "MAL" 
2a2e f5				push af  
2a2f 3a 43 2a			ld a, (.dmark)  
2a32 32 b4 fe			ld (debug_mark),a  
2a35 3a 44 2a			ld a, (.dmark+1)  
2a38 32 b5 fe			ld (debug_mark+1),a  
2a3b 3a 45 2a			ld a, (.dmark+2)  
2a3e 32 b6 fe			ld (debug_mark+2),a  
2a41 18 03			jr .pastdmark  
2a43 ..			.dmark: db "MAL"  
2a46 f1			.pastdmark: pop af  
2a47			endm  
# End of macro DMARK
2a47						CALLMONITOR 
2a47 cd 70 17			call break_point_state  
2a4a				endm  
# End of macro CALLMONITOR
2a4a					endif 
2a4a			.mallocc: 
2a4a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a4a cd d5 1f			call macro_dsp_valuehl 
2a4d				endm 
# End of macro FORTH_DSP_VALUEHL
2a4d			 
2a4d			;		push hl 
2a4d			 
2a4d					; destroy value TOS 
2a4d			 
2a4d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a4d cd 8d 20			call macro_forth_dsp_pop 
2a50				endm 
# End of macro FORTH_DSP_POP
2a50			 
2a50			;		pop hl 
2a50 cd ba 12				call malloc 
2a53				if DEBUG_FORTH_MALLOC_GUARD 
2a53 f5					push af 
2a54 cd 1c 0e				call ishlzero 
2a57			;		ld a, l 
2a57			;		add h 
2a57			;		cp 0 
2a57 f1					pop af 
2a58					 
2a58 cc 9d 53				call z,malloc_error 
2a5b				endif 
2a5b			 
2a5b cd de 1d				call forth_push_numhl 
2a5e					NEXTW 
2a5e c3 47 21			jp macro_next 
2a61				endm 
# End of macro NEXTW
2a61			 
2a61			.FREE: 
2a61				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2a61 57				db WORD_SYS_CORE+67             
2a62 92 2a			dw .LIST            
2a64 05				db 4 + 1 
2a65 .. 00			db "FREE",0              
2a6a				endm 
# End of macro CWHEAD
2a6a			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2a6a					if DEBUG_FORTH_WORDS_KEY 
2a6a						DMARK "FRE" 
2a6a f5				push af  
2a6b 3a 7f 2a			ld a, (.dmark)  
2a6e 32 b4 fe			ld (debug_mark),a  
2a71 3a 80 2a			ld a, (.dmark+1)  
2a74 32 b5 fe			ld (debug_mark+1),a  
2a77 3a 81 2a			ld a, (.dmark+2)  
2a7a 32 b6 fe			ld (debug_mark+2),a  
2a7d 18 03			jr .pastdmark  
2a7f ..			.dmark: db "FRE"  
2a82 f1			.pastdmark: pop af  
2a83			endm  
# End of macro DMARK
2a83						CALLMONITOR 
2a83 cd 70 17			call break_point_state  
2a86				endm  
# End of macro CALLMONITOR
2a86					endif 
2a86					; get address 
2a86			 
2a86					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a86 cd d5 1f			call macro_dsp_valuehl 
2a89				endm 
# End of macro FORTH_DSP_VALUEHL
2a89			 
2a89			;		push hl 
2a89			 
2a89					; destroy value TOS 
2a89			 
2a89					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a89 cd 8d 20			call macro_forth_dsp_pop 
2a8c				endm 
# End of macro FORTH_DSP_POP
2a8c			 
2a8c			;		pop hl 
2a8c			if FORTH_ENABLE_MALLOCFREE 
2a8c cd 84 13				call free 
2a8f			endif 
2a8f					NEXTW 
2a8f c3 47 21			jp macro_next 
2a92				endm 
# End of macro NEXTW
2a92			.LIST: 
2a92				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2a92 5c				db WORD_SYS_CORE+72             
2a93 80 2c			dw .FORGET            
2a95 05				db 4 + 1 
2a96 .. 00			db "LIST",0              
2a9b				endm 
# End of macro CWHEAD
2a9b			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2a9b			; | | The quoted word must be in upper case. 
2a9b				if DEBUG_FORTH_WORDS_KEY 
2a9b					DMARK "LST" 
2a9b f5				push af  
2a9c 3a b0 2a			ld a, (.dmark)  
2a9f 32 b4 fe			ld (debug_mark),a  
2aa2 3a b1 2a			ld a, (.dmark+1)  
2aa5 32 b5 fe			ld (debug_mark+1),a  
2aa8 3a b2 2a			ld a, (.dmark+2)  
2aab 32 b6 fe			ld (debug_mark+2),a  
2aae 18 03			jr .pastdmark  
2ab0 ..			.dmark: db "LST"  
2ab3 f1			.pastdmark: pop af  
2ab4			endm  
# End of macro DMARK
2ab4					CALLMONITOR 
2ab4 cd 70 17			call break_point_state  
2ab7				endm  
# End of macro CALLMONITOR
2ab7				endif 
2ab7			 
2ab7					FORTH_DSP_VALUEHL 
2ab7 cd d5 1f			call macro_dsp_valuehl 
2aba				endm 
# End of macro FORTH_DSP_VALUEHL
2aba			 
2aba e5					push hl 
2abb					FORTH_DSP_POP 
2abb cd 8d 20			call macro_forth_dsp_pop 
2abe				endm 
# End of macro FORTH_DSP_POP
2abe c1					pop bc 
2abf			 
2abf			; Start format of scratch string 
2abf			 
2abf 21 5a f4				ld hl, scratch 
2ac2			 
2ac2 3e 3a				ld a, ':' 
2ac4 77					ld (hl),a 
2ac5 23					inc hl 
2ac6 3e 20				ld a, ' ' 
2ac8 77					ld (hl), a 
2ac9			 
2ac9					; Get ptr to the word we need to look up 
2ac9			 
2ac9			;		FORTH_DSP_VALUEHL 
2ac9					;v5 FORTH_DSP_VALUE 
2ac9				; TODO type check 
2ac9			;		inc hl    ; Skip type check  
2ac9			;		push hl 
2ac9			;		ex de, hl    ; put into DE 
2ac9			 
2ac9			 
2ac9 21 00 80				ld hl, baseram 
2acc					;ld hl, baseusermem 
2acc			 
2acc e5			push hl   ; sacreifical push 
2acd			 
2acd			.ldouscanm: 
2acd e1				pop hl 
2ace			.ldouscan: 
2ace				if DEBUG_FORTH_WORDS 
2ace					DMARK "LSs" 
2ace f5				push af  
2acf 3a e3 2a			ld a, (.dmark)  
2ad2 32 b4 fe			ld (debug_mark),a  
2ad5 3a e4 2a			ld a, (.dmark+1)  
2ad8 32 b5 fe			ld (debug_mark+1),a  
2adb 3a e5 2a			ld a, (.dmark+2)  
2ade 32 b6 fe			ld (debug_mark+2),a  
2ae1 18 03			jr .pastdmark  
2ae3 ..			.dmark: db "LSs"  
2ae6 f1			.pastdmark: pop af  
2ae7			endm  
# End of macro DMARK
2ae7					CALLMONITOR 
2ae7 cd 70 17			call break_point_state  
2aea				endm  
# End of macro CALLMONITOR
2aea				endif 
2aea				; skip dict stub 
2aea cd 98 22				call forth_tok_next 
2aed			 
2aed			 
2aed			; while we have words to look for 
2aed			 
2aed 7e				ld a, (hl)      
2aee				if DEBUG_FORTH_WORDS 
2aee					DMARK "LSk" 
2aee f5				push af  
2aef 3a 03 2b			ld a, (.dmark)  
2af2 32 b4 fe			ld (debug_mark),a  
2af5 3a 04 2b			ld a, (.dmark+1)  
2af8 32 b5 fe			ld (debug_mark+1),a  
2afb 3a 05 2b			ld a, (.dmark+2)  
2afe 32 b6 fe			ld (debug_mark+2),a  
2b01 18 03			jr .pastdmark  
2b03 ..			.dmark: db "LSk"  
2b06 f1			.pastdmark: pop af  
2b07			endm  
# End of macro DMARK
2b07					CALLMONITOR 
2b07 cd 70 17			call break_point_state  
2b0a				endm  
# End of macro CALLMONITOR
2b0a				endif 
2b0a					;cp WORD_SYS_END 
2b0a					;jp z, .lunotfound 
2b0a			 
2b0a					; if we hit non uwords then gone too far 
2b0a fe 01				cp WORD_SYS_UWORD 
2b0c c2 3c 2c				jp nz, .lunotfound 
2b0f			 
2b0f				if DEBUG_FORTH_WORDS 
2b0f					DMARK "LSu" 
2b0f f5				push af  
2b10 3a 24 2b			ld a, (.dmark)  
2b13 32 b4 fe			ld (debug_mark),a  
2b16 3a 25 2b			ld a, (.dmark+1)  
2b19 32 b5 fe			ld (debug_mark+1),a  
2b1c 3a 26 2b			ld a, (.dmark+2)  
2b1f 32 b6 fe			ld (debug_mark+2),a  
2b22 18 03			jr .pastdmark  
2b24 ..			.dmark: db "LSu"  
2b27 f1			.pastdmark: pop af  
2b28			endm  
# End of macro DMARK
2b28					CALLMONITOR 
2b28 cd 70 17			call break_point_state  
2b2b				endm  
# End of macro CALLMONITOR
2b2b				endif 
2b2b			 
2b2b					; found a uword but is it the one we want... 
2b2b			 
2b2b c5					push bc     ; uword to find is on bc 
2b2c d1					pop de 
2b2d			 
2b2d e5					push hl  ; to save the ptr 
2b2e			 
2b2e					; skip opcode 
2b2e 23					inc hl  
2b2f					; skip next ptr 
2b2f 23					inc hl  
2b30 23					inc hl 
2b31					; skip len 
2b31 23					inc hl 
2b32			 
2b32				if DEBUG_FORTH_WORDS 
2b32					DMARK "LSc" 
2b32 f5				push af  
2b33 3a 47 2b			ld a, (.dmark)  
2b36 32 b4 fe			ld (debug_mark),a  
2b39 3a 48 2b			ld a, (.dmark+1)  
2b3c 32 b5 fe			ld (debug_mark+1),a  
2b3f 3a 49 2b			ld a, (.dmark+2)  
2b42 32 b6 fe			ld (debug_mark+2),a  
2b45 18 03			jr .pastdmark  
2b47 ..			.dmark: db "LSc"  
2b4a f1			.pastdmark: pop af  
2b4b			endm  
# End of macro DMARK
2b4b					CALLMONITOR 
2b4b cd 70 17			call break_point_state  
2b4e				endm  
# End of macro CALLMONITOR
2b4e				endif 
2b4e cd 89 12				call strcmp 
2b51 c2 cd 2a				jp nz, .ldouscanm 
2b54				 
2b54			 
2b54			 
2b54					; we have a uword so push its name to the stack 
2b54			 
2b54			;	   	push hl  ; save so we can move to next dict block 
2b54 e1			pop hl 
2b55			 
2b55				if DEBUG_FORTH_WORDS 
2b55					DMARK "LSm" 
2b55 f5				push af  
2b56 3a 6a 2b			ld a, (.dmark)  
2b59 32 b4 fe			ld (debug_mark),a  
2b5c 3a 6b 2b			ld a, (.dmark+1)  
2b5f 32 b5 fe			ld (debug_mark+1),a  
2b62 3a 6c 2b			ld a, (.dmark+2)  
2b65 32 b6 fe			ld (debug_mark+2),a  
2b68 18 03			jr .pastdmark  
2b6a ..			.dmark: db "LSm"  
2b6d f1			.pastdmark: pop af  
2b6e			endm  
# End of macro DMARK
2b6e					CALLMONITOR 
2b6e cd 70 17			call break_point_state  
2b71				endm  
# End of macro CALLMONITOR
2b71				endif 
2b71			 
2b71					; skip opcode 
2b71 23					inc hl  
2b72					; skip next ptr 
2b72 23					inc hl  
2b73 23					inc hl 
2b74					; skip len 
2b74 7e					ld a, (hl)   ; save length to add 
2b75				if DEBUG_FORTH_WORDS 
2b75					DMARK "LS2" 
2b75 f5				push af  
2b76 3a 8a 2b			ld a, (.dmark)  
2b79 32 b4 fe			ld (debug_mark),a  
2b7c 3a 8b 2b			ld a, (.dmark+1)  
2b7f 32 b5 fe			ld (debug_mark+1),a  
2b82 3a 8c 2b			ld a, (.dmark+2)  
2b85 32 b6 fe			ld (debug_mark+2),a  
2b88 18 03			jr .pastdmark  
2b8a ..			.dmark: db "LS2"  
2b8d f1			.pastdmark: pop af  
2b8e			endm  
# End of macro DMARK
2b8e					CALLMONITOR 
2b8e cd 70 17			call break_point_state  
2b91				endm  
# End of macro CALLMONITOR
2b91				endif 
2b91			 
2b91					; save this location 
2b91				 
2b91 e5					push hl 
2b92			 
2b92 23					inc hl 
2b93 11 5c f4				ld de, scratch+2 
2b96 4f					ld c, a 
2b97 06 00				ld b, 0 
2b99			 
2b99				if DEBUG_FORTH_WORDS 
2b99					DMARK "LSn" 
2b99 f5				push af  
2b9a 3a ae 2b			ld a, (.dmark)  
2b9d 32 b4 fe			ld (debug_mark),a  
2ba0 3a af 2b			ld a, (.dmark+1)  
2ba3 32 b5 fe			ld (debug_mark+1),a  
2ba6 3a b0 2b			ld a, (.dmark+2)  
2ba9 32 b6 fe			ld (debug_mark+2),a  
2bac 18 03			jr .pastdmark  
2bae ..			.dmark: db "LSn"  
2bb1 f1			.pastdmark: pop af  
2bb2			endm  
# End of macro DMARK
2bb2					CALLMONITOR 
2bb2 cd 70 17			call break_point_state  
2bb5				endm  
# End of macro CALLMONITOR
2bb5				endif 
2bb5			 
2bb5					; copy uword name to scratch 
2bb5			 
2bb5 ed b0				ldir 
2bb7			 
2bb7 1b					dec de 
2bb8 3e 20				ld a, ' '    ; change null to space 
2bba 12					ld (de), a 
2bbb			 
2bbb 13					inc de 
2bbc			 
2bbc d5					push de 
2bbd c1					pop bc     ; move scratch pointer to end of word name and save it 
2bbe			 
2bbe e1					pop hl 
2bbf 7e					ld a, (hl) 
2bc0					;inc hl 
2bc0					; skip word string 
2bc0 cd f3 0d				call addatohl 
2bc3			 
2bc3 23					inc hl 
2bc4			 
2bc4				if DEBUG_FORTH_WORDS 
2bc4					DMARK "LS3" 
2bc4 f5				push af  
2bc5 3a d9 2b			ld a, (.dmark)  
2bc8 32 b4 fe			ld (debug_mark),a  
2bcb 3a da 2b			ld a, (.dmark+1)  
2bce 32 b5 fe			ld (debug_mark+1),a  
2bd1 3a db 2b			ld a, (.dmark+2)  
2bd4 32 b6 fe			ld (debug_mark+2),a  
2bd7 18 03			jr .pastdmark  
2bd9 ..			.dmark: db "LS3"  
2bdc f1			.pastdmark: pop af  
2bdd			endm  
# End of macro DMARK
2bdd					CALLMONITOR 
2bdd cd 70 17			call break_point_state  
2be0				endm  
# End of macro CALLMONITOR
2be0				endif 
2be0					; should now be at the start of the machine code to setup the eval of the uword 
2be0					; now locate the ptr to the string defintion 
2be0			 
2be0					; skip ld hl, 
2be0					; then load the ptr 
2be0			; TODO use get from hl ptr 
2be0 23					inc hl 
2be1 5e					ld e, (hl) 
2be2 23					inc hl 
2be3 56					ld d, (hl) 
2be4 eb					ex de, hl 
2be5			 
2be5			 
2be5				if DEBUG_FORTH_WORDS 
2be5					DMARK "LSt" 
2be5 f5				push af  
2be6 3a fa 2b			ld a, (.dmark)  
2be9 32 b4 fe			ld (debug_mark),a  
2bec 3a fb 2b			ld a, (.dmark+1)  
2bef 32 b5 fe			ld (debug_mark+1),a  
2bf2 3a fc 2b			ld a, (.dmark+2)  
2bf5 32 b6 fe			ld (debug_mark+2),a  
2bf8 18 03			jr .pastdmark  
2bfa ..			.dmark: db "LSt"  
2bfd f1			.pastdmark: pop af  
2bfe			endm  
# End of macro DMARK
2bfe					CALLMONITOR 
2bfe cd 70 17			call break_point_state  
2c01				endm  
# End of macro CALLMONITOR
2c01				endif 
2c01			 
2c01			; cant push right now due to tokenised strings  
2c01			 
2c01			; get the destination of where to copy this definition to. 
2c01			 
2c01 c5					push bc 
2c02 d1					pop de 
2c03			 
2c03 7e			.listl:         ld a,(hl) 
2c04 fe 00				cp 0 
2c06 28 09				jr z, .lreplsp     ; replace zero with space 
2c08					;cp FORTH_END_BUFFER 
2c08 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2c0a 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2c0c				 
2c0c					; just copy this char as is then 
2c0c			 
2c0c 12					ld (de), a 
2c0d			 
2c0d 23			.listnxt:	inc hl 
2c0e 13					inc de 
2c0f 18 f2				jr .listl 
2c11			 
2c11 3e 20		.lreplsp:	ld a,' ' 
2c13 12					ld (de), a 
2c14 18 f7				jr .listnxt 
2c16			 
2c16			; close up uword def 
2c16			 
2c16			.listdone: 
2c16 12					ld (de), a 
2c17 13					inc de 
2c18 3e 00				ld a, 0 
2c1a 12					ld (de), a 
2c1b			 
2c1b			; now have def so clean up and push to stack 
2c1b			 
2c1b 21 5a f4				ld hl, scratch 
2c1e				if DEBUG_FORTH_WORDS 
2c1e					DMARK "Ltp" 
2c1e f5				push af  
2c1f 3a 33 2c			ld a, (.dmark)  
2c22 32 b4 fe			ld (debug_mark),a  
2c25 3a 34 2c			ld a, (.dmark+1)  
2c28 32 b5 fe			ld (debug_mark+1),a  
2c2b 3a 35 2c			ld a, (.dmark+2)  
2c2e 32 b6 fe			ld (debug_mark+2),a  
2c31 18 03			jr .pastdmark  
2c33 ..			.dmark: db "Ltp"  
2c36 f1			.pastdmark: pop af  
2c37			endm  
# End of macro DMARK
2c37					CALLMONITOR 
2c37 cd 70 17			call break_point_state  
2c3a				endm  
# End of macro CALLMONITOR
2c3a				endif 
2c3a			 
2c3a 18 1f			jr .listpush 
2c3c			 
2c3c			;.lnuword:	pop hl 
2c3c			;		call forth_tok_next 
2c3c			;		jp .ldouscan  
2c3c			 
2c3c			.lunotfound:		  
2c3c			 
2c3c				if DEBUG_FORTH_WORDS 
2c3c					DMARK "LSn" 
2c3c f5				push af  
2c3d 3a 51 2c			ld a, (.dmark)  
2c40 32 b4 fe			ld (debug_mark),a  
2c43 3a 52 2c			ld a, (.dmark+1)  
2c46 32 b5 fe			ld (debug_mark+1),a  
2c49 3a 53 2c			ld a, (.dmark+2)  
2c4c 32 b6 fe			ld (debug_mark+2),a  
2c4f 18 03			jr .pastdmark  
2c51 ..			.dmark: db "LSn"  
2c54 f1			.pastdmark: pop af  
2c55			endm  
# End of macro DMARK
2c55					CALLMONITOR 
2c55 cd 70 17			call break_point_state  
2c58				endm  
# End of macro CALLMONITOR
2c58				endif 
2c58			 
2c58					 
2c58			;		FORTH_DSP_POP 
2c58			;		ld hl, .luno 
2c58			 
2c58					NEXTW			 
2c58 c3 47 21			jp macro_next 
2c5b				endm 
# End of macro NEXTW
2c5b			 
2c5b			.listpush: 
2c5b				if DEBUG_FORTH_WORDS 
2c5b					DMARK "LS>" 
2c5b f5				push af  
2c5c 3a 70 2c			ld a, (.dmark)  
2c5f 32 b4 fe			ld (debug_mark),a  
2c62 3a 71 2c			ld a, (.dmark+1)  
2c65 32 b5 fe			ld (debug_mark+1),a  
2c68 3a 72 2c			ld a, (.dmark+2)  
2c6b 32 b6 fe			ld (debug_mark+2),a  
2c6e 18 03			jr .pastdmark  
2c70 ..			.dmark: db "LS>"  
2c73 f1			.pastdmark: pop af  
2c74			endm  
# End of macro DMARK
2c74					CALLMONITOR 
2c74 cd 70 17			call break_point_state  
2c77				endm  
# End of macro CALLMONITOR
2c77				endif 
2c77 cd 4c 1e				call forth_push_str 
2c7a			 
2c7a			 
2c7a			 
2c7a					NEXTW 
2c7a c3 47 21			jp macro_next 
2c7d				endm 
# End of macro NEXTW
2c7d			 
2c7d			;.luno:    db "Word not found",0 
2c7d			 
2c7d			 
2c7d			 
2c7d			 
2c7d			 
2c7d			;		push hl   ; save pointer to start of uword def string 
2c7d			; 
2c7d			;; look for FORTH_EOL_LINE 
2c7d			;		ld a, FORTH_END_BUFFER 
2c7d			;		call strlent 
2c7d			; 
2c7d			;		inc hl		 ; space for coln def 
2c7d			;		inc hl 
2c7d			;		inc hl          ; space for terms 
2c7d			;		inc hl 
2c7d			; 
2c7d			;		ld a, 20   ; TODO get actual length 
2c7d			;		call addatohl    ; include a random amount of room for the uword name 
2c7d			; 
2c7d			;		 
2c7d			;	if DEBUG_FORTH_WORDS 
2c7d			;		DMARK "Lt1" 
2c7d			;		CALLMONITOR 
2c7d			;	endif 
2c7d			;		 
2c7d			; 
2c7d			;; malloc space for the string because we cant change it 
2c7d			; 
2c7d			;		call malloc 
2c7d			;	if DEBUG_FORTH_MALLOC_GUARD 
2c7d			;		push af 
2c7d			;		call ishlzero 
2c7d			;		pop af 
2c7d			;		 
2c7d			;		call z,malloc_error 
2c7d			;	endif 
2c7d			; 
2c7d			;	if DEBUG_FORTH_WORDS 
2c7d			;		DMARK "Lt2" 
2c7d			;		CALLMONITOR 
2c7d			;	endif 
2c7d			;		pop de 
2c7d			;		push hl    ; push the malloc to release later 
2c7d			;		push hl   ;  push back a copy for the later stack push 
2c7d			;		 
2c7d			;; copy the string swapping out the zero terms for spaces 
2c7d			; 
2c7d			;		; de has our source 
2c7d			;		; hl has our dest 
2c7d			; 
2c7d			;; add the coln def 
2c7d			; 
2c7d			;		ld a, ':' 
2c7d			;		ld (hl), a 
2c7d			;		inc hl 
2c7d			;		ld a, ' ' 
2c7d			;		ld (hl), a 
2c7d			;		inc hl 
2c7d			; 
2c7d			;; add the uname word 
2c7d			;		push de   ; save our string for now 
2c7d			;		ex de, hl 
2c7d			; 
2c7d			;		FORTH_DSP_VALUE 
2c7d			;		;v5 FORTH_DSP_VALUE 
2c7d			; 
2c7d			;		inc hl   ; skip type but we know by now this is OK 
2c7d			; 
2c7d			;.luword:	ld a,(hl) 
2c7d			;		cp 0 
2c7d			;		jr z, .luword2 
2c7d			;		ld (de), a 
2c7d			;		inc de 
2c7d			;		inc hl 
2c7d			;		jr .luword 
2c7d			; 
2c7d			;.luword2:	ld a, ' ' 
2c7d			;		ld (de), a 
2c7d			;;		inc hl 
2c7d			;;		inc de 
2c7d			;;		ld (de), a 
2c7d			;;		inc hl 
2c7d			;		inc de 
2c7d			; 
2c7d			;		ex de, hl 
2c7d			;		pop de 
2c7d			;		 
2c7d			;		 
2c7d			; 
2c7d			;; detoken that string and copy it 
2c7d			; 
2c7d			;	if DEBUG_FORTH_WORDS 
2c7d			;		DMARK "Lt2" 
2c7d			;		CALLMONITOR 
2c7d			;	endif 
2c7d			;.ldetok:	ld a, (de) 
2c7d			;		cp FORTH_END_BUFFER 
2c7d			;		jr z, .ldetokend 
2c7d			;		; swap out any zero term for space 
2c7d			;		cp 0 
2c7d			;		jr nz, .ldetoknext 
2c7d			;		ld a, ' ' 
2c7d			; 
2c7d			;	if DEBUG_FORTH_WORDS 
2c7d			;		DMARK "LtS" 
2c7d			;		CALLMONITOR 
2c7d			;	endif 
2c7d			;.ldetoknext:	ld (hl), a 
2c7d			;		inc de 
2c7d			;		inc hl 
2c7d			;		jr .ldetok 
2c7d			; 
2c7d			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2c7d			;		ld (hl), a  
2c7d			; 
2c7d			;; free that temp malloc 
2c7d			; 
2c7d			;		pop hl    
2c7d			; 
2c7d			;	if DEBUG_FORTH_WORDS 
2c7d			;		DMARK "Lt4" 
2c7d			;		CALLMONITOR 
2c7d			;	endif 
2c7d			;		call forth_apushstrhl 
2c7d			; 
2c7d			;		; get rid of temp malloc area 
2c7d			; 
2c7d			;		pop hl 
2c7d			;		call free 
2c7d			; 
2c7d			;		jr .ludone 
2c7d			; 
2c7d			;.lnuword:	pop hl 
2c7d			;		call forth_tok_next 
2c7d			;		jp .ldouscan  
2c7d			; 
2c7d			;.ludone:		 pop hl 
2c7d			; 
2c7d					NEXTW 
2c7d c3 47 21			jp macro_next 
2c80				endm 
# End of macro NEXTW
2c80			 
2c80			.FORGET: 
2c80				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2c80 5d				db WORD_SYS_CORE+73             
2c81 f9 2c			dw .NOP            
2c83 07				db 6 + 1 
2c84 .. 00			db "FORGET",0              
2c8b				endm 
# End of macro CWHEAD
2c8b			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2c8b			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2c8b			; | |  
2c8b			; | | e.g. "MORE" forget 
2c8b					if DEBUG_FORTH_WORDS_KEY 
2c8b						DMARK "FRG" 
2c8b f5				push af  
2c8c 3a a0 2c			ld a, (.dmark)  
2c8f 32 b4 fe			ld (debug_mark),a  
2c92 3a a1 2c			ld a, (.dmark+1)  
2c95 32 b5 fe			ld (debug_mark+1),a  
2c98 3a a2 2c			ld a, (.dmark+2)  
2c9b 32 b6 fe			ld (debug_mark+2),a  
2c9e 18 03			jr .pastdmark  
2ca0 ..			.dmark: db "FRG"  
2ca3 f1			.pastdmark: pop af  
2ca4			endm  
# End of macro DMARK
2ca4						CALLMONITOR 
2ca4 cd 70 17			call break_point_state  
2ca7				endm  
# End of macro CALLMONITOR
2ca7					endif 
2ca7			 
2ca7				; find uword 
2ca7			        ; update start of word with "_" 
2ca7				; replace uword with deleted flag 
2ca7			 
2ca7			 
2ca7			;	if DEBUG_FORTH_WORDS 
2ca7			;		DMARK "FOG" 
2ca7			;		CALLMONITOR 
2ca7			;	endif 
2ca7			 
2ca7			 
2ca7					; Get ptr to the word we need to look up 
2ca7			 
2ca7					FORTH_DSP_VALUEHL 
2ca7 cd d5 1f			call macro_dsp_valuehl 
2caa				endm 
# End of macro FORTH_DSP_VALUEHL
2caa					;v5 FORTH_DSP_VALUE 
2caa				; TODO type check 
2caa			;		inc hl    ; Skip type check  
2caa e5					push hl 
2cab c1					pop bc 
2cac			;		ex de, hl    ; put into DE 
2cac			 
2cac			 
2cac 21 00 80				ld hl, baseram 
2caf					;ld hl, baseusermem 
2caf			 
2caf				; skip dict stub 
2caf			;	call forth_tok_next 
2caf e5			push hl   ; sacreifical push 
2cb0			 
2cb0			.fldouscanm: 
2cb0 e1				pop hl 
2cb1			.fldouscan: 
2cb1			;	if DEBUG_FORTH_WORDS 
2cb1			;		DMARK "LSs" 
2cb1			;		CALLMONITOR 
2cb1			;	endif 
2cb1				; skip dict stub 
2cb1 cd 98 22				call forth_tok_next 
2cb4			 
2cb4			 
2cb4			; while we have words to look for 
2cb4			 
2cb4 7e				ld a, (hl)      
2cb5			;	if DEBUG_FORTH_WORDS 
2cb5			;		DMARK "LSk" 
2cb5			;		CALLMONITOR 
2cb5			;	endif 
2cb5 fe 00				cp WORD_SYS_END 
2cb7 ca f3 2c				jp z, .flunotfound 
2cba fe 01				cp WORD_SYS_UWORD 
2cbc c2 b1 2c				jp nz, .fldouscan 
2cbf			 
2cbf			;	if DEBUG_FORTH_WORDS 
2cbf			;		DMARK "LSu" 
2cbf			;		CALLMONITOR 
2cbf			;	endif 
2cbf			 
2cbf					; found a uword but is it the one we want... 
2cbf			 
2cbf c5					push bc     ; uword to find is on bc 
2cc0 d1					pop de 
2cc1			 
2cc1 e5					push hl  ; to save the ptr 
2cc2			 
2cc2					; skip opcode 
2cc2 23					inc hl  
2cc3					; skip next ptr 
2cc3 23					inc hl  
2cc4 23					inc hl 
2cc5					; skip len 
2cc5 23					inc hl 
2cc6			 
2cc6			;	if DEBUG_FORTH_WORDS 
2cc6			;		DMARK "LSc" 
2cc6			;		CALLMONITOR 
2cc6			;	endif 
2cc6 cd 89 12				call strcmp 
2cc9 c2 b0 2c				jp nz, .fldouscanm 
2ccc			; 
2ccc			; 
2ccc			;; while we have words to look for 
2ccc			; 
2ccc			;.fdouscan:	ld a, (hl)      
2ccc			;	if DEBUG_FORTH_WORDS 
2ccc			;		DMARK "LSs" 
2ccc			;		CALLMONITOR 
2ccc			;	endif 
2ccc			;		cp WORD_SYS_END 
2ccc			;		jp z, .fudone 
2ccc			;		cp WORD_SYS_UWORD 
2ccc			;		jp nz, .fnuword 
2ccc			; 
2ccc			;	if DEBUG_FORTH_WORDS 
2ccc			;		DMARK "FGu" 
2ccc			;		CALLMONITOR 
2ccc			;	endif 
2ccc			; 
2ccc			;		; found a uword but is it the one we want... 
2ccc			; 
2ccc			; 
2ccc			;	        pop de   ; get back the dsp name 
2ccc			;		push de 
2ccc			; 
2ccc			;		push hl  ; to save the ptr 
2ccc			; 
2ccc			;		; skip opcode 
2ccc			;		inc hl  
2ccc			;		; skip next ptr 
2ccc			;		inc hl  
2ccc			;		inc hl 
2ccc			;		; skip len 
2ccc			;		inc hl 
2ccc			; 
2ccc			;	if DEBUG_FORTH_WORDS 
2ccc			;		DMARK "FGc" 
2ccc			;		CALLMONITOR 
2ccc			;	endif 
2ccc			;		call strcmp 
2ccc			;		jp nz, .fnuword 
2ccc			 
2ccc			 
2ccc e1			pop hl 
2ccd			 
2ccd				 
2ccd				if DEBUG_FORTH_WORDS 
2ccd					DMARK "FGm" 
2ccd f5				push af  
2cce 3a e2 2c			ld a, (.dmark)  
2cd1 32 b4 fe			ld (debug_mark),a  
2cd4 3a e3 2c			ld a, (.dmark+1)  
2cd7 32 b5 fe			ld (debug_mark+1),a  
2cda 3a e4 2c			ld a, (.dmark+2)  
2cdd 32 b6 fe			ld (debug_mark+2),a  
2ce0 18 03			jr .pastdmark  
2ce2 ..			.dmark: db "FGm"  
2ce5 f1			.pastdmark: pop af  
2ce6			endm  
# End of macro DMARK
2ce6					CALLMONITOR 
2ce6 cd 70 17			call break_point_state  
2ce9				endm  
# End of macro CALLMONITOR
2ce9				endif 
2ce9			 
2ce9			 
2ce9			 
2ce9					; we have a uword so push its name to the stack 
2ce9			 
2ce9			;	   	push hl  ; save so we can move to next dict block 
2ce9			;pop hl 
2ce9			 
2ce9					; update opcode to deleted 
2ce9 3e 03				ld a, WORD_SYS_DELETED 
2ceb 77					ld (hl), a 
2cec			 
2cec 23					inc hl  
2ced					; skip next ptr 
2ced 23					inc hl  
2cee 23					inc hl 
2cef					; skip len 
2cef 23					inc hl 
2cf0			 
2cf0					; TODO change parser to skip deleted words but for now mark it out 
2cf0 3e 5f				ld a, "_" 
2cf2 77					ld  (hl),a 
2cf3			 
2cf3			;		jr .fudone 
2cf3			; 
2cf3			;.fnuword:	pop hl 
2cf3			;		call forth_tok_next 
2cf3			;		jp .fdouscan  
2cf3			 
2cf3			.flunotfound:		  
2cf3			 
2cf3			 
2cf3					 
2cf3					FORTH_DSP_POP 
2cf3 cd 8d 20			call macro_forth_dsp_pop 
2cf6				endm 
# End of macro FORTH_DSP_POP
2cf6			;		ld hl, .luno 
2cf6			;.fudone:		 pop hl 
2cf6					NEXTW 
2cf6 c3 47 21			jp macro_next 
2cf9				endm 
# End of macro NEXTW
2cf9			.NOP: 
2cf9				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2cf9 61				db WORD_SYS_CORE+77             
2cfa 20 2d			dw .COMO            
2cfc 04				db 3 + 1 
2cfd .. 00			db "NOP",0              
2d01				endm 
# End of macro CWHEAD
2d01			; | NOP (  --  ) Do nothing | DONE 
2d01					if DEBUG_FORTH_WORDS_KEY 
2d01						DMARK "NOP" 
2d01 f5				push af  
2d02 3a 16 2d			ld a, (.dmark)  
2d05 32 b4 fe			ld (debug_mark),a  
2d08 3a 17 2d			ld a, (.dmark+1)  
2d0b 32 b5 fe			ld (debug_mark+1),a  
2d0e 3a 18 2d			ld a, (.dmark+2)  
2d11 32 b6 fe			ld (debug_mark+2),a  
2d14 18 03			jr .pastdmark  
2d16 ..			.dmark: db "NOP"  
2d19 f1			.pastdmark: pop af  
2d1a			endm  
# End of macro DMARK
2d1a						CALLMONITOR 
2d1a cd 70 17			call break_point_state  
2d1d				endm  
# End of macro CALLMONITOR
2d1d					endif 
2d1d				       NEXTW 
2d1d c3 47 21			jp macro_next 
2d20				endm 
# End of macro NEXTW
2d20			.COMO: 
2d20				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2d20 6e				db WORD_SYS_CORE+90             
2d21 72 2d			dw .COMC            
2d23 02				db 1 + 1 
2d24 .. 00			db "(",0              
2d26				endm 
# End of macro CWHEAD
2d26			; | ( ( -- )  Start of comment | DONE 
2d26			 
2d26			 
2d26 2a 5b f7				ld hl, ( os_tok_ptr) 
2d29 11 6d 2d			ld de, .closepar 
2d2c					 
2d2c					if DEBUG_FORTH_WORDS 
2d2c						DMARK ").." 
2d2c f5				push af  
2d2d 3a 41 2d			ld a, (.dmark)  
2d30 32 b4 fe			ld (debug_mark),a  
2d33 3a 42 2d			ld a, (.dmark+1)  
2d36 32 b5 fe			ld (debug_mark+1),a  
2d39 3a 43 2d			ld a, (.dmark+2)  
2d3c 32 b6 fe			ld (debug_mark+2),a  
2d3f 18 03			jr .pastdmark  
2d41 ..			.dmark: db ").."  
2d44 f1			.pastdmark: pop af  
2d45			endm  
# End of macro DMARK
2d45						CALLMONITOR 
2d45 cd 70 17			call break_point_state  
2d48				endm  
# End of macro CALLMONITOR
2d48					endif 
2d48 cd 62 22			call findnexttok  
2d4b			 
2d4b					if DEBUG_FORTH_WORDS 
2d4b						DMARK "IF5" 
2d4b f5				push af  
2d4c 3a 60 2d			ld a, (.dmark)  
2d4f 32 b4 fe			ld (debug_mark),a  
2d52 3a 61 2d			ld a, (.dmark+1)  
2d55 32 b5 fe			ld (debug_mark+1),a  
2d58 3a 62 2d			ld a, (.dmark+2)  
2d5b 32 b6 fe			ld (debug_mark+2),a  
2d5e 18 03			jr .pastdmark  
2d60 ..			.dmark: db "IF5"  
2d63 f1			.pastdmark: pop af  
2d64			endm  
# End of macro DMARK
2d64						CALLMONITOR 
2d64 cd 70 17			call break_point_state  
2d67				endm  
# End of macro CALLMONITOR
2d67					endif 
2d67				; replace below with ) exec using tok_ptr 
2d67 22 5b f7			ld (os_tok_ptr), hl 
2d6a c3 d8 21			jp exec1 
2d6d			 
2d6d .. 00			.closepar:   db ")",0 
2d6f			 
2d6f				       NEXTW 
2d6f c3 47 21			jp macro_next 
2d72				endm 
# End of macro NEXTW
2d72			.COMC: 
2d72				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2d72 6f				db WORD_SYS_CORE+91             
2d73 7b 2d			dw .SCRATCH            
2d75 02				db 1 + 1 
2d76 .. 00			db ")",0              
2d78				endm 
# End of macro CWHEAD
2d78			; | ) ( -- )  End of comment |  DONE  
2d78				       NEXTW 
2d78 c3 47 21			jp macro_next 
2d7b				endm 
# End of macro NEXTW
2d7b			 
2d7b			.SCRATCH: 
2d7b				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2d7b 6f				db WORD_SYS_CORE+91             
2d7c b6 2d			dw .INC            
2d7e 08				db 7 + 1 
2d7f .. 00			db "SCRATCH",0              
2d87				endm 
# End of macro CWHEAD
2d87			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2d87			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2d87			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2d87			; | |  
2d87			; | | e.g.    : score $00 scratch ; 
2d87			; | |  
2d87			; | | $00 score ! 
2d87			; | | $01 score +! 
2d87			; | |  
2d87			; | | e.g.   : varword $0a scratch ;  
2d87			; | | 
2d87			; | | $8000 varword ! 
2d87					if DEBUG_FORTH_WORDS_KEY 
2d87						DMARK "SCR" 
2d87 f5				push af  
2d88 3a 9c 2d			ld a, (.dmark)  
2d8b 32 b4 fe			ld (debug_mark),a  
2d8e 3a 9d 2d			ld a, (.dmark+1)  
2d91 32 b5 fe			ld (debug_mark+1),a  
2d94 3a 9e 2d			ld a, (.dmark+2)  
2d97 32 b6 fe			ld (debug_mark+2),a  
2d9a 18 03			jr .pastdmark  
2d9c ..			.dmark: db "SCR"  
2d9f f1			.pastdmark: pop af  
2da0			endm  
# End of macro DMARK
2da0						CALLMONITOR 
2da0 cd 70 17			call break_point_state  
2da3				endm  
# End of macro CALLMONITOR
2da3					endif 
2da3			 
2da3					FORTH_DSP_VALUEHL 
2da3 cd d5 1f			call macro_dsp_valuehl 
2da6				endm 
# End of macro FORTH_DSP_VALUEHL
2da6				 
2da6					FORTH_DSP_POP 
2da6 cd 8d 20			call macro_forth_dsp_pop 
2da9				endm 
# End of macro FORTH_DSP_POP
2da9			 
2da9 7d					ld a, l 
2daa 21 7f f9				ld hl, os_var_array 
2dad cd f3 0d				call addatohl 
2db0			 
2db0 cd de 1d				call forth_push_numhl 
2db3			 
2db3				       NEXTW 
2db3 c3 47 21			jp macro_next 
2db6				endm 
# End of macro NEXTW
2db6			 
2db6			.INC: 
2db6				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2db6 6f				db WORD_SYS_CORE+91             
2db7 0a 2e			dw .DEC            
2db9 03				db 2 + 1 
2dba .. 00			db "+!",0              
2dbd				endm 
# End of macro CWHEAD
2dbd			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2dbd					if DEBUG_FORTH_WORDS_KEY 
2dbd						DMARK "+s_" 
2dbd f5				push af  
2dbe 3a d2 2d			ld a, (.dmark)  
2dc1 32 b4 fe			ld (debug_mark),a  
2dc4 3a d3 2d			ld a, (.dmark+1)  
2dc7 32 b5 fe			ld (debug_mark+1),a  
2dca 3a d4 2d			ld a, (.dmark+2)  
2dcd 32 b6 fe			ld (debug_mark+2),a  
2dd0 18 03			jr .pastdmark  
2dd2 ..			.dmark: db "+s_"  
2dd5 f1			.pastdmark: pop af  
2dd6			endm  
# End of macro DMARK
2dd6						CALLMONITOR 
2dd6 cd 70 17			call break_point_state  
2dd9				endm  
# End of macro CALLMONITOR
2dd9					endif 
2dd9			 
2dd9					FORTH_DSP_VALUEHL 
2dd9 cd d5 1f			call macro_dsp_valuehl 
2ddc				endm 
# End of macro FORTH_DSP_VALUEHL
2ddc			 
2ddc e5					push hl   ; save address 
2ddd			 
2ddd					FORTH_DSP_POP 
2ddd cd 8d 20			call macro_forth_dsp_pop 
2de0				endm 
# End of macro FORTH_DSP_POP
2de0			 
2de0					FORTH_DSP_VALUEHL 
2de0 cd d5 1f			call macro_dsp_valuehl 
2de3				endm 
# End of macro FORTH_DSP_VALUEHL
2de3			 
2de3					FORTH_DSP_POP 
2de3 cd 8d 20			call macro_forth_dsp_pop 
2de6				endm 
# End of macro FORTH_DSP_POP
2de6			 
2de6					; hl contains value to add to byte at a 
2de6				 
2de6 eb					ex de, hl 
2de7			 
2de7 e1					pop hl 
2de8			 
2de8					if DEBUG_FORTH_WORDS 
2de8						DMARK "INC" 
2de8 f5				push af  
2de9 3a fd 2d			ld a, (.dmark)  
2dec 32 b4 fe			ld (debug_mark),a  
2def 3a fe 2d			ld a, (.dmark+1)  
2df2 32 b5 fe			ld (debug_mark+1),a  
2df5 3a ff 2d			ld a, (.dmark+2)  
2df8 32 b6 fe			ld (debug_mark+2),a  
2dfb 18 03			jr .pastdmark  
2dfd ..			.dmark: db "INC"  
2e00 f1			.pastdmark: pop af  
2e01			endm  
# End of macro DMARK
2e01						CALLMONITOR 
2e01 cd 70 17			call break_point_state  
2e04				endm  
# End of macro CALLMONITOR
2e04					endif 
2e04			 
2e04 7e					ld a,(hl) 
2e05 83					add e 
2e06 77					ld (hl),a 
2e07			 
2e07			 
2e07			 
2e07				       NEXTW 
2e07 c3 47 21			jp macro_next 
2e0a				endm 
# End of macro NEXTW
2e0a			 
2e0a			.DEC: 
2e0a				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2e0a 6f				db WORD_SYS_CORE+91             
2e0b 5b 2e			dw .INC2            
2e0d 03				db 2 + 1 
2e0e .. 00			db "-!",0              
2e11				endm 
# End of macro CWHEAD
2e11			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2e11					if DEBUG_FORTH_WORDS_KEY 
2e11						DMARK "-s_" 
2e11 f5				push af  
2e12 3a 26 2e			ld a, (.dmark)  
2e15 32 b4 fe			ld (debug_mark),a  
2e18 3a 27 2e			ld a, (.dmark+1)  
2e1b 32 b5 fe			ld (debug_mark+1),a  
2e1e 3a 28 2e			ld a, (.dmark+2)  
2e21 32 b6 fe			ld (debug_mark+2),a  
2e24 18 03			jr .pastdmark  
2e26 ..			.dmark: db "-s_"  
2e29 f1			.pastdmark: pop af  
2e2a			endm  
# End of macro DMARK
2e2a						CALLMONITOR 
2e2a cd 70 17			call break_point_state  
2e2d				endm  
# End of macro CALLMONITOR
2e2d					endif 
2e2d			 
2e2d					FORTH_DSP_VALUEHL 
2e2d cd d5 1f			call macro_dsp_valuehl 
2e30				endm 
# End of macro FORTH_DSP_VALUEHL
2e30			 
2e30 e5					push hl   ; save address 
2e31			 
2e31					FORTH_DSP_POP 
2e31 cd 8d 20			call macro_forth_dsp_pop 
2e34				endm 
# End of macro FORTH_DSP_POP
2e34			 
2e34					FORTH_DSP_VALUEHL 
2e34 cd d5 1f			call macro_dsp_valuehl 
2e37				endm 
# End of macro FORTH_DSP_VALUEHL
2e37			 
2e37					; hl contains value to add to byte at a 
2e37				 
2e37 eb					ex de, hl 
2e38			 
2e38 e1					pop hl 
2e39			 
2e39					if DEBUG_FORTH_WORDS 
2e39						DMARK "DEC" 
2e39 f5				push af  
2e3a 3a 4e 2e			ld a, (.dmark)  
2e3d 32 b4 fe			ld (debug_mark),a  
2e40 3a 4f 2e			ld a, (.dmark+1)  
2e43 32 b5 fe			ld (debug_mark+1),a  
2e46 3a 50 2e			ld a, (.dmark+2)  
2e49 32 b6 fe			ld (debug_mark+2),a  
2e4c 18 03			jr .pastdmark  
2e4e ..			.dmark: db "DEC"  
2e51 f1			.pastdmark: pop af  
2e52			endm  
# End of macro DMARK
2e52						CALLMONITOR 
2e52 cd 70 17			call break_point_state  
2e55				endm  
# End of macro CALLMONITOR
2e55					endif 
2e55			 
2e55 7e					ld a,(hl) 
2e56 93					sub e 
2e57 77					ld (hl),a 
2e58			 
2e58			 
2e58			 
2e58				       NEXTW 
2e58 c3 47 21			jp macro_next 
2e5b				endm 
# End of macro NEXTW
2e5b			 
2e5b			.INC2: 
2e5b				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2e5b 6f				db WORD_SYS_CORE+91             
2e5c 05 2f			dw .DEC2            
2e5e 04				db 3 + 1 
2e5f .. 00			db "+2!",0              
2e63				endm 
# End of macro CWHEAD
2e63			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2e63			 
2e63					if DEBUG_FORTH_WORDS_KEY 
2e63						DMARK "+2s" 
2e63 f5				push af  
2e64 3a 78 2e			ld a, (.dmark)  
2e67 32 b4 fe			ld (debug_mark),a  
2e6a 3a 79 2e			ld a, (.dmark+1)  
2e6d 32 b5 fe			ld (debug_mark+1),a  
2e70 3a 7a 2e			ld a, (.dmark+2)  
2e73 32 b6 fe			ld (debug_mark+2),a  
2e76 18 03			jr .pastdmark  
2e78 ..			.dmark: db "+2s"  
2e7b f1			.pastdmark: pop af  
2e7c			endm  
# End of macro DMARK
2e7c						CALLMONITOR 
2e7c cd 70 17			call break_point_state  
2e7f				endm  
# End of macro CALLMONITOR
2e7f					endif 
2e7f			 
2e7f					; Address 
2e7f			 
2e7f					FORTH_DSP_VALUEHL 
2e7f cd d5 1f			call macro_dsp_valuehl 
2e82				endm 
# End of macro FORTH_DSP_VALUEHL
2e82			 
2e82 e5					push hl    ; save address 
2e83			 
2e83					; load content into de 
2e83			 
2e83 5e					ld e,(hl) 
2e84 23					inc hl 
2e85 56					ld d, (hl) 
2e86			 
2e86					if DEBUG_FORTH_WORDS 
2e86						DMARK "+2a" 
2e86 f5				push af  
2e87 3a 9b 2e			ld a, (.dmark)  
2e8a 32 b4 fe			ld (debug_mark),a  
2e8d 3a 9c 2e			ld a, (.dmark+1)  
2e90 32 b5 fe			ld (debug_mark+1),a  
2e93 3a 9d 2e			ld a, (.dmark+2)  
2e96 32 b6 fe			ld (debug_mark+2),a  
2e99 18 03			jr .pastdmark  
2e9b ..			.dmark: db "+2a"  
2e9e f1			.pastdmark: pop af  
2e9f			endm  
# End of macro DMARK
2e9f						CALLMONITOR 
2e9f cd 70 17			call break_point_state  
2ea2				endm  
# End of macro CALLMONITOR
2ea2					endif 
2ea2			 
2ea2					FORTH_DSP_POP 
2ea2 cd 8d 20			call macro_forth_dsp_pop 
2ea5				endm 
# End of macro FORTH_DSP_POP
2ea5			 
2ea5					; Get value to add 
2ea5			 
2ea5					FORTH_DSP_VALUE 
2ea5 cd be 1f			call macro_forth_dsp_value 
2ea8				endm 
# End of macro FORTH_DSP_VALUE
2ea8			 
2ea8					if DEBUG_FORTH_WORDS 
2ea8						DMARK "+2v" 
2ea8 f5				push af  
2ea9 3a bd 2e			ld a, (.dmark)  
2eac 32 b4 fe			ld (debug_mark),a  
2eaf 3a be 2e			ld a, (.dmark+1)  
2eb2 32 b5 fe			ld (debug_mark+1),a  
2eb5 3a bf 2e			ld a, (.dmark+2)  
2eb8 32 b6 fe			ld (debug_mark+2),a  
2ebb 18 03			jr .pastdmark  
2ebd ..			.dmark: db "+2v"  
2ec0 f1			.pastdmark: pop af  
2ec1			endm  
# End of macro DMARK
2ec1						CALLMONITOR 
2ec1 cd 70 17			call break_point_state  
2ec4				endm  
# End of macro CALLMONITOR
2ec4					endif 
2ec4			 
2ec4 19					add hl, de 
2ec5			 
2ec5					if DEBUG_FORTH_WORDS 
2ec5						DMARK "+2+" 
2ec5 f5				push af  
2ec6 3a da 2e			ld a, (.dmark)  
2ec9 32 b4 fe			ld (debug_mark),a  
2ecc 3a db 2e			ld a, (.dmark+1)  
2ecf 32 b5 fe			ld (debug_mark+1),a  
2ed2 3a dc 2e			ld a, (.dmark+2)  
2ed5 32 b6 fe			ld (debug_mark+2),a  
2ed8 18 03			jr .pastdmark  
2eda ..			.dmark: db "+2+"  
2edd f1			.pastdmark: pop af  
2ede			endm  
# End of macro DMARK
2ede						CALLMONITOR 
2ede cd 70 17			call break_point_state  
2ee1				endm  
# End of macro CALLMONITOR
2ee1					endif 
2ee1			 
2ee1					; move result to de 
2ee1			 
2ee1 eb					ex de, hl 
2ee2			 
2ee2					; Address 
2ee2			 
2ee2 e1					pop hl 
2ee3			 
2ee3					; save it back 
2ee3			 
2ee3 73					ld (hl), e 
2ee4 23					inc hl 
2ee5 72					ld (hl), d 
2ee6			 
2ee6					if DEBUG_FORTH_WORDS 
2ee6						DMARK "+2e" 
2ee6 f5				push af  
2ee7 3a fb 2e			ld a, (.dmark)  
2eea 32 b4 fe			ld (debug_mark),a  
2eed 3a fc 2e			ld a, (.dmark+1)  
2ef0 32 b5 fe			ld (debug_mark+1),a  
2ef3 3a fd 2e			ld a, (.dmark+2)  
2ef6 32 b6 fe			ld (debug_mark+2),a  
2ef9 18 03			jr .pastdmark  
2efb ..			.dmark: db "+2e"  
2efe f1			.pastdmark: pop af  
2eff			endm  
# End of macro DMARK
2eff						CALLMONITOR 
2eff cd 70 17			call break_point_state  
2f02				endm  
# End of macro CALLMONITOR
2f02					endif 
2f02			 
2f02			 
2f02			 
2f02			 
2f02			 
2f02				       NEXTW 
2f02 c3 47 21			jp macro_next 
2f05				endm 
# End of macro NEXTW
2f05			 
2f05			.DEC2: 
2f05				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2f05 6f				db WORD_SYS_CORE+91             
2f06 b1 2f			dw .GET2            
2f08 04				db 3 + 1 
2f09 .. 00			db "-2!",0              
2f0d				endm 
# End of macro CWHEAD
2f0d			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2f0d			 
2f0d			 
2f0d					if DEBUG_FORTH_WORDS_KEY 
2f0d						DMARK "-2s" 
2f0d f5				push af  
2f0e 3a 22 2f			ld a, (.dmark)  
2f11 32 b4 fe			ld (debug_mark),a  
2f14 3a 23 2f			ld a, (.dmark+1)  
2f17 32 b5 fe			ld (debug_mark+1),a  
2f1a 3a 24 2f			ld a, (.dmark+2)  
2f1d 32 b6 fe			ld (debug_mark+2),a  
2f20 18 03			jr .pastdmark  
2f22 ..			.dmark: db "-2s"  
2f25 f1			.pastdmark: pop af  
2f26			endm  
# End of macro DMARK
2f26						CALLMONITOR 
2f26 cd 70 17			call break_point_state  
2f29				endm  
# End of macro CALLMONITOR
2f29					endif 
2f29			 
2f29					; Address 
2f29			 
2f29					FORTH_DSP_VALUEHL 
2f29 cd d5 1f			call macro_dsp_valuehl 
2f2c				endm 
# End of macro FORTH_DSP_VALUEHL
2f2c			 
2f2c e5					push hl    ; save address 
2f2d			 
2f2d					; load content into de 
2f2d			 
2f2d 5e					ld e,(hl) 
2f2e 23					inc hl 
2f2f 56					ld d, (hl) 
2f30			 
2f30					if DEBUG_FORTH_WORDS 
2f30						DMARK "-2a" 
2f30 f5				push af  
2f31 3a 45 2f			ld a, (.dmark)  
2f34 32 b4 fe			ld (debug_mark),a  
2f37 3a 46 2f			ld a, (.dmark+1)  
2f3a 32 b5 fe			ld (debug_mark+1),a  
2f3d 3a 47 2f			ld a, (.dmark+2)  
2f40 32 b6 fe			ld (debug_mark+2),a  
2f43 18 03			jr .pastdmark  
2f45 ..			.dmark: db "-2a"  
2f48 f1			.pastdmark: pop af  
2f49			endm  
# End of macro DMARK
2f49						CALLMONITOR 
2f49 cd 70 17			call break_point_state  
2f4c				endm  
# End of macro CALLMONITOR
2f4c					endif 
2f4c			 
2f4c					FORTH_DSP_POP 
2f4c cd 8d 20			call macro_forth_dsp_pop 
2f4f				endm 
# End of macro FORTH_DSP_POP
2f4f			 
2f4f					; Get value to remove 
2f4f			 
2f4f					FORTH_DSP_VALUE 
2f4f cd be 1f			call macro_forth_dsp_value 
2f52				endm 
# End of macro FORTH_DSP_VALUE
2f52			 
2f52					if DEBUG_FORTH_WORDS 
2f52						DMARK "-2v" 
2f52 f5				push af  
2f53 3a 67 2f			ld a, (.dmark)  
2f56 32 b4 fe			ld (debug_mark),a  
2f59 3a 68 2f			ld a, (.dmark+1)  
2f5c 32 b5 fe			ld (debug_mark+1),a  
2f5f 3a 69 2f			ld a, (.dmark+2)  
2f62 32 b6 fe			ld (debug_mark+2),a  
2f65 18 03			jr .pastdmark  
2f67 ..			.dmark: db "-2v"  
2f6a f1			.pastdmark: pop af  
2f6b			endm  
# End of macro DMARK
2f6b						CALLMONITOR 
2f6b cd 70 17			call break_point_state  
2f6e				endm  
# End of macro CALLMONITOR
2f6e					endif 
2f6e			 
2f6e eb					ex de, hl 
2f6f ed 52				sbc hl, de 
2f71			 
2f71					if DEBUG_FORTH_WORDS 
2f71						DMARK "-2d" 
2f71 f5				push af  
2f72 3a 86 2f			ld a, (.dmark)  
2f75 32 b4 fe			ld (debug_mark),a  
2f78 3a 87 2f			ld a, (.dmark+1)  
2f7b 32 b5 fe			ld (debug_mark+1),a  
2f7e 3a 88 2f			ld a, (.dmark+2)  
2f81 32 b6 fe			ld (debug_mark+2),a  
2f84 18 03			jr .pastdmark  
2f86 ..			.dmark: db "-2d"  
2f89 f1			.pastdmark: pop af  
2f8a			endm  
# End of macro DMARK
2f8a						CALLMONITOR 
2f8a cd 70 17			call break_point_state  
2f8d				endm  
# End of macro CALLMONITOR
2f8d					endif 
2f8d			 
2f8d					; move result to de 
2f8d			 
2f8d eb					ex de, hl 
2f8e			 
2f8e					; Address 
2f8e			 
2f8e e1					pop hl 
2f8f			 
2f8f					; save it back 
2f8f			 
2f8f 73					ld (hl), e 
2f90 23					inc hl 
2f91 72					ld (hl), d 
2f92			 
2f92					if DEBUG_FORTH_WORDS 
2f92						DMARK "-2e" 
2f92 f5				push af  
2f93 3a a7 2f			ld a, (.dmark)  
2f96 32 b4 fe			ld (debug_mark),a  
2f99 3a a8 2f			ld a, (.dmark+1)  
2f9c 32 b5 fe			ld (debug_mark+1),a  
2f9f 3a a9 2f			ld a, (.dmark+2)  
2fa2 32 b6 fe			ld (debug_mark+2),a  
2fa5 18 03			jr .pastdmark  
2fa7 ..			.dmark: db "-2e"  
2faa f1			.pastdmark: pop af  
2fab			endm  
# End of macro DMARK
2fab						CALLMONITOR 
2fab cd 70 17			call break_point_state  
2fae				endm  
# End of macro CALLMONITOR
2fae					endif 
2fae			 
2fae			 
2fae			 
2fae			 
2fae			 
2fae				       NEXTW 
2fae c3 47 21			jp macro_next 
2fb1				endm 
# End of macro NEXTW
2fb1			.GET2: 
2fb1				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2fb1 6f				db WORD_SYS_CORE+91             
2fb2 e1 2f			dw .BANG2            
2fb4 03				db 2 + 1 
2fb5 .. 00			db "2@",0              
2fb8				endm 
# End of macro CWHEAD
2fb8			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2fb8					if DEBUG_FORTH_WORDS_KEY 
2fb8						DMARK "2A_" 
2fb8 f5				push af  
2fb9 3a cd 2f			ld a, (.dmark)  
2fbc 32 b4 fe			ld (debug_mark),a  
2fbf 3a ce 2f			ld a, (.dmark+1)  
2fc2 32 b5 fe			ld (debug_mark+1),a  
2fc5 3a cf 2f			ld a, (.dmark+2)  
2fc8 32 b6 fe			ld (debug_mark+2),a  
2fcb 18 03			jr .pastdmark  
2fcd ..			.dmark: db "2A_"  
2fd0 f1			.pastdmark: pop af  
2fd1			endm  
# End of macro DMARK
2fd1						CALLMONITOR 
2fd1 cd 70 17			call break_point_state  
2fd4				endm  
# End of macro CALLMONITOR
2fd4					endif 
2fd4			 
2fd4					FORTH_DSP_VALUEHL 
2fd4 cd d5 1f			call macro_dsp_valuehl 
2fd7				endm 
# End of macro FORTH_DSP_VALUEHL
2fd7			 
2fd7 5e					ld e, (hl) 
2fd8 23					inc hl 
2fd9 56					ld d, (hl) 
2fda			 
2fda eb					ex de, hl 
2fdb			 
2fdb cd de 1d				call forth_push_numhl 
2fde			 
2fde				       NEXTW 
2fde c3 47 21			jp macro_next 
2fe1				endm 
# End of macro NEXTW
2fe1			.BANG2: 
2fe1				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2fe1 6f				db WORD_SYS_CORE+91             
2fe2 19 30			dw .CONFIG            
2fe4 03				db 2 + 1 
2fe5 .. 00			db "2!",0              
2fe8				endm 
# End of macro CWHEAD
2fe8			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2fe8					if DEBUG_FORTH_WORDS_KEY 
2fe8						DMARK "2S_" 
2fe8 f5				push af  
2fe9 3a fd 2f			ld a, (.dmark)  
2fec 32 b4 fe			ld (debug_mark),a  
2fef 3a fe 2f			ld a, (.dmark+1)  
2ff2 32 b5 fe			ld (debug_mark+1),a  
2ff5 3a ff 2f			ld a, (.dmark+2)  
2ff8 32 b6 fe			ld (debug_mark+2),a  
2ffb 18 03			jr .pastdmark  
2ffd ..			.dmark: db "2S_"  
3000 f1			.pastdmark: pop af  
3001			endm  
# End of macro DMARK
3001						CALLMONITOR 
3001 cd 70 17			call break_point_state  
3004				endm  
# End of macro CALLMONITOR
3004					endif 
3004			 
3004					FORTH_DSP_VALUEHL 
3004 cd d5 1f			call macro_dsp_valuehl 
3007				endm 
# End of macro FORTH_DSP_VALUEHL
3007			 
3007 e5					push hl   ; save address 
3008			 
3008			 
3008					FORTH_DSP_POP 
3008 cd 8d 20			call macro_forth_dsp_pop 
300b				endm 
# End of macro FORTH_DSP_POP
300b			 
300b					 
300b					FORTH_DSP_VALUEHL 
300b cd d5 1f			call macro_dsp_valuehl 
300e				endm 
# End of macro FORTH_DSP_VALUEHL
300e			 
300e					FORTH_DSP_POP 
300e cd 8d 20			call macro_forth_dsp_pop 
3011				endm 
# End of macro FORTH_DSP_POP
3011			 
3011 eb					ex de, hl    ; value now in de 
3012			 
3012 e1					pop hl 
3013			 
3013 73					ld (hl), e 
3014			 
3014 23					inc hl 
3015			 
3015 72					ld (hl), d 
3016			 
3016			 
3016				       NEXTW 
3016 c3 47 21			jp macro_next 
3019				endm 
# End of macro NEXTW
3019			.CONFIG: 
3019				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
3019 6f				db WORD_SYS_CORE+91             
301a 2a 30			dw .ENDCORE            
301c 07				db 6 + 1 
301d .. 00			db "CONFIG",0              
3024				endm 
# End of macro CWHEAD
3024			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3024			 
3024 cd 53 14				call config 
3027					NEXTW 
3027 c3 47 21			jp macro_next 
302a				endm 
# End of macro NEXTW
302a			.ENDCORE: 
302a			 
302a			; eof 
302a			 
302a			 
# End of file forth_words_core.asm
302a			include "forth_words_flow.asm" 
302a			 
302a			; | ## Program Flow Words 
302a			 
302a			.IF: 
302a				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
302a 1e				db WORD_SYS_CORE+10             
302b 1f 31			dw .THEN            
302d 03				db 2 + 1 
302e .. 00			db "IF",0              
3031				endm 
# End of macro CWHEAD
3031			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
3031			; 
3031					if DEBUG_FORTH_WORDS_KEY 
3031						DMARK "IF." 
3031 f5				push af  
3032 3a 46 30			ld a, (.dmark)  
3035 32 b4 fe			ld (debug_mark),a  
3038 3a 47 30			ld a, (.dmark+1)  
303b 32 b5 fe			ld (debug_mark+1),a  
303e 3a 48 30			ld a, (.dmark+2)  
3041 32 b6 fe			ld (debug_mark+2),a  
3044 18 03			jr .pastdmark  
3046 ..			.dmark: db "IF."  
3049 f1			.pastdmark: pop af  
304a			endm  
# End of macro DMARK
304a						CALLMONITOR 
304a cd 70 17			call break_point_state  
304d				endm  
# End of macro CALLMONITOR
304d					endif 
304d			; eval TOS 
304d			 
304d				FORTH_DSP_VALUEHL 
304d cd d5 1f			call macro_dsp_valuehl 
3050				endm 
# End of macro FORTH_DSP_VALUEHL
3050			 
3050			;	push hl 
3050				FORTH_DSP_POP 
3050 cd 8d 20			call macro_forth_dsp_pop 
3053				endm 
# End of macro FORTH_DSP_POP
3053			;	pop hl 
3053			 
3053					if DEBUG_FORTH_WORDS 
3053						DMARK "IF1" 
3053 f5				push af  
3054 3a 68 30			ld a, (.dmark)  
3057 32 b4 fe			ld (debug_mark),a  
305a 3a 69 30			ld a, (.dmark+1)  
305d 32 b5 fe			ld (debug_mark+1),a  
3060 3a 6a 30			ld a, (.dmark+2)  
3063 32 b6 fe			ld (debug_mark+2),a  
3066 18 03			jr .pastdmark  
3068 ..			.dmark: db "IF1"  
306b f1			.pastdmark: pop af  
306c			endm  
# End of macro DMARK
306c						CALLMONITOR 
306c cd 70 17			call break_point_state  
306f				endm  
# End of macro CALLMONITOR
306f					endif 
306f b7				or a        ; clear carry flag 
3070 11 00 00			ld de, 0 
3073 eb				ex de,hl 
3074 ed 52			sbc hl, de 
3076 c2 00 31			jp nz, .iftrue 
3079			 
3079					if DEBUG_FORTH_WORDS 
3079						DMARK "IF2" 
3079 f5				push af  
307a 3a 8e 30			ld a, (.dmark)  
307d 32 b4 fe			ld (debug_mark),a  
3080 3a 8f 30			ld a, (.dmark+1)  
3083 32 b5 fe			ld (debug_mark+1),a  
3086 3a 90 30			ld a, (.dmark+2)  
3089 32 b6 fe			ld (debug_mark+2),a  
308c 18 03			jr .pastdmark  
308e ..			.dmark: db "IF2"  
3091 f1			.pastdmark: pop af  
3092			endm  
# End of macro DMARK
3092						CALLMONITOR 
3092 cd 70 17			call break_point_state  
3095				endm  
# End of macro CALLMONITOR
3095					endif 
3095			 
3095			; if not true then skip to THEN 
3095			 
3095				; TODO get tok_ptr 
3095				; TODO consume toks until we get to THEN 
3095			 
3095 2a 5b f7			ld hl, (os_tok_ptr) 
3098					if DEBUG_FORTH_WORDS 
3098						DMARK "IF3" 
3098 f5				push af  
3099 3a ad 30			ld a, (.dmark)  
309c 32 b4 fe			ld (debug_mark),a  
309f 3a ae 30			ld a, (.dmark+1)  
30a2 32 b5 fe			ld (debug_mark+1),a  
30a5 3a af 30			ld a, (.dmark+2)  
30a8 32 b6 fe			ld (debug_mark+2),a  
30ab 18 03			jr .pastdmark  
30ad ..			.dmark: db "IF3"  
30b0 f1			.pastdmark: pop af  
30b1			endm  
# End of macro DMARK
30b1						CALLMONITOR 
30b1 cd 70 17			call break_point_state  
30b4				endm  
# End of macro CALLMONITOR
30b4						 
30b4					endif 
30b4 11 fb 30			ld de, .ifthen 
30b7					if DEBUG_FORTH_WORDS 
30b7						DMARK "IF4" 
30b7 f5				push af  
30b8 3a cc 30			ld a, (.dmark)  
30bb 32 b4 fe			ld (debug_mark),a  
30be 3a cd 30			ld a, (.dmark+1)  
30c1 32 b5 fe			ld (debug_mark+1),a  
30c4 3a ce 30			ld a, (.dmark+2)  
30c7 32 b6 fe			ld (debug_mark+2),a  
30ca 18 03			jr .pastdmark  
30cc ..			.dmark: db "IF4"  
30cf f1			.pastdmark: pop af  
30d0			endm  
# End of macro DMARK
30d0						CALLMONITOR 
30d0 cd 70 17			call break_point_state  
30d3				endm  
# End of macro CALLMONITOR
30d3					endif 
30d3 cd 62 22			call findnexttok  
30d6			 
30d6					if DEBUG_FORTH_WORDS 
30d6						DMARK "IF5" 
30d6 f5				push af  
30d7 3a eb 30			ld a, (.dmark)  
30da 32 b4 fe			ld (debug_mark),a  
30dd 3a ec 30			ld a, (.dmark+1)  
30e0 32 b5 fe			ld (debug_mark+1),a  
30e3 3a ed 30			ld a, (.dmark+2)  
30e6 32 b6 fe			ld (debug_mark+2),a  
30e9 18 03			jr .pastdmark  
30eb ..			.dmark: db "IF5"  
30ee f1			.pastdmark: pop af  
30ef			endm  
# End of macro DMARK
30ef						CALLMONITOR 
30ef cd 70 17			call break_point_state  
30f2				endm  
# End of macro CALLMONITOR
30f2					endif 
30f2				; TODO replace below with ; exec using tok_ptr 
30f2 22 5b f7			ld (os_tok_ptr), hl 
30f5 c3 d8 21			jp exec1 
30f8				NEXTW 
30f8 c3 47 21			jp macro_next 
30fb				endm 
# End of macro NEXTW
30fb			 
30fb .. 00		.ifthen:  db "THEN",0 
3100			 
3100			.iftrue:		 
3100				; Exec next words normally 
3100			 
3100				; if true then exec following IF as normal 
3100					if DEBUG_FORTH_WORDS 
3100						DMARK "IFT" 
3100 f5				push af  
3101 3a 15 31			ld a, (.dmark)  
3104 32 b4 fe			ld (debug_mark),a  
3107 3a 16 31			ld a, (.dmark+1)  
310a 32 b5 fe			ld (debug_mark+1),a  
310d 3a 17 31			ld a, (.dmark+2)  
3110 32 b6 fe			ld (debug_mark+2),a  
3113 18 03			jr .pastdmark  
3115 ..			.dmark: db "IFT"  
3118 f1			.pastdmark: pop af  
3119			endm  
# End of macro DMARK
3119						CALLMONITOR 
3119 cd 70 17			call break_point_state  
311c				endm  
# End of macro CALLMONITOR
311c					endif 
311c			 
311c					NEXTW 
311c c3 47 21			jp macro_next 
311f				endm 
# End of macro NEXTW
311f			.THEN: 
311f				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
311f 1f				db WORD_SYS_CORE+11             
3120 47 31			dw .ELSE            
3122 05				db 4 + 1 
3123 .. 00			db "THEN",0              
3128				endm 
# End of macro CWHEAD
3128			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3128					if DEBUG_FORTH_WORDS_KEY 
3128						DMARK "THN" 
3128 f5				push af  
3129 3a 3d 31			ld a, (.dmark)  
312c 32 b4 fe			ld (debug_mark),a  
312f 3a 3e 31			ld a, (.dmark+1)  
3132 32 b5 fe			ld (debug_mark+1),a  
3135 3a 3f 31			ld a, (.dmark+2)  
3138 32 b6 fe			ld (debug_mark+2),a  
313b 18 03			jr .pastdmark  
313d ..			.dmark: db "THN"  
3140 f1			.pastdmark: pop af  
3141			endm  
# End of macro DMARK
3141						CALLMONITOR 
3141 cd 70 17			call break_point_state  
3144				endm  
# End of macro CALLMONITOR
3144					endif 
3144					NEXTW 
3144 c3 47 21			jp macro_next 
3147				endm 
# End of macro NEXTW
3147			.ELSE: 
3147				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3147 20				db WORD_SYS_CORE+12             
3148 6f 31			dw .DO            
314a 03				db 2 + 1 
314b .. 00			db "ELSE",0              
3150				endm 
# End of macro CWHEAD
3150			; | ELSE ( -- ) Not supported - does nothing | TODO 
3150			 
3150					if DEBUG_FORTH_WORDS_KEY 
3150						DMARK "ELS" 
3150 f5				push af  
3151 3a 65 31			ld a, (.dmark)  
3154 32 b4 fe			ld (debug_mark),a  
3157 3a 66 31			ld a, (.dmark+1)  
315a 32 b5 fe			ld (debug_mark+1),a  
315d 3a 67 31			ld a, (.dmark+2)  
3160 32 b6 fe			ld (debug_mark+2),a  
3163 18 03			jr .pastdmark  
3165 ..			.dmark: db "ELS"  
3168 f1			.pastdmark: pop af  
3169			endm  
# End of macro DMARK
3169						CALLMONITOR 
3169 cd 70 17			call break_point_state  
316c				endm  
# End of macro CALLMONITOR
316c					endif 
316c			 
316c			 
316c					NEXTW 
316c c3 47 21			jp macro_next 
316f				endm 
# End of macro NEXTW
316f			.DO: 
316f				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
316f 21				db WORD_SYS_CORE+13             
3170 96 32			dw .LOOP            
3172 03				db 2 + 1 
3173 .. 00			db "DO",0              
3176				endm 
# End of macro CWHEAD
3176			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3176			 
3176					if DEBUG_FORTH_WORDS_KEY 
3176						DMARK "DO." 
3176 f5				push af  
3177 3a 8b 31			ld a, (.dmark)  
317a 32 b4 fe			ld (debug_mark),a  
317d 3a 8c 31			ld a, (.dmark+1)  
3180 32 b5 fe			ld (debug_mark+1),a  
3183 3a 8d 31			ld a, (.dmark+2)  
3186 32 b6 fe			ld (debug_mark+2),a  
3189 18 03			jr .pastdmark  
318b ..			.dmark: db "DO."  
318e f1			.pastdmark: pop af  
318f			endm  
# End of macro DMARK
318f						CALLMONITOR 
318f cd 70 17			call break_point_state  
3192				endm  
# End of macro CALLMONITOR
3192					endif 
3192			;  push pc to rsp stack past the DO 
3192			 
3192 2a 5b f7				ld hl, (os_tok_ptr) 
3195 23					inc hl   ; D 
3196 23					inc hl  ; O 
3197 23					inc hl   ; null 
3198					if DEBUG_FORTH_WORDS 
3198						DMARK "DO2" 
3198 f5				push af  
3199 3a ad 31			ld a, (.dmark)  
319c 32 b4 fe			ld (debug_mark),a  
319f 3a ae 31			ld a, (.dmark+1)  
31a2 32 b5 fe			ld (debug_mark+1),a  
31a5 3a af 31			ld a, (.dmark+2)  
31a8 32 b6 fe			ld (debug_mark+2),a  
31ab 18 03			jr .pastdmark  
31ad ..			.dmark: db "DO2"  
31b0 f1			.pastdmark: pop af  
31b1			endm  
# End of macro DMARK
31b1						CALLMONITOR 
31b1 cd 70 17			call break_point_state  
31b4				endm  
# End of macro CALLMONITOR
31b4					endif 
31b4					FORTH_RSP_NEXT 
31b4 cd 85 1d			call macro_forth_rsp_next 
31b7				endm 
# End of macro FORTH_RSP_NEXT
31b7					if DEBUG_FORTH_WORDS 
31b7						DMARK "DO3" 
31b7 f5				push af  
31b8 3a cc 31			ld a, (.dmark)  
31bb 32 b4 fe			ld (debug_mark),a  
31be 3a cd 31			ld a, (.dmark+1)  
31c1 32 b5 fe			ld (debug_mark+1),a  
31c4 3a ce 31			ld a, (.dmark+2)  
31c7 32 b6 fe			ld (debug_mark+2),a  
31ca 18 03			jr .pastdmark  
31cc ..			.dmark: db "DO3"  
31cf f1			.pastdmark: pop af  
31d0			endm  
# End of macro DMARK
31d0						CALLMONITOR 
31d0 cd 70 17			call break_point_state  
31d3				endm  
# End of macro CALLMONITOR
31d3					endif 
31d3			 
31d3					;if DEBUG_FORTH_WORDS 
31d3				;		push hl 
31d3			;		endif  
31d3			 
31d3			; get counters from data stack 
31d3			 
31d3			 
31d3					FORTH_DSP_VALUEHL 
31d3 cd d5 1f			call macro_dsp_valuehl 
31d6				endm 
# End of macro FORTH_DSP_VALUEHL
31d6 e5					push hl		 ; hl now has starting counter which needs to be tos 
31d7			 
31d7					if DEBUG_FORTH_WORDS 
31d7						DMARK "DO4" 
31d7 f5				push af  
31d8 3a ec 31			ld a, (.dmark)  
31db 32 b4 fe			ld (debug_mark),a  
31de 3a ed 31			ld a, (.dmark+1)  
31e1 32 b5 fe			ld (debug_mark+1),a  
31e4 3a ee 31			ld a, (.dmark+2)  
31e7 32 b6 fe			ld (debug_mark+2),a  
31ea 18 03			jr .pastdmark  
31ec ..			.dmark: db "DO4"  
31ef f1			.pastdmark: pop af  
31f0			endm  
# End of macro DMARK
31f0						CALLMONITOR 
31f0 cd 70 17			call break_point_state  
31f3				endm  
# End of macro CALLMONITOR
31f3					endif 
31f3					FORTH_DSP_POP 
31f3 cd 8d 20			call macro_forth_dsp_pop 
31f6				endm 
# End of macro FORTH_DSP_POP
31f6			 
31f6					if DEBUG_FORTH_WORDS 
31f6						DMARK "DO5" 
31f6 f5				push af  
31f7 3a 0b 32			ld a, (.dmark)  
31fa 32 b4 fe			ld (debug_mark),a  
31fd 3a 0c 32			ld a, (.dmark+1)  
3200 32 b5 fe			ld (debug_mark+1),a  
3203 3a 0d 32			ld a, (.dmark+2)  
3206 32 b6 fe			ld (debug_mark+2),a  
3209 18 03			jr .pastdmark  
320b ..			.dmark: db "DO5"  
320e f1			.pastdmark: pop af  
320f			endm  
# End of macro DMARK
320f						CALLMONITOR 
320f cd 70 17			call break_point_state  
3212				endm  
# End of macro CALLMONITOR
3212					endif 
3212			 
3212					FORTH_DSP_VALUEHL 
3212 cd d5 1f			call macro_dsp_valuehl 
3215				endm 
# End of macro FORTH_DSP_VALUEHL
3215			;		push hl		 ; hl now has starting limit counter 
3215			 
3215					if DEBUG_FORTH_WORDS 
3215						DMARK "DO6" 
3215 f5				push af  
3216 3a 2a 32			ld a, (.dmark)  
3219 32 b4 fe			ld (debug_mark),a  
321c 3a 2b 32			ld a, (.dmark+1)  
321f 32 b5 fe			ld (debug_mark+1),a  
3222 3a 2c 32			ld a, (.dmark+2)  
3225 32 b6 fe			ld (debug_mark+2),a  
3228 18 03			jr .pastdmark  
322a ..			.dmark: db "DO6"  
322d f1			.pastdmark: pop af  
322e			endm  
# End of macro DMARK
322e						CALLMONITOR 
322e cd 70 17			call break_point_state  
3231				endm  
# End of macro CALLMONITOR
3231					endif 
3231					FORTH_DSP_POP 
3231 cd 8d 20			call macro_forth_dsp_pop 
3234				endm 
# End of macro FORTH_DSP_POP
3234			 
3234			; put counters on the loop stack 
3234			 
3234			;		pop hl			 ; limit counter 
3234 d1					pop de			; start counter 
3235			 
3235					; push limit counter 
3235			 
3235					if DEBUG_FORTH_WORDS 
3235						DMARK "DO7" 
3235 f5				push af  
3236 3a 4a 32			ld a, (.dmark)  
3239 32 b4 fe			ld (debug_mark),a  
323c 3a 4b 32			ld a, (.dmark+1)  
323f 32 b5 fe			ld (debug_mark+1),a  
3242 3a 4c 32			ld a, (.dmark+2)  
3245 32 b6 fe			ld (debug_mark+2),a  
3248 18 03			jr .pastdmark  
324a ..			.dmark: db "DO7"  
324d f1			.pastdmark: pop af  
324e			endm  
# End of macro DMARK
324e						CALLMONITOR 
324e cd 70 17			call break_point_state  
3251				endm  
# End of macro CALLMONITOR
3251					endif 
3251					FORTH_LOOP_NEXT 
3251 cd 06 20			call macro_forth_loop_next 
3254				endm 
# End of macro FORTH_LOOP_NEXT
3254			 
3254					; push start counter 
3254			 
3254 eb					ex de, hl 
3255					if DEBUG_FORTH_WORDS 
3255						DMARK "DO7" 
3255 f5				push af  
3256 3a 6a 32			ld a, (.dmark)  
3259 32 b4 fe			ld (debug_mark),a  
325c 3a 6b 32			ld a, (.dmark+1)  
325f 32 b5 fe			ld (debug_mark+1),a  
3262 3a 6c 32			ld a, (.dmark+2)  
3265 32 b6 fe			ld (debug_mark+2),a  
3268 18 03			jr .pastdmark  
326a ..			.dmark: db "DO7"  
326d f1			.pastdmark: pop af  
326e			endm  
# End of macro DMARK
326e						CALLMONITOR 
326e cd 70 17			call break_point_state  
3271				endm  
# End of macro CALLMONITOR
3271					endif 
3271					FORTH_LOOP_NEXT 
3271 cd 06 20			call macro_forth_loop_next 
3274				endm 
# End of macro FORTH_LOOP_NEXT
3274			 
3274			 
3274					; init first round of I counter 
3274			 
3274 22 7f f7				ld (os_current_i), hl 
3277			 
3277					if DEBUG_FORTH_WORDS 
3277						DMARK "DO8" 
3277 f5				push af  
3278 3a 8c 32			ld a, (.dmark)  
327b 32 b4 fe			ld (debug_mark),a  
327e 3a 8d 32			ld a, (.dmark+1)  
3281 32 b5 fe			ld (debug_mark+1),a  
3284 3a 8e 32			ld a, (.dmark+2)  
3287 32 b6 fe			ld (debug_mark+2),a  
328a 18 03			jr .pastdmark  
328c ..			.dmark: db "DO8"  
328f f1			.pastdmark: pop af  
3290			endm  
# End of macro DMARK
3290						CALLMONITOR 
3290 cd 70 17			call break_point_state  
3293				endm  
# End of macro CALLMONITOR
3293					endif 
3293			 
3293					NEXTW 
3293 c3 47 21			jp macro_next 
3296				endm 
# End of macro NEXTW
3296			.LOOP: 
3296				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3296 22				db WORD_SYS_CORE+14             
3297 ae 33			dw .I            
3299 05				db 4 + 1 
329a .. 00			db "LOOP",0              
329f				endm 
# End of macro CWHEAD
329f			; | LOOP ( -- ) Increment and test loop counter  | DONE 
329f			 
329f				; pop tos as current loop count to hl 
329f			 
329f				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
329f			 
329f				FORTH_LOOP_TOS 
329f cd 39 20			call macro_forth_loop_tos 
32a2				endm 
# End of macro FORTH_LOOP_TOS
32a2 e5				push hl 
32a3			 
32a3					if DEBUG_FORTH_WORDS_KEY 
32a3						DMARK "LOP" 
32a3 f5				push af  
32a4 3a b8 32			ld a, (.dmark)  
32a7 32 b4 fe			ld (debug_mark),a  
32aa 3a b9 32			ld a, (.dmark+1)  
32ad 32 b5 fe			ld (debug_mark+1),a  
32b0 3a ba 32			ld a, (.dmark+2)  
32b3 32 b6 fe			ld (debug_mark+2),a  
32b6 18 03			jr .pastdmark  
32b8 ..			.dmark: db "LOP"  
32bb f1			.pastdmark: pop af  
32bc			endm  
# End of macro DMARK
32bc						CALLMONITOR 
32bc cd 70 17			call break_point_state  
32bf				endm  
# End of macro CALLMONITOR
32bf					endif 
32bf				; next item on the stack is the limit. get it 
32bf			 
32bf			 
32bf				FORTH_LOOP_POP 
32bf cd 43 20			call macro_forth_loop_pop 
32c2				endm 
# End of macro FORTH_LOOP_POP
32c2			 
32c2				FORTH_LOOP_TOS 
32c2 cd 39 20			call macro_forth_loop_tos 
32c5				endm 
# End of macro FORTH_LOOP_TOS
32c5			 
32c5 d1				pop de		 ; de = i, hl = limit 
32c6			 
32c6					if DEBUG_FORTH_WORDS 
32c6						DMARK "LP1" 
32c6 f5				push af  
32c7 3a db 32			ld a, (.dmark)  
32ca 32 b4 fe			ld (debug_mark),a  
32cd 3a dc 32			ld a, (.dmark+1)  
32d0 32 b5 fe			ld (debug_mark+1),a  
32d3 3a dd 32			ld a, (.dmark+2)  
32d6 32 b6 fe			ld (debug_mark+2),a  
32d9 18 03			jr .pastdmark  
32db ..			.dmark: db "LP1"  
32de f1			.pastdmark: pop af  
32df			endm  
# End of macro DMARK
32df						CALLMONITOR 
32df cd 70 17			call break_point_state  
32e2				endm  
# End of macro CALLMONITOR
32e2					endif 
32e2			 
32e2				; go back to previous word 
32e2			 
32e2 d5				push de    ; save I for inc later 
32e3			 
32e3			 
32e3				; get limit 
32e3				;  is I at limit? 
32e3			 
32e3			 
32e3					if DEBUG_FORTH_WORDS 
32e3						DMARK "LP1" 
32e3 f5				push af  
32e4 3a f8 32			ld a, (.dmark)  
32e7 32 b4 fe			ld (debug_mark),a  
32ea 3a f9 32			ld a, (.dmark+1)  
32ed 32 b5 fe			ld (debug_mark+1),a  
32f0 3a fa 32			ld a, (.dmark+2)  
32f3 32 b6 fe			ld (debug_mark+2),a  
32f6 18 03			jr .pastdmark  
32f8 ..			.dmark: db "LP1"  
32fb f1			.pastdmark: pop af  
32fc			endm  
# End of macro DMARK
32fc						CALLMONITOR 
32fc cd 70 17			call break_point_state  
32ff				endm  
# End of macro CALLMONITOR
32ff					endif 
32ff			 
32ff ed 52			sbc hl, de 
3301			 
3301			 
3301				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3301			 
3301 20 26				jr nz, .loopnotdone 
3303			 
3303 e1				pop hl   ; get rid of saved I 
3304				FORTH_LOOP_POP     ; get rid of limit 
3304 cd 43 20			call macro_forth_loop_pop 
3307				endm 
# End of macro FORTH_LOOP_POP
3307			 
3307				FORTH_RSP_POP     ; get rid of DO ptr 
3307 cd a6 1d			call macro_forth_rsp_pop 
330a				endm 
# End of macro FORTH_RSP_POP
330a			 
330a			if DEBUG_FORTH_WORDS 
330a						DMARK "LP>" 
330a f5				push af  
330b 3a 1f 33			ld a, (.dmark)  
330e 32 b4 fe			ld (debug_mark),a  
3311 3a 20 33			ld a, (.dmark+1)  
3314 32 b5 fe			ld (debug_mark+1),a  
3317 3a 21 33			ld a, (.dmark+2)  
331a 32 b6 fe			ld (debug_mark+2),a  
331d 18 03			jr .pastdmark  
331f ..			.dmark: db "LP>"  
3322 f1			.pastdmark: pop af  
3323			endm  
# End of macro DMARK
3323				CALLMONITOR 
3323 cd 70 17			call break_point_state  
3326				endm  
# End of macro CALLMONITOR
3326			endif 
3326			 
3326					NEXTW 
3326 c3 47 21			jp macro_next 
3329				endm 
# End of macro NEXTW
3329				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3329			 
3329			.loopnotdone: 
3329			 
3329 e1				pop hl    ; get I 
332a 23				inc hl 
332b			 
332b			   	; save new I 
332b			 
332b			 
332b					; set I counter 
332b			 
332b 22 7f f7				ld (os_current_i), hl 
332e			 
332e					if DEBUG_FORTH_WORDS 
332e						DMARK "LPN" 
332e f5				push af  
332f 3a 43 33			ld a, (.dmark)  
3332 32 b4 fe			ld (debug_mark),a  
3335 3a 44 33			ld a, (.dmark+1)  
3338 32 b5 fe			ld (debug_mark+1),a  
333b 3a 45 33			ld a, (.dmark+2)  
333e 32 b6 fe			ld (debug_mark+2),a  
3341 18 03			jr .pastdmark  
3343 ..			.dmark: db "LPN"  
3346 f1			.pastdmark: pop af  
3347			endm  
# End of macro DMARK
3347					CALLMONITOR 
3347 cd 70 17			call break_point_state  
334a				endm  
# End of macro CALLMONITOR
334a					endif 
334a					 
334a				FORTH_LOOP_NEXT 
334a cd 06 20			call macro_forth_loop_next 
334d				endm 
# End of macro FORTH_LOOP_NEXT
334d			 
334d			 
334d					if DEBUG_FORTH_WORDS 
334d eb						ex de,hl 
334e					endif 
334e			 
334e			;	; get DO ptr 
334e			; 
334e					if DEBUG_FORTH_WORDS 
334e						DMARK "LP7" 
334e f5				push af  
334f 3a 63 33			ld a, (.dmark)  
3352 32 b4 fe			ld (debug_mark),a  
3355 3a 64 33			ld a, (.dmark+1)  
3358 32 b5 fe			ld (debug_mark+1),a  
335b 3a 65 33			ld a, (.dmark+2)  
335e 32 b6 fe			ld (debug_mark+2),a  
3361 18 03			jr .pastdmark  
3363 ..			.dmark: db "LP7"  
3366 f1			.pastdmark: pop af  
3367			endm  
# End of macro DMARK
3367					CALLMONITOR 
3367 cd 70 17			call break_point_state  
336a				endm  
# End of macro CALLMONITOR
336a					endif 
336a				FORTH_RSP_TOS 
336a cd 9c 1d			call macro_forth_rsp_tos 
336d				endm 
# End of macro FORTH_RSP_TOS
336d			 
336d					if DEBUG_FORTH_WORDS 
336d						DMARK "LP8" 
336d f5				push af  
336e 3a 82 33			ld a, (.dmark)  
3371 32 b4 fe			ld (debug_mark),a  
3374 3a 83 33			ld a, (.dmark+1)  
3377 32 b5 fe			ld (debug_mark+1),a  
337a 3a 84 33			ld a, (.dmark+2)  
337d 32 b6 fe			ld (debug_mark+2),a  
3380 18 03			jr .pastdmark  
3382 ..			.dmark: db "LP8"  
3385 f1			.pastdmark: pop af  
3386			endm  
# End of macro DMARK
3386					CALLMONITOR 
3386 cd 70 17			call break_point_state  
3389				endm  
# End of macro CALLMONITOR
3389					endif 
3389				;push hl 
3389			 
3389				; not going to DO any more 
3389				; get rid of the RSP pointer as DO will add it back in 
3389				;FORTH_RSP_POP 
3389				;pop hl 
3389			 
3389				;ld hl,(cli_ret_sp) 
3389				;ld e, (hl) 
3389				;inc hl 
3389				;ld d, (hl) 
3389				;ex de,hl 
3389 22 5b f7			ld (os_tok_ptr), hl 
338c					if DEBUG_FORTH_WORDS 
338c						DMARK "LP<" 
338c f5				push af  
338d 3a a1 33			ld a, (.dmark)  
3390 32 b4 fe			ld (debug_mark),a  
3393 3a a2 33			ld a, (.dmark+1)  
3396 32 b5 fe			ld (debug_mark+1),a  
3399 3a a3 33			ld a, (.dmark+2)  
339c 32 b6 fe			ld (debug_mark+2),a  
339f 18 03			jr .pastdmark  
33a1 ..			.dmark: db "LP<"  
33a4 f1			.pastdmark: pop af  
33a5			endm  
# End of macro DMARK
33a5					CALLMONITOR 
33a5 cd 70 17			call break_point_state  
33a8				endm  
# End of macro CALLMONITOR
33a8				endif 
33a8 c3 d8 21			jp exec1 
33ab			 
33ab					 
33ab			 
33ab			 
33ab					NEXTW 
33ab c3 47 21			jp macro_next 
33ae				endm 
# End of macro NEXTW
33ae			.I:  
33ae			 
33ae				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
33ae 5e				db WORD_SYS_CORE+74             
33af d9 33			dw .DLOOP            
33b1 02				db 1 + 1 
33b2 .. 00			db "I",0              
33b4				endm 
# End of macro CWHEAD
33b4			; | I ( -- ) Current loop counter | DONE 
33b4					if DEBUG_FORTH_WORDS_KEY 
33b4						DMARK "I.." 
33b4 f5				push af  
33b5 3a c9 33			ld a, (.dmark)  
33b8 32 b4 fe			ld (debug_mark),a  
33bb 3a ca 33			ld a, (.dmark+1)  
33be 32 b5 fe			ld (debug_mark+1),a  
33c1 3a cb 33			ld a, (.dmark+2)  
33c4 32 b6 fe			ld (debug_mark+2),a  
33c7 18 03			jr .pastdmark  
33c9 ..			.dmark: db "I.."  
33cc f1			.pastdmark: pop af  
33cd			endm  
# End of macro DMARK
33cd						CALLMONITOR 
33cd cd 70 17			call break_point_state  
33d0				endm  
# End of macro CALLMONITOR
33d0					endif 
33d0			 
33d0 2a 7f f7				ld hl,(os_current_i) 
33d3 cd de 1d				call forth_push_numhl 
33d6			 
33d6					NEXTW 
33d6 c3 47 21			jp macro_next 
33d9				endm 
# End of macro NEXTW
33d9			.DLOOP: 
33d9				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
33d9 5f				db WORD_SYS_CORE+75             
33da ba 34			dw .REPEAT            
33dc 06				db 5 + 1 
33dd .. 00			db "-LOOP",0              
33e3				endm 
# End of macro CWHEAD
33e3			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
33e3				; pop tos as current loop count to hl 
33e3					if DEBUG_FORTH_WORDS_KEY 
33e3						DMARK "-LP" 
33e3 f5				push af  
33e4 3a f8 33			ld a, (.dmark)  
33e7 32 b4 fe			ld (debug_mark),a  
33ea 3a f9 33			ld a, (.dmark+1)  
33ed 32 b5 fe			ld (debug_mark+1),a  
33f0 3a fa 33			ld a, (.dmark+2)  
33f3 32 b6 fe			ld (debug_mark+2),a  
33f6 18 03			jr .pastdmark  
33f8 ..			.dmark: db "-LP"  
33fb f1			.pastdmark: pop af  
33fc			endm  
# End of macro DMARK
33fc						CALLMONITOR 
33fc cd 70 17			call break_point_state  
33ff				endm  
# End of macro CALLMONITOR
33ff					endif 
33ff			 
33ff				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
33ff			 
33ff				FORTH_LOOP_TOS 
33ff cd 39 20			call macro_forth_loop_tos 
3402				endm 
# End of macro FORTH_LOOP_TOS
3402 e5				push hl 
3403			 
3403					if DEBUG_FORTH_WORDS 
3403						DMARK "-LP" 
3403 f5				push af  
3404 3a 18 34			ld a, (.dmark)  
3407 32 b4 fe			ld (debug_mark),a  
340a 3a 19 34			ld a, (.dmark+1)  
340d 32 b5 fe			ld (debug_mark+1),a  
3410 3a 1a 34			ld a, (.dmark+2)  
3413 32 b6 fe			ld (debug_mark+2),a  
3416 18 03			jr .pastdmark  
3418 ..			.dmark: db "-LP"  
341b f1			.pastdmark: pop af  
341c			endm  
# End of macro DMARK
341c						CALLMONITOR 
341c cd 70 17			call break_point_state  
341f				endm  
# End of macro CALLMONITOR
341f					endif 
341f				; next item on the stack is the limit. get it 
341f			 
341f			 
341f				FORTH_LOOP_POP 
341f cd 43 20			call macro_forth_loop_pop 
3422				endm 
# End of macro FORTH_LOOP_POP
3422			 
3422				FORTH_LOOP_TOS 
3422 cd 39 20			call macro_forth_loop_tos 
3425				endm 
# End of macro FORTH_LOOP_TOS
3425			 
3425 d1				pop de		 ; de = i, hl = limit 
3426			 
3426					if DEBUG_FORTH_WORDS 
3426						DMARK "-L1" 
3426 f5				push af  
3427 3a 3b 34			ld a, (.dmark)  
342a 32 b4 fe			ld (debug_mark),a  
342d 3a 3c 34			ld a, (.dmark+1)  
3430 32 b5 fe			ld (debug_mark+1),a  
3433 3a 3d 34			ld a, (.dmark+2)  
3436 32 b6 fe			ld (debug_mark+2),a  
3439 18 03			jr .pastdmark  
343b ..			.dmark: db "-L1"  
343e f1			.pastdmark: pop af  
343f			endm  
# End of macro DMARK
343f						CALLMONITOR 
343f cd 70 17			call break_point_state  
3442				endm  
# End of macro CALLMONITOR
3442					endif 
3442			 
3442				; go back to previous word 
3442			 
3442 d5				push de    ; save I for inc later 
3443			 
3443			 
3443				; get limit 
3443				;  is I at limit? 
3443			 
3443			 
3443					if DEBUG_FORTH_WORDS 
3443						DMARK "-L1" 
3443 f5				push af  
3444 3a 58 34			ld a, (.dmark)  
3447 32 b4 fe			ld (debug_mark),a  
344a 3a 59 34			ld a, (.dmark+1)  
344d 32 b5 fe			ld (debug_mark+1),a  
3450 3a 5a 34			ld a, (.dmark+2)  
3453 32 b6 fe			ld (debug_mark+2),a  
3456 18 03			jr .pastdmark  
3458 ..			.dmark: db "-L1"  
345b f1			.pastdmark: pop af  
345c			endm  
# End of macro DMARK
345c						CALLMONITOR 
345c cd 70 17			call break_point_state  
345f				endm  
# End of macro CALLMONITOR
345f					endif 
345f			 
345f ed 52			sbc hl, de 
3461			 
3461			 
3461				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3461			 
3461 20 26				jr nz, .mloopnotdone 
3463			 
3463 e1				pop hl   ; get rid of saved I 
3464				FORTH_LOOP_POP     ; get rid of limit 
3464 cd 43 20			call macro_forth_loop_pop 
3467				endm 
# End of macro FORTH_LOOP_POP
3467			 
3467				FORTH_RSP_POP     ; get rid of DO ptr 
3467 cd a6 1d			call macro_forth_rsp_pop 
346a				endm 
# End of macro FORTH_RSP_POP
346a			 
346a			if DEBUG_FORTH_WORDS 
346a						DMARK "-L>" 
346a f5				push af  
346b 3a 7f 34			ld a, (.dmark)  
346e 32 b4 fe			ld (debug_mark),a  
3471 3a 80 34			ld a, (.dmark+1)  
3474 32 b5 fe			ld (debug_mark+1),a  
3477 3a 81 34			ld a, (.dmark+2)  
347a 32 b6 fe			ld (debug_mark+2),a  
347d 18 03			jr .pastdmark  
347f ..			.dmark: db "-L>"  
3482 f1			.pastdmark: pop af  
3483			endm  
# End of macro DMARK
3483				CALLMONITOR 
3483 cd 70 17			call break_point_state  
3486				endm  
# End of macro CALLMONITOR
3486			endif 
3486			 
3486					NEXTW 
3486 c3 47 21			jp macro_next 
3489				endm 
# End of macro NEXTW
3489				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3489			 
3489			.mloopnotdone: 
3489			 
3489 e1				pop hl    ; get I 
348a 2b				dec hl 
348b			 
348b			   	; save new I 
348b			 
348b			 
348b					; set I counter 
348b			 
348b 22 7f f7				ld (os_current_i), hl 
348e			 
348e					 
348e				FORTH_LOOP_NEXT 
348e cd 06 20			call macro_forth_loop_next 
3491				endm 
# End of macro FORTH_LOOP_NEXT
3491			 
3491			 
3491					if DEBUG_FORTH_WORDS 
3491 eb						ex de,hl 
3492					endif 
3492			 
3492			;	; get DO ptr 
3492			; 
3492				FORTH_RSP_TOS 
3492 cd 9c 1d			call macro_forth_rsp_tos 
3495				endm 
# End of macro FORTH_RSP_TOS
3495			 
3495				;push hl 
3495			 
3495				; not going to DO any more 
3495				; get rid of the RSP pointer as DO will add it back in 
3495				;FORTH_RSP_POP 
3495				;pop hl 
3495			 
3495			 
3495 22 5b f7			ld (os_tok_ptr), hl 
3498					if DEBUG_FORTH_WORDS 
3498						DMARK "-L<" 
3498 f5				push af  
3499 3a ad 34			ld a, (.dmark)  
349c 32 b4 fe			ld (debug_mark),a  
349f 3a ae 34			ld a, (.dmark+1)  
34a2 32 b5 fe			ld (debug_mark+1),a  
34a5 3a af 34			ld a, (.dmark+2)  
34a8 32 b6 fe			ld (debug_mark+2),a  
34ab 18 03			jr .pastdmark  
34ad ..			.dmark: db "-L<"  
34b0 f1			.pastdmark: pop af  
34b1			endm  
# End of macro DMARK
34b1					CALLMONITOR 
34b1 cd 70 17			call break_point_state  
34b4				endm  
# End of macro CALLMONITOR
34b4				endif 
34b4 c3 d8 21			jp exec1 
34b7			 
34b7					 
34b7			 
34b7			 
34b7			 
34b7				NEXTW 
34b7 c3 47 21			jp macro_next 
34ba				endm 
# End of macro NEXTW
34ba			 
34ba			 
34ba			 
34ba			 
34ba			.REPEAT: 
34ba				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
34ba 71				db WORD_SYS_CORE+93             
34bb 0d 35			dw .UNTIL            
34bd 06				db 5 + 1 
34be .. 00			db "REPEAT",0              
34c5				endm 
# End of macro CWHEAD
34c5			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
34c5			;  push pc to rsp stack past the REPEAT 
34c5					if DEBUG_FORTH_WORDS_KEY 
34c5						DMARK "REP" 
34c5 f5				push af  
34c6 3a da 34			ld a, (.dmark)  
34c9 32 b4 fe			ld (debug_mark),a  
34cc 3a db 34			ld a, (.dmark+1)  
34cf 32 b5 fe			ld (debug_mark+1),a  
34d2 3a dc 34			ld a, (.dmark+2)  
34d5 32 b6 fe			ld (debug_mark+2),a  
34d8 18 03			jr .pastdmark  
34da ..			.dmark: db "REP"  
34dd f1			.pastdmark: pop af  
34de			endm  
# End of macro DMARK
34de						CALLMONITOR 
34de cd 70 17			call break_point_state  
34e1				endm  
# End of macro CALLMONITOR
34e1					endif 
34e1			 
34e1 2a 5b f7				ld hl, (os_tok_ptr) 
34e4 23					inc hl   ; R 
34e5 23					inc hl  ; E 
34e6 23					inc hl   ; P 
34e7 23					inc hl   ; E 
34e8 23					inc hl   ; A 
34e9 23					inc hl   ; T 
34ea 23					inc hl   ; zero 
34eb					FORTH_RSP_NEXT 
34eb cd 85 1d			call macro_forth_rsp_next 
34ee				endm 
# End of macro FORTH_RSP_NEXT
34ee			 
34ee			 
34ee					if DEBUG_FORTH_WORDS 
34ee						DMARK "REP" 
34ee f5				push af  
34ef 3a 03 35			ld a, (.dmark)  
34f2 32 b4 fe			ld (debug_mark),a  
34f5 3a 04 35			ld a, (.dmark+1)  
34f8 32 b5 fe			ld (debug_mark+1),a  
34fb 3a 05 35			ld a, (.dmark+2)  
34fe 32 b6 fe			ld (debug_mark+2),a  
3501 18 03			jr .pastdmark  
3503 ..			.dmark: db "REP"  
3506 f1			.pastdmark: pop af  
3507			endm  
# End of macro DMARK
3507						;pop bc    ; TODO BUG ?????? what is this for???? 
3507						CALLMONITOR 
3507 cd 70 17			call break_point_state  
350a				endm  
# End of macro CALLMONITOR
350a					endif 
350a			 
350a					NEXTW 
350a c3 47 21			jp macro_next 
350d				endm 
# End of macro NEXTW
350d			;	       NEXTW 
350d			 
350d			.UNTIL: 
350d				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
350d 72				db WORD_SYS_CORE+94             
350e a4 35			dw .ENDFLOW            
3510 06				db 5 + 1 
3511 .. 00			db "UNTIL",0              
3517				endm 
# End of macro CWHEAD
3517			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3517			 
3517				; pop tos as check 
3517			 
3517				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3517			 
3517				FORTH_DSP_VALUEHL 
3517 cd d5 1f			call macro_dsp_valuehl 
351a				endm 
# End of macro FORTH_DSP_VALUEHL
351a			 
351a					if DEBUG_FORTH_WORDS_KEY 
351a						DMARK "UNT" 
351a f5				push af  
351b 3a 2f 35			ld a, (.dmark)  
351e 32 b4 fe			ld (debug_mark),a  
3521 3a 30 35			ld a, (.dmark+1)  
3524 32 b5 fe			ld (debug_mark+1),a  
3527 3a 31 35			ld a, (.dmark+2)  
352a 32 b6 fe			ld (debug_mark+2),a  
352d 18 03			jr .pastdmark  
352f ..			.dmark: db "UNT"  
3532 f1			.pastdmark: pop af  
3533			endm  
# End of macro DMARK
3533						CALLMONITOR 
3533 cd 70 17			call break_point_state  
3536				endm  
# End of macro CALLMONITOR
3536					endif 
3536			 
3536			;	push hl 
3536				FORTH_DSP_POP 
3536 cd 8d 20			call macro_forth_dsp_pop 
3539				endm 
# End of macro FORTH_DSP_POP
3539			 
3539			;	pop hl 
3539			 
3539				; test if true 
3539			 
3539 cd 1c 0e			call ishlzero 
353c			;	ld a,l 
353c			;	add h 
353c			; 
353c			;	cp 0 
353c			 
353c 20 3e			jr nz, .untilnotdone 
353e			 
353e					if DEBUG_FORTH_WORDS 
353e						DMARK "UNf" 
353e f5				push af  
353f 3a 53 35			ld a, (.dmark)  
3542 32 b4 fe			ld (debug_mark),a  
3545 3a 54 35			ld a, (.dmark+1)  
3548 32 b5 fe			ld (debug_mark+1),a  
354b 3a 55 35			ld a, (.dmark+2)  
354e 32 b6 fe			ld (debug_mark+2),a  
3551 18 03			jr .pastdmark  
3553 ..			.dmark: db "UNf"  
3556 f1			.pastdmark: pop af  
3557			endm  
# End of macro DMARK
3557						CALLMONITOR 
3557 cd 70 17			call break_point_state  
355a				endm  
# End of macro CALLMONITOR
355a					endif 
355a			 
355a			 
355a			 
355a				FORTH_RSP_POP     ; get rid of DO ptr 
355a cd a6 1d			call macro_forth_rsp_pop 
355d				endm 
# End of macro FORTH_RSP_POP
355d			 
355d			if DEBUG_FORTH_WORDS 
355d						DMARK "UN>" 
355d f5				push af  
355e 3a 72 35			ld a, (.dmark)  
3561 32 b4 fe			ld (debug_mark),a  
3564 3a 73 35			ld a, (.dmark+1)  
3567 32 b5 fe			ld (debug_mark+1),a  
356a 3a 74 35			ld a, (.dmark+2)  
356d 32 b6 fe			ld (debug_mark+2),a  
3570 18 03			jr .pastdmark  
3572 ..			.dmark: db "UN>"  
3575 f1			.pastdmark: pop af  
3576			endm  
# End of macro DMARK
3576				CALLMONITOR 
3576 cd 70 17			call break_point_state  
3579				endm  
# End of macro CALLMONITOR
3579			endif 
3579			 
3579					NEXTW 
3579 c3 47 21			jp macro_next 
357c				endm 
# End of macro NEXTW
357c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
357c			 
357c			.untilnotdone: 
357c			 
357c			 
357c			;	; get DO ptr 
357c			; 
357c				FORTH_RSP_TOS 
357c cd 9c 1d			call macro_forth_rsp_tos 
357f				endm 
# End of macro FORTH_RSP_TOS
357f			 
357f				;push hl 
357f			 
357f				; not going to DO any more 
357f				; get rid of the RSP pointer as DO will add it back in 
357f				;FORTH_RSP_POP 
357f				;pop hl 
357f			 
357f			 
357f 22 5b f7			ld (os_tok_ptr), hl 
3582					if DEBUG_FORTH_WORDS 
3582						DMARK "UN<" 
3582 f5				push af  
3583 3a 97 35			ld a, (.dmark)  
3586 32 b4 fe			ld (debug_mark),a  
3589 3a 98 35			ld a, (.dmark+1)  
358c 32 b5 fe			ld (debug_mark+1),a  
358f 3a 99 35			ld a, (.dmark+2)  
3592 32 b6 fe			ld (debug_mark+2),a  
3595 18 03			jr .pastdmark  
3597 ..			.dmark: db "UN<"  
359a f1			.pastdmark: pop af  
359b			endm  
# End of macro DMARK
359b					CALLMONITOR 
359b cd 70 17			call break_point_state  
359e				endm  
# End of macro CALLMONITOR
359e				endif 
359e c3 d8 21			jp exec1 
35a1			 
35a1					 
35a1			 
35a1			 
35a1					NEXTW 
35a1 c3 47 21			jp macro_next 
35a4				endm 
# End of macro NEXTW
35a4			 
35a4			 
35a4			.ENDFLOW: 
35a4			 
35a4			; eof 
35a4			 
# End of file forth_words_flow.asm
35a4			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
35a4			include "forth_words_logic.asm" 
35a4			 
35a4			; | ## Logic Words 
35a4			 
35a4			.NOT: 
35a4				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
35a4 2d				db WORD_SYS_CORE+25             
35a5 ec 35			dw .IS            
35a7 04				db 3 + 1 
35a8 .. 00			db "NOT",0              
35ac				endm 
# End of macro CWHEAD
35ac			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
35ac					if DEBUG_FORTH_WORDS_KEY 
35ac						DMARK "NOT" 
35ac f5				push af  
35ad 3a c1 35			ld a, (.dmark)  
35b0 32 b4 fe			ld (debug_mark),a  
35b3 3a c2 35			ld a, (.dmark+1)  
35b6 32 b5 fe			ld (debug_mark+1),a  
35b9 3a c3 35			ld a, (.dmark+2)  
35bc 32 b6 fe			ld (debug_mark+2),a  
35bf 18 03			jr .pastdmark  
35c1 ..			.dmark: db "NOT"  
35c4 f1			.pastdmark: pop af  
35c5			endm  
# End of macro DMARK
35c5						CALLMONITOR 
35c5 cd 70 17			call break_point_state  
35c8				endm  
# End of macro CALLMONITOR
35c8					endif 
35c8					FORTH_DSP 
35c8 cd 9b 1f			call macro_forth_dsp 
35cb				endm 
# End of macro FORTH_DSP
35cb 7e					ld a,(hl)	; get type of value on TOS 
35cc fe 02				cp DS_TYPE_INUM  
35ce 28 03				jr z, .noti 
35d0					NEXTW 
35d0 c3 47 21			jp macro_next 
35d3				endm 
# End of macro NEXTW
35d3			.noti:          FORTH_DSP_VALUEHL 
35d3 cd d5 1f			call macro_dsp_valuehl 
35d6				endm 
# End of macro FORTH_DSP_VALUEHL
35d6			;		push hl 
35d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35d6 cd 8d 20			call macro_forth_dsp_pop 
35d9				endm 
# End of macro FORTH_DSP_POP
35d9			;		pop hl 
35d9 3e 00				ld a,0 
35db bd					cp l 
35dc 28 04				jr z, .not2t 
35de 2e 00				ld l, 0 
35e0 18 02				jr .notip 
35e2			 
35e2 2e ff		.not2t:		ld l, 255 
35e4			 
35e4 26 00		.notip:		ld h, 0	 
35e6			 
35e6 cd de 1d				call forth_push_numhl 
35e9					NEXTW 
35e9 c3 47 21			jp macro_next 
35ec				endm 
# End of macro NEXTW
35ec			 
35ec			.IS: 
35ec				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
35ec 2d				db WORD_SYS_CORE+25             
35ed 12 36			dw .LZERO            
35ef 03				db 2 + 1 
35f0 .. 00			db "IS",0              
35f3				endm 
# End of macro CWHEAD
35f3			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
35f3					if DEBUG_FORTH_WORDS_KEY 
35f3						DMARK "IS." 
35f3 f5				push af  
35f4 3a 08 36			ld a, (.dmark)  
35f7 32 b4 fe			ld (debug_mark),a  
35fa 3a 09 36			ld a, (.dmark+1)  
35fd 32 b5 fe			ld (debug_mark+1),a  
3600 3a 0a 36			ld a, (.dmark+2)  
3603 32 b6 fe			ld (debug_mark+2),a  
3606 18 03			jr .pastdmark  
3608 ..			.dmark: db "IS."  
360b f1			.pastdmark: pop af  
360c			endm  
# End of macro DMARK
360c						CALLMONITOR 
360c cd 70 17			call break_point_state  
360f				endm  
# End of macro CALLMONITOR
360f					endif 
360f					NEXTW 
360f c3 47 21			jp macro_next 
3612				endm 
# End of macro NEXTW
3612			.LZERO: 
3612				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3612 2d				db WORD_SYS_CORE+25             
3613 1c 36			dw .TZERO            
3615 03				db 2 + 1 
3616 .. 00			db "0<",0              
3619				endm 
# End of macro CWHEAD
3619			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3619					NEXTW 
3619 c3 47 21			jp macro_next 
361c				endm 
# End of macro NEXTW
361c			.TZERO: 
361c				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
361c 2e				db WORD_SYS_CORE+26             
361d 63 36			dw .LESS            
361f 03				db 2 + 1 
3620 .. 00			db "0=",0              
3623				endm 
# End of macro CWHEAD
3623			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3623				; TODO add floating point number detection 
3623					;v5 FORTH_DSP_VALUE 
3623					if DEBUG_FORTH_WORDS_KEY 
3623						DMARK "0=." 
3623 f5				push af  
3624 3a 38 36			ld a, (.dmark)  
3627 32 b4 fe			ld (debug_mark),a  
362a 3a 39 36			ld a, (.dmark+1)  
362d 32 b5 fe			ld (debug_mark+1),a  
3630 3a 3a 36			ld a, (.dmark+2)  
3633 32 b6 fe			ld (debug_mark+2),a  
3636 18 03			jr .pastdmark  
3638 ..			.dmark: db "0=."  
363b f1			.pastdmark: pop af  
363c			endm  
# End of macro DMARK
363c						CALLMONITOR 
363c cd 70 17			call break_point_state  
363f				endm  
# End of macro CALLMONITOR
363f					endif 
363f					FORTH_DSP 
363f cd 9b 1f			call macro_forth_dsp 
3642				endm 
# End of macro FORTH_DSP
3642 7e					ld a,(hl)	; get type of value on TOS 
3643 fe 02				cp DS_TYPE_INUM  
3645 28 00				jr z, .tz_inum 
3647			 
3647				if FORTH_ENABLE_FLOATMATH 
3647					jr .tz_done 
3647			 
3647				endif 
3647					 
3647			 
3647			.tz_inum: 
3647					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3647 cd d5 1f			call macro_dsp_valuehl 
364a				endm 
# End of macro FORTH_DSP_VALUEHL
364a			 
364a			;		push hl 
364a			 
364a					; destroy value TOS 
364a			 
364a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
364a cd 8d 20			call macro_forth_dsp_pop 
364d				endm 
# End of macro FORTH_DSP_POP
364d			 
364d			;		pop hl 
364d			 
364d 3e 00				ld a,0 
364f			 
364f bd					cp l 
3650 20 08				jr nz, .tz_notzero 
3652			 
3652 bc					cp h 
3653			 
3653 20 05				jr nz, .tz_notzero 
3655			 
3655			 
3655 21 01 00				ld hl, FORTH_TRUE 
3658 18 03				jr .tz_done 
365a			 
365a 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
365d			 
365d					; push value back onto stack for another op etc 
365d			 
365d			.tz_done: 
365d cd de 1d				call forth_push_numhl 
3660			 
3660					NEXTW 
3660 c3 47 21			jp macro_next 
3663				endm 
# End of macro NEXTW
3663			.LESS: 
3663				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3663 2f				db WORD_SYS_CORE+27             
3664 cc 36			dw .GT            
3666 02				db 1 + 1 
3667 .. 00			db "<",0              
3669				endm 
# End of macro CWHEAD
3669			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3669				; TODO add floating point number detection 
3669					if DEBUG_FORTH_WORDS_KEY 
3669						DMARK "LES" 
3669 f5				push af  
366a 3a 7e 36			ld a, (.dmark)  
366d 32 b4 fe			ld (debug_mark),a  
3670 3a 7f 36			ld a, (.dmark+1)  
3673 32 b5 fe			ld (debug_mark+1),a  
3676 3a 80 36			ld a, (.dmark+2)  
3679 32 b6 fe			ld (debug_mark+2),a  
367c 18 03			jr .pastdmark  
367e ..			.dmark: db "LES"  
3681 f1			.pastdmark: pop af  
3682			endm  
# End of macro DMARK
3682						CALLMONITOR 
3682 cd 70 17			call break_point_state  
3685				endm  
# End of macro CALLMONITOR
3685					endif 
3685					FORTH_DSP 
3685 cd 9b 1f			call macro_forth_dsp 
3688				endm 
# End of macro FORTH_DSP
3688					;v5 FORTH_DSP_VALUE 
3688 7e					ld a,(hl)	; get type of value on TOS 
3689 fe 02				cp DS_TYPE_INUM  
368b 28 00				jr z, .less_inum 
368d			 
368d				if FORTH_ENABLE_FLOATMATH 
368d					jr .less_done 
368d			 
368d				endif 
368d					 
368d			 
368d			.less_inum: 
368d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
368d cd d5 1f			call macro_dsp_valuehl 
3690				endm 
# End of macro FORTH_DSP_VALUEHL
3690			 
3690 e5					push hl  ; u2 
3691			 
3691					; destroy value TOS 
3691			 
3691					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3691 cd 8d 20			call macro_forth_dsp_pop 
3694				endm 
# End of macro FORTH_DSP_POP
3694			 
3694			 
3694					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3694 cd d5 1f			call macro_dsp_valuehl 
3697				endm 
# End of macro FORTH_DSP_VALUEHL
3697			 
3697 e5					push hl    ; u1 
3698			 
3698					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3698 cd 8d 20			call macro_forth_dsp_pop 
369b				endm 
# End of macro FORTH_DSP_POP
369b			 
369b			 
369b b7			 or a      ;clear carry flag 
369c 01 00 00		 ld bc, FORTH_FALSE 
369f e1			  pop hl    ; u1 
36a0 d1			  pop de    ; u2 
36a1 ed 52		  sbc hl,de 
36a3 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
36a5			 
36a5 01 01 00		 ld bc, FORTH_TRUE 
36a8			.lscont:  
36a8 c5					push bc 
36a9 e1					pop hl 
36aa			 
36aa					if DEBUG_FORTH_WORDS 
36aa						DMARK "LT1" 
36aa f5				push af  
36ab 3a bf 36			ld a, (.dmark)  
36ae 32 b4 fe			ld (debug_mark),a  
36b1 3a c0 36			ld a, (.dmark+1)  
36b4 32 b5 fe			ld (debug_mark+1),a  
36b7 3a c1 36			ld a, (.dmark+2)  
36ba 32 b6 fe			ld (debug_mark+2),a  
36bd 18 03			jr .pastdmark  
36bf ..			.dmark: db "LT1"  
36c2 f1			.pastdmark: pop af  
36c3			endm  
# End of macro DMARK
36c3						CALLMONITOR 
36c3 cd 70 17			call break_point_state  
36c6				endm  
# End of macro CALLMONITOR
36c6					endif 
36c6 cd de 1d				call forth_push_numhl 
36c9			 
36c9					NEXTW 
36c9 c3 47 21			jp macro_next 
36cc				endm 
# End of macro NEXTW
36cc			.GT: 
36cc				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
36cc 30				db WORD_SYS_CORE+28             
36cd 35 37			dw .EQUAL            
36cf 02				db 1 + 1 
36d0 .. 00			db ">",0              
36d2				endm 
# End of macro CWHEAD
36d2			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
36d2				; TODO add floating point number detection 
36d2					if DEBUG_FORTH_WORDS_KEY 
36d2						DMARK "GRT" 
36d2 f5				push af  
36d3 3a e7 36			ld a, (.dmark)  
36d6 32 b4 fe			ld (debug_mark),a  
36d9 3a e8 36			ld a, (.dmark+1)  
36dc 32 b5 fe			ld (debug_mark+1),a  
36df 3a e9 36			ld a, (.dmark+2)  
36e2 32 b6 fe			ld (debug_mark+2),a  
36e5 18 03			jr .pastdmark  
36e7 ..			.dmark: db "GRT"  
36ea f1			.pastdmark: pop af  
36eb			endm  
# End of macro DMARK
36eb						CALLMONITOR 
36eb cd 70 17			call break_point_state  
36ee				endm  
# End of macro CALLMONITOR
36ee					endif 
36ee					FORTH_DSP 
36ee cd 9b 1f			call macro_forth_dsp 
36f1				endm 
# End of macro FORTH_DSP
36f1					;FORTH_DSP_VALUE 
36f1 7e					ld a,(hl)	; get type of value on TOS 
36f2 fe 02				cp DS_TYPE_INUM  
36f4 28 00				jr z, .gt_inum 
36f6			 
36f6				if FORTH_ENABLE_FLOATMATH 
36f6					jr .gt_done 
36f6			 
36f6				endif 
36f6					 
36f6			 
36f6			.gt_inum: 
36f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36f6 cd d5 1f			call macro_dsp_valuehl 
36f9				endm 
# End of macro FORTH_DSP_VALUEHL
36f9			 
36f9 e5					push hl  ; u2 
36fa			 
36fa					; destroy value TOS 
36fa			 
36fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36fa cd 8d 20			call macro_forth_dsp_pop 
36fd				endm 
# End of macro FORTH_DSP_POP
36fd			 
36fd			 
36fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36fd cd d5 1f			call macro_dsp_valuehl 
3700				endm 
# End of macro FORTH_DSP_VALUEHL
3700			 
3700 e5					push hl    ; u1 
3701			 
3701					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3701 cd 8d 20			call macro_forth_dsp_pop 
3704				endm 
# End of macro FORTH_DSP_POP
3704			 
3704			 
3704 b7			 or a      ;clear carry flag 
3705 01 00 00		 ld bc, FORTH_FALSE 
3708 e1			  pop hl    ; u1 
3709 d1			  pop de    ; u2 
370a ed 52		  sbc hl,de 
370c 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
370e			 
370e 01 01 00		 ld bc, FORTH_TRUE 
3711			.gtcont:  
3711 c5					push bc 
3712 e1					pop hl 
3713			 
3713					if DEBUG_FORTH_WORDS 
3713						DMARK "GT1" 
3713 f5				push af  
3714 3a 28 37			ld a, (.dmark)  
3717 32 b4 fe			ld (debug_mark),a  
371a 3a 29 37			ld a, (.dmark+1)  
371d 32 b5 fe			ld (debug_mark+1),a  
3720 3a 2a 37			ld a, (.dmark+2)  
3723 32 b6 fe			ld (debug_mark+2),a  
3726 18 03			jr .pastdmark  
3728 ..			.dmark: db "GT1"  
372b f1			.pastdmark: pop af  
372c			endm  
# End of macro DMARK
372c						CALLMONITOR 
372c cd 70 17			call break_point_state  
372f				endm  
# End of macro CALLMONITOR
372f					endif 
372f cd de 1d				call forth_push_numhl 
3732			 
3732					NEXTW 
3732 c3 47 21			jp macro_next 
3735				endm 
# End of macro NEXTW
3735			.EQUAL: 
3735				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3735 31				db WORD_SYS_CORE+29             
3736 a0 37			dw .ENDLOGIC            
3738 02				db 1 + 1 
3739 .. 00			db "=",0              
373b				endm 
# End of macro CWHEAD
373b			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
373b				; TODO add floating point number detection 
373b					if DEBUG_FORTH_WORDS_KEY 
373b						DMARK "EQ." 
373b f5				push af  
373c 3a 50 37			ld a, (.dmark)  
373f 32 b4 fe			ld (debug_mark),a  
3742 3a 51 37			ld a, (.dmark+1)  
3745 32 b5 fe			ld (debug_mark+1),a  
3748 3a 52 37			ld a, (.dmark+2)  
374b 32 b6 fe			ld (debug_mark+2),a  
374e 18 03			jr .pastdmark  
3750 ..			.dmark: db "EQ."  
3753 f1			.pastdmark: pop af  
3754			endm  
# End of macro DMARK
3754						CALLMONITOR 
3754 cd 70 17			call break_point_state  
3757				endm  
# End of macro CALLMONITOR
3757					endif 
3757					FORTH_DSP 
3757 cd 9b 1f			call macro_forth_dsp 
375a				endm 
# End of macro FORTH_DSP
375a					;v5 FORTH_DSP_VALUE 
375a 7e					ld a,(hl)	; get type of value on TOS 
375b fe 02				cp DS_TYPE_INUM  
375d 28 00				jr z, .eq_inum 
375f			 
375f				if FORTH_ENABLE_FLOATMATH 
375f					jr .eq_done 
375f			 
375f				endif 
375f					 
375f			 
375f			.eq_inum: 
375f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
375f cd d5 1f			call macro_dsp_valuehl 
3762				endm 
# End of macro FORTH_DSP_VALUEHL
3762			 
3762 e5					push hl 
3763			 
3763					; destroy value TOS 
3763			 
3763					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3763 cd 8d 20			call macro_forth_dsp_pop 
3766				endm 
# End of macro FORTH_DSP_POP
3766			 
3766			 
3766					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3766 cd d5 1f			call macro_dsp_valuehl 
3769				endm 
# End of macro FORTH_DSP_VALUEHL
3769			 
3769					; one value on hl get other one back 
3769			 
3769 e5					push hl 
376a			 
376a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
376a cd 8d 20			call macro_forth_dsp_pop 
376d				endm 
# End of macro FORTH_DSP_POP
376d			 
376d 0e 00				ld c, FORTH_FALSE 
376f			 
376f e1					pop hl 
3770 d1					pop de 
3771			 
3771 7b					ld a, e 
3772 bd					cp l 
3773			 
3773 20 06				jr nz, .eq_done 
3775			 
3775 7a					ld a, d 
3776 bc					cp h 
3777			 
3777 20 02				jr nz, .eq_done 
3779			 
3779 0e 01				ld c, FORTH_TRUE 
377b					 
377b			 
377b			 
377b			.eq_done: 
377b			 
377b					; TODO push value back onto stack for another op etc 
377b			 
377b 26 00				ld h, 0 
377d 69					ld l, c 
377e					if DEBUG_FORTH_WORDS 
377e						DMARK "EQ1" 
377e f5				push af  
377f 3a 93 37			ld a, (.dmark)  
3782 32 b4 fe			ld (debug_mark),a  
3785 3a 94 37			ld a, (.dmark+1)  
3788 32 b5 fe			ld (debug_mark+1),a  
378b 3a 95 37			ld a, (.dmark+2)  
378e 32 b6 fe			ld (debug_mark+2),a  
3791 18 03			jr .pastdmark  
3793 ..			.dmark: db "EQ1"  
3796 f1			.pastdmark: pop af  
3797			endm  
# End of macro DMARK
3797						CALLMONITOR 
3797 cd 70 17			call break_point_state  
379a				endm  
# End of macro CALLMONITOR
379a					endif 
379a cd de 1d				call forth_push_numhl 
379d			 
379d					NEXTW 
379d c3 47 21			jp macro_next 
37a0				endm 
# End of macro NEXTW
37a0			 
37a0			 
37a0			.ENDLOGIC: 
37a0			; eof 
37a0			 
37a0			 
# End of file forth_words_logic.asm
37a0			include "forth_words_maths.asm" 
37a0			 
37a0			; | ## Maths Words 
37a0			 
37a0			.PLUS:	 
37a0				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
37a0 15				db WORD_SYS_CORE+1             
37a1 e2 37			dw .NEG            
37a3 02				db 1 + 1 
37a4 .. 00			db "+",0              
37a6				endm 
# End of macro CWHEAD
37a6			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
37a6					if DEBUG_FORTH_WORDS_KEY 
37a6						DMARK "PLU" 
37a6 f5				push af  
37a7 3a bb 37			ld a, (.dmark)  
37aa 32 b4 fe			ld (debug_mark),a  
37ad 3a bc 37			ld a, (.dmark+1)  
37b0 32 b5 fe			ld (debug_mark+1),a  
37b3 3a bd 37			ld a, (.dmark+2)  
37b6 32 b6 fe			ld (debug_mark+2),a  
37b9 18 03			jr .pastdmark  
37bb ..			.dmark: db "PLU"  
37be f1			.pastdmark: pop af  
37bf			endm  
# End of macro DMARK
37bf						CALLMONITOR 
37bf cd 70 17			call break_point_state  
37c2				endm  
# End of macro CALLMONITOR
37c2					endif 
37c2					; add top two values and push back result 
37c2			 
37c2					;for v5 FORTH_DSP_VALUE 
37c2					FORTH_DSP 
37c2 cd 9b 1f			call macro_forth_dsp 
37c5				endm 
# End of macro FORTH_DSP
37c5 7e					ld a,(hl)	; get type of value on TOS 
37c6 fe 02				cp DS_TYPE_INUM  
37c8 28 03				jr z, .dot_inum 
37ca			 
37ca					NEXTW 
37ca c3 47 21			jp macro_next 
37cd				endm 
# End of macro NEXTW
37cd			 
37cd			; float maths 
37cd			 
37cd				if FORTH_ENABLE_FLOATMATH 
37cd						inc hl      ; now at start of numeric as string 
37cd			 
37cd					if DEBUG_FORTH_MATHS 
37cd						DMARK "ADD" 
37cd				CALLMONITOR 
37cd					endif 
37cd			 
37cd					;ld ix, hl 
37cd					call CON 
37cd			 
37cd			 
37cd					push hl 
37cd					 
37cd					 
37cd			 
37cd						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
37cd			 
37cd					; get next number 
37cd			 
37cd						FORTH_DSP_VALUE 
37cd			 
37cd						inc hl      ; now at start of numeric as string 
37cd			 
37cd					;ld ix, hl 
37cd					call CON 
37cd			 
37cd					push hl 
37cd			 
37cd			 
37cd						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37cd			 
37cd						; TODO do add 
37cd			 
37cd						call IADD 
37cd			 
37cd						; TODO get result back as ascii 
37cd			 
37cd						; TODO push result  
37cd			 
37cd			 
37cd			 
37cd						jr .dot_done 
37cd				endif 
37cd			 
37cd			.dot_inum: 
37cd			 
37cd			 
37cd					if DEBUG_FORTH_DOT 
37cd						DMARK "+IT" 
37cd				CALLMONITOR 
37cd					endif 
37cd			 
37cd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37cd cd d5 1f			call macro_dsp_valuehl 
37d0				endm 
# End of macro FORTH_DSP_VALUEHL
37d0			 
37d0				; TODO add floating point number detection 
37d0			 
37d0 e5					push hl 
37d1			 
37d1					; destroy value TOS 
37d1			 
37d1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37d1 cd 8d 20			call macro_forth_dsp_pop 
37d4				endm 
# End of macro FORTH_DSP_POP
37d4			 
37d4			 
37d4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37d4 cd d5 1f			call macro_dsp_valuehl 
37d7				endm 
# End of macro FORTH_DSP_VALUEHL
37d7			 
37d7					; one value on hl get other one back 
37d7			 
37d7 d1					pop de 
37d8			 
37d8					; do the add 
37d8			 
37d8 19					add hl,de 
37d9			 
37d9					; save it 
37d9			 
37d9			;		push hl	 
37d9			 
37d9					; 
37d9			 
37d9					; destroy value TOS 
37d9			 
37d9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37d9 cd 8d 20			call macro_forth_dsp_pop 
37dc				endm 
# End of macro FORTH_DSP_POP
37dc			 
37dc					; TODO push value back onto stack for another op etc 
37dc			 
37dc			;		pop hl 
37dc			 
37dc			.dot_done: 
37dc cd de 1d				call forth_push_numhl 
37df			 
37df					NEXTW 
37df c3 47 21			jp macro_next 
37e2				endm 
# End of macro NEXTW
37e2			.NEG: 
37e2			 
37e2				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
37e2 17				db WORD_SYS_CORE+3             
37e3 25 38			dw .DIV            
37e5 02				db 1 + 1 
37e6 .. 00			db "-",0              
37e8				endm 
# End of macro CWHEAD
37e8			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
37e8					if DEBUG_FORTH_WORDS_KEY 
37e8						DMARK "SUB" 
37e8 f5				push af  
37e9 3a fd 37			ld a, (.dmark)  
37ec 32 b4 fe			ld (debug_mark),a  
37ef 3a fe 37			ld a, (.dmark+1)  
37f2 32 b5 fe			ld (debug_mark+1),a  
37f5 3a ff 37			ld a, (.dmark+2)  
37f8 32 b6 fe			ld (debug_mark+2),a  
37fb 18 03			jr .pastdmark  
37fd ..			.dmark: db "SUB"  
3800 f1			.pastdmark: pop af  
3801			endm  
# End of macro DMARK
3801						CALLMONITOR 
3801 cd 70 17			call break_point_state  
3804				endm  
# End of macro CALLMONITOR
3804					endif 
3804			 
3804			 
3804				; TODO add floating point number detection 
3804					; v5 FORTH_DSP_VALUE 
3804					FORTH_DSP 
3804 cd 9b 1f			call macro_forth_dsp 
3807				endm 
# End of macro FORTH_DSP
3807 7e					ld a,(hl)	; get type of value on TOS 
3808 fe 02				cp DS_TYPE_INUM  
380a 28 03				jr z, .neg_inum 
380c			 
380c					NEXTW 
380c c3 47 21			jp macro_next 
380f				endm 
# End of macro NEXTW
380f			 
380f			; float maths 
380f			 
380f				if FORTH_ENABLE_FLOATMATH 
380f					jr .neg_done 
380f			 
380f				endif 
380f					 
380f			 
380f			.neg_inum: 
380f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
380f cd d5 1f			call macro_dsp_valuehl 
3812				endm 
# End of macro FORTH_DSP_VALUEHL
3812			 
3812 e5					push hl 
3813			 
3813					; destroy value TOS 
3813			 
3813					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3813 cd 8d 20			call macro_forth_dsp_pop 
3816				endm 
# End of macro FORTH_DSP_POP
3816			 
3816			 
3816					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3816 cd d5 1f			call macro_dsp_valuehl 
3819				endm 
# End of macro FORTH_DSP_VALUEHL
3819			 
3819					; one value on hl get other one back 
3819			 
3819 d1					pop de 
381a			 
381a					; do the sub 
381a			;		ex de, hl 
381a			 
381a ed 52				sbc hl,de 
381c			 
381c					; save it 
381c			 
381c			;		push hl	 
381c			 
381c					; 
381c			 
381c					; destroy value TOS 
381c			 
381c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
381c cd 8d 20			call macro_forth_dsp_pop 
381f				endm 
# End of macro FORTH_DSP_POP
381f			 
381f					; TODO push value back onto stack for another op etc 
381f			 
381f			;		pop hl 
381f			 
381f cd de 1d				call forth_push_numhl 
3822			.neg_done: 
3822			 
3822					NEXTW 
3822 c3 47 21			jp macro_next 
3825				endm 
# End of macro NEXTW
3825			.DIV: 
3825				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3825 18				db WORD_SYS_CORE+4             
3826 72 38			dw .MUL            
3828 02				db 1 + 1 
3829 .. 00			db "/",0              
382b				endm 
# End of macro CWHEAD
382b			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
382b					if DEBUG_FORTH_WORDS_KEY 
382b						DMARK "DIV" 
382b f5				push af  
382c 3a 40 38			ld a, (.dmark)  
382f 32 b4 fe			ld (debug_mark),a  
3832 3a 41 38			ld a, (.dmark+1)  
3835 32 b5 fe			ld (debug_mark+1),a  
3838 3a 42 38			ld a, (.dmark+2)  
383b 32 b6 fe			ld (debug_mark+2),a  
383e 18 03			jr .pastdmark  
3840 ..			.dmark: db "DIV"  
3843 f1			.pastdmark: pop af  
3844			endm  
# End of macro DMARK
3844						CALLMONITOR 
3844 cd 70 17			call break_point_state  
3847				endm  
# End of macro CALLMONITOR
3847					endif 
3847				; TODO add floating point number detection 
3847					; v5 FORTH_DSP_VALUE 
3847					FORTH_DSP 
3847 cd 9b 1f			call macro_forth_dsp 
384a				endm 
# End of macro FORTH_DSP
384a 7e					ld a,(hl)	; get type of value on TOS 
384b fe 02				cp DS_TYPE_INUM  
384d 28 03				jr z, .div_inum 
384f			 
384f				if FORTH_ENABLE_FLOATMATH 
384f					jr .div_done 
384f			 
384f				endif 
384f					NEXTW 
384f c3 47 21			jp macro_next 
3852				endm 
# End of macro NEXTW
3852			.div_inum: 
3852			 
3852					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3852 cd d5 1f			call macro_dsp_valuehl 
3855				endm 
# End of macro FORTH_DSP_VALUEHL
3855			 
3855 e5					push hl    ; to go to bc 
3856			 
3856					; destroy value TOS 
3856			 
3856					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3856 cd 8d 20			call macro_forth_dsp_pop 
3859				endm 
# End of macro FORTH_DSP_POP
3859			 
3859			 
3859					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3859 cd d5 1f			call macro_dsp_valuehl 
385c				endm 
# End of macro FORTH_DSP_VALUEHL
385c			 
385c					; hl to go to de 
385c			 
385c e5					push hl 
385d			 
385d c1					pop bc 
385e d1					pop de		 
385f			 
385f			 
385f					if DEBUG_FORTH_MATHS 
385f						DMARK "DIV" 
385f				CALLMONITOR 
385f					endif 
385f					; one value on hl but move to a get other one back 
385f			 
385f			        
385f cd 50 0d			call Div16 
3862			 
3862			;	push af	 
3862 e5				push hl 
3863 c5				push bc 
3864			 
3864					if DEBUG_FORTH_MATHS 
3864						DMARK "DI1" 
3864				CALLMONITOR 
3864					endif 
3864			 
3864					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3864 cd 8d 20			call macro_forth_dsp_pop 
3867				endm 
# End of macro FORTH_DSP_POP
3867			 
3867			 
3867			 
3867 e1					pop hl    ; result 
3868			 
3868 cd de 1d				call forth_push_numhl 
386b			 
386b e1					pop hl    ; reminder 
386c			;		ld h,0 
386c			;		ld l,d 
386c			 
386c cd de 1d				call forth_push_numhl 
386f			.div_done: 
386f					NEXTW 
386f c3 47 21			jp macro_next 
3872				endm 
# End of macro NEXTW
3872			.MUL: 
3872				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3872 19				db WORD_SYS_CORE+5             
3873 b7 38			dw .MIN            
3875 02				db 1 + 1 
3876 .. 00			db "*",0              
3878				endm 
# End of macro CWHEAD
3878			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3878				; TODO add floating point number detection 
3878					if DEBUG_FORTH_WORDS_KEY 
3878						DMARK "MUL" 
3878 f5				push af  
3879 3a 8d 38			ld a, (.dmark)  
387c 32 b4 fe			ld (debug_mark),a  
387f 3a 8e 38			ld a, (.dmark+1)  
3882 32 b5 fe			ld (debug_mark+1),a  
3885 3a 8f 38			ld a, (.dmark+2)  
3888 32 b6 fe			ld (debug_mark+2),a  
388b 18 03			jr .pastdmark  
388d ..			.dmark: db "MUL"  
3890 f1			.pastdmark: pop af  
3891			endm  
# End of macro DMARK
3891						CALLMONITOR 
3891 cd 70 17			call break_point_state  
3894				endm  
# End of macro CALLMONITOR
3894					endif 
3894					FORTH_DSP 
3894 cd 9b 1f			call macro_forth_dsp 
3897				endm 
# End of macro FORTH_DSP
3897					; v5 FORTH_DSP_VALUE 
3897 7e					ld a,(hl)	; get type of value on TOS 
3898 fe 02				cp DS_TYPE_INUM  
389a 28 03				jr z, .mul_inum 
389c			 
389c				if FORTH_ENABLE_FLOATMATH 
389c					jr .mul_done 
389c			 
389c				endif 
389c			 
389c					NEXTW 
389c c3 47 21			jp macro_next 
389f				endm 
# End of macro NEXTW
389f			.mul_inum:	 
389f			 
389f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
389f cd d5 1f			call macro_dsp_valuehl 
38a2				endm 
# End of macro FORTH_DSP_VALUEHL
38a2			 
38a2 e5					push hl 
38a3			 
38a3					; destroy value TOS 
38a3			 
38a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38a3 cd 8d 20			call macro_forth_dsp_pop 
38a6				endm 
# End of macro FORTH_DSP_POP
38a6			 
38a6			 
38a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38a6 cd d5 1f			call macro_dsp_valuehl 
38a9				endm 
# End of macro FORTH_DSP_VALUEHL
38a9			 
38a9					; one value on hl but move to a get other one back 
38a9			 
38a9 7d					ld a, l 
38aa			 
38aa d1					pop de 
38ab			 
38ab					; do the mull 
38ab			;		ex de, hl 
38ab			 
38ab cd 76 0d				call Mult16 
38ae					; save it 
38ae			 
38ae			;		push hl	 
38ae			 
38ae					; 
38ae			 
38ae					; destroy value TOS 
38ae			 
38ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38ae cd 8d 20			call macro_forth_dsp_pop 
38b1				endm 
# End of macro FORTH_DSP_POP
38b1			 
38b1					; TODO push value back onto stack for another op etc 
38b1			 
38b1			;		pop hl 
38b1			 
38b1 cd de 1d				call forth_push_numhl 
38b4			 
38b4			.mul_done: 
38b4					NEXTW 
38b4 c3 47 21			jp macro_next 
38b7				endm 
# End of macro NEXTW
38b7			 
38b7			 
38b7			 
38b7			 
38b7			.MIN: 
38b7				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
38b7 49				db WORD_SYS_CORE+53             
38b8 38 39			dw .MAX            
38ba 04				db 3 + 1 
38bb .. 00			db "MIN",0              
38bf				endm 
# End of macro CWHEAD
38bf			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
38bf					if DEBUG_FORTH_WORDS_KEY 
38bf						DMARK "MIN" 
38bf f5				push af  
38c0 3a d4 38			ld a, (.dmark)  
38c3 32 b4 fe			ld (debug_mark),a  
38c6 3a d5 38			ld a, (.dmark+1)  
38c9 32 b5 fe			ld (debug_mark+1),a  
38cc 3a d6 38			ld a, (.dmark+2)  
38cf 32 b6 fe			ld (debug_mark+2),a  
38d2 18 03			jr .pastdmark  
38d4 ..			.dmark: db "MIN"  
38d7 f1			.pastdmark: pop af  
38d8			endm  
# End of macro DMARK
38d8						CALLMONITOR 
38d8 cd 70 17			call break_point_state  
38db				endm  
# End of macro CALLMONITOR
38db					endif 
38db					; get u2 
38db			 
38db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38db cd d5 1f			call macro_dsp_valuehl 
38de				endm 
# End of macro FORTH_DSP_VALUEHL
38de			 
38de e5					push hl   ; u2 
38df			 
38df					; destroy value TOS 
38df			 
38df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38df cd 8d 20			call macro_forth_dsp_pop 
38e2				endm 
# End of macro FORTH_DSP_POP
38e2			 
38e2					; get u1 
38e2			 
38e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38e2 cd d5 1f			call macro_dsp_valuehl 
38e5				endm 
# End of macro FORTH_DSP_VALUEHL
38e5			 
38e5 e5					push hl  ; u1 
38e6			 
38e6					; destroy value TOS 
38e6			 
38e6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38e6 cd 8d 20			call macro_forth_dsp_pop 
38e9				endm 
# End of macro FORTH_DSP_POP
38e9			 
38e9 b7			 or a      ;clear carry flag 
38ea e1			  pop hl    ; u1 
38eb d1			  pop de    ; u2 
38ec e5				push hl   ; saved in case hl is lowest 
38ed ed 52		  sbc hl,de 
38ef 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
38f1			 
38f1 e1				pop hl 
38f2					if DEBUG_FORTH_WORDS 
38f2						DMARK "MIN" 
38f2 f5				push af  
38f3 3a 07 39			ld a, (.dmark)  
38f6 32 b4 fe			ld (debug_mark),a  
38f9 3a 08 39			ld a, (.dmark+1)  
38fc 32 b5 fe			ld (debug_mark+1),a  
38ff 3a 09 39			ld a, (.dmark+2)  
3902 32 b6 fe			ld (debug_mark+2),a  
3905 18 03			jr .pastdmark  
3907 ..			.dmark: db "MIN"  
390a f1			.pastdmark: pop af  
390b			endm  
# End of macro DMARK
390b						CALLMONITOR 
390b cd 70 17			call break_point_state  
390e				endm  
# End of macro CALLMONITOR
390e					endif 
390e cd de 1d				call forth_push_numhl 
3911			 
3911				       NEXTW 
3911 c3 47 21			jp macro_next 
3914				endm 
# End of macro NEXTW
3914			 
3914			.mincont:  
3914 c1				pop bc   ; tidy up 
3915 eb				ex de , hl  
3916					if DEBUG_FORTH_WORDS 
3916						DMARK "MI1" 
3916 f5				push af  
3917 3a 2b 39			ld a, (.dmark)  
391a 32 b4 fe			ld (debug_mark),a  
391d 3a 2c 39			ld a, (.dmark+1)  
3920 32 b5 fe			ld (debug_mark+1),a  
3923 3a 2d 39			ld a, (.dmark+2)  
3926 32 b6 fe			ld (debug_mark+2),a  
3929 18 03			jr .pastdmark  
392b ..			.dmark: db "MI1"  
392e f1			.pastdmark: pop af  
392f			endm  
# End of macro DMARK
392f						CALLMONITOR 
392f cd 70 17			call break_point_state  
3932				endm  
# End of macro CALLMONITOR
3932					endif 
3932 cd de 1d				call forth_push_numhl 
3935			 
3935				       NEXTW 
3935 c3 47 21			jp macro_next 
3938				endm 
# End of macro NEXTW
3938			.MAX: 
3938				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3938 4a				db WORD_SYS_CORE+54             
3939 b9 39			dw .RND16            
393b 04				db 3 + 1 
393c .. 00			db "MAX",0              
3940				endm 
# End of macro CWHEAD
3940			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3940					if DEBUG_FORTH_WORDS_KEY 
3940						DMARK "MAX" 
3940 f5				push af  
3941 3a 55 39			ld a, (.dmark)  
3944 32 b4 fe			ld (debug_mark),a  
3947 3a 56 39			ld a, (.dmark+1)  
394a 32 b5 fe			ld (debug_mark+1),a  
394d 3a 57 39			ld a, (.dmark+2)  
3950 32 b6 fe			ld (debug_mark+2),a  
3953 18 03			jr .pastdmark  
3955 ..			.dmark: db "MAX"  
3958 f1			.pastdmark: pop af  
3959			endm  
# End of macro DMARK
3959						CALLMONITOR 
3959 cd 70 17			call break_point_state  
395c				endm  
# End of macro CALLMONITOR
395c					endif 
395c					; get u2 
395c			 
395c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
395c cd d5 1f			call macro_dsp_valuehl 
395f				endm 
# End of macro FORTH_DSP_VALUEHL
395f			 
395f e5					push hl   ; u2 
3960			 
3960					; destroy value TOS 
3960			 
3960					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3960 cd 8d 20			call macro_forth_dsp_pop 
3963				endm 
# End of macro FORTH_DSP_POP
3963			 
3963					; get u1 
3963			 
3963					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3963 cd d5 1f			call macro_dsp_valuehl 
3966				endm 
# End of macro FORTH_DSP_VALUEHL
3966			 
3966 e5					push hl  ; u1 
3967			 
3967					; destroy value TOS 
3967			 
3967					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3967 cd 8d 20			call macro_forth_dsp_pop 
396a				endm 
# End of macro FORTH_DSP_POP
396a			 
396a b7			 or a      ;clear carry flag 
396b e1			  pop hl    ; u1 
396c d1			  pop de    ; u2 
396d e5				push hl   ; saved in case hl is lowest 
396e ed 52		  sbc hl,de 
3970 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3972			 
3972 e1				pop hl 
3973					if DEBUG_FORTH_WORDS 
3973						DMARK "MAX" 
3973 f5				push af  
3974 3a 88 39			ld a, (.dmark)  
3977 32 b4 fe			ld (debug_mark),a  
397a 3a 89 39			ld a, (.dmark+1)  
397d 32 b5 fe			ld (debug_mark+1),a  
3980 3a 8a 39			ld a, (.dmark+2)  
3983 32 b6 fe			ld (debug_mark+2),a  
3986 18 03			jr .pastdmark  
3988 ..			.dmark: db "MAX"  
398b f1			.pastdmark: pop af  
398c			endm  
# End of macro DMARK
398c						CALLMONITOR 
398c cd 70 17			call break_point_state  
398f				endm  
# End of macro CALLMONITOR
398f					endif 
398f cd de 1d				call forth_push_numhl 
3992			 
3992				       NEXTW 
3992 c3 47 21			jp macro_next 
3995				endm 
# End of macro NEXTW
3995			 
3995			.maxcont:  
3995 c1				pop bc   ; tidy up 
3996 eb				ex de , hl  
3997					if DEBUG_FORTH_WORDS 
3997						DMARK "MA1" 
3997 f5				push af  
3998 3a ac 39			ld a, (.dmark)  
399b 32 b4 fe			ld (debug_mark),a  
399e 3a ad 39			ld a, (.dmark+1)  
39a1 32 b5 fe			ld (debug_mark+1),a  
39a4 3a ae 39			ld a, (.dmark+2)  
39a7 32 b6 fe			ld (debug_mark+2),a  
39aa 18 03			jr .pastdmark  
39ac ..			.dmark: db "MA1"  
39af f1			.pastdmark: pop af  
39b0			endm  
# End of macro DMARK
39b0						CALLMONITOR 
39b0 cd 70 17			call break_point_state  
39b3				endm  
# End of macro CALLMONITOR
39b3					endif 
39b3 cd de 1d				call forth_push_numhl 
39b6				       NEXTW 
39b6 c3 47 21			jp macro_next 
39b9				endm 
# End of macro NEXTW
39b9			 
39b9			.RND16: 
39b9				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
39b9 4e				db WORD_SYS_CORE+58             
39ba e8 39			dw .RND8            
39bc 06				db 5 + 1 
39bd .. 00			db "RND16",0              
39c3				endm 
# End of macro CWHEAD
39c3			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
39c3					if DEBUG_FORTH_WORDS_KEY 
39c3						DMARK "R16" 
39c3 f5				push af  
39c4 3a d8 39			ld a, (.dmark)  
39c7 32 b4 fe			ld (debug_mark),a  
39ca 3a d9 39			ld a, (.dmark+1)  
39cd 32 b5 fe			ld (debug_mark+1),a  
39d0 3a da 39			ld a, (.dmark+2)  
39d3 32 b6 fe			ld (debug_mark+2),a  
39d6 18 03			jr .pastdmark  
39d8 ..			.dmark: db "R16"  
39db f1			.pastdmark: pop af  
39dc			endm  
# End of macro DMARK
39dc						CALLMONITOR 
39dc cd 70 17			call break_point_state  
39df				endm  
# End of macro CALLMONITOR
39df					endif 
39df cd 1a 0d				call prng16  
39e2 cd de 1d				call forth_push_numhl 
39e5				       NEXTW 
39e5 c3 47 21			jp macro_next 
39e8				endm 
# End of macro NEXTW
39e8			.RND8: 
39e8				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
39e8 60				db WORD_SYS_CORE+76             
39e9 1d 3a			dw .RND            
39eb 05				db 4 + 1 
39ec .. 00			db "RND8",0              
39f1				endm 
# End of macro CWHEAD
39f1			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
39f1					if DEBUG_FORTH_WORDS_KEY 
39f1						DMARK "RN8" 
39f1 f5				push af  
39f2 3a 06 3a			ld a, (.dmark)  
39f5 32 b4 fe			ld (debug_mark),a  
39f8 3a 07 3a			ld a, (.dmark+1)  
39fb 32 b5 fe			ld (debug_mark+1),a  
39fe 3a 08 3a			ld a, (.dmark+2)  
3a01 32 b6 fe			ld (debug_mark+2),a  
3a04 18 03			jr .pastdmark  
3a06 ..			.dmark: db "RN8"  
3a09 f1			.pastdmark: pop af  
3a0a			endm  
# End of macro DMARK
3a0a						CALLMONITOR 
3a0a cd 70 17			call break_point_state  
3a0d				endm  
# End of macro CALLMONITOR
3a0d					endif 
3a0d 2a 35 fd				ld hl,(xrandc) 
3a10 23					inc hl 
3a11 cd 34 0d				call xrnd 
3a14 6f					ld l,a	 
3a15 26 00				ld h,0 
3a17 cd de 1d				call forth_push_numhl 
3a1a				       NEXTW 
3a1a c3 47 21			jp macro_next 
3a1d				endm 
# End of macro NEXTW
3a1d			.RND: 
3a1d				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3a1d 60				db WORD_SYS_CORE+76             
3a1e 23 3b			dw .ENDMATHS            
3a20 04				db 3 + 1 
3a21 .. 00			db "RND",0              
3a25				endm 
# End of macro CWHEAD
3a25			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3a25			 
3a25					if DEBUG_FORTH_WORDS_KEY 
3a25						DMARK "RND" 
3a25 f5				push af  
3a26 3a 3a 3a			ld a, (.dmark)  
3a29 32 b4 fe			ld (debug_mark),a  
3a2c 3a 3b 3a			ld a, (.dmark+1)  
3a2f 32 b5 fe			ld (debug_mark+1),a  
3a32 3a 3c 3a			ld a, (.dmark+2)  
3a35 32 b6 fe			ld (debug_mark+2),a  
3a38 18 03			jr .pastdmark  
3a3a ..			.dmark: db "RND"  
3a3d f1			.pastdmark: pop af  
3a3e			endm  
# End of macro DMARK
3a3e						CALLMONITOR 
3a3e cd 70 17			call break_point_state  
3a41				endm  
# End of macro CALLMONITOR
3a41					endif 
3a41					 
3a41					FORTH_DSP_VALUEHL    ; upper range 
3a41 cd d5 1f			call macro_dsp_valuehl 
3a44				endm 
# End of macro FORTH_DSP_VALUEHL
3a44			 
3a44 22 39 fd				ld (LFSRSeed), hl	 
3a47			 
3a47					if DEBUG_FORTH_WORDS 
3a47						DMARK "RN1" 
3a47 f5				push af  
3a48 3a 5c 3a			ld a, (.dmark)  
3a4b 32 b4 fe			ld (debug_mark),a  
3a4e 3a 5d 3a			ld a, (.dmark+1)  
3a51 32 b5 fe			ld (debug_mark+1),a  
3a54 3a 5e 3a			ld a, (.dmark+2)  
3a57 32 b6 fe			ld (debug_mark+2),a  
3a5a 18 03			jr .pastdmark  
3a5c ..			.dmark: db "RN1"  
3a5f f1			.pastdmark: pop af  
3a60			endm  
# End of macro DMARK
3a60						CALLMONITOR 
3a60 cd 70 17			call break_point_state  
3a63				endm  
# End of macro CALLMONITOR
3a63					endif 
3a63					FORTH_DSP_POP 
3a63 cd 8d 20			call macro_forth_dsp_pop 
3a66				endm 
# End of macro FORTH_DSP_POP
3a66			 
3a66					FORTH_DSP_VALUEHL    ; low range 
3a66 cd d5 1f			call macro_dsp_valuehl 
3a69				endm 
# End of macro FORTH_DSP_VALUEHL
3a69			 
3a69					if DEBUG_FORTH_WORDS 
3a69						DMARK "RN2" 
3a69 f5				push af  
3a6a 3a 7e 3a			ld a, (.dmark)  
3a6d 32 b4 fe			ld (debug_mark),a  
3a70 3a 7f 3a			ld a, (.dmark+1)  
3a73 32 b5 fe			ld (debug_mark+1),a  
3a76 3a 80 3a			ld a, (.dmark+2)  
3a79 32 b6 fe			ld (debug_mark+2),a  
3a7c 18 03			jr .pastdmark  
3a7e ..			.dmark: db "RN2"  
3a81 f1			.pastdmark: pop af  
3a82			endm  
# End of macro DMARK
3a82						CALLMONITOR 
3a82 cd 70 17			call break_point_state  
3a85				endm  
# End of macro CALLMONITOR
3a85					endif 
3a85 22 3b fd				ld (LFSRSeed+2), hl 
3a88			 
3a88					FORTH_DSP_POP 
3a88 cd 8d 20			call macro_forth_dsp_pop 
3a8b				endm 
# End of macro FORTH_DSP_POP
3a8b			 
3a8b e5					push hl 
3a8c			 
3a8c e1			.inrange:	pop hl 
3a8d cd 1a 0d				call prng16  
3a90					if DEBUG_FORTH_WORDS 
3a90						DMARK "RN3" 
3a90 f5				push af  
3a91 3a a5 3a			ld a, (.dmark)  
3a94 32 b4 fe			ld (debug_mark),a  
3a97 3a a6 3a			ld a, (.dmark+1)  
3a9a 32 b5 fe			ld (debug_mark+1),a  
3a9d 3a a7 3a			ld a, (.dmark+2)  
3aa0 32 b6 fe			ld (debug_mark+2),a  
3aa3 18 03			jr .pastdmark  
3aa5 ..			.dmark: db "RN3"  
3aa8 f1			.pastdmark: pop af  
3aa9			endm  
# End of macro DMARK
3aa9						CALLMONITOR 
3aa9 cd 70 17			call break_point_state  
3aac				endm  
# End of macro CALLMONITOR
3aac					endif 
3aac					 
3aac					; if the range is 8bit knock out the high byte 
3aac			 
3aac ed 5b 39 fd			ld de, (LFSRSeed)     ; check high level 
3ab0			 
3ab0 3e 00				ld a, 0 
3ab2 ba					cp d  
3ab3 20 1e				jr nz, .hirange 
3ab5 26 00				ld h, 0   ; knock it down to 8bit 
3ab7			 
3ab7					if DEBUG_FORTH_WORDS 
3ab7						DMARK "RNk" 
3ab7 f5				push af  
3ab8 3a cc 3a			ld a, (.dmark)  
3abb 32 b4 fe			ld (debug_mark),a  
3abe 3a cd 3a			ld a, (.dmark+1)  
3ac1 32 b5 fe			ld (debug_mark+1),a  
3ac4 3a ce 3a			ld a, (.dmark+2)  
3ac7 32 b6 fe			ld (debug_mark+2),a  
3aca 18 03			jr .pastdmark  
3acc ..			.dmark: db "RNk"  
3acf f1			.pastdmark: pop af  
3ad0			endm  
# End of macro DMARK
3ad0						CALLMONITOR 
3ad0 cd 70 17			call break_point_state  
3ad3				endm  
# End of macro CALLMONITOR
3ad3					endif 
3ad3			.hirange:   
3ad3 e5					push hl  
3ad4 b7					or a  
3ad5 ed 52		                sbc hl, de 
3ad7			 
3ad7					;call cmp16 
3ad7			 
3ad7 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3ad9 e1					pop hl 
3ada e5					push hl 
3adb			 
3adb					if DEBUG_FORTH_WORDS 
3adb						DMARK "RN4" 
3adb f5				push af  
3adc 3a f0 3a			ld a, (.dmark)  
3adf 32 b4 fe			ld (debug_mark),a  
3ae2 3a f1 3a			ld a, (.dmark+1)  
3ae5 32 b5 fe			ld (debug_mark+1),a  
3ae8 3a f2 3a			ld a, (.dmark+2)  
3aeb 32 b6 fe			ld (debug_mark+2),a  
3aee 18 03			jr .pastdmark  
3af0 ..			.dmark: db "RN4"  
3af3 f1			.pastdmark: pop af  
3af4			endm  
# End of macro DMARK
3af4						CALLMONITOR 
3af4 cd 70 17			call break_point_state  
3af7				endm  
# End of macro CALLMONITOR
3af7					endif 
3af7 ed 5b 3b fd			ld de, (LFSRSeed+2)   ; check low range 
3afb					;call cmp16 
3afb				 
3afb b7					or a  
3afc ed 52		                sbc hl, de 
3afe 38 8c				jr c, .inrange 
3b00			 
3b00 e1					pop hl 
3b01					 
3b01					if DEBUG_FORTH_WORDS 
3b01						DMARK "RNd" 
3b01 f5				push af  
3b02 3a 16 3b			ld a, (.dmark)  
3b05 32 b4 fe			ld (debug_mark),a  
3b08 3a 17 3b			ld a, (.dmark+1)  
3b0b 32 b5 fe			ld (debug_mark+1),a  
3b0e 3a 18 3b			ld a, (.dmark+2)  
3b11 32 b6 fe			ld (debug_mark+2),a  
3b14 18 03			jr .pastdmark  
3b16 ..			.dmark: db "RNd"  
3b19 f1			.pastdmark: pop af  
3b1a			endm  
# End of macro DMARK
3b1a						CALLMONITOR 
3b1a cd 70 17			call break_point_state  
3b1d				endm  
# End of macro CALLMONITOR
3b1d					endif 
3b1d			 
3b1d			 
3b1d cd de 1d				call forth_push_numhl 
3b20				       NEXTW 
3b20 c3 47 21			jp macro_next 
3b23				endm 
# End of macro NEXTW
3b23			 
3b23			.ENDMATHS: 
3b23			 
3b23			; eof 
3b23			 
# End of file forth_words_maths.asm
3b23			include "forth_words_display.asm" 
3b23			 
3b23			; | ## Display Words 
3b23			 
3b23			.INFO: 
3b23			 
3b23				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3b23 62				db WORD_SYS_CORE+78             
3b24 40 3b			dw .ATP            
3b26 05				db 4 + 1 
3b27 .. 00			db "INFO",0              
3b2c				endm 
# End of macro CWHEAD
3b2c			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3b2c					FORTH_DSP_VALUEHL 
3b2c cd d5 1f			call macro_dsp_valuehl 
3b2f				endm 
# End of macro FORTH_DSP_VALUEHL
3b2f			 
3b2f					FORTH_DSP_POP 
3b2f cd 8d 20			call macro_forth_dsp_pop 
3b32				endm 
# End of macro FORTH_DSP_POP
3b32			 
3b32 e5					push hl 
3b33			 
3b33					FORTH_DSP_VALUEHL 
3b33 cd d5 1f			call macro_dsp_valuehl 
3b36				endm 
# End of macro FORTH_DSP_VALUEHL
3b36			 
3b36					FORTH_DSP_POP 
3b36 cd 8d 20			call macro_forth_dsp_pop 
3b39				endm 
# End of macro FORTH_DSP_POP
3b39			 
3b39 d1					pop de 
3b3a			 
3b3a cd 50 0b				call info_panel 
3b3d			 
3b3d			 
3b3d					NEXTW 
3b3d c3 47 21			jp macro_next 
3b40				endm 
# End of macro NEXTW
3b40			.ATP: 
3b40				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3b40 62				db WORD_SYS_CORE+78             
3b41 b7 3b			dw .FB            
3b43 04				db 3 + 1 
3b44 .. 00			db "AT?",0              
3b48				endm 
# End of macro CWHEAD
3b48			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3b48					if DEBUG_FORTH_WORDS_KEY 
3b48						DMARK "AT?" 
3b48 f5				push af  
3b49 3a 5d 3b			ld a, (.dmark)  
3b4c 32 b4 fe			ld (debug_mark),a  
3b4f 3a 5e 3b			ld a, (.dmark+1)  
3b52 32 b5 fe			ld (debug_mark+1),a  
3b55 3a 5f 3b			ld a, (.dmark+2)  
3b58 32 b6 fe			ld (debug_mark+2),a  
3b5b 18 03			jr .pastdmark  
3b5d ..			.dmark: db "AT?"  
3b60 f1			.pastdmark: pop af  
3b61			endm  
# End of macro DMARK
3b61						CALLMONITOR 
3b61 cd 70 17			call break_point_state  
3b64				endm  
# End of macro CALLMONITOR
3b64					endif 
3b64 3a c3 fc				ld a, (f_cursor_ptr) 
3b67			 
3b67			if DEBUG_FORTH_WORDS 
3b67				DMARK "AT?" 
3b67 f5				push af  
3b68 3a 7c 3b			ld a, (.dmark)  
3b6b 32 b4 fe			ld (debug_mark),a  
3b6e 3a 7d 3b			ld a, (.dmark+1)  
3b71 32 b5 fe			ld (debug_mark+1),a  
3b74 3a 7e 3b			ld a, (.dmark+2)  
3b77 32 b6 fe			ld (debug_mark+2),a  
3b7a 18 03			jr .pastdmark  
3b7c ..			.dmark: db "AT?"  
3b7f f1			.pastdmark: pop af  
3b80			endm  
# End of macro DMARK
3b80				CALLMONITOR 
3b80 cd 70 17			call break_point_state  
3b83				endm  
# End of macro CALLMONITOR
3b83			endif	 
3b83					; count the number of rows 
3b83			 
3b83 06 00				ld b, 0 
3b85 4f			.atpr:		ld c, a    ; save in case we go below zero 
3b86 d6 14				sub display_cols 
3b88 f2 8e 3b				jp p, .atprunder 
3b8b 04					inc b 
3b8c 18 f7				jr .atpr 
3b8e			.atprunder:	 
3b8e			if DEBUG_FORTH_WORDS 
3b8e				DMARK "A?2" 
3b8e f5				push af  
3b8f 3a a3 3b			ld a, (.dmark)  
3b92 32 b4 fe			ld (debug_mark),a  
3b95 3a a4 3b			ld a, (.dmark+1)  
3b98 32 b5 fe			ld (debug_mark+1),a  
3b9b 3a a5 3b			ld a, (.dmark+2)  
3b9e 32 b6 fe			ld (debug_mark+2),a  
3ba1 18 03			jr .pastdmark  
3ba3 ..			.dmark: db "A?2"  
3ba6 f1			.pastdmark: pop af  
3ba7			endm  
# End of macro DMARK
3ba7				CALLMONITOR 
3ba7 cd 70 17			call break_point_state  
3baa				endm  
# End of macro CALLMONITOR
3baa			endif	 
3baa 26 00				ld h, 0 
3bac 69					ld l, c 
3bad cd de 1d				call forth_push_numhl 
3bb0 68					ld l, b  
3bb1 cd de 1d				call forth_push_numhl 
3bb4			 
3bb4			 
3bb4				NEXTW 
3bb4 c3 47 21			jp macro_next 
3bb7				endm 
# End of macro NEXTW
3bb7			 
3bb7			.FB: 
3bb7				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3bb7 1b				db WORD_SYS_CORE+7             
3bb8 05 3c			dw .EMIT            
3bba 03				db 2 + 1 
3bbb .. 00			db "FB",0              
3bbe				endm 
# End of macro CWHEAD
3bbe			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3bbe			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3bbe			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3bbe			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3bbe					if DEBUG_FORTH_WORDS_KEY 
3bbe						DMARK "FB." 
3bbe f5				push af  
3bbf 3a d3 3b			ld a, (.dmark)  
3bc2 32 b4 fe			ld (debug_mark),a  
3bc5 3a d4 3b			ld a, (.dmark+1)  
3bc8 32 b5 fe			ld (debug_mark+1),a  
3bcb 3a d5 3b			ld a, (.dmark+2)  
3bce 32 b6 fe			ld (debug_mark+2),a  
3bd1 18 03			jr .pastdmark  
3bd3 ..			.dmark: db "FB."  
3bd6 f1			.pastdmark: pop af  
3bd7			endm  
# End of macro DMARK
3bd7						CALLMONITOR 
3bd7 cd 70 17			call break_point_state  
3bda				endm  
# End of macro CALLMONITOR
3bda					endif 
3bda			 
3bda					FORTH_DSP_VALUEHL 
3bda cd d5 1f			call macro_dsp_valuehl 
3bdd				endm 
# End of macro FORTH_DSP_VALUEHL
3bdd			 
3bdd 7d					ld a, l 
3bde fe 01				cp 1 
3be0 20 05				jr nz, .fbn1 
3be2 21 f9 fd				ld hl, display_fb1 
3be5 18 15				jr .fbset 
3be7 fe 02		.fbn1:		cp 2 
3be9 20 05				jr nz, .fbn2 
3beb 21 57 fd				ld hl, display_fb2 
3bee 18 0c				jr .fbset 
3bf0 fe 03		.fbn2:		cp 3 
3bf2 20 05				jr nz, .fbn3 
3bf4 21 a8 fd				ld hl, display_fb3 
3bf7 18 03				jr .fbset 
3bf9			.fbn3:		 ; if invalid number select first 
3bf9 21 f9 fd				ld hl, display_fb1 
3bfc 22 55 fd		.fbset:		ld (display_fb_active), hl 
3bff			 
3bff					FORTH_DSP_POP 
3bff cd 8d 20			call macro_forth_dsp_pop 
3c02				endm 
# End of macro FORTH_DSP_POP
3c02			 
3c02					NEXTW 
3c02 c3 47 21			jp macro_next 
3c05				endm 
# End of macro NEXTW
3c05			 
3c05			 
3c05			.EMIT: 
3c05				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3c05 1b				db WORD_SYS_CORE+7             
3c06 56 3c			dw .DOTH            
3c08 05				db 4 + 1 
3c09 .. 00			db "EMIT",0              
3c0e				endm 
# End of macro CWHEAD
3c0e			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3c0e					; get value off TOS and display it 
3c0e			 
3c0e					if DEBUG_FORTH_WORDS_KEY 
3c0e						DMARK "EMT" 
3c0e f5				push af  
3c0f 3a 23 3c			ld a, (.dmark)  
3c12 32 b4 fe			ld (debug_mark),a  
3c15 3a 24 3c			ld a, (.dmark+1)  
3c18 32 b5 fe			ld (debug_mark+1),a  
3c1b 3a 25 3c			ld a, (.dmark+2)  
3c1e 32 b6 fe			ld (debug_mark+2),a  
3c21 18 03			jr .pastdmark  
3c23 ..			.dmark: db "EMT"  
3c26 f1			.pastdmark: pop af  
3c27			endm  
# End of macro DMARK
3c27						CALLMONITOR 
3c27 cd 70 17			call break_point_state  
3c2a				endm  
# End of macro CALLMONITOR
3c2a					endif 
3c2a			 
3c2a					FORTH_DSP_VALUEHL 
3c2a cd d5 1f			call macro_dsp_valuehl 
3c2d				endm 
# End of macro FORTH_DSP_VALUEHL
3c2d			 
3c2d 7d					ld a,l 
3c2e			 
3c2e					; TODO write to display 
3c2e			 
3c2e 32 58 f6				ld (os_input), a 
3c31 3e 00				ld a, 0 
3c33 32 59 f6				ld (os_input+1), a 
3c36					 
3c36 3a c3 fc				ld a, (f_cursor_ptr) 
3c39 11 58 f6				ld de, os_input 
3c3c cd d2 0b				call str_at_display 
3c3f			 
3c3f			 
3c3f 3a a1 fc				ld a,(cli_autodisplay) 
3c42 fe 00				cp 0 
3c44 28 03				jr z, .enoupdate 
3c46 cd e2 0b						call update_display 
3c49					.enoupdate: 
3c49			 
3c49 3a c3 fc				ld a, (f_cursor_ptr) 
3c4c 3c					inc a 
3c4d 32 c3 fc				ld (f_cursor_ptr), a   ; save new pos 
3c50			 
3c50			 
3c50					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c50 cd 8d 20			call macro_forth_dsp_pop 
3c53				endm 
# End of macro FORTH_DSP_POP
3c53			  
3c53			 
3c53					NEXTW 
3c53 c3 47 21			jp macro_next 
3c56				endm 
# End of macro NEXTW
3c56			.DOTH: 
3c56				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3c56 1c				db WORD_SYS_CORE+8             
3c57 86 3c			dw .DOTF            
3c59 03				db 2 + 1 
3c5a .. 00			db ".-",0              
3c5d				endm 
# End of macro CWHEAD
3c5d			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3c5d					; get value off TOS and display it 
3c5d					if DEBUG_FORTH_WORDS_KEY 
3c5d						DMARK "DTD" 
3c5d f5				push af  
3c5e 3a 72 3c			ld a, (.dmark)  
3c61 32 b4 fe			ld (debug_mark),a  
3c64 3a 73 3c			ld a, (.dmark+1)  
3c67 32 b5 fe			ld (debug_mark+1),a  
3c6a 3a 74 3c			ld a, (.dmark+2)  
3c6d 32 b6 fe			ld (debug_mark+2),a  
3c70 18 03			jr .pastdmark  
3c72 ..			.dmark: db "DTD"  
3c75 f1			.pastdmark: pop af  
3c76			endm  
# End of macro DMARK
3c76						CALLMONITOR 
3c76 cd 70 17			call break_point_state  
3c79				endm  
# End of macro CALLMONITOR
3c79					endif 
3c79 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3c7b 3e 00			ld a, 0 
3c7d 32 a2 fc			ld (cli_mvdot), a 
3c80 c3 dd 3c			jp .dotgo 
3c83				NEXTW 
3c83 c3 47 21			jp macro_next 
3c86				endm 
# End of macro NEXTW
3c86			.DOTF: 
3c86				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3c86 1c				db WORD_SYS_CORE+8             
3c87 b4 3c			dw .DOT            
3c89 03				db 2 + 1 
3c8a .. 00			db ".>",0              
3c8d				endm 
# End of macro CWHEAD
3c8d			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3c8d					; get value off TOS and display it 
3c8d			        ; TODO BUG adds extra spaces 
3c8d			        ; TODO BUG handle numerics? 
3c8d					if DEBUG_FORTH_WORDS_KEY 
3c8d						DMARK "DTC" 
3c8d f5				push af  
3c8e 3a a2 3c			ld a, (.dmark)  
3c91 32 b4 fe			ld (debug_mark),a  
3c94 3a a3 3c			ld a, (.dmark+1)  
3c97 32 b5 fe			ld (debug_mark+1),a  
3c9a 3a a4 3c			ld a, (.dmark+2)  
3c9d 32 b6 fe			ld (debug_mark+2),a  
3ca0 18 03			jr .pastdmark  
3ca2 ..			.dmark: db "DTC"  
3ca5 f1			.pastdmark: pop af  
3ca6			endm  
# End of macro DMARK
3ca6						CALLMONITOR 
3ca6 cd 70 17			call break_point_state  
3ca9				endm  
# End of macro CALLMONITOR
3ca9					endif 
3ca9 3e 01			ld a, 1 
3cab 32 a2 fc			ld (cli_mvdot), a 
3cae c3 dd 3c			jp .dotgo 
3cb1				NEXTW 
3cb1 c3 47 21			jp macro_next 
3cb4				endm 
# End of macro NEXTW
3cb4			 
3cb4			.DOT: 
3cb4				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3cb4 1c				db WORD_SYS_CORE+8             
3cb5 40 3d			dw .CLS            
3cb7 02				db 1 + 1 
3cb8 .. 00			db ".",0              
3cba				endm 
# End of macro CWHEAD
3cba			        ; | . ( u -- ) Display TOS | DONE 
3cba					; get value off TOS and display it 
3cba			 
3cba					if DEBUG_FORTH_WORDS_KEY 
3cba						DMARK "DOT" 
3cba f5				push af  
3cbb 3a cf 3c			ld a, (.dmark)  
3cbe 32 b4 fe			ld (debug_mark),a  
3cc1 3a d0 3c			ld a, (.dmark+1)  
3cc4 32 b5 fe			ld (debug_mark+1),a  
3cc7 3a d1 3c			ld a, (.dmark+2)  
3cca 32 b6 fe			ld (debug_mark+2),a  
3ccd 18 03			jr .pastdmark  
3ccf ..			.dmark: db "DOT"  
3cd2 f1			.pastdmark: pop af  
3cd3			endm  
# End of macro DMARK
3cd3						CALLMONITOR 
3cd3 cd 70 17			call break_point_state  
3cd6				endm  
# End of macro CALLMONITOR
3cd6					endif 
3cd6 3e 00			ld a, 0 
3cd8 32 a2 fc			ld (cli_mvdot), a 
3cdb 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3cdd				 
3cdd			 
3cdd			.dotgo: 
3cdd			 
3cdd			; move up type to on stack for parserv5 
3cdd					FORTH_DSP 
3cdd cd 9b 1f			call macro_forth_dsp 
3ce0				endm 
# End of macro FORTH_DSP
3ce0				;FORTH_DSP_VALUE  
3ce0			 
3ce0			if DEBUG_FORTH_DOT 
3ce0				DMARK "DOT" 
3ce0				CALLMONITOR 
3ce0			endif	 
3ce0			;		.print: 
3ce0			 
3ce0 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3ce1 23				inc hl   ; position to the actual value 
3ce2 fe 01			cp DS_TYPE_STR 
3ce4 20 06			jr nz, .dotnum1  
3ce6			 
3ce6			; display string 
3ce6				FORTH_DSP_VALUE  
3ce6 cd be 1f			call macro_forth_dsp_value 
3ce9				endm 
# End of macro FORTH_DSP_VALUE
3ce9 eb				ex de,hl 
3cea 18 11			jr .dotwrite 
3cec			 
3cec			.dotnum1: 
3cec fe 02			cp DS_TYPE_INUM 
3cee 20 0c			jr nz, .dotflot 
3cf0			 
3cf0			 
3cf0			; display number 
3cf0			 
3cf0			;	push hl 
3cf0			;	call clear_display 
3cf0			;	pop hl 
3cf0			 
3cf0 5e				ld e, (hl) 
3cf1 23				inc hl 
3cf2 56				ld d, (hl) 
3cf3 21 5a f4			ld hl, scratch 
3cf6			if DEBUG_FORTH_DOT 
3cf6				DMARK "DT1" 
3cf6				CALLMONITOR 
3cf6			endif	 
3cf6			 
3cf6 cd 00 12			call uitoa_16 
3cf9 eb				ex de,hl 
3cfa			 
3cfa			if DEBUG_FORTH_DOT 
3cfa				DMARK "DT2" 
3cfa				CALLMONITOR 
3cfa			endif	 
3cfa			 
3cfa			;	ld de, os_word_scratch 
3cfa 18 01			jr .dotwrite 
3cfc			 
3cfc 00			.dotflot:   nop 
3cfd			; TODO print floating point number 
3cfd			 
3cfd			.dotwrite:		 
3cfd			 
3cfd					; if c is set then set all '-' to spaces 
3cfd					; need to also take into account .>  
3cfd			 
3cfd 3e 01				ld a, 1 
3cff b9					cp c 
3d00 20 13				jr nz, .nodashswap 
3d02			 
3d02					; DE has the string to write, working with HL 
3d02			 
3d02 06 ff				ld b, 255 
3d04 d5					push de 
3d05 e1					pop hl 
3d06			 
3d06			if DEBUG_FORTH_DOT 
3d06				DMARK "DT-" 
3d06				CALLMONITOR 
3d06			endif	 
3d06 7e			.dashscan:	ld a, (hl) 
3d07 fe 00				cp 0 
3d09 28 0a				jr z, .nodashswap 
3d0b fe 2d				cp '-' 
3d0d 20 03				jr nz, .dashskip 
3d0f 3e 20				ld a, ' ' 
3d11 77					ld (hl), a 
3d12 23			.dashskip:	inc hl 
3d13			if DEBUG_FORTH_DOT 
3d13				DMARK "D-2" 
3d13				CALLMONITOR 
3d13			endif	 
3d13 10 f1				djnz .dashscan 
3d15			 
3d15			if DEBUG_FORTH_DOT 
3d15				DMARK "D-1" 
3d15				CALLMONITOR 
3d15			endif	 
3d15			 
3d15			.nodashswap: 
3d15			 
3d15 e5					push hl   ; save string start in case we need to advance print 
3d16			 
3d16 3a c3 fc				ld a, (f_cursor_ptr) 
3d19 cd d2 0b				call str_at_display 
3d1c 3a a1 fc				ld a,(cli_autodisplay) 
3d1f fe 00				cp 0 
3d21 28 03				jr z, .noupdate 
3d23 cd e2 0b						call update_display 
3d26					.noupdate: 
3d26			 
3d26			 
3d26					; see if we need to advance the print position 
3d26			 
3d26 e1					pop hl   ; get back string 
3d27			 
3d27 3a a2 fc				ld a, (cli_mvdot) 
3d2a			if DEBUG_FORTH_DOT 
3d2a					ld e,a 
3d2a				DMARK "D>1" 
3d2a				CALLMONITOR 
3d2a			endif	 
3d2a fe 00				cp 0 
3d2c 28 0c				jr z, .noadv 
3d2e					; yes, lets advance the print position 
3d2e 3e 00				ld a, 0 
3d30 cd 5c 12				call strlent 
3d33 3a c3 fc				ld a, (f_cursor_ptr) 
3d36 85					add a,l 
3d37					;call addatohl 
3d37					;ld a, l 
3d37 32 c3 fc				ld (f_cursor_ptr), a   ; save new pos 
3d3a			 
3d3a			if DEBUG_FORTH_DOT 
3d3a				DMARK "D->" 
3d3a				CALLMONITOR 
3d3a			endif	 
3d3a			 
3d3a			.noadv:	 
3d3a			 
3d3a					if DEBUG_FORTH_DOT_WAIT 
3d3a							call next_page_prompt 
3d3a					endif	 
3d3a			; TODO this pop off the stack causes a crash. i dont know why 
3d3a			 
3d3a			 
3d3a			if DEBUG_FORTH_DOT 
3d3a				DMARK "DTh" 
3d3a				CALLMONITOR 
3d3a			endif	 
3d3a			 
3d3a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d3a cd 8d 20			call macro_forth_dsp_pop 
3d3d				endm 
# End of macro FORTH_DSP_POP
3d3d			 
3d3d			if DEBUG_FORTH_DOT 
3d3d				DMARK "DTi" 
3d3d				CALLMONITOR 
3d3d			endif	 
3d3d			 
3d3d			 
3d3d					NEXTW 
3d3d c3 47 21			jp macro_next 
3d40				endm 
# End of macro NEXTW
3d40			 
3d40			.CLS: 
3d40				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3d40 35				db WORD_SYS_CORE+33             
3d41 6d 3d			dw .DRAW            
3d43 04				db 3 + 1 
3d44 .. 00			db "CLS",0              
3d48				endm 
# End of macro CWHEAD
3d48			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3d48					if DEBUG_FORTH_WORDS_KEY 
3d48						DMARK "CLS" 
3d48 f5				push af  
3d49 3a 5d 3d			ld a, (.dmark)  
3d4c 32 b4 fe			ld (debug_mark),a  
3d4f 3a 5e 3d			ld a, (.dmark+1)  
3d52 32 b5 fe			ld (debug_mark+1),a  
3d55 3a 5f 3d			ld a, (.dmark+2)  
3d58 32 b6 fe			ld (debug_mark+2),a  
3d5b 18 03			jr .pastdmark  
3d5d ..			.dmark: db "CLS"  
3d60 f1			.pastdmark: pop af  
3d61			endm  
# End of macro DMARK
3d61						CALLMONITOR 
3d61 cd 70 17			call break_point_state  
3d64				endm  
# End of macro CALLMONITOR
3d64					endif 
3d64 cd bf 0b				call clear_display 
3d67 c3 7b 3e				jp .home		; and home cursor 
3d6a					NEXTW 
3d6a c3 47 21			jp macro_next 
3d6d				endm 
# End of macro NEXTW
3d6d			 
3d6d			.DRAW: 
3d6d				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3d6d 36				db WORD_SYS_CORE+34             
3d6e 98 3d			dw .DUMP            
3d70 05				db 4 + 1 
3d71 .. 00			db "DRAW",0              
3d76				endm 
# End of macro CWHEAD
3d76			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3d76					if DEBUG_FORTH_WORDS_KEY 
3d76						DMARK "DRW" 
3d76 f5				push af  
3d77 3a 8b 3d			ld a, (.dmark)  
3d7a 32 b4 fe			ld (debug_mark),a  
3d7d 3a 8c 3d			ld a, (.dmark+1)  
3d80 32 b5 fe			ld (debug_mark+1),a  
3d83 3a 8d 3d			ld a, (.dmark+2)  
3d86 32 b6 fe			ld (debug_mark+2),a  
3d89 18 03			jr .pastdmark  
3d8b ..			.dmark: db "DRW"  
3d8e f1			.pastdmark: pop af  
3d8f			endm  
# End of macro DMARK
3d8f						CALLMONITOR 
3d8f cd 70 17			call break_point_state  
3d92				endm  
# End of macro CALLMONITOR
3d92					endif 
3d92 cd e2 0b				call update_display 
3d95					NEXTW 
3d95 c3 47 21			jp macro_next 
3d98				endm 
# End of macro NEXTW
3d98			 
3d98			.DUMP: 
3d98				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3d98 37				db WORD_SYS_CORE+35             
3d99 d0 3d			dw .CDUMP            
3d9b 05				db 4 + 1 
3d9c .. 00			db "DUMP",0              
3da1				endm 
# End of macro CWHEAD
3da1			; | DUMP ( x -- ) With address x display dump   | DONE 
3da1			; TODO pop address to use off of the stack 
3da1					if DEBUG_FORTH_WORDS_KEY 
3da1						DMARK "DUM" 
3da1 f5				push af  
3da2 3a b6 3d			ld a, (.dmark)  
3da5 32 b4 fe			ld (debug_mark),a  
3da8 3a b7 3d			ld a, (.dmark+1)  
3dab 32 b5 fe			ld (debug_mark+1),a  
3dae 3a b8 3d			ld a, (.dmark+2)  
3db1 32 b6 fe			ld (debug_mark+2),a  
3db4 18 03			jr .pastdmark  
3db6 ..			.dmark: db "DUM"  
3db9 f1			.pastdmark: pop af  
3dba			endm  
# End of macro DMARK
3dba						CALLMONITOR 
3dba cd 70 17			call break_point_state  
3dbd				endm  
# End of macro CALLMONITOR
3dbd					endif 
3dbd cd bf 0b				call clear_display 
3dc0			 
3dc0					; get address 
3dc0			 
3dc0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dc0 cd d5 1f			call macro_dsp_valuehl 
3dc3				endm 
# End of macro FORTH_DSP_VALUEHL
3dc3				 
3dc3					; save it for cdump 
3dc3			 
3dc3 22 7d f7				ld (os_cur_ptr),hl 
3dc6			 
3dc6					; destroy value TOS 
3dc6			 
3dc6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3dc6 cd 8d 20			call macro_forth_dsp_pop 
3dc9				endm 
# End of macro FORTH_DSP_POP
3dc9			 
3dc9 cd 5e 1c				call dumpcont	; skip old style of param parsing	 
3dcc c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3dcd					NEXTW 
3dcd c3 47 21			jp macro_next 
3dd0				endm 
# End of macro NEXTW
3dd0			.CDUMP: 
3dd0				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3dd0 38				db WORD_SYS_CORE+36             
3dd1 00 3e			dw .DAT            
3dd3 06				db 5 + 1 
3dd4 .. 00			db "CDUMP",0              
3dda				endm 
# End of macro CWHEAD
3dda			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3dda					if DEBUG_FORTH_WORDS_KEY 
3dda						DMARK "CDP" 
3dda f5				push af  
3ddb 3a ef 3d			ld a, (.dmark)  
3dde 32 b4 fe			ld (debug_mark),a  
3de1 3a f0 3d			ld a, (.dmark+1)  
3de4 32 b5 fe			ld (debug_mark+1),a  
3de7 3a f1 3d			ld a, (.dmark+2)  
3dea 32 b6 fe			ld (debug_mark+2),a  
3ded 18 03			jr .pastdmark  
3def ..			.dmark: db "CDP"  
3df2 f1			.pastdmark: pop af  
3df3			endm  
# End of macro DMARK
3df3						CALLMONITOR 
3df3 cd 70 17			call break_point_state  
3df6				endm  
# End of macro CALLMONITOR
3df6					endif 
3df6 cd bf 0b				call clear_display 
3df9 cd 5e 1c				call dumpcont	 
3dfc c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3dfd					NEXTW 
3dfd c3 47 21			jp macro_next 
3e00				endm 
# End of macro NEXTW
3e00			 
3e00			 
3e00			 
3e00			 
3e00			.DAT: 
3e00				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3e00 3d				db WORD_SYS_CORE+41             
3e01 56 3e			dw .HOME            
3e03 03				db 2 + 1 
3e04 .. 00			db "AT",0              
3e07				endm 
# End of macro CWHEAD
3e07			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3e07					if DEBUG_FORTH_WORDS_KEY 
3e07						DMARK "AT." 
3e07 f5				push af  
3e08 3a 1c 3e			ld a, (.dmark)  
3e0b 32 b4 fe			ld (debug_mark),a  
3e0e 3a 1d 3e			ld a, (.dmark+1)  
3e11 32 b5 fe			ld (debug_mark+1),a  
3e14 3a 1e 3e			ld a, (.dmark+2)  
3e17 32 b6 fe			ld (debug_mark+2),a  
3e1a 18 03			jr .pastdmark  
3e1c ..			.dmark: db "AT."  
3e1f f1			.pastdmark: pop af  
3e20			endm  
# End of macro DMARK
3e20						CALLMONITOR 
3e20 cd 70 17			call break_point_state  
3e23				endm  
# End of macro CALLMONITOR
3e23					endif 
3e23					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e23 cd d5 1f			call macro_dsp_valuehl 
3e26				endm 
# End of macro FORTH_DSP_VALUEHL
3e26			 
3e26			 
3e26					; TODO save cursor row 
3e26 7d					ld a,l 
3e27 fe 02				cp 2 
3e29 20 04				jr nz, .crow3 
3e2b 3e 14				ld a, display_row_2 
3e2d 18 12				jr .ccol1 
3e2f fe 03		.crow3:		cp 3 
3e31 20 04				jr nz, .crow4 
3e33 3e 28				ld a, display_row_3 
3e35 18 0a				jr .ccol1 
3e37 fe 04		.crow4:		cp 4 
3e39 20 04				jr nz, .crow1 
3e3b 3e 3c				ld a, display_row_4 
3e3d 18 02				jr .ccol1 
3e3f 3e 00		.crow1:		ld a,display_row_1 
3e41 f5			.ccol1:		push af			; got row offset 
3e42 6f					ld l,a 
3e43 26 00				ld h,0 
3e45					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e45 cd 8d 20			call macro_forth_dsp_pop 
3e48				endm 
# End of macro FORTH_DSP_POP
3e48					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e48 cd d5 1f			call macro_dsp_valuehl 
3e4b				endm 
# End of macro FORTH_DSP_VALUEHL
3e4b					; TODO save cursor col 
3e4b f1					pop af 
3e4c 85					add l		; add col offset 
3e4d 32 c3 fc				ld (f_cursor_ptr), a 
3e50					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e50 cd 8d 20			call macro_forth_dsp_pop 
3e53				endm 
# End of macro FORTH_DSP_POP
3e53			 
3e53					; calculate  
3e53			 
3e53					NEXTW 
3e53 c3 47 21			jp macro_next 
3e56				endm 
# End of macro NEXTW
3e56			 
3e56			 
3e56			.HOME: 
3e56				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3e56 41				db WORD_SYS_CORE+45             
3e57 83 3e			dw .SPACE            
3e59 05				db 4 + 1 
3e5a .. 00			db "HOME",0              
3e5f				endm 
# End of macro CWHEAD
3e5f			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3e5f					if DEBUG_FORTH_WORDS_KEY 
3e5f						DMARK "HOM" 
3e5f f5				push af  
3e60 3a 74 3e			ld a, (.dmark)  
3e63 32 b4 fe			ld (debug_mark),a  
3e66 3a 75 3e			ld a, (.dmark+1)  
3e69 32 b5 fe			ld (debug_mark+1),a  
3e6c 3a 76 3e			ld a, (.dmark+2)  
3e6f 32 b6 fe			ld (debug_mark+2),a  
3e72 18 03			jr .pastdmark  
3e74 ..			.dmark: db "HOM"  
3e77 f1			.pastdmark: pop af  
3e78			endm  
# End of macro DMARK
3e78						CALLMONITOR 
3e78 cd 70 17			call break_point_state  
3e7b				endm  
# End of macro CALLMONITOR
3e7b					endif 
3e7b 3e 00		.home:		ld a, 0		; and home cursor 
3e7d 32 c3 fc				ld (f_cursor_ptr), a 
3e80					NEXTW 
3e80 c3 47 21			jp macro_next 
3e83				endm 
# End of macro NEXTW
3e83			 
3e83			 
3e83			.SPACE: 
3e83				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3e83 46				db WORD_SYS_CORE+50             
3e84 b1 3e			dw .SPACES            
3e86 03				db 2 + 1 
3e87 .. 00			db "BL",0              
3e8a				endm 
# End of macro CWHEAD
3e8a			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3e8a					if DEBUG_FORTH_WORDS_KEY 
3e8a						DMARK "BL." 
3e8a f5				push af  
3e8b 3a 9f 3e			ld a, (.dmark)  
3e8e 32 b4 fe			ld (debug_mark),a  
3e91 3a a0 3e			ld a, (.dmark+1)  
3e94 32 b5 fe			ld (debug_mark+1),a  
3e97 3a a1 3e			ld a, (.dmark+2)  
3e9a 32 b6 fe			ld (debug_mark+2),a  
3e9d 18 03			jr .pastdmark  
3e9f ..			.dmark: db "BL."  
3ea2 f1			.pastdmark: pop af  
3ea3			endm  
# End of macro DMARK
3ea3						CALLMONITOR 
3ea3 cd 70 17			call break_point_state  
3ea6				endm  
# End of macro CALLMONITOR
3ea6					endif 
3ea6 21 af 3e				ld hl, .blstr 
3ea9 cd 4c 1e				call forth_push_str 
3eac					 
3eac				       NEXTW 
3eac c3 47 21			jp macro_next 
3eaf				endm 
# End of macro NEXTW
3eaf			 
3eaf .. 00		.blstr: db " ", 0 
3eb1			 
3eb1			.SPACES: 
3eb1				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3eb1 47				db WORD_SYS_CORE+51             
3eb2 4c 3f			dw .SCROLL            
3eb4 07				db 6 + 1 
3eb5 .. 00			db "SPACES",0              
3ebc				endm 
# End of macro CWHEAD
3ebc			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3ebc					if DEBUG_FORTH_WORDS_KEY 
3ebc						DMARK "SPS" 
3ebc f5				push af  
3ebd 3a d1 3e			ld a, (.dmark)  
3ec0 32 b4 fe			ld (debug_mark),a  
3ec3 3a d2 3e			ld a, (.dmark+1)  
3ec6 32 b5 fe			ld (debug_mark+1),a  
3ec9 3a d3 3e			ld a, (.dmark+2)  
3ecc 32 b6 fe			ld (debug_mark+2),a  
3ecf 18 03			jr .pastdmark  
3ed1 ..			.dmark: db "SPS"  
3ed4 f1			.pastdmark: pop af  
3ed5			endm  
# End of macro DMARK
3ed5						CALLMONITOR 
3ed5 cd 70 17			call break_point_state  
3ed8				endm  
# End of macro CALLMONITOR
3ed8					endif 
3ed8			 
3ed8			 
3ed8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ed8 cd d5 1f			call macro_dsp_valuehl 
3edb				endm 
# End of macro FORTH_DSP_VALUEHL
3edb			 
3edb			;		push hl    ; u 
3edb					if DEBUG_FORTH_WORDS 
3edb						DMARK "SPA" 
3edb f5				push af  
3edc 3a f0 3e			ld a, (.dmark)  
3edf 32 b4 fe			ld (debug_mark),a  
3ee2 3a f1 3e			ld a, (.dmark+1)  
3ee5 32 b5 fe			ld (debug_mark+1),a  
3ee8 3a f2 3e			ld a, (.dmark+2)  
3eeb 32 b6 fe			ld (debug_mark+2),a  
3eee 18 03			jr .pastdmark  
3ef0 ..			.dmark: db "SPA"  
3ef3 f1			.pastdmark: pop af  
3ef4			endm  
# End of macro DMARK
3ef4						CALLMONITOR 
3ef4 cd 70 17			call break_point_state  
3ef7				endm  
# End of macro CALLMONITOR
3ef7					endif 
3ef7			 
3ef7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ef7 cd 8d 20			call macro_forth_dsp_pop 
3efa				endm 
# End of macro FORTH_DSP_POP
3efa			;		pop hl 
3efa 4d					ld c, l 
3efb 06 00				ld b, 0 
3efd 21 5a f4				ld hl, scratch  
3f00			 
3f00					if DEBUG_FORTH_WORDS 
3f00						DMARK "SP2" 
3f00 f5				push af  
3f01 3a 15 3f			ld a, (.dmark)  
3f04 32 b4 fe			ld (debug_mark),a  
3f07 3a 16 3f			ld a, (.dmark+1)  
3f0a 32 b5 fe			ld (debug_mark+1),a  
3f0d 3a 17 3f			ld a, (.dmark+2)  
3f10 32 b6 fe			ld (debug_mark+2),a  
3f13 18 03			jr .pastdmark  
3f15 ..			.dmark: db "SP2"  
3f18 f1			.pastdmark: pop af  
3f19			endm  
# End of macro DMARK
3f19						CALLMONITOR 
3f19 cd 70 17			call break_point_state  
3f1c				endm  
# End of macro CALLMONITOR
3f1c					endif 
3f1c 3e 20				ld a, ' ' 
3f1e c5			.spaces1:	push bc 
3f1f 77					ld (hl),a 
3f20 23					inc hl 
3f21 c1					pop bc 
3f22 10 fa				djnz .spaces1 
3f24 3e 00				ld a,0 
3f26 77					ld (hl),a 
3f27 21 5a f4				ld hl, scratch 
3f2a					if DEBUG_FORTH_WORDS 
3f2a						DMARK "SP3" 
3f2a f5				push af  
3f2b 3a 3f 3f			ld a, (.dmark)  
3f2e 32 b4 fe			ld (debug_mark),a  
3f31 3a 40 3f			ld a, (.dmark+1)  
3f34 32 b5 fe			ld (debug_mark+1),a  
3f37 3a 41 3f			ld a, (.dmark+2)  
3f3a 32 b6 fe			ld (debug_mark+2),a  
3f3d 18 03			jr .pastdmark  
3f3f ..			.dmark: db "SP3"  
3f42 f1			.pastdmark: pop af  
3f43			endm  
# End of macro DMARK
3f43						CALLMONITOR 
3f43 cd 70 17			call break_point_state  
3f46				endm  
# End of macro CALLMONITOR
3f46					endif 
3f46 cd 47 1f				call forth_apush 
3f49			 
3f49				       NEXTW 
3f49 c3 47 21			jp macro_next 
3f4c				endm 
# End of macro NEXTW
3f4c			 
3f4c			 
3f4c			 
3f4c			.SCROLL: 
3f4c				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3f4c 53				db WORD_SYS_CORE+63             
3f4d 79 3f			dw .SCROLLD            
3f4f 07				db 6 + 1 
3f50 .. 00			db "SCROLL",0              
3f57				endm 
# End of macro CWHEAD
3f57			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3f57					if DEBUG_FORTH_WORDS_KEY 
3f57						DMARK "SCR" 
3f57 f5				push af  
3f58 3a 6c 3f			ld a, (.dmark)  
3f5b 32 b4 fe			ld (debug_mark),a  
3f5e 3a 6d 3f			ld a, (.dmark+1)  
3f61 32 b5 fe			ld (debug_mark+1),a  
3f64 3a 6e 3f			ld a, (.dmark+2)  
3f67 32 b6 fe			ld (debug_mark+2),a  
3f6a 18 03			jr .pastdmark  
3f6c ..			.dmark: db "SCR"  
3f6f f1			.pastdmark: pop af  
3f70			endm  
# End of macro DMARK
3f70						CALLMONITOR 
3f70 cd 70 17			call break_point_state  
3f73				endm  
# End of macro CALLMONITOR
3f73					endif 
3f73			 
3f73 cd 81 0b			call scroll_up 
3f76			;	call update_display 
3f76			 
3f76					NEXTW 
3f76 c3 47 21			jp macro_next 
3f79				endm 
# End of macro NEXTW
3f79			 
3f79			 
3f79			 
3f79			;		; get dir 
3f79			; 
3f79			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f79			; 
3f79			;		push hl 
3f79			; 
3f79			;		; destroy value TOS 
3f79			; 
3f79			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f79			; 
3f79			;		; get count 
3f79			; 
3f79			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f79			; 
3f79			;		push hl 
3f79			; 
3f79			;		; destroy value TOS 
3f79			; 
3f79			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f79			; 
3f79			;		; one value on hl get other one back 
3f79			; 
3f79			;		pop bc    ; count 
3f79			; 
3f79			;		pop de   ; dir 
3f79			; 
3f79			; 
3f79			;		ld b, c 
3f79			; 
3f79			;.scrolldir:     push bc 
3f79			;		push de 
3f79			; 
3f79			;		ld a, 0 
3f79			;		cp e 
3f79			;		jr z, .scrollup  
3f79			;		call scroll_down 
3f79			;		jr .scrollnext 
3f79			;.scrollup:	call scroll_up 
3f79			; 
3f79			;		 
3f79			;.scrollnext: 
3f79			;		pop de 
3f79			;		pop bc 
3f79			;		djnz .scrolldir 
3f79			; 
3f79			; 
3f79			; 
3f79			; 
3f79			; 
3f79			;		NEXTW 
3f79			 
3f79			.SCROLLD: 
3f79				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3f79 53				db WORD_SYS_CORE+63             
3f7a a7 3f			dw .ATQ            
3f7c 08				db 7 + 1 
3f7d .. 00			db "SCROLLD",0              
3f85				endm 
# End of macro CWHEAD
3f85			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3f85					if DEBUG_FORTH_WORDS_KEY 
3f85						DMARK "SCD" 
3f85 f5				push af  
3f86 3a 9a 3f			ld a, (.dmark)  
3f89 32 b4 fe			ld (debug_mark),a  
3f8c 3a 9b 3f			ld a, (.dmark+1)  
3f8f 32 b5 fe			ld (debug_mark+1),a  
3f92 3a 9c 3f			ld a, (.dmark+2)  
3f95 32 b6 fe			ld (debug_mark+2),a  
3f98 18 03			jr .pastdmark  
3f9a ..			.dmark: db "SCD"  
3f9d f1			.pastdmark: pop af  
3f9e			endm  
# End of macro DMARK
3f9e						CALLMONITOR 
3f9e cd 70 17			call break_point_state  
3fa1				endm  
# End of macro CALLMONITOR
3fa1					endif 
3fa1			 
3fa1 cd a5 0b			call scroll_down 
3fa4			;	call update_display 
3fa4			 
3fa4					NEXTW 
3fa4 c3 47 21			jp macro_next 
3fa7				endm 
# End of macro NEXTW
3fa7			 
3fa7			 
3fa7			.ATQ: 
3fa7				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3fa7 62				db WORD_SYS_CORE+78             
3fa8 05 40			dw .AUTODSP            
3faa 04				db 3 + 1 
3fab .. 00			db "AT@",0              
3faf				endm 
# End of macro CWHEAD
3faf			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3faf					if DEBUG_FORTH_WORDS_KEY 
3faf						DMARK "ATA" 
3faf f5				push af  
3fb0 3a c4 3f			ld a, (.dmark)  
3fb3 32 b4 fe			ld (debug_mark),a  
3fb6 3a c5 3f			ld a, (.dmark+1)  
3fb9 32 b5 fe			ld (debug_mark+1),a  
3fbc 3a c6 3f			ld a, (.dmark+2)  
3fbf 32 b6 fe			ld (debug_mark+2),a  
3fc2 18 03			jr .pastdmark  
3fc4 ..			.dmark: db "ATA"  
3fc7 f1			.pastdmark: pop af  
3fc8			endm  
# End of macro DMARK
3fc8						CALLMONITOR 
3fc8 cd 70 17			call break_point_state  
3fcb				endm  
# End of macro CALLMONITOR
3fcb					endif 
3fcb			 
3fcb			 
3fcb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fcb cd d5 1f			call macro_dsp_valuehl 
3fce				endm 
# End of macro FORTH_DSP_VALUEHL
3fce			 
3fce					; TODO save cursor row 
3fce 7d					ld a,l 
3fcf fe 02				cp 2 
3fd1 20 04				jr nz, .crow3aq 
3fd3 3e 14				ld a, display_row_2 
3fd5 18 12				jr .ccol1aq 
3fd7 fe 03		.crow3aq:		cp 3 
3fd9 20 04				jr nz, .crow4aq 
3fdb 3e 28				ld a, display_row_3 
3fdd 18 0a				jr .ccol1aq 
3fdf fe 04		.crow4aq:		cp 4 
3fe1 20 04				jr nz, .crow1aq 
3fe3 3e 3c				ld a, display_row_4 
3fe5 18 02				jr .ccol1aq 
3fe7 3e 00		.crow1aq:		ld a,display_row_1 
3fe9 f5			.ccol1aq:		push af			; got row offset 
3fea 6f					ld l,a 
3feb 26 00				ld h,0 
3fed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fed cd 8d 20			call macro_forth_dsp_pop 
3ff0				endm 
# End of macro FORTH_DSP_POP
3ff0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ff0 cd d5 1f			call macro_dsp_valuehl 
3ff3				endm 
# End of macro FORTH_DSP_VALUEHL
3ff3					; TODO save cursor col 
3ff3 f1					pop af 
3ff4 85					add l		; add col offset 
3ff5			 
3ff5					; add current frame buffer address 
3ff5 2a 55 fd				ld hl, (display_fb_active) 
3ff8 cd f3 0d				call addatohl 
3ffb			 
3ffb			 
3ffb			 
3ffb			 
3ffb					; get char frame buffer location offset in hl 
3ffb			 
3ffb 7e					ld a,(hl) 
3ffc 26 00				ld h, 0 
3ffe 6f					ld l, a 
3fff			 
3fff cd de 1d				call forth_push_numhl 
4002			 
4002			 
4002					NEXTW 
4002 c3 47 21			jp macro_next 
4005				endm 
# End of macro NEXTW
4005			 
4005			.AUTODSP: 
4005				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4005 63				db WORD_SYS_CORE+79             
4006 1b 40			dw .MENU            
4008 05				db 4 + 1 
4009 .. 00			db "ADSP",0              
400e				endm 
# End of macro CWHEAD
400e			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
400e			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
400e			 
400e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
400e cd d5 1f			call macro_dsp_valuehl 
4011				endm 
# End of macro FORTH_DSP_VALUEHL
4011			 
4011			;		push hl 
4011			 
4011					; destroy value TOS 
4011			 
4011					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4011 cd 8d 20			call macro_forth_dsp_pop 
4014				endm 
# End of macro FORTH_DSP_POP
4014			 
4014			;		pop hl 
4014			 
4014 7d					ld a,l 
4015 32 a1 fc				ld (cli_autodisplay), a 
4018				       NEXTW 
4018 c3 47 21			jp macro_next 
401b				endm 
# End of macro NEXTW
401b			 
401b			.MENU: 
401b				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
401b 70				db WORD_SYS_CORE+92             
401c c4 40			dw .ENDDISPLAY            
401e 05				db 4 + 1 
401f .. 00			db "MENU",0              
4024				endm 
# End of macro CWHEAD
4024			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
4024			 
4024			;		; get number of items on the stack 
4024			; 
4024				 
4024					FORTH_DSP_VALUEHL 
4024 cd d5 1f			call macro_dsp_valuehl 
4027				endm 
# End of macro FORTH_DSP_VALUEHL
4027				 
4027					if DEBUG_FORTH_WORDS_KEY 
4027						DMARK "MNU" 
4027 f5				push af  
4028 3a 3c 40			ld a, (.dmark)  
402b 32 b4 fe			ld (debug_mark),a  
402e 3a 3d 40			ld a, (.dmark+1)  
4031 32 b5 fe			ld (debug_mark+1),a  
4034 3a 3e 40			ld a, (.dmark+2)  
4037 32 b6 fe			ld (debug_mark+2),a  
403a 18 03			jr .pastdmark  
403c ..			.dmark: db "MNU"  
403f f1			.pastdmark: pop af  
4040			endm  
# End of macro DMARK
4040						CALLMONITOR 
4040 cd 70 17			call break_point_state  
4043				endm  
# End of macro CALLMONITOR
4043					endif 
4043			 
4043 45					ld b, l	 
4044 05					dec b 
4045			 
4045					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4045 cd 8d 20			call macro_forth_dsp_pop 
4048				endm 
# End of macro FORTH_DSP_POP
4048			 
4048			 
4048					; go directly through the stack to pluck out the string pointers and build an array 
4048			 
4048			;		FORTH_DSP 
4048			 
4048					; hl contains top most stack item 
4048				 
4048 11 5a f4				ld de, scratch 
404b			 
404b			.mbuild: 
404b			 
404b					FORTH_DSP_VALUEHL 
404b cd d5 1f			call macro_dsp_valuehl 
404e				endm 
# End of macro FORTH_DSP_VALUEHL
404e			 
404e					if DEBUG_FORTH_WORDS 
404e						DMARK "MN3" 
404e f5				push af  
404f 3a 63 40			ld a, (.dmark)  
4052 32 b4 fe			ld (debug_mark),a  
4055 3a 64 40			ld a, (.dmark+1)  
4058 32 b5 fe			ld (debug_mark+1),a  
405b 3a 65 40			ld a, (.dmark+2)  
405e 32 b6 fe			ld (debug_mark+2),a  
4061 18 03			jr .pastdmark  
4063 ..			.dmark: db "MN3"  
4066 f1			.pastdmark: pop af  
4067			endm  
# End of macro DMARK
4067						CALLMONITOR 
4067 cd 70 17			call break_point_state  
406a				endm  
# End of macro CALLMONITOR
406a					endif 
406a eb					ex de, hl 
406b 73					ld (hl), e 
406c 23					inc hl 
406d 72					ld (hl), d 
406e 23					inc hl 
406f eb					ex de, hl 
4070			 
4070					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4070 cd 8d 20			call macro_forth_dsp_pop 
4073				endm 
# End of macro FORTH_DSP_POP
4073			 
4073 10 d6				djnz .mbuild 
4075			 
4075					; done add term 
4075			 
4075 eb					ex de, hl 
4076 36 00				ld (hl), 0 
4078 23					inc hl 
4079 36 00				ld (hl), 0 
407b			 
407b				 
407b					 
407b 21 5a f4				ld hl, scratch 
407e			 
407e					if DEBUG_FORTH_WORDS 
407e						DMARK "MNx" 
407e f5				push af  
407f 3a 93 40			ld a, (.dmark)  
4082 32 b4 fe			ld (debug_mark),a  
4085 3a 94 40			ld a, (.dmark+1)  
4088 32 b5 fe			ld (debug_mark+1),a  
408b 3a 95 40			ld a, (.dmark+2)  
408e 32 b6 fe			ld (debug_mark+2),a  
4091 18 03			jr .pastdmark  
4093 ..			.dmark: db "MNx"  
4096 f1			.pastdmark: pop af  
4097			endm  
# End of macro DMARK
4097						CALLMONITOR 
4097 cd 70 17			call break_point_state  
409a				endm  
# End of macro CALLMONITOR
409a					endif 
409a			 
409a			 
409a			 
409a 3e 00				ld a, 0 
409c cd f0 0b				call menu 
409f			 
409f			 
409f 6f					ld l, a 
40a0 26 00				ld h, 0 
40a2			 
40a2					if DEBUG_FORTH_WORDS 
40a2						DMARK "MNr" 
40a2 f5				push af  
40a3 3a b7 40			ld a, (.dmark)  
40a6 32 b4 fe			ld (debug_mark),a  
40a9 3a b8 40			ld a, (.dmark+1)  
40ac 32 b5 fe			ld (debug_mark+1),a  
40af 3a b9 40			ld a, (.dmark+2)  
40b2 32 b6 fe			ld (debug_mark+2),a  
40b5 18 03			jr .pastdmark  
40b7 ..			.dmark: db "MNr"  
40ba f1			.pastdmark: pop af  
40bb			endm  
# End of macro DMARK
40bb						CALLMONITOR 
40bb cd 70 17			call break_point_state  
40be				endm  
# End of macro CALLMONITOR
40be					endif 
40be			 
40be cd de 1d				call forth_push_numhl 
40c1			 
40c1			 
40c1			 
40c1			 
40c1				       NEXTW 
40c1 c3 47 21			jp macro_next 
40c4				endm 
# End of macro NEXTW
40c4			 
40c4			 
40c4			.ENDDISPLAY: 
40c4			 
40c4			; eof 
# End of file forth_words_display.asm
40c4			include "forth_words_str.asm" 
40c4			 
40c4			; | ## String Words 
40c4			 
40c4			.PTR:   
40c4			 
40c4				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
40c4 48				db WORD_SYS_CORE+52             
40c5 f1 40			dw .STYPE            
40c7 04				db 3 + 1 
40c8 .. 00			db "PTR",0              
40cc				endm 
# End of macro CWHEAD
40cc			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
40cc			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
40cc			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
40cc			 
40cc					if DEBUG_FORTH_WORDS_KEY 
40cc						DMARK "PTR" 
40cc f5				push af  
40cd 3a e1 40			ld a, (.dmark)  
40d0 32 b4 fe			ld (debug_mark),a  
40d3 3a e2 40			ld a, (.dmark+1)  
40d6 32 b5 fe			ld (debug_mark+1),a  
40d9 3a e3 40			ld a, (.dmark+2)  
40dc 32 b6 fe			ld (debug_mark+2),a  
40df 18 03			jr .pastdmark  
40e1 ..			.dmark: db "PTR"  
40e4 f1			.pastdmark: pop af  
40e5			endm  
# End of macro DMARK
40e5						CALLMONITOR 
40e5 cd 70 17			call break_point_state  
40e8				endm  
# End of macro CALLMONITOR
40e8					endif 
40e8					FORTH_DSP_VALUEHL 
40e8 cd d5 1f			call macro_dsp_valuehl 
40eb				endm 
# End of macro FORTH_DSP_VALUEHL
40eb cd de 1d				call forth_push_numhl 
40ee			 
40ee			 
40ee					NEXTW 
40ee c3 47 21			jp macro_next 
40f1				endm 
# End of macro NEXTW
40f1			.STYPE: 
40f1				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
40f1 48				db WORD_SYS_CORE+52             
40f2 40 41			dw .UPPER            
40f4 06				db 5 + 1 
40f5 .. 00			db "STYPE",0              
40fb				endm 
# End of macro CWHEAD
40fb			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
40fb					if DEBUG_FORTH_WORDS_KEY 
40fb						DMARK "STY" 
40fb f5				push af  
40fc 3a 10 41			ld a, (.dmark)  
40ff 32 b4 fe			ld (debug_mark),a  
4102 3a 11 41			ld a, (.dmark+1)  
4105 32 b5 fe			ld (debug_mark+1),a  
4108 3a 12 41			ld a, (.dmark+2)  
410b 32 b6 fe			ld (debug_mark+2),a  
410e 18 03			jr .pastdmark  
4110 ..			.dmark: db "STY"  
4113 f1			.pastdmark: pop af  
4114			endm  
# End of macro DMARK
4114						CALLMONITOR 
4114 cd 70 17			call break_point_state  
4117				endm  
# End of macro CALLMONITOR
4117					endif 
4117					FORTH_DSP 
4117 cd 9b 1f			call macro_forth_dsp 
411a				endm 
# End of macro FORTH_DSP
411a					;v5 FORTH_DSP_VALUE 
411a			 
411a 7e					ld a, (hl) 
411b			 
411b f5					push af 
411c			 
411c			; Dont destroy TOS		FORTH_DSP_POP 
411c			 
411c f1					pop af 
411d			 
411d fe 01				cp DS_TYPE_STR 
411f 28 09				jr z, .typestr 
4121			 
4121 fe 02				cp DS_TYPE_INUM 
4123 28 0a				jr z, .typeinum 
4125			 
4125 21 3e 41				ld hl, .tna 
4128 18 0a				jr .tpush 
412a			 
412a 21 3a 41		.typestr:	ld hl, .tstr 
412d 18 05				jr .tpush 
412f 21 3c 41		.typeinum:	ld hl, .tinum 
4132 18 00				jr .tpush 
4134			 
4134			.tpush: 
4134			 
4134 cd 4c 1e				call forth_push_str 
4137			 
4137					NEXTW 
4137 c3 47 21			jp macro_next 
413a				endm 
# End of macro NEXTW
413a .. 00		.tstr:	db "s",0 
413c .. 00		.tinum:  db "i",0 
413e .. 00		.tna:   db "?", 0 
4140			 
4140			 
4140			.UPPER: 
4140				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4140 48				db WORD_SYS_CORE+52             
4141 7b 41			dw .LOWER            
4143 06				db 5 + 1 
4144 .. 00			db "UPPER",0              
414a				endm 
# End of macro CWHEAD
414a			; | UPPER ( s -- s ) Upper case string s  | DONE 
414a					if DEBUG_FORTH_WORDS_KEY 
414a						DMARK "UPR" 
414a f5				push af  
414b 3a 5f 41			ld a, (.dmark)  
414e 32 b4 fe			ld (debug_mark),a  
4151 3a 60 41			ld a, (.dmark+1)  
4154 32 b5 fe			ld (debug_mark+1),a  
4157 3a 61 41			ld a, (.dmark+2)  
415a 32 b6 fe			ld (debug_mark+2),a  
415d 18 03			jr .pastdmark  
415f ..			.dmark: db "UPR"  
4162 f1			.pastdmark: pop af  
4163			endm  
# End of macro DMARK
4163						CALLMONITOR 
4163 cd 70 17			call break_point_state  
4166				endm  
# End of macro CALLMONITOR
4166					endif 
4166			 
4166					FORTH_DSP 
4166 cd 9b 1f			call macro_forth_dsp 
4169				endm 
# End of macro FORTH_DSP
4169					 
4169			; TODO check is string type 
4169			 
4169					FORTH_DSP_VALUEHL 
4169 cd d5 1f			call macro_dsp_valuehl 
416c				endm 
# End of macro FORTH_DSP_VALUEHL
416c			; get pointer to string in hl 
416c			 
416c 7e			.toup:		ld a, (hl) 
416d fe 00				cp 0 
416f 28 07				jr z, .toupdone 
4171			 
4171 cd 60 11				call to_upper 
4174			 
4174 77					ld (hl), a 
4175 23					inc hl 
4176 18 f4				jr .toup 
4178			 
4178					 
4178			 
4178			 
4178			; for each char convert to upper 
4178					 
4178			.toupdone: 
4178			 
4178			 
4178					NEXTW 
4178 c3 47 21			jp macro_next 
417b				endm 
# End of macro NEXTW
417b			.LOWER: 
417b				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
417b 48				db WORD_SYS_CORE+52             
417c b6 41			dw .TCASE            
417e 06				db 5 + 1 
417f .. 00			db "LOWER",0              
4185				endm 
# End of macro CWHEAD
4185			; | LOWER ( s -- s ) Lower case string s  | DONE 
4185					if DEBUG_FORTH_WORDS_KEY 
4185						DMARK "LWR" 
4185 f5				push af  
4186 3a 9a 41			ld a, (.dmark)  
4189 32 b4 fe			ld (debug_mark),a  
418c 3a 9b 41			ld a, (.dmark+1)  
418f 32 b5 fe			ld (debug_mark+1),a  
4192 3a 9c 41			ld a, (.dmark+2)  
4195 32 b6 fe			ld (debug_mark+2),a  
4198 18 03			jr .pastdmark  
419a ..			.dmark: db "LWR"  
419d f1			.pastdmark: pop af  
419e			endm  
# End of macro DMARK
419e						CALLMONITOR 
419e cd 70 17			call break_point_state  
41a1				endm  
# End of macro CALLMONITOR
41a1					endif 
41a1			 
41a1					FORTH_DSP 
41a1 cd 9b 1f			call macro_forth_dsp 
41a4				endm 
# End of macro FORTH_DSP
41a4					 
41a4			; TODO check is string type 
41a4			 
41a4					FORTH_DSP_VALUEHL 
41a4 cd d5 1f			call macro_dsp_valuehl 
41a7				endm 
# End of macro FORTH_DSP_VALUEHL
41a7			; get pointer to string in hl 
41a7			 
41a7 7e			.tolow:		ld a, (hl) 
41a8 fe 00				cp 0 
41aa 28 07				jr z, .tolowdone 
41ac			 
41ac cd 69 11				call to_lower 
41af			 
41af 77					ld (hl), a 
41b0 23					inc hl 
41b1 18 f4				jr .tolow 
41b3			 
41b3					 
41b3			 
41b3			 
41b3			; for each char convert to low 
41b3					 
41b3			.tolowdone: 
41b3					NEXTW 
41b3 c3 47 21			jp macro_next 
41b6				endm 
# End of macro NEXTW
41b6			.TCASE: 
41b6				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
41b6 48				db WORD_SYS_CORE+52             
41b7 ec 42			dw .SUBSTR            
41b9 06				db 5 + 1 
41ba .. 00			db "TCASE",0              
41c0				endm 
# End of macro CWHEAD
41c0			; | TCASE ( s -- s ) Title case string s  | DONE 
41c0					if DEBUG_FORTH_WORDS_KEY 
41c0						DMARK "TCS" 
41c0 f5				push af  
41c1 3a d5 41			ld a, (.dmark)  
41c4 32 b4 fe			ld (debug_mark),a  
41c7 3a d6 41			ld a, (.dmark+1)  
41ca 32 b5 fe			ld (debug_mark+1),a  
41cd 3a d7 41			ld a, (.dmark+2)  
41d0 32 b6 fe			ld (debug_mark+2),a  
41d3 18 03			jr .pastdmark  
41d5 ..			.dmark: db "TCS"  
41d8 f1			.pastdmark: pop af  
41d9			endm  
# End of macro DMARK
41d9						CALLMONITOR 
41d9 cd 70 17			call break_point_state  
41dc				endm  
# End of macro CALLMONITOR
41dc					endif 
41dc			 
41dc					FORTH_DSP 
41dc cd 9b 1f			call macro_forth_dsp 
41df				endm 
# End of macro FORTH_DSP
41df					 
41df			; TODO check is string type 
41df			 
41df					FORTH_DSP_VALUEHL 
41df cd d5 1f			call macro_dsp_valuehl 
41e2				endm 
# End of macro FORTH_DSP_VALUEHL
41e2			; get pointer to string in hl 
41e2			 
41e2					if DEBUG_FORTH_WORDS 
41e2						DMARK "TC1" 
41e2 f5				push af  
41e3 3a f7 41			ld a, (.dmark)  
41e6 32 b4 fe			ld (debug_mark),a  
41e9 3a f8 41			ld a, (.dmark+1)  
41ec 32 b5 fe			ld (debug_mark+1),a  
41ef 3a f9 41			ld a, (.dmark+2)  
41f2 32 b6 fe			ld (debug_mark+2),a  
41f5 18 03			jr .pastdmark  
41f7 ..			.dmark: db "TC1"  
41fa f1			.pastdmark: pop af  
41fb			endm  
# End of macro DMARK
41fb						CALLMONITOR 
41fb cd 70 17			call break_point_state  
41fe				endm  
# End of macro CALLMONITOR
41fe					endif 
41fe			 
41fe					; first time in turn to upper case first char 
41fe			 
41fe 7e					ld a, (hl) 
41ff c3 89 42				jp .totsiptou 
4202			 
4202			 
4202 7e			.tot:		ld a, (hl) 
4203 fe 00				cp 0 
4205 ca cd 42				jp z, .totdone 
4208			 
4208					if DEBUG_FORTH_WORDS 
4208						DMARK "TC2" 
4208 f5				push af  
4209 3a 1d 42			ld a, (.dmark)  
420c 32 b4 fe			ld (debug_mark),a  
420f 3a 1e 42			ld a, (.dmark+1)  
4212 32 b5 fe			ld (debug_mark+1),a  
4215 3a 1f 42			ld a, (.dmark+2)  
4218 32 b6 fe			ld (debug_mark+2),a  
421b 18 03			jr .pastdmark  
421d ..			.dmark: db "TC2"  
4220 f1			.pastdmark: pop af  
4221			endm  
# End of macro DMARK
4221						CALLMONITOR 
4221 cd 70 17			call break_point_state  
4224				endm  
# End of macro CALLMONITOR
4224					endif 
4224					; check to see if current char is a space 
4224			 
4224 fe 20				cp ' ' 
4226 28 21				jr z, .totsp 
4228 cd 69 11				call to_lower 
422b					if DEBUG_FORTH_WORDS 
422b						DMARK "TC3" 
422b f5				push af  
422c 3a 40 42			ld a, (.dmark)  
422f 32 b4 fe			ld (debug_mark),a  
4232 3a 41 42			ld a, (.dmark+1)  
4235 32 b5 fe			ld (debug_mark+1),a  
4238 3a 42 42			ld a, (.dmark+2)  
423b 32 b6 fe			ld (debug_mark+2),a  
423e 18 03			jr .pastdmark  
4240 ..			.dmark: db "TC3"  
4243 f1			.pastdmark: pop af  
4244			endm  
# End of macro DMARK
4244						CALLMONITOR 
4244 cd 70 17			call break_point_state  
4247				endm  
# End of macro CALLMONITOR
4247					endif 
4247 18 63				jr .totnxt 
4249			 
4249			.totsp:         ; on a space, find next char which should be upper 
4249			 
4249					if DEBUG_FORTH_WORDS 
4249						DMARK "TC4" 
4249 f5				push af  
424a 3a 5e 42			ld a, (.dmark)  
424d 32 b4 fe			ld (debug_mark),a  
4250 3a 5f 42			ld a, (.dmark+1)  
4253 32 b5 fe			ld (debug_mark+1),a  
4256 3a 60 42			ld a, (.dmark+2)  
4259 32 b6 fe			ld (debug_mark+2),a  
425c 18 03			jr .pastdmark  
425e ..			.dmark: db "TC4"  
4261 f1			.pastdmark: pop af  
4262			endm  
# End of macro DMARK
4262						CALLMONITOR 
4262 cd 70 17			call break_point_state  
4265				endm  
# End of macro CALLMONITOR
4265					endif 
4265					;; 
4265			 
4265 fe 20				cp ' ' 
4267 20 20				jr nz, .totsiptou 
4269 23					inc hl 
426a 7e					ld a, (hl) 
426b					if DEBUG_FORTH_WORDS 
426b						DMARK "TC5" 
426b f5				push af  
426c 3a 80 42			ld a, (.dmark)  
426f 32 b4 fe			ld (debug_mark),a  
4272 3a 81 42			ld a, (.dmark+1)  
4275 32 b5 fe			ld (debug_mark+1),a  
4278 3a 82 42			ld a, (.dmark+2)  
427b 32 b6 fe			ld (debug_mark+2),a  
427e 18 03			jr .pastdmark  
4280 ..			.dmark: db "TC5"  
4283 f1			.pastdmark: pop af  
4284			endm  
# End of macro DMARK
4284						CALLMONITOR 
4284 cd 70 17			call break_point_state  
4287				endm  
# End of macro CALLMONITOR
4287					endif 
4287 18 c0				jr .totsp 
4289 fe 00		.totsiptou:    cp 0 
428b 28 40				jr z, .totdone 
428d					; not space and not zero term so upper case it 
428d cd 60 11				call to_upper 
4290			 
4290					if DEBUG_FORTH_WORDS 
4290						DMARK "TC6" 
4290 f5				push af  
4291 3a a5 42			ld a, (.dmark)  
4294 32 b4 fe			ld (debug_mark),a  
4297 3a a6 42			ld a, (.dmark+1)  
429a 32 b5 fe			ld (debug_mark+1),a  
429d 3a a7 42			ld a, (.dmark+2)  
42a0 32 b6 fe			ld (debug_mark+2),a  
42a3 18 03			jr .pastdmark  
42a5 ..			.dmark: db "TC6"  
42a8 f1			.pastdmark: pop af  
42a9			endm  
# End of macro DMARK
42a9						CALLMONITOR 
42a9 cd 70 17			call break_point_state  
42ac				endm  
# End of macro CALLMONITOR
42ac					endif 
42ac			 
42ac			 
42ac			.totnxt: 
42ac			 
42ac 77					ld (hl), a 
42ad 23					inc hl 
42ae					if DEBUG_FORTH_WORDS 
42ae						DMARK "TC7" 
42ae f5				push af  
42af 3a c3 42			ld a, (.dmark)  
42b2 32 b4 fe			ld (debug_mark),a  
42b5 3a c4 42			ld a, (.dmark+1)  
42b8 32 b5 fe			ld (debug_mark+1),a  
42bb 3a c5 42			ld a, (.dmark+2)  
42be 32 b6 fe			ld (debug_mark+2),a  
42c1 18 03			jr .pastdmark  
42c3 ..			.dmark: db "TC7"  
42c6 f1			.pastdmark: pop af  
42c7			endm  
# End of macro DMARK
42c7						CALLMONITOR 
42c7 cd 70 17			call break_point_state  
42ca				endm  
# End of macro CALLMONITOR
42ca					endif 
42ca c3 02 42				jp .tot 
42cd			 
42cd					 
42cd			 
42cd			 
42cd			; for each char convert to low 
42cd					 
42cd			.totdone: 
42cd					if DEBUG_FORTH_WORDS 
42cd						DMARK "TCd" 
42cd f5				push af  
42ce 3a e2 42			ld a, (.dmark)  
42d1 32 b4 fe			ld (debug_mark),a  
42d4 3a e3 42			ld a, (.dmark+1)  
42d7 32 b5 fe			ld (debug_mark+1),a  
42da 3a e4 42			ld a, (.dmark+2)  
42dd 32 b6 fe			ld (debug_mark+2),a  
42e0 18 03			jr .pastdmark  
42e2 ..			.dmark: db "TCd"  
42e5 f1			.pastdmark: pop af  
42e6			endm  
# End of macro DMARK
42e6						CALLMONITOR 
42e6 cd 70 17			call break_point_state  
42e9				endm  
# End of macro CALLMONITOR
42e9					endif 
42e9					NEXTW 
42e9 c3 47 21			jp macro_next 
42ec				endm 
# End of macro NEXTW
42ec			 
42ec			.SUBSTR: 
42ec				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
42ec 48				db WORD_SYS_CORE+52             
42ed 4a 43			dw .LEFT            
42ef 07				db 6 + 1 
42f0 .. 00			db "SUBSTR",0              
42f7				endm 
# End of macro CWHEAD
42f7			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
42f7			 
42f7					if DEBUG_FORTH_WORDS_KEY 
42f7						DMARK "SST" 
42f7 f5				push af  
42f8 3a 0c 43			ld a, (.dmark)  
42fb 32 b4 fe			ld (debug_mark),a  
42fe 3a 0d 43			ld a, (.dmark+1)  
4301 32 b5 fe			ld (debug_mark+1),a  
4304 3a 0e 43			ld a, (.dmark+2)  
4307 32 b6 fe			ld (debug_mark+2),a  
430a 18 03			jr .pastdmark  
430c ..			.dmark: db "SST"  
430f f1			.pastdmark: pop af  
4310			endm  
# End of macro DMARK
4310						CALLMONITOR 
4310 cd 70 17			call break_point_state  
4313				endm  
# End of macro CALLMONITOR
4313					endif 
4313			; TODO check string type 
4313					FORTH_DSP_VALUEHL 
4313 cd d5 1f			call macro_dsp_valuehl 
4316				endm 
# End of macro FORTH_DSP_VALUEHL
4316			 
4316 e5					push hl      ; string length 
4317			 
4317					FORTH_DSP_POP 
4317 cd 8d 20			call macro_forth_dsp_pop 
431a				endm 
# End of macro FORTH_DSP_POP
431a			 
431a					FORTH_DSP_VALUEHL 
431a cd d5 1f			call macro_dsp_valuehl 
431d				endm 
# End of macro FORTH_DSP_VALUEHL
431d			 
431d e5					push hl     ; start char 
431e			 
431e					FORTH_DSP_POP 
431e cd 8d 20			call macro_forth_dsp_pop 
4321				endm 
# End of macro FORTH_DSP_POP
4321			 
4321			 
4321					FORTH_DSP_VALUE 
4321 cd be 1f			call macro_forth_dsp_value 
4324				endm 
# End of macro FORTH_DSP_VALUE
4324			 
4324 d1					pop de    ; get start post offset 
4325			 
4325 19					add hl, de    ; starting offset 
4326			 
4326 c1					pop bc 
4327 c5					push bc      ; grab size of string 
4328			 
4328 e5					push hl    ; save string start  
4329			 
4329 26 00				ld h, 0 
432b 69					ld l, c 
432c 23					inc hl 
432d 23					inc hl 
432e			 
432e cd ba 12				call malloc 
4331				if DEBUG_FORTH_MALLOC_GUARD 
4331 cc 9d 53				call z,malloc_error 
4334				endif 
4334			 
4334 eb					ex de, hl      ; save malloc area for string copy 
4335 e1					pop hl    ; get back source 
4336 c1					pop bc    ; get length of string back 
4337			 
4337 d5					push de    ; save malloc area for after we push 
4338 ed b0				ldir     ; copy substr 
433a			 
433a			 
433a eb					ex de, hl 
433b 3e 00				ld a, 0 
433d 77					ld (hl), a   ; term substr 
433e			 
433e					 
433e e1					pop hl    ; get malloc so we can push it 
433f e5					push hl   ; save so we can free it afterwards 
4340			 
4340 cd 4c 1e				call forth_push_str 
4343			 
4343 e1					pop hl 
4344 cd 84 13				call free 
4347			 
4347					 
4347					 
4347			 
4347			 
4347					NEXTW 
4347 c3 47 21			jp macro_next 
434a				endm 
# End of macro NEXTW
434a			 
434a			.LEFT: 
434a				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
434a 48				db WORD_SYS_CORE+52             
434b 72 43			dw .RIGHT            
434d 05				db 4 + 1 
434e .. 00			db "LEFT",0              
4353				endm 
# End of macro CWHEAD
4353			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4353					if DEBUG_FORTH_WORDS_KEY 
4353						DMARK "LEF" 
4353 f5				push af  
4354 3a 68 43			ld a, (.dmark)  
4357 32 b4 fe			ld (debug_mark),a  
435a 3a 69 43			ld a, (.dmark+1)  
435d 32 b5 fe			ld (debug_mark+1),a  
4360 3a 6a 43			ld a, (.dmark+2)  
4363 32 b6 fe			ld (debug_mark+2),a  
4366 18 03			jr .pastdmark  
4368 ..			.dmark: db "LEF"  
436b f1			.pastdmark: pop af  
436c			endm  
# End of macro DMARK
436c						CALLMONITOR 
436c cd 70 17			call break_point_state  
436f				endm  
# End of macro CALLMONITOR
436f					endif 
436f			 
436f					NEXTW 
436f c3 47 21			jp macro_next 
4372				endm 
# End of macro NEXTW
4372			.RIGHT: 
4372				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4372 48				db WORD_SYS_CORE+52             
4373 9b 43			dw .STR2NUM            
4375 06				db 5 + 1 
4376 .. 00			db "RIGHT",0              
437c				endm 
# End of macro CWHEAD
437c			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
437c					if DEBUG_FORTH_WORDS_KEY 
437c						DMARK "RIG" 
437c f5				push af  
437d 3a 91 43			ld a, (.dmark)  
4380 32 b4 fe			ld (debug_mark),a  
4383 3a 92 43			ld a, (.dmark+1)  
4386 32 b5 fe			ld (debug_mark+1),a  
4389 3a 93 43			ld a, (.dmark+2)  
438c 32 b6 fe			ld (debug_mark+2),a  
438f 18 03			jr .pastdmark  
4391 ..			.dmark: db "RIG"  
4394 f1			.pastdmark: pop af  
4395			endm  
# End of macro DMARK
4395						CALLMONITOR 
4395 cd 70 17			call break_point_state  
4398				endm  
# End of macro CALLMONITOR
4398					endif 
4398			 
4398					NEXTW 
4398 c3 47 21			jp macro_next 
439b				endm 
# End of macro NEXTW
439b			 
439b			 
439b			.STR2NUM: 
439b				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
439b 48				db WORD_SYS_CORE+52             
439c 27 44			dw .NUM2STR            
439e 08				db 7 + 1 
439f .. 00			db "STR2NUM",0              
43a7				endm 
# End of macro CWHEAD
43a7			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
43a7			 
43a7			 
43a7			; TODO STR type check to do 
43a7					if DEBUG_FORTH_WORDS_KEY 
43a7						DMARK "S2N" 
43a7 f5				push af  
43a8 3a bc 43			ld a, (.dmark)  
43ab 32 b4 fe			ld (debug_mark),a  
43ae 3a bd 43			ld a, (.dmark+1)  
43b1 32 b5 fe			ld (debug_mark+1),a  
43b4 3a be 43			ld a, (.dmark+2)  
43b7 32 b6 fe			ld (debug_mark+2),a  
43ba 18 03			jr .pastdmark  
43bc ..			.dmark: db "S2N"  
43bf f1			.pastdmark: pop af  
43c0			endm  
# End of macro DMARK
43c0						CALLMONITOR 
43c0 cd 70 17			call break_point_state  
43c3				endm  
# End of macro CALLMONITOR
43c3					endif 
43c3			 
43c3					;FORTH_DSP 
43c3					FORTH_DSP_VALUE 
43c3 cd be 1f			call macro_forth_dsp_value 
43c6				endm 
# End of macro FORTH_DSP_VALUE
43c6					;inc hl 
43c6			 
43c6 eb					ex de, hl 
43c7					if DEBUG_FORTH_WORDS 
43c7						DMARK "S2a" 
43c7 f5				push af  
43c8 3a dc 43			ld a, (.dmark)  
43cb 32 b4 fe			ld (debug_mark),a  
43ce 3a dd 43			ld a, (.dmark+1)  
43d1 32 b5 fe			ld (debug_mark+1),a  
43d4 3a de 43			ld a, (.dmark+2)  
43d7 32 b6 fe			ld (debug_mark+2),a  
43da 18 03			jr .pastdmark  
43dc ..			.dmark: db "S2a"  
43df f1			.pastdmark: pop af  
43e0			endm  
# End of macro DMARK
43e0						CALLMONITOR 
43e0 cd 70 17			call break_point_state  
43e3				endm  
# End of macro CALLMONITOR
43e3					endif 
43e3 cd e8 11				call string_to_uint16 
43e6			 
43e6					if DEBUG_FORTH_WORDS 
43e6						DMARK "S2b" 
43e6 f5				push af  
43e7 3a fb 43			ld a, (.dmark)  
43ea 32 b4 fe			ld (debug_mark),a  
43ed 3a fc 43			ld a, (.dmark+1)  
43f0 32 b5 fe			ld (debug_mark+1),a  
43f3 3a fd 43			ld a, (.dmark+2)  
43f6 32 b6 fe			ld (debug_mark+2),a  
43f9 18 03			jr .pastdmark  
43fb ..			.dmark: db "S2b"  
43fe f1			.pastdmark: pop af  
43ff			endm  
# End of macro DMARK
43ff						CALLMONITOR 
43ff cd 70 17			call break_point_state  
4402				endm  
# End of macro CALLMONITOR
4402					endif 
4402			;		push hl 
4402					FORTH_DSP_POP 
4402 cd 8d 20			call macro_forth_dsp_pop 
4405				endm 
# End of macro FORTH_DSP_POP
4405			;		pop hl 
4405					 
4405					if DEBUG_FORTH_WORDS 
4405						DMARK "S2b" 
4405 f5				push af  
4406 3a 1a 44			ld a, (.dmark)  
4409 32 b4 fe			ld (debug_mark),a  
440c 3a 1b 44			ld a, (.dmark+1)  
440f 32 b5 fe			ld (debug_mark+1),a  
4412 3a 1c 44			ld a, (.dmark+2)  
4415 32 b6 fe			ld (debug_mark+2),a  
4418 18 03			jr .pastdmark  
441a ..			.dmark: db "S2b"  
441d f1			.pastdmark: pop af  
441e			endm  
# End of macro DMARK
441e						CALLMONITOR 
441e cd 70 17			call break_point_state  
4421				endm  
# End of macro CALLMONITOR
4421					endif 
4421 cd de 1d				call forth_push_numhl	 
4424			 
4424				 
4424				       NEXTW 
4424 c3 47 21			jp macro_next 
4427				endm 
# End of macro NEXTW
4427			.NUM2STR: 
4427				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4427 48				db WORD_SYS_CORE+52             
4428 36 44			dw .CONCAT            
442a 08				db 7 + 1 
442b .. 00			db "NUM2STR",0              
4433				endm 
# End of macro CWHEAD
4433			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4433			 
4433			;		; malloc a string to target 
4433			;		ld hl, 10     ; TODO max string size should be fine 
4433			;		call malloc 
4433			;		push hl    ; save malloc location 
4433			; 
4433			; 
4433			;; TODO check int type 
4433			;		FORTH_DSP_VALUEHL 
4433			;		ld a, l 
4433			;		call DispAToASCII   
4433			;;TODO need to chage above call to dump into string 
4433			; 
4433			; 
4433			 
4433				       NEXTW 
4433 c3 47 21			jp macro_next 
4436				endm 
# End of macro NEXTW
4436			 
4436			.CONCAT: 
4436				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4436 48				db WORD_SYS_CORE+52             
4437 e9 44			dw .FIND            
4439 07				db 6 + 1 
443a .. 00			db "CONCAT",0              
4441				endm 
# End of macro CWHEAD
4441			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4441			 
4441			; TODO check string type 
4441			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4441			 
4441					if DEBUG_FORTH_WORDS_KEY 
4441						DMARK "CON" 
4441 f5				push af  
4442 3a 56 44			ld a, (.dmark)  
4445 32 b4 fe			ld (debug_mark),a  
4448 3a 57 44			ld a, (.dmark+1)  
444b 32 b5 fe			ld (debug_mark+1),a  
444e 3a 58 44			ld a, (.dmark+2)  
4451 32 b6 fe			ld (debug_mark+2),a  
4454 18 03			jr .pastdmark  
4456 ..			.dmark: db "CON"  
4459 f1			.pastdmark: pop af  
445a			endm  
# End of macro DMARK
445a						CALLMONITOR 
445a cd 70 17			call break_point_state  
445d				endm  
# End of macro CALLMONITOR
445d					endif 
445d			 
445d			 
445d					FORTH_DSP_VALUE 
445d cd be 1f			call macro_forth_dsp_value 
4460				endm 
# End of macro FORTH_DSP_VALUE
4460 e5					push hl   ; s2 
4461			 
4461					FORTH_DSP_POP 
4461 cd 8d 20			call macro_forth_dsp_pop 
4464				endm 
# End of macro FORTH_DSP_POP
4464			 
4464					FORTH_DSP_VALUE 
4464 cd be 1f			call macro_forth_dsp_value 
4467				endm 
# End of macro FORTH_DSP_VALUE
4467			 
4467 e5					push hl   ; s1 
4468			 
4468					FORTH_DSP_POP 
4468 cd 8d 20			call macro_forth_dsp_pop 
446b				endm 
# End of macro FORTH_DSP_POP
446b					 
446b			 
446b					; copy s1 
446b			 
446b				 
446b					; save ptr 
446b e1					pop hl  
446c e5					push hl 
446d 3e 00				ld a, 0 
446f cd 5c 12				call strlent 
4472					;inc hl    ; zer0 
4472 06 00				ld b, 0 
4474 4d					ld c, l 
4475 e1					pop hl		 
4476 11 5a f4				ld de, scratch	 
4479					if DEBUG_FORTH_WORDS 
4479						DMARK "CO1" 
4479 f5				push af  
447a 3a 8e 44			ld a, (.dmark)  
447d 32 b4 fe			ld (debug_mark),a  
4480 3a 8f 44			ld a, (.dmark+1)  
4483 32 b5 fe			ld (debug_mark+1),a  
4486 3a 90 44			ld a, (.dmark+2)  
4489 32 b6 fe			ld (debug_mark+2),a  
448c 18 03			jr .pastdmark  
448e ..			.dmark: db "CO1"  
4491 f1			.pastdmark: pop af  
4492			endm  
# End of macro DMARK
4492						CALLMONITOR 
4492 cd 70 17			call break_point_state  
4495				endm  
# End of macro CALLMONITOR
4495					endif 
4495 ed b0				ldir 
4497			 
4497 e1					pop hl 
4498 e5					push hl 
4499 d5					push de 
449a			 
449a			 
449a 3e 00				ld a, 0 
449c cd 5c 12				call strlent 
449f 23					inc hl    ; zer0 
44a0 23					inc hl 
44a1 06 00				ld b, 0 
44a3 4d					ld c, l 
44a4 d1					pop de 
44a5 e1					pop hl		 
44a6					if DEBUG_FORTH_WORDS 
44a6						DMARK "CO2" 
44a6 f5				push af  
44a7 3a bb 44			ld a, (.dmark)  
44aa 32 b4 fe			ld (debug_mark),a  
44ad 3a bc 44			ld a, (.dmark+1)  
44b0 32 b5 fe			ld (debug_mark+1),a  
44b3 3a bd 44			ld a, (.dmark+2)  
44b6 32 b6 fe			ld (debug_mark+2),a  
44b9 18 03			jr .pastdmark  
44bb ..			.dmark: db "CO2"  
44be f1			.pastdmark: pop af  
44bf			endm  
# End of macro DMARK
44bf						CALLMONITOR 
44bf cd 70 17			call break_point_state  
44c2				endm  
# End of macro CALLMONITOR
44c2					endif 
44c2 ed b0				ldir 
44c4			 
44c4			 
44c4			 
44c4 21 5a f4				ld hl, scratch 
44c7					if DEBUG_FORTH_WORDS 
44c7						DMARK "CO5" 
44c7 f5				push af  
44c8 3a dc 44			ld a, (.dmark)  
44cb 32 b4 fe			ld (debug_mark),a  
44ce 3a dd 44			ld a, (.dmark+1)  
44d1 32 b5 fe			ld (debug_mark+1),a  
44d4 3a de 44			ld a, (.dmark+2)  
44d7 32 b6 fe			ld (debug_mark+2),a  
44da 18 03			jr .pastdmark  
44dc ..			.dmark: db "CO5"  
44df f1			.pastdmark: pop af  
44e0			endm  
# End of macro DMARK
44e0						CALLMONITOR 
44e0 cd 70 17			call break_point_state  
44e3				endm  
# End of macro CALLMONITOR
44e3					endif 
44e3			 
44e3 cd 4c 1e				call forth_push_str 
44e6			 
44e6			 
44e6			 
44e6			 
44e6				       NEXTW 
44e6 c3 47 21			jp macro_next 
44e9				endm 
# End of macro NEXTW
44e9			 
44e9			 
44e9			.FIND: 
44e9				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
44e9 4b				db WORD_SYS_CORE+55             
44ea a7 45			dw .LEN            
44ec 05				db 4 + 1 
44ed .. 00			db "FIND",0              
44f2				endm 
# End of macro CWHEAD
44f2			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
44f2			 
44f2					if DEBUG_FORTH_WORDS_KEY 
44f2						DMARK "FND" 
44f2 f5				push af  
44f3 3a 07 45			ld a, (.dmark)  
44f6 32 b4 fe			ld (debug_mark),a  
44f9 3a 08 45			ld a, (.dmark+1)  
44fc 32 b5 fe			ld (debug_mark+1),a  
44ff 3a 09 45			ld a, (.dmark+2)  
4502 32 b6 fe			ld (debug_mark+2),a  
4505 18 03			jr .pastdmark  
4507 ..			.dmark: db "FND"  
450a f1			.pastdmark: pop af  
450b			endm  
# End of macro DMARK
450b						CALLMONITOR 
450b cd 70 17			call break_point_state  
450e				endm  
# End of macro CALLMONITOR
450e					endif 
450e			 
450e			; TODO check string type 
450e					FORTH_DSP_VALUE 
450e cd be 1f			call macro_forth_dsp_value 
4511				endm 
# End of macro FORTH_DSP_VALUE
4511			 
4511 e5					push hl    
4512 7e					ld a,(hl)    ; char to find   
4513			; TODO change char to substr 
4513			 
4513 f5					push af 
4514					 
4514			 
4514			 
4514					if DEBUG_FORTH_WORDS 
4514						DMARK "FN1" 
4514 f5				push af  
4515 3a 29 45			ld a, (.dmark)  
4518 32 b4 fe			ld (debug_mark),a  
451b 3a 2a 45			ld a, (.dmark+1)  
451e 32 b5 fe			ld (debug_mark+1),a  
4521 3a 2b 45			ld a, (.dmark+2)  
4524 32 b6 fe			ld (debug_mark+2),a  
4527 18 03			jr .pastdmark  
4529 ..			.dmark: db "FN1"  
452c f1			.pastdmark: pop af  
452d			endm  
# End of macro DMARK
452d						CALLMONITOR 
452d cd 70 17			call break_point_state  
4530				endm  
# End of macro CALLMONITOR
4530					endif 
4530			 
4530					FORTH_DSP_POP 
4530 cd 8d 20			call macro_forth_dsp_pop 
4533				endm 
# End of macro FORTH_DSP_POP
4533			 
4533					; string to search 
4533			 
4533					FORTH_DSP_VALUE 
4533 cd be 1f			call macro_forth_dsp_value 
4536				endm 
# End of macro FORTH_DSP_VALUE
4536			 
4536 d1					pop de  ; d is char to find  
4537			 
4537					if DEBUG_FORTH_WORDS 
4537						DMARK "FN2" 
4537 f5				push af  
4538 3a 4c 45			ld a, (.dmark)  
453b 32 b4 fe			ld (debug_mark),a  
453e 3a 4d 45			ld a, (.dmark+1)  
4541 32 b5 fe			ld (debug_mark+1),a  
4544 3a 4e 45			ld a, (.dmark+2)  
4547 32 b6 fe			ld (debug_mark+2),a  
454a 18 03			jr .pastdmark  
454c ..			.dmark: db "FN2"  
454f f1			.pastdmark: pop af  
4550			endm  
# End of macro DMARK
4550						CALLMONITOR 
4550 cd 70 17			call break_point_state  
4553				endm  
# End of macro CALLMONITOR
4553					endif 
4553					 
4553 01 00 00				ld bc, 0 
4556 7e			.findchar:      ld a,(hl) 
4557 fe 00				cp 0   		 
4559 28 27				jr z, .finddone     
455b ba					cp d 
455c 28 20				jr z, .foundchar 
455e 03					inc bc 
455f 23					inc hl 
4560					if DEBUG_FORTH_WORDS 
4560						DMARK "FN3" 
4560 f5				push af  
4561 3a 75 45			ld a, (.dmark)  
4564 32 b4 fe			ld (debug_mark),a  
4567 3a 76 45			ld a, (.dmark+1)  
456a 32 b5 fe			ld (debug_mark+1),a  
456d 3a 77 45			ld a, (.dmark+2)  
4570 32 b6 fe			ld (debug_mark+2),a  
4573 18 03			jr .pastdmark  
4575 ..			.dmark: db "FN3"  
4578 f1			.pastdmark: pop af  
4579			endm  
# End of macro DMARK
4579						CALLMONITOR 
4579 cd 70 17			call break_point_state  
457c				endm  
# End of macro CALLMONITOR
457c					endif 
457c 18 d8				jr .findchar 
457e			 
457e			 
457e c5			.foundchar:	push bc 
457f e1					pop hl 
4580 18 03				jr .findexit 
4582			 
4582			 
4582							 
4582			 
4582			.finddone:     ; got to end of string with no find 
4582 21 00 00				ld hl, 0 
4585			.findexit: 
4585			 
4585					if DEBUG_FORTH_WORDS 
4585						DMARK "FNd" 
4585 f5				push af  
4586 3a 9a 45			ld a, (.dmark)  
4589 32 b4 fe			ld (debug_mark),a  
458c 3a 9b 45			ld a, (.dmark+1)  
458f 32 b5 fe			ld (debug_mark+1),a  
4592 3a 9c 45			ld a, (.dmark+2)  
4595 32 b6 fe			ld (debug_mark+2),a  
4598 18 03			jr .pastdmark  
459a ..			.dmark: db "FNd"  
459d f1			.pastdmark: pop af  
459e			endm  
# End of macro DMARK
459e						CALLMONITOR 
459e cd 70 17			call break_point_state  
45a1				endm  
# End of macro CALLMONITOR
45a1					endif 
45a1 cd de 1d			call forth_push_numhl 
45a4			 
45a4				       NEXTW 
45a4 c3 47 21			jp macro_next 
45a7				endm 
# End of macro NEXTW
45a7			 
45a7			.LEN: 
45a7				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
45a7 4c				db WORD_SYS_CORE+56             
45a8 dc 45			dw .CHAR            
45aa 06				db 5 + 1 
45ab .. 00			db "COUNT",0              
45b1				endm 
# End of macro CWHEAD
45b1			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
45b1			 
45b1					if DEBUG_FORTH_WORDS_KEY 
45b1						DMARK "CNT" 
45b1 f5				push af  
45b2 3a c6 45			ld a, (.dmark)  
45b5 32 b4 fe			ld (debug_mark),a  
45b8 3a c7 45			ld a, (.dmark+1)  
45bb 32 b5 fe			ld (debug_mark+1),a  
45be 3a c8 45			ld a, (.dmark+2)  
45c1 32 b6 fe			ld (debug_mark+2),a  
45c4 18 03			jr .pastdmark  
45c6 ..			.dmark: db "CNT"  
45c9 f1			.pastdmark: pop af  
45ca			endm  
# End of macro DMARK
45ca						CALLMONITOR 
45ca cd 70 17			call break_point_state  
45cd				endm  
# End of macro CALLMONITOR
45cd					endif 
45cd			; TODO check string type 
45cd					FORTH_DSP 
45cd cd 9b 1f			call macro_forth_dsp 
45d0				endm 
# End of macro FORTH_DSP
45d0					;v5FORTH_DSP_VALUE 
45d0			 
45d0 23					inc hl 
45d1			 
45d1 3e 00				ld a, 0 
45d3 cd 5c 12				call strlent 
45d6			 
45d6 cd de 1d				call forth_push_numhl 
45d9			 
45d9			 
45d9			 
45d9				       NEXTW 
45d9 c3 47 21			jp macro_next 
45dc				endm 
# End of macro NEXTW
45dc			.CHAR: 
45dc				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
45dc 4d				db WORD_SYS_CORE+57             
45dd 12 46			dw .ENDSTR            
45df 05				db 4 + 1 
45e0 .. 00			db "CHAR",0              
45e5				endm 
# End of macro CWHEAD
45e5			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
45e5					if DEBUG_FORTH_WORDS_KEY 
45e5						DMARK "CHR" 
45e5 f5				push af  
45e6 3a fa 45			ld a, (.dmark)  
45e9 32 b4 fe			ld (debug_mark),a  
45ec 3a fb 45			ld a, (.dmark+1)  
45ef 32 b5 fe			ld (debug_mark+1),a  
45f2 3a fc 45			ld a, (.dmark+2)  
45f5 32 b6 fe			ld (debug_mark+2),a  
45f8 18 03			jr .pastdmark  
45fa ..			.dmark: db "CHR"  
45fd f1			.pastdmark: pop af  
45fe			endm  
# End of macro DMARK
45fe						CALLMONITOR 
45fe cd 70 17			call break_point_state  
4601				endm  
# End of macro CALLMONITOR
4601					endif 
4601					FORTH_DSP 
4601 cd 9b 1f			call macro_forth_dsp 
4604				endm 
# End of macro FORTH_DSP
4604					;v5 FORTH_DSP_VALUE 
4604 23					inc hl      ; now at start of numeric as string 
4605			 
4605			;		push hl 
4605			 
4605					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4605 cd 8d 20			call macro_forth_dsp_pop 
4608				endm 
# End of macro FORTH_DSP_POP
4608			 
4608			;		pop hl 
4608			 
4608					; push the content of a onto the stack as a value 
4608			 
4608 7e					ld a,(hl)   ; get char 
4609 26 00				ld h,0 
460b 6f					ld l,a 
460c cd de 1d				call forth_push_numhl 
460f			 
460f				       NEXTW 
460f c3 47 21			jp macro_next 
4612				endm 
# End of macro NEXTW
4612			 
4612			 
4612			 
4612			 
4612			.ENDSTR: 
4612			; eof 
4612			 
# End of file forth_words_str.asm
4612			include "forth_words_key.asm" 
4612			 
4612			; | ## Keyboard Words 
4612			 
4612			.KEY: 
4612				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4612 3e				db WORD_SYS_CORE+42             
4613 42 46			dw .WAITK            
4615 04				db 3 + 1 
4616 .. 00			db "KEY",0              
461a				endm 
# End of macro CWHEAD
461a			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
461a			 
461a					if DEBUG_FORTH_WORDS_KEY 
461a						DMARK "KEY" 
461a f5				push af  
461b 3a 2f 46			ld a, (.dmark)  
461e 32 b4 fe			ld (debug_mark),a  
4621 3a 30 46			ld a, (.dmark+1)  
4624 32 b5 fe			ld (debug_mark+1),a  
4627 3a 31 46			ld a, (.dmark+2)  
462a 32 b6 fe			ld (debug_mark+2),a  
462d 18 03			jr .pastdmark  
462f ..			.dmark: db "KEY"  
4632 f1			.pastdmark: pop af  
4633			endm  
# End of macro DMARK
4633						CALLMONITOR 
4633 cd 70 17			call break_point_state  
4636				endm  
# End of macro CALLMONITOR
4636					endif 
4636			; TODO currently waits 
4636 cd 5c 69				call cin 
4639					;call cin_wait 
4639 6f					ld l, a 
463a 26 00				ld h, 0 
463c cd de 1d				call forth_push_numhl 
463f					NEXTW 
463f c3 47 21			jp macro_next 
4642				endm 
# End of macro NEXTW
4642			.WAITK: 
4642				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4642 3f				db WORD_SYS_CORE+43             
4643 74 46			dw .ACCEPT            
4645 06				db 5 + 1 
4646 .. 00			db "WAITK",0              
464c				endm 
# End of macro CWHEAD
464c			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
464c					if DEBUG_FORTH_WORDS_KEY 
464c						DMARK "WAI" 
464c f5				push af  
464d 3a 61 46			ld a, (.dmark)  
4650 32 b4 fe			ld (debug_mark),a  
4653 3a 62 46			ld a, (.dmark+1)  
4656 32 b5 fe			ld (debug_mark+1),a  
4659 3a 63 46			ld a, (.dmark+2)  
465c 32 b6 fe			ld (debug_mark+2),a  
465f 18 03			jr .pastdmark  
4661 ..			.dmark: db "WAI"  
4664 f1			.pastdmark: pop af  
4665			endm  
# End of macro DMARK
4665						CALLMONITOR 
4665 cd 70 17			call break_point_state  
4668				endm  
# End of macro CALLMONITOR
4668					endif 
4668 cd 4b 69				call cin_wait 
466b 6f					ld l, a 
466c 26 00				ld h, 0 
466e cd de 1d				call forth_push_numhl 
4671					NEXTW 
4671 c3 47 21			jp macro_next 
4674				endm 
# End of macro NEXTW
4674			.ACCEPT: 
4674				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4674 40				db WORD_SYS_CORE+44             
4675 d2 46			dw .EDIT            
4677 07				db 6 + 1 
4678 .. 00			db "ACCEPT",0              
467f				endm 
# End of macro CWHEAD
467f			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
467f					; TODO crashes on push 
467f					if DEBUG_FORTH_WORDS_KEY 
467f						DMARK "ACC" 
467f f5				push af  
4680 3a 94 46			ld a, (.dmark)  
4683 32 b4 fe			ld (debug_mark),a  
4686 3a 95 46			ld a, (.dmark+1)  
4689 32 b5 fe			ld (debug_mark+1),a  
468c 3a 96 46			ld a, (.dmark+2)  
468f 32 b6 fe			ld (debug_mark+2),a  
4692 18 03			jr .pastdmark  
4694 ..			.dmark: db "ACC"  
4697 f1			.pastdmark: pop af  
4698			endm  
# End of macro DMARK
4698						CALLMONITOR 
4698 cd 70 17			call break_point_state  
469b				endm  
# End of macro CALLMONITOR
469b					endif 
469b 21 58 f6				ld hl, os_input 
469e 3e 00				ld a, 0 
46a0 77					ld (hl),a 
46a1 3a c3 fc				ld a,(f_cursor_ptr) 
46a4 16 64				ld d, 100 
46a6 0e 00				ld c, 0 
46a8 1e 28				ld e, 40 
46aa cd 20 0e				call input_str 
46ad					; TODO perhaps do a type check and wrap in quotes if not a number 
46ad 21 58 f6				ld hl, os_input 
46b0					if DEBUG_FORTH_WORDS 
46b0						DMARK "AC1" 
46b0 f5				push af  
46b1 3a c5 46			ld a, (.dmark)  
46b4 32 b4 fe			ld (debug_mark),a  
46b7 3a c6 46			ld a, (.dmark+1)  
46ba 32 b5 fe			ld (debug_mark+1),a  
46bd 3a c7 46			ld a, (.dmark+2)  
46c0 32 b6 fe			ld (debug_mark+2),a  
46c3 18 03			jr .pastdmark  
46c5 ..			.dmark: db "AC1"  
46c8 f1			.pastdmark: pop af  
46c9			endm  
# End of macro DMARK
46c9						CALLMONITOR 
46c9 cd 70 17			call break_point_state  
46cc				endm  
# End of macro CALLMONITOR
46cc					endif 
46cc cd 4c 1e				call forth_push_str 
46cf					NEXTW 
46cf c3 47 21			jp macro_next 
46d2				endm 
# End of macro NEXTW
46d2			 
46d2			.EDIT: 
46d2				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
46d2 40				db WORD_SYS_CORE+44             
46d3 74 47			dw .ENDKEY            
46d5 05				db 4 + 1 
46d6 .. 00			db "EDIT",0              
46db				endm 
# End of macro CWHEAD
46db			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
46db			 
46db					; TODO does not copy from stack 
46db					if DEBUG_FORTH_WORDS_KEY 
46db						DMARK "EDT" 
46db f5				push af  
46dc 3a f0 46			ld a, (.dmark)  
46df 32 b4 fe			ld (debug_mark),a  
46e2 3a f1 46			ld a, (.dmark+1)  
46e5 32 b5 fe			ld (debug_mark+1),a  
46e8 3a f2 46			ld a, (.dmark+2)  
46eb 32 b6 fe			ld (debug_mark+2),a  
46ee 18 03			jr .pastdmark  
46f0 ..			.dmark: db "EDT"  
46f3 f1			.pastdmark: pop af  
46f4			endm  
# End of macro DMARK
46f4						CALLMONITOR 
46f4 cd 70 17			call break_point_state  
46f7				endm  
# End of macro CALLMONITOR
46f7					endif 
46f7			 
46f7					;FORTH_DSP 
46f7					FORTH_DSP_VALUEHL 
46f7 cd d5 1f			call macro_dsp_valuehl 
46fa				endm 
# End of macro FORTH_DSP_VALUEHL
46fa			;		inc hl    ; TODO do type check 
46fa			 
46fa			;		call get_word_hl 
46fa e5					push hl 
46fb					if DEBUG_FORTH_WORDS 
46fb						DMARK "EDp" 
46fb f5				push af  
46fc 3a 10 47			ld a, (.dmark)  
46ff 32 b4 fe			ld (debug_mark),a  
4702 3a 11 47			ld a, (.dmark+1)  
4705 32 b5 fe			ld (debug_mark+1),a  
4708 3a 12 47			ld a, (.dmark+2)  
470b 32 b6 fe			ld (debug_mark+2),a  
470e 18 03			jr .pastdmark  
4710 ..			.dmark: db "EDp"  
4713 f1			.pastdmark: pop af  
4714			endm  
# End of macro DMARK
4714						CALLMONITOR 
4714 cd 70 17			call break_point_state  
4717				endm  
# End of macro CALLMONITOR
4717					endif 
4717				;	ld a, 0 
4717 cd 51 12				call strlenz 
471a 23					inc hl 
471b			 
471b 06 00				ld b, 0 
471d 4d					ld c, l 
471e			 
471e e1					pop hl 
471f 11 58 f6				ld de, os_input 
4722					if DEBUG_FORTH_WORDS_KEY 
4722						DMARK "EDc" 
4722 f5				push af  
4723 3a 37 47			ld a, (.dmark)  
4726 32 b4 fe			ld (debug_mark),a  
4729 3a 38 47			ld a, (.dmark+1)  
472c 32 b5 fe			ld (debug_mark+1),a  
472f 3a 39 47			ld a, (.dmark+2)  
4732 32 b6 fe			ld (debug_mark+2),a  
4735 18 03			jr .pastdmark  
4737 ..			.dmark: db "EDc"  
473a f1			.pastdmark: pop af  
473b			endm  
# End of macro DMARK
473b						CALLMONITOR 
473b cd 70 17			call break_point_state  
473e				endm  
# End of macro CALLMONITOR
473e					endif 
473e ed b0				ldir 
4740			 
4740			 
4740 21 58 f6				ld hl, os_input 
4743					;ld a, 0 
4743					;ld (hl),a 
4743 3a c3 fc				ld a,(f_cursor_ptr) 
4746 16 64				ld d, 100 
4748 0e 00				ld c, 0 
474a 1e 28				ld e, 40 
474c cd 20 0e				call input_str 
474f					; TODO perhaps do a type check and wrap in quotes if not a number 
474f 21 58 f6				ld hl, os_input 
4752					if DEBUG_FORTH_WORDS 
4752						DMARK "ED1" 
4752 f5				push af  
4753 3a 67 47			ld a, (.dmark)  
4756 32 b4 fe			ld (debug_mark),a  
4759 3a 68 47			ld a, (.dmark+1)  
475c 32 b5 fe			ld (debug_mark+1),a  
475f 3a 69 47			ld a, (.dmark+2)  
4762 32 b6 fe			ld (debug_mark+2),a  
4765 18 03			jr .pastdmark  
4767 ..			.dmark: db "ED1"  
476a f1			.pastdmark: pop af  
476b			endm  
# End of macro DMARK
476b						CALLMONITOR 
476b cd 70 17			call break_point_state  
476e				endm  
# End of macro CALLMONITOR
476e					endif 
476e cd 4c 1e				call forth_push_str 
4771					NEXTW 
4771 c3 47 21			jp macro_next 
4774				endm 
# End of macro NEXTW
4774			 
4774			 
4774			 
4774			.ENDKEY: 
4774			; eof 
4774			 
# End of file forth_words_key.asm
4774			 
4774			if STORAGE_SE 
4774			   	include "forth_words_storage.asm" 
4774			 
4774			; | ## Fixed Storage Words 
4774			 
4774			.RECORD: 
4774			  
4774				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
4774 3a				db WORD_SYS_CORE+38             
4775 18 48			dw .BREAD            
4777 07				db 6 + 1 
4778 .. 00			db "RECORD",0              
477f				endm 
# End of macro CWHEAD
477f			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
477f			 
477f					if DEBUG_FORTH_WORDS_KEY 
477f						DMARK "REC" 
477f f5				push af  
4780 3a 94 47			ld a, (.dmark)  
4783 32 b4 fe			ld (debug_mark),a  
4786 3a 95 47			ld a, (.dmark+1)  
4789 32 b5 fe			ld (debug_mark+1),a  
478c 3a 96 47			ld a, (.dmark+2)  
478f 32 b6 fe			ld (debug_mark+2),a  
4792 18 03			jr .pastdmark  
4794 ..			.dmark: db "REC"  
4797 f1			.pastdmark: pop af  
4798			endm  
# End of macro DMARK
4798						CALLMONITOR 
4798 cd 70 17			call break_point_state  
479b				endm  
# End of macro CALLMONITOR
479b					endif 
479b			 
479b					FORTH_DSP_VALUEHL 
479b cd d5 1f			call macro_dsp_valuehl 
479e				endm 
# End of macro FORTH_DSP_VALUEHL
479e			 
479e e5					push hl    ; id 
479f			 
479f					FORTH_DSP_POP 
479f cd 8d 20			call macro_forth_dsp_pop 
47a2				endm 
# End of macro FORTH_DSP_POP
47a2			 
47a2					FORTH_DSP_VALUEHL 
47a2 cd d5 1f			call macro_dsp_valuehl 
47a5				endm 
# End of macro FORTH_DSP_VALUEHL
47a5			 
47a5					FORTH_DSP_POP 
47a5 cd 8d 20			call macro_forth_dsp_pop 
47a8				endm 
# End of macro FORTH_DSP_POP
47a8			 
47a8 d1					pop de     ; get file id 
47a9			 
47a9					; e = file id 
47a9					; l = file extent 
47a9			 
47a9			 
47a9					; construct request to access file extent 
47a9			 
47a9			;		ld a, e 
47a9 63					ld h, e 
47aa					 
47aa					 
47aa					 
47aa			 
47aa					; e has id 
47aa			 
47aa 11 df fc			ld de, store_page 
47ad					if DEBUG_FORTH_WORDS 
47ad						DMARK "REr" 
47ad f5				push af  
47ae 3a c2 47			ld a, (.dmark)  
47b1 32 b4 fe			ld (debug_mark),a  
47b4 3a c3 47			ld a, (.dmark+1)  
47b7 32 b5 fe			ld (debug_mark+1),a  
47ba 3a c4 47			ld a, (.dmark+2)  
47bd 32 b6 fe			ld (debug_mark+2),a  
47c0 18 03			jr .pastdmark  
47c2 ..			.dmark: db "REr"  
47c5 f1			.pastdmark: pop af  
47c6			endm  
# End of macro DMARK
47c6						CALLMONITOR 
47c6 cd 70 17			call break_point_state  
47c9				endm  
# End of macro CALLMONITOR
47c9					endif 
47c9 cd 2a 09				call storage_read 
47cc cd 1c 0e			call ishlzero 
47cf 28 22			jr z, .recnotfound 
47d1			 
47d1			 
47d1					if DEBUG_FORTH_WORDS 
47d1						DMARK "REe" 
47d1 f5				push af  
47d2 3a e6 47			ld a, (.dmark)  
47d5 32 b4 fe			ld (debug_mark),a  
47d8 3a e7 47			ld a, (.dmark+1)  
47db 32 b5 fe			ld (debug_mark+1),a  
47de 3a e8 47			ld a, (.dmark+2)  
47e1 32 b6 fe			ld (debug_mark+2),a  
47e4 18 03			jr .pastdmark  
47e6 ..			.dmark: db "REe"  
47e9 f1			.pastdmark: pop af  
47ea			endm  
# End of macro DMARK
47ea						CALLMONITOR 
47ea cd 70 17			call break_point_state  
47ed				endm  
# End of macro CALLMONITOR
47ed					endif 
47ed cd 4c 1e			call forth_push_str 
47f0			 
47f0					NEXTW 
47f0 c3 47 21			jp macro_next 
47f3				endm 
# End of macro NEXTW
47f3			 
47f3			.recnotfound: 
47f3					if DEBUG_FORTH_WORDS 
47f3						DMARK "REf" 
47f3 f5				push af  
47f4 3a 08 48			ld a, (.dmark)  
47f7 32 b4 fe			ld (debug_mark),a  
47fa 3a 09 48			ld a, (.dmark+1)  
47fd 32 b5 fe			ld (debug_mark+1),a  
4800 3a 0a 48			ld a, (.dmark+2)  
4803 32 b6 fe			ld (debug_mark+2),a  
4806 18 03			jr .pastdmark  
4808 ..			.dmark: db "REf"  
480b f1			.pastdmark: pop af  
480c			endm  
# End of macro DMARK
480c						CALLMONITOR 
480c cd 70 17			call break_point_state  
480f				endm  
# End of macro CALLMONITOR
480f					endif 
480f 21 ff 00			ld hl, 255 
4812 cd de 1d			call forth_push_numhl 
4815				NEXTW 
4815 c3 47 21			jp macro_next 
4818				endm 
# End of macro NEXTW
4818			 
4818			 
4818			.BREAD: 
4818			  
4818				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4818 3a				db WORD_SYS_CORE+38             
4819 9b 48			dw .BWRITE            
481b 06				db 5 + 1 
481c .. 00			db "BREAD",0              
4822				endm 
# End of macro CWHEAD
4822			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
4822				 
4822					if DEBUG_FORTH_WORDS_KEY 
4822						DMARK "BRD" 
4822 f5				push af  
4823 3a 37 48			ld a, (.dmark)  
4826 32 b4 fe			ld (debug_mark),a  
4829 3a 38 48			ld a, (.dmark+1)  
482c 32 b5 fe			ld (debug_mark+1),a  
482f 3a 39 48			ld a, (.dmark+2)  
4832 32 b6 fe			ld (debug_mark+2),a  
4835 18 03			jr .pastdmark  
4837 ..			.dmark: db "BRD"  
483a f1			.pastdmark: pop af  
483b			endm  
# End of macro DMARK
483b						CALLMONITOR 
483b cd 70 17			call break_point_state  
483e				endm  
# End of macro CALLMONITOR
483e					endif 
483e			 
483e				FORTH_DSP_VALUEHL 
483e cd d5 1f			call macro_dsp_valuehl 
4841				endm 
# End of macro FORTH_DSP_VALUEHL
4841			 
4841				FORTH_DSP_POP 
4841 cd 8d 20			call macro_forth_dsp_pop 
4844				endm 
# End of macro FORTH_DSP_POP
4844			 
4844				; calc block address 
4844			 
4844 eb				ex de, hl 
4845 3e 40			ld a, STORE_BLOCK_PHY 
4847 cd 76 0d			call Mult16 
484a			 
484a			 
484a 11 df fc			ld de, store_page 
484d			 
484d					if DEBUG_FORTH_WORDS 
484d						DMARK "BR1" 
484d f5				push af  
484e 3a 62 48			ld a, (.dmark)  
4851 32 b4 fe			ld (debug_mark),a  
4854 3a 63 48			ld a, (.dmark+1)  
4857 32 b5 fe			ld (debug_mark+1),a  
485a 3a 64 48			ld a, (.dmark+2)  
485d 32 b6 fe			ld (debug_mark+2),a  
4860 18 03			jr .pastdmark  
4862 ..			.dmark: db "BR1"  
4865 f1			.pastdmark: pop af  
4866			endm  
# End of macro DMARK
4866						CALLMONITOR 
4866 cd 70 17			call break_point_state  
4869				endm  
# End of macro CALLMONITOR
4869					endif 
4869			 
4869 cd d1 03			call storage_read_block 
486c			 
486c cd 1c 0e			call ishlzero 
486f 20 05			jr nz, .brfound 
4871			 
4871 cd de 1d			call forth_push_numhl 
4874 18 22			jr .brdone 
4876			 
4876			 
4876			.brfound: 
4876 21 e1 fc		        ld hl, store_page+2 
4879			 
4879					if DEBUG_FORTH_WORDS 
4879						DMARK "BR2" 
4879 f5				push af  
487a 3a 8e 48			ld a, (.dmark)  
487d 32 b4 fe			ld (debug_mark),a  
4880 3a 8f 48			ld a, (.dmark+1)  
4883 32 b5 fe			ld (debug_mark+1),a  
4886 3a 90 48			ld a, (.dmark+2)  
4889 32 b6 fe			ld (debug_mark+2),a  
488c 18 03			jr .pastdmark  
488e ..			.dmark: db "BR2"  
4891 f1			.pastdmark: pop af  
4892			endm  
# End of macro DMARK
4892						CALLMONITOR 
4892 cd 70 17			call break_point_state  
4895				endm  
# End of macro CALLMONITOR
4895					endif 
4895			 
4895 cd 4c 1e			call forth_push_str 
4898			 
4898			 
4898			.brdone: 
4898			 
4898					NEXTW 
4898 c3 47 21			jp macro_next 
489b				endm 
# End of macro NEXTW
489b			.BWRITE: 
489b				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
489b 3a				db WORD_SYS_CORE+38             
489c 30 49			dw .BUPD            
489e 07				db 6 + 1 
489f .. 00			db "BWRITE",0              
48a6				endm 
# End of macro CWHEAD
48a6			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to address u | DONE 
48a6			 
48a6					if DEBUG_FORTH_WORDS_KEY 
48a6						DMARK "BWR" 
48a6 f5				push af  
48a7 3a bb 48			ld a, (.dmark)  
48aa 32 b4 fe			ld (debug_mark),a  
48ad 3a bc 48			ld a, (.dmark+1)  
48b0 32 b5 fe			ld (debug_mark+1),a  
48b3 3a bd 48			ld a, (.dmark+2)  
48b6 32 b6 fe			ld (debug_mark+2),a  
48b9 18 03			jr .pastdmark  
48bb ..			.dmark: db "BWR"  
48be f1			.pastdmark: pop af  
48bf			endm  
# End of macro DMARK
48bf						CALLMONITOR 
48bf cd 70 17			call break_point_state  
48c2				endm  
# End of macro CALLMONITOR
48c2					endif 
48c2			 
48c2				FORTH_DSP_VALUEHL 
48c2 cd d5 1f			call macro_dsp_valuehl 
48c5				endm 
# End of macro FORTH_DSP_VALUEHL
48c5			 
48c5				; calc block address 
48c5			 
48c5 eb				ex de, hl 
48c6 3e 40			ld a, STORE_BLOCK_PHY 
48c8 cd 76 0d			call Mult16 
48cb			 
48cb e5				push hl         ; address 
48cc			 
48cc				FORTH_DSP_POP 
48cc cd 8d 20			call macro_forth_dsp_pop 
48cf				endm 
# End of macro FORTH_DSP_POP
48cf			 
48cf				FORTH_DSP_VALUEHL 
48cf cd d5 1f			call macro_dsp_valuehl 
48d2				endm 
# End of macro FORTH_DSP_VALUEHL
48d2			 
48d2				FORTH_DSP_POP 
48d2 cd 8d 20			call macro_forth_dsp_pop 
48d5				endm 
# End of macro FORTH_DSP_POP
48d5			 
48d5 cd ff 0a			call storage_clear_page 
48d8			 
48d8				; copy string to store page 
48d8			 
48d8 e5				push hl     ; save string address 
48d9			 
48d9 3e 00			ld a, 0 
48db cd 5c 12			call strlent 
48de			 
48de 23				inc hl 
48df			 
48df 4d				ld c, l 
48e0 06 00			ld b, 0 
48e2			 
48e2 e1				pop hl 
48e3 11 e1 fc			ld de, store_page + 2 
48e6					if DEBUG_FORTH_WORDS 
48e6						DMARK "BW1" 
48e6 f5				push af  
48e7 3a fb 48			ld a, (.dmark)  
48ea 32 b4 fe			ld (debug_mark),a  
48ed 3a fc 48			ld a, (.dmark+1)  
48f0 32 b5 fe			ld (debug_mark+1),a  
48f3 3a fd 48			ld a, (.dmark+2)  
48f6 32 b6 fe			ld (debug_mark+2),a  
48f9 18 03			jr .pastdmark  
48fb ..			.dmark: db "BW1"  
48fe f1			.pastdmark: pop af  
48ff			endm  
# End of macro DMARK
48ff						CALLMONITOR 
48ff cd 70 17			call break_point_state  
4902				endm  
# End of macro CALLMONITOR
4902					endif 
4902 ed b0			ldir 
4904			 
4904			 
4904				; poke the start of the block with flags to prevent high level file ops hitting the block 
4904			 
4904 21 ff ff			ld hl, $ffff 
4907			 
4907 22 df fc			ld (store_page), hl	 
490a				 
490a e1				pop hl    ; get address 
490b 11 df fc			ld de, store_page 
490e			 
490e					if DEBUG_FORTH_WORDS 
490e						DMARK "BW2" 
490e f5				push af  
490f 3a 23 49			ld a, (.dmark)  
4912 32 b4 fe			ld (debug_mark),a  
4915 3a 24 49			ld a, (.dmark+1)  
4918 32 b5 fe			ld (debug_mark+1),a  
491b 3a 25 49			ld a, (.dmark+2)  
491e 32 b6 fe			ld (debug_mark+2),a  
4921 18 03			jr .pastdmark  
4923 ..			.dmark: db "BW2"  
4926 f1			.pastdmark: pop af  
4927			endm  
# End of macro DMARK
4927						CALLMONITOR 
4927 cd 70 17			call break_point_state  
492a				endm  
# End of macro CALLMONITOR
492a					endif 
492a			 
492a cd 36 04			call storage_write_block 
492d			 
492d					NEXTW 
492d c3 47 21			jp macro_next 
4930				endm 
# End of macro NEXTW
4930			 
4930			.BUPD: 
4930				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4930 3a				db WORD_SYS_CORE+38             
4931 86 49			dw .BYID            
4933 05				db 4 + 1 
4934 .. 00			db "BUPD",0              
4939				endm 
# End of macro CWHEAD
4939			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to address u | DONE 
4939			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4939			; | | or completely different file system structure. 
4939			 
4939					if DEBUG_FORTH_WORDS_KEY 
4939						DMARK "BUD" 
4939 f5				push af  
493a 3a 4e 49			ld a, (.dmark)  
493d 32 b4 fe			ld (debug_mark),a  
4940 3a 4f 49			ld a, (.dmark+1)  
4943 32 b5 fe			ld (debug_mark+1),a  
4946 3a 50 49			ld a, (.dmark+2)  
4949 32 b6 fe			ld (debug_mark+2),a  
494c 18 03			jr .pastdmark  
494e ..			.dmark: db "BUD"  
4951 f1			.pastdmark: pop af  
4952			endm  
# End of macro DMARK
4952						CALLMONITOR 
4952 cd 70 17			call break_point_state  
4955				endm  
# End of macro CALLMONITOR
4955					endif 
4955			 
4955				FORTH_DSP_VALUEHL 
4955 cd d5 1f			call macro_dsp_valuehl 
4958				endm 
# End of macro FORTH_DSP_VALUEHL
4958			 
4958				; calc block address 
4958			 
4958 eb				ex de, hl 
4959 3e 40			ld a, STORE_BLOCK_PHY 
495b cd 76 0d			call Mult16 
495e			 
495e				FORTH_DSP_POP 
495e cd 8d 20			call macro_forth_dsp_pop 
4961				endm 
# End of macro FORTH_DSP_POP
4961			 
4961			 
4961 11 df fc			ld de, store_page 
4964			 
4964					if DEBUG_FORTH_WORDS 
4964						DMARK "BUe" 
4964 f5				push af  
4965 3a 79 49			ld a, (.dmark)  
4968 32 b4 fe			ld (debug_mark),a  
496b 3a 7a 49			ld a, (.dmark+1)  
496e 32 b5 fe			ld (debug_mark+1),a  
4971 3a 7b 49			ld a, (.dmark+2)  
4974 32 b6 fe			ld (debug_mark+2),a  
4977 18 03			jr .pastdmark  
4979 ..			.dmark: db "BUe"  
497c f1			.pastdmark: pop af  
497d			endm  
# End of macro DMARK
497d						CALLMONITOR 
497d cd 70 17			call break_point_state  
4980				endm  
# End of macro CALLMONITOR
4980					endif 
4980			 
4980 cd 36 04			call storage_write_block 
4983			 
4983					NEXTW 
4983 c3 47 21			jp macro_next 
4986				endm 
# End of macro NEXTW
4986			 
4986			.BYID: 
4986			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4986			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4986			; 
4986			;		 
4986			;		if DEBUG_FORTH_WORDS_KEY 
4986			;			DMARK "BYID" 
4986			;			CALLMONITOR 
4986			;		endif 
4986			; 
4986			;		; get direct address 
4986			; 
4986			;		FORTH_DSP_VALUEHL 
4986			; 
4986			;		FORTH_DSP_POP 
4986			; 
4986			;	; calc block address 
4986			; 
4986			;	ex de, hl 
4986			;	ld a, STORE_BLOCK_PHY 
4986			;	call Mult16 
4986			;	;	do BREAD with number as param 
4986			;	; push the file name	 
4986			;	ld de, store_page 
4986			;	call storage_read_block 
4986			 ;       ld hl, store_page+2 
4986			; 
4986			; 
4986			;		NEXTW 
4986			;.BYNAME: 
4986				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
4986 3a				db WORD_SYS_CORE+38             
4987 9f 49			dw .DIR            
4989 06				db 5 + 1 
498a .. 00			db "GETID",0              
4990				endm 
# End of macro CWHEAD
4990			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
4990			 
4990					; get pointer to file name to seek 
4990			 
4990					FORTH_DSP_VALUEHL 
4990 cd d5 1f			call macro_dsp_valuehl 
4993				endm 
# End of macro FORTH_DSP_VALUEHL
4993			 
4993			 
4993 cd f8 02				call storage_getid  
4996			 
4996					FORTH_DSP_POP 
4996 cd 8d 20			call macro_forth_dsp_pop 
4999				endm 
# End of macro FORTH_DSP_POP
4999			 
4999 cd de 1d				call forth_push_numhl 
499c			 
499c					NEXTW 
499c c3 47 21			jp macro_next 
499f				endm 
# End of macro NEXTW
499f			; 
499f			.DIR: 
499f				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
499f 3a				db WORD_SYS_CORE+38             
49a0 a3 4a			dw .SAVE            
49a2 04				db 3 + 1 
49a3 .. 00			db "DIR",0              
49a7				endm 
# End of macro CWHEAD
49a7			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
49a7			 
49a7					if DEBUG_FORTH_WORDS_KEY 
49a7						DMARK "DIR" 
49a7 f5				push af  
49a8 3a bc 49			ld a, (.dmark)  
49ab 32 b4 fe			ld (debug_mark),a  
49ae 3a bd 49			ld a, (.dmark+1)  
49b1 32 b5 fe			ld (debug_mark+1),a  
49b4 3a be 49			ld a, (.dmark+2)  
49b7 32 b6 fe			ld (debug_mark+2),a  
49ba 18 03			jr .pastdmark  
49bc ..			.dmark: db "DIR"  
49bf f1			.pastdmark: pop af  
49c0			endm  
# End of macro DMARK
49c0						CALLMONITOR 
49c0 cd 70 17			call break_point_state  
49c3				endm  
# End of macro CALLMONITOR
49c3					endif 
49c3 cd 82 04			call storage_get_block_0 
49c6			 
49c6 21 df fc			ld hl, store_page     ; get current id count 
49c9 46				ld b, (hl) 
49ca 0e 00			ld c, 0    ; count of files   
49cc					if DEBUG_FORTH_WORDS 
49cc						DMARK "DI1" 
49cc f5				push af  
49cd 3a e1 49			ld a, (.dmark)  
49d0 32 b4 fe			ld (debug_mark),a  
49d3 3a e2 49			ld a, (.dmark+1)  
49d6 32 b5 fe			ld (debug_mark+1),a  
49d9 3a e3 49			ld a, (.dmark+2)  
49dc 32 b6 fe			ld (debug_mark+2),a  
49df 18 03			jr .pastdmark  
49e1 ..			.dmark: db "DI1"  
49e4 f1			.pastdmark: pop af  
49e5			endm  
# End of macro DMARK
49e5						CALLMONITOR 
49e5 cd 70 17			call break_point_state  
49e8				endm  
# End of macro CALLMONITOR
49e8					endif 
49e8			 
49e8				; check for empty drive 
49e8			 
49e8 3e 00			ld a, 0 
49ea b8				cp b 
49eb ca 59 4a			jp z, .dirdone 
49ee			 
49ee				; for each of the current ids do a search for them and if found push to stack 
49ee			 
49ee c5			.diritem:	push bc 
49ef 21 40 00				ld hl, STORE_BLOCK_PHY 
49f2 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
49f4 58					ld e,b 
49f5			 
49f5			;		if DEBUG_FORTH_WORDS 
49f5			;			DMARK "DI2" 
49f5			;			CALLMONITOR 
49f5			;		endif 
49f5			 
49f5 cd 04 07				call storage_findnextid 
49f8			 
49f8			;		if DEBUG_FORTH_WORDS 
49f8			;			DMARK "DI3" 
49f8			;			CALLMONITOR 
49f8			;		endif 
49f8			 
49f8					; if found hl will be non zero 
49f8			 
49f8 cd 1c 0e				call ishlzero 
49fb			;		ld a, l 
49fb			;		add h 
49fb			; 
49fb			;		cp 0 
49fb 28 59				jr z, .dirnotfound 
49fd			 
49fd					; increase count 
49fd			 
49fd c1					pop bc	 
49fe 0c					inc c 
49ff c5					push bc 
4a00					 
4a00			 
4a00					; get file header and push the file name 
4a00			 
4a00 11 df fc				ld de, store_page 
4a03 cd d1 03				call storage_read_block 
4a06			 
4a06					; push file id to stack 
4a06				 
4a06 3a df fc				ld a, (store_page) 
4a09 26 00				ld h, 0 
4a0b 6f					ld l, a 
4a0c cd de 1d				call forth_push_numhl 
4a0f			 
4a0f					; push extent count to stack  
4a0f				 
4a0f 3a e1 fc				ld a, (store_page+2) 
4a12 26 00				ld h, 0 
4a14 6f					ld l, a 
4a15 cd de 1d				call forth_push_numhl 
4a18			 
4a18					; push file name 
4a18			 
4a18 21 e2 fc				ld hl, store_page+3 
4a1b					if DEBUG_FORTH_WORDS 
4a1b						DMARK "DI5" 
4a1b f5				push af  
4a1c 3a 30 4a			ld a, (.dmark)  
4a1f 32 b4 fe			ld (debug_mark),a  
4a22 3a 31 4a			ld a, (.dmark+1)  
4a25 32 b5 fe			ld (debug_mark+1),a  
4a28 3a 32 4a			ld a, (.dmark+2)  
4a2b 32 b6 fe			ld (debug_mark+2),a  
4a2e 18 03			jr .pastdmark  
4a30 ..			.dmark: db "DI5"  
4a33 f1			.pastdmark: pop af  
4a34			endm  
# End of macro DMARK
4a34						CALLMONITOR 
4a34 cd 70 17			call break_point_state  
4a37				endm  
# End of macro CALLMONITOR
4a37					endif 
4a37 cd 4c 1e				call forth_push_str 
4a3a					if DEBUG_FORTH_WORDS 
4a3a						DMARK "DI6" 
4a3a f5				push af  
4a3b 3a 4f 4a			ld a, (.dmark)  
4a3e 32 b4 fe			ld (debug_mark),a  
4a41 3a 50 4a			ld a, (.dmark+1)  
4a44 32 b5 fe			ld (debug_mark+1),a  
4a47 3a 51 4a			ld a, (.dmark+2)  
4a4a 32 b6 fe			ld (debug_mark+2),a  
4a4d 18 03			jr .pastdmark  
4a4f ..			.dmark: db "DI6"  
4a52 f1			.pastdmark: pop af  
4a53			endm  
# End of macro DMARK
4a53						CALLMONITOR 
4a53 cd 70 17			call break_point_state  
4a56				endm  
# End of macro CALLMONITOR
4a56					endif 
4a56			.dirnotfound: 
4a56 c1					pop bc     
4a57 10 95				djnz .diritem 
4a59				 
4a59			.dirdone:	 
4a59					if DEBUG_FORTH_WORDS 
4a59						DMARK "DI7" 
4a59 f5				push af  
4a5a 3a 6e 4a			ld a, (.dmark)  
4a5d 32 b4 fe			ld (debug_mark),a  
4a60 3a 6f 4a			ld a, (.dmark+1)  
4a63 32 b5 fe			ld (debug_mark+1),a  
4a66 3a 70 4a			ld a, (.dmark+2)  
4a69 32 b6 fe			ld (debug_mark+2),a  
4a6c 18 03			jr .pastdmark  
4a6e ..			.dmark: db "DI7"  
4a71 f1			.pastdmark: pop af  
4a72			endm  
# End of macro DMARK
4a72						CALLMONITOR 
4a72 cd 70 17			call break_point_state  
4a75				endm  
# End of macro CALLMONITOR
4a75					endif 
4a75			 
4a75					; push a count of the dir items found 
4a75			 
4a75 26 00				ld h, 0 
4a77 69					ld l, c 
4a78 cd de 1d				call forth_push_numhl 
4a7b			 
4a7b					; push the bank label 
4a7b			 
4a7b cd 82 04				call storage_get_block_0 
4a7e			 
4a7e				 
4a7e 21 e2 fc		 		ld hl, store_page+3 
4a81			 
4a81					if DEBUG_FORTH_WORDS 
4a81						DMARK "DI8" 
4a81 f5				push af  
4a82 3a 96 4a			ld a, (.dmark)  
4a85 32 b4 fe			ld (debug_mark),a  
4a88 3a 97 4a			ld a, (.dmark+1)  
4a8b 32 b5 fe			ld (debug_mark+1),a  
4a8e 3a 98 4a			ld a, (.dmark+2)  
4a91 32 b6 fe			ld (debug_mark+2),a  
4a94 18 03			jr .pastdmark  
4a96 ..			.dmark: db "DI8"  
4a99 f1			.pastdmark: pop af  
4a9a			endm  
# End of macro DMARK
4a9a						CALLMONITOR 
4a9a cd 70 17			call break_point_state  
4a9d				endm  
# End of macro CALLMONITOR
4a9d					endif 
4a9d cd 4c 1e				call forth_push_str 
4aa0			 
4aa0			 
4aa0				 
4aa0					NEXTW 
4aa0 c3 47 21			jp macro_next 
4aa3				endm 
# End of macro NEXTW
4aa3			.SAVE: 
4aa3			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4aa3			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4aa3			;		NEXTW 
4aa3			;.LOAD: 
4aa3			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4aa3			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4aa3			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4aa3			;; > > The LOAD command can not be used in any user words or compound lines. 
4aa3			; 
4aa3			;		; store_openext use it. If zero it is EOF 
4aa3			; 
4aa3			;		; read block from current stream id 
4aa3			;		; if the block does not contain zero term keep reading blocks until zero found 
4aa3			;		; push the block to stack 
4aa3			;		; save the block id to stream 
4aa3			; 
4aa3			; 
4aa3			;		FORTH_DSP_VALUEHL 
4aa3			; 
4aa3			;;		push hl 
4aa3			; 
4aa3			;	if DEBUG_STORESE 
4aa3			;		DMARK "LOA" 
4aa3			;		CALLMONITOR 
4aa3			;	endif 
4aa3			;		FORTH_DSP_POP 
4aa3			; 
4aa3			;;		pop hl 
4aa3			; 
4aa3			;		ld h, l 
4aa3			;		ld l, 0 
4aa3			; 
4aa3			;		push hl     ; stack holds current file id and extent to work with 
4aa3			; 
4aa3			; 
4aa3			;		ld de, store_page      ; get block zero of file 
4aa3			;	if DEBUG_STORESE 
4aa3			;		DMARK "LO0" 
4aa3			;		CALLMONITOR 
4aa3			;	endif 
4aa3			;		call storage_read 
4aa3			; 
4aa3			;		ld a, (store_page+2)    ; max extents for this file 
4aa3			;		ld  (store_openmaxext),a   ; get our limit 
4aa3			; 
4aa3			;	if DEBUG_STORESE 
4aa3			;		DMARK "LOE" 
4aa3			;		CALLMONITOR 
4aa3			;	endif 
4aa3			; 
4aa3			;; TODO dont know why max extents are not present 
4aa3			;;		cp 0 
4aa3			;;		jp z, .loadeof     ; dont read past eof 
4aa3			; 
4aa3			;;		ld a, 1   ; start from the head of the file 
4aa3			; 
4aa3			;.loadline:	pop hl 
4aa3			;		inc hl 
4aa3			;		ld  a, (store_openmaxext)   ; get our limit 
4aa3			;	if DEBUG_STORESE 
4aa3			;		DMARK "LOx" 
4aa3			;		CALLMONITOR 
4aa3			;	endif 
4aa3			;		inc a 
4aa3			;		cp l 
4aa3			;		jp z, .loadeof 
4aa3			;		push hl    ; save current extent 
4aa3			; 
4aa3			;		ld de, store_page 
4aa3			; 
4aa3			;	if DEBUG_STORESE 
4aa3			;		DMARK "LO1" 
4aa3			;		CALLMONITOR 
4aa3			;	endif 
4aa3			;		call storage_read 
4aa3			; 
4aa3			;	if DEBUG_STORESE 
4aa3			;		DMARK "LO2" 
4aa3			;		CALLMONITOR 
4aa3			;	endif 
4aa3			;	call ishlzero 
4aa3			;	ld a, l 
4aa3			;	add h 
4aa3			;	cp 0 
4aa3			;	jr z, .loadeof 
4aa3			; 
4aa3			;	; not eof so hl should point to data to exec 
4aa3			; 
4aa3			;	; will need to add the FORTH_END_BUFFER flag 
4aa3			 ; 
4aa3			;	ld hl, store_page+2 
4aa3			;	ld bc, 255 
4aa3			;	ld a, 0 
4aa3			;	cpir 
4aa3			;	if DEBUG_STORESE 
4aa3			;		DMARK "LOt" 
4aa3			;		CALLMONITOR 
4aa3			;	endif 
4aa3			;	dec hl 
4aa3			;	ld a, ' ' 
4aa3			;	ld (hl), a 
4aa3			;	inc hl 
4aa3			;	ld (hl), a 
4aa3			;	inc hl 
4aa3			;	ld (hl), a 
4aa3			;	inc hl 
4aa3			;	ld a, FORTH_END_BUFFER 
4aa3			;	ld (hl), a 
4aa3			; 
4aa3			;	; TODO handle more than a single block read 
4aa3			; 
4aa3			; 
4aa3			;	ld hl, store_page+2 
4aa3			; 
4aa3			;	ld (os_tok_ptr), hl 
4aa3			; 
4aa3			;	if DEBUG_STORESE 
4aa3			;		DMARK "LO3" 
4aa3			;		CALLMONITOR 
4aa3			;	endif 
4aa3			; 
4aa3			;	call forthparse 
4aa3			;	call forthexec 
4aa3			;	call forthexec_cleanup 
4aa3			; 
4aa3			;	; go to next extent 
4aa3			; 
4aa3			;	; get next block  or mark as eof 
4aa3			;	jp .loadline 
4aa3			; 
4aa3			; 
4aa3			; 
4aa3			;	       NEXTW 
4aa3			;.loadeof:	ld a, 0 
4aa3			;		ld (store_openext), a 
4aa3			; 
4aa3			;	if DEBUG_STORESE 
4aa3			;		DMARK "LOF" 
4aa3			;		CALLMONITOR 
4aa3			;	endif 
4aa3			;		ret 
4aa3			;		;NEXTW 
4aa3			;.BSAVE:   
4aa3			; 
4aa3			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4aa3			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4aa3			;		NEXTW 
4aa3			;.BLOAD: 
4aa3			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4aa3			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4aa3			;		NEXTW 
4aa3			;;;; counter gap 
4aa3			 
4aa3			 
4aa3			.SEO: 
4aa3				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4aa3 64				db WORD_SYS_CORE+80             
4aa4 c2 4a			dw .SEI            
4aa6 04				db 3 + 1 
4aa7 .. 00			db "SEO",0              
4aab				endm 
# End of macro CWHEAD
4aab			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4aab			 
4aab					; get port 
4aab			 
4aab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aab cd d5 1f			call macro_dsp_valuehl 
4aae				endm 
# End of macro FORTH_DSP_VALUEHL
4aae			 
4aae e5					push hl    ; u2 - byte 
4aaf			 
4aaf					; destroy value TOS 
4aaf			 
4aaf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aaf cd 8d 20			call macro_forth_dsp_pop 
4ab2				endm 
# End of macro FORTH_DSP_POP
4ab2			 
4ab2					; get byte to send 
4ab2			 
4ab2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ab2 cd d5 1f			call macro_dsp_valuehl 
4ab5				endm 
# End of macro FORTH_DSP_VALUEHL
4ab5			 
4ab5 e5					push hl    ; u1 - addr 
4ab6			 
4ab6					; destroy value TOS 
4ab6			 
4ab6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ab6 cd 8d 20			call macro_forth_dsp_pop 
4ab9				endm 
# End of macro FORTH_DSP_POP
4ab9			 
4ab9					; one value on hl get other one back 
4ab9			 
4ab9 d1					pop de   ; u1 - byte 
4aba			 
4aba e1					pop hl   ; u2 - addr 
4abb			 
4abb					; TODO Send SPI byte 
4abb			 
4abb			 
4abb 7b					ld a, e 
4abc cd d6 01				call se_writebyte 
4abf			 
4abf					 
4abf			 
4abf					NEXTW 
4abf c3 47 21			jp macro_next 
4ac2				endm 
# End of macro NEXTW
4ac2			 
4ac2			.SEI: 
4ac2				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4ac2 65				db WORD_SYS_CORE+81             
4ac3 dc 4a			dw .SFREE            
4ac5 04				db 3 + 1 
4ac6 .. 00			db "SEI",0              
4aca				endm 
# End of macro CWHEAD
4aca			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4aca			 
4aca					; get port 
4aca			 
4aca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aca cd d5 1f			call macro_dsp_valuehl 
4acd				endm 
# End of macro FORTH_DSP_VALUEHL
4acd			 
4acd			;		push hl 
4acd			 
4acd					; destroy value TOS 
4acd			 
4acd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4acd cd 8d 20			call macro_forth_dsp_pop 
4ad0				endm 
# End of macro FORTH_DSP_POP
4ad0			 
4ad0					; one value on hl get other one back 
4ad0			 
4ad0			;		pop hl 
4ad0			 
4ad0			 
4ad0					; TODO Get SPI byte 
4ad0			 
4ad0 cd 78 02				call se_readbyte 
4ad3			 
4ad3 26 00				ld h, 0 
4ad5 6f					ld l, a 
4ad6 cd de 1d				call forth_push_numhl 
4ad9			 
4ad9					NEXTW 
4ad9 c3 47 21			jp macro_next 
4adc				endm 
# End of macro NEXTW
4adc			 
4adc			.SFREE: 
4adc				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4adc 67				db WORD_SYS_CORE+83             
4add 0b 4b			dw .SIZE            
4adf 06				db 5 + 1 
4ae0 .. 00			db "FFREE",0              
4ae6				endm 
# End of macro CWHEAD
4ae6			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4ae6					if DEBUG_FORTH_WORDS_KEY 
4ae6						DMARK "FFR" 
4ae6 f5				push af  
4ae7 3a fb 4a			ld a, (.dmark)  
4aea 32 b4 fe			ld (debug_mark),a  
4aed 3a fc 4a			ld a, (.dmark+1)  
4af0 32 b5 fe			ld (debug_mark+1),a  
4af3 3a fd 4a			ld a, (.dmark+2)  
4af6 32 b6 fe			ld (debug_mark+2),a  
4af9 18 03			jr .pastdmark  
4afb ..			.dmark: db "FFR"  
4afe f1			.pastdmark: pop af  
4aff			endm  
# End of macro DMARK
4aff						CALLMONITOR 
4aff cd 70 17			call break_point_state  
4b02				endm  
# End of macro CALLMONITOR
4b02					endif 
4b02			 
4b02 cd 9e 07				call storage_freeblocks 
4b05			 
4b05 cd de 1d				call forth_push_numhl 
4b08			 
4b08				       NEXTW 
4b08 c3 47 21			jp macro_next 
4b0b				endm 
# End of macro NEXTW
4b0b			.SIZE: 
4b0b				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4b0b 67				db WORD_SYS_CORE+83             
4b0c 3f 4b			dw .CREATE            
4b0e 05				db 4 + 1 
4b0f .. 00			db "SIZE",0              
4b14				endm 
# End of macro CWHEAD
4b14			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4b14					if DEBUG_FORTH_WORDS_KEY 
4b14						DMARK "SIZ" 
4b14 f5				push af  
4b15 3a 29 4b			ld a, (.dmark)  
4b18 32 b4 fe			ld (debug_mark),a  
4b1b 3a 2a 4b			ld a, (.dmark+1)  
4b1e 32 b5 fe			ld (debug_mark+1),a  
4b21 3a 2b 4b			ld a, (.dmark+2)  
4b24 32 b6 fe			ld (debug_mark+2),a  
4b27 18 03			jr .pastdmark  
4b29 ..			.dmark: db "SIZ"  
4b2c f1			.pastdmark: pop af  
4b2d			endm  
# End of macro DMARK
4b2d						CALLMONITOR 
4b2d cd 70 17			call break_point_state  
4b30				endm  
# End of macro CALLMONITOR
4b30					endif 
4b30			 
4b30					FORTH_DSP_VALUEHL 
4b30 cd d5 1f			call macro_dsp_valuehl 
4b33				endm 
# End of macro FORTH_DSP_VALUEHL
4b33			;		push hl 
4b33					FORTH_DSP_POP 
4b33 cd 8d 20			call macro_forth_dsp_pop 
4b36				endm 
# End of macro FORTH_DSP_POP
4b36			;		pop hl 
4b36 cd 00 04				call storage_file_size 
4b39			 
4b39 cd de 1d				call forth_push_numhl 
4b3c			  
4b3c			 
4b3c				       NEXTW 
4b3c c3 47 21			jp macro_next 
4b3f				endm 
# End of macro NEXTW
4b3f			 
4b3f			.CREATE: 
4b3f				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4b3f 68				db WORD_SYS_CORE+84             
4b40 ad 4b			dw .APPEND            
4b42 07				db 6 + 1 
4b43 .. 00			db "CREATE",0              
4b4a				endm 
# End of macro CWHEAD
4b4a			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
4b4a			; | | e.g.  
4b4a			; | | TestProgram CREATE 
4b4a			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4b4a			; | |  
4b4a			; | | Max file IDs are 255. 
4b4a			; | |  
4b4a					 
4b4a					if DEBUG_FORTH_WORDS_KEY 
4b4a						DMARK "CRT" 
4b4a f5				push af  
4b4b 3a 5f 4b			ld a, (.dmark)  
4b4e 32 b4 fe			ld (debug_mark),a  
4b51 3a 60 4b			ld a, (.dmark+1)  
4b54 32 b5 fe			ld (debug_mark+1),a  
4b57 3a 61 4b			ld a, (.dmark+2)  
4b5a 32 b6 fe			ld (debug_mark+2),a  
4b5d 18 03			jr .pastdmark  
4b5f ..			.dmark: db "CRT"  
4b62 f1			.pastdmark: pop af  
4b63			endm  
# End of macro DMARK
4b63						CALLMONITOR 
4b63 cd 70 17			call break_point_state  
4b66				endm  
# End of macro CALLMONITOR
4b66					endif 
4b66			;		call storage_get_block_0 
4b66			 
4b66					; TODO pop hl 
4b66			 
4b66					;v5 FORTH_DSP_VALUE 
4b66					FORTH_DSP_VALUE 
4b66 cd be 1f			call macro_forth_dsp_value 
4b69				endm 
# End of macro FORTH_DSP_VALUE
4b69			 
4b69				if DEBUG_STORESE 
4b69					DMARK "CR1" 
4b69 f5				push af  
4b6a 3a 7e 4b			ld a, (.dmark)  
4b6d 32 b4 fe			ld (debug_mark),a  
4b70 3a 7f 4b			ld a, (.dmark+1)  
4b73 32 b5 fe			ld (debug_mark+1),a  
4b76 3a 80 4b			ld a, (.dmark+2)  
4b79 32 b6 fe			ld (debug_mark+2),a  
4b7c 18 03			jr .pastdmark  
4b7e ..			.dmark: db "CR1"  
4b81 f1			.pastdmark: pop af  
4b82			endm  
# End of macro DMARK
4b82					CALLMONITOR 
4b82 cd 70 17			call break_point_state  
4b85				endm  
# End of macro CALLMONITOR
4b85				endif 
4b85			;		push hl 
4b85			;		FORTH_DSP_POP 
4b85			;		pop hl 
4b85			 
4b85			;		inc hl   ; move past the type marker 
4b85			 
4b85 cd d4 07				call storage_create 
4b88			 
4b88				if DEBUG_STORESE 
4b88					DMARK "CT1" 
4b88 f5				push af  
4b89 3a 9d 4b			ld a, (.dmark)  
4b8c 32 b4 fe			ld (debug_mark),a  
4b8f 3a 9e 4b			ld a, (.dmark+1)  
4b92 32 b5 fe			ld (debug_mark+1),a  
4b95 3a 9f 4b			ld a, (.dmark+2)  
4b98 32 b6 fe			ld (debug_mark+2),a  
4b9b 18 03			jr .pastdmark  
4b9d ..			.dmark: db "CT1"  
4ba0 f1			.pastdmark: pop af  
4ba1			endm  
# End of macro DMARK
4ba1					CALLMONITOR 
4ba1 cd 70 17			call break_point_state  
4ba4				endm  
# End of macro CALLMONITOR
4ba4				endif 
4ba4			;		push hl 
4ba4					FORTH_DSP_POP 
4ba4 cd 8d 20			call macro_forth_dsp_pop 
4ba7				endm 
# End of macro FORTH_DSP_POP
4ba7			;		pop hl 
4ba7					; push file id to stack 
4ba7 cd de 1d				call forth_push_numhl 
4baa			 
4baa			 
4baa			 
4baa				       NEXTW 
4baa c3 47 21			jp macro_next 
4bad				endm 
# End of macro NEXTW
4bad			 
4bad			.APPEND: 
4bad				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4bad 69				db WORD_SYS_CORE+85             
4bae 3e 4c			dw .SDEL            
4bb0 07				db 6 + 1 
4bb1 .. 00			db "APPEND",0              
4bb8				endm 
# End of macro CWHEAD
4bb8			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4bb8			; | | e.g. 
4bb8			; | | Test CREATE      -> $01 
4bb8			; | | "A string to add to file" $01 APPEND 
4bb8			; | |  
4bb8			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4bb8					if DEBUG_FORTH_WORDS_KEY 
4bb8						DMARK "APP" 
4bb8 f5				push af  
4bb9 3a cd 4b			ld a, (.dmark)  
4bbc 32 b4 fe			ld (debug_mark),a  
4bbf 3a ce 4b			ld a, (.dmark+1)  
4bc2 32 b5 fe			ld (debug_mark+1),a  
4bc5 3a cf 4b			ld a, (.dmark+2)  
4bc8 32 b6 fe			ld (debug_mark+2),a  
4bcb 18 03			jr .pastdmark  
4bcd ..			.dmark: db "APP"  
4bd0 f1			.pastdmark: pop af  
4bd1			endm  
# End of macro DMARK
4bd1						CALLMONITOR 
4bd1 cd 70 17			call break_point_state  
4bd4				endm  
# End of macro CALLMONITOR
4bd4					endif 
4bd4			 
4bd4					FORTH_DSP_VALUEHL 
4bd4 cd d5 1f			call macro_dsp_valuehl 
4bd7				endm 
# End of macro FORTH_DSP_VALUEHL
4bd7 e5					push hl 	; save file id 
4bd8			 
4bd8				if DEBUG_STORESE 
4bd8					DMARK "AP1" 
4bd8 f5				push af  
4bd9 3a ed 4b			ld a, (.dmark)  
4bdc 32 b4 fe			ld (debug_mark),a  
4bdf 3a ee 4b			ld a, (.dmark+1)  
4be2 32 b5 fe			ld (debug_mark+1),a  
4be5 3a ef 4b			ld a, (.dmark+2)  
4be8 32 b6 fe			ld (debug_mark+2),a  
4beb 18 03			jr .pastdmark  
4bed ..			.dmark: db "AP1"  
4bf0 f1			.pastdmark: pop af  
4bf1			endm  
# End of macro DMARK
4bf1					CALLMONITOR 
4bf1 cd 70 17			call break_point_state  
4bf4				endm  
# End of macro CALLMONITOR
4bf4				endif 
4bf4					FORTH_DSP_POP 
4bf4 cd 8d 20			call macro_forth_dsp_pop 
4bf7				endm 
# End of macro FORTH_DSP_POP
4bf7			 
4bf7					FORTH_DSP_VALUEHL 
4bf7 cd d5 1f			call macro_dsp_valuehl 
4bfa				endm 
# End of macro FORTH_DSP_VALUEHL
4bfa					;v5 FORTH_DSP_VALUE 
4bfa e5					push hl 	; save ptr to string to save 
4bfb			 
4bfb				if DEBUG_STORESE 
4bfb					DMARK "AP1" 
4bfb f5				push af  
4bfc 3a 10 4c			ld a, (.dmark)  
4bff 32 b4 fe			ld (debug_mark),a  
4c02 3a 11 4c			ld a, (.dmark+1)  
4c05 32 b5 fe			ld (debug_mark+1),a  
4c08 3a 12 4c			ld a, (.dmark+2)  
4c0b 32 b6 fe			ld (debug_mark+2),a  
4c0e 18 03			jr .pastdmark  
4c10 ..			.dmark: db "AP1"  
4c13 f1			.pastdmark: pop af  
4c14			endm  
# End of macro DMARK
4c14					CALLMONITOR 
4c14 cd 70 17			call break_point_state  
4c17				endm  
# End of macro CALLMONITOR
4c17				endif 
4c17					FORTH_DSP_POP 
4c17 cd 8d 20			call macro_forth_dsp_pop 
4c1a				endm 
# End of macro FORTH_DSP_POP
4c1a			 
4c1a d1					pop de 
4c1b e1					pop hl 
4c1c				if DEBUG_STORESE 
4c1c					DMARK "AP2" 
4c1c f5				push af  
4c1d 3a 31 4c			ld a, (.dmark)  
4c20 32 b4 fe			ld (debug_mark),a  
4c23 3a 32 4c			ld a, (.dmark+1)  
4c26 32 b5 fe			ld (debug_mark+1),a  
4c29 3a 33 4c			ld a, (.dmark+2)  
4c2c 32 b6 fe			ld (debug_mark+2),a  
4c2f 18 03			jr .pastdmark  
4c31 ..			.dmark: db "AP2"  
4c34 f1			.pastdmark: pop af  
4c35			endm  
# End of macro DMARK
4c35					CALLMONITOR 
4c35 cd 70 17			call break_point_state  
4c38				endm  
# End of macro CALLMONITOR
4c38				endif 
4c38					;inc de ; skip var type indicator 
4c38			 
4c38					; TODO how to append numerics???? 
4c38			 
4c38 cd b3 09				call storage_append		 
4c3b			 
4c3b				       NEXTW 
4c3b c3 47 21			jp macro_next 
4c3e				endm 
# End of macro NEXTW
4c3e			.SDEL: 
4c3e				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4c3e 6a				db WORD_SYS_CORE+86             
4c3f 8a 4c			dw .OPEN            
4c41 05				db 4 + 1 
4c42 .. 00			db "ERA",0              
4c46				endm 
# End of macro CWHEAD
4c46			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4c46					FORTH_DSP_VALUEHL 
4c46 cd d5 1f			call macro_dsp_valuehl 
4c49				endm 
# End of macro FORTH_DSP_VALUEHL
4c49			;		push hl 	; save file id 
4c49			 
4c49					if DEBUG_FORTH_WORDS_KEY 
4c49						DMARK "ERA" 
4c49 f5				push af  
4c4a 3a 5e 4c			ld a, (.dmark)  
4c4d 32 b4 fe			ld (debug_mark),a  
4c50 3a 5f 4c			ld a, (.dmark+1)  
4c53 32 b5 fe			ld (debug_mark+1),a  
4c56 3a 60 4c			ld a, (.dmark+2)  
4c59 32 b6 fe			ld (debug_mark+2),a  
4c5c 18 03			jr .pastdmark  
4c5e ..			.dmark: db "ERA"  
4c61 f1			.pastdmark: pop af  
4c62			endm  
# End of macro DMARK
4c62						CALLMONITOR 
4c62 cd 70 17			call break_point_state  
4c65				endm  
# End of macro CALLMONITOR
4c65					endif 
4c65				if DEBUG_STORESE 
4c65					DMARK "ER1" 
4c65 f5				push af  
4c66 3a 7a 4c			ld a, (.dmark)  
4c69 32 b4 fe			ld (debug_mark),a  
4c6c 3a 7b 4c			ld a, (.dmark+1)  
4c6f 32 b5 fe			ld (debug_mark+1),a  
4c72 3a 7c 4c			ld a, (.dmark+2)  
4c75 32 b6 fe			ld (debug_mark+2),a  
4c78 18 03			jr .pastdmark  
4c7a ..			.dmark: db "ER1"  
4c7d f1			.pastdmark: pop af  
4c7e			endm  
# End of macro DMARK
4c7e					CALLMONITOR 
4c7e cd 70 17			call break_point_state  
4c81				endm  
# End of macro CALLMONITOR
4c81				endif 
4c81					FORTH_DSP_POP 
4c81 cd 8d 20			call macro_forth_dsp_pop 
4c84				endm 
# End of macro FORTH_DSP_POP
4c84			 
4c84			;		pop hl 
4c84			 
4c84 cd 13 06				call storage_erase 
4c87				       NEXTW 
4c87 c3 47 21			jp macro_next 
4c8a				endm 
# End of macro NEXTW
4c8a			 
4c8a			.OPEN: 
4c8a				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4c8a 6b				db WORD_SYS_CORE+87             
4c8b 1a 4d			dw .READ            
4c8d 05				db 4 + 1 
4c8e .. 00			db "OPEN",0              
4c93				endm 
# End of macro CWHEAD
4c93			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4c93			; | | e.g. 
4c93			; | | $01 OPEN $01 DO $01 READ . LOOP 
4c93			; | | 
4c93			; | | Will return with 255 blocks if the file does not exist 
4c93			 
4c93					if DEBUG_FORTH_WORDS_KEY 
4c93						DMARK "OPN" 
4c93 f5				push af  
4c94 3a a8 4c			ld a, (.dmark)  
4c97 32 b4 fe			ld (debug_mark),a  
4c9a 3a a9 4c			ld a, (.dmark+1)  
4c9d 32 b5 fe			ld (debug_mark+1),a  
4ca0 3a aa 4c			ld a, (.dmark+2)  
4ca3 32 b6 fe			ld (debug_mark+2),a  
4ca6 18 03			jr .pastdmark  
4ca8 ..			.dmark: db "OPN"  
4cab f1			.pastdmark: pop af  
4cac			endm  
# End of macro DMARK
4cac						CALLMONITOR 
4cac cd 70 17			call break_point_state  
4caf				endm  
# End of macro CALLMONITOR
4caf					endif 
4caf					; TODO handle multiple file opens 
4caf			 
4caf 3e 01			       	ld a, 1 
4cb1 32 d6 fc				ld (store_openext), a 
4cb4			 
4cb4					; get max extents for this file 
4cb4				 
4cb4								 
4cb4					FORTH_DSP_VALUEHL 
4cb4 cd d5 1f			call macro_dsp_valuehl 
4cb7				endm 
# End of macro FORTH_DSP_VALUEHL
4cb7			 
4cb7 65					ld h, l 
4cb8 2e 00				ld l, 0 
4cba			 
4cba				if DEBUG_STORESE 
4cba					DMARK "OPN" 
4cba f5				push af  
4cbb 3a cf 4c			ld a, (.dmark)  
4cbe 32 b4 fe			ld (debug_mark),a  
4cc1 3a d0 4c			ld a, (.dmark+1)  
4cc4 32 b5 fe			ld (debug_mark+1),a  
4cc7 3a d1 4c			ld a, (.dmark+2)  
4cca 32 b6 fe			ld (debug_mark+2),a  
4ccd 18 03			jr .pastdmark  
4ccf ..			.dmark: db "OPN"  
4cd2 f1			.pastdmark: pop af  
4cd3			endm  
# End of macro DMARK
4cd3					CALLMONITOR 
4cd3 cd 70 17			call break_point_state  
4cd6				endm  
# End of macro CALLMONITOR
4cd6				endif 
4cd6			;		push hl 
4cd6					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4cd6 cd 8d 20			call macro_forth_dsp_pop 
4cd9				endm 
# End of macro FORTH_DSP_POP
4cd9			;		pop hl 
4cd9						 
4cd9 11 df fc				ld de, store_page      ; get block zero of file 
4cdc cd 2a 09				call storage_read 
4cdf cd 1c 0e			call ishlzero 
4ce2 20 04			jr nz, .opfound 
4ce4			 
4ce4				; file does not exist so indicate with 255 extents in use 
4ce4			 
4ce4 3e ff			ld a, 255 
4ce6 18 29			jr .skipopeneof 
4ce8			 
4ce8			 
4ce8			.opfound: 
4ce8			 
4ce8			 
4ce8 3a e1 fc				ld a, (store_page+2)    ; max extents for this file 
4ceb 32 d5 fc				ld  (store_openmaxext), a   ; get our limit and push 
4cee					 
4cee				if DEBUG_STORESE 
4cee					DMARK "OPx" 
4cee f5				push af  
4cef 3a 03 4d			ld a, (.dmark)  
4cf2 32 b4 fe			ld (debug_mark),a  
4cf5 3a 04 4d			ld a, (.dmark+1)  
4cf8 32 b5 fe			ld (debug_mark+1),a  
4cfb 3a 05 4d			ld a, (.dmark+2)  
4cfe 32 b6 fe			ld (debug_mark+2),a  
4d01 18 03			jr .pastdmark  
4d03 ..			.dmark: db "OPx"  
4d06 f1			.pastdmark: pop af  
4d07			endm  
# End of macro DMARK
4d07					CALLMONITOR 
4d07 cd 70 17			call break_point_state  
4d0a				endm  
# End of macro CALLMONITOR
4d0a				endif 
4d0a fe 00				cp 0 
4d0c 20 03				jr nz, .skipopeneof 
4d0e					; have opened an empty file 
4d0e					 
4d0e 32 d6 fc				ld (store_openext), a 
4d11			 
4d11			.skipopeneof: 
4d11			 
4d11 6f					ld l, a 
4d12 26 00				ld h, 0 
4d14 cd de 1d				call forth_push_numhl 
4d17			 
4d17			 
4d17				       NEXTW 
4d17 c3 47 21			jp macro_next 
4d1a				endm 
# End of macro NEXTW
4d1a			.READ: 
4d1a				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4d1a 6c				db WORD_SYS_CORE+88             
4d1b 61 4e			dw .EOF            
4d1d 05				db 4 + 1 
4d1e .. 00			db "READ",0              
4d23				endm 
# End of macro CWHEAD
4d23			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4d23			; | | e.g. 
4d23			; | | $01 OPEN $01 DO $01 READ . LOOP 
4d23			 
4d23					if DEBUG_FORTH_WORDS_KEY 
4d23						DMARK "REA" 
4d23 f5				push af  
4d24 3a 38 4d			ld a, (.dmark)  
4d27 32 b4 fe			ld (debug_mark),a  
4d2a 3a 39 4d			ld a, (.dmark+1)  
4d2d 32 b5 fe			ld (debug_mark+1),a  
4d30 3a 3a 4d			ld a, (.dmark+2)  
4d33 32 b6 fe			ld (debug_mark+2),a  
4d36 18 03			jr .pastdmark  
4d38 ..			.dmark: db "REA"  
4d3b f1			.pastdmark: pop af  
4d3c			endm  
# End of macro DMARK
4d3c						CALLMONITOR 
4d3c cd 70 17			call break_point_state  
4d3f				endm  
# End of macro CALLMONITOR
4d3f					endif 
4d3f					; store_openext use it. If zero it is EOF 
4d3f			 
4d3f					; read block from current stream id 
4d3f					; if the block does not contain zero term keep reading blocks until zero found 
4d3f					; push the block to stack 
4d3f					; save the block id to stream 
4d3f			 
4d3f			 
4d3f					FORTH_DSP_VALUEHL 
4d3f cd d5 1f			call macro_dsp_valuehl 
4d42				endm 
# End of macro FORTH_DSP_VALUEHL
4d42			 
4d42			;		push hl 
4d42			 
4d42				if DEBUG_STORESE 
4d42					DMARK "REA" 
4d42 f5				push af  
4d43 3a 57 4d			ld a, (.dmark)  
4d46 32 b4 fe			ld (debug_mark),a  
4d49 3a 58 4d			ld a, (.dmark+1)  
4d4c 32 b5 fe			ld (debug_mark+1),a  
4d4f 3a 59 4d			ld a, (.dmark+2)  
4d52 32 b6 fe			ld (debug_mark+2),a  
4d55 18 03			jr .pastdmark  
4d57 ..			.dmark: db "REA"  
4d5a f1			.pastdmark: pop af  
4d5b			endm  
# End of macro DMARK
4d5b					CALLMONITOR 
4d5b cd 70 17			call break_point_state  
4d5e				endm  
# End of macro CALLMONITOR
4d5e				endif 
4d5e					FORTH_DSP_POP 
4d5e cd 8d 20			call macro_forth_dsp_pop 
4d61				endm 
# End of macro FORTH_DSP_POP
4d61			 
4d61			;		pop hl 
4d61				 
4d61 65					ld h,l 
4d62			 
4d62 3a d6 fc				ld a, (store_openext) 
4d65 6f					ld l, a 
4d66					 
4d66 fe 00				cp 0 
4d68 ca 33 4e				jp z, .ateof     ; dont read past eof 
4d6b			 
4d6b			 
4d6b 11 df fc				ld de, store_page 
4d6e				if DEBUG_STORESE 
4d6e					DMARK "RE1" 
4d6e f5				push af  
4d6f 3a 83 4d			ld a, (.dmark)  
4d72 32 b4 fe			ld (debug_mark),a  
4d75 3a 84 4d			ld a, (.dmark+1)  
4d78 32 b5 fe			ld (debug_mark+1),a  
4d7b 3a 85 4d			ld a, (.dmark+2)  
4d7e 32 b6 fe			ld (debug_mark+2),a  
4d81 18 03			jr .pastdmark  
4d83 ..			.dmark: db "RE1"  
4d86 f1			.pastdmark: pop af  
4d87			endm  
# End of macro DMARK
4d87					CALLMONITOR 
4d87 cd 70 17			call break_point_state  
4d8a				endm  
# End of macro CALLMONITOR
4d8a				endif 
4d8a cd 2a 09				call storage_read 
4d8d			 
4d8d				if DEBUG_STORESE 
4d8d					DMARK "RE2" 
4d8d f5				push af  
4d8e 3a a2 4d			ld a, (.dmark)  
4d91 32 b4 fe			ld (debug_mark),a  
4d94 3a a3 4d			ld a, (.dmark+1)  
4d97 32 b5 fe			ld (debug_mark+1),a  
4d9a 3a a4 4d			ld a, (.dmark+2)  
4d9d 32 b6 fe			ld (debug_mark+2),a  
4da0 18 03			jr .pastdmark  
4da2 ..			.dmark: db "RE2"  
4da5 f1			.pastdmark: pop af  
4da6			endm  
# End of macro DMARK
4da6					CALLMONITOR 
4da6 cd 70 17			call break_point_state  
4da9				endm  
# End of macro CALLMONITOR
4da9				endif 
4da9 cd 1c 0e			call ishlzero 
4dac			;	ld a, l 
4dac			;	add h 
4dac			;	cp 0 
4dac ca 39 4e			jp z, .readeof 
4daf			 
4daf				; not eof so hl should point to data to push to stack 
4daf			 
4daf				if DEBUG_STORESE 
4daf					DMARK "RE3" 
4daf f5				push af  
4db0 3a c4 4d			ld a, (.dmark)  
4db3 32 b4 fe			ld (debug_mark),a  
4db6 3a c5 4d			ld a, (.dmark+1)  
4db9 32 b5 fe			ld (debug_mark+1),a  
4dbc 3a c6 4d			ld a, (.dmark+2)  
4dbf 32 b6 fe			ld (debug_mark+2),a  
4dc2 18 03			jr .pastdmark  
4dc4 ..			.dmark: db "RE3"  
4dc7 f1			.pastdmark: pop af  
4dc8			endm  
# End of macro DMARK
4dc8					CALLMONITOR 
4dc8 cd 70 17			call break_point_state  
4dcb				endm  
# End of macro CALLMONITOR
4dcb				endif 
4dcb cd 4c 1e			call forth_push_str 
4dce			 
4dce				if DEBUG_STORESE 
4dce					DMARK "RE4" 
4dce f5				push af  
4dcf 3a e3 4d			ld a, (.dmark)  
4dd2 32 b4 fe			ld (debug_mark),a  
4dd5 3a e4 4d			ld a, (.dmark+1)  
4dd8 32 b5 fe			ld (debug_mark+1),a  
4ddb 3a e5 4d			ld a, (.dmark+2)  
4dde 32 b6 fe			ld (debug_mark+2),a  
4de1 18 03			jr .pastdmark  
4de3 ..			.dmark: db "RE4"  
4de6 f1			.pastdmark: pop af  
4de7			endm  
# End of macro DMARK
4de7					CALLMONITOR 
4de7 cd 70 17			call break_point_state  
4dea				endm  
# End of macro CALLMONITOR
4dea				endif 
4dea				; get next block  or mark as eof 
4dea			 
4dea 3a d5 fc			ld a, (store_openmaxext)   ; get our limit 
4ded 4f				ld c, a	 
4dee 3a d6 fc			ld a, (store_openext) 
4df1			 
4df1				if DEBUG_STORESE 
4df1					DMARK "RE5" 
4df1 f5				push af  
4df2 3a 06 4e			ld a, (.dmark)  
4df5 32 b4 fe			ld (debug_mark),a  
4df8 3a 07 4e			ld a, (.dmark+1)  
4dfb 32 b5 fe			ld (debug_mark+1),a  
4dfe 3a 08 4e			ld a, (.dmark+2)  
4e01 32 b6 fe			ld (debug_mark+2),a  
4e04 18 03			jr .pastdmark  
4e06 ..			.dmark: db "RE5"  
4e09 f1			.pastdmark: pop af  
4e0a			endm  
# End of macro DMARK
4e0a					CALLMONITOR 
4e0a cd 70 17			call break_point_state  
4e0d				endm  
# End of macro CALLMONITOR
4e0d				endif 
4e0d b9				cp c 
4e0e 28 29			jr z, .readeof     ; at last extent 
4e10			 
4e10 3c					inc a 
4e11 32 d6 fc				ld (store_openext), a 
4e14			 
4e14				if DEBUG_STORESE 
4e14					DMARK "RE6" 
4e14 f5				push af  
4e15 3a 29 4e			ld a, (.dmark)  
4e18 32 b4 fe			ld (debug_mark),a  
4e1b 3a 2a 4e			ld a, (.dmark+1)  
4e1e 32 b5 fe			ld (debug_mark+1),a  
4e21 3a 2b 4e			ld a, (.dmark+2)  
4e24 32 b6 fe			ld (debug_mark+2),a  
4e27 18 03			jr .pastdmark  
4e29 ..			.dmark: db "RE6"  
4e2c f1			.pastdmark: pop af  
4e2d			endm  
# End of macro DMARK
4e2d					CALLMONITOR 
4e2d cd 70 17			call break_point_state  
4e30				endm  
# End of macro CALLMONITOR
4e30				endif 
4e30			 
4e30			 
4e30				       NEXTW 
4e30 c3 47 21			jp macro_next 
4e33				endm 
# End of macro NEXTW
4e33			.ateof: 
4e33 21 5d 4e				ld hl, .showeof 
4e36 cd 4c 1e				call forth_push_str 
4e39 3e 00		.readeof:	ld a, 0 
4e3b 32 d6 fc				ld (store_openext), a 
4e3e			 
4e3e					 
4e3e				if DEBUG_STORESE 
4e3e					DMARK "REF" 
4e3e f5				push af  
4e3f 3a 53 4e			ld a, (.dmark)  
4e42 32 b4 fe			ld (debug_mark),a  
4e45 3a 54 4e			ld a, (.dmark+1)  
4e48 32 b5 fe			ld (debug_mark+1),a  
4e4b 3a 55 4e			ld a, (.dmark+2)  
4e4e 32 b6 fe			ld (debug_mark+2),a  
4e51 18 03			jr .pastdmark  
4e53 ..			.dmark: db "REF"  
4e56 f1			.pastdmark: pop af  
4e57			endm  
# End of macro DMARK
4e57					CALLMONITOR 
4e57 cd 70 17			call break_point_state  
4e5a				endm  
# End of macro CALLMONITOR
4e5a				endif 
4e5a				       NEXTW 
4e5a c3 47 21			jp macro_next 
4e5d				endm 
# End of macro NEXTW
4e5d			 
4e5d .. 00		.showeof:   db "eof", 0 
4e61			 
4e61			 
4e61			.EOF: 
4e61				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4e61 6d				db WORD_SYS_CORE+89             
4e62 a2 4e			dw .FORMAT            
4e64 04				db 3 + 1 
4e65 .. 00			db "EOF",0              
4e69				endm 
# End of macro CWHEAD
4e69			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4e69			; | | e.g. 
4e69			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4e69					; TODO if current block id for stream is zero then push true else false 
4e69			 
4e69					if DEBUG_FORTH_WORDS_KEY 
4e69						DMARK "EOF" 
4e69 f5				push af  
4e6a 3a 7e 4e			ld a, (.dmark)  
4e6d 32 b4 fe			ld (debug_mark),a  
4e70 3a 7f 4e			ld a, (.dmark+1)  
4e73 32 b5 fe			ld (debug_mark+1),a  
4e76 3a 80 4e			ld a, (.dmark+2)  
4e79 32 b6 fe			ld (debug_mark+2),a  
4e7c 18 03			jr .pastdmark  
4e7e ..			.dmark: db "EOF"  
4e81 f1			.pastdmark: pop af  
4e82			endm  
# End of macro DMARK
4e82						CALLMONITOR 
4e82 cd 70 17			call break_point_state  
4e85				endm  
# End of macro CALLMONITOR
4e85					endif 
4e85			 
4e85					; TODO handlue multiple file streams 
4e85			 
4e85					FORTH_DSP_POP     ; for now just get rid of stream id 
4e85 cd 8d 20			call macro_forth_dsp_pop 
4e88				endm 
# End of macro FORTH_DSP_POP
4e88			 
4e88 2e 01				ld l, 1 
4e8a 3a d5 fc				ld a, (store_openmaxext) 
4e8d fe 00				cp 0 
4e8f 28 09				jr  z, .eofdone   ; empty file 
4e91 3a d6 fc				ld a, (store_openext) 
4e94 fe 00				cp 0 
4e96 28 02				jr  z, .eofdone 
4e98 2e 00				ld l, 0 
4e9a 26 00		.eofdone:	ld h, 0 
4e9c cd de 1d				call forth_push_numhl 
4e9f			 
4e9f			 
4e9f				       NEXTW 
4e9f c3 47 21			jp macro_next 
4ea2				endm 
# End of macro NEXTW
4ea2			 
4ea2			.FORMAT: 
4ea2				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4ea2 6d				db WORD_SYS_CORE+89             
4ea3 f3 4e			dw .LABEL            
4ea5 07				db 6 + 1 
4ea6 .. 00			db "FORMAT",0              
4ead				endm 
# End of macro CWHEAD
4ead			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4ead					; TODO if current block id for stream is zero then push true else false 
4ead				 
4ead				if DEBUG_STORESE 
4ead					DMARK "FOR" 
4ead f5				push af  
4eae 3a c2 4e			ld a, (.dmark)  
4eb1 32 b4 fe			ld (debug_mark),a  
4eb4 3a c3 4e			ld a, (.dmark+1)  
4eb7 32 b5 fe			ld (debug_mark+1),a  
4eba 3a c4 4e			ld a, (.dmark+2)  
4ebd 32 b6 fe			ld (debug_mark+2),a  
4ec0 18 03			jr .pastdmark  
4ec2 ..			.dmark: db "FOR"  
4ec5 f1			.pastdmark: pop af  
4ec6			endm  
# End of macro DMARK
4ec6					CALLMONITOR 
4ec6 cd 70 17			call break_point_state  
4ec9				endm  
# End of macro CALLMONITOR
4ec9				endif 
4ec9					; Wipes the bank check flags to cause a reformat on next block 0 read 
4ec9			 
4ec9 21 01 00				ld hl, 1 
4ecc 3e 00				ld a, 0 
4ece cd d6 01				call se_writebyte 
4ed1			 
4ed1				if DEBUG_STORESE 
4ed1					DMARK "FO0" 
4ed1 f5				push af  
4ed2 3a e6 4e			ld a, (.dmark)  
4ed5 32 b4 fe			ld (debug_mark),a  
4ed8 3a e7 4e			ld a, (.dmark+1)  
4edb 32 b5 fe			ld (debug_mark+1),a  
4ede 3a e8 4e			ld a, (.dmark+2)  
4ee1 32 b6 fe			ld (debug_mark+2),a  
4ee4 18 03			jr .pastdmark  
4ee6 ..			.dmark: db "FO0"  
4ee9 f1			.pastdmark: pop af  
4eea			endm  
# End of macro DMARK
4eea					CALLMONITOR 
4eea cd 70 17			call break_point_state  
4eed				endm  
# End of macro CALLMONITOR
4eed				endif 
4eed					; force bank init 
4eed			 
4eed cd 82 04				call storage_get_block_0 
4ef0					 
4ef0				       NEXTW 
4ef0 c3 47 21			jp macro_next 
4ef3				endm 
# End of macro NEXTW
4ef3			.LABEL: 
4ef3				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4ef3 6d				db WORD_SYS_CORE+89             
4ef4 41 4f			dw .STOREPAGE            
4ef6 06				db 5 + 1 
4ef7 .. 00			db "LABEL",0              
4efd				endm 
# End of macro CWHEAD
4efd			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4efd					; TODO test to see if bank is selected 
4efd				 
4efd					if DEBUG_FORTH_WORDS_KEY 
4efd						DMARK "LBL" 
4efd f5				push af  
4efe 3a 12 4f			ld a, (.dmark)  
4f01 32 b4 fe			ld (debug_mark),a  
4f04 3a 13 4f			ld a, (.dmark+1)  
4f07 32 b5 fe			ld (debug_mark+1),a  
4f0a 3a 14 4f			ld a, (.dmark+2)  
4f0d 32 b6 fe			ld (debug_mark+2),a  
4f10 18 03			jr .pastdmark  
4f12 ..			.dmark: db "LBL"  
4f15 f1			.pastdmark: pop af  
4f16			endm  
# End of macro DMARK
4f16						CALLMONITOR 
4f16 cd 70 17			call break_point_state  
4f19				endm  
# End of macro CALLMONITOR
4f19					endif 
4f19			;	if DEBUG_STORESE 
4f19			;		DMARK "LBL" 
4f19			;		CALLMONITOR 
4f19			;	endif 
4f19					FORTH_DSP_VALUEHL 
4f19 cd d5 1f			call macro_dsp_valuehl 
4f1c				endm 
# End of macro FORTH_DSP_VALUEHL
4f1c					;v5FORTH_DSP_VALUE 
4f1c					 
4f1c			;		push hl 
4f1c					FORTH_DSP_POP 
4f1c cd 8d 20			call macro_forth_dsp_pop 
4f1f				endm 
# End of macro FORTH_DSP_POP
4f1f			;		pop hl 
4f1f			 
4f1f			;v5		inc hl   ; move past the type marker 
4f1f			 
4f1f				if DEBUG_STORESE 
4f1f					DMARK "LBl" 
4f1f f5				push af  
4f20 3a 34 4f			ld a, (.dmark)  
4f23 32 b4 fe			ld (debug_mark),a  
4f26 3a 35 4f			ld a, (.dmark+1)  
4f29 32 b5 fe			ld (debug_mark+1),a  
4f2c 3a 36 4f			ld a, (.dmark+2)  
4f2f 32 b6 fe			ld (debug_mark+2),a  
4f32 18 03			jr .pastdmark  
4f34 ..			.dmark: db "LBl"  
4f37 f1			.pastdmark: pop af  
4f38			endm  
# End of macro DMARK
4f38					CALLMONITOR 
4f38 cd 70 17			call break_point_state  
4f3b				endm  
# End of macro CALLMONITOR
4f3b				endif 
4f3b cd a6 05				call storage_label 
4f3e			 
4f3e				       NEXTW 
4f3e c3 47 21			jp macro_next 
4f41				endm 
# End of macro NEXTW
4f41			.STOREPAGE: 
4f41				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4f41 6d				db WORD_SYS_CORE+89             
4f42 74 4f			dw .LABELS            
4f44 0a				db 9 + 1 
4f45 .. 00			db "STOREPAGE",0              
4f4f				endm 
# End of macro CWHEAD
4f4f			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4f4f					; TODO test to see if bank is selected 
4f4f				 
4f4f					if DEBUG_FORTH_WORDS_KEY 
4f4f						DMARK "STP" 
4f4f f5				push af  
4f50 3a 64 4f			ld a, (.dmark)  
4f53 32 b4 fe			ld (debug_mark),a  
4f56 3a 65 4f			ld a, (.dmark+1)  
4f59 32 b5 fe			ld (debug_mark+1),a  
4f5c 3a 66 4f			ld a, (.dmark+2)  
4f5f 32 b6 fe			ld (debug_mark+2),a  
4f62 18 03			jr .pastdmark  
4f64 ..			.dmark: db "STP"  
4f67 f1			.pastdmark: pop af  
4f68			endm  
# End of macro DMARK
4f68						CALLMONITOR 
4f68 cd 70 17			call break_point_state  
4f6b				endm  
# End of macro CALLMONITOR
4f6b					endif 
4f6b			;	if DEBUG_STORESE 
4f6b			;		DMARK "STP" 
4f6b			;		CALLMONITOR 
4f6b			;	endif 
4f6b			 
4f6b 21 df fc			ld hl, store_page 
4f6e cd de 1d			call forth_push_numhl 
4f71			 
4f71			 
4f71				       NEXTW 
4f71 c3 47 21			jp macro_next 
4f74				endm 
# End of macro NEXTW
4f74			.LABELS: 
4f74				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4f74 6d				db WORD_SYS_CORE+89             
4f75 fe 4f			dw .ENDSTORAGE            
4f77 07				db 6 + 1 
4f78 .. 00			db "LABELS",0              
4f7f				endm 
# End of macro CWHEAD
4f7f			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4f7f					;  
4f7f			 
4f7f					; save the current device selected to restore afterwards 
4f7f				 
4f7f 3a c5 fc				ld a, (spi_device) 
4f82 f5					push af 
4f83			 
4f83			 
4f83					; run through each of the banks 
4f83			 
4f83 21 01 00				ld hl, 1 
4f86 cd de 1d				call forth_push_numhl 
4f89 3e ff				ld a, SPI_CE_HIGH 
4f8b cb 87				res SPI_CE0, a 
4f8d 32 c5 fc				ld (spi_device), a 
4f90 cd 82 04				call storage_get_block_0 
4f93 21 e2 fc				ld hl, store_page+3 
4f96 cd 4c 1e				call forth_push_str 
4f99			 
4f99					 
4f99 21 02 00				ld hl, 2 
4f9c cd de 1d				call forth_push_numhl 
4f9f 3e ff				ld a, SPI_CE_HIGH 
4fa1 cb 8f				res SPI_CE1, a 
4fa3 32 c5 fc				ld (spi_device), a 
4fa6 cd 82 04				call storage_get_block_0 
4fa9 21 e2 fc				ld hl, store_page+3 
4fac cd 4c 1e				call forth_push_str 
4faf			 
4faf					 
4faf 21 03 00				ld hl, 3 
4fb2 cd de 1d				call forth_push_numhl 
4fb5 3e ff				ld a, SPI_CE_HIGH 
4fb7 cb 97				res SPI_CE2, a 
4fb9 32 c5 fc				ld (spi_device), a 
4fbc cd 82 04				call storage_get_block_0 
4fbf 21 e2 fc				ld hl, store_page+3 
4fc2 cd 4c 1e				call forth_push_str 
4fc5			 
4fc5			 
4fc5 21 04 00				ld hl, 4 
4fc8 cd de 1d				call forth_push_numhl 
4fcb 3e ff				ld a, SPI_CE_HIGH 
4fcd cb 9f				res SPI_CE3, a 
4fcf 32 c5 fc				ld (spi_device), a 
4fd2 cd 82 04				call storage_get_block_0 
4fd5 21 e2 fc				ld hl, store_page+3 
4fd8 cd 4c 1e				call forth_push_str 
4fdb			 
4fdb					 
4fdb			 
4fdb 21 05 00				ld hl, 5 
4fde cd de 1d				call forth_push_numhl 
4fe1 3e ff				ld a, SPI_CE_HIGH 
4fe3 cb a7				res SPI_CE4, a 
4fe5 32 c5 fc				ld (spi_device), a 
4fe8 cd 82 04				call storage_get_block_0 
4feb 21 e2 fc				ld hl, store_page+3 
4fee cd 4c 1e				call forth_push_str 
4ff1			 
4ff1					 
4ff1					; push fixed count of storage devices (on board) for now 
4ff1			 
4ff1 21 05 00				ld hl, 5 
4ff4 cd de 1d				call forth_push_numhl 
4ff7			 
4ff7					; restore selected device  
4ff7				 
4ff7 f1					pop af 
4ff8 32 c5 fc				ld (spi_device), a 
4ffb			 
4ffb				       NEXTW 
4ffb c3 47 21			jp macro_next 
4ffe				endm 
# End of macro NEXTW
4ffe			 
4ffe			.ENDSTORAGE: 
4ffe			; eof 
# End of file forth_words_storage.asm
4ffe			endif 
4ffe				include "forth_words_device.asm" 
4ffe			; Device related words 
4ffe			 
4ffe			; | ## Device Words 
4ffe			 
4ffe			if SOUND_ENABLE 
4ffe			.NOTE: 
4ffe				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4ffe			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4ffe					if DEBUG_FORTH_WORDS_KEY 
4ffe						DMARK "NTE" 
4ffe						CALLMONITOR 
4ffe					endif 
4ffe			 
4ffe				 
4ffe			 
4ffe					NEXTW 
4ffe			.AFTERSOUND: 
4ffe			endif 
4ffe			 
4ffe			 
4ffe			USE_GPIO: equ 0 
4ffe			 
4ffe			if USE_GPIO 
4ffe			.GP1: 
4ffe				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4ffe			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4ffe					NEXTW 
4ffe			.GP2: 
4ffe				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4ffe			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4ffe			 
4ffe					NEXTW 
4ffe			 
4ffe			.GP3: 
4ffe				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4ffe			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4ffe			 
4ffe					NEXTW 
4ffe			 
4ffe			.GP4: 
4ffe				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4ffe			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4ffe			 
4ffe					NEXTW 
4ffe			.SIN: 
4ffe			 
4ffe			 
4ffe			endif 
4ffe			 
4ffe			 
4ffe				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4ffe 33				db WORD_SYS_CORE+31             
4fff 33 50			dw .SOUT            
5001 03				db 2 + 1 
5002 .. 00			db "IN",0              
5005				endm 
# End of macro CWHEAD
5005			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5005					if DEBUG_FORTH_WORDS_KEY 
5005						DMARK "IN." 
5005 f5				push af  
5006 3a 1a 50			ld a, (.dmark)  
5009 32 b4 fe			ld (debug_mark),a  
500c 3a 1b 50			ld a, (.dmark+1)  
500f 32 b5 fe			ld (debug_mark+1),a  
5012 3a 1c 50			ld a, (.dmark+2)  
5015 32 b6 fe			ld (debug_mark+2),a  
5018 18 03			jr .pastdmark  
501a ..			.dmark: db "IN."  
501d f1			.pastdmark: pop af  
501e			endm  
# End of macro DMARK
501e						CALLMONITOR 
501e cd 70 17			call break_point_state  
5021				endm  
# End of macro CALLMONITOR
5021					endif 
5021					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5021 cd d5 1f			call macro_dsp_valuehl 
5024				endm 
# End of macro FORTH_DSP_VALUEHL
5024			 
5024 e5					push hl 
5025			 
5025					; destroy value TOS 
5025			 
5025					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5025 cd 8d 20			call macro_forth_dsp_pop 
5028				endm 
# End of macro FORTH_DSP_POP
5028			 
5028					; one value on hl get other one back 
5028			 
5028 c1					pop bc 
5029			 
5029					; do the sub 
5029			;		ex de, hl 
5029			 
5029 ed 68				in l,(c) 
502b			 
502b					; save it 
502b			 
502b 26 00				ld h,0 
502d			 
502d					; TODO push value back onto stack for another op etc 
502d			 
502d cd de 1d				call forth_push_numhl 
5030					NEXTW 
5030 c3 47 21			jp macro_next 
5033				endm 
# End of macro NEXTW
5033			.SOUT: 
5033				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5033 34				db WORD_SYS_CORE+32             
5034 86 50			dw .SPIO            
5036 04				db 3 + 1 
5037 .. 00			db "OUT",0              
503b				endm 
# End of macro CWHEAD
503b			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
503b					if DEBUG_FORTH_WORDS_KEY 
503b						DMARK "OUT" 
503b f5				push af  
503c 3a 50 50			ld a, (.dmark)  
503f 32 b4 fe			ld (debug_mark),a  
5042 3a 51 50			ld a, (.dmark+1)  
5045 32 b5 fe			ld (debug_mark+1),a  
5048 3a 52 50			ld a, (.dmark+2)  
504b 32 b6 fe			ld (debug_mark+2),a  
504e 18 03			jr .pastdmark  
5050 ..			.dmark: db "OUT"  
5053 f1			.pastdmark: pop af  
5054			endm  
# End of macro DMARK
5054						CALLMONITOR 
5054 cd 70 17			call break_point_state  
5057				endm  
# End of macro CALLMONITOR
5057					endif 
5057			 
5057					; get port 
5057			 
5057					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5057 cd d5 1f			call macro_dsp_valuehl 
505a				endm 
# End of macro FORTH_DSP_VALUEHL
505a			 
505a e5					push hl 
505b			 
505b					; destroy value TOS 
505b			 
505b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
505b cd 8d 20			call macro_forth_dsp_pop 
505e				endm 
# End of macro FORTH_DSP_POP
505e			 
505e					; get byte to send 
505e			 
505e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
505e cd d5 1f			call macro_dsp_valuehl 
5061				endm 
# End of macro FORTH_DSP_VALUEHL
5061			 
5061			;		push hl 
5061			 
5061					; destroy value TOS 
5061			 
5061					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5061 cd 8d 20			call macro_forth_dsp_pop 
5064				endm 
# End of macro FORTH_DSP_POP
5064			 
5064					; one value on hl get other one back 
5064			 
5064			;		pop hl 
5064			 
5064 c1					pop bc 
5065			 
5065					if DEBUG_FORTH_WORDS 
5065						DMARK "OUT" 
5065 f5				push af  
5066 3a 7a 50			ld a, (.dmark)  
5069 32 b4 fe			ld (debug_mark),a  
506c 3a 7b 50			ld a, (.dmark+1)  
506f 32 b5 fe			ld (debug_mark+1),a  
5072 3a 7c 50			ld a, (.dmark+2)  
5075 32 b6 fe			ld (debug_mark+2),a  
5078 18 03			jr .pastdmark  
507a ..			.dmark: db "OUT"  
507d f1			.pastdmark: pop af  
507e			endm  
# End of macro DMARK
507e						CALLMONITOR 
507e cd 70 17			call break_point_state  
5081				endm  
# End of macro CALLMONITOR
5081					endif 
5081			 
5081 ed 69				out (c), l 
5083			 
5083					NEXTW 
5083 c3 47 21			jp macro_next 
5086				endm 
# End of macro NEXTW
5086			 
5086			 
5086			.SPIO: 
5086			 
5086			if STORAGE_SE 
5086				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
5086 51				db WORD_SYS_CORE+61             
5087 97 50			dw .SPICEH            
5089 07				db 6 + 1 
508a .. 00			db "SPICEL",0              
5091				endm 
# End of macro CWHEAD
5091			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5091			 
5091 cd 84 01				call spi_ce_low 
5094			    NEXTW 
5094 c3 47 21			jp macro_next 
5097				endm 
# End of macro NEXTW
5097			 
5097			.SPICEH: 
5097				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5097 51				db WORD_SYS_CORE+61             
5098 a8 50			dw .SPIOb            
509a 07				db 6 + 1 
509b .. 00			db "SPICEH",0              
50a2				endm 
# End of macro CWHEAD
50a2			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
50a2			 
50a2 cd 73 01				call spi_ce_high 
50a5			    NEXTW 
50a5 c3 47 21			jp macro_next 
50a8				endm 
# End of macro NEXTW
50a8			 
50a8			 
50a8			.SPIOb: 
50a8			 
50a8				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
50a8 51				db WORD_SYS_CORE+61             
50a9 be 50			dw .SPII            
50ab 05				db 4 + 1 
50ac .. 00			db "SPIO",0              
50b1				endm 
# End of macro CWHEAD
50b1			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
50b1			 
50b1					; get port 
50b1			 
50b1			 
50b1					; get byte to send 
50b1			 
50b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50b1 cd d5 1f			call macro_dsp_valuehl 
50b4				endm 
# End of macro FORTH_DSP_VALUEHL
50b4			 
50b4			;		push hl    ; u1  
50b4			 
50b4					; destroy value TOS 
50b4			 
50b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50b4 cd 8d 20			call macro_forth_dsp_pop 
50b7				endm 
# End of macro FORTH_DSP_POP
50b7			 
50b7					; one value on hl get other one back 
50b7			 
50b7			;		pop hl   ; u2 - addr 
50b7			 
50b7					; TODO Send SPI byte 
50b7			 
50b7 7d					ld a, l 
50b8 cd a8 00				call spi_send_byte 
50bb			 
50bb					NEXTW 
50bb c3 47 21			jp macro_next 
50be				endm 
# End of macro NEXTW
50be			 
50be			.SPII: 
50be				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
50be 52				db WORD_SYS_CORE+62             
50bf d3 50			dw .SESEL            
50c1 06				db 5 + 1 
50c2 .. 00			db "SPII",0              
50c7				endm 
# End of macro CWHEAD
50c7			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
50c7			 
50c7					; TODO Get SPI byte 
50c7			 
50c7 cd c9 00				call spi_read_byte 
50ca			 
50ca 26 00				ld h, 0 
50cc 6f					ld l, a 
50cd cd de 1d				call forth_push_numhl 
50d0			 
50d0					NEXTW 
50d0 c3 47 21			jp macro_next 
50d3				endm 
# End of macro NEXTW
50d3			 
50d3			 
50d3			 
50d3			.SESEL: 
50d3				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
50d3 66				db WORD_SYS_CORE+82             
50d4 77 51			dw .CARTDEV            
50d6 05				db 4 + 1 
50d7 .. 00			db "BANK",0              
50dc				endm 
# End of macro CWHEAD
50dc			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
50dc					if DEBUG_FORTH_WORDS_KEY 
50dc						DMARK "BNK" 
50dc f5				push af  
50dd 3a f1 50			ld a, (.dmark)  
50e0 32 b4 fe			ld (debug_mark),a  
50e3 3a f2 50			ld a, (.dmark+1)  
50e6 32 b5 fe			ld (debug_mark+1),a  
50e9 3a f3 50			ld a, (.dmark+2)  
50ec 32 b6 fe			ld (debug_mark+2),a  
50ef 18 03			jr .pastdmark  
50f1 ..			.dmark: db "BNK"  
50f4 f1			.pastdmark: pop af  
50f5			endm  
# End of macro DMARK
50f5						CALLMONITOR 
50f5 cd 70 17			call break_point_state  
50f8				endm  
# End of macro CALLMONITOR
50f8					endif 
50f8			 
50f8 3e ff				ld a, 255 
50fa 32 c8 fc				ld (spi_cartdev), a 
50fd			 
50fd					; get bank 
50fd			 
50fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50fd cd d5 1f			call macro_dsp_valuehl 
5100				endm 
# End of macro FORTH_DSP_VALUEHL
5100			 
5100			;		push hl 
5100			 
5100					; destroy value TOS 
5100			 
5100					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5100 cd 8d 20			call macro_forth_dsp_pop 
5103				endm 
# End of macro FORTH_DSP_POP
5103			 
5103					; one value on hl get other one back 
5103			 
5103			;		pop hl 
5103			 
5103			 
5103 0e ff				ld c, SPI_CE_HIGH 
5105 06 30				ld b, '0'    ; human readable bank number 
5107			 
5107 7d					ld a, l 
5108			 
5108					if DEBUG_FORTH_WORDS 
5108						DMARK "BNK" 
5108 f5				push af  
5109 3a 1d 51			ld a, (.dmark)  
510c 32 b4 fe			ld (debug_mark),a  
510f 3a 1e 51			ld a, (.dmark+1)  
5112 32 b5 fe			ld (debug_mark+1),a  
5115 3a 1f 51			ld a, (.dmark+2)  
5118 32 b6 fe			ld (debug_mark+2),a  
511b 18 03			jr .pastdmark  
511d ..			.dmark: db "BNK"  
5120 f1			.pastdmark: pop af  
5121			endm  
# End of macro DMARK
5121						CALLMONITOR 
5121 cd 70 17			call break_point_state  
5124				endm  
# End of macro CALLMONITOR
5124					endif 
5124			 
5124					; active low 
5124			 
5124 fe 00				cp 0 
5126 28 28				jr z, .bset 
5128 fe 01				cp 1 
512a 20 04				jr nz, .b2 
512c cb 81				res 0, c 
512e 06 31				ld b, '1'    ; human readable bank number 
5130 fe 02		.b2:		cp 2 
5132 20 04				jr nz, .b3 
5134 cb 89				res 1, c 
5136 06 32				ld b, '2'    ; human readable bank number 
5138 fe 03		.b3:		cp 3 
513a 20 04				jr nz, .b4 
513c cb 91				res 2, c 
513e 06 33				ld b, '3'    ; human readable bank number 
5140 fe 04		.b4:		cp 4 
5142 20 04				jr nz, .b5 
5144 cb 99				res 3, c 
5146 06 34				ld b, '4'    ; human readable bank number 
5148 fe 05		.b5:		cp 5 
514a 20 04				jr nz, .bset 
514c cb a1				res 4, c 
514e 06 35				ld b, '5'    ; human readable bank number 
5150			 
5150			.bset: 
5150 79					ld a, c 
5151 32 c5 fc				ld (spi_device),a 
5154 78					ld a, b 
5155 32 c4 fc				ld (spi_device_id),a 
5158					if DEBUG_FORTH_WORDS 
5158						DMARK "BN2" 
5158 f5				push af  
5159 3a 6d 51			ld a, (.dmark)  
515c 32 b4 fe			ld (debug_mark),a  
515f 3a 6e 51			ld a, (.dmark+1)  
5162 32 b5 fe			ld (debug_mark+1),a  
5165 3a 6f 51			ld a, (.dmark+2)  
5168 32 b6 fe			ld (debug_mark+2),a  
516b 18 03			jr .pastdmark  
516d ..			.dmark: db "BN2"  
5170 f1			.pastdmark: pop af  
5171			endm  
# End of macro DMARK
5171						CALLMONITOR 
5171 cd 70 17			call break_point_state  
5174				endm  
# End of macro CALLMONITOR
5174					endif 
5174			 
5174					NEXTW 
5174 c3 47 21			jp macro_next 
5177				endm 
# End of macro NEXTW
5177			 
5177			.CARTDEV: 
5177				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5177 66				db WORD_SYS_CORE+82             
5178 20 52			dw .ENDDEVICE            
517a 08				db 7 + 1 
517b .. 00			db "CARTDEV",0              
5183				endm 
# End of macro CWHEAD
5183			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5183					if DEBUG_FORTH_WORDS_KEY 
5183						DMARK "CDV" 
5183 f5				push af  
5184 3a 98 51			ld a, (.dmark)  
5187 32 b4 fe			ld (debug_mark),a  
518a 3a 99 51			ld a, (.dmark+1)  
518d 32 b5 fe			ld (debug_mark+1),a  
5190 3a 9a 51			ld a, (.dmark+2)  
5193 32 b6 fe			ld (debug_mark+2),a  
5196 18 03			jr .pastdmark  
5198 ..			.dmark: db "CDV"  
519b f1			.pastdmark: pop af  
519c			endm  
# End of macro DMARK
519c						CALLMONITOR 
519c cd 70 17			call break_point_state  
519f				endm  
# End of macro CALLMONITOR
519f					endif 
519f			 
519f					; disable se storage bank selection 
519f			 
519f 3e ff				ld a, SPI_CE_HIGH		; ce high 
51a1 32 c5 fc				ld (spi_device), a 
51a4			 
51a4					; get bank 
51a4			 
51a4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51a4 cd d5 1f			call macro_dsp_valuehl 
51a7				endm 
# End of macro FORTH_DSP_VALUEHL
51a7			 
51a7			;		push hl 
51a7			 
51a7					; destroy value TOS 
51a7			 
51a7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51a7 cd 8d 20			call macro_forth_dsp_pop 
51aa				endm 
# End of macro FORTH_DSP_POP
51aa			 
51aa					; one value on hl get other one back 
51aa			 
51aa			;		pop hl 
51aa			 
51aa					; active low 
51aa			 
51aa 0e ff				ld c, 255 
51ac			 
51ac 7d					ld a, l 
51ad					if DEBUG_FORTH_WORDS 
51ad						DMARK "CDV" 
51ad f5				push af  
51ae 3a c2 51			ld a, (.dmark)  
51b1 32 b4 fe			ld (debug_mark),a  
51b4 3a c3 51			ld a, (.dmark+1)  
51b7 32 b5 fe			ld (debug_mark+1),a  
51ba 3a c4 51			ld a, (.dmark+2)  
51bd 32 b6 fe			ld (debug_mark+2),a  
51c0 18 03			jr .pastdmark  
51c2 ..			.dmark: db "CDV"  
51c5 f1			.pastdmark: pop af  
51c6			endm  
# End of macro DMARK
51c6						CALLMONITOR 
51c6 cd 70 17			call break_point_state  
51c9				endm  
# End of macro CALLMONITOR
51c9					endif 
51c9 fe 00				cp 0 
51cb 28 30				jr z, .cset 
51cd fe 01				cp 1 
51cf 20 02				jr nz, .c2 
51d1 cb 81				res 0, c 
51d3 fe 02		.c2:		cp 2 
51d5 20 02				jr nz, .c3 
51d7 cb 89				res 1, c 
51d9 fe 03		.c3:		cp 3 
51db 20 02				jr nz, .c4 
51dd cb 91				res 2, c 
51df fe 04		.c4:		cp 4 
51e1 20 02				jr nz, .c5 
51e3 cb 99				res 3, c 
51e5 fe 05		.c5:		cp 5 
51e7 20 02				jr nz, .c6 
51e9 cb a1				res 4, c 
51eb fe 06		.c6:		cp 6 
51ed 20 02				jr nz, .c7 
51ef cb a9				res 5, c 
51f1 fe 07		.c7:		cp 7 
51f3 20 02				jr nz, .c8 
51f5 cb b1				res 6, c 
51f7 fe 08		.c8:		cp 8 
51f9 20 02				jr nz, .cset 
51fb cb b9				res 7, c 
51fd 79			.cset:		ld a, c 
51fe 32 c8 fc				ld (spi_cartdev),a 
5201			 
5201					if DEBUG_FORTH_WORDS 
5201						DMARK "CD2" 
5201 f5				push af  
5202 3a 16 52			ld a, (.dmark)  
5205 32 b4 fe			ld (debug_mark),a  
5208 3a 17 52			ld a, (.dmark+1)  
520b 32 b5 fe			ld (debug_mark+1),a  
520e 3a 18 52			ld a, (.dmark+2)  
5211 32 b6 fe			ld (debug_mark+2),a  
5214 18 03			jr .pastdmark  
5216 ..			.dmark: db "CD2"  
5219 f1			.pastdmark: pop af  
521a			endm  
# End of macro DMARK
521a						CALLMONITOR 
521a cd 70 17			call break_point_state  
521d				endm  
# End of macro CALLMONITOR
521d					endif 
521d					NEXTW 
521d c3 47 21			jp macro_next 
5220				endm 
# End of macro NEXTW
5220			endif 
5220			 
5220			.ENDDEVICE: 
5220			; eof 
5220			 
# End of file forth_words_device.asm
5220			 
5220			; var handler 
5220			 
5220			 
5220			.VARS: 
5220				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5220 78				db WORD_SYS_CORE+100             
5221 38 52			dw .V0Q            
5223 04				db 3 + 1 
5224 .. 00			db "V0!",0              
5228				endm 
# End of macro CWHEAD
5228			;| V0! ( u1 -- )  Store value to v0  | DONE 
5228			 
5228					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5228 cd d5 1f			call macro_dsp_valuehl 
522b				endm 
# End of macro FORTH_DSP_VALUEHL
522b			 
522b 11 8d fc				ld de, cli_var_array 
522e			 
522e eb					ex de, hl 
522f 73					ld (hl), e 
5230 23					inc hl 
5231 72					ld (hl), d 
5232			 
5232					; destroy value TOS 
5232			 
5232					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5232 cd 8d 20			call macro_forth_dsp_pop 
5235				endm 
# End of macro FORTH_DSP_POP
5235			 
5235				       NEXTW 
5235 c3 47 21			jp macro_next 
5238				endm 
# End of macro NEXTW
5238			.V0Q: 
5238				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5238 79				db WORD_SYS_CORE+101             
5239 49 52			dw .V1S            
523b 04				db 3 + 1 
523c .. 00			db "V0@",0              
5240				endm 
# End of macro CWHEAD
5240			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5240 2a 8d fc				ld hl, (cli_var_array) 
5243 cd de 1d				call forth_push_numhl 
5246			 
5246				       NEXTW 
5246 c3 47 21			jp macro_next 
5249				endm 
# End of macro NEXTW
5249			.V1S: 
5249				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5249 7a				db WORD_SYS_CORE+102             
524a 61 52			dw .V1Q            
524c 04				db 3 + 1 
524d .. 00			db "V1!",0              
5251				endm 
# End of macro CWHEAD
5251			;| V1! ( u1 -- )  Store value to v1 | DONE 
5251					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5251 cd d5 1f			call macro_dsp_valuehl 
5254				endm 
# End of macro FORTH_DSP_VALUEHL
5254			 
5254 11 8f fc				ld de, cli_var_array+2 
5257				 
5257 eb					ex de, hl 
5258 73					ld (hl), e 
5259 23					inc hl 
525a 72					ld (hl), d 
525b			 
525b					; destroy value TOS 
525b			 
525b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
525b cd 8d 20			call macro_forth_dsp_pop 
525e				endm 
# End of macro FORTH_DSP_POP
525e				       NEXTW 
525e c3 47 21			jp macro_next 
5261				endm 
# End of macro NEXTW
5261			.V1Q: 
5261				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5261 7b				db WORD_SYS_CORE+103             
5262 72 52			dw .V2S            
5264 04				db 3 + 1 
5265 .. 00			db "V1@",0              
5269				endm 
# End of macro CWHEAD
5269			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5269 2a 8f fc				ld hl, (cli_var_array+2) 
526c cd de 1d				call forth_push_numhl 
526f				       NEXTW 
526f c3 47 21			jp macro_next 
5272				endm 
# End of macro NEXTW
5272			.V2S: 
5272				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5272 7c				db WORD_SYS_CORE+104             
5273 8a 52			dw .V2Q            
5275 04				db 3 + 1 
5276 .. 00			db "V2!",0              
527a				endm 
# End of macro CWHEAD
527a			;| V2! ( u1 -- )  Store value to v2 | DONE 
527a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
527a cd d5 1f			call macro_dsp_valuehl 
527d				endm 
# End of macro FORTH_DSP_VALUEHL
527d			 
527d 11 91 fc				ld de, cli_var_array+4 
5280				 
5280 eb					ex de, hl 
5281 73					ld (hl), e 
5282 23					inc hl 
5283 72					ld (hl), d 
5284			 
5284					; destroy value TOS 
5284			 
5284					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5284 cd 8d 20			call macro_forth_dsp_pop 
5287				endm 
# End of macro FORTH_DSP_POP
5287				       NEXTW 
5287 c3 47 21			jp macro_next 
528a				endm 
# End of macro NEXTW
528a			.V2Q: 
528a				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
528a 7d				db WORD_SYS_CORE+105             
528b 9b 52			dw .V3S            
528d 04				db 3 + 1 
528e .. 00			db "V2@",0              
5292				endm 
# End of macro CWHEAD
5292			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5292 2a 91 fc				ld hl, (cli_var_array+4) 
5295 cd de 1d				call forth_push_numhl 
5298				       NEXTW 
5298 c3 47 21			jp macro_next 
529b				endm 
# End of macro NEXTW
529b			.V3S: 
529b				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
529b 7c				db WORD_SYS_CORE+104             
529c b3 52			dw .V3Q            
529e 04				db 3 + 1 
529f .. 00			db "V3!",0              
52a3				endm 
# End of macro CWHEAD
52a3			;| V3! ( u1 -- )  Store value to v3 | DONE 
52a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52a3 cd d5 1f			call macro_dsp_valuehl 
52a6				endm 
# End of macro FORTH_DSP_VALUEHL
52a6			 
52a6 11 93 fc				ld de, cli_var_array+6 
52a9				 
52a9 eb					ex de, hl 
52aa 73					ld (hl), e 
52ab 23					inc hl 
52ac 72					ld (hl), d 
52ad			 
52ad					; destroy value TOS 
52ad			 
52ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52ad cd 8d 20			call macro_forth_dsp_pop 
52b0				endm 
# End of macro FORTH_DSP_POP
52b0				       NEXTW 
52b0 c3 47 21			jp macro_next 
52b3				endm 
# End of macro NEXTW
52b3			.V3Q: 
52b3				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
52b3 7d				db WORD_SYS_CORE+105             
52b4 c4 52			dw .END            
52b6 04				db 3 + 1 
52b7 .. 00			db "V3@",0              
52bb				endm 
# End of macro CWHEAD
52bb			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
52bb 2a 93 fc				ld hl, (cli_var_array+6) 
52be cd de 1d				call forth_push_numhl 
52c1				       NEXTW 
52c1 c3 47 21			jp macro_next 
52c4				endm 
# End of macro NEXTW
52c4			 
52c4			 
52c4			 
52c4			 
52c4			 
52c4			; end of dict marker 
52c4			 
52c4 00			.END:    db WORD_SYS_END 
52c5 00 00			dw 0 
52c7 00				db 0 
52c8			 
52c8			; use to jp here for user dict words to save on macro expansion  
52c8			 
52c8			user_dict_next: 
52c8				NEXTW 
52c8 c3 47 21			jp macro_next 
52cb				endm 
# End of macro NEXTW
52cb			 
52cb			 
52cb			user_exec: 
52cb				;    ld hl, <word code> 
52cb				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
52cb				;    call forthexec 
52cb				;    jp user_dict_next   (NEXT) 
52cb			        ;    <word code bytes> 
52cb eb				ex de, hl 
52cc 2a 5b f7			ld hl,(os_tok_ptr) 
52cf				 
52cf				FORTH_RSP_NEXT 
52cf cd 85 1d			call macro_forth_rsp_next 
52d2				endm 
# End of macro FORTH_RSP_NEXT
52d2			 
52d2			if DEBUG_FORTH_UWORD 
52d2						DMARK "UEX" 
52d2 f5				push af  
52d3 3a e7 52			ld a, (.dmark)  
52d6 32 b4 fe			ld (debug_mark),a  
52d9 3a e8 52			ld a, (.dmark+1)  
52dc 32 b5 fe			ld (debug_mark+1),a  
52df 3a e9 52			ld a, (.dmark+2)  
52e2 32 b6 fe			ld (debug_mark+2),a  
52e5 18 03			jr .pastdmark  
52e7 ..			.dmark: db "UEX"  
52ea f1			.pastdmark: pop af  
52eb			endm  
# End of macro DMARK
52eb				CALLMONITOR 
52eb cd 70 17			call break_point_state  
52ee				endm  
# End of macro CALLMONITOR
52ee			endif 
52ee			 
52ee			 
52ee			 
52ee eb				ex de, hl 
52ef 22 5b f7			ld (os_tok_ptr), hl 
52f2				 
52f2				; Don't use next - Skips the first word in uword. 
52f2			 
52f2 c3 d8 21			jp exec1 
52f5			;	NEXT 
52f5			 
52f5			 
52f5			; eof 
# End of file forth_wordsv4.asm
52f5			endif 
52f5			;;;;;;;;;;;;;; Debug code 
52f5			 
52f5			 
52f5			;if DEBUG_FORTH_PARSE 
52f5 .. 00		.nowordfound: db "No match",0 
52fe .. 00		.compword:	db "Comparing word ",0 
530e .. 00		.nextwordat:	db "Next word at",0 
531b .. 00		.charmatch:	db "Char match",0 
5326			;endif 
5326			if DEBUG_FORTH_JP 
5326			.foundword:	db "Word match. Exec..",0 
5326			endif 
5326			;if DEBUG_FORTH_PUSH 
5326 .. 00		.enddict:	db "Dict end. Push.",0 
5336 .. 00		.push_str:	db "Pushing string",0 
5345 .. 00		.push_num:	db "Pushing number",0 
5354 .. 00		.data_sp:	db "SP:",0 
5358 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
536a .. 00		.wordinde:	db "Word in DE (3/0):",0 
537c .. 00		.wordinbc:	db "Word in BC (4/0):",0 
538e			;endif 
538e			;if DEBUG_FORTH_MALLOC 
538e .. 00		.push_malloc:	db "Malloc address",0 
539d			;endif 
539d			 
539d			 
539d			 
539d			; display malloc address and current data stack pointer  
539d			 
539d			malloc_error: 
539d d5				push de 
539e f5				push af 
539f e5				push hl 
53a0 cd bf 0b			call clear_display 
53a3 11 c5 53			ld de, .mallocerr 
53a6 3e 00			ld a,0 
53a8			;	ld de,os_word_scratch 
53a8 cd d2 0b			call str_at_display 
53ab 3e 11			ld a, display_row_1+17 
53ad 11 b4 fe			ld de, debug_mark 
53b0 cd d2 0b			call str_at_display 
53b3 cd e2 0b			call update_display 
53b6				;call break_point_state 
53b6 cd 4b 69			call cin_wait 
53b9			 
53b9 3e 20			ld a, ' ' 
53bb 32 4b f4			ld (os_view_disable), a 
53be e1				pop hl 
53bf f1				pop af 
53c0 d1				pop de	 
53c1				CALLMONITOR 
53c1 cd 70 17			call break_point_state  
53c4				endm  
# End of macro CALLMONITOR
53c4 c9				ret 
53c5			 
53c5 .. 00		.mallocerr: 	db "Malloc Error",0 
53d2			;if DEBUG_FORTH_PUSH 
53d2			display_data_sp: 
53d2 f5				push af 
53d3			 
53d3				; see if disabled 
53d3			 
53d3 3a 4b f4			ld a, (os_view_disable) 
53d6 fe 2a			cp '*' 
53d8 28 67			jr z, .skipdsp 
53da			 
53da e5				push hl 
53db e5				push hl 
53dc e5			push hl 
53dd cd bf 0b			call clear_display 
53e0 e1			pop hl 
53e1 7c				ld a,h 
53e2 21 5f f7			ld hl, os_word_scratch 
53e5 cd f4 10			call hexout 
53e8 e1				pop hl 
53e9 7d				ld a,l 
53ea 21 61 f7			ld hl, os_word_scratch+2 
53ed cd f4 10			call hexout 
53f0 21 63 f7			ld hl, os_word_scratch+4 
53f3 3e 00			ld a,0 
53f5 77				ld (hl),a 
53f6 11 5f f7			ld de,os_word_scratch 
53f9 3e 14				ld a, display_row_2 
53fb cd d2 0b				call str_at_display 
53fe 11 58 53			ld de, .wordinhl 
5401 3e 00			ld a, display_row_1 
5403			 
5403 cd d2 0b				call str_at_display 
5406 11 b4 fe			ld de, debug_mark 
5409 3e 11			ld a, display_row_1+17 
540b			 
540b cd d2 0b				call str_at_display 
540e			 
540e				; display current data stack pointer 
540e 11 54 53			ld de,.data_sp 
5411 3e 1c				ld a, display_row_2 + 8 
5413 cd d2 0b				call str_at_display 
5416			 
5416 2a 87 fc			ld hl,(cli_data_sp) 
5419 e5				push hl 
541a 7c				ld a,h 
541b 21 5f f7			ld hl, os_word_scratch 
541e cd f4 10			call hexout 
5421 e1				pop hl 
5422 7d				ld a,l 
5423 21 61 f7			ld hl, os_word_scratch+2 
5426 cd f4 10			call hexout 
5429 21 63 f7			ld hl, os_word_scratch+4 
542c 3e 00			ld a,0 
542e 77				ld (hl),a 
542f 11 5f f7			ld de,os_word_scratch 
5432 3e 1f				ld a, display_row_2 + 11 
5434 cd d2 0b				call str_at_display 
5437			 
5437			 
5437 cd e2 0b			call update_display 
543a cd 3c 0b			call delay1s 
543d cd 3c 0b			call delay1s 
5440 e1				pop hl 
5441			.skipdsp: 
5441 f1				pop af 
5442 c9				ret 
5443			 
5443			display_data_malloc: 
5443			 
5443 f5				push af 
5444 e5				push hl 
5445 e5				push hl 
5446 e5			push hl 
5447 cd bf 0b			call clear_display 
544a e1			pop hl 
544b 7c				ld a,h 
544c 21 5f f7			ld hl, os_word_scratch 
544f cd f4 10			call hexout 
5452 e1				pop hl 
5453 7d				ld a,l 
5454 21 61 f7			ld hl, os_word_scratch+2 
5457 cd f4 10			call hexout 
545a 21 63 f7			ld hl, os_word_scratch+4 
545d 3e 00			ld a,0 
545f 77				ld (hl),a 
5460 11 5f f7			ld de,os_word_scratch 
5463 3e 14				ld a, display_row_2 
5465 cd d2 0b				call str_at_display 
5468 11 8e 53			ld de, .push_malloc 
546b 3e 00			ld a, display_row_1 
546d			 
546d cd d2 0b				call str_at_display 
5470			 
5470				; display current data stack pointer 
5470 11 54 53			ld de,.data_sp 
5473 3e 1c				ld a, display_row_2 + 8 
5475 cd d2 0b				call str_at_display 
5478			 
5478 2a 87 fc			ld hl,(cli_data_sp) 
547b e5				push hl 
547c 7c				ld a,h 
547d 21 5f f7			ld hl, os_word_scratch 
5480 cd f4 10			call hexout 
5483 e1				pop hl 
5484 7d				ld a,l 
5485 21 61 f7			ld hl, os_word_scratch+2 
5488 cd f4 10			call hexout 
548b 21 63 f7			ld hl, os_word_scratch+4 
548e 3e 00			ld a,0 
5490 77				ld (hl),a 
5491 11 5f f7			ld de,os_word_scratch 
5494 3e 1f				ld a, display_row_2 + 11 
5496 cd d2 0b				call str_at_display 
5499			 
5499 cd e2 0b			call update_display 
549c cd 3c 0b			call delay1s 
549f cd 3c 0b			call delay1s 
54a2 e1				pop hl 
54a3 f1				pop af 
54a4 c9				ret 
54a5			;endif 
54a5			 
54a5			include "forth_autostart.asm" 
54a5			; list of commands to perform at system start up 
54a5			 
54a5			startcmds: 
54a5			;	dw test11 
54a5			;	dw test12 
54a5			;	dw test13 
54a5			;	dw test14 
54a5			;	dw test15 
54a5			;	dw test16 
54a5			;	dw test17 
54a5			;	dw ifthtest1 
54a5			;	dw ifthtest2 
54a5			;	dw ifthtest3 
54a5			;	dw mmtest1 
54a5			;	dw mmtest2 
54a5			;	dw mmtest3 
54a5			;	dw mmtest4 
54a5			;	dw mmtest5 
54a5			;	dw mmtest6 
54a5			;	dw iftest1 
54a5			;	dw iftest2 
54a5			;	dw iftest3 
54a5			;	dw looptest1 
54a5			;	dw looptest2 
54a5			;	dw test1 
54a5			;	dw test2 
54a5			;	dw test3 
54a5			;	dw test4 
54a5			;	dw game2r 
54a5			;	dw game2b1 
54a5			;	dw game2b2 
54a5			 
54a5				; start up words that are actually useful 
54a5			 
54a5 03 55			dw clrstack 
54a7 36 55			dw type 
54a9 26 57			dw stest 
54ab 5a 55			dw strncpy 
54ad bc 56			dw list 
54af bb 55			dw start1 
54b1 cd 55			dw start2 
54b3			;	dw start3 
54b3 e0 55			dw start3b 
54b5 5c 56			dw start3c 
54b7			 
54b7				; (unit) testing words 
54b7			 
54b7 9d 57			dw mtesta 
54b9 52 58			dw mtestb 
54bb f5 58			dw mtestc 
54bd aa 59			dw mtestd 
54bf 4e 5a			dw mteste 
54c1			 
54c1				; demo/game words 
54c1			 
54c1 5a 61		        dw game3w 
54c3 88 61		        dw game3p 
54c5 a6 61		        dw game3sc 
54c7 d7 61		        dw game3vsi 
54c9 03 62		        dw game3vs 
54cb				 
54cb 4d 5f			dw game2b 
54cd bb 5f			dw game2bf 
54cf 05 60			dw game2mba 
54d1 9b 60			dw game2mbas 
54d3 dd 60			dw game2mb 
54d5			 
54d5 0e 5c			dw game1 
54d7 1f 5c			dw game1a 
54d9 81 5c			dw game1b 
54db b6 5c			dw game1c 
54dd ec 5c			dw game1d 
54df 1d 5d			dw game1s 
54e1 31 5d			dw game1t 
54e3 46 5d			dw game1f 
54e5 7a 5d			dw game1z 
54e7 be 5d			dw game1zz 
54e9			 
54e9 04 5b			dw test5 
54eb 3c 5b			dw test6 
54ed 74 5b			dw test7 
54ef 88 5b			dw test8 
54f1 b4 5b			dw test9 
54f3 ca 5b			dw test10 
54f5				 
54f5 95 5e		        dw ssv5 
54f7 79 5e		        dw ssv4 
54f9 5d 5e		        dw ssv3 
54fb 27 5e		        dw ssv2 
54fd ae 5e		        dw ssv1 
54ff f6 5e		        dw ssv1cpm 
5501			;	dw keyup 
5501			;	dw keydown 
5501			;	dw keyleft 
5501			;	dw keyright 
5501			;	dw 	keyf1 
5501			;	dw keyf2 
5501			;	dw keyf3 
5501			;	dw keyf4 
5501			;	dw keyf5 
5501			;	dw keyf6 
5501			;	dw keyf7 
5501			;	dw keyf8 
5501			;	dw keyf9 
5501			;	dw keyf10 
5501			;	dw keyf11 
5501			;	dw keyf12 
5501			;	dw keytab 
5501			;	dw keycr 
5501			;	dw keyhome 
5501			;	dw keyend 
5501			;	dw keybs 
5501 00 00			db 0, 0	 
5503			 
5503			 
5503			; clear stack  
5503			 
5503 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5536			 
5536			; type ( addr count - ) 
5536 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
555a			 
555a			; some direct memory words 
555a			; strncpy ( len t f -- t ) 
555a			 
555a .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
55bb			 
55bb .. 00		start1:     	db ": bpon $0000 bp ;",0 
55cd .. 00		start2:     	db ": bpoff $0001 bp ;",0 
55e0 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
565c .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
56bc			 
56bc			 
56bc			; a handy word to list items on the stack 
56bc			 
56bc .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5726			 
5726			 
5726			; test stack  
5726			; rnd8 stest 
5726			 
5726 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
579d			 
579d			; random malloc and free cycles 
579d			 
579d .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5852			 
5852			; fixed malloc and free cycles 
5852			 
5852 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
58f5			 
58f5			; fixed double string push and drop cycle  
58f5			 
58f5 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
59aa			 
59aa			; consistent fixed string push and drop cycle  
59aa			 
59aa .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5a4e			 
5a4e .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5b04			 
5b04			;test1:		db ": aa 1 2 3 ;", 0 
5b04			;test2:     	db "111 aa 888 999",0 
5b04			;test3:     	db ": bb 77 ;",0 
5b04			;test4:     	db "$02 $01 do i . loop bb",0 
5b04			 
5b04 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5b3c .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5b74 .. 00		test7:     	db ": box hline vline ;",0 
5b88 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5bb4 .. 00		test9:     	db ": sw $01 adsp world ;",0 
5bca .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5bef .. 00		test11:     	db "hello create .",0 
5bfe .. 00		test12:     	db "hello2 create .",0 
5c0e			 
5c0e			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5c0e			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5c0e			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5c0e			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5c0e			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5c0e			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5c0e			 
5c0e			;iftest1:     	db "$0001 IF cls .",0 
5c0e			;iftest2:     	db "$0000 IF cls .",0 
5c0e			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5c0e			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5c0e			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5c0e			 
5c0e			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5c0e			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5c0e			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5c0e			 
5c0e			 
5c0e			 
5c0e			; a small guess the number game 
5c0e			 
5c0e .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5c1f .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5c81			 
5c81 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5cb6 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5cec .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5d1d .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5d31 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5d46 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5d7a .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5dbe			 
5dbe			; Using 'ga' save a high score across multiple runs using external storage 
5dbe			 
5dbe .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5e27			 
5e27			 
5e27			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5e27			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5e27			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5e27			 
5e27			; simple screen saver to test code memory reuse to destruction 
5e27			 
5e27 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5e5d .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5e79 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5e95 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5eae .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5ef6 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5f4d			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5f4d			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5f4d			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5f4d			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5f4d			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5f4d			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5f4d			 
5f4d			 
5f4d			 
5f4d			; minesweeper/battleship finding game 
5f4d			; draws a game board of random ship/mine positions 
5f4d			; user enters coords to see if it hits on 
5f4d			; game ends when all are hit 
5f4d			; when hit or miss says how many may be in the area 
5f4d			 
5f4d			; setup the game board and then hide it 
5f4d .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5fbb .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6005			; prompt for where to target 
6005 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
609b .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
60c0			; TODO see if the entered coords hits or misses pushes char hit of miss 
60c0 .. 00		game2mbht:      db ": mbckht nop ;",0 
60cf .. 00		game2mbms:      db ": mbcms nop ;",0 
60dd			; TODO how many might be near by 
60dd .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
615a			 
615a			; Game 3 
615a			 
615a			; Vert scroller ski game - avoid the trees! 
615a			 
615a			; v0 score (ie turns) 
615a			; v1 player pos 
615a			; v2 left wall 
615a			; v3 right wall 
615a			 
615a			; Draw side walls randomly 
615a			 
615a .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6188			 
6188			; Draw player 
6188 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
61a6			 
61a6			; TODO Get Key 
61a6			 
61a6			; TODO Move left right 
61a6			 
61a6			; scroll and move walls a bit 
61a6			 
61a6 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
61d7			 
61d7			; main game loop 
61d7			 
61d7 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6203 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6242			 
6242			; key board defs 
6242			 
6242 .. 00		keyup:       db ": keyup $05 ;",0 
6250 .. 00		keydown:       db ": keydown $0a ;",0 
6260 .. 00		keyleft:       db ": keyleft $0b ;",0 
6270 .. 00		keyright:       db ": keyright $0c ;",0 
6281 .. 00		keyf1:       db ": keyf1 $10 ;",0 
628f .. 00		keyf2:       db ": keyf2 $11 ;",0 
629d .. 00		keyf3:       db ": keyf3 $12 ;",0 
62ab .. 00		keyf4:       db ": keyf4 $13 ;",0 
62b9 .. 00		keyf5:       db ": keyf5 $14 ;",0 
62c7 .. 00		keyf6:       db ": keyf6 $15 ;",0 
62d5 .. 00		keyf7:       db ": keyf7 $16 ;",0 
62e3 .. 00		keyf8:       db ": keyf8 $17 ;",0 
62f1 .. 00		keyf9:       db ": keyf9 $18 ;",0 
62ff .. 00		keyf10:       db ": keyf10 $19 ;",0 
630e .. 00		keyf11:       db ": keyf11 $1a ;",0 
631d .. 00		keyf12:       db ": keyf12 $1b ;",0 
632c			 
632c .. 00		keytab:       db ": keytab $09 ;",0 
633b .. 00		keycr:       db ": keycr $0d ;",0 
6349 .. 00		keyhome:       db ": keyhome $0e ;",0 
6359 .. 00		keyend:       db ": keyend $0f ;",0 
6368 .. 00		keybs:       db ": keybs $08 ;",0 
6376			 
6376			   
6376			 
6376			 
6376			 
6376			; eof 
# End of file forth_autostart.asm
6376			 
6376 .. 00		sprompt1: db "Startup load...",0 
6386 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
639c			 
639c			 
639c			 
639c			 
639c			forth_startup: 
639c 21 a5 54			ld hl, startcmds 
639f 3e 00			ld a, 0 
63a1 32 80 f8			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
63a4			 
63a4 e5			.start1:	push hl 
63a5 cd bf 0b			call clear_display 
63a8 11 76 63			ld de, sprompt1 
63ab 3e 00		        ld a, display_row_1 
63ad cd d2 0b			call str_at_display 
63b0 11 86 63			ld de, sprompt2 
63b3 3e 14		        ld a, display_row_2 
63b5 cd d2 0b			call str_at_display 
63b8 e1				pop hl 
63b9 e5				push hl 
63ba 5e				ld e,(hl) 
63bb 23				inc hl 
63bc 56				ld d,(hl) 
63bd 3e 28		        ld a, display_row_3 
63bf cd d2 0b			call str_at_display 
63c2 cd e2 0b			call update_display 
63c5			 
63c5			 
63c5 3a 80 f8			ld a, (os_last_cmd) 
63c8 fe 00			cp 0 
63ca 28 05			jr z, .startprompt 
63cc cd 30 0b			call delay250ms 
63cf 18 24			jr .startdo 
63d1				 
63d1				 
63d1			 
63d1			.startprompt: 
63d1			 
63d1 3e 4f			ld a,display_row_4 + display_cols - 1 
63d3 11 54 1d		        ld de, endprg 
63d6 cd d2 0b			call str_at_display 
63d9 cd e2 0b			call update_display 
63dc cd 3c 0b			call delay1s 
63df cd 4b 69			call cin_wait 
63e2						 
63e2 fe 2a			cp '*' 
63e4 28 5e			jr z, .startupend1 
63e6 fe 23			cp '#' 
63e8 20 07			jr nz, .startno 
63ea 3e 01			ld a, 1 
63ec 32 80 f8			ld (os_last_cmd),a 
63ef 18 04			jr .startdo 
63f1 fe 31		.startno:	cp '1' 
63f3 28 3a			jr z,.startnxt  
63f5			 
63f5				; exec startup line 
63f5			.startdo:	 
63f5 e1				pop hl 
63f6 e5				push hl 
63f7				 
63f7 5e				ld e,(hl) 
63f8 23				inc hl 
63f9 56				ld d,(hl) 
63fa eb				ex de,hl 
63fb			 
63fb e5				push hl 
63fc			 
63fc 3e 00			ld a, 0 
63fe				;ld a, FORTH_END_BUFFER 
63fe cd 5c 12			call strlent 
6401 23				inc hl   ; include zero term to copy 
6402 06 00			ld b,0 
6404 4d				ld c,l 
6405 e1				pop hl 
6406 11 5a f4			ld de, scratch 
6409 ed b0			ldir 
640b			 
640b			 
640b 21 5a f4			ld hl, scratch 
640e cd 95 21			call forthparse 
6411 cd d5 21			call forthexec 
6414 cd ec 20			call forthexec_cleanup 
6417			 
6417 3e 3c			ld a, display_row_4 
6419 11 f8 1a			ld de, endprog 
641c			 
641c cd e2 0b			call update_display		 
641f			 
641f 3a 80 f8			ld a, (os_last_cmd) 
6422 fe 00			cp 0 
6424 20 09			jr nz, .startnxt 
6426 cd 56 1d			call next_page_prompt 
6429 cd bf 0b		        call clear_display 
642c cd e2 0b			call update_display		 
642f			 
642f				; move onto next startup line? 
642f			.startnxt: 
642f			 
642f cd 30 0b			call delay250ms 
6432 e1				pop hl 
6433			 
6433 23				inc hl 
6434 23				inc hl 
6435			 
6435 e5				push hl 
6436 5e				ld e, (hl) 
6437 23				inc hl 
6438 56				ld d, (hl) 
6439 e1				pop hl 
643a				; TODO replace 0 test 
643a			 
643a eb				ex de, hl 
643b cd 1c 0e			call ishlzero 
643e			;	ld a,e 
643e			;	add d 
643e			;	cp 0    ; any left to do? 
643e eb				ex de, hl 
643f c2 a4 63			jp nz, .start1 
6442 18 01			jr .startupend 
6444			 
6444 e1			.startupend1: pop hl 
6445			.startupend: 
6445			 
6445 cd bf 0b			call clear_display 
6448 cd e2 0b			call update_display 
644b c9				ret 
644c			 
644c			 
644c			; stack over and underflow checks 
644c			 
644c			; init the words to detect the under/overflow 
644c			 
644c			chk_stk_init: 
644c				; a vague random number to check so we dont get any "lucky" hits 
644c 3e 2d			ld a, 45 
644e 6f				ld l, a 
644f 00				nop 
6450 3e 17			ld a, 23 
6452 67				ld h, a 
6453			 
6453 22 41 f4			ld (chk_word), hl     ; the word we need to check against 
6456			 
6456			;	ld (chk_stund), hl	; stack points.... 
6456 22 fd fe			ld (chk_stovr), hl 
6459 22 85 fc			ld (chk_ret_und), hl 
645c 22 43 fc			ld (chk_ret_ovr), hl 
645f 22 c1 fb			ld (chk_loop_ovr), hl 
6462 22 bf f9			ld (chk_data_ovr), hl 
6465 c9				ret 
6466				 
6466			check_stacks: 
6466				; check all stack words 
6466			 
6466 e5				push hl 
6467 d5				push de 
6468			 
6468			;	ld de,(chk_word) 
6468			;	ld hl, (chk_stund)	; stack points.... 
6468			;	if DEBUG_STK_FAULT 
6468			;		DMARK "FAa" 
6468			;		CALLMONITOR 
6468			;	endif 
6468			;	call cmp16 
6468			;	jp z, .chk_faulta 
6468			; 
6468			;	ld de, sfaultsu 
6468			;	jp .chk_fault 
6468			 
6468 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
646b ed 5b 41 f4		ld de,(chk_word) 
646f				if DEBUG_STK_FAULT 
646f					DMARK "FAb" 
646f					CALLMONITOR 
646f				endif 
646f cd 11 0e			call cmp16 
6472 28 06			jr z, .chk_fault1 
6474 11 15 65			ld de, sfaultso 
6477 c3 c9 64			jp .chk_fault 
647a			.chk_fault1:  
647a 2a 85 fc			ld hl, (chk_ret_und) 
647d ed 5b 41 f4		ld de,(chk_word) 
6481				if DEBUG_STK_FAULT 
6481					DMARK "FAU" 
6481					CALLMONITOR 
6481				endif 
6481 cd 11 0e			call cmp16 
6484 ca 8d 64			jp z, .chk_fault2 
6487 11 25 65			ld de, sfaultru 
648a c3 c9 64			jp .chk_fault 
648d			.chk_fault2:  
648d 2a 43 fc			ld hl, (chk_ret_ovr) 
6490 ed 5b 41 f4		ld de,(chk_word) 
6494				if DEBUG_STK_FAULT 
6494					DMARK "FA1" 
6494					CALLMONITOR 
6494				endif 
6494 cd 11 0e			call cmp16 
6497 ca a0 64			jp z, .chk_fault3 
649a 11 33 65			ld de, sfaultro 
649d c3 c9 64			jp .chk_fault 
64a0			.chk_fault3:  
64a0 2a c1 fb			ld hl, (chk_loop_ovr) 
64a3 ed 5b 41 f4		ld de,(chk_word) 
64a7				if DEBUG_STK_FAULT 
64a7					DMARK "FA2" 
64a7					CALLMONITOR 
64a7				endif 
64a7 cd 11 0e			call cmp16 
64aa ca b3 64			jp z, .chk_fault4 
64ad 11 4d 65			ld de, sfaultlo 
64b0 c3 c9 64			jp .chk_fault 
64b3			.chk_fault4:  
64b3 2a bf f9			ld hl, (chk_data_ovr) 
64b6 ed 5b 41 f4		ld de,(chk_word) 
64ba				if DEBUG_STK_FAULT 
64ba					DMARK "FA3" 
64ba					CALLMONITOR 
64ba				endif 
64ba cd 11 0e			call cmp16 
64bd ca c6 64			jp z, .chk_fault5 
64c0 11 67 65			ld de, sfaultdo 
64c3 c3 c9 64			jp .chk_fault 
64c6			 
64c6			 
64c6			.chk_fault5:  
64c6 d1				pop de 
64c7 e1				pop hl 
64c8			 
64c8 c9				ret 
64c9			 
64c9 cd bf 0b		.chk_fault: 	call clear_display 
64cc 3e 14				ld a, display_row_2 
64ce cd d2 0b				call str_at_display 
64d1 11 f7 64				   ld de, .stackfault 
64d4 3e 00				ld a, display_row_1 
64d6 cd d2 0b				call str_at_display 
64d9 11 b4 fe				    ld de, debug_mark 
64dc 3e 11				ld a, display_row_1+17 
64de cd d2 0b				call str_at_display 
64e1 cd e2 0b				call update_display 
64e4			 
64e4				; prompt before entering montior for investigating issue 
64e4			 
64e4 3e 3c			ld a, display_row_4 
64e6 11 f8 1a			ld de, endprog 
64e9			 
64e9 cd e2 0b			call update_display		 
64ec			 
64ec cd 56 1d			call next_page_prompt 
64ef			 
64ef d1				pop de 
64f0 e1				pop hl 
64f1 cd 4c 1b				call monitor 
64f4 c3 43 1a				jp warmstart 
64f7					;jp 0 
64f7					;halt 
64f7			 
64f7			 
64f7			 
64f7 .. 00		.stackfault: 	db "Stack fault:",0 
6504			 
6504 .. 00		sfaultsu: 	db	"Stack under flow",0 
6515 .. 00		sfaultso: 	db	"Stack over flow",0 
6525 .. 00		sfaultru:	db "RTS underflow",0 
6533 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
654d .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6567 .. 00		sfaultdo:	db "DTS overflow", 0 
6574			 
6574			 
6574			fault_dsp_under: 
6574 11 86 65			ld de, .dsp_under 
6577 c3 36 66			jp .show_fault 
657a			 
657a			fault_rsp_under: 
657a 11 94 65			ld de, .rsp_under 
657d c3 36 66			jp .show_fault 
6580			fault_loop_under: 
6580 11 a2 65			ld de, .loop_under 
6583 c3 36 66			jp .show_fault 
6586			 
6586 .. 00		.dsp_under: db "DSP Underflow",0 
6594 .. 00		.rsp_under: db "RSP Underflow",0 
65a2 .. 00		.loop_under: db "LOOP Underflow",0 
65b1			 
65b1			 
65b1 d5			type_faultn: 	push de 
65b2 e5					push hl 
65b3 cd bf 0b				call clear_display 
65b6 11 dd 65				   ld de, .typefaultn 
65b9 3e 00				ld a, display_row_1 
65bb cd d2 0b				call str_at_display 
65be 11 b4 fe				    ld de, debug_mark 
65c1 3e 11				ld a, display_row_1+17 
65c3 cd d2 0b				call str_at_display 
65c6 cd e2 0b				call update_display 
65c9			 
65c9				; prompt before entering montior for investigating issue 
65c9			 
65c9 3e 3c			ld a, display_row_4 
65cb 11 f8 1a			ld de, endprog 
65ce			 
65ce cd e2 0b			call update_display		 
65d1			 
65d1 cd 56 1d			call next_page_prompt 
65d4			 
65d4 e5					push hl 
65d5 d5					push de 
65d6 cd 4c 1b				call monitor 
65d9 c3 43 1a				jp warmstart 
65dc 76					halt 
65dd			 
65dd			 
65dd .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
65f4			 
65f4 d5			type_faults: 	push de 
65f5 e5					push hl 
65f6 cd bf 0b				call clear_display 
65f9 11 1f 66				   ld de, .typefaults 
65fc 3e 00				ld a, display_row_1 
65fe cd d2 0b				call str_at_display 
6601 11 b4 fe				    ld de, debug_mark 
6604 3e 11				ld a, display_row_1+17 
6606 cd d2 0b				call str_at_display 
6609 cd e2 0b				call update_display 
660c			 
660c				; prompt before entering montior for investigating issue 
660c			 
660c 3e 3c			ld a, display_row_4 
660e 11 f8 1a			ld de, endprog 
6611			 
6611 cd e2 0b			call update_display		 
6614			 
6614 cd 56 1d			call next_page_prompt 
6617			 
6617 e1					pop hl 
6618 d1					pop de 
6619 cd 4c 1b				call monitor 
661c c3 43 1a				jp warmstart 
661f			 
661f			 
661f .. 00		.typefaults: db "STR Type Expected TOS!",0 
6636			 
6636			.show_fault: 	 
6636 d5					push de 
6637 cd bf 0b				call clear_display 
663a d1					pop de 
663b 3e 00				ld a, display_row_1 
663d cd d2 0b				call str_at_display 
6640 11 b4 fe				    ld de, debug_mark 
6643 3e 11				ld a, display_row_1+17 
6645 cd d2 0b				call str_at_display 
6648 cd e2 0b				call update_display 
664b			 
664b				; prompt before entering montior for investigating issue 
664b			 
664b 3e 3c			ld a, display_row_4 
664d 11 f8 1a			ld de, endprog 
6650			 
6650 cd e2 0b			call update_display		 
6653			 
6653 cd 56 1d			call next_page_prompt 
6656			 
6656 e1					pop hl 
6657 d1					pop de 
6658 cd 4c 1b				call monitor 
665b			; do a dump to cli and not warmstart so we preserve all of the uwords.  
665b			; TODO Make optional fault restart to cli or warm boot? 
665b					;jp warmstart 
665b c3 9e 1a				jp cli 
665e 76					halt 
665f			 
665f			; handle the auto run of code from files in storage 
665f			 
665f			 
665f			if STORAGE_SE 
665f			 
665f .. 00		sprompt3: db "Loading from start-up file?:",0 
667c .. 00		sprompt4: db "(Y=Any key/N=No)",0 
668d			 
668d			 
668d			forth_autoload: 
668d			 
668d				; load block 0 of store 1 
668d				 
668d 3e fe			ld a, $fe      ; bit 0 clear 
668f 32 c5 fc			ld (spi_device), a 
6692			 
6692 cd 82 04			call storage_get_block_0 
6695			 
6695 3a 00 fd			ld a, (store_page+STORE_0_AUTOFILE) 
6698			 
6698 fe 00			cp 0 
669a c8				ret z     ; auto start not enabled 
669b			 
669b cd bf 0b			call clear_display 
669e			 
669e				; set bank 
669e			 
669e 3a 02 fd				ld a, (store_page+STORE_0_BANKRUN) 
66a1 32 c5 fc				ld (spi_device), a 
66a4			 
66a4				; get file id to load from and get the file name to display 
66a4			 
66a4 3a 03 fd				ld a, (store_page+STORE_0_FILERUN) 
66a7			 
66a7 2e 00				ld l, 0 
66a9 67					ld h, a 
66aa 11 df fc				ld de, store_page 
66ad			 
66ad					if DEBUG_FORTH_WORDS 
66ad						DMARK "ASp" 
66ad f5				push af  
66ae 3a c2 66			ld a, (.dmark)  
66b1 32 b4 fe			ld (debug_mark),a  
66b4 3a c3 66			ld a, (.dmark+1)  
66b7 32 b5 fe			ld (debug_mark+1),a  
66ba 3a c4 66			ld a, (.dmark+2)  
66bd 32 b6 fe			ld (debug_mark+2),a  
66c0 18 03			jr .pastdmark  
66c2 ..			.dmark: db "ASp"  
66c5 f1			.pastdmark: pop af  
66c6			endm  
# End of macro DMARK
66c6						CALLMONITOR 
66c6 cd 70 17			call break_point_state  
66c9				endm  
# End of macro CALLMONITOR
66c9					endif 
66c9 cd 2a 09				call storage_read 
66cc			 
66cc					if DEBUG_FORTH_WORDS 
66cc						DMARK "ASr" 
66cc f5				push af  
66cd 3a e1 66			ld a, (.dmark)  
66d0 32 b4 fe			ld (debug_mark),a  
66d3 3a e2 66			ld a, (.dmark+1)  
66d6 32 b5 fe			ld (debug_mark+1),a  
66d9 3a e3 66			ld a, (.dmark+2)  
66dc 32 b6 fe			ld (debug_mark+2),a  
66df 18 03			jr .pastdmark  
66e1 ..			.dmark: db "ASr"  
66e4 f1			.pastdmark: pop af  
66e5			endm  
# End of macro DMARK
66e5						CALLMONITOR 
66e5 cd 70 17			call break_point_state  
66e8				endm  
# End of macro CALLMONITOR
66e8					endif 
66e8			 
66e8 cd 1c 0e				call ishlzero 
66eb c8					ret z             ; file not found 
66ec			 
66ec 3e 1e				ld a, display_row_2 + 10 
66ee 11 e2 fc				ld de, store_page+3 
66f1 cd d2 0b				call str_at_display 
66f4				 
66f4			; 
66f4			 
66f4 3e 05			ld a, display_row_1+5 
66f6 11 5f 66			ld de, sprompt3 
66f9 cd d2 0b			call str_at_display 
66fc 3e 37			ld a, display_row_3+15 
66fe 11 7c 66			ld de, sprompt4 
6701 cd d2 0b			call str_at_display 
6704			 
6704 cd e2 0b			call update_display 
6707			 
6707 cd 4b 69			call cin_wait 
670a fe 6e			cp 'n' 
670c c8				ret z 
670d fe 4e			cp 'N' 
670f c8				ret z 
6710			 
6710 cd 3c 0b			call delay1s 
6713			 
6713 3a e1 fc			ld a, (store_page+2) 
6716 32 d5 fc			ld (store_openmaxext), a    ; save count of ext 
6719 3e 01			ld a, 1  
671b 32 d6 fc			ld (store_openext), a    ; save count of ext 
671e			 
671e			.autof:  
671e 6f				ld l , a 
671f				 
671f 3a df fc			ld a, (store_page) 
6722 67				ld h, a	 
6723 11 df fc			ld de, store_page 
6726					if DEBUG_FORTH_WORDS 
6726						DMARK "ASl" 
6726 f5				push af  
6727 3a 3b 67			ld a, (.dmark)  
672a 32 b4 fe			ld (debug_mark),a  
672d 3a 3c 67			ld a, (.dmark+1)  
6730 32 b5 fe			ld (debug_mark+1),a  
6733 3a 3d 67			ld a, (.dmark+2)  
6736 32 b6 fe			ld (debug_mark+2),a  
6739 18 03			jr .pastdmark  
673b ..			.dmark: db "ASl"  
673e f1			.pastdmark: pop af  
673f			endm  
# End of macro DMARK
673f						CALLMONITOR 
673f cd 70 17			call break_point_state  
6742				endm  
# End of macro CALLMONITOR
6742					endif 
6742 cd 2a 09				call storage_read 
6745 cd 1c 0e			call ishlzero 
6748 c8				ret z 
6749			;	jr z, .autoend 
6749			 
6749					if DEBUG_FORTH_WORDS 
6749						DMARK "ASc" 
6749 f5				push af  
674a 3a 5e 67			ld a, (.dmark)  
674d 32 b4 fe			ld (debug_mark),a  
6750 3a 5f 67			ld a, (.dmark+1)  
6753 32 b5 fe			ld (debug_mark+1),a  
6756 3a 60 67			ld a, (.dmark+2)  
6759 32 b6 fe			ld (debug_mark+2),a  
675c 18 03			jr .pastdmark  
675e ..			.dmark: db "ASc"  
6761 f1			.pastdmark: pop af  
6762			endm  
# End of macro DMARK
6762						CALLMONITOR 
6762 cd 70 17			call break_point_state  
6765				endm  
# End of macro CALLMONITOR
6765					endif 
6765 11 e1 fc			ld de, store_page+2 
6768 3e 3c			ld a, display_row_4 
676a cd d2 0b			call str_at_display 
676d			 
676d cd e2 0b			call update_display 
6770 cd 30 0b			call delay250ms 
6773			 
6773			 
6773			 
6773 21 e1 fc			ld hl, store_page+2 
6776 cd 95 21			call forthparse 
6779 cd d5 21			call forthexec 
677c cd ec 20			call forthexec_cleanup 
677f			 
677f				 
677f 3a d6 fc			ld a, (store_openext) 
6782 3c				inc a 
6783 32 d6 fc			ld (store_openext), a    ; save count of ext 
6786			 
6786 18 96			jr .autof 
6788			;.autofdone: 
6788			; 
6788			;		if DEBUG_FORTH_WORDS 
6788			;			DMARK "ASx" 
6788			;			CALLMONITOR 
6788			;		endif 
6788			;;	call clear_display 
6788			;	ret 
6788			 
6788			 
6788			 
6788			endif 
6788			 
6788			 
6788			; eof 
# End of file forth_kernel.asm
6788			;include "nascombasic.asm" 
6788			 
6788			 
6788			; find out where the code ends if loaded into RAM (for SC114) 
6788			;endofcode:  
6788			;	nop 
6788			 
6788			 
6788			; eof 
6788			 
# End of file main.asm
6788			include "firmware_lcd_4x20.asm" 
6788			; **********************************************************************  
6788			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6788			; **********************************************************************  
6788			;  
6788			; **  Written as a Small Computer Monitor App  
6788			; **  www.scc.me.uk  
6788			;  
6788			; History  
6788			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6788			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6788			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6788			;  
6788			; **********************************************************************  
6788			;  
6788			; This program is an example of one of the methods of interfacing an   
6788			; alphanumeric LCD module.   
6788			;  
6788			; In this example the display is connected to either a Z80 PIO or a   
6788			; simple 8-bit output port.   
6788			;  
6788			; This interfacing method uses 4-bit data mode and uses time delays  
6788			; rather than polling the display's ready status. As a result the   
6788			; interface only requires 6 simple output lines:  
6788			;   Output bit 0 = not used  
6788			;   Output bit 1 = not used  
6788			;   Output bit 2 = RS         High = data, Low = instruction  
6788			;   Output bit 3 = E          Active high  
6788			;   Output bit 4 = DB4  
6788			;   Output bit 5 = DB5  
6788			;   Output bit 6 = DB6  
6788			;   Output bit 7 = DB7  
6788			; Display's R/W is connected to 0v so it is always in write mode  
6788			;  
6788			; This set up should work with any system supporting the RC2014 bus  
6788			  
6788			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6788			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6788			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6788			;  
6788			; **********************************************************************  
6788			  
6788			; **********************************************************************  
6788			; **  Constants  
6788			; **********************************************************************  
6788			; LCD constants required by LCD support module  
6788			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6788			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6788			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
6788			kLCDWidth:  EQU display_cols             ;Width in characters  
6788			  
6788			; **********************************************************************  
6788			; **  Code library usage  
6788			; **********************************************************************  
6788			  
6788			; send character to current cursor position  
6788			; wraps and/or scrolls screen automatically  
6788			  
6788			  
6788			lcd_init:  
6788			  
6788			; SCMonAPI functions used  
6788			  
6788			; Alphanumeric LCD functions used  
6788			; no need to specify specific functions for this module  
6788			  
6788 3e cf		            LD   A, 11001111b  
678a d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
678c 3e 00		            LD   A, 00000000b  
678e d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6790			  
6790			; Initialise alphanumeric LCD module  
6790 cd 09 68		            CALL fLCD_Init      ;Initialise LCD module  
6793			  
6793 c9				ret  
6794			  
6794			;  
6794			;;  
6794			; lcd functions  
6794			;  
6794			;  
6794			  
6794			; what is at cursor position   
6794			  
6794			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6794			;		call curptr  
6794			;		ret  
6794			  
6794			  
6794			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6794			  
6794			curptr:  
6794 c5				push bc  
6795 21 4a fe			ld hl, display_fb0  
6798			cpr:	  
6798				; loop for cursor whole row  
6798 0e 14			ld c, display_cols  
679a 23			cpr1:	inc hl  
679b 0d				dec c  
679c 20 fc			jr nz, cpr1  
679e 05				dec b  
679f 20 f7			jr nz, cpr  
67a1			  
67a1				; add col	  
67a1			  
67a1 23			cpr2:	inc hl  
67a2 1d				dec e  
67a3 20 fc			jr nz, cpr2  
67a5			  
67a5 c1				pop bc  
67a6 c9				ret  
67a7				  
67a7			  
67a7			  
67a7			  
67a7			  
67a7			; write the frame buffer given in hl to hardware   
67a7 22 52 fd		write_display: ld (display_write_tmp), hl 	   
67aa 3e 00			ld a, kLCD_Line1  
67ac cd 7a 68		            CALL fLCD_Pos       ;Position cursor to location in A  
67af 06 14			ld b, display_cols  
67b1 ed 5b 52 fd		ld de, (display_write_tmp)  
67b5 cd 01 68			call write_len_string  
67b8				  
67b8				  
67b8 2a 52 fd			ld hl, (display_write_tmp)  
67bb 11 14 00			ld de, display_cols  
67be 19				add hl,de  
67bf 22 52 fd			ld (display_write_tmp),hl  
67c2			  
67c2				  
67c2 3e 40			ld a, kLCD_Line2  
67c4 cd 7a 68		            CALL fLCD_Pos       ;Position cursor to location in A  
67c7 06 14			ld b, display_cols  
67c9 ed 5b 52 fd		ld de, (display_write_tmp)  
67cd cd 01 68			call write_len_string  
67d0				  
67d0 2a 52 fd			ld hl, (display_write_tmp)  
67d3 11 14 00			ld de, display_cols  
67d6 19				add hl,de  
67d7 22 52 fd			ld (display_write_tmp),hl  
67da			  
67da				  
67da 3e 14			ld a, kLCD_Line3  
67dc cd 7a 68		            CALL fLCD_Pos       ;Position cursor to location in A  
67df 06 14			ld b, display_cols  
67e1 ed 5b 52 fd		ld de, (display_write_tmp)  
67e5 cd 01 68			call write_len_string  
67e8				  
67e8 2a 52 fd			ld hl, (display_write_tmp)  
67eb 11 14 00			ld de, display_cols  
67ee 19				add hl,de  
67ef 22 52 fd			ld (display_write_tmp),hl  
67f2			  
67f2				  
67f2 3e 54			ld a, kLCD_Line4  
67f4 cd 7a 68		            CALL fLCD_Pos       ;Position cursor to location in A  
67f7 06 14			ld b, display_cols  
67f9 ed 5b 52 fd		ld de, (display_write_tmp)  
67fd cd 01 68			call write_len_string  
6800 c9					ret  
6801				  
6801				; write out a fixed length string given in b from de  
6801			  
6801 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6802 cd 53 68		            CALL fLCD_Data      ;Write character to display  
6805 13				inc de  
6806 10 f9			djnz write_len_string  
6808 c9				ret  
6809			  
6809			; Some other things to do  
6809			;            LD   A, kLCD_Clear ;Display clear  
6809			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6809			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6809			;            LD   A, kLCD_On     ;Display on with no cursor  
6809			;            ;LD   A, kLCD_Off   ;Display off  
6809			;            CALL fLCD_Inst      ;Send instruction to display  
6809			;  
6809			;  
6809			;            halt  
6809			;  
6809			;  
6809			;MsgHello:   DB  "Hello World!",0  
6809			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6809			  
6809			; Custom characters 5 pixels wide by 8 pixels high  
6809			; Up to 8 custom characters can be defined  
6809			;BitMaps:      
6809			;; Character 0x00 = Battery icon  
6809			;            DB  01110b  
6809			;            DB  11011b  
6809			;            DB  10001b  
6809			;            DB  10001b  
6809			;            DB  11111b  
6809			;            DB  11111b  
6809			;            DB  11111b  
6809			;            DB  11111b  
6809			;; Character 0x01 = Bluetooth icon  
6809			;            DB  01100b  
6809			;            DB  01010b  
6809			;            DB  11100b  
6809			;            DB  01000b  
6809			;            DB  11100b  
6809			;            DB  01010b  
6809			;            DB  01100b  
6809			;            DB  00000b  
6809			;  
6809			  
6809			  
6809			; **********************************************************************  
6809			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6809			; **********************************************************************  
6809			;  
6809			; **  Written as a Small Computer Monitor App   
6809			; **  Version 0.1 SCC 2018-05-16  
6809			; **  www.scc.me.uk  
6809			;  
6809			; **********************************************************************  
6809			;  
6809			; This module provides support for alphanumeric LCD modules using with  
6809			; *  HD44780 (or compatible) controller  
6809			; *  5 x 7 pixel fonts  
6809			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6809			; *  Interface via six digital outputs to the display (see below)  
6809			;  
6809			; LCD module pinout:  
6809			;   1  Vss   0v supply  
6809			;   2  Vdd   5v supply  
6809			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6809			;   4  RS    High = data, Low = instruction  
6809			;   5  R/W   High = Read, Low = Write  
6809			;   6  E     Enable signal (active high)  
6809			;   7  DB0   Data bit 0  
6809			;   8  DB1   Data bit 1  
6809			;   9  DB2   Data bit 2  
6809			;  10  DB3   Data bit 3  
6809			;  11  DB4   Data bit 4  
6809			;  12  DB5   Data bit 5  
6809			;  13  DB6   Data bit 6  
6809			;  14  DB7   Data bit 7  
6809			;  15  A     Backlight anode (+)  
6809			;  16  K     Backlight cathode (-)  
6809			;  
6809			; This interfacing method uses 4-bit data mode and uses time delays  
6809			; rather than polling the display's ready status. As a result the   
6809			; interface only requires 6 simple output lines:  
6809			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6809			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6809			;   LCD DB4 = Microcomputer output port bit 4  
6809			;   LCD DB5 = Microcomputer output port bit 5  
6809			;   LCD DB6 = Microcomputer output port bit 6  
6809			;   LCD DB7 = Microcomputer output port bit 7  
6809			; Display's R/W is connected to 0v so it is always in write mode  
6809			; All 6 connections must be on the same port address <kLCDPrt>  
6809			; This method also allows a decent length of cable from micro to LCD  
6809			;  
6809			; **********************************************************************  
6809			;  
6809			; To include the code for any given function provided by this module,   
6809			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6809			; the parent source file.  
6809			; For example:  #REQUIRES   uHexPrefix  
6809			;  
6809			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6809			; in the parent source file.  
6809			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6809			;  
6809			; These are the function names provided by this module:  
6809			; fLCD_Init                     ;Initialise LCD  
6809			; fLCD_Inst                     ;Send instruction to LCD  
6809			; fLCD_Data                     ;Send data byte to LCD  
6809			; fLCD_Pos                      ;Position cursor  
6809			; fLCD_Str                      ;Display string  
6809			; fLCD_Def                      ;Define custom character  
6809			;  
6809			; **********************************************************************  
6809			;  
6809			; Requires SCMonAPI.asm to also be included in the project  
6809			;  
6809			  
6809			  
6809			; **********************************************************************  
6809			; **  Constants  
6809			; **********************************************************************  
6809			  
6809			; Constants that must be defined externally  
6809			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6809			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6809			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6809			;kLCDWidth: EQU 20             ;Width in characters  
6809			  
6809			; general line offsets in any frame buffer  
6809			  
6809			  
6809			display_row_1: equ 0  
6809			display_row_2: equ display_row_1+display_cols  
6809			display_row_3: equ display_row_2 + display_cols  
6809			display_row_4: equ display_row_3 + display_cols  
6809			;display_row_4_eol:   
6809			  
6809			  
6809			; Cursor position values for the start of each line  
6809			kLCD_Line1: EQU 0x00   
6809			kLCD_Line2: EQU 0x40    
6809			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
6809			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
6809			  
6809			; Instructions to send as A register to fLCD_Inst  
6809			kLCD_Clear: EQU 00000001b     ;LCD clear  
6809			kLCD_Off:   EQU 00001000b     ;LCD off  
6809			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6809			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6809			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6809			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6809			  
6809			; Constants used by this code module  
6809			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6809			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6809			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6809			  
6809			  
6809			  
6809			; **********************************************************************  
6809			; **  LCD support functions  
6809			; **********************************************************************  
6809			  
6809			; Initialise alphanumeric LCD module  
6809			; LCD control register codes:  
6809			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6809			;   N    0 = 1-line mode       1 = 2-line mode  
6809			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6809			;   D    0 = Display off       1 = Display on  
6809			;   C    0 = Cursor off        1 = Cursor on  
6809			;   B    0 = Blinking off      1 = Blinking on  
6809			;   ID   0 = Decrement mode    1 = Increment mode  
6809			;   SH   0 = Entire shift off  1 = Entire shift on  
6809 3e 28		fLCD_Init:  LD   A, 40  
680b cd c0 68		            CALL LCDDelay       ;Delay 40ms after power up  
680e			; For reliable reset set 8-bit mode - 3 times  
680e cd aa 68		            CALL WrFn8bit       ;Function = 8-bit mode  
6811 cd aa 68		            CALL WrFn8bit       ;Function = 8-bit mode  
6814 cd aa 68		            CALL WrFn8bit       ;Function = 8-bit mode  
6817			; Set 4-bit mode  
6817 cd a6 68		            CALL WrFn4bit       ;Function = 4-bit mode  
681a cd be 68		            CALL LCDDelay1      ;Delay 37 us or more  
681d			; Function set  
681d 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
681f cd 32 68		            CALL fLCD_Inst      ;2 line, display on  
6822			; Display On/Off control  
6822 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6824 cd 32 68		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6827			; Display Clear  
6827 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6829 cd 32 68		            CALL fLCD_Inst      ;Clear display  
682c			; Entry mode  
682c 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
682e cd 32 68		            CALL fLCD_Inst      ;Increment mode, shift off  
6831			; Display module now initialised  
6831 c9			            RET  
6832			; ok to here  
6832			  
6832			; Write instruction to LCD  
6832			;   On entry: A = Instruction byte to be written  
6832			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6832 f5			fLCD_Inst:  PUSH AF  
6833 f5			            PUSH AF  
6834 cd 46 68		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6837 f1			            POP  AF  
6838 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6839 17			            RLA  
683a 17			            RLA  
683b 17			            RLA  
683c cd 46 68		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
683f 3e 02		            LD   A, 2  
6841 cd c0 68		            CALL LCDDelay       ;Delay 2 ms to complete   
6844 f1			            POP  AF  
6845 c9			            RET  
6846 e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
6848 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
684a cb df		            SET  kLCDBitE, A  
684c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
684e cb 9f		            RES  kLCDBitE, A  
6850 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6852 c9			            RET  
6853			  
6853			  
6853			; Write data to LCD  
6853			;   On entry: A = Data byte to be written  
6853			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6853 f5			fLCD_Data:  PUSH AF  
6854 f5			            PUSH AF  
6855 cd 67 68		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
6858 f1			            POP  AF  
6859 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
685a 17			            RLA  
685b 17			            RLA  
685c 17			            RLA  
685d cd 67 68		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
6860 3e 96		            LD   A, 150  
6862 3d			Wait:      DEC  A              ;Wait a while to allow data   
6863 20 fd		            JR   NZ, Wait      ;  write to complete  
6865 f1			            POP  AF  
6866 c9			            RET  
6867 e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
6869 cb d7		            SET  kLCDBitRS, A  
686b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
686d cb df		            SET  kLCDBitE, A  
686f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6871 cb 9f		            RES  kLCDBitE, A  
6873 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6875 cb 97		            RES  kLCDBitRS, A  
6877 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6879 c9			            RET  
687a			  
687a			  
687a			; Position cursor to specified location  
687a			;   On entry: A = Cursor position  
687a			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
687a f5			fLCD_Pos:   PUSH AF  
687b f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
687d cd 32 68		            CALL fLCD_Inst      ;Write instruction to LCD  
6880 f1			            POP  AF  
6881 c9			            RET  
6882			  
6882			  
6882			; Output text string to LCD  
6882			;   On entry: DE = Pointer to null terminated text string  
6882			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6882 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6883 b7			            OR   A              ;Null terminator?  
6884 c8			            RET  Z              ;Yes, so finished  
6885 cd 53 68		            CALL fLCD_Data      ;Write character to display  
6888 13			            INC  DE             ;Point to next character  
6889 18 f7		            JR   fLCD_Str       ;Repeat  
688b c9					ret  
688c			  
688c			; Define custom character  
688c			;   On entry: A = Character number (0 to 7)  
688c			;             DE = Pointer to character bitmap data  
688c			;   On exit:  A = Next character number  
688c			;             DE = Next location following bitmap  
688c			;             BC HL IX IY I AF' BC' DE' HL' preserved  
688c			; Character is   
688c c5			fLCD_Def:   PUSH BC  
688d f5			            PUSH AF  
688e 07			            RLCA                ;Calculate location  
688f 07			            RLCA                ;  for bitmap data  
6890 07			            RLCA                ;  = 8 x CharacterNumber  
6891 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6893 cd 32 68		            CALL fLCD_Inst      ;Write instruction to LCD  
6896 06 00		            LD   B, 0  
6898 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
6899 cd 53 68		            CALL fLCD_Data      ;Write byte to display  
689c 13			            INC  DE             ;Point to next byte  
689d 04			            INC  B              ;Count bytes  
689e cb 58		            BIT  3, B           ;Finish all 8 bytes?  
68a0 28 f6		            JR   Z, Loop       ;No, so repeat  
68a2 f1			            POP  AF  
68a3 3c			            INC  A              ;Increment character number  
68a4 c1			            POP  BC  
68a5 c9			            RET  
68a6			  
68a6			  
68a6			; **********************************************************************  
68a6			; **  Private functions  
68a6			; **********************************************************************  
68a6			  
68a6			; Write function to LCD  
68a6			;   On entry: A = Function byte to be written  
68a6			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
68a6 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
68a8 18 02		            JR   WrFunc  
68aa 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
68ac f5			WrFunc:     PUSH AF  
68ad d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
68af cb df		            SET  kLCDBitE, A  
68b1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
68b3 cb 9f		            RES  kLCDBitE, A  
68b5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
68b7 3e 05		            LD   A, 5  
68b9 cd c0 68		            CALL LCDDelay       ;Delay 5 ms to complete  
68bc f1			            POP  AF  
68bd c9			            RET  
68be			  
68be			  
68be			; Delay in milliseconds  
68be			;   On entry: A = Number of milliseconds delay  
68be			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
68be 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
68c0 d5			LCDDelay:   PUSH DE  
68c1 5f			            LD   E, A           ;Delay by 'A' ms  
68c2 16 00		            LD   D, 0  
68c4 cd 21 0b		            CALL aDelayInMS  
68c7 d1			            POP  DE  
68c8 c9			            RET  
68c9			  
68c9			  
68c9			  
68c9			  
68c9			; eof  
68c9			  
# End of file firmware_lcd_4x20.asm
68c9			include "firmware_key_4x4.asm" 
68c9			  
68c9			  
68c9			; bit mask for each scan column and row for teing the matrix  
68c9			  
68c9			; out   
68c9 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
68cd			; in  
68cd 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
68d1			  
68d1			; row/col to character map  
68d1			  
68d1			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
68d1			;    
68d1			  
68d1			; physical key matrix map to face of key  
68d1			  
68d1			  
68d1			;      	1	2	3	A  
68d1			;   	abc”	def&	ghi$	s1  
68d1			;			  
68d1			;	4	5	6	B  
68d1			; 	jkl,	mno.	pqr:	s2  
68d1			;			  
68d1			; 	7	8	9	C  
68d1			;	stu;	vwx@	yz?!	s3  
68d1			;			  
68d1			; 	*	0	#	D  
68d1			; 	shift lck '	Space < >	Enter ( )	s4  
68d1			;       tab bs 		  
68d1			  
68d1			  
68d1			  
68d1			  
68d1			key_init:  
68d1			  
68d1			; SCMonAPI functions used  
68d1			  
68d1			; Alphanumeric LCD functions used  
68d1			; no need to specify specific functions for this module  
68d1			  
68d1			  
68d1 3e cf		            LD   A, 11001111b  
68d3 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
68d5			;            LD   A, 00000000b  
68d5 3e 0f		            LD   A, 00001111b  
68d7 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
68d9			  
68d9			  
68d9				; TODO Configure cursor shapes  
68d9			  
68d9				; Load cursor shapes   
68d9 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
68db 11 eb 68		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
68de 06 02		            LD   B, 2           ;Number of characters to define  
68e0 cd 8c 68		.DefLoop:   CALL fLCD_Def       ;Define custom character  
68e3 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
68e5			  
68e5 3e 01				ld a, 1  
68e7 32 4d fd			ld (cursor_shape),a  
68ea c9				ret  
68eb			  
68eb			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
68eb			; Up to 8 custom characters can be defined  
68eb			.cursor_shapes:      
68eb			;; Character 0x00 = Normal  
68eb 1f			            DB  11111b  
68ec 1f			            DB  11111b  
68ed 1f			            DB  11111b  
68ee 1f			            DB  11111b  
68ef 1f			            DB  11111b  
68f0 1f			            DB  11111b  
68f1 1f			            DB  11111b  
68f2 1f			            DB  11111b  
68f3			;; Character 0x01 = Modifier  
68f3 1f			            DB  11111b  
68f4 1b			            DB  11011b  
68f5 1b			            DB  11011b  
68f6 1b			            DB  11011b  
68f7 1b			            DB  11011b  
68f8 1f			            DB  11111b  
68f9 1b			            DB  11011b  
68fa 1f			            DB  11111b  
68fb			  
68fb			  
68fb			  
68fb			  
68fb			; Display custom character 0  
68fb			;            LD   A, kLCD_Line1+14  
68fb			;            CALL fLCD_Pos       ;Position cursor to location in A  
68fb			;            LD   A, 0  
68fb			;            CALL fLCD_Data      ;Write character in A at cursor  
68fb			  
68fb			; Display custom character 1  
68fb			;            LD   A, kLCD_Line2+14  
68fb			;            CALL fLCD_Pos      ;Position cursor to location in A  
68fb			;            LD   A, 1  
68fb			;            CALL fLCD_Data     ;Write character in A at cursor  
68fb			  
68fb			; keyboard scanning   
68fb			  
68fb			  
68fb			; key_rows: equ 4  
68fb			; key_cols: equ 4  
68fb			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
68fb			  
68fb			; key_scanr: equ key_row_bitmask  
68fb			; key_scanc: equ key_col_bitmask  
68fb			  
68fb			; key_char_map: equ key_map  
68fb			  
68fb			  
68fb			  
68fb			; character in from keyboard  
68fb			  
68fb ..			.matrix_to_char: db "D#0*C987B654A321"  
690b			  
690b			  
690b			; map the physical key to a char dependant on state  
690b			  
690b			.key_map_fa:   
690b			  
690b ..					db 'D'  
690c 0d					db KEY_CR    ; cr  
690d ..					db ' '  
690e 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
690f ..					db 'C'  
6910 ..					db 'y'  
6911 ..					db 'v'  
6912 ..					db 's'  
6913 ..					db 'B'  
6914 ..					db 'p'  
6915 ..					db 'm'  
6916 ..					db 'j'  
6917 ..					db 'A'  
6918 ..					db 'g'  
6919 ..					db 'd'  
691a ..					db 'a'  
691b			  
691b			.key_map_fb:  
691b			  
691b ..					db 'A'  
691c ..					db '+'   
691d ..					db '<'  
691e ..					db  "'"    
691f			  
691f ..					db 'A'  
6920 ..					db 'z'  
6921 ..					db 'w'  
6922 ..					db 't'  
6923 ..					db 'A'  
6924 ..					db 'q'  
6925 ..					db 'n'  
6926 ..					db 'k'  
6927 ..					db 'A'  
6928 ..					db 'h'  
6929 ..					db 'e'  
692a ..			 		db 'b'  
692b			  
692b			.key_map_fc:   
692b			  
692b			  
692b ..					db 'A'  
692c ..					db '-'   
692d ..					db '>'  
692e ..					db  '='   	  
692f ..					db 'A'  
6930 ..					db '?'  
6931 ..					db 'x'  
6932 ..					db 'u'  
6933 ..					db 'A'  
6934 ..					db 'r'  
6935 ..					db 'o'  
6936 ..					db 'l'  
6937 ..					db 'A'  
6938 ..					db 'i'  
6939 ..					db 'f'  
693a ..					db 'c'  
693b			  
693b				  
693b			.key_map_fd:  
693b			  
693b ..					db 'A'  
693c ..					db '/'   
693d ..					db '%'   
693e 08					db KEY_BS  ; back space  
693f ..					db 'A'  
6940 ..					db '!'  
6941 ..					db '@'  
6942 ..					db ';'  
6943 ..					db 'A'  
6944 ..					db ':'  
6945 ..					db '.'  
6946 ..					db ','  
6947 ..					db 'A'  
6948 ..					db '$'  
6949 ..					db '&'  
694a ..				 	db '"'  
694b			  
694b					  
694b				  
694b			  
694b			; add cin and cin_wait  
694b			  
694b cd 5c 69		cin_wait: 	call cin  
694e fe 00			cp 0  
6950 28 f9			jr z, cin_wait   ; block until key press  
6952			  
6952 f5				push af   ; save key pressed  
6953			  
6953 cd 5c 69		.cin_wait1:	call cin  
6956 fe 00			cp 0  
6958 20 f9			jr nz, .cin_wait1  	; wait for key release  
695a			  
695a f1				pop af   ; get key  
695b c9				ret  
695c			  
695c			  
695c cd 6d 69		cin: 	call .mtoc  
695f			  
695f				; no key held  
695f fe 00			cp 0  
6961 c8				ret z  
6962			  
6962				; stop key bounce  
6962			  
6962			;	ld (key_held),a		 ; save it  
6962 47				ld b, a  
6963			  
6963 c5			.cina1:	push bc  
6964 cd 6d 69			call .mtoc  
6967 c1				pop bc  
6968 b8				cp b  
6969 28 f8			jr z, .cina1  
696b 78				ld a,b		  
696c c9				ret  
696d			  
696d			; detect keyboard modifier key press and apply new overlay to the face key held  
696d			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
696d			  
696d			;.cin_map_modifier:   
696d			;	ld a, (hl)  
696d			;	and 255  
696d			;	ret NZ		; modifier key not flagged  
696d			;  
696d			;	; get key face  
696d			;  
696d			;	ld b,(key_face_held)  
696d			;  
696d			;	ld b, key_cols * key_rows  
696d			;  
696d			;	push de  
696d			;	pop hl  
696d			;  
696d			;.mmod1: ld a,(hl)   ; get map test  
696d			;	cp b  
696d			;	jr z, .mmod2  
696d			;  
696d			;  
696d			;  
696d			;.mmod2: inc hl    ;   
696d			;  
696d			;	  
696d			;  
696d			;	  
696d			;  
696d			;	ld hl,key_actual_pressed  
696d			;	ld (hl),a,  
696d			;	ret  
696d			  
696d				  
696d			  
696d			; map matrix key held to char on face of key  
696d			  
696d			.mtoc:  
696d			  
696d			  
696d				; TODO optimise the code....  
696d			  
696d			; scan keyboard row 1  
696d 3e 80			ld a, 128  
696f 21 d3 fe			ld hl, keyscan_table  
6972 cd 54 6a			call .rowscan  
6975			  
6975				   
6975			  
6975 3e 40			ld a, 64  
6977 21 d7 fe			ld hl, keyscan_table+key_cols  
697a cd 54 6a			call .rowscan  
697d			  
697d			  
697d			  
697d			  
697d 3e 20			ld a, 32  
697f 21 db fe			ld hl, keyscan_table+(key_cols*2)  
6982 cd 54 6a			call .rowscan  
6985			  
6985			  
6985			  
6985 3e 10			ld a, 16  
6987 21 df fe			ld hl, keyscan_table+(key_cols*3)  
698a cd 54 6a			call .rowscan  
698d			  
698d			  
698d				; flag if key D is held down and remove from reporting  
698d 01 3b 69			ld bc, .key_map_fd    
6990 21 d3 fe			ld hl, keyscan_table  
6993 11 c5 fe			ld de, key_fd  
6996 cd e6 69			call .key_shift_hold  
6999 fe ff			cp 255  
699b 28 33			jr z, .cinmap  
699d				; flag if key C is held down and remove from reporting  
699d 01 2b 69			ld bc, .key_map_fc    
69a0 21 d7 fe			ld hl, keyscan_table+key_cols  
69a3 11 c6 fe			ld de, key_fc  
69a6 cd e6 69			call .key_shift_hold  
69a9 fe ff			cp 255  
69ab 28 23			jr z, .cinmap  
69ad				; flag if key B is held down and remove from reporting  
69ad 01 1b 69			ld bc, .key_map_fb    
69b0 21 db fe			ld hl, keyscan_table+(key_cols*2)  
69b3 11 c7 fe			ld de, key_fb  
69b6 cd e6 69			call .key_shift_hold  
69b9 fe ff			cp 255  
69bb 28 13			jr z, .cinmap  
69bd				; flag if key A is held down and remove from reporting  
69bd 01 0b 69			ld bc, .key_map_fa    
69c0 21 df fe			ld hl, keyscan_table+(key_cols*3)  
69c3 11 c8 fe			ld de, key_fa  
69c6 cd e6 69			call .key_shift_hold  
69c9 fe ff			cp 255  
69cb 28 03			jr z, .cinmap  
69cd			  
69cd 11 fb 68			ld de, .matrix_to_char  
69d0			  
69d0			  
69d0			.cinmap:   
69d0				if DEBUG_KEY  
69d0			            LD   A, kLCD_Line4  
69d0			            CALL fLCD_Pos       ;Position cursor to location in A  
69d0					push de  
69d0			            LD   DE, keyscan_table  
69d0			            CALL fLCD_Str       ;Display string pointed to by DE  
69d0					pop de  
69d0				endif  
69d0			  
69d0				; scan key matrix table for any held key  
69d0			  
69d0				; de holds either the default matrix or one selected above  
69d0			  
69d0 21 d3 fe			ld hl, keyscan_table  
69d3 06 10			ld b,key_cols*key_rows  
69d5			  
69d5 7e			.cin1:	ld a,(hl)  
69d6 fe 23			cp '#'  
69d8 28 08			jr z, .cinhit  
69da 23				inc hl  
69db 13				inc de  
69dc 05				dec b  
69dd 20 f6			jr nz, .cin1  
69df				; no key found held  
69df 3e 00			ld a,0  
69e1 c9				ret  
69e2 d5			.cinhit: push de  
69e3 e1				pop hl  
69e4 7e				ld a,(hl)  
69e5 c9				ret  
69e6			  
69e6			; flag a control key is held   
69e6			; hl is key pin, de is flag indicator  
69e6			  
69e6			.key_shift_hold:  
69e6 c5				push bc  
69e7 3e 01			ld a, 1  
69e9 32 4d fd			ld (cursor_shape),a  
69ec 06 00			ld b, 0  
69ee 7e				ld a, (hl)  
69ef fe 2e			cp '.'  
69f1 28 0a			jr z, .key_shift1  
69f3 06 ff			ld b, 255  
69f5 3e 2b			ld a, '+'    ; hide key from later scans  
69f7 77				ld (hl),a  
69f8 3e 02			ld a, 2  
69fa 32 4d fd			ld (cursor_shape),a  
69fd			.key_shift1:  
69fd				; write flag indicator  
69fd 78				ld a,b  
69fe 12				ld (de),a  
69ff			  
69ff d1				pop de    ; de now holds the key map ptr  
6a00 c9				ret  
6a01			  
6a01				  
6a01				  
6a01			  
6a01			  
6a01			  
6a01			  
6a01			  
6a01			  
6a01			  
6a01			  
6a01			  
6a01			  
6a01 c9				ret  
6a02			  
6a02			;	push hl  
6a02			;	push de  
6a02			;	push bc  
6a02			;	call keyscan  
6a02			;	; map key matrix to ascii value of key face  
6a02			;  
6a02			;	ld hl, key_face_map  
6a02			;	ld de, keyscan_table  
6a02			;  
6a02			;	; get how many keys to look at  
6a02			;	ld b, keyscan_table_len  
6a02			;	  
6a02			;  
6a02			;	; at this stage fall out on first key hit  
6a02			;	; TODO handle multiple key press  
6a02			;  
6a02			;map1:	ld a,(hl)  
6a02			;	cp '#'  
6a02			;	jr z, keyhit  
6a02			;	inc hl  
6a02			;	inc de  
6a02			;	dec b  
6a02			;	jr nz, map1  
6a02			;nohit:	ld a, 0  
6a02			;	jr keydone  
6a02			;keyhit: push de  
6a02			;	pop hl  
6a02			;	ld a,(hl)  
6a02			;keydone:  
6a02			;	push bc  
6a02			;	push de  
6a02			; 	push hl  
6a02			;	ret   
6a02			;  
6a02			  
6a02			  
6a02			  
6a02			  
6a02			; scan physical key matrix  
6a02			  
6a02			  
6a02			;keyscan:  
6a02			;  
6a02			;; for each key_row use keyscanr bit mask for out  
6a02			;; then read in for keyscanc bitmask  
6a02			;; save result of row scan to keyscantable  
6a02			;  
6a02			;; scan keyboard row 1  
6a02			;  
6a02			;	ld b, key_rows  
6a02			;	ld hl, key_scanr  
6a02			;	ld de, keyscan_table  
6a02			;  
6a02			;rowloop:  
6a02			;  
6a02			;	ld a,(hl)		; out bit mask to energise keyboard row  
6a02			;	call rowscan  
6a02			;	inc hl  
6a02			;	dec b  
6a02			;	jr nz, rowloop  
6a02			;  
6a02			;	ret  
6a02			;  
6a02			;  
6a02			;; pass a out bitmask, b row number  
6a02			;arowscan:   
6a02			;	push bc  
6a02			;  
6a02			;	ld d, b  
6a02			;  
6a02			;	; calculate buffer location for this row  
6a02			;  
6a02			;	ld hl, keyscan_table	  
6a02			;kbufr:  ld e, key_cols  
6a02			;kbufc:	inc hl  
6a02			;	dec e  
6a02			;	jr nz, kbufc  
6a02			;	dec d  
6a02			;	jr nz, kbufr  
6a02			;  
6a02			;	; energise row and read columns  
6a02			;  
6a02			;	out (portbdata),a  
6a02			;	in a,(portbdata)  
6a02			;	ld c,a  
6a02			;  
6a02			;  
6a02			;	; save buffer loc  
6a02			;  
6a02			;	ld (keybufptr), hl  
6a02			;  
6a02			;	ld hl, key_scanc  
6a02			;	ld d, key_cols  
6a02			;  
6a02			;	; for each column check each bit mask  
6a02			;  
6a02			;colloop:  
6a02			;	  
6a02			;  
6a02			;	; reset flags for the row   
6a02			;  
6a02			;	ld b,'.'  
6a02			;	and (hl)  
6a02			;	jr z, maskskip  
6a02			;	ld b,'#'  
6a02			;maskskip:  
6a02			;	; save  key state  
6a02			;	push hl  
6a02			;	ld hl, (keybufptr)  
6a02			;	ld (hl), b  
6a02			;	inc hl  
6a02			;	ld (keybufptr), hl  
6a02			;  
6a02			;	; move to next bit mask  
6a02			;	pop hl  
6a02			;	inc hl  
6a02			;  
6a02			;	dec d  
6a02			;	jr nz, colloop  
6a02			;  
6a02			;	ret  
6a02			;  
6a02			;  
6a02			;;  
6a02			; lcd functions  
6a02			;  
6a02			;  
6a02			  
6a02			;if DEBUG_KEY_MATRIX  
6a02			  
6a02			; test function to display hardware view of matrix state  
6a02			  
6a02			matrix:  
6a02			  
6a02			  
6a02			  
6a02			; scan keyboard row 1  
6a02 3e 80			ld a, 128  
6a04 21 f8 fe			ld hl, keyscan_table_row1  
6a07 cd 54 6a			call .rowscan  
6a0a			  
6a0a 3e 40			ld a, 64  
6a0c 21 f3 fe			ld hl, keyscan_table_row2  
6a0f cd 54 6a			call .rowscan  
6a12			  
6a12 3e 20			ld a, 32  
6a14 21 ee fe			ld hl, keyscan_table_row3  
6a17 cd 54 6a			call .rowscan  
6a1a			  
6a1a 3e 10			ld a, 16  
6a1c 21 e9 fe			ld hl, keyscan_table_row4  
6a1f cd 54 6a			call .rowscan  
6a22			  
6a22			; Display text on first line  
6a22 3e 00		            LD   A, kLCD_Line1  
6a24 cd 7a 68		            CALL fLCD_Pos       ;Position cursor to location in A  
6a27 11 f8 fe		            LD   DE, keyscan_table_row1  
6a2a			            ;LD   DE, MsgHello  
6a2a cd 82 68		            CALL fLCD_Str       ;Display string pointed to by DE  
6a2d			  
6a2d			; Display text on second line  
6a2d 3e 40		            LD   A, kLCD_Line2  
6a2f cd 7a 68		            CALL fLCD_Pos       ;Position cursor to location in A  
6a32 11 f3 fe		            LD   DE, keyscan_table_row2  
6a35 cd 82 68		            CALL fLCD_Str       ;Display string pointed to by DE  
6a38 3e 14		            LD   A, kLCD_Line3  
6a3a cd 7a 68		            CALL fLCD_Pos       ;Position cursor to location in A  
6a3d 11 ee fe		            LD   DE, keyscan_table_row3  
6a40 cd 82 68		            CALL fLCD_Str       ;Display string pointed to by DE  
6a43 3e 54		            LD   A, kLCD_Line4  
6a45 cd 7a 68		            CALL fLCD_Pos       ;Position cursor to location in A  
6a48 11 e9 fe		            LD   DE, keyscan_table_row4  
6a4b cd 82 68		            CALL fLCD_Str       ;Display string pointed to by DE  
6a4e			  
6a4e cd 30 0b			call delay250ms  
6a51 c3 02 6a			jp matrix  
6a54			  
6a54			; pass de as row display flags  
6a54			.rowscan:   
6a54 d3 c1			out (portbdata),a  
6a56 db c1			in a,(portbdata)  
6a58 4f				ld c,a  
6a59				; reset flags for the row   
6a59 06 2e			ld b,'.'  
6a5b e6 01			and 1  
6a5d 28 02			jr z, .p1on  
6a5f 06 23			ld b,'#'  
6a61			.p1on:  
6a61 70				ld (hl), b  
6a62 23				inc hl  
6a63			  
6a63 06 2e			ld b,'.'  
6a65 79				ld a,c  
6a66 e6 02			and 2  
6a68			;	bit 0,a  
6a68 28 02			jr z, .p2on  
6a6a 06 23			ld b,'#'  
6a6c			.p2on:  
6a6c 70				ld (hl), b  
6a6d 23				inc hl  
6a6e			;  
6a6e 06 2e			ld b,'.'  
6a70 79				ld a,c  
6a71 e6 04			and 4  
6a73			;;	bit 0,a  
6a73 28 02			jr z, .p3on  
6a75 06 23			ld b,'#'  
6a77			.p3on:  
6a77 70				ld (hl), b  
6a78 23				inc hl  
6a79			;;  
6a79 06 2e			ld b,'.'  
6a7b			;;	bit 0,a  
6a7b 79				ld a,c  
6a7c e6 08			and 8  
6a7e 28 02			jr z, .p4on  
6a80 06 23			ld b,'#'  
6a82			.p4on:  
6a82 70				ld (hl), b  
6a83 23				inc hl  
6a84			  
6a84			; zero term  
6a84 06 00			ld b,0  
6a86 70				ld (hl), b  
6a87			  
6a87 c9			.rscandone: ret  
6a88			  
6a88			  
6a88			  
6a88			;endif  
6a88			  
6a88			  
6a88			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
6a88
