# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 aa 16			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 0   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext+(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ os_input  
0003			os_new_parse_len: equ os_new_malloc + 2  
0003			os_new_word_len: equ os_new_parse_len + 2  
0003			os_new_work_ptr: equ os_new_word_len + 2  
0003			os_new_src_ptr: equ os_new_work_ptr + 2  
0003			os_new_exec: equ os_new_src_ptr + 2  
0003			os_new_exec_ptr: equ os_new_exec + 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ scratch - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 c3 fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 02 fb				ld hl, display_fb1  
000b 22 5e fa				ld (display_fb_active), hl  
000e			  
000e cd 8c 0a				call clear_display  
0011			  
0011 21 60 fa				ld hl, display_fb2  
0014 22 5e fa				ld (display_fb_active), hl  
0017			  
0017 cd 8c 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 53 fb				ld hl, display_fb0  
001d 22 5e fa				ld (display_fb_active), hl  
0020			  
0020 cd 8c 0a				call clear_display  
0023			  
0023			  
0023 cd 75 61				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd be 62			call key_init  
0029 cd c9 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd 5f 11				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f					call sound_init  
002f				endif  
002f			  
002f				; lcd test sequence  
002f					  
002f cd af 0a			call update_display  
0032 cd 3a 0a			call delay1s  
0035 3e 2b			ld a,'+'  
0037 cd 91 0a			call fill_display  
003a cd af 0a			call update_display  
003d cd 3a 0a			call delay1s  
0040 3e 2a			ld a,'*'  
0042 cd 91 0a			call fill_display  
0045 cd af 0a			call update_display  
0048 cd 3a 0a			call delay1s  
004b 3e 2d			ld a,'-'  
004d cd 91 0a			call fill_display  
0050 cd af 0a			call update_display  
0053 cd 3a 0a			call delay1s  
0056			  
0056			; boot splash screen  
0056			if display_cols == 20	  
0056 3e 00		        ld a, display_row_1    
0058			else  
0058			        ld a, display_row_1 +10   
0058			endif  
0058 11 89 00			ld de, bootmsg  
005b cd 9f 0a			call str_at_display  
005e cd af 0a			call update_display  
0061			  
0061			  
0061 cd 3a 0a			call delay1s  
0064 cd 3a 0a			call delay1s  
0067			if display_cols == 20	  
0067 3e 2a		            LD   A, display_row_3+2  
0069			else  
0069			            LD   A, display_row_3+12  
0069			endif  
0069 11 9e 00			ld de, bootmsg1  
006c cd 9f 0a			call str_at_display  
006f cd af 0a			call update_display  
0072 cd 3a 0a			call delay1s  
0075 cd 3a 0a			call delay1s  
0078			  
0078			;	ld a, display_row_4+3  
0078			;	ld de, bootmsg2  
0078			;	call str_at_display  
0078			;	call update_display  
0078			;	call delay1s  
0078			;	call delay1s  
0078			  
0078			; debug mark setup  
0078			  
0078 3e 5f		ld a, '_'  
007a 32 bd fb		ld (debug_mark),a  
007d 32 be fb		ld (debug_mark+1),a  
0080 32 bf fb		ld (debug_mark+2),a  
0083 3e 00		ld a,0  
0085 32 c0 fb		ld (debug_mark+3),a  
0088			  
0088 c9					ret  
0089			  
0089			  
0089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
009e .. 00		bootmsg1:	db "by Kevin Groves",0  
00ae			;bootmsg2:	db "Firmware v0.1",0  
00ae			  
00ae			; a 4x20 lcd  
00ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00ae			  
00ae			;if display_cols == 20  
00ae			;	include "firmware_lcd_4x20.asm"  
00ae			;endif  
00ae			  
00ae			;if display_cols == 40  
00ae			;	include "firmware_lcd_4x40.asm"  
00ae			;endif  
00ae			  
00ae			;  
00ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00ae			; TODO abstract the bit bang video out interface for dual display  
00ae			; TODO wire video out to tx pin on rc2014 bus  
00ae			  
00ae			; must supply cin, and cin_wait for low level hardware abstraction   
00ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00ae			; test scancode  
00ae			  
00ae			;;;;;  
00ae			;;;  
00ae			; Moved out to mini and maxi versions  
00ae			;  
00ae			; include "firmware_key_4x4.asm"  
00ae			; using existing 4 wire x 4 resistor array for input  
00ae			;include "firmware_key_4x10.asm"  
00ae			; need to mod the board for 5 rows due to resistor array  
00ae			;include "firmware_key_5x10.asm"  
00ae			  
00ae			; storage hardware interface  
00ae			  
00ae			; use microchip serial eeprom for storage  
00ae			  
00ae			  
00ae			if STORAGE_SE  
00ae				include "firmware_spi.asm"  
00ae			; my spi protocol (used by storage) 
00ae			 
00ae			; SPI pins 
00ae			 
00ae			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00ae			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00ae			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00ae			 
00ae			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00ae			; chip pin 4 gnd 
00ae			 
00ae			 
00ae			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00ae			SPI_CE1: equ 1      ;    port a1 pin 14  
00ae			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00ae			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00ae			SPI_CE4: equ 4      ; port a4     pin 10 
00ae			 
00ae			; active low AND masks 
00ae			 
00ae			;SPI_CE0_MASK: equ    255-1 
00ae			;SPI_CE1_MASK: equ   255-2 
00ae			;SPI_CE2_MASK: equ   255-4 
00ae			;SPI_CE3_MASK: equ   255-8 
00ae			;SPI_CE4_MASK: equ   255-16 
00ae			SPI_CE_HIGH:  equ 255 
00ae			 
00ae			 
00ae			 
00ae			 
00ae			; TODO store port id for spi device ie dev c 
00ae			; TODO store pin for SO 
00ae			; TODO store pin for SI 
00ae			; TODO store pin for SCLK 
00ae			 
00ae			; 
00ae			 
00ae			; ensure that spi bus is in a stable state with default pins  
00ae			 
00ae			se_stable_spi:   
00ae			 
00ae				 ; set DI high, CE high , SCLK low 
00ae				;ld a, SPI_DI | SPI_CE0 
00ae 3e 07			ld a, SPI_DI  
00b0 cd 84 01			call spi_ce_high 
00b3 d3 80			 out (storage_adata),a 
00b5 32 e3 f9			ld (spi_portbyte),a 
00b8			 
00b8				if DEBUG_SPI 
00b8					push hl 
00b8					ld l, a 
00b8					DMARK "SPI" 
00b8					CALLMONITOR 
00b8					pop hl 
00b8				endif 
00b8 c9				ret 
00b9			 
00b9			; byte to send in a 
00b9			 
00b9			spi_send_byte: 
00b9				; save byte to send for bit mask shift out 
00b9 4f			        ld c,a 
00ba 3a e3 f9			ld a,(spi_portbyte) 
00bd				  
00bd				; clock out	each bit of the byte msb first 
00bd			 
00bd 06 08			ld b, 8 
00bf			.ssb1: 
00bf				; clear so bit  
00bf cb bf			res SPI_DI, a 
00c1 cb 11			rl c 
00c3				; if bit 7 is set then carry is set 
00c3 30 02			jr nc, .ssb2 
00c5 cb ff			set SPI_DI,a 
00c7			.ssb2:  ; output bit to ensure it is stable 
00c7 d3 80			out (storage_adata),a 
00c9 00				nop 
00ca				; clock bit high 
00ca cb ef			set SPI_SCLK,a 
00cc d3 80			out (storage_adata),a 
00ce 00				nop 
00cf				; then low 
00cf cb af			res SPI_SCLK,a 
00d1 d3 80			out (storage_adata),a 
00d3 00				nop 
00d4 10 e9			djnz .ssb1 
00d6			 
00d6 32 e3 f9			ld (spi_portbyte),a 
00d9 c9				ret 
00da			 
00da			; TODO low level get byte into A on spi 
00da			 
00da			spi_read_byte:  
00da			 
00da				; save byte to send for bit mask shift out 
00da 0e 00		    ld c,0 
00dc 3a e3 f9			ld a,(spi_portbyte) 
00df				  
00df				; clock out	each bit of the byte msb first 
00df			 
00df			 
00df				; clock bit high 
00df cb ef			set SPI_SCLK,a 
00e1 d3 80			out (storage_adata),a 
00e3 00				nop 
00e4			 
00e4			    ; read DO  
00e4			 
00e4 cb f9		    set 7,c 
00e6 db 80			in a,(storage_adata) 
00e8 cb 77		    bit SPI_DO,a 
00ea 20 02		    jr nz, .b7 
00ec cb b9		    res 7,c 
00ee			.b7: 
00ee				; then low 
00ee cb af			res SPI_SCLK,a 
00f0 d3 80			out (storage_adata),a 
00f2 00				nop 
00f3			     
00f3			 
00f3				; clock bit high 
00f3 cb ef			set SPI_SCLK,a 
00f5 d3 80			out (storage_adata),a 
00f7 00				nop 
00f8			 
00f8			    ; read DO  
00f8			 
00f8 cb f1		    set 6,c 
00fa db 80			in a,(storage_adata) 
00fc cb 77		    bit SPI_DO,a 
00fe 20 02		    jr nz, .b6 
0100 cb b1		    res 6,c 
0102			.b6: 
0102				; then low 
0102 cb af			res SPI_SCLK,a 
0104 d3 80			out (storage_adata),a 
0106 00				nop 
0107			 
0107				; clock bit high 
0107 cb ef			set SPI_SCLK,a 
0109 d3 80			out (storage_adata),a 
010b 00				nop 
010c			 
010c			 
010c			    ; read DO  
010c			 
010c cb e9		    set 5,c 
010e db 80			in a,(storage_adata) 
0110 cb 77		    bit SPI_DO,a 
0112 20 02		    jr nz, .b5 
0114 cb a9		    res 5,c 
0116			.b5: 
0116				; then low 
0116 cb af			res SPI_SCLK,a 
0118 d3 80			out (storage_adata),a 
011a 00				nop 
011b				; clock bit high 
011b cb ef			set SPI_SCLK,a 
011d d3 80			out (storage_adata),a 
011f 00				nop 
0120			 
0120			    ; read DO  
0120			 
0120 cb e1		    set 4,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b4 
0128 cb a1		    res 4,c 
012a			.b4: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f				; clock bit high 
012f cb ef			set SPI_SCLK,a 
0131 d3 80			out (storage_adata),a 
0133 00				nop 
0134			 
0134			    ; read DO  
0134			 
0134 cb d9		    set 3,c 
0136 db 80			in a,(storage_adata) 
0138 cb 77		    bit SPI_DO,a 
013a 20 02		    jr nz, .b3 
013c cb 99		    res 3,c 
013e			.b3: 
013e				; then low 
013e cb af			res SPI_SCLK,a 
0140 d3 80			out (storage_adata),a 
0142 00				nop 
0143				; clock bit high 
0143 cb ef			set SPI_SCLK,a 
0145 d3 80			out (storage_adata),a 
0147 00				nop 
0148			 
0148			    ; read DO  
0148			 
0148 cb d1		    set 2,c 
014a db 80			in a,(storage_adata) 
014c cb 77		    bit SPI_DO,a 
014e 20 02		    jr nz, .b2 
0150 cb 91		    res 2,c 
0152			.b2: 
0152				; then low 
0152 cb af			res SPI_SCLK,a 
0154 d3 80			out (storage_adata),a 
0156 00				nop 
0157				; clock bit high 
0157 cb ef			set SPI_SCLK,a 
0159 d3 80			out (storage_adata),a 
015b 00				nop 
015c			 
015c			    ; read DO  
015c			 
015c cb c9		    set 1,c 
015e db 80			in a,(storage_adata) 
0160 cb 77		    bit SPI_DO,a 
0162 20 02		    jr nz, .b1 
0164 cb 89		    res 1,c 
0166			.b1: 
0166				; then low 
0166 cb af			res SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b				; clock bit high 
016b cb ef			set SPI_SCLK,a 
016d d3 80			out (storage_adata),a 
016f 00				nop 
0170			 
0170			    ; read DO  
0170			 
0170 cb c1		    set 0,c 
0172 db 80			in a,(storage_adata) 
0174 cb 77		    bit SPI_DO,a 
0176 20 02		    jr nz, .b0 
0178 cb 81		    res 0,c 
017a			.b0: 
017a				; then low 
017a cb af			res SPI_SCLK,a 
017c d3 80			out (storage_adata),a 
017e 00				nop 
017f			 
017f			 
017f 32 e3 f9			ld (spi_portbyte),a 
0182			 
0182			    ; return byte 
0182 79			    ld a,c 
0183			 
0183			 
0183 c9				ret 
0184			 
0184			 
0184			 
0184			spi_ce_high: 
0184			 
0184				if DEBUG_SPI_HARD_CE0 
0184			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0184					ret 
0184			 
0184				endif 
0184			 
0184			 
0184 f5				push af 
0185			 
0185				; send direct ce to port b 
0185 3e ff			ld a, 255 
0187 d3 81			out (storage_bdata), a 
0189			 
0189 f1				pop af 
018a			 
018a				; for port a that shares with spi lines AND the mask 
018a			  
018a				if DEBUG_SPI 
018a					push hl 
018a					ld h, a 
018a				endif 
018a			;	ld c, SPI_CE_HIGH 
018a			;	and c 
018a cb c7			set SPI_CE0, a 
018c cb cf			set SPI_CE1, a 
018e cb d7			set SPI_CE2, a 
0190 cb df			set SPI_CE3, a 
0192 cb e7			set SPI_CE4, a 
0194			 
0194				if DEBUG_SPI 
0194					ld l, a 
0194					DMARK "CEh" 
0194					CALLMONITOR 
0194					pop hl 
0194				endif 
0194 c9				ret 
0195			 
0195			 
0195			spi_ce_low: 
0195			 
0195				if DEBUG_SPI_HARD_CE0 
0195			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0195					ret 
0195			 
0195				endif 
0195			 
0195 c5				push bc 
0196 f5				push af 
0197			 
0197				; send direct ce to port b 
0197 3a e5 f9			ld a, (spi_cartdev) 
019a d3 81			out (storage_bdata), a 
019c			 
019c			 
019c			 
019c				; for port a that shares with spi lines AND the mask 
019c			 
019c 3a e2 f9			ld a, (spi_device)  
019f 4f				ld c, a 
01a0			 
01a0 f1				pop af 
01a1			 
01a1				; detect CEx 
01a1			 
01a1				if DEBUG_SPI 
01a1					push hl 
01a1					ld h, a 
01a1				endif 
01a1			 
01a1 cb 41			bit SPI_CE0, c 
01a3 20 04			jr nz, .cel1 
01a5 cb 87			res SPI_CE0, a 
01a7 18 1e			jr .celn 
01a9			.cel1: 
01a9 cb 49			bit SPI_CE1, c 
01ab 20 04			jr nz, .cel2 
01ad cb 8f			res SPI_CE1, a 
01af 18 16			jr .celn 
01b1			.cel2: 
01b1 cb 51			bit SPI_CE2, c 
01b3 20 04			jr nz, .cel3 
01b5 cb 97			res SPI_CE2, a 
01b7 18 0e			jr .celn 
01b9			.cel3: 
01b9 cb 59			bit SPI_CE3, c 
01bb 20 04			jr nz, .cel4 
01bd cb 9f			res SPI_CE3, a 
01bf 18 06			jr .celn 
01c1			.cel4: 
01c1 cb 61			bit SPI_CE4, c 
01c3 20 02			jr nz, .celn 
01c5 cb a7			res SPI_CE4, a 
01c7			.celn: 
01c7			 
01c7			 
01c7			 
01c7			;	add c 
01c7			 
01c7				if DEBUG_SPI 
01c7					ld l, a 
01c7					DMARK "CEl" 
01c7					CALLMONITOR 
01c7					pop hl 
01c7				endif 
01c7 c1				pop bc 
01c8 c9				ret 
01c9			 
01c9			 
01c9			 
01c9			; eof 
01c9			 
01c9			 
01c9			 
01c9			 
01c9			 
# End of file firmware_spi.asm
01c9				include "firmware_seeprom.asm"  
01c9			; 
01c9			; persisent storage interface via microchip serial eeprom 
01c9			 
01c9			; port a pio 2 
01c9			; pa 7 - si 
01c9			; pa 6 - sclk  
01c9			; pa 5 - so 
01c9			; pa 4 - cs 
01c9			; pa 3 - cs 
01c9			; pa 2 - cs 
01c9			; pa 1 - cs 
01c9			; pa 0 - cs 
01c9			; 
01c9			; TODO get block 
01c9			; TODO save block 
01c9			; TODO load file 
01c9			; TODO save file 
01c9			; TODO get dir  
01c9			 
01c9			;  
01c9			storage_adata: equ Device_C    ; device c port a - onboard storage 
01c9			storage_actl: equ Device_C+2     ; device c port a 
01c9			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01c9			storage_bctl: equ Device_C+3     ; device c port b 
01c9			 
01c9			 
01c9			; TODO move these to hardware driver file 
01c9			 
01c9			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01c9			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01c9			; storage bank file system format 
01c9			; 
01c9			; first page of bank: 
01c9			; 	addr 0 - status check 
01c9			;       addr 1 - write protect flag 
01c9			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01c9			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01c9			;         TODO see if scanning whole of for available next file id is fast enough 
01c9			;	addr 4 > zero term string of bank label 
01c9			; 
01c9			;        
01c9			;  
01c9			; first page of any file: 
01c9			;      byte 0 - file id  
01c9			;      byte 1-17 - fixed file name  
01c9			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01c9			; 
01c9			; other pages of any file: 
01c9			;      byte 0 - file id 
01c9			;      byte 1> - file data 
01c9			; 
01c9			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01c9			;  
01c9			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01c9			 
01c9			 
01c9			;storage_so_bit: 5 
01c9			;storage_si_bit: 7 
01c9			;storage_sclk_bit: 6 
01c9			  
01c9			 
01c9			; init storage pio 
01c9			 
01c9			storage_init: 
01c9			 
01c9 3e cf		            LD   A, 11001111b 
01cb d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01cd 3e 00		            LD   A, 00000000b 
01cf cb f7			set SPI_DO,a 
01d1			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d1 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d3			 
01d3 3e cf		            LD   A, 11001111b 
01d5 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01d7 3e 00		            LD   A, 00000000b 
01d9 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01db			 
01db				; set all external spi devices off 
01db 3e 00			ld a, 0 
01dd 32 e2 f9			ld (spi_device), a 
01e0 32 e5 f9			ld (spi_cartdev), a 
01e3			 
01e3					; ensure the spi bus is in a default stable state 
01e3 cd ae 00				call se_stable_spi 
01e6			 
01e6			; TODO scan spi bus and gather which storage banks are present 
01e6			 
01e6			; populate store_bank_active  
01e6			; for each ce line activate and attempt to write first byte of bank and read back 
01e6			; if zero is returned then bank is empty 
01e6			;   
01e6			; 
01e6			 
01e6					; init file extent cache to save on slow reads 
01e6			 
01e6			;	ld hl, store_filecache 
01e6			;	ld de, 0 
01e6			;	ld hl,(de)	 
01e6			 
01e6			 
01e6 c9			    ret 
01e7			 
01e7			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01e7			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01e7			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01e7			 
01e7			; INSTRUCTION SET 
01e7			; READ 0000 0011 Read data from memory array beginning at selected address 
01e7			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01e7			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01e7			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01e7			; RDSR 0000 0101 Read STATUS register 
01e7			; WRSR 0000 0001 Write STATUS register 
01e7			; PE 0100 0010 Page Erase – erase one page in memory array 
01e7			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01e7			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01e7			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01e7			 
01e7			; TODO send byte steam for page without setting the address for every single byte 
01e7			; TODO read byte  
01e7			 
01e7			; byte in a 
01e7			; address in hl  
01e7			se_writebyte: 
01e7			        
01e7			    ;   ld c, a 
01e7 f5			        push af 
01e8 e5			        push hl 
01e9			 
01e9			    ; initi write mode 
01e9			    ; 
01e9			    ;CS low 
01e9			 
01e9 3a e3 f9		       ld a,(spi_portbyte) 
01ec cd 95 01			call spi_ce_low 
01ef			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ef d3 80		       out (storage_adata),a 
01f1 32 e3 f9		       ld (spi_portbyte), a 
01f4			 
01f4			    ;clock out wren instruction 
01f4			 
01f4 3e 06		    ld a, store_wren_ins 
01f6 cd b9 00		    call spi_send_byte  
01f9			 
01f9			    ;cs high to enable write latch 
01f9			 
01f9 3a e3 f9		       ld a,(spi_portbyte) 
01fc cd 84 01			call spi_ce_high 
01ff			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ff d3 80		       out (storage_adata),a 
0201 32 e3 f9		       ld (spi_portbyte), a 
0204			 
0204 00				nop 
0205			    ; 
0205			    ; intial write data 
0205			    ; 
0205			    ; cs low 
0205			     
0205 3a e3 f9		       ld a,(spi_portbyte) 
0208 cd 95 01			call spi_ce_low 
020b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020b d3 80		       out (storage_adata),a 
020d 32 e3 f9		       ld (spi_portbyte), a 
0210			 
0210			    ; clock out write instruction 
0210			     
0210 3e 02		    ld a, store_write_ins  
0212 cd b9 00		    call spi_send_byte  
0215			 
0215			    ; clock out address (depending on address size) 
0215			     
0215 e1			    pop hl 
0216 7c			    ld a,h    ; address out msb first 
0217 cd b9 00		    call spi_send_byte  
021a 7d			    ld a,l 
021b cd b9 00		    call spi_send_byte  
021e			 
021e			    ; clock out byte(s) for page 
021e			 
021e f1			    pop af 
021f cd b9 00		    call spi_send_byte  
0222			 
0222			    ; end write with ce high 
0222 3a e3 f9		       ld a,(spi_portbyte) 
0225			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0225 cd 84 01			call spi_ce_high 
0228 d3 80		       out (storage_adata),a 
022a 32 e3 f9		       ld (spi_portbyte), a 
022d			 
022d				; pause for internal write cycle 
022d 3e 0a			ld a, 10 
022f cd 1f 0a			call aDelayInMS 
0232 c9			    ret 
0233			 
0233			; buffer to write in de 
0233			; address in hl  
0233			se_writepage: 
0233			        
0233			    ;   ld c, a 
0233 d5				push de 
0234 e5			        push hl 
0235			 
0235			    ; initi write mode 
0235			    ; 
0235			    ;CS low 
0235			 
0235 3a e3 f9		       ld a,(spi_portbyte) 
0238 cd 95 01			call spi_ce_low 
023b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023b d3 80		       out (storage_adata),a 
023d 32 e3 f9		       ld (spi_portbyte), a 
0240			 
0240			    ;clock out wren instruction 
0240			 
0240 3e 06		    ld a, store_wren_ins 
0242 cd b9 00		    call spi_send_byte  
0245			 
0245			    ;cs high to enable write latch 
0245			 
0245 3a e3 f9		       ld a,(spi_portbyte) 
0248 cd 84 01			call spi_ce_high 
024b			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024b d3 80		       out (storage_adata),a 
024d 32 e3 f9		       ld (spi_portbyte), a 
0250			 
0250 00				nop 
0251			    ; 
0251			    ; intial write data 
0251			    ; 
0251			    ; cs low 
0251			     
0251 3a e3 f9		       ld a,(spi_portbyte) 
0254			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0254 cd 95 01			call spi_ce_low 
0257 d3 80		       out (storage_adata),a 
0259 32 e3 f9		       ld (spi_portbyte), a 
025c			 
025c			    ; clock out write instruction 
025c			     
025c 3e 02		    ld a, store_write_ins  
025e cd b9 00		    call spi_send_byte  
0261			 
0261			    ; clock out address (depending on address size) 
0261			     
0261 e1			    pop hl 
0262 7c			    ld a,h    ; address out msb first 
0263 cd b9 00		    call spi_send_byte  
0266 7d			    ld a,l 
0267 cd b9 00		    call spi_send_byte  
026a			 
026a			    ; clock out byte(s) for page 
026a			 
026a e1				pop hl 
026b 06 40			ld b, STORE_BLOCK_PHY 
026d			.bytewrite: 
026d			 
026d 7e				ld a,(hl) 
026e e5			    push hl 
026f c5				push bc 
0270 cd b9 00		    call spi_send_byte  
0273 c1				pop bc 
0274 e1				pop hl 
0275			 
0275			    ; end write with ce high 
0275 3a e3 f9		       ld a,(spi_portbyte) 
0278 cd 84 01			call spi_ce_high 
027b			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027b d3 80		       out (storage_adata),a 
027d 32 e3 f9		       ld (spi_portbyte), a 
0280			 
0280 23				inc hl 
0281 10 ea			djnz .bytewrite 
0283			 
0283				; pause for internal write cycle 
0283 3e 64			ld a, 100 
0285 cd 1f 0a			call aDelayInMS 
0288 c9			    ret 
0289			; returns byte in a 
0289			; address in hl  
0289			se_readbyte: 
0289 d5				push de 
028a c5				push bc 
028b			 
028b			    ;   ld c, a 
028b e5			        push hl 
028c			 
028c			    ; initi write mode 
028c			    ; 
028c			    ;CS low 
028c			 
028c 3a e3 f9		       ld a,(spi_portbyte) 
028f cd 95 01			call spi_ce_low 
0292			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0292 d3 80		       out (storage_adata),a 
0294 32 e3 f9		       ld (spi_portbyte), a 
0297			 
0297			    ;clock out wren instruction 
0297			 
0297 3e 03		    ld a, store_read_ins 
0299 cd b9 00		    call spi_send_byte  
029c			 
029c			 
029c			    ; clock out address (depending on address size) 
029c			     
029c e1			    pop hl 
029d 7c			    ld a,h    ; address out msb first 
029e cd b9 00		    call spi_send_byte  
02a1 7d			    ld a,l 
02a2 cd b9 00		    call spi_send_byte  
02a5			 
02a5			    ; clock in byte(s) for page 
02a5			 
02a5 cd da 00		    call spi_read_byte  
02a8 f5				push af 
02a9			 
02a9			    ; end write with ce high 
02a9 3a e3 f9		       ld a,(spi_portbyte) 
02ac			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02ac cd 84 01			call spi_ce_high 
02af d3 80		       out (storage_adata),a 
02b1 32 e3 f9		       ld (spi_portbyte), a 
02b4			 
02b4 f1				pop af 
02b5			 
02b5 c1				pop bc 
02b6 d1				pop de 
02b7			 
02b7 c9			    ret 
02b8			 
02b8			if DEBUG_STORESE 
02b8			 
02b8			storageput:  
02b8			 
02b8			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02b8			 
02b8 21 ba ef			ld hl,scratch+2 
02bb cd 73 10			call get_word_hl 
02be			 
02be				; stuff it here for the moment as it will be overwritten later anyway 
02be			 
02be 22 db f2			ld (os_cur_ptr),hl	 
02c1			 
02c1			 
02c1			; get pointer to start of string 
02c1			 
02c1 21 bf ef			ld hl, scratch+7 
02c4			 
02c4			; loop writing char of string to eeprom 
02c4			 
02c4 7e			.writestr:	ld a,(hl) 
02c5 fe 00				cp 0 
02c7 28 12				jr z, .wsdone		; done writing 
02c9 e5					push hl 
02ca 2a db f2				ld hl,(os_cur_ptr) 
02cd cd e7 01				call se_writebyte 
02d0			 
02d0 2a db f2				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d3 23					inc hl 
02d4 22 db f2				ld (os_cur_ptr),hl 
02d7			 
02d7					; restore string pointer and get next char 
02d7			 
02d7 e1					pop hl 
02d8 23					inc hl 
02d9 18 e9				jr .writestr 
02db			 
02db			 
02db			 
02db			.wsdone: 
02db			 
02db			 
02db			; when done load first page into a buffer  
02db			 
02db 21 00 80				ld hl,08000h		; start in ram 
02de 22 db f2				ld (os_cur_ptr),hl 
02e1 21 00 00				ld hl, 0		 ; start of page 
02e4 22 e0 ef				ld (scratch+40),hl	; hang on to it 
02e7			 
02e7 06 80				ld b, 128		; actually get more then one page 
02e9 c5			.wsload:	push bc 
02ea 2a e0 ef				ld hl,(scratch+40) 
02ed e5					push hl 
02ee cd 89 02				call se_readbyte 
02f1			 
02f1					; a now as the byte 
02f1			 
02f1 2a db f2				ld hl,(os_cur_ptr) 
02f4 77					ld (hl),a 
02f5					; inc next buffer area 
02f5 23					inc hl 
02f6 22 db f2				ld (os_cur_ptr),hl 
02f9			 
02f9					; get eeprom position, inc and save for next round 
02f9 e1					pop hl		 
02fa 23					inc hl 
02fb 22 e0 ef				ld (scratch+40),hl 
02fe c1					pop bc 
02ff 10 e8				djnz .wsload 
0301			 
0301			; set 'd' pointer to start of buffer 
0301			 
0301 21 00 80				ld hl,08000h 
0304 22 db f2				ld (os_cur_ptr),hl 
0307			 
0307			 
0307 c9			ret 
0308			 
0308			 
0308 c9			storageread: ret 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			endif 
0309			 
0309			 
0309			 
# End of file firmware_seeprom.asm
0309			else  
0309			   ; create some stubs for the labels  
0309			se_readbyte: ret  
0309			se_writebyte: ret  
0309			storage_init: ret  
0309			  
0309			endif  
0309			  
0309			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0309			;include "firmware_cf.asm"  
0309			  
0309			; load up high level storage hardward abstractions  
0309			include "firmware_storage.asm"  
0309			 
0309			; persisent storage hardware abstraction layer  
0309			 
0309			 
0309			 
0309			; Block 0 on storage is a config state 
0309			 
0309			 
0309			 
0309			; TODO add read phy block and write phy block functions 
0309			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0309			 
0309			; Abstraction layer  
0309			 
0309			; Logocial block size is same size as physical size - using tape concept 
0309			 
0309			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0309			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0309			 
0309			 
0309			 
0309			; Filesystem layout (Logical layout) 
0309			; 
0309			; Block 0 - Bank config  
0309			; 
0309			;      Byte - 0 file id counter 
0309			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0309			;      Byte - 3-20 zero terminated bank label 
0309			; 
0309			; Block 1 > File storage 
0309			; 
0309			;      Byte 0 file id    - block 0 file details 
0309			;      Byte 1 block id - block 0 is file  
0309			;            Byte 2-15 - File name 
0309			; 
0309			;       - to end of block data 
0309			; 
0309			 
0309			 
0309			; Read Block 
0309			; ---------- 
0309			; 
0309			; With current bank 
0309			;  
0309			; Get block number to read 
0309			; Load physical blocks starting at start block into buffer 
0309			 
0309			; de points to buffer to use 
0309			; hl holds logical block number  
0309			 
0309			storage_read_block: 
0309			 
0309				; TODO bank selection 
0309			 
0309				; for each of the physical blocks read it into the buffer 
0309 06 40			ld b, STORE_BLOCK_PHY 
030b			 
030b				if DEBUG_STORESE 
030b d5					push de 
030c				endif 
030c				 
030c			.rl1:    
030c			 
030c				; read physical block at hl into de 
030c			        ; increment hl and de to next read position on exit 
030c			 
030c e5				push hl 
030d d5				push de	 
030e c5				push bc 
030f			;	if DEBUG_STORESE 
030f			;		push af 
030f			;		ld a, 'R' 
030f			;		ld (debug_mark),a 
030f			;		pop af 
030f			;		CALLMONITOR 
030f			;	endif 
030f cd 89 02			call se_readbyte 
0312			;	if DEBUG_STORESE 
0312			;		ld a,(spi_portbyte) 
0312			;		ld l, a 
0312			;		push af 
0312			;		ld a, '1' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 c1				pop bc 
0313 d1				pop de 
0314 e1				pop hl 
0315 12				ld (de),a 
0316 23				inc hl 
0317 13				inc de 
0318			 
0318			;	if DEBUG_STORESE 
0318			;		push af 
0318			;		ld a, 'r' 
0318			;		ld (debug_mark),a 
0318			;		pop af 
0318			;		CALLMONITOR 
0318			;	endif 
0318			 
0318 10 f2			djnz .rl1 
031a			 
031a				if DEBUG_STORESE 
031a					DMARK "SRB" 
031a f5				push af  
031b 3a 2f 03			ld a, (.dmark)  
031e 32 bd fb			ld (debug_mark),a  
0321 3a 30 03			ld a, (.dmark+1)  
0324 32 be fb			ld (debug_mark+1),a  
0327 3a 31 03			ld a, (.dmark+2)  
032a 32 bf fb			ld (debug_mark+2),a  
032d 18 03			jr .pastdmark  
032f ..			.dmark: db "SRB"  
0332 f1			.pastdmark: pop af  
0333			endm  
# End of macro DMARK
0333 d1					pop de 
0334			; 
0334			;		push af 
0334			;		ld a, 'R' 
0334			;		ld (debug_mark),a 
0334			;		pop af 
0334					CALLMONITOR 
0334 cd d4 14			call break_point_state  
0337				endm  
# End of macro CALLMONITOR
0337				endif 
0337 c9				ret	 
0338				 
0338			 
0338			; File Size 
0338			; --------- 
0338			; 
0338			;   hl file id 
0338			; 
0338			;  returns in hl the number of blocks 
0338			 
0338			storage_file_size: 
0338 5d				ld e, l 
0339 16 00			ld d, 0 
033b 21 40 00			ld hl, STORE_BLOCK_PHY 
033e					if DEBUG_FORTH_WORDS 
033e						DMARK "SIZ" 
033e f5				push af  
033f 3a 53 03			ld a, (.dmark)  
0342 32 bd fb			ld (debug_mark),a  
0345 3a 54 03			ld a, (.dmark+1)  
0348 32 be fb			ld (debug_mark+1),a  
034b 3a 55 03			ld a, (.dmark+2)  
034e 32 bf fb			ld (debug_mark+2),a  
0351 18 03			jr .pastdmark  
0353 ..			.dmark: db "SIZ"  
0356 f1			.pastdmark: pop af  
0357			endm  
# End of macro DMARK
0357						CALLMONITOR 
0357 cd d4 14			call break_point_state  
035a				endm  
# End of macro CALLMONITOR
035a					endif 
035a cd 1f 06			call storage_findnextid 
035d			 
035d cd e5 0c			call ishlzero 
0360			;	ld a, l 
0360			;	add h 
0360			;	cp 0 
0360 c8				ret z			; block not found so EOF 
0361			 
0361 11 e8 f9			ld de, store_page 
0364 cd 09 03			call storage_read_block 
0367			 
0367 3a ea f9			ld a, (store_page+2)	 ; get extent count 
036a 6f				ld l, a 
036b 26 00			ld h, 0 
036d c9			 	ret 
036e			 
036e			 
036e			; Write Block 
036e			; ----------- 
036e			; 
036e			; With current bank 
036e			;  
036e			; Get block number to write 
036e			; Write physical blocks starting at start block from buffer 
036e			  
036e			storage_write_block: 
036e				; TODO bank selection 
036e			 
036e				; for each of the physical blocks read it into the buffer 
036e 06 40			ld b, STORE_BLOCK_PHY 
0370			 
0370				if DEBUG_STORESE 
0370					DMARK "SWB" 
0370 f5				push af  
0371 3a 85 03			ld a, (.dmark)  
0374 32 bd fb			ld (debug_mark),a  
0377 3a 86 03			ld a, (.dmark+1)  
037a 32 be fb			ld (debug_mark+1),a  
037d 3a 87 03			ld a, (.dmark+2)  
0380 32 bf fb			ld (debug_mark+2),a  
0383 18 03			jr .pastdmark  
0385 ..			.dmark: db "SWB"  
0388 f1			.pastdmark: pop af  
0389			endm  
# End of macro DMARK
0389			 
0389					;push af 
0389					;ld a, 'W' 
0389					;ld (debug_mark),a 
0389					;pop af 
0389					CALLMONITOR 
0389 cd d4 14			call break_point_state  
038c				endm  
# End of macro CALLMONITOR
038c				endif 
038c			 
038c			; might not be working 
038c			;	call se_writepage 
038c			 
038c			;	ret 
038c			; 
038c			 
038c			 
038c			 
038c			.wl1:    
038c			 
038c				; read physical block at hl into de 
038c			        ; increment hl and de to next read position on exit 
038c			 
038c e5				push hl 
038d d5				push de	 
038e c5				push bc 
038f 1a				ld a,(de) 
0390				;if DEBUG_STORESE 
0390			;		push af 
0390			;		ld a, 'W' 
0390			;		ld (debug_mark),a 
0390			;		pop af 
0390			;		CALLMONITOR 
0390			;	endif 
0390 cd e7 01			call se_writebyte 
0393			;	call delay250ms 
0393 00				nop 
0394 00				nop 
0395 00				nop 
0396			;	if DEBUG_STORESE 
0396			;		push af 
0396			;		ld a, 'w' 
0396			;		ld (debug_mark),a 
0396			;		pop af 
0396			;		CALLMONITOR 
0396			;	endif 
0396 c1				pop bc 
0397 d1				pop de 
0398 e1				pop hl 
0399 23				inc hl 
039a 13				inc de 
039b			 
039b			 
039b 10 ef			djnz .wl1 
039d			 
039d				if DEBUG_STORESE 
039d					DMARK "SW2" 
039d f5				push af  
039e 3a b2 03			ld a, (.dmark)  
03a1 32 bd fb			ld (debug_mark),a  
03a4 3a b3 03			ld a, (.dmark+1)  
03a7 32 be fb			ld (debug_mark+1),a  
03aa 3a b4 03			ld a, (.dmark+2)  
03ad 32 bf fb			ld (debug_mark+2),a  
03b0 18 03			jr .pastdmark  
03b2 ..			.dmark: db "SW2"  
03b5 f1			.pastdmark: pop af  
03b6			endm  
# End of macro DMARK
03b6			 
03b6					;push af 
03b6					;ld a, 'W' 
03b6					;ld (debug_mark),a 
03b6					;pop af 
03b6					CALLMONITOR 
03b6 cd d4 14			call break_point_state  
03b9				endm  
# End of macro CALLMONITOR
03b9				endif 
03b9 c9				ret	 
03ba			 
03ba			; Init bank 
03ba			; --------- 
03ba			; 
03ba			; With current bank 
03ba			; 
03ba			; Setup block 0 config 
03ba			;     Set 0 file id counter 
03ba			;     Set formatted byte pattern 
03ba			;     Zero out bank label 
03ba			;      
03ba			; For every logical block write 0-1 byte as null 
03ba			 
03ba			storage_get_block_0: 
03ba			 
03ba				; TODO check presence 
03ba			 
03ba				; get block 0 config 
03ba			 
03ba 21 00 00			ld hl, 0 
03bd 11 e8 f9			ld de, store_page 
03c0 cd 09 03			call storage_read_block 
03c3			 
03c3				if DEBUG_STORESE 
03c3					DMARK "SB0" 
03c3 f5				push af  
03c4 3a d8 03			ld a, (.dmark)  
03c7 32 bd fb			ld (debug_mark),a  
03ca 3a d9 03			ld a, (.dmark+1)  
03cd 32 be fb			ld (debug_mark+1),a  
03d0 3a da 03			ld a, (.dmark+2)  
03d3 32 bf fb			ld (debug_mark+2),a  
03d6 18 03			jr .pastdmark  
03d8 ..			.dmark: db "SB0"  
03db f1			.pastdmark: pop af  
03dc			endm  
# End of macro DMARK
03dc 11 e8 f9				ld de, store_page 
03df			;		push af 
03df			;		ld a, 'i' 
03df			;		ld (debug_mark),a 
03df			;		pop af 
03df					CALLMONITOR 
03df cd d4 14			call break_point_state  
03e2				endm  
# End of macro CALLMONITOR
03e2				endif 
03e2			 
03e2				; is this area formatted? 
03e2			 
03e2			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e2 2a e9 f9			ld hl, (store_page+1) 
03e5 3e 80			ld a,0x80 
03e7 bd				cp l 
03e8 20 22			jr nz, .ininotformatted 
03ea				; do a double check 
03ea 3e 27			ld a, 0x27 
03ec bc				cp h 
03ed 20 1d			jr nz, .ininotformatted 
03ef			 
03ef				; formatted then 
03ef			 
03ef				if DEBUG_STORESE 
03ef					DMARK "SB1" 
03ef f5				push af  
03f0 3a 04 04			ld a, (.dmark)  
03f3 32 bd fb			ld (debug_mark),a  
03f6 3a 05 04			ld a, (.dmark+1)  
03f9 32 be fb			ld (debug_mark+1),a  
03fc 3a 06 04			ld a, (.dmark+2)  
03ff 32 bf fb			ld (debug_mark+2),a  
0402 18 03			jr .pastdmark  
0404 ..			.dmark: db "SB1"  
0407 f1			.pastdmark: pop af  
0408			endm  
# End of macro DMARK
0408					;push af 
0408					;ld a, 'I' 
0408					;ld (debug_mark),a 
0408					;pop af 
0408					CALLMONITOR 
0408 cd d4 14			call break_point_state  
040b				endm  
# End of macro CALLMONITOR
040b				endif 
040b c9				ret 
040c			 
040c			.ininotformatted: 
040c				; bank not formatted so poke various bits to make sure 
040c			 
040c				if DEBUG_STORESE 
040c					DMARK "SB2" 
040c f5				push af  
040d 3a 21 04			ld a, (.dmark)  
0410 32 bd fb			ld (debug_mark),a  
0413 3a 22 04			ld a, (.dmark+1)  
0416 32 be fb			ld (debug_mark+1),a  
0419 3a 23 04			ld a, (.dmark+2)  
041c 32 bf fb			ld (debug_mark+2),a  
041f 18 03			jr .pastdmark  
0421 ..			.dmark: db "SB2"  
0424 f1			.pastdmark: pop af  
0425			endm  
# End of macro DMARK
0425					;push af 
0425					;ld a, 'f' 
0425					;ld (debug_mark),a 
0425					;pop af 
0425					CALLMONITOR 
0425 cd d4 14			call break_point_state  
0428				endm  
# End of macro CALLMONITOR
0428				endif 
0428			 
0428 21 e8 f9			ld hl, store_page 
042b 3e 00			ld a, 0 
042d				 
042d 77				ld (hl),a   ; reset file counter 
042e			 
042e 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0431 22 e9 f9		 	ld (store_page+1), hl	 
0434			 
0434				; set default label 
0434			 
0434 21 c9 04			ld hl, .defaultbanklabl 
0437 11 eb f9		 	ld de, store_page+3 
043a 01 0f 00			ld bc, 15 
043d ed b0			ldir 
043f			 
043f				; save default page 0 
043f			 
043f 21 00 00			ld hl, 0 
0442 11 e8 f9			ld de, store_page 
0445				if DEBUG_STORESE 
0445					DMARK "SB3" 
0445 f5				push af  
0446 3a 5a 04			ld a, (.dmark)  
0449 32 bd fb			ld (debug_mark),a  
044c 3a 5b 04			ld a, (.dmark+1)  
044f 32 be fb			ld (debug_mark+1),a  
0452 3a 5c 04			ld a, (.dmark+2)  
0455 32 bf fb			ld (debug_mark+2),a  
0458 18 03			jr .pastdmark  
045a ..			.dmark: db "SB3"  
045d f1			.pastdmark: pop af  
045e			endm  
# End of macro DMARK
045e			;		push af 
045e			;		ld a, 'F' 
045e			;		ld (debug_mark),a 
045e			;		pop af 
045e					CALLMONITOR 
045e cd d4 14			call break_point_state  
0461				endm  
# End of macro CALLMONITOR
0461				endif 
0461 cd 6e 03			call storage_write_block 
0464				if DEBUG_STORESE 
0464					DMARK "SB4" 
0464 f5				push af  
0465 3a 79 04			ld a, (.dmark)  
0468 32 bd fb			ld (debug_mark),a  
046b 3a 7a 04			ld a, (.dmark+1)  
046e 32 be fb			ld (debug_mark+1),a  
0471 3a 7b 04			ld a, (.dmark+2)  
0474 32 bf fb			ld (debug_mark+2),a  
0477 18 03			jr .pastdmark  
0479 ..			.dmark: db "SB4"  
047c f1			.pastdmark: pop af  
047d			endm  
# End of macro DMARK
047d			;		push af 
047d			;		ld a, '>' 
047d			;		ld (debug_mark),a 
047d			;		pop af 
047d					CALLMONITOR 
047d cd d4 14			call break_point_state  
0480				endm  
# End of macro CALLMONITOR
0480				endif 
0480			 
0480 00				nop 
0481 00				nop 
0482 00				nop 
0483			 
0483				; now set 0 in every page to mark as a free block 
0483			 
0483 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0485 21 40 00			ld hl, STORE_BLOCK_PHY 
0488			 
0488 3e 00		.setmark1:   	ld a,0 
048a e5					push hl 
048b c5					push bc 
048c cd e7 01				call se_writebyte 
048f 3e 0a			ld a, 10 
0491 cd 1f 0a			call aDelayInMS 
0494 23				inc hl 
0495 cd e7 01				call se_writebyte 
0498 3e 0a			ld a, 10 
049a cd 1f 0a			call aDelayInMS 
049d 2b				dec hl 
049e c1					pop bc 
049f e1					pop hl 
04a0 3e 40				ld a, STORE_BLOCK_PHY 
04a2 cd bc 0c				call addatohl 
04a5 10 e1				djnz .setmark1 
04a7			 
04a7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04a9 3e 00		.setmark2:   	ld a,0 
04ab e5					push hl 
04ac c5					push bc 
04ad cd e7 01				call se_writebyte 
04b0 3e 0a			ld a, 10 
04b2 cd 1f 0a			call aDelayInMS 
04b5 23				inc hl 
04b6 cd e7 01				call se_writebyte 
04b9 3e 0a			ld a, 10 
04bb cd 1f 0a			call aDelayInMS 
04be 2b				dec hl 
04bf c1					pop bc 
04c0 e1					pop hl 
04c1 3e 40				ld a, STORE_BLOCK_PHY 
04c3 cd bc 0c				call addatohl 
04c6 10 e1				djnz .setmark2 
04c8			 
04c8					 
04c8			 
04c8			 
04c8 c9				ret 
04c9			 
04c9			 
04c9			 
04c9			 
04c9 .. 00		.defaultbanklabl:   db "BankLabel",0 
04d3			 
04d3			 
04d3			 
04d3			; Label Bank 
04d3			; ---------- 
04d3			; 
04d3			; With current bank 
04d3			; Read block 0 
04d3			; Set label 
04d3			; Write block 0 
04d3			 
04d3			; label str pointer in hl 
04d3			 
04d3			storage_label:     
04d3			 
04d3				if DEBUG_STORESE 
04d3					DMARK "LBL" 
04d3 f5				push af  
04d4 3a e8 04			ld a, (.dmark)  
04d7 32 bd fb			ld (debug_mark),a  
04da 3a e9 04			ld a, (.dmark+1)  
04dd 32 be fb			ld (debug_mark+1),a  
04e0 3a ea 04			ld a, (.dmark+2)  
04e3 32 bf fb			ld (debug_mark+2),a  
04e6 18 03			jr .pastdmark  
04e8 ..			.dmark: db "LBL"  
04eb f1			.pastdmark: pop af  
04ec			endm  
# End of macro DMARK
04ec					CALLMONITOR 
04ec cd d4 14			call break_point_state  
04ef				endm  
# End of macro CALLMONITOR
04ef				endif 
04ef			 
04ef e5				push hl 
04f0			 
04f0 cd ba 03			call storage_get_block_0 
04f3			 
04f3				; set default label 
04f3			 
04f3 e1				pop hl 
04f4			 
04f4 11 eb f9		 	ld de, store_page+3 
04f7 01 0f 00			ld bc, 15 
04fa				if DEBUG_STORESE 
04fa					DMARK "LB3" 
04fa f5				push af  
04fb 3a 0f 05			ld a, (.dmark)  
04fe 32 bd fb			ld (debug_mark),a  
0501 3a 10 05			ld a, (.dmark+1)  
0504 32 be fb			ld (debug_mark+1),a  
0507 3a 11 05			ld a, (.dmark+2)  
050a 32 bf fb			ld (debug_mark+2),a  
050d 18 03			jr .pastdmark  
050f ..			.dmark: db "LB3"  
0512 f1			.pastdmark: pop af  
0513			endm  
# End of macro DMARK
0513					CALLMONITOR 
0513 cd d4 14			call break_point_state  
0516				endm  
# End of macro CALLMONITOR
0516				endif 
0516 ed b0			ldir 
0518				; save default page 0 
0518			 
0518 21 00 00			ld hl, 0 
051b 11 e8 f9			ld de, store_page 
051e				if DEBUG_STORESE 
051e					DMARK "LBW" 
051e f5				push af  
051f 3a 33 05			ld a, (.dmark)  
0522 32 bd fb			ld (debug_mark),a  
0525 3a 34 05			ld a, (.dmark+1)  
0528 32 be fb			ld (debug_mark+1),a  
052b 3a 35 05			ld a, (.dmark+2)  
052e 32 bf fb			ld (debug_mark+2),a  
0531 18 03			jr .pastdmark  
0533 ..			.dmark: db "LBW"  
0536 f1			.pastdmark: pop af  
0537			endm  
# End of macro DMARK
0537					CALLMONITOR 
0537 cd d4 14			call break_point_state  
053a				endm  
# End of macro CALLMONITOR
053a				endif 
053a cd 6e 03			call storage_write_block 
053d			 
053d c9				ret 
053e			 
053e			 
053e			 
053e			; Read Block 0 - Config 
053e			; --------------------- 
053e			; 
053e			; With current bank 
053e			; Call presence test 
053e			;    If not present format/init bank  
053e			; Read block 0  
053e			;  
053e			 
053e			 
053e			; Dir 
053e			; --- 
053e			; 
053e			; With current bank 
053e			; Load Block 0 Config 
053e			; Get max file id number 
053e			; For each logical block 
053e			;    Read block read byte 2 
053e			;      if first block of file 
053e			;         Display file name 
053e			;         Display type flags for file 
053e			;        
053e			 
053e			; moving to words as this requires stack control 
053e			 
053e			 
053e			; Delete File 
053e			; ----------- 
053e			; 
053e			; With current bank 
053e			; 
053e			; Load Block 0 Config 
053e			; Get max file id number 
053e			; For each logical block 
053e			;    Read block file id 
053e			;      If first block of file and dont have file id 
053e			;         if file to delete 
053e			;         Save file id 
053e			;         Null file id 
053e			;         Write this block back 
053e			;      If file id is one saved 
053e			;         Null file id 
053e			;         Write this block back 
053e			 
053e			storage_erase: 
053e			 
053e				; hl contains the file id 
053e			 
053e 5d				ld e, l 
053f 16 00			ld d, 0 
0541 21 40 00			ld hl, STORE_BLOCK_PHY 
0544					if DEBUG_FORTH_WORDS 
0544						DMARK "ERA" 
0544 f5				push af  
0545 3a 59 05			ld a, (.dmark)  
0548 32 bd fb			ld (debug_mark),a  
054b 3a 5a 05			ld a, (.dmark+1)  
054e 32 be fb			ld (debug_mark+1),a  
0551 3a 5b 05			ld a, (.dmark+2)  
0554 32 bf fb			ld (debug_mark+2),a  
0557 18 03			jr .pastdmark  
0559 ..			.dmark: db "ERA"  
055c f1			.pastdmark: pop af  
055d			endm  
# End of macro DMARK
055d						CALLMONITOR 
055d cd d4 14			call break_point_state  
0560				endm  
# End of macro CALLMONITOR
0560					endif 
0560 cd 1f 06			call storage_findnextid 
0563			 
0563 e5				push hl 
0564			 
0564				; TODO check file not found 
0564			 
0564 11 e8 f9			ld de, store_page 
0567 cd 09 03			call storage_read_block 
056a			 
056a					if DEBUG_FORTH_WORDS 
056a						DMARK "ER1" 
056a f5				push af  
056b 3a 7f 05			ld a, (.dmark)  
056e 32 bd fb			ld (debug_mark),a  
0571 3a 80 05			ld a, (.dmark+1)  
0574 32 be fb			ld (debug_mark+1),a  
0577 3a 81 05			ld a, (.dmark+2)  
057a 32 bf fb			ld (debug_mark+2),a  
057d 18 03			jr .pastdmark  
057f ..			.dmark: db "ER1"  
0582 f1			.pastdmark: pop af  
0583			endm  
# End of macro DMARK
0583						CALLMONITOR 
0583 cd d4 14			call break_point_state  
0586				endm  
# End of macro CALLMONITOR
0586					endif 
0586 3a e8 f9			ld a, (store_page)	; get file id 
0589 32 e1 f9			ld (store_tmpid), a 
058c			 
058c 3a ea f9			ld a, (store_page+2)    ; get count of extends 
058f 32 e0 f9			ld (store_tmpext), a 
0592			 
0592				; wipe file header 
0592			 
0592 e1				pop hl 
0593 3e 00			ld a, 0 
0595 32 e8 f9			ld (store_page), a 
0598 32 e9 f9			ld (store_page+1),a 
059b 11 e8 f9			ld de, store_page 
059e					if DEBUG_FORTH_WORDS 
059e						DMARK "ER2" 
059e f5				push af  
059f 3a b3 05			ld a, (.dmark)  
05a2 32 bd fb			ld (debug_mark),a  
05a5 3a b4 05			ld a, (.dmark+1)  
05a8 32 be fb			ld (debug_mark+1),a  
05ab 3a b5 05			ld a, (.dmark+2)  
05ae 32 bf fb			ld (debug_mark+2),a  
05b1 18 03			jr .pastdmark  
05b3 ..			.dmark: db "ER2"  
05b6 f1			.pastdmark: pop af  
05b7			endm  
# End of macro DMARK
05b7						CALLMONITOR 
05b7 cd d4 14			call break_point_state  
05ba				endm  
# End of macro CALLMONITOR
05ba					endif 
05ba cd 6e 03			call storage_write_block 
05bd			 
05bd			 
05bd				; wipe file extents 
05bd			 
05bd 3a e0 f9			ld a, (store_tmpext) 
05c0 47				ld b, a 
05c1			 
05c1			.eraext:	  
05c1 c5				push bc 
05c2			 
05c2 21 40 00			ld hl, STORE_BLOCK_PHY 
05c5 3a e1 f9			ld a,(store_tmpid) 
05c8 5f				ld e, a 
05c9 50				ld d, b	 
05ca					if DEBUG_FORTH_WORDS 
05ca						DMARK "ER3" 
05ca f5				push af  
05cb 3a df 05			ld a, (.dmark)  
05ce 32 bd fb			ld (debug_mark),a  
05d1 3a e0 05			ld a, (.dmark+1)  
05d4 32 be fb			ld (debug_mark+1),a  
05d7 3a e1 05			ld a, (.dmark+2)  
05da 32 bf fb			ld (debug_mark+2),a  
05dd 18 03			jr .pastdmark  
05df ..			.dmark: db "ER3"  
05e2 f1			.pastdmark: pop af  
05e3			endm  
# End of macro DMARK
05e3						CALLMONITOR 
05e3 cd d4 14			call break_point_state  
05e6				endm  
# End of macro CALLMONITOR
05e6					endif 
05e6 cd 1f 06			call storage_findnextid 
05e9			 
05e9 e5				push hl 
05ea 11 e8 f9			ld de, store_page 
05ed cd 09 03			call storage_read_block 
05f0			 
05f0				; free block	 
05f0			 
05f0 3e 00			ld a, 0 
05f2 32 e8 f9			ld (store_page), a 
05f5 32 e9 f9			ld (store_page+1),a 
05f8 11 e8 f9			ld de, store_page 
05fb e1				pop hl 
05fc					if DEBUG_FORTH_WORDS 
05fc						DMARK "ER4" 
05fc f5				push af  
05fd 3a 11 06			ld a, (.dmark)  
0600 32 bd fb			ld (debug_mark),a  
0603 3a 12 06			ld a, (.dmark+1)  
0606 32 be fb			ld (debug_mark+1),a  
0609 3a 13 06			ld a, (.dmark+2)  
060c 32 bf fb			ld (debug_mark+2),a  
060f 18 03			jr .pastdmark  
0611 ..			.dmark: db "ER4"  
0614 f1			.pastdmark: pop af  
0615			endm  
# End of macro DMARK
0615						CALLMONITOR 
0615 cd d4 14			call break_point_state  
0618				endm  
# End of macro CALLMONITOR
0618					endif 
0618 cd 6e 03			call storage_write_block 
061b			 
061b c1				pop bc 
061c 10 a3			djnz .eraext 
061e			 
061e c9				ret 
061f			 
061f			 
061f			; Find Free Block 
061f			; --------------- 
061f			; 
061f			; With current bank 
061f			;  
061f			; From given starting logical block 
061f			;    Read block  
061f			;    If no file id 
061f			;         Return block id 
061f			 
061f			 
061f			; hl starting page number 
061f			; hl contains free page number or zero if no pages free 
061f			; e contains the file id to locate 
061f			; d contains the block number 
061f			 
061f			; TODO change to find file id and use zero for free block 
061f			 
061f			storage_findnextid: 
061f			 
061f				; now locate first 0 page to mark as a free block 
061f			 
061f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0621			;	ld hl, STORE_BLOCK_PHY 
0621			 
0621					if DEBUG_FORTH_WORDS 
0621					DMARK "FNI" 
0621 f5				push af  
0622 3a 36 06			ld a, (.dmark)  
0625 32 bd fb			ld (debug_mark),a  
0628 3a 37 06			ld a, (.dmark+1)  
062b 32 be fb			ld (debug_mark+1),a  
062e 3a 38 06			ld a, (.dmark+2)  
0631 32 bf fb			ld (debug_mark+2),a  
0634 18 03			jr .pastdmark  
0636 ..			.dmark: db "FNI"  
0639 f1			.pastdmark: pop af  
063a			endm  
# End of macro DMARK
063a						CALLMONITOR 
063a cd d4 14			call break_point_state  
063d				endm  
# End of macro CALLMONITOR
063d					endif 
063d			.ff1:   	 
063d e5					push hl 
063e c5					push bc 
063f d5					push de 
0640 cd 89 02				call se_readbyte 
0643 5f					ld e,a 
0644 23					inc hl 
0645 cd 89 02				call se_readbyte 
0648 57					ld d, a 
0649 e1					pop hl 
064a e5					push hl 
064b cd da 0c				call cmp16 
064e 28 49				jr z, .fffound 
0650			 
0650 d1					pop de 
0651 c1					pop bc 
0652 e1					pop hl 
0653			 
0653					; is found? 
0653					;cp e 
0653					;ret z 
0653			 
0653 3e 40				ld a, STORE_BLOCK_PHY 
0655 cd bc 0c				call addatohl 
0658 10 e3				djnz .ff1 
065a			 
065a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
065c			.ff2:   	 
065c			 
065c e5					push hl 
065d c5					push bc 
065e d5					push de 
065f cd 89 02				call se_readbyte 
0662 5f					ld e,a 
0663 23					inc hl 
0664 cd 89 02				call se_readbyte 
0667 57					ld d, a 
0668			 
0668 e1					pop hl 
0669 e5					push hl 
066a cd da 0c				call cmp16 
066d 28 2a				jr z, .fffound 
066f			 
066f d1					pop de 
0670 c1					pop bc 
0671 e1					pop hl 
0672					; is found? 
0672					;cp e 
0672					;ret z 
0672			 
0672 3e 40				ld a, STORE_BLOCK_PHY 
0674 cd bc 0c				call addatohl 
0677 10 e3				djnz .ff2 
0679			 
0679			 
0679					if DEBUG_FORTH_WORDS 
0679					DMARK "FN-" 
0679 f5				push af  
067a 3a 8e 06			ld a, (.dmark)  
067d 32 bd fb			ld (debug_mark),a  
0680 3a 8f 06			ld a, (.dmark+1)  
0683 32 be fb			ld (debug_mark+1),a  
0686 3a 90 06			ld a, (.dmark+2)  
0689 32 bf fb			ld (debug_mark+2),a  
068c 18 03			jr .pastdmark  
068e ..			.dmark: db "FN-"  
0691 f1			.pastdmark: pop af  
0692			endm  
# End of macro DMARK
0692					;	push af 
0692					;	ld a, 'n' 
0692					;	ld (debug_mark),a 
0692					;	pop af 
0692						CALLMONITOR 
0692 cd d4 14			call break_point_state  
0695				endm  
# End of macro CALLMONITOR
0695					endif 
0695				; no free marks! 
0695 21 00 00				ld hl, 0 
0698 c9				ret 
0699			.fffound: 
0699				 
0699			 
0699 d1					pop de 
069a c1					pop bc 
069b e1					pop hl 
069c					if DEBUG_FORTH_WORDS 
069c					DMARK "FNF" 
069c f5				push af  
069d 3a b1 06			ld a, (.dmark)  
06a0 32 bd fb			ld (debug_mark),a  
06a3 3a b2 06			ld a, (.dmark+1)  
06a6 32 be fb			ld (debug_mark+1),a  
06a9 3a b3 06			ld a, (.dmark+2)  
06ac 32 bf fb			ld (debug_mark+2),a  
06af 18 03			jr .pastdmark  
06b1 ..			.dmark: db "FNF"  
06b4 f1			.pastdmark: pop af  
06b5			endm  
# End of macro DMARK
06b5					;	push af 
06b5					;	ld a, 'n' 
06b5					;	ld (debug_mark),a 
06b5					;	pop af 
06b5						CALLMONITOR 
06b5 cd d4 14			call break_point_state  
06b8				endm  
# End of macro CALLMONITOR
06b8					endif 
06b8 c9				ret 
06b9			 
06b9			 
06b9			 
06b9			; Free Space 
06b9			; ---------- 
06b9			; 
06b9			; With current bank 
06b9			; 
06b9			; Set block count to zero 
06b9			; Starting with first logical block 
06b9			;      Find free block  
06b9			;      If block id given, increment block count 
06b9			; 
06b9			;  
06b9			 
06b9			 
06b9			; hl contains count of free blocks 
06b9			 
06b9			storage_freeblocks: 
06b9			 
06b9				; now locate first 0 page to mark as a free block 
06b9			 
06b9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06bb 21 40 00			ld hl, STORE_BLOCK_PHY 
06be 11 00 00			ld de, 0 
06c1			 
06c1			.fb1:   	 
06c1 e5					push hl 
06c2 c5					push bc 
06c3 d5					push de 
06c4 cd 89 02				call se_readbyte 
06c7 d1					pop de 
06c8 c1					pop bc 
06c9 e1					pop hl 
06ca			 
06ca					; is free? 
06ca fe 00				cp 0 
06cc 20 01				jr nz, .ff1cont 
06ce 13					inc de 
06cf			 
06cf			.ff1cont: 
06cf			 
06cf			 
06cf 3e 40				ld a, STORE_BLOCK_PHY 
06d1 cd bc 0c				call addatohl 
06d4 10 eb				djnz .fb1 
06d6			 
06d6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06d8			.fb2:   	 
06d8 e5					push hl 
06d9 c5					push bc 
06da d5					push de 
06db cd 89 02				call se_readbyte 
06de d1					pop de 
06df c1					pop bc 
06e0 e1					pop hl 
06e1			 
06e1					; is free? 
06e1 fe 00				cp 0 
06e3 20 01				jr nz, .ff2cont 
06e5 13					inc de 
06e6			 
06e6			.ff2cont: 
06e6			 
06e6 3e 40				ld a, STORE_BLOCK_PHY 
06e8 cd bc 0c				call addatohl 
06eb 10 eb				djnz .fb2 
06ed			 
06ed eb				ex de, hl 
06ee c9				ret 
06ef			 
06ef			; Get File ID 
06ef			; ----------- 
06ef			; 
06ef			; With current bank 
06ef			;  
06ef			; Load Block 0 Config 
06ef			; Get max file id number 
06ef			; For each logical block 
06ef			;    Read block file id 
06ef			;      If first block of file and dont have file id 
06ef			;         if file get id and exit 
06ef			 
06ef			 
06ef			 
06ef			 
06ef			; Create File 
06ef			; ----------- 
06ef			; 
06ef			; With current bank  
06ef			; Load Block 0 Config 
06ef			; Get max file id number 
06ef			; Increment file id number 
06ef			; Save Config 
06ef			; Find free block 
06ef			; Set buffer with file name and file id 
06ef			; Write buffer to free block  
06ef			 
06ef			 
06ef			; hl point to file name 
06ef			; hl returns file id 
06ef			 
06ef			; file format: 
06ef			; byte 0 - file id 
06ef			; byte 1 - extent number 
06ef			; byte 2-> data 
06ef			 
06ef			; format for extent number 0: 
06ef			; 
06ef			; byte 0 - file id 
06ef			; byte 1 - extent 0 
06ef			; byte 2 - extent count 
06ef			; byte 3 -> file name and meta data 
06ef			 
06ef			 
06ef			storage_create: 
06ef				if DEBUG_STORESE 
06ef					DMARK "SCR" 
06ef f5				push af  
06f0 3a 04 07			ld a, (.dmark)  
06f3 32 bd fb			ld (debug_mark),a  
06f6 3a 05 07			ld a, (.dmark+1)  
06f9 32 be fb			ld (debug_mark+1),a  
06fc 3a 06 07			ld a, (.dmark+2)  
06ff 32 bf fb			ld (debug_mark+2),a  
0702 18 03			jr .pastdmark  
0704 ..			.dmark: db "SCR"  
0707 f1			.pastdmark: pop af  
0708			endm  
# End of macro DMARK
0708					CALLMONITOR 
0708 cd d4 14			call break_point_state  
070b				endm  
# End of macro CALLMONITOR
070b				endif 
070b			 
070b e5				push hl		; save file name pointer 
070c			 
070c cd ba 03			call storage_get_block_0 
070f			 
070f 3a e8 f9			ld a,(store_page)	; get current file id 
0712 3c				inc a 
0713 32 e8 f9			ld (store_page),a 
0716				 
0716 32 e1 f9			ld (store_tmpid),a			; save id 
0719			 
0719 21 00 00			ld hl, 0 
071c 11 e8 f9			ld de, store_page 
071f				if DEBUG_STORESE 
071f					DMARK "SCw" 
071f f5				push af  
0720 3a 34 07			ld a, (.dmark)  
0723 32 bd fb			ld (debug_mark),a  
0726 3a 35 07			ld a, (.dmark+1)  
0729 32 be fb			ld (debug_mark+1),a  
072c 3a 36 07			ld a, (.dmark+2)  
072f 32 bf fb			ld (debug_mark+2),a  
0732 18 03			jr .pastdmark  
0734 ..			.dmark: db "SCw"  
0737 f1			.pastdmark: pop af  
0738			endm  
# End of macro DMARK
0738					CALLMONITOR 
0738 cd d4 14			call break_point_state  
073b				endm  
# End of macro CALLMONITOR
073b				endif 
073b cd 6e 03			call storage_write_block	 ; save update 
073e			 
073e				if DEBUG_STORESE 
073e 11 e8 f9				ld de, store_page 
0741					DMARK "SCC" 
0741 f5				push af  
0742 3a 56 07			ld a, (.dmark)  
0745 32 bd fb			ld (debug_mark),a  
0748 3a 57 07			ld a, (.dmark+1)  
074b 32 be fb			ld (debug_mark+1),a  
074e 3a 58 07			ld a, (.dmark+2)  
0751 32 bf fb			ld (debug_mark+2),a  
0754 18 03			jr .pastdmark  
0756 ..			.dmark: db "SCC"  
0759 f1			.pastdmark: pop af  
075a			endm  
# End of macro DMARK
075a					CALLMONITOR 
075a cd d4 14			call break_point_state  
075d				endm  
# End of macro CALLMONITOR
075d				endif 
075d				;  
075d				 
075d 21 40 00			ld hl, STORE_BLOCK_PHY 
0760 11 00 00			ld de, 0 
0763 cd 1f 06			call storage_findnextid 
0766			 
0766 22 e6 f9			ld (store_tmppageid), hl    ; save page to use  
0769			 
0769				; TODO detect 0 = no spare blocks 
0769			 
0769				; hl now contains the free page to use for the file header page 
0769			 
0769				if DEBUG_STORESE 
0769				DMARK "SCF" 
0769 f5				push af  
076a 3a 7e 07			ld a, (.dmark)  
076d 32 bd fb			ld (debug_mark),a  
0770 3a 7f 07			ld a, (.dmark+1)  
0773 32 be fb			ld (debug_mark+1),a  
0776 3a 80 07			ld a, (.dmark+2)  
0779 32 bf fb			ld (debug_mark+2),a  
077c 18 03			jr .pastdmark  
077e ..			.dmark: db "SCF"  
0781 f1			.pastdmark: pop af  
0782			endm  
# End of macro DMARK
0782					CALLMONITOR 
0782 cd d4 14			call break_point_state  
0785				endm  
# End of macro CALLMONITOR
0785				endif 
0785			 
0785 22 e6 f9			ld (store_tmppageid), hl 
0788				 
0788 3a e1 f9			ld a,(store_tmpid)    ; get file id 
078b			;	ld a, (store_filecache)			; save to cache 
078b			 
078b 32 e8 f9			ld (store_page),a    ; set page id 
078e 3e 00			ld a, 0			 ; extent 0 is file header 
0790 32 e9 f9			ld (store_page+1), a   ; set file extent 
0793			 
0793 32 ea f9			ld (store_page+2), a   ; extent count for the file 
0796			 
0796			;	inc hl 		; init block 0 of file 
0796			;	inc hl   		; skip file and extent id 
0796			 ;       ld a, 0 
0796			;	ld (hl),a 
0796			;	ld a, (store_filecache+1)  	; save to cache 
0796			 
0796			;	inc hl    ; file name 
0796				 
0796				 
0796 11 eb f9			ld de, store_page+3    ; get buffer for term string to use as file name 
0799				if DEBUG_STORESE 
0799					DMARK "SCc" 
0799 f5				push af  
079a 3a ae 07			ld a, (.dmark)  
079d 32 bd fb			ld (debug_mark),a  
07a0 3a af 07			ld a, (.dmark+1)  
07a3 32 be fb			ld (debug_mark+1),a  
07a6 3a b0 07			ld a, (.dmark+2)  
07a9 32 bf fb			ld (debug_mark+2),a  
07ac 18 03			jr .pastdmark  
07ae ..			.dmark: db "SCc"  
07b1 f1			.pastdmark: pop af  
07b2			endm  
# End of macro DMARK
07b2					CALLMONITOR 
07b2 cd d4 14			call break_point_state  
07b5				endm  
# End of macro CALLMONITOR
07b5				endif 
07b5 e1				pop hl    ; get zero term string 
07b6 e5				push hl 
07b7 3e 00			ld a, 0 
07b9 cd 25 11			call strlent 
07bc 23				inc hl   ; cover zero term 
07bd 06 00			ld b,0 
07bf 4d				ld c,l 
07c0 e1				pop hl 
07c1				;ex de, hl 
07c1				if DEBUG_STORESE 
07c1					DMARK "SCa" 
07c1 f5				push af  
07c2 3a d6 07			ld a, (.dmark)  
07c5 32 bd fb			ld (debug_mark),a  
07c8 3a d7 07			ld a, (.dmark+1)  
07cb 32 be fb			ld (debug_mark+1),a  
07ce 3a d8 07			ld a, (.dmark+2)  
07d1 32 bf fb			ld (debug_mark+2),a  
07d4 18 03			jr .pastdmark  
07d6 ..			.dmark: db "SCa"  
07d9 f1			.pastdmark: pop af  
07da			endm  
# End of macro DMARK
07da					;push af 
07da					;ld a, 'a' 
07da					;ld (debug_mark),a 
07da					;pop af 
07da					CALLMONITOR 
07da cd d4 14			call break_point_state  
07dd				endm  
# End of macro CALLMONITOR
07dd				endif 
07dd ed b0			ldir    ; copy zero term string 
07df				if DEBUG_STORESE 
07df					DMARK "SCA" 
07df f5				push af  
07e0 3a f4 07			ld a, (.dmark)  
07e3 32 bd fb			ld (debug_mark),a  
07e6 3a f5 07			ld a, (.dmark+1)  
07e9 32 be fb			ld (debug_mark+1),a  
07ec 3a f6 07			ld a, (.dmark+2)  
07ef 32 bf fb			ld (debug_mark+2),a  
07f2 18 03			jr .pastdmark  
07f4 ..			.dmark: db "SCA"  
07f7 f1			.pastdmark: pop af  
07f8			endm  
# End of macro DMARK
07f8					CALLMONITOR 
07f8 cd d4 14			call break_point_state  
07fb				endm  
# End of macro CALLMONITOR
07fb				endif 
07fb			 
07fb				; write file header page 
07fb			 
07fb 2a e6 f9			ld hl,(store_tmppageid) 
07fe 11 e8 f9			ld de, store_page 
0801				if DEBUG_STORESE 
0801					DMARK "SCb" 
0801 f5				push af  
0802 3a 16 08			ld a, (.dmark)  
0805 32 bd fb			ld (debug_mark),a  
0808 3a 17 08			ld a, (.dmark+1)  
080b 32 be fb			ld (debug_mark+1),a  
080e 3a 18 08			ld a, (.dmark+2)  
0811 32 bf fb			ld (debug_mark+2),a  
0814 18 03			jr .pastdmark  
0816 ..			.dmark: db "SCb"  
0819 f1			.pastdmark: pop af  
081a			endm  
# End of macro DMARK
081a					;push af 
081a					;ld a, 'b' 
081a					;ld (debug_mark),a 
081a					;pop af 
081a					CALLMONITOR 
081a cd d4 14			call break_point_state  
081d				endm  
# End of macro CALLMONITOR
081d				endif 
081d cd 6e 03			call storage_write_block 
0820			 
0820 3a e1 f9			ld a, (store_tmpid) 
0823 6f				ld l, a 
0824 26 00			ld h,0 
0826				if DEBUG_STORESE 
0826					DMARK "SCz" 
0826 f5				push af  
0827 3a 3b 08			ld a, (.dmark)  
082a 32 bd fb			ld (debug_mark),a  
082d 3a 3c 08			ld a, (.dmark+1)  
0830 32 be fb			ld (debug_mark+1),a  
0833 3a 3d 08			ld a, (.dmark+2)  
0836 32 bf fb			ld (debug_mark+2),a  
0839 18 03			jr .pastdmark  
083b ..			.dmark: db "SCz"  
083e f1			.pastdmark: pop af  
083f			endm  
# End of macro DMARK
083f					CALLMONITOR 
083f cd d4 14			call break_point_state  
0842				endm  
# End of macro CALLMONITOR
0842				endif 
0842 c9				ret 
0843				 
0843			 
0843			 
0843			; 
0843			; Read File 
0843			; 
0843			; h - file id to locate 
0843			; l - extent to locate 
0843			; de - pointer to string to read into 
0843			; 
0843			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0843			storage_read: 
0843 d5				push de 
0844			 
0844			; TODO BUG the above push is it popped before the RET Z? 
0844			 
0844			; TODO how to handle multiple part blocks 
0844			 
0844				; locate file extent to read 
0844			 
0844 5c				ld e, h 
0845 55				ld d, l 
0846 21 40 00			ld hl, STORE_BLOCK_PHY 
0849				if DEBUG_STORESE 
0849					DMARK "SRE" 
0849 f5				push af  
084a 3a 5e 08			ld a, (.dmark)  
084d 32 bd fb			ld (debug_mark),a  
0850 3a 5f 08			ld a, (.dmark+1)  
0853 32 be fb			ld (debug_mark+1),a  
0856 3a 60 08			ld a, (.dmark+2)  
0859 32 bf fb			ld (debug_mark+2),a  
085c 18 03			jr .pastdmark  
085e ..			.dmark: db "SRE"  
0861 f1			.pastdmark: pop af  
0862			endm  
# End of macro DMARK
0862					CALLMONITOR 
0862 cd d4 14			call break_point_state  
0865				endm  
# End of macro CALLMONITOR
0865				endif 
0865 cd 1f 06			call storage_findnextid 
0868			 
0868				if DEBUG_STORESE 
0868					DMARK "SRf" 
0868 f5				push af  
0869 3a 7d 08			ld a, (.dmark)  
086c 32 bd fb			ld (debug_mark),a  
086f 3a 7e 08			ld a, (.dmark+1)  
0872 32 be fb			ld (debug_mark+1),a  
0875 3a 7f 08			ld a, (.dmark+2)  
0878 32 bf fb			ld (debug_mark+2),a  
087b 18 03			jr .pastdmark  
087d ..			.dmark: db "SRf"  
0880 f1			.pastdmark: pop af  
0881			endm  
# End of macro DMARK
0881					CALLMONITOR 
0881 cd d4 14			call break_point_state  
0884				endm  
# End of macro CALLMONITOR
0884				endif 
0884 cd e5 0c			call ishlzero 
0887			;	ld a, l 
0887			;	add h 
0887			;	cp 0 
0887 c8				ret z			; block not found so EOF 
0888			 
0888				; hl contains page number to load 
0888 d1				pop de   ; get storage 
0889 d5				push de 
088a				if DEBUG_STORESE 
088a					DMARK "SRg" 
088a f5				push af  
088b 3a 9f 08			ld a, (.dmark)  
088e 32 bd fb			ld (debug_mark),a  
0891 3a a0 08			ld a, (.dmark+1)  
0894 32 be fb			ld (debug_mark+1),a  
0897 3a a1 08			ld a, (.dmark+2)  
089a 32 bf fb			ld (debug_mark+2),a  
089d 18 03			jr .pastdmark  
089f ..			.dmark: db "SRg"  
08a2 f1			.pastdmark: pop af  
08a3			endm  
# End of macro DMARK
08a3					CALLMONITOR 
08a3 cd d4 14			call break_point_state  
08a6				endm  
# End of macro CALLMONITOR
08a6				endif 
08a6 cd 09 03			call storage_read_block 
08a9			 
08a9			 
08a9			; TODO if block has no zeros then need to read next block  
08a9			 
08a9			 
08a9					 
08a9 e1				pop hl 		 ; return start of data to show as not EOF 
08aa 23				inc hl   ; past file id 
08ab 23				inc hl   ; past ext 
08ac				if DEBUG_STORESE 
08ac					DMARK "SRe" 
08ac f5				push af  
08ad 3a c1 08			ld a, (.dmark)  
08b0 32 bd fb			ld (debug_mark),a  
08b3 3a c2 08			ld a, (.dmark+1)  
08b6 32 be fb			ld (debug_mark+1),a  
08b9 3a c3 08			ld a, (.dmark+2)  
08bc 32 bf fb			ld (debug_mark+2),a  
08bf 18 03			jr .pastdmark  
08c1 ..			.dmark: db "SRe"  
08c4 f1			.pastdmark: pop af  
08c5			endm  
# End of macro DMARK
08c5					CALLMONITOR 
08c5 cd d4 14			call break_point_state  
08c8				endm  
# End of macro CALLMONITOR
08c8				endif 
08c8 c9					ret 
08c9			 
08c9			 
08c9			 
08c9			; 
08c9			; Append File 
08c9			; 
08c9			; hl - file id to locate 
08c9			; de - pointer to (multi block) string to write 
08c9			 
08c9			 
08c9			storage_append: 
08c9				; hl -  file id to append to 
08c9				; de - string to append 
08c9			 
08c9 d5				push de 
08ca				 
08ca				if DEBUG_STORESE 
08ca					DMARK "AP1" 
08ca f5				push af  
08cb 3a df 08			ld a, (.dmark)  
08ce 32 bd fb			ld (debug_mark),a  
08d1 3a e0 08			ld a, (.dmark+1)  
08d4 32 be fb			ld (debug_mark+1),a  
08d7 3a e1 08			ld a, (.dmark+2)  
08da 32 bf fb			ld (debug_mark+2),a  
08dd 18 03			jr .pastdmark  
08df ..			.dmark: db "AP1"  
08e2 f1			.pastdmark: pop af  
08e3			endm  
# End of macro DMARK
08e3					CALLMONITOR 
08e3 cd d4 14			call break_point_state  
08e6				endm  
# End of macro CALLMONITOR
08e6				endif 
08e6			 
08e6 7d				ld a, l 
08e7 32 e1 f9			ld (store_tmpid), a 
08ea			 
08ea				; get file header  
08ea			 
08ea 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08ec 3a e1 f9			ld a, (store_tmpid) 
08ef 5f				ld e, a 
08f0			 
08f0 21 40 00				ld hl, STORE_BLOCK_PHY 
08f3 cd 1f 06				call storage_findnextid 
08f6			 
08f6 22 e6 f9			ld (store_tmppageid), hl 
08f9			 
08f9				; TODO handle file id not found 
08f9			 
08f9				if DEBUG_STORESE 
08f9					DMARK "AP2" 
08f9 f5				push af  
08fa 3a 0e 09			ld a, (.dmark)  
08fd 32 bd fb			ld (debug_mark),a  
0900 3a 0f 09			ld a, (.dmark+1)  
0903 32 be fb			ld (debug_mark+1),a  
0906 3a 10 09			ld a, (.dmark+2)  
0909 32 bf fb			ld (debug_mark+2),a  
090c 18 03			jr .pastdmark  
090e ..			.dmark: db "AP2"  
0911 f1			.pastdmark: pop af  
0912			endm  
# End of macro DMARK
0912					CALLMONITOR 
0912 cd d4 14			call break_point_state  
0915				endm  
# End of macro CALLMONITOR
0915				endif 
0915			 
0915				; update file extent count 
0915			 
0915 11 e8 f9			ld de, store_page 
0918			 
0918 cd 09 03			call storage_read_block 
091b			 
091b				if DEBUG_STORESE 
091b					DMARK "AP3" 
091b f5				push af  
091c 3a 30 09			ld a, (.dmark)  
091f 32 bd fb			ld (debug_mark),a  
0922 3a 31 09			ld a, (.dmark+1)  
0925 32 be fb			ld (debug_mark+1),a  
0928 3a 32 09			ld a, (.dmark+2)  
092b 32 bf fb			ld (debug_mark+2),a  
092e 18 03			jr .pastdmark  
0930 ..			.dmark: db "AP3"  
0933 f1			.pastdmark: pop af  
0934			endm  
# End of macro DMARK
0934					CALLMONITOR 
0934 cd d4 14			call break_point_state  
0937				endm  
# End of macro CALLMONITOR
0937				endif 
0937			;	ld (store_tmppageid), hl 
0937			 
0937 3a ea f9			ld a, (store_page+2) 
093a 3c				inc a 
093b 32 ea f9			ld (store_page+2), a 
093e 32 e0 f9			ld (store_tmpext), a 
0941				 
0941				if DEBUG_STORESE 
0941					DMARK "AP3" 
0941 f5				push af  
0942 3a 56 09			ld a, (.dmark)  
0945 32 bd fb			ld (debug_mark),a  
0948 3a 57 09			ld a, (.dmark+1)  
094b 32 be fb			ld (debug_mark+1),a  
094e 3a 58 09			ld a, (.dmark+2)  
0951 32 bf fb			ld (debug_mark+2),a  
0954 18 03			jr .pastdmark  
0956 ..			.dmark: db "AP3"  
0959 f1			.pastdmark: pop af  
095a			endm  
# End of macro DMARK
095a					CALLMONITOR 
095a cd d4 14			call break_point_state  
095d				endm  
# End of macro CALLMONITOR
095d				endif 
095d 2a e6 f9			ld hl, (store_tmppageid) 
0960 11 e8 f9			ld de, store_page 
0963 cd 6e 03			call storage_write_block 
0966			 
0966				; find free block 
0966			 
0966 11 00 00			ld de, 0			 ; file extent to locate 
0969			 
0969 21 40 00				ld hl, STORE_BLOCK_PHY 
096c cd 1f 06				call storage_findnextid 
096f			 
096f					; TODO handle no space left 
096f					 
096f 22 e6 f9				ld (store_tmppageid), hl 
0972			 
0972				if DEBUG_STORESE 
0972					DMARK "AP4" 
0972 f5				push af  
0973 3a 87 09			ld a, (.dmark)  
0976 32 bd fb			ld (debug_mark),a  
0979 3a 88 09			ld a, (.dmark+1)  
097c 32 be fb			ld (debug_mark+1),a  
097f 3a 89 09			ld a, (.dmark+2)  
0982 32 bf fb			ld (debug_mark+2),a  
0985 18 03			jr .pastdmark  
0987 ..			.dmark: db "AP4"  
098a f1			.pastdmark: pop af  
098b			endm  
# End of macro DMARK
098b					CALLMONITOR 
098b cd d4 14			call break_point_state  
098e				endm  
# End of macro CALLMONITOR
098e				endif 
098e					; init the buffer with zeros so we can id if the buffer is full or not 
098e			 
098e e5					push hl 
098f c5					push bc 
0990			 
0990 21 e8 f9				ld hl, store_page 
0993 06 40				ld b, STORE_BLOCK_PHY 
0995 3e 00				ld a, 0 
0997 77			.zeroblock:	ld (hl), a 
0998 23					inc hl 
0999 10 fc				djnz .zeroblock 
099b			 
099b c1					pop bc 
099c e1					pop hl 
099d			 
099d					; construct block 
099d			 
099d 3a e1 f9				ld a, (store_tmpid) 
09a0 32 e8 f9				ld (store_page), a   ; file id 
09a3 3a e0 f9				ld a, (store_tmpext)   ; extent for this block 
09a6 32 e9 f9				ld (store_page+1), a 
09a9			 
09a9 e1					pop hl    ; get string to write 
09aa 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09ac 11 ea f9				ld de, store_page+2 
09af			 
09af				if DEBUG_STORESE 
09af					DMARK "AP5" 
09af f5				push af  
09b0 3a c4 09			ld a, (.dmark)  
09b3 32 bd fb			ld (debug_mark),a  
09b6 3a c5 09			ld a, (.dmark+1)  
09b9 32 be fb			ld (debug_mark+1),a  
09bc 3a c6 09			ld a, (.dmark+2)  
09bf 32 bf fb			ld (debug_mark+2),a  
09c2 18 03			jr .pastdmark  
09c4 ..			.dmark: db "AP5"  
09c7 f1			.pastdmark: pop af  
09c8			endm  
# End of macro DMARK
09c8					CALLMONITOR 
09c8 cd d4 14			call break_point_state  
09cb				endm  
# End of macro CALLMONITOR
09cb				endif 
09cb			 
09cb			 
09cb			 
09cb					; fill buffer with data until end of string or full block 
09cb			 
09cb 7e			.appd:		ld a, (hl) 
09cc 12					ld (de), a 
09cd fe 00				cp 0 
09cf 28 04				jr z, .appdone 
09d1 23					inc hl 
09d2 13					inc de 
09d3 10 f6				djnz .appd 
09d5			 
09d5 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09d6 f5					push af   		; save last byte dumped 
09d7			 
09d7			 
09d7 2a e6 f9			ld hl, (store_tmppageid) 
09da 11 e8 f9			ld de, store_page 
09dd				if DEBUG_STORESE 
09dd					DMARK "AP6" 
09dd f5				push af  
09de 3a f2 09			ld a, (.dmark)  
09e1 32 bd fb			ld (debug_mark),a  
09e4 3a f3 09			ld a, (.dmark+1)  
09e7 32 be fb			ld (debug_mark+1),a  
09ea 3a f4 09			ld a, (.dmark+2)  
09ed 32 bf fb			ld (debug_mark+2),a  
09f0 18 03			jr .pastdmark  
09f2 ..			.dmark: db "AP6"  
09f5 f1			.pastdmark: pop af  
09f6			endm  
# End of macro DMARK
09f6					CALLMONITOR 
09f6 cd d4 14			call break_point_state  
09f9				endm  
# End of macro CALLMONITOR
09f9				endif 
09f9 cd 6e 03				call storage_write_block 
09fc			 
09fc			 
09fc				; was that a full block of data written? 
09fc				; any more to write out? 
09fc			 
09fc				; if yes then set vars and jump to start of function again 
09fc			 
09fc f1					pop af 
09fd d1					pop de 
09fe			 
09fe fe 00				cp 0		 ; no, string was fully written 
0a00 c8					ret z 
0a01			 
0a01					; setup vars for next cycle 
0a01			 
0a01 3a e1 f9				ld a, (store_tmpid) 
0a04 6f					ld l, a 
0a05 26 00				ld h, 0 
0a07			 
0a07 c3 c9 08			 	jp storage_append	 ; yes, need to write out some more 
0a0a			 
0a0a			 
0a0a			 
0a0a			 
0a0a			 
0a0a			 
0a0a			 
0a0a			if DEBUG_STORECF 
0a0a			storageput:	 
0a0a					ret 
0a0a			storageread: 
0a0a					ld hl, store_page 
0a0a					ld b, 200 
0a0a					ld a,0 
0a0a			.src:		ld (hl),a 
0a0a					inc hl 
0a0a					djnz .src 
0a0a					 
0a0a			 
0a0a					ld de, 0 
0a0a					ld bc, 1 
0a0a					ld hl, store_page 
0a0a					call cfRead 
0a0a			 
0a0a				call cfGetError 
0a0a				ld hl,scratch 
0a0a				call hexout 
0a0a				ld hl, scratch+2 
0a0a				ld a, 0 
0a0a				ld (hl),a 
0a0a				ld de, scratch 
0a0a				ld a,display_row_1 
0a0a				call str_at_display 
0a0a				call update_display 
0a0a			 
0a0a					ld hl, store_page 
0a0a					ld (os_cur_ptr),hl 
0a0a			 
0a0a					ret 
0a0a			endif 
0a0a			 
0a0a			 
0a0a			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a0a			 
0a0a			storage_clear_page: 
0a0a e5				push hl 
0a0b d5				push de 
0a0c c5				push bc 
0a0d 21 e8 f9			ld hl, store_page 
0a10 3e 00			ld a, 0 
0a12 77				ld (hl), a 
0a13			 
0a13 11 e9 f9			ld de, store_page+1 
0a16 01 40 00			ld bc, STORE_BLOCK_PHY 
0a19			 
0a19 ed b0			ldir 
0a1b				 
0a1b c1				pop bc 
0a1c d1				pop de 
0a1d e1				pop hl 
0a1e c9				ret 
0a1f			 
0a1f			; eof 
# End of file firmware_storage.asm
0a1f			  
0a1f			; support routines for above hardware abstraction layer  
0a1f			  
0a1f			include "firmware_general.asm"        ; general support functions  
0a1f			 
0a1f			 
0a1f			 
0a1f			; Delay loops 
0a1f			 
0a1f			 
0a1f			 
0a1f			aDelayInMS: 
0a1f c5				push bc 
0a20 47				ld b,a 
0a21			msdelay: 
0a21 c5				push bc 
0a22				 
0a22			 
0a22 01 41 00			ld bc,041h 
0a25 cd 3d 0a			call delayloop 
0a28 c1				pop bc 
0a29 05				dec b 
0a2a 20 f5			jr nz,msdelay 
0a2c			 
0a2c			;if CPU_CLOCK_8MHZ 
0a2c			;msdelay8: 
0a2c			;	push bc 
0a2c			;	 
0a2c			; 
0a2c			;	ld bc,041h 
0a2c			;	call delayloop 
0a2c			;	pop bc 
0a2c			;	dec b 
0a2c			;	jr nz,msdelay8 
0a2c			;endif 
0a2c			 
0a2c			 
0a2c c1				pop bc 
0a2d c9				ret 
0a2e			 
0a2e			 
0a2e			delay250ms: 
0a2e				;push de 
0a2e 01 00 40			ld bc, 04000h 
0a31 c3 3d 0a			jp delayloop 
0a34			delay500ms: 
0a34				;push de 
0a34 01 00 80			ld bc, 08000h 
0a37 c3 3d 0a			jp delayloop 
0a3a			delay1s: 
0a3a				;push bc 
0a3a			   ; Clobbers A, d and e 
0a3a 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a3d			delayloop: 
0a3d c5			    push bc 
0a3e			 
0a3e			if BASE_CPM 
0a3e				ld bc, CPM_DELAY_TUNE 
0a3e			.cpmloop: 
0a3e				push bc 
0a3e			 
0a3e			endif 
0a3e			 
0a3e			 
0a3e			 
0a3e			delayloopi: 
0a3e			;	push bc 
0a3e			;.dl: 
0a3e cb 47		    bit     0,a    	; 8 
0a40 cb 47		    bit     0,a    	; 8 
0a42 cb 47		    bit     0,a    	; 8 
0a44 e6 ff		    and     255  	; 7 
0a46 0b			    dec     bc      	; 6 
0a47 79			    ld      a,c     	; 4 
0a48 b0			    or      b     	; 4 
0a49 c2 3e 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a4c			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a4c				;pop de 
0a4c			;pop bc 
0a4c			 
0a4c			if BASE_CPM 
0a4c				pop bc 
0a4c				 
0a4c			    dec     bc      	; 6 
0a4c			    ld      a,c     	; 4 
0a4c			    or      b     	; 4 
0a4c			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a4c				 
0a4c			 
0a4c			endif 
0a4c			;if CPU_CLOCK_8MHZ 
0a4c			;    pop bc 
0a4c			;    push bc 
0a4c			;.dl8: 
0a4c			;    bit     0,a    	; 8 
0a4c			;    bit     0,a    	; 8 
0a4c			;    bit     0,a    	; 8 
0a4c			;    and     255  	; 7 
0a4c			;    dec     bc      	; 6 
0a4c			;    ld      a,c     	; 4 
0a4c			;    or      b     	; 4 
0a4c			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a4c			;endif 
0a4c			 
0a4c			;if CPU_CLOCK_10MHZ 
0a4c			;    pop bc 
0a4c			;    push bc 
0a4c			;.dl8: 
0a4c			;    bit     0,a    	; 8 
0a4c			;    bit     0,a    	; 8 
0a4c			;    bit     0,a    	; 8 
0a4c			;    and     255  	; 7 
0a4c			;    dec     bc      	; 6 
0a4c			;    ld      a,c     	; 4 
0a4c			;    or      b     	; 4 
0a4c			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a4c			;endif 
0a4c c1			    pop bc 
0a4d			 
0a4d c9				ret 
0a4e			 
0a4e			 
0a4e			 
0a4e			; eof 
# End of file firmware_general.asm
0a4e			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a4e			; display routines that use the physical hardware abstraction layer 
0a4e			 
0a4e			 
0a4e			; TODO windowing? 
0a4e			 
0a4e			; TODO scroll line up 
0a4e			 
0a4e			scroll_up: 
0a4e			 
0a4e e5				push hl 
0a4f d5				push de 
0a50 c5				push bc 
0a51			 
0a51				; get frame buffer  
0a51			 
0a51 2a 5e fa			ld hl, (display_fb_active) 
0a54 e5				push hl    ; future de destination 
0a55			 
0a55 11 14 00			ld  de, display_cols 
0a58 19				add hl, de 
0a59			 
0a59 d1				pop de 
0a5a			 
0a5a				;ex de, hl 
0a5a 01 4f 00			ld bc, display_fb_len -1  
0a5d			;if DEBUG_FORTH_WORDS 
0a5d			;	DMARK "SCL" 
0a5d			;	CALLMONITOR 
0a5d			;endif	 
0a5d ed b0			ldir 
0a5f			 
0a5f				; wipe bottom row 
0a5f			 
0a5f			 
0a5f 2a 5e fa			ld hl, (display_fb_active) 
0a62 11 50 00			ld de, display_cols*display_rows 
0a65 19				add hl, de 
0a66 06 14			ld b, display_cols 
0a68 3e 20			ld a, ' ' 
0a6a			.scwipe: 
0a6a 77				ld (hl), a 
0a6b 2b				dec hl 
0a6c 10 fc			djnz .scwipe 
0a6e			 
0a6e				;pop hl 
0a6e			 
0a6e c1				pop bc 
0a6f d1				pop de 
0a70 e1				pop hl 
0a71			 
0a71 c9				ret 
0a72			 
0a72			 
0a72			;scroll_upo: 
0a72			;	ld de, display_row_1 
0a72			 ;	ld hl, display_row_2 
0a72			;	ld bc, display_cols 
0a72			;	ldir 
0a72			;	ld de, display_row_2 
0a72			 ;	ld hl, display_row_3 
0a72			;	ld bc, display_cols 
0a72			;	ldir 
0a72			;	ld de, display_row_3 
0a72			 ;	ld hl, display_row_4 
0a72			;	ld bc, display_cols 
0a72			;	ldir 
0a72			 
0a72			; TODO clear row 4 
0a72			 
0a72			;	ret 
0a72			 
0a72				 
0a72			scroll_down: 
0a72			 
0a72 e5				push hl 
0a73 d5				push de 
0a74 c5				push bc 
0a75			 
0a75				; get frame buffer  
0a75			 
0a75 2a 5e fa			ld hl, (display_fb_active) 
0a78			 
0a78 11 4f 00			ld de, display_fb_len - 1 
0a7b 19				add hl, de 
0a7c			 
0a7c e5			push hl    ; future de destination 
0a7d			 
0a7d 11 14 00			ld  de, display_cols 
0a80 ed 52			sbc hl, de 
0a82			 
0a82			 
0a82 d1				pop de 
0a83			 
0a83			;	ex de, hl 
0a83 01 4f 00			ld bc, display_fb_len -1  
0a86			 
0a86			 
0a86				 
0a86			 
0a86 ed b0			ldir 
0a88			 
0a88				; wipe bottom row 
0a88			 
0a88			 
0a88			;	ld hl, (display_fb_active) 
0a88			;;	ld de, display_cols*display_rows 
0a88			;;	add hl, de 
0a88			;	ld b, display_cols 
0a88			;	ld a, ' ' 
0a88			;.scwiped: 
0a88			;	ld (hl), a 
0a88			;	dec hl 
0a88			;	djnz .scwiped 
0a88			 
0a88				;pop hl 
0a88			 
0a88 c1				pop bc 
0a89 d1				pop de 
0a8a e1				pop hl 
0a8b			 
0a8b c9				ret 
0a8c			;scroll_down: 
0a8c			;	ld de, display_row_4 
0a8c			;	ld hl, display_row_3 
0a8c			;	ld bc, display_cols 
0a8c			;	ldir 
0a8c			;	ld de, display_row_3 
0a8c			; 	ld hl, display_row_2 
0a8c			;	ld bc, display_cols 
0a8c			;	ldir 
0a8c			;	ld de, display_row_2 
0a8c			;	ld hl, display_row_1 
0a8c			;	ld bc, display_cols 
0a8c			;	ldir 
0a8c			;;; TODO clear row 1 
0a8c			;	ret 
0a8c			 
0a8c			 
0a8c			 
0a8c			 
0a8c			 
0a8c			; clear active frame buffer 
0a8c			 
0a8c			clear_display: 
0a8c 3e 20			ld a, ' ' 
0a8e c3 91 0a			jp fill_display 
0a91			 
0a91			; fill active frame buffer with a char in A 
0a91			 
0a91			fill_display: 
0a91 06 50			ld b,display_fb_len 
0a93 2a 5e fa			ld hl, (display_fb_active) 
0a96 77			.fd1:	ld (hl),a 
0a97 23				inc hl 
0a98 10 fc			djnz .fd1 
0a9a 23				inc hl 
0a9b 3e 00			ld a,0 
0a9d 77				ld (hl),a 
0a9e			 
0a9e			 
0a9e c9				ret 
0a9f			; Write string (DE) at pos (A) to active frame buffer 
0a9f			 
0a9f 2a 5e fa		str_at_display:    ld hl,(display_fb_active) 
0aa2 06 00					ld b,0 
0aa4 4f					ld c,a 
0aa5 09					add hl,bc 
0aa6 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0aa7 b7			            OR   A              ;Null terminator? 
0aa8 c8			            RET  Z              ;Yes, so finished 
0aa9 77					ld (hl),a 
0aaa 23				inc hl 
0aab 13			            INC  DE             ;Point to next character 
0aac 18 f8		            JR   .sad1     ;Repeat 
0aae c9					ret 
0aaf			 
0aaf			; using current frame buffer write to physical display 
0aaf			 
0aaf			update_display: 
0aaf e5				push hl 
0ab0 2a 5e fa			ld hl, (display_fb_active) 
0ab3 cd 94 61			call write_display 
0ab6 e1				pop hl 
0ab7 c9				ret 
0ab8			 
0ab8			; TODO scrolling 
0ab8			 
0ab8			 
0ab8			; move cursor right one char 
0ab8			cursor_right: 
0ab8			 
0ab8				; TODO shift right 
0ab8				; TODO if beyond max col 
0ab8				; TODO       cursor_next_line 
0ab8			 
0ab8 c9				ret 
0ab9			 
0ab9			 
0ab9			cursor_next_line: 
0ab9				; TODO first char 
0ab9				; TODO line down 
0ab9				; TODO if past last row 
0ab9				; TODO    scroll up 
0ab9			 
0ab9 c9				ret 
0aba			 
0aba			cursor_left: 
0aba				; TODO shift left 
0aba				; TODO if beyond left  
0aba				; TODO     cursor prev line 
0aba				 
0aba c9				ret 
0abb			 
0abb			cursor_prev_line: 
0abb				; TODO last char 
0abb				; TODO line up 
0abb				; TODO if past first row 
0abb				; TODO   scroll down 
0abb			 
0abb c9				ret 
0abc			 
0abc			 
0abc			cout: 
0abc				; A - char 
0abc c9				ret 
0abd			 
0abd			 
0abd			; Display a menu and allow item selection (optional toggle items) 
0abd			; 
0abd			; format: 
0abd			; hl pointer to word array with zero term for items 
0abd			; e.g.    db item1 
0abd			;         db .... 
0abd			;         db 0 
0abd			; 
0abd			; a = starting menu item  
0abd			; 
0abd			; de = pointer item toggle array   (todo) 
0abd			; 
0abd			; returns item selected in a 1-... 
0abd			; returns 0 if back button pressed 
0abd			; 
0abd			; NOTE: Uses system frame buffer to display 
0abd			 
0abd			 
0abd			 
0abd			 
0abd			 
0abd			 
0abd			menu: 
0abd			 
0abd					; keep array pointer 
0abd			 
0abd 22 e6 f9				ld (store_tmp1), hl 
0ac0 32 e4 f9				ld (store_tmp2), a 
0ac3			 
0ac3					; check for key bounce 
0ac3			 
0ac3			if BASE_KEV 
0ac3			 
0ac3 cd 49 63		.mbounce:	call cin 
0ac6 fe 00				cp 0 
0ac8 20 f9				jr nz, .mbounce 
0aca			endif 
0aca					; for ease use ex 
0aca			 
0aca					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0aca 21 53 fb				ld hl, display_fb0 
0acd 22 5e fa				ld (display_fb_active), hl 
0ad0			 
0ad0 cd 8c 0a		.mloop:		call clear_display 
0ad3 cd af 0a				call update_display 
0ad6			 
0ad6					; draw selection id '>' at 1 
0ad6			 
0ad6					; init start of list display 
0ad6			 
0ad6 3e 05				ld a, 5 
0ad8 32 e2 f9				ld (store_tmp3), a   ; display row count 
0adb 3a e4 f9				ld a,( store_tmp2) 
0ade 32 e5 f9				ld (store_tmp2+1), a   ; display item count 
0ae1			 
0ae1					 
0ae1			.mitem:	 
0ae1			 
0ae1			 
0ae1 3a e5 f9				ld a,(store_tmp2+1) 
0ae4 6f					ld l, a 
0ae5 26 00				ld h, 0 
0ae7 29					add hl, hl 
0ae8 ed 5b e6 f9			ld de, (store_tmp1) 
0aec 19					add hl, de 
0aed 7e					ld a, (hl) 
0aee 23					inc hl 
0aef 66					ld h,(hl) 
0af0 6f					ld l, a 
0af1			 
0af1 cd e5 0c				call ishlzero 
0af4 28 1a				jr z, .mdone 
0af6			 
0af6 eb					ex de, hl 
0af7 3a e2 f9				ld a, (store_tmp3) 
0afa cd 9f 0a				call str_at_display 
0afd					 
0afd			 
0afd					; next item 
0afd 3a e5 f9				ld a, (store_tmp2+1) 
0b00 3c					inc a 
0b01 32 e5 f9				ld (store_tmp2+1), a   ; display item count 
0b04			 
0b04			 		; next row 
0b04			 
0b04 3a e2 f9				ld a, (store_tmp3) 
0b07 c6 14				add display_cols 
0b09 32 e2 f9				ld (store_tmp3), a 
0b0c			 
0b0c					; at end of screen? 
0b0c			 
0b0c fe 10				cp display_rows*4 
0b0e 20 d1				jr nz, .mitem 
0b10			 
0b10			 
0b10			.mdone: 
0b10 cd e5 0c				call ishlzero 
0b13 28 08				jr z, .nodn 
0b15			 
0b15 3e 3c				ld a, display_row_4 
0b17 11 92 0b				ld de, .mdown 
0b1a cd 9f 0a				call str_at_display 
0b1d			 
0b1d					; draw options to fill the screens with active item on line 1 
0b1d					; if current option is 2 or more then display ^ in top 
0b1d			 
0b1d 3a e4 f9		.nodn:		ld a, (store_tmp2) 
0b20 fe 00				cp 0 
0b22 28 08				jr z, .noup 
0b24			 
0b24 3e 00				ld a, 0 
0b26 11 90 0b				ld de, .mup 
0b29 cd 9f 0a				call str_at_display 
0b2c			 
0b2c 3e 02		.noup:		ld a, 2 
0b2e 11 8e 0b				ld de, .msel 
0b31 cd 9f 0a				call str_at_display 
0b34			 
0b34					; if current option + 1 is not null then display V in bottom 
0b34					; get key 
0b34 cd af 0a				call update_display 
0b37			 
0b37			 
0b37					; handle key 
0b37			 
0b37 cd 38 63				call cin_wait 
0b3a			 
0b3a fe 05				cp KEY_UP 
0b3c 28 27				jr z, .mgoup 
0b3e fe 61				cp 'a' 
0b40 28 23				jr z, .mgoup 
0b42 fe 0a				cp KEY_DOWN 
0b44 28 2e				jr z, .mgod 
0b46 fe 7a				cp 'z' 
0b48 28 2a				jr z, .mgod 
0b4a fe 20				cp ' ' 
0b4c 28 30				jr z, .goend 
0b4e fe 0d				cp KEY_CR 
0b50 28 2c				jr z, .goend 
0b52 fe 71				cp 'q' 
0b54 28 0b				jr z, .goback 
0b56			 
0b56 fe 0b				cp KEY_LEFT 
0b58 28 07				jr z, .goback 
0b5a fe 08				cp KEY_BS 
0b5c 28 03				jr z, .goback 
0b5e c3 d0 0a				jp .mloop 
0b61			 
0b61			.goback: 
0b61 3e 00			ld a, 0 
0b63 18 1d			jr .goend2 
0b65			 
0b65				; move up one 
0b65			.mgoup: 
0b65 3a e4 f9				ld a, (store_tmp2) 
0b68 fe 00				cp 0 
0b6a ca d0 0a				jp z, .mloop 
0b6d 3d					dec a 
0b6e 32 e4 f9				ld (store_tmp2), a 
0b71 c3 d0 0a				jp .mloop 
0b74			 
0b74				; move down one 
0b74			.mgod: 
0b74 3a e4 f9				ld a, (store_tmp2) 
0b77 3c					inc a 
0b78 32 e4 f9				ld (store_tmp2), a 
0b7b c3 d0 0a				jp .mloop 
0b7e			 
0b7e			 
0b7e			.goend: 
0b7e					; get selected item number 
0b7e			 
0b7e 3a e4 f9				ld a, (store_tmp2) 
0b81 3c					inc a 
0b82			 
0b82			.goend2: 
0b82 f5					push af 
0b83			 
0b83					; restore active fb 
0b83					; TODO BUG assumes fb1 
0b83			 
0b83 21 02 fb				ld hl, display_fb1 
0b86 22 5e fa				ld (display_fb_active), hl 
0b89			 
0b89					; restore main regs 
0b89			 
0b89			 
0b89 cd af 0a				call update_display 
0b8c			 
0b8c f1					pop af 
0b8d			 
0b8d c9				ret 
0b8e			 
0b8e .. 00		.msel:   db ">",0 
0b90 .. 00		.mup:   db "^",0 
0b92 .. 00		.mdown:   db "v",0 
0b94			 
0b94			 
0b94			; eof 
0b94			 
# End of file firmware_display.asm
0b94			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0b94			; random number generators 
0b94			 
0b94			 
0b94			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0b94			 
0b94			 
0b94			;-----> Generate a random number 
0b94			; output a=answer 0<=a<=255 
0b94			; all registers are preserved except: af 
0b94			random: 
0b94 e5			        push    hl 
0b95 d5			        push    de 
0b96 2a 40 fa		        ld      hl,(randData) 
0b99 ed 5f		        ld      a,r 
0b9b 57			        ld      d,a 
0b9c 5e			        ld      e,(hl) 
0b9d 19			        add     hl,de 
0b9e 85			        add     a,l 
0b9f ac			        xor     h 
0ba0 22 40 fa		        ld      (randData),hl 
0ba3 d1			        pop     de 
0ba4 e1			        pop     hl 
0ba5 c9			        ret 
0ba6			 
0ba6			 
0ba6			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0ba6			 
0ba6			 
0ba6			 
0ba6			;------LFSR------ 
0ba6			;James Montelongo 
0ba6			;optimized by Spencer Putt 
0ba6			;out: 
0ba6			; a = 8 bit random number 
0ba6			RandLFSR: 
0ba6 21 46 fa		        ld hl,LFSRSeed+4 
0ba9 5e			        ld e,(hl) 
0baa 23			        inc hl 
0bab 56			        ld d,(hl) 
0bac 23			        inc hl 
0bad 4e			        ld c,(hl) 
0bae 23			        inc hl 
0baf 7e			        ld a,(hl) 
0bb0 47			        ld b,a 
0bb1 cb 13		        rl e  
0bb3 cb 12			rl d 
0bb5 cb 11		        rl c  
0bb7 17				rla 
0bb8 cb 13		        rl e  
0bba cb 12			rl d 
0bbc cb 11		        rl c  
0bbe 17				rla 
0bbf cb 13		        rl e  
0bc1 cb 12			rl d 
0bc3 cb 11		        rl c  
0bc5 17				rla 
0bc6 67			        ld h,a 
0bc7 cb 13		        rl e  
0bc9 cb 12			rl d 
0bcb cb 11		        rl c  
0bcd 17				rla 
0bce a8			        xor b 
0bcf cb 13		        rl e  
0bd1 cb 12			rl d 
0bd3 ac			        xor h 
0bd4 a9			        xor c 
0bd5 aa			        xor d 
0bd6 21 48 fa		        ld hl,LFSRSeed+6 
0bd9 11 49 fa		        ld de,LFSRSeed+7 
0bdc 01 07 00		        ld bc,7 
0bdf ed b8		        lddr 
0be1 12			        ld (de),a 
0be2 c9			        ret 
0be3			 
0be3			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0be3			 
0be3			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0be3			 
0be3			 
0be3			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0be3			 
0be3			prng16: 
0be3			;Inputs: 
0be3			;   (seed1) contains a 16-bit seed value 
0be3			;   (seed2) contains a NON-ZERO 16-bit seed value 
0be3			;Outputs: 
0be3			;   HL is the result 
0be3			;   BC is the result of the LCG, so not that great of quality 
0be3			;   DE is preserved 
0be3			;Destroys: 
0be3			;   AF 
0be3			;cycle: 4,294,901,760 (almost 4.3 billion) 
0be3			;160cc 
0be3			;26 bytes 
0be3 2a 3a fa		    ld hl,(seed1) 
0be6 44			    ld b,h 
0be7 4d			    ld c,l 
0be8 29			    add hl,hl 
0be9 29			    add hl,hl 
0bea 2c			    inc l 
0beb 09			    add hl,bc 
0bec 22 3a fa		    ld (seed1),hl 
0bef 2a 38 fa		    ld hl,(seed2) 
0bf2 29			    add hl,hl 
0bf3 9f			    sbc a,a 
0bf4 e6 2d		    and %00101101 
0bf6 ad			    xor l 
0bf7 6f			    ld l,a 
0bf8 22 38 fa		    ld (seed2),hl 
0bfb 09			    add hl,bc 
0bfc c9			    ret 
0bfd			 
0bfd			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0bfd			 
0bfd			rand32: 
0bfd			;Inputs: 
0bfd			;   (seed1_0) holds the lower 16 bits of the first seed 
0bfd			;   (seed1_1) holds the upper 16 bits of the first seed 
0bfd			;   (seed2_0) holds the lower 16 bits of the second seed 
0bfd			;   (seed2_1) holds the upper 16 bits of the second seed 
0bfd			;   **NOTE: seed2 must be non-zero 
0bfd			;Outputs: 
0bfd			;   HL is the result 
0bfd			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0bfd			;Destroys: 
0bfd			;   AF 
0bfd			;Tested and passes all CAcert tests 
0bfd			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0bfd			;it has a period of 18,446,744,069,414,584,320 
0bfd			;roughly 18.4 quintillion. 
0bfd			;LFSR taps: 0,2,6,7  = 11000101 
0bfd			;291cc 
0bfd			;seed1_0=$+1 
0bfd			;    ld hl,12345 
0bfd			;seed1_1=$+1 
0bfd			;    ld de,6789 
0bfd			;    ld b,h 
0bfd			;    ld c,l 
0bfd			;    add hl,hl \ rl e \ rl d 
0bfd			;    add hl,hl \ rl e \ rl d 
0bfd			;    inc l 
0bfd			;    add hl,bc 
0bfd			;    ld (seed1_0),hl 
0bfd			;    ld hl,(seed1_1) 
0bfd			;    adc hl,de 
0bfd			;    ld (seed1_1),hl 
0bfd			;    ex de,hl 
0bfd			;seed2_0=$+1 
0bfd			;    ld hl,9876 
0bfd			;seed2_1=$+1 
0bfd			;    ld bc,54321 
0bfd			;    add hl,hl \ rl c \ rl b 
0bfd			;    ld (seed2_1),bc 
0bfd			;    sbc a,a 
0bfd			;    and %11000101 
0bfd			;    xor l 
0bfd			;    ld l,a 
0bfd			;    ld (seed2_0),hl 
0bfd			;    ex de,hl 
0bfd			;    add hl,bc 
0bfd			;    ret 
0bfd			; 
0bfd			 
0bfd			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0bfd			; 20 bytes, 86 cycles (excluding ret) 
0bfd			 
0bfd			; returns   hl = pseudorandom number 
0bfd			; corrupts   a 
0bfd			 
0bfd			; generates 16-bit pseudorandom numbers with a period of 65535 
0bfd			; using the xorshift method: 
0bfd			 
0bfd			; hl ^= hl << 7 
0bfd			; hl ^= hl >> 9 
0bfd			; hl ^= hl << 8 
0bfd			 
0bfd			; some alternative shift triplets which also perform well are: 
0bfd			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0bfd			 
0bfd			;  org 32768 
0bfd			 
0bfd			xrnd: 
0bfd 2a 3e fa		  ld hl,(xrandc)       ; seed must not be 0 
0c00 3e 00		  ld a,0 
0c02 bd			  cp l 
0c03 20 02		  jr nz, .xrnd1 
0c05 2e 01		  ld l, 1 
0c07			.xrnd1: 
0c07			 
0c07 7c			  ld a,h 
0c08 1f			  rra 
0c09 7d			  ld a,l 
0c0a 1f			  rra 
0c0b ac			  xor h 
0c0c 67			  ld h,a 
0c0d 7d			  ld a,l 
0c0e 1f			  rra 
0c0f 7c			  ld a,h 
0c10 1f			  rra 
0c11 ad			  xor l 
0c12 6f			  ld l,a 
0c13 ac			  xor h 
0c14 67			  ld h,a 
0c15			 
0c15 22 3e fa		  ld (xrandc),hl 
0c18			 
0c18 c9			  ret 
0c19			;  
0c19			 
0c19			 
0c19			;;;; int maths 
0c19			 
0c19			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c19			; Divide 16-bit values (with 16-bit result) 
0c19			; In: Divide BC by divider DE 
0c19			; Out: BC = result, HL = rest 
0c19			; 
0c19			Div16: 
0c19 21 00 00		    ld hl,0 
0c1c 78			    ld a,b 
0c1d 06 08		    ld b,8 
0c1f			Div16_Loop1: 
0c1f 17			    rla 
0c20 ed 6a		    adc hl,hl 
0c22 ed 52		    sbc hl,de 
0c24 30 01		    jr nc,Div16_NoAdd1 
0c26 19			    add hl,de 
0c27			Div16_NoAdd1: 
0c27 10 f6		    djnz Div16_Loop1 
0c29 17			    rla 
0c2a 2f			    cpl 
0c2b 47			    ld b,a 
0c2c 79			    ld a,c 
0c2d 48			    ld c,b 
0c2e 06 08		    ld b,8 
0c30			Div16_Loop2: 
0c30 17			    rla 
0c31 ed 6a		    adc hl,hl 
0c33 ed 52		    sbc hl,de 
0c35 30 01		    jr nc,Div16_NoAdd2 
0c37 19			    add hl,de 
0c38			Div16_NoAdd2: 
0c38 10 f6		    djnz Div16_Loop2 
0c3a 17			    rla 
0c3b 2f			    cpl 
0c3c 41			    ld b,c 
0c3d 4f			    ld c,a 
0c3e c9			ret 
0c3f			 
0c3f			 
0c3f			;http://z80-heaven.wikidot.com/math 
0c3f			; 
0c3f			;Inputs: 
0c3f			;     DE and A are factors 
0c3f			;Outputs: 
0c3f			;     A is not changed 
0c3f			;     B is 0 
0c3f			;     C is not changed 
0c3f			;     DE is not changed 
0c3f			;     HL is the product 
0c3f			;Time: 
0c3f			;     342+6x 
0c3f			; 
0c3f			Mult16: 
0c3f			 
0c3f 06 08		     ld b,8          ;7           7 
0c41 21 00 00		     ld hl,0         ;10         10 
0c44 29			       add hl,hl     ;11*8       88 
0c45 07			       rlca          ;4*8        32 
0c46 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0c48 19			         add hl,de   ;--         -- 
0c49 10 f9		       djnz $-5      ;13*7+8     99 
0c4b c9			ret 
0c4c			 
0c4c			; 
0c4c			; Square root of 16-bit value 
0c4c			; In:  HL = value 
0c4c			; Out:  D = result (rounded down) 
0c4c			; 
0c4c			;Sqr16: 
0c4c			;    ld de,#0040 
0c4c			;    ld a,l 
0c4c			;    ld l,h 
0c4c			;    ld h,d 
0c4c			;    or a 
0c4c			;    ld b,8 
0c4c			;Sqr16_Loop: 
0c4c			;    sbc hl,de 
0c4c			;    jr nc,Sqr16_Skip 
0c4c			;    add hl,de 
0c4c			;Sqr16_Skip: 
0c4c			;    ccf 
0c4c			;    rl d 
0c4c			;    add a,a 
0c4c			;    adc hl,hl 
0c4c			;    add a,a 
0c4c			;    adc hl,hl 
0c4c			;    djnz Sqr16_Loop 
0c4c			;    ret 
0c4c			; 
0c4c			; 
0c4c			; Divide 8-bit values 
0c4c			; In: Divide E by divider C 
0c4c			; Out: A = result, B = rest 
0c4c			; 
0c4c			Div8: 
0c4c af			    xor a 
0c4d 06 08		    ld b,8 
0c4f			Div8_Loop: 
0c4f cb 13		    rl e 
0c51 17			    rla 
0c52 91			    sub c 
0c53 30 01		    jr nc,Div8_NoAdd 
0c55 81			    add a,c 
0c56			Div8_NoAdd: 
0c56 10 f7		    djnz Div8_Loop 
0c58 47			    ld b,a 
0c59 7b			    ld a,e 
0c5a 17			    rla 
0c5b 2f			    cpl 
0c5c c9			    ret 
0c5d			 
0c5d			; 
0c5d			; Multiply 8-bit value with a 16-bit value (unrolled) 
0c5d			; In: Multiply A with DE 
0c5d			; Out: HL = result 
0c5d			; 
0c5d			Mult12U: 
0c5d 2e 00		    ld l,0 
0c5f 87			    add a,a 
0c60 30 01		    jr nc,Mult12U_NoAdd0 
0c62 19			    add hl,de 
0c63			Mult12U_NoAdd0: 
0c63 29			    add hl,hl 
0c64 87			    add a,a 
0c65 30 01		    jr nc,Mult12U_NoAdd1 
0c67 19			    add hl,de 
0c68			Mult12U_NoAdd1: 
0c68 29			    add hl,hl 
0c69 87			    add a,a 
0c6a 30 01		    jr nc,Mult12U_NoAdd2 
0c6c 19			    add hl,de 
0c6d			Mult12U_NoAdd2: 
0c6d 29			    add hl,hl 
0c6e 87			    add a,a 
0c6f 30 01		    jr nc,Mult12U_NoAdd3 
0c71 19			    add hl,de 
0c72			Mult12U_NoAdd3: 
0c72 29			    add hl,hl 
0c73 87			    add a,a 
0c74 30 01		    jr nc,Mult12U_NoAdd4 
0c76 19			    add hl,de 
0c77			Mult12U_NoAdd4: 
0c77 29			    add hl,hl 
0c78 87			    add a,a 
0c79 30 01		    jr nc,Mult12U_NoAdd5 
0c7b 19			    add hl,de 
0c7c			Mult12U_NoAdd5: 
0c7c 29			    add hl,hl 
0c7d 87			    add a,a 
0c7e 30 01		    jr nc,Mult12U_NoAdd6 
0c80 19			    add hl,de 
0c81			Mult12U_NoAdd6: 
0c81 29			    add hl,hl 
0c82 87			    add a,a 
0c83 d0			    ret nc 
0c84 19			    add hl,de 
0c85 c9			    ret 
0c86			 
0c86			; 
0c86			; Multiply 8-bit value with a 16-bit value (right rotating) 
0c86			; In: Multiply A with DE 
0c86			;      Put lowest value in A for most efficient calculation 
0c86			; Out: HL = result 
0c86			; 
0c86			Mult12R: 
0c86 21 00 00		    ld hl,0 
0c89			Mult12R_Loop: 
0c89 cb 3f		    srl a 
0c8b 30 01		    jr nc,Mult12R_NoAdd 
0c8d 19			    add hl,de 
0c8e			Mult12R_NoAdd: 
0c8e cb 23		    sla e 
0c90 cb 12		    rl d 
0c92 b7			    or a 
0c93 c2 89 0c		    jp nz,Mult12R_Loop 
0c96 c9			    ret 
0c97			 
0c97			; 
0c97			; Multiply 16-bit values (with 32-bit result) 
0c97			; In: Multiply BC with DE 
0c97			; Out: BCHL = result 
0c97			; 
0c97			Mult32: 
0c97 79			    ld a,c 
0c98 48			    ld c,b 
0c99 21 00 00		    ld hl,0 
0c9c 06 10		    ld b,16 
0c9e			Mult32_Loop: 
0c9e 29			    add hl,hl 
0c9f 17			    rla 
0ca0 cb 11		    rl c 
0ca2 30 07		    jr nc,Mult32_NoAdd 
0ca4 19			    add hl,de 
0ca5 ce 00		    adc a,0 
0ca7 d2 ab 0c		    jp nc,Mult32_NoAdd 
0caa 0c			    inc c 
0cab			Mult32_NoAdd: 
0cab 10 f1		    djnz Mult32_Loop 
0cad 41			    ld b,c 
0cae 4f			    ld c,a 
0caf c9			    ret 
0cb0			 
0cb0			 
0cb0			 
0cb0			; 
0cb0			; Multiply 8-bit values 
0cb0			; In:  Multiply H with E 
0cb0			; Out: HL = result 
0cb0			; 
0cb0			Mult8: 
0cb0 16 00		    ld d,0 
0cb2 6a			    ld l,d 
0cb3 06 08		    ld b,8 
0cb5			Mult8_Loop: 
0cb5 29			    add hl,hl 
0cb6 30 01		    jr nc,Mult8_NoAdd 
0cb8 19			    add hl,de 
0cb9			Mult8_NoAdd: 
0cb9 10 fa		    djnz Mult8_Loop 
0cbb c9			    ret 
0cbc			 
0cbc			 
0cbc			 
0cbc			 
0cbc			 
0cbc			 
0cbc			 
0cbc			 
0cbc			;;http://z80-heaven.wikidot.com/math 
0cbc			;;This divides DE by BC, storing the result in DE, remainder in HL 
0cbc			; 
0cbc			;DE_Div_BC:          ;1281-2x, x is at most 16 
0cbc			;     ld a,16        ;7 
0cbc			;     ld hl,0        ;10 
0cbc			;     jp $+5         ;10 
0cbc			;.DivLoop: 
0cbc			;       add hl,bc    ;-- 
0cbc			;       dec a        ;64 
0cbc			;       jr z,.DivLoopEnd        ;86 
0cbc			; 
0cbc			;       sla e        ;128 
0cbc			;       rl d         ;128 
0cbc			;       adc hl,hl    ;240 
0cbc			;       sbc hl,bc    ;240 
0cbc			;       jr nc,.DivLoop ;23|21 
0cbc			;       inc e        ;-- 
0cbc			;       jp .DivLoop+1 
0cbc			; 
0cbc			;.DivLoopEnd: 
0cbc			 
0cbc			;HL_Div_C: 
0cbc			;Inputs: 
0cbc			;     HL is the numerator 
0cbc			;     C is the denominator 
0cbc			;Outputs: 
0cbc			;     A is the remainder 
0cbc			;     B is 0 
0cbc			;     C is not changed 
0cbc			;     DE is not changed 
0cbc			;     HL is the quotient 
0cbc			; 
0cbc			;       ld b,16 
0cbc			;       xor a 
0cbc			;         add hl,hl 
0cbc			;         rla 
0cbc			;         cp c 
0cbc			;         jr c,$+4 
0cbc			;           inc l 
0cbc			;           sub c 
0cbc			;         djnz $-7 
0cbc			 
0cbc			; https://plutiedev.com/z80-add-8bit-to-16bit 
0cbc			 
0cbc			addatohl: 
0cbc 85			    add   a, l    ; A = A+L 
0cbd 6f			    ld    l, a    ; L = A+L 
0cbe 8c			    adc   a, h    ; A = A+L+H+carry 
0cbf 95			    sub   l       ; A = H+carry 
0cc0 67			    ld    h, a    ; H = H+carry 
0cc1 c9			ret 
0cc2			 
0cc2			addatode: 
0cc2 83			    add   a, e    ; A = A+L 
0cc3 5f			    ld    e, a    ; L = A+L 
0cc4 8a			    adc   a, d    ; A = A+L+H+carry 
0cc5 93			    sub   e       ; A = H+carry 
0cc6 57			    ld    d, a    ; H = H+carry 
0cc7 c9			ret 
0cc8			 
0cc8			 
0cc8			addatobc: 
0cc8 81			    add   a, c    ; A = A+L 
0cc9 4f			    ld    c, a    ; L = A+L 
0cca 88			    adc   a, b    ; A = A+L+H+carry 
0ccb 91			    sub   c       ; A = H+carry 
0ccc 47			    ld    b, a    ; H = H+carry 
0ccd c9			ret 
0cce			 
0cce			subafromhl: 
0cce			   ; If A=0 do nothing 
0cce			    ; Otherwise flip A's sign. Since 
0cce			    ; the upper byte becomes -1, also 
0cce			    ; substract 1 from H. 
0cce ed 44		    neg 
0cd0 ca d9 0c		    jp    z, Skip 
0cd3 25			    dec   h 
0cd4			     
0cd4			    ; Now add the low byte as usual 
0cd4			    ; Two's complement takes care of 
0cd4			    ; ensuring the result is correct 
0cd4 85			    add   a, l 
0cd5 6f			    ld    l, a 
0cd6 8c			    adc   a, h 
0cd7 95			    sub   l 
0cd8 67			    ld    h, a 
0cd9			Skip: 
0cd9 c9				ret 
0cda			 
0cda			 
0cda			; compare hl and de 
0cda			; returns:  
0cda			; if hl = de, z=1, s=0, c0=0 
0cda			; if hl > de, z=0, s=0, c=0 
0cda			; if hl < de, z=0, s=1, c=1 
0cda			cmp16:	 
0cda b7				or a 
0cdb ed 52			sbc hl,de 
0cdd e0				ret po 
0cde 7c				ld a,h 
0cdf 1f				rra 
0ce0 ee 40			xor 01000000B 
0ce2 37				scf 
0ce3 8f				adc a,a 
0ce4 c9				ret 
0ce5			 
0ce5			 
0ce5			; test if hl contains zero   - A is destroyed 
0ce5			 
0ce5			ishlzero:    
0ce5 b7				or a     ; reset flags 
0ce6 7c				ld a, h 
0ce7 b5				or l        	 
0ce8			 
0ce8 c9				ret 
0ce9			 
0ce9			 
0ce9			 
0ce9			 
0ce9			if FORTH_ENABLE_FLOATMATH 
0ce9			;include "float/bbcmath.z80" 
0ce9			include "float/lpfpcalc.asm" 
0ce9			endif 
0ce9			 
0ce9			 
0ce9			; eof 
0ce9			 
# End of file firmware_maths.asm
0ce9			include "firmware_strings.asm"   ; string handling  
0ce9			 
0ce9			 
0ce9			; TODO string len 
0ce9			; input text string, end on cr with zero term 
0ce9			; a offset into frame buffer to start prompt 
0ce9			; d is max length 
0ce9			; e is display size TODO 
0ce9			; c is current cursor position 
0ce9			; hl is ptr to where string will be stored 
0ce9			 
0ce9			 
0ce9			; TODO check limit of buffer for new inserts 
0ce9			; TODO check insert does not push beyond buffer 
0ce9			; TODO scroll in a limited display area 
0ce9			; TODO scroll whole screen on page wrap 
0ce9			 
0ce9			 
0ce9			; TODO handle KEY_PREVWORD 
0ce9			; TODO handle KEY_NEXTWORD 
0ce9			; TODO handle KEY_HOME 
0ce9			; TODO handle KEY_END 
0ce9			; TODO use LCD cursor? 
0ce9			 
0ce9 32 b6 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0cec 81					add c 
0ced 32 b4 fb				ld (input_at_cursor),a	; save draw pos of cursor 
0cf0 22 b9 fb				ld (input_start), hl     ; save ptr to buffer 
0cf3 79					ld a, c 
0cf4 cd bc 0c				call addatohl 
0cf7 22 bb fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0cfa 7a					ld a,d 
0cfb 32 b8 fb			        ld (input_size), a       ; save length of input area 
0cfe 79					ld a, c 
0cff 32 a7 fb				ld (input_cursor),a      ; init cursor start position  
0d02 7b					ld a,e 
0d03 32 b7 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d06					 
0d06					 
0d06			 
0d06			;		ld a,(input_ptr) 
0d06			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d06			 
0d06			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d06					; init cursor shape if not set by the cin routines 
0d06 21 56 fa				ld hl, cursor_shape 
0d09 3e ff				ld a, 255 
0d0b 77					ld (hl), a 
0d0c 23					inc hl 
0d0d 3e 00				ld a, 0 
0d0f 77					ld (hl), a 
0d10			 
0d10 3e 0f				ld a, CUR_BLINK_RATE 
0d12 32 b2 fb				ld (input_cur_flash), a 
0d15 3e 01				ld a, 1 
0d17 32 b1 fb				ld (input_cur_onoff),a 
0d1a			 
0d1a			;	if DEBUG_INPUT 
0d1a			;		push af 
0d1a			;		ld a, 'I' 
0d1a			;		ld (debug_mark),a 
0d1a			;		pop af 
0d1a			;		CALLMONITOR 
0d1a			;	endif 
0d1a			.is1:		; main entry loop 
0d1a			 
0d1a			 
0d1a			 
0d1a					; pause 1ms 
0d1a			 
0d1a 3e 01				ld a, 1 
0d1c cd 1f 0a				call aDelayInMS 
0d1f			 
0d1f					; dec flash counter 
0d1f 3a b2 fb				ld a, (input_cur_flash) 
0d22 3d					dec a 
0d23 32 b2 fb				ld (input_cur_flash), a 
0d26 fe 00				cp 0 
0d28 20 0d				jr nz, .nochgstate 
0d2a			 
0d2a			 
0d2a					; change state 
0d2a 3a b1 fb				ld a,(input_cur_onoff) 
0d2d ed 44				neg 
0d2f 32 b1 fb				ld (input_cur_onoff),a 
0d32			 
0d32			 
0d32					; reset on change of state 
0d32 3e 0f				ld a, CUR_BLINK_RATE 
0d34 32 b2 fb				ld (input_cur_flash), a 
0d37			 
0d37			.nochgstate: 
0d37					 
0d37					 
0d37			 
0d37					; display cursor  
0d37			 
0d37			;		ld hl, (input_start) 
0d37			;		ld a, (input_cursor) 
0d37			;		call addatohl 
0d37			 
0d37					; get char under cursor and replace with cursor 
0d37 2a bb fb		ld hl, (input_ptr) 
0d3a			;		ld a, (hl) 
0d3a			;		ld (input_under_cursor),a 
0d3a			;		ld a, '_' 
0d3a			;		ld (hl), a 
0d3a			 
0d3a					; display string 
0d3a			 
0d3a ed 5b b9 fb			ld de, (input_start) 
0d3e 3a b6 fb				ld a, (input_at_pos) 
0d41 cd 9f 0a				call str_at_display 
0d44			;	        call update_display 
0d44			 
0d44					; find place to put the cursor 
0d44			;		add h 
0d44			;		ld l, display_row_1 
0d44			;		sub l 
0d44			; (input_at_pos) 
0d44					;ld c, a 
0d44			;		ld a, (input_cursor) 
0d44			;		ld l, (input_at_pos) 
0d44			;		;ld b, h 
0d44			;		add l 
0d44			;		ld (input_at_cursor),a 
0d44					;ld l,h 
0d44			 
0d44			;		ld h, 0 
0d44			;		ld l,(input_at_pos) 
0d44			;		ld a, (input_cursor) 
0d44			;		call addatohl 
0d44			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0d44			;		call subafromhl 
0d44			;		ld a,l 
0d44			;		ld (input_at_cursor), a 
0d44			 
0d44				if DEBUG_INPUT 
0d44					ld a, (hardware_diag) 
0d44					cp 0 
0d44					jr z, .skip_input_diag 
0d44			 
0d44					ld a,(input_at_pos) 
0d44					ld hl, LFSRSeed 
0d44					call hexout 
0d44					ld a, (input_cursor) 
0d44					ld hl, LFSRSeed+2 
0d44					call hexout 
0d44					ld a,(input_at_cursor) 
0d44					ld hl, LFSRSeed+4 
0d44					call hexout 
0d44			 
0d44					ld a,(input_cur_onoff) 
0d44					ld hl, LFSRSeed+6 
0d44					call hexout 
0d44			 
0d44					ld a,(input_cur_flash) 
0d44					ld hl, LFSRSeed+8 
0d44					call hexout 
0d44			 
0d44					ld a,(input_len) 
0d44					ld hl, LFSRSeed+10 
0d44					call hexout 
0d44					ld hl, LFSRSeed+12 
0d44					ld a, 0 
0d44					ld (hl),a 
0d44					ld a, display_row_4 
0d44					ld de, LFSRSeed 
0d44					call str_at_display 
0d44					.skip_input_diag: 
0d44				endif 
0d44			 
0d44					; decide on if we are showing the cursor this time round 
0d44			 
0d44 3a b1 fb				ld a, (input_cur_onoff) 
0d47 fe ff				cp 255 
0d49 28 13				jr z, .skipcur 
0d4b			 
0d4b			 
0d4b 3a b4 fb				ld a,(input_at_cursor) 
0d4e 11 56 fa				ld de, cursor_shape 
0d51 cd 9f 0a				call str_at_display 
0d54			 
0d54					; save length of current input string 
0d54 2a b9 fb				ld hl, (input_start) 
0d57 cd 1a 11				call strlenz 
0d5a 7d					ld a,l 
0d5b 32 ac fb				ld (input_len),a 
0d5e			 
0d5e			.skipcur: 
0d5e			 
0d5e cd af 0a			        call update_display 
0d61					 
0d61			 
0d61			 
0d61					; wait 
0d61				 
0d61					; TODO loop without wait to flash the cursor and char under cursor	 
0d61 cd 49 63				call cin    ; _wait 
0d64			 
0d64 fe 00				cp 0 
0d66 ca 1a 0d				jp z, .is1 
0d69			 
0d69					; get ptr to char to input into 
0d69			 
0d69 4f					ld c,a 
0d6a 2a b9 fb				ld hl, (input_start) 
0d6d 3a a7 fb				ld a, (input_cursor) 
0d70 cd bc 0c				call addatohl 
0d73 22 bb fb				ld (input_ptr), hl 
0d76 79					ld a,c 
0d77			 
0d77					; replace char under cursor 
0d77			 
0d77			;		ld hl, (input_ptr) 
0d77			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0d77			;		ld (hl), a 
0d77			 
0d77			;	if DEBUG_INPUT 
0d77			;		push af 
0d77			;		ld a, 'i' 
0d77			;		ld (debug_mark),a 
0d77			;		pop af 
0d77			;		CALLMONITOR 
0d77			;	endif 
0d77 fe 0e				cp KEY_HOME 
0d79 20 0e				jr nz, .iske 
0d7b			 
0d7b 3a b6 fb				ld a, (input_at_pos) 
0d7e 32 b4 fb				ld (input_at_cursor),a 
0d81 3e 00				ld a, 0 
0d83 32 a7 fb				ld (input_cursor), a 
0d86 c3 1a 0d				jp .is1 
0d89					 
0d89 fe 0f		.iske:		cp KEY_END 
0d8b 20 03				jr nz, .isknw 
0d8d c3 1a 0d				jp .is1 
0d90			 
0d90 fe 06		.isknw:		cp KEY_NEXTWORD 
0d92 20 1b				jr nz, .iskpw 
0d94			 
0d94 2a bb fb		.isknwm:	ld hl, (input_ptr) 
0d97 7e					ld a,(hl)	 
0d98 fe 00				cp 0 
0d9a ca 1a 0d				jp z, .is1    ; end of string 
0d9d fe 20				cp ' ' 
0d9f ca 1a 0d				jp z, .is1    ; end of word 
0da2 23					inc hl 
0da3 22 bb fb				ld (input_ptr), hl 
0da6 3a b4 fb				ld a, (input_at_cursor) 
0da9 3c					inc a 
0daa 32 b4 fb				ld (input_at_cursor), a 
0dad 18 e5				jr .isknwm 
0daf			 
0daf fe 07		.iskpw:		cp KEY_PREVWORD 
0db1 20 1b				jr nz, .iskl 
0db3			.iskpwm:	 
0db3 2a bb fb				ld hl, (input_ptr) 
0db6 7e					ld a,(hl)	 
0db7 fe 00				cp 0  
0db9 ca 1a 0d				jp z, .is1    ; end of string 
0dbc fe 20				cp ' ' 
0dbe ca 1a 0d				jp z, .is1    ; end of word 
0dc1 2b					dec hl 
0dc2 22 bb fb				ld (input_ptr), hl 
0dc5 3a b4 fb				ld a, (input_at_cursor) 
0dc8 3d					dec a 
0dc9 32 b4 fb				ld (input_at_cursor), a 
0dcc 18 e5				jr .iskpwm 
0dce			 
0dce			 
0dce fe 0b		.iskl:		cp KEY_LEFT 
0dd0 20 27				jr nz, .isk1 
0dd2			 
0dd2 3a a7 fb				ld a, (input_cursor) 
0dd5			 
0dd5 fe 00				cp 0 
0dd7 ca 1a 0d				jp z, .is1 		; at start of line to ignore  
0dda			 
0dda 3d					dec  a 		; TODO check underflow 
0ddb 32 a7 fb				ld (input_cursor), a 
0dde			 
0dde 2a bb fb				ld hl, (input_ptr) 
0de1 2b					dec hl 
0de2 22 bb fb				ld (input_ptr), hl 
0de5					 
0de5 3a b4 fb				ld a, (input_at_cursor) 
0de8 3d					dec a 
0de9 32 b4 fb				ld (input_at_cursor), a 
0dec			 
0dec 3e 01				ld a, 1		; show cursor moving 
0dee 32 b1 fb				ld (input_cur_onoff),a 
0df1 3e 0f				ld a, CUR_BLINK_RATE 
0df3 32 b2 fb				ld (input_cur_flash), a 
0df6			 
0df6 c3 1a 0d				jp .is1 
0df9			 
0df9 fe 0c		.isk1:		cp KEY_RIGHT 
0dfb 20 2a				jr nz, .isk2 
0dfd			 
0dfd 3a ac fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e00 5f					ld e,a 
0e01 3a a7 fb				ld a, (input_cursor) 
0e04 bb					cp e 
0e05 ca 1a 0d				jp z, .is1		; at the end of string so dont go right 
0e08			 
0e08 3c					inc  a 		; TODO check overflow 
0e09 32 a7 fb				ld (input_cursor), a 
0e0c			 
0e0c 3a b4 fb				ld a, (input_at_cursor) 
0e0f 3c					inc a 
0e10 32 b4 fb				ld (input_at_cursor), a 
0e13			 
0e13 2a bb fb				ld hl, (input_ptr) 
0e16 23					inc hl 
0e17 22 bb fb				ld (input_ptr), hl 
0e1a			 
0e1a 3e 01				ld a, 1		; show cursor moving 
0e1c 32 b1 fb				ld (input_cur_onoff),a 
0e1f 3e 0f				ld a, CUR_BLINK_RATE 
0e21 32 b2 fb				ld (input_cur_flash), a 
0e24			 
0e24 c3 1a 0d				jp .is1 
0e27			 
0e27 fe 05		.isk2:		cp KEY_UP 
0e29			 
0e29 20 26				jr nz, .isk3 
0e2b			 
0e2b					; swap last command with the current on 
0e2b			 
0e2b					; move cursor to start of string 
0e2b 2a b9 fb				ld hl, (input_start) 
0e2e 22 bb fb				ld (input_ptr), hl 
0e31			 
0e31 3a b6 fb				ld a, (input_at_pos) 
0e34 32 b4 fb				ld (input_at_cursor), a 
0e37			 
0e37 3e 00				ld a, 0 
0e39 32 a7 fb				ld (input_cursor), a 
0e3c					 
0e3c					; swap input and last command buffers 
0e3c			 
0e3c 21 df f2				ld hl, os_cli_cmd 
0e3f 11 de f3				ld de, os_last_cmd 
0e42 06 ff				ld b, 255 
0e44 7e			.swap1:		ld a, (hl) 
0e45 4f					ld c,a 
0e46 1a					ld a, (de) 
0e47 77					ld (hl), a 
0e48 79					ld a,c 
0e49 12					ld (de),a 
0e4a 23					inc hl 
0e4b 13					inc de 
0e4c 10 f6				djnz .swap1 
0e4e			 
0e4e			 
0e4e			 
0e4e			 
0e4e			 
0e4e c3 1a 0d				jp .is1 
0e51			 
0e51 fe 08		.isk3:		cp KEY_BS 
0e53 20 3c				jr nz, .isk4 
0e55			 
0e55 3a a7 fb				ld a, (input_cursor) 
0e58			 
0e58 fe 00				cp 0 
0e5a ca 1a 0d				jp z, .is1 		; at start of line to ignore  
0e5d			 
0e5d 3d					dec  a 		; TODO check underflow 
0e5e 32 a7 fb				ld (input_cursor), a 
0e61			 
0e61					; hl is source 
0e61					; de needs to be source - 1 
0e61			 
0e61			;		ld a, 0 
0e61			;		dec hl 
0e61			;		ld (hl), a 
0e61			 
0e61 2a bb fb				ld hl, (input_ptr) 
0e64 2b					dec hl 
0e65 22 bb fb				ld (input_ptr), hl 
0e68			 
0e68					; shift all data 
0e68			 
0e68 e5					push hl 
0e69 23					inc hl 
0e6a d1					pop de 
0e6b 3a ac fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0e6e 4f					ld c,a 
0e6f 06 00				ld b,0 
0e71 ed b0				ldir  
0e73			 
0e73			 
0e73			 
0e73			 
0e73 3a b4 fb				ld a, (input_at_cursor) 
0e76 3d					dec a 
0e77 32 b4 fb				ld (input_at_cursor), a 
0e7a			 
0e7a			 
0e7a 3e 01				ld a, 1		; show cursor moving 
0e7c 32 b1 fb				ld (input_cur_onoff),a 
0e7f 3e 0f				ld a, CUR_BLINK_RATE 
0e81 32 b2 fb				ld (input_cur_flash), a 
0e84			 
0e84					; remove char 
0e84 3a b4 fb				ld a, (input_at_cursor) 
0e87 3c					inc a 
0e88 11 12 0f				ld de,.iblank 
0e8b cd 9f 0a				call str_at_display 
0e8e			 
0e8e c3 1a 0d				jp .is1 
0e91			 
0e91 fe 0d		.isk4:		cp KEY_CR 
0e93 28 6c				jr z, .endinput 
0e95			 
0e95					; else add the key press to the end 
0e95			 
0e95 4f					ld c, a			; save key pressed 
0e96			 
0e96 7e					ld a,(hl)		; get what is currently under char 
0e97			 
0e97 fe 00				cp 0			; we are at the end of the string 
0e99 20 2f				jr nz, .onchar 
0e9b					 
0e9b					; add a char to the end of the string 
0e9b				 
0e9b 71					ld (hl),c 
0e9c 23					inc hl 
0e9d			;		ld a,' ' 
0e9d			;		ld (hl),a 
0e9d			;		inc hl 
0e9d 3e 00				ld a,0 
0e9f 77					ld (hl),a 
0ea0 2b					dec hl 
0ea1			 
0ea1 3a a7 fb				ld a, (input_cursor) 
0ea4 3c					inc a				; TODO check max string length and scroll  
0ea5 32 a7 fb				ld (input_cursor), a		; inc cursor pos 
0ea8							 
0ea8 3a b4 fb				ld a, (input_at_cursor) 
0eab 3c					inc a 
0eac 32 b4 fb				ld (input_at_cursor), a 
0eaf			 
0eaf 2a bb fb				ld hl, (input_ptr) 
0eb2 23					inc hl 
0eb3 22 bb fb				ld (input_ptr), hl 
0eb6			 
0eb6 2a bb fb				ld hl, (input_ptr) 
0eb9 23					inc hl 
0eba 22 bb fb				ld (input_ptr), hl 
0ebd			;	if DEBUG_INPUT 
0ebd			;		push af 
0ebd			;		ld a, '+' 
0ebd			;		ld (debug_mark),a 
0ebd			;		pop af 
0ebd			;		CALLMONITOR 
0ebd			;	endif 
0ebd 3e 01				ld a, 1		; show cursor moving 
0ebf 32 b1 fb				ld (input_cur_onoff),a 
0ec2 3e 0f				ld a, CUR_BLINK_RATE 
0ec4 32 b2 fb				ld (input_cur_flash), a 
0ec7 c3 1a 0d				jp .is1 
0eca					 
0eca			 
0eca			 
0eca					; if on a char then insert 
0eca			.onchar: 
0eca			 
0eca					; TODO over flow check: make sure insert does not blow out buffer 
0eca			 
0eca					; need to do some maths to use lddr 
0eca			 
0eca e5					push hl   ; save char pos 
0ecb c5					push bc 
0ecc			 
0ecc 2a b9 fb				ld hl, (input_start) 
0ecf 3a ac fb				ld a, (input_len) 
0ed2 cd bc 0c				call addatohl  		; end of string 
0ed5 23					inc hl 
0ed6 23					inc hl		; past zero term 
0ed7 e5					push hl 
0ed8 23					inc hl 
0ed9 e5					push hl  
0eda			 
0eda								; start and end of lddr set, now how much to move? 
0eda			 
0eda							 
0eda 3a a7 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0edd 47					ld b,a 
0ede 3a ac fb				ld a,(input_len) 
0ee1 5f					ld e,a 
0ee2 90					sub b 
0ee3 3c					inc a		;?? 
0ee4 3c					inc a		;?? 
0ee5 3c					inc a		;?? 
0ee6			 
0ee6 06 00				ld b,0 
0ee8 4f					ld c,a 
0ee9			 
0ee9				if DEBUG_INPUT 
0ee9					push af 
0ee9					ld a, 'i' 
0ee9					ld (debug_mark),a 
0ee9					pop af 
0ee9			;		CALLMONITOR 
0ee9				endif 
0ee9 d1					pop de 
0eea e1					pop hl 
0eeb				if DEBUG_INPUT 
0eeb					push af 
0eeb					ld a, 'I' 
0eeb					ld (debug_mark),a 
0eeb					pop af 
0eeb			;		CALLMONITOR 
0eeb				endif 
0eeb ed b8				lddr 
0eed				 
0eed			 
0eed			 
0eed					; TODO have a key for insert/overwrite mode???? 
0eed c1					pop bc 
0eee e1					pop hl 
0eef 71					ld (hl), c		; otherwise overwrite current char 
0ef0					 
0ef0			 
0ef0			 
0ef0			 
0ef0 3a a7 fb				ld a, (input_cursor) 
0ef3 3c					inc  a 		; TODO check overflow 
0ef4 32 a7 fb				ld (input_cursor), a 
0ef7			 
0ef7 3a b4 fb				ld a, (input_at_cursor) 
0efa 3c					inc a 
0efb 32 b4 fb				ld (input_at_cursor), a 
0efe			 
0efe c3 1a 0d				jp .is1 
0f01			 
0f01			.endinput:	; TODO look for end of string 
0f01			 
0f01					; add trailing space for end of token 
0f01			 
0f01 2a b9 fb				ld hl, (input_start) 
0f04 3a ac fb				ld a,(input_len) 
0f07 cd bc 0c				call addatohl 
0f0a 3e 20				ld a, ' ' 
0f0c 77					ld (hl),a 
0f0d					; TODO eof of parse marker 
0f0d			 
0f0d 23					inc hl 
0f0e 3e 00				ld a, 0 
0f10 77					ld (hl),a 
0f11			 
0f11			 
0f11 c9					ret 
0f12			 
0f12 .. 00		.iblank: db " ",0 
0f14			 
0f14			 
0f14 32 b6 fb		input_str_prev:	ld (input_at_pos), a 
0f17 22 b9 fb				ld (input_start), hl 
0f1a 3e 01				ld a,1			; add cursor 
0f1c 77					ld (hl),a 
0f1d 23					inc hl 
0f1e 3e 00				ld a,0 
0f20 77					ld (hl),a 
0f21 22 bb fb				ld (input_ptr), hl 
0f24 7a					ld a,d 
0f25 32 b8 fb				ld (input_size), a 
0f28 3e 00				ld a,0 
0f2a 32 a7 fb				ld (input_cursor),a 
0f2d			.instr1:	 
0f2d			 
0f2d					; TODO do block cursor 
0f2d					; TODO switch cursor depending on the modifer key 
0f2d			 
0f2d					; update cursor shape change on key hold 
0f2d			 
0f2d 2a bb fb				ld hl, (input_ptr) 
0f30 2b					dec hl 
0f31 3a 56 fa				ld a,(cursor_shape) 
0f34 77					ld (hl), a 
0f35			 
0f35					; display entered text 
0f35 3a b6 fb				ld a,(input_at_pos) 
0f38 cd 67 62		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f3b ed 5b b9 fb	            	LD   de, (input_start) 
0f3f cd 6f 62		            	CALL fLCD_Str       ;Display string pointed to by DE 
0f42			 
0f42 cd 49 63				call cin 
0f45 fe 00				cp 0 
0f47 28 e4				jr z, .instr1 
0f49			 
0f49					; proecess keyboard controls first 
0f49			 
0f49 2a bb fb				ld hl,(input_ptr) 
0f4c			 
0f4c fe 0d				cp KEY_CR	 ; pressing enter ends input 
0f4e 28 5a				jr z, .instrcr 
0f50			 
0f50 fe 08				cp KEY_BS 	; back space 
0f52 20 0f				jr nz, .instr2 
0f54					; process back space 
0f54			 
0f54					; TODO stop back space if at start of string 
0f54 2b					dec hl 
0f55 2b					dec hl ; to over write cursor 
0f56 3a 56 fa				ld a,(cursor_shape) 
0f59					;ld a,0 
0f59 77					ld (hl),a 
0f5a 23					inc hl 
0f5b 3e 20				ld a," " 
0f5d 77					ld (hl),a 
0f5e 22 bb fb				ld (input_ptr),hl 
0f61					 
0f61			 
0f61 18 ca				jr .instr1 
0f63			 
0f63 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0f65 20 06				jr nz, .instr3 
0f67 2b					dec hl 
0f68 22 bb fb				ld (input_ptr),hl 
0f6b 18 c0				jr .instr1 
0f6d				 
0f6d fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0f6f 20 06				jr nz, .instr4 
0f71 23					inc hl 
0f72 22 bb fb				ld (input_ptr),hl 
0f75 18 b6				jr .instr1 
0f77			 
0f77 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0f79 20 06				jr nz, .instr5 
0f7b 2b					dec hl 
0f7c 22 bb fb				ld (input_ptr),hl 
0f7f 18 ac				jr .instr1 
0f81			 
0f81 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0f83 20 06				jr nz, .instr6 
0f85 2b					dec hl 
0f86 22 bb fb				ld (input_ptr),hl 
0f89 18 a2				jr .instr1 
0f8b fe 05		.instr6:        cp KEY_UP      ; recall last command 
0f8d 20 0b				jr nz, .instrnew 
0f8f			 
0f8f 21 b8 ef			ld hl, scratch 
0f92 11 de f3			ld de, os_last_cmd 
0f95 cd b3 0f			call strcpy 
0f98 18 93				jr .instr1 
0f9a			 
0f9a			 
0f9a			.instrnew:	; no special key pressed to see if we have room to store it 
0f9a			 
0f9a					; TODO do string size test 
0f9a			 
0f9a 2b					dec hl ; to over write cursor 
0f9b 77					ld (hl),a 
0f9c 23					inc hl 
0f9d 3a 56 fa				ld a,(cursor_shape) 
0fa0 77					ld (hl),a 
0fa1 23					inc hl 
0fa2 3e 00				ld a,0 
0fa4 77					ld (hl),a 
0fa5			 
0fa5 22 bb fb				ld (input_ptr),hl 
0fa8					 
0fa8 18 83				jr .instr1 
0faa 2b			.instrcr:	dec hl		; remove cursor 
0fab 3e 20				ld a,' '	; TODO add a trailing space for safety 
0fad 77					ld (hl),a 
0fae 23					inc hl 
0faf 3e 00				ld a,0 
0fb1 77					ld (hl),a 
0fb2			 
0fb2			 
0fb2					; if at end of line scroll up    
0fb2					; TODO detecting only end of line 4 for scroll up  
0fb2			 
0fb2					;ld   
0fb2			 
0fb2 c9					ret 
0fb3			 
0fb3			 
0fb3			; strcpy hl = dest, de source 
0fb3			 
0fb3 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0fb4 b7			            OR   A              ;Null terminator? 
0fb5 c8			            RET  Z              ;Yes, so finished 
0fb6 1a					ld a,(de) 
0fb7 77					ld (hl),a 
0fb8 13			            INC  DE             ;Point to next character 
0fb9 23					inc hl 
0fba 18 f7		            JR   strcpy       ;Repeat 
0fbc c9					ret 
0fbd			 
0fbd			 
0fbd			; TODO string_at  
0fbd			; pass string which starts with lcd offset address and then null term string 
0fbd			 
0fbd			; TODO string to dec 
0fbd			; TODO string to hex 
0fbd			; TODO byte to string hex 
0fbd			; TODO byte to string dec 
0fbd			 
0fbd			 
0fbd			 
0fbd			; from z80uartmonitor 
0fbd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fbd			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0fbd			; pass hl for where to put the text 
0fbd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fbd c5			hexout:	PUSH BC 
0fbe f5					PUSH AF 
0fbf 47					LD B, A 
0fc0					; Upper nybble 
0fc0 cb 3f				SRL A 
0fc2 cb 3f				SRL A 
0fc4 cb 3f				SRL A 
0fc6 cb 3f				SRL A 
0fc8 cd d8 0f				CALL tohex 
0fcb 77					ld (hl),a 
0fcc 23					inc hl	 
0fcd					 
0fcd					; Lower nybble 
0fcd 78					LD A, B 
0fce e6 0f				AND 0FH 
0fd0 cd d8 0f				CALL tohex 
0fd3 77					ld (hl),a 
0fd4 23					inc hl	 
0fd5					 
0fd5 f1					POP AF 
0fd6 c1					POP BC 
0fd7 c9					RET 
0fd8					 
0fd8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fd8			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0fd8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fd8			tohex: 
0fd8 e5					PUSH HL 
0fd9 d5					PUSH DE 
0fda 16 00				LD D, 0 
0fdc 5f					LD E, A 
0fdd 21 e5 0f				LD HL, .DATA 
0fe0 19					ADD HL, DE 
0fe1 7e					LD A, (HL) 
0fe2 d1					POP DE 
0fe3 e1					POP HL 
0fe4 c9					RET 
0fe5			 
0fe5			.DATA: 
0fe5 30					DEFB	30h	; 0 
0fe6 31					DEFB	31h	; 1 
0fe7 32					DEFB	32h	; 2 
0fe8 33					DEFB	33h	; 3 
0fe9 34					DEFB	34h	; 4 
0fea 35					DEFB	35h	; 5 
0feb 36					DEFB	36h	; 6 
0fec 37					DEFB	37h	; 7 
0fed 38					DEFB	38h	; 8 
0fee 39					DEFB	39h	; 9 
0fef 41					DEFB	41h	; A 
0ff0 42					DEFB	42h	; B 
0ff1 43					DEFB	43h	; C 
0ff2 44					DEFB	44h	; D 
0ff3 45					DEFB	45h	; E 
0ff4 46					DEFB	46h	; F 
0ff5			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0ff5			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0ff5			;;    subtract $30, if result > 9 then subtract $7 more 
0ff5			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0ff5			atohex: 
0ff5 d6 30				SUB $30 
0ff7 fe 0a				CP 10 
0ff9 f8					RET M		; If result negative it was 0-9 so we're done 
0ffa d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0ffc c9					RET		 
0ffd			 
0ffd			 
0ffd			 
0ffd			 
0ffd			; Get 2 ASCII characters as hex byte from pointer in hl 
0ffd			 
0ffd			BYTERD: 
0ffd 16 00			LD	D,00h		;Set up 
0fff cd 07 10			CALL	HEXCON		;Get byte and convert to hex 
1002 87				ADD	A,A		;First nibble so 
1003 87				ADD	A,A		;multiply by 16 
1004 87				ADD	A,A		; 
1005 87				ADD	A,A		; 
1006 57				LD	D,A		;Save hi nibble in D 
1007			HEXCON: 
1007 7e				ld a, (hl)		;Get next chr 
1008 23				inc hl 
1009 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
100b fe 0a			CP	00Ah		;Is it 0-9 ? 
100d 38 02			JR	C,NALPHA	;If so miss next bit 
100f d6 07			SUB	007h		;Else convert alpha 
1011			NALPHA: 
1011 b2				OR	D		;Add hi nibble back 
1012 c9				RET			; 
1013			 
1013			 
1013			; 
1013			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1013			; Since the routines get_byte and therefore get_nibble are called, only valid 
1013			; characters (0-9a-f) are accepted. 
1013			; 
1013			;get_word        push    af 
1013			;                call    get_byte        ; Get the upper byte 
1013			;                ld      h, a 
1013			;                call    get_byte        ; Get the lower byte 
1013			;                ld      l, a 
1013			;                pop     af 
1013			;                ret 
1013			; 
1013			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1013			; the routine get_nibble is used only valid characters are accepted - the  
1013			; input routine only accepts characters 0-9a-f. 
1013			; 
1013 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1014 7e					ld a,(hl) 
1015 23					inc hl 
1016 cd 3b 10		                call    nibble2val      ; Get upper nibble 
1019 cb 07		                rlc     a 
101b cb 07		                rlc     a 
101d cb 07		                rlc     a 
101f cb 07		                rlc     a 
1021 47			                ld      b, a            ; Save upper four bits 
1022 7e					ld a,(hl) 
1023 cd 3b 10		                call    nibble2val      ; Get lower nibble 
1026 b0			                or      b               ; Combine both nibbles 
1027 c1			                pop     bc              ; Restore B (and C) 
1028 c9			                ret 
1029			; 
1029			; Get a hexadecimal digit from the serial line. This routine blocks until 
1029			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1029			; to the serial line interface. The lower 4 bits of A contain the value of  
1029			; that particular digit. 
1029			; 
1029			;get_nibble      ld a,(hl)           ; Read a character 
1029			;                call    to_upper        ; Convert to upper case 
1029			;                call    is_hex          ; Was it a hex digit? 
1029			;                jr      nc, get_nibble  ; No, get another character 
1029			 ;               call    nibble2val      ; Convert nibble to value 
1029			 ;               call    print_nibble 
1029			 ;               ret 
1029			; 
1029			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1029			; A valid hexadecimal digit is denoted by a set C flag. 
1029			; 
1029			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1029			;                ret     nc              ; Yes 
1029			;                cp      '0'             ; Less than '0'? 
1029			;                jr      nc, is_hex_1    ; No, continue 
1029			;                ccf                     ; Complement carry (i.e. clear it) 
1029			;                ret 
1029			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1029			;                ret     c               ; Yes 
1029			;                cp      'A'             ; Less than 'A'? 
1029			;                jr      nc, is_hex_2    ; No, continue 
1029			;                ccf                     ; Yes - clear carry and return 
1029			;                ret 
1029			;is_hex_2        scf                     ; Set carry 
1029			;                ret 
1029			; 
1029			; Convert a single character contained in A to upper case: 
1029			; 
1029 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
102b d8			                ret     c 
102c fe 7b		                cp      'z' + 1         ; > 'z'? 
102e d0			                ret     nc              ; Nothing to do, either 
102f e6 5f		                and     $5f             ; Convert to upper case 
1031 c9			                ret 
1032			 
1032			 
1032			to_lower: 
1032			 
1032			   ; if char is in [A-Z] make it lower case 
1032			 
1032			   ; enter : a = char 
1032			   ; exit  : a = lower case char 
1032			   ; uses  : af 
1032			 
1032 fe 41		   cp 'A' 
1034 d8			   ret c 
1035			    
1035 fe 5b		   cp 'Z'+1 
1037 d0			   ret nc 
1038			    
1038 f6 20		   or $20 
103a c9			   ret 
103b			 
103b			; 
103b			; Expects a hexadecimal digit (upper case!) in A and returns the 
103b			; corresponding value in A. 
103b			; 
103b fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
103d 38 02		                jr      c, nibble2val_1 ; Yes 
103f d6 07		                sub     7               ; Adjust for A-F 
1041 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1043 e6 0f		                and     $f              ; Only return lower 4 bits 
1045 c9			                ret 
1046			; 
1046			; Print_nibble prints a single hex nibble which is contained in the lower  
1046			; four bits of A: 
1046			; 
1046			;print_nibble    push    af              ; We won't destroy the contents of A 
1046			;                and     $f              ; Just in case... 
1046			;                add     a, '0'             ; If we have a digit we are done here. 
1046			;                cp      '9' + 1         ; Is the result > 9? 
1046			;                jr      c, print_nibble_1 
1046			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1046			;print_nibble_1  call    putc            ; Print the nibble and 
1046			;                pop     af              ; restore the original value of A 
1046			;                ret 
1046			;; 
1046			;; Send a CR/LF pair: 
1046			; 
1046			;crlf            push    af 
1046			;                ld      a, cr 
1046			;                call    putc 
1046			;                ld      a, lf 
1046			;                call    putc 
1046			;                pop     af 
1046			;                ret 
1046			; 
1046			; Print_word prints the four hex digits of a word to the serial line. The  
1046			; word is expected to be in HL. 
1046			; 
1046			;print_word      push    hl 
1046			;                push    af 
1046			;                ld      a, h 
1046			;                call    print_byte 
1046			;                ld      a, l 
1046			;                call    print_byte 
1046			;                pop     af 
1046			;                pop     hl 
1046			;                ret 
1046			; 
1046			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1046			; The byte to be printed is expected to be in A. 
1046			; 
1046			;print_byte      push    af              ; Save the contents of the registers 
1046			;                push    bc 
1046			;                ld      b, a 
1046			;                rrca 
1046			;                rrca 
1046			;                rrca 
1046			;                rrca 
1046			;                call    print_nibble    ; Print high nibble 
1046			;                ld      a, b 
1046			;                call    print_nibble    ; Print low nibble 
1046			;                pop     bc              ; Restore original register contents 
1046			;                pop     af 
1046			;                ret 
1046			 
1046			 
1046			 
1046			 
1046			 
1046			fourehexhl:  
1046 7e				ld a,(hl) 
1047 cd f5 0f			call atohex 
104a cb 3f				SRL A 
104c cb 3f				SRL A 
104e cb 3f				SRL A 
1050 cb 3f				SRL A 
1052 47				ld b, a 
1053 23				inc hl 
1054 7e				ld a,(hl) 
1055 23				inc hl 
1056 cd f5 0f			call atohex 
1059 80				add b 
105a 57				ld d,a 
105b 7e				ld a,(hl) 
105c cd f5 0f			call atohex 
105f cb 3f				SRL A 
1061 cb 3f				SRL A 
1063 cb 3f				SRL A 
1065 cb 3f				SRL A 
1067 47				ld b, a 
1068 23				inc hl 
1069 7e				ld a,(hl) 
106a 23				inc hl 
106b cd f5 0f			call atohex 
106e 80				add b 
106f 5f				ld e, a 
1070 d5				push de 
1071 e1				pop hl 
1072 c9				ret 
1073			 
1073			; pass hl. returns z set if the byte at hl is a digit 
1073			;isdigithl:  
1073			;	push bc 
1073			;	ld a,(hl) 
1073			;	cp ':' 
1073			;	jr nc, .isdf 		; > 
1073			;	cp '0' 
1073			;	jr c, .isdf		; < 
1073			; 
1073			;	; TODO find a better way to set z 
1073			; 
1073			;	ld b,a 
1073			;	cp b 
1073			;	pop bc 
1073			;	ret 
1073			; 
1073			;.isdf:	; not digit so clear z 
1073			; 
1073			;	; TODO find a better way to unset z 
1073			; 
1073			;	ld b,a 
1073			;	inc b 
1073			;	cp b 
1073			; 
1073			;	pop bc 
1073			;	ret 
1073				 
1073				 
1073			 
1073			 
1073			; pass hl as the four byte address to load 
1073			 
1073			get_word_hl:  
1073 e5				push hl 
1074 cd 13 10			call get_byte 
1077				 
1077 47				ld b, a 
1078			 
1078 e1				pop hl 
1079 23				inc hl 
107a 23				inc hl 
107b			 
107b			; TODO not able to handle a-f  
107b 7e				ld a,(hl) 
107c			;	;cp ':' 
107c			;	cp 'g' 
107c			;	jr nc, .single_byte_hl 		; > 
107c			;	cp 'G' 
107c			;	jr nc, .single_byte_hl 		; > 
107c			;	cp '0' 
107c			;	jr c, .single_byte_hl		; < 
107c			 
107c				;call isdigithl 
107c fe 00			cp 0 
107e 28 06			jr z, .single_byte_hl 
1080			 
1080			.getwhln:   ; hex word so get next byte 
1080			 
1080 cd 13 10			call get_byte 
1083 6f				ld l, a 
1084 60				ld h,b 
1085 c9				ret 
1086 68			.single_byte_hl:   ld l,b 
1087 26 00				ld h,0 
1089 c9					ret 
108a			 
108a			 
108a			 
108a			 
108a 21 85 17			ld hl,asc+1 
108d			;	ld a, (hl) 
108d			;	call nibble2val 
108d cd 13 10			call get_byte 
1090			 
1090			;	call fourehexhl 
1090 32 ec ef			ld (scratch+52),a 
1093				 
1093 21 ea ef			ld hl,scratch+50 
1096 22 db f2			ld (os_cur_ptr),hl 
1099			 
1099 c9				ret 
109a			 
109a			 
109a			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
109a			 
109a			; Decimal Unsigned Version 
109a			 
109a			;Number in a to decimal ASCII 
109a			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
109a			;Example: display a=56 as "056" 
109a			;input: a = number 
109a			;Output: a=0,value of a in the screen 
109a			;destroys af,bc (don't know about hl and de) 
109a			DispAToASCII: 
109a 0e 9c			ld	c,-100 
109c cd a6 10			call	.Na1 
109f 0e f6			ld	c,-10 
10a1 cd a6 10			call	.Na1 
10a4 0e ff			ld	c,-1 
10a6 06 2f		.Na1:	ld	b,'0'-1 
10a8 04			.Na2:	inc	b 
10a9 81				add	a,c 
10aa 38 fc			jr	c,.Na2 
10ac 91				sub	c		;works as add 100/10/1 
10ad f5				push af		;safer than ld c,a 
10ae 78				ld	a,b		;char is in b 
10af			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10af f1				pop af		;safer than ld a,c 
10b0 c9				ret 
10b1			 
10b1			; Decimal Signed Version 
10b1			 
10b1			; DispA 
10b1			; -------------------------------------------------------------- 
10b1			; Converts a signed integer value to a zero-terminated ASCII 
10b1			; string representative of that value (using radix 10). 
10b1			; -------------------------------------------------------------- 
10b1			; INPUTS: 
10b1			;     HL     Value to convert (two's complement integer). 
10b1			;     DE     Base address of string destination. (pointer). 
10b1			; -------------------------------------------------------------- 
10b1			; OUTPUTS: 
10b1			;     None 
10b1			; -------------------------------------------------------------- 
10b1			; REGISTERS/MEMORY DESTROYED 
10b1			; AF HL 
10b1			; -------------------------------------------------------------- 
10b1			 
10b1			;DispHLToASCII: 
10b1			;   push    de 
10b1			;   push    bc 
10b1			; 
10b1			;; Detect sign of HL. 
10b1			;    bit    7, h 
10b1			;    jr     z, ._DoConvert 
10b1			; 
10b1			;; HL is negative. Output '-' to string and negate HL. 
10b1			;    ld     a, '-' 
10b1			;    ld     (de), a 
10b1			;    inc    de 
10b1			; 
10b1			;; Negate HL (using two's complement) 
10b1			;    xor    a 
10b1			;    sub    l 
10b1			;    ld     l, a 
10b1			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10b1			;    sbc    a, h 
10b1			;    ld     h, a 
10b1			; 
10b1			;; Convert HL to digit characters 
10b1			;._DoConvert: 
10b1			;    ld     b, 0     ; B will count character length of number 
10b1			;-   ld     a, 10 
10b1			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10b1			;    push   af 
10b1			;    inc    b 
10b1			;    ld     a, h 
10b1			;    or     l 
10b1			;    jr     nz, - 
10b1			; 
10b1			;; Retrieve digits from stack 
10b1			;-   pop    af 
10b1			;    or     $30 
10b1			;    ld     (de), a 
10b1			;    inc    de 
10b1			;    djnz   - 
10b1			; 
10b1			;; Terminate string with NULL 
10b1			;    xor    a 
10b1			;    ld     (de), a 
10b1			; 
10b1			;    pop    bc 
10b1			;    pop    de 
10b1			;    ret 
10b1			 
10b1			;Comments 
10b1			; 
10b1			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10b1			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10b1			;    Note that the output string will not be fixed-width. 
10b1			; 
10b1			;Example Usage 
10b1			; 
10b1			;    ld    hl, -1004 
10b1			;    ld    de, OP1 
10b1			;    call  DispA 
10b1			;    ld    hl, OP1 
10b1			;    syscall  PutS 
10b1			 
10b1			 
10b1			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10b1			 
10b1			 
10b1			;Converts an ASCII string to an unsigned 16-bit integer 
10b1			;Quits when it reaches a non-decimal digit 
10b1			 
10b1			string_to_uint16: 
10b1			atoui_16: 
10b1			;Input: 
10b1			;     DE points to the string 
10b1			;Outputs: 
10b1			;     HL is the result 
10b1			;     A is the 8-bit value of the number 
10b1			;     DE points to the byte after the number 
10b1			;Destroys: 
10b1			;     BC 
10b1			;       if the string is non-empty, BC is HL/10 
10b1			;Size:  24 bytes 
10b1			;Speed: 42+d(104+{0,9}) 
10b1			;       d is the number of digits in the number 
10b1			;       max is 640 cycles for a 5 digit number 
10b1			;Assuming no leading zeros: 
10b1			;1 digit:  146cc 
10b1			;2 digit:  250cc 
10b1			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10b1			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10b1			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10b1			;avg: 544.81158447265625cc (544+13297/16384) 
10b1			;=============================================================== 
10b1 21 00 00		  ld hl,0 
10b4			.u16a: 
10b4 1a			  ld a,(de) 
10b5 d6 30		  sub 30h 
10b7 fe 0a		  cp 10 
10b9 d0			  ret nc 
10ba 13			  inc de 
10bb 44			  ld b,h 
10bc 4d			  ld c,l 
10bd 29			  add hl,hl 
10be 29			  add hl,hl 
10bf 09			  add hl,bc 
10c0 29			  add hl,hl 
10c1 85			  add a,l 
10c2 6f			  ld l,a 
10c3 30 ef		  jr nc,.u16a 
10c5 24			  inc h 
10c6 c3 b4 10		  jp .u16a 
10c9			 
10c9			 
10c9			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10c9			 
10c9			;written by Zeda 
10c9			;Converts a 16-bit unsigned integer to an ASCII string. 
10c9			 
10c9			uitoa_16: 
10c9			;Input: 
10c9			;   DE is the number to convert 
10c9			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
10c9			;Output: 
10c9			;   HL points to the null-terminated ASCII string 
10c9			;      NOTE: This isn't necessarily the same as the input HL. 
10c9 d5			  push de 
10ca c5			  push bc 
10cb f5			  push af 
10cc eb			  ex de,hl 
10cd			 
10cd 01 f0 d8		  ld bc,-10000 
10d0 3e 2f		  ld a,'0'-1 
10d2 3c			  inc a 
10d3 09			  add hl,bc  
10d4 38 fc		   jr c,$-2 
10d6 12			  ld (de),a 
10d7 13			  inc de 
10d8			 
10d8 01 e8 03		  ld bc,1000 
10db 3e 3a		  ld a,'9'+1 
10dd 3d			  dec a  
10de 09			  add hl,bc  
10df 30 fc		   jr nc,$-2 
10e1 12			  ld (de),a 
10e2 13			  inc de 
10e3			 
10e3 01 9c ff		  ld bc,-100 
10e6 3e 2f		  ld a,'0'-1 
10e8 3c			  inc a  
10e9 09			  add hl,bc  
10ea 38 fc		   jr c,$-2 
10ec 12			  ld (de),a 
10ed 13			  inc de 
10ee			 
10ee 7d			  ld a,l 
10ef 26 3a		  ld h,'9'+1 
10f1 25			  dec h  
10f2 c6 0a		  add a,10  
10f4 30 fb		   jr nc,$-3 
10f6 c6 30		  add a,'0' 
10f8 eb			  ex de,hl 
10f9 72			  ld (hl),d 
10fa 23			  inc hl 
10fb 77			  ld (hl),a 
10fc 23			  inc hl 
10fd 36 00		  ld (hl),0 
10ff			 
10ff			;Now strip the leading zeros 
10ff 0e fa		  ld c,-6 
1101 09			  add hl,bc 
1102 3e 30		  ld a,'0' 
1104 23			  inc hl  
1105 be			  cp (hl)  
1106 28 fc		  jr z,$-2 
1108			 
1108			;Make sure that the string is non-empty! 
1108 7e			  ld a,(hl) 
1109 b7			  or a 
110a 20 01		  jr nz,.atoub 
110c 2b			  dec hl 
110d			.atoub: 
110d			 
110d f1			  pop af 
110e c1			  pop bc 
110f d1			  pop de 
1110 c9			  ret 
1111			 
1111			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1111			 
1111			toUpper: 
1111			;A is the char. 
1111			;If A is a lowercase letter, this sets it to the matching uppercase 
1111			;18cc or 30cc or 41cc 
1111			;avg: 26.75cc 
1111 fe 61		  cp 'a' 
1113 d8			  ret c 
1114 fe 7b		  cp 'z'+1 
1116 d0			  ret nc 
1117 d6 20		  sub 'a'-'A' 
1119 c9			  ret 
111a			 
111a			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
111a			 
111a			; String Length 
111a			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
111a			 
111a			; Get the length of the null-terminated string starting at $8000 hl 
111a			;    LD     HL, $8000 
111a			 
111a			strlenz: 
111a			 
111a af			    XOR    A               ; Zero is the value we are looking for. 
111b 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
111c 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
111d			                           ; 65, 536 bytes (the entire addressable memory space). 
111d ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
111f			 
111f			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
111f 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1120 6f			    LD     L, A             ; number of bytes 
1121 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1123 2b			    DEC    HL              ; Compensate for null. 
1124 c9				ret 
1125			 
1125			; Get the length of the A terminated string starting at $8000 hl 
1125			;    LD     HL, $8000 
1125			 
1125			strlent: 
1125			 
1125			                  ; A is the value we are looking for. 
1125 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1127 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1129			                           ; 65, 536 bytes (the entire addressable memory space). 
1129 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
112b			 
112b			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
112b 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
112d 2e 00		    LD     L, 0             ; number of bytes 
112f ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1131 2b			    DEC    HL              ; Compensate for null. 
1132 c9				ret 
1133			 
1133			 
1133			;Comparing Strings 
1133			 
1133			;IN    HL     Address of string1. 
1133			;      DE     Address of string2. 
1133			 
1133			; doc given but wrong??? 
1133			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1133			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1133			; tested 
1133			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1133			 
1133			strcmp_old: 
1133 e5			    PUSH   HL 
1134 d5			    PUSH   DE 
1135			 
1135 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1136 be			    CP     (HL)            ; (want to minimize work). 
1137 38 01		    JR     C, Str1IsBigger 
1139 7e			    LD     A, (HL) 
113a			 
113a			Str1IsBigger: 
113a 4f			    LD     C, A             ; Put length in BC 
113b 06 00		    LD     B, 0 
113d 13			    INC    DE              ; Increment pointers to meat of string. 
113e 23			    INC    HL 
113f			 
113f			CmpLoop: 
113f 1a			    LD     A, (DE)          ; Compare bytes. 
1140 ed a1		    CPI 
1142 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1144 13			    INC    DE              ; Update pointer. 
1145 ea 3f 11		    JP     PE, CmpLoop 
1148			 
1148 d1			    POP    DE 
1149 e1			    POP    HL 
114a 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
114b be			    CP     (HL) 
114c c9			    RET 
114d			 
114d			NoMatch: 
114d 2b			    DEC    HL 
114e be			    CP     (HL)            ; Compare again to affect carry. 
114f d1			    POP    DE 
1150 e1			    POP    HL 
1151 c9			    RET 
1152			 
1152			;; test strmp 
1152			; 
1152			;ld de, .str1 
1152			;ld hl, .str2 
1152			;call strcmp 
1152			;jr z, .z1 
1152			;;this 
1152			;	if DEBUG_FORTH_WORDS 
1152			;		DMARK "NZ1" 
1152			;		CALLMONITOR 
1152			;	endif 
1152			;.z1: 
1152			; 
1152			;	if DEBUG_FORTH_WORDS 
1152			;		DMARK "ZZ1" 
1152			;		CALLMONITOR 
1152			;	endif 
1152			; 
1152			;ld de, .str1 
1152			;ld hl, .str1 
1152			;call strcmp 
1152			;jr z, .z2 
1152			;;this 
1152			;	if DEBUG_FORTH_WORDS 
1152			;		DMARK "NZ2" 
1152			;		CALLMONITOR 
1152			;	endif 
1152			;.z2: 
1152			; 
1152			;	if DEBUG_FORTH_WORDS 
1152			;		DMARK "ZZ2" 
1152			;		CALLMONITOR 
1152			;	endif 
1152			; 
1152			;ld de, .str1 
1152			;ld hl, .str2 
1152			;call strcmp 
1152			;jr c, .c1 
1152			; 
1152			;	if DEBUG_FORTH_WORDS 
1152			;		DMARK "Nc1" 
1152			;		CALLMONITOR 
1152			;	endif 
1152			;.c1: 
1152			;;this 
1152			;	if DEBUG_FORTH_WORDS 
1152			;		DMARK "cc1" 
1152			;		CALLMONITOR 
1152			;	endif 
1152			; 
1152			;ld de, .str1 
1152			;ld hl, .str1 
1152			;call strcmp 
1152			;jr c, .c2 
1152			;;this 
1152			;	if DEBUG_FORTH_WORDS 
1152			;		DMARK "Nc2" 
1152			;		CALLMONITOR 
1152			;	endif 
1152			;.c2: 
1152			; 
1152			;	if DEBUG_FORTH_WORDS 
1152			;		DMARK "cc2" 
1152			;		CALLMONITOR 
1152			;	endif 
1152			;	NEXTW 
1152			;.str1:   db "string1",0 
1152			;.str2:   db "string2",0 
1152			 
1152			; only care about direct match or not 
1152			; hl and de strings 
1152			; zero set if the same 
1152			 
1152			strcmp: 
1152 1a				ld a, (de) 
1153 be				cp (hl) 
1154 28 02			jr z, .ssame 
1156 b7				or a 
1157 c9				ret 
1158			 
1158			.ssame:  
1158 fe 00			cp 0 
115a c8				ret z 
115b			 
115b 23				inc hl 
115c 13				inc de 
115d 18 f3			jr strcmp 
115f				 
115f				 
115f			 
115f			 
115f			 
115f			 
115f			; eof 
115f			 
115f			 
115f			 
115f			 
115f			 
115f			 
# End of file firmware_strings.asm
115f			include "firmware_memory.asm"   ; malloc and free  
115f			 
115f			if DEBUG_FORTH_MALLOC_HIGH 
115f			.mallocsize: db "Wants malloc >256",0 
115f			.mallocasize: db "MALLOC gives >256",0 
115f			.malloczero: db "MALLOC gives zero",0 
115f			 
115f			malloc_guard_zerolen: 
115f				push hl 
115f				push de 
115f				push af 
115f			 
115f				ld de, 0 
115f			        call cmp16 
115f				jr nz, .lowalloz 
115f			 
115f				push hl 
115f				push de 
115f					ld hl, display_fb0 
115f					ld (display_fb_active), hl 
115f				call clear_display 
115f				ld a, 0 
115f				ld de, .malloczero 
115f				call str_at_display 
115f				call update_display 
115f				call delay1s 
115f				call delay1s 
115f				ld a, 0 
115f				ld (os_view_disable), a 
115f			 
115f				pop de 
115f				pop hl 
115f			 
115f				 
115f			 
115f				CALLMONITOR 
115f			.lowalloz: 
115f			 
115f			 
115f				pop af 
115f				pop de 
115f				pop hl 
115f			ret 
115f			 
115f			malloc_guard_entry: 
115f				push hl 
115f				push de 
115f				push af 
115f			 
115f			 	or a      ;clear carry flag 
115f				push hl 
115f				ld de, 255 
115f				sbc hl, de 
115f				jr c, .lowalloc 
115f			 
115f				push de 
115f					ld hl, display_fb0 
115f					ld (display_fb_active), hl 
115f				call clear_display 
115f				ld a, 0 
115f				ld de, .mallocsize 
115f				call str_at_display 
115f				call update_display 
115f				call delay1s 
115f				call delay1s 
115f				ld a, 0 
115f				ld (os_view_disable), a 
115f			 
115f				pop de 
115f				pop hl 
115f			 
115f				 
115f			 
115f				CALLMONITOR 
115f				jr .lowdone 
115f			.lowalloc: 
115f			 
115f			 
115f				pop hl 
115f			.lowdone:	pop af 
115f				pop de 
115f				pop hl 
115f			ret 
115f			 
115f			malloc_guard_exit: 
115f				push hl 
115f				push de 
115f				push af 
115f			 
115f			 	or a      ;clear carry flag 
115f				push hl 
115f				ld de, 255 
115f				sbc hl, de 
115f				jr c, .lowallocx 
115f			 
115f				push de 
115f					ld hl, display_fb0 
115f					ld (display_fb_active), hl 
115f				call clear_display 
115f				ld a, 0 
115f				ld de, .mallocasize 
115f				call str_at_display 
115f				call update_display 
115f				call delay1s 
115f				call delay1s 
115f				ld a, 0 
115f				ld (os_view_disable), a 
115f				pop de 
115f				pop hl 
115f			 
115f				CALLMONITOR 
115f				jr .lowdonex 
115f			.lowallocx: 
115f			 
115f				pop hl 
115f			.lowdonex:	pop af 
115f				pop de 
115f				pop hl 
115f			ret 
115f			endif 
115f			 
115f			if MALLOC_2 
115f			; Z80 Malloc and Free Functions 
115f			 
115f			; Malloc Function: 
115f			; Input: 
115f			;   HL: Size of block to allocate 
115f			; Output: 
115f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
115f			 
115f			malloc: 
115f				 
115f			if DEBUG_FORTH_MALLOC_HIGH 
115f			call malloc_guard_entry 
115f			endif 
115f			 
115f			 
115f			 
115f			 
115f					if DEBUG_FORTH_MALLOC 
115f						DMARK "mal" 
115f						CALLMONITOR 
115f					endif 
115f			    push af            ; Save AF register 
115f			    ld a, l            ; Load low byte of size into A 
115f			    or h               ; Check if size is zero 
115f			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
115f			 
115f			    ; Allocate memory 
115f			    ld hl, (heap_start) ; Load start of heap into HL 
115f					if DEBUG_FORTH_MALLOC 
115f						DMARK "ma1" 
115f						CALLMONITOR 
115f					endif 
115f			    call malloc_internal ; Call internal malloc function 
115f			    pop af             ; Restore AF register 
115f			if DEBUG_FORTH_MALLOC_HIGH 
115f			call malloc_guard_exit 
115f			call malloc_guard_zerolen 
115f			endif 
115f			    ret                ; Return 
115f			 
115f			; Free Function: 
115f			; Input: 
115f			;   HL: Pointer to memory block to free 
115f			; Output: 
115f			;   None 
115f			 
115f			free: 
115f			    push af            ; Save AF register 
115f			    ld a, l            ; Load low byte of pointer into A 
115f			    or h               ; Check if pointer is NULL 
115f			    jp z, free_exit    ; If pointer is NULL, exit 
115f			 
115f			    ; Free memory 
115f			    ld hl, (heap_start) ; Load start of heap into HL 
115f			    call free_internal  ; Call internal free function 
115f			    pop af             ; Restore AF register 
115f			    ret                ; Return 
115f			 
115f			; Internal Malloc Function: 
115f			; Input: 
115f			;   HL: Size of block to allocate 
115f			; Output: 
115f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
115f			 
115f			malloc_internal: 
115f			    ld bc, 2           ; Number of bytes to allocate for management overhead 
115f			    add hl, bc         ; Add management overhead to requested size 
115f			    ex de, hl          ; Save total size in DE, and keep it in HL 
115f					if DEBUG_FORTH_MALLOC 
115f						DMARK "ma2" 
115f						CALLMONITOR 
115f					endif 
115f			 
115f			    ; Search for free memory block 
115f			    ld de, (heap_end)  ; Load end of heap into DE 
115f			    ld bc, 0           ; Initialize counter 
115f			 
115f					if DEBUG_FORTH_MALLOC 
115f						DMARK "ma2" 
115f						CALLMONITOR 
115f					endif 
115f			malloc_search_loop: 
115f			    ; Check if current block is free 
115f			    ld a, (hl)         ; Load current block's status (free or used) 
115f			    cp 0               ; Compare with zero (free) 
115f			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
115f			 
115f			    ; Check if current block is large enough 
115f			    ld a, (hl+1)       ; Load high byte of block size 
115f			    cp l               ; Compare with low byte of requested size 
115f			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
115f			 
115f			    ld a, (hl+2)       ; Load low byte of block size 
115f			    cp h               ; Compare with high byte of requested size 
115f			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
115f			 
115f			    ; Mark block as used 
115f			    ld (hl), 0xFF      ; Set status byte to indicate used block 
115f			 
115f			    ; Calculate remaining space in block 
115f			    ld bc, 0           ; Clear BC 
115f			    add hl, bc         ; Increment HL to point to start of data block 
115f			    add hl, de         ; HL = HL + DE (total size) 
115f			    ld bc, 1           ; Number of bytes to allocate for management overhead 
115f			    add hl, bc         ; Add management overhead to start of data block 
115f			 
115f			    ; Save pointer to allocated block in HL 
115f			if DEBUG_FORTH_MALLOC_HIGH 
115f						DMARK "ma5" 
115f			call malloc_guard_exit 
115f			call malloc_guard_zerolen 
115f			endif 
115f			    ret 
115f			 
115f			malloc_skip_block_check: 
115f			    ; Move to the next block 
115f			    ld bc, 3           ; Size of management overhead 
115f			    add hl, bc         ; Move to the next block 
115f			    inc de             ; Increment counter 
115f			 
115f			    ; Check if we have reached the end of heap 
115f			    ld a, e            ; Load low byte of heap end address 
115f			    cp (hl)            ; Compare with low byte of current address 
115f			    jr nz, malloc_search_loop  ; If not equal, continue searching 
115f			    ld a, d            ; Load high byte of heap end address 
115f			    cp 0               ; Check if it's zero (end of memory) 
115f			    jr nz, malloc_search_loop  ; If not zero, continue searching 
115f			 
115f			    ; If we reached here, allocation failed 
115f			    xor a              ; Set result to NULL 
115f			if DEBUG_FORTH_MALLOC_HIGH 
115f						DMARK "ma6" 
115f			call malloc_guard_exit 
115f			call malloc_guard_zerolen 
115f			endif 
115f			    ret 
115f			malloc_exit: 
115f			if DEBUG_FORTH_MALLOC_HIGH 
115f						DMARK "ma7" 
115f			call malloc_guard_exit 
115f			call malloc_guard_zerolen 
115f			endif 
115f			    ret 
115f			 
115f			; Internal Free Function: 
115f			; Input: 
115f			;   HL: Pointer to memory block to free 
115f			; Output: 
115f			;   None 
115f			 
115f			free_internal: 
115f			    ld de, (heap_start) ; Load start of heap into DE 
115f			    ld bc, 0            ; Initialize counter 
115f			 
115f			free_search_loop: 
115f			    ; Check if current block contains the pointer 
115f			    ld a, l             ; Load low byte of pointer 
115f			    cp (hl+1)           ; Compare with high byte of current block's address 
115f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
115f			    ld a, h             ; Load high byte of pointer 
115f			    cp (hl+2)           ; Compare with low byte of current block's address 
115f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
115f			 
115f			    ; Mark block as free 
115f			    ld (hl), 0          ; Set status byte to indicate free block 
115f			    ret                 ; Return 
115f			 
115f			free_skip_block_check: 
115f			    ; Move to the next block 
115f			    ld bc, 3            ; Size of management overhead 
115f			    add hl, bc          ; Move to the next block 
115f			    inc de              ; Increment counter 
115f			 
115f			    ; Check if we have reached the end of heap 
115f			    ld a, e             ; Load low byte of heap end address 
115f			    cp (hl)             ; Compare with low byte of current address 
115f			    jr nz, free_search_loop  ; If not equal, continue searching 
115f			    ld a, d             ; Load high byte of heap end address 
115f			    cp 0                ; Check if it's zero (end of memory) 
115f			    jr nz, free_search_loop  ; If not zero, continue searching 
115f			 
115f			    ; If we reached here, pointer is not found in heap 
115f			    ret 
115f			 
115f			free_exit: 
115f			    ret                 ; Return 
115f			 
115f			; Define heap start and end addresses 
115f			;heap_start:    .dw 0xC000   ; Start of heap 
115f			;heap_end:      .dw 0xE000   ; End of heap 
115f			 
115f			endif 
115f			 
115f			 
115f			if MALLOC_1 
115f			 
115f			 
115f			 
115f			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
115f			 
115f			;moved to firmware.asm 
115f			;heap_start        .equ  0x9000      ; Starting address of heap 
115f			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
115f			 
115f			;      .org 0 
115f			;      jp    main 
115f			 
115f			 
115f			;      .org  0x100 
115f			;main: 
115f			;      ld    HL, 0x8100 
115f			;      ld    SP, HL 
115f			; 
115f			;      call  heap_init 
115f			; 
115f			;      ; Make some allocations 
115f			;      ld    HL, 12 
115f			;      call  malloc            ; Allocates 0x9004 
115f			; 
115f			;      ld    HL, 12 
115f			;      call  malloc            ; Allocates 0x9014 
115f			; 
115f			;      ld    HL, 12 
115f			;      call  malloc            ; Allocates 0x9024 
115f			; 
115f			;      ; Free some allocations 
115f			;      ld    HL, 0x9014 
115f			;      call  free 
115f			; 
115f			;      ld    HL, 0x9004 
115f			;      call  free 
115f			; 
115f			;      ld    HL, 0x9024 
115f			;      call  free 
115f			; 
115f			; 
115f			;      halt 
115f			 
115f			 
115f			;------------------------------------------------------------------------------ 
115f			;     heap_init                                                               : 
115f			;                                                                             : 
115f			; Description                                                                 : 
115f			;     Initialise the heap and make it ready for malloc and free operations.   : 
115f			;                                                                             : 
115f			;     The heap is maintained as a linked list, starting with an initial       : 
115f			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
115f			;     the first free block in the heap. Each block then points to the next    : 
115f			;     free block within the heap, and the free list ends at the first block   : 
115f			;     with a null pointer to the next free block.                             : 
115f			;                                                                             : 
115f			; Parameters                                                                  : 
115f			;     Inputs are compile-time only. Two defines which specify the starting    : 
115f			;     address of the heap and its size are required, along with a memory      : 
115f			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
115f			;     principally stores a pointer to the first free block in the heap.       : 
115f			;                                                                             : 
115f			; Returns                                                                     : 
115f			;     Nothing                                                                 : 
115f			;------------------------------------------------------------------------------ 
115f			heap_init: 
115f e5			      push  HL 
1160			 
1160			      ; Initialise free list struct 
1160 21 0e 80		      ld    HL, heap_start 
1163 22 0a 80		      ld    (free_list), HL 
1166 21 00 00		      ld    HL, 0 
1169 22 0c 80		      ld    (free_list+2), HL 
116c			 
116c			      ; Insert first free block at bottom of heap, consumes entire heap 
116c 21 0a 80		      ld    HL, heap_start+heap_size-4 
116f 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1172 21 fc ff		      ld    HL, heap_size-4 
1175 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1178			 
1178			      ; Insert end of free list block at top of heap - two null words will 
1178			      ; terminate the free list 
1178 21 00 00		      ld    HL, 0 
117b 22 0c 80		      ld    (heap_start+heap_size-2), HL 
117e 22 0a 80		      ld    (heap_start+heap_size-4), HL 
1181			 
1181 e1			      pop   HL 
1182			 
1182 c9			      ret 
1183			 
1183			 
1183			;------------------------------------------------------------------------------ 
1183			;     malloc                                                                  : 
1183			;                                                                             : 
1183			; Description                                                                 : 
1183			;     Allocates the wanted space from the heap and returns the address of the : 
1183			;     first useable byte of the allocation.                                   : 
1183			;                                                                             : 
1183			;     Allocations can happen in one of two ways:                              : 
1183			;                                                                             : 
1183			;     1. A free block may be found which is the exact size wanted. In this    : 
1183			;        case the block is removed from the free list and retuedn to the      : 
1183			;        caller.                                                              : 
1183			;     2. A free block may be found which is larger than the size wanted. In   : 
1183			;        this case, the larger block is split into two. The first portion of  : 
1183			;        this block will become the requested space by the malloc call and    : 
1183			;        is returned to the caller. The second portion becomes a new free     : 
1183			;        block, and the free list is adjusted to maintain continuity via this : 
1183			;        newly created block.                                                 : 
1183			;                                                                             : 
1183			;     malloc does not set any initial value in the allocated space, the       : 
1183			;     caller is required to do this as required.                              : 
1183			;                                                                             : 
1183			;     This implementation of malloc uses the stack exclusively, and is        : 
1183			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1183			;     advisable to disable interrupts before calling malloc, and recommended  : 
1183			;     to avoid the use of malloc inside ISRs in general.                      : 
1183			;                                                                             : 
1183			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1183			;                                                                             : 
1183			; Parameters                                                                  : 
1183			;     HL  Number of bytes wanted                                              : 
1183			;                                                                             : 
1183			; Returns                                                                     : 
1183			;     HL  Address of the first useable byte of the allocation                 : 
1183			;                                                                             : 
1183			; Flags                                                                       : 
1183			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1183			;                                                                             : 
1183			; Stack frame                                                                 : 
1183			;       |             |                                                       : 
1183			;       +-------------+                                                       : 
1183			;       |     BC      |                                                       : 
1183			;       +-------------+                                                       : 
1183			;       |     DE      |                                                       : 
1183			;       +-------------+                                                       : 
1183			;       |     IX      |                                                       : 
1183			;       +-------------+                                                       : 
1183			;       |  prev_free  |                                                       : 
1183			;   +4  +-------------+                                                       : 
1183			;       |  this_free  |                                                       : 
1183			;   +2  +-------------+                                                       : 
1183			;       |  next_free  |                                                       : 
1183			;   +0  +-------------+                                                       : 
1183			;       |             |                                                       : 
1183			;                                                                             : 
1183			;------------------------------------------------------------------------------ 
1183			 
1183			 
1183			;malloc: 
1183			; 
1183			;	SAVESP ON 1 
1183			; 
1183			;	call malloc_code 
1183			; 
1183			;	CHECKSP ON 1 
1183			;	ret 
1183			 
1183			 
1183			malloc: 
1183 c5			      push  BC 
1184 d5			      push  DE 
1185 dd e5		      push  IX 
1187			if DEBUG_FORTH_MALLOC_HIGH 
1187			call malloc_guard_entry 
1187			endif 
1187			 
1187					if DEBUG_FORTH_MALLOC 
1187						DMARK "mal" 
1187						CALLMONITOR 
1187					endif 
1187 7c			      ld    A, H                    ; Exit if no space requested 
1188 b5			      or    L 
1189 ca 48 12		      jp    Z, malloc_early_exit 
118c			 
118c			;inc hl 
118c			;inc hl 
118c			;inc hl 
118c			; 
118c			;inc hl 
118c			;inc hl 
118c			;inc hl 
118c			;inc hl 
118c			;inc hl 
118c			;inc hl 
118c			;inc hl 
118c			;inc hl 
118c			;inc hl 
118c			 
118c			 
118c			 
118c			 
118c					if DEBUG_FORTH_MALLOC 
118c						DMARK "maA" 
118c						CALLMONITOR 
118c					endif 
118c			      ; Set up stack frame 
118c eb			      ex    DE, HL 
118d 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1190 39			      add   HL, SP 
1191 f9			      ld    SP, HL 
1192 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1196 dd 39		      add   IX, SP 
1198			 
1198			      ; Setup initial state 
1198 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
119b 19			      add   HL, DE 
119c			 
119c 44			      ld    B, H                    ; Move want to BC 
119d 4d			      ld    C, L 
119e			 
119e 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
11a1 dd 75 04		      ld    (IX+4), L 
11a4 dd 74 05		      ld    (IX+5), H 
11a7			 
11a7 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11a8 23			      inc   HL 
11a9 56			      ld    D, (HL) 
11aa dd 73 02		      ld    (IX+2), E 
11ad dd 72 03		      ld    (IX+3), D 
11b0 eb			      ex    DE, HL                  ; this_free ptr into HL 
11b1			 
11b1					if DEBUG_FORTH_MALLOC 
11b1						DMARK "maB" 
11b1						CALLMONITOR 
11b1					endif 
11b1			      ; Loop through free block list to find some space 
11b1			malloc_find_space: 
11b1 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11b2 23			      inc   HL 
11b3 56			      ld    D, (HL) 
11b4			 
11b4 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
11b5 b3			      or    E 
11b6 ca 42 12		      jp    Z, malloc_no_space 
11b9			 
11b9 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
11bc dd 72 01		      ld    (IX+1), D 
11bf			 
11bf			      ; Does this block have enough space to make the allocation? 
11bf 23			      inc   HL                      ; Load free block size into DE 
11c0 5e			      ld    E, (HL) 
11c1 23			      inc   HL 
11c2 56			      ld    D, (HL) 
11c3			 
11c3 eb			      ex    DE, HL                  ; Check size of block against want 
11c4 b7			      or    A                       ; Ensure carry flag clear 
11c5 ed 42		      sbc   HL, BC 
11c7 e5			      push  HL                      ; Store the result for later (new block size) 
11c8			 
11c8 ca 17 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
11cb 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
11cd			 
11cd			      ; this_free block is not big enough, setup ptrs to test next free block 
11cd e1			      pop   HL                      ; Discard previous result 
11ce			 
11ce dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
11d1 dd 66 03		      ld    H, (IX+3) 
11d4 dd 75 04		      ld    (IX+4), L 
11d7 dd 74 05		      ld    (IX+5), H 
11da			 
11da dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
11dd dd 66 01		      ld    H, (IX+1) 
11e0 dd 75 02		      ld    (IX+2), L 
11e3 dd 74 03		      ld    (IX+3), H 
11e6			 
11e6					if DEBUG_FORTH_MALLOC 
11e6						DMARK "MA>" 
11e6						CALLMONITOR 
11e6					endif 
11e6 18 c9		      jr    malloc_find_space 
11e8			 
11e8			      ; split a bigger block into two - requested size and remaining size 
11e8			malloc_alloc_split: 
11e8					if DEBUG_FORTH_MALLOC 
11e8						DMARK "MAs" 
11e8						CALLMONITOR 
11e8					endif 
11e8 eb			      ex    DE, HL                  ; Calculate address of new free block 
11e9 2b			      dec   HL 
11ea 2b			      dec   HL 
11eb 2b			      dec   HL 
11ec 09			      add   HL, BC 
11ed			 
11ed			      ; Create a new block and point it at next_free 
11ed dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
11f0 dd 56 01		      ld    D, (IX+1) 
11f3			 
11f3 73			      ld    (HL), E                 ; Store next_free ptr into new block 
11f4 23			      inc   HL 
11f5 72			      ld    (HL), D 
11f6			 
11f6 d1			      pop   DE                      ; Store size of new block into new block 
11f7 23			      inc   HL 
11f8 73			      ld    (HL), E 
11f9 23			      inc   HL 
11fa 72			      ld    (HL), D 
11fb			 
11fb			      ; Update this_free ptr to point to new block 
11fb 2b			      dec   HL 
11fc 2b			      dec   HL 
11fd 2b			      dec   HL 
11fe			 
11fe dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1201 dd 56 03		      ld    D, (IX+3) 
1204			 
1204 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1207 dd 74 03		      ld    (IX+3), H 
120a			 
120a			      ; Modify this_free block to be allocation 
120a eb			      ex    DE, HL 
120b af			      xor   A                       ; Null the next block ptr of allocated block 
120c 77			      ld    (HL), A 
120d 23			      inc   HL 
120e 77			      ld    (HL), A 
120f			 
120f 23			      inc   HL                      ; Store want size into allocated block 
1210 71			      ld    (HL), C 
1211 23			      inc   HL 
1212 70			      ld    (HL), B 
1213 23			      inc   HL 
1214 e5			      push  HL                      ; Address of allocation to return 
1215			 
1215 18 19		      jr    malloc_update_links 
1217			 
1217			malloc_alloc_fit: 
1217 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1218			 
1218					if DEBUG_FORTH_MALLOC 
1218						DMARK "MAf" 
1218						CALLMONITOR 
1218					endif 
1218			      ; Modify this_free block to be allocation 
1218 eb			      ex    DE, HL 
1219 2b			      dec   HL 
121a 2b			      dec   HL 
121b 2b			      dec   HL 
121c			 
121c af			      xor   A                       ; Null the next block ptr of allocated block 
121d 77			      ld    (HL), A 
121e 23			      inc   HL 
121f 77			      ld    (HL), A 
1220			 
1220 23			      inc   HL                      ; Store address of allocation to return 
1221 23			      inc   HL 
1222 23			      inc   HL 
1223 e5			      push  HL 
1224			 
1224			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1224 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1227 dd 66 01		      ld    H, (IX+1) 
122a			 
122a dd 75 02		      ld    (IX+2), L               ; HL to this_free 
122d dd 74 03		      ld    (IX+3), H 
1230			 
1230			 
1230			malloc_update_links: 
1230			      ; Update prev_free ptr to point to this_free 
1230 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1233 dd 66 05		      ld    H, (IX+5) 
1236			 
1236 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1239 dd 56 03		      ld    D, (IX+3) 
123c			 
123c 73			      ld    (HL), E                 ; this_free ptr into prev_free 
123d 23			      inc   HL 
123e 72			      ld    (HL), D 
123f			 
123f					if DEBUG_FORTH_MALLOC 
123f						DMARK "Mul" 
123f						CALLMONITOR 
123f					endif 
123f			      ; Clear the Z flag to indicate successful allocation 
123f 7a			      ld    A, D 
1240 b3			      or    E 
1241			 
1241 d1			      pop   DE                      ; Address of allocation 
1242					if DEBUG_FORTH_MALLOC 
1242						DMARK "MAu" 
1242						CALLMONITOR 
1242					endif 
1242			 
1242			malloc_no_space: 
1242 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1245 39			      add   HL, SP 
1246 f9			      ld    SP, HL 
1247			 
1247 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1248					if DEBUG_FORTH_MALLOC 
1248						DMARK "MAN" 
1248						CALLMONITOR 
1248					endif 
1248			 
1248			malloc_early_exit: 
1248					if DEBUG_FORTH_MALLOC 
1248						DMARK "MAx" 
1248						CALLMONITOR 
1248					endif 
1248 dd e1		      pop   IX 
124a d1			      pop   DE 
124b c1			      pop   BC 
124c			 
124c			if DEBUG_FORTH_MALLOC_HIGH 
124c			call malloc_guard_exit 
124c			call malloc_guard_zerolen 
124c			endif 
124c c9			      ret 
124d			 
124d			 
124d			;------------------------------------------------------------------------------ 
124d			;     free                                                                    : 
124d			;                                                                             : 
124d			; Description                                                                 : 
124d			;     Return the space pointed to by HL to the heap. HL must be an address as : 
124d			;     returned by malloc, otherwise the behaviour is undefined.               : 
124d			;                                                                             : 
124d			;     Where possible, directly adjacent free blocks will be merged together   : 
124d			;     into larger blocks to help ensure that the heap does not become         : 
124d			;     excessively fragmented.                                                 : 
124d			;                                                                             : 
124d			;     free does not clear or set any other value into the freed space, and    : 
124d			;     therefore its contents may be visible through subsequent malloc's. The  : 
124d			;     caller should clear the freed space as required.                        : 
124d			;                                                                             : 
124d			;     This implementation of free uses the stack exclusively, and is          : 
124d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
124d			;     advisable to disable interrupts before calling free, and recommended    : 
124d			;     to avoid the use of free inside ISRs in general.                        : 
124d			;                                                                             : 
124d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
124d			;                                                                             : 
124d			; Parameters                                                                  : 
124d			;     HL  Pointer to address of first byte of allocation to be freed          : 
124d			;                                                                             : 
124d			; Returns                                                                     : 
124d			;     Nothing                                                                 : 
124d			;                                                                             : 
124d			; Stack frame                                                                 : 
124d			;       |             |                                                       : 
124d			;       +-------------+                                                       : 
124d			;       |     BC      |                                                       : 
124d			;       +-------------+                                                       : 
124d			;       |     DE      |                                                       : 
124d			;       +-------------+                                                       : 
124d			;       |     IX      |                                                       : 
124d			;       +-------------+                                                       : 
124d			;       |  prev_free  |                                                       : 
124d			;   +2  +-------------+                                                       : 
124d			;       |  next_free  |                                                       : 
124d			;   +0  +-------------+                                                       : 
124d			;       |             |                                                       : 
124d			;                                                                             : 
124d			;------------------------------------------------------------------------------ 
124d			free: 
124d c5			      push  BC 
124e d5			      push  DE 
124f dd e5		      push  IX 
1251			 
1251 7c			      ld    A, H                    ; Exit if ptr is null 
1252 b5			      or    L 
1253 ca 17 13		      jp    Z, free_early_exit 
1256			 
1256			      ; Set up stack frame 
1256 eb			      ex    DE, HL 
1257 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
125a 39			      add   HL, SP 
125b f9			      ld    SP, HL 
125c dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1260 dd 39		      add   IX, SP 
1262			 
1262			      ; The address in HL points to the start of the useable allocated space, 
1262			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1262			      ; address of the block itself. 
1262 eb			      ex    DE, HL 
1263 11 fc ff		      ld    DE, -4 
1266 19			      add   HL, DE 
1267			 
1267			      ; An allocated block must have a null next block pointer in it 
1267 7e			      ld    A, (HL) 
1268 23			      inc   HL 
1269 b6			      or    (HL) 
126a c2 12 13		      jp    NZ, free_done 
126d			 
126d 2b			      dec   HL 
126e			 
126e 44			      ld    B, H                    ; Copy HL to BC 
126f 4d			      ld    C, L 
1270			 
1270			      ; Loop through the free list to find the first block with an address 
1270			      ; higher than the block being freed 
1270 21 0a 80		      ld    HL, free_list 
1273			 
1273			free_find_higher_block: 
1273 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1274 23			      inc   HL 
1275 56			      ld    D, (HL) 
1276 2b			      dec   HL 
1277			 
1277 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
127a dd 72 01		      ld    (IX+1), D 
127d dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1280 dd 74 03		      ld    (IX+3), H 
1283			 
1283 78			      ld    A, B                    ; Check if DE is greater than BC 
1284 ba			      cp    D                       ; Compare MSB first 
1285 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1287 30 04		      jr    NC, free_find_higher_block_skip 
1289 79			      ld    A, C 
128a bb			      cp    E                       ; Then compare LSB 
128b 38 08		      jr    C, free_found_higher_block 
128d			 
128d			free_find_higher_block_skip: 
128d 7a			      ld    A, D                    ; Reached the end of the free list? 
128e b3			      or    E 
128f ca 12 13		      jp    Z, free_done 
1292			 
1292 eb			      ex    DE, HL 
1293			 
1293 18 de		      jr    free_find_higher_block 
1295			 
1295			free_found_higher_block: 
1295			      ; Insert freed block between prev and next free blocks 
1295 71			      ld    (HL), C                 ; Point prev free block to freed block 
1296 23			      inc   HL 
1297 70			      ld    (HL), B 
1298			 
1298 60			      ld    H, B                    ; Point freed block at next free block 
1299 69			      ld    L, C 
129a 73			      ld    (HL), E 
129b 23			      inc   HL 
129c 72			      ld    (HL), D 
129d			 
129d			      ; Check if the freed block is adjacent to the next free block 
129d 23			      inc   HL                      ; Load size of freed block into HL 
129e 5e			      ld    E, (HL) 
129f 23			      inc   HL 
12a0 56			      ld    D, (HL) 
12a1 eb			      ex    DE, HL 
12a2			 
12a2 09			      add   HL, BC                  ; Add addr of freed block and its size 
12a3			 
12a3 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12a6 dd 56 01		      ld    D, (IX+1) 
12a9			 
12a9 b7			      or    A                       ; Clear the carry flag 
12aa ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12ac 20 22		      jr    NZ, free_check_adjacent_to_prev 
12ae			 
12ae			      ; Freed block is adjacent to next, merge into one bigger block 
12ae eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12af 5e			      ld    E, (HL) 
12b0 23			      inc   HL 
12b1 56			      ld    D, (HL) 
12b2 e5			      push  HL                      ; Save ptr to next block for later 
12b3			 
12b3 60			      ld    H, B                    ; Store ptr from next block into freed block 
12b4 69			      ld    L, C 
12b5 73			      ld    (HL), E 
12b6 23			      inc   HL 
12b7 72			      ld    (HL), D 
12b8			 
12b8 e1			      pop   HL                      ; Restore ptr to next block 
12b9 23			      inc   HL                      ; Load size of next block into DE 
12ba 5e			      ld    E, (HL) 
12bb 23			      inc   HL 
12bc 56			      ld    D, (HL) 
12bd d5			      push  DE                      ; Save next block size for later 
12be			 
12be 60			      ld    H, B                    ; Load size of freed block into HL 
12bf 69			      ld    L, C 
12c0 23			      inc   HL 
12c1 23			      inc   HL 
12c2 5e			      ld    E, (HL) 
12c3 23			      inc   HL 
12c4 56			      ld    D, (HL) 
12c5 eb			      ex    DE, HL 
12c6			 
12c6 d1			      pop   DE                      ; Restore size of next block 
12c7 19			      add   HL, DE                  ; Add sizes of both blocks 
12c8 eb			      ex    DE, HL 
12c9			 
12c9 60			      ld    H, B                    ; Store new bigger size into freed block 
12ca 69			      ld    L, C 
12cb 23			      inc   HL 
12cc 23			      inc   HL 
12cd 73			      ld    (HL), E 
12ce 23			      inc   HL 
12cf 72			      ld    (HL), D 
12d0			 
12d0			free_check_adjacent_to_prev: 
12d0			      ; Check if the freed block is adjacent to the prev free block 
12d0 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
12d3 dd 66 03		      ld    H, (IX+3) 
12d6			 
12d6 23			      inc   HL                      ; Size of prev free block into DE 
12d7 23			      inc   HL 
12d8 5e			      ld    E, (HL) 
12d9 23			      inc   HL 
12da 56			      ld    D, (HL) 
12db 2b			      dec   HL 
12dc 2b			      dec   HL 
12dd 2b			      dec   HL 
12de			 
12de 19			      add   HL, DE                  ; Add prev block addr and size 
12df			 
12df b7			      or    A                       ; Clear the carry flag 
12e0 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
12e2 20 2e		      jr    NZ, free_done 
12e4			 
12e4			      ; Freed block is adjacent to prev, merge into one bigger block 
12e4 60			      ld    H, B                    ; Load next ptr from freed block into DE 
12e5 69			      ld    L, C 
12e6 5e			      ld    E, (HL) 
12e7 23			      inc   HL 
12e8 56			      ld    D, (HL) 
12e9 e5			      push  HL                      ; Save freed block ptr for later 
12ea			 
12ea dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
12ed dd 66 03		      ld    H, (IX+3) 
12f0 73			      ld    (HL), E 
12f1 23			      inc   HL 
12f2 72			      ld    (HL), D 
12f3			 
12f3 e1			      pop   HL                      ; Restore freed block ptr 
12f4 23			      inc   HL                      ; Load size of freed block into DE 
12f5 5e			      ld    E, (HL) 
12f6 23			      inc   HL 
12f7 56			      ld    D, (HL) 
12f8 d5			      push  DE                      ; Save freed block size for later 
12f9			 
12f9 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
12fc dd 66 03		      ld    H, (IX+3) 
12ff 23			      inc   HL 
1300 23			      inc   HL 
1301 5e			      ld    E, (HL) 
1302 23			      inc   HL 
1303 56			      ld    D, (HL) 
1304			 
1304 e1			      pop   HL                      ; Add sizes of both blocks 
1305 19			      add   HL, DE 
1306 eb			      ex    DE, HL 
1307			 
1307 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
130a dd 66 03		      ld    H, (IX+3) 
130d 23			      inc   HL 
130e 23			      inc   HL 
130f 73			      ld    (HL), E 
1310 23			      inc   HL 
1311 72			      ld    (HL), D 
1312			 
1312			free_done: 
1312 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1315 39			      add   HL, SP 
1316 f9			      ld    SP, HL 
1317			 
1317			free_early_exit: 
1317 dd e1		      pop   IX 
1319 d1			      pop   DE 
131a c1			      pop   BC 
131b			 
131b c9			      ret 
131c			 
131c			; moved to firmware.asm 
131c			; 
131c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
131c			;                  .dw   0 
131c			 
131c			 
131c			endif 
131c			 
131c			 
131c			if MALLOC_3 
131c			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
131c			;heap_start        .equ  0x9000      ; Starting address of heap 
131c			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
131c			; 
131c			 ;     .org 0 
131c			  ;    jp    main 
131c			; 
131c			; 
131c			 ;     .org  0x100 
131c			;main: 
131c			 ;     ld    HL, 0x8100 
131c			  ;    ld    SP, HL 
131c			; 
131c			;      call  heap_init 
131c			 
131c			      ; Make some allocations 
131c			;      ld    HL, 12 
131c			;      call  malloc            ; Allocates 0x9004 
131c			; 
131c			 ;     ld    HL, 12 
131c			;      call  malloc            ; Allocates 0x9014 
131c			 
131c			;      ld    HL, 12 
131c			;      call  malloc            ; Allocates 0x9024 
131c			 
131c			      ; Free some allocations 
131c			;      ld    HL, 0x9014 
131c			;      call  free 
131c			 
131c			;      ld    HL, 0x9004 
131c			;      call  free 
131c			; 
131c			;      ld    HL, 0x9024 
131c			;      call  free 
131c			 
131c			 
131c			 ;     halt 
131c			 
131c			 
131c			;------------------------------------------------------------------------------ 
131c			;     heap_init                                                               : 
131c			;                                                                             : 
131c			; Description                                                                 : 
131c			;     Initialise the heap and make it ready for malloc and free operations.   : 
131c			;                                                                             : 
131c			;     The heap is maintained as a linked list, starting with an initial       : 
131c			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
131c			;     the first free block in the heap. Each block then points to the next    : 
131c			;     free block within the heap, and the free list ends at the first block   : 
131c			;     with a null pointer to the next free block.                             : 
131c			;                                                                             : 
131c			; Parameters                                                                  : 
131c			;     Inputs are compile-time only. Two defines which specify the starting    : 
131c			;     address of the heap and its size are required, along with a memory      : 
131c			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
131c			;     principally stores a pointer to the first free block in the heap.       : 
131c			;                                                                             : 
131c			; Returns                                                                     : 
131c			;     Nothing                                                                 : 
131c			;------------------------------------------------------------------------------ 
131c			heap_init: 
131c			      push  HL 
131c			 
131c			      ; Initialise free list struct 
131c			      ld    HL, heap_start 
131c			      ld    (free_list), HL 
131c			      ld    HL, 0 
131c			      ld    (free_list+2), HL 
131c			 
131c			      ; Insert first free block at bottom of heap, consumes entire heap 
131c			      ld    HL, heap_start+heap_size-4 
131c			      ld    (heap_start), HL        ; Next block (end of free list) 
131c			      ld    HL, heap_size-4 
131c			      ld    (heap_start+2), HL      ; Block size 
131c			 
131c			      ; Insert end of free list block at top of heap - two null words will 
131c			      ; terminate the free list 
131c			      ld    HL, 0 
131c			      ld    (heap_start+heap_size-2), HL 
131c			      ld    (heap_start+heap_size-4), HL 
131c			 
131c			      pop   HL 
131c			 
131c			      ret 
131c			 
131c			 
131c			;------------------------------------------------------------------------------ 
131c			;     malloc                                                                  : 
131c			;                                                                             : 
131c			; Description                                                                 : 
131c			;     Allocates the wanted space from the heap and returns the address of the : 
131c			;     first useable byte of the allocation.                                   : 
131c			;                                                                             : 
131c			;     Allocations can happen in one of two ways:                              : 
131c			;                                                                             : 
131c			;     1. A free block may be found which is the exact size wanted. In this    : 
131c			;        case the block is removed from the free list and retuedn to the      : 
131c			;        caller.                                                              : 
131c			;     2. A free block may be found which is larger than the size wanted. In   : 
131c			;        this case, the larger block is split into two. The first portion of  : 
131c			;        this block will become the requested space by the malloc call and    : 
131c			;        is returned to the caller. The second portion becomes a new free     : 
131c			;        block, and the free list is adjusted to maintain continuity via this : 
131c			;        newly created block.                                                 : 
131c			;                                                                             : 
131c			;     malloc does not set any initial value in the allocated space, the       : 
131c			;     caller is required to do this as required.                              : 
131c			;                                                                             : 
131c			;     This implementation of malloc uses the stack exclusively, and is        : 
131c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
131c			;     advisable to disable interrupts before calling malloc, and recommended  : 
131c			;     to avoid the use of malloc inside ISRs in general.                      : 
131c			;                                                                             : 
131c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
131c			;                                                                             : 
131c			; Parameters                                                                  : 
131c			;     HL  Number of bytes wanted                                              : 
131c			;                                                                             : 
131c			; Returns                                                                     : 
131c			;     HL  Address of the first useable byte of the allocation                 : 
131c			;                                                                             : 
131c			; Flags                                                                       : 
131c			;     Z   Set if the allocation did not succeed, clear otherwise              : 
131c			;                                                                             : 
131c			; Stack frame                                                                 : 
131c			;       |             |                                                       : 
131c			;       +-------------+                                                       : 
131c			;       |     BC      |                                                       : 
131c			;       +-------------+                                                       : 
131c			;       |     DE      |                                                       : 
131c			;       +-------------+                                                       : 
131c			;       |     IX      |                                                       : 
131c			;       +-------------+                                                       : 
131c			;       |  prev_free  |                                                       : 
131c			;   +4  +-------------+                                                       : 
131c			;       |  this_free  |                                                       : 
131c			;   +2  +-------------+                                                       : 
131c			;       |  next_free  |                                                       : 
131c			;   +0  +-------------+                                                       : 
131c			;       |             |                                                       : 
131c			;                                                                             : 
131c			;------------------------------------------------------------------------------ 
131c			malloc: 
131c			      push  BC 
131c			      push  DE 
131c			      push  IX 
131c			 
131c			      ld    A, H                    ; Exit if no space requested 
131c			      or    L 
131c			      jp    Z, malloc_early_exit 
131c			 
131c			      ; Set up stack frame 
131c			      ex    DE, HL 
131c			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
131c			      add   HL, SP 
131c			      ld    SP, HL 
131c			      ld    IX, 0                   ; Use IX as a frame pointer 
131c			      add   IX, SP 
131c			 
131c			      ; Setup initial state 
131c			      ld    HL, 4                   ; want must also include space used by block struct 
131c			      add   HL, DE 
131c			 
131c			      ld    B, H                    ; Move want to BC 
131c			      ld    C, L 
131c			 
131c			      ld    HL, free_list           ; Store prev_free ptr to stack 
131c			      ld    (IX+4), L 
131c			      ld    (IX+5), H 
131c			 
131c			      ld    E, (HL)                 ; Store this_free ptr to stack 
131c			      inc   HL 
131c			      ld    D, (HL) 
131c			      ld    (IX+2), E 
131c			      ld    (IX+3), D 
131c			      ex    DE, HL                  ; this_free ptr into HL 
131c			 
131c			      ; Loop through free block list to find some space 
131c			malloc_find_space: 
131c			      ld    E, (HL)                 ; Load next_free ptr into DE 
131c			      inc   HL 
131c			      ld    D, (HL) 
131c			 
131c			      ld    A, D                    ; Check for null next_free ptr - end of free list 
131c			      or    E 
131c			      jp    Z, malloc_no_space 
131c			 
131c			      ld    (IX+0), E               ; Store next_free ptr to stack 
131c			      ld    (IX+1), D 
131c			 
131c			      ; Does this block have enough space to make the allocation? 
131c			      inc   HL                      ; Load free block size into DE 
131c			      ld    E, (HL) 
131c			      inc   HL 
131c			      ld    D, (HL) 
131c			 
131c			      ex    DE, HL                  ; Check size of block against want 
131c			      or    A                       ; Ensure carry flag clear 
131c			      sbc   HL, BC 
131c			      push  HL                      ; Store the result for later (new block size) 
131c			 
131c			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
131c			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
131c			 
131c			      ; this_free block is not big enough, setup ptrs to test next free block 
131c			      pop   HL                      ; Discard previous result 
131c			 
131c			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
131c			      ld    H, (IX+3) 
131c			      ld    (IX+4), L 
131c			      ld    (IX+5), H 
131c			 
131c			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
131c			      ld    H, (IX+1) 
131c			      ld    (IX+2), L 
131c			      ld    (IX+3), H 
131c			 
131c			      jr    malloc_find_space 
131c			 
131c			      ; split a bigger block into two - requested size and remaining size 
131c			malloc_alloc_split: 
131c			      ex    DE, HL                  ; Calculate address of new free block 
131c			      dec   HL 
131c			      dec   HL 
131c			      dec   HL 
131c			      add   HL, BC 
131c			 
131c			      ; Create a new block and point it at next_free 
131c			      ld    E, (IX+0)               ; Load next_free ptr into DE 
131c			      ld    D, (IX+1) 
131c			 
131c			      ld    (HL), E                 ; Store next_free ptr into new block 
131c			      inc   HL 
131c			      ld    (HL), D 
131c			 
131c			      pop   DE                      ; Store size of new block into new block 
131c			      inc   HL 
131c			      ld    (HL), E 
131c			      inc   HL 
131c			      ld    (HL), D 
131c			 
131c			      ; Update this_free ptr to point to new block 
131c			      dec   HL 
131c			      dec   HL 
131c			      dec   HL 
131c			 
131c			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
131c			      ld    D, (IX+3) 
131c			 
131c			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
131c			      ld    (IX+3), H 
131c			 
131c			      ; Modify this_free block to be allocation 
131c			      ex    DE, HL 
131c			      xor   A                       ; Null the next block ptr of allocated block 
131c			      ld    (HL), A 
131c			      inc   HL 
131c			      ld    (HL), A 
131c			 
131c			      inc   HL                      ; Store want size into allocated block 
131c			      ld    (HL), C 
131c			      inc   HL 
131c			      ld    (HL), B 
131c			      inc   HL 
131c			      push  HL                      ; Address of allocation to return 
131c			 
131c			      jr    malloc_update_links 
131c			 
131c			malloc_alloc_fit: 
131c			      pop   HL                      ; Dont need new block size, want is exact fit 
131c			 
131c			      ; Modify this_free block to be allocation 
131c			      ex    DE, HL 
131c			      dec   HL 
131c			      dec   HL 
131c			      dec   HL 
131c			 
131c			      xor   A                       ; Null the next block ptr of allocated block 
131c			      ld    (HL), A 
131c			      inc   HL 
131c			      ld    (HL), A 
131c			 
131c			      inc   HL                      ; Store address of allocation to return 
131c			      inc   HL 
131c			      inc   HL 
131c			      push  HL 
131c			 
131c			      ; Copy next_free ptr to this_free, remove allocated block from free list 
131c			      ld    L, (IX+0)               ; next_free to HL 
131c			      ld    H, (IX+1) 
131c			 
131c			      ld    (IX+2), L               ; HL to this_free 
131c			      ld    (IX+3), H 
131c			 
131c			 
131c			malloc_update_links: 
131c			      ; Update prev_free ptr to point to this_free 
131c			      ld    L, (IX+4)               ; prev_free ptr to HL 
131c			      ld    H, (IX+5) 
131c			 
131c			      ld    E, (IX+2)               ; this_free ptr to DE 
131c			      ld    D, (IX+3) 
131c			 
131c			      ld    (HL), E                 ; this_free ptr into prev_free 
131c			      inc   HL 
131c			      ld    (HL), D 
131c			 
131c			      ; Clear the Z flag to indicate successful allocation 
131c			      ld    A, D 
131c			      or    E 
131c			 
131c			      pop   DE                      ; Address of allocation 
131c			 
131c			malloc_no_space: 
131c			      ld    HL, 6                   ; Clean up stack frame 
131c			      add   HL, SP 
131c			      ld    SP, HL 
131c			 
131c			      ex    DE, HL                  ; Alloc addr into HL for return 
131c			 
131c			malloc_early_exit: 
131c			      pop   IX 
131c			      pop   DE 
131c			      pop   BC 
131c			 
131c			      ret 
131c			 
131c			 
131c			;------------------------------------------------------------------------------ 
131c			;     free                                                                    : 
131c			;                                                                             : 
131c			; Description                                                                 : 
131c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
131c			;     returned by malloc, otherwise the behaviour is undefined.               : 
131c			;                                                                             : 
131c			;     Where possible, directly adjacent free blocks will be merged together   : 
131c			;     into larger blocks to help ensure that the heap does not become         : 
131c			;     excessively fragmented.                                                 : 
131c			;                                                                             : 
131c			;     free does not clear or set any other value into the freed space, and    : 
131c			;     therefore its contents may be visible through subsequent malloc's. The  : 
131c			;     caller should clear the freed space as required.                        : 
131c			;                                                                             : 
131c			;     This implementation of free uses the stack exclusively, and is          : 
131c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
131c			;     advisable to disable interrupts before calling free, and recommended    : 
131c			;     to avoid the use of free inside ISRs in general.                        : 
131c			;                                                                             : 
131c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
131c			;                                                                             : 
131c			; Parameters                                                                  : 
131c			;     HL  Pointer to address of first byte of allocation to be freed          : 
131c			;                                                                             : 
131c			; Returns                                                                     : 
131c			;     Nothing                                                                 : 
131c			;                                                                             : 
131c			; Stack frame                                                                 : 
131c			;       |             |                                                       : 
131c			;       +-------------+                                                       : 
131c			;       |     BC      |                                                       : 
131c			;       +-------------+                                                       : 
131c			;       |     DE      |                                                       : 
131c			;       +-------------+                                                       : 
131c			;       |     IX      |                                                       : 
131c			;       +-------------+                                                       : 
131c			;       |  prev_free  |                                                       : 
131c			;   +2  +-------------+                                                       : 
131c			;       |  next_free  |                                                       : 
131c			;   +0  +-------------+                                                       : 
131c			;       |             |                                                       : 
131c			;                                                                             : 
131c			;------------------------------------------------------------------------------ 
131c			free: 
131c			      push  BC 
131c			      push  DE 
131c			      push  IX 
131c			 
131c			      ld    A, H                    ; Exit if ptr is null 
131c			      or    L 
131c			      jp    Z, free_early_exit 
131c			 
131c			      ; Set up stack frame 
131c			      ex    DE, HL 
131c			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
131c			      add   HL, SP 
131c			      ld    SP, HL 
131c			      ld    IX, 0                   ; Use IX as a frame pointer 
131c			      add   IX, SP 
131c			 
131c			      ; The address in HL points to the start of the useable allocated space, 
131c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
131c			      ; address of the block itself. 
131c			      ex    DE, HL 
131c			      ld    DE, -4 
131c			      add   HL, DE 
131c			 
131c			      ; An allocated block must have a null next block pointer in it 
131c			      ld    A, (HL) 
131c			      inc   HL 
131c			      or    (HL) 
131c			      jp    NZ, free_done 
131c			 
131c			      dec   HL 
131c			 
131c			      ld    B, H                    ; Copy HL to BC 
131c			      ld    C, L 
131c			 
131c			      ; Loop through the free list to find the first block with an address 
131c			      ; higher than the block being freed 
131c			      ld    HL, free_list 
131c			 
131c			free_find_higher_block: 
131c			      ld    E, (HL)                 ; Load next ptr from free block 
131c			      inc   HL 
131c			      ld    D, (HL) 
131c			      dec   HL 
131c			 
131c			      ld    (IX+0), E               ; Save ptr to next free block 
131c			      ld    (IX+1), D 
131c			      ld    (IX+2), L               ; Save ptr to prev free block 
131c			      ld    (IX+3), H 
131c			 
131c			      ld    A, B                    ; Check if DE is greater than BC 
131c			      cp    D                       ; Compare MSB first 
131c			      jr    Z, $+4                  ; MSB the same, compare LSB 
131c			      jr    NC, free_find_higher_block_skip 
131c			      ld    A, C 
131c			      cp    E                       ; Then compare LSB 
131c			      jr    C, free_found_higher_block 
131c			 
131c			free_find_higher_block_skip: 
131c			      ld    A, D                    ; Reached the end of the free list? 
131c			      or    E 
131c			      jp    Z, free_done 
131c			 
131c			      ex    DE, HL 
131c			 
131c			      jr    free_find_higher_block 
131c			 
131c			free_found_higher_block: 
131c			      ; Insert freed block between prev and next free blocks 
131c			      ld    (HL), C                 ; Point prev free block to freed block 
131c			      inc   HL 
131c			      ld    (HL), B 
131c			 
131c			      ld    H, B                    ; Point freed block at next free block 
131c			      ld    L, C 
131c			      ld    (HL), E 
131c			      inc   HL 
131c			      ld    (HL), D 
131c			 
131c			      ; Check if the freed block is adjacent to the next free block 
131c			      inc   HL                      ; Load size of freed block into HL 
131c			      ld    E, (HL) 
131c			      inc   HL 
131c			      ld    D, (HL) 
131c			      ex    DE, HL 
131c			 
131c			      add   HL, BC                  ; Add addr of freed block and its size 
131c			 
131c			      ld    E, (IX+0)               ; Load addr of next free block into DE 
131c			      ld    D, (IX+1) 
131c			 
131c			      or    A                       ; Clear the carry flag 
131c			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
131c			      jr    NZ, free_check_adjacent_to_prev 
131c			 
131c			      ; Freed block is adjacent to next, merge into one bigger block 
131c			      ex    DE, HL                  ; Load next ptr from next block into DE 
131c			      ld    E, (HL) 
131c			      inc   HL 
131c			      ld    D, (HL) 
131c			      push  HL                      ; Save ptr to next block for later 
131c			 
131c			      ld    H, B                    ; Store ptr from next block into freed block 
131c			      ld    L, C 
131c			      ld    (HL), E 
131c			      inc   HL 
131c			      ld    (HL), D 
131c			 
131c			      pop   HL                      ; Restore ptr to next block 
131c			      inc   HL                      ; Load size of next block into DE 
131c			      ld    E, (HL) 
131c			      inc   HL 
131c			      ld    D, (HL) 
131c			      push  DE                      ; Save next block size for later 
131c			 
131c			      ld    H, B                    ; Load size of freed block into HL 
131c			      ld    L, C 
131c			      inc   HL 
131c			      inc   HL 
131c			      ld    E, (HL) 
131c			      inc   HL 
131c			      ld    D, (HL) 
131c			      ex    DE, HL 
131c			 
131c			      pop   DE                      ; Restore size of next block 
131c			      add   HL, DE                  ; Add sizes of both blocks 
131c			      ex    DE, HL 
131c			 
131c			      ld    H, B                    ; Store new bigger size into freed block 
131c			      ld    L, C 
131c			      inc   HL 
131c			      inc   HL 
131c			      ld    (HL), E 
131c			      inc   HL 
131c			      ld    (HL), D 
131c			 
131c			free_check_adjacent_to_prev: 
131c			      ; Check if the freed block is adjacent to the prev free block 
131c			      ld    L, (IX+2)               ; Prev free block ptr into HL 
131c			      ld    H, (IX+3) 
131c			 
131c			      inc   HL                      ; Size of prev free block into DE 
131c			      inc   HL 
131c			      ld    E, (HL) 
131c			      inc   HL 
131c			      ld    D, (HL) 
131c			      dec   HL 
131c			      dec   HL 
131c			      dec   HL 
131c			 
131c			      add   HL, DE                  ; Add prev block addr and size 
131c			 
131c			      or    A                       ; Clear the carry flag 
131c			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
131c			      jr    NZ, free_done 
131c			 
131c			      ; Freed block is adjacent to prev, merge into one bigger block 
131c			      ld    H, B                    ; Load next ptr from freed block into DE 
131c			      ld    L, C 
131c			      ld    E, (HL) 
131c			      inc   HL 
131c			      ld    D, (HL) 
131c			      push  HL                      ; Save freed block ptr for later 
131c			 
131c			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
131c			      ld    H, (IX+3) 
131c			      ld    (HL), E 
131c			      inc   HL 
131c			      ld    (HL), D 
131c			 
131c			      pop   HL                      ; Restore freed block ptr 
131c			      inc   HL                      ; Load size of freed block into DE 
131c			      ld    E, (HL) 
131c			      inc   HL 
131c			      ld    D, (HL) 
131c			      push  DE                      ; Save freed block size for later 
131c			 
131c			      ld    L, (IX+2)               ; Load size of prev block into DE 
131c			      ld    H, (IX+3) 
131c			      inc   HL 
131c			      inc   HL 
131c			      ld    E, (HL) 
131c			      inc   HL 
131c			      ld    D, (HL) 
131c			 
131c			      pop   HL                      ; Add sizes of both blocks 
131c			      add   HL, DE 
131c			      ex    DE, HL 
131c			 
131c			      ld    L, (IX+2)               ; Store new bigger size into prev block 
131c			      ld    H, (IX+3) 
131c			      inc   HL 
131c			      inc   HL 
131c			      ld    (HL), E 
131c			      inc   HL 
131c			      ld    (HL), D 
131c			 
131c			free_done: 
131c			      ld    HL, 4                   ; Clean up stack frame 
131c			      add   HL, SP 
131c			      ld    SP, HL 
131c			 
131c			free_early_exit: 
131c			      pop   IX 
131c			      pop   DE 
131c			      pop   BC 
131c			 
131c			      ret 
131c			 
131c			 
131c			;      .org 0x8000 
131c			; 
131c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
131c			 ;                 .dw   0 
131c			 
131c			endif 
131c			 
131c			 
131c			if MALLOC_4 
131c			 
131c			; My memory allocation code. Very very simple.... 
131c			; allocate space under 250 chars 
131c			 
131c			heap_init: 
131c				; init start of heap as zero 
131c				;  
131c			 
131c				ld hl, heap_start 
131c				ld a, 0 
131c				ld (hl), a      ; empty block 
131c				inc hl 
131c				ld a, 0 
131c				ld (hl), a      ; length of block 
131c				; write end of list 
131c				inc hl 
131c				ld a,(hl) 
131c				inc hl 
131c				ld a,(hl) 
131c				 
131c			 
131c				; init some malloc vars 
131c			 
131c				ld hl, 0 
131c				ld (free_list), hl       ; store last malloc location 
131c			 
131c				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
131c				ld a, 0 
131c				ld (hl), a 
131c			 
131c			 
131c				ld hl, heap_start 
131c				;  
131c				  
131c				ret 
131c			 
131c			 
131c			;    free block marker 
131c			;    requested size  
131c			;    pointer to next block 
131c			;    .... 
131c			;    next block marker 
131c			 
131c			 
131c			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
131c			; 
131c			 
131c			 
131c			malloc:  
131c				push de 
131c				push bc 
131c				push af 
131c			 
131c				; hl space required 
131c				 
131c				ld c, l    ; hold space   (TODO only a max of 255) 
131c			 
131c			;	inc c     ; TODO BUG need to fix memory leak on push str 
131c			;	inc c 
131c			;	inc c 
131c			;	inc c 
131c			;	inc c 
131c			;	inc c 
131c			;	inc c 
131c			 
131c			 
131c			 
131c				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
131c			 
131c				ld a, (free_list+3) 
131c				cp 0 
131c				jr z, .contheap 
131c			 
131c				ld hl, (free_list)     ; get last alloc 
131c					if DEBUG_FORTH_MALLOC_INT 
131c						DMARK "mrs" 
131c						CALLMONITOR 
131c					endif 
131c				jr .startalloc 
131c			 
131c			.contheap: 
131c				ld hl, heap_start 
131c			 
131c			.startalloc: 
131c			 
131c					if DEBUG_FORTH_MALLOC_INT 
131c						DMARK "mym" 
131c						CALLMONITOR 
131c					endif 
131c			.findblock: 
131c					if DEBUG_FORTH_MALLOC_INT 
131c						DMARK "mmf" 
131c						CALLMONITOR 
131c					endif 
131c			 
131c				ld a,(hl)  
131c				; if byte is zero then clear to use 
131c			 
131c				cp 0 
131c				jr z, .foundemptyblock 
131c			 
131c				; if byte is not clear 
131c				;     then byte is offset to next block 
131c			 
131c				inc hl 
131c				ld a, (hl) ; get size 
131c			.nextblock:	inc hl 
131c					ld e, (hl) 
131c					inc hl 
131c					ld d, (hl) 
131c					ex de, hl 
131c			;	inc hl  ; move past the store space 
131c			;	inc hl  ; move past zero index  
131c			 
131c				; TODO detect no more space 
131c			 
131c				push hl 
131c				ld de, heap_end 
131c				call cmp16 
131c				pop hl 
131c				jr nc, .nospace 
131c			 
131c				jr .findblock 
131c			 
131c			.nospace: ld hl, 0 
131c				jp .exit 
131c			 
131c			 
131c			.foundemptyblock:	 
131c					if DEBUG_FORTH_MALLOC_INT 
131c						DMARK "mme" 
131c						CALLMONITOR 
131c					endif 
131c			 
131c			; TODO has block enough space if reusing??? 
131c			 
131c				;  
131c			 
131c			; see if this block has been previously used 
131c				inc hl 
131c				ld a, (hl) 
131c				dec hl 
131c				cp 0 
131c				jr z, .newblock 
131c			 
131c					if DEBUG_FORTH_MALLOC_INT 
131c						DMARK "meR" 
131c						CALLMONITOR 
131c					endif 
131c			 
131c			; no reusing previously allocated block 
131c			 
131c			; is it smaller than previously used? 
131c				 
131c				inc hl    ; move to size 
131c				ld a, c 
131c				sub (hl)        ; we want c < (hl) 
131c				dec hl    ; move back to marker 
131c			        jr z, .findblock 
131c			 
131c				; update with the new size which should be lower 
131c			 
131c			        ;inc  hl   ; negate next move. move back to size  
131c			 
131c			.newblock: 
131c				; need to be at marker here 
131c			 
131c					if DEBUG_FORTH_MALLOC_INT 
131c						DMARK "meN" 
131c						CALLMONITOR 
131c					endif 
131c			 
131c			 
131c				ld a, c 
131c			 
131c				ld (free_list+3), a	 ; flag resume from last malloc  
131c				ld (free_list), hl    ; save out last location 
131c			 
131c			 
131c				;inc a     ; space for length byte 
131c				ld (hl), a     ; save block in use marker 
131c			 
131c				inc hl   ; move to space marker 
131c				ld (hl), a    ; save new space 
131c			 
131c				inc hl   ; move to start of allocated area 
131c				 
131c			;	push hl     ; save where we are - 1  
131c			 
131c			;	inc hl  ; move past zero index  
131c				; skip space to set down new marker 
131c			 
131c				; provide some extra space for now 
131c			 
131c				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
131c				inc a 
131c				inc a 
131c			 
131c				push hl   ; save where we are in the node block 
131c			 
131c				call addatohl 
131c			 
131c				; write linked list point 
131c			 
131c				pop de     ; get our node position 
131c				ex de, hl 
131c			 
131c				ld (hl), e 
131c				inc hl 
131c				ld (hl), d 
131c			 
131c				inc hl 
131c			 
131c				; now at start of allocated data so save pointer 
131c			 
131c				push hl 
131c			 
131c				; jump to position of next node and setup empty header in DE 
131c			 
131c				ex de, hl 
131c			 
131c			;	inc hl ; move past end of block 
131c			 
131c				ld a, 0 
131c				ld (hl), a   ; empty marker 
131c				inc hl 
131c				ld (hl), a   ; size 
131c				inc hl  
131c				ld (hl), a   ; ptr 
131c				inc hl 
131c				ld (hl), a   ; ptr 
131c			 
131c			 
131c				pop hl 
131c			 
131c					if DEBUG_FORTH_MALLOC_INT 
131c						DMARK "mmr" 
131c						CALLMONITOR 
131c					endif 
131c			 
131c			.exit: 
131c				pop af 
131c				pop bc 
131c				pop de  
131c				ret 
131c			 
131c			 
131c			 
131c			 
131c			free:  
131c				push hl 
131c				push af 
131c				; get address in hl 
131c			 
131c					if DEBUG_FORTH_MALLOC_INT 
131c						DMARK "fre" 
131c						CALLMONITOR 
131c					endif 
131c				; data is at hl - move to block count 
131c				dec hl 
131c				dec hl    ; get past pointer 
131c				dec hl 
131c			 
131c				ld a, (hl)    ; need this for a validation check 
131c			 
131c				dec hl    ; move to block marker 
131c			 
131c				; now check that the block count and block marker are the same  
131c			        ; this checks that we are on a malloc node and not random memory 
131c			        ; OK a faint chance this could be a problem but rare - famous last words! 
131c			 
131c				ld c, a 
131c				ld a, (hl)    
131c			 
131c				cp c 
131c				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
131c			 
131c				; yes good chance we are on a malloc node 
131c			 
131c				ld a, 0      
131c				ld (hl), a   ; mark as free 
131c			 
131c				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
131c			 
131c			.freeignore:  
131c			 
131c				pop af 
131c				pop hl 
131c			 
131c				ret 
131c			 
131c			 
131c			 
131c			endif 
131c			 
131c			; eof 
# End of file firmware_memory.asm
131c			  
131c			; device C  
131c			if SOUND_ENABLE  
131c				include "firmware_sound.asm"  
131c			endif  
131c			  
131c			include "firmware_diags.asm"  
131c			; Hardware diags menu 
131c			 
131c			 
131c			config: 
131c			 
131c 3e 00			ld a, 0 
131e 21 2e 13			ld hl, .configmn 
1321 cd bd 0a			call menu 
1324			 
1324 fe 00			cp 0 
1326 c8				ret z 
1327			 
1327 fe 04			cp 4 
1329 cc a6 13			call z, hardware_diags 
132c			 
132c 18 ee			jr config 
132e			 
132e			.configmn: 
132e 38 13			dw .c3 
1330 53 13			dw .c2 
1332 68 13			dw .c4 
1334 71 13			dw .c1 
1336 00 00			dw 0 
1338				 
1338			 
1338 .. 00		.c3: db "Save User Words To Storage",0 
1353 .. 00		.c2: db "Select Autoload File",0 
1368 .. 00		.c4: db "Settings",0 
1371 .. 00		.c1: db "Hardware Diags",0 
1380			 
1380			 
1380			; Settings 
1380			; Run  
1380			 
1380			 
1380			 
1380			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1380			;;hd_menu2:   db "        2: Editor",0   
1380			;hd_menu2:   db "        2: Editor       6: Menu",0   
1380			;hd_menu3:   db "        3: Storage",0 
1380			;hd_menu4:   db "0=quit  4: Debug",0 
1380			;hd_don:     db "ON",0 
1380			;hd_doff:     db "OFF",0 
1380			; 
1380			; 
1380			; 
1380			;hardware_diags_old:       
1380			; 
1380			;.diagmenu: 
1380			;	call clear_display 
1380			;	ld a, display_row_1 
1380			;	ld de, hd_menu1 
1380			;	call str_at_display 
1380			; 
1380			;	ld a, display_row_2 
1380			;	ld de, hd_menu2 
1380			;	call str_at_display 
1380			; 
1380			;	ld a, display_row_3 
1380			;	ld de, hd_menu3 
1380			;	call str_at_display 
1380			; 
1380			;	ld a,  display_row_4 
1380			;	ld de, hd_menu4 
1380			;	call str_at_display 
1380			; 
1380			;	; display debug state 
1380			; 
1380			;	ld de, hd_don 
1380			;	ld a, (os_view_disable) 
1380			;	cp 0 
1380			;	jr z, .distog 
1380			;	ld de, hd_doff 
1380			;.distog: ld a, display_row_4+17 
1380			;	call str_at_display 
1380			; 
1380			;	call update_display 
1380			; 
1380			;	call cin_wait 
1380			; 
1380			; 
1380			; 
1380			;	cp '4' 
1380			;	jr nz, .diagn1 
1380			; 
1380			;	; debug toggle 
1380			; 
1380			;	ld a, (os_view_disable) 
1380			;	ld b, '*' 
1380			;	cp 0 
1380			;	jr z, .debtog 
1380			;	ld b, 0 
1380			;.debtog:	 
1380			;	ld a,b 
1380			;	ld (os_view_disable),a 
1380			; 
1380			;.diagn1: cp '0' 
1380			;	 ret z 
1380			; 
1380			;;	cp '1' 
1380			;;       jp z, matrix	 
1380			;;   TODO keyboard matrix test 
1380			; 
1380			;	cp '2' 
1380			;	jp z, .diagedit 
1380			; 
1380			;;	cp '6' 
1380			;;	jp z, .menutest 
1380			;;if ENABLE_BASIC 
1380			;;	cp '6' 
1380			;;	jp z, basic 
1380			;;endif 
1380			 ; 
1380			;	jp .diagmenu 
1380			; 
1380			; 
1380			;	ret 
1380			 
1380			 
1380			.debug_tog: 
1380 21 ce 13			ld hl, .menudebug 
1383				 
1383 3a b7 ef			ld a, (os_view_disable) 
1386 fe 2a			cp '*' 
1388 20 04			jr nz,.tdon  
138a 3e 01			ld a, 1 
138c 18 02			jr .tog1 
138e 3e 00		.tdon: ld a, 0 
1390			 
1390			.tog1: 
1390 cd bd 0a			call menu 
1393 fe 00			cp 0 
1395 c8				ret z 
1396 fe 01			cp 1    ; disable debug 
1398 28 04			jr z, .dtog0 
139a 3e 2a			ld a, '*' 
139c 18 02			jr .dtogset 
139e 3e 00		.dtog0: ld a, 0 
13a0 32 b7 ef		.dtogset:  ld (os_view_disable), a 
13a3 c3 80 13			jp .debug_tog 
13a6			 
13a6			 
13a6			hardware_diags:       
13a6			 
13a6			.diagm: 
13a6 21 be 13			ld hl, .menuitems 
13a9 3e 00			ld a, 0 
13ab cd bd 0a			call menu 
13ae			 
13ae fe 00		         cp 0 
13b0 c8				 ret z 
13b1			 
13b1 fe 02			cp 2 
13b3 ca 28 14			jp z, .diagedit 
13b6 fe 04			cp 4 
13b8 cc 80 13			call z, .debug_tog 
13bb			 
13bb			;	cp '6' 
13bb			;	jp z, .menutest 
13bb			;if ENABLE_BASIC 
13bb			;	cp '6' 
13bb			;	jp z, basic 
13bb			;endif 
13bb			  
13bb c3 a6 13			jp .diagm 
13be			 
13be				 
13be d4 13		.menuitems:   	dw .m1 
13c0 df 13				dw .m2 
13c2 e6 13				dw .m3 
13c4 ee 13				dw .m4 
13c6 fd 13				dw .m5 
13c8 03 14				dw .m5a 
13ca 0c 14				dw .m5b 
13cc 00 00				dw 0 
13ce			 
13ce			.menudebug: 
13ce 15 14				dw .m6 
13d0 1e 14				dw .m7 
13d2 00 00				dw 0 
13d4			 
13d4 .. 00		.m1:   db "Key Matrix",0 
13df .. 00		.m2:   db "Editor",0 
13e6 .. 00		.m3:   db "Storage",0 
13ee .. 00		.m4:   db "Software Debug",0 
13fd .. 00		.m5:   db "Sound",0 
1403 .. 00		.m5a:  db "RAM Test",0 
140c .. 00		.m5b:  db "LCD Test",0 
1415			 
1415 .. 00		.m6:   db "Debug ON",0 
141e .. 00		.m7:   db "Debug OFF",0 
1428			 
1428			; debug editor 
1428			 
1428			.diagedit: 
1428			 
1428 21 b8 ef			ld hl, scratch 
142b			;	ld bc, 250 
142b			;	ldir 
142b				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
142b 3e 00			ld a, 0 
142d 77				ld (hl), a 
142e 23				inc hl 
142f 77				ld (hl), a 
1430 23				inc hl 
1431 77				ld (hl), a 
1432			 
1432 cd 8c 0a		        call clear_display 
1435 cd af 0a			call update_display 
1438 3e 01			ld a, 1 
143a 32 c3 fb			ld (hardware_diag), a 
143d			.diloop: 
143d 3e 00			ld a, display_row_1 
143f 0e 00			ld c, 0 
1441 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1443 1e 28			ld e, 40 
1445			 
1445 21 b8 ef			ld hl, scratch	 
1448 cd e9 0c			call input_str 
144b			 
144b 3e 14			ld a, display_row_2 
144d 11 b8 ef			ld de, scratch 
1450 cd 9f 0a			call str_at_display 
1453 cd af 0a			call update_display 
1456			 
1456 c3 3d 14			jp .diloop 
1459			 
1459			 
1459			; pass word in hl 
1459			; a has display location 
1459			display_word_at: 
1459 f5				push af 
145a e5				push hl 
145b 7c				ld a,h 
145c 21 bd f2			ld hl, os_word_scratch 
145f cd bd 0f			call hexout 
1462 e1				pop hl 
1463 7d				ld a,l 
1464 21 bf f2			ld hl, os_word_scratch+2 
1467 cd bd 0f			call hexout 
146a 21 c1 f2			ld hl, os_word_scratch+4 
146d 3e 00			ld a,0 
146f 77				ld (hl),a 
1470 11 bd f2			ld de,os_word_scratch 
1473 f1				pop af 
1474 cd 9f 0a				call str_at_display 
1477 c9				ret 
1478			 
1478			display_ptr_state: 
1478			 
1478				; to restore afterwards 
1478			 
1478 d5				push de 
1479 c5				push bc 
147a e5				push hl 
147b f5				push af 
147c			 
147c				; for use in here 
147c			 
147c			;	push bc 
147c			;	push de 
147c			;	push hl 
147c			;	push af 
147c			 
147c cd 8c 0a			call clear_display 
147f			 
147f 11 52 16			ld de, .ptrstate 
1482 3e 00			ld a, display_row_1 
1484 cd 9f 0a			call str_at_display 
1487			 
1487				; display debug step 
1487			 
1487			 
1487 11 bd fb			ld de, debug_mark 
148a 3e 12			ld a, display_row_1+display_cols-2 
148c cd 9f 0a			call str_at_display 
148f			 
148f				; display a 
148f 11 5c 16			ld de, .ptrcliptr 
1492 3e 14			ld a, display_row_2 
1494 cd 9f 0a			call str_at_display 
1497			 
1497 f1				pop af 
1498 2a c3 f9			ld hl,(cli_ptr) 
149b 3e 1c			ld a, display_row_2+8 
149d cd 59 14			call display_word_at 
14a0			 
14a0			 
14a0				; display hl 
14a0			 
14a0			 
14a0 11 64 16			ld de, .ptrclioptr 
14a3 3e 1e			ld a, display_row_2+10 
14a5 cd 9f 0a			call str_at_display 
14a8			; 
14a8			;	pop hl 
14a8 3e 21			ld a, display_row_2+13 
14aa 2a c1 f9			ld hl,(cli_origptr) 
14ad cd 59 14			call display_word_at 
14b0			; 
14b0			;	 
14b0			;	; display de 
14b0			 
14b0			;	ld de, .regstatede 
14b0			;	ld a, display_row_3 
14b0			;	call str_at_display 
14b0			 
14b0			;	pop de 
14b0			;	ld h,d 
14b0			;	ld l, e 
14b0			;	ld a, display_row_3+3 
14b0			;	call display_word_at 
14b0			 
14b0			 
14b0				; display bc 
14b0			 
14b0			;	ld de, .regstatebc 
14b0			;	ld a, display_row_3+10 
14b0			;	call str_at_display 
14b0			 
14b0			;	pop bc 
14b0			;	ld h,b 
14b0			;	ld l, c 
14b0			;	ld a, display_row_3+13 
14b0			;	call display_word_at 
14b0			 
14b0			 
14b0				; display dsp 
14b0			 
14b0			;	ld de, .regstatedsp 
14b0			;	ld a, display_row_4 
14b0			;	call str_at_display 
14b0			 
14b0				 
14b0			;	ld hl,(cli_data_sp) 
14b0			;	ld a, display_row_4+4 
14b0			;	call display_word_at 
14b0			 
14b0				; display rsp 
14b0			 
14b0 11 93 16			ld de, .regstatersp 
14b3 3e 46			ld a, display_row_4+10 
14b5 cd 9f 0a			call str_at_display 
14b8			 
14b8				 
14b8 2a a9 f9			ld hl,(cli_ret_sp) 
14bb 3e 4a			ld a, display_row_4+14 
14bd cd 59 14			call display_word_at 
14c0			 
14c0 cd af 0a			call update_display 
14c3			 
14c3 cd 3a 0a			call delay1s 
14c6 cd 3a 0a			call delay1s 
14c9 cd 3a 0a			call delay1s 
14cc			 
14cc			 
14cc cd e6 19			call next_page_prompt 
14cf			 
14cf				; restore  
14cf			 
14cf f1				pop af 
14d0 e1				pop hl 
14d1 c1				pop bc 
14d2 d1				pop de 
14d3 c9				ret 
14d4			 
14d4			break_point_state: 
14d4 f5				push af 
14d5			 
14d5				; see if disabled 
14d5			 
14d5 3a b7 ef			ld a, (os_view_disable) 
14d8 fe 2a			cp '*' 
14da 20 02			jr nz, .bpsgo 
14dc f1				pop af 
14dd c9				ret 
14de			 
14de			.bpsgo: 
14de f1				pop af 
14df f5				push af 
14e0 22 b3 ef			ld (os_view_hl), hl 
14e3 ed 53 b1 ef		ld (os_view_de), de 
14e7 ed 43 af ef		ld (os_view_bc), bc 
14eb e5				push hl 
14ec 6f				ld l, a 
14ed 26 00			ld h, 0 
14ef 22 b5 ef			ld (os_view_af),hl 
14f2			 
14f2 21 53 fb				ld hl, display_fb0 
14f5 22 5e fa				ld (display_fb_active), hl 
14f8 e1				pop hl	 
14f9			 
14f9 3e 31			ld a, '1' 
14fb fe 2a		.bps1:  cp '*' 
14fd 20 03			jr nz, .bps1b 
14ff 32 b7 ef			ld (os_view_disable),a 
1502 fe 31		.bps1b:  cp '1' 
1504 20 14			jr nz, .bps2 
1506			 
1506				; display reg 
1506			 
1506				 
1506			 
1506 3a b5 ef			ld a, (os_view_af) 
1509 2a b3 ef			ld hl, (os_view_hl) 
150c ed 5b b1 ef		ld de, (os_view_de) 
1510 ed 4b af ef		ld bc, (os_view_bc) 
1514 cd ae 15			call display_reg_state 
1517 c3 9a 15			jp .bpschk 
151a			 
151a fe 32		.bps2:  cp '2' 
151c 20 08			jr nz, .bps3 
151e				 
151e				; display hl 
151e 2a b3 ef			ld hl, (os_view_hl) 
1521 cd 98 16			call display_dump_at_hl 
1524			 
1524 18 74			jr .bpschk 
1526			 
1526 fe 33		.bps3:  cp '3' 
1528 20 08			jr nz, .bps4 
152a			 
152a			        ; display de 
152a 2a b1 ef			ld hl, (os_view_de) 
152d cd 98 16			call display_dump_at_hl 
1530			 
1530 18 68			jr .bpschk 
1532 fe 34		.bps4:  cp '4' 
1534 20 08			jr nz, .bps5 
1536			 
1536			        ; display bc 
1536 2a af ef			ld hl, (os_view_bc) 
1539 cd 98 16			call display_dump_at_hl 
153c			 
153c 18 5c			jr .bpschk 
153e fe 35		.bps5:  cp '5' 
1540 20 08		        jr nz, .bps7 
1542			 
1542				; display cur ptr 
1542 2a c3 f9			ld hl, (cli_ptr) 
1545 cd 98 16			call display_dump_at_hl 
1548			 
1548 18 50			jr .bpschk 
154a fe 36		.bps7:  cp '6' 
154c 20 08			jr nz, .bps8b 
154e				 
154e				; display cur orig ptr 
154e 2a c1 f9			ld hl, (cli_origptr) 
1551 cd 98 16			call display_dump_at_hl 
1554 18 44			jr .bpschk 
1556 fe 37		.bps8b:  cp '7' 
1558 20 08			jr nz, .bps9 
155a				 
155a				; display dsp 
155a 2a a5 f9			ld hl, (cli_data_sp) 
155d cd 98 16			call display_dump_at_hl 
1560			 
1560 18 38			jr .bpschk 
1562 fe 39		.bps9:  cp '9' 
1564 20 05			jr nz, .bps8c 
1566				 
1566				; display SP 
1566			;	ld hl, sp 
1566 cd 98 16			call display_dump_at_hl 
1569			 
1569 18 2f			jr .bpschk 
156b fe 38		.bps8c:  cp '8' 
156d 20 08			jr nz, .bps8d 
156f				 
156f				; display rsp 
156f 2a a9 f9			ld hl, (cli_ret_sp) 
1572 cd 98 16			call display_dump_at_hl 
1575			 
1575 18 23			jr .bpschk 
1577 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1579 20 05			jr nz, .bps8 
157b cd dc 17			call monitor 
157e			 
157e 18 1a			jr .bpschk 
1580 fe 30		.bps8:  cp '0' 
1582 20 16			jr nz, .bpschk 
1584			 
1584 21 02 fb				ld hl, display_fb1 
1587 22 5e fa				ld (display_fb_active), hl 
158a cd af 0a				call update_display 
158d			 
158d				;ld a, (os_view_af) 
158d 2a b3 ef			ld hl, (os_view_hl) 
1590 ed 5b b1 ef		ld de, (os_view_de) 
1594 ed 4b af ef		ld bc, (os_view_bc) 
1598 f1				pop af 
1599 c9				ret 
159a			 
159a			.bpschk:   
159a cd 3a 0a			call delay1s 
159d 3e 4f		ld a,display_row_4 + display_cols - 1 
159f 11 e4 19		        ld de, endprg 
15a2 cd 9f 0a			call str_at_display 
15a5 cd af 0a			call update_display 
15a8 cd 38 63			call cin_wait 
15ab			 
15ab c3 fb 14			jp .bps1 
15ae			 
15ae			 
15ae			display_reg_state: 
15ae			 
15ae				; to restore afterwards 
15ae			 
15ae d5				push de 
15af c5				push bc 
15b0 e5				push hl 
15b1 f5				push af 
15b2			 
15b2				; for use in here 
15b2			 
15b2 c5				push bc 
15b3 d5				push de 
15b4 e5				push hl 
15b5 f5				push af 
15b6			 
15b6 cd 8c 0a			call clear_display 
15b9			 
15b9 11 6e 16			ld de, .regstate 
15bc 3e 00			ld a, display_row_1 
15be cd 9f 0a			call str_at_display 
15c1			 
15c1				; display debug step 
15c1			 
15c1			 
15c1 11 bd fb			ld de, debug_mark 
15c4 3e 11			ld a, display_row_1+display_cols-3 
15c6 cd 9f 0a			call str_at_display 
15c9			 
15c9				; display a 
15c9 11 8a 16			ld de, .regstatea 
15cc 3e 14			ld a, display_row_2 
15ce cd 9f 0a			call str_at_display 
15d1			 
15d1 e1				pop hl 
15d2			;	ld h,0 
15d2			;	ld l, a 
15d2 3e 17			ld a, display_row_2+3 
15d4 cd 59 14			call display_word_at 
15d7			 
15d7			 
15d7				; display hl 
15d7			 
15d7			 
15d7 11 7e 16			ld de, .regstatehl 
15da 3e 1e			ld a, display_row_2+10 
15dc cd 9f 0a			call str_at_display 
15df			 
15df e1				pop hl 
15e0 3e 21			ld a, display_row_2+13 
15e2 cd 59 14			call display_word_at 
15e5			 
15e5				 
15e5				; display de 
15e5			 
15e5 11 82 16			ld de, .regstatede 
15e8 3e 28			ld a, display_row_3 
15ea cd 9f 0a			call str_at_display 
15ed			 
15ed e1				pop hl 
15ee			;	ld h,d 
15ee			;	ld l, e 
15ee 3e 2b			ld a, display_row_3+3 
15f0 cd 59 14			call display_word_at 
15f3			 
15f3			 
15f3				; display bc 
15f3			 
15f3 11 86 16			ld de, .regstatebc 
15f6 3e 32			ld a, display_row_3+10 
15f8 cd 9f 0a			call str_at_display 
15fb			 
15fb e1				pop hl 
15fc			;	ld h,b 
15fc			;	ld l, c 
15fc 3e 35			ld a, display_row_3+13 
15fe cd 59 14			call display_word_at 
1601			 
1601			 
1601				; display dsp 
1601			 
1601 11 8e 16			ld de, .regstatedsp 
1604 3e 3c			ld a, display_row_4 
1606 cd 9f 0a			call str_at_display 
1609			 
1609				 
1609 2a a5 f9			ld hl,(cli_data_sp) 
160c 3e 40			ld a, display_row_4+4 
160e cd 59 14			call display_word_at 
1611			 
1611				; display rsp 
1611			 
1611 11 93 16			ld de, .regstatersp 
1614 3e 46			ld a, display_row_4+10 
1616 cd 9f 0a			call str_at_display 
1619			 
1619				 
1619 2a a9 f9			ld hl,(cli_ret_sp) 
161c 3e 4a			ld a, display_row_4+14 
161e cd 59 14			call display_word_at 
1621			 
1621 cd af 0a			call update_display 
1624			 
1624			;	call delay1s 
1624			;	call delay1s 
1624			;	call delay1s 
1624			 
1624			 
1624			;	call next_page_prompt 
1624			 
1624				; restore  
1624			 
1624 f1				pop af 
1625 e1				pop hl 
1626 c1				pop bc 
1627 d1				pop de 
1628 c9				ret 
1629			 
1629 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
163d .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1652 .. 00		.ptrstate:	db "Ptr State",0 
165c .. 00		.ptrcliptr:     db "cli_ptr",0 
1664 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
166e .. 00		.regstate:	db "Reg State (1/0)",0 
167e .. 00		.regstatehl:	db "HL:",0 
1682 .. 00		.regstatede:	db "DE:",0 
1686 .. 00		.regstatebc:	db "BC:",0 
168a .. 00		.regstatea:	db "A :",0 
168e .. 00		.regstatedsp:	db "DSP:",0 
1693 .. 00		.regstatersp:	db "RSP:",0 
1698			 
1698			display_dump_at_hl: 
1698 e5				push hl 
1699 d5				push de 
169a c5				push bc 
169b f5				push af 
169c			 
169c 22 db f2			ld (os_cur_ptr),hl	 
169f cd 8c 0a			call clear_display 
16a2 cd ee 18			call dumpcont 
16a5			;	call delay1s 
16a5			;	call next_page_prompt 
16a5			 
16a5			 
16a5 f1				pop af 
16a6 c1				pop bc 
16a7 d1				pop de 
16a8 e1				pop hl 
16a9 c9				ret 
16aa			 
16aa			;if ENABLE_BASIC 
16aa			;	include "nascombasic.asm" 
16aa			;	basic: 
16aa			;	include "forth/FORTH.ASM" 
16aa			;endif 
16aa			 
16aa			; eof 
16aa			 
16aa			 
# End of file firmware_diags.asm
16aa			  
16aa			  
16aa			  
16aa			  
16aa			; eof  
16aa			  
# End of file firmware.asm
16aa			 
16aa			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
16aa			;if BASE_KEV  
16aa			;baseram: equ 08000h 
16aa			;endif 
16aa			 
16aa			;if BASE_SC114 
16aa			;baseram:     equ    endofcode 
16aa			;endif 
16aa			 
16aa			 
16aa			; start system 
16aa			 
16aa			coldstart: 
16aa				; set sp 
16aa				; di/ei 
16aa			 
16aa f3				di 
16ab 31 fd ff			ld sp, tos 
16ae			;	ei 
16ae			 
16ae			 
16ae				; disable breakpoint by default 
16ae			 
16ae 3e 2a			ld a,'*' 
16b0 32 b7 ef			ld (os_view_disable),a 
16b3			 
16b3				; init hardware 
16b3			 
16b3				; init keyboard and screen hardware 
16b3			 
16b3 cd 03 00			call hardware_init 
16b6			 
16b6			 
16b6				; detect if any keys are held down to enable breakpoints at start up 
16b6			 
16b6 cd 49 63			call cin  
16b9 fe 00			cp 0 
16bb 28 03			jr z, .nokeys 
16bd			 
16bd				;call hardware_diags 
16bd cd 1c 13			call config 
16c0			 
16c0			;	ld de, .bpen 
16c0			;	ld a, display_row_4 
16c0			;	call str_at_display 
16c0			;	call update_display 
16c0			; 
16c0			;	ld a,0 
16c0			;	ld (os_view_disable),a 
16c0			; 
16c0			;.bpwait: 
16c0			;	call cin 
16c0			;	cp 0 
16c0			;	jr z, .bpwait 
16c0			;	jr .nokeys 
16c0			; 
16c0			; 
16c0			;.bpen:  db "Break points enabled!",0 
16c0			 
16c0			 
16c0			 
16c0			 
16c0			 
16c0			 
16c0			.nokeys: 
16c0			 
16c0			 
16c0				 
16c0			 
16c0			;jp  testkey 
16c0			 
16c0			;call storage_get_block_0 
16c0			; 
16c0			;ld hl, 0 
16c0			;ld de, store_page 
16c0			;call storage_read_block 
16c0			 
16c0				 
16c0			;ld hl, 10 
16c0			;ld de, store_page 
16c0			;call storage_read_block 
16c0			 
16c0			 
16c0			 
16c0			 
16c0			 
16c0			;stop:	nop 
16c0			;	jp stop 
16c0			 
16c0			 
16c0			 
16c0			main: 
16c0 cd 8c 0a			call clear_display 
16c3 cd af 0a			call update_display 
16c6			 
16c6			 
16c6			 
16c6			;	call testlcd 
16c6			 
16c6			 
16c6			 
16c6 cd 34 1c			call forth_init 
16c9			 
16c9			 
16c9			warmstart: 
16c9 cd 0a 1c			call forth_warmstart 
16cc			 
16cc				; run startup word load 
16cc			        ; TODO prevent this running at warmstart after crash  
16cc			 
16cc				if STARTUP_ENABLE 
16cc cd b2 5e				call forth_startup 
16cf				endif 
16cf			 
16cf				; show free memory after boot 
16cf 11 76 17			ld de, freeram 
16d2 3e 00			ld a, display_row_1 
16d4 cd 9f 0a			call str_at_display 
16d7			 
16d7			; Or use heap_size word???? 
16d7 21 ac ef			ld hl, heap_end 
16da 11 0e 80			ld de, heap_start 
16dd ed 52			sbc hl, de 
16df e5				push hl 
16e0 7c				ld a,h	         	 
16e1 21 bd f2			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
16e4 cd bd 0f			call hexout 
16e7 e1			   	pop hl 
16e8			 
16e8 7d				ld a,l 
16e9 21 bf f2			ld hl, os_word_scratch+2 
16ec cd bd 0f			call hexout 
16ef 21 c1 f2			ld hl, os_word_scratch+4 
16f2 3e 00			ld a, 0 
16f4 77				ld (hl),a 
16f5 11 bd f2			ld de, os_word_scratch 
16f8 3e 0d			ld a, display_row_1 + 13 
16fa cd 9f 0a			call str_at_display 
16fd cd af 0a			call update_display 
1700			 
1700			 
1700				;call demo 
1700			 
1700			 
1700				; init scratch input area for cli commands 
1700			 
1700 21 df f2			ld hl, os_cli_cmd 
1703 3e 00			ld a,0 
1705 77				ld (hl),a 
1706 23				inc hl 
1707 77				ld (hl),a 
1708			 
1708 3e 00			ld a,0 
170a 32 de f3			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
170d			 
170d 32 db f2			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1710 32 dc f2			ld (os_cur_ptr+1),a	 
1713			 
1713 32 bd f2			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1716 32 be f2			ld (os_word_scratch+1),a	 
1719				 
1719			 
1719				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1719 21 df f2			ld hl, os_cli_cmd 
171c			 
171c 3e 00			ld a, 0		 ; init cli input 
171e 77				ld (hl), a 
171f 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1721			cli: 
1721				; show cli prompt 
1721				;push af 
1721				;ld a, 0 
1721				;ld de, prompt 
1721				;call str_at_display 
1721			 
1721				;call update_display 
1721				;pop af 
1721				;inc a 
1721				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1721 0e 00			ld c, 0 
1723 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1725 1e 28			ld e, 40 
1727			 
1727 21 df f2			ld hl, os_cli_cmd 
172a			 
172a				STACKFRAME OFF $fefe $9f9f 
172a				if DEBUG_STACK_IMB 
172a					if OFF 
172a						exx 
172a						ld de, $fefe 
172a						ld a, d 
172a						ld hl, curframe 
172a						call hexout 
172a						ld a, e 
172a						ld hl, curframe+2 
172a						call hexout 
172a						ld hl, $fefe 
172a						push hl 
172a						ld hl, $9f9f 
172a						push hl 
172a						exx 
172a					endif 
172a				endif 
172a			endm 
# End of macro STACKFRAME
172a			 
172a cd e9 0c			call input_str 
172d			 
172d				STACKFRAMECHK OFF $fefe $9f9f 
172d				if DEBUG_STACK_IMB 
172d					if OFF 
172d						exx 
172d						ld hl, $9f9f 
172d						pop de   ; $9f9f 
172d						call cmp16 
172d						jr nz, .spnosame 
172d						ld hl, $fefe 
172d						pop de   ; $fefe 
172d						call cmp16 
172d						jr z, .spfrsame 
172d						.spnosame: call showsperror 
172d						.spfrsame: nop 
172d						exx 
172d					endif 
172d				endif 
172d			endm 
# End of macro STACKFRAMECHK
172d			 
172d				; copy input to last command 
172d			 
172d 21 df f2			ld hl, os_cli_cmd 
1730 11 de f3			ld de, os_last_cmd 
1733 01 ff 00			ld bc, 255 
1736 ed b0			ldir 
1738			 
1738				; wipe current buffer 
1738			 
1738 3e 00			ld a, 0 
173a 21 df f2			ld hl, os_cli_cmd 
173d 11 e0 f2			ld de, os_cli_cmd+1 
1740 01 fe 00			ld bc, 254 
1743 ed b0			ldir 
1745				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1745			;	call strcpy 
1745			;	ld a, 0 
1745			;	ld (hl), a 
1745			;	inc hl 
1745			;	ld (hl), a 
1745			;	inc hl 
1745			;	ld (hl), a 
1745			 
1745				; switch frame buffer to program  
1745			 
1745 21 02 fb				ld hl, display_fb1 
1748 22 5e fa				ld (display_fb_active), hl 
174b			 
174b			;	nop 
174b				STACKFRAME ON $fbfe $8f9f 
174b				if DEBUG_STACK_IMB 
174b					if ON 
174b						exx 
174b						ld de, $fbfe 
174b						ld a, d 
174b						ld hl, curframe 
174b						call hexout 
174b						ld a, e 
174b						ld hl, curframe+2 
174b						call hexout 
174b						ld hl, $fbfe 
174b						push hl 
174b						ld hl, $8f9f 
174b						push hl 
174b						exx 
174b					endif 
174b				endif 
174b			endm 
# End of macro STACKFRAME
174b				; first time into the parser so pass over the current scratch pad 
174b 21 df f2			ld hl,os_cli_cmd 
174e				; tokenise the entered statement(s) in HL 
174e cd ad 1c			call forthparse 
1751			        ; exec forth statements in top of return stack 
1751 cd ed 1c			call forthexec 
1754				;call forthexec_cleanup 
1754			;	call parsenext 
1754			 
1754				STACKFRAMECHK ON $fbfe $8f9f 
1754				if DEBUG_STACK_IMB 
1754					if ON 
1754						exx 
1754						ld hl, $8f9f 
1754						pop de   ; $8f9f 
1754						call cmp16 
1754						jr nz, .spnosame 
1754						ld hl, $fbfe 
1754						pop de   ; $fbfe 
1754						call cmp16 
1754						jr z, .spfrsame 
1754						.spnosame: call showsperror 
1754						.spfrsame: nop 
1754						exx 
1754					endif 
1754				endif 
1754			endm 
# End of macro STACKFRAMECHK
1754				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1754			 
1754 3e 3c			ld a, display_row_4 
1756 11 88 17			ld de, endprog 
1759			 
1759 cd af 0a			call update_display		 
175c			 
175c cd e6 19			call next_page_prompt 
175f			 
175f				; switch frame buffer to cli 
175f			 
175f 21 53 fb				ld hl, display_fb0 
1762 22 5e fa				ld (display_fb_active), hl 
1765			 
1765			 
1765 cd 8c 0a		        call clear_display 
1768 cd af 0a			call update_display		 
176b			 
176b 21 df f2			ld hl, os_cli_cmd 
176e			 
176e 3e 00			ld a, 0		 ; init cli input 
1770 77				ld (hl), a 
1771			 
1771				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1771			 
1771				; now on last line 
1771			 
1771				; TODO scroll screen up 
1771			 
1771				; TODO instead just clear screen and place at top of screen 
1771			 
1771			;	ld a, 0 
1771			;	ld (f_cursor_ptr),a 
1771			 
1771				;call clear_display 
1771				;call update_display 
1771			 
1771				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1771 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1773 c3 21 17			jp cli 
1776			 
1776 .. 00		freeram: db "Free bytes: $",0 
1784 ..			asc: db "1A2F" 
1788 .. 00		endprog: db "End prog...",0 
1794			 
1794			testenter2:   
1794 21 ea ef			ld hl,scratch+50 
1797 22 db f2			ld (os_cur_ptr),hl 
179a c3 21 17			jp cli 
179d			 
179d			testenter:  
179d			 
179d 21 84 17			ld hl,asc 
17a0			;	ld a,(hl) 
17a0			;	call nibble2val 
17a0 cd 13 10			call get_byte 
17a3			 
17a3			 
17a3			;	ld a,(hl) 
17a3			;	call atohex 
17a3			 
17a3			;	call fourehexhl 
17a3 32 ea ef			ld (scratch+50),a 
17a6			 
17a6			 
17a6			 
17a6 21 86 17			ld hl,asc+2 
17a9			;	ld a, (hl) 
17a9			;	call nibble2val 
17a9 cd 13 10			call get_byte 
17ac			 
17ac			;	call fourehexhl 
17ac 32 ec ef			ld (scratch+52),a 
17af				 
17af 21 ea ef			ld hl,scratch+50 
17b2 22 db f2			ld (os_cur_ptr),hl 
17b5 c3 21 17			jp cli 
17b8			 
17b8			enter:	 
17b8 3a bc ef			ld a,(scratch+4) 
17bb fe 00			cp 0 
17bd 28 0c			jr z, .entercont 
17bf				; no, not a null term line so has an address to work out.... 
17bf			 
17bf 21 ba ef			ld hl,scratch+2 
17c2 cd 73 10			call get_word_hl 
17c5			 
17c5 22 db f2			ld (os_cur_ptr),hl	 
17c8 c3 21 17			jp cli 
17cb			 
17cb			 
17cb			.entercont:  
17cb			 
17cb 21 ba ef			ld hl, scratch+2 
17ce cd 13 10			call get_byte 
17d1			 
17d1 2a db f2		   	ld hl,(os_cur_ptr) 
17d4 77					ld (hl),a 
17d5 23					inc hl 
17d6 22 db f2				ld (os_cur_ptr),hl 
17d9				 
17d9			; get byte  
17d9			 
17d9			 
17d9 c3 21 17			jp cli 
17dc			 
17dc			 
17dc			; basic monitor support 
17dc			 
17dc			monitor: 
17dc				;  
17dc cd 8c 0a			call clear_display 
17df 3e 00			ld a, 0 
17e1 11 29 18			ld de, .monprompt 
17e4 cd 9f 0a			call str_at_display 
17e7 cd af 0a			call update_display 
17ea			 
17ea				; get a monitor command 
17ea			 
17ea 0e 00			ld c, 0     ; entry at top left 
17ec 16 64			ld d, 100   ; max buffer size 
17ee 1e 0f			ld e, 15    ; input scroll area 
17f0 3e 00			ld a, 0     ; init string 
17f2 21 b6 f1			ld hl, os_input 
17f5 77				ld (hl), a 
17f6 23				inc hl 
17f7 77				ld (hl), a 
17f8 21 b6 f1			ld hl, os_input 
17fb 3e 01			ld a, 1     ; init string 
17fd cd e9 0c			call input_str 
1800			 
1800 cd 8c 0a		        call clear_display 
1803 cd af 0a			call update_display		 
1806			 
1806 3a b6 f1			ld a, (os_input) 
1809 cd 11 11			call toUpper 
180c fe 48		        cp 'H' 
180e 28 6f		        jr z, .monhelp 
1810 fe 44			cp 'D'		; dump 
1812 ca a0 18			jp z, .mondump	 
1815 fe 43			cp 'C'		; dump 
1817 ca ba 18			jp z, .moncdump	 
181a fe 4d			cp 'M'		; dump 
181c ca 2b 18			jp z, .moneditstart 
181f fe 55			cp 'U'		; dump 
1821 28 14			jr z, .monedit	 
1823 fe 51			cp 'Q'		; dump 
1825 c8				ret z	 
1826			 
1826			 
1826				; TODO "S" to access symbol by name and not need the address 
1826				; TODO "F" to find a string in memory 
1826			 
1826 c3 dc 17			jp monitor 
1829			 
1829 .. 00		.monprompt: db ">", 0 
182b			 
182b			.moneditstart: 
182b				; get starting address 
182b			 
182b 21 b8 f1			ld hl,os_input+2 
182e cd 73 10			call get_word_hl 
1831			 
1831 22 db f2			ld (os_cur_ptr),hl	 
1834			 
1834 c3 dc 17			jp monitor 
1837			 
1837			.monedit: 
1837				; get byte to load 
1837			 
1837 21 b8 f1			ld hl,os_input+2 
183a cd 13 10			call get_byte 
183d			 
183d				; get address to update 
183d 2a db f2			ld hl, (os_cur_ptr) 
1840			 
1840				; update byte 
1840			 
1840 77				ld (hl), a 
1841			 
1841				; move to next address and save it 
1841			 
1841 23				inc hl 
1842 22 db f2			ld (os_cur_ptr),hl	 
1845			 
1845 c3 dc 17			jp monitor 
1848			 
1848			 
1848 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
185c .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1878 .. 00		.monhelptext3:  db "Q-Quit",0 
187f			        
187f			.monhelp: 
187f 3e 00			ld a, display_row_1 
1881 11 48 18		        ld de, .monhelptext1 
1884			 
1884 cd 9f 0a			call str_at_display 
1887 3e 14			ld a, display_row_2 
1889 11 5c 18		        ld de, .monhelptext2 
188c					 
188c cd 9f 0a			call str_at_display 
188f 3e 28			ld a, display_row_3 
1891 11 78 18		        ld de, .monhelptext3 
1894					 
1894 cd 9f 0a			call str_at_display 
1897 cd af 0a			call update_display		 
189a			 
189a cd e6 19			call next_page_prompt 
189d c3 dc 17			jp monitor 
18a0			 
18a0			.mondump:    
18a0 21 b8 f1			ld hl,os_input+2 
18a3 cd 73 10			call get_word_hl 
18a6			 
18a6 22 db f2			ld (os_cur_ptr),hl	 
18a9 cd ee 18			call dumpcont 
18ac 3e 3c			ld a, display_row_4 
18ae 11 88 17			ld de, endprog 
18b1			 
18b1 cd af 0a			call update_display		 
18b4			 
18b4 cd e6 19			call next_page_prompt 
18b7 c3 dc 17			jp monitor 
18ba			.moncdump: 
18ba cd ee 18			call dumpcont 
18bd 3e 3c			ld a, display_row_4 
18bf 11 88 17			ld de, endprog 
18c2			 
18c2 cd af 0a			call update_display		 
18c5			 
18c5 cd e6 19			call next_page_prompt 
18c8 c3 dc 17			jp monitor 
18cb			 
18cb			 
18cb			; TODO symbol access  
18cb			 
18cb			.symbols:     ;; A list of symbols that can be called up  
18cb 53 fb			dw display_fb0 
18cd .. 00			db "fb0",0  
18d1 e8 f9		     	dw store_page 
18d3 .. 00			db "store_page",0 
18de			 
18de			 
18de			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
18de			 
18de 3a b9 ef			ld a,(scratch+1) 
18e1 fe 00			cp 0 
18e3 28 09			jr z, dumpcont 
18e5			 
18e5				; no, not a null term line so has an address to work out.... 
18e5			 
18e5 21 ba ef			ld hl,scratch+2 
18e8 cd 73 10			call get_word_hl 
18eb			 
18eb 22 db f2			ld (os_cur_ptr),hl	 
18ee			 
18ee			 
18ee			 
18ee			dumpcont: 
18ee			 
18ee				; dump bytes at ptr 
18ee			 
18ee			 
18ee 3e 00			ld a, display_row_1 
18f0 2a 5e fa			ld hl, (display_fb_active) 
18f3 cd bc 0c			call addatohl 
18f6 cd 1e 19			call .dumpbyterow 
18f9			 
18f9 3e 14			ld a, display_row_2 
18fb 2a 5e fa			ld hl, (display_fb_active) 
18fe cd bc 0c			call addatohl 
1901 cd 1e 19			call .dumpbyterow 
1904			 
1904			 
1904 3e 28			ld a, display_row_3 
1906 2a 5e fa			ld hl, (display_fb_active) 
1909 cd bc 0c			call addatohl 
190c cd 1e 19			call .dumpbyterow 
190f			 
190f 3e 3c			ld a, display_row_4 
1911 2a 5e fa			ld hl, (display_fb_active) 
1914 cd bc 0c			call addatohl 
1917 cd 1e 19			call .dumpbyterow 
191a			 
191a cd af 0a			call update_display 
191d			;		jp cli 
191d c9				ret 
191e			 
191e			.dumpbyterow: 
191e			 
191e				;push af 
191e			 
191e e5				push hl 
191f			 
191f				; calc where to poke the ascii 
191f			if display_cols == 20 
191f 3e 10			ld a, 16 
1921			else 
1921				ld a, 31 
1921			endif 
1921			 
1921 cd bc 0c			call addatohl 
1924 22 bd f2			ld (os_word_scratch),hl  		; save pos for later 
1927			 
1927			 
1927			; display decoding address 
1927 2a db f2		   	ld hl,(os_cur_ptr) 
192a			 
192a 7c				ld a,h 
192b e1				pop hl 
192c e5				push hl 
192d			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
192d cd bd 0f			call hexout 
1930 2a db f2		   	ld hl,(os_cur_ptr) 
1933			 
1933 7d				ld a,l 
1934 e1				pop hl 
1935 23				inc hl 
1936 23				inc hl 
1937 e5				push hl 
1938			;	ld hl, os_word_scratch+2 
1938 cd bd 0f			call hexout 
193b e1				pop hl 
193c 23				inc hl 
193d 23				inc hl 
193e				;ld hl, os_word_scratch+4 
193e 3e 3a			ld a, ':' 
1940 77				ld (hl),a 
1941 23				inc hl 
1942				;ld a, 0 
1942				;ld (hl),a 
1942				;ld de, os_word_scratch 
1942				;pop af 
1942				;push af 
1942			;		ld a, display_row_2 
1942			;		call str_at_display 
1942			;		call update_display 
1942			 
1942			 
1942			;pop af 
1942			;	add 5 
1942			 
1942			if display_cols == 20 
1942 06 04			ld b, 4 
1944			else 
1944				ld b, 8 
1944			endif	 
1944			 
1944			.dumpbyte: 
1944 c5				push bc 
1945 e5				push hl 
1946			 
1946			 
1946 2a db f2		   	ld hl,(os_cur_ptr) 
1949 7e					ld a,(hl) 
194a			 
194a					; poke the ascii to display 
194a 2a bd f2				ld hl,(os_word_scratch) 
194d 77					ld (hl),a 
194e 23					inc hl 
194f 22 bd f2				ld (os_word_scratch),hl 
1952			 
1952					 
1952			 
1952			 
1952 e1					pop hl 
1953 e5					push hl 
1954			 
1954 cd bd 0f				call hexout 
1957			 
1957					 
1957 2a db f2		   	ld hl,(os_cur_ptr) 
195a 23				inc hl 
195b 22 db f2		   	ld (os_cur_ptr),hl 
195e			 
195e e1					pop hl 
195f 23					inc hl 
1960 23					inc hl 
1961 23					inc hl 
1962			 
1962			 
1962			 
1962					;ld a,0 
1962					;ld (os_word_scratch+2),a 
1962					;pop af 
1962					;push af 
1962			 
1962					;ld de, os_word_scratch 
1962					;call str_at_display 
1962			;		call update_display 
1962			;		pop af 
1962 c1					pop bc 
1963 c6 03				add 3 
1965 10 dd			djnz .dumpbyte 
1967			 
1967				 
1967			 
1967 c9				ret 
1968			 
1968			jump:	 
1968			 
1968 21 ba ef			ld hl,scratch+2 
196b cd 73 10			call get_word_hl 
196e				;ld hl,(scratch+2) 
196e				;call fourehexhl 
196e			 
196e 22 db f2			ld (os_cur_ptr),hl	 
1971			 
1971 e9				jp (hl) 
1972			 
1972			 
1972			 
1972			; TODO implement a basic monitor mode to start with 
1972			 
1972			 
1972			 
1972			 
1972			 
1972			 
1972			 
1972			 
1972			 
1972			; testing and demo code during development 
1972			 
1972			 
1972 .. 00		str1: db "Enter some text...",0 
1985 .. 00		clear: db "                    ",0 
199a			 
199a			demo: 
199a			 
199a			 
199a			 
199a			;	call update_display 
199a			 
199a				; init scratch input area for testing 
199a 21 b8 ef			ld hl, scratch	 
199d 3e 00			ld a,0 
199f 77				ld (hl),a 
19a0			 
19a0			 
19a0 3e 14		            LD   A, display_row_2 
19a2			;            CALL fLCD_Pos       ;Position cursor to location in A 
19a2 11 72 19		            LD   DE, str1 
19a5 cd 9f 0a			call str_at_display 
19a8			 
19a8			;            CALL fLCD_Str       ;Display string pointed to by DE 
19a8			cloop:	 
19a8 3e 28		            LD   A, display_row_3 
19aa			;            CALL fLCD_Pos       ;Position cursor to location in A 
19aa 11 85 19		            LD   DE, clear 
19ad			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
19ad cd 9f 0a				call str_at_display 
19b0 3e 3c			ld a, display_row_4 
19b2 11 e2 19			ld de, prompt 
19b5			 
19b5 cd 9f 0a				call str_at_display 
19b8 cd af 0a			call update_display 
19bb			 
19bb 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
19bd 16 0a			ld d, 10 
19bf 21 b8 ef			ld hl, scratch	 
19c2 cd e9 0c			call input_str 
19c5			 
19c5			;	call clear_display 
19c5			;'	call update_display 
19c5			 
19c5 3e 00		            LD   A, display_row_1 
19c7			;            CALL fLCD_Pos       ;Position cursor to location in A 
19c7 11 85 19		            LD   DE, clear 
19ca cd 9f 0a				call str_at_display 
19cd			;            CALL fLCD_Str       ;Display string pointed to by DE 
19cd 3e 00		            LD   A, display_row_1 
19cf			;            CALL fLCD_Pos       ;Position cursor to location in A 
19cf 11 b8 ef		            LD   DE, scratch 
19d2			;            CALL fLCD_Str       ;Display string pointed to by DE 
19d2 cd 9f 0a				call str_at_display 
19d5 cd af 0a			call update_display 
19d8			 
19d8 3e 00				ld a,0 
19da 21 b8 ef			ld hl, scratch 
19dd 77				ld (hl),a 
19de			 
19de 00				nop 
19df c3 a8 19			jp cloop 
19e2			 
19e2			 
19e2			 
19e2			; OS Prompt 
19e2			 
19e2 .. 00		prompt: db ">",0 
19e4 .. 00		endprg: db "?",0 
19e6			 
19e6			 
19e6			; handy next page prompt 
19e6			next_page_prompt: 
19e6 e5				push hl 
19e7 d5				push de 
19e8 f5				push af 
19e9 c5				push bc 
19ea			 
19ea 3e 4f			ld a,display_row_4 + display_cols - 1 
19ec 11 e4 19		        ld de, endprg 
19ef cd 9f 0a			call str_at_display 
19f2 cd af 0a			call update_display 
19f5 cd 38 63			call cin_wait 
19f8 c1				pop bc 
19f9 f1				pop af 
19fa d1				pop de 
19fb e1				pop hl 
19fc			 
19fc			 
19fc c9				ret 
19fd			 
19fd			 
19fd			; forth parser 
19fd			 
19fd			; My forth kernel 
19fd			include "forth_kernel.asm" 
19fd			; 
19fd			; kernel to the forth OS 
19fd			 
19fd			DS_TYPE_STR: equ 1     ; string type 
19fd			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
19fd			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
19fd			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
19fd			 
19fd			FORTH_PARSEV1: equ 0 
19fd			FORTH_PARSEV2: equ 0 
19fd			FORTH_PARSEV3: equ 0 
19fd			FORTH_PARSEV4: equ 0 
19fd			FORTH_PARSEV5: equ 1 
19fd			 
19fd			;if FORTH_PARSEV5 
19fd			;	FORTH_END_BUFFER: equ 0 
19fd			;else 
19fd			FORTH_END_BUFFER: equ 127 
19fd			;endif 
19fd			 
19fd			FORTH_TRUE: equ 1 
19fd			FORTH_FALSE: equ 0 
19fd			 
19fd			if FORTH_PARSEV4 
19fd			include "forth_stackops.asm" 
19fd			endif 
19fd			 
19fd			if FORTH_PARSEV5 
19fd			include "forth_stackopsv5.asm" 
19fd			 
19fd			; Stack operations for v5 parser on wards 
19fd			; * DATA stack 
19fd			; * LOOP stack 
19fd			; * RETURN stack 
19fd			 
19fd			 
19fd			 
19fd			FORTH_CHK_DSP_UNDER: macro 
19fd				push hl 
19fd				push de 
19fd				ld hl,(cli_data_sp) 
19fd				ld de, cli_data_stack 
19fd				call cmp16 
19fd				jp c, fault_dsp_under 
19fd				pop de 
19fd				pop hl 
19fd				endm 
19fd			 
19fd			 
19fd			FORTH_CHK_RSP_UNDER: macro 
19fd				push hl 
19fd				push de 
19fd				ld hl,(cli_ret_sp) 
19fd				ld de, cli_ret_stack 
19fd				call cmp16 
19fd				jp c, fault_rsp_under 
19fd				pop de 
19fd				pop hl 
19fd				endm 
19fd			 
19fd			FORTH_CHK_LOOP_UNDER: macro 
19fd				push hl 
19fd				push de 
19fd				ld hl,(cli_loop_sp) 
19fd				ld de, cli_loop_stack 
19fd				call cmp16 
19fd				jp c, fault_loop_under 
19fd				pop de 
19fd				pop hl 
19fd				endm 
19fd			 
19fd			FORTH_ERR_TOS_NOTSTR: macro 
19fd				; TOSO might need more for checks when used 
19fd				push af 
19fd				ld a,(hl) 
19fd				cp DS_TYPE_STR 
19fd				jp nz, type_faultn   
19fd				pop af 
19fd				endm 
19fd			 
19fd			FORTH_ERR_TOS_NOTNUM: macro 
19fd				push af 
19fd				ld a,(hl) 
19fd				cp DS_TYPE_INUM 
19fd				jp nz, type_faultn   
19fd				pop af 
19fd				endm 
19fd			 
19fd			 
19fd			; increase data stack pointer and save hl to it 
19fd				 
19fd			FORTH_DSP_NEXT: macro 
19fd				call macro_forth_dsp_next 
19fd				endm 
19fd			 
19fd			 
19fd			macro_forth_dsp_next: 
19fd				if DEBUG_FORTH_STACK_GUARD 
19fd cd 7c 5f				call check_stacks 
1a00				endif 
1a00 e5				push hl 
1a01 d5				push de 
1a02 eb				ex de,hl 
1a03 2a a5 f9			ld hl,(cli_data_sp) 
1a06 23				inc hl 
1a07 23				inc hl 
1a08			 
1a08			; PARSEV5 
1a08 23				inc hl 
1a09 22 a5 f9			ld (cli_data_sp),hl 
1a0c 73				ld (hl), e 
1a0d 23				inc hl 
1a0e 72				ld (hl), d 
1a0f d1				pop de 
1a10 e1				pop hl 
1a11				if DEBUG_FORTH_STACK_GUARD 
1a11 cd 7c 5f				call check_stacks 
1a14				endif 
1a14 c9				ret 
1a15			 
1a15			 
1a15			; increase ret stack pointer and save hl to it 
1a15				 
1a15			FORTH_RSP_NEXT: macro 
1a15				call macro_forth_rsp_next 
1a15				endm 
1a15			 
1a15			macro_forth_rsp_next: 
1a15				if DEBUG_FORTH_STACK_GUARD 
1a15 cd 7c 5f				call check_stacks 
1a18				endif 
1a18 e5				push hl 
1a19 d5				push de 
1a1a eb				ex de,hl 
1a1b 2a a9 f9			ld hl,(cli_ret_sp) 
1a1e 23				inc hl 
1a1f 23				inc hl 
1a20 22 a9 f9			ld (cli_ret_sp),hl 
1a23 73				ld (hl), e 
1a24 23				inc hl 
1a25 72				ld (hl), d 
1a26 d1				pop de 
1a27 e1				pop hl 
1a28				if DEBUG_FORTH_STACK_GUARD 
1a28 cd 7c 5f				call check_stacks 
1a2b				endif 
1a2b c9				ret 
1a2c			 
1a2c			; get current ret stack pointer and save to hl  
1a2c				 
1a2c			FORTH_RSP_TOS: macro 
1a2c				call macro_forth_rsp_tos 
1a2c				endm 
1a2c			 
1a2c			macro_forth_rsp_tos: 
1a2c				;push de 
1a2c 2a a9 f9			ld hl,(cli_ret_sp) 
1a2f cd 67 1a			call loadhlptrtohl 
1a32				;ld e, (hl) 
1a32				;inc hl 
1a32				;ld d, (hl) 
1a32				;ex de, hl 
1a32					if DEBUG_FORTH_WORDS 
1a32			;			DMARK "RST" 
1a32						CALLMONITOR 
1a32 cd d4 14			call break_point_state  
1a35				endm  
# End of macro CALLMONITOR
1a35					endif 
1a35				;pop de 
1a35 c9				ret 
1a36			 
1a36			; pop ret stack pointer 
1a36				 
1a36			FORTH_RSP_POP: macro 
1a36				call macro_forth_rsp_pop 
1a36				endm 
1a36			 
1a36			 
1a36			macro_forth_rsp_pop: 
1a36				if DEBUG_FORTH_STACK_GUARD 
1a36			;		DMARK "RPP" 
1a36 cd 7c 5f				call check_stacks 
1a39					FORTH_CHK_RSP_UNDER 
1a39 e5				push hl 
1a3a d5				push de 
1a3b 2a a9 f9			ld hl,(cli_ret_sp) 
1a3e 11 23 f9			ld de, cli_ret_stack 
1a41 cd da 0c			call cmp16 
1a44 da 90 60			jp c, fault_rsp_under 
1a47 d1				pop de 
1a48 e1				pop hl 
1a49				endm 
# End of macro FORTH_CHK_RSP_UNDER
1a49				endif 
1a49 e5				push hl 
1a4a 2a a9 f9			ld hl,(cli_ret_sp) 
1a4d			 
1a4d			 
1a4d				if FORTH_ENABLE_FREE 
1a4d			 
1a4d					; get pointer 
1a4d			 
1a4d					push de 
1a4d					push hl 
1a4d			 
1a4d					ld e, (hl) 
1a4d					inc hl 
1a4d					ld d, (hl) 
1a4d			 
1a4d					ex de, hl 
1a4d					call free 
1a4d			 
1a4d					pop hl 
1a4d					pop de 
1a4d			 
1a4d			 
1a4d				endif 
1a4d			 
1a4d			 
1a4d 2b				dec hl 
1a4e 2b				dec hl 
1a4f 22 a9 f9			ld (cli_ret_sp), hl 
1a52				; do stack underflow checks 
1a52 e1				pop hl 
1a53				if DEBUG_FORTH_STACK_GUARD 
1a53 cd 7c 5f				call check_stacks 
1a56					FORTH_CHK_RSP_UNDER 
1a56 e5				push hl 
1a57 d5				push de 
1a58 2a a9 f9			ld hl,(cli_ret_sp) 
1a5b 11 23 f9			ld de, cli_ret_stack 
1a5e cd da 0c			call cmp16 
1a61 da 90 60			jp c, fault_rsp_under 
1a64 d1				pop de 
1a65 e1				pop hl 
1a66				endm 
# End of macro FORTH_CHK_RSP_UNDER
1a66				endif 
1a66 c9				ret 
1a67			 
1a67			 
1a67			 
1a67			; routine to load word pointed to by hl into hl 
1a67			 
1a67			loadhlptrtohl: 
1a67			 
1a67 d5				push de 
1a68 5e				ld e, (hl) 
1a69 23				inc hl 
1a6a 56				ld d, (hl) 
1a6b eb				ex de, hl 
1a6c d1				pop de 
1a6d			 
1a6d c9				ret 
1a6e			 
1a6e			 
1a6e			 
1a6e			 
1a6e			 
1a6e			; push a number held in HL onto the data stack 
1a6e			; entry point for pushing a value when already in hl used in function above 
1a6e			 
1a6e			forth_push_numhl: 
1a6e			 
1a6e e5				push hl    ; save value to push 
1a6f			 
1a6f			if DEBUG_FORTH_PUSH 
1a6f				; see if disabled 
1a6f			 
1a6f			 
1a6f				push af 
1a6f				ld a, (os_view_disable) 
1a6f				cp '*' 
1a6f				jr z, .pskip2 
1a6f				push hl 
1a6f			push hl 
1a6f				call clear_display 
1a6f			pop hl 
1a6f				ld a,h 
1a6f				ld hl, os_word_scratch 
1a6f				call hexout 
1a6f				pop hl 
1a6f				ld a,l 
1a6f				ld hl, os_word_scratch+2 
1a6f				call hexout 
1a6f			 
1a6f				ld hl, os_word_scratch+4 
1a6f				ld a,0 
1a6f				ld (hl),a 
1a6f				ld de,os_word_scratch 
1a6f					ld a, display_row_2 
1a6f					call str_at_display 
1a6f				ld de, .push_num 
1a6f				ld a, display_row_1 
1a6f			 
1a6f					call str_at_display 
1a6f			 
1a6f			 
1a6f				call update_display 
1a6f				call delay1s 
1a6f				call delay1s 
1a6f			.pskip2:  
1a6f			 
1a6f				pop af 
1a6f			endif	 
1a6f			 
1a6f			 
1a6f				FORTH_DSP_NEXT 
1a6f cd fd 19			call macro_forth_dsp_next 
1a72				endm 
# End of macro FORTH_DSP_NEXT
1a72			 
1a72 2a a5 f9			ld hl, (cli_data_sp) 
1a75			 
1a75				; save item type 
1a75 3e 02			ld a,  DS_TYPE_INUM 
1a77 77				ld (hl), a 
1a78 23				inc hl 
1a79			 
1a79				; get word off stack 
1a79 d1				pop de 
1a7a 7b				ld a,e 
1a7b 77				ld (hl), a 
1a7c 23				inc hl 
1a7d 7a				ld a,d 
1a7e 77				ld (hl), a 
1a7f			 
1a7f			if DEBUG_FORTH_PUSH 
1a7f				dec hl 
1a7f				dec hl 
1a7f				dec hl 
1a7f						DMARK "PH5" 
1a7f				CALLMONITOR 
1a7f			endif	 
1a7f			 
1a7f c9				ret 
1a80			 
1a80			 
1a80			; Push a string to stack pointed to by hl 
1a80			 
1a80			forth_push_str: 
1a80			 
1a80			if DEBUG_FORTH_PUSH 
1a80						DMARK "PSQ" 
1a80				CALLMONITOR 
1a80			endif	 
1a80			    
1a80 e5				push hl 
1a81 e5				push hl 
1a82			 
1a82 3e 00			ld a, 0   ; find end of string 
1a84 cd 25 11			call strlent       
1a87			if DEBUG_FORTH_PUSH 
1a87						DMARK "PQ2" 
1a87				CALLMONITOR 
1a87			endif	 
1a87 eb				ex de, hl 
1a88 e1				pop hl   ; get ptr to start of string 
1a89			if DEBUG_FORTH_PUSH 
1a89						DMARK "PQ3" 
1a89				CALLMONITOR 
1a89			endif	 
1a89 19				add hl,de 
1a8a			if DEBUG_FORTH_PUSH 
1a8a						DMARK "PQE" 
1a8a				CALLMONITOR 
1a8a			endif	 
1a8a			 
1a8a 2b				dec hl    ; see if there is an optional trailing double quote 
1a8b 7e				ld a,(hl) 
1a8c fe 22			cp '"' 
1a8e 20 03			jr nz, .strnoq 
1a90 3e 00			ld a, 0      ; get rid of double quote 
1a92 77				ld (hl), a 
1a93 23			.strnoq: inc hl 
1a94			 
1a94 3e 00			ld a, 0 
1a96 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1a97			 
1a97 13				inc de ; add one for the type string 
1a98 13				inc de ; add one for null term??? 
1a99			 
1a99				; tos is get string pointer again 
1a99				; de contains space to allocate 
1a99				 
1a99 d5				push de 
1a9a			 
1a9a eb				ex de, hl 
1a9b			 
1a9b				;push af 
1a9b			 
1a9b			if DEBUG_FORTH_PUSH 
1a9b						DMARK "PHm" 
1a9b				CALLMONITOR 
1a9b			endif	 
1a9b cd 83 11			call malloc	; on ret hl now contains allocated memory 
1a9e				if DEBUG_FORTH_MALLOC_GUARD 
1a9e cc e2 4e				call z,malloc_error 
1aa1				endif 
1aa1			 
1aa1				 
1aa1 c1				pop bc    ; get length 
1aa2 d1				pop de   ;  get string start    
1aa3			 
1aa3				; hl has destination from malloc 
1aa3			 
1aa3 eb				ex de, hl    ; prep for ldir 
1aa4			 
1aa4 e5				push hl   ; save malloc area for DSP later 
1aa5			 
1aa5			if DEBUG_FORTH_PUSH 
1aa5						DMARK "PHc" 
1aa5				CALLMONITOR 
1aa5			endif	 
1aa5			 
1aa5			 
1aa5 ed b0			ldir 
1aa7			 
1aa7			 
1aa7				; push malloc to data stack     macro?????  
1aa7			 
1aa7				FORTH_DSP_NEXT 
1aa7 cd fd 19			call macro_forth_dsp_next 
1aaa				endm 
# End of macro FORTH_DSP_NEXT
1aaa			 
1aaa				; save value and type 
1aaa			 
1aaa 2a a5 f9			ld hl, (cli_data_sp) 
1aad			 
1aad				; save item type 
1aad 3e 01			ld a,  DS_TYPE_STR 
1aaf 77				ld (hl), a 
1ab0 23				inc hl 
1ab1			 
1ab1				; get malloc word off stack 
1ab1 d1				pop de 
1ab2 73				ld (hl), e 
1ab3 23				inc hl 
1ab4 72				ld (hl), d 
1ab5			 
1ab5			 
1ab5			 
1ab5			if DEBUG_FORTH_PUSH 
1ab5				ld hl, (cli_data_sp) 
1ab5						DMARK "PHS" 
1ab5				CALLMONITOR 
1ab5			;	ex de,hl 
1ab5			endif	 
1ab5				; in case of spaces, skip the ptr past the copied string 
1ab5				;pop af 
1ab5				;ld (cli_origptr),hl 
1ab5			 
1ab5 c9				ret 
1ab6			 
1ab6			 
1ab6			 
1ab6			; TODO ascii push input onto stack given hl to start of input 
1ab6			 
1ab6			; identify type 
1ab6			; if starts with a " then a string 
1ab6			; otherwise it is a number 
1ab6			;  
1ab6			; if a string 
1ab6			;     scan for ending " to get length of string to malloc for + 1 
1ab6			;     malloc 
1ab6			;     put pointer to string on stack first byte flags as string 
1ab6			; 
1ab6			; else a number 
1ab6			;    look for number format identifier 
1ab6			;    $xx hex 
1ab6			;    %xxxxx bin 
1ab6			;    xxxxx decimal 
1ab6			;    convert number to 16bit word.  
1ab6			;    malloc word + 1 with flag to identiy as num 
1ab6			;    put pointer to number on stack 
1ab6			;   
1ab6			;  
1ab6			  
1ab6			forth_apush: 
1ab6				; kernel push 
1ab6			 
1ab6			if DEBUG_FORTH_PUSH 
1ab6						DMARK "PSH" 
1ab6				CALLMONITOR 
1ab6			endif	 
1ab6				; identify input type 
1ab6			 
1ab6 7e				ld a,(hl) 
1ab7 fe 22			cp '"' 
1ab9 28 0a			jr z, .fapstr 
1abb fe 24			cp '$' 
1abd ca e5 1a			jp z, .faphex 
1ac0 fe 25			cp '%' 
1ac2 ca cd 1a			jp z, .fapbin 
1ac5			;	cp 'b' 
1ac5			;	jp z, .fabin 
1ac5				; else decimal 
1ac5			 
1ac5				; TODO do decimal conversion 
1ac5				; decimal is stored as a 16bit word 
1ac5			 
1ac5				; by default everything is a string if type is not detected 
1ac5			.fapstr: ; 
1ac5 fe 22			cp '"' 
1ac7 20 01			jr nz, .strnoqu 
1ac9 23				inc hl 
1aca			.strnoqu: 
1aca c3 80 1a			jp forth_push_str 
1acd			 
1acd			 
1acd			 
1acd			.fapbin:    ; push a binary string.  
1acd 11 00 00			ld de, 0   ; hold a 16bit value 
1ad0			 
1ad0 23			.fapbinshift:	inc hl  
1ad1 7e				ld a,(hl) 
1ad2 fe 00			cp 0     ; done scanning  
1ad4 28 0b			jr z, .fapbdone  	; got it in HL so push  
1ad6			 
1ad6				; left shift de 
1ad6 eb				ex de, hl	 
1ad7 29				add hl, hl 
1ad8			 
1ad8				; is 1 
1ad8 fe 31			cp '1' 
1ada 20 02			jr nz, .binzero 
1adc cb 4d			bit 1, l 
1ade			.binzero: 
1ade eb				ex de, hl	 ; save current de 
1adf 18 ef			jr .fapbinshift 
1ae1			 
1ae1			.fapbdone: 
1ae1 eb				ex de, hl 
1ae2 c3 6e 1a			jp forth_push_numhl 
1ae5			 
1ae5			 
1ae5			.faphex:   ; hex is always stored as a 16bit word 
1ae5				; skip number prefix 
1ae5 23				inc hl 
1ae6				; turn ascii into number 
1ae6 cd 73 10			call get_word_hl	; ret 16bit word in hl 
1ae9			 
1ae9 c3 6e 1a			jp forth_push_numhl 
1aec			 
1aec 00				 nop 
1aed			 
1aed			.fabin:   ; TODO bin conversion 
1aed			 
1aed			 
1aed c9				ret 
1aee			 
1aee			 
1aee			; get either a string ptr or a 16bit word from the data stack 
1aee			 
1aee			FORTH_DSP: macro 
1aee				call macro_forth_dsp 
1aee				endm 
1aee			 
1aee			macro_forth_dsp: 
1aee				; data stack pointer points to current word on tos 
1aee			 
1aee 2a a5 f9			ld hl,(cli_data_sp) 
1af1			 
1af1				if DEBUG_FORTH_PUSH 
1af1						DMARK "DSP" 
1af1			 
1af1					call display_data_sp 
1af1				;call break_point_state 
1af1				;rst 030h 
1af1				CALLMONITOR 
1af1				endif 
1af1			 
1af1 c9				ret 
1af2			 
1af2			; return hl to start of value on stack 
1af2			 
1af2			FORTH_DSP_VALUE: macro 
1af2				call macro_forth_dsp_value 
1af2				endm 
1af2			 
1af2			macro_forth_dsp_value: 
1af2			 
1af2				FORTH_DSP 
1af2 cd ee 1a			call macro_forth_dsp 
1af5				endm 
# End of macro FORTH_DSP
1af5			 
1af5 d5				push de 
1af6			 
1af6 23				inc hl ; skip type 
1af7			 
1af7 5e				ld e, (hl) 
1af8 23				inc hl 
1af9 56				ld d, (hl) 
1afa eb				ex de,hl  
1afb			 
1afb d1				pop de 
1afc			 
1afc c9				ret 
1afd			 
1afd			; return hl to start of value to second item on stack 
1afd			 
1afd			FORTH_DSP_VALUEM1: macro 
1afd				call macro_forth_dsp_value_m1 
1afd				endm 
1afd			 
1afd			macro_forth_dsp_value_m1: 
1afd			 
1afd				FORTH_DSP 
1afd cd ee 1a			call macro_forth_dsp 
1b00				endm 
# End of macro FORTH_DSP
1b00			 
1b00 2b				dec hl 
1b01 2b				dec hl 
1b02			;	dec hl 
1b02			 
1b02 d5				push de 
1b03			 
1b03 5e				ld e, (hl) 
1b04 23				inc hl 
1b05 56				ld d, (hl) 
1b06 eb				ex de,hl  
1b07			 
1b07 d1				pop de 
1b08			 
1b08 c9				ret 
1b09			 
1b09				 
1b09			 
1b09			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1b09			 
1b09			FORTH_DSP_POP: macro 
1b09				call macro_forth_dsp_pop 
1b09				endm 
1b09			 
1b09			 
1b09			; get the tos data type 
1b09			 
1b09			FORTH_DSP_TYPE:   macro 
1b09			 
1b09				;FORTH_DSP_VALUE 
1b09				FORTH_DSP 
1b09				 
1b09				; hl points to value 
1b09				; check type 
1b09			 
1b09				ld a,(hl) 
1b09			 
1b09				endm 
1b09			 
1b09			; load the tos value into hl 
1b09			 
1b09			 
1b09			FORTH_DSP_VALUEHL:  macro 
1b09				call macro_dsp_valuehl 
1b09				endm 
1b09			 
1b09			 
1b09			 
1b09			macro_dsp_valuehl: 
1b09				FORTH_DSP_VALUE 
1b09 cd f2 1a			call macro_forth_dsp_value 
1b0c				endm 
# End of macro FORTH_DSP_VALUE
1b0c			 
1b0c				;FORTH_ERR_TOS_NOTNUM 
1b0c			 
1b0c				;inc hl   ; skip type id 
1b0c			 
1b0c			;	push de 
1b0c			; 
1b0c			;	ld e, (hl) 
1b0c			;	inc hl 
1b0c			;	ld d, (hl) 
1b0c			;	ex de,hl  
1b0c			 
1b0c			;	pop de 
1b0c			 
1b0c				if DEBUG_FORTH_PUSH 
1b0c						DMARK "DVL" 
1b0c				CALLMONITOR 
1b0c				endif 
1b0c c9				ret 
1b0d			 
1b0d			forth_apushstrhl:      
1b0d				; push of string requires use of cli_origptr 
1b0d				; bodge use 
1b0d			 
1b0d				; get current cli_origptr, save, update with temp pointer  
1b0d ed 5b c1 f9		ld de, (cli_origptr) 
1b11 22 c1 f9			ld (cli_origptr), hl 
1b14 d5				push de 
1b15 cd b6 1a			call forth_apush 
1b18 d1				pop de 
1b19 ed 53 c1 f9		ld (cli_origptr), de 
1b1d c9			        ret	 
1b1e			 
1b1e			 
1b1e			; increase loop stack pointer and save hl to it 
1b1e				 
1b1e			FORTH_LOOP_NEXT: macro 
1b1e				call macro_forth_loop_next 
1b1e				;nop 
1b1e				endm 
1b1e			 
1b1e			macro_forth_loop_next: 
1b1e				if DEBUG_FORTH_STACK_GUARD 
1b1e cd 7c 5f				call check_stacks 
1b21				endif 
1b21 e5				push hl 
1b22 d5				push de 
1b23 eb				ex de,hl 
1b24 2a a7 f9			ld hl,(cli_loop_sp) 
1b27 23				inc hl 
1b28 23				inc hl 
1b29					if DEBUG_FORTH_WORDS 
1b29						DMARK "LNX" 
1b29 f5				push af  
1b2a 3a 3e 1b			ld a, (.dmark)  
1b2d 32 bd fb			ld (debug_mark),a  
1b30 3a 3f 1b			ld a, (.dmark+1)  
1b33 32 be fb			ld (debug_mark+1),a  
1b36 3a 40 1b			ld a, (.dmark+2)  
1b39 32 bf fb			ld (debug_mark+2),a  
1b3c 18 03			jr .pastdmark  
1b3e ..			.dmark: db "LNX"  
1b41 f1			.pastdmark: pop af  
1b42			endm  
# End of macro DMARK
1b42						CALLMONITOR 
1b42 cd d4 14			call break_point_state  
1b45				endm  
# End of macro CALLMONITOR
1b45					endif 
1b45 22 a7 f9			ld (cli_loop_sp),hl 
1b48 73				ld (hl), e 
1b49 23				inc hl 
1b4a 72				ld (hl), d 
1b4b d1				pop de    ; been reversed so save a swap on restore 
1b4c e1				pop hl 
1b4d				if DEBUG_FORTH_STACK_GUARD 
1b4d cd 7c 5f				call check_stacks 
1b50				endif 
1b50 c9				ret 
1b51			 
1b51			; get current ret stack pointer and save to hl  
1b51				 
1b51			FORTH_LOOP_TOS: macro 
1b51				call macro_forth_loop_tos 
1b51				endm 
1b51			 
1b51			macro_forth_loop_tos: 
1b51 d5				push de 
1b52 2a a7 f9			ld hl,(cli_loop_sp) 
1b55 5e				ld e, (hl) 
1b56 23				inc hl 
1b57 56				ld d, (hl) 
1b58 eb				ex de, hl 
1b59 d1				pop de 
1b5a c9				ret 
1b5b			 
1b5b			; pop loop stack pointer 
1b5b				 
1b5b			FORTH_LOOP_POP: macro 
1b5b				call macro_forth_loop_pop 
1b5b				endm 
1b5b			 
1b5b			 
1b5b			macro_forth_loop_pop: 
1b5b				if DEBUG_FORTH_STACK_GUARD 
1b5b					DMARK "LPP" 
1b5b f5				push af  
1b5c 3a 70 1b			ld a, (.dmark)  
1b5f 32 bd fb			ld (debug_mark),a  
1b62 3a 71 1b			ld a, (.dmark+1)  
1b65 32 be fb			ld (debug_mark+1),a  
1b68 3a 72 1b			ld a, (.dmark+2)  
1b6b 32 bf fb			ld (debug_mark+2),a  
1b6e 18 03			jr .pastdmark  
1b70 ..			.dmark: db "LPP"  
1b73 f1			.pastdmark: pop af  
1b74			endm  
# End of macro DMARK
1b74 cd 7c 5f				call check_stacks 
1b77					FORTH_CHK_LOOP_UNDER 
1b77 e5				push hl 
1b78 d5				push de 
1b79 2a a7 f9			ld hl,(cli_loop_sp) 
1b7c 11 21 f7			ld de, cli_loop_stack 
1b7f cd da 0c			call cmp16 
1b82 da 96 60			jp c, fault_loop_under 
1b85 d1				pop de 
1b86 e1				pop hl 
1b87				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1b87				endif 
1b87 e5				push hl 
1b88 2a a7 f9			ld hl,(cli_loop_sp) 
1b8b 2b				dec hl 
1b8c 2b				dec hl 
1b8d 22 a7 f9			ld (cli_loop_sp), hl 
1b90				; TODO do stack underflow checks 
1b90 e1				pop hl 
1b91				if DEBUG_FORTH_STACK_GUARD 
1b91 cd 7c 5f				call check_stacks 
1b94					FORTH_CHK_LOOP_UNDER 
1b94 e5				push hl 
1b95 d5				push de 
1b96 2a a7 f9			ld hl,(cli_loop_sp) 
1b99 11 21 f7			ld de, cli_loop_stack 
1b9c cd da 0c			call cmp16 
1b9f da 96 60			jp c, fault_loop_under 
1ba2 d1				pop de 
1ba3 e1				pop hl 
1ba4				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ba4				endif 
1ba4 c9				ret 
1ba5			 
1ba5			macro_forth_dsp_pop: 
1ba5			 
1ba5 e5				push hl 
1ba6			 
1ba6				; release malloc data 
1ba6			 
1ba6				if DEBUG_FORTH_STACK_GUARD 
1ba6 cd 7c 5f				call check_stacks 
1ba9					FORTH_CHK_DSP_UNDER 
1ba9 e5				push hl 
1baa d5				push de 
1bab 2a a5 f9			ld hl,(cli_data_sp) 
1bae 11 1f f5			ld de, cli_data_stack 
1bb1 cd da 0c			call cmp16 
1bb4 da 8a 60			jp c, fault_dsp_under 
1bb7 d1				pop de 
1bb8 e1				pop hl 
1bb9				endm 
# End of macro FORTH_CHK_DSP_UNDER
1bb9				endif 
1bb9				;ld hl,(cli_data_sp) 
1bb9			if DEBUG_FORTH_DOT 
1bb9				DMARK "DPP" 
1bb9				CALLMONITOR 
1bb9			endif	 
1bb9			 
1bb9			 
1bb9			if FORTH_ENABLE_DSPPOPFREE 
1bb9			 
1bb9				FORTH_DSP 
1bb9 cd ee 1a			call macro_forth_dsp 
1bbc				endm 
# End of macro FORTH_DSP
1bbc			 
1bbc 7e				ld a, (hl) 
1bbd fe 01			cp DS_TYPE_STR 
1bbf 20 07			jr nz, .skippopfree 
1bc1			 
1bc1				FORTH_DSP_VALUEHL 
1bc1 cd 09 1b			call macro_dsp_valuehl 
1bc4				endm 
# End of macro FORTH_DSP_VALUEHL
1bc4 00				nop 
1bc5			if DEBUG_FORTH_DOT 
1bc5				DMARK "DPf" 
1bc5				CALLMONITOR 
1bc5			endif	 
1bc5 cd 4d 12			call free 
1bc8			.skippopfree: 
1bc8				 
1bc8			 
1bc8			endif 
1bc8			 
1bc8			if DEBUG_FORTH_DOT_KEY 
1bc8				DMARK "DP2" 
1bc8				CALLMONITOR 
1bc8			endif	 
1bc8			 
1bc8				; move pointer down 
1bc8			 
1bc8 2a a5 f9			ld hl,(cli_data_sp) 
1bcb 2b				dec hl 
1bcc 2b				dec hl 
1bcd			; PARSEV5 
1bcd 2b				dec hl 
1bce 22 a5 f9			ld (cli_data_sp), hl 
1bd1			 
1bd1				if DEBUG_FORTH_STACK_GUARD 
1bd1 cd 7c 5f				call check_stacks 
1bd4					FORTH_CHK_DSP_UNDER 
1bd4 e5				push hl 
1bd5 d5				push de 
1bd6 2a a5 f9			ld hl,(cli_data_sp) 
1bd9 11 1f f5			ld de, cli_data_stack 
1bdc cd da 0c			call cmp16 
1bdf da 8a 60			jp c, fault_dsp_under 
1be2 d1				pop de 
1be3 e1				pop hl 
1be4				endm 
# End of macro FORTH_CHK_DSP_UNDER
1be4				endif 
1be4			 
1be4 e1				pop hl 
1be5			 
1be5 c9				ret 
1be6			 
1be6			getwordathl: 
1be6				; hl points to an address 
1be6				; load hl with the word at that address 
1be6			 
1be6 d5				push de 
1be7			 
1be7 5e				ld e, (hl) 
1be8 23				inc hl 
1be9 56				ld d, (hl) 
1bea eb				ex de, hl 
1beb			 
1beb d1				pop de 
1bec c9				ret 
1bed			 
1bed			 
1bed			 
1bed			 
1bed			 
1bed			; eof 
1bed			 
# End of file forth_stackopsv5.asm
1bed			endif 
1bed			 
1bed			user_word_eol:  
1bed				; hl contains the pointer to where to create a linked list item from the end 
1bed				; of the user dict to continue on at the system word dict 
1bed				 
1bed				; poke the stub of the word list linked list to repoint to rom words 
1bed			 
1bed				; stub format 
1bed				; db   word id 
1bed				; dw    link to next word 
1bed			        ; db char length of token 
1bed				; db string + 0 term 
1bed				; db exec code....  
1bed			 
1bed 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1bef 77				ld (hl), a		; word id 
1bf0 23				inc hl 
1bf1			 
1bf1 11 b7 1d			ld de, sysdict 
1bf4 73				ld (hl), e		; next word link ie system dict 
1bf5 23				inc hl 
1bf6 72				ld (hl), d		; next word link ie system dict 
1bf7 23				inc hl	 
1bf8			 
1bf8			;	ld (hl), sysdict		; next word link ie system dict 
1bf8			;	inc hl 
1bf8			;	inc hl 
1bf8			 
1bf8			;	inc hl 
1bf8			;	inc hl 
1bf8			 
1bf8 3e 02			ld a, 2			; word length is 0 
1bfa 77				ld (hl), a	 
1bfb 23				inc hl 
1bfc			 
1bfc 3e 7e			ld a, '~'			; word length is 0 
1bfe 77				ld (hl), a	 
1bff 23				inc hl 
1c00 3e 00			ld a, 0			; save empty word 
1c02 77				ld (hl), a 
1c03			 
1c03 c9				ret 
1c04			 
1c04				 
1c04			 
1c04			forthexec_cleanup: 
1c04				FORTH_RSP_POP 
1c04 cd 36 1a			call macro_forth_rsp_pop 
1c07				endm 
# End of macro FORTH_RSP_POP
1c07 c9				ret 
1c08			 
1c08			forth_call_hl: 
1c08				; taking hl 
1c08 e5				push hl 
1c09 c9				ret 
1c0a			 
1c0a			; this is called to reset Forth system but keep existing uwords etc 
1c0a			 
1c0a			forth_warmstart: 
1c0a				; setup stack over/under flow checks 
1c0a				if DEBUG_FORTH_STACK_GUARD 
1c0a cd 62 5f				call chk_stk_init 
1c0d				endif 
1c0d			 
1c0d				; init stack pointers  - * these stacks go upwards *  
1c0d 21 23 f9			ld hl, cli_ret_stack 
1c10 22 a9 f9			ld (cli_ret_sp), hl	 
1c13				; set bottom of stack 
1c13 3e 00			ld a,0 
1c15 77				ld (hl),a 
1c16 23				inc hl 
1c17 77				ld (hl),a 
1c18			 
1c18 21 1f f5			ld hl, cli_data_stack 
1c1b 22 a5 f9			ld (cli_data_sp), hl	 
1c1e				; set bottom of stack 
1c1e 3e 00			ld a,0 
1c20 77				ld (hl),a 
1c21 23				inc hl 
1c22 77				ld (hl),a 
1c23			 
1c23 21 21 f7			ld hl, cli_loop_stack 
1c26 22 a7 f9			ld (cli_loop_sp), hl	 
1c29				; set bottom of stack 
1c29 3e 00			ld a,0 
1c2b 77				ld (hl),a 
1c2c 23				inc hl 
1c2d 77				ld (hl),a 
1c2e			 
1c2e				; init extent of current open file 
1c2e			 
1c2e 3e 00			ld a, 0 
1c30 32 df f9			ld (store_openext), a 
1c33			 
1c33 c9				ret 
1c34			 
1c34			 
1c34			; Cold Start - this is called to setup the whole Forth system 
1c34			 
1c34			forth_init: 
1c34			 
1c34				; setup stack over/under flow checks 
1c34			 
1c34			;	if DEBUG_FORTH_STACK_GUARD 
1c34			;		call chk_stk_init 
1c34			;	endif 
1c34			 
1c34				; enable auto display updates (slow.....) 
1c34			 
1c34 3e 01			ld a, 1 
1c36 32 bf f9			ld (cli_autodisplay), a 
1c39			 
1c39			 
1c39			 
1c39				; show start up screen 
1c39			 
1c39 cd 8c 0a			call clear_display 
1c3c			 
1c3c 3e 00			ld a,0 
1c3e 32 e1 f9			ld (f_cursor_ptr), a 
1c41			 
1c41				; set start of word list in start of ram - for use when creating user words 
1c41			 
1c41 21 00 80			ld hl, baseram 
1c44 22 b5 f2			ld (os_last_new_uword), hl 
1c47 cd ed 1b			call user_word_eol 
1c4a				 
1c4a			;		call display_data_sp 
1c4a			;		call next_page_prompt 
1c4a			 
1c4a			 
1c4a			 
1c4a			 
1c4a c9				ret 
1c4b			 
1c4b .. 00		.bootforth: db " Forth Kernel Init ",0 
1c5f			 
1c5f			; TODO push to stack 
1c5f			 
1c5f			;  
1c5f			 
1c5f			if FORTH_PARSEV2 
1c5f			 
1c5f			 
1c5f				include "forth_parserv2.asm" 
1c5f			 
1c5f			endif 
1c5f			 
1c5f			 
1c5f			; parse cli version 1 
1c5f			 
1c5f			if FORTH_PARSEV1 
1c5f			 
1c5f			 
1c5f			 
1c5f			      include "forth_parserv1.asm" 
1c5f			endif 
1c5f				 
1c5f			if FORTH_PARSEV3 
1c5f			 
1c5f			 
1c5f			 
1c5f			      include "forth_parserv3.asm" 
1c5f				include "forth_wordsv3.asm" 
1c5f			endif 
1c5f			 
1c5f			if FORTH_PARSEV4 
1c5f			 
1c5f			 
1c5f			 
1c5f			      include "forth_parserv4.asm" 
1c5f				include "forth_wordsv4.asm" 
1c5f			endif 
1c5f			 
1c5f			if FORTH_PARSEV5 
1c5f			 
1c5f			 
1c5f			 
1c5f			      include "forth_parserv5.asm" 
1c5f			 
1c5f			 
1c5f			; A better parser without using malloc and string copies all over the place.  
1c5f			; Exec in situ should be faster 
1c5f			 
1c5f			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1c5f			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1c5f			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1c5f			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1c5f			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1c5f			WORD_SYS_END: equ 0   ; Opcode for all user words 
1c5f			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1c5f			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1c5f			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1c5f			 
1c5f			; Core word preamble macro 
1c5f			 
1c5f			CWHEAD:   macro nxtword opcode lit len opflags 
1c5f				db WORD_SYS_CORE+opcode             
1c5f				; internal op code number 
1c5f				dw nxtword            
1c5f				; link to next dict word block 
1c5f				db len + 1 
1c5f				; literal length of dict word inc zero term 
1c5f				db lit,0              
1c5f				; literal dict word 
1c5f			        ; TODO db opflags        
1c5f				endm 
1c5f			 
1c5f			 
1c5f			NEXTW: macro  
1c5f				jp macro_next 
1c5f				endm 
1c5f			 
1c5f			macro_next: 
1c5f			if DEBUG_FORTH_PARSE_KEY 
1c5f				DMARK "NXT" 
1c5f				CALLMONITOR 
1c5f			endif	 
1c5f			;	inc hl  ; skip token null term  
1c5f ed 4b c3 f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1c63 ed 5b c1 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1c67 2a b9 f2			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1c6a			if DEBUG_FORTH_PARSE_KEY 
1c6a				DMARK "}AA" 
1c6a				CALLMONITOR 
1c6a			endif	 
1c6a c3 6d 1d			jp execnext 
1c6d				;jp exec1 
1c6d			       
1c6d			 
1c6d			 
1c6d			; Another go at the parser to compile  
1c6d			 
1c6d			 
1c6d			; TODO rework parser to change all of the string words to byte tokens 
1c6d			; TODO do a search for  
1c6d			 
1c6d			; TODO first run normal parser to zero term sections 
1c6d			; TODO for each word do a token look up to get the op code 
1c6d			; TODO need some means to flag to the exec that this is a byte code form    
1c6d			 
1c6d			 
1c6d			forthcompile: 
1c6d			 
1c6d			; 
1c6d			; line parse: 
1c6d			;       parse raw input buffer 
1c6d			;       tokenise the words 
1c6d			;       malloc new copy (for looping etc) 
1c6d			;       copy to malloc + current pc in line to start of string and add line term 
1c6d			;       save on new rsp 
1c6d			; 
1c6d			 
1c6d			; hl to point to the line to tokenise 
1c6d			 
1c6d			;	push hl 
1c6d 22 b9 f2			ld (os_tok_ptr), hl  ; save ptr to string 
1c70			 
1c70			;	ld a,0		; string term on input 
1c70			;	call strlent 
1c70			 
1c70			;	ld (os_tok_len), hl	 ; save string length 
1c70			 
1c70			;if DEBUG_FORTH_TOK 
1c70			;	ex de,hl		 
1c70			;endif 
1c70			 
1c70			;	pop hl 		; get back string pointer 
1c70			 
1c70			if DEBUG_FORTH_TOK 
1c70						DMARK "TOc" 
1c70				CALLMONITOR 
1c70			endif 
1c70 7e			.cptoken2:    ld a,(hl) 
1c71 23				inc hl 
1c72 fe 7f			cp FORTH_END_BUFFER 
1c74 28 29			jr z, .cptokendone2 
1c76 fe 00			cp 0 
1c78 28 25			jr z, .cptokendone2 
1c7a fe 22			cp '"' 
1c7c 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1c7e fe 20			cp ' ' 
1c80 20 ee			jr nz,  .cptoken2 
1c82			 
1c82			; TODO consume comments held between ( and ) 
1c82			 
1c82				; we have a space so change to zero term for dict match later 
1c82 2b				dec hl 
1c83 3e 00			ld a,0 
1c85 77				ld (hl), a 
1c86 23				inc hl 
1c87 18 e7			jr .cptoken2 
1c89				 
1c89			 
1c89			.cptokenstr2: 
1c89				; skip all white space until either eol (because forgot to term) or end double quote 
1c89			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1c89				;inc hl ; skip current double quote 
1c89 7e				ld a,(hl) 
1c8a 23				inc hl 
1c8b fe 22			cp '"' 
1c8d 28 e1			jr z, .cptoken2 
1c8f fe 7f			cp FORTH_END_BUFFER 
1c91 28 0c			jr z, .cptokendone2 
1c93 fe 00			cp 0 
1c95 28 08			jr z, .cptokendone2 
1c97 fe 20			cp ' ' 
1c99 28 02			jr z, .cptmp2 
1c9b 18 ec			jr .cptokenstr2 
1c9d			 
1c9d			.cptmp2:	; we have a space so change to zero term for dict match later 
1c9d				;dec hl 
1c9d				;ld a,"-"	; TODO remove this when working 
1c9d				;ld (hl), a 
1c9d				;inc hl 
1c9d 18 ea			jr .cptokenstr2 
1c9f			 
1c9f			.cptokendone2: 
1c9f				;inc hl 
1c9f 3e 7f			ld a, FORTH_END_BUFFER 
1ca1 77				ld (hl),a 
1ca2 23				inc hl 
1ca3 3e 21			ld a, '!' 
1ca5 77				ld (hl),a 
1ca6			 
1ca6 2a b9 f2			ld hl,(os_tok_ptr) 
1ca9			         
1ca9			if DEBUG_FORTH_TOK 
1ca9						DMARK "Tc1" 
1ca9				CALLMONITOR 
1ca9			endif 
1ca9			 
1ca9				; push exec string to top of return stack 
1ca9				FORTH_RSP_NEXT 
1ca9 cd 15 1a			call macro_forth_rsp_next 
1cac				endm 
# End of macro FORTH_RSP_NEXT
1cac c9				ret 
1cad			 
1cad			; Another go at the parser need to simplify the process 
1cad			 
1cad			forthparse: 
1cad			 
1cad			; 
1cad			; line parse: 
1cad			;       parse raw input buffer 
1cad			;       tokenise the words 
1cad			;       malloc new copy (for looping etc) 
1cad			;       copy to malloc + current pc in line to start of string and add line term 
1cad			;       save on new rsp 
1cad			; 
1cad			 
1cad			; hl to point to the line to tokenise 
1cad			 
1cad			;	push hl 
1cad 22 b9 f2			ld (os_tok_ptr), hl  ; save ptr to string 
1cb0			 
1cb0			;	ld a,0		; string term on input 
1cb0			;	call strlent 
1cb0			 
1cb0			;	ld (os_tok_len), hl	 ; save string length 
1cb0			 
1cb0			;if DEBUG_FORTH_TOK 
1cb0			;	ex de,hl		 
1cb0			;endif 
1cb0			 
1cb0			;	pop hl 		; get back string pointer 
1cb0			 
1cb0			if DEBUG_FORTH_TOK 
1cb0						DMARK "TOK" 
1cb0				CALLMONITOR 
1cb0			endif 
1cb0 7e			.ptoken2:    ld a,(hl) 
1cb1 23				inc hl 
1cb2 fe 7f			cp FORTH_END_BUFFER 
1cb4 28 29			jr z, .ptokendone2 
1cb6 fe 00			cp 0 
1cb8 28 25			jr z, .ptokendone2 
1cba fe 22			cp '"' 
1cbc 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1cbe fe 20			cp ' ' 
1cc0 20 ee			jr nz,  .ptoken2 
1cc2			 
1cc2			; TODO consume comments held between ( and ) 
1cc2			 
1cc2				; we have a space so change to zero term for dict match later 
1cc2 2b				dec hl 
1cc3 3e 00			ld a,0 
1cc5 77				ld (hl), a 
1cc6 23				inc hl 
1cc7 18 e7			jr .ptoken2 
1cc9				 
1cc9			 
1cc9			.ptokenstr2: 
1cc9				; skip all white space until either eol (because forgot to term) or end double quote 
1cc9			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1cc9				;inc hl ; skip current double quote 
1cc9 7e				ld a,(hl) 
1cca 23				inc hl 
1ccb fe 22			cp '"' 
1ccd 28 e1			jr z, .ptoken2 
1ccf fe 7f			cp FORTH_END_BUFFER 
1cd1 28 0c			jr z, .ptokendone2 
1cd3 fe 00			cp 0 
1cd5 28 08			jr z, .ptokendone2 
1cd7 fe 20			cp ' ' 
1cd9 28 02			jr z, .ptmp2 
1cdb 18 ec			jr .ptokenstr2 
1cdd			 
1cdd			.ptmp2:	; we have a space so change to zero term for dict match later 
1cdd				;dec hl 
1cdd				;ld a,"-"	; TODO remove this when working 
1cdd				;ld (hl), a 
1cdd				;inc hl 
1cdd 18 ea			jr .ptokenstr2 
1cdf			 
1cdf			.ptokendone2: 
1cdf				;inc hl 
1cdf 3e 7f			ld a, FORTH_END_BUFFER 
1ce1 77				ld (hl),a 
1ce2 23				inc hl 
1ce3 3e 21			ld a, '!' 
1ce5 77				ld (hl),a 
1ce6			 
1ce6 2a b9 f2			ld hl,(os_tok_ptr) 
1ce9			         
1ce9			if DEBUG_FORTH_TOK 
1ce9						DMARK "TK1" 
1ce9				CALLMONITOR 
1ce9			endif 
1ce9			 
1ce9				; push exec string to top of return stack 
1ce9				FORTH_RSP_NEXT 
1ce9 cd 15 1a			call macro_forth_rsp_next 
1cec				endm 
# End of macro FORTH_RSP_NEXT
1cec c9				ret 
1ced			 
1ced			; 
1ced			;	; malloc size + buffer pointer + if is loop flag 
1ced			;	ld hl,(os_tok_len) 		 ; get string length 
1ced			; 
1ced			;	ld a,l 
1ced			; 
1ced			;	cp 0			; we dont want to use a null string 
1ced			;	ret z 
1ced			; 
1ced			;;	add 3    ; prefix malloc with buffer for current word ptr 
1ced			; 
1ced			;	add 5     ; TODO when certain not over writing memory remove 
1ced			; 
1ced			;		 
1ced			; 
1ced			;if DEBUG_FORTH_TOK 
1ced			;			DMARK "TKE" 
1ced			;	CALLMONITOR 
1ced			;endif 
1ced			; 
1ced			;	ld l,a 
1ced			;	ld h,0 
1ced			;;	push hl   ; save required space for the copy later 
1ced			;	call malloc 
1ced			;if DEBUG_FORTH_TOK 
1ced			;			DMARK "TKM" 
1ced			;	CALLMONITOR 
1ced			;endif 
1ced			;	if DEBUG_FORTH_MALLOC_GUARD 
1ced			;		push af 
1ced			;		call ishlzero 
1ced			;;		ld a, l 
1ced			;;		add h 
1ced			;;		cp 0 
1ced			;		pop af 
1ced			;		 
1ced			;		call z,malloc_error 
1ced			;	endif 
1ced			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1ced			; 
1ced			; 
1ced			;if DEBUG_FORTH_TOK 
1ced			;			DMARK "TKR" 
1ced			;	CALLMONITOR 
1ced			;endif 
1ced			; 
1ced			;	FORTH_RSP_NEXT 
1ced			; 
1ced			;	;inc hl	 ; go past current buffer pointer 
1ced			;	;inc hl 
1ced			;	;inc hl   ; and past if loop flag 
1ced			;		; TODO Need to set flag  
1ced			; 
1ced			;	 
1ced			;	 
1ced			;	ex de,hl	; malloc is dest 
1ced			;	ld hl, (os_tok_len) 
1ced			;;	pop bc 
1ced			;	ld c, l                
1ced			;	ld b,0 
1ced			;	ld hl, (os_tok_ptr) 
1ced			; 
1ced			;if DEBUG_FORTH_TOK 
1ced			;			DMARK "TKT" 
1ced			;	CALLMONITOR 
1ced			;endif 
1ced			; 
1ced			;	; do str cpy 
1ced			; 
1ced			;	ldir      ; copy byte in hl to de 
1ced			; 
1ced			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1ced			; 
1ced			;if DEBUG_FORTH_TOK 
1ced			; 
1ced			;			DMARK "TKY" 
1ced			;	CALLMONITOR 
1ced			;endif 
1ced			;	;ld a,0 
1ced			;	;ld a,FORTH_END_BUFFER 
1ced			;	ex de, hl 
1ced			;	;dec hl			 ; go back over the space delim at the end of word 
1ced			;	;ld (hl),a 
1ced			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1ced			;	ld a,FORTH_END_BUFFER 
1ced			;	ld (hl),a 
1ced			;	inc hl 
1ced			;	ld a,FORTH_END_BUFFER 
1ced			;	ld (hl),a 
1ced			; 
1ced			;	; init the malloc area data 
1ced			;	; set pc for in current area 
1ced			;	;ld hl, (os_tok_malloc) 
1ced			;	;inc hl 
1ced			;	;inc hl 
1ced			;	;inc hl 
1ced			;	;ex de,hl 
1ced			;	;ld hl, (os_tok_malloc) 
1ced			;	;ld (hl),e 
1ced			;	;inc hl 
1ced			;	;ld (hl),d 
1ced			; 
1ced			; 
1ced			;	ld hl,(os_tok_malloc) 
1ced			;if DEBUG_FORTH_PARSE_KEY 
1ced			;			DMARK "TKU" 
1ced			;	CALLMONITOR 
1ced			;endif 
1ced			; 
1ced			;	ret 
1ced			 
1ced			forthexec: 
1ced			 
1ced			; line exec: 
1ced			; forth parser 
1ced			 
1ced			; 
1ced			;       get current exec line on rsp 
1ced			 
1ced				FORTH_RSP_TOS 
1ced cd 2c 1a			call macro_forth_rsp_tos 
1cf0				endm 
# End of macro FORTH_RSP_TOS
1cf0			 
1cf0			;       restore current pc - hl points to malloc of data 
1cf0			 
1cf0				;ld e, (hl) 
1cf0				;inc hl 
1cf0				;ld d, (hl) 
1cf0				;ex de,hl 
1cf0			 
1cf0			 
1cf0			exec1: 
1cf0 22 b9 f2			ld (os_tok_ptr), hl 
1cf3			 
1cf3				; copy our PC to working vars  
1cf3 22 c3 f9			ld (cli_ptr), hl 
1cf6 22 c1 f9			ld (cli_origptr), hl 
1cf9			 
1cf9 7e				ld a,(hl) 
1cfa fe 7f			cp FORTH_END_BUFFER 
1cfc c8				ret z 
1cfd			 
1cfd				; skip any nulls 
1cfd			 
1cfd fe 00			cp 0 
1cff 20 03			jr nz, .execword 
1d01 23				inc hl 
1d02 18 ec			jr exec1 
1d04			 
1d04			 
1d04			.execword: 
1d04			 
1d04			 
1d04			 
1d04			if DEBUG_FORTH_PARSE_KEY 
1d04						DMARK "KYQ" 
1d04				CALLMONITOR 
1d04			endif 
1d04			;       while at start of word: 
1d04			; get start of dict (in user area first) 
1d04			 
1d04 21 00 80		ld hl, baseram 
1d07			;ld hl, sysdict 
1d07 22 c5 f9		ld (cli_nextword),hl 
1d0a			;           match word at pc 
1d0a			;           exec word 
1d0a			;           or push to dsp 
1d0a			;           forward to next token 
1d0a			;           if line term pop rsp and exit 
1d0a			;        
1d0a			 
1d0a			if DEBUG_FORTH_PARSE_KEY 
1d0a						DMARK "KYq" 
1d0a				CALLMONITOR 
1d0a			endif 
1d0a			 
1d0a			; 
1d0a			; word comp 
1d0a			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1d0a			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1d0a			;    move to start of word  
1d0a			;    compare word to cli_token 
1d0a			 
1d0a			.execpnword:	; HL at start of a word in the dictionary to check 
1d0a			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1d0a			;	ld (cli_ptr), hl 
1d0a			 
1d0a 2a c5 f9			ld hl,(cli_nextword) 
1d0d			 
1d0d cd b0 1d			call forth_tok_next 
1d10			; tok next start here 
1d10			;	; TODO skip compiled symbol for now 
1d10			;	inc hl 
1d10			; 
1d10			;	; save pointer to next word 
1d10			; 
1d10			;	; hl now points to the address of the next word pointer  
1d10			;	ld e, (hl) 
1d10			;	inc hl 
1d10			;	ld d, (hl) 
1d10			;	inc l 
1d10			; 
1d10			;	ex de,hl 
1d10			;if DEBUG_FORTH_PARSE_NEXTWORD 
1d10			;	push bc 
1d10			;	ld bc, (cli_nextword) 
1d10			;			DMARK "NXW" 
1d10			;	CALLMONITOR 
1d10			;	pop bc 
1d10			;endif 
1d10			; tok next end here 
1d10 22 c5 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
1d13 eb				ex de, hl 
1d14			 
1d14			 
1d14				; save the pointer of the current token - 1 to check against 
1d14				 
1d14 22 c9 f9			ld (cli_token), hl   
1d17				; TODO maybe remove below save if no debug 
1d17				; save token string ptr for any debug later 
1d17 23				inc hl  
1d18 22 cb f9			ld (cli_origtoken), hl 
1d1b 2b				dec hl 
1d1c				; save pointer to the start of the next dictionay word 
1d1c 7e				ld a,(hl)   ; get string length 
1d1d 47				ld b,a 
1d1e			.execpnwordinc:  
1d1e 23				inc hl 
1d1f 10 fd			djnz .execpnwordinc 
1d21 22 c7 f9			ld (cli_execword), hl      ; save start of this words code 
1d24			 
1d24				; now check the word token against the string being parsed 
1d24			 
1d24 2a c9 f9			ld hl,(cli_token) 
1d27 23				inc hl     ; skip string length (use zero term instead to end) 
1d28 22 c9 f9			ld (cli_token), hl 
1d2b			 
1d2b			if DEBUG_FORTH_PARSE_KEY 
1d2b						DMARK "KY2" 
1d2b			endif 
1d2b			if DEBUG_FORTH_PARSE_EXEC 
1d2b				; see if disabled 
1d2b			 
1d2b				ld a, (os_view_disable) 
1d2b				cp '*' 
1d2b				jr z, .skip 
1d2b			 
1d2b				push hl 
1d2b				push hl 
1d2b				call clear_display 
1d2b				ld de, .compword 
1d2b				ld a, display_row_1 
1d2b				call str_at_display 
1d2b				pop de 
1d2b				ld a, display_row_2 
1d2b				call str_at_display 
1d2b				ld hl,(cli_ptr) 
1d2b				ld a,(hl) 
1d2b			        ld hl, os_word_scratch 
1d2b				ld (hl),a 
1d2b				ld a,0 
1d2b				inc hl 
1d2b				ld (hl),a 	 
1d2b				ld de, os_word_scratch 
1d2b				ld a, display_row_2+10 
1d2b				call str_at_display 
1d2b				call update_display 
1d2b				ld a, 100 
1d2b				call aDelayInMS 
1d2b				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1d2b				call delay250ms 
1d2b				endif 
1d2b				pop hl 
1d2b			.skip:  
1d2b			endif	 
1d2b			.execpnchar:    ; compare char between token and string to parse 
1d2b			 
1d2b			if DEBUG_FORTH_PARSE_KEY 
1d2b						DMARK "Ky3" 
1d2b			endif 
1d2b			if DEBUG_FORTH_PARSE_EXEC 
1d2b				; see if disabled 
1d2b			 
1d2b				ld a, (os_view_disable) 
1d2b				cp '*' 
1d2b				jr z, .skip2 
1d2b			 
1d2b			;	call clear_display 
1d2b			ld hl,(cli_token) 
1d2b			ld a,(hl) 
1d2b			ld (os_word_scratch),a 
1d2b				ld hl,(cli_ptr) 
1d2b			ld a,(hl) 
1d2b				ld (os_word_scratch+1),a 
1d2b				ld a,0 
1d2b				ld (os_word_scratch+2),a 
1d2b				ld de,os_word_scratch 
1d2b				ld a,display_row_4 
1d2b				call str_at_display 
1d2b				call update_display 
1d2b			.skip2:  
1d2b			endif 
1d2b 2a c9 f9			ld hl,(cli_token) 
1d2e 7e				ld a, (hl)	 ; char in word token 
1d2f 23				inc hl 		; move to next char 
1d30 22 c9 f9			ld (cli_token), hl ; and save it 
1d33 47				ld b,a 
1d34			 
1d34 2a c3 f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
1d37 7e				ld a,(hl) 
1d38 23				inc hl 
1d39 22 c3 f9			ld (cli_ptr), hl		; move to next char 
1d3c cd 11 11			call toUpper 		; make sure the input string matches case 
1d3f			 
1d3f			if DEBUG_FORTH_PARSE 
1d3f			endif 
1d3f			 
1d3f				; input stream end of token is a space so get rid of it 
1d3f			 
1d3f			;	cp ' ' 
1d3f			;	jr nz, .pnskipspace 
1d3f			; 
1d3f			;	ld a, 0		; make same term as word token term 
1d3f			; 
1d3f			;.pnskipspace: 
1d3f			 
1d3f			if DEBUG_FORTH_PARSE_KEY 
1d3f						DMARK "KY7" 
1d3f			endif 
1d3f b8				cp b 
1d40 c2 56 1d			jp nz, .execpnskipword	 ; no match so move to next word 
1d43				 
1d43			;    if same 
1d43			;       scan for string terms 0 for token and 32 for input 
1d43			 
1d43				 
1d43			if DEBUG_FORTH_PARSE_KEY 
1d43						DMARK "KY8" 
1d43			endif 
1d43			 
1d43 80				add b			 
1d44 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1d46							; TODO need to make sure last word in zero term string is accounted for 
1d46 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1d48			 
1d48			 
1d48				; at end of both strings so both are exact match 
1d48			 
1d48			;       skip ptr for next word 
1d48			 
1d48 2a c3 f9			ld hl,(cli_ptr) 	; at input string term 
1d4b 23				inc hl			 ; at next char 
1d4c 22 c3 f9			ld (cli_ptr), hl     ; save for next round of the parser 
1d4f 22 c1 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1d52				 
1d52				 
1d52			if DEBUG_FORTH_PARSE_KEY 
1d52						DMARK "KY3" 
1d52			endif 
1d52			 
1d52			 
1d52			 
1d52			;       exec code block 
1d52			if DEBUG_FORTH_JP 
1d52				call clear_display 
1d52				call update_display 
1d52				call delay1s 
1d52				ld hl, (cli_execword)     ; save for next check if no match on this word 
1d52				ld a,h 
1d52				ld hl, os_word_scratch 
1d52				call hexout 
1d52				ld hl, (cli_execword)     ; save for next check if no match on this word 
1d52				ld a,l 
1d52				ld hl, os_word_scratch+2 
1d52				call hexout 
1d52				ld hl, os_word_scratch+4 
1d52				ld a,0 
1d52				ld (hl),a 
1d52				ld de,os_word_scratch 
1d52				call str_at_display 
1d52					ld a, display_row_2 
1d52					call str_at_display 
1d52				ld de, (cli_origtoken) 
1d52				ld a, display_row_1+10 
1d52					call str_at_display 
1d52			 
1d52				ld a,display_row_1 
1d52				ld de, .foundword 
1d52				ld a, display_row_3 
1d52				call str_at_display 
1d52				call update_display 
1d52				call delay1s 
1d52				call delay1s 
1d52				call delay1s 
1d52			endif 
1d52			 
1d52			if DEBUG_FORTH_PARSE_KEY 
1d52						DMARK "KYj" 
1d52			endif 
1d52				; TODO save the word pointer in this exec 
1d52			 
1d52 2a c7 f9			ld hl,(cli_execword) 
1d55 e9				jp (hl) 
1d56			 
1d56			 
1d56			;    if not same 
1d56			;	scan for zero term 
1d56			;	get ptr for next word 
1d56			;	goto word comp 
1d56			 
1d56			.execpnskipword:	; get pointer to next word 
1d56 2a c5 f9			ld hl,(cli_nextword) 
1d59			 
1d59 7e				ld a,(hl) 
1d5a fe 00			cp WORD_SYS_END 
1d5c			;	cp 0 
1d5c 28 09			jr z, .execendofdict			 ; at end of words 
1d5e			 
1d5e			if DEBUG_FORTH_PARSE_KEY 
1d5e						DMARK "KY4" 
1d5e			endif 
1d5e			if DEBUG_FORTH_PARSE_EXEC 
1d5e			 
1d5e				; see if disabled 
1d5e			 
1d5e				ld a, (os_view_disable) 
1d5e				cp '*' 
1d5e				jr z, .noskip 
1d5e			 
1d5e			 
1d5e				ld de, .nowordfound 
1d5e				ld a, display_row_3 
1d5e				call str_at_display 
1d5e				call update_display 
1d5e				ld a, 100 
1d5e				call aDelayInMS 
1d5e				 
1d5e				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1d5e					call delay250ms 
1d5e				endif 
1d5e			.noskip:  
1d5e			 
1d5e			endif	 
1d5e			 
1d5e 2a c1 f9			ld hl,(cli_origptr) 
1d61 22 c3 f9			ld (cli_ptr),hl 
1d64			 
1d64			if DEBUG_FORTH_PARSE_KEY 
1d64						DMARK "KY5" 
1d64			endif 
1d64 c3 0a 1d			jp .execpnword			; else go to next word 
1d67			 
1d67			.execendofdict:  
1d67			 
1d67			if DEBUG_FORTH_PARSE_KEY 
1d67						DMARK "KYe" 
1d67			endif 
1d67			if DEBUG_FORTH_PARSE_EXEC 
1d67				; see if disabled 
1d67			 
1d67				ld a, (os_view_disable) 
1d67				cp '*' 
1d67				jr z, .ispskip 
1d67			 
1d67				call clear_display 
1d67				call update_display 
1d67				call delay1s 
1d67				ld de, (cli_origptr) 
1d67				ld a, display_row_1 
1d67				call str_at_display 
1d67				 
1d67				ld de, .enddict 
1d67				ld a, display_row_3 
1d67				call str_at_display 
1d67				call update_display 
1d67				ld a, 100 
1d67				call aDelayInMS 
1d67				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1d67				call delay1s 
1d67				call delay1s 
1d67				call delay1s 
1d67				endif 
1d67			.ispskip:  
1d67				 
1d67			endif	 
1d67			 
1d67			 
1d67			 
1d67				; if the word is not a keyword then must be a literal so push it to stack 
1d67			 
1d67			; push token to stack to end of word 
1d67			 
1d67				STACKFRAME ON $1efe $2f9f 
1d67				if DEBUG_STACK_IMB 
1d67					if ON 
1d67						exx 
1d67						ld de, $1efe 
1d67						ld a, d 
1d67						ld hl, curframe 
1d67						call hexout 
1d67						ld a, e 
1d67						ld hl, curframe+2 
1d67						call hexout 
1d67						ld hl, $1efe 
1d67						push hl 
1d67						ld hl, $2f9f 
1d67						push hl 
1d67						exx 
1d67					endif 
1d67				endif 
1d67			endm 
# End of macro STACKFRAME
1d67			 
1d67 2a b9 f2		ld hl,(os_tok_ptr) 
1d6a cd b6 1a		call forth_apush 
1d6d			 
1d6d				STACKFRAMECHK ON $1efe $2f9f 
1d6d				if DEBUG_STACK_IMB 
1d6d					if ON 
1d6d						exx 
1d6d						ld hl, $2f9f 
1d6d						pop de   ; $2f9f 
1d6d						call cmp16 
1d6d						jr nz, .spnosame 
1d6d						ld hl, $1efe 
1d6d						pop de   ; $1efe 
1d6d						call cmp16 
1d6d						jr z, .spfrsame 
1d6d						.spnosame: call showsperror 
1d6d						.spfrsame: nop 
1d6d						exx 
1d6d					endif 
1d6d				endif 
1d6d			endm 
# End of macro STACKFRAMECHK
1d6d			 
1d6d			execnext: 
1d6d			 
1d6d			if DEBUG_FORTH_PARSE_KEY 
1d6d						DMARK "KY>" 
1d6d			endif 
1d6d			; move past token to next word 
1d6d			 
1d6d 2a b9 f2		ld hl, (os_tok_ptr) 
1d70 3e 00		ld a, 0 
1d72 01 ff 00		ld bc, 255     ; input buffer size 
1d75 ed b1		cpir 
1d77			 
1d77			if DEBUG_FORTH_PARSE_KEY 
1d77						DMARK "KY!" 
1d77				CALLMONITOR 
1d77			endif	 
1d77			; TODO this might place hl on the null, so will need to forward on??? 
1d77			;inc hl   ; see if this gets onto the next item 
1d77			 
1d77			 
1d77			; TODO pass a pointer to the buffer to push 
1d77			; TODO call function to push 
1d77			 
1d77			; look for end of input 
1d77			 
1d77			;inc hl 
1d77			;ld a,(hl) 
1d77			;cp FORTH_END_BUFFER 
1d77			;ret z 
1d77			 
1d77			 
1d77 c3 f0 1c		jp exec1 
1d7a			 
1d7a			 
1d7a			 
1d7a			 
1d7a			 
1d7a			 
1d7a			 
1d7a			 
1d7a			 
1d7a			findnexttok: 
1d7a			 
1d7a				; hl is pointer to move 
1d7a				; de is the token to locate 
1d7a			 
1d7a					if DEBUG_FORTH 
1d7a						DMARK "NTK" 
1d7a						CALLMONITOR 
1d7a					endif 
1d7a d5				push de 
1d7b			 
1d7b			.fnt1:	 
1d7b				; find first char of token to locate 
1d7b			 
1d7b 1a				ld a, (de) 
1d7c 4f				ld c,a 
1d7d 7e				ld a,(hl) 
1d7e cd 11 11			call toUpper 
1d81					if DEBUG_FORTH 
1d81						DMARK "NT1" 
1d81						CALLMONITOR 
1d81					endif 
1d81 b9				cp c 
1d82			 
1d82 28 03			jr z, .fnt2cmpmorefirst	 
1d84			 
1d84				; first char not found move to next char 
1d84			 
1d84 23				inc hl 
1d85 18 f4			jr .fnt1 
1d87			 
1d87			.fnt2cmpmorefirst:	 
1d87				; first char of token found.  
1d87			 
1d87 e5				push hl     ; save start of token just in case it is the right one 
1d88 d9				exx 
1d89 e1				pop hl        ; save it to hl' 
1d8a d9				exx 
1d8b			 
1d8b			 
1d8b			.fnt2cmpmore:	 
1d8b				; compare the rest 
1d8b				 
1d8b 23				inc hl 
1d8c 13				inc de 
1d8d				 
1d8d 1a				ld a, (de) 
1d8e 4f				ld c,a 
1d8f 7e				ld a,(hl) 
1d90 cd 11 11			call toUpper 
1d93			 
1d93					if DEBUG_FORTH 
1d93						DMARK "NT2" 
1d93						CALLMONITOR 
1d93					endif 
1d93				; c has the token to find char 
1d93				; a has the mem to scan char 
1d93			 
1d93 b9				cp c 
1d94 28 04			jr z,.fntmatch1 
1d96			 
1d96				; they are not the same 
1d96			 
1d96					if DEBUG_FORTH 
1d96						DMARK "NT3" 
1d96						CALLMONITOR 
1d96					endif 
1d96 d1				pop de	; reset de token to look for 
1d97 d5				push de 
1d98 18 e1			jr .fnt1 
1d9a				 
1d9a			.fntmatch1: 
1d9a			 
1d9a				; is the same char a null which means we might have a full hit? 
1d9a					if DEBUG_FORTH 
1d9a						DMARK "NT4" 
1d9a						CALLMONITOR 
1d9a					endif 
1d9a			 
1d9a fe 00			cp 0 
1d9c 28 0b			jr z, .fntmatchyes 
1d9e			 
1d9e				; are we at the end of the token to find? 
1d9e			 
1d9e					if DEBUG_FORTH 
1d9e						DMARK "NT5" 
1d9e						CALLMONITOR 
1d9e					endif 
1d9e 3e 00			ld a, 0 
1da0 b9				cp c 
1da1			 
1da1 c2 8b 1d			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1da4			 
1da4					if DEBUG_FORTH 
1da4						DMARK "NT6" 
1da4						CALLMONITOR 
1da4					endif 
1da4				; token to find is exhusted but no match to stream 
1da4			 
1da4				; restore tok pointer and continue on 
1da4 d1				pop de 
1da5 d5				push de 
1da6 c3 7b 1d			jp .fnt1 
1da9			 
1da9			 
1da9			.fntmatchyes: 
1da9			 
1da9				; hl now contains the end of the found token 
1da9			 
1da9				; get rid of saved token pointer to find 
1da9			 
1da9 d1				pop de 
1daa			 
1daa					if DEBUG_FORTH 
1daa						DMARK "NT9" 
1daa						CALLMONITOR 
1daa					endif 
1daa			 
1daa				; hl will be on the null term so forward on 
1daa			 
1daa				; get back the saved start of the token 
1daa			 
1daa d9				exx 
1dab e5				push hl     ; save start of token just in case it is the right one 
1dac d9				exx 
1dad e1				pop hl        ; save it to hl 
1dae			 
1dae c9				ret 
1daf			 
1daf			 
1daf			; LIST needs to find a specific token   
1daf			; FORGET needs to find a spefici token 
1daf			 
1daf			; SAVE needs to find all tokens by flag 
1daf			; WORDS just needs to scan through all  by flag 
1daf			; UWORDS needs to scan through all by flag 
1daf			 
1daf			 
1daf			; given hl as pointer to start of dict look up string 
1daf			; return hl as pointer to start of word block 
1daf			; or 0 if not found 
1daf			 
1daf			forth_find_tok: 
1daf c9				ret 
1db0			 
1db0			; given hl as pointer to dict structure 
1db0			; move to the next dict block structure 
1db0			 
1db0			forth_tok_next: 
1db0				; hl now points to the address of the next word pointer  
1db0				; TODO skip compiled symbol for now 
1db0			;	push de 
1db0 23				inc hl 
1db1 5e				ld e, (hl) 
1db2 23				inc hl 
1db3 56				ld d, (hl) 
1db4 23				inc hl 
1db5			 
1db5 eb				ex de,hl 
1db6			if DEBUG_FORTH_PARSE_NEXTWORD 
1db6				push bc 
1db6				ld bc, (cli_nextword) 
1db6						DMARK "NXW" 
1db6				CALLMONITOR 
1db6				pop bc 
1db6			endif 
1db6			;	pop de	 
1db6 c9				ret 
1db7			 
1db7			 
1db7			 
1db7			; eof 
# End of file forth_parserv5.asm
1db7				include "forth_wordsv4.asm" 
1db7			 
1db7			; the core word dictionary v4 
1db7			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1db7			 
1db7			; this is a linked list for each of the system words used 
1db7			; user defined words will follow the same format but will be in ram 
1db7			 
1db7			 
1db7			; 
1db7			; 
1db7			; define linked list: 
1db7			; 
1db7			; 1. compiled byte op code 
1db7			; 2. len of text word 
1db7			; 3. text word 
1db7			; 4. ptr to next dictionary word 
1db7			; 5. asm, calls etc for the word 
1db7			; 
1db7			;  if 1 == 0 then last word in dict  
1db7			;   
1db7			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1db7			;  
1db7			;  
1db7			; create basic standard set of words 
1db7			; 
1db7			;  
1db7			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1db7			; 2DUP 2DROP 2SWAP  
1db7			; @ C@ - get byte  
1db7			; ! C! - store byte 
1db7			; 0< true if less than zero 
1db7			; 0= true if zero 
1db7			; < >  
1db7			; = true if same 
1db7			; variables 
1db7			 
1db7			 
1db7			; Hardware specific words I may need 
1db7			; 
1db7			; IN OUT  
1db7			; calls to key util functions 
1db7			; calls to hardward abstraction stuff 
1db7			; easy control of frame buffers and lcd i/o 
1db7			; keyboard  
1db7			 
1db7			 
1db7			;DICT: macro 
1db7			; op_code, len, word, next 
1db7			;    word: 
1db7			;    db op_code 
1db7			;    ds word zero term 
1db7			;    dw next 
1db7			;    endm 
1db7			 
1db7			 
1db7			 
1db7			 
1db7			; op code 1 is a flag for user define words which are to be handled differently 
1db7			 
1db7			 
1db7			; 
1db7			; 
1db7			;    TODO on entry to a word this should be the expected environment 
1db7			;    hl - tos value if number then held, if string this is the ptr 
1db7			;    de -  
1db7			 
1db7			 
1db7			; opcode ranges 
1db7			; 0 - end of word dict 
1db7			; 255 - user define words 
1db7			 
1db7			sysdict: 
1db7			include "forth_opcodes.asm" 
1db7			; op codes for forth keywords 
1db7			; free to use code 0  
1db7				OPCODE_HEAP: equ  1 
1db7				OPCODE_EXEC: equ 2 
1db7				OPCODE_DUP: equ 3 
1db7				OPCODE_SWAP: equ 4 
1db7				OPCODE_COLN: equ 5 
1db7				OPCODE_SCOLN: equ 6 
1db7				OPCODE_DROP: equ 7 
1db7				OPCODE_DUP2: equ 8 
1db7				OPCODE_DROP2: equ 9 
1db7				OPCODE_SWAP2: equ 10 
1db7				OPCODE_AT: equ 11 
1db7				OPCODE_CAT: equ 12 
1db7				OPCODE_BANG: equ 13 
1db7				OPCODE_CBANG: equ 14 
1db7				OPCODE_SCALL: equ 15 
1db7				OPCODE_DEPTH: equ 16 
1db7				OPCODE_OVER: equ 17 
1db7				OPCODE_PAUSE: equ 18 
1db7				OPCODE_PAUSES: equ 19 
1db7				OPCODE_ROT: equ 20 
1db7			;free to reuse	OPCODE_WORDS: equ 21 
1db7			        OPCODE_NOT: equ 21 
1db7				OPCODE_UWORDS: equ 22 
1db7				OPCODE_BP: equ 23 
1db7				OPCODE_MONITOR: equ 24  
1db7				OPCODE_MALLOC: equ 25 
1db7				OPCODE_FREE: equ 26 
1db7				OPCODE_LIST: equ 27 
1db7				OPCODE_FORGET: equ 28 
1db7				OPCODE_NOP: equ 29 
1db7				OPCODE_COMO: equ 30 
1db7				OPCODE_COMC: equ 31 
1db7			;free to reuse	OPCODE_ENDCORE: equ 32 
1db7				OPCODE_AFTERSOUND: equ 33 
1db7				OPCODE_GP2: equ 34 
1db7				OPCODE_GP3: equ 35 
1db7				OPCODE_GP4: equ 36 
1db7				OPCODE_SIN: equ 37 
1db7				OPCODE_SOUT: equ 38 
1db7				OPCODE_SPIO: equ 39 
1db7				OPCODE_SPICEH: equ 40 
1db7				OPCODE_SPIOb: equ 41 
1db7				OPCODE_SPII: equ 42 
1db7				OPCODE_SESEL: equ 43 
1db7				OPCODE_CARTDEV: equ 44 
1db7			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1db7				OPCODE_FB: equ 46 
1db7				OPCODE_EMIT: equ 47 
1db7				OPCODE_DOTH: equ 48 
1db7				OPCODE_DOTF: equ 49 
1db7				OPCODE_DOT: equ 50 
1db7				OPCODE_CLS: equ 51 
1db7				OPCODE_DRAW: equ 52 
1db7				OPCODE_DUMP: equ 53 
1db7				OPCODE_CDUMP: equ 54 
1db7				OPCODE_DAT: equ 55 
1db7				OPCODE_HOME: equ 56 
1db7				OPCODE_SPACE: equ 57 
1db7				OPCODE_SPACES: equ 58 
1db7				OPCODE_SCROLL: equ 59 
1db7				OPCODE_ATQ: equ 60 
1db7				OPCODE_AUTODSP: equ 61 
1db7				OPCODE_MENU: equ 62 
1db7			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1db7				OPCODE_THEN: equ 64 
1db7				OPCODE_ELSE: equ 65 
1db7				OPCODE_DO: equ 66 
1db7				OPCODE_LOOP: equ 67 
1db7				OPCODE_I: equ 68 
1db7				OPCODE_DLOOP: equ 69  
1db7				OPCODE_REPEAT: equ 70  
1db7				OPCODE_UNTIL: equ 71 
1db7				OPCODE_ENDFLOW: equ 72 
1db7				OPCODE_WAITK: equ 73 
1db7				OPCODE_ACCEPT: equ 74 
1db7				OPCODE_EDIT: equ 75 
1db7			;free to reuse	OPCODE_ENDKEY: equ 76 
1db7				OPCODE_LZERO: equ 77 
1db7				OPCODE_TZERO: equ 78 
1db7				OPCODE_LESS: equ 79 
1db7				OPCODE_GT: equ 80 
1db7				OPCODE_EQUAL: equ 81  
1db7			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1db7				OPCODE_NEG: equ 83 
1db7				OPCODE_DIV: equ 84 
1db7				OPCODE_MUL: equ 85 
1db7				OPCODE_MIN: equ 86 
1db7				OPCODE_MAX: equ 87 
1db7				OPCODE_RND16: equ 88 
1db7				OPCODE_RND8: equ 89 
1db7				OPCODE_RND: equ 90 
1db7			;free to reuse	OPCODE_ENDMATHS: equ 91  
1db7				OPCODE_BYNAME: equ 92 
1db7				OPCODE_DIR: equ 93 
1db7				OPCODE_SAVE: equ 94 
1db7				OPCODE_LOAD: equ 95 
1db7				OPCODE_BSAVE: equ 96 
1db7				OPCODE_BLOAD: equ 97 
1db7				OPCODE_SEO: equ 98  
1db7				OPCODE_SEI: equ 99 
1db7				OPCODE_SFREE: equ 100 
1db7				OPCODE_SIZE: equ 101 
1db7				OPCODE_CREATE: equ 102 
1db7				OPCODE_APPEND: equ 103 
1db7				OPCODE_SDEL: equ 104 
1db7				OPCODE_OPEN: equ 105 
1db7				OPCODE_READ: equ 106 
1db7				OPCODE_EOF: equ 106 
1db7				OPCODE_FORMAT: equ 107 
1db7				OPCODE_LABEL: equ 108 
1db7				OPCODE_LABELS: equ 109 
1db7			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1db7				OPCODE_UPPER: equ 111 
1db7				OPCODE_LOWER: equ 112 
1db7				OPCODE_SUBSTR: equ 113 
1db7				OPCODE_LEFT: equ 114 
1db7				OPCODE_RIGHT: equ 115 
1db7				OPCODE_STR2NUM: equ 116 
1db7				OPCODE_NUM2STR: equ 117 
1db7				OPCODE_CONCAT: equ 118 
1db7				OPCODE_FIND: equ 119 
1db7				OPCODE_LEN: equ 120 
1db7				OPCODE_CHAR: equ 121 
1db7			; free to reuse	OPCODE_STRLEN: equ 122 
1db7			; free to reuse	OPCODE_ENDSTR: equ 123 
1db7				OPCODE_V0S: equ 124 
1db7				OPCODE_V0Q: equ 125 
1db7				OPCODE_V1S: equ 126 
1db7				OPCODE_V1Q: equ 127 
1db7				OPCODE_V2S: equ 128 
1db7				OPCODE_V2Q: equ 129 
1db7				OPCODE_V3S: equ 130 
1db7				OPCODE_V3Q: equ 131 
1db7			;free to reuse	OPCODE_END: equ 132 
1db7				OPCODE_ZDUP: equ 133 
1db7			 
1db7			; eof 
# End of file forth_opcodes.asm
1db7			 
1db7			include "forth_words_core.asm" 
1db7			 
1db7			; | ## Core Words 
1db7			 
1db7			;if MALLOC_4 
1db7			 
1db7			.HEAP: 
1db7				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1db7 15				db WORD_SYS_CORE+OPCODE_HEAP             
1db8 f6 1d			dw .EXEC            
1dba 05				db 4 + 1 
1dbb .. 00			db "HEAP",0              
1dc0				endm 
# End of macro CWHEAD
1dc0			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1dc0			; | | u1 - Current number of bytes in the heap 
1dc0			; | | u2 - Remaining bytes left on the heap 
1dc0			; | |  
1dc0			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1dc0			 
1dc0			 
1dc0					if DEBUG_FORTH_WORDS_KEY 
1dc0						DMARK "HEP" 
1dc0 f5				push af  
1dc1 3a d5 1d			ld a, (.dmark)  
1dc4 32 bd fb			ld (debug_mark),a  
1dc7 3a d6 1d			ld a, (.dmark+1)  
1dca 32 be fb			ld (debug_mark+1),a  
1dcd 3a d7 1d			ld a, (.dmark+2)  
1dd0 32 bf fb			ld (debug_mark+2),a  
1dd3 18 03			jr .pastdmark  
1dd5 ..			.dmark: db "HEP"  
1dd8 f1			.pastdmark: pop af  
1dd9			endm  
# End of macro DMARK
1dd9						CALLMONITOR 
1dd9 cd d4 14			call break_point_state  
1ddc				endm  
# End of macro CALLMONITOR
1ddc					endif 
1ddc 2a 0a 80				ld hl, (free_list )      
1ddf 11 0e 80				ld de, heap_start 
1de2			 
1de2 ed 52				sbc hl, de  
1de4			 
1de4 cd 6e 1a				call forth_push_numhl 
1de7			 
1de7			 
1de7 ed 5b 0a 80			ld de, (free_list )      
1deb 21 ac ef				ld hl, heap_end 
1dee			 
1dee ed 52				sbc hl, de 
1df0			 
1df0 cd 6e 1a				call forth_push_numhl 
1df3					 
1df3			 
1df3					 
1df3			 
1df3			 
1df3			 
1df3					NEXTW 
1df3 c3 5f 1c			jp macro_next 
1df6				endm 
# End of macro NEXTW
1df6			;endif 
1df6			 
1df6			.EXEC: 
1df6				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1df6 16				db WORD_SYS_CORE+OPCODE_EXEC             
1df7 92 1e			dw .STKEXEC            
1df9 05				db 4 + 1 
1dfa .. 00			db "EXEC",0              
1dff				endm 
# End of macro CWHEAD
1dff			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
1dff			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1dff			; | | 
1dff			; | |   
1dff				STACKFRAME OFF $5efe $5f9f 
1dff				if DEBUG_STACK_IMB 
1dff					if OFF 
1dff						exx 
1dff						ld de, $5efe 
1dff						ld a, d 
1dff						ld hl, curframe 
1dff						call hexout 
1dff						ld a, e 
1dff						ld hl, curframe+2 
1dff						call hexout 
1dff						ld hl, $5efe 
1dff						push hl 
1dff						ld hl, $5f9f 
1dff						push hl 
1dff						exx 
1dff					endif 
1dff				endif 
1dff			endm 
# End of macro STACKFRAME
1dff			 
1dff					if DEBUG_FORTH_WORDS_KEY 
1dff						DMARK "EXE" 
1dff f5				push af  
1e00 3a 14 1e			ld a, (.dmark)  
1e03 32 bd fb			ld (debug_mark),a  
1e06 3a 15 1e			ld a, (.dmark+1)  
1e09 32 be fb			ld (debug_mark+1),a  
1e0c 3a 16 1e			ld a, (.dmark+2)  
1e0f 32 bf fb			ld (debug_mark+2),a  
1e12 18 03			jr .pastdmark  
1e14 ..			.dmark: db "EXE"  
1e17 f1			.pastdmark: pop af  
1e18			endm  
# End of macro DMARK
1e18						CALLMONITOR 
1e18 cd d4 14			call break_point_state  
1e1b				endm  
# End of macro CALLMONITOR
1e1b					endif 
1e1b			 
1e1b				FORTH_DSP_VALUEHL 
1e1b cd 09 1b			call macro_dsp_valuehl 
1e1e				endm 
# End of macro FORTH_DSP_VALUEHL
1e1e			 
1e1e				FORTH_DSP_POP 
1e1e cd a5 1b			call macro_forth_dsp_pop 
1e21				endm 
# End of macro FORTH_DSP_POP
1e21			 
1e21					if DEBUG_FORTH_WORDS 
1e21						DMARK "EX1" 
1e21 f5				push af  
1e22 3a 36 1e			ld a, (.dmark)  
1e25 32 bd fb			ld (debug_mark),a  
1e28 3a 37 1e			ld a, (.dmark+1)  
1e2b 32 be fb			ld (debug_mark+1),a  
1e2e 3a 38 1e			ld a, (.dmark+2)  
1e31 32 bf fb			ld (debug_mark+2),a  
1e34 18 03			jr .pastdmark  
1e36 ..			.dmark: db "EX1"  
1e39 f1			.pastdmark: pop af  
1e3a			endm  
# End of macro DMARK
1e3a						CALLMONITOR 
1e3a cd d4 14			call break_point_state  
1e3d				endm  
# End of macro CALLMONITOR
1e3d					endif 
1e3d			;	ld e,(hl) 
1e3d			;	inc hl 
1e3d			;	ld d,(hl) 
1e3d			;	ex de,hl 
1e3d			 
1e3d			;		if DEBUG_FORTH_WORDS 
1e3d			;			DMARK "EX2" 
1e3d			;			CALLMONITOR 
1e3d			;		endif 
1e3d e5				push hl 
1e3e			 
1e3e				;ld a, 0 
1e3e				;ld a, FORTH_END_BUFFER 
1e3e cd 1a 11			call strlenz 
1e41 23				inc hl   ; include zero term to copy 
1e42 23				inc hl   ; include term 
1e43 23				inc hl   ; include term 
1e44 06 00			ld b,0 
1e46 4d				ld c,l 
1e47 e1				pop hl 
1e48 11 b7 f0			ld de, execscratch 
1e4b					if DEBUG_FORTH_WORDS 
1e4b						DMARK "EX3" 
1e4b f5				push af  
1e4c 3a 60 1e			ld a, (.dmark)  
1e4f 32 bd fb			ld (debug_mark),a  
1e52 3a 61 1e			ld a, (.dmark+1)  
1e55 32 be fb			ld (debug_mark+1),a  
1e58 3a 62 1e			ld a, (.dmark+2)  
1e5b 32 bf fb			ld (debug_mark+2),a  
1e5e 18 03			jr .pastdmark  
1e60 ..			.dmark: db "EX3"  
1e63 f1			.pastdmark: pop af  
1e64			endm  
# End of macro DMARK
1e64						CALLMONITOR 
1e64 cd d4 14			call break_point_state  
1e67				endm  
# End of macro CALLMONITOR
1e67					endif 
1e67 ed b0			ldir 
1e69			 
1e69			 
1e69 21 b7 f0			ld hl, execscratch 
1e6c			 
1e6c					if DEBUG_FORTH_WORDS 
1e6c						DMARK "EXe" 
1e6c f5				push af  
1e6d 3a 81 1e			ld a, (.dmark)  
1e70 32 bd fb			ld (debug_mark),a  
1e73 3a 82 1e			ld a, (.dmark+1)  
1e76 32 be fb			ld (debug_mark+1),a  
1e79 3a 83 1e			ld a, (.dmark+2)  
1e7c 32 bf fb			ld (debug_mark+2),a  
1e7f 18 03			jr .pastdmark  
1e81 ..			.dmark: db "EXe"  
1e84 f1			.pastdmark: pop af  
1e85			endm  
# End of macro DMARK
1e85						CALLMONITOR 
1e85 cd d4 14			call break_point_state  
1e88				endm  
# End of macro CALLMONITOR
1e88					endif 
1e88			 
1e88 cd ad 1c			call forthparse 
1e8b cd ed 1c			call forthexec 
1e8e			;	call forthexec_cleanup 
1e8e			;	call forthparse 
1e8e			;	call forthexec 
1e8e			 
1e8e				STACKFRAMECHK OFF $5efe $5f9f 
1e8e				if DEBUG_STACK_IMB 
1e8e					if OFF 
1e8e						exx 
1e8e						ld hl, $5f9f 
1e8e						pop de   ; $5f9f 
1e8e						call cmp16 
1e8e						jr nz, .spnosame 
1e8e						ld hl, $5efe 
1e8e						pop de   ; $5efe 
1e8e						call cmp16 
1e8e						jr z, .spfrsame 
1e8e						.spnosame: call showsperror 
1e8e						.spfrsame: nop 
1e8e						exx 
1e8e					endif 
1e8e				endif 
1e8e			endm 
# End of macro STACKFRAMECHK
1e8e			 
1e8e				; an immediate word so no need to process any more words 
1e8e c9				ret 
1e8f				NEXTW 
1e8f c3 5f 1c			jp macro_next 
1e92				endm 
# End of macro NEXTW
1e92			 
1e92			; dead code - old version  
1e92			;	FORTH_RSP_NEXT 
1e92			 
1e92			;  
1e92			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1e92			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1e92			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1e92			;	push hl 
1e92			;	push de 
1e92			;	push bc 
1e92			; 
1e92			; 
1e92			;		if DEBUG_FORTH_WORDS_KEY 
1e92			;			DMARK "EXR" 
1e92			;			CALLMONITOR 
1e92			;		endif 
1e92			; 
1e92			; 
1e92			; 
1e92			;	;v5 FORTH_DSP_VALUE 
1e92			;	FORTH_DSP_VALUEHL 
1e92			; 
1e92			;	; TODO do string type checks 
1e92			; 
1e92			;;v5	inc hl   ; skip type 
1e92			; 
1e92			;	push hl  ; source code  
1e92			;		if DEBUG_FORTH_WORDS 
1e92			;			DMARK "EX1" 
1e92			;			CALLMONITOR 
1e92			;		endif 
1e92			;	ld a, 0 
1e92			;	call strlent 
1e92			; 
1e92			;	inc hl 
1e92			;	inc hl 
1e92			;	inc hl 
1e92			;	inc hl 
1e92			; 
1e92			;	push hl    ; size 
1e92			; 
1e92			;		if DEBUG_FORTH_WORDS 
1e92			;			DMARK "EX2" 
1e92			;			CALLMONITOR 
1e92			;		endif 
1e92			;	call malloc 
1e92			; 
1e92			;	ex de, hl    ; de now contains malloc area 
1e92			;	pop bc   	; get byte count 
1e92			;	pop hl      ; get string to copy 
1e92			; 
1e92			;	push de     ; save malloc for free later 
1e92			; 
1e92			;		if DEBUG_FORTH_WORDS 
1e92			;			DMARK "EX3" 
1e92			;			CALLMONITOR 
1e92			;		endif 
1e92			;	ldir       ; duplicate string 
1e92			; 
1e92			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1e92			;	 
1e92			;	; TODO fix the parse would be better than this...  
1e92			;	ex de, hl 
1e92			;	dec hl 
1e92			;	ld a, 0 
1e92			;	ld (hl), a 
1e92			;	dec hl 
1e92			;	ld a, ' ' 
1e92			;	ld (hl), a 
1e92			;	dec hl 
1e92			;	ld (hl), a 
1e92			; 
1e92			;	dec hl 
1e92			;	ld (hl), a 
1e92			; 
1e92			; 
1e92			;	FORTH_DSP_POP  
1e92			; 
1e92			;	pop hl     
1e92			;	push hl    ; save malloc area 
1e92			; 
1e92			;		if DEBUG_FORTH_WORDS 
1e92			;			DMARK "EX4" 
1e92			;			CALLMONITOR 
1e92			;		endif 
1e92			; 
1e92			;	call forthparse 
1e92			;	call forthexec 
1e92			;	 
1e92			;	pop hl 
1e92			;	if DEBUG_FORTH_WORDS 
1e92			;		DMARK "EX5" 
1e92			;		CALLMONITOR 
1e92			;	endif 
1e92			; 
1e92			;	if FORTH_ENABLE_FREE 
1e92			;	call free 
1e92			;	endif 
1e92			; 
1e92			;	if DEBUG_FORTH_WORDS 
1e92			;		DMARK "EX6" 
1e92			;		CALLMONITOR 
1e92			;	endif 
1e92			; 
1e92			;	pop bc 
1e92			;	pop de 
1e92			;	pop hl 
1e92			;;	FORTH_RSP_POP	  
1e92			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1e92			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1e92			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1e92			; 
1e92			;	if DEBUG_FORTH_WORDS 
1e92			;		DMARK "EX7" 
1e92			;		CALLMONITOR 
1e92			;	endif 
1e92			;	NEXTW 
1e92			 
1e92			.STKEXEC: 
1e92				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1e92 3f				db WORD_SYS_CORE+43             
1e93 da 1f			dw .ZDUP            
1e95 08				db 7 + 1 
1e96 .. 00			db "STKEXEC",0              
1e9e				endm 
# End of macro CWHEAD
1e9e			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
1e9e			 
1e9e			 
1e9e					if DEBUG_FORTH_WORDS_KEY 
1e9e						DMARK "STX" 
1e9e f5				push af  
1e9f 3a b3 1e			ld a, (.dmark)  
1ea2 32 bd fb			ld (debug_mark),a  
1ea5 3a b4 1e			ld a, (.dmark+1)  
1ea8 32 be fb			ld (debug_mark+1),a  
1eab 3a b5 1e			ld a, (.dmark+2)  
1eae 32 bf fb			ld (debug_mark+2),a  
1eb1 18 03			jr .pastdmark  
1eb3 ..			.dmark: db "STX"  
1eb6 f1			.pastdmark: pop af  
1eb7			endm  
# End of macro DMARK
1eb7						CALLMONITOR 
1eb7 cd d4 14			call break_point_state  
1eba				endm  
# End of macro CALLMONITOR
1eba					endif 
1eba			 
1eba				FORTH_DSP_VALUEHL 
1eba cd 09 1b			call macro_dsp_valuehl 
1ebd				endm 
# End of macro FORTH_DSP_VALUEHL
1ebd			 
1ebd 22 e6 f9			ld (store_tmp1), hl    ; count 
1ec0			 
1ec0				FORTH_DSP_POP 
1ec0 cd a5 1b			call macro_forth_dsp_pop 
1ec3				endm 
# End of macro FORTH_DSP_POP
1ec3			.stkexec1: 
1ec3 2a e6 f9			ld hl, (store_tmp1)   ; count 
1ec6 3e 00			ld a, 0 
1ec8 bd				cp l 
1ec9 c8				ret z 
1eca			 
1eca 2b				dec hl 
1ecb 22 e6 f9			ld (store_tmp1), hl    ; count 
1ece				 
1ece				FORTH_DSP_VALUEHL 
1ece cd 09 1b			call macro_dsp_valuehl 
1ed1				endm 
# End of macro FORTH_DSP_VALUEHL
1ed1 e5				push hl 
1ed2				 
1ed2					if DEBUG_FORTH_WORDS 
1ed2						DMARK "EXp" 
1ed2 f5				push af  
1ed3 3a e7 1e			ld a, (.dmark)  
1ed6 32 bd fb			ld (debug_mark),a  
1ed9 3a e8 1e			ld a, (.dmark+1)  
1edc 32 be fb			ld (debug_mark+1),a  
1edf 3a e9 1e			ld a, (.dmark+2)  
1ee2 32 bf fb			ld (debug_mark+2),a  
1ee5 18 03			jr .pastdmark  
1ee7 ..			.dmark: db "EXp"  
1eea f1			.pastdmark: pop af  
1eeb			endm  
# End of macro DMARK
1eeb						CALLMONITOR 
1eeb cd d4 14			call break_point_state  
1eee				endm  
# End of macro CALLMONITOR
1eee					endif 
1eee				FORTH_DSP_POP 
1eee cd a5 1b			call macro_forth_dsp_pop 
1ef1				endm 
# End of macro FORTH_DSP_POP
1ef1			 
1ef1 cd 1a 11			call strlenz 
1ef4 23				inc hl   ; include zero term to copy 
1ef5 23				inc hl   ; include zero term to copy 
1ef6 23				inc hl   ; include zero term to copy 
1ef7 06 00			ld b,0 
1ef9 4d				ld c,l 
1efa e1				pop hl 
1efb 11 b7 f0			ld de, execscratch 
1efe					if DEBUG_FORTH_WORDS 
1efe						DMARK "EX3" 
1efe f5				push af  
1eff 3a 13 1f			ld a, (.dmark)  
1f02 32 bd fb			ld (debug_mark),a  
1f05 3a 14 1f			ld a, (.dmark+1)  
1f08 32 be fb			ld (debug_mark+1),a  
1f0b 3a 15 1f			ld a, (.dmark+2)  
1f0e 32 bf fb			ld (debug_mark+2),a  
1f11 18 03			jr .pastdmark  
1f13 ..			.dmark: db "EX3"  
1f16 f1			.pastdmark: pop af  
1f17			endm  
# End of macro DMARK
1f17						CALLMONITOR 
1f17 cd d4 14			call break_point_state  
1f1a				endm  
# End of macro CALLMONITOR
1f1a					endif 
1f1a ed b0			ldir 
1f1c			 
1f1c			 
1f1c 21 b7 f0			ld hl, execscratch 
1f1f			 
1f1f					if DEBUG_FORTH_WORDS 
1f1f						DMARK "EXP" 
1f1f f5				push af  
1f20 3a 34 1f			ld a, (.dmark)  
1f23 32 bd fb			ld (debug_mark),a  
1f26 3a 35 1f			ld a, (.dmark+1)  
1f29 32 be fb			ld (debug_mark+1),a  
1f2c 3a 36 1f			ld a, (.dmark+2)  
1f2f 32 bf fb			ld (debug_mark+2),a  
1f32 18 03			jr .pastdmark  
1f34 ..			.dmark: db "EXP"  
1f37 f1			.pastdmark: pop af  
1f38			endm  
# End of macro DMARK
1f38						CALLMONITOR 
1f38 cd d4 14			call break_point_state  
1f3b				endm  
# End of macro CALLMONITOR
1f3b					endif 
1f3b			 
1f3b cd ad 1c			call forthparse 
1f3e 21 b7 f0			ld hl, execscratch 
1f41					if DEBUG_FORTH_WORDS 
1f41						DMARK "EXx" 
1f41 f5				push af  
1f42 3a 56 1f			ld a, (.dmark)  
1f45 32 bd fb			ld (debug_mark),a  
1f48 3a 57 1f			ld a, (.dmark+1)  
1f4b 32 be fb			ld (debug_mark+1),a  
1f4e 3a 58 1f			ld a, (.dmark+2)  
1f51 32 bf fb			ld (debug_mark+2),a  
1f54 18 03			jr .pastdmark  
1f56 ..			.dmark: db "EXx"  
1f59 f1			.pastdmark: pop af  
1f5a			endm  
# End of macro DMARK
1f5a						CALLMONITOR 
1f5a cd d4 14			call break_point_state  
1f5d				endm  
# End of macro CALLMONITOR
1f5d					endif 
1f5d cd ed 1c			call forthexec 
1f60			 
1f60 c3 c3 1e			jp .stkexec1 
1f63			 
1f63 c9				ret 
1f64			 
1f64			 
1f64			.DUP: 
1f64				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1f64 17				db WORD_SYS_CORE+OPCODE_DUP             
1f65 da 1f			dw .ZDUP            
1f67 04				db 3 + 1 
1f68 .. 00			db "DUP",0              
1f6c				endm 
# End of macro CWHEAD
1f6c			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1f6c			 
1f6c					if DEBUG_FORTH_WORDS_KEY 
1f6c						DMARK "DUP" 
1f6c f5				push af  
1f6d 3a 81 1f			ld a, (.dmark)  
1f70 32 bd fb			ld (debug_mark),a  
1f73 3a 82 1f			ld a, (.dmark+1)  
1f76 32 be fb			ld (debug_mark+1),a  
1f79 3a 83 1f			ld a, (.dmark+2)  
1f7c 32 bf fb			ld (debug_mark+2),a  
1f7f 18 03			jr .pastdmark  
1f81 ..			.dmark: db "DUP"  
1f84 f1			.pastdmark: pop af  
1f85			endm  
# End of macro DMARK
1f85						CALLMONITOR 
1f85 cd d4 14			call break_point_state  
1f88				endm  
# End of macro CALLMONITOR
1f88					endif 
1f88			 
1f88					FORTH_DSP 
1f88 cd ee 1a			call macro_forth_dsp 
1f8b				endm 
# End of macro FORTH_DSP
1f8b			 
1f8b 7e					ld a, (HL) 
1f8c fe 01				cp DS_TYPE_STR 
1f8e 20 25				jr nz, .dupinum 
1f90			 
1f90					; push another string 
1f90			 
1f90					FORTH_DSP_VALUEHL     		 
1f90 cd 09 1b			call macro_dsp_valuehl 
1f93				endm 
# End of macro FORTH_DSP_VALUEHL
1f93			 
1f93				if DEBUG_FORTH_WORDS 
1f93					DMARK "DUs" 
1f93 f5				push af  
1f94 3a a8 1f			ld a, (.dmark)  
1f97 32 bd fb			ld (debug_mark),a  
1f9a 3a a9 1f			ld a, (.dmark+1)  
1f9d 32 be fb			ld (debug_mark+1),a  
1fa0 3a aa 1f			ld a, (.dmark+2)  
1fa3 32 bf fb			ld (debug_mark+2),a  
1fa6 18 03			jr .pastdmark  
1fa8 ..			.dmark: db "DUs"  
1fab f1			.pastdmark: pop af  
1fac			endm  
# End of macro DMARK
1fac					CALLMONITOR 
1fac cd d4 14			call break_point_state  
1faf				endm  
# End of macro CALLMONITOR
1faf				endif 
1faf cd 80 1a				call forth_push_str 
1fb2			 
1fb2					NEXTW 
1fb2 c3 5f 1c			jp macro_next 
1fb5				endm 
# End of macro NEXTW
1fb5			 
1fb5			 
1fb5			.dupinum: 
1fb5					 
1fb5			 
1fb5			 
1fb5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1fb5 cd 09 1b			call macro_dsp_valuehl 
1fb8				endm 
# End of macro FORTH_DSP_VALUEHL
1fb8			 
1fb8				; TODO add floating point number detection 
1fb8			 
1fb8				if DEBUG_FORTH_WORDS 
1fb8					DMARK "DUi" 
1fb8 f5				push af  
1fb9 3a cd 1f			ld a, (.dmark)  
1fbc 32 bd fb			ld (debug_mark),a  
1fbf 3a ce 1f			ld a, (.dmark+1)  
1fc2 32 be fb			ld (debug_mark+1),a  
1fc5 3a cf 1f			ld a, (.dmark+2)  
1fc8 32 bf fb			ld (debug_mark+2),a  
1fcb 18 03			jr .pastdmark  
1fcd ..			.dmark: db "DUi"  
1fd0 f1			.pastdmark: pop af  
1fd1			endm  
# End of macro DMARK
1fd1					CALLMONITOR 
1fd1 cd d4 14			call break_point_state  
1fd4				endm  
# End of macro CALLMONITOR
1fd4				endif 
1fd4			 
1fd4 cd 6e 1a				call forth_push_numhl 
1fd7					NEXTW 
1fd7 c3 5f 1c			jp macro_next 
1fda				endm 
# End of macro NEXTW
1fda			.ZDUP: 
1fda				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
1fda 99				db WORD_SYS_CORE+OPCODE_ZDUP             
1fdb 12 20			dw .SWAP            
1fdd 05				db 4 + 1 
1fde .. 00			db "?DUP",0              
1fe3				endm 
# End of macro CWHEAD
1fe3			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
1fe3			 
1fe3					if DEBUG_FORTH_WORDS_KEY 
1fe3						DMARK "qDU" 
1fe3 f5				push af  
1fe4 3a f8 1f			ld a, (.dmark)  
1fe7 32 bd fb			ld (debug_mark),a  
1fea 3a f9 1f			ld a, (.dmark+1)  
1fed 32 be fb			ld (debug_mark+1),a  
1ff0 3a fa 1f			ld a, (.dmark+2)  
1ff3 32 bf fb			ld (debug_mark+2),a  
1ff6 18 03			jr .pastdmark  
1ff8 ..			.dmark: db "qDU"  
1ffb f1			.pastdmark: pop af  
1ffc			endm  
# End of macro DMARK
1ffc						CALLMONITOR 
1ffc cd d4 14			call break_point_state  
1fff				endm  
# End of macro CALLMONITOR
1fff					endif 
1fff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1fff cd 09 1b			call macro_dsp_valuehl 
2002				endm 
# End of macro FORTH_DSP_VALUEHL
2002			 
2002 e5					push hl 
2003			 
2003					; is it a zero? 
2003			 
2003 3e 00				ld a, 0 
2005 84					add h 
2006 85					add l 
2007			 
2007 e1					pop hl 
2008			 
2008 fe 00				cp 0 
200a 28 03				jr z, .dup2orig 
200c			 
200c			 
200c cd 6e 1a				call forth_push_numhl 
200f			 
200f			 
200f				; TODO add floating point number detection 
200f			 
200f			.dup2orig: 
200f			 
200f					NEXTW 
200f c3 5f 1c			jp macro_next 
2012				endm 
# End of macro NEXTW
2012			.SWAP: 
2012				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2012 18				db WORD_SYS_CORE+OPCODE_SWAP             
2013 51 20			dw .COLN            
2015 05				db 4 + 1 
2016 .. 00			db "SWAP",0              
201b				endm 
# End of macro CWHEAD
201b			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
201b					if DEBUG_FORTH_WORDS_KEY 
201b						DMARK "SWP" 
201b f5				push af  
201c 3a 30 20			ld a, (.dmark)  
201f 32 bd fb			ld (debug_mark),a  
2022 3a 31 20			ld a, (.dmark+1)  
2025 32 be fb			ld (debug_mark+1),a  
2028 3a 32 20			ld a, (.dmark+2)  
202b 32 bf fb			ld (debug_mark+2),a  
202e 18 03			jr .pastdmark  
2030 ..			.dmark: db "SWP"  
2033 f1			.pastdmark: pop af  
2034			endm  
# End of macro DMARK
2034						CALLMONITOR 
2034 cd d4 14			call break_point_state  
2037				endm  
# End of macro CALLMONITOR
2037					endif 
2037			 
2037					FORTH_DSP_VALUEHL 
2037 cd 09 1b			call macro_dsp_valuehl 
203a				endm 
# End of macro FORTH_DSP_VALUEHL
203a e5					push hl     ; w2 
203b			 
203b					FORTH_DSP_POP 
203b cd a5 1b			call macro_forth_dsp_pop 
203e				endm 
# End of macro FORTH_DSP_POP
203e			 
203e					FORTH_DSP_VALUEHL 
203e cd 09 1b			call macro_dsp_valuehl 
2041				endm 
# End of macro FORTH_DSP_VALUEHL
2041			 
2041					FORTH_DSP_POP 
2041 cd a5 1b			call macro_forth_dsp_pop 
2044				endm 
# End of macro FORTH_DSP_POP
2044			 
2044 d1					pop de     ; w2	, hl = w1 
2045			 
2045 eb					ex de, hl 
2046 d5					push de 
2047			 
2047 cd 6e 1a				call forth_push_numhl 
204a			 
204a e1					pop hl 
204b			 
204b cd 6e 1a				call forth_push_numhl 
204e					 
204e			 
204e					NEXTW 
204e c3 5f 1c			jp macro_next 
2051				endm 
# End of macro NEXTW
2051			.COLN: 
2051				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2051 19				db WORD_SYS_CORE+OPCODE_COLN             
2052 dd 21			dw .SCOLN            
2054 02				db 1 + 1 
2055 .. 00			db ":",0              
2057				endm 
# End of macro CWHEAD
2057			; | : ( -- )         Create new word | DONE 
2057			 
2057					if DEBUG_FORTH_WORDS_KEY 
2057						DMARK "CLN" 
2057 f5				push af  
2058 3a 6c 20			ld a, (.dmark)  
205b 32 bd fb			ld (debug_mark),a  
205e 3a 6d 20			ld a, (.dmark+1)  
2061 32 be fb			ld (debug_mark+1),a  
2064 3a 6e 20			ld a, (.dmark+2)  
2067 32 bf fb			ld (debug_mark+2),a  
206a 18 03			jr .pastdmark  
206c ..			.dmark: db "CLN"  
206f f1			.pastdmark: pop af  
2070			endm  
# End of macro DMARK
2070						CALLMONITOR 
2070 cd d4 14			call break_point_state  
2073				endm  
# End of macro CALLMONITOR
2073					endif 
2073				STACKFRAME OFF $8efe $989f 
2073				if DEBUG_STACK_IMB 
2073					if OFF 
2073						exx 
2073						ld de, $8efe 
2073						ld a, d 
2073						ld hl, curframe 
2073						call hexout 
2073						ld a, e 
2073						ld hl, curframe+2 
2073						call hexout 
2073						ld hl, $8efe 
2073						push hl 
2073						ld hl, $989f 
2073						push hl 
2073						exx 
2073					endif 
2073				endif 
2073			endm 
# End of macro STACKFRAME
2073				; get parser buffer length  of new word 
2073			 
2073				 
2073			 
2073					; move tok past this to start of name defintition 
2073					; TODO get word to define 
2073					; TODO Move past word token 
2073					; TODO get length of string up to the ';' 
2073			 
2073 2a b9 f2			ld hl, (os_tok_ptr) 
2076 23				inc hl 
2077 23				inc hl 
2078			 
2078 3e 3b			ld a, ';' 
207a cd 25 11			call strlent 
207d			 
207d 7d				ld a,l 
207e 32 b8 f1			ld (os_new_parse_len), a 
2081			 
2081			 
2081			if DEBUG_FORTH_UWORD 
2081 ed 5b b9 f2		ld de, (os_tok_ptr) 
2085						DMARK ":01" 
2085 f5				push af  
2086 3a 9a 20			ld a, (.dmark)  
2089 32 bd fb			ld (debug_mark),a  
208c 3a 9b 20			ld a, (.dmark+1)  
208f 32 be fb			ld (debug_mark+1),a  
2092 3a 9c 20			ld a, (.dmark+2)  
2095 32 bf fb			ld (debug_mark+2),a  
2098 18 03			jr .pastdmark  
209a ..			.dmark: db ":01"  
209d f1			.pastdmark: pop af  
209e			endm  
# End of macro DMARK
209e				CALLMONITOR 
209e cd d4 14			call break_point_state  
20a1				endm  
# End of macro CALLMONITOR
20a1			endif 
20a1			 
20a1			; 
20a1			;  new word memory layout: 
20a1			;  
20a1			;    : adg 6666 ;  
20a1			; 
20a1			;    db   1     ; user defined word  
20a1 23				inc hl    
20a2			;    dw   sysdict 
20a2 23				inc hl 
20a3 23				inc hl 
20a4			;    db <word len>+1 (for null) 
20a4 23				inc hl 
20a5			;    db .... <word> 
20a5			; 
20a5			 
20a5 23				inc hl    ; some extras for the word preamble before the above 
20a6 23				inc hl 
20a7 23				inc hl 
20a8 23				inc hl 
20a9 23				inc hl 
20aa 23				inc hl 
20ab 23				inc hl  
20ac 23				inc hl 
20ad 23				inc hl 
20ae 23				inc hl 
20af 23				inc hl 
20b0 23				inc hl 
20b1 23				inc hl 
20b2 23				inc hl     ; TODO how many do we really need?     maybe only 6 
20b3			;       exec word buffer 
20b3			;	<ptr word>   
20b3 23				inc hl 
20b4 23				inc hl 
20b5			;       <word list><null term> 7F final term 
20b5			 
20b5			 
20b5			if DEBUG_FORTH_UWORD 
20b5						DMARK ":02" 
20b5 f5				push af  
20b6 3a ca 20			ld a, (.dmark)  
20b9 32 bd fb			ld (debug_mark),a  
20bc 3a cb 20			ld a, (.dmark+1)  
20bf 32 be fb			ld (debug_mark+1),a  
20c2 3a cc 20			ld a, (.dmark+2)  
20c5 32 bf fb			ld (debug_mark+2),a  
20c8 18 03			jr .pastdmark  
20ca ..			.dmark: db ":02"  
20cd f1			.pastdmark: pop af  
20ce			endm  
# End of macro DMARK
20ce				CALLMONITOR 
20ce cd d4 14			call break_point_state  
20d1				endm  
# End of macro CALLMONITOR
20d1			endif 
20d1			 
20d1				 
20d1					; malloc the size 
20d1			 
20d1 cd 83 11				call malloc 
20d4 22 b6 f1				ld (os_new_malloc), hl     ; save malloc start 
20d7			 
20d7			;    db   1     ; user defined word  
20d7 3e 01				ld a, WORD_SYS_UWORD  
20d9 77					ld (hl), a 
20da				 
20da 23				inc hl    
20db			;    dw   sysdict 
20db 11 b7 1d			ld de, sysdict       ; continue on with the scan to the system dict 
20de 73				ld (hl), e 
20df 23				inc hl 
20e0 72				ld (hl), d 
20e1 23				inc hl 
20e2			 
20e2			 
20e2			;    Setup dict word 
20e2			 
20e2 23				inc hl 
20e3 22 bc f1			ld (os_new_work_ptr), hl     ; save start of dict word  
20e6			 
20e6				; 1. get length of dict word 
20e6			 
20e6			 
20e6 2a b9 f2			ld hl, (os_tok_ptr) 
20e9 23				inc hl 
20ea 23				inc hl    ; position to start of dict word 
20eb 3e 00			ld a, 0 
20ed cd 25 11			call strlent 
20f0			 
20f0			 
20f0 23				inc hl    ; to include null??? 
20f1			 
20f1				; write length of dict word 
20f1			 
20f1 ed 5b bc f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
20f5 1b				dec de 
20f6 eb				ex de, hl 
20f7 73				ld (hl), e 
20f8 eb				ex de, hl 
20f9			 
20f9				 
20f9			 
20f9				; copy  
20f9 4d				ld c, l 
20fa 06 00			ld b, 0 
20fc ed 5b bc f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2100 2a b9 f2			ld hl, (os_tok_ptr) 
2103 23				inc hl 
2104 23				inc hl    ; position to start of dict word 
2105				 
2105			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2105				 
2105				; TODO need to convert word to upper case 
2105			 
2105			ucasetok:	 
2105 7e				ld a,(hl) 
2106 cd 11 11			call toUpper 
2109 77				ld (hl),a 
210a ed a0			ldi 
210c f2 05 21		 	jp p, ucasetok 
210f			 
210f			 
210f			 
210f				; de now points to start of where the word body code should be placed 
210f ed 53 bc f1		ld (os_new_work_ptr), de 
2113				; hl now points to the words to throw at forthexec which needs to be copied 
2113 22 be f1			ld (os_new_src_ptr), hl 
2116			 
2116				; TODO add 'call to forthexec' 
2116			 
2116			if DEBUG_FORTH_UWORD 
2116 c5				push bc 
2117 ed 4b b6 f1		ld bc, (os_new_malloc) 
211b						DMARK ":0x" 
211b f5				push af  
211c 3a 30 21			ld a, (.dmark)  
211f 32 bd fb			ld (debug_mark),a  
2122 3a 31 21			ld a, (.dmark+1)  
2125 32 be fb			ld (debug_mark+1),a  
2128 3a 32 21			ld a, (.dmark+2)  
212b 32 bf fb			ld (debug_mark+2),a  
212e 18 03			jr .pastdmark  
2130 ..			.dmark: db ":0x"  
2133 f1			.pastdmark: pop af  
2134			endm  
# End of macro DMARK
2134				CALLMONITOR 
2134 cd d4 14			call break_point_state  
2137				endm  
# End of macro CALLMONITOR
2137 c1				pop bc 
2138			endif 
2138			 
2138			 
2138				; create word preamble which should be: 
2138			 
2138			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2138			 
2138				;    ld hl, <word code> 
2138				;    jp user_exec 
2138			        ;    <word code bytes> 
2138			 
2138			 
2138			;	inc de     ; TODO ??? or are we already past the word's null 
2138 eb				ex de, hl 
2139			 
2139 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
213b			 
213b 23				inc hl 
213c 22 c2 f1			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
213f 23				inc hl 
2140			 
2140 23				inc hl 
2141 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2143			 
2143 01 10 4e			ld bc, user_exec 
2146 23				inc hl 
2147 71				ld (hl), c     ; poke address of user_exec 
2148 23				inc hl 
2149 70				ld (hl), b     
214a			 ; 
214a			;	inc hl 
214a			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
214a			; 
214a			; 
214a			;	ld bc, macro_forth_rsp_next 
214a			;	inc hl 
214a			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
214a			;	inc hl 
214a			;	ld (hl), b     
214a			 ; 
214a			;	inc hl 
214a			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
214a			; 
214a			; 
214a			;	inc hl 
214a			;	ld bc, forthexec 
214a			;	ld (hl), c     ; poke address of forthexec 
214a			;	inc hl 
214a			;	ld (hl), b      
214a			; 
214a			;	inc hl 
214a			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
214a			; 
214a			;	ld bc, user_dict_next 
214a			;	inc hl 
214a			;	ld (hl), c     ; poke address of forthexec 
214a			;	inc hl 
214a			;	ld (hl), b      
214a			 
214a				; hl is now where we need to copy the word byte data to save this 
214a			 
214a 23				inc hl 
214b 22 c0 f1			ld (os_new_exec), hl 
214e				 
214e				; copy definition 
214e			 
214e eb				ex de, hl 
214f			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
214f			;	inc de    ; skip the PC for this parse 
214f 3a b8 f1			ld a, (os_new_parse_len) 
2152 4f				ld c, a 
2153 06 00			ld b, 0 
2155 ed b0			ldir		 ; copy defintion 
2157			 
2157			 
2157				; poke the address of where the new word bytes live for forthexec 
2157			 
2157 2a c2 f1			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
215a			 
215a ed 5b c0 f1		ld de, (os_new_exec)      
215e				 
215e 73				ld (hl), e 
215f 23				inc hl 
2160 72				ld (hl), d 
2161			 
2161					; TODO copy last user dict word next link to this word 
2161					; TODO update last user dict word to point to this word 
2161			; 
2161			; hl f923 de 812a ; bc 811a 
2161			 
2161			if DEBUG_FORTH_UWORD 
2161 c5				push bc 
2162 ed 4b b6 f1		ld bc, (os_new_malloc) 
2166						DMARK ":0A" 
2166 f5				push af  
2167 3a 7b 21			ld a, (.dmark)  
216a 32 bd fb			ld (debug_mark),a  
216d 3a 7c 21			ld a, (.dmark+1)  
2170 32 be fb			ld (debug_mark+1),a  
2173 3a 7d 21			ld a, (.dmark+2)  
2176 32 bf fb			ld (debug_mark+2),a  
2179 18 03			jr .pastdmark  
217b ..			.dmark: db ":0A"  
217e f1			.pastdmark: pop af  
217f			endm  
# End of macro DMARK
217f				CALLMONITOR 
217f cd d4 14			call break_point_state  
2182				endm  
# End of macro CALLMONITOR
2182 c1				pop bc 
2183			endif 
2183			if DEBUG_FORTH_UWORD 
2183 c5				push bc 
2184 ed 4b b6 f1		ld bc, (os_new_malloc) 
2188 03				inc bc 
2189 03				inc bc 
218a 03				inc bc 
218b 03				inc bc 
218c 03				inc bc 
218d 03				inc bc 
218e 03				inc bc 
218f 03				inc bc 
2190			 
2190						DMARK ":0B" 
2190 f5				push af  
2191 3a a5 21			ld a, (.dmark)  
2194 32 bd fb			ld (debug_mark),a  
2197 3a a6 21			ld a, (.dmark+1)  
219a 32 be fb			ld (debug_mark+1),a  
219d 3a a7 21			ld a, (.dmark+2)  
21a0 32 bf fb			ld (debug_mark+2),a  
21a3 18 03			jr .pastdmark  
21a5 ..			.dmark: db ":0B"  
21a8 f1			.pastdmark: pop af  
21a9			endm  
# End of macro DMARK
21a9				CALLMONITOR 
21a9 cd d4 14			call break_point_state  
21ac				endm  
# End of macro CALLMONITOR
21ac c1				pop bc 
21ad			endif 
21ad			 
21ad			; update word dict linked list for new word 
21ad			 
21ad			 
21ad 2a b5 f2		ld hl, (os_last_new_uword)		; get the start of the last added uword 
21b0 23			inc hl     ; move to next work linked list ptr 
21b1			 
21b1 ed 5b b6 f1	ld de, (os_new_malloc)		 ; new next word 
21b5 73			ld (hl), e 
21b6 23			inc hl 
21b7 72			ld (hl), d 
21b8			 
21b8			if DEBUG_FORTH_UWORD 
21b8 ed 4b b5 f2		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
21bc			endif 
21bc			 
21bc ed 53 b5 f2	ld (os_last_new_uword), de      ; update last new uword ptr 
21c0			 
21c0			 
21c0			if DEBUG_FORTH_UWORD 
21c0						DMARK ":0+" 
21c0 f5				push af  
21c1 3a d5 21			ld a, (.dmark)  
21c4 32 bd fb			ld (debug_mark),a  
21c7 3a d6 21			ld a, (.dmark+1)  
21ca 32 be fb			ld (debug_mark+1),a  
21cd 3a d7 21			ld a, (.dmark+2)  
21d0 32 bf fb			ld (debug_mark+2),a  
21d3 18 03			jr .pastdmark  
21d5 ..			.dmark: db ":0+"  
21d8 f1			.pastdmark: pop af  
21d9			endm  
# End of macro DMARK
21d9				CALLMONITOR 
21d9 cd d4 14			call break_point_state  
21dc				endm  
# End of macro CALLMONITOR
21dc			endif 
21dc			 
21dc				STACKFRAMECHK OFF $8efe $989f 
21dc				if DEBUG_STACK_IMB 
21dc					if OFF 
21dc						exx 
21dc						ld hl, $989f 
21dc						pop de   ; $989f 
21dc						call cmp16 
21dc						jr nz, .spnosame 
21dc						ld hl, $8efe 
21dc						pop de   ; $8efe 
21dc						call cmp16 
21dc						jr z, .spfrsame 
21dc						.spnosame: call showsperror 
21dc						.spfrsame: nop 
21dc						exx 
21dc					endif 
21dc				endif 
21dc			endm 
# End of macro STACKFRAMECHK
21dc			 
21dc c9			ret    ; dont process any remaining parser tokens as they form new word 
21dd			 
21dd			 
21dd			 
21dd			 
21dd			;		NEXT 
21dd			.SCOLN: 
21dd			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
21dd 06				db OPCODE_SCOLN 
21de 29 22			dw .DROP 
21e0 02				db 2 
21e1 .. 00			db ";",0           
21e3			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
21e3					if DEBUG_FORTH_WORDS_KEY 
21e3						DMARK "SCN" 
21e3 f5				push af  
21e4 3a f8 21			ld a, (.dmark)  
21e7 32 bd fb			ld (debug_mark),a  
21ea 3a f9 21			ld a, (.dmark+1)  
21ed 32 be fb			ld (debug_mark+1),a  
21f0 3a fa 21			ld a, (.dmark+2)  
21f3 32 bf fb			ld (debug_mark+2),a  
21f6 18 03			jr .pastdmark  
21f8 ..			.dmark: db "SCN"  
21fb f1			.pastdmark: pop af  
21fc			endm  
# End of macro DMARK
21fc						CALLMONITOR 
21fc cd d4 14			call break_point_state  
21ff				endm  
# End of macro CALLMONITOR
21ff					endif 
21ff					FORTH_RSP_TOS 
21ff cd 2c 1a			call macro_forth_rsp_tos 
2202				endm 
# End of macro FORTH_RSP_TOS
2202 e5					push hl 
2203					FORTH_RSP_POP 
2203 cd 36 1a			call macro_forth_rsp_pop 
2206				endm 
# End of macro FORTH_RSP_POP
2206 e1					pop hl 
2207			;		ex de,hl 
2207 22 b9 f2				ld (os_tok_ptr),hl 
220a			 
220a			if DEBUG_FORTH_UWORD 
220a						DMARK "SCL" 
220a f5				push af  
220b 3a 1f 22			ld a, (.dmark)  
220e 32 bd fb			ld (debug_mark),a  
2211 3a 20 22			ld a, (.dmark+1)  
2214 32 be fb			ld (debug_mark+1),a  
2217 3a 21 22			ld a, (.dmark+2)  
221a 32 bf fb			ld (debug_mark+2),a  
221d 18 03			jr .pastdmark  
221f ..			.dmark: db "SCL"  
2222 f1			.pastdmark: pop af  
2223			endm  
# End of macro DMARK
2223				CALLMONITOR 
2223 cd d4 14			call break_point_state  
2226				endm  
# End of macro CALLMONITOR
2226			endif 
2226					NEXTW 
2226 c3 5f 1c			jp macro_next 
2229				endm 
# End of macro NEXTW
2229			 
2229			.DROP: 
2229				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2229 1b				db WORD_SYS_CORE+OPCODE_DROP             
222a 54 22			dw .DUP2            
222c 05				db 4 + 1 
222d .. 00			db "DROP",0              
2232				endm 
# End of macro CWHEAD
2232			; | DROP ( w -- )   drop the TOS item   | DONE 
2232					if DEBUG_FORTH_WORDS_KEY 
2232						DMARK "DRP" 
2232 f5				push af  
2233 3a 47 22			ld a, (.dmark)  
2236 32 bd fb			ld (debug_mark),a  
2239 3a 48 22			ld a, (.dmark+1)  
223c 32 be fb			ld (debug_mark+1),a  
223f 3a 49 22			ld a, (.dmark+2)  
2242 32 bf fb			ld (debug_mark+2),a  
2245 18 03			jr .pastdmark  
2247 ..			.dmark: db "DRP"  
224a f1			.pastdmark: pop af  
224b			endm  
# End of macro DMARK
224b						CALLMONITOR 
224b cd d4 14			call break_point_state  
224e				endm  
# End of macro CALLMONITOR
224e					endif 
224e					FORTH_DSP_POP 
224e cd a5 1b			call macro_forth_dsp_pop 
2251				endm 
# End of macro FORTH_DSP_POP
2251					NEXTW 
2251 c3 5f 1c			jp macro_next 
2254				endm 
# End of macro NEXTW
2254			.DUP2: 
2254				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2254 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2255 99 22			dw .DROP2            
2257 05				db 4 + 1 
2258 .. 00			db "2DUP",0              
225d				endm 
# End of macro CWHEAD
225d			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
225d					if DEBUG_FORTH_WORDS_KEY 
225d						DMARK "2DU" 
225d f5				push af  
225e 3a 72 22			ld a, (.dmark)  
2261 32 bd fb			ld (debug_mark),a  
2264 3a 73 22			ld a, (.dmark+1)  
2267 32 be fb			ld (debug_mark+1),a  
226a 3a 74 22			ld a, (.dmark+2)  
226d 32 bf fb			ld (debug_mark+2),a  
2270 18 03			jr .pastdmark  
2272 ..			.dmark: db "2DU"  
2275 f1			.pastdmark: pop af  
2276			endm  
# End of macro DMARK
2276						CALLMONITOR 
2276 cd d4 14			call break_point_state  
2279				endm  
# End of macro CALLMONITOR
2279					endif 
2279					FORTH_DSP_VALUEHL 
2279 cd 09 1b			call macro_dsp_valuehl 
227c				endm 
# End of macro FORTH_DSP_VALUEHL
227c e5					push hl      ; 2 
227d			 
227d					FORTH_DSP_POP 
227d cd a5 1b			call macro_forth_dsp_pop 
2280				endm 
# End of macro FORTH_DSP_POP
2280					 
2280					FORTH_DSP_VALUEHL 
2280 cd 09 1b			call macro_dsp_valuehl 
2283				endm 
# End of macro FORTH_DSP_VALUEHL
2283			;		push hl      ; 1 
2283			 
2283					FORTH_DSP_POP 
2283 cd a5 1b			call macro_forth_dsp_pop 
2286				endm 
# End of macro FORTH_DSP_POP
2286			 
2286			;		pop hl       ; 1 
2286 d1					pop de       ; 2 
2287			 
2287 cd 6e 1a				call forth_push_numhl 
228a eb					ex de, hl 
228b cd 6e 1a				call forth_push_numhl 
228e			 
228e					 
228e eb					ex de, hl 
228f			 
228f cd 6e 1a				call forth_push_numhl 
2292 eb					ex de, hl 
2293 cd 6e 1a				call forth_push_numhl 
2296			 
2296			 
2296					NEXTW 
2296 c3 5f 1c			jp macro_next 
2299				endm 
# End of macro NEXTW
2299			.DROP2: 
2299				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2299 1d				db WORD_SYS_CORE+OPCODE_DROP2             
229a c8 22			dw .SWAP2            
229c 06				db 5 + 1 
229d .. 00			db "2DROP",0              
22a3				endm 
# End of macro CWHEAD
22a3			; | 2DROP ( w w -- )    Double drop | DONE 
22a3					if DEBUG_FORTH_WORDS_KEY 
22a3						DMARK "2DR" 
22a3 f5				push af  
22a4 3a b8 22			ld a, (.dmark)  
22a7 32 bd fb			ld (debug_mark),a  
22aa 3a b9 22			ld a, (.dmark+1)  
22ad 32 be fb			ld (debug_mark+1),a  
22b0 3a ba 22			ld a, (.dmark+2)  
22b3 32 bf fb			ld (debug_mark+2),a  
22b6 18 03			jr .pastdmark  
22b8 ..			.dmark: db "2DR"  
22bb f1			.pastdmark: pop af  
22bc			endm  
# End of macro DMARK
22bc						CALLMONITOR 
22bc cd d4 14			call break_point_state  
22bf				endm  
# End of macro CALLMONITOR
22bf					endif 
22bf					FORTH_DSP_POP 
22bf cd a5 1b			call macro_forth_dsp_pop 
22c2				endm 
# End of macro FORTH_DSP_POP
22c2					FORTH_DSP_POP 
22c2 cd a5 1b			call macro_forth_dsp_pop 
22c5				endm 
# End of macro FORTH_DSP_POP
22c5					NEXTW 
22c5 c3 5f 1c			jp macro_next 
22c8				endm 
# End of macro NEXTW
22c8			.SWAP2: 
22c8				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
22c8 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
22c9 f1 22			dw .AT            
22cb 06				db 5 + 1 
22cc .. 00			db "2SWAP",0              
22d2				endm 
# End of macro CWHEAD
22d2			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
22d2					if DEBUG_FORTH_WORDS_KEY 
22d2						DMARK "2SW" 
22d2 f5				push af  
22d3 3a e7 22			ld a, (.dmark)  
22d6 32 bd fb			ld (debug_mark),a  
22d9 3a e8 22			ld a, (.dmark+1)  
22dc 32 be fb			ld (debug_mark+1),a  
22df 3a e9 22			ld a, (.dmark+2)  
22e2 32 bf fb			ld (debug_mark+2),a  
22e5 18 03			jr .pastdmark  
22e7 ..			.dmark: db "2SW"  
22ea f1			.pastdmark: pop af  
22eb			endm  
# End of macro DMARK
22eb						CALLMONITOR 
22eb cd d4 14			call break_point_state  
22ee				endm  
# End of macro CALLMONITOR
22ee					endif 
22ee					NEXTW 
22ee c3 5f 1c			jp macro_next 
22f1				endm 
# End of macro NEXTW
22f1			.AT: 
22f1				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
22f1 1f				db WORD_SYS_CORE+OPCODE_AT             
22f2 23 23			dw .CAT            
22f4 02				db 1 + 1 
22f5 .. 00			db "@",0              
22f7				endm 
# End of macro CWHEAD
22f7			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
22f7			 
22f7					if DEBUG_FORTH_WORDS_KEY 
22f7						DMARK "AT." 
22f7 f5				push af  
22f8 3a 0c 23			ld a, (.dmark)  
22fb 32 bd fb			ld (debug_mark),a  
22fe 3a 0d 23			ld a, (.dmark+1)  
2301 32 be fb			ld (debug_mark+1),a  
2304 3a 0e 23			ld a, (.dmark+2)  
2307 32 bf fb			ld (debug_mark+2),a  
230a 18 03			jr .pastdmark  
230c ..			.dmark: db "AT."  
230f f1			.pastdmark: pop af  
2310			endm  
# End of macro DMARK
2310						CALLMONITOR 
2310 cd d4 14			call break_point_state  
2313				endm  
# End of macro CALLMONITOR
2313					endif 
2313			.getbyteat:	 
2313					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2313 cd 09 1b			call macro_dsp_valuehl 
2316				endm 
# End of macro FORTH_DSP_VALUEHL
2316					 
2316			;		push hl 
2316				 
2316					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2316 cd a5 1b			call macro_forth_dsp_pop 
2319				endm 
# End of macro FORTH_DSP_POP
2319			 
2319			;		pop hl 
2319			 
2319 7e					ld a, (hl) 
231a			 
231a 6f					ld l, a 
231b 26 00				ld h, 0 
231d cd 6e 1a				call forth_push_numhl 
2320			 
2320					NEXTW 
2320 c3 5f 1c			jp macro_next 
2323				endm 
# End of macro NEXTW
2323			.CAT: 
2323				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2323 20				db WORD_SYS_CORE+OPCODE_CAT             
2324 4c 23			dw .BANG            
2326 03				db 2 + 1 
2327 .. 00			db "C@",0              
232a				endm 
# End of macro CWHEAD
232a			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
232a					if DEBUG_FORTH_WORDS_KEY 
232a						DMARK "CAA" 
232a f5				push af  
232b 3a 3f 23			ld a, (.dmark)  
232e 32 bd fb			ld (debug_mark),a  
2331 3a 40 23			ld a, (.dmark+1)  
2334 32 be fb			ld (debug_mark+1),a  
2337 3a 41 23			ld a, (.dmark+2)  
233a 32 bf fb			ld (debug_mark+2),a  
233d 18 03			jr .pastdmark  
233f ..			.dmark: db "CAA"  
2342 f1			.pastdmark: pop af  
2343			endm  
# End of macro DMARK
2343						CALLMONITOR 
2343 cd d4 14			call break_point_state  
2346				endm  
# End of macro CALLMONITOR
2346					endif 
2346 c3 13 23				jp .getbyteat 
2349					NEXTW 
2349 c3 5f 1c			jp macro_next 
234c				endm 
# End of macro NEXTW
234c			.BANG: 
234c				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
234c 21				db WORD_SYS_CORE+OPCODE_BANG             
234d 82 23			dw .CBANG            
234f 02				db 1 + 1 
2350 .. 00			db "!",0              
2352				endm 
# End of macro CWHEAD
2352			; | ! ( x w -- ) Store x at address w      | DONE 
2352					if DEBUG_FORTH_WORDS_KEY 
2352						DMARK "BNG" 
2352 f5				push af  
2353 3a 67 23			ld a, (.dmark)  
2356 32 bd fb			ld (debug_mark),a  
2359 3a 68 23			ld a, (.dmark+1)  
235c 32 be fb			ld (debug_mark+1),a  
235f 3a 69 23			ld a, (.dmark+2)  
2362 32 bf fb			ld (debug_mark+2),a  
2365 18 03			jr .pastdmark  
2367 ..			.dmark: db "BNG"  
236a f1			.pastdmark: pop af  
236b			endm  
# End of macro DMARK
236b						CALLMONITOR 
236b cd d4 14			call break_point_state  
236e				endm  
# End of macro CALLMONITOR
236e					endif 
236e			 
236e			.storebyteat:		 
236e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
236e cd 09 1b			call macro_dsp_valuehl 
2371				endm 
# End of macro FORTH_DSP_VALUEHL
2371					 
2371 e5					push hl 
2372				 
2372					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2372 cd a5 1b			call macro_forth_dsp_pop 
2375				endm 
# End of macro FORTH_DSP_POP
2375			 
2375					; get byte to poke 
2375			 
2375					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2375 cd 09 1b			call macro_dsp_valuehl 
2378				endm 
# End of macro FORTH_DSP_VALUEHL
2378 e5					push hl 
2379			 
2379			 
2379					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2379 cd a5 1b			call macro_forth_dsp_pop 
237c				endm 
# End of macro FORTH_DSP_POP
237c			 
237c			 
237c d1					pop de 
237d e1					pop hl 
237e			 
237e 73					ld (hl),e 
237f			 
237f			 
237f					NEXTW 
237f c3 5f 1c			jp macro_next 
2382				endm 
# End of macro NEXTW
2382			.CBANG: 
2382				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2382 22				db WORD_SYS_CORE+OPCODE_CBANG             
2383 ab 23			dw .SCALL            
2385 03				db 2 + 1 
2386 .. 00			db "C!",0              
2389				endm 
# End of macro CWHEAD
2389			; | C!  ( x w -- ) Store x at address w  | DONE 
2389					if DEBUG_FORTH_WORDS_KEY 
2389						DMARK "CBA" 
2389 f5				push af  
238a 3a 9e 23			ld a, (.dmark)  
238d 32 bd fb			ld (debug_mark),a  
2390 3a 9f 23			ld a, (.dmark+1)  
2393 32 be fb			ld (debug_mark+1),a  
2396 3a a0 23			ld a, (.dmark+2)  
2399 32 bf fb			ld (debug_mark+2),a  
239c 18 03			jr .pastdmark  
239e ..			.dmark: db "CBA"  
23a1 f1			.pastdmark: pop af  
23a2			endm  
# End of macro DMARK
23a2						CALLMONITOR 
23a2 cd d4 14			call break_point_state  
23a5				endm  
# End of macro CALLMONITOR
23a5					endif 
23a5 c3 6e 23				jp .storebyteat 
23a8					NEXTW 
23a8 c3 5f 1c			jp macro_next 
23ab				endm 
# End of macro NEXTW
23ab			.SCALL: 
23ab				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
23ab 23				db WORD_SYS_CORE+OPCODE_SCALL             
23ac df 23			dw .DEPTH            
23ae 05				db 4 + 1 
23af .. 00			db "CALL",0              
23b4				endm 
# End of macro CWHEAD
23b4			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
23b4					if DEBUG_FORTH_WORDS_KEY 
23b4						DMARK "CLL" 
23b4 f5				push af  
23b5 3a c9 23			ld a, (.dmark)  
23b8 32 bd fb			ld (debug_mark),a  
23bb 3a ca 23			ld a, (.dmark+1)  
23be 32 be fb			ld (debug_mark+1),a  
23c1 3a cb 23			ld a, (.dmark+2)  
23c4 32 bf fb			ld (debug_mark+2),a  
23c7 18 03			jr .pastdmark  
23c9 ..			.dmark: db "CLL"  
23cc f1			.pastdmark: pop af  
23cd			endm  
# End of macro DMARK
23cd						CALLMONITOR 
23cd cd d4 14			call break_point_state  
23d0				endm  
# End of macro CALLMONITOR
23d0					endif 
23d0			 
23d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23d0 cd 09 1b			call macro_dsp_valuehl 
23d3				endm 
# End of macro FORTH_DSP_VALUEHL
23d3			 
23d3			;		push hl 
23d3			 
23d3					; destroy value TOS 
23d3			 
23d3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23d3 cd a5 1b			call macro_forth_dsp_pop 
23d6				endm 
# End of macro FORTH_DSP_POP
23d6			 
23d6						 
23d6			;		pop hl 
23d6			 
23d6					; how to do a call with hl???? save SP? 
23d6 cd 08 1c				call forth_call_hl 
23d9			 
23d9			 
23d9					; TODO push value back onto stack for another op etc 
23d9			 
23d9 cd 6e 1a				call forth_push_numhl 
23dc					NEXTW 
23dc c3 5f 1c			jp macro_next 
23df				endm 
# End of macro NEXTW
23df			.DEPTH: 
23df				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
23df 24				db WORD_SYS_CORE+OPCODE_DEPTH             
23e0 1c 24			dw .OVER            
23e2 06				db 5 + 1 
23e3 .. 00			db "DEPTH",0              
23e9				endm 
# End of macro CWHEAD
23e9			; | DEPTH ( -- u ) Push count of stack | DONE 
23e9					; take current TOS and remove from base value div by two to get count 
23e9					if DEBUG_FORTH_WORDS_KEY 
23e9						DMARK "DEP" 
23e9 f5				push af  
23ea 3a fe 23			ld a, (.dmark)  
23ed 32 bd fb			ld (debug_mark),a  
23f0 3a ff 23			ld a, (.dmark+1)  
23f3 32 be fb			ld (debug_mark+1),a  
23f6 3a 00 24			ld a, (.dmark+2)  
23f9 32 bf fb			ld (debug_mark+2),a  
23fc 18 03			jr .pastdmark  
23fe ..			.dmark: db "DEP"  
2401 f1			.pastdmark: pop af  
2402			endm  
# End of macro DMARK
2402						CALLMONITOR 
2402 cd d4 14			call break_point_state  
2405				endm  
# End of macro CALLMONITOR
2405					endif 
2405			 
2405			 
2405 2a a5 f9			ld hl, (cli_data_sp) 
2408 11 1f f5			ld de, cli_data_stack 
240b ed 52			sbc hl,de 
240d				 
240d				; div by size of stack item 
240d			 
240d 5d				ld e,l 
240e 0e 03			ld c, 3 
2410 cd 4c 0c			call Div8 
2413			 
2413 6f				ld l,a 
2414 26 00			ld h,0 
2416			 
2416				;srl h 
2416				;rr l 
2416			 
2416 cd 6e 1a				call forth_push_numhl 
2419					NEXTW 
2419 c3 5f 1c			jp macro_next 
241c				endm 
# End of macro NEXTW
241c			.OVER: 
241c				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
241c 42				db WORD_SYS_CORE+46             
241d 63 24			dw .PAUSE            
241f 05				db 4 + 1 
2420 .. 00			db "OVER",0              
2425				endm 
# End of macro CWHEAD
2425			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2425					if DEBUG_FORTH_WORDS_KEY 
2425						DMARK "OVR" 
2425 f5				push af  
2426 3a 3a 24			ld a, (.dmark)  
2429 32 bd fb			ld (debug_mark),a  
242c 3a 3b 24			ld a, (.dmark+1)  
242f 32 be fb			ld (debug_mark+1),a  
2432 3a 3c 24			ld a, (.dmark+2)  
2435 32 bf fb			ld (debug_mark+2),a  
2438 18 03			jr .pastdmark  
243a ..			.dmark: db "OVR"  
243d f1			.pastdmark: pop af  
243e			endm  
# End of macro DMARK
243e						CALLMONITOR 
243e cd d4 14			call break_point_state  
2441				endm  
# End of macro CALLMONITOR
2441					endif 
2441			 
2441					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2441 cd 09 1b			call macro_dsp_valuehl 
2444				endm 
# End of macro FORTH_DSP_VALUEHL
2444 e5					push hl    ; n2 
2445					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2445 cd a5 1b			call macro_forth_dsp_pop 
2448				endm 
# End of macro FORTH_DSP_POP
2448			 
2448					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2448 cd 09 1b			call macro_dsp_valuehl 
244b				endm 
# End of macro FORTH_DSP_VALUEHL
244b e5					push hl    ; n1 
244c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
244c cd a5 1b			call macro_forth_dsp_pop 
244f				endm 
# End of macro FORTH_DSP_POP
244f			 
244f d1					pop de     ; n1 
2450 e1					pop hl     ; n2 
2451			 
2451 d5					push de 
2452 e5					push hl 
2453 d5					push de 
2454			 
2454					; push back  
2454			 
2454 e1					pop hl 
2455 cd 6e 1a				call forth_push_numhl 
2458 e1					pop hl 
2459 cd 6e 1a				call forth_push_numhl 
245c e1					pop hl 
245d cd 6e 1a				call forth_push_numhl 
2460					NEXTW 
2460 c3 5f 1c			jp macro_next 
2463				endm 
# End of macro NEXTW
2463			 
2463			.PAUSE: 
2463				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2463 43				db WORD_SYS_CORE+47             
2464 98 24			dw .PAUSES            
2466 08				db 7 + 1 
2467 .. 00			db "PAUSEMS",0              
246f				endm 
# End of macro CWHEAD
246f			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
246f					if DEBUG_FORTH_WORDS_KEY 
246f						DMARK "PMS" 
246f f5				push af  
2470 3a 84 24			ld a, (.dmark)  
2473 32 bd fb			ld (debug_mark),a  
2476 3a 85 24			ld a, (.dmark+1)  
2479 32 be fb			ld (debug_mark+1),a  
247c 3a 86 24			ld a, (.dmark+2)  
247f 32 bf fb			ld (debug_mark+2),a  
2482 18 03			jr .pastdmark  
2484 ..			.dmark: db "PMS"  
2487 f1			.pastdmark: pop af  
2488			endm  
# End of macro DMARK
2488						CALLMONITOR 
2488 cd d4 14			call break_point_state  
248b				endm  
# End of macro CALLMONITOR
248b					endif 
248b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
248b cd 09 1b			call macro_dsp_valuehl 
248e				endm 
# End of macro FORTH_DSP_VALUEHL
248e			;		push hl    ; n2 
248e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
248e cd a5 1b			call macro_forth_dsp_pop 
2491				endm 
# End of macro FORTH_DSP_POP
2491			;		pop hl 
2491			 
2491 7d					ld a, l 
2492 cd 1f 0a				call aDelayInMS 
2495				       NEXTW 
2495 c3 5f 1c			jp macro_next 
2498				endm 
# End of macro NEXTW
2498			.PAUSES:  
2498				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2498 44				db WORD_SYS_CORE+48             
2499 07 25			dw .ROT            
249b 06				db 5 + 1 
249c .. 00			db "PAUSE",0              
24a2				endm 
# End of macro CWHEAD
24a2			; | PAUSE ( n -- )  Pause for n seconds | DONE 
24a2					if DEBUG_FORTH_WORDS_KEY 
24a2						DMARK "PAU" 
24a2 f5				push af  
24a3 3a b7 24			ld a, (.dmark)  
24a6 32 bd fb			ld (debug_mark),a  
24a9 3a b8 24			ld a, (.dmark+1)  
24ac 32 be fb			ld (debug_mark+1),a  
24af 3a b9 24			ld a, (.dmark+2)  
24b2 32 bf fb			ld (debug_mark+2),a  
24b5 18 03			jr .pastdmark  
24b7 ..			.dmark: db "PAU"  
24ba f1			.pastdmark: pop af  
24bb			endm  
# End of macro DMARK
24bb						CALLMONITOR 
24bb cd d4 14			call break_point_state  
24be				endm  
# End of macro CALLMONITOR
24be					endif 
24be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24be cd 09 1b			call macro_dsp_valuehl 
24c1				endm 
# End of macro FORTH_DSP_VALUEHL
24c1			;		push hl    ; n2 
24c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24c1 cd a5 1b			call macro_forth_dsp_pop 
24c4				endm 
# End of macro FORTH_DSP_POP
24c4			;		pop hl 
24c4 45					ld b, l 
24c5					if DEBUG_FORTH_WORDS 
24c5						DMARK "PAU" 
24c5 f5				push af  
24c6 3a da 24			ld a, (.dmark)  
24c9 32 bd fb			ld (debug_mark),a  
24cc 3a db 24			ld a, (.dmark+1)  
24cf 32 be fb			ld (debug_mark+1),a  
24d2 3a dc 24			ld a, (.dmark+2)  
24d5 32 bf fb			ld (debug_mark+2),a  
24d8 18 03			jr .pastdmark  
24da ..			.dmark: db "PAU"  
24dd f1			.pastdmark: pop af  
24de			endm  
# End of macro DMARK
24de						CALLMONITOR 
24de cd d4 14			call break_point_state  
24e1				endm  
# End of macro CALLMONITOR
24e1					endif 
24e1 c5			.pauses1:	push bc 
24e2 cd 3a 0a				call delay1s 
24e5 c1					pop bc 
24e6					if DEBUG_FORTH_WORDS 
24e6						DMARK "PA1" 
24e6 f5				push af  
24e7 3a fb 24			ld a, (.dmark)  
24ea 32 bd fb			ld (debug_mark),a  
24ed 3a fc 24			ld a, (.dmark+1)  
24f0 32 be fb			ld (debug_mark+1),a  
24f3 3a fd 24			ld a, (.dmark+2)  
24f6 32 bf fb			ld (debug_mark+2),a  
24f9 18 03			jr .pastdmark  
24fb ..			.dmark: db "PA1"  
24fe f1			.pastdmark: pop af  
24ff			endm  
# End of macro DMARK
24ff						CALLMONITOR 
24ff cd d4 14			call break_point_state  
2502				endm  
# End of macro CALLMONITOR
2502					endif 
2502 10 dd				djnz .pauses1 
2504			 
2504				       NEXTW 
2504 c3 5f 1c			jp macro_next 
2507				endm 
# End of macro NEXTW
2507			.ROT: 
2507				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2507 45				db WORD_SYS_CORE+49             
2508 55 25			dw .UWORDS            
250a 04				db 3 + 1 
250b .. 00			db "ROT",0              
250f				endm 
# End of macro CWHEAD
250f			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
250f					if DEBUG_FORTH_WORDS_KEY 
250f						DMARK "ROT" 
250f f5				push af  
2510 3a 24 25			ld a, (.dmark)  
2513 32 bd fb			ld (debug_mark),a  
2516 3a 25 25			ld a, (.dmark+1)  
2519 32 be fb			ld (debug_mark+1),a  
251c 3a 26 25			ld a, (.dmark+2)  
251f 32 bf fb			ld (debug_mark+2),a  
2522 18 03			jr .pastdmark  
2524 ..			.dmark: db "ROT"  
2527 f1			.pastdmark: pop af  
2528			endm  
# End of macro DMARK
2528						CALLMONITOR 
2528 cd d4 14			call break_point_state  
252b				endm  
# End of macro CALLMONITOR
252b					endif 
252b			 
252b					FORTH_DSP_VALUEHL 
252b cd 09 1b			call macro_dsp_valuehl 
252e				endm 
# End of macro FORTH_DSP_VALUEHL
252e e5					push hl    ; u3  
252f			 
252f					FORTH_DSP_POP 
252f cd a5 1b			call macro_forth_dsp_pop 
2532				endm 
# End of macro FORTH_DSP_POP
2532			   
2532					FORTH_DSP_VALUEHL 
2532 cd 09 1b			call macro_dsp_valuehl 
2535				endm 
# End of macro FORTH_DSP_VALUEHL
2535 e5					push hl     ; u2 
2536			 
2536					FORTH_DSP_POP 
2536 cd a5 1b			call macro_forth_dsp_pop 
2539				endm 
# End of macro FORTH_DSP_POP
2539			 
2539					FORTH_DSP_VALUEHL 
2539 cd 09 1b			call macro_dsp_valuehl 
253c				endm 
# End of macro FORTH_DSP_VALUEHL
253c e5					push hl     ; u1 
253d			 
253d					FORTH_DSP_POP 
253d cd a5 1b			call macro_forth_dsp_pop 
2540				endm 
# End of macro FORTH_DSP_POP
2540			 
2540 c1					pop bc      ; u1 
2541 e1					pop hl      ; u2 
2542 d1					pop de      ; u3 
2543			 
2543			 
2543 c5					push bc 
2544 d5					push de 
2545 e5					push hl 
2546			 
2546			 
2546 e1					pop hl 
2547 cd 6e 1a				call forth_push_numhl 
254a			 
254a e1					pop hl 
254b cd 6e 1a				call forth_push_numhl 
254e			 
254e e1					pop hl 
254f cd 6e 1a				call forth_push_numhl 
2552					 
2552			 
2552			 
2552			 
2552			 
2552			 
2552				       NEXTW 
2552 c3 5f 1c			jp macro_next 
2555				endm 
# End of macro NEXTW
2555			 
2555			.UWORDS: 
2555				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2555 50				db WORD_SYS_CORE+60             
2556 17 26			dw .BP            
2558 07				db 6 + 1 
2559 .. 00			db "UWORDS",0              
2560				endm 
# End of macro CWHEAD
2560			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2560			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2560			; | | Following the count are the individual words. 
2560			; | | 
2560			; | | e.g. UWORDS 
2560			; | | BOX DIRLIST 2 
2560			; | |  
2560			; | | Can be used to save the words to storage via: 
2560			; | | UWORDS $01 DO $01 APPEND LOOP 
2560				if DEBUG_FORTH_WORDS_KEY 
2560					DMARK "UWR" 
2560 f5				push af  
2561 3a 75 25			ld a, (.dmark)  
2564 32 bd fb			ld (debug_mark),a  
2567 3a 76 25			ld a, (.dmark+1)  
256a 32 be fb			ld (debug_mark+1),a  
256d 3a 77 25			ld a, (.dmark+2)  
2570 32 bf fb			ld (debug_mark+2),a  
2573 18 03			jr .pastdmark  
2575 ..			.dmark: db "UWR"  
2578 f1			.pastdmark: pop af  
2579			endm  
# End of macro DMARK
2579					CALLMONITOR 
2579 cd d4 14			call break_point_state  
257c				endm  
# End of macro CALLMONITOR
257c				endif 
257c 21 00 80				ld hl, baseram 
257f					;ld hl, baseusermem 
257f 01 00 00				ld bc, 0    ; start a counter 
2582			 
2582				; skip dict stub 
2582			 
2582 cd b0 1d				call forth_tok_next 
2585			 
2585			 
2585			; while we have words to look for 
2585			 
2585 7e			.douscan:	ld a, (hl)      
2586				if DEBUG_FORTH_WORDS 
2586					DMARK "UWs" 
2586 f5				push af  
2587 3a 9b 25			ld a, (.dmark)  
258a 32 bd fb			ld (debug_mark),a  
258d 3a 9c 25			ld a, (.dmark+1)  
2590 32 be fb			ld (debug_mark+1),a  
2593 3a 9d 25			ld a, (.dmark+2)  
2596 32 bf fb			ld (debug_mark+2),a  
2599 18 03			jr .pastdmark  
259b ..			.dmark: db "UWs"  
259e f1			.pastdmark: pop af  
259f			endm  
# End of macro DMARK
259f					CALLMONITOR 
259f cd d4 14			call break_point_state  
25a2				endm  
# End of macro CALLMONITOR
25a2				endif 
25a2 fe 00				cp WORD_SYS_END 
25a4 28 4d				jr z, .udone 
25a6 fe 01				cp WORD_SYS_UWORD 
25a8 20 44				jr nz, .nuword 
25aa			 
25aa				if DEBUG_FORTH_WORDS 
25aa					DMARK "UWu" 
25aa f5				push af  
25ab 3a bf 25			ld a, (.dmark)  
25ae 32 bd fb			ld (debug_mark),a  
25b1 3a c0 25			ld a, (.dmark+1)  
25b4 32 be fb			ld (debug_mark+1),a  
25b7 3a c1 25			ld a, (.dmark+2)  
25ba 32 bf fb			ld (debug_mark+2),a  
25bd 18 03			jr .pastdmark  
25bf ..			.dmark: db "UWu"  
25c2 f1			.pastdmark: pop af  
25c3			endm  
# End of macro DMARK
25c3					CALLMONITOR 
25c3 cd d4 14			call break_point_state  
25c6				endm  
# End of macro CALLMONITOR
25c6				endif 
25c6					; we have a uword so push its name to the stack 
25c6			 
25c6 e5				   	push hl  ; save so we can move to next dict block 
25c7			 
25c7					; skip opcode 
25c7 23					inc hl  
25c8					; skip next ptr 
25c8 23					inc hl  
25c9 23					inc hl 
25ca					; skip len 
25ca 23					inc hl 
25cb				if DEBUG_FORTH_WORDS 
25cb					DMARK "UWt" 
25cb f5				push af  
25cc 3a e0 25			ld a, (.dmark)  
25cf 32 bd fb			ld (debug_mark),a  
25d2 3a e1 25			ld a, (.dmark+1)  
25d5 32 be fb			ld (debug_mark+1),a  
25d8 3a e2 25			ld a, (.dmark+2)  
25db 32 bf fb			ld (debug_mark+2),a  
25de 18 03			jr .pastdmark  
25e0 ..			.dmark: db "UWt"  
25e3 f1			.pastdmark: pop af  
25e4			endm  
# End of macro DMARK
25e4					CALLMONITOR 
25e4 cd d4 14			call break_point_state  
25e7				endm  
# End of macro CALLMONITOR
25e7				endif 
25e7 03					inc bc 
25e8			 
25e8 c5					push bc 
25e9 cd 80 1a				call forth_push_str 
25ec c1					pop bc 
25ed			 
25ed e1					pop hl 	 
25ee			 
25ee cd b0 1d		.nuword:	call forth_tok_next 
25f1 18 92				jr .douscan  
25f3			 
25f3			.udone:		 ; push count of uwords found 
25f3 c5					push bc 
25f4 e1					pop hl 
25f5			 
25f5				if DEBUG_FORTH_WORDS 
25f5					DMARK "UWc" 
25f5 f5				push af  
25f6 3a 0a 26			ld a, (.dmark)  
25f9 32 bd fb			ld (debug_mark),a  
25fc 3a 0b 26			ld a, (.dmark+1)  
25ff 32 be fb			ld (debug_mark+1),a  
2602 3a 0c 26			ld a, (.dmark+2)  
2605 32 bf fb			ld (debug_mark+2),a  
2608 18 03			jr .pastdmark  
260a ..			.dmark: db "UWc"  
260d f1			.pastdmark: pop af  
260e			endm  
# End of macro DMARK
260e					CALLMONITOR 
260e cd d4 14			call break_point_state  
2611				endm  
# End of macro CALLMONITOR
2611				endif 
2611 cd 6e 1a				call forth_push_numhl 
2614			 
2614			 
2614				       NEXTW 
2614 c3 5f 1c			jp macro_next 
2617				endm 
# End of macro NEXTW
2617			 
2617			.BP: 
2617				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2617 54				db WORD_SYS_CORE+64             
2618 4d 26			dw .MONITOR            
261a 03				db 2 + 1 
261b .. 00			db "BP",0              
261e				endm 
# End of macro CWHEAD
261e			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
261e			; | | $00 Will enable the break points within specific code paths 
261e			; | | $01 Will disable break points 
261e			; | |  
261e			; | | By default break points are off. Either the above can be used to enable them 
261e			; | | or if a key is held down during start up the spashscreen will appear to freeze 
261e			; | | and on release of the pressed key a message will be disaplayed to notify 
261e			; | | that break points are enabled. Pressing any key will then continue boot process. 
261e					; get byte count 
261e					if DEBUG_FORTH_WORDS_KEY 
261e						DMARK "BP." 
261e f5				push af  
261f 3a 33 26			ld a, (.dmark)  
2622 32 bd fb			ld (debug_mark),a  
2625 3a 34 26			ld a, (.dmark+1)  
2628 32 be fb			ld (debug_mark+1),a  
262b 3a 35 26			ld a, (.dmark+2)  
262e 32 bf fb			ld (debug_mark+2),a  
2631 18 03			jr .pastdmark  
2633 ..			.dmark: db "BP."  
2636 f1			.pastdmark: pop af  
2637			endm  
# End of macro DMARK
2637						CALLMONITOR 
2637 cd d4 14			call break_point_state  
263a				endm  
# End of macro CALLMONITOR
263a					endif 
263a			 
263a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
263a cd 09 1b			call macro_dsp_valuehl 
263d				endm 
# End of macro FORTH_DSP_VALUEHL
263d			 
263d			;		push hl 
263d			 
263d					; destroy value TOS 
263d			 
263d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
263d cd a5 1b			call macro_forth_dsp_pop 
2640				endm 
# End of macro FORTH_DSP_POP
2640			 
2640			;		pop hl 
2640			 
2640 3e 00				ld a,0 
2642 bd					cp l 
2643 28 02				jr z, .bpset 
2645 3e 2a				ld a, '*' 
2647			 
2647 32 b7 ef		.bpset:		ld (os_view_disable), a 
264a			 
264a			 
264a					NEXTW 
264a c3 5f 1c			jp macro_next 
264d				endm 
# End of macro NEXTW
264d			 
264d			 
264d			.MONITOR: 
264d				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
264d 55				db WORD_SYS_CORE+65             
264e 80 26			dw .MALLOC            
2650 08				db 7 + 1 
2651 .. 00			db "MONITOR",0              
2659				endm 
# End of macro CWHEAD
2659			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2659			; | | At start the current various registers will be displayed with contents. 
2659			; | | Top right corner will show the most recent debug marker seen. 
2659			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2659			; | | and the return stack pointer (RSP). 
2659			; | | Pressing: 
2659			; | |    1 - Initial screen 
2659			; | |    2 - Display a data dump of HL 
2659			; | |    3 - Display a data dump of DE 
2659			; | |    4 - Display a data dump of BC 
2659			; | |    5 - Display a data dump of HL 
2659			; | |    6 - Display a data dump of DSP 
2659			; | |    7 - Display a data dump of RSP 
2659			; | |    8 - Display a data dump of what is at DSP 
2659			; | |    9 - Display a data dump of what is at RSP 
2659			; | |    0 - Exit monitor and continue running. This will also enable break points 
2659			; | |    * - Disable break points 
2659			; | |    # - Enter traditional monitor mode 
2659			; | | 
2659			; | | Monitor Mode 
2659			; | | ------------ 
2659			; | | A prompt of '>' will be shown for various commands: 
2659			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2659			; | |    C - Continue display a data dump from the last set address 
2659			; | |    M xxxx - Set start of memory edit at address xx 
2659			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2659			; | |    Q - Return to previous 
2659					if DEBUG_FORTH_WORDS_KEY 
2659						DMARK "MON" 
2659 f5				push af  
265a 3a 6e 26			ld a, (.dmark)  
265d 32 bd fb			ld (debug_mark),a  
2660 3a 6f 26			ld a, (.dmark+1)  
2663 32 be fb			ld (debug_mark+1),a  
2666 3a 70 26			ld a, (.dmark+2)  
2669 32 bf fb			ld (debug_mark+2),a  
266c 18 03			jr .pastdmark  
266e ..			.dmark: db "MON"  
2671 f1			.pastdmark: pop af  
2672			endm  
# End of macro DMARK
2672						CALLMONITOR 
2672 cd d4 14			call break_point_state  
2675				endm  
# End of macro CALLMONITOR
2675					endif 
2675 3e 00				ld a, 0 
2677 32 b7 ef				ld (os_view_disable), a 
267a			 
267a					CALLMONITOR 
267a cd d4 14			call break_point_state  
267d				endm  
# End of macro CALLMONITOR
267d			 
267d			;	call monitor 
267d			 
267d					NEXTW 
267d c3 5f 1c			jp macro_next 
2680				endm 
# End of macro NEXTW
2680			 
2680			 
2680			.MALLOC: 
2680				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2680 56				db WORD_SYS_CORE+66             
2681 a9 26			dw .MALLOC2            
2683 06				db 5 + 1 
2684 .. 00			db "ALLOT",0              
268a				endm 
# End of macro CWHEAD
268a			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
268a					if DEBUG_FORTH_WORDS_KEY 
268a						DMARK "ALL" 
268a f5				push af  
268b 3a 9f 26			ld a, (.dmark)  
268e 32 bd fb			ld (debug_mark),a  
2691 3a a0 26			ld a, (.dmark+1)  
2694 32 be fb			ld (debug_mark+1),a  
2697 3a a1 26			ld a, (.dmark+2)  
269a 32 bf fb			ld (debug_mark+2),a  
269d 18 03			jr .pastdmark  
269f ..			.dmark: db "ALL"  
26a2 f1			.pastdmark: pop af  
26a3			endm  
# End of macro DMARK
26a3						CALLMONITOR 
26a3 cd d4 14			call break_point_state  
26a6				endm  
# End of macro CALLMONITOR
26a6					endif 
26a6 c3 d0 26				jp .mallocc 
26a9			.MALLOC2: 
26a9				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
26a9 56				db WORD_SYS_CORE+66             
26aa e7 26			dw .FREE            
26ac 07				db 6 + 1 
26ad .. 00			db "MALLOC",0              
26b4				endm 
# End of macro CWHEAD
26b4			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
26b4					; get byte count 
26b4					if DEBUG_FORTH_WORDS_KEY 
26b4						DMARK "MAL" 
26b4 f5				push af  
26b5 3a c9 26			ld a, (.dmark)  
26b8 32 bd fb			ld (debug_mark),a  
26bb 3a ca 26			ld a, (.dmark+1)  
26be 32 be fb			ld (debug_mark+1),a  
26c1 3a cb 26			ld a, (.dmark+2)  
26c4 32 bf fb			ld (debug_mark+2),a  
26c7 18 03			jr .pastdmark  
26c9 ..			.dmark: db "MAL"  
26cc f1			.pastdmark: pop af  
26cd			endm  
# End of macro DMARK
26cd						CALLMONITOR 
26cd cd d4 14			call break_point_state  
26d0				endm  
# End of macro CALLMONITOR
26d0					endif 
26d0			.mallocc: 
26d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26d0 cd 09 1b			call macro_dsp_valuehl 
26d3				endm 
# End of macro FORTH_DSP_VALUEHL
26d3			 
26d3			;		push hl 
26d3			 
26d3					; destroy value TOS 
26d3			 
26d3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26d3 cd a5 1b			call macro_forth_dsp_pop 
26d6				endm 
# End of macro FORTH_DSP_POP
26d6			 
26d6			;		pop hl 
26d6 cd 83 11				call malloc 
26d9				if DEBUG_FORTH_MALLOC_GUARD 
26d9 f5					push af 
26da cd e5 0c				call ishlzero 
26dd			;		ld a, l 
26dd			;		add h 
26dd			;		cp 0 
26dd f1					pop af 
26de					 
26de cc e2 4e				call z,malloc_error 
26e1				endif 
26e1			 
26e1 cd 6e 1a				call forth_push_numhl 
26e4					NEXTW 
26e4 c3 5f 1c			jp macro_next 
26e7				endm 
# End of macro NEXTW
26e7			 
26e7			.FREE: 
26e7				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
26e7 57				db WORD_SYS_CORE+67             
26e8 18 27			dw .LIST            
26ea 05				db 4 + 1 
26eb .. 00			db "FREE",0              
26f0				endm 
# End of macro CWHEAD
26f0			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
26f0					if DEBUG_FORTH_WORDS_KEY 
26f0						DMARK "FRE" 
26f0 f5				push af  
26f1 3a 05 27			ld a, (.dmark)  
26f4 32 bd fb			ld (debug_mark),a  
26f7 3a 06 27			ld a, (.dmark+1)  
26fa 32 be fb			ld (debug_mark+1),a  
26fd 3a 07 27			ld a, (.dmark+2)  
2700 32 bf fb			ld (debug_mark+2),a  
2703 18 03			jr .pastdmark  
2705 ..			.dmark: db "FRE"  
2708 f1			.pastdmark: pop af  
2709			endm  
# End of macro DMARK
2709						CALLMONITOR 
2709 cd d4 14			call break_point_state  
270c				endm  
# End of macro CALLMONITOR
270c					endif 
270c					; get address 
270c			 
270c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
270c cd 09 1b			call macro_dsp_valuehl 
270f				endm 
# End of macro FORTH_DSP_VALUEHL
270f			 
270f			;		push hl 
270f			 
270f					; destroy value TOS 
270f			 
270f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
270f cd a5 1b			call macro_forth_dsp_pop 
2712				endm 
# End of macro FORTH_DSP_POP
2712			 
2712			;		pop hl 
2712			if FORTH_ENABLE_MALLOCFREE 
2712 cd 4d 12				call free 
2715			endif 
2715					NEXTW 
2715 c3 5f 1c			jp macro_next 
2718				endm 
# End of macro NEXTW
2718			.LIST: 
2718				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2718 5c				db WORD_SYS_CORE+72             
2719 db 28			dw .FORGET            
271b 05				db 4 + 1 
271c .. 00			db "LIST",0              
2721				endm 
# End of macro CWHEAD
2721			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2721			; | | The quoted word must be in upper case. 
2721				if DEBUG_FORTH_WORDS_KEY 
2721					DMARK "LST" 
2721 f5				push af  
2722 3a 36 27			ld a, (.dmark)  
2725 32 bd fb			ld (debug_mark),a  
2728 3a 37 27			ld a, (.dmark+1)  
272b 32 be fb			ld (debug_mark+1),a  
272e 3a 38 27			ld a, (.dmark+2)  
2731 32 bf fb			ld (debug_mark+2),a  
2734 18 03			jr .pastdmark  
2736 ..			.dmark: db "LST"  
2739 f1			.pastdmark: pop af  
273a			endm  
# End of macro DMARK
273a					CALLMONITOR 
273a cd d4 14			call break_point_state  
273d				endm  
# End of macro CALLMONITOR
273d				endif 
273d			 
273d					FORTH_DSP_VALUEHL 
273d cd 09 1b			call macro_dsp_valuehl 
2740				endm 
# End of macro FORTH_DSP_VALUEHL
2740			 
2740 e5					push hl 
2741 c1					pop bc 
2742			 
2742			; Start format of scratch string 
2742			 
2742 21 b8 ef				ld hl, scratch 
2745			 
2745 3e 3a				ld a, ':' 
2747 77					ld (hl),a 
2748 23					inc hl 
2749 3e 20				ld a, ' ' 
274b 77					ld (hl), a 
274c			 
274c					; Get ptr to the word we need to look up 
274c			 
274c			;		FORTH_DSP_VALUEHL 
274c					;v5 FORTH_DSP_VALUE 
274c				; TODO type check 
274c			;		inc hl    ; Skip type check  
274c			;		push hl 
274c			;		ex de, hl    ; put into DE 
274c			 
274c			 
274c 21 00 80				ld hl, baseram 
274f					;ld hl, baseusermem 
274f			 
274f e5			push hl   ; sacreifical push 
2750			 
2750			.ldouscanm: 
2750 e1				pop hl 
2751			.ldouscan: 
2751				if DEBUG_FORTH_WORDS 
2751					DMARK "LSs" 
2751 f5				push af  
2752 3a 66 27			ld a, (.dmark)  
2755 32 bd fb			ld (debug_mark),a  
2758 3a 67 27			ld a, (.dmark+1)  
275b 32 be fb			ld (debug_mark+1),a  
275e 3a 68 27			ld a, (.dmark+2)  
2761 32 bf fb			ld (debug_mark+2),a  
2764 18 03			jr .pastdmark  
2766 ..			.dmark: db "LSs"  
2769 f1			.pastdmark: pop af  
276a			endm  
# End of macro DMARK
276a					CALLMONITOR 
276a cd d4 14			call break_point_state  
276d				endm  
# End of macro CALLMONITOR
276d				endif 
276d				; skip dict stub 
276d cd b0 1d				call forth_tok_next 
2770			 
2770			 
2770			; while we have words to look for 
2770			 
2770 7e				ld a, (hl)      
2771				if DEBUG_FORTH_WORDS 
2771					DMARK "LSk" 
2771 f5				push af  
2772 3a 86 27			ld a, (.dmark)  
2775 32 bd fb			ld (debug_mark),a  
2778 3a 87 27			ld a, (.dmark+1)  
277b 32 be fb			ld (debug_mark+1),a  
277e 3a 88 27			ld a, (.dmark+2)  
2781 32 bf fb			ld (debug_mark+2),a  
2784 18 03			jr .pastdmark  
2786 ..			.dmark: db "LSk"  
2789 f1			.pastdmark: pop af  
278a			endm  
# End of macro DMARK
278a					CALLMONITOR 
278a cd d4 14			call break_point_state  
278d				endm  
# End of macro CALLMONITOR
278d				endif 
278d fe 00				cp WORD_SYS_END 
278f ca c2 28				jp z, .lunotfound 
2792 fe 01				cp WORD_SYS_UWORD 
2794 c2 51 27				jp nz, .ldouscan 
2797			 
2797				if DEBUG_FORTH_WORDS 
2797					DMARK "LSu" 
2797 f5				push af  
2798 3a ac 27			ld a, (.dmark)  
279b 32 bd fb			ld (debug_mark),a  
279e 3a ad 27			ld a, (.dmark+1)  
27a1 32 be fb			ld (debug_mark+1),a  
27a4 3a ae 27			ld a, (.dmark+2)  
27a7 32 bf fb			ld (debug_mark+2),a  
27aa 18 03			jr .pastdmark  
27ac ..			.dmark: db "LSu"  
27af f1			.pastdmark: pop af  
27b0			endm  
# End of macro DMARK
27b0					CALLMONITOR 
27b0 cd d4 14			call break_point_state  
27b3				endm  
# End of macro CALLMONITOR
27b3				endif 
27b3			 
27b3					; found a uword but is it the one we want... 
27b3			 
27b3 c5					push bc     ; uword to find is on bc 
27b4 d1					pop de 
27b5			 
27b5 e5					push hl  ; to save the ptr 
27b6			 
27b6					; skip opcode 
27b6 23					inc hl  
27b7					; skip next ptr 
27b7 23					inc hl  
27b8 23					inc hl 
27b9					; skip len 
27b9 23					inc hl 
27ba			 
27ba				if DEBUG_FORTH_WORDS 
27ba					DMARK "LSc" 
27ba f5				push af  
27bb 3a cf 27			ld a, (.dmark)  
27be 32 bd fb			ld (debug_mark),a  
27c1 3a d0 27			ld a, (.dmark+1)  
27c4 32 be fb			ld (debug_mark+1),a  
27c7 3a d1 27			ld a, (.dmark+2)  
27ca 32 bf fb			ld (debug_mark+2),a  
27cd 18 03			jr .pastdmark  
27cf ..			.dmark: db "LSc"  
27d2 f1			.pastdmark: pop af  
27d3			endm  
# End of macro DMARK
27d3					CALLMONITOR 
27d3 cd d4 14			call break_point_state  
27d6				endm  
# End of macro CALLMONITOR
27d6				endif 
27d6 cd 52 11				call strcmp 
27d9 c2 50 27				jp nz, .ldouscanm 
27dc				 
27dc			 
27dc			 
27dc					; we have a uword so push its name to the stack 
27dc			 
27dc			;	   	push hl  ; save so we can move to next dict block 
27dc e1			pop hl 
27dd			 
27dd				if DEBUG_FORTH_WORDS 
27dd					DMARK "LSm" 
27dd f5				push af  
27de 3a f2 27			ld a, (.dmark)  
27e1 32 bd fb			ld (debug_mark),a  
27e4 3a f3 27			ld a, (.dmark+1)  
27e7 32 be fb			ld (debug_mark+1),a  
27ea 3a f4 27			ld a, (.dmark+2)  
27ed 32 bf fb			ld (debug_mark+2),a  
27f0 18 03			jr .pastdmark  
27f2 ..			.dmark: db "LSm"  
27f5 f1			.pastdmark: pop af  
27f6			endm  
# End of macro DMARK
27f6					CALLMONITOR 
27f6 cd d4 14			call break_point_state  
27f9				endm  
# End of macro CALLMONITOR
27f9				endif 
27f9			 
27f9					; skip opcode 
27f9 23					inc hl  
27fa					; skip next ptr 
27fa 23					inc hl  
27fb 23					inc hl 
27fc					; skip len 
27fc 7e					ld a, (hl)   ; save length to add 
27fd				if DEBUG_FORTH_WORDS 
27fd					DMARK "LS2" 
27fd f5				push af  
27fe 3a 12 28			ld a, (.dmark)  
2801 32 bd fb			ld (debug_mark),a  
2804 3a 13 28			ld a, (.dmark+1)  
2807 32 be fb			ld (debug_mark+1),a  
280a 3a 14 28			ld a, (.dmark+2)  
280d 32 bf fb			ld (debug_mark+2),a  
2810 18 03			jr .pastdmark  
2812 ..			.dmark: db "LS2"  
2815 f1			.pastdmark: pop af  
2816			endm  
# End of macro DMARK
2816					CALLMONITOR 
2816 cd d4 14			call break_point_state  
2819				endm  
# End of macro CALLMONITOR
2819				endif 
2819			 
2819					; save this location 
2819				 
2819 e5					push hl 
281a			 
281a 23					inc hl 
281b 11 ba ef				ld de, scratch+2 
281e 4f					ld c, a 
281f 06 00				ld b, 0 
2821			 
2821				if DEBUG_FORTH_WORDS 
2821					DMARK "LSn" 
2821 f5				push af  
2822 3a 36 28			ld a, (.dmark)  
2825 32 bd fb			ld (debug_mark),a  
2828 3a 37 28			ld a, (.dmark+1)  
282b 32 be fb			ld (debug_mark+1),a  
282e 3a 38 28			ld a, (.dmark+2)  
2831 32 bf fb			ld (debug_mark+2),a  
2834 18 03			jr .pastdmark  
2836 ..			.dmark: db "LSn"  
2839 f1			.pastdmark: pop af  
283a			endm  
# End of macro DMARK
283a					CALLMONITOR 
283a cd d4 14			call break_point_state  
283d				endm  
# End of macro CALLMONITOR
283d				endif 
283d			 
283d					; copy uword name to scratch 
283d			 
283d ed b0				ldir 
283f			 
283f 1b					dec de 
2840 3e 20				ld a, ' '    ; change null to space 
2842 12					ld (de), a 
2843			 
2843 13					inc de 
2844			 
2844 d5					push de 
2845 c1					pop bc     ; move scratch pointer to end of word name and save it 
2846			 
2846 e1					pop hl 
2847 7e					ld a, (hl) 
2848					;inc hl 
2848					; skip word string 
2848 cd bc 0c				call addatohl 
284b			 
284b 23					inc hl 
284c			 
284c				if DEBUG_FORTH_WORDS 
284c					DMARK "LS3" 
284c f5				push af  
284d 3a 61 28			ld a, (.dmark)  
2850 32 bd fb			ld (debug_mark),a  
2853 3a 62 28			ld a, (.dmark+1)  
2856 32 be fb			ld (debug_mark+1),a  
2859 3a 63 28			ld a, (.dmark+2)  
285c 32 bf fb			ld (debug_mark+2),a  
285f 18 03			jr .pastdmark  
2861 ..			.dmark: db "LS3"  
2864 f1			.pastdmark: pop af  
2865			endm  
# End of macro DMARK
2865					CALLMONITOR 
2865 cd d4 14			call break_point_state  
2868				endm  
# End of macro CALLMONITOR
2868				endif 
2868					; should now be at the start of the machine code to setup the eval of the uword 
2868					; now locate the ptr to the string defintion 
2868			 
2868					; skip ld hl, 
2868					; then load the ptr 
2868			 
2868 23					inc hl 
2869 5e					ld e, (hl) 
286a 23					inc hl 
286b 56					ld d, (hl) 
286c eb					ex de, hl 
286d			 
286d			 
286d				if DEBUG_FORTH_WORDS 
286d					DMARK "LSt" 
286d f5				push af  
286e 3a 82 28			ld a, (.dmark)  
2871 32 bd fb			ld (debug_mark),a  
2874 3a 83 28			ld a, (.dmark+1)  
2877 32 be fb			ld (debug_mark+1),a  
287a 3a 84 28			ld a, (.dmark+2)  
287d 32 bf fb			ld (debug_mark+2),a  
2880 18 03			jr .pastdmark  
2882 ..			.dmark: db "LSt"  
2885 f1			.pastdmark: pop af  
2886			endm  
# End of macro DMARK
2886					CALLMONITOR 
2886 cd d4 14			call break_point_state  
2889				endm  
# End of macro CALLMONITOR
2889				endif 
2889			 
2889			; cant push right now due to tokenised strings  
2889			 
2889			; get the destination of where to copy this definition to. 
2889			 
2889 c5					push bc 
288a d1					pop de 
288b			 
288b 7e			.listl:         ld a,(hl) 
288c fe 00				cp 0 
288e 28 09				jr z, .lreplsp     ; replace zero with space 
2890 fe 7f				cp FORTH_END_BUFFER 
2892 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2894				 
2894					; just copy this char as is then 
2894			 
2894 12					ld (de), a 
2895			 
2895 23			.listnxt:	inc hl 
2896 13					inc de 
2897 18 f2				jr .listl 
2899			 
2899 3e 20		.lreplsp:	ld a,' ' 
289b 12					ld (de), a 
289c 18 f7				jr .listnxt 
289e			 
289e			; close up uword def 
289e			 
289e			.listdone: 
289e 3e 00				ld a, 0 
28a0 12					ld (de), a 
28a1			 
28a1			; now have def so clean up and push to stack 
28a1			 
28a1 21 b8 ef				ld hl, scratch 
28a4				if DEBUG_FORTH_WORDS 
28a4					DMARK "Ltp" 
28a4 f5				push af  
28a5 3a b9 28			ld a, (.dmark)  
28a8 32 bd fb			ld (debug_mark),a  
28ab 3a ba 28			ld a, (.dmark+1)  
28ae 32 be fb			ld (debug_mark+1),a  
28b1 3a bb 28			ld a, (.dmark+2)  
28b4 32 bf fb			ld (debug_mark+2),a  
28b7 18 03			jr .pastdmark  
28b9 ..			.dmark: db "Ltp"  
28bc f1			.pastdmark: pop af  
28bd			endm  
# End of macro DMARK
28bd					CALLMONITOR 
28bd cd d4 14			call break_point_state  
28c0				endm  
# End of macro CALLMONITOR
28c0				endif 
28c0			 
28c0 18 06			jr .listpush 
28c2			 
28c2			;.lnuword:	pop hl 
28c2			;		call forth_tok_next 
28c2			;		jp .ldouscan  
28c2			 
28c2			.lunotfound:		  
28c2			 
28c2			 
28c2					 
28c2					FORTH_DSP_POP 
28c2 cd a5 1b			call macro_forth_dsp_pop 
28c5				endm 
# End of macro FORTH_DSP_POP
28c5 21 ce 28				ld hl, .luno 
28c8						 
28c8			 
28c8			.listpush: 
28c8 cd 80 1a				call forth_push_str 
28cb			 
28cb			 
28cb			 
28cb					NEXTW 
28cb c3 5f 1c			jp macro_next 
28ce				endm 
# End of macro NEXTW
28ce			 
28ce .. 00		.luno:    db "Not found",0 
28d8			 
28d8			 
28d8			 
28d8			 
28d8			 
28d8			;		push hl   ; save pointer to start of uword def string 
28d8			; 
28d8			;; look for FORTH_EOL_LINE 
28d8			;		ld a, FORTH_END_BUFFER 
28d8			;		call strlent 
28d8			; 
28d8			;		inc hl		 ; space for coln def 
28d8			;		inc hl 
28d8			;		inc hl          ; space for terms 
28d8			;		inc hl 
28d8			; 
28d8			;		ld a, 20   ; TODO get actual length 
28d8			;		call addatohl    ; include a random amount of room for the uword name 
28d8			; 
28d8			;		 
28d8			;	if DEBUG_FORTH_WORDS 
28d8			;		DMARK "Lt1" 
28d8			;		CALLMONITOR 
28d8			;	endif 
28d8			;		 
28d8			; 
28d8			;; malloc space for the string because we cant change it 
28d8			; 
28d8			;		call malloc 
28d8			;	if DEBUG_FORTH_MALLOC_GUARD 
28d8			;		push af 
28d8			;		call ishlzero 
28d8			;		pop af 
28d8			;		 
28d8			;		call z,malloc_error 
28d8			;	endif 
28d8			; 
28d8			;	if DEBUG_FORTH_WORDS 
28d8			;		DMARK "Lt2" 
28d8			;		CALLMONITOR 
28d8			;	endif 
28d8			;		pop de 
28d8			;		push hl    ; push the malloc to release later 
28d8			;		push hl   ;  push back a copy for the later stack push 
28d8			;		 
28d8			;; copy the string swapping out the zero terms for spaces 
28d8			; 
28d8			;		; de has our source 
28d8			;		; hl has our dest 
28d8			; 
28d8			;; add the coln def 
28d8			; 
28d8			;		ld a, ':' 
28d8			;		ld (hl), a 
28d8			;		inc hl 
28d8			;		ld a, ' ' 
28d8			;		ld (hl), a 
28d8			;		inc hl 
28d8			; 
28d8			;; add the uname word 
28d8			;		push de   ; save our string for now 
28d8			;		ex de, hl 
28d8			; 
28d8			;		FORTH_DSP_VALUE 
28d8			;		;v5 FORTH_DSP_VALUE 
28d8			; 
28d8			;		inc hl   ; skip type but we know by now this is OK 
28d8			; 
28d8			;.luword:	ld a,(hl) 
28d8			;		cp 0 
28d8			;		jr z, .luword2 
28d8			;		ld (de), a 
28d8			;		inc de 
28d8			;		inc hl 
28d8			;		jr .luword 
28d8			; 
28d8			;.luword2:	ld a, ' ' 
28d8			;		ld (de), a 
28d8			;;		inc hl 
28d8			;;		inc de 
28d8			;;		ld (de), a 
28d8			;;		inc hl 
28d8			;		inc de 
28d8			; 
28d8			;		ex de, hl 
28d8			;		pop de 
28d8			;		 
28d8			;		 
28d8			; 
28d8			;; detoken that string and copy it 
28d8			; 
28d8			;	if DEBUG_FORTH_WORDS 
28d8			;		DMARK "Lt2" 
28d8			;		CALLMONITOR 
28d8			;	endif 
28d8			;.ldetok:	ld a, (de) 
28d8			;		cp FORTH_END_BUFFER 
28d8			;		jr z, .ldetokend 
28d8			;		; swap out any zero term for space 
28d8			;		cp 0 
28d8			;		jr nz, .ldetoknext 
28d8			;		ld a, ' ' 
28d8			; 
28d8			;	if DEBUG_FORTH_WORDS 
28d8			;		DMARK "LtS" 
28d8			;		CALLMONITOR 
28d8			;	endif 
28d8			;.ldetoknext:	ld (hl), a 
28d8			;		inc de 
28d8			;		inc hl 
28d8			;		jr .ldetok 
28d8			; 
28d8			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
28d8			;		ld (hl), a  
28d8			; 
28d8			;; free that temp malloc 
28d8			; 
28d8			;		pop hl    
28d8			; 
28d8			;	if DEBUG_FORTH_WORDS 
28d8			;		DMARK "Lt4" 
28d8			;		CALLMONITOR 
28d8			;	endif 
28d8			;		call forth_apushstrhl 
28d8			; 
28d8			;		; get rid of temp malloc area 
28d8			; 
28d8			;		pop hl 
28d8			;		call free 
28d8			; 
28d8			;		jr .ludone 
28d8			; 
28d8			;.lnuword:	pop hl 
28d8			;		call forth_tok_next 
28d8			;		jp .ldouscan  
28d8			; 
28d8			;.ludone:		 pop hl 
28d8			; 
28d8					NEXTW 
28d8 c3 5f 1c			jp macro_next 
28db				endm 
# End of macro NEXTW
28db			 
28db			.FORGET: 
28db				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
28db 5d				db WORD_SYS_CORE+73             
28dc 54 29			dw .NOP            
28de 07				db 6 + 1 
28df .. 00			db "FORGET",0              
28e6				endm 
# End of macro CWHEAD
28e6			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
28e6			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
28e6			; | |  
28e6			; | | e.g. "MORE" forget 
28e6					if DEBUG_FORTH_WORDS_KEY 
28e6						DMARK "FRG" 
28e6 f5				push af  
28e7 3a fb 28			ld a, (.dmark)  
28ea 32 bd fb			ld (debug_mark),a  
28ed 3a fc 28			ld a, (.dmark+1)  
28f0 32 be fb			ld (debug_mark+1),a  
28f3 3a fd 28			ld a, (.dmark+2)  
28f6 32 bf fb			ld (debug_mark+2),a  
28f9 18 03			jr .pastdmark  
28fb ..			.dmark: db "FRG"  
28fe f1			.pastdmark: pop af  
28ff			endm  
# End of macro DMARK
28ff						CALLMONITOR 
28ff cd d4 14			call break_point_state  
2902				endm  
# End of macro CALLMONITOR
2902					endif 
2902			 
2902				; find uword 
2902			        ; update start of word with "_" 
2902				; replace uword with deleted flag 
2902			 
2902			 
2902			;	if DEBUG_FORTH_WORDS 
2902			;		DMARK "FOG" 
2902			;		CALLMONITOR 
2902			;	endif 
2902			 
2902			 
2902					; Get ptr to the word we need to look up 
2902			 
2902					FORTH_DSP_VALUEHL 
2902 cd 09 1b			call macro_dsp_valuehl 
2905				endm 
# End of macro FORTH_DSP_VALUEHL
2905					;v5 FORTH_DSP_VALUE 
2905				; TODO type check 
2905			;		inc hl    ; Skip type check  
2905 e5					push hl 
2906 c1					pop bc 
2907			;		ex de, hl    ; put into DE 
2907			 
2907			 
2907 21 00 80				ld hl, baseram 
290a					;ld hl, baseusermem 
290a			 
290a				; skip dict stub 
290a			;	call forth_tok_next 
290a e5			push hl   ; sacreifical push 
290b			 
290b			.fldouscanm: 
290b e1				pop hl 
290c			.fldouscan: 
290c			;	if DEBUG_FORTH_WORDS 
290c			;		DMARK "LSs" 
290c			;		CALLMONITOR 
290c			;	endif 
290c				; skip dict stub 
290c cd b0 1d				call forth_tok_next 
290f			 
290f			 
290f			; while we have words to look for 
290f			 
290f 7e				ld a, (hl)      
2910			;	if DEBUG_FORTH_WORDS 
2910			;		DMARK "LSk" 
2910			;		CALLMONITOR 
2910			;	endif 
2910 fe 00				cp WORD_SYS_END 
2912 ca 4e 29				jp z, .flunotfound 
2915 fe 01				cp WORD_SYS_UWORD 
2917 c2 0c 29				jp nz, .fldouscan 
291a			 
291a			;	if DEBUG_FORTH_WORDS 
291a			;		DMARK "LSu" 
291a			;		CALLMONITOR 
291a			;	endif 
291a			 
291a					; found a uword but is it the one we want... 
291a			 
291a c5					push bc     ; uword to find is on bc 
291b d1					pop de 
291c			 
291c e5					push hl  ; to save the ptr 
291d			 
291d					; skip opcode 
291d 23					inc hl  
291e					; skip next ptr 
291e 23					inc hl  
291f 23					inc hl 
2920					; skip len 
2920 23					inc hl 
2921			 
2921			;	if DEBUG_FORTH_WORDS 
2921			;		DMARK "LSc" 
2921			;		CALLMONITOR 
2921			;	endif 
2921 cd 52 11				call strcmp 
2924 c2 0b 29				jp nz, .fldouscanm 
2927			; 
2927			; 
2927			;; while we have words to look for 
2927			; 
2927			;.fdouscan:	ld a, (hl)      
2927			;	if DEBUG_FORTH_WORDS 
2927			;		DMARK "LSs" 
2927			;		CALLMONITOR 
2927			;	endif 
2927			;		cp WORD_SYS_END 
2927			;		jp z, .fudone 
2927			;		cp WORD_SYS_UWORD 
2927			;		jp nz, .fnuword 
2927			; 
2927			;	if DEBUG_FORTH_WORDS 
2927			;		DMARK "FGu" 
2927			;		CALLMONITOR 
2927			;	endif 
2927			; 
2927			;		; found a uword but is it the one we want... 
2927			; 
2927			; 
2927			;	        pop de   ; get back the dsp name 
2927			;		push de 
2927			; 
2927			;		push hl  ; to save the ptr 
2927			; 
2927			;		; skip opcode 
2927			;		inc hl  
2927			;		; skip next ptr 
2927			;		inc hl  
2927			;		inc hl 
2927			;		; skip len 
2927			;		inc hl 
2927			; 
2927			;	if DEBUG_FORTH_WORDS 
2927			;		DMARK "FGc" 
2927			;		CALLMONITOR 
2927			;	endif 
2927			;		call strcmp 
2927			;		jp nz, .fnuword 
2927			 
2927			 
2927 e1			pop hl 
2928			 
2928				 
2928				if DEBUG_FORTH_WORDS 
2928					DMARK "FGm" 
2928 f5				push af  
2929 3a 3d 29			ld a, (.dmark)  
292c 32 bd fb			ld (debug_mark),a  
292f 3a 3e 29			ld a, (.dmark+1)  
2932 32 be fb			ld (debug_mark+1),a  
2935 3a 3f 29			ld a, (.dmark+2)  
2938 32 bf fb			ld (debug_mark+2),a  
293b 18 03			jr .pastdmark  
293d ..			.dmark: db "FGm"  
2940 f1			.pastdmark: pop af  
2941			endm  
# End of macro DMARK
2941					CALLMONITOR 
2941 cd d4 14			call break_point_state  
2944				endm  
# End of macro CALLMONITOR
2944				endif 
2944			 
2944			 
2944			 
2944					; we have a uword so push its name to the stack 
2944			 
2944			;	   	push hl  ; save so we can move to next dict block 
2944			;pop hl 
2944			 
2944					; update opcode to deleted 
2944 3e 03				ld a, WORD_SYS_DELETED 
2946 77					ld (hl), a 
2947			 
2947 23					inc hl  
2948					; skip next ptr 
2948 23					inc hl  
2949 23					inc hl 
294a					; skip len 
294a 23					inc hl 
294b			 
294b					; TODO change parser to skip deleted words but for now mark it out 
294b 3e 5f				ld a, "_" 
294d 77					ld  (hl),a 
294e			 
294e			;		jr .fudone 
294e			; 
294e			;.fnuword:	pop hl 
294e			;		call forth_tok_next 
294e			;		jp .fdouscan  
294e			 
294e			.flunotfound:		  
294e			 
294e			 
294e					 
294e					FORTH_DSP_POP 
294e cd a5 1b			call macro_forth_dsp_pop 
2951				endm 
# End of macro FORTH_DSP_POP
2951			;		ld hl, .luno 
2951			;.fudone:		 pop hl 
2951					NEXTW 
2951 c3 5f 1c			jp macro_next 
2954				endm 
# End of macro NEXTW
2954			.NOP: 
2954				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2954 61				db WORD_SYS_CORE+77             
2955 7b 29			dw .COMO            
2957 04				db 3 + 1 
2958 .. 00			db "NOP",0              
295c				endm 
# End of macro CWHEAD
295c			; | NOP (  --  ) Do nothing | DONE 
295c					if DEBUG_FORTH_WORDS_KEY 
295c						DMARK "NOP" 
295c f5				push af  
295d 3a 71 29			ld a, (.dmark)  
2960 32 bd fb			ld (debug_mark),a  
2963 3a 72 29			ld a, (.dmark+1)  
2966 32 be fb			ld (debug_mark+1),a  
2969 3a 73 29			ld a, (.dmark+2)  
296c 32 bf fb			ld (debug_mark+2),a  
296f 18 03			jr .pastdmark  
2971 ..			.dmark: db "NOP"  
2974 f1			.pastdmark: pop af  
2975			endm  
# End of macro DMARK
2975						CALLMONITOR 
2975 cd d4 14			call break_point_state  
2978				endm  
# End of macro CALLMONITOR
2978					endif 
2978				       NEXTW 
2978 c3 5f 1c			jp macro_next 
297b				endm 
# End of macro NEXTW
297b			.COMO: 
297b				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
297b 6e				db WORD_SYS_CORE+90             
297c cd 29			dw .COMC            
297e 02				db 1 + 1 
297f .. 00			db "(",0              
2981				endm 
# End of macro CWHEAD
2981			; | ( ( -- )  Start of comment | DONE 
2981			 
2981			 
2981 2a b9 f2				ld hl, ( os_tok_ptr) 
2984 11 c8 29			ld de, .closepar 
2987					 
2987					if DEBUG_FORTH_WORDS 
2987						DMARK ").." 
2987 f5				push af  
2988 3a 9c 29			ld a, (.dmark)  
298b 32 bd fb			ld (debug_mark),a  
298e 3a 9d 29			ld a, (.dmark+1)  
2991 32 be fb			ld (debug_mark+1),a  
2994 3a 9e 29			ld a, (.dmark+2)  
2997 32 bf fb			ld (debug_mark+2),a  
299a 18 03			jr .pastdmark  
299c ..			.dmark: db ").."  
299f f1			.pastdmark: pop af  
29a0			endm  
# End of macro DMARK
29a0						CALLMONITOR 
29a0 cd d4 14			call break_point_state  
29a3				endm  
# End of macro CALLMONITOR
29a3					endif 
29a3 cd 7a 1d			call findnexttok  
29a6			 
29a6					if DEBUG_FORTH_WORDS 
29a6						DMARK "IF5" 
29a6 f5				push af  
29a7 3a bb 29			ld a, (.dmark)  
29aa 32 bd fb			ld (debug_mark),a  
29ad 3a bc 29			ld a, (.dmark+1)  
29b0 32 be fb			ld (debug_mark+1),a  
29b3 3a bd 29			ld a, (.dmark+2)  
29b6 32 bf fb			ld (debug_mark+2),a  
29b9 18 03			jr .pastdmark  
29bb ..			.dmark: db "IF5"  
29be f1			.pastdmark: pop af  
29bf			endm  
# End of macro DMARK
29bf						CALLMONITOR 
29bf cd d4 14			call break_point_state  
29c2				endm  
# End of macro CALLMONITOR
29c2					endif 
29c2				; replace below with ) exec using tok_ptr 
29c2 22 b9 f2			ld (os_tok_ptr), hl 
29c5 c3 f0 1c			jp exec1 
29c8			 
29c8 .. 00			.closepar:   db ")",0 
29ca			 
29ca				       NEXTW 
29ca c3 5f 1c			jp macro_next 
29cd				endm 
# End of macro NEXTW
29cd			.COMC: 
29cd				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
29cd 6f				db WORD_SYS_CORE+91             
29ce d6 29			dw .SCRATCH            
29d0 02				db 1 + 1 
29d1 .. 00			db ")",0              
29d3				endm 
# End of macro CWHEAD
29d3			; | ) ( -- )  End of comment |  DONE  
29d3				       NEXTW 
29d3 c3 5f 1c			jp macro_next 
29d6				endm 
# End of macro NEXTW
29d6			 
29d6			.SCRATCH: 
29d6				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
29d6 6f				db WORD_SYS_CORE+91             
29d7 11 2a			dw .INC            
29d9 08				db 7 + 1 
29da .. 00			db "SCRATCH",0              
29e2				endm 
# End of macro CWHEAD
29e2			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
29e2			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
29e2			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
29e2			; | |  
29e2			; | | e.g.    : score $00 scratch ; 
29e2			; | |  
29e2			; | | $00 score ! 
29e2			; | | $01 score +! 
29e2			; | |  
29e2			; | | e.g.   : varword $0a scratch ;  
29e2			; | | 
29e2			; | | $8000 varword ! 
29e2					if DEBUG_FORTH_WORDS_KEY 
29e2						DMARK "SCR" 
29e2 f5				push af  
29e3 3a f7 29			ld a, (.dmark)  
29e6 32 bd fb			ld (debug_mark),a  
29e9 3a f8 29			ld a, (.dmark+1)  
29ec 32 be fb			ld (debug_mark+1),a  
29ef 3a f9 29			ld a, (.dmark+2)  
29f2 32 bf fb			ld (debug_mark+2),a  
29f5 18 03			jr .pastdmark  
29f7 ..			.dmark: db "SCR"  
29fa f1			.pastdmark: pop af  
29fb			endm  
# End of macro DMARK
29fb						CALLMONITOR 
29fb cd d4 14			call break_point_state  
29fe				endm  
# End of macro CALLMONITOR
29fe					endif 
29fe			 
29fe					FORTH_DSP_VALUEHL 
29fe cd 09 1b			call macro_dsp_valuehl 
2a01				endm 
# End of macro FORTH_DSP_VALUEHL
2a01				 
2a01					FORTH_DSP_POP 
2a01 cd a5 1b			call macro_forth_dsp_pop 
2a04				endm 
# End of macro FORTH_DSP_POP
2a04			 
2a04 7d					ld a, l 
2a05 21 dd f4				ld hl, os_var_array 
2a08 cd bc 0c				call addatohl 
2a0b			 
2a0b cd 6e 1a				call forth_push_numhl 
2a0e			 
2a0e				       NEXTW 
2a0e c3 5f 1c			jp macro_next 
2a11				endm 
# End of macro NEXTW
2a11			 
2a11			.INC: 
2a11				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2a11 6f				db WORD_SYS_CORE+91             
2a12 65 2a			dw .DEC            
2a14 03				db 2 + 1 
2a15 .. 00			db "+!",0              
2a18				endm 
# End of macro CWHEAD
2a18			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2a18					if DEBUG_FORTH_WORDS_KEY 
2a18						DMARK "+s_" 
2a18 f5				push af  
2a19 3a 2d 2a			ld a, (.dmark)  
2a1c 32 bd fb			ld (debug_mark),a  
2a1f 3a 2e 2a			ld a, (.dmark+1)  
2a22 32 be fb			ld (debug_mark+1),a  
2a25 3a 2f 2a			ld a, (.dmark+2)  
2a28 32 bf fb			ld (debug_mark+2),a  
2a2b 18 03			jr .pastdmark  
2a2d ..			.dmark: db "+s_"  
2a30 f1			.pastdmark: pop af  
2a31			endm  
# End of macro DMARK
2a31						CALLMONITOR 
2a31 cd d4 14			call break_point_state  
2a34				endm  
# End of macro CALLMONITOR
2a34					endif 
2a34			 
2a34					FORTH_DSP_VALUEHL 
2a34 cd 09 1b			call macro_dsp_valuehl 
2a37				endm 
# End of macro FORTH_DSP_VALUEHL
2a37			 
2a37 e5					push hl   ; save address 
2a38			 
2a38					FORTH_DSP_POP 
2a38 cd a5 1b			call macro_forth_dsp_pop 
2a3b				endm 
# End of macro FORTH_DSP_POP
2a3b			 
2a3b					FORTH_DSP_VALUEHL 
2a3b cd 09 1b			call macro_dsp_valuehl 
2a3e				endm 
# End of macro FORTH_DSP_VALUEHL
2a3e			 
2a3e					FORTH_DSP_POP 
2a3e cd a5 1b			call macro_forth_dsp_pop 
2a41				endm 
# End of macro FORTH_DSP_POP
2a41			 
2a41					; hl contains value to add to byte at a 
2a41				 
2a41 eb					ex de, hl 
2a42			 
2a42 e1					pop hl 
2a43			 
2a43					if DEBUG_FORTH_WORDS 
2a43						DMARK "INC" 
2a43 f5				push af  
2a44 3a 58 2a			ld a, (.dmark)  
2a47 32 bd fb			ld (debug_mark),a  
2a4a 3a 59 2a			ld a, (.dmark+1)  
2a4d 32 be fb			ld (debug_mark+1),a  
2a50 3a 5a 2a			ld a, (.dmark+2)  
2a53 32 bf fb			ld (debug_mark+2),a  
2a56 18 03			jr .pastdmark  
2a58 ..			.dmark: db "INC"  
2a5b f1			.pastdmark: pop af  
2a5c			endm  
# End of macro DMARK
2a5c						CALLMONITOR 
2a5c cd d4 14			call break_point_state  
2a5f				endm  
# End of macro CALLMONITOR
2a5f					endif 
2a5f			 
2a5f 7e					ld a,(hl) 
2a60 83					add e 
2a61 77					ld (hl),a 
2a62			 
2a62			 
2a62			 
2a62				       NEXTW 
2a62 c3 5f 1c			jp macro_next 
2a65				endm 
# End of macro NEXTW
2a65			 
2a65			.DEC: 
2a65				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2a65 6f				db WORD_SYS_CORE+91             
2a66 b6 2a			dw .INC2            
2a68 03				db 2 + 1 
2a69 .. 00			db "-!",0              
2a6c				endm 
# End of macro CWHEAD
2a6c			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2a6c					if DEBUG_FORTH_WORDS_KEY 
2a6c						DMARK "-s_" 
2a6c f5				push af  
2a6d 3a 81 2a			ld a, (.dmark)  
2a70 32 bd fb			ld (debug_mark),a  
2a73 3a 82 2a			ld a, (.dmark+1)  
2a76 32 be fb			ld (debug_mark+1),a  
2a79 3a 83 2a			ld a, (.dmark+2)  
2a7c 32 bf fb			ld (debug_mark+2),a  
2a7f 18 03			jr .pastdmark  
2a81 ..			.dmark: db "-s_"  
2a84 f1			.pastdmark: pop af  
2a85			endm  
# End of macro DMARK
2a85						CALLMONITOR 
2a85 cd d4 14			call break_point_state  
2a88				endm  
# End of macro CALLMONITOR
2a88					endif 
2a88			 
2a88					FORTH_DSP_VALUEHL 
2a88 cd 09 1b			call macro_dsp_valuehl 
2a8b				endm 
# End of macro FORTH_DSP_VALUEHL
2a8b			 
2a8b e5					push hl   ; save address 
2a8c			 
2a8c					FORTH_DSP_POP 
2a8c cd a5 1b			call macro_forth_dsp_pop 
2a8f				endm 
# End of macro FORTH_DSP_POP
2a8f			 
2a8f					FORTH_DSP_VALUEHL 
2a8f cd 09 1b			call macro_dsp_valuehl 
2a92				endm 
# End of macro FORTH_DSP_VALUEHL
2a92			 
2a92					; hl contains value to add to byte at a 
2a92				 
2a92 eb					ex de, hl 
2a93			 
2a93 e1					pop hl 
2a94			 
2a94					if DEBUG_FORTH_WORDS 
2a94						DMARK "DEC" 
2a94 f5				push af  
2a95 3a a9 2a			ld a, (.dmark)  
2a98 32 bd fb			ld (debug_mark),a  
2a9b 3a aa 2a			ld a, (.dmark+1)  
2a9e 32 be fb			ld (debug_mark+1),a  
2aa1 3a ab 2a			ld a, (.dmark+2)  
2aa4 32 bf fb			ld (debug_mark+2),a  
2aa7 18 03			jr .pastdmark  
2aa9 ..			.dmark: db "DEC"  
2aac f1			.pastdmark: pop af  
2aad			endm  
# End of macro DMARK
2aad						CALLMONITOR 
2aad cd d4 14			call break_point_state  
2ab0				endm  
# End of macro CALLMONITOR
2ab0					endif 
2ab0			 
2ab0 7e					ld a,(hl) 
2ab1 93					sub e 
2ab2 77					ld (hl),a 
2ab3			 
2ab3			 
2ab3			 
2ab3				       NEXTW 
2ab3 c3 5f 1c			jp macro_next 
2ab6				endm 
# End of macro NEXTW
2ab6			 
2ab6			.INC2: 
2ab6				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2ab6 6f				db WORD_SYS_CORE+91             
2ab7 60 2b			dw .DEC2            
2ab9 04				db 3 + 1 
2aba .. 00			db "+2!",0              
2abe				endm 
# End of macro CWHEAD
2abe			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2abe			 
2abe					if DEBUG_FORTH_WORDS_KEY 
2abe						DMARK "+2s" 
2abe f5				push af  
2abf 3a d3 2a			ld a, (.dmark)  
2ac2 32 bd fb			ld (debug_mark),a  
2ac5 3a d4 2a			ld a, (.dmark+1)  
2ac8 32 be fb			ld (debug_mark+1),a  
2acb 3a d5 2a			ld a, (.dmark+2)  
2ace 32 bf fb			ld (debug_mark+2),a  
2ad1 18 03			jr .pastdmark  
2ad3 ..			.dmark: db "+2s"  
2ad6 f1			.pastdmark: pop af  
2ad7			endm  
# End of macro DMARK
2ad7						CALLMONITOR 
2ad7 cd d4 14			call break_point_state  
2ada				endm  
# End of macro CALLMONITOR
2ada					endif 
2ada			 
2ada					; Address 
2ada			 
2ada					FORTH_DSP_VALUEHL 
2ada cd 09 1b			call macro_dsp_valuehl 
2add				endm 
# End of macro FORTH_DSP_VALUEHL
2add			 
2add e5					push hl    ; save address 
2ade			 
2ade					; load content into de 
2ade			 
2ade 5e					ld e,(hl) 
2adf 23					inc hl 
2ae0 56					ld d, (hl) 
2ae1			 
2ae1					if DEBUG_FORTH_WORDS 
2ae1						DMARK "+2a" 
2ae1 f5				push af  
2ae2 3a f6 2a			ld a, (.dmark)  
2ae5 32 bd fb			ld (debug_mark),a  
2ae8 3a f7 2a			ld a, (.dmark+1)  
2aeb 32 be fb			ld (debug_mark+1),a  
2aee 3a f8 2a			ld a, (.dmark+2)  
2af1 32 bf fb			ld (debug_mark+2),a  
2af4 18 03			jr .pastdmark  
2af6 ..			.dmark: db "+2a"  
2af9 f1			.pastdmark: pop af  
2afa			endm  
# End of macro DMARK
2afa						CALLMONITOR 
2afa cd d4 14			call break_point_state  
2afd				endm  
# End of macro CALLMONITOR
2afd					endif 
2afd			 
2afd					FORTH_DSP_POP 
2afd cd a5 1b			call macro_forth_dsp_pop 
2b00				endm 
# End of macro FORTH_DSP_POP
2b00			 
2b00					; Get value to add 
2b00			 
2b00					FORTH_DSP_VALUE 
2b00 cd f2 1a			call macro_forth_dsp_value 
2b03				endm 
# End of macro FORTH_DSP_VALUE
2b03			 
2b03					if DEBUG_FORTH_WORDS 
2b03						DMARK "+2v" 
2b03 f5				push af  
2b04 3a 18 2b			ld a, (.dmark)  
2b07 32 bd fb			ld (debug_mark),a  
2b0a 3a 19 2b			ld a, (.dmark+1)  
2b0d 32 be fb			ld (debug_mark+1),a  
2b10 3a 1a 2b			ld a, (.dmark+2)  
2b13 32 bf fb			ld (debug_mark+2),a  
2b16 18 03			jr .pastdmark  
2b18 ..			.dmark: db "+2v"  
2b1b f1			.pastdmark: pop af  
2b1c			endm  
# End of macro DMARK
2b1c						CALLMONITOR 
2b1c cd d4 14			call break_point_state  
2b1f				endm  
# End of macro CALLMONITOR
2b1f					endif 
2b1f			 
2b1f 19					add hl, de 
2b20			 
2b20					if DEBUG_FORTH_WORDS 
2b20						DMARK "+2+" 
2b20 f5				push af  
2b21 3a 35 2b			ld a, (.dmark)  
2b24 32 bd fb			ld (debug_mark),a  
2b27 3a 36 2b			ld a, (.dmark+1)  
2b2a 32 be fb			ld (debug_mark+1),a  
2b2d 3a 37 2b			ld a, (.dmark+2)  
2b30 32 bf fb			ld (debug_mark+2),a  
2b33 18 03			jr .pastdmark  
2b35 ..			.dmark: db "+2+"  
2b38 f1			.pastdmark: pop af  
2b39			endm  
# End of macro DMARK
2b39						CALLMONITOR 
2b39 cd d4 14			call break_point_state  
2b3c				endm  
# End of macro CALLMONITOR
2b3c					endif 
2b3c			 
2b3c					; move result to de 
2b3c			 
2b3c eb					ex de, hl 
2b3d			 
2b3d					; Address 
2b3d			 
2b3d e1					pop hl 
2b3e			 
2b3e					; save it back 
2b3e			 
2b3e 73					ld (hl), e 
2b3f 23					inc hl 
2b40 72					ld (hl), d 
2b41			 
2b41					if DEBUG_FORTH_WORDS 
2b41						DMARK "+2e" 
2b41 f5				push af  
2b42 3a 56 2b			ld a, (.dmark)  
2b45 32 bd fb			ld (debug_mark),a  
2b48 3a 57 2b			ld a, (.dmark+1)  
2b4b 32 be fb			ld (debug_mark+1),a  
2b4e 3a 58 2b			ld a, (.dmark+2)  
2b51 32 bf fb			ld (debug_mark+2),a  
2b54 18 03			jr .pastdmark  
2b56 ..			.dmark: db "+2e"  
2b59 f1			.pastdmark: pop af  
2b5a			endm  
# End of macro DMARK
2b5a						CALLMONITOR 
2b5a cd d4 14			call break_point_state  
2b5d				endm  
# End of macro CALLMONITOR
2b5d					endif 
2b5d			 
2b5d			 
2b5d			 
2b5d			 
2b5d			 
2b5d				       NEXTW 
2b5d c3 5f 1c			jp macro_next 
2b60				endm 
# End of macro NEXTW
2b60			 
2b60			.DEC2: 
2b60				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2b60 6f				db WORD_SYS_CORE+91             
2b61 0c 2c			dw .GET2            
2b63 04				db 3 + 1 
2b64 .. 00			db "-2!",0              
2b68				endm 
# End of macro CWHEAD
2b68			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2b68			 
2b68			 
2b68					if DEBUG_FORTH_WORDS_KEY 
2b68						DMARK "-2s" 
2b68 f5				push af  
2b69 3a 7d 2b			ld a, (.dmark)  
2b6c 32 bd fb			ld (debug_mark),a  
2b6f 3a 7e 2b			ld a, (.dmark+1)  
2b72 32 be fb			ld (debug_mark+1),a  
2b75 3a 7f 2b			ld a, (.dmark+2)  
2b78 32 bf fb			ld (debug_mark+2),a  
2b7b 18 03			jr .pastdmark  
2b7d ..			.dmark: db "-2s"  
2b80 f1			.pastdmark: pop af  
2b81			endm  
# End of macro DMARK
2b81						CALLMONITOR 
2b81 cd d4 14			call break_point_state  
2b84				endm  
# End of macro CALLMONITOR
2b84					endif 
2b84			 
2b84					; Address 
2b84			 
2b84					FORTH_DSP_VALUEHL 
2b84 cd 09 1b			call macro_dsp_valuehl 
2b87				endm 
# End of macro FORTH_DSP_VALUEHL
2b87			 
2b87 e5					push hl    ; save address 
2b88			 
2b88					; load content into de 
2b88			 
2b88 5e					ld e,(hl) 
2b89 23					inc hl 
2b8a 56					ld d, (hl) 
2b8b			 
2b8b					if DEBUG_FORTH_WORDS 
2b8b						DMARK "-2a" 
2b8b f5				push af  
2b8c 3a a0 2b			ld a, (.dmark)  
2b8f 32 bd fb			ld (debug_mark),a  
2b92 3a a1 2b			ld a, (.dmark+1)  
2b95 32 be fb			ld (debug_mark+1),a  
2b98 3a a2 2b			ld a, (.dmark+2)  
2b9b 32 bf fb			ld (debug_mark+2),a  
2b9e 18 03			jr .pastdmark  
2ba0 ..			.dmark: db "-2a"  
2ba3 f1			.pastdmark: pop af  
2ba4			endm  
# End of macro DMARK
2ba4						CALLMONITOR 
2ba4 cd d4 14			call break_point_state  
2ba7				endm  
# End of macro CALLMONITOR
2ba7					endif 
2ba7			 
2ba7					FORTH_DSP_POP 
2ba7 cd a5 1b			call macro_forth_dsp_pop 
2baa				endm 
# End of macro FORTH_DSP_POP
2baa			 
2baa					; Get value to remove 
2baa			 
2baa					FORTH_DSP_VALUE 
2baa cd f2 1a			call macro_forth_dsp_value 
2bad				endm 
# End of macro FORTH_DSP_VALUE
2bad			 
2bad					if DEBUG_FORTH_WORDS 
2bad						DMARK "-2v" 
2bad f5				push af  
2bae 3a c2 2b			ld a, (.dmark)  
2bb1 32 bd fb			ld (debug_mark),a  
2bb4 3a c3 2b			ld a, (.dmark+1)  
2bb7 32 be fb			ld (debug_mark+1),a  
2bba 3a c4 2b			ld a, (.dmark+2)  
2bbd 32 bf fb			ld (debug_mark+2),a  
2bc0 18 03			jr .pastdmark  
2bc2 ..			.dmark: db "-2v"  
2bc5 f1			.pastdmark: pop af  
2bc6			endm  
# End of macro DMARK
2bc6						CALLMONITOR 
2bc6 cd d4 14			call break_point_state  
2bc9				endm  
# End of macro CALLMONITOR
2bc9					endif 
2bc9			 
2bc9 eb					ex de, hl 
2bca ed 52				sbc hl, de 
2bcc			 
2bcc					if DEBUG_FORTH_WORDS 
2bcc						DMARK "-2d" 
2bcc f5				push af  
2bcd 3a e1 2b			ld a, (.dmark)  
2bd0 32 bd fb			ld (debug_mark),a  
2bd3 3a e2 2b			ld a, (.dmark+1)  
2bd6 32 be fb			ld (debug_mark+1),a  
2bd9 3a e3 2b			ld a, (.dmark+2)  
2bdc 32 bf fb			ld (debug_mark+2),a  
2bdf 18 03			jr .pastdmark  
2be1 ..			.dmark: db "-2d"  
2be4 f1			.pastdmark: pop af  
2be5			endm  
# End of macro DMARK
2be5						CALLMONITOR 
2be5 cd d4 14			call break_point_state  
2be8				endm  
# End of macro CALLMONITOR
2be8					endif 
2be8			 
2be8					; move result to de 
2be8			 
2be8 eb					ex de, hl 
2be9			 
2be9					; Address 
2be9			 
2be9 e1					pop hl 
2bea			 
2bea					; save it back 
2bea			 
2bea 73					ld (hl), e 
2beb 23					inc hl 
2bec 72					ld (hl), d 
2bed			 
2bed					if DEBUG_FORTH_WORDS 
2bed						DMARK "-2e" 
2bed f5				push af  
2bee 3a 02 2c			ld a, (.dmark)  
2bf1 32 bd fb			ld (debug_mark),a  
2bf4 3a 03 2c			ld a, (.dmark+1)  
2bf7 32 be fb			ld (debug_mark+1),a  
2bfa 3a 04 2c			ld a, (.dmark+2)  
2bfd 32 bf fb			ld (debug_mark+2),a  
2c00 18 03			jr .pastdmark  
2c02 ..			.dmark: db "-2e"  
2c05 f1			.pastdmark: pop af  
2c06			endm  
# End of macro DMARK
2c06						CALLMONITOR 
2c06 cd d4 14			call break_point_state  
2c09				endm  
# End of macro CALLMONITOR
2c09					endif 
2c09			 
2c09			 
2c09			 
2c09			 
2c09			 
2c09				       NEXTW 
2c09 c3 5f 1c			jp macro_next 
2c0c				endm 
# End of macro NEXTW
2c0c			.GET2: 
2c0c				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2c0c 6f				db WORD_SYS_CORE+91             
2c0d 3c 2c			dw .BANG2            
2c0f 03				db 2 + 1 
2c10 .. 00			db "2@",0              
2c13				endm 
# End of macro CWHEAD
2c13			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2c13					if DEBUG_FORTH_WORDS_KEY 
2c13						DMARK "2A_" 
2c13 f5				push af  
2c14 3a 28 2c			ld a, (.dmark)  
2c17 32 bd fb			ld (debug_mark),a  
2c1a 3a 29 2c			ld a, (.dmark+1)  
2c1d 32 be fb			ld (debug_mark+1),a  
2c20 3a 2a 2c			ld a, (.dmark+2)  
2c23 32 bf fb			ld (debug_mark+2),a  
2c26 18 03			jr .pastdmark  
2c28 ..			.dmark: db "2A_"  
2c2b f1			.pastdmark: pop af  
2c2c			endm  
# End of macro DMARK
2c2c						CALLMONITOR 
2c2c cd d4 14			call break_point_state  
2c2f				endm  
# End of macro CALLMONITOR
2c2f					endif 
2c2f			 
2c2f					FORTH_DSP_VALUEHL 
2c2f cd 09 1b			call macro_dsp_valuehl 
2c32				endm 
# End of macro FORTH_DSP_VALUEHL
2c32			 
2c32 5e					ld e, (hl) 
2c33 23					inc hl 
2c34 56					ld d, (hl) 
2c35			 
2c35 eb					ex de, hl 
2c36			 
2c36 cd 6e 1a				call forth_push_numhl 
2c39			 
2c39				       NEXTW 
2c39 c3 5f 1c			jp macro_next 
2c3c				endm 
# End of macro NEXTW
2c3c			.BANG2: 
2c3c				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2c3c 6f				db WORD_SYS_CORE+91             
2c3d 74 2c			dw .CONFIG            
2c3f 03				db 2 + 1 
2c40 .. 00			db "2!",0              
2c43				endm 
# End of macro CWHEAD
2c43			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2c43					if DEBUG_FORTH_WORDS_KEY 
2c43						DMARK "2S_" 
2c43 f5				push af  
2c44 3a 58 2c			ld a, (.dmark)  
2c47 32 bd fb			ld (debug_mark),a  
2c4a 3a 59 2c			ld a, (.dmark+1)  
2c4d 32 be fb			ld (debug_mark+1),a  
2c50 3a 5a 2c			ld a, (.dmark+2)  
2c53 32 bf fb			ld (debug_mark+2),a  
2c56 18 03			jr .pastdmark  
2c58 ..			.dmark: db "2S_"  
2c5b f1			.pastdmark: pop af  
2c5c			endm  
# End of macro DMARK
2c5c						CALLMONITOR 
2c5c cd d4 14			call break_point_state  
2c5f				endm  
# End of macro CALLMONITOR
2c5f					endif 
2c5f			 
2c5f					FORTH_DSP_VALUEHL 
2c5f cd 09 1b			call macro_dsp_valuehl 
2c62				endm 
# End of macro FORTH_DSP_VALUEHL
2c62			 
2c62 e5					push hl   ; save address 
2c63			 
2c63			 
2c63					FORTH_DSP_POP 
2c63 cd a5 1b			call macro_forth_dsp_pop 
2c66				endm 
# End of macro FORTH_DSP_POP
2c66			 
2c66					 
2c66					FORTH_DSP_VALUEHL 
2c66 cd 09 1b			call macro_dsp_valuehl 
2c69				endm 
# End of macro FORTH_DSP_VALUEHL
2c69			 
2c69					FORTH_DSP_POP 
2c69 cd a5 1b			call macro_forth_dsp_pop 
2c6c				endm 
# End of macro FORTH_DSP_POP
2c6c			 
2c6c eb					ex de, hl    ; value now in de 
2c6d			 
2c6d e1					pop hl 
2c6e			 
2c6e 73					ld (hl), e 
2c6f			 
2c6f 23					inc hl 
2c70			 
2c70 72					ld (hl), d 
2c71			 
2c71			 
2c71				       NEXTW 
2c71 c3 5f 1c			jp macro_next 
2c74				endm 
# End of macro NEXTW
2c74			.CONFIG: 
2c74				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2c74 6f				db WORD_SYS_CORE+91             
2c75 85 2c			dw .ENDCORE            
2c77 07				db 6 + 1 
2c78 .. 00			db "CONFIG",0              
2c7f				endm 
# End of macro CWHEAD
2c7f			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
2c7f			 
2c7f cd 1c 13				call config 
2c82					NEXTW 
2c82 c3 5f 1c			jp macro_next 
2c85				endm 
# End of macro NEXTW
2c85			.ENDCORE: 
2c85			 
2c85			; eof 
2c85			 
2c85			 
# End of file forth_words_core.asm
2c85			include "forth_words_flow.asm" 
2c85			 
2c85			; | ## Program Flow Words 
2c85			 
2c85			.IF: 
2c85				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2c85 1e				db WORD_SYS_CORE+10             
2c86 7a 2d			dw .THEN            
2c88 03				db 2 + 1 
2c89 .. 00			db "IF",0              
2c8c				endm 
# End of macro CWHEAD
2c8c			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2c8c			; 
2c8c					if DEBUG_FORTH_WORDS_KEY 
2c8c						DMARK "IF." 
2c8c f5				push af  
2c8d 3a a1 2c			ld a, (.dmark)  
2c90 32 bd fb			ld (debug_mark),a  
2c93 3a a2 2c			ld a, (.dmark+1)  
2c96 32 be fb			ld (debug_mark+1),a  
2c99 3a a3 2c			ld a, (.dmark+2)  
2c9c 32 bf fb			ld (debug_mark+2),a  
2c9f 18 03			jr .pastdmark  
2ca1 ..			.dmark: db "IF."  
2ca4 f1			.pastdmark: pop af  
2ca5			endm  
# End of macro DMARK
2ca5						CALLMONITOR 
2ca5 cd d4 14			call break_point_state  
2ca8				endm  
# End of macro CALLMONITOR
2ca8					endif 
2ca8			; eval TOS 
2ca8			 
2ca8				FORTH_DSP_VALUEHL 
2ca8 cd 09 1b			call macro_dsp_valuehl 
2cab				endm 
# End of macro FORTH_DSP_VALUEHL
2cab			 
2cab			;	push hl 
2cab				FORTH_DSP_POP 
2cab cd a5 1b			call macro_forth_dsp_pop 
2cae				endm 
# End of macro FORTH_DSP_POP
2cae			;	pop hl 
2cae			 
2cae					if DEBUG_FORTH_WORDS 
2cae						DMARK "IF1" 
2cae f5				push af  
2caf 3a c3 2c			ld a, (.dmark)  
2cb2 32 bd fb			ld (debug_mark),a  
2cb5 3a c4 2c			ld a, (.dmark+1)  
2cb8 32 be fb			ld (debug_mark+1),a  
2cbb 3a c5 2c			ld a, (.dmark+2)  
2cbe 32 bf fb			ld (debug_mark+2),a  
2cc1 18 03			jr .pastdmark  
2cc3 ..			.dmark: db "IF1"  
2cc6 f1			.pastdmark: pop af  
2cc7			endm  
# End of macro DMARK
2cc7						CALLMONITOR 
2cc7 cd d4 14			call break_point_state  
2cca				endm  
# End of macro CALLMONITOR
2cca					endif 
2cca b7				or a        ; clear carry flag 
2ccb 11 00 00			ld de, 0 
2cce eb				ex de,hl 
2ccf ed 52			sbc hl, de 
2cd1 c2 5b 2d			jp nz, .iftrue 
2cd4			 
2cd4					if DEBUG_FORTH_WORDS 
2cd4						DMARK "IF2" 
2cd4 f5				push af  
2cd5 3a e9 2c			ld a, (.dmark)  
2cd8 32 bd fb			ld (debug_mark),a  
2cdb 3a ea 2c			ld a, (.dmark+1)  
2cde 32 be fb			ld (debug_mark+1),a  
2ce1 3a eb 2c			ld a, (.dmark+2)  
2ce4 32 bf fb			ld (debug_mark+2),a  
2ce7 18 03			jr .pastdmark  
2ce9 ..			.dmark: db "IF2"  
2cec f1			.pastdmark: pop af  
2ced			endm  
# End of macro DMARK
2ced						CALLMONITOR 
2ced cd d4 14			call break_point_state  
2cf0				endm  
# End of macro CALLMONITOR
2cf0					endif 
2cf0			 
2cf0			; if not true then skip to THEN 
2cf0			 
2cf0				; TODO get tok_ptr 
2cf0				; TODO consume toks until we get to THEN 
2cf0			 
2cf0 2a b9 f2			ld hl, (os_tok_ptr) 
2cf3					if DEBUG_FORTH_WORDS 
2cf3						DMARK "IF3" 
2cf3 f5				push af  
2cf4 3a 08 2d			ld a, (.dmark)  
2cf7 32 bd fb			ld (debug_mark),a  
2cfa 3a 09 2d			ld a, (.dmark+1)  
2cfd 32 be fb			ld (debug_mark+1),a  
2d00 3a 0a 2d			ld a, (.dmark+2)  
2d03 32 bf fb			ld (debug_mark+2),a  
2d06 18 03			jr .pastdmark  
2d08 ..			.dmark: db "IF3"  
2d0b f1			.pastdmark: pop af  
2d0c			endm  
# End of macro DMARK
2d0c						CALLMONITOR 
2d0c cd d4 14			call break_point_state  
2d0f				endm  
# End of macro CALLMONITOR
2d0f						 
2d0f					endif 
2d0f 11 56 2d			ld de, .ifthen 
2d12					if DEBUG_FORTH_WORDS 
2d12						DMARK "IF4" 
2d12 f5				push af  
2d13 3a 27 2d			ld a, (.dmark)  
2d16 32 bd fb			ld (debug_mark),a  
2d19 3a 28 2d			ld a, (.dmark+1)  
2d1c 32 be fb			ld (debug_mark+1),a  
2d1f 3a 29 2d			ld a, (.dmark+2)  
2d22 32 bf fb			ld (debug_mark+2),a  
2d25 18 03			jr .pastdmark  
2d27 ..			.dmark: db "IF4"  
2d2a f1			.pastdmark: pop af  
2d2b			endm  
# End of macro DMARK
2d2b						CALLMONITOR 
2d2b cd d4 14			call break_point_state  
2d2e				endm  
# End of macro CALLMONITOR
2d2e					endif 
2d2e cd 7a 1d			call findnexttok  
2d31			 
2d31					if DEBUG_FORTH_WORDS 
2d31						DMARK "IF5" 
2d31 f5				push af  
2d32 3a 46 2d			ld a, (.dmark)  
2d35 32 bd fb			ld (debug_mark),a  
2d38 3a 47 2d			ld a, (.dmark+1)  
2d3b 32 be fb			ld (debug_mark+1),a  
2d3e 3a 48 2d			ld a, (.dmark+2)  
2d41 32 bf fb			ld (debug_mark+2),a  
2d44 18 03			jr .pastdmark  
2d46 ..			.dmark: db "IF5"  
2d49 f1			.pastdmark: pop af  
2d4a			endm  
# End of macro DMARK
2d4a						CALLMONITOR 
2d4a cd d4 14			call break_point_state  
2d4d				endm  
# End of macro CALLMONITOR
2d4d					endif 
2d4d				; TODO replace below with ; exec using tok_ptr 
2d4d 22 b9 f2			ld (os_tok_ptr), hl 
2d50 c3 f0 1c			jp exec1 
2d53				NEXTW 
2d53 c3 5f 1c			jp macro_next 
2d56				endm 
# End of macro NEXTW
2d56			 
2d56 .. 00		.ifthen:  db "THEN",0 
2d5b			 
2d5b			.iftrue:		 
2d5b				; Exec next words normally 
2d5b			 
2d5b				; if true then exec following IF as normal 
2d5b					if DEBUG_FORTH_WORDS 
2d5b						DMARK "IFT" 
2d5b f5				push af  
2d5c 3a 70 2d			ld a, (.dmark)  
2d5f 32 bd fb			ld (debug_mark),a  
2d62 3a 71 2d			ld a, (.dmark+1)  
2d65 32 be fb			ld (debug_mark+1),a  
2d68 3a 72 2d			ld a, (.dmark+2)  
2d6b 32 bf fb			ld (debug_mark+2),a  
2d6e 18 03			jr .pastdmark  
2d70 ..			.dmark: db "IFT"  
2d73 f1			.pastdmark: pop af  
2d74			endm  
# End of macro DMARK
2d74						CALLMONITOR 
2d74 cd d4 14			call break_point_state  
2d77				endm  
# End of macro CALLMONITOR
2d77					endif 
2d77			 
2d77					NEXTW 
2d77 c3 5f 1c			jp macro_next 
2d7a				endm 
# End of macro NEXTW
2d7a			.THEN: 
2d7a				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2d7a 1f				db WORD_SYS_CORE+11             
2d7b a2 2d			dw .ELSE            
2d7d 05				db 4 + 1 
2d7e .. 00			db "THEN",0              
2d83				endm 
# End of macro CWHEAD
2d83			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2d83					if DEBUG_FORTH_WORDS_KEY 
2d83						DMARK "THN" 
2d83 f5				push af  
2d84 3a 98 2d			ld a, (.dmark)  
2d87 32 bd fb			ld (debug_mark),a  
2d8a 3a 99 2d			ld a, (.dmark+1)  
2d8d 32 be fb			ld (debug_mark+1),a  
2d90 3a 9a 2d			ld a, (.dmark+2)  
2d93 32 bf fb			ld (debug_mark+2),a  
2d96 18 03			jr .pastdmark  
2d98 ..			.dmark: db "THN"  
2d9b f1			.pastdmark: pop af  
2d9c			endm  
# End of macro DMARK
2d9c						CALLMONITOR 
2d9c cd d4 14			call break_point_state  
2d9f				endm  
# End of macro CALLMONITOR
2d9f					endif 
2d9f					NEXTW 
2d9f c3 5f 1c			jp macro_next 
2da2				endm 
# End of macro NEXTW
2da2			.ELSE: 
2da2				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2da2 20				db WORD_SYS_CORE+12             
2da3 ca 2d			dw .DO            
2da5 03				db 2 + 1 
2da6 .. 00			db "ELSE",0              
2dab				endm 
# End of macro CWHEAD
2dab			; | ELSE ( -- ) Not supported - does nothing | TODO 
2dab			 
2dab					if DEBUG_FORTH_WORDS_KEY 
2dab						DMARK "ELS" 
2dab f5				push af  
2dac 3a c0 2d			ld a, (.dmark)  
2daf 32 bd fb			ld (debug_mark),a  
2db2 3a c1 2d			ld a, (.dmark+1)  
2db5 32 be fb			ld (debug_mark+1),a  
2db8 3a c2 2d			ld a, (.dmark+2)  
2dbb 32 bf fb			ld (debug_mark+2),a  
2dbe 18 03			jr .pastdmark  
2dc0 ..			.dmark: db "ELS"  
2dc3 f1			.pastdmark: pop af  
2dc4			endm  
# End of macro DMARK
2dc4						CALLMONITOR 
2dc4 cd d4 14			call break_point_state  
2dc7				endm  
# End of macro CALLMONITOR
2dc7					endif 
2dc7			 
2dc7			 
2dc7					NEXTW 
2dc7 c3 5f 1c			jp macro_next 
2dca				endm 
# End of macro NEXTW
2dca			.DO: 
2dca				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2dca 21				db WORD_SYS_CORE+13             
2dcb f1 2e			dw .LOOP            
2dcd 03				db 2 + 1 
2dce .. 00			db "DO",0              
2dd1				endm 
# End of macro CWHEAD
2dd1			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2dd1			 
2dd1					if DEBUG_FORTH_WORDS_KEY 
2dd1						DMARK "DO." 
2dd1 f5				push af  
2dd2 3a e6 2d			ld a, (.dmark)  
2dd5 32 bd fb			ld (debug_mark),a  
2dd8 3a e7 2d			ld a, (.dmark+1)  
2ddb 32 be fb			ld (debug_mark+1),a  
2dde 3a e8 2d			ld a, (.dmark+2)  
2de1 32 bf fb			ld (debug_mark+2),a  
2de4 18 03			jr .pastdmark  
2de6 ..			.dmark: db "DO."  
2de9 f1			.pastdmark: pop af  
2dea			endm  
# End of macro DMARK
2dea						CALLMONITOR 
2dea cd d4 14			call break_point_state  
2ded				endm  
# End of macro CALLMONITOR
2ded					endif 
2ded			;  push pc to rsp stack past the DO 
2ded			 
2ded 2a b9 f2				ld hl, (os_tok_ptr) 
2df0 23					inc hl   ; D 
2df1 23					inc hl  ; O 
2df2 23					inc hl   ; null 
2df3					if DEBUG_FORTH_WORDS 
2df3						DMARK "DO2" 
2df3 f5				push af  
2df4 3a 08 2e			ld a, (.dmark)  
2df7 32 bd fb			ld (debug_mark),a  
2dfa 3a 09 2e			ld a, (.dmark+1)  
2dfd 32 be fb			ld (debug_mark+1),a  
2e00 3a 0a 2e			ld a, (.dmark+2)  
2e03 32 bf fb			ld (debug_mark+2),a  
2e06 18 03			jr .pastdmark  
2e08 ..			.dmark: db "DO2"  
2e0b f1			.pastdmark: pop af  
2e0c			endm  
# End of macro DMARK
2e0c						CALLMONITOR 
2e0c cd d4 14			call break_point_state  
2e0f				endm  
# End of macro CALLMONITOR
2e0f					endif 
2e0f					FORTH_RSP_NEXT 
2e0f cd 15 1a			call macro_forth_rsp_next 
2e12				endm 
# End of macro FORTH_RSP_NEXT
2e12					if DEBUG_FORTH_WORDS 
2e12						DMARK "DO3" 
2e12 f5				push af  
2e13 3a 27 2e			ld a, (.dmark)  
2e16 32 bd fb			ld (debug_mark),a  
2e19 3a 28 2e			ld a, (.dmark+1)  
2e1c 32 be fb			ld (debug_mark+1),a  
2e1f 3a 29 2e			ld a, (.dmark+2)  
2e22 32 bf fb			ld (debug_mark+2),a  
2e25 18 03			jr .pastdmark  
2e27 ..			.dmark: db "DO3"  
2e2a f1			.pastdmark: pop af  
2e2b			endm  
# End of macro DMARK
2e2b						CALLMONITOR 
2e2b cd d4 14			call break_point_state  
2e2e				endm  
# End of macro CALLMONITOR
2e2e					endif 
2e2e			 
2e2e					;if DEBUG_FORTH_WORDS 
2e2e				;		push hl 
2e2e			;		endif  
2e2e			 
2e2e			; get counters from data stack 
2e2e			 
2e2e			 
2e2e					FORTH_DSP_VALUEHL 
2e2e cd 09 1b			call macro_dsp_valuehl 
2e31				endm 
# End of macro FORTH_DSP_VALUEHL
2e31 e5					push hl		 ; hl now has starting counter which needs to be tos 
2e32			 
2e32					if DEBUG_FORTH_WORDS 
2e32						DMARK "DO4" 
2e32 f5				push af  
2e33 3a 47 2e			ld a, (.dmark)  
2e36 32 bd fb			ld (debug_mark),a  
2e39 3a 48 2e			ld a, (.dmark+1)  
2e3c 32 be fb			ld (debug_mark+1),a  
2e3f 3a 49 2e			ld a, (.dmark+2)  
2e42 32 bf fb			ld (debug_mark+2),a  
2e45 18 03			jr .pastdmark  
2e47 ..			.dmark: db "DO4"  
2e4a f1			.pastdmark: pop af  
2e4b			endm  
# End of macro DMARK
2e4b						CALLMONITOR 
2e4b cd d4 14			call break_point_state  
2e4e				endm  
# End of macro CALLMONITOR
2e4e					endif 
2e4e					FORTH_DSP_POP 
2e4e cd a5 1b			call macro_forth_dsp_pop 
2e51				endm 
# End of macro FORTH_DSP_POP
2e51			 
2e51					if DEBUG_FORTH_WORDS 
2e51						DMARK "DO5" 
2e51 f5				push af  
2e52 3a 66 2e			ld a, (.dmark)  
2e55 32 bd fb			ld (debug_mark),a  
2e58 3a 67 2e			ld a, (.dmark+1)  
2e5b 32 be fb			ld (debug_mark+1),a  
2e5e 3a 68 2e			ld a, (.dmark+2)  
2e61 32 bf fb			ld (debug_mark+2),a  
2e64 18 03			jr .pastdmark  
2e66 ..			.dmark: db "DO5"  
2e69 f1			.pastdmark: pop af  
2e6a			endm  
# End of macro DMARK
2e6a						CALLMONITOR 
2e6a cd d4 14			call break_point_state  
2e6d				endm  
# End of macro CALLMONITOR
2e6d					endif 
2e6d			 
2e6d					FORTH_DSP_VALUEHL 
2e6d cd 09 1b			call macro_dsp_valuehl 
2e70				endm 
# End of macro FORTH_DSP_VALUEHL
2e70			;		push hl		 ; hl now has starting limit counter 
2e70			 
2e70					if DEBUG_FORTH_WORDS 
2e70						DMARK "DO6" 
2e70 f5				push af  
2e71 3a 85 2e			ld a, (.dmark)  
2e74 32 bd fb			ld (debug_mark),a  
2e77 3a 86 2e			ld a, (.dmark+1)  
2e7a 32 be fb			ld (debug_mark+1),a  
2e7d 3a 87 2e			ld a, (.dmark+2)  
2e80 32 bf fb			ld (debug_mark+2),a  
2e83 18 03			jr .pastdmark  
2e85 ..			.dmark: db "DO6"  
2e88 f1			.pastdmark: pop af  
2e89			endm  
# End of macro DMARK
2e89						CALLMONITOR 
2e89 cd d4 14			call break_point_state  
2e8c				endm  
# End of macro CALLMONITOR
2e8c					endif 
2e8c					FORTH_DSP_POP 
2e8c cd a5 1b			call macro_forth_dsp_pop 
2e8f				endm 
# End of macro FORTH_DSP_POP
2e8f			 
2e8f			; put counters on the loop stack 
2e8f			 
2e8f			;		pop hl			 ; limit counter 
2e8f d1					pop de			; start counter 
2e90			 
2e90					; push limit counter 
2e90			 
2e90					if DEBUG_FORTH_WORDS 
2e90						DMARK "DO7" 
2e90 f5				push af  
2e91 3a a5 2e			ld a, (.dmark)  
2e94 32 bd fb			ld (debug_mark),a  
2e97 3a a6 2e			ld a, (.dmark+1)  
2e9a 32 be fb			ld (debug_mark+1),a  
2e9d 3a a7 2e			ld a, (.dmark+2)  
2ea0 32 bf fb			ld (debug_mark+2),a  
2ea3 18 03			jr .pastdmark  
2ea5 ..			.dmark: db "DO7"  
2ea8 f1			.pastdmark: pop af  
2ea9			endm  
# End of macro DMARK
2ea9						CALLMONITOR 
2ea9 cd d4 14			call break_point_state  
2eac				endm  
# End of macro CALLMONITOR
2eac					endif 
2eac					FORTH_LOOP_NEXT 
2eac cd 1e 1b			call macro_forth_loop_next 
2eaf				endm 
# End of macro FORTH_LOOP_NEXT
2eaf			 
2eaf					; push start counter 
2eaf			 
2eaf eb					ex de, hl 
2eb0					if DEBUG_FORTH_WORDS 
2eb0						DMARK "DO7" 
2eb0 f5				push af  
2eb1 3a c5 2e			ld a, (.dmark)  
2eb4 32 bd fb			ld (debug_mark),a  
2eb7 3a c6 2e			ld a, (.dmark+1)  
2eba 32 be fb			ld (debug_mark+1),a  
2ebd 3a c7 2e			ld a, (.dmark+2)  
2ec0 32 bf fb			ld (debug_mark+2),a  
2ec3 18 03			jr .pastdmark  
2ec5 ..			.dmark: db "DO7"  
2ec8 f1			.pastdmark: pop af  
2ec9			endm  
# End of macro DMARK
2ec9						CALLMONITOR 
2ec9 cd d4 14			call break_point_state  
2ecc				endm  
# End of macro CALLMONITOR
2ecc					endif 
2ecc					FORTH_LOOP_NEXT 
2ecc cd 1e 1b			call macro_forth_loop_next 
2ecf				endm 
# End of macro FORTH_LOOP_NEXT
2ecf			 
2ecf			 
2ecf					; init first round of I counter 
2ecf			 
2ecf 22 dd f2				ld (os_current_i), hl 
2ed2			 
2ed2					if DEBUG_FORTH_WORDS 
2ed2						DMARK "DO8" 
2ed2 f5				push af  
2ed3 3a e7 2e			ld a, (.dmark)  
2ed6 32 bd fb			ld (debug_mark),a  
2ed9 3a e8 2e			ld a, (.dmark+1)  
2edc 32 be fb			ld (debug_mark+1),a  
2edf 3a e9 2e			ld a, (.dmark+2)  
2ee2 32 bf fb			ld (debug_mark+2),a  
2ee5 18 03			jr .pastdmark  
2ee7 ..			.dmark: db "DO8"  
2eea f1			.pastdmark: pop af  
2eeb			endm  
# End of macro DMARK
2eeb						CALLMONITOR 
2eeb cd d4 14			call break_point_state  
2eee				endm  
# End of macro CALLMONITOR
2eee					endif 
2eee			 
2eee					NEXTW 
2eee c3 5f 1c			jp macro_next 
2ef1				endm 
# End of macro NEXTW
2ef1			.LOOP: 
2ef1				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2ef1 22				db WORD_SYS_CORE+14             
2ef2 09 30			dw .I            
2ef4 05				db 4 + 1 
2ef5 .. 00			db "LOOP",0              
2efa				endm 
# End of macro CWHEAD
2efa			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2efa			 
2efa				; pop tos as current loop count to hl 
2efa			 
2efa				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2efa			 
2efa				FORTH_LOOP_TOS 
2efa cd 51 1b			call macro_forth_loop_tos 
2efd				endm 
# End of macro FORTH_LOOP_TOS
2efd e5				push hl 
2efe			 
2efe					if DEBUG_FORTH_WORDS_KEY 
2efe						DMARK "LOP" 
2efe f5				push af  
2eff 3a 13 2f			ld a, (.dmark)  
2f02 32 bd fb			ld (debug_mark),a  
2f05 3a 14 2f			ld a, (.dmark+1)  
2f08 32 be fb			ld (debug_mark+1),a  
2f0b 3a 15 2f			ld a, (.dmark+2)  
2f0e 32 bf fb			ld (debug_mark+2),a  
2f11 18 03			jr .pastdmark  
2f13 ..			.dmark: db "LOP"  
2f16 f1			.pastdmark: pop af  
2f17			endm  
# End of macro DMARK
2f17						CALLMONITOR 
2f17 cd d4 14			call break_point_state  
2f1a				endm  
# End of macro CALLMONITOR
2f1a					endif 
2f1a				; next item on the stack is the limit. get it 
2f1a			 
2f1a			 
2f1a				FORTH_LOOP_POP 
2f1a cd 5b 1b			call macro_forth_loop_pop 
2f1d				endm 
# End of macro FORTH_LOOP_POP
2f1d			 
2f1d				FORTH_LOOP_TOS 
2f1d cd 51 1b			call macro_forth_loop_tos 
2f20				endm 
# End of macro FORTH_LOOP_TOS
2f20			 
2f20 d1				pop de		 ; de = i, hl = limit 
2f21			 
2f21					if DEBUG_FORTH_WORDS 
2f21						DMARK "LP1" 
2f21 f5				push af  
2f22 3a 36 2f			ld a, (.dmark)  
2f25 32 bd fb			ld (debug_mark),a  
2f28 3a 37 2f			ld a, (.dmark+1)  
2f2b 32 be fb			ld (debug_mark+1),a  
2f2e 3a 38 2f			ld a, (.dmark+2)  
2f31 32 bf fb			ld (debug_mark+2),a  
2f34 18 03			jr .pastdmark  
2f36 ..			.dmark: db "LP1"  
2f39 f1			.pastdmark: pop af  
2f3a			endm  
# End of macro DMARK
2f3a						CALLMONITOR 
2f3a cd d4 14			call break_point_state  
2f3d				endm  
# End of macro CALLMONITOR
2f3d					endif 
2f3d			 
2f3d				; go back to previous word 
2f3d			 
2f3d d5				push de    ; save I for inc later 
2f3e			 
2f3e			 
2f3e				; get limit 
2f3e				;  is I at limit? 
2f3e			 
2f3e			 
2f3e					if DEBUG_FORTH_WORDS 
2f3e						DMARK "LP1" 
2f3e f5				push af  
2f3f 3a 53 2f			ld a, (.dmark)  
2f42 32 bd fb			ld (debug_mark),a  
2f45 3a 54 2f			ld a, (.dmark+1)  
2f48 32 be fb			ld (debug_mark+1),a  
2f4b 3a 55 2f			ld a, (.dmark+2)  
2f4e 32 bf fb			ld (debug_mark+2),a  
2f51 18 03			jr .pastdmark  
2f53 ..			.dmark: db "LP1"  
2f56 f1			.pastdmark: pop af  
2f57			endm  
# End of macro DMARK
2f57						CALLMONITOR 
2f57 cd d4 14			call break_point_state  
2f5a				endm  
# End of macro CALLMONITOR
2f5a					endif 
2f5a			 
2f5a ed 52			sbc hl, de 
2f5c			 
2f5c			 
2f5c				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2f5c			 
2f5c 20 26				jr nz, .loopnotdone 
2f5e			 
2f5e e1				pop hl   ; get rid of saved I 
2f5f				FORTH_LOOP_POP     ; get rid of limit 
2f5f cd 5b 1b			call macro_forth_loop_pop 
2f62				endm 
# End of macro FORTH_LOOP_POP
2f62			 
2f62				FORTH_RSP_POP     ; get rid of DO ptr 
2f62 cd 36 1a			call macro_forth_rsp_pop 
2f65				endm 
# End of macro FORTH_RSP_POP
2f65			 
2f65			if DEBUG_FORTH_WORDS 
2f65						DMARK "LP>" 
2f65 f5				push af  
2f66 3a 7a 2f			ld a, (.dmark)  
2f69 32 bd fb			ld (debug_mark),a  
2f6c 3a 7b 2f			ld a, (.dmark+1)  
2f6f 32 be fb			ld (debug_mark+1),a  
2f72 3a 7c 2f			ld a, (.dmark+2)  
2f75 32 bf fb			ld (debug_mark+2),a  
2f78 18 03			jr .pastdmark  
2f7a ..			.dmark: db "LP>"  
2f7d f1			.pastdmark: pop af  
2f7e			endm  
# End of macro DMARK
2f7e				CALLMONITOR 
2f7e cd d4 14			call break_point_state  
2f81				endm  
# End of macro CALLMONITOR
2f81			endif 
2f81			 
2f81					NEXTW 
2f81 c3 5f 1c			jp macro_next 
2f84				endm 
# End of macro NEXTW
2f84				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2f84			 
2f84			.loopnotdone: 
2f84			 
2f84 e1				pop hl    ; get I 
2f85 23				inc hl 
2f86			 
2f86			   	; save new I 
2f86			 
2f86			 
2f86					; set I counter 
2f86			 
2f86 22 dd f2				ld (os_current_i), hl 
2f89			 
2f89					if DEBUG_FORTH_WORDS 
2f89						DMARK "LPN" 
2f89 f5				push af  
2f8a 3a 9e 2f			ld a, (.dmark)  
2f8d 32 bd fb			ld (debug_mark),a  
2f90 3a 9f 2f			ld a, (.dmark+1)  
2f93 32 be fb			ld (debug_mark+1),a  
2f96 3a a0 2f			ld a, (.dmark+2)  
2f99 32 bf fb			ld (debug_mark+2),a  
2f9c 18 03			jr .pastdmark  
2f9e ..			.dmark: db "LPN"  
2fa1 f1			.pastdmark: pop af  
2fa2			endm  
# End of macro DMARK
2fa2					CALLMONITOR 
2fa2 cd d4 14			call break_point_state  
2fa5				endm  
# End of macro CALLMONITOR
2fa5					endif 
2fa5					 
2fa5				FORTH_LOOP_NEXT 
2fa5 cd 1e 1b			call macro_forth_loop_next 
2fa8				endm 
# End of macro FORTH_LOOP_NEXT
2fa8			 
2fa8			 
2fa8					if DEBUG_FORTH_WORDS 
2fa8 eb						ex de,hl 
2fa9					endif 
2fa9			 
2fa9			;	; get DO ptr 
2fa9			; 
2fa9					if DEBUG_FORTH_WORDS 
2fa9						DMARK "LP7" 
2fa9 f5				push af  
2faa 3a be 2f			ld a, (.dmark)  
2fad 32 bd fb			ld (debug_mark),a  
2fb0 3a bf 2f			ld a, (.dmark+1)  
2fb3 32 be fb			ld (debug_mark+1),a  
2fb6 3a c0 2f			ld a, (.dmark+2)  
2fb9 32 bf fb			ld (debug_mark+2),a  
2fbc 18 03			jr .pastdmark  
2fbe ..			.dmark: db "LP7"  
2fc1 f1			.pastdmark: pop af  
2fc2			endm  
# End of macro DMARK
2fc2					CALLMONITOR 
2fc2 cd d4 14			call break_point_state  
2fc5				endm  
# End of macro CALLMONITOR
2fc5					endif 
2fc5				FORTH_RSP_TOS 
2fc5 cd 2c 1a			call macro_forth_rsp_tos 
2fc8				endm 
# End of macro FORTH_RSP_TOS
2fc8			 
2fc8					if DEBUG_FORTH_WORDS 
2fc8						DMARK "LP8" 
2fc8 f5				push af  
2fc9 3a dd 2f			ld a, (.dmark)  
2fcc 32 bd fb			ld (debug_mark),a  
2fcf 3a de 2f			ld a, (.dmark+1)  
2fd2 32 be fb			ld (debug_mark+1),a  
2fd5 3a df 2f			ld a, (.dmark+2)  
2fd8 32 bf fb			ld (debug_mark+2),a  
2fdb 18 03			jr .pastdmark  
2fdd ..			.dmark: db "LP8"  
2fe0 f1			.pastdmark: pop af  
2fe1			endm  
# End of macro DMARK
2fe1					CALLMONITOR 
2fe1 cd d4 14			call break_point_state  
2fe4				endm  
# End of macro CALLMONITOR
2fe4					endif 
2fe4				;push hl 
2fe4			 
2fe4				; not going to DO any more 
2fe4				; get rid of the RSP pointer as DO will add it back in 
2fe4				;FORTH_RSP_POP 
2fe4				;pop hl 
2fe4			 
2fe4				;ld hl,(cli_ret_sp) 
2fe4				;ld e, (hl) 
2fe4				;inc hl 
2fe4				;ld d, (hl) 
2fe4				;ex de,hl 
2fe4 22 b9 f2			ld (os_tok_ptr), hl 
2fe7					if DEBUG_FORTH_WORDS 
2fe7						DMARK "LP<" 
2fe7 f5				push af  
2fe8 3a fc 2f			ld a, (.dmark)  
2feb 32 bd fb			ld (debug_mark),a  
2fee 3a fd 2f			ld a, (.dmark+1)  
2ff1 32 be fb			ld (debug_mark+1),a  
2ff4 3a fe 2f			ld a, (.dmark+2)  
2ff7 32 bf fb			ld (debug_mark+2),a  
2ffa 18 03			jr .pastdmark  
2ffc ..			.dmark: db "LP<"  
2fff f1			.pastdmark: pop af  
3000			endm  
# End of macro DMARK
3000					CALLMONITOR 
3000 cd d4 14			call break_point_state  
3003				endm  
# End of macro CALLMONITOR
3003				endif 
3003 c3 f0 1c			jp exec1 
3006			 
3006					 
3006			 
3006			 
3006					NEXTW 
3006 c3 5f 1c			jp macro_next 
3009				endm 
# End of macro NEXTW
3009			.I:  
3009			 
3009				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3009 5e				db WORD_SYS_CORE+74             
300a 34 30			dw .DLOOP            
300c 02				db 1 + 1 
300d .. 00			db "I",0              
300f				endm 
# End of macro CWHEAD
300f			; | I ( -- ) Current loop counter | DONE 
300f					if DEBUG_FORTH_WORDS_KEY 
300f						DMARK "I.." 
300f f5				push af  
3010 3a 24 30			ld a, (.dmark)  
3013 32 bd fb			ld (debug_mark),a  
3016 3a 25 30			ld a, (.dmark+1)  
3019 32 be fb			ld (debug_mark+1),a  
301c 3a 26 30			ld a, (.dmark+2)  
301f 32 bf fb			ld (debug_mark+2),a  
3022 18 03			jr .pastdmark  
3024 ..			.dmark: db "I.."  
3027 f1			.pastdmark: pop af  
3028			endm  
# End of macro DMARK
3028						CALLMONITOR 
3028 cd d4 14			call break_point_state  
302b				endm  
# End of macro CALLMONITOR
302b					endif 
302b			 
302b 2a dd f2				ld hl,(os_current_i) 
302e cd 6e 1a				call forth_push_numhl 
3031			 
3031					NEXTW 
3031 c3 5f 1c			jp macro_next 
3034				endm 
# End of macro NEXTW
3034			.DLOOP: 
3034				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3034 5f				db WORD_SYS_CORE+75             
3035 15 31			dw .REPEAT            
3037 06				db 5 + 1 
3038 .. 00			db "-LOOP",0              
303e				endm 
# End of macro CWHEAD
303e			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
303e				; pop tos as current loop count to hl 
303e					if DEBUG_FORTH_WORDS_KEY 
303e						DMARK "-LP" 
303e f5				push af  
303f 3a 53 30			ld a, (.dmark)  
3042 32 bd fb			ld (debug_mark),a  
3045 3a 54 30			ld a, (.dmark+1)  
3048 32 be fb			ld (debug_mark+1),a  
304b 3a 55 30			ld a, (.dmark+2)  
304e 32 bf fb			ld (debug_mark+2),a  
3051 18 03			jr .pastdmark  
3053 ..			.dmark: db "-LP"  
3056 f1			.pastdmark: pop af  
3057			endm  
# End of macro DMARK
3057						CALLMONITOR 
3057 cd d4 14			call break_point_state  
305a				endm  
# End of macro CALLMONITOR
305a					endif 
305a			 
305a				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
305a			 
305a				FORTH_LOOP_TOS 
305a cd 51 1b			call macro_forth_loop_tos 
305d				endm 
# End of macro FORTH_LOOP_TOS
305d e5				push hl 
305e			 
305e					if DEBUG_FORTH_WORDS 
305e						DMARK "-LP" 
305e f5				push af  
305f 3a 73 30			ld a, (.dmark)  
3062 32 bd fb			ld (debug_mark),a  
3065 3a 74 30			ld a, (.dmark+1)  
3068 32 be fb			ld (debug_mark+1),a  
306b 3a 75 30			ld a, (.dmark+2)  
306e 32 bf fb			ld (debug_mark+2),a  
3071 18 03			jr .pastdmark  
3073 ..			.dmark: db "-LP"  
3076 f1			.pastdmark: pop af  
3077			endm  
# End of macro DMARK
3077						CALLMONITOR 
3077 cd d4 14			call break_point_state  
307a				endm  
# End of macro CALLMONITOR
307a					endif 
307a				; next item on the stack is the limit. get it 
307a			 
307a			 
307a				FORTH_LOOP_POP 
307a cd 5b 1b			call macro_forth_loop_pop 
307d				endm 
# End of macro FORTH_LOOP_POP
307d			 
307d				FORTH_LOOP_TOS 
307d cd 51 1b			call macro_forth_loop_tos 
3080				endm 
# End of macro FORTH_LOOP_TOS
3080			 
3080 d1				pop de		 ; de = i, hl = limit 
3081			 
3081					if DEBUG_FORTH_WORDS 
3081						DMARK "-L1" 
3081 f5				push af  
3082 3a 96 30			ld a, (.dmark)  
3085 32 bd fb			ld (debug_mark),a  
3088 3a 97 30			ld a, (.dmark+1)  
308b 32 be fb			ld (debug_mark+1),a  
308e 3a 98 30			ld a, (.dmark+2)  
3091 32 bf fb			ld (debug_mark+2),a  
3094 18 03			jr .pastdmark  
3096 ..			.dmark: db "-L1"  
3099 f1			.pastdmark: pop af  
309a			endm  
# End of macro DMARK
309a						CALLMONITOR 
309a cd d4 14			call break_point_state  
309d				endm  
# End of macro CALLMONITOR
309d					endif 
309d			 
309d				; go back to previous word 
309d			 
309d d5				push de    ; save I for inc later 
309e			 
309e			 
309e				; get limit 
309e				;  is I at limit? 
309e			 
309e			 
309e					if DEBUG_FORTH_WORDS 
309e						DMARK "-L1" 
309e f5				push af  
309f 3a b3 30			ld a, (.dmark)  
30a2 32 bd fb			ld (debug_mark),a  
30a5 3a b4 30			ld a, (.dmark+1)  
30a8 32 be fb			ld (debug_mark+1),a  
30ab 3a b5 30			ld a, (.dmark+2)  
30ae 32 bf fb			ld (debug_mark+2),a  
30b1 18 03			jr .pastdmark  
30b3 ..			.dmark: db "-L1"  
30b6 f1			.pastdmark: pop af  
30b7			endm  
# End of macro DMARK
30b7						CALLMONITOR 
30b7 cd d4 14			call break_point_state  
30ba				endm  
# End of macro CALLMONITOR
30ba					endif 
30ba			 
30ba ed 52			sbc hl, de 
30bc			 
30bc			 
30bc				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
30bc			 
30bc 20 26				jr nz, .mloopnotdone 
30be			 
30be e1				pop hl   ; get rid of saved I 
30bf				FORTH_LOOP_POP     ; get rid of limit 
30bf cd 5b 1b			call macro_forth_loop_pop 
30c2				endm 
# End of macro FORTH_LOOP_POP
30c2			 
30c2				FORTH_RSP_POP     ; get rid of DO ptr 
30c2 cd 36 1a			call macro_forth_rsp_pop 
30c5				endm 
# End of macro FORTH_RSP_POP
30c5			 
30c5			if DEBUG_FORTH_WORDS 
30c5						DMARK "-L>" 
30c5 f5				push af  
30c6 3a da 30			ld a, (.dmark)  
30c9 32 bd fb			ld (debug_mark),a  
30cc 3a db 30			ld a, (.dmark+1)  
30cf 32 be fb			ld (debug_mark+1),a  
30d2 3a dc 30			ld a, (.dmark+2)  
30d5 32 bf fb			ld (debug_mark+2),a  
30d8 18 03			jr .pastdmark  
30da ..			.dmark: db "-L>"  
30dd f1			.pastdmark: pop af  
30de			endm  
# End of macro DMARK
30de				CALLMONITOR 
30de cd d4 14			call break_point_state  
30e1				endm  
# End of macro CALLMONITOR
30e1			endif 
30e1			 
30e1					NEXTW 
30e1 c3 5f 1c			jp macro_next 
30e4				endm 
# End of macro NEXTW
30e4				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
30e4			 
30e4			.mloopnotdone: 
30e4			 
30e4 e1				pop hl    ; get I 
30e5 2b				dec hl 
30e6			 
30e6			   	; save new I 
30e6			 
30e6			 
30e6					; set I counter 
30e6			 
30e6 22 dd f2				ld (os_current_i), hl 
30e9			 
30e9					 
30e9				FORTH_LOOP_NEXT 
30e9 cd 1e 1b			call macro_forth_loop_next 
30ec				endm 
# End of macro FORTH_LOOP_NEXT
30ec			 
30ec			 
30ec					if DEBUG_FORTH_WORDS 
30ec eb						ex de,hl 
30ed					endif 
30ed			 
30ed			;	; get DO ptr 
30ed			; 
30ed				FORTH_RSP_TOS 
30ed cd 2c 1a			call macro_forth_rsp_tos 
30f0				endm 
# End of macro FORTH_RSP_TOS
30f0			 
30f0				;push hl 
30f0			 
30f0				; not going to DO any more 
30f0				; get rid of the RSP pointer as DO will add it back in 
30f0				;FORTH_RSP_POP 
30f0				;pop hl 
30f0			 
30f0			 
30f0 22 b9 f2			ld (os_tok_ptr), hl 
30f3					if DEBUG_FORTH_WORDS 
30f3						DMARK "-L<" 
30f3 f5				push af  
30f4 3a 08 31			ld a, (.dmark)  
30f7 32 bd fb			ld (debug_mark),a  
30fa 3a 09 31			ld a, (.dmark+1)  
30fd 32 be fb			ld (debug_mark+1),a  
3100 3a 0a 31			ld a, (.dmark+2)  
3103 32 bf fb			ld (debug_mark+2),a  
3106 18 03			jr .pastdmark  
3108 ..			.dmark: db "-L<"  
310b f1			.pastdmark: pop af  
310c			endm  
# End of macro DMARK
310c					CALLMONITOR 
310c cd d4 14			call break_point_state  
310f				endm  
# End of macro CALLMONITOR
310f				endif 
310f c3 f0 1c			jp exec1 
3112			 
3112					 
3112			 
3112			 
3112			 
3112				NEXTW 
3112 c3 5f 1c			jp macro_next 
3115				endm 
# End of macro NEXTW
3115			 
3115			 
3115			 
3115			 
3115			.REPEAT: 
3115				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3115 71				db WORD_SYS_CORE+93             
3116 68 31			dw .UNTIL            
3118 06				db 5 + 1 
3119 .. 00			db "REPEAT",0              
3120				endm 
# End of macro CWHEAD
3120			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3120			;  push pc to rsp stack past the REPEAT 
3120					if DEBUG_FORTH_WORDS_KEY 
3120						DMARK "REP" 
3120 f5				push af  
3121 3a 35 31			ld a, (.dmark)  
3124 32 bd fb			ld (debug_mark),a  
3127 3a 36 31			ld a, (.dmark+1)  
312a 32 be fb			ld (debug_mark+1),a  
312d 3a 37 31			ld a, (.dmark+2)  
3130 32 bf fb			ld (debug_mark+2),a  
3133 18 03			jr .pastdmark  
3135 ..			.dmark: db "REP"  
3138 f1			.pastdmark: pop af  
3139			endm  
# End of macro DMARK
3139						CALLMONITOR 
3139 cd d4 14			call break_point_state  
313c				endm  
# End of macro CALLMONITOR
313c					endif 
313c			 
313c 2a b9 f2				ld hl, (os_tok_ptr) 
313f 23					inc hl   ; R 
3140 23					inc hl  ; E 
3141 23					inc hl   ; P 
3142 23					inc hl   ; E 
3143 23					inc hl   ; A 
3144 23					inc hl   ; T 
3145 23					inc hl   ; zero 
3146					FORTH_RSP_NEXT 
3146 cd 15 1a			call macro_forth_rsp_next 
3149				endm 
# End of macro FORTH_RSP_NEXT
3149			 
3149			 
3149					if DEBUG_FORTH_WORDS 
3149						DMARK "REP" 
3149 f5				push af  
314a 3a 5e 31			ld a, (.dmark)  
314d 32 bd fb			ld (debug_mark),a  
3150 3a 5f 31			ld a, (.dmark+1)  
3153 32 be fb			ld (debug_mark+1),a  
3156 3a 60 31			ld a, (.dmark+2)  
3159 32 bf fb			ld (debug_mark+2),a  
315c 18 03			jr .pastdmark  
315e ..			.dmark: db "REP"  
3161 f1			.pastdmark: pop af  
3162			endm  
# End of macro DMARK
3162						;pop bc    ; TODO BUG ?????? what is this for???? 
3162						CALLMONITOR 
3162 cd d4 14			call break_point_state  
3165				endm  
# End of macro CALLMONITOR
3165					endif 
3165			 
3165					NEXTW 
3165 c3 5f 1c			jp macro_next 
3168				endm 
# End of macro NEXTW
3168			;	       NEXTW 
3168			 
3168			.UNTIL: 
3168				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3168 72				db WORD_SYS_CORE+94             
3169 ff 31			dw .ENDFLOW            
316b 06				db 5 + 1 
316c .. 00			db "UNTIL",0              
3172				endm 
# End of macro CWHEAD
3172			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3172			 
3172				; pop tos as check 
3172			 
3172				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3172			 
3172				FORTH_DSP_VALUEHL 
3172 cd 09 1b			call macro_dsp_valuehl 
3175				endm 
# End of macro FORTH_DSP_VALUEHL
3175			 
3175					if DEBUG_FORTH_WORDS_KEY 
3175						DMARK "UNT" 
3175 f5				push af  
3176 3a 8a 31			ld a, (.dmark)  
3179 32 bd fb			ld (debug_mark),a  
317c 3a 8b 31			ld a, (.dmark+1)  
317f 32 be fb			ld (debug_mark+1),a  
3182 3a 8c 31			ld a, (.dmark+2)  
3185 32 bf fb			ld (debug_mark+2),a  
3188 18 03			jr .pastdmark  
318a ..			.dmark: db "UNT"  
318d f1			.pastdmark: pop af  
318e			endm  
# End of macro DMARK
318e						CALLMONITOR 
318e cd d4 14			call break_point_state  
3191				endm  
# End of macro CALLMONITOR
3191					endif 
3191			 
3191			;	push hl 
3191				FORTH_DSP_POP 
3191 cd a5 1b			call macro_forth_dsp_pop 
3194				endm 
# End of macro FORTH_DSP_POP
3194			 
3194			;	pop hl 
3194			 
3194				; test if true 
3194			 
3194 cd e5 0c			call ishlzero 
3197			;	ld a,l 
3197			;	add h 
3197			; 
3197			;	cp 0 
3197			 
3197 20 3e			jr nz, .untilnotdone 
3199			 
3199					if DEBUG_FORTH_WORDS 
3199						DMARK "UNf" 
3199 f5				push af  
319a 3a ae 31			ld a, (.dmark)  
319d 32 bd fb			ld (debug_mark),a  
31a0 3a af 31			ld a, (.dmark+1)  
31a3 32 be fb			ld (debug_mark+1),a  
31a6 3a b0 31			ld a, (.dmark+2)  
31a9 32 bf fb			ld (debug_mark+2),a  
31ac 18 03			jr .pastdmark  
31ae ..			.dmark: db "UNf"  
31b1 f1			.pastdmark: pop af  
31b2			endm  
# End of macro DMARK
31b2						CALLMONITOR 
31b2 cd d4 14			call break_point_state  
31b5				endm  
# End of macro CALLMONITOR
31b5					endif 
31b5			 
31b5			 
31b5			 
31b5				FORTH_RSP_POP     ; get rid of DO ptr 
31b5 cd 36 1a			call macro_forth_rsp_pop 
31b8				endm 
# End of macro FORTH_RSP_POP
31b8			 
31b8			if DEBUG_FORTH_WORDS 
31b8						DMARK "UN>" 
31b8 f5				push af  
31b9 3a cd 31			ld a, (.dmark)  
31bc 32 bd fb			ld (debug_mark),a  
31bf 3a ce 31			ld a, (.dmark+1)  
31c2 32 be fb			ld (debug_mark+1),a  
31c5 3a cf 31			ld a, (.dmark+2)  
31c8 32 bf fb			ld (debug_mark+2),a  
31cb 18 03			jr .pastdmark  
31cd ..			.dmark: db "UN>"  
31d0 f1			.pastdmark: pop af  
31d1			endm  
# End of macro DMARK
31d1				CALLMONITOR 
31d1 cd d4 14			call break_point_state  
31d4				endm  
# End of macro CALLMONITOR
31d4			endif 
31d4			 
31d4					NEXTW 
31d4 c3 5f 1c			jp macro_next 
31d7				endm 
# End of macro NEXTW
31d7				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
31d7			 
31d7			.untilnotdone: 
31d7			 
31d7			 
31d7			;	; get DO ptr 
31d7			; 
31d7				FORTH_RSP_TOS 
31d7 cd 2c 1a			call macro_forth_rsp_tos 
31da				endm 
# End of macro FORTH_RSP_TOS
31da			 
31da				;push hl 
31da			 
31da				; not going to DO any more 
31da				; get rid of the RSP pointer as DO will add it back in 
31da				;FORTH_RSP_POP 
31da				;pop hl 
31da			 
31da			 
31da 22 b9 f2			ld (os_tok_ptr), hl 
31dd					if DEBUG_FORTH_WORDS 
31dd						DMARK "UN<" 
31dd f5				push af  
31de 3a f2 31			ld a, (.dmark)  
31e1 32 bd fb			ld (debug_mark),a  
31e4 3a f3 31			ld a, (.dmark+1)  
31e7 32 be fb			ld (debug_mark+1),a  
31ea 3a f4 31			ld a, (.dmark+2)  
31ed 32 bf fb			ld (debug_mark+2),a  
31f0 18 03			jr .pastdmark  
31f2 ..			.dmark: db "UN<"  
31f5 f1			.pastdmark: pop af  
31f6			endm  
# End of macro DMARK
31f6					CALLMONITOR 
31f6 cd d4 14			call break_point_state  
31f9				endm  
# End of macro CALLMONITOR
31f9				endif 
31f9 c3 f0 1c			jp exec1 
31fc			 
31fc					 
31fc			 
31fc			 
31fc					NEXTW 
31fc c3 5f 1c			jp macro_next 
31ff				endm 
# End of macro NEXTW
31ff			 
31ff			 
31ff			.ENDFLOW: 
31ff			 
31ff			; eof 
31ff			 
# End of file forth_words_flow.asm
31ff			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
31ff			include "forth_words_logic.asm" 
31ff			 
31ff			; | ## Logic Words 
31ff			 
31ff			.NOT: 
31ff				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
31ff 2d				db WORD_SYS_CORE+25             
3200 47 32			dw .IS            
3202 04				db 3 + 1 
3203 .. 00			db "NOT",0              
3207				endm 
# End of macro CWHEAD
3207			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3207					if DEBUG_FORTH_WORDS_KEY 
3207						DMARK "NOT" 
3207 f5				push af  
3208 3a 1c 32			ld a, (.dmark)  
320b 32 bd fb			ld (debug_mark),a  
320e 3a 1d 32			ld a, (.dmark+1)  
3211 32 be fb			ld (debug_mark+1),a  
3214 3a 1e 32			ld a, (.dmark+2)  
3217 32 bf fb			ld (debug_mark+2),a  
321a 18 03			jr .pastdmark  
321c ..			.dmark: db "NOT"  
321f f1			.pastdmark: pop af  
3220			endm  
# End of macro DMARK
3220						CALLMONITOR 
3220 cd d4 14			call break_point_state  
3223				endm  
# End of macro CALLMONITOR
3223					endif 
3223					FORTH_DSP 
3223 cd ee 1a			call macro_forth_dsp 
3226				endm 
# End of macro FORTH_DSP
3226 7e					ld a,(hl)	; get type of value on TOS 
3227 fe 02				cp DS_TYPE_INUM  
3229 28 03				jr z, .noti 
322b					NEXTW 
322b c3 5f 1c			jp macro_next 
322e				endm 
# End of macro NEXTW
322e			.noti:          FORTH_DSP_VALUEHL 
322e cd 09 1b			call macro_dsp_valuehl 
3231				endm 
# End of macro FORTH_DSP_VALUEHL
3231			;		push hl 
3231					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3231 cd a5 1b			call macro_forth_dsp_pop 
3234				endm 
# End of macro FORTH_DSP_POP
3234			;		pop hl 
3234 3e 00				ld a,0 
3236 bd					cp l 
3237 28 04				jr z, .not2t 
3239 2e 00				ld l, 0 
323b 18 02				jr .notip 
323d			 
323d 2e ff		.not2t:		ld l, 255 
323f			 
323f 26 00		.notip:		ld h, 0	 
3241			 
3241 cd 6e 1a				call forth_push_numhl 
3244					NEXTW 
3244 c3 5f 1c			jp macro_next 
3247				endm 
# End of macro NEXTW
3247			 
3247			.IS: 
3247				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3247 2d				db WORD_SYS_CORE+25             
3248 6d 32			dw .LZERO            
324a 03				db 2 + 1 
324b .. 00			db "IS",0              
324e				endm 
# End of macro CWHEAD
324e			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
324e					if DEBUG_FORTH_WORDS_KEY 
324e						DMARK "IS." 
324e f5				push af  
324f 3a 63 32			ld a, (.dmark)  
3252 32 bd fb			ld (debug_mark),a  
3255 3a 64 32			ld a, (.dmark+1)  
3258 32 be fb			ld (debug_mark+1),a  
325b 3a 65 32			ld a, (.dmark+2)  
325e 32 bf fb			ld (debug_mark+2),a  
3261 18 03			jr .pastdmark  
3263 ..			.dmark: db "IS."  
3266 f1			.pastdmark: pop af  
3267			endm  
# End of macro DMARK
3267						CALLMONITOR 
3267 cd d4 14			call break_point_state  
326a				endm  
# End of macro CALLMONITOR
326a					endif 
326a					NEXTW 
326a c3 5f 1c			jp macro_next 
326d				endm 
# End of macro NEXTW
326d			.LZERO: 
326d				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
326d 2d				db WORD_SYS_CORE+25             
326e 77 32			dw .TZERO            
3270 03				db 2 + 1 
3271 .. 00			db "0<",0              
3274				endm 
# End of macro CWHEAD
3274			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3274					NEXTW 
3274 c3 5f 1c			jp macro_next 
3277				endm 
# End of macro NEXTW
3277			.TZERO: 
3277				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3277 2e				db WORD_SYS_CORE+26             
3278 be 32			dw .LESS            
327a 03				db 2 + 1 
327b .. 00			db "0=",0              
327e				endm 
# End of macro CWHEAD
327e			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
327e				; TODO add floating point number detection 
327e					;v5 FORTH_DSP_VALUE 
327e					if DEBUG_FORTH_WORDS_KEY 
327e						DMARK "0=." 
327e f5				push af  
327f 3a 93 32			ld a, (.dmark)  
3282 32 bd fb			ld (debug_mark),a  
3285 3a 94 32			ld a, (.dmark+1)  
3288 32 be fb			ld (debug_mark+1),a  
328b 3a 95 32			ld a, (.dmark+2)  
328e 32 bf fb			ld (debug_mark+2),a  
3291 18 03			jr .pastdmark  
3293 ..			.dmark: db "0=."  
3296 f1			.pastdmark: pop af  
3297			endm  
# End of macro DMARK
3297						CALLMONITOR 
3297 cd d4 14			call break_point_state  
329a				endm  
# End of macro CALLMONITOR
329a					endif 
329a					FORTH_DSP 
329a cd ee 1a			call macro_forth_dsp 
329d				endm 
# End of macro FORTH_DSP
329d 7e					ld a,(hl)	; get type of value on TOS 
329e fe 02				cp DS_TYPE_INUM  
32a0 28 00				jr z, .tz_inum 
32a2			 
32a2				if FORTH_ENABLE_FLOATMATH 
32a2					jr .tz_done 
32a2			 
32a2				endif 
32a2					 
32a2			 
32a2			.tz_inum: 
32a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32a2 cd 09 1b			call macro_dsp_valuehl 
32a5				endm 
# End of macro FORTH_DSP_VALUEHL
32a5			 
32a5			;		push hl 
32a5			 
32a5					; destroy value TOS 
32a5			 
32a5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32a5 cd a5 1b			call macro_forth_dsp_pop 
32a8				endm 
# End of macro FORTH_DSP_POP
32a8			 
32a8			;		pop hl 
32a8			 
32a8 3e 00				ld a,0 
32aa			 
32aa bd					cp l 
32ab 20 08				jr nz, .tz_notzero 
32ad			 
32ad bc					cp h 
32ae			 
32ae 20 05				jr nz, .tz_notzero 
32b0			 
32b0			 
32b0 21 01 00				ld hl, FORTH_TRUE 
32b3 18 03				jr .tz_done 
32b5			 
32b5 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
32b8			 
32b8					; push value back onto stack for another op etc 
32b8			 
32b8			.tz_done: 
32b8 cd 6e 1a				call forth_push_numhl 
32bb			 
32bb					NEXTW 
32bb c3 5f 1c			jp macro_next 
32be				endm 
# End of macro NEXTW
32be			.LESS: 
32be				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
32be 2f				db WORD_SYS_CORE+27             
32bf 27 33			dw .GT            
32c1 02				db 1 + 1 
32c2 .. 00			db "<",0              
32c4				endm 
# End of macro CWHEAD
32c4			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
32c4				; TODO add floating point number detection 
32c4					if DEBUG_FORTH_WORDS_KEY 
32c4						DMARK "LES" 
32c4 f5				push af  
32c5 3a d9 32			ld a, (.dmark)  
32c8 32 bd fb			ld (debug_mark),a  
32cb 3a da 32			ld a, (.dmark+1)  
32ce 32 be fb			ld (debug_mark+1),a  
32d1 3a db 32			ld a, (.dmark+2)  
32d4 32 bf fb			ld (debug_mark+2),a  
32d7 18 03			jr .pastdmark  
32d9 ..			.dmark: db "LES"  
32dc f1			.pastdmark: pop af  
32dd			endm  
# End of macro DMARK
32dd						CALLMONITOR 
32dd cd d4 14			call break_point_state  
32e0				endm  
# End of macro CALLMONITOR
32e0					endif 
32e0					FORTH_DSP 
32e0 cd ee 1a			call macro_forth_dsp 
32e3				endm 
# End of macro FORTH_DSP
32e3					;v5 FORTH_DSP_VALUE 
32e3 7e					ld a,(hl)	; get type of value on TOS 
32e4 fe 02				cp DS_TYPE_INUM  
32e6 28 00				jr z, .less_inum 
32e8			 
32e8				if FORTH_ENABLE_FLOATMATH 
32e8					jr .less_done 
32e8			 
32e8				endif 
32e8					 
32e8			 
32e8			.less_inum: 
32e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32e8 cd 09 1b			call macro_dsp_valuehl 
32eb				endm 
# End of macro FORTH_DSP_VALUEHL
32eb			 
32eb e5					push hl  ; u2 
32ec			 
32ec					; destroy value TOS 
32ec			 
32ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32ec cd a5 1b			call macro_forth_dsp_pop 
32ef				endm 
# End of macro FORTH_DSP_POP
32ef			 
32ef			 
32ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32ef cd 09 1b			call macro_dsp_valuehl 
32f2				endm 
# End of macro FORTH_DSP_VALUEHL
32f2			 
32f2 e5					push hl    ; u1 
32f3			 
32f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32f3 cd a5 1b			call macro_forth_dsp_pop 
32f6				endm 
# End of macro FORTH_DSP_POP
32f6			 
32f6			 
32f6 b7			 or a      ;clear carry flag 
32f7 01 00 00		 ld bc, FORTH_FALSE 
32fa e1			  pop hl    ; u1 
32fb d1			  pop de    ; u2 
32fc ed 52		  sbc hl,de 
32fe 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3300			 
3300 01 01 00		 ld bc, FORTH_TRUE 
3303			.lscont:  
3303 c5					push bc 
3304 e1					pop hl 
3305			 
3305					if DEBUG_FORTH_WORDS 
3305						DMARK "LT1" 
3305 f5				push af  
3306 3a 1a 33			ld a, (.dmark)  
3309 32 bd fb			ld (debug_mark),a  
330c 3a 1b 33			ld a, (.dmark+1)  
330f 32 be fb			ld (debug_mark+1),a  
3312 3a 1c 33			ld a, (.dmark+2)  
3315 32 bf fb			ld (debug_mark+2),a  
3318 18 03			jr .pastdmark  
331a ..			.dmark: db "LT1"  
331d f1			.pastdmark: pop af  
331e			endm  
# End of macro DMARK
331e						CALLMONITOR 
331e cd d4 14			call break_point_state  
3321				endm  
# End of macro CALLMONITOR
3321					endif 
3321 cd 6e 1a				call forth_push_numhl 
3324			 
3324					NEXTW 
3324 c3 5f 1c			jp macro_next 
3327				endm 
# End of macro NEXTW
3327			.GT: 
3327				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3327 30				db WORD_SYS_CORE+28             
3328 90 33			dw .EQUAL            
332a 02				db 1 + 1 
332b .. 00			db ">",0              
332d				endm 
# End of macro CWHEAD
332d			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
332d				; TODO add floating point number detection 
332d					if DEBUG_FORTH_WORDS_KEY 
332d						DMARK "GRT" 
332d f5				push af  
332e 3a 42 33			ld a, (.dmark)  
3331 32 bd fb			ld (debug_mark),a  
3334 3a 43 33			ld a, (.dmark+1)  
3337 32 be fb			ld (debug_mark+1),a  
333a 3a 44 33			ld a, (.dmark+2)  
333d 32 bf fb			ld (debug_mark+2),a  
3340 18 03			jr .pastdmark  
3342 ..			.dmark: db "GRT"  
3345 f1			.pastdmark: pop af  
3346			endm  
# End of macro DMARK
3346						CALLMONITOR 
3346 cd d4 14			call break_point_state  
3349				endm  
# End of macro CALLMONITOR
3349					endif 
3349					FORTH_DSP 
3349 cd ee 1a			call macro_forth_dsp 
334c				endm 
# End of macro FORTH_DSP
334c					;FORTH_DSP_VALUE 
334c 7e					ld a,(hl)	; get type of value on TOS 
334d fe 02				cp DS_TYPE_INUM  
334f 28 00				jr z, .gt_inum 
3351			 
3351				if FORTH_ENABLE_FLOATMATH 
3351					jr .gt_done 
3351			 
3351				endif 
3351					 
3351			 
3351			.gt_inum: 
3351					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3351 cd 09 1b			call macro_dsp_valuehl 
3354				endm 
# End of macro FORTH_DSP_VALUEHL
3354			 
3354 e5					push hl  ; u2 
3355			 
3355					; destroy value TOS 
3355			 
3355					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3355 cd a5 1b			call macro_forth_dsp_pop 
3358				endm 
# End of macro FORTH_DSP_POP
3358			 
3358			 
3358					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3358 cd 09 1b			call macro_dsp_valuehl 
335b				endm 
# End of macro FORTH_DSP_VALUEHL
335b			 
335b e5					push hl    ; u1 
335c			 
335c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
335c cd a5 1b			call macro_forth_dsp_pop 
335f				endm 
# End of macro FORTH_DSP_POP
335f			 
335f			 
335f b7			 or a      ;clear carry flag 
3360 01 00 00		 ld bc, FORTH_FALSE 
3363 e1			  pop hl    ; u1 
3364 d1			  pop de    ; u2 
3365 ed 52		  sbc hl,de 
3367 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3369			 
3369 01 01 00		 ld bc, FORTH_TRUE 
336c			.gtcont:  
336c c5					push bc 
336d e1					pop hl 
336e			 
336e					if DEBUG_FORTH_WORDS 
336e						DMARK "GT1" 
336e f5				push af  
336f 3a 83 33			ld a, (.dmark)  
3372 32 bd fb			ld (debug_mark),a  
3375 3a 84 33			ld a, (.dmark+1)  
3378 32 be fb			ld (debug_mark+1),a  
337b 3a 85 33			ld a, (.dmark+2)  
337e 32 bf fb			ld (debug_mark+2),a  
3381 18 03			jr .pastdmark  
3383 ..			.dmark: db "GT1"  
3386 f1			.pastdmark: pop af  
3387			endm  
# End of macro DMARK
3387						CALLMONITOR 
3387 cd d4 14			call break_point_state  
338a				endm  
# End of macro CALLMONITOR
338a					endif 
338a cd 6e 1a				call forth_push_numhl 
338d			 
338d					NEXTW 
338d c3 5f 1c			jp macro_next 
3390				endm 
# End of macro NEXTW
3390			.EQUAL: 
3390				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3390 31				db WORD_SYS_CORE+29             
3391 fb 33			dw .ENDLOGIC            
3393 02				db 1 + 1 
3394 .. 00			db "=",0              
3396				endm 
# End of macro CWHEAD
3396			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3396				; TODO add floating point number detection 
3396					if DEBUG_FORTH_WORDS_KEY 
3396						DMARK "EQ." 
3396 f5				push af  
3397 3a ab 33			ld a, (.dmark)  
339a 32 bd fb			ld (debug_mark),a  
339d 3a ac 33			ld a, (.dmark+1)  
33a0 32 be fb			ld (debug_mark+1),a  
33a3 3a ad 33			ld a, (.dmark+2)  
33a6 32 bf fb			ld (debug_mark+2),a  
33a9 18 03			jr .pastdmark  
33ab ..			.dmark: db "EQ."  
33ae f1			.pastdmark: pop af  
33af			endm  
# End of macro DMARK
33af						CALLMONITOR 
33af cd d4 14			call break_point_state  
33b2				endm  
# End of macro CALLMONITOR
33b2					endif 
33b2					FORTH_DSP 
33b2 cd ee 1a			call macro_forth_dsp 
33b5				endm 
# End of macro FORTH_DSP
33b5					;v5 FORTH_DSP_VALUE 
33b5 7e					ld a,(hl)	; get type of value on TOS 
33b6 fe 02				cp DS_TYPE_INUM  
33b8 28 00				jr z, .eq_inum 
33ba			 
33ba				if FORTH_ENABLE_FLOATMATH 
33ba					jr .eq_done 
33ba			 
33ba				endif 
33ba					 
33ba			 
33ba			.eq_inum: 
33ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33ba cd 09 1b			call macro_dsp_valuehl 
33bd				endm 
# End of macro FORTH_DSP_VALUEHL
33bd			 
33bd e5					push hl 
33be			 
33be					; destroy value TOS 
33be			 
33be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33be cd a5 1b			call macro_forth_dsp_pop 
33c1				endm 
# End of macro FORTH_DSP_POP
33c1			 
33c1			 
33c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33c1 cd 09 1b			call macro_dsp_valuehl 
33c4				endm 
# End of macro FORTH_DSP_VALUEHL
33c4			 
33c4					; one value on hl get other one back 
33c4			 
33c4 e5					push hl 
33c5			 
33c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33c5 cd a5 1b			call macro_forth_dsp_pop 
33c8				endm 
# End of macro FORTH_DSP_POP
33c8			 
33c8 0e 00				ld c, FORTH_FALSE 
33ca			 
33ca e1					pop hl 
33cb d1					pop de 
33cc			 
33cc 7b					ld a, e 
33cd bd					cp l 
33ce			 
33ce 20 06				jr nz, .eq_done 
33d0			 
33d0 7a					ld a, d 
33d1 bc					cp h 
33d2			 
33d2 20 02				jr nz, .eq_done 
33d4			 
33d4 0e 01				ld c, FORTH_TRUE 
33d6					 
33d6			 
33d6			 
33d6			.eq_done: 
33d6			 
33d6					; TODO push value back onto stack for another op etc 
33d6			 
33d6 26 00				ld h, 0 
33d8 69					ld l, c 
33d9					if DEBUG_FORTH_WORDS 
33d9						DMARK "EQ1" 
33d9 f5				push af  
33da 3a ee 33			ld a, (.dmark)  
33dd 32 bd fb			ld (debug_mark),a  
33e0 3a ef 33			ld a, (.dmark+1)  
33e3 32 be fb			ld (debug_mark+1),a  
33e6 3a f0 33			ld a, (.dmark+2)  
33e9 32 bf fb			ld (debug_mark+2),a  
33ec 18 03			jr .pastdmark  
33ee ..			.dmark: db "EQ1"  
33f1 f1			.pastdmark: pop af  
33f2			endm  
# End of macro DMARK
33f2						CALLMONITOR 
33f2 cd d4 14			call break_point_state  
33f5				endm  
# End of macro CALLMONITOR
33f5					endif 
33f5 cd 6e 1a				call forth_push_numhl 
33f8			 
33f8					NEXTW 
33f8 c3 5f 1c			jp macro_next 
33fb				endm 
# End of macro NEXTW
33fb			 
33fb			 
33fb			.ENDLOGIC: 
33fb			; eof 
33fb			 
33fb			 
# End of file forth_words_logic.asm
33fb			include "forth_words_maths.asm" 
33fb			 
33fb			; | ## Maths Words 
33fb			 
33fb			.PLUS:	 
33fb				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
33fb 15				db WORD_SYS_CORE+1             
33fc 3d 34			dw .NEG            
33fe 02				db 1 + 1 
33ff .. 00			db "+",0              
3401				endm 
# End of macro CWHEAD
3401			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3401					if DEBUG_FORTH_WORDS_KEY 
3401						DMARK "PLU" 
3401 f5				push af  
3402 3a 16 34			ld a, (.dmark)  
3405 32 bd fb			ld (debug_mark),a  
3408 3a 17 34			ld a, (.dmark+1)  
340b 32 be fb			ld (debug_mark+1),a  
340e 3a 18 34			ld a, (.dmark+2)  
3411 32 bf fb			ld (debug_mark+2),a  
3414 18 03			jr .pastdmark  
3416 ..			.dmark: db "PLU"  
3419 f1			.pastdmark: pop af  
341a			endm  
# End of macro DMARK
341a						CALLMONITOR 
341a cd d4 14			call break_point_state  
341d				endm  
# End of macro CALLMONITOR
341d					endif 
341d					; add top two values and push back result 
341d			 
341d					;for v5 FORTH_DSP_VALUE 
341d					FORTH_DSP 
341d cd ee 1a			call macro_forth_dsp 
3420				endm 
# End of macro FORTH_DSP
3420 7e					ld a,(hl)	; get type of value on TOS 
3421 fe 02				cp DS_TYPE_INUM  
3423 28 03				jr z, .dot_inum 
3425			 
3425					NEXTW 
3425 c3 5f 1c			jp macro_next 
3428				endm 
# End of macro NEXTW
3428			 
3428			; float maths 
3428			 
3428				if FORTH_ENABLE_FLOATMATH 
3428						inc hl      ; now at start of numeric as string 
3428			 
3428					if DEBUG_FORTH_MATHS 
3428						DMARK "ADD" 
3428				CALLMONITOR 
3428					endif 
3428			 
3428					;ld ix, hl 
3428					call CON 
3428			 
3428			 
3428					push hl 
3428					 
3428					 
3428			 
3428						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3428			 
3428					; get next number 
3428			 
3428						FORTH_DSP_VALUE 
3428			 
3428						inc hl      ; now at start of numeric as string 
3428			 
3428					;ld ix, hl 
3428					call CON 
3428			 
3428					push hl 
3428			 
3428			 
3428						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3428			 
3428						; TODO do add 
3428			 
3428						call IADD 
3428			 
3428						; TODO get result back as ascii 
3428			 
3428						; TODO push result  
3428			 
3428			 
3428			 
3428						jr .dot_done 
3428				endif 
3428			 
3428			.dot_inum: 
3428			 
3428			 
3428					if DEBUG_FORTH_DOT 
3428						DMARK "+IT" 
3428				CALLMONITOR 
3428					endif 
3428			 
3428					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3428 cd 09 1b			call macro_dsp_valuehl 
342b				endm 
# End of macro FORTH_DSP_VALUEHL
342b			 
342b				; TODO add floating point number detection 
342b			 
342b e5					push hl 
342c			 
342c					; destroy value TOS 
342c			 
342c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
342c cd a5 1b			call macro_forth_dsp_pop 
342f				endm 
# End of macro FORTH_DSP_POP
342f			 
342f			 
342f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
342f cd 09 1b			call macro_dsp_valuehl 
3432				endm 
# End of macro FORTH_DSP_VALUEHL
3432			 
3432					; one value on hl get other one back 
3432			 
3432 d1					pop de 
3433			 
3433					; do the add 
3433			 
3433 19					add hl,de 
3434			 
3434					; save it 
3434			 
3434			;		push hl	 
3434			 
3434					; 
3434			 
3434					; destroy value TOS 
3434			 
3434					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3434 cd a5 1b			call macro_forth_dsp_pop 
3437				endm 
# End of macro FORTH_DSP_POP
3437			 
3437					; TODO push value back onto stack for another op etc 
3437			 
3437			;		pop hl 
3437			 
3437			.dot_done: 
3437 cd 6e 1a				call forth_push_numhl 
343a			 
343a					NEXTW 
343a c3 5f 1c			jp macro_next 
343d				endm 
# End of macro NEXTW
343d			.NEG: 
343d			 
343d				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
343d 17				db WORD_SYS_CORE+3             
343e 80 34			dw .DIV            
3440 02				db 1 + 1 
3441 .. 00			db "-",0              
3443				endm 
# End of macro CWHEAD
3443			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3443					if DEBUG_FORTH_WORDS_KEY 
3443						DMARK "SUB" 
3443 f5				push af  
3444 3a 58 34			ld a, (.dmark)  
3447 32 bd fb			ld (debug_mark),a  
344a 3a 59 34			ld a, (.dmark+1)  
344d 32 be fb			ld (debug_mark+1),a  
3450 3a 5a 34			ld a, (.dmark+2)  
3453 32 bf fb			ld (debug_mark+2),a  
3456 18 03			jr .pastdmark  
3458 ..			.dmark: db "SUB"  
345b f1			.pastdmark: pop af  
345c			endm  
# End of macro DMARK
345c						CALLMONITOR 
345c cd d4 14			call break_point_state  
345f				endm  
# End of macro CALLMONITOR
345f					endif 
345f			 
345f			 
345f				; TODO add floating point number detection 
345f					; v5 FORTH_DSP_VALUE 
345f					FORTH_DSP 
345f cd ee 1a			call macro_forth_dsp 
3462				endm 
# End of macro FORTH_DSP
3462 7e					ld a,(hl)	; get type of value on TOS 
3463 fe 02				cp DS_TYPE_INUM  
3465 28 03				jr z, .neg_inum 
3467			 
3467					NEXTW 
3467 c3 5f 1c			jp macro_next 
346a				endm 
# End of macro NEXTW
346a			 
346a			; float maths 
346a			 
346a				if FORTH_ENABLE_FLOATMATH 
346a					jr .neg_done 
346a			 
346a				endif 
346a					 
346a			 
346a			.neg_inum: 
346a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
346a cd 09 1b			call macro_dsp_valuehl 
346d				endm 
# End of macro FORTH_DSP_VALUEHL
346d			 
346d e5					push hl 
346e			 
346e					; destroy value TOS 
346e			 
346e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
346e cd a5 1b			call macro_forth_dsp_pop 
3471				endm 
# End of macro FORTH_DSP_POP
3471			 
3471			 
3471					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3471 cd 09 1b			call macro_dsp_valuehl 
3474				endm 
# End of macro FORTH_DSP_VALUEHL
3474			 
3474					; one value on hl get other one back 
3474			 
3474 d1					pop de 
3475			 
3475					; do the sub 
3475			;		ex de, hl 
3475			 
3475 ed 52				sbc hl,de 
3477			 
3477					; save it 
3477			 
3477			;		push hl	 
3477			 
3477					; 
3477			 
3477					; destroy value TOS 
3477			 
3477					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3477 cd a5 1b			call macro_forth_dsp_pop 
347a				endm 
# End of macro FORTH_DSP_POP
347a			 
347a					; TODO push value back onto stack for another op etc 
347a			 
347a			;		pop hl 
347a			 
347a cd 6e 1a				call forth_push_numhl 
347d			.neg_done: 
347d			 
347d					NEXTW 
347d c3 5f 1c			jp macro_next 
3480				endm 
# End of macro NEXTW
3480			.DIV: 
3480				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3480 18				db WORD_SYS_CORE+4             
3481 cd 34			dw .MUL            
3483 02				db 1 + 1 
3484 .. 00			db "/",0              
3486				endm 
# End of macro CWHEAD
3486			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3486					if DEBUG_FORTH_WORDS_KEY 
3486						DMARK "DIV" 
3486 f5				push af  
3487 3a 9b 34			ld a, (.dmark)  
348a 32 bd fb			ld (debug_mark),a  
348d 3a 9c 34			ld a, (.dmark+1)  
3490 32 be fb			ld (debug_mark+1),a  
3493 3a 9d 34			ld a, (.dmark+2)  
3496 32 bf fb			ld (debug_mark+2),a  
3499 18 03			jr .pastdmark  
349b ..			.dmark: db "DIV"  
349e f1			.pastdmark: pop af  
349f			endm  
# End of macro DMARK
349f						CALLMONITOR 
349f cd d4 14			call break_point_state  
34a2				endm  
# End of macro CALLMONITOR
34a2					endif 
34a2				; TODO add floating point number detection 
34a2					; v5 FORTH_DSP_VALUE 
34a2					FORTH_DSP 
34a2 cd ee 1a			call macro_forth_dsp 
34a5				endm 
# End of macro FORTH_DSP
34a5 7e					ld a,(hl)	; get type of value on TOS 
34a6 fe 02				cp DS_TYPE_INUM  
34a8 28 03				jr z, .div_inum 
34aa			 
34aa				if FORTH_ENABLE_FLOATMATH 
34aa					jr .div_done 
34aa			 
34aa				endif 
34aa					NEXTW 
34aa c3 5f 1c			jp macro_next 
34ad				endm 
# End of macro NEXTW
34ad			.div_inum: 
34ad			 
34ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34ad cd 09 1b			call macro_dsp_valuehl 
34b0				endm 
# End of macro FORTH_DSP_VALUEHL
34b0			 
34b0 e5					push hl    ; to go to bc 
34b1			 
34b1					; destroy value TOS 
34b1			 
34b1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34b1 cd a5 1b			call macro_forth_dsp_pop 
34b4				endm 
# End of macro FORTH_DSP_POP
34b4			 
34b4			 
34b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34b4 cd 09 1b			call macro_dsp_valuehl 
34b7				endm 
# End of macro FORTH_DSP_VALUEHL
34b7			 
34b7					; hl to go to de 
34b7			 
34b7 e5					push hl 
34b8			 
34b8 c1					pop bc 
34b9 d1					pop de		 
34ba			 
34ba			 
34ba					if DEBUG_FORTH_MATHS 
34ba						DMARK "DIV" 
34ba				CALLMONITOR 
34ba					endif 
34ba					; one value on hl but move to a get other one back 
34ba			 
34ba			        
34ba cd 19 0c			call Div16 
34bd			 
34bd			;	push af	 
34bd e5				push hl 
34be c5				push bc 
34bf			 
34bf					if DEBUG_FORTH_MATHS 
34bf						DMARK "DI1" 
34bf				CALLMONITOR 
34bf					endif 
34bf			 
34bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34bf cd a5 1b			call macro_forth_dsp_pop 
34c2				endm 
# End of macro FORTH_DSP_POP
34c2			 
34c2			 
34c2			 
34c2 e1					pop hl    ; result 
34c3			 
34c3 cd 6e 1a				call forth_push_numhl 
34c6			 
34c6 e1					pop hl    ; reminder 
34c7			;		ld h,0 
34c7			;		ld l,d 
34c7			 
34c7 cd 6e 1a				call forth_push_numhl 
34ca			.div_done: 
34ca					NEXTW 
34ca c3 5f 1c			jp macro_next 
34cd				endm 
# End of macro NEXTW
34cd			.MUL: 
34cd				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
34cd 19				db WORD_SYS_CORE+5             
34ce 12 35			dw .MIN            
34d0 02				db 1 + 1 
34d1 .. 00			db "*",0              
34d3				endm 
# End of macro CWHEAD
34d3			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
34d3				; TODO add floating point number detection 
34d3					if DEBUG_FORTH_WORDS_KEY 
34d3						DMARK "MUL" 
34d3 f5				push af  
34d4 3a e8 34			ld a, (.dmark)  
34d7 32 bd fb			ld (debug_mark),a  
34da 3a e9 34			ld a, (.dmark+1)  
34dd 32 be fb			ld (debug_mark+1),a  
34e0 3a ea 34			ld a, (.dmark+2)  
34e3 32 bf fb			ld (debug_mark+2),a  
34e6 18 03			jr .pastdmark  
34e8 ..			.dmark: db "MUL"  
34eb f1			.pastdmark: pop af  
34ec			endm  
# End of macro DMARK
34ec						CALLMONITOR 
34ec cd d4 14			call break_point_state  
34ef				endm  
# End of macro CALLMONITOR
34ef					endif 
34ef					FORTH_DSP 
34ef cd ee 1a			call macro_forth_dsp 
34f2				endm 
# End of macro FORTH_DSP
34f2					; v5 FORTH_DSP_VALUE 
34f2 7e					ld a,(hl)	; get type of value on TOS 
34f3 fe 02				cp DS_TYPE_INUM  
34f5 28 03				jr z, .mul_inum 
34f7			 
34f7				if FORTH_ENABLE_FLOATMATH 
34f7					jr .mul_done 
34f7			 
34f7				endif 
34f7			 
34f7					NEXTW 
34f7 c3 5f 1c			jp macro_next 
34fa				endm 
# End of macro NEXTW
34fa			.mul_inum:	 
34fa			 
34fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34fa cd 09 1b			call macro_dsp_valuehl 
34fd				endm 
# End of macro FORTH_DSP_VALUEHL
34fd			 
34fd e5					push hl 
34fe			 
34fe					; destroy value TOS 
34fe			 
34fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34fe cd a5 1b			call macro_forth_dsp_pop 
3501				endm 
# End of macro FORTH_DSP_POP
3501			 
3501			 
3501					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3501 cd 09 1b			call macro_dsp_valuehl 
3504				endm 
# End of macro FORTH_DSP_VALUEHL
3504			 
3504					; one value on hl but move to a get other one back 
3504			 
3504 7d					ld a, l 
3505			 
3505 d1					pop de 
3506			 
3506					; do the mull 
3506			;		ex de, hl 
3506			 
3506 cd 3f 0c				call Mult16 
3509					; save it 
3509			 
3509			;		push hl	 
3509			 
3509					; 
3509			 
3509					; destroy value TOS 
3509			 
3509					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3509 cd a5 1b			call macro_forth_dsp_pop 
350c				endm 
# End of macro FORTH_DSP_POP
350c			 
350c					; TODO push value back onto stack for another op etc 
350c			 
350c			;		pop hl 
350c			 
350c cd 6e 1a				call forth_push_numhl 
350f			 
350f			.mul_done: 
350f					NEXTW 
350f c3 5f 1c			jp macro_next 
3512				endm 
# End of macro NEXTW
3512			 
3512			 
3512			 
3512			 
3512			.MIN: 
3512				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3512 49				db WORD_SYS_CORE+53             
3513 93 35			dw .MAX            
3515 04				db 3 + 1 
3516 .. 00			db "MIN",0              
351a				endm 
# End of macro CWHEAD
351a			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
351a					if DEBUG_FORTH_WORDS_KEY 
351a						DMARK "MIN" 
351a f5				push af  
351b 3a 2f 35			ld a, (.dmark)  
351e 32 bd fb			ld (debug_mark),a  
3521 3a 30 35			ld a, (.dmark+1)  
3524 32 be fb			ld (debug_mark+1),a  
3527 3a 31 35			ld a, (.dmark+2)  
352a 32 bf fb			ld (debug_mark+2),a  
352d 18 03			jr .pastdmark  
352f ..			.dmark: db "MIN"  
3532 f1			.pastdmark: pop af  
3533			endm  
# End of macro DMARK
3533						CALLMONITOR 
3533 cd d4 14			call break_point_state  
3536				endm  
# End of macro CALLMONITOR
3536					endif 
3536					; get u2 
3536			 
3536					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3536 cd 09 1b			call macro_dsp_valuehl 
3539				endm 
# End of macro FORTH_DSP_VALUEHL
3539			 
3539 e5					push hl   ; u2 
353a			 
353a					; destroy value TOS 
353a			 
353a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
353a cd a5 1b			call macro_forth_dsp_pop 
353d				endm 
# End of macro FORTH_DSP_POP
353d			 
353d					; get u1 
353d			 
353d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
353d cd 09 1b			call macro_dsp_valuehl 
3540				endm 
# End of macro FORTH_DSP_VALUEHL
3540			 
3540 e5					push hl  ; u1 
3541			 
3541					; destroy value TOS 
3541			 
3541					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3541 cd a5 1b			call macro_forth_dsp_pop 
3544				endm 
# End of macro FORTH_DSP_POP
3544			 
3544 b7			 or a      ;clear carry flag 
3545 e1			  pop hl    ; u1 
3546 d1			  pop de    ; u2 
3547 e5				push hl   ; saved in case hl is lowest 
3548 ed 52		  sbc hl,de 
354a 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
354c			 
354c e1				pop hl 
354d					if DEBUG_FORTH_WORDS 
354d						DMARK "MIN" 
354d f5				push af  
354e 3a 62 35			ld a, (.dmark)  
3551 32 bd fb			ld (debug_mark),a  
3554 3a 63 35			ld a, (.dmark+1)  
3557 32 be fb			ld (debug_mark+1),a  
355a 3a 64 35			ld a, (.dmark+2)  
355d 32 bf fb			ld (debug_mark+2),a  
3560 18 03			jr .pastdmark  
3562 ..			.dmark: db "MIN"  
3565 f1			.pastdmark: pop af  
3566			endm  
# End of macro DMARK
3566						CALLMONITOR 
3566 cd d4 14			call break_point_state  
3569				endm  
# End of macro CALLMONITOR
3569					endif 
3569 cd 6e 1a				call forth_push_numhl 
356c			 
356c				       NEXTW 
356c c3 5f 1c			jp macro_next 
356f				endm 
# End of macro NEXTW
356f			 
356f			.mincont:  
356f c1				pop bc   ; tidy up 
3570 eb				ex de , hl  
3571					if DEBUG_FORTH_WORDS 
3571						DMARK "MI1" 
3571 f5				push af  
3572 3a 86 35			ld a, (.dmark)  
3575 32 bd fb			ld (debug_mark),a  
3578 3a 87 35			ld a, (.dmark+1)  
357b 32 be fb			ld (debug_mark+1),a  
357e 3a 88 35			ld a, (.dmark+2)  
3581 32 bf fb			ld (debug_mark+2),a  
3584 18 03			jr .pastdmark  
3586 ..			.dmark: db "MI1"  
3589 f1			.pastdmark: pop af  
358a			endm  
# End of macro DMARK
358a						CALLMONITOR 
358a cd d4 14			call break_point_state  
358d				endm  
# End of macro CALLMONITOR
358d					endif 
358d cd 6e 1a				call forth_push_numhl 
3590			 
3590				       NEXTW 
3590 c3 5f 1c			jp macro_next 
3593				endm 
# End of macro NEXTW
3593			.MAX: 
3593				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3593 4a				db WORD_SYS_CORE+54             
3594 14 36			dw .RND16            
3596 04				db 3 + 1 
3597 .. 00			db "MAX",0              
359b				endm 
# End of macro CWHEAD
359b			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
359b					if DEBUG_FORTH_WORDS_KEY 
359b						DMARK "MAX" 
359b f5				push af  
359c 3a b0 35			ld a, (.dmark)  
359f 32 bd fb			ld (debug_mark),a  
35a2 3a b1 35			ld a, (.dmark+1)  
35a5 32 be fb			ld (debug_mark+1),a  
35a8 3a b2 35			ld a, (.dmark+2)  
35ab 32 bf fb			ld (debug_mark+2),a  
35ae 18 03			jr .pastdmark  
35b0 ..			.dmark: db "MAX"  
35b3 f1			.pastdmark: pop af  
35b4			endm  
# End of macro DMARK
35b4						CALLMONITOR 
35b4 cd d4 14			call break_point_state  
35b7				endm  
# End of macro CALLMONITOR
35b7					endif 
35b7					; get u2 
35b7			 
35b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35b7 cd 09 1b			call macro_dsp_valuehl 
35ba				endm 
# End of macro FORTH_DSP_VALUEHL
35ba			 
35ba e5					push hl   ; u2 
35bb			 
35bb					; destroy value TOS 
35bb			 
35bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35bb cd a5 1b			call macro_forth_dsp_pop 
35be				endm 
# End of macro FORTH_DSP_POP
35be			 
35be					; get u1 
35be			 
35be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35be cd 09 1b			call macro_dsp_valuehl 
35c1				endm 
# End of macro FORTH_DSP_VALUEHL
35c1			 
35c1 e5					push hl  ; u1 
35c2			 
35c2					; destroy value TOS 
35c2			 
35c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35c2 cd a5 1b			call macro_forth_dsp_pop 
35c5				endm 
# End of macro FORTH_DSP_POP
35c5			 
35c5 b7			 or a      ;clear carry flag 
35c6 e1			  pop hl    ; u1 
35c7 d1			  pop de    ; u2 
35c8 e5				push hl   ; saved in case hl is lowest 
35c9 ed 52		  sbc hl,de 
35cb 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
35cd			 
35cd e1				pop hl 
35ce					if DEBUG_FORTH_WORDS 
35ce						DMARK "MAX" 
35ce f5				push af  
35cf 3a e3 35			ld a, (.dmark)  
35d2 32 bd fb			ld (debug_mark),a  
35d5 3a e4 35			ld a, (.dmark+1)  
35d8 32 be fb			ld (debug_mark+1),a  
35db 3a e5 35			ld a, (.dmark+2)  
35de 32 bf fb			ld (debug_mark+2),a  
35e1 18 03			jr .pastdmark  
35e3 ..			.dmark: db "MAX"  
35e6 f1			.pastdmark: pop af  
35e7			endm  
# End of macro DMARK
35e7						CALLMONITOR 
35e7 cd d4 14			call break_point_state  
35ea				endm  
# End of macro CALLMONITOR
35ea					endif 
35ea cd 6e 1a				call forth_push_numhl 
35ed			 
35ed				       NEXTW 
35ed c3 5f 1c			jp macro_next 
35f0				endm 
# End of macro NEXTW
35f0			 
35f0			.maxcont:  
35f0 c1				pop bc   ; tidy up 
35f1 eb				ex de , hl  
35f2					if DEBUG_FORTH_WORDS 
35f2						DMARK "MA1" 
35f2 f5				push af  
35f3 3a 07 36			ld a, (.dmark)  
35f6 32 bd fb			ld (debug_mark),a  
35f9 3a 08 36			ld a, (.dmark+1)  
35fc 32 be fb			ld (debug_mark+1),a  
35ff 3a 09 36			ld a, (.dmark+2)  
3602 32 bf fb			ld (debug_mark+2),a  
3605 18 03			jr .pastdmark  
3607 ..			.dmark: db "MA1"  
360a f1			.pastdmark: pop af  
360b			endm  
# End of macro DMARK
360b						CALLMONITOR 
360b cd d4 14			call break_point_state  
360e				endm  
# End of macro CALLMONITOR
360e					endif 
360e cd 6e 1a				call forth_push_numhl 
3611				       NEXTW 
3611 c3 5f 1c			jp macro_next 
3614				endm 
# End of macro NEXTW
3614			 
3614			.RND16: 
3614				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3614 4e				db WORD_SYS_CORE+58             
3615 43 36			dw .RND8            
3617 06				db 5 + 1 
3618 .. 00			db "RND16",0              
361e				endm 
# End of macro CWHEAD
361e			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
361e					if DEBUG_FORTH_WORDS_KEY 
361e						DMARK "R16" 
361e f5				push af  
361f 3a 33 36			ld a, (.dmark)  
3622 32 bd fb			ld (debug_mark),a  
3625 3a 34 36			ld a, (.dmark+1)  
3628 32 be fb			ld (debug_mark+1),a  
362b 3a 35 36			ld a, (.dmark+2)  
362e 32 bf fb			ld (debug_mark+2),a  
3631 18 03			jr .pastdmark  
3633 ..			.dmark: db "R16"  
3636 f1			.pastdmark: pop af  
3637			endm  
# End of macro DMARK
3637						CALLMONITOR 
3637 cd d4 14			call break_point_state  
363a				endm  
# End of macro CALLMONITOR
363a					endif 
363a cd e3 0b				call prng16  
363d cd 6e 1a				call forth_push_numhl 
3640				       NEXTW 
3640 c3 5f 1c			jp macro_next 
3643				endm 
# End of macro NEXTW
3643			.RND8: 
3643				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3643 60				db WORD_SYS_CORE+76             
3644 78 36			dw .RND            
3646 05				db 4 + 1 
3647 .. 00			db "RND8",0              
364c				endm 
# End of macro CWHEAD
364c			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
364c					if DEBUG_FORTH_WORDS_KEY 
364c						DMARK "RN8" 
364c f5				push af  
364d 3a 61 36			ld a, (.dmark)  
3650 32 bd fb			ld (debug_mark),a  
3653 3a 62 36			ld a, (.dmark+1)  
3656 32 be fb			ld (debug_mark+1),a  
3659 3a 63 36			ld a, (.dmark+2)  
365c 32 bf fb			ld (debug_mark+2),a  
365f 18 03			jr .pastdmark  
3661 ..			.dmark: db "RN8"  
3664 f1			.pastdmark: pop af  
3665			endm  
# End of macro DMARK
3665						CALLMONITOR 
3665 cd d4 14			call break_point_state  
3668				endm  
# End of macro CALLMONITOR
3668					endif 
3668 2a 3e fa				ld hl,(xrandc) 
366b 23					inc hl 
366c cd fd 0b				call xrnd 
366f 6f					ld l,a	 
3670 26 00				ld h,0 
3672 cd 6e 1a				call forth_push_numhl 
3675				       NEXTW 
3675 c3 5f 1c			jp macro_next 
3678				endm 
# End of macro NEXTW
3678			.RND: 
3678				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3678 60				db WORD_SYS_CORE+76             
3679 7e 37			dw .ENDMATHS            
367b 04				db 3 + 1 
367c .. 00			db "RND",0              
3680				endm 
# End of macro CWHEAD
3680			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3680			 
3680					if DEBUG_FORTH_WORDS_KEY 
3680						DMARK "RND" 
3680 f5				push af  
3681 3a 95 36			ld a, (.dmark)  
3684 32 bd fb			ld (debug_mark),a  
3687 3a 96 36			ld a, (.dmark+1)  
368a 32 be fb			ld (debug_mark+1),a  
368d 3a 97 36			ld a, (.dmark+2)  
3690 32 bf fb			ld (debug_mark+2),a  
3693 18 03			jr .pastdmark  
3695 ..			.dmark: db "RND"  
3698 f1			.pastdmark: pop af  
3699			endm  
# End of macro DMARK
3699						CALLMONITOR 
3699 cd d4 14			call break_point_state  
369c				endm  
# End of macro CALLMONITOR
369c					endif 
369c					 
369c					FORTH_DSP_VALUEHL    ; upper range 
369c cd 09 1b			call macro_dsp_valuehl 
369f				endm 
# End of macro FORTH_DSP_VALUEHL
369f			 
369f 22 42 fa				ld (LFSRSeed), hl	 
36a2			 
36a2					if DEBUG_FORTH_WORDS 
36a2						DMARK "RN1" 
36a2 f5				push af  
36a3 3a b7 36			ld a, (.dmark)  
36a6 32 bd fb			ld (debug_mark),a  
36a9 3a b8 36			ld a, (.dmark+1)  
36ac 32 be fb			ld (debug_mark+1),a  
36af 3a b9 36			ld a, (.dmark+2)  
36b2 32 bf fb			ld (debug_mark+2),a  
36b5 18 03			jr .pastdmark  
36b7 ..			.dmark: db "RN1"  
36ba f1			.pastdmark: pop af  
36bb			endm  
# End of macro DMARK
36bb						CALLMONITOR 
36bb cd d4 14			call break_point_state  
36be				endm  
# End of macro CALLMONITOR
36be					endif 
36be					FORTH_DSP_POP 
36be cd a5 1b			call macro_forth_dsp_pop 
36c1				endm 
# End of macro FORTH_DSP_POP
36c1			 
36c1					FORTH_DSP_VALUEHL    ; low range 
36c1 cd 09 1b			call macro_dsp_valuehl 
36c4				endm 
# End of macro FORTH_DSP_VALUEHL
36c4			 
36c4					if DEBUG_FORTH_WORDS 
36c4						DMARK "RN2" 
36c4 f5				push af  
36c5 3a d9 36			ld a, (.dmark)  
36c8 32 bd fb			ld (debug_mark),a  
36cb 3a da 36			ld a, (.dmark+1)  
36ce 32 be fb			ld (debug_mark+1),a  
36d1 3a db 36			ld a, (.dmark+2)  
36d4 32 bf fb			ld (debug_mark+2),a  
36d7 18 03			jr .pastdmark  
36d9 ..			.dmark: db "RN2"  
36dc f1			.pastdmark: pop af  
36dd			endm  
# End of macro DMARK
36dd						CALLMONITOR 
36dd cd d4 14			call break_point_state  
36e0				endm  
# End of macro CALLMONITOR
36e0					endif 
36e0 22 44 fa				ld (LFSRSeed+2), hl 
36e3			 
36e3					FORTH_DSP_POP 
36e3 cd a5 1b			call macro_forth_dsp_pop 
36e6				endm 
# End of macro FORTH_DSP_POP
36e6			 
36e6 e5					push hl 
36e7			 
36e7 e1			.inrange:	pop hl 
36e8 cd e3 0b				call prng16  
36eb					if DEBUG_FORTH_WORDS 
36eb						DMARK "RN3" 
36eb f5				push af  
36ec 3a 00 37			ld a, (.dmark)  
36ef 32 bd fb			ld (debug_mark),a  
36f2 3a 01 37			ld a, (.dmark+1)  
36f5 32 be fb			ld (debug_mark+1),a  
36f8 3a 02 37			ld a, (.dmark+2)  
36fb 32 bf fb			ld (debug_mark+2),a  
36fe 18 03			jr .pastdmark  
3700 ..			.dmark: db "RN3"  
3703 f1			.pastdmark: pop af  
3704			endm  
# End of macro DMARK
3704						CALLMONITOR 
3704 cd d4 14			call break_point_state  
3707				endm  
# End of macro CALLMONITOR
3707					endif 
3707					 
3707					; if the range is 8bit knock out the high byte 
3707			 
3707 ed 5b 42 fa			ld de, (LFSRSeed)     ; check high level 
370b			 
370b 3e 00				ld a, 0 
370d ba					cp d  
370e 20 1e				jr nz, .hirange 
3710 26 00				ld h, 0   ; knock it down to 8bit 
3712			 
3712					if DEBUG_FORTH_WORDS 
3712						DMARK "RNk" 
3712 f5				push af  
3713 3a 27 37			ld a, (.dmark)  
3716 32 bd fb			ld (debug_mark),a  
3719 3a 28 37			ld a, (.dmark+1)  
371c 32 be fb			ld (debug_mark+1),a  
371f 3a 29 37			ld a, (.dmark+2)  
3722 32 bf fb			ld (debug_mark+2),a  
3725 18 03			jr .pastdmark  
3727 ..			.dmark: db "RNk"  
372a f1			.pastdmark: pop af  
372b			endm  
# End of macro DMARK
372b						CALLMONITOR 
372b cd d4 14			call break_point_state  
372e				endm  
# End of macro CALLMONITOR
372e					endif 
372e			.hirange:   
372e e5					push hl  
372f b7					or a  
3730 ed 52		                sbc hl, de 
3732			 
3732					;call cmp16 
3732			 
3732 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3734 e1					pop hl 
3735 e5					push hl 
3736			 
3736					if DEBUG_FORTH_WORDS 
3736						DMARK "RN4" 
3736 f5				push af  
3737 3a 4b 37			ld a, (.dmark)  
373a 32 bd fb			ld (debug_mark),a  
373d 3a 4c 37			ld a, (.dmark+1)  
3740 32 be fb			ld (debug_mark+1),a  
3743 3a 4d 37			ld a, (.dmark+2)  
3746 32 bf fb			ld (debug_mark+2),a  
3749 18 03			jr .pastdmark  
374b ..			.dmark: db "RN4"  
374e f1			.pastdmark: pop af  
374f			endm  
# End of macro DMARK
374f						CALLMONITOR 
374f cd d4 14			call break_point_state  
3752				endm  
# End of macro CALLMONITOR
3752					endif 
3752 ed 5b 44 fa			ld de, (LFSRSeed+2)   ; check low range 
3756					;call cmp16 
3756				 
3756 b7					or a  
3757 ed 52		                sbc hl, de 
3759 38 8c				jr c, .inrange 
375b			 
375b e1					pop hl 
375c					 
375c					if DEBUG_FORTH_WORDS 
375c						DMARK "RNd" 
375c f5				push af  
375d 3a 71 37			ld a, (.dmark)  
3760 32 bd fb			ld (debug_mark),a  
3763 3a 72 37			ld a, (.dmark+1)  
3766 32 be fb			ld (debug_mark+1),a  
3769 3a 73 37			ld a, (.dmark+2)  
376c 32 bf fb			ld (debug_mark+2),a  
376f 18 03			jr .pastdmark  
3771 ..			.dmark: db "RNd"  
3774 f1			.pastdmark: pop af  
3775			endm  
# End of macro DMARK
3775						CALLMONITOR 
3775 cd d4 14			call break_point_state  
3778				endm  
# End of macro CALLMONITOR
3778					endif 
3778			 
3778			 
3778 cd 6e 1a				call forth_push_numhl 
377b				       NEXTW 
377b c3 5f 1c			jp macro_next 
377e				endm 
# End of macro NEXTW
377e			 
377e			.ENDMATHS: 
377e			 
377e			; eof 
377e			 
# End of file forth_words_maths.asm
377e			include "forth_words_display.asm" 
377e			 
377e			; | ## Display Words 
377e			 
377e			.ATP: 
377e				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
377e 62				db WORD_SYS_CORE+78             
377f f5 37			dw .FB            
3781 04				db 3 + 1 
3782 .. 00			db "AT?",0              
3786				endm 
# End of macro CWHEAD
3786			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3786					if DEBUG_FORTH_WORDS_KEY 
3786						DMARK "AT?" 
3786 f5				push af  
3787 3a 9b 37			ld a, (.dmark)  
378a 32 bd fb			ld (debug_mark),a  
378d 3a 9c 37			ld a, (.dmark+1)  
3790 32 be fb			ld (debug_mark+1),a  
3793 3a 9d 37			ld a, (.dmark+2)  
3796 32 bf fb			ld (debug_mark+2),a  
3799 18 03			jr .pastdmark  
379b ..			.dmark: db "AT?"  
379e f1			.pastdmark: pop af  
379f			endm  
# End of macro DMARK
379f						CALLMONITOR 
379f cd d4 14			call break_point_state  
37a2				endm  
# End of macro CALLMONITOR
37a2					endif 
37a2 3a e1 f9				ld a, (f_cursor_ptr) 
37a5			 
37a5			if DEBUG_FORTH_WORDS 
37a5				DMARK "AT?" 
37a5 f5				push af  
37a6 3a ba 37			ld a, (.dmark)  
37a9 32 bd fb			ld (debug_mark),a  
37ac 3a bb 37			ld a, (.dmark+1)  
37af 32 be fb			ld (debug_mark+1),a  
37b2 3a bc 37			ld a, (.dmark+2)  
37b5 32 bf fb			ld (debug_mark+2),a  
37b8 18 03			jr .pastdmark  
37ba ..			.dmark: db "AT?"  
37bd f1			.pastdmark: pop af  
37be			endm  
# End of macro DMARK
37be				CALLMONITOR 
37be cd d4 14			call break_point_state  
37c1				endm  
# End of macro CALLMONITOR
37c1			endif	 
37c1					; count the number of rows 
37c1			 
37c1 06 00				ld b, 0 
37c3 4f			.atpr:		ld c, a    ; save in case we go below zero 
37c4 d6 14				sub display_cols 
37c6 f2 cc 37				jp p, .atprunder 
37c9 04					inc b 
37ca 18 f7				jr .atpr 
37cc			.atprunder:	 
37cc			if DEBUG_FORTH_WORDS 
37cc				DMARK "A?2" 
37cc f5				push af  
37cd 3a e1 37			ld a, (.dmark)  
37d0 32 bd fb			ld (debug_mark),a  
37d3 3a e2 37			ld a, (.dmark+1)  
37d6 32 be fb			ld (debug_mark+1),a  
37d9 3a e3 37			ld a, (.dmark+2)  
37dc 32 bf fb			ld (debug_mark+2),a  
37df 18 03			jr .pastdmark  
37e1 ..			.dmark: db "A?2"  
37e4 f1			.pastdmark: pop af  
37e5			endm  
# End of macro DMARK
37e5				CALLMONITOR 
37e5 cd d4 14			call break_point_state  
37e8				endm  
# End of macro CALLMONITOR
37e8			endif	 
37e8 26 00				ld h, 0 
37ea 69					ld l, c 
37eb cd 6e 1a				call forth_push_numhl 
37ee 68					ld l, b  
37ef cd 6e 1a				call forth_push_numhl 
37f2			 
37f2			 
37f2				NEXTW 
37f2 c3 5f 1c			jp macro_next 
37f5				endm 
# End of macro NEXTW
37f5			 
37f5			.FB: 
37f5				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
37f5 1b				db WORD_SYS_CORE+7             
37f6 43 38			dw .EMIT            
37f8 03				db 2 + 1 
37f9 .. 00			db "FB",0              
37fc				endm 
# End of macro CWHEAD
37fc			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
37fc			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
37fc			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
37fc			; | | If automatic display is off then updates will not be shown until DRAW is used. 
37fc					if DEBUG_FORTH_WORDS_KEY 
37fc						DMARK "FB." 
37fc f5				push af  
37fd 3a 11 38			ld a, (.dmark)  
3800 32 bd fb			ld (debug_mark),a  
3803 3a 12 38			ld a, (.dmark+1)  
3806 32 be fb			ld (debug_mark+1),a  
3809 3a 13 38			ld a, (.dmark+2)  
380c 32 bf fb			ld (debug_mark+2),a  
380f 18 03			jr .pastdmark  
3811 ..			.dmark: db "FB."  
3814 f1			.pastdmark: pop af  
3815			endm  
# End of macro DMARK
3815						CALLMONITOR 
3815 cd d4 14			call break_point_state  
3818				endm  
# End of macro CALLMONITOR
3818					endif 
3818			 
3818					FORTH_DSP_VALUEHL 
3818 cd 09 1b			call macro_dsp_valuehl 
381b				endm 
# End of macro FORTH_DSP_VALUEHL
381b			 
381b 7d					ld a, l 
381c fe 01				cp 1 
381e 20 05				jr nz, .fbn1 
3820 21 02 fb				ld hl, display_fb1 
3823 18 15				jr .fbset 
3825 fe 02		.fbn1:		cp 2 
3827 20 05				jr nz, .fbn2 
3829 21 60 fa				ld hl, display_fb2 
382c 18 0c				jr .fbset 
382e fe 03		.fbn2:		cp 3 
3830 20 05				jr nz, .fbn3 
3832 21 b1 fa				ld hl, display_fb3 
3835 18 03				jr .fbset 
3837			.fbn3:		 ; if invalid number select first 
3837 21 02 fb				ld hl, display_fb1 
383a 22 5e fa		.fbset:		ld (display_fb_active), hl 
383d			 
383d					FORTH_DSP_POP 
383d cd a5 1b			call macro_forth_dsp_pop 
3840				endm 
# End of macro FORTH_DSP_POP
3840			 
3840					NEXTW 
3840 c3 5f 1c			jp macro_next 
3843				endm 
# End of macro NEXTW
3843			 
3843			 
3843			.EMIT: 
3843				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3843 1b				db WORD_SYS_CORE+7             
3844 94 38			dw .DOTH            
3846 05				db 4 + 1 
3847 .. 00			db "EMIT",0              
384c				endm 
# End of macro CWHEAD
384c			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
384c					; get value off TOS and display it 
384c			 
384c					if DEBUG_FORTH_WORDS_KEY 
384c						DMARK "EMT" 
384c f5				push af  
384d 3a 61 38			ld a, (.dmark)  
3850 32 bd fb			ld (debug_mark),a  
3853 3a 62 38			ld a, (.dmark+1)  
3856 32 be fb			ld (debug_mark+1),a  
3859 3a 63 38			ld a, (.dmark+2)  
385c 32 bf fb			ld (debug_mark+2),a  
385f 18 03			jr .pastdmark  
3861 ..			.dmark: db "EMT"  
3864 f1			.pastdmark: pop af  
3865			endm  
# End of macro DMARK
3865						CALLMONITOR 
3865 cd d4 14			call break_point_state  
3868				endm  
# End of macro CALLMONITOR
3868					endif 
3868			 
3868					FORTH_DSP_VALUEHL 
3868 cd 09 1b			call macro_dsp_valuehl 
386b				endm 
# End of macro FORTH_DSP_VALUEHL
386b			 
386b 7d					ld a,l 
386c			 
386c					; TODO write to display 
386c			 
386c 32 b6 f1				ld (os_input), a 
386f 3e 00				ld a, 0 
3871 32 b7 f1				ld (os_input+1), a 
3874					 
3874 3a e1 f9				ld a, (f_cursor_ptr) 
3877 11 b6 f1				ld de, os_input 
387a cd 9f 0a				call str_at_display 
387d			 
387d			 
387d 3a bf f9				ld a,(cli_autodisplay) 
3880 fe 00				cp 0 
3882 28 03				jr z, .enoupdate 
3884 cd af 0a						call update_display 
3887					.enoupdate: 
3887			 
3887 3a e1 f9				ld a, (f_cursor_ptr) 
388a 3c					inc a 
388b 32 e1 f9				ld (f_cursor_ptr), a   ; save new pos 
388e			 
388e			 
388e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
388e cd a5 1b			call macro_forth_dsp_pop 
3891				endm 
# End of macro FORTH_DSP_POP
3891			  
3891			 
3891					NEXTW 
3891 c3 5f 1c			jp macro_next 
3894				endm 
# End of macro NEXTW
3894			.DOTH: 
3894				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3894 1c				db WORD_SYS_CORE+8             
3895 c4 38			dw .DOTF            
3897 03				db 2 + 1 
3898 .. 00			db ".-",0              
389b				endm 
# End of macro CWHEAD
389b			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
389b					; get value off TOS and display it 
389b					if DEBUG_FORTH_WORDS_KEY 
389b						DMARK "DTD" 
389b f5				push af  
389c 3a b0 38			ld a, (.dmark)  
389f 32 bd fb			ld (debug_mark),a  
38a2 3a b1 38			ld a, (.dmark+1)  
38a5 32 be fb			ld (debug_mark+1),a  
38a8 3a b2 38			ld a, (.dmark+2)  
38ab 32 bf fb			ld (debug_mark+2),a  
38ae 18 03			jr .pastdmark  
38b0 ..			.dmark: db "DTD"  
38b3 f1			.pastdmark: pop af  
38b4			endm  
# End of macro DMARK
38b4						CALLMONITOR 
38b4 cd d4 14			call break_point_state  
38b7				endm  
# End of macro CALLMONITOR
38b7					endif 
38b7 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
38b9 3e 00			ld a, 0 
38bb 32 c0 f9			ld (cli_mvdot), a 
38be c3 1b 39			jp .dotgo 
38c1				NEXTW 
38c1 c3 5f 1c			jp macro_next 
38c4				endm 
# End of macro NEXTW
38c4			.DOTF: 
38c4				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
38c4 1c				db WORD_SYS_CORE+8             
38c5 f2 38			dw .DOT            
38c7 03				db 2 + 1 
38c8 .. 00			db ".>",0              
38cb				endm 
# End of macro CWHEAD
38cb			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
38cb					; get value off TOS and display it 
38cb			        ; TODO BUG adds extra spaces 
38cb			        ; TODO BUG handle numerics? 
38cb					if DEBUG_FORTH_WORDS_KEY 
38cb						DMARK "DTC" 
38cb f5				push af  
38cc 3a e0 38			ld a, (.dmark)  
38cf 32 bd fb			ld (debug_mark),a  
38d2 3a e1 38			ld a, (.dmark+1)  
38d5 32 be fb			ld (debug_mark+1),a  
38d8 3a e2 38			ld a, (.dmark+2)  
38db 32 bf fb			ld (debug_mark+2),a  
38de 18 03			jr .pastdmark  
38e0 ..			.dmark: db "DTC"  
38e3 f1			.pastdmark: pop af  
38e4			endm  
# End of macro DMARK
38e4						CALLMONITOR 
38e4 cd d4 14			call break_point_state  
38e7				endm  
# End of macro CALLMONITOR
38e7					endif 
38e7 3e 01			ld a, 1 
38e9 32 c0 f9			ld (cli_mvdot), a 
38ec c3 1b 39			jp .dotgo 
38ef				NEXTW 
38ef c3 5f 1c			jp macro_next 
38f2				endm 
# End of macro NEXTW
38f2			 
38f2			.DOT: 
38f2				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
38f2 1c				db WORD_SYS_CORE+8             
38f3 7e 39			dw .CLS            
38f5 02				db 1 + 1 
38f6 .. 00			db ".",0              
38f8				endm 
# End of macro CWHEAD
38f8			        ; | . ( u -- ) Display TOS | DONE 
38f8					; get value off TOS and display it 
38f8			 
38f8					if DEBUG_FORTH_WORDS_KEY 
38f8						DMARK "DOT" 
38f8 f5				push af  
38f9 3a 0d 39			ld a, (.dmark)  
38fc 32 bd fb			ld (debug_mark),a  
38ff 3a 0e 39			ld a, (.dmark+1)  
3902 32 be fb			ld (debug_mark+1),a  
3905 3a 0f 39			ld a, (.dmark+2)  
3908 32 bf fb			ld (debug_mark+2),a  
390b 18 03			jr .pastdmark  
390d ..			.dmark: db "DOT"  
3910 f1			.pastdmark: pop af  
3911			endm  
# End of macro DMARK
3911						CALLMONITOR 
3911 cd d4 14			call break_point_state  
3914				endm  
# End of macro CALLMONITOR
3914					endif 
3914 3e 00			ld a, 0 
3916 32 c0 f9			ld (cli_mvdot), a 
3919 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
391b				 
391b			 
391b			.dotgo: 
391b			 
391b			; move up type to on stack for parserv5 
391b					FORTH_DSP 
391b cd ee 1a			call macro_forth_dsp 
391e				endm 
# End of macro FORTH_DSP
391e				;FORTH_DSP_VALUE  
391e			 
391e			if DEBUG_FORTH_DOT 
391e				DMARK "DOT" 
391e				CALLMONITOR 
391e			endif	 
391e			;		.print: 
391e			 
391e 7e				ld a,(hl)  ; work out what type of value is on the TOS 
391f 23				inc hl   ; position to the actual value 
3920 fe 01			cp DS_TYPE_STR 
3922 20 06			jr nz, .dotnum1  
3924			 
3924			; display string 
3924				FORTH_DSP_VALUE  
3924 cd f2 1a			call macro_forth_dsp_value 
3927				endm 
# End of macro FORTH_DSP_VALUE
3927 eb				ex de,hl 
3928 18 11			jr .dotwrite 
392a			 
392a			.dotnum1: 
392a fe 02			cp DS_TYPE_INUM 
392c 20 0c			jr nz, .dotflot 
392e			 
392e			 
392e			; display number 
392e			 
392e			;	push hl 
392e			;	call clear_display 
392e			;	pop hl 
392e			 
392e 5e				ld e, (hl) 
392f 23				inc hl 
3930 56				ld d, (hl) 
3931 21 b8 ef			ld hl, scratch 
3934			if DEBUG_FORTH_DOT 
3934				DMARK "DT1" 
3934				CALLMONITOR 
3934			endif	 
3934			 
3934 cd c9 10			call uitoa_16 
3937 eb				ex de,hl 
3938			 
3938			if DEBUG_FORTH_DOT 
3938				DMARK "DT2" 
3938				CALLMONITOR 
3938			endif	 
3938			 
3938			;	ld de, os_word_scratch 
3938 18 01			jr .dotwrite 
393a			 
393a 00			.dotflot:   nop 
393b			; TODO print floating point number 
393b			 
393b			.dotwrite:		 
393b			 
393b					; if c is set then set all '-' to spaces 
393b					; need to also take into account .>  
393b			 
393b 3e 01				ld a, 1 
393d b9					cp c 
393e 20 13				jr nz, .nodashswap 
3940			 
3940					; DE has the string to write, working with HL 
3940			 
3940 06 ff				ld b, 255 
3942 d5					push de 
3943 e1					pop hl 
3944			 
3944			if DEBUG_FORTH_DOT 
3944				DMARK "DT-" 
3944				CALLMONITOR 
3944			endif	 
3944 7e			.dashscan:	ld a, (hl) 
3945 fe 00				cp 0 
3947 28 0a				jr z, .nodashswap 
3949 fe 2d				cp '-' 
394b 20 03				jr nz, .dashskip 
394d 3e 20				ld a, ' ' 
394f 77					ld (hl), a 
3950 23			.dashskip:	inc hl 
3951			if DEBUG_FORTH_DOT 
3951				DMARK "D-2" 
3951				CALLMONITOR 
3951			endif	 
3951 10 f1				djnz .dashscan 
3953			 
3953			if DEBUG_FORTH_DOT 
3953				DMARK "D-1" 
3953				CALLMONITOR 
3953			endif	 
3953			 
3953			.nodashswap: 
3953			 
3953 e5					push hl   ; save string start in case we need to advance print 
3954			 
3954 3a e1 f9				ld a, (f_cursor_ptr) 
3957 cd 9f 0a				call str_at_display 
395a 3a bf f9				ld a,(cli_autodisplay) 
395d fe 00				cp 0 
395f 28 03				jr z, .noupdate 
3961 cd af 0a						call update_display 
3964					.noupdate: 
3964			 
3964			 
3964					; see if we need to advance the print position 
3964			 
3964 e1					pop hl   ; get back string 
3965			 
3965 3a c0 f9				ld a, (cli_mvdot) 
3968			if DEBUG_FORTH_DOT 
3968					ld e,a 
3968				DMARK "D>1" 
3968				CALLMONITOR 
3968			endif	 
3968 fe 00				cp 0 
396a 28 0c				jr z, .noadv 
396c					; yes, lets advance the print position 
396c 3e 00				ld a, 0 
396e cd 25 11				call strlent 
3971 3a e1 f9				ld a, (f_cursor_ptr) 
3974 85					add a,l 
3975					;call addatohl 
3975					;ld a, l 
3975 32 e1 f9				ld (f_cursor_ptr), a   ; save new pos 
3978			 
3978			if DEBUG_FORTH_DOT 
3978				DMARK "D->" 
3978				CALLMONITOR 
3978			endif	 
3978			 
3978			.noadv:	 
3978			 
3978					if DEBUG_FORTH_DOT_WAIT 
3978							call next_page_prompt 
3978					endif	 
3978			; TODO this pop off the stack causes a crash. i dont know why 
3978			 
3978			 
3978			if DEBUG_FORTH_DOT 
3978				DMARK "DTh" 
3978				CALLMONITOR 
3978			endif	 
3978			 
3978					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3978 cd a5 1b			call macro_forth_dsp_pop 
397b				endm 
# End of macro FORTH_DSP_POP
397b			 
397b			if DEBUG_FORTH_DOT 
397b				DMARK "DTi" 
397b				CALLMONITOR 
397b			endif	 
397b			 
397b			 
397b					NEXTW 
397b c3 5f 1c			jp macro_next 
397e				endm 
# End of macro NEXTW
397e			 
397e			.CLS: 
397e				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
397e 35				db WORD_SYS_CORE+33             
397f ab 39			dw .DRAW            
3981 04				db 3 + 1 
3982 .. 00			db "CLS",0              
3986				endm 
# End of macro CWHEAD
3986			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3986					if DEBUG_FORTH_WORDS_KEY 
3986						DMARK "CLS" 
3986 f5				push af  
3987 3a 9b 39			ld a, (.dmark)  
398a 32 bd fb			ld (debug_mark),a  
398d 3a 9c 39			ld a, (.dmark+1)  
3990 32 be fb			ld (debug_mark+1),a  
3993 3a 9d 39			ld a, (.dmark+2)  
3996 32 bf fb			ld (debug_mark+2),a  
3999 18 03			jr .pastdmark  
399b ..			.dmark: db "CLS"  
399e f1			.pastdmark: pop af  
399f			endm  
# End of macro DMARK
399f						CALLMONITOR 
399f cd d4 14			call break_point_state  
39a2				endm  
# End of macro CALLMONITOR
39a2					endif 
39a2 cd 8c 0a				call clear_display 
39a5 c3 b9 3a				jp .home		; and home cursor 
39a8					NEXTW 
39a8 c3 5f 1c			jp macro_next 
39ab				endm 
# End of macro NEXTW
39ab			 
39ab			.DRAW: 
39ab				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
39ab 36				db WORD_SYS_CORE+34             
39ac d6 39			dw .DUMP            
39ae 05				db 4 + 1 
39af .. 00			db "DRAW",0              
39b4				endm 
# End of macro CWHEAD
39b4			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
39b4					if DEBUG_FORTH_WORDS_KEY 
39b4						DMARK "DRW" 
39b4 f5				push af  
39b5 3a c9 39			ld a, (.dmark)  
39b8 32 bd fb			ld (debug_mark),a  
39bb 3a ca 39			ld a, (.dmark+1)  
39be 32 be fb			ld (debug_mark+1),a  
39c1 3a cb 39			ld a, (.dmark+2)  
39c4 32 bf fb			ld (debug_mark+2),a  
39c7 18 03			jr .pastdmark  
39c9 ..			.dmark: db "DRW"  
39cc f1			.pastdmark: pop af  
39cd			endm  
# End of macro DMARK
39cd						CALLMONITOR 
39cd cd d4 14			call break_point_state  
39d0				endm  
# End of macro CALLMONITOR
39d0					endif 
39d0 cd af 0a				call update_display 
39d3					NEXTW 
39d3 c3 5f 1c			jp macro_next 
39d6				endm 
# End of macro NEXTW
39d6			 
39d6			.DUMP: 
39d6				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
39d6 37				db WORD_SYS_CORE+35             
39d7 0e 3a			dw .CDUMP            
39d9 05				db 4 + 1 
39da .. 00			db "DUMP",0              
39df				endm 
# End of macro CWHEAD
39df			; | DUMP ( x -- ) With address x display dump   | DONE 
39df			; TODO pop address to use off of the stack 
39df					if DEBUG_FORTH_WORDS_KEY 
39df						DMARK "DUM" 
39df f5				push af  
39e0 3a f4 39			ld a, (.dmark)  
39e3 32 bd fb			ld (debug_mark),a  
39e6 3a f5 39			ld a, (.dmark+1)  
39e9 32 be fb			ld (debug_mark+1),a  
39ec 3a f6 39			ld a, (.dmark+2)  
39ef 32 bf fb			ld (debug_mark+2),a  
39f2 18 03			jr .pastdmark  
39f4 ..			.dmark: db "DUM"  
39f7 f1			.pastdmark: pop af  
39f8			endm  
# End of macro DMARK
39f8						CALLMONITOR 
39f8 cd d4 14			call break_point_state  
39fb				endm  
# End of macro CALLMONITOR
39fb					endif 
39fb cd 8c 0a				call clear_display 
39fe			 
39fe					; get address 
39fe			 
39fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39fe cd 09 1b			call macro_dsp_valuehl 
3a01				endm 
# End of macro FORTH_DSP_VALUEHL
3a01				 
3a01					; save it for cdump 
3a01			 
3a01 22 db f2				ld (os_cur_ptr),hl 
3a04			 
3a04					; destroy value TOS 
3a04			 
3a04					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a04 cd a5 1b			call macro_forth_dsp_pop 
3a07				endm 
# End of macro FORTH_DSP_POP
3a07			 
3a07 cd ee 18				call dumpcont	; skip old style of param parsing	 
3a0a c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3a0b					NEXTW 
3a0b c3 5f 1c			jp macro_next 
3a0e				endm 
# End of macro NEXTW
3a0e			.CDUMP: 
3a0e				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3a0e 38				db WORD_SYS_CORE+36             
3a0f 3e 3a			dw .DAT            
3a11 06				db 5 + 1 
3a12 .. 00			db "CDUMP",0              
3a18				endm 
# End of macro CWHEAD
3a18			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3a18					if DEBUG_FORTH_WORDS_KEY 
3a18						DMARK "CDP" 
3a18 f5				push af  
3a19 3a 2d 3a			ld a, (.dmark)  
3a1c 32 bd fb			ld (debug_mark),a  
3a1f 3a 2e 3a			ld a, (.dmark+1)  
3a22 32 be fb			ld (debug_mark+1),a  
3a25 3a 2f 3a			ld a, (.dmark+2)  
3a28 32 bf fb			ld (debug_mark+2),a  
3a2b 18 03			jr .pastdmark  
3a2d ..			.dmark: db "CDP"  
3a30 f1			.pastdmark: pop af  
3a31			endm  
# End of macro DMARK
3a31						CALLMONITOR 
3a31 cd d4 14			call break_point_state  
3a34				endm  
# End of macro CALLMONITOR
3a34					endif 
3a34 cd 8c 0a				call clear_display 
3a37 cd ee 18				call dumpcont	 
3a3a c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3a3b					NEXTW 
3a3b c3 5f 1c			jp macro_next 
3a3e				endm 
# End of macro NEXTW
3a3e			 
3a3e			 
3a3e			 
3a3e			 
3a3e			.DAT: 
3a3e				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3a3e 3d				db WORD_SYS_CORE+41             
3a3f 94 3a			dw .HOME            
3a41 03				db 2 + 1 
3a42 .. 00			db "AT",0              
3a45				endm 
# End of macro CWHEAD
3a45			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3a45					if DEBUG_FORTH_WORDS_KEY 
3a45						DMARK "AT." 
3a45 f5				push af  
3a46 3a 5a 3a			ld a, (.dmark)  
3a49 32 bd fb			ld (debug_mark),a  
3a4c 3a 5b 3a			ld a, (.dmark+1)  
3a4f 32 be fb			ld (debug_mark+1),a  
3a52 3a 5c 3a			ld a, (.dmark+2)  
3a55 32 bf fb			ld (debug_mark+2),a  
3a58 18 03			jr .pastdmark  
3a5a ..			.dmark: db "AT."  
3a5d f1			.pastdmark: pop af  
3a5e			endm  
# End of macro DMARK
3a5e						CALLMONITOR 
3a5e cd d4 14			call break_point_state  
3a61				endm  
# End of macro CALLMONITOR
3a61					endif 
3a61					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a61 cd 09 1b			call macro_dsp_valuehl 
3a64				endm 
# End of macro FORTH_DSP_VALUEHL
3a64			 
3a64			 
3a64					; TODO save cursor row 
3a64 7d					ld a,l 
3a65 fe 02				cp 2 
3a67 20 04				jr nz, .crow3 
3a69 3e 14				ld a, display_row_2 
3a6b 18 12				jr .ccol1 
3a6d fe 03		.crow3:		cp 3 
3a6f 20 04				jr nz, .crow4 
3a71 3e 28				ld a, display_row_3 
3a73 18 0a				jr .ccol1 
3a75 fe 04		.crow4:		cp 4 
3a77 20 04				jr nz, .crow1 
3a79 3e 3c				ld a, display_row_4 
3a7b 18 02				jr .ccol1 
3a7d 3e 00		.crow1:		ld a,display_row_1 
3a7f f5			.ccol1:		push af			; got row offset 
3a80 6f					ld l,a 
3a81 26 00				ld h,0 
3a83					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a83 cd a5 1b			call macro_forth_dsp_pop 
3a86				endm 
# End of macro FORTH_DSP_POP
3a86					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a86 cd 09 1b			call macro_dsp_valuehl 
3a89				endm 
# End of macro FORTH_DSP_VALUEHL
3a89					; TODO save cursor col 
3a89 f1					pop af 
3a8a 85					add l		; add col offset 
3a8b 32 e1 f9				ld (f_cursor_ptr), a 
3a8e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a8e cd a5 1b			call macro_forth_dsp_pop 
3a91				endm 
# End of macro FORTH_DSP_POP
3a91			 
3a91					; calculate  
3a91			 
3a91					NEXTW 
3a91 c3 5f 1c			jp macro_next 
3a94				endm 
# End of macro NEXTW
3a94			 
3a94			 
3a94			.HOME: 
3a94				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3a94 41				db WORD_SYS_CORE+45             
3a95 c1 3a			dw .SPACE            
3a97 05				db 4 + 1 
3a98 .. 00			db "HOME",0              
3a9d				endm 
# End of macro CWHEAD
3a9d			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3a9d					if DEBUG_FORTH_WORDS_KEY 
3a9d						DMARK "HOM" 
3a9d f5				push af  
3a9e 3a b2 3a			ld a, (.dmark)  
3aa1 32 bd fb			ld (debug_mark),a  
3aa4 3a b3 3a			ld a, (.dmark+1)  
3aa7 32 be fb			ld (debug_mark+1),a  
3aaa 3a b4 3a			ld a, (.dmark+2)  
3aad 32 bf fb			ld (debug_mark+2),a  
3ab0 18 03			jr .pastdmark  
3ab2 ..			.dmark: db "HOM"  
3ab5 f1			.pastdmark: pop af  
3ab6			endm  
# End of macro DMARK
3ab6						CALLMONITOR 
3ab6 cd d4 14			call break_point_state  
3ab9				endm  
# End of macro CALLMONITOR
3ab9					endif 
3ab9 3e 00		.home:		ld a, 0		; and home cursor 
3abb 32 e1 f9				ld (f_cursor_ptr), a 
3abe					NEXTW 
3abe c3 5f 1c			jp macro_next 
3ac1				endm 
# End of macro NEXTW
3ac1			 
3ac1			 
3ac1			.SPACE: 
3ac1				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3ac1 46				db WORD_SYS_CORE+50             
3ac2 ef 3a			dw .SPACES            
3ac4 03				db 2 + 1 
3ac5 .. 00			db "BL",0              
3ac8				endm 
# End of macro CWHEAD
3ac8			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3ac8					if DEBUG_FORTH_WORDS_KEY 
3ac8						DMARK "BL." 
3ac8 f5				push af  
3ac9 3a dd 3a			ld a, (.dmark)  
3acc 32 bd fb			ld (debug_mark),a  
3acf 3a de 3a			ld a, (.dmark+1)  
3ad2 32 be fb			ld (debug_mark+1),a  
3ad5 3a df 3a			ld a, (.dmark+2)  
3ad8 32 bf fb			ld (debug_mark+2),a  
3adb 18 03			jr .pastdmark  
3add ..			.dmark: db "BL."  
3ae0 f1			.pastdmark: pop af  
3ae1			endm  
# End of macro DMARK
3ae1						CALLMONITOR 
3ae1 cd d4 14			call break_point_state  
3ae4				endm  
# End of macro CALLMONITOR
3ae4					endif 
3ae4 21 ed 3a				ld hl, .blstr 
3ae7 cd 80 1a				call forth_push_str 
3aea					 
3aea				       NEXTW 
3aea c3 5f 1c			jp macro_next 
3aed				endm 
# End of macro NEXTW
3aed			 
3aed .. 00		.blstr: db " ", 0 
3aef			 
3aef			.SPACES: 
3aef				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3aef 47				db WORD_SYS_CORE+51             
3af0 8a 3b			dw .SCROLL            
3af2 07				db 6 + 1 
3af3 .. 00			db "SPACES",0              
3afa				endm 
# End of macro CWHEAD
3afa			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3afa					if DEBUG_FORTH_WORDS_KEY 
3afa						DMARK "SPS" 
3afa f5				push af  
3afb 3a 0f 3b			ld a, (.dmark)  
3afe 32 bd fb			ld (debug_mark),a  
3b01 3a 10 3b			ld a, (.dmark+1)  
3b04 32 be fb			ld (debug_mark+1),a  
3b07 3a 11 3b			ld a, (.dmark+2)  
3b0a 32 bf fb			ld (debug_mark+2),a  
3b0d 18 03			jr .pastdmark  
3b0f ..			.dmark: db "SPS"  
3b12 f1			.pastdmark: pop af  
3b13			endm  
# End of macro DMARK
3b13						CALLMONITOR 
3b13 cd d4 14			call break_point_state  
3b16				endm  
# End of macro CALLMONITOR
3b16					endif 
3b16			 
3b16			 
3b16					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b16 cd 09 1b			call macro_dsp_valuehl 
3b19				endm 
# End of macro FORTH_DSP_VALUEHL
3b19			 
3b19			;		push hl    ; u 
3b19					if DEBUG_FORTH_WORDS 
3b19						DMARK "SPA" 
3b19 f5				push af  
3b1a 3a 2e 3b			ld a, (.dmark)  
3b1d 32 bd fb			ld (debug_mark),a  
3b20 3a 2f 3b			ld a, (.dmark+1)  
3b23 32 be fb			ld (debug_mark+1),a  
3b26 3a 30 3b			ld a, (.dmark+2)  
3b29 32 bf fb			ld (debug_mark+2),a  
3b2c 18 03			jr .pastdmark  
3b2e ..			.dmark: db "SPA"  
3b31 f1			.pastdmark: pop af  
3b32			endm  
# End of macro DMARK
3b32						CALLMONITOR 
3b32 cd d4 14			call break_point_state  
3b35				endm  
# End of macro CALLMONITOR
3b35					endif 
3b35			 
3b35					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b35 cd a5 1b			call macro_forth_dsp_pop 
3b38				endm 
# End of macro FORTH_DSP_POP
3b38			;		pop hl 
3b38 4d					ld c, l 
3b39 06 00				ld b, 0 
3b3b 21 b8 ef				ld hl, scratch  
3b3e			 
3b3e					if DEBUG_FORTH_WORDS 
3b3e						DMARK "SP2" 
3b3e f5				push af  
3b3f 3a 53 3b			ld a, (.dmark)  
3b42 32 bd fb			ld (debug_mark),a  
3b45 3a 54 3b			ld a, (.dmark+1)  
3b48 32 be fb			ld (debug_mark+1),a  
3b4b 3a 55 3b			ld a, (.dmark+2)  
3b4e 32 bf fb			ld (debug_mark+2),a  
3b51 18 03			jr .pastdmark  
3b53 ..			.dmark: db "SP2"  
3b56 f1			.pastdmark: pop af  
3b57			endm  
# End of macro DMARK
3b57						CALLMONITOR 
3b57 cd d4 14			call break_point_state  
3b5a				endm  
# End of macro CALLMONITOR
3b5a					endif 
3b5a 3e 20				ld a, ' ' 
3b5c c5			.spaces1:	push bc 
3b5d 77					ld (hl),a 
3b5e 23					inc hl 
3b5f c1					pop bc 
3b60 10 fa				djnz .spaces1 
3b62 3e 00				ld a,0 
3b64 77					ld (hl),a 
3b65 21 b8 ef				ld hl, scratch 
3b68					if DEBUG_FORTH_WORDS 
3b68						DMARK "SP3" 
3b68 f5				push af  
3b69 3a 7d 3b			ld a, (.dmark)  
3b6c 32 bd fb			ld (debug_mark),a  
3b6f 3a 7e 3b			ld a, (.dmark+1)  
3b72 32 be fb			ld (debug_mark+1),a  
3b75 3a 7f 3b			ld a, (.dmark+2)  
3b78 32 bf fb			ld (debug_mark+2),a  
3b7b 18 03			jr .pastdmark  
3b7d ..			.dmark: db "SP3"  
3b80 f1			.pastdmark: pop af  
3b81			endm  
# End of macro DMARK
3b81						CALLMONITOR 
3b81 cd d4 14			call break_point_state  
3b84				endm  
# End of macro CALLMONITOR
3b84					endif 
3b84 cd b6 1a				call forth_apush 
3b87			 
3b87				       NEXTW 
3b87 c3 5f 1c			jp macro_next 
3b8a				endm 
# End of macro NEXTW
3b8a			 
3b8a			 
3b8a			 
3b8a			.SCROLL: 
3b8a				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3b8a 53				db WORD_SYS_CORE+63             
3b8b b7 3b			dw .SCROLLD            
3b8d 07				db 6 + 1 
3b8e .. 00			db "SCROLL",0              
3b95				endm 
# End of macro CWHEAD
3b95			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3b95					if DEBUG_FORTH_WORDS_KEY 
3b95						DMARK "SCR" 
3b95 f5				push af  
3b96 3a aa 3b			ld a, (.dmark)  
3b99 32 bd fb			ld (debug_mark),a  
3b9c 3a ab 3b			ld a, (.dmark+1)  
3b9f 32 be fb			ld (debug_mark+1),a  
3ba2 3a ac 3b			ld a, (.dmark+2)  
3ba5 32 bf fb			ld (debug_mark+2),a  
3ba8 18 03			jr .pastdmark  
3baa ..			.dmark: db "SCR"  
3bad f1			.pastdmark: pop af  
3bae			endm  
# End of macro DMARK
3bae						CALLMONITOR 
3bae cd d4 14			call break_point_state  
3bb1				endm  
# End of macro CALLMONITOR
3bb1					endif 
3bb1			 
3bb1 cd 4e 0a			call scroll_up 
3bb4			;	call update_display 
3bb4			 
3bb4					NEXTW 
3bb4 c3 5f 1c			jp macro_next 
3bb7				endm 
# End of macro NEXTW
3bb7			 
3bb7			 
3bb7			 
3bb7			;		; get dir 
3bb7			; 
3bb7			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bb7			; 
3bb7			;		push hl 
3bb7			; 
3bb7			;		; destroy value TOS 
3bb7			; 
3bb7			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bb7			; 
3bb7			;		; get count 
3bb7			; 
3bb7			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bb7			; 
3bb7			;		push hl 
3bb7			; 
3bb7			;		; destroy value TOS 
3bb7			; 
3bb7			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bb7			; 
3bb7			;		; one value on hl get other one back 
3bb7			; 
3bb7			;		pop bc    ; count 
3bb7			; 
3bb7			;		pop de   ; dir 
3bb7			; 
3bb7			; 
3bb7			;		ld b, c 
3bb7			; 
3bb7			;.scrolldir:     push bc 
3bb7			;		push de 
3bb7			; 
3bb7			;		ld a, 0 
3bb7			;		cp e 
3bb7			;		jr z, .scrollup  
3bb7			;		call scroll_down 
3bb7			;		jr .scrollnext 
3bb7			;.scrollup:	call scroll_up 
3bb7			; 
3bb7			;		 
3bb7			;.scrollnext: 
3bb7			;		pop de 
3bb7			;		pop bc 
3bb7			;		djnz .scrolldir 
3bb7			; 
3bb7			; 
3bb7			; 
3bb7			; 
3bb7			; 
3bb7			;		NEXTW 
3bb7			 
3bb7			.SCROLLD: 
3bb7				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3bb7 53				db WORD_SYS_CORE+63             
3bb8 e5 3b			dw .ATQ            
3bba 08				db 7 + 1 
3bbb .. 00			db "SCROLLD",0              
3bc3				endm 
# End of macro CWHEAD
3bc3			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3bc3					if DEBUG_FORTH_WORDS_KEY 
3bc3						DMARK "SCD" 
3bc3 f5				push af  
3bc4 3a d8 3b			ld a, (.dmark)  
3bc7 32 bd fb			ld (debug_mark),a  
3bca 3a d9 3b			ld a, (.dmark+1)  
3bcd 32 be fb			ld (debug_mark+1),a  
3bd0 3a da 3b			ld a, (.dmark+2)  
3bd3 32 bf fb			ld (debug_mark+2),a  
3bd6 18 03			jr .pastdmark  
3bd8 ..			.dmark: db "SCD"  
3bdb f1			.pastdmark: pop af  
3bdc			endm  
# End of macro DMARK
3bdc						CALLMONITOR 
3bdc cd d4 14			call break_point_state  
3bdf				endm  
# End of macro CALLMONITOR
3bdf					endif 
3bdf			 
3bdf cd 72 0a			call scroll_down 
3be2			;	call update_display 
3be2			 
3be2					NEXTW 
3be2 c3 5f 1c			jp macro_next 
3be5				endm 
# End of macro NEXTW
3be5			 
3be5			 
3be5			.ATQ: 
3be5				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3be5 62				db WORD_SYS_CORE+78             
3be6 43 3c			dw .AUTODSP            
3be8 04				db 3 + 1 
3be9 .. 00			db "AT@",0              
3bed				endm 
# End of macro CWHEAD
3bed			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3bed					if DEBUG_FORTH_WORDS_KEY 
3bed						DMARK "ATA" 
3bed f5				push af  
3bee 3a 02 3c			ld a, (.dmark)  
3bf1 32 bd fb			ld (debug_mark),a  
3bf4 3a 03 3c			ld a, (.dmark+1)  
3bf7 32 be fb			ld (debug_mark+1),a  
3bfa 3a 04 3c			ld a, (.dmark+2)  
3bfd 32 bf fb			ld (debug_mark+2),a  
3c00 18 03			jr .pastdmark  
3c02 ..			.dmark: db "ATA"  
3c05 f1			.pastdmark: pop af  
3c06			endm  
# End of macro DMARK
3c06						CALLMONITOR 
3c06 cd d4 14			call break_point_state  
3c09				endm  
# End of macro CALLMONITOR
3c09					endif 
3c09			 
3c09			 
3c09					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c09 cd 09 1b			call macro_dsp_valuehl 
3c0c				endm 
# End of macro FORTH_DSP_VALUEHL
3c0c			 
3c0c					; TODO save cursor row 
3c0c 7d					ld a,l 
3c0d fe 02				cp 2 
3c0f 20 04				jr nz, .crow3aq 
3c11 3e 14				ld a, display_row_2 
3c13 18 12				jr .ccol1aq 
3c15 fe 03		.crow3aq:		cp 3 
3c17 20 04				jr nz, .crow4aq 
3c19 3e 28				ld a, display_row_3 
3c1b 18 0a				jr .ccol1aq 
3c1d fe 04		.crow4aq:		cp 4 
3c1f 20 04				jr nz, .crow1aq 
3c21 3e 3c				ld a, display_row_4 
3c23 18 02				jr .ccol1aq 
3c25 3e 00		.crow1aq:		ld a,display_row_1 
3c27 f5			.ccol1aq:		push af			; got row offset 
3c28 6f					ld l,a 
3c29 26 00				ld h,0 
3c2b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c2b cd a5 1b			call macro_forth_dsp_pop 
3c2e				endm 
# End of macro FORTH_DSP_POP
3c2e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c2e cd 09 1b			call macro_dsp_valuehl 
3c31				endm 
# End of macro FORTH_DSP_VALUEHL
3c31					; TODO save cursor col 
3c31 f1					pop af 
3c32 85					add l		; add col offset 
3c33			 
3c33					; add current frame buffer address 
3c33 2a 5e fa				ld hl, (display_fb_active) 
3c36 cd bc 0c				call addatohl 
3c39			 
3c39			 
3c39			 
3c39			 
3c39					; get char frame buffer location offset in hl 
3c39			 
3c39 7e					ld a,(hl) 
3c3a 26 00				ld h, 0 
3c3c 6f					ld l, a 
3c3d			 
3c3d cd 6e 1a				call forth_push_numhl 
3c40			 
3c40			 
3c40					NEXTW 
3c40 c3 5f 1c			jp macro_next 
3c43				endm 
# End of macro NEXTW
3c43			 
3c43			.AUTODSP: 
3c43				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3c43 63				db WORD_SYS_CORE+79             
3c44 59 3c			dw .MENU            
3c46 05				db 4 + 1 
3c47 .. 00			db "ADSP",0              
3c4c				endm 
# End of macro CWHEAD
3c4c			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3c4c			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3c4c			 
3c4c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c4c cd 09 1b			call macro_dsp_valuehl 
3c4f				endm 
# End of macro FORTH_DSP_VALUEHL
3c4f			 
3c4f			;		push hl 
3c4f			 
3c4f					; destroy value TOS 
3c4f			 
3c4f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c4f cd a5 1b			call macro_forth_dsp_pop 
3c52				endm 
# End of macro FORTH_DSP_POP
3c52			 
3c52			;		pop hl 
3c52			 
3c52 7d					ld a,l 
3c53 32 bf f9				ld (cli_autodisplay), a 
3c56				       NEXTW 
3c56 c3 5f 1c			jp macro_next 
3c59				endm 
# End of macro NEXTW
3c59			 
3c59			.MENU: 
3c59				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3c59 70				db WORD_SYS_CORE+92             
3c5a 02 3d			dw .ENDDISPLAY            
3c5c 05				db 4 + 1 
3c5d .. 00			db "MENU",0              
3c62				endm 
# End of macro CWHEAD
3c62			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3c62			 
3c62			;		; get number of items on the stack 
3c62			; 
3c62				 
3c62					FORTH_DSP_VALUEHL 
3c62 cd 09 1b			call macro_dsp_valuehl 
3c65				endm 
# End of macro FORTH_DSP_VALUEHL
3c65				 
3c65					if DEBUG_FORTH_WORDS_KEY 
3c65						DMARK "MNU" 
3c65 f5				push af  
3c66 3a 7a 3c			ld a, (.dmark)  
3c69 32 bd fb			ld (debug_mark),a  
3c6c 3a 7b 3c			ld a, (.dmark+1)  
3c6f 32 be fb			ld (debug_mark+1),a  
3c72 3a 7c 3c			ld a, (.dmark+2)  
3c75 32 bf fb			ld (debug_mark+2),a  
3c78 18 03			jr .pastdmark  
3c7a ..			.dmark: db "MNU"  
3c7d f1			.pastdmark: pop af  
3c7e			endm  
# End of macro DMARK
3c7e						CALLMONITOR 
3c7e cd d4 14			call break_point_state  
3c81				endm  
# End of macro CALLMONITOR
3c81					endif 
3c81			 
3c81 45					ld b, l	 
3c82 05					dec b 
3c83			 
3c83					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c83 cd a5 1b			call macro_forth_dsp_pop 
3c86				endm 
# End of macro FORTH_DSP_POP
3c86			 
3c86			 
3c86					; go directly through the stack to pluck out the string pointers and build an array 
3c86			 
3c86			;		FORTH_DSP 
3c86			 
3c86					; hl contains top most stack item 
3c86				 
3c86 11 b8 ef				ld de, scratch 
3c89			 
3c89			.mbuild: 
3c89			 
3c89					FORTH_DSP_VALUEHL 
3c89 cd 09 1b			call macro_dsp_valuehl 
3c8c				endm 
# End of macro FORTH_DSP_VALUEHL
3c8c			 
3c8c					if DEBUG_FORTH_WORDS 
3c8c						DMARK "MN3" 
3c8c f5				push af  
3c8d 3a a1 3c			ld a, (.dmark)  
3c90 32 bd fb			ld (debug_mark),a  
3c93 3a a2 3c			ld a, (.dmark+1)  
3c96 32 be fb			ld (debug_mark+1),a  
3c99 3a a3 3c			ld a, (.dmark+2)  
3c9c 32 bf fb			ld (debug_mark+2),a  
3c9f 18 03			jr .pastdmark  
3ca1 ..			.dmark: db "MN3"  
3ca4 f1			.pastdmark: pop af  
3ca5			endm  
# End of macro DMARK
3ca5						CALLMONITOR 
3ca5 cd d4 14			call break_point_state  
3ca8				endm  
# End of macro CALLMONITOR
3ca8					endif 
3ca8 eb					ex de, hl 
3ca9 73					ld (hl), e 
3caa 23					inc hl 
3cab 72					ld (hl), d 
3cac 23					inc hl 
3cad eb					ex de, hl 
3cae			 
3cae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cae cd a5 1b			call macro_forth_dsp_pop 
3cb1				endm 
# End of macro FORTH_DSP_POP
3cb1			 
3cb1 10 d6				djnz .mbuild 
3cb3			 
3cb3					; done add term 
3cb3			 
3cb3 eb					ex de, hl 
3cb4 36 00				ld (hl), 0 
3cb6 23					inc hl 
3cb7 36 00				ld (hl), 0 
3cb9			 
3cb9				 
3cb9					 
3cb9 21 b8 ef				ld hl, scratch 
3cbc			 
3cbc					if DEBUG_FORTH_WORDS 
3cbc						DMARK "MNx" 
3cbc f5				push af  
3cbd 3a d1 3c			ld a, (.dmark)  
3cc0 32 bd fb			ld (debug_mark),a  
3cc3 3a d2 3c			ld a, (.dmark+1)  
3cc6 32 be fb			ld (debug_mark+1),a  
3cc9 3a d3 3c			ld a, (.dmark+2)  
3ccc 32 bf fb			ld (debug_mark+2),a  
3ccf 18 03			jr .pastdmark  
3cd1 ..			.dmark: db "MNx"  
3cd4 f1			.pastdmark: pop af  
3cd5			endm  
# End of macro DMARK
3cd5						CALLMONITOR 
3cd5 cd d4 14			call break_point_state  
3cd8				endm  
# End of macro CALLMONITOR
3cd8					endif 
3cd8			 
3cd8			 
3cd8			 
3cd8 3e 00				ld a, 0 
3cda cd bd 0a				call menu 
3cdd			 
3cdd			 
3cdd 6f					ld l, a 
3cde 26 00				ld h, 0 
3ce0			 
3ce0					if DEBUG_FORTH_WORDS 
3ce0						DMARK "MNr" 
3ce0 f5				push af  
3ce1 3a f5 3c			ld a, (.dmark)  
3ce4 32 bd fb			ld (debug_mark),a  
3ce7 3a f6 3c			ld a, (.dmark+1)  
3cea 32 be fb			ld (debug_mark+1),a  
3ced 3a f7 3c			ld a, (.dmark+2)  
3cf0 32 bf fb			ld (debug_mark+2),a  
3cf3 18 03			jr .pastdmark  
3cf5 ..			.dmark: db "MNr"  
3cf8 f1			.pastdmark: pop af  
3cf9			endm  
# End of macro DMARK
3cf9						CALLMONITOR 
3cf9 cd d4 14			call break_point_state  
3cfc				endm  
# End of macro CALLMONITOR
3cfc					endif 
3cfc			 
3cfc cd 6e 1a				call forth_push_numhl 
3cff			 
3cff			 
3cff			 
3cff			 
3cff				       NEXTW 
3cff c3 5f 1c			jp macro_next 
3d02				endm 
# End of macro NEXTW
3d02			 
3d02			 
3d02			.ENDDISPLAY: 
3d02			 
3d02			; eof 
# End of file forth_words_display.asm
3d02			include "forth_words_str.asm" 
3d02			 
3d02			; | ## String Words 
3d02			 
3d02			.PTR:   
3d02			 
3d02				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3d02 48				db WORD_SYS_CORE+52             
3d03 2f 3d			dw .STYPE            
3d05 04				db 3 + 1 
3d06 .. 00			db "PTR",0              
3d0a				endm 
# End of macro CWHEAD
3d0a			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3d0a			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3d0a			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3d0a			 
3d0a					if DEBUG_FORTH_WORDS_KEY 
3d0a						DMARK "PTR" 
3d0a f5				push af  
3d0b 3a 1f 3d			ld a, (.dmark)  
3d0e 32 bd fb			ld (debug_mark),a  
3d11 3a 20 3d			ld a, (.dmark+1)  
3d14 32 be fb			ld (debug_mark+1),a  
3d17 3a 21 3d			ld a, (.dmark+2)  
3d1a 32 bf fb			ld (debug_mark+2),a  
3d1d 18 03			jr .pastdmark  
3d1f ..			.dmark: db "PTR"  
3d22 f1			.pastdmark: pop af  
3d23			endm  
# End of macro DMARK
3d23						CALLMONITOR 
3d23 cd d4 14			call break_point_state  
3d26				endm  
# End of macro CALLMONITOR
3d26					endif 
3d26					FORTH_DSP_VALUEHL 
3d26 cd 09 1b			call macro_dsp_valuehl 
3d29				endm 
# End of macro FORTH_DSP_VALUEHL
3d29 cd 6e 1a				call forth_push_numhl 
3d2c			 
3d2c			 
3d2c					NEXTW 
3d2c c3 5f 1c			jp macro_next 
3d2f				endm 
# End of macro NEXTW
3d2f			.STYPE: 
3d2f				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3d2f 48				db WORD_SYS_CORE+52             
3d30 7e 3d			dw .UPPER            
3d32 06				db 5 + 1 
3d33 .. 00			db "STYPE",0              
3d39				endm 
# End of macro CWHEAD
3d39			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3d39					if DEBUG_FORTH_WORDS_KEY 
3d39						DMARK "STY" 
3d39 f5				push af  
3d3a 3a 4e 3d			ld a, (.dmark)  
3d3d 32 bd fb			ld (debug_mark),a  
3d40 3a 4f 3d			ld a, (.dmark+1)  
3d43 32 be fb			ld (debug_mark+1),a  
3d46 3a 50 3d			ld a, (.dmark+2)  
3d49 32 bf fb			ld (debug_mark+2),a  
3d4c 18 03			jr .pastdmark  
3d4e ..			.dmark: db "STY"  
3d51 f1			.pastdmark: pop af  
3d52			endm  
# End of macro DMARK
3d52						CALLMONITOR 
3d52 cd d4 14			call break_point_state  
3d55				endm  
# End of macro CALLMONITOR
3d55					endif 
3d55					FORTH_DSP 
3d55 cd ee 1a			call macro_forth_dsp 
3d58				endm 
# End of macro FORTH_DSP
3d58					;v5 FORTH_DSP_VALUE 
3d58			 
3d58 7e					ld a, (hl) 
3d59			 
3d59 f5					push af 
3d5a			 
3d5a			; Dont destroy TOS		FORTH_DSP_POP 
3d5a			 
3d5a f1					pop af 
3d5b			 
3d5b fe 01				cp DS_TYPE_STR 
3d5d 28 09				jr z, .typestr 
3d5f			 
3d5f fe 02				cp DS_TYPE_INUM 
3d61 28 0a				jr z, .typeinum 
3d63			 
3d63 21 7c 3d				ld hl, .tna 
3d66 18 0a				jr .tpush 
3d68			 
3d68 21 78 3d		.typestr:	ld hl, .tstr 
3d6b 18 05				jr .tpush 
3d6d 21 7a 3d		.typeinum:	ld hl, .tinum 
3d70 18 00				jr .tpush 
3d72			 
3d72			.tpush: 
3d72			 
3d72 cd 80 1a				call forth_push_str 
3d75			 
3d75					NEXTW 
3d75 c3 5f 1c			jp macro_next 
3d78				endm 
# End of macro NEXTW
3d78 .. 00		.tstr:	db "s",0 
3d7a .. 00		.tinum:  db "i",0 
3d7c .. 00		.tna:   db "?", 0 
3d7e			 
3d7e			 
3d7e			.UPPER: 
3d7e				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3d7e 48				db WORD_SYS_CORE+52             
3d7f b9 3d			dw .LOWER            
3d81 06				db 5 + 1 
3d82 .. 00			db "UPPER",0              
3d88				endm 
# End of macro CWHEAD
3d88			; | UPPER ( s -- s ) Upper case string s  | DONE 
3d88					if DEBUG_FORTH_WORDS_KEY 
3d88						DMARK "UPR" 
3d88 f5				push af  
3d89 3a 9d 3d			ld a, (.dmark)  
3d8c 32 bd fb			ld (debug_mark),a  
3d8f 3a 9e 3d			ld a, (.dmark+1)  
3d92 32 be fb			ld (debug_mark+1),a  
3d95 3a 9f 3d			ld a, (.dmark+2)  
3d98 32 bf fb			ld (debug_mark+2),a  
3d9b 18 03			jr .pastdmark  
3d9d ..			.dmark: db "UPR"  
3da0 f1			.pastdmark: pop af  
3da1			endm  
# End of macro DMARK
3da1						CALLMONITOR 
3da1 cd d4 14			call break_point_state  
3da4				endm  
# End of macro CALLMONITOR
3da4					endif 
3da4			 
3da4					FORTH_DSP 
3da4 cd ee 1a			call macro_forth_dsp 
3da7				endm 
# End of macro FORTH_DSP
3da7					 
3da7			; TODO check is string type 
3da7			 
3da7					FORTH_DSP_VALUEHL 
3da7 cd 09 1b			call macro_dsp_valuehl 
3daa				endm 
# End of macro FORTH_DSP_VALUEHL
3daa			; get pointer to string in hl 
3daa			 
3daa 7e			.toup:		ld a, (hl) 
3dab fe 00				cp 0 
3dad 28 07				jr z, .toupdone 
3daf			 
3daf cd 29 10				call to_upper 
3db2			 
3db2 77					ld (hl), a 
3db3 23					inc hl 
3db4 18 f4				jr .toup 
3db6			 
3db6					 
3db6			 
3db6			 
3db6			; for each char convert to upper 
3db6					 
3db6			.toupdone: 
3db6			 
3db6			 
3db6					NEXTW 
3db6 c3 5f 1c			jp macro_next 
3db9				endm 
# End of macro NEXTW
3db9			.LOWER: 
3db9				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3db9 48				db WORD_SYS_CORE+52             
3dba f4 3d			dw .TCASE            
3dbc 06				db 5 + 1 
3dbd .. 00			db "LOWER",0              
3dc3				endm 
# End of macro CWHEAD
3dc3			; | LOWER ( s -- s ) Lower case string s  | DONE 
3dc3					if DEBUG_FORTH_WORDS_KEY 
3dc3						DMARK "LWR" 
3dc3 f5				push af  
3dc4 3a d8 3d			ld a, (.dmark)  
3dc7 32 bd fb			ld (debug_mark),a  
3dca 3a d9 3d			ld a, (.dmark+1)  
3dcd 32 be fb			ld (debug_mark+1),a  
3dd0 3a da 3d			ld a, (.dmark+2)  
3dd3 32 bf fb			ld (debug_mark+2),a  
3dd6 18 03			jr .pastdmark  
3dd8 ..			.dmark: db "LWR"  
3ddb f1			.pastdmark: pop af  
3ddc			endm  
# End of macro DMARK
3ddc						CALLMONITOR 
3ddc cd d4 14			call break_point_state  
3ddf				endm  
# End of macro CALLMONITOR
3ddf					endif 
3ddf			 
3ddf					FORTH_DSP 
3ddf cd ee 1a			call macro_forth_dsp 
3de2				endm 
# End of macro FORTH_DSP
3de2					 
3de2			; TODO check is string type 
3de2			 
3de2					FORTH_DSP_VALUEHL 
3de2 cd 09 1b			call macro_dsp_valuehl 
3de5				endm 
# End of macro FORTH_DSP_VALUEHL
3de5			; get pointer to string in hl 
3de5			 
3de5 7e			.tolow:		ld a, (hl) 
3de6 fe 00				cp 0 
3de8 28 07				jr z, .tolowdone 
3dea			 
3dea cd 32 10				call to_lower 
3ded			 
3ded 77					ld (hl), a 
3dee 23					inc hl 
3def 18 f4				jr .tolow 
3df1			 
3df1					 
3df1			 
3df1			 
3df1			; for each char convert to low 
3df1					 
3df1			.tolowdone: 
3df1					NEXTW 
3df1 c3 5f 1c			jp macro_next 
3df4				endm 
# End of macro NEXTW
3df4			.TCASE: 
3df4				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3df4 48				db WORD_SYS_CORE+52             
3df5 2a 3f			dw .SUBSTR            
3df7 06				db 5 + 1 
3df8 .. 00			db "TCASE",0              
3dfe				endm 
# End of macro CWHEAD
3dfe			; | TCASE ( s -- s ) Title case string s  | DONE 
3dfe					if DEBUG_FORTH_WORDS_KEY 
3dfe						DMARK "TCS" 
3dfe f5				push af  
3dff 3a 13 3e			ld a, (.dmark)  
3e02 32 bd fb			ld (debug_mark),a  
3e05 3a 14 3e			ld a, (.dmark+1)  
3e08 32 be fb			ld (debug_mark+1),a  
3e0b 3a 15 3e			ld a, (.dmark+2)  
3e0e 32 bf fb			ld (debug_mark+2),a  
3e11 18 03			jr .pastdmark  
3e13 ..			.dmark: db "TCS"  
3e16 f1			.pastdmark: pop af  
3e17			endm  
# End of macro DMARK
3e17						CALLMONITOR 
3e17 cd d4 14			call break_point_state  
3e1a				endm  
# End of macro CALLMONITOR
3e1a					endif 
3e1a			 
3e1a					FORTH_DSP 
3e1a cd ee 1a			call macro_forth_dsp 
3e1d				endm 
# End of macro FORTH_DSP
3e1d					 
3e1d			; TODO check is string type 
3e1d			 
3e1d					FORTH_DSP_VALUEHL 
3e1d cd 09 1b			call macro_dsp_valuehl 
3e20				endm 
# End of macro FORTH_DSP_VALUEHL
3e20			; get pointer to string in hl 
3e20			 
3e20					if DEBUG_FORTH_WORDS 
3e20						DMARK "TC1" 
3e20 f5				push af  
3e21 3a 35 3e			ld a, (.dmark)  
3e24 32 bd fb			ld (debug_mark),a  
3e27 3a 36 3e			ld a, (.dmark+1)  
3e2a 32 be fb			ld (debug_mark+1),a  
3e2d 3a 37 3e			ld a, (.dmark+2)  
3e30 32 bf fb			ld (debug_mark+2),a  
3e33 18 03			jr .pastdmark  
3e35 ..			.dmark: db "TC1"  
3e38 f1			.pastdmark: pop af  
3e39			endm  
# End of macro DMARK
3e39						CALLMONITOR 
3e39 cd d4 14			call break_point_state  
3e3c				endm  
# End of macro CALLMONITOR
3e3c					endif 
3e3c			 
3e3c					; first time in turn to upper case first char 
3e3c			 
3e3c 7e					ld a, (hl) 
3e3d c3 c7 3e				jp .totsiptou 
3e40			 
3e40			 
3e40 7e			.tot:		ld a, (hl) 
3e41 fe 00				cp 0 
3e43 ca 0b 3f				jp z, .totdone 
3e46			 
3e46					if DEBUG_FORTH_WORDS 
3e46						DMARK "TC2" 
3e46 f5				push af  
3e47 3a 5b 3e			ld a, (.dmark)  
3e4a 32 bd fb			ld (debug_mark),a  
3e4d 3a 5c 3e			ld a, (.dmark+1)  
3e50 32 be fb			ld (debug_mark+1),a  
3e53 3a 5d 3e			ld a, (.dmark+2)  
3e56 32 bf fb			ld (debug_mark+2),a  
3e59 18 03			jr .pastdmark  
3e5b ..			.dmark: db "TC2"  
3e5e f1			.pastdmark: pop af  
3e5f			endm  
# End of macro DMARK
3e5f						CALLMONITOR 
3e5f cd d4 14			call break_point_state  
3e62				endm  
# End of macro CALLMONITOR
3e62					endif 
3e62					; check to see if current char is a space 
3e62			 
3e62 fe 20				cp ' ' 
3e64 28 21				jr z, .totsp 
3e66 cd 32 10				call to_lower 
3e69					if DEBUG_FORTH_WORDS 
3e69						DMARK "TC3" 
3e69 f5				push af  
3e6a 3a 7e 3e			ld a, (.dmark)  
3e6d 32 bd fb			ld (debug_mark),a  
3e70 3a 7f 3e			ld a, (.dmark+1)  
3e73 32 be fb			ld (debug_mark+1),a  
3e76 3a 80 3e			ld a, (.dmark+2)  
3e79 32 bf fb			ld (debug_mark+2),a  
3e7c 18 03			jr .pastdmark  
3e7e ..			.dmark: db "TC3"  
3e81 f1			.pastdmark: pop af  
3e82			endm  
# End of macro DMARK
3e82						CALLMONITOR 
3e82 cd d4 14			call break_point_state  
3e85				endm  
# End of macro CALLMONITOR
3e85					endif 
3e85 18 63				jr .totnxt 
3e87			 
3e87			.totsp:         ; on a space, find next char which should be upper 
3e87			 
3e87					if DEBUG_FORTH_WORDS 
3e87						DMARK "TC4" 
3e87 f5				push af  
3e88 3a 9c 3e			ld a, (.dmark)  
3e8b 32 bd fb			ld (debug_mark),a  
3e8e 3a 9d 3e			ld a, (.dmark+1)  
3e91 32 be fb			ld (debug_mark+1),a  
3e94 3a 9e 3e			ld a, (.dmark+2)  
3e97 32 bf fb			ld (debug_mark+2),a  
3e9a 18 03			jr .pastdmark  
3e9c ..			.dmark: db "TC4"  
3e9f f1			.pastdmark: pop af  
3ea0			endm  
# End of macro DMARK
3ea0						CALLMONITOR 
3ea0 cd d4 14			call break_point_state  
3ea3				endm  
# End of macro CALLMONITOR
3ea3					endif 
3ea3					;; 
3ea3			 
3ea3 fe 20				cp ' ' 
3ea5 20 20				jr nz, .totsiptou 
3ea7 23					inc hl 
3ea8 7e					ld a, (hl) 
3ea9					if DEBUG_FORTH_WORDS 
3ea9						DMARK "TC5" 
3ea9 f5				push af  
3eaa 3a be 3e			ld a, (.dmark)  
3ead 32 bd fb			ld (debug_mark),a  
3eb0 3a bf 3e			ld a, (.dmark+1)  
3eb3 32 be fb			ld (debug_mark+1),a  
3eb6 3a c0 3e			ld a, (.dmark+2)  
3eb9 32 bf fb			ld (debug_mark+2),a  
3ebc 18 03			jr .pastdmark  
3ebe ..			.dmark: db "TC5"  
3ec1 f1			.pastdmark: pop af  
3ec2			endm  
# End of macro DMARK
3ec2						CALLMONITOR 
3ec2 cd d4 14			call break_point_state  
3ec5				endm  
# End of macro CALLMONITOR
3ec5					endif 
3ec5 18 c0				jr .totsp 
3ec7 fe 00		.totsiptou:    cp 0 
3ec9 28 40				jr z, .totdone 
3ecb					; not space and not zero term so upper case it 
3ecb cd 29 10				call to_upper 
3ece			 
3ece					if DEBUG_FORTH_WORDS 
3ece						DMARK "TC6" 
3ece f5				push af  
3ecf 3a e3 3e			ld a, (.dmark)  
3ed2 32 bd fb			ld (debug_mark),a  
3ed5 3a e4 3e			ld a, (.dmark+1)  
3ed8 32 be fb			ld (debug_mark+1),a  
3edb 3a e5 3e			ld a, (.dmark+2)  
3ede 32 bf fb			ld (debug_mark+2),a  
3ee1 18 03			jr .pastdmark  
3ee3 ..			.dmark: db "TC6"  
3ee6 f1			.pastdmark: pop af  
3ee7			endm  
# End of macro DMARK
3ee7						CALLMONITOR 
3ee7 cd d4 14			call break_point_state  
3eea				endm  
# End of macro CALLMONITOR
3eea					endif 
3eea			 
3eea			 
3eea			.totnxt: 
3eea			 
3eea 77					ld (hl), a 
3eeb 23					inc hl 
3eec					if DEBUG_FORTH_WORDS 
3eec						DMARK "TC7" 
3eec f5				push af  
3eed 3a 01 3f			ld a, (.dmark)  
3ef0 32 bd fb			ld (debug_mark),a  
3ef3 3a 02 3f			ld a, (.dmark+1)  
3ef6 32 be fb			ld (debug_mark+1),a  
3ef9 3a 03 3f			ld a, (.dmark+2)  
3efc 32 bf fb			ld (debug_mark+2),a  
3eff 18 03			jr .pastdmark  
3f01 ..			.dmark: db "TC7"  
3f04 f1			.pastdmark: pop af  
3f05			endm  
# End of macro DMARK
3f05						CALLMONITOR 
3f05 cd d4 14			call break_point_state  
3f08				endm  
# End of macro CALLMONITOR
3f08					endif 
3f08 c3 40 3e				jp .tot 
3f0b			 
3f0b					 
3f0b			 
3f0b			 
3f0b			; for each char convert to low 
3f0b					 
3f0b			.totdone: 
3f0b					if DEBUG_FORTH_WORDS 
3f0b						DMARK "TCd" 
3f0b f5				push af  
3f0c 3a 20 3f			ld a, (.dmark)  
3f0f 32 bd fb			ld (debug_mark),a  
3f12 3a 21 3f			ld a, (.dmark+1)  
3f15 32 be fb			ld (debug_mark+1),a  
3f18 3a 22 3f			ld a, (.dmark+2)  
3f1b 32 bf fb			ld (debug_mark+2),a  
3f1e 18 03			jr .pastdmark  
3f20 ..			.dmark: db "TCd"  
3f23 f1			.pastdmark: pop af  
3f24			endm  
# End of macro DMARK
3f24						CALLMONITOR 
3f24 cd d4 14			call break_point_state  
3f27				endm  
# End of macro CALLMONITOR
3f27					endif 
3f27					NEXTW 
3f27 c3 5f 1c			jp macro_next 
3f2a				endm 
# End of macro NEXTW
3f2a			 
3f2a			.SUBSTR: 
3f2a				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
3f2a 48				db WORD_SYS_CORE+52             
3f2b 88 3f			dw .LEFT            
3f2d 07				db 6 + 1 
3f2e .. 00			db "SUBSTR",0              
3f35				endm 
# End of macro CWHEAD
3f35			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3f35			 
3f35					if DEBUG_FORTH_WORDS_KEY 
3f35						DMARK "SST" 
3f35 f5				push af  
3f36 3a 4a 3f			ld a, (.dmark)  
3f39 32 bd fb			ld (debug_mark),a  
3f3c 3a 4b 3f			ld a, (.dmark+1)  
3f3f 32 be fb			ld (debug_mark+1),a  
3f42 3a 4c 3f			ld a, (.dmark+2)  
3f45 32 bf fb			ld (debug_mark+2),a  
3f48 18 03			jr .pastdmark  
3f4a ..			.dmark: db "SST"  
3f4d f1			.pastdmark: pop af  
3f4e			endm  
# End of macro DMARK
3f4e						CALLMONITOR 
3f4e cd d4 14			call break_point_state  
3f51				endm  
# End of macro CALLMONITOR
3f51					endif 
3f51			; TODO check string type 
3f51					FORTH_DSP_VALUEHL 
3f51 cd 09 1b			call macro_dsp_valuehl 
3f54				endm 
# End of macro FORTH_DSP_VALUEHL
3f54			 
3f54 e5					push hl      ; string length 
3f55			 
3f55					FORTH_DSP_POP 
3f55 cd a5 1b			call macro_forth_dsp_pop 
3f58				endm 
# End of macro FORTH_DSP_POP
3f58			 
3f58					FORTH_DSP_VALUEHL 
3f58 cd 09 1b			call macro_dsp_valuehl 
3f5b				endm 
# End of macro FORTH_DSP_VALUEHL
3f5b			 
3f5b e5					push hl     ; start char 
3f5c			 
3f5c					FORTH_DSP_POP 
3f5c cd a5 1b			call macro_forth_dsp_pop 
3f5f				endm 
# End of macro FORTH_DSP_POP
3f5f			 
3f5f			 
3f5f					FORTH_DSP_VALUE 
3f5f cd f2 1a			call macro_forth_dsp_value 
3f62				endm 
# End of macro FORTH_DSP_VALUE
3f62			 
3f62 d1					pop de    ; get start post offset 
3f63			 
3f63 19					add hl, de    ; starting offset 
3f64			 
3f64 c1					pop bc 
3f65 c5					push bc      ; grab size of string 
3f66			 
3f66 e5					push hl    ; save string start  
3f67			 
3f67 26 00				ld h, 0 
3f69 69					ld l, c 
3f6a 23					inc hl 
3f6b 23					inc hl 
3f6c			 
3f6c cd 83 11				call malloc 
3f6f				if DEBUG_FORTH_MALLOC_GUARD 
3f6f cc e2 4e				call z,malloc_error 
3f72				endif 
3f72			 
3f72 eb					ex de, hl      ; save malloc area for string copy 
3f73 e1					pop hl    ; get back source 
3f74 c1					pop bc    ; get length of string back 
3f75			 
3f75 d5					push de    ; save malloc area for after we push 
3f76 ed b0				ldir     ; copy substr 
3f78			 
3f78			 
3f78 eb					ex de, hl 
3f79 3e 00				ld a, 0 
3f7b 77					ld (hl), a   ; term substr 
3f7c			 
3f7c					 
3f7c e1					pop hl    ; get malloc so we can push it 
3f7d e5					push hl   ; save so we can free it afterwards 
3f7e			 
3f7e cd 80 1a				call forth_push_str 
3f81			 
3f81 e1					pop hl 
3f82 cd 4d 12				call free 
3f85			 
3f85					 
3f85					 
3f85			 
3f85			 
3f85					NEXTW 
3f85 c3 5f 1c			jp macro_next 
3f88				endm 
# End of macro NEXTW
3f88			 
3f88			.LEFT: 
3f88				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
3f88 48				db WORD_SYS_CORE+52             
3f89 b0 3f			dw .RIGHT            
3f8b 05				db 4 + 1 
3f8c .. 00			db "LEFT",0              
3f91				endm 
# End of macro CWHEAD
3f91			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
3f91					if DEBUG_FORTH_WORDS_KEY 
3f91						DMARK "LEF" 
3f91 f5				push af  
3f92 3a a6 3f			ld a, (.dmark)  
3f95 32 bd fb			ld (debug_mark),a  
3f98 3a a7 3f			ld a, (.dmark+1)  
3f9b 32 be fb			ld (debug_mark+1),a  
3f9e 3a a8 3f			ld a, (.dmark+2)  
3fa1 32 bf fb			ld (debug_mark+2),a  
3fa4 18 03			jr .pastdmark  
3fa6 ..			.dmark: db "LEF"  
3fa9 f1			.pastdmark: pop af  
3faa			endm  
# End of macro DMARK
3faa						CALLMONITOR 
3faa cd d4 14			call break_point_state  
3fad				endm  
# End of macro CALLMONITOR
3fad					endif 
3fad			 
3fad					NEXTW 
3fad c3 5f 1c			jp macro_next 
3fb0				endm 
# End of macro NEXTW
3fb0			.RIGHT: 
3fb0				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
3fb0 48				db WORD_SYS_CORE+52             
3fb1 d9 3f			dw .STR2NUM            
3fb3 06				db 5 + 1 
3fb4 .. 00			db "RIGHT",0              
3fba				endm 
# End of macro CWHEAD
3fba			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
3fba					if DEBUG_FORTH_WORDS_KEY 
3fba						DMARK "RIG" 
3fba f5				push af  
3fbb 3a cf 3f			ld a, (.dmark)  
3fbe 32 bd fb			ld (debug_mark),a  
3fc1 3a d0 3f			ld a, (.dmark+1)  
3fc4 32 be fb			ld (debug_mark+1),a  
3fc7 3a d1 3f			ld a, (.dmark+2)  
3fca 32 bf fb			ld (debug_mark+2),a  
3fcd 18 03			jr .pastdmark  
3fcf ..			.dmark: db "RIG"  
3fd2 f1			.pastdmark: pop af  
3fd3			endm  
# End of macro DMARK
3fd3						CALLMONITOR 
3fd3 cd d4 14			call break_point_state  
3fd6				endm  
# End of macro CALLMONITOR
3fd6					endif 
3fd6			 
3fd6					NEXTW 
3fd6 c3 5f 1c			jp macro_next 
3fd9				endm 
# End of macro NEXTW
3fd9			 
3fd9			 
3fd9			.STR2NUM: 
3fd9				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
3fd9 48				db WORD_SYS_CORE+52             
3fda 65 40			dw .NUM2STR            
3fdc 08				db 7 + 1 
3fdd .. 00			db "STR2NUM",0              
3fe5				endm 
# End of macro CWHEAD
3fe5			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
3fe5			 
3fe5			 
3fe5			; TODO STR type check to do 
3fe5					if DEBUG_FORTH_WORDS_KEY 
3fe5						DMARK "S2N" 
3fe5 f5				push af  
3fe6 3a fa 3f			ld a, (.dmark)  
3fe9 32 bd fb			ld (debug_mark),a  
3fec 3a fb 3f			ld a, (.dmark+1)  
3fef 32 be fb			ld (debug_mark+1),a  
3ff2 3a fc 3f			ld a, (.dmark+2)  
3ff5 32 bf fb			ld (debug_mark+2),a  
3ff8 18 03			jr .pastdmark  
3ffa ..			.dmark: db "S2N"  
3ffd f1			.pastdmark: pop af  
3ffe			endm  
# End of macro DMARK
3ffe						CALLMONITOR 
3ffe cd d4 14			call break_point_state  
4001				endm  
# End of macro CALLMONITOR
4001					endif 
4001			 
4001					;FORTH_DSP 
4001					FORTH_DSP_VALUE 
4001 cd f2 1a			call macro_forth_dsp_value 
4004				endm 
# End of macro FORTH_DSP_VALUE
4004					;inc hl 
4004			 
4004 eb					ex de, hl 
4005					if DEBUG_FORTH_WORDS 
4005						DMARK "S2a" 
4005 f5				push af  
4006 3a 1a 40			ld a, (.dmark)  
4009 32 bd fb			ld (debug_mark),a  
400c 3a 1b 40			ld a, (.dmark+1)  
400f 32 be fb			ld (debug_mark+1),a  
4012 3a 1c 40			ld a, (.dmark+2)  
4015 32 bf fb			ld (debug_mark+2),a  
4018 18 03			jr .pastdmark  
401a ..			.dmark: db "S2a"  
401d f1			.pastdmark: pop af  
401e			endm  
# End of macro DMARK
401e						CALLMONITOR 
401e cd d4 14			call break_point_state  
4021				endm  
# End of macro CALLMONITOR
4021					endif 
4021 cd b1 10				call string_to_uint16 
4024			 
4024					if DEBUG_FORTH_WORDS 
4024						DMARK "S2b" 
4024 f5				push af  
4025 3a 39 40			ld a, (.dmark)  
4028 32 bd fb			ld (debug_mark),a  
402b 3a 3a 40			ld a, (.dmark+1)  
402e 32 be fb			ld (debug_mark+1),a  
4031 3a 3b 40			ld a, (.dmark+2)  
4034 32 bf fb			ld (debug_mark+2),a  
4037 18 03			jr .pastdmark  
4039 ..			.dmark: db "S2b"  
403c f1			.pastdmark: pop af  
403d			endm  
# End of macro DMARK
403d						CALLMONITOR 
403d cd d4 14			call break_point_state  
4040				endm  
# End of macro CALLMONITOR
4040					endif 
4040			;		push hl 
4040					FORTH_DSP_POP 
4040 cd a5 1b			call macro_forth_dsp_pop 
4043				endm 
# End of macro FORTH_DSP_POP
4043			;		pop hl 
4043					 
4043					if DEBUG_FORTH_WORDS 
4043						DMARK "S2b" 
4043 f5				push af  
4044 3a 58 40			ld a, (.dmark)  
4047 32 bd fb			ld (debug_mark),a  
404a 3a 59 40			ld a, (.dmark+1)  
404d 32 be fb			ld (debug_mark+1),a  
4050 3a 5a 40			ld a, (.dmark+2)  
4053 32 bf fb			ld (debug_mark+2),a  
4056 18 03			jr .pastdmark  
4058 ..			.dmark: db "S2b"  
405b f1			.pastdmark: pop af  
405c			endm  
# End of macro DMARK
405c						CALLMONITOR 
405c cd d4 14			call break_point_state  
405f				endm  
# End of macro CALLMONITOR
405f					endif 
405f cd 6e 1a				call forth_push_numhl	 
4062			 
4062				 
4062				       NEXTW 
4062 c3 5f 1c			jp macro_next 
4065				endm 
# End of macro NEXTW
4065			.NUM2STR: 
4065				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4065 48				db WORD_SYS_CORE+52             
4066 74 40			dw .CONCAT            
4068 08				db 7 + 1 
4069 .. 00			db "NUM2STR",0              
4071				endm 
# End of macro CWHEAD
4071			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4071			 
4071			;		; malloc a string to target 
4071			;		ld hl, 10     ; TODO max string size should be fine 
4071			;		call malloc 
4071			;		push hl    ; save malloc location 
4071			; 
4071			; 
4071			;; TODO check int type 
4071			;		FORTH_DSP_VALUEHL 
4071			;		ld a, l 
4071			;		call DispAToASCII   
4071			;;TODO need to chage above call to dump into string 
4071			; 
4071			; 
4071			 
4071				       NEXTW 
4071 c3 5f 1c			jp macro_next 
4074				endm 
# End of macro NEXTW
4074			 
4074			.CONCAT: 
4074				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4074 48				db WORD_SYS_CORE+52             
4075 27 41			dw .FIND            
4077 07				db 6 + 1 
4078 .. 00			db "CONCAT",0              
407f				endm 
# End of macro CWHEAD
407f			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
407f			 
407f			; TODO check string type 
407f			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
407f			 
407f					if DEBUG_FORTH_WORDS_KEY 
407f						DMARK "CON" 
407f f5				push af  
4080 3a 94 40			ld a, (.dmark)  
4083 32 bd fb			ld (debug_mark),a  
4086 3a 95 40			ld a, (.dmark+1)  
4089 32 be fb			ld (debug_mark+1),a  
408c 3a 96 40			ld a, (.dmark+2)  
408f 32 bf fb			ld (debug_mark+2),a  
4092 18 03			jr .pastdmark  
4094 ..			.dmark: db "CON"  
4097 f1			.pastdmark: pop af  
4098			endm  
# End of macro DMARK
4098						CALLMONITOR 
4098 cd d4 14			call break_point_state  
409b				endm  
# End of macro CALLMONITOR
409b					endif 
409b			 
409b			 
409b					FORTH_DSP_VALUE 
409b cd f2 1a			call macro_forth_dsp_value 
409e				endm 
# End of macro FORTH_DSP_VALUE
409e e5					push hl   ; s2 
409f			 
409f					FORTH_DSP_POP 
409f cd a5 1b			call macro_forth_dsp_pop 
40a2				endm 
# End of macro FORTH_DSP_POP
40a2			 
40a2					FORTH_DSP_VALUE 
40a2 cd f2 1a			call macro_forth_dsp_value 
40a5				endm 
# End of macro FORTH_DSP_VALUE
40a5			 
40a5 e5					push hl   ; s1 
40a6			 
40a6					FORTH_DSP_POP 
40a6 cd a5 1b			call macro_forth_dsp_pop 
40a9				endm 
# End of macro FORTH_DSP_POP
40a9					 
40a9			 
40a9					; copy s1 
40a9			 
40a9				 
40a9					; save ptr 
40a9 e1					pop hl  
40aa e5					push hl 
40ab 3e 00				ld a, 0 
40ad cd 25 11				call strlent 
40b0					;inc hl    ; zer0 
40b0 06 00				ld b, 0 
40b2 4d					ld c, l 
40b3 e1					pop hl		 
40b4 11 b8 ef				ld de, scratch	 
40b7					if DEBUG_FORTH_WORDS 
40b7						DMARK "CO1" 
40b7 f5				push af  
40b8 3a cc 40			ld a, (.dmark)  
40bb 32 bd fb			ld (debug_mark),a  
40be 3a cd 40			ld a, (.dmark+1)  
40c1 32 be fb			ld (debug_mark+1),a  
40c4 3a ce 40			ld a, (.dmark+2)  
40c7 32 bf fb			ld (debug_mark+2),a  
40ca 18 03			jr .pastdmark  
40cc ..			.dmark: db "CO1"  
40cf f1			.pastdmark: pop af  
40d0			endm  
# End of macro DMARK
40d0						CALLMONITOR 
40d0 cd d4 14			call break_point_state  
40d3				endm  
# End of macro CALLMONITOR
40d3					endif 
40d3 ed b0				ldir 
40d5			 
40d5 e1					pop hl 
40d6 e5					push hl 
40d7 d5					push de 
40d8			 
40d8			 
40d8 3e 00				ld a, 0 
40da cd 25 11				call strlent 
40dd 23					inc hl    ; zer0 
40de 23					inc hl 
40df 06 00				ld b, 0 
40e1 4d					ld c, l 
40e2 d1					pop de 
40e3 e1					pop hl		 
40e4					if DEBUG_FORTH_WORDS 
40e4						DMARK "CO2" 
40e4 f5				push af  
40e5 3a f9 40			ld a, (.dmark)  
40e8 32 bd fb			ld (debug_mark),a  
40eb 3a fa 40			ld a, (.dmark+1)  
40ee 32 be fb			ld (debug_mark+1),a  
40f1 3a fb 40			ld a, (.dmark+2)  
40f4 32 bf fb			ld (debug_mark+2),a  
40f7 18 03			jr .pastdmark  
40f9 ..			.dmark: db "CO2"  
40fc f1			.pastdmark: pop af  
40fd			endm  
# End of macro DMARK
40fd						CALLMONITOR 
40fd cd d4 14			call break_point_state  
4100				endm  
# End of macro CALLMONITOR
4100					endif 
4100 ed b0				ldir 
4102			 
4102			 
4102			 
4102 21 b8 ef				ld hl, scratch 
4105					if DEBUG_FORTH_WORDS 
4105						DMARK "CO5" 
4105 f5				push af  
4106 3a 1a 41			ld a, (.dmark)  
4109 32 bd fb			ld (debug_mark),a  
410c 3a 1b 41			ld a, (.dmark+1)  
410f 32 be fb			ld (debug_mark+1),a  
4112 3a 1c 41			ld a, (.dmark+2)  
4115 32 bf fb			ld (debug_mark+2),a  
4118 18 03			jr .pastdmark  
411a ..			.dmark: db "CO5"  
411d f1			.pastdmark: pop af  
411e			endm  
# End of macro DMARK
411e						CALLMONITOR 
411e cd d4 14			call break_point_state  
4121				endm  
# End of macro CALLMONITOR
4121					endif 
4121			 
4121 cd 80 1a				call forth_push_str 
4124			 
4124			 
4124			 
4124			 
4124				       NEXTW 
4124 c3 5f 1c			jp macro_next 
4127				endm 
# End of macro NEXTW
4127			 
4127			 
4127			.FIND: 
4127				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4127 4b				db WORD_SYS_CORE+55             
4128 e5 41			dw .LEN            
412a 05				db 4 + 1 
412b .. 00			db "FIND",0              
4130				endm 
# End of macro CWHEAD
4130			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4130			 
4130					if DEBUG_FORTH_WORDS_KEY 
4130						DMARK "FND" 
4130 f5				push af  
4131 3a 45 41			ld a, (.dmark)  
4134 32 bd fb			ld (debug_mark),a  
4137 3a 46 41			ld a, (.dmark+1)  
413a 32 be fb			ld (debug_mark+1),a  
413d 3a 47 41			ld a, (.dmark+2)  
4140 32 bf fb			ld (debug_mark+2),a  
4143 18 03			jr .pastdmark  
4145 ..			.dmark: db "FND"  
4148 f1			.pastdmark: pop af  
4149			endm  
# End of macro DMARK
4149						CALLMONITOR 
4149 cd d4 14			call break_point_state  
414c				endm  
# End of macro CALLMONITOR
414c					endif 
414c			 
414c			; TODO check string type 
414c					FORTH_DSP_VALUE 
414c cd f2 1a			call macro_forth_dsp_value 
414f				endm 
# End of macro FORTH_DSP_VALUE
414f			 
414f e5					push hl    
4150 7e					ld a,(hl)    ; char to find   
4151			; TODO change char to substr 
4151			 
4151 f5					push af 
4152					 
4152			 
4152			 
4152					if DEBUG_FORTH_WORDS 
4152						DMARK "FN1" 
4152 f5				push af  
4153 3a 67 41			ld a, (.dmark)  
4156 32 bd fb			ld (debug_mark),a  
4159 3a 68 41			ld a, (.dmark+1)  
415c 32 be fb			ld (debug_mark+1),a  
415f 3a 69 41			ld a, (.dmark+2)  
4162 32 bf fb			ld (debug_mark+2),a  
4165 18 03			jr .pastdmark  
4167 ..			.dmark: db "FN1"  
416a f1			.pastdmark: pop af  
416b			endm  
# End of macro DMARK
416b						CALLMONITOR 
416b cd d4 14			call break_point_state  
416e				endm  
# End of macro CALLMONITOR
416e					endif 
416e			 
416e					FORTH_DSP_POP 
416e cd a5 1b			call macro_forth_dsp_pop 
4171				endm 
# End of macro FORTH_DSP_POP
4171			 
4171					; string to search 
4171			 
4171					FORTH_DSP_VALUE 
4171 cd f2 1a			call macro_forth_dsp_value 
4174				endm 
# End of macro FORTH_DSP_VALUE
4174			 
4174 d1					pop de  ; d is char to find  
4175			 
4175					if DEBUG_FORTH_WORDS 
4175						DMARK "FN2" 
4175 f5				push af  
4176 3a 8a 41			ld a, (.dmark)  
4179 32 bd fb			ld (debug_mark),a  
417c 3a 8b 41			ld a, (.dmark+1)  
417f 32 be fb			ld (debug_mark+1),a  
4182 3a 8c 41			ld a, (.dmark+2)  
4185 32 bf fb			ld (debug_mark+2),a  
4188 18 03			jr .pastdmark  
418a ..			.dmark: db "FN2"  
418d f1			.pastdmark: pop af  
418e			endm  
# End of macro DMARK
418e						CALLMONITOR 
418e cd d4 14			call break_point_state  
4191				endm  
# End of macro CALLMONITOR
4191					endif 
4191					 
4191 01 00 00				ld bc, 0 
4194 7e			.findchar:      ld a,(hl) 
4195 fe 00				cp 0   		 
4197 28 27				jr z, .finddone     
4199 ba					cp d 
419a 28 20				jr z, .foundchar 
419c 03					inc bc 
419d 23					inc hl 
419e					if DEBUG_FORTH_WORDS 
419e						DMARK "FN3" 
419e f5				push af  
419f 3a b3 41			ld a, (.dmark)  
41a2 32 bd fb			ld (debug_mark),a  
41a5 3a b4 41			ld a, (.dmark+1)  
41a8 32 be fb			ld (debug_mark+1),a  
41ab 3a b5 41			ld a, (.dmark+2)  
41ae 32 bf fb			ld (debug_mark+2),a  
41b1 18 03			jr .pastdmark  
41b3 ..			.dmark: db "FN3"  
41b6 f1			.pastdmark: pop af  
41b7			endm  
# End of macro DMARK
41b7						CALLMONITOR 
41b7 cd d4 14			call break_point_state  
41ba				endm  
# End of macro CALLMONITOR
41ba					endif 
41ba 18 d8				jr .findchar 
41bc			 
41bc			 
41bc c5			.foundchar:	push bc 
41bd e1					pop hl 
41be 18 03				jr .findexit 
41c0			 
41c0			 
41c0							 
41c0			 
41c0			.finddone:     ; got to end of string with no find 
41c0 21 00 00				ld hl, 0 
41c3			.findexit: 
41c3			 
41c3					if DEBUG_FORTH_WORDS 
41c3						DMARK "FNd" 
41c3 f5				push af  
41c4 3a d8 41			ld a, (.dmark)  
41c7 32 bd fb			ld (debug_mark),a  
41ca 3a d9 41			ld a, (.dmark+1)  
41cd 32 be fb			ld (debug_mark+1),a  
41d0 3a da 41			ld a, (.dmark+2)  
41d3 32 bf fb			ld (debug_mark+2),a  
41d6 18 03			jr .pastdmark  
41d8 ..			.dmark: db "FNd"  
41db f1			.pastdmark: pop af  
41dc			endm  
# End of macro DMARK
41dc						CALLMONITOR 
41dc cd d4 14			call break_point_state  
41df				endm  
# End of macro CALLMONITOR
41df					endif 
41df cd 6e 1a			call forth_push_numhl 
41e2			 
41e2				       NEXTW 
41e2 c3 5f 1c			jp macro_next 
41e5				endm 
# End of macro NEXTW
41e5			 
41e5			.LEN: 
41e5				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
41e5 4c				db WORD_SYS_CORE+56             
41e6 1a 42			dw .CHAR            
41e8 06				db 5 + 1 
41e9 .. 00			db "COUNT",0              
41ef				endm 
# End of macro CWHEAD
41ef			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
41ef			 
41ef					if DEBUG_FORTH_WORDS_KEY 
41ef						DMARK "CNT" 
41ef f5				push af  
41f0 3a 04 42			ld a, (.dmark)  
41f3 32 bd fb			ld (debug_mark),a  
41f6 3a 05 42			ld a, (.dmark+1)  
41f9 32 be fb			ld (debug_mark+1),a  
41fc 3a 06 42			ld a, (.dmark+2)  
41ff 32 bf fb			ld (debug_mark+2),a  
4202 18 03			jr .pastdmark  
4204 ..			.dmark: db "CNT"  
4207 f1			.pastdmark: pop af  
4208			endm  
# End of macro DMARK
4208						CALLMONITOR 
4208 cd d4 14			call break_point_state  
420b				endm  
# End of macro CALLMONITOR
420b					endif 
420b			; TODO check string type 
420b					FORTH_DSP 
420b cd ee 1a			call macro_forth_dsp 
420e				endm 
# End of macro FORTH_DSP
420e					;v5FORTH_DSP_VALUE 
420e			 
420e 23					inc hl 
420f			 
420f 3e 00				ld a, 0 
4211 cd 25 11				call strlent 
4214			 
4214 cd 6e 1a				call forth_push_numhl 
4217			 
4217			 
4217			 
4217				       NEXTW 
4217 c3 5f 1c			jp macro_next 
421a				endm 
# End of macro NEXTW
421a			.CHAR: 
421a				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
421a 4d				db WORD_SYS_CORE+57             
421b 50 42			dw .ENDSTR            
421d 05				db 4 + 1 
421e .. 00			db "CHAR",0              
4223				endm 
# End of macro CWHEAD
4223			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4223					if DEBUG_FORTH_WORDS_KEY 
4223						DMARK "CHR" 
4223 f5				push af  
4224 3a 38 42			ld a, (.dmark)  
4227 32 bd fb			ld (debug_mark),a  
422a 3a 39 42			ld a, (.dmark+1)  
422d 32 be fb			ld (debug_mark+1),a  
4230 3a 3a 42			ld a, (.dmark+2)  
4233 32 bf fb			ld (debug_mark+2),a  
4236 18 03			jr .pastdmark  
4238 ..			.dmark: db "CHR"  
423b f1			.pastdmark: pop af  
423c			endm  
# End of macro DMARK
423c						CALLMONITOR 
423c cd d4 14			call break_point_state  
423f				endm  
# End of macro CALLMONITOR
423f					endif 
423f					FORTH_DSP 
423f cd ee 1a			call macro_forth_dsp 
4242				endm 
# End of macro FORTH_DSP
4242					;v5 FORTH_DSP_VALUE 
4242 23					inc hl      ; now at start of numeric as string 
4243			 
4243			;		push hl 
4243			 
4243					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4243 cd a5 1b			call macro_forth_dsp_pop 
4246				endm 
# End of macro FORTH_DSP_POP
4246			 
4246			;		pop hl 
4246			 
4246					; push the content of a onto the stack as a value 
4246			 
4246 7e					ld a,(hl)   ; get char 
4247 26 00				ld h,0 
4249 6f					ld l,a 
424a cd 6e 1a				call forth_push_numhl 
424d			 
424d				       NEXTW 
424d c3 5f 1c			jp macro_next 
4250				endm 
# End of macro NEXTW
4250			 
4250			 
4250			 
4250			 
4250			.ENDSTR: 
4250			; eof 
4250			 
# End of file forth_words_str.asm
4250			include "forth_words_key.asm" 
4250			 
4250			; | ## Keyboard Words 
4250			 
4250			.KEY: 
4250				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4250 3e				db WORD_SYS_CORE+42             
4251 80 42			dw .WAITK            
4253 04				db 3 + 1 
4254 .. 00			db "KEY",0              
4258				endm 
# End of macro CWHEAD
4258			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4258			 
4258					if DEBUG_FORTH_WORDS_KEY 
4258						DMARK "KEY" 
4258 f5				push af  
4259 3a 6d 42			ld a, (.dmark)  
425c 32 bd fb			ld (debug_mark),a  
425f 3a 6e 42			ld a, (.dmark+1)  
4262 32 be fb			ld (debug_mark+1),a  
4265 3a 6f 42			ld a, (.dmark+2)  
4268 32 bf fb			ld (debug_mark+2),a  
426b 18 03			jr .pastdmark  
426d ..			.dmark: db "KEY"  
4270 f1			.pastdmark: pop af  
4271			endm  
# End of macro DMARK
4271						CALLMONITOR 
4271 cd d4 14			call break_point_state  
4274				endm  
# End of macro CALLMONITOR
4274					endif 
4274			; TODO currently waits 
4274 cd 49 63				call cin 
4277					;call cin_wait 
4277 6f					ld l, a 
4278 26 00				ld h, 0 
427a cd 6e 1a				call forth_push_numhl 
427d					NEXTW 
427d c3 5f 1c			jp macro_next 
4280				endm 
# End of macro NEXTW
4280			.WAITK: 
4280				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4280 3f				db WORD_SYS_CORE+43             
4281 b2 42			dw .ACCEPT            
4283 06				db 5 + 1 
4284 .. 00			db "WAITK",0              
428a				endm 
# End of macro CWHEAD
428a			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
428a					if DEBUG_FORTH_WORDS_KEY 
428a						DMARK "WAI" 
428a f5				push af  
428b 3a 9f 42			ld a, (.dmark)  
428e 32 bd fb			ld (debug_mark),a  
4291 3a a0 42			ld a, (.dmark+1)  
4294 32 be fb			ld (debug_mark+1),a  
4297 3a a1 42			ld a, (.dmark+2)  
429a 32 bf fb			ld (debug_mark+2),a  
429d 18 03			jr .pastdmark  
429f ..			.dmark: db "WAI"  
42a2 f1			.pastdmark: pop af  
42a3			endm  
# End of macro DMARK
42a3						CALLMONITOR 
42a3 cd d4 14			call break_point_state  
42a6				endm  
# End of macro CALLMONITOR
42a6					endif 
42a6 cd 38 63				call cin_wait 
42a9 6f					ld l, a 
42aa 26 00				ld h, 0 
42ac cd 6e 1a				call forth_push_numhl 
42af					NEXTW 
42af c3 5f 1c			jp macro_next 
42b2				endm 
# End of macro NEXTW
42b2			.ACCEPT: 
42b2				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
42b2 40				db WORD_SYS_CORE+44             
42b3 10 43			dw .EDIT            
42b5 07				db 6 + 1 
42b6 .. 00			db "ACCEPT",0              
42bd				endm 
# End of macro CWHEAD
42bd			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
42bd					; TODO crashes on push 
42bd					if DEBUG_FORTH_WORDS_KEY 
42bd						DMARK "ACC" 
42bd f5				push af  
42be 3a d2 42			ld a, (.dmark)  
42c1 32 bd fb			ld (debug_mark),a  
42c4 3a d3 42			ld a, (.dmark+1)  
42c7 32 be fb			ld (debug_mark+1),a  
42ca 3a d4 42			ld a, (.dmark+2)  
42cd 32 bf fb			ld (debug_mark+2),a  
42d0 18 03			jr .pastdmark  
42d2 ..			.dmark: db "ACC"  
42d5 f1			.pastdmark: pop af  
42d6			endm  
# End of macro DMARK
42d6						CALLMONITOR 
42d6 cd d4 14			call break_point_state  
42d9				endm  
# End of macro CALLMONITOR
42d9					endif 
42d9 21 b6 f1				ld hl, os_input 
42dc 3e 00				ld a, 0 
42de 77					ld (hl),a 
42df 3a e1 f9				ld a,(f_cursor_ptr) 
42e2 16 64				ld d, 100 
42e4 0e 00				ld c, 0 
42e6 1e 28				ld e, 40 
42e8 cd e9 0c				call input_str 
42eb					; TODO perhaps do a type check and wrap in quotes if not a number 
42eb 21 b6 f1				ld hl, os_input 
42ee					if DEBUG_FORTH_WORDS 
42ee						DMARK "AC1" 
42ee f5				push af  
42ef 3a 03 43			ld a, (.dmark)  
42f2 32 bd fb			ld (debug_mark),a  
42f5 3a 04 43			ld a, (.dmark+1)  
42f8 32 be fb			ld (debug_mark+1),a  
42fb 3a 05 43			ld a, (.dmark+2)  
42fe 32 bf fb			ld (debug_mark+2),a  
4301 18 03			jr .pastdmark  
4303 ..			.dmark: db "AC1"  
4306 f1			.pastdmark: pop af  
4307			endm  
# End of macro DMARK
4307						CALLMONITOR 
4307 cd d4 14			call break_point_state  
430a				endm  
# End of macro CALLMONITOR
430a					endif 
430a cd 80 1a				call forth_push_str 
430d					NEXTW 
430d c3 5f 1c			jp macro_next 
4310				endm 
# End of macro NEXTW
4310			 
4310			.EDIT: 
4310				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4310 40				db WORD_SYS_CORE+44             
4311 99 43			dw .ENDKEY            
4313 05				db 4 + 1 
4314 .. 00			db "EDIT",0              
4319				endm 
# End of macro CWHEAD
4319			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4319			 
4319					; TODO does not copy from stack 
4319					if DEBUG_FORTH_WORDS_KEY 
4319						DMARK "EDT" 
4319 f5				push af  
431a 3a 2e 43			ld a, (.dmark)  
431d 32 bd fb			ld (debug_mark),a  
4320 3a 2f 43			ld a, (.dmark+1)  
4323 32 be fb			ld (debug_mark+1),a  
4326 3a 30 43			ld a, (.dmark+2)  
4329 32 bf fb			ld (debug_mark+2),a  
432c 18 03			jr .pastdmark  
432e ..			.dmark: db "EDT"  
4331 f1			.pastdmark: pop af  
4332			endm  
# End of macro DMARK
4332						CALLMONITOR 
4332 cd d4 14			call break_point_state  
4335				endm  
# End of macro CALLMONITOR
4335					endif 
4335			 
4335					FORTH_DSP 
4335 cd ee 1a			call macro_forth_dsp 
4338				endm 
# End of macro FORTH_DSP
4338					;v5 FORTH_DSP_VALUE 
4338 23					inc hl    ; TODO do type check 
4339			 
4339 e5					push hl 
433a 3e 00				ld a, 0 
433c cd 25 11				call strlent 
433f 23					inc hl 
4340			 
4340 06 00				ld b, 0 
4342 4d					ld c, l 
4343			 
4343 e1					pop hl 
4344 11 b6 f1				ld de, os_input 
4347					if DEBUG_FORTH_WORDS_KEY 
4347						DMARK "EDc" 
4347 f5				push af  
4348 3a 5c 43			ld a, (.dmark)  
434b 32 bd fb			ld (debug_mark),a  
434e 3a 5d 43			ld a, (.dmark+1)  
4351 32 be fb			ld (debug_mark+1),a  
4354 3a 5e 43			ld a, (.dmark+2)  
4357 32 bf fb			ld (debug_mark+2),a  
435a 18 03			jr .pastdmark  
435c ..			.dmark: db "EDc"  
435f f1			.pastdmark: pop af  
4360			endm  
# End of macro DMARK
4360						CALLMONITOR 
4360 cd d4 14			call break_point_state  
4363				endm  
# End of macro CALLMONITOR
4363					endif 
4363 ed b0				ldir 
4365			 
4365			 
4365 21 b6 f1				ld hl, os_input 
4368					;ld a, 0 
4368					;ld (hl),a 
4368 3a e1 f9				ld a,(f_cursor_ptr) 
436b 16 64				ld d, 100 
436d 0e 00				ld c, 0 
436f 1e 28				ld e, 40 
4371 cd e9 0c				call input_str 
4374					; TODO perhaps do a type check and wrap in quotes if not a number 
4374 21 b6 f1				ld hl, os_input 
4377					if DEBUG_FORTH_WORDS 
4377						DMARK "ED1" 
4377 f5				push af  
4378 3a 8c 43			ld a, (.dmark)  
437b 32 bd fb			ld (debug_mark),a  
437e 3a 8d 43			ld a, (.dmark+1)  
4381 32 be fb			ld (debug_mark+1),a  
4384 3a 8e 43			ld a, (.dmark+2)  
4387 32 bf fb			ld (debug_mark+2),a  
438a 18 03			jr .pastdmark  
438c ..			.dmark: db "ED1"  
438f f1			.pastdmark: pop af  
4390			endm  
# End of macro DMARK
4390						CALLMONITOR 
4390 cd d4 14			call break_point_state  
4393				endm  
# End of macro CALLMONITOR
4393					endif 
4393 cd 80 1a				call forth_push_str 
4396					NEXTW 
4396 c3 5f 1c			jp macro_next 
4399				endm 
# End of macro NEXTW
4399			 
4399			 
4399			 
4399			.ENDKEY: 
4399			; eof 
4399			 
# End of file forth_words_key.asm
4399			 
4399			if STORAGE_SE 
4399			   	include "forth_words_storage.asm" 
4399			 
4399			; | ## Fixed Storage Words 
4399			 
4399			 
4399			.BREAD: 
4399			  
4399				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4399 3a				db WORD_SYS_CORE+38             
439a 12 44			dw .BWRITE            
439c 06				db 5 + 1 
439d .. 00			db "BREAD",0              
43a3				endm 
# End of macro CWHEAD
43a3			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
43a3				 
43a3					if DEBUG_FORTH_WORDS_KEY 
43a3						DMARK "BRD" 
43a3 f5				push af  
43a4 3a b8 43			ld a, (.dmark)  
43a7 32 bd fb			ld (debug_mark),a  
43aa 3a b9 43			ld a, (.dmark+1)  
43ad 32 be fb			ld (debug_mark+1),a  
43b0 3a ba 43			ld a, (.dmark+2)  
43b3 32 bf fb			ld (debug_mark+2),a  
43b6 18 03			jr .pastdmark  
43b8 ..			.dmark: db "BRD"  
43bb f1			.pastdmark: pop af  
43bc			endm  
# End of macro DMARK
43bc						CALLMONITOR 
43bc cd d4 14			call break_point_state  
43bf				endm  
# End of macro CALLMONITOR
43bf					endif 
43bf			 
43bf				FORTH_DSP_VALUEHL 
43bf cd 09 1b			call macro_dsp_valuehl 
43c2				endm 
# End of macro FORTH_DSP_VALUEHL
43c2			 
43c2				FORTH_DSP_POP 
43c2 cd a5 1b			call macro_forth_dsp_pop 
43c5				endm 
# End of macro FORTH_DSP_POP
43c5			 
43c5				; calc block address 
43c5			 
43c5 eb				ex de, hl 
43c6 3e 40			ld a, STORE_BLOCK_PHY 
43c8 cd 3f 0c			call Mult16 
43cb			 
43cb			 
43cb 11 e8 f9			ld de, store_page 
43ce			 
43ce					if DEBUG_FORTH_WORDS 
43ce						DMARK "BR1" 
43ce f5				push af  
43cf 3a e3 43			ld a, (.dmark)  
43d2 32 bd fb			ld (debug_mark),a  
43d5 3a e4 43			ld a, (.dmark+1)  
43d8 32 be fb			ld (debug_mark+1),a  
43db 3a e5 43			ld a, (.dmark+2)  
43de 32 bf fb			ld (debug_mark+2),a  
43e1 18 03			jr .pastdmark  
43e3 ..			.dmark: db "BR1"  
43e6 f1			.pastdmark: pop af  
43e7			endm  
# End of macro DMARK
43e7						CALLMONITOR 
43e7 cd d4 14			call break_point_state  
43ea				endm  
# End of macro CALLMONITOR
43ea					endif 
43ea			 
43ea cd 09 03			call storage_read_block 
43ed			 
43ed 21 ea f9		        ld hl, store_page+2 
43f0					if DEBUG_FORTH_WORDS 
43f0						DMARK "BR2" 
43f0 f5				push af  
43f1 3a 05 44			ld a, (.dmark)  
43f4 32 bd fb			ld (debug_mark),a  
43f7 3a 06 44			ld a, (.dmark+1)  
43fa 32 be fb			ld (debug_mark+1),a  
43fd 3a 07 44			ld a, (.dmark+2)  
4400 32 bf fb			ld (debug_mark+2),a  
4403 18 03			jr .pastdmark  
4405 ..			.dmark: db "BR2"  
4408 f1			.pastdmark: pop af  
4409			endm  
# End of macro DMARK
4409						CALLMONITOR 
4409 cd d4 14			call break_point_state  
440c				endm  
# End of macro CALLMONITOR
440c					endif 
440c cd 80 1a			call forth_push_str 
440f			 
440f			 
440f					NEXTW 
440f c3 5f 1c			jp macro_next 
4412				endm 
# End of macro NEXTW
4412			.BWRITE: 
4412				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4412 3a				db WORD_SYS_CORE+38             
4413 a7 44			dw .BUPD            
4415 07				db 6 + 1 
4416 .. 00			db "BWRITE",0              
441d				endm 
# End of macro CWHEAD
441d			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
441d			 
441d					if DEBUG_FORTH_WORDS_KEY 
441d						DMARK "BWR" 
441d f5				push af  
441e 3a 32 44			ld a, (.dmark)  
4421 32 bd fb			ld (debug_mark),a  
4424 3a 33 44			ld a, (.dmark+1)  
4427 32 be fb			ld (debug_mark+1),a  
442a 3a 34 44			ld a, (.dmark+2)  
442d 32 bf fb			ld (debug_mark+2),a  
4430 18 03			jr .pastdmark  
4432 ..			.dmark: db "BWR"  
4435 f1			.pastdmark: pop af  
4436			endm  
# End of macro DMARK
4436						CALLMONITOR 
4436 cd d4 14			call break_point_state  
4439				endm  
# End of macro CALLMONITOR
4439					endif 
4439			 
4439				FORTH_DSP_VALUEHL 
4439 cd 09 1b			call macro_dsp_valuehl 
443c				endm 
# End of macro FORTH_DSP_VALUEHL
443c			 
443c				; calc block address 
443c			 
443c eb				ex de, hl 
443d 3e 40			ld a, STORE_BLOCK_PHY 
443f cd 3f 0c			call Mult16 
4442			 
4442 e5				push hl         ; address 
4443			 
4443				FORTH_DSP_POP 
4443 cd a5 1b			call macro_forth_dsp_pop 
4446				endm 
# End of macro FORTH_DSP_POP
4446			 
4446				FORTH_DSP_VALUEHL 
4446 cd 09 1b			call macro_dsp_valuehl 
4449				endm 
# End of macro FORTH_DSP_VALUEHL
4449			 
4449				FORTH_DSP_POP 
4449 cd a5 1b			call macro_forth_dsp_pop 
444c				endm 
# End of macro FORTH_DSP_POP
444c			 
444c cd 0a 0a			call storage_clear_page 
444f			 
444f				; copy string to store page 
444f			 
444f e5				push hl     ; save string address 
4450			 
4450 3e 00			ld a, 0 
4452 cd 25 11			call strlent 
4455			 
4455 23				inc hl 
4456			 
4456 4d				ld c, l 
4457 06 00			ld b, 0 
4459			 
4459 e1				pop hl 
445a 11 ea f9			ld de, store_page + 2 
445d					if DEBUG_FORTH_WORDS 
445d						DMARK "BW1" 
445d f5				push af  
445e 3a 72 44			ld a, (.dmark)  
4461 32 bd fb			ld (debug_mark),a  
4464 3a 73 44			ld a, (.dmark+1)  
4467 32 be fb			ld (debug_mark+1),a  
446a 3a 74 44			ld a, (.dmark+2)  
446d 32 bf fb			ld (debug_mark+2),a  
4470 18 03			jr .pastdmark  
4472 ..			.dmark: db "BW1"  
4475 f1			.pastdmark: pop af  
4476			endm  
# End of macro DMARK
4476						CALLMONITOR 
4476 cd d4 14			call break_point_state  
4479				endm  
# End of macro CALLMONITOR
4479					endif 
4479 ed b0			ldir 
447b			 
447b			 
447b				; poke the start of the block with flags to prevent high level file ops hitting the block 
447b			 
447b 21 ff ff			ld hl, $ffff 
447e			 
447e 22 e8 f9			ld (store_page), hl	 
4481				 
4481 e1				pop hl    ; get address 
4482 11 e8 f9			ld de, store_page 
4485			 
4485					if DEBUG_FORTH_WORDS 
4485						DMARK "BW2" 
4485 f5				push af  
4486 3a 9a 44			ld a, (.dmark)  
4489 32 bd fb			ld (debug_mark),a  
448c 3a 9b 44			ld a, (.dmark+1)  
448f 32 be fb			ld (debug_mark+1),a  
4492 3a 9c 44			ld a, (.dmark+2)  
4495 32 bf fb			ld (debug_mark+2),a  
4498 18 03			jr .pastdmark  
449a ..			.dmark: db "BW2"  
449d f1			.pastdmark: pop af  
449e			endm  
# End of macro DMARK
449e						CALLMONITOR 
449e cd d4 14			call break_point_state  
44a1				endm  
# End of macro CALLMONITOR
44a1					endif 
44a1			 
44a1 cd 6e 03			call storage_write_block 
44a4			 
44a4					NEXTW 
44a4 c3 5f 1c			jp macro_next 
44a7				endm 
# End of macro NEXTW
44a7			 
44a7			.BUPD: 
44a7				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
44a7 3a				db WORD_SYS_CORE+38             
44a8 fd 44			dw .BYID            
44aa 05				db 4 + 1 
44ab .. 00			db "BUPD",0              
44b0				endm 
# End of macro CWHEAD
44b0			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
44b0			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
44b0			; | | or completely different file system structure. 
44b0			 
44b0					if DEBUG_FORTH_WORDS_KEY 
44b0						DMARK "BUD" 
44b0 f5				push af  
44b1 3a c5 44			ld a, (.dmark)  
44b4 32 bd fb			ld (debug_mark),a  
44b7 3a c6 44			ld a, (.dmark+1)  
44ba 32 be fb			ld (debug_mark+1),a  
44bd 3a c7 44			ld a, (.dmark+2)  
44c0 32 bf fb			ld (debug_mark+2),a  
44c3 18 03			jr .pastdmark  
44c5 ..			.dmark: db "BUD"  
44c8 f1			.pastdmark: pop af  
44c9			endm  
# End of macro DMARK
44c9						CALLMONITOR 
44c9 cd d4 14			call break_point_state  
44cc				endm  
# End of macro CALLMONITOR
44cc					endif 
44cc			 
44cc				FORTH_DSP_VALUEHL 
44cc cd 09 1b			call macro_dsp_valuehl 
44cf				endm 
# End of macro FORTH_DSP_VALUEHL
44cf			 
44cf				; calc block address 
44cf			 
44cf eb				ex de, hl 
44d0 3e 40			ld a, STORE_BLOCK_PHY 
44d2 cd 3f 0c			call Mult16 
44d5			 
44d5				FORTH_DSP_POP 
44d5 cd a5 1b			call macro_forth_dsp_pop 
44d8				endm 
# End of macro FORTH_DSP_POP
44d8			 
44d8			 
44d8 11 e8 f9			ld de, store_page 
44db			 
44db					if DEBUG_FORTH_WORDS 
44db						DMARK "BUe" 
44db f5				push af  
44dc 3a f0 44			ld a, (.dmark)  
44df 32 bd fb			ld (debug_mark),a  
44e2 3a f1 44			ld a, (.dmark+1)  
44e5 32 be fb			ld (debug_mark+1),a  
44e8 3a f2 44			ld a, (.dmark+2)  
44eb 32 bf fb			ld (debug_mark+2),a  
44ee 18 03			jr .pastdmark  
44f0 ..			.dmark: db "BUe"  
44f3 f1			.pastdmark: pop af  
44f4			endm  
# End of macro DMARK
44f4						CALLMONITOR 
44f4 cd d4 14			call break_point_state  
44f7				endm  
# End of macro CALLMONITOR
44f7					endif 
44f7			 
44f7 cd 6e 03			call storage_write_block 
44fa			 
44fa					NEXTW 
44fa c3 5f 1c			jp macro_next 
44fd				endm 
# End of macro NEXTW
44fd			 
44fd			.BYID: 
44fd			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
44fd			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
44fd			; 
44fd			;		 
44fd			;		if DEBUG_FORTH_WORDS_KEY 
44fd			;			DMARK "BYID" 
44fd			;			CALLMONITOR 
44fd			;		endif 
44fd			; 
44fd			;		; get direct address 
44fd			; 
44fd			;		FORTH_DSP_VALUEHL 
44fd			; 
44fd			;		FORTH_DSP_POP 
44fd			; 
44fd			;	; calc block address 
44fd			; 
44fd			;	ex de, hl 
44fd			;	ld a, STORE_BLOCK_PHY 
44fd			;	call Mult16 
44fd			;	;	do BREAD with number as param 
44fd			;	; push the file name	 
44fd			;	ld de, store_page 
44fd			;	call storage_read_block 
44fd			 ;       ld hl, store_page+2 
44fd			; 
44fd			; 
44fd			;		NEXTW 
44fd			;.BYNAME: 
44fd			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
44fd			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
44fd			;		NEXTW 
44fd			; 
44fd			.DIR: 
44fd				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
44fd 3a				db WORD_SYS_CORE+38             
44fe 01 46			dw .SAVE            
4500 04				db 3 + 1 
4501 .. 00			db "DIR",0              
4505				endm 
# End of macro CWHEAD
4505			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4505			 
4505					if DEBUG_FORTH_WORDS_KEY 
4505						DMARK "DIR" 
4505 f5				push af  
4506 3a 1a 45			ld a, (.dmark)  
4509 32 bd fb			ld (debug_mark),a  
450c 3a 1b 45			ld a, (.dmark+1)  
450f 32 be fb			ld (debug_mark+1),a  
4512 3a 1c 45			ld a, (.dmark+2)  
4515 32 bf fb			ld (debug_mark+2),a  
4518 18 03			jr .pastdmark  
451a ..			.dmark: db "DIR"  
451d f1			.pastdmark: pop af  
451e			endm  
# End of macro DMARK
451e						CALLMONITOR 
451e cd d4 14			call break_point_state  
4521				endm  
# End of macro CALLMONITOR
4521					endif 
4521 cd ba 03			call storage_get_block_0 
4524			 
4524 21 e8 f9			ld hl, store_page     ; get current id count 
4527 46				ld b, (hl) 
4528 0e 00			ld c, 0    ; count of files   
452a					if DEBUG_FORTH_WORDS 
452a						DMARK "DI1" 
452a f5				push af  
452b 3a 3f 45			ld a, (.dmark)  
452e 32 bd fb			ld (debug_mark),a  
4531 3a 40 45			ld a, (.dmark+1)  
4534 32 be fb			ld (debug_mark+1),a  
4537 3a 41 45			ld a, (.dmark+2)  
453a 32 bf fb			ld (debug_mark+2),a  
453d 18 03			jr .pastdmark  
453f ..			.dmark: db "DI1"  
4542 f1			.pastdmark: pop af  
4543			endm  
# End of macro DMARK
4543						CALLMONITOR 
4543 cd d4 14			call break_point_state  
4546				endm  
# End of macro CALLMONITOR
4546					endif 
4546			 
4546				; check for empty drive 
4546			 
4546 3e 00			ld a, 0 
4548 b8				cp b 
4549 ca b7 45			jp z, .dirdone 
454c			 
454c				; for each of the current ids do a search for them and if found push to stack 
454c			 
454c c5			.diritem:	push bc 
454d 21 40 00				ld hl, STORE_BLOCK_PHY 
4550 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4552 58					ld e,b 
4553			 
4553			;		if DEBUG_FORTH_WORDS 
4553			;			DMARK "DI2" 
4553			;			CALLMONITOR 
4553			;		endif 
4553			 
4553 cd 1f 06				call storage_findnextid 
4556			 
4556			;		if DEBUG_FORTH_WORDS 
4556			;			DMARK "DI3" 
4556			;			CALLMONITOR 
4556			;		endif 
4556			 
4556					; if found hl will be non zero 
4556			 
4556 cd e5 0c				call ishlzero 
4559			;		ld a, l 
4559			;		add h 
4559			; 
4559			;		cp 0 
4559 28 59				jr z, .dirnotfound 
455b			 
455b					; increase count 
455b			 
455b c1					pop bc	 
455c 0c					inc c 
455d c5					push bc 
455e					 
455e			 
455e					; get file header and push the file name 
455e			 
455e 11 e8 f9				ld de, store_page 
4561 cd 09 03				call storage_read_block 
4564			 
4564					; push file id to stack 
4564				 
4564 3a e8 f9				ld a, (store_page) 
4567 26 00				ld h, 0 
4569 6f					ld l, a 
456a cd 6e 1a				call forth_push_numhl 
456d			 
456d					; push extent count to stack  
456d				 
456d 3a ea f9				ld a, (store_page+2) 
4570 26 00				ld h, 0 
4572 6f					ld l, a 
4573 cd 6e 1a				call forth_push_numhl 
4576			 
4576					; push file name 
4576			 
4576 21 eb f9				ld hl, store_page+3 
4579					if DEBUG_FORTH_WORDS 
4579						DMARK "DI5" 
4579 f5				push af  
457a 3a 8e 45			ld a, (.dmark)  
457d 32 bd fb			ld (debug_mark),a  
4580 3a 8f 45			ld a, (.dmark+1)  
4583 32 be fb			ld (debug_mark+1),a  
4586 3a 90 45			ld a, (.dmark+2)  
4589 32 bf fb			ld (debug_mark+2),a  
458c 18 03			jr .pastdmark  
458e ..			.dmark: db "DI5"  
4591 f1			.pastdmark: pop af  
4592			endm  
# End of macro DMARK
4592						CALLMONITOR 
4592 cd d4 14			call break_point_state  
4595				endm  
# End of macro CALLMONITOR
4595					endif 
4595 cd 80 1a				call forth_push_str 
4598					if DEBUG_FORTH_WORDS 
4598						DMARK "DI6" 
4598 f5				push af  
4599 3a ad 45			ld a, (.dmark)  
459c 32 bd fb			ld (debug_mark),a  
459f 3a ae 45			ld a, (.dmark+1)  
45a2 32 be fb			ld (debug_mark+1),a  
45a5 3a af 45			ld a, (.dmark+2)  
45a8 32 bf fb			ld (debug_mark+2),a  
45ab 18 03			jr .pastdmark  
45ad ..			.dmark: db "DI6"  
45b0 f1			.pastdmark: pop af  
45b1			endm  
# End of macro DMARK
45b1						CALLMONITOR 
45b1 cd d4 14			call break_point_state  
45b4				endm  
# End of macro CALLMONITOR
45b4					endif 
45b4			.dirnotfound: 
45b4 c1					pop bc     
45b5 10 95				djnz .diritem 
45b7				 
45b7			.dirdone:	 
45b7					if DEBUG_FORTH_WORDS 
45b7						DMARK "DI7" 
45b7 f5				push af  
45b8 3a cc 45			ld a, (.dmark)  
45bb 32 bd fb			ld (debug_mark),a  
45be 3a cd 45			ld a, (.dmark+1)  
45c1 32 be fb			ld (debug_mark+1),a  
45c4 3a ce 45			ld a, (.dmark+2)  
45c7 32 bf fb			ld (debug_mark+2),a  
45ca 18 03			jr .pastdmark  
45cc ..			.dmark: db "DI7"  
45cf f1			.pastdmark: pop af  
45d0			endm  
# End of macro DMARK
45d0						CALLMONITOR 
45d0 cd d4 14			call break_point_state  
45d3				endm  
# End of macro CALLMONITOR
45d3					endif 
45d3			 
45d3					; push a count of the dir items found 
45d3			 
45d3 26 00				ld h, 0 
45d5 69					ld l, c 
45d6 cd 6e 1a				call forth_push_numhl 
45d9			 
45d9					; push the bank label 
45d9			 
45d9 cd ba 03				call storage_get_block_0 
45dc			 
45dc				 
45dc 21 eb f9		 		ld hl, store_page+3 
45df			 
45df					if DEBUG_FORTH_WORDS 
45df						DMARK "DI8" 
45df f5				push af  
45e0 3a f4 45			ld a, (.dmark)  
45e3 32 bd fb			ld (debug_mark),a  
45e6 3a f5 45			ld a, (.dmark+1)  
45e9 32 be fb			ld (debug_mark+1),a  
45ec 3a f6 45			ld a, (.dmark+2)  
45ef 32 bf fb			ld (debug_mark+2),a  
45f2 18 03			jr .pastdmark  
45f4 ..			.dmark: db "DI8"  
45f7 f1			.pastdmark: pop af  
45f8			endm  
# End of macro DMARK
45f8						CALLMONITOR 
45f8 cd d4 14			call break_point_state  
45fb				endm  
# End of macro CALLMONITOR
45fb					endif 
45fb cd 80 1a				call forth_push_str 
45fe			 
45fe			 
45fe				 
45fe					NEXTW 
45fe c3 5f 1c			jp macro_next 
4601				endm 
# End of macro NEXTW
4601			.SAVE: 
4601			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4601			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4601			;		NEXTW 
4601			;.LOAD: 
4601			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4601			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4601			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4601			;; > > The LOAD command can not be used in any user words or compound lines. 
4601			; 
4601			;		; store_openext use it. If zero it is EOF 
4601			; 
4601			;		; read block from current stream id 
4601			;		; if the block does not contain zero term keep reading blocks until zero found 
4601			;		; push the block to stack 
4601			;		; save the block id to stream 
4601			; 
4601			; 
4601			;		FORTH_DSP_VALUEHL 
4601			; 
4601			;;		push hl 
4601			; 
4601			;	if DEBUG_STORESE 
4601			;		DMARK "LOA" 
4601			;		CALLMONITOR 
4601			;	endif 
4601			;		FORTH_DSP_POP 
4601			; 
4601			;;		pop hl 
4601			; 
4601			;		ld h, l 
4601			;		ld l, 0 
4601			; 
4601			;		push hl     ; stack holds current file id and extent to work with 
4601			; 
4601			; 
4601			;		ld de, store_page      ; get block zero of file 
4601			;	if DEBUG_STORESE 
4601			;		DMARK "LO0" 
4601			;		CALLMONITOR 
4601			;	endif 
4601			;		call storage_read 
4601			; 
4601			;		ld a, (store_page+2)    ; max extents for this file 
4601			;		ld  (store_openmaxext),a   ; get our limit 
4601			; 
4601			;	if DEBUG_STORESE 
4601			;		DMARK "LOE" 
4601			;		CALLMONITOR 
4601			;	endif 
4601			; 
4601			;; TODO dont know why max extents are not present 
4601			;;		cp 0 
4601			;;		jp z, .loadeof     ; dont read past eof 
4601			; 
4601			;;		ld a, 1   ; start from the head of the file 
4601			; 
4601			;.loadline:	pop hl 
4601			;		inc hl 
4601			;		ld  a, (store_openmaxext)   ; get our limit 
4601			;	if DEBUG_STORESE 
4601			;		DMARK "LOx" 
4601			;		CALLMONITOR 
4601			;	endif 
4601			;		inc a 
4601			;		cp l 
4601			;		jp z, .loadeof 
4601			;		push hl    ; save current extent 
4601			; 
4601			;		ld de, store_page 
4601			; 
4601			;	if DEBUG_STORESE 
4601			;		DMARK "LO1" 
4601			;		CALLMONITOR 
4601			;	endif 
4601			;		call storage_read 
4601			; 
4601			;	if DEBUG_STORESE 
4601			;		DMARK "LO2" 
4601			;		CALLMONITOR 
4601			;	endif 
4601			;	call ishlzero 
4601			;	ld a, l 
4601			;	add h 
4601			;	cp 0 
4601			;	jr z, .loadeof 
4601			; 
4601			;	; not eof so hl should point to data to exec 
4601			; 
4601			;	; will need to add the FORTH_END_BUFFER flag 
4601			 ; 
4601			;	ld hl, store_page+2 
4601			;	ld bc, 255 
4601			;	ld a, 0 
4601			;	cpir 
4601			;	if DEBUG_STORESE 
4601			;		DMARK "LOt" 
4601			;		CALLMONITOR 
4601			;	endif 
4601			;	dec hl 
4601			;	ld a, ' ' 
4601			;	ld (hl), a 
4601			;	inc hl 
4601			;	ld (hl), a 
4601			;	inc hl 
4601			;	ld (hl), a 
4601			;	inc hl 
4601			;	ld a, FORTH_END_BUFFER 
4601			;	ld (hl), a 
4601			; 
4601			;	; TODO handle more than a single block read 
4601			; 
4601			; 
4601			;	ld hl, store_page+2 
4601			; 
4601			;	ld (os_tok_ptr), hl 
4601			; 
4601			;	if DEBUG_STORESE 
4601			;		DMARK "LO3" 
4601			;		CALLMONITOR 
4601			;	endif 
4601			; 
4601			;	call forthparse 
4601			;	call forthexec 
4601			;	call forthexec_cleanup 
4601			; 
4601			;	; go to next extent 
4601			; 
4601			;	; get next block  or mark as eof 
4601			;	jp .loadline 
4601			; 
4601			; 
4601			; 
4601			;	       NEXTW 
4601			;.loadeof:	ld a, 0 
4601			;		ld (store_openext), a 
4601			; 
4601			;	if DEBUG_STORESE 
4601			;		DMARK "LOF" 
4601			;		CALLMONITOR 
4601			;	endif 
4601			;		ret 
4601			;		;NEXTW 
4601			;.BSAVE:   
4601			; 
4601			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4601			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4601			;		NEXTW 
4601			;.BLOAD: 
4601			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4601			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4601			;		NEXTW 
4601			;;;; counter gap 
4601			 
4601			 
4601			.SEO: 
4601				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4601 64				db WORD_SYS_CORE+80             
4602 20 46			dw .SEI            
4604 04				db 3 + 1 
4605 .. 00			db "SEO",0              
4609				endm 
# End of macro CWHEAD
4609			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4609			 
4609					; get port 
4609			 
4609					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4609 cd 09 1b			call macro_dsp_valuehl 
460c				endm 
# End of macro FORTH_DSP_VALUEHL
460c			 
460c e5					push hl    ; u2 - byte 
460d			 
460d					; destroy value TOS 
460d			 
460d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
460d cd a5 1b			call macro_forth_dsp_pop 
4610				endm 
# End of macro FORTH_DSP_POP
4610			 
4610					; get byte to send 
4610			 
4610					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4610 cd 09 1b			call macro_dsp_valuehl 
4613				endm 
# End of macro FORTH_DSP_VALUEHL
4613			 
4613 e5					push hl    ; u1 - addr 
4614			 
4614					; destroy value TOS 
4614			 
4614					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4614 cd a5 1b			call macro_forth_dsp_pop 
4617				endm 
# End of macro FORTH_DSP_POP
4617			 
4617					; one value on hl get other one back 
4617			 
4617 d1					pop de   ; u1 - byte 
4618			 
4618 e1					pop hl   ; u2 - addr 
4619			 
4619					; TODO Send SPI byte 
4619			 
4619			 
4619 7b					ld a, e 
461a cd e7 01				call se_writebyte 
461d			 
461d					 
461d			 
461d					NEXTW 
461d c3 5f 1c			jp macro_next 
4620				endm 
# End of macro NEXTW
4620			 
4620			.SEI: 
4620				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4620 65				db WORD_SYS_CORE+81             
4621 3a 46			dw .SFREE            
4623 04				db 3 + 1 
4624 .. 00			db "SEI",0              
4628				endm 
# End of macro CWHEAD
4628			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4628			 
4628					; get port 
4628			 
4628					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4628 cd 09 1b			call macro_dsp_valuehl 
462b				endm 
# End of macro FORTH_DSP_VALUEHL
462b			 
462b			;		push hl 
462b			 
462b					; destroy value TOS 
462b			 
462b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
462b cd a5 1b			call macro_forth_dsp_pop 
462e				endm 
# End of macro FORTH_DSP_POP
462e			 
462e					; one value on hl get other one back 
462e			 
462e			;		pop hl 
462e			 
462e			 
462e					; TODO Get SPI byte 
462e			 
462e cd 89 02				call se_readbyte 
4631			 
4631 26 00				ld h, 0 
4633 6f					ld l, a 
4634 cd 6e 1a				call forth_push_numhl 
4637			 
4637					NEXTW 
4637 c3 5f 1c			jp macro_next 
463a				endm 
# End of macro NEXTW
463a			 
463a			.SFREE: 
463a				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
463a 67				db WORD_SYS_CORE+83             
463b 69 46			dw .SIZE            
463d 06				db 5 + 1 
463e .. 00			db "FFREE",0              
4644				endm 
# End of macro CWHEAD
4644			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4644					if DEBUG_FORTH_WORDS_KEY 
4644						DMARK "FFR" 
4644 f5				push af  
4645 3a 59 46			ld a, (.dmark)  
4648 32 bd fb			ld (debug_mark),a  
464b 3a 5a 46			ld a, (.dmark+1)  
464e 32 be fb			ld (debug_mark+1),a  
4651 3a 5b 46			ld a, (.dmark+2)  
4654 32 bf fb			ld (debug_mark+2),a  
4657 18 03			jr .pastdmark  
4659 ..			.dmark: db "FFR"  
465c f1			.pastdmark: pop af  
465d			endm  
# End of macro DMARK
465d						CALLMONITOR 
465d cd d4 14			call break_point_state  
4660				endm  
# End of macro CALLMONITOR
4660					endif 
4660			 
4660 cd b9 06				call storage_freeblocks 
4663			 
4663 cd 6e 1a				call forth_push_numhl 
4666			 
4666				       NEXTW 
4666 c3 5f 1c			jp macro_next 
4669				endm 
# End of macro NEXTW
4669			.SIZE: 
4669				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4669 67				db WORD_SYS_CORE+83             
466a 9d 46			dw .CREATE            
466c 05				db 4 + 1 
466d .. 00			db "SIZE",0              
4672				endm 
# End of macro CWHEAD
4672			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4672					if DEBUG_FORTH_WORDS_KEY 
4672						DMARK "SIZ" 
4672 f5				push af  
4673 3a 87 46			ld a, (.dmark)  
4676 32 bd fb			ld (debug_mark),a  
4679 3a 88 46			ld a, (.dmark+1)  
467c 32 be fb			ld (debug_mark+1),a  
467f 3a 89 46			ld a, (.dmark+2)  
4682 32 bf fb			ld (debug_mark+2),a  
4685 18 03			jr .pastdmark  
4687 ..			.dmark: db "SIZ"  
468a f1			.pastdmark: pop af  
468b			endm  
# End of macro DMARK
468b						CALLMONITOR 
468b cd d4 14			call break_point_state  
468e				endm  
# End of macro CALLMONITOR
468e					endif 
468e			 
468e					FORTH_DSP_VALUEHL 
468e cd 09 1b			call macro_dsp_valuehl 
4691				endm 
# End of macro FORTH_DSP_VALUEHL
4691			;		push hl 
4691					FORTH_DSP_POP 
4691 cd a5 1b			call macro_forth_dsp_pop 
4694				endm 
# End of macro FORTH_DSP_POP
4694			;		pop hl 
4694 cd 38 03				call storage_file_size 
4697			 
4697 cd 6e 1a				call forth_push_numhl 
469a			  
469a			 
469a				       NEXTW 
469a c3 5f 1c			jp macro_next 
469d				endm 
# End of macro NEXTW
469d			 
469d			.CREATE: 
469d				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
469d 68				db WORD_SYS_CORE+84             
469e 0b 47			dw .APPEND            
46a0 07				db 6 + 1 
46a1 .. 00			db "CREATE",0              
46a8				endm 
# End of macro CWHEAD
46a8			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
46a8			; | | e.g.  
46a8			; | | TestProgram CREATE 
46a8			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
46a8			; | |  
46a8			; | | Max file IDs are 255. 
46a8			; | |  
46a8					 
46a8					if DEBUG_FORTH_WORDS_KEY 
46a8						DMARK "CRT" 
46a8 f5				push af  
46a9 3a bd 46			ld a, (.dmark)  
46ac 32 bd fb			ld (debug_mark),a  
46af 3a be 46			ld a, (.dmark+1)  
46b2 32 be fb			ld (debug_mark+1),a  
46b5 3a bf 46			ld a, (.dmark+2)  
46b8 32 bf fb			ld (debug_mark+2),a  
46bb 18 03			jr .pastdmark  
46bd ..			.dmark: db "CRT"  
46c0 f1			.pastdmark: pop af  
46c1			endm  
# End of macro DMARK
46c1						CALLMONITOR 
46c1 cd d4 14			call break_point_state  
46c4				endm  
# End of macro CALLMONITOR
46c4					endif 
46c4			;		call storage_get_block_0 
46c4			 
46c4					; TODO pop hl 
46c4			 
46c4					;v5 FORTH_DSP_VALUE 
46c4					FORTH_DSP_VALUE 
46c4 cd f2 1a			call macro_forth_dsp_value 
46c7				endm 
# End of macro FORTH_DSP_VALUE
46c7			 
46c7				if DEBUG_STORESE 
46c7					DMARK "CR1" 
46c7 f5				push af  
46c8 3a dc 46			ld a, (.dmark)  
46cb 32 bd fb			ld (debug_mark),a  
46ce 3a dd 46			ld a, (.dmark+1)  
46d1 32 be fb			ld (debug_mark+1),a  
46d4 3a de 46			ld a, (.dmark+2)  
46d7 32 bf fb			ld (debug_mark+2),a  
46da 18 03			jr .pastdmark  
46dc ..			.dmark: db "CR1"  
46df f1			.pastdmark: pop af  
46e0			endm  
# End of macro DMARK
46e0					CALLMONITOR 
46e0 cd d4 14			call break_point_state  
46e3				endm  
# End of macro CALLMONITOR
46e3				endif 
46e3			;		push hl 
46e3			;		FORTH_DSP_POP 
46e3			;		pop hl 
46e3			 
46e3			;		inc hl   ; move past the type marker 
46e3			 
46e3 cd ef 06				call storage_create 
46e6			 
46e6				if DEBUG_STORESE 
46e6					DMARK "CT1" 
46e6 f5				push af  
46e7 3a fb 46			ld a, (.dmark)  
46ea 32 bd fb			ld (debug_mark),a  
46ed 3a fc 46			ld a, (.dmark+1)  
46f0 32 be fb			ld (debug_mark+1),a  
46f3 3a fd 46			ld a, (.dmark+2)  
46f6 32 bf fb			ld (debug_mark+2),a  
46f9 18 03			jr .pastdmark  
46fb ..			.dmark: db "CT1"  
46fe f1			.pastdmark: pop af  
46ff			endm  
# End of macro DMARK
46ff					CALLMONITOR 
46ff cd d4 14			call break_point_state  
4702				endm  
# End of macro CALLMONITOR
4702				endif 
4702			;		push hl 
4702					FORTH_DSP_POP 
4702 cd a5 1b			call macro_forth_dsp_pop 
4705				endm 
# End of macro FORTH_DSP_POP
4705			;		pop hl 
4705					; push file id to stack 
4705 cd 6e 1a				call forth_push_numhl 
4708			 
4708			 
4708			 
4708				       NEXTW 
4708 c3 5f 1c			jp macro_next 
470b				endm 
# End of macro NEXTW
470b			 
470b			.APPEND: 
470b				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
470b 69				db WORD_SYS_CORE+85             
470c 9c 47			dw .SDEL            
470e 07				db 6 + 1 
470f .. 00			db "APPEND",0              
4716				endm 
# End of macro CWHEAD
4716			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4716			; | | e.g. 
4716			; | | Test CREATE      -> $01 
4716			; | | "A string to add to file" $01 APPEND 
4716			; | |  
4716			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4716					if DEBUG_FORTH_WORDS_KEY 
4716						DMARK "APP" 
4716 f5				push af  
4717 3a 2b 47			ld a, (.dmark)  
471a 32 bd fb			ld (debug_mark),a  
471d 3a 2c 47			ld a, (.dmark+1)  
4720 32 be fb			ld (debug_mark+1),a  
4723 3a 2d 47			ld a, (.dmark+2)  
4726 32 bf fb			ld (debug_mark+2),a  
4729 18 03			jr .pastdmark  
472b ..			.dmark: db "APP"  
472e f1			.pastdmark: pop af  
472f			endm  
# End of macro DMARK
472f						CALLMONITOR 
472f cd d4 14			call break_point_state  
4732				endm  
# End of macro CALLMONITOR
4732					endif 
4732			 
4732					FORTH_DSP_VALUEHL 
4732 cd 09 1b			call macro_dsp_valuehl 
4735				endm 
# End of macro FORTH_DSP_VALUEHL
4735 e5					push hl 	; save file id 
4736			 
4736				if DEBUG_STORESE 
4736					DMARK "AP1" 
4736 f5				push af  
4737 3a 4b 47			ld a, (.dmark)  
473a 32 bd fb			ld (debug_mark),a  
473d 3a 4c 47			ld a, (.dmark+1)  
4740 32 be fb			ld (debug_mark+1),a  
4743 3a 4d 47			ld a, (.dmark+2)  
4746 32 bf fb			ld (debug_mark+2),a  
4749 18 03			jr .pastdmark  
474b ..			.dmark: db "AP1"  
474e f1			.pastdmark: pop af  
474f			endm  
# End of macro DMARK
474f					CALLMONITOR 
474f cd d4 14			call break_point_state  
4752				endm  
# End of macro CALLMONITOR
4752				endif 
4752					FORTH_DSP_POP 
4752 cd a5 1b			call macro_forth_dsp_pop 
4755				endm 
# End of macro FORTH_DSP_POP
4755			 
4755					FORTH_DSP_VALUEHL 
4755 cd 09 1b			call macro_dsp_valuehl 
4758				endm 
# End of macro FORTH_DSP_VALUEHL
4758					;v5 FORTH_DSP_VALUE 
4758 e5					push hl 	; save ptr to string to save 
4759			 
4759				if DEBUG_STORESE 
4759					DMARK "AP1" 
4759 f5				push af  
475a 3a 6e 47			ld a, (.dmark)  
475d 32 bd fb			ld (debug_mark),a  
4760 3a 6f 47			ld a, (.dmark+1)  
4763 32 be fb			ld (debug_mark+1),a  
4766 3a 70 47			ld a, (.dmark+2)  
4769 32 bf fb			ld (debug_mark+2),a  
476c 18 03			jr .pastdmark  
476e ..			.dmark: db "AP1"  
4771 f1			.pastdmark: pop af  
4772			endm  
# End of macro DMARK
4772					CALLMONITOR 
4772 cd d4 14			call break_point_state  
4775				endm  
# End of macro CALLMONITOR
4775				endif 
4775					FORTH_DSP_POP 
4775 cd a5 1b			call macro_forth_dsp_pop 
4778				endm 
# End of macro FORTH_DSP_POP
4778			 
4778 d1					pop de 
4779 e1					pop hl 
477a				if DEBUG_STORESE 
477a					DMARK "AP2" 
477a f5				push af  
477b 3a 8f 47			ld a, (.dmark)  
477e 32 bd fb			ld (debug_mark),a  
4781 3a 90 47			ld a, (.dmark+1)  
4784 32 be fb			ld (debug_mark+1),a  
4787 3a 91 47			ld a, (.dmark+2)  
478a 32 bf fb			ld (debug_mark+2),a  
478d 18 03			jr .pastdmark  
478f ..			.dmark: db "AP2"  
4792 f1			.pastdmark: pop af  
4793			endm  
# End of macro DMARK
4793					CALLMONITOR 
4793 cd d4 14			call break_point_state  
4796				endm  
# End of macro CALLMONITOR
4796				endif 
4796					;inc de ; skip var type indicator 
4796			 
4796					; TODO how to append numerics???? 
4796			 
4796 cd c9 08				call storage_append		 
4799			 
4799				       NEXTW 
4799 c3 5f 1c			jp macro_next 
479c				endm 
# End of macro NEXTW
479c			.SDEL: 
479c				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
479c 6a				db WORD_SYS_CORE+86             
479d e8 47			dw .OPEN            
479f 05				db 4 + 1 
47a0 .. 00			db "ERA",0              
47a4				endm 
# End of macro CWHEAD
47a4			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
47a4					FORTH_DSP_VALUEHL 
47a4 cd 09 1b			call macro_dsp_valuehl 
47a7				endm 
# End of macro FORTH_DSP_VALUEHL
47a7			;		push hl 	; save file id 
47a7			 
47a7					if DEBUG_FORTH_WORDS_KEY 
47a7						DMARK "ERA" 
47a7 f5				push af  
47a8 3a bc 47			ld a, (.dmark)  
47ab 32 bd fb			ld (debug_mark),a  
47ae 3a bd 47			ld a, (.dmark+1)  
47b1 32 be fb			ld (debug_mark+1),a  
47b4 3a be 47			ld a, (.dmark+2)  
47b7 32 bf fb			ld (debug_mark+2),a  
47ba 18 03			jr .pastdmark  
47bc ..			.dmark: db "ERA"  
47bf f1			.pastdmark: pop af  
47c0			endm  
# End of macro DMARK
47c0						CALLMONITOR 
47c0 cd d4 14			call break_point_state  
47c3				endm  
# End of macro CALLMONITOR
47c3					endif 
47c3				if DEBUG_STORESE 
47c3					DMARK "ER1" 
47c3 f5				push af  
47c4 3a d8 47			ld a, (.dmark)  
47c7 32 bd fb			ld (debug_mark),a  
47ca 3a d9 47			ld a, (.dmark+1)  
47cd 32 be fb			ld (debug_mark+1),a  
47d0 3a da 47			ld a, (.dmark+2)  
47d3 32 bf fb			ld (debug_mark+2),a  
47d6 18 03			jr .pastdmark  
47d8 ..			.dmark: db "ER1"  
47db f1			.pastdmark: pop af  
47dc			endm  
# End of macro DMARK
47dc					CALLMONITOR 
47dc cd d4 14			call break_point_state  
47df				endm  
# End of macro CALLMONITOR
47df				endif 
47df					FORTH_DSP_POP 
47df cd a5 1b			call macro_forth_dsp_pop 
47e2				endm 
# End of macro FORTH_DSP_POP
47e2			 
47e2			;		pop hl 
47e2			 
47e2 cd 3e 05				call storage_erase 
47e5				       NEXTW 
47e5 c3 5f 1c			jp macro_next 
47e8				endm 
# End of macro NEXTW
47e8			 
47e8			.OPEN: 
47e8				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
47e8 6b				db WORD_SYS_CORE+87             
47e9 6f 48			dw .READ            
47eb 05				db 4 + 1 
47ec .. 00			db "OPEN",0              
47f1				endm 
# End of macro CWHEAD
47f1			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
47f1			; | | e.g. 
47f1			; | | $01 OPEN $01 DO $01 READ . LOOP 
47f1			 
47f1					if DEBUG_FORTH_WORDS_KEY 
47f1						DMARK "OPN" 
47f1 f5				push af  
47f2 3a 06 48			ld a, (.dmark)  
47f5 32 bd fb			ld (debug_mark),a  
47f8 3a 07 48			ld a, (.dmark+1)  
47fb 32 be fb			ld (debug_mark+1),a  
47fe 3a 08 48			ld a, (.dmark+2)  
4801 32 bf fb			ld (debug_mark+2),a  
4804 18 03			jr .pastdmark  
4806 ..			.dmark: db "OPN"  
4809 f1			.pastdmark: pop af  
480a			endm  
# End of macro DMARK
480a						CALLMONITOR 
480a cd d4 14			call break_point_state  
480d				endm  
# End of macro CALLMONITOR
480d					endif 
480d					; TODO handle multiple file opens 
480d			 
480d 3e 01			       	ld a, 1 
480f 32 df f9				ld (store_openext), a 
4812			 
4812					; get max extents for this file 
4812				 
4812								 
4812					FORTH_DSP_VALUEHL 
4812 cd 09 1b			call macro_dsp_valuehl 
4815				endm 
# End of macro FORTH_DSP_VALUEHL
4815			 
4815 65					ld h, l 
4816 2e 00				ld l, 0 
4818			 
4818				if DEBUG_STORESE 
4818					DMARK "OPN" 
4818 f5				push af  
4819 3a 2d 48			ld a, (.dmark)  
481c 32 bd fb			ld (debug_mark),a  
481f 3a 2e 48			ld a, (.dmark+1)  
4822 32 be fb			ld (debug_mark+1),a  
4825 3a 2f 48			ld a, (.dmark+2)  
4828 32 bf fb			ld (debug_mark+2),a  
482b 18 03			jr .pastdmark  
482d ..			.dmark: db "OPN"  
4830 f1			.pastdmark: pop af  
4831			endm  
# End of macro DMARK
4831					CALLMONITOR 
4831 cd d4 14			call break_point_state  
4834				endm  
# End of macro CALLMONITOR
4834				endif 
4834			;		push hl 
4834					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4834 cd a5 1b			call macro_forth_dsp_pop 
4837				endm 
# End of macro FORTH_DSP_POP
4837			;		pop hl 
4837						 
4837 11 e8 f9				ld de, store_page      ; get block zero of file 
483a cd 43 08				call storage_read 
483d			 
483d			 
483d 3a ea f9				ld a, (store_page+2)    ; max extents for this file 
4840 32 de f9				ld  (store_openmaxext), a   ; get our limit and push 
4843					 
4843				if DEBUG_STORESE 
4843					DMARK "OPx" 
4843 f5				push af  
4844 3a 58 48			ld a, (.dmark)  
4847 32 bd fb			ld (debug_mark),a  
484a 3a 59 48			ld a, (.dmark+1)  
484d 32 be fb			ld (debug_mark+1),a  
4850 3a 5a 48			ld a, (.dmark+2)  
4853 32 bf fb			ld (debug_mark+2),a  
4856 18 03			jr .pastdmark  
4858 ..			.dmark: db "OPx"  
485b f1			.pastdmark: pop af  
485c			endm  
# End of macro DMARK
485c					CALLMONITOR 
485c cd d4 14			call break_point_state  
485f				endm  
# End of macro CALLMONITOR
485f				endif 
485f fe 00				cp 0 
4861 20 03				jr nz, .skipopeneof 
4863					; have opened an empty file 
4863					 
4863 32 df f9				ld (store_openext), a 
4866			 
4866			.skipopeneof: 
4866			 
4866 6f					ld l, a 
4867 26 00				ld h, 0 
4869 cd 6e 1a				call forth_push_numhl 
486c			 
486c			 
486c				       NEXTW 
486c c3 5f 1c			jp macro_next 
486f				endm 
# End of macro NEXTW
486f			.READ: 
486f				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
486f 6c				db WORD_SYS_CORE+88             
4870 b6 49			dw .EOF            
4872 05				db 4 + 1 
4873 .. 00			db "READ",0              
4878				endm 
# End of macro CWHEAD
4878			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4878			; | | e.g. 
4878			; | | $01 OPEN $01 DO $01 READ . LOOP 
4878			 
4878					if DEBUG_FORTH_WORDS_KEY 
4878						DMARK "REA" 
4878 f5				push af  
4879 3a 8d 48			ld a, (.dmark)  
487c 32 bd fb			ld (debug_mark),a  
487f 3a 8e 48			ld a, (.dmark+1)  
4882 32 be fb			ld (debug_mark+1),a  
4885 3a 8f 48			ld a, (.dmark+2)  
4888 32 bf fb			ld (debug_mark+2),a  
488b 18 03			jr .pastdmark  
488d ..			.dmark: db "REA"  
4890 f1			.pastdmark: pop af  
4891			endm  
# End of macro DMARK
4891						CALLMONITOR 
4891 cd d4 14			call break_point_state  
4894				endm  
# End of macro CALLMONITOR
4894					endif 
4894					; store_openext use it. If zero it is EOF 
4894			 
4894					; read block from current stream id 
4894					; if the block does not contain zero term keep reading blocks until zero found 
4894					; push the block to stack 
4894					; save the block id to stream 
4894			 
4894			 
4894					FORTH_DSP_VALUEHL 
4894 cd 09 1b			call macro_dsp_valuehl 
4897				endm 
# End of macro FORTH_DSP_VALUEHL
4897			 
4897			;		push hl 
4897			 
4897				if DEBUG_STORESE 
4897					DMARK "REA" 
4897 f5				push af  
4898 3a ac 48			ld a, (.dmark)  
489b 32 bd fb			ld (debug_mark),a  
489e 3a ad 48			ld a, (.dmark+1)  
48a1 32 be fb			ld (debug_mark+1),a  
48a4 3a ae 48			ld a, (.dmark+2)  
48a7 32 bf fb			ld (debug_mark+2),a  
48aa 18 03			jr .pastdmark  
48ac ..			.dmark: db "REA"  
48af f1			.pastdmark: pop af  
48b0			endm  
# End of macro DMARK
48b0					CALLMONITOR 
48b0 cd d4 14			call break_point_state  
48b3				endm  
# End of macro CALLMONITOR
48b3				endif 
48b3					FORTH_DSP_POP 
48b3 cd a5 1b			call macro_forth_dsp_pop 
48b6				endm 
# End of macro FORTH_DSP_POP
48b6			 
48b6			;		pop hl 
48b6				 
48b6 65					ld h,l 
48b7			 
48b7 3a df f9				ld a, (store_openext) 
48ba 6f					ld l, a 
48bb					 
48bb fe 00				cp 0 
48bd ca 88 49				jp z, .ateof     ; dont read past eof 
48c0			 
48c0			 
48c0 11 e8 f9				ld de, store_page 
48c3				if DEBUG_STORESE 
48c3					DMARK "RE1" 
48c3 f5				push af  
48c4 3a d8 48			ld a, (.dmark)  
48c7 32 bd fb			ld (debug_mark),a  
48ca 3a d9 48			ld a, (.dmark+1)  
48cd 32 be fb			ld (debug_mark+1),a  
48d0 3a da 48			ld a, (.dmark+2)  
48d3 32 bf fb			ld (debug_mark+2),a  
48d6 18 03			jr .pastdmark  
48d8 ..			.dmark: db "RE1"  
48db f1			.pastdmark: pop af  
48dc			endm  
# End of macro DMARK
48dc					CALLMONITOR 
48dc cd d4 14			call break_point_state  
48df				endm  
# End of macro CALLMONITOR
48df				endif 
48df cd 43 08				call storage_read 
48e2			 
48e2				if DEBUG_STORESE 
48e2					DMARK "RE2" 
48e2 f5				push af  
48e3 3a f7 48			ld a, (.dmark)  
48e6 32 bd fb			ld (debug_mark),a  
48e9 3a f8 48			ld a, (.dmark+1)  
48ec 32 be fb			ld (debug_mark+1),a  
48ef 3a f9 48			ld a, (.dmark+2)  
48f2 32 bf fb			ld (debug_mark+2),a  
48f5 18 03			jr .pastdmark  
48f7 ..			.dmark: db "RE2"  
48fa f1			.pastdmark: pop af  
48fb			endm  
# End of macro DMARK
48fb					CALLMONITOR 
48fb cd d4 14			call break_point_state  
48fe				endm  
# End of macro CALLMONITOR
48fe				endif 
48fe cd e5 0c			call ishlzero 
4901			;	ld a, l 
4901			;	add h 
4901			;	cp 0 
4901 ca 8e 49			jp z, .readeof 
4904			 
4904				; not eof so hl should point to data to push to stack 
4904			 
4904				if DEBUG_STORESE 
4904					DMARK "RE3" 
4904 f5				push af  
4905 3a 19 49			ld a, (.dmark)  
4908 32 bd fb			ld (debug_mark),a  
490b 3a 1a 49			ld a, (.dmark+1)  
490e 32 be fb			ld (debug_mark+1),a  
4911 3a 1b 49			ld a, (.dmark+2)  
4914 32 bf fb			ld (debug_mark+2),a  
4917 18 03			jr .pastdmark  
4919 ..			.dmark: db "RE3"  
491c f1			.pastdmark: pop af  
491d			endm  
# End of macro DMARK
491d					CALLMONITOR 
491d cd d4 14			call break_point_state  
4920				endm  
# End of macro CALLMONITOR
4920				endif 
4920 cd 80 1a			call forth_push_str 
4923			 
4923				if DEBUG_STORESE 
4923					DMARK "RE4" 
4923 f5				push af  
4924 3a 38 49			ld a, (.dmark)  
4927 32 bd fb			ld (debug_mark),a  
492a 3a 39 49			ld a, (.dmark+1)  
492d 32 be fb			ld (debug_mark+1),a  
4930 3a 3a 49			ld a, (.dmark+2)  
4933 32 bf fb			ld (debug_mark+2),a  
4936 18 03			jr .pastdmark  
4938 ..			.dmark: db "RE4"  
493b f1			.pastdmark: pop af  
493c			endm  
# End of macro DMARK
493c					CALLMONITOR 
493c cd d4 14			call break_point_state  
493f				endm  
# End of macro CALLMONITOR
493f				endif 
493f				; get next block  or mark as eof 
493f			 
493f 3a de f9			ld a, (store_openmaxext)   ; get our limit 
4942 4f				ld c, a	 
4943 3a df f9			ld a, (store_openext) 
4946			 
4946				if DEBUG_STORESE 
4946					DMARK "RE5" 
4946 f5				push af  
4947 3a 5b 49			ld a, (.dmark)  
494a 32 bd fb			ld (debug_mark),a  
494d 3a 5c 49			ld a, (.dmark+1)  
4950 32 be fb			ld (debug_mark+1),a  
4953 3a 5d 49			ld a, (.dmark+2)  
4956 32 bf fb			ld (debug_mark+2),a  
4959 18 03			jr .pastdmark  
495b ..			.dmark: db "RE5"  
495e f1			.pastdmark: pop af  
495f			endm  
# End of macro DMARK
495f					CALLMONITOR 
495f cd d4 14			call break_point_state  
4962				endm  
# End of macro CALLMONITOR
4962				endif 
4962 b9				cp c 
4963 28 29			jr z, .readeof     ; at last extent 
4965			 
4965 3c					inc a 
4966 32 df f9				ld (store_openext), a 
4969			 
4969				if DEBUG_STORESE 
4969					DMARK "RE6" 
4969 f5				push af  
496a 3a 7e 49			ld a, (.dmark)  
496d 32 bd fb			ld (debug_mark),a  
4970 3a 7f 49			ld a, (.dmark+1)  
4973 32 be fb			ld (debug_mark+1),a  
4976 3a 80 49			ld a, (.dmark+2)  
4979 32 bf fb			ld (debug_mark+2),a  
497c 18 03			jr .pastdmark  
497e ..			.dmark: db "RE6"  
4981 f1			.pastdmark: pop af  
4982			endm  
# End of macro DMARK
4982					CALLMONITOR 
4982 cd d4 14			call break_point_state  
4985				endm  
# End of macro CALLMONITOR
4985				endif 
4985			 
4985			 
4985				       NEXTW 
4985 c3 5f 1c			jp macro_next 
4988				endm 
# End of macro NEXTW
4988			.ateof: 
4988 21 b2 49				ld hl, .showeof 
498b cd 80 1a				call forth_push_str 
498e 3e 00		.readeof:	ld a, 0 
4990 32 df f9				ld (store_openext), a 
4993			 
4993					 
4993				if DEBUG_STORESE 
4993					DMARK "REF" 
4993 f5				push af  
4994 3a a8 49			ld a, (.dmark)  
4997 32 bd fb			ld (debug_mark),a  
499a 3a a9 49			ld a, (.dmark+1)  
499d 32 be fb			ld (debug_mark+1),a  
49a0 3a aa 49			ld a, (.dmark+2)  
49a3 32 bf fb			ld (debug_mark+2),a  
49a6 18 03			jr .pastdmark  
49a8 ..			.dmark: db "REF"  
49ab f1			.pastdmark: pop af  
49ac			endm  
# End of macro DMARK
49ac					CALLMONITOR 
49ac cd d4 14			call break_point_state  
49af				endm  
# End of macro CALLMONITOR
49af				endif 
49af				       NEXTW 
49af c3 5f 1c			jp macro_next 
49b2				endm 
# End of macro NEXTW
49b2			 
49b2 .. 00		.showeof:   db "eof", 0 
49b6			 
49b6			 
49b6			.EOF: 
49b6				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
49b6 6d				db WORD_SYS_CORE+89             
49b7 f7 49			dw .FORMAT            
49b9 04				db 3 + 1 
49ba .. 00			db "EOF",0              
49be				endm 
# End of macro CWHEAD
49be			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
49be			; | | e.g. 
49be			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
49be					; TODO if current block id for stream is zero then push true else false 
49be			 
49be					if DEBUG_FORTH_WORDS_KEY 
49be						DMARK "EOF" 
49be f5				push af  
49bf 3a d3 49			ld a, (.dmark)  
49c2 32 bd fb			ld (debug_mark),a  
49c5 3a d4 49			ld a, (.dmark+1)  
49c8 32 be fb			ld (debug_mark+1),a  
49cb 3a d5 49			ld a, (.dmark+2)  
49ce 32 bf fb			ld (debug_mark+2),a  
49d1 18 03			jr .pastdmark  
49d3 ..			.dmark: db "EOF"  
49d6 f1			.pastdmark: pop af  
49d7			endm  
# End of macro DMARK
49d7						CALLMONITOR 
49d7 cd d4 14			call break_point_state  
49da				endm  
# End of macro CALLMONITOR
49da					endif 
49da			 
49da					; TODO handlue multiple file streams 
49da			 
49da					FORTH_DSP_POP     ; for now just get rid of stream id 
49da cd a5 1b			call macro_forth_dsp_pop 
49dd				endm 
# End of macro FORTH_DSP_POP
49dd			 
49dd 2e 01				ld l, 1 
49df 3a de f9				ld a, (store_openmaxext) 
49e2 fe 00				cp 0 
49e4 28 09				jr  z, .eofdone   ; empty file 
49e6 3a df f9				ld a, (store_openext) 
49e9 fe 00				cp 0 
49eb 28 02				jr  z, .eofdone 
49ed 2e 00				ld l, 0 
49ef 26 00		.eofdone:	ld h, 0 
49f1 cd 6e 1a				call forth_push_numhl 
49f4			 
49f4			 
49f4				       NEXTW 
49f4 c3 5f 1c			jp macro_next 
49f7				endm 
# End of macro NEXTW
49f7			 
49f7			.FORMAT: 
49f7				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
49f7 6d				db WORD_SYS_CORE+89             
49f8 48 4a			dw .LABEL            
49fa 07				db 6 + 1 
49fb .. 00			db "FORMAT",0              
4a02				endm 
# End of macro CWHEAD
4a02			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4a02					; TODO if current block id for stream is zero then push true else false 
4a02				 
4a02				if DEBUG_STORESE 
4a02					DMARK "FOR" 
4a02 f5				push af  
4a03 3a 17 4a			ld a, (.dmark)  
4a06 32 bd fb			ld (debug_mark),a  
4a09 3a 18 4a			ld a, (.dmark+1)  
4a0c 32 be fb			ld (debug_mark+1),a  
4a0f 3a 19 4a			ld a, (.dmark+2)  
4a12 32 bf fb			ld (debug_mark+2),a  
4a15 18 03			jr .pastdmark  
4a17 ..			.dmark: db "FOR"  
4a1a f1			.pastdmark: pop af  
4a1b			endm  
# End of macro DMARK
4a1b					CALLMONITOR 
4a1b cd d4 14			call break_point_state  
4a1e				endm  
# End of macro CALLMONITOR
4a1e				endif 
4a1e					; Wipes the bank check flags to cause a reformat on next block 0 read 
4a1e			 
4a1e 21 01 00				ld hl, 1 
4a21 3e 00				ld a, 0 
4a23 cd e7 01				call se_writebyte 
4a26			 
4a26				if DEBUG_STORESE 
4a26					DMARK "FO0" 
4a26 f5				push af  
4a27 3a 3b 4a			ld a, (.dmark)  
4a2a 32 bd fb			ld (debug_mark),a  
4a2d 3a 3c 4a			ld a, (.dmark+1)  
4a30 32 be fb			ld (debug_mark+1),a  
4a33 3a 3d 4a			ld a, (.dmark+2)  
4a36 32 bf fb			ld (debug_mark+2),a  
4a39 18 03			jr .pastdmark  
4a3b ..			.dmark: db "FO0"  
4a3e f1			.pastdmark: pop af  
4a3f			endm  
# End of macro DMARK
4a3f					CALLMONITOR 
4a3f cd d4 14			call break_point_state  
4a42				endm  
# End of macro CALLMONITOR
4a42				endif 
4a42					; force bank init 
4a42			 
4a42 cd ba 03				call storage_get_block_0 
4a45					 
4a45				       NEXTW 
4a45 c3 5f 1c			jp macro_next 
4a48				endm 
# End of macro NEXTW
4a48			.LABEL: 
4a48				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4a48 6d				db WORD_SYS_CORE+89             
4a49 96 4a			dw .STOREPAGE            
4a4b 06				db 5 + 1 
4a4c .. 00			db "LABEL",0              
4a52				endm 
# End of macro CWHEAD
4a52			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4a52					; TODO test to see if bank is selected 
4a52				 
4a52					if DEBUG_FORTH_WORDS_KEY 
4a52						DMARK "LBL" 
4a52 f5				push af  
4a53 3a 67 4a			ld a, (.dmark)  
4a56 32 bd fb			ld (debug_mark),a  
4a59 3a 68 4a			ld a, (.dmark+1)  
4a5c 32 be fb			ld (debug_mark+1),a  
4a5f 3a 69 4a			ld a, (.dmark+2)  
4a62 32 bf fb			ld (debug_mark+2),a  
4a65 18 03			jr .pastdmark  
4a67 ..			.dmark: db "LBL"  
4a6a f1			.pastdmark: pop af  
4a6b			endm  
# End of macro DMARK
4a6b						CALLMONITOR 
4a6b cd d4 14			call break_point_state  
4a6e				endm  
# End of macro CALLMONITOR
4a6e					endif 
4a6e			;	if DEBUG_STORESE 
4a6e			;		DMARK "LBL" 
4a6e			;		CALLMONITOR 
4a6e			;	endif 
4a6e					FORTH_DSP_VALUEHL 
4a6e cd 09 1b			call macro_dsp_valuehl 
4a71				endm 
# End of macro FORTH_DSP_VALUEHL
4a71					;v5FORTH_DSP_VALUE 
4a71					 
4a71			;		push hl 
4a71					FORTH_DSP_POP 
4a71 cd a5 1b			call macro_forth_dsp_pop 
4a74				endm 
# End of macro FORTH_DSP_POP
4a74			;		pop hl 
4a74			 
4a74			;v5		inc hl   ; move past the type marker 
4a74			 
4a74				if DEBUG_STORESE 
4a74					DMARK "LBl" 
4a74 f5				push af  
4a75 3a 89 4a			ld a, (.dmark)  
4a78 32 bd fb			ld (debug_mark),a  
4a7b 3a 8a 4a			ld a, (.dmark+1)  
4a7e 32 be fb			ld (debug_mark+1),a  
4a81 3a 8b 4a			ld a, (.dmark+2)  
4a84 32 bf fb			ld (debug_mark+2),a  
4a87 18 03			jr .pastdmark  
4a89 ..			.dmark: db "LBl"  
4a8c f1			.pastdmark: pop af  
4a8d			endm  
# End of macro DMARK
4a8d					CALLMONITOR 
4a8d cd d4 14			call break_point_state  
4a90				endm  
# End of macro CALLMONITOR
4a90				endif 
4a90 cd d3 04				call storage_label 
4a93			 
4a93				       NEXTW 
4a93 c3 5f 1c			jp macro_next 
4a96				endm 
# End of macro NEXTW
4a96			.STOREPAGE: 
4a96				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4a96 6d				db WORD_SYS_CORE+89             
4a97 c9 4a			dw .LABELS            
4a99 0a				db 9 + 1 
4a9a .. 00			db "STOREPAGE",0              
4aa4				endm 
# End of macro CWHEAD
4aa4			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4aa4					; TODO test to see if bank is selected 
4aa4				 
4aa4					if DEBUG_FORTH_WORDS_KEY 
4aa4						DMARK "STP" 
4aa4 f5				push af  
4aa5 3a b9 4a			ld a, (.dmark)  
4aa8 32 bd fb			ld (debug_mark),a  
4aab 3a ba 4a			ld a, (.dmark+1)  
4aae 32 be fb			ld (debug_mark+1),a  
4ab1 3a bb 4a			ld a, (.dmark+2)  
4ab4 32 bf fb			ld (debug_mark+2),a  
4ab7 18 03			jr .pastdmark  
4ab9 ..			.dmark: db "STP"  
4abc f1			.pastdmark: pop af  
4abd			endm  
# End of macro DMARK
4abd						CALLMONITOR 
4abd cd d4 14			call break_point_state  
4ac0				endm  
# End of macro CALLMONITOR
4ac0					endif 
4ac0			;	if DEBUG_STORESE 
4ac0			;		DMARK "STP" 
4ac0			;		CALLMONITOR 
4ac0			;	endif 
4ac0			 
4ac0 21 e8 f9			ld hl, store_page 
4ac3 cd 6e 1a			call forth_push_numhl 
4ac6			 
4ac6			 
4ac6				       NEXTW 
4ac6 c3 5f 1c			jp macro_next 
4ac9				endm 
# End of macro NEXTW
4ac9			.LABELS: 
4ac9				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4ac9 6d				db WORD_SYS_CORE+89             
4aca 53 4b			dw .ENDSTORAGE            
4acc 07				db 6 + 1 
4acd .. 00			db "LABELS",0              
4ad4				endm 
# End of macro CWHEAD
4ad4			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4ad4					;  
4ad4			 
4ad4					; save the current device selected to restore afterwards 
4ad4				 
4ad4 3a e2 f9				ld a, (spi_device) 
4ad7 f5					push af 
4ad8			 
4ad8			 
4ad8					; run through each of the banks 
4ad8			 
4ad8 21 01 00				ld hl, 1 
4adb cd 6e 1a				call forth_push_numhl 
4ade 3e ff				ld a, SPI_CE_HIGH 
4ae0 cb 87				res SPI_CE0, a 
4ae2 32 e2 f9				ld (spi_device), a 
4ae5 cd ba 03				call storage_get_block_0 
4ae8 21 eb f9				ld hl, store_page+3 
4aeb cd 80 1a				call forth_push_str 
4aee			 
4aee					 
4aee 21 02 00				ld hl, 2 
4af1 cd 6e 1a				call forth_push_numhl 
4af4 3e ff				ld a, SPI_CE_HIGH 
4af6 cb 8f				res SPI_CE1, a 
4af8 32 e2 f9				ld (spi_device), a 
4afb cd ba 03				call storage_get_block_0 
4afe 21 eb f9				ld hl, store_page+3 
4b01 cd 80 1a				call forth_push_str 
4b04			 
4b04					 
4b04 21 03 00				ld hl, 3 
4b07 cd 6e 1a				call forth_push_numhl 
4b0a 3e ff				ld a, SPI_CE_HIGH 
4b0c cb 97				res SPI_CE2, a 
4b0e 32 e2 f9				ld (spi_device), a 
4b11 cd ba 03				call storage_get_block_0 
4b14 21 eb f9				ld hl, store_page+3 
4b17 cd 80 1a				call forth_push_str 
4b1a			 
4b1a			 
4b1a 21 04 00				ld hl, 4 
4b1d cd 6e 1a				call forth_push_numhl 
4b20 3e ff				ld a, SPI_CE_HIGH 
4b22 cb 9f				res SPI_CE3, a 
4b24 32 e2 f9				ld (spi_device), a 
4b27 cd ba 03				call storage_get_block_0 
4b2a 21 eb f9				ld hl, store_page+3 
4b2d cd 80 1a				call forth_push_str 
4b30			 
4b30					 
4b30			 
4b30 21 05 00				ld hl, 5 
4b33 cd 6e 1a				call forth_push_numhl 
4b36 3e ff				ld a, SPI_CE_HIGH 
4b38 cb a7				res SPI_CE4, a 
4b3a 32 e2 f9				ld (spi_device), a 
4b3d cd ba 03				call storage_get_block_0 
4b40 21 eb f9				ld hl, store_page+3 
4b43 cd 80 1a				call forth_push_str 
4b46			 
4b46					 
4b46					; push fixed count of storage devices (on board) for now 
4b46			 
4b46 21 05 00				ld hl, 5 
4b49 cd 6e 1a				call forth_push_numhl 
4b4c			 
4b4c					; restore selected device  
4b4c				 
4b4c f1					pop af 
4b4d 32 e2 f9				ld (spi_device), a 
4b50			 
4b50				       NEXTW 
4b50 c3 5f 1c			jp macro_next 
4b53				endm 
# End of macro NEXTW
4b53			 
4b53			.ENDSTORAGE: 
4b53			; eof 
# End of file forth_words_storage.asm
4b53			endif 
4b53				include "forth_words_device.asm" 
4b53			; Device related words 
4b53			 
4b53			; | ## Device Words 
4b53			 
4b53			if SOUND_ENABLE 
4b53			.NOTE: 
4b53				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4b53			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4b53					if DEBUG_FORTH_WORDS_KEY 
4b53						DMARK "NTE" 
4b53						CALLMONITOR 
4b53					endif 
4b53			 
4b53				 
4b53			 
4b53					NEXTW 
4b53			.AFTERSOUND: 
4b53			endif 
4b53			 
4b53			 
4b53			USE_GPIO: equ 0 
4b53			 
4b53			if USE_GPIO 
4b53			.GP1: 
4b53				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4b53			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4b53					NEXTW 
4b53			.GP2: 
4b53				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4b53			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4b53			 
4b53					NEXTW 
4b53			 
4b53			.GP3: 
4b53				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4b53			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4b53			 
4b53					NEXTW 
4b53			 
4b53			.GP4: 
4b53				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4b53			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4b53			 
4b53					NEXTW 
4b53			.SIN: 
4b53			 
4b53			 
4b53			endif 
4b53			 
4b53			 
4b53				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4b53 33				db WORD_SYS_CORE+31             
4b54 88 4b			dw .SOUT            
4b56 03				db 2 + 1 
4b57 .. 00			db "IN",0              
4b5a				endm 
# End of macro CWHEAD
4b5a			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4b5a					if DEBUG_FORTH_WORDS_KEY 
4b5a						DMARK "IN." 
4b5a f5				push af  
4b5b 3a 6f 4b			ld a, (.dmark)  
4b5e 32 bd fb			ld (debug_mark),a  
4b61 3a 70 4b			ld a, (.dmark+1)  
4b64 32 be fb			ld (debug_mark+1),a  
4b67 3a 71 4b			ld a, (.dmark+2)  
4b6a 32 bf fb			ld (debug_mark+2),a  
4b6d 18 03			jr .pastdmark  
4b6f ..			.dmark: db "IN."  
4b72 f1			.pastdmark: pop af  
4b73			endm  
# End of macro DMARK
4b73						CALLMONITOR 
4b73 cd d4 14			call break_point_state  
4b76				endm  
# End of macro CALLMONITOR
4b76					endif 
4b76					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b76 cd 09 1b			call macro_dsp_valuehl 
4b79				endm 
# End of macro FORTH_DSP_VALUEHL
4b79			 
4b79 e5					push hl 
4b7a			 
4b7a					; destroy value TOS 
4b7a			 
4b7a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b7a cd a5 1b			call macro_forth_dsp_pop 
4b7d				endm 
# End of macro FORTH_DSP_POP
4b7d			 
4b7d					; one value on hl get other one back 
4b7d			 
4b7d c1					pop bc 
4b7e			 
4b7e					; do the sub 
4b7e			;		ex de, hl 
4b7e			 
4b7e ed 68				in l,(c) 
4b80			 
4b80					; save it 
4b80			 
4b80 26 00				ld h,0 
4b82			 
4b82					; TODO push value back onto stack for another op etc 
4b82			 
4b82 cd 6e 1a				call forth_push_numhl 
4b85					NEXTW 
4b85 c3 5f 1c			jp macro_next 
4b88				endm 
# End of macro NEXTW
4b88			.SOUT: 
4b88				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4b88 34				db WORD_SYS_CORE+32             
4b89 db 4b			dw .SPIO            
4b8b 04				db 3 + 1 
4b8c .. 00			db "OUT",0              
4b90				endm 
# End of macro CWHEAD
4b90			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4b90					if DEBUG_FORTH_WORDS_KEY 
4b90						DMARK "OUT" 
4b90 f5				push af  
4b91 3a a5 4b			ld a, (.dmark)  
4b94 32 bd fb			ld (debug_mark),a  
4b97 3a a6 4b			ld a, (.dmark+1)  
4b9a 32 be fb			ld (debug_mark+1),a  
4b9d 3a a7 4b			ld a, (.dmark+2)  
4ba0 32 bf fb			ld (debug_mark+2),a  
4ba3 18 03			jr .pastdmark  
4ba5 ..			.dmark: db "OUT"  
4ba8 f1			.pastdmark: pop af  
4ba9			endm  
# End of macro DMARK
4ba9						CALLMONITOR 
4ba9 cd d4 14			call break_point_state  
4bac				endm  
# End of macro CALLMONITOR
4bac					endif 
4bac			 
4bac					; get port 
4bac			 
4bac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bac cd 09 1b			call macro_dsp_valuehl 
4baf				endm 
# End of macro FORTH_DSP_VALUEHL
4baf			 
4baf e5					push hl 
4bb0			 
4bb0					; destroy value TOS 
4bb0			 
4bb0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bb0 cd a5 1b			call macro_forth_dsp_pop 
4bb3				endm 
# End of macro FORTH_DSP_POP
4bb3			 
4bb3					; get byte to send 
4bb3			 
4bb3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bb3 cd 09 1b			call macro_dsp_valuehl 
4bb6				endm 
# End of macro FORTH_DSP_VALUEHL
4bb6			 
4bb6			;		push hl 
4bb6			 
4bb6					; destroy value TOS 
4bb6			 
4bb6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bb6 cd a5 1b			call macro_forth_dsp_pop 
4bb9				endm 
# End of macro FORTH_DSP_POP
4bb9			 
4bb9					; one value on hl get other one back 
4bb9			 
4bb9			;		pop hl 
4bb9			 
4bb9 c1					pop bc 
4bba			 
4bba					if DEBUG_FORTH_WORDS 
4bba						DMARK "OUT" 
4bba f5				push af  
4bbb 3a cf 4b			ld a, (.dmark)  
4bbe 32 bd fb			ld (debug_mark),a  
4bc1 3a d0 4b			ld a, (.dmark+1)  
4bc4 32 be fb			ld (debug_mark+1),a  
4bc7 3a d1 4b			ld a, (.dmark+2)  
4bca 32 bf fb			ld (debug_mark+2),a  
4bcd 18 03			jr .pastdmark  
4bcf ..			.dmark: db "OUT"  
4bd2 f1			.pastdmark: pop af  
4bd3			endm  
# End of macro DMARK
4bd3						CALLMONITOR 
4bd3 cd d4 14			call break_point_state  
4bd6				endm  
# End of macro CALLMONITOR
4bd6					endif 
4bd6			 
4bd6 ed 69				out (c), l 
4bd8			 
4bd8					NEXTW 
4bd8 c3 5f 1c			jp macro_next 
4bdb				endm 
# End of macro NEXTW
4bdb			 
4bdb			 
4bdb			.SPIO: 
4bdb			 
4bdb			if STORAGE_SE 
4bdb				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4bdb 51				db WORD_SYS_CORE+61             
4bdc ec 4b			dw .SPICEH            
4bde 07				db 6 + 1 
4bdf .. 00			db "SPICEL",0              
4be6				endm 
# End of macro CWHEAD
4be6			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4be6			 
4be6 cd 95 01				call spi_ce_low 
4be9			    NEXTW 
4be9 c3 5f 1c			jp macro_next 
4bec				endm 
# End of macro NEXTW
4bec			 
4bec			.SPICEH: 
4bec				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4bec 51				db WORD_SYS_CORE+61             
4bed fd 4b			dw .SPIOb            
4bef 07				db 6 + 1 
4bf0 .. 00			db "SPICEH",0              
4bf7				endm 
# End of macro CWHEAD
4bf7			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4bf7			 
4bf7 cd 84 01				call spi_ce_high 
4bfa			    NEXTW 
4bfa c3 5f 1c			jp macro_next 
4bfd				endm 
# End of macro NEXTW
4bfd			 
4bfd			 
4bfd			.SPIOb: 
4bfd			 
4bfd				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4bfd 51				db WORD_SYS_CORE+61             
4bfe 13 4c			dw .SPII            
4c00 05				db 4 + 1 
4c01 .. 00			db "SPIO",0              
4c06				endm 
# End of macro CWHEAD
4c06			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4c06			 
4c06					; get port 
4c06			 
4c06			 
4c06					; get byte to send 
4c06			 
4c06					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c06 cd 09 1b			call macro_dsp_valuehl 
4c09				endm 
# End of macro FORTH_DSP_VALUEHL
4c09			 
4c09			;		push hl    ; u1  
4c09			 
4c09					; destroy value TOS 
4c09			 
4c09					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c09 cd a5 1b			call macro_forth_dsp_pop 
4c0c				endm 
# End of macro FORTH_DSP_POP
4c0c			 
4c0c					; one value on hl get other one back 
4c0c			 
4c0c			;		pop hl   ; u2 - addr 
4c0c			 
4c0c					; TODO Send SPI byte 
4c0c			 
4c0c 7d					ld a, l 
4c0d cd b9 00				call spi_send_byte 
4c10			 
4c10					NEXTW 
4c10 c3 5f 1c			jp macro_next 
4c13				endm 
# End of macro NEXTW
4c13			 
4c13			.SPII: 
4c13				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4c13 52				db WORD_SYS_CORE+62             
4c14 28 4c			dw .SESEL            
4c16 06				db 5 + 1 
4c17 .. 00			db "SPII",0              
4c1c				endm 
# End of macro CWHEAD
4c1c			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4c1c			 
4c1c					; TODO Get SPI byte 
4c1c			 
4c1c cd da 00				call spi_read_byte 
4c1f			 
4c1f 26 00				ld h, 0 
4c21 6f					ld l, a 
4c22 cd 6e 1a				call forth_push_numhl 
4c25			 
4c25					NEXTW 
4c25 c3 5f 1c			jp macro_next 
4c28				endm 
# End of macro NEXTW
4c28			 
4c28			 
4c28			 
4c28			.SESEL: 
4c28				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4c28 66				db WORD_SYS_CORE+82             
4c29 bc 4c			dw .CARTDEV            
4c2b 05				db 4 + 1 
4c2c .. 00			db "BANK",0              
4c31				endm 
# End of macro CWHEAD
4c31			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4c31					if DEBUG_FORTH_WORDS_KEY 
4c31						DMARK "BNK" 
4c31 f5				push af  
4c32 3a 46 4c			ld a, (.dmark)  
4c35 32 bd fb			ld (debug_mark),a  
4c38 3a 47 4c			ld a, (.dmark+1)  
4c3b 32 be fb			ld (debug_mark+1),a  
4c3e 3a 48 4c			ld a, (.dmark+2)  
4c41 32 bf fb			ld (debug_mark+2),a  
4c44 18 03			jr .pastdmark  
4c46 ..			.dmark: db "BNK"  
4c49 f1			.pastdmark: pop af  
4c4a			endm  
# End of macro DMARK
4c4a						CALLMONITOR 
4c4a cd d4 14			call break_point_state  
4c4d				endm  
# End of macro CALLMONITOR
4c4d					endif 
4c4d			 
4c4d 3e ff				ld a, 255 
4c4f 32 e5 f9				ld (spi_cartdev), a 
4c52			 
4c52					; get bank 
4c52			 
4c52					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c52 cd 09 1b			call macro_dsp_valuehl 
4c55				endm 
# End of macro FORTH_DSP_VALUEHL
4c55			 
4c55			;		push hl 
4c55			 
4c55					; destroy value TOS 
4c55			 
4c55					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c55 cd a5 1b			call macro_forth_dsp_pop 
4c58				endm 
# End of macro FORTH_DSP_POP
4c58			 
4c58					; one value on hl get other one back 
4c58			 
4c58			;		pop hl 
4c58			 
4c58			 
4c58 0e ff				ld c, SPI_CE_HIGH 
4c5a			 
4c5a 7d					ld a, l 
4c5b			 
4c5b					if DEBUG_FORTH_WORDS 
4c5b						DMARK "BNK" 
4c5b f5				push af  
4c5c 3a 70 4c			ld a, (.dmark)  
4c5f 32 bd fb			ld (debug_mark),a  
4c62 3a 71 4c			ld a, (.dmark+1)  
4c65 32 be fb			ld (debug_mark+1),a  
4c68 3a 72 4c			ld a, (.dmark+2)  
4c6b 32 bf fb			ld (debug_mark+2),a  
4c6e 18 03			jr .pastdmark  
4c70 ..			.dmark: db "BNK"  
4c73 f1			.pastdmark: pop af  
4c74			endm  
# End of macro DMARK
4c74						CALLMONITOR 
4c74 cd d4 14			call break_point_state  
4c77				endm  
# End of macro CALLMONITOR
4c77					endif 
4c77			 
4c77					; active low 
4c77			 
4c77 fe 00				cp 0 
4c79 28 1e				jr z, .bset 
4c7b fe 01				cp 1 
4c7d 20 02				jr nz, .b2 
4c7f cb 81				res 0, c 
4c81 fe 02		.b2:		cp 2 
4c83 20 02				jr nz, .b3 
4c85 cb 89				res 1, c 
4c87 fe 03		.b3:		cp 3 
4c89 20 02				jr nz, .b4 
4c8b cb 91				res 2, c 
4c8d fe 04		.b4:		cp 4 
4c8f 20 02				jr nz, .b5 
4c91 cb 99				res 3, c 
4c93 fe 05		.b5:		cp 5 
4c95 20 02				jr nz, .bset 
4c97 cb a1				res 4, c 
4c99			 
4c99			.bset: 
4c99 79					ld a, c 
4c9a 32 e2 f9				ld (spi_device),a 
4c9d					if DEBUG_FORTH_WORDS 
4c9d						DMARK "BN2" 
4c9d f5				push af  
4c9e 3a b2 4c			ld a, (.dmark)  
4ca1 32 bd fb			ld (debug_mark),a  
4ca4 3a b3 4c			ld a, (.dmark+1)  
4ca7 32 be fb			ld (debug_mark+1),a  
4caa 3a b4 4c			ld a, (.dmark+2)  
4cad 32 bf fb			ld (debug_mark+2),a  
4cb0 18 03			jr .pastdmark  
4cb2 ..			.dmark: db "BN2"  
4cb5 f1			.pastdmark: pop af  
4cb6			endm  
# End of macro DMARK
4cb6						CALLMONITOR 
4cb6 cd d4 14			call break_point_state  
4cb9				endm  
# End of macro CALLMONITOR
4cb9					endif 
4cb9			 
4cb9					NEXTW 
4cb9 c3 5f 1c			jp macro_next 
4cbc				endm 
# End of macro NEXTW
4cbc			 
4cbc			.CARTDEV: 
4cbc				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4cbc 66				db WORD_SYS_CORE+82             
4cbd 65 4d			dw .ENDDEVICE            
4cbf 08				db 7 + 1 
4cc0 .. 00			db "CARTDEV",0              
4cc8				endm 
# End of macro CWHEAD
4cc8			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4cc8					if DEBUG_FORTH_WORDS_KEY 
4cc8						DMARK "CDV" 
4cc8 f5				push af  
4cc9 3a dd 4c			ld a, (.dmark)  
4ccc 32 bd fb			ld (debug_mark),a  
4ccf 3a de 4c			ld a, (.dmark+1)  
4cd2 32 be fb			ld (debug_mark+1),a  
4cd5 3a df 4c			ld a, (.dmark+2)  
4cd8 32 bf fb			ld (debug_mark+2),a  
4cdb 18 03			jr .pastdmark  
4cdd ..			.dmark: db "CDV"  
4ce0 f1			.pastdmark: pop af  
4ce1			endm  
# End of macro DMARK
4ce1						CALLMONITOR 
4ce1 cd d4 14			call break_point_state  
4ce4				endm  
# End of macro CALLMONITOR
4ce4					endif 
4ce4			 
4ce4					; disable se storage bank selection 
4ce4			 
4ce4 3e ff				ld a, SPI_CE_HIGH		; ce high 
4ce6 32 e2 f9				ld (spi_device), a 
4ce9			 
4ce9					; get bank 
4ce9			 
4ce9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ce9 cd 09 1b			call macro_dsp_valuehl 
4cec				endm 
# End of macro FORTH_DSP_VALUEHL
4cec			 
4cec			;		push hl 
4cec			 
4cec					; destroy value TOS 
4cec			 
4cec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4cec cd a5 1b			call macro_forth_dsp_pop 
4cef				endm 
# End of macro FORTH_DSP_POP
4cef			 
4cef					; one value on hl get other one back 
4cef			 
4cef			;		pop hl 
4cef			 
4cef					; active low 
4cef			 
4cef 0e ff				ld c, 255 
4cf1			 
4cf1 7d					ld a, l 
4cf2					if DEBUG_FORTH_WORDS 
4cf2						DMARK "CDV" 
4cf2 f5				push af  
4cf3 3a 07 4d			ld a, (.dmark)  
4cf6 32 bd fb			ld (debug_mark),a  
4cf9 3a 08 4d			ld a, (.dmark+1)  
4cfc 32 be fb			ld (debug_mark+1),a  
4cff 3a 09 4d			ld a, (.dmark+2)  
4d02 32 bf fb			ld (debug_mark+2),a  
4d05 18 03			jr .pastdmark  
4d07 ..			.dmark: db "CDV"  
4d0a f1			.pastdmark: pop af  
4d0b			endm  
# End of macro DMARK
4d0b						CALLMONITOR 
4d0b cd d4 14			call break_point_state  
4d0e				endm  
# End of macro CALLMONITOR
4d0e					endif 
4d0e fe 00				cp 0 
4d10 28 30				jr z, .cset 
4d12 fe 01				cp 1 
4d14 20 02				jr nz, .c2 
4d16 cb 81				res 0, c 
4d18 fe 02		.c2:		cp 2 
4d1a 20 02				jr nz, .c3 
4d1c cb 89				res 1, c 
4d1e fe 03		.c3:		cp 3 
4d20 20 02				jr nz, .c4 
4d22 cb 91				res 2, c 
4d24 fe 04		.c4:		cp 4 
4d26 20 02				jr nz, .c5 
4d28 cb 99				res 3, c 
4d2a fe 05		.c5:		cp 5 
4d2c 20 02				jr nz, .c6 
4d2e cb a1				res 4, c 
4d30 fe 06		.c6:		cp 6 
4d32 20 02				jr nz, .c7 
4d34 cb a9				res 5, c 
4d36 fe 07		.c7:		cp 7 
4d38 20 02				jr nz, .c8 
4d3a cb b1				res 6, c 
4d3c fe 08		.c8:		cp 8 
4d3e 20 02				jr nz, .cset 
4d40 cb b9				res 7, c 
4d42 79			.cset:		ld a, c 
4d43 32 e5 f9				ld (spi_cartdev),a 
4d46			 
4d46					if DEBUG_FORTH_WORDS 
4d46						DMARK "CD2" 
4d46 f5				push af  
4d47 3a 5b 4d			ld a, (.dmark)  
4d4a 32 bd fb			ld (debug_mark),a  
4d4d 3a 5c 4d			ld a, (.dmark+1)  
4d50 32 be fb			ld (debug_mark+1),a  
4d53 3a 5d 4d			ld a, (.dmark+2)  
4d56 32 bf fb			ld (debug_mark+2),a  
4d59 18 03			jr .pastdmark  
4d5b ..			.dmark: db "CD2"  
4d5e f1			.pastdmark: pop af  
4d5f			endm  
# End of macro DMARK
4d5f						CALLMONITOR 
4d5f cd d4 14			call break_point_state  
4d62				endm  
# End of macro CALLMONITOR
4d62					endif 
4d62					NEXTW 
4d62 c3 5f 1c			jp macro_next 
4d65				endm 
# End of macro NEXTW
4d65			endif 
4d65			 
4d65			.ENDDEVICE: 
4d65			; eof 
4d65			 
# End of file forth_words_device.asm
4d65			 
4d65			; var handler 
4d65			 
4d65			 
4d65			.VARS: 
4d65				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4d65 78				db WORD_SYS_CORE+100             
4d66 7d 4d			dw .V0Q            
4d68 04				db 3 + 1 
4d69 .. 00			db "V0!",0              
4d6d				endm 
# End of macro CWHEAD
4d6d			;| V0! ( u1 -- )  Store value to v0  | DONE 
4d6d			 
4d6d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4d6d cd 09 1b			call macro_dsp_valuehl 
4d70				endm 
# End of macro FORTH_DSP_VALUEHL
4d70			 
4d70 11 ab f9				ld de, cli_var_array 
4d73			 
4d73 eb					ex de, hl 
4d74 73					ld (hl), e 
4d75 23					inc hl 
4d76 72					ld (hl), d 
4d77			 
4d77					; destroy value TOS 
4d77			 
4d77					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4d77 cd a5 1b			call macro_forth_dsp_pop 
4d7a				endm 
# End of macro FORTH_DSP_POP
4d7a			 
4d7a				       NEXTW 
4d7a c3 5f 1c			jp macro_next 
4d7d				endm 
# End of macro NEXTW
4d7d			.V0Q: 
4d7d				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4d7d 79				db WORD_SYS_CORE+101             
4d7e 8e 4d			dw .V1S            
4d80 04				db 3 + 1 
4d81 .. 00			db "V0@",0              
4d85				endm 
# End of macro CWHEAD
4d85			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4d85 2a ab f9				ld hl, (cli_var_array) 
4d88 cd 6e 1a				call forth_push_numhl 
4d8b			 
4d8b				       NEXTW 
4d8b c3 5f 1c			jp macro_next 
4d8e				endm 
# End of macro NEXTW
4d8e			.V1S: 
4d8e				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4d8e 7a				db WORD_SYS_CORE+102             
4d8f a6 4d			dw .V1Q            
4d91 04				db 3 + 1 
4d92 .. 00			db "V1!",0              
4d96				endm 
# End of macro CWHEAD
4d96			;| V1! ( u1 -- )  Store value to v1 | DONE 
4d96					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4d96 cd 09 1b			call macro_dsp_valuehl 
4d99				endm 
# End of macro FORTH_DSP_VALUEHL
4d99			 
4d99 11 ad f9				ld de, cli_var_array+2 
4d9c				 
4d9c eb					ex de, hl 
4d9d 73					ld (hl), e 
4d9e 23					inc hl 
4d9f 72					ld (hl), d 
4da0			 
4da0					; destroy value TOS 
4da0			 
4da0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4da0 cd a5 1b			call macro_forth_dsp_pop 
4da3				endm 
# End of macro FORTH_DSP_POP
4da3				       NEXTW 
4da3 c3 5f 1c			jp macro_next 
4da6				endm 
# End of macro NEXTW
4da6			.V1Q: 
4da6				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4da6 7b				db WORD_SYS_CORE+103             
4da7 b7 4d			dw .V2S            
4da9 04				db 3 + 1 
4daa .. 00			db "V1@",0              
4dae				endm 
# End of macro CWHEAD
4dae			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4dae 2a ad f9				ld hl, (cli_var_array+2) 
4db1 cd 6e 1a				call forth_push_numhl 
4db4				       NEXTW 
4db4 c3 5f 1c			jp macro_next 
4db7				endm 
# End of macro NEXTW
4db7			.V2S: 
4db7				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4db7 7c				db WORD_SYS_CORE+104             
4db8 cf 4d			dw .V2Q            
4dba 04				db 3 + 1 
4dbb .. 00			db "V2!",0              
4dbf				endm 
# End of macro CWHEAD
4dbf			;| V2! ( u1 -- )  Store value to v2 | DONE 
4dbf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4dbf cd 09 1b			call macro_dsp_valuehl 
4dc2				endm 
# End of macro FORTH_DSP_VALUEHL
4dc2			 
4dc2 11 af f9				ld de, cli_var_array+4 
4dc5				 
4dc5 eb					ex de, hl 
4dc6 73					ld (hl), e 
4dc7 23					inc hl 
4dc8 72					ld (hl), d 
4dc9			 
4dc9					; destroy value TOS 
4dc9			 
4dc9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4dc9 cd a5 1b			call macro_forth_dsp_pop 
4dcc				endm 
# End of macro FORTH_DSP_POP
4dcc				       NEXTW 
4dcc c3 5f 1c			jp macro_next 
4dcf				endm 
# End of macro NEXTW
4dcf			.V2Q: 
4dcf				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4dcf 7d				db WORD_SYS_CORE+105             
4dd0 e0 4d			dw .V3S            
4dd2 04				db 3 + 1 
4dd3 .. 00			db "V2@",0              
4dd7				endm 
# End of macro CWHEAD
4dd7			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4dd7 2a af f9				ld hl, (cli_var_array+4) 
4dda cd 6e 1a				call forth_push_numhl 
4ddd				       NEXTW 
4ddd c3 5f 1c			jp macro_next 
4de0				endm 
# End of macro NEXTW
4de0			.V3S: 
4de0				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4de0 7c				db WORD_SYS_CORE+104             
4de1 f8 4d			dw .V3Q            
4de3 04				db 3 + 1 
4de4 .. 00			db "V3!",0              
4de8				endm 
# End of macro CWHEAD
4de8			;| V3! ( u1 -- )  Store value to v3 | DONE 
4de8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4de8 cd 09 1b			call macro_dsp_valuehl 
4deb				endm 
# End of macro FORTH_DSP_VALUEHL
4deb			 
4deb 11 b1 f9				ld de, cli_var_array+6 
4dee				 
4dee eb					ex de, hl 
4def 73					ld (hl), e 
4df0 23					inc hl 
4df1 72					ld (hl), d 
4df2			 
4df2					; destroy value TOS 
4df2			 
4df2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4df2 cd a5 1b			call macro_forth_dsp_pop 
4df5				endm 
# End of macro FORTH_DSP_POP
4df5				       NEXTW 
4df5 c3 5f 1c			jp macro_next 
4df8				endm 
# End of macro NEXTW
4df8			.V3Q: 
4df8				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4df8 7d				db WORD_SYS_CORE+105             
4df9 09 4e			dw .END            
4dfb 04				db 3 + 1 
4dfc .. 00			db "V3@",0              
4e00				endm 
# End of macro CWHEAD
4e00			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4e00 2a b1 f9				ld hl, (cli_var_array+6) 
4e03 cd 6e 1a				call forth_push_numhl 
4e06				       NEXTW 
4e06 c3 5f 1c			jp macro_next 
4e09				endm 
# End of macro NEXTW
4e09			 
4e09			 
4e09			 
4e09			 
4e09			 
4e09			; end of dict marker 
4e09			 
4e09 00			.END:    db WORD_SYS_END 
4e0a 00 00			dw 0 
4e0c 00				db 0 
4e0d			 
4e0d			; use to jp here for user dict words to save on macro expansion  
4e0d			 
4e0d			user_dict_next: 
4e0d				NEXTW 
4e0d c3 5f 1c			jp macro_next 
4e10				endm 
# End of macro NEXTW
4e10			 
4e10			 
4e10			user_exec: 
4e10				;    ld hl, <word code> 
4e10				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4e10				;    call forthexec 
4e10				;    jp user_dict_next   (NEXT) 
4e10			        ;    <word code bytes> 
4e10 eb				ex de, hl 
4e11 2a b9 f2			ld hl,(os_tok_ptr) 
4e14				 
4e14				FORTH_RSP_NEXT 
4e14 cd 15 1a			call macro_forth_rsp_next 
4e17				endm 
# End of macro FORTH_RSP_NEXT
4e17			 
4e17			if DEBUG_FORTH_UWORD 
4e17						DMARK "UEX" 
4e17 f5				push af  
4e18 3a 2c 4e			ld a, (.dmark)  
4e1b 32 bd fb			ld (debug_mark),a  
4e1e 3a 2d 4e			ld a, (.dmark+1)  
4e21 32 be fb			ld (debug_mark+1),a  
4e24 3a 2e 4e			ld a, (.dmark+2)  
4e27 32 bf fb			ld (debug_mark+2),a  
4e2a 18 03			jr .pastdmark  
4e2c ..			.dmark: db "UEX"  
4e2f f1			.pastdmark: pop af  
4e30			endm  
# End of macro DMARK
4e30				CALLMONITOR 
4e30 cd d4 14			call break_point_state  
4e33				endm  
# End of macro CALLMONITOR
4e33			endif 
4e33			 
4e33			 
4e33			 
4e33 eb				ex de, hl 
4e34 22 b9 f2			ld (os_tok_ptr), hl 
4e37				 
4e37				; Don't use next - Skips the first word in uword. 
4e37			 
4e37 c3 f0 1c			jp exec1 
4e3a			;	NEXT 
4e3a			 
4e3a			 
4e3a			; eof 
# End of file forth_wordsv4.asm
4e3a			endif 
4e3a			;;;;;;;;;;;;;; Debug code 
4e3a			 
4e3a			 
4e3a			;if DEBUG_FORTH_PARSE 
4e3a .. 00		.nowordfound: db "No match",0 
4e43 .. 00		.compword:	db "Comparing word ",0 
4e53 .. 00		.nextwordat:	db "Next word at",0 
4e60 .. 00		.charmatch:	db "Char match",0 
4e6b			;endif 
4e6b			if DEBUG_FORTH_JP 
4e6b			.foundword:	db "Word match. Exec..",0 
4e6b			endif 
4e6b			;if DEBUG_FORTH_PUSH 
4e6b .. 00		.enddict:	db "Dict end. Push.",0 
4e7b .. 00		.push_str:	db "Pushing string",0 
4e8a .. 00		.push_num:	db "Pushing number",0 
4e99 .. 00		.data_sp:	db "SP:",0 
4e9d .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4eaf .. 00		.wordinde:	db "Word in DE (3/0):",0 
4ec1 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4ed3			;endif 
4ed3			;if DEBUG_FORTH_MALLOC 
4ed3 .. 00		.push_malloc:	db "Malloc address",0 
4ee2			;endif 
4ee2			 
4ee2			 
4ee2			 
4ee2			; display malloc address and current data stack pointer  
4ee2			 
4ee2			malloc_error: 
4ee2 d5				push de 
4ee3 f5				push af 
4ee4 e5				push hl 
4ee5 cd 8c 0a			call clear_display 
4ee8 11 0a 4f			ld de, .mallocerr 
4eeb 3e 00			ld a,0 
4eed			;	ld de,os_word_scratch 
4eed cd 9f 0a			call str_at_display 
4ef0 3e 11			ld a, display_row_1+17 
4ef2 11 bd fb			ld de, debug_mark 
4ef5 cd 9f 0a			call str_at_display 
4ef8 cd af 0a			call update_display 
4efb				;call break_point_state 
4efb cd 38 63			call cin_wait 
4efe			 
4efe 3e 20			ld a, ' ' 
4f00 32 b7 ef			ld (os_view_disable), a 
4f03 e1				pop hl 
4f04 f1				pop af 
4f05 d1				pop de	 
4f06				CALLMONITOR 
4f06 cd d4 14			call break_point_state  
4f09				endm  
# End of macro CALLMONITOR
4f09 c9				ret 
4f0a			 
4f0a .. 00		.mallocerr: 	db "Malloc Error",0 
4f17			;if DEBUG_FORTH_PUSH 
4f17			display_data_sp: 
4f17 f5				push af 
4f18			 
4f18				; see if disabled 
4f18			 
4f18 3a b7 ef			ld a, (os_view_disable) 
4f1b fe 2a			cp '*' 
4f1d 28 67			jr z, .skipdsp 
4f1f			 
4f1f e5				push hl 
4f20 e5				push hl 
4f21 e5			push hl 
4f22 cd 8c 0a			call clear_display 
4f25 e1			pop hl 
4f26 7c				ld a,h 
4f27 21 bd f2			ld hl, os_word_scratch 
4f2a cd bd 0f			call hexout 
4f2d e1				pop hl 
4f2e 7d				ld a,l 
4f2f 21 bf f2			ld hl, os_word_scratch+2 
4f32 cd bd 0f			call hexout 
4f35 21 c1 f2			ld hl, os_word_scratch+4 
4f38 3e 00			ld a,0 
4f3a 77				ld (hl),a 
4f3b 11 bd f2			ld de,os_word_scratch 
4f3e 3e 14				ld a, display_row_2 
4f40 cd 9f 0a				call str_at_display 
4f43 11 9d 4e			ld de, .wordinhl 
4f46 3e 00			ld a, display_row_1 
4f48			 
4f48 cd 9f 0a				call str_at_display 
4f4b 11 bd fb			ld de, debug_mark 
4f4e 3e 11			ld a, display_row_1+17 
4f50			 
4f50 cd 9f 0a				call str_at_display 
4f53			 
4f53				; display current data stack pointer 
4f53 11 99 4e			ld de,.data_sp 
4f56 3e 1c				ld a, display_row_2 + 8 
4f58 cd 9f 0a				call str_at_display 
4f5b			 
4f5b 2a a5 f9			ld hl,(cli_data_sp) 
4f5e e5				push hl 
4f5f 7c				ld a,h 
4f60 21 bd f2			ld hl, os_word_scratch 
4f63 cd bd 0f			call hexout 
4f66 e1				pop hl 
4f67 7d				ld a,l 
4f68 21 bf f2			ld hl, os_word_scratch+2 
4f6b cd bd 0f			call hexout 
4f6e 21 c1 f2			ld hl, os_word_scratch+4 
4f71 3e 00			ld a,0 
4f73 77				ld (hl),a 
4f74 11 bd f2			ld de,os_word_scratch 
4f77 3e 1f				ld a, display_row_2 + 11 
4f79 cd 9f 0a				call str_at_display 
4f7c			 
4f7c			 
4f7c cd af 0a			call update_display 
4f7f cd 3a 0a			call delay1s 
4f82 cd 3a 0a			call delay1s 
4f85 e1				pop hl 
4f86			.skipdsp: 
4f86 f1				pop af 
4f87 c9				ret 
4f88			 
4f88			display_data_malloc: 
4f88			 
4f88 f5				push af 
4f89 e5				push hl 
4f8a e5				push hl 
4f8b e5			push hl 
4f8c cd 8c 0a			call clear_display 
4f8f e1			pop hl 
4f90 7c				ld a,h 
4f91 21 bd f2			ld hl, os_word_scratch 
4f94 cd bd 0f			call hexout 
4f97 e1				pop hl 
4f98 7d				ld a,l 
4f99 21 bf f2			ld hl, os_word_scratch+2 
4f9c cd bd 0f			call hexout 
4f9f 21 c1 f2			ld hl, os_word_scratch+4 
4fa2 3e 00			ld a,0 
4fa4 77				ld (hl),a 
4fa5 11 bd f2			ld de,os_word_scratch 
4fa8 3e 14				ld a, display_row_2 
4faa cd 9f 0a				call str_at_display 
4fad 11 d3 4e			ld de, .push_malloc 
4fb0 3e 00			ld a, display_row_1 
4fb2			 
4fb2 cd 9f 0a				call str_at_display 
4fb5			 
4fb5				; display current data stack pointer 
4fb5 11 99 4e			ld de,.data_sp 
4fb8 3e 1c				ld a, display_row_2 + 8 
4fba cd 9f 0a				call str_at_display 
4fbd			 
4fbd 2a a5 f9			ld hl,(cli_data_sp) 
4fc0 e5				push hl 
4fc1 7c				ld a,h 
4fc2 21 bd f2			ld hl, os_word_scratch 
4fc5 cd bd 0f			call hexout 
4fc8 e1				pop hl 
4fc9 7d				ld a,l 
4fca 21 bf f2			ld hl, os_word_scratch+2 
4fcd cd bd 0f			call hexout 
4fd0 21 c1 f2			ld hl, os_word_scratch+4 
4fd3 3e 00			ld a,0 
4fd5 77				ld (hl),a 
4fd6 11 bd f2			ld de,os_word_scratch 
4fd9 3e 1f				ld a, display_row_2 + 11 
4fdb cd 9f 0a				call str_at_display 
4fde			 
4fde cd af 0a			call update_display 
4fe1 cd 3a 0a			call delay1s 
4fe4 cd 3a 0a			call delay1s 
4fe7 e1				pop hl 
4fe8 f1				pop af 
4fe9 c9				ret 
4fea			;endif 
4fea			 
4fea			include "forth_autostart.asm" 
4fea			; list of commands to perform at system start up 
4fea			 
4fea			startcmds: 
4fea			;	dw test11 
4fea			;	dw test12 
4fea			;	dw test13 
4fea			;	dw test14 
4fea			;	dw test15 
4fea			;	dw test16 
4fea			;	dw test17 
4fea			;	dw ifthtest1 
4fea			;	dw ifthtest2 
4fea			;	dw ifthtest3 
4fea			;	dw mmtest1 
4fea			;	dw mmtest2 
4fea			;	dw mmtest3 
4fea			;	dw mmtest4 
4fea			;	dw mmtest5 
4fea			;	dw mmtest6 
4fea			;	dw iftest1 
4fea			;	dw iftest2 
4fea			;	dw iftest3 
4fea			;	dw looptest1 
4fea			;	dw looptest2 
4fea			;	dw test1 
4fea			;	dw test2 
4fea			;	dw test3 
4fea			;	dw test4 
4fea			;	dw game2r 
4fea			;	dw game2b1 
4fea			;	dw game2b2 
4fea			 
4fea				; start up words that are actually useful 
4fea			 
4fea 48 50			dw clrstack 
4fec 7b 50			dw type 
4fee 3c 52			dw stest 
4ff0 9f 50			dw strncpy 
4ff2 dd 51			dw list 
4ff4 00 51			dw start1 
4ff6 12 51			dw start2 
4ff8			;	dw start3 
4ff8 25 51			dw start3b 
4ffa 7d 51			dw start3c 
4ffc			 
4ffc				; (unit) testing words 
4ffc			 
4ffc b3 52			dw mtesta 
4ffe 68 53			dw mtestb 
5000 0b 54			dw mtestc 
5002 c0 54			dw mtestd 
5004 64 55			dw mteste 
5006			 
5006				; demo/game words 
5006			 
5006 70 5c		        dw game3w 
5008 9e 5c		        dw game3p 
500a bc 5c		        dw game3sc 
500c ed 5c		        dw game3vsi 
500e 19 5d		        dw game3vs 
5010				 
5010 63 5a			dw game2b 
5012 d1 5a			dw game2bf 
5014 1b 5b			dw game2mba 
5016 b1 5b			dw game2mbas 
5018 f3 5b			dw game2mb 
501a			 
501a 24 57			dw game1 
501c 35 57			dw game1a 
501e 97 57			dw game1b 
5020 cc 57			dw game1c 
5022 02 58			dw game1d 
5024 33 58			dw game1s 
5026 47 58			dw game1t 
5028 5c 58			dw game1f 
502a 90 58			dw game1z 
502c d4 58			dw game1zz 
502e			 
502e 1a 56			dw test5 
5030 52 56			dw test6 
5032 8a 56			dw test7 
5034 9e 56			dw test8 
5036 ca 56			dw test9 
5038 e0 56			dw test10 
503a				 
503a ab 59		        dw ssv5 
503c 8f 59		        dw ssv4 
503e 73 59		        dw ssv3 
5040 3d 59		        dw ssv2 
5042 c4 59		        dw ssv1 
5044 0c 5a		        dw ssv1cpm 
5046			;	dw keyup 
5046			;	dw keydown 
5046			;	dw keyleft 
5046			;	dw keyright 
5046			;	dw 	keyf1 
5046			;	dw keyf2 
5046			;	dw keyf3 
5046			;	dw keyf4 
5046			;	dw keyf5 
5046			;	dw keyf6 
5046			;	dw keyf7 
5046			;	dw keyf8 
5046			;	dw keyf9 
5046			;	dw keyf10 
5046			;	dw keyf11 
5046			;	dw keyf12 
5046			;	dw keytab 
5046			;	dw keycr 
5046			;	dw keyhome 
5046			;	dw keyend 
5046			;	dw keybs 
5046 00 00			db 0, 0	 
5048			 
5048			 
5048			; clear stack  
5048			 
5048 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
507b			 
507b			; type ( addr count - ) 
507b .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
509f			 
509f			; some direct memory words 
509f			; strncpy ( len t f -- t ) 
509f			 
509f .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5100			 
5100 .. 00		start1:     	db ": bpon $0000 bp ;",0 
5112 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
5125			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
5125 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
517d .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
51dd			 
51dd			 
51dd			; a handy word to list items on the stack 
51dd			 
51dd .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
523c			 
523c			 
523c			; test stack  
523c			; rnd8 stest 
523c			 
523c .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
52b3			 
52b3			; random malloc and free cycles 
52b3			 
52b3 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5368			 
5368			; fixed malloc and free cycles 
5368			 
5368 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
540b			 
540b			; fixed double string push and drop cycle  
540b			 
540b .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
54c0			 
54c0			; consistent fixed string push and drop cycle  
54c0			 
54c0 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5564			 
5564 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
561a			 
561a			;test1:		db ": aa 1 2 3 ;", 0 
561a			;test2:     	db "111 aa 888 999",0 
561a			;test3:     	db ": bb 77 ;",0 
561a			;test4:     	db "$02 $01 do i . loop bb",0 
561a			 
561a .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5652 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
568a .. 00		test7:     	db ": box hline vline ;",0 
569e .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
56ca .. 00		test9:     	db ": sw $01 adsp world ;",0 
56e0 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5705 .. 00		test11:     	db "hello create .",0 
5714 .. 00		test12:     	db "hello2 create .",0 
5724			 
5724			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5724			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5724			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5724			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5724			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5724			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5724			 
5724			;iftest1:     	db "$0001 IF cls .",0 
5724			;iftest2:     	db "$0000 IF cls .",0 
5724			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5724			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5724			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5724			 
5724			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5724			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5724			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5724			 
5724			 
5724			 
5724			; a small guess the number game 
5724			 
5724 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5735 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5797			 
5797 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
57cc .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5802 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5833 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5847 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
585c .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5890 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
58d4			 
58d4			; Using 'ga' save a high score across multiple runs using external storage 
58d4			 
58d4 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
593d			 
593d			 
593d			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
593d			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
593d			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
593d			 
593d			; simple screen saver to test code memory reuse to destruction 
593d			 
593d .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5973 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
598f .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
59ab .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
59c4 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5a0c .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5a63			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5a63			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5a63			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5a63			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5a63			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5a63			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5a63			 
5a63			 
5a63			 
5a63			; minesweeper/battleship finding game 
5a63			; draws a game board of random ship/mine positions 
5a63			; user enters coords to see if it hits on 
5a63			; game ends when all are hit 
5a63			; when hit or miss says how many may be in the area 
5a63			 
5a63			; setup the game board and then hide it 
5a63 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5ad1 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5b1b			; prompt for where to target 
5b1b .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5bb1 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5bd6			; TODO see if the entered coords hits or misses pushes char hit of miss 
5bd6 .. 00		game2mbht:      db ": mbckht nop ;",0 
5be5 .. 00		game2mbms:      db ": mbcms nop ;",0 
5bf3			; TODO how many might be near by 
5bf3 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5c70			 
5c70			; Game 3 
5c70			 
5c70			; Vert scroller ski game - avoid the trees! 
5c70			 
5c70			; v0 score (ie turns) 
5c70			; v1 player pos 
5c70			; v2 left wall 
5c70			; v3 right wall 
5c70			 
5c70			; Draw side walls randomly 
5c70			 
5c70 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5c9e			 
5c9e			; Draw player 
5c9e .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5cbc			 
5cbc			; TODO Get Key 
5cbc			 
5cbc			; TODO Move left right 
5cbc			 
5cbc			; scroll and move walls a bit 
5cbc			 
5cbc .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5ced			 
5ced			; main game loop 
5ced			 
5ced .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5d19 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5d58			 
5d58			; key board defs 
5d58			 
5d58 .. 00		keyup:       db ": keyup $05 ;",0 
5d66 .. 00		keydown:       db ": keydown $0a ;",0 
5d76 .. 00		keyleft:       db ": keyleft $0b ;",0 
5d86 .. 00		keyright:       db ": keyright $0c ;",0 
5d97 .. 00		keyf1:       db ": keyf1 $10 ;",0 
5da5 .. 00		keyf2:       db ": keyf2 $11 ;",0 
5db3 .. 00		keyf3:       db ": keyf3 $12 ;",0 
5dc1 .. 00		keyf4:       db ": keyf4 $13 ;",0 
5dcf .. 00		keyf5:       db ": keyf5 $14 ;",0 
5ddd .. 00		keyf6:       db ": keyf6 $15 ;",0 
5deb .. 00		keyf7:       db ": keyf7 $16 ;",0 
5df9 .. 00		keyf8:       db ": keyf8 $17 ;",0 
5e07 .. 00		keyf9:       db ": keyf9 $18 ;",0 
5e15 .. 00		keyf10:       db ": keyf10 $19 ;",0 
5e24 .. 00		keyf11:       db ": keyf11 $1a ;",0 
5e33 .. 00		keyf12:       db ": keyf12 $1b ;",0 
5e42			 
5e42 .. 00		keytab:       db ": keytab $09 ;",0 
5e51 .. 00		keycr:       db ": keycr $0d ;",0 
5e5f .. 00		keyhome:       db ": keyhome $0e ;",0 
5e6f .. 00		keyend:       db ": keyend $0f ;",0 
5e7e .. 00		keybs:       db ": keybs $08 ;",0 
5e8c			 
5e8c			   
5e8c			 
5e8c			 
5e8c			 
5e8c			; eof 
# End of file forth_autostart.asm
5e8c			 
5e8c .. 00		sprompt1: db "Startup load...",0 
5e9c .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5eb2			 
5eb2			forth_startup: 
5eb2 21 ea 4f			ld hl, startcmds 
5eb5 3e 00			ld a, 0 
5eb7 32 de f3			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
5eba			 
5eba e5			.start1:	push hl 
5ebb cd 8c 0a			call clear_display 
5ebe 11 8c 5e			ld de, sprompt1 
5ec1 3e 00		        ld a, display_row_1 
5ec3 cd 9f 0a			call str_at_display 
5ec6 11 9c 5e			ld de, sprompt2 
5ec9 3e 14		        ld a, display_row_2 
5ecb cd 9f 0a			call str_at_display 
5ece e1				pop hl 
5ecf e5				push hl 
5ed0 5e				ld e,(hl) 
5ed1 23				inc hl 
5ed2 56				ld d,(hl) 
5ed3 3e 28		        ld a, display_row_3 
5ed5 cd 9f 0a			call str_at_display 
5ed8 cd af 0a			call update_display 
5edb			 
5edb			 
5edb 3a de f3			ld a, (os_last_cmd) 
5ede fe 00			cp 0 
5ee0 28 05			jr z, .startprompt 
5ee2 cd 2e 0a			call delay250ms 
5ee5 18 24			jr .startdo 
5ee7				 
5ee7				 
5ee7			 
5ee7			.startprompt: 
5ee7			 
5ee7 3e 4f			ld a,display_row_4 + display_cols - 1 
5ee9 11 e4 19		        ld de, endprg 
5eec cd 9f 0a			call str_at_display 
5eef cd af 0a			call update_display 
5ef2 cd 3a 0a			call delay1s 
5ef5 cd 38 63			call cin_wait 
5ef8						 
5ef8 fe 2a			cp '*' 
5efa 28 5e			jr z, .startupend1 
5efc fe 23			cp '#' 
5efe 20 07			jr nz, .startno 
5f00 3e 01			ld a, 1 
5f02 32 de f3			ld (os_last_cmd),a 
5f05 18 04			jr .startdo 
5f07 fe 31		.startno:	cp '1' 
5f09 28 3a			jr z,.startnxt  
5f0b			 
5f0b				; exec startup line 
5f0b			.startdo:	 
5f0b e1				pop hl 
5f0c e5				push hl 
5f0d				 
5f0d 5e				ld e,(hl) 
5f0e 23				inc hl 
5f0f 56				ld d,(hl) 
5f10 eb				ex de,hl 
5f11			 
5f11 e5				push hl 
5f12			 
5f12 3e 00			ld a, 0 
5f14				;ld a, FORTH_END_BUFFER 
5f14 cd 25 11			call strlent 
5f17 23				inc hl   ; include zero term to copy 
5f18 06 00			ld b,0 
5f1a 4d				ld c,l 
5f1b e1				pop hl 
5f1c 11 b8 ef			ld de, scratch 
5f1f ed b0			ldir 
5f21			 
5f21			 
5f21 21 b8 ef			ld hl, scratch 
5f24 cd ad 1c			call forthparse 
5f27 cd ed 1c			call forthexec 
5f2a cd 04 1c			call forthexec_cleanup 
5f2d			 
5f2d 3e 3c			ld a, display_row_4 
5f2f 11 88 17			ld de, endprog 
5f32			 
5f32 cd af 0a			call update_display		 
5f35			 
5f35 3a de f3			ld a, (os_last_cmd) 
5f38 fe 00			cp 0 
5f3a 20 09			jr nz, .startnxt 
5f3c cd e6 19			call next_page_prompt 
5f3f cd 8c 0a		        call clear_display 
5f42 cd af 0a			call update_display		 
5f45			 
5f45				; move onto next startup line? 
5f45			.startnxt: 
5f45			 
5f45 cd 2e 0a			call delay250ms 
5f48 e1				pop hl 
5f49			 
5f49 23				inc hl 
5f4a 23				inc hl 
5f4b			 
5f4b e5				push hl 
5f4c 5e				ld e, (hl) 
5f4d 23				inc hl 
5f4e 56				ld d, (hl) 
5f4f e1				pop hl 
5f50				; TODO replace 0 test 
5f50			 
5f50 eb				ex de, hl 
5f51 cd e5 0c			call ishlzero 
5f54			;	ld a,e 
5f54			;	add d 
5f54			;	cp 0    ; any left to do? 
5f54 eb				ex de, hl 
5f55 c2 ba 5e			jp nz, .start1 
5f58 18 01			jr .startupend 
5f5a			 
5f5a e1			.startupend1: pop hl 
5f5b			.startupend: 
5f5b			 
5f5b cd 8c 0a			call clear_display 
5f5e cd af 0a			call update_display 
5f61 c9				ret 
5f62			 
5f62			 
5f62			; stack over and underflow checks 
5f62			 
5f62			; init the words to detect the under/overflow 
5f62			 
5f62			chk_stk_init: 
5f62				; a vague random number to check so we dont get any "lucky" hits 
5f62 3e 2d			ld a, 45 
5f64 6f				ld l, a 
5f65 00				nop 
5f66 3e 17			ld a, 23 
5f68 67				ld h, a 
5f69			 
5f69 22 ad ef			ld (chk_word), hl     ; the word we need to check against 
5f6c			 
5f6c			;	ld (chk_stund), hl	; stack points.... 
5f6c 22 fd fb			ld (chk_stovr), hl 
5f6f 22 a3 f9			ld (chk_ret_und), hl 
5f72 22 21 f9			ld (chk_ret_ovr), hl 
5f75 22 1f f7			ld (chk_loop_ovr), hl 
5f78 22 1d f5			ld (chk_data_ovr), hl 
5f7b c9				ret 
5f7c				 
5f7c			check_stacks: 
5f7c				; check all stack words 
5f7c			 
5f7c e5				push hl 
5f7d d5				push de 
5f7e			 
5f7e			;	ld de,(chk_word) 
5f7e			;	ld hl, (chk_stund)	; stack points.... 
5f7e			;	if DEBUG_STK_FAULT 
5f7e			;		DMARK "FAa" 
5f7e			;		CALLMONITOR 
5f7e			;	endif 
5f7e			;	call cmp16 
5f7e			;	jp z, .chk_faulta 
5f7e			; 
5f7e			;	ld de, sfaultsu 
5f7e			;	jp .chk_fault 
5f7e			 
5f7e 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
5f81 ed 5b ad ef		ld de,(chk_word) 
5f85				if DEBUG_STK_FAULT 
5f85					DMARK "FAb" 
5f85					CALLMONITOR 
5f85				endif 
5f85 cd da 0c			call cmp16 
5f88 28 06			jr z, .chk_fault1 
5f8a 11 2b 60			ld de, sfaultso 
5f8d c3 df 5f			jp .chk_fault 
5f90			.chk_fault1:  
5f90 2a a3 f9			ld hl, (chk_ret_und) 
5f93 ed 5b ad ef		ld de,(chk_word) 
5f97				if DEBUG_STK_FAULT 
5f97					DMARK "FAU" 
5f97					CALLMONITOR 
5f97				endif 
5f97 cd da 0c			call cmp16 
5f9a ca a3 5f			jp z, .chk_fault2 
5f9d 11 3b 60			ld de, sfaultru 
5fa0 c3 df 5f			jp .chk_fault 
5fa3			.chk_fault2:  
5fa3 2a 21 f9			ld hl, (chk_ret_ovr) 
5fa6 ed 5b ad ef		ld de,(chk_word) 
5faa				if DEBUG_STK_FAULT 
5faa					DMARK "FA1" 
5faa					CALLMONITOR 
5faa				endif 
5faa cd da 0c			call cmp16 
5fad ca b6 5f			jp z, .chk_fault3 
5fb0 11 49 60			ld de, sfaultro 
5fb3 c3 df 5f			jp .chk_fault 
5fb6			.chk_fault3:  
5fb6 2a 1f f7			ld hl, (chk_loop_ovr) 
5fb9 ed 5b ad ef		ld de,(chk_word) 
5fbd				if DEBUG_STK_FAULT 
5fbd					DMARK "FA2" 
5fbd					CALLMONITOR 
5fbd				endif 
5fbd cd da 0c			call cmp16 
5fc0 ca c9 5f			jp z, .chk_fault4 
5fc3 11 63 60			ld de, sfaultlo 
5fc6 c3 df 5f			jp .chk_fault 
5fc9			.chk_fault4:  
5fc9 2a 1d f5			ld hl, (chk_data_ovr) 
5fcc ed 5b ad ef		ld de,(chk_word) 
5fd0				if DEBUG_STK_FAULT 
5fd0					DMARK "FA3" 
5fd0					CALLMONITOR 
5fd0				endif 
5fd0 cd da 0c			call cmp16 
5fd3 ca dc 5f			jp z, .chk_fault5 
5fd6 11 7d 60			ld de, sfaultdo 
5fd9 c3 df 5f			jp .chk_fault 
5fdc			 
5fdc			 
5fdc			.chk_fault5:  
5fdc d1				pop de 
5fdd e1				pop hl 
5fde			 
5fde c9				ret 
5fdf			 
5fdf cd 8c 0a		.chk_fault: 	call clear_display 
5fe2 3e 14				ld a, display_row_2 
5fe4 cd 9f 0a				call str_at_display 
5fe7 11 0d 60				   ld de, .stackfault 
5fea 3e 00				ld a, display_row_1 
5fec cd 9f 0a				call str_at_display 
5fef 11 bd fb				    ld de, debug_mark 
5ff2 3e 11				ld a, display_row_1+17 
5ff4 cd 9f 0a				call str_at_display 
5ff7 cd af 0a				call update_display 
5ffa			 
5ffa				; prompt before entering montior for investigating issue 
5ffa			 
5ffa 3e 3c			ld a, display_row_4 
5ffc 11 88 17			ld de, endprog 
5fff			 
5fff cd af 0a			call update_display		 
6002			 
6002 cd e6 19			call next_page_prompt 
6005			 
6005 d1				pop de 
6006 e1				pop hl 
6007 cd dc 17				call monitor 
600a c3 c9 16				jp warmstart 
600d					;jp 0 
600d					;halt 
600d			 
600d			 
600d			 
600d .. 00		.stackfault: 	db "Stack fault:",0 
601a			 
601a .. 00		sfaultsu: 	db	"Stack under flow",0 
602b .. 00		sfaultso: 	db	"Stack over flow",0 
603b .. 00		sfaultru:	db "RTS underflow",0 
6049 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6063 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
607d .. 00		sfaultdo:	db "DTS overflow", 0 
608a			 
608a			 
608a			fault_dsp_under: 
608a 11 9c 60			ld de, .dsp_under 
608d c3 4c 61			jp .show_fault 
6090			 
6090			fault_rsp_under: 
6090 11 aa 60			ld de, .rsp_under 
6093 c3 4c 61			jp .show_fault 
6096			fault_loop_under: 
6096 11 b8 60			ld de, .loop_under 
6099 c3 4c 61			jp .show_fault 
609c			 
609c .. 00		.dsp_under: db "DSP Underflow",0 
60aa .. 00		.rsp_under: db "RSP Underflow",0 
60b8 .. 00		.loop_under: db "LOOP Underflow",0 
60c7			 
60c7			 
60c7 d5			type_faultn: 	push de 
60c8 e5					push hl 
60c9 cd 8c 0a				call clear_display 
60cc 11 f3 60				   ld de, .typefaultn 
60cf 3e 00				ld a, display_row_1 
60d1 cd 9f 0a				call str_at_display 
60d4 11 bd fb				    ld de, debug_mark 
60d7 3e 11				ld a, display_row_1+17 
60d9 cd 9f 0a				call str_at_display 
60dc cd af 0a				call update_display 
60df			 
60df				; prompt before entering montior for investigating issue 
60df			 
60df 3e 3c			ld a, display_row_4 
60e1 11 88 17			ld de, endprog 
60e4			 
60e4 cd af 0a			call update_display		 
60e7			 
60e7 cd e6 19			call next_page_prompt 
60ea			 
60ea e5					push hl 
60eb d5					push de 
60ec cd dc 17				call monitor 
60ef c3 c9 16				jp warmstart 
60f2 76					halt 
60f3			 
60f3			 
60f3 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
610a			 
610a d5			type_faults: 	push de 
610b e5					push hl 
610c cd 8c 0a				call clear_display 
610f 11 35 61				   ld de, .typefaults 
6112 3e 00				ld a, display_row_1 
6114 cd 9f 0a				call str_at_display 
6117 11 bd fb				    ld de, debug_mark 
611a 3e 11				ld a, display_row_1+17 
611c cd 9f 0a				call str_at_display 
611f cd af 0a				call update_display 
6122			 
6122				; prompt before entering montior for investigating issue 
6122			 
6122 3e 3c			ld a, display_row_4 
6124 11 88 17			ld de, endprog 
6127			 
6127 cd af 0a			call update_display		 
612a			 
612a cd e6 19			call next_page_prompt 
612d			 
612d e1					pop hl 
612e d1					pop de 
612f cd dc 17				call monitor 
6132 c3 c9 16				jp warmstart 
6135			 
6135			 
6135 .. 00		.typefaults: db "STR Type Expected TOS!",0 
614c			 
614c			.show_fault: 	 
614c d5					push de 
614d cd 8c 0a				call clear_display 
6150 d1					pop de 
6151 3e 00				ld a, display_row_1 
6153 cd 9f 0a				call str_at_display 
6156 11 bd fb				    ld de, debug_mark 
6159 3e 11				ld a, display_row_1+17 
615b cd 9f 0a				call str_at_display 
615e cd af 0a				call update_display 
6161			 
6161				; prompt before entering montior for investigating issue 
6161			 
6161 3e 3c			ld a, display_row_4 
6163 11 88 17			ld de, endprog 
6166			 
6166 cd af 0a			call update_display		 
6169			 
6169 cd e6 19			call next_page_prompt 
616c			 
616c e1					pop hl 
616d d1					pop de 
616e cd dc 17				call monitor 
6171			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6171			; TODO Make optional fault restart to cli or warm boot? 
6171					;jp warmstart 
6171 c3 21 17				jp cli 
6174 76					halt 
6175			; eof 
# End of file forth_kernel.asm
6175			;include "nascombasic.asm" 
6175			 
6175			 
6175			; find out where the code ends if loaded into RAM (for SC114) 
6175			;endofcode:  
6175			;	nop 
6175			 
6175			 
6175			; eof 
6175			 
# End of file main.asm
6175			include "firmware_lcd_4x20.asm" 
6175			; **********************************************************************  
6175			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6175			; **********************************************************************  
6175			;  
6175			; **  Written as a Small Computer Monitor App  
6175			; **  www.scc.me.uk  
6175			;  
6175			; History  
6175			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6175			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6175			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6175			;  
6175			; **********************************************************************  
6175			;  
6175			; This program is an example of one of the methods of interfacing an   
6175			; alphanumeric LCD module.   
6175			;  
6175			; In this example the display is connected to either a Z80 PIO or a   
6175			; simple 8-bit output port.   
6175			;  
6175			; This interfacing method uses 4-bit data mode and uses time delays  
6175			; rather than polling the display's ready status. As a result the   
6175			; interface only requires 6 simple output lines:  
6175			;   Output bit 0 = not used  
6175			;   Output bit 1 = not used  
6175			;   Output bit 2 = RS         High = data, Low = instruction  
6175			;   Output bit 3 = E          Active high  
6175			;   Output bit 4 = DB4  
6175			;   Output bit 5 = DB5  
6175			;   Output bit 6 = DB6  
6175			;   Output bit 7 = DB7  
6175			; Display's R/W is connected to 0v so it is always in write mode  
6175			;  
6175			; This set up should work with any system supporting the RC2014 bus  
6175			  
6175			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6175			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6175			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6175			;  
6175			; **********************************************************************  
6175			  
6175			; **********************************************************************  
6175			; **  Constants  
6175			; **********************************************************************  
6175			; LCD constants required by LCD support module  
6175			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6175			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6175			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
6175			kLCDWidth:  EQU display_cols             ;Width in characters  
6175			  
6175			; **********************************************************************  
6175			; **  Code library usage  
6175			; **********************************************************************  
6175			  
6175			; send character to current cursor position  
6175			; wraps and/or scrolls screen automatically  
6175			  
6175			  
6175			lcd_init:  
6175			  
6175			; SCMonAPI functions used  
6175			  
6175			; Alphanumeric LCD functions used  
6175			; no need to specify specific functions for this module  
6175			  
6175 3e cf		            LD   A, 11001111b  
6177 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
6179 3e 00		            LD   A, 00000000b  
617b d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
617d			  
617d			; Initialise alphanumeric LCD module  
617d cd f6 61		            CALL fLCD_Init      ;Initialise LCD module  
6180			  
6180 c9				ret  
6181			  
6181			;  
6181			;;  
6181			; lcd functions  
6181			;  
6181			;  
6181			  
6181			; what is at cursor position   
6181			  
6181			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6181			;		call curptr  
6181			;		ret  
6181			  
6181			  
6181			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6181			  
6181			curptr:  
6181 c5				push bc  
6182 21 53 fb			ld hl, display_fb0  
6185			cpr:	  
6185				; loop for cursor whole row  
6185 0e 14			ld c, display_cols  
6187 23			cpr1:	inc hl  
6188 0d				dec c  
6189 20 fc			jr nz, cpr1  
618b 05				dec b  
618c 20 f7			jr nz, cpr  
618e			  
618e				; add col	  
618e			  
618e 23			cpr2:	inc hl  
618f 1d				dec e  
6190 20 fc			jr nz, cpr2  
6192			  
6192 c1				pop bc  
6193 c9				ret  
6194				  
6194			  
6194			  
6194			  
6194			  
6194			; write the frame buffer given in hl to hardware   
6194 22 5b fa		write_display: ld (display_write_tmp), hl 	   
6197 3e 00			ld a, kLCD_Line1  
6199 cd 67 62		            CALL fLCD_Pos       ;Position cursor to location in A  
619c 06 14			ld b, display_cols  
619e ed 5b 5b fa		ld de, (display_write_tmp)  
61a2 cd ee 61			call write_len_string  
61a5				  
61a5				  
61a5 2a 5b fa			ld hl, (display_write_tmp)  
61a8 11 14 00			ld de, display_cols  
61ab 19				add hl,de  
61ac 22 5b fa			ld (display_write_tmp),hl  
61af			  
61af				  
61af 3e 40			ld a, kLCD_Line2  
61b1 cd 67 62		            CALL fLCD_Pos       ;Position cursor to location in A  
61b4 06 14			ld b, display_cols  
61b6 ed 5b 5b fa		ld de, (display_write_tmp)  
61ba cd ee 61			call write_len_string  
61bd				  
61bd 2a 5b fa			ld hl, (display_write_tmp)  
61c0 11 14 00			ld de, display_cols  
61c3 19				add hl,de  
61c4 22 5b fa			ld (display_write_tmp),hl  
61c7			  
61c7				  
61c7 3e 14			ld a, kLCD_Line3  
61c9 cd 67 62		            CALL fLCD_Pos       ;Position cursor to location in A  
61cc 06 14			ld b, display_cols  
61ce ed 5b 5b fa		ld de, (display_write_tmp)  
61d2 cd ee 61			call write_len_string  
61d5				  
61d5 2a 5b fa			ld hl, (display_write_tmp)  
61d8 11 14 00			ld de, display_cols  
61db 19				add hl,de  
61dc 22 5b fa			ld (display_write_tmp),hl  
61df			  
61df				  
61df 3e 54			ld a, kLCD_Line4  
61e1 cd 67 62		            CALL fLCD_Pos       ;Position cursor to location in A  
61e4 06 14			ld b, display_cols  
61e6 ed 5b 5b fa		ld de, (display_write_tmp)  
61ea cd ee 61			call write_len_string  
61ed c9					ret  
61ee				  
61ee				; write out a fixed length string given in b from de  
61ee			  
61ee 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
61ef cd 40 62		            CALL fLCD_Data      ;Write character to display  
61f2 13				inc de  
61f3 10 f9			djnz write_len_string  
61f5 c9				ret  
61f6			  
61f6			; Some other things to do  
61f6			;            LD   A, kLCD_Clear ;Display clear  
61f6			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
61f6			;            LD   A, kLCD_Under ;Display on with underscore cursor  
61f6			;            LD   A, kLCD_On     ;Display on with no cursor  
61f6			;            ;LD   A, kLCD_Off   ;Display off  
61f6			;            CALL fLCD_Inst      ;Send instruction to display  
61f6			;  
61f6			;  
61f6			;            halt  
61f6			;  
61f6			;  
61f6			;MsgHello:   DB  "Hello World!",0  
61f6			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
61f6			  
61f6			; Custom characters 5 pixels wide by 8 pixels high  
61f6			; Up to 8 custom characters can be defined  
61f6			;BitMaps:      
61f6			;; Character 0x00 = Battery icon  
61f6			;            DB  01110b  
61f6			;            DB  11011b  
61f6			;            DB  10001b  
61f6			;            DB  10001b  
61f6			;            DB  11111b  
61f6			;            DB  11111b  
61f6			;            DB  11111b  
61f6			;            DB  11111b  
61f6			;; Character 0x01 = Bluetooth icon  
61f6			;            DB  01100b  
61f6			;            DB  01010b  
61f6			;            DB  11100b  
61f6			;            DB  01000b  
61f6			;            DB  11100b  
61f6			;            DB  01010b  
61f6			;            DB  01100b  
61f6			;            DB  00000b  
61f6			;  
61f6			  
61f6			  
61f6			; **********************************************************************  
61f6			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
61f6			; **********************************************************************  
61f6			;  
61f6			; **  Written as a Small Computer Monitor App   
61f6			; **  Version 0.1 SCC 2018-05-16  
61f6			; **  www.scc.me.uk  
61f6			;  
61f6			; **********************************************************************  
61f6			;  
61f6			; This module provides support for alphanumeric LCD modules using with  
61f6			; *  HD44780 (or compatible) controller  
61f6			; *  5 x 7 pixel fonts  
61f6			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
61f6			; *  Interface via six digital outputs to the display (see below)  
61f6			;  
61f6			; LCD module pinout:  
61f6			;   1  Vss   0v supply  
61f6			;   2  Vdd   5v supply  
61f6			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
61f6			;   4  RS    High = data, Low = instruction  
61f6			;   5  R/W   High = Read, Low = Write  
61f6			;   6  E     Enable signal (active high)  
61f6			;   7  DB0   Data bit 0  
61f6			;   8  DB1   Data bit 1  
61f6			;   9  DB2   Data bit 2  
61f6			;  10  DB3   Data bit 3  
61f6			;  11  DB4   Data bit 4  
61f6			;  12  DB5   Data bit 5  
61f6			;  13  DB6   Data bit 6  
61f6			;  14  DB7   Data bit 7  
61f6			;  15  A     Backlight anode (+)  
61f6			;  16  K     Backlight cathode (-)  
61f6			;  
61f6			; This interfacing method uses 4-bit data mode and uses time delays  
61f6			; rather than polling the display's ready status. As a result the   
61f6			; interface only requires 6 simple output lines:  
61f6			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
61f6			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
61f6			;   LCD DB4 = Microcomputer output port bit 4  
61f6			;   LCD DB5 = Microcomputer output port bit 5  
61f6			;   LCD DB6 = Microcomputer output port bit 6  
61f6			;   LCD DB7 = Microcomputer output port bit 7  
61f6			; Display's R/W is connected to 0v so it is always in write mode  
61f6			; All 6 connections must be on the same port address <kLCDPrt>  
61f6			; This method also allows a decent length of cable from micro to LCD  
61f6			;  
61f6			; **********************************************************************  
61f6			;  
61f6			; To include the code for any given function provided by this module,   
61f6			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
61f6			; the parent source file.  
61f6			; For example:  #REQUIRES   uHexPrefix  
61f6			;  
61f6			; Also #INCLUDE this file at some point after the #REQUIRES statements  
61f6			; in the parent source file.  
61f6			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
61f6			;  
61f6			; These are the function names provided by this module:  
61f6			; fLCD_Init                     ;Initialise LCD  
61f6			; fLCD_Inst                     ;Send instruction to LCD  
61f6			; fLCD_Data                     ;Send data byte to LCD  
61f6			; fLCD_Pos                      ;Position cursor  
61f6			; fLCD_Str                      ;Display string  
61f6			; fLCD_Def                      ;Define custom character  
61f6			;  
61f6			; **********************************************************************  
61f6			;  
61f6			; Requires SCMonAPI.asm to also be included in the project  
61f6			;  
61f6			  
61f6			  
61f6			; **********************************************************************  
61f6			; **  Constants  
61f6			; **********************************************************************  
61f6			  
61f6			; Constants that must be defined externally  
61f6			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
61f6			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
61f6			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
61f6			;kLCDWidth: EQU 20             ;Width in characters  
61f6			  
61f6			; general line offsets in any frame buffer  
61f6			  
61f6			  
61f6			display_row_1: equ 0  
61f6			display_row_2: equ display_row_1+display_cols  
61f6			display_row_3: equ display_row_2 + display_cols  
61f6			display_row_4: equ display_row_3 + display_cols  
61f6			;display_row_4_eol:   
61f6			  
61f6			  
61f6			; Cursor position values for the start of each line  
61f6			kLCD_Line1: EQU 0x00   
61f6			kLCD_Line2: EQU 0x40    
61f6			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
61f6			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
61f6			  
61f6			; Instructions to send as A register to fLCD_Inst  
61f6			kLCD_Clear: EQU 00000001b     ;LCD clear  
61f6			kLCD_Off:   EQU 00001000b     ;LCD off  
61f6			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
61f6			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
61f6			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
61f6			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
61f6			  
61f6			; Constants used by this code module  
61f6			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
61f6			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
61f6			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
61f6			  
61f6			  
61f6			  
61f6			; **********************************************************************  
61f6			; **  LCD support functions  
61f6			; **********************************************************************  
61f6			  
61f6			; Initialise alphanumeric LCD module  
61f6			; LCD control register codes:  
61f6			;   DL   0 = 4-bit mode        1 = 8-bit mode  
61f6			;   N    0 = 1-line mode       1 = 2-line mode  
61f6			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
61f6			;   D    0 = Display off       1 = Display on  
61f6			;   C    0 = Cursor off        1 = Cursor on  
61f6			;   B    0 = Blinking off      1 = Blinking on  
61f6			;   ID   0 = Decrement mode    1 = Increment mode  
61f6			;   SH   0 = Entire shift off  1 = Entire shift on  
61f6 3e 28		fLCD_Init:  LD   A, 40  
61f8 cd ad 62		            CALL LCDDelay       ;Delay 40ms after power up  
61fb			; For reliable reset set 8-bit mode - 3 times  
61fb cd 97 62		            CALL WrFn8bit       ;Function = 8-bit mode  
61fe cd 97 62		            CALL WrFn8bit       ;Function = 8-bit mode  
6201 cd 97 62		            CALL WrFn8bit       ;Function = 8-bit mode  
6204			; Set 4-bit mode  
6204 cd 93 62		            CALL WrFn4bit       ;Function = 4-bit mode  
6207 cd ab 62		            CALL LCDDelay1      ;Delay 37 us or more  
620a			; Function set  
620a 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
620c cd 1f 62		            CALL fLCD_Inst      ;2 line, display on  
620f			; Display On/Off control  
620f 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6211 cd 1f 62		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6214			; Display Clear  
6214 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6216 cd 1f 62		            CALL fLCD_Inst      ;Clear display  
6219			; Entry mode  
6219 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
621b cd 1f 62		            CALL fLCD_Inst      ;Increment mode, shift off  
621e			; Display module now initialised  
621e c9			            RET  
621f			; ok to here  
621f			  
621f			; Write instruction to LCD  
621f			;   On entry: A = Instruction byte to be written  
621f			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
621f f5			fLCD_Inst:  PUSH AF  
6220 f5			            PUSH AF  
6221 cd 33 62		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6224 f1			            POP  AF  
6225 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6226 17			            RLA  
6227 17			            RLA  
6228 17			            RLA  
6229 cd 33 62		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
622c 3e 02		            LD   A, 2  
622e cd ad 62		            CALL LCDDelay       ;Delay 2 ms to complete   
6231 f1			            POP  AF  
6232 c9			            RET  
6233 e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
6235 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6237 cb df		            SET  kLCDBitE, A  
6239 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
623b cb 9f		            RES  kLCDBitE, A  
623d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
623f c9			            RET  
6240			  
6240			  
6240			; Write data to LCD  
6240			;   On entry: A = Data byte to be written  
6240			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6240 f5			fLCD_Data:  PUSH AF  
6241 f5			            PUSH AF  
6242 cd 54 62		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
6245 f1			            POP  AF  
6246 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6247 17			            RLA  
6248 17			            RLA  
6249 17			            RLA  
624a cd 54 62		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
624d 3e 96		            LD   A, 150  
624f 3d			Wait:      DEC  A              ;Wait a while to allow data   
6250 20 fd		            JR   NZ, Wait      ;  write to complete  
6252 f1			            POP  AF  
6253 c9			            RET  
6254 e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
6256 cb d7		            SET  kLCDBitRS, A  
6258 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
625a cb df		            SET  kLCDBitE, A  
625c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
625e cb 9f		            RES  kLCDBitE, A  
6260 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6262 cb 97		            RES  kLCDBitRS, A  
6264 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6266 c9			            RET  
6267			  
6267			  
6267			; Position cursor to specified location  
6267			;   On entry: A = Cursor position  
6267			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6267 f5			fLCD_Pos:   PUSH AF  
6268 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
626a cd 1f 62		            CALL fLCD_Inst      ;Write instruction to LCD  
626d f1			            POP  AF  
626e c9			            RET  
626f			  
626f			  
626f			; Output text string to LCD  
626f			;   On entry: DE = Pointer to null terminated text string  
626f			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
626f 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6270 b7			            OR   A              ;Null terminator?  
6271 c8			            RET  Z              ;Yes, so finished  
6272 cd 40 62		            CALL fLCD_Data      ;Write character to display  
6275 13			            INC  DE             ;Point to next character  
6276 18 f7		            JR   fLCD_Str       ;Repeat  
6278 c9					ret  
6279			  
6279			; Define custom character  
6279			;   On entry: A = Character number (0 to 7)  
6279			;             DE = Pointer to character bitmap data  
6279			;   On exit:  A = Next character number  
6279			;             DE = Next location following bitmap  
6279			;             BC HL IX IY I AF' BC' DE' HL' preserved  
6279			; Character is   
6279 c5			fLCD_Def:   PUSH BC  
627a f5			            PUSH AF  
627b 07			            RLCA                ;Calculate location  
627c 07			            RLCA                ;  for bitmap data  
627d 07			            RLCA                ;  = 8 x CharacterNumber  
627e f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6280 cd 1f 62		            CALL fLCD_Inst      ;Write instruction to LCD  
6283 06 00		            LD   B, 0  
6285 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
6286 cd 40 62		            CALL fLCD_Data      ;Write byte to display  
6289 13			            INC  DE             ;Point to next byte  
628a 04			            INC  B              ;Count bytes  
628b cb 58		            BIT  3, B           ;Finish all 8 bytes?  
628d 28 f6		            JR   Z, Loop       ;No, so repeat  
628f f1			            POP  AF  
6290 3c			            INC  A              ;Increment character number  
6291 c1			            POP  BC  
6292 c9			            RET  
6293			  
6293			  
6293			; **********************************************************************  
6293			; **  Private functions  
6293			; **********************************************************************  
6293			  
6293			; Write function to LCD  
6293			;   On entry: A = Function byte to be written  
6293			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6293 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6295 18 02		            JR   WrFunc  
6297 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6299 f5			WrFunc:     PUSH AF  
629a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
629c cb df		            SET  kLCDBitE, A  
629e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
62a0 cb 9f		            RES  kLCDBitE, A  
62a2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
62a4 3e 05		            LD   A, 5  
62a6 cd ad 62		            CALL LCDDelay       ;Delay 5 ms to complete  
62a9 f1			            POP  AF  
62aa c9			            RET  
62ab			  
62ab			  
62ab			; Delay in milliseconds  
62ab			;   On entry: A = Number of milliseconds delay  
62ab			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
62ab 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
62ad d5			LCDDelay:   PUSH DE  
62ae 5f			            LD   E, A           ;Delay by 'A' ms  
62af 16 00		            LD   D, 0  
62b1 cd 1f 0a		            CALL aDelayInMS  
62b4 d1			            POP  DE  
62b5 c9			            RET  
62b6			  
62b6			  
62b6			  
62b6			  
62b6			; eof  
62b6			  
# End of file firmware_lcd_4x20.asm
62b6			include "firmware_key_4x4.asm" 
62b6			  
62b6			  
62b6			; bit mask for each scan column and row for teing the matrix  
62b6			  
62b6			; out   
62b6 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
62ba			; in  
62ba 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
62be			  
62be			; row/col to character map  
62be			  
62be			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
62be			;    
62be			  
62be			; physical key matrix map to face of key  
62be			  
62be			  
62be			;      	1	2	3	A  
62be			;   	abc”	def&	ghi$	s1  
62be			;			  
62be			;	4	5	6	B  
62be			; 	jkl,	mno.	pqr:	s2  
62be			;			  
62be			; 	7	8	9	C  
62be			;	stu;	vwx@	yz?!	s3  
62be			;			  
62be			; 	*	0	#	D  
62be			; 	shift lck '	Space < >	Enter ( )	s4  
62be			;       tab bs 		  
62be			  
62be			  
62be			  
62be			  
62be			key_init:  
62be			  
62be			; SCMonAPI functions used  
62be			  
62be			; Alphanumeric LCD functions used  
62be			; no need to specify specific functions for this module  
62be			  
62be			  
62be 3e cf		            LD   A, 11001111b  
62c0 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
62c2			;            LD   A, 00000000b  
62c2 3e 0f		            LD   A, 00001111b  
62c4 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
62c6			  
62c6			  
62c6				; TODO Configure cursor shapes  
62c6			  
62c6				; Load cursor shapes   
62c6 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
62c8 11 d8 62		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
62cb 06 02		            LD   B, 2           ;Number of characters to define  
62cd cd 79 62		.DefLoop:   CALL fLCD_Def       ;Define custom character  
62d0 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
62d2			  
62d2 3e 01				ld a, 1  
62d4 32 56 fa			ld (cursor_shape),a  
62d7 c9				ret  
62d8			  
62d8			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
62d8			; Up to 8 custom characters can be defined  
62d8			.cursor_shapes:      
62d8			;; Character 0x00 = Normal  
62d8 1f			            DB  11111b  
62d9 1f			            DB  11111b  
62da 1f			            DB  11111b  
62db 1f			            DB  11111b  
62dc 1f			            DB  11111b  
62dd 1f			            DB  11111b  
62de 1f			            DB  11111b  
62df 1f			            DB  11111b  
62e0			;; Character 0x01 = Modifier  
62e0 1f			            DB  11111b  
62e1 1b			            DB  11011b  
62e2 1b			            DB  11011b  
62e3 1b			            DB  11011b  
62e4 1b			            DB  11011b  
62e5 1f			            DB  11111b  
62e6 1b			            DB  11011b  
62e7 1f			            DB  11111b  
62e8			  
62e8			  
62e8			  
62e8			  
62e8			; Display custom character 0  
62e8			;            LD   A, kLCD_Line1+14  
62e8			;            CALL fLCD_Pos       ;Position cursor to location in A  
62e8			;            LD   A, 0  
62e8			;            CALL fLCD_Data      ;Write character in A at cursor  
62e8			  
62e8			; Display custom character 1  
62e8			;            LD   A, kLCD_Line2+14  
62e8			;            CALL fLCD_Pos      ;Position cursor to location in A  
62e8			;            LD   A, 1  
62e8			;            CALL fLCD_Data     ;Write character in A at cursor  
62e8			  
62e8			; keyboard scanning   
62e8			  
62e8			  
62e8			; key_rows: equ 4  
62e8			; key_cols: equ 4  
62e8			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
62e8			  
62e8			; key_scanr: equ key_row_bitmask  
62e8			; key_scanc: equ key_col_bitmask  
62e8			  
62e8			; key_char_map: equ key_map  
62e8			  
62e8			  
62e8			  
62e8			; character in from keyboard  
62e8			  
62e8 ..			.matrix_to_char: db "D#0*C987B654A321"  
62f8			  
62f8			  
62f8			; map the physical key to a char dependant on state  
62f8			  
62f8			.key_map_fa:   
62f8			  
62f8 ..					db 'D'  
62f9 0d					db KEY_CR    ; cr  
62fa ..					db ' '  
62fb 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
62fc ..					db 'C'  
62fd ..					db 'y'  
62fe ..					db 'v'  
62ff ..					db 's'  
6300 ..					db 'B'  
6301 ..					db 'p'  
6302 ..					db 'm'  
6303 ..					db 'j'  
6304 ..					db 'A'  
6305 ..					db 'g'  
6306 ..					db 'd'  
6307 ..					db 'a'  
6308			  
6308			.key_map_fb:  
6308			  
6308 ..					db 'A'  
6309 ..					db '+'   
630a ..					db '<'  
630b ..					db  "'"    
630c			  
630c ..					db 'A'  
630d ..					db 'z'  
630e ..					db 'w'  
630f ..					db 't'  
6310 ..					db 'A'  
6311 ..					db 'q'  
6312 ..					db 'n'  
6313 ..					db 'k'  
6314 ..					db 'A'  
6315 ..					db 'h'  
6316 ..					db 'e'  
6317 ..			 		db 'b'  
6318			  
6318			.key_map_fc:   
6318			  
6318			  
6318 ..					db 'A'  
6319 ..					db '-'   
631a ..					db '>'  
631b ..					db  '='   	  
631c ..					db 'A'  
631d ..					db '?'  
631e ..					db 'x'  
631f ..					db 'u'  
6320 ..					db 'A'  
6321 ..					db 'r'  
6322 ..					db 'o'  
6323 ..					db 'l'  
6324 ..					db 'A'  
6325 ..					db 'i'  
6326 ..					db 'f'  
6327 ..					db 'c'  
6328			  
6328				  
6328			.key_map_fd:  
6328			  
6328 ..					db 'A'  
6329 ..					db '/'   
632a ..					db '%'   
632b 08					db KEY_BS  ; back space  
632c ..					db 'A'  
632d ..					db '!'  
632e ..					db '@'  
632f ..					db ';'  
6330 ..					db 'A'  
6331 ..					db ':'  
6332 ..					db '.'  
6333 ..					db ','  
6334 ..					db 'A'  
6335 ..					db '$'  
6336 ..					db '&'  
6337 ..				 	db '"'  
6338			  
6338					  
6338				  
6338			  
6338			; add cin and cin_wait  
6338			  
6338 cd 49 63		cin_wait: 	call cin  
633b fe 00			cp 0  
633d 28 f9			jr z, cin_wait   ; block until key press  
633f			  
633f f5				push af   ; save key pressed  
6340			  
6340 cd 49 63		.cin_wait1:	call cin  
6343 fe 00			cp 0  
6345 20 f9			jr nz, .cin_wait1  	; wait for key release  
6347			  
6347 f1				pop af   ; get key  
6348 c9				ret  
6349			  
6349			  
6349 cd 5a 63		cin: 	call .mtoc  
634c			  
634c				; no key held  
634c fe 00			cp 0  
634e c8				ret z  
634f			  
634f				; stop key bounce  
634f			  
634f			;	ld (key_held),a		 ; save it  
634f 47				ld b, a  
6350			  
6350 c5			.cina1:	push bc  
6351 cd 5a 63			call .mtoc  
6354 c1				pop bc  
6355 b8				cp b  
6356 28 f8			jr z, .cina1  
6358 78				ld a,b		  
6359 c9				ret  
635a			  
635a			; detect keyboard modifier key press and apply new overlay to the face key held  
635a			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
635a			  
635a			;.cin_map_modifier:   
635a			;	ld a, (hl)  
635a			;	and 255  
635a			;	ret NZ		; modifier key not flagged  
635a			;  
635a			;	; get key face  
635a			;  
635a			;	ld b,(key_face_held)  
635a			;  
635a			;	ld b, key_cols * key_rows  
635a			;  
635a			;	push de  
635a			;	pop hl  
635a			;  
635a			;.mmod1: ld a,(hl)   ; get map test  
635a			;	cp b  
635a			;	jr z, .mmod2  
635a			;  
635a			;  
635a			;  
635a			;.mmod2: inc hl    ;   
635a			;  
635a			;	  
635a			;  
635a			;	  
635a			;  
635a			;	ld hl,key_actual_pressed  
635a			;	ld (hl),a,  
635a			;	ret  
635a			  
635a				  
635a			  
635a			; map matrix key held to char on face of key  
635a			  
635a			.mtoc:  
635a			  
635a			  
635a				; TODO optimise the code....  
635a			  
635a			; scan keyboard row 1  
635a 3e 80			ld a, 128  
635c 21 d3 fb			ld hl, keyscan_table  
635f cd 41 64			call .rowscan  
6362			  
6362				   
6362			  
6362 3e 40			ld a, 64  
6364 21 d7 fb			ld hl, keyscan_table+key_cols  
6367 cd 41 64			call .rowscan  
636a			  
636a			  
636a			  
636a			  
636a 3e 20			ld a, 32  
636c 21 db fb			ld hl, keyscan_table+(key_cols*2)  
636f cd 41 64			call .rowscan  
6372			  
6372			  
6372			  
6372 3e 10			ld a, 16  
6374 21 df fb			ld hl, keyscan_table+(key_cols*3)  
6377 cd 41 64			call .rowscan  
637a			  
637a			  
637a				; flag if key D is held down and remove from reporting  
637a 01 28 63			ld bc, .key_map_fd    
637d 21 d3 fb			ld hl, keyscan_table  
6380 11 c5 fb			ld de, key_fd  
6383 cd d3 63			call .key_shift_hold  
6386 fe ff			cp 255  
6388 28 33			jr z, .cinmap  
638a				; flag if key C is held down and remove from reporting  
638a 01 18 63			ld bc, .key_map_fc    
638d 21 d7 fb			ld hl, keyscan_table+key_cols  
6390 11 c6 fb			ld de, key_fc  
6393 cd d3 63			call .key_shift_hold  
6396 fe ff			cp 255  
6398 28 23			jr z, .cinmap  
639a				; flag if key B is held down and remove from reporting  
639a 01 08 63			ld bc, .key_map_fb    
639d 21 db fb			ld hl, keyscan_table+(key_cols*2)  
63a0 11 c7 fb			ld de, key_fb  
63a3 cd d3 63			call .key_shift_hold  
63a6 fe ff			cp 255  
63a8 28 13			jr z, .cinmap  
63aa				; flag if key A is held down and remove from reporting  
63aa 01 f8 62			ld bc, .key_map_fa    
63ad 21 df fb			ld hl, keyscan_table+(key_cols*3)  
63b0 11 c8 fb			ld de, key_fa  
63b3 cd d3 63			call .key_shift_hold  
63b6 fe ff			cp 255  
63b8 28 03			jr z, .cinmap  
63ba			  
63ba 11 e8 62			ld de, .matrix_to_char  
63bd			  
63bd			  
63bd			.cinmap:   
63bd				if DEBUG_KEY  
63bd			            LD   A, kLCD_Line4  
63bd			            CALL fLCD_Pos       ;Position cursor to location in A  
63bd					push de  
63bd			            LD   DE, keyscan_table  
63bd			            CALL fLCD_Str       ;Display string pointed to by DE  
63bd					pop de  
63bd				endif  
63bd			  
63bd				; scan key matrix table for any held key  
63bd			  
63bd				; de holds either the default matrix or one selected above  
63bd			  
63bd 21 d3 fb			ld hl, keyscan_table  
63c0 06 10			ld b,key_cols*key_rows  
63c2			  
63c2 7e			.cin1:	ld a,(hl)  
63c3 fe 23			cp '#'  
63c5 28 08			jr z, .cinhit  
63c7 23				inc hl  
63c8 13				inc de  
63c9 05				dec b  
63ca 20 f6			jr nz, .cin1  
63cc				; no key found held  
63cc 3e 00			ld a,0  
63ce c9				ret  
63cf d5			.cinhit: push de  
63d0 e1				pop hl  
63d1 7e				ld a,(hl)  
63d2 c9				ret  
63d3			  
63d3			; flag a control key is held   
63d3			; hl is key pin, de is flag indicator  
63d3			  
63d3			.key_shift_hold:  
63d3 c5				push bc  
63d4 3e 01			ld a, 1  
63d6 32 56 fa			ld (cursor_shape),a  
63d9 06 00			ld b, 0  
63db 7e				ld a, (hl)  
63dc fe 2e			cp '.'  
63de 28 0a			jr z, .key_shift1  
63e0 06 ff			ld b, 255  
63e2 3e 2b			ld a, '+'    ; hide key from later scans  
63e4 77				ld (hl),a  
63e5 3e 02			ld a, 2  
63e7 32 56 fa			ld (cursor_shape),a  
63ea			.key_shift1:  
63ea				; write flag indicator  
63ea 78				ld a,b  
63eb 12				ld (de),a  
63ec			  
63ec d1				pop de    ; de now holds the key map ptr  
63ed c9				ret  
63ee			  
63ee				  
63ee				  
63ee			  
63ee			  
63ee			  
63ee			  
63ee			  
63ee			  
63ee			  
63ee			  
63ee			  
63ee			  
63ee c9				ret  
63ef			  
63ef			;	push hl  
63ef			;	push de  
63ef			;	push bc  
63ef			;	call keyscan  
63ef			;	; map key matrix to ascii value of key face  
63ef			;  
63ef			;	ld hl, key_face_map  
63ef			;	ld de, keyscan_table  
63ef			;  
63ef			;	; get how many keys to look at  
63ef			;	ld b, keyscan_table_len  
63ef			;	  
63ef			;  
63ef			;	; at this stage fall out on first key hit  
63ef			;	; TODO handle multiple key press  
63ef			;  
63ef			;map1:	ld a,(hl)  
63ef			;	cp '#'  
63ef			;	jr z, keyhit  
63ef			;	inc hl  
63ef			;	inc de  
63ef			;	dec b  
63ef			;	jr nz, map1  
63ef			;nohit:	ld a, 0  
63ef			;	jr keydone  
63ef			;keyhit: push de  
63ef			;	pop hl  
63ef			;	ld a,(hl)  
63ef			;keydone:  
63ef			;	push bc  
63ef			;	push de  
63ef			; 	push hl  
63ef			;	ret   
63ef			;  
63ef			  
63ef			  
63ef			  
63ef			  
63ef			; scan physical key matrix  
63ef			  
63ef			  
63ef			;keyscan:  
63ef			;  
63ef			;; for each key_row use keyscanr bit mask for out  
63ef			;; then read in for keyscanc bitmask  
63ef			;; save result of row scan to keyscantable  
63ef			;  
63ef			;; scan keyboard row 1  
63ef			;  
63ef			;	ld b, key_rows  
63ef			;	ld hl, key_scanr  
63ef			;	ld de, keyscan_table  
63ef			;  
63ef			;rowloop:  
63ef			;  
63ef			;	ld a,(hl)		; out bit mask to energise keyboard row  
63ef			;	call rowscan  
63ef			;	inc hl  
63ef			;	dec b  
63ef			;	jr nz, rowloop  
63ef			;  
63ef			;	ret  
63ef			;  
63ef			;  
63ef			;; pass a out bitmask, b row number  
63ef			;arowscan:   
63ef			;	push bc  
63ef			;  
63ef			;	ld d, b  
63ef			;  
63ef			;	; calculate buffer location for this row  
63ef			;  
63ef			;	ld hl, keyscan_table	  
63ef			;kbufr:  ld e, key_cols  
63ef			;kbufc:	inc hl  
63ef			;	dec e  
63ef			;	jr nz, kbufc  
63ef			;	dec d  
63ef			;	jr nz, kbufr  
63ef			;  
63ef			;	; energise row and read columns  
63ef			;  
63ef			;	out (portbdata),a  
63ef			;	in a,(portbdata)  
63ef			;	ld c,a  
63ef			;  
63ef			;  
63ef			;	; save buffer loc  
63ef			;  
63ef			;	ld (keybufptr), hl  
63ef			;  
63ef			;	ld hl, key_scanc  
63ef			;	ld d, key_cols  
63ef			;  
63ef			;	; for each column check each bit mask  
63ef			;  
63ef			;colloop:  
63ef			;	  
63ef			;  
63ef			;	; reset flags for the row   
63ef			;  
63ef			;	ld b,'.'  
63ef			;	and (hl)  
63ef			;	jr z, maskskip  
63ef			;	ld b,'#'  
63ef			;maskskip:  
63ef			;	; save  key state  
63ef			;	push hl  
63ef			;	ld hl, (keybufptr)  
63ef			;	ld (hl), b  
63ef			;	inc hl  
63ef			;	ld (keybufptr), hl  
63ef			;  
63ef			;	; move to next bit mask  
63ef			;	pop hl  
63ef			;	inc hl  
63ef			;  
63ef			;	dec d  
63ef			;	jr nz, colloop  
63ef			;  
63ef			;	ret  
63ef			;  
63ef			;  
63ef			;;  
63ef			; lcd functions  
63ef			;  
63ef			;  
63ef			  
63ef			;if DEBUG_KEY_MATRIX  
63ef			  
63ef			; test function to display hardware view of matrix state  
63ef			  
63ef			matrix:  
63ef			  
63ef			  
63ef			  
63ef			; scan keyboard row 1  
63ef 3e 80			ld a, 128  
63f1 21 f8 fb			ld hl, keyscan_table_row1  
63f4 cd 41 64			call .rowscan  
63f7			  
63f7 3e 40			ld a, 64  
63f9 21 f3 fb			ld hl, keyscan_table_row2  
63fc cd 41 64			call .rowscan  
63ff			  
63ff 3e 20			ld a, 32  
6401 21 ee fb			ld hl, keyscan_table_row3  
6404 cd 41 64			call .rowscan  
6407			  
6407 3e 10			ld a, 16  
6409 21 e9 fb			ld hl, keyscan_table_row4  
640c cd 41 64			call .rowscan  
640f			  
640f			; Display text on first line  
640f 3e 00		            LD   A, kLCD_Line1  
6411 cd 67 62		            CALL fLCD_Pos       ;Position cursor to location in A  
6414 11 f8 fb		            LD   DE, keyscan_table_row1  
6417			            ;LD   DE, MsgHello  
6417 cd 6f 62		            CALL fLCD_Str       ;Display string pointed to by DE  
641a			  
641a			; Display text on second line  
641a 3e 40		            LD   A, kLCD_Line2  
641c cd 67 62		            CALL fLCD_Pos       ;Position cursor to location in A  
641f 11 f3 fb		            LD   DE, keyscan_table_row2  
6422 cd 6f 62		            CALL fLCD_Str       ;Display string pointed to by DE  
6425 3e 14		            LD   A, kLCD_Line3  
6427 cd 67 62		            CALL fLCD_Pos       ;Position cursor to location in A  
642a 11 ee fb		            LD   DE, keyscan_table_row3  
642d cd 6f 62		            CALL fLCD_Str       ;Display string pointed to by DE  
6430 3e 54		            LD   A, kLCD_Line4  
6432 cd 67 62		            CALL fLCD_Pos       ;Position cursor to location in A  
6435 11 e9 fb		            LD   DE, keyscan_table_row4  
6438 cd 6f 62		            CALL fLCD_Str       ;Display string pointed to by DE  
643b			  
643b cd 2e 0a			call delay250ms  
643e c3 ef 63			jp matrix  
6441			  
6441			; pass de as row display flags  
6441			.rowscan:   
6441 d3 c1			out (portbdata),a  
6443 db c1			in a,(portbdata)  
6445 4f				ld c,a  
6446				; reset flags for the row   
6446 06 2e			ld b,'.'  
6448 e6 01			and 1  
644a 28 02			jr z, .p1on  
644c 06 23			ld b,'#'  
644e			.p1on:  
644e 70				ld (hl), b  
644f 23				inc hl  
6450			  
6450 06 2e			ld b,'.'  
6452 79				ld a,c  
6453 e6 02			and 2  
6455			;	bit 0,a  
6455 28 02			jr z, .p2on  
6457 06 23			ld b,'#'  
6459			.p2on:  
6459 70				ld (hl), b  
645a 23				inc hl  
645b			;  
645b 06 2e			ld b,'.'  
645d 79				ld a,c  
645e e6 04			and 4  
6460			;;	bit 0,a  
6460 28 02			jr z, .p3on  
6462 06 23			ld b,'#'  
6464			.p3on:  
6464 70				ld (hl), b  
6465 23				inc hl  
6466			;;  
6466 06 2e			ld b,'.'  
6468			;;	bit 0,a  
6468 79				ld a,c  
6469 e6 08			and 8  
646b 28 02			jr z, .p4on  
646d 06 23			ld b,'#'  
646f			.p4on:  
646f 70				ld (hl), b  
6470 23				inc hl  
6471			  
6471			; zero term  
6471 06 00			ld b,0  
6473 70				ld (hl), b  
6474			  
6474 c9			.rscandone: ret  
6475			  
6475			  
6475			  
6475			;endif  
6475			  
6475			  
6475			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
6475
