# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 d7 16			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 0   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext+(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ os_input  
0003			os_new_parse_len: equ os_new_malloc + 2  
0003			os_new_word_len: equ os_new_parse_len + 2  
0003			os_new_work_ptr: equ os_new_word_len + 2  
0003			os_new_src_ptr: equ os_new_work_ptr + 2  
0003			os_new_exec: equ os_new_src_ptr + 2  
0003			os_new_exec_ptr: equ os_new_exec + 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ scratch - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 7d fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 1c fa				ld hl, display_fb1  
000b 22 d8 f8				ld (display_fb_active), hl  
000e			  
000e cd 8f 0a				call clear_display  
0011			  
0011 21 da f8				ld hl, display_fb2  
0014 22 d8 f8				ld (display_fb_active), hl  
0017			  
0017 cd 8f 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 bd fa				ld hl, display_fb0  
001d 22 d8 f8				ld (display_fb_active), hl  
0020			  
0020 cd 8f 0a				call clear_display  
0023			  
0023			  
0023 cd ca 61				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd 61 64			call key_init  
0029 cd cc 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd 62 11				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f cd 1f 13				call sound_init  
0032				endif  
0032			  
0032				; lcd test sequence  
0032					  
0032 cd b2 0a			call update_display  
0035 cd 3d 0a			call delay1s  
0038 3e 2b			ld a,'+'  
003a cd 94 0a			call fill_display  
003d cd b2 0a			call update_display  
0040 cd 3d 0a			call delay1s  
0043 3e 2a			ld a,'*'  
0045 cd 94 0a			call fill_display  
0048 cd b2 0a			call update_display  
004b cd 3d 0a			call delay1s  
004e 3e 2d			ld a,'-'  
0050 cd 94 0a			call fill_display  
0053 cd b2 0a			call update_display  
0056 cd 3d 0a			call delay1s  
0059			  
0059			; boot splash screen  
0059			if display_cols == 20	  
0059			        ld a, display_row_1    
0059			else  
0059 3e 0a		        ld a, display_row_1 +10   
005b			endif  
005b 11 8c 00			ld de, bootmsg  
005e cd a2 0a			call str_at_display  
0061 cd b2 0a			call update_display  
0064			  
0064			  
0064 cd 3d 0a			call delay1s  
0067 cd 3d 0a			call delay1s  
006a			if display_cols == 20	  
006a			            LD   A, display_row_3+2  
006a			else  
006a 3e 5c		            LD   A, display_row_3+12  
006c			endif  
006c 11 a1 00			ld de, bootmsg1  
006f cd a2 0a			call str_at_display  
0072 cd b2 0a			call update_display  
0075 cd 3d 0a			call delay1s  
0078 cd 3d 0a			call delay1s  
007b			  
007b			;	ld a, display_row_4+3  
007b			;	ld de, bootmsg2  
007b			;	call str_at_display  
007b			;	call update_display  
007b			;	call delay1s  
007b			;	call delay1s  
007b			  
007b			; debug mark setup  
007b			  
007b 3e 5f		ld a, '_'  
007d 32 77 fb		ld (debug_mark),a  
0080 32 78 fb		ld (debug_mark+1),a  
0083 32 79 fb		ld (debug_mark+2),a  
0086 3e 00		ld a,0  
0088 32 7a fb		ld (debug_mark+3),a  
008b			  
008b c9					ret  
008c			  
008c			  
008c .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
00a1 .. 00		bootmsg1:	db "by Kevin Groves",0  
00b1			;bootmsg2:	db "Firmware v0.1",0  
00b1			  
00b1			; a 4x20 lcd  
00b1			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00b1			  
00b1			;if display_cols == 20  
00b1			;	include "firmware_lcd_4x20.asm"  
00b1			;endif  
00b1			  
00b1			;if display_cols == 40  
00b1			;	include "firmware_lcd_4x40.asm"  
00b1			;endif  
00b1			  
00b1			;  
00b1			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00b1			; TODO abstract the bit bang video out interface for dual display  
00b1			; TODO wire video out to tx pin on rc2014 bus  
00b1			  
00b1			; must supply cin, and cin_wait for low level hardware abstraction   
00b1			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00b1			; test scancode  
00b1			  
00b1			;;;;;  
00b1			;;;  
00b1			; Moved out to mini and maxi versions  
00b1			;  
00b1			; include "firmware_key_4x4.asm"  
00b1			; using existing 4 wire x 4 resistor array for input  
00b1			;include "firmware_key_4x10.asm"  
00b1			; need to mod the board for 5 rows due to resistor array  
00b1			;include "firmware_key_5x10.asm"  
00b1			  
00b1			; storage hardware interface  
00b1			  
00b1			; use microchip serial eeprom for storage  
00b1			  
00b1			  
00b1			if STORAGE_SE  
00b1				include "firmware_spi.asm"  
00b1			; my spi protocol (used by storage) 
00b1			 
00b1			; SPI pins 
00b1			 
00b1			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00b1			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00b1			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00b1			 
00b1			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00b1			; chip pin 4 gnd 
00b1			 
00b1			 
00b1			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00b1			SPI_CE1: equ 1      ;    port a1 pin 14  
00b1			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00b1			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00b1			SPI_CE4: equ 4      ; port a4     pin 10 
00b1			 
00b1			; active low AND masks 
00b1			 
00b1			;SPI_CE0_MASK: equ    255-1 
00b1			;SPI_CE1_MASK: equ   255-2 
00b1			;SPI_CE2_MASK: equ   255-4 
00b1			;SPI_CE3_MASK: equ   255-8 
00b1			;SPI_CE4_MASK: equ   255-16 
00b1			SPI_CE_HIGH:  equ 255 
00b1			 
00b1			 
00b1			 
00b1			 
00b1			; TODO store port id for spi device ie dev c 
00b1			; TODO store pin for SO 
00b1			; TODO store pin for SI 
00b1			; TODO store pin for SCLK 
00b1			 
00b1			; 
00b1			 
00b1			; ensure that spi bus is in a stable state with default pins  
00b1			 
00b1			se_stable_spi:   
00b1			 
00b1				 ; set DI high, CE high , SCLK low 
00b1				;ld a, SPI_DI | SPI_CE0 
00b1 3e 07			ld a, SPI_DI  
00b3 cd 87 01			call spi_ce_high 
00b6 d3 80			 out (storage_adata),a 
00b8 32 5d f8			ld (spi_portbyte),a 
00bb			 
00bb				if DEBUG_SPI 
00bb					push hl 
00bb					ld l, a 
00bb					DMARK "SPI" 
00bb					CALLMONITOR 
00bb					pop hl 
00bb				endif 
00bb c9				ret 
00bc			 
00bc			; byte to send in a 
00bc			 
00bc			spi_send_byte: 
00bc				; save byte to send for bit mask shift out 
00bc 4f			        ld c,a 
00bd 3a 5d f8			ld a,(spi_portbyte) 
00c0				  
00c0				; clock out	each bit of the byte msb first 
00c0			 
00c0 06 08			ld b, 8 
00c2			.ssb1: 
00c2				; clear so bit  
00c2 cb bf			res SPI_DI, a 
00c4 cb 11			rl c 
00c6				; if bit 7 is set then carry is set 
00c6 30 02			jr nc, .ssb2 
00c8 cb ff			set SPI_DI,a 
00ca			.ssb2:  ; output bit to ensure it is stable 
00ca d3 80			out (storage_adata),a 
00cc 00				nop 
00cd				; clock bit high 
00cd cb ef			set SPI_SCLK,a 
00cf d3 80			out (storage_adata),a 
00d1 00				nop 
00d2				; then low 
00d2 cb af			res SPI_SCLK,a 
00d4 d3 80			out (storage_adata),a 
00d6 00				nop 
00d7 10 e9			djnz .ssb1 
00d9			 
00d9 32 5d f8			ld (spi_portbyte),a 
00dc c9				ret 
00dd			 
00dd			; TODO low level get byte into A on spi 
00dd			 
00dd			spi_read_byte:  
00dd			 
00dd				; save byte to send for bit mask shift out 
00dd 0e 00		    ld c,0 
00df 3a 5d f8			ld a,(spi_portbyte) 
00e2				  
00e2				; clock out	each bit of the byte msb first 
00e2			 
00e2			 
00e2				; clock bit high 
00e2 cb ef			set SPI_SCLK,a 
00e4 d3 80			out (storage_adata),a 
00e6 00				nop 
00e7			 
00e7			    ; read DO  
00e7			 
00e7 cb f9		    set 7,c 
00e9 db 80			in a,(storage_adata) 
00eb cb 77		    bit SPI_DO,a 
00ed 20 02		    jr nz, .b7 
00ef cb b9		    res 7,c 
00f1			.b7: 
00f1				; then low 
00f1 cb af			res SPI_SCLK,a 
00f3 d3 80			out (storage_adata),a 
00f5 00				nop 
00f6			     
00f6			 
00f6				; clock bit high 
00f6 cb ef			set SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb			 
00fb			    ; read DO  
00fb			 
00fb cb f1		    set 6,c 
00fd db 80			in a,(storage_adata) 
00ff cb 77		    bit SPI_DO,a 
0101 20 02		    jr nz, .b6 
0103 cb b1		    res 6,c 
0105			.b6: 
0105				; then low 
0105 cb af			res SPI_SCLK,a 
0107 d3 80			out (storage_adata),a 
0109 00				nop 
010a			 
010a				; clock bit high 
010a cb ef			set SPI_SCLK,a 
010c d3 80			out (storage_adata),a 
010e 00				nop 
010f			 
010f			 
010f			    ; read DO  
010f			 
010f cb e9		    set 5,c 
0111 db 80			in a,(storage_adata) 
0113 cb 77		    bit SPI_DO,a 
0115 20 02		    jr nz, .b5 
0117 cb a9		    res 5,c 
0119			.b5: 
0119				; then low 
0119 cb af			res SPI_SCLK,a 
011b d3 80			out (storage_adata),a 
011d 00				nop 
011e				; clock bit high 
011e cb ef			set SPI_SCLK,a 
0120 d3 80			out (storage_adata),a 
0122 00				nop 
0123			 
0123			    ; read DO  
0123			 
0123 cb e1		    set 4,c 
0125 db 80			in a,(storage_adata) 
0127 cb 77		    bit SPI_DO,a 
0129 20 02		    jr nz, .b4 
012b cb a1		    res 4,c 
012d			.b4: 
012d				; then low 
012d cb af			res SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137			 
0137			    ; read DO  
0137			 
0137 cb d9		    set 3,c 
0139 db 80			in a,(storage_adata) 
013b cb 77		    bit SPI_DO,a 
013d 20 02		    jr nz, .b3 
013f cb 99		    res 3,c 
0141			.b3: 
0141				; then low 
0141 cb af			res SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146				; clock bit high 
0146 cb ef			set SPI_SCLK,a 
0148 d3 80			out (storage_adata),a 
014a 00				nop 
014b			 
014b			    ; read DO  
014b			 
014b cb d1		    set 2,c 
014d db 80			in a,(storage_adata) 
014f cb 77		    bit SPI_DO,a 
0151 20 02		    jr nz, .b2 
0153 cb 91		    res 2,c 
0155			.b2: 
0155				; then low 
0155 cb af			res SPI_SCLK,a 
0157 d3 80			out (storage_adata),a 
0159 00				nop 
015a				; clock bit high 
015a cb ef			set SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f			 
015f			    ; read DO  
015f			 
015f cb c9		    set 1,c 
0161 db 80			in a,(storage_adata) 
0163 cb 77		    bit SPI_DO,a 
0165 20 02		    jr nz, .b1 
0167 cb 89		    res 1,c 
0169			.b1: 
0169				; then low 
0169 cb af			res SPI_SCLK,a 
016b d3 80			out (storage_adata),a 
016d 00				nop 
016e				; clock bit high 
016e cb ef			set SPI_SCLK,a 
0170 d3 80			out (storage_adata),a 
0172 00				nop 
0173			 
0173			    ; read DO  
0173			 
0173 cb c1		    set 0,c 
0175 db 80			in a,(storage_adata) 
0177 cb 77		    bit SPI_DO,a 
0179 20 02		    jr nz, .b0 
017b cb 81		    res 0,c 
017d			.b0: 
017d				; then low 
017d cb af			res SPI_SCLK,a 
017f d3 80			out (storage_adata),a 
0181 00				nop 
0182			 
0182			 
0182 32 5d f8			ld (spi_portbyte),a 
0185			 
0185			    ; return byte 
0185 79			    ld a,c 
0186			 
0186			 
0186 c9				ret 
0187			 
0187			 
0187			 
0187			spi_ce_high: 
0187			 
0187				if DEBUG_SPI_HARD_CE0 
0187			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0187					ret 
0187			 
0187				endif 
0187			 
0187			 
0187 f5				push af 
0188			 
0188				; send direct ce to port b 
0188 3e ff			ld a, 255 
018a d3 81			out (storage_bdata), a 
018c			 
018c f1				pop af 
018d			 
018d				; for port a that shares with spi lines AND the mask 
018d			  
018d				if DEBUG_SPI 
018d					push hl 
018d					ld h, a 
018d				endif 
018d			;	ld c, SPI_CE_HIGH 
018d			;	and c 
018d cb c7			set SPI_CE0, a 
018f cb cf			set SPI_CE1, a 
0191 cb d7			set SPI_CE2, a 
0193 cb df			set SPI_CE3, a 
0195 cb e7			set SPI_CE4, a 
0197			 
0197				if DEBUG_SPI 
0197					ld l, a 
0197					DMARK "CEh" 
0197					CALLMONITOR 
0197					pop hl 
0197				endif 
0197 c9				ret 
0198			 
0198			 
0198			spi_ce_low: 
0198			 
0198				if DEBUG_SPI_HARD_CE0 
0198			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0198					ret 
0198			 
0198				endif 
0198			 
0198 c5				push bc 
0199 f5				push af 
019a			 
019a				; send direct ce to port b 
019a 3a 5f f8			ld a, (spi_cartdev) 
019d d3 81			out (storage_bdata), a 
019f			 
019f			 
019f			 
019f				; for port a that shares with spi lines AND the mask 
019f			 
019f 3a 5c f8			ld a, (spi_device)  
01a2 4f				ld c, a 
01a3			 
01a3 f1				pop af 
01a4			 
01a4				; detect CEx 
01a4			 
01a4				if DEBUG_SPI 
01a4					push hl 
01a4					ld h, a 
01a4				endif 
01a4			 
01a4 cb 41			bit SPI_CE0, c 
01a6 20 04			jr nz, .cel1 
01a8 cb 87			res SPI_CE0, a 
01aa 18 1e			jr .celn 
01ac			.cel1: 
01ac cb 49			bit SPI_CE1, c 
01ae 20 04			jr nz, .cel2 
01b0 cb 8f			res SPI_CE1, a 
01b2 18 16			jr .celn 
01b4			.cel2: 
01b4 cb 51			bit SPI_CE2, c 
01b6 20 04			jr nz, .cel3 
01b8 cb 97			res SPI_CE2, a 
01ba 18 0e			jr .celn 
01bc			.cel3: 
01bc cb 59			bit SPI_CE3, c 
01be 20 04			jr nz, .cel4 
01c0 cb 9f			res SPI_CE3, a 
01c2 18 06			jr .celn 
01c4			.cel4: 
01c4 cb 61			bit SPI_CE4, c 
01c6 20 02			jr nz, .celn 
01c8 cb a7			res SPI_CE4, a 
01ca			.celn: 
01ca			 
01ca			 
01ca			 
01ca			;	add c 
01ca			 
01ca				if DEBUG_SPI 
01ca					ld l, a 
01ca					DMARK "CEl" 
01ca					CALLMONITOR 
01ca					pop hl 
01ca				endif 
01ca c1				pop bc 
01cb c9				ret 
01cc			 
01cc			 
01cc			 
01cc			; eof 
01cc			 
01cc			 
01cc			 
01cc			 
01cc			 
# End of file firmware_spi.asm
01cc				include "firmware_seeprom.asm"  
01cc			; 
01cc			; persisent storage interface via microchip serial eeprom 
01cc			 
01cc			; port a pio 2 
01cc			; pa 7 - si 
01cc			; pa 6 - sclk  
01cc			; pa 5 - so 
01cc			; pa 4 - cs 
01cc			; pa 3 - cs 
01cc			; pa 2 - cs 
01cc			; pa 1 - cs 
01cc			; pa 0 - cs 
01cc			; 
01cc			; TODO get block 
01cc			; TODO save block 
01cc			; TODO load file 
01cc			; TODO save file 
01cc			; TODO get dir  
01cc			 
01cc			;  
01cc			storage_adata: equ Device_C    ; device c port a - onboard storage 
01cc			storage_actl: equ Device_C+2     ; device c port a 
01cc			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01cc			storage_bctl: equ Device_C+3     ; device c port b 
01cc			 
01cc			 
01cc			; TODO move these to hardware driver file 
01cc			 
01cc			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01cc			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01cc			; storage bank file system format 
01cc			; 
01cc			; first page of bank: 
01cc			; 	addr 0 - status check 
01cc			;       addr 1 - write protect flag 
01cc			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01cc			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01cc			;         TODO see if scanning whole of for available next file id is fast enough 
01cc			;	addr 4 > zero term string of bank label 
01cc			; 
01cc			;        
01cc			;  
01cc			; first page of any file: 
01cc			;      byte 0 - file id  
01cc			;      byte 1-17 - fixed file name  
01cc			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01cc			; 
01cc			; other pages of any file: 
01cc			;      byte 0 - file id 
01cc			;      byte 1> - file data 
01cc			; 
01cc			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01cc			;  
01cc			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01cc			 
01cc			 
01cc			;storage_so_bit: 5 
01cc			;storage_si_bit: 7 
01cc			;storage_sclk_bit: 6 
01cc			  
01cc			 
01cc			; init storage pio 
01cc			 
01cc			storage_init: 
01cc			 
01cc 3e cf		            LD   A, 11001111b 
01ce d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01d0 3e 00		            LD   A, 00000000b 
01d2 cb f7			set SPI_DO,a 
01d4			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d4 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d6			 
01d6 3e cf		            LD   A, 11001111b 
01d8 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01da 3e 00		            LD   A, 00000000b 
01dc d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01de			 
01de				; set all external spi devices off 
01de 3e 00			ld a, 0 
01e0 32 5c f8			ld (spi_device), a 
01e3 32 5f f8			ld (spi_cartdev), a 
01e6			 
01e6					; ensure the spi bus is in a default stable state 
01e6 cd b1 00				call se_stable_spi 
01e9			 
01e9			; TODO scan spi bus and gather which storage banks are present 
01e9			 
01e9			; populate store_bank_active  
01e9			; for each ce line activate and attempt to write first byte of bank and read back 
01e9			; if zero is returned then bank is empty 
01e9			;   
01e9			; 
01e9			 
01e9					; init file extent cache to save on slow reads 
01e9			 
01e9			;	ld hl, store_filecache 
01e9			;	ld de, 0 
01e9			;	ld hl,(de)	 
01e9			 
01e9			 
01e9 c9			    ret 
01ea			 
01ea			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01ea			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01ea			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01ea			 
01ea			; INSTRUCTION SET 
01ea			; READ 0000 0011 Read data from memory array beginning at selected address 
01ea			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01ea			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01ea			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01ea			; RDSR 0000 0101 Read STATUS register 
01ea			; WRSR 0000 0001 Write STATUS register 
01ea			; PE 0100 0010 Page Erase – erase one page in memory array 
01ea			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01ea			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01ea			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01ea			 
01ea			; TODO send byte steam for page without setting the address for every single byte 
01ea			; TODO read byte  
01ea			 
01ea			; byte in a 
01ea			; address in hl  
01ea			se_writebyte: 
01ea			        
01ea			    ;   ld c, a 
01ea f5			        push af 
01eb e5			        push hl 
01ec			 
01ec			    ; initi write mode 
01ec			    ; 
01ec			    ;CS low 
01ec			 
01ec 3a 5d f8		       ld a,(spi_portbyte) 
01ef cd 98 01			call spi_ce_low 
01f2			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01f2 d3 80		       out (storage_adata),a 
01f4 32 5d f8		       ld (spi_portbyte), a 
01f7			 
01f7			    ;clock out wren instruction 
01f7			 
01f7 3e 06		    ld a, store_wren_ins 
01f9 cd bc 00		    call spi_send_byte  
01fc			 
01fc			    ;cs high to enable write latch 
01fc			 
01fc 3a 5d f8		       ld a,(spi_portbyte) 
01ff cd 87 01			call spi_ce_high 
0202			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0202 d3 80		       out (storage_adata),a 
0204 32 5d f8		       ld (spi_portbyte), a 
0207			 
0207 00				nop 
0208			    ; 
0208			    ; intial write data 
0208			    ; 
0208			    ; cs low 
0208			     
0208 3a 5d f8		       ld a,(spi_portbyte) 
020b cd 98 01			call spi_ce_low 
020e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020e d3 80		       out (storage_adata),a 
0210 32 5d f8		       ld (spi_portbyte), a 
0213			 
0213			    ; clock out write instruction 
0213			     
0213 3e 02		    ld a, store_write_ins  
0215 cd bc 00		    call spi_send_byte  
0218			 
0218			    ; clock out address (depending on address size) 
0218			     
0218 e1			    pop hl 
0219 7c			    ld a,h    ; address out msb first 
021a cd bc 00		    call spi_send_byte  
021d 7d			    ld a,l 
021e cd bc 00		    call spi_send_byte  
0221			 
0221			    ; clock out byte(s) for page 
0221			 
0221 f1			    pop af 
0222 cd bc 00		    call spi_send_byte  
0225			 
0225			    ; end write with ce high 
0225 3a 5d f8		       ld a,(spi_portbyte) 
0228			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0228 cd 87 01			call spi_ce_high 
022b d3 80		       out (storage_adata),a 
022d 32 5d f8		       ld (spi_portbyte), a 
0230			 
0230				; pause for internal write cycle 
0230 3e 0a			ld a, 10 
0232 cd 22 0a			call aDelayInMS 
0235 c9			    ret 
0236			 
0236			; buffer to write in de 
0236			; address in hl  
0236			se_writepage: 
0236			        
0236			    ;   ld c, a 
0236 d5				push de 
0237 e5			        push hl 
0238			 
0238			    ; initi write mode 
0238			    ; 
0238			    ;CS low 
0238			 
0238 3a 5d f8		       ld a,(spi_portbyte) 
023b cd 98 01			call spi_ce_low 
023e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023e d3 80		       out (storage_adata),a 
0240 32 5d f8		       ld (spi_portbyte), a 
0243			 
0243			    ;clock out wren instruction 
0243			 
0243 3e 06		    ld a, store_wren_ins 
0245 cd bc 00		    call spi_send_byte  
0248			 
0248			    ;cs high to enable write latch 
0248			 
0248 3a 5d f8		       ld a,(spi_portbyte) 
024b cd 87 01			call spi_ce_high 
024e			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024e d3 80		       out (storage_adata),a 
0250 32 5d f8		       ld (spi_portbyte), a 
0253			 
0253 00				nop 
0254			    ; 
0254			    ; intial write data 
0254			    ; 
0254			    ; cs low 
0254			     
0254 3a 5d f8		       ld a,(spi_portbyte) 
0257			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0257 cd 98 01			call spi_ce_low 
025a d3 80		       out (storage_adata),a 
025c 32 5d f8		       ld (spi_portbyte), a 
025f			 
025f			    ; clock out write instruction 
025f			     
025f 3e 02		    ld a, store_write_ins  
0261 cd bc 00		    call spi_send_byte  
0264			 
0264			    ; clock out address (depending on address size) 
0264			     
0264 e1			    pop hl 
0265 7c			    ld a,h    ; address out msb first 
0266 cd bc 00		    call spi_send_byte  
0269 7d			    ld a,l 
026a cd bc 00		    call spi_send_byte  
026d			 
026d			    ; clock out byte(s) for page 
026d			 
026d e1				pop hl 
026e 06 40			ld b, STORE_BLOCK_PHY 
0270			.bytewrite: 
0270			 
0270 7e				ld a,(hl) 
0271 e5			    push hl 
0272 c5				push bc 
0273 cd bc 00		    call spi_send_byte  
0276 c1				pop bc 
0277 e1				pop hl 
0278			 
0278			    ; end write with ce high 
0278 3a 5d f8		       ld a,(spi_portbyte) 
027b cd 87 01			call spi_ce_high 
027e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027e d3 80		       out (storage_adata),a 
0280 32 5d f8		       ld (spi_portbyte), a 
0283			 
0283 23				inc hl 
0284 10 ea			djnz .bytewrite 
0286			 
0286				; pause for internal write cycle 
0286 3e 64			ld a, 100 
0288 cd 22 0a			call aDelayInMS 
028b c9			    ret 
028c			; returns byte in a 
028c			; address in hl  
028c			se_readbyte: 
028c d5				push de 
028d c5				push bc 
028e			 
028e			    ;   ld c, a 
028e e5			        push hl 
028f			 
028f			    ; initi write mode 
028f			    ; 
028f			    ;CS low 
028f			 
028f 3a 5d f8		       ld a,(spi_portbyte) 
0292 cd 98 01			call spi_ce_low 
0295			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0295 d3 80		       out (storage_adata),a 
0297 32 5d f8		       ld (spi_portbyte), a 
029a			 
029a			    ;clock out wren instruction 
029a			 
029a 3e 03		    ld a, store_read_ins 
029c cd bc 00		    call spi_send_byte  
029f			 
029f			 
029f			    ; clock out address (depending on address size) 
029f			     
029f e1			    pop hl 
02a0 7c			    ld a,h    ; address out msb first 
02a1 cd bc 00		    call spi_send_byte  
02a4 7d			    ld a,l 
02a5 cd bc 00		    call spi_send_byte  
02a8			 
02a8			    ; clock in byte(s) for page 
02a8			 
02a8 cd dd 00		    call spi_read_byte  
02ab f5				push af 
02ac			 
02ac			    ; end write with ce high 
02ac 3a 5d f8		       ld a,(spi_portbyte) 
02af			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02af cd 87 01			call spi_ce_high 
02b2 d3 80		       out (storage_adata),a 
02b4 32 5d f8		       ld (spi_portbyte), a 
02b7			 
02b7 f1				pop af 
02b8			 
02b8 c1				pop bc 
02b9 d1				pop de 
02ba			 
02ba c9			    ret 
02bb			 
02bb			if DEBUG_STORESE 
02bb			 
02bb			storageput:  
02bb			 
02bb			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02bb			 
02bb 21 34 ee			ld hl,scratch+2 
02be cd 76 10			call get_word_hl 
02c1			 
02c1				; stuff it here for the moment as it will be overwritten later anyway 
02c1			 
02c1 22 55 f1			ld (os_cur_ptr),hl	 
02c4			 
02c4			 
02c4			; get pointer to start of string 
02c4			 
02c4 21 39 ee			ld hl, scratch+7 
02c7			 
02c7			; loop writing char of string to eeprom 
02c7			 
02c7 7e			.writestr:	ld a,(hl) 
02c8 fe 00				cp 0 
02ca 28 12				jr z, .wsdone		; done writing 
02cc e5					push hl 
02cd 2a 55 f1				ld hl,(os_cur_ptr) 
02d0 cd ea 01				call se_writebyte 
02d3			 
02d3 2a 55 f1				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d6 23					inc hl 
02d7 22 55 f1				ld (os_cur_ptr),hl 
02da			 
02da					; restore string pointer and get next char 
02da			 
02da e1					pop hl 
02db 23					inc hl 
02dc 18 e9				jr .writestr 
02de			 
02de			 
02de			 
02de			.wsdone: 
02de			 
02de			 
02de			; when done load first page into a buffer  
02de			 
02de 21 00 80				ld hl,08000h		; start in ram 
02e1 22 55 f1				ld (os_cur_ptr),hl 
02e4 21 00 00				ld hl, 0		 ; start of page 
02e7 22 5a ee				ld (scratch+40),hl	; hang on to it 
02ea			 
02ea 06 80				ld b, 128		; actually get more then one page 
02ec c5			.wsload:	push bc 
02ed 2a 5a ee				ld hl,(scratch+40) 
02f0 e5					push hl 
02f1 cd 8c 02				call se_readbyte 
02f4			 
02f4					; a now as the byte 
02f4			 
02f4 2a 55 f1				ld hl,(os_cur_ptr) 
02f7 77					ld (hl),a 
02f8					; inc next buffer area 
02f8 23					inc hl 
02f9 22 55 f1				ld (os_cur_ptr),hl 
02fc			 
02fc					; get eeprom position, inc and save for next round 
02fc e1					pop hl		 
02fd 23					inc hl 
02fe 22 5a ee				ld (scratch+40),hl 
0301 c1					pop bc 
0302 10 e8				djnz .wsload 
0304			 
0304			; set 'd' pointer to start of buffer 
0304			 
0304 21 00 80				ld hl,08000h 
0307 22 55 f1				ld (os_cur_ptr),hl 
030a			 
030a			 
030a c9			ret 
030b			 
030b			 
030b c9			storageread: ret 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			endif 
030c			 
030c			 
030c			 
# End of file firmware_seeprom.asm
030c			else  
030c			   ; create some stubs for the labels  
030c			se_readbyte: ret  
030c			se_writebyte: ret  
030c			storage_init: ret  
030c			  
030c			endif  
030c			  
030c			; use cf card for storage - throwing timeout errors. Hardware or software?????  
030c			;include "firmware_cf.asm"  
030c			  
030c			; load up high level storage hardward abstractions  
030c			include "firmware_storage.asm"  
030c			 
030c			; persisent storage hardware abstraction layer  
030c			 
030c			 
030c			 
030c			; Block 0 on storage is a config state 
030c			 
030c			 
030c			 
030c			; TODO add read phy block and write phy block functions 
030c			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
030c			 
030c			; Abstraction layer  
030c			 
030c			; Logocial block size is same size as physical size - using tape concept 
030c			 
030c			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
030c			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
030c			 
030c			 
030c			 
030c			; Filesystem layout (Logical layout) 
030c			; 
030c			; Block 0 - Bank config  
030c			; 
030c			;      Byte - 0 file id counter 
030c			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
030c			;      Byte - 3-20 zero terminated bank label 
030c			; 
030c			; Block 1 > File storage 
030c			; 
030c			;      Byte 0 file id    - block 0 file details 
030c			;      Byte 1 block id - block 0 is file  
030c			;            Byte 2-15 - File name 
030c			; 
030c			;       - to end of block data 
030c			; 
030c			 
030c			 
030c			; Read Block 
030c			; ---------- 
030c			; 
030c			; With current bank 
030c			;  
030c			; Get block number to read 
030c			; Load physical blocks starting at start block into buffer 
030c			 
030c			; de points to buffer to use 
030c			; hl holds logical block number  
030c			 
030c			storage_read_block: 
030c			 
030c				; TODO bank selection 
030c			 
030c				; for each of the physical blocks read it into the buffer 
030c 06 40			ld b, STORE_BLOCK_PHY 
030e			 
030e				if DEBUG_STORESE 
030e d5					push de 
030f				endif 
030f				 
030f			.rl1:    
030f			 
030f				; read physical block at hl into de 
030f			        ; increment hl and de to next read position on exit 
030f			 
030f e5				push hl 
0310 d5				push de	 
0311 c5				push bc 
0312			;	if DEBUG_STORESE 
0312			;		push af 
0312			;		ld a, 'R' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 cd 8c 02			call se_readbyte 
0315			;	if DEBUG_STORESE 
0315			;		ld a,(spi_portbyte) 
0315			;		ld l, a 
0315			;		push af 
0315			;		ld a, '1' 
0315			;		ld (debug_mark),a 
0315			;		pop af 
0315			;		CALLMONITOR 
0315			;	endif 
0315 c1				pop bc 
0316 d1				pop de 
0317 e1				pop hl 
0318 12				ld (de),a 
0319 23				inc hl 
031a 13				inc de 
031b			 
031b			;	if DEBUG_STORESE 
031b			;		push af 
031b			;		ld a, 'r' 
031b			;		ld (debug_mark),a 
031b			;		pop af 
031b			;		CALLMONITOR 
031b			;	endif 
031b			 
031b 10 f2			djnz .rl1 
031d			 
031d				if DEBUG_STORESE 
031d					DMARK "SRB" 
031d f5				push af  
031e 3a 32 03			ld a, (.dmark)  
0321 32 77 fb			ld (debug_mark),a  
0324 3a 33 03			ld a, (.dmark+1)  
0327 32 78 fb			ld (debug_mark+1),a  
032a 3a 34 03			ld a, (.dmark+2)  
032d 32 79 fb			ld (debug_mark+2),a  
0330 18 03			jr .pastdmark  
0332 ..			.dmark: db "SRB"  
0335 f1			.pastdmark: pop af  
0336			endm  
# End of macro DMARK
0336 d1					pop de 
0337			; 
0337			;		push af 
0337			;		ld a, 'R' 
0337			;		ld (debug_mark),a 
0337			;		pop af 
0337					CALLMONITOR 
0337 cd 01 15			call break_point_state  
033a				endm  
# End of macro CALLMONITOR
033a				endif 
033a c9				ret	 
033b				 
033b			 
033b			; File Size 
033b			; --------- 
033b			; 
033b			;   hl file id 
033b			; 
033b			;  returns in hl the number of blocks 
033b			 
033b			storage_file_size: 
033b 5d				ld e, l 
033c 16 00			ld d, 0 
033e 21 40 00			ld hl, STORE_BLOCK_PHY 
0341					if DEBUG_FORTH_WORDS 
0341						DMARK "SIZ" 
0341 f5				push af  
0342 3a 56 03			ld a, (.dmark)  
0345 32 77 fb			ld (debug_mark),a  
0348 3a 57 03			ld a, (.dmark+1)  
034b 32 78 fb			ld (debug_mark+1),a  
034e 3a 58 03			ld a, (.dmark+2)  
0351 32 79 fb			ld (debug_mark+2),a  
0354 18 03			jr .pastdmark  
0356 ..			.dmark: db "SIZ"  
0359 f1			.pastdmark: pop af  
035a			endm  
# End of macro DMARK
035a						CALLMONITOR 
035a cd 01 15			call break_point_state  
035d				endm  
# End of macro CALLMONITOR
035d					endif 
035d cd 22 06			call storage_findnextid 
0360			 
0360 cd e8 0c			call ishlzero 
0363			;	ld a, l 
0363			;	add h 
0363			;	cp 0 
0363 c8				ret z			; block not found so EOF 
0364			 
0364 11 62 f8			ld de, store_page 
0367 cd 0c 03			call storage_read_block 
036a			 
036a 3a 64 f8			ld a, (store_page+2)	 ; get extent count 
036d 6f				ld l, a 
036e 26 00			ld h, 0 
0370 c9			 	ret 
0371			 
0371			 
0371			; Write Block 
0371			; ----------- 
0371			; 
0371			; With current bank 
0371			;  
0371			; Get block number to write 
0371			; Write physical blocks starting at start block from buffer 
0371			  
0371			storage_write_block: 
0371				; TODO bank selection 
0371			 
0371				; for each of the physical blocks read it into the buffer 
0371 06 40			ld b, STORE_BLOCK_PHY 
0373			 
0373				if DEBUG_STORESE 
0373					DMARK "SWB" 
0373 f5				push af  
0374 3a 88 03			ld a, (.dmark)  
0377 32 77 fb			ld (debug_mark),a  
037a 3a 89 03			ld a, (.dmark+1)  
037d 32 78 fb			ld (debug_mark+1),a  
0380 3a 8a 03			ld a, (.dmark+2)  
0383 32 79 fb			ld (debug_mark+2),a  
0386 18 03			jr .pastdmark  
0388 ..			.dmark: db "SWB"  
038b f1			.pastdmark: pop af  
038c			endm  
# End of macro DMARK
038c			 
038c					;push af 
038c					;ld a, 'W' 
038c					;ld (debug_mark),a 
038c					;pop af 
038c					CALLMONITOR 
038c cd 01 15			call break_point_state  
038f				endm  
# End of macro CALLMONITOR
038f				endif 
038f			 
038f			; might not be working 
038f			;	call se_writepage 
038f			 
038f			;	ret 
038f			; 
038f			 
038f			 
038f			 
038f			.wl1:    
038f			 
038f				; read physical block at hl into de 
038f			        ; increment hl and de to next read position on exit 
038f			 
038f e5				push hl 
0390 d5				push de	 
0391 c5				push bc 
0392 1a				ld a,(de) 
0393				;if DEBUG_STORESE 
0393			;		push af 
0393			;		ld a, 'W' 
0393			;		ld (debug_mark),a 
0393			;		pop af 
0393			;		CALLMONITOR 
0393			;	endif 
0393 cd ea 01			call se_writebyte 
0396			;	call delay250ms 
0396 00				nop 
0397 00				nop 
0398 00				nop 
0399			;	if DEBUG_STORESE 
0399			;		push af 
0399			;		ld a, 'w' 
0399			;		ld (debug_mark),a 
0399			;		pop af 
0399			;		CALLMONITOR 
0399			;	endif 
0399 c1				pop bc 
039a d1				pop de 
039b e1				pop hl 
039c 23				inc hl 
039d 13				inc de 
039e			 
039e			 
039e 10 ef			djnz .wl1 
03a0			 
03a0				if DEBUG_STORESE 
03a0					DMARK "SW2" 
03a0 f5				push af  
03a1 3a b5 03			ld a, (.dmark)  
03a4 32 77 fb			ld (debug_mark),a  
03a7 3a b6 03			ld a, (.dmark+1)  
03aa 32 78 fb			ld (debug_mark+1),a  
03ad 3a b7 03			ld a, (.dmark+2)  
03b0 32 79 fb			ld (debug_mark+2),a  
03b3 18 03			jr .pastdmark  
03b5 ..			.dmark: db "SW2"  
03b8 f1			.pastdmark: pop af  
03b9			endm  
# End of macro DMARK
03b9			 
03b9					;push af 
03b9					;ld a, 'W' 
03b9					;ld (debug_mark),a 
03b9					;pop af 
03b9					CALLMONITOR 
03b9 cd 01 15			call break_point_state  
03bc				endm  
# End of macro CALLMONITOR
03bc				endif 
03bc c9				ret	 
03bd			 
03bd			; Init bank 
03bd			; --------- 
03bd			; 
03bd			; With current bank 
03bd			; 
03bd			; Setup block 0 config 
03bd			;     Set 0 file id counter 
03bd			;     Set formatted byte pattern 
03bd			;     Zero out bank label 
03bd			;      
03bd			; For every logical block write 0-1 byte as null 
03bd			 
03bd			storage_get_block_0: 
03bd			 
03bd				; TODO check presence 
03bd			 
03bd				; get block 0 config 
03bd			 
03bd 21 00 00			ld hl, 0 
03c0 11 62 f8			ld de, store_page 
03c3 cd 0c 03			call storage_read_block 
03c6			 
03c6				if DEBUG_STORESE 
03c6					DMARK "SB0" 
03c6 f5				push af  
03c7 3a db 03			ld a, (.dmark)  
03ca 32 77 fb			ld (debug_mark),a  
03cd 3a dc 03			ld a, (.dmark+1)  
03d0 32 78 fb			ld (debug_mark+1),a  
03d3 3a dd 03			ld a, (.dmark+2)  
03d6 32 79 fb			ld (debug_mark+2),a  
03d9 18 03			jr .pastdmark  
03db ..			.dmark: db "SB0"  
03de f1			.pastdmark: pop af  
03df			endm  
# End of macro DMARK
03df 11 62 f8				ld de, store_page 
03e2			;		push af 
03e2			;		ld a, 'i' 
03e2			;		ld (debug_mark),a 
03e2			;		pop af 
03e2					CALLMONITOR 
03e2 cd 01 15			call break_point_state  
03e5				endm  
# End of macro CALLMONITOR
03e5				endif 
03e5			 
03e5				; is this area formatted? 
03e5			 
03e5			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e5 2a 63 f8			ld hl, (store_page+1) 
03e8 3e 80			ld a,0x80 
03ea bd				cp l 
03eb 20 22			jr nz, .ininotformatted 
03ed				; do a double check 
03ed 3e 27			ld a, 0x27 
03ef bc				cp h 
03f0 20 1d			jr nz, .ininotformatted 
03f2			 
03f2				; formatted then 
03f2			 
03f2				if DEBUG_STORESE 
03f2					DMARK "SB1" 
03f2 f5				push af  
03f3 3a 07 04			ld a, (.dmark)  
03f6 32 77 fb			ld (debug_mark),a  
03f9 3a 08 04			ld a, (.dmark+1)  
03fc 32 78 fb			ld (debug_mark+1),a  
03ff 3a 09 04			ld a, (.dmark+2)  
0402 32 79 fb			ld (debug_mark+2),a  
0405 18 03			jr .pastdmark  
0407 ..			.dmark: db "SB1"  
040a f1			.pastdmark: pop af  
040b			endm  
# End of macro DMARK
040b					;push af 
040b					;ld a, 'I' 
040b					;ld (debug_mark),a 
040b					;pop af 
040b					CALLMONITOR 
040b cd 01 15			call break_point_state  
040e				endm  
# End of macro CALLMONITOR
040e				endif 
040e c9				ret 
040f			 
040f			.ininotformatted: 
040f				; bank not formatted so poke various bits to make sure 
040f			 
040f				if DEBUG_STORESE 
040f					DMARK "SB2" 
040f f5				push af  
0410 3a 24 04			ld a, (.dmark)  
0413 32 77 fb			ld (debug_mark),a  
0416 3a 25 04			ld a, (.dmark+1)  
0419 32 78 fb			ld (debug_mark+1),a  
041c 3a 26 04			ld a, (.dmark+2)  
041f 32 79 fb			ld (debug_mark+2),a  
0422 18 03			jr .pastdmark  
0424 ..			.dmark: db "SB2"  
0427 f1			.pastdmark: pop af  
0428			endm  
# End of macro DMARK
0428					;push af 
0428					;ld a, 'f' 
0428					;ld (debug_mark),a 
0428					;pop af 
0428					CALLMONITOR 
0428 cd 01 15			call break_point_state  
042b				endm  
# End of macro CALLMONITOR
042b				endif 
042b			 
042b 21 62 f8			ld hl, store_page 
042e 3e 00			ld a, 0 
0430				 
0430 77				ld (hl),a   ; reset file counter 
0431			 
0431 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0434 22 63 f8		 	ld (store_page+1), hl	 
0437			 
0437				; set default label 
0437			 
0437 21 cc 04			ld hl, .defaultbanklabl 
043a 11 65 f8		 	ld de, store_page+3 
043d 01 0f 00			ld bc, 15 
0440 ed b0			ldir 
0442			 
0442				; save default page 0 
0442			 
0442 21 00 00			ld hl, 0 
0445 11 62 f8			ld de, store_page 
0448				if DEBUG_STORESE 
0448					DMARK "SB3" 
0448 f5				push af  
0449 3a 5d 04			ld a, (.dmark)  
044c 32 77 fb			ld (debug_mark),a  
044f 3a 5e 04			ld a, (.dmark+1)  
0452 32 78 fb			ld (debug_mark+1),a  
0455 3a 5f 04			ld a, (.dmark+2)  
0458 32 79 fb			ld (debug_mark+2),a  
045b 18 03			jr .pastdmark  
045d ..			.dmark: db "SB3"  
0460 f1			.pastdmark: pop af  
0461			endm  
# End of macro DMARK
0461			;		push af 
0461			;		ld a, 'F' 
0461			;		ld (debug_mark),a 
0461			;		pop af 
0461					CALLMONITOR 
0461 cd 01 15			call break_point_state  
0464				endm  
# End of macro CALLMONITOR
0464				endif 
0464 cd 71 03			call storage_write_block 
0467				if DEBUG_STORESE 
0467					DMARK "SB4" 
0467 f5				push af  
0468 3a 7c 04			ld a, (.dmark)  
046b 32 77 fb			ld (debug_mark),a  
046e 3a 7d 04			ld a, (.dmark+1)  
0471 32 78 fb			ld (debug_mark+1),a  
0474 3a 7e 04			ld a, (.dmark+2)  
0477 32 79 fb			ld (debug_mark+2),a  
047a 18 03			jr .pastdmark  
047c ..			.dmark: db "SB4"  
047f f1			.pastdmark: pop af  
0480			endm  
# End of macro DMARK
0480			;		push af 
0480			;		ld a, '>' 
0480			;		ld (debug_mark),a 
0480			;		pop af 
0480					CALLMONITOR 
0480 cd 01 15			call break_point_state  
0483				endm  
# End of macro CALLMONITOR
0483				endif 
0483			 
0483 00				nop 
0484 00				nop 
0485 00				nop 
0486			 
0486				; now set 0 in every page to mark as a free block 
0486			 
0486 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0488 21 40 00			ld hl, STORE_BLOCK_PHY 
048b			 
048b 3e 00		.setmark1:   	ld a,0 
048d e5					push hl 
048e c5					push bc 
048f cd ea 01				call se_writebyte 
0492 3e 0a			ld a, 10 
0494 cd 22 0a			call aDelayInMS 
0497 23				inc hl 
0498 cd ea 01				call se_writebyte 
049b 3e 0a			ld a, 10 
049d cd 22 0a			call aDelayInMS 
04a0 2b				dec hl 
04a1 c1					pop bc 
04a2 e1					pop hl 
04a3 3e 40				ld a, STORE_BLOCK_PHY 
04a5 cd bf 0c				call addatohl 
04a8 10 e1				djnz .setmark1 
04aa			 
04aa 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04ac 3e 00		.setmark2:   	ld a,0 
04ae e5					push hl 
04af c5					push bc 
04b0 cd ea 01				call se_writebyte 
04b3 3e 0a			ld a, 10 
04b5 cd 22 0a			call aDelayInMS 
04b8 23				inc hl 
04b9 cd ea 01				call se_writebyte 
04bc 3e 0a			ld a, 10 
04be cd 22 0a			call aDelayInMS 
04c1 2b				dec hl 
04c2 c1					pop bc 
04c3 e1					pop hl 
04c4 3e 40				ld a, STORE_BLOCK_PHY 
04c6 cd bf 0c				call addatohl 
04c9 10 e1				djnz .setmark2 
04cb			 
04cb					 
04cb			 
04cb			 
04cb c9				ret 
04cc			 
04cc			 
04cc			 
04cc			 
04cc .. 00		.defaultbanklabl:   db "BankLabel",0 
04d6			 
04d6			 
04d6			 
04d6			; Label Bank 
04d6			; ---------- 
04d6			; 
04d6			; With current bank 
04d6			; Read block 0 
04d6			; Set label 
04d6			; Write block 0 
04d6			 
04d6			; label str pointer in hl 
04d6			 
04d6			storage_label:     
04d6			 
04d6				if DEBUG_STORESE 
04d6					DMARK "LBL" 
04d6 f5				push af  
04d7 3a eb 04			ld a, (.dmark)  
04da 32 77 fb			ld (debug_mark),a  
04dd 3a ec 04			ld a, (.dmark+1)  
04e0 32 78 fb			ld (debug_mark+1),a  
04e3 3a ed 04			ld a, (.dmark+2)  
04e6 32 79 fb			ld (debug_mark+2),a  
04e9 18 03			jr .pastdmark  
04eb ..			.dmark: db "LBL"  
04ee f1			.pastdmark: pop af  
04ef			endm  
# End of macro DMARK
04ef					CALLMONITOR 
04ef cd 01 15			call break_point_state  
04f2				endm  
# End of macro CALLMONITOR
04f2				endif 
04f2			 
04f2 e5				push hl 
04f3			 
04f3 cd bd 03			call storage_get_block_0 
04f6			 
04f6				; set default label 
04f6			 
04f6 e1				pop hl 
04f7			 
04f7 11 65 f8		 	ld de, store_page+3 
04fa 01 0f 00			ld bc, 15 
04fd				if DEBUG_STORESE 
04fd					DMARK "LB3" 
04fd f5				push af  
04fe 3a 12 05			ld a, (.dmark)  
0501 32 77 fb			ld (debug_mark),a  
0504 3a 13 05			ld a, (.dmark+1)  
0507 32 78 fb			ld (debug_mark+1),a  
050a 3a 14 05			ld a, (.dmark+2)  
050d 32 79 fb			ld (debug_mark+2),a  
0510 18 03			jr .pastdmark  
0512 ..			.dmark: db "LB3"  
0515 f1			.pastdmark: pop af  
0516			endm  
# End of macro DMARK
0516					CALLMONITOR 
0516 cd 01 15			call break_point_state  
0519				endm  
# End of macro CALLMONITOR
0519				endif 
0519 ed b0			ldir 
051b				; save default page 0 
051b			 
051b 21 00 00			ld hl, 0 
051e 11 62 f8			ld de, store_page 
0521				if DEBUG_STORESE 
0521					DMARK "LBW" 
0521 f5				push af  
0522 3a 36 05			ld a, (.dmark)  
0525 32 77 fb			ld (debug_mark),a  
0528 3a 37 05			ld a, (.dmark+1)  
052b 32 78 fb			ld (debug_mark+1),a  
052e 3a 38 05			ld a, (.dmark+2)  
0531 32 79 fb			ld (debug_mark+2),a  
0534 18 03			jr .pastdmark  
0536 ..			.dmark: db "LBW"  
0539 f1			.pastdmark: pop af  
053a			endm  
# End of macro DMARK
053a					CALLMONITOR 
053a cd 01 15			call break_point_state  
053d				endm  
# End of macro CALLMONITOR
053d				endif 
053d cd 71 03			call storage_write_block 
0540			 
0540 c9				ret 
0541			 
0541			 
0541			 
0541			; Read Block 0 - Config 
0541			; --------------------- 
0541			; 
0541			; With current bank 
0541			; Call presence test 
0541			;    If not present format/init bank  
0541			; Read block 0  
0541			;  
0541			 
0541			 
0541			; Dir 
0541			; --- 
0541			; 
0541			; With current bank 
0541			; Load Block 0 Config 
0541			; Get max file id number 
0541			; For each logical block 
0541			;    Read block read byte 2 
0541			;      if first block of file 
0541			;         Display file name 
0541			;         Display type flags for file 
0541			;        
0541			 
0541			; moving to words as this requires stack control 
0541			 
0541			 
0541			; Delete File 
0541			; ----------- 
0541			; 
0541			; With current bank 
0541			; 
0541			; Load Block 0 Config 
0541			; Get max file id number 
0541			; For each logical block 
0541			;    Read block file id 
0541			;      If first block of file and dont have file id 
0541			;         if file to delete 
0541			;         Save file id 
0541			;         Null file id 
0541			;         Write this block back 
0541			;      If file id is one saved 
0541			;         Null file id 
0541			;         Write this block back 
0541			 
0541			storage_erase: 
0541			 
0541				; hl contains the file id 
0541			 
0541 5d				ld e, l 
0542 16 00			ld d, 0 
0544 21 40 00			ld hl, STORE_BLOCK_PHY 
0547					if DEBUG_FORTH_WORDS 
0547						DMARK "ERA" 
0547 f5				push af  
0548 3a 5c 05			ld a, (.dmark)  
054b 32 77 fb			ld (debug_mark),a  
054e 3a 5d 05			ld a, (.dmark+1)  
0551 32 78 fb			ld (debug_mark+1),a  
0554 3a 5e 05			ld a, (.dmark+2)  
0557 32 79 fb			ld (debug_mark+2),a  
055a 18 03			jr .pastdmark  
055c ..			.dmark: db "ERA"  
055f f1			.pastdmark: pop af  
0560			endm  
# End of macro DMARK
0560						CALLMONITOR 
0560 cd 01 15			call break_point_state  
0563				endm  
# End of macro CALLMONITOR
0563					endif 
0563 cd 22 06			call storage_findnextid 
0566			 
0566 e5				push hl 
0567			 
0567				; TODO check file not found 
0567			 
0567 11 62 f8			ld de, store_page 
056a cd 0c 03			call storage_read_block 
056d			 
056d					if DEBUG_FORTH_WORDS 
056d						DMARK "ER1" 
056d f5				push af  
056e 3a 82 05			ld a, (.dmark)  
0571 32 77 fb			ld (debug_mark),a  
0574 3a 83 05			ld a, (.dmark+1)  
0577 32 78 fb			ld (debug_mark+1),a  
057a 3a 84 05			ld a, (.dmark+2)  
057d 32 79 fb			ld (debug_mark+2),a  
0580 18 03			jr .pastdmark  
0582 ..			.dmark: db "ER1"  
0585 f1			.pastdmark: pop af  
0586			endm  
# End of macro DMARK
0586						CALLMONITOR 
0586 cd 01 15			call break_point_state  
0589				endm  
# End of macro CALLMONITOR
0589					endif 
0589 3a 62 f8			ld a, (store_page)	; get file id 
058c 32 5b f8			ld (store_tmpid), a 
058f			 
058f 3a 64 f8			ld a, (store_page+2)    ; get count of extends 
0592 32 5a f8			ld (store_tmpext), a 
0595			 
0595				; wipe file header 
0595			 
0595 e1				pop hl 
0596 3e 00			ld a, 0 
0598 32 62 f8			ld (store_page), a 
059b 32 63 f8			ld (store_page+1),a 
059e 11 62 f8			ld de, store_page 
05a1					if DEBUG_FORTH_WORDS 
05a1						DMARK "ER2" 
05a1 f5				push af  
05a2 3a b6 05			ld a, (.dmark)  
05a5 32 77 fb			ld (debug_mark),a  
05a8 3a b7 05			ld a, (.dmark+1)  
05ab 32 78 fb			ld (debug_mark+1),a  
05ae 3a b8 05			ld a, (.dmark+2)  
05b1 32 79 fb			ld (debug_mark+2),a  
05b4 18 03			jr .pastdmark  
05b6 ..			.dmark: db "ER2"  
05b9 f1			.pastdmark: pop af  
05ba			endm  
# End of macro DMARK
05ba						CALLMONITOR 
05ba cd 01 15			call break_point_state  
05bd				endm  
# End of macro CALLMONITOR
05bd					endif 
05bd cd 71 03			call storage_write_block 
05c0			 
05c0			 
05c0				; wipe file extents 
05c0			 
05c0 3a 5a f8			ld a, (store_tmpext) 
05c3 47				ld b, a 
05c4			 
05c4			.eraext:	  
05c4 c5				push bc 
05c5			 
05c5 21 40 00			ld hl, STORE_BLOCK_PHY 
05c8 3a 5b f8			ld a,(store_tmpid) 
05cb 5f				ld e, a 
05cc 50				ld d, b	 
05cd					if DEBUG_FORTH_WORDS 
05cd						DMARK "ER3" 
05cd f5				push af  
05ce 3a e2 05			ld a, (.dmark)  
05d1 32 77 fb			ld (debug_mark),a  
05d4 3a e3 05			ld a, (.dmark+1)  
05d7 32 78 fb			ld (debug_mark+1),a  
05da 3a e4 05			ld a, (.dmark+2)  
05dd 32 79 fb			ld (debug_mark+2),a  
05e0 18 03			jr .pastdmark  
05e2 ..			.dmark: db "ER3"  
05e5 f1			.pastdmark: pop af  
05e6			endm  
# End of macro DMARK
05e6						CALLMONITOR 
05e6 cd 01 15			call break_point_state  
05e9				endm  
# End of macro CALLMONITOR
05e9					endif 
05e9 cd 22 06			call storage_findnextid 
05ec			 
05ec e5				push hl 
05ed 11 62 f8			ld de, store_page 
05f0 cd 0c 03			call storage_read_block 
05f3			 
05f3				; free block	 
05f3			 
05f3 3e 00			ld a, 0 
05f5 32 62 f8			ld (store_page), a 
05f8 32 63 f8			ld (store_page+1),a 
05fb 11 62 f8			ld de, store_page 
05fe e1				pop hl 
05ff					if DEBUG_FORTH_WORDS 
05ff						DMARK "ER4" 
05ff f5				push af  
0600 3a 14 06			ld a, (.dmark)  
0603 32 77 fb			ld (debug_mark),a  
0606 3a 15 06			ld a, (.dmark+1)  
0609 32 78 fb			ld (debug_mark+1),a  
060c 3a 16 06			ld a, (.dmark+2)  
060f 32 79 fb			ld (debug_mark+2),a  
0612 18 03			jr .pastdmark  
0614 ..			.dmark: db "ER4"  
0617 f1			.pastdmark: pop af  
0618			endm  
# End of macro DMARK
0618						CALLMONITOR 
0618 cd 01 15			call break_point_state  
061b				endm  
# End of macro CALLMONITOR
061b					endif 
061b cd 71 03			call storage_write_block 
061e			 
061e c1				pop bc 
061f 10 a3			djnz .eraext 
0621			 
0621 c9				ret 
0622			 
0622			 
0622			; Find Free Block 
0622			; --------------- 
0622			; 
0622			; With current bank 
0622			;  
0622			; From given starting logical block 
0622			;    Read block  
0622			;    If no file id 
0622			;         Return block id 
0622			 
0622			 
0622			; hl starting page number 
0622			; hl contains free page number or zero if no pages free 
0622			; e contains the file id to locate 
0622			; d contains the block number 
0622			 
0622			; TODO change to find file id and use zero for free block 
0622			 
0622			storage_findnextid: 
0622			 
0622				; now locate first 0 page to mark as a free block 
0622			 
0622 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0624			;	ld hl, STORE_BLOCK_PHY 
0624			 
0624					if DEBUG_FORTH_WORDS 
0624					DMARK "FNI" 
0624 f5				push af  
0625 3a 39 06			ld a, (.dmark)  
0628 32 77 fb			ld (debug_mark),a  
062b 3a 3a 06			ld a, (.dmark+1)  
062e 32 78 fb			ld (debug_mark+1),a  
0631 3a 3b 06			ld a, (.dmark+2)  
0634 32 79 fb			ld (debug_mark+2),a  
0637 18 03			jr .pastdmark  
0639 ..			.dmark: db "FNI"  
063c f1			.pastdmark: pop af  
063d			endm  
# End of macro DMARK
063d						CALLMONITOR 
063d cd 01 15			call break_point_state  
0640				endm  
# End of macro CALLMONITOR
0640					endif 
0640			.ff1:   	 
0640 e5					push hl 
0641 c5					push bc 
0642 d5					push de 
0643 cd 8c 02				call se_readbyte 
0646 5f					ld e,a 
0647 23					inc hl 
0648 cd 8c 02				call se_readbyte 
064b 57					ld d, a 
064c e1					pop hl 
064d e5					push hl 
064e cd dd 0c				call cmp16 
0651 28 49				jr z, .fffound 
0653			 
0653 d1					pop de 
0654 c1					pop bc 
0655 e1					pop hl 
0656			 
0656					; is found? 
0656					;cp e 
0656					;ret z 
0656			 
0656 3e 40				ld a, STORE_BLOCK_PHY 
0658 cd bf 0c				call addatohl 
065b 10 e3				djnz .ff1 
065d			 
065d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
065f			.ff2:   	 
065f			 
065f e5					push hl 
0660 c5					push bc 
0661 d5					push de 
0662 cd 8c 02				call se_readbyte 
0665 5f					ld e,a 
0666 23					inc hl 
0667 cd 8c 02				call se_readbyte 
066a 57					ld d, a 
066b			 
066b e1					pop hl 
066c e5					push hl 
066d cd dd 0c				call cmp16 
0670 28 2a				jr z, .fffound 
0672			 
0672 d1					pop de 
0673 c1					pop bc 
0674 e1					pop hl 
0675					; is found? 
0675					;cp e 
0675					;ret z 
0675			 
0675 3e 40				ld a, STORE_BLOCK_PHY 
0677 cd bf 0c				call addatohl 
067a 10 e3				djnz .ff2 
067c			 
067c			 
067c					if DEBUG_FORTH_WORDS 
067c					DMARK "FN-" 
067c f5				push af  
067d 3a 91 06			ld a, (.dmark)  
0680 32 77 fb			ld (debug_mark),a  
0683 3a 92 06			ld a, (.dmark+1)  
0686 32 78 fb			ld (debug_mark+1),a  
0689 3a 93 06			ld a, (.dmark+2)  
068c 32 79 fb			ld (debug_mark+2),a  
068f 18 03			jr .pastdmark  
0691 ..			.dmark: db "FN-"  
0694 f1			.pastdmark: pop af  
0695			endm  
# End of macro DMARK
0695					;	push af 
0695					;	ld a, 'n' 
0695					;	ld (debug_mark),a 
0695					;	pop af 
0695						CALLMONITOR 
0695 cd 01 15			call break_point_state  
0698				endm  
# End of macro CALLMONITOR
0698					endif 
0698				; no free marks! 
0698 21 00 00				ld hl, 0 
069b c9				ret 
069c			.fffound: 
069c				 
069c			 
069c d1					pop de 
069d c1					pop bc 
069e e1					pop hl 
069f					if DEBUG_FORTH_WORDS 
069f					DMARK "FNF" 
069f f5				push af  
06a0 3a b4 06			ld a, (.dmark)  
06a3 32 77 fb			ld (debug_mark),a  
06a6 3a b5 06			ld a, (.dmark+1)  
06a9 32 78 fb			ld (debug_mark+1),a  
06ac 3a b6 06			ld a, (.dmark+2)  
06af 32 79 fb			ld (debug_mark+2),a  
06b2 18 03			jr .pastdmark  
06b4 ..			.dmark: db "FNF"  
06b7 f1			.pastdmark: pop af  
06b8			endm  
# End of macro DMARK
06b8					;	push af 
06b8					;	ld a, 'n' 
06b8					;	ld (debug_mark),a 
06b8					;	pop af 
06b8						CALLMONITOR 
06b8 cd 01 15			call break_point_state  
06bb				endm  
# End of macro CALLMONITOR
06bb					endif 
06bb c9				ret 
06bc			 
06bc			 
06bc			 
06bc			; Free Space 
06bc			; ---------- 
06bc			; 
06bc			; With current bank 
06bc			; 
06bc			; Set block count to zero 
06bc			; Starting with first logical block 
06bc			;      Find free block  
06bc			;      If block id given, increment block count 
06bc			; 
06bc			;  
06bc			 
06bc			 
06bc			; hl contains count of free blocks 
06bc			 
06bc			storage_freeblocks: 
06bc			 
06bc				; now locate first 0 page to mark as a free block 
06bc			 
06bc 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06be 21 40 00			ld hl, STORE_BLOCK_PHY 
06c1 11 00 00			ld de, 0 
06c4			 
06c4			.fb1:   	 
06c4 e5					push hl 
06c5 c5					push bc 
06c6 d5					push de 
06c7 cd 8c 02				call se_readbyte 
06ca d1					pop de 
06cb c1					pop bc 
06cc e1					pop hl 
06cd			 
06cd					; is free? 
06cd fe 00				cp 0 
06cf 20 01				jr nz, .ff1cont 
06d1 13					inc de 
06d2			 
06d2			.ff1cont: 
06d2			 
06d2			 
06d2 3e 40				ld a, STORE_BLOCK_PHY 
06d4 cd bf 0c				call addatohl 
06d7 10 eb				djnz .fb1 
06d9			 
06d9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06db			.fb2:   	 
06db e5					push hl 
06dc c5					push bc 
06dd d5					push de 
06de cd 8c 02				call se_readbyte 
06e1 d1					pop de 
06e2 c1					pop bc 
06e3 e1					pop hl 
06e4			 
06e4					; is free? 
06e4 fe 00				cp 0 
06e6 20 01				jr nz, .ff2cont 
06e8 13					inc de 
06e9			 
06e9			.ff2cont: 
06e9			 
06e9 3e 40				ld a, STORE_BLOCK_PHY 
06eb cd bf 0c				call addatohl 
06ee 10 eb				djnz .fb2 
06f0			 
06f0 eb				ex de, hl 
06f1 c9				ret 
06f2			 
06f2			; Get File ID 
06f2			; ----------- 
06f2			; 
06f2			; With current bank 
06f2			;  
06f2			; Load Block 0 Config 
06f2			; Get max file id number 
06f2			; For each logical block 
06f2			;    Read block file id 
06f2			;      If first block of file and dont have file id 
06f2			;         if file get id and exit 
06f2			 
06f2			 
06f2			 
06f2			 
06f2			; Create File 
06f2			; ----------- 
06f2			; 
06f2			; With current bank  
06f2			; Load Block 0 Config 
06f2			; Get max file id number 
06f2			; Increment file id number 
06f2			; Save Config 
06f2			; Find free block 
06f2			; Set buffer with file name and file id 
06f2			; Write buffer to free block  
06f2			 
06f2			 
06f2			; hl point to file name 
06f2			; hl returns file id 
06f2			 
06f2			; file format: 
06f2			; byte 0 - file id 
06f2			; byte 1 - extent number 
06f2			; byte 2-> data 
06f2			 
06f2			; format for extent number 0: 
06f2			; 
06f2			; byte 0 - file id 
06f2			; byte 1 - extent 0 
06f2			; byte 2 - extent count 
06f2			; byte 3 -> file name and meta data 
06f2			 
06f2			 
06f2			storage_create: 
06f2				if DEBUG_STORESE 
06f2					DMARK "SCR" 
06f2 f5				push af  
06f3 3a 07 07			ld a, (.dmark)  
06f6 32 77 fb			ld (debug_mark),a  
06f9 3a 08 07			ld a, (.dmark+1)  
06fc 32 78 fb			ld (debug_mark+1),a  
06ff 3a 09 07			ld a, (.dmark+2)  
0702 32 79 fb			ld (debug_mark+2),a  
0705 18 03			jr .pastdmark  
0707 ..			.dmark: db "SCR"  
070a f1			.pastdmark: pop af  
070b			endm  
# End of macro DMARK
070b					CALLMONITOR 
070b cd 01 15			call break_point_state  
070e				endm  
# End of macro CALLMONITOR
070e				endif 
070e			 
070e e5				push hl		; save file name pointer 
070f			 
070f cd bd 03			call storage_get_block_0 
0712			 
0712 3a 62 f8			ld a,(store_page)	; get current file id 
0715 3c				inc a 
0716 32 62 f8			ld (store_page),a 
0719				 
0719 32 5b f8			ld (store_tmpid),a			; save id 
071c			 
071c 21 00 00			ld hl, 0 
071f 11 62 f8			ld de, store_page 
0722				if DEBUG_STORESE 
0722					DMARK "SCw" 
0722 f5				push af  
0723 3a 37 07			ld a, (.dmark)  
0726 32 77 fb			ld (debug_mark),a  
0729 3a 38 07			ld a, (.dmark+1)  
072c 32 78 fb			ld (debug_mark+1),a  
072f 3a 39 07			ld a, (.dmark+2)  
0732 32 79 fb			ld (debug_mark+2),a  
0735 18 03			jr .pastdmark  
0737 ..			.dmark: db "SCw"  
073a f1			.pastdmark: pop af  
073b			endm  
# End of macro DMARK
073b					CALLMONITOR 
073b cd 01 15			call break_point_state  
073e				endm  
# End of macro CALLMONITOR
073e				endif 
073e cd 71 03			call storage_write_block	 ; save update 
0741			 
0741				if DEBUG_STORESE 
0741 11 62 f8				ld de, store_page 
0744					DMARK "SCC" 
0744 f5				push af  
0745 3a 59 07			ld a, (.dmark)  
0748 32 77 fb			ld (debug_mark),a  
074b 3a 5a 07			ld a, (.dmark+1)  
074e 32 78 fb			ld (debug_mark+1),a  
0751 3a 5b 07			ld a, (.dmark+2)  
0754 32 79 fb			ld (debug_mark+2),a  
0757 18 03			jr .pastdmark  
0759 ..			.dmark: db "SCC"  
075c f1			.pastdmark: pop af  
075d			endm  
# End of macro DMARK
075d					CALLMONITOR 
075d cd 01 15			call break_point_state  
0760				endm  
# End of macro CALLMONITOR
0760				endif 
0760				;  
0760				 
0760 21 40 00			ld hl, STORE_BLOCK_PHY 
0763 11 00 00			ld de, 0 
0766 cd 22 06			call storage_findnextid 
0769			 
0769 22 60 f8			ld (store_tmppageid), hl    ; save page to use  
076c			 
076c				; TODO detect 0 = no spare blocks 
076c			 
076c				; hl now contains the free page to use for the file header page 
076c			 
076c				if DEBUG_STORESE 
076c				DMARK "SCF" 
076c f5				push af  
076d 3a 81 07			ld a, (.dmark)  
0770 32 77 fb			ld (debug_mark),a  
0773 3a 82 07			ld a, (.dmark+1)  
0776 32 78 fb			ld (debug_mark+1),a  
0779 3a 83 07			ld a, (.dmark+2)  
077c 32 79 fb			ld (debug_mark+2),a  
077f 18 03			jr .pastdmark  
0781 ..			.dmark: db "SCF"  
0784 f1			.pastdmark: pop af  
0785			endm  
# End of macro DMARK
0785					CALLMONITOR 
0785 cd 01 15			call break_point_state  
0788				endm  
# End of macro CALLMONITOR
0788				endif 
0788			 
0788 22 60 f8			ld (store_tmppageid), hl 
078b				 
078b 3a 5b f8			ld a,(store_tmpid)    ; get file id 
078e			;	ld a, (store_filecache)			; save to cache 
078e			 
078e 32 62 f8			ld (store_page),a    ; set page id 
0791 3e 00			ld a, 0			 ; extent 0 is file header 
0793 32 63 f8			ld (store_page+1), a   ; set file extent 
0796			 
0796 32 64 f8			ld (store_page+2), a   ; extent count for the file 
0799			 
0799			;	inc hl 		; init block 0 of file 
0799			;	inc hl   		; skip file and extent id 
0799			 ;       ld a, 0 
0799			;	ld (hl),a 
0799			;	ld a, (store_filecache+1)  	; save to cache 
0799			 
0799			;	inc hl    ; file name 
0799				 
0799				 
0799 11 65 f8			ld de, store_page+3    ; get buffer for term string to use as file name 
079c				if DEBUG_STORESE 
079c					DMARK "SCc" 
079c f5				push af  
079d 3a b1 07			ld a, (.dmark)  
07a0 32 77 fb			ld (debug_mark),a  
07a3 3a b2 07			ld a, (.dmark+1)  
07a6 32 78 fb			ld (debug_mark+1),a  
07a9 3a b3 07			ld a, (.dmark+2)  
07ac 32 79 fb			ld (debug_mark+2),a  
07af 18 03			jr .pastdmark  
07b1 ..			.dmark: db "SCc"  
07b4 f1			.pastdmark: pop af  
07b5			endm  
# End of macro DMARK
07b5					CALLMONITOR 
07b5 cd 01 15			call break_point_state  
07b8				endm  
# End of macro CALLMONITOR
07b8				endif 
07b8 e1				pop hl    ; get zero term string 
07b9 e5				push hl 
07ba 3e 00			ld a, 0 
07bc cd 28 11			call strlent 
07bf 23				inc hl   ; cover zero term 
07c0 06 00			ld b,0 
07c2 4d				ld c,l 
07c3 e1				pop hl 
07c4				;ex de, hl 
07c4				if DEBUG_STORESE 
07c4					DMARK "SCa" 
07c4 f5				push af  
07c5 3a d9 07			ld a, (.dmark)  
07c8 32 77 fb			ld (debug_mark),a  
07cb 3a da 07			ld a, (.dmark+1)  
07ce 32 78 fb			ld (debug_mark+1),a  
07d1 3a db 07			ld a, (.dmark+2)  
07d4 32 79 fb			ld (debug_mark+2),a  
07d7 18 03			jr .pastdmark  
07d9 ..			.dmark: db "SCa"  
07dc f1			.pastdmark: pop af  
07dd			endm  
# End of macro DMARK
07dd					;push af 
07dd					;ld a, 'a' 
07dd					;ld (debug_mark),a 
07dd					;pop af 
07dd					CALLMONITOR 
07dd cd 01 15			call break_point_state  
07e0				endm  
# End of macro CALLMONITOR
07e0				endif 
07e0 ed b0			ldir    ; copy zero term string 
07e2				if DEBUG_STORESE 
07e2					DMARK "SCA" 
07e2 f5				push af  
07e3 3a f7 07			ld a, (.dmark)  
07e6 32 77 fb			ld (debug_mark),a  
07e9 3a f8 07			ld a, (.dmark+1)  
07ec 32 78 fb			ld (debug_mark+1),a  
07ef 3a f9 07			ld a, (.dmark+2)  
07f2 32 79 fb			ld (debug_mark+2),a  
07f5 18 03			jr .pastdmark  
07f7 ..			.dmark: db "SCA"  
07fa f1			.pastdmark: pop af  
07fb			endm  
# End of macro DMARK
07fb					CALLMONITOR 
07fb cd 01 15			call break_point_state  
07fe				endm  
# End of macro CALLMONITOR
07fe				endif 
07fe			 
07fe				; write file header page 
07fe			 
07fe 2a 60 f8			ld hl,(store_tmppageid) 
0801 11 62 f8			ld de, store_page 
0804				if DEBUG_STORESE 
0804					DMARK "SCb" 
0804 f5				push af  
0805 3a 19 08			ld a, (.dmark)  
0808 32 77 fb			ld (debug_mark),a  
080b 3a 1a 08			ld a, (.dmark+1)  
080e 32 78 fb			ld (debug_mark+1),a  
0811 3a 1b 08			ld a, (.dmark+2)  
0814 32 79 fb			ld (debug_mark+2),a  
0817 18 03			jr .pastdmark  
0819 ..			.dmark: db "SCb"  
081c f1			.pastdmark: pop af  
081d			endm  
# End of macro DMARK
081d					;push af 
081d					;ld a, 'b' 
081d					;ld (debug_mark),a 
081d					;pop af 
081d					CALLMONITOR 
081d cd 01 15			call break_point_state  
0820				endm  
# End of macro CALLMONITOR
0820				endif 
0820 cd 71 03			call storage_write_block 
0823			 
0823 3a 5b f8			ld a, (store_tmpid) 
0826 6f				ld l, a 
0827 26 00			ld h,0 
0829				if DEBUG_STORESE 
0829					DMARK "SCz" 
0829 f5				push af  
082a 3a 3e 08			ld a, (.dmark)  
082d 32 77 fb			ld (debug_mark),a  
0830 3a 3f 08			ld a, (.dmark+1)  
0833 32 78 fb			ld (debug_mark+1),a  
0836 3a 40 08			ld a, (.dmark+2)  
0839 32 79 fb			ld (debug_mark+2),a  
083c 18 03			jr .pastdmark  
083e ..			.dmark: db "SCz"  
0841 f1			.pastdmark: pop af  
0842			endm  
# End of macro DMARK
0842					CALLMONITOR 
0842 cd 01 15			call break_point_state  
0845				endm  
# End of macro CALLMONITOR
0845				endif 
0845 c9				ret 
0846				 
0846			 
0846			 
0846			; 
0846			; Read File 
0846			; 
0846			; h - file id to locate 
0846			; l - extent to locate 
0846			; de - pointer to string to read into 
0846			; 
0846			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0846			storage_read: 
0846 d5				push de 
0847			 
0847			; TODO BUG the above push is it popped before the RET Z? 
0847			 
0847			; TODO how to handle multiple part blocks 
0847			 
0847				; locate file extent to read 
0847			 
0847 5c				ld e, h 
0848 55				ld d, l 
0849 21 40 00			ld hl, STORE_BLOCK_PHY 
084c				if DEBUG_STORESE 
084c					DMARK "SRE" 
084c f5				push af  
084d 3a 61 08			ld a, (.dmark)  
0850 32 77 fb			ld (debug_mark),a  
0853 3a 62 08			ld a, (.dmark+1)  
0856 32 78 fb			ld (debug_mark+1),a  
0859 3a 63 08			ld a, (.dmark+2)  
085c 32 79 fb			ld (debug_mark+2),a  
085f 18 03			jr .pastdmark  
0861 ..			.dmark: db "SRE"  
0864 f1			.pastdmark: pop af  
0865			endm  
# End of macro DMARK
0865					CALLMONITOR 
0865 cd 01 15			call break_point_state  
0868				endm  
# End of macro CALLMONITOR
0868				endif 
0868 cd 22 06			call storage_findnextid 
086b			 
086b				if DEBUG_STORESE 
086b					DMARK "SRf" 
086b f5				push af  
086c 3a 80 08			ld a, (.dmark)  
086f 32 77 fb			ld (debug_mark),a  
0872 3a 81 08			ld a, (.dmark+1)  
0875 32 78 fb			ld (debug_mark+1),a  
0878 3a 82 08			ld a, (.dmark+2)  
087b 32 79 fb			ld (debug_mark+2),a  
087e 18 03			jr .pastdmark  
0880 ..			.dmark: db "SRf"  
0883 f1			.pastdmark: pop af  
0884			endm  
# End of macro DMARK
0884					CALLMONITOR 
0884 cd 01 15			call break_point_state  
0887				endm  
# End of macro CALLMONITOR
0887				endif 
0887 cd e8 0c			call ishlzero 
088a			;	ld a, l 
088a			;	add h 
088a			;	cp 0 
088a c8				ret z			; block not found so EOF 
088b			 
088b				; hl contains page number to load 
088b d1				pop de   ; get storage 
088c d5				push de 
088d				if DEBUG_STORESE 
088d					DMARK "SRg" 
088d f5				push af  
088e 3a a2 08			ld a, (.dmark)  
0891 32 77 fb			ld (debug_mark),a  
0894 3a a3 08			ld a, (.dmark+1)  
0897 32 78 fb			ld (debug_mark+1),a  
089a 3a a4 08			ld a, (.dmark+2)  
089d 32 79 fb			ld (debug_mark+2),a  
08a0 18 03			jr .pastdmark  
08a2 ..			.dmark: db "SRg"  
08a5 f1			.pastdmark: pop af  
08a6			endm  
# End of macro DMARK
08a6					CALLMONITOR 
08a6 cd 01 15			call break_point_state  
08a9				endm  
# End of macro CALLMONITOR
08a9				endif 
08a9 cd 0c 03			call storage_read_block 
08ac			 
08ac			 
08ac			; TODO if block has no zeros then need to read next block  
08ac			 
08ac			 
08ac					 
08ac e1				pop hl 		 ; return start of data to show as not EOF 
08ad 23				inc hl   ; past file id 
08ae 23				inc hl   ; past ext 
08af				if DEBUG_STORESE 
08af					DMARK "SRe" 
08af f5				push af  
08b0 3a c4 08			ld a, (.dmark)  
08b3 32 77 fb			ld (debug_mark),a  
08b6 3a c5 08			ld a, (.dmark+1)  
08b9 32 78 fb			ld (debug_mark+1),a  
08bc 3a c6 08			ld a, (.dmark+2)  
08bf 32 79 fb			ld (debug_mark+2),a  
08c2 18 03			jr .pastdmark  
08c4 ..			.dmark: db "SRe"  
08c7 f1			.pastdmark: pop af  
08c8			endm  
# End of macro DMARK
08c8					CALLMONITOR 
08c8 cd 01 15			call break_point_state  
08cb				endm  
# End of macro CALLMONITOR
08cb				endif 
08cb c9					ret 
08cc			 
08cc			 
08cc			 
08cc			; 
08cc			; Append File 
08cc			; 
08cc			; hl - file id to locate 
08cc			; de - pointer to (multi block) string to write 
08cc			 
08cc			 
08cc			storage_append: 
08cc				; hl -  file id to append to 
08cc				; de - string to append 
08cc			 
08cc d5				push de 
08cd				 
08cd				if DEBUG_STORESE 
08cd					DMARK "AP1" 
08cd f5				push af  
08ce 3a e2 08			ld a, (.dmark)  
08d1 32 77 fb			ld (debug_mark),a  
08d4 3a e3 08			ld a, (.dmark+1)  
08d7 32 78 fb			ld (debug_mark+1),a  
08da 3a e4 08			ld a, (.dmark+2)  
08dd 32 79 fb			ld (debug_mark+2),a  
08e0 18 03			jr .pastdmark  
08e2 ..			.dmark: db "AP1"  
08e5 f1			.pastdmark: pop af  
08e6			endm  
# End of macro DMARK
08e6					CALLMONITOR 
08e6 cd 01 15			call break_point_state  
08e9				endm  
# End of macro CALLMONITOR
08e9				endif 
08e9			 
08e9 7d				ld a, l 
08ea 32 5b f8			ld (store_tmpid), a 
08ed			 
08ed				; get file header  
08ed			 
08ed 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08ef 3a 5b f8			ld a, (store_tmpid) 
08f2 5f				ld e, a 
08f3			 
08f3 21 40 00				ld hl, STORE_BLOCK_PHY 
08f6 cd 22 06				call storage_findnextid 
08f9			 
08f9 22 60 f8			ld (store_tmppageid), hl 
08fc			 
08fc				; TODO handle file id not found 
08fc			 
08fc				if DEBUG_STORESE 
08fc					DMARK "AP2" 
08fc f5				push af  
08fd 3a 11 09			ld a, (.dmark)  
0900 32 77 fb			ld (debug_mark),a  
0903 3a 12 09			ld a, (.dmark+1)  
0906 32 78 fb			ld (debug_mark+1),a  
0909 3a 13 09			ld a, (.dmark+2)  
090c 32 79 fb			ld (debug_mark+2),a  
090f 18 03			jr .pastdmark  
0911 ..			.dmark: db "AP2"  
0914 f1			.pastdmark: pop af  
0915			endm  
# End of macro DMARK
0915					CALLMONITOR 
0915 cd 01 15			call break_point_state  
0918				endm  
# End of macro CALLMONITOR
0918				endif 
0918			 
0918				; update file extent count 
0918			 
0918 11 62 f8			ld de, store_page 
091b			 
091b cd 0c 03			call storage_read_block 
091e			 
091e				if DEBUG_STORESE 
091e					DMARK "AP3" 
091e f5				push af  
091f 3a 33 09			ld a, (.dmark)  
0922 32 77 fb			ld (debug_mark),a  
0925 3a 34 09			ld a, (.dmark+1)  
0928 32 78 fb			ld (debug_mark+1),a  
092b 3a 35 09			ld a, (.dmark+2)  
092e 32 79 fb			ld (debug_mark+2),a  
0931 18 03			jr .pastdmark  
0933 ..			.dmark: db "AP3"  
0936 f1			.pastdmark: pop af  
0937			endm  
# End of macro DMARK
0937					CALLMONITOR 
0937 cd 01 15			call break_point_state  
093a				endm  
# End of macro CALLMONITOR
093a				endif 
093a			;	ld (store_tmppageid), hl 
093a			 
093a 3a 64 f8			ld a, (store_page+2) 
093d 3c				inc a 
093e 32 64 f8			ld (store_page+2), a 
0941 32 5a f8			ld (store_tmpext), a 
0944				 
0944				if DEBUG_STORESE 
0944					DMARK "AP3" 
0944 f5				push af  
0945 3a 59 09			ld a, (.dmark)  
0948 32 77 fb			ld (debug_mark),a  
094b 3a 5a 09			ld a, (.dmark+1)  
094e 32 78 fb			ld (debug_mark+1),a  
0951 3a 5b 09			ld a, (.dmark+2)  
0954 32 79 fb			ld (debug_mark+2),a  
0957 18 03			jr .pastdmark  
0959 ..			.dmark: db "AP3"  
095c f1			.pastdmark: pop af  
095d			endm  
# End of macro DMARK
095d					CALLMONITOR 
095d cd 01 15			call break_point_state  
0960				endm  
# End of macro CALLMONITOR
0960				endif 
0960 2a 60 f8			ld hl, (store_tmppageid) 
0963 11 62 f8			ld de, store_page 
0966 cd 71 03			call storage_write_block 
0969			 
0969				; find free block 
0969			 
0969 11 00 00			ld de, 0			 ; file extent to locate 
096c			 
096c 21 40 00				ld hl, STORE_BLOCK_PHY 
096f cd 22 06				call storage_findnextid 
0972			 
0972					; TODO handle no space left 
0972					 
0972 22 60 f8				ld (store_tmppageid), hl 
0975			 
0975				if DEBUG_STORESE 
0975					DMARK "AP4" 
0975 f5				push af  
0976 3a 8a 09			ld a, (.dmark)  
0979 32 77 fb			ld (debug_mark),a  
097c 3a 8b 09			ld a, (.dmark+1)  
097f 32 78 fb			ld (debug_mark+1),a  
0982 3a 8c 09			ld a, (.dmark+2)  
0985 32 79 fb			ld (debug_mark+2),a  
0988 18 03			jr .pastdmark  
098a ..			.dmark: db "AP4"  
098d f1			.pastdmark: pop af  
098e			endm  
# End of macro DMARK
098e					CALLMONITOR 
098e cd 01 15			call break_point_state  
0991				endm  
# End of macro CALLMONITOR
0991				endif 
0991					; init the buffer with zeros so we can id if the buffer is full or not 
0991			 
0991 e5					push hl 
0992 c5					push bc 
0993			 
0993 21 62 f8				ld hl, store_page 
0996 06 40				ld b, STORE_BLOCK_PHY 
0998 3e 00				ld a, 0 
099a 77			.zeroblock:	ld (hl), a 
099b 23					inc hl 
099c 10 fc				djnz .zeroblock 
099e			 
099e c1					pop bc 
099f e1					pop hl 
09a0			 
09a0					; construct block 
09a0			 
09a0 3a 5b f8				ld a, (store_tmpid) 
09a3 32 62 f8				ld (store_page), a   ; file id 
09a6 3a 5a f8				ld a, (store_tmpext)   ; extent for this block 
09a9 32 63 f8				ld (store_page+1), a 
09ac			 
09ac e1					pop hl    ; get string to write 
09ad 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09af 11 64 f8				ld de, store_page+2 
09b2			 
09b2				if DEBUG_STORESE 
09b2					DMARK "AP5" 
09b2 f5				push af  
09b3 3a c7 09			ld a, (.dmark)  
09b6 32 77 fb			ld (debug_mark),a  
09b9 3a c8 09			ld a, (.dmark+1)  
09bc 32 78 fb			ld (debug_mark+1),a  
09bf 3a c9 09			ld a, (.dmark+2)  
09c2 32 79 fb			ld (debug_mark+2),a  
09c5 18 03			jr .pastdmark  
09c7 ..			.dmark: db "AP5"  
09ca f1			.pastdmark: pop af  
09cb			endm  
# End of macro DMARK
09cb					CALLMONITOR 
09cb cd 01 15			call break_point_state  
09ce				endm  
# End of macro CALLMONITOR
09ce				endif 
09ce			 
09ce			 
09ce			 
09ce					; fill buffer with data until end of string or full block 
09ce			 
09ce 7e			.appd:		ld a, (hl) 
09cf 12					ld (de), a 
09d0 fe 00				cp 0 
09d2 28 04				jr z, .appdone 
09d4 23					inc hl 
09d5 13					inc de 
09d6 10 f6				djnz .appd 
09d8			 
09d8 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09d9 f5					push af   		; save last byte dumped 
09da			 
09da			 
09da 2a 60 f8			ld hl, (store_tmppageid) 
09dd 11 62 f8			ld de, store_page 
09e0				if DEBUG_STORESE 
09e0					DMARK "AP6" 
09e0 f5				push af  
09e1 3a f5 09			ld a, (.dmark)  
09e4 32 77 fb			ld (debug_mark),a  
09e7 3a f6 09			ld a, (.dmark+1)  
09ea 32 78 fb			ld (debug_mark+1),a  
09ed 3a f7 09			ld a, (.dmark+2)  
09f0 32 79 fb			ld (debug_mark+2),a  
09f3 18 03			jr .pastdmark  
09f5 ..			.dmark: db "AP6"  
09f8 f1			.pastdmark: pop af  
09f9			endm  
# End of macro DMARK
09f9					CALLMONITOR 
09f9 cd 01 15			call break_point_state  
09fc				endm  
# End of macro CALLMONITOR
09fc				endif 
09fc cd 71 03				call storage_write_block 
09ff			 
09ff			 
09ff				; was that a full block of data written? 
09ff				; any more to write out? 
09ff			 
09ff				; if yes then set vars and jump to start of function again 
09ff			 
09ff f1					pop af 
0a00 d1					pop de 
0a01			 
0a01 fe 00				cp 0		 ; no, string was fully written 
0a03 c8					ret z 
0a04			 
0a04					; setup vars for next cycle 
0a04			 
0a04 3a 5b f8				ld a, (store_tmpid) 
0a07 6f					ld l, a 
0a08 26 00				ld h, 0 
0a0a			 
0a0a c3 cc 08			 	jp storage_append	 ; yes, need to write out some more 
0a0d			 
0a0d			 
0a0d			 
0a0d			 
0a0d			 
0a0d			 
0a0d			 
0a0d			if DEBUG_STORECF 
0a0d			storageput:	 
0a0d					ret 
0a0d			storageread: 
0a0d					ld hl, store_page 
0a0d					ld b, 200 
0a0d					ld a,0 
0a0d			.src:		ld (hl),a 
0a0d					inc hl 
0a0d					djnz .src 
0a0d					 
0a0d			 
0a0d					ld de, 0 
0a0d					ld bc, 1 
0a0d					ld hl, store_page 
0a0d					call cfRead 
0a0d			 
0a0d				call cfGetError 
0a0d				ld hl,scratch 
0a0d				call hexout 
0a0d				ld hl, scratch+2 
0a0d				ld a, 0 
0a0d				ld (hl),a 
0a0d				ld de, scratch 
0a0d				ld a,display_row_1 
0a0d				call str_at_display 
0a0d				call update_display 
0a0d			 
0a0d					ld hl, store_page 
0a0d					ld (os_cur_ptr),hl 
0a0d			 
0a0d					ret 
0a0d			endif 
0a0d			 
0a0d			 
0a0d			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a0d			 
0a0d			storage_clear_page: 
0a0d e5				push hl 
0a0e d5				push de 
0a0f c5				push bc 
0a10 21 62 f8			ld hl, store_page 
0a13 3e 00			ld a, 0 
0a15 77				ld (hl), a 
0a16			 
0a16 11 63 f8			ld de, store_page+1 
0a19 01 40 00			ld bc, STORE_BLOCK_PHY 
0a1c			 
0a1c ed b0			ldir 
0a1e				 
0a1e c1				pop bc 
0a1f d1				pop de 
0a20 e1				pop hl 
0a21 c9				ret 
0a22			 
0a22			; eof 
# End of file firmware_storage.asm
0a22			  
0a22			; support routines for above hardware abstraction layer  
0a22			  
0a22			include "firmware_general.asm"        ; general support functions  
0a22			 
0a22			 
0a22			 
0a22			; Delay loops 
0a22			 
0a22			 
0a22			 
0a22			aDelayInMS: 
0a22 c5				push bc 
0a23 47				ld b,a 
0a24			msdelay: 
0a24 c5				push bc 
0a25				 
0a25			 
0a25 01 41 00			ld bc,041h 
0a28 cd 40 0a			call delayloop 
0a2b c1				pop bc 
0a2c 05				dec b 
0a2d 20 f5			jr nz,msdelay 
0a2f			 
0a2f			;if CPU_CLOCK_8MHZ 
0a2f			;msdelay8: 
0a2f			;	push bc 
0a2f			;	 
0a2f			; 
0a2f			;	ld bc,041h 
0a2f			;	call delayloop 
0a2f			;	pop bc 
0a2f			;	dec b 
0a2f			;	jr nz,msdelay8 
0a2f			;endif 
0a2f			 
0a2f			 
0a2f c1				pop bc 
0a30 c9				ret 
0a31			 
0a31			 
0a31			delay250ms: 
0a31				;push de 
0a31 01 00 40			ld bc, 04000h 
0a34 c3 40 0a			jp delayloop 
0a37			delay500ms: 
0a37				;push de 
0a37 01 00 80			ld bc, 08000h 
0a3a c3 40 0a			jp delayloop 
0a3d			delay1s: 
0a3d				;push bc 
0a3d			   ; Clobbers A, d and e 
0a3d 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a40			delayloop: 
0a40 c5			    push bc 
0a41			 
0a41			if BASE_CPM 
0a41				ld bc, CPM_DELAY_TUNE 
0a41			.cpmloop: 
0a41				push bc 
0a41			 
0a41			endif 
0a41			 
0a41			 
0a41			 
0a41			delayloopi: 
0a41			;	push bc 
0a41			;.dl: 
0a41 cb 47		    bit     0,a    	; 8 
0a43 cb 47		    bit     0,a    	; 8 
0a45 cb 47		    bit     0,a    	; 8 
0a47 e6 ff		    and     255  	; 7 
0a49 0b			    dec     bc      	; 6 
0a4a 79			    ld      a,c     	; 4 
0a4b b0			    or      b     	; 4 
0a4c c2 41 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a4f			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a4f				;pop de 
0a4f			;pop bc 
0a4f			 
0a4f			if BASE_CPM 
0a4f				pop bc 
0a4f				 
0a4f			    dec     bc      	; 6 
0a4f			    ld      a,c     	; 4 
0a4f			    or      b     	; 4 
0a4f			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a4f				 
0a4f			 
0a4f			endif 
0a4f			;if CPU_CLOCK_8MHZ 
0a4f			;    pop bc 
0a4f			;    push bc 
0a4f			;.dl8: 
0a4f			;    bit     0,a    	; 8 
0a4f			;    bit     0,a    	; 8 
0a4f			;    bit     0,a    	; 8 
0a4f			;    and     255  	; 7 
0a4f			;    dec     bc      	; 6 
0a4f			;    ld      a,c     	; 4 
0a4f			;    or      b     	; 4 
0a4f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a4f			;endif 
0a4f			 
0a4f			;if CPU_CLOCK_10MHZ 
0a4f			;    pop bc 
0a4f			;    push bc 
0a4f			;.dl8: 
0a4f			;    bit     0,a    	; 8 
0a4f			;    bit     0,a    	; 8 
0a4f			;    bit     0,a    	; 8 
0a4f			;    and     255  	; 7 
0a4f			;    dec     bc      	; 6 
0a4f			;    ld      a,c     	; 4 
0a4f			;    or      b     	; 4 
0a4f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a4f			;endif 
0a4f c1			    pop bc 
0a50			 
0a50 c9				ret 
0a51			 
0a51			 
0a51			 
0a51			; eof 
# End of file firmware_general.asm
0a51			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a51			; display routines that use the physical hardware abstraction layer 
0a51			 
0a51			 
0a51			; TODO windowing? 
0a51			 
0a51			; TODO scroll line up 
0a51			 
0a51			scroll_up: 
0a51			 
0a51 e5				push hl 
0a52 d5				push de 
0a53 c5				push bc 
0a54			 
0a54				; get frame buffer  
0a54			 
0a54 2a d8 f8			ld hl, (display_fb_active) 
0a57 e5				push hl    ; future de destination 
0a58			 
0a58 11 28 00			ld  de, display_cols 
0a5b 19				add hl, de 
0a5c			 
0a5c d1				pop de 
0a5d			 
0a5d				;ex de, hl 
0a5d 01 9f 00			ld bc, display_fb_len -1  
0a60			;if DEBUG_FORTH_WORDS 
0a60			;	DMARK "SCL" 
0a60			;	CALLMONITOR 
0a60			;endif	 
0a60 ed b0			ldir 
0a62			 
0a62				; wipe bottom row 
0a62			 
0a62			 
0a62 2a d8 f8			ld hl, (display_fb_active) 
0a65 11 a0 00			ld de, display_cols*display_rows 
0a68 19				add hl, de 
0a69 06 28			ld b, display_cols 
0a6b 3e 20			ld a, ' ' 
0a6d			.scwipe: 
0a6d 77				ld (hl), a 
0a6e 2b				dec hl 
0a6f 10 fc			djnz .scwipe 
0a71			 
0a71				;pop hl 
0a71			 
0a71 c1				pop bc 
0a72 d1				pop de 
0a73 e1				pop hl 
0a74			 
0a74 c9				ret 
0a75			 
0a75			 
0a75			;scroll_upo: 
0a75			;	ld de, display_row_1 
0a75			 ;	ld hl, display_row_2 
0a75			;	ld bc, display_cols 
0a75			;	ldir 
0a75			;	ld de, display_row_2 
0a75			 ;	ld hl, display_row_3 
0a75			;	ld bc, display_cols 
0a75			;	ldir 
0a75			;	ld de, display_row_3 
0a75			 ;	ld hl, display_row_4 
0a75			;	ld bc, display_cols 
0a75			;	ldir 
0a75			 
0a75			; TODO clear row 4 
0a75			 
0a75			;	ret 
0a75			 
0a75				 
0a75			scroll_down: 
0a75			 
0a75 e5				push hl 
0a76 d5				push de 
0a77 c5				push bc 
0a78			 
0a78				; get frame buffer  
0a78			 
0a78 2a d8 f8			ld hl, (display_fb_active) 
0a7b			 
0a7b 11 9f 00			ld de, display_fb_len - 1 
0a7e 19				add hl, de 
0a7f			 
0a7f e5			push hl    ; future de destination 
0a80			 
0a80 11 28 00			ld  de, display_cols 
0a83 ed 52			sbc hl, de 
0a85			 
0a85			 
0a85 d1				pop de 
0a86			 
0a86			;	ex de, hl 
0a86 01 9f 00			ld bc, display_fb_len -1  
0a89			 
0a89			 
0a89				 
0a89			 
0a89 ed b0			ldir 
0a8b			 
0a8b				; wipe bottom row 
0a8b			 
0a8b			 
0a8b			;	ld hl, (display_fb_active) 
0a8b			;;	ld de, display_cols*display_rows 
0a8b			;;	add hl, de 
0a8b			;	ld b, display_cols 
0a8b			;	ld a, ' ' 
0a8b			;.scwiped: 
0a8b			;	ld (hl), a 
0a8b			;	dec hl 
0a8b			;	djnz .scwiped 
0a8b			 
0a8b				;pop hl 
0a8b			 
0a8b c1				pop bc 
0a8c d1				pop de 
0a8d e1				pop hl 
0a8e			 
0a8e c9				ret 
0a8f			;scroll_down: 
0a8f			;	ld de, display_row_4 
0a8f			;	ld hl, display_row_3 
0a8f			;	ld bc, display_cols 
0a8f			;	ldir 
0a8f			;	ld de, display_row_3 
0a8f			; 	ld hl, display_row_2 
0a8f			;	ld bc, display_cols 
0a8f			;	ldir 
0a8f			;	ld de, display_row_2 
0a8f			;	ld hl, display_row_1 
0a8f			;	ld bc, display_cols 
0a8f			;	ldir 
0a8f			;;; TODO clear row 1 
0a8f			;	ret 
0a8f			 
0a8f			 
0a8f			 
0a8f			 
0a8f			 
0a8f			; clear active frame buffer 
0a8f			 
0a8f			clear_display: 
0a8f 3e 20			ld a, ' ' 
0a91 c3 94 0a			jp fill_display 
0a94			 
0a94			; fill active frame buffer with a char in A 
0a94			 
0a94			fill_display: 
0a94 06 a0			ld b,display_fb_len 
0a96 2a d8 f8			ld hl, (display_fb_active) 
0a99 77			.fd1:	ld (hl),a 
0a9a 23				inc hl 
0a9b 10 fc			djnz .fd1 
0a9d 23				inc hl 
0a9e 3e 00			ld a,0 
0aa0 77				ld (hl),a 
0aa1			 
0aa1			 
0aa1 c9				ret 
0aa2			; Write string (DE) at pos (A) to active frame buffer 
0aa2			 
0aa2 2a d8 f8		str_at_display:    ld hl,(display_fb_active) 
0aa5 06 00					ld b,0 
0aa7 4f					ld c,a 
0aa8 09					add hl,bc 
0aa9 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0aaa b7			            OR   A              ;Null terminator? 
0aab c8			            RET  Z              ;Yes, so finished 
0aac 77					ld (hl),a 
0aad 23				inc hl 
0aae 13			            INC  DE             ;Point to next character 
0aaf 18 f8		            JR   .sad1     ;Repeat 
0ab1 c9					ret 
0ab2			 
0ab2			; using current frame buffer write to physical display 
0ab2			 
0ab2			update_display: 
0ab2 e5				push hl 
0ab3 2a d8 f8			ld hl, (display_fb_active) 
0ab6 cd f6 61			call write_display 
0ab9 e1				pop hl 
0aba c9				ret 
0abb			 
0abb			; TODO scrolling 
0abb			 
0abb			 
0abb			; move cursor right one char 
0abb			cursor_right: 
0abb			 
0abb				; TODO shift right 
0abb				; TODO if beyond max col 
0abb				; TODO       cursor_next_line 
0abb			 
0abb c9				ret 
0abc			 
0abc			 
0abc			cursor_next_line: 
0abc				; TODO first char 
0abc				; TODO line down 
0abc				; TODO if past last row 
0abc				; TODO    scroll up 
0abc			 
0abc c9				ret 
0abd			 
0abd			cursor_left: 
0abd				; TODO shift left 
0abd				; TODO if beyond left  
0abd				; TODO     cursor prev line 
0abd				 
0abd c9				ret 
0abe			 
0abe			cursor_prev_line: 
0abe				; TODO last char 
0abe				; TODO line up 
0abe				; TODO if past first row 
0abe				; TODO   scroll down 
0abe			 
0abe c9				ret 
0abf			 
0abf			 
0abf			cout: 
0abf				; A - char 
0abf c9				ret 
0ac0			 
0ac0			 
0ac0			; Display a menu and allow item selection (optional toggle items) 
0ac0			; 
0ac0			; format: 
0ac0			; hl pointer to word array with zero term for items 
0ac0			; e.g.    db item1 
0ac0			;         db .... 
0ac0			;         db 0 
0ac0			; 
0ac0			; a = starting menu item  
0ac0			; 
0ac0			; de = pointer item toggle array   (todo) 
0ac0			; 
0ac0			; returns item selected in a 1-... 
0ac0			; returns 0 if back button pressed 
0ac0			; 
0ac0			; NOTE: Uses system frame buffer to display 
0ac0			 
0ac0			 
0ac0			 
0ac0			 
0ac0			 
0ac0			 
0ac0			menu: 
0ac0			 
0ac0					; keep array pointer 
0ac0			 
0ac0 22 60 f8				ld (store_tmp1), hl 
0ac3 32 5e f8				ld (store_tmp2), a 
0ac6			 
0ac6					; check for key bounce 
0ac6			 
0ac6			if BASE_KEV 
0ac6			 
0ac6 cd 41 65		.mbounce:	call cin 
0ac9 fe 00				cp 0 
0acb 20 f9				jr nz, .mbounce 
0acd			endif 
0acd					; for ease use ex 
0acd			 
0acd					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0acd 21 bd fa				ld hl, display_fb0 
0ad0 22 d8 f8				ld (display_fb_active), hl 
0ad3			 
0ad3 cd 8f 0a		.mloop:		call clear_display 
0ad6 cd b2 0a				call update_display 
0ad9			 
0ad9					; draw selection id '>' at 1 
0ad9			 
0ad9					; init start of list display 
0ad9			 
0ad9 3e 05				ld a, 5 
0adb 32 5c f8				ld (store_tmp3), a   ; display row count 
0ade 3a 5e f8				ld a,( store_tmp2) 
0ae1 32 5f f8				ld (store_tmp2+1), a   ; display item count 
0ae4			 
0ae4					 
0ae4			.mitem:	 
0ae4			 
0ae4			 
0ae4 3a 5f f8				ld a,(store_tmp2+1) 
0ae7 6f					ld l, a 
0ae8 26 00				ld h, 0 
0aea 29					add hl, hl 
0aeb ed 5b 60 f8			ld de, (store_tmp1) 
0aef 19					add hl, de 
0af0 7e					ld a, (hl) 
0af1 23					inc hl 
0af2 66					ld h,(hl) 
0af3 6f					ld l, a 
0af4			 
0af4 cd e8 0c				call ishlzero 
0af7 28 1a				jr z, .mdone 
0af9			 
0af9 eb					ex de, hl 
0afa 3a 5c f8				ld a, (store_tmp3) 
0afd cd a2 0a				call str_at_display 
0b00					 
0b00			 
0b00					; next item 
0b00 3a 5f f8				ld a, (store_tmp2+1) 
0b03 3c					inc a 
0b04 32 5f f8				ld (store_tmp2+1), a   ; display item count 
0b07			 
0b07			 		; next row 
0b07			 
0b07 3a 5c f8				ld a, (store_tmp3) 
0b0a c6 28				add display_cols 
0b0c 32 5c f8				ld (store_tmp3), a 
0b0f			 
0b0f					; at end of screen? 
0b0f			 
0b0f fe 10				cp display_rows*4 
0b11 20 d1				jr nz, .mitem 
0b13			 
0b13			 
0b13			.mdone: 
0b13 cd e8 0c				call ishlzero 
0b16 28 08				jr z, .nodn 
0b18			 
0b18 3e 78				ld a, display_row_4 
0b1a 11 95 0b				ld de, .mdown 
0b1d cd a2 0a				call str_at_display 
0b20			 
0b20					; draw options to fill the screens with active item on line 1 
0b20					; if current option is 2 or more then display ^ in top 
0b20			 
0b20 3a 5e f8		.nodn:		ld a, (store_tmp2) 
0b23 fe 00				cp 0 
0b25 28 08				jr z, .noup 
0b27			 
0b27 3e 00				ld a, 0 
0b29 11 93 0b				ld de, .mup 
0b2c cd a2 0a				call str_at_display 
0b2f			 
0b2f 3e 02		.noup:		ld a, 2 
0b31 11 91 0b				ld de, .msel 
0b34 cd a2 0a				call str_at_display 
0b37			 
0b37					; if current option + 1 is not null then display V in bottom 
0b37					; get key 
0b37 cd b2 0a				call update_display 
0b3a			 
0b3a			 
0b3a					; handle key 
0b3a			 
0b3a cd 30 65				call cin_wait 
0b3d			 
0b3d fe 05				cp KEY_UP 
0b3f 28 27				jr z, .mgoup 
0b41 fe 61				cp 'a' 
0b43 28 23				jr z, .mgoup 
0b45 fe 0a				cp KEY_DOWN 
0b47 28 2e				jr z, .mgod 
0b49 fe 7a				cp 'z' 
0b4b 28 2a				jr z, .mgod 
0b4d fe 20				cp ' ' 
0b4f 28 30				jr z, .goend 
0b51 fe 0d				cp KEY_CR 
0b53 28 2c				jr z, .goend 
0b55 fe 71				cp 'q' 
0b57 28 0b				jr z, .goback 
0b59			 
0b59 fe 0b				cp KEY_LEFT 
0b5b 28 07				jr z, .goback 
0b5d fe 08				cp KEY_BS 
0b5f 28 03				jr z, .goback 
0b61 c3 d3 0a				jp .mloop 
0b64			 
0b64			.goback: 
0b64 3e 00			ld a, 0 
0b66 18 1d			jr .goend2 
0b68			 
0b68				; move up one 
0b68			.mgoup: 
0b68 3a 5e f8				ld a, (store_tmp2) 
0b6b fe 00				cp 0 
0b6d ca d3 0a				jp z, .mloop 
0b70 3d					dec a 
0b71 32 5e f8				ld (store_tmp2), a 
0b74 c3 d3 0a				jp .mloop 
0b77			 
0b77				; move down one 
0b77			.mgod: 
0b77 3a 5e f8				ld a, (store_tmp2) 
0b7a 3c					inc a 
0b7b 32 5e f8				ld (store_tmp2), a 
0b7e c3 d3 0a				jp .mloop 
0b81			 
0b81			 
0b81			.goend: 
0b81					; get selected item number 
0b81			 
0b81 3a 5e f8				ld a, (store_tmp2) 
0b84 3c					inc a 
0b85			 
0b85			.goend2: 
0b85 f5					push af 
0b86			 
0b86					; restore active fb 
0b86					; TODO BUG assumes fb1 
0b86			 
0b86 21 1c fa				ld hl, display_fb1 
0b89 22 d8 f8				ld (display_fb_active), hl 
0b8c			 
0b8c					; restore main regs 
0b8c			 
0b8c			 
0b8c cd b2 0a				call update_display 
0b8f			 
0b8f f1					pop af 
0b90			 
0b90 c9				ret 
0b91			 
0b91 .. 00		.msel:   db ">",0 
0b93 .. 00		.mup:   db "^",0 
0b95 .. 00		.mdown:   db "v",0 
0b97			 
0b97			 
0b97			; eof 
0b97			 
# End of file firmware_display.asm
0b97			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0b97			; random number generators 
0b97			 
0b97			 
0b97			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0b97			 
0b97			 
0b97			;-----> Generate a random number 
0b97			; output a=answer 0<=a<=255 
0b97			; all registers are preserved except: af 
0b97			random: 
0b97 e5			        push    hl 
0b98 d5			        push    de 
0b99 2a ba f8		        ld      hl,(randData) 
0b9c ed 5f		        ld      a,r 
0b9e 57			        ld      d,a 
0b9f 5e			        ld      e,(hl) 
0ba0 19			        add     hl,de 
0ba1 85			        add     a,l 
0ba2 ac			        xor     h 
0ba3 22 ba f8		        ld      (randData),hl 
0ba6 d1			        pop     de 
0ba7 e1			        pop     hl 
0ba8 c9			        ret 
0ba9			 
0ba9			 
0ba9			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0ba9			 
0ba9			 
0ba9			 
0ba9			;------LFSR------ 
0ba9			;James Montelongo 
0ba9			;optimized by Spencer Putt 
0ba9			;out: 
0ba9			; a = 8 bit random number 
0ba9			RandLFSR: 
0ba9 21 c0 f8		        ld hl,LFSRSeed+4 
0bac 5e			        ld e,(hl) 
0bad 23			        inc hl 
0bae 56			        ld d,(hl) 
0baf 23			        inc hl 
0bb0 4e			        ld c,(hl) 
0bb1 23			        inc hl 
0bb2 7e			        ld a,(hl) 
0bb3 47			        ld b,a 
0bb4 cb 13		        rl e  
0bb6 cb 12			rl d 
0bb8 cb 11		        rl c  
0bba 17				rla 
0bbb cb 13		        rl e  
0bbd cb 12			rl d 
0bbf cb 11		        rl c  
0bc1 17				rla 
0bc2 cb 13		        rl e  
0bc4 cb 12			rl d 
0bc6 cb 11		        rl c  
0bc8 17				rla 
0bc9 67			        ld h,a 
0bca cb 13		        rl e  
0bcc cb 12			rl d 
0bce cb 11		        rl c  
0bd0 17				rla 
0bd1 a8			        xor b 
0bd2 cb 13		        rl e  
0bd4 cb 12			rl d 
0bd6 ac			        xor h 
0bd7 a9			        xor c 
0bd8 aa			        xor d 
0bd9 21 c2 f8		        ld hl,LFSRSeed+6 
0bdc 11 c3 f8		        ld de,LFSRSeed+7 
0bdf 01 07 00		        ld bc,7 
0be2 ed b8		        lddr 
0be4 12			        ld (de),a 
0be5 c9			        ret 
0be6			 
0be6			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0be6			 
0be6			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0be6			 
0be6			 
0be6			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0be6			 
0be6			prng16: 
0be6			;Inputs: 
0be6			;   (seed1) contains a 16-bit seed value 
0be6			;   (seed2) contains a NON-ZERO 16-bit seed value 
0be6			;Outputs: 
0be6			;   HL is the result 
0be6			;   BC is the result of the LCG, so not that great of quality 
0be6			;   DE is preserved 
0be6			;Destroys: 
0be6			;   AF 
0be6			;cycle: 4,294,901,760 (almost 4.3 billion) 
0be6			;160cc 
0be6			;26 bytes 
0be6 2a b4 f8		    ld hl,(seed1) 
0be9 44			    ld b,h 
0bea 4d			    ld c,l 
0beb 29			    add hl,hl 
0bec 29			    add hl,hl 
0bed 2c			    inc l 
0bee 09			    add hl,bc 
0bef 22 b4 f8		    ld (seed1),hl 
0bf2 2a b2 f8		    ld hl,(seed2) 
0bf5 29			    add hl,hl 
0bf6 9f			    sbc a,a 
0bf7 e6 2d		    and %00101101 
0bf9 ad			    xor l 
0bfa 6f			    ld l,a 
0bfb 22 b2 f8		    ld (seed2),hl 
0bfe 09			    add hl,bc 
0bff c9			    ret 
0c00			 
0c00			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c00			 
0c00			rand32: 
0c00			;Inputs: 
0c00			;   (seed1_0) holds the lower 16 bits of the first seed 
0c00			;   (seed1_1) holds the upper 16 bits of the first seed 
0c00			;   (seed2_0) holds the lower 16 bits of the second seed 
0c00			;   (seed2_1) holds the upper 16 bits of the second seed 
0c00			;   **NOTE: seed2 must be non-zero 
0c00			;Outputs: 
0c00			;   HL is the result 
0c00			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c00			;Destroys: 
0c00			;   AF 
0c00			;Tested and passes all CAcert tests 
0c00			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c00			;it has a period of 18,446,744,069,414,584,320 
0c00			;roughly 18.4 quintillion. 
0c00			;LFSR taps: 0,2,6,7  = 11000101 
0c00			;291cc 
0c00			;seed1_0=$+1 
0c00			;    ld hl,12345 
0c00			;seed1_1=$+1 
0c00			;    ld de,6789 
0c00			;    ld b,h 
0c00			;    ld c,l 
0c00			;    add hl,hl \ rl e \ rl d 
0c00			;    add hl,hl \ rl e \ rl d 
0c00			;    inc l 
0c00			;    add hl,bc 
0c00			;    ld (seed1_0),hl 
0c00			;    ld hl,(seed1_1) 
0c00			;    adc hl,de 
0c00			;    ld (seed1_1),hl 
0c00			;    ex de,hl 
0c00			;seed2_0=$+1 
0c00			;    ld hl,9876 
0c00			;seed2_1=$+1 
0c00			;    ld bc,54321 
0c00			;    add hl,hl \ rl c \ rl b 
0c00			;    ld (seed2_1),bc 
0c00			;    sbc a,a 
0c00			;    and %11000101 
0c00			;    xor l 
0c00			;    ld l,a 
0c00			;    ld (seed2_0),hl 
0c00			;    ex de,hl 
0c00			;    add hl,bc 
0c00			;    ret 
0c00			; 
0c00			 
0c00			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c00			; 20 bytes, 86 cycles (excluding ret) 
0c00			 
0c00			; returns   hl = pseudorandom number 
0c00			; corrupts   a 
0c00			 
0c00			; generates 16-bit pseudorandom numbers with a period of 65535 
0c00			; using the xorshift method: 
0c00			 
0c00			; hl ^= hl << 7 
0c00			; hl ^= hl >> 9 
0c00			; hl ^= hl << 8 
0c00			 
0c00			; some alternative shift triplets which also perform well are: 
0c00			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c00			 
0c00			;  org 32768 
0c00			 
0c00			xrnd: 
0c00 2a b8 f8		  ld hl,(xrandc)       ; seed must not be 0 
0c03 3e 00		  ld a,0 
0c05 bd			  cp l 
0c06 20 02		  jr nz, .xrnd1 
0c08 2e 01		  ld l, 1 
0c0a			.xrnd1: 
0c0a			 
0c0a 7c			  ld a,h 
0c0b 1f			  rra 
0c0c 7d			  ld a,l 
0c0d 1f			  rra 
0c0e ac			  xor h 
0c0f 67			  ld h,a 
0c10 7d			  ld a,l 
0c11 1f			  rra 
0c12 7c			  ld a,h 
0c13 1f			  rra 
0c14 ad			  xor l 
0c15 6f			  ld l,a 
0c16 ac			  xor h 
0c17 67			  ld h,a 
0c18			 
0c18 22 b8 f8		  ld (xrandc),hl 
0c1b			 
0c1b c9			  ret 
0c1c			;  
0c1c			 
0c1c			 
0c1c			;;;; int maths 
0c1c			 
0c1c			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c1c			; Divide 16-bit values (with 16-bit result) 
0c1c			; In: Divide BC by divider DE 
0c1c			; Out: BC = result, HL = rest 
0c1c			; 
0c1c			Div16: 
0c1c 21 00 00		    ld hl,0 
0c1f 78			    ld a,b 
0c20 06 08		    ld b,8 
0c22			Div16_Loop1: 
0c22 17			    rla 
0c23 ed 6a		    adc hl,hl 
0c25 ed 52		    sbc hl,de 
0c27 30 01		    jr nc,Div16_NoAdd1 
0c29 19			    add hl,de 
0c2a			Div16_NoAdd1: 
0c2a 10 f6		    djnz Div16_Loop1 
0c2c 17			    rla 
0c2d 2f			    cpl 
0c2e 47			    ld b,a 
0c2f 79			    ld a,c 
0c30 48			    ld c,b 
0c31 06 08		    ld b,8 
0c33			Div16_Loop2: 
0c33 17			    rla 
0c34 ed 6a		    adc hl,hl 
0c36 ed 52		    sbc hl,de 
0c38 30 01		    jr nc,Div16_NoAdd2 
0c3a 19			    add hl,de 
0c3b			Div16_NoAdd2: 
0c3b 10 f6		    djnz Div16_Loop2 
0c3d 17			    rla 
0c3e 2f			    cpl 
0c3f 41			    ld b,c 
0c40 4f			    ld c,a 
0c41 c9			ret 
0c42			 
0c42			 
0c42			;http://z80-heaven.wikidot.com/math 
0c42			; 
0c42			;Inputs: 
0c42			;     DE and A are factors 
0c42			;Outputs: 
0c42			;     A is not changed 
0c42			;     B is 0 
0c42			;     C is not changed 
0c42			;     DE is not changed 
0c42			;     HL is the product 
0c42			;Time: 
0c42			;     342+6x 
0c42			; 
0c42			Mult16: 
0c42			 
0c42 06 08		     ld b,8          ;7           7 
0c44 21 00 00		     ld hl,0         ;10         10 
0c47 29			       add hl,hl     ;11*8       88 
0c48 07			       rlca          ;4*8        32 
0c49 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0c4b 19			         add hl,de   ;--         -- 
0c4c 10 f9		       djnz $-5      ;13*7+8     99 
0c4e c9			ret 
0c4f			 
0c4f			; 
0c4f			; Square root of 16-bit value 
0c4f			; In:  HL = value 
0c4f			; Out:  D = result (rounded down) 
0c4f			; 
0c4f			;Sqr16: 
0c4f			;    ld de,#0040 
0c4f			;    ld a,l 
0c4f			;    ld l,h 
0c4f			;    ld h,d 
0c4f			;    or a 
0c4f			;    ld b,8 
0c4f			;Sqr16_Loop: 
0c4f			;    sbc hl,de 
0c4f			;    jr nc,Sqr16_Skip 
0c4f			;    add hl,de 
0c4f			;Sqr16_Skip: 
0c4f			;    ccf 
0c4f			;    rl d 
0c4f			;    add a,a 
0c4f			;    adc hl,hl 
0c4f			;    add a,a 
0c4f			;    adc hl,hl 
0c4f			;    djnz Sqr16_Loop 
0c4f			;    ret 
0c4f			; 
0c4f			; 
0c4f			; Divide 8-bit values 
0c4f			; In: Divide E by divider C 
0c4f			; Out: A = result, B = rest 
0c4f			; 
0c4f			Div8: 
0c4f af			    xor a 
0c50 06 08		    ld b,8 
0c52			Div8_Loop: 
0c52 cb 13		    rl e 
0c54 17			    rla 
0c55 91			    sub c 
0c56 30 01		    jr nc,Div8_NoAdd 
0c58 81			    add a,c 
0c59			Div8_NoAdd: 
0c59 10 f7		    djnz Div8_Loop 
0c5b 47			    ld b,a 
0c5c 7b			    ld a,e 
0c5d 17			    rla 
0c5e 2f			    cpl 
0c5f c9			    ret 
0c60			 
0c60			; 
0c60			; Multiply 8-bit value with a 16-bit value (unrolled) 
0c60			; In: Multiply A with DE 
0c60			; Out: HL = result 
0c60			; 
0c60			Mult12U: 
0c60 2e 00		    ld l,0 
0c62 87			    add a,a 
0c63 30 01		    jr nc,Mult12U_NoAdd0 
0c65 19			    add hl,de 
0c66			Mult12U_NoAdd0: 
0c66 29			    add hl,hl 
0c67 87			    add a,a 
0c68 30 01		    jr nc,Mult12U_NoAdd1 
0c6a 19			    add hl,de 
0c6b			Mult12U_NoAdd1: 
0c6b 29			    add hl,hl 
0c6c 87			    add a,a 
0c6d 30 01		    jr nc,Mult12U_NoAdd2 
0c6f 19			    add hl,de 
0c70			Mult12U_NoAdd2: 
0c70 29			    add hl,hl 
0c71 87			    add a,a 
0c72 30 01		    jr nc,Mult12U_NoAdd3 
0c74 19			    add hl,de 
0c75			Mult12U_NoAdd3: 
0c75 29			    add hl,hl 
0c76 87			    add a,a 
0c77 30 01		    jr nc,Mult12U_NoAdd4 
0c79 19			    add hl,de 
0c7a			Mult12U_NoAdd4: 
0c7a 29			    add hl,hl 
0c7b 87			    add a,a 
0c7c 30 01		    jr nc,Mult12U_NoAdd5 
0c7e 19			    add hl,de 
0c7f			Mult12U_NoAdd5: 
0c7f 29			    add hl,hl 
0c80 87			    add a,a 
0c81 30 01		    jr nc,Mult12U_NoAdd6 
0c83 19			    add hl,de 
0c84			Mult12U_NoAdd6: 
0c84 29			    add hl,hl 
0c85 87			    add a,a 
0c86 d0			    ret nc 
0c87 19			    add hl,de 
0c88 c9			    ret 
0c89			 
0c89			; 
0c89			; Multiply 8-bit value with a 16-bit value (right rotating) 
0c89			; In: Multiply A with DE 
0c89			;      Put lowest value in A for most efficient calculation 
0c89			; Out: HL = result 
0c89			; 
0c89			Mult12R: 
0c89 21 00 00		    ld hl,0 
0c8c			Mult12R_Loop: 
0c8c cb 3f		    srl a 
0c8e 30 01		    jr nc,Mult12R_NoAdd 
0c90 19			    add hl,de 
0c91			Mult12R_NoAdd: 
0c91 cb 23		    sla e 
0c93 cb 12		    rl d 
0c95 b7			    or a 
0c96 c2 8c 0c		    jp nz,Mult12R_Loop 
0c99 c9			    ret 
0c9a			 
0c9a			; 
0c9a			; Multiply 16-bit values (with 32-bit result) 
0c9a			; In: Multiply BC with DE 
0c9a			; Out: BCHL = result 
0c9a			; 
0c9a			Mult32: 
0c9a 79			    ld a,c 
0c9b 48			    ld c,b 
0c9c 21 00 00		    ld hl,0 
0c9f 06 10		    ld b,16 
0ca1			Mult32_Loop: 
0ca1 29			    add hl,hl 
0ca2 17			    rla 
0ca3 cb 11		    rl c 
0ca5 30 07		    jr nc,Mult32_NoAdd 
0ca7 19			    add hl,de 
0ca8 ce 00		    adc a,0 
0caa d2 ae 0c		    jp nc,Mult32_NoAdd 
0cad 0c			    inc c 
0cae			Mult32_NoAdd: 
0cae 10 f1		    djnz Mult32_Loop 
0cb0 41			    ld b,c 
0cb1 4f			    ld c,a 
0cb2 c9			    ret 
0cb3			 
0cb3			 
0cb3			 
0cb3			; 
0cb3			; Multiply 8-bit values 
0cb3			; In:  Multiply H with E 
0cb3			; Out: HL = result 
0cb3			; 
0cb3			Mult8: 
0cb3 16 00		    ld d,0 
0cb5 6a			    ld l,d 
0cb6 06 08		    ld b,8 
0cb8			Mult8_Loop: 
0cb8 29			    add hl,hl 
0cb9 30 01		    jr nc,Mult8_NoAdd 
0cbb 19			    add hl,de 
0cbc			Mult8_NoAdd: 
0cbc 10 fa		    djnz Mult8_Loop 
0cbe c9			    ret 
0cbf			 
0cbf			 
0cbf			 
0cbf			 
0cbf			 
0cbf			 
0cbf			 
0cbf			 
0cbf			;;http://z80-heaven.wikidot.com/math 
0cbf			;;This divides DE by BC, storing the result in DE, remainder in HL 
0cbf			; 
0cbf			;DE_Div_BC:          ;1281-2x, x is at most 16 
0cbf			;     ld a,16        ;7 
0cbf			;     ld hl,0        ;10 
0cbf			;     jp $+5         ;10 
0cbf			;.DivLoop: 
0cbf			;       add hl,bc    ;-- 
0cbf			;       dec a        ;64 
0cbf			;       jr z,.DivLoopEnd        ;86 
0cbf			; 
0cbf			;       sla e        ;128 
0cbf			;       rl d         ;128 
0cbf			;       adc hl,hl    ;240 
0cbf			;       sbc hl,bc    ;240 
0cbf			;       jr nc,.DivLoop ;23|21 
0cbf			;       inc e        ;-- 
0cbf			;       jp .DivLoop+1 
0cbf			; 
0cbf			;.DivLoopEnd: 
0cbf			 
0cbf			;HL_Div_C: 
0cbf			;Inputs: 
0cbf			;     HL is the numerator 
0cbf			;     C is the denominator 
0cbf			;Outputs: 
0cbf			;     A is the remainder 
0cbf			;     B is 0 
0cbf			;     C is not changed 
0cbf			;     DE is not changed 
0cbf			;     HL is the quotient 
0cbf			; 
0cbf			;       ld b,16 
0cbf			;       xor a 
0cbf			;         add hl,hl 
0cbf			;         rla 
0cbf			;         cp c 
0cbf			;         jr c,$+4 
0cbf			;           inc l 
0cbf			;           sub c 
0cbf			;         djnz $-7 
0cbf			 
0cbf			; https://plutiedev.com/z80-add-8bit-to-16bit 
0cbf			 
0cbf			addatohl: 
0cbf 85			    add   a, l    ; A = A+L 
0cc0 6f			    ld    l, a    ; L = A+L 
0cc1 8c			    adc   a, h    ; A = A+L+H+carry 
0cc2 95			    sub   l       ; A = H+carry 
0cc3 67			    ld    h, a    ; H = H+carry 
0cc4 c9			ret 
0cc5			 
0cc5			addatode: 
0cc5 83			    add   a, e    ; A = A+L 
0cc6 5f			    ld    e, a    ; L = A+L 
0cc7 8a			    adc   a, d    ; A = A+L+H+carry 
0cc8 93			    sub   e       ; A = H+carry 
0cc9 57			    ld    d, a    ; H = H+carry 
0cca c9			ret 
0ccb			 
0ccb			 
0ccb			addatobc: 
0ccb 81			    add   a, c    ; A = A+L 
0ccc 4f			    ld    c, a    ; L = A+L 
0ccd 88			    adc   a, b    ; A = A+L+H+carry 
0cce 91			    sub   c       ; A = H+carry 
0ccf 47			    ld    b, a    ; H = H+carry 
0cd0 c9			ret 
0cd1			 
0cd1			subafromhl: 
0cd1			   ; If A=0 do nothing 
0cd1			    ; Otherwise flip A's sign. Since 
0cd1			    ; the upper byte becomes -1, also 
0cd1			    ; substract 1 from H. 
0cd1 ed 44		    neg 
0cd3 ca dc 0c		    jp    z, Skip 
0cd6 25			    dec   h 
0cd7			     
0cd7			    ; Now add the low byte as usual 
0cd7			    ; Two's complement takes care of 
0cd7			    ; ensuring the result is correct 
0cd7 85			    add   a, l 
0cd8 6f			    ld    l, a 
0cd9 8c			    adc   a, h 
0cda 95			    sub   l 
0cdb 67			    ld    h, a 
0cdc			Skip: 
0cdc c9				ret 
0cdd			 
0cdd			 
0cdd			; compare hl and de 
0cdd			; returns:  
0cdd			; if hl = de, z=1, s=0, c0=0 
0cdd			; if hl > de, z=0, s=0, c=0 
0cdd			; if hl < de, z=0, s=1, c=1 
0cdd			cmp16:	 
0cdd b7				or a 
0cde ed 52			sbc hl,de 
0ce0 e0				ret po 
0ce1 7c				ld a,h 
0ce2 1f				rra 
0ce3 ee 40			xor 01000000B 
0ce5 37				scf 
0ce6 8f				adc a,a 
0ce7 c9				ret 
0ce8			 
0ce8			 
0ce8			; test if hl contains zero   - A is destroyed 
0ce8			 
0ce8			ishlzero:    
0ce8 b7				or a     ; reset flags 
0ce9 7c				ld a, h 
0cea b5				or l        	 
0ceb			 
0ceb c9				ret 
0cec			 
0cec			 
0cec			 
0cec			 
0cec			if FORTH_ENABLE_FLOATMATH 
0cec			;include "float/bbcmath.z80" 
0cec			include "float/lpfpcalc.asm" 
0cec			endif 
0cec			 
0cec			 
0cec			; eof 
0cec			 
# End of file firmware_maths.asm
0cec			include "firmware_strings.asm"   ; string handling  
0cec			 
0cec			 
0cec			; TODO string len 
0cec			; input text string, end on cr with zero term 
0cec			; a offset into frame buffer to start prompt 
0cec			; d is max length 
0cec			; e is display size TODO 
0cec			; c is current cursor position 
0cec			; hl is ptr to where string will be stored 
0cec			 
0cec			 
0cec			; TODO check limit of buffer for new inserts 
0cec			; TODO check insert does not push beyond buffer 
0cec			; TODO scroll in a limited display area 
0cec			; TODO scroll whole screen on page wrap 
0cec			 
0cec			 
0cec			; TODO handle KEY_PREVWORD 
0cec			; TODO handle KEY_NEXTWORD 
0cec			; TODO handle KEY_HOME 
0cec			; TODO handle KEY_END 
0cec			; TODO use LCD cursor? 
0cec			 
0cec 32 70 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0cef 81					add c 
0cf0 32 6e fb				ld (input_at_cursor),a	; save draw pos of cursor 
0cf3 22 73 fb				ld (input_start), hl     ; save ptr to buffer 
0cf6 79					ld a, c 
0cf7 cd bf 0c				call addatohl 
0cfa 22 75 fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0cfd 7a					ld a,d 
0cfe 32 72 fb			        ld (input_size), a       ; save length of input area 
0d01 79					ld a, c 
0d02 32 61 fb				ld (input_cursor),a      ; init cursor start position  
0d05 7b					ld a,e 
0d06 32 71 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d09					 
0d09					 
0d09			 
0d09			;		ld a,(input_ptr) 
0d09			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d09			 
0d09			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d09					; init cursor shape if not set by the cin routines 
0d09 21 d0 f8				ld hl, cursor_shape 
0d0c 3e ff				ld a, 255 
0d0e 77					ld (hl), a 
0d0f 23					inc hl 
0d10 3e 00				ld a, 0 
0d12 77					ld (hl), a 
0d13			 
0d13 3e 0f				ld a, CUR_BLINK_RATE 
0d15 32 6c fb				ld (input_cur_flash), a 
0d18 3e 01				ld a, 1 
0d1a 32 6b fb				ld (input_cur_onoff),a 
0d1d			 
0d1d			;	if DEBUG_INPUT 
0d1d			;		push af 
0d1d			;		ld a, 'I' 
0d1d			;		ld (debug_mark),a 
0d1d			;		pop af 
0d1d			;		CALLMONITOR 
0d1d			;	endif 
0d1d			.is1:		; main entry loop 
0d1d			 
0d1d			 
0d1d			 
0d1d					; pause 1ms 
0d1d			 
0d1d 3e 01				ld a, 1 
0d1f cd 22 0a				call aDelayInMS 
0d22			 
0d22					; dec flash counter 
0d22 3a 6c fb				ld a, (input_cur_flash) 
0d25 3d					dec a 
0d26 32 6c fb				ld (input_cur_flash), a 
0d29 fe 00				cp 0 
0d2b 20 0d				jr nz, .nochgstate 
0d2d			 
0d2d			 
0d2d					; change state 
0d2d 3a 6b fb				ld a,(input_cur_onoff) 
0d30 ed 44				neg 
0d32 32 6b fb				ld (input_cur_onoff),a 
0d35			 
0d35			 
0d35					; reset on change of state 
0d35 3e 0f				ld a, CUR_BLINK_RATE 
0d37 32 6c fb				ld (input_cur_flash), a 
0d3a			 
0d3a			.nochgstate: 
0d3a					 
0d3a					 
0d3a			 
0d3a					; display cursor  
0d3a			 
0d3a			;		ld hl, (input_start) 
0d3a			;		ld a, (input_cursor) 
0d3a			;		call addatohl 
0d3a			 
0d3a					; get char under cursor and replace with cursor 
0d3a 2a 75 fb		ld hl, (input_ptr) 
0d3d			;		ld a, (hl) 
0d3d			;		ld (input_under_cursor),a 
0d3d			;		ld a, '_' 
0d3d			;		ld (hl), a 
0d3d			 
0d3d					; display string 
0d3d			 
0d3d ed 5b 73 fb			ld de, (input_start) 
0d41 3a 70 fb				ld a, (input_at_pos) 
0d44 cd a2 0a				call str_at_display 
0d47			;	        call update_display 
0d47			 
0d47					; find place to put the cursor 
0d47			;		add h 
0d47			;		ld l, display_row_1 
0d47			;		sub l 
0d47			; (input_at_pos) 
0d47					;ld c, a 
0d47			;		ld a, (input_cursor) 
0d47			;		ld l, (input_at_pos) 
0d47			;		;ld b, h 
0d47			;		add l 
0d47			;		ld (input_at_cursor),a 
0d47					;ld l,h 
0d47			 
0d47			;		ld h, 0 
0d47			;		ld l,(input_at_pos) 
0d47			;		ld a, (input_cursor) 
0d47			;		call addatohl 
0d47			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0d47			;		call subafromhl 
0d47			;		ld a,l 
0d47			;		ld (input_at_cursor), a 
0d47			 
0d47				if DEBUG_INPUT 
0d47					ld a, (hardware_diag) 
0d47					cp 0 
0d47					jr z, .skip_input_diag 
0d47			 
0d47					ld a,(input_at_pos) 
0d47					ld hl, LFSRSeed 
0d47					call hexout 
0d47					ld a, (input_cursor) 
0d47					ld hl, LFSRSeed+2 
0d47					call hexout 
0d47					ld a,(input_at_cursor) 
0d47					ld hl, LFSRSeed+4 
0d47					call hexout 
0d47			 
0d47					ld a,(input_cur_onoff) 
0d47					ld hl, LFSRSeed+6 
0d47					call hexout 
0d47			 
0d47					ld a,(input_cur_flash) 
0d47					ld hl, LFSRSeed+8 
0d47					call hexout 
0d47			 
0d47					ld a,(input_len) 
0d47					ld hl, LFSRSeed+10 
0d47					call hexout 
0d47					ld hl, LFSRSeed+12 
0d47					ld a, 0 
0d47					ld (hl),a 
0d47					ld a, display_row_4 
0d47					ld de, LFSRSeed 
0d47					call str_at_display 
0d47					.skip_input_diag: 
0d47				endif 
0d47			 
0d47					; decide on if we are showing the cursor this time round 
0d47			 
0d47 3a 6b fb				ld a, (input_cur_onoff) 
0d4a fe ff				cp 255 
0d4c 28 13				jr z, .skipcur 
0d4e			 
0d4e			 
0d4e 3a 6e fb				ld a,(input_at_cursor) 
0d51 11 d0 f8				ld de, cursor_shape 
0d54 cd a2 0a				call str_at_display 
0d57			 
0d57					; save length of current input string 
0d57 2a 73 fb				ld hl, (input_start) 
0d5a cd 1d 11				call strlenz 
0d5d 7d					ld a,l 
0d5e 32 66 fb				ld (input_len),a 
0d61			 
0d61			.skipcur: 
0d61			 
0d61 cd b2 0a			        call update_display 
0d64					 
0d64			 
0d64			 
0d64					; wait 
0d64				 
0d64					; TODO loop without wait to flash the cursor and char under cursor	 
0d64 cd 41 65				call cin    ; _wait 
0d67			 
0d67 fe 00				cp 0 
0d69 ca 1d 0d				jp z, .is1 
0d6c			 
0d6c					; get ptr to char to input into 
0d6c			 
0d6c 4f					ld c,a 
0d6d 2a 73 fb				ld hl, (input_start) 
0d70 3a 61 fb				ld a, (input_cursor) 
0d73 cd bf 0c				call addatohl 
0d76 22 75 fb				ld (input_ptr), hl 
0d79 79					ld a,c 
0d7a			 
0d7a					; replace char under cursor 
0d7a			 
0d7a			;		ld hl, (input_ptr) 
0d7a			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0d7a			;		ld (hl), a 
0d7a			 
0d7a			;	if DEBUG_INPUT 
0d7a			;		push af 
0d7a			;		ld a, 'i' 
0d7a			;		ld (debug_mark),a 
0d7a			;		pop af 
0d7a			;		CALLMONITOR 
0d7a			;	endif 
0d7a fe 0e				cp KEY_HOME 
0d7c 20 0e				jr nz, .iske 
0d7e			 
0d7e 3a 70 fb				ld a, (input_at_pos) 
0d81 32 6e fb				ld (input_at_cursor),a 
0d84 3e 00				ld a, 0 
0d86 32 61 fb				ld (input_cursor), a 
0d89 c3 1d 0d				jp .is1 
0d8c					 
0d8c fe 0f		.iske:		cp KEY_END 
0d8e 20 03				jr nz, .isknw 
0d90 c3 1d 0d				jp .is1 
0d93			 
0d93 fe 06		.isknw:		cp KEY_NEXTWORD 
0d95 20 1b				jr nz, .iskpw 
0d97			 
0d97 2a 75 fb		.isknwm:	ld hl, (input_ptr) 
0d9a 7e					ld a,(hl)	 
0d9b fe 00				cp 0 
0d9d ca 1d 0d				jp z, .is1    ; end of string 
0da0 fe 20				cp ' ' 
0da2 ca 1d 0d				jp z, .is1    ; end of word 
0da5 23					inc hl 
0da6 22 75 fb				ld (input_ptr), hl 
0da9 3a 6e fb				ld a, (input_at_cursor) 
0dac 3c					inc a 
0dad 32 6e fb				ld (input_at_cursor), a 
0db0 18 e5				jr .isknwm 
0db2			 
0db2 fe 07		.iskpw:		cp KEY_PREVWORD 
0db4 20 1b				jr nz, .iskl 
0db6			.iskpwm:	 
0db6 2a 75 fb				ld hl, (input_ptr) 
0db9 7e					ld a,(hl)	 
0dba fe 00				cp 0  
0dbc ca 1d 0d				jp z, .is1    ; end of string 
0dbf fe 20				cp ' ' 
0dc1 ca 1d 0d				jp z, .is1    ; end of word 
0dc4 2b					dec hl 
0dc5 22 75 fb				ld (input_ptr), hl 
0dc8 3a 6e fb				ld a, (input_at_cursor) 
0dcb 3d					dec a 
0dcc 32 6e fb				ld (input_at_cursor), a 
0dcf 18 e5				jr .iskpwm 
0dd1			 
0dd1			 
0dd1 fe 0b		.iskl:		cp KEY_LEFT 
0dd3 20 27				jr nz, .isk1 
0dd5			 
0dd5 3a 61 fb				ld a, (input_cursor) 
0dd8			 
0dd8 fe 00				cp 0 
0dda ca 1d 0d				jp z, .is1 		; at start of line to ignore  
0ddd			 
0ddd 3d					dec  a 		; TODO check underflow 
0dde 32 61 fb				ld (input_cursor), a 
0de1			 
0de1 2a 75 fb				ld hl, (input_ptr) 
0de4 2b					dec hl 
0de5 22 75 fb				ld (input_ptr), hl 
0de8					 
0de8 3a 6e fb				ld a, (input_at_cursor) 
0deb 3d					dec a 
0dec 32 6e fb				ld (input_at_cursor), a 
0def			 
0def 3e 01				ld a, 1		; show cursor moving 
0df1 32 6b fb				ld (input_cur_onoff),a 
0df4 3e 0f				ld a, CUR_BLINK_RATE 
0df6 32 6c fb				ld (input_cur_flash), a 
0df9			 
0df9 c3 1d 0d				jp .is1 
0dfc			 
0dfc fe 0c		.isk1:		cp KEY_RIGHT 
0dfe 20 2a				jr nz, .isk2 
0e00			 
0e00 3a 66 fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e03 5f					ld e,a 
0e04 3a 61 fb				ld a, (input_cursor) 
0e07 bb					cp e 
0e08 ca 1d 0d				jp z, .is1		; at the end of string so dont go right 
0e0b			 
0e0b 3c					inc  a 		; TODO check overflow 
0e0c 32 61 fb				ld (input_cursor), a 
0e0f			 
0e0f 3a 6e fb				ld a, (input_at_cursor) 
0e12 3c					inc a 
0e13 32 6e fb				ld (input_at_cursor), a 
0e16			 
0e16 2a 75 fb				ld hl, (input_ptr) 
0e19 23					inc hl 
0e1a 22 75 fb				ld (input_ptr), hl 
0e1d			 
0e1d 3e 01				ld a, 1		; show cursor moving 
0e1f 32 6b fb				ld (input_cur_onoff),a 
0e22 3e 0f				ld a, CUR_BLINK_RATE 
0e24 32 6c fb				ld (input_cur_flash), a 
0e27			 
0e27 c3 1d 0d				jp .is1 
0e2a			 
0e2a fe 05		.isk2:		cp KEY_UP 
0e2c			 
0e2c 20 26				jr nz, .isk3 
0e2e			 
0e2e					; swap last command with the current on 
0e2e			 
0e2e					; move cursor to start of string 
0e2e 2a 73 fb				ld hl, (input_start) 
0e31 22 75 fb				ld (input_ptr), hl 
0e34			 
0e34 3a 70 fb				ld a, (input_at_pos) 
0e37 32 6e fb				ld (input_at_cursor), a 
0e3a			 
0e3a 3e 00				ld a, 0 
0e3c 32 61 fb				ld (input_cursor), a 
0e3f					 
0e3f					; swap input and last command buffers 
0e3f			 
0e3f 21 59 f1				ld hl, os_cli_cmd 
0e42 11 58 f2				ld de, os_last_cmd 
0e45 06 ff				ld b, 255 
0e47 7e			.swap1:		ld a, (hl) 
0e48 4f					ld c,a 
0e49 1a					ld a, (de) 
0e4a 77					ld (hl), a 
0e4b 79					ld a,c 
0e4c 12					ld (de),a 
0e4d 23					inc hl 
0e4e 13					inc de 
0e4f 10 f6				djnz .swap1 
0e51			 
0e51			 
0e51			 
0e51			 
0e51			 
0e51 c3 1d 0d				jp .is1 
0e54			 
0e54 fe 08		.isk3:		cp KEY_BS 
0e56 20 3c				jr nz, .isk4 
0e58			 
0e58 3a 61 fb				ld a, (input_cursor) 
0e5b			 
0e5b fe 00				cp 0 
0e5d ca 1d 0d				jp z, .is1 		; at start of line to ignore  
0e60			 
0e60 3d					dec  a 		; TODO check underflow 
0e61 32 61 fb				ld (input_cursor), a 
0e64			 
0e64					; hl is source 
0e64					; de needs to be source - 1 
0e64			 
0e64			;		ld a, 0 
0e64			;		dec hl 
0e64			;		ld (hl), a 
0e64			 
0e64 2a 75 fb				ld hl, (input_ptr) 
0e67 2b					dec hl 
0e68 22 75 fb				ld (input_ptr), hl 
0e6b			 
0e6b					; shift all data 
0e6b			 
0e6b e5					push hl 
0e6c 23					inc hl 
0e6d d1					pop de 
0e6e 3a 66 fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0e71 4f					ld c,a 
0e72 06 00				ld b,0 
0e74 ed b0				ldir  
0e76			 
0e76			 
0e76			 
0e76			 
0e76 3a 6e fb				ld a, (input_at_cursor) 
0e79 3d					dec a 
0e7a 32 6e fb				ld (input_at_cursor), a 
0e7d			 
0e7d			 
0e7d 3e 01				ld a, 1		; show cursor moving 
0e7f 32 6b fb				ld (input_cur_onoff),a 
0e82 3e 0f				ld a, CUR_BLINK_RATE 
0e84 32 6c fb				ld (input_cur_flash), a 
0e87			 
0e87					; remove char 
0e87 3a 6e fb				ld a, (input_at_cursor) 
0e8a 3c					inc a 
0e8b 11 15 0f				ld de,.iblank 
0e8e cd a2 0a				call str_at_display 
0e91			 
0e91 c3 1d 0d				jp .is1 
0e94			 
0e94 fe 0d		.isk4:		cp KEY_CR 
0e96 28 6c				jr z, .endinput 
0e98			 
0e98					; else add the key press to the end 
0e98			 
0e98 4f					ld c, a			; save key pressed 
0e99			 
0e99 7e					ld a,(hl)		; get what is currently under char 
0e9a			 
0e9a fe 00				cp 0			; we are at the end of the string 
0e9c 20 2f				jr nz, .onchar 
0e9e					 
0e9e					; add a char to the end of the string 
0e9e				 
0e9e 71					ld (hl),c 
0e9f 23					inc hl 
0ea0			;		ld a,' ' 
0ea0			;		ld (hl),a 
0ea0			;		inc hl 
0ea0 3e 00				ld a,0 
0ea2 77					ld (hl),a 
0ea3 2b					dec hl 
0ea4			 
0ea4 3a 61 fb				ld a, (input_cursor) 
0ea7 3c					inc a				; TODO check max string length and scroll  
0ea8 32 61 fb				ld (input_cursor), a		; inc cursor pos 
0eab							 
0eab 3a 6e fb				ld a, (input_at_cursor) 
0eae 3c					inc a 
0eaf 32 6e fb				ld (input_at_cursor), a 
0eb2			 
0eb2 2a 75 fb				ld hl, (input_ptr) 
0eb5 23					inc hl 
0eb6 22 75 fb				ld (input_ptr), hl 
0eb9			 
0eb9 2a 75 fb				ld hl, (input_ptr) 
0ebc 23					inc hl 
0ebd 22 75 fb				ld (input_ptr), hl 
0ec0			;	if DEBUG_INPUT 
0ec0			;		push af 
0ec0			;		ld a, '+' 
0ec0			;		ld (debug_mark),a 
0ec0			;		pop af 
0ec0			;		CALLMONITOR 
0ec0			;	endif 
0ec0 3e 01				ld a, 1		; show cursor moving 
0ec2 32 6b fb				ld (input_cur_onoff),a 
0ec5 3e 0f				ld a, CUR_BLINK_RATE 
0ec7 32 6c fb				ld (input_cur_flash), a 
0eca c3 1d 0d				jp .is1 
0ecd					 
0ecd			 
0ecd			 
0ecd					; if on a char then insert 
0ecd			.onchar: 
0ecd			 
0ecd					; TODO over flow check: make sure insert does not blow out buffer 
0ecd			 
0ecd					; need to do some maths to use lddr 
0ecd			 
0ecd e5					push hl   ; save char pos 
0ece c5					push bc 
0ecf			 
0ecf 2a 73 fb				ld hl, (input_start) 
0ed2 3a 66 fb				ld a, (input_len) 
0ed5 cd bf 0c				call addatohl  		; end of string 
0ed8 23					inc hl 
0ed9 23					inc hl		; past zero term 
0eda e5					push hl 
0edb 23					inc hl 
0edc e5					push hl  
0edd			 
0edd								; start and end of lddr set, now how much to move? 
0edd			 
0edd							 
0edd 3a 61 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0ee0 47					ld b,a 
0ee1 3a 66 fb				ld a,(input_len) 
0ee4 5f					ld e,a 
0ee5 90					sub b 
0ee6 3c					inc a		;?? 
0ee7 3c					inc a		;?? 
0ee8 3c					inc a		;?? 
0ee9			 
0ee9 06 00				ld b,0 
0eeb 4f					ld c,a 
0eec			 
0eec				if DEBUG_INPUT 
0eec					push af 
0eec					ld a, 'i' 
0eec					ld (debug_mark),a 
0eec					pop af 
0eec			;		CALLMONITOR 
0eec				endif 
0eec d1					pop de 
0eed e1					pop hl 
0eee				if DEBUG_INPUT 
0eee					push af 
0eee					ld a, 'I' 
0eee					ld (debug_mark),a 
0eee					pop af 
0eee			;		CALLMONITOR 
0eee				endif 
0eee ed b8				lddr 
0ef0				 
0ef0			 
0ef0			 
0ef0					; TODO have a key for insert/overwrite mode???? 
0ef0 c1					pop bc 
0ef1 e1					pop hl 
0ef2 71					ld (hl), c		; otherwise overwrite current char 
0ef3					 
0ef3			 
0ef3			 
0ef3			 
0ef3 3a 61 fb				ld a, (input_cursor) 
0ef6 3c					inc  a 		; TODO check overflow 
0ef7 32 61 fb				ld (input_cursor), a 
0efa			 
0efa 3a 6e fb				ld a, (input_at_cursor) 
0efd 3c					inc a 
0efe 32 6e fb				ld (input_at_cursor), a 
0f01			 
0f01 c3 1d 0d				jp .is1 
0f04			 
0f04			.endinput:	; TODO look for end of string 
0f04			 
0f04					; add trailing space for end of token 
0f04			 
0f04 2a 73 fb				ld hl, (input_start) 
0f07 3a 66 fb				ld a,(input_len) 
0f0a cd bf 0c				call addatohl 
0f0d 3e 20				ld a, ' ' 
0f0f 77					ld (hl),a 
0f10					; TODO eof of parse marker 
0f10			 
0f10 23					inc hl 
0f11 3e 00				ld a, 0 
0f13 77					ld (hl),a 
0f14			 
0f14			 
0f14 c9					ret 
0f15			 
0f15 .. 00		.iblank: db " ",0 
0f17			 
0f17			 
0f17 32 70 fb		input_str_prev:	ld (input_at_pos), a 
0f1a 22 73 fb				ld (input_start), hl 
0f1d 3e 01				ld a,1			; add cursor 
0f1f 77					ld (hl),a 
0f20 23					inc hl 
0f21 3e 00				ld a,0 
0f23 77					ld (hl),a 
0f24 22 75 fb				ld (input_ptr), hl 
0f27 7a					ld a,d 
0f28 32 72 fb				ld (input_size), a 
0f2b 3e 00				ld a,0 
0f2d 32 61 fb				ld (input_cursor),a 
0f30			.instr1:	 
0f30			 
0f30					; TODO do block cursor 
0f30					; TODO switch cursor depending on the modifer key 
0f30			 
0f30					; update cursor shape change on key hold 
0f30			 
0f30 2a 75 fb				ld hl, (input_ptr) 
0f33 2b					dec hl 
0f34 3a d0 f8				ld a,(cursor_shape) 
0f37 77					ld (hl), a 
0f38			 
0f38					; display entered text 
0f38 3a 70 fb				ld a,(input_at_pos) 
0f3b cd 05 63		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f3e ed 5b 73 fb	            	LD   de, (input_start) 
0f42 cd 27 63		            	CALL fLCD_Str       ;Display string pointed to by DE 
0f45			 
0f45 cd 41 65				call cin 
0f48 fe 00				cp 0 
0f4a 28 e4				jr z, .instr1 
0f4c			 
0f4c					; proecess keyboard controls first 
0f4c			 
0f4c 2a 75 fb				ld hl,(input_ptr) 
0f4f			 
0f4f fe 0d				cp KEY_CR	 ; pressing enter ends input 
0f51 28 5a				jr z, .instrcr 
0f53			 
0f53 fe 08				cp KEY_BS 	; back space 
0f55 20 0f				jr nz, .instr2 
0f57					; process back space 
0f57			 
0f57					; TODO stop back space if at start of string 
0f57 2b					dec hl 
0f58 2b					dec hl ; to over write cursor 
0f59 3a d0 f8				ld a,(cursor_shape) 
0f5c					;ld a,0 
0f5c 77					ld (hl),a 
0f5d 23					inc hl 
0f5e 3e 20				ld a," " 
0f60 77					ld (hl),a 
0f61 22 75 fb				ld (input_ptr),hl 
0f64					 
0f64			 
0f64 18 ca				jr .instr1 
0f66			 
0f66 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0f68 20 06				jr nz, .instr3 
0f6a 2b					dec hl 
0f6b 22 75 fb				ld (input_ptr),hl 
0f6e 18 c0				jr .instr1 
0f70				 
0f70 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0f72 20 06				jr nz, .instr4 
0f74 23					inc hl 
0f75 22 75 fb				ld (input_ptr),hl 
0f78 18 b6				jr .instr1 
0f7a			 
0f7a fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0f7c 20 06				jr nz, .instr5 
0f7e 2b					dec hl 
0f7f 22 75 fb				ld (input_ptr),hl 
0f82 18 ac				jr .instr1 
0f84			 
0f84 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0f86 20 06				jr nz, .instr6 
0f88 2b					dec hl 
0f89 22 75 fb				ld (input_ptr),hl 
0f8c 18 a2				jr .instr1 
0f8e fe 05		.instr6:        cp KEY_UP      ; recall last command 
0f90 20 0b				jr nz, .instrnew 
0f92			 
0f92 21 32 ee			ld hl, scratch 
0f95 11 58 f2			ld de, os_last_cmd 
0f98 cd b6 0f			call strcpy 
0f9b 18 93				jr .instr1 
0f9d			 
0f9d			 
0f9d			.instrnew:	; no special key pressed to see if we have room to store it 
0f9d			 
0f9d					; TODO do string size test 
0f9d			 
0f9d 2b					dec hl ; to over write cursor 
0f9e 77					ld (hl),a 
0f9f 23					inc hl 
0fa0 3a d0 f8				ld a,(cursor_shape) 
0fa3 77					ld (hl),a 
0fa4 23					inc hl 
0fa5 3e 00				ld a,0 
0fa7 77					ld (hl),a 
0fa8			 
0fa8 22 75 fb				ld (input_ptr),hl 
0fab					 
0fab 18 83				jr .instr1 
0fad 2b			.instrcr:	dec hl		; remove cursor 
0fae 3e 20				ld a,' '	; TODO add a trailing space for safety 
0fb0 77					ld (hl),a 
0fb1 23					inc hl 
0fb2 3e 00				ld a,0 
0fb4 77					ld (hl),a 
0fb5			 
0fb5			 
0fb5					; if at end of line scroll up    
0fb5					; TODO detecting only end of line 4 for scroll up  
0fb5			 
0fb5					;ld   
0fb5			 
0fb5 c9					ret 
0fb6			 
0fb6			 
0fb6			; strcpy hl = dest, de source 
0fb6			 
0fb6 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0fb7 b7			            OR   A              ;Null terminator? 
0fb8 c8			            RET  Z              ;Yes, so finished 
0fb9 1a					ld a,(de) 
0fba 77					ld (hl),a 
0fbb 13			            INC  DE             ;Point to next character 
0fbc 23					inc hl 
0fbd 18 f7		            JR   strcpy       ;Repeat 
0fbf c9					ret 
0fc0			 
0fc0			 
0fc0			; TODO string_at  
0fc0			; pass string which starts with lcd offset address and then null term string 
0fc0			 
0fc0			; TODO string to dec 
0fc0			; TODO string to hex 
0fc0			; TODO byte to string hex 
0fc0			; TODO byte to string dec 
0fc0			 
0fc0			 
0fc0			 
0fc0			; from z80uartmonitor 
0fc0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fc0			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0fc0			; pass hl for where to put the text 
0fc0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fc0 c5			hexout:	PUSH BC 
0fc1 f5					PUSH AF 
0fc2 47					LD B, A 
0fc3					; Upper nybble 
0fc3 cb 3f				SRL A 
0fc5 cb 3f				SRL A 
0fc7 cb 3f				SRL A 
0fc9 cb 3f				SRL A 
0fcb cd db 0f				CALL tohex 
0fce 77					ld (hl),a 
0fcf 23					inc hl	 
0fd0					 
0fd0					; Lower nybble 
0fd0 78					LD A, B 
0fd1 e6 0f				AND 0FH 
0fd3 cd db 0f				CALL tohex 
0fd6 77					ld (hl),a 
0fd7 23					inc hl	 
0fd8					 
0fd8 f1					POP AF 
0fd9 c1					POP BC 
0fda c9					RET 
0fdb					 
0fdb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fdb			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0fdb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fdb			tohex: 
0fdb e5					PUSH HL 
0fdc d5					PUSH DE 
0fdd 16 00				LD D, 0 
0fdf 5f					LD E, A 
0fe0 21 e8 0f				LD HL, .DATA 
0fe3 19					ADD HL, DE 
0fe4 7e					LD A, (HL) 
0fe5 d1					POP DE 
0fe6 e1					POP HL 
0fe7 c9					RET 
0fe8			 
0fe8			.DATA: 
0fe8 30					DEFB	30h	; 0 
0fe9 31					DEFB	31h	; 1 
0fea 32					DEFB	32h	; 2 
0feb 33					DEFB	33h	; 3 
0fec 34					DEFB	34h	; 4 
0fed 35					DEFB	35h	; 5 
0fee 36					DEFB	36h	; 6 
0fef 37					DEFB	37h	; 7 
0ff0 38					DEFB	38h	; 8 
0ff1 39					DEFB	39h	; 9 
0ff2 41					DEFB	41h	; A 
0ff3 42					DEFB	42h	; B 
0ff4 43					DEFB	43h	; C 
0ff5 44					DEFB	44h	; D 
0ff6 45					DEFB	45h	; E 
0ff7 46					DEFB	46h	; F 
0ff8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0ff8			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0ff8			;;    subtract $30, if result > 9 then subtract $7 more 
0ff8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0ff8			atohex: 
0ff8 d6 30				SUB $30 
0ffa fe 0a				CP 10 
0ffc f8					RET M		; If result negative it was 0-9 so we're done 
0ffd d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0fff c9					RET		 
1000			 
1000			 
1000			 
1000			 
1000			; Get 2 ASCII characters as hex byte from pointer in hl 
1000			 
1000			BYTERD: 
1000 16 00			LD	D,00h		;Set up 
1002 cd 0a 10			CALL	HEXCON		;Get byte and convert to hex 
1005 87				ADD	A,A		;First nibble so 
1006 87				ADD	A,A		;multiply by 16 
1007 87				ADD	A,A		; 
1008 87				ADD	A,A		; 
1009 57				LD	D,A		;Save hi nibble in D 
100a			HEXCON: 
100a 7e				ld a, (hl)		;Get next chr 
100b 23				inc hl 
100c d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
100e fe 0a			CP	00Ah		;Is it 0-9 ? 
1010 38 02			JR	C,NALPHA	;If so miss next bit 
1012 d6 07			SUB	007h		;Else convert alpha 
1014			NALPHA: 
1014 b2				OR	D		;Add hi nibble back 
1015 c9				RET			; 
1016			 
1016			 
1016			; 
1016			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1016			; Since the routines get_byte and therefore get_nibble are called, only valid 
1016			; characters (0-9a-f) are accepted. 
1016			; 
1016			;get_word        push    af 
1016			;                call    get_byte        ; Get the upper byte 
1016			;                ld      h, a 
1016			;                call    get_byte        ; Get the lower byte 
1016			;                ld      l, a 
1016			;                pop     af 
1016			;                ret 
1016			; 
1016			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1016			; the routine get_nibble is used only valid characters are accepted - the  
1016			; input routine only accepts characters 0-9a-f. 
1016			; 
1016 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1017 7e					ld a,(hl) 
1018 23					inc hl 
1019 cd 3e 10		                call    nibble2val      ; Get upper nibble 
101c cb 07		                rlc     a 
101e cb 07		                rlc     a 
1020 cb 07		                rlc     a 
1022 cb 07		                rlc     a 
1024 47			                ld      b, a            ; Save upper four bits 
1025 7e					ld a,(hl) 
1026 cd 3e 10		                call    nibble2val      ; Get lower nibble 
1029 b0			                or      b               ; Combine both nibbles 
102a c1			                pop     bc              ; Restore B (and C) 
102b c9			                ret 
102c			; 
102c			; Get a hexadecimal digit from the serial line. This routine blocks until 
102c			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
102c			; to the serial line interface. The lower 4 bits of A contain the value of  
102c			; that particular digit. 
102c			; 
102c			;get_nibble      ld a,(hl)           ; Read a character 
102c			;                call    to_upper        ; Convert to upper case 
102c			;                call    is_hex          ; Was it a hex digit? 
102c			;                jr      nc, get_nibble  ; No, get another character 
102c			 ;               call    nibble2val      ; Convert nibble to value 
102c			 ;               call    print_nibble 
102c			 ;               ret 
102c			; 
102c			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
102c			; A valid hexadecimal digit is denoted by a set C flag. 
102c			; 
102c			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
102c			;                ret     nc              ; Yes 
102c			;                cp      '0'             ; Less than '0'? 
102c			;                jr      nc, is_hex_1    ; No, continue 
102c			;                ccf                     ; Complement carry (i.e. clear it) 
102c			;                ret 
102c			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
102c			;                ret     c               ; Yes 
102c			;                cp      'A'             ; Less than 'A'? 
102c			;                jr      nc, is_hex_2    ; No, continue 
102c			;                ccf                     ; Yes - clear carry and return 
102c			;                ret 
102c			;is_hex_2        scf                     ; Set carry 
102c			;                ret 
102c			; 
102c			; Convert a single character contained in A to upper case: 
102c			; 
102c fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
102e d8			                ret     c 
102f fe 7b		                cp      'z' + 1         ; > 'z'? 
1031 d0			                ret     nc              ; Nothing to do, either 
1032 e6 5f		                and     $5f             ; Convert to upper case 
1034 c9			                ret 
1035			 
1035			 
1035			to_lower: 
1035			 
1035			   ; if char is in [A-Z] make it lower case 
1035			 
1035			   ; enter : a = char 
1035			   ; exit  : a = lower case char 
1035			   ; uses  : af 
1035			 
1035 fe 41		   cp 'A' 
1037 d8			   ret c 
1038			    
1038 fe 5b		   cp 'Z'+1 
103a d0			   ret nc 
103b			    
103b f6 20		   or $20 
103d c9			   ret 
103e			 
103e			; 
103e			; Expects a hexadecimal digit (upper case!) in A and returns the 
103e			; corresponding value in A. 
103e			; 
103e fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1040 38 02		                jr      c, nibble2val_1 ; Yes 
1042 d6 07		                sub     7               ; Adjust for A-F 
1044 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1046 e6 0f		                and     $f              ; Only return lower 4 bits 
1048 c9			                ret 
1049			; 
1049			; Print_nibble prints a single hex nibble which is contained in the lower  
1049			; four bits of A: 
1049			; 
1049			;print_nibble    push    af              ; We won't destroy the contents of A 
1049			;                and     $f              ; Just in case... 
1049			;                add     a, '0'             ; If we have a digit we are done here. 
1049			;                cp      '9' + 1         ; Is the result > 9? 
1049			;                jr      c, print_nibble_1 
1049			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1049			;print_nibble_1  call    putc            ; Print the nibble and 
1049			;                pop     af              ; restore the original value of A 
1049			;                ret 
1049			;; 
1049			;; Send a CR/LF pair: 
1049			; 
1049			;crlf            push    af 
1049			;                ld      a, cr 
1049			;                call    putc 
1049			;                ld      a, lf 
1049			;                call    putc 
1049			;                pop     af 
1049			;                ret 
1049			; 
1049			; Print_word prints the four hex digits of a word to the serial line. The  
1049			; word is expected to be in HL. 
1049			; 
1049			;print_word      push    hl 
1049			;                push    af 
1049			;                ld      a, h 
1049			;                call    print_byte 
1049			;                ld      a, l 
1049			;                call    print_byte 
1049			;                pop     af 
1049			;                pop     hl 
1049			;                ret 
1049			; 
1049			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1049			; The byte to be printed is expected to be in A. 
1049			; 
1049			;print_byte      push    af              ; Save the contents of the registers 
1049			;                push    bc 
1049			;                ld      b, a 
1049			;                rrca 
1049			;                rrca 
1049			;                rrca 
1049			;                rrca 
1049			;                call    print_nibble    ; Print high nibble 
1049			;                ld      a, b 
1049			;                call    print_nibble    ; Print low nibble 
1049			;                pop     bc              ; Restore original register contents 
1049			;                pop     af 
1049			;                ret 
1049			 
1049			 
1049			 
1049			 
1049			 
1049			fourehexhl:  
1049 7e				ld a,(hl) 
104a cd f8 0f			call atohex 
104d cb 3f				SRL A 
104f cb 3f				SRL A 
1051 cb 3f				SRL A 
1053 cb 3f				SRL A 
1055 47				ld b, a 
1056 23				inc hl 
1057 7e				ld a,(hl) 
1058 23				inc hl 
1059 cd f8 0f			call atohex 
105c 80				add b 
105d 57				ld d,a 
105e 7e				ld a,(hl) 
105f cd f8 0f			call atohex 
1062 cb 3f				SRL A 
1064 cb 3f				SRL A 
1066 cb 3f				SRL A 
1068 cb 3f				SRL A 
106a 47				ld b, a 
106b 23				inc hl 
106c 7e				ld a,(hl) 
106d 23				inc hl 
106e cd f8 0f			call atohex 
1071 80				add b 
1072 5f				ld e, a 
1073 d5				push de 
1074 e1				pop hl 
1075 c9				ret 
1076			 
1076			; pass hl. returns z set if the byte at hl is a digit 
1076			;isdigithl:  
1076			;	push bc 
1076			;	ld a,(hl) 
1076			;	cp ':' 
1076			;	jr nc, .isdf 		; > 
1076			;	cp '0' 
1076			;	jr c, .isdf		; < 
1076			; 
1076			;	; TODO find a better way to set z 
1076			; 
1076			;	ld b,a 
1076			;	cp b 
1076			;	pop bc 
1076			;	ret 
1076			; 
1076			;.isdf:	; not digit so clear z 
1076			; 
1076			;	; TODO find a better way to unset z 
1076			; 
1076			;	ld b,a 
1076			;	inc b 
1076			;	cp b 
1076			; 
1076			;	pop bc 
1076			;	ret 
1076				 
1076				 
1076			 
1076			 
1076			; pass hl as the four byte address to load 
1076			 
1076			get_word_hl:  
1076 e5				push hl 
1077 cd 16 10			call get_byte 
107a				 
107a 47				ld b, a 
107b			 
107b e1				pop hl 
107c 23				inc hl 
107d 23				inc hl 
107e			 
107e			; TODO not able to handle a-f  
107e 7e				ld a,(hl) 
107f			;	;cp ':' 
107f			;	cp 'g' 
107f			;	jr nc, .single_byte_hl 		; > 
107f			;	cp 'G' 
107f			;	jr nc, .single_byte_hl 		; > 
107f			;	cp '0' 
107f			;	jr c, .single_byte_hl		; < 
107f			 
107f				;call isdigithl 
107f fe 00			cp 0 
1081 28 06			jr z, .single_byte_hl 
1083			 
1083			.getwhln:   ; hex word so get next byte 
1083			 
1083 cd 16 10			call get_byte 
1086 6f				ld l, a 
1087 60				ld h,b 
1088 c9				ret 
1089 68			.single_byte_hl:   ld l,b 
108a 26 00				ld h,0 
108c c9					ret 
108d			 
108d			 
108d			 
108d			 
108d 21 b2 17			ld hl,asc+1 
1090			;	ld a, (hl) 
1090			;	call nibble2val 
1090 cd 16 10			call get_byte 
1093			 
1093			;	call fourehexhl 
1093 32 66 ee			ld (scratch+52),a 
1096				 
1096 21 64 ee			ld hl,scratch+50 
1099 22 55 f1			ld (os_cur_ptr),hl 
109c			 
109c c9				ret 
109d			 
109d			 
109d			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
109d			 
109d			; Decimal Unsigned Version 
109d			 
109d			;Number in a to decimal ASCII 
109d			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
109d			;Example: display a=56 as "056" 
109d			;input: a = number 
109d			;Output: a=0,value of a in the screen 
109d			;destroys af,bc (don't know about hl and de) 
109d			DispAToASCII: 
109d 0e 9c			ld	c,-100 
109f cd a9 10			call	.Na1 
10a2 0e f6			ld	c,-10 
10a4 cd a9 10			call	.Na1 
10a7 0e ff			ld	c,-1 
10a9 06 2f		.Na1:	ld	b,'0'-1 
10ab 04			.Na2:	inc	b 
10ac 81				add	a,c 
10ad 38 fc			jr	c,.Na2 
10af 91				sub	c		;works as add 100/10/1 
10b0 f5				push af		;safer than ld c,a 
10b1 78				ld	a,b		;char is in b 
10b2			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10b2 f1				pop af		;safer than ld a,c 
10b3 c9				ret 
10b4			 
10b4			; Decimal Signed Version 
10b4			 
10b4			; DispA 
10b4			; -------------------------------------------------------------- 
10b4			; Converts a signed integer value to a zero-terminated ASCII 
10b4			; string representative of that value (using radix 10). 
10b4			; -------------------------------------------------------------- 
10b4			; INPUTS: 
10b4			;     HL     Value to convert (two's complement integer). 
10b4			;     DE     Base address of string destination. (pointer). 
10b4			; -------------------------------------------------------------- 
10b4			; OUTPUTS: 
10b4			;     None 
10b4			; -------------------------------------------------------------- 
10b4			; REGISTERS/MEMORY DESTROYED 
10b4			; AF HL 
10b4			; -------------------------------------------------------------- 
10b4			 
10b4			;DispHLToASCII: 
10b4			;   push    de 
10b4			;   push    bc 
10b4			; 
10b4			;; Detect sign of HL. 
10b4			;    bit    7, h 
10b4			;    jr     z, ._DoConvert 
10b4			; 
10b4			;; HL is negative. Output '-' to string and negate HL. 
10b4			;    ld     a, '-' 
10b4			;    ld     (de), a 
10b4			;    inc    de 
10b4			; 
10b4			;; Negate HL (using two's complement) 
10b4			;    xor    a 
10b4			;    sub    l 
10b4			;    ld     l, a 
10b4			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10b4			;    sbc    a, h 
10b4			;    ld     h, a 
10b4			; 
10b4			;; Convert HL to digit characters 
10b4			;._DoConvert: 
10b4			;    ld     b, 0     ; B will count character length of number 
10b4			;-   ld     a, 10 
10b4			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10b4			;    push   af 
10b4			;    inc    b 
10b4			;    ld     a, h 
10b4			;    or     l 
10b4			;    jr     nz, - 
10b4			; 
10b4			;; Retrieve digits from stack 
10b4			;-   pop    af 
10b4			;    or     $30 
10b4			;    ld     (de), a 
10b4			;    inc    de 
10b4			;    djnz   - 
10b4			; 
10b4			;; Terminate string with NULL 
10b4			;    xor    a 
10b4			;    ld     (de), a 
10b4			; 
10b4			;    pop    bc 
10b4			;    pop    de 
10b4			;    ret 
10b4			 
10b4			;Comments 
10b4			; 
10b4			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10b4			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10b4			;    Note that the output string will not be fixed-width. 
10b4			; 
10b4			;Example Usage 
10b4			; 
10b4			;    ld    hl, -1004 
10b4			;    ld    de, OP1 
10b4			;    call  DispA 
10b4			;    ld    hl, OP1 
10b4			;    syscall  PutS 
10b4			 
10b4			 
10b4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10b4			 
10b4			 
10b4			;Converts an ASCII string to an unsigned 16-bit integer 
10b4			;Quits when it reaches a non-decimal digit 
10b4			 
10b4			string_to_uint16: 
10b4			atoui_16: 
10b4			;Input: 
10b4			;     DE points to the string 
10b4			;Outputs: 
10b4			;     HL is the result 
10b4			;     A is the 8-bit value of the number 
10b4			;     DE points to the byte after the number 
10b4			;Destroys: 
10b4			;     BC 
10b4			;       if the string is non-empty, BC is HL/10 
10b4			;Size:  24 bytes 
10b4			;Speed: 42+d(104+{0,9}) 
10b4			;       d is the number of digits in the number 
10b4			;       max is 640 cycles for a 5 digit number 
10b4			;Assuming no leading zeros: 
10b4			;1 digit:  146cc 
10b4			;2 digit:  250cc 
10b4			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10b4			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10b4			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10b4			;avg: 544.81158447265625cc (544+13297/16384) 
10b4			;=============================================================== 
10b4 21 00 00		  ld hl,0 
10b7			.u16a: 
10b7 1a			  ld a,(de) 
10b8 d6 30		  sub 30h 
10ba fe 0a		  cp 10 
10bc d0			  ret nc 
10bd 13			  inc de 
10be 44			  ld b,h 
10bf 4d			  ld c,l 
10c0 29			  add hl,hl 
10c1 29			  add hl,hl 
10c2 09			  add hl,bc 
10c3 29			  add hl,hl 
10c4 85			  add a,l 
10c5 6f			  ld l,a 
10c6 30 ef		  jr nc,.u16a 
10c8 24			  inc h 
10c9 c3 b7 10		  jp .u16a 
10cc			 
10cc			 
10cc			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10cc			 
10cc			;written by Zeda 
10cc			;Converts a 16-bit unsigned integer to an ASCII string. 
10cc			 
10cc			uitoa_16: 
10cc			;Input: 
10cc			;   DE is the number to convert 
10cc			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
10cc			;Output: 
10cc			;   HL points to the null-terminated ASCII string 
10cc			;      NOTE: This isn't necessarily the same as the input HL. 
10cc d5			  push de 
10cd c5			  push bc 
10ce f5			  push af 
10cf eb			  ex de,hl 
10d0			 
10d0 01 f0 d8		  ld bc,-10000 
10d3 3e 2f		  ld a,'0'-1 
10d5 3c			  inc a 
10d6 09			  add hl,bc  
10d7 38 fc		   jr c,$-2 
10d9 12			  ld (de),a 
10da 13			  inc de 
10db			 
10db 01 e8 03		  ld bc,1000 
10de 3e 3a		  ld a,'9'+1 
10e0 3d			  dec a  
10e1 09			  add hl,bc  
10e2 30 fc		   jr nc,$-2 
10e4 12			  ld (de),a 
10e5 13			  inc de 
10e6			 
10e6 01 9c ff		  ld bc,-100 
10e9 3e 2f		  ld a,'0'-1 
10eb 3c			  inc a  
10ec 09			  add hl,bc  
10ed 38 fc		   jr c,$-2 
10ef 12			  ld (de),a 
10f0 13			  inc de 
10f1			 
10f1 7d			  ld a,l 
10f2 26 3a		  ld h,'9'+1 
10f4 25			  dec h  
10f5 c6 0a		  add a,10  
10f7 30 fb		   jr nc,$-3 
10f9 c6 30		  add a,'0' 
10fb eb			  ex de,hl 
10fc 72			  ld (hl),d 
10fd 23			  inc hl 
10fe 77			  ld (hl),a 
10ff 23			  inc hl 
1100 36 00		  ld (hl),0 
1102			 
1102			;Now strip the leading zeros 
1102 0e fa		  ld c,-6 
1104 09			  add hl,bc 
1105 3e 30		  ld a,'0' 
1107 23			  inc hl  
1108 be			  cp (hl)  
1109 28 fc		  jr z,$-2 
110b			 
110b			;Make sure that the string is non-empty! 
110b 7e			  ld a,(hl) 
110c b7			  or a 
110d 20 01		  jr nz,.atoub 
110f 2b			  dec hl 
1110			.atoub: 
1110			 
1110 f1			  pop af 
1111 c1			  pop bc 
1112 d1			  pop de 
1113 c9			  ret 
1114			 
1114			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1114			 
1114			toUpper: 
1114			;A is the char. 
1114			;If A is a lowercase letter, this sets it to the matching uppercase 
1114			;18cc or 30cc or 41cc 
1114			;avg: 26.75cc 
1114 fe 61		  cp 'a' 
1116 d8			  ret c 
1117 fe 7b		  cp 'z'+1 
1119 d0			  ret nc 
111a d6 20		  sub 'a'-'A' 
111c c9			  ret 
111d			 
111d			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
111d			 
111d			; String Length 
111d			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
111d			 
111d			; Get the length of the null-terminated string starting at $8000 hl 
111d			;    LD     HL, $8000 
111d			 
111d			strlenz: 
111d			 
111d af			    XOR    A               ; Zero is the value we are looking for. 
111e 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
111f 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1120			                           ; 65, 536 bytes (the entire addressable memory space). 
1120 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1122			 
1122			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1122 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1123 6f			    LD     L, A             ; number of bytes 
1124 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1126 2b			    DEC    HL              ; Compensate for null. 
1127 c9				ret 
1128			 
1128			; Get the length of the A terminated string starting at $8000 hl 
1128			;    LD     HL, $8000 
1128			 
1128			strlent: 
1128			 
1128			                  ; A is the value we are looking for. 
1128 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
112a 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
112c			                           ; 65, 536 bytes (the entire addressable memory space). 
112c ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
112e			 
112e			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
112e 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1130 2e 00		    LD     L, 0             ; number of bytes 
1132 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1134 2b			    DEC    HL              ; Compensate for null. 
1135 c9				ret 
1136			 
1136			 
1136			;Comparing Strings 
1136			 
1136			;IN    HL     Address of string1. 
1136			;      DE     Address of string2. 
1136			 
1136			; doc given but wrong??? 
1136			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1136			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1136			; tested 
1136			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1136			 
1136			strcmp_old: 
1136 e5			    PUSH   HL 
1137 d5			    PUSH   DE 
1138			 
1138 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1139 be			    CP     (HL)            ; (want to minimize work). 
113a 38 01		    JR     C, Str1IsBigger 
113c 7e			    LD     A, (HL) 
113d			 
113d			Str1IsBigger: 
113d 4f			    LD     C, A             ; Put length in BC 
113e 06 00		    LD     B, 0 
1140 13			    INC    DE              ; Increment pointers to meat of string. 
1141 23			    INC    HL 
1142			 
1142			CmpLoop: 
1142 1a			    LD     A, (DE)          ; Compare bytes. 
1143 ed a1		    CPI 
1145 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1147 13			    INC    DE              ; Update pointer. 
1148 ea 42 11		    JP     PE, CmpLoop 
114b			 
114b d1			    POP    DE 
114c e1			    POP    HL 
114d 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
114e be			    CP     (HL) 
114f c9			    RET 
1150			 
1150			NoMatch: 
1150 2b			    DEC    HL 
1151 be			    CP     (HL)            ; Compare again to affect carry. 
1152 d1			    POP    DE 
1153 e1			    POP    HL 
1154 c9			    RET 
1155			 
1155			;; test strmp 
1155			; 
1155			;ld de, .str1 
1155			;ld hl, .str2 
1155			;call strcmp 
1155			;jr z, .z1 
1155			;;this 
1155			;	if DEBUG_FORTH_WORDS 
1155			;		DMARK "NZ1" 
1155			;		CALLMONITOR 
1155			;	endif 
1155			;.z1: 
1155			; 
1155			;	if DEBUG_FORTH_WORDS 
1155			;		DMARK "ZZ1" 
1155			;		CALLMONITOR 
1155			;	endif 
1155			; 
1155			;ld de, .str1 
1155			;ld hl, .str1 
1155			;call strcmp 
1155			;jr z, .z2 
1155			;;this 
1155			;	if DEBUG_FORTH_WORDS 
1155			;		DMARK "NZ2" 
1155			;		CALLMONITOR 
1155			;	endif 
1155			;.z2: 
1155			; 
1155			;	if DEBUG_FORTH_WORDS 
1155			;		DMARK "ZZ2" 
1155			;		CALLMONITOR 
1155			;	endif 
1155			; 
1155			;ld de, .str1 
1155			;ld hl, .str2 
1155			;call strcmp 
1155			;jr c, .c1 
1155			; 
1155			;	if DEBUG_FORTH_WORDS 
1155			;		DMARK "Nc1" 
1155			;		CALLMONITOR 
1155			;	endif 
1155			;.c1: 
1155			;;this 
1155			;	if DEBUG_FORTH_WORDS 
1155			;		DMARK "cc1" 
1155			;		CALLMONITOR 
1155			;	endif 
1155			; 
1155			;ld de, .str1 
1155			;ld hl, .str1 
1155			;call strcmp 
1155			;jr c, .c2 
1155			;;this 
1155			;	if DEBUG_FORTH_WORDS 
1155			;		DMARK "Nc2" 
1155			;		CALLMONITOR 
1155			;	endif 
1155			;.c2: 
1155			; 
1155			;	if DEBUG_FORTH_WORDS 
1155			;		DMARK "cc2" 
1155			;		CALLMONITOR 
1155			;	endif 
1155			;	NEXTW 
1155			;.str1:   db "string1",0 
1155			;.str2:   db "string2",0 
1155			 
1155			; only care about direct match or not 
1155			; hl and de strings 
1155			; zero set if the same 
1155			 
1155			strcmp: 
1155 1a				ld a, (de) 
1156 be				cp (hl) 
1157 28 02			jr z, .ssame 
1159 b7				or a 
115a c9				ret 
115b			 
115b			.ssame:  
115b fe 00			cp 0 
115d c8				ret z 
115e			 
115e 23				inc hl 
115f 13				inc de 
1160 18 f3			jr strcmp 
1162				 
1162				 
1162			 
1162			 
1162			 
1162			 
1162			; eof 
1162			 
1162			 
1162			 
1162			 
1162			 
1162			 
# End of file firmware_strings.asm
1162			include "firmware_memory.asm"   ; malloc and free  
1162			 
1162			if DEBUG_FORTH_MALLOC_HIGH 
1162			.mallocsize: db "Wants malloc >256",0 
1162			.mallocasize: db "MALLOC gives >256",0 
1162			.malloczero: db "MALLOC gives zero",0 
1162			 
1162			malloc_guard_zerolen: 
1162				push hl 
1162				push de 
1162				push af 
1162			 
1162				ld de, 0 
1162			        call cmp16 
1162				jr nz, .lowalloz 
1162			 
1162				push hl 
1162				push de 
1162					ld hl, display_fb0 
1162					ld (display_fb_active), hl 
1162				call clear_display 
1162				ld a, 0 
1162				ld de, .malloczero 
1162				call str_at_display 
1162				call update_display 
1162				call delay1s 
1162				call delay1s 
1162				ld a, 0 
1162				ld (os_view_disable), a 
1162			 
1162				pop de 
1162				pop hl 
1162			 
1162				 
1162			 
1162				CALLMONITOR 
1162			.lowalloz: 
1162			 
1162			 
1162				pop af 
1162				pop de 
1162				pop hl 
1162			ret 
1162			 
1162			malloc_guard_entry: 
1162				push hl 
1162				push de 
1162				push af 
1162			 
1162			 	or a      ;clear carry flag 
1162				push hl 
1162				ld de, 255 
1162				sbc hl, de 
1162				jr c, .lowalloc 
1162			 
1162				push de 
1162					ld hl, display_fb0 
1162					ld (display_fb_active), hl 
1162				call clear_display 
1162				ld a, 0 
1162				ld de, .mallocsize 
1162				call str_at_display 
1162				call update_display 
1162				call delay1s 
1162				call delay1s 
1162				ld a, 0 
1162				ld (os_view_disable), a 
1162			 
1162				pop de 
1162				pop hl 
1162			 
1162				 
1162			 
1162				CALLMONITOR 
1162				jr .lowdone 
1162			.lowalloc: 
1162			 
1162			 
1162				pop hl 
1162			.lowdone:	pop af 
1162				pop de 
1162				pop hl 
1162			ret 
1162			 
1162			malloc_guard_exit: 
1162				push hl 
1162				push de 
1162				push af 
1162			 
1162			 	or a      ;clear carry flag 
1162				push hl 
1162				ld de, 255 
1162				sbc hl, de 
1162				jr c, .lowallocx 
1162			 
1162				push de 
1162					ld hl, display_fb0 
1162					ld (display_fb_active), hl 
1162				call clear_display 
1162				ld a, 0 
1162				ld de, .mallocasize 
1162				call str_at_display 
1162				call update_display 
1162				call delay1s 
1162				call delay1s 
1162				ld a, 0 
1162				ld (os_view_disable), a 
1162				pop de 
1162				pop hl 
1162			 
1162				CALLMONITOR 
1162				jr .lowdonex 
1162			.lowallocx: 
1162			 
1162				pop hl 
1162			.lowdonex:	pop af 
1162				pop de 
1162				pop hl 
1162			ret 
1162			endif 
1162			 
1162			if MALLOC_2 
1162			; Z80 Malloc and Free Functions 
1162			 
1162			; Malloc Function: 
1162			; Input: 
1162			;   HL: Size of block to allocate 
1162			; Output: 
1162			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1162			 
1162			malloc: 
1162				 
1162			if DEBUG_FORTH_MALLOC_HIGH 
1162			call malloc_guard_entry 
1162			endif 
1162			 
1162			 
1162			 
1162			 
1162					if DEBUG_FORTH_MALLOC 
1162						DMARK "mal" 
1162						CALLMONITOR 
1162					endif 
1162			    push af            ; Save AF register 
1162			    ld a, l            ; Load low byte of size into A 
1162			    or h               ; Check if size is zero 
1162			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1162			 
1162			    ; Allocate memory 
1162			    ld hl, (heap_start) ; Load start of heap into HL 
1162					if DEBUG_FORTH_MALLOC 
1162						DMARK "ma1" 
1162						CALLMONITOR 
1162					endif 
1162			    call malloc_internal ; Call internal malloc function 
1162			    pop af             ; Restore AF register 
1162			if DEBUG_FORTH_MALLOC_HIGH 
1162			call malloc_guard_exit 
1162			call malloc_guard_zerolen 
1162			endif 
1162			    ret                ; Return 
1162			 
1162			; Free Function: 
1162			; Input: 
1162			;   HL: Pointer to memory block to free 
1162			; Output: 
1162			;   None 
1162			 
1162			free: 
1162			    push af            ; Save AF register 
1162			    ld a, l            ; Load low byte of pointer into A 
1162			    or h               ; Check if pointer is NULL 
1162			    jp z, free_exit    ; If pointer is NULL, exit 
1162			 
1162			    ; Free memory 
1162			    ld hl, (heap_start) ; Load start of heap into HL 
1162			    call free_internal  ; Call internal free function 
1162			    pop af             ; Restore AF register 
1162			    ret                ; Return 
1162			 
1162			; Internal Malloc Function: 
1162			; Input: 
1162			;   HL: Size of block to allocate 
1162			; Output: 
1162			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1162			 
1162			malloc_internal: 
1162			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1162			    add hl, bc         ; Add management overhead to requested size 
1162			    ex de, hl          ; Save total size in DE, and keep it in HL 
1162					if DEBUG_FORTH_MALLOC 
1162						DMARK "ma2" 
1162						CALLMONITOR 
1162					endif 
1162			 
1162			    ; Search for free memory block 
1162			    ld de, (heap_end)  ; Load end of heap into DE 
1162			    ld bc, 0           ; Initialize counter 
1162			 
1162					if DEBUG_FORTH_MALLOC 
1162						DMARK "ma2" 
1162						CALLMONITOR 
1162					endif 
1162			malloc_search_loop: 
1162			    ; Check if current block is free 
1162			    ld a, (hl)         ; Load current block's status (free or used) 
1162			    cp 0               ; Compare with zero (free) 
1162			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1162			 
1162			    ; Check if current block is large enough 
1162			    ld a, (hl+1)       ; Load high byte of block size 
1162			    cp l               ; Compare with low byte of requested size 
1162			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1162			 
1162			    ld a, (hl+2)       ; Load low byte of block size 
1162			    cp h               ; Compare with high byte of requested size 
1162			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1162			 
1162			    ; Mark block as used 
1162			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1162			 
1162			    ; Calculate remaining space in block 
1162			    ld bc, 0           ; Clear BC 
1162			    add hl, bc         ; Increment HL to point to start of data block 
1162			    add hl, de         ; HL = HL + DE (total size) 
1162			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1162			    add hl, bc         ; Add management overhead to start of data block 
1162			 
1162			    ; Save pointer to allocated block in HL 
1162			if DEBUG_FORTH_MALLOC_HIGH 
1162						DMARK "ma5" 
1162			call malloc_guard_exit 
1162			call malloc_guard_zerolen 
1162			endif 
1162			    ret 
1162			 
1162			malloc_skip_block_check: 
1162			    ; Move to the next block 
1162			    ld bc, 3           ; Size of management overhead 
1162			    add hl, bc         ; Move to the next block 
1162			    inc de             ; Increment counter 
1162			 
1162			    ; Check if we have reached the end of heap 
1162			    ld a, e            ; Load low byte of heap end address 
1162			    cp (hl)            ; Compare with low byte of current address 
1162			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1162			    ld a, d            ; Load high byte of heap end address 
1162			    cp 0               ; Check if it's zero (end of memory) 
1162			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1162			 
1162			    ; If we reached here, allocation failed 
1162			    xor a              ; Set result to NULL 
1162			if DEBUG_FORTH_MALLOC_HIGH 
1162						DMARK "ma6" 
1162			call malloc_guard_exit 
1162			call malloc_guard_zerolen 
1162			endif 
1162			    ret 
1162			malloc_exit: 
1162			if DEBUG_FORTH_MALLOC_HIGH 
1162						DMARK "ma7" 
1162			call malloc_guard_exit 
1162			call malloc_guard_zerolen 
1162			endif 
1162			    ret 
1162			 
1162			; Internal Free Function: 
1162			; Input: 
1162			;   HL: Pointer to memory block to free 
1162			; Output: 
1162			;   None 
1162			 
1162			free_internal: 
1162			    ld de, (heap_start) ; Load start of heap into DE 
1162			    ld bc, 0            ; Initialize counter 
1162			 
1162			free_search_loop: 
1162			    ; Check if current block contains the pointer 
1162			    ld a, l             ; Load low byte of pointer 
1162			    cp (hl+1)           ; Compare with high byte of current block's address 
1162			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1162			    ld a, h             ; Load high byte of pointer 
1162			    cp (hl+2)           ; Compare with low byte of current block's address 
1162			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1162			 
1162			    ; Mark block as free 
1162			    ld (hl), 0          ; Set status byte to indicate free block 
1162			    ret                 ; Return 
1162			 
1162			free_skip_block_check: 
1162			    ; Move to the next block 
1162			    ld bc, 3            ; Size of management overhead 
1162			    add hl, bc          ; Move to the next block 
1162			    inc de              ; Increment counter 
1162			 
1162			    ; Check if we have reached the end of heap 
1162			    ld a, e             ; Load low byte of heap end address 
1162			    cp (hl)             ; Compare with low byte of current address 
1162			    jr nz, free_search_loop  ; If not equal, continue searching 
1162			    ld a, d             ; Load high byte of heap end address 
1162			    cp 0                ; Check if it's zero (end of memory) 
1162			    jr nz, free_search_loop  ; If not zero, continue searching 
1162			 
1162			    ; If we reached here, pointer is not found in heap 
1162			    ret 
1162			 
1162			free_exit: 
1162			    ret                 ; Return 
1162			 
1162			; Define heap start and end addresses 
1162			;heap_start:    .dw 0xC000   ; Start of heap 
1162			;heap_end:      .dw 0xE000   ; End of heap 
1162			 
1162			endif 
1162			 
1162			 
1162			if MALLOC_1 
1162			 
1162			 
1162			 
1162			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1162			 
1162			;moved to firmware.asm 
1162			;heap_start        .equ  0x9000      ; Starting address of heap 
1162			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1162			 
1162			;      .org 0 
1162			;      jp    main 
1162			 
1162			 
1162			;      .org  0x100 
1162			;main: 
1162			;      ld    HL, 0x8100 
1162			;      ld    SP, HL 
1162			; 
1162			;      call  heap_init 
1162			; 
1162			;      ; Make some allocations 
1162			;      ld    HL, 12 
1162			;      call  malloc            ; Allocates 0x9004 
1162			; 
1162			;      ld    HL, 12 
1162			;      call  malloc            ; Allocates 0x9014 
1162			; 
1162			;      ld    HL, 12 
1162			;      call  malloc            ; Allocates 0x9024 
1162			; 
1162			;      ; Free some allocations 
1162			;      ld    HL, 0x9014 
1162			;      call  free 
1162			; 
1162			;      ld    HL, 0x9004 
1162			;      call  free 
1162			; 
1162			;      ld    HL, 0x9024 
1162			;      call  free 
1162			; 
1162			; 
1162			;      halt 
1162			 
1162			 
1162			;------------------------------------------------------------------------------ 
1162			;     heap_init                                                               : 
1162			;                                                                             : 
1162			; Description                                                                 : 
1162			;     Initialise the heap and make it ready for malloc and free operations.   : 
1162			;                                                                             : 
1162			;     The heap is maintained as a linked list, starting with an initial       : 
1162			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1162			;     the first free block in the heap. Each block then points to the next    : 
1162			;     free block within the heap, and the free list ends at the first block   : 
1162			;     with a null pointer to the next free block.                             : 
1162			;                                                                             : 
1162			; Parameters                                                                  : 
1162			;     Inputs are compile-time only. Two defines which specify the starting    : 
1162			;     address of the heap and its size are required, along with a memory      : 
1162			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1162			;     principally stores a pointer to the first free block in the heap.       : 
1162			;                                                                             : 
1162			; Returns                                                                     : 
1162			;     Nothing                                                                 : 
1162			;------------------------------------------------------------------------------ 
1162			heap_init: 
1162 e5			      push  HL 
1163			 
1163			      ; Initialise free list struct 
1163 21 0e 80		      ld    HL, heap_start 
1166 22 0a 80		      ld    (free_list), HL 
1169 21 00 00		      ld    HL, 0 
116c 22 0c 80		      ld    (free_list+2), HL 
116f			 
116f			      ; Insert first free block at bottom of heap, consumes entire heap 
116f 21 22 ee		      ld    HL, heap_start+heap_size-4 
1172 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1175 21 14 6e		      ld    HL, heap_size-4 
1178 22 10 80		      ld    (heap_start+2), HL      ; Block size 
117b			 
117b			      ; Insert end of free list block at top of heap - two null words will 
117b			      ; terminate the free list 
117b 21 00 00		      ld    HL, 0 
117e 22 24 ee		      ld    (heap_start+heap_size-2), HL 
1181 22 22 ee		      ld    (heap_start+heap_size-4), HL 
1184			 
1184 e1			      pop   HL 
1185			 
1185 c9			      ret 
1186			 
1186			 
1186			;------------------------------------------------------------------------------ 
1186			;     malloc                                                                  : 
1186			;                                                                             : 
1186			; Description                                                                 : 
1186			;     Allocates the wanted space from the heap and returns the address of the : 
1186			;     first useable byte of the allocation.                                   : 
1186			;                                                                             : 
1186			;     Allocations can happen in one of two ways:                              : 
1186			;                                                                             : 
1186			;     1. A free block may be found which is the exact size wanted. In this    : 
1186			;        case the block is removed from the free list and retuedn to the      : 
1186			;        caller.                                                              : 
1186			;     2. A free block may be found which is larger than the size wanted. In   : 
1186			;        this case, the larger block is split into two. The first portion of  : 
1186			;        this block will become the requested space by the malloc call and    : 
1186			;        is returned to the caller. The second portion becomes a new free     : 
1186			;        block, and the free list is adjusted to maintain continuity via this : 
1186			;        newly created block.                                                 : 
1186			;                                                                             : 
1186			;     malloc does not set any initial value in the allocated space, the       : 
1186			;     caller is required to do this as required.                              : 
1186			;                                                                             : 
1186			;     This implementation of malloc uses the stack exclusively, and is        : 
1186			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1186			;     advisable to disable interrupts before calling malloc, and recommended  : 
1186			;     to avoid the use of malloc inside ISRs in general.                      : 
1186			;                                                                             : 
1186			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1186			;                                                                             : 
1186			; Parameters                                                                  : 
1186			;     HL  Number of bytes wanted                                              : 
1186			;                                                                             : 
1186			; Returns                                                                     : 
1186			;     HL  Address of the first useable byte of the allocation                 : 
1186			;                                                                             : 
1186			; Flags                                                                       : 
1186			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1186			;                                                                             : 
1186			; Stack frame                                                                 : 
1186			;       |             |                                                       : 
1186			;       +-------------+                                                       : 
1186			;       |     BC      |                                                       : 
1186			;       +-------------+                                                       : 
1186			;       |     DE      |                                                       : 
1186			;       +-------------+                                                       : 
1186			;       |     IX      |                                                       : 
1186			;       +-------------+                                                       : 
1186			;       |  prev_free  |                                                       : 
1186			;   +4  +-------------+                                                       : 
1186			;       |  this_free  |                                                       : 
1186			;   +2  +-------------+                                                       : 
1186			;       |  next_free  |                                                       : 
1186			;   +0  +-------------+                                                       : 
1186			;       |             |                                                       : 
1186			;                                                                             : 
1186			;------------------------------------------------------------------------------ 
1186			 
1186			 
1186			;malloc: 
1186			; 
1186			;	SAVESP ON 1 
1186			; 
1186			;	call malloc_code 
1186			; 
1186			;	CHECKSP ON 1 
1186			;	ret 
1186			 
1186			 
1186			malloc: 
1186 c5			      push  BC 
1187 d5			      push  DE 
1188 dd e5		      push  IX 
118a			if DEBUG_FORTH_MALLOC_HIGH 
118a			call malloc_guard_entry 
118a			endif 
118a			 
118a					if DEBUG_FORTH_MALLOC 
118a						DMARK "mal" 
118a						CALLMONITOR 
118a					endif 
118a 7c			      ld    A, H                    ; Exit if no space requested 
118b b5			      or    L 
118c ca 4b 12		      jp    Z, malloc_early_exit 
118f			 
118f			;inc hl 
118f			;inc hl 
118f			;inc hl 
118f			; 
118f			;inc hl 
118f			;inc hl 
118f			;inc hl 
118f			;inc hl 
118f			;inc hl 
118f			;inc hl 
118f			;inc hl 
118f			;inc hl 
118f			;inc hl 
118f			 
118f			 
118f			 
118f			 
118f					if DEBUG_FORTH_MALLOC 
118f						DMARK "maA" 
118f						CALLMONITOR 
118f					endif 
118f			      ; Set up stack frame 
118f eb			      ex    DE, HL 
1190 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1193 39			      add   HL, SP 
1194 f9			      ld    SP, HL 
1195 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1199 dd 39		      add   IX, SP 
119b			 
119b			      ; Setup initial state 
119b 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
119e 19			      add   HL, DE 
119f			 
119f 44			      ld    B, H                    ; Move want to BC 
11a0 4d			      ld    C, L 
11a1			 
11a1 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
11a4 dd 75 04		      ld    (IX+4), L 
11a7 dd 74 05		      ld    (IX+5), H 
11aa			 
11aa 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11ab 23			      inc   HL 
11ac 56			      ld    D, (HL) 
11ad dd 73 02		      ld    (IX+2), E 
11b0 dd 72 03		      ld    (IX+3), D 
11b3 eb			      ex    DE, HL                  ; this_free ptr into HL 
11b4			 
11b4					if DEBUG_FORTH_MALLOC 
11b4						DMARK "maB" 
11b4						CALLMONITOR 
11b4					endif 
11b4			      ; Loop through free block list to find some space 
11b4			malloc_find_space: 
11b4 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11b5 23			      inc   HL 
11b6 56			      ld    D, (HL) 
11b7			 
11b7 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
11b8 b3			      or    E 
11b9 ca 45 12		      jp    Z, malloc_no_space 
11bc			 
11bc dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
11bf dd 72 01		      ld    (IX+1), D 
11c2			 
11c2			      ; Does this block have enough space to make the allocation? 
11c2 23			      inc   HL                      ; Load free block size into DE 
11c3 5e			      ld    E, (HL) 
11c4 23			      inc   HL 
11c5 56			      ld    D, (HL) 
11c6			 
11c6 eb			      ex    DE, HL                  ; Check size of block against want 
11c7 b7			      or    A                       ; Ensure carry flag clear 
11c8 ed 42		      sbc   HL, BC 
11ca e5			      push  HL                      ; Store the result for later (new block size) 
11cb			 
11cb ca 1a 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
11ce 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
11d0			 
11d0			      ; this_free block is not big enough, setup ptrs to test next free block 
11d0 e1			      pop   HL                      ; Discard previous result 
11d1			 
11d1 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
11d4 dd 66 03		      ld    H, (IX+3) 
11d7 dd 75 04		      ld    (IX+4), L 
11da dd 74 05		      ld    (IX+5), H 
11dd			 
11dd dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
11e0 dd 66 01		      ld    H, (IX+1) 
11e3 dd 75 02		      ld    (IX+2), L 
11e6 dd 74 03		      ld    (IX+3), H 
11e9			 
11e9					if DEBUG_FORTH_MALLOC 
11e9						DMARK "MA>" 
11e9						CALLMONITOR 
11e9					endif 
11e9 18 c9		      jr    malloc_find_space 
11eb			 
11eb			      ; split a bigger block into two - requested size and remaining size 
11eb			malloc_alloc_split: 
11eb					if DEBUG_FORTH_MALLOC 
11eb						DMARK "MAs" 
11eb						CALLMONITOR 
11eb					endif 
11eb eb			      ex    DE, HL                  ; Calculate address of new free block 
11ec 2b			      dec   HL 
11ed 2b			      dec   HL 
11ee 2b			      dec   HL 
11ef 09			      add   HL, BC 
11f0			 
11f0			      ; Create a new block and point it at next_free 
11f0 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
11f3 dd 56 01		      ld    D, (IX+1) 
11f6			 
11f6 73			      ld    (HL), E                 ; Store next_free ptr into new block 
11f7 23			      inc   HL 
11f8 72			      ld    (HL), D 
11f9			 
11f9 d1			      pop   DE                      ; Store size of new block into new block 
11fa 23			      inc   HL 
11fb 73			      ld    (HL), E 
11fc 23			      inc   HL 
11fd 72			      ld    (HL), D 
11fe			 
11fe			      ; Update this_free ptr to point to new block 
11fe 2b			      dec   HL 
11ff 2b			      dec   HL 
1200 2b			      dec   HL 
1201			 
1201 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1204 dd 56 03		      ld    D, (IX+3) 
1207			 
1207 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
120a dd 74 03		      ld    (IX+3), H 
120d			 
120d			      ; Modify this_free block to be allocation 
120d eb			      ex    DE, HL 
120e af			      xor   A                       ; Null the next block ptr of allocated block 
120f 77			      ld    (HL), A 
1210 23			      inc   HL 
1211 77			      ld    (HL), A 
1212			 
1212 23			      inc   HL                      ; Store want size into allocated block 
1213 71			      ld    (HL), C 
1214 23			      inc   HL 
1215 70			      ld    (HL), B 
1216 23			      inc   HL 
1217 e5			      push  HL                      ; Address of allocation to return 
1218			 
1218 18 19		      jr    malloc_update_links 
121a			 
121a			malloc_alloc_fit: 
121a e1			      pop   HL                      ; Dont need new block size, want is exact fit 
121b			 
121b					if DEBUG_FORTH_MALLOC 
121b						DMARK "MAf" 
121b						CALLMONITOR 
121b					endif 
121b			      ; Modify this_free block to be allocation 
121b eb			      ex    DE, HL 
121c 2b			      dec   HL 
121d 2b			      dec   HL 
121e 2b			      dec   HL 
121f			 
121f af			      xor   A                       ; Null the next block ptr of allocated block 
1220 77			      ld    (HL), A 
1221 23			      inc   HL 
1222 77			      ld    (HL), A 
1223			 
1223 23			      inc   HL                      ; Store address of allocation to return 
1224 23			      inc   HL 
1225 23			      inc   HL 
1226 e5			      push  HL 
1227			 
1227			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1227 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
122a dd 66 01		      ld    H, (IX+1) 
122d			 
122d dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1230 dd 74 03		      ld    (IX+3), H 
1233			 
1233			 
1233			malloc_update_links: 
1233			      ; Update prev_free ptr to point to this_free 
1233 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1236 dd 66 05		      ld    H, (IX+5) 
1239			 
1239 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
123c dd 56 03		      ld    D, (IX+3) 
123f			 
123f 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1240 23			      inc   HL 
1241 72			      ld    (HL), D 
1242			 
1242					if DEBUG_FORTH_MALLOC 
1242						DMARK "Mul" 
1242						CALLMONITOR 
1242					endif 
1242			      ; Clear the Z flag to indicate successful allocation 
1242 7a			      ld    A, D 
1243 b3			      or    E 
1244			 
1244 d1			      pop   DE                      ; Address of allocation 
1245					if DEBUG_FORTH_MALLOC 
1245						DMARK "MAu" 
1245						CALLMONITOR 
1245					endif 
1245			 
1245			malloc_no_space: 
1245 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1248 39			      add   HL, SP 
1249 f9			      ld    SP, HL 
124a			 
124a eb			      ex    DE, HL                  ; Alloc addr into HL for return 
124b					if DEBUG_FORTH_MALLOC 
124b						DMARK "MAN" 
124b						CALLMONITOR 
124b					endif 
124b			 
124b			malloc_early_exit: 
124b					if DEBUG_FORTH_MALLOC 
124b						DMARK "MAx" 
124b						CALLMONITOR 
124b					endif 
124b dd e1		      pop   IX 
124d d1			      pop   DE 
124e c1			      pop   BC 
124f			 
124f			if DEBUG_FORTH_MALLOC_HIGH 
124f			call malloc_guard_exit 
124f			call malloc_guard_zerolen 
124f			endif 
124f c9			      ret 
1250			 
1250			 
1250			;------------------------------------------------------------------------------ 
1250			;     free                                                                    : 
1250			;                                                                             : 
1250			; Description                                                                 : 
1250			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1250			;     returned by malloc, otherwise the behaviour is undefined.               : 
1250			;                                                                             : 
1250			;     Where possible, directly adjacent free blocks will be merged together   : 
1250			;     into larger blocks to help ensure that the heap does not become         : 
1250			;     excessively fragmented.                                                 : 
1250			;                                                                             : 
1250			;     free does not clear or set any other value into the freed space, and    : 
1250			;     therefore its contents may be visible through subsequent malloc's. The  : 
1250			;     caller should clear the freed space as required.                        : 
1250			;                                                                             : 
1250			;     This implementation of free uses the stack exclusively, and is          : 
1250			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1250			;     advisable to disable interrupts before calling free, and recommended    : 
1250			;     to avoid the use of free inside ISRs in general.                        : 
1250			;                                                                             : 
1250			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1250			;                                                                             : 
1250			; Parameters                                                                  : 
1250			;     HL  Pointer to address of first byte of allocation to be freed          : 
1250			;                                                                             : 
1250			; Returns                                                                     : 
1250			;     Nothing                                                                 : 
1250			;                                                                             : 
1250			; Stack frame                                                                 : 
1250			;       |             |                                                       : 
1250			;       +-------------+                                                       : 
1250			;       |     BC      |                                                       : 
1250			;       +-------------+                                                       : 
1250			;       |     DE      |                                                       : 
1250			;       +-------------+                                                       : 
1250			;       |     IX      |                                                       : 
1250			;       +-------------+                                                       : 
1250			;       |  prev_free  |                                                       : 
1250			;   +2  +-------------+                                                       : 
1250			;       |  next_free  |                                                       : 
1250			;   +0  +-------------+                                                       : 
1250			;       |             |                                                       : 
1250			;                                                                             : 
1250			;------------------------------------------------------------------------------ 
1250			free: 
1250 c5			      push  BC 
1251 d5			      push  DE 
1252 dd e5		      push  IX 
1254			 
1254 7c			      ld    A, H                    ; Exit if ptr is null 
1255 b5			      or    L 
1256 ca 1a 13		      jp    Z, free_early_exit 
1259			 
1259			      ; Set up stack frame 
1259 eb			      ex    DE, HL 
125a 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
125d 39			      add   HL, SP 
125e f9			      ld    SP, HL 
125f dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1263 dd 39		      add   IX, SP 
1265			 
1265			      ; The address in HL points to the start of the useable allocated space, 
1265			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1265			      ; address of the block itself. 
1265 eb			      ex    DE, HL 
1266 11 fc ff		      ld    DE, -4 
1269 19			      add   HL, DE 
126a			 
126a			      ; An allocated block must have a null next block pointer in it 
126a 7e			      ld    A, (HL) 
126b 23			      inc   HL 
126c b6			      or    (HL) 
126d c2 15 13		      jp    NZ, free_done 
1270			 
1270 2b			      dec   HL 
1271			 
1271 44			      ld    B, H                    ; Copy HL to BC 
1272 4d			      ld    C, L 
1273			 
1273			      ; Loop through the free list to find the first block with an address 
1273			      ; higher than the block being freed 
1273 21 0a 80		      ld    HL, free_list 
1276			 
1276			free_find_higher_block: 
1276 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1277 23			      inc   HL 
1278 56			      ld    D, (HL) 
1279 2b			      dec   HL 
127a			 
127a dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
127d dd 72 01		      ld    (IX+1), D 
1280 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1283 dd 74 03		      ld    (IX+3), H 
1286			 
1286 78			      ld    A, B                    ; Check if DE is greater than BC 
1287 ba			      cp    D                       ; Compare MSB first 
1288 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
128a 30 04		      jr    NC, free_find_higher_block_skip 
128c 79			      ld    A, C 
128d bb			      cp    E                       ; Then compare LSB 
128e 38 08		      jr    C, free_found_higher_block 
1290			 
1290			free_find_higher_block_skip: 
1290 7a			      ld    A, D                    ; Reached the end of the free list? 
1291 b3			      or    E 
1292 ca 15 13		      jp    Z, free_done 
1295			 
1295 eb			      ex    DE, HL 
1296			 
1296 18 de		      jr    free_find_higher_block 
1298			 
1298			free_found_higher_block: 
1298			      ; Insert freed block between prev and next free blocks 
1298 71			      ld    (HL), C                 ; Point prev free block to freed block 
1299 23			      inc   HL 
129a 70			      ld    (HL), B 
129b			 
129b 60			      ld    H, B                    ; Point freed block at next free block 
129c 69			      ld    L, C 
129d 73			      ld    (HL), E 
129e 23			      inc   HL 
129f 72			      ld    (HL), D 
12a0			 
12a0			      ; Check if the freed block is adjacent to the next free block 
12a0 23			      inc   HL                      ; Load size of freed block into HL 
12a1 5e			      ld    E, (HL) 
12a2 23			      inc   HL 
12a3 56			      ld    D, (HL) 
12a4 eb			      ex    DE, HL 
12a5			 
12a5 09			      add   HL, BC                  ; Add addr of freed block and its size 
12a6			 
12a6 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12a9 dd 56 01		      ld    D, (IX+1) 
12ac			 
12ac b7			      or    A                       ; Clear the carry flag 
12ad ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12af 20 22		      jr    NZ, free_check_adjacent_to_prev 
12b1			 
12b1			      ; Freed block is adjacent to next, merge into one bigger block 
12b1 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12b2 5e			      ld    E, (HL) 
12b3 23			      inc   HL 
12b4 56			      ld    D, (HL) 
12b5 e5			      push  HL                      ; Save ptr to next block for later 
12b6			 
12b6 60			      ld    H, B                    ; Store ptr from next block into freed block 
12b7 69			      ld    L, C 
12b8 73			      ld    (HL), E 
12b9 23			      inc   HL 
12ba 72			      ld    (HL), D 
12bb			 
12bb e1			      pop   HL                      ; Restore ptr to next block 
12bc 23			      inc   HL                      ; Load size of next block into DE 
12bd 5e			      ld    E, (HL) 
12be 23			      inc   HL 
12bf 56			      ld    D, (HL) 
12c0 d5			      push  DE                      ; Save next block size for later 
12c1			 
12c1 60			      ld    H, B                    ; Load size of freed block into HL 
12c2 69			      ld    L, C 
12c3 23			      inc   HL 
12c4 23			      inc   HL 
12c5 5e			      ld    E, (HL) 
12c6 23			      inc   HL 
12c7 56			      ld    D, (HL) 
12c8 eb			      ex    DE, HL 
12c9			 
12c9 d1			      pop   DE                      ; Restore size of next block 
12ca 19			      add   HL, DE                  ; Add sizes of both blocks 
12cb eb			      ex    DE, HL 
12cc			 
12cc 60			      ld    H, B                    ; Store new bigger size into freed block 
12cd 69			      ld    L, C 
12ce 23			      inc   HL 
12cf 23			      inc   HL 
12d0 73			      ld    (HL), E 
12d1 23			      inc   HL 
12d2 72			      ld    (HL), D 
12d3			 
12d3			free_check_adjacent_to_prev: 
12d3			      ; Check if the freed block is adjacent to the prev free block 
12d3 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
12d6 dd 66 03		      ld    H, (IX+3) 
12d9			 
12d9 23			      inc   HL                      ; Size of prev free block into DE 
12da 23			      inc   HL 
12db 5e			      ld    E, (HL) 
12dc 23			      inc   HL 
12dd 56			      ld    D, (HL) 
12de 2b			      dec   HL 
12df 2b			      dec   HL 
12e0 2b			      dec   HL 
12e1			 
12e1 19			      add   HL, DE                  ; Add prev block addr and size 
12e2			 
12e2 b7			      or    A                       ; Clear the carry flag 
12e3 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
12e5 20 2e		      jr    NZ, free_done 
12e7			 
12e7			      ; Freed block is adjacent to prev, merge into one bigger block 
12e7 60			      ld    H, B                    ; Load next ptr from freed block into DE 
12e8 69			      ld    L, C 
12e9 5e			      ld    E, (HL) 
12ea 23			      inc   HL 
12eb 56			      ld    D, (HL) 
12ec e5			      push  HL                      ; Save freed block ptr for later 
12ed			 
12ed dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
12f0 dd 66 03		      ld    H, (IX+3) 
12f3 73			      ld    (HL), E 
12f4 23			      inc   HL 
12f5 72			      ld    (HL), D 
12f6			 
12f6 e1			      pop   HL                      ; Restore freed block ptr 
12f7 23			      inc   HL                      ; Load size of freed block into DE 
12f8 5e			      ld    E, (HL) 
12f9 23			      inc   HL 
12fa 56			      ld    D, (HL) 
12fb d5			      push  DE                      ; Save freed block size for later 
12fc			 
12fc dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
12ff dd 66 03		      ld    H, (IX+3) 
1302 23			      inc   HL 
1303 23			      inc   HL 
1304 5e			      ld    E, (HL) 
1305 23			      inc   HL 
1306 56			      ld    D, (HL) 
1307			 
1307 e1			      pop   HL                      ; Add sizes of both blocks 
1308 19			      add   HL, DE 
1309 eb			      ex    DE, HL 
130a			 
130a dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
130d dd 66 03		      ld    H, (IX+3) 
1310 23			      inc   HL 
1311 23			      inc   HL 
1312 73			      ld    (HL), E 
1313 23			      inc   HL 
1314 72			      ld    (HL), D 
1315			 
1315			free_done: 
1315 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1318 39			      add   HL, SP 
1319 f9			      ld    SP, HL 
131a			 
131a			free_early_exit: 
131a dd e1		      pop   IX 
131c d1			      pop   DE 
131d c1			      pop   BC 
131e			 
131e c9			      ret 
131f			 
131f			; moved to firmware.asm 
131f			; 
131f			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
131f			;                  .dw   0 
131f			 
131f			 
131f			endif 
131f			 
131f			 
131f			if MALLOC_3 
131f			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
131f			;heap_start        .equ  0x9000      ; Starting address of heap 
131f			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
131f			; 
131f			 ;     .org 0 
131f			  ;    jp    main 
131f			; 
131f			; 
131f			 ;     .org  0x100 
131f			;main: 
131f			 ;     ld    HL, 0x8100 
131f			  ;    ld    SP, HL 
131f			; 
131f			;      call  heap_init 
131f			 
131f			      ; Make some allocations 
131f			;      ld    HL, 12 
131f			;      call  malloc            ; Allocates 0x9004 
131f			; 
131f			 ;     ld    HL, 12 
131f			;      call  malloc            ; Allocates 0x9014 
131f			 
131f			;      ld    HL, 12 
131f			;      call  malloc            ; Allocates 0x9024 
131f			 
131f			      ; Free some allocations 
131f			;      ld    HL, 0x9014 
131f			;      call  free 
131f			 
131f			;      ld    HL, 0x9004 
131f			;      call  free 
131f			; 
131f			;      ld    HL, 0x9024 
131f			;      call  free 
131f			 
131f			 
131f			 ;     halt 
131f			 
131f			 
131f			;------------------------------------------------------------------------------ 
131f			;     heap_init                                                               : 
131f			;                                                                             : 
131f			; Description                                                                 : 
131f			;     Initialise the heap and make it ready for malloc and free operations.   : 
131f			;                                                                             : 
131f			;     The heap is maintained as a linked list, starting with an initial       : 
131f			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
131f			;     the first free block in the heap. Each block then points to the next    : 
131f			;     free block within the heap, and the free list ends at the first block   : 
131f			;     with a null pointer to the next free block.                             : 
131f			;                                                                             : 
131f			; Parameters                                                                  : 
131f			;     Inputs are compile-time only. Two defines which specify the starting    : 
131f			;     address of the heap and its size are required, along with a memory      : 
131f			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
131f			;     principally stores a pointer to the first free block in the heap.       : 
131f			;                                                                             : 
131f			; Returns                                                                     : 
131f			;     Nothing                                                                 : 
131f			;------------------------------------------------------------------------------ 
131f			heap_init: 
131f			      push  HL 
131f			 
131f			      ; Initialise free list struct 
131f			      ld    HL, heap_start 
131f			      ld    (free_list), HL 
131f			      ld    HL, 0 
131f			      ld    (free_list+2), HL 
131f			 
131f			      ; Insert first free block at bottom of heap, consumes entire heap 
131f			      ld    HL, heap_start+heap_size-4 
131f			      ld    (heap_start), HL        ; Next block (end of free list) 
131f			      ld    HL, heap_size-4 
131f			      ld    (heap_start+2), HL      ; Block size 
131f			 
131f			      ; Insert end of free list block at top of heap - two null words will 
131f			      ; terminate the free list 
131f			      ld    HL, 0 
131f			      ld    (heap_start+heap_size-2), HL 
131f			      ld    (heap_start+heap_size-4), HL 
131f			 
131f			      pop   HL 
131f			 
131f			      ret 
131f			 
131f			 
131f			;------------------------------------------------------------------------------ 
131f			;     malloc                                                                  : 
131f			;                                                                             : 
131f			; Description                                                                 : 
131f			;     Allocates the wanted space from the heap and returns the address of the : 
131f			;     first useable byte of the allocation.                                   : 
131f			;                                                                             : 
131f			;     Allocations can happen in one of two ways:                              : 
131f			;                                                                             : 
131f			;     1. A free block may be found which is the exact size wanted. In this    : 
131f			;        case the block is removed from the free list and retuedn to the      : 
131f			;        caller.                                                              : 
131f			;     2. A free block may be found which is larger than the size wanted. In   : 
131f			;        this case, the larger block is split into two. The first portion of  : 
131f			;        this block will become the requested space by the malloc call and    : 
131f			;        is returned to the caller. The second portion becomes a new free     : 
131f			;        block, and the free list is adjusted to maintain continuity via this : 
131f			;        newly created block.                                                 : 
131f			;                                                                             : 
131f			;     malloc does not set any initial value in the allocated space, the       : 
131f			;     caller is required to do this as required.                              : 
131f			;                                                                             : 
131f			;     This implementation of malloc uses the stack exclusively, and is        : 
131f			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
131f			;     advisable to disable interrupts before calling malloc, and recommended  : 
131f			;     to avoid the use of malloc inside ISRs in general.                      : 
131f			;                                                                             : 
131f			;     NOTE: heap_init must be called before malloc and free can be used.      : 
131f			;                                                                             : 
131f			; Parameters                                                                  : 
131f			;     HL  Number of bytes wanted                                              : 
131f			;                                                                             : 
131f			; Returns                                                                     : 
131f			;     HL  Address of the first useable byte of the allocation                 : 
131f			;                                                                             : 
131f			; Flags                                                                       : 
131f			;     Z   Set if the allocation did not succeed, clear otherwise              : 
131f			;                                                                             : 
131f			; Stack frame                                                                 : 
131f			;       |             |                                                       : 
131f			;       +-------------+                                                       : 
131f			;       |     BC      |                                                       : 
131f			;       +-------------+                                                       : 
131f			;       |     DE      |                                                       : 
131f			;       +-------------+                                                       : 
131f			;       |     IX      |                                                       : 
131f			;       +-------------+                                                       : 
131f			;       |  prev_free  |                                                       : 
131f			;   +4  +-------------+                                                       : 
131f			;       |  this_free  |                                                       : 
131f			;   +2  +-------------+                                                       : 
131f			;       |  next_free  |                                                       : 
131f			;   +0  +-------------+                                                       : 
131f			;       |             |                                                       : 
131f			;                                                                             : 
131f			;------------------------------------------------------------------------------ 
131f			malloc: 
131f			      push  BC 
131f			      push  DE 
131f			      push  IX 
131f			 
131f			      ld    A, H                    ; Exit if no space requested 
131f			      or    L 
131f			      jp    Z, malloc_early_exit 
131f			 
131f			      ; Set up stack frame 
131f			      ex    DE, HL 
131f			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
131f			      add   HL, SP 
131f			      ld    SP, HL 
131f			      ld    IX, 0                   ; Use IX as a frame pointer 
131f			      add   IX, SP 
131f			 
131f			      ; Setup initial state 
131f			      ld    HL, 4                   ; want must also include space used by block struct 
131f			      add   HL, DE 
131f			 
131f			      ld    B, H                    ; Move want to BC 
131f			      ld    C, L 
131f			 
131f			      ld    HL, free_list           ; Store prev_free ptr to stack 
131f			      ld    (IX+4), L 
131f			      ld    (IX+5), H 
131f			 
131f			      ld    E, (HL)                 ; Store this_free ptr to stack 
131f			      inc   HL 
131f			      ld    D, (HL) 
131f			      ld    (IX+2), E 
131f			      ld    (IX+3), D 
131f			      ex    DE, HL                  ; this_free ptr into HL 
131f			 
131f			      ; Loop through free block list to find some space 
131f			malloc_find_space: 
131f			      ld    E, (HL)                 ; Load next_free ptr into DE 
131f			      inc   HL 
131f			      ld    D, (HL) 
131f			 
131f			      ld    A, D                    ; Check for null next_free ptr - end of free list 
131f			      or    E 
131f			      jp    Z, malloc_no_space 
131f			 
131f			      ld    (IX+0), E               ; Store next_free ptr to stack 
131f			      ld    (IX+1), D 
131f			 
131f			      ; Does this block have enough space to make the allocation? 
131f			      inc   HL                      ; Load free block size into DE 
131f			      ld    E, (HL) 
131f			      inc   HL 
131f			      ld    D, (HL) 
131f			 
131f			      ex    DE, HL                  ; Check size of block against want 
131f			      or    A                       ; Ensure carry flag clear 
131f			      sbc   HL, BC 
131f			      push  HL                      ; Store the result for later (new block size) 
131f			 
131f			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
131f			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
131f			 
131f			      ; this_free block is not big enough, setup ptrs to test next free block 
131f			      pop   HL                      ; Discard previous result 
131f			 
131f			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
131f			      ld    H, (IX+3) 
131f			      ld    (IX+4), L 
131f			      ld    (IX+5), H 
131f			 
131f			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
131f			      ld    H, (IX+1) 
131f			      ld    (IX+2), L 
131f			      ld    (IX+3), H 
131f			 
131f			      jr    malloc_find_space 
131f			 
131f			      ; split a bigger block into two - requested size and remaining size 
131f			malloc_alloc_split: 
131f			      ex    DE, HL                  ; Calculate address of new free block 
131f			      dec   HL 
131f			      dec   HL 
131f			      dec   HL 
131f			      add   HL, BC 
131f			 
131f			      ; Create a new block and point it at next_free 
131f			      ld    E, (IX+0)               ; Load next_free ptr into DE 
131f			      ld    D, (IX+1) 
131f			 
131f			      ld    (HL), E                 ; Store next_free ptr into new block 
131f			      inc   HL 
131f			      ld    (HL), D 
131f			 
131f			      pop   DE                      ; Store size of new block into new block 
131f			      inc   HL 
131f			      ld    (HL), E 
131f			      inc   HL 
131f			      ld    (HL), D 
131f			 
131f			      ; Update this_free ptr to point to new block 
131f			      dec   HL 
131f			      dec   HL 
131f			      dec   HL 
131f			 
131f			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
131f			      ld    D, (IX+3) 
131f			 
131f			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
131f			      ld    (IX+3), H 
131f			 
131f			      ; Modify this_free block to be allocation 
131f			      ex    DE, HL 
131f			      xor   A                       ; Null the next block ptr of allocated block 
131f			      ld    (HL), A 
131f			      inc   HL 
131f			      ld    (HL), A 
131f			 
131f			      inc   HL                      ; Store want size into allocated block 
131f			      ld    (HL), C 
131f			      inc   HL 
131f			      ld    (HL), B 
131f			      inc   HL 
131f			      push  HL                      ; Address of allocation to return 
131f			 
131f			      jr    malloc_update_links 
131f			 
131f			malloc_alloc_fit: 
131f			      pop   HL                      ; Dont need new block size, want is exact fit 
131f			 
131f			      ; Modify this_free block to be allocation 
131f			      ex    DE, HL 
131f			      dec   HL 
131f			      dec   HL 
131f			      dec   HL 
131f			 
131f			      xor   A                       ; Null the next block ptr of allocated block 
131f			      ld    (HL), A 
131f			      inc   HL 
131f			      ld    (HL), A 
131f			 
131f			      inc   HL                      ; Store address of allocation to return 
131f			      inc   HL 
131f			      inc   HL 
131f			      push  HL 
131f			 
131f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
131f			      ld    L, (IX+0)               ; next_free to HL 
131f			      ld    H, (IX+1) 
131f			 
131f			      ld    (IX+2), L               ; HL to this_free 
131f			      ld    (IX+3), H 
131f			 
131f			 
131f			malloc_update_links: 
131f			      ; Update prev_free ptr to point to this_free 
131f			      ld    L, (IX+4)               ; prev_free ptr to HL 
131f			      ld    H, (IX+5) 
131f			 
131f			      ld    E, (IX+2)               ; this_free ptr to DE 
131f			      ld    D, (IX+3) 
131f			 
131f			      ld    (HL), E                 ; this_free ptr into prev_free 
131f			      inc   HL 
131f			      ld    (HL), D 
131f			 
131f			      ; Clear the Z flag to indicate successful allocation 
131f			      ld    A, D 
131f			      or    E 
131f			 
131f			      pop   DE                      ; Address of allocation 
131f			 
131f			malloc_no_space: 
131f			      ld    HL, 6                   ; Clean up stack frame 
131f			      add   HL, SP 
131f			      ld    SP, HL 
131f			 
131f			      ex    DE, HL                  ; Alloc addr into HL for return 
131f			 
131f			malloc_early_exit: 
131f			      pop   IX 
131f			      pop   DE 
131f			      pop   BC 
131f			 
131f			      ret 
131f			 
131f			 
131f			;------------------------------------------------------------------------------ 
131f			;     free                                                                    : 
131f			;                                                                             : 
131f			; Description                                                                 : 
131f			;     Return the space pointed to by HL to the heap. HL must be an address as : 
131f			;     returned by malloc, otherwise the behaviour is undefined.               : 
131f			;                                                                             : 
131f			;     Where possible, directly adjacent free blocks will be merged together   : 
131f			;     into larger blocks to help ensure that the heap does not become         : 
131f			;     excessively fragmented.                                                 : 
131f			;                                                                             : 
131f			;     free does not clear or set any other value into the freed space, and    : 
131f			;     therefore its contents may be visible through subsequent malloc's. The  : 
131f			;     caller should clear the freed space as required.                        : 
131f			;                                                                             : 
131f			;     This implementation of free uses the stack exclusively, and is          : 
131f			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
131f			;     advisable to disable interrupts before calling free, and recommended    : 
131f			;     to avoid the use of free inside ISRs in general.                        : 
131f			;                                                                             : 
131f			;     NOTE: heap_init must be called before malloc and free can be used.      : 
131f			;                                                                             : 
131f			; Parameters                                                                  : 
131f			;     HL  Pointer to address of first byte of allocation to be freed          : 
131f			;                                                                             : 
131f			; Returns                                                                     : 
131f			;     Nothing                                                                 : 
131f			;                                                                             : 
131f			; Stack frame                                                                 : 
131f			;       |             |                                                       : 
131f			;       +-------------+                                                       : 
131f			;       |     BC      |                                                       : 
131f			;       +-------------+                                                       : 
131f			;       |     DE      |                                                       : 
131f			;       +-------------+                                                       : 
131f			;       |     IX      |                                                       : 
131f			;       +-------------+                                                       : 
131f			;       |  prev_free  |                                                       : 
131f			;   +2  +-------------+                                                       : 
131f			;       |  next_free  |                                                       : 
131f			;   +0  +-------------+                                                       : 
131f			;       |             |                                                       : 
131f			;                                                                             : 
131f			;------------------------------------------------------------------------------ 
131f			free: 
131f			      push  BC 
131f			      push  DE 
131f			      push  IX 
131f			 
131f			      ld    A, H                    ; Exit if ptr is null 
131f			      or    L 
131f			      jp    Z, free_early_exit 
131f			 
131f			      ; Set up stack frame 
131f			      ex    DE, HL 
131f			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
131f			      add   HL, SP 
131f			      ld    SP, HL 
131f			      ld    IX, 0                   ; Use IX as a frame pointer 
131f			      add   IX, SP 
131f			 
131f			      ; The address in HL points to the start of the useable allocated space, 
131f			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
131f			      ; address of the block itself. 
131f			      ex    DE, HL 
131f			      ld    DE, -4 
131f			      add   HL, DE 
131f			 
131f			      ; An allocated block must have a null next block pointer in it 
131f			      ld    A, (HL) 
131f			      inc   HL 
131f			      or    (HL) 
131f			      jp    NZ, free_done 
131f			 
131f			      dec   HL 
131f			 
131f			      ld    B, H                    ; Copy HL to BC 
131f			      ld    C, L 
131f			 
131f			      ; Loop through the free list to find the first block with an address 
131f			      ; higher than the block being freed 
131f			      ld    HL, free_list 
131f			 
131f			free_find_higher_block: 
131f			      ld    E, (HL)                 ; Load next ptr from free block 
131f			      inc   HL 
131f			      ld    D, (HL) 
131f			      dec   HL 
131f			 
131f			      ld    (IX+0), E               ; Save ptr to next free block 
131f			      ld    (IX+1), D 
131f			      ld    (IX+2), L               ; Save ptr to prev free block 
131f			      ld    (IX+3), H 
131f			 
131f			      ld    A, B                    ; Check if DE is greater than BC 
131f			      cp    D                       ; Compare MSB first 
131f			      jr    Z, $+4                  ; MSB the same, compare LSB 
131f			      jr    NC, free_find_higher_block_skip 
131f			      ld    A, C 
131f			      cp    E                       ; Then compare LSB 
131f			      jr    C, free_found_higher_block 
131f			 
131f			free_find_higher_block_skip: 
131f			      ld    A, D                    ; Reached the end of the free list? 
131f			      or    E 
131f			      jp    Z, free_done 
131f			 
131f			      ex    DE, HL 
131f			 
131f			      jr    free_find_higher_block 
131f			 
131f			free_found_higher_block: 
131f			      ; Insert freed block between prev and next free blocks 
131f			      ld    (HL), C                 ; Point prev free block to freed block 
131f			      inc   HL 
131f			      ld    (HL), B 
131f			 
131f			      ld    H, B                    ; Point freed block at next free block 
131f			      ld    L, C 
131f			      ld    (HL), E 
131f			      inc   HL 
131f			      ld    (HL), D 
131f			 
131f			      ; Check if the freed block is adjacent to the next free block 
131f			      inc   HL                      ; Load size of freed block into HL 
131f			      ld    E, (HL) 
131f			      inc   HL 
131f			      ld    D, (HL) 
131f			      ex    DE, HL 
131f			 
131f			      add   HL, BC                  ; Add addr of freed block and its size 
131f			 
131f			      ld    E, (IX+0)               ; Load addr of next free block into DE 
131f			      ld    D, (IX+1) 
131f			 
131f			      or    A                       ; Clear the carry flag 
131f			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
131f			      jr    NZ, free_check_adjacent_to_prev 
131f			 
131f			      ; Freed block is adjacent to next, merge into one bigger block 
131f			      ex    DE, HL                  ; Load next ptr from next block into DE 
131f			      ld    E, (HL) 
131f			      inc   HL 
131f			      ld    D, (HL) 
131f			      push  HL                      ; Save ptr to next block for later 
131f			 
131f			      ld    H, B                    ; Store ptr from next block into freed block 
131f			      ld    L, C 
131f			      ld    (HL), E 
131f			      inc   HL 
131f			      ld    (HL), D 
131f			 
131f			      pop   HL                      ; Restore ptr to next block 
131f			      inc   HL                      ; Load size of next block into DE 
131f			      ld    E, (HL) 
131f			      inc   HL 
131f			      ld    D, (HL) 
131f			      push  DE                      ; Save next block size for later 
131f			 
131f			      ld    H, B                    ; Load size of freed block into HL 
131f			      ld    L, C 
131f			      inc   HL 
131f			      inc   HL 
131f			      ld    E, (HL) 
131f			      inc   HL 
131f			      ld    D, (HL) 
131f			      ex    DE, HL 
131f			 
131f			      pop   DE                      ; Restore size of next block 
131f			      add   HL, DE                  ; Add sizes of both blocks 
131f			      ex    DE, HL 
131f			 
131f			      ld    H, B                    ; Store new bigger size into freed block 
131f			      ld    L, C 
131f			      inc   HL 
131f			      inc   HL 
131f			      ld    (HL), E 
131f			      inc   HL 
131f			      ld    (HL), D 
131f			 
131f			free_check_adjacent_to_prev: 
131f			      ; Check if the freed block is adjacent to the prev free block 
131f			      ld    L, (IX+2)               ; Prev free block ptr into HL 
131f			      ld    H, (IX+3) 
131f			 
131f			      inc   HL                      ; Size of prev free block into DE 
131f			      inc   HL 
131f			      ld    E, (HL) 
131f			      inc   HL 
131f			      ld    D, (HL) 
131f			      dec   HL 
131f			      dec   HL 
131f			      dec   HL 
131f			 
131f			      add   HL, DE                  ; Add prev block addr and size 
131f			 
131f			      or    A                       ; Clear the carry flag 
131f			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
131f			      jr    NZ, free_done 
131f			 
131f			      ; Freed block is adjacent to prev, merge into one bigger block 
131f			      ld    H, B                    ; Load next ptr from freed block into DE 
131f			      ld    L, C 
131f			      ld    E, (HL) 
131f			      inc   HL 
131f			      ld    D, (HL) 
131f			      push  HL                      ; Save freed block ptr for later 
131f			 
131f			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
131f			      ld    H, (IX+3) 
131f			      ld    (HL), E 
131f			      inc   HL 
131f			      ld    (HL), D 
131f			 
131f			      pop   HL                      ; Restore freed block ptr 
131f			      inc   HL                      ; Load size of freed block into DE 
131f			      ld    E, (HL) 
131f			      inc   HL 
131f			      ld    D, (HL) 
131f			      push  DE                      ; Save freed block size for later 
131f			 
131f			      ld    L, (IX+2)               ; Load size of prev block into DE 
131f			      ld    H, (IX+3) 
131f			      inc   HL 
131f			      inc   HL 
131f			      ld    E, (HL) 
131f			      inc   HL 
131f			      ld    D, (HL) 
131f			 
131f			      pop   HL                      ; Add sizes of both blocks 
131f			      add   HL, DE 
131f			      ex    DE, HL 
131f			 
131f			      ld    L, (IX+2)               ; Store new bigger size into prev block 
131f			      ld    H, (IX+3) 
131f			      inc   HL 
131f			      inc   HL 
131f			      ld    (HL), E 
131f			      inc   HL 
131f			      ld    (HL), D 
131f			 
131f			free_done: 
131f			      ld    HL, 4                   ; Clean up stack frame 
131f			      add   HL, SP 
131f			      ld    SP, HL 
131f			 
131f			free_early_exit: 
131f			      pop   IX 
131f			      pop   DE 
131f			      pop   BC 
131f			 
131f			      ret 
131f			 
131f			 
131f			;      .org 0x8000 
131f			; 
131f			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
131f			 ;                 .dw   0 
131f			 
131f			endif 
131f			 
131f			 
131f			if MALLOC_4 
131f			 
131f			; My memory allocation code. Very very simple.... 
131f			; allocate space under 250 chars 
131f			 
131f			heap_init: 
131f				; init start of heap as zero 
131f				;  
131f			 
131f				ld hl, heap_start 
131f				ld a, 0 
131f				ld (hl), a      ; empty block 
131f				inc hl 
131f				ld a, 0 
131f				ld (hl), a      ; length of block 
131f				; write end of list 
131f				inc hl 
131f				ld a,(hl) 
131f				inc hl 
131f				ld a,(hl) 
131f				 
131f			 
131f				; init some malloc vars 
131f			 
131f				ld hl, 0 
131f				ld (free_list), hl       ; store last malloc location 
131f			 
131f				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
131f				ld a, 0 
131f				ld (hl), a 
131f			 
131f			 
131f				ld hl, heap_start 
131f				;  
131f				  
131f				ret 
131f			 
131f			 
131f			;    free block marker 
131f			;    requested size  
131f			;    pointer to next block 
131f			;    .... 
131f			;    next block marker 
131f			 
131f			 
131f			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
131f			; 
131f			 
131f			 
131f			malloc:  
131f				push de 
131f				push bc 
131f				push af 
131f			 
131f				; hl space required 
131f				 
131f				ld c, l    ; hold space   (TODO only a max of 255) 
131f			 
131f			;	inc c     ; TODO BUG need to fix memory leak on push str 
131f			;	inc c 
131f			;	inc c 
131f			;	inc c 
131f			;	inc c 
131f			;	inc c 
131f			;	inc c 
131f			 
131f			 
131f			 
131f				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
131f			 
131f				ld a, (free_list+3) 
131f				cp 0 
131f				jr z, .contheap 
131f			 
131f				ld hl, (free_list)     ; get last alloc 
131f					if DEBUG_FORTH_MALLOC_INT 
131f						DMARK "mrs" 
131f						CALLMONITOR 
131f					endif 
131f				jr .startalloc 
131f			 
131f			.contheap: 
131f				ld hl, heap_start 
131f			 
131f			.startalloc: 
131f			 
131f					if DEBUG_FORTH_MALLOC_INT 
131f						DMARK "mym" 
131f						CALLMONITOR 
131f					endif 
131f			.findblock: 
131f					if DEBUG_FORTH_MALLOC_INT 
131f						DMARK "mmf" 
131f						CALLMONITOR 
131f					endif 
131f			 
131f				ld a,(hl)  
131f				; if byte is zero then clear to use 
131f			 
131f				cp 0 
131f				jr z, .foundemptyblock 
131f			 
131f				; if byte is not clear 
131f				;     then byte is offset to next block 
131f			 
131f				inc hl 
131f				ld a, (hl) ; get size 
131f			.nextblock:	inc hl 
131f					ld e, (hl) 
131f					inc hl 
131f					ld d, (hl) 
131f					ex de, hl 
131f			;	inc hl  ; move past the store space 
131f			;	inc hl  ; move past zero index  
131f			 
131f				; TODO detect no more space 
131f			 
131f				push hl 
131f				ld de, heap_end 
131f				call cmp16 
131f				pop hl 
131f				jr nc, .nospace 
131f			 
131f				jr .findblock 
131f			 
131f			.nospace: ld hl, 0 
131f				jp .exit 
131f			 
131f			 
131f			.foundemptyblock:	 
131f					if DEBUG_FORTH_MALLOC_INT 
131f						DMARK "mme" 
131f						CALLMONITOR 
131f					endif 
131f			 
131f			; TODO has block enough space if reusing??? 
131f			 
131f				;  
131f			 
131f			; see if this block has been previously used 
131f				inc hl 
131f				ld a, (hl) 
131f				dec hl 
131f				cp 0 
131f				jr z, .newblock 
131f			 
131f					if DEBUG_FORTH_MALLOC_INT 
131f						DMARK "meR" 
131f						CALLMONITOR 
131f					endif 
131f			 
131f			; no reusing previously allocated block 
131f			 
131f			; is it smaller than previously used? 
131f				 
131f				inc hl    ; move to size 
131f				ld a, c 
131f				sub (hl)        ; we want c < (hl) 
131f				dec hl    ; move back to marker 
131f			        jr z, .findblock 
131f			 
131f				; update with the new size which should be lower 
131f			 
131f			        ;inc  hl   ; negate next move. move back to size  
131f			 
131f			.newblock: 
131f				; need to be at marker here 
131f			 
131f					if DEBUG_FORTH_MALLOC_INT 
131f						DMARK "meN" 
131f						CALLMONITOR 
131f					endif 
131f			 
131f			 
131f				ld a, c 
131f			 
131f				ld (free_list+3), a	 ; flag resume from last malloc  
131f				ld (free_list), hl    ; save out last location 
131f			 
131f			 
131f				;inc a     ; space for length byte 
131f				ld (hl), a     ; save block in use marker 
131f			 
131f				inc hl   ; move to space marker 
131f				ld (hl), a    ; save new space 
131f			 
131f				inc hl   ; move to start of allocated area 
131f				 
131f			;	push hl     ; save where we are - 1  
131f			 
131f			;	inc hl  ; move past zero index  
131f				; skip space to set down new marker 
131f			 
131f				; provide some extra space for now 
131f			 
131f				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
131f				inc a 
131f				inc a 
131f			 
131f				push hl   ; save where we are in the node block 
131f			 
131f				call addatohl 
131f			 
131f				; write linked list point 
131f			 
131f				pop de     ; get our node position 
131f				ex de, hl 
131f			 
131f				ld (hl), e 
131f				inc hl 
131f				ld (hl), d 
131f			 
131f				inc hl 
131f			 
131f				; now at start of allocated data so save pointer 
131f			 
131f				push hl 
131f			 
131f				; jump to position of next node and setup empty header in DE 
131f			 
131f				ex de, hl 
131f			 
131f			;	inc hl ; move past end of block 
131f			 
131f				ld a, 0 
131f				ld (hl), a   ; empty marker 
131f				inc hl 
131f				ld (hl), a   ; size 
131f				inc hl  
131f				ld (hl), a   ; ptr 
131f				inc hl 
131f				ld (hl), a   ; ptr 
131f			 
131f			 
131f				pop hl 
131f			 
131f					if DEBUG_FORTH_MALLOC_INT 
131f						DMARK "mmr" 
131f						CALLMONITOR 
131f					endif 
131f			 
131f			.exit: 
131f				pop af 
131f				pop bc 
131f				pop de  
131f				ret 
131f			 
131f			 
131f			 
131f			 
131f			free:  
131f				push hl 
131f				push af 
131f				; get address in hl 
131f			 
131f					if DEBUG_FORTH_MALLOC_INT 
131f						DMARK "fre" 
131f						CALLMONITOR 
131f					endif 
131f				; data is at hl - move to block count 
131f				dec hl 
131f				dec hl    ; get past pointer 
131f				dec hl 
131f			 
131f				ld a, (hl)    ; need this for a validation check 
131f			 
131f				dec hl    ; move to block marker 
131f			 
131f				; now check that the block count and block marker are the same  
131f			        ; this checks that we are on a malloc node and not random memory 
131f			        ; OK a faint chance this could be a problem but rare - famous last words! 
131f			 
131f				ld c, a 
131f				ld a, (hl)    
131f			 
131f				cp c 
131f				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
131f			 
131f				; yes good chance we are on a malloc node 
131f			 
131f				ld a, 0      
131f				ld (hl), a   ; mark as free 
131f			 
131f				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
131f			 
131f			.freeignore:  
131f			 
131f				pop af 
131f				pop hl 
131f			 
131f				ret 
131f			 
131f			 
131f			 
131f			endif 
131f			 
131f			; eof 
# End of file firmware_memory.asm
131f			  
131f			; device C  
131f			if SOUND_ENABLE  
131f				include "firmware_sound.asm"  
131f			; Sound abstraction layer 
131f			 
131f			; support different sound chips through common interface 
131f			 
131f			SOUND_DEVICE_AY: equ 0 
131f			 
131f			SOUND_DEVICE: equ Device_A 
131f			 
131f			 
131f			 
131f			if SOUND_DEVICE_AY 
131f				include "firmware_sound_ay38910.asm" 
131f			else 
131f				include "firmware_sound_sn76489an.asm" 
131f			 
131f			; Device support for SN76489AN sound chip 
131f			 
131f			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
131f			; http://danceswithferrets.org/geekblog/?p=93 
131f			; https://www.smspower.org/Development/SN76489 
131f			 
131f			; D0 [ 3] 
131f			; D1 [ 2] 
131f			; D2 [ 1] 
131f			; D3 [15] 
131f			; D4 [13] 
131f			; D5 [12] 
131f			; D6 [11] 
131f			; D7 [10] 
131f			; /WE [ 5] 
131f			; CLK [14] 
131f			; /OE [ 6] 
131f			; AUDIO [ 7] 
131f			; GND 8 
131f			; +5 16 
131f			; 
131f			 
131f			; Write sequence: 
131f			; CE low 
131f			; Data bus 
131f			; WE low then high 
131f			; 32 clock cycles / 8ns write time at 4mhz 
131f			; 
131f			; https://github.com/jblang/SN76489 
131f			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
131f			; Tried: 
131f			; 
131f			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
131f			; 
131f			; Connected WE to OR too 
131f			;  
131f			; That enabled the clock when required 
131f			; However still random bus corruption. Need further investigation 
131f			 
131f			 
131f			SOUND_LATCH: equ 10000000B 
131f			SOUND_DATA: equ 0B 
131f			SOUND_CH0:  equ 0B    ; Tone 
131f			SOUND_CH1: equ 0100000B        ; Tone 
131f			SOUND_CH2: equ 1000000B   ; Tone 
131f			SOUND_CH3: equ 1100000B    ; Noise 
131f			SOUND_VOL: equ 10000B 
131f			SOUND_TONE: equ 0B 
131f			 
131f			 
131f			sound_init: 
131f 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
1321 cd 36 13			call note_send_byte 
1324 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
1326 cd 36 13			call note_send_byte 
1329 cd 31 0a			call delay250ms 
132c 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
132e cd 36 13			call note_send_byte 
1331 cd 31 0a			call delay250ms 
1334 c9				ret 
1335			 
1335			; Play a note 
1335			; h = note 
1335			; l = duration 
1335			; a = channel 
1335			 
1335			 
1335			;  frequ = clock / ( 2 x reg valu x 32 )  
1335			 
1335			note:  
1335				 
1335			 
1335 c9				ret 
1336			 
1336			note_send_byte: 
1336				; byte in a 
1336			 
1336				; we high 
1336 d3 40			out (Device_B), a 
1338			;	ld a, 1 
1338			;	call aDelayInMS 
1338 00				nop  
1339 00				nop  
133a 00				nop  
133b 00				nop  
133c				; we low 
133c d3 40			out (Device_B), a 
133e			;	ld a, 1 
133e			;	call aDelayInMS 
133e 00				nop  
133f 00				nop  
1340 00				nop  
1341 00				nop  
1342				; we high 
1342 d3 40			out (Device_B), a 
1344			;	ld a, 1 
1344			;	call aDelayInMS 
1344 00				nop  
1345 00				nop  
1346 00				nop  
1347 00				nop  
1348			 
1348			 
1348 c9				ret 
1349			 
1349			;void SilenceAllChannels() 
1349			;{ 
1349			;  SendByte(0x9f); 
1349			;  SendByte(0xbf); 
1349			;  SendByte(0xdf); 
1349			;  SendByte(0xff); 
1349			;} 
1349			 
1349			 
1349			; eof 
1349			 
# End of file firmware_sound_sn76489an.asm
1349			endif 
1349			 
1349			 
1349			; Abstraction entry points 
1349			 
1349			; init  
1349			 
1349			; sound_init in specific hardware files 
1349			 
1349			; Play a note 
1349			; h = note 
1349			; l = duration 
1349			; a = channel 
1349			 
1349			;note:     
1349			;	ret 
1349			 
1349			 
1349			 
1349			 
1349			; eof 
1349			 
# End of file firmware_sound.asm
1349			endif  
1349			  
1349			include "firmware_diags.asm"  
1349			; Hardware diags menu 
1349			 
1349			 
1349			config: 
1349			 
1349 3e 00			ld a, 0 
134b 21 5b 13			ld hl, .configmn 
134e cd c0 0a			call menu 
1351			 
1351 fe 00			cp 0 
1353 c8				ret z 
1354			 
1354 fe 04			cp 4 
1356 cc d3 13			call z, hardware_diags 
1359			 
1359 18 ee			jr config 
135b			 
135b			.configmn: 
135b 65 13			dw .c3 
135d 80 13			dw .c2 
135f 95 13			dw .c4 
1361 9e 13			dw .c1 
1363 00 00			dw 0 
1365				 
1365			 
1365 .. 00		.c3: db "Save User Words To Storage",0 
1380 .. 00		.c2: db "Select Autoload File",0 
1395 .. 00		.c4: db "Settings",0 
139e .. 00		.c1: db "Hardware Diags",0 
13ad			 
13ad			 
13ad			; Settings 
13ad			; Run  
13ad			 
13ad			 
13ad			 
13ad			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
13ad			;;hd_menu2:   db "        2: Editor",0   
13ad			;hd_menu2:   db "        2: Editor       6: Menu",0   
13ad			;hd_menu3:   db "        3: Storage",0 
13ad			;hd_menu4:   db "0=quit  4: Debug",0 
13ad			;hd_don:     db "ON",0 
13ad			;hd_doff:     db "OFF",0 
13ad			; 
13ad			; 
13ad			; 
13ad			;hardware_diags_old:       
13ad			; 
13ad			;.diagmenu: 
13ad			;	call clear_display 
13ad			;	ld a, display_row_1 
13ad			;	ld de, hd_menu1 
13ad			;	call str_at_display 
13ad			; 
13ad			;	ld a, display_row_2 
13ad			;	ld de, hd_menu2 
13ad			;	call str_at_display 
13ad			; 
13ad			;	ld a, display_row_3 
13ad			;	ld de, hd_menu3 
13ad			;	call str_at_display 
13ad			; 
13ad			;	ld a,  display_row_4 
13ad			;	ld de, hd_menu4 
13ad			;	call str_at_display 
13ad			; 
13ad			;	; display debug state 
13ad			; 
13ad			;	ld de, hd_don 
13ad			;	ld a, (os_view_disable) 
13ad			;	cp 0 
13ad			;	jr z, .distog 
13ad			;	ld de, hd_doff 
13ad			;.distog: ld a, display_row_4+17 
13ad			;	call str_at_display 
13ad			; 
13ad			;	call update_display 
13ad			; 
13ad			;	call cin_wait 
13ad			; 
13ad			; 
13ad			; 
13ad			;	cp '4' 
13ad			;	jr nz, .diagn1 
13ad			; 
13ad			;	; debug toggle 
13ad			; 
13ad			;	ld a, (os_view_disable) 
13ad			;	ld b, '*' 
13ad			;	cp 0 
13ad			;	jr z, .debtog 
13ad			;	ld b, 0 
13ad			;.debtog:	 
13ad			;	ld a,b 
13ad			;	ld (os_view_disable),a 
13ad			; 
13ad			;.diagn1: cp '0' 
13ad			;	 ret z 
13ad			; 
13ad			;;	cp '1' 
13ad			;;       jp z, matrix	 
13ad			;;   TODO keyboard matrix test 
13ad			; 
13ad			;	cp '2' 
13ad			;	jp z, .diagedit 
13ad			; 
13ad			;;	cp '6' 
13ad			;;	jp z, .menutest 
13ad			;;if ENABLE_BASIC 
13ad			;;	cp '6' 
13ad			;;	jp z, basic 
13ad			;;endif 
13ad			 ; 
13ad			;	jp .diagmenu 
13ad			; 
13ad			; 
13ad			;	ret 
13ad			 
13ad			 
13ad			.debug_tog: 
13ad 21 fb 13			ld hl, .menudebug 
13b0				 
13b0 3a 31 ee			ld a, (os_view_disable) 
13b3 fe 2a			cp '*' 
13b5 20 04			jr nz,.tdon  
13b7 3e 01			ld a, 1 
13b9 18 02			jr .tog1 
13bb 3e 00		.tdon: ld a, 0 
13bd			 
13bd			.tog1: 
13bd cd c0 0a			call menu 
13c0 fe 00			cp 0 
13c2 c8				ret z 
13c3 fe 01			cp 1    ; disable debug 
13c5 28 04			jr z, .dtog0 
13c7 3e 2a			ld a, '*' 
13c9 18 02			jr .dtogset 
13cb 3e 00		.dtog0: ld a, 0 
13cd 32 31 ee		.dtogset:  ld (os_view_disable), a 
13d0 c3 ad 13			jp .debug_tog 
13d3			 
13d3			 
13d3			hardware_diags:       
13d3			 
13d3			.diagm: 
13d3 21 eb 13			ld hl, .menuitems 
13d6 3e 00			ld a, 0 
13d8 cd c0 0a			call menu 
13db			 
13db fe 00		         cp 0 
13dd c8				 ret z 
13de			 
13de fe 02			cp 2 
13e0 ca 55 14			jp z, .diagedit 
13e3 fe 04			cp 4 
13e5 cc ad 13			call z, .debug_tog 
13e8			 
13e8			;	cp '6' 
13e8			;	jp z, .menutest 
13e8			;if ENABLE_BASIC 
13e8			;	cp '6' 
13e8			;	jp z, basic 
13e8			;endif 
13e8			  
13e8 c3 d3 13			jp .diagm 
13eb			 
13eb				 
13eb 01 14		.menuitems:   	dw .m1 
13ed 0c 14				dw .m2 
13ef 13 14				dw .m3 
13f1 1b 14				dw .m4 
13f3 2a 14				dw .m5 
13f5 30 14				dw .m5a 
13f7 39 14				dw .m5b 
13f9 00 00				dw 0 
13fb			 
13fb			.menudebug: 
13fb 42 14				dw .m6 
13fd 4b 14				dw .m7 
13ff 00 00				dw 0 
1401			 
1401 .. 00		.m1:   db "Key Matrix",0 
140c .. 00		.m2:   db "Editor",0 
1413 .. 00		.m3:   db "Storage",0 
141b .. 00		.m4:   db "Software Debug",0 
142a .. 00		.m5:   db "Sound",0 
1430 .. 00		.m5a:  db "RAM Test",0 
1439 .. 00		.m5b:  db "LCD Test",0 
1442			 
1442 .. 00		.m6:   db "Debug ON",0 
144b .. 00		.m7:   db "Debug OFF",0 
1455			 
1455			; debug editor 
1455			 
1455			.diagedit: 
1455			 
1455 21 32 ee			ld hl, scratch 
1458			;	ld bc, 250 
1458			;	ldir 
1458				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1458 3e 00			ld a, 0 
145a 77				ld (hl), a 
145b 23				inc hl 
145c 77				ld (hl), a 
145d 23				inc hl 
145e 77				ld (hl), a 
145f			 
145f cd 8f 0a		        call clear_display 
1462 cd b2 0a			call update_display 
1465 3e 01			ld a, 1 
1467 32 7d fb			ld (hardware_diag), a 
146a			.diloop: 
146a 3e 00			ld a, display_row_1 
146c 0e 00			ld c, 0 
146e 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1470 1e 28			ld e, 40 
1472			 
1472 21 32 ee			ld hl, scratch	 
1475 cd ec 0c			call input_str 
1478			 
1478 3e 28			ld a, display_row_2 
147a 11 32 ee			ld de, scratch 
147d cd a2 0a			call str_at_display 
1480 cd b2 0a			call update_display 
1483			 
1483 c3 6a 14			jp .diloop 
1486			 
1486			 
1486			; pass word in hl 
1486			; a has display location 
1486			display_word_at: 
1486 f5				push af 
1487 e5				push hl 
1488 7c				ld a,h 
1489 21 37 f1			ld hl, os_word_scratch 
148c cd c0 0f			call hexout 
148f e1				pop hl 
1490 7d				ld a,l 
1491 21 39 f1			ld hl, os_word_scratch+2 
1494 cd c0 0f			call hexout 
1497 21 3b f1			ld hl, os_word_scratch+4 
149a 3e 00			ld a,0 
149c 77				ld (hl),a 
149d 11 37 f1			ld de,os_word_scratch 
14a0 f1				pop af 
14a1 cd a2 0a				call str_at_display 
14a4 c9				ret 
14a5			 
14a5			display_ptr_state: 
14a5			 
14a5				; to restore afterwards 
14a5			 
14a5 d5				push de 
14a6 c5				push bc 
14a7 e5				push hl 
14a8 f5				push af 
14a9			 
14a9				; for use in here 
14a9			 
14a9			;	push bc 
14a9			;	push de 
14a9			;	push hl 
14a9			;	push af 
14a9			 
14a9 cd 8f 0a			call clear_display 
14ac			 
14ac 11 7f 16			ld de, .ptrstate 
14af 3e 00			ld a, display_row_1 
14b1 cd a2 0a			call str_at_display 
14b4			 
14b4				; display debug step 
14b4			 
14b4			 
14b4 11 77 fb			ld de, debug_mark 
14b7 3e 26			ld a, display_row_1+display_cols-2 
14b9 cd a2 0a			call str_at_display 
14bc			 
14bc				; display a 
14bc 11 89 16			ld de, .ptrcliptr 
14bf 3e 28			ld a, display_row_2 
14c1 cd a2 0a			call str_at_display 
14c4			 
14c4 f1				pop af 
14c5 2a 3d f8			ld hl,(cli_ptr) 
14c8 3e 30			ld a, display_row_2+8 
14ca cd 86 14			call display_word_at 
14cd			 
14cd			 
14cd				; display hl 
14cd			 
14cd			 
14cd 11 91 16			ld de, .ptrclioptr 
14d0 3e 32			ld a, display_row_2+10 
14d2 cd a2 0a			call str_at_display 
14d5			; 
14d5			;	pop hl 
14d5 3e 35			ld a, display_row_2+13 
14d7 2a 3b f8			ld hl,(cli_origptr) 
14da cd 86 14			call display_word_at 
14dd			; 
14dd			;	 
14dd			;	; display de 
14dd			 
14dd			;	ld de, .regstatede 
14dd			;	ld a, display_row_3 
14dd			;	call str_at_display 
14dd			 
14dd			;	pop de 
14dd			;	ld h,d 
14dd			;	ld l, e 
14dd			;	ld a, display_row_3+3 
14dd			;	call display_word_at 
14dd			 
14dd			 
14dd				; display bc 
14dd			 
14dd			;	ld de, .regstatebc 
14dd			;	ld a, display_row_3+10 
14dd			;	call str_at_display 
14dd			 
14dd			;	pop bc 
14dd			;	ld h,b 
14dd			;	ld l, c 
14dd			;	ld a, display_row_3+13 
14dd			;	call display_word_at 
14dd			 
14dd			 
14dd				; display dsp 
14dd			 
14dd			;	ld de, .regstatedsp 
14dd			;	ld a, display_row_4 
14dd			;	call str_at_display 
14dd			 
14dd				 
14dd			;	ld hl,(cli_data_sp) 
14dd			;	ld a, display_row_4+4 
14dd			;	call display_word_at 
14dd			 
14dd				; display rsp 
14dd			 
14dd 11 c0 16			ld de, .regstatersp 
14e0 3e 82			ld a, display_row_4+10 
14e2 cd a2 0a			call str_at_display 
14e5			 
14e5				 
14e5 2a 23 f8			ld hl,(cli_ret_sp) 
14e8 3e 86			ld a, display_row_4+14 
14ea cd 86 14			call display_word_at 
14ed			 
14ed cd b2 0a			call update_display 
14f0			 
14f0 cd 3d 0a			call delay1s 
14f3 cd 3d 0a			call delay1s 
14f6 cd 3d 0a			call delay1s 
14f9			 
14f9			 
14f9 cd 13 1a			call next_page_prompt 
14fc			 
14fc				; restore  
14fc			 
14fc f1				pop af 
14fd e1				pop hl 
14fe c1				pop bc 
14ff d1				pop de 
1500 c9				ret 
1501			 
1501			break_point_state: 
1501 f5				push af 
1502			 
1502				; see if disabled 
1502			 
1502 3a 31 ee			ld a, (os_view_disable) 
1505 fe 2a			cp '*' 
1507 20 02			jr nz, .bpsgo 
1509 f1				pop af 
150a c9				ret 
150b			 
150b			.bpsgo: 
150b f1				pop af 
150c f5				push af 
150d 22 2d ee			ld (os_view_hl), hl 
1510 ed 53 2b ee		ld (os_view_de), de 
1514 ed 43 29 ee		ld (os_view_bc), bc 
1518 e5				push hl 
1519 6f				ld l, a 
151a 26 00			ld h, 0 
151c 22 2f ee			ld (os_view_af),hl 
151f			 
151f 21 bd fa				ld hl, display_fb0 
1522 22 d8 f8				ld (display_fb_active), hl 
1525 e1				pop hl	 
1526			 
1526 3e 31			ld a, '1' 
1528 fe 2a		.bps1:  cp '*' 
152a 20 03			jr nz, .bps1b 
152c 32 31 ee			ld (os_view_disable),a 
152f fe 31		.bps1b:  cp '1' 
1531 20 14			jr nz, .bps2 
1533			 
1533				; display reg 
1533			 
1533				 
1533			 
1533 3a 2f ee			ld a, (os_view_af) 
1536 2a 2d ee			ld hl, (os_view_hl) 
1539 ed 5b 2b ee		ld de, (os_view_de) 
153d ed 4b 29 ee		ld bc, (os_view_bc) 
1541 cd db 15			call display_reg_state 
1544 c3 c7 15			jp .bpschk 
1547			 
1547 fe 32		.bps2:  cp '2' 
1549 20 08			jr nz, .bps3 
154b				 
154b				; display hl 
154b 2a 2d ee			ld hl, (os_view_hl) 
154e cd c5 16			call display_dump_at_hl 
1551			 
1551 18 74			jr .bpschk 
1553			 
1553 fe 33		.bps3:  cp '3' 
1555 20 08			jr nz, .bps4 
1557			 
1557			        ; display de 
1557 2a 2b ee			ld hl, (os_view_de) 
155a cd c5 16			call display_dump_at_hl 
155d			 
155d 18 68			jr .bpschk 
155f fe 34		.bps4:  cp '4' 
1561 20 08			jr nz, .bps5 
1563			 
1563			        ; display bc 
1563 2a 29 ee			ld hl, (os_view_bc) 
1566 cd c5 16			call display_dump_at_hl 
1569			 
1569 18 5c			jr .bpschk 
156b fe 35		.bps5:  cp '5' 
156d 20 08		        jr nz, .bps7 
156f			 
156f				; display cur ptr 
156f 2a 3d f8			ld hl, (cli_ptr) 
1572 cd c5 16			call display_dump_at_hl 
1575			 
1575 18 50			jr .bpschk 
1577 fe 36		.bps7:  cp '6' 
1579 20 08			jr nz, .bps8b 
157b				 
157b				; display cur orig ptr 
157b 2a 3b f8			ld hl, (cli_origptr) 
157e cd c5 16			call display_dump_at_hl 
1581 18 44			jr .bpschk 
1583 fe 37		.bps8b:  cp '7' 
1585 20 08			jr nz, .bps9 
1587				 
1587				; display dsp 
1587 2a 1f f8			ld hl, (cli_data_sp) 
158a cd c5 16			call display_dump_at_hl 
158d			 
158d 18 38			jr .bpschk 
158f fe 39		.bps9:  cp '9' 
1591 20 05			jr nz, .bps8c 
1593				 
1593				; display SP 
1593			;	ld hl, sp 
1593 cd c5 16			call display_dump_at_hl 
1596			 
1596 18 2f			jr .bpschk 
1598 fe 38		.bps8c:  cp '8' 
159a 20 08			jr nz, .bps8d 
159c				 
159c				; display rsp 
159c 2a 23 f8			ld hl, (cli_ret_sp) 
159f cd c5 16			call display_dump_at_hl 
15a2			 
15a2 18 23			jr .bpschk 
15a4 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
15a6 20 05			jr nz, .bps8 
15a8 cd 09 18			call monitor 
15ab			 
15ab 18 1a			jr .bpschk 
15ad fe 30		.bps8:  cp '0' 
15af 20 16			jr nz, .bpschk 
15b1			 
15b1 21 1c fa				ld hl, display_fb1 
15b4 22 d8 f8				ld (display_fb_active), hl 
15b7 cd b2 0a				call update_display 
15ba			 
15ba				;ld a, (os_view_af) 
15ba 2a 2d ee			ld hl, (os_view_hl) 
15bd ed 5b 2b ee		ld de, (os_view_de) 
15c1 ed 4b 29 ee		ld bc, (os_view_bc) 
15c5 f1				pop af 
15c6 c9				ret 
15c7			 
15c7			.bpschk:   
15c7 cd 3d 0a			call delay1s 
15ca 3e 9f		ld a,display_row_4 + display_cols - 1 
15cc 11 11 1a		        ld de, endprg 
15cf cd a2 0a			call str_at_display 
15d2 cd b2 0a			call update_display 
15d5 cd 30 65			call cin_wait 
15d8			 
15d8 c3 28 15			jp .bps1 
15db			 
15db			 
15db			display_reg_state: 
15db			 
15db				; to restore afterwards 
15db			 
15db d5				push de 
15dc c5				push bc 
15dd e5				push hl 
15de f5				push af 
15df			 
15df				; for use in here 
15df			 
15df c5				push bc 
15e0 d5				push de 
15e1 e5				push hl 
15e2 f5				push af 
15e3			 
15e3 cd 8f 0a			call clear_display 
15e6			 
15e6 11 9b 16			ld de, .regstate 
15e9 3e 00			ld a, display_row_1 
15eb cd a2 0a			call str_at_display 
15ee			 
15ee				; display debug step 
15ee			 
15ee			 
15ee 11 77 fb			ld de, debug_mark 
15f1 3e 25			ld a, display_row_1+display_cols-3 
15f3 cd a2 0a			call str_at_display 
15f6			 
15f6				; display a 
15f6 11 b7 16			ld de, .regstatea 
15f9 3e 28			ld a, display_row_2 
15fb cd a2 0a			call str_at_display 
15fe			 
15fe e1				pop hl 
15ff			;	ld h,0 
15ff			;	ld l, a 
15ff 3e 2b			ld a, display_row_2+3 
1601 cd 86 14			call display_word_at 
1604			 
1604			 
1604				; display hl 
1604			 
1604			 
1604 11 ab 16			ld de, .regstatehl 
1607 3e 32			ld a, display_row_2+10 
1609 cd a2 0a			call str_at_display 
160c			 
160c e1				pop hl 
160d 3e 35			ld a, display_row_2+13 
160f cd 86 14			call display_word_at 
1612			 
1612				 
1612				; display de 
1612			 
1612 11 af 16			ld de, .regstatede 
1615 3e 50			ld a, display_row_3 
1617 cd a2 0a			call str_at_display 
161a			 
161a e1				pop hl 
161b			;	ld h,d 
161b			;	ld l, e 
161b 3e 53			ld a, display_row_3+3 
161d cd 86 14			call display_word_at 
1620			 
1620			 
1620				; display bc 
1620			 
1620 11 b3 16			ld de, .regstatebc 
1623 3e 5a			ld a, display_row_3+10 
1625 cd a2 0a			call str_at_display 
1628			 
1628 e1				pop hl 
1629			;	ld h,b 
1629			;	ld l, c 
1629 3e 5d			ld a, display_row_3+13 
162b cd 86 14			call display_word_at 
162e			 
162e			 
162e				; display dsp 
162e			 
162e 11 bb 16			ld de, .regstatedsp 
1631 3e 78			ld a, display_row_4 
1633 cd a2 0a			call str_at_display 
1636			 
1636				 
1636 2a 1f f8			ld hl,(cli_data_sp) 
1639 3e 7c			ld a, display_row_4+4 
163b cd 86 14			call display_word_at 
163e			 
163e				; display rsp 
163e			 
163e 11 c0 16			ld de, .regstatersp 
1641 3e 82			ld a, display_row_4+10 
1643 cd a2 0a			call str_at_display 
1646			 
1646				 
1646 2a 23 f8			ld hl,(cli_ret_sp) 
1649 3e 86			ld a, display_row_4+14 
164b cd 86 14			call display_word_at 
164e			 
164e cd b2 0a			call update_display 
1651			 
1651			;	call delay1s 
1651			;	call delay1s 
1651			;	call delay1s 
1651			 
1651			 
1651			;	call next_page_prompt 
1651			 
1651				; restore  
1651			 
1651 f1				pop af 
1652 e1				pop hl 
1653 c1				pop bc 
1654 d1				pop de 
1655 c9				ret 
1656			 
1656 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
166a .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
167f .. 00		.ptrstate:	db "Ptr State",0 
1689 .. 00		.ptrcliptr:     db "cli_ptr",0 
1691 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
169b .. 00		.regstate:	db "Reg State (1/0)",0 
16ab .. 00		.regstatehl:	db "HL:",0 
16af .. 00		.regstatede:	db "DE:",0 
16b3 .. 00		.regstatebc:	db "BC:",0 
16b7 .. 00		.regstatea:	db "A :",0 
16bb .. 00		.regstatedsp:	db "DSP:",0 
16c0 .. 00		.regstatersp:	db "RSP:",0 
16c5			 
16c5			display_dump_at_hl: 
16c5 e5				push hl 
16c6 d5				push de 
16c7 c5				push bc 
16c8 f5				push af 
16c9			 
16c9 22 55 f1			ld (os_cur_ptr),hl	 
16cc cd 8f 0a			call clear_display 
16cf cd 1b 19			call dumpcont 
16d2			;	call delay1s 
16d2			;	call next_page_prompt 
16d2			 
16d2			 
16d2 f1				pop af 
16d3 c1				pop bc 
16d4 d1				pop de 
16d5 e1				pop hl 
16d6 c9				ret 
16d7			 
16d7			;if ENABLE_BASIC 
16d7			;	include "nascombasic.asm" 
16d7			;	basic: 
16d7			;	include "forth/FORTH.ASM" 
16d7			;endif 
16d7			 
16d7			; eof 
16d7			 
16d7			 
# End of file firmware_diags.asm
16d7			  
16d7			  
16d7			  
16d7			  
16d7			; eof  
16d7			  
# End of file firmware.asm
16d7			 
16d7			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
16d7			;if BASE_KEV  
16d7			;baseram: equ 08000h 
16d7			;endif 
16d7			 
16d7			;if BASE_SC114 
16d7			;baseram:     equ    endofcode 
16d7			;endif 
16d7			 
16d7			 
16d7			; start system 
16d7			 
16d7			coldstart: 
16d7				; set sp 
16d7				; di/ei 
16d7			 
16d7 f3				di 
16d8 31 fd ff			ld sp, tos 
16db			;	ei 
16db			 
16db			 
16db				; disable breakpoint by default 
16db			 
16db 3e 2a			ld a,'*' 
16dd 32 31 ee			ld (os_view_disable),a 
16e0			 
16e0				; init hardware 
16e0			 
16e0				; init keyboard and screen hardware 
16e0			 
16e0 cd 03 00			call hardware_init 
16e3			 
16e3			 
16e3				; detect if any keys are held down to enable breakpoints at start up 
16e3			 
16e3 cd 41 65			call cin  
16e6 fe 00			cp 0 
16e8 28 03			jr z, .nokeys 
16ea			 
16ea				;call hardware_diags 
16ea cd 49 13			call config 
16ed			 
16ed			;	ld de, .bpen 
16ed			;	ld a, display_row_4 
16ed			;	call str_at_display 
16ed			;	call update_display 
16ed			; 
16ed			;	ld a,0 
16ed			;	ld (os_view_disable),a 
16ed			; 
16ed			;.bpwait: 
16ed			;	call cin 
16ed			;	cp 0 
16ed			;	jr z, .bpwait 
16ed			;	jr .nokeys 
16ed			; 
16ed			; 
16ed			;.bpen:  db "Break points enabled!",0 
16ed			 
16ed			 
16ed			 
16ed			 
16ed			 
16ed			 
16ed			.nokeys: 
16ed			 
16ed			 
16ed				 
16ed			 
16ed			;jp  testkey 
16ed			 
16ed			;call storage_get_block_0 
16ed			; 
16ed			;ld hl, 0 
16ed			;ld de, store_page 
16ed			;call storage_read_block 
16ed			 
16ed				 
16ed			;ld hl, 10 
16ed			;ld de, store_page 
16ed			;call storage_read_block 
16ed			 
16ed			 
16ed			 
16ed			 
16ed			 
16ed			;stop:	nop 
16ed			;	jp stop 
16ed			 
16ed			 
16ed			 
16ed			main: 
16ed cd 8f 0a			call clear_display 
16f0 cd b2 0a			call update_display 
16f3			 
16f3			 
16f3			 
16f3			;	call testlcd 
16f3			 
16f3			 
16f3			 
16f3 cd 61 1c			call forth_init 
16f6			 
16f6			 
16f6			warmstart: 
16f6 cd 37 1c			call forth_warmstart 
16f9			 
16f9				; run startup word load 
16f9			        ; TODO prevent this running at warmstart after crash  
16f9			 
16f9				if STARTUP_ENABLE 
16f9 cd 07 5f				call forth_startup 
16fc				endif 
16fc			 
16fc				; show free memory after boot 
16fc 11 a3 17			ld de, freeram 
16ff 3e 00			ld a, display_row_1 
1701 cd a2 0a			call str_at_display 
1704			 
1704			; Or use heap_size word???? 
1704 21 26 ee			ld hl, heap_end 
1707 11 0e 80			ld de, heap_start 
170a ed 52			sbc hl, de 
170c e5				push hl 
170d 7c				ld a,h	         	 
170e 21 37 f1			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1711 cd c0 0f			call hexout 
1714 e1			   	pop hl 
1715			 
1715 7d				ld a,l 
1716 21 39 f1			ld hl, os_word_scratch+2 
1719 cd c0 0f			call hexout 
171c 21 3b f1			ld hl, os_word_scratch+4 
171f 3e 00			ld a, 0 
1721 77				ld (hl),a 
1722 11 37 f1			ld de, os_word_scratch 
1725 3e 0d			ld a, display_row_1 + 13 
1727 cd a2 0a			call str_at_display 
172a cd b2 0a			call update_display 
172d			 
172d			 
172d				;call demo 
172d			 
172d			 
172d				; init scratch input area for cli commands 
172d			 
172d 21 59 f1			ld hl, os_cli_cmd 
1730 3e 00			ld a,0 
1732 77				ld (hl),a 
1733 23				inc hl 
1734 77				ld (hl),a 
1735			 
1735 3e 00			ld a,0 
1737 32 58 f2			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
173a			 
173a 32 55 f1			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
173d 32 56 f1			ld (os_cur_ptr+1),a	 
1740			 
1740 32 37 f1			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1743 32 38 f1			ld (os_word_scratch+1),a	 
1746				 
1746			 
1746				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1746 21 59 f1			ld hl, os_cli_cmd 
1749			 
1749 3e 00			ld a, 0		 ; init cli input 
174b 77				ld (hl), a 
174c 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
174e			cli: 
174e				; show cli prompt 
174e				;push af 
174e				;ld a, 0 
174e				;ld de, prompt 
174e				;call str_at_display 
174e			 
174e				;call update_display 
174e				;pop af 
174e				;inc a 
174e				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
174e 0e 00			ld c, 0 
1750 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1752 1e 28			ld e, 40 
1754			 
1754 21 59 f1			ld hl, os_cli_cmd 
1757			 
1757				STACKFRAME OFF $fefe $9f9f 
1757				if DEBUG_STACK_IMB 
1757					if OFF 
1757						exx 
1757						ld de, $fefe 
1757						ld a, d 
1757						ld hl, curframe 
1757						call hexout 
1757						ld a, e 
1757						ld hl, curframe+2 
1757						call hexout 
1757						ld hl, $fefe 
1757						push hl 
1757						ld hl, $9f9f 
1757						push hl 
1757						exx 
1757					endif 
1757				endif 
1757			endm 
# End of macro STACKFRAME
1757			 
1757 cd ec 0c			call input_str 
175a			 
175a				STACKFRAMECHK OFF $fefe $9f9f 
175a				if DEBUG_STACK_IMB 
175a					if OFF 
175a						exx 
175a						ld hl, $9f9f 
175a						pop de   ; $9f9f 
175a						call cmp16 
175a						jr nz, .spnosame 
175a						ld hl, $fefe 
175a						pop de   ; $fefe 
175a						call cmp16 
175a						jr z, .spfrsame 
175a						.spnosame: call showsperror 
175a						.spfrsame: nop 
175a						exx 
175a					endif 
175a				endif 
175a			endm 
# End of macro STACKFRAMECHK
175a			 
175a				; copy input to last command 
175a			 
175a 21 59 f1			ld hl, os_cli_cmd 
175d 11 58 f2			ld de, os_last_cmd 
1760 01 ff 00			ld bc, 255 
1763 ed b0			ldir 
1765			 
1765				; wipe current buffer 
1765			 
1765 3e 00			ld a, 0 
1767 21 59 f1			ld hl, os_cli_cmd 
176a 11 5a f1			ld de, os_cli_cmd+1 
176d 01 fe 00			ld bc, 254 
1770 ed b0			ldir 
1772				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1772			;	call strcpy 
1772			;	ld a, 0 
1772			;	ld (hl), a 
1772			;	inc hl 
1772			;	ld (hl), a 
1772			;	inc hl 
1772			;	ld (hl), a 
1772			 
1772				; switch frame buffer to program  
1772			 
1772 21 1c fa				ld hl, display_fb1 
1775 22 d8 f8				ld (display_fb_active), hl 
1778			 
1778			;	nop 
1778				STACKFRAME ON $fbfe $8f9f 
1778				if DEBUG_STACK_IMB 
1778					if ON 
1778						exx 
1778						ld de, $fbfe 
1778						ld a, d 
1778						ld hl, curframe 
1778						call hexout 
1778						ld a, e 
1778						ld hl, curframe+2 
1778						call hexout 
1778						ld hl, $fbfe 
1778						push hl 
1778						ld hl, $8f9f 
1778						push hl 
1778						exx 
1778					endif 
1778				endif 
1778			endm 
# End of macro STACKFRAME
1778				; first time into the parser so pass over the current scratch pad 
1778 21 59 f1			ld hl,os_cli_cmd 
177b				; tokenise the entered statement(s) in HL 
177b cd da 1c			call forthparse 
177e			        ; exec forth statements in top of return stack 
177e cd 1a 1d			call forthexec 
1781				;call forthexec_cleanup 
1781			;	call parsenext 
1781			 
1781				STACKFRAMECHK ON $fbfe $8f9f 
1781				if DEBUG_STACK_IMB 
1781					if ON 
1781						exx 
1781						ld hl, $8f9f 
1781						pop de   ; $8f9f 
1781						call cmp16 
1781						jr nz, .spnosame 
1781						ld hl, $fbfe 
1781						pop de   ; $fbfe 
1781						call cmp16 
1781						jr z, .spfrsame 
1781						.spnosame: call showsperror 
1781						.spfrsame: nop 
1781						exx 
1781					endif 
1781				endif 
1781			endm 
# End of macro STACKFRAMECHK
1781				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1781			 
1781 3e 78			ld a, display_row_4 
1783 11 b5 17			ld de, endprog 
1786			 
1786 cd b2 0a			call update_display		 
1789			 
1789 cd 13 1a			call next_page_prompt 
178c			 
178c				; switch frame buffer to cli 
178c			 
178c 21 bd fa				ld hl, display_fb0 
178f 22 d8 f8				ld (display_fb_active), hl 
1792			 
1792			 
1792 cd 8f 0a		        call clear_display 
1795 cd b2 0a			call update_display		 
1798			 
1798 21 59 f1			ld hl, os_cli_cmd 
179b			 
179b 3e 00			ld a, 0		 ; init cli input 
179d 77				ld (hl), a 
179e			 
179e				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
179e			 
179e				; now on last line 
179e			 
179e				; TODO scroll screen up 
179e			 
179e				; TODO instead just clear screen and place at top of screen 
179e			 
179e			;	ld a, 0 
179e			;	ld (f_cursor_ptr),a 
179e			 
179e				;call clear_display 
179e				;call update_display 
179e			 
179e				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
179e 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17a0 c3 4e 17			jp cli 
17a3			 
17a3 .. 00		freeram: db "Free bytes: $",0 
17b1 ..			asc: db "1A2F" 
17b5 .. 00		endprog: db "End prog...",0 
17c1			 
17c1			testenter2:   
17c1 21 64 ee			ld hl,scratch+50 
17c4 22 55 f1			ld (os_cur_ptr),hl 
17c7 c3 4e 17			jp cli 
17ca			 
17ca			testenter:  
17ca			 
17ca 21 b1 17			ld hl,asc 
17cd			;	ld a,(hl) 
17cd			;	call nibble2val 
17cd cd 16 10			call get_byte 
17d0			 
17d0			 
17d0			;	ld a,(hl) 
17d0			;	call atohex 
17d0			 
17d0			;	call fourehexhl 
17d0 32 64 ee			ld (scratch+50),a 
17d3			 
17d3			 
17d3			 
17d3 21 b3 17			ld hl,asc+2 
17d6			;	ld a, (hl) 
17d6			;	call nibble2val 
17d6 cd 16 10			call get_byte 
17d9			 
17d9			;	call fourehexhl 
17d9 32 66 ee			ld (scratch+52),a 
17dc				 
17dc 21 64 ee			ld hl,scratch+50 
17df 22 55 f1			ld (os_cur_ptr),hl 
17e2 c3 4e 17			jp cli 
17e5			 
17e5			enter:	 
17e5 3a 36 ee			ld a,(scratch+4) 
17e8 fe 00			cp 0 
17ea 28 0c			jr z, .entercont 
17ec				; no, not a null term line so has an address to work out.... 
17ec			 
17ec 21 34 ee			ld hl,scratch+2 
17ef cd 76 10			call get_word_hl 
17f2			 
17f2 22 55 f1			ld (os_cur_ptr),hl	 
17f5 c3 4e 17			jp cli 
17f8			 
17f8			 
17f8			.entercont:  
17f8			 
17f8 21 34 ee			ld hl, scratch+2 
17fb cd 16 10			call get_byte 
17fe			 
17fe 2a 55 f1		   	ld hl,(os_cur_ptr) 
1801 77					ld (hl),a 
1802 23					inc hl 
1803 22 55 f1				ld (os_cur_ptr),hl 
1806				 
1806			; get byte  
1806			 
1806			 
1806 c3 4e 17			jp cli 
1809			 
1809			 
1809			; basic monitor support 
1809			 
1809			monitor: 
1809				;  
1809 cd 8f 0a			call clear_display 
180c 3e 00			ld a, 0 
180e 11 56 18			ld de, .monprompt 
1811 cd a2 0a			call str_at_display 
1814 cd b2 0a			call update_display 
1817			 
1817				; get a monitor command 
1817			 
1817 0e 00			ld c, 0     ; entry at top left 
1819 16 64			ld d, 100   ; max buffer size 
181b 1e 0f			ld e, 15    ; input scroll area 
181d 3e 00			ld a, 0     ; init string 
181f 21 30 f0			ld hl, os_input 
1822 77				ld (hl), a 
1823 23				inc hl 
1824 77				ld (hl), a 
1825 21 30 f0			ld hl, os_input 
1828 3e 01			ld a, 1     ; init string 
182a cd ec 0c			call input_str 
182d			 
182d cd 8f 0a		        call clear_display 
1830 cd b2 0a			call update_display		 
1833			 
1833 3a 30 f0			ld a, (os_input) 
1836 cd 14 11			call toUpper 
1839 fe 48		        cp 'H' 
183b 28 6f		        jr z, .monhelp 
183d fe 44			cp 'D'		; dump 
183f ca cd 18			jp z, .mondump	 
1842 fe 43			cp 'C'		; dump 
1844 ca e7 18			jp z, .moncdump	 
1847 fe 4d			cp 'M'		; dump 
1849 ca 58 18			jp z, .moneditstart 
184c fe 55			cp 'U'		; dump 
184e 28 14			jr z, .monedit	 
1850 fe 51			cp 'Q'		; dump 
1852 c8				ret z	 
1853			 
1853			 
1853				; TODO "S" to access symbol by name and not need the address 
1853				; TODO "F" to find a string in memory 
1853			 
1853 c3 09 18			jp monitor 
1856			 
1856 .. 00		.monprompt: db ">", 0 
1858			 
1858			.moneditstart: 
1858				; get starting address 
1858			 
1858 21 32 f0			ld hl,os_input+2 
185b cd 76 10			call get_word_hl 
185e			 
185e 22 55 f1			ld (os_cur_ptr),hl	 
1861			 
1861 c3 09 18			jp monitor 
1864			 
1864			.monedit: 
1864				; get byte to load 
1864			 
1864 21 32 f0			ld hl,os_input+2 
1867 cd 16 10			call get_byte 
186a			 
186a				; get address to update 
186a 2a 55 f1			ld hl, (os_cur_ptr) 
186d			 
186d				; update byte 
186d			 
186d 77				ld (hl), a 
186e			 
186e				; move to next address and save it 
186e			 
186e 23				inc hl 
186f 22 55 f1			ld (os_cur_ptr),hl	 
1872			 
1872 c3 09 18			jp monitor 
1875			 
1875			 
1875 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1889 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
18a5 .. 00		.monhelptext3:  db "Q-Quit",0 
18ac			        
18ac			.monhelp: 
18ac 3e 00			ld a, display_row_1 
18ae 11 75 18		        ld de, .monhelptext1 
18b1			 
18b1 cd a2 0a			call str_at_display 
18b4 3e 28			ld a, display_row_2 
18b6 11 89 18		        ld de, .monhelptext2 
18b9					 
18b9 cd a2 0a			call str_at_display 
18bc 3e 50			ld a, display_row_3 
18be 11 a5 18		        ld de, .monhelptext3 
18c1					 
18c1 cd a2 0a			call str_at_display 
18c4 cd b2 0a			call update_display		 
18c7			 
18c7 cd 13 1a			call next_page_prompt 
18ca c3 09 18			jp monitor 
18cd			 
18cd			.mondump:    
18cd 21 32 f0			ld hl,os_input+2 
18d0 cd 76 10			call get_word_hl 
18d3			 
18d3 22 55 f1			ld (os_cur_ptr),hl	 
18d6 cd 1b 19			call dumpcont 
18d9 3e 78			ld a, display_row_4 
18db 11 b5 17			ld de, endprog 
18de			 
18de cd b2 0a			call update_display		 
18e1			 
18e1 cd 13 1a			call next_page_prompt 
18e4 c3 09 18			jp monitor 
18e7			.moncdump: 
18e7 cd 1b 19			call dumpcont 
18ea 3e 78			ld a, display_row_4 
18ec 11 b5 17			ld de, endprog 
18ef			 
18ef cd b2 0a			call update_display		 
18f2			 
18f2 cd 13 1a			call next_page_prompt 
18f5 c3 09 18			jp monitor 
18f8			 
18f8			 
18f8			; TODO symbol access  
18f8			 
18f8			.symbols:     ;; A list of symbols that can be called up  
18f8 bd fa			dw display_fb0 
18fa .. 00			db "fb0",0  
18fe 62 f8		     	dw store_page 
1900 .. 00			db "store_page",0 
190b			 
190b			 
190b			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
190b			 
190b 3a 33 ee			ld a,(scratch+1) 
190e fe 00			cp 0 
1910 28 09			jr z, dumpcont 
1912			 
1912				; no, not a null term line so has an address to work out.... 
1912			 
1912 21 34 ee			ld hl,scratch+2 
1915 cd 76 10			call get_word_hl 
1918			 
1918 22 55 f1			ld (os_cur_ptr),hl	 
191b			 
191b			 
191b			 
191b			dumpcont: 
191b			 
191b				; dump bytes at ptr 
191b			 
191b			 
191b 3e 00			ld a, display_row_1 
191d 2a d8 f8			ld hl, (display_fb_active) 
1920 cd bf 0c			call addatohl 
1923 cd 4b 19			call .dumpbyterow 
1926			 
1926 3e 28			ld a, display_row_2 
1928 2a d8 f8			ld hl, (display_fb_active) 
192b cd bf 0c			call addatohl 
192e cd 4b 19			call .dumpbyterow 
1931			 
1931			 
1931 3e 50			ld a, display_row_3 
1933 2a d8 f8			ld hl, (display_fb_active) 
1936 cd bf 0c			call addatohl 
1939 cd 4b 19			call .dumpbyterow 
193c			 
193c 3e 78			ld a, display_row_4 
193e 2a d8 f8			ld hl, (display_fb_active) 
1941 cd bf 0c			call addatohl 
1944 cd 4b 19			call .dumpbyterow 
1947			 
1947 cd b2 0a			call update_display 
194a			;		jp cli 
194a c9				ret 
194b			 
194b			.dumpbyterow: 
194b			 
194b				;push af 
194b			 
194b e5				push hl 
194c			 
194c				; calc where to poke the ascii 
194c			if display_cols == 20 
194c				ld a, 16 
194c			else 
194c 3e 1f			ld a, 31 
194e			endif 
194e			 
194e cd bf 0c			call addatohl 
1951 22 37 f1			ld (os_word_scratch),hl  		; save pos for later 
1954			 
1954			 
1954			; display decoding address 
1954 2a 55 f1		   	ld hl,(os_cur_ptr) 
1957			 
1957 7c				ld a,h 
1958 e1				pop hl 
1959 e5				push hl 
195a			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
195a cd c0 0f			call hexout 
195d 2a 55 f1		   	ld hl,(os_cur_ptr) 
1960			 
1960 7d				ld a,l 
1961 e1				pop hl 
1962 23				inc hl 
1963 23				inc hl 
1964 e5				push hl 
1965			;	ld hl, os_word_scratch+2 
1965 cd c0 0f			call hexout 
1968 e1				pop hl 
1969 23				inc hl 
196a 23				inc hl 
196b				;ld hl, os_word_scratch+4 
196b 3e 3a			ld a, ':' 
196d 77				ld (hl),a 
196e 23				inc hl 
196f				;ld a, 0 
196f				;ld (hl),a 
196f				;ld de, os_word_scratch 
196f				;pop af 
196f				;push af 
196f			;		ld a, display_row_2 
196f			;		call str_at_display 
196f			;		call update_display 
196f			 
196f			 
196f			;pop af 
196f			;	add 5 
196f			 
196f			if display_cols == 20 
196f				ld b, 4 
196f			else 
196f 06 08			ld b, 8 
1971			endif	 
1971			 
1971			.dumpbyte: 
1971 c5				push bc 
1972 e5				push hl 
1973			 
1973			 
1973 2a 55 f1		   	ld hl,(os_cur_ptr) 
1976 7e					ld a,(hl) 
1977			 
1977					; poke the ascii to display 
1977 2a 37 f1				ld hl,(os_word_scratch) 
197a 77					ld (hl),a 
197b 23					inc hl 
197c 22 37 f1				ld (os_word_scratch),hl 
197f			 
197f					 
197f			 
197f			 
197f e1					pop hl 
1980 e5					push hl 
1981			 
1981 cd c0 0f				call hexout 
1984			 
1984					 
1984 2a 55 f1		   	ld hl,(os_cur_ptr) 
1987 23				inc hl 
1988 22 55 f1		   	ld (os_cur_ptr),hl 
198b			 
198b e1					pop hl 
198c 23					inc hl 
198d 23					inc hl 
198e 23					inc hl 
198f			 
198f			 
198f			 
198f					;ld a,0 
198f					;ld (os_word_scratch+2),a 
198f					;pop af 
198f					;push af 
198f			 
198f					;ld de, os_word_scratch 
198f					;call str_at_display 
198f			;		call update_display 
198f			;		pop af 
198f c1					pop bc 
1990 c6 03				add 3 
1992 10 dd			djnz .dumpbyte 
1994			 
1994				 
1994			 
1994 c9				ret 
1995			 
1995			jump:	 
1995			 
1995 21 34 ee			ld hl,scratch+2 
1998 cd 76 10			call get_word_hl 
199b				;ld hl,(scratch+2) 
199b				;call fourehexhl 
199b			 
199b 22 55 f1			ld (os_cur_ptr),hl	 
199e			 
199e e9				jp (hl) 
199f			 
199f			 
199f			 
199f			; TODO implement a basic monitor mode to start with 
199f			 
199f			 
199f			 
199f			 
199f			 
199f			 
199f			 
199f			 
199f			 
199f			; testing and demo code during development 
199f			 
199f			 
199f .. 00		str1: db "Enter some text...",0 
19b2 .. 00		clear: db "                    ",0 
19c7			 
19c7			demo: 
19c7			 
19c7			 
19c7			 
19c7			;	call update_display 
19c7			 
19c7				; init scratch input area for testing 
19c7 21 32 ee			ld hl, scratch	 
19ca 3e 00			ld a,0 
19cc 77				ld (hl),a 
19cd			 
19cd			 
19cd 3e 28		            LD   A, display_row_2 
19cf			;            CALL fLCD_Pos       ;Position cursor to location in A 
19cf 11 9f 19		            LD   DE, str1 
19d2 cd a2 0a			call str_at_display 
19d5			 
19d5			;            CALL fLCD_Str       ;Display string pointed to by DE 
19d5			cloop:	 
19d5 3e 50		            LD   A, display_row_3 
19d7			;            CALL fLCD_Pos       ;Position cursor to location in A 
19d7 11 b2 19		            LD   DE, clear 
19da			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
19da cd a2 0a				call str_at_display 
19dd 3e 78			ld a, display_row_4 
19df 11 0f 1a			ld de, prompt 
19e2			 
19e2 cd a2 0a				call str_at_display 
19e5 cd b2 0a			call update_display 
19e8			 
19e8 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
19ea 16 0a			ld d, 10 
19ec 21 32 ee			ld hl, scratch	 
19ef cd ec 0c			call input_str 
19f2			 
19f2			;	call clear_display 
19f2			;'	call update_display 
19f2			 
19f2 3e 00		            LD   A, display_row_1 
19f4			;            CALL fLCD_Pos       ;Position cursor to location in A 
19f4 11 b2 19		            LD   DE, clear 
19f7 cd a2 0a				call str_at_display 
19fa			;            CALL fLCD_Str       ;Display string pointed to by DE 
19fa 3e 00		            LD   A, display_row_1 
19fc			;            CALL fLCD_Pos       ;Position cursor to location in A 
19fc 11 32 ee		            LD   DE, scratch 
19ff			;            CALL fLCD_Str       ;Display string pointed to by DE 
19ff cd a2 0a				call str_at_display 
1a02 cd b2 0a			call update_display 
1a05			 
1a05 3e 00				ld a,0 
1a07 21 32 ee			ld hl, scratch 
1a0a 77				ld (hl),a 
1a0b			 
1a0b 00				nop 
1a0c c3 d5 19			jp cloop 
1a0f			 
1a0f			 
1a0f			 
1a0f			; OS Prompt 
1a0f			 
1a0f .. 00		prompt: db ">",0 
1a11 .. 00		endprg: db "?",0 
1a13			 
1a13			 
1a13			; handy next page prompt 
1a13			next_page_prompt: 
1a13 e5				push hl 
1a14 d5				push de 
1a15 f5				push af 
1a16 c5				push bc 
1a17			 
1a17 3e 9f			ld a,display_row_4 + display_cols - 1 
1a19 11 11 1a		        ld de, endprg 
1a1c cd a2 0a			call str_at_display 
1a1f cd b2 0a			call update_display 
1a22 cd 30 65			call cin_wait 
1a25 c1				pop bc 
1a26 f1				pop af 
1a27 d1				pop de 
1a28 e1				pop hl 
1a29			 
1a29			 
1a29 c9				ret 
1a2a			 
1a2a			 
1a2a			; forth parser 
1a2a			 
1a2a			; My forth kernel 
1a2a			include "forth_kernel.asm" 
1a2a			; 
1a2a			; kernel to the forth OS 
1a2a			 
1a2a			DS_TYPE_STR: equ 1     ; string type 
1a2a			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1a2a			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1a2a			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1a2a			 
1a2a			FORTH_PARSEV1: equ 0 
1a2a			FORTH_PARSEV2: equ 0 
1a2a			FORTH_PARSEV3: equ 0 
1a2a			FORTH_PARSEV4: equ 0 
1a2a			FORTH_PARSEV5: equ 1 
1a2a			 
1a2a			;if FORTH_PARSEV5 
1a2a			;	FORTH_END_BUFFER: equ 0 
1a2a			;else 
1a2a			FORTH_END_BUFFER: equ 127 
1a2a			;endif 
1a2a			 
1a2a			FORTH_TRUE: equ 1 
1a2a			FORTH_FALSE: equ 0 
1a2a			 
1a2a			if FORTH_PARSEV4 
1a2a			include "forth_stackops.asm" 
1a2a			endif 
1a2a			 
1a2a			if FORTH_PARSEV5 
1a2a			include "forth_stackopsv5.asm" 
1a2a			 
1a2a			; Stack operations for v5 parser on wards 
1a2a			; * DATA stack 
1a2a			; * LOOP stack 
1a2a			; * RETURN stack 
1a2a			 
1a2a			 
1a2a			 
1a2a			FORTH_CHK_DSP_UNDER: macro 
1a2a				push hl 
1a2a				push de 
1a2a				ld hl,(cli_data_sp) 
1a2a				ld de, cli_data_stack 
1a2a				call cmp16 
1a2a				jp c, fault_dsp_under 
1a2a				pop de 
1a2a				pop hl 
1a2a				endm 
1a2a			 
1a2a			 
1a2a			FORTH_CHK_RSP_UNDER: macro 
1a2a				push hl 
1a2a				push de 
1a2a				ld hl,(cli_ret_sp) 
1a2a				ld de, cli_ret_stack 
1a2a				call cmp16 
1a2a				jp c, fault_rsp_under 
1a2a				pop de 
1a2a				pop hl 
1a2a				endm 
1a2a			 
1a2a			FORTH_CHK_LOOP_UNDER: macro 
1a2a				push hl 
1a2a				push de 
1a2a				ld hl,(cli_loop_sp) 
1a2a				ld de, cli_loop_stack 
1a2a				call cmp16 
1a2a				jp c, fault_loop_under 
1a2a				pop de 
1a2a				pop hl 
1a2a				endm 
1a2a			 
1a2a			FORTH_ERR_TOS_NOTSTR: macro 
1a2a				; TOSO might need more for checks when used 
1a2a				push af 
1a2a				ld a,(hl) 
1a2a				cp DS_TYPE_STR 
1a2a				jp nz, type_faultn   
1a2a				pop af 
1a2a				endm 
1a2a			 
1a2a			FORTH_ERR_TOS_NOTNUM: macro 
1a2a				push af 
1a2a				ld a,(hl) 
1a2a				cp DS_TYPE_INUM 
1a2a				jp nz, type_faultn   
1a2a				pop af 
1a2a				endm 
1a2a			 
1a2a			 
1a2a			; increase data stack pointer and save hl to it 
1a2a				 
1a2a			FORTH_DSP_NEXT: macro 
1a2a				call macro_forth_dsp_next 
1a2a				endm 
1a2a			 
1a2a			 
1a2a			macro_forth_dsp_next: 
1a2a				if DEBUG_FORTH_STACK_GUARD 
1a2a cd d1 5f				call check_stacks 
1a2d				endif 
1a2d e5				push hl 
1a2e d5				push de 
1a2f eb				ex de,hl 
1a30 2a 1f f8			ld hl,(cli_data_sp) 
1a33 23				inc hl 
1a34 23				inc hl 
1a35			 
1a35			; PARSEV5 
1a35 23				inc hl 
1a36 22 1f f8			ld (cli_data_sp),hl 
1a39 73				ld (hl), e 
1a3a 23				inc hl 
1a3b 72				ld (hl), d 
1a3c d1				pop de 
1a3d e1				pop hl 
1a3e				if DEBUG_FORTH_STACK_GUARD 
1a3e cd d1 5f				call check_stacks 
1a41				endif 
1a41 c9				ret 
1a42			 
1a42			 
1a42			; increase ret stack pointer and save hl to it 
1a42				 
1a42			FORTH_RSP_NEXT: macro 
1a42				call macro_forth_rsp_next 
1a42				endm 
1a42			 
1a42			macro_forth_rsp_next: 
1a42				if DEBUG_FORTH_STACK_GUARD 
1a42 cd d1 5f				call check_stacks 
1a45				endif 
1a45 e5				push hl 
1a46 d5				push de 
1a47 eb				ex de,hl 
1a48 2a 23 f8			ld hl,(cli_ret_sp) 
1a4b 23				inc hl 
1a4c 23				inc hl 
1a4d 22 23 f8			ld (cli_ret_sp),hl 
1a50 73				ld (hl), e 
1a51 23				inc hl 
1a52 72				ld (hl), d 
1a53 d1				pop de 
1a54 e1				pop hl 
1a55				if DEBUG_FORTH_STACK_GUARD 
1a55 cd d1 5f				call check_stacks 
1a58				endif 
1a58 c9				ret 
1a59			 
1a59			; get current ret stack pointer and save to hl  
1a59				 
1a59			FORTH_RSP_TOS: macro 
1a59				call macro_forth_rsp_tos 
1a59				endm 
1a59			 
1a59			macro_forth_rsp_tos: 
1a59				;push de 
1a59 2a 23 f8			ld hl,(cli_ret_sp) 
1a5c cd 94 1a			call loadhlptrtohl 
1a5f				;ld e, (hl) 
1a5f				;inc hl 
1a5f				;ld d, (hl) 
1a5f				;ex de, hl 
1a5f					if DEBUG_FORTH_WORDS 
1a5f			;			DMARK "RST" 
1a5f						CALLMONITOR 
1a5f cd 01 15			call break_point_state  
1a62				endm  
# End of macro CALLMONITOR
1a62					endif 
1a62				;pop de 
1a62 c9				ret 
1a63			 
1a63			; pop ret stack pointer 
1a63				 
1a63			FORTH_RSP_POP: macro 
1a63				call macro_forth_rsp_pop 
1a63				endm 
1a63			 
1a63			 
1a63			macro_forth_rsp_pop: 
1a63				if DEBUG_FORTH_STACK_GUARD 
1a63			;		DMARK "RPP" 
1a63 cd d1 5f				call check_stacks 
1a66					FORTH_CHK_RSP_UNDER 
1a66 e5				push hl 
1a67 d5				push de 
1a68 2a 23 f8			ld hl,(cli_ret_sp) 
1a6b 11 9d f7			ld de, cli_ret_stack 
1a6e cd dd 0c			call cmp16 
1a71 da e5 60			jp c, fault_rsp_under 
1a74 d1				pop de 
1a75 e1				pop hl 
1a76				endm 
# End of macro FORTH_CHK_RSP_UNDER
1a76				endif 
1a76 e5				push hl 
1a77 2a 23 f8			ld hl,(cli_ret_sp) 
1a7a			 
1a7a			 
1a7a				if FORTH_ENABLE_FREE 
1a7a			 
1a7a					; get pointer 
1a7a			 
1a7a					push de 
1a7a					push hl 
1a7a			 
1a7a					ld e, (hl) 
1a7a					inc hl 
1a7a					ld d, (hl) 
1a7a			 
1a7a					ex de, hl 
1a7a					call free 
1a7a			 
1a7a					pop hl 
1a7a					pop de 
1a7a			 
1a7a			 
1a7a				endif 
1a7a			 
1a7a			 
1a7a 2b				dec hl 
1a7b 2b				dec hl 
1a7c 22 23 f8			ld (cli_ret_sp), hl 
1a7f				; do stack underflow checks 
1a7f e1				pop hl 
1a80				if DEBUG_FORTH_STACK_GUARD 
1a80 cd d1 5f				call check_stacks 
1a83					FORTH_CHK_RSP_UNDER 
1a83 e5				push hl 
1a84 d5				push de 
1a85 2a 23 f8			ld hl,(cli_ret_sp) 
1a88 11 9d f7			ld de, cli_ret_stack 
1a8b cd dd 0c			call cmp16 
1a8e da e5 60			jp c, fault_rsp_under 
1a91 d1				pop de 
1a92 e1				pop hl 
1a93				endm 
# End of macro FORTH_CHK_RSP_UNDER
1a93				endif 
1a93 c9				ret 
1a94			 
1a94			 
1a94			 
1a94			; routine to load word pointed to by hl into hl 
1a94			 
1a94			loadhlptrtohl: 
1a94			 
1a94 d5				push de 
1a95 5e				ld e, (hl) 
1a96 23				inc hl 
1a97 56				ld d, (hl) 
1a98 eb				ex de, hl 
1a99 d1				pop de 
1a9a			 
1a9a c9				ret 
1a9b			 
1a9b			 
1a9b			 
1a9b			 
1a9b			 
1a9b			; push a number held in HL onto the data stack 
1a9b			; entry point for pushing a value when already in hl used in function above 
1a9b			 
1a9b			forth_push_numhl: 
1a9b			 
1a9b e5				push hl    ; save value to push 
1a9c			 
1a9c			if DEBUG_FORTH_PUSH 
1a9c				; see if disabled 
1a9c			 
1a9c			 
1a9c				push af 
1a9c				ld a, (os_view_disable) 
1a9c				cp '*' 
1a9c				jr z, .pskip2 
1a9c				push hl 
1a9c			push hl 
1a9c				call clear_display 
1a9c			pop hl 
1a9c				ld a,h 
1a9c				ld hl, os_word_scratch 
1a9c				call hexout 
1a9c				pop hl 
1a9c				ld a,l 
1a9c				ld hl, os_word_scratch+2 
1a9c				call hexout 
1a9c			 
1a9c				ld hl, os_word_scratch+4 
1a9c				ld a,0 
1a9c				ld (hl),a 
1a9c				ld de,os_word_scratch 
1a9c					ld a, display_row_2 
1a9c					call str_at_display 
1a9c				ld de, .push_num 
1a9c				ld a, display_row_1 
1a9c			 
1a9c					call str_at_display 
1a9c			 
1a9c			 
1a9c				call update_display 
1a9c				call delay1s 
1a9c				call delay1s 
1a9c			.pskip2:  
1a9c			 
1a9c				pop af 
1a9c			endif	 
1a9c			 
1a9c			 
1a9c				FORTH_DSP_NEXT 
1a9c cd 2a 1a			call macro_forth_dsp_next 
1a9f				endm 
# End of macro FORTH_DSP_NEXT
1a9f			 
1a9f 2a 1f f8			ld hl, (cli_data_sp) 
1aa2			 
1aa2				; save item type 
1aa2 3e 02			ld a,  DS_TYPE_INUM 
1aa4 77				ld (hl), a 
1aa5 23				inc hl 
1aa6			 
1aa6				; get word off stack 
1aa6 d1				pop de 
1aa7 7b				ld a,e 
1aa8 77				ld (hl), a 
1aa9 23				inc hl 
1aaa 7a				ld a,d 
1aab 77				ld (hl), a 
1aac			 
1aac			if DEBUG_FORTH_PUSH 
1aac				dec hl 
1aac				dec hl 
1aac				dec hl 
1aac						DMARK "PH5" 
1aac				CALLMONITOR 
1aac			endif	 
1aac			 
1aac c9				ret 
1aad			 
1aad			 
1aad			; Push a string to stack pointed to by hl 
1aad			 
1aad			forth_push_str: 
1aad			 
1aad			if DEBUG_FORTH_PUSH 
1aad						DMARK "PSQ" 
1aad				CALLMONITOR 
1aad			endif	 
1aad			    
1aad e5				push hl 
1aae e5				push hl 
1aaf			 
1aaf 3e 00			ld a, 0   ; find end of string 
1ab1 cd 28 11			call strlent       
1ab4			if DEBUG_FORTH_PUSH 
1ab4						DMARK "PQ2" 
1ab4				CALLMONITOR 
1ab4			endif	 
1ab4 eb				ex de, hl 
1ab5 e1				pop hl   ; get ptr to start of string 
1ab6			if DEBUG_FORTH_PUSH 
1ab6						DMARK "PQ3" 
1ab6				CALLMONITOR 
1ab6			endif	 
1ab6 19				add hl,de 
1ab7			if DEBUG_FORTH_PUSH 
1ab7						DMARK "PQE" 
1ab7				CALLMONITOR 
1ab7			endif	 
1ab7			 
1ab7 2b				dec hl    ; see if there is an optional trailing double quote 
1ab8 7e				ld a,(hl) 
1ab9 fe 22			cp '"' 
1abb 20 03			jr nz, .strnoq 
1abd 3e 00			ld a, 0      ; get rid of double quote 
1abf 77				ld (hl), a 
1ac0 23			.strnoq: inc hl 
1ac1			 
1ac1 3e 00			ld a, 0 
1ac3 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1ac4			 
1ac4 13				inc de ; add one for the type string 
1ac5 13				inc de ; add one for null term??? 
1ac6			 
1ac6				; tos is get string pointer again 
1ac6				; de contains space to allocate 
1ac6				 
1ac6 d5				push de 
1ac7			 
1ac7 eb				ex de, hl 
1ac8			 
1ac8				;push af 
1ac8			 
1ac8			if DEBUG_FORTH_PUSH 
1ac8						DMARK "PHm" 
1ac8				CALLMONITOR 
1ac8			endif	 
1ac8 cd 86 11			call malloc	; on ret hl now contains allocated memory 
1acb				if DEBUG_FORTH_MALLOC_GUARD 
1acb cc 37 4f				call z,malloc_error 
1ace				endif 
1ace			 
1ace				 
1ace c1				pop bc    ; get length 
1acf d1				pop de   ;  get string start    
1ad0			 
1ad0				; hl has destination from malloc 
1ad0			 
1ad0 eb				ex de, hl    ; prep for ldir 
1ad1			 
1ad1 e5				push hl   ; save malloc area for DSP later 
1ad2			 
1ad2			if DEBUG_FORTH_PUSH 
1ad2						DMARK "PHc" 
1ad2				CALLMONITOR 
1ad2			endif	 
1ad2			 
1ad2			 
1ad2 ed b0			ldir 
1ad4			 
1ad4			 
1ad4				; push malloc to data stack     macro?????  
1ad4			 
1ad4				FORTH_DSP_NEXT 
1ad4 cd 2a 1a			call macro_forth_dsp_next 
1ad7				endm 
# End of macro FORTH_DSP_NEXT
1ad7			 
1ad7				; save value and type 
1ad7			 
1ad7 2a 1f f8			ld hl, (cli_data_sp) 
1ada			 
1ada				; save item type 
1ada 3e 01			ld a,  DS_TYPE_STR 
1adc 77				ld (hl), a 
1add 23				inc hl 
1ade			 
1ade				; get malloc word off stack 
1ade d1				pop de 
1adf 73				ld (hl), e 
1ae0 23				inc hl 
1ae1 72				ld (hl), d 
1ae2			 
1ae2			 
1ae2			 
1ae2			if DEBUG_FORTH_PUSH 
1ae2				ld hl, (cli_data_sp) 
1ae2						DMARK "PHS" 
1ae2				CALLMONITOR 
1ae2			;	ex de,hl 
1ae2			endif	 
1ae2				; in case of spaces, skip the ptr past the copied string 
1ae2				;pop af 
1ae2				;ld (cli_origptr),hl 
1ae2			 
1ae2 c9				ret 
1ae3			 
1ae3			 
1ae3			 
1ae3			; TODO ascii push input onto stack given hl to start of input 
1ae3			 
1ae3			; identify type 
1ae3			; if starts with a " then a string 
1ae3			; otherwise it is a number 
1ae3			;  
1ae3			; if a string 
1ae3			;     scan for ending " to get length of string to malloc for + 1 
1ae3			;     malloc 
1ae3			;     put pointer to string on stack first byte flags as string 
1ae3			; 
1ae3			; else a number 
1ae3			;    look for number format identifier 
1ae3			;    $xx hex 
1ae3			;    %xxxxx bin 
1ae3			;    xxxxx decimal 
1ae3			;    convert number to 16bit word.  
1ae3			;    malloc word + 1 with flag to identiy as num 
1ae3			;    put pointer to number on stack 
1ae3			;   
1ae3			;  
1ae3			  
1ae3			forth_apush: 
1ae3				; kernel push 
1ae3			 
1ae3			if DEBUG_FORTH_PUSH 
1ae3						DMARK "PSH" 
1ae3				CALLMONITOR 
1ae3			endif	 
1ae3				; identify input type 
1ae3			 
1ae3 7e				ld a,(hl) 
1ae4 fe 22			cp '"' 
1ae6 28 0a			jr z, .fapstr 
1ae8 fe 24			cp '$' 
1aea ca 12 1b			jp z, .faphex 
1aed fe 25			cp '%' 
1aef ca fa 1a			jp z, .fapbin 
1af2			;	cp 'b' 
1af2			;	jp z, .fabin 
1af2				; else decimal 
1af2			 
1af2				; TODO do decimal conversion 
1af2				; decimal is stored as a 16bit word 
1af2			 
1af2				; by default everything is a string if type is not detected 
1af2			.fapstr: ; 
1af2 fe 22			cp '"' 
1af4 20 01			jr nz, .strnoqu 
1af6 23				inc hl 
1af7			.strnoqu: 
1af7 c3 ad 1a			jp forth_push_str 
1afa			 
1afa			 
1afa			 
1afa			.fapbin:    ; push a binary string.  
1afa 11 00 00			ld de, 0   ; hold a 16bit value 
1afd			 
1afd 23			.fapbinshift:	inc hl  
1afe 7e				ld a,(hl) 
1aff fe 00			cp 0     ; done scanning  
1b01 28 0b			jr z, .fapbdone  	; got it in HL so push  
1b03			 
1b03				; left shift de 
1b03 eb				ex de, hl	 
1b04 29				add hl, hl 
1b05			 
1b05				; is 1 
1b05 fe 31			cp '1' 
1b07 20 02			jr nz, .binzero 
1b09 cb 4d			bit 1, l 
1b0b			.binzero: 
1b0b eb				ex de, hl	 ; save current de 
1b0c 18 ef			jr .fapbinshift 
1b0e			 
1b0e			.fapbdone: 
1b0e eb				ex de, hl 
1b0f c3 9b 1a			jp forth_push_numhl 
1b12			 
1b12			 
1b12			.faphex:   ; hex is always stored as a 16bit word 
1b12				; skip number prefix 
1b12 23				inc hl 
1b13				; turn ascii into number 
1b13 cd 76 10			call get_word_hl	; ret 16bit word in hl 
1b16			 
1b16 c3 9b 1a			jp forth_push_numhl 
1b19			 
1b19 00				 nop 
1b1a			 
1b1a			.fabin:   ; TODO bin conversion 
1b1a			 
1b1a			 
1b1a c9				ret 
1b1b			 
1b1b			 
1b1b			; get either a string ptr or a 16bit word from the data stack 
1b1b			 
1b1b			FORTH_DSP: macro 
1b1b				call macro_forth_dsp 
1b1b				endm 
1b1b			 
1b1b			macro_forth_dsp: 
1b1b				; data stack pointer points to current word on tos 
1b1b			 
1b1b 2a 1f f8			ld hl,(cli_data_sp) 
1b1e			 
1b1e				if DEBUG_FORTH_PUSH 
1b1e						DMARK "DSP" 
1b1e			 
1b1e					call display_data_sp 
1b1e				;call break_point_state 
1b1e				;rst 030h 
1b1e				CALLMONITOR 
1b1e				endif 
1b1e			 
1b1e c9				ret 
1b1f			 
1b1f			; return hl to start of value on stack 
1b1f			 
1b1f			FORTH_DSP_VALUE: macro 
1b1f				call macro_forth_dsp_value 
1b1f				endm 
1b1f			 
1b1f			macro_forth_dsp_value: 
1b1f			 
1b1f				FORTH_DSP 
1b1f cd 1b 1b			call macro_forth_dsp 
1b22				endm 
# End of macro FORTH_DSP
1b22			 
1b22 d5				push de 
1b23			 
1b23 23				inc hl ; skip type 
1b24			 
1b24 5e				ld e, (hl) 
1b25 23				inc hl 
1b26 56				ld d, (hl) 
1b27 eb				ex de,hl  
1b28			 
1b28 d1				pop de 
1b29			 
1b29 c9				ret 
1b2a			 
1b2a			; return hl to start of value to second item on stack 
1b2a			 
1b2a			FORTH_DSP_VALUEM1: macro 
1b2a				call macro_forth_dsp_value_m1 
1b2a				endm 
1b2a			 
1b2a			macro_forth_dsp_value_m1: 
1b2a			 
1b2a				FORTH_DSP 
1b2a cd 1b 1b			call macro_forth_dsp 
1b2d				endm 
# End of macro FORTH_DSP
1b2d			 
1b2d 2b				dec hl 
1b2e 2b				dec hl 
1b2f			;	dec hl 
1b2f			 
1b2f d5				push de 
1b30			 
1b30 5e				ld e, (hl) 
1b31 23				inc hl 
1b32 56				ld d, (hl) 
1b33 eb				ex de,hl  
1b34			 
1b34 d1				pop de 
1b35			 
1b35 c9				ret 
1b36			 
1b36				 
1b36			 
1b36			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1b36			 
1b36			FORTH_DSP_POP: macro 
1b36				call macro_forth_dsp_pop 
1b36				endm 
1b36			 
1b36			 
1b36			; get the tos data type 
1b36			 
1b36			FORTH_DSP_TYPE:   macro 
1b36			 
1b36				;FORTH_DSP_VALUE 
1b36				FORTH_DSP 
1b36				 
1b36				; hl points to value 
1b36				; check type 
1b36			 
1b36				ld a,(hl) 
1b36			 
1b36				endm 
1b36			 
1b36			; load the tos value into hl 
1b36			 
1b36			 
1b36			FORTH_DSP_VALUEHL:  macro 
1b36				call macro_dsp_valuehl 
1b36				endm 
1b36			 
1b36			 
1b36			 
1b36			macro_dsp_valuehl: 
1b36				FORTH_DSP_VALUE 
1b36 cd 1f 1b			call macro_forth_dsp_value 
1b39				endm 
# End of macro FORTH_DSP_VALUE
1b39			 
1b39				;FORTH_ERR_TOS_NOTNUM 
1b39			 
1b39				;inc hl   ; skip type id 
1b39			 
1b39			;	push de 
1b39			; 
1b39			;	ld e, (hl) 
1b39			;	inc hl 
1b39			;	ld d, (hl) 
1b39			;	ex de,hl  
1b39			 
1b39			;	pop de 
1b39			 
1b39				if DEBUG_FORTH_PUSH 
1b39						DMARK "DVL" 
1b39				CALLMONITOR 
1b39				endif 
1b39 c9				ret 
1b3a			 
1b3a			forth_apushstrhl:      
1b3a				; push of string requires use of cli_origptr 
1b3a				; bodge use 
1b3a			 
1b3a				; get current cli_origptr, save, update with temp pointer  
1b3a ed 5b 3b f8		ld de, (cli_origptr) 
1b3e 22 3b f8			ld (cli_origptr), hl 
1b41 d5				push de 
1b42 cd e3 1a			call forth_apush 
1b45 d1				pop de 
1b46 ed 53 3b f8		ld (cli_origptr), de 
1b4a c9			        ret	 
1b4b			 
1b4b			 
1b4b			; increase loop stack pointer and save hl to it 
1b4b				 
1b4b			FORTH_LOOP_NEXT: macro 
1b4b				call macro_forth_loop_next 
1b4b				;nop 
1b4b				endm 
1b4b			 
1b4b			macro_forth_loop_next: 
1b4b				if DEBUG_FORTH_STACK_GUARD 
1b4b cd d1 5f				call check_stacks 
1b4e				endif 
1b4e e5				push hl 
1b4f d5				push de 
1b50 eb				ex de,hl 
1b51 2a 21 f8			ld hl,(cli_loop_sp) 
1b54 23				inc hl 
1b55 23				inc hl 
1b56					if DEBUG_FORTH_WORDS 
1b56						DMARK "LNX" 
1b56 f5				push af  
1b57 3a 6b 1b			ld a, (.dmark)  
1b5a 32 77 fb			ld (debug_mark),a  
1b5d 3a 6c 1b			ld a, (.dmark+1)  
1b60 32 78 fb			ld (debug_mark+1),a  
1b63 3a 6d 1b			ld a, (.dmark+2)  
1b66 32 79 fb			ld (debug_mark+2),a  
1b69 18 03			jr .pastdmark  
1b6b ..			.dmark: db "LNX"  
1b6e f1			.pastdmark: pop af  
1b6f			endm  
# End of macro DMARK
1b6f						CALLMONITOR 
1b6f cd 01 15			call break_point_state  
1b72				endm  
# End of macro CALLMONITOR
1b72					endif 
1b72 22 21 f8			ld (cli_loop_sp),hl 
1b75 73				ld (hl), e 
1b76 23				inc hl 
1b77 72				ld (hl), d 
1b78 d1				pop de    ; been reversed so save a swap on restore 
1b79 e1				pop hl 
1b7a				if DEBUG_FORTH_STACK_GUARD 
1b7a cd d1 5f				call check_stacks 
1b7d				endif 
1b7d c9				ret 
1b7e			 
1b7e			; get current ret stack pointer and save to hl  
1b7e				 
1b7e			FORTH_LOOP_TOS: macro 
1b7e				call macro_forth_loop_tos 
1b7e				endm 
1b7e			 
1b7e			macro_forth_loop_tos: 
1b7e d5				push de 
1b7f 2a 21 f8			ld hl,(cli_loop_sp) 
1b82 5e				ld e, (hl) 
1b83 23				inc hl 
1b84 56				ld d, (hl) 
1b85 eb				ex de, hl 
1b86 d1				pop de 
1b87 c9				ret 
1b88			 
1b88			; pop loop stack pointer 
1b88				 
1b88			FORTH_LOOP_POP: macro 
1b88				call macro_forth_loop_pop 
1b88				endm 
1b88			 
1b88			 
1b88			macro_forth_loop_pop: 
1b88				if DEBUG_FORTH_STACK_GUARD 
1b88					DMARK "LPP" 
1b88 f5				push af  
1b89 3a 9d 1b			ld a, (.dmark)  
1b8c 32 77 fb			ld (debug_mark),a  
1b8f 3a 9e 1b			ld a, (.dmark+1)  
1b92 32 78 fb			ld (debug_mark+1),a  
1b95 3a 9f 1b			ld a, (.dmark+2)  
1b98 32 79 fb			ld (debug_mark+2),a  
1b9b 18 03			jr .pastdmark  
1b9d ..			.dmark: db "LPP"  
1ba0 f1			.pastdmark: pop af  
1ba1			endm  
# End of macro DMARK
1ba1 cd d1 5f				call check_stacks 
1ba4					FORTH_CHK_LOOP_UNDER 
1ba4 e5				push hl 
1ba5 d5				push de 
1ba6 2a 21 f8			ld hl,(cli_loop_sp) 
1ba9 11 9b f5			ld de, cli_loop_stack 
1bac cd dd 0c			call cmp16 
1baf da eb 60			jp c, fault_loop_under 
1bb2 d1				pop de 
1bb3 e1				pop hl 
1bb4				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1bb4				endif 
1bb4 e5				push hl 
1bb5 2a 21 f8			ld hl,(cli_loop_sp) 
1bb8 2b				dec hl 
1bb9 2b				dec hl 
1bba 22 21 f8			ld (cli_loop_sp), hl 
1bbd				; TODO do stack underflow checks 
1bbd e1				pop hl 
1bbe				if DEBUG_FORTH_STACK_GUARD 
1bbe cd d1 5f				call check_stacks 
1bc1					FORTH_CHK_LOOP_UNDER 
1bc1 e5				push hl 
1bc2 d5				push de 
1bc3 2a 21 f8			ld hl,(cli_loop_sp) 
1bc6 11 9b f5			ld de, cli_loop_stack 
1bc9 cd dd 0c			call cmp16 
1bcc da eb 60			jp c, fault_loop_under 
1bcf d1				pop de 
1bd0 e1				pop hl 
1bd1				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1bd1				endif 
1bd1 c9				ret 
1bd2			 
1bd2			macro_forth_dsp_pop: 
1bd2			 
1bd2 e5				push hl 
1bd3			 
1bd3				; release malloc data 
1bd3			 
1bd3				if DEBUG_FORTH_STACK_GUARD 
1bd3 cd d1 5f				call check_stacks 
1bd6					FORTH_CHK_DSP_UNDER 
1bd6 e5				push hl 
1bd7 d5				push de 
1bd8 2a 1f f8			ld hl,(cli_data_sp) 
1bdb 11 99 f3			ld de, cli_data_stack 
1bde cd dd 0c			call cmp16 
1be1 da df 60			jp c, fault_dsp_under 
1be4 d1				pop de 
1be5 e1				pop hl 
1be6				endm 
# End of macro FORTH_CHK_DSP_UNDER
1be6				endif 
1be6				;ld hl,(cli_data_sp) 
1be6			if DEBUG_FORTH_DOT 
1be6				DMARK "DPP" 
1be6				CALLMONITOR 
1be6			endif	 
1be6			 
1be6			 
1be6			if FORTH_ENABLE_DSPPOPFREE 
1be6			 
1be6				FORTH_DSP 
1be6 cd 1b 1b			call macro_forth_dsp 
1be9				endm 
# End of macro FORTH_DSP
1be9			 
1be9 7e				ld a, (hl) 
1bea fe 01			cp DS_TYPE_STR 
1bec 20 07			jr nz, .skippopfree 
1bee			 
1bee				FORTH_DSP_VALUEHL 
1bee cd 36 1b			call macro_dsp_valuehl 
1bf1				endm 
# End of macro FORTH_DSP_VALUEHL
1bf1 00				nop 
1bf2			if DEBUG_FORTH_DOT 
1bf2				DMARK "DPf" 
1bf2				CALLMONITOR 
1bf2			endif	 
1bf2 cd 50 12			call free 
1bf5			.skippopfree: 
1bf5				 
1bf5			 
1bf5			endif 
1bf5			 
1bf5			if DEBUG_FORTH_DOT_KEY 
1bf5				DMARK "DP2" 
1bf5				CALLMONITOR 
1bf5			endif	 
1bf5			 
1bf5				; move pointer down 
1bf5			 
1bf5 2a 1f f8			ld hl,(cli_data_sp) 
1bf8 2b				dec hl 
1bf9 2b				dec hl 
1bfa			; PARSEV5 
1bfa 2b				dec hl 
1bfb 22 1f f8			ld (cli_data_sp), hl 
1bfe			 
1bfe				if DEBUG_FORTH_STACK_GUARD 
1bfe cd d1 5f				call check_stacks 
1c01					FORTH_CHK_DSP_UNDER 
1c01 e5				push hl 
1c02 d5				push de 
1c03 2a 1f f8			ld hl,(cli_data_sp) 
1c06 11 99 f3			ld de, cli_data_stack 
1c09 cd dd 0c			call cmp16 
1c0c da df 60			jp c, fault_dsp_under 
1c0f d1				pop de 
1c10 e1				pop hl 
1c11				endm 
# End of macro FORTH_CHK_DSP_UNDER
1c11				endif 
1c11			 
1c11 e1				pop hl 
1c12			 
1c12 c9				ret 
1c13			 
1c13			getwordathl: 
1c13				; hl points to an address 
1c13				; load hl with the word at that address 
1c13			 
1c13 d5				push de 
1c14			 
1c14 5e				ld e, (hl) 
1c15 23				inc hl 
1c16 56				ld d, (hl) 
1c17 eb				ex de, hl 
1c18			 
1c18 d1				pop de 
1c19 c9				ret 
1c1a			 
1c1a			 
1c1a			 
1c1a			 
1c1a			 
1c1a			; eof 
1c1a			 
# End of file forth_stackopsv5.asm
1c1a			endif 
1c1a			 
1c1a			user_word_eol:  
1c1a				; hl contains the pointer to where to create a linked list item from the end 
1c1a				; of the user dict to continue on at the system word dict 
1c1a				 
1c1a				; poke the stub of the word list linked list to repoint to rom words 
1c1a			 
1c1a				; stub format 
1c1a				; db   word id 
1c1a				; dw    link to next word 
1c1a			        ; db char length of token 
1c1a				; db string + 0 term 
1c1a				; db exec code....  
1c1a			 
1c1a 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1c1c 77				ld (hl), a		; word id 
1c1d 23				inc hl 
1c1e			 
1c1e 11 e4 1d			ld de, sysdict 
1c21 73				ld (hl), e		; next word link ie system dict 
1c22 23				inc hl 
1c23 72				ld (hl), d		; next word link ie system dict 
1c24 23				inc hl	 
1c25			 
1c25			;	ld (hl), sysdict		; next word link ie system dict 
1c25			;	inc hl 
1c25			;	inc hl 
1c25			 
1c25			;	inc hl 
1c25			;	inc hl 
1c25			 
1c25 3e 02			ld a, 2			; word length is 0 
1c27 77				ld (hl), a	 
1c28 23				inc hl 
1c29			 
1c29 3e 7e			ld a, '~'			; word length is 0 
1c2b 77				ld (hl), a	 
1c2c 23				inc hl 
1c2d 3e 00			ld a, 0			; save empty word 
1c2f 77				ld (hl), a 
1c30			 
1c30 c9				ret 
1c31			 
1c31				 
1c31			 
1c31			forthexec_cleanup: 
1c31				FORTH_RSP_POP 
1c31 cd 63 1a			call macro_forth_rsp_pop 
1c34				endm 
# End of macro FORTH_RSP_POP
1c34 c9				ret 
1c35			 
1c35			forth_call_hl: 
1c35				; taking hl 
1c35 e5				push hl 
1c36 c9				ret 
1c37			 
1c37			; this is called to reset Forth system but keep existing uwords etc 
1c37			 
1c37			forth_warmstart: 
1c37				; setup stack over/under flow checks 
1c37				if DEBUG_FORTH_STACK_GUARD 
1c37 cd b7 5f				call chk_stk_init 
1c3a				endif 
1c3a			 
1c3a				; init stack pointers  - * these stacks go upwards *  
1c3a 21 9d f7			ld hl, cli_ret_stack 
1c3d 22 23 f8			ld (cli_ret_sp), hl	 
1c40				; set bottom of stack 
1c40 3e 00			ld a,0 
1c42 77				ld (hl),a 
1c43 23				inc hl 
1c44 77				ld (hl),a 
1c45			 
1c45 21 99 f3			ld hl, cli_data_stack 
1c48 22 1f f8			ld (cli_data_sp), hl	 
1c4b				; set bottom of stack 
1c4b 3e 00			ld a,0 
1c4d 77				ld (hl),a 
1c4e 23				inc hl 
1c4f 77				ld (hl),a 
1c50			 
1c50 21 9b f5			ld hl, cli_loop_stack 
1c53 22 21 f8			ld (cli_loop_sp), hl	 
1c56				; set bottom of stack 
1c56 3e 00			ld a,0 
1c58 77				ld (hl),a 
1c59 23				inc hl 
1c5a 77				ld (hl),a 
1c5b			 
1c5b				; init extent of current open file 
1c5b			 
1c5b 3e 00			ld a, 0 
1c5d 32 59 f8			ld (store_openext), a 
1c60			 
1c60 c9				ret 
1c61			 
1c61			 
1c61			; Cold Start - this is called to setup the whole Forth system 
1c61			 
1c61			forth_init: 
1c61			 
1c61				; setup stack over/under flow checks 
1c61			 
1c61			;	if DEBUG_FORTH_STACK_GUARD 
1c61			;		call chk_stk_init 
1c61			;	endif 
1c61			 
1c61				; enable auto display updates (slow.....) 
1c61			 
1c61 3e 01			ld a, 1 
1c63 32 39 f8			ld (cli_autodisplay), a 
1c66			 
1c66			 
1c66			 
1c66				; show start up screen 
1c66			 
1c66 cd 8f 0a			call clear_display 
1c69			 
1c69 3e 00			ld a,0 
1c6b 32 5b f8			ld (f_cursor_ptr), a 
1c6e			 
1c6e				; set start of word list in start of ram - for use when creating user words 
1c6e			 
1c6e 21 00 80			ld hl, baseram 
1c71 22 2f f1			ld (os_last_new_uword), hl 
1c74 cd 1a 1c			call user_word_eol 
1c77				 
1c77			;		call display_data_sp 
1c77			;		call next_page_prompt 
1c77			 
1c77			 
1c77			 
1c77			 
1c77 c9				ret 
1c78			 
1c78 .. 00		.bootforth: db " Forth Kernel Init ",0 
1c8c			 
1c8c			; TODO push to stack 
1c8c			 
1c8c			;  
1c8c			 
1c8c			if FORTH_PARSEV2 
1c8c			 
1c8c			 
1c8c				include "forth_parserv2.asm" 
1c8c			 
1c8c			endif 
1c8c			 
1c8c			 
1c8c			; parse cli version 1 
1c8c			 
1c8c			if FORTH_PARSEV1 
1c8c			 
1c8c			 
1c8c			 
1c8c			      include "forth_parserv1.asm" 
1c8c			endif 
1c8c				 
1c8c			if FORTH_PARSEV3 
1c8c			 
1c8c			 
1c8c			 
1c8c			      include "forth_parserv3.asm" 
1c8c				include "forth_wordsv3.asm" 
1c8c			endif 
1c8c			 
1c8c			if FORTH_PARSEV4 
1c8c			 
1c8c			 
1c8c			 
1c8c			      include "forth_parserv4.asm" 
1c8c				include "forth_wordsv4.asm" 
1c8c			endif 
1c8c			 
1c8c			if FORTH_PARSEV5 
1c8c			 
1c8c			 
1c8c			 
1c8c			      include "forth_parserv5.asm" 
1c8c			 
1c8c			 
1c8c			; A better parser without using malloc and string copies all over the place.  
1c8c			; Exec in situ should be faster 
1c8c			 
1c8c			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1c8c			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1c8c			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1c8c			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1c8c			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1c8c			WORD_SYS_END: equ 0   ; Opcode for all user words 
1c8c			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1c8c			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1c8c			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1c8c			 
1c8c			; Core word preamble macro 
1c8c			 
1c8c			CWHEAD:   macro nxtword opcode lit len opflags 
1c8c				db WORD_SYS_CORE+opcode             
1c8c				; internal op code number 
1c8c				dw nxtword            
1c8c				; link to next dict word block 
1c8c				db len + 1 
1c8c				; literal length of dict word inc zero term 
1c8c				db lit,0              
1c8c				; literal dict word 
1c8c			        ; TODO db opflags        
1c8c				endm 
1c8c			 
1c8c			 
1c8c			NEXTW: macro  
1c8c				jp macro_next 
1c8c				endm 
1c8c			 
1c8c			macro_next: 
1c8c			if DEBUG_FORTH_PARSE_KEY 
1c8c				DMARK "NXT" 
1c8c				CALLMONITOR 
1c8c			endif	 
1c8c			;	inc hl  ; skip token null term  
1c8c ed 4b 3d f8		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1c90 ed 5b 3b f8		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1c94 2a 33 f1			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1c97			if DEBUG_FORTH_PARSE_KEY 
1c97				DMARK "}AA" 
1c97				CALLMONITOR 
1c97			endif	 
1c97 c3 9a 1d			jp execnext 
1c9a				;jp exec1 
1c9a			       
1c9a			 
1c9a			 
1c9a			; Another go at the parser to compile  
1c9a			 
1c9a			 
1c9a			; TODO rework parser to change all of the string words to byte tokens 
1c9a			; TODO do a search for  
1c9a			 
1c9a			; TODO first run normal parser to zero term sections 
1c9a			; TODO for each word do a token look up to get the op code 
1c9a			; TODO need some means to flag to the exec that this is a byte code form    
1c9a			 
1c9a			 
1c9a			forthcompile: 
1c9a			 
1c9a			; 
1c9a			; line parse: 
1c9a			;       parse raw input buffer 
1c9a			;       tokenise the words 
1c9a			;       malloc new copy (for looping etc) 
1c9a			;       copy to malloc + current pc in line to start of string and add line term 
1c9a			;       save on new rsp 
1c9a			; 
1c9a			 
1c9a			; hl to point to the line to tokenise 
1c9a			 
1c9a			;	push hl 
1c9a 22 33 f1			ld (os_tok_ptr), hl  ; save ptr to string 
1c9d			 
1c9d			;	ld a,0		; string term on input 
1c9d			;	call strlent 
1c9d			 
1c9d			;	ld (os_tok_len), hl	 ; save string length 
1c9d			 
1c9d			;if DEBUG_FORTH_TOK 
1c9d			;	ex de,hl		 
1c9d			;endif 
1c9d			 
1c9d			;	pop hl 		; get back string pointer 
1c9d			 
1c9d			if DEBUG_FORTH_TOK 
1c9d						DMARK "TOc" 
1c9d				CALLMONITOR 
1c9d			endif 
1c9d 7e			.cptoken2:    ld a,(hl) 
1c9e 23				inc hl 
1c9f fe 7f			cp FORTH_END_BUFFER 
1ca1 28 29			jr z, .cptokendone2 
1ca3 fe 00			cp 0 
1ca5 28 25			jr z, .cptokendone2 
1ca7 fe 22			cp '"' 
1ca9 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1cab fe 20			cp ' ' 
1cad 20 ee			jr nz,  .cptoken2 
1caf			 
1caf			; TODO consume comments held between ( and ) 
1caf			 
1caf				; we have a space so change to zero term for dict match later 
1caf 2b				dec hl 
1cb0 3e 00			ld a,0 
1cb2 77				ld (hl), a 
1cb3 23				inc hl 
1cb4 18 e7			jr .cptoken2 
1cb6				 
1cb6			 
1cb6			.cptokenstr2: 
1cb6				; skip all white space until either eol (because forgot to term) or end double quote 
1cb6			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1cb6				;inc hl ; skip current double quote 
1cb6 7e				ld a,(hl) 
1cb7 23				inc hl 
1cb8 fe 22			cp '"' 
1cba 28 e1			jr z, .cptoken2 
1cbc fe 7f			cp FORTH_END_BUFFER 
1cbe 28 0c			jr z, .cptokendone2 
1cc0 fe 00			cp 0 
1cc2 28 08			jr z, .cptokendone2 
1cc4 fe 20			cp ' ' 
1cc6 28 02			jr z, .cptmp2 
1cc8 18 ec			jr .cptokenstr2 
1cca			 
1cca			.cptmp2:	; we have a space so change to zero term for dict match later 
1cca				;dec hl 
1cca				;ld a,"-"	; TODO remove this when working 
1cca				;ld (hl), a 
1cca				;inc hl 
1cca 18 ea			jr .cptokenstr2 
1ccc			 
1ccc			.cptokendone2: 
1ccc				;inc hl 
1ccc 3e 7f			ld a, FORTH_END_BUFFER 
1cce 77				ld (hl),a 
1ccf 23				inc hl 
1cd0 3e 21			ld a, '!' 
1cd2 77				ld (hl),a 
1cd3			 
1cd3 2a 33 f1			ld hl,(os_tok_ptr) 
1cd6			         
1cd6			if DEBUG_FORTH_TOK 
1cd6						DMARK "Tc1" 
1cd6				CALLMONITOR 
1cd6			endif 
1cd6			 
1cd6				; push exec string to top of return stack 
1cd6				FORTH_RSP_NEXT 
1cd6 cd 42 1a			call macro_forth_rsp_next 
1cd9				endm 
# End of macro FORTH_RSP_NEXT
1cd9 c9				ret 
1cda			 
1cda			; Another go at the parser need to simplify the process 
1cda			 
1cda			forthparse: 
1cda			 
1cda			; 
1cda			; line parse: 
1cda			;       parse raw input buffer 
1cda			;       tokenise the words 
1cda			;       malloc new copy (for looping etc) 
1cda			;       copy to malloc + current pc in line to start of string and add line term 
1cda			;       save on new rsp 
1cda			; 
1cda			 
1cda			; hl to point to the line to tokenise 
1cda			 
1cda			;	push hl 
1cda 22 33 f1			ld (os_tok_ptr), hl  ; save ptr to string 
1cdd			 
1cdd			;	ld a,0		; string term on input 
1cdd			;	call strlent 
1cdd			 
1cdd			;	ld (os_tok_len), hl	 ; save string length 
1cdd			 
1cdd			;if DEBUG_FORTH_TOK 
1cdd			;	ex de,hl		 
1cdd			;endif 
1cdd			 
1cdd			;	pop hl 		; get back string pointer 
1cdd			 
1cdd			if DEBUG_FORTH_TOK 
1cdd						DMARK "TOK" 
1cdd				CALLMONITOR 
1cdd			endif 
1cdd 7e			.ptoken2:    ld a,(hl) 
1cde 23				inc hl 
1cdf fe 7f			cp FORTH_END_BUFFER 
1ce1 28 29			jr z, .ptokendone2 
1ce3 fe 00			cp 0 
1ce5 28 25			jr z, .ptokendone2 
1ce7 fe 22			cp '"' 
1ce9 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1ceb fe 20			cp ' ' 
1ced 20 ee			jr nz,  .ptoken2 
1cef			 
1cef			; TODO consume comments held between ( and ) 
1cef			 
1cef				; we have a space so change to zero term for dict match later 
1cef 2b				dec hl 
1cf0 3e 00			ld a,0 
1cf2 77				ld (hl), a 
1cf3 23				inc hl 
1cf4 18 e7			jr .ptoken2 
1cf6				 
1cf6			 
1cf6			.ptokenstr2: 
1cf6				; skip all white space until either eol (because forgot to term) or end double quote 
1cf6			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1cf6				;inc hl ; skip current double quote 
1cf6 7e				ld a,(hl) 
1cf7 23				inc hl 
1cf8 fe 22			cp '"' 
1cfa 28 e1			jr z, .ptoken2 
1cfc fe 7f			cp FORTH_END_BUFFER 
1cfe 28 0c			jr z, .ptokendone2 
1d00 fe 00			cp 0 
1d02 28 08			jr z, .ptokendone2 
1d04 fe 20			cp ' ' 
1d06 28 02			jr z, .ptmp2 
1d08 18 ec			jr .ptokenstr2 
1d0a			 
1d0a			.ptmp2:	; we have a space so change to zero term for dict match later 
1d0a				;dec hl 
1d0a				;ld a,"-"	; TODO remove this when working 
1d0a				;ld (hl), a 
1d0a				;inc hl 
1d0a 18 ea			jr .ptokenstr2 
1d0c			 
1d0c			.ptokendone2: 
1d0c				;inc hl 
1d0c 3e 7f			ld a, FORTH_END_BUFFER 
1d0e 77				ld (hl),a 
1d0f 23				inc hl 
1d10 3e 21			ld a, '!' 
1d12 77				ld (hl),a 
1d13			 
1d13 2a 33 f1			ld hl,(os_tok_ptr) 
1d16			         
1d16			if DEBUG_FORTH_TOK 
1d16						DMARK "TK1" 
1d16				CALLMONITOR 
1d16			endif 
1d16			 
1d16				; push exec string to top of return stack 
1d16				FORTH_RSP_NEXT 
1d16 cd 42 1a			call macro_forth_rsp_next 
1d19				endm 
# End of macro FORTH_RSP_NEXT
1d19 c9				ret 
1d1a			 
1d1a			; 
1d1a			;	; malloc size + buffer pointer + if is loop flag 
1d1a			;	ld hl,(os_tok_len) 		 ; get string length 
1d1a			; 
1d1a			;	ld a,l 
1d1a			; 
1d1a			;	cp 0			; we dont want to use a null string 
1d1a			;	ret z 
1d1a			; 
1d1a			;;	add 3    ; prefix malloc with buffer for current word ptr 
1d1a			; 
1d1a			;	add 5     ; TODO when certain not over writing memory remove 
1d1a			; 
1d1a			;		 
1d1a			; 
1d1a			;if DEBUG_FORTH_TOK 
1d1a			;			DMARK "TKE" 
1d1a			;	CALLMONITOR 
1d1a			;endif 
1d1a			; 
1d1a			;	ld l,a 
1d1a			;	ld h,0 
1d1a			;;	push hl   ; save required space for the copy later 
1d1a			;	call malloc 
1d1a			;if DEBUG_FORTH_TOK 
1d1a			;			DMARK "TKM" 
1d1a			;	CALLMONITOR 
1d1a			;endif 
1d1a			;	if DEBUG_FORTH_MALLOC_GUARD 
1d1a			;		push af 
1d1a			;		call ishlzero 
1d1a			;;		ld a, l 
1d1a			;;		add h 
1d1a			;;		cp 0 
1d1a			;		pop af 
1d1a			;		 
1d1a			;		call z,malloc_error 
1d1a			;	endif 
1d1a			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1d1a			; 
1d1a			; 
1d1a			;if DEBUG_FORTH_TOK 
1d1a			;			DMARK "TKR" 
1d1a			;	CALLMONITOR 
1d1a			;endif 
1d1a			; 
1d1a			;	FORTH_RSP_NEXT 
1d1a			; 
1d1a			;	;inc hl	 ; go past current buffer pointer 
1d1a			;	;inc hl 
1d1a			;	;inc hl   ; and past if loop flag 
1d1a			;		; TODO Need to set flag  
1d1a			; 
1d1a			;	 
1d1a			;	 
1d1a			;	ex de,hl	; malloc is dest 
1d1a			;	ld hl, (os_tok_len) 
1d1a			;;	pop bc 
1d1a			;	ld c, l                
1d1a			;	ld b,0 
1d1a			;	ld hl, (os_tok_ptr) 
1d1a			; 
1d1a			;if DEBUG_FORTH_TOK 
1d1a			;			DMARK "TKT" 
1d1a			;	CALLMONITOR 
1d1a			;endif 
1d1a			; 
1d1a			;	; do str cpy 
1d1a			; 
1d1a			;	ldir      ; copy byte in hl to de 
1d1a			; 
1d1a			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1d1a			; 
1d1a			;if DEBUG_FORTH_TOK 
1d1a			; 
1d1a			;			DMARK "TKY" 
1d1a			;	CALLMONITOR 
1d1a			;endif 
1d1a			;	;ld a,0 
1d1a			;	;ld a,FORTH_END_BUFFER 
1d1a			;	ex de, hl 
1d1a			;	;dec hl			 ; go back over the space delim at the end of word 
1d1a			;	;ld (hl),a 
1d1a			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1d1a			;	ld a,FORTH_END_BUFFER 
1d1a			;	ld (hl),a 
1d1a			;	inc hl 
1d1a			;	ld a,FORTH_END_BUFFER 
1d1a			;	ld (hl),a 
1d1a			; 
1d1a			;	; init the malloc area data 
1d1a			;	; set pc for in current area 
1d1a			;	;ld hl, (os_tok_malloc) 
1d1a			;	;inc hl 
1d1a			;	;inc hl 
1d1a			;	;inc hl 
1d1a			;	;ex de,hl 
1d1a			;	;ld hl, (os_tok_malloc) 
1d1a			;	;ld (hl),e 
1d1a			;	;inc hl 
1d1a			;	;ld (hl),d 
1d1a			; 
1d1a			; 
1d1a			;	ld hl,(os_tok_malloc) 
1d1a			;if DEBUG_FORTH_PARSE_KEY 
1d1a			;			DMARK "TKU" 
1d1a			;	CALLMONITOR 
1d1a			;endif 
1d1a			; 
1d1a			;	ret 
1d1a			 
1d1a			forthexec: 
1d1a			 
1d1a			; line exec: 
1d1a			; forth parser 
1d1a			 
1d1a			; 
1d1a			;       get current exec line on rsp 
1d1a			 
1d1a				FORTH_RSP_TOS 
1d1a cd 59 1a			call macro_forth_rsp_tos 
1d1d				endm 
# End of macro FORTH_RSP_TOS
1d1d			 
1d1d			;       restore current pc - hl points to malloc of data 
1d1d			 
1d1d				;ld e, (hl) 
1d1d				;inc hl 
1d1d				;ld d, (hl) 
1d1d				;ex de,hl 
1d1d			 
1d1d			 
1d1d			exec1: 
1d1d 22 33 f1			ld (os_tok_ptr), hl 
1d20			 
1d20				; copy our PC to working vars  
1d20 22 3d f8			ld (cli_ptr), hl 
1d23 22 3b f8			ld (cli_origptr), hl 
1d26			 
1d26 7e				ld a,(hl) 
1d27 fe 7f			cp FORTH_END_BUFFER 
1d29 c8				ret z 
1d2a			 
1d2a				; skip any nulls 
1d2a			 
1d2a fe 00			cp 0 
1d2c 20 03			jr nz, .execword 
1d2e 23				inc hl 
1d2f 18 ec			jr exec1 
1d31			 
1d31			 
1d31			.execword: 
1d31			 
1d31			 
1d31			 
1d31			if DEBUG_FORTH_PARSE_KEY 
1d31						DMARK "KYQ" 
1d31				CALLMONITOR 
1d31			endif 
1d31			;       while at start of word: 
1d31			; get start of dict (in user area first) 
1d31			 
1d31 21 00 80		ld hl, baseram 
1d34			;ld hl, sysdict 
1d34 22 3f f8		ld (cli_nextword),hl 
1d37			;           match word at pc 
1d37			;           exec word 
1d37			;           or push to dsp 
1d37			;           forward to next token 
1d37			;           if line term pop rsp and exit 
1d37			;        
1d37			 
1d37			if DEBUG_FORTH_PARSE_KEY 
1d37						DMARK "KYq" 
1d37				CALLMONITOR 
1d37			endif 
1d37			 
1d37			; 
1d37			; word comp 
1d37			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1d37			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1d37			;    move to start of word  
1d37			;    compare word to cli_token 
1d37			 
1d37			.execpnword:	; HL at start of a word in the dictionary to check 
1d37			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1d37			;	ld (cli_ptr), hl 
1d37			 
1d37 2a 3f f8			ld hl,(cli_nextword) 
1d3a			 
1d3a cd dd 1d			call forth_tok_next 
1d3d			; tok next start here 
1d3d			;	; TODO skip compiled symbol for now 
1d3d			;	inc hl 
1d3d			; 
1d3d			;	; save pointer to next word 
1d3d			; 
1d3d			;	; hl now points to the address of the next word pointer  
1d3d			;	ld e, (hl) 
1d3d			;	inc hl 
1d3d			;	ld d, (hl) 
1d3d			;	inc l 
1d3d			; 
1d3d			;	ex de,hl 
1d3d			;if DEBUG_FORTH_PARSE_NEXTWORD 
1d3d			;	push bc 
1d3d			;	ld bc, (cli_nextword) 
1d3d			;			DMARK "NXW" 
1d3d			;	CALLMONITOR 
1d3d			;	pop bc 
1d3d			;endif 
1d3d			; tok next end here 
1d3d 22 3f f8			ld (cli_nextword), hl     ; save for next check if no match on this word 
1d40 eb				ex de, hl 
1d41			 
1d41			 
1d41				; save the pointer of the current token - 1 to check against 
1d41				 
1d41 22 43 f8			ld (cli_token), hl   
1d44				; TODO maybe remove below save if no debug 
1d44				; save token string ptr for any debug later 
1d44 23				inc hl  
1d45 22 45 f8			ld (cli_origtoken), hl 
1d48 2b				dec hl 
1d49				; save pointer to the start of the next dictionay word 
1d49 7e				ld a,(hl)   ; get string length 
1d4a 47				ld b,a 
1d4b			.execpnwordinc:  
1d4b 23				inc hl 
1d4c 10 fd			djnz .execpnwordinc 
1d4e 22 41 f8			ld (cli_execword), hl      ; save start of this words code 
1d51			 
1d51				; now check the word token against the string being parsed 
1d51			 
1d51 2a 43 f8			ld hl,(cli_token) 
1d54 23				inc hl     ; skip string length (use zero term instead to end) 
1d55 22 43 f8			ld (cli_token), hl 
1d58			 
1d58			if DEBUG_FORTH_PARSE_KEY 
1d58						DMARK "KY2" 
1d58			endif 
1d58			if DEBUG_FORTH_PARSE_EXEC 
1d58				; see if disabled 
1d58			 
1d58				ld a, (os_view_disable) 
1d58				cp '*' 
1d58				jr z, .skip 
1d58			 
1d58				push hl 
1d58				push hl 
1d58				call clear_display 
1d58				ld de, .compword 
1d58				ld a, display_row_1 
1d58				call str_at_display 
1d58				pop de 
1d58				ld a, display_row_2 
1d58				call str_at_display 
1d58				ld hl,(cli_ptr) 
1d58				ld a,(hl) 
1d58			        ld hl, os_word_scratch 
1d58				ld (hl),a 
1d58				ld a,0 
1d58				inc hl 
1d58				ld (hl),a 	 
1d58				ld de, os_word_scratch 
1d58				ld a, display_row_2+10 
1d58				call str_at_display 
1d58				call update_display 
1d58				ld a, 100 
1d58				call aDelayInMS 
1d58				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1d58				call delay250ms 
1d58				endif 
1d58				pop hl 
1d58			.skip:  
1d58			endif	 
1d58			.execpnchar:    ; compare char between token and string to parse 
1d58			 
1d58			if DEBUG_FORTH_PARSE_KEY 
1d58						DMARK "Ky3" 
1d58			endif 
1d58			if DEBUG_FORTH_PARSE_EXEC 
1d58				; see if disabled 
1d58			 
1d58				ld a, (os_view_disable) 
1d58				cp '*' 
1d58				jr z, .skip2 
1d58			 
1d58			;	call clear_display 
1d58			ld hl,(cli_token) 
1d58			ld a,(hl) 
1d58			ld (os_word_scratch),a 
1d58				ld hl,(cli_ptr) 
1d58			ld a,(hl) 
1d58				ld (os_word_scratch+1),a 
1d58				ld a,0 
1d58				ld (os_word_scratch+2),a 
1d58				ld de,os_word_scratch 
1d58				ld a,display_row_4 
1d58				call str_at_display 
1d58				call update_display 
1d58			.skip2:  
1d58			endif 
1d58 2a 43 f8			ld hl,(cli_token) 
1d5b 7e				ld a, (hl)	 ; char in word token 
1d5c 23				inc hl 		; move to next char 
1d5d 22 43 f8			ld (cli_token), hl ; and save it 
1d60 47				ld b,a 
1d61			 
1d61 2a 3d f8			ld hl,(cli_ptr) ;	get the char from the string to parse 
1d64 7e				ld a,(hl) 
1d65 23				inc hl 
1d66 22 3d f8			ld (cli_ptr), hl		; move to next char 
1d69 cd 14 11			call toUpper 		; make sure the input string matches case 
1d6c			 
1d6c			if DEBUG_FORTH_PARSE 
1d6c			endif 
1d6c			 
1d6c				; input stream end of token is a space so get rid of it 
1d6c			 
1d6c			;	cp ' ' 
1d6c			;	jr nz, .pnskipspace 
1d6c			; 
1d6c			;	ld a, 0		; make same term as word token term 
1d6c			; 
1d6c			;.pnskipspace: 
1d6c			 
1d6c			if DEBUG_FORTH_PARSE_KEY 
1d6c						DMARK "KY7" 
1d6c			endif 
1d6c b8				cp b 
1d6d c2 83 1d			jp nz, .execpnskipword	 ; no match so move to next word 
1d70				 
1d70			;    if same 
1d70			;       scan for string terms 0 for token and 32 for input 
1d70			 
1d70				 
1d70			if DEBUG_FORTH_PARSE_KEY 
1d70						DMARK "KY8" 
1d70			endif 
1d70			 
1d70 80				add b			 
1d71 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1d73							; TODO need to make sure last word in zero term string is accounted for 
1d73 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1d75			 
1d75			 
1d75				; at end of both strings so both are exact match 
1d75			 
1d75			;       skip ptr for next word 
1d75			 
1d75 2a 3d f8			ld hl,(cli_ptr) 	; at input string term 
1d78 23				inc hl			 ; at next char 
1d79 22 3d f8			ld (cli_ptr), hl     ; save for next round of the parser 
1d7c 22 3b f8			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1d7f				 
1d7f				 
1d7f			if DEBUG_FORTH_PARSE_KEY 
1d7f						DMARK "KY3" 
1d7f			endif 
1d7f			 
1d7f			 
1d7f			 
1d7f			;       exec code block 
1d7f			if DEBUG_FORTH_JP 
1d7f				call clear_display 
1d7f				call update_display 
1d7f				call delay1s 
1d7f				ld hl, (cli_execword)     ; save for next check if no match on this word 
1d7f				ld a,h 
1d7f				ld hl, os_word_scratch 
1d7f				call hexout 
1d7f				ld hl, (cli_execword)     ; save for next check if no match on this word 
1d7f				ld a,l 
1d7f				ld hl, os_word_scratch+2 
1d7f				call hexout 
1d7f				ld hl, os_word_scratch+4 
1d7f				ld a,0 
1d7f				ld (hl),a 
1d7f				ld de,os_word_scratch 
1d7f				call str_at_display 
1d7f					ld a, display_row_2 
1d7f					call str_at_display 
1d7f				ld de, (cli_origtoken) 
1d7f				ld a, display_row_1+10 
1d7f					call str_at_display 
1d7f			 
1d7f				ld a,display_row_1 
1d7f				ld de, .foundword 
1d7f				ld a, display_row_3 
1d7f				call str_at_display 
1d7f				call update_display 
1d7f				call delay1s 
1d7f				call delay1s 
1d7f				call delay1s 
1d7f			endif 
1d7f			 
1d7f			if DEBUG_FORTH_PARSE_KEY 
1d7f						DMARK "KYj" 
1d7f			endif 
1d7f				; TODO save the word pointer in this exec 
1d7f			 
1d7f 2a 41 f8			ld hl,(cli_execword) 
1d82 e9				jp (hl) 
1d83			 
1d83			 
1d83			;    if not same 
1d83			;	scan for zero term 
1d83			;	get ptr for next word 
1d83			;	goto word comp 
1d83			 
1d83			.execpnskipword:	; get pointer to next word 
1d83 2a 3f f8			ld hl,(cli_nextword) 
1d86			 
1d86 7e				ld a,(hl) 
1d87 fe 00			cp WORD_SYS_END 
1d89			;	cp 0 
1d89 28 09			jr z, .execendofdict			 ; at end of words 
1d8b			 
1d8b			if DEBUG_FORTH_PARSE_KEY 
1d8b						DMARK "KY4" 
1d8b			endif 
1d8b			if DEBUG_FORTH_PARSE_EXEC 
1d8b			 
1d8b				; see if disabled 
1d8b			 
1d8b				ld a, (os_view_disable) 
1d8b				cp '*' 
1d8b				jr z, .noskip 
1d8b			 
1d8b			 
1d8b				ld de, .nowordfound 
1d8b				ld a, display_row_3 
1d8b				call str_at_display 
1d8b				call update_display 
1d8b				ld a, 100 
1d8b				call aDelayInMS 
1d8b				 
1d8b				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1d8b					call delay250ms 
1d8b				endif 
1d8b			.noskip:  
1d8b			 
1d8b			endif	 
1d8b			 
1d8b 2a 3b f8			ld hl,(cli_origptr) 
1d8e 22 3d f8			ld (cli_ptr),hl 
1d91			 
1d91			if DEBUG_FORTH_PARSE_KEY 
1d91						DMARK "KY5" 
1d91			endif 
1d91 c3 37 1d			jp .execpnword			; else go to next word 
1d94			 
1d94			.execendofdict:  
1d94			 
1d94			if DEBUG_FORTH_PARSE_KEY 
1d94						DMARK "KYe" 
1d94			endif 
1d94			if DEBUG_FORTH_PARSE_EXEC 
1d94				; see if disabled 
1d94			 
1d94				ld a, (os_view_disable) 
1d94				cp '*' 
1d94				jr z, .ispskip 
1d94			 
1d94				call clear_display 
1d94				call update_display 
1d94				call delay1s 
1d94				ld de, (cli_origptr) 
1d94				ld a, display_row_1 
1d94				call str_at_display 
1d94				 
1d94				ld de, .enddict 
1d94				ld a, display_row_3 
1d94				call str_at_display 
1d94				call update_display 
1d94				ld a, 100 
1d94				call aDelayInMS 
1d94				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1d94				call delay1s 
1d94				call delay1s 
1d94				call delay1s 
1d94				endif 
1d94			.ispskip:  
1d94				 
1d94			endif	 
1d94			 
1d94			 
1d94			 
1d94				; if the word is not a keyword then must be a literal so push it to stack 
1d94			 
1d94			; push token to stack to end of word 
1d94			 
1d94				STACKFRAME ON $1efe $2f9f 
1d94				if DEBUG_STACK_IMB 
1d94					if ON 
1d94						exx 
1d94						ld de, $1efe 
1d94						ld a, d 
1d94						ld hl, curframe 
1d94						call hexout 
1d94						ld a, e 
1d94						ld hl, curframe+2 
1d94						call hexout 
1d94						ld hl, $1efe 
1d94						push hl 
1d94						ld hl, $2f9f 
1d94						push hl 
1d94						exx 
1d94					endif 
1d94				endif 
1d94			endm 
# End of macro STACKFRAME
1d94			 
1d94 2a 33 f1		ld hl,(os_tok_ptr) 
1d97 cd e3 1a		call forth_apush 
1d9a			 
1d9a				STACKFRAMECHK ON $1efe $2f9f 
1d9a				if DEBUG_STACK_IMB 
1d9a					if ON 
1d9a						exx 
1d9a						ld hl, $2f9f 
1d9a						pop de   ; $2f9f 
1d9a						call cmp16 
1d9a						jr nz, .spnosame 
1d9a						ld hl, $1efe 
1d9a						pop de   ; $1efe 
1d9a						call cmp16 
1d9a						jr z, .spfrsame 
1d9a						.spnosame: call showsperror 
1d9a						.spfrsame: nop 
1d9a						exx 
1d9a					endif 
1d9a				endif 
1d9a			endm 
# End of macro STACKFRAMECHK
1d9a			 
1d9a			execnext: 
1d9a			 
1d9a			if DEBUG_FORTH_PARSE_KEY 
1d9a						DMARK "KY>" 
1d9a			endif 
1d9a			; move past token to next word 
1d9a			 
1d9a 2a 33 f1		ld hl, (os_tok_ptr) 
1d9d 3e 00		ld a, 0 
1d9f 01 ff 00		ld bc, 255     ; input buffer size 
1da2 ed b1		cpir 
1da4			 
1da4			if DEBUG_FORTH_PARSE_KEY 
1da4						DMARK "KY!" 
1da4				CALLMONITOR 
1da4			endif	 
1da4			; TODO this might place hl on the null, so will need to forward on??? 
1da4			;inc hl   ; see if this gets onto the next item 
1da4			 
1da4			 
1da4			; TODO pass a pointer to the buffer to push 
1da4			; TODO call function to push 
1da4			 
1da4			; look for end of input 
1da4			 
1da4			;inc hl 
1da4			;ld a,(hl) 
1da4			;cp FORTH_END_BUFFER 
1da4			;ret z 
1da4			 
1da4			 
1da4 c3 1d 1d		jp exec1 
1da7			 
1da7			 
1da7			 
1da7			 
1da7			 
1da7			 
1da7			 
1da7			 
1da7			 
1da7			findnexttok: 
1da7			 
1da7				; hl is pointer to move 
1da7				; de is the token to locate 
1da7			 
1da7					if DEBUG_FORTH 
1da7						DMARK "NTK" 
1da7						CALLMONITOR 
1da7					endif 
1da7 d5				push de 
1da8			 
1da8			.fnt1:	 
1da8				; find first char of token to locate 
1da8			 
1da8 1a				ld a, (de) 
1da9 4f				ld c,a 
1daa 7e				ld a,(hl) 
1dab cd 14 11			call toUpper 
1dae					if DEBUG_FORTH 
1dae						DMARK "NT1" 
1dae						CALLMONITOR 
1dae					endif 
1dae b9				cp c 
1daf			 
1daf 28 03			jr z, .fnt2cmpmorefirst	 
1db1			 
1db1				; first char not found move to next char 
1db1			 
1db1 23				inc hl 
1db2 18 f4			jr .fnt1 
1db4			 
1db4			.fnt2cmpmorefirst:	 
1db4				; first char of token found.  
1db4			 
1db4 e5				push hl     ; save start of token just in case it is the right one 
1db5 d9				exx 
1db6 e1				pop hl        ; save it to hl' 
1db7 d9				exx 
1db8			 
1db8			 
1db8			.fnt2cmpmore:	 
1db8				; compare the rest 
1db8				 
1db8 23				inc hl 
1db9 13				inc de 
1dba				 
1dba 1a				ld a, (de) 
1dbb 4f				ld c,a 
1dbc 7e				ld a,(hl) 
1dbd cd 14 11			call toUpper 
1dc0			 
1dc0					if DEBUG_FORTH 
1dc0						DMARK "NT2" 
1dc0						CALLMONITOR 
1dc0					endif 
1dc0				; c has the token to find char 
1dc0				; a has the mem to scan char 
1dc0			 
1dc0 b9				cp c 
1dc1 28 04			jr z,.fntmatch1 
1dc3			 
1dc3				; they are not the same 
1dc3			 
1dc3					if DEBUG_FORTH 
1dc3						DMARK "NT3" 
1dc3						CALLMONITOR 
1dc3					endif 
1dc3 d1				pop de	; reset de token to look for 
1dc4 d5				push de 
1dc5 18 e1			jr .fnt1 
1dc7				 
1dc7			.fntmatch1: 
1dc7			 
1dc7				; is the same char a null which means we might have a full hit? 
1dc7					if DEBUG_FORTH 
1dc7						DMARK "NT4" 
1dc7						CALLMONITOR 
1dc7					endif 
1dc7			 
1dc7 fe 00			cp 0 
1dc9 28 0b			jr z, .fntmatchyes 
1dcb			 
1dcb				; are we at the end of the token to find? 
1dcb			 
1dcb					if DEBUG_FORTH 
1dcb						DMARK "NT5" 
1dcb						CALLMONITOR 
1dcb					endif 
1dcb 3e 00			ld a, 0 
1dcd b9				cp c 
1dce			 
1dce c2 b8 1d			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1dd1			 
1dd1					if DEBUG_FORTH 
1dd1						DMARK "NT6" 
1dd1						CALLMONITOR 
1dd1					endif 
1dd1				; token to find is exhusted but no match to stream 
1dd1			 
1dd1				; restore tok pointer and continue on 
1dd1 d1				pop de 
1dd2 d5				push de 
1dd3 c3 a8 1d			jp .fnt1 
1dd6			 
1dd6			 
1dd6			.fntmatchyes: 
1dd6			 
1dd6				; hl now contains the end of the found token 
1dd6			 
1dd6				; get rid of saved token pointer to find 
1dd6			 
1dd6 d1				pop de 
1dd7			 
1dd7					if DEBUG_FORTH 
1dd7						DMARK "NT9" 
1dd7						CALLMONITOR 
1dd7					endif 
1dd7			 
1dd7				; hl will be on the null term so forward on 
1dd7			 
1dd7				; get back the saved start of the token 
1dd7			 
1dd7 d9				exx 
1dd8 e5				push hl     ; save start of token just in case it is the right one 
1dd9 d9				exx 
1dda e1				pop hl        ; save it to hl 
1ddb			 
1ddb c9				ret 
1ddc			 
1ddc			 
1ddc			; LIST needs to find a specific token   
1ddc			; FORGET needs to find a spefici token 
1ddc			 
1ddc			; SAVE needs to find all tokens by flag 
1ddc			; WORDS just needs to scan through all  by flag 
1ddc			; UWORDS needs to scan through all by flag 
1ddc			 
1ddc			 
1ddc			; given hl as pointer to start of dict look up string 
1ddc			; return hl as pointer to start of word block 
1ddc			; or 0 if not found 
1ddc			 
1ddc			forth_find_tok: 
1ddc c9				ret 
1ddd			 
1ddd			; given hl as pointer to dict structure 
1ddd			; move to the next dict block structure 
1ddd			 
1ddd			forth_tok_next: 
1ddd				; hl now points to the address of the next word pointer  
1ddd				; TODO skip compiled symbol for now 
1ddd			;	push de 
1ddd 23				inc hl 
1dde 5e				ld e, (hl) 
1ddf 23				inc hl 
1de0 56				ld d, (hl) 
1de1 23				inc hl 
1de2			 
1de2 eb				ex de,hl 
1de3			if DEBUG_FORTH_PARSE_NEXTWORD 
1de3				push bc 
1de3				ld bc, (cli_nextword) 
1de3						DMARK "NXW" 
1de3				CALLMONITOR 
1de3				pop bc 
1de3			endif 
1de3			;	pop de	 
1de3 c9				ret 
1de4			 
1de4			 
1de4			 
1de4			; eof 
# End of file forth_parserv5.asm
1de4				include "forth_wordsv4.asm" 
1de4			 
1de4			; the core word dictionary v4 
1de4			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1de4			 
1de4			; this is a linked list for each of the system words used 
1de4			; user defined words will follow the same format but will be in ram 
1de4			 
1de4			 
1de4			; 
1de4			; 
1de4			; define linked list: 
1de4			; 
1de4			; 1. compiled byte op code 
1de4			; 2. len of text word 
1de4			; 3. text word 
1de4			; 4. ptr to next dictionary word 
1de4			; 5. asm, calls etc for the word 
1de4			; 
1de4			;  if 1 == 0 then last word in dict  
1de4			;   
1de4			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1de4			;  
1de4			;  
1de4			; create basic standard set of words 
1de4			; 
1de4			;  
1de4			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1de4			; 2DUP 2DROP 2SWAP  
1de4			; @ C@ - get byte  
1de4			; ! C! - store byte 
1de4			; 0< true if less than zero 
1de4			; 0= true if zero 
1de4			; < >  
1de4			; = true if same 
1de4			; variables 
1de4			 
1de4			 
1de4			; Hardware specific words I may need 
1de4			; 
1de4			; IN OUT  
1de4			; calls to key util functions 
1de4			; calls to hardward abstraction stuff 
1de4			; easy control of frame buffers and lcd i/o 
1de4			; keyboard  
1de4			 
1de4			 
1de4			;DICT: macro 
1de4			; op_code, len, word, next 
1de4			;    word: 
1de4			;    db op_code 
1de4			;    ds word zero term 
1de4			;    dw next 
1de4			;    endm 
1de4			 
1de4			 
1de4			 
1de4			 
1de4			; op code 1 is a flag for user define words which are to be handled differently 
1de4			 
1de4			 
1de4			; 
1de4			; 
1de4			;    TODO on entry to a word this should be the expected environment 
1de4			;    hl - tos value if number then held, if string this is the ptr 
1de4			;    de -  
1de4			 
1de4			 
1de4			; opcode ranges 
1de4			; 0 - end of word dict 
1de4			; 255 - user define words 
1de4			 
1de4			sysdict: 
1de4			include "forth_opcodes.asm" 
1de4			; op codes for forth keywords 
1de4			; free to use code 0  
1de4				OPCODE_HEAP: equ  1 
1de4				OPCODE_EXEC: equ 2 
1de4				OPCODE_DUP: equ 3 
1de4				OPCODE_SWAP: equ 4 
1de4				OPCODE_COLN: equ 5 
1de4				OPCODE_SCOLN: equ 6 
1de4				OPCODE_DROP: equ 7 
1de4				OPCODE_DUP2: equ 8 
1de4				OPCODE_DROP2: equ 9 
1de4				OPCODE_SWAP2: equ 10 
1de4				OPCODE_AT: equ 11 
1de4				OPCODE_CAT: equ 12 
1de4				OPCODE_BANG: equ 13 
1de4				OPCODE_CBANG: equ 14 
1de4				OPCODE_SCALL: equ 15 
1de4				OPCODE_DEPTH: equ 16 
1de4				OPCODE_OVER: equ 17 
1de4				OPCODE_PAUSE: equ 18 
1de4				OPCODE_PAUSES: equ 19 
1de4				OPCODE_ROT: equ 20 
1de4			;free to reuse	OPCODE_WORDS: equ 21 
1de4			        OPCODE_NOT: equ 21 
1de4				OPCODE_UWORDS: equ 22 
1de4				OPCODE_BP: equ 23 
1de4				OPCODE_MONITOR: equ 24  
1de4				OPCODE_MALLOC: equ 25 
1de4				OPCODE_FREE: equ 26 
1de4				OPCODE_LIST: equ 27 
1de4				OPCODE_FORGET: equ 28 
1de4				OPCODE_NOP: equ 29 
1de4				OPCODE_COMO: equ 30 
1de4				OPCODE_COMC: equ 31 
1de4			;free to reuse	OPCODE_ENDCORE: equ 32 
1de4				OPCODE_AFTERSOUND: equ 33 
1de4				OPCODE_GP2: equ 34 
1de4				OPCODE_GP3: equ 35 
1de4				OPCODE_GP4: equ 36 
1de4				OPCODE_SIN: equ 37 
1de4				OPCODE_SOUT: equ 38 
1de4				OPCODE_SPIO: equ 39 
1de4				OPCODE_SPICEH: equ 40 
1de4				OPCODE_SPIOb: equ 41 
1de4				OPCODE_SPII: equ 42 
1de4				OPCODE_SESEL: equ 43 
1de4				OPCODE_CARTDEV: equ 44 
1de4			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1de4				OPCODE_FB: equ 46 
1de4				OPCODE_EMIT: equ 47 
1de4				OPCODE_DOTH: equ 48 
1de4				OPCODE_DOTF: equ 49 
1de4				OPCODE_DOT: equ 50 
1de4				OPCODE_CLS: equ 51 
1de4				OPCODE_DRAW: equ 52 
1de4				OPCODE_DUMP: equ 53 
1de4				OPCODE_CDUMP: equ 54 
1de4				OPCODE_DAT: equ 55 
1de4				OPCODE_HOME: equ 56 
1de4				OPCODE_SPACE: equ 57 
1de4				OPCODE_SPACES: equ 58 
1de4				OPCODE_SCROLL: equ 59 
1de4				OPCODE_ATQ: equ 60 
1de4				OPCODE_AUTODSP: equ 61 
1de4				OPCODE_MENU: equ 62 
1de4			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1de4				OPCODE_THEN: equ 64 
1de4				OPCODE_ELSE: equ 65 
1de4				OPCODE_DO: equ 66 
1de4				OPCODE_LOOP: equ 67 
1de4				OPCODE_I: equ 68 
1de4				OPCODE_DLOOP: equ 69  
1de4				OPCODE_REPEAT: equ 70  
1de4				OPCODE_UNTIL: equ 71 
1de4				OPCODE_ENDFLOW: equ 72 
1de4				OPCODE_WAITK: equ 73 
1de4				OPCODE_ACCEPT: equ 74 
1de4				OPCODE_EDIT: equ 75 
1de4			;free to reuse	OPCODE_ENDKEY: equ 76 
1de4				OPCODE_LZERO: equ 77 
1de4				OPCODE_TZERO: equ 78 
1de4				OPCODE_LESS: equ 79 
1de4				OPCODE_GT: equ 80 
1de4				OPCODE_EQUAL: equ 81  
1de4			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1de4				OPCODE_NEG: equ 83 
1de4				OPCODE_DIV: equ 84 
1de4				OPCODE_MUL: equ 85 
1de4				OPCODE_MIN: equ 86 
1de4				OPCODE_MAX: equ 87 
1de4				OPCODE_RND16: equ 88 
1de4				OPCODE_RND8: equ 89 
1de4				OPCODE_RND: equ 90 
1de4			;free to reuse	OPCODE_ENDMATHS: equ 91  
1de4				OPCODE_BYNAME: equ 92 
1de4				OPCODE_DIR: equ 93 
1de4				OPCODE_SAVE: equ 94 
1de4				OPCODE_LOAD: equ 95 
1de4				OPCODE_BSAVE: equ 96 
1de4				OPCODE_BLOAD: equ 97 
1de4				OPCODE_SEO: equ 98  
1de4				OPCODE_SEI: equ 99 
1de4				OPCODE_SFREE: equ 100 
1de4				OPCODE_SIZE: equ 101 
1de4				OPCODE_CREATE: equ 102 
1de4				OPCODE_APPEND: equ 103 
1de4				OPCODE_SDEL: equ 104 
1de4				OPCODE_OPEN: equ 105 
1de4				OPCODE_READ: equ 106 
1de4				OPCODE_EOF: equ 106 
1de4				OPCODE_FORMAT: equ 107 
1de4				OPCODE_LABEL: equ 108 
1de4				OPCODE_LABELS: equ 109 
1de4			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1de4				OPCODE_UPPER: equ 111 
1de4				OPCODE_LOWER: equ 112 
1de4				OPCODE_SUBSTR: equ 113 
1de4				OPCODE_LEFT: equ 114 
1de4				OPCODE_RIGHT: equ 115 
1de4				OPCODE_STR2NUM: equ 116 
1de4				OPCODE_NUM2STR: equ 117 
1de4				OPCODE_CONCAT: equ 118 
1de4				OPCODE_FIND: equ 119 
1de4				OPCODE_LEN: equ 120 
1de4				OPCODE_CHAR: equ 121 
1de4			; free to reuse	OPCODE_STRLEN: equ 122 
1de4			; free to reuse	OPCODE_ENDSTR: equ 123 
1de4				OPCODE_V0S: equ 124 
1de4				OPCODE_V0Q: equ 125 
1de4				OPCODE_V1S: equ 126 
1de4				OPCODE_V1Q: equ 127 
1de4				OPCODE_V2S: equ 128 
1de4				OPCODE_V2Q: equ 129 
1de4				OPCODE_V3S: equ 130 
1de4				OPCODE_V3Q: equ 131 
1de4			;free to reuse	OPCODE_END: equ 132 
1de4				OPCODE_ZDUP: equ 133 
1de4			 
1de4			; eof 
# End of file forth_opcodes.asm
1de4			 
1de4			include "forth_words_core.asm" 
1de4			 
1de4			; | ## Core Words 
1de4			 
1de4			;if MALLOC_4 
1de4			 
1de4			.HEAP: 
1de4				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1de4 15				db WORD_SYS_CORE+OPCODE_HEAP             
1de5 23 1e			dw .EXEC            
1de7 05				db 4 + 1 
1de8 .. 00			db "HEAP",0              
1ded				endm 
# End of macro CWHEAD
1ded			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1ded			; | | u1 - Current number of bytes in the heap 
1ded			; | | u2 - Remaining bytes left on the heap 
1ded			; | |  
1ded			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1ded			 
1ded			 
1ded					if DEBUG_FORTH_WORDS_KEY 
1ded						DMARK "HEP" 
1ded f5				push af  
1dee 3a 02 1e			ld a, (.dmark)  
1df1 32 77 fb			ld (debug_mark),a  
1df4 3a 03 1e			ld a, (.dmark+1)  
1df7 32 78 fb			ld (debug_mark+1),a  
1dfa 3a 04 1e			ld a, (.dmark+2)  
1dfd 32 79 fb			ld (debug_mark+2),a  
1e00 18 03			jr .pastdmark  
1e02 ..			.dmark: db "HEP"  
1e05 f1			.pastdmark: pop af  
1e06			endm  
# End of macro DMARK
1e06						CALLMONITOR 
1e06 cd 01 15			call break_point_state  
1e09				endm  
# End of macro CALLMONITOR
1e09					endif 
1e09 2a 0a 80				ld hl, (free_list )      
1e0c 11 0e 80				ld de, heap_start 
1e0f			 
1e0f ed 52				sbc hl, de  
1e11			 
1e11 cd 9b 1a				call forth_push_numhl 
1e14			 
1e14			 
1e14 ed 5b 0a 80			ld de, (free_list )      
1e18 21 26 ee				ld hl, heap_end 
1e1b			 
1e1b ed 52				sbc hl, de 
1e1d			 
1e1d cd 9b 1a				call forth_push_numhl 
1e20					 
1e20			 
1e20					 
1e20			 
1e20			 
1e20			 
1e20					NEXTW 
1e20 c3 8c 1c			jp macro_next 
1e23				endm 
# End of macro NEXTW
1e23			;endif 
1e23			 
1e23			.EXEC: 
1e23				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1e23 16				db WORD_SYS_CORE+OPCODE_EXEC             
1e24 bf 1e			dw .STKEXEC            
1e26 05				db 4 + 1 
1e27 .. 00			db "EXEC",0              
1e2c				endm 
# End of macro CWHEAD
1e2c			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
1e2c			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1e2c			; | | 
1e2c			; | |   
1e2c				STACKFRAME OFF $5efe $5f9f 
1e2c				if DEBUG_STACK_IMB 
1e2c					if OFF 
1e2c						exx 
1e2c						ld de, $5efe 
1e2c						ld a, d 
1e2c						ld hl, curframe 
1e2c						call hexout 
1e2c						ld a, e 
1e2c						ld hl, curframe+2 
1e2c						call hexout 
1e2c						ld hl, $5efe 
1e2c						push hl 
1e2c						ld hl, $5f9f 
1e2c						push hl 
1e2c						exx 
1e2c					endif 
1e2c				endif 
1e2c			endm 
# End of macro STACKFRAME
1e2c			 
1e2c					if DEBUG_FORTH_WORDS_KEY 
1e2c						DMARK "EXE" 
1e2c f5				push af  
1e2d 3a 41 1e			ld a, (.dmark)  
1e30 32 77 fb			ld (debug_mark),a  
1e33 3a 42 1e			ld a, (.dmark+1)  
1e36 32 78 fb			ld (debug_mark+1),a  
1e39 3a 43 1e			ld a, (.dmark+2)  
1e3c 32 79 fb			ld (debug_mark+2),a  
1e3f 18 03			jr .pastdmark  
1e41 ..			.dmark: db "EXE"  
1e44 f1			.pastdmark: pop af  
1e45			endm  
# End of macro DMARK
1e45						CALLMONITOR 
1e45 cd 01 15			call break_point_state  
1e48				endm  
# End of macro CALLMONITOR
1e48					endif 
1e48			 
1e48				FORTH_DSP_VALUEHL 
1e48 cd 36 1b			call macro_dsp_valuehl 
1e4b				endm 
# End of macro FORTH_DSP_VALUEHL
1e4b			 
1e4b				FORTH_DSP_POP 
1e4b cd d2 1b			call macro_forth_dsp_pop 
1e4e				endm 
# End of macro FORTH_DSP_POP
1e4e			 
1e4e					if DEBUG_FORTH_WORDS 
1e4e						DMARK "EX1" 
1e4e f5				push af  
1e4f 3a 63 1e			ld a, (.dmark)  
1e52 32 77 fb			ld (debug_mark),a  
1e55 3a 64 1e			ld a, (.dmark+1)  
1e58 32 78 fb			ld (debug_mark+1),a  
1e5b 3a 65 1e			ld a, (.dmark+2)  
1e5e 32 79 fb			ld (debug_mark+2),a  
1e61 18 03			jr .pastdmark  
1e63 ..			.dmark: db "EX1"  
1e66 f1			.pastdmark: pop af  
1e67			endm  
# End of macro DMARK
1e67						CALLMONITOR 
1e67 cd 01 15			call break_point_state  
1e6a				endm  
# End of macro CALLMONITOR
1e6a					endif 
1e6a			;	ld e,(hl) 
1e6a			;	inc hl 
1e6a			;	ld d,(hl) 
1e6a			;	ex de,hl 
1e6a			 
1e6a			;		if DEBUG_FORTH_WORDS 
1e6a			;			DMARK "EX2" 
1e6a			;			CALLMONITOR 
1e6a			;		endif 
1e6a e5				push hl 
1e6b			 
1e6b				;ld a, 0 
1e6b				;ld a, FORTH_END_BUFFER 
1e6b cd 1d 11			call strlenz 
1e6e 23				inc hl   ; include zero term to copy 
1e6f 23				inc hl   ; include term 
1e70 23				inc hl   ; include term 
1e71 06 00			ld b,0 
1e73 4d				ld c,l 
1e74 e1				pop hl 
1e75 11 31 ef			ld de, execscratch 
1e78					if DEBUG_FORTH_WORDS 
1e78						DMARK "EX3" 
1e78 f5				push af  
1e79 3a 8d 1e			ld a, (.dmark)  
1e7c 32 77 fb			ld (debug_mark),a  
1e7f 3a 8e 1e			ld a, (.dmark+1)  
1e82 32 78 fb			ld (debug_mark+1),a  
1e85 3a 8f 1e			ld a, (.dmark+2)  
1e88 32 79 fb			ld (debug_mark+2),a  
1e8b 18 03			jr .pastdmark  
1e8d ..			.dmark: db "EX3"  
1e90 f1			.pastdmark: pop af  
1e91			endm  
# End of macro DMARK
1e91						CALLMONITOR 
1e91 cd 01 15			call break_point_state  
1e94				endm  
# End of macro CALLMONITOR
1e94					endif 
1e94 ed b0			ldir 
1e96			 
1e96			 
1e96 21 31 ef			ld hl, execscratch 
1e99			 
1e99					if DEBUG_FORTH_WORDS 
1e99						DMARK "EXe" 
1e99 f5				push af  
1e9a 3a ae 1e			ld a, (.dmark)  
1e9d 32 77 fb			ld (debug_mark),a  
1ea0 3a af 1e			ld a, (.dmark+1)  
1ea3 32 78 fb			ld (debug_mark+1),a  
1ea6 3a b0 1e			ld a, (.dmark+2)  
1ea9 32 79 fb			ld (debug_mark+2),a  
1eac 18 03			jr .pastdmark  
1eae ..			.dmark: db "EXe"  
1eb1 f1			.pastdmark: pop af  
1eb2			endm  
# End of macro DMARK
1eb2						CALLMONITOR 
1eb2 cd 01 15			call break_point_state  
1eb5				endm  
# End of macro CALLMONITOR
1eb5					endif 
1eb5			 
1eb5 cd da 1c			call forthparse 
1eb8 cd 1a 1d			call forthexec 
1ebb			;	call forthexec_cleanup 
1ebb			;	call forthparse 
1ebb			;	call forthexec 
1ebb			 
1ebb				STACKFRAMECHK OFF $5efe $5f9f 
1ebb				if DEBUG_STACK_IMB 
1ebb					if OFF 
1ebb						exx 
1ebb						ld hl, $5f9f 
1ebb						pop de   ; $5f9f 
1ebb						call cmp16 
1ebb						jr nz, .spnosame 
1ebb						ld hl, $5efe 
1ebb						pop de   ; $5efe 
1ebb						call cmp16 
1ebb						jr z, .spfrsame 
1ebb						.spnosame: call showsperror 
1ebb						.spfrsame: nop 
1ebb						exx 
1ebb					endif 
1ebb				endif 
1ebb			endm 
# End of macro STACKFRAMECHK
1ebb			 
1ebb				; an immediate word so no need to process any more words 
1ebb c9				ret 
1ebc				NEXTW 
1ebc c3 8c 1c			jp macro_next 
1ebf				endm 
# End of macro NEXTW
1ebf			 
1ebf			; dead code - old version  
1ebf			;	FORTH_RSP_NEXT 
1ebf			 
1ebf			;  
1ebf			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1ebf			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1ebf			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1ebf			;	push hl 
1ebf			;	push de 
1ebf			;	push bc 
1ebf			; 
1ebf			; 
1ebf			;		if DEBUG_FORTH_WORDS_KEY 
1ebf			;			DMARK "EXR" 
1ebf			;			CALLMONITOR 
1ebf			;		endif 
1ebf			; 
1ebf			; 
1ebf			; 
1ebf			;	;v5 FORTH_DSP_VALUE 
1ebf			;	FORTH_DSP_VALUEHL 
1ebf			; 
1ebf			;	; TODO do string type checks 
1ebf			; 
1ebf			;;v5	inc hl   ; skip type 
1ebf			; 
1ebf			;	push hl  ; source code  
1ebf			;		if DEBUG_FORTH_WORDS 
1ebf			;			DMARK "EX1" 
1ebf			;			CALLMONITOR 
1ebf			;		endif 
1ebf			;	ld a, 0 
1ebf			;	call strlent 
1ebf			; 
1ebf			;	inc hl 
1ebf			;	inc hl 
1ebf			;	inc hl 
1ebf			;	inc hl 
1ebf			; 
1ebf			;	push hl    ; size 
1ebf			; 
1ebf			;		if DEBUG_FORTH_WORDS 
1ebf			;			DMARK "EX2" 
1ebf			;			CALLMONITOR 
1ebf			;		endif 
1ebf			;	call malloc 
1ebf			; 
1ebf			;	ex de, hl    ; de now contains malloc area 
1ebf			;	pop bc   	; get byte count 
1ebf			;	pop hl      ; get string to copy 
1ebf			; 
1ebf			;	push de     ; save malloc for free later 
1ebf			; 
1ebf			;		if DEBUG_FORTH_WORDS 
1ebf			;			DMARK "EX3" 
1ebf			;			CALLMONITOR 
1ebf			;		endif 
1ebf			;	ldir       ; duplicate string 
1ebf			; 
1ebf			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1ebf			;	 
1ebf			;	; TODO fix the parse would be better than this...  
1ebf			;	ex de, hl 
1ebf			;	dec hl 
1ebf			;	ld a, 0 
1ebf			;	ld (hl), a 
1ebf			;	dec hl 
1ebf			;	ld a, ' ' 
1ebf			;	ld (hl), a 
1ebf			;	dec hl 
1ebf			;	ld (hl), a 
1ebf			; 
1ebf			;	dec hl 
1ebf			;	ld (hl), a 
1ebf			; 
1ebf			; 
1ebf			;	FORTH_DSP_POP  
1ebf			; 
1ebf			;	pop hl     
1ebf			;	push hl    ; save malloc area 
1ebf			; 
1ebf			;		if DEBUG_FORTH_WORDS 
1ebf			;			DMARK "EX4" 
1ebf			;			CALLMONITOR 
1ebf			;		endif 
1ebf			; 
1ebf			;	call forthparse 
1ebf			;	call forthexec 
1ebf			;	 
1ebf			;	pop hl 
1ebf			;	if DEBUG_FORTH_WORDS 
1ebf			;		DMARK "EX5" 
1ebf			;		CALLMONITOR 
1ebf			;	endif 
1ebf			; 
1ebf			;	if FORTH_ENABLE_FREE 
1ebf			;	call free 
1ebf			;	endif 
1ebf			; 
1ebf			;	if DEBUG_FORTH_WORDS 
1ebf			;		DMARK "EX6" 
1ebf			;		CALLMONITOR 
1ebf			;	endif 
1ebf			; 
1ebf			;	pop bc 
1ebf			;	pop de 
1ebf			;	pop hl 
1ebf			;;	FORTH_RSP_POP	  
1ebf			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1ebf			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1ebf			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1ebf			; 
1ebf			;	if DEBUG_FORTH_WORDS 
1ebf			;		DMARK "EX7" 
1ebf			;		CALLMONITOR 
1ebf			;	endif 
1ebf			;	NEXTW 
1ebf			 
1ebf			.STKEXEC: 
1ebf				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1ebf 3f				db WORD_SYS_CORE+43             
1ec0 07 20			dw .ZDUP            
1ec2 08				db 7 + 1 
1ec3 .. 00			db "STKEXEC",0              
1ecb				endm 
# End of macro CWHEAD
1ecb			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
1ecb			 
1ecb			 
1ecb					if DEBUG_FORTH_WORDS_KEY 
1ecb						DMARK "STX" 
1ecb f5				push af  
1ecc 3a e0 1e			ld a, (.dmark)  
1ecf 32 77 fb			ld (debug_mark),a  
1ed2 3a e1 1e			ld a, (.dmark+1)  
1ed5 32 78 fb			ld (debug_mark+1),a  
1ed8 3a e2 1e			ld a, (.dmark+2)  
1edb 32 79 fb			ld (debug_mark+2),a  
1ede 18 03			jr .pastdmark  
1ee0 ..			.dmark: db "STX"  
1ee3 f1			.pastdmark: pop af  
1ee4			endm  
# End of macro DMARK
1ee4						CALLMONITOR 
1ee4 cd 01 15			call break_point_state  
1ee7				endm  
# End of macro CALLMONITOR
1ee7					endif 
1ee7			 
1ee7				FORTH_DSP_VALUEHL 
1ee7 cd 36 1b			call macro_dsp_valuehl 
1eea				endm 
# End of macro FORTH_DSP_VALUEHL
1eea			 
1eea 22 60 f8			ld (store_tmp1), hl    ; count 
1eed			 
1eed				FORTH_DSP_POP 
1eed cd d2 1b			call macro_forth_dsp_pop 
1ef0				endm 
# End of macro FORTH_DSP_POP
1ef0			.stkexec1: 
1ef0 2a 60 f8			ld hl, (store_tmp1)   ; count 
1ef3 3e 00			ld a, 0 
1ef5 bd				cp l 
1ef6 c8				ret z 
1ef7			 
1ef7 2b				dec hl 
1ef8 22 60 f8			ld (store_tmp1), hl    ; count 
1efb				 
1efb				FORTH_DSP_VALUEHL 
1efb cd 36 1b			call macro_dsp_valuehl 
1efe				endm 
# End of macro FORTH_DSP_VALUEHL
1efe e5				push hl 
1eff				 
1eff					if DEBUG_FORTH_WORDS 
1eff						DMARK "EXp" 
1eff f5				push af  
1f00 3a 14 1f			ld a, (.dmark)  
1f03 32 77 fb			ld (debug_mark),a  
1f06 3a 15 1f			ld a, (.dmark+1)  
1f09 32 78 fb			ld (debug_mark+1),a  
1f0c 3a 16 1f			ld a, (.dmark+2)  
1f0f 32 79 fb			ld (debug_mark+2),a  
1f12 18 03			jr .pastdmark  
1f14 ..			.dmark: db "EXp"  
1f17 f1			.pastdmark: pop af  
1f18			endm  
# End of macro DMARK
1f18						CALLMONITOR 
1f18 cd 01 15			call break_point_state  
1f1b				endm  
# End of macro CALLMONITOR
1f1b					endif 
1f1b				FORTH_DSP_POP 
1f1b cd d2 1b			call macro_forth_dsp_pop 
1f1e				endm 
# End of macro FORTH_DSP_POP
1f1e			 
1f1e cd 1d 11			call strlenz 
1f21 23				inc hl   ; include zero term to copy 
1f22 23				inc hl   ; include zero term to copy 
1f23 23				inc hl   ; include zero term to copy 
1f24 06 00			ld b,0 
1f26 4d				ld c,l 
1f27 e1				pop hl 
1f28 11 31 ef			ld de, execscratch 
1f2b					if DEBUG_FORTH_WORDS 
1f2b						DMARK "EX3" 
1f2b f5				push af  
1f2c 3a 40 1f			ld a, (.dmark)  
1f2f 32 77 fb			ld (debug_mark),a  
1f32 3a 41 1f			ld a, (.dmark+1)  
1f35 32 78 fb			ld (debug_mark+1),a  
1f38 3a 42 1f			ld a, (.dmark+2)  
1f3b 32 79 fb			ld (debug_mark+2),a  
1f3e 18 03			jr .pastdmark  
1f40 ..			.dmark: db "EX3"  
1f43 f1			.pastdmark: pop af  
1f44			endm  
# End of macro DMARK
1f44						CALLMONITOR 
1f44 cd 01 15			call break_point_state  
1f47				endm  
# End of macro CALLMONITOR
1f47					endif 
1f47 ed b0			ldir 
1f49			 
1f49			 
1f49 21 31 ef			ld hl, execscratch 
1f4c			 
1f4c					if DEBUG_FORTH_WORDS 
1f4c						DMARK "EXP" 
1f4c f5				push af  
1f4d 3a 61 1f			ld a, (.dmark)  
1f50 32 77 fb			ld (debug_mark),a  
1f53 3a 62 1f			ld a, (.dmark+1)  
1f56 32 78 fb			ld (debug_mark+1),a  
1f59 3a 63 1f			ld a, (.dmark+2)  
1f5c 32 79 fb			ld (debug_mark+2),a  
1f5f 18 03			jr .pastdmark  
1f61 ..			.dmark: db "EXP"  
1f64 f1			.pastdmark: pop af  
1f65			endm  
# End of macro DMARK
1f65						CALLMONITOR 
1f65 cd 01 15			call break_point_state  
1f68				endm  
# End of macro CALLMONITOR
1f68					endif 
1f68			 
1f68 cd da 1c			call forthparse 
1f6b 21 31 ef			ld hl, execscratch 
1f6e					if DEBUG_FORTH_WORDS 
1f6e						DMARK "EXx" 
1f6e f5				push af  
1f6f 3a 83 1f			ld a, (.dmark)  
1f72 32 77 fb			ld (debug_mark),a  
1f75 3a 84 1f			ld a, (.dmark+1)  
1f78 32 78 fb			ld (debug_mark+1),a  
1f7b 3a 85 1f			ld a, (.dmark+2)  
1f7e 32 79 fb			ld (debug_mark+2),a  
1f81 18 03			jr .pastdmark  
1f83 ..			.dmark: db "EXx"  
1f86 f1			.pastdmark: pop af  
1f87			endm  
# End of macro DMARK
1f87						CALLMONITOR 
1f87 cd 01 15			call break_point_state  
1f8a				endm  
# End of macro CALLMONITOR
1f8a					endif 
1f8a cd 1a 1d			call forthexec 
1f8d			 
1f8d c3 f0 1e			jp .stkexec1 
1f90			 
1f90 c9				ret 
1f91			 
1f91			 
1f91			.DUP: 
1f91				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1f91 17				db WORD_SYS_CORE+OPCODE_DUP             
1f92 07 20			dw .ZDUP            
1f94 04				db 3 + 1 
1f95 .. 00			db "DUP",0              
1f99				endm 
# End of macro CWHEAD
1f99			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1f99			 
1f99					if DEBUG_FORTH_WORDS_KEY 
1f99						DMARK "DUP" 
1f99 f5				push af  
1f9a 3a ae 1f			ld a, (.dmark)  
1f9d 32 77 fb			ld (debug_mark),a  
1fa0 3a af 1f			ld a, (.dmark+1)  
1fa3 32 78 fb			ld (debug_mark+1),a  
1fa6 3a b0 1f			ld a, (.dmark+2)  
1fa9 32 79 fb			ld (debug_mark+2),a  
1fac 18 03			jr .pastdmark  
1fae ..			.dmark: db "DUP"  
1fb1 f1			.pastdmark: pop af  
1fb2			endm  
# End of macro DMARK
1fb2						CALLMONITOR 
1fb2 cd 01 15			call break_point_state  
1fb5				endm  
# End of macro CALLMONITOR
1fb5					endif 
1fb5			 
1fb5					FORTH_DSP 
1fb5 cd 1b 1b			call macro_forth_dsp 
1fb8				endm 
# End of macro FORTH_DSP
1fb8			 
1fb8 7e					ld a, (HL) 
1fb9 fe 01				cp DS_TYPE_STR 
1fbb 20 25				jr nz, .dupinum 
1fbd			 
1fbd					; push another string 
1fbd			 
1fbd					FORTH_DSP_VALUEHL     		 
1fbd cd 36 1b			call macro_dsp_valuehl 
1fc0				endm 
# End of macro FORTH_DSP_VALUEHL
1fc0			 
1fc0				if DEBUG_FORTH_WORDS 
1fc0					DMARK "DUs" 
1fc0 f5				push af  
1fc1 3a d5 1f			ld a, (.dmark)  
1fc4 32 77 fb			ld (debug_mark),a  
1fc7 3a d6 1f			ld a, (.dmark+1)  
1fca 32 78 fb			ld (debug_mark+1),a  
1fcd 3a d7 1f			ld a, (.dmark+2)  
1fd0 32 79 fb			ld (debug_mark+2),a  
1fd3 18 03			jr .pastdmark  
1fd5 ..			.dmark: db "DUs"  
1fd8 f1			.pastdmark: pop af  
1fd9			endm  
# End of macro DMARK
1fd9					CALLMONITOR 
1fd9 cd 01 15			call break_point_state  
1fdc				endm  
# End of macro CALLMONITOR
1fdc				endif 
1fdc cd ad 1a				call forth_push_str 
1fdf			 
1fdf					NEXTW 
1fdf c3 8c 1c			jp macro_next 
1fe2				endm 
# End of macro NEXTW
1fe2			 
1fe2			 
1fe2			.dupinum: 
1fe2					 
1fe2			 
1fe2			 
1fe2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1fe2 cd 36 1b			call macro_dsp_valuehl 
1fe5				endm 
# End of macro FORTH_DSP_VALUEHL
1fe5			 
1fe5				; TODO add floating point number detection 
1fe5			 
1fe5				if DEBUG_FORTH_WORDS 
1fe5					DMARK "DUi" 
1fe5 f5				push af  
1fe6 3a fa 1f			ld a, (.dmark)  
1fe9 32 77 fb			ld (debug_mark),a  
1fec 3a fb 1f			ld a, (.dmark+1)  
1fef 32 78 fb			ld (debug_mark+1),a  
1ff2 3a fc 1f			ld a, (.dmark+2)  
1ff5 32 79 fb			ld (debug_mark+2),a  
1ff8 18 03			jr .pastdmark  
1ffa ..			.dmark: db "DUi"  
1ffd f1			.pastdmark: pop af  
1ffe			endm  
# End of macro DMARK
1ffe					CALLMONITOR 
1ffe cd 01 15			call break_point_state  
2001				endm  
# End of macro CALLMONITOR
2001				endif 
2001			 
2001 cd 9b 1a				call forth_push_numhl 
2004					NEXTW 
2004 c3 8c 1c			jp macro_next 
2007				endm 
# End of macro NEXTW
2007			.ZDUP: 
2007				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2007 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2008 3f 20			dw .SWAP            
200a 05				db 4 + 1 
200b .. 00			db "?DUP",0              
2010				endm 
# End of macro CWHEAD
2010			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2010			 
2010					if DEBUG_FORTH_WORDS_KEY 
2010						DMARK "qDU" 
2010 f5				push af  
2011 3a 25 20			ld a, (.dmark)  
2014 32 77 fb			ld (debug_mark),a  
2017 3a 26 20			ld a, (.dmark+1)  
201a 32 78 fb			ld (debug_mark+1),a  
201d 3a 27 20			ld a, (.dmark+2)  
2020 32 79 fb			ld (debug_mark+2),a  
2023 18 03			jr .pastdmark  
2025 ..			.dmark: db "qDU"  
2028 f1			.pastdmark: pop af  
2029			endm  
# End of macro DMARK
2029						CALLMONITOR 
2029 cd 01 15			call break_point_state  
202c				endm  
# End of macro CALLMONITOR
202c					endif 
202c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
202c cd 36 1b			call macro_dsp_valuehl 
202f				endm 
# End of macro FORTH_DSP_VALUEHL
202f			 
202f e5					push hl 
2030			 
2030					; is it a zero? 
2030			 
2030 3e 00				ld a, 0 
2032 84					add h 
2033 85					add l 
2034			 
2034 e1					pop hl 
2035			 
2035 fe 00				cp 0 
2037 28 03				jr z, .dup2orig 
2039			 
2039			 
2039 cd 9b 1a				call forth_push_numhl 
203c			 
203c			 
203c				; TODO add floating point number detection 
203c			 
203c			.dup2orig: 
203c			 
203c					NEXTW 
203c c3 8c 1c			jp macro_next 
203f				endm 
# End of macro NEXTW
203f			.SWAP: 
203f				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
203f 18				db WORD_SYS_CORE+OPCODE_SWAP             
2040 7e 20			dw .COLN            
2042 05				db 4 + 1 
2043 .. 00			db "SWAP",0              
2048				endm 
# End of macro CWHEAD
2048			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2048					if DEBUG_FORTH_WORDS_KEY 
2048						DMARK "SWP" 
2048 f5				push af  
2049 3a 5d 20			ld a, (.dmark)  
204c 32 77 fb			ld (debug_mark),a  
204f 3a 5e 20			ld a, (.dmark+1)  
2052 32 78 fb			ld (debug_mark+1),a  
2055 3a 5f 20			ld a, (.dmark+2)  
2058 32 79 fb			ld (debug_mark+2),a  
205b 18 03			jr .pastdmark  
205d ..			.dmark: db "SWP"  
2060 f1			.pastdmark: pop af  
2061			endm  
# End of macro DMARK
2061						CALLMONITOR 
2061 cd 01 15			call break_point_state  
2064				endm  
# End of macro CALLMONITOR
2064					endif 
2064			 
2064					FORTH_DSP_VALUEHL 
2064 cd 36 1b			call macro_dsp_valuehl 
2067				endm 
# End of macro FORTH_DSP_VALUEHL
2067 e5					push hl     ; w2 
2068			 
2068					FORTH_DSP_POP 
2068 cd d2 1b			call macro_forth_dsp_pop 
206b				endm 
# End of macro FORTH_DSP_POP
206b			 
206b					FORTH_DSP_VALUEHL 
206b cd 36 1b			call macro_dsp_valuehl 
206e				endm 
# End of macro FORTH_DSP_VALUEHL
206e			 
206e					FORTH_DSP_POP 
206e cd d2 1b			call macro_forth_dsp_pop 
2071				endm 
# End of macro FORTH_DSP_POP
2071			 
2071 d1					pop de     ; w2	, hl = w1 
2072			 
2072 eb					ex de, hl 
2073 d5					push de 
2074			 
2074 cd 9b 1a				call forth_push_numhl 
2077			 
2077 e1					pop hl 
2078			 
2078 cd 9b 1a				call forth_push_numhl 
207b					 
207b			 
207b					NEXTW 
207b c3 8c 1c			jp macro_next 
207e				endm 
# End of macro NEXTW
207e			.COLN: 
207e				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
207e 19				db WORD_SYS_CORE+OPCODE_COLN             
207f 0a 22			dw .SCOLN            
2081 02				db 1 + 1 
2082 .. 00			db ":",0              
2084				endm 
# End of macro CWHEAD
2084			; | : ( -- )         Create new word | DONE 
2084			 
2084					if DEBUG_FORTH_WORDS_KEY 
2084						DMARK "CLN" 
2084 f5				push af  
2085 3a 99 20			ld a, (.dmark)  
2088 32 77 fb			ld (debug_mark),a  
208b 3a 9a 20			ld a, (.dmark+1)  
208e 32 78 fb			ld (debug_mark+1),a  
2091 3a 9b 20			ld a, (.dmark+2)  
2094 32 79 fb			ld (debug_mark+2),a  
2097 18 03			jr .pastdmark  
2099 ..			.dmark: db "CLN"  
209c f1			.pastdmark: pop af  
209d			endm  
# End of macro DMARK
209d						CALLMONITOR 
209d cd 01 15			call break_point_state  
20a0				endm  
# End of macro CALLMONITOR
20a0					endif 
20a0				STACKFRAME OFF $8efe $989f 
20a0				if DEBUG_STACK_IMB 
20a0					if OFF 
20a0						exx 
20a0						ld de, $8efe 
20a0						ld a, d 
20a0						ld hl, curframe 
20a0						call hexout 
20a0						ld a, e 
20a0						ld hl, curframe+2 
20a0						call hexout 
20a0						ld hl, $8efe 
20a0						push hl 
20a0						ld hl, $989f 
20a0						push hl 
20a0						exx 
20a0					endif 
20a0				endif 
20a0			endm 
# End of macro STACKFRAME
20a0				; get parser buffer length  of new word 
20a0			 
20a0				 
20a0			 
20a0					; move tok past this to start of name defintition 
20a0					; TODO get word to define 
20a0					; TODO Move past word token 
20a0					; TODO get length of string up to the ';' 
20a0			 
20a0 2a 33 f1			ld hl, (os_tok_ptr) 
20a3 23				inc hl 
20a4 23				inc hl 
20a5			 
20a5 3e 3b			ld a, ';' 
20a7 cd 28 11			call strlent 
20aa			 
20aa 7d				ld a,l 
20ab 32 32 f0			ld (os_new_parse_len), a 
20ae			 
20ae			 
20ae			if DEBUG_FORTH_UWORD 
20ae ed 5b 33 f1		ld de, (os_tok_ptr) 
20b2						DMARK ":01" 
20b2 f5				push af  
20b3 3a c7 20			ld a, (.dmark)  
20b6 32 77 fb			ld (debug_mark),a  
20b9 3a c8 20			ld a, (.dmark+1)  
20bc 32 78 fb			ld (debug_mark+1),a  
20bf 3a c9 20			ld a, (.dmark+2)  
20c2 32 79 fb			ld (debug_mark+2),a  
20c5 18 03			jr .pastdmark  
20c7 ..			.dmark: db ":01"  
20ca f1			.pastdmark: pop af  
20cb			endm  
# End of macro DMARK
20cb				CALLMONITOR 
20cb cd 01 15			call break_point_state  
20ce				endm  
# End of macro CALLMONITOR
20ce			endif 
20ce			 
20ce			; 
20ce			;  new word memory layout: 
20ce			;  
20ce			;    : adg 6666 ;  
20ce			; 
20ce			;    db   1     ; user defined word  
20ce 23				inc hl    
20cf			;    dw   sysdict 
20cf 23				inc hl 
20d0 23				inc hl 
20d1			;    db <word len>+1 (for null) 
20d1 23				inc hl 
20d2			;    db .... <word> 
20d2			; 
20d2			 
20d2 23				inc hl    ; some extras for the word preamble before the above 
20d3 23				inc hl 
20d4 23				inc hl 
20d5 23				inc hl 
20d6 23				inc hl 
20d7 23				inc hl 
20d8 23				inc hl  
20d9 23				inc hl 
20da 23				inc hl 
20db 23				inc hl 
20dc 23				inc hl 
20dd 23				inc hl 
20de 23				inc hl 
20df 23				inc hl     ; TODO how many do we really need?     maybe only 6 
20e0			;       exec word buffer 
20e0			;	<ptr word>   
20e0 23				inc hl 
20e1 23				inc hl 
20e2			;       <word list><null term> 7F final term 
20e2			 
20e2			 
20e2			if DEBUG_FORTH_UWORD 
20e2						DMARK ":02" 
20e2 f5				push af  
20e3 3a f7 20			ld a, (.dmark)  
20e6 32 77 fb			ld (debug_mark),a  
20e9 3a f8 20			ld a, (.dmark+1)  
20ec 32 78 fb			ld (debug_mark+1),a  
20ef 3a f9 20			ld a, (.dmark+2)  
20f2 32 79 fb			ld (debug_mark+2),a  
20f5 18 03			jr .pastdmark  
20f7 ..			.dmark: db ":02"  
20fa f1			.pastdmark: pop af  
20fb			endm  
# End of macro DMARK
20fb				CALLMONITOR 
20fb cd 01 15			call break_point_state  
20fe				endm  
# End of macro CALLMONITOR
20fe			endif 
20fe			 
20fe				 
20fe					; malloc the size 
20fe			 
20fe cd 86 11				call malloc 
2101 22 30 f0				ld (os_new_malloc), hl     ; save malloc start 
2104			 
2104			;    db   1     ; user defined word  
2104 3e 01				ld a, WORD_SYS_UWORD  
2106 77					ld (hl), a 
2107				 
2107 23				inc hl    
2108			;    dw   sysdict 
2108 11 e4 1d			ld de, sysdict       ; continue on with the scan to the system dict 
210b 73				ld (hl), e 
210c 23				inc hl 
210d 72				ld (hl), d 
210e 23				inc hl 
210f			 
210f			 
210f			;    Setup dict word 
210f			 
210f 23				inc hl 
2110 22 36 f0			ld (os_new_work_ptr), hl     ; save start of dict word  
2113			 
2113				; 1. get length of dict word 
2113			 
2113			 
2113 2a 33 f1			ld hl, (os_tok_ptr) 
2116 23				inc hl 
2117 23				inc hl    ; position to start of dict word 
2118 3e 00			ld a, 0 
211a cd 28 11			call strlent 
211d			 
211d			 
211d 23				inc hl    ; to include null??? 
211e			 
211e				; write length of dict word 
211e			 
211e ed 5b 36 f0		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2122 1b				dec de 
2123 eb				ex de, hl 
2124 73				ld (hl), e 
2125 eb				ex de, hl 
2126			 
2126				 
2126			 
2126				; copy  
2126 4d				ld c, l 
2127 06 00			ld b, 0 
2129 ed 5b 36 f0		ld de, (os_new_work_ptr)   ; get dest for copy of word 
212d 2a 33 f1			ld hl, (os_tok_ptr) 
2130 23				inc hl 
2131 23				inc hl    ; position to start of dict word 
2132				 
2132			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2132				 
2132				; TODO need to convert word to upper case 
2132			 
2132			ucasetok:	 
2132 7e				ld a,(hl) 
2133 cd 14 11			call toUpper 
2136 77				ld (hl),a 
2137 ed a0			ldi 
2139 f2 32 21		 	jp p, ucasetok 
213c			 
213c			 
213c			 
213c				; de now points to start of where the word body code should be placed 
213c ed 53 36 f0		ld (os_new_work_ptr), de 
2140				; hl now points to the words to throw at forthexec which needs to be copied 
2140 22 38 f0			ld (os_new_src_ptr), hl 
2143			 
2143				; TODO add 'call to forthexec' 
2143			 
2143			if DEBUG_FORTH_UWORD 
2143 c5				push bc 
2144 ed 4b 30 f0		ld bc, (os_new_malloc) 
2148						DMARK ":0x" 
2148 f5				push af  
2149 3a 5d 21			ld a, (.dmark)  
214c 32 77 fb			ld (debug_mark),a  
214f 3a 5e 21			ld a, (.dmark+1)  
2152 32 78 fb			ld (debug_mark+1),a  
2155 3a 5f 21			ld a, (.dmark+2)  
2158 32 79 fb			ld (debug_mark+2),a  
215b 18 03			jr .pastdmark  
215d ..			.dmark: db ":0x"  
2160 f1			.pastdmark: pop af  
2161			endm  
# End of macro DMARK
2161				CALLMONITOR 
2161 cd 01 15			call break_point_state  
2164				endm  
# End of macro CALLMONITOR
2164 c1				pop bc 
2165			endif 
2165			 
2165			 
2165				; create word preamble which should be: 
2165			 
2165			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2165			 
2165				;    ld hl, <word code> 
2165				;    jp user_exec 
2165			        ;    <word code bytes> 
2165			 
2165			 
2165			;	inc de     ; TODO ??? or are we already past the word's null 
2165 eb				ex de, hl 
2166			 
2166 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2168			 
2168 23				inc hl 
2169 22 3c f0			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
216c 23				inc hl 
216d			 
216d 23				inc hl 
216e 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2170			 
2170 01 65 4e			ld bc, user_exec 
2173 23				inc hl 
2174 71				ld (hl), c     ; poke address of user_exec 
2175 23				inc hl 
2176 70				ld (hl), b     
2177			 ; 
2177			;	inc hl 
2177			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2177			; 
2177			; 
2177			;	ld bc, macro_forth_rsp_next 
2177			;	inc hl 
2177			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2177			;	inc hl 
2177			;	ld (hl), b     
2177			 ; 
2177			;	inc hl 
2177			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2177			; 
2177			; 
2177			;	inc hl 
2177			;	ld bc, forthexec 
2177			;	ld (hl), c     ; poke address of forthexec 
2177			;	inc hl 
2177			;	ld (hl), b      
2177			; 
2177			;	inc hl 
2177			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2177			; 
2177			;	ld bc, user_dict_next 
2177			;	inc hl 
2177			;	ld (hl), c     ; poke address of forthexec 
2177			;	inc hl 
2177			;	ld (hl), b      
2177			 
2177				; hl is now where we need to copy the word byte data to save this 
2177			 
2177 23				inc hl 
2178 22 3a f0			ld (os_new_exec), hl 
217b				 
217b				; copy definition 
217b			 
217b eb				ex de, hl 
217c			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
217c			;	inc de    ; skip the PC for this parse 
217c 3a 32 f0			ld a, (os_new_parse_len) 
217f 4f				ld c, a 
2180 06 00			ld b, 0 
2182 ed b0			ldir		 ; copy defintion 
2184			 
2184			 
2184				; poke the address of where the new word bytes live for forthexec 
2184			 
2184 2a 3c f0			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2187			 
2187 ed 5b 3a f0		ld de, (os_new_exec)      
218b				 
218b 73				ld (hl), e 
218c 23				inc hl 
218d 72				ld (hl), d 
218e			 
218e					; TODO copy last user dict word next link to this word 
218e					; TODO update last user dict word to point to this word 
218e			; 
218e			; hl f923 de 812a ; bc 811a 
218e			 
218e			if DEBUG_FORTH_UWORD 
218e c5				push bc 
218f ed 4b 30 f0		ld bc, (os_new_malloc) 
2193						DMARK ":0A" 
2193 f5				push af  
2194 3a a8 21			ld a, (.dmark)  
2197 32 77 fb			ld (debug_mark),a  
219a 3a a9 21			ld a, (.dmark+1)  
219d 32 78 fb			ld (debug_mark+1),a  
21a0 3a aa 21			ld a, (.dmark+2)  
21a3 32 79 fb			ld (debug_mark+2),a  
21a6 18 03			jr .pastdmark  
21a8 ..			.dmark: db ":0A"  
21ab f1			.pastdmark: pop af  
21ac			endm  
# End of macro DMARK
21ac				CALLMONITOR 
21ac cd 01 15			call break_point_state  
21af				endm  
# End of macro CALLMONITOR
21af c1				pop bc 
21b0			endif 
21b0			if DEBUG_FORTH_UWORD 
21b0 c5				push bc 
21b1 ed 4b 30 f0		ld bc, (os_new_malloc) 
21b5 03				inc bc 
21b6 03				inc bc 
21b7 03				inc bc 
21b8 03				inc bc 
21b9 03				inc bc 
21ba 03				inc bc 
21bb 03				inc bc 
21bc 03				inc bc 
21bd			 
21bd						DMARK ":0B" 
21bd f5				push af  
21be 3a d2 21			ld a, (.dmark)  
21c1 32 77 fb			ld (debug_mark),a  
21c4 3a d3 21			ld a, (.dmark+1)  
21c7 32 78 fb			ld (debug_mark+1),a  
21ca 3a d4 21			ld a, (.dmark+2)  
21cd 32 79 fb			ld (debug_mark+2),a  
21d0 18 03			jr .pastdmark  
21d2 ..			.dmark: db ":0B"  
21d5 f1			.pastdmark: pop af  
21d6			endm  
# End of macro DMARK
21d6				CALLMONITOR 
21d6 cd 01 15			call break_point_state  
21d9				endm  
# End of macro CALLMONITOR
21d9 c1				pop bc 
21da			endif 
21da			 
21da			; update word dict linked list for new word 
21da			 
21da			 
21da 2a 2f f1		ld hl, (os_last_new_uword)		; get the start of the last added uword 
21dd 23			inc hl     ; move to next work linked list ptr 
21de			 
21de ed 5b 30 f0	ld de, (os_new_malloc)		 ; new next word 
21e2 73			ld (hl), e 
21e3 23			inc hl 
21e4 72			ld (hl), d 
21e5			 
21e5			if DEBUG_FORTH_UWORD 
21e5 ed 4b 2f f1		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
21e9			endif 
21e9			 
21e9 ed 53 2f f1	ld (os_last_new_uword), de      ; update last new uword ptr 
21ed			 
21ed			 
21ed			if DEBUG_FORTH_UWORD 
21ed						DMARK ":0+" 
21ed f5				push af  
21ee 3a 02 22			ld a, (.dmark)  
21f1 32 77 fb			ld (debug_mark),a  
21f4 3a 03 22			ld a, (.dmark+1)  
21f7 32 78 fb			ld (debug_mark+1),a  
21fa 3a 04 22			ld a, (.dmark+2)  
21fd 32 79 fb			ld (debug_mark+2),a  
2200 18 03			jr .pastdmark  
2202 ..			.dmark: db ":0+"  
2205 f1			.pastdmark: pop af  
2206			endm  
# End of macro DMARK
2206				CALLMONITOR 
2206 cd 01 15			call break_point_state  
2209				endm  
# End of macro CALLMONITOR
2209			endif 
2209			 
2209				STACKFRAMECHK OFF $8efe $989f 
2209				if DEBUG_STACK_IMB 
2209					if OFF 
2209						exx 
2209						ld hl, $989f 
2209						pop de   ; $989f 
2209						call cmp16 
2209						jr nz, .spnosame 
2209						ld hl, $8efe 
2209						pop de   ; $8efe 
2209						call cmp16 
2209						jr z, .spfrsame 
2209						.spnosame: call showsperror 
2209						.spfrsame: nop 
2209						exx 
2209					endif 
2209				endif 
2209			endm 
# End of macro STACKFRAMECHK
2209			 
2209 c9			ret    ; dont process any remaining parser tokens as they form new word 
220a			 
220a			 
220a			 
220a			 
220a			;		NEXT 
220a			.SCOLN: 
220a			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
220a 06				db OPCODE_SCOLN 
220b 56 22			dw .DROP 
220d 02				db 2 
220e .. 00			db ";",0           
2210			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2210					if DEBUG_FORTH_WORDS_KEY 
2210						DMARK "SCN" 
2210 f5				push af  
2211 3a 25 22			ld a, (.dmark)  
2214 32 77 fb			ld (debug_mark),a  
2217 3a 26 22			ld a, (.dmark+1)  
221a 32 78 fb			ld (debug_mark+1),a  
221d 3a 27 22			ld a, (.dmark+2)  
2220 32 79 fb			ld (debug_mark+2),a  
2223 18 03			jr .pastdmark  
2225 ..			.dmark: db "SCN"  
2228 f1			.pastdmark: pop af  
2229			endm  
# End of macro DMARK
2229						CALLMONITOR 
2229 cd 01 15			call break_point_state  
222c				endm  
# End of macro CALLMONITOR
222c					endif 
222c					FORTH_RSP_TOS 
222c cd 59 1a			call macro_forth_rsp_tos 
222f				endm 
# End of macro FORTH_RSP_TOS
222f e5					push hl 
2230					FORTH_RSP_POP 
2230 cd 63 1a			call macro_forth_rsp_pop 
2233				endm 
# End of macro FORTH_RSP_POP
2233 e1					pop hl 
2234			;		ex de,hl 
2234 22 33 f1				ld (os_tok_ptr),hl 
2237			 
2237			if DEBUG_FORTH_UWORD 
2237						DMARK "SCL" 
2237 f5				push af  
2238 3a 4c 22			ld a, (.dmark)  
223b 32 77 fb			ld (debug_mark),a  
223e 3a 4d 22			ld a, (.dmark+1)  
2241 32 78 fb			ld (debug_mark+1),a  
2244 3a 4e 22			ld a, (.dmark+2)  
2247 32 79 fb			ld (debug_mark+2),a  
224a 18 03			jr .pastdmark  
224c ..			.dmark: db "SCL"  
224f f1			.pastdmark: pop af  
2250			endm  
# End of macro DMARK
2250				CALLMONITOR 
2250 cd 01 15			call break_point_state  
2253				endm  
# End of macro CALLMONITOR
2253			endif 
2253					NEXTW 
2253 c3 8c 1c			jp macro_next 
2256				endm 
# End of macro NEXTW
2256			 
2256			.DROP: 
2256				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2256 1b				db WORD_SYS_CORE+OPCODE_DROP             
2257 81 22			dw .DUP2            
2259 05				db 4 + 1 
225a .. 00			db "DROP",0              
225f				endm 
# End of macro CWHEAD
225f			; | DROP ( w -- )   drop the TOS item   | DONE 
225f					if DEBUG_FORTH_WORDS_KEY 
225f						DMARK "DRP" 
225f f5				push af  
2260 3a 74 22			ld a, (.dmark)  
2263 32 77 fb			ld (debug_mark),a  
2266 3a 75 22			ld a, (.dmark+1)  
2269 32 78 fb			ld (debug_mark+1),a  
226c 3a 76 22			ld a, (.dmark+2)  
226f 32 79 fb			ld (debug_mark+2),a  
2272 18 03			jr .pastdmark  
2274 ..			.dmark: db "DRP"  
2277 f1			.pastdmark: pop af  
2278			endm  
# End of macro DMARK
2278						CALLMONITOR 
2278 cd 01 15			call break_point_state  
227b				endm  
# End of macro CALLMONITOR
227b					endif 
227b					FORTH_DSP_POP 
227b cd d2 1b			call macro_forth_dsp_pop 
227e				endm 
# End of macro FORTH_DSP_POP
227e					NEXTW 
227e c3 8c 1c			jp macro_next 
2281				endm 
# End of macro NEXTW
2281			.DUP2: 
2281				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2281 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2282 c6 22			dw .DROP2            
2284 05				db 4 + 1 
2285 .. 00			db "2DUP",0              
228a				endm 
# End of macro CWHEAD
228a			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
228a					if DEBUG_FORTH_WORDS_KEY 
228a						DMARK "2DU" 
228a f5				push af  
228b 3a 9f 22			ld a, (.dmark)  
228e 32 77 fb			ld (debug_mark),a  
2291 3a a0 22			ld a, (.dmark+1)  
2294 32 78 fb			ld (debug_mark+1),a  
2297 3a a1 22			ld a, (.dmark+2)  
229a 32 79 fb			ld (debug_mark+2),a  
229d 18 03			jr .pastdmark  
229f ..			.dmark: db "2DU"  
22a2 f1			.pastdmark: pop af  
22a3			endm  
# End of macro DMARK
22a3						CALLMONITOR 
22a3 cd 01 15			call break_point_state  
22a6				endm  
# End of macro CALLMONITOR
22a6					endif 
22a6					FORTH_DSP_VALUEHL 
22a6 cd 36 1b			call macro_dsp_valuehl 
22a9				endm 
# End of macro FORTH_DSP_VALUEHL
22a9 e5					push hl      ; 2 
22aa			 
22aa					FORTH_DSP_POP 
22aa cd d2 1b			call macro_forth_dsp_pop 
22ad				endm 
# End of macro FORTH_DSP_POP
22ad					 
22ad					FORTH_DSP_VALUEHL 
22ad cd 36 1b			call macro_dsp_valuehl 
22b0				endm 
# End of macro FORTH_DSP_VALUEHL
22b0			;		push hl      ; 1 
22b0			 
22b0					FORTH_DSP_POP 
22b0 cd d2 1b			call macro_forth_dsp_pop 
22b3				endm 
# End of macro FORTH_DSP_POP
22b3			 
22b3			;		pop hl       ; 1 
22b3 d1					pop de       ; 2 
22b4			 
22b4 cd 9b 1a				call forth_push_numhl 
22b7 eb					ex de, hl 
22b8 cd 9b 1a				call forth_push_numhl 
22bb			 
22bb					 
22bb eb					ex de, hl 
22bc			 
22bc cd 9b 1a				call forth_push_numhl 
22bf eb					ex de, hl 
22c0 cd 9b 1a				call forth_push_numhl 
22c3			 
22c3			 
22c3					NEXTW 
22c3 c3 8c 1c			jp macro_next 
22c6				endm 
# End of macro NEXTW
22c6			.DROP2: 
22c6				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
22c6 1d				db WORD_SYS_CORE+OPCODE_DROP2             
22c7 f5 22			dw .SWAP2            
22c9 06				db 5 + 1 
22ca .. 00			db "2DROP",0              
22d0				endm 
# End of macro CWHEAD
22d0			; | 2DROP ( w w -- )    Double drop | DONE 
22d0					if DEBUG_FORTH_WORDS_KEY 
22d0						DMARK "2DR" 
22d0 f5				push af  
22d1 3a e5 22			ld a, (.dmark)  
22d4 32 77 fb			ld (debug_mark),a  
22d7 3a e6 22			ld a, (.dmark+1)  
22da 32 78 fb			ld (debug_mark+1),a  
22dd 3a e7 22			ld a, (.dmark+2)  
22e0 32 79 fb			ld (debug_mark+2),a  
22e3 18 03			jr .pastdmark  
22e5 ..			.dmark: db "2DR"  
22e8 f1			.pastdmark: pop af  
22e9			endm  
# End of macro DMARK
22e9						CALLMONITOR 
22e9 cd 01 15			call break_point_state  
22ec				endm  
# End of macro CALLMONITOR
22ec					endif 
22ec					FORTH_DSP_POP 
22ec cd d2 1b			call macro_forth_dsp_pop 
22ef				endm 
# End of macro FORTH_DSP_POP
22ef					FORTH_DSP_POP 
22ef cd d2 1b			call macro_forth_dsp_pop 
22f2				endm 
# End of macro FORTH_DSP_POP
22f2					NEXTW 
22f2 c3 8c 1c			jp macro_next 
22f5				endm 
# End of macro NEXTW
22f5			.SWAP2: 
22f5				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
22f5 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
22f6 1e 23			dw .AT            
22f8 06				db 5 + 1 
22f9 .. 00			db "2SWAP",0              
22ff				endm 
# End of macro CWHEAD
22ff			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
22ff					if DEBUG_FORTH_WORDS_KEY 
22ff						DMARK "2SW" 
22ff f5				push af  
2300 3a 14 23			ld a, (.dmark)  
2303 32 77 fb			ld (debug_mark),a  
2306 3a 15 23			ld a, (.dmark+1)  
2309 32 78 fb			ld (debug_mark+1),a  
230c 3a 16 23			ld a, (.dmark+2)  
230f 32 79 fb			ld (debug_mark+2),a  
2312 18 03			jr .pastdmark  
2314 ..			.dmark: db "2SW"  
2317 f1			.pastdmark: pop af  
2318			endm  
# End of macro DMARK
2318						CALLMONITOR 
2318 cd 01 15			call break_point_state  
231b				endm  
# End of macro CALLMONITOR
231b					endif 
231b					NEXTW 
231b c3 8c 1c			jp macro_next 
231e				endm 
# End of macro NEXTW
231e			.AT: 
231e				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
231e 1f				db WORD_SYS_CORE+OPCODE_AT             
231f 50 23			dw .CAT            
2321 02				db 1 + 1 
2322 .. 00			db "@",0              
2324				endm 
# End of macro CWHEAD
2324			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2324			 
2324					if DEBUG_FORTH_WORDS_KEY 
2324						DMARK "AT." 
2324 f5				push af  
2325 3a 39 23			ld a, (.dmark)  
2328 32 77 fb			ld (debug_mark),a  
232b 3a 3a 23			ld a, (.dmark+1)  
232e 32 78 fb			ld (debug_mark+1),a  
2331 3a 3b 23			ld a, (.dmark+2)  
2334 32 79 fb			ld (debug_mark+2),a  
2337 18 03			jr .pastdmark  
2339 ..			.dmark: db "AT."  
233c f1			.pastdmark: pop af  
233d			endm  
# End of macro DMARK
233d						CALLMONITOR 
233d cd 01 15			call break_point_state  
2340				endm  
# End of macro CALLMONITOR
2340					endif 
2340			.getbyteat:	 
2340					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2340 cd 36 1b			call macro_dsp_valuehl 
2343				endm 
# End of macro FORTH_DSP_VALUEHL
2343					 
2343			;		push hl 
2343				 
2343					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2343 cd d2 1b			call macro_forth_dsp_pop 
2346				endm 
# End of macro FORTH_DSP_POP
2346			 
2346			;		pop hl 
2346			 
2346 7e					ld a, (hl) 
2347			 
2347 6f					ld l, a 
2348 26 00				ld h, 0 
234a cd 9b 1a				call forth_push_numhl 
234d			 
234d					NEXTW 
234d c3 8c 1c			jp macro_next 
2350				endm 
# End of macro NEXTW
2350			.CAT: 
2350				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2350 20				db WORD_SYS_CORE+OPCODE_CAT             
2351 79 23			dw .BANG            
2353 03				db 2 + 1 
2354 .. 00			db "C@",0              
2357				endm 
# End of macro CWHEAD
2357			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2357					if DEBUG_FORTH_WORDS_KEY 
2357						DMARK "CAA" 
2357 f5				push af  
2358 3a 6c 23			ld a, (.dmark)  
235b 32 77 fb			ld (debug_mark),a  
235e 3a 6d 23			ld a, (.dmark+1)  
2361 32 78 fb			ld (debug_mark+1),a  
2364 3a 6e 23			ld a, (.dmark+2)  
2367 32 79 fb			ld (debug_mark+2),a  
236a 18 03			jr .pastdmark  
236c ..			.dmark: db "CAA"  
236f f1			.pastdmark: pop af  
2370			endm  
# End of macro DMARK
2370						CALLMONITOR 
2370 cd 01 15			call break_point_state  
2373				endm  
# End of macro CALLMONITOR
2373					endif 
2373 c3 40 23				jp .getbyteat 
2376					NEXTW 
2376 c3 8c 1c			jp macro_next 
2379				endm 
# End of macro NEXTW
2379			.BANG: 
2379				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2379 21				db WORD_SYS_CORE+OPCODE_BANG             
237a af 23			dw .CBANG            
237c 02				db 1 + 1 
237d .. 00			db "!",0              
237f				endm 
# End of macro CWHEAD
237f			; | ! ( x w -- ) Store x at address w      | DONE 
237f					if DEBUG_FORTH_WORDS_KEY 
237f						DMARK "BNG" 
237f f5				push af  
2380 3a 94 23			ld a, (.dmark)  
2383 32 77 fb			ld (debug_mark),a  
2386 3a 95 23			ld a, (.dmark+1)  
2389 32 78 fb			ld (debug_mark+1),a  
238c 3a 96 23			ld a, (.dmark+2)  
238f 32 79 fb			ld (debug_mark+2),a  
2392 18 03			jr .pastdmark  
2394 ..			.dmark: db "BNG"  
2397 f1			.pastdmark: pop af  
2398			endm  
# End of macro DMARK
2398						CALLMONITOR 
2398 cd 01 15			call break_point_state  
239b				endm  
# End of macro CALLMONITOR
239b					endif 
239b			 
239b			.storebyteat:		 
239b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
239b cd 36 1b			call macro_dsp_valuehl 
239e				endm 
# End of macro FORTH_DSP_VALUEHL
239e					 
239e e5					push hl 
239f				 
239f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
239f cd d2 1b			call macro_forth_dsp_pop 
23a2				endm 
# End of macro FORTH_DSP_POP
23a2			 
23a2					; get byte to poke 
23a2			 
23a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23a2 cd 36 1b			call macro_dsp_valuehl 
23a5				endm 
# End of macro FORTH_DSP_VALUEHL
23a5 e5					push hl 
23a6			 
23a6			 
23a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23a6 cd d2 1b			call macro_forth_dsp_pop 
23a9				endm 
# End of macro FORTH_DSP_POP
23a9			 
23a9			 
23a9 d1					pop de 
23aa e1					pop hl 
23ab			 
23ab 73					ld (hl),e 
23ac			 
23ac			 
23ac					NEXTW 
23ac c3 8c 1c			jp macro_next 
23af				endm 
# End of macro NEXTW
23af			.CBANG: 
23af				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
23af 22				db WORD_SYS_CORE+OPCODE_CBANG             
23b0 d8 23			dw .SCALL            
23b2 03				db 2 + 1 
23b3 .. 00			db "C!",0              
23b6				endm 
# End of macro CWHEAD
23b6			; | C!  ( x w -- ) Store x at address w  | DONE 
23b6					if DEBUG_FORTH_WORDS_KEY 
23b6						DMARK "CBA" 
23b6 f5				push af  
23b7 3a cb 23			ld a, (.dmark)  
23ba 32 77 fb			ld (debug_mark),a  
23bd 3a cc 23			ld a, (.dmark+1)  
23c0 32 78 fb			ld (debug_mark+1),a  
23c3 3a cd 23			ld a, (.dmark+2)  
23c6 32 79 fb			ld (debug_mark+2),a  
23c9 18 03			jr .pastdmark  
23cb ..			.dmark: db "CBA"  
23ce f1			.pastdmark: pop af  
23cf			endm  
# End of macro DMARK
23cf						CALLMONITOR 
23cf cd 01 15			call break_point_state  
23d2				endm  
# End of macro CALLMONITOR
23d2					endif 
23d2 c3 9b 23				jp .storebyteat 
23d5					NEXTW 
23d5 c3 8c 1c			jp macro_next 
23d8				endm 
# End of macro NEXTW
23d8			.SCALL: 
23d8				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
23d8 23				db WORD_SYS_CORE+OPCODE_SCALL             
23d9 0c 24			dw .DEPTH            
23db 05				db 4 + 1 
23dc .. 00			db "CALL",0              
23e1				endm 
# End of macro CWHEAD
23e1			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
23e1					if DEBUG_FORTH_WORDS_KEY 
23e1						DMARK "CLL" 
23e1 f5				push af  
23e2 3a f6 23			ld a, (.dmark)  
23e5 32 77 fb			ld (debug_mark),a  
23e8 3a f7 23			ld a, (.dmark+1)  
23eb 32 78 fb			ld (debug_mark+1),a  
23ee 3a f8 23			ld a, (.dmark+2)  
23f1 32 79 fb			ld (debug_mark+2),a  
23f4 18 03			jr .pastdmark  
23f6 ..			.dmark: db "CLL"  
23f9 f1			.pastdmark: pop af  
23fa			endm  
# End of macro DMARK
23fa						CALLMONITOR 
23fa cd 01 15			call break_point_state  
23fd				endm  
# End of macro CALLMONITOR
23fd					endif 
23fd			 
23fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23fd cd 36 1b			call macro_dsp_valuehl 
2400				endm 
# End of macro FORTH_DSP_VALUEHL
2400			 
2400			;		push hl 
2400			 
2400					; destroy value TOS 
2400			 
2400					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2400 cd d2 1b			call macro_forth_dsp_pop 
2403				endm 
# End of macro FORTH_DSP_POP
2403			 
2403						 
2403			;		pop hl 
2403			 
2403					; how to do a call with hl???? save SP? 
2403 cd 35 1c				call forth_call_hl 
2406			 
2406			 
2406					; TODO push value back onto stack for another op etc 
2406			 
2406 cd 9b 1a				call forth_push_numhl 
2409					NEXTW 
2409 c3 8c 1c			jp macro_next 
240c				endm 
# End of macro NEXTW
240c			.DEPTH: 
240c				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
240c 24				db WORD_SYS_CORE+OPCODE_DEPTH             
240d 49 24			dw .OVER            
240f 06				db 5 + 1 
2410 .. 00			db "DEPTH",0              
2416				endm 
# End of macro CWHEAD
2416			; | DEPTH ( -- u ) Push count of stack | DONE 
2416					; take current TOS and remove from base value div by two to get count 
2416					if DEBUG_FORTH_WORDS_KEY 
2416						DMARK "DEP" 
2416 f5				push af  
2417 3a 2b 24			ld a, (.dmark)  
241a 32 77 fb			ld (debug_mark),a  
241d 3a 2c 24			ld a, (.dmark+1)  
2420 32 78 fb			ld (debug_mark+1),a  
2423 3a 2d 24			ld a, (.dmark+2)  
2426 32 79 fb			ld (debug_mark+2),a  
2429 18 03			jr .pastdmark  
242b ..			.dmark: db "DEP"  
242e f1			.pastdmark: pop af  
242f			endm  
# End of macro DMARK
242f						CALLMONITOR 
242f cd 01 15			call break_point_state  
2432				endm  
# End of macro CALLMONITOR
2432					endif 
2432			 
2432			 
2432 2a 1f f8			ld hl, (cli_data_sp) 
2435 11 99 f3			ld de, cli_data_stack 
2438 ed 52			sbc hl,de 
243a				 
243a				; div by size of stack item 
243a			 
243a 5d				ld e,l 
243b 0e 03			ld c, 3 
243d cd 4f 0c			call Div8 
2440			 
2440 6f				ld l,a 
2441 26 00			ld h,0 
2443			 
2443				;srl h 
2443				;rr l 
2443			 
2443 cd 9b 1a				call forth_push_numhl 
2446					NEXTW 
2446 c3 8c 1c			jp macro_next 
2449				endm 
# End of macro NEXTW
2449			.OVER: 
2449				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2449 42				db WORD_SYS_CORE+46             
244a 90 24			dw .PAUSE            
244c 05				db 4 + 1 
244d .. 00			db "OVER",0              
2452				endm 
# End of macro CWHEAD
2452			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2452					if DEBUG_FORTH_WORDS_KEY 
2452						DMARK "OVR" 
2452 f5				push af  
2453 3a 67 24			ld a, (.dmark)  
2456 32 77 fb			ld (debug_mark),a  
2459 3a 68 24			ld a, (.dmark+1)  
245c 32 78 fb			ld (debug_mark+1),a  
245f 3a 69 24			ld a, (.dmark+2)  
2462 32 79 fb			ld (debug_mark+2),a  
2465 18 03			jr .pastdmark  
2467 ..			.dmark: db "OVR"  
246a f1			.pastdmark: pop af  
246b			endm  
# End of macro DMARK
246b						CALLMONITOR 
246b cd 01 15			call break_point_state  
246e				endm  
# End of macro CALLMONITOR
246e					endif 
246e			 
246e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
246e cd 36 1b			call macro_dsp_valuehl 
2471				endm 
# End of macro FORTH_DSP_VALUEHL
2471 e5					push hl    ; n2 
2472					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2472 cd d2 1b			call macro_forth_dsp_pop 
2475				endm 
# End of macro FORTH_DSP_POP
2475			 
2475					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2475 cd 36 1b			call macro_dsp_valuehl 
2478				endm 
# End of macro FORTH_DSP_VALUEHL
2478 e5					push hl    ; n1 
2479					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2479 cd d2 1b			call macro_forth_dsp_pop 
247c				endm 
# End of macro FORTH_DSP_POP
247c			 
247c d1					pop de     ; n1 
247d e1					pop hl     ; n2 
247e			 
247e d5					push de 
247f e5					push hl 
2480 d5					push de 
2481			 
2481					; push back  
2481			 
2481 e1					pop hl 
2482 cd 9b 1a				call forth_push_numhl 
2485 e1					pop hl 
2486 cd 9b 1a				call forth_push_numhl 
2489 e1					pop hl 
248a cd 9b 1a				call forth_push_numhl 
248d					NEXTW 
248d c3 8c 1c			jp macro_next 
2490				endm 
# End of macro NEXTW
2490			 
2490			.PAUSE: 
2490				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2490 43				db WORD_SYS_CORE+47             
2491 c5 24			dw .PAUSES            
2493 08				db 7 + 1 
2494 .. 00			db "PAUSEMS",0              
249c				endm 
# End of macro CWHEAD
249c			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
249c					if DEBUG_FORTH_WORDS_KEY 
249c						DMARK "PMS" 
249c f5				push af  
249d 3a b1 24			ld a, (.dmark)  
24a0 32 77 fb			ld (debug_mark),a  
24a3 3a b2 24			ld a, (.dmark+1)  
24a6 32 78 fb			ld (debug_mark+1),a  
24a9 3a b3 24			ld a, (.dmark+2)  
24ac 32 79 fb			ld (debug_mark+2),a  
24af 18 03			jr .pastdmark  
24b1 ..			.dmark: db "PMS"  
24b4 f1			.pastdmark: pop af  
24b5			endm  
# End of macro DMARK
24b5						CALLMONITOR 
24b5 cd 01 15			call break_point_state  
24b8				endm  
# End of macro CALLMONITOR
24b8					endif 
24b8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24b8 cd 36 1b			call macro_dsp_valuehl 
24bb				endm 
# End of macro FORTH_DSP_VALUEHL
24bb			;		push hl    ; n2 
24bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24bb cd d2 1b			call macro_forth_dsp_pop 
24be				endm 
# End of macro FORTH_DSP_POP
24be			;		pop hl 
24be			 
24be 7d					ld a, l 
24bf cd 22 0a				call aDelayInMS 
24c2				       NEXTW 
24c2 c3 8c 1c			jp macro_next 
24c5				endm 
# End of macro NEXTW
24c5			.PAUSES:  
24c5				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
24c5 44				db WORD_SYS_CORE+48             
24c6 34 25			dw .ROT            
24c8 06				db 5 + 1 
24c9 .. 00			db "PAUSE",0              
24cf				endm 
# End of macro CWHEAD
24cf			; | PAUSE ( n -- )  Pause for n seconds | DONE 
24cf					if DEBUG_FORTH_WORDS_KEY 
24cf						DMARK "PAU" 
24cf f5				push af  
24d0 3a e4 24			ld a, (.dmark)  
24d3 32 77 fb			ld (debug_mark),a  
24d6 3a e5 24			ld a, (.dmark+1)  
24d9 32 78 fb			ld (debug_mark+1),a  
24dc 3a e6 24			ld a, (.dmark+2)  
24df 32 79 fb			ld (debug_mark+2),a  
24e2 18 03			jr .pastdmark  
24e4 ..			.dmark: db "PAU"  
24e7 f1			.pastdmark: pop af  
24e8			endm  
# End of macro DMARK
24e8						CALLMONITOR 
24e8 cd 01 15			call break_point_state  
24eb				endm  
# End of macro CALLMONITOR
24eb					endif 
24eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24eb cd 36 1b			call macro_dsp_valuehl 
24ee				endm 
# End of macro FORTH_DSP_VALUEHL
24ee			;		push hl    ; n2 
24ee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24ee cd d2 1b			call macro_forth_dsp_pop 
24f1				endm 
# End of macro FORTH_DSP_POP
24f1			;		pop hl 
24f1 45					ld b, l 
24f2					if DEBUG_FORTH_WORDS 
24f2						DMARK "PAU" 
24f2 f5				push af  
24f3 3a 07 25			ld a, (.dmark)  
24f6 32 77 fb			ld (debug_mark),a  
24f9 3a 08 25			ld a, (.dmark+1)  
24fc 32 78 fb			ld (debug_mark+1),a  
24ff 3a 09 25			ld a, (.dmark+2)  
2502 32 79 fb			ld (debug_mark+2),a  
2505 18 03			jr .pastdmark  
2507 ..			.dmark: db "PAU"  
250a f1			.pastdmark: pop af  
250b			endm  
# End of macro DMARK
250b						CALLMONITOR 
250b cd 01 15			call break_point_state  
250e				endm  
# End of macro CALLMONITOR
250e					endif 
250e c5			.pauses1:	push bc 
250f cd 3d 0a				call delay1s 
2512 c1					pop bc 
2513					if DEBUG_FORTH_WORDS 
2513						DMARK "PA1" 
2513 f5				push af  
2514 3a 28 25			ld a, (.dmark)  
2517 32 77 fb			ld (debug_mark),a  
251a 3a 29 25			ld a, (.dmark+1)  
251d 32 78 fb			ld (debug_mark+1),a  
2520 3a 2a 25			ld a, (.dmark+2)  
2523 32 79 fb			ld (debug_mark+2),a  
2526 18 03			jr .pastdmark  
2528 ..			.dmark: db "PA1"  
252b f1			.pastdmark: pop af  
252c			endm  
# End of macro DMARK
252c						CALLMONITOR 
252c cd 01 15			call break_point_state  
252f				endm  
# End of macro CALLMONITOR
252f					endif 
252f 10 dd				djnz .pauses1 
2531			 
2531				       NEXTW 
2531 c3 8c 1c			jp macro_next 
2534				endm 
# End of macro NEXTW
2534			.ROT: 
2534				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2534 45				db WORD_SYS_CORE+49             
2535 82 25			dw .UWORDS            
2537 04				db 3 + 1 
2538 .. 00			db "ROT",0              
253c				endm 
# End of macro CWHEAD
253c			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
253c					if DEBUG_FORTH_WORDS_KEY 
253c						DMARK "ROT" 
253c f5				push af  
253d 3a 51 25			ld a, (.dmark)  
2540 32 77 fb			ld (debug_mark),a  
2543 3a 52 25			ld a, (.dmark+1)  
2546 32 78 fb			ld (debug_mark+1),a  
2549 3a 53 25			ld a, (.dmark+2)  
254c 32 79 fb			ld (debug_mark+2),a  
254f 18 03			jr .pastdmark  
2551 ..			.dmark: db "ROT"  
2554 f1			.pastdmark: pop af  
2555			endm  
# End of macro DMARK
2555						CALLMONITOR 
2555 cd 01 15			call break_point_state  
2558				endm  
# End of macro CALLMONITOR
2558					endif 
2558			 
2558					FORTH_DSP_VALUEHL 
2558 cd 36 1b			call macro_dsp_valuehl 
255b				endm 
# End of macro FORTH_DSP_VALUEHL
255b e5					push hl    ; u3  
255c			 
255c					FORTH_DSP_POP 
255c cd d2 1b			call macro_forth_dsp_pop 
255f				endm 
# End of macro FORTH_DSP_POP
255f			   
255f					FORTH_DSP_VALUEHL 
255f cd 36 1b			call macro_dsp_valuehl 
2562				endm 
# End of macro FORTH_DSP_VALUEHL
2562 e5					push hl     ; u2 
2563			 
2563					FORTH_DSP_POP 
2563 cd d2 1b			call macro_forth_dsp_pop 
2566				endm 
# End of macro FORTH_DSP_POP
2566			 
2566					FORTH_DSP_VALUEHL 
2566 cd 36 1b			call macro_dsp_valuehl 
2569				endm 
# End of macro FORTH_DSP_VALUEHL
2569 e5					push hl     ; u1 
256a			 
256a					FORTH_DSP_POP 
256a cd d2 1b			call macro_forth_dsp_pop 
256d				endm 
# End of macro FORTH_DSP_POP
256d			 
256d c1					pop bc      ; u1 
256e e1					pop hl      ; u2 
256f d1					pop de      ; u3 
2570			 
2570			 
2570 c5					push bc 
2571 d5					push de 
2572 e5					push hl 
2573			 
2573			 
2573 e1					pop hl 
2574 cd 9b 1a				call forth_push_numhl 
2577			 
2577 e1					pop hl 
2578 cd 9b 1a				call forth_push_numhl 
257b			 
257b e1					pop hl 
257c cd 9b 1a				call forth_push_numhl 
257f					 
257f			 
257f			 
257f			 
257f			 
257f			 
257f				       NEXTW 
257f c3 8c 1c			jp macro_next 
2582				endm 
# End of macro NEXTW
2582			 
2582			.UWORDS: 
2582				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2582 50				db WORD_SYS_CORE+60             
2583 44 26			dw .BP            
2585 07				db 6 + 1 
2586 .. 00			db "UWORDS",0              
258d				endm 
# End of macro CWHEAD
258d			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
258d			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
258d			; | | Following the count are the individual words. 
258d			; | | 
258d			; | | e.g. UWORDS 
258d			; | | BOX DIRLIST 2 
258d			; | |  
258d			; | | Can be used to save the words to storage via: 
258d			; | | UWORDS $01 DO $01 APPEND LOOP 
258d				if DEBUG_FORTH_WORDS_KEY 
258d					DMARK "UWR" 
258d f5				push af  
258e 3a a2 25			ld a, (.dmark)  
2591 32 77 fb			ld (debug_mark),a  
2594 3a a3 25			ld a, (.dmark+1)  
2597 32 78 fb			ld (debug_mark+1),a  
259a 3a a4 25			ld a, (.dmark+2)  
259d 32 79 fb			ld (debug_mark+2),a  
25a0 18 03			jr .pastdmark  
25a2 ..			.dmark: db "UWR"  
25a5 f1			.pastdmark: pop af  
25a6			endm  
# End of macro DMARK
25a6					CALLMONITOR 
25a6 cd 01 15			call break_point_state  
25a9				endm  
# End of macro CALLMONITOR
25a9				endif 
25a9 21 00 80				ld hl, baseram 
25ac					;ld hl, baseusermem 
25ac 01 00 00				ld bc, 0    ; start a counter 
25af			 
25af				; skip dict stub 
25af			 
25af cd dd 1d				call forth_tok_next 
25b2			 
25b2			 
25b2			; while we have words to look for 
25b2			 
25b2 7e			.douscan:	ld a, (hl)      
25b3				if DEBUG_FORTH_WORDS 
25b3					DMARK "UWs" 
25b3 f5				push af  
25b4 3a c8 25			ld a, (.dmark)  
25b7 32 77 fb			ld (debug_mark),a  
25ba 3a c9 25			ld a, (.dmark+1)  
25bd 32 78 fb			ld (debug_mark+1),a  
25c0 3a ca 25			ld a, (.dmark+2)  
25c3 32 79 fb			ld (debug_mark+2),a  
25c6 18 03			jr .pastdmark  
25c8 ..			.dmark: db "UWs"  
25cb f1			.pastdmark: pop af  
25cc			endm  
# End of macro DMARK
25cc					CALLMONITOR 
25cc cd 01 15			call break_point_state  
25cf				endm  
# End of macro CALLMONITOR
25cf				endif 
25cf fe 00				cp WORD_SYS_END 
25d1 28 4d				jr z, .udone 
25d3 fe 01				cp WORD_SYS_UWORD 
25d5 20 44				jr nz, .nuword 
25d7			 
25d7				if DEBUG_FORTH_WORDS 
25d7					DMARK "UWu" 
25d7 f5				push af  
25d8 3a ec 25			ld a, (.dmark)  
25db 32 77 fb			ld (debug_mark),a  
25de 3a ed 25			ld a, (.dmark+1)  
25e1 32 78 fb			ld (debug_mark+1),a  
25e4 3a ee 25			ld a, (.dmark+2)  
25e7 32 79 fb			ld (debug_mark+2),a  
25ea 18 03			jr .pastdmark  
25ec ..			.dmark: db "UWu"  
25ef f1			.pastdmark: pop af  
25f0			endm  
# End of macro DMARK
25f0					CALLMONITOR 
25f0 cd 01 15			call break_point_state  
25f3				endm  
# End of macro CALLMONITOR
25f3				endif 
25f3					; we have a uword so push its name to the stack 
25f3			 
25f3 e5				   	push hl  ; save so we can move to next dict block 
25f4			 
25f4					; skip opcode 
25f4 23					inc hl  
25f5					; skip next ptr 
25f5 23					inc hl  
25f6 23					inc hl 
25f7					; skip len 
25f7 23					inc hl 
25f8				if DEBUG_FORTH_WORDS 
25f8					DMARK "UWt" 
25f8 f5				push af  
25f9 3a 0d 26			ld a, (.dmark)  
25fc 32 77 fb			ld (debug_mark),a  
25ff 3a 0e 26			ld a, (.dmark+1)  
2602 32 78 fb			ld (debug_mark+1),a  
2605 3a 0f 26			ld a, (.dmark+2)  
2608 32 79 fb			ld (debug_mark+2),a  
260b 18 03			jr .pastdmark  
260d ..			.dmark: db "UWt"  
2610 f1			.pastdmark: pop af  
2611			endm  
# End of macro DMARK
2611					CALLMONITOR 
2611 cd 01 15			call break_point_state  
2614				endm  
# End of macro CALLMONITOR
2614				endif 
2614 03					inc bc 
2615			 
2615 c5					push bc 
2616 cd ad 1a				call forth_push_str 
2619 c1					pop bc 
261a			 
261a e1					pop hl 	 
261b			 
261b cd dd 1d		.nuword:	call forth_tok_next 
261e 18 92				jr .douscan  
2620			 
2620			.udone:		 ; push count of uwords found 
2620 c5					push bc 
2621 e1					pop hl 
2622			 
2622				if DEBUG_FORTH_WORDS 
2622					DMARK "UWc" 
2622 f5				push af  
2623 3a 37 26			ld a, (.dmark)  
2626 32 77 fb			ld (debug_mark),a  
2629 3a 38 26			ld a, (.dmark+1)  
262c 32 78 fb			ld (debug_mark+1),a  
262f 3a 39 26			ld a, (.dmark+2)  
2632 32 79 fb			ld (debug_mark+2),a  
2635 18 03			jr .pastdmark  
2637 ..			.dmark: db "UWc"  
263a f1			.pastdmark: pop af  
263b			endm  
# End of macro DMARK
263b					CALLMONITOR 
263b cd 01 15			call break_point_state  
263e				endm  
# End of macro CALLMONITOR
263e				endif 
263e cd 9b 1a				call forth_push_numhl 
2641			 
2641			 
2641				       NEXTW 
2641 c3 8c 1c			jp macro_next 
2644				endm 
# End of macro NEXTW
2644			 
2644			.BP: 
2644				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2644 54				db WORD_SYS_CORE+64             
2645 7a 26			dw .MONITOR            
2647 03				db 2 + 1 
2648 .. 00			db "BP",0              
264b				endm 
# End of macro CWHEAD
264b			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
264b			; | | $00 Will enable the break points within specific code paths 
264b			; | | $01 Will disable break points 
264b			; | |  
264b			; | | By default break points are off. Either the above can be used to enable them 
264b			; | | or if a key is held down during start up the spashscreen will appear to freeze 
264b			; | | and on release of the pressed key a message will be disaplayed to notify 
264b			; | | that break points are enabled. Pressing any key will then continue boot process. 
264b					; get byte count 
264b					if DEBUG_FORTH_WORDS_KEY 
264b						DMARK "BP." 
264b f5				push af  
264c 3a 60 26			ld a, (.dmark)  
264f 32 77 fb			ld (debug_mark),a  
2652 3a 61 26			ld a, (.dmark+1)  
2655 32 78 fb			ld (debug_mark+1),a  
2658 3a 62 26			ld a, (.dmark+2)  
265b 32 79 fb			ld (debug_mark+2),a  
265e 18 03			jr .pastdmark  
2660 ..			.dmark: db "BP."  
2663 f1			.pastdmark: pop af  
2664			endm  
# End of macro DMARK
2664						CALLMONITOR 
2664 cd 01 15			call break_point_state  
2667				endm  
# End of macro CALLMONITOR
2667					endif 
2667			 
2667					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2667 cd 36 1b			call macro_dsp_valuehl 
266a				endm 
# End of macro FORTH_DSP_VALUEHL
266a			 
266a			;		push hl 
266a			 
266a					; destroy value TOS 
266a			 
266a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
266a cd d2 1b			call macro_forth_dsp_pop 
266d				endm 
# End of macro FORTH_DSP_POP
266d			 
266d			;		pop hl 
266d			 
266d 3e 00				ld a,0 
266f bd					cp l 
2670 28 02				jr z, .bpset 
2672 3e 2a				ld a, '*' 
2674			 
2674 32 31 ee		.bpset:		ld (os_view_disable), a 
2677			 
2677			 
2677					NEXTW 
2677 c3 8c 1c			jp macro_next 
267a				endm 
# End of macro NEXTW
267a			 
267a			 
267a			.MONITOR: 
267a				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
267a 55				db WORD_SYS_CORE+65             
267b ad 26			dw .MALLOC            
267d 08				db 7 + 1 
267e .. 00			db "MONITOR",0              
2686				endm 
# End of macro CWHEAD
2686			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2686			; | | At start the current various registers will be displayed with contents. 
2686			; | | Top right corner will show the most recent debug marker seen. 
2686			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2686			; | | and the return stack pointer (RSP). 
2686			; | | Pressing: 
2686			; | |    1 - Initial screen 
2686			; | |    2 - Display a data dump of HL 
2686			; | |    3 - Display a data dump of DE 
2686			; | |    4 - Display a data dump of BC 
2686			; | |    5 - Display a data dump of HL 
2686			; | |    6 - Display a data dump of DSP 
2686			; | |    7 - Display a data dump of RSP 
2686			; | |    8 - Display a data dump of what is at DSP 
2686			; | |    9 - Display a data dump of what is at RSP 
2686			; | |    0 - Exit monitor and continue running. This will also enable break points 
2686			; | |    * - Disable break points 
2686			; | |    # - Enter traditional monitor mode 
2686			; | | 
2686			; | | Monitor Mode 
2686			; | | ------------ 
2686			; | | A prompt of '>' will be shown for various commands: 
2686			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2686			; | |    C - Continue display a data dump from the last set address 
2686			; | |    M xxxx - Set start of memory edit at address xx 
2686			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2686			; | |    Q - Return to previous 
2686					if DEBUG_FORTH_WORDS_KEY 
2686						DMARK "MON" 
2686 f5				push af  
2687 3a 9b 26			ld a, (.dmark)  
268a 32 77 fb			ld (debug_mark),a  
268d 3a 9c 26			ld a, (.dmark+1)  
2690 32 78 fb			ld (debug_mark+1),a  
2693 3a 9d 26			ld a, (.dmark+2)  
2696 32 79 fb			ld (debug_mark+2),a  
2699 18 03			jr .pastdmark  
269b ..			.dmark: db "MON"  
269e f1			.pastdmark: pop af  
269f			endm  
# End of macro DMARK
269f						CALLMONITOR 
269f cd 01 15			call break_point_state  
26a2				endm  
# End of macro CALLMONITOR
26a2					endif 
26a2 3e 00				ld a, 0 
26a4 32 31 ee				ld (os_view_disable), a 
26a7			 
26a7					CALLMONITOR 
26a7 cd 01 15			call break_point_state  
26aa				endm  
# End of macro CALLMONITOR
26aa			 
26aa			;	call monitor 
26aa			 
26aa					NEXTW 
26aa c3 8c 1c			jp macro_next 
26ad				endm 
# End of macro NEXTW
26ad			 
26ad			 
26ad			.MALLOC: 
26ad				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
26ad 56				db WORD_SYS_CORE+66             
26ae d6 26			dw .MALLOC2            
26b0 06				db 5 + 1 
26b1 .. 00			db "ALLOT",0              
26b7				endm 
# End of macro CWHEAD
26b7			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
26b7					if DEBUG_FORTH_WORDS_KEY 
26b7						DMARK "ALL" 
26b7 f5				push af  
26b8 3a cc 26			ld a, (.dmark)  
26bb 32 77 fb			ld (debug_mark),a  
26be 3a cd 26			ld a, (.dmark+1)  
26c1 32 78 fb			ld (debug_mark+1),a  
26c4 3a ce 26			ld a, (.dmark+2)  
26c7 32 79 fb			ld (debug_mark+2),a  
26ca 18 03			jr .pastdmark  
26cc ..			.dmark: db "ALL"  
26cf f1			.pastdmark: pop af  
26d0			endm  
# End of macro DMARK
26d0						CALLMONITOR 
26d0 cd 01 15			call break_point_state  
26d3				endm  
# End of macro CALLMONITOR
26d3					endif 
26d3 c3 fd 26				jp .mallocc 
26d6			.MALLOC2: 
26d6				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
26d6 56				db WORD_SYS_CORE+66             
26d7 14 27			dw .FREE            
26d9 07				db 6 + 1 
26da .. 00			db "MALLOC",0              
26e1				endm 
# End of macro CWHEAD
26e1			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
26e1					; get byte count 
26e1					if DEBUG_FORTH_WORDS_KEY 
26e1						DMARK "MAL" 
26e1 f5				push af  
26e2 3a f6 26			ld a, (.dmark)  
26e5 32 77 fb			ld (debug_mark),a  
26e8 3a f7 26			ld a, (.dmark+1)  
26eb 32 78 fb			ld (debug_mark+1),a  
26ee 3a f8 26			ld a, (.dmark+2)  
26f1 32 79 fb			ld (debug_mark+2),a  
26f4 18 03			jr .pastdmark  
26f6 ..			.dmark: db "MAL"  
26f9 f1			.pastdmark: pop af  
26fa			endm  
# End of macro DMARK
26fa						CALLMONITOR 
26fa cd 01 15			call break_point_state  
26fd				endm  
# End of macro CALLMONITOR
26fd					endif 
26fd			.mallocc: 
26fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26fd cd 36 1b			call macro_dsp_valuehl 
2700				endm 
# End of macro FORTH_DSP_VALUEHL
2700			 
2700			;		push hl 
2700			 
2700					; destroy value TOS 
2700			 
2700					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2700 cd d2 1b			call macro_forth_dsp_pop 
2703				endm 
# End of macro FORTH_DSP_POP
2703			 
2703			;		pop hl 
2703 cd 86 11				call malloc 
2706				if DEBUG_FORTH_MALLOC_GUARD 
2706 f5					push af 
2707 cd e8 0c				call ishlzero 
270a			;		ld a, l 
270a			;		add h 
270a			;		cp 0 
270a f1					pop af 
270b					 
270b cc 37 4f				call z,malloc_error 
270e				endif 
270e			 
270e cd 9b 1a				call forth_push_numhl 
2711					NEXTW 
2711 c3 8c 1c			jp macro_next 
2714				endm 
# End of macro NEXTW
2714			 
2714			.FREE: 
2714				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2714 57				db WORD_SYS_CORE+67             
2715 45 27			dw .LIST            
2717 05				db 4 + 1 
2718 .. 00			db "FREE",0              
271d				endm 
# End of macro CWHEAD
271d			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
271d					if DEBUG_FORTH_WORDS_KEY 
271d						DMARK "FRE" 
271d f5				push af  
271e 3a 32 27			ld a, (.dmark)  
2721 32 77 fb			ld (debug_mark),a  
2724 3a 33 27			ld a, (.dmark+1)  
2727 32 78 fb			ld (debug_mark+1),a  
272a 3a 34 27			ld a, (.dmark+2)  
272d 32 79 fb			ld (debug_mark+2),a  
2730 18 03			jr .pastdmark  
2732 ..			.dmark: db "FRE"  
2735 f1			.pastdmark: pop af  
2736			endm  
# End of macro DMARK
2736						CALLMONITOR 
2736 cd 01 15			call break_point_state  
2739				endm  
# End of macro CALLMONITOR
2739					endif 
2739					; get address 
2739			 
2739					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2739 cd 36 1b			call macro_dsp_valuehl 
273c				endm 
# End of macro FORTH_DSP_VALUEHL
273c			 
273c			;		push hl 
273c			 
273c					; destroy value TOS 
273c			 
273c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
273c cd d2 1b			call macro_forth_dsp_pop 
273f				endm 
# End of macro FORTH_DSP_POP
273f			 
273f			;		pop hl 
273f			if FORTH_ENABLE_MALLOCFREE 
273f cd 50 12				call free 
2742			endif 
2742					NEXTW 
2742 c3 8c 1c			jp macro_next 
2745				endm 
# End of macro NEXTW
2745			.LIST: 
2745				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2745 5c				db WORD_SYS_CORE+72             
2746 08 29			dw .FORGET            
2748 05				db 4 + 1 
2749 .. 00			db "LIST",0              
274e				endm 
# End of macro CWHEAD
274e			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
274e			; | | The quoted word must be in upper case. 
274e				if DEBUG_FORTH_WORDS_KEY 
274e					DMARK "LST" 
274e f5				push af  
274f 3a 63 27			ld a, (.dmark)  
2752 32 77 fb			ld (debug_mark),a  
2755 3a 64 27			ld a, (.dmark+1)  
2758 32 78 fb			ld (debug_mark+1),a  
275b 3a 65 27			ld a, (.dmark+2)  
275e 32 79 fb			ld (debug_mark+2),a  
2761 18 03			jr .pastdmark  
2763 ..			.dmark: db "LST"  
2766 f1			.pastdmark: pop af  
2767			endm  
# End of macro DMARK
2767					CALLMONITOR 
2767 cd 01 15			call break_point_state  
276a				endm  
# End of macro CALLMONITOR
276a				endif 
276a			 
276a					FORTH_DSP_VALUEHL 
276a cd 36 1b			call macro_dsp_valuehl 
276d				endm 
# End of macro FORTH_DSP_VALUEHL
276d			 
276d e5					push hl 
276e c1					pop bc 
276f			 
276f			; Start format of scratch string 
276f			 
276f 21 32 ee				ld hl, scratch 
2772			 
2772 3e 3a				ld a, ':' 
2774 77					ld (hl),a 
2775 23					inc hl 
2776 3e 20				ld a, ' ' 
2778 77					ld (hl), a 
2779			 
2779					; Get ptr to the word we need to look up 
2779			 
2779			;		FORTH_DSP_VALUEHL 
2779					;v5 FORTH_DSP_VALUE 
2779				; TODO type check 
2779			;		inc hl    ; Skip type check  
2779			;		push hl 
2779			;		ex de, hl    ; put into DE 
2779			 
2779			 
2779 21 00 80				ld hl, baseram 
277c					;ld hl, baseusermem 
277c			 
277c e5			push hl   ; sacreifical push 
277d			 
277d			.ldouscanm: 
277d e1				pop hl 
277e			.ldouscan: 
277e				if DEBUG_FORTH_WORDS 
277e					DMARK "LSs" 
277e f5				push af  
277f 3a 93 27			ld a, (.dmark)  
2782 32 77 fb			ld (debug_mark),a  
2785 3a 94 27			ld a, (.dmark+1)  
2788 32 78 fb			ld (debug_mark+1),a  
278b 3a 95 27			ld a, (.dmark+2)  
278e 32 79 fb			ld (debug_mark+2),a  
2791 18 03			jr .pastdmark  
2793 ..			.dmark: db "LSs"  
2796 f1			.pastdmark: pop af  
2797			endm  
# End of macro DMARK
2797					CALLMONITOR 
2797 cd 01 15			call break_point_state  
279a				endm  
# End of macro CALLMONITOR
279a				endif 
279a				; skip dict stub 
279a cd dd 1d				call forth_tok_next 
279d			 
279d			 
279d			; while we have words to look for 
279d			 
279d 7e				ld a, (hl)      
279e				if DEBUG_FORTH_WORDS 
279e					DMARK "LSk" 
279e f5				push af  
279f 3a b3 27			ld a, (.dmark)  
27a2 32 77 fb			ld (debug_mark),a  
27a5 3a b4 27			ld a, (.dmark+1)  
27a8 32 78 fb			ld (debug_mark+1),a  
27ab 3a b5 27			ld a, (.dmark+2)  
27ae 32 79 fb			ld (debug_mark+2),a  
27b1 18 03			jr .pastdmark  
27b3 ..			.dmark: db "LSk"  
27b6 f1			.pastdmark: pop af  
27b7			endm  
# End of macro DMARK
27b7					CALLMONITOR 
27b7 cd 01 15			call break_point_state  
27ba				endm  
# End of macro CALLMONITOR
27ba				endif 
27ba fe 00				cp WORD_SYS_END 
27bc ca ef 28				jp z, .lunotfound 
27bf fe 01				cp WORD_SYS_UWORD 
27c1 c2 7e 27				jp nz, .ldouscan 
27c4			 
27c4				if DEBUG_FORTH_WORDS 
27c4					DMARK "LSu" 
27c4 f5				push af  
27c5 3a d9 27			ld a, (.dmark)  
27c8 32 77 fb			ld (debug_mark),a  
27cb 3a da 27			ld a, (.dmark+1)  
27ce 32 78 fb			ld (debug_mark+1),a  
27d1 3a db 27			ld a, (.dmark+2)  
27d4 32 79 fb			ld (debug_mark+2),a  
27d7 18 03			jr .pastdmark  
27d9 ..			.dmark: db "LSu"  
27dc f1			.pastdmark: pop af  
27dd			endm  
# End of macro DMARK
27dd					CALLMONITOR 
27dd cd 01 15			call break_point_state  
27e0				endm  
# End of macro CALLMONITOR
27e0				endif 
27e0			 
27e0					; found a uword but is it the one we want... 
27e0			 
27e0 c5					push bc     ; uword to find is on bc 
27e1 d1					pop de 
27e2			 
27e2 e5					push hl  ; to save the ptr 
27e3			 
27e3					; skip opcode 
27e3 23					inc hl  
27e4					; skip next ptr 
27e4 23					inc hl  
27e5 23					inc hl 
27e6					; skip len 
27e6 23					inc hl 
27e7			 
27e7				if DEBUG_FORTH_WORDS 
27e7					DMARK "LSc" 
27e7 f5				push af  
27e8 3a fc 27			ld a, (.dmark)  
27eb 32 77 fb			ld (debug_mark),a  
27ee 3a fd 27			ld a, (.dmark+1)  
27f1 32 78 fb			ld (debug_mark+1),a  
27f4 3a fe 27			ld a, (.dmark+2)  
27f7 32 79 fb			ld (debug_mark+2),a  
27fa 18 03			jr .pastdmark  
27fc ..			.dmark: db "LSc"  
27ff f1			.pastdmark: pop af  
2800			endm  
# End of macro DMARK
2800					CALLMONITOR 
2800 cd 01 15			call break_point_state  
2803				endm  
# End of macro CALLMONITOR
2803				endif 
2803 cd 55 11				call strcmp 
2806 c2 7d 27				jp nz, .ldouscanm 
2809				 
2809			 
2809			 
2809					; we have a uword so push its name to the stack 
2809			 
2809			;	   	push hl  ; save so we can move to next dict block 
2809 e1			pop hl 
280a			 
280a				if DEBUG_FORTH_WORDS 
280a					DMARK "LSm" 
280a f5				push af  
280b 3a 1f 28			ld a, (.dmark)  
280e 32 77 fb			ld (debug_mark),a  
2811 3a 20 28			ld a, (.dmark+1)  
2814 32 78 fb			ld (debug_mark+1),a  
2817 3a 21 28			ld a, (.dmark+2)  
281a 32 79 fb			ld (debug_mark+2),a  
281d 18 03			jr .pastdmark  
281f ..			.dmark: db "LSm"  
2822 f1			.pastdmark: pop af  
2823			endm  
# End of macro DMARK
2823					CALLMONITOR 
2823 cd 01 15			call break_point_state  
2826				endm  
# End of macro CALLMONITOR
2826				endif 
2826			 
2826					; skip opcode 
2826 23					inc hl  
2827					; skip next ptr 
2827 23					inc hl  
2828 23					inc hl 
2829					; skip len 
2829 7e					ld a, (hl)   ; save length to add 
282a				if DEBUG_FORTH_WORDS 
282a					DMARK "LS2" 
282a f5				push af  
282b 3a 3f 28			ld a, (.dmark)  
282e 32 77 fb			ld (debug_mark),a  
2831 3a 40 28			ld a, (.dmark+1)  
2834 32 78 fb			ld (debug_mark+1),a  
2837 3a 41 28			ld a, (.dmark+2)  
283a 32 79 fb			ld (debug_mark+2),a  
283d 18 03			jr .pastdmark  
283f ..			.dmark: db "LS2"  
2842 f1			.pastdmark: pop af  
2843			endm  
# End of macro DMARK
2843					CALLMONITOR 
2843 cd 01 15			call break_point_state  
2846				endm  
# End of macro CALLMONITOR
2846				endif 
2846			 
2846					; save this location 
2846				 
2846 e5					push hl 
2847			 
2847 23					inc hl 
2848 11 34 ee				ld de, scratch+2 
284b 4f					ld c, a 
284c 06 00				ld b, 0 
284e			 
284e				if DEBUG_FORTH_WORDS 
284e					DMARK "LSn" 
284e f5				push af  
284f 3a 63 28			ld a, (.dmark)  
2852 32 77 fb			ld (debug_mark),a  
2855 3a 64 28			ld a, (.dmark+1)  
2858 32 78 fb			ld (debug_mark+1),a  
285b 3a 65 28			ld a, (.dmark+2)  
285e 32 79 fb			ld (debug_mark+2),a  
2861 18 03			jr .pastdmark  
2863 ..			.dmark: db "LSn"  
2866 f1			.pastdmark: pop af  
2867			endm  
# End of macro DMARK
2867					CALLMONITOR 
2867 cd 01 15			call break_point_state  
286a				endm  
# End of macro CALLMONITOR
286a				endif 
286a			 
286a					; copy uword name to scratch 
286a			 
286a ed b0				ldir 
286c			 
286c 1b					dec de 
286d 3e 20				ld a, ' '    ; change null to space 
286f 12					ld (de), a 
2870			 
2870 13					inc de 
2871			 
2871 d5					push de 
2872 c1					pop bc     ; move scratch pointer to end of word name and save it 
2873			 
2873 e1					pop hl 
2874 7e					ld a, (hl) 
2875					;inc hl 
2875					; skip word string 
2875 cd bf 0c				call addatohl 
2878			 
2878 23					inc hl 
2879			 
2879				if DEBUG_FORTH_WORDS 
2879					DMARK "LS3" 
2879 f5				push af  
287a 3a 8e 28			ld a, (.dmark)  
287d 32 77 fb			ld (debug_mark),a  
2880 3a 8f 28			ld a, (.dmark+1)  
2883 32 78 fb			ld (debug_mark+1),a  
2886 3a 90 28			ld a, (.dmark+2)  
2889 32 79 fb			ld (debug_mark+2),a  
288c 18 03			jr .pastdmark  
288e ..			.dmark: db "LS3"  
2891 f1			.pastdmark: pop af  
2892			endm  
# End of macro DMARK
2892					CALLMONITOR 
2892 cd 01 15			call break_point_state  
2895				endm  
# End of macro CALLMONITOR
2895				endif 
2895					; should now be at the start of the machine code to setup the eval of the uword 
2895					; now locate the ptr to the string defintion 
2895			 
2895					; skip ld hl, 
2895					; then load the ptr 
2895			 
2895 23					inc hl 
2896 5e					ld e, (hl) 
2897 23					inc hl 
2898 56					ld d, (hl) 
2899 eb					ex de, hl 
289a			 
289a			 
289a				if DEBUG_FORTH_WORDS 
289a					DMARK "LSt" 
289a f5				push af  
289b 3a af 28			ld a, (.dmark)  
289e 32 77 fb			ld (debug_mark),a  
28a1 3a b0 28			ld a, (.dmark+1)  
28a4 32 78 fb			ld (debug_mark+1),a  
28a7 3a b1 28			ld a, (.dmark+2)  
28aa 32 79 fb			ld (debug_mark+2),a  
28ad 18 03			jr .pastdmark  
28af ..			.dmark: db "LSt"  
28b2 f1			.pastdmark: pop af  
28b3			endm  
# End of macro DMARK
28b3					CALLMONITOR 
28b3 cd 01 15			call break_point_state  
28b6				endm  
# End of macro CALLMONITOR
28b6				endif 
28b6			 
28b6			; cant push right now due to tokenised strings  
28b6			 
28b6			; get the destination of where to copy this definition to. 
28b6			 
28b6 c5					push bc 
28b7 d1					pop de 
28b8			 
28b8 7e			.listl:         ld a,(hl) 
28b9 fe 00				cp 0 
28bb 28 09				jr z, .lreplsp     ; replace zero with space 
28bd fe 7f				cp FORTH_END_BUFFER 
28bf 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
28c1				 
28c1					; just copy this char as is then 
28c1			 
28c1 12					ld (de), a 
28c2			 
28c2 23			.listnxt:	inc hl 
28c3 13					inc de 
28c4 18 f2				jr .listl 
28c6			 
28c6 3e 20		.lreplsp:	ld a,' ' 
28c8 12					ld (de), a 
28c9 18 f7				jr .listnxt 
28cb			 
28cb			; close up uword def 
28cb			 
28cb			.listdone: 
28cb 3e 00				ld a, 0 
28cd 12					ld (de), a 
28ce			 
28ce			; now have def so clean up and push to stack 
28ce			 
28ce 21 32 ee				ld hl, scratch 
28d1				if DEBUG_FORTH_WORDS 
28d1					DMARK "Ltp" 
28d1 f5				push af  
28d2 3a e6 28			ld a, (.dmark)  
28d5 32 77 fb			ld (debug_mark),a  
28d8 3a e7 28			ld a, (.dmark+1)  
28db 32 78 fb			ld (debug_mark+1),a  
28de 3a e8 28			ld a, (.dmark+2)  
28e1 32 79 fb			ld (debug_mark+2),a  
28e4 18 03			jr .pastdmark  
28e6 ..			.dmark: db "Ltp"  
28e9 f1			.pastdmark: pop af  
28ea			endm  
# End of macro DMARK
28ea					CALLMONITOR 
28ea cd 01 15			call break_point_state  
28ed				endm  
# End of macro CALLMONITOR
28ed				endif 
28ed			 
28ed 18 06			jr .listpush 
28ef			 
28ef			;.lnuword:	pop hl 
28ef			;		call forth_tok_next 
28ef			;		jp .ldouscan  
28ef			 
28ef			.lunotfound:		  
28ef			 
28ef			 
28ef					 
28ef					FORTH_DSP_POP 
28ef cd d2 1b			call macro_forth_dsp_pop 
28f2				endm 
# End of macro FORTH_DSP_POP
28f2 21 fb 28				ld hl, .luno 
28f5						 
28f5			 
28f5			.listpush: 
28f5 cd ad 1a				call forth_push_str 
28f8			 
28f8			 
28f8			 
28f8					NEXTW 
28f8 c3 8c 1c			jp macro_next 
28fb				endm 
# End of macro NEXTW
28fb			 
28fb .. 00		.luno:    db "Not found",0 
2905			 
2905			 
2905			 
2905			 
2905			 
2905			;		push hl   ; save pointer to start of uword def string 
2905			; 
2905			;; look for FORTH_EOL_LINE 
2905			;		ld a, FORTH_END_BUFFER 
2905			;		call strlent 
2905			; 
2905			;		inc hl		 ; space for coln def 
2905			;		inc hl 
2905			;		inc hl          ; space for terms 
2905			;		inc hl 
2905			; 
2905			;		ld a, 20   ; TODO get actual length 
2905			;		call addatohl    ; include a random amount of room for the uword name 
2905			; 
2905			;		 
2905			;	if DEBUG_FORTH_WORDS 
2905			;		DMARK "Lt1" 
2905			;		CALLMONITOR 
2905			;	endif 
2905			;		 
2905			; 
2905			;; malloc space for the string because we cant change it 
2905			; 
2905			;		call malloc 
2905			;	if DEBUG_FORTH_MALLOC_GUARD 
2905			;		push af 
2905			;		call ishlzero 
2905			;		pop af 
2905			;		 
2905			;		call z,malloc_error 
2905			;	endif 
2905			; 
2905			;	if DEBUG_FORTH_WORDS 
2905			;		DMARK "Lt2" 
2905			;		CALLMONITOR 
2905			;	endif 
2905			;		pop de 
2905			;		push hl    ; push the malloc to release later 
2905			;		push hl   ;  push back a copy for the later stack push 
2905			;		 
2905			;; copy the string swapping out the zero terms for spaces 
2905			; 
2905			;		; de has our source 
2905			;		; hl has our dest 
2905			; 
2905			;; add the coln def 
2905			; 
2905			;		ld a, ':' 
2905			;		ld (hl), a 
2905			;		inc hl 
2905			;		ld a, ' ' 
2905			;		ld (hl), a 
2905			;		inc hl 
2905			; 
2905			;; add the uname word 
2905			;		push de   ; save our string for now 
2905			;		ex de, hl 
2905			; 
2905			;		FORTH_DSP_VALUE 
2905			;		;v5 FORTH_DSP_VALUE 
2905			; 
2905			;		inc hl   ; skip type but we know by now this is OK 
2905			; 
2905			;.luword:	ld a,(hl) 
2905			;		cp 0 
2905			;		jr z, .luword2 
2905			;		ld (de), a 
2905			;		inc de 
2905			;		inc hl 
2905			;		jr .luword 
2905			; 
2905			;.luword2:	ld a, ' ' 
2905			;		ld (de), a 
2905			;;		inc hl 
2905			;;		inc de 
2905			;;		ld (de), a 
2905			;;		inc hl 
2905			;		inc de 
2905			; 
2905			;		ex de, hl 
2905			;		pop de 
2905			;		 
2905			;		 
2905			; 
2905			;; detoken that string and copy it 
2905			; 
2905			;	if DEBUG_FORTH_WORDS 
2905			;		DMARK "Lt2" 
2905			;		CALLMONITOR 
2905			;	endif 
2905			;.ldetok:	ld a, (de) 
2905			;		cp FORTH_END_BUFFER 
2905			;		jr z, .ldetokend 
2905			;		; swap out any zero term for space 
2905			;		cp 0 
2905			;		jr nz, .ldetoknext 
2905			;		ld a, ' ' 
2905			; 
2905			;	if DEBUG_FORTH_WORDS 
2905			;		DMARK "LtS" 
2905			;		CALLMONITOR 
2905			;	endif 
2905			;.ldetoknext:	ld (hl), a 
2905			;		inc de 
2905			;		inc hl 
2905			;		jr .ldetok 
2905			; 
2905			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2905			;		ld (hl), a  
2905			; 
2905			;; free that temp malloc 
2905			; 
2905			;		pop hl    
2905			; 
2905			;	if DEBUG_FORTH_WORDS 
2905			;		DMARK "Lt4" 
2905			;		CALLMONITOR 
2905			;	endif 
2905			;		call forth_apushstrhl 
2905			; 
2905			;		; get rid of temp malloc area 
2905			; 
2905			;		pop hl 
2905			;		call free 
2905			; 
2905			;		jr .ludone 
2905			; 
2905			;.lnuword:	pop hl 
2905			;		call forth_tok_next 
2905			;		jp .ldouscan  
2905			; 
2905			;.ludone:		 pop hl 
2905			; 
2905					NEXTW 
2905 c3 8c 1c			jp macro_next 
2908				endm 
# End of macro NEXTW
2908			 
2908			.FORGET: 
2908				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2908 5d				db WORD_SYS_CORE+73             
2909 81 29			dw .NOP            
290b 07				db 6 + 1 
290c .. 00			db "FORGET",0              
2913				endm 
# End of macro CWHEAD
2913			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2913			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2913			; | |  
2913			; | | e.g. "MORE" forget 
2913					if DEBUG_FORTH_WORDS_KEY 
2913						DMARK "FRG" 
2913 f5				push af  
2914 3a 28 29			ld a, (.dmark)  
2917 32 77 fb			ld (debug_mark),a  
291a 3a 29 29			ld a, (.dmark+1)  
291d 32 78 fb			ld (debug_mark+1),a  
2920 3a 2a 29			ld a, (.dmark+2)  
2923 32 79 fb			ld (debug_mark+2),a  
2926 18 03			jr .pastdmark  
2928 ..			.dmark: db "FRG"  
292b f1			.pastdmark: pop af  
292c			endm  
# End of macro DMARK
292c						CALLMONITOR 
292c cd 01 15			call break_point_state  
292f				endm  
# End of macro CALLMONITOR
292f					endif 
292f			 
292f				; find uword 
292f			        ; update start of word with "_" 
292f				; replace uword with deleted flag 
292f			 
292f			 
292f			;	if DEBUG_FORTH_WORDS 
292f			;		DMARK "FOG" 
292f			;		CALLMONITOR 
292f			;	endif 
292f			 
292f			 
292f					; Get ptr to the word we need to look up 
292f			 
292f					FORTH_DSP_VALUEHL 
292f cd 36 1b			call macro_dsp_valuehl 
2932				endm 
# End of macro FORTH_DSP_VALUEHL
2932					;v5 FORTH_DSP_VALUE 
2932				; TODO type check 
2932			;		inc hl    ; Skip type check  
2932 e5					push hl 
2933 c1					pop bc 
2934			;		ex de, hl    ; put into DE 
2934			 
2934			 
2934 21 00 80				ld hl, baseram 
2937					;ld hl, baseusermem 
2937			 
2937				; skip dict stub 
2937			;	call forth_tok_next 
2937 e5			push hl   ; sacreifical push 
2938			 
2938			.fldouscanm: 
2938 e1				pop hl 
2939			.fldouscan: 
2939			;	if DEBUG_FORTH_WORDS 
2939			;		DMARK "LSs" 
2939			;		CALLMONITOR 
2939			;	endif 
2939				; skip dict stub 
2939 cd dd 1d				call forth_tok_next 
293c			 
293c			 
293c			; while we have words to look for 
293c			 
293c 7e				ld a, (hl)      
293d			;	if DEBUG_FORTH_WORDS 
293d			;		DMARK "LSk" 
293d			;		CALLMONITOR 
293d			;	endif 
293d fe 00				cp WORD_SYS_END 
293f ca 7b 29				jp z, .flunotfound 
2942 fe 01				cp WORD_SYS_UWORD 
2944 c2 39 29				jp nz, .fldouscan 
2947			 
2947			;	if DEBUG_FORTH_WORDS 
2947			;		DMARK "LSu" 
2947			;		CALLMONITOR 
2947			;	endif 
2947			 
2947					; found a uword but is it the one we want... 
2947			 
2947 c5					push bc     ; uword to find is on bc 
2948 d1					pop de 
2949			 
2949 e5					push hl  ; to save the ptr 
294a			 
294a					; skip opcode 
294a 23					inc hl  
294b					; skip next ptr 
294b 23					inc hl  
294c 23					inc hl 
294d					; skip len 
294d 23					inc hl 
294e			 
294e			;	if DEBUG_FORTH_WORDS 
294e			;		DMARK "LSc" 
294e			;		CALLMONITOR 
294e			;	endif 
294e cd 55 11				call strcmp 
2951 c2 38 29				jp nz, .fldouscanm 
2954			; 
2954			; 
2954			;; while we have words to look for 
2954			; 
2954			;.fdouscan:	ld a, (hl)      
2954			;	if DEBUG_FORTH_WORDS 
2954			;		DMARK "LSs" 
2954			;		CALLMONITOR 
2954			;	endif 
2954			;		cp WORD_SYS_END 
2954			;		jp z, .fudone 
2954			;		cp WORD_SYS_UWORD 
2954			;		jp nz, .fnuword 
2954			; 
2954			;	if DEBUG_FORTH_WORDS 
2954			;		DMARK "FGu" 
2954			;		CALLMONITOR 
2954			;	endif 
2954			; 
2954			;		; found a uword but is it the one we want... 
2954			; 
2954			; 
2954			;	        pop de   ; get back the dsp name 
2954			;		push de 
2954			; 
2954			;		push hl  ; to save the ptr 
2954			; 
2954			;		; skip opcode 
2954			;		inc hl  
2954			;		; skip next ptr 
2954			;		inc hl  
2954			;		inc hl 
2954			;		; skip len 
2954			;		inc hl 
2954			; 
2954			;	if DEBUG_FORTH_WORDS 
2954			;		DMARK "FGc" 
2954			;		CALLMONITOR 
2954			;	endif 
2954			;		call strcmp 
2954			;		jp nz, .fnuword 
2954			 
2954			 
2954 e1			pop hl 
2955			 
2955				 
2955				if DEBUG_FORTH_WORDS 
2955					DMARK "FGm" 
2955 f5				push af  
2956 3a 6a 29			ld a, (.dmark)  
2959 32 77 fb			ld (debug_mark),a  
295c 3a 6b 29			ld a, (.dmark+1)  
295f 32 78 fb			ld (debug_mark+1),a  
2962 3a 6c 29			ld a, (.dmark+2)  
2965 32 79 fb			ld (debug_mark+2),a  
2968 18 03			jr .pastdmark  
296a ..			.dmark: db "FGm"  
296d f1			.pastdmark: pop af  
296e			endm  
# End of macro DMARK
296e					CALLMONITOR 
296e cd 01 15			call break_point_state  
2971				endm  
# End of macro CALLMONITOR
2971				endif 
2971			 
2971			 
2971			 
2971					; we have a uword so push its name to the stack 
2971			 
2971			;	   	push hl  ; save so we can move to next dict block 
2971			;pop hl 
2971			 
2971					; update opcode to deleted 
2971 3e 03				ld a, WORD_SYS_DELETED 
2973 77					ld (hl), a 
2974			 
2974 23					inc hl  
2975					; skip next ptr 
2975 23					inc hl  
2976 23					inc hl 
2977					; skip len 
2977 23					inc hl 
2978			 
2978					; TODO change parser to skip deleted words but for now mark it out 
2978 3e 5f				ld a, "_" 
297a 77					ld  (hl),a 
297b			 
297b			;		jr .fudone 
297b			; 
297b			;.fnuword:	pop hl 
297b			;		call forth_tok_next 
297b			;		jp .fdouscan  
297b			 
297b			.flunotfound:		  
297b			 
297b			 
297b					 
297b					FORTH_DSP_POP 
297b cd d2 1b			call macro_forth_dsp_pop 
297e				endm 
# End of macro FORTH_DSP_POP
297e			;		ld hl, .luno 
297e			;.fudone:		 pop hl 
297e					NEXTW 
297e c3 8c 1c			jp macro_next 
2981				endm 
# End of macro NEXTW
2981			.NOP: 
2981				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2981 61				db WORD_SYS_CORE+77             
2982 a8 29			dw .COMO            
2984 04				db 3 + 1 
2985 .. 00			db "NOP",0              
2989				endm 
# End of macro CWHEAD
2989			; | NOP (  --  ) Do nothing | DONE 
2989					if DEBUG_FORTH_WORDS_KEY 
2989						DMARK "NOP" 
2989 f5				push af  
298a 3a 9e 29			ld a, (.dmark)  
298d 32 77 fb			ld (debug_mark),a  
2990 3a 9f 29			ld a, (.dmark+1)  
2993 32 78 fb			ld (debug_mark+1),a  
2996 3a a0 29			ld a, (.dmark+2)  
2999 32 79 fb			ld (debug_mark+2),a  
299c 18 03			jr .pastdmark  
299e ..			.dmark: db "NOP"  
29a1 f1			.pastdmark: pop af  
29a2			endm  
# End of macro DMARK
29a2						CALLMONITOR 
29a2 cd 01 15			call break_point_state  
29a5				endm  
# End of macro CALLMONITOR
29a5					endif 
29a5				       NEXTW 
29a5 c3 8c 1c			jp macro_next 
29a8				endm 
# End of macro NEXTW
29a8			.COMO: 
29a8				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
29a8 6e				db WORD_SYS_CORE+90             
29a9 fa 29			dw .COMC            
29ab 02				db 1 + 1 
29ac .. 00			db "(",0              
29ae				endm 
# End of macro CWHEAD
29ae			; | ( ( -- )  Start of comment | DONE 
29ae			 
29ae			 
29ae 2a 33 f1				ld hl, ( os_tok_ptr) 
29b1 11 f5 29			ld de, .closepar 
29b4					 
29b4					if DEBUG_FORTH_WORDS 
29b4						DMARK ").." 
29b4 f5				push af  
29b5 3a c9 29			ld a, (.dmark)  
29b8 32 77 fb			ld (debug_mark),a  
29bb 3a ca 29			ld a, (.dmark+1)  
29be 32 78 fb			ld (debug_mark+1),a  
29c1 3a cb 29			ld a, (.dmark+2)  
29c4 32 79 fb			ld (debug_mark+2),a  
29c7 18 03			jr .pastdmark  
29c9 ..			.dmark: db ").."  
29cc f1			.pastdmark: pop af  
29cd			endm  
# End of macro DMARK
29cd						CALLMONITOR 
29cd cd 01 15			call break_point_state  
29d0				endm  
# End of macro CALLMONITOR
29d0					endif 
29d0 cd a7 1d			call findnexttok  
29d3			 
29d3					if DEBUG_FORTH_WORDS 
29d3						DMARK "IF5" 
29d3 f5				push af  
29d4 3a e8 29			ld a, (.dmark)  
29d7 32 77 fb			ld (debug_mark),a  
29da 3a e9 29			ld a, (.dmark+1)  
29dd 32 78 fb			ld (debug_mark+1),a  
29e0 3a ea 29			ld a, (.dmark+2)  
29e3 32 79 fb			ld (debug_mark+2),a  
29e6 18 03			jr .pastdmark  
29e8 ..			.dmark: db "IF5"  
29eb f1			.pastdmark: pop af  
29ec			endm  
# End of macro DMARK
29ec						CALLMONITOR 
29ec cd 01 15			call break_point_state  
29ef				endm  
# End of macro CALLMONITOR
29ef					endif 
29ef				; replace below with ) exec using tok_ptr 
29ef 22 33 f1			ld (os_tok_ptr), hl 
29f2 c3 1d 1d			jp exec1 
29f5			 
29f5 .. 00			.closepar:   db ")",0 
29f7			 
29f7				       NEXTW 
29f7 c3 8c 1c			jp macro_next 
29fa				endm 
# End of macro NEXTW
29fa			.COMC: 
29fa				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
29fa 6f				db WORD_SYS_CORE+91             
29fb 03 2a			dw .SCRATCH            
29fd 02				db 1 + 1 
29fe .. 00			db ")",0              
2a00				endm 
# End of macro CWHEAD
2a00			; | ) ( -- )  End of comment |  DONE  
2a00				       NEXTW 
2a00 c3 8c 1c			jp macro_next 
2a03				endm 
# End of macro NEXTW
2a03			 
2a03			.SCRATCH: 
2a03				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2a03 6f				db WORD_SYS_CORE+91             
2a04 3e 2a			dw .INC            
2a06 08				db 7 + 1 
2a07 .. 00			db "SCRATCH",0              
2a0f				endm 
# End of macro CWHEAD
2a0f			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2a0f			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2a0f			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2a0f			; | |  
2a0f			; | | e.g.    : score $00 scratch ; 
2a0f			; | |  
2a0f			; | | $00 score ! 
2a0f			; | | $01 score +! 
2a0f			; | |  
2a0f			; | | e.g.   : varword $0a scratch ;  
2a0f			; | | 
2a0f			; | | $8000 varword ! 
2a0f					if DEBUG_FORTH_WORDS_KEY 
2a0f						DMARK "SCR" 
2a0f f5				push af  
2a10 3a 24 2a			ld a, (.dmark)  
2a13 32 77 fb			ld (debug_mark),a  
2a16 3a 25 2a			ld a, (.dmark+1)  
2a19 32 78 fb			ld (debug_mark+1),a  
2a1c 3a 26 2a			ld a, (.dmark+2)  
2a1f 32 79 fb			ld (debug_mark+2),a  
2a22 18 03			jr .pastdmark  
2a24 ..			.dmark: db "SCR"  
2a27 f1			.pastdmark: pop af  
2a28			endm  
# End of macro DMARK
2a28						CALLMONITOR 
2a28 cd 01 15			call break_point_state  
2a2b				endm  
# End of macro CALLMONITOR
2a2b					endif 
2a2b			 
2a2b					FORTH_DSP_VALUEHL 
2a2b cd 36 1b			call macro_dsp_valuehl 
2a2e				endm 
# End of macro FORTH_DSP_VALUEHL
2a2e				 
2a2e					FORTH_DSP_POP 
2a2e cd d2 1b			call macro_forth_dsp_pop 
2a31				endm 
# End of macro FORTH_DSP_POP
2a31			 
2a31 7d					ld a, l 
2a32 21 57 f3				ld hl, os_var_array 
2a35 cd bf 0c				call addatohl 
2a38			 
2a38 cd 9b 1a				call forth_push_numhl 
2a3b			 
2a3b				       NEXTW 
2a3b c3 8c 1c			jp macro_next 
2a3e				endm 
# End of macro NEXTW
2a3e			 
2a3e			.INC: 
2a3e				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2a3e 6f				db WORD_SYS_CORE+91             
2a3f 92 2a			dw .DEC            
2a41 03				db 2 + 1 
2a42 .. 00			db "+!",0              
2a45				endm 
# End of macro CWHEAD
2a45			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2a45					if DEBUG_FORTH_WORDS_KEY 
2a45						DMARK "+s_" 
2a45 f5				push af  
2a46 3a 5a 2a			ld a, (.dmark)  
2a49 32 77 fb			ld (debug_mark),a  
2a4c 3a 5b 2a			ld a, (.dmark+1)  
2a4f 32 78 fb			ld (debug_mark+1),a  
2a52 3a 5c 2a			ld a, (.dmark+2)  
2a55 32 79 fb			ld (debug_mark+2),a  
2a58 18 03			jr .pastdmark  
2a5a ..			.dmark: db "+s_"  
2a5d f1			.pastdmark: pop af  
2a5e			endm  
# End of macro DMARK
2a5e						CALLMONITOR 
2a5e cd 01 15			call break_point_state  
2a61				endm  
# End of macro CALLMONITOR
2a61					endif 
2a61			 
2a61					FORTH_DSP_VALUEHL 
2a61 cd 36 1b			call macro_dsp_valuehl 
2a64				endm 
# End of macro FORTH_DSP_VALUEHL
2a64			 
2a64 e5					push hl   ; save address 
2a65			 
2a65					FORTH_DSP_POP 
2a65 cd d2 1b			call macro_forth_dsp_pop 
2a68				endm 
# End of macro FORTH_DSP_POP
2a68			 
2a68					FORTH_DSP_VALUEHL 
2a68 cd 36 1b			call macro_dsp_valuehl 
2a6b				endm 
# End of macro FORTH_DSP_VALUEHL
2a6b			 
2a6b					FORTH_DSP_POP 
2a6b cd d2 1b			call macro_forth_dsp_pop 
2a6e				endm 
# End of macro FORTH_DSP_POP
2a6e			 
2a6e					; hl contains value to add to byte at a 
2a6e				 
2a6e eb					ex de, hl 
2a6f			 
2a6f e1					pop hl 
2a70			 
2a70					if DEBUG_FORTH_WORDS 
2a70						DMARK "INC" 
2a70 f5				push af  
2a71 3a 85 2a			ld a, (.dmark)  
2a74 32 77 fb			ld (debug_mark),a  
2a77 3a 86 2a			ld a, (.dmark+1)  
2a7a 32 78 fb			ld (debug_mark+1),a  
2a7d 3a 87 2a			ld a, (.dmark+2)  
2a80 32 79 fb			ld (debug_mark+2),a  
2a83 18 03			jr .pastdmark  
2a85 ..			.dmark: db "INC"  
2a88 f1			.pastdmark: pop af  
2a89			endm  
# End of macro DMARK
2a89						CALLMONITOR 
2a89 cd 01 15			call break_point_state  
2a8c				endm  
# End of macro CALLMONITOR
2a8c					endif 
2a8c			 
2a8c 7e					ld a,(hl) 
2a8d 83					add e 
2a8e 77					ld (hl),a 
2a8f			 
2a8f			 
2a8f			 
2a8f				       NEXTW 
2a8f c3 8c 1c			jp macro_next 
2a92				endm 
# End of macro NEXTW
2a92			 
2a92			.DEC: 
2a92				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2a92 6f				db WORD_SYS_CORE+91             
2a93 e3 2a			dw .INC2            
2a95 03				db 2 + 1 
2a96 .. 00			db "-!",0              
2a99				endm 
# End of macro CWHEAD
2a99			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2a99					if DEBUG_FORTH_WORDS_KEY 
2a99						DMARK "-s_" 
2a99 f5				push af  
2a9a 3a ae 2a			ld a, (.dmark)  
2a9d 32 77 fb			ld (debug_mark),a  
2aa0 3a af 2a			ld a, (.dmark+1)  
2aa3 32 78 fb			ld (debug_mark+1),a  
2aa6 3a b0 2a			ld a, (.dmark+2)  
2aa9 32 79 fb			ld (debug_mark+2),a  
2aac 18 03			jr .pastdmark  
2aae ..			.dmark: db "-s_"  
2ab1 f1			.pastdmark: pop af  
2ab2			endm  
# End of macro DMARK
2ab2						CALLMONITOR 
2ab2 cd 01 15			call break_point_state  
2ab5				endm  
# End of macro CALLMONITOR
2ab5					endif 
2ab5			 
2ab5					FORTH_DSP_VALUEHL 
2ab5 cd 36 1b			call macro_dsp_valuehl 
2ab8				endm 
# End of macro FORTH_DSP_VALUEHL
2ab8			 
2ab8 e5					push hl   ; save address 
2ab9			 
2ab9					FORTH_DSP_POP 
2ab9 cd d2 1b			call macro_forth_dsp_pop 
2abc				endm 
# End of macro FORTH_DSP_POP
2abc			 
2abc					FORTH_DSP_VALUEHL 
2abc cd 36 1b			call macro_dsp_valuehl 
2abf				endm 
# End of macro FORTH_DSP_VALUEHL
2abf			 
2abf					; hl contains value to add to byte at a 
2abf				 
2abf eb					ex de, hl 
2ac0			 
2ac0 e1					pop hl 
2ac1			 
2ac1					if DEBUG_FORTH_WORDS 
2ac1						DMARK "DEC" 
2ac1 f5				push af  
2ac2 3a d6 2a			ld a, (.dmark)  
2ac5 32 77 fb			ld (debug_mark),a  
2ac8 3a d7 2a			ld a, (.dmark+1)  
2acb 32 78 fb			ld (debug_mark+1),a  
2ace 3a d8 2a			ld a, (.dmark+2)  
2ad1 32 79 fb			ld (debug_mark+2),a  
2ad4 18 03			jr .pastdmark  
2ad6 ..			.dmark: db "DEC"  
2ad9 f1			.pastdmark: pop af  
2ada			endm  
# End of macro DMARK
2ada						CALLMONITOR 
2ada cd 01 15			call break_point_state  
2add				endm  
# End of macro CALLMONITOR
2add					endif 
2add			 
2add 7e					ld a,(hl) 
2ade 93					sub e 
2adf 77					ld (hl),a 
2ae0			 
2ae0			 
2ae0			 
2ae0				       NEXTW 
2ae0 c3 8c 1c			jp macro_next 
2ae3				endm 
# End of macro NEXTW
2ae3			 
2ae3			.INC2: 
2ae3				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2ae3 6f				db WORD_SYS_CORE+91             
2ae4 8d 2b			dw .DEC2            
2ae6 04				db 3 + 1 
2ae7 .. 00			db "+2!",0              
2aeb				endm 
# End of macro CWHEAD
2aeb			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2aeb			 
2aeb					if DEBUG_FORTH_WORDS_KEY 
2aeb						DMARK "+2s" 
2aeb f5				push af  
2aec 3a 00 2b			ld a, (.dmark)  
2aef 32 77 fb			ld (debug_mark),a  
2af2 3a 01 2b			ld a, (.dmark+1)  
2af5 32 78 fb			ld (debug_mark+1),a  
2af8 3a 02 2b			ld a, (.dmark+2)  
2afb 32 79 fb			ld (debug_mark+2),a  
2afe 18 03			jr .pastdmark  
2b00 ..			.dmark: db "+2s"  
2b03 f1			.pastdmark: pop af  
2b04			endm  
# End of macro DMARK
2b04						CALLMONITOR 
2b04 cd 01 15			call break_point_state  
2b07				endm  
# End of macro CALLMONITOR
2b07					endif 
2b07			 
2b07					; Address 
2b07			 
2b07					FORTH_DSP_VALUEHL 
2b07 cd 36 1b			call macro_dsp_valuehl 
2b0a				endm 
# End of macro FORTH_DSP_VALUEHL
2b0a			 
2b0a e5					push hl    ; save address 
2b0b			 
2b0b					; load content into de 
2b0b			 
2b0b 5e					ld e,(hl) 
2b0c 23					inc hl 
2b0d 56					ld d, (hl) 
2b0e			 
2b0e					if DEBUG_FORTH_WORDS 
2b0e						DMARK "+2a" 
2b0e f5				push af  
2b0f 3a 23 2b			ld a, (.dmark)  
2b12 32 77 fb			ld (debug_mark),a  
2b15 3a 24 2b			ld a, (.dmark+1)  
2b18 32 78 fb			ld (debug_mark+1),a  
2b1b 3a 25 2b			ld a, (.dmark+2)  
2b1e 32 79 fb			ld (debug_mark+2),a  
2b21 18 03			jr .pastdmark  
2b23 ..			.dmark: db "+2a"  
2b26 f1			.pastdmark: pop af  
2b27			endm  
# End of macro DMARK
2b27						CALLMONITOR 
2b27 cd 01 15			call break_point_state  
2b2a				endm  
# End of macro CALLMONITOR
2b2a					endif 
2b2a			 
2b2a					FORTH_DSP_POP 
2b2a cd d2 1b			call macro_forth_dsp_pop 
2b2d				endm 
# End of macro FORTH_DSP_POP
2b2d			 
2b2d					; Get value to add 
2b2d			 
2b2d					FORTH_DSP_VALUE 
2b2d cd 1f 1b			call macro_forth_dsp_value 
2b30				endm 
# End of macro FORTH_DSP_VALUE
2b30			 
2b30					if DEBUG_FORTH_WORDS 
2b30						DMARK "+2v" 
2b30 f5				push af  
2b31 3a 45 2b			ld a, (.dmark)  
2b34 32 77 fb			ld (debug_mark),a  
2b37 3a 46 2b			ld a, (.dmark+1)  
2b3a 32 78 fb			ld (debug_mark+1),a  
2b3d 3a 47 2b			ld a, (.dmark+2)  
2b40 32 79 fb			ld (debug_mark+2),a  
2b43 18 03			jr .pastdmark  
2b45 ..			.dmark: db "+2v"  
2b48 f1			.pastdmark: pop af  
2b49			endm  
# End of macro DMARK
2b49						CALLMONITOR 
2b49 cd 01 15			call break_point_state  
2b4c				endm  
# End of macro CALLMONITOR
2b4c					endif 
2b4c			 
2b4c 19					add hl, de 
2b4d			 
2b4d					if DEBUG_FORTH_WORDS 
2b4d						DMARK "+2+" 
2b4d f5				push af  
2b4e 3a 62 2b			ld a, (.dmark)  
2b51 32 77 fb			ld (debug_mark),a  
2b54 3a 63 2b			ld a, (.dmark+1)  
2b57 32 78 fb			ld (debug_mark+1),a  
2b5a 3a 64 2b			ld a, (.dmark+2)  
2b5d 32 79 fb			ld (debug_mark+2),a  
2b60 18 03			jr .pastdmark  
2b62 ..			.dmark: db "+2+"  
2b65 f1			.pastdmark: pop af  
2b66			endm  
# End of macro DMARK
2b66						CALLMONITOR 
2b66 cd 01 15			call break_point_state  
2b69				endm  
# End of macro CALLMONITOR
2b69					endif 
2b69			 
2b69					; move result to de 
2b69			 
2b69 eb					ex de, hl 
2b6a			 
2b6a					; Address 
2b6a			 
2b6a e1					pop hl 
2b6b			 
2b6b					; save it back 
2b6b			 
2b6b 73					ld (hl), e 
2b6c 23					inc hl 
2b6d 72					ld (hl), d 
2b6e			 
2b6e					if DEBUG_FORTH_WORDS 
2b6e						DMARK "+2e" 
2b6e f5				push af  
2b6f 3a 83 2b			ld a, (.dmark)  
2b72 32 77 fb			ld (debug_mark),a  
2b75 3a 84 2b			ld a, (.dmark+1)  
2b78 32 78 fb			ld (debug_mark+1),a  
2b7b 3a 85 2b			ld a, (.dmark+2)  
2b7e 32 79 fb			ld (debug_mark+2),a  
2b81 18 03			jr .pastdmark  
2b83 ..			.dmark: db "+2e"  
2b86 f1			.pastdmark: pop af  
2b87			endm  
# End of macro DMARK
2b87						CALLMONITOR 
2b87 cd 01 15			call break_point_state  
2b8a				endm  
# End of macro CALLMONITOR
2b8a					endif 
2b8a			 
2b8a			 
2b8a			 
2b8a			 
2b8a			 
2b8a				       NEXTW 
2b8a c3 8c 1c			jp macro_next 
2b8d				endm 
# End of macro NEXTW
2b8d			 
2b8d			.DEC2: 
2b8d				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2b8d 6f				db WORD_SYS_CORE+91             
2b8e 39 2c			dw .GET2            
2b90 04				db 3 + 1 
2b91 .. 00			db "-2!",0              
2b95				endm 
# End of macro CWHEAD
2b95			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2b95			 
2b95			 
2b95					if DEBUG_FORTH_WORDS_KEY 
2b95						DMARK "-2s" 
2b95 f5				push af  
2b96 3a aa 2b			ld a, (.dmark)  
2b99 32 77 fb			ld (debug_mark),a  
2b9c 3a ab 2b			ld a, (.dmark+1)  
2b9f 32 78 fb			ld (debug_mark+1),a  
2ba2 3a ac 2b			ld a, (.dmark+2)  
2ba5 32 79 fb			ld (debug_mark+2),a  
2ba8 18 03			jr .pastdmark  
2baa ..			.dmark: db "-2s"  
2bad f1			.pastdmark: pop af  
2bae			endm  
# End of macro DMARK
2bae						CALLMONITOR 
2bae cd 01 15			call break_point_state  
2bb1				endm  
# End of macro CALLMONITOR
2bb1					endif 
2bb1			 
2bb1					; Address 
2bb1			 
2bb1					FORTH_DSP_VALUEHL 
2bb1 cd 36 1b			call macro_dsp_valuehl 
2bb4				endm 
# End of macro FORTH_DSP_VALUEHL
2bb4			 
2bb4 e5					push hl    ; save address 
2bb5			 
2bb5					; load content into de 
2bb5			 
2bb5 5e					ld e,(hl) 
2bb6 23					inc hl 
2bb7 56					ld d, (hl) 
2bb8			 
2bb8					if DEBUG_FORTH_WORDS 
2bb8						DMARK "-2a" 
2bb8 f5				push af  
2bb9 3a cd 2b			ld a, (.dmark)  
2bbc 32 77 fb			ld (debug_mark),a  
2bbf 3a ce 2b			ld a, (.dmark+1)  
2bc2 32 78 fb			ld (debug_mark+1),a  
2bc5 3a cf 2b			ld a, (.dmark+2)  
2bc8 32 79 fb			ld (debug_mark+2),a  
2bcb 18 03			jr .pastdmark  
2bcd ..			.dmark: db "-2a"  
2bd0 f1			.pastdmark: pop af  
2bd1			endm  
# End of macro DMARK
2bd1						CALLMONITOR 
2bd1 cd 01 15			call break_point_state  
2bd4				endm  
# End of macro CALLMONITOR
2bd4					endif 
2bd4			 
2bd4					FORTH_DSP_POP 
2bd4 cd d2 1b			call macro_forth_dsp_pop 
2bd7				endm 
# End of macro FORTH_DSP_POP
2bd7			 
2bd7					; Get value to remove 
2bd7			 
2bd7					FORTH_DSP_VALUE 
2bd7 cd 1f 1b			call macro_forth_dsp_value 
2bda				endm 
# End of macro FORTH_DSP_VALUE
2bda			 
2bda					if DEBUG_FORTH_WORDS 
2bda						DMARK "-2v" 
2bda f5				push af  
2bdb 3a ef 2b			ld a, (.dmark)  
2bde 32 77 fb			ld (debug_mark),a  
2be1 3a f0 2b			ld a, (.dmark+1)  
2be4 32 78 fb			ld (debug_mark+1),a  
2be7 3a f1 2b			ld a, (.dmark+2)  
2bea 32 79 fb			ld (debug_mark+2),a  
2bed 18 03			jr .pastdmark  
2bef ..			.dmark: db "-2v"  
2bf2 f1			.pastdmark: pop af  
2bf3			endm  
# End of macro DMARK
2bf3						CALLMONITOR 
2bf3 cd 01 15			call break_point_state  
2bf6				endm  
# End of macro CALLMONITOR
2bf6					endif 
2bf6			 
2bf6 eb					ex de, hl 
2bf7 ed 52				sbc hl, de 
2bf9			 
2bf9					if DEBUG_FORTH_WORDS 
2bf9						DMARK "-2d" 
2bf9 f5				push af  
2bfa 3a 0e 2c			ld a, (.dmark)  
2bfd 32 77 fb			ld (debug_mark),a  
2c00 3a 0f 2c			ld a, (.dmark+1)  
2c03 32 78 fb			ld (debug_mark+1),a  
2c06 3a 10 2c			ld a, (.dmark+2)  
2c09 32 79 fb			ld (debug_mark+2),a  
2c0c 18 03			jr .pastdmark  
2c0e ..			.dmark: db "-2d"  
2c11 f1			.pastdmark: pop af  
2c12			endm  
# End of macro DMARK
2c12						CALLMONITOR 
2c12 cd 01 15			call break_point_state  
2c15				endm  
# End of macro CALLMONITOR
2c15					endif 
2c15			 
2c15					; move result to de 
2c15			 
2c15 eb					ex de, hl 
2c16			 
2c16					; Address 
2c16			 
2c16 e1					pop hl 
2c17			 
2c17					; save it back 
2c17			 
2c17 73					ld (hl), e 
2c18 23					inc hl 
2c19 72					ld (hl), d 
2c1a			 
2c1a					if DEBUG_FORTH_WORDS 
2c1a						DMARK "-2e" 
2c1a f5				push af  
2c1b 3a 2f 2c			ld a, (.dmark)  
2c1e 32 77 fb			ld (debug_mark),a  
2c21 3a 30 2c			ld a, (.dmark+1)  
2c24 32 78 fb			ld (debug_mark+1),a  
2c27 3a 31 2c			ld a, (.dmark+2)  
2c2a 32 79 fb			ld (debug_mark+2),a  
2c2d 18 03			jr .pastdmark  
2c2f ..			.dmark: db "-2e"  
2c32 f1			.pastdmark: pop af  
2c33			endm  
# End of macro DMARK
2c33						CALLMONITOR 
2c33 cd 01 15			call break_point_state  
2c36				endm  
# End of macro CALLMONITOR
2c36					endif 
2c36			 
2c36			 
2c36			 
2c36			 
2c36			 
2c36				       NEXTW 
2c36 c3 8c 1c			jp macro_next 
2c39				endm 
# End of macro NEXTW
2c39			.GET2: 
2c39				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2c39 6f				db WORD_SYS_CORE+91             
2c3a 69 2c			dw .BANG2            
2c3c 03				db 2 + 1 
2c3d .. 00			db "2@",0              
2c40				endm 
# End of macro CWHEAD
2c40			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2c40					if DEBUG_FORTH_WORDS_KEY 
2c40						DMARK "2A_" 
2c40 f5				push af  
2c41 3a 55 2c			ld a, (.dmark)  
2c44 32 77 fb			ld (debug_mark),a  
2c47 3a 56 2c			ld a, (.dmark+1)  
2c4a 32 78 fb			ld (debug_mark+1),a  
2c4d 3a 57 2c			ld a, (.dmark+2)  
2c50 32 79 fb			ld (debug_mark+2),a  
2c53 18 03			jr .pastdmark  
2c55 ..			.dmark: db "2A_"  
2c58 f1			.pastdmark: pop af  
2c59			endm  
# End of macro DMARK
2c59						CALLMONITOR 
2c59 cd 01 15			call break_point_state  
2c5c				endm  
# End of macro CALLMONITOR
2c5c					endif 
2c5c			 
2c5c					FORTH_DSP_VALUEHL 
2c5c cd 36 1b			call macro_dsp_valuehl 
2c5f				endm 
# End of macro FORTH_DSP_VALUEHL
2c5f			 
2c5f 5e					ld e, (hl) 
2c60 23					inc hl 
2c61 56					ld d, (hl) 
2c62			 
2c62 eb					ex de, hl 
2c63			 
2c63 cd 9b 1a				call forth_push_numhl 
2c66			 
2c66				       NEXTW 
2c66 c3 8c 1c			jp macro_next 
2c69				endm 
# End of macro NEXTW
2c69			.BANG2: 
2c69				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2c69 6f				db WORD_SYS_CORE+91             
2c6a a1 2c			dw .CONFIG            
2c6c 03				db 2 + 1 
2c6d .. 00			db "2!",0              
2c70				endm 
# End of macro CWHEAD
2c70			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2c70					if DEBUG_FORTH_WORDS_KEY 
2c70						DMARK "2S_" 
2c70 f5				push af  
2c71 3a 85 2c			ld a, (.dmark)  
2c74 32 77 fb			ld (debug_mark),a  
2c77 3a 86 2c			ld a, (.dmark+1)  
2c7a 32 78 fb			ld (debug_mark+1),a  
2c7d 3a 87 2c			ld a, (.dmark+2)  
2c80 32 79 fb			ld (debug_mark+2),a  
2c83 18 03			jr .pastdmark  
2c85 ..			.dmark: db "2S_"  
2c88 f1			.pastdmark: pop af  
2c89			endm  
# End of macro DMARK
2c89						CALLMONITOR 
2c89 cd 01 15			call break_point_state  
2c8c				endm  
# End of macro CALLMONITOR
2c8c					endif 
2c8c			 
2c8c					FORTH_DSP_VALUEHL 
2c8c cd 36 1b			call macro_dsp_valuehl 
2c8f				endm 
# End of macro FORTH_DSP_VALUEHL
2c8f			 
2c8f e5					push hl   ; save address 
2c90			 
2c90			 
2c90					FORTH_DSP_POP 
2c90 cd d2 1b			call macro_forth_dsp_pop 
2c93				endm 
# End of macro FORTH_DSP_POP
2c93			 
2c93					 
2c93					FORTH_DSP_VALUEHL 
2c93 cd 36 1b			call macro_dsp_valuehl 
2c96				endm 
# End of macro FORTH_DSP_VALUEHL
2c96			 
2c96					FORTH_DSP_POP 
2c96 cd d2 1b			call macro_forth_dsp_pop 
2c99				endm 
# End of macro FORTH_DSP_POP
2c99			 
2c99 eb					ex de, hl    ; value now in de 
2c9a			 
2c9a e1					pop hl 
2c9b			 
2c9b 73					ld (hl), e 
2c9c			 
2c9c 23					inc hl 
2c9d			 
2c9d 72					ld (hl), d 
2c9e			 
2c9e			 
2c9e				       NEXTW 
2c9e c3 8c 1c			jp macro_next 
2ca1				endm 
# End of macro NEXTW
2ca1			.CONFIG: 
2ca1				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2ca1 6f				db WORD_SYS_CORE+91             
2ca2 b2 2c			dw .ENDCORE            
2ca4 07				db 6 + 1 
2ca5 .. 00			db "CONFIG",0              
2cac				endm 
# End of macro CWHEAD
2cac			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
2cac			 
2cac cd 49 13				call config 
2caf					NEXTW 
2caf c3 8c 1c			jp macro_next 
2cb2				endm 
# End of macro NEXTW
2cb2			.ENDCORE: 
2cb2			 
2cb2			; eof 
2cb2			 
2cb2			 
# End of file forth_words_core.asm
2cb2			include "forth_words_flow.asm" 
2cb2			 
2cb2			; | ## Program Flow Words 
2cb2			 
2cb2			.IF: 
2cb2				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2cb2 1e				db WORD_SYS_CORE+10             
2cb3 a7 2d			dw .THEN            
2cb5 03				db 2 + 1 
2cb6 .. 00			db "IF",0              
2cb9				endm 
# End of macro CWHEAD
2cb9			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2cb9			; 
2cb9					if DEBUG_FORTH_WORDS_KEY 
2cb9						DMARK "IF." 
2cb9 f5				push af  
2cba 3a ce 2c			ld a, (.dmark)  
2cbd 32 77 fb			ld (debug_mark),a  
2cc0 3a cf 2c			ld a, (.dmark+1)  
2cc3 32 78 fb			ld (debug_mark+1),a  
2cc6 3a d0 2c			ld a, (.dmark+2)  
2cc9 32 79 fb			ld (debug_mark+2),a  
2ccc 18 03			jr .pastdmark  
2cce ..			.dmark: db "IF."  
2cd1 f1			.pastdmark: pop af  
2cd2			endm  
# End of macro DMARK
2cd2						CALLMONITOR 
2cd2 cd 01 15			call break_point_state  
2cd5				endm  
# End of macro CALLMONITOR
2cd5					endif 
2cd5			; eval TOS 
2cd5			 
2cd5				FORTH_DSP_VALUEHL 
2cd5 cd 36 1b			call macro_dsp_valuehl 
2cd8				endm 
# End of macro FORTH_DSP_VALUEHL
2cd8			 
2cd8			;	push hl 
2cd8				FORTH_DSP_POP 
2cd8 cd d2 1b			call macro_forth_dsp_pop 
2cdb				endm 
# End of macro FORTH_DSP_POP
2cdb			;	pop hl 
2cdb			 
2cdb					if DEBUG_FORTH_WORDS 
2cdb						DMARK "IF1" 
2cdb f5				push af  
2cdc 3a f0 2c			ld a, (.dmark)  
2cdf 32 77 fb			ld (debug_mark),a  
2ce2 3a f1 2c			ld a, (.dmark+1)  
2ce5 32 78 fb			ld (debug_mark+1),a  
2ce8 3a f2 2c			ld a, (.dmark+2)  
2ceb 32 79 fb			ld (debug_mark+2),a  
2cee 18 03			jr .pastdmark  
2cf0 ..			.dmark: db "IF1"  
2cf3 f1			.pastdmark: pop af  
2cf4			endm  
# End of macro DMARK
2cf4						CALLMONITOR 
2cf4 cd 01 15			call break_point_state  
2cf7				endm  
# End of macro CALLMONITOR
2cf7					endif 
2cf7 b7				or a        ; clear carry flag 
2cf8 11 00 00			ld de, 0 
2cfb eb				ex de,hl 
2cfc ed 52			sbc hl, de 
2cfe c2 88 2d			jp nz, .iftrue 
2d01			 
2d01					if DEBUG_FORTH_WORDS 
2d01						DMARK "IF2" 
2d01 f5				push af  
2d02 3a 16 2d			ld a, (.dmark)  
2d05 32 77 fb			ld (debug_mark),a  
2d08 3a 17 2d			ld a, (.dmark+1)  
2d0b 32 78 fb			ld (debug_mark+1),a  
2d0e 3a 18 2d			ld a, (.dmark+2)  
2d11 32 79 fb			ld (debug_mark+2),a  
2d14 18 03			jr .pastdmark  
2d16 ..			.dmark: db "IF2"  
2d19 f1			.pastdmark: pop af  
2d1a			endm  
# End of macro DMARK
2d1a						CALLMONITOR 
2d1a cd 01 15			call break_point_state  
2d1d				endm  
# End of macro CALLMONITOR
2d1d					endif 
2d1d			 
2d1d			; if not true then skip to THEN 
2d1d			 
2d1d				; TODO get tok_ptr 
2d1d				; TODO consume toks until we get to THEN 
2d1d			 
2d1d 2a 33 f1			ld hl, (os_tok_ptr) 
2d20					if DEBUG_FORTH_WORDS 
2d20						DMARK "IF3" 
2d20 f5				push af  
2d21 3a 35 2d			ld a, (.dmark)  
2d24 32 77 fb			ld (debug_mark),a  
2d27 3a 36 2d			ld a, (.dmark+1)  
2d2a 32 78 fb			ld (debug_mark+1),a  
2d2d 3a 37 2d			ld a, (.dmark+2)  
2d30 32 79 fb			ld (debug_mark+2),a  
2d33 18 03			jr .pastdmark  
2d35 ..			.dmark: db "IF3"  
2d38 f1			.pastdmark: pop af  
2d39			endm  
# End of macro DMARK
2d39						CALLMONITOR 
2d39 cd 01 15			call break_point_state  
2d3c				endm  
# End of macro CALLMONITOR
2d3c						 
2d3c					endif 
2d3c 11 83 2d			ld de, .ifthen 
2d3f					if DEBUG_FORTH_WORDS 
2d3f						DMARK "IF4" 
2d3f f5				push af  
2d40 3a 54 2d			ld a, (.dmark)  
2d43 32 77 fb			ld (debug_mark),a  
2d46 3a 55 2d			ld a, (.dmark+1)  
2d49 32 78 fb			ld (debug_mark+1),a  
2d4c 3a 56 2d			ld a, (.dmark+2)  
2d4f 32 79 fb			ld (debug_mark+2),a  
2d52 18 03			jr .pastdmark  
2d54 ..			.dmark: db "IF4"  
2d57 f1			.pastdmark: pop af  
2d58			endm  
# End of macro DMARK
2d58						CALLMONITOR 
2d58 cd 01 15			call break_point_state  
2d5b				endm  
# End of macro CALLMONITOR
2d5b					endif 
2d5b cd a7 1d			call findnexttok  
2d5e			 
2d5e					if DEBUG_FORTH_WORDS 
2d5e						DMARK "IF5" 
2d5e f5				push af  
2d5f 3a 73 2d			ld a, (.dmark)  
2d62 32 77 fb			ld (debug_mark),a  
2d65 3a 74 2d			ld a, (.dmark+1)  
2d68 32 78 fb			ld (debug_mark+1),a  
2d6b 3a 75 2d			ld a, (.dmark+2)  
2d6e 32 79 fb			ld (debug_mark+2),a  
2d71 18 03			jr .pastdmark  
2d73 ..			.dmark: db "IF5"  
2d76 f1			.pastdmark: pop af  
2d77			endm  
# End of macro DMARK
2d77						CALLMONITOR 
2d77 cd 01 15			call break_point_state  
2d7a				endm  
# End of macro CALLMONITOR
2d7a					endif 
2d7a				; TODO replace below with ; exec using tok_ptr 
2d7a 22 33 f1			ld (os_tok_ptr), hl 
2d7d c3 1d 1d			jp exec1 
2d80				NEXTW 
2d80 c3 8c 1c			jp macro_next 
2d83				endm 
# End of macro NEXTW
2d83			 
2d83 .. 00		.ifthen:  db "THEN",0 
2d88			 
2d88			.iftrue:		 
2d88				; Exec next words normally 
2d88			 
2d88				; if true then exec following IF as normal 
2d88					if DEBUG_FORTH_WORDS 
2d88						DMARK "IFT" 
2d88 f5				push af  
2d89 3a 9d 2d			ld a, (.dmark)  
2d8c 32 77 fb			ld (debug_mark),a  
2d8f 3a 9e 2d			ld a, (.dmark+1)  
2d92 32 78 fb			ld (debug_mark+1),a  
2d95 3a 9f 2d			ld a, (.dmark+2)  
2d98 32 79 fb			ld (debug_mark+2),a  
2d9b 18 03			jr .pastdmark  
2d9d ..			.dmark: db "IFT"  
2da0 f1			.pastdmark: pop af  
2da1			endm  
# End of macro DMARK
2da1						CALLMONITOR 
2da1 cd 01 15			call break_point_state  
2da4				endm  
# End of macro CALLMONITOR
2da4					endif 
2da4			 
2da4					NEXTW 
2da4 c3 8c 1c			jp macro_next 
2da7				endm 
# End of macro NEXTW
2da7			.THEN: 
2da7				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2da7 1f				db WORD_SYS_CORE+11             
2da8 cf 2d			dw .ELSE            
2daa 05				db 4 + 1 
2dab .. 00			db "THEN",0              
2db0				endm 
# End of macro CWHEAD
2db0			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2db0					if DEBUG_FORTH_WORDS_KEY 
2db0						DMARK "THN" 
2db0 f5				push af  
2db1 3a c5 2d			ld a, (.dmark)  
2db4 32 77 fb			ld (debug_mark),a  
2db7 3a c6 2d			ld a, (.dmark+1)  
2dba 32 78 fb			ld (debug_mark+1),a  
2dbd 3a c7 2d			ld a, (.dmark+2)  
2dc0 32 79 fb			ld (debug_mark+2),a  
2dc3 18 03			jr .pastdmark  
2dc5 ..			.dmark: db "THN"  
2dc8 f1			.pastdmark: pop af  
2dc9			endm  
# End of macro DMARK
2dc9						CALLMONITOR 
2dc9 cd 01 15			call break_point_state  
2dcc				endm  
# End of macro CALLMONITOR
2dcc					endif 
2dcc					NEXTW 
2dcc c3 8c 1c			jp macro_next 
2dcf				endm 
# End of macro NEXTW
2dcf			.ELSE: 
2dcf				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2dcf 20				db WORD_SYS_CORE+12             
2dd0 f7 2d			dw .DO            
2dd2 03				db 2 + 1 
2dd3 .. 00			db "ELSE",0              
2dd8				endm 
# End of macro CWHEAD
2dd8			; | ELSE ( -- ) Not supported - does nothing | TODO 
2dd8			 
2dd8					if DEBUG_FORTH_WORDS_KEY 
2dd8						DMARK "ELS" 
2dd8 f5				push af  
2dd9 3a ed 2d			ld a, (.dmark)  
2ddc 32 77 fb			ld (debug_mark),a  
2ddf 3a ee 2d			ld a, (.dmark+1)  
2de2 32 78 fb			ld (debug_mark+1),a  
2de5 3a ef 2d			ld a, (.dmark+2)  
2de8 32 79 fb			ld (debug_mark+2),a  
2deb 18 03			jr .pastdmark  
2ded ..			.dmark: db "ELS"  
2df0 f1			.pastdmark: pop af  
2df1			endm  
# End of macro DMARK
2df1						CALLMONITOR 
2df1 cd 01 15			call break_point_state  
2df4				endm  
# End of macro CALLMONITOR
2df4					endif 
2df4			 
2df4			 
2df4					NEXTW 
2df4 c3 8c 1c			jp macro_next 
2df7				endm 
# End of macro NEXTW
2df7			.DO: 
2df7				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2df7 21				db WORD_SYS_CORE+13             
2df8 1e 2f			dw .LOOP            
2dfa 03				db 2 + 1 
2dfb .. 00			db "DO",0              
2dfe				endm 
# End of macro CWHEAD
2dfe			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2dfe			 
2dfe					if DEBUG_FORTH_WORDS_KEY 
2dfe						DMARK "DO." 
2dfe f5				push af  
2dff 3a 13 2e			ld a, (.dmark)  
2e02 32 77 fb			ld (debug_mark),a  
2e05 3a 14 2e			ld a, (.dmark+1)  
2e08 32 78 fb			ld (debug_mark+1),a  
2e0b 3a 15 2e			ld a, (.dmark+2)  
2e0e 32 79 fb			ld (debug_mark+2),a  
2e11 18 03			jr .pastdmark  
2e13 ..			.dmark: db "DO."  
2e16 f1			.pastdmark: pop af  
2e17			endm  
# End of macro DMARK
2e17						CALLMONITOR 
2e17 cd 01 15			call break_point_state  
2e1a				endm  
# End of macro CALLMONITOR
2e1a					endif 
2e1a			;  push pc to rsp stack past the DO 
2e1a			 
2e1a 2a 33 f1				ld hl, (os_tok_ptr) 
2e1d 23					inc hl   ; D 
2e1e 23					inc hl  ; O 
2e1f 23					inc hl   ; null 
2e20					if DEBUG_FORTH_WORDS 
2e20						DMARK "DO2" 
2e20 f5				push af  
2e21 3a 35 2e			ld a, (.dmark)  
2e24 32 77 fb			ld (debug_mark),a  
2e27 3a 36 2e			ld a, (.dmark+1)  
2e2a 32 78 fb			ld (debug_mark+1),a  
2e2d 3a 37 2e			ld a, (.dmark+2)  
2e30 32 79 fb			ld (debug_mark+2),a  
2e33 18 03			jr .pastdmark  
2e35 ..			.dmark: db "DO2"  
2e38 f1			.pastdmark: pop af  
2e39			endm  
# End of macro DMARK
2e39						CALLMONITOR 
2e39 cd 01 15			call break_point_state  
2e3c				endm  
# End of macro CALLMONITOR
2e3c					endif 
2e3c					FORTH_RSP_NEXT 
2e3c cd 42 1a			call macro_forth_rsp_next 
2e3f				endm 
# End of macro FORTH_RSP_NEXT
2e3f					if DEBUG_FORTH_WORDS 
2e3f						DMARK "DO3" 
2e3f f5				push af  
2e40 3a 54 2e			ld a, (.dmark)  
2e43 32 77 fb			ld (debug_mark),a  
2e46 3a 55 2e			ld a, (.dmark+1)  
2e49 32 78 fb			ld (debug_mark+1),a  
2e4c 3a 56 2e			ld a, (.dmark+2)  
2e4f 32 79 fb			ld (debug_mark+2),a  
2e52 18 03			jr .pastdmark  
2e54 ..			.dmark: db "DO3"  
2e57 f1			.pastdmark: pop af  
2e58			endm  
# End of macro DMARK
2e58						CALLMONITOR 
2e58 cd 01 15			call break_point_state  
2e5b				endm  
# End of macro CALLMONITOR
2e5b					endif 
2e5b			 
2e5b					;if DEBUG_FORTH_WORDS 
2e5b				;		push hl 
2e5b			;		endif  
2e5b			 
2e5b			; get counters from data stack 
2e5b			 
2e5b			 
2e5b					FORTH_DSP_VALUEHL 
2e5b cd 36 1b			call macro_dsp_valuehl 
2e5e				endm 
# End of macro FORTH_DSP_VALUEHL
2e5e e5					push hl		 ; hl now has starting counter which needs to be tos 
2e5f			 
2e5f					if DEBUG_FORTH_WORDS 
2e5f						DMARK "DO4" 
2e5f f5				push af  
2e60 3a 74 2e			ld a, (.dmark)  
2e63 32 77 fb			ld (debug_mark),a  
2e66 3a 75 2e			ld a, (.dmark+1)  
2e69 32 78 fb			ld (debug_mark+1),a  
2e6c 3a 76 2e			ld a, (.dmark+2)  
2e6f 32 79 fb			ld (debug_mark+2),a  
2e72 18 03			jr .pastdmark  
2e74 ..			.dmark: db "DO4"  
2e77 f1			.pastdmark: pop af  
2e78			endm  
# End of macro DMARK
2e78						CALLMONITOR 
2e78 cd 01 15			call break_point_state  
2e7b				endm  
# End of macro CALLMONITOR
2e7b					endif 
2e7b					FORTH_DSP_POP 
2e7b cd d2 1b			call macro_forth_dsp_pop 
2e7e				endm 
# End of macro FORTH_DSP_POP
2e7e			 
2e7e					if DEBUG_FORTH_WORDS 
2e7e						DMARK "DO5" 
2e7e f5				push af  
2e7f 3a 93 2e			ld a, (.dmark)  
2e82 32 77 fb			ld (debug_mark),a  
2e85 3a 94 2e			ld a, (.dmark+1)  
2e88 32 78 fb			ld (debug_mark+1),a  
2e8b 3a 95 2e			ld a, (.dmark+2)  
2e8e 32 79 fb			ld (debug_mark+2),a  
2e91 18 03			jr .pastdmark  
2e93 ..			.dmark: db "DO5"  
2e96 f1			.pastdmark: pop af  
2e97			endm  
# End of macro DMARK
2e97						CALLMONITOR 
2e97 cd 01 15			call break_point_state  
2e9a				endm  
# End of macro CALLMONITOR
2e9a					endif 
2e9a			 
2e9a					FORTH_DSP_VALUEHL 
2e9a cd 36 1b			call macro_dsp_valuehl 
2e9d				endm 
# End of macro FORTH_DSP_VALUEHL
2e9d			;		push hl		 ; hl now has starting limit counter 
2e9d			 
2e9d					if DEBUG_FORTH_WORDS 
2e9d						DMARK "DO6" 
2e9d f5				push af  
2e9e 3a b2 2e			ld a, (.dmark)  
2ea1 32 77 fb			ld (debug_mark),a  
2ea4 3a b3 2e			ld a, (.dmark+1)  
2ea7 32 78 fb			ld (debug_mark+1),a  
2eaa 3a b4 2e			ld a, (.dmark+2)  
2ead 32 79 fb			ld (debug_mark+2),a  
2eb0 18 03			jr .pastdmark  
2eb2 ..			.dmark: db "DO6"  
2eb5 f1			.pastdmark: pop af  
2eb6			endm  
# End of macro DMARK
2eb6						CALLMONITOR 
2eb6 cd 01 15			call break_point_state  
2eb9				endm  
# End of macro CALLMONITOR
2eb9					endif 
2eb9					FORTH_DSP_POP 
2eb9 cd d2 1b			call macro_forth_dsp_pop 
2ebc				endm 
# End of macro FORTH_DSP_POP
2ebc			 
2ebc			; put counters on the loop stack 
2ebc			 
2ebc			;		pop hl			 ; limit counter 
2ebc d1					pop de			; start counter 
2ebd			 
2ebd					; push limit counter 
2ebd			 
2ebd					if DEBUG_FORTH_WORDS 
2ebd						DMARK "DO7" 
2ebd f5				push af  
2ebe 3a d2 2e			ld a, (.dmark)  
2ec1 32 77 fb			ld (debug_mark),a  
2ec4 3a d3 2e			ld a, (.dmark+1)  
2ec7 32 78 fb			ld (debug_mark+1),a  
2eca 3a d4 2e			ld a, (.dmark+2)  
2ecd 32 79 fb			ld (debug_mark+2),a  
2ed0 18 03			jr .pastdmark  
2ed2 ..			.dmark: db "DO7"  
2ed5 f1			.pastdmark: pop af  
2ed6			endm  
# End of macro DMARK
2ed6						CALLMONITOR 
2ed6 cd 01 15			call break_point_state  
2ed9				endm  
# End of macro CALLMONITOR
2ed9					endif 
2ed9					FORTH_LOOP_NEXT 
2ed9 cd 4b 1b			call macro_forth_loop_next 
2edc				endm 
# End of macro FORTH_LOOP_NEXT
2edc			 
2edc					; push start counter 
2edc			 
2edc eb					ex de, hl 
2edd					if DEBUG_FORTH_WORDS 
2edd						DMARK "DO7" 
2edd f5				push af  
2ede 3a f2 2e			ld a, (.dmark)  
2ee1 32 77 fb			ld (debug_mark),a  
2ee4 3a f3 2e			ld a, (.dmark+1)  
2ee7 32 78 fb			ld (debug_mark+1),a  
2eea 3a f4 2e			ld a, (.dmark+2)  
2eed 32 79 fb			ld (debug_mark+2),a  
2ef0 18 03			jr .pastdmark  
2ef2 ..			.dmark: db "DO7"  
2ef5 f1			.pastdmark: pop af  
2ef6			endm  
# End of macro DMARK
2ef6						CALLMONITOR 
2ef6 cd 01 15			call break_point_state  
2ef9				endm  
# End of macro CALLMONITOR
2ef9					endif 
2ef9					FORTH_LOOP_NEXT 
2ef9 cd 4b 1b			call macro_forth_loop_next 
2efc				endm 
# End of macro FORTH_LOOP_NEXT
2efc			 
2efc			 
2efc					; init first round of I counter 
2efc			 
2efc 22 57 f1				ld (os_current_i), hl 
2eff			 
2eff					if DEBUG_FORTH_WORDS 
2eff						DMARK "DO8" 
2eff f5				push af  
2f00 3a 14 2f			ld a, (.dmark)  
2f03 32 77 fb			ld (debug_mark),a  
2f06 3a 15 2f			ld a, (.dmark+1)  
2f09 32 78 fb			ld (debug_mark+1),a  
2f0c 3a 16 2f			ld a, (.dmark+2)  
2f0f 32 79 fb			ld (debug_mark+2),a  
2f12 18 03			jr .pastdmark  
2f14 ..			.dmark: db "DO8"  
2f17 f1			.pastdmark: pop af  
2f18			endm  
# End of macro DMARK
2f18						CALLMONITOR 
2f18 cd 01 15			call break_point_state  
2f1b				endm  
# End of macro CALLMONITOR
2f1b					endif 
2f1b			 
2f1b					NEXTW 
2f1b c3 8c 1c			jp macro_next 
2f1e				endm 
# End of macro NEXTW
2f1e			.LOOP: 
2f1e				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2f1e 22				db WORD_SYS_CORE+14             
2f1f 36 30			dw .I            
2f21 05				db 4 + 1 
2f22 .. 00			db "LOOP",0              
2f27				endm 
# End of macro CWHEAD
2f27			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2f27			 
2f27				; pop tos as current loop count to hl 
2f27			 
2f27				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2f27			 
2f27				FORTH_LOOP_TOS 
2f27 cd 7e 1b			call macro_forth_loop_tos 
2f2a				endm 
# End of macro FORTH_LOOP_TOS
2f2a e5				push hl 
2f2b			 
2f2b					if DEBUG_FORTH_WORDS_KEY 
2f2b						DMARK "LOP" 
2f2b f5				push af  
2f2c 3a 40 2f			ld a, (.dmark)  
2f2f 32 77 fb			ld (debug_mark),a  
2f32 3a 41 2f			ld a, (.dmark+1)  
2f35 32 78 fb			ld (debug_mark+1),a  
2f38 3a 42 2f			ld a, (.dmark+2)  
2f3b 32 79 fb			ld (debug_mark+2),a  
2f3e 18 03			jr .pastdmark  
2f40 ..			.dmark: db "LOP"  
2f43 f1			.pastdmark: pop af  
2f44			endm  
# End of macro DMARK
2f44						CALLMONITOR 
2f44 cd 01 15			call break_point_state  
2f47				endm  
# End of macro CALLMONITOR
2f47					endif 
2f47				; next item on the stack is the limit. get it 
2f47			 
2f47			 
2f47				FORTH_LOOP_POP 
2f47 cd 88 1b			call macro_forth_loop_pop 
2f4a				endm 
# End of macro FORTH_LOOP_POP
2f4a			 
2f4a				FORTH_LOOP_TOS 
2f4a cd 7e 1b			call macro_forth_loop_tos 
2f4d				endm 
# End of macro FORTH_LOOP_TOS
2f4d			 
2f4d d1				pop de		 ; de = i, hl = limit 
2f4e			 
2f4e					if DEBUG_FORTH_WORDS 
2f4e						DMARK "LP1" 
2f4e f5				push af  
2f4f 3a 63 2f			ld a, (.dmark)  
2f52 32 77 fb			ld (debug_mark),a  
2f55 3a 64 2f			ld a, (.dmark+1)  
2f58 32 78 fb			ld (debug_mark+1),a  
2f5b 3a 65 2f			ld a, (.dmark+2)  
2f5e 32 79 fb			ld (debug_mark+2),a  
2f61 18 03			jr .pastdmark  
2f63 ..			.dmark: db "LP1"  
2f66 f1			.pastdmark: pop af  
2f67			endm  
# End of macro DMARK
2f67						CALLMONITOR 
2f67 cd 01 15			call break_point_state  
2f6a				endm  
# End of macro CALLMONITOR
2f6a					endif 
2f6a			 
2f6a				; go back to previous word 
2f6a			 
2f6a d5				push de    ; save I for inc later 
2f6b			 
2f6b			 
2f6b				; get limit 
2f6b				;  is I at limit? 
2f6b			 
2f6b			 
2f6b					if DEBUG_FORTH_WORDS 
2f6b						DMARK "LP1" 
2f6b f5				push af  
2f6c 3a 80 2f			ld a, (.dmark)  
2f6f 32 77 fb			ld (debug_mark),a  
2f72 3a 81 2f			ld a, (.dmark+1)  
2f75 32 78 fb			ld (debug_mark+1),a  
2f78 3a 82 2f			ld a, (.dmark+2)  
2f7b 32 79 fb			ld (debug_mark+2),a  
2f7e 18 03			jr .pastdmark  
2f80 ..			.dmark: db "LP1"  
2f83 f1			.pastdmark: pop af  
2f84			endm  
# End of macro DMARK
2f84						CALLMONITOR 
2f84 cd 01 15			call break_point_state  
2f87				endm  
# End of macro CALLMONITOR
2f87					endif 
2f87			 
2f87 ed 52			sbc hl, de 
2f89			 
2f89			 
2f89				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2f89			 
2f89 20 26				jr nz, .loopnotdone 
2f8b			 
2f8b e1				pop hl   ; get rid of saved I 
2f8c				FORTH_LOOP_POP     ; get rid of limit 
2f8c cd 88 1b			call macro_forth_loop_pop 
2f8f				endm 
# End of macro FORTH_LOOP_POP
2f8f			 
2f8f				FORTH_RSP_POP     ; get rid of DO ptr 
2f8f cd 63 1a			call macro_forth_rsp_pop 
2f92				endm 
# End of macro FORTH_RSP_POP
2f92			 
2f92			if DEBUG_FORTH_WORDS 
2f92						DMARK "LP>" 
2f92 f5				push af  
2f93 3a a7 2f			ld a, (.dmark)  
2f96 32 77 fb			ld (debug_mark),a  
2f99 3a a8 2f			ld a, (.dmark+1)  
2f9c 32 78 fb			ld (debug_mark+1),a  
2f9f 3a a9 2f			ld a, (.dmark+2)  
2fa2 32 79 fb			ld (debug_mark+2),a  
2fa5 18 03			jr .pastdmark  
2fa7 ..			.dmark: db "LP>"  
2faa f1			.pastdmark: pop af  
2fab			endm  
# End of macro DMARK
2fab				CALLMONITOR 
2fab cd 01 15			call break_point_state  
2fae				endm  
# End of macro CALLMONITOR
2fae			endif 
2fae			 
2fae					NEXTW 
2fae c3 8c 1c			jp macro_next 
2fb1				endm 
# End of macro NEXTW
2fb1				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2fb1			 
2fb1			.loopnotdone: 
2fb1			 
2fb1 e1				pop hl    ; get I 
2fb2 23				inc hl 
2fb3			 
2fb3			   	; save new I 
2fb3			 
2fb3			 
2fb3					; set I counter 
2fb3			 
2fb3 22 57 f1				ld (os_current_i), hl 
2fb6			 
2fb6					if DEBUG_FORTH_WORDS 
2fb6						DMARK "LPN" 
2fb6 f5				push af  
2fb7 3a cb 2f			ld a, (.dmark)  
2fba 32 77 fb			ld (debug_mark),a  
2fbd 3a cc 2f			ld a, (.dmark+1)  
2fc0 32 78 fb			ld (debug_mark+1),a  
2fc3 3a cd 2f			ld a, (.dmark+2)  
2fc6 32 79 fb			ld (debug_mark+2),a  
2fc9 18 03			jr .pastdmark  
2fcb ..			.dmark: db "LPN"  
2fce f1			.pastdmark: pop af  
2fcf			endm  
# End of macro DMARK
2fcf					CALLMONITOR 
2fcf cd 01 15			call break_point_state  
2fd2				endm  
# End of macro CALLMONITOR
2fd2					endif 
2fd2					 
2fd2				FORTH_LOOP_NEXT 
2fd2 cd 4b 1b			call macro_forth_loop_next 
2fd5				endm 
# End of macro FORTH_LOOP_NEXT
2fd5			 
2fd5			 
2fd5					if DEBUG_FORTH_WORDS 
2fd5 eb						ex de,hl 
2fd6					endif 
2fd6			 
2fd6			;	; get DO ptr 
2fd6			; 
2fd6					if DEBUG_FORTH_WORDS 
2fd6						DMARK "LP7" 
2fd6 f5				push af  
2fd7 3a eb 2f			ld a, (.dmark)  
2fda 32 77 fb			ld (debug_mark),a  
2fdd 3a ec 2f			ld a, (.dmark+1)  
2fe0 32 78 fb			ld (debug_mark+1),a  
2fe3 3a ed 2f			ld a, (.dmark+2)  
2fe6 32 79 fb			ld (debug_mark+2),a  
2fe9 18 03			jr .pastdmark  
2feb ..			.dmark: db "LP7"  
2fee f1			.pastdmark: pop af  
2fef			endm  
# End of macro DMARK
2fef					CALLMONITOR 
2fef cd 01 15			call break_point_state  
2ff2				endm  
# End of macro CALLMONITOR
2ff2					endif 
2ff2				FORTH_RSP_TOS 
2ff2 cd 59 1a			call macro_forth_rsp_tos 
2ff5				endm 
# End of macro FORTH_RSP_TOS
2ff5			 
2ff5					if DEBUG_FORTH_WORDS 
2ff5						DMARK "LP8" 
2ff5 f5				push af  
2ff6 3a 0a 30			ld a, (.dmark)  
2ff9 32 77 fb			ld (debug_mark),a  
2ffc 3a 0b 30			ld a, (.dmark+1)  
2fff 32 78 fb			ld (debug_mark+1),a  
3002 3a 0c 30			ld a, (.dmark+2)  
3005 32 79 fb			ld (debug_mark+2),a  
3008 18 03			jr .pastdmark  
300a ..			.dmark: db "LP8"  
300d f1			.pastdmark: pop af  
300e			endm  
# End of macro DMARK
300e					CALLMONITOR 
300e cd 01 15			call break_point_state  
3011				endm  
# End of macro CALLMONITOR
3011					endif 
3011				;push hl 
3011			 
3011				; not going to DO any more 
3011				; get rid of the RSP pointer as DO will add it back in 
3011				;FORTH_RSP_POP 
3011				;pop hl 
3011			 
3011				;ld hl,(cli_ret_sp) 
3011				;ld e, (hl) 
3011				;inc hl 
3011				;ld d, (hl) 
3011				;ex de,hl 
3011 22 33 f1			ld (os_tok_ptr), hl 
3014					if DEBUG_FORTH_WORDS 
3014						DMARK "LP<" 
3014 f5				push af  
3015 3a 29 30			ld a, (.dmark)  
3018 32 77 fb			ld (debug_mark),a  
301b 3a 2a 30			ld a, (.dmark+1)  
301e 32 78 fb			ld (debug_mark+1),a  
3021 3a 2b 30			ld a, (.dmark+2)  
3024 32 79 fb			ld (debug_mark+2),a  
3027 18 03			jr .pastdmark  
3029 ..			.dmark: db "LP<"  
302c f1			.pastdmark: pop af  
302d			endm  
# End of macro DMARK
302d					CALLMONITOR 
302d cd 01 15			call break_point_state  
3030				endm  
# End of macro CALLMONITOR
3030				endif 
3030 c3 1d 1d			jp exec1 
3033			 
3033					 
3033			 
3033			 
3033					NEXTW 
3033 c3 8c 1c			jp macro_next 
3036				endm 
# End of macro NEXTW
3036			.I:  
3036			 
3036				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3036 5e				db WORD_SYS_CORE+74             
3037 61 30			dw .DLOOP            
3039 02				db 1 + 1 
303a .. 00			db "I",0              
303c				endm 
# End of macro CWHEAD
303c			; | I ( -- ) Current loop counter | DONE 
303c					if DEBUG_FORTH_WORDS_KEY 
303c						DMARK "I.." 
303c f5				push af  
303d 3a 51 30			ld a, (.dmark)  
3040 32 77 fb			ld (debug_mark),a  
3043 3a 52 30			ld a, (.dmark+1)  
3046 32 78 fb			ld (debug_mark+1),a  
3049 3a 53 30			ld a, (.dmark+2)  
304c 32 79 fb			ld (debug_mark+2),a  
304f 18 03			jr .pastdmark  
3051 ..			.dmark: db "I.."  
3054 f1			.pastdmark: pop af  
3055			endm  
# End of macro DMARK
3055						CALLMONITOR 
3055 cd 01 15			call break_point_state  
3058				endm  
# End of macro CALLMONITOR
3058					endif 
3058			 
3058 2a 57 f1				ld hl,(os_current_i) 
305b cd 9b 1a				call forth_push_numhl 
305e			 
305e					NEXTW 
305e c3 8c 1c			jp macro_next 
3061				endm 
# End of macro NEXTW
3061			.DLOOP: 
3061				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3061 5f				db WORD_SYS_CORE+75             
3062 42 31			dw .REPEAT            
3064 06				db 5 + 1 
3065 .. 00			db "-LOOP",0              
306b				endm 
# End of macro CWHEAD
306b			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
306b				; pop tos as current loop count to hl 
306b					if DEBUG_FORTH_WORDS_KEY 
306b						DMARK "-LP" 
306b f5				push af  
306c 3a 80 30			ld a, (.dmark)  
306f 32 77 fb			ld (debug_mark),a  
3072 3a 81 30			ld a, (.dmark+1)  
3075 32 78 fb			ld (debug_mark+1),a  
3078 3a 82 30			ld a, (.dmark+2)  
307b 32 79 fb			ld (debug_mark+2),a  
307e 18 03			jr .pastdmark  
3080 ..			.dmark: db "-LP"  
3083 f1			.pastdmark: pop af  
3084			endm  
# End of macro DMARK
3084						CALLMONITOR 
3084 cd 01 15			call break_point_state  
3087				endm  
# End of macro CALLMONITOR
3087					endif 
3087			 
3087				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3087			 
3087				FORTH_LOOP_TOS 
3087 cd 7e 1b			call macro_forth_loop_tos 
308a				endm 
# End of macro FORTH_LOOP_TOS
308a e5				push hl 
308b			 
308b					if DEBUG_FORTH_WORDS 
308b						DMARK "-LP" 
308b f5				push af  
308c 3a a0 30			ld a, (.dmark)  
308f 32 77 fb			ld (debug_mark),a  
3092 3a a1 30			ld a, (.dmark+1)  
3095 32 78 fb			ld (debug_mark+1),a  
3098 3a a2 30			ld a, (.dmark+2)  
309b 32 79 fb			ld (debug_mark+2),a  
309e 18 03			jr .pastdmark  
30a0 ..			.dmark: db "-LP"  
30a3 f1			.pastdmark: pop af  
30a4			endm  
# End of macro DMARK
30a4						CALLMONITOR 
30a4 cd 01 15			call break_point_state  
30a7				endm  
# End of macro CALLMONITOR
30a7					endif 
30a7				; next item on the stack is the limit. get it 
30a7			 
30a7			 
30a7				FORTH_LOOP_POP 
30a7 cd 88 1b			call macro_forth_loop_pop 
30aa				endm 
# End of macro FORTH_LOOP_POP
30aa			 
30aa				FORTH_LOOP_TOS 
30aa cd 7e 1b			call macro_forth_loop_tos 
30ad				endm 
# End of macro FORTH_LOOP_TOS
30ad			 
30ad d1				pop de		 ; de = i, hl = limit 
30ae			 
30ae					if DEBUG_FORTH_WORDS 
30ae						DMARK "-L1" 
30ae f5				push af  
30af 3a c3 30			ld a, (.dmark)  
30b2 32 77 fb			ld (debug_mark),a  
30b5 3a c4 30			ld a, (.dmark+1)  
30b8 32 78 fb			ld (debug_mark+1),a  
30bb 3a c5 30			ld a, (.dmark+2)  
30be 32 79 fb			ld (debug_mark+2),a  
30c1 18 03			jr .pastdmark  
30c3 ..			.dmark: db "-L1"  
30c6 f1			.pastdmark: pop af  
30c7			endm  
# End of macro DMARK
30c7						CALLMONITOR 
30c7 cd 01 15			call break_point_state  
30ca				endm  
# End of macro CALLMONITOR
30ca					endif 
30ca			 
30ca				; go back to previous word 
30ca			 
30ca d5				push de    ; save I for inc later 
30cb			 
30cb			 
30cb				; get limit 
30cb				;  is I at limit? 
30cb			 
30cb			 
30cb					if DEBUG_FORTH_WORDS 
30cb						DMARK "-L1" 
30cb f5				push af  
30cc 3a e0 30			ld a, (.dmark)  
30cf 32 77 fb			ld (debug_mark),a  
30d2 3a e1 30			ld a, (.dmark+1)  
30d5 32 78 fb			ld (debug_mark+1),a  
30d8 3a e2 30			ld a, (.dmark+2)  
30db 32 79 fb			ld (debug_mark+2),a  
30de 18 03			jr .pastdmark  
30e0 ..			.dmark: db "-L1"  
30e3 f1			.pastdmark: pop af  
30e4			endm  
# End of macro DMARK
30e4						CALLMONITOR 
30e4 cd 01 15			call break_point_state  
30e7				endm  
# End of macro CALLMONITOR
30e7					endif 
30e7			 
30e7 ed 52			sbc hl, de 
30e9			 
30e9			 
30e9				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
30e9			 
30e9 20 26				jr nz, .mloopnotdone 
30eb			 
30eb e1				pop hl   ; get rid of saved I 
30ec				FORTH_LOOP_POP     ; get rid of limit 
30ec cd 88 1b			call macro_forth_loop_pop 
30ef				endm 
# End of macro FORTH_LOOP_POP
30ef			 
30ef				FORTH_RSP_POP     ; get rid of DO ptr 
30ef cd 63 1a			call macro_forth_rsp_pop 
30f2				endm 
# End of macro FORTH_RSP_POP
30f2			 
30f2			if DEBUG_FORTH_WORDS 
30f2						DMARK "-L>" 
30f2 f5				push af  
30f3 3a 07 31			ld a, (.dmark)  
30f6 32 77 fb			ld (debug_mark),a  
30f9 3a 08 31			ld a, (.dmark+1)  
30fc 32 78 fb			ld (debug_mark+1),a  
30ff 3a 09 31			ld a, (.dmark+2)  
3102 32 79 fb			ld (debug_mark+2),a  
3105 18 03			jr .pastdmark  
3107 ..			.dmark: db "-L>"  
310a f1			.pastdmark: pop af  
310b			endm  
# End of macro DMARK
310b				CALLMONITOR 
310b cd 01 15			call break_point_state  
310e				endm  
# End of macro CALLMONITOR
310e			endif 
310e			 
310e					NEXTW 
310e c3 8c 1c			jp macro_next 
3111				endm 
# End of macro NEXTW
3111				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3111			 
3111			.mloopnotdone: 
3111			 
3111 e1				pop hl    ; get I 
3112 2b				dec hl 
3113			 
3113			   	; save new I 
3113			 
3113			 
3113					; set I counter 
3113			 
3113 22 57 f1				ld (os_current_i), hl 
3116			 
3116					 
3116				FORTH_LOOP_NEXT 
3116 cd 4b 1b			call macro_forth_loop_next 
3119				endm 
# End of macro FORTH_LOOP_NEXT
3119			 
3119			 
3119					if DEBUG_FORTH_WORDS 
3119 eb						ex de,hl 
311a					endif 
311a			 
311a			;	; get DO ptr 
311a			; 
311a				FORTH_RSP_TOS 
311a cd 59 1a			call macro_forth_rsp_tos 
311d				endm 
# End of macro FORTH_RSP_TOS
311d			 
311d				;push hl 
311d			 
311d				; not going to DO any more 
311d				; get rid of the RSP pointer as DO will add it back in 
311d				;FORTH_RSP_POP 
311d				;pop hl 
311d			 
311d			 
311d 22 33 f1			ld (os_tok_ptr), hl 
3120					if DEBUG_FORTH_WORDS 
3120						DMARK "-L<" 
3120 f5				push af  
3121 3a 35 31			ld a, (.dmark)  
3124 32 77 fb			ld (debug_mark),a  
3127 3a 36 31			ld a, (.dmark+1)  
312a 32 78 fb			ld (debug_mark+1),a  
312d 3a 37 31			ld a, (.dmark+2)  
3130 32 79 fb			ld (debug_mark+2),a  
3133 18 03			jr .pastdmark  
3135 ..			.dmark: db "-L<"  
3138 f1			.pastdmark: pop af  
3139			endm  
# End of macro DMARK
3139					CALLMONITOR 
3139 cd 01 15			call break_point_state  
313c				endm  
# End of macro CALLMONITOR
313c				endif 
313c c3 1d 1d			jp exec1 
313f			 
313f					 
313f			 
313f			 
313f			 
313f				NEXTW 
313f c3 8c 1c			jp macro_next 
3142				endm 
# End of macro NEXTW
3142			 
3142			 
3142			 
3142			 
3142			.REPEAT: 
3142				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3142 71				db WORD_SYS_CORE+93             
3143 95 31			dw .UNTIL            
3145 06				db 5 + 1 
3146 .. 00			db "REPEAT",0              
314d				endm 
# End of macro CWHEAD
314d			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
314d			;  push pc to rsp stack past the REPEAT 
314d					if DEBUG_FORTH_WORDS_KEY 
314d						DMARK "REP" 
314d f5				push af  
314e 3a 62 31			ld a, (.dmark)  
3151 32 77 fb			ld (debug_mark),a  
3154 3a 63 31			ld a, (.dmark+1)  
3157 32 78 fb			ld (debug_mark+1),a  
315a 3a 64 31			ld a, (.dmark+2)  
315d 32 79 fb			ld (debug_mark+2),a  
3160 18 03			jr .pastdmark  
3162 ..			.dmark: db "REP"  
3165 f1			.pastdmark: pop af  
3166			endm  
# End of macro DMARK
3166						CALLMONITOR 
3166 cd 01 15			call break_point_state  
3169				endm  
# End of macro CALLMONITOR
3169					endif 
3169			 
3169 2a 33 f1				ld hl, (os_tok_ptr) 
316c 23					inc hl   ; R 
316d 23					inc hl  ; E 
316e 23					inc hl   ; P 
316f 23					inc hl   ; E 
3170 23					inc hl   ; A 
3171 23					inc hl   ; T 
3172 23					inc hl   ; zero 
3173					FORTH_RSP_NEXT 
3173 cd 42 1a			call macro_forth_rsp_next 
3176				endm 
# End of macro FORTH_RSP_NEXT
3176			 
3176			 
3176					if DEBUG_FORTH_WORDS 
3176						DMARK "REP" 
3176 f5				push af  
3177 3a 8b 31			ld a, (.dmark)  
317a 32 77 fb			ld (debug_mark),a  
317d 3a 8c 31			ld a, (.dmark+1)  
3180 32 78 fb			ld (debug_mark+1),a  
3183 3a 8d 31			ld a, (.dmark+2)  
3186 32 79 fb			ld (debug_mark+2),a  
3189 18 03			jr .pastdmark  
318b ..			.dmark: db "REP"  
318e f1			.pastdmark: pop af  
318f			endm  
# End of macro DMARK
318f						;pop bc    ; TODO BUG ?????? what is this for???? 
318f						CALLMONITOR 
318f cd 01 15			call break_point_state  
3192				endm  
# End of macro CALLMONITOR
3192					endif 
3192			 
3192					NEXTW 
3192 c3 8c 1c			jp macro_next 
3195				endm 
# End of macro NEXTW
3195			;	       NEXTW 
3195			 
3195			.UNTIL: 
3195				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3195 72				db WORD_SYS_CORE+94             
3196 2c 32			dw .ENDFLOW            
3198 06				db 5 + 1 
3199 .. 00			db "UNTIL",0              
319f				endm 
# End of macro CWHEAD
319f			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
319f			 
319f				; pop tos as check 
319f			 
319f				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
319f			 
319f				FORTH_DSP_VALUEHL 
319f cd 36 1b			call macro_dsp_valuehl 
31a2				endm 
# End of macro FORTH_DSP_VALUEHL
31a2			 
31a2					if DEBUG_FORTH_WORDS_KEY 
31a2						DMARK "UNT" 
31a2 f5				push af  
31a3 3a b7 31			ld a, (.dmark)  
31a6 32 77 fb			ld (debug_mark),a  
31a9 3a b8 31			ld a, (.dmark+1)  
31ac 32 78 fb			ld (debug_mark+1),a  
31af 3a b9 31			ld a, (.dmark+2)  
31b2 32 79 fb			ld (debug_mark+2),a  
31b5 18 03			jr .pastdmark  
31b7 ..			.dmark: db "UNT"  
31ba f1			.pastdmark: pop af  
31bb			endm  
# End of macro DMARK
31bb						CALLMONITOR 
31bb cd 01 15			call break_point_state  
31be				endm  
# End of macro CALLMONITOR
31be					endif 
31be			 
31be			;	push hl 
31be				FORTH_DSP_POP 
31be cd d2 1b			call macro_forth_dsp_pop 
31c1				endm 
# End of macro FORTH_DSP_POP
31c1			 
31c1			;	pop hl 
31c1			 
31c1				; test if true 
31c1			 
31c1 cd e8 0c			call ishlzero 
31c4			;	ld a,l 
31c4			;	add h 
31c4			; 
31c4			;	cp 0 
31c4			 
31c4 20 3e			jr nz, .untilnotdone 
31c6			 
31c6					if DEBUG_FORTH_WORDS 
31c6						DMARK "UNf" 
31c6 f5				push af  
31c7 3a db 31			ld a, (.dmark)  
31ca 32 77 fb			ld (debug_mark),a  
31cd 3a dc 31			ld a, (.dmark+1)  
31d0 32 78 fb			ld (debug_mark+1),a  
31d3 3a dd 31			ld a, (.dmark+2)  
31d6 32 79 fb			ld (debug_mark+2),a  
31d9 18 03			jr .pastdmark  
31db ..			.dmark: db "UNf"  
31de f1			.pastdmark: pop af  
31df			endm  
# End of macro DMARK
31df						CALLMONITOR 
31df cd 01 15			call break_point_state  
31e2				endm  
# End of macro CALLMONITOR
31e2					endif 
31e2			 
31e2			 
31e2			 
31e2				FORTH_RSP_POP     ; get rid of DO ptr 
31e2 cd 63 1a			call macro_forth_rsp_pop 
31e5				endm 
# End of macro FORTH_RSP_POP
31e5			 
31e5			if DEBUG_FORTH_WORDS 
31e5						DMARK "UN>" 
31e5 f5				push af  
31e6 3a fa 31			ld a, (.dmark)  
31e9 32 77 fb			ld (debug_mark),a  
31ec 3a fb 31			ld a, (.dmark+1)  
31ef 32 78 fb			ld (debug_mark+1),a  
31f2 3a fc 31			ld a, (.dmark+2)  
31f5 32 79 fb			ld (debug_mark+2),a  
31f8 18 03			jr .pastdmark  
31fa ..			.dmark: db "UN>"  
31fd f1			.pastdmark: pop af  
31fe			endm  
# End of macro DMARK
31fe				CALLMONITOR 
31fe cd 01 15			call break_point_state  
3201				endm  
# End of macro CALLMONITOR
3201			endif 
3201			 
3201					NEXTW 
3201 c3 8c 1c			jp macro_next 
3204				endm 
# End of macro NEXTW
3204				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3204			 
3204			.untilnotdone: 
3204			 
3204			 
3204			;	; get DO ptr 
3204			; 
3204				FORTH_RSP_TOS 
3204 cd 59 1a			call macro_forth_rsp_tos 
3207				endm 
# End of macro FORTH_RSP_TOS
3207			 
3207				;push hl 
3207			 
3207				; not going to DO any more 
3207				; get rid of the RSP pointer as DO will add it back in 
3207				;FORTH_RSP_POP 
3207				;pop hl 
3207			 
3207			 
3207 22 33 f1			ld (os_tok_ptr), hl 
320a					if DEBUG_FORTH_WORDS 
320a						DMARK "UN<" 
320a f5				push af  
320b 3a 1f 32			ld a, (.dmark)  
320e 32 77 fb			ld (debug_mark),a  
3211 3a 20 32			ld a, (.dmark+1)  
3214 32 78 fb			ld (debug_mark+1),a  
3217 3a 21 32			ld a, (.dmark+2)  
321a 32 79 fb			ld (debug_mark+2),a  
321d 18 03			jr .pastdmark  
321f ..			.dmark: db "UN<"  
3222 f1			.pastdmark: pop af  
3223			endm  
# End of macro DMARK
3223					CALLMONITOR 
3223 cd 01 15			call break_point_state  
3226				endm  
# End of macro CALLMONITOR
3226				endif 
3226 c3 1d 1d			jp exec1 
3229			 
3229					 
3229			 
3229			 
3229					NEXTW 
3229 c3 8c 1c			jp macro_next 
322c				endm 
# End of macro NEXTW
322c			 
322c			 
322c			.ENDFLOW: 
322c			 
322c			; eof 
322c			 
# End of file forth_words_flow.asm
322c			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
322c			include "forth_words_logic.asm" 
322c			 
322c			; | ## Logic Words 
322c			 
322c			.NOT: 
322c				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
322c 2d				db WORD_SYS_CORE+25             
322d 74 32			dw .IS            
322f 04				db 3 + 1 
3230 .. 00			db "NOT",0              
3234				endm 
# End of macro CWHEAD
3234			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3234					if DEBUG_FORTH_WORDS_KEY 
3234						DMARK "NOT" 
3234 f5				push af  
3235 3a 49 32			ld a, (.dmark)  
3238 32 77 fb			ld (debug_mark),a  
323b 3a 4a 32			ld a, (.dmark+1)  
323e 32 78 fb			ld (debug_mark+1),a  
3241 3a 4b 32			ld a, (.dmark+2)  
3244 32 79 fb			ld (debug_mark+2),a  
3247 18 03			jr .pastdmark  
3249 ..			.dmark: db "NOT"  
324c f1			.pastdmark: pop af  
324d			endm  
# End of macro DMARK
324d						CALLMONITOR 
324d cd 01 15			call break_point_state  
3250				endm  
# End of macro CALLMONITOR
3250					endif 
3250					FORTH_DSP 
3250 cd 1b 1b			call macro_forth_dsp 
3253				endm 
# End of macro FORTH_DSP
3253 7e					ld a,(hl)	; get type of value on TOS 
3254 fe 02				cp DS_TYPE_INUM  
3256 28 03				jr z, .noti 
3258					NEXTW 
3258 c3 8c 1c			jp macro_next 
325b				endm 
# End of macro NEXTW
325b			.noti:          FORTH_DSP_VALUEHL 
325b cd 36 1b			call macro_dsp_valuehl 
325e				endm 
# End of macro FORTH_DSP_VALUEHL
325e			;		push hl 
325e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
325e cd d2 1b			call macro_forth_dsp_pop 
3261				endm 
# End of macro FORTH_DSP_POP
3261			;		pop hl 
3261 3e 00				ld a,0 
3263 bd					cp l 
3264 28 04				jr z, .not2t 
3266 2e 00				ld l, 0 
3268 18 02				jr .notip 
326a			 
326a 2e ff		.not2t:		ld l, 255 
326c			 
326c 26 00		.notip:		ld h, 0	 
326e			 
326e cd 9b 1a				call forth_push_numhl 
3271					NEXTW 
3271 c3 8c 1c			jp macro_next 
3274				endm 
# End of macro NEXTW
3274			 
3274			.IS: 
3274				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3274 2d				db WORD_SYS_CORE+25             
3275 9a 32			dw .LZERO            
3277 03				db 2 + 1 
3278 .. 00			db "IS",0              
327b				endm 
# End of macro CWHEAD
327b			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
327b					if DEBUG_FORTH_WORDS_KEY 
327b						DMARK "IS." 
327b f5				push af  
327c 3a 90 32			ld a, (.dmark)  
327f 32 77 fb			ld (debug_mark),a  
3282 3a 91 32			ld a, (.dmark+1)  
3285 32 78 fb			ld (debug_mark+1),a  
3288 3a 92 32			ld a, (.dmark+2)  
328b 32 79 fb			ld (debug_mark+2),a  
328e 18 03			jr .pastdmark  
3290 ..			.dmark: db "IS."  
3293 f1			.pastdmark: pop af  
3294			endm  
# End of macro DMARK
3294						CALLMONITOR 
3294 cd 01 15			call break_point_state  
3297				endm  
# End of macro CALLMONITOR
3297					endif 
3297					NEXTW 
3297 c3 8c 1c			jp macro_next 
329a				endm 
# End of macro NEXTW
329a			.LZERO: 
329a				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
329a 2d				db WORD_SYS_CORE+25             
329b a4 32			dw .TZERO            
329d 03				db 2 + 1 
329e .. 00			db "0<",0              
32a1				endm 
# End of macro CWHEAD
32a1			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
32a1					NEXTW 
32a1 c3 8c 1c			jp macro_next 
32a4				endm 
# End of macro NEXTW
32a4			.TZERO: 
32a4				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
32a4 2e				db WORD_SYS_CORE+26             
32a5 eb 32			dw .LESS            
32a7 03				db 2 + 1 
32a8 .. 00			db "0=",0              
32ab				endm 
# End of macro CWHEAD
32ab			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
32ab				; TODO add floating point number detection 
32ab					;v5 FORTH_DSP_VALUE 
32ab					if DEBUG_FORTH_WORDS_KEY 
32ab						DMARK "0=." 
32ab f5				push af  
32ac 3a c0 32			ld a, (.dmark)  
32af 32 77 fb			ld (debug_mark),a  
32b2 3a c1 32			ld a, (.dmark+1)  
32b5 32 78 fb			ld (debug_mark+1),a  
32b8 3a c2 32			ld a, (.dmark+2)  
32bb 32 79 fb			ld (debug_mark+2),a  
32be 18 03			jr .pastdmark  
32c0 ..			.dmark: db "0=."  
32c3 f1			.pastdmark: pop af  
32c4			endm  
# End of macro DMARK
32c4						CALLMONITOR 
32c4 cd 01 15			call break_point_state  
32c7				endm  
# End of macro CALLMONITOR
32c7					endif 
32c7					FORTH_DSP 
32c7 cd 1b 1b			call macro_forth_dsp 
32ca				endm 
# End of macro FORTH_DSP
32ca 7e					ld a,(hl)	; get type of value on TOS 
32cb fe 02				cp DS_TYPE_INUM  
32cd 28 00				jr z, .tz_inum 
32cf			 
32cf				if FORTH_ENABLE_FLOATMATH 
32cf					jr .tz_done 
32cf			 
32cf				endif 
32cf					 
32cf			 
32cf			.tz_inum: 
32cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32cf cd 36 1b			call macro_dsp_valuehl 
32d2				endm 
# End of macro FORTH_DSP_VALUEHL
32d2			 
32d2			;		push hl 
32d2			 
32d2					; destroy value TOS 
32d2			 
32d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32d2 cd d2 1b			call macro_forth_dsp_pop 
32d5				endm 
# End of macro FORTH_DSP_POP
32d5			 
32d5			;		pop hl 
32d5			 
32d5 3e 00				ld a,0 
32d7			 
32d7 bd					cp l 
32d8 20 08				jr nz, .tz_notzero 
32da			 
32da bc					cp h 
32db			 
32db 20 05				jr nz, .tz_notzero 
32dd			 
32dd			 
32dd 21 01 00				ld hl, FORTH_TRUE 
32e0 18 03				jr .tz_done 
32e2			 
32e2 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
32e5			 
32e5					; push value back onto stack for another op etc 
32e5			 
32e5			.tz_done: 
32e5 cd 9b 1a				call forth_push_numhl 
32e8			 
32e8					NEXTW 
32e8 c3 8c 1c			jp macro_next 
32eb				endm 
# End of macro NEXTW
32eb			.LESS: 
32eb				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
32eb 2f				db WORD_SYS_CORE+27             
32ec 54 33			dw .GT            
32ee 02				db 1 + 1 
32ef .. 00			db "<",0              
32f1				endm 
# End of macro CWHEAD
32f1			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
32f1				; TODO add floating point number detection 
32f1					if DEBUG_FORTH_WORDS_KEY 
32f1						DMARK "LES" 
32f1 f5				push af  
32f2 3a 06 33			ld a, (.dmark)  
32f5 32 77 fb			ld (debug_mark),a  
32f8 3a 07 33			ld a, (.dmark+1)  
32fb 32 78 fb			ld (debug_mark+1),a  
32fe 3a 08 33			ld a, (.dmark+2)  
3301 32 79 fb			ld (debug_mark+2),a  
3304 18 03			jr .pastdmark  
3306 ..			.dmark: db "LES"  
3309 f1			.pastdmark: pop af  
330a			endm  
# End of macro DMARK
330a						CALLMONITOR 
330a cd 01 15			call break_point_state  
330d				endm  
# End of macro CALLMONITOR
330d					endif 
330d					FORTH_DSP 
330d cd 1b 1b			call macro_forth_dsp 
3310				endm 
# End of macro FORTH_DSP
3310					;v5 FORTH_DSP_VALUE 
3310 7e					ld a,(hl)	; get type of value on TOS 
3311 fe 02				cp DS_TYPE_INUM  
3313 28 00				jr z, .less_inum 
3315			 
3315				if FORTH_ENABLE_FLOATMATH 
3315					jr .less_done 
3315			 
3315				endif 
3315					 
3315			 
3315			.less_inum: 
3315					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3315 cd 36 1b			call macro_dsp_valuehl 
3318				endm 
# End of macro FORTH_DSP_VALUEHL
3318			 
3318 e5					push hl  ; u2 
3319			 
3319					; destroy value TOS 
3319			 
3319					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3319 cd d2 1b			call macro_forth_dsp_pop 
331c				endm 
# End of macro FORTH_DSP_POP
331c			 
331c			 
331c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
331c cd 36 1b			call macro_dsp_valuehl 
331f				endm 
# End of macro FORTH_DSP_VALUEHL
331f			 
331f e5					push hl    ; u1 
3320			 
3320					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3320 cd d2 1b			call macro_forth_dsp_pop 
3323				endm 
# End of macro FORTH_DSP_POP
3323			 
3323			 
3323 b7			 or a      ;clear carry flag 
3324 01 00 00		 ld bc, FORTH_FALSE 
3327 e1			  pop hl    ; u1 
3328 d1			  pop de    ; u2 
3329 ed 52		  sbc hl,de 
332b 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
332d			 
332d 01 01 00		 ld bc, FORTH_TRUE 
3330			.lscont:  
3330 c5					push bc 
3331 e1					pop hl 
3332			 
3332					if DEBUG_FORTH_WORDS 
3332						DMARK "LT1" 
3332 f5				push af  
3333 3a 47 33			ld a, (.dmark)  
3336 32 77 fb			ld (debug_mark),a  
3339 3a 48 33			ld a, (.dmark+1)  
333c 32 78 fb			ld (debug_mark+1),a  
333f 3a 49 33			ld a, (.dmark+2)  
3342 32 79 fb			ld (debug_mark+2),a  
3345 18 03			jr .pastdmark  
3347 ..			.dmark: db "LT1"  
334a f1			.pastdmark: pop af  
334b			endm  
# End of macro DMARK
334b						CALLMONITOR 
334b cd 01 15			call break_point_state  
334e				endm  
# End of macro CALLMONITOR
334e					endif 
334e cd 9b 1a				call forth_push_numhl 
3351			 
3351					NEXTW 
3351 c3 8c 1c			jp macro_next 
3354				endm 
# End of macro NEXTW
3354			.GT: 
3354				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3354 30				db WORD_SYS_CORE+28             
3355 bd 33			dw .EQUAL            
3357 02				db 1 + 1 
3358 .. 00			db ">",0              
335a				endm 
# End of macro CWHEAD
335a			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
335a				; TODO add floating point number detection 
335a					if DEBUG_FORTH_WORDS_KEY 
335a						DMARK "GRT" 
335a f5				push af  
335b 3a 6f 33			ld a, (.dmark)  
335e 32 77 fb			ld (debug_mark),a  
3361 3a 70 33			ld a, (.dmark+1)  
3364 32 78 fb			ld (debug_mark+1),a  
3367 3a 71 33			ld a, (.dmark+2)  
336a 32 79 fb			ld (debug_mark+2),a  
336d 18 03			jr .pastdmark  
336f ..			.dmark: db "GRT"  
3372 f1			.pastdmark: pop af  
3373			endm  
# End of macro DMARK
3373						CALLMONITOR 
3373 cd 01 15			call break_point_state  
3376				endm  
# End of macro CALLMONITOR
3376					endif 
3376					FORTH_DSP 
3376 cd 1b 1b			call macro_forth_dsp 
3379				endm 
# End of macro FORTH_DSP
3379					;FORTH_DSP_VALUE 
3379 7e					ld a,(hl)	; get type of value on TOS 
337a fe 02				cp DS_TYPE_INUM  
337c 28 00				jr z, .gt_inum 
337e			 
337e				if FORTH_ENABLE_FLOATMATH 
337e					jr .gt_done 
337e			 
337e				endif 
337e					 
337e			 
337e			.gt_inum: 
337e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
337e cd 36 1b			call macro_dsp_valuehl 
3381				endm 
# End of macro FORTH_DSP_VALUEHL
3381			 
3381 e5					push hl  ; u2 
3382			 
3382					; destroy value TOS 
3382			 
3382					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3382 cd d2 1b			call macro_forth_dsp_pop 
3385				endm 
# End of macro FORTH_DSP_POP
3385			 
3385			 
3385					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3385 cd 36 1b			call macro_dsp_valuehl 
3388				endm 
# End of macro FORTH_DSP_VALUEHL
3388			 
3388 e5					push hl    ; u1 
3389			 
3389					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3389 cd d2 1b			call macro_forth_dsp_pop 
338c				endm 
# End of macro FORTH_DSP_POP
338c			 
338c			 
338c b7			 or a      ;clear carry flag 
338d 01 00 00		 ld bc, FORTH_FALSE 
3390 e1			  pop hl    ; u1 
3391 d1			  pop de    ; u2 
3392 ed 52		  sbc hl,de 
3394 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3396			 
3396 01 01 00		 ld bc, FORTH_TRUE 
3399			.gtcont:  
3399 c5					push bc 
339a e1					pop hl 
339b			 
339b					if DEBUG_FORTH_WORDS 
339b						DMARK "GT1" 
339b f5				push af  
339c 3a b0 33			ld a, (.dmark)  
339f 32 77 fb			ld (debug_mark),a  
33a2 3a b1 33			ld a, (.dmark+1)  
33a5 32 78 fb			ld (debug_mark+1),a  
33a8 3a b2 33			ld a, (.dmark+2)  
33ab 32 79 fb			ld (debug_mark+2),a  
33ae 18 03			jr .pastdmark  
33b0 ..			.dmark: db "GT1"  
33b3 f1			.pastdmark: pop af  
33b4			endm  
# End of macro DMARK
33b4						CALLMONITOR 
33b4 cd 01 15			call break_point_state  
33b7				endm  
# End of macro CALLMONITOR
33b7					endif 
33b7 cd 9b 1a				call forth_push_numhl 
33ba			 
33ba					NEXTW 
33ba c3 8c 1c			jp macro_next 
33bd				endm 
# End of macro NEXTW
33bd			.EQUAL: 
33bd				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
33bd 31				db WORD_SYS_CORE+29             
33be 28 34			dw .ENDLOGIC            
33c0 02				db 1 + 1 
33c1 .. 00			db "=",0              
33c3				endm 
# End of macro CWHEAD
33c3			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
33c3				; TODO add floating point number detection 
33c3					if DEBUG_FORTH_WORDS_KEY 
33c3						DMARK "EQ." 
33c3 f5				push af  
33c4 3a d8 33			ld a, (.dmark)  
33c7 32 77 fb			ld (debug_mark),a  
33ca 3a d9 33			ld a, (.dmark+1)  
33cd 32 78 fb			ld (debug_mark+1),a  
33d0 3a da 33			ld a, (.dmark+2)  
33d3 32 79 fb			ld (debug_mark+2),a  
33d6 18 03			jr .pastdmark  
33d8 ..			.dmark: db "EQ."  
33db f1			.pastdmark: pop af  
33dc			endm  
# End of macro DMARK
33dc						CALLMONITOR 
33dc cd 01 15			call break_point_state  
33df				endm  
# End of macro CALLMONITOR
33df					endif 
33df					FORTH_DSP 
33df cd 1b 1b			call macro_forth_dsp 
33e2				endm 
# End of macro FORTH_DSP
33e2					;v5 FORTH_DSP_VALUE 
33e2 7e					ld a,(hl)	; get type of value on TOS 
33e3 fe 02				cp DS_TYPE_INUM  
33e5 28 00				jr z, .eq_inum 
33e7			 
33e7				if FORTH_ENABLE_FLOATMATH 
33e7					jr .eq_done 
33e7			 
33e7				endif 
33e7					 
33e7			 
33e7			.eq_inum: 
33e7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33e7 cd 36 1b			call macro_dsp_valuehl 
33ea				endm 
# End of macro FORTH_DSP_VALUEHL
33ea			 
33ea e5					push hl 
33eb			 
33eb					; destroy value TOS 
33eb			 
33eb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33eb cd d2 1b			call macro_forth_dsp_pop 
33ee				endm 
# End of macro FORTH_DSP_POP
33ee			 
33ee			 
33ee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33ee cd 36 1b			call macro_dsp_valuehl 
33f1				endm 
# End of macro FORTH_DSP_VALUEHL
33f1			 
33f1					; one value on hl get other one back 
33f1			 
33f1 e5					push hl 
33f2			 
33f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33f2 cd d2 1b			call macro_forth_dsp_pop 
33f5				endm 
# End of macro FORTH_DSP_POP
33f5			 
33f5 0e 00				ld c, FORTH_FALSE 
33f7			 
33f7 e1					pop hl 
33f8 d1					pop de 
33f9			 
33f9 7b					ld a, e 
33fa bd					cp l 
33fb			 
33fb 20 06				jr nz, .eq_done 
33fd			 
33fd 7a					ld a, d 
33fe bc					cp h 
33ff			 
33ff 20 02				jr nz, .eq_done 
3401			 
3401 0e 01				ld c, FORTH_TRUE 
3403					 
3403			 
3403			 
3403			.eq_done: 
3403			 
3403					; TODO push value back onto stack for another op etc 
3403			 
3403 26 00				ld h, 0 
3405 69					ld l, c 
3406					if DEBUG_FORTH_WORDS 
3406						DMARK "EQ1" 
3406 f5				push af  
3407 3a 1b 34			ld a, (.dmark)  
340a 32 77 fb			ld (debug_mark),a  
340d 3a 1c 34			ld a, (.dmark+1)  
3410 32 78 fb			ld (debug_mark+1),a  
3413 3a 1d 34			ld a, (.dmark+2)  
3416 32 79 fb			ld (debug_mark+2),a  
3419 18 03			jr .pastdmark  
341b ..			.dmark: db "EQ1"  
341e f1			.pastdmark: pop af  
341f			endm  
# End of macro DMARK
341f						CALLMONITOR 
341f cd 01 15			call break_point_state  
3422				endm  
# End of macro CALLMONITOR
3422					endif 
3422 cd 9b 1a				call forth_push_numhl 
3425			 
3425					NEXTW 
3425 c3 8c 1c			jp macro_next 
3428				endm 
# End of macro NEXTW
3428			 
3428			 
3428			.ENDLOGIC: 
3428			; eof 
3428			 
3428			 
# End of file forth_words_logic.asm
3428			include "forth_words_maths.asm" 
3428			 
3428			; | ## Maths Words 
3428			 
3428			.PLUS:	 
3428				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3428 15				db WORD_SYS_CORE+1             
3429 6a 34			dw .NEG            
342b 02				db 1 + 1 
342c .. 00			db "+",0              
342e				endm 
# End of macro CWHEAD
342e			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
342e					if DEBUG_FORTH_WORDS_KEY 
342e						DMARK "PLU" 
342e f5				push af  
342f 3a 43 34			ld a, (.dmark)  
3432 32 77 fb			ld (debug_mark),a  
3435 3a 44 34			ld a, (.dmark+1)  
3438 32 78 fb			ld (debug_mark+1),a  
343b 3a 45 34			ld a, (.dmark+2)  
343e 32 79 fb			ld (debug_mark+2),a  
3441 18 03			jr .pastdmark  
3443 ..			.dmark: db "PLU"  
3446 f1			.pastdmark: pop af  
3447			endm  
# End of macro DMARK
3447						CALLMONITOR 
3447 cd 01 15			call break_point_state  
344a				endm  
# End of macro CALLMONITOR
344a					endif 
344a					; add top two values and push back result 
344a			 
344a					;for v5 FORTH_DSP_VALUE 
344a					FORTH_DSP 
344a cd 1b 1b			call macro_forth_dsp 
344d				endm 
# End of macro FORTH_DSP
344d 7e					ld a,(hl)	; get type of value on TOS 
344e fe 02				cp DS_TYPE_INUM  
3450 28 03				jr z, .dot_inum 
3452			 
3452					NEXTW 
3452 c3 8c 1c			jp macro_next 
3455				endm 
# End of macro NEXTW
3455			 
3455			; float maths 
3455			 
3455				if FORTH_ENABLE_FLOATMATH 
3455						inc hl      ; now at start of numeric as string 
3455			 
3455					if DEBUG_FORTH_MATHS 
3455						DMARK "ADD" 
3455				CALLMONITOR 
3455					endif 
3455			 
3455					;ld ix, hl 
3455					call CON 
3455			 
3455			 
3455					push hl 
3455					 
3455					 
3455			 
3455						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3455			 
3455					; get next number 
3455			 
3455						FORTH_DSP_VALUE 
3455			 
3455						inc hl      ; now at start of numeric as string 
3455			 
3455					;ld ix, hl 
3455					call CON 
3455			 
3455					push hl 
3455			 
3455			 
3455						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3455			 
3455						; TODO do add 
3455			 
3455						call IADD 
3455			 
3455						; TODO get result back as ascii 
3455			 
3455						; TODO push result  
3455			 
3455			 
3455			 
3455						jr .dot_done 
3455				endif 
3455			 
3455			.dot_inum: 
3455			 
3455			 
3455					if DEBUG_FORTH_DOT 
3455						DMARK "+IT" 
3455				CALLMONITOR 
3455					endif 
3455			 
3455					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3455 cd 36 1b			call macro_dsp_valuehl 
3458				endm 
# End of macro FORTH_DSP_VALUEHL
3458			 
3458				; TODO add floating point number detection 
3458			 
3458 e5					push hl 
3459			 
3459					; destroy value TOS 
3459			 
3459					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3459 cd d2 1b			call macro_forth_dsp_pop 
345c				endm 
# End of macro FORTH_DSP_POP
345c			 
345c			 
345c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
345c cd 36 1b			call macro_dsp_valuehl 
345f				endm 
# End of macro FORTH_DSP_VALUEHL
345f			 
345f					; one value on hl get other one back 
345f			 
345f d1					pop de 
3460			 
3460					; do the add 
3460			 
3460 19					add hl,de 
3461			 
3461					; save it 
3461			 
3461			;		push hl	 
3461			 
3461					; 
3461			 
3461					; destroy value TOS 
3461			 
3461					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3461 cd d2 1b			call macro_forth_dsp_pop 
3464				endm 
# End of macro FORTH_DSP_POP
3464			 
3464					; TODO push value back onto stack for another op etc 
3464			 
3464			;		pop hl 
3464			 
3464			.dot_done: 
3464 cd 9b 1a				call forth_push_numhl 
3467			 
3467					NEXTW 
3467 c3 8c 1c			jp macro_next 
346a				endm 
# End of macro NEXTW
346a			.NEG: 
346a			 
346a				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
346a 17				db WORD_SYS_CORE+3             
346b ad 34			dw .DIV            
346d 02				db 1 + 1 
346e .. 00			db "-",0              
3470				endm 
# End of macro CWHEAD
3470			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3470					if DEBUG_FORTH_WORDS_KEY 
3470						DMARK "SUB" 
3470 f5				push af  
3471 3a 85 34			ld a, (.dmark)  
3474 32 77 fb			ld (debug_mark),a  
3477 3a 86 34			ld a, (.dmark+1)  
347a 32 78 fb			ld (debug_mark+1),a  
347d 3a 87 34			ld a, (.dmark+2)  
3480 32 79 fb			ld (debug_mark+2),a  
3483 18 03			jr .pastdmark  
3485 ..			.dmark: db "SUB"  
3488 f1			.pastdmark: pop af  
3489			endm  
# End of macro DMARK
3489						CALLMONITOR 
3489 cd 01 15			call break_point_state  
348c				endm  
# End of macro CALLMONITOR
348c					endif 
348c			 
348c			 
348c				; TODO add floating point number detection 
348c					; v5 FORTH_DSP_VALUE 
348c					FORTH_DSP 
348c cd 1b 1b			call macro_forth_dsp 
348f				endm 
# End of macro FORTH_DSP
348f 7e					ld a,(hl)	; get type of value on TOS 
3490 fe 02				cp DS_TYPE_INUM  
3492 28 03				jr z, .neg_inum 
3494			 
3494					NEXTW 
3494 c3 8c 1c			jp macro_next 
3497				endm 
# End of macro NEXTW
3497			 
3497			; float maths 
3497			 
3497				if FORTH_ENABLE_FLOATMATH 
3497					jr .neg_done 
3497			 
3497				endif 
3497					 
3497			 
3497			.neg_inum: 
3497					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3497 cd 36 1b			call macro_dsp_valuehl 
349a				endm 
# End of macro FORTH_DSP_VALUEHL
349a			 
349a e5					push hl 
349b			 
349b					; destroy value TOS 
349b			 
349b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
349b cd d2 1b			call macro_forth_dsp_pop 
349e				endm 
# End of macro FORTH_DSP_POP
349e			 
349e			 
349e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
349e cd 36 1b			call macro_dsp_valuehl 
34a1				endm 
# End of macro FORTH_DSP_VALUEHL
34a1			 
34a1					; one value on hl get other one back 
34a1			 
34a1 d1					pop de 
34a2			 
34a2					; do the sub 
34a2			;		ex de, hl 
34a2			 
34a2 ed 52				sbc hl,de 
34a4			 
34a4					; save it 
34a4			 
34a4			;		push hl	 
34a4			 
34a4					; 
34a4			 
34a4					; destroy value TOS 
34a4			 
34a4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34a4 cd d2 1b			call macro_forth_dsp_pop 
34a7				endm 
# End of macro FORTH_DSP_POP
34a7			 
34a7					; TODO push value back onto stack for another op etc 
34a7			 
34a7			;		pop hl 
34a7			 
34a7 cd 9b 1a				call forth_push_numhl 
34aa			.neg_done: 
34aa			 
34aa					NEXTW 
34aa c3 8c 1c			jp macro_next 
34ad				endm 
# End of macro NEXTW
34ad			.DIV: 
34ad				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
34ad 18				db WORD_SYS_CORE+4             
34ae fa 34			dw .MUL            
34b0 02				db 1 + 1 
34b1 .. 00			db "/",0              
34b3				endm 
# End of macro CWHEAD
34b3			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
34b3					if DEBUG_FORTH_WORDS_KEY 
34b3						DMARK "DIV" 
34b3 f5				push af  
34b4 3a c8 34			ld a, (.dmark)  
34b7 32 77 fb			ld (debug_mark),a  
34ba 3a c9 34			ld a, (.dmark+1)  
34bd 32 78 fb			ld (debug_mark+1),a  
34c0 3a ca 34			ld a, (.dmark+2)  
34c3 32 79 fb			ld (debug_mark+2),a  
34c6 18 03			jr .pastdmark  
34c8 ..			.dmark: db "DIV"  
34cb f1			.pastdmark: pop af  
34cc			endm  
# End of macro DMARK
34cc						CALLMONITOR 
34cc cd 01 15			call break_point_state  
34cf				endm  
# End of macro CALLMONITOR
34cf					endif 
34cf				; TODO add floating point number detection 
34cf					; v5 FORTH_DSP_VALUE 
34cf					FORTH_DSP 
34cf cd 1b 1b			call macro_forth_dsp 
34d2				endm 
# End of macro FORTH_DSP
34d2 7e					ld a,(hl)	; get type of value on TOS 
34d3 fe 02				cp DS_TYPE_INUM  
34d5 28 03				jr z, .div_inum 
34d7			 
34d7				if FORTH_ENABLE_FLOATMATH 
34d7					jr .div_done 
34d7			 
34d7				endif 
34d7					NEXTW 
34d7 c3 8c 1c			jp macro_next 
34da				endm 
# End of macro NEXTW
34da			.div_inum: 
34da			 
34da					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34da cd 36 1b			call macro_dsp_valuehl 
34dd				endm 
# End of macro FORTH_DSP_VALUEHL
34dd			 
34dd e5					push hl    ; to go to bc 
34de			 
34de					; destroy value TOS 
34de			 
34de					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34de cd d2 1b			call macro_forth_dsp_pop 
34e1				endm 
# End of macro FORTH_DSP_POP
34e1			 
34e1			 
34e1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34e1 cd 36 1b			call macro_dsp_valuehl 
34e4				endm 
# End of macro FORTH_DSP_VALUEHL
34e4			 
34e4					; hl to go to de 
34e4			 
34e4 e5					push hl 
34e5			 
34e5 c1					pop bc 
34e6 d1					pop de		 
34e7			 
34e7			 
34e7					if DEBUG_FORTH_MATHS 
34e7						DMARK "DIV" 
34e7				CALLMONITOR 
34e7					endif 
34e7					; one value on hl but move to a get other one back 
34e7			 
34e7			        
34e7 cd 1c 0c			call Div16 
34ea			 
34ea			;	push af	 
34ea e5				push hl 
34eb c5				push bc 
34ec			 
34ec					if DEBUG_FORTH_MATHS 
34ec						DMARK "DI1" 
34ec				CALLMONITOR 
34ec					endif 
34ec			 
34ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34ec cd d2 1b			call macro_forth_dsp_pop 
34ef				endm 
# End of macro FORTH_DSP_POP
34ef			 
34ef			 
34ef			 
34ef e1					pop hl    ; result 
34f0			 
34f0 cd 9b 1a				call forth_push_numhl 
34f3			 
34f3 e1					pop hl    ; reminder 
34f4			;		ld h,0 
34f4			;		ld l,d 
34f4			 
34f4 cd 9b 1a				call forth_push_numhl 
34f7			.div_done: 
34f7					NEXTW 
34f7 c3 8c 1c			jp macro_next 
34fa				endm 
# End of macro NEXTW
34fa			.MUL: 
34fa				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
34fa 19				db WORD_SYS_CORE+5             
34fb 3f 35			dw .MIN            
34fd 02				db 1 + 1 
34fe .. 00			db "*",0              
3500				endm 
# End of macro CWHEAD
3500			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3500				; TODO add floating point number detection 
3500					if DEBUG_FORTH_WORDS_KEY 
3500						DMARK "MUL" 
3500 f5				push af  
3501 3a 15 35			ld a, (.dmark)  
3504 32 77 fb			ld (debug_mark),a  
3507 3a 16 35			ld a, (.dmark+1)  
350a 32 78 fb			ld (debug_mark+1),a  
350d 3a 17 35			ld a, (.dmark+2)  
3510 32 79 fb			ld (debug_mark+2),a  
3513 18 03			jr .pastdmark  
3515 ..			.dmark: db "MUL"  
3518 f1			.pastdmark: pop af  
3519			endm  
# End of macro DMARK
3519						CALLMONITOR 
3519 cd 01 15			call break_point_state  
351c				endm  
# End of macro CALLMONITOR
351c					endif 
351c					FORTH_DSP 
351c cd 1b 1b			call macro_forth_dsp 
351f				endm 
# End of macro FORTH_DSP
351f					; v5 FORTH_DSP_VALUE 
351f 7e					ld a,(hl)	; get type of value on TOS 
3520 fe 02				cp DS_TYPE_INUM  
3522 28 03				jr z, .mul_inum 
3524			 
3524				if FORTH_ENABLE_FLOATMATH 
3524					jr .mul_done 
3524			 
3524				endif 
3524			 
3524					NEXTW 
3524 c3 8c 1c			jp macro_next 
3527				endm 
# End of macro NEXTW
3527			.mul_inum:	 
3527			 
3527					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3527 cd 36 1b			call macro_dsp_valuehl 
352a				endm 
# End of macro FORTH_DSP_VALUEHL
352a			 
352a e5					push hl 
352b			 
352b					; destroy value TOS 
352b			 
352b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
352b cd d2 1b			call macro_forth_dsp_pop 
352e				endm 
# End of macro FORTH_DSP_POP
352e			 
352e			 
352e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
352e cd 36 1b			call macro_dsp_valuehl 
3531				endm 
# End of macro FORTH_DSP_VALUEHL
3531			 
3531					; one value on hl but move to a get other one back 
3531			 
3531 7d					ld a, l 
3532			 
3532 d1					pop de 
3533			 
3533					; do the mull 
3533			;		ex de, hl 
3533			 
3533 cd 42 0c				call Mult16 
3536					; save it 
3536			 
3536			;		push hl	 
3536			 
3536					; 
3536			 
3536					; destroy value TOS 
3536			 
3536					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3536 cd d2 1b			call macro_forth_dsp_pop 
3539				endm 
# End of macro FORTH_DSP_POP
3539			 
3539					; TODO push value back onto stack for another op etc 
3539			 
3539			;		pop hl 
3539			 
3539 cd 9b 1a				call forth_push_numhl 
353c			 
353c			.mul_done: 
353c					NEXTW 
353c c3 8c 1c			jp macro_next 
353f				endm 
# End of macro NEXTW
353f			 
353f			 
353f			 
353f			 
353f			.MIN: 
353f				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
353f 49				db WORD_SYS_CORE+53             
3540 c0 35			dw .MAX            
3542 04				db 3 + 1 
3543 .. 00			db "MIN",0              
3547				endm 
# End of macro CWHEAD
3547			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3547					if DEBUG_FORTH_WORDS_KEY 
3547						DMARK "MIN" 
3547 f5				push af  
3548 3a 5c 35			ld a, (.dmark)  
354b 32 77 fb			ld (debug_mark),a  
354e 3a 5d 35			ld a, (.dmark+1)  
3551 32 78 fb			ld (debug_mark+1),a  
3554 3a 5e 35			ld a, (.dmark+2)  
3557 32 79 fb			ld (debug_mark+2),a  
355a 18 03			jr .pastdmark  
355c ..			.dmark: db "MIN"  
355f f1			.pastdmark: pop af  
3560			endm  
# End of macro DMARK
3560						CALLMONITOR 
3560 cd 01 15			call break_point_state  
3563				endm  
# End of macro CALLMONITOR
3563					endif 
3563					; get u2 
3563			 
3563					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3563 cd 36 1b			call macro_dsp_valuehl 
3566				endm 
# End of macro FORTH_DSP_VALUEHL
3566			 
3566 e5					push hl   ; u2 
3567			 
3567					; destroy value TOS 
3567			 
3567					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3567 cd d2 1b			call macro_forth_dsp_pop 
356a				endm 
# End of macro FORTH_DSP_POP
356a			 
356a					; get u1 
356a			 
356a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
356a cd 36 1b			call macro_dsp_valuehl 
356d				endm 
# End of macro FORTH_DSP_VALUEHL
356d			 
356d e5					push hl  ; u1 
356e			 
356e					; destroy value TOS 
356e			 
356e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
356e cd d2 1b			call macro_forth_dsp_pop 
3571				endm 
# End of macro FORTH_DSP_POP
3571			 
3571 b7			 or a      ;clear carry flag 
3572 e1			  pop hl    ; u1 
3573 d1			  pop de    ; u2 
3574 e5				push hl   ; saved in case hl is lowest 
3575 ed 52		  sbc hl,de 
3577 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3579			 
3579 e1				pop hl 
357a					if DEBUG_FORTH_WORDS 
357a						DMARK "MIN" 
357a f5				push af  
357b 3a 8f 35			ld a, (.dmark)  
357e 32 77 fb			ld (debug_mark),a  
3581 3a 90 35			ld a, (.dmark+1)  
3584 32 78 fb			ld (debug_mark+1),a  
3587 3a 91 35			ld a, (.dmark+2)  
358a 32 79 fb			ld (debug_mark+2),a  
358d 18 03			jr .pastdmark  
358f ..			.dmark: db "MIN"  
3592 f1			.pastdmark: pop af  
3593			endm  
# End of macro DMARK
3593						CALLMONITOR 
3593 cd 01 15			call break_point_state  
3596				endm  
# End of macro CALLMONITOR
3596					endif 
3596 cd 9b 1a				call forth_push_numhl 
3599			 
3599				       NEXTW 
3599 c3 8c 1c			jp macro_next 
359c				endm 
# End of macro NEXTW
359c			 
359c			.mincont:  
359c c1				pop bc   ; tidy up 
359d eb				ex de , hl  
359e					if DEBUG_FORTH_WORDS 
359e						DMARK "MI1" 
359e f5				push af  
359f 3a b3 35			ld a, (.dmark)  
35a2 32 77 fb			ld (debug_mark),a  
35a5 3a b4 35			ld a, (.dmark+1)  
35a8 32 78 fb			ld (debug_mark+1),a  
35ab 3a b5 35			ld a, (.dmark+2)  
35ae 32 79 fb			ld (debug_mark+2),a  
35b1 18 03			jr .pastdmark  
35b3 ..			.dmark: db "MI1"  
35b6 f1			.pastdmark: pop af  
35b7			endm  
# End of macro DMARK
35b7						CALLMONITOR 
35b7 cd 01 15			call break_point_state  
35ba				endm  
# End of macro CALLMONITOR
35ba					endif 
35ba cd 9b 1a				call forth_push_numhl 
35bd			 
35bd				       NEXTW 
35bd c3 8c 1c			jp macro_next 
35c0				endm 
# End of macro NEXTW
35c0			.MAX: 
35c0				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
35c0 4a				db WORD_SYS_CORE+54             
35c1 41 36			dw .RND16            
35c3 04				db 3 + 1 
35c4 .. 00			db "MAX",0              
35c8				endm 
# End of macro CWHEAD
35c8			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
35c8					if DEBUG_FORTH_WORDS_KEY 
35c8						DMARK "MAX" 
35c8 f5				push af  
35c9 3a dd 35			ld a, (.dmark)  
35cc 32 77 fb			ld (debug_mark),a  
35cf 3a de 35			ld a, (.dmark+1)  
35d2 32 78 fb			ld (debug_mark+1),a  
35d5 3a df 35			ld a, (.dmark+2)  
35d8 32 79 fb			ld (debug_mark+2),a  
35db 18 03			jr .pastdmark  
35dd ..			.dmark: db "MAX"  
35e0 f1			.pastdmark: pop af  
35e1			endm  
# End of macro DMARK
35e1						CALLMONITOR 
35e1 cd 01 15			call break_point_state  
35e4				endm  
# End of macro CALLMONITOR
35e4					endif 
35e4					; get u2 
35e4			 
35e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35e4 cd 36 1b			call macro_dsp_valuehl 
35e7				endm 
# End of macro FORTH_DSP_VALUEHL
35e7			 
35e7 e5					push hl   ; u2 
35e8			 
35e8					; destroy value TOS 
35e8			 
35e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35e8 cd d2 1b			call macro_forth_dsp_pop 
35eb				endm 
# End of macro FORTH_DSP_POP
35eb			 
35eb					; get u1 
35eb			 
35eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35eb cd 36 1b			call macro_dsp_valuehl 
35ee				endm 
# End of macro FORTH_DSP_VALUEHL
35ee			 
35ee e5					push hl  ; u1 
35ef			 
35ef					; destroy value TOS 
35ef			 
35ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35ef cd d2 1b			call macro_forth_dsp_pop 
35f2				endm 
# End of macro FORTH_DSP_POP
35f2			 
35f2 b7			 or a      ;clear carry flag 
35f3 e1			  pop hl    ; u1 
35f4 d1			  pop de    ; u2 
35f5 e5				push hl   ; saved in case hl is lowest 
35f6 ed 52		  sbc hl,de 
35f8 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
35fa			 
35fa e1				pop hl 
35fb					if DEBUG_FORTH_WORDS 
35fb						DMARK "MAX" 
35fb f5				push af  
35fc 3a 10 36			ld a, (.dmark)  
35ff 32 77 fb			ld (debug_mark),a  
3602 3a 11 36			ld a, (.dmark+1)  
3605 32 78 fb			ld (debug_mark+1),a  
3608 3a 12 36			ld a, (.dmark+2)  
360b 32 79 fb			ld (debug_mark+2),a  
360e 18 03			jr .pastdmark  
3610 ..			.dmark: db "MAX"  
3613 f1			.pastdmark: pop af  
3614			endm  
# End of macro DMARK
3614						CALLMONITOR 
3614 cd 01 15			call break_point_state  
3617				endm  
# End of macro CALLMONITOR
3617					endif 
3617 cd 9b 1a				call forth_push_numhl 
361a			 
361a				       NEXTW 
361a c3 8c 1c			jp macro_next 
361d				endm 
# End of macro NEXTW
361d			 
361d			.maxcont:  
361d c1				pop bc   ; tidy up 
361e eb				ex de , hl  
361f					if DEBUG_FORTH_WORDS 
361f						DMARK "MA1" 
361f f5				push af  
3620 3a 34 36			ld a, (.dmark)  
3623 32 77 fb			ld (debug_mark),a  
3626 3a 35 36			ld a, (.dmark+1)  
3629 32 78 fb			ld (debug_mark+1),a  
362c 3a 36 36			ld a, (.dmark+2)  
362f 32 79 fb			ld (debug_mark+2),a  
3632 18 03			jr .pastdmark  
3634 ..			.dmark: db "MA1"  
3637 f1			.pastdmark: pop af  
3638			endm  
# End of macro DMARK
3638						CALLMONITOR 
3638 cd 01 15			call break_point_state  
363b				endm  
# End of macro CALLMONITOR
363b					endif 
363b cd 9b 1a				call forth_push_numhl 
363e				       NEXTW 
363e c3 8c 1c			jp macro_next 
3641				endm 
# End of macro NEXTW
3641			 
3641			.RND16: 
3641				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3641 4e				db WORD_SYS_CORE+58             
3642 70 36			dw .RND8            
3644 06				db 5 + 1 
3645 .. 00			db "RND16",0              
364b				endm 
# End of macro CWHEAD
364b			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
364b					if DEBUG_FORTH_WORDS_KEY 
364b						DMARK "R16" 
364b f5				push af  
364c 3a 60 36			ld a, (.dmark)  
364f 32 77 fb			ld (debug_mark),a  
3652 3a 61 36			ld a, (.dmark+1)  
3655 32 78 fb			ld (debug_mark+1),a  
3658 3a 62 36			ld a, (.dmark+2)  
365b 32 79 fb			ld (debug_mark+2),a  
365e 18 03			jr .pastdmark  
3660 ..			.dmark: db "R16"  
3663 f1			.pastdmark: pop af  
3664			endm  
# End of macro DMARK
3664						CALLMONITOR 
3664 cd 01 15			call break_point_state  
3667				endm  
# End of macro CALLMONITOR
3667					endif 
3667 cd e6 0b				call prng16  
366a cd 9b 1a				call forth_push_numhl 
366d				       NEXTW 
366d c3 8c 1c			jp macro_next 
3670				endm 
# End of macro NEXTW
3670			.RND8: 
3670				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3670 60				db WORD_SYS_CORE+76             
3671 a5 36			dw .RND            
3673 05				db 4 + 1 
3674 .. 00			db "RND8",0              
3679				endm 
# End of macro CWHEAD
3679			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3679					if DEBUG_FORTH_WORDS_KEY 
3679						DMARK "RN8" 
3679 f5				push af  
367a 3a 8e 36			ld a, (.dmark)  
367d 32 77 fb			ld (debug_mark),a  
3680 3a 8f 36			ld a, (.dmark+1)  
3683 32 78 fb			ld (debug_mark+1),a  
3686 3a 90 36			ld a, (.dmark+2)  
3689 32 79 fb			ld (debug_mark+2),a  
368c 18 03			jr .pastdmark  
368e ..			.dmark: db "RN8"  
3691 f1			.pastdmark: pop af  
3692			endm  
# End of macro DMARK
3692						CALLMONITOR 
3692 cd 01 15			call break_point_state  
3695				endm  
# End of macro CALLMONITOR
3695					endif 
3695 2a b8 f8				ld hl,(xrandc) 
3698 23					inc hl 
3699 cd 00 0c				call xrnd 
369c 6f					ld l,a	 
369d 26 00				ld h,0 
369f cd 9b 1a				call forth_push_numhl 
36a2				       NEXTW 
36a2 c3 8c 1c			jp macro_next 
36a5				endm 
# End of macro NEXTW
36a5			.RND: 
36a5				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
36a5 60				db WORD_SYS_CORE+76             
36a6 ab 37			dw .ENDMATHS            
36a8 04				db 3 + 1 
36a9 .. 00			db "RND",0              
36ad				endm 
# End of macro CWHEAD
36ad			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
36ad			 
36ad					if DEBUG_FORTH_WORDS_KEY 
36ad						DMARK "RND" 
36ad f5				push af  
36ae 3a c2 36			ld a, (.dmark)  
36b1 32 77 fb			ld (debug_mark),a  
36b4 3a c3 36			ld a, (.dmark+1)  
36b7 32 78 fb			ld (debug_mark+1),a  
36ba 3a c4 36			ld a, (.dmark+2)  
36bd 32 79 fb			ld (debug_mark+2),a  
36c0 18 03			jr .pastdmark  
36c2 ..			.dmark: db "RND"  
36c5 f1			.pastdmark: pop af  
36c6			endm  
# End of macro DMARK
36c6						CALLMONITOR 
36c6 cd 01 15			call break_point_state  
36c9				endm  
# End of macro CALLMONITOR
36c9					endif 
36c9					 
36c9					FORTH_DSP_VALUEHL    ; upper range 
36c9 cd 36 1b			call macro_dsp_valuehl 
36cc				endm 
# End of macro FORTH_DSP_VALUEHL
36cc			 
36cc 22 bc f8				ld (LFSRSeed), hl	 
36cf			 
36cf					if DEBUG_FORTH_WORDS 
36cf						DMARK "RN1" 
36cf f5				push af  
36d0 3a e4 36			ld a, (.dmark)  
36d3 32 77 fb			ld (debug_mark),a  
36d6 3a e5 36			ld a, (.dmark+1)  
36d9 32 78 fb			ld (debug_mark+1),a  
36dc 3a e6 36			ld a, (.dmark+2)  
36df 32 79 fb			ld (debug_mark+2),a  
36e2 18 03			jr .pastdmark  
36e4 ..			.dmark: db "RN1"  
36e7 f1			.pastdmark: pop af  
36e8			endm  
# End of macro DMARK
36e8						CALLMONITOR 
36e8 cd 01 15			call break_point_state  
36eb				endm  
# End of macro CALLMONITOR
36eb					endif 
36eb					FORTH_DSP_POP 
36eb cd d2 1b			call macro_forth_dsp_pop 
36ee				endm 
# End of macro FORTH_DSP_POP
36ee			 
36ee					FORTH_DSP_VALUEHL    ; low range 
36ee cd 36 1b			call macro_dsp_valuehl 
36f1				endm 
# End of macro FORTH_DSP_VALUEHL
36f1			 
36f1					if DEBUG_FORTH_WORDS 
36f1						DMARK "RN2" 
36f1 f5				push af  
36f2 3a 06 37			ld a, (.dmark)  
36f5 32 77 fb			ld (debug_mark),a  
36f8 3a 07 37			ld a, (.dmark+1)  
36fb 32 78 fb			ld (debug_mark+1),a  
36fe 3a 08 37			ld a, (.dmark+2)  
3701 32 79 fb			ld (debug_mark+2),a  
3704 18 03			jr .pastdmark  
3706 ..			.dmark: db "RN2"  
3709 f1			.pastdmark: pop af  
370a			endm  
# End of macro DMARK
370a						CALLMONITOR 
370a cd 01 15			call break_point_state  
370d				endm  
# End of macro CALLMONITOR
370d					endif 
370d 22 be f8				ld (LFSRSeed+2), hl 
3710			 
3710					FORTH_DSP_POP 
3710 cd d2 1b			call macro_forth_dsp_pop 
3713				endm 
# End of macro FORTH_DSP_POP
3713			 
3713 e5					push hl 
3714			 
3714 e1			.inrange:	pop hl 
3715 cd e6 0b				call prng16  
3718					if DEBUG_FORTH_WORDS 
3718						DMARK "RN3" 
3718 f5				push af  
3719 3a 2d 37			ld a, (.dmark)  
371c 32 77 fb			ld (debug_mark),a  
371f 3a 2e 37			ld a, (.dmark+1)  
3722 32 78 fb			ld (debug_mark+1),a  
3725 3a 2f 37			ld a, (.dmark+2)  
3728 32 79 fb			ld (debug_mark+2),a  
372b 18 03			jr .pastdmark  
372d ..			.dmark: db "RN3"  
3730 f1			.pastdmark: pop af  
3731			endm  
# End of macro DMARK
3731						CALLMONITOR 
3731 cd 01 15			call break_point_state  
3734				endm  
# End of macro CALLMONITOR
3734					endif 
3734					 
3734					; if the range is 8bit knock out the high byte 
3734			 
3734 ed 5b bc f8			ld de, (LFSRSeed)     ; check high level 
3738			 
3738 3e 00				ld a, 0 
373a ba					cp d  
373b 20 1e				jr nz, .hirange 
373d 26 00				ld h, 0   ; knock it down to 8bit 
373f			 
373f					if DEBUG_FORTH_WORDS 
373f						DMARK "RNk" 
373f f5				push af  
3740 3a 54 37			ld a, (.dmark)  
3743 32 77 fb			ld (debug_mark),a  
3746 3a 55 37			ld a, (.dmark+1)  
3749 32 78 fb			ld (debug_mark+1),a  
374c 3a 56 37			ld a, (.dmark+2)  
374f 32 79 fb			ld (debug_mark+2),a  
3752 18 03			jr .pastdmark  
3754 ..			.dmark: db "RNk"  
3757 f1			.pastdmark: pop af  
3758			endm  
# End of macro DMARK
3758						CALLMONITOR 
3758 cd 01 15			call break_point_state  
375b				endm  
# End of macro CALLMONITOR
375b					endif 
375b			.hirange:   
375b e5					push hl  
375c b7					or a  
375d ed 52		                sbc hl, de 
375f			 
375f					;call cmp16 
375f			 
375f 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3761 e1					pop hl 
3762 e5					push hl 
3763			 
3763					if DEBUG_FORTH_WORDS 
3763						DMARK "RN4" 
3763 f5				push af  
3764 3a 78 37			ld a, (.dmark)  
3767 32 77 fb			ld (debug_mark),a  
376a 3a 79 37			ld a, (.dmark+1)  
376d 32 78 fb			ld (debug_mark+1),a  
3770 3a 7a 37			ld a, (.dmark+2)  
3773 32 79 fb			ld (debug_mark+2),a  
3776 18 03			jr .pastdmark  
3778 ..			.dmark: db "RN4"  
377b f1			.pastdmark: pop af  
377c			endm  
# End of macro DMARK
377c						CALLMONITOR 
377c cd 01 15			call break_point_state  
377f				endm  
# End of macro CALLMONITOR
377f					endif 
377f ed 5b be f8			ld de, (LFSRSeed+2)   ; check low range 
3783					;call cmp16 
3783				 
3783 b7					or a  
3784 ed 52		                sbc hl, de 
3786 38 8c				jr c, .inrange 
3788			 
3788 e1					pop hl 
3789					 
3789					if DEBUG_FORTH_WORDS 
3789						DMARK "RNd" 
3789 f5				push af  
378a 3a 9e 37			ld a, (.dmark)  
378d 32 77 fb			ld (debug_mark),a  
3790 3a 9f 37			ld a, (.dmark+1)  
3793 32 78 fb			ld (debug_mark+1),a  
3796 3a a0 37			ld a, (.dmark+2)  
3799 32 79 fb			ld (debug_mark+2),a  
379c 18 03			jr .pastdmark  
379e ..			.dmark: db "RNd"  
37a1 f1			.pastdmark: pop af  
37a2			endm  
# End of macro DMARK
37a2						CALLMONITOR 
37a2 cd 01 15			call break_point_state  
37a5				endm  
# End of macro CALLMONITOR
37a5					endif 
37a5			 
37a5			 
37a5 cd 9b 1a				call forth_push_numhl 
37a8				       NEXTW 
37a8 c3 8c 1c			jp macro_next 
37ab				endm 
# End of macro NEXTW
37ab			 
37ab			.ENDMATHS: 
37ab			 
37ab			; eof 
37ab			 
# End of file forth_words_maths.asm
37ab			include "forth_words_display.asm" 
37ab			 
37ab			; | ## Display Words 
37ab			 
37ab			.ATP: 
37ab				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
37ab 62				db WORD_SYS_CORE+78             
37ac 22 38			dw .FB            
37ae 04				db 3 + 1 
37af .. 00			db "AT?",0              
37b3				endm 
# End of macro CWHEAD
37b3			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
37b3					if DEBUG_FORTH_WORDS_KEY 
37b3						DMARK "AT?" 
37b3 f5				push af  
37b4 3a c8 37			ld a, (.dmark)  
37b7 32 77 fb			ld (debug_mark),a  
37ba 3a c9 37			ld a, (.dmark+1)  
37bd 32 78 fb			ld (debug_mark+1),a  
37c0 3a ca 37			ld a, (.dmark+2)  
37c3 32 79 fb			ld (debug_mark+2),a  
37c6 18 03			jr .pastdmark  
37c8 ..			.dmark: db "AT?"  
37cb f1			.pastdmark: pop af  
37cc			endm  
# End of macro DMARK
37cc						CALLMONITOR 
37cc cd 01 15			call break_point_state  
37cf				endm  
# End of macro CALLMONITOR
37cf					endif 
37cf 3a 5b f8				ld a, (f_cursor_ptr) 
37d2			 
37d2			if DEBUG_FORTH_WORDS 
37d2				DMARK "AT?" 
37d2 f5				push af  
37d3 3a e7 37			ld a, (.dmark)  
37d6 32 77 fb			ld (debug_mark),a  
37d9 3a e8 37			ld a, (.dmark+1)  
37dc 32 78 fb			ld (debug_mark+1),a  
37df 3a e9 37			ld a, (.dmark+2)  
37e2 32 79 fb			ld (debug_mark+2),a  
37e5 18 03			jr .pastdmark  
37e7 ..			.dmark: db "AT?"  
37ea f1			.pastdmark: pop af  
37eb			endm  
# End of macro DMARK
37eb				CALLMONITOR 
37eb cd 01 15			call break_point_state  
37ee				endm  
# End of macro CALLMONITOR
37ee			endif	 
37ee					; count the number of rows 
37ee			 
37ee 06 00				ld b, 0 
37f0 4f			.atpr:		ld c, a    ; save in case we go below zero 
37f1 d6 28				sub display_cols 
37f3 f2 f9 37				jp p, .atprunder 
37f6 04					inc b 
37f7 18 f7				jr .atpr 
37f9			.atprunder:	 
37f9			if DEBUG_FORTH_WORDS 
37f9				DMARK "A?2" 
37f9 f5				push af  
37fa 3a 0e 38			ld a, (.dmark)  
37fd 32 77 fb			ld (debug_mark),a  
3800 3a 0f 38			ld a, (.dmark+1)  
3803 32 78 fb			ld (debug_mark+1),a  
3806 3a 10 38			ld a, (.dmark+2)  
3809 32 79 fb			ld (debug_mark+2),a  
380c 18 03			jr .pastdmark  
380e ..			.dmark: db "A?2"  
3811 f1			.pastdmark: pop af  
3812			endm  
# End of macro DMARK
3812				CALLMONITOR 
3812 cd 01 15			call break_point_state  
3815				endm  
# End of macro CALLMONITOR
3815			endif	 
3815 26 00				ld h, 0 
3817 69					ld l, c 
3818 cd 9b 1a				call forth_push_numhl 
381b 68					ld l, b  
381c cd 9b 1a				call forth_push_numhl 
381f			 
381f			 
381f				NEXTW 
381f c3 8c 1c			jp macro_next 
3822				endm 
# End of macro NEXTW
3822			 
3822			.FB: 
3822				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3822 1b				db WORD_SYS_CORE+7             
3823 70 38			dw .EMIT            
3825 03				db 2 + 1 
3826 .. 00			db "FB",0              
3829				endm 
# End of macro CWHEAD
3829			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3829			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3829			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3829			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3829					if DEBUG_FORTH_WORDS_KEY 
3829						DMARK "FB." 
3829 f5				push af  
382a 3a 3e 38			ld a, (.dmark)  
382d 32 77 fb			ld (debug_mark),a  
3830 3a 3f 38			ld a, (.dmark+1)  
3833 32 78 fb			ld (debug_mark+1),a  
3836 3a 40 38			ld a, (.dmark+2)  
3839 32 79 fb			ld (debug_mark+2),a  
383c 18 03			jr .pastdmark  
383e ..			.dmark: db "FB."  
3841 f1			.pastdmark: pop af  
3842			endm  
# End of macro DMARK
3842						CALLMONITOR 
3842 cd 01 15			call break_point_state  
3845				endm  
# End of macro CALLMONITOR
3845					endif 
3845			 
3845					FORTH_DSP_VALUEHL 
3845 cd 36 1b			call macro_dsp_valuehl 
3848				endm 
# End of macro FORTH_DSP_VALUEHL
3848			 
3848 7d					ld a, l 
3849 fe 01				cp 1 
384b 20 05				jr nz, .fbn1 
384d 21 1c fa				ld hl, display_fb1 
3850 18 15				jr .fbset 
3852 fe 02		.fbn1:		cp 2 
3854 20 05				jr nz, .fbn2 
3856 21 da f8				ld hl, display_fb2 
3859 18 0c				jr .fbset 
385b fe 03		.fbn2:		cp 3 
385d 20 05				jr nz, .fbn3 
385f 21 7b f9				ld hl, display_fb3 
3862 18 03				jr .fbset 
3864			.fbn3:		 ; if invalid number select first 
3864 21 1c fa				ld hl, display_fb1 
3867 22 d8 f8		.fbset:		ld (display_fb_active), hl 
386a			 
386a					FORTH_DSP_POP 
386a cd d2 1b			call macro_forth_dsp_pop 
386d				endm 
# End of macro FORTH_DSP_POP
386d			 
386d					NEXTW 
386d c3 8c 1c			jp macro_next 
3870				endm 
# End of macro NEXTW
3870			 
3870			 
3870			.EMIT: 
3870				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3870 1b				db WORD_SYS_CORE+7             
3871 c1 38			dw .DOTH            
3873 05				db 4 + 1 
3874 .. 00			db "EMIT",0              
3879				endm 
# End of macro CWHEAD
3879			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3879					; get value off TOS and display it 
3879			 
3879					if DEBUG_FORTH_WORDS_KEY 
3879						DMARK "EMT" 
3879 f5				push af  
387a 3a 8e 38			ld a, (.dmark)  
387d 32 77 fb			ld (debug_mark),a  
3880 3a 8f 38			ld a, (.dmark+1)  
3883 32 78 fb			ld (debug_mark+1),a  
3886 3a 90 38			ld a, (.dmark+2)  
3889 32 79 fb			ld (debug_mark+2),a  
388c 18 03			jr .pastdmark  
388e ..			.dmark: db "EMT"  
3891 f1			.pastdmark: pop af  
3892			endm  
# End of macro DMARK
3892						CALLMONITOR 
3892 cd 01 15			call break_point_state  
3895				endm  
# End of macro CALLMONITOR
3895					endif 
3895			 
3895					FORTH_DSP_VALUEHL 
3895 cd 36 1b			call macro_dsp_valuehl 
3898				endm 
# End of macro FORTH_DSP_VALUEHL
3898			 
3898 7d					ld a,l 
3899			 
3899					; TODO write to display 
3899			 
3899 32 30 f0				ld (os_input), a 
389c 3e 00				ld a, 0 
389e 32 31 f0				ld (os_input+1), a 
38a1					 
38a1 3a 5b f8				ld a, (f_cursor_ptr) 
38a4 11 30 f0				ld de, os_input 
38a7 cd a2 0a				call str_at_display 
38aa			 
38aa			 
38aa 3a 39 f8				ld a,(cli_autodisplay) 
38ad fe 00				cp 0 
38af 28 03				jr z, .enoupdate 
38b1 cd b2 0a						call update_display 
38b4					.enoupdate: 
38b4			 
38b4 3a 5b f8				ld a, (f_cursor_ptr) 
38b7 3c					inc a 
38b8 32 5b f8				ld (f_cursor_ptr), a   ; save new pos 
38bb			 
38bb			 
38bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38bb cd d2 1b			call macro_forth_dsp_pop 
38be				endm 
# End of macro FORTH_DSP_POP
38be			  
38be			 
38be					NEXTW 
38be c3 8c 1c			jp macro_next 
38c1				endm 
# End of macro NEXTW
38c1			.DOTH: 
38c1				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
38c1 1c				db WORD_SYS_CORE+8             
38c2 f1 38			dw .DOTF            
38c4 03				db 2 + 1 
38c5 .. 00			db ".-",0              
38c8				endm 
# End of macro CWHEAD
38c8			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
38c8					; get value off TOS and display it 
38c8					if DEBUG_FORTH_WORDS_KEY 
38c8						DMARK "DTD" 
38c8 f5				push af  
38c9 3a dd 38			ld a, (.dmark)  
38cc 32 77 fb			ld (debug_mark),a  
38cf 3a de 38			ld a, (.dmark+1)  
38d2 32 78 fb			ld (debug_mark+1),a  
38d5 3a df 38			ld a, (.dmark+2)  
38d8 32 79 fb			ld (debug_mark+2),a  
38db 18 03			jr .pastdmark  
38dd ..			.dmark: db "DTD"  
38e0 f1			.pastdmark: pop af  
38e1			endm  
# End of macro DMARK
38e1						CALLMONITOR 
38e1 cd 01 15			call break_point_state  
38e4				endm  
# End of macro CALLMONITOR
38e4					endif 
38e4 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
38e6 3e 00			ld a, 0 
38e8 32 3a f8			ld (cli_mvdot), a 
38eb c3 48 39			jp .dotgo 
38ee				NEXTW 
38ee c3 8c 1c			jp macro_next 
38f1				endm 
# End of macro NEXTW
38f1			.DOTF: 
38f1				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
38f1 1c				db WORD_SYS_CORE+8             
38f2 1f 39			dw .DOT            
38f4 03				db 2 + 1 
38f5 .. 00			db ".>",0              
38f8				endm 
# End of macro CWHEAD
38f8			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
38f8					; get value off TOS and display it 
38f8			        ; TODO BUG adds extra spaces 
38f8			        ; TODO BUG handle numerics? 
38f8					if DEBUG_FORTH_WORDS_KEY 
38f8						DMARK "DTC" 
38f8 f5				push af  
38f9 3a 0d 39			ld a, (.dmark)  
38fc 32 77 fb			ld (debug_mark),a  
38ff 3a 0e 39			ld a, (.dmark+1)  
3902 32 78 fb			ld (debug_mark+1),a  
3905 3a 0f 39			ld a, (.dmark+2)  
3908 32 79 fb			ld (debug_mark+2),a  
390b 18 03			jr .pastdmark  
390d ..			.dmark: db "DTC"  
3910 f1			.pastdmark: pop af  
3911			endm  
# End of macro DMARK
3911						CALLMONITOR 
3911 cd 01 15			call break_point_state  
3914				endm  
# End of macro CALLMONITOR
3914					endif 
3914 3e 01			ld a, 1 
3916 32 3a f8			ld (cli_mvdot), a 
3919 c3 48 39			jp .dotgo 
391c				NEXTW 
391c c3 8c 1c			jp macro_next 
391f				endm 
# End of macro NEXTW
391f			 
391f			.DOT: 
391f				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
391f 1c				db WORD_SYS_CORE+8             
3920 ab 39			dw .CLS            
3922 02				db 1 + 1 
3923 .. 00			db ".",0              
3925				endm 
# End of macro CWHEAD
3925			        ; | . ( u -- ) Display TOS | DONE 
3925					; get value off TOS and display it 
3925			 
3925					if DEBUG_FORTH_WORDS_KEY 
3925						DMARK "DOT" 
3925 f5				push af  
3926 3a 3a 39			ld a, (.dmark)  
3929 32 77 fb			ld (debug_mark),a  
392c 3a 3b 39			ld a, (.dmark+1)  
392f 32 78 fb			ld (debug_mark+1),a  
3932 3a 3c 39			ld a, (.dmark+2)  
3935 32 79 fb			ld (debug_mark+2),a  
3938 18 03			jr .pastdmark  
393a ..			.dmark: db "DOT"  
393d f1			.pastdmark: pop af  
393e			endm  
# End of macro DMARK
393e						CALLMONITOR 
393e cd 01 15			call break_point_state  
3941				endm  
# End of macro CALLMONITOR
3941					endif 
3941 3e 00			ld a, 0 
3943 32 3a f8			ld (cli_mvdot), a 
3946 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3948				 
3948			 
3948			.dotgo: 
3948			 
3948			; move up type to on stack for parserv5 
3948					FORTH_DSP 
3948 cd 1b 1b			call macro_forth_dsp 
394b				endm 
# End of macro FORTH_DSP
394b				;FORTH_DSP_VALUE  
394b			 
394b			if DEBUG_FORTH_DOT 
394b				DMARK "DOT" 
394b				CALLMONITOR 
394b			endif	 
394b			;		.print: 
394b			 
394b 7e				ld a,(hl)  ; work out what type of value is on the TOS 
394c 23				inc hl   ; position to the actual value 
394d fe 01			cp DS_TYPE_STR 
394f 20 06			jr nz, .dotnum1  
3951			 
3951			; display string 
3951				FORTH_DSP_VALUE  
3951 cd 1f 1b			call macro_forth_dsp_value 
3954				endm 
# End of macro FORTH_DSP_VALUE
3954 eb				ex de,hl 
3955 18 11			jr .dotwrite 
3957			 
3957			.dotnum1: 
3957 fe 02			cp DS_TYPE_INUM 
3959 20 0c			jr nz, .dotflot 
395b			 
395b			 
395b			; display number 
395b			 
395b			;	push hl 
395b			;	call clear_display 
395b			;	pop hl 
395b			 
395b 5e				ld e, (hl) 
395c 23				inc hl 
395d 56				ld d, (hl) 
395e 21 32 ee			ld hl, scratch 
3961			if DEBUG_FORTH_DOT 
3961				DMARK "DT1" 
3961				CALLMONITOR 
3961			endif	 
3961			 
3961 cd cc 10			call uitoa_16 
3964 eb				ex de,hl 
3965			 
3965			if DEBUG_FORTH_DOT 
3965				DMARK "DT2" 
3965				CALLMONITOR 
3965			endif	 
3965			 
3965			;	ld de, os_word_scratch 
3965 18 01			jr .dotwrite 
3967			 
3967 00			.dotflot:   nop 
3968			; TODO print floating point number 
3968			 
3968			.dotwrite:		 
3968			 
3968					; if c is set then set all '-' to spaces 
3968					; need to also take into account .>  
3968			 
3968 3e 01				ld a, 1 
396a b9					cp c 
396b 20 13				jr nz, .nodashswap 
396d			 
396d					; DE has the string to write, working with HL 
396d			 
396d 06 ff				ld b, 255 
396f d5					push de 
3970 e1					pop hl 
3971			 
3971			if DEBUG_FORTH_DOT 
3971				DMARK "DT-" 
3971				CALLMONITOR 
3971			endif	 
3971 7e			.dashscan:	ld a, (hl) 
3972 fe 00				cp 0 
3974 28 0a				jr z, .nodashswap 
3976 fe 2d				cp '-' 
3978 20 03				jr nz, .dashskip 
397a 3e 20				ld a, ' ' 
397c 77					ld (hl), a 
397d 23			.dashskip:	inc hl 
397e			if DEBUG_FORTH_DOT 
397e				DMARK "D-2" 
397e				CALLMONITOR 
397e			endif	 
397e 10 f1				djnz .dashscan 
3980			 
3980			if DEBUG_FORTH_DOT 
3980				DMARK "D-1" 
3980				CALLMONITOR 
3980			endif	 
3980			 
3980			.nodashswap: 
3980			 
3980 e5					push hl   ; save string start in case we need to advance print 
3981			 
3981 3a 5b f8				ld a, (f_cursor_ptr) 
3984 cd a2 0a				call str_at_display 
3987 3a 39 f8				ld a,(cli_autodisplay) 
398a fe 00				cp 0 
398c 28 03				jr z, .noupdate 
398e cd b2 0a						call update_display 
3991					.noupdate: 
3991			 
3991			 
3991					; see if we need to advance the print position 
3991			 
3991 e1					pop hl   ; get back string 
3992			 
3992 3a 3a f8				ld a, (cli_mvdot) 
3995			if DEBUG_FORTH_DOT 
3995					ld e,a 
3995				DMARK "D>1" 
3995				CALLMONITOR 
3995			endif	 
3995 fe 00				cp 0 
3997 28 0c				jr z, .noadv 
3999					; yes, lets advance the print position 
3999 3e 00				ld a, 0 
399b cd 28 11				call strlent 
399e 3a 5b f8				ld a, (f_cursor_ptr) 
39a1 85					add a,l 
39a2					;call addatohl 
39a2					;ld a, l 
39a2 32 5b f8				ld (f_cursor_ptr), a   ; save new pos 
39a5			 
39a5			if DEBUG_FORTH_DOT 
39a5				DMARK "D->" 
39a5				CALLMONITOR 
39a5			endif	 
39a5			 
39a5			.noadv:	 
39a5			 
39a5					if DEBUG_FORTH_DOT_WAIT 
39a5							call next_page_prompt 
39a5					endif	 
39a5			; TODO this pop off the stack causes a crash. i dont know why 
39a5			 
39a5			 
39a5			if DEBUG_FORTH_DOT 
39a5				DMARK "DTh" 
39a5				CALLMONITOR 
39a5			endif	 
39a5			 
39a5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39a5 cd d2 1b			call macro_forth_dsp_pop 
39a8				endm 
# End of macro FORTH_DSP_POP
39a8			 
39a8			if DEBUG_FORTH_DOT 
39a8				DMARK "DTi" 
39a8				CALLMONITOR 
39a8			endif	 
39a8			 
39a8			 
39a8					NEXTW 
39a8 c3 8c 1c			jp macro_next 
39ab				endm 
# End of macro NEXTW
39ab			 
39ab			.CLS: 
39ab				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
39ab 35				db WORD_SYS_CORE+33             
39ac d8 39			dw .DRAW            
39ae 04				db 3 + 1 
39af .. 00			db "CLS",0              
39b3				endm 
# End of macro CWHEAD
39b3			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
39b3					if DEBUG_FORTH_WORDS_KEY 
39b3						DMARK "CLS" 
39b3 f5				push af  
39b4 3a c8 39			ld a, (.dmark)  
39b7 32 77 fb			ld (debug_mark),a  
39ba 3a c9 39			ld a, (.dmark+1)  
39bd 32 78 fb			ld (debug_mark+1),a  
39c0 3a ca 39			ld a, (.dmark+2)  
39c3 32 79 fb			ld (debug_mark+2),a  
39c6 18 03			jr .pastdmark  
39c8 ..			.dmark: db "CLS"  
39cb f1			.pastdmark: pop af  
39cc			endm  
# End of macro DMARK
39cc						CALLMONITOR 
39cc cd 01 15			call break_point_state  
39cf				endm  
# End of macro CALLMONITOR
39cf					endif 
39cf cd 8f 0a				call clear_display 
39d2 c3 e6 3a				jp .home		; and home cursor 
39d5					NEXTW 
39d5 c3 8c 1c			jp macro_next 
39d8				endm 
# End of macro NEXTW
39d8			 
39d8			.DRAW: 
39d8				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
39d8 36				db WORD_SYS_CORE+34             
39d9 03 3a			dw .DUMP            
39db 05				db 4 + 1 
39dc .. 00			db "DRAW",0              
39e1				endm 
# End of macro CWHEAD
39e1			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
39e1					if DEBUG_FORTH_WORDS_KEY 
39e1						DMARK "DRW" 
39e1 f5				push af  
39e2 3a f6 39			ld a, (.dmark)  
39e5 32 77 fb			ld (debug_mark),a  
39e8 3a f7 39			ld a, (.dmark+1)  
39eb 32 78 fb			ld (debug_mark+1),a  
39ee 3a f8 39			ld a, (.dmark+2)  
39f1 32 79 fb			ld (debug_mark+2),a  
39f4 18 03			jr .pastdmark  
39f6 ..			.dmark: db "DRW"  
39f9 f1			.pastdmark: pop af  
39fa			endm  
# End of macro DMARK
39fa						CALLMONITOR 
39fa cd 01 15			call break_point_state  
39fd				endm  
# End of macro CALLMONITOR
39fd					endif 
39fd cd b2 0a				call update_display 
3a00					NEXTW 
3a00 c3 8c 1c			jp macro_next 
3a03				endm 
# End of macro NEXTW
3a03			 
3a03			.DUMP: 
3a03				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3a03 37				db WORD_SYS_CORE+35             
3a04 3b 3a			dw .CDUMP            
3a06 05				db 4 + 1 
3a07 .. 00			db "DUMP",0              
3a0c				endm 
# End of macro CWHEAD
3a0c			; | DUMP ( x -- ) With address x display dump   | DONE 
3a0c			; TODO pop address to use off of the stack 
3a0c					if DEBUG_FORTH_WORDS_KEY 
3a0c						DMARK "DUM" 
3a0c f5				push af  
3a0d 3a 21 3a			ld a, (.dmark)  
3a10 32 77 fb			ld (debug_mark),a  
3a13 3a 22 3a			ld a, (.dmark+1)  
3a16 32 78 fb			ld (debug_mark+1),a  
3a19 3a 23 3a			ld a, (.dmark+2)  
3a1c 32 79 fb			ld (debug_mark+2),a  
3a1f 18 03			jr .pastdmark  
3a21 ..			.dmark: db "DUM"  
3a24 f1			.pastdmark: pop af  
3a25			endm  
# End of macro DMARK
3a25						CALLMONITOR 
3a25 cd 01 15			call break_point_state  
3a28				endm  
# End of macro CALLMONITOR
3a28					endif 
3a28 cd 8f 0a				call clear_display 
3a2b			 
3a2b					; get address 
3a2b			 
3a2b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a2b cd 36 1b			call macro_dsp_valuehl 
3a2e				endm 
# End of macro FORTH_DSP_VALUEHL
3a2e				 
3a2e					; save it for cdump 
3a2e			 
3a2e 22 55 f1				ld (os_cur_ptr),hl 
3a31			 
3a31					; destroy value TOS 
3a31			 
3a31					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a31 cd d2 1b			call macro_forth_dsp_pop 
3a34				endm 
# End of macro FORTH_DSP_POP
3a34			 
3a34 cd 1b 19				call dumpcont	; skip old style of param parsing	 
3a37 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3a38					NEXTW 
3a38 c3 8c 1c			jp macro_next 
3a3b				endm 
# End of macro NEXTW
3a3b			.CDUMP: 
3a3b				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3a3b 38				db WORD_SYS_CORE+36             
3a3c 6b 3a			dw .DAT            
3a3e 06				db 5 + 1 
3a3f .. 00			db "CDUMP",0              
3a45				endm 
# End of macro CWHEAD
3a45			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3a45					if DEBUG_FORTH_WORDS_KEY 
3a45						DMARK "CDP" 
3a45 f5				push af  
3a46 3a 5a 3a			ld a, (.dmark)  
3a49 32 77 fb			ld (debug_mark),a  
3a4c 3a 5b 3a			ld a, (.dmark+1)  
3a4f 32 78 fb			ld (debug_mark+1),a  
3a52 3a 5c 3a			ld a, (.dmark+2)  
3a55 32 79 fb			ld (debug_mark+2),a  
3a58 18 03			jr .pastdmark  
3a5a ..			.dmark: db "CDP"  
3a5d f1			.pastdmark: pop af  
3a5e			endm  
# End of macro DMARK
3a5e						CALLMONITOR 
3a5e cd 01 15			call break_point_state  
3a61				endm  
# End of macro CALLMONITOR
3a61					endif 
3a61 cd 8f 0a				call clear_display 
3a64 cd 1b 19				call dumpcont	 
3a67 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3a68					NEXTW 
3a68 c3 8c 1c			jp macro_next 
3a6b				endm 
# End of macro NEXTW
3a6b			 
3a6b			 
3a6b			 
3a6b			 
3a6b			.DAT: 
3a6b				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3a6b 3d				db WORD_SYS_CORE+41             
3a6c c1 3a			dw .HOME            
3a6e 03				db 2 + 1 
3a6f .. 00			db "AT",0              
3a72				endm 
# End of macro CWHEAD
3a72			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3a72					if DEBUG_FORTH_WORDS_KEY 
3a72						DMARK "AT." 
3a72 f5				push af  
3a73 3a 87 3a			ld a, (.dmark)  
3a76 32 77 fb			ld (debug_mark),a  
3a79 3a 88 3a			ld a, (.dmark+1)  
3a7c 32 78 fb			ld (debug_mark+1),a  
3a7f 3a 89 3a			ld a, (.dmark+2)  
3a82 32 79 fb			ld (debug_mark+2),a  
3a85 18 03			jr .pastdmark  
3a87 ..			.dmark: db "AT."  
3a8a f1			.pastdmark: pop af  
3a8b			endm  
# End of macro DMARK
3a8b						CALLMONITOR 
3a8b cd 01 15			call break_point_state  
3a8e				endm  
# End of macro CALLMONITOR
3a8e					endif 
3a8e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a8e cd 36 1b			call macro_dsp_valuehl 
3a91				endm 
# End of macro FORTH_DSP_VALUEHL
3a91			 
3a91			 
3a91					; TODO save cursor row 
3a91 7d					ld a,l 
3a92 fe 02				cp 2 
3a94 20 04				jr nz, .crow3 
3a96 3e 28				ld a, display_row_2 
3a98 18 12				jr .ccol1 
3a9a fe 03		.crow3:		cp 3 
3a9c 20 04				jr nz, .crow4 
3a9e 3e 50				ld a, display_row_3 
3aa0 18 0a				jr .ccol1 
3aa2 fe 04		.crow4:		cp 4 
3aa4 20 04				jr nz, .crow1 
3aa6 3e 78				ld a, display_row_4 
3aa8 18 02				jr .ccol1 
3aaa 3e 00		.crow1:		ld a,display_row_1 
3aac f5			.ccol1:		push af			; got row offset 
3aad 6f					ld l,a 
3aae 26 00				ld h,0 
3ab0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ab0 cd d2 1b			call macro_forth_dsp_pop 
3ab3				endm 
# End of macro FORTH_DSP_POP
3ab3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ab3 cd 36 1b			call macro_dsp_valuehl 
3ab6				endm 
# End of macro FORTH_DSP_VALUEHL
3ab6					; TODO save cursor col 
3ab6 f1					pop af 
3ab7 85					add l		; add col offset 
3ab8 32 5b f8				ld (f_cursor_ptr), a 
3abb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3abb cd d2 1b			call macro_forth_dsp_pop 
3abe				endm 
# End of macro FORTH_DSP_POP
3abe			 
3abe					; calculate  
3abe			 
3abe					NEXTW 
3abe c3 8c 1c			jp macro_next 
3ac1				endm 
# End of macro NEXTW
3ac1			 
3ac1			 
3ac1			.HOME: 
3ac1				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3ac1 41				db WORD_SYS_CORE+45             
3ac2 ee 3a			dw .SPACE            
3ac4 05				db 4 + 1 
3ac5 .. 00			db "HOME",0              
3aca				endm 
# End of macro CWHEAD
3aca			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3aca					if DEBUG_FORTH_WORDS_KEY 
3aca						DMARK "HOM" 
3aca f5				push af  
3acb 3a df 3a			ld a, (.dmark)  
3ace 32 77 fb			ld (debug_mark),a  
3ad1 3a e0 3a			ld a, (.dmark+1)  
3ad4 32 78 fb			ld (debug_mark+1),a  
3ad7 3a e1 3a			ld a, (.dmark+2)  
3ada 32 79 fb			ld (debug_mark+2),a  
3add 18 03			jr .pastdmark  
3adf ..			.dmark: db "HOM"  
3ae2 f1			.pastdmark: pop af  
3ae3			endm  
# End of macro DMARK
3ae3						CALLMONITOR 
3ae3 cd 01 15			call break_point_state  
3ae6				endm  
# End of macro CALLMONITOR
3ae6					endif 
3ae6 3e 00		.home:		ld a, 0		; and home cursor 
3ae8 32 5b f8				ld (f_cursor_ptr), a 
3aeb					NEXTW 
3aeb c3 8c 1c			jp macro_next 
3aee				endm 
# End of macro NEXTW
3aee			 
3aee			 
3aee			.SPACE: 
3aee				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3aee 46				db WORD_SYS_CORE+50             
3aef 1c 3b			dw .SPACES            
3af1 03				db 2 + 1 
3af2 .. 00			db "BL",0              
3af5				endm 
# End of macro CWHEAD
3af5			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3af5					if DEBUG_FORTH_WORDS_KEY 
3af5						DMARK "BL." 
3af5 f5				push af  
3af6 3a 0a 3b			ld a, (.dmark)  
3af9 32 77 fb			ld (debug_mark),a  
3afc 3a 0b 3b			ld a, (.dmark+1)  
3aff 32 78 fb			ld (debug_mark+1),a  
3b02 3a 0c 3b			ld a, (.dmark+2)  
3b05 32 79 fb			ld (debug_mark+2),a  
3b08 18 03			jr .pastdmark  
3b0a ..			.dmark: db "BL."  
3b0d f1			.pastdmark: pop af  
3b0e			endm  
# End of macro DMARK
3b0e						CALLMONITOR 
3b0e cd 01 15			call break_point_state  
3b11				endm  
# End of macro CALLMONITOR
3b11					endif 
3b11 21 1a 3b				ld hl, .blstr 
3b14 cd ad 1a				call forth_push_str 
3b17					 
3b17				       NEXTW 
3b17 c3 8c 1c			jp macro_next 
3b1a				endm 
# End of macro NEXTW
3b1a			 
3b1a .. 00		.blstr: db " ", 0 
3b1c			 
3b1c			.SPACES: 
3b1c				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3b1c 47				db WORD_SYS_CORE+51             
3b1d b7 3b			dw .SCROLL            
3b1f 07				db 6 + 1 
3b20 .. 00			db "SPACES",0              
3b27				endm 
# End of macro CWHEAD
3b27			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3b27					if DEBUG_FORTH_WORDS_KEY 
3b27						DMARK "SPS" 
3b27 f5				push af  
3b28 3a 3c 3b			ld a, (.dmark)  
3b2b 32 77 fb			ld (debug_mark),a  
3b2e 3a 3d 3b			ld a, (.dmark+1)  
3b31 32 78 fb			ld (debug_mark+1),a  
3b34 3a 3e 3b			ld a, (.dmark+2)  
3b37 32 79 fb			ld (debug_mark+2),a  
3b3a 18 03			jr .pastdmark  
3b3c ..			.dmark: db "SPS"  
3b3f f1			.pastdmark: pop af  
3b40			endm  
# End of macro DMARK
3b40						CALLMONITOR 
3b40 cd 01 15			call break_point_state  
3b43				endm  
# End of macro CALLMONITOR
3b43					endif 
3b43			 
3b43			 
3b43					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b43 cd 36 1b			call macro_dsp_valuehl 
3b46				endm 
# End of macro FORTH_DSP_VALUEHL
3b46			 
3b46			;		push hl    ; u 
3b46					if DEBUG_FORTH_WORDS 
3b46						DMARK "SPA" 
3b46 f5				push af  
3b47 3a 5b 3b			ld a, (.dmark)  
3b4a 32 77 fb			ld (debug_mark),a  
3b4d 3a 5c 3b			ld a, (.dmark+1)  
3b50 32 78 fb			ld (debug_mark+1),a  
3b53 3a 5d 3b			ld a, (.dmark+2)  
3b56 32 79 fb			ld (debug_mark+2),a  
3b59 18 03			jr .pastdmark  
3b5b ..			.dmark: db "SPA"  
3b5e f1			.pastdmark: pop af  
3b5f			endm  
# End of macro DMARK
3b5f						CALLMONITOR 
3b5f cd 01 15			call break_point_state  
3b62				endm  
# End of macro CALLMONITOR
3b62					endif 
3b62			 
3b62					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b62 cd d2 1b			call macro_forth_dsp_pop 
3b65				endm 
# End of macro FORTH_DSP_POP
3b65			;		pop hl 
3b65 4d					ld c, l 
3b66 06 00				ld b, 0 
3b68 21 32 ee				ld hl, scratch  
3b6b			 
3b6b					if DEBUG_FORTH_WORDS 
3b6b						DMARK "SP2" 
3b6b f5				push af  
3b6c 3a 80 3b			ld a, (.dmark)  
3b6f 32 77 fb			ld (debug_mark),a  
3b72 3a 81 3b			ld a, (.dmark+1)  
3b75 32 78 fb			ld (debug_mark+1),a  
3b78 3a 82 3b			ld a, (.dmark+2)  
3b7b 32 79 fb			ld (debug_mark+2),a  
3b7e 18 03			jr .pastdmark  
3b80 ..			.dmark: db "SP2"  
3b83 f1			.pastdmark: pop af  
3b84			endm  
# End of macro DMARK
3b84						CALLMONITOR 
3b84 cd 01 15			call break_point_state  
3b87				endm  
# End of macro CALLMONITOR
3b87					endif 
3b87 3e 20				ld a, ' ' 
3b89 c5			.spaces1:	push bc 
3b8a 77					ld (hl),a 
3b8b 23					inc hl 
3b8c c1					pop bc 
3b8d 10 fa				djnz .spaces1 
3b8f 3e 00				ld a,0 
3b91 77					ld (hl),a 
3b92 21 32 ee				ld hl, scratch 
3b95					if DEBUG_FORTH_WORDS 
3b95						DMARK "SP3" 
3b95 f5				push af  
3b96 3a aa 3b			ld a, (.dmark)  
3b99 32 77 fb			ld (debug_mark),a  
3b9c 3a ab 3b			ld a, (.dmark+1)  
3b9f 32 78 fb			ld (debug_mark+1),a  
3ba2 3a ac 3b			ld a, (.dmark+2)  
3ba5 32 79 fb			ld (debug_mark+2),a  
3ba8 18 03			jr .pastdmark  
3baa ..			.dmark: db "SP3"  
3bad f1			.pastdmark: pop af  
3bae			endm  
# End of macro DMARK
3bae						CALLMONITOR 
3bae cd 01 15			call break_point_state  
3bb1				endm  
# End of macro CALLMONITOR
3bb1					endif 
3bb1 cd e3 1a				call forth_apush 
3bb4			 
3bb4				       NEXTW 
3bb4 c3 8c 1c			jp macro_next 
3bb7				endm 
# End of macro NEXTW
3bb7			 
3bb7			 
3bb7			 
3bb7			.SCROLL: 
3bb7				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3bb7 53				db WORD_SYS_CORE+63             
3bb8 e4 3b			dw .SCROLLD            
3bba 07				db 6 + 1 
3bbb .. 00			db "SCROLL",0              
3bc2				endm 
# End of macro CWHEAD
3bc2			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3bc2					if DEBUG_FORTH_WORDS_KEY 
3bc2						DMARK "SCR" 
3bc2 f5				push af  
3bc3 3a d7 3b			ld a, (.dmark)  
3bc6 32 77 fb			ld (debug_mark),a  
3bc9 3a d8 3b			ld a, (.dmark+1)  
3bcc 32 78 fb			ld (debug_mark+1),a  
3bcf 3a d9 3b			ld a, (.dmark+2)  
3bd2 32 79 fb			ld (debug_mark+2),a  
3bd5 18 03			jr .pastdmark  
3bd7 ..			.dmark: db "SCR"  
3bda f1			.pastdmark: pop af  
3bdb			endm  
# End of macro DMARK
3bdb						CALLMONITOR 
3bdb cd 01 15			call break_point_state  
3bde				endm  
# End of macro CALLMONITOR
3bde					endif 
3bde			 
3bde cd 51 0a			call scroll_up 
3be1			;	call update_display 
3be1			 
3be1					NEXTW 
3be1 c3 8c 1c			jp macro_next 
3be4				endm 
# End of macro NEXTW
3be4			 
3be4			 
3be4			 
3be4			;		; get dir 
3be4			; 
3be4			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3be4			; 
3be4			;		push hl 
3be4			; 
3be4			;		; destroy value TOS 
3be4			; 
3be4			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3be4			; 
3be4			;		; get count 
3be4			; 
3be4			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3be4			; 
3be4			;		push hl 
3be4			; 
3be4			;		; destroy value TOS 
3be4			; 
3be4			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3be4			; 
3be4			;		; one value on hl get other one back 
3be4			; 
3be4			;		pop bc    ; count 
3be4			; 
3be4			;		pop de   ; dir 
3be4			; 
3be4			; 
3be4			;		ld b, c 
3be4			; 
3be4			;.scrolldir:     push bc 
3be4			;		push de 
3be4			; 
3be4			;		ld a, 0 
3be4			;		cp e 
3be4			;		jr z, .scrollup  
3be4			;		call scroll_down 
3be4			;		jr .scrollnext 
3be4			;.scrollup:	call scroll_up 
3be4			; 
3be4			;		 
3be4			;.scrollnext: 
3be4			;		pop de 
3be4			;		pop bc 
3be4			;		djnz .scrolldir 
3be4			; 
3be4			; 
3be4			; 
3be4			; 
3be4			; 
3be4			;		NEXTW 
3be4			 
3be4			.SCROLLD: 
3be4				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3be4 53				db WORD_SYS_CORE+63             
3be5 12 3c			dw .ATQ            
3be7 08				db 7 + 1 
3be8 .. 00			db "SCROLLD",0              
3bf0				endm 
# End of macro CWHEAD
3bf0			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3bf0					if DEBUG_FORTH_WORDS_KEY 
3bf0						DMARK "SCD" 
3bf0 f5				push af  
3bf1 3a 05 3c			ld a, (.dmark)  
3bf4 32 77 fb			ld (debug_mark),a  
3bf7 3a 06 3c			ld a, (.dmark+1)  
3bfa 32 78 fb			ld (debug_mark+1),a  
3bfd 3a 07 3c			ld a, (.dmark+2)  
3c00 32 79 fb			ld (debug_mark+2),a  
3c03 18 03			jr .pastdmark  
3c05 ..			.dmark: db "SCD"  
3c08 f1			.pastdmark: pop af  
3c09			endm  
# End of macro DMARK
3c09						CALLMONITOR 
3c09 cd 01 15			call break_point_state  
3c0c				endm  
# End of macro CALLMONITOR
3c0c					endif 
3c0c			 
3c0c cd 75 0a			call scroll_down 
3c0f			;	call update_display 
3c0f			 
3c0f					NEXTW 
3c0f c3 8c 1c			jp macro_next 
3c12				endm 
# End of macro NEXTW
3c12			 
3c12			 
3c12			.ATQ: 
3c12				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3c12 62				db WORD_SYS_CORE+78             
3c13 70 3c			dw .AUTODSP            
3c15 04				db 3 + 1 
3c16 .. 00			db "AT@",0              
3c1a				endm 
# End of macro CWHEAD
3c1a			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3c1a					if DEBUG_FORTH_WORDS_KEY 
3c1a						DMARK "ATA" 
3c1a f5				push af  
3c1b 3a 2f 3c			ld a, (.dmark)  
3c1e 32 77 fb			ld (debug_mark),a  
3c21 3a 30 3c			ld a, (.dmark+1)  
3c24 32 78 fb			ld (debug_mark+1),a  
3c27 3a 31 3c			ld a, (.dmark+2)  
3c2a 32 79 fb			ld (debug_mark+2),a  
3c2d 18 03			jr .pastdmark  
3c2f ..			.dmark: db "ATA"  
3c32 f1			.pastdmark: pop af  
3c33			endm  
# End of macro DMARK
3c33						CALLMONITOR 
3c33 cd 01 15			call break_point_state  
3c36				endm  
# End of macro CALLMONITOR
3c36					endif 
3c36			 
3c36			 
3c36					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c36 cd 36 1b			call macro_dsp_valuehl 
3c39				endm 
# End of macro FORTH_DSP_VALUEHL
3c39			 
3c39					; TODO save cursor row 
3c39 7d					ld a,l 
3c3a fe 02				cp 2 
3c3c 20 04				jr nz, .crow3aq 
3c3e 3e 28				ld a, display_row_2 
3c40 18 12				jr .ccol1aq 
3c42 fe 03		.crow3aq:		cp 3 
3c44 20 04				jr nz, .crow4aq 
3c46 3e 50				ld a, display_row_3 
3c48 18 0a				jr .ccol1aq 
3c4a fe 04		.crow4aq:		cp 4 
3c4c 20 04				jr nz, .crow1aq 
3c4e 3e 78				ld a, display_row_4 
3c50 18 02				jr .ccol1aq 
3c52 3e 00		.crow1aq:		ld a,display_row_1 
3c54 f5			.ccol1aq:		push af			; got row offset 
3c55 6f					ld l,a 
3c56 26 00				ld h,0 
3c58					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c58 cd d2 1b			call macro_forth_dsp_pop 
3c5b				endm 
# End of macro FORTH_DSP_POP
3c5b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c5b cd 36 1b			call macro_dsp_valuehl 
3c5e				endm 
# End of macro FORTH_DSP_VALUEHL
3c5e					; TODO save cursor col 
3c5e f1					pop af 
3c5f 85					add l		; add col offset 
3c60			 
3c60					; add current frame buffer address 
3c60 2a d8 f8				ld hl, (display_fb_active) 
3c63 cd bf 0c				call addatohl 
3c66			 
3c66			 
3c66			 
3c66			 
3c66					; get char frame buffer location offset in hl 
3c66			 
3c66 7e					ld a,(hl) 
3c67 26 00				ld h, 0 
3c69 6f					ld l, a 
3c6a			 
3c6a cd 9b 1a				call forth_push_numhl 
3c6d			 
3c6d			 
3c6d					NEXTW 
3c6d c3 8c 1c			jp macro_next 
3c70				endm 
# End of macro NEXTW
3c70			 
3c70			.AUTODSP: 
3c70				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3c70 63				db WORD_SYS_CORE+79             
3c71 86 3c			dw .MENU            
3c73 05				db 4 + 1 
3c74 .. 00			db "ADSP",0              
3c79				endm 
# End of macro CWHEAD
3c79			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3c79			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3c79			 
3c79					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c79 cd 36 1b			call macro_dsp_valuehl 
3c7c				endm 
# End of macro FORTH_DSP_VALUEHL
3c7c			 
3c7c			;		push hl 
3c7c			 
3c7c					; destroy value TOS 
3c7c			 
3c7c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c7c cd d2 1b			call macro_forth_dsp_pop 
3c7f				endm 
# End of macro FORTH_DSP_POP
3c7f			 
3c7f			;		pop hl 
3c7f			 
3c7f 7d					ld a,l 
3c80 32 39 f8				ld (cli_autodisplay), a 
3c83				       NEXTW 
3c83 c3 8c 1c			jp macro_next 
3c86				endm 
# End of macro NEXTW
3c86			 
3c86			.MENU: 
3c86				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3c86 70				db WORD_SYS_CORE+92             
3c87 2f 3d			dw .ENDDISPLAY            
3c89 05				db 4 + 1 
3c8a .. 00			db "MENU",0              
3c8f				endm 
# End of macro CWHEAD
3c8f			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3c8f			 
3c8f			;		; get number of items on the stack 
3c8f			; 
3c8f				 
3c8f					FORTH_DSP_VALUEHL 
3c8f cd 36 1b			call macro_dsp_valuehl 
3c92				endm 
# End of macro FORTH_DSP_VALUEHL
3c92				 
3c92					if DEBUG_FORTH_WORDS_KEY 
3c92						DMARK "MNU" 
3c92 f5				push af  
3c93 3a a7 3c			ld a, (.dmark)  
3c96 32 77 fb			ld (debug_mark),a  
3c99 3a a8 3c			ld a, (.dmark+1)  
3c9c 32 78 fb			ld (debug_mark+1),a  
3c9f 3a a9 3c			ld a, (.dmark+2)  
3ca2 32 79 fb			ld (debug_mark+2),a  
3ca5 18 03			jr .pastdmark  
3ca7 ..			.dmark: db "MNU"  
3caa f1			.pastdmark: pop af  
3cab			endm  
# End of macro DMARK
3cab						CALLMONITOR 
3cab cd 01 15			call break_point_state  
3cae				endm  
# End of macro CALLMONITOR
3cae					endif 
3cae			 
3cae 45					ld b, l	 
3caf 05					dec b 
3cb0			 
3cb0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cb0 cd d2 1b			call macro_forth_dsp_pop 
3cb3				endm 
# End of macro FORTH_DSP_POP
3cb3			 
3cb3			 
3cb3					; go directly through the stack to pluck out the string pointers and build an array 
3cb3			 
3cb3			;		FORTH_DSP 
3cb3			 
3cb3					; hl contains top most stack item 
3cb3				 
3cb3 11 32 ee				ld de, scratch 
3cb6			 
3cb6			.mbuild: 
3cb6			 
3cb6					FORTH_DSP_VALUEHL 
3cb6 cd 36 1b			call macro_dsp_valuehl 
3cb9				endm 
# End of macro FORTH_DSP_VALUEHL
3cb9			 
3cb9					if DEBUG_FORTH_WORDS 
3cb9						DMARK "MN3" 
3cb9 f5				push af  
3cba 3a ce 3c			ld a, (.dmark)  
3cbd 32 77 fb			ld (debug_mark),a  
3cc0 3a cf 3c			ld a, (.dmark+1)  
3cc3 32 78 fb			ld (debug_mark+1),a  
3cc6 3a d0 3c			ld a, (.dmark+2)  
3cc9 32 79 fb			ld (debug_mark+2),a  
3ccc 18 03			jr .pastdmark  
3cce ..			.dmark: db "MN3"  
3cd1 f1			.pastdmark: pop af  
3cd2			endm  
# End of macro DMARK
3cd2						CALLMONITOR 
3cd2 cd 01 15			call break_point_state  
3cd5				endm  
# End of macro CALLMONITOR
3cd5					endif 
3cd5 eb					ex de, hl 
3cd6 73					ld (hl), e 
3cd7 23					inc hl 
3cd8 72					ld (hl), d 
3cd9 23					inc hl 
3cda eb					ex de, hl 
3cdb			 
3cdb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cdb cd d2 1b			call macro_forth_dsp_pop 
3cde				endm 
# End of macro FORTH_DSP_POP
3cde			 
3cde 10 d6				djnz .mbuild 
3ce0			 
3ce0					; done add term 
3ce0			 
3ce0 eb					ex de, hl 
3ce1 36 00				ld (hl), 0 
3ce3 23					inc hl 
3ce4 36 00				ld (hl), 0 
3ce6			 
3ce6				 
3ce6					 
3ce6 21 32 ee				ld hl, scratch 
3ce9			 
3ce9					if DEBUG_FORTH_WORDS 
3ce9						DMARK "MNx" 
3ce9 f5				push af  
3cea 3a fe 3c			ld a, (.dmark)  
3ced 32 77 fb			ld (debug_mark),a  
3cf0 3a ff 3c			ld a, (.dmark+1)  
3cf3 32 78 fb			ld (debug_mark+1),a  
3cf6 3a 00 3d			ld a, (.dmark+2)  
3cf9 32 79 fb			ld (debug_mark+2),a  
3cfc 18 03			jr .pastdmark  
3cfe ..			.dmark: db "MNx"  
3d01 f1			.pastdmark: pop af  
3d02			endm  
# End of macro DMARK
3d02						CALLMONITOR 
3d02 cd 01 15			call break_point_state  
3d05				endm  
# End of macro CALLMONITOR
3d05					endif 
3d05			 
3d05			 
3d05			 
3d05 3e 00				ld a, 0 
3d07 cd c0 0a				call menu 
3d0a			 
3d0a			 
3d0a 6f					ld l, a 
3d0b 26 00				ld h, 0 
3d0d			 
3d0d					if DEBUG_FORTH_WORDS 
3d0d						DMARK "MNr" 
3d0d f5				push af  
3d0e 3a 22 3d			ld a, (.dmark)  
3d11 32 77 fb			ld (debug_mark),a  
3d14 3a 23 3d			ld a, (.dmark+1)  
3d17 32 78 fb			ld (debug_mark+1),a  
3d1a 3a 24 3d			ld a, (.dmark+2)  
3d1d 32 79 fb			ld (debug_mark+2),a  
3d20 18 03			jr .pastdmark  
3d22 ..			.dmark: db "MNr"  
3d25 f1			.pastdmark: pop af  
3d26			endm  
# End of macro DMARK
3d26						CALLMONITOR 
3d26 cd 01 15			call break_point_state  
3d29				endm  
# End of macro CALLMONITOR
3d29					endif 
3d29			 
3d29 cd 9b 1a				call forth_push_numhl 
3d2c			 
3d2c			 
3d2c			 
3d2c			 
3d2c				       NEXTW 
3d2c c3 8c 1c			jp macro_next 
3d2f				endm 
# End of macro NEXTW
3d2f			 
3d2f			 
3d2f			.ENDDISPLAY: 
3d2f			 
3d2f			; eof 
# End of file forth_words_display.asm
3d2f			include "forth_words_str.asm" 
3d2f			 
3d2f			; | ## String Words 
3d2f			 
3d2f			.PTR:   
3d2f			 
3d2f				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3d2f 48				db WORD_SYS_CORE+52             
3d30 5c 3d			dw .STYPE            
3d32 04				db 3 + 1 
3d33 .. 00			db "PTR",0              
3d37				endm 
# End of macro CWHEAD
3d37			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3d37			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3d37			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3d37			 
3d37					if DEBUG_FORTH_WORDS_KEY 
3d37						DMARK "PTR" 
3d37 f5				push af  
3d38 3a 4c 3d			ld a, (.dmark)  
3d3b 32 77 fb			ld (debug_mark),a  
3d3e 3a 4d 3d			ld a, (.dmark+1)  
3d41 32 78 fb			ld (debug_mark+1),a  
3d44 3a 4e 3d			ld a, (.dmark+2)  
3d47 32 79 fb			ld (debug_mark+2),a  
3d4a 18 03			jr .pastdmark  
3d4c ..			.dmark: db "PTR"  
3d4f f1			.pastdmark: pop af  
3d50			endm  
# End of macro DMARK
3d50						CALLMONITOR 
3d50 cd 01 15			call break_point_state  
3d53				endm  
# End of macro CALLMONITOR
3d53					endif 
3d53					FORTH_DSP_VALUEHL 
3d53 cd 36 1b			call macro_dsp_valuehl 
3d56				endm 
# End of macro FORTH_DSP_VALUEHL
3d56 cd 9b 1a				call forth_push_numhl 
3d59			 
3d59			 
3d59					NEXTW 
3d59 c3 8c 1c			jp macro_next 
3d5c				endm 
# End of macro NEXTW
3d5c			.STYPE: 
3d5c				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3d5c 48				db WORD_SYS_CORE+52             
3d5d ab 3d			dw .UPPER            
3d5f 06				db 5 + 1 
3d60 .. 00			db "STYPE",0              
3d66				endm 
# End of macro CWHEAD
3d66			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3d66					if DEBUG_FORTH_WORDS_KEY 
3d66						DMARK "STY" 
3d66 f5				push af  
3d67 3a 7b 3d			ld a, (.dmark)  
3d6a 32 77 fb			ld (debug_mark),a  
3d6d 3a 7c 3d			ld a, (.dmark+1)  
3d70 32 78 fb			ld (debug_mark+1),a  
3d73 3a 7d 3d			ld a, (.dmark+2)  
3d76 32 79 fb			ld (debug_mark+2),a  
3d79 18 03			jr .pastdmark  
3d7b ..			.dmark: db "STY"  
3d7e f1			.pastdmark: pop af  
3d7f			endm  
# End of macro DMARK
3d7f						CALLMONITOR 
3d7f cd 01 15			call break_point_state  
3d82				endm  
# End of macro CALLMONITOR
3d82					endif 
3d82					FORTH_DSP 
3d82 cd 1b 1b			call macro_forth_dsp 
3d85				endm 
# End of macro FORTH_DSP
3d85					;v5 FORTH_DSP_VALUE 
3d85			 
3d85 7e					ld a, (hl) 
3d86			 
3d86 f5					push af 
3d87			 
3d87			; Dont destroy TOS		FORTH_DSP_POP 
3d87			 
3d87 f1					pop af 
3d88			 
3d88 fe 01				cp DS_TYPE_STR 
3d8a 28 09				jr z, .typestr 
3d8c			 
3d8c fe 02				cp DS_TYPE_INUM 
3d8e 28 0a				jr z, .typeinum 
3d90			 
3d90 21 a9 3d				ld hl, .tna 
3d93 18 0a				jr .tpush 
3d95			 
3d95 21 a5 3d		.typestr:	ld hl, .tstr 
3d98 18 05				jr .tpush 
3d9a 21 a7 3d		.typeinum:	ld hl, .tinum 
3d9d 18 00				jr .tpush 
3d9f			 
3d9f			.tpush: 
3d9f			 
3d9f cd ad 1a				call forth_push_str 
3da2			 
3da2					NEXTW 
3da2 c3 8c 1c			jp macro_next 
3da5				endm 
# End of macro NEXTW
3da5 .. 00		.tstr:	db "s",0 
3da7 .. 00		.tinum:  db "i",0 
3da9 .. 00		.tna:   db "?", 0 
3dab			 
3dab			 
3dab			.UPPER: 
3dab				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3dab 48				db WORD_SYS_CORE+52             
3dac e6 3d			dw .LOWER            
3dae 06				db 5 + 1 
3daf .. 00			db "UPPER",0              
3db5				endm 
# End of macro CWHEAD
3db5			; | UPPER ( s -- s ) Upper case string s  | DONE 
3db5					if DEBUG_FORTH_WORDS_KEY 
3db5						DMARK "UPR" 
3db5 f5				push af  
3db6 3a ca 3d			ld a, (.dmark)  
3db9 32 77 fb			ld (debug_mark),a  
3dbc 3a cb 3d			ld a, (.dmark+1)  
3dbf 32 78 fb			ld (debug_mark+1),a  
3dc2 3a cc 3d			ld a, (.dmark+2)  
3dc5 32 79 fb			ld (debug_mark+2),a  
3dc8 18 03			jr .pastdmark  
3dca ..			.dmark: db "UPR"  
3dcd f1			.pastdmark: pop af  
3dce			endm  
# End of macro DMARK
3dce						CALLMONITOR 
3dce cd 01 15			call break_point_state  
3dd1				endm  
# End of macro CALLMONITOR
3dd1					endif 
3dd1			 
3dd1					FORTH_DSP 
3dd1 cd 1b 1b			call macro_forth_dsp 
3dd4				endm 
# End of macro FORTH_DSP
3dd4					 
3dd4			; TODO check is string type 
3dd4			 
3dd4					FORTH_DSP_VALUEHL 
3dd4 cd 36 1b			call macro_dsp_valuehl 
3dd7				endm 
# End of macro FORTH_DSP_VALUEHL
3dd7			; get pointer to string in hl 
3dd7			 
3dd7 7e			.toup:		ld a, (hl) 
3dd8 fe 00				cp 0 
3dda 28 07				jr z, .toupdone 
3ddc			 
3ddc cd 2c 10				call to_upper 
3ddf			 
3ddf 77					ld (hl), a 
3de0 23					inc hl 
3de1 18 f4				jr .toup 
3de3			 
3de3					 
3de3			 
3de3			 
3de3			; for each char convert to upper 
3de3					 
3de3			.toupdone: 
3de3			 
3de3			 
3de3					NEXTW 
3de3 c3 8c 1c			jp macro_next 
3de6				endm 
# End of macro NEXTW
3de6			.LOWER: 
3de6				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3de6 48				db WORD_SYS_CORE+52             
3de7 21 3e			dw .TCASE            
3de9 06				db 5 + 1 
3dea .. 00			db "LOWER",0              
3df0				endm 
# End of macro CWHEAD
3df0			; | LOWER ( s -- s ) Lower case string s  | DONE 
3df0					if DEBUG_FORTH_WORDS_KEY 
3df0						DMARK "LWR" 
3df0 f5				push af  
3df1 3a 05 3e			ld a, (.dmark)  
3df4 32 77 fb			ld (debug_mark),a  
3df7 3a 06 3e			ld a, (.dmark+1)  
3dfa 32 78 fb			ld (debug_mark+1),a  
3dfd 3a 07 3e			ld a, (.dmark+2)  
3e00 32 79 fb			ld (debug_mark+2),a  
3e03 18 03			jr .pastdmark  
3e05 ..			.dmark: db "LWR"  
3e08 f1			.pastdmark: pop af  
3e09			endm  
# End of macro DMARK
3e09						CALLMONITOR 
3e09 cd 01 15			call break_point_state  
3e0c				endm  
# End of macro CALLMONITOR
3e0c					endif 
3e0c			 
3e0c					FORTH_DSP 
3e0c cd 1b 1b			call macro_forth_dsp 
3e0f				endm 
# End of macro FORTH_DSP
3e0f					 
3e0f			; TODO check is string type 
3e0f			 
3e0f					FORTH_DSP_VALUEHL 
3e0f cd 36 1b			call macro_dsp_valuehl 
3e12				endm 
# End of macro FORTH_DSP_VALUEHL
3e12			; get pointer to string in hl 
3e12			 
3e12 7e			.tolow:		ld a, (hl) 
3e13 fe 00				cp 0 
3e15 28 07				jr z, .tolowdone 
3e17			 
3e17 cd 35 10				call to_lower 
3e1a			 
3e1a 77					ld (hl), a 
3e1b 23					inc hl 
3e1c 18 f4				jr .tolow 
3e1e			 
3e1e					 
3e1e			 
3e1e			 
3e1e			; for each char convert to low 
3e1e					 
3e1e			.tolowdone: 
3e1e					NEXTW 
3e1e c3 8c 1c			jp macro_next 
3e21				endm 
# End of macro NEXTW
3e21			.TCASE: 
3e21				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3e21 48				db WORD_SYS_CORE+52             
3e22 57 3f			dw .SUBSTR            
3e24 06				db 5 + 1 
3e25 .. 00			db "TCASE",0              
3e2b				endm 
# End of macro CWHEAD
3e2b			; | TCASE ( s -- s ) Title case string s  | DONE 
3e2b					if DEBUG_FORTH_WORDS_KEY 
3e2b						DMARK "TCS" 
3e2b f5				push af  
3e2c 3a 40 3e			ld a, (.dmark)  
3e2f 32 77 fb			ld (debug_mark),a  
3e32 3a 41 3e			ld a, (.dmark+1)  
3e35 32 78 fb			ld (debug_mark+1),a  
3e38 3a 42 3e			ld a, (.dmark+2)  
3e3b 32 79 fb			ld (debug_mark+2),a  
3e3e 18 03			jr .pastdmark  
3e40 ..			.dmark: db "TCS"  
3e43 f1			.pastdmark: pop af  
3e44			endm  
# End of macro DMARK
3e44						CALLMONITOR 
3e44 cd 01 15			call break_point_state  
3e47				endm  
# End of macro CALLMONITOR
3e47					endif 
3e47			 
3e47					FORTH_DSP 
3e47 cd 1b 1b			call macro_forth_dsp 
3e4a				endm 
# End of macro FORTH_DSP
3e4a					 
3e4a			; TODO check is string type 
3e4a			 
3e4a					FORTH_DSP_VALUEHL 
3e4a cd 36 1b			call macro_dsp_valuehl 
3e4d				endm 
# End of macro FORTH_DSP_VALUEHL
3e4d			; get pointer to string in hl 
3e4d			 
3e4d					if DEBUG_FORTH_WORDS 
3e4d						DMARK "TC1" 
3e4d f5				push af  
3e4e 3a 62 3e			ld a, (.dmark)  
3e51 32 77 fb			ld (debug_mark),a  
3e54 3a 63 3e			ld a, (.dmark+1)  
3e57 32 78 fb			ld (debug_mark+1),a  
3e5a 3a 64 3e			ld a, (.dmark+2)  
3e5d 32 79 fb			ld (debug_mark+2),a  
3e60 18 03			jr .pastdmark  
3e62 ..			.dmark: db "TC1"  
3e65 f1			.pastdmark: pop af  
3e66			endm  
# End of macro DMARK
3e66						CALLMONITOR 
3e66 cd 01 15			call break_point_state  
3e69				endm  
# End of macro CALLMONITOR
3e69					endif 
3e69			 
3e69					; first time in turn to upper case first char 
3e69			 
3e69 7e					ld a, (hl) 
3e6a c3 f4 3e				jp .totsiptou 
3e6d			 
3e6d			 
3e6d 7e			.tot:		ld a, (hl) 
3e6e fe 00				cp 0 
3e70 ca 38 3f				jp z, .totdone 
3e73			 
3e73					if DEBUG_FORTH_WORDS 
3e73						DMARK "TC2" 
3e73 f5				push af  
3e74 3a 88 3e			ld a, (.dmark)  
3e77 32 77 fb			ld (debug_mark),a  
3e7a 3a 89 3e			ld a, (.dmark+1)  
3e7d 32 78 fb			ld (debug_mark+1),a  
3e80 3a 8a 3e			ld a, (.dmark+2)  
3e83 32 79 fb			ld (debug_mark+2),a  
3e86 18 03			jr .pastdmark  
3e88 ..			.dmark: db "TC2"  
3e8b f1			.pastdmark: pop af  
3e8c			endm  
# End of macro DMARK
3e8c						CALLMONITOR 
3e8c cd 01 15			call break_point_state  
3e8f				endm  
# End of macro CALLMONITOR
3e8f					endif 
3e8f					; check to see if current char is a space 
3e8f			 
3e8f fe 20				cp ' ' 
3e91 28 21				jr z, .totsp 
3e93 cd 35 10				call to_lower 
3e96					if DEBUG_FORTH_WORDS 
3e96						DMARK "TC3" 
3e96 f5				push af  
3e97 3a ab 3e			ld a, (.dmark)  
3e9a 32 77 fb			ld (debug_mark),a  
3e9d 3a ac 3e			ld a, (.dmark+1)  
3ea0 32 78 fb			ld (debug_mark+1),a  
3ea3 3a ad 3e			ld a, (.dmark+2)  
3ea6 32 79 fb			ld (debug_mark+2),a  
3ea9 18 03			jr .pastdmark  
3eab ..			.dmark: db "TC3"  
3eae f1			.pastdmark: pop af  
3eaf			endm  
# End of macro DMARK
3eaf						CALLMONITOR 
3eaf cd 01 15			call break_point_state  
3eb2				endm  
# End of macro CALLMONITOR
3eb2					endif 
3eb2 18 63				jr .totnxt 
3eb4			 
3eb4			.totsp:         ; on a space, find next char which should be upper 
3eb4			 
3eb4					if DEBUG_FORTH_WORDS 
3eb4						DMARK "TC4" 
3eb4 f5				push af  
3eb5 3a c9 3e			ld a, (.dmark)  
3eb8 32 77 fb			ld (debug_mark),a  
3ebb 3a ca 3e			ld a, (.dmark+1)  
3ebe 32 78 fb			ld (debug_mark+1),a  
3ec1 3a cb 3e			ld a, (.dmark+2)  
3ec4 32 79 fb			ld (debug_mark+2),a  
3ec7 18 03			jr .pastdmark  
3ec9 ..			.dmark: db "TC4"  
3ecc f1			.pastdmark: pop af  
3ecd			endm  
# End of macro DMARK
3ecd						CALLMONITOR 
3ecd cd 01 15			call break_point_state  
3ed0				endm  
# End of macro CALLMONITOR
3ed0					endif 
3ed0					;; 
3ed0			 
3ed0 fe 20				cp ' ' 
3ed2 20 20				jr nz, .totsiptou 
3ed4 23					inc hl 
3ed5 7e					ld a, (hl) 
3ed6					if DEBUG_FORTH_WORDS 
3ed6						DMARK "TC5" 
3ed6 f5				push af  
3ed7 3a eb 3e			ld a, (.dmark)  
3eda 32 77 fb			ld (debug_mark),a  
3edd 3a ec 3e			ld a, (.dmark+1)  
3ee0 32 78 fb			ld (debug_mark+1),a  
3ee3 3a ed 3e			ld a, (.dmark+2)  
3ee6 32 79 fb			ld (debug_mark+2),a  
3ee9 18 03			jr .pastdmark  
3eeb ..			.dmark: db "TC5"  
3eee f1			.pastdmark: pop af  
3eef			endm  
# End of macro DMARK
3eef						CALLMONITOR 
3eef cd 01 15			call break_point_state  
3ef2				endm  
# End of macro CALLMONITOR
3ef2					endif 
3ef2 18 c0				jr .totsp 
3ef4 fe 00		.totsiptou:    cp 0 
3ef6 28 40				jr z, .totdone 
3ef8					; not space and not zero term so upper case it 
3ef8 cd 2c 10				call to_upper 
3efb			 
3efb					if DEBUG_FORTH_WORDS 
3efb						DMARK "TC6" 
3efb f5				push af  
3efc 3a 10 3f			ld a, (.dmark)  
3eff 32 77 fb			ld (debug_mark),a  
3f02 3a 11 3f			ld a, (.dmark+1)  
3f05 32 78 fb			ld (debug_mark+1),a  
3f08 3a 12 3f			ld a, (.dmark+2)  
3f0b 32 79 fb			ld (debug_mark+2),a  
3f0e 18 03			jr .pastdmark  
3f10 ..			.dmark: db "TC6"  
3f13 f1			.pastdmark: pop af  
3f14			endm  
# End of macro DMARK
3f14						CALLMONITOR 
3f14 cd 01 15			call break_point_state  
3f17				endm  
# End of macro CALLMONITOR
3f17					endif 
3f17			 
3f17			 
3f17			.totnxt: 
3f17			 
3f17 77					ld (hl), a 
3f18 23					inc hl 
3f19					if DEBUG_FORTH_WORDS 
3f19						DMARK "TC7" 
3f19 f5				push af  
3f1a 3a 2e 3f			ld a, (.dmark)  
3f1d 32 77 fb			ld (debug_mark),a  
3f20 3a 2f 3f			ld a, (.dmark+1)  
3f23 32 78 fb			ld (debug_mark+1),a  
3f26 3a 30 3f			ld a, (.dmark+2)  
3f29 32 79 fb			ld (debug_mark+2),a  
3f2c 18 03			jr .pastdmark  
3f2e ..			.dmark: db "TC7"  
3f31 f1			.pastdmark: pop af  
3f32			endm  
# End of macro DMARK
3f32						CALLMONITOR 
3f32 cd 01 15			call break_point_state  
3f35				endm  
# End of macro CALLMONITOR
3f35					endif 
3f35 c3 6d 3e				jp .tot 
3f38			 
3f38					 
3f38			 
3f38			 
3f38			; for each char convert to low 
3f38					 
3f38			.totdone: 
3f38					if DEBUG_FORTH_WORDS 
3f38						DMARK "TCd" 
3f38 f5				push af  
3f39 3a 4d 3f			ld a, (.dmark)  
3f3c 32 77 fb			ld (debug_mark),a  
3f3f 3a 4e 3f			ld a, (.dmark+1)  
3f42 32 78 fb			ld (debug_mark+1),a  
3f45 3a 4f 3f			ld a, (.dmark+2)  
3f48 32 79 fb			ld (debug_mark+2),a  
3f4b 18 03			jr .pastdmark  
3f4d ..			.dmark: db "TCd"  
3f50 f1			.pastdmark: pop af  
3f51			endm  
# End of macro DMARK
3f51						CALLMONITOR 
3f51 cd 01 15			call break_point_state  
3f54				endm  
# End of macro CALLMONITOR
3f54					endif 
3f54					NEXTW 
3f54 c3 8c 1c			jp macro_next 
3f57				endm 
# End of macro NEXTW
3f57			 
3f57			.SUBSTR: 
3f57				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
3f57 48				db WORD_SYS_CORE+52             
3f58 b5 3f			dw .LEFT            
3f5a 07				db 6 + 1 
3f5b .. 00			db "SUBSTR",0              
3f62				endm 
# End of macro CWHEAD
3f62			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3f62			 
3f62					if DEBUG_FORTH_WORDS_KEY 
3f62						DMARK "SST" 
3f62 f5				push af  
3f63 3a 77 3f			ld a, (.dmark)  
3f66 32 77 fb			ld (debug_mark),a  
3f69 3a 78 3f			ld a, (.dmark+1)  
3f6c 32 78 fb			ld (debug_mark+1),a  
3f6f 3a 79 3f			ld a, (.dmark+2)  
3f72 32 79 fb			ld (debug_mark+2),a  
3f75 18 03			jr .pastdmark  
3f77 ..			.dmark: db "SST"  
3f7a f1			.pastdmark: pop af  
3f7b			endm  
# End of macro DMARK
3f7b						CALLMONITOR 
3f7b cd 01 15			call break_point_state  
3f7e				endm  
# End of macro CALLMONITOR
3f7e					endif 
3f7e			; TODO check string type 
3f7e					FORTH_DSP_VALUEHL 
3f7e cd 36 1b			call macro_dsp_valuehl 
3f81				endm 
# End of macro FORTH_DSP_VALUEHL
3f81			 
3f81 e5					push hl      ; string length 
3f82			 
3f82					FORTH_DSP_POP 
3f82 cd d2 1b			call macro_forth_dsp_pop 
3f85				endm 
# End of macro FORTH_DSP_POP
3f85			 
3f85					FORTH_DSP_VALUEHL 
3f85 cd 36 1b			call macro_dsp_valuehl 
3f88				endm 
# End of macro FORTH_DSP_VALUEHL
3f88			 
3f88 e5					push hl     ; start char 
3f89			 
3f89					FORTH_DSP_POP 
3f89 cd d2 1b			call macro_forth_dsp_pop 
3f8c				endm 
# End of macro FORTH_DSP_POP
3f8c			 
3f8c			 
3f8c					FORTH_DSP_VALUE 
3f8c cd 1f 1b			call macro_forth_dsp_value 
3f8f				endm 
# End of macro FORTH_DSP_VALUE
3f8f			 
3f8f d1					pop de    ; get start post offset 
3f90			 
3f90 19					add hl, de    ; starting offset 
3f91			 
3f91 c1					pop bc 
3f92 c5					push bc      ; grab size of string 
3f93			 
3f93 e5					push hl    ; save string start  
3f94			 
3f94 26 00				ld h, 0 
3f96 69					ld l, c 
3f97 23					inc hl 
3f98 23					inc hl 
3f99			 
3f99 cd 86 11				call malloc 
3f9c				if DEBUG_FORTH_MALLOC_GUARD 
3f9c cc 37 4f				call z,malloc_error 
3f9f				endif 
3f9f			 
3f9f eb					ex de, hl      ; save malloc area for string copy 
3fa0 e1					pop hl    ; get back source 
3fa1 c1					pop bc    ; get length of string back 
3fa2			 
3fa2 d5					push de    ; save malloc area for after we push 
3fa3 ed b0				ldir     ; copy substr 
3fa5			 
3fa5			 
3fa5 eb					ex de, hl 
3fa6 3e 00				ld a, 0 
3fa8 77					ld (hl), a   ; term substr 
3fa9			 
3fa9					 
3fa9 e1					pop hl    ; get malloc so we can push it 
3faa e5					push hl   ; save so we can free it afterwards 
3fab			 
3fab cd ad 1a				call forth_push_str 
3fae			 
3fae e1					pop hl 
3faf cd 50 12				call free 
3fb2			 
3fb2					 
3fb2					 
3fb2			 
3fb2			 
3fb2					NEXTW 
3fb2 c3 8c 1c			jp macro_next 
3fb5				endm 
# End of macro NEXTW
3fb5			 
3fb5			.LEFT: 
3fb5				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
3fb5 48				db WORD_SYS_CORE+52             
3fb6 dd 3f			dw .RIGHT            
3fb8 05				db 4 + 1 
3fb9 .. 00			db "LEFT",0              
3fbe				endm 
# End of macro CWHEAD
3fbe			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
3fbe					if DEBUG_FORTH_WORDS_KEY 
3fbe						DMARK "LEF" 
3fbe f5				push af  
3fbf 3a d3 3f			ld a, (.dmark)  
3fc2 32 77 fb			ld (debug_mark),a  
3fc5 3a d4 3f			ld a, (.dmark+1)  
3fc8 32 78 fb			ld (debug_mark+1),a  
3fcb 3a d5 3f			ld a, (.dmark+2)  
3fce 32 79 fb			ld (debug_mark+2),a  
3fd1 18 03			jr .pastdmark  
3fd3 ..			.dmark: db "LEF"  
3fd6 f1			.pastdmark: pop af  
3fd7			endm  
# End of macro DMARK
3fd7						CALLMONITOR 
3fd7 cd 01 15			call break_point_state  
3fda				endm  
# End of macro CALLMONITOR
3fda					endif 
3fda			 
3fda					NEXTW 
3fda c3 8c 1c			jp macro_next 
3fdd				endm 
# End of macro NEXTW
3fdd			.RIGHT: 
3fdd				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
3fdd 48				db WORD_SYS_CORE+52             
3fde 06 40			dw .STR2NUM            
3fe0 06				db 5 + 1 
3fe1 .. 00			db "RIGHT",0              
3fe7				endm 
# End of macro CWHEAD
3fe7			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
3fe7					if DEBUG_FORTH_WORDS_KEY 
3fe7						DMARK "RIG" 
3fe7 f5				push af  
3fe8 3a fc 3f			ld a, (.dmark)  
3feb 32 77 fb			ld (debug_mark),a  
3fee 3a fd 3f			ld a, (.dmark+1)  
3ff1 32 78 fb			ld (debug_mark+1),a  
3ff4 3a fe 3f			ld a, (.dmark+2)  
3ff7 32 79 fb			ld (debug_mark+2),a  
3ffa 18 03			jr .pastdmark  
3ffc ..			.dmark: db "RIG"  
3fff f1			.pastdmark: pop af  
4000			endm  
# End of macro DMARK
4000						CALLMONITOR 
4000 cd 01 15			call break_point_state  
4003				endm  
# End of macro CALLMONITOR
4003					endif 
4003			 
4003					NEXTW 
4003 c3 8c 1c			jp macro_next 
4006				endm 
# End of macro NEXTW
4006			 
4006			 
4006			.STR2NUM: 
4006				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4006 48				db WORD_SYS_CORE+52             
4007 92 40			dw .NUM2STR            
4009 08				db 7 + 1 
400a .. 00			db "STR2NUM",0              
4012				endm 
# End of macro CWHEAD
4012			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4012			 
4012			 
4012			; TODO STR type check to do 
4012					if DEBUG_FORTH_WORDS_KEY 
4012						DMARK "S2N" 
4012 f5				push af  
4013 3a 27 40			ld a, (.dmark)  
4016 32 77 fb			ld (debug_mark),a  
4019 3a 28 40			ld a, (.dmark+1)  
401c 32 78 fb			ld (debug_mark+1),a  
401f 3a 29 40			ld a, (.dmark+2)  
4022 32 79 fb			ld (debug_mark+2),a  
4025 18 03			jr .pastdmark  
4027 ..			.dmark: db "S2N"  
402a f1			.pastdmark: pop af  
402b			endm  
# End of macro DMARK
402b						CALLMONITOR 
402b cd 01 15			call break_point_state  
402e				endm  
# End of macro CALLMONITOR
402e					endif 
402e			 
402e					;FORTH_DSP 
402e					FORTH_DSP_VALUE 
402e cd 1f 1b			call macro_forth_dsp_value 
4031				endm 
# End of macro FORTH_DSP_VALUE
4031					;inc hl 
4031			 
4031 eb					ex de, hl 
4032					if DEBUG_FORTH_WORDS 
4032						DMARK "S2a" 
4032 f5				push af  
4033 3a 47 40			ld a, (.dmark)  
4036 32 77 fb			ld (debug_mark),a  
4039 3a 48 40			ld a, (.dmark+1)  
403c 32 78 fb			ld (debug_mark+1),a  
403f 3a 49 40			ld a, (.dmark+2)  
4042 32 79 fb			ld (debug_mark+2),a  
4045 18 03			jr .pastdmark  
4047 ..			.dmark: db "S2a"  
404a f1			.pastdmark: pop af  
404b			endm  
# End of macro DMARK
404b						CALLMONITOR 
404b cd 01 15			call break_point_state  
404e				endm  
# End of macro CALLMONITOR
404e					endif 
404e cd b4 10				call string_to_uint16 
4051			 
4051					if DEBUG_FORTH_WORDS 
4051						DMARK "S2b" 
4051 f5				push af  
4052 3a 66 40			ld a, (.dmark)  
4055 32 77 fb			ld (debug_mark),a  
4058 3a 67 40			ld a, (.dmark+1)  
405b 32 78 fb			ld (debug_mark+1),a  
405e 3a 68 40			ld a, (.dmark+2)  
4061 32 79 fb			ld (debug_mark+2),a  
4064 18 03			jr .pastdmark  
4066 ..			.dmark: db "S2b"  
4069 f1			.pastdmark: pop af  
406a			endm  
# End of macro DMARK
406a						CALLMONITOR 
406a cd 01 15			call break_point_state  
406d				endm  
# End of macro CALLMONITOR
406d					endif 
406d			;		push hl 
406d					FORTH_DSP_POP 
406d cd d2 1b			call macro_forth_dsp_pop 
4070				endm 
# End of macro FORTH_DSP_POP
4070			;		pop hl 
4070					 
4070					if DEBUG_FORTH_WORDS 
4070						DMARK "S2b" 
4070 f5				push af  
4071 3a 85 40			ld a, (.dmark)  
4074 32 77 fb			ld (debug_mark),a  
4077 3a 86 40			ld a, (.dmark+1)  
407a 32 78 fb			ld (debug_mark+1),a  
407d 3a 87 40			ld a, (.dmark+2)  
4080 32 79 fb			ld (debug_mark+2),a  
4083 18 03			jr .pastdmark  
4085 ..			.dmark: db "S2b"  
4088 f1			.pastdmark: pop af  
4089			endm  
# End of macro DMARK
4089						CALLMONITOR 
4089 cd 01 15			call break_point_state  
408c				endm  
# End of macro CALLMONITOR
408c					endif 
408c cd 9b 1a				call forth_push_numhl	 
408f			 
408f				 
408f				       NEXTW 
408f c3 8c 1c			jp macro_next 
4092				endm 
# End of macro NEXTW
4092			.NUM2STR: 
4092				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4092 48				db WORD_SYS_CORE+52             
4093 a1 40			dw .CONCAT            
4095 08				db 7 + 1 
4096 .. 00			db "NUM2STR",0              
409e				endm 
# End of macro CWHEAD
409e			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
409e			 
409e			;		; malloc a string to target 
409e			;		ld hl, 10     ; TODO max string size should be fine 
409e			;		call malloc 
409e			;		push hl    ; save malloc location 
409e			; 
409e			; 
409e			;; TODO check int type 
409e			;		FORTH_DSP_VALUEHL 
409e			;		ld a, l 
409e			;		call DispAToASCII   
409e			;;TODO need to chage above call to dump into string 
409e			; 
409e			; 
409e			 
409e				       NEXTW 
409e c3 8c 1c			jp macro_next 
40a1				endm 
# End of macro NEXTW
40a1			 
40a1			.CONCAT: 
40a1				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
40a1 48				db WORD_SYS_CORE+52             
40a2 54 41			dw .FIND            
40a4 07				db 6 + 1 
40a5 .. 00			db "CONCAT",0              
40ac				endm 
# End of macro CWHEAD
40ac			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
40ac			 
40ac			; TODO check string type 
40ac			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
40ac			 
40ac					if DEBUG_FORTH_WORDS_KEY 
40ac						DMARK "CON" 
40ac f5				push af  
40ad 3a c1 40			ld a, (.dmark)  
40b0 32 77 fb			ld (debug_mark),a  
40b3 3a c2 40			ld a, (.dmark+1)  
40b6 32 78 fb			ld (debug_mark+1),a  
40b9 3a c3 40			ld a, (.dmark+2)  
40bc 32 79 fb			ld (debug_mark+2),a  
40bf 18 03			jr .pastdmark  
40c1 ..			.dmark: db "CON"  
40c4 f1			.pastdmark: pop af  
40c5			endm  
# End of macro DMARK
40c5						CALLMONITOR 
40c5 cd 01 15			call break_point_state  
40c8				endm  
# End of macro CALLMONITOR
40c8					endif 
40c8			 
40c8			 
40c8					FORTH_DSP_VALUE 
40c8 cd 1f 1b			call macro_forth_dsp_value 
40cb				endm 
# End of macro FORTH_DSP_VALUE
40cb e5					push hl   ; s2 
40cc			 
40cc					FORTH_DSP_POP 
40cc cd d2 1b			call macro_forth_dsp_pop 
40cf				endm 
# End of macro FORTH_DSP_POP
40cf			 
40cf					FORTH_DSP_VALUE 
40cf cd 1f 1b			call macro_forth_dsp_value 
40d2				endm 
# End of macro FORTH_DSP_VALUE
40d2			 
40d2 e5					push hl   ; s1 
40d3			 
40d3					FORTH_DSP_POP 
40d3 cd d2 1b			call macro_forth_dsp_pop 
40d6				endm 
# End of macro FORTH_DSP_POP
40d6					 
40d6			 
40d6					; copy s1 
40d6			 
40d6				 
40d6					; save ptr 
40d6 e1					pop hl  
40d7 e5					push hl 
40d8 3e 00				ld a, 0 
40da cd 28 11				call strlent 
40dd					;inc hl    ; zer0 
40dd 06 00				ld b, 0 
40df 4d					ld c, l 
40e0 e1					pop hl		 
40e1 11 32 ee				ld de, scratch	 
40e4					if DEBUG_FORTH_WORDS 
40e4						DMARK "CO1" 
40e4 f5				push af  
40e5 3a f9 40			ld a, (.dmark)  
40e8 32 77 fb			ld (debug_mark),a  
40eb 3a fa 40			ld a, (.dmark+1)  
40ee 32 78 fb			ld (debug_mark+1),a  
40f1 3a fb 40			ld a, (.dmark+2)  
40f4 32 79 fb			ld (debug_mark+2),a  
40f7 18 03			jr .pastdmark  
40f9 ..			.dmark: db "CO1"  
40fc f1			.pastdmark: pop af  
40fd			endm  
# End of macro DMARK
40fd						CALLMONITOR 
40fd cd 01 15			call break_point_state  
4100				endm  
# End of macro CALLMONITOR
4100					endif 
4100 ed b0				ldir 
4102			 
4102 e1					pop hl 
4103 e5					push hl 
4104 d5					push de 
4105			 
4105			 
4105 3e 00				ld a, 0 
4107 cd 28 11				call strlent 
410a 23					inc hl    ; zer0 
410b 23					inc hl 
410c 06 00				ld b, 0 
410e 4d					ld c, l 
410f d1					pop de 
4110 e1					pop hl		 
4111					if DEBUG_FORTH_WORDS 
4111						DMARK "CO2" 
4111 f5				push af  
4112 3a 26 41			ld a, (.dmark)  
4115 32 77 fb			ld (debug_mark),a  
4118 3a 27 41			ld a, (.dmark+1)  
411b 32 78 fb			ld (debug_mark+1),a  
411e 3a 28 41			ld a, (.dmark+2)  
4121 32 79 fb			ld (debug_mark+2),a  
4124 18 03			jr .pastdmark  
4126 ..			.dmark: db "CO2"  
4129 f1			.pastdmark: pop af  
412a			endm  
# End of macro DMARK
412a						CALLMONITOR 
412a cd 01 15			call break_point_state  
412d				endm  
# End of macro CALLMONITOR
412d					endif 
412d ed b0				ldir 
412f			 
412f			 
412f			 
412f 21 32 ee				ld hl, scratch 
4132					if DEBUG_FORTH_WORDS 
4132						DMARK "CO5" 
4132 f5				push af  
4133 3a 47 41			ld a, (.dmark)  
4136 32 77 fb			ld (debug_mark),a  
4139 3a 48 41			ld a, (.dmark+1)  
413c 32 78 fb			ld (debug_mark+1),a  
413f 3a 49 41			ld a, (.dmark+2)  
4142 32 79 fb			ld (debug_mark+2),a  
4145 18 03			jr .pastdmark  
4147 ..			.dmark: db "CO5"  
414a f1			.pastdmark: pop af  
414b			endm  
# End of macro DMARK
414b						CALLMONITOR 
414b cd 01 15			call break_point_state  
414e				endm  
# End of macro CALLMONITOR
414e					endif 
414e			 
414e cd ad 1a				call forth_push_str 
4151			 
4151			 
4151			 
4151			 
4151				       NEXTW 
4151 c3 8c 1c			jp macro_next 
4154				endm 
# End of macro NEXTW
4154			 
4154			 
4154			.FIND: 
4154				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4154 4b				db WORD_SYS_CORE+55             
4155 12 42			dw .LEN            
4157 05				db 4 + 1 
4158 .. 00			db "FIND",0              
415d				endm 
# End of macro CWHEAD
415d			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
415d			 
415d					if DEBUG_FORTH_WORDS_KEY 
415d						DMARK "FND" 
415d f5				push af  
415e 3a 72 41			ld a, (.dmark)  
4161 32 77 fb			ld (debug_mark),a  
4164 3a 73 41			ld a, (.dmark+1)  
4167 32 78 fb			ld (debug_mark+1),a  
416a 3a 74 41			ld a, (.dmark+2)  
416d 32 79 fb			ld (debug_mark+2),a  
4170 18 03			jr .pastdmark  
4172 ..			.dmark: db "FND"  
4175 f1			.pastdmark: pop af  
4176			endm  
# End of macro DMARK
4176						CALLMONITOR 
4176 cd 01 15			call break_point_state  
4179				endm  
# End of macro CALLMONITOR
4179					endif 
4179			 
4179			; TODO check string type 
4179					FORTH_DSP_VALUE 
4179 cd 1f 1b			call macro_forth_dsp_value 
417c				endm 
# End of macro FORTH_DSP_VALUE
417c			 
417c e5					push hl    
417d 7e					ld a,(hl)    ; char to find   
417e			; TODO change char to substr 
417e			 
417e f5					push af 
417f					 
417f			 
417f			 
417f					if DEBUG_FORTH_WORDS 
417f						DMARK "FN1" 
417f f5				push af  
4180 3a 94 41			ld a, (.dmark)  
4183 32 77 fb			ld (debug_mark),a  
4186 3a 95 41			ld a, (.dmark+1)  
4189 32 78 fb			ld (debug_mark+1),a  
418c 3a 96 41			ld a, (.dmark+2)  
418f 32 79 fb			ld (debug_mark+2),a  
4192 18 03			jr .pastdmark  
4194 ..			.dmark: db "FN1"  
4197 f1			.pastdmark: pop af  
4198			endm  
# End of macro DMARK
4198						CALLMONITOR 
4198 cd 01 15			call break_point_state  
419b				endm  
# End of macro CALLMONITOR
419b					endif 
419b			 
419b					FORTH_DSP_POP 
419b cd d2 1b			call macro_forth_dsp_pop 
419e				endm 
# End of macro FORTH_DSP_POP
419e			 
419e					; string to search 
419e			 
419e					FORTH_DSP_VALUE 
419e cd 1f 1b			call macro_forth_dsp_value 
41a1				endm 
# End of macro FORTH_DSP_VALUE
41a1			 
41a1 d1					pop de  ; d is char to find  
41a2			 
41a2					if DEBUG_FORTH_WORDS 
41a2						DMARK "FN2" 
41a2 f5				push af  
41a3 3a b7 41			ld a, (.dmark)  
41a6 32 77 fb			ld (debug_mark),a  
41a9 3a b8 41			ld a, (.dmark+1)  
41ac 32 78 fb			ld (debug_mark+1),a  
41af 3a b9 41			ld a, (.dmark+2)  
41b2 32 79 fb			ld (debug_mark+2),a  
41b5 18 03			jr .pastdmark  
41b7 ..			.dmark: db "FN2"  
41ba f1			.pastdmark: pop af  
41bb			endm  
# End of macro DMARK
41bb						CALLMONITOR 
41bb cd 01 15			call break_point_state  
41be				endm  
# End of macro CALLMONITOR
41be					endif 
41be					 
41be 01 00 00				ld bc, 0 
41c1 7e			.findchar:      ld a,(hl) 
41c2 fe 00				cp 0   		 
41c4 28 27				jr z, .finddone     
41c6 ba					cp d 
41c7 28 20				jr z, .foundchar 
41c9 03					inc bc 
41ca 23					inc hl 
41cb					if DEBUG_FORTH_WORDS 
41cb						DMARK "FN3" 
41cb f5				push af  
41cc 3a e0 41			ld a, (.dmark)  
41cf 32 77 fb			ld (debug_mark),a  
41d2 3a e1 41			ld a, (.dmark+1)  
41d5 32 78 fb			ld (debug_mark+1),a  
41d8 3a e2 41			ld a, (.dmark+2)  
41db 32 79 fb			ld (debug_mark+2),a  
41de 18 03			jr .pastdmark  
41e0 ..			.dmark: db "FN3"  
41e3 f1			.pastdmark: pop af  
41e4			endm  
# End of macro DMARK
41e4						CALLMONITOR 
41e4 cd 01 15			call break_point_state  
41e7				endm  
# End of macro CALLMONITOR
41e7					endif 
41e7 18 d8				jr .findchar 
41e9			 
41e9			 
41e9 c5			.foundchar:	push bc 
41ea e1					pop hl 
41eb 18 03				jr .findexit 
41ed			 
41ed			 
41ed							 
41ed			 
41ed			.finddone:     ; got to end of string with no find 
41ed 21 00 00				ld hl, 0 
41f0			.findexit: 
41f0			 
41f0					if DEBUG_FORTH_WORDS 
41f0						DMARK "FNd" 
41f0 f5				push af  
41f1 3a 05 42			ld a, (.dmark)  
41f4 32 77 fb			ld (debug_mark),a  
41f7 3a 06 42			ld a, (.dmark+1)  
41fa 32 78 fb			ld (debug_mark+1),a  
41fd 3a 07 42			ld a, (.dmark+2)  
4200 32 79 fb			ld (debug_mark+2),a  
4203 18 03			jr .pastdmark  
4205 ..			.dmark: db "FNd"  
4208 f1			.pastdmark: pop af  
4209			endm  
# End of macro DMARK
4209						CALLMONITOR 
4209 cd 01 15			call break_point_state  
420c				endm  
# End of macro CALLMONITOR
420c					endif 
420c cd 9b 1a			call forth_push_numhl 
420f			 
420f				       NEXTW 
420f c3 8c 1c			jp macro_next 
4212				endm 
# End of macro NEXTW
4212			 
4212			.LEN: 
4212				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
4212 4c				db WORD_SYS_CORE+56             
4213 47 42			dw .CHAR            
4215 06				db 5 + 1 
4216 .. 00			db "COUNT",0              
421c				endm 
# End of macro CWHEAD
421c			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
421c			 
421c					if DEBUG_FORTH_WORDS_KEY 
421c						DMARK "CNT" 
421c f5				push af  
421d 3a 31 42			ld a, (.dmark)  
4220 32 77 fb			ld (debug_mark),a  
4223 3a 32 42			ld a, (.dmark+1)  
4226 32 78 fb			ld (debug_mark+1),a  
4229 3a 33 42			ld a, (.dmark+2)  
422c 32 79 fb			ld (debug_mark+2),a  
422f 18 03			jr .pastdmark  
4231 ..			.dmark: db "CNT"  
4234 f1			.pastdmark: pop af  
4235			endm  
# End of macro DMARK
4235						CALLMONITOR 
4235 cd 01 15			call break_point_state  
4238				endm  
# End of macro CALLMONITOR
4238					endif 
4238			; TODO check string type 
4238					FORTH_DSP 
4238 cd 1b 1b			call macro_forth_dsp 
423b				endm 
# End of macro FORTH_DSP
423b					;v5FORTH_DSP_VALUE 
423b			 
423b 23					inc hl 
423c			 
423c 3e 00				ld a, 0 
423e cd 28 11				call strlent 
4241			 
4241 cd 9b 1a				call forth_push_numhl 
4244			 
4244			 
4244			 
4244				       NEXTW 
4244 c3 8c 1c			jp macro_next 
4247				endm 
# End of macro NEXTW
4247			.CHAR: 
4247				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
4247 4d				db WORD_SYS_CORE+57             
4248 7d 42			dw .ENDSTR            
424a 05				db 4 + 1 
424b .. 00			db "CHAR",0              
4250				endm 
# End of macro CWHEAD
4250			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4250					if DEBUG_FORTH_WORDS_KEY 
4250						DMARK "CHR" 
4250 f5				push af  
4251 3a 65 42			ld a, (.dmark)  
4254 32 77 fb			ld (debug_mark),a  
4257 3a 66 42			ld a, (.dmark+1)  
425a 32 78 fb			ld (debug_mark+1),a  
425d 3a 67 42			ld a, (.dmark+2)  
4260 32 79 fb			ld (debug_mark+2),a  
4263 18 03			jr .pastdmark  
4265 ..			.dmark: db "CHR"  
4268 f1			.pastdmark: pop af  
4269			endm  
# End of macro DMARK
4269						CALLMONITOR 
4269 cd 01 15			call break_point_state  
426c				endm  
# End of macro CALLMONITOR
426c					endif 
426c					FORTH_DSP 
426c cd 1b 1b			call macro_forth_dsp 
426f				endm 
# End of macro FORTH_DSP
426f					;v5 FORTH_DSP_VALUE 
426f 23					inc hl      ; now at start of numeric as string 
4270			 
4270			;		push hl 
4270			 
4270					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4270 cd d2 1b			call macro_forth_dsp_pop 
4273				endm 
# End of macro FORTH_DSP_POP
4273			 
4273			;		pop hl 
4273			 
4273					; push the content of a onto the stack as a value 
4273			 
4273 7e					ld a,(hl)   ; get char 
4274 26 00				ld h,0 
4276 6f					ld l,a 
4277 cd 9b 1a				call forth_push_numhl 
427a			 
427a				       NEXTW 
427a c3 8c 1c			jp macro_next 
427d				endm 
# End of macro NEXTW
427d			 
427d			 
427d			 
427d			 
427d			.ENDSTR: 
427d			; eof 
427d			 
# End of file forth_words_str.asm
427d			include "forth_words_key.asm" 
427d			 
427d			; | ## Keyboard Words 
427d			 
427d			.KEY: 
427d				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
427d 3e				db WORD_SYS_CORE+42             
427e ad 42			dw .WAITK            
4280 04				db 3 + 1 
4281 .. 00			db "KEY",0              
4285				endm 
# End of macro CWHEAD
4285			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4285			 
4285					if DEBUG_FORTH_WORDS_KEY 
4285						DMARK "KEY" 
4285 f5				push af  
4286 3a 9a 42			ld a, (.dmark)  
4289 32 77 fb			ld (debug_mark),a  
428c 3a 9b 42			ld a, (.dmark+1)  
428f 32 78 fb			ld (debug_mark+1),a  
4292 3a 9c 42			ld a, (.dmark+2)  
4295 32 79 fb			ld (debug_mark+2),a  
4298 18 03			jr .pastdmark  
429a ..			.dmark: db "KEY"  
429d f1			.pastdmark: pop af  
429e			endm  
# End of macro DMARK
429e						CALLMONITOR 
429e cd 01 15			call break_point_state  
42a1				endm  
# End of macro CALLMONITOR
42a1					endif 
42a1			; TODO currently waits 
42a1 cd 41 65				call cin 
42a4					;call cin_wait 
42a4 6f					ld l, a 
42a5 26 00				ld h, 0 
42a7 cd 9b 1a				call forth_push_numhl 
42aa					NEXTW 
42aa c3 8c 1c			jp macro_next 
42ad				endm 
# End of macro NEXTW
42ad			.WAITK: 
42ad				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
42ad 3f				db WORD_SYS_CORE+43             
42ae df 42			dw .ACCEPT            
42b0 06				db 5 + 1 
42b1 .. 00			db "WAITK",0              
42b7				endm 
# End of macro CWHEAD
42b7			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
42b7					if DEBUG_FORTH_WORDS_KEY 
42b7						DMARK "WAI" 
42b7 f5				push af  
42b8 3a cc 42			ld a, (.dmark)  
42bb 32 77 fb			ld (debug_mark),a  
42be 3a cd 42			ld a, (.dmark+1)  
42c1 32 78 fb			ld (debug_mark+1),a  
42c4 3a ce 42			ld a, (.dmark+2)  
42c7 32 79 fb			ld (debug_mark+2),a  
42ca 18 03			jr .pastdmark  
42cc ..			.dmark: db "WAI"  
42cf f1			.pastdmark: pop af  
42d0			endm  
# End of macro DMARK
42d0						CALLMONITOR 
42d0 cd 01 15			call break_point_state  
42d3				endm  
# End of macro CALLMONITOR
42d3					endif 
42d3 cd 30 65				call cin_wait 
42d6 6f					ld l, a 
42d7 26 00				ld h, 0 
42d9 cd 9b 1a				call forth_push_numhl 
42dc					NEXTW 
42dc c3 8c 1c			jp macro_next 
42df				endm 
# End of macro NEXTW
42df			.ACCEPT: 
42df				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
42df 40				db WORD_SYS_CORE+44             
42e0 3d 43			dw .EDIT            
42e2 07				db 6 + 1 
42e3 .. 00			db "ACCEPT",0              
42ea				endm 
# End of macro CWHEAD
42ea			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
42ea					; TODO crashes on push 
42ea					if DEBUG_FORTH_WORDS_KEY 
42ea						DMARK "ACC" 
42ea f5				push af  
42eb 3a ff 42			ld a, (.dmark)  
42ee 32 77 fb			ld (debug_mark),a  
42f1 3a 00 43			ld a, (.dmark+1)  
42f4 32 78 fb			ld (debug_mark+1),a  
42f7 3a 01 43			ld a, (.dmark+2)  
42fa 32 79 fb			ld (debug_mark+2),a  
42fd 18 03			jr .pastdmark  
42ff ..			.dmark: db "ACC"  
4302 f1			.pastdmark: pop af  
4303			endm  
# End of macro DMARK
4303						CALLMONITOR 
4303 cd 01 15			call break_point_state  
4306				endm  
# End of macro CALLMONITOR
4306					endif 
4306 21 30 f0				ld hl, os_input 
4309 3e 00				ld a, 0 
430b 77					ld (hl),a 
430c 3a 5b f8				ld a,(f_cursor_ptr) 
430f 16 64				ld d, 100 
4311 0e 00				ld c, 0 
4313 1e 28				ld e, 40 
4315 cd ec 0c				call input_str 
4318					; TODO perhaps do a type check and wrap in quotes if not a number 
4318 21 30 f0				ld hl, os_input 
431b					if DEBUG_FORTH_WORDS 
431b						DMARK "AC1" 
431b f5				push af  
431c 3a 30 43			ld a, (.dmark)  
431f 32 77 fb			ld (debug_mark),a  
4322 3a 31 43			ld a, (.dmark+1)  
4325 32 78 fb			ld (debug_mark+1),a  
4328 3a 32 43			ld a, (.dmark+2)  
432b 32 79 fb			ld (debug_mark+2),a  
432e 18 03			jr .pastdmark  
4330 ..			.dmark: db "AC1"  
4333 f1			.pastdmark: pop af  
4334			endm  
# End of macro DMARK
4334						CALLMONITOR 
4334 cd 01 15			call break_point_state  
4337				endm  
# End of macro CALLMONITOR
4337					endif 
4337 cd ad 1a				call forth_push_str 
433a					NEXTW 
433a c3 8c 1c			jp macro_next 
433d				endm 
# End of macro NEXTW
433d			 
433d			.EDIT: 
433d				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
433d 40				db WORD_SYS_CORE+44             
433e c6 43			dw .ENDKEY            
4340 05				db 4 + 1 
4341 .. 00			db "EDIT",0              
4346				endm 
# End of macro CWHEAD
4346			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4346			 
4346					; TODO does not copy from stack 
4346					if DEBUG_FORTH_WORDS_KEY 
4346						DMARK "EDT" 
4346 f5				push af  
4347 3a 5b 43			ld a, (.dmark)  
434a 32 77 fb			ld (debug_mark),a  
434d 3a 5c 43			ld a, (.dmark+1)  
4350 32 78 fb			ld (debug_mark+1),a  
4353 3a 5d 43			ld a, (.dmark+2)  
4356 32 79 fb			ld (debug_mark+2),a  
4359 18 03			jr .pastdmark  
435b ..			.dmark: db "EDT"  
435e f1			.pastdmark: pop af  
435f			endm  
# End of macro DMARK
435f						CALLMONITOR 
435f cd 01 15			call break_point_state  
4362				endm  
# End of macro CALLMONITOR
4362					endif 
4362			 
4362					FORTH_DSP 
4362 cd 1b 1b			call macro_forth_dsp 
4365				endm 
# End of macro FORTH_DSP
4365					;v5 FORTH_DSP_VALUE 
4365 23					inc hl    ; TODO do type check 
4366			 
4366 e5					push hl 
4367 3e 00				ld a, 0 
4369 cd 28 11				call strlent 
436c 23					inc hl 
436d			 
436d 06 00				ld b, 0 
436f 4d					ld c, l 
4370			 
4370 e1					pop hl 
4371 11 30 f0				ld de, os_input 
4374					if DEBUG_FORTH_WORDS_KEY 
4374						DMARK "EDc" 
4374 f5				push af  
4375 3a 89 43			ld a, (.dmark)  
4378 32 77 fb			ld (debug_mark),a  
437b 3a 8a 43			ld a, (.dmark+1)  
437e 32 78 fb			ld (debug_mark+1),a  
4381 3a 8b 43			ld a, (.dmark+2)  
4384 32 79 fb			ld (debug_mark+2),a  
4387 18 03			jr .pastdmark  
4389 ..			.dmark: db "EDc"  
438c f1			.pastdmark: pop af  
438d			endm  
# End of macro DMARK
438d						CALLMONITOR 
438d cd 01 15			call break_point_state  
4390				endm  
# End of macro CALLMONITOR
4390					endif 
4390 ed b0				ldir 
4392			 
4392			 
4392 21 30 f0				ld hl, os_input 
4395					;ld a, 0 
4395					;ld (hl),a 
4395 3a 5b f8				ld a,(f_cursor_ptr) 
4398 16 64				ld d, 100 
439a 0e 00				ld c, 0 
439c 1e 28				ld e, 40 
439e cd ec 0c				call input_str 
43a1					; TODO perhaps do a type check and wrap in quotes if not a number 
43a1 21 30 f0				ld hl, os_input 
43a4					if DEBUG_FORTH_WORDS 
43a4						DMARK "ED1" 
43a4 f5				push af  
43a5 3a b9 43			ld a, (.dmark)  
43a8 32 77 fb			ld (debug_mark),a  
43ab 3a ba 43			ld a, (.dmark+1)  
43ae 32 78 fb			ld (debug_mark+1),a  
43b1 3a bb 43			ld a, (.dmark+2)  
43b4 32 79 fb			ld (debug_mark+2),a  
43b7 18 03			jr .pastdmark  
43b9 ..			.dmark: db "ED1"  
43bc f1			.pastdmark: pop af  
43bd			endm  
# End of macro DMARK
43bd						CALLMONITOR 
43bd cd 01 15			call break_point_state  
43c0				endm  
# End of macro CALLMONITOR
43c0					endif 
43c0 cd ad 1a				call forth_push_str 
43c3					NEXTW 
43c3 c3 8c 1c			jp macro_next 
43c6				endm 
# End of macro NEXTW
43c6			 
43c6			 
43c6			 
43c6			.ENDKEY: 
43c6			; eof 
43c6			 
# End of file forth_words_key.asm
43c6			 
43c6			if STORAGE_SE 
43c6			   	include "forth_words_storage.asm" 
43c6			 
43c6			; | ## Fixed Storage Words 
43c6			 
43c6			 
43c6			.BREAD: 
43c6			  
43c6				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
43c6 3a				db WORD_SYS_CORE+38             
43c7 3f 44			dw .BWRITE            
43c9 06				db 5 + 1 
43ca .. 00			db "BREAD",0              
43d0				endm 
# End of macro CWHEAD
43d0			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
43d0				 
43d0					if DEBUG_FORTH_WORDS_KEY 
43d0						DMARK "BRD" 
43d0 f5				push af  
43d1 3a e5 43			ld a, (.dmark)  
43d4 32 77 fb			ld (debug_mark),a  
43d7 3a e6 43			ld a, (.dmark+1)  
43da 32 78 fb			ld (debug_mark+1),a  
43dd 3a e7 43			ld a, (.dmark+2)  
43e0 32 79 fb			ld (debug_mark+2),a  
43e3 18 03			jr .pastdmark  
43e5 ..			.dmark: db "BRD"  
43e8 f1			.pastdmark: pop af  
43e9			endm  
# End of macro DMARK
43e9						CALLMONITOR 
43e9 cd 01 15			call break_point_state  
43ec				endm  
# End of macro CALLMONITOR
43ec					endif 
43ec			 
43ec				FORTH_DSP_VALUEHL 
43ec cd 36 1b			call macro_dsp_valuehl 
43ef				endm 
# End of macro FORTH_DSP_VALUEHL
43ef			 
43ef				FORTH_DSP_POP 
43ef cd d2 1b			call macro_forth_dsp_pop 
43f2				endm 
# End of macro FORTH_DSP_POP
43f2			 
43f2				; calc block address 
43f2			 
43f2 eb				ex de, hl 
43f3 3e 40			ld a, STORE_BLOCK_PHY 
43f5 cd 42 0c			call Mult16 
43f8			 
43f8			 
43f8 11 62 f8			ld de, store_page 
43fb			 
43fb					if DEBUG_FORTH_WORDS 
43fb						DMARK "BR1" 
43fb f5				push af  
43fc 3a 10 44			ld a, (.dmark)  
43ff 32 77 fb			ld (debug_mark),a  
4402 3a 11 44			ld a, (.dmark+1)  
4405 32 78 fb			ld (debug_mark+1),a  
4408 3a 12 44			ld a, (.dmark+2)  
440b 32 79 fb			ld (debug_mark+2),a  
440e 18 03			jr .pastdmark  
4410 ..			.dmark: db "BR1"  
4413 f1			.pastdmark: pop af  
4414			endm  
# End of macro DMARK
4414						CALLMONITOR 
4414 cd 01 15			call break_point_state  
4417				endm  
# End of macro CALLMONITOR
4417					endif 
4417			 
4417 cd 0c 03			call storage_read_block 
441a			 
441a 21 64 f8		        ld hl, store_page+2 
441d					if DEBUG_FORTH_WORDS 
441d						DMARK "BR2" 
441d f5				push af  
441e 3a 32 44			ld a, (.dmark)  
4421 32 77 fb			ld (debug_mark),a  
4424 3a 33 44			ld a, (.dmark+1)  
4427 32 78 fb			ld (debug_mark+1),a  
442a 3a 34 44			ld a, (.dmark+2)  
442d 32 79 fb			ld (debug_mark+2),a  
4430 18 03			jr .pastdmark  
4432 ..			.dmark: db "BR2"  
4435 f1			.pastdmark: pop af  
4436			endm  
# End of macro DMARK
4436						CALLMONITOR 
4436 cd 01 15			call break_point_state  
4439				endm  
# End of macro CALLMONITOR
4439					endif 
4439 cd ad 1a			call forth_push_str 
443c			 
443c			 
443c					NEXTW 
443c c3 8c 1c			jp macro_next 
443f				endm 
# End of macro NEXTW
443f			.BWRITE: 
443f				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
443f 3a				db WORD_SYS_CORE+38             
4440 d4 44			dw .BUPD            
4442 07				db 6 + 1 
4443 .. 00			db "BWRITE",0              
444a				endm 
# End of macro CWHEAD
444a			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
444a			 
444a					if DEBUG_FORTH_WORDS_KEY 
444a						DMARK "BWR" 
444a f5				push af  
444b 3a 5f 44			ld a, (.dmark)  
444e 32 77 fb			ld (debug_mark),a  
4451 3a 60 44			ld a, (.dmark+1)  
4454 32 78 fb			ld (debug_mark+1),a  
4457 3a 61 44			ld a, (.dmark+2)  
445a 32 79 fb			ld (debug_mark+2),a  
445d 18 03			jr .pastdmark  
445f ..			.dmark: db "BWR"  
4462 f1			.pastdmark: pop af  
4463			endm  
# End of macro DMARK
4463						CALLMONITOR 
4463 cd 01 15			call break_point_state  
4466				endm  
# End of macro CALLMONITOR
4466					endif 
4466			 
4466				FORTH_DSP_VALUEHL 
4466 cd 36 1b			call macro_dsp_valuehl 
4469				endm 
# End of macro FORTH_DSP_VALUEHL
4469			 
4469				; calc block address 
4469			 
4469 eb				ex de, hl 
446a 3e 40			ld a, STORE_BLOCK_PHY 
446c cd 42 0c			call Mult16 
446f			 
446f e5				push hl         ; address 
4470			 
4470				FORTH_DSP_POP 
4470 cd d2 1b			call macro_forth_dsp_pop 
4473				endm 
# End of macro FORTH_DSP_POP
4473			 
4473				FORTH_DSP_VALUEHL 
4473 cd 36 1b			call macro_dsp_valuehl 
4476				endm 
# End of macro FORTH_DSP_VALUEHL
4476			 
4476				FORTH_DSP_POP 
4476 cd d2 1b			call macro_forth_dsp_pop 
4479				endm 
# End of macro FORTH_DSP_POP
4479			 
4479 cd 0d 0a			call storage_clear_page 
447c			 
447c				; copy string to store page 
447c			 
447c e5				push hl     ; save string address 
447d			 
447d 3e 00			ld a, 0 
447f cd 28 11			call strlent 
4482			 
4482 23				inc hl 
4483			 
4483 4d				ld c, l 
4484 06 00			ld b, 0 
4486			 
4486 e1				pop hl 
4487 11 64 f8			ld de, store_page + 2 
448a					if DEBUG_FORTH_WORDS 
448a						DMARK "BW1" 
448a f5				push af  
448b 3a 9f 44			ld a, (.dmark)  
448e 32 77 fb			ld (debug_mark),a  
4491 3a a0 44			ld a, (.dmark+1)  
4494 32 78 fb			ld (debug_mark+1),a  
4497 3a a1 44			ld a, (.dmark+2)  
449a 32 79 fb			ld (debug_mark+2),a  
449d 18 03			jr .pastdmark  
449f ..			.dmark: db "BW1"  
44a2 f1			.pastdmark: pop af  
44a3			endm  
# End of macro DMARK
44a3						CALLMONITOR 
44a3 cd 01 15			call break_point_state  
44a6				endm  
# End of macro CALLMONITOR
44a6					endif 
44a6 ed b0			ldir 
44a8			 
44a8			 
44a8				; poke the start of the block with flags to prevent high level file ops hitting the block 
44a8			 
44a8 21 ff ff			ld hl, $ffff 
44ab			 
44ab 22 62 f8			ld (store_page), hl	 
44ae				 
44ae e1				pop hl    ; get address 
44af 11 62 f8			ld de, store_page 
44b2			 
44b2					if DEBUG_FORTH_WORDS 
44b2						DMARK "BW2" 
44b2 f5				push af  
44b3 3a c7 44			ld a, (.dmark)  
44b6 32 77 fb			ld (debug_mark),a  
44b9 3a c8 44			ld a, (.dmark+1)  
44bc 32 78 fb			ld (debug_mark+1),a  
44bf 3a c9 44			ld a, (.dmark+2)  
44c2 32 79 fb			ld (debug_mark+2),a  
44c5 18 03			jr .pastdmark  
44c7 ..			.dmark: db "BW2"  
44ca f1			.pastdmark: pop af  
44cb			endm  
# End of macro DMARK
44cb						CALLMONITOR 
44cb cd 01 15			call break_point_state  
44ce				endm  
# End of macro CALLMONITOR
44ce					endif 
44ce			 
44ce cd 71 03			call storage_write_block 
44d1			 
44d1					NEXTW 
44d1 c3 8c 1c			jp macro_next 
44d4				endm 
# End of macro NEXTW
44d4			 
44d4			.BUPD: 
44d4				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
44d4 3a				db WORD_SYS_CORE+38             
44d5 2a 45			dw .BYID            
44d7 05				db 4 + 1 
44d8 .. 00			db "BUPD",0              
44dd				endm 
# End of macro CWHEAD
44dd			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
44dd			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
44dd			; | | or completely different file system structure. 
44dd			 
44dd					if DEBUG_FORTH_WORDS_KEY 
44dd						DMARK "BUD" 
44dd f5				push af  
44de 3a f2 44			ld a, (.dmark)  
44e1 32 77 fb			ld (debug_mark),a  
44e4 3a f3 44			ld a, (.dmark+1)  
44e7 32 78 fb			ld (debug_mark+1),a  
44ea 3a f4 44			ld a, (.dmark+2)  
44ed 32 79 fb			ld (debug_mark+2),a  
44f0 18 03			jr .pastdmark  
44f2 ..			.dmark: db "BUD"  
44f5 f1			.pastdmark: pop af  
44f6			endm  
# End of macro DMARK
44f6						CALLMONITOR 
44f6 cd 01 15			call break_point_state  
44f9				endm  
# End of macro CALLMONITOR
44f9					endif 
44f9			 
44f9				FORTH_DSP_VALUEHL 
44f9 cd 36 1b			call macro_dsp_valuehl 
44fc				endm 
# End of macro FORTH_DSP_VALUEHL
44fc			 
44fc				; calc block address 
44fc			 
44fc eb				ex de, hl 
44fd 3e 40			ld a, STORE_BLOCK_PHY 
44ff cd 42 0c			call Mult16 
4502			 
4502				FORTH_DSP_POP 
4502 cd d2 1b			call macro_forth_dsp_pop 
4505				endm 
# End of macro FORTH_DSP_POP
4505			 
4505			 
4505 11 62 f8			ld de, store_page 
4508			 
4508					if DEBUG_FORTH_WORDS 
4508						DMARK "BUe" 
4508 f5				push af  
4509 3a 1d 45			ld a, (.dmark)  
450c 32 77 fb			ld (debug_mark),a  
450f 3a 1e 45			ld a, (.dmark+1)  
4512 32 78 fb			ld (debug_mark+1),a  
4515 3a 1f 45			ld a, (.dmark+2)  
4518 32 79 fb			ld (debug_mark+2),a  
451b 18 03			jr .pastdmark  
451d ..			.dmark: db "BUe"  
4520 f1			.pastdmark: pop af  
4521			endm  
# End of macro DMARK
4521						CALLMONITOR 
4521 cd 01 15			call break_point_state  
4524				endm  
# End of macro CALLMONITOR
4524					endif 
4524			 
4524 cd 71 03			call storage_write_block 
4527			 
4527					NEXTW 
4527 c3 8c 1c			jp macro_next 
452a				endm 
# End of macro NEXTW
452a			 
452a			.BYID: 
452a			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
452a			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
452a			; 
452a			;		 
452a			;		if DEBUG_FORTH_WORDS_KEY 
452a			;			DMARK "BYID" 
452a			;			CALLMONITOR 
452a			;		endif 
452a			; 
452a			;		; get direct address 
452a			; 
452a			;		FORTH_DSP_VALUEHL 
452a			; 
452a			;		FORTH_DSP_POP 
452a			; 
452a			;	; calc block address 
452a			; 
452a			;	ex de, hl 
452a			;	ld a, STORE_BLOCK_PHY 
452a			;	call Mult16 
452a			;	;	do BREAD with number as param 
452a			;	; push the file name	 
452a			;	ld de, store_page 
452a			;	call storage_read_block 
452a			 ;       ld hl, store_page+2 
452a			; 
452a			; 
452a			;		NEXTW 
452a			;.BYNAME: 
452a			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
452a			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
452a			;		NEXTW 
452a			; 
452a			.DIR: 
452a				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
452a 3a				db WORD_SYS_CORE+38             
452b 2e 46			dw .SAVE            
452d 04				db 3 + 1 
452e .. 00			db "DIR",0              
4532				endm 
# End of macro CWHEAD
4532			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4532			 
4532					if DEBUG_FORTH_WORDS_KEY 
4532						DMARK "DIR" 
4532 f5				push af  
4533 3a 47 45			ld a, (.dmark)  
4536 32 77 fb			ld (debug_mark),a  
4539 3a 48 45			ld a, (.dmark+1)  
453c 32 78 fb			ld (debug_mark+1),a  
453f 3a 49 45			ld a, (.dmark+2)  
4542 32 79 fb			ld (debug_mark+2),a  
4545 18 03			jr .pastdmark  
4547 ..			.dmark: db "DIR"  
454a f1			.pastdmark: pop af  
454b			endm  
# End of macro DMARK
454b						CALLMONITOR 
454b cd 01 15			call break_point_state  
454e				endm  
# End of macro CALLMONITOR
454e					endif 
454e cd bd 03			call storage_get_block_0 
4551			 
4551 21 62 f8			ld hl, store_page     ; get current id count 
4554 46				ld b, (hl) 
4555 0e 00			ld c, 0    ; count of files   
4557					if DEBUG_FORTH_WORDS 
4557						DMARK "DI1" 
4557 f5				push af  
4558 3a 6c 45			ld a, (.dmark)  
455b 32 77 fb			ld (debug_mark),a  
455e 3a 6d 45			ld a, (.dmark+1)  
4561 32 78 fb			ld (debug_mark+1),a  
4564 3a 6e 45			ld a, (.dmark+2)  
4567 32 79 fb			ld (debug_mark+2),a  
456a 18 03			jr .pastdmark  
456c ..			.dmark: db "DI1"  
456f f1			.pastdmark: pop af  
4570			endm  
# End of macro DMARK
4570						CALLMONITOR 
4570 cd 01 15			call break_point_state  
4573				endm  
# End of macro CALLMONITOR
4573					endif 
4573			 
4573				; check for empty drive 
4573			 
4573 3e 00			ld a, 0 
4575 b8				cp b 
4576 ca e4 45			jp z, .dirdone 
4579			 
4579				; for each of the current ids do a search for them and if found push to stack 
4579			 
4579 c5			.diritem:	push bc 
457a 21 40 00				ld hl, STORE_BLOCK_PHY 
457d 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
457f 58					ld e,b 
4580			 
4580			;		if DEBUG_FORTH_WORDS 
4580			;			DMARK "DI2" 
4580			;			CALLMONITOR 
4580			;		endif 
4580			 
4580 cd 22 06				call storage_findnextid 
4583			 
4583			;		if DEBUG_FORTH_WORDS 
4583			;			DMARK "DI3" 
4583			;			CALLMONITOR 
4583			;		endif 
4583			 
4583					; if found hl will be non zero 
4583			 
4583 cd e8 0c				call ishlzero 
4586			;		ld a, l 
4586			;		add h 
4586			; 
4586			;		cp 0 
4586 28 59				jr z, .dirnotfound 
4588			 
4588					; increase count 
4588			 
4588 c1					pop bc	 
4589 0c					inc c 
458a c5					push bc 
458b					 
458b			 
458b					; get file header and push the file name 
458b			 
458b 11 62 f8				ld de, store_page 
458e cd 0c 03				call storage_read_block 
4591			 
4591					; push file id to stack 
4591				 
4591 3a 62 f8				ld a, (store_page) 
4594 26 00				ld h, 0 
4596 6f					ld l, a 
4597 cd 9b 1a				call forth_push_numhl 
459a			 
459a					; push extent count to stack  
459a				 
459a 3a 64 f8				ld a, (store_page+2) 
459d 26 00				ld h, 0 
459f 6f					ld l, a 
45a0 cd 9b 1a				call forth_push_numhl 
45a3			 
45a3					; push file name 
45a3			 
45a3 21 65 f8				ld hl, store_page+3 
45a6					if DEBUG_FORTH_WORDS 
45a6						DMARK "DI5" 
45a6 f5				push af  
45a7 3a bb 45			ld a, (.dmark)  
45aa 32 77 fb			ld (debug_mark),a  
45ad 3a bc 45			ld a, (.dmark+1)  
45b0 32 78 fb			ld (debug_mark+1),a  
45b3 3a bd 45			ld a, (.dmark+2)  
45b6 32 79 fb			ld (debug_mark+2),a  
45b9 18 03			jr .pastdmark  
45bb ..			.dmark: db "DI5"  
45be f1			.pastdmark: pop af  
45bf			endm  
# End of macro DMARK
45bf						CALLMONITOR 
45bf cd 01 15			call break_point_state  
45c2				endm  
# End of macro CALLMONITOR
45c2					endif 
45c2 cd ad 1a				call forth_push_str 
45c5					if DEBUG_FORTH_WORDS 
45c5						DMARK "DI6" 
45c5 f5				push af  
45c6 3a da 45			ld a, (.dmark)  
45c9 32 77 fb			ld (debug_mark),a  
45cc 3a db 45			ld a, (.dmark+1)  
45cf 32 78 fb			ld (debug_mark+1),a  
45d2 3a dc 45			ld a, (.dmark+2)  
45d5 32 79 fb			ld (debug_mark+2),a  
45d8 18 03			jr .pastdmark  
45da ..			.dmark: db "DI6"  
45dd f1			.pastdmark: pop af  
45de			endm  
# End of macro DMARK
45de						CALLMONITOR 
45de cd 01 15			call break_point_state  
45e1				endm  
# End of macro CALLMONITOR
45e1					endif 
45e1			.dirnotfound: 
45e1 c1					pop bc     
45e2 10 95				djnz .diritem 
45e4				 
45e4			.dirdone:	 
45e4					if DEBUG_FORTH_WORDS 
45e4						DMARK "DI7" 
45e4 f5				push af  
45e5 3a f9 45			ld a, (.dmark)  
45e8 32 77 fb			ld (debug_mark),a  
45eb 3a fa 45			ld a, (.dmark+1)  
45ee 32 78 fb			ld (debug_mark+1),a  
45f1 3a fb 45			ld a, (.dmark+2)  
45f4 32 79 fb			ld (debug_mark+2),a  
45f7 18 03			jr .pastdmark  
45f9 ..			.dmark: db "DI7"  
45fc f1			.pastdmark: pop af  
45fd			endm  
# End of macro DMARK
45fd						CALLMONITOR 
45fd cd 01 15			call break_point_state  
4600				endm  
# End of macro CALLMONITOR
4600					endif 
4600			 
4600					; push a count of the dir items found 
4600			 
4600 26 00				ld h, 0 
4602 69					ld l, c 
4603 cd 9b 1a				call forth_push_numhl 
4606			 
4606					; push the bank label 
4606			 
4606 cd bd 03				call storage_get_block_0 
4609			 
4609				 
4609 21 65 f8		 		ld hl, store_page+3 
460c			 
460c					if DEBUG_FORTH_WORDS 
460c						DMARK "DI8" 
460c f5				push af  
460d 3a 21 46			ld a, (.dmark)  
4610 32 77 fb			ld (debug_mark),a  
4613 3a 22 46			ld a, (.dmark+1)  
4616 32 78 fb			ld (debug_mark+1),a  
4619 3a 23 46			ld a, (.dmark+2)  
461c 32 79 fb			ld (debug_mark+2),a  
461f 18 03			jr .pastdmark  
4621 ..			.dmark: db "DI8"  
4624 f1			.pastdmark: pop af  
4625			endm  
# End of macro DMARK
4625						CALLMONITOR 
4625 cd 01 15			call break_point_state  
4628				endm  
# End of macro CALLMONITOR
4628					endif 
4628 cd ad 1a				call forth_push_str 
462b			 
462b			 
462b				 
462b					NEXTW 
462b c3 8c 1c			jp macro_next 
462e				endm 
# End of macro NEXTW
462e			.SAVE: 
462e			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
462e			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
462e			;		NEXTW 
462e			;.LOAD: 
462e			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
462e			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
462e			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
462e			;; > > The LOAD command can not be used in any user words or compound lines. 
462e			; 
462e			;		; store_openext use it. If zero it is EOF 
462e			; 
462e			;		; read block from current stream id 
462e			;		; if the block does not contain zero term keep reading blocks until zero found 
462e			;		; push the block to stack 
462e			;		; save the block id to stream 
462e			; 
462e			; 
462e			;		FORTH_DSP_VALUEHL 
462e			; 
462e			;;		push hl 
462e			; 
462e			;	if DEBUG_STORESE 
462e			;		DMARK "LOA" 
462e			;		CALLMONITOR 
462e			;	endif 
462e			;		FORTH_DSP_POP 
462e			; 
462e			;;		pop hl 
462e			; 
462e			;		ld h, l 
462e			;		ld l, 0 
462e			; 
462e			;		push hl     ; stack holds current file id and extent to work with 
462e			; 
462e			; 
462e			;		ld de, store_page      ; get block zero of file 
462e			;	if DEBUG_STORESE 
462e			;		DMARK "LO0" 
462e			;		CALLMONITOR 
462e			;	endif 
462e			;		call storage_read 
462e			; 
462e			;		ld a, (store_page+2)    ; max extents for this file 
462e			;		ld  (store_openmaxext),a   ; get our limit 
462e			; 
462e			;	if DEBUG_STORESE 
462e			;		DMARK "LOE" 
462e			;		CALLMONITOR 
462e			;	endif 
462e			; 
462e			;; TODO dont know why max extents are not present 
462e			;;		cp 0 
462e			;;		jp z, .loadeof     ; dont read past eof 
462e			; 
462e			;;		ld a, 1   ; start from the head of the file 
462e			; 
462e			;.loadline:	pop hl 
462e			;		inc hl 
462e			;		ld  a, (store_openmaxext)   ; get our limit 
462e			;	if DEBUG_STORESE 
462e			;		DMARK "LOx" 
462e			;		CALLMONITOR 
462e			;	endif 
462e			;		inc a 
462e			;		cp l 
462e			;		jp z, .loadeof 
462e			;		push hl    ; save current extent 
462e			; 
462e			;		ld de, store_page 
462e			; 
462e			;	if DEBUG_STORESE 
462e			;		DMARK "LO1" 
462e			;		CALLMONITOR 
462e			;	endif 
462e			;		call storage_read 
462e			; 
462e			;	if DEBUG_STORESE 
462e			;		DMARK "LO2" 
462e			;		CALLMONITOR 
462e			;	endif 
462e			;	call ishlzero 
462e			;	ld a, l 
462e			;	add h 
462e			;	cp 0 
462e			;	jr z, .loadeof 
462e			; 
462e			;	; not eof so hl should point to data to exec 
462e			; 
462e			;	; will need to add the FORTH_END_BUFFER flag 
462e			 ; 
462e			;	ld hl, store_page+2 
462e			;	ld bc, 255 
462e			;	ld a, 0 
462e			;	cpir 
462e			;	if DEBUG_STORESE 
462e			;		DMARK "LOt" 
462e			;		CALLMONITOR 
462e			;	endif 
462e			;	dec hl 
462e			;	ld a, ' ' 
462e			;	ld (hl), a 
462e			;	inc hl 
462e			;	ld (hl), a 
462e			;	inc hl 
462e			;	ld (hl), a 
462e			;	inc hl 
462e			;	ld a, FORTH_END_BUFFER 
462e			;	ld (hl), a 
462e			; 
462e			;	; TODO handle more than a single block read 
462e			; 
462e			; 
462e			;	ld hl, store_page+2 
462e			; 
462e			;	ld (os_tok_ptr), hl 
462e			; 
462e			;	if DEBUG_STORESE 
462e			;		DMARK "LO3" 
462e			;		CALLMONITOR 
462e			;	endif 
462e			; 
462e			;	call forthparse 
462e			;	call forthexec 
462e			;	call forthexec_cleanup 
462e			; 
462e			;	; go to next extent 
462e			; 
462e			;	; get next block  or mark as eof 
462e			;	jp .loadline 
462e			; 
462e			; 
462e			; 
462e			;	       NEXTW 
462e			;.loadeof:	ld a, 0 
462e			;		ld (store_openext), a 
462e			; 
462e			;	if DEBUG_STORESE 
462e			;		DMARK "LOF" 
462e			;		CALLMONITOR 
462e			;	endif 
462e			;		ret 
462e			;		;NEXTW 
462e			;.BSAVE:   
462e			; 
462e			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
462e			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
462e			;		NEXTW 
462e			;.BLOAD: 
462e			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
462e			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
462e			;		NEXTW 
462e			;;;; counter gap 
462e			 
462e			 
462e			.SEO: 
462e				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
462e 64				db WORD_SYS_CORE+80             
462f 4d 46			dw .SEI            
4631 04				db 3 + 1 
4632 .. 00			db "SEO",0              
4636				endm 
# End of macro CWHEAD
4636			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4636			 
4636					; get port 
4636			 
4636					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4636 cd 36 1b			call macro_dsp_valuehl 
4639				endm 
# End of macro FORTH_DSP_VALUEHL
4639			 
4639 e5					push hl    ; u2 - byte 
463a			 
463a					; destroy value TOS 
463a			 
463a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
463a cd d2 1b			call macro_forth_dsp_pop 
463d				endm 
# End of macro FORTH_DSP_POP
463d			 
463d					; get byte to send 
463d			 
463d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
463d cd 36 1b			call macro_dsp_valuehl 
4640				endm 
# End of macro FORTH_DSP_VALUEHL
4640			 
4640 e5					push hl    ; u1 - addr 
4641			 
4641					; destroy value TOS 
4641			 
4641					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4641 cd d2 1b			call macro_forth_dsp_pop 
4644				endm 
# End of macro FORTH_DSP_POP
4644			 
4644					; one value on hl get other one back 
4644			 
4644 d1					pop de   ; u1 - byte 
4645			 
4645 e1					pop hl   ; u2 - addr 
4646			 
4646					; TODO Send SPI byte 
4646			 
4646			 
4646 7b					ld a, e 
4647 cd ea 01				call se_writebyte 
464a			 
464a					 
464a			 
464a					NEXTW 
464a c3 8c 1c			jp macro_next 
464d				endm 
# End of macro NEXTW
464d			 
464d			.SEI: 
464d				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
464d 65				db WORD_SYS_CORE+81             
464e 67 46			dw .SFREE            
4650 04				db 3 + 1 
4651 .. 00			db "SEI",0              
4655				endm 
# End of macro CWHEAD
4655			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4655			 
4655					; get port 
4655			 
4655					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4655 cd 36 1b			call macro_dsp_valuehl 
4658				endm 
# End of macro FORTH_DSP_VALUEHL
4658			 
4658			;		push hl 
4658			 
4658					; destroy value TOS 
4658			 
4658					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4658 cd d2 1b			call macro_forth_dsp_pop 
465b				endm 
# End of macro FORTH_DSP_POP
465b			 
465b					; one value on hl get other one back 
465b			 
465b			;		pop hl 
465b			 
465b			 
465b					; TODO Get SPI byte 
465b			 
465b cd 8c 02				call se_readbyte 
465e			 
465e 26 00				ld h, 0 
4660 6f					ld l, a 
4661 cd 9b 1a				call forth_push_numhl 
4664			 
4664					NEXTW 
4664 c3 8c 1c			jp macro_next 
4667				endm 
# End of macro NEXTW
4667			 
4667			.SFREE: 
4667				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4667 67				db WORD_SYS_CORE+83             
4668 96 46			dw .SIZE            
466a 06				db 5 + 1 
466b .. 00			db "FFREE",0              
4671				endm 
# End of macro CWHEAD
4671			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4671					if DEBUG_FORTH_WORDS_KEY 
4671						DMARK "FFR" 
4671 f5				push af  
4672 3a 86 46			ld a, (.dmark)  
4675 32 77 fb			ld (debug_mark),a  
4678 3a 87 46			ld a, (.dmark+1)  
467b 32 78 fb			ld (debug_mark+1),a  
467e 3a 88 46			ld a, (.dmark+2)  
4681 32 79 fb			ld (debug_mark+2),a  
4684 18 03			jr .pastdmark  
4686 ..			.dmark: db "FFR"  
4689 f1			.pastdmark: pop af  
468a			endm  
# End of macro DMARK
468a						CALLMONITOR 
468a cd 01 15			call break_point_state  
468d				endm  
# End of macro CALLMONITOR
468d					endif 
468d			 
468d cd bc 06				call storage_freeblocks 
4690			 
4690 cd 9b 1a				call forth_push_numhl 
4693			 
4693				       NEXTW 
4693 c3 8c 1c			jp macro_next 
4696				endm 
# End of macro NEXTW
4696			.SIZE: 
4696				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4696 67				db WORD_SYS_CORE+83             
4697 ca 46			dw .CREATE            
4699 05				db 4 + 1 
469a .. 00			db "SIZE",0              
469f				endm 
# End of macro CWHEAD
469f			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
469f					if DEBUG_FORTH_WORDS_KEY 
469f						DMARK "SIZ" 
469f f5				push af  
46a0 3a b4 46			ld a, (.dmark)  
46a3 32 77 fb			ld (debug_mark),a  
46a6 3a b5 46			ld a, (.dmark+1)  
46a9 32 78 fb			ld (debug_mark+1),a  
46ac 3a b6 46			ld a, (.dmark+2)  
46af 32 79 fb			ld (debug_mark+2),a  
46b2 18 03			jr .pastdmark  
46b4 ..			.dmark: db "SIZ"  
46b7 f1			.pastdmark: pop af  
46b8			endm  
# End of macro DMARK
46b8						CALLMONITOR 
46b8 cd 01 15			call break_point_state  
46bb				endm  
# End of macro CALLMONITOR
46bb					endif 
46bb			 
46bb					FORTH_DSP_VALUEHL 
46bb cd 36 1b			call macro_dsp_valuehl 
46be				endm 
# End of macro FORTH_DSP_VALUEHL
46be			;		push hl 
46be					FORTH_DSP_POP 
46be cd d2 1b			call macro_forth_dsp_pop 
46c1				endm 
# End of macro FORTH_DSP_POP
46c1			;		pop hl 
46c1 cd 3b 03				call storage_file_size 
46c4			 
46c4 cd 9b 1a				call forth_push_numhl 
46c7			  
46c7			 
46c7				       NEXTW 
46c7 c3 8c 1c			jp macro_next 
46ca				endm 
# End of macro NEXTW
46ca			 
46ca			.CREATE: 
46ca				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
46ca 68				db WORD_SYS_CORE+84             
46cb 38 47			dw .APPEND            
46cd 07				db 6 + 1 
46ce .. 00			db "CREATE",0              
46d5				endm 
# End of macro CWHEAD
46d5			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
46d5			; | | e.g.  
46d5			; | | TestProgram CREATE 
46d5			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
46d5			; | |  
46d5			; | | Max file IDs are 255. 
46d5			; | |  
46d5					 
46d5					if DEBUG_FORTH_WORDS_KEY 
46d5						DMARK "CRT" 
46d5 f5				push af  
46d6 3a ea 46			ld a, (.dmark)  
46d9 32 77 fb			ld (debug_mark),a  
46dc 3a eb 46			ld a, (.dmark+1)  
46df 32 78 fb			ld (debug_mark+1),a  
46e2 3a ec 46			ld a, (.dmark+2)  
46e5 32 79 fb			ld (debug_mark+2),a  
46e8 18 03			jr .pastdmark  
46ea ..			.dmark: db "CRT"  
46ed f1			.pastdmark: pop af  
46ee			endm  
# End of macro DMARK
46ee						CALLMONITOR 
46ee cd 01 15			call break_point_state  
46f1				endm  
# End of macro CALLMONITOR
46f1					endif 
46f1			;		call storage_get_block_0 
46f1			 
46f1					; TODO pop hl 
46f1			 
46f1					;v5 FORTH_DSP_VALUE 
46f1					FORTH_DSP_VALUE 
46f1 cd 1f 1b			call macro_forth_dsp_value 
46f4				endm 
# End of macro FORTH_DSP_VALUE
46f4			 
46f4				if DEBUG_STORESE 
46f4					DMARK "CR1" 
46f4 f5				push af  
46f5 3a 09 47			ld a, (.dmark)  
46f8 32 77 fb			ld (debug_mark),a  
46fb 3a 0a 47			ld a, (.dmark+1)  
46fe 32 78 fb			ld (debug_mark+1),a  
4701 3a 0b 47			ld a, (.dmark+2)  
4704 32 79 fb			ld (debug_mark+2),a  
4707 18 03			jr .pastdmark  
4709 ..			.dmark: db "CR1"  
470c f1			.pastdmark: pop af  
470d			endm  
# End of macro DMARK
470d					CALLMONITOR 
470d cd 01 15			call break_point_state  
4710				endm  
# End of macro CALLMONITOR
4710				endif 
4710			;		push hl 
4710			;		FORTH_DSP_POP 
4710			;		pop hl 
4710			 
4710			;		inc hl   ; move past the type marker 
4710			 
4710 cd f2 06				call storage_create 
4713			 
4713				if DEBUG_STORESE 
4713					DMARK "CT1" 
4713 f5				push af  
4714 3a 28 47			ld a, (.dmark)  
4717 32 77 fb			ld (debug_mark),a  
471a 3a 29 47			ld a, (.dmark+1)  
471d 32 78 fb			ld (debug_mark+1),a  
4720 3a 2a 47			ld a, (.dmark+2)  
4723 32 79 fb			ld (debug_mark+2),a  
4726 18 03			jr .pastdmark  
4728 ..			.dmark: db "CT1"  
472b f1			.pastdmark: pop af  
472c			endm  
# End of macro DMARK
472c					CALLMONITOR 
472c cd 01 15			call break_point_state  
472f				endm  
# End of macro CALLMONITOR
472f				endif 
472f			;		push hl 
472f					FORTH_DSP_POP 
472f cd d2 1b			call macro_forth_dsp_pop 
4732				endm 
# End of macro FORTH_DSP_POP
4732			;		pop hl 
4732					; push file id to stack 
4732 cd 9b 1a				call forth_push_numhl 
4735			 
4735			 
4735			 
4735				       NEXTW 
4735 c3 8c 1c			jp macro_next 
4738				endm 
# End of macro NEXTW
4738			 
4738			.APPEND: 
4738				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4738 69				db WORD_SYS_CORE+85             
4739 c9 47			dw .SDEL            
473b 07				db 6 + 1 
473c .. 00			db "APPEND",0              
4743				endm 
# End of macro CWHEAD
4743			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4743			; | | e.g. 
4743			; | | Test CREATE      -> $01 
4743			; | | "A string to add to file" $01 APPEND 
4743			; | |  
4743			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4743					if DEBUG_FORTH_WORDS_KEY 
4743						DMARK "APP" 
4743 f5				push af  
4744 3a 58 47			ld a, (.dmark)  
4747 32 77 fb			ld (debug_mark),a  
474a 3a 59 47			ld a, (.dmark+1)  
474d 32 78 fb			ld (debug_mark+1),a  
4750 3a 5a 47			ld a, (.dmark+2)  
4753 32 79 fb			ld (debug_mark+2),a  
4756 18 03			jr .pastdmark  
4758 ..			.dmark: db "APP"  
475b f1			.pastdmark: pop af  
475c			endm  
# End of macro DMARK
475c						CALLMONITOR 
475c cd 01 15			call break_point_state  
475f				endm  
# End of macro CALLMONITOR
475f					endif 
475f			 
475f					FORTH_DSP_VALUEHL 
475f cd 36 1b			call macro_dsp_valuehl 
4762				endm 
# End of macro FORTH_DSP_VALUEHL
4762 e5					push hl 	; save file id 
4763			 
4763				if DEBUG_STORESE 
4763					DMARK "AP1" 
4763 f5				push af  
4764 3a 78 47			ld a, (.dmark)  
4767 32 77 fb			ld (debug_mark),a  
476a 3a 79 47			ld a, (.dmark+1)  
476d 32 78 fb			ld (debug_mark+1),a  
4770 3a 7a 47			ld a, (.dmark+2)  
4773 32 79 fb			ld (debug_mark+2),a  
4776 18 03			jr .pastdmark  
4778 ..			.dmark: db "AP1"  
477b f1			.pastdmark: pop af  
477c			endm  
# End of macro DMARK
477c					CALLMONITOR 
477c cd 01 15			call break_point_state  
477f				endm  
# End of macro CALLMONITOR
477f				endif 
477f					FORTH_DSP_POP 
477f cd d2 1b			call macro_forth_dsp_pop 
4782				endm 
# End of macro FORTH_DSP_POP
4782			 
4782					FORTH_DSP_VALUEHL 
4782 cd 36 1b			call macro_dsp_valuehl 
4785				endm 
# End of macro FORTH_DSP_VALUEHL
4785					;v5 FORTH_DSP_VALUE 
4785 e5					push hl 	; save ptr to string to save 
4786			 
4786				if DEBUG_STORESE 
4786					DMARK "AP1" 
4786 f5				push af  
4787 3a 9b 47			ld a, (.dmark)  
478a 32 77 fb			ld (debug_mark),a  
478d 3a 9c 47			ld a, (.dmark+1)  
4790 32 78 fb			ld (debug_mark+1),a  
4793 3a 9d 47			ld a, (.dmark+2)  
4796 32 79 fb			ld (debug_mark+2),a  
4799 18 03			jr .pastdmark  
479b ..			.dmark: db "AP1"  
479e f1			.pastdmark: pop af  
479f			endm  
# End of macro DMARK
479f					CALLMONITOR 
479f cd 01 15			call break_point_state  
47a2				endm  
# End of macro CALLMONITOR
47a2				endif 
47a2					FORTH_DSP_POP 
47a2 cd d2 1b			call macro_forth_dsp_pop 
47a5				endm 
# End of macro FORTH_DSP_POP
47a5			 
47a5 d1					pop de 
47a6 e1					pop hl 
47a7				if DEBUG_STORESE 
47a7					DMARK "AP2" 
47a7 f5				push af  
47a8 3a bc 47			ld a, (.dmark)  
47ab 32 77 fb			ld (debug_mark),a  
47ae 3a bd 47			ld a, (.dmark+1)  
47b1 32 78 fb			ld (debug_mark+1),a  
47b4 3a be 47			ld a, (.dmark+2)  
47b7 32 79 fb			ld (debug_mark+2),a  
47ba 18 03			jr .pastdmark  
47bc ..			.dmark: db "AP2"  
47bf f1			.pastdmark: pop af  
47c0			endm  
# End of macro DMARK
47c0					CALLMONITOR 
47c0 cd 01 15			call break_point_state  
47c3				endm  
# End of macro CALLMONITOR
47c3				endif 
47c3					;inc de ; skip var type indicator 
47c3			 
47c3					; TODO how to append numerics???? 
47c3			 
47c3 cd cc 08				call storage_append		 
47c6			 
47c6				       NEXTW 
47c6 c3 8c 1c			jp macro_next 
47c9				endm 
# End of macro NEXTW
47c9			.SDEL: 
47c9				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
47c9 6a				db WORD_SYS_CORE+86             
47ca 15 48			dw .OPEN            
47cc 05				db 4 + 1 
47cd .. 00			db "ERA",0              
47d1				endm 
# End of macro CWHEAD
47d1			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
47d1					FORTH_DSP_VALUEHL 
47d1 cd 36 1b			call macro_dsp_valuehl 
47d4				endm 
# End of macro FORTH_DSP_VALUEHL
47d4			;		push hl 	; save file id 
47d4			 
47d4					if DEBUG_FORTH_WORDS_KEY 
47d4						DMARK "ERA" 
47d4 f5				push af  
47d5 3a e9 47			ld a, (.dmark)  
47d8 32 77 fb			ld (debug_mark),a  
47db 3a ea 47			ld a, (.dmark+1)  
47de 32 78 fb			ld (debug_mark+1),a  
47e1 3a eb 47			ld a, (.dmark+2)  
47e4 32 79 fb			ld (debug_mark+2),a  
47e7 18 03			jr .pastdmark  
47e9 ..			.dmark: db "ERA"  
47ec f1			.pastdmark: pop af  
47ed			endm  
# End of macro DMARK
47ed						CALLMONITOR 
47ed cd 01 15			call break_point_state  
47f0				endm  
# End of macro CALLMONITOR
47f0					endif 
47f0				if DEBUG_STORESE 
47f0					DMARK "ER1" 
47f0 f5				push af  
47f1 3a 05 48			ld a, (.dmark)  
47f4 32 77 fb			ld (debug_mark),a  
47f7 3a 06 48			ld a, (.dmark+1)  
47fa 32 78 fb			ld (debug_mark+1),a  
47fd 3a 07 48			ld a, (.dmark+2)  
4800 32 79 fb			ld (debug_mark+2),a  
4803 18 03			jr .pastdmark  
4805 ..			.dmark: db "ER1"  
4808 f1			.pastdmark: pop af  
4809			endm  
# End of macro DMARK
4809					CALLMONITOR 
4809 cd 01 15			call break_point_state  
480c				endm  
# End of macro CALLMONITOR
480c				endif 
480c					FORTH_DSP_POP 
480c cd d2 1b			call macro_forth_dsp_pop 
480f				endm 
# End of macro FORTH_DSP_POP
480f			 
480f			;		pop hl 
480f			 
480f cd 41 05				call storage_erase 
4812				       NEXTW 
4812 c3 8c 1c			jp macro_next 
4815				endm 
# End of macro NEXTW
4815			 
4815			.OPEN: 
4815				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4815 6b				db WORD_SYS_CORE+87             
4816 9c 48			dw .READ            
4818 05				db 4 + 1 
4819 .. 00			db "OPEN",0              
481e				endm 
# End of macro CWHEAD
481e			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
481e			; | | e.g. 
481e			; | | $01 OPEN $01 DO $01 READ . LOOP 
481e			 
481e					if DEBUG_FORTH_WORDS_KEY 
481e						DMARK "OPN" 
481e f5				push af  
481f 3a 33 48			ld a, (.dmark)  
4822 32 77 fb			ld (debug_mark),a  
4825 3a 34 48			ld a, (.dmark+1)  
4828 32 78 fb			ld (debug_mark+1),a  
482b 3a 35 48			ld a, (.dmark+2)  
482e 32 79 fb			ld (debug_mark+2),a  
4831 18 03			jr .pastdmark  
4833 ..			.dmark: db "OPN"  
4836 f1			.pastdmark: pop af  
4837			endm  
# End of macro DMARK
4837						CALLMONITOR 
4837 cd 01 15			call break_point_state  
483a				endm  
# End of macro CALLMONITOR
483a					endif 
483a					; TODO handle multiple file opens 
483a			 
483a 3e 01			       	ld a, 1 
483c 32 59 f8				ld (store_openext), a 
483f			 
483f					; get max extents for this file 
483f				 
483f								 
483f					FORTH_DSP_VALUEHL 
483f cd 36 1b			call macro_dsp_valuehl 
4842				endm 
# End of macro FORTH_DSP_VALUEHL
4842			 
4842 65					ld h, l 
4843 2e 00				ld l, 0 
4845			 
4845				if DEBUG_STORESE 
4845					DMARK "OPN" 
4845 f5				push af  
4846 3a 5a 48			ld a, (.dmark)  
4849 32 77 fb			ld (debug_mark),a  
484c 3a 5b 48			ld a, (.dmark+1)  
484f 32 78 fb			ld (debug_mark+1),a  
4852 3a 5c 48			ld a, (.dmark+2)  
4855 32 79 fb			ld (debug_mark+2),a  
4858 18 03			jr .pastdmark  
485a ..			.dmark: db "OPN"  
485d f1			.pastdmark: pop af  
485e			endm  
# End of macro DMARK
485e					CALLMONITOR 
485e cd 01 15			call break_point_state  
4861				endm  
# End of macro CALLMONITOR
4861				endif 
4861			;		push hl 
4861					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4861 cd d2 1b			call macro_forth_dsp_pop 
4864				endm 
# End of macro FORTH_DSP_POP
4864			;		pop hl 
4864						 
4864 11 62 f8				ld de, store_page      ; get block zero of file 
4867 cd 46 08				call storage_read 
486a			 
486a			 
486a 3a 64 f8				ld a, (store_page+2)    ; max extents for this file 
486d 32 58 f8				ld  (store_openmaxext), a   ; get our limit and push 
4870					 
4870				if DEBUG_STORESE 
4870					DMARK "OPx" 
4870 f5				push af  
4871 3a 85 48			ld a, (.dmark)  
4874 32 77 fb			ld (debug_mark),a  
4877 3a 86 48			ld a, (.dmark+1)  
487a 32 78 fb			ld (debug_mark+1),a  
487d 3a 87 48			ld a, (.dmark+2)  
4880 32 79 fb			ld (debug_mark+2),a  
4883 18 03			jr .pastdmark  
4885 ..			.dmark: db "OPx"  
4888 f1			.pastdmark: pop af  
4889			endm  
# End of macro DMARK
4889					CALLMONITOR 
4889 cd 01 15			call break_point_state  
488c				endm  
# End of macro CALLMONITOR
488c				endif 
488c fe 00				cp 0 
488e 20 03				jr nz, .skipopeneof 
4890					; have opened an empty file 
4890					 
4890 32 59 f8				ld (store_openext), a 
4893			 
4893			.skipopeneof: 
4893			 
4893 6f					ld l, a 
4894 26 00				ld h, 0 
4896 cd 9b 1a				call forth_push_numhl 
4899			 
4899			 
4899				       NEXTW 
4899 c3 8c 1c			jp macro_next 
489c				endm 
# End of macro NEXTW
489c			.READ: 
489c				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
489c 6c				db WORD_SYS_CORE+88             
489d e3 49			dw .EOF            
489f 05				db 4 + 1 
48a0 .. 00			db "READ",0              
48a5				endm 
# End of macro CWHEAD
48a5			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
48a5			; | | e.g. 
48a5			; | | $01 OPEN $01 DO $01 READ . LOOP 
48a5			 
48a5					if DEBUG_FORTH_WORDS_KEY 
48a5						DMARK "REA" 
48a5 f5				push af  
48a6 3a ba 48			ld a, (.dmark)  
48a9 32 77 fb			ld (debug_mark),a  
48ac 3a bb 48			ld a, (.dmark+1)  
48af 32 78 fb			ld (debug_mark+1),a  
48b2 3a bc 48			ld a, (.dmark+2)  
48b5 32 79 fb			ld (debug_mark+2),a  
48b8 18 03			jr .pastdmark  
48ba ..			.dmark: db "REA"  
48bd f1			.pastdmark: pop af  
48be			endm  
# End of macro DMARK
48be						CALLMONITOR 
48be cd 01 15			call break_point_state  
48c1				endm  
# End of macro CALLMONITOR
48c1					endif 
48c1					; store_openext use it. If zero it is EOF 
48c1			 
48c1					; read block from current stream id 
48c1					; if the block does not contain zero term keep reading blocks until zero found 
48c1					; push the block to stack 
48c1					; save the block id to stream 
48c1			 
48c1			 
48c1					FORTH_DSP_VALUEHL 
48c1 cd 36 1b			call macro_dsp_valuehl 
48c4				endm 
# End of macro FORTH_DSP_VALUEHL
48c4			 
48c4			;		push hl 
48c4			 
48c4				if DEBUG_STORESE 
48c4					DMARK "REA" 
48c4 f5				push af  
48c5 3a d9 48			ld a, (.dmark)  
48c8 32 77 fb			ld (debug_mark),a  
48cb 3a da 48			ld a, (.dmark+1)  
48ce 32 78 fb			ld (debug_mark+1),a  
48d1 3a db 48			ld a, (.dmark+2)  
48d4 32 79 fb			ld (debug_mark+2),a  
48d7 18 03			jr .pastdmark  
48d9 ..			.dmark: db "REA"  
48dc f1			.pastdmark: pop af  
48dd			endm  
# End of macro DMARK
48dd					CALLMONITOR 
48dd cd 01 15			call break_point_state  
48e0				endm  
# End of macro CALLMONITOR
48e0				endif 
48e0					FORTH_DSP_POP 
48e0 cd d2 1b			call macro_forth_dsp_pop 
48e3				endm 
# End of macro FORTH_DSP_POP
48e3			 
48e3			;		pop hl 
48e3				 
48e3 65					ld h,l 
48e4			 
48e4 3a 59 f8				ld a, (store_openext) 
48e7 6f					ld l, a 
48e8					 
48e8 fe 00				cp 0 
48ea ca b5 49				jp z, .ateof     ; dont read past eof 
48ed			 
48ed			 
48ed 11 62 f8				ld de, store_page 
48f0				if DEBUG_STORESE 
48f0					DMARK "RE1" 
48f0 f5				push af  
48f1 3a 05 49			ld a, (.dmark)  
48f4 32 77 fb			ld (debug_mark),a  
48f7 3a 06 49			ld a, (.dmark+1)  
48fa 32 78 fb			ld (debug_mark+1),a  
48fd 3a 07 49			ld a, (.dmark+2)  
4900 32 79 fb			ld (debug_mark+2),a  
4903 18 03			jr .pastdmark  
4905 ..			.dmark: db "RE1"  
4908 f1			.pastdmark: pop af  
4909			endm  
# End of macro DMARK
4909					CALLMONITOR 
4909 cd 01 15			call break_point_state  
490c				endm  
# End of macro CALLMONITOR
490c				endif 
490c cd 46 08				call storage_read 
490f			 
490f				if DEBUG_STORESE 
490f					DMARK "RE2" 
490f f5				push af  
4910 3a 24 49			ld a, (.dmark)  
4913 32 77 fb			ld (debug_mark),a  
4916 3a 25 49			ld a, (.dmark+1)  
4919 32 78 fb			ld (debug_mark+1),a  
491c 3a 26 49			ld a, (.dmark+2)  
491f 32 79 fb			ld (debug_mark+2),a  
4922 18 03			jr .pastdmark  
4924 ..			.dmark: db "RE2"  
4927 f1			.pastdmark: pop af  
4928			endm  
# End of macro DMARK
4928					CALLMONITOR 
4928 cd 01 15			call break_point_state  
492b				endm  
# End of macro CALLMONITOR
492b				endif 
492b cd e8 0c			call ishlzero 
492e			;	ld a, l 
492e			;	add h 
492e			;	cp 0 
492e ca bb 49			jp z, .readeof 
4931			 
4931				; not eof so hl should point to data to push to stack 
4931			 
4931				if DEBUG_STORESE 
4931					DMARK "RE3" 
4931 f5				push af  
4932 3a 46 49			ld a, (.dmark)  
4935 32 77 fb			ld (debug_mark),a  
4938 3a 47 49			ld a, (.dmark+1)  
493b 32 78 fb			ld (debug_mark+1),a  
493e 3a 48 49			ld a, (.dmark+2)  
4941 32 79 fb			ld (debug_mark+2),a  
4944 18 03			jr .pastdmark  
4946 ..			.dmark: db "RE3"  
4949 f1			.pastdmark: pop af  
494a			endm  
# End of macro DMARK
494a					CALLMONITOR 
494a cd 01 15			call break_point_state  
494d				endm  
# End of macro CALLMONITOR
494d				endif 
494d cd ad 1a			call forth_push_str 
4950			 
4950				if DEBUG_STORESE 
4950					DMARK "RE4" 
4950 f5				push af  
4951 3a 65 49			ld a, (.dmark)  
4954 32 77 fb			ld (debug_mark),a  
4957 3a 66 49			ld a, (.dmark+1)  
495a 32 78 fb			ld (debug_mark+1),a  
495d 3a 67 49			ld a, (.dmark+2)  
4960 32 79 fb			ld (debug_mark+2),a  
4963 18 03			jr .pastdmark  
4965 ..			.dmark: db "RE4"  
4968 f1			.pastdmark: pop af  
4969			endm  
# End of macro DMARK
4969					CALLMONITOR 
4969 cd 01 15			call break_point_state  
496c				endm  
# End of macro CALLMONITOR
496c				endif 
496c				; get next block  or mark as eof 
496c			 
496c 3a 58 f8			ld a, (store_openmaxext)   ; get our limit 
496f 4f				ld c, a	 
4970 3a 59 f8			ld a, (store_openext) 
4973			 
4973				if DEBUG_STORESE 
4973					DMARK "RE5" 
4973 f5				push af  
4974 3a 88 49			ld a, (.dmark)  
4977 32 77 fb			ld (debug_mark),a  
497a 3a 89 49			ld a, (.dmark+1)  
497d 32 78 fb			ld (debug_mark+1),a  
4980 3a 8a 49			ld a, (.dmark+2)  
4983 32 79 fb			ld (debug_mark+2),a  
4986 18 03			jr .pastdmark  
4988 ..			.dmark: db "RE5"  
498b f1			.pastdmark: pop af  
498c			endm  
# End of macro DMARK
498c					CALLMONITOR 
498c cd 01 15			call break_point_state  
498f				endm  
# End of macro CALLMONITOR
498f				endif 
498f b9				cp c 
4990 28 29			jr z, .readeof     ; at last extent 
4992			 
4992 3c					inc a 
4993 32 59 f8				ld (store_openext), a 
4996			 
4996				if DEBUG_STORESE 
4996					DMARK "RE6" 
4996 f5				push af  
4997 3a ab 49			ld a, (.dmark)  
499a 32 77 fb			ld (debug_mark),a  
499d 3a ac 49			ld a, (.dmark+1)  
49a0 32 78 fb			ld (debug_mark+1),a  
49a3 3a ad 49			ld a, (.dmark+2)  
49a6 32 79 fb			ld (debug_mark+2),a  
49a9 18 03			jr .pastdmark  
49ab ..			.dmark: db "RE6"  
49ae f1			.pastdmark: pop af  
49af			endm  
# End of macro DMARK
49af					CALLMONITOR 
49af cd 01 15			call break_point_state  
49b2				endm  
# End of macro CALLMONITOR
49b2				endif 
49b2			 
49b2			 
49b2				       NEXTW 
49b2 c3 8c 1c			jp macro_next 
49b5				endm 
# End of macro NEXTW
49b5			.ateof: 
49b5 21 df 49				ld hl, .showeof 
49b8 cd ad 1a				call forth_push_str 
49bb 3e 00		.readeof:	ld a, 0 
49bd 32 59 f8				ld (store_openext), a 
49c0			 
49c0					 
49c0				if DEBUG_STORESE 
49c0					DMARK "REF" 
49c0 f5				push af  
49c1 3a d5 49			ld a, (.dmark)  
49c4 32 77 fb			ld (debug_mark),a  
49c7 3a d6 49			ld a, (.dmark+1)  
49ca 32 78 fb			ld (debug_mark+1),a  
49cd 3a d7 49			ld a, (.dmark+2)  
49d0 32 79 fb			ld (debug_mark+2),a  
49d3 18 03			jr .pastdmark  
49d5 ..			.dmark: db "REF"  
49d8 f1			.pastdmark: pop af  
49d9			endm  
# End of macro DMARK
49d9					CALLMONITOR 
49d9 cd 01 15			call break_point_state  
49dc				endm  
# End of macro CALLMONITOR
49dc				endif 
49dc				       NEXTW 
49dc c3 8c 1c			jp macro_next 
49df				endm 
# End of macro NEXTW
49df			 
49df .. 00		.showeof:   db "eof", 0 
49e3			 
49e3			 
49e3			.EOF: 
49e3				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
49e3 6d				db WORD_SYS_CORE+89             
49e4 24 4a			dw .FORMAT            
49e6 04				db 3 + 1 
49e7 .. 00			db "EOF",0              
49eb				endm 
# End of macro CWHEAD
49eb			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
49eb			; | | e.g. 
49eb			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
49eb					; TODO if current block id for stream is zero then push true else false 
49eb			 
49eb					if DEBUG_FORTH_WORDS_KEY 
49eb						DMARK "EOF" 
49eb f5				push af  
49ec 3a 00 4a			ld a, (.dmark)  
49ef 32 77 fb			ld (debug_mark),a  
49f2 3a 01 4a			ld a, (.dmark+1)  
49f5 32 78 fb			ld (debug_mark+1),a  
49f8 3a 02 4a			ld a, (.dmark+2)  
49fb 32 79 fb			ld (debug_mark+2),a  
49fe 18 03			jr .pastdmark  
4a00 ..			.dmark: db "EOF"  
4a03 f1			.pastdmark: pop af  
4a04			endm  
# End of macro DMARK
4a04						CALLMONITOR 
4a04 cd 01 15			call break_point_state  
4a07				endm  
# End of macro CALLMONITOR
4a07					endif 
4a07			 
4a07					; TODO handlue multiple file streams 
4a07			 
4a07					FORTH_DSP_POP     ; for now just get rid of stream id 
4a07 cd d2 1b			call macro_forth_dsp_pop 
4a0a				endm 
# End of macro FORTH_DSP_POP
4a0a			 
4a0a 2e 01				ld l, 1 
4a0c 3a 58 f8				ld a, (store_openmaxext) 
4a0f fe 00				cp 0 
4a11 28 09				jr  z, .eofdone   ; empty file 
4a13 3a 59 f8				ld a, (store_openext) 
4a16 fe 00				cp 0 
4a18 28 02				jr  z, .eofdone 
4a1a 2e 00				ld l, 0 
4a1c 26 00		.eofdone:	ld h, 0 
4a1e cd 9b 1a				call forth_push_numhl 
4a21			 
4a21			 
4a21				       NEXTW 
4a21 c3 8c 1c			jp macro_next 
4a24				endm 
# End of macro NEXTW
4a24			 
4a24			.FORMAT: 
4a24				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4a24 6d				db WORD_SYS_CORE+89             
4a25 75 4a			dw .LABEL            
4a27 07				db 6 + 1 
4a28 .. 00			db "FORMAT",0              
4a2f				endm 
# End of macro CWHEAD
4a2f			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4a2f					; TODO if current block id for stream is zero then push true else false 
4a2f				 
4a2f				if DEBUG_STORESE 
4a2f					DMARK "FOR" 
4a2f f5				push af  
4a30 3a 44 4a			ld a, (.dmark)  
4a33 32 77 fb			ld (debug_mark),a  
4a36 3a 45 4a			ld a, (.dmark+1)  
4a39 32 78 fb			ld (debug_mark+1),a  
4a3c 3a 46 4a			ld a, (.dmark+2)  
4a3f 32 79 fb			ld (debug_mark+2),a  
4a42 18 03			jr .pastdmark  
4a44 ..			.dmark: db "FOR"  
4a47 f1			.pastdmark: pop af  
4a48			endm  
# End of macro DMARK
4a48					CALLMONITOR 
4a48 cd 01 15			call break_point_state  
4a4b				endm  
# End of macro CALLMONITOR
4a4b				endif 
4a4b					; Wipes the bank check flags to cause a reformat on next block 0 read 
4a4b			 
4a4b 21 01 00				ld hl, 1 
4a4e 3e 00				ld a, 0 
4a50 cd ea 01				call se_writebyte 
4a53			 
4a53				if DEBUG_STORESE 
4a53					DMARK "FO0" 
4a53 f5				push af  
4a54 3a 68 4a			ld a, (.dmark)  
4a57 32 77 fb			ld (debug_mark),a  
4a5a 3a 69 4a			ld a, (.dmark+1)  
4a5d 32 78 fb			ld (debug_mark+1),a  
4a60 3a 6a 4a			ld a, (.dmark+2)  
4a63 32 79 fb			ld (debug_mark+2),a  
4a66 18 03			jr .pastdmark  
4a68 ..			.dmark: db "FO0"  
4a6b f1			.pastdmark: pop af  
4a6c			endm  
# End of macro DMARK
4a6c					CALLMONITOR 
4a6c cd 01 15			call break_point_state  
4a6f				endm  
# End of macro CALLMONITOR
4a6f				endif 
4a6f					; force bank init 
4a6f			 
4a6f cd bd 03				call storage_get_block_0 
4a72					 
4a72				       NEXTW 
4a72 c3 8c 1c			jp macro_next 
4a75				endm 
# End of macro NEXTW
4a75			.LABEL: 
4a75				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4a75 6d				db WORD_SYS_CORE+89             
4a76 c3 4a			dw .STOREPAGE            
4a78 06				db 5 + 1 
4a79 .. 00			db "LABEL",0              
4a7f				endm 
# End of macro CWHEAD
4a7f			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4a7f					; TODO test to see if bank is selected 
4a7f				 
4a7f					if DEBUG_FORTH_WORDS_KEY 
4a7f						DMARK "LBL" 
4a7f f5				push af  
4a80 3a 94 4a			ld a, (.dmark)  
4a83 32 77 fb			ld (debug_mark),a  
4a86 3a 95 4a			ld a, (.dmark+1)  
4a89 32 78 fb			ld (debug_mark+1),a  
4a8c 3a 96 4a			ld a, (.dmark+2)  
4a8f 32 79 fb			ld (debug_mark+2),a  
4a92 18 03			jr .pastdmark  
4a94 ..			.dmark: db "LBL"  
4a97 f1			.pastdmark: pop af  
4a98			endm  
# End of macro DMARK
4a98						CALLMONITOR 
4a98 cd 01 15			call break_point_state  
4a9b				endm  
# End of macro CALLMONITOR
4a9b					endif 
4a9b			;	if DEBUG_STORESE 
4a9b			;		DMARK "LBL" 
4a9b			;		CALLMONITOR 
4a9b			;	endif 
4a9b					FORTH_DSP_VALUEHL 
4a9b cd 36 1b			call macro_dsp_valuehl 
4a9e				endm 
# End of macro FORTH_DSP_VALUEHL
4a9e					;v5FORTH_DSP_VALUE 
4a9e					 
4a9e			;		push hl 
4a9e					FORTH_DSP_POP 
4a9e cd d2 1b			call macro_forth_dsp_pop 
4aa1				endm 
# End of macro FORTH_DSP_POP
4aa1			;		pop hl 
4aa1			 
4aa1			;v5		inc hl   ; move past the type marker 
4aa1			 
4aa1				if DEBUG_STORESE 
4aa1					DMARK "LBl" 
4aa1 f5				push af  
4aa2 3a b6 4a			ld a, (.dmark)  
4aa5 32 77 fb			ld (debug_mark),a  
4aa8 3a b7 4a			ld a, (.dmark+1)  
4aab 32 78 fb			ld (debug_mark+1),a  
4aae 3a b8 4a			ld a, (.dmark+2)  
4ab1 32 79 fb			ld (debug_mark+2),a  
4ab4 18 03			jr .pastdmark  
4ab6 ..			.dmark: db "LBl"  
4ab9 f1			.pastdmark: pop af  
4aba			endm  
# End of macro DMARK
4aba					CALLMONITOR 
4aba cd 01 15			call break_point_state  
4abd				endm  
# End of macro CALLMONITOR
4abd				endif 
4abd cd d6 04				call storage_label 
4ac0			 
4ac0				       NEXTW 
4ac0 c3 8c 1c			jp macro_next 
4ac3				endm 
# End of macro NEXTW
4ac3			.STOREPAGE: 
4ac3				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4ac3 6d				db WORD_SYS_CORE+89             
4ac4 f6 4a			dw .LABELS            
4ac6 0a				db 9 + 1 
4ac7 .. 00			db "STOREPAGE",0              
4ad1				endm 
# End of macro CWHEAD
4ad1			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4ad1					; TODO test to see if bank is selected 
4ad1				 
4ad1					if DEBUG_FORTH_WORDS_KEY 
4ad1						DMARK "STP" 
4ad1 f5				push af  
4ad2 3a e6 4a			ld a, (.dmark)  
4ad5 32 77 fb			ld (debug_mark),a  
4ad8 3a e7 4a			ld a, (.dmark+1)  
4adb 32 78 fb			ld (debug_mark+1),a  
4ade 3a e8 4a			ld a, (.dmark+2)  
4ae1 32 79 fb			ld (debug_mark+2),a  
4ae4 18 03			jr .pastdmark  
4ae6 ..			.dmark: db "STP"  
4ae9 f1			.pastdmark: pop af  
4aea			endm  
# End of macro DMARK
4aea						CALLMONITOR 
4aea cd 01 15			call break_point_state  
4aed				endm  
# End of macro CALLMONITOR
4aed					endif 
4aed			;	if DEBUG_STORESE 
4aed			;		DMARK "STP" 
4aed			;		CALLMONITOR 
4aed			;	endif 
4aed			 
4aed 21 62 f8			ld hl, store_page 
4af0 cd 9b 1a			call forth_push_numhl 
4af3			 
4af3			 
4af3				       NEXTW 
4af3 c3 8c 1c			jp macro_next 
4af6				endm 
# End of macro NEXTW
4af6			.LABELS: 
4af6				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4af6 6d				db WORD_SYS_CORE+89             
4af7 80 4b			dw .ENDSTORAGE            
4af9 07				db 6 + 1 
4afa .. 00			db "LABELS",0              
4b01				endm 
# End of macro CWHEAD
4b01			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4b01					;  
4b01			 
4b01					; save the current device selected to restore afterwards 
4b01				 
4b01 3a 5c f8				ld a, (spi_device) 
4b04 f5					push af 
4b05			 
4b05			 
4b05					; run through each of the banks 
4b05			 
4b05 21 01 00				ld hl, 1 
4b08 cd 9b 1a				call forth_push_numhl 
4b0b 3e ff				ld a, SPI_CE_HIGH 
4b0d cb 87				res SPI_CE0, a 
4b0f 32 5c f8				ld (spi_device), a 
4b12 cd bd 03				call storage_get_block_0 
4b15 21 65 f8				ld hl, store_page+3 
4b18 cd ad 1a				call forth_push_str 
4b1b			 
4b1b					 
4b1b 21 02 00				ld hl, 2 
4b1e cd 9b 1a				call forth_push_numhl 
4b21 3e ff				ld a, SPI_CE_HIGH 
4b23 cb 8f				res SPI_CE1, a 
4b25 32 5c f8				ld (spi_device), a 
4b28 cd bd 03				call storage_get_block_0 
4b2b 21 65 f8				ld hl, store_page+3 
4b2e cd ad 1a				call forth_push_str 
4b31			 
4b31					 
4b31 21 03 00				ld hl, 3 
4b34 cd 9b 1a				call forth_push_numhl 
4b37 3e ff				ld a, SPI_CE_HIGH 
4b39 cb 97				res SPI_CE2, a 
4b3b 32 5c f8				ld (spi_device), a 
4b3e cd bd 03				call storage_get_block_0 
4b41 21 65 f8				ld hl, store_page+3 
4b44 cd ad 1a				call forth_push_str 
4b47			 
4b47			 
4b47 21 04 00				ld hl, 4 
4b4a cd 9b 1a				call forth_push_numhl 
4b4d 3e ff				ld a, SPI_CE_HIGH 
4b4f cb 9f				res SPI_CE3, a 
4b51 32 5c f8				ld (spi_device), a 
4b54 cd bd 03				call storage_get_block_0 
4b57 21 65 f8				ld hl, store_page+3 
4b5a cd ad 1a				call forth_push_str 
4b5d			 
4b5d					 
4b5d			 
4b5d 21 05 00				ld hl, 5 
4b60 cd 9b 1a				call forth_push_numhl 
4b63 3e ff				ld a, SPI_CE_HIGH 
4b65 cb a7				res SPI_CE4, a 
4b67 32 5c f8				ld (spi_device), a 
4b6a cd bd 03				call storage_get_block_0 
4b6d 21 65 f8				ld hl, store_page+3 
4b70 cd ad 1a				call forth_push_str 
4b73			 
4b73					 
4b73					; push fixed count of storage devices (on board) for now 
4b73			 
4b73 21 05 00				ld hl, 5 
4b76 cd 9b 1a				call forth_push_numhl 
4b79			 
4b79					; restore selected device  
4b79				 
4b79 f1					pop af 
4b7a 32 5c f8				ld (spi_device), a 
4b7d			 
4b7d				       NEXTW 
4b7d c3 8c 1c			jp macro_next 
4b80				endm 
# End of macro NEXTW
4b80			 
4b80			.ENDSTORAGE: 
4b80			; eof 
# End of file forth_words_storage.asm
4b80			endif 
4b80				include "forth_words_device.asm" 
4b80			; Device related words 
4b80			 
4b80			; | ## Device Words 
4b80			 
4b80			if SOUND_ENABLE 
4b80			.NOTE: 
4b80				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4b80 33				db WORD_SYS_CORE+31             
4b81 a8 4b			dw .AFTERSOUND            
4b83 05				db 4 + 1 
4b84 .. 00			db "NOTE",0              
4b89				endm 
# End of macro CWHEAD
4b89			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4b89					if DEBUG_FORTH_WORDS_KEY 
4b89						DMARK "NTE" 
4b89 f5				push af  
4b8a 3a 9e 4b			ld a, (.dmark)  
4b8d 32 77 fb			ld (debug_mark),a  
4b90 3a 9f 4b			ld a, (.dmark+1)  
4b93 32 78 fb			ld (debug_mark+1),a  
4b96 3a a0 4b			ld a, (.dmark+2)  
4b99 32 79 fb			ld (debug_mark+2),a  
4b9c 18 03			jr .pastdmark  
4b9e ..			.dmark: db "NTE"  
4ba1 f1			.pastdmark: pop af  
4ba2			endm  
# End of macro DMARK
4ba2						CALLMONITOR 
4ba2 cd 01 15			call break_point_state  
4ba5				endm  
# End of macro CALLMONITOR
4ba5					endif 
4ba5			 
4ba5				 
4ba5			 
4ba5					NEXTW 
4ba5 c3 8c 1c			jp macro_next 
4ba8				endm 
# End of macro NEXTW
4ba8			.AFTERSOUND: 
4ba8			endif 
4ba8			 
4ba8			 
4ba8			USE_GPIO: equ 0 
4ba8			 
4ba8			if USE_GPIO 
4ba8			.GP1: 
4ba8				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4ba8			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4ba8					NEXTW 
4ba8			.GP2: 
4ba8				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4ba8			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4ba8			 
4ba8					NEXTW 
4ba8			 
4ba8			.GP3: 
4ba8				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4ba8			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4ba8			 
4ba8					NEXTW 
4ba8			 
4ba8			.GP4: 
4ba8				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4ba8			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4ba8			 
4ba8					NEXTW 
4ba8			.SIN: 
4ba8			 
4ba8			 
4ba8			endif 
4ba8			 
4ba8			 
4ba8				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4ba8 33				db WORD_SYS_CORE+31             
4ba9 dd 4b			dw .SOUT            
4bab 03				db 2 + 1 
4bac .. 00			db "IN",0              
4baf				endm 
# End of macro CWHEAD
4baf			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4baf					if DEBUG_FORTH_WORDS_KEY 
4baf						DMARK "IN." 
4baf f5				push af  
4bb0 3a c4 4b			ld a, (.dmark)  
4bb3 32 77 fb			ld (debug_mark),a  
4bb6 3a c5 4b			ld a, (.dmark+1)  
4bb9 32 78 fb			ld (debug_mark+1),a  
4bbc 3a c6 4b			ld a, (.dmark+2)  
4bbf 32 79 fb			ld (debug_mark+2),a  
4bc2 18 03			jr .pastdmark  
4bc4 ..			.dmark: db "IN."  
4bc7 f1			.pastdmark: pop af  
4bc8			endm  
# End of macro DMARK
4bc8						CALLMONITOR 
4bc8 cd 01 15			call break_point_state  
4bcb				endm  
# End of macro CALLMONITOR
4bcb					endif 
4bcb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bcb cd 36 1b			call macro_dsp_valuehl 
4bce				endm 
# End of macro FORTH_DSP_VALUEHL
4bce			 
4bce e5					push hl 
4bcf			 
4bcf					; destroy value TOS 
4bcf			 
4bcf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bcf cd d2 1b			call macro_forth_dsp_pop 
4bd2				endm 
# End of macro FORTH_DSP_POP
4bd2			 
4bd2					; one value on hl get other one back 
4bd2			 
4bd2 c1					pop bc 
4bd3			 
4bd3					; do the sub 
4bd3			;		ex de, hl 
4bd3			 
4bd3 ed 68				in l,(c) 
4bd5			 
4bd5					; save it 
4bd5			 
4bd5 26 00				ld h,0 
4bd7			 
4bd7					; TODO push value back onto stack for another op etc 
4bd7			 
4bd7 cd 9b 1a				call forth_push_numhl 
4bda					NEXTW 
4bda c3 8c 1c			jp macro_next 
4bdd				endm 
# End of macro NEXTW
4bdd			.SOUT: 
4bdd				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4bdd 34				db WORD_SYS_CORE+32             
4bde 30 4c			dw .SPIO            
4be0 04				db 3 + 1 
4be1 .. 00			db "OUT",0              
4be5				endm 
# End of macro CWHEAD
4be5			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4be5					if DEBUG_FORTH_WORDS_KEY 
4be5						DMARK "OUT" 
4be5 f5				push af  
4be6 3a fa 4b			ld a, (.dmark)  
4be9 32 77 fb			ld (debug_mark),a  
4bec 3a fb 4b			ld a, (.dmark+1)  
4bef 32 78 fb			ld (debug_mark+1),a  
4bf2 3a fc 4b			ld a, (.dmark+2)  
4bf5 32 79 fb			ld (debug_mark+2),a  
4bf8 18 03			jr .pastdmark  
4bfa ..			.dmark: db "OUT"  
4bfd f1			.pastdmark: pop af  
4bfe			endm  
# End of macro DMARK
4bfe						CALLMONITOR 
4bfe cd 01 15			call break_point_state  
4c01				endm  
# End of macro CALLMONITOR
4c01					endif 
4c01			 
4c01					; get port 
4c01			 
4c01					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c01 cd 36 1b			call macro_dsp_valuehl 
4c04				endm 
# End of macro FORTH_DSP_VALUEHL
4c04			 
4c04 e5					push hl 
4c05			 
4c05					; destroy value TOS 
4c05			 
4c05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c05 cd d2 1b			call macro_forth_dsp_pop 
4c08				endm 
# End of macro FORTH_DSP_POP
4c08			 
4c08					; get byte to send 
4c08			 
4c08					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c08 cd 36 1b			call macro_dsp_valuehl 
4c0b				endm 
# End of macro FORTH_DSP_VALUEHL
4c0b			 
4c0b			;		push hl 
4c0b			 
4c0b					; destroy value TOS 
4c0b			 
4c0b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c0b cd d2 1b			call macro_forth_dsp_pop 
4c0e				endm 
# End of macro FORTH_DSP_POP
4c0e			 
4c0e					; one value on hl get other one back 
4c0e			 
4c0e			;		pop hl 
4c0e			 
4c0e c1					pop bc 
4c0f			 
4c0f					if DEBUG_FORTH_WORDS 
4c0f						DMARK "OUT" 
4c0f f5				push af  
4c10 3a 24 4c			ld a, (.dmark)  
4c13 32 77 fb			ld (debug_mark),a  
4c16 3a 25 4c			ld a, (.dmark+1)  
4c19 32 78 fb			ld (debug_mark+1),a  
4c1c 3a 26 4c			ld a, (.dmark+2)  
4c1f 32 79 fb			ld (debug_mark+2),a  
4c22 18 03			jr .pastdmark  
4c24 ..			.dmark: db "OUT"  
4c27 f1			.pastdmark: pop af  
4c28			endm  
# End of macro DMARK
4c28						CALLMONITOR 
4c28 cd 01 15			call break_point_state  
4c2b				endm  
# End of macro CALLMONITOR
4c2b					endif 
4c2b			 
4c2b ed 69				out (c), l 
4c2d			 
4c2d					NEXTW 
4c2d c3 8c 1c			jp macro_next 
4c30				endm 
# End of macro NEXTW
4c30			 
4c30			 
4c30			.SPIO: 
4c30			 
4c30			if STORAGE_SE 
4c30				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4c30 51				db WORD_SYS_CORE+61             
4c31 41 4c			dw .SPICEH            
4c33 07				db 6 + 1 
4c34 .. 00			db "SPICEL",0              
4c3b				endm 
# End of macro CWHEAD
4c3b			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4c3b			 
4c3b cd 98 01				call spi_ce_low 
4c3e			    NEXTW 
4c3e c3 8c 1c			jp macro_next 
4c41				endm 
# End of macro NEXTW
4c41			 
4c41			.SPICEH: 
4c41				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4c41 51				db WORD_SYS_CORE+61             
4c42 52 4c			dw .SPIOb            
4c44 07				db 6 + 1 
4c45 .. 00			db "SPICEH",0              
4c4c				endm 
# End of macro CWHEAD
4c4c			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4c4c			 
4c4c cd 87 01				call spi_ce_high 
4c4f			    NEXTW 
4c4f c3 8c 1c			jp macro_next 
4c52				endm 
# End of macro NEXTW
4c52			 
4c52			 
4c52			.SPIOb: 
4c52			 
4c52				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4c52 51				db WORD_SYS_CORE+61             
4c53 68 4c			dw .SPII            
4c55 05				db 4 + 1 
4c56 .. 00			db "SPIO",0              
4c5b				endm 
# End of macro CWHEAD
4c5b			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4c5b			 
4c5b					; get port 
4c5b			 
4c5b			 
4c5b					; get byte to send 
4c5b			 
4c5b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c5b cd 36 1b			call macro_dsp_valuehl 
4c5e				endm 
# End of macro FORTH_DSP_VALUEHL
4c5e			 
4c5e			;		push hl    ; u1  
4c5e			 
4c5e					; destroy value TOS 
4c5e			 
4c5e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c5e cd d2 1b			call macro_forth_dsp_pop 
4c61				endm 
# End of macro FORTH_DSP_POP
4c61			 
4c61					; one value on hl get other one back 
4c61			 
4c61			;		pop hl   ; u2 - addr 
4c61			 
4c61					; TODO Send SPI byte 
4c61			 
4c61 7d					ld a, l 
4c62 cd bc 00				call spi_send_byte 
4c65			 
4c65					NEXTW 
4c65 c3 8c 1c			jp macro_next 
4c68				endm 
# End of macro NEXTW
4c68			 
4c68			.SPII: 
4c68				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4c68 52				db WORD_SYS_CORE+62             
4c69 7d 4c			dw .SESEL            
4c6b 06				db 5 + 1 
4c6c .. 00			db "SPII",0              
4c71				endm 
# End of macro CWHEAD
4c71			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4c71			 
4c71					; TODO Get SPI byte 
4c71			 
4c71 cd dd 00				call spi_read_byte 
4c74			 
4c74 26 00				ld h, 0 
4c76 6f					ld l, a 
4c77 cd 9b 1a				call forth_push_numhl 
4c7a			 
4c7a					NEXTW 
4c7a c3 8c 1c			jp macro_next 
4c7d				endm 
# End of macro NEXTW
4c7d			 
4c7d			 
4c7d			 
4c7d			.SESEL: 
4c7d				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4c7d 66				db WORD_SYS_CORE+82             
4c7e 11 4d			dw .CARTDEV            
4c80 05				db 4 + 1 
4c81 .. 00			db "BANK",0              
4c86				endm 
# End of macro CWHEAD
4c86			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4c86					if DEBUG_FORTH_WORDS_KEY 
4c86						DMARK "BNK" 
4c86 f5				push af  
4c87 3a 9b 4c			ld a, (.dmark)  
4c8a 32 77 fb			ld (debug_mark),a  
4c8d 3a 9c 4c			ld a, (.dmark+1)  
4c90 32 78 fb			ld (debug_mark+1),a  
4c93 3a 9d 4c			ld a, (.dmark+2)  
4c96 32 79 fb			ld (debug_mark+2),a  
4c99 18 03			jr .pastdmark  
4c9b ..			.dmark: db "BNK"  
4c9e f1			.pastdmark: pop af  
4c9f			endm  
# End of macro DMARK
4c9f						CALLMONITOR 
4c9f cd 01 15			call break_point_state  
4ca2				endm  
# End of macro CALLMONITOR
4ca2					endif 
4ca2			 
4ca2 3e ff				ld a, 255 
4ca4 32 5f f8				ld (spi_cartdev), a 
4ca7			 
4ca7					; get bank 
4ca7			 
4ca7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ca7 cd 36 1b			call macro_dsp_valuehl 
4caa				endm 
# End of macro FORTH_DSP_VALUEHL
4caa			 
4caa			;		push hl 
4caa			 
4caa					; destroy value TOS 
4caa			 
4caa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4caa cd d2 1b			call macro_forth_dsp_pop 
4cad				endm 
# End of macro FORTH_DSP_POP
4cad			 
4cad					; one value on hl get other one back 
4cad			 
4cad			;		pop hl 
4cad			 
4cad			 
4cad 0e ff				ld c, SPI_CE_HIGH 
4caf			 
4caf 7d					ld a, l 
4cb0			 
4cb0					if DEBUG_FORTH_WORDS 
4cb0						DMARK "BNK" 
4cb0 f5				push af  
4cb1 3a c5 4c			ld a, (.dmark)  
4cb4 32 77 fb			ld (debug_mark),a  
4cb7 3a c6 4c			ld a, (.dmark+1)  
4cba 32 78 fb			ld (debug_mark+1),a  
4cbd 3a c7 4c			ld a, (.dmark+2)  
4cc0 32 79 fb			ld (debug_mark+2),a  
4cc3 18 03			jr .pastdmark  
4cc5 ..			.dmark: db "BNK"  
4cc8 f1			.pastdmark: pop af  
4cc9			endm  
# End of macro DMARK
4cc9						CALLMONITOR 
4cc9 cd 01 15			call break_point_state  
4ccc				endm  
# End of macro CALLMONITOR
4ccc					endif 
4ccc			 
4ccc					; active low 
4ccc			 
4ccc fe 00				cp 0 
4cce 28 1e				jr z, .bset 
4cd0 fe 01				cp 1 
4cd2 20 02				jr nz, .b2 
4cd4 cb 81				res 0, c 
4cd6 fe 02		.b2:		cp 2 
4cd8 20 02				jr nz, .b3 
4cda cb 89				res 1, c 
4cdc fe 03		.b3:		cp 3 
4cde 20 02				jr nz, .b4 
4ce0 cb 91				res 2, c 
4ce2 fe 04		.b4:		cp 4 
4ce4 20 02				jr nz, .b5 
4ce6 cb 99				res 3, c 
4ce8 fe 05		.b5:		cp 5 
4cea 20 02				jr nz, .bset 
4cec cb a1				res 4, c 
4cee			 
4cee			.bset: 
4cee 79					ld a, c 
4cef 32 5c f8				ld (spi_device),a 
4cf2					if DEBUG_FORTH_WORDS 
4cf2						DMARK "BN2" 
4cf2 f5				push af  
4cf3 3a 07 4d			ld a, (.dmark)  
4cf6 32 77 fb			ld (debug_mark),a  
4cf9 3a 08 4d			ld a, (.dmark+1)  
4cfc 32 78 fb			ld (debug_mark+1),a  
4cff 3a 09 4d			ld a, (.dmark+2)  
4d02 32 79 fb			ld (debug_mark+2),a  
4d05 18 03			jr .pastdmark  
4d07 ..			.dmark: db "BN2"  
4d0a f1			.pastdmark: pop af  
4d0b			endm  
# End of macro DMARK
4d0b						CALLMONITOR 
4d0b cd 01 15			call break_point_state  
4d0e				endm  
# End of macro CALLMONITOR
4d0e					endif 
4d0e			 
4d0e					NEXTW 
4d0e c3 8c 1c			jp macro_next 
4d11				endm 
# End of macro NEXTW
4d11			 
4d11			.CARTDEV: 
4d11				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4d11 66				db WORD_SYS_CORE+82             
4d12 ba 4d			dw .ENDDEVICE            
4d14 08				db 7 + 1 
4d15 .. 00			db "CARTDEV",0              
4d1d				endm 
# End of macro CWHEAD
4d1d			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4d1d					if DEBUG_FORTH_WORDS_KEY 
4d1d						DMARK "CDV" 
4d1d f5				push af  
4d1e 3a 32 4d			ld a, (.dmark)  
4d21 32 77 fb			ld (debug_mark),a  
4d24 3a 33 4d			ld a, (.dmark+1)  
4d27 32 78 fb			ld (debug_mark+1),a  
4d2a 3a 34 4d			ld a, (.dmark+2)  
4d2d 32 79 fb			ld (debug_mark+2),a  
4d30 18 03			jr .pastdmark  
4d32 ..			.dmark: db "CDV"  
4d35 f1			.pastdmark: pop af  
4d36			endm  
# End of macro DMARK
4d36						CALLMONITOR 
4d36 cd 01 15			call break_point_state  
4d39				endm  
# End of macro CALLMONITOR
4d39					endif 
4d39			 
4d39					; disable se storage bank selection 
4d39			 
4d39 3e ff				ld a, SPI_CE_HIGH		; ce high 
4d3b 32 5c f8				ld (spi_device), a 
4d3e			 
4d3e					; get bank 
4d3e			 
4d3e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4d3e cd 36 1b			call macro_dsp_valuehl 
4d41				endm 
# End of macro FORTH_DSP_VALUEHL
4d41			 
4d41			;		push hl 
4d41			 
4d41					; destroy value TOS 
4d41			 
4d41					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4d41 cd d2 1b			call macro_forth_dsp_pop 
4d44				endm 
# End of macro FORTH_DSP_POP
4d44			 
4d44					; one value on hl get other one back 
4d44			 
4d44			;		pop hl 
4d44			 
4d44					; active low 
4d44			 
4d44 0e ff				ld c, 255 
4d46			 
4d46 7d					ld a, l 
4d47					if DEBUG_FORTH_WORDS 
4d47						DMARK "CDV" 
4d47 f5				push af  
4d48 3a 5c 4d			ld a, (.dmark)  
4d4b 32 77 fb			ld (debug_mark),a  
4d4e 3a 5d 4d			ld a, (.dmark+1)  
4d51 32 78 fb			ld (debug_mark+1),a  
4d54 3a 5e 4d			ld a, (.dmark+2)  
4d57 32 79 fb			ld (debug_mark+2),a  
4d5a 18 03			jr .pastdmark  
4d5c ..			.dmark: db "CDV"  
4d5f f1			.pastdmark: pop af  
4d60			endm  
# End of macro DMARK
4d60						CALLMONITOR 
4d60 cd 01 15			call break_point_state  
4d63				endm  
# End of macro CALLMONITOR
4d63					endif 
4d63 fe 00				cp 0 
4d65 28 30				jr z, .cset 
4d67 fe 01				cp 1 
4d69 20 02				jr nz, .c2 
4d6b cb 81				res 0, c 
4d6d fe 02		.c2:		cp 2 
4d6f 20 02				jr nz, .c3 
4d71 cb 89				res 1, c 
4d73 fe 03		.c3:		cp 3 
4d75 20 02				jr nz, .c4 
4d77 cb 91				res 2, c 
4d79 fe 04		.c4:		cp 4 
4d7b 20 02				jr nz, .c5 
4d7d cb 99				res 3, c 
4d7f fe 05		.c5:		cp 5 
4d81 20 02				jr nz, .c6 
4d83 cb a1				res 4, c 
4d85 fe 06		.c6:		cp 6 
4d87 20 02				jr nz, .c7 
4d89 cb a9				res 5, c 
4d8b fe 07		.c7:		cp 7 
4d8d 20 02				jr nz, .c8 
4d8f cb b1				res 6, c 
4d91 fe 08		.c8:		cp 8 
4d93 20 02				jr nz, .cset 
4d95 cb b9				res 7, c 
4d97 79			.cset:		ld a, c 
4d98 32 5f f8				ld (spi_cartdev),a 
4d9b			 
4d9b					if DEBUG_FORTH_WORDS 
4d9b						DMARK "CD2" 
4d9b f5				push af  
4d9c 3a b0 4d			ld a, (.dmark)  
4d9f 32 77 fb			ld (debug_mark),a  
4da2 3a b1 4d			ld a, (.dmark+1)  
4da5 32 78 fb			ld (debug_mark+1),a  
4da8 3a b2 4d			ld a, (.dmark+2)  
4dab 32 79 fb			ld (debug_mark+2),a  
4dae 18 03			jr .pastdmark  
4db0 ..			.dmark: db "CD2"  
4db3 f1			.pastdmark: pop af  
4db4			endm  
# End of macro DMARK
4db4						CALLMONITOR 
4db4 cd 01 15			call break_point_state  
4db7				endm  
# End of macro CALLMONITOR
4db7					endif 
4db7					NEXTW 
4db7 c3 8c 1c			jp macro_next 
4dba				endm 
# End of macro NEXTW
4dba			endif 
4dba			 
4dba			.ENDDEVICE: 
4dba			; eof 
4dba			 
# End of file forth_words_device.asm
4dba			 
4dba			; var handler 
4dba			 
4dba			 
4dba			.VARS: 
4dba				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4dba 78				db WORD_SYS_CORE+100             
4dbb d2 4d			dw .V0Q            
4dbd 04				db 3 + 1 
4dbe .. 00			db "V0!",0              
4dc2				endm 
# End of macro CWHEAD
4dc2			;| V0! ( u1 -- )  Store value to v0  | DONE 
4dc2			 
4dc2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4dc2 cd 36 1b			call macro_dsp_valuehl 
4dc5				endm 
# End of macro FORTH_DSP_VALUEHL
4dc5			 
4dc5 11 25 f8				ld de, cli_var_array 
4dc8			 
4dc8 eb					ex de, hl 
4dc9 73					ld (hl), e 
4dca 23					inc hl 
4dcb 72					ld (hl), d 
4dcc			 
4dcc					; destroy value TOS 
4dcc			 
4dcc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4dcc cd d2 1b			call macro_forth_dsp_pop 
4dcf				endm 
# End of macro FORTH_DSP_POP
4dcf			 
4dcf				       NEXTW 
4dcf c3 8c 1c			jp macro_next 
4dd2				endm 
# End of macro NEXTW
4dd2			.V0Q: 
4dd2				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4dd2 79				db WORD_SYS_CORE+101             
4dd3 e3 4d			dw .V1S            
4dd5 04				db 3 + 1 
4dd6 .. 00			db "V0@",0              
4dda				endm 
# End of macro CWHEAD
4dda			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4dda 2a 25 f8				ld hl, (cli_var_array) 
4ddd cd 9b 1a				call forth_push_numhl 
4de0			 
4de0				       NEXTW 
4de0 c3 8c 1c			jp macro_next 
4de3				endm 
# End of macro NEXTW
4de3			.V1S: 
4de3				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4de3 7a				db WORD_SYS_CORE+102             
4de4 fb 4d			dw .V1Q            
4de6 04				db 3 + 1 
4de7 .. 00			db "V1!",0              
4deb				endm 
# End of macro CWHEAD
4deb			;| V1! ( u1 -- )  Store value to v1 | DONE 
4deb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4deb cd 36 1b			call macro_dsp_valuehl 
4dee				endm 
# End of macro FORTH_DSP_VALUEHL
4dee			 
4dee 11 27 f8				ld de, cli_var_array+2 
4df1				 
4df1 eb					ex de, hl 
4df2 73					ld (hl), e 
4df3 23					inc hl 
4df4 72					ld (hl), d 
4df5			 
4df5					; destroy value TOS 
4df5			 
4df5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4df5 cd d2 1b			call macro_forth_dsp_pop 
4df8				endm 
# End of macro FORTH_DSP_POP
4df8				       NEXTW 
4df8 c3 8c 1c			jp macro_next 
4dfb				endm 
# End of macro NEXTW
4dfb			.V1Q: 
4dfb				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4dfb 7b				db WORD_SYS_CORE+103             
4dfc 0c 4e			dw .V2S            
4dfe 04				db 3 + 1 
4dff .. 00			db "V1@",0              
4e03				endm 
# End of macro CWHEAD
4e03			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4e03 2a 27 f8				ld hl, (cli_var_array+2) 
4e06 cd 9b 1a				call forth_push_numhl 
4e09				       NEXTW 
4e09 c3 8c 1c			jp macro_next 
4e0c				endm 
# End of macro NEXTW
4e0c			.V2S: 
4e0c				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4e0c 7c				db WORD_SYS_CORE+104             
4e0d 24 4e			dw .V2Q            
4e0f 04				db 3 + 1 
4e10 .. 00			db "V2!",0              
4e14				endm 
# End of macro CWHEAD
4e14			;| V2! ( u1 -- )  Store value to v2 | DONE 
4e14					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e14 cd 36 1b			call macro_dsp_valuehl 
4e17				endm 
# End of macro FORTH_DSP_VALUEHL
4e17			 
4e17 11 29 f8				ld de, cli_var_array+4 
4e1a				 
4e1a eb					ex de, hl 
4e1b 73					ld (hl), e 
4e1c 23					inc hl 
4e1d 72					ld (hl), d 
4e1e			 
4e1e					; destroy value TOS 
4e1e			 
4e1e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e1e cd d2 1b			call macro_forth_dsp_pop 
4e21				endm 
# End of macro FORTH_DSP_POP
4e21				       NEXTW 
4e21 c3 8c 1c			jp macro_next 
4e24				endm 
# End of macro NEXTW
4e24			.V2Q: 
4e24				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4e24 7d				db WORD_SYS_CORE+105             
4e25 35 4e			dw .V3S            
4e27 04				db 3 + 1 
4e28 .. 00			db "V2@",0              
4e2c				endm 
# End of macro CWHEAD
4e2c			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4e2c 2a 29 f8				ld hl, (cli_var_array+4) 
4e2f cd 9b 1a				call forth_push_numhl 
4e32				       NEXTW 
4e32 c3 8c 1c			jp macro_next 
4e35				endm 
# End of macro NEXTW
4e35			.V3S: 
4e35				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4e35 7c				db WORD_SYS_CORE+104             
4e36 4d 4e			dw .V3Q            
4e38 04				db 3 + 1 
4e39 .. 00			db "V3!",0              
4e3d				endm 
# End of macro CWHEAD
4e3d			;| V3! ( u1 -- )  Store value to v3 | DONE 
4e3d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e3d cd 36 1b			call macro_dsp_valuehl 
4e40				endm 
# End of macro FORTH_DSP_VALUEHL
4e40			 
4e40 11 2b f8				ld de, cli_var_array+6 
4e43				 
4e43 eb					ex de, hl 
4e44 73					ld (hl), e 
4e45 23					inc hl 
4e46 72					ld (hl), d 
4e47			 
4e47					; destroy value TOS 
4e47			 
4e47					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e47 cd d2 1b			call macro_forth_dsp_pop 
4e4a				endm 
# End of macro FORTH_DSP_POP
4e4a				       NEXTW 
4e4a c3 8c 1c			jp macro_next 
4e4d				endm 
# End of macro NEXTW
4e4d			.V3Q: 
4e4d				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4e4d 7d				db WORD_SYS_CORE+105             
4e4e 5e 4e			dw .END            
4e50 04				db 3 + 1 
4e51 .. 00			db "V3@",0              
4e55				endm 
# End of macro CWHEAD
4e55			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4e55 2a 2b f8				ld hl, (cli_var_array+6) 
4e58 cd 9b 1a				call forth_push_numhl 
4e5b				       NEXTW 
4e5b c3 8c 1c			jp macro_next 
4e5e				endm 
# End of macro NEXTW
4e5e			 
4e5e			 
4e5e			 
4e5e			 
4e5e			 
4e5e			; end of dict marker 
4e5e			 
4e5e 00			.END:    db WORD_SYS_END 
4e5f 00 00			dw 0 
4e61 00				db 0 
4e62			 
4e62			; use to jp here for user dict words to save on macro expansion  
4e62			 
4e62			user_dict_next: 
4e62				NEXTW 
4e62 c3 8c 1c			jp macro_next 
4e65				endm 
# End of macro NEXTW
4e65			 
4e65			 
4e65			user_exec: 
4e65				;    ld hl, <word code> 
4e65				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4e65				;    call forthexec 
4e65				;    jp user_dict_next   (NEXT) 
4e65			        ;    <word code bytes> 
4e65 eb				ex de, hl 
4e66 2a 33 f1			ld hl,(os_tok_ptr) 
4e69				 
4e69				FORTH_RSP_NEXT 
4e69 cd 42 1a			call macro_forth_rsp_next 
4e6c				endm 
# End of macro FORTH_RSP_NEXT
4e6c			 
4e6c			if DEBUG_FORTH_UWORD 
4e6c						DMARK "UEX" 
4e6c f5				push af  
4e6d 3a 81 4e			ld a, (.dmark)  
4e70 32 77 fb			ld (debug_mark),a  
4e73 3a 82 4e			ld a, (.dmark+1)  
4e76 32 78 fb			ld (debug_mark+1),a  
4e79 3a 83 4e			ld a, (.dmark+2)  
4e7c 32 79 fb			ld (debug_mark+2),a  
4e7f 18 03			jr .pastdmark  
4e81 ..			.dmark: db "UEX"  
4e84 f1			.pastdmark: pop af  
4e85			endm  
# End of macro DMARK
4e85				CALLMONITOR 
4e85 cd 01 15			call break_point_state  
4e88				endm  
# End of macro CALLMONITOR
4e88			endif 
4e88			 
4e88			 
4e88			 
4e88 eb				ex de, hl 
4e89 22 33 f1			ld (os_tok_ptr), hl 
4e8c				 
4e8c				; Don't use next - Skips the first word in uword. 
4e8c			 
4e8c c3 1d 1d			jp exec1 
4e8f			;	NEXT 
4e8f			 
4e8f			 
4e8f			; eof 
# End of file forth_wordsv4.asm
4e8f			endif 
4e8f			;;;;;;;;;;;;;; Debug code 
4e8f			 
4e8f			 
4e8f			;if DEBUG_FORTH_PARSE 
4e8f .. 00		.nowordfound: db "No match",0 
4e98 .. 00		.compword:	db "Comparing word ",0 
4ea8 .. 00		.nextwordat:	db "Next word at",0 
4eb5 .. 00		.charmatch:	db "Char match",0 
4ec0			;endif 
4ec0			if DEBUG_FORTH_JP 
4ec0			.foundword:	db "Word match. Exec..",0 
4ec0			endif 
4ec0			;if DEBUG_FORTH_PUSH 
4ec0 .. 00		.enddict:	db "Dict end. Push.",0 
4ed0 .. 00		.push_str:	db "Pushing string",0 
4edf .. 00		.push_num:	db "Pushing number",0 
4eee .. 00		.data_sp:	db "SP:",0 
4ef2 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4f04 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4f16 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4f28			;endif 
4f28			;if DEBUG_FORTH_MALLOC 
4f28 .. 00		.push_malloc:	db "Malloc address",0 
4f37			;endif 
4f37			 
4f37			 
4f37			 
4f37			; display malloc address and current data stack pointer  
4f37			 
4f37			malloc_error: 
4f37 d5				push de 
4f38 f5				push af 
4f39 e5				push hl 
4f3a cd 8f 0a			call clear_display 
4f3d 11 5f 4f			ld de, .mallocerr 
4f40 3e 00			ld a,0 
4f42			;	ld de,os_word_scratch 
4f42 cd a2 0a			call str_at_display 
4f45 3e 11			ld a, display_row_1+17 
4f47 11 77 fb			ld de, debug_mark 
4f4a cd a2 0a			call str_at_display 
4f4d cd b2 0a			call update_display 
4f50				;call break_point_state 
4f50 cd 30 65			call cin_wait 
4f53			 
4f53 3e 20			ld a, ' ' 
4f55 32 31 ee			ld (os_view_disable), a 
4f58 e1				pop hl 
4f59 f1				pop af 
4f5a d1				pop de	 
4f5b				CALLMONITOR 
4f5b cd 01 15			call break_point_state  
4f5e				endm  
# End of macro CALLMONITOR
4f5e c9				ret 
4f5f			 
4f5f .. 00		.mallocerr: 	db "Malloc Error",0 
4f6c			;if DEBUG_FORTH_PUSH 
4f6c			display_data_sp: 
4f6c f5				push af 
4f6d			 
4f6d				; see if disabled 
4f6d			 
4f6d 3a 31 ee			ld a, (os_view_disable) 
4f70 fe 2a			cp '*' 
4f72 28 67			jr z, .skipdsp 
4f74			 
4f74 e5				push hl 
4f75 e5				push hl 
4f76 e5			push hl 
4f77 cd 8f 0a			call clear_display 
4f7a e1			pop hl 
4f7b 7c				ld a,h 
4f7c 21 37 f1			ld hl, os_word_scratch 
4f7f cd c0 0f			call hexout 
4f82 e1				pop hl 
4f83 7d				ld a,l 
4f84 21 39 f1			ld hl, os_word_scratch+2 
4f87 cd c0 0f			call hexout 
4f8a 21 3b f1			ld hl, os_word_scratch+4 
4f8d 3e 00			ld a,0 
4f8f 77				ld (hl),a 
4f90 11 37 f1			ld de,os_word_scratch 
4f93 3e 28				ld a, display_row_2 
4f95 cd a2 0a				call str_at_display 
4f98 11 f2 4e			ld de, .wordinhl 
4f9b 3e 00			ld a, display_row_1 
4f9d			 
4f9d cd a2 0a				call str_at_display 
4fa0 11 77 fb			ld de, debug_mark 
4fa3 3e 11			ld a, display_row_1+17 
4fa5			 
4fa5 cd a2 0a				call str_at_display 
4fa8			 
4fa8				; display current data stack pointer 
4fa8 11 ee 4e			ld de,.data_sp 
4fab 3e 30				ld a, display_row_2 + 8 
4fad cd a2 0a				call str_at_display 
4fb0			 
4fb0 2a 1f f8			ld hl,(cli_data_sp) 
4fb3 e5				push hl 
4fb4 7c				ld a,h 
4fb5 21 37 f1			ld hl, os_word_scratch 
4fb8 cd c0 0f			call hexout 
4fbb e1				pop hl 
4fbc 7d				ld a,l 
4fbd 21 39 f1			ld hl, os_word_scratch+2 
4fc0 cd c0 0f			call hexout 
4fc3 21 3b f1			ld hl, os_word_scratch+4 
4fc6 3e 00			ld a,0 
4fc8 77				ld (hl),a 
4fc9 11 37 f1			ld de,os_word_scratch 
4fcc 3e 33				ld a, display_row_2 + 11 
4fce cd a2 0a				call str_at_display 
4fd1			 
4fd1			 
4fd1 cd b2 0a			call update_display 
4fd4 cd 3d 0a			call delay1s 
4fd7 cd 3d 0a			call delay1s 
4fda e1				pop hl 
4fdb			.skipdsp: 
4fdb f1				pop af 
4fdc c9				ret 
4fdd			 
4fdd			display_data_malloc: 
4fdd			 
4fdd f5				push af 
4fde e5				push hl 
4fdf e5				push hl 
4fe0 e5			push hl 
4fe1 cd 8f 0a			call clear_display 
4fe4 e1			pop hl 
4fe5 7c				ld a,h 
4fe6 21 37 f1			ld hl, os_word_scratch 
4fe9 cd c0 0f			call hexout 
4fec e1				pop hl 
4fed 7d				ld a,l 
4fee 21 39 f1			ld hl, os_word_scratch+2 
4ff1 cd c0 0f			call hexout 
4ff4 21 3b f1			ld hl, os_word_scratch+4 
4ff7 3e 00			ld a,0 
4ff9 77				ld (hl),a 
4ffa 11 37 f1			ld de,os_word_scratch 
4ffd 3e 28				ld a, display_row_2 
4fff cd a2 0a				call str_at_display 
5002 11 28 4f			ld de, .push_malloc 
5005 3e 00			ld a, display_row_1 
5007			 
5007 cd a2 0a				call str_at_display 
500a			 
500a				; display current data stack pointer 
500a 11 ee 4e			ld de,.data_sp 
500d 3e 30				ld a, display_row_2 + 8 
500f cd a2 0a				call str_at_display 
5012			 
5012 2a 1f f8			ld hl,(cli_data_sp) 
5015 e5				push hl 
5016 7c				ld a,h 
5017 21 37 f1			ld hl, os_word_scratch 
501a cd c0 0f			call hexout 
501d e1				pop hl 
501e 7d				ld a,l 
501f 21 39 f1			ld hl, os_word_scratch+2 
5022 cd c0 0f			call hexout 
5025 21 3b f1			ld hl, os_word_scratch+4 
5028 3e 00			ld a,0 
502a 77				ld (hl),a 
502b 11 37 f1			ld de,os_word_scratch 
502e 3e 33				ld a, display_row_2 + 11 
5030 cd a2 0a				call str_at_display 
5033			 
5033 cd b2 0a			call update_display 
5036 cd 3d 0a			call delay1s 
5039 cd 3d 0a			call delay1s 
503c e1				pop hl 
503d f1				pop af 
503e c9				ret 
503f			;endif 
503f			 
503f			include "forth_autostart.asm" 
503f			; list of commands to perform at system start up 
503f			 
503f			startcmds: 
503f			;	dw test11 
503f			;	dw test12 
503f			;	dw test13 
503f			;	dw test14 
503f			;	dw test15 
503f			;	dw test16 
503f			;	dw test17 
503f			;	dw ifthtest1 
503f			;	dw ifthtest2 
503f			;	dw ifthtest3 
503f			;	dw mmtest1 
503f			;	dw mmtest2 
503f			;	dw mmtest3 
503f			;	dw mmtest4 
503f			;	dw mmtest5 
503f			;	dw mmtest6 
503f			;	dw iftest1 
503f			;	dw iftest2 
503f			;	dw iftest3 
503f			;	dw looptest1 
503f			;	dw looptest2 
503f			;	dw test1 
503f			;	dw test2 
503f			;	dw test3 
503f			;	dw test4 
503f			;	dw game2r 
503f			;	dw game2b1 
503f			;	dw game2b2 
503f			 
503f				; start up words that are actually useful 
503f			 
503f 9d 50			dw clrstack 
5041 d0 50			dw type 
5043 91 52			dw stest 
5045 f4 50			dw strncpy 
5047 32 52			dw list 
5049 55 51			dw start1 
504b 67 51			dw start2 
504d			;	dw start3 
504d 7a 51			dw start3b 
504f d2 51			dw start3c 
5051			 
5051				; (unit) testing words 
5051			 
5051 08 53			dw mtesta 
5053 bd 53			dw mtestb 
5055 60 54			dw mtestc 
5057 15 55			dw mtestd 
5059 b9 55			dw mteste 
505b			 
505b				; demo/game words 
505b			 
505b c5 5c		        dw game3w 
505d f3 5c		        dw game3p 
505f 11 5d		        dw game3sc 
5061 42 5d		        dw game3vsi 
5063 6e 5d		        dw game3vs 
5065				 
5065 b8 5a			dw game2b 
5067 26 5b			dw game2bf 
5069 70 5b			dw game2mba 
506b 06 5c			dw game2mbas 
506d 48 5c			dw game2mb 
506f			 
506f 79 57			dw game1 
5071 8a 57			dw game1a 
5073 ec 57			dw game1b 
5075 21 58			dw game1c 
5077 57 58			dw game1d 
5079 88 58			dw game1s 
507b 9c 58			dw game1t 
507d b1 58			dw game1f 
507f e5 58			dw game1z 
5081 29 59			dw game1zz 
5083			 
5083 6f 56			dw test5 
5085 a7 56			dw test6 
5087 df 56			dw test7 
5089 f3 56			dw test8 
508b 1f 57			dw test9 
508d 35 57			dw test10 
508f				 
508f 00 5a		        dw ssv5 
5091 e4 59		        dw ssv4 
5093 c8 59		        dw ssv3 
5095 92 59		        dw ssv2 
5097 19 5a		        dw ssv1 
5099 61 5a		        dw ssv1cpm 
509b			;	dw keyup 
509b			;	dw keydown 
509b			;	dw keyleft 
509b			;	dw keyright 
509b			;	dw 	keyf1 
509b			;	dw keyf2 
509b			;	dw keyf3 
509b			;	dw keyf4 
509b			;	dw keyf5 
509b			;	dw keyf6 
509b			;	dw keyf7 
509b			;	dw keyf8 
509b			;	dw keyf9 
509b			;	dw keyf10 
509b			;	dw keyf11 
509b			;	dw keyf12 
509b			;	dw keytab 
509b			;	dw keycr 
509b			;	dw keyhome 
509b			;	dw keyend 
509b			;	dw keybs 
509b 00 00			db 0, 0	 
509d			 
509d			 
509d			; clear stack  
509d			 
509d .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
50d0			 
50d0			; type ( addr count - ) 
50d0 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
50f4			 
50f4			; some direct memory words 
50f4			; strncpy ( len t f -- t ) 
50f4			 
50f4 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5155			 
5155 .. 00		start1:     	db ": bpon $0000 bp ;",0 
5167 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
517a			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
517a .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
51d2 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5232			 
5232			 
5232			; a handy word to list items on the stack 
5232			 
5232 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
5291			 
5291			 
5291			; test stack  
5291			; rnd8 stest 
5291			 
5291 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5308			 
5308			; random malloc and free cycles 
5308			 
5308 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
53bd			 
53bd			; fixed malloc and free cycles 
53bd			 
53bd .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5460			 
5460			; fixed double string push and drop cycle  
5460			 
5460 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5515			 
5515			; consistent fixed string push and drop cycle  
5515			 
5515 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
55b9			 
55b9 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
566f			 
566f			;test1:		db ": aa 1 2 3 ;", 0 
566f			;test2:     	db "111 aa 888 999",0 
566f			;test3:     	db ": bb 77 ;",0 
566f			;test4:     	db "$02 $01 do i . loop bb",0 
566f			 
566f .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
56a7 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
56df .. 00		test7:     	db ": box hline vline ;",0 
56f3 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
571f .. 00		test9:     	db ": sw $01 adsp world ;",0 
5735 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
575a .. 00		test11:     	db "hello create .",0 
5769 .. 00		test12:     	db "hello2 create .",0 
5779			 
5779			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5779			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5779			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5779			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5779			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5779			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5779			 
5779			;iftest1:     	db "$0001 IF cls .",0 
5779			;iftest2:     	db "$0000 IF cls .",0 
5779			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5779			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5779			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5779			 
5779			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5779			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5779			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5779			 
5779			 
5779			 
5779			; a small guess the number game 
5779			 
5779 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
578a .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
57ec			 
57ec .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5821 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5857 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5888 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
589c .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
58b1 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
58e5 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5929			 
5929			; Using 'ga' save a high score across multiple runs using external storage 
5929			 
5929 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5992			 
5992			 
5992			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5992			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5992			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5992			 
5992			; simple screen saver to test code memory reuse to destruction 
5992			 
5992 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
59c8 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
59e4 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5a00 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5a19 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5a61 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5ab8			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5ab8			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5ab8			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5ab8			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5ab8			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5ab8			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5ab8			 
5ab8			 
5ab8			 
5ab8			; minesweeper/battleship finding game 
5ab8			; draws a game board of random ship/mine positions 
5ab8			; user enters coords to see if it hits on 
5ab8			; game ends when all are hit 
5ab8			; when hit or miss says how many may be in the area 
5ab8			 
5ab8			; setup the game board and then hide it 
5ab8 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5b26 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5b70			; prompt for where to target 
5b70 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5c06 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5c2b			; TODO see if the entered coords hits or misses pushes char hit of miss 
5c2b .. 00		game2mbht:      db ": mbckht nop ;",0 
5c3a .. 00		game2mbms:      db ": mbcms nop ;",0 
5c48			; TODO how many might be near by 
5c48 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5cc5			 
5cc5			; Game 3 
5cc5			 
5cc5			; Vert scroller ski game - avoid the trees! 
5cc5			 
5cc5			; v0 score (ie turns) 
5cc5			; v1 player pos 
5cc5			; v2 left wall 
5cc5			; v3 right wall 
5cc5			 
5cc5			; Draw side walls randomly 
5cc5			 
5cc5 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5cf3			 
5cf3			; Draw player 
5cf3 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5d11			 
5d11			; TODO Get Key 
5d11			 
5d11			; TODO Move left right 
5d11			 
5d11			; scroll and move walls a bit 
5d11			 
5d11 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5d42			 
5d42			; main game loop 
5d42			 
5d42 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5d6e .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5dad			 
5dad			; key board defs 
5dad			 
5dad .. 00		keyup:       db ": keyup $05 ;",0 
5dbb .. 00		keydown:       db ": keydown $0a ;",0 
5dcb .. 00		keyleft:       db ": keyleft $0b ;",0 
5ddb .. 00		keyright:       db ": keyright $0c ;",0 
5dec .. 00		keyf1:       db ": keyf1 $10 ;",0 
5dfa .. 00		keyf2:       db ": keyf2 $11 ;",0 
5e08 .. 00		keyf3:       db ": keyf3 $12 ;",0 
5e16 .. 00		keyf4:       db ": keyf4 $13 ;",0 
5e24 .. 00		keyf5:       db ": keyf5 $14 ;",0 
5e32 .. 00		keyf6:       db ": keyf6 $15 ;",0 
5e40 .. 00		keyf7:       db ": keyf7 $16 ;",0 
5e4e .. 00		keyf8:       db ": keyf8 $17 ;",0 
5e5c .. 00		keyf9:       db ": keyf9 $18 ;",0 
5e6a .. 00		keyf10:       db ": keyf10 $19 ;",0 
5e79 .. 00		keyf11:       db ": keyf11 $1a ;",0 
5e88 .. 00		keyf12:       db ": keyf12 $1b ;",0 
5e97			 
5e97 .. 00		keytab:       db ": keytab $09 ;",0 
5ea6 .. 00		keycr:       db ": keycr $0d ;",0 
5eb4 .. 00		keyhome:       db ": keyhome $0e ;",0 
5ec4 .. 00		keyend:       db ": keyend $0f ;",0 
5ed3 .. 00		keybs:       db ": keybs $08 ;",0 
5ee1			 
5ee1			   
5ee1			 
5ee1			 
5ee1			 
5ee1			; eof 
# End of file forth_autostart.asm
5ee1			 
5ee1 .. 00		sprompt1: db "Startup load...",0 
5ef1 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5f07			 
5f07			forth_startup: 
5f07 21 3f 50			ld hl, startcmds 
5f0a 3e 00			ld a, 0 
5f0c 32 58 f2			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
5f0f			 
5f0f e5			.start1:	push hl 
5f10 cd 8f 0a			call clear_display 
5f13 11 e1 5e			ld de, sprompt1 
5f16 3e 00		        ld a, display_row_1 
5f18 cd a2 0a			call str_at_display 
5f1b 11 f1 5e			ld de, sprompt2 
5f1e 3e 28		        ld a, display_row_2 
5f20 cd a2 0a			call str_at_display 
5f23 e1				pop hl 
5f24 e5				push hl 
5f25 5e				ld e,(hl) 
5f26 23				inc hl 
5f27 56				ld d,(hl) 
5f28 3e 50		        ld a, display_row_3 
5f2a cd a2 0a			call str_at_display 
5f2d cd b2 0a			call update_display 
5f30			 
5f30			 
5f30 3a 58 f2			ld a, (os_last_cmd) 
5f33 fe 00			cp 0 
5f35 28 05			jr z, .startprompt 
5f37 cd 31 0a			call delay250ms 
5f3a 18 24			jr .startdo 
5f3c				 
5f3c				 
5f3c			 
5f3c			.startprompt: 
5f3c			 
5f3c 3e 9f			ld a,display_row_4 + display_cols - 1 
5f3e 11 11 1a		        ld de, endprg 
5f41 cd a2 0a			call str_at_display 
5f44 cd b2 0a			call update_display 
5f47 cd 3d 0a			call delay1s 
5f4a cd 30 65			call cin_wait 
5f4d						 
5f4d fe 2a			cp '*' 
5f4f 28 5e			jr z, .startupend1 
5f51 fe 23			cp '#' 
5f53 20 07			jr nz, .startno 
5f55 3e 01			ld a, 1 
5f57 32 58 f2			ld (os_last_cmd),a 
5f5a 18 04			jr .startdo 
5f5c fe 31		.startno:	cp '1' 
5f5e 28 3a			jr z,.startnxt  
5f60			 
5f60				; exec startup line 
5f60			.startdo:	 
5f60 e1				pop hl 
5f61 e5				push hl 
5f62				 
5f62 5e				ld e,(hl) 
5f63 23				inc hl 
5f64 56				ld d,(hl) 
5f65 eb				ex de,hl 
5f66			 
5f66 e5				push hl 
5f67			 
5f67 3e 00			ld a, 0 
5f69				;ld a, FORTH_END_BUFFER 
5f69 cd 28 11			call strlent 
5f6c 23				inc hl   ; include zero term to copy 
5f6d 06 00			ld b,0 
5f6f 4d				ld c,l 
5f70 e1				pop hl 
5f71 11 32 ee			ld de, scratch 
5f74 ed b0			ldir 
5f76			 
5f76			 
5f76 21 32 ee			ld hl, scratch 
5f79 cd da 1c			call forthparse 
5f7c cd 1a 1d			call forthexec 
5f7f cd 31 1c			call forthexec_cleanup 
5f82			 
5f82 3e 78			ld a, display_row_4 
5f84 11 b5 17			ld de, endprog 
5f87			 
5f87 cd b2 0a			call update_display		 
5f8a			 
5f8a 3a 58 f2			ld a, (os_last_cmd) 
5f8d fe 00			cp 0 
5f8f 20 09			jr nz, .startnxt 
5f91 cd 13 1a			call next_page_prompt 
5f94 cd 8f 0a		        call clear_display 
5f97 cd b2 0a			call update_display		 
5f9a			 
5f9a				; move onto next startup line? 
5f9a			.startnxt: 
5f9a			 
5f9a cd 31 0a			call delay250ms 
5f9d e1				pop hl 
5f9e			 
5f9e 23				inc hl 
5f9f 23				inc hl 
5fa0			 
5fa0 e5				push hl 
5fa1 5e				ld e, (hl) 
5fa2 23				inc hl 
5fa3 56				ld d, (hl) 
5fa4 e1				pop hl 
5fa5				; TODO replace 0 test 
5fa5			 
5fa5 eb				ex de, hl 
5fa6 cd e8 0c			call ishlzero 
5fa9			;	ld a,e 
5fa9			;	add d 
5fa9			;	cp 0    ; any left to do? 
5fa9 eb				ex de, hl 
5faa c2 0f 5f			jp nz, .start1 
5fad 18 01			jr .startupend 
5faf			 
5faf e1			.startupend1: pop hl 
5fb0			.startupend: 
5fb0			 
5fb0 cd 8f 0a			call clear_display 
5fb3 cd b2 0a			call update_display 
5fb6 c9				ret 
5fb7			 
5fb7			 
5fb7			; stack over and underflow checks 
5fb7			 
5fb7			; init the words to detect the under/overflow 
5fb7			 
5fb7			chk_stk_init: 
5fb7				; a vague random number to check so we dont get any "lucky" hits 
5fb7 3e 2d			ld a, 45 
5fb9 6f				ld l, a 
5fba 00				nop 
5fbb 3e 17			ld a, 23 
5fbd 67				ld h, a 
5fbe			 
5fbe 22 27 ee			ld (chk_word), hl     ; the word we need to check against 
5fc1			 
5fc1			;	ld (chk_stund), hl	; stack points.... 
5fc1 22 fd fb			ld (chk_stovr), hl 
5fc4 22 1d f8			ld (chk_ret_und), hl 
5fc7 22 9b f7			ld (chk_ret_ovr), hl 
5fca 22 99 f5			ld (chk_loop_ovr), hl 
5fcd 22 97 f3			ld (chk_data_ovr), hl 
5fd0 c9				ret 
5fd1				 
5fd1			check_stacks: 
5fd1				; check all stack words 
5fd1			 
5fd1 e5				push hl 
5fd2 d5				push de 
5fd3			 
5fd3			;	ld de,(chk_word) 
5fd3			;	ld hl, (chk_stund)	; stack points.... 
5fd3			;	if DEBUG_STK_FAULT 
5fd3			;		DMARK "FAa" 
5fd3			;		CALLMONITOR 
5fd3			;	endif 
5fd3			;	call cmp16 
5fd3			;	jp z, .chk_faulta 
5fd3			; 
5fd3			;	ld de, sfaultsu 
5fd3			;	jp .chk_fault 
5fd3			 
5fd3 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
5fd6 ed 5b 27 ee		ld de,(chk_word) 
5fda				if DEBUG_STK_FAULT 
5fda					DMARK "FAb" 
5fda					CALLMONITOR 
5fda				endif 
5fda cd dd 0c			call cmp16 
5fdd 28 06			jr z, .chk_fault1 
5fdf 11 80 60			ld de, sfaultso 
5fe2 c3 34 60			jp .chk_fault 
5fe5			.chk_fault1:  
5fe5 2a 1d f8			ld hl, (chk_ret_und) 
5fe8 ed 5b 27 ee		ld de,(chk_word) 
5fec				if DEBUG_STK_FAULT 
5fec					DMARK "FAU" 
5fec					CALLMONITOR 
5fec				endif 
5fec cd dd 0c			call cmp16 
5fef ca f8 5f			jp z, .chk_fault2 
5ff2 11 90 60			ld de, sfaultru 
5ff5 c3 34 60			jp .chk_fault 
5ff8			.chk_fault2:  
5ff8 2a 9b f7			ld hl, (chk_ret_ovr) 
5ffb ed 5b 27 ee		ld de,(chk_word) 
5fff				if DEBUG_STK_FAULT 
5fff					DMARK "FA1" 
5fff					CALLMONITOR 
5fff				endif 
5fff cd dd 0c			call cmp16 
6002 ca 0b 60			jp z, .chk_fault3 
6005 11 9e 60			ld de, sfaultro 
6008 c3 34 60			jp .chk_fault 
600b			.chk_fault3:  
600b 2a 99 f5			ld hl, (chk_loop_ovr) 
600e ed 5b 27 ee		ld de,(chk_word) 
6012				if DEBUG_STK_FAULT 
6012					DMARK "FA2" 
6012					CALLMONITOR 
6012				endif 
6012 cd dd 0c			call cmp16 
6015 ca 1e 60			jp z, .chk_fault4 
6018 11 b8 60			ld de, sfaultlo 
601b c3 34 60			jp .chk_fault 
601e			.chk_fault4:  
601e 2a 97 f3			ld hl, (chk_data_ovr) 
6021 ed 5b 27 ee		ld de,(chk_word) 
6025				if DEBUG_STK_FAULT 
6025					DMARK "FA3" 
6025					CALLMONITOR 
6025				endif 
6025 cd dd 0c			call cmp16 
6028 ca 31 60			jp z, .chk_fault5 
602b 11 d2 60			ld de, sfaultdo 
602e c3 34 60			jp .chk_fault 
6031			 
6031			 
6031			.chk_fault5:  
6031 d1				pop de 
6032 e1				pop hl 
6033			 
6033 c9				ret 
6034			 
6034 cd 8f 0a		.chk_fault: 	call clear_display 
6037 3e 28				ld a, display_row_2 
6039 cd a2 0a				call str_at_display 
603c 11 62 60				   ld de, .stackfault 
603f 3e 00				ld a, display_row_1 
6041 cd a2 0a				call str_at_display 
6044 11 77 fb				    ld de, debug_mark 
6047 3e 11				ld a, display_row_1+17 
6049 cd a2 0a				call str_at_display 
604c cd b2 0a				call update_display 
604f			 
604f				; prompt before entering montior for investigating issue 
604f			 
604f 3e 78			ld a, display_row_4 
6051 11 b5 17			ld de, endprog 
6054			 
6054 cd b2 0a			call update_display		 
6057			 
6057 cd 13 1a			call next_page_prompt 
605a			 
605a d1				pop de 
605b e1				pop hl 
605c cd 09 18				call monitor 
605f c3 f6 16				jp warmstart 
6062					;jp 0 
6062					;halt 
6062			 
6062			 
6062			 
6062 .. 00		.stackfault: 	db "Stack fault:",0 
606f			 
606f .. 00		sfaultsu: 	db	"Stack under flow",0 
6080 .. 00		sfaultso: 	db	"Stack over flow",0 
6090 .. 00		sfaultru:	db "RTS underflow",0 
609e .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
60b8 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
60d2 .. 00		sfaultdo:	db "DTS overflow", 0 
60df			 
60df			 
60df			fault_dsp_under: 
60df 11 f1 60			ld de, .dsp_under 
60e2 c3 a1 61			jp .show_fault 
60e5			 
60e5			fault_rsp_under: 
60e5 11 ff 60			ld de, .rsp_under 
60e8 c3 a1 61			jp .show_fault 
60eb			fault_loop_under: 
60eb 11 0d 61			ld de, .loop_under 
60ee c3 a1 61			jp .show_fault 
60f1			 
60f1 .. 00		.dsp_under: db "DSP Underflow",0 
60ff .. 00		.rsp_under: db "RSP Underflow",0 
610d .. 00		.loop_under: db "LOOP Underflow",0 
611c			 
611c			 
611c d5			type_faultn: 	push de 
611d e5					push hl 
611e cd 8f 0a				call clear_display 
6121 11 48 61				   ld de, .typefaultn 
6124 3e 00				ld a, display_row_1 
6126 cd a2 0a				call str_at_display 
6129 11 77 fb				    ld de, debug_mark 
612c 3e 11				ld a, display_row_1+17 
612e cd a2 0a				call str_at_display 
6131 cd b2 0a				call update_display 
6134			 
6134				; prompt before entering montior for investigating issue 
6134			 
6134 3e 78			ld a, display_row_4 
6136 11 b5 17			ld de, endprog 
6139			 
6139 cd b2 0a			call update_display		 
613c			 
613c cd 13 1a			call next_page_prompt 
613f			 
613f e5					push hl 
6140 d5					push de 
6141 cd 09 18				call monitor 
6144 c3 f6 16				jp warmstart 
6147 76					halt 
6148			 
6148			 
6148 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
615f			 
615f d5			type_faults: 	push de 
6160 e5					push hl 
6161 cd 8f 0a				call clear_display 
6164 11 8a 61				   ld de, .typefaults 
6167 3e 00				ld a, display_row_1 
6169 cd a2 0a				call str_at_display 
616c 11 77 fb				    ld de, debug_mark 
616f 3e 11				ld a, display_row_1+17 
6171 cd a2 0a				call str_at_display 
6174 cd b2 0a				call update_display 
6177			 
6177				; prompt before entering montior for investigating issue 
6177			 
6177 3e 78			ld a, display_row_4 
6179 11 b5 17			ld de, endprog 
617c			 
617c cd b2 0a			call update_display		 
617f			 
617f cd 13 1a			call next_page_prompt 
6182			 
6182 e1					pop hl 
6183 d1					pop de 
6184 cd 09 18				call monitor 
6187 c3 f6 16				jp warmstart 
618a			 
618a			 
618a .. 00		.typefaults: db "STR Type Expected TOS!",0 
61a1			 
61a1			.show_fault: 	 
61a1 d5					push de 
61a2 cd 8f 0a				call clear_display 
61a5 d1					pop de 
61a6 3e 00				ld a, display_row_1 
61a8 cd a2 0a				call str_at_display 
61ab 11 77 fb				    ld de, debug_mark 
61ae 3e 11				ld a, display_row_1+17 
61b0 cd a2 0a				call str_at_display 
61b3 cd b2 0a				call update_display 
61b6			 
61b6				; prompt before entering montior for investigating issue 
61b6			 
61b6 3e 78			ld a, display_row_4 
61b8 11 b5 17			ld de, endprog 
61bb			 
61bb cd b2 0a			call update_display		 
61be			 
61be cd 13 1a			call next_page_prompt 
61c1			 
61c1 e1					pop hl 
61c2 d1					pop de 
61c3 cd 09 18				call monitor 
61c6			; do a dump to cli and not warmstart so we preserve all of the uwords.  
61c6			; TODO Make optional fault restart to cli or warm boot? 
61c6					;jp warmstart 
61c6 c3 4e 17				jp cli 
61c9 76					halt 
61ca			; eof 
# End of file forth_kernel.asm
61ca			;include "nascombasic.asm" 
61ca			 
61ca			 
61ca			; find out where the code ends if loaded into RAM (for SC114) 
61ca			;endofcode:  
61ca			;	nop 
61ca			 
61ca			 
61ca			; eof 
61ca			 
# End of file main.asm
61ca			include "firmware_lcd_4x40.asm" 
61ca			; **********************************************************************  
61ca			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
61ca			; **********************************************************************  
61ca			;  
61ca			; **  Written as a Small Computer Monitor App  
61ca			; **  www.scc.me.uk  
61ca			;  
61ca			; History  
61ca			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
61ca			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
61ca			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
61ca			;  
61ca			; **********************************************************************  
61ca			;  
61ca			; This program is an example of one of the methods of interfacing an   
61ca			; alphanumeric LCD module.   
61ca			;  
61ca			; In this example the display is connected to either a Z80 PIO or a   
61ca			; simple 8-bit output port.   
61ca			;  
61ca			; This interfacing method uses 4-bit data mode and uses time delays  
61ca			; rather than polling the display's ready status. As a result the   
61ca			; interface only requires 6 simple output lines:  
61ca			;   Output bit 0 = not used  
61ca			;   Output bit 1 = not used  
61ca			;   Output bit 2 = RS         High = data, Low = instruction  
61ca			;   Output bit 3 = E          Active high  
61ca			;   Output bit 4 = DB4  
61ca			;   Output bit 5 = DB5  
61ca			;   Output bit 6 = DB6  
61ca			;   Output bit 7 = DB7  
61ca			; Display's R/W is connected to 0v so it is always in write mode  
61ca			;  
61ca			; This set up should work with any system supporting the RC2014 bus  
61ca			  
61ca			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
61ca			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
61ca			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
61ca			;  
61ca			; **********************************************************************  
61ca			  
61ca			; Additonal for 4x40. E1 and E2 instead of just E   
61ca			; TODO swipe vidout signal on port a to activate E2  
61ca			  
61ca			; **********************************************************************  
61ca			; **  Constants  
61ca			; **********************************************************************  
61ca			; LCD constants required by LCD support module  
61ca			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
61ca			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
61ca			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
61ca			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
61ca			; TODO Decide which E is being set  
61ca			kLCDWidth:  EQU display_cols             ;Width in characters  
61ca			  
61ca			; **********************************************************************  
61ca			; **  Code library usage  
61ca			; **********************************************************************  
61ca			  
61ca			; send character to current cursor position  
61ca			; wraps and/or scrolls screen automatically  
61ca			  
61ca			  
61ca			  
61ca			lcd_init:  
61ca			  
61ca			; SCMonAPI functions used  
61ca			  
61ca			; Alphanumeric LCD functions used  
61ca			; no need to specify specific functions for this module  
61ca			  
61ca 3e cf		            LD   A, 11001111b  
61cc d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
61ce 3e 00		            LD   A, 00000000b  
61d0 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
61d2			  
61d2			; Initialise alphanumeric LCD module  
61d2 3e 00				ld a, 0  
61d4 32 d7 f8				ld (display_lcde1e2), a  
61d7 cd 58 62		            CALL fLCD_Init      ;Initialise LCD module  
61da 3e 01				ld a, 1  
61dc 32 d7 f8				ld (display_lcde1e2), a  
61df cd 58 62		            CALL fLCD_Init      ;Initialise LCD module  
61e2			  
61e2 c9				ret  
61e3			  
61e3			;  
61e3			;;  
61e3			; lcd functions  
61e3			;  
61e3			;  
61e3			  
61e3			; what is at cursor position   
61e3			  
61e3			;get_cursor:	ld de, (cursor_row)   ;  row + col  
61e3			;		call curptr  
61e3			;		ret  
61e3			  
61e3			  
61e3			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
61e3			  
61e3			curptr:  
61e3 c5				push bc  
61e4 21 bd fa			ld hl, display_fb0  
61e7			cpr:	  
61e7				; loop for cursor whole row  
61e7 0e 28			ld c, display_cols  
61e9 23			cpr1:	inc hl  
61ea 0d				dec c  
61eb 20 fc			jr nz, cpr1  
61ed 05				dec b  
61ee 20 f7			jr nz, cpr  
61f0			  
61f0				; add col	  
61f0			  
61f0 23			cpr2:	inc hl  
61f1 1d				dec e  
61f2 20 fc			jr nz, cpr2  
61f4			  
61f4 c1				pop bc  
61f5 c9				ret  
61f6				  
61f6			  
61f6			  
61f6			  
61f6			  
61f6			; write the frame buffer given in hl to hardware   
61f6 22 d5 f8		write_display: ld (display_write_tmp), hl 	   
61f9 3e 00			ld a, kLCD_Line1  
61fb cd 05 63		            CALL fLCD_Pos       ;Position cursor to location in A  
61fe 06 28			ld b, display_cols  
6200 ed 5b d5 f8		ld de, (display_write_tmp)  
6204 cd 50 62			call write_len_string  
6207				  
6207				  
6207 2a d5 f8			ld hl, (display_write_tmp)  
620a 11 28 00			ld de, display_cols  
620d 19				add hl,de  
620e 22 d5 f8			ld (display_write_tmp),hl  
6211			  
6211				  
6211 3e 28			ld a, kLCD_Line2  
6213 cd 05 63		            CALL fLCD_Pos       ;Position cursor to location in A  
6216 06 28			ld b, display_cols  
6218 ed 5b d5 f8		ld de, (display_write_tmp)  
621c cd 50 62			call write_len_string  
621f				  
621f 2a d5 f8			ld hl, (display_write_tmp)  
6222 11 28 00			ld de, display_cols  
6225 19				add hl,de  
6226 22 d5 f8			ld (display_write_tmp),hl  
6229			  
6229				  
6229 3e 50			ld a, kLCD_Line3  
622b cd 05 63		            CALL fLCD_Pos       ;Position cursor to location in A  
622e 06 28			ld b, display_cols  
6230 ed 5b d5 f8		ld de, (display_write_tmp)  
6234 cd 50 62			call write_len_string  
6237				  
6237 2a d5 f8			ld hl, (display_write_tmp)  
623a 11 28 00			ld de, display_cols  
623d 19				add hl,de  
623e 22 d5 f8			ld (display_write_tmp),hl  
6241			  
6241				  
6241 3e 78			ld a, kLCD_Line4  
6243 cd 05 63		            CALL fLCD_Pos       ;Position cursor to location in A  
6246 06 28			ld b, display_cols  
6248 ed 5b d5 f8		ld de, (display_write_tmp)  
624c cd 50 62			call write_len_string  
624f c9					ret  
6250				  
6250				; write out a fixed length string given in b from de  
6250			  
6250 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6251 cd bd 62		            CALL fLCD_Data      ;Write character to display  
6254 13				inc de  
6255 10 f9			djnz write_len_string  
6257 c9				ret  
6258			  
6258			; Some other things to do  
6258			;            LD   A, kLCD_Clear ;Display clear  
6258			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6258			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6258			;            LD   A, kLCD_On     ;Display on with no cursor  
6258			;            ;LD   A, kLCD_Off   ;Display off  
6258			;            CALL fLCD_Inst      ;Send instruction to display  
6258			;  
6258			;  
6258			;            halt  
6258			;  
6258			;  
6258			;MsgHello:   DB  "Hello World!",0  
6258			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6258			  
6258			; Custom characters 5 pixels wide by 8 pixels high  
6258			; Up to 8 custom characters can be defined  
6258			;BitMaps:      
6258			;; Character 0x00 = Battery icon  
6258			;            DB  01110b  
6258			;            DB  11011b  
6258			;            DB  10001b  
6258			;            DB  10001b  
6258			;            DB  11111b  
6258			;            DB  11111b  
6258			;            DB  11111b  
6258			;            DB  11111b  
6258			;; Character 0x01 = Bluetooth icon  
6258			;            DB  01100b  
6258			;            DB  01010b  
6258			;            DB  11100b  
6258			;            DB  01000b  
6258			;            DB  11100b  
6258			;            DB  01010b  
6258			;            DB  01100b  
6258			;            DB  00000b  
6258			;  
6258			  
6258			  
6258			; **********************************************************************  
6258			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6258			; **********************************************************************  
6258			;  
6258			; **  Written as a Small Computer Monitor App   
6258			; **  Version 0.1 SCC 2018-05-16  
6258			; **  www.scc.me.uk  
6258			;  
6258			; **********************************************************************  
6258			;  
6258			; This module provides support for alphanumeric LCD modules using with  
6258			; *  HD44780 (or compatible) controller  
6258			; *  5 x 7 pixel fonts  
6258			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6258			; *  Interface via six digital outputs to the display (see below)  
6258			;  
6258			; LCD module pinout:  
6258			;   1  Vss   0v supply  
6258			;   2  Vdd   5v supply  
6258			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6258			;   4  RS    High = data, Low = instruction  
6258			;   5  R/W   High = Read, Low = Write  
6258			;   6  E     Enable signal (active high)  
6258			;   7  DB0   Data bit 0  
6258			;   8  DB1   Data bit 1  
6258			;   9  DB2   Data bit 2  
6258			;  10  DB3   Data bit 3  
6258			;  11  DB4   Data bit 4  
6258			;  12  DB5   Data bit 5  
6258			;  13  DB6   Data bit 6  
6258			;  14  DB7   Data bit 7  
6258			;  15  A     Backlight anode (+)  
6258			;  16  K     Backlight cathode (-)  
6258			;  
6258			; This interfacing method uses 4-bit data mode and uses time delays  
6258			; rather than polling the display's ready status. As a result the   
6258			; interface only requires 6 simple output lines:  
6258			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6258			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6258			;   LCD DB4 = Microcomputer output port bit 4  
6258			;   LCD DB5 = Microcomputer output port bit 5  
6258			;   LCD DB6 = Microcomputer output port bit 6  
6258			;   LCD DB7 = Microcomputer output port bit 7  
6258			; Display's R/W is connected to 0v so it is always in write mode  
6258			; All 6 connections must be on the same port address <kLCDPrt>  
6258			; This method also allows a decent length of cable from micro to LCD  
6258			;  
6258			; **********************************************************************  
6258			;  
6258			; To include the code for any given function provided by this module,   
6258			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6258			; the parent source file.  
6258			; For example:  #REQUIRES   uHexPrefix  
6258			;  
6258			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6258			; in the parent source file.  
6258			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6258			;  
6258			; These are the function names provided by this module:  
6258			; fLCD_Init                     ;Initialise LCD  
6258			; fLCD_Inst                     ;Send instruction to LCD  
6258			; fLCD_Data                     ;Send data byte to LCD  
6258			; fLCD_Pos                      ;Position cursor  
6258			; fLCD_Str                      ;Display string  
6258			; fLCD_Def                      ;Define custom character  
6258			;  
6258			; **********************************************************************  
6258			;  
6258			; Requires SCMonAPI.asm to also be included in the project  
6258			;  
6258			  
6258			  
6258			; **********************************************************************  
6258			; **  Constants  
6258			; **********************************************************************  
6258			  
6258			; Constants that must be defined externally  
6258			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6258			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6258			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6258			;kLCDWidth: EQU 20             ;Width in characters  
6258			  
6258			; general line offsets in any frame buffer  
6258			  
6258			  
6258			display_row_1: equ 0  
6258			display_row_2: equ display_row_1+display_cols  
6258			display_row_3: equ display_row_2 + display_cols  
6258			display_row_4: equ display_row_3 + display_cols  
6258			;display_row_4_eol:   
6258			  
6258			  
6258			; Cursor position values for the start of each line  
6258			  
6258			; E  
6258			kLCD_Line1: EQU 0x00   
6258			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
6258			; E1  
6258			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
6258			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
6258			  
6258			; Instructions to send as A register to fLCD_Inst  
6258			kLCD_Clear: EQU 00000001b     ;LCD clear  
6258			kLCD_Off:   EQU 00001000b     ;LCD off  
6258			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6258			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6258			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6258			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6258			  
6258			; Constants used by this code module  
6258			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6258			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6258			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6258			  
6258			  
6258			  
6258			; **********************************************************************  
6258			; **  LCD support functions  
6258			; **********************************************************************  
6258			  
6258			; Initialise alphanumeric LCD module  
6258			; LCD control register codes:  
6258			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6258			;   N    0 = 1-line mode       1 = 2-line mode  
6258			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6258			;   D    0 = Display off       1 = Display on  
6258			;   C    0 = Cursor off        1 = Cursor on  
6258			;   B    0 = Blinking off      1 = Blinking on  
6258			;   ID   0 = Decrement mode    1 = Increment mode  
6258			;   SH   0 = Entire shift off  1 = Entire shift on  
6258 3e 28		fLCD_Init:  LD   A, 40  
625a cd 7f 63		            CALL LCDDelay       ;Delay 40ms after power up  
625d			; For reliable reset set 8-bit mode - 3 times  
625d cd 4f 63		            CALL WrFn8bit       ;Function = 8-bit mode  
6260 cd 4f 63		            CALL WrFn8bit       ;Function = 8-bit mode  
6263 cd 4f 63		            CALL WrFn8bit       ;Function = 8-bit mode  
6266			; Set 4-bit mode  
6266 cd 4b 63		            CALL WrFn4bit       ;Function = 4-bit mode  
6269 cd 7d 63		            CALL LCDDelay1      ;Delay 37 us or more  
626c			; Function set  
626c 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
626e cd 81 62		            CALL fLCD_Inst      ;2 line, display on  
6271			; Display On/Off control  
6271 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6273 cd 81 62		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6276			; Display Clear  
6276 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6278 cd 81 62		            CALL fLCD_Inst      ;Clear display  
627b			; Entry mode  
627b 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
627d cd 81 62		            CALL fLCD_Inst      ;Increment mode, shift off  
6280			; Display module now initialised  
6280 c9			            RET  
6281			; ok to here  
6281			  
6281			; Write instruction to LCD  
6281			;   On entry: A = Instruction byte to be written  
6281			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6281 f5			fLCD_Inst:  PUSH AF  
6282 f5			            PUSH AF  
6283 cd 95 62		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6286 f1			            POP  AF  
6287 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6288 17			            RLA  
6289 17			            RLA  
628a 17			            RLA  
628b cd 95 62		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
628e 3e 02		            LD   A, 2  
6290 cd 7f 63		            CALL LCDDelay       ;Delay 2 ms to complete   
6293 f1			            POP  AF  
6294 c9			            RET  
6295			Wr4bits:   
6295 f5					push af  
6296 3a d7 f8				ld a, (display_lcde1e2)  
6299 fe 00				cp 0     ; e  
629b 20 10				jr nz, .wea2	  
629d f1					pop af  
629e e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
62a0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
62a2 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
62a4 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
62a6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
62a8 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
62aa d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
62ac c9			            RET  
62ad f1			.wea2:		pop af  
62ae e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
62b0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
62b2 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
62b4 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
62b6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
62b8 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
62ba d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
62bc c9			            RET  
62bd			  
62bd			  
62bd			; Write data to LCD  
62bd			;   On entry: A = Data byte to be written  
62bd			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
62bd f5			fLCD_Data:  PUSH AF  
62be f5			            PUSH AF  
62bf cd d1 62		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
62c2 f1			            POP  AF  
62c3 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
62c4 17			            RLA  
62c5 17			            RLA  
62c6 17			            RLA  
62c7 cd d1 62		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
62ca 3e 96		            LD   A, 150  
62cc 3d			Wait:      DEC  A              ;Wait a while to allow data   
62cd 20 fd		            JR   NZ, Wait      ;  write to complete  
62cf f1			            POP  AF  
62d0 c9			            RET  
62d1			Wr4bitsa:     
62d1 f5					push af  
62d2 3a d7 f8				ld a, (display_lcde1e2)  
62d5 fe 00				cp 0     ; e1  
62d7 20 16				jr nz, .we2	  
62d9 f1					pop af  
62da e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
62dc cb d7		            SET  kLCDBitRS, A  
62de d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
62e0 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
62e2 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
62e4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
62e6 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
62e8 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
62ea cb 97		            RES  kLCDBitRS, A  
62ec d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
62ee c9			            RET  
62ef f1			.we2:		pop af  
62f0 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
62f2 cb d7		            SET  kLCDBitRS, A  
62f4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
62f6 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
62f8 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
62fa d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
62fc cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
62fe d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6300 cb 97		            RES  kLCDBitRS, A  
6302 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6304 c9			            RET  
6305			  
6305			  
6305			; Position cursor to specified location  
6305			;   On entry: A = Cursor position  
6305			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6305 f5			fLCD_Pos:   PUSH AF  
6306					; at this point set the E1 or E2 flag depending on position  
6306			  
6306 c5					push bc  
6307			;		push af  
6307 06 00				ld b, 0  
6309 4f					ld c, a  
630a 3e 4f				ld a, kLCD_Line3-1  
630c b7			 		or a      ;clear carry flag  
630d 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
630e 38 04				jr c, .pe1  
6310			  
6310					; E selection  
6310 cb 80				res 0, b         ; bit 0 unset e  
6312			;		pop af    ; before line 3 so recover orig pos  
6312			;		ld c, a    ; save for poking back  
6312 18 06				jr .peset	          
6314			.pe1:          	; E2 selection  
6314 cb c0				set 0, b         ; bit 0 set e1  
6316 79					ld a, c  
6317 de 4f				sbc a, kLCD_Line3-1  
6319 4f					ld c, a	         ; save caculated offset  
631a			;		pop af     ; bin this original value now we have calculated form  
631a			  
631a			.peset:		; set bit  
631a 78					ld a, b  
631b 32 d7 f8				ld (display_lcde1e2), a 	  
631e 79					ld a, c  
631f c1					pop bc  
6320			  
6320 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
6322 cd 81 62		            CALL fLCD_Inst      ;Write instruction to LCD  
6325 f1			            POP  AF  
6326 c9			            RET  
6327			  
6327			  
6327			; Output text string to LCD  
6327			;   On entry: DE = Pointer to null terminated text string  
6327			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6327 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6328 b7			            OR   A              ;Null terminator?  
6329 c8			            RET  Z              ;Yes, so finished  
632a cd bd 62		            CALL fLCD_Data      ;Write character to display  
632d 13			            INC  DE             ;Point to next character  
632e 18 f7		            JR   fLCD_Str       ;Repeat  
6330 c9					ret  
6331			  
6331			; Define custom character  
6331			;   On entry: A = Character number (0 to 7)  
6331			;             DE = Pointer to character bitmap data  
6331			;   On exit:  A = Next character number  
6331			;             DE = Next location following bitmap  
6331			;             BC HL IX IY I AF' BC' DE' HL' preserved  
6331			; Character is   
6331 c5			fLCD_Def:   PUSH BC  
6332 f5			            PUSH AF  
6333 07			            RLCA                ;Calculate location  
6334 07			            RLCA                ;  for bitmap data  
6335 07			            RLCA                ;  = 8 x CharacterNumber  
6336 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6338 cd 81 62		            CALL fLCD_Inst      ;Write instruction to LCD  
633b 06 00		            LD   B, 0  
633d 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
633e cd bd 62		            CALL fLCD_Data      ;Write byte to display  
6341 13			            INC  DE             ;Point to next byte  
6342 04			            INC  B              ;Count bytes  
6343 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6345 28 f6		            JR   Z, Loop       ;No, so repeat  
6347 f1			            POP  AF  
6348 3c			            INC  A              ;Increment character number  
6349 c1			            POP  BC  
634a c9			            RET  
634b			  
634b			  
634b			; **********************************************************************  
634b			; **  Private functions  
634b			; **********************************************************************  
634b			  
634b			; Write function to LCD  
634b			;   On entry: A = Function byte to be written  
634b			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
634b 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
634d 18 02		            JR   WrFunc  
634f 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6351 f5			WrFunc:     PUSH AF  
6352 f5					push af  
6353 3a d7 f8				ld a, (display_lcde1e2)  
6356 fe 00				cp 0     ; e1  
6358 20 0f				jr nz, .wfea2	  
635a f1					pop af  
635b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
635d cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
635f cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6361 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6363 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6365 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6367 18 0d			jr .wfskip  
6369 f1			.wfea2:		pop af  
636a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
636c cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
636e cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6370 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6372 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6374 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6376 3e 05		.wfskip:            LD  A, 5  
6378 cd 7f 63		            CALL LCDDelay       ;Delay 5 ms to complete  
637b f1			            POP  AF  
637c c9			            RET  
637d			  
637d			  
637d			; Delay in milliseconds  
637d			;   On entry: A = Number of milliseconds delay  
637d			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
637d 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
637f d5			LCDDelay:   PUSH DE  
6380 5f			            LD   E, A           ;Delay by 'A' ms  
6381 16 00		            LD   D, 0  
6383 cd 22 0a		            CALL aDelayInMS  
6386 d1			            POP  DE  
6387 c9			            RET  
6388			  
6388			  
6388			testlcd:  
6388 3e 00			ld a, kLCD_Line1  
638a cd 05 63			call fLCD_Pos  
638d 06 28			ld b, 40  
638f 11 bd 63			ld de, .ttext1  
6392 cd 50 62			call write_len_string  
6395			  
6395 3e 28			ld a, kLCD_Line2  
6397 cd 05 63			call fLCD_Pos  
639a 06 28			ld b, 40  
639c 11 e6 63			ld de, .ttext2  
639f cd 50 62			call write_len_string  
63a2 3e 50			ld a, kLCD_Line3  
63a4 cd 05 63			call fLCD_Pos  
63a7 06 28			ld b, 40  
63a9 11 0f 64			ld de, .ttext3  
63ac cd 50 62			call write_len_string  
63af 3e 78			ld a, kLCD_Line4  
63b1 cd 05 63			call fLCD_Pos  
63b4 06 28			ld b, 40  
63b6 11 38 64			ld de, .ttext4  
63b9 cd 50 62			call write_len_string  
63bc			  
63bc 76				halt  
63bd			  
63bd			  
63bd .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
63e6 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
640f .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
6438 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
6461			   
6461			  
6461			  
6461			; eof  
6461			  
# End of file firmware_lcd_4x40.asm
6461			;include "firmware_lcd_4x20.asm" 
6461			include "firmware_key_5x10.asm" 
6461			; 5 x 10 decade counter scanner  
6461			  
6461			  
6461			; TODO do cursor shape change for shift keys  
6461			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
6461			  
6461			  
6461			; bit mask for each scan column and row for teing the matrix  
6461			  
6461			  
6461			key_init:  
6461			  
6461			; SCMonAPI functions used  
6461			  
6461			; Alphanumeric LCD functions used  
6461			; no need to specify specific functions for this module  
6461			  
6461			  
6461 3e cf		            LD   A, 11001111b  
6463 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
6465			;            LD   A, 00000000b  
6465 3e 1f		            LD   A, 00011111b  
6467 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
6469			  
6469			  
6469				; TODO Configure cursor shapes  
6469			  
6469				; Load cursor shapes   
6469 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
646b 11 7b 64		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
646e 06 02		            LD   B, 2           ;Number of characters to define  
6470 cd 31 63		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6473 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6475			  
6475 3e 01				ld a, 1  
6477 32 d0 f8			ld (cursor_shape),a  
647a c9				ret  
647b			  
647b			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
647b			; Up to 8 custom characters can be defined  
647b			.cursor_shapes:      
647b			;; Character 0x00 = Normal  
647b 1f			            DB  11111b  
647c 1f			            DB  11111b  
647d 1f			            DB  11111b  
647e 1f			            DB  11111b  
647f 1f			            DB  11111b  
6480 1f			            DB  11111b  
6481 1f			            DB  11111b  
6482 1f			            DB  11111b  
6483			;; Character 0x01 = Modifier  
6483 1f			            DB  11111b  
6484 1b			            DB  11011b  
6485 1b			            DB  11011b  
6486 1b			            DB  11011b  
6487 1b			            DB  11011b  
6488 1f			            DB  11111b  
6489 1b			            DB  11011b  
648a 1f			            DB  11111b  
648b			  
648b			  
648b			  
648b			  
648b			; Display custom character 0  
648b			;            LD   A, kLCD_Line1+14  
648b			;            CALL fLCD_Pos       ;Position cursor to location in A  
648b			;            LD   A, 0  
648b			;            CALL fLCD_Data      ;Write character in A at cursor  
648b			  
648b			; Display custom character 1  
648b			;            LD   A, kLCD_Line2+14  
648b			;            CALL fLCD_Pos      ;Position cursor to location in A  
648b			;            LD   A, 1  
648b			;            CALL fLCD_Data     ;Write character in A at cursor  
648b			  
648b			; keyboard scanning   
648b			  
648b			; character in from keyboard  
648b			  
648b			; mapping for the pcb layout  
648b			  
648b			.matrix_to_char:  
648b .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
6496 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
64a1 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
64ac 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
64b7 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
64c2			.matrix_to_shift:  
64c2			  
64c2 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
64cd .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
64d8 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
64e3 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
64ee .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
64f9			  
64f9			.matrix_to_symbolshift:  
64f9			  
64f9 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
6504 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
650f 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
651a			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
651a 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
6525 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
6530			  
6530			  
6530			  
6530			; mapping for a simple straight through breadboard layout  
6530			  
6530			;.matrix_to_char:  
6530			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6530			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
6530			;		db "asdfghjkl",KEY_CR,0  
6530			;		db "qwertyuiop",0  
6530			;		 db "1234567890",0  
6530			;.matrix_to_shift:  
6530			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
6530			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
6530			;		db "ASDFGHJKL",KEY_CR,0  
6530			;		db "QWERTYUIOP",0  
6530			;		 db "!",'"',"#$%^&*()",0  
6530			;.matrix_to_symbolshift:  
6530			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6530			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
6530			;		db "_?*fghjk=",KEY_CR,0  
6530			;		db "-/+*[]{}@#",0  
6530			;		 db "1234567890",0  
6530			  
6530			;.matrix_to_char: db "D#0*C987B654A321"  
6530			  
6530			  
6530				  
6530			  
6530			; add cin and cin_wait  
6530			  
6530 cd 41 65		cin_wait: 	call cin  
6533						if DEBUG_KEYCINWAIT  
6533							push af  
6533							  
6533							ld hl,key_repeat_ct  
6533							ld (hl),a  
6533							inc hl  
6533							call hexout  
6533							ld hl,key_repeat_ct+3  
6533							ld a,0  
6533							ld (hl),a  
6533			  
6533							    LD   A, kLCD_Line1+11  
6533							    CALL fLCD_Pos       ;Position cursor to location in A  
6533							    LD   DE, key_repeat_ct  
6533							    ;LD   DE, MsgHello  
6533							    CALL fLCD_Str       ;Display string pointed to by DE  
6533			  
6533			  
6533			  
6533							pop af  
6533						endif  
6533 fe 00			cp 0  
6535 28 f9			jr z, cin_wait   ; block until key press  
6537			  
6537							if DEBUG_KEYCINWAIT  
6537								push af  
6537			  
6537								ld a, 'A'	  
6537								ld hl,key_repeat_ct  
6537								ld (hl),a  
6537								inc hl  
6537								ld a,0  
6537								ld (hl),a  
6537			  
6537								    LD   A, kLCD_Line2+11  
6537								    CALL fLCD_Pos       ;Position cursor to location in A  
6537								    LD   DE, key_repeat_ct  
6537								    ;LD   DE, MsgHello  
6537								    CALL fLCD_Str       ;Display string pointed to by DE  
6537			  
6537							call delay500ms  
6537			  
6537								pop af  
6537							endif  
6537 f5				push af   ; save key pressed  
6538			  
6538			.cin_wait1:	  
6538							if DEBUG_KEYCINWAIT  
6538								push af  
6538			  
6538								ld a, 'b'	  
6538								ld hl,key_repeat_ct  
6538								ld (hl),a  
6538								inc hl  
6538								ld a,0  
6538								ld (hl),a  
6538			  
6538								    LD   A, kLCD_Line2+11  
6538								    CALL fLCD_Pos       ;Position cursor to location in A  
6538								    LD   DE, key_repeat_ct  
6538								    ;LD   DE, MsgHello  
6538								    CALL fLCD_Str       ;Display string pointed to by DE  
6538			  
6538			  
6538							call delay500ms  
6538			  
6538								pop af  
6538							endif  
6538			  
6538 cd 41 65		call cin  
653b fe 00			cp 0  
653d 20 f9			jr nz, .cin_wait1  	; wait for key release  
653f			if DEBUG_KEYCINWAIT  
653f				push af  
653f			  
653f				ld a, '3'	  
653f				ld hl,key_repeat_ct  
653f				ld (hl),a  
653f				inc hl  
653f				ld a,0  
653f				ld (hl),a  
653f			  
653f			            LD   A, kLCD_Line2+11  
653f			            CALL fLCD_Pos       ;Position cursor to location in A  
653f			            LD   DE, key_repeat_ct  
653f			            ;LD   DE, MsgHello  
653f			            CALL fLCD_Str       ;Display string pointed to by DE  
653f			  
653f			  
653f			call delay500ms  
653f			  
653f				pop af  
653f			endif  
653f			  
653f f1				pop af   ; get key  
6540 c9				ret  
6541			  
6541			  
6541 cd 55 65		cin: 	call .mtoc  
6544			  
6544			if DEBUG_KEYCIN  
6544				push af  
6544				  
6544				ld hl,key_repeat_ct  
6544				ld (hl),a  
6544				inc hl  
6544				call hexout  
6544				ld hl,key_repeat_ct+3  
6544				ld a,0  
6544				ld (hl),a  
6544			  
6544			            LD   A, kLCD_Line3+15  
6544			            CALL fLCD_Pos       ;Position cursor to location in A  
6544			            LD   DE, key_repeat_ct  
6544			            ;LD   DE, MsgHello  
6544			            CALL fLCD_Str       ;Display string pointed to by DE  
6544			  
6544			  
6544			call delay500ms  
6544			  
6544				pop af  
6544			endif  
6544			  
6544			  
6544				; no key held  
6544 fe 00			cp 0  
6546 c8				ret z  
6547			  
6547			if DEBUG_KEYCIN  
6547				push af  
6547			  
6547				ld a, '1'	  
6547				ld hl,key_repeat_ct  
6547				ld (hl),a  
6547				inc hl  
6547				ld a,0  
6547				ld (hl),a  
6547			  
6547			            LD   A, kLCD_Line4+15  
6547			            CALL fLCD_Pos       ;Position cursor to location in A  
6547			            LD   DE, key_repeat_ct  
6547			            ;LD   DE, MsgHello  
6547			            CALL fLCD_Str       ;Display string pointed to by DE  
6547			  
6547			  
6547			call delay500ms  
6547			  
6547				pop af  
6547			endif  
6547			  
6547				; stop key bounce  
6547			  
6547 32 88 fb			ld (key_held),a		 ; save it  
654a 47				ld b, a  
654b			  
654b c5			.cina1:	push bc  
654c			if DEBUG_KEYCIN  
654c				push af  
654c			  
654c				ld hl,key_repeat_ct  
654c				inc hl  
654c				call hexout  
654c				ld hl,key_repeat_ct+3  
654c				ld a,0  
654c				ld (hl),a  
654c				ld hl,key_repeat_ct  
654c				ld a, '2'	  
654c				ld (hl),a  
654c			  
654c			            LD   A, kLCD_Line4+15  
654c			            CALL fLCD_Pos       ;Position cursor to location in A  
654c			            LD   DE, key_repeat_ct  
654c			            ;LD   DE, MsgHello  
654c			            CALL fLCD_Str       ;Display string pointed to by DE  
654c			  
654c				pop af  
654c			endif  
654c cd 55 65			call .mtoc  
654f c1				pop bc  
6550 b8				cp b  
6551 28 f8			jr z, .cina1  
6553 78				ld a,b		  
6554			if DEBUG_KEYCIN  
6554				push af  
6554			  
6554				ld hl,key_repeat_ct  
6554				inc hl  
6554				call hexout  
6554				ld hl,key_repeat_ct+3  
6554				ld a,0  
6554				ld (hl),a  
6554				ld hl,key_repeat_ct  
6554				ld a, '3'	  
6554				ld (hl),a  
6554			  
6554			            LD   A, kLCD_Line4+15  
6554			            CALL fLCD_Pos       ;Position cursor to location in A  
6554			            LD   DE, key_repeat_ct  
6554			            ;LD   DE, MsgHello  
6554			            CALL fLCD_Str       ;Display string pointed to by DE  
6554			  
6554				pop af  
6554			endif  
6554 c9				ret  
6555			  
6555			; detect keyboard modifier key press and apply new overlay to the face key held  
6555			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
6555			  
6555			;.cin_map_modifier:   
6555			;	ld a, (hl)  
6555			;	and 255  
6555			;	ret NZ		; modifier key not flagged  
6555			;  
6555			;	; get key face  
6555			;  
6555			;	ld b,(key_face_held)  
6555			;  
6555			;	ld b, key_cols * key_rows  
6555			;  
6555			;	push de  
6555			;	pop hl  
6555			;  
6555			;.mmod1: ld a,(hl)   ; get map test  
6555			;	cp b  
6555			;	jr z, .mmod2  
6555			;  
6555			;  
6555			;  
6555			;.mmod2: inc hl    ;   
6555			;  
6555			;	  
6555			;  
6555			;	  
6555			;  
6555			;	ld hl,key_actual_pressed  
6555			;	ld (hl),a,  
6555			;	ret  
6555			  
6555			; map matrix key held to char on face of key  
6555			  
6555			.mtoc:  
6555			  
6555			; test decade counter strobes  
6555			  
6555			;.decadetest1:  
6555			  
6555			; reset counter  
6555			;ld a, 128  
6555			;out (portbdata),a  
6555			  
6555			  
6555			;ld b, 5  
6555			;.dec1:  
6555			;ld a, 0  
6555			;out (portbdata),a  
6555			;call delay1s  
6555			  
6555			;ld a, 32  
6555			;out (portbdata),a  
6555			;call delay1s  
6555			;call delay1s  
6555			;call delay1s  
6555			;  
6555			;ld a, 64+32  
6555			;out (portbdata),a  
6555			;call delay1s  
6555			;;djnz .dec1  
6555			;  
6555			;jp .decadetest1  
6555			  
6555			  
6555			  
6555			  
6555			  
6555			  
6555			  
6555			  
6555			  
6555			  
6555				; scan keyboard matrix and generate raw scan map  
6555 cd e8 65			call matrix  
6558			  
6558				; reuse c bit 0 left modifer button - ie shift  
6558			        ; reuse c bit 1 for right modifer button - ie symbol shift  
6558				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
6558			  
6558 0e 00			ld c, 0  
655a			  
655a				; TODO set flags for modifer key presses   
655a				; TODO do a search for modifer key...  
655a			  
655a				;ld hl,keyscan_table_row4  
655a 21 e7 fb			ld hl,keyscan_table_row2  
655d			  
655d 7e				ld a, (hl)  
655e fe 23			cp '#'  
6560 20 07			jr nz, .nextmodcheck  
6562 cb c1			set 0, c  
6564 21 c2 64			ld hl, .matrix_to_shift  
6567 18 21			jr .dokeymap  
6569				; TODO for now igonre  
6569			.nextmodcheck:  
6569 21 dc fb			ld hl,keyscan_table_row3  
656c			  
656c 7e				ld a, (hl)  
656d fe 23			cp '#'  
656f 20 07			jr nz, .nextmodcheck2  
6571 cb c9			set 1, c   
6573 21 f9 64			ld hl, .matrix_to_symbolshift  
6576 18 12			jr .dokeymap  
6578			.nextmodcheck2:  
6578 21 f0 fb			ld hl,keyscan_table_row2+9    ; right shift  
657b			  
657b 7e				ld a, (hl)  
657c fe 23			cp '#'  
657e 20 07			jr nz, .donemodcheck  
6580 cb c9			set 1, c   
6582 21 c2 64			ld hl, .matrix_to_shift  
6585 18 03			jr .dokeymap  
6587			  
6587				; no modifer found so just map to normal keys  
6587				; get mtoc map matrix to respective keys  
6587			;	ld hl, .matrix_to_char  
6587			;	ld hl, .matrix_to_char  
6587			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6587			;	ld a, KEY_SHIFT  
6587			;	call findchar  
6587			;  
6587			;	; got offset to key modifer in b  
6587			;  
6587			;	ld hl,keyscan_table_row5  
6587			;  
6587			;	ld a,b  
6587			;	call addatohl  
6587			;	ld a,(hl)  
6587			;  
6587			;	cp '#'  
6587			;	jr nz, .nextmodcheck  
6587			;	set 0, c  
6587			;	ld hl, .matrix_to_char  
6587			;	jr .dokeymap  
6587			;	; TODO for now igonre  
6587			;.nextmodcheck:  
6587			;	ld hl, .matrix_to_symbolshift  
6587			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6587			;	ld a, KEY_SYMBOLSHIFT  
6587			;	call findchar  
6587			;  
6587			;  
6587			;	; got offset to key modifer in b  
6587			;  
6587			;	ld hl,keyscan_table_row5  
6587			;  
6587			;	ld a,b  
6587			;	call addatohl  
6587			;	ld a,(hl)  
6587			;  
6587			;	cp '#'  
6587			;	jr nz, .donemodcheck  
6587			;	set 1, c   
6587			;	ld hl, .matrix_to_symbolshift  
6587			;	jr .dokeymap  
6587			  
6587			  
6587			  
6587			.donemodcheck:  
6587				; no modifer found so just map to normal keys  
6587				; get mtoc map matrix to respective keys  
6587 21 8b 64			ld hl, .matrix_to_char  
658a			  
658a			.dokeymap:  
658a				;ld (key_fa), c   
658a cd a3 65			call .mapkeys  
658d			  
658d			  
658d			if DEBUG_KEY  
658d			  
658d			; Display text on first line  
658d			            LD   A, kLCD_Line1  
658d			            CALL fLCD_Pos       ;Position cursor to location in A  
658d			            LD   DE, keyscan_table_row1  
658d			            ;LD   DE, MsgHello  
658d			            CALL fLCD_Str       ;Display string pointed to by DE  
658d			  
658d			; Display text on second line  
658d			            LD   A, kLCD_Line2  
658d			            CALL fLCD_Pos       ;Position cursor to location in A  
658d			            LD   DE, keyscan_table_row2  
658d			            CALL fLCD_Str       ;Display string pointed to by DE  
658d			            LD   A, kLCD_Line3  
658d			            CALL fLCD_Pos       ;Position cursor to location in A  
658d			            LD   DE, keyscan_table_row3  
658d			            CALL fLCD_Str       ;Display string pointed to by DE  
658d			            LD   A, kLCD_Line4  
658d			            CALL fLCD_Pos       ;Position cursor to location in A  
658d			            LD   DE, keyscan_table_row4  
658d			            CALL fLCD_Str       ;Display string pointed to by DE  
658d			            LD   A, kLCD_Line1+10  
658d			            CALL fLCD_Pos       ;Position cursor to location in A  
658d			            LD   DE, keyscan_table_row5  
658d			            CALL fLCD_Str       ;Display string pointed to by DE  
658d			  
658d				;call delay250ms  
658d			endif  
658d			;	jp testkey  
658d			  
658d			; get first char reported  
658d			  
658d 21 c6 fb			ld hl,keyscan_table_row5  
6590			  
6590				;ld b, 46   ; 30 keys to remap + 8 nulls   
6590 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6592			.findkey:  
6592 7e				ld a,(hl)  
6593 fe 00			cp 0  
6595 28 04			jr z, .nextkey  
6597 fe 7e			cp KEY_MATRIX_NO_PRESS  
6599 20 06			jr nz, .foundkey  
659b			.nextkey:  
659b 23				inc hl  
659c 10 f4			djnz .findkey  
659e 3e 00			ld a,0  
65a0 c9				ret  
65a1			.foundkey:  
65a1 7e				ld a,(hl)  
65a2 c9				ret  
65a3				  
65a3			  
65a3			; convert the raw key map given hl for destination key  
65a3			.mapkeys:  
65a3 11 c6 fb			ld de,keyscan_table_row5  
65a6			  
65a6 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
65a8			.remap:  
65a8 1a				ld a,(de)  
65a9 fe 23			cp '#'  
65ab 20 02			jr nz, .remapnext  
65ad				;CALLMONITOR  
65ad 7e				ld a,(hl)  
65ae 12				ld (de),a  
65af			  
65af			  
65af			  
65af			.remapnext:  
65af 23				inc hl  
65b0 13				inc de  
65b1 10 f5			djnz .remap  
65b3				  
65b3 c9				ret  
65b4			  
65b4			  
65b4			  
65b4			.mtocold2:  
65b4			  
65b4			;	; flag if key D is held down and remove from reporting  
65b4			;	ld bc, .key_map_fd    
65b4			;	ld hl, keyscan_table  
65b4			;	ld de, key_fd  
65b4			;	call .key_shift_hold  
65b4			;	cp 255  
65b4			;	jr z, .cinmap  
65b4			;	; flag if key C is held down and remove from reporting  
65b4			;	ld bc, .key_map_fc    
65b4			;	ld hl, keyscan_table+key_cols  
65b4			;	ld de, key_fc  
65b4			;	call .key_shift_hold  
65b4			;	cp 255  
65b4			;	jr z, .cinmap  
65b4			;	; flag if key B is held down and remove from reporting  
65b4			;	ld bc, .key_map_fb    
65b4			;	ld hl, keyscan_table+(key_cols*2)  
65b4			;	ld de, key_fb  
65b4			;	call .key_shift_hold  
65b4			;	cp 255  
65b4			;	jr z, .cinmap  
65b4			;	; flag if key A is held down and remove from reporting  
65b4			;	ld bc, .key_map_fa    
65b4			;	ld hl, keyscan_table+(key_cols*3)  
65b4			;	ld de, key_fa  
65b4			;	call .key_shift_hold  
65b4			;	cp 255  
65b4			;	jr z, .cinmap  
65b4			  
65b4 11 8b 64			ld de, .matrix_to_char  
65b7			  
65b7			  
65b7			.cinmap1:   
65b7				if DEBUG_KEY  
65b7			            LD   A, kLCD_Line4  
65b7			            CALL fLCD_Pos       ;Position cursor to location in A  
65b7					push de  
65b7			            LD   DE, keyscan_table  
65b7			            CALL fLCD_Str       ;Display string pointed to by DE  
65b7					pop de  
65b7				endif  
65b7			  
65b7				; scan key matrix table for any held key  
65b7			  
65b7				; de holds either the default matrix or one selected above  
65b7			  
65b7 21 93 fb			ld hl, keyscan_table  
65ba 06 32			ld b,key_cols*key_rows  
65bc			  
65bc 7e			.cin11:	ld a,(hl)  
65bd fe 23			cp '#'  
65bf 28 08			jr z, .cinhit1  
65c1 23				inc hl  
65c2 13				inc de  
65c3 05				dec b  
65c4 20 f6			jr nz, .cin11  
65c6				; no key found held  
65c6 3e 00			ld a,0  
65c8 c9				ret  
65c9 d5			.cinhit1: push de  
65ca e1				pop hl  
65cb 7e				ld a,(hl)  
65cc c9				ret  
65cd			  
65cd			; flag a control key is held   
65cd			; hl is key pin, de is flag indicator  
65cd			  
65cd			.key_shift_hold1:  
65cd c5				push bc  
65ce 3e 01			ld a, 1  
65d0 32 d0 f8			ld (cursor_shape),a  
65d3 06 00			ld b, 0  
65d5 7e				ld a, (hl)  
65d6 fe 2e			cp '.'  
65d8 28 0a			jr z, .key_shift11  
65da 06 ff			ld b, 255  
65dc 3e 2b			ld a, '+'    ; hide key from later scans  
65de 77				ld (hl),a  
65df 3e 02			ld a, 2  
65e1 32 d0 f8			ld (cursor_shape),a  
65e4			.key_shift11:  
65e4				; write flag indicator  
65e4 78				ld a,b  
65e5 12				ld (de),a  
65e6			  
65e6 d1				pop de    ; de now holds the key map ptr  
65e7 c9				ret  
65e8			  
65e8				  
65e8			  
65e8			; scans keyboard matrix and flags key press in memory array	  
65e8				  
65e8			matrix:  
65e8				;call matrix  
65e8				; TODO optimise the code....  
65e8			  
65e8			  
65e8			;ld hl, keyscan_table_row1  
65e8			;ld de, keyscan_table_row1+1  
65e8			;ld bc,46  
65e8			;ld a,KEY_MATRIX_NO_PRESS  
65e8			;ldir  
65e8			  
65e8			  
65e8			  
65e8			; reset counter  
65e8 3e 80		ld a, 128  
65ea d3 c1		out (portbdata),a  
65ec			  
65ec 06 0a		ld b, 10  
65ee 0e 00		ld c, 0       ; current clock toggle  
65f0			  
65f0			.colscan:  
65f0			  
65f0			; set current column  
65f0			; disable clock enable and set clock low  
65f0			  
65f0			;ld a, 0  
65f0			;out (portbdata),a  
65f0			  
65f0			; For each column scan for switches  
65f0			  
65f0 c5			push bc  
65f1 21 89 fb		ld hl, keyscan_scancol  
65f4 cd fd 66		call .rowscan  
65f7 c1			pop bc  
65f8			  
65f8			  
65f8			; get back current column  
65f8			  
65f8			; translate the row scan  
65f8			  
65f8			;   
65f8			; row 1  
65f8			  
65f8 78			ld a,b  
65f9			  
65f9 21 fc fb		LD   hl, keyscan_table_row1+10  
65fc			  
65fc cd d1 0c		call subafromhl  
65ff			;call addatohl  
65ff			  
65ff 11 89 fb		ld de, keyscan_scancol  
6602			  
6602 1a			ld a,(de)  
6603 77			ld (hl),a  
6604			  
6604			  
6604			  
6604			  
6604			; row 2  
6604			  
6604 78			ld a,b  
6605			  
6605 21 f1 fb		LD   hl, keyscan_table_row2+10  
6608			  
6608			;call addatohl  
6608 cd d1 0c		call subafromhl  
660b			  
660b			  
660b 11 8a fb		ld de, keyscan_scancol+1  
660e			  
660e 1a			ld a,(de)  
660f 77			ld (hl),a  
6610			  
6610			  
6610			; row 3  
6610			  
6610 78			ld a,b  
6611			  
6611 21 e6 fb		LD   hl, keyscan_table_row3+10  
6614			  
6614			;call addatohl  
6614 cd d1 0c		call subafromhl  
6617			  
6617 11 8b fb		ld de, keyscan_scancol+2  
661a			  
661a 1a			ld a,(de)  
661b 77			ld (hl),a  
661c			  
661c			  
661c			  
661c			; row 4  
661c			  
661c 78			ld a,b  
661d			  
661d 21 db fb		LD   hl, keyscan_table_row4+10  
6620			  
6620			;call addatohl  
6620 cd d1 0c		call subafromhl  
6623			  
6623 11 8c fb		ld de, keyscan_scancol+3  
6626			  
6626 1a			ld a,(de)  
6627 77			ld (hl),a  
6628			  
6628			; row 5  
6628			  
6628 78			ld a,b  
6629			  
6629 21 d0 fb		LD   hl, keyscan_table_row5+10  
662c			  
662c			;call addatohl  
662c cd d1 0c		call subafromhl  
662f			  
662f 11 8d fb		ld de, keyscan_scancol+4  
6632			  
6632 1a			ld a,(de)  
6633 77			ld (hl),a  
6634			  
6634			; handshake next column  
6634			  
6634			  
6634 3e 40		ld a, 64  
6636 d3 c1		out (portbdata),a  
6638			  
6638 3e 00		ld a, 0  
663a d3 c1		out (portbdata),a  
663c			  
663c			; toggle clk and move to next column  
663c			;ld a, 64  
663c			;cp c  
663c			;  
663c			;jr z, .coltoglow  
663c			;ld c, a  
663c			;jr .coltog  
663c			;.coltoglow:  
663c			;ld c, 0  
663c			;.coltog:  
663c			;ld a, c  
663c			;out (portbdata),a  
663c			  
663c 10 b2		djnz .colscan  
663e			  
663e 3e 0a		ld a,10  
6640 21 f2 fb		LD   hl, keyscan_table_row1  
6643 cd bf 0c		call addatohl  
6646 3e 00		ld a, 0  
6648 77			ld (hl), a  
6649			  
6649			  
6649 3e 0a		ld a,10  
664b 21 e7 fb		LD   hl, keyscan_table_row2  
664e cd bf 0c		call addatohl  
6651 3e 00		ld a, 0  
6653 77			ld (hl), a  
6654			  
6654 3e 0a		ld a,10  
6656 21 dc fb		LD   hl, keyscan_table_row3  
6659 cd bf 0c		call addatohl  
665c 3e 00		ld a, 0  
665e 77			ld (hl), a  
665f			  
665f 3e 0a		ld a,10  
6661 21 d1 fb		LD   hl, keyscan_table_row4  
6664 cd bf 0c		call addatohl  
6667 3e 00		ld a, 0  
6669 77			ld (hl), a  
666a			  
666a 3e 0a		ld a,10  
666c 21 c6 fb		LD   hl, keyscan_table_row5  
666f cd bf 0c		call addatohl  
6672 3e 00		ld a, 0  
6674 77			ld (hl), a  
6675			  
6675			if DEBUG_KEY_MATRIX  
6675			  
6675			; Display text on first line  
6675			            LD   A, kLCD_Line1  
6675			            CALL fLCD_Pos       ;Position cursor to location in A  
6675			            LD   DE, keyscan_table_row1  
6675			            ;LD   DE, MsgHello  
6675			            CALL fLCD_Str       ;Display string pointed to by DE  
6675			  
6675			; Display text on second line  
6675			            LD   A, kLCD_Line2  
6675			            CALL fLCD_Pos       ;Position cursor to location in A  
6675			            LD   DE, keyscan_table_row2  
6675			            CALL fLCD_Str       ;Display string pointed to by DE  
6675			            LD   A, kLCD_Line3  
6675			            CALL fLCD_Pos       ;Position cursor to location in A  
6675			            LD   DE, keyscan_table_row3  
6675			            CALL fLCD_Str       ;Display string pointed to by DE  
6675			            LD   A, kLCD_Line4  
6675			            CALL fLCD_Pos       ;Position cursor to location in A  
6675			            LD   DE, keyscan_table_row4  
6675			            CALL fLCD_Str       ;Display string pointed to by DE  
6675			            LD   A, kLCD_Line4+10  
6675			            CALL fLCD_Pos       ;Position cursor to location in A  
6675			            LD   DE, keyscan_table_row5  
6675			            CALL fLCD_Str       ;Display string pointed to by DE  
6675			  
6675			;call delay250ms  
6675				jp matrix  
6675			endif  
6675 c9			ret  
6676			  
6676			; using decade counter....  
6676			  
6676			  
6676			; TODO reset decade counter to start of scan  
6676			  
6676			; reset 15  
6676			; clock 14  
6676			; ce 13  
6676			  
6676			; 1 - q5  
6676			; 2 - q1  
6676			; 3 - q0  
6676			; 4 - q2  
6676			; 5 - q6  
6676			; 6 - q7  
6676			; 7 - q3  
6676			; 8 - vss  
6676			; 9 - q8  
6676			; 10 - q4  
6676			; 11 - q9  
6676			; 12 - cout  
6676			; 16 - vdd  
6676			  
6676			; clock      ce       reset     output  
6676			; 0          x        0         n  
6676			; x          1        0         n  
6676			; x          x        1         q0  
6676			; rising     0        0         n+1  
6676			; falling    x        0         n  
6676			; x          rising   0         n  
6676			; 1          falling  0         x+1  
6676			;  
6676			; x = dont care, if n < 5 carry = 1 otherwise 0  
6676			  
6676			;   
6676			; reset   
6676			; 13=0, 14=0, 15=1 .. 15=0  
6676			;  
6676			; handshake line  
6676			; 14=1.... read line 14=0  
6676			  
6676			  
6676			  
6676			  
6676			  
6676			; TODO hand shake clock for next column scan  
6676			; TODO detect each row  
6676			  
6676			  
6676			  
6676			  
6676			; reset 128  
6676			; clock 64  
6676			; ce 32  
6676			  
6676			  
6676			.cyclestart:  
6676			  
6676			; reset counter  
6676 3e 80		ld a, 128  
6678 d3 c1		out (portbdata),a  
667a			  
667a			; loop leds  
667a 06 0a		ld b,10  
667c			  
667c			.cycle1:  
667c c5			push bc  
667d 3e 00		ld a, 0  
667f d3 c1		out (portbdata),a  
6681 cd 31 0a		call delay250ms  
6684			  
6684 3e 40		ld a, 64  
6686 d3 c1		out (portbdata),a  
6688 cd 31 0a		call delay250ms  
668b			  
668b 3e 00		ld a, 0  
668d d3 c1		out (portbdata),a  
668f cd 31 0a		call delay250ms  
6692			  
6692 c1			pop bc  
6693 10 e7		djnz .cycle1  
6695			  
6695			  
6695 18 df		jr .cyclestart  
6697			  
6697			  
6697			  
6697			  
6697			  
6697			  
6697			  
6697			  
6697			  
6697			; map matrix key held to char on face of key  
6697			  
6697			;.mtocold:  
6697			;  
6697			;  
6697			;; reset counter  
6697			;ld a, 128  
6697			;out (portbdata),a  
6697			;  
6697			;  
6697			;; scan keyboard row 1  
6697			;ld a, 0  
6697			;out (portbdata),a  
6697			;;ld a, 64  
6697			;;out (portbdata),a  
6697			;  
6697			;  
6697			;	ld a, 128  
6697			;	ld hl, keyscan_table  
6697			;	call .rowscan  
6697			;  
6697			;;ld a, 0  
6697			;;out (portbdata),a  
6697			;ld a, 64  
6697			;out (portbdata),a  
6697			;  
6697			;	ld a, 64  
6697			;	ld hl, keyscan_table+key_cols  
6697			;	call .rowscan  
6697			;  
6697			;ld a, 0  
6697			;out (portbdata),a  
6697			;;ld a, 64  
6697			;;out (portbdata),a  
6697			;	ld a, 32  
6697			;	ld hl, keyscan_table+(key_cols*2)  
6697			;	call .rowscan  
6697			;  
6697			;  
6697			;;ld a, 0  
6697			;;out (portbdata),a  
6697			;ld a, 64  
6697			;out (portbdata),a  
6697			;  
6697			;	ld a, 16  
6697			;	ld hl, keyscan_table+(key_cols*3)  
6697			;	call .rowscan  
6697			;  
6697			;  
6697			;	; flag if key D is held down and remove from reporting  
6697			;	ld bc, .key_map_fd    
6697			;	ld hl, keyscan_table  
6697			;	ld de, key_fd  
6697			;	call .key_shift_hold  
6697			;	cp 255  
6697			;	jr z, .cinmap  
6697			;	; flag if key C is held down and remove from reporting  
6697			;	ld bc, .key_map_fc    
6697			;	ld hl, keyscan_table+key_cols  
6697			;	ld de, key_fc  
6697			;	call .key_shift_hold  
6697			;	cp 255  
6697			;	jr z, .cinmap  
6697			;	; flag if key B is held down and remove from reporting  
6697			;	ld bc, .key_map_fb    
6697			;	ld hl, keyscan_table+(key_cols*2)  
6697			;	ld de, key_fb  
6697			;	call .key_shift_hold  
6697			;	cp 255  
6697			;	jr z, .cinmap  
6697			;	; flag if key A is held down and remove from reporting  
6697			;	ld bc, .key_map_fa    
6697			;	ld hl, keyscan_table+(key_cols*3)  
6697			;	ld de, key_fa  
6697			;	call .key_shift_hold  
6697			;	cp 255  
6697			;	jr z, .cinmap  
6697			;  
6697			;	ld de, .matrix_to_char  
6697			;  
6697			;  
6697			;.cinmap:   
6697			;	if DEBUG_KEY  
6697			;            LD   A, kLCD_Line4  
6697			;            CALL fLCD_Pos       ;Position cursor to location in A  
6697			;		push de  
6697			;            LD   DE, keyscan_table  
6697			;            CALL fLCD_Str       ;Display string pointed to by DE  
6697			;		pop de  
6697			;	endif  
6697			  
6697				; scan key matrix table for any held key  
6697			  
6697				; de holds either the default matrix or one selected above  
6697			  
6697			;	ld hl, keyscan_table  
6697			;	ld b,key_cols*key_rows  
6697			;  
6697			;.cin1:	ld a,(hl)  
6697			;	cp '#'  
6697			;	jr z, .cinhit  
6697			;	inc hl  
6697			;	inc de  
6697			;	dec b  
6697			;	jr nz, .cin1  
6697			;	; no key found held  
6697			;	ld a,0  
6697			;	ret  
6697			;.cinhit: push de  
6697			;	pop hl  
6697			;	ld a,(hl)  
6697			;	ret  
6697			  
6697			; flag a control key is held   
6697			; hl is key pin, de is flag indicator  
6697			  
6697			;.key_shift_hold:  
6697			;	push bc  
6697			;	ld a, 1  
6697			;	ld (cursor_shape),a  
6697			;	ld b, 0  
6697			;	ld a, (hl)  
6697			;	cp '.'  
6697			;	jr z, .key_shift1  
6697			;	ld b, 255  
6697			;	ld a, '+'    ; hide key from later scans  
6697			;	ld (hl),a  
6697			;	ld a, 2  
6697			;	ld (cursor_shape),a  
6697			;.key_shift1:  
6697			;	; write flag indicator  
6697			;	ld a,b  
6697			;	ld (de),a  
6697			;  
6697			;	pop de    ; de now holds the key map ptr  
6697			;	ret  
6697			  
6697				  
6697				  
6697			  
6697			  
6697			  
6697			  
6697			  
6697			  
6697			  
6697			  
6697			  
6697			  
6697			  
6697			;	push hl  
6697			;	push de  
6697			;	push bc  
6697			;	call keyscan  
6697			;	; map key matrix to ascii value of key face  
6697			;  
6697			;	ld hl, key_face_map  
6697			;	ld de, keyscan_table  
6697			;  
6697			;	; get how many keys to look at  
6697			;	ld b, keyscan_table_len  
6697			;	  
6697			;  
6697			;	; at this stage fall out on first key hit  
6697			;	; TODO handle multiple key press  
6697			;  
6697			;map1:	ld a,(hl)  
6697			;	cp '#'  
6697			;	jr z, keyhit  
6697			;	inc hl  
6697			;	inc de  
6697			;	dec b  
6697			;	jr nz, map1  
6697			;nohit:	ld a, 0  
6697			;	jr keydone  
6697			;keyhit: push de  
6697			;	pop hl  
6697			;	ld a,(hl)  
6697			;keydone:  
6697			;	push bc  
6697			;	push de  
6697			; 	push hl  
6697			;	ret   
6697			;  
6697			  
6697			  
6697			  
6697			  
6697			; scan physical key matrix  
6697			  
6697			  
6697			;keyscan:  
6697			;  
6697			;; for each key_row use keyscanr bit mask for out  
6697			;; then read in for keyscanc bitmask  
6697			;; save result of row scan to keyscantable  
6697			;  
6697			;; scan keyboard row 1  
6697			;  
6697			;	ld b, key_rows  
6697			;	ld hl, key_scanr  
6697			;	ld de, keyscan_table  
6697			;  
6697			;rowloop:  
6697			;  
6697			;	ld a,(hl)		; out bit mask to energise keyboard row  
6697			;	call rowscan  
6697			;	inc hl  
6697			;	dec b  
6697			;	jr nz, rowloop  
6697			;  
6697			;	ret  
6697			;  
6697			;  
6697			;; pass a out bitmask, b row number  
6697			;arowscan:   
6697			;	push bc  
6697			;  
6697			;	ld d, b  
6697			;  
6697			;	; calculate buffer location for this row  
6697			;  
6697			;	ld hl, keyscan_table	  
6697			;kbufr:  ld e, key_cols  
6697			;kbufc:	inc hl  
6697			;	dec e  
6697			;	jr nz, kbufc  
6697			;	dec d  
6697			;	jr nz, kbufr  
6697			;  
6697			;	; energise row and read columns  
6697			;  
6697			;	out (portbdata),a  
6697			;	in a,(portbdata)  
6697			;	ld c,a  
6697			;  
6697			;  
6697			;	; save buffer loc  
6697			;  
6697			;	ld (keybufptr), hl  
6697			;  
6697			;	ld hl, key_scanc  
6697			;	ld d, key_cols  
6697			;  
6697			;	; for each column check each bit mask  
6697			;  
6697			;colloop:  
6697			;	  
6697			;  
6697			;	; reset flags for the row   
6697			;  
6697			;	ld b,'.'  
6697			;	and (hl)  
6697			;	jr z, maskskip  
6697			;	ld b,'#'  
6697			;maskskip:  
6697			;	; save  key state  
6697			;	push hl  
6697			;	ld hl, (keybufptr)  
6697			;	ld (hl), b  
6697			;	inc hl  
6697			;	ld (keybufptr), hl  
6697			;  
6697			;	; move to next bit mask  
6697			;	pop hl  
6697			;	inc hl  
6697			;  
6697			;	dec d  
6697			;	jr nz, colloop  
6697			;  
6697			;	ret  
6697			;  
6697			;  
6697			;;  
6697			; lcd functions  
6697			;  
6697			;  
6697			  
6697			;if DEBUG_KEY_MATRIX  
6697			  
6697			; test function to display hardware view of matrix state  
6697			  
6697			matrixold:  
6697			  
6697			  
6697			  
6697			; reset counter  
6697 3e 80		ld a, 128  
6699 d3 c1		out (portbdata),a  
669b			; scan keyboard row 1  
669b 3e 00		ld a, 0  
669d d3 c1		out (portbdata),a  
669f			;ld a, 64  
669f			;out (portbdata),a  
669f 3e 80			ld a, 128  
66a1 21 f2 fb			ld hl, keyscan_table_row1  
66a4 cd fd 66			call .rowscan  
66a7			  
66a7			;ld a, 0  
66a7			;out (portbdata),a  
66a7 3e 40		ld a, 64  
66a9 d3 c1		out (portbdata),a  
66ab 3e 40			ld a, 64  
66ad 21 e7 fb			ld hl, keyscan_table_row2  
66b0 cd fd 66			call .rowscan  
66b3			  
66b3 3e 00		ld a, 0  
66b5 d3 c1		out (portbdata),a  
66b7			;ld a, 64  
66b7			;out (portbdata),a  
66b7 3e 20			ld a, 32  
66b9 21 dc fb			ld hl, keyscan_table_row3  
66bc cd fd 66			call .rowscan  
66bf			  
66bf			;ld a, 0  
66bf			;out (portbdata),a  
66bf 3e 40		ld a, 64  
66c1 d3 c1		out (portbdata),a  
66c3 3e 10			ld a, 16  
66c5 21 d1 fb			ld hl, keyscan_table_row4  
66c8 cd fd 66			call .rowscan  
66cb			  
66cb			; Display text on first line  
66cb 3e 00		            LD   A, kLCD_Line1  
66cd cd 05 63		            CALL fLCD_Pos       ;Position cursor to location in A  
66d0 11 f2 fb		            LD   DE, keyscan_table_row1  
66d3			            ;LD   DE, MsgHello  
66d3 cd 27 63		            CALL fLCD_Str       ;Display string pointed to by DE  
66d6			  
66d6			; Display text on second line  
66d6 3e 28		            LD   A, kLCD_Line2  
66d8 cd 05 63		            CALL fLCD_Pos       ;Position cursor to location in A  
66db 11 e7 fb		            LD   DE, keyscan_table_row2  
66de cd 27 63		            CALL fLCD_Str       ;Display string pointed to by DE  
66e1 3e 50		            LD   A, kLCD_Line3  
66e3 cd 05 63		            CALL fLCD_Pos       ;Position cursor to location in A  
66e6 11 dc fb		            LD   DE, keyscan_table_row3  
66e9 cd 27 63		            CALL fLCD_Str       ;Display string pointed to by DE  
66ec 3e 78		            LD   A, kLCD_Line4  
66ee cd 05 63		            CALL fLCD_Pos       ;Position cursor to location in A  
66f1 11 d1 fb		            LD   DE, keyscan_table_row4  
66f4 cd 27 63		            CALL fLCD_Str       ;Display string pointed to by DE  
66f7			  
66f7 cd 31 0a			call delay250ms  
66fa c3 e8 65			jp matrix  
66fd			  
66fd			; pass de as row display flags  
66fd			.rowscan:   
66fd			;	out (portbdata),a  
66fd db c1			in a,(portbdata)  
66ff 4f				ld c,a  
6700				; reset flags for the row   
6700 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6702 e6 01			and 1  
6704 28 02			jr z, .p1on  
6706 06 23			ld b,'#'  
6708			.p1on:  
6708 70				ld (hl), b  
6709 23				inc hl  
670a			  
670a 06 7e			ld b,KEY_MATRIX_NO_PRESS  
670c 79				ld a,c  
670d e6 02			and 2  
670f			;	bit 0,a  
670f 28 02			jr z, .p2on  
6711 06 23			ld b,'#'  
6713			.p2on:  
6713 70				ld (hl), b  
6714 23				inc hl  
6715			;  
6715 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6717 79				ld a,c  
6718 e6 04			and 4  
671a			;;	bit 0,a  
671a 28 02			jr z, .p3on  
671c 06 23			ld b,'#'  
671e			.p3on:  
671e 70				ld (hl), b  
671f 23				inc hl  
6720			;;  
6720 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6722			;;	bit 0,a  
6722 79				ld a,c  
6723 e6 08			and 8  
6725 28 02			jr z, .p4on  
6727 06 23			ld b,'#'  
6729			.p4on:  
6729 70				ld (hl), b  
672a 23				inc hl  
672b			  
672b 06 7e			ld b,KEY_MATRIX_NO_PRESS  
672d			;;	bit 0,a  
672d 79				ld a,c  
672e e6 10			and 16  
6730 28 02			jr z, .p5on  
6732 06 23			ld b,'#'  
6734			.p5on:  
6734 70				ld (hl), b  
6735 23				inc hl  
6736			; zero term  
6736 06 00			ld b,0  
6738 70				ld (hl), b  
6739			  
6739 c9			.rscandone: ret  
673a			  
673a			;addatohl:  
673a			;  
673a			 ;add   a, l    ; A = A+L  
673a			  ;  ld    l, a    ; L = A+L  
673a			   ; adc   a, h    ; A = A+L+H+carry  
673a			   ; sub   l       ; A = H+carry  
673a			   ; ld    h, a    ; H = H+carry  
673a			  
673a			;ret  
673a			; eof  
# End of file firmware_key_5x10.asm
673a			;include "firmware_key_4x10.asm" 
673a			 
673a			heap_size:    equ heap_end - heap_start 
673a			;eof 
# End of file os_mega.asm
673a
