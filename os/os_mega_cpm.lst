# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 02 16			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			;        nop  
0103			;        nop 
0103			;;	org 05h		; null out bdos call 
0103			; 
0103			;        nop  
0103			;        nop  
0103			;        nop 
0103			;;	org 08h 
0103			;;; 
0103			;;	jp cin		; rst 8 - char in 
0103			;;; 
0103			; 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;	org 010h 
0103			;; 
0103			;	jp cout		; rest 010h  - char out 
0103			;; 
0103			;	org 01bh   
0103			; 
0103			;	;jp  		; rst 01bh   - write string to display 
0103			;	jp str_at_display 
0103			; 
0103			; 
0103			;	org 020h 
0103			; 
0103			;	; jp		 ; rst 020h - read char at screen location 
0103			; 
0103			;	org 028h 
0103			 
0103				; jp		 ; rst 028h  - storage i/o 
0103			 
0103			; 	org 030h 
0103			;	jp break_point_state 
0103			  
0103			; $30  
0103			; org 038h 
0103			; $38 
0103			 
0103			; TODO any more important entry points to add to jump table for easier coding use? 
0103			 
0103			 
0103			include "firmware.asm" 
0103			  
0103			; main constants (used here and in firmware)  
0103			  
0103			; TODO have page 0 of storage as bios  
0103			  
0103			Device_A: equ 0h  
0103			Device_B: equ 040h          ; Sound  
0103			  
0103			if BASE_KEV  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_SC114  
0103			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			; TODO fixup for CPM  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			Device_D: equ 0c0h             ; Keyboard and LCD  
0103			  
0103			; Odd specific debug points for testing hardware dev  
0103			  
0103			DEBUG_SOUND: equ 1  
0103			DEBUG_STK_FAULT: equ 0  
0103			DEBUG_INPUT: equ 0     ; Debug input entry code  
0103			DEBUG_KEYCINWAIT: equ 0  
0103			DEBUG_KEYCIN: equ 0  
0103			DEBUG_KEY: equ 0  
0103			DEBUG_KEY_MATRIX: equ 0  
0103			DEBUG_STORECF: equ 0  
0103			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0103			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0103			DEBUG_SPI: equ 0    ; low level spi tests  
0103			  
0103			; Enable many break points  
0103			  
0103			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0103			DEBUG_FORTH_JP: equ 0    ; 4  
0103			DEBUG_FORTH_MALLOC: equ 0  
0103			DEBUG_FORTH_MALLOC_INT: equ 0  
0103			DEBUG_FORTH_DOT: equ 0  
0103			DEBUG_FORTH_DOT_WAIT: equ 0  
0103			DEBUG_FORTH_MATHS: equ 0  
0103			DEBUG_FORTH_TOK: equ 0    ; 4  
0103			DEBUG_FORTH_PARSE: equ 0    ; 3  
0103			DEBUG_FORTH: equ 0  ;2  
0103			DEBUG_FORTH_WORDS: equ 1   ; 1  
0103			DEBUG_FORTH_PUSH: equ 1   ; 1  
0103			DEBUG_FORTH_UWORD: equ 1   ; 1  
0103			  
0103			; Enable key point breakpoints  
0103			  
0103			DEBUG_FORTH_DOT_KEY: equ 0  
0103			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0103			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0103			  
0103			; Debug stack imbalances  
0103			  
0103			ON: equ 1  
0103			OFF: equ 0  
0103			  
0103			DEBUG_STACK_IMB: equ 0  
0103			STACK_IMB_STORE: equ 20  
0103			  
0103			; House keeping and protections  
0103			  
0103			DEBUG_FORTH_STACK_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0103			FORTH_ENABLE_FREE: equ 0  
0103			FORTH_ENABLE_MALLOCFREE: equ 1  
0103			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0103			FORTH_ENABLE_FLOATMATH: equ 0  
0103			  
0103			  
0103			CALLMONITOR: macro  
0103				call break_point_state  
0103				endm  
0103			  
0103			MALLOC_1: equ 1        ; from dk88   
0103			MALLOC_2: equ 0           ; broke  
0103			MALLOC_3: equ 0           ; really broke  
0103			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0103			  
0103			if BASE_KEV   
0103			stacksize: equ 512*2  
0103			  
0103			STACK_RET_SIZE: equ 128  
0103			STACK_LOOP_SIZE: equ 512  
0103			STACK_DATA_SIZE: equ 512  
0103			endif  
0103			if BASE_SC114  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			;if STORAGE_SE == 0  
0103			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0103			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0103			;endif  
0103			  
0103			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0103			  
0103			STORE_0_AUTOFILE: equ $21  
0103			STORE_0_BANKRUN: equ $23  
0103			STORE_0_FILERUN: equ $24  
0103			  
0103			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0103			  
0103			STORE_0_AUTORUN: equ $20  
0103			  
0103			; Blocks where directory table is held  
0103			  
0103			; Reducing the number of entries increases the max file size  
0103			  
0103			;STORE_DIR_START: equ 1  
0103			;STORE_DIR_END: equ 33  
0103			  
0103			; Blocks from where file data is stored  
0103			  
0103			;STORE_DATA_START: equ STORE_DIR_END + 1  
0103			  
0103			; Block indicators (<32 are data files)  
0103			  
0103			;STORE_BLOCK_CFG: equ $8f       ; config block  
0103			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0103			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0103			;STORE_BLOCK_FREE: equ $85       ; data block free  
0103			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0103			  
0103			  
0103			  
0103			; Directory entry flags  
0103			  
0103			;STORE_DIR_FREE: equ 0  
0103			;STORE_DIR_FILE:  equ 1  
0103			  
0103			; Structure offsets to directory entries  
0103			;STORE_DE_FLAG: equ 0  
0103			;STORE_DE_MAXEXT: equ 1  
0103			;STORE_DE_FILENAME: equ 2  
0103			  
0103			; Structure offsets to block 0  
0103			  
0103			;STORE_BK0_ISFOR: equ 1  
0103			;STORE_BK0_LABEL: equ 3  
0103			  
0103			; memory allocation   
0103			  
0103			chk_stund: equ tos+2           ; underflow check word  
0103			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0103			  
0103			; keyscan table needs rows x cols buffer  
0103			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0103			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0103			  
0103			keyscan_table_row1: equ chk_stovr -key_cols-1  
0103			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0103			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0103			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0103			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0103			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0103			keyscan_scancol: equ keyscan_table-key_cols  
0103			;keyscan_table_len: equ key_rows*key_cols  
0103			;keybufptr: equ keyscan_table - 2  
0103			;keysymbol: equ keybufptr - 1  
0103			key_held: equ keyscan_scancol-1	; currently held  
0103			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0103			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0103			key_fa: equ key_repeat_ct -1 ;  
0103			key_fb: equ key_fa -1 ;  
0103			key_fc: equ key_fb -1 ;  
0103			key_fd: equ key_fc -1 ;  
0103			key_face_held: equ key_fd - 1   
0103			  
0103			; flag for enabling/disabling various hardware diags   
0103			  
0103			hardware_diag: equ key_face_held - 1  
0103			  
0103			; hardware config switches  
0103			; TODO add bitmasks on includes for hardware  
0103			; high byte for expansion ids  
0103			;     0000 0000  no card inserted  
0103			;     0000 0001  storage card inserted  
0103			;     0000 0010  spi sd card active  
0103			  
0103			;       
0103			; low byte:  
0103			;     0000 0001   4x4 keypad  
0103			;     0000 0010   full keyboard  
0103			;     0000 0011   spi/ext keyboard  
0103			;     0000 0100   20x4 lcd  
0103			;     0000 1000   40x4 lcd  
0103			;     0000 1100   spi/ext display  
0103			;     0001 0000   ide interface available  
0103			  
0103			hardware_word: equ hardware_diag - 2  
0103			  
0103			; debug marker - optional display of debug point on the debug screens  
0103			  
0103			debug_mark: equ hardware_word - 4  
0103			  
0103			; input_str vars  
0103			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0103			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0103			input_size: equ input_start -1  ; number of chars  
0103			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0103			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0103			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0103			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0103			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0103			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0103			input_len: equ input_cur_onoff - 5 ; length of current input  
0103			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0103			  
0103			CUR_BLINK_RATE: equ 15  
0103			  
0103			key_actual_pressed: equ input_cursor - 1   
0103			key_symbol: equ key_actual_pressed - 1   
0103			key_shift: equ key_symbol - 1   
0103			  
0103			; Display allocation  
0103			  
0103			;display_rows: equ 4     ; move out to mini and mega files  
0103			;display_cols: equ 20  
0103			  
0103			display_fb_len: equ display_rows*display_cols  
0103			  
0103			; primary frame buffer     
0103			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0103			; working frame buffers  
0103			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0103			display_fb3: equ  display_fb1-display_fb_len - 1  
0103			display_fb2: equ  display_fb3-display_fb_len - 1  
0103			;  
0103			; pointer to active frame buffer  
0103			display_fb_active: equ display_fb2 - 2  
0103			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0103			display_write_tmp: equ display_lcde1e2 - 2  
0103			  
0103			  
0103			;  
0103			  
0103			;; can load into de directory  
0103			cursor_col: equ display_write_tmp-1  
0103			cursor_row: equ cursor_col-1  
0103			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0103			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0103			  
0103			; maths vars  
0103			  
0103			LFSRSeed: equ cursor_shape -20   
0103			randData: equ LFSRSeed - 2  
0103			xrandc: equ randData - 2  
0103			stackstore: equ xrandc - 2  
0103			seed1: equ  stackstore -2   
0103			seed2: equ seed1 - 2  
0103			  
0103			; cf storage vars  
0103			  
0103			iErrorNum:  equ seed2-1         ;Error number  
0103			iErrorReg:  equ iErrorNum -1              ;Error register  
0103			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0103			  
0103			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0103			  
0103			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0103			  
0103			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0103			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0103			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0103			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0103			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0103			store_tmpid: equ store_tmp3 - 1		; page temp id  
0103			store_tmpext: equ store_tmpid - 1		; file extent temp  
0103			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0103			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0103			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0103			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0103			;  
0103			; spi vars  
0103			  
0103			  
0103			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0103			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0103			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0103			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0103			spi_device_id: equ spi_device - 1    ; human readable bank number  
0103			  
0103			;;;;; forth cli params  
0103			  
0103			; TODO use a different frame buffer for forth???  
0103			  
0103			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0103			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0103			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0103			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0103			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0103			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0103			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0103			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0103			  
0103			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0103			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0103			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0103			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0103			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0103			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0103			  
0103			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0103			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0103			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0103			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0103			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0103			  
0103			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0103			  
0103			; os/forth token vars  
0103			  
0103			os_last_cmd: equ os_var_array-255  
0103			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0103			os_current_i: equ os_cli_cmd-2  
0103			os_cur_ptr: equ os_current_i-2  
0103			os_word_scratch: equ os_cur_ptr-30  
0103			os_tok_len: equ os_word_scratch - 2  
0103			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0103			os_tok_malloc: equ os_tok_ptr - 2  
0103			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0103			os_input: equ os_last_new_uword-255  
0103			execscratch: equ os_input-255        ; exec cmd eval buffer  
0103			scratch: equ execscratch-255  
0103			  
0103			  
0103			; temp locations for new word processing to save on adding more   
0103			  
0103			os_new_malloc: equ scratch-2  
0103			os_new_parse_len: equ os_new_malloc - 2  
0103			os_new_word_len: equ os_new_parse_len - 2  
0103			os_new_work_ptr: equ os_new_word_len - 2  
0103			os_new_src_ptr: equ os_new_work_ptr - 2  
0103			os_new_exec: equ os_new_src_ptr - 2  
0103			os_new_exec_ptr: equ os_new_exec - 2  
0103			  
0103			; resume memory alloocations....  
0103			  
0103			os_view_disable: equ os_new_exec_ptr - 1  
0103			os_view_af: equ os_view_disable - 2  
0103			os_view_hl: equ os_view_af -2  
0103			os_view_de: equ os_view_hl - 2  
0103			os_view_bc: equ os_view_de - 2  
0103			  
0103			; stack checksum word  
0103			if DEBUG_STACK_IMB  
0103				curframe: equ  os_view_de - 5  
0103				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0103				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			else  
0103				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			endif  
0103			  
0103			; with data stack could see memory filled with junk. need some memory management   
0103			; malloc and free entry points added  
0103			  
0103			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0103			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			;heap_end: equ free_list-1  ; Starting address of heap  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			heap_end: equ chk_word-1  ; Starting address of heap  
0103			  
0103			  
0103			;if BASE_KEV   
0103			;heap_start: equ 0800eh  ; Starting address of heap  
0103			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;heap_start: equ baseram+15  ; Starting address of heap  
0103			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;endif  
0103			  
0103			  
0103			;;;;  
0103			  
0103			  
0103			; change below to point to last memory alloc above  
0103			topusermem:  equ   heap_start  
0103			  
0103			;if BASE_KEV   
0103			;baseusermem: equ 08000h  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;;aseusermem:     equ    12  
0103			;baseusermem:     equ    prompt  
0103			;;baseusermem:     equ    endofcode  
0103			;endif  
0103			  
0103			  
0103			; **********************************************************************  
0103			; **  Constants  
0103			; **********************************************************************  
0103			  
0103			; Constants used by this code module  
0103			kDataReg:   EQU Device_D           ;PIO port A data register  
0103			kContReg:   EQU Device_D+2           ;PIO port A control register  
0103			  
0103			  
0103			portbdata:  equ Device_D+1    ; port b data  
0103			portbctl:   equ Device_D+3    ; port b control  
0103			  
0103			  
0103			;KEY_SHIFT:   equ 5  
0103			;KEY_SYMBOLSHIFT:  equ 6  
0103			  
0103			KEY_SHIFTLOCK: equ 4  
0103			  
0103			  
0103			KEY_UP: equ 5  
0103			KEY_NEXTWORD: equ 6  
0103			KEY_PREVWORD: equ 7  
0103			KEY_BS: equ 8  
0103			KEY_TAB:  equ 9  
0103			KEY_DOWN: equ 10  
0103			KEY_LEFT: equ 11  
0103			KEY_RIGHT: equ 12  
0103			KEY_CR:   equ 13  
0103			KEY_HOME: equ 14  
0103			KEY_END: equ 15  
0103			  
0103			KEY_F1: equ 16  
0103			KEY_F2: equ 17  
0103			KEY_F3: equ 18  
0103			KEY_F4: equ 19  
0103			  
0103			KEY_F5: equ 20  
0103			KEY_F6: equ 21  
0103			KEY_F7: equ 22  
0103			KEY_F8: equ 23  
0103			  
0103			KEY_F9: equ 24  
0103			KEY_F10: equ 25  
0103			KEY_F11: equ 26  
0103			KEY_F12: equ 27  
0103			  
0103			;if DEBUG_KEY  
0103			;	KEY_MATRIX_NO_PRESS: equ '.'  
0103			;	KEY_SHIFT:   equ '.'  
0103			;	KEY_SYMBOLSHIFT:  equ '.'  
0103			;else  
0103				KEY_SHIFT:   equ '~'  
0103				KEY_SYMBOLSHIFT:  equ '~'  
0103				KEY_MATRIX_NO_PRESS: equ '~'  
0103			;endi  
0103			  
0103			  
0103			  
0103			  
0103			; Macro to make adding debug marks easier  
0103			  
0103			DMARK: macro str  
0103				push af  
0103				ld a, (.dmark)  
0103				ld (debug_mark),a  
0103				ld a, (.dmark+1)  
0103				ld (debug_mark+1),a  
0103				ld a, (.dmark+2)  
0103				ld (debug_mark+2),a  
0103				jr .pastdmark  
0103			.dmark: db str  
0103			.pastdmark: pop af  
0103			  
0103			endm  
0103			  
0103			  
0103			; macro to detect for stack imbalances  
0103			  
0103			include "stackimbal.asm"  
0103			; Macro and code to detect stock imbalances 
0103			 
0103			SPPUSH: equ 0 
0103			 
0103			; Add a stack frame which can be checked before return 
0103			 
0103			STACKFRAME: macro onoff frame1 frame2 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103						exx 
0103			 
0103						ld de, frame1 
0103						ld a, d 
0103						ld hl, curframe 
0103						call hexout 
0103						ld a, e 
0103						ld hl, curframe+2 
0103						call hexout 
0103			  
0103						ld hl, frame1 
0103						push hl 
0103						ld hl, frame2 
0103						push hl 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			endm 
0103			 
0103			STACKFRAMECHK: macro onoff frame1 frame2 
0103			 
0103					 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						exx 
0103						; check stack frame SP 
0103			 
0103						ld hl, frame2 
0103						pop de   ; frame2 
0103			 
0103						call cmp16 
0103						jr nz, .spnosame 
0103						 
0103			 
0103						ld hl, frame1 
0103						pop de   ; frame1 
0103			 
0103						call cmp16 
0103						jr z, .spfrsame 
0103			 
0103						.spnosame: call showsperror 
0103			 
0103						.spfrsame: nop 
0103			 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			 
0103			 
0103			endm 
0103			 
0103			 
0103			; for a sub routine, wrap SP collection and comparisons 
0103			 
0103			; Usage: 
0103			; 
0103			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0103			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0103			 
0103			SAVESP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103			 
0103						ld (store_sp+(storeword*4)), sp 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			CHECKSP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103			 
0103						; save SP after last save 
0103				 
0103						ld (store_sp+(storeword*4)+2), sp 
0103			 
0103						push hl 
0103						ld hl, store_sp+(storeword*4) 
0103						call check_stack_sp  
0103						pop hl 
0103			 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			if DEBUG_STACK_IMB 
0103			 
0103			check_stack_sp: 
0103					push de 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					push de 
0103			 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					pop hl 
0103			 
0103			 
0103					; check to see if the same 
0103			 
0103					call cmp16 
0103					jr z, .spsame 
0103			 
0103					; not same 
0103			 
0103					call showsperror 
0103			.spsame: 
0103			 
0103					pop de 
0103			 
0103					ret 
0103			 
0103			.sperr:  db "Stack imbalance",0 
0103			 
0103			 
0103			showsperror: 
0103			 
0103			 
0103				push hl 
0103				push af 
0103				push de 
0103				call clear_display 
0103				ld de, .sperr 
0103				ld a,0 
0103			;	ld de,os_word_scratch 
0103				call str_at_display 
0103				ld a, display_row_1+17 
0103				ld de, debug_mark 
0103				call str_at_display 
0103				ld a, 0 
0103				ld (curframe+4),a 
0103				ld hl, curframe 
0103				ld de, os_word_scratch 
0103				ld a, display_row_4 
0103				call str_at_display 
0103				call update_display 
0103				;call break_point_state 
0103				call cin_wait 
0103			 
0103				ld a, ' ' 
0103				ld (os_view_disable), a 
0103				pop de	 
0103				pop af 
0103				pop hl 
0103				CALLMONITOR 
0103				ret 
0103			 
0103			endif 
0103			 
0103			 
0103			 
0103			; eof 
# End of file stackimbal.asm
0103			  
0103			;TODO macro to calc col and row offset into screen  
0103			  
0103			  
0103			  
0103			hardware_init:  
0103			  
0103 3e 00				ld a, 0  
0105 32 80 ee				ld (hardware_diag), a  
0108			  
0108					; clear all the buffers  
0108			  
0108 21 1f ed				ld hl, display_fb1  
010b 22 db eb				ld (display_fb_active), hl  
010e			  
010e cd 85 09				call clear_display  
0111			  
0111 21 dd eb				ld hl, display_fb2  
0114 22 db eb				ld (display_fb_active), hl  
0117			  
0117 cd 85 09				call clear_display  
011a			  
011a					; init primary frame buffer area  
011a 21 c0 ed				ld hl, display_fb0  
011d 22 db eb				ld (display_fb_active), hl  
0120			  
0120 cd 85 09				call clear_display  
0123			  
0123			  
0123 cd 86 57				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0126			  
0126 cd 74 58			call key_init  
0129 cd b0 01			call storage_init  
012c			  
012c				; setup malloc functions  
012c			  
012c				if MALLOC_1  
012c cd 55 10				call  heap_init  
012f				endif  
012f				if MALLOC_4  
012f					call  heap_init  
012f				endif  
012f			  
012f				; init sound hardware if present  
012f			  
012f				if SOUND_ENABLE  
012f					call sound_init  
012f				endif  
012f			  
012f				; lcd test sequence  
012f					  
012f cd a8 09			call update_display  
0132 cd fa 08			call delay1s  
0135 3e 2b			ld a,'+'  
0137 cd 8a 09			call fill_display  
013a cd a8 09			call update_display  
013d cd fa 08			call delay1s  
0140 3e 2a			ld a,'*'  
0142 cd 8a 09			call fill_display  
0145 cd a8 09			call update_display  
0148 cd fa 08			call delay1s  
014b 3e 2d			ld a,'-'  
014d cd 8a 09			call fill_display  
0150 cd a8 09			call update_display  
0153 cd fa 08			call delay1s  
0156			  
0156			; boot splash screen  
0156			if display_cols == 20	  
0156			        ld a, display_row_1    
0156			else  
0156 3e 0a		        ld a, display_row_1 +10   
0158			endif  
0158 11 89 01			ld de, bootmsg  
015b cd 98 09			call str_at_display  
015e cd a8 09			call update_display  
0161			  
0161			  
0161 cd fa 08			call delay1s  
0164 cd fa 08			call delay1s  
0167			if display_cols == 20	  
0167			            LD   A, display_row_3+2  
0167			else  
0167 3e 5c		            LD   A, display_row_3+12  
0169			endif  
0169 11 9e 01			ld de, bootmsg1  
016c cd 98 09			call str_at_display  
016f cd a8 09			call update_display  
0172 cd fa 08			call delay1s  
0175 cd fa 08			call delay1s  
0178			  
0178			;	ld a, display_row_4+3  
0178			;	ld de, bootmsg2  
0178			;	call str_at_display  
0178			;	call update_display  
0178			;	call delay1s  
0178			;	call delay1s  
0178			  
0178			; debug mark setup  
0178			  
0178 3e 5f		ld a, '_'  
017a 32 7a ee		ld (debug_mark),a  
017d 32 7b ee		ld (debug_mark+1),a  
0180 32 7c ee		ld (debug_mark+2),a  
0183 3e 00		ld a,0  
0185 32 7d ee		ld (debug_mark+3),a  
0188			  
0188 c9					ret  
0189			  
0189			  
0189 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
019e .. 00		bootmsg1:	db "by Kevin Groves",0  
01ae			;bootmsg2:	db "Firmware v0.1",0  
01ae			  
01ae			; a 4x20 lcd  
01ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01ae			  
01ae			;if display_cols == 20  
01ae			;	include "firmware_lcd_4x20.asm"  
01ae			;endif  
01ae			  
01ae			;if display_cols == 40  
01ae			;	include "firmware_lcd_4x40.asm"  
01ae			;endif  
01ae			  
01ae			;  
01ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01ae			; TODO abstract the bit bang video out interface for dual display  
01ae			; TODO wire video out to tx pin on rc2014 bus  
01ae			  
01ae			; must supply cin, and cin_wait for low level hardware abstraction   
01ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01ae			; test scancode  
01ae			  
01ae			;;;;;  
01ae			;;;  
01ae			; Moved out to mini and maxi versions  
01ae			;  
01ae			; include "firmware_key_4x4.asm"  
01ae			; using existing 4 wire x 4 resistor array for input  
01ae			;include "firmware_key_4x10.asm"  
01ae			; need to mod the board for 5 rows due to resistor array  
01ae			;include "firmware_key_5x10.asm"  
01ae			  
01ae			; storage hardware interface  
01ae			  
01ae			; use microchip serial eeprom for storage  
01ae			  
01ae			  
01ae			if STORAGE_SE  
01ae				include "firmware_spi.asm"  
01ae				include "firmware_seeprom.asm"  
01ae			else  
01ae			   ; create some stubs for the labels  
01ae c9			se_readbyte: ret  
01af c9			se_writebyte: ret  
01b0 c9			storage_init: ret  
01b1			  
01b1			endif  
01b1			  
01b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01b1			;include "firmware_cf.asm"  
01b1			  
01b1			; load up high level storage hardward abstractions  
01b1			include "firmware_storage.asm"  
01b1			 
01b1			; persisent storage hardware abstraction layer  
01b1			 
01b1			 
01b1			 
01b1			; Block 0 on storage is a config state 
01b1			 
01b1			 
01b1			 
01b1			; TODO add read phy block and write phy block functions 
01b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01b1			 
01b1			; Abstraction layer  
01b1			 
01b1			; Logocial block size is same size as physical size - using tape concept 
01b1			 
01b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01b1			 
01b1			 
01b1			 
01b1			; Filesystem layout (Logical layout) 
01b1			; 
01b1			; Block 0 - Bank config  
01b1			; 
01b1			;      Byte - 0 file id counter 
01b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01b1			;      Byte - 3-20 zero terminated bank label 
01b1			; 
01b1			; Block 1 > File storage 
01b1			; 
01b1			;      Byte 0 file id    - block 0 file details 
01b1			;      Byte 1 block id - block 0 is file  
01b1			;            Byte 2-15 - File name 
01b1			; 
01b1			;       - to end of block data 
01b1			; 
01b1			 
01b1			 
01b1			; Read Block 
01b1			; ---------- 
01b1			; 
01b1			; With current bank 
01b1			;  
01b1			; Get block number to read 
01b1			; Load physical blocks starting at start block into buffer 
01b1			 
01b1			; de points to buffer to use 
01b1			; hl holds logical block number  
01b1			 
01b1			storage_read_block: 
01b1			 
01b1				; TODO bank selection 
01b1			 
01b1				; for each of the physical blocks read it into the buffer 
01b1 06 40			ld b, STORE_BLOCK_PHY 
01b3			 
01b3				if DEBUG_STORESE 
01b3 d5					push de 
01b4				endif 
01b4				 
01b4			.rl1:    
01b4			 
01b4				; read physical block at hl into de 
01b4			        ; increment hl and de to next read position on exit 
01b4			 
01b4 e5				push hl 
01b5 d5				push de	 
01b6 c5				push bc 
01b7			;	if DEBUG_STORESE 
01b7			;		push af 
01b7			;		ld a, 'R' 
01b7			;		ld (debug_mark),a 
01b7			;		pop af 
01b7			;		CALLMONITOR 
01b7			;	endif 
01b7 cd ae 01			call se_readbyte 
01ba			;	if DEBUG_STORESE 
01ba			;		ld a,(spi_portbyte) 
01ba			;		ld l, a 
01ba			;		push af 
01ba			;		ld a, '1' 
01ba			;		ld (debug_mark),a 
01ba			;		pop af 
01ba			;		CALLMONITOR 
01ba			;	endif 
01ba c1				pop bc 
01bb d1				pop de 
01bc e1				pop hl 
01bd 12				ld (de),a 
01be 23				inc hl 
01bf 13				inc de 
01c0			 
01c0			;	if DEBUG_STORESE 
01c0			;		push af 
01c0			;		ld a, 'r' 
01c0			;		ld (debug_mark),a 
01c0			;		pop af 
01c0			;		CALLMONITOR 
01c0			;	endif 
01c0			 
01c0 10 f2			djnz .rl1 
01c2			 
01c2				if DEBUG_STORESE 
01c2					DMARK "SRB" 
01c2 f5				push af  
01c3 3a d7 01			ld a, (.dmark)  
01c6 32 7a ee			ld (debug_mark),a  
01c9 3a d8 01			ld a, (.dmark+1)  
01cc 32 7b ee			ld (debug_mark+1),a  
01cf 3a d9 01			ld a, (.dmark+2)  
01d2 32 7c ee			ld (debug_mark+2),a  
01d5 18 03			jr .pastdmark  
01d7 ..			.dmark: db "SRB"  
01da f1			.pastdmark: pop af  
01db			endm  
# End of macro DMARK
01db d1					pop de 
01dc			; 
01dc			;		push af 
01dc			;		ld a, 'R' 
01dc			;		ld (debug_mark),a 
01dc			;		pop af 
01dc					CALLMONITOR 
01dc cd 2c 14			call break_point_state  
01df				endm  
# End of macro CALLMONITOR
01df				endif 
01df c9				ret	 
01e0				 
01e0			 
01e0			; File Size 
01e0			; --------- 
01e0			; 
01e0			;   hl file id 
01e0			; 
01e0			;  returns in hl the number of blocks 
01e0			 
01e0			storage_file_size: 
01e0 5d				ld e, l 
01e1 16 00			ld d, 0 
01e3 21 40 00			ld hl, STORE_BLOCK_PHY 
01e6					if DEBUG_FORTH_WORDS 
01e6						DMARK "SIZ" 
01e6 f5				push af  
01e7 3a fb 01			ld a, (.dmark)  
01ea 32 7a ee			ld (debug_mark),a  
01ed 3a fc 01			ld a, (.dmark+1)  
01f0 32 7b ee			ld (debug_mark+1),a  
01f3 3a fd 01			ld a, (.dmark+2)  
01f6 32 7c ee			ld (debug_mark+2),a  
01f9 18 03			jr .pastdmark  
01fb ..			.dmark: db "SIZ"  
01fe f1			.pastdmark: pop af  
01ff			endm  
# End of macro DMARK
01ff						CALLMONITOR 
01ff cd 2c 14			call break_point_state  
0202				endm  
# End of macro CALLMONITOR
0202					endif 
0202 cd d2 04			call storage_findnextid 
0205			 
0205 cd db 0b			call ishlzero 
0208			;	ld a, l 
0208			;	add h 
0208			;	cp 0 
0208 c8				ret z			; block not found so EOF 
0209			 
0209 11 65 eb			ld de, store_page 
020c cd b1 01			call storage_read_block 
020f			 
020f 3a 67 eb			ld a, (store_page+2)	 ; get extent count 
0212 6f				ld l, a 
0213 26 00			ld h, 0 
0215 c9			 	ret 
0216			 
0216			 
0216			; Write Block 
0216			; ----------- 
0216			; 
0216			; With current bank 
0216			;  
0216			; Get block number to write 
0216			; Write physical blocks starting at start block from buffer 
0216			  
0216			storage_write_block: 
0216				; TODO bank selection 
0216			 
0216				; for each of the physical blocks read it into the buffer 
0216 06 40			ld b, STORE_BLOCK_PHY 
0218			 
0218				if DEBUG_STORESE 
0218					DMARK "SWB" 
0218 f5				push af  
0219 3a 2d 02			ld a, (.dmark)  
021c 32 7a ee			ld (debug_mark),a  
021f 3a 2e 02			ld a, (.dmark+1)  
0222 32 7b ee			ld (debug_mark+1),a  
0225 3a 2f 02			ld a, (.dmark+2)  
0228 32 7c ee			ld (debug_mark+2),a  
022b 18 03			jr .pastdmark  
022d ..			.dmark: db "SWB"  
0230 f1			.pastdmark: pop af  
0231			endm  
# End of macro DMARK
0231			 
0231					;push af 
0231					;ld a, 'W' 
0231					;ld (debug_mark),a 
0231					;pop af 
0231					CALLMONITOR 
0231 cd 2c 14			call break_point_state  
0234				endm  
# End of macro CALLMONITOR
0234				endif 
0234			 
0234			; might not be working 
0234			;	call se_writepage 
0234			 
0234			;	ret 
0234			; 
0234			 
0234			 
0234			 
0234			.wl1:    
0234			 
0234				; read physical block at hl into de 
0234			        ; increment hl and de to next read position on exit 
0234			 
0234 e5				push hl 
0235 d5				push de	 
0236 c5				push bc 
0237 1a				ld a,(de) 
0238				;if DEBUG_STORESE 
0238			;		push af 
0238			;		ld a, 'W' 
0238			;		ld (debug_mark),a 
0238			;		pop af 
0238			;		CALLMONITOR 
0238			;	endif 
0238 cd af 01			call se_writebyte 
023b			;	call delay250ms 
023b 00				nop 
023c 00				nop 
023d 00				nop 
023e			;	if DEBUG_STORESE 
023e			;		push af 
023e			;		ld a, 'w' 
023e			;		ld (debug_mark),a 
023e			;		pop af 
023e			;		CALLMONITOR 
023e			;	endif 
023e c1				pop bc 
023f d1				pop de 
0240 e1				pop hl 
0241 23				inc hl 
0242 13				inc de 
0243			 
0243			 
0243 10 ef			djnz .wl1 
0245			 
0245				if DEBUG_STORESE 
0245					DMARK "SW2" 
0245 f5				push af  
0246 3a 5a 02			ld a, (.dmark)  
0249 32 7a ee			ld (debug_mark),a  
024c 3a 5b 02			ld a, (.dmark+1)  
024f 32 7b ee			ld (debug_mark+1),a  
0252 3a 5c 02			ld a, (.dmark+2)  
0255 32 7c ee			ld (debug_mark+2),a  
0258 18 03			jr .pastdmark  
025a ..			.dmark: db "SW2"  
025d f1			.pastdmark: pop af  
025e			endm  
# End of macro DMARK
025e			 
025e					;push af 
025e					;ld a, 'W' 
025e					;ld (debug_mark),a 
025e					;pop af 
025e					CALLMONITOR 
025e cd 2c 14			call break_point_state  
0261				endm  
# End of macro CALLMONITOR
0261				endif 
0261 c9				ret	 
0262			 
0262			; Init bank 
0262			; --------- 
0262			; 
0262			; With current bank 
0262			; 
0262			; Setup block 0 config 
0262			;     Set 0 file id counter 
0262			;     Set formatted byte pattern 
0262			;     Zero out bank label 
0262			;      
0262			; For every logical block write 0-1 byte as null 
0262			 
0262			storage_get_block_0: 
0262			 
0262				; TODO check presence 
0262			 
0262				; get block 0 config 
0262			 
0262 21 00 00			ld hl, 0 
0265 11 65 eb			ld de, store_page 
0268 cd b1 01			call storage_read_block 
026b			 
026b				if DEBUG_STORESE 
026b					DMARK "SB0" 
026b f5				push af  
026c 3a 80 02			ld a, (.dmark)  
026f 32 7a ee			ld (debug_mark),a  
0272 3a 81 02			ld a, (.dmark+1)  
0275 32 7b ee			ld (debug_mark+1),a  
0278 3a 82 02			ld a, (.dmark+2)  
027b 32 7c ee			ld (debug_mark+2),a  
027e 18 03			jr .pastdmark  
0280 ..			.dmark: db "SB0"  
0283 f1			.pastdmark: pop af  
0284			endm  
# End of macro DMARK
0284 11 65 eb				ld de, store_page 
0287			;		push af 
0287			;		ld a, 'i' 
0287			;		ld (debug_mark),a 
0287			;		pop af 
0287					CALLMONITOR 
0287 cd 2c 14			call break_point_state  
028a				endm  
# End of macro CALLMONITOR
028a				endif 
028a			 
028a				; is this area formatted? 
028a			 
028a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
028a 2a 66 eb			ld hl, (store_page+1) 
028d 3e 80			ld a,0x80 
028f bd				cp l 
0290 20 22			jr nz, .ininotformatted 
0292				; do a double check 
0292 3e 27			ld a, 0x27 
0294 bc				cp h 
0295 20 1d			jr nz, .ininotformatted 
0297			 
0297				; formatted then 
0297			 
0297				if DEBUG_STORESE 
0297					DMARK "SB1" 
0297 f5				push af  
0298 3a ac 02			ld a, (.dmark)  
029b 32 7a ee			ld (debug_mark),a  
029e 3a ad 02			ld a, (.dmark+1)  
02a1 32 7b ee			ld (debug_mark+1),a  
02a4 3a ae 02			ld a, (.dmark+2)  
02a7 32 7c ee			ld (debug_mark+2),a  
02aa 18 03			jr .pastdmark  
02ac ..			.dmark: db "SB1"  
02af f1			.pastdmark: pop af  
02b0			endm  
# End of macro DMARK
02b0					;push af 
02b0					;ld a, 'I' 
02b0					;ld (debug_mark),a 
02b0					;pop af 
02b0					CALLMONITOR 
02b0 cd 2c 14			call break_point_state  
02b3				endm  
# End of macro CALLMONITOR
02b3				endif 
02b3 c9				ret 
02b4			 
02b4			.ininotformatted: 
02b4				; bank not formatted so poke various bits to make sure 
02b4			 
02b4				if DEBUG_STORESE 
02b4					DMARK "SB2" 
02b4 f5				push af  
02b5 3a c9 02			ld a, (.dmark)  
02b8 32 7a ee			ld (debug_mark),a  
02bb 3a ca 02			ld a, (.dmark+1)  
02be 32 7b ee			ld (debug_mark+1),a  
02c1 3a cb 02			ld a, (.dmark+2)  
02c4 32 7c ee			ld (debug_mark+2),a  
02c7 18 03			jr .pastdmark  
02c9 ..			.dmark: db "SB2"  
02cc f1			.pastdmark: pop af  
02cd			endm  
# End of macro DMARK
02cd					;push af 
02cd					;ld a, 'f' 
02cd					;ld (debug_mark),a 
02cd					;pop af 
02cd					CALLMONITOR 
02cd cd 2c 14			call break_point_state  
02d0				endm  
# End of macro CALLMONITOR
02d0				endif 
02d0			 
02d0 cd bd 08			call storage_clear_page 
02d3			 
02d3 21 65 eb			ld hl, store_page 
02d6 3e 00			ld a, 0 
02d8				 
02d8 77				ld (hl),a   ; reset file counter 
02d9			 
02d9 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02dc 22 66 eb		 	ld (store_page+1), hl	 
02df			 
02df				; set default label 
02df			 
02df 21 7b 03			ld hl, .defaultbanklabl 
02e2 11 68 eb		 	ld de, store_page+3 
02e5 01 0f 00			ld bc, 15 
02e8 ed b0			ldir 
02ea			 
02ea				; Append the current bank id 
02ea 21 71 eb			ld hl, store_page+3+9 
02ed 3a 4a eb			ld a, (spi_device_id) 
02f0 77				ld (hl), a 
02f1			 
02f1				; save default page 0 
02f1			 
02f1 21 00 00			ld hl, 0 
02f4 11 65 eb			ld de, store_page 
02f7				if DEBUG_STORESE 
02f7					DMARK "SB3" 
02f7 f5				push af  
02f8 3a 0c 03			ld a, (.dmark)  
02fb 32 7a ee			ld (debug_mark),a  
02fe 3a 0d 03			ld a, (.dmark+1)  
0301 32 7b ee			ld (debug_mark+1),a  
0304 3a 0e 03			ld a, (.dmark+2)  
0307 32 7c ee			ld (debug_mark+2),a  
030a 18 03			jr .pastdmark  
030c ..			.dmark: db "SB3"  
030f f1			.pastdmark: pop af  
0310			endm  
# End of macro DMARK
0310			;		push af 
0310			;		ld a, 'F' 
0310			;		ld (debug_mark),a 
0310			;		pop af 
0310					CALLMONITOR 
0310 cd 2c 14			call break_point_state  
0313				endm  
# End of macro CALLMONITOR
0313				endif 
0313 cd 16 02			call storage_write_block 
0316				if DEBUG_STORESE 
0316					DMARK "SB4" 
0316 f5				push af  
0317 3a 2b 03			ld a, (.dmark)  
031a 32 7a ee			ld (debug_mark),a  
031d 3a 2c 03			ld a, (.dmark+1)  
0320 32 7b ee			ld (debug_mark+1),a  
0323 3a 2d 03			ld a, (.dmark+2)  
0326 32 7c ee			ld (debug_mark+2),a  
0329 18 03			jr .pastdmark  
032b ..			.dmark: db "SB4"  
032e f1			.pastdmark: pop af  
032f			endm  
# End of macro DMARK
032f			;		push af 
032f			;		ld a, '>' 
032f			;		ld (debug_mark),a 
032f			;		pop af 
032f					CALLMONITOR 
032f cd 2c 14			call break_point_state  
0332				endm  
# End of macro CALLMONITOR
0332				endif 
0332			 
0332 00				nop 
0333 00				nop 
0334 00				nop 
0335			 
0335				; now set 0 in every page to mark as a free block 
0335			 
0335 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0337 21 40 00			ld hl, STORE_BLOCK_PHY 
033a			 
033a 3e 00		.setmark1:   	ld a,0 
033c e5					push hl 
033d c5					push bc 
033e cd af 01				call se_writebyte 
0341 3e 0a			ld a, 10 
0343 cd df 08			call aDelayInMS 
0346 23				inc hl 
0347 cd af 01				call se_writebyte 
034a 3e 0a			ld a, 10 
034c cd df 08			call aDelayInMS 
034f 2b				dec hl 
0350 c1					pop bc 
0351 e1					pop hl 
0352 3e 40				ld a, STORE_BLOCK_PHY 
0354 cd b2 0b				call addatohl 
0357 10 e1				djnz .setmark1 
0359			 
0359 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
035b 3e 00		.setmark2:   	ld a,0 
035d e5					push hl 
035e c5					push bc 
035f cd af 01				call se_writebyte 
0362 3e 0a			ld a, 10 
0364 cd df 08			call aDelayInMS 
0367 23				inc hl 
0368 cd af 01				call se_writebyte 
036b 3e 0a			ld a, 10 
036d cd df 08			call aDelayInMS 
0370 2b				dec hl 
0371 c1					pop bc 
0372 e1					pop hl 
0373 3e 40				ld a, STORE_BLOCK_PHY 
0375 cd b2 0b				call addatohl 
0378 10 e1				djnz .setmark2 
037a			 
037a					 
037a			 
037a			 
037a c9				ret 
037b			 
037b			 
037b			 
037b			 
037b .. 00		.defaultbanklabl:   db "BankLabel_",0 
0386			 
0386			 
0386			 
0386			; Label Bank 
0386			; ---------- 
0386			; 
0386			; With current bank 
0386			; Read block 0 
0386			; Set label 
0386			; Write block 0 
0386			 
0386			; label str pointer in hl 
0386			 
0386			storage_label:     
0386			 
0386				if DEBUG_STORESE 
0386					DMARK "LBL" 
0386 f5				push af  
0387 3a 9b 03			ld a, (.dmark)  
038a 32 7a ee			ld (debug_mark),a  
038d 3a 9c 03			ld a, (.dmark+1)  
0390 32 7b ee			ld (debug_mark+1),a  
0393 3a 9d 03			ld a, (.dmark+2)  
0396 32 7c ee			ld (debug_mark+2),a  
0399 18 03			jr .pastdmark  
039b ..			.dmark: db "LBL"  
039e f1			.pastdmark: pop af  
039f			endm  
# End of macro DMARK
039f					CALLMONITOR 
039f cd 2c 14			call break_point_state  
03a2				endm  
# End of macro CALLMONITOR
03a2				endif 
03a2			 
03a2 e5				push hl 
03a3			 
03a3 cd 62 02			call storage_get_block_0 
03a6			 
03a6				; set default label 
03a6			 
03a6 e1				pop hl 
03a7			 
03a7 11 68 eb		 	ld de, store_page+3 
03aa 01 0f 00			ld bc, 15 
03ad				if DEBUG_STORESE 
03ad					DMARK "LB3" 
03ad f5				push af  
03ae 3a c2 03			ld a, (.dmark)  
03b1 32 7a ee			ld (debug_mark),a  
03b4 3a c3 03			ld a, (.dmark+1)  
03b7 32 7b ee			ld (debug_mark+1),a  
03ba 3a c4 03			ld a, (.dmark+2)  
03bd 32 7c ee			ld (debug_mark+2),a  
03c0 18 03			jr .pastdmark  
03c2 ..			.dmark: db "LB3"  
03c5 f1			.pastdmark: pop af  
03c6			endm  
# End of macro DMARK
03c6					CALLMONITOR 
03c6 cd 2c 14			call break_point_state  
03c9				endm  
# End of macro CALLMONITOR
03c9				endif 
03c9 ed b0			ldir 
03cb				; save default page 0 
03cb			 
03cb 21 00 00			ld hl, 0 
03ce 11 65 eb			ld de, store_page 
03d1				if DEBUG_STORESE 
03d1					DMARK "LBW" 
03d1 f5				push af  
03d2 3a e6 03			ld a, (.dmark)  
03d5 32 7a ee			ld (debug_mark),a  
03d8 3a e7 03			ld a, (.dmark+1)  
03db 32 7b ee			ld (debug_mark+1),a  
03de 3a e8 03			ld a, (.dmark+2)  
03e1 32 7c ee			ld (debug_mark+2),a  
03e4 18 03			jr .pastdmark  
03e6 ..			.dmark: db "LBW"  
03e9 f1			.pastdmark: pop af  
03ea			endm  
# End of macro DMARK
03ea					CALLMONITOR 
03ea cd 2c 14			call break_point_state  
03ed				endm  
# End of macro CALLMONITOR
03ed				endif 
03ed cd 16 02			call storage_write_block 
03f0			 
03f0 c9				ret 
03f1			 
03f1			 
03f1			 
03f1			; Read Block 0 - Config 
03f1			; --------------------- 
03f1			; 
03f1			; With current bank 
03f1			; Call presence test 
03f1			;    If not present format/init bank  
03f1			; Read block 0  
03f1			;  
03f1			 
03f1			 
03f1			; Dir 
03f1			; --- 
03f1			; 
03f1			; With current bank 
03f1			; Load Block 0 Config 
03f1			; Get max file id number 
03f1			; For each logical block 
03f1			;    Read block read byte 2 
03f1			;      if first block of file 
03f1			;         Display file name 
03f1			;         Display type flags for file 
03f1			;        
03f1			 
03f1			; moving to words as this requires stack control 
03f1			 
03f1			 
03f1			; Delete File 
03f1			; ----------- 
03f1			; 
03f1			; With current bank 
03f1			; 
03f1			; Load Block 0 Config 
03f1			; Get max file id number 
03f1			; For each logical block 
03f1			;    Read block file id 
03f1			;      If first block of file and dont have file id 
03f1			;         if file to delete 
03f1			;         Save file id 
03f1			;         Null file id 
03f1			;         Write this block back 
03f1			;      If file id is one saved 
03f1			;         Null file id 
03f1			;         Write this block back 
03f1			 
03f1			storage_erase: 
03f1			 
03f1				; hl contains the file id 
03f1			 
03f1 5d				ld e, l 
03f2 16 00			ld d, 0 
03f4 21 40 00			ld hl, STORE_BLOCK_PHY 
03f7					if DEBUG_FORTH_WORDS 
03f7						DMARK "ERA" 
03f7 f5				push af  
03f8 3a 0c 04			ld a, (.dmark)  
03fb 32 7a ee			ld (debug_mark),a  
03fe 3a 0d 04			ld a, (.dmark+1)  
0401 32 7b ee			ld (debug_mark+1),a  
0404 3a 0e 04			ld a, (.dmark+2)  
0407 32 7c ee			ld (debug_mark+2),a  
040a 18 03			jr .pastdmark  
040c ..			.dmark: db "ERA"  
040f f1			.pastdmark: pop af  
0410			endm  
# End of macro DMARK
0410						CALLMONITOR 
0410 cd 2c 14			call break_point_state  
0413				endm  
# End of macro CALLMONITOR
0413					endif 
0413 cd d2 04			call storage_findnextid 
0416			 
0416 e5				push hl 
0417			 
0417				; TODO check file not found 
0417			 
0417 11 65 eb			ld de, store_page 
041a cd b1 01			call storage_read_block 
041d			 
041d					if DEBUG_FORTH_WORDS 
041d						DMARK "ER1" 
041d f5				push af  
041e 3a 32 04			ld a, (.dmark)  
0421 32 7a ee			ld (debug_mark),a  
0424 3a 33 04			ld a, (.dmark+1)  
0427 32 7b ee			ld (debug_mark+1),a  
042a 3a 34 04			ld a, (.dmark+2)  
042d 32 7c ee			ld (debug_mark+2),a  
0430 18 03			jr .pastdmark  
0432 ..			.dmark: db "ER1"  
0435 f1			.pastdmark: pop af  
0436			endm  
# End of macro DMARK
0436						CALLMONITOR 
0436 cd 2c 14			call break_point_state  
0439				endm  
# End of macro CALLMONITOR
0439					endif 
0439 3a 65 eb			ld a, (store_page)	; get file id 
043c 32 5e eb			ld (store_tmpid), a 
043f			 
043f 3a 67 eb			ld a, (store_page+2)    ; get count of extends 
0442 32 5d eb			ld (store_tmpext), a 
0445			 
0445				; wipe file header 
0445			 
0445 e1				pop hl 
0446 3e 00			ld a, 0 
0448 32 65 eb			ld (store_page), a 
044b 32 66 eb			ld (store_page+1),a 
044e 11 65 eb			ld de, store_page 
0451					if DEBUG_FORTH_WORDS 
0451						DMARK "ER2" 
0451 f5				push af  
0452 3a 66 04			ld a, (.dmark)  
0455 32 7a ee			ld (debug_mark),a  
0458 3a 67 04			ld a, (.dmark+1)  
045b 32 7b ee			ld (debug_mark+1),a  
045e 3a 68 04			ld a, (.dmark+2)  
0461 32 7c ee			ld (debug_mark+2),a  
0464 18 03			jr .pastdmark  
0466 ..			.dmark: db "ER2"  
0469 f1			.pastdmark: pop af  
046a			endm  
# End of macro DMARK
046a						CALLMONITOR 
046a cd 2c 14			call break_point_state  
046d				endm  
# End of macro CALLMONITOR
046d					endif 
046d cd 16 02			call storage_write_block 
0470			 
0470			 
0470				; wipe file extents 
0470			 
0470 3a 5d eb			ld a, (store_tmpext) 
0473 47				ld b, a 
0474			 
0474			.eraext:	  
0474 c5				push bc 
0475			 
0475 21 40 00			ld hl, STORE_BLOCK_PHY 
0478 3a 5e eb			ld a,(store_tmpid) 
047b 5f				ld e, a 
047c 50				ld d, b	 
047d					if DEBUG_FORTH_WORDS 
047d						DMARK "ER3" 
047d f5				push af  
047e 3a 92 04			ld a, (.dmark)  
0481 32 7a ee			ld (debug_mark),a  
0484 3a 93 04			ld a, (.dmark+1)  
0487 32 7b ee			ld (debug_mark+1),a  
048a 3a 94 04			ld a, (.dmark+2)  
048d 32 7c ee			ld (debug_mark+2),a  
0490 18 03			jr .pastdmark  
0492 ..			.dmark: db "ER3"  
0495 f1			.pastdmark: pop af  
0496			endm  
# End of macro DMARK
0496						CALLMONITOR 
0496 cd 2c 14			call break_point_state  
0499				endm  
# End of macro CALLMONITOR
0499					endif 
0499 cd d2 04			call storage_findnextid 
049c			 
049c e5				push hl 
049d 11 65 eb			ld de, store_page 
04a0 cd b1 01			call storage_read_block 
04a3			 
04a3				; free block	 
04a3			 
04a3 3e 00			ld a, 0 
04a5 32 65 eb			ld (store_page), a 
04a8 32 66 eb			ld (store_page+1),a 
04ab 11 65 eb			ld de, store_page 
04ae e1				pop hl 
04af					if DEBUG_FORTH_WORDS 
04af						DMARK "ER4" 
04af f5				push af  
04b0 3a c4 04			ld a, (.dmark)  
04b3 32 7a ee			ld (debug_mark),a  
04b6 3a c5 04			ld a, (.dmark+1)  
04b9 32 7b ee			ld (debug_mark+1),a  
04bc 3a c6 04			ld a, (.dmark+2)  
04bf 32 7c ee			ld (debug_mark+2),a  
04c2 18 03			jr .pastdmark  
04c4 ..			.dmark: db "ER4"  
04c7 f1			.pastdmark: pop af  
04c8			endm  
# End of macro DMARK
04c8						CALLMONITOR 
04c8 cd 2c 14			call break_point_state  
04cb				endm  
# End of macro CALLMONITOR
04cb					endif 
04cb cd 16 02			call storage_write_block 
04ce			 
04ce c1				pop bc 
04cf 10 a3			djnz .eraext 
04d1			 
04d1 c9				ret 
04d2			 
04d2			 
04d2			; Find Free Block 
04d2			; --------------- 
04d2			; 
04d2			; With current bank 
04d2			;  
04d2			; From given starting logical block 
04d2			;    Read block  
04d2			;    If no file id 
04d2			;         Return block id 
04d2			 
04d2			 
04d2			; hl starting page number 
04d2			; hl contains free page number or zero if no pages free 
04d2			; e contains the file id to locate 
04d2			; d contains the block number 
04d2			 
04d2			; TODO change to find file id and use zero for free block 
04d2			 
04d2			storage_findnextid: 
04d2			 
04d2				; now locate first 0 page to mark as a free block 
04d2			 
04d2 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04d4			;	ld hl, STORE_BLOCK_PHY 
04d4			 
04d4					if DEBUG_FORTH_WORDS 
04d4					DMARK "FNI" 
04d4 f5				push af  
04d5 3a e9 04			ld a, (.dmark)  
04d8 32 7a ee			ld (debug_mark),a  
04db 3a ea 04			ld a, (.dmark+1)  
04de 32 7b ee			ld (debug_mark+1),a  
04e1 3a eb 04			ld a, (.dmark+2)  
04e4 32 7c ee			ld (debug_mark+2),a  
04e7 18 03			jr .pastdmark  
04e9 ..			.dmark: db "FNI"  
04ec f1			.pastdmark: pop af  
04ed			endm  
# End of macro DMARK
04ed						CALLMONITOR 
04ed cd 2c 14			call break_point_state  
04f0				endm  
# End of macro CALLMONITOR
04f0					endif 
04f0			.ff1:   	 
04f0 e5					push hl 
04f1 c5					push bc 
04f2 d5					push de 
04f3 cd ae 01				call se_readbyte 
04f6 5f					ld e,a 
04f7 23					inc hl 
04f8 cd ae 01				call se_readbyte 
04fb 57					ld d, a 
04fc e1					pop hl 
04fd e5					push hl 
04fe cd d0 0b				call cmp16 
0501 28 49				jr z, .fffound 
0503			 
0503 d1					pop de 
0504 c1					pop bc 
0505 e1					pop hl 
0506			 
0506					; is found? 
0506					;cp e 
0506					;ret z 
0506			 
0506 3e 40				ld a, STORE_BLOCK_PHY 
0508 cd b2 0b				call addatohl 
050b 10 e3				djnz .ff1 
050d			 
050d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
050f			.ff2:   	 
050f			 
050f e5					push hl 
0510 c5					push bc 
0511 d5					push de 
0512 cd ae 01				call se_readbyte 
0515 5f					ld e,a 
0516 23					inc hl 
0517 cd ae 01				call se_readbyte 
051a 57					ld d, a 
051b			 
051b e1					pop hl 
051c e5					push hl 
051d cd d0 0b				call cmp16 
0520 28 2a				jr z, .fffound 
0522			 
0522 d1					pop de 
0523 c1					pop bc 
0524 e1					pop hl 
0525					; is found? 
0525					;cp e 
0525					;ret z 
0525			 
0525 3e 40				ld a, STORE_BLOCK_PHY 
0527 cd b2 0b				call addatohl 
052a 10 e3				djnz .ff2 
052c			 
052c			 
052c					if DEBUG_FORTH_WORDS 
052c					DMARK "FN-" 
052c f5				push af  
052d 3a 41 05			ld a, (.dmark)  
0530 32 7a ee			ld (debug_mark),a  
0533 3a 42 05			ld a, (.dmark+1)  
0536 32 7b ee			ld (debug_mark+1),a  
0539 3a 43 05			ld a, (.dmark+2)  
053c 32 7c ee			ld (debug_mark+2),a  
053f 18 03			jr .pastdmark  
0541 ..			.dmark: db "FN-"  
0544 f1			.pastdmark: pop af  
0545			endm  
# End of macro DMARK
0545					;	push af 
0545					;	ld a, 'n' 
0545					;	ld (debug_mark),a 
0545					;	pop af 
0545						CALLMONITOR 
0545 cd 2c 14			call break_point_state  
0548				endm  
# End of macro CALLMONITOR
0548					endif 
0548				; no free marks! 
0548 21 00 00				ld hl, 0 
054b c9				ret 
054c			.fffound: 
054c				 
054c			 
054c d1					pop de 
054d c1					pop bc 
054e e1					pop hl 
054f					if DEBUG_FORTH_WORDS 
054f					DMARK "FNF" 
054f f5				push af  
0550 3a 64 05			ld a, (.dmark)  
0553 32 7a ee			ld (debug_mark),a  
0556 3a 65 05			ld a, (.dmark+1)  
0559 32 7b ee			ld (debug_mark+1),a  
055c 3a 66 05			ld a, (.dmark+2)  
055f 32 7c ee			ld (debug_mark+2),a  
0562 18 03			jr .pastdmark  
0564 ..			.dmark: db "FNF"  
0567 f1			.pastdmark: pop af  
0568			endm  
# End of macro DMARK
0568					;	push af 
0568					;	ld a, 'n' 
0568					;	ld (debug_mark),a 
0568					;	pop af 
0568						CALLMONITOR 
0568 cd 2c 14			call break_point_state  
056b				endm  
# End of macro CALLMONITOR
056b					endif 
056b c9				ret 
056c			 
056c			 
056c			 
056c			; Free Space 
056c			; ---------- 
056c			; 
056c			; With current bank 
056c			; 
056c			; Set block count to zero 
056c			; Starting with first logical block 
056c			;      Find free block  
056c			;      If block id given, increment block count 
056c			; 
056c			;  
056c			 
056c			 
056c			; hl contains count of free blocks 
056c			 
056c			storage_freeblocks: 
056c			 
056c				; now locate first 0 page to mark as a free block 
056c			 
056c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
056e 21 40 00			ld hl, STORE_BLOCK_PHY 
0571 11 00 00			ld de, 0 
0574			 
0574			.fb1:   	 
0574 e5					push hl 
0575 c5					push bc 
0576 d5					push de 
0577 cd ae 01				call se_readbyte 
057a d1					pop de 
057b c1					pop bc 
057c e1					pop hl 
057d			 
057d					; is free? 
057d fe 00				cp 0 
057f 20 01				jr nz, .ff1cont 
0581 13					inc de 
0582			 
0582			.ff1cont: 
0582			 
0582			 
0582 3e 40				ld a, STORE_BLOCK_PHY 
0584 cd b2 0b				call addatohl 
0587 10 eb				djnz .fb1 
0589			 
0589 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
058b			.fb2:   	 
058b e5					push hl 
058c c5					push bc 
058d d5					push de 
058e cd ae 01				call se_readbyte 
0591 d1					pop de 
0592 c1					pop bc 
0593 e1					pop hl 
0594			 
0594					; is free? 
0594 fe 00				cp 0 
0596 20 01				jr nz, .ff2cont 
0598 13					inc de 
0599			 
0599			.ff2cont: 
0599			 
0599 3e 40				ld a, STORE_BLOCK_PHY 
059b cd b2 0b				call addatohl 
059e 10 eb				djnz .fb2 
05a0			 
05a0 eb				ex de, hl 
05a1 c9				ret 
05a2			 
05a2			; Get File ID 
05a2			; ----------- 
05a2			; 
05a2			; With current bank 
05a2			;  
05a2			; Load Block 0 Config 
05a2			; Get max file id number 
05a2			; For each logical block 
05a2			;    Read block file id 
05a2			;      If first block of file and dont have file id 
05a2			;         if file get id and exit 
05a2			 
05a2			 
05a2			 
05a2			 
05a2			; Create File 
05a2			; ----------- 
05a2			; 
05a2			; With current bank  
05a2			; Load Block 0 Config 
05a2			; Get max file id number 
05a2			; Increment file id number 
05a2			; Save Config 
05a2			; Find free block 
05a2			; Set buffer with file name and file id 
05a2			; Write buffer to free block  
05a2			 
05a2			 
05a2			; hl point to file name 
05a2			; hl returns file id 
05a2			 
05a2			; file format: 
05a2			; byte 0 - file id 
05a2			; byte 1 - extent number 
05a2			; byte 2-> data 
05a2			 
05a2			; format for extent number 0: 
05a2			; 
05a2			; byte 0 - file id 
05a2			; byte 1 - extent 0 
05a2			; byte 2 - extent count 
05a2			; byte 3 -> file name and meta data 
05a2			 
05a2			 
05a2			storage_create: 
05a2				if DEBUG_STORESE 
05a2					DMARK "SCR" 
05a2 f5				push af  
05a3 3a b7 05			ld a, (.dmark)  
05a6 32 7a ee			ld (debug_mark),a  
05a9 3a b8 05			ld a, (.dmark+1)  
05ac 32 7b ee			ld (debug_mark+1),a  
05af 3a b9 05			ld a, (.dmark+2)  
05b2 32 7c ee			ld (debug_mark+2),a  
05b5 18 03			jr .pastdmark  
05b7 ..			.dmark: db "SCR"  
05ba f1			.pastdmark: pop af  
05bb			endm  
# End of macro DMARK
05bb					CALLMONITOR 
05bb cd 2c 14			call break_point_state  
05be				endm  
# End of macro CALLMONITOR
05be				endif 
05be			 
05be e5				push hl		; save file name pointer 
05bf			 
05bf cd 62 02			call storage_get_block_0 
05c2			 
05c2 3a 65 eb			ld a,(store_page)	; get current file id 
05c5 3c				inc a 
05c6 32 65 eb			ld (store_page),a 
05c9				 
05c9 32 5e eb			ld (store_tmpid),a			; save id 
05cc			 
05cc 21 00 00			ld hl, 0 
05cf 11 65 eb			ld de, store_page 
05d2				if DEBUG_STORESE 
05d2					DMARK "SCw" 
05d2 f5				push af  
05d3 3a e7 05			ld a, (.dmark)  
05d6 32 7a ee			ld (debug_mark),a  
05d9 3a e8 05			ld a, (.dmark+1)  
05dc 32 7b ee			ld (debug_mark+1),a  
05df 3a e9 05			ld a, (.dmark+2)  
05e2 32 7c ee			ld (debug_mark+2),a  
05e5 18 03			jr .pastdmark  
05e7 ..			.dmark: db "SCw"  
05ea f1			.pastdmark: pop af  
05eb			endm  
# End of macro DMARK
05eb					CALLMONITOR 
05eb cd 2c 14			call break_point_state  
05ee				endm  
# End of macro CALLMONITOR
05ee				endif 
05ee cd 16 02			call storage_write_block	 ; save update 
05f1			 
05f1				if DEBUG_STORESE 
05f1 11 65 eb				ld de, store_page 
05f4					DMARK "SCC" 
05f4 f5				push af  
05f5 3a 09 06			ld a, (.dmark)  
05f8 32 7a ee			ld (debug_mark),a  
05fb 3a 0a 06			ld a, (.dmark+1)  
05fe 32 7b ee			ld (debug_mark+1),a  
0601 3a 0b 06			ld a, (.dmark+2)  
0604 32 7c ee			ld (debug_mark+2),a  
0607 18 03			jr .pastdmark  
0609 ..			.dmark: db "SCC"  
060c f1			.pastdmark: pop af  
060d			endm  
# End of macro DMARK
060d					CALLMONITOR 
060d cd 2c 14			call break_point_state  
0610				endm  
# End of macro CALLMONITOR
0610				endif 
0610				;  
0610				 
0610 21 40 00			ld hl, STORE_BLOCK_PHY 
0613 11 00 00			ld de, 0 
0616 cd d2 04			call storage_findnextid 
0619			 
0619 22 4f eb			ld (store_tmppageid), hl    ; save page to use  
061c			 
061c				; TODO detect 0 = no spare blocks 
061c			 
061c				; hl now contains the free page to use for the file header page 
061c			 
061c				if DEBUG_STORESE 
061c				DMARK "SCF" 
061c f5				push af  
061d 3a 31 06			ld a, (.dmark)  
0620 32 7a ee			ld (debug_mark),a  
0623 3a 32 06			ld a, (.dmark+1)  
0626 32 7b ee			ld (debug_mark+1),a  
0629 3a 33 06			ld a, (.dmark+2)  
062c 32 7c ee			ld (debug_mark+2),a  
062f 18 03			jr .pastdmark  
0631 ..			.dmark: db "SCF"  
0634 f1			.pastdmark: pop af  
0635			endm  
# End of macro DMARK
0635					CALLMONITOR 
0635 cd 2c 14			call break_point_state  
0638				endm  
# End of macro CALLMONITOR
0638				endif 
0638			 
0638 22 4f eb			ld (store_tmppageid), hl 
063b				 
063b 3a 5e eb			ld a,(store_tmpid)    ; get file id 
063e			;	ld a, (store_filecache)			; save to cache 
063e			 
063e 32 65 eb			ld (store_page),a    ; set page id 
0641 3e 00			ld a, 0			 ; extent 0 is file header 
0643 32 66 eb			ld (store_page+1), a   ; set file extent 
0646			 
0646 32 67 eb			ld (store_page+2), a   ; extent count for the file 
0649			 
0649			;	inc hl 		; init block 0 of file 
0649			;	inc hl   		; skip file and extent id 
0649			 ;       ld a, 0 
0649			;	ld (hl),a 
0649			;	ld a, (store_filecache+1)  	; save to cache 
0649			 
0649			;	inc hl    ; file name 
0649				 
0649				 
0649 11 68 eb			ld de, store_page+3    ; get buffer for term string to use as file name 
064c				if DEBUG_STORESE 
064c					DMARK "SCc" 
064c f5				push af  
064d 3a 61 06			ld a, (.dmark)  
0650 32 7a ee			ld (debug_mark),a  
0653 3a 62 06			ld a, (.dmark+1)  
0656 32 7b ee			ld (debug_mark+1),a  
0659 3a 63 06			ld a, (.dmark+2)  
065c 32 7c ee			ld (debug_mark+2),a  
065f 18 03			jr .pastdmark  
0661 ..			.dmark: db "SCc"  
0664 f1			.pastdmark: pop af  
0665			endm  
# End of macro DMARK
0665					CALLMONITOR 
0665 cd 2c 14			call break_point_state  
0668				endm  
# End of macro CALLMONITOR
0668				endif 
0668 e1				pop hl    ; get zero term string 
0669 e5				push hl 
066a 3e 00			ld a, 0 
066c cd 1b 10			call strlent 
066f 23				inc hl   ; cover zero term 
0670 06 00			ld b,0 
0672 4d				ld c,l 
0673 e1				pop hl 
0674				;ex de, hl 
0674				if DEBUG_STORESE 
0674					DMARK "SCa" 
0674 f5				push af  
0675 3a 89 06			ld a, (.dmark)  
0678 32 7a ee			ld (debug_mark),a  
067b 3a 8a 06			ld a, (.dmark+1)  
067e 32 7b ee			ld (debug_mark+1),a  
0681 3a 8b 06			ld a, (.dmark+2)  
0684 32 7c ee			ld (debug_mark+2),a  
0687 18 03			jr .pastdmark  
0689 ..			.dmark: db "SCa"  
068c f1			.pastdmark: pop af  
068d			endm  
# End of macro DMARK
068d					;push af 
068d					;ld a, 'a' 
068d					;ld (debug_mark),a 
068d					;pop af 
068d					CALLMONITOR 
068d cd 2c 14			call break_point_state  
0690				endm  
# End of macro CALLMONITOR
0690				endif 
0690 ed b0			ldir    ; copy zero term string 
0692				if DEBUG_STORESE 
0692					DMARK "SCA" 
0692 f5				push af  
0693 3a a7 06			ld a, (.dmark)  
0696 32 7a ee			ld (debug_mark),a  
0699 3a a8 06			ld a, (.dmark+1)  
069c 32 7b ee			ld (debug_mark+1),a  
069f 3a a9 06			ld a, (.dmark+2)  
06a2 32 7c ee			ld (debug_mark+2),a  
06a5 18 03			jr .pastdmark  
06a7 ..			.dmark: db "SCA"  
06aa f1			.pastdmark: pop af  
06ab			endm  
# End of macro DMARK
06ab					CALLMONITOR 
06ab cd 2c 14			call break_point_state  
06ae				endm  
# End of macro CALLMONITOR
06ae				endif 
06ae			 
06ae				; write file header page 
06ae			 
06ae 2a 4f eb			ld hl,(store_tmppageid) 
06b1 11 65 eb			ld de, store_page 
06b4				if DEBUG_STORESE 
06b4					DMARK "SCb" 
06b4 f5				push af  
06b5 3a c9 06			ld a, (.dmark)  
06b8 32 7a ee			ld (debug_mark),a  
06bb 3a ca 06			ld a, (.dmark+1)  
06be 32 7b ee			ld (debug_mark+1),a  
06c1 3a cb 06			ld a, (.dmark+2)  
06c4 32 7c ee			ld (debug_mark+2),a  
06c7 18 03			jr .pastdmark  
06c9 ..			.dmark: db "SCb"  
06cc f1			.pastdmark: pop af  
06cd			endm  
# End of macro DMARK
06cd					;push af 
06cd					;ld a, 'b' 
06cd					;ld (debug_mark),a 
06cd					;pop af 
06cd					CALLMONITOR 
06cd cd 2c 14			call break_point_state  
06d0				endm  
# End of macro CALLMONITOR
06d0				endif 
06d0 cd 16 02			call storage_write_block 
06d3			 
06d3 3a 5e eb			ld a, (store_tmpid) 
06d6 6f				ld l, a 
06d7 26 00			ld h,0 
06d9				if DEBUG_STORESE 
06d9					DMARK "SCz" 
06d9 f5				push af  
06da 3a ee 06			ld a, (.dmark)  
06dd 32 7a ee			ld (debug_mark),a  
06e0 3a ef 06			ld a, (.dmark+1)  
06e3 32 7b ee			ld (debug_mark+1),a  
06e6 3a f0 06			ld a, (.dmark+2)  
06e9 32 7c ee			ld (debug_mark+2),a  
06ec 18 03			jr .pastdmark  
06ee ..			.dmark: db "SCz"  
06f1 f1			.pastdmark: pop af  
06f2			endm  
# End of macro DMARK
06f2					CALLMONITOR 
06f2 cd 2c 14			call break_point_state  
06f5				endm  
# End of macro CALLMONITOR
06f5				endif 
06f5 c9				ret 
06f6				 
06f6			 
06f6			 
06f6			; 
06f6			; Read File 
06f6			; 
06f6			; h - file id to locate 
06f6			; l - extent to locate 
06f6			; de - pointer to string to read into 
06f6			; 
06f6			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
06f6			storage_read: 
06f6 d5				push de 
06f7			 
06f7			; TODO BUG the above push is it popped before the RET Z? 
06f7			 
06f7			; TODO how to handle multiple part blocks 
06f7			 
06f7				; locate file extent to read 
06f7			 
06f7 5c				ld e, h 
06f8 55				ld d, l 
06f9 21 40 00			ld hl, STORE_BLOCK_PHY 
06fc				if DEBUG_STORESE 
06fc					DMARK "SRE" 
06fc f5				push af  
06fd 3a 11 07			ld a, (.dmark)  
0700 32 7a ee			ld (debug_mark),a  
0703 3a 12 07			ld a, (.dmark+1)  
0706 32 7b ee			ld (debug_mark+1),a  
0709 3a 13 07			ld a, (.dmark+2)  
070c 32 7c ee			ld (debug_mark+2),a  
070f 18 03			jr .pastdmark  
0711 ..			.dmark: db "SRE"  
0714 f1			.pastdmark: pop af  
0715			endm  
# End of macro DMARK
0715					CALLMONITOR 
0715 cd 2c 14			call break_point_state  
0718				endm  
# End of macro CALLMONITOR
0718				endif 
0718 cd d2 04			call storage_findnextid 
071b			 
071b				if DEBUG_STORESE 
071b					DMARK "SRf" 
071b f5				push af  
071c 3a 30 07			ld a, (.dmark)  
071f 32 7a ee			ld (debug_mark),a  
0722 3a 31 07			ld a, (.dmark+1)  
0725 32 7b ee			ld (debug_mark+1),a  
0728 3a 32 07			ld a, (.dmark+2)  
072b 32 7c ee			ld (debug_mark+2),a  
072e 18 03			jr .pastdmark  
0730 ..			.dmark: db "SRf"  
0733 f1			.pastdmark: pop af  
0734			endm  
# End of macro DMARK
0734					CALLMONITOR 
0734 cd 2c 14			call break_point_state  
0737				endm  
# End of macro CALLMONITOR
0737				endif 
0737 cd db 0b			call ishlzero 
073a			;	ld a, l 
073a			;	add h 
073a			;	cp 0 
073a c8				ret z			; block not found so EOF 
073b			 
073b				; hl contains page number to load 
073b d1				pop de   ; get storage 
073c d5				push de 
073d				if DEBUG_STORESE 
073d					DMARK "SRg" 
073d f5				push af  
073e 3a 52 07			ld a, (.dmark)  
0741 32 7a ee			ld (debug_mark),a  
0744 3a 53 07			ld a, (.dmark+1)  
0747 32 7b ee			ld (debug_mark+1),a  
074a 3a 54 07			ld a, (.dmark+2)  
074d 32 7c ee			ld (debug_mark+2),a  
0750 18 03			jr .pastdmark  
0752 ..			.dmark: db "SRg"  
0755 f1			.pastdmark: pop af  
0756			endm  
# End of macro DMARK
0756					CALLMONITOR 
0756 cd 2c 14			call break_point_state  
0759				endm  
# End of macro CALLMONITOR
0759				endif 
0759 cd b1 01			call storage_read_block 
075c			 
075c			 
075c			; TODO if block has no zeros then need to read next block  
075c			 
075c			 
075c					 
075c e1				pop hl 		 ; return start of data to show as not EOF 
075d 23				inc hl   ; past file id 
075e 23				inc hl   ; past ext 
075f				if DEBUG_STORESE 
075f					DMARK "SRe" 
075f f5				push af  
0760 3a 74 07			ld a, (.dmark)  
0763 32 7a ee			ld (debug_mark),a  
0766 3a 75 07			ld a, (.dmark+1)  
0769 32 7b ee			ld (debug_mark+1),a  
076c 3a 76 07			ld a, (.dmark+2)  
076f 32 7c ee			ld (debug_mark+2),a  
0772 18 03			jr .pastdmark  
0774 ..			.dmark: db "SRe"  
0777 f1			.pastdmark: pop af  
0778			endm  
# End of macro DMARK
0778					CALLMONITOR 
0778 cd 2c 14			call break_point_state  
077b				endm  
# End of macro CALLMONITOR
077b				endif 
077b c9					ret 
077c			 
077c			 
077c			 
077c			; 
077c			; Append File 
077c			; 
077c			; hl - file id to locate 
077c			; de - pointer to (multi block) string to write 
077c			 
077c			 
077c			storage_append: 
077c				; hl -  file id to append to 
077c				; de - string to append 
077c			 
077c d5				push de 
077d				 
077d				if DEBUG_STORESE 
077d					DMARK "AP1" 
077d f5				push af  
077e 3a 92 07			ld a, (.dmark)  
0781 32 7a ee			ld (debug_mark),a  
0784 3a 93 07			ld a, (.dmark+1)  
0787 32 7b ee			ld (debug_mark+1),a  
078a 3a 94 07			ld a, (.dmark+2)  
078d 32 7c ee			ld (debug_mark+2),a  
0790 18 03			jr .pastdmark  
0792 ..			.dmark: db "AP1"  
0795 f1			.pastdmark: pop af  
0796			endm  
# End of macro DMARK
0796					CALLMONITOR 
0796 cd 2c 14			call break_point_state  
0799				endm  
# End of macro CALLMONITOR
0799				endif 
0799			 
0799 7d				ld a, l 
079a 32 5e eb			ld (store_tmpid), a 
079d			 
079d				; get file header  
079d			 
079d 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
079f 3a 5e eb			ld a, (store_tmpid) 
07a2 5f				ld e, a 
07a3			 
07a3 21 40 00				ld hl, STORE_BLOCK_PHY 
07a6 cd d2 04				call storage_findnextid 
07a9			 
07a9 22 4f eb			ld (store_tmppageid), hl 
07ac			 
07ac				; TODO handle file id not found 
07ac			 
07ac				if DEBUG_STORESE 
07ac					DMARK "AP2" 
07ac f5				push af  
07ad 3a c1 07			ld a, (.dmark)  
07b0 32 7a ee			ld (debug_mark),a  
07b3 3a c2 07			ld a, (.dmark+1)  
07b6 32 7b ee			ld (debug_mark+1),a  
07b9 3a c3 07			ld a, (.dmark+2)  
07bc 32 7c ee			ld (debug_mark+2),a  
07bf 18 03			jr .pastdmark  
07c1 ..			.dmark: db "AP2"  
07c4 f1			.pastdmark: pop af  
07c5			endm  
# End of macro DMARK
07c5					CALLMONITOR 
07c5 cd 2c 14			call break_point_state  
07c8				endm  
# End of macro CALLMONITOR
07c8				endif 
07c8			 
07c8				; update file extent count 
07c8			 
07c8 11 65 eb			ld de, store_page 
07cb			 
07cb cd b1 01			call storage_read_block 
07ce			 
07ce				if DEBUG_STORESE 
07ce					DMARK "AP3" 
07ce f5				push af  
07cf 3a e3 07			ld a, (.dmark)  
07d2 32 7a ee			ld (debug_mark),a  
07d5 3a e4 07			ld a, (.dmark+1)  
07d8 32 7b ee			ld (debug_mark+1),a  
07db 3a e5 07			ld a, (.dmark+2)  
07de 32 7c ee			ld (debug_mark+2),a  
07e1 18 03			jr .pastdmark  
07e3 ..			.dmark: db "AP3"  
07e6 f1			.pastdmark: pop af  
07e7			endm  
# End of macro DMARK
07e7					CALLMONITOR 
07e7 cd 2c 14			call break_point_state  
07ea				endm  
# End of macro CALLMONITOR
07ea				endif 
07ea			;	ld (store_tmppageid), hl 
07ea			 
07ea 3a 67 eb			ld a, (store_page+2) 
07ed 3c				inc a 
07ee 32 67 eb			ld (store_page+2), a 
07f1 32 5d eb			ld (store_tmpext), a 
07f4				 
07f4				if DEBUG_STORESE 
07f4					DMARK "AP3" 
07f4 f5				push af  
07f5 3a 09 08			ld a, (.dmark)  
07f8 32 7a ee			ld (debug_mark),a  
07fb 3a 0a 08			ld a, (.dmark+1)  
07fe 32 7b ee			ld (debug_mark+1),a  
0801 3a 0b 08			ld a, (.dmark+2)  
0804 32 7c ee			ld (debug_mark+2),a  
0807 18 03			jr .pastdmark  
0809 ..			.dmark: db "AP3"  
080c f1			.pastdmark: pop af  
080d			endm  
# End of macro DMARK
080d					CALLMONITOR 
080d cd 2c 14			call break_point_state  
0810				endm  
# End of macro CALLMONITOR
0810				endif 
0810 2a 4f eb			ld hl, (store_tmppageid) 
0813 11 65 eb			ld de, store_page 
0816 cd 16 02			call storage_write_block 
0819			 
0819				; find free block 
0819			 
0819 11 00 00			ld de, 0			 ; file extent to locate 
081c			 
081c 21 40 00				ld hl, STORE_BLOCK_PHY 
081f cd d2 04				call storage_findnextid 
0822			 
0822					; TODO handle no space left 
0822					 
0822 22 4f eb				ld (store_tmppageid), hl 
0825			 
0825				if DEBUG_STORESE 
0825					DMARK "AP4" 
0825 f5				push af  
0826 3a 3a 08			ld a, (.dmark)  
0829 32 7a ee			ld (debug_mark),a  
082c 3a 3b 08			ld a, (.dmark+1)  
082f 32 7b ee			ld (debug_mark+1),a  
0832 3a 3c 08			ld a, (.dmark+2)  
0835 32 7c ee			ld (debug_mark+2),a  
0838 18 03			jr .pastdmark  
083a ..			.dmark: db "AP4"  
083d f1			.pastdmark: pop af  
083e			endm  
# End of macro DMARK
083e					CALLMONITOR 
083e cd 2c 14			call break_point_state  
0841				endm  
# End of macro CALLMONITOR
0841				endif 
0841					; init the buffer with zeros so we can id if the buffer is full or not 
0841			 
0841 e5					push hl 
0842 c5					push bc 
0843			 
0843 21 65 eb				ld hl, store_page 
0846 06 40				ld b, STORE_BLOCK_PHY 
0848 3e 00				ld a, 0 
084a 77			.zeroblock:	ld (hl), a 
084b 23					inc hl 
084c 10 fc				djnz .zeroblock 
084e			 
084e c1					pop bc 
084f e1					pop hl 
0850			 
0850					; construct block 
0850			 
0850 3a 5e eb				ld a, (store_tmpid) 
0853 32 65 eb				ld (store_page), a   ; file id 
0856 3a 5d eb				ld a, (store_tmpext)   ; extent for this block 
0859 32 66 eb				ld (store_page+1), a 
085c			 
085c e1					pop hl    ; get string to write 
085d 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
085f 11 67 eb				ld de, store_page+2 
0862			 
0862				if DEBUG_STORESE 
0862					DMARK "AP5" 
0862 f5				push af  
0863 3a 77 08			ld a, (.dmark)  
0866 32 7a ee			ld (debug_mark),a  
0869 3a 78 08			ld a, (.dmark+1)  
086c 32 7b ee			ld (debug_mark+1),a  
086f 3a 79 08			ld a, (.dmark+2)  
0872 32 7c ee			ld (debug_mark+2),a  
0875 18 03			jr .pastdmark  
0877 ..			.dmark: db "AP5"  
087a f1			.pastdmark: pop af  
087b			endm  
# End of macro DMARK
087b					CALLMONITOR 
087b cd 2c 14			call break_point_state  
087e				endm  
# End of macro CALLMONITOR
087e				endif 
087e			 
087e			 
087e			 
087e					; fill buffer with data until end of string or full block 
087e			 
087e 7e			.appd:		ld a, (hl) 
087f 12					ld (de), a 
0880 fe 00				cp 0 
0882 28 04				jr z, .appdone 
0884 23					inc hl 
0885 13					inc de 
0886 10 f6				djnz .appd 
0888			 
0888 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0889 f5					push af   		; save last byte dumped 
088a			 
088a			 
088a 2a 4f eb			ld hl, (store_tmppageid) 
088d 11 65 eb			ld de, store_page 
0890				if DEBUG_STORESE 
0890					DMARK "AP6" 
0890 f5				push af  
0891 3a a5 08			ld a, (.dmark)  
0894 32 7a ee			ld (debug_mark),a  
0897 3a a6 08			ld a, (.dmark+1)  
089a 32 7b ee			ld (debug_mark+1),a  
089d 3a a7 08			ld a, (.dmark+2)  
08a0 32 7c ee			ld (debug_mark+2),a  
08a3 18 03			jr .pastdmark  
08a5 ..			.dmark: db "AP6"  
08a8 f1			.pastdmark: pop af  
08a9			endm  
# End of macro DMARK
08a9					CALLMONITOR 
08a9 cd 2c 14			call break_point_state  
08ac				endm  
# End of macro CALLMONITOR
08ac				endif 
08ac cd 16 02				call storage_write_block 
08af			 
08af			 
08af				; was that a full block of data written? 
08af				; any more to write out? 
08af			 
08af				; if yes then set vars and jump to start of function again 
08af			 
08af f1					pop af 
08b0 d1					pop de 
08b1			 
08b1 fe 00				cp 0		 ; no, string was fully written 
08b3 c8					ret z 
08b4			 
08b4					; setup vars for next cycle 
08b4			 
08b4 3a 5e eb				ld a, (store_tmpid) 
08b7 6f					ld l, a 
08b8 26 00				ld h, 0 
08ba			 
08ba c3 7c 07			 	jp storage_append	 ; yes, need to write out some more 
08bd			 
08bd			 
08bd			 
08bd			 
08bd			 
08bd			 
08bd			 
08bd			if DEBUG_STORECF 
08bd			storageput:	 
08bd					ret 
08bd			storageread: 
08bd					ld hl, store_page 
08bd					ld b, 200 
08bd					ld a,0 
08bd			.src:		ld (hl),a 
08bd					inc hl 
08bd					djnz .src 
08bd					 
08bd			 
08bd					ld de, 0 
08bd					ld bc, 1 
08bd					ld hl, store_page 
08bd					call cfRead 
08bd			 
08bd				call cfGetError 
08bd				ld hl,scratch 
08bd				call hexout 
08bd				ld hl, scratch+2 
08bd				ld a, 0 
08bd				ld (hl),a 
08bd				ld de, scratch 
08bd				ld a,display_row_1 
08bd				call str_at_display 
08bd				call update_display 
08bd			 
08bd					ld hl, store_page 
08bd					ld (os_cur_ptr),hl 
08bd			 
08bd					ret 
08bd			endif 
08bd			 
08bd			 
08bd			; Clear out the main buffer store (used to remove junk before writing a new block) 
08bd			 
08bd			storage_clear_page: 
08bd e5				push hl 
08be d5				push de 
08bf c5				push bc 
08c0 21 65 eb			ld hl, store_page 
08c3 3e 00			ld a, 0 
08c5 77				ld (hl), a 
08c6			 
08c6 11 66 eb			ld de, store_page+1 
08c9 01 40 00			ld bc, STORE_BLOCK_PHY 
08cc			 
08cc ed b0			ldir 
08ce				 
08ce c1				pop bc 
08cf d1				pop de 
08d0 e1				pop hl 
08d1 c9				ret 
08d2			 
08d2			; eof 
# End of file firmware_storage.asm
08d2			  
08d2			; support routines for above hardware abstraction layer  
08d2			  
08d2			include "firmware_general.asm"        ; general support functions  
08d2			 
08d2			; word look up 
08d2			 
08d2			; in 
08d2			; a is the index 
08d2			; hl is pointer start of array 
08d2			; 
08d2			; returns 
08d2			; hl to the word 
08d2			; 
08d2			 
08d2			table_lookup:  
08d2 d5					push de 
08d3 eb					ex de, hl 
08d4			 
08d4 6f					ld l, a 
08d5 26 00				ld h, 0 
08d7 29					add hl, hl 
08d8 19					add hl, de 
08d9 7e					ld a, (hl) 
08da 23					inc hl 
08db 66					ld h,(hl) 
08dc 6f					ld l, a 
08dd			 
08dd d1					pop de 
08de c9					ret 
08df			 
08df			; Delay loops 
08df			 
08df			 
08df			 
08df			aDelayInMS: 
08df c5				push bc 
08e0 47				ld b,a 
08e1			msdelay: 
08e1 c5				push bc 
08e2				 
08e2			 
08e2 01 41 00			ld bc,041h 
08e5 cd fd 08			call delayloop 
08e8 c1				pop bc 
08e9 05				dec b 
08ea 20 f5			jr nz,msdelay 
08ec			 
08ec			;if CPU_CLOCK_8MHZ 
08ec			;msdelay8: 
08ec			;	push bc 
08ec			;	 
08ec			; 
08ec			;	ld bc,041h 
08ec			;	call delayloop 
08ec			;	pop bc 
08ec			;	dec b 
08ec			;	jr nz,msdelay8 
08ec			;endif 
08ec			 
08ec			 
08ec c1				pop bc 
08ed c9				ret 
08ee			 
08ee			 
08ee			delay250ms: 
08ee				;push de 
08ee 01 00 40			ld bc, 04000h 
08f1 c3 fd 08			jp delayloop 
08f4			delay500ms: 
08f4				;push de 
08f4 01 00 80			ld bc, 08000h 
08f7 c3 fd 08			jp delayloop 
08fa			delay1s: 
08fa				;push bc 
08fa			   ; Clobbers A, d and e 
08fa 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
08fd			delayloop: 
08fd c5			    push bc 
08fe			 
08fe			if BASE_CPM 
08fe 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0901			.cpmloop: 
0901 c5				push bc 
0902			 
0902			endif 
0902			 
0902			 
0902			 
0902			delayloopi: 
0902			;	push bc 
0902			;.dl: 
0902 cb 47		    bit     0,a    	; 8 
0904 cb 47		    bit     0,a    	; 8 
0906 cb 47		    bit     0,a    	; 8 
0908 e6 ff		    and     255  	; 7 
090a 0b			    dec     bc      	; 6 
090b 79			    ld      a,c     	; 4 
090c b0			    or      b     	; 4 
090d c2 02 09		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0910			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0910				;pop de 
0910			;pop bc 
0910			 
0910			if BASE_CPM 
0910 c1				pop bc 
0911				 
0911 0b			    dec     bc      	; 6 
0912 79			    ld      a,c     	; 4 
0913 b0			    or      b     	; 4 
0914 c2 01 09		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0917				 
0917			 
0917			endif 
0917			;if CPU_CLOCK_8MHZ 
0917			;    pop bc 
0917			;    push bc 
0917			;.dl8: 
0917			;    bit     0,a    	; 8 
0917			;    bit     0,a    	; 8 
0917			;    bit     0,a    	; 8 
0917			;    and     255  	; 7 
0917			;    dec     bc      	; 6 
0917			;    ld      a,c     	; 4 
0917			;    or      b     	; 4 
0917			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0917			;endif 
0917			 
0917			;if CPU_CLOCK_10MHZ 
0917			;    pop bc 
0917			;    push bc 
0917			;.dl8: 
0917			;    bit     0,a    	; 8 
0917			;    bit     0,a    	; 8 
0917			;    bit     0,a    	; 8 
0917			;    and     255  	; 7 
0917			;    dec     bc      	; 6 
0917			;    ld      a,c     	; 4 
0917			;    or      b     	; 4 
0917			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0917			;endif 
0917 c1			    pop bc 
0918			 
0918 c9				ret 
0919			 
0919			 
0919			 
0919			; eof 
# End of file firmware_general.asm
0919			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0919			; display routines that use the physical hardware abstraction layer 
0919			 
0919			 
0919			; information window 
0919			 
0919			; pass hl with 1st string to display 
0919			; pass de with 2nd string to display 
0919			 
0919			info_panel: 
0919 e5				push hl 
091a			 
091a 2a db eb			ld hl, (display_fb_active) 
091d e5				push hl    ; future de destination 
091e 21 c0 ed				ld hl, display_fb0 
0921 22 db eb				ld (display_fb_active), hl 
0924			 
0924 cd 85 09			call clear_display 
0927			 
0927			 
0927 3e 55			ld a, display_row_3 + 5 
0929 cd 98 09			call str_at_display 
092c			 
092c e1				pop hl 
092d d1				pop de 
092e			 
092e e5				push hl 
092f			 
092f			 
092f 3e 2d			ld a, display_row_2 + 5 
0931 cd 98 09			call str_at_display 
0934			 
0934			 
0934 cd a8 09			call update_display 
0937 cd 31 19			call next_page_prompt 
093a cd 85 09			call clear_display 
093d			 
093d				 
093d 21 1f ed				ld hl, display_fb1 
0940 22 db eb				ld (display_fb_active), hl 
0943 cd a8 09			call update_display 
0946			 
0946			 
0946 c9				ret 
0947			 
0947			 
0947			 
0947			 
0947			; TODO windowing? 
0947			 
0947			; TODO scroll line up 
0947			 
0947			scroll_up: 
0947			 
0947 e5				push hl 
0948 d5				push de 
0949 c5				push bc 
094a			 
094a				; get frame buffer  
094a			 
094a 2a db eb			ld hl, (display_fb_active) 
094d e5				push hl    ; future de destination 
094e			 
094e 11 28 00			ld  de, display_cols 
0951 19				add hl, de 
0952			 
0952 d1				pop de 
0953			 
0953				;ex de, hl 
0953 01 9f 00			ld bc, display_fb_len -1  
0956			;if DEBUG_FORTH_WORDS 
0956			;	DMARK "SCL" 
0956			;	CALLMONITOR 
0956			;endif	 
0956 ed b0			ldir 
0958			 
0958				; wipe bottom row 
0958			 
0958			 
0958 2a db eb			ld hl, (display_fb_active) 
095b 11 a0 00			ld de, display_cols*display_rows 
095e 19				add hl, de 
095f 06 28			ld b, display_cols 
0961 3e 20			ld a, ' ' 
0963			.scwipe: 
0963 77				ld (hl), a 
0964 2b				dec hl 
0965 10 fc			djnz .scwipe 
0967			 
0967				;pop hl 
0967			 
0967 c1				pop bc 
0968 d1				pop de 
0969 e1				pop hl 
096a			 
096a c9				ret 
096b			 
096b			 
096b			;scroll_upo: 
096b			;	ld de, display_row_1 
096b			 ;	ld hl, display_row_2 
096b			;	ld bc, display_cols 
096b			;	ldir 
096b			;	ld de, display_row_2 
096b			 ;	ld hl, display_row_3 
096b			;	ld bc, display_cols 
096b			;	ldir 
096b			;	ld de, display_row_3 
096b			 ;	ld hl, display_row_4 
096b			;	ld bc, display_cols 
096b			;	ldir 
096b			 
096b			; TODO clear row 4 
096b			 
096b			;	ret 
096b			 
096b				 
096b			scroll_down: 
096b			 
096b e5				push hl 
096c d5				push de 
096d c5				push bc 
096e			 
096e				; get frame buffer  
096e			 
096e 2a db eb			ld hl, (display_fb_active) 
0971			 
0971 11 9f 00			ld de, display_fb_len - 1 
0974 19				add hl, de 
0975			 
0975 e5			push hl    ; future de destination 
0976			 
0976 11 28 00			ld  de, display_cols 
0979 ed 52			sbc hl, de 
097b			 
097b			 
097b d1				pop de 
097c			 
097c			;	ex de, hl 
097c 01 9f 00			ld bc, display_fb_len -1  
097f			 
097f			 
097f				 
097f			 
097f ed b0			ldir 
0981			 
0981				; wipe bottom row 
0981			 
0981			 
0981			;	ld hl, (display_fb_active) 
0981			;;	ld de, display_cols*display_rows 
0981			;;	add hl, de 
0981			;	ld b, display_cols 
0981			;	ld a, ' ' 
0981			;.scwiped: 
0981			;	ld (hl), a 
0981			;	dec hl 
0981			;	djnz .scwiped 
0981			 
0981				;pop hl 
0981			 
0981 c1				pop bc 
0982 d1				pop de 
0983 e1				pop hl 
0984			 
0984 c9				ret 
0985			;scroll_down: 
0985			;	ld de, display_row_4 
0985			;	ld hl, display_row_3 
0985			;	ld bc, display_cols 
0985			;	ldir 
0985			;	ld de, display_row_3 
0985			; 	ld hl, display_row_2 
0985			;	ld bc, display_cols 
0985			;	ldir 
0985			;	ld de, display_row_2 
0985			;	ld hl, display_row_1 
0985			;	ld bc, display_cols 
0985			;	ldir 
0985			;;; TODO clear row 1 
0985			;	ret 
0985			 
0985			 
0985			 
0985			 
0985			 
0985			; clear active frame buffer 
0985			 
0985			clear_display: 
0985 3e 20			ld a, ' ' 
0987 c3 8a 09			jp fill_display 
098a			 
098a			; fill active frame buffer with a char in A 
098a			 
098a			fill_display: 
098a 06 a0			ld b,display_fb_len 
098c 2a db eb			ld hl, (display_fb_active) 
098f 77			.fd1:	ld (hl),a 
0990 23				inc hl 
0991 10 fc			djnz .fd1 
0993 23				inc hl 
0994 3e 00			ld a,0 
0996 77				ld (hl),a 
0997			 
0997			 
0997 c9				ret 
0998			; Write string (DE) at pos (A) to active frame buffer 
0998			 
0998 2a db eb		str_at_display:    ld hl,(display_fb_active) 
099b 06 00					ld b,0 
099d 4f					ld c,a 
099e 09					add hl,bc 
099f 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
09a0 b7			            OR   A              ;Null terminator? 
09a1 c8			            RET  Z              ;Yes, so finished 
09a2 77					ld (hl),a 
09a3 23				inc hl 
09a4 13			            INC  DE             ;Point to next character 
09a5 18 f8		            JR   .sad1     ;Repeat 
09a7 c9					ret 
09a8			 
09a8			; using current frame buffer write to physical display 
09a8			 
09a8			update_display: 
09a8 e5				push hl 
09a9 2a db eb			ld hl, (display_fb_active) 
09ac cd c3 57			call write_display 
09af e1				pop hl 
09b0 c9				ret 
09b1			 
09b1			; TODO scrolling 
09b1			 
09b1			 
09b1			; move cursor right one char 
09b1			cursor_right: 
09b1			 
09b1				; TODO shift right 
09b1				; TODO if beyond max col 
09b1				; TODO       cursor_next_line 
09b1			 
09b1 c9				ret 
09b2			 
09b2			 
09b2			cursor_next_line: 
09b2				; TODO first char 
09b2				; TODO line down 
09b2				; TODO if past last row 
09b2				; TODO    scroll up 
09b2			 
09b2 c9				ret 
09b3			 
09b3			cursor_left: 
09b3				; TODO shift left 
09b3				; TODO if beyond left  
09b3				; TODO     cursor prev line 
09b3				 
09b3 c9				ret 
09b4			 
09b4			cursor_prev_line: 
09b4				; TODO last char 
09b4				; TODO line up 
09b4				; TODO if past first row 
09b4				; TODO   scroll down 
09b4			 
09b4 c9				ret 
09b5			 
09b5			 
09b5			cout: 
09b5				; A - char 
09b5 c9				ret 
09b6			 
09b6			 
09b6			; Display a menu and allow item selection (optional toggle items) 
09b6			; 
09b6			; format: 
09b6			; hl pointer to word array with zero term for items 
09b6			; e.g.    db item1 
09b6			;         db .... 
09b6			;         db 0 
09b6			; 
09b6			; a = starting menu item  
09b6			; 
09b6			; de = pointer item toggle array   (todo) 
09b6			; 
09b6			; returns item selected in a 1-... 
09b6			; returns 0 if back button pressed 
09b6			; 
09b6			; NOTE: Uses system frame buffer to display 
09b6			; 
09b6			; LEFT, Q = go back 
09b6			; RIGHT, SPACE, CR = select 
09b6			; UP, A - Up 
09b6			; DOWN, Z - Down 
09b6			 
09b6			 
09b6			 
09b6			 
09b6			 
09b6			menu: 
09b6			 
09b6					; keep array pointer 
09b6			 
09b6 22 63 eb				ld (store_tmp1), hl 
09b9 32 61 eb				ld (store_tmp2), a 
09bc			 
09bc					; check for key bounce 
09bc			 
09bc			if BASE_KEV 
09bc			 
09bc			.mbounce:	call cin 
09bc					cp 0 
09bc					jr nz, .mbounce 
09bc			endif 
09bc					; for ease use ex 
09bc			 
09bc					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
09bc 21 c0 ed				ld hl, display_fb0 
09bf 22 db eb				ld (display_fb_active), hl 
09c2			 
09c2 cd 85 09		.mloop:		call clear_display 
09c5 cd a8 09				call update_display 
09c8			 
09c8					; draw selection id '>' at 1 
09c8			 
09c8					; init start of list display 
09c8			 
09c8 3e 05				ld a, 5 
09ca 32 5f eb				ld (store_tmp3), a   ; display row count 
09cd 3a 61 eb				ld a,( store_tmp2) 
09d0 32 62 eb				ld (store_tmp2+1), a   ; display item count 
09d3			 
09d3					 
09d3			.mitem:	 
09d3			 
09d3			 
09d3 3a 62 eb				ld a,(store_tmp2+1) 
09d6 6f					ld l, a 
09d7 26 00				ld h, 0 
09d9 29					add hl, hl 
09da ed 5b 63 eb			ld de, (store_tmp1) 
09de 19					add hl, de 
09df 7e					ld a, (hl) 
09e0 23					inc hl 
09e1 66					ld h,(hl) 
09e2 6f					ld l, a 
09e3			 
09e3 cd db 0b				call ishlzero 
09e6 28 1a				jr z, .mdone 
09e8			 
09e8 eb					ex de, hl 
09e9 3a 5f eb				ld a, (store_tmp3) 
09ec cd 98 09				call str_at_display 
09ef					 
09ef			 
09ef					; next item 
09ef 3a 62 eb				ld a, (store_tmp2+1) 
09f2 3c					inc a 
09f3 32 62 eb				ld (store_tmp2+1), a   ; display item count 
09f6			 
09f6			 		; next row 
09f6			 
09f6 3a 5f eb				ld a, (store_tmp3) 
09f9 c6 28				add display_cols 
09fb 32 5f eb				ld (store_tmp3), a 
09fe			 
09fe					; at end of screen? 
09fe			 
09fe fe 10				cp display_rows*4 
0a00 20 d1				jr nz, .mitem 
0a02			 
0a02			 
0a02			.mdone: 
0a02 cd db 0b				call ishlzero 
0a05 28 08				jr z, .nodn 
0a07			 
0a07 3e 78				ld a, display_row_4 
0a09 11 88 0a				ld de, .mdown 
0a0c cd 98 09				call str_at_display 
0a0f			 
0a0f					; draw options to fill the screens with active item on line 1 
0a0f					; if current option is 2 or more then display ^ in top 
0a0f			 
0a0f 3a 61 eb		.nodn:		ld a, (store_tmp2) 
0a12 fe 00				cp 0 
0a14 28 08				jr z, .noup 
0a16			 
0a16 3e 00				ld a, 0 
0a18 11 86 0a				ld de, .mup 
0a1b cd 98 09				call str_at_display 
0a1e			 
0a1e 3e 02		.noup:		ld a, 2 
0a20 11 84 0a				ld de, .msel 
0a23 cd 98 09				call str_at_display 
0a26			 
0a26					; if current option + 1 is not null then display V in bottom 
0a26					; get key 
0a26 cd a8 09				call update_display 
0a29			 
0a29			 
0a29					; handle key 
0a29			 
0a29 cd 75 58				call cin_wait 
0a2c			 
0a2c fe 05				cp KEY_UP 
0a2e 28 2b				jr z, .mgoup 
0a30 fe 61				cp 'a' 
0a32 28 27				jr z, .mgoup 
0a34 fe 0a				cp KEY_DOWN 
0a36 28 32				jr z, .mgod 
0a38 fe 7a				cp 'z' 
0a3a 28 2e				jr z, .mgod 
0a3c fe 20				cp ' ' 
0a3e 28 34				jr z, .goend 
0a40 fe 0c				cp KEY_RIGHT 
0a42 28 30				jr z, .goend 
0a44 fe 0d				cp KEY_CR 
0a46 28 2c				jr z, .goend 
0a48 fe 71				cp 'q' 
0a4a 28 0b				jr z, .goback 
0a4c			 
0a4c fe 0b				cp KEY_LEFT 
0a4e 28 07				jr z, .goback 
0a50 fe 08				cp KEY_BS 
0a52 28 03				jr z, .goback 
0a54 c3 c2 09				jp .mloop 
0a57			 
0a57			.goback: 
0a57 3e 00			ld a, 0 
0a59 18 1d			jr .goend2 
0a5b			 
0a5b				; move up one 
0a5b			.mgoup: 
0a5b 3a 61 eb				ld a, (store_tmp2) 
0a5e fe 00				cp 0 
0a60 ca c2 09				jp z, .mloop 
0a63 3d					dec a 
0a64 32 61 eb				ld (store_tmp2), a 
0a67 c3 c2 09				jp .mloop 
0a6a			 
0a6a				; move down one 
0a6a			.mgod: 
0a6a 3a 61 eb				ld a, (store_tmp2) 
0a6d 3c					inc a 
0a6e 32 61 eb				ld (store_tmp2), a 
0a71 c3 c2 09				jp .mloop 
0a74			 
0a74			 
0a74			.goend: 
0a74					; get selected item number 
0a74			 
0a74 3a 61 eb				ld a, (store_tmp2) 
0a77 3c					inc a 
0a78			 
0a78			.goend2: 
0a78 f5					push af 
0a79			 
0a79					; restore active fb 
0a79					; TODO BUG assumes fb1 
0a79			 
0a79 21 1f ed				ld hl, display_fb1 
0a7c 22 db eb				ld (display_fb_active), hl 
0a7f			 
0a7f					; restore main regs 
0a7f			 
0a7f			 
0a7f cd a8 09				call update_display 
0a82			 
0a82 f1					pop af 
0a83			 
0a83 c9				ret 
0a84			 
0a84 .. 00		.msel:   db ">",0 
0a86 .. 00		.mup:   db "^",0 
0a88 .. 00		.mdown:   db "v",0 
0a8a			 
0a8a			 
0a8a			; eof 
0a8a			 
# End of file firmware_display.asm
0a8a			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0a8a			; random number generators 
0a8a			 
0a8a			 
0a8a			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0a8a			 
0a8a			 
0a8a			;-----> Generate a random number 
0a8a			; output a=answer 0<=a<=255 
0a8a			; all registers are preserved except: af 
0a8a			random: 
0a8a e5			        push    hl 
0a8b d5			        push    de 
0a8c 2a bd eb		        ld      hl,(randData) 
0a8f ed 5f		        ld      a,r 
0a91 57			        ld      d,a 
0a92 5e			        ld      e,(hl) 
0a93 19			        add     hl,de 
0a94 85			        add     a,l 
0a95 ac			        xor     h 
0a96 22 bd eb		        ld      (randData),hl 
0a99 d1			        pop     de 
0a9a e1			        pop     hl 
0a9b c9			        ret 
0a9c			 
0a9c			 
0a9c			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0a9c			 
0a9c			 
0a9c			 
0a9c			;------LFSR------ 
0a9c			;James Montelongo 
0a9c			;optimized by Spencer Putt 
0a9c			;out: 
0a9c			; a = 8 bit random number 
0a9c			RandLFSR: 
0a9c 21 c3 eb		        ld hl,LFSRSeed+4 
0a9f 5e			        ld e,(hl) 
0aa0 23			        inc hl 
0aa1 56			        ld d,(hl) 
0aa2 23			        inc hl 
0aa3 4e			        ld c,(hl) 
0aa4 23			        inc hl 
0aa5 7e			        ld a,(hl) 
0aa6 47			        ld b,a 
0aa7 cb 13		        rl e  
0aa9 cb 12			rl d 
0aab cb 11		        rl c  
0aad 17				rla 
0aae cb 13		        rl e  
0ab0 cb 12			rl d 
0ab2 cb 11		        rl c  
0ab4 17				rla 
0ab5 cb 13		        rl e  
0ab7 cb 12			rl d 
0ab9 cb 11		        rl c  
0abb 17				rla 
0abc 67			        ld h,a 
0abd cb 13		        rl e  
0abf cb 12			rl d 
0ac1 cb 11		        rl c  
0ac3 17				rla 
0ac4 a8			        xor b 
0ac5 cb 13		        rl e  
0ac7 cb 12			rl d 
0ac9 ac			        xor h 
0aca a9			        xor c 
0acb aa			        xor d 
0acc 21 c5 eb		        ld hl,LFSRSeed+6 
0acf 11 c6 eb		        ld de,LFSRSeed+7 
0ad2 01 07 00		        ld bc,7 
0ad5 ed b8		        lddr 
0ad7 12			        ld (de),a 
0ad8 c9			        ret 
0ad9			 
0ad9			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ad9			 
0ad9			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ad9			 
0ad9			 
0ad9			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ad9			 
0ad9			prng16: 
0ad9			;Inputs: 
0ad9			;   (seed1) contains a 16-bit seed value 
0ad9			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ad9			;Outputs: 
0ad9			;   HL is the result 
0ad9			;   BC is the result of the LCG, so not that great of quality 
0ad9			;   DE is preserved 
0ad9			;Destroys: 
0ad9			;   AF 
0ad9			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ad9			;160cc 
0ad9			;26 bytes 
0ad9 2a b7 eb		    ld hl,(seed1) 
0adc 44			    ld b,h 
0add 4d			    ld c,l 
0ade 29			    add hl,hl 
0adf 29			    add hl,hl 
0ae0 2c			    inc l 
0ae1 09			    add hl,bc 
0ae2 22 b7 eb		    ld (seed1),hl 
0ae5 2a b5 eb		    ld hl,(seed2) 
0ae8 29			    add hl,hl 
0ae9 9f			    sbc a,a 
0aea e6 2d		    and %00101101 
0aec ad			    xor l 
0aed 6f			    ld l,a 
0aee 22 b5 eb		    ld (seed2),hl 
0af1 09			    add hl,bc 
0af2 c9			    ret 
0af3			 
0af3			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0af3			 
0af3			rand32: 
0af3			;Inputs: 
0af3			;   (seed1_0) holds the lower 16 bits of the first seed 
0af3			;   (seed1_1) holds the upper 16 bits of the first seed 
0af3			;   (seed2_0) holds the lower 16 bits of the second seed 
0af3			;   (seed2_1) holds the upper 16 bits of the second seed 
0af3			;   **NOTE: seed2 must be non-zero 
0af3			;Outputs: 
0af3			;   HL is the result 
0af3			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0af3			;Destroys: 
0af3			;   AF 
0af3			;Tested and passes all CAcert tests 
0af3			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0af3			;it has a period of 18,446,744,069,414,584,320 
0af3			;roughly 18.4 quintillion. 
0af3			;LFSR taps: 0,2,6,7  = 11000101 
0af3			;291cc 
0af3			;seed1_0=$+1 
0af3			;    ld hl,12345 
0af3			;seed1_1=$+1 
0af3			;    ld de,6789 
0af3			;    ld b,h 
0af3			;    ld c,l 
0af3			;    add hl,hl \ rl e \ rl d 
0af3			;    add hl,hl \ rl e \ rl d 
0af3			;    inc l 
0af3			;    add hl,bc 
0af3			;    ld (seed1_0),hl 
0af3			;    ld hl,(seed1_1) 
0af3			;    adc hl,de 
0af3			;    ld (seed1_1),hl 
0af3			;    ex de,hl 
0af3			;seed2_0=$+1 
0af3			;    ld hl,9876 
0af3			;seed2_1=$+1 
0af3			;    ld bc,54321 
0af3			;    add hl,hl \ rl c \ rl b 
0af3			;    ld (seed2_1),bc 
0af3			;    sbc a,a 
0af3			;    and %11000101 
0af3			;    xor l 
0af3			;    ld l,a 
0af3			;    ld (seed2_0),hl 
0af3			;    ex de,hl 
0af3			;    add hl,bc 
0af3			;    ret 
0af3			; 
0af3			 
0af3			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0af3			; 20 bytes, 86 cycles (excluding ret) 
0af3			 
0af3			; returns   hl = pseudorandom number 
0af3			; corrupts   a 
0af3			 
0af3			; generates 16-bit pseudorandom numbers with a period of 65535 
0af3			; using the xorshift method: 
0af3			 
0af3			; hl ^= hl << 7 
0af3			; hl ^= hl >> 9 
0af3			; hl ^= hl << 8 
0af3			 
0af3			; some alternative shift triplets which also perform well are: 
0af3			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0af3			 
0af3			;  org 32768 
0af3			 
0af3			xrnd: 
0af3 2a bb eb		  ld hl,(xrandc)       ; seed must not be 0 
0af6 3e 00		  ld a,0 
0af8 bd			  cp l 
0af9 20 02		  jr nz, .xrnd1 
0afb 2e 01		  ld l, 1 
0afd			.xrnd1: 
0afd			 
0afd 7c			  ld a,h 
0afe 1f			  rra 
0aff 7d			  ld a,l 
0b00 1f			  rra 
0b01 ac			  xor h 
0b02 67			  ld h,a 
0b03 7d			  ld a,l 
0b04 1f			  rra 
0b05 7c			  ld a,h 
0b06 1f			  rra 
0b07 ad			  xor l 
0b08 6f			  ld l,a 
0b09 ac			  xor h 
0b0a 67			  ld h,a 
0b0b			 
0b0b 22 bb eb		  ld (xrandc),hl 
0b0e			 
0b0e c9			  ret 
0b0f			;  
0b0f			 
0b0f			 
0b0f			;;;; int maths 
0b0f			 
0b0f			; https://map.grauw.nl/articles/mult_div_shifts.php 
0b0f			; Divide 16-bit values (with 16-bit result) 
0b0f			; In: Divide BC by divider DE 
0b0f			; Out: BC = result, HL = rest 
0b0f			; 
0b0f			Div16: 
0b0f 21 00 00		    ld hl,0 
0b12 78			    ld a,b 
0b13 06 08		    ld b,8 
0b15			Div16_Loop1: 
0b15 17			    rla 
0b16 ed 6a		    adc hl,hl 
0b18 ed 52		    sbc hl,de 
0b1a 30 01		    jr nc,Div16_NoAdd1 
0b1c 19			    add hl,de 
0b1d			Div16_NoAdd1: 
0b1d 10 f6		    djnz Div16_Loop1 
0b1f 17			    rla 
0b20 2f			    cpl 
0b21 47			    ld b,a 
0b22 79			    ld a,c 
0b23 48			    ld c,b 
0b24 06 08		    ld b,8 
0b26			Div16_Loop2: 
0b26 17			    rla 
0b27 ed 6a		    adc hl,hl 
0b29 ed 52		    sbc hl,de 
0b2b 30 01		    jr nc,Div16_NoAdd2 
0b2d 19			    add hl,de 
0b2e			Div16_NoAdd2: 
0b2e 10 f6		    djnz Div16_Loop2 
0b30 17			    rla 
0b31 2f			    cpl 
0b32 41			    ld b,c 
0b33 4f			    ld c,a 
0b34 c9			ret 
0b35			 
0b35			 
0b35			;http://z80-heaven.wikidot.com/math 
0b35			; 
0b35			;Inputs: 
0b35			;     DE and A are factors 
0b35			;Outputs: 
0b35			;     A is not changed 
0b35			;     B is 0 
0b35			;     C is not changed 
0b35			;     DE is not changed 
0b35			;     HL is the product 
0b35			;Time: 
0b35			;     342+6x 
0b35			; 
0b35			Mult16: 
0b35			 
0b35 06 08		     ld b,8          ;7           7 
0b37 21 00 00		     ld hl,0         ;10         10 
0b3a 29			       add hl,hl     ;11*8       88 
0b3b 07			       rlca          ;4*8        32 
0b3c 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0b3e 19			         add hl,de   ;--         -- 
0b3f 10 f9		       djnz $-5      ;13*7+8     99 
0b41 c9			ret 
0b42			 
0b42			; 
0b42			; Square root of 16-bit value 
0b42			; In:  HL = value 
0b42			; Out:  D = result (rounded down) 
0b42			; 
0b42			;Sqr16: 
0b42			;    ld de,#0040 
0b42			;    ld a,l 
0b42			;    ld l,h 
0b42			;    ld h,d 
0b42			;    or a 
0b42			;    ld b,8 
0b42			;Sqr16_Loop: 
0b42			;    sbc hl,de 
0b42			;    jr nc,Sqr16_Skip 
0b42			;    add hl,de 
0b42			;Sqr16_Skip: 
0b42			;    ccf 
0b42			;    rl d 
0b42			;    add a,a 
0b42			;    adc hl,hl 
0b42			;    add a,a 
0b42			;    adc hl,hl 
0b42			;    djnz Sqr16_Loop 
0b42			;    ret 
0b42			; 
0b42			; 
0b42			; Divide 8-bit values 
0b42			; In: Divide E by divider C 
0b42			; Out: A = result, B = rest 
0b42			; 
0b42			Div8: 
0b42 af			    xor a 
0b43 06 08		    ld b,8 
0b45			Div8_Loop: 
0b45 cb 13		    rl e 
0b47 17			    rla 
0b48 91			    sub c 
0b49 30 01		    jr nc,Div8_NoAdd 
0b4b 81			    add a,c 
0b4c			Div8_NoAdd: 
0b4c 10 f7		    djnz Div8_Loop 
0b4e 47			    ld b,a 
0b4f 7b			    ld a,e 
0b50 17			    rla 
0b51 2f			    cpl 
0b52 c9			    ret 
0b53			 
0b53			; 
0b53			; Multiply 8-bit value with a 16-bit value (unrolled) 
0b53			; In: Multiply A with DE 
0b53			; Out: HL = result 
0b53			; 
0b53			Mult12U: 
0b53 2e 00		    ld l,0 
0b55 87			    add a,a 
0b56 30 01		    jr nc,Mult12U_NoAdd0 
0b58 19			    add hl,de 
0b59			Mult12U_NoAdd0: 
0b59 29			    add hl,hl 
0b5a 87			    add a,a 
0b5b 30 01		    jr nc,Mult12U_NoAdd1 
0b5d 19			    add hl,de 
0b5e			Mult12U_NoAdd1: 
0b5e 29			    add hl,hl 
0b5f 87			    add a,a 
0b60 30 01		    jr nc,Mult12U_NoAdd2 
0b62 19			    add hl,de 
0b63			Mult12U_NoAdd2: 
0b63 29			    add hl,hl 
0b64 87			    add a,a 
0b65 30 01		    jr nc,Mult12U_NoAdd3 
0b67 19			    add hl,de 
0b68			Mult12U_NoAdd3: 
0b68 29			    add hl,hl 
0b69 87			    add a,a 
0b6a 30 01		    jr nc,Mult12U_NoAdd4 
0b6c 19			    add hl,de 
0b6d			Mult12U_NoAdd4: 
0b6d 29			    add hl,hl 
0b6e 87			    add a,a 
0b6f 30 01		    jr nc,Mult12U_NoAdd5 
0b71 19			    add hl,de 
0b72			Mult12U_NoAdd5: 
0b72 29			    add hl,hl 
0b73 87			    add a,a 
0b74 30 01		    jr nc,Mult12U_NoAdd6 
0b76 19			    add hl,de 
0b77			Mult12U_NoAdd6: 
0b77 29			    add hl,hl 
0b78 87			    add a,a 
0b79 d0			    ret nc 
0b7a 19			    add hl,de 
0b7b c9			    ret 
0b7c			 
0b7c			; 
0b7c			; Multiply 8-bit value with a 16-bit value (right rotating) 
0b7c			; In: Multiply A with DE 
0b7c			;      Put lowest value in A for most efficient calculation 
0b7c			; Out: HL = result 
0b7c			; 
0b7c			Mult12R: 
0b7c 21 00 00		    ld hl,0 
0b7f			Mult12R_Loop: 
0b7f cb 3f		    srl a 
0b81 30 01		    jr nc,Mult12R_NoAdd 
0b83 19			    add hl,de 
0b84			Mult12R_NoAdd: 
0b84 cb 23		    sla e 
0b86 cb 12		    rl d 
0b88 b7			    or a 
0b89 c2 7f 0b		    jp nz,Mult12R_Loop 
0b8c c9			    ret 
0b8d			 
0b8d			; 
0b8d			; Multiply 16-bit values (with 32-bit result) 
0b8d			; In: Multiply BC with DE 
0b8d			; Out: BCHL = result 
0b8d			; 
0b8d			Mult32: 
0b8d 79			    ld a,c 
0b8e 48			    ld c,b 
0b8f 21 00 00		    ld hl,0 
0b92 06 10		    ld b,16 
0b94			Mult32_Loop: 
0b94 29			    add hl,hl 
0b95 17			    rla 
0b96 cb 11		    rl c 
0b98 30 07		    jr nc,Mult32_NoAdd 
0b9a 19			    add hl,de 
0b9b ce 00		    adc a,0 
0b9d d2 a1 0b		    jp nc,Mult32_NoAdd 
0ba0 0c			    inc c 
0ba1			Mult32_NoAdd: 
0ba1 10 f1		    djnz Mult32_Loop 
0ba3 41			    ld b,c 
0ba4 4f			    ld c,a 
0ba5 c9			    ret 
0ba6			 
0ba6			 
0ba6			 
0ba6			; 
0ba6			; Multiply 8-bit values 
0ba6			; In:  Multiply H with E 
0ba6			; Out: HL = result 
0ba6			; 
0ba6			Mult8: 
0ba6 16 00		    ld d,0 
0ba8 6a			    ld l,d 
0ba9 06 08		    ld b,8 
0bab			Mult8_Loop: 
0bab 29			    add hl,hl 
0bac 30 01		    jr nc,Mult8_NoAdd 
0bae 19			    add hl,de 
0baf			Mult8_NoAdd: 
0baf 10 fa		    djnz Mult8_Loop 
0bb1 c9			    ret 
0bb2			 
0bb2			 
0bb2			 
0bb2			 
0bb2			 
0bb2			 
0bb2			 
0bb2			 
0bb2			;;http://z80-heaven.wikidot.com/math 
0bb2			;;This divides DE by BC, storing the result in DE, remainder in HL 
0bb2			; 
0bb2			;DE_Div_BC:          ;1281-2x, x is at most 16 
0bb2			;     ld a,16        ;7 
0bb2			;     ld hl,0        ;10 
0bb2			;     jp $+5         ;10 
0bb2			;.DivLoop: 
0bb2			;       add hl,bc    ;-- 
0bb2			;       dec a        ;64 
0bb2			;       jr z,.DivLoopEnd        ;86 
0bb2			; 
0bb2			;       sla e        ;128 
0bb2			;       rl d         ;128 
0bb2			;       adc hl,hl    ;240 
0bb2			;       sbc hl,bc    ;240 
0bb2			;       jr nc,.DivLoop ;23|21 
0bb2			;       inc e        ;-- 
0bb2			;       jp .DivLoop+1 
0bb2			; 
0bb2			;.DivLoopEnd: 
0bb2			 
0bb2			;HL_Div_C: 
0bb2			;Inputs: 
0bb2			;     HL is the numerator 
0bb2			;     C is the denominator 
0bb2			;Outputs: 
0bb2			;     A is the remainder 
0bb2			;     B is 0 
0bb2			;     C is not changed 
0bb2			;     DE is not changed 
0bb2			;     HL is the quotient 
0bb2			; 
0bb2			;       ld b,16 
0bb2			;       xor a 
0bb2			;         add hl,hl 
0bb2			;         rla 
0bb2			;         cp c 
0bb2			;         jr c,$+4 
0bb2			;           inc l 
0bb2			;           sub c 
0bb2			;         djnz $-7 
0bb2			 
0bb2			; https://plutiedev.com/z80-add-8bit-to-16bit 
0bb2			 
0bb2			addatohl: 
0bb2 85			    add   a, l    ; A = A+L 
0bb3 6f			    ld    l, a    ; L = A+L 
0bb4 8c			    adc   a, h    ; A = A+L+H+carry 
0bb5 95			    sub   l       ; A = H+carry 
0bb6 67			    ld    h, a    ; H = H+carry 
0bb7 c9			ret 
0bb8			 
0bb8			addatode: 
0bb8 83			    add   a, e    ; A = A+L 
0bb9 5f			    ld    e, a    ; L = A+L 
0bba 8a			    adc   a, d    ; A = A+L+H+carry 
0bbb 93			    sub   e       ; A = H+carry 
0bbc 57			    ld    d, a    ; H = H+carry 
0bbd c9			ret 
0bbe			 
0bbe			 
0bbe			addatobc: 
0bbe 81			    add   a, c    ; A = A+L 
0bbf 4f			    ld    c, a    ; L = A+L 
0bc0 88			    adc   a, b    ; A = A+L+H+carry 
0bc1 91			    sub   c       ; A = H+carry 
0bc2 47			    ld    b, a    ; H = H+carry 
0bc3 c9			ret 
0bc4			 
0bc4			subafromhl: 
0bc4			   ; If A=0 do nothing 
0bc4			    ; Otherwise flip A's sign. Since 
0bc4			    ; the upper byte becomes -1, also 
0bc4			    ; substract 1 from H. 
0bc4 ed 44		    neg 
0bc6 ca cf 0b		    jp    z, Skip 
0bc9 25			    dec   h 
0bca			     
0bca			    ; Now add the low byte as usual 
0bca			    ; Two's complement takes care of 
0bca			    ; ensuring the result is correct 
0bca 85			    add   a, l 
0bcb 6f			    ld    l, a 
0bcc 8c			    adc   a, h 
0bcd 95			    sub   l 
0bce 67			    ld    h, a 
0bcf			Skip: 
0bcf c9				ret 
0bd0			 
0bd0			 
0bd0			; compare hl and de 
0bd0			; returns:  
0bd0			; if hl = de, z=1, s=0, c0=0 
0bd0			; if hl > de, z=0, s=0, c=0 
0bd0			; if hl < de, z=0, s=1, c=1 
0bd0			cmp16:	 
0bd0 b7				or a 
0bd1 ed 52			sbc hl,de 
0bd3 e0				ret po 
0bd4 7c				ld a,h 
0bd5 1f				rra 
0bd6 ee 40			xor 01000000B 
0bd8 37				scf 
0bd9 8f				adc a,a 
0bda c9				ret 
0bdb			 
0bdb			 
0bdb			; test if hl contains zero   - A is destroyed 
0bdb			 
0bdb			ishlzero:    
0bdb b7				or a     ; reset flags 
0bdc 7c				ld a, h 
0bdd b5				or l        	 
0bde			 
0bde c9				ret 
0bdf			 
0bdf			 
0bdf			 
0bdf			 
0bdf			if FORTH_ENABLE_FLOATMATH 
0bdf			;include "float/bbcmath.z80" 
0bdf			include "float/lpfpcalc.asm" 
0bdf			endif 
0bdf			 
0bdf			 
0bdf			; eof 
0bdf			 
# End of file firmware_maths.asm
0bdf			include "firmware_strings.asm"   ; string handling  
0bdf			 
0bdf			 
0bdf			; TODO string len 
0bdf			; input text string, end on cr with zero term 
0bdf			; a offset into frame buffer to start prompt 
0bdf			; d is max length 
0bdf			; e is display size TODO 
0bdf			; c is current cursor position 
0bdf			; hl is ptr to where string will be stored 
0bdf			 
0bdf			 
0bdf			; TODO check limit of buffer for new inserts 
0bdf			; TODO check insert does not push beyond buffer 
0bdf			; TODO scroll in a limited display area 
0bdf			; TODO scroll whole screen on page wrap 
0bdf			 
0bdf			 
0bdf			; TODO handle KEY_PREVWORD 
0bdf			; TODO handle KEY_NEXTWORD 
0bdf			; TODO handle KEY_HOME 
0bdf			; TODO handle KEY_END 
0bdf			; TODO use LCD cursor? 
0bdf			 
0bdf 32 73 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0be2 81					add c 
0be3 32 71 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0be6 22 76 ee				ld (input_start), hl     ; save ptr to buffer 
0be9 79					ld a, c 
0bea cd b2 0b				call addatohl 
0bed 22 78 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0bf0 7a					ld a,d 
0bf1 32 75 ee			        ld (input_size), a       ; save length of input area 
0bf4 79					ld a, c 
0bf5 32 64 ee				ld (input_cursor),a      ; init cursor start position  
0bf8 7b					ld a,e 
0bf9 32 74 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0bfc					 
0bfc					 
0bfc			 
0bfc			;		ld a,(input_ptr) 
0bfc			;		ld (input_under_cursor),a 	; save what is under the cursor 
0bfc			 
0bfc			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0bfc					; init cursor shape if not set by the cin routines 
0bfc 21 d3 eb				ld hl, cursor_shape 
0bff 3e ff				ld a, 255 
0c01 77					ld (hl), a 
0c02 23					inc hl 
0c03 3e 00				ld a, 0 
0c05 77					ld (hl), a 
0c06			 
0c06 3e 0f				ld a, CUR_BLINK_RATE 
0c08 32 6f ee				ld (input_cur_flash), a 
0c0b 3e 01				ld a, 1 
0c0d 32 6e ee				ld (input_cur_onoff),a 
0c10			 
0c10			;	if DEBUG_INPUT 
0c10			;		push af 
0c10			;		ld a, 'I' 
0c10			;		ld (debug_mark),a 
0c10			;		pop af 
0c10			;		CALLMONITOR 
0c10			;	endif 
0c10			.is1:		; main entry loop 
0c10			 
0c10			 
0c10			 
0c10					; pause 1ms 
0c10			 
0c10 3e 01				ld a, 1 
0c12 cd df 08				call aDelayInMS 
0c15			 
0c15					; dec flash counter 
0c15 3a 6f ee				ld a, (input_cur_flash) 
0c18 3d					dec a 
0c19 32 6f ee				ld (input_cur_flash), a 
0c1c fe 00				cp 0 
0c1e 20 0d				jr nz, .nochgstate 
0c20			 
0c20			 
0c20					; change state 
0c20 3a 6e ee				ld a,(input_cur_onoff) 
0c23 ed 44				neg 
0c25 32 6e ee				ld (input_cur_onoff),a 
0c28			 
0c28			 
0c28					; reset on change of state 
0c28 3e 0f				ld a, CUR_BLINK_RATE 
0c2a 32 6f ee				ld (input_cur_flash), a 
0c2d			 
0c2d			.nochgstate: 
0c2d					 
0c2d					 
0c2d			 
0c2d					; display cursor  
0c2d			 
0c2d			;		ld hl, (input_start) 
0c2d			;		ld a, (input_cursor) 
0c2d			;		call addatohl 
0c2d			 
0c2d					; get char under cursor and replace with cursor 
0c2d 2a 78 ee		ld hl, (input_ptr) 
0c30			;		ld a, (hl) 
0c30			;		ld (input_under_cursor),a 
0c30			;		ld a, '_' 
0c30			;		ld (hl), a 
0c30			 
0c30					; display string 
0c30			 
0c30 ed 5b 76 ee			ld de, (input_start) 
0c34 3a 73 ee				ld a, (input_at_pos) 
0c37 cd 98 09				call str_at_display 
0c3a			;	        call update_display 
0c3a			 
0c3a					; find place to put the cursor 
0c3a			;		add h 
0c3a			;		ld l, display_row_1 
0c3a			;		sub l 
0c3a			; (input_at_pos) 
0c3a					;ld c, a 
0c3a			;		ld a, (input_cursor) 
0c3a			;		ld l, (input_at_pos) 
0c3a			;		;ld b, h 
0c3a			;		add l 
0c3a			;		ld (input_at_cursor),a 
0c3a					;ld l,h 
0c3a			 
0c3a			;		ld h, 0 
0c3a			;		ld l,(input_at_pos) 
0c3a			;		ld a, (input_cursor) 
0c3a			;		call addatohl 
0c3a			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0c3a			;		call subafromhl 
0c3a			;		ld a,l 
0c3a			;		ld (input_at_cursor), a 
0c3a			 
0c3a				if DEBUG_INPUT 
0c3a					ld a, (hardware_diag) 
0c3a					cp 0 
0c3a					jr z, .skip_input_diag 
0c3a			 
0c3a					ld a,(input_at_pos) 
0c3a					ld hl, LFSRSeed 
0c3a					call hexout 
0c3a					ld a, (input_cursor) 
0c3a					ld hl, LFSRSeed+2 
0c3a					call hexout 
0c3a					ld a,(input_at_cursor) 
0c3a					ld hl, LFSRSeed+4 
0c3a					call hexout 
0c3a			 
0c3a					ld a,(input_cur_onoff) 
0c3a					ld hl, LFSRSeed+6 
0c3a					call hexout 
0c3a			 
0c3a					ld a,(input_cur_flash) 
0c3a					ld hl, LFSRSeed+8 
0c3a					call hexout 
0c3a			 
0c3a					ld a,(input_len) 
0c3a					ld hl, LFSRSeed+10 
0c3a					call hexout 
0c3a					ld hl, LFSRSeed+12 
0c3a					ld a, 0 
0c3a					ld (hl),a 
0c3a					ld a, display_row_4 
0c3a					ld de, LFSRSeed 
0c3a					call str_at_display 
0c3a					.skip_input_diag: 
0c3a				endif 
0c3a			 
0c3a					; decide on if we are showing the cursor this time round 
0c3a			 
0c3a 3a 6e ee				ld a, (input_cur_onoff) 
0c3d fe ff				cp 255 
0c3f 28 13				jr z, .skipcur 
0c41			 
0c41			 
0c41 3a 71 ee				ld a,(input_at_cursor) 
0c44 11 d3 eb				ld de, cursor_shape 
0c47 cd 98 09				call str_at_display 
0c4a			 
0c4a					; save length of current input string 
0c4a 2a 76 ee				ld hl, (input_start) 
0c4d cd 10 10				call strlenz 
0c50 7d					ld a,l 
0c51 32 69 ee				ld (input_len),a 
0c54			 
0c54			.skipcur: 
0c54			 
0c54 cd a8 09			        call update_display 
0c57					 
0c57			 
0c57			 
0c57					; wait 
0c57				 
0c57					; TODO loop without wait to flash the cursor and char under cursor	 
0c57 cd 7d 58				call cin    ; _wait 
0c5a			 
0c5a fe 00				cp 0 
0c5c ca 10 0c				jp z, .is1 
0c5f			 
0c5f					; get ptr to char to input into 
0c5f			 
0c5f 4f					ld c,a 
0c60 2a 76 ee				ld hl, (input_start) 
0c63 3a 64 ee				ld a, (input_cursor) 
0c66 cd b2 0b				call addatohl 
0c69 22 78 ee				ld (input_ptr), hl 
0c6c 79					ld a,c 
0c6d			 
0c6d					; replace char under cursor 
0c6d			 
0c6d			;		ld hl, (input_ptr) 
0c6d			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0c6d			;		ld (hl), a 
0c6d			 
0c6d			;	if DEBUG_INPUT 
0c6d			;		push af 
0c6d			;		ld a, 'i' 
0c6d			;		ld (debug_mark),a 
0c6d			;		pop af 
0c6d			;		CALLMONITOR 
0c6d			;	endif 
0c6d fe 0e				cp KEY_HOME 
0c6f 20 0e				jr nz, .iske 
0c71			 
0c71 3a 73 ee				ld a, (input_at_pos) 
0c74 32 71 ee				ld (input_at_cursor),a 
0c77 3e 00				ld a, 0 
0c79 32 64 ee				ld (input_cursor), a 
0c7c c3 10 0c				jp .is1 
0c7f					 
0c7f fe 0f		.iske:		cp KEY_END 
0c81 20 03				jr nz, .isknw 
0c83 c3 10 0c				jp .is1 
0c86			 
0c86 fe 06		.isknw:		cp KEY_NEXTWORD 
0c88 20 1b				jr nz, .iskpw 
0c8a			 
0c8a 2a 78 ee		.isknwm:	ld hl, (input_ptr) 
0c8d 7e					ld a,(hl)	 
0c8e fe 00				cp 0 
0c90 ca 10 0c				jp z, .is1    ; end of string 
0c93 fe 20				cp ' ' 
0c95 ca 10 0c				jp z, .is1    ; end of word 
0c98 23					inc hl 
0c99 22 78 ee				ld (input_ptr), hl 
0c9c 3a 71 ee				ld a, (input_at_cursor) 
0c9f 3c					inc a 
0ca0 32 71 ee				ld (input_at_cursor), a 
0ca3 18 e5				jr .isknwm 
0ca5			 
0ca5 fe 07		.iskpw:		cp KEY_PREVWORD 
0ca7 20 1b				jr nz, .iskl 
0ca9			.iskpwm:	 
0ca9 2a 78 ee				ld hl, (input_ptr) 
0cac 7e					ld a,(hl)	 
0cad fe 00				cp 0  
0caf ca 10 0c				jp z, .is1    ; end of string 
0cb2 fe 20				cp ' ' 
0cb4 ca 10 0c				jp z, .is1    ; end of word 
0cb7 2b					dec hl 
0cb8 22 78 ee				ld (input_ptr), hl 
0cbb 3a 71 ee				ld a, (input_at_cursor) 
0cbe 3d					dec a 
0cbf 32 71 ee				ld (input_at_cursor), a 
0cc2 18 e5				jr .iskpwm 
0cc4			 
0cc4			 
0cc4 fe 0b		.iskl:		cp KEY_LEFT 
0cc6 20 27				jr nz, .isk1 
0cc8			 
0cc8 3a 64 ee				ld a, (input_cursor) 
0ccb			 
0ccb fe 00				cp 0 
0ccd ca 10 0c				jp z, .is1 		; at start of line to ignore  
0cd0			 
0cd0 3d					dec  a 		; TODO check underflow 
0cd1 32 64 ee				ld (input_cursor), a 
0cd4			 
0cd4 2a 78 ee				ld hl, (input_ptr) 
0cd7 2b					dec hl 
0cd8 22 78 ee				ld (input_ptr), hl 
0cdb					 
0cdb 3a 71 ee				ld a, (input_at_cursor) 
0cde 3d					dec a 
0cdf 32 71 ee				ld (input_at_cursor), a 
0ce2			 
0ce2 3e 01				ld a, 1		; show cursor moving 
0ce4 32 6e ee				ld (input_cur_onoff),a 
0ce7 3e 0f				ld a, CUR_BLINK_RATE 
0ce9 32 6f ee				ld (input_cur_flash), a 
0cec			 
0cec c3 10 0c				jp .is1 
0cef			 
0cef fe 0c		.isk1:		cp KEY_RIGHT 
0cf1 20 2a				jr nz, .isk2 
0cf3			 
0cf3 3a 69 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0cf6 5f					ld e,a 
0cf7 3a 64 ee				ld a, (input_cursor) 
0cfa bb					cp e 
0cfb ca 10 0c				jp z, .is1		; at the end of string so dont go right 
0cfe			 
0cfe 3c					inc  a 		; TODO check overflow 
0cff 32 64 ee				ld (input_cursor), a 
0d02			 
0d02 3a 71 ee				ld a, (input_at_cursor) 
0d05 3c					inc a 
0d06 32 71 ee				ld (input_at_cursor), a 
0d09			 
0d09 2a 78 ee				ld hl, (input_ptr) 
0d0c 23					inc hl 
0d0d 22 78 ee				ld (input_ptr), hl 
0d10			 
0d10 3e 01				ld a, 1		; show cursor moving 
0d12 32 6e ee				ld (input_cur_onoff),a 
0d15 3e 0f				ld a, CUR_BLINK_RATE 
0d17 32 6f ee				ld (input_cur_flash), a 
0d1a			 
0d1a c3 10 0c				jp .is1 
0d1d			 
0d1d fe 05		.isk2:		cp KEY_UP 
0d1f			 
0d1f 20 26				jr nz, .isk3 
0d21			 
0d21					; swap last command with the current on 
0d21			 
0d21					; move cursor to start of string 
0d21 2a 76 ee				ld hl, (input_start) 
0d24 22 78 ee				ld (input_ptr), hl 
0d27			 
0d27 3a 73 ee				ld a, (input_at_pos) 
0d2a 32 71 ee				ld (input_at_cursor), a 
0d2d			 
0d2d 3e 00				ld a, 0 
0d2f 32 64 ee				ld (input_cursor), a 
0d32					 
0d32					; swap input and last command buffers 
0d32			 
0d32 21 87 e6				ld hl, os_cli_cmd 
0d35 11 86 e7				ld de, os_last_cmd 
0d38 06 ff				ld b, 255 
0d3a 7e			.swap1:		ld a, (hl) 
0d3b 4f					ld c,a 
0d3c 1a					ld a, (de) 
0d3d 77					ld (hl), a 
0d3e 79					ld a,c 
0d3f 12					ld (de),a 
0d40 23					inc hl 
0d41 13					inc de 
0d42 10 f6				djnz .swap1 
0d44			 
0d44			 
0d44			 
0d44			 
0d44			 
0d44 c3 10 0c				jp .is1 
0d47			 
0d47 fe 08		.isk3:		cp KEY_BS 
0d49 20 3c				jr nz, .isk4 
0d4b			 
0d4b 3a 64 ee				ld a, (input_cursor) 
0d4e			 
0d4e fe 00				cp 0 
0d50 ca 10 0c				jp z, .is1 		; at start of line to ignore  
0d53			 
0d53 3d					dec  a 		; TODO check underflow 
0d54 32 64 ee				ld (input_cursor), a 
0d57			 
0d57					; hl is source 
0d57					; de needs to be source - 1 
0d57			 
0d57			;		ld a, 0 
0d57			;		dec hl 
0d57			;		ld (hl), a 
0d57			 
0d57 2a 78 ee				ld hl, (input_ptr) 
0d5a 2b					dec hl 
0d5b 22 78 ee				ld (input_ptr), hl 
0d5e			 
0d5e					; shift all data 
0d5e			 
0d5e e5					push hl 
0d5f 23					inc hl 
0d60 d1					pop de 
0d61 3a 69 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0d64 4f					ld c,a 
0d65 06 00				ld b,0 
0d67 ed b0				ldir  
0d69			 
0d69			 
0d69			 
0d69			 
0d69 3a 71 ee				ld a, (input_at_cursor) 
0d6c 3d					dec a 
0d6d 32 71 ee				ld (input_at_cursor), a 
0d70			 
0d70			 
0d70 3e 01				ld a, 1		; show cursor moving 
0d72 32 6e ee				ld (input_cur_onoff),a 
0d75 3e 0f				ld a, CUR_BLINK_RATE 
0d77 32 6f ee				ld (input_cur_flash), a 
0d7a			 
0d7a					; remove char 
0d7a 3a 71 ee				ld a, (input_at_cursor) 
0d7d 3c					inc a 
0d7e 11 08 0e				ld de,.iblank 
0d81 cd 98 09				call str_at_display 
0d84			 
0d84 c3 10 0c				jp .is1 
0d87			 
0d87 fe 0d		.isk4:		cp KEY_CR 
0d89 28 6c				jr z, .endinput 
0d8b			 
0d8b					; else add the key press to the end 
0d8b			 
0d8b 4f					ld c, a			; save key pressed 
0d8c			 
0d8c 7e					ld a,(hl)		; get what is currently under char 
0d8d			 
0d8d fe 00				cp 0			; we are at the end of the string 
0d8f 20 2f				jr nz, .onchar 
0d91					 
0d91					; add a char to the end of the string 
0d91				 
0d91 71					ld (hl),c 
0d92 23					inc hl 
0d93			;		ld a,' ' 
0d93			;		ld (hl),a 
0d93			;		inc hl 
0d93 3e 00				ld a,0 
0d95 77					ld (hl),a 
0d96 2b					dec hl 
0d97			 
0d97 3a 64 ee				ld a, (input_cursor) 
0d9a 3c					inc a				; TODO check max string length and scroll  
0d9b 32 64 ee				ld (input_cursor), a		; inc cursor pos 
0d9e							 
0d9e 3a 71 ee				ld a, (input_at_cursor) 
0da1 3c					inc a 
0da2 32 71 ee				ld (input_at_cursor), a 
0da5			 
0da5 2a 78 ee				ld hl, (input_ptr) 
0da8 23					inc hl 
0da9 22 78 ee				ld (input_ptr), hl 
0dac			 
0dac 2a 78 ee				ld hl, (input_ptr) 
0daf 23					inc hl 
0db0 22 78 ee				ld (input_ptr), hl 
0db3			;	if DEBUG_INPUT 
0db3			;		push af 
0db3			;		ld a, '+' 
0db3			;		ld (debug_mark),a 
0db3			;		pop af 
0db3			;		CALLMONITOR 
0db3			;	endif 
0db3 3e 01				ld a, 1		; show cursor moving 
0db5 32 6e ee				ld (input_cur_onoff),a 
0db8 3e 0f				ld a, CUR_BLINK_RATE 
0dba 32 6f ee				ld (input_cur_flash), a 
0dbd c3 10 0c				jp .is1 
0dc0					 
0dc0			 
0dc0			 
0dc0					; if on a char then insert 
0dc0			.onchar: 
0dc0			 
0dc0					; TODO over flow check: make sure insert does not blow out buffer 
0dc0			 
0dc0					; need to do some maths to use lddr 
0dc0			 
0dc0 e5					push hl   ; save char pos 
0dc1 c5					push bc 
0dc2			 
0dc2 2a 76 ee				ld hl, (input_start) 
0dc5 3a 69 ee				ld a, (input_len) 
0dc8 cd b2 0b				call addatohl  		; end of string 
0dcb 23					inc hl 
0dcc 23					inc hl		; past zero term 
0dcd e5					push hl 
0dce 23					inc hl 
0dcf e5					push hl  
0dd0			 
0dd0								; start and end of lddr set, now how much to move? 
0dd0			 
0dd0							 
0dd0 3a 64 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0dd3 47					ld b,a 
0dd4 3a 69 ee				ld a,(input_len) 
0dd7 5f					ld e,a 
0dd8 90					sub b 
0dd9 3c					inc a		;?? 
0dda 3c					inc a		;?? 
0ddb 3c					inc a		;?? 
0ddc			 
0ddc 06 00				ld b,0 
0dde 4f					ld c,a 
0ddf			 
0ddf				if DEBUG_INPUT 
0ddf					push af 
0ddf					ld a, 'i' 
0ddf					ld (debug_mark),a 
0ddf					pop af 
0ddf			;		CALLMONITOR 
0ddf				endif 
0ddf d1					pop de 
0de0 e1					pop hl 
0de1				if DEBUG_INPUT 
0de1					push af 
0de1					ld a, 'I' 
0de1					ld (debug_mark),a 
0de1					pop af 
0de1			;		CALLMONITOR 
0de1				endif 
0de1 ed b8				lddr 
0de3				 
0de3			 
0de3			 
0de3					; TODO have a key for insert/overwrite mode???? 
0de3 c1					pop bc 
0de4 e1					pop hl 
0de5 71					ld (hl), c		; otherwise overwrite current char 
0de6					 
0de6			 
0de6			 
0de6			 
0de6 3a 64 ee				ld a, (input_cursor) 
0de9 3c					inc  a 		; TODO check overflow 
0dea 32 64 ee				ld (input_cursor), a 
0ded			 
0ded 3a 71 ee				ld a, (input_at_cursor) 
0df0 3c					inc a 
0df1 32 71 ee				ld (input_at_cursor), a 
0df4			 
0df4 c3 10 0c				jp .is1 
0df7			 
0df7			.endinput:	; TODO look for end of string 
0df7			 
0df7					; add trailing space for end of token 
0df7			 
0df7 2a 76 ee				ld hl, (input_start) 
0dfa 3a 69 ee				ld a,(input_len) 
0dfd cd b2 0b				call addatohl 
0e00 3e 20				ld a, ' ' 
0e02 77					ld (hl),a 
0e03					; TODO eof of parse marker 
0e03			 
0e03 23					inc hl 
0e04 3e 00				ld a, 0 
0e06 77					ld (hl),a 
0e07			 
0e07			 
0e07 c9					ret 
0e08			 
0e08 .. 00		.iblank: db " ",0 
0e0a			 
0e0a			 
0e0a 32 73 ee		input_str_prev:	ld (input_at_pos), a 
0e0d 22 76 ee				ld (input_start), hl 
0e10 3e 01				ld a,1			; add cursor 
0e12 77					ld (hl),a 
0e13 23					inc hl 
0e14 3e 00				ld a,0 
0e16 77					ld (hl),a 
0e17 22 78 ee				ld (input_ptr), hl 
0e1a 7a					ld a,d 
0e1b 32 75 ee				ld (input_size), a 
0e1e 3e 00				ld a,0 
0e20 32 64 ee				ld (input_cursor),a 
0e23			.instr1:	 
0e23			 
0e23					; TODO do block cursor 
0e23					; TODO switch cursor depending on the modifer key 
0e23			 
0e23					; update cursor shape change on key hold 
0e23			 
0e23 2a 78 ee				ld hl, (input_ptr) 
0e26 2b					dec hl 
0e27 3a d3 eb				ld a,(cursor_shape) 
0e2a 77					ld (hl), a 
0e2b			 
0e2b					; display entered text 
0e2b 3a 73 ee				ld a,(input_at_pos) 
0e2e cd 92 57		            	CALL fLCD_Pos       ;Position cursor to location in A 
0e31 ed 5b 76 ee	            	LD   de, (input_start) 
0e35 cd 87 57		            	CALL fLCD_Str       ;Display string pointed to by DE 
0e38			 
0e38 cd 7d 58				call cin 
0e3b fe 00				cp 0 
0e3d 28 e4				jr z, .instr1 
0e3f			 
0e3f					; proecess keyboard controls first 
0e3f			 
0e3f 2a 78 ee				ld hl,(input_ptr) 
0e42			 
0e42 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0e44 28 5a				jr z, .instrcr 
0e46			 
0e46 fe 08				cp KEY_BS 	; back space 
0e48 20 0f				jr nz, .instr2 
0e4a					; process back space 
0e4a			 
0e4a					; TODO stop back space if at start of string 
0e4a 2b					dec hl 
0e4b 2b					dec hl ; to over write cursor 
0e4c 3a d3 eb				ld a,(cursor_shape) 
0e4f					;ld a,0 
0e4f 77					ld (hl),a 
0e50 23					inc hl 
0e51 3e 20				ld a," " 
0e53 77					ld (hl),a 
0e54 22 78 ee				ld (input_ptr),hl 
0e57					 
0e57			 
0e57 18 ca				jr .instr1 
0e59			 
0e59 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0e5b 20 06				jr nz, .instr3 
0e5d 2b					dec hl 
0e5e 22 78 ee				ld (input_ptr),hl 
0e61 18 c0				jr .instr1 
0e63				 
0e63 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0e65 20 06				jr nz, .instr4 
0e67 23					inc hl 
0e68 22 78 ee				ld (input_ptr),hl 
0e6b 18 b6				jr .instr1 
0e6d			 
0e6d fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0e6f 20 06				jr nz, .instr5 
0e71 2b					dec hl 
0e72 22 78 ee				ld (input_ptr),hl 
0e75 18 ac				jr .instr1 
0e77			 
0e77 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0e79 20 06				jr nz, .instr6 
0e7b 2b					dec hl 
0e7c 22 78 ee				ld (input_ptr),hl 
0e7f 18 a2				jr .instr1 
0e81 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0e83 20 0b				jr nz, .instrnew 
0e85			 
0e85 21 60 e3			ld hl, scratch 
0e88 11 86 e7			ld de, os_last_cmd 
0e8b cd a9 0e			call strcpy 
0e8e 18 93				jr .instr1 
0e90			 
0e90			 
0e90			.instrnew:	; no special key pressed to see if we have room to store it 
0e90			 
0e90					; TODO do string size test 
0e90			 
0e90 2b					dec hl ; to over write cursor 
0e91 77					ld (hl),a 
0e92 23					inc hl 
0e93 3a d3 eb				ld a,(cursor_shape) 
0e96 77					ld (hl),a 
0e97 23					inc hl 
0e98 3e 00				ld a,0 
0e9a 77					ld (hl),a 
0e9b			 
0e9b 22 78 ee				ld (input_ptr),hl 
0e9e					 
0e9e 18 83				jr .instr1 
0ea0 2b			.instrcr:	dec hl		; remove cursor 
0ea1 3e 20				ld a,' '	; TODO add a trailing space for safety 
0ea3 77					ld (hl),a 
0ea4 23					inc hl 
0ea5 3e 00				ld a,0 
0ea7 77					ld (hl),a 
0ea8			 
0ea8			 
0ea8					; if at end of line scroll up    
0ea8					; TODO detecting only end of line 4 for scroll up  
0ea8			 
0ea8					;ld   
0ea8			 
0ea8 c9					ret 
0ea9			 
0ea9			 
0ea9			; strcpy hl = dest, de source 
0ea9			 
0ea9 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0eaa b7			            OR   A              ;Null terminator? 
0eab c8			            RET  Z              ;Yes, so finished 
0eac 1a					ld a,(de) 
0ead 77					ld (hl),a 
0eae 13			            INC  DE             ;Point to next character 
0eaf 23					inc hl 
0eb0 18 f7		            JR   strcpy       ;Repeat 
0eb2 c9					ret 
0eb3			 
0eb3			 
0eb3			; TODO string_at  
0eb3			; pass string which starts with lcd offset address and then null term string 
0eb3			 
0eb3			; TODO string to dec 
0eb3			; TODO string to hex 
0eb3			; TODO byte to string hex 
0eb3			; TODO byte to string dec 
0eb3			 
0eb3			 
0eb3			 
0eb3			; from z80uartmonitor 
0eb3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0eb3			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0eb3			; pass hl for where to put the text 
0eb3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0eb3 c5			hexout:	PUSH BC 
0eb4 f5					PUSH AF 
0eb5 47					LD B, A 
0eb6					; Upper nybble 
0eb6 cb 3f				SRL A 
0eb8 cb 3f				SRL A 
0eba cb 3f				SRL A 
0ebc cb 3f				SRL A 
0ebe cd ce 0e				CALL tohex 
0ec1 77					ld (hl),a 
0ec2 23					inc hl	 
0ec3					 
0ec3					; Lower nybble 
0ec3 78					LD A, B 
0ec4 e6 0f				AND 0FH 
0ec6 cd ce 0e				CALL tohex 
0ec9 77					ld (hl),a 
0eca 23					inc hl	 
0ecb					 
0ecb f1					POP AF 
0ecc c1					POP BC 
0ecd c9					RET 
0ece					 
0ece			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ece			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0ece			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ece			tohex: 
0ece e5					PUSH HL 
0ecf d5					PUSH DE 
0ed0 16 00				LD D, 0 
0ed2 5f					LD E, A 
0ed3 21 db 0e				LD HL, .DATA 
0ed6 19					ADD HL, DE 
0ed7 7e					LD A, (HL) 
0ed8 d1					POP DE 
0ed9 e1					POP HL 
0eda c9					RET 
0edb			 
0edb			.DATA: 
0edb 30					DEFB	30h	; 0 
0edc 31					DEFB	31h	; 1 
0edd 32					DEFB	32h	; 2 
0ede 33					DEFB	33h	; 3 
0edf 34					DEFB	34h	; 4 
0ee0 35					DEFB	35h	; 5 
0ee1 36					DEFB	36h	; 6 
0ee2 37					DEFB	37h	; 7 
0ee3 38					DEFB	38h	; 8 
0ee4 39					DEFB	39h	; 9 
0ee5 41					DEFB	41h	; A 
0ee6 42					DEFB	42h	; B 
0ee7 43					DEFB	43h	; C 
0ee8 44					DEFB	44h	; D 
0ee9 45					DEFB	45h	; E 
0eea 46					DEFB	46h	; F 
0eeb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0eeb			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0eeb			;;    subtract $30, if result > 9 then subtract $7 more 
0eeb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0eeb			atohex: 
0eeb d6 30				SUB $30 
0eed fe 0a				CP 10 
0eef f8					RET M		; If result negative it was 0-9 so we're done 
0ef0 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0ef2 c9					RET		 
0ef3			 
0ef3			 
0ef3			 
0ef3			 
0ef3			; Get 2 ASCII characters as hex byte from pointer in hl 
0ef3			 
0ef3			BYTERD: 
0ef3 16 00			LD	D,00h		;Set up 
0ef5 cd fd 0e			CALL	HEXCON		;Get byte and convert to hex 
0ef8 87				ADD	A,A		;First nibble so 
0ef9 87				ADD	A,A		;multiply by 16 
0efa 87				ADD	A,A		; 
0efb 87				ADD	A,A		; 
0efc 57				LD	D,A		;Save hi nibble in D 
0efd			HEXCON: 
0efd 7e				ld a, (hl)		;Get next chr 
0efe 23				inc hl 
0eff d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0f01 fe 0a			CP	00Ah		;Is it 0-9 ? 
0f03 38 02			JR	C,NALPHA	;If so miss next bit 
0f05 d6 07			SUB	007h		;Else convert alpha 
0f07			NALPHA: 
0f07 b2				OR	D		;Add hi nibble back 
0f08 c9				RET			; 
0f09			 
0f09			 
0f09			; 
0f09			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0f09			; Since the routines get_byte and therefore get_nibble are called, only valid 
0f09			; characters (0-9a-f) are accepted. 
0f09			; 
0f09			;get_word        push    af 
0f09			;                call    get_byte        ; Get the upper byte 
0f09			;                ld      h, a 
0f09			;                call    get_byte        ; Get the lower byte 
0f09			;                ld      l, a 
0f09			;                pop     af 
0f09			;                ret 
0f09			; 
0f09			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0f09			; the routine get_nibble is used only valid characters are accepted - the  
0f09			; input routine only accepts characters 0-9a-f. 
0f09			; 
0f09 c5			get_byte:        push    bc              ; Save contents of B (and C) 
0f0a 7e					ld a,(hl) 
0f0b 23					inc hl 
0f0c cd 31 0f		                call    nibble2val      ; Get upper nibble 
0f0f cb 07		                rlc     a 
0f11 cb 07		                rlc     a 
0f13 cb 07		                rlc     a 
0f15 cb 07		                rlc     a 
0f17 47			                ld      b, a            ; Save upper four bits 
0f18 7e					ld a,(hl) 
0f19 cd 31 0f		                call    nibble2val      ; Get lower nibble 
0f1c b0			                or      b               ; Combine both nibbles 
0f1d c1			                pop     bc              ; Restore B (and C) 
0f1e c9			                ret 
0f1f			; 
0f1f			; Get a hexadecimal digit from the serial line. This routine blocks until 
0f1f			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0f1f			; to the serial line interface. The lower 4 bits of A contain the value of  
0f1f			; that particular digit. 
0f1f			; 
0f1f			;get_nibble      ld a,(hl)           ; Read a character 
0f1f			;                call    to_upper        ; Convert to upper case 
0f1f			;                call    is_hex          ; Was it a hex digit? 
0f1f			;                jr      nc, get_nibble  ; No, get another character 
0f1f			 ;               call    nibble2val      ; Convert nibble to value 
0f1f			 ;               call    print_nibble 
0f1f			 ;               ret 
0f1f			; 
0f1f			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0f1f			; A valid hexadecimal digit is denoted by a set C flag. 
0f1f			; 
0f1f			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0f1f			;                ret     nc              ; Yes 
0f1f			;                cp      '0'             ; Less than '0'? 
0f1f			;                jr      nc, is_hex_1    ; No, continue 
0f1f			;                ccf                     ; Complement carry (i.e. clear it) 
0f1f			;                ret 
0f1f			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0f1f			;                ret     c               ; Yes 
0f1f			;                cp      'A'             ; Less than 'A'? 
0f1f			;                jr      nc, is_hex_2    ; No, continue 
0f1f			;                ccf                     ; Yes - clear carry and return 
0f1f			;                ret 
0f1f			;is_hex_2        scf                     ; Set carry 
0f1f			;                ret 
0f1f			; 
0f1f			; Convert a single character contained in A to upper case: 
0f1f			; 
0f1f fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0f21 d8			                ret     c 
0f22 fe 7b		                cp      'z' + 1         ; > 'z'? 
0f24 d0			                ret     nc              ; Nothing to do, either 
0f25 e6 5f		                and     $5f             ; Convert to upper case 
0f27 c9			                ret 
0f28			 
0f28			 
0f28			to_lower: 
0f28			 
0f28			   ; if char is in [A-Z] make it lower case 
0f28			 
0f28			   ; enter : a = char 
0f28			   ; exit  : a = lower case char 
0f28			   ; uses  : af 
0f28			 
0f28 fe 41		   cp 'A' 
0f2a d8			   ret c 
0f2b			    
0f2b fe 5b		   cp 'Z'+1 
0f2d d0			   ret nc 
0f2e			    
0f2e f6 20		   or $20 
0f30 c9			   ret 
0f31			 
0f31			; 
0f31			; Expects a hexadecimal digit (upper case!) in A and returns the 
0f31			; corresponding value in A. 
0f31			; 
0f31 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
0f33 38 02		                jr      c, nibble2val_1 ; Yes 
0f35 d6 07		                sub     7               ; Adjust for A-F 
0f37 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
0f39 e6 0f		                and     $f              ; Only return lower 4 bits 
0f3b c9			                ret 
0f3c			; 
0f3c			; Print_nibble prints a single hex nibble which is contained in the lower  
0f3c			; four bits of A: 
0f3c			; 
0f3c			;print_nibble    push    af              ; We won't destroy the contents of A 
0f3c			;                and     $f              ; Just in case... 
0f3c			;                add     a, '0'             ; If we have a digit we are done here. 
0f3c			;                cp      '9' + 1         ; Is the result > 9? 
0f3c			;                jr      c, print_nibble_1 
0f3c			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
0f3c			;print_nibble_1  call    putc            ; Print the nibble and 
0f3c			;                pop     af              ; restore the original value of A 
0f3c			;                ret 
0f3c			;; 
0f3c			;; Send a CR/LF pair: 
0f3c			; 
0f3c			;crlf            push    af 
0f3c			;                ld      a, cr 
0f3c			;                call    putc 
0f3c			;                ld      a, lf 
0f3c			;                call    putc 
0f3c			;                pop     af 
0f3c			;                ret 
0f3c			; 
0f3c			; Print_word prints the four hex digits of a word to the serial line. The  
0f3c			; word is expected to be in HL. 
0f3c			; 
0f3c			;print_word      push    hl 
0f3c			;                push    af 
0f3c			;                ld      a, h 
0f3c			;                call    print_byte 
0f3c			;                ld      a, l 
0f3c			;                call    print_byte 
0f3c			;                pop     af 
0f3c			;                pop     hl 
0f3c			;                ret 
0f3c			; 
0f3c			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
0f3c			; The byte to be printed is expected to be in A. 
0f3c			; 
0f3c			;print_byte      push    af              ; Save the contents of the registers 
0f3c			;                push    bc 
0f3c			;                ld      b, a 
0f3c			;                rrca 
0f3c			;                rrca 
0f3c			;                rrca 
0f3c			;                rrca 
0f3c			;                call    print_nibble    ; Print high nibble 
0f3c			;                ld      a, b 
0f3c			;                call    print_nibble    ; Print low nibble 
0f3c			;                pop     bc              ; Restore original register contents 
0f3c			;                pop     af 
0f3c			;                ret 
0f3c			 
0f3c			 
0f3c			 
0f3c			 
0f3c			 
0f3c			fourehexhl:  
0f3c 7e				ld a,(hl) 
0f3d cd eb 0e			call atohex 
0f40 cb 3f				SRL A 
0f42 cb 3f				SRL A 
0f44 cb 3f				SRL A 
0f46 cb 3f				SRL A 
0f48 47				ld b, a 
0f49 23				inc hl 
0f4a 7e				ld a,(hl) 
0f4b 23				inc hl 
0f4c cd eb 0e			call atohex 
0f4f 80				add b 
0f50 57				ld d,a 
0f51 7e				ld a,(hl) 
0f52 cd eb 0e			call atohex 
0f55 cb 3f				SRL A 
0f57 cb 3f				SRL A 
0f59 cb 3f				SRL A 
0f5b cb 3f				SRL A 
0f5d 47				ld b, a 
0f5e 23				inc hl 
0f5f 7e				ld a,(hl) 
0f60 23				inc hl 
0f61 cd eb 0e			call atohex 
0f64 80				add b 
0f65 5f				ld e, a 
0f66 d5				push de 
0f67 e1				pop hl 
0f68 c9				ret 
0f69			 
0f69			; pass hl. returns z set if the byte at hl is a digit 
0f69			;isdigithl:  
0f69			;	push bc 
0f69			;	ld a,(hl) 
0f69			;	cp ':' 
0f69			;	jr nc, .isdf 		; > 
0f69			;	cp '0' 
0f69			;	jr c, .isdf		; < 
0f69			; 
0f69			;	; TODO find a better way to set z 
0f69			; 
0f69			;	ld b,a 
0f69			;	cp b 
0f69			;	pop bc 
0f69			;	ret 
0f69			; 
0f69			;.isdf:	; not digit so clear z 
0f69			; 
0f69			;	; TODO find a better way to unset z 
0f69			; 
0f69			;	ld b,a 
0f69			;	inc b 
0f69			;	cp b 
0f69			; 
0f69			;	pop bc 
0f69			;	ret 
0f69				 
0f69				 
0f69			 
0f69			 
0f69			; pass hl as the four byte address to load 
0f69			 
0f69			get_word_hl:  
0f69 e5				push hl 
0f6a cd 09 0f			call get_byte 
0f6d				 
0f6d 47				ld b, a 
0f6e			 
0f6e e1				pop hl 
0f6f 23				inc hl 
0f70 23				inc hl 
0f71			 
0f71			; TODO not able to handle a-f  
0f71 7e				ld a,(hl) 
0f72			;	;cp ':' 
0f72			;	cp 'g' 
0f72			;	jr nc, .single_byte_hl 		; > 
0f72			;	cp 'G' 
0f72			;	jr nc, .single_byte_hl 		; > 
0f72			;	cp '0' 
0f72			;	jr c, .single_byte_hl		; < 
0f72			 
0f72				;call isdigithl 
0f72 fe 00			cp 0 
0f74 28 06			jr z, .single_byte_hl 
0f76			 
0f76			.getwhln:   ; hex word so get next byte 
0f76			 
0f76 cd 09 0f			call get_byte 
0f79 6f				ld l, a 
0f7a 60				ld h,b 
0f7b c9				ret 
0f7c 68			.single_byte_hl:   ld l,b 
0f7d 26 00				ld h,0 
0f7f c9					ret 
0f80			 
0f80			 
0f80			 
0f80			 
0f80 21 d0 16			ld hl,asc+1 
0f83			;	ld a, (hl) 
0f83			;	call nibble2val 
0f83 cd 09 0f			call get_byte 
0f86			 
0f86			;	call fourehexhl 
0f86 32 94 e3			ld (scratch+52),a 
0f89				 
0f89 21 92 e3			ld hl,scratch+50 
0f8c 22 83 e6			ld (os_cur_ptr),hl 
0f8f			 
0f8f c9				ret 
0f90			 
0f90			 
0f90			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
0f90			 
0f90			; Decimal Unsigned Version 
0f90			 
0f90			;Number in a to decimal ASCII 
0f90			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
0f90			;Example: display a=56 as "056" 
0f90			;input: a = number 
0f90			;Output: a=0,value of a in the screen 
0f90			;destroys af,bc (don't know about hl and de) 
0f90			DispAToASCII: 
0f90 0e 9c			ld	c,-100 
0f92 cd 9c 0f			call	.Na1 
0f95 0e f6			ld	c,-10 
0f97 cd 9c 0f			call	.Na1 
0f9a 0e ff			ld	c,-1 
0f9c 06 2f		.Na1:	ld	b,'0'-1 
0f9e 04			.Na2:	inc	b 
0f9f 81				add	a,c 
0fa0 38 fc			jr	c,.Na2 
0fa2 91				sub	c		;works as add 100/10/1 
0fa3 f5				push af		;safer than ld c,a 
0fa4 78				ld	a,b		;char is in b 
0fa5			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
0fa5 f1				pop af		;safer than ld a,c 
0fa6 c9				ret 
0fa7			 
0fa7			; Decimal Signed Version 
0fa7			 
0fa7			; DispA 
0fa7			; -------------------------------------------------------------- 
0fa7			; Converts a signed integer value to a zero-terminated ASCII 
0fa7			; string representative of that value (using radix 10). 
0fa7			; -------------------------------------------------------------- 
0fa7			; INPUTS: 
0fa7			;     HL     Value to convert (two's complement integer). 
0fa7			;     DE     Base address of string destination. (pointer). 
0fa7			; -------------------------------------------------------------- 
0fa7			; OUTPUTS: 
0fa7			;     None 
0fa7			; -------------------------------------------------------------- 
0fa7			; REGISTERS/MEMORY DESTROYED 
0fa7			; AF HL 
0fa7			; -------------------------------------------------------------- 
0fa7			 
0fa7			;DispHLToASCII: 
0fa7			;   push    de 
0fa7			;   push    bc 
0fa7			; 
0fa7			;; Detect sign of HL. 
0fa7			;    bit    7, h 
0fa7			;    jr     z, ._DoConvert 
0fa7			; 
0fa7			;; HL is negative. Output '-' to string and negate HL. 
0fa7			;    ld     a, '-' 
0fa7			;    ld     (de), a 
0fa7			;    inc    de 
0fa7			; 
0fa7			;; Negate HL (using two's complement) 
0fa7			;    xor    a 
0fa7			;    sub    l 
0fa7			;    ld     l, a 
0fa7			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
0fa7			;    sbc    a, h 
0fa7			;    ld     h, a 
0fa7			; 
0fa7			;; Convert HL to digit characters 
0fa7			;._DoConvert: 
0fa7			;    ld     b, 0     ; B will count character length of number 
0fa7			;-   ld     a, 10 
0fa7			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
0fa7			;    push   af 
0fa7			;    inc    b 
0fa7			;    ld     a, h 
0fa7			;    or     l 
0fa7			;    jr     nz, - 
0fa7			; 
0fa7			;; Retrieve digits from stack 
0fa7			;-   pop    af 
0fa7			;    or     $30 
0fa7			;    ld     (de), a 
0fa7			;    inc    de 
0fa7			;    djnz   - 
0fa7			; 
0fa7			;; Terminate string with NULL 
0fa7			;    xor    a 
0fa7			;    ld     (de), a 
0fa7			; 
0fa7			;    pop    bc 
0fa7			;    pop    de 
0fa7			;    ret 
0fa7			 
0fa7			;Comments 
0fa7			; 
0fa7			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
0fa7			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
0fa7			;    Note that the output string will not be fixed-width. 
0fa7			; 
0fa7			;Example Usage 
0fa7			; 
0fa7			;    ld    hl, -1004 
0fa7			;    ld    de, OP1 
0fa7			;    call  DispA 
0fa7			;    ld    hl, OP1 
0fa7			;    syscall  PutS 
0fa7			 
0fa7			 
0fa7			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0fa7			 
0fa7			 
0fa7			;Converts an ASCII string to an unsigned 16-bit integer 
0fa7			;Quits when it reaches a non-decimal digit 
0fa7			 
0fa7			string_to_uint16: 
0fa7			atoui_16: 
0fa7			;Input: 
0fa7			;     DE points to the string 
0fa7			;Outputs: 
0fa7			;     HL is the result 
0fa7			;     A is the 8-bit value of the number 
0fa7			;     DE points to the byte after the number 
0fa7			;Destroys: 
0fa7			;     BC 
0fa7			;       if the string is non-empty, BC is HL/10 
0fa7			;Size:  24 bytes 
0fa7			;Speed: 42+d(104+{0,9}) 
0fa7			;       d is the number of digits in the number 
0fa7			;       max is 640 cycles for a 5 digit number 
0fa7			;Assuming no leading zeros: 
0fa7			;1 digit:  146cc 
0fa7			;2 digit:  250cc 
0fa7			;3 digit:  354cc or 363cc (avg: 354.126cc) 
0fa7			;4 digit:  458cc or 467cc (avg: 458.27cc) 
0fa7			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
0fa7			;avg: 544.81158447265625cc (544+13297/16384) 
0fa7			;=============================================================== 
0fa7 21 00 00		  ld hl,0 
0faa			.u16a: 
0faa 1a			  ld a,(de) 
0fab d6 30		  sub 30h 
0fad fe 0a		  cp 10 
0faf d0			  ret nc 
0fb0 13			  inc de 
0fb1 44			  ld b,h 
0fb2 4d			  ld c,l 
0fb3 29			  add hl,hl 
0fb4 29			  add hl,hl 
0fb5 09			  add hl,bc 
0fb6 29			  add hl,hl 
0fb7 85			  add a,l 
0fb8 6f			  ld l,a 
0fb9 30 ef		  jr nc,.u16a 
0fbb 24			  inc h 
0fbc c3 aa 0f		  jp .u16a 
0fbf			 
0fbf			 
0fbf			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0fbf			 
0fbf			;written by Zeda 
0fbf			;Converts a 16-bit unsigned integer to an ASCII string. 
0fbf			 
0fbf			uitoa_16: 
0fbf			;Input: 
0fbf			;   DE is the number to convert 
0fbf			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
0fbf			;Output: 
0fbf			;   HL points to the null-terminated ASCII string 
0fbf			;      NOTE: This isn't necessarily the same as the input HL. 
0fbf d5			  push de 
0fc0 c5			  push bc 
0fc1 f5			  push af 
0fc2 eb			  ex de,hl 
0fc3			 
0fc3 01 f0 d8		  ld bc,-10000 
0fc6 3e 2f		  ld a,'0'-1 
0fc8 3c			  inc a 
0fc9 09			  add hl,bc  
0fca 38 fc		   jr c,$-2 
0fcc 12			  ld (de),a 
0fcd 13			  inc de 
0fce			 
0fce 01 e8 03		  ld bc,1000 
0fd1 3e 3a		  ld a,'9'+1 
0fd3 3d			  dec a  
0fd4 09			  add hl,bc  
0fd5 30 fc		   jr nc,$-2 
0fd7 12			  ld (de),a 
0fd8 13			  inc de 
0fd9			 
0fd9 01 9c ff		  ld bc,-100 
0fdc 3e 2f		  ld a,'0'-1 
0fde 3c			  inc a  
0fdf 09			  add hl,bc  
0fe0 38 fc		   jr c,$-2 
0fe2 12			  ld (de),a 
0fe3 13			  inc de 
0fe4			 
0fe4 7d			  ld a,l 
0fe5 26 3a		  ld h,'9'+1 
0fe7 25			  dec h  
0fe8 c6 0a		  add a,10  
0fea 30 fb		   jr nc,$-3 
0fec c6 30		  add a,'0' 
0fee eb			  ex de,hl 
0fef 72			  ld (hl),d 
0ff0 23			  inc hl 
0ff1 77			  ld (hl),a 
0ff2 23			  inc hl 
0ff3 36 00		  ld (hl),0 
0ff5			 
0ff5			;Now strip the leading zeros 
0ff5 0e fa		  ld c,-6 
0ff7 09			  add hl,bc 
0ff8 3e 30		  ld a,'0' 
0ffa 23			  inc hl  
0ffb be			  cp (hl)  
0ffc 28 fc		  jr z,$-2 
0ffe			 
0ffe			;Make sure that the string is non-empty! 
0ffe 7e			  ld a,(hl) 
0fff b7			  or a 
1000 20 01		  jr nz,.atoub 
1002 2b			  dec hl 
1003			.atoub: 
1003			 
1003 f1			  pop af 
1004 c1			  pop bc 
1005 d1			  pop de 
1006 c9			  ret 
1007			 
1007			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1007			 
1007			toUpper: 
1007			;A is the char. 
1007			;If A is a lowercase letter, this sets it to the matching uppercase 
1007			;18cc or 30cc or 41cc 
1007			;avg: 26.75cc 
1007 fe 61		  cp 'a' 
1009 d8			  ret c 
100a fe 7b		  cp 'z'+1 
100c d0			  ret nc 
100d d6 20		  sub 'a'-'A' 
100f c9			  ret 
1010			 
1010			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1010			 
1010			; String Length 
1010			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1010			 
1010			; Get the length of the null-terminated string starting at $8000 hl 
1010			;    LD     HL, $8000 
1010			 
1010			strlenz: 
1010			 
1010 af			    XOR    A               ; Zero is the value we are looking for. 
1011 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1012 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1013			                           ; 65, 536 bytes (the entire addressable memory space). 
1013 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1015			 
1015			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1015 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1016 6f			    LD     L, A             ; number of bytes 
1017 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1019 2b			    DEC    HL              ; Compensate for null. 
101a c9				ret 
101b			 
101b			; Get the length of the A terminated string starting at $8000 hl 
101b			;    LD     HL, $8000 
101b			 
101b			strlent: 
101b			 
101b			                  ; A is the value we are looking for. 
101b 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
101d 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
101f			                           ; 65, 536 bytes (the entire addressable memory space). 
101f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1021			 
1021			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1021 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1023 2e 00		    LD     L, 0             ; number of bytes 
1025 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1027 2b			    DEC    HL              ; Compensate for null. 
1028 c9				ret 
1029			 
1029			 
1029			;Comparing Strings 
1029			 
1029			;IN    HL     Address of string1. 
1029			;      DE     Address of string2. 
1029			 
1029			; doc given but wrong??? 
1029			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1029			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1029			; tested 
1029			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1029			 
1029			strcmp_old: 
1029 e5			    PUSH   HL 
102a d5			    PUSH   DE 
102b			 
102b 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
102c be			    CP     (HL)            ; (want to minimize work). 
102d 38 01		    JR     C, Str1IsBigger 
102f 7e			    LD     A, (HL) 
1030			 
1030			Str1IsBigger: 
1030 4f			    LD     C, A             ; Put length in BC 
1031 06 00		    LD     B, 0 
1033 13			    INC    DE              ; Increment pointers to meat of string. 
1034 23			    INC    HL 
1035			 
1035			CmpLoop: 
1035 1a			    LD     A, (DE)          ; Compare bytes. 
1036 ed a1		    CPI 
1038 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
103a 13			    INC    DE              ; Update pointer. 
103b ea 35 10		    JP     PE, CmpLoop 
103e			 
103e d1			    POP    DE 
103f e1			    POP    HL 
1040 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1041 be			    CP     (HL) 
1042 c9			    RET 
1043			 
1043			NoMatch: 
1043 2b			    DEC    HL 
1044 be			    CP     (HL)            ; Compare again to affect carry. 
1045 d1			    POP    DE 
1046 e1			    POP    HL 
1047 c9			    RET 
1048			 
1048			;; test strmp 
1048			; 
1048			;ld de, .str1 
1048			;ld hl, .str2 
1048			;call strcmp 
1048			;jr z, .z1 
1048			;;this 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "NZ1" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			;.z1: 
1048			; 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "ZZ1" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			; 
1048			;ld de, .str1 
1048			;ld hl, .str1 
1048			;call strcmp 
1048			;jr z, .z2 
1048			;;this 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "NZ2" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			;.z2: 
1048			; 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "ZZ2" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			; 
1048			;ld de, .str1 
1048			;ld hl, .str2 
1048			;call strcmp 
1048			;jr c, .c1 
1048			; 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "Nc1" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			;.c1: 
1048			;;this 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "cc1" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			; 
1048			;ld de, .str1 
1048			;ld hl, .str1 
1048			;call strcmp 
1048			;jr c, .c2 
1048			;;this 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "Nc2" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			;.c2: 
1048			; 
1048			;	if DEBUG_FORTH_WORDS 
1048			;		DMARK "cc2" 
1048			;		CALLMONITOR 
1048			;	endif 
1048			;	NEXTW 
1048			;.str1:   db "string1",0 
1048			;.str2:   db "string2",0 
1048			 
1048			; only care about direct match or not 
1048			; hl and de strings 
1048			; zero set if the same 
1048			 
1048			strcmp: 
1048 1a				ld a, (de) 
1049 be				cp (hl) 
104a 28 02			jr z, .ssame 
104c b7				or a 
104d c9				ret 
104e			 
104e			.ssame:  
104e fe 00			cp 0 
1050 c8				ret z 
1051			 
1051 23				inc hl 
1052 13				inc de 
1053 18 f3			jr strcmp 
1055				 
1055				 
1055			 
1055			 
1055			 
1055			 
1055			; eof 
1055			 
1055			 
1055			 
1055			 
1055			 
1055			 
# End of file firmware_strings.asm
1055			include "firmware_memory.asm"   ; malloc and free  
1055			 
1055			if DEBUG_FORTH_MALLOC_HIGH 
1055			.mallocsize: db "Wants malloc >256",0 
1055			.mallocasize: db "MALLOC gives >256",0 
1055			.malloczero: db "MALLOC gives zero",0 
1055			 
1055			malloc_guard_zerolen: 
1055				push hl 
1055				push de 
1055				push af 
1055			 
1055				ld de, 0 
1055			        call cmp16 
1055				jr nz, .lowalloz 
1055			 
1055				push hl 
1055				push de 
1055					ld hl, display_fb0 
1055					ld (display_fb_active), hl 
1055				call clear_display 
1055				ld a, 0 
1055				ld de, .malloczero 
1055				call str_at_display 
1055				call update_display 
1055				call delay1s 
1055				call delay1s 
1055				ld a, 0 
1055				ld (os_view_disable), a 
1055			 
1055				pop de 
1055				pop hl 
1055			 
1055				 
1055			 
1055				CALLMONITOR 
1055			.lowalloz: 
1055			 
1055			 
1055				pop af 
1055				pop de 
1055				pop hl 
1055			ret 
1055			 
1055			malloc_guard_entry: 
1055				push hl 
1055				push de 
1055				push af 
1055			 
1055			 	or a      ;clear carry flag 
1055				push hl 
1055				ld de, 255 
1055				sbc hl, de 
1055				jr c, .lowalloc 
1055			 
1055				push de 
1055					ld hl, display_fb0 
1055					ld (display_fb_active), hl 
1055				call clear_display 
1055				ld a, 0 
1055				ld de, .mallocsize 
1055				call str_at_display 
1055				call update_display 
1055				call delay1s 
1055				call delay1s 
1055				ld a, 0 
1055				ld (os_view_disable), a 
1055			 
1055				pop de 
1055				pop hl 
1055			 
1055				 
1055			 
1055				CALLMONITOR 
1055				jr .lowdone 
1055			.lowalloc: 
1055			 
1055			 
1055				pop hl 
1055			.lowdone:	pop af 
1055				pop de 
1055				pop hl 
1055			ret 
1055			 
1055			malloc_guard_exit: 
1055				push hl 
1055				push de 
1055				push af 
1055			 
1055			 	or a      ;clear carry flag 
1055				push hl 
1055				ld de, 255 
1055				sbc hl, de 
1055				jr c, .lowallocx 
1055			 
1055				push de 
1055					ld hl, display_fb0 
1055					ld (display_fb_active), hl 
1055				call clear_display 
1055				ld a, 0 
1055				ld de, .mallocasize 
1055				call str_at_display 
1055				call update_display 
1055				call delay1s 
1055				call delay1s 
1055				ld a, 0 
1055				ld (os_view_disable), a 
1055				pop de 
1055				pop hl 
1055			 
1055				CALLMONITOR 
1055				jr .lowdonex 
1055			.lowallocx: 
1055			 
1055				pop hl 
1055			.lowdonex:	pop af 
1055				pop de 
1055				pop hl 
1055			ret 
1055			endif 
1055			 
1055			if MALLOC_2 
1055			; Z80 Malloc and Free Functions 
1055			 
1055			; Malloc Function: 
1055			; Input: 
1055			;   HL: Size of block to allocate 
1055			; Output: 
1055			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1055			 
1055			malloc: 
1055				 
1055			if DEBUG_FORTH_MALLOC_HIGH 
1055			call malloc_guard_entry 
1055			endif 
1055			 
1055			 
1055			 
1055			 
1055					if DEBUG_FORTH_MALLOC 
1055						DMARK "mal" 
1055						CALLMONITOR 
1055					endif 
1055			    push af            ; Save AF register 
1055			    ld a, l            ; Load low byte of size into A 
1055			    or h               ; Check if size is zero 
1055			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1055			 
1055			    ; Allocate memory 
1055			    ld hl, (heap_start) ; Load start of heap into HL 
1055					if DEBUG_FORTH_MALLOC 
1055						DMARK "ma1" 
1055						CALLMONITOR 
1055					endif 
1055			    call malloc_internal ; Call internal malloc function 
1055			    pop af             ; Restore AF register 
1055			if DEBUG_FORTH_MALLOC_HIGH 
1055			call malloc_guard_exit 
1055			call malloc_guard_zerolen 
1055			endif 
1055			    ret                ; Return 
1055			 
1055			; Free Function: 
1055			; Input: 
1055			;   HL: Pointer to memory block to free 
1055			; Output: 
1055			;   None 
1055			 
1055			free: 
1055			    push af            ; Save AF register 
1055			    ld a, l            ; Load low byte of pointer into A 
1055			    or h               ; Check if pointer is NULL 
1055			    jp z, free_exit    ; If pointer is NULL, exit 
1055			 
1055			    ; Free memory 
1055			    ld hl, (heap_start) ; Load start of heap into HL 
1055			    call free_internal  ; Call internal free function 
1055			    pop af             ; Restore AF register 
1055			    ret                ; Return 
1055			 
1055			; Internal Malloc Function: 
1055			; Input: 
1055			;   HL: Size of block to allocate 
1055			; Output: 
1055			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1055			 
1055			malloc_internal: 
1055			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1055			    add hl, bc         ; Add management overhead to requested size 
1055			    ex de, hl          ; Save total size in DE, and keep it in HL 
1055					if DEBUG_FORTH_MALLOC 
1055						DMARK "ma2" 
1055						CALLMONITOR 
1055					endif 
1055			 
1055			    ; Search for free memory block 
1055			    ld de, (heap_end)  ; Load end of heap into DE 
1055			    ld bc, 0           ; Initialize counter 
1055			 
1055					if DEBUG_FORTH_MALLOC 
1055						DMARK "ma2" 
1055						CALLMONITOR 
1055					endif 
1055			malloc_search_loop: 
1055			    ; Check if current block is free 
1055			    ld a, (hl)         ; Load current block's status (free or used) 
1055			    cp 0               ; Compare with zero (free) 
1055			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1055			 
1055			    ; Check if current block is large enough 
1055			    ld a, (hl+1)       ; Load high byte of block size 
1055			    cp l               ; Compare with low byte of requested size 
1055			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1055			 
1055			    ld a, (hl+2)       ; Load low byte of block size 
1055			    cp h               ; Compare with high byte of requested size 
1055			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1055			 
1055			    ; Mark block as used 
1055			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1055			 
1055			    ; Calculate remaining space in block 
1055			    ld bc, 0           ; Clear BC 
1055			    add hl, bc         ; Increment HL to point to start of data block 
1055			    add hl, de         ; HL = HL + DE (total size) 
1055			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1055			    add hl, bc         ; Add management overhead to start of data block 
1055			 
1055			    ; Save pointer to allocated block in HL 
1055			if DEBUG_FORTH_MALLOC_HIGH 
1055						DMARK "ma5" 
1055			call malloc_guard_exit 
1055			call malloc_guard_zerolen 
1055			endif 
1055			    ret 
1055			 
1055			malloc_skip_block_check: 
1055			    ; Move to the next block 
1055			    ld bc, 3           ; Size of management overhead 
1055			    add hl, bc         ; Move to the next block 
1055			    inc de             ; Increment counter 
1055			 
1055			    ; Check if we have reached the end of heap 
1055			    ld a, e            ; Load low byte of heap end address 
1055			    cp (hl)            ; Compare with low byte of current address 
1055			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1055			    ld a, d            ; Load high byte of heap end address 
1055			    cp 0               ; Check if it's zero (end of memory) 
1055			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1055			 
1055			    ; If we reached here, allocation failed 
1055			    xor a              ; Set result to NULL 
1055			if DEBUG_FORTH_MALLOC_HIGH 
1055						DMARK "ma6" 
1055			call malloc_guard_exit 
1055			call malloc_guard_zerolen 
1055			endif 
1055			    ret 
1055			malloc_exit: 
1055			if DEBUG_FORTH_MALLOC_HIGH 
1055						DMARK "ma7" 
1055			call malloc_guard_exit 
1055			call malloc_guard_zerolen 
1055			endif 
1055			    ret 
1055			 
1055			; Internal Free Function: 
1055			; Input: 
1055			;   HL: Pointer to memory block to free 
1055			; Output: 
1055			;   None 
1055			 
1055			free_internal: 
1055			    ld de, (heap_start) ; Load start of heap into DE 
1055			    ld bc, 0            ; Initialize counter 
1055			 
1055			free_search_loop: 
1055			    ; Check if current block contains the pointer 
1055			    ld a, l             ; Load low byte of pointer 
1055			    cp (hl+1)           ; Compare with high byte of current block's address 
1055			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1055			    ld a, h             ; Load high byte of pointer 
1055			    cp (hl+2)           ; Compare with low byte of current block's address 
1055			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1055			 
1055			    ; Mark block as free 
1055			    ld (hl), 0          ; Set status byte to indicate free block 
1055			    ret                 ; Return 
1055			 
1055			free_skip_block_check: 
1055			    ; Move to the next block 
1055			    ld bc, 3            ; Size of management overhead 
1055			    add hl, bc          ; Move to the next block 
1055			    inc de              ; Increment counter 
1055			 
1055			    ; Check if we have reached the end of heap 
1055			    ld a, e             ; Load low byte of heap end address 
1055			    cp (hl)             ; Compare with low byte of current address 
1055			    jr nz, free_search_loop  ; If not equal, continue searching 
1055			    ld a, d             ; Load high byte of heap end address 
1055			    cp 0                ; Check if it's zero (end of memory) 
1055			    jr nz, free_search_loop  ; If not zero, continue searching 
1055			 
1055			    ; If we reached here, pointer is not found in heap 
1055			    ret 
1055			 
1055			free_exit: 
1055			    ret                 ; Return 
1055			 
1055			; Define heap start and end addresses 
1055			;heap_start:    .dw 0xC000   ; Start of heap 
1055			;heap_end:      .dw 0xE000   ; End of heap 
1055			 
1055			endif 
1055			 
1055			 
1055			if MALLOC_1 
1055			 
1055			 
1055			 
1055			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1055			 
1055			;moved to firmware.asm 
1055			;heap_start        .equ  0x9000      ; Starting address of heap 
1055			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1055			 
1055			;      .org 0 
1055			;      jp    main 
1055			 
1055			 
1055			;      .org  0x100 
1055			;main: 
1055			;      ld    HL, 0x8100 
1055			;      ld    SP, HL 
1055			; 
1055			;      call  heap_init 
1055			; 
1055			;      ; Make some allocations 
1055			;      ld    HL, 12 
1055			;      call  malloc            ; Allocates 0x9004 
1055			; 
1055			;      ld    HL, 12 
1055			;      call  malloc            ; Allocates 0x9014 
1055			; 
1055			;      ld    HL, 12 
1055			;      call  malloc            ; Allocates 0x9024 
1055			; 
1055			;      ; Free some allocations 
1055			;      ld    HL, 0x9014 
1055			;      call  free 
1055			; 
1055			;      ld    HL, 0x9004 
1055			;      call  free 
1055			; 
1055			;      ld    HL, 0x9024 
1055			;      call  free 
1055			; 
1055			; 
1055			;      halt 
1055			 
1055			 
1055			;------------------------------------------------------------------------------ 
1055			;     heap_init                                                               : 
1055			;                                                                             : 
1055			; Description                                                                 : 
1055			;     Initialise the heap and make it ready for malloc and free operations.   : 
1055			;                                                                             : 
1055			;     The heap is maintained as a linked list, starting with an initial       : 
1055			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1055			;     the first free block in the heap. Each block then points to the next    : 
1055			;     free block within the heap, and the free list ends at the first block   : 
1055			;     with a null pointer to the next free block.                             : 
1055			;                                                                             : 
1055			; Parameters                                                                  : 
1055			;     Inputs are compile-time only. Two defines which specify the starting    : 
1055			;     address of the heap and its size are required, along with a memory      : 
1055			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1055			;     principally stores a pointer to the first free block in the heap.       : 
1055			;                                                                             : 
1055			; Returns                                                                     : 
1055			;     Nothing                                                                 : 
1055			;------------------------------------------------------------------------------ 
1055			heap_init: 
1055 e5			      push  HL 
1056			 
1056			      ; Initialise free list struct 
1056 21 a5 58		      ld    HL, heap_start 
1059 22 a0 58		      ld    (free_list), HL 
105c 21 00 00		      ld    HL, 0 
105f 22 a2 58		      ld    (free_list+2), HL 
1062			 
1062			      ; Insert first free block at bottom of heap, consumes entire heap 
1062 21 42 e3		      ld    HL, heap_start+heap_size-4 
1065 22 a5 58		      ld    (heap_start), HL        ; Next block (end of free list) 
1068 21 9d 8a		      ld    HL, heap_size-4 
106b 22 a7 58		      ld    (heap_start+2), HL      ; Block size 
106e			 
106e			      ; Insert end of free list block at top of heap - two null words will 
106e			      ; terminate the free list 
106e 21 00 00		      ld    HL, 0 
1071 22 44 e3		      ld    (heap_start+heap_size-2), HL 
1074 22 42 e3		      ld    (heap_start+heap_size-4), HL 
1077			 
1077 e1			      pop   HL 
1078			 
1078 c9			      ret 
1079			 
1079			 
1079			;------------------------------------------------------------------------------ 
1079			;     malloc                                                                  : 
1079			;                                                                             : 
1079			; Description                                                                 : 
1079			;     Allocates the wanted space from the heap and returns the address of the : 
1079			;     first useable byte of the allocation.                                   : 
1079			;                                                                             : 
1079			;     Allocations can happen in one of two ways:                              : 
1079			;                                                                             : 
1079			;     1. A free block may be found which is the exact size wanted. In this    : 
1079			;        case the block is removed from the free list and retuedn to the      : 
1079			;        caller.                                                              : 
1079			;     2. A free block may be found which is larger than the size wanted. In   : 
1079			;        this case, the larger block is split into two. The first portion of  : 
1079			;        this block will become the requested space by the malloc call and    : 
1079			;        is returned to the caller. The second portion becomes a new free     : 
1079			;        block, and the free list is adjusted to maintain continuity via this : 
1079			;        newly created block.                                                 : 
1079			;                                                                             : 
1079			;     malloc does not set any initial value in the allocated space, the       : 
1079			;     caller is required to do this as required.                              : 
1079			;                                                                             : 
1079			;     This implementation of malloc uses the stack exclusively, and is        : 
1079			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1079			;     advisable to disable interrupts before calling malloc, and recommended  : 
1079			;     to avoid the use of malloc inside ISRs in general.                      : 
1079			;                                                                             : 
1079			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1079			;                                                                             : 
1079			; Parameters                                                                  : 
1079			;     HL  Number of bytes wanted                                              : 
1079			;                                                                             : 
1079			; Returns                                                                     : 
1079			;     HL  Address of the first useable byte of the allocation                 : 
1079			;                                                                             : 
1079			; Flags                                                                       : 
1079			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1079			;                                                                             : 
1079			; Stack frame                                                                 : 
1079			;       |             |                                                       : 
1079			;       +-------------+                                                       : 
1079			;       |     BC      |                                                       : 
1079			;       +-------------+                                                       : 
1079			;       |     DE      |                                                       : 
1079			;       +-------------+                                                       : 
1079			;       |     IX      |                                                       : 
1079			;       +-------------+                                                       : 
1079			;       |  prev_free  |                                                       : 
1079			;   +4  +-------------+                                                       : 
1079			;       |  this_free  |                                                       : 
1079			;   +2  +-------------+                                                       : 
1079			;       |  next_free  |                                                       : 
1079			;   +0  +-------------+                                                       : 
1079			;       |             |                                                       : 
1079			;                                                                             : 
1079			;------------------------------------------------------------------------------ 
1079			 
1079			 
1079			;malloc: 
1079			; 
1079			;	SAVESP ON 1 
1079			; 
1079			;	call malloc_code 
1079			; 
1079			;	CHECKSP ON 1 
1079			;	ret 
1079			 
1079			 
1079			malloc: 
1079 c5			      push  BC 
107a d5			      push  DE 
107b dd e5		      push  IX 
107d			if DEBUG_FORTH_MALLOC_HIGH 
107d			call malloc_guard_entry 
107d			endif 
107d			 
107d					if DEBUG_FORTH_MALLOC 
107d						DMARK "mal" 
107d						CALLMONITOR 
107d					endif 
107d 7c			      ld    A, H                    ; Exit if no space requested 
107e b5			      or    L 
107f ca 3e 11		      jp    Z, malloc_early_exit 
1082			 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			; 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			;inc hl 
1082			 
1082			 
1082			 
1082			 
1082					if DEBUG_FORTH_MALLOC 
1082						DMARK "maA" 
1082						CALLMONITOR 
1082					endif 
1082			      ; Set up stack frame 
1082 eb			      ex    DE, HL 
1083 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1086 39			      add   HL, SP 
1087 f9			      ld    SP, HL 
1088 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
108c dd 39		      add   IX, SP 
108e			 
108e			      ; Setup initial state 
108e 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1091 19			      add   HL, DE 
1092			 
1092 44			      ld    B, H                    ; Move want to BC 
1093 4d			      ld    C, L 
1094			 
1094 21 a0 58		      ld    HL, free_list           ; Store prev_free ptr to stack 
1097 dd 75 04		      ld    (IX+4), L 
109a dd 74 05		      ld    (IX+5), H 
109d			 
109d 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
109e 23			      inc   HL 
109f 56			      ld    D, (HL) 
10a0 dd 73 02		      ld    (IX+2), E 
10a3 dd 72 03		      ld    (IX+3), D 
10a6 eb			      ex    DE, HL                  ; this_free ptr into HL 
10a7			 
10a7					if DEBUG_FORTH_MALLOC 
10a7						DMARK "maB" 
10a7						CALLMONITOR 
10a7					endif 
10a7			      ; Loop through free block list to find some space 
10a7			malloc_find_space: 
10a7 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
10a8 23			      inc   HL 
10a9 56			      ld    D, (HL) 
10aa			 
10aa 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
10ab b3			      or    E 
10ac ca 38 11		      jp    Z, malloc_no_space 
10af			 
10af dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
10b2 dd 72 01		      ld    (IX+1), D 
10b5			 
10b5			      ; Does this block have enough space to make the allocation? 
10b5 23			      inc   HL                      ; Load free block size into DE 
10b6 5e			      ld    E, (HL) 
10b7 23			      inc   HL 
10b8 56			      ld    D, (HL) 
10b9			 
10b9 eb			      ex    DE, HL                  ; Check size of block against want 
10ba b7			      or    A                       ; Ensure carry flag clear 
10bb ed 42		      sbc   HL, BC 
10bd e5			      push  HL                      ; Store the result for later (new block size) 
10be			 
10be ca 0d 11		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
10c1 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
10c3			 
10c3			      ; this_free block is not big enough, setup ptrs to test next free block 
10c3 e1			      pop   HL                      ; Discard previous result 
10c4			 
10c4 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
10c7 dd 66 03		      ld    H, (IX+3) 
10ca dd 75 04		      ld    (IX+4), L 
10cd dd 74 05		      ld    (IX+5), H 
10d0			 
10d0 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
10d3 dd 66 01		      ld    H, (IX+1) 
10d6 dd 75 02		      ld    (IX+2), L 
10d9 dd 74 03		      ld    (IX+3), H 
10dc			 
10dc					if DEBUG_FORTH_MALLOC 
10dc						DMARK "MA>" 
10dc						CALLMONITOR 
10dc					endif 
10dc 18 c9		      jr    malloc_find_space 
10de			 
10de			      ; split a bigger block into two - requested size and remaining size 
10de			malloc_alloc_split: 
10de					if DEBUG_FORTH_MALLOC 
10de						DMARK "MAs" 
10de						CALLMONITOR 
10de					endif 
10de eb			      ex    DE, HL                  ; Calculate address of new free block 
10df 2b			      dec   HL 
10e0 2b			      dec   HL 
10e1 2b			      dec   HL 
10e2 09			      add   HL, BC 
10e3			 
10e3			      ; Create a new block and point it at next_free 
10e3 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
10e6 dd 56 01		      ld    D, (IX+1) 
10e9			 
10e9 73			      ld    (HL), E                 ; Store next_free ptr into new block 
10ea 23			      inc   HL 
10eb 72			      ld    (HL), D 
10ec			 
10ec d1			      pop   DE                      ; Store size of new block into new block 
10ed 23			      inc   HL 
10ee 73			      ld    (HL), E 
10ef 23			      inc   HL 
10f0 72			      ld    (HL), D 
10f1			 
10f1			      ; Update this_free ptr to point to new block 
10f1 2b			      dec   HL 
10f2 2b			      dec   HL 
10f3 2b			      dec   HL 
10f4			 
10f4 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
10f7 dd 56 03		      ld    D, (IX+3) 
10fa			 
10fa dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
10fd dd 74 03		      ld    (IX+3), H 
1100			 
1100			      ; Modify this_free block to be allocation 
1100 eb			      ex    DE, HL 
1101 af			      xor   A                       ; Null the next block ptr of allocated block 
1102 77			      ld    (HL), A 
1103 23			      inc   HL 
1104 77			      ld    (HL), A 
1105			 
1105 23			      inc   HL                      ; Store want size into allocated block 
1106 71			      ld    (HL), C 
1107 23			      inc   HL 
1108 70			      ld    (HL), B 
1109 23			      inc   HL 
110a e5			      push  HL                      ; Address of allocation to return 
110b			 
110b 18 19		      jr    malloc_update_links 
110d			 
110d			malloc_alloc_fit: 
110d e1			      pop   HL                      ; Dont need new block size, want is exact fit 
110e			 
110e					if DEBUG_FORTH_MALLOC 
110e						DMARK "MAf" 
110e						CALLMONITOR 
110e					endif 
110e			      ; Modify this_free block to be allocation 
110e eb			      ex    DE, HL 
110f 2b			      dec   HL 
1110 2b			      dec   HL 
1111 2b			      dec   HL 
1112			 
1112 af			      xor   A                       ; Null the next block ptr of allocated block 
1113 77			      ld    (HL), A 
1114 23			      inc   HL 
1115 77			      ld    (HL), A 
1116			 
1116 23			      inc   HL                      ; Store address of allocation to return 
1117 23			      inc   HL 
1118 23			      inc   HL 
1119 e5			      push  HL 
111a			 
111a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
111a dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
111d dd 66 01		      ld    H, (IX+1) 
1120			 
1120 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1123 dd 74 03		      ld    (IX+3), H 
1126			 
1126			 
1126			malloc_update_links: 
1126			      ; Update prev_free ptr to point to this_free 
1126 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1129 dd 66 05		      ld    H, (IX+5) 
112c			 
112c dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
112f dd 56 03		      ld    D, (IX+3) 
1132			 
1132 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1133 23			      inc   HL 
1134 72			      ld    (HL), D 
1135			 
1135					if DEBUG_FORTH_MALLOC 
1135						DMARK "Mul" 
1135						CALLMONITOR 
1135					endif 
1135			      ; Clear the Z flag to indicate successful allocation 
1135 7a			      ld    A, D 
1136 b3			      or    E 
1137			 
1137 d1			      pop   DE                      ; Address of allocation 
1138					if DEBUG_FORTH_MALLOC 
1138						DMARK "MAu" 
1138						CALLMONITOR 
1138					endif 
1138			 
1138			malloc_no_space: 
1138 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
113b 39			      add   HL, SP 
113c f9			      ld    SP, HL 
113d			 
113d eb			      ex    DE, HL                  ; Alloc addr into HL for return 
113e					if DEBUG_FORTH_MALLOC 
113e						DMARK "MAN" 
113e						CALLMONITOR 
113e					endif 
113e			 
113e			malloc_early_exit: 
113e					if DEBUG_FORTH_MALLOC 
113e						DMARK "MAx" 
113e						CALLMONITOR 
113e					endif 
113e dd e1		      pop   IX 
1140 d1			      pop   DE 
1141 c1			      pop   BC 
1142			 
1142			if DEBUG_FORTH_MALLOC_HIGH 
1142			call malloc_guard_exit 
1142			call malloc_guard_zerolen 
1142			endif 
1142 c9			      ret 
1143			 
1143			 
1143			;------------------------------------------------------------------------------ 
1143			;     free                                                                    : 
1143			;                                                                             : 
1143			; Description                                                                 : 
1143			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1143			;     returned by malloc, otherwise the behaviour is undefined.               : 
1143			;                                                                             : 
1143			;     Where possible, directly adjacent free blocks will be merged together   : 
1143			;     into larger blocks to help ensure that the heap does not become         : 
1143			;     excessively fragmented.                                                 : 
1143			;                                                                             : 
1143			;     free does not clear or set any other value into the freed space, and    : 
1143			;     therefore its contents may be visible through subsequent malloc's. The  : 
1143			;     caller should clear the freed space as required.                        : 
1143			;                                                                             : 
1143			;     This implementation of free uses the stack exclusively, and is          : 
1143			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1143			;     advisable to disable interrupts before calling free, and recommended    : 
1143			;     to avoid the use of free inside ISRs in general.                        : 
1143			;                                                                             : 
1143			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1143			;                                                                             : 
1143			; Parameters                                                                  : 
1143			;     HL  Pointer to address of first byte of allocation to be freed          : 
1143			;                                                                             : 
1143			; Returns                                                                     : 
1143			;     Nothing                                                                 : 
1143			;                                                                             : 
1143			; Stack frame                                                                 : 
1143			;       |             |                                                       : 
1143			;       +-------------+                                                       : 
1143			;       |     BC      |                                                       : 
1143			;       +-------------+                                                       : 
1143			;       |     DE      |                                                       : 
1143			;       +-------------+                                                       : 
1143			;       |     IX      |                                                       : 
1143			;       +-------------+                                                       : 
1143			;       |  prev_free  |                                                       : 
1143			;   +2  +-------------+                                                       : 
1143			;       |  next_free  |                                                       : 
1143			;   +0  +-------------+                                                       : 
1143			;       |             |                                                       : 
1143			;                                                                             : 
1143			;------------------------------------------------------------------------------ 
1143			free: 
1143 c5			      push  BC 
1144 d5			      push  DE 
1145 dd e5		      push  IX 
1147			 
1147 7c			      ld    A, H                    ; Exit if ptr is null 
1148 b5			      or    L 
1149 ca 0d 12		      jp    Z, free_early_exit 
114c			 
114c			      ; Set up stack frame 
114c eb			      ex    DE, HL 
114d 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1150 39			      add   HL, SP 
1151 f9			      ld    SP, HL 
1152 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1156 dd 39		      add   IX, SP 
1158			 
1158			      ; The address in HL points to the start of the useable allocated space, 
1158			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1158			      ; address of the block itself. 
1158 eb			      ex    DE, HL 
1159 11 fc ff		      ld    DE, -4 
115c 19			      add   HL, DE 
115d			 
115d			      ; An allocated block must have a null next block pointer in it 
115d 7e			      ld    A, (HL) 
115e 23			      inc   HL 
115f b6			      or    (HL) 
1160 c2 08 12		      jp    NZ, free_done 
1163			 
1163 2b			      dec   HL 
1164			 
1164 44			      ld    B, H                    ; Copy HL to BC 
1165 4d			      ld    C, L 
1166			 
1166			      ; Loop through the free list to find the first block with an address 
1166			      ; higher than the block being freed 
1166 21 a0 58		      ld    HL, free_list 
1169			 
1169			free_find_higher_block: 
1169 5e			      ld    E, (HL)                 ; Load next ptr from free block 
116a 23			      inc   HL 
116b 56			      ld    D, (HL) 
116c 2b			      dec   HL 
116d			 
116d dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1170 dd 72 01		      ld    (IX+1), D 
1173 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1176 dd 74 03		      ld    (IX+3), H 
1179			 
1179 78			      ld    A, B                    ; Check if DE is greater than BC 
117a ba			      cp    D                       ; Compare MSB first 
117b 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
117d 30 04		      jr    NC, free_find_higher_block_skip 
117f 79			      ld    A, C 
1180 bb			      cp    E                       ; Then compare LSB 
1181 38 08		      jr    C, free_found_higher_block 
1183			 
1183			free_find_higher_block_skip: 
1183 7a			      ld    A, D                    ; Reached the end of the free list? 
1184 b3			      or    E 
1185 ca 08 12		      jp    Z, free_done 
1188			 
1188 eb			      ex    DE, HL 
1189			 
1189 18 de		      jr    free_find_higher_block 
118b			 
118b			free_found_higher_block: 
118b			      ; Insert freed block between prev and next free blocks 
118b 71			      ld    (HL), C                 ; Point prev free block to freed block 
118c 23			      inc   HL 
118d 70			      ld    (HL), B 
118e			 
118e 60			      ld    H, B                    ; Point freed block at next free block 
118f 69			      ld    L, C 
1190 73			      ld    (HL), E 
1191 23			      inc   HL 
1192 72			      ld    (HL), D 
1193			 
1193			      ; Check if the freed block is adjacent to the next free block 
1193 23			      inc   HL                      ; Load size of freed block into HL 
1194 5e			      ld    E, (HL) 
1195 23			      inc   HL 
1196 56			      ld    D, (HL) 
1197 eb			      ex    DE, HL 
1198			 
1198 09			      add   HL, BC                  ; Add addr of freed block and its size 
1199			 
1199 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
119c dd 56 01		      ld    D, (IX+1) 
119f			 
119f b7			      or    A                       ; Clear the carry flag 
11a0 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
11a2 20 22		      jr    NZ, free_check_adjacent_to_prev 
11a4			 
11a4			      ; Freed block is adjacent to next, merge into one bigger block 
11a4 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
11a5 5e			      ld    E, (HL) 
11a6 23			      inc   HL 
11a7 56			      ld    D, (HL) 
11a8 e5			      push  HL                      ; Save ptr to next block for later 
11a9			 
11a9 60			      ld    H, B                    ; Store ptr from next block into freed block 
11aa 69			      ld    L, C 
11ab 73			      ld    (HL), E 
11ac 23			      inc   HL 
11ad 72			      ld    (HL), D 
11ae			 
11ae e1			      pop   HL                      ; Restore ptr to next block 
11af 23			      inc   HL                      ; Load size of next block into DE 
11b0 5e			      ld    E, (HL) 
11b1 23			      inc   HL 
11b2 56			      ld    D, (HL) 
11b3 d5			      push  DE                      ; Save next block size for later 
11b4			 
11b4 60			      ld    H, B                    ; Load size of freed block into HL 
11b5 69			      ld    L, C 
11b6 23			      inc   HL 
11b7 23			      inc   HL 
11b8 5e			      ld    E, (HL) 
11b9 23			      inc   HL 
11ba 56			      ld    D, (HL) 
11bb eb			      ex    DE, HL 
11bc			 
11bc d1			      pop   DE                      ; Restore size of next block 
11bd 19			      add   HL, DE                  ; Add sizes of both blocks 
11be eb			      ex    DE, HL 
11bf			 
11bf 60			      ld    H, B                    ; Store new bigger size into freed block 
11c0 69			      ld    L, C 
11c1 23			      inc   HL 
11c2 23			      inc   HL 
11c3 73			      ld    (HL), E 
11c4 23			      inc   HL 
11c5 72			      ld    (HL), D 
11c6			 
11c6			free_check_adjacent_to_prev: 
11c6			      ; Check if the freed block is adjacent to the prev free block 
11c6 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
11c9 dd 66 03		      ld    H, (IX+3) 
11cc			 
11cc 23			      inc   HL                      ; Size of prev free block into DE 
11cd 23			      inc   HL 
11ce 5e			      ld    E, (HL) 
11cf 23			      inc   HL 
11d0 56			      ld    D, (HL) 
11d1 2b			      dec   HL 
11d2 2b			      dec   HL 
11d3 2b			      dec   HL 
11d4			 
11d4 19			      add   HL, DE                  ; Add prev block addr and size 
11d5			 
11d5 b7			      or    A                       ; Clear the carry flag 
11d6 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
11d8 20 2e		      jr    NZ, free_done 
11da			 
11da			      ; Freed block is adjacent to prev, merge into one bigger block 
11da 60			      ld    H, B                    ; Load next ptr from freed block into DE 
11db 69			      ld    L, C 
11dc 5e			      ld    E, (HL) 
11dd 23			      inc   HL 
11de 56			      ld    D, (HL) 
11df e5			      push  HL                      ; Save freed block ptr for later 
11e0			 
11e0 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
11e3 dd 66 03		      ld    H, (IX+3) 
11e6 73			      ld    (HL), E 
11e7 23			      inc   HL 
11e8 72			      ld    (HL), D 
11e9			 
11e9 e1			      pop   HL                      ; Restore freed block ptr 
11ea 23			      inc   HL                      ; Load size of freed block into DE 
11eb 5e			      ld    E, (HL) 
11ec 23			      inc   HL 
11ed 56			      ld    D, (HL) 
11ee d5			      push  DE                      ; Save freed block size for later 
11ef			 
11ef dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
11f2 dd 66 03		      ld    H, (IX+3) 
11f5 23			      inc   HL 
11f6 23			      inc   HL 
11f7 5e			      ld    E, (HL) 
11f8 23			      inc   HL 
11f9 56			      ld    D, (HL) 
11fa			 
11fa e1			      pop   HL                      ; Add sizes of both blocks 
11fb 19			      add   HL, DE 
11fc eb			      ex    DE, HL 
11fd			 
11fd dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1200 dd 66 03		      ld    H, (IX+3) 
1203 23			      inc   HL 
1204 23			      inc   HL 
1205 73			      ld    (HL), E 
1206 23			      inc   HL 
1207 72			      ld    (HL), D 
1208			 
1208			free_done: 
1208 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
120b 39			      add   HL, SP 
120c f9			      ld    SP, HL 
120d			 
120d			free_early_exit: 
120d dd e1		      pop   IX 
120f d1			      pop   DE 
1210 c1			      pop   BC 
1211			 
1211 c9			      ret 
1212			 
1212			; moved to firmware.asm 
1212			; 
1212			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1212			;                  .dw   0 
1212			 
1212			 
1212			endif 
1212			 
1212			 
1212			if MALLOC_3 
1212			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1212			;heap_start        .equ  0x9000      ; Starting address of heap 
1212			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1212			; 
1212			 ;     .org 0 
1212			  ;    jp    main 
1212			; 
1212			; 
1212			 ;     .org  0x100 
1212			;main: 
1212			 ;     ld    HL, 0x8100 
1212			  ;    ld    SP, HL 
1212			; 
1212			;      call  heap_init 
1212			 
1212			      ; Make some allocations 
1212			;      ld    HL, 12 
1212			;      call  malloc            ; Allocates 0x9004 
1212			; 
1212			 ;     ld    HL, 12 
1212			;      call  malloc            ; Allocates 0x9014 
1212			 
1212			;      ld    HL, 12 
1212			;      call  malloc            ; Allocates 0x9024 
1212			 
1212			      ; Free some allocations 
1212			;      ld    HL, 0x9014 
1212			;      call  free 
1212			 
1212			;      ld    HL, 0x9004 
1212			;      call  free 
1212			; 
1212			;      ld    HL, 0x9024 
1212			;      call  free 
1212			 
1212			 
1212			 ;     halt 
1212			 
1212			 
1212			;------------------------------------------------------------------------------ 
1212			;     heap_init                                                               : 
1212			;                                                                             : 
1212			; Description                                                                 : 
1212			;     Initialise the heap and make it ready for malloc and free operations.   : 
1212			;                                                                             : 
1212			;     The heap is maintained as a linked list, starting with an initial       : 
1212			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1212			;     the first free block in the heap. Each block then points to the next    : 
1212			;     free block within the heap, and the free list ends at the first block   : 
1212			;     with a null pointer to the next free block.                             : 
1212			;                                                                             : 
1212			; Parameters                                                                  : 
1212			;     Inputs are compile-time only. Two defines which specify the starting    : 
1212			;     address of the heap and its size are required, along with a memory      : 
1212			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1212			;     principally stores a pointer to the first free block in the heap.       : 
1212			;                                                                             : 
1212			; Returns                                                                     : 
1212			;     Nothing                                                                 : 
1212			;------------------------------------------------------------------------------ 
1212			heap_init: 
1212			      push  HL 
1212			 
1212			      ; Initialise free list struct 
1212			      ld    HL, heap_start 
1212			      ld    (free_list), HL 
1212			      ld    HL, 0 
1212			      ld    (free_list+2), HL 
1212			 
1212			      ; Insert first free block at bottom of heap, consumes entire heap 
1212			      ld    HL, heap_start+heap_size-4 
1212			      ld    (heap_start), HL        ; Next block (end of free list) 
1212			      ld    HL, heap_size-4 
1212			      ld    (heap_start+2), HL      ; Block size 
1212			 
1212			      ; Insert end of free list block at top of heap - two null words will 
1212			      ; terminate the free list 
1212			      ld    HL, 0 
1212			      ld    (heap_start+heap_size-2), HL 
1212			      ld    (heap_start+heap_size-4), HL 
1212			 
1212			      pop   HL 
1212			 
1212			      ret 
1212			 
1212			 
1212			;------------------------------------------------------------------------------ 
1212			;     malloc                                                                  : 
1212			;                                                                             : 
1212			; Description                                                                 : 
1212			;     Allocates the wanted space from the heap and returns the address of the : 
1212			;     first useable byte of the allocation.                                   : 
1212			;                                                                             : 
1212			;     Allocations can happen in one of two ways:                              : 
1212			;                                                                             : 
1212			;     1. A free block may be found which is the exact size wanted. In this    : 
1212			;        case the block is removed from the free list and retuedn to the      : 
1212			;        caller.                                                              : 
1212			;     2. A free block may be found which is larger than the size wanted. In   : 
1212			;        this case, the larger block is split into two. The first portion of  : 
1212			;        this block will become the requested space by the malloc call and    : 
1212			;        is returned to the caller. The second portion becomes a new free     : 
1212			;        block, and the free list is adjusted to maintain continuity via this : 
1212			;        newly created block.                                                 : 
1212			;                                                                             : 
1212			;     malloc does not set any initial value in the allocated space, the       : 
1212			;     caller is required to do this as required.                              : 
1212			;                                                                             : 
1212			;     This implementation of malloc uses the stack exclusively, and is        : 
1212			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1212			;     advisable to disable interrupts before calling malloc, and recommended  : 
1212			;     to avoid the use of malloc inside ISRs in general.                      : 
1212			;                                                                             : 
1212			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1212			;                                                                             : 
1212			; Parameters                                                                  : 
1212			;     HL  Number of bytes wanted                                              : 
1212			;                                                                             : 
1212			; Returns                                                                     : 
1212			;     HL  Address of the first useable byte of the allocation                 : 
1212			;                                                                             : 
1212			; Flags                                                                       : 
1212			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1212			;                                                                             : 
1212			; Stack frame                                                                 : 
1212			;       |             |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |     BC      |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |     DE      |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |     IX      |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |  prev_free  |                                                       : 
1212			;   +4  +-------------+                                                       : 
1212			;       |  this_free  |                                                       : 
1212			;   +2  +-------------+                                                       : 
1212			;       |  next_free  |                                                       : 
1212			;   +0  +-------------+                                                       : 
1212			;       |             |                                                       : 
1212			;                                                                             : 
1212			;------------------------------------------------------------------------------ 
1212			malloc: 
1212			      push  BC 
1212			      push  DE 
1212			      push  IX 
1212			 
1212			      ld    A, H                    ; Exit if no space requested 
1212			      or    L 
1212			      jp    Z, malloc_early_exit 
1212			 
1212			      ; Set up stack frame 
1212			      ex    DE, HL 
1212			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1212			      add   HL, SP 
1212			      ld    SP, HL 
1212			      ld    IX, 0                   ; Use IX as a frame pointer 
1212			      add   IX, SP 
1212			 
1212			      ; Setup initial state 
1212			      ld    HL, 4                   ; want must also include space used by block struct 
1212			      add   HL, DE 
1212			 
1212			      ld    B, H                    ; Move want to BC 
1212			      ld    C, L 
1212			 
1212			      ld    HL, free_list           ; Store prev_free ptr to stack 
1212			      ld    (IX+4), L 
1212			      ld    (IX+5), H 
1212			 
1212			      ld    E, (HL)                 ; Store this_free ptr to stack 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      ld    (IX+2), E 
1212			      ld    (IX+3), D 
1212			      ex    DE, HL                  ; this_free ptr into HL 
1212			 
1212			      ; Loop through free block list to find some space 
1212			malloc_find_space: 
1212			      ld    E, (HL)                 ; Load next_free ptr into DE 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			 
1212			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1212			      or    E 
1212			      jp    Z, malloc_no_space 
1212			 
1212			      ld    (IX+0), E               ; Store next_free ptr to stack 
1212			      ld    (IX+1), D 
1212			 
1212			      ; Does this block have enough space to make the allocation? 
1212			      inc   HL                      ; Load free block size into DE 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			 
1212			      ex    DE, HL                  ; Check size of block against want 
1212			      or    A                       ; Ensure carry flag clear 
1212			      sbc   HL, BC 
1212			      push  HL                      ; Store the result for later (new block size) 
1212			 
1212			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1212			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1212			 
1212			      ; this_free block is not big enough, setup ptrs to test next free block 
1212			      pop   HL                      ; Discard previous result 
1212			 
1212			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1212			      ld    H, (IX+3) 
1212			      ld    (IX+4), L 
1212			      ld    (IX+5), H 
1212			 
1212			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1212			      ld    H, (IX+1) 
1212			      ld    (IX+2), L 
1212			      ld    (IX+3), H 
1212			 
1212			      jr    malloc_find_space 
1212			 
1212			      ; split a bigger block into two - requested size and remaining size 
1212			malloc_alloc_split: 
1212			      ex    DE, HL                  ; Calculate address of new free block 
1212			      dec   HL 
1212			      dec   HL 
1212			      dec   HL 
1212			      add   HL, BC 
1212			 
1212			      ; Create a new block and point it at next_free 
1212			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1212			      ld    D, (IX+1) 
1212			 
1212			      ld    (HL), E                 ; Store next_free ptr into new block 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			      pop   DE                      ; Store size of new block into new block 
1212			      inc   HL 
1212			      ld    (HL), E 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			      ; Update this_free ptr to point to new block 
1212			      dec   HL 
1212			      dec   HL 
1212			      dec   HL 
1212			 
1212			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1212			      ld    D, (IX+3) 
1212			 
1212			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1212			      ld    (IX+3), H 
1212			 
1212			      ; Modify this_free block to be allocation 
1212			      ex    DE, HL 
1212			      xor   A                       ; Null the next block ptr of allocated block 
1212			      ld    (HL), A 
1212			      inc   HL 
1212			      ld    (HL), A 
1212			 
1212			      inc   HL                      ; Store want size into allocated block 
1212			      ld    (HL), C 
1212			      inc   HL 
1212			      ld    (HL), B 
1212			      inc   HL 
1212			      push  HL                      ; Address of allocation to return 
1212			 
1212			      jr    malloc_update_links 
1212			 
1212			malloc_alloc_fit: 
1212			      pop   HL                      ; Dont need new block size, want is exact fit 
1212			 
1212			      ; Modify this_free block to be allocation 
1212			      ex    DE, HL 
1212			      dec   HL 
1212			      dec   HL 
1212			      dec   HL 
1212			 
1212			      xor   A                       ; Null the next block ptr of allocated block 
1212			      ld    (HL), A 
1212			      inc   HL 
1212			      ld    (HL), A 
1212			 
1212			      inc   HL                      ; Store address of allocation to return 
1212			      inc   HL 
1212			      inc   HL 
1212			      push  HL 
1212			 
1212			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1212			      ld    L, (IX+0)               ; next_free to HL 
1212			      ld    H, (IX+1) 
1212			 
1212			      ld    (IX+2), L               ; HL to this_free 
1212			      ld    (IX+3), H 
1212			 
1212			 
1212			malloc_update_links: 
1212			      ; Update prev_free ptr to point to this_free 
1212			      ld    L, (IX+4)               ; prev_free ptr to HL 
1212			      ld    H, (IX+5) 
1212			 
1212			      ld    E, (IX+2)               ; this_free ptr to DE 
1212			      ld    D, (IX+3) 
1212			 
1212			      ld    (HL), E                 ; this_free ptr into prev_free 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			      ; Clear the Z flag to indicate successful allocation 
1212			      ld    A, D 
1212			      or    E 
1212			 
1212			      pop   DE                      ; Address of allocation 
1212			 
1212			malloc_no_space: 
1212			      ld    HL, 6                   ; Clean up stack frame 
1212			      add   HL, SP 
1212			      ld    SP, HL 
1212			 
1212			      ex    DE, HL                  ; Alloc addr into HL for return 
1212			 
1212			malloc_early_exit: 
1212			      pop   IX 
1212			      pop   DE 
1212			      pop   BC 
1212			 
1212			      ret 
1212			 
1212			 
1212			;------------------------------------------------------------------------------ 
1212			;     free                                                                    : 
1212			;                                                                             : 
1212			; Description                                                                 : 
1212			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1212			;     returned by malloc, otherwise the behaviour is undefined.               : 
1212			;                                                                             : 
1212			;     Where possible, directly adjacent free blocks will be merged together   : 
1212			;     into larger blocks to help ensure that the heap does not become         : 
1212			;     excessively fragmented.                                                 : 
1212			;                                                                             : 
1212			;     free does not clear or set any other value into the freed space, and    : 
1212			;     therefore its contents may be visible through subsequent malloc's. The  : 
1212			;     caller should clear the freed space as required.                        : 
1212			;                                                                             : 
1212			;     This implementation of free uses the stack exclusively, and is          : 
1212			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1212			;     advisable to disable interrupts before calling free, and recommended    : 
1212			;     to avoid the use of free inside ISRs in general.                        : 
1212			;                                                                             : 
1212			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1212			;                                                                             : 
1212			; Parameters                                                                  : 
1212			;     HL  Pointer to address of first byte of allocation to be freed          : 
1212			;                                                                             : 
1212			; Returns                                                                     : 
1212			;     Nothing                                                                 : 
1212			;                                                                             : 
1212			; Stack frame                                                                 : 
1212			;       |             |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |     BC      |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |     DE      |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |     IX      |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |  prev_free  |                                                       : 
1212			;   +2  +-------------+                                                       : 
1212			;       |  next_free  |                                                       : 
1212			;   +0  +-------------+                                                       : 
1212			;       |             |                                                       : 
1212			;                                                                             : 
1212			;------------------------------------------------------------------------------ 
1212			free: 
1212			      push  BC 
1212			      push  DE 
1212			      push  IX 
1212			 
1212			      ld    A, H                    ; Exit if ptr is null 
1212			      or    L 
1212			      jp    Z, free_early_exit 
1212			 
1212			      ; Set up stack frame 
1212			      ex    DE, HL 
1212			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1212			      add   HL, SP 
1212			      ld    SP, HL 
1212			      ld    IX, 0                   ; Use IX as a frame pointer 
1212			      add   IX, SP 
1212			 
1212			      ; The address in HL points to the start of the useable allocated space, 
1212			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1212			      ; address of the block itself. 
1212			      ex    DE, HL 
1212			      ld    DE, -4 
1212			      add   HL, DE 
1212			 
1212			      ; An allocated block must have a null next block pointer in it 
1212			      ld    A, (HL) 
1212			      inc   HL 
1212			      or    (HL) 
1212			      jp    NZ, free_done 
1212			 
1212			      dec   HL 
1212			 
1212			      ld    B, H                    ; Copy HL to BC 
1212			      ld    C, L 
1212			 
1212			      ; Loop through the free list to find the first block with an address 
1212			      ; higher than the block being freed 
1212			      ld    HL, free_list 
1212			 
1212			free_find_higher_block: 
1212			      ld    E, (HL)                 ; Load next ptr from free block 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      dec   HL 
1212			 
1212			      ld    (IX+0), E               ; Save ptr to next free block 
1212			      ld    (IX+1), D 
1212			      ld    (IX+2), L               ; Save ptr to prev free block 
1212			      ld    (IX+3), H 
1212			 
1212			      ld    A, B                    ; Check if DE is greater than BC 
1212			      cp    D                       ; Compare MSB first 
1212			      jr    Z, $+4                  ; MSB the same, compare LSB 
1212			      jr    NC, free_find_higher_block_skip 
1212			      ld    A, C 
1212			      cp    E                       ; Then compare LSB 
1212			      jr    C, free_found_higher_block 
1212			 
1212			free_find_higher_block_skip: 
1212			      ld    A, D                    ; Reached the end of the free list? 
1212			      or    E 
1212			      jp    Z, free_done 
1212			 
1212			      ex    DE, HL 
1212			 
1212			      jr    free_find_higher_block 
1212			 
1212			free_found_higher_block: 
1212			      ; Insert freed block between prev and next free blocks 
1212			      ld    (HL), C                 ; Point prev free block to freed block 
1212			      inc   HL 
1212			      ld    (HL), B 
1212			 
1212			      ld    H, B                    ; Point freed block at next free block 
1212			      ld    L, C 
1212			      ld    (HL), E 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			      ; Check if the freed block is adjacent to the next free block 
1212			      inc   HL                      ; Load size of freed block into HL 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      ex    DE, HL 
1212			 
1212			      add   HL, BC                  ; Add addr of freed block and its size 
1212			 
1212			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1212			      ld    D, (IX+1) 
1212			 
1212			      or    A                       ; Clear the carry flag 
1212			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1212			      jr    NZ, free_check_adjacent_to_prev 
1212			 
1212			      ; Freed block is adjacent to next, merge into one bigger block 
1212			      ex    DE, HL                  ; Load next ptr from next block into DE 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      push  HL                      ; Save ptr to next block for later 
1212			 
1212			      ld    H, B                    ; Store ptr from next block into freed block 
1212			      ld    L, C 
1212			      ld    (HL), E 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			      pop   HL                      ; Restore ptr to next block 
1212			      inc   HL                      ; Load size of next block into DE 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      push  DE                      ; Save next block size for later 
1212			 
1212			      ld    H, B                    ; Load size of freed block into HL 
1212			      ld    L, C 
1212			      inc   HL 
1212			      inc   HL 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      ex    DE, HL 
1212			 
1212			      pop   DE                      ; Restore size of next block 
1212			      add   HL, DE                  ; Add sizes of both blocks 
1212			      ex    DE, HL 
1212			 
1212			      ld    H, B                    ; Store new bigger size into freed block 
1212			      ld    L, C 
1212			      inc   HL 
1212			      inc   HL 
1212			      ld    (HL), E 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			free_check_adjacent_to_prev: 
1212			      ; Check if the freed block is adjacent to the prev free block 
1212			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1212			      ld    H, (IX+3) 
1212			 
1212			      inc   HL                      ; Size of prev free block into DE 
1212			      inc   HL 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      dec   HL 
1212			      dec   HL 
1212			      dec   HL 
1212			 
1212			      add   HL, DE                  ; Add prev block addr and size 
1212			 
1212			      or    A                       ; Clear the carry flag 
1212			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1212			      jr    NZ, free_done 
1212			 
1212			      ; Freed block is adjacent to prev, merge into one bigger block 
1212			      ld    H, B                    ; Load next ptr from freed block into DE 
1212			      ld    L, C 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      push  HL                      ; Save freed block ptr for later 
1212			 
1212			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1212			      ld    H, (IX+3) 
1212			      ld    (HL), E 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			      pop   HL                      ; Restore freed block ptr 
1212			      inc   HL                      ; Load size of freed block into DE 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			      push  DE                      ; Save freed block size for later 
1212			 
1212			      ld    L, (IX+2)               ; Load size of prev block into DE 
1212			      ld    H, (IX+3) 
1212			      inc   HL 
1212			      inc   HL 
1212			      ld    E, (HL) 
1212			      inc   HL 
1212			      ld    D, (HL) 
1212			 
1212			      pop   HL                      ; Add sizes of both blocks 
1212			      add   HL, DE 
1212			      ex    DE, HL 
1212			 
1212			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1212			      ld    H, (IX+3) 
1212			      inc   HL 
1212			      inc   HL 
1212			      ld    (HL), E 
1212			      inc   HL 
1212			      ld    (HL), D 
1212			 
1212			free_done: 
1212			      ld    HL, 4                   ; Clean up stack frame 
1212			      add   HL, SP 
1212			      ld    SP, HL 
1212			 
1212			free_early_exit: 
1212			      pop   IX 
1212			      pop   DE 
1212			      pop   BC 
1212			 
1212			      ret 
1212			 
1212			 
1212			;      .org 0x8000 
1212			; 
1212			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1212			 ;                 .dw   0 
1212			 
1212			endif 
1212			 
1212			 
1212			if MALLOC_4 
1212			 
1212			; My memory allocation code. Very very simple.... 
1212			; allocate space under 250 chars 
1212			 
1212			heap_init: 
1212				; init start of heap as zero 
1212				;  
1212			 
1212				ld hl, heap_start 
1212				ld a, 0 
1212				ld (hl), a      ; empty block 
1212				inc hl 
1212				ld a, 0 
1212				ld (hl), a      ; length of block 
1212				; write end of list 
1212				inc hl 
1212				ld a,(hl) 
1212				inc hl 
1212				ld a,(hl) 
1212				 
1212			 
1212				; init some malloc vars 
1212			 
1212				ld hl, 0 
1212				ld (free_list), hl       ; store last malloc location 
1212			 
1212				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1212				ld a, 0 
1212				ld (hl), a 
1212			 
1212			 
1212				ld hl, heap_start 
1212				;  
1212				  
1212				ret 
1212			 
1212			 
1212			;    free block marker 
1212			;    requested size  
1212			;    pointer to next block 
1212			;    .... 
1212			;    next block marker 
1212			 
1212			 
1212			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1212			; 
1212			 
1212			 
1212			malloc:  
1212				push de 
1212				push bc 
1212				push af 
1212			 
1212				; hl space required 
1212				 
1212				ld c, l    ; hold space   (TODO only a max of 255) 
1212			 
1212			;	inc c     ; TODO BUG need to fix memory leak on push str 
1212			;	inc c 
1212			;	inc c 
1212			;	inc c 
1212			;	inc c 
1212			;	inc c 
1212			;	inc c 
1212			 
1212			 
1212			 
1212				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1212			 
1212				ld a, (free_list+3) 
1212				cp 0 
1212				jr z, .contheap 
1212			 
1212				ld hl, (free_list)     ; get last alloc 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "mrs" 
1212						CALLMONITOR 
1212					endif 
1212				jr .startalloc 
1212			 
1212			.contheap: 
1212				ld hl, heap_start 
1212			 
1212			.startalloc: 
1212			 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "mym" 
1212						CALLMONITOR 
1212					endif 
1212			.findblock: 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "mmf" 
1212						CALLMONITOR 
1212					endif 
1212			 
1212				ld a,(hl)  
1212				; if byte is zero then clear to use 
1212			 
1212				cp 0 
1212				jr z, .foundemptyblock 
1212			 
1212				; if byte is not clear 
1212				;     then byte is offset to next block 
1212			 
1212				inc hl 
1212				ld a, (hl) ; get size 
1212			.nextblock:	inc hl 
1212					ld e, (hl) 
1212					inc hl 
1212					ld d, (hl) 
1212					ex de, hl 
1212			;	inc hl  ; move past the store space 
1212			;	inc hl  ; move past zero index  
1212			 
1212				; TODO detect no more space 
1212			 
1212				push hl 
1212				ld de, heap_end 
1212				call cmp16 
1212				pop hl 
1212				jr nc, .nospace 
1212			 
1212				jr .findblock 
1212			 
1212			.nospace: ld hl, 0 
1212				jp .exit 
1212			 
1212			 
1212			.foundemptyblock:	 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "mme" 
1212						CALLMONITOR 
1212					endif 
1212			 
1212			; TODO has block enough space if reusing??? 
1212			 
1212				;  
1212			 
1212			; see if this block has been previously used 
1212				inc hl 
1212				ld a, (hl) 
1212				dec hl 
1212				cp 0 
1212				jr z, .newblock 
1212			 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "meR" 
1212						CALLMONITOR 
1212					endif 
1212			 
1212			; no reusing previously allocated block 
1212			 
1212			; is it smaller than previously used? 
1212				 
1212				inc hl    ; move to size 
1212				ld a, c 
1212				sub (hl)        ; we want c < (hl) 
1212				dec hl    ; move back to marker 
1212			        jr z, .findblock 
1212			 
1212				; update with the new size which should be lower 
1212			 
1212			        ;inc  hl   ; negate next move. move back to size  
1212			 
1212			.newblock: 
1212				; need to be at marker here 
1212			 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "meN" 
1212						CALLMONITOR 
1212					endif 
1212			 
1212			 
1212				ld a, c 
1212			 
1212				ld (free_list+3), a	 ; flag resume from last malloc  
1212				ld (free_list), hl    ; save out last location 
1212			 
1212			 
1212				;inc a     ; space for length byte 
1212				ld (hl), a     ; save block in use marker 
1212			 
1212				inc hl   ; move to space marker 
1212				ld (hl), a    ; save new space 
1212			 
1212				inc hl   ; move to start of allocated area 
1212				 
1212			;	push hl     ; save where we are - 1  
1212			 
1212			;	inc hl  ; move past zero index  
1212				; skip space to set down new marker 
1212			 
1212				; provide some extra space for now 
1212			 
1212				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1212				inc a 
1212				inc a 
1212			 
1212				push hl   ; save where we are in the node block 
1212			 
1212				call addatohl 
1212			 
1212				; write linked list point 
1212			 
1212				pop de     ; get our node position 
1212				ex de, hl 
1212			 
1212				ld (hl), e 
1212				inc hl 
1212				ld (hl), d 
1212			 
1212				inc hl 
1212			 
1212				; now at start of allocated data so save pointer 
1212			 
1212				push hl 
1212			 
1212				; jump to position of next node and setup empty header in DE 
1212			 
1212				ex de, hl 
1212			 
1212			;	inc hl ; move past end of block 
1212			 
1212				ld a, 0 
1212				ld (hl), a   ; empty marker 
1212				inc hl 
1212				ld (hl), a   ; size 
1212				inc hl  
1212				ld (hl), a   ; ptr 
1212				inc hl 
1212				ld (hl), a   ; ptr 
1212			 
1212			 
1212				pop hl 
1212			 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "mmr" 
1212						CALLMONITOR 
1212					endif 
1212			 
1212			.exit: 
1212				pop af 
1212				pop bc 
1212				pop de  
1212				ret 
1212			 
1212			 
1212			 
1212			 
1212			free:  
1212				push hl 
1212				push af 
1212				; get address in hl 
1212			 
1212					if DEBUG_FORTH_MALLOC_INT 
1212						DMARK "fre" 
1212						CALLMONITOR 
1212					endif 
1212				; data is at hl - move to block count 
1212				dec hl 
1212				dec hl    ; get past pointer 
1212				dec hl 
1212			 
1212				ld a, (hl)    ; need this for a validation check 
1212			 
1212				dec hl    ; move to block marker 
1212			 
1212				; now check that the block count and block marker are the same  
1212			        ; this checks that we are on a malloc node and not random memory 
1212			        ; OK a faint chance this could be a problem but rare - famous last words! 
1212			 
1212				ld c, a 
1212				ld a, (hl)    
1212			 
1212				cp c 
1212				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1212			 
1212				; yes good chance we are on a malloc node 
1212			 
1212				ld a, 0      
1212				ld (hl), a   ; mark as free 
1212			 
1212				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1212			 
1212			.freeignore:  
1212			 
1212				pop af 
1212				pop hl 
1212			 
1212				ret 
1212			 
1212			 
1212			 
1212			endif 
1212			 
1212			; eof 
# End of file firmware_memory.asm
1212			  
1212			; device C  
1212			if SOUND_ENABLE  
1212				include "firmware_sound.asm"  
1212			endif  
1212			  
1212			include "firmware_diags.asm"  
1212			; Hardware diags menu 
1212			 
1212			 
1212			config: 
1212			 
1212 3e 00			ld a, 0 
1214 21 42 12			ld hl, .configmn 
1217 cd b6 09			call menu 
121a			 
121a fe 00			cp 0 
121c c8				ret z 
121d			 
121d fe 01			cp 1 
121f cc ed 12			call z, .savetostore 
1222			 
1222 fe 02			cp 2 
1224 cc eb 12			call z, .selautoload 
1227 fe 03			cp 3 
1229 cc ea 12			call z, .disautoload 
122c fe 04			cp 4 
122e cc ec 12			call z, .selbank 
1231 fe 06			cp 6 
1233 cc ee 12			call z, .debug_tog 
1236 fe 07			cp 7 
1238 cc 36 14			call z, .bpsgo 
123b fe 08			cp 8 
123d cc 14 13			call z, hardware_diags 
1240			 
1240 18 d0			jr config 
1242			 
1242			.configmn: 
1242 54 12			dw .c3 
1244 70 12			dw .c2 
1246 85 12			dw .c2a 
1248 9b 12			dw .c2b 
124a af 12			dw .c4 
124c b8 12			dw .m4 
124e d3 12			dw .m4b 
1250 db 12			dw .c1 
1252 00 00			dw 0 
1254				 
1254			 
1254 .. 00		.c3: db "Add User Dictionary To File",0 
1270 .. 00		.c2: db "Select Autoload File",0 
1285 .. 00		.c2a: db "Disable Autoload File", 0 
129b .. 00		.c2b: db "Select Storage Bank",0 
12af .. 00		.c4: db "Settings",0 
12b8 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
12d3 .. 00		.m4b:   db "Monitor",0 
12db .. 00		.c1: db "Hardware Diags",0 
12ea			 
12ea			 
12ea			.disautoload: 
12ea				if STORAGE_SE 
12ea				ld a, $fe      ; bit 0 clear 
12ea				ld (spi_device), a 
12ea			 
12ea				call storage_get_block_0 
12ea			 
12ea				ld a, 0 
12ea				ld (store_page+STORE_0_AUTOFILE), a 
12ea			 
12ea					ld hl, 0 
12ea					ld de, store_page 
12ea				call storage_write_block	 ; save update 
12ea				endif 
12ea			 
12ea			 
12ea c9				ret 
12eb			 
12eb			 
12eb			 
12eb			; Select auto start 
12eb			 
12eb			.selautoload: 
12eb			 
12eb				 
12eb				if STORAGE_SE 
12eb			 
12eb					call config_dir 
12eb				        ld hl, scratch 
12eb					ld a, 0 
12eb					call menu 
12eb			 
12eb					cp 0 
12eb					ret z 
12eb			 
12eb					dec a 
12eb			 
12eb			 
12eb					; locate menu option 
12eb			 
12eb					ld hl, scratch 
12eb					call table_lookup 
12eb			 
12eb					if DEBUG_FORTH_WORDS 
12eb						DMARK "ALl" 
12eb						CALLMONITOR 
12eb					endif 
12eb					; with the pointer to the menu it, the byte following the zero term is the file id 
12eb			 
12eb					ld a, 0 
12eb					ld bc, 50   ; max of bytes to look at 
12eb					cpir  
12eb			 
12eb					if DEBUG_FORTH_WORDS 
12eb						DMARK "ALb" 
12eb						CALLMONITOR 
12eb					endif 
12eb					;inc hl 
12eb			 
12eb					ld a, (hl)   ; file id 
12eb					 
12eb				        ; save bank and file ids 
12eb			 
12eb					push af 
12eb			 
12eb			; TODO need to save to block 0 on bank 1	 
12eb			 
12eb					call storage_get_block_0 
12eb			 
12eb					if DEBUG_FORTH_WORDS 
12eb						DMARK "AL0" 
12eb						CALLMONITOR 
12eb					endif 
12eb					pop af 
12eb			 
12eb					ld (store_page+STORE_0_FILERUN),a 
12eb					 
12eb					; save bank id 
12eb			 
12eb					ld a,(spi_device) 
12eb					ld (store_page+STORE_0_BANKRUN),a 
12eb			 
12eb					; enable auto run of store file 
12eb			 
12eb					ld a, 1 
12eb					ld (store_page+STORE_0_AUTOFILE),a 
12eb			 
12eb					; save buffer 
12eb			 
12eb					ld hl, 0 
12eb					ld de, store_page 
12eb					if DEBUG_FORTH_WORDS 
12eb						DMARK "ALw" 
12eb						CALLMONITOR 
12eb					endif 
12eb				call storage_write_block	 ; save update 
12eb			  
12eb			 
12eb			 
12eb			 
12eb					ld hl, scratch 
12eb					call config_fdir 
12eb			 
12eb			 
12eb				endif 
12eb c9				ret 
12ec			 
12ec			 
12ec			 
12ec			; Select storage bank 
12ec			 
12ec			.selbank: 
12ec			 
12ec				if STORAGE_SE 
12ec				endif 
12ec				 
12ec c9				ret 
12ed			 
12ed			if STORAGE_SE 
12ed			 
12ed			.config_ldir:   
12ed				; Load storage bank labels into menu array 
12ed			 
12ed				 
12ed			 
12ed			 
12ed				ret 
12ed			 
12ed			 
12ed			endif 
12ed			 
12ed			 
12ed			; Save user words to storage 
12ed			 
12ed			.savetostore: 
12ed			 
12ed				if STORAGE_SE 
12ed			 
12ed					call config_dir 
12ed				        ld hl, scratch 
12ed					ld a, 0 
12ed					call menu 
12ed					 
12ed					ld hl, scratch 
12ed					call config_fdir 
12ed			 
12ed			 
12ed				endif 
12ed			 
12ed c9				ret 
12ee			 
12ee			 
12ee			 
12ee			if STORAGE_SE 
12ee			 
12ee			config_fdir: 
12ee				; using the scratch dir go through and release the memory allocated for each string 
12ee				 
12ee				ld hl, scratch 
12ee			.cfdir:	ld e,(hl) 
12ee				inc hl 
12ee				ld d,(hl) 
12ee				inc hl 
12ee			 
12ee				ex de, hl 
12ee				call ishlzero 
12ee				ret z     ; return on null pointer 
12ee				call free 
12ee				ex de, hl 
12ee				jr .cfdir 
12ee			 
12ee			 
12ee				ret 
12ee			 
12ee			 
12ee			config_dir: 
12ee			 
12ee				; for the config menus that need to build a directory of storage call this routine 
12ee				; it will construct a menu in scratch to pass to menu 
12ee			 
12ee				; open storage device 
12ee			 
12ee				; execute DIR to build a list of files and their ids into scratch in menu format 
12ee				; once the menu has finished then will need to call config_fdir to release the strings 
12ee				 
12ee				; c = number items 
12ee			 
12ee				 
12ee				call storage_get_block_0 
12ee			 
12ee				ld hl, store_page     ; get current id count 
12ee				ld b, (hl) 
12ee				ld c, 0    ; count of files   
12ee			 
12ee			 
12ee				ld hl, scratch 
12ee				ld (store_tmp2), hl    ; location to poke strings 
12ee			 
12ee				; check for empty drive 
12ee			 
12ee				ld a, 0 
12ee				cp b 
12ee				jp z, .dirdone 
12ee			 
12ee				 
12ee					if DEBUG_FORTH_WORDS 
12ee						DMARK "Cdc" 
12ee						CALLMONITOR 
12ee					endif 
12ee			 
12ee			 
12ee			.diritem:	 
12ee				push bc 
12ee				; for each of the current ids do a search for them and if found push to stack 
12ee			 
12ee					ld hl, STORE_BLOCK_PHY 
12ee					ld d, 0		 ; look for extent 0 of block id as this contains file name 
12ee					ld e,b 
12ee			 
12ee					call storage_findnextid 
12ee			 
12ee			 
12ee					; if found hl will be non zero 
12ee			 
12ee					call ishlzero 
12ee					jr z, .dirnotfound 
12ee			 
12ee					; increase count 
12ee			 
12ee					pop bc	 
12ee					inc c 
12ee					push bc 
12ee					 
12ee			 
12ee					; get file header and push the file name 
12ee			 
12ee					ld de, store_page 
12ee					call storage_read_block 
12ee			 
12ee					; push file id to stack 
12ee				 
12ee					ld a, (store_page) 
12ee					ld h, 0 
12ee					ld l, a 
12ee			 
12ee					;call forth_push_numhl 
12ee					; TODO store id 
12ee			 
12ee					push hl 
12ee			 
12ee					; push extent count to stack  
12ee				 
12ee					ld hl, store_page+3 
12ee			 
12ee					; get file name length 
12ee			 
12ee					call strlenz   
12ee			 
12ee					inc hl   ; cover zero term 
12ee					inc hl  ; stick the id at the end of the area 
12ee			 
12ee					push hl 
12ee					pop bc    ; move length to bc 
12ee			 
12ee					call malloc 
12ee			 
12ee					; TODO save malloc area to scratch 
12ee			 
12ee					ex de, hl 
12ee					ld hl, (store_tmp2) 
12ee					ld (hl), e 
12ee					inc hl 
12ee					ld (hl), d 
12ee					inc hl 
12ee					ld (store_tmp2), hl 
12ee			 
12ee					 
12ee			 
12ee					;pop hl   ; get source 
12ee			;		ex de, hl    ; swap aronund	 
12ee			 
12ee					ld hl, store_page+3 
12ee					if DEBUG_FORTH_WORDS 
12ee						DMARK "CFd" 
12ee						CALLMONITOR 
12ee					endif 
12ee					ldir 
12ee			 
12ee					; de is past string, move back one and store id 
12ee					 
12ee					dec de 
12ee			 
12ee					; store file id 
12ee			 
12ee					pop hl 
12ee					ex de,hl 
12ee					ld (hl), e 
12ee			 
12ee					if DEBUG_FORTH_WORDS 
12ee						DMARK "Cdi" 
12ee						CALLMONITOR 
12ee					endif 
12ee					 
12ee			.dirnotfound: 
12ee					pop bc     
12ee					djnz .diritem 
12ee				 
12ee			.dirdone:	 
12ee			 
12ee					ld a, 0 
12ee					ld hl, (store_tmp2) 
12ee					ld (hl), a 
12ee					inc hl 
12ee					ld (hl), a 
12ee					inc hl 
12ee					; push a count of the dir items found 
12ee			 
12ee			;		ld h, 0 
12ee			;		ld l, c 
12ee			 
12ee				ret 
12ee			 
12ee			endif 
12ee			 
12ee			 
12ee			; Settings 
12ee			; Run  
12ee			 
12ee			 
12ee			 
12ee			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
12ee			;;hd_menu2:   db "        2: Editor",0   
12ee			;hd_menu2:   db "        2: Editor       6: Menu",0   
12ee			;hd_menu3:   db "        3: Storage",0 
12ee			;hd_menu4:   db "0=quit  4: Debug",0 
12ee			;hd_don:     db "ON",0 
12ee			;hd_doff:     db "OFF",0 
12ee			; 
12ee			; 
12ee			; 
12ee			;hardware_diags_old:       
12ee			; 
12ee			;.diagmenu: 
12ee			;	call clear_display 
12ee			;	ld a, display_row_1 
12ee			;	ld de, hd_menu1 
12ee			;	call str_at_display 
12ee			; 
12ee			;	ld a, display_row_2 
12ee			;	ld de, hd_menu2 
12ee			;	call str_at_display 
12ee			; 
12ee			;	ld a, display_row_3 
12ee			;	ld de, hd_menu3 
12ee			;	call str_at_display 
12ee			; 
12ee			;	ld a,  display_row_4 
12ee			;	ld de, hd_menu4 
12ee			;	call str_at_display 
12ee			; 
12ee			;	; display debug state 
12ee			; 
12ee			;	ld de, hd_don 
12ee			;	ld a, (os_view_disable) 
12ee			;	cp 0 
12ee			;	jr z, .distog 
12ee			;	ld de, hd_doff 
12ee			;.distog: ld a, display_row_4+17 
12ee			;	call str_at_display 
12ee			; 
12ee			;	call update_display 
12ee			; 
12ee			;	call cin_wait 
12ee			; 
12ee			; 
12ee			; 
12ee			;	cp '4' 
12ee			;	jr nz, .diagn1 
12ee			; 
12ee			;	; debug toggle 
12ee			; 
12ee			;	ld a, (os_view_disable) 
12ee			;	ld b, '*' 
12ee			;	cp 0 
12ee			;	jr z, .debtog 
12ee			;	ld b, 0 
12ee			;.debtog:	 
12ee			;	ld a,b 
12ee			;	ld (os_view_disable),a 
12ee			; 
12ee			;.diagn1: cp '0' 
12ee			;	 ret z 
12ee			; 
12ee			;;	cp '1' 
12ee			;;       jp z, matrix	 
12ee			;;   TODO keyboard matrix test 
12ee			; 
12ee			;	cp '2' 
12ee			;	jp z, .diagedit 
12ee			; 
12ee			;;	cp '6' 
12ee			;;	jp z, .menutest 
12ee			;;if ENABLE_BASIC 
12ee			;;	cp '6' 
12ee			;;	jp z, basic 
12ee			;;endif 
12ee			 ; 
12ee			;	jp .diagmenu 
12ee			; 
12ee			; 
12ee			;	ret 
12ee			 
12ee			 
12ee			.debug_tog: 
12ee 21 35 13			ld hl, .menudebug 
12f1				 
12f1 3a 51 e3			ld a, (os_view_disable) 
12f4 fe 2a			cp '*' 
12f6 20 04			jr nz,.tdon  
12f8 3e 01			ld a, 1 
12fa 18 02			jr .tog1 
12fc 3e 00		.tdon: ld a, 0 
12fe			 
12fe			.tog1: 
12fe cd b6 09			call menu 
1301 fe 00			cp 0 
1303 c8				ret z 
1304 fe 01			cp 1    ; disable debug 
1306 28 04			jr z, .dtog0 
1308 3e 2a			ld a, '*' 
130a 18 02			jr .dtogset 
130c 3e 00		.dtog0: ld a, 0 
130e 32 51 e3		.dtogset:  ld (os_view_disable), a 
1311 c3 ee 12			jp .debug_tog 
1314			 
1314			 
1314			hardware_diags:       
1314			 
1314			.diagm: 
1314 21 27 13			ld hl, .menuitems 
1317 3e 00			ld a, 0 
1319 cd b6 09			call menu 
131c			 
131c fe 00		         cp 0 
131e c8				 ret z 
131f			 
131f fe 02			cp 2 
1321 ca 80 13			jp z, .diagedit 
1324			 
1324			;	cp '6' 
1324			;	jp z, .menutest 
1324			;if ENABLE_BASIC 
1324			;	cp '6' 
1324			;	jp z, basic 
1324			;endif 
1324			  
1324 c3 14 13			jp .diagm 
1327			 
1327				 
1327 3b 13		.menuitems:   	dw .m1 
1329 46 13				dw .m2 
132b 4d 13				dw .m3 
132d 55 13				dw .m5 
132f 5b 13				dw .m5a 
1331 64 13				dw .m5b 
1333 00 00				dw 0 
1335			 
1335			.menudebug: 
1335 6d 13				dw .m6 
1337 76 13				dw .m7 
1339 00 00				dw 0 
133b			 
133b .. 00		.m1:   db "Key Matrix",0 
1346 .. 00		.m2:   db "Editor",0 
134d .. 00		.m3:   db "Storage",0 
1355 .. 00		.m5:   db "Sound",0 
135b .. 00		.m5a:  db "RAM Test",0 
1364 .. 00		.m5b:  db "LCD Test",0 
136d			 
136d .. 00		.m6:   db "Debug ON",0 
1376 .. 00		.m7:   db "Debug OFF",0 
1380			 
1380			; debug editor 
1380			 
1380			.diagedit: 
1380			 
1380 21 60 e3			ld hl, scratch 
1383			;	ld bc, 250 
1383			;	ldir 
1383				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1383 3e 00			ld a, 0 
1385 77				ld (hl), a 
1386 23				inc hl 
1387 77				ld (hl), a 
1388 23				inc hl 
1389 77				ld (hl), a 
138a			 
138a cd 85 09		        call clear_display 
138d cd a8 09			call update_display 
1390 3e 01			ld a, 1 
1392 32 80 ee			ld (hardware_diag), a 
1395			.diloop: 
1395 3e 00			ld a, display_row_1 
1397 0e 00			ld c, 0 
1399 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
139b 1e 28			ld e, 40 
139d			 
139d 21 60 e3			ld hl, scratch	 
13a0 cd df 0b			call input_str 
13a3			 
13a3 3e 28			ld a, display_row_2 
13a5 11 60 e3			ld de, scratch 
13a8 cd 98 09			call str_at_display 
13ab cd a8 09			call update_display 
13ae			 
13ae c3 95 13			jp .diloop 
13b1			 
13b1			 
13b1			; pass word in hl 
13b1			; a has display location 
13b1			display_word_at: 
13b1 f5				push af 
13b2 e5				push hl 
13b3 7c				ld a,h 
13b4 21 65 e6			ld hl, os_word_scratch 
13b7 cd b3 0e			call hexout 
13ba e1				pop hl 
13bb 7d				ld a,l 
13bc 21 67 e6			ld hl, os_word_scratch+2 
13bf cd b3 0e			call hexout 
13c2 21 69 e6			ld hl, os_word_scratch+4 
13c5 3e 00			ld a,0 
13c7 77				ld (hl),a 
13c8 11 65 e6			ld de,os_word_scratch 
13cb f1				pop af 
13cc cd 98 09				call str_at_display 
13cf c9				ret 
13d0			 
13d0			display_ptr_state: 
13d0			 
13d0				; to restore afterwards 
13d0			 
13d0 d5				push de 
13d1 c5				push bc 
13d2 e5				push hl 
13d3 f5				push af 
13d4			 
13d4				; for use in here 
13d4			 
13d4			;	push bc 
13d4			;	push de 
13d4			;	push hl 
13d4			;	push af 
13d4			 
13d4 cd 85 09			call clear_display 
13d7			 
13d7 11 aa 15			ld de, .ptrstate 
13da 3e 00			ld a, display_row_1 
13dc cd 98 09			call str_at_display 
13df			 
13df				; display debug step 
13df			 
13df			 
13df 11 7a ee			ld de, debug_mark 
13e2 3e 26			ld a, display_row_1+display_cols-2 
13e4 cd 98 09			call str_at_display 
13e7			 
13e7				; display a 
13e7 11 b4 15			ld de, .ptrcliptr 
13ea 3e 28			ld a, display_row_2 
13ec cd 98 09			call str_at_display 
13ef			 
13ef f1				pop af 
13f0 2a 2b eb			ld hl,(cli_ptr) 
13f3 3e 30			ld a, display_row_2+8 
13f5 cd b1 13			call display_word_at 
13f8			 
13f8			 
13f8				; display hl 
13f8			 
13f8			 
13f8 11 bc 15			ld de, .ptrclioptr 
13fb 3e 32			ld a, display_row_2+10 
13fd cd 98 09			call str_at_display 
1400			; 
1400			;	pop hl 
1400 3e 35			ld a, display_row_2+13 
1402 2a 29 eb			ld hl,(cli_origptr) 
1405 cd b1 13			call display_word_at 
1408			; 
1408			;	 
1408			;	; display de 
1408			 
1408			;	ld de, .regstatede 
1408			;	ld a, display_row_3 
1408			;	call str_at_display 
1408			 
1408			;	pop de 
1408			;	ld h,d 
1408			;	ld l, e 
1408			;	ld a, display_row_3+3 
1408			;	call display_word_at 
1408			 
1408			 
1408				; display bc 
1408			 
1408			;	ld de, .regstatebc 
1408			;	ld a, display_row_3+10 
1408			;	call str_at_display 
1408			 
1408			;	pop bc 
1408			;	ld h,b 
1408			;	ld l, c 
1408			;	ld a, display_row_3+13 
1408			;	call display_word_at 
1408			 
1408			 
1408				; display dsp 
1408			 
1408			;	ld de, .regstatedsp 
1408			;	ld a, display_row_4 
1408			;	call str_at_display 
1408			 
1408				 
1408			;	ld hl,(cli_data_sp) 
1408			;	ld a, display_row_4+4 
1408			;	call display_word_at 
1408			 
1408				; display rsp 
1408			 
1408 11 eb 15			ld de, .regstatersp 
140b 3e 82			ld a, display_row_4+10 
140d cd 98 09			call str_at_display 
1410			 
1410				 
1410 2a 11 eb			ld hl,(cli_ret_sp) 
1413 3e 86			ld a, display_row_4+14 
1415 cd b1 13			call display_word_at 
1418			 
1418 cd a8 09			call update_display 
141b			 
141b cd fa 08			call delay1s 
141e cd fa 08			call delay1s 
1421 cd fa 08			call delay1s 
1424			 
1424			 
1424 cd 31 19			call next_page_prompt 
1427			 
1427				; restore  
1427			 
1427 f1				pop af 
1428 e1				pop hl 
1429 c1				pop bc 
142a d1				pop de 
142b c9				ret 
142c			 
142c			break_point_state: 
142c f5				push af 
142d			 
142d				; see if disabled 
142d			 
142d 3a 51 e3			ld a, (os_view_disable) 
1430 fe 2a			cp '*' 
1432 20 02			jr nz, .bpsgo 
1434 f1				pop af 
1435 c9				ret 
1436			 
1436			.bpsgo: 
1436 f1				pop af 
1437 f5				push af 
1438 22 4d e3			ld (os_view_hl), hl 
143b ed 53 4b e3		ld (os_view_de), de 
143f ed 43 49 e3		ld (os_view_bc), bc 
1443 e5				push hl 
1444 6f				ld l, a 
1445 26 00			ld h, 0 
1447 22 4f e3			ld (os_view_af),hl 
144a			 
144a 21 c0 ed				ld hl, display_fb0 
144d 22 db eb				ld (display_fb_active), hl 
1450 e1				pop hl	 
1451			 
1451 3e 31			ld a, '1' 
1453 fe 2a		.bps1:  cp '*' 
1455 20 03			jr nz, .bps1b 
1457 32 51 e3			ld (os_view_disable),a 
145a fe 31		.bps1b:  cp '1' 
145c 20 14			jr nz, .bps2 
145e			 
145e				; display reg 
145e			 
145e				 
145e			 
145e 3a 4f e3			ld a, (os_view_af) 
1461 2a 4d e3			ld hl, (os_view_hl) 
1464 ed 5b 4b e3		ld de, (os_view_de) 
1468 ed 4b 49 e3		ld bc, (os_view_bc) 
146c cd 06 15			call display_reg_state 
146f c3 f2 14			jp .bpschk 
1472			 
1472 fe 32		.bps2:  cp '2' 
1474 20 08			jr nz, .bps3 
1476				 
1476				; display hl 
1476 2a 4d e3			ld hl, (os_view_hl) 
1479 cd f0 15			call display_dump_at_hl 
147c			 
147c 18 74			jr .bpschk 
147e			 
147e fe 33		.bps3:  cp '3' 
1480 20 08			jr nz, .bps4 
1482			 
1482			        ; display de 
1482 2a 4b e3			ld hl, (os_view_de) 
1485 cd f0 15			call display_dump_at_hl 
1488			 
1488 18 68			jr .bpschk 
148a fe 34		.bps4:  cp '4' 
148c 20 08			jr nz, .bps5 
148e			 
148e			        ; display bc 
148e 2a 49 e3			ld hl, (os_view_bc) 
1491 cd f0 15			call display_dump_at_hl 
1494			 
1494 18 5c			jr .bpschk 
1496 fe 35		.bps5:  cp '5' 
1498 20 08		        jr nz, .bps7 
149a			 
149a				; display cur ptr 
149a 2a 2b eb			ld hl, (cli_ptr) 
149d cd f0 15			call display_dump_at_hl 
14a0			 
14a0 18 50			jr .bpschk 
14a2 fe 36		.bps7:  cp '6' 
14a4 20 08			jr nz, .bps8b 
14a6				 
14a6				; display cur orig ptr 
14a6 2a 29 eb			ld hl, (cli_origptr) 
14a9 cd f0 15			call display_dump_at_hl 
14ac 18 44			jr .bpschk 
14ae fe 37		.bps8b:  cp '7' 
14b0 20 08			jr nz, .bps9 
14b2				 
14b2				; display dsp 
14b2 2a 0d eb			ld hl, (cli_data_sp) 
14b5 cd f0 15			call display_dump_at_hl 
14b8			 
14b8 18 38			jr .bpschk 
14ba fe 39		.bps9:  cp '9' 
14bc 20 05			jr nz, .bps8c 
14be				 
14be				; display SP 
14be			;	ld hl, sp 
14be cd f0 15			call display_dump_at_hl 
14c1			 
14c1 18 2f			jr .bpschk 
14c3 fe 38		.bps8c:  cp '8' 
14c5 20 08			jr nz, .bps8d 
14c7				 
14c7				; display rsp 
14c7 2a 11 eb			ld hl, (cli_ret_sp) 
14ca cd f0 15			call display_dump_at_hl 
14cd			 
14cd 18 23			jr .bpschk 
14cf fe 23		.bps8d:  cp '#'     ; access monitor sub system 
14d1 20 05			jr nz, .bps8 
14d3 cd 27 17			call monitor 
14d6			 
14d6 18 1a			jr .bpschk 
14d8 fe 30		.bps8:  cp '0' 
14da 20 16			jr nz, .bpschk 
14dc			 
14dc 21 1f ed				ld hl, display_fb1 
14df 22 db eb				ld (display_fb_active), hl 
14e2 cd a8 09				call update_display 
14e5			 
14e5				;ld a, (os_view_af) 
14e5 2a 4d e3			ld hl, (os_view_hl) 
14e8 ed 5b 4b e3		ld de, (os_view_de) 
14ec ed 4b 49 e3		ld bc, (os_view_bc) 
14f0 f1				pop af 
14f1 c9				ret 
14f2			 
14f2			.bpschk:   
14f2 cd fa 08			call delay1s 
14f5 3e 9f		ld a,display_row_4 + display_cols - 1 
14f7 11 2f 19		        ld de, endprg 
14fa cd 98 09			call str_at_display 
14fd cd a8 09			call update_display 
1500 cd 75 58			call cin_wait 
1503			 
1503 c3 53 14			jp .bps1 
1506			 
1506			 
1506			display_reg_state: 
1506			 
1506				; to restore afterwards 
1506			 
1506 d5				push de 
1507 c5				push bc 
1508 e5				push hl 
1509 f5				push af 
150a			 
150a				; for use in here 
150a			 
150a c5				push bc 
150b d5				push de 
150c e5				push hl 
150d f5				push af 
150e			 
150e cd 85 09			call clear_display 
1511			 
1511 11 c6 15			ld de, .regstate 
1514 3e 00			ld a, display_row_1 
1516 cd 98 09			call str_at_display 
1519			 
1519				; display debug step 
1519			 
1519			 
1519 11 7a ee			ld de, debug_mark 
151c 3e 25			ld a, display_row_1+display_cols-3 
151e cd 98 09			call str_at_display 
1521			 
1521				; display a 
1521 11 e2 15			ld de, .regstatea 
1524 3e 28			ld a, display_row_2 
1526 cd 98 09			call str_at_display 
1529			 
1529 e1				pop hl 
152a			;	ld h,0 
152a			;	ld l, a 
152a 3e 2b			ld a, display_row_2+3 
152c cd b1 13			call display_word_at 
152f			 
152f			 
152f				; display hl 
152f			 
152f			 
152f 11 d6 15			ld de, .regstatehl 
1532 3e 32			ld a, display_row_2+10 
1534 cd 98 09			call str_at_display 
1537			 
1537 e1				pop hl 
1538 3e 35			ld a, display_row_2+13 
153a cd b1 13			call display_word_at 
153d			 
153d				 
153d				; display de 
153d			 
153d 11 da 15			ld de, .regstatede 
1540 3e 50			ld a, display_row_3 
1542 cd 98 09			call str_at_display 
1545			 
1545 e1				pop hl 
1546			;	ld h,d 
1546			;	ld l, e 
1546 3e 53			ld a, display_row_3+3 
1548 cd b1 13			call display_word_at 
154b			 
154b			 
154b				; display bc 
154b			 
154b 11 de 15			ld de, .regstatebc 
154e 3e 5a			ld a, display_row_3+10 
1550 cd 98 09			call str_at_display 
1553			 
1553 e1				pop hl 
1554			;	ld h,b 
1554			;	ld l, c 
1554 3e 5d			ld a, display_row_3+13 
1556 cd b1 13			call display_word_at 
1559			 
1559			 
1559				; display dsp 
1559			 
1559 11 e6 15			ld de, .regstatedsp 
155c 3e 78			ld a, display_row_4 
155e cd 98 09			call str_at_display 
1561			 
1561				 
1561 2a 0d eb			ld hl,(cli_data_sp) 
1564 3e 7c			ld a, display_row_4+4 
1566 cd b1 13			call display_word_at 
1569			 
1569				; display rsp 
1569			 
1569 11 eb 15			ld de, .regstatersp 
156c 3e 82			ld a, display_row_4+10 
156e cd 98 09			call str_at_display 
1571			 
1571				 
1571 2a 11 eb			ld hl,(cli_ret_sp) 
1574 3e 86			ld a, display_row_4+14 
1576 cd b1 13			call display_word_at 
1579			 
1579 cd a8 09			call update_display 
157c			 
157c			;	call delay1s 
157c			;	call delay1s 
157c			;	call delay1s 
157c			 
157c			 
157c			;	call next_page_prompt 
157c			 
157c				; restore  
157c			 
157c f1				pop af 
157d e1				pop hl 
157e c1				pop bc 
157f d1				pop de 
1580 c9				ret 
1581			 
1581 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1595 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
15aa .. 00		.ptrstate:	db "Ptr State",0 
15b4 .. 00		.ptrcliptr:     db "cli_ptr",0 
15bc .. 00		.ptrclioptr:     db "cli_o_ptr",0 
15c6 .. 00		.regstate:	db "Reg State (1/0)",0 
15d6 .. 00		.regstatehl:	db "HL:",0 
15da .. 00		.regstatede:	db "DE:",0 
15de .. 00		.regstatebc:	db "BC:",0 
15e2 .. 00		.regstatea:	db "A :",0 
15e6 .. 00		.regstatedsp:	db "DSP:",0 
15eb .. 00		.regstatersp:	db "RSP:",0 
15f0			 
15f0			display_dump_at_hl: 
15f0 e5				push hl 
15f1 d5				push de 
15f2 c5				push bc 
15f3 f5				push af 
15f4			 
15f4 22 83 e6			ld (os_cur_ptr),hl	 
15f7 cd 85 09			call clear_display 
15fa cd 39 18			call dumpcont 
15fd			;	call delay1s 
15fd			;	call next_page_prompt 
15fd			 
15fd			 
15fd f1				pop af 
15fe c1				pop bc 
15ff d1				pop de 
1600 e1				pop hl 
1601 c9				ret 
1602			 
1602			;if ENABLE_BASIC 
1602			;	include "nascombasic.asm" 
1602			;	basic: 
1602			;	include "forth/FORTH.ASM" 
1602			;endif 
1602			 
1602			; eof 
1602			 
1602			 
# End of file firmware_diags.asm
1602			  
1602			  
1602			  
1602			  
1602			; eof  
1602			  
# End of file firmware.asm
1602			 
1602			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1602			;if BASE_KEV  
1602			;baseram: equ 08000h 
1602			;endif 
1602			 
1602			;if BASE_SC114 
1602			;baseram:     equ    endofcode 
1602			;endif 
1602			 
1602			 
1602			; start system 
1602			 
1602			coldstart: 
1602				; set sp 
1602				; di/ei 
1602			 
1602 f3				di 
1603 31 00 f0			ld sp, tos 
1606			;	ei 
1606			 
1606			 
1606				; disable breakpoint by default 
1606			 
1606 3e 2a			ld a,'*' 
1608 32 51 e3			ld (os_view_disable),a 
160b			 
160b				; init hardware 
160b			 
160b				; init keyboard and screen hardware 
160b			 
160b cd 03 01			call hardware_init 
160e			 
160e			 
160e				; detect if any keys are held down to enable breakpoints at start up 
160e			 
160e cd 7d 58			call cin  
1611 fe 00			cp 0 
1613 28 03			jr z, .nokeys 
1615			 
1615				;call hardware_diags 
1615 cd 12 12			call config 
1618			 
1618			;	ld de, .bpen 
1618			;	ld a, display_row_4 
1618			;	call str_at_display 
1618			;	call update_display 
1618			; 
1618			;	ld a,0 
1618			;	ld (os_view_disable),a 
1618			; 
1618			;.bpwait: 
1618			;	call cin 
1618			;	cp 0 
1618			;	jr z, .bpwait 
1618			;	jr .nokeys 
1618			; 
1618			; 
1618			;.bpen:  db "Break points enabled!",0 
1618			 
1618			 
1618			 
1618			 
1618			 
1618			 
1618			.nokeys: 
1618			 
1618			 
1618				 
1618			 
1618			;jp  testkey 
1618			 
1618			;call storage_get_block_0 
1618			; 
1618			;ld hl, 0 
1618			;ld de, store_page 
1618			;call storage_read_block 
1618			 
1618				 
1618			;ld hl, 10 
1618			;ld de, store_page 
1618			;call storage_read_block 
1618			 
1618			 
1618			 
1618			 
1618			 
1618			;stop:	nop 
1618			;	jp stop 
1618			 
1618			 
1618			 
1618			main: 
1618 cd 85 09			call clear_display 
161b cd a8 09			call update_display 
161e			 
161e			 
161e			 
161e			;	call testlcd 
161e			 
161e			 
161e			 
161e cd f7 1c			call forth_init 
1621			 
1621			 
1621			warmstart: 
1621 cd cd 1c			call forth_warmstart 
1624			 
1624				; run startup word load 
1624			        ; TODO prevent this running at warmstart after crash  
1624			 
1624				if STARTUP_ENABLE 
1624					if STORAGE_SE 
1624						call forth_autoload 
1624					endif 
1624 cd c3 54				call forth_startup 
1627			 
1627			 
1627				endif 
1627			 
1627				; show free memory after boot 
1627 11 c1 16			ld de, freeram 
162a 3e 00			ld a, display_row_1 
162c cd 98 09			call str_at_display 
162f			 
162f			; Or use heap_size word???? 
162f 21 46 e3			ld hl, heap_end 
1632 11 a5 58			ld de, heap_start 
1635 ed 52			sbc hl, de 
1637 e5				push hl 
1638 7c				ld a,h	         	 
1639 21 65 e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
163c cd b3 0e			call hexout 
163f e1			   	pop hl 
1640			 
1640 7d				ld a,l 
1641 21 67 e6			ld hl, os_word_scratch+2 
1644 cd b3 0e			call hexout 
1647 21 69 e6			ld hl, os_word_scratch+4 
164a 3e 00			ld a, 0 
164c 77				ld (hl),a 
164d 11 65 e6			ld de, os_word_scratch 
1650 3e 0d			ld a, display_row_1 + 13 
1652 cd 98 09			call str_at_display 
1655 cd a8 09			call update_display 
1658			 
1658			 
1658				;call demo 
1658			 
1658			 
1658				; init scratch input area for cli commands 
1658			 
1658 21 87 e6			ld hl, os_cli_cmd 
165b 3e 00			ld a,0 
165d 77				ld (hl),a 
165e 23				inc hl 
165f 77				ld (hl),a 
1660			 
1660 3e 00			ld a,0 
1662 32 86 e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1665			 
1665 32 83 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1668 32 84 e6			ld (os_cur_ptr+1),a	 
166b			 
166b 32 65 e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
166e 32 66 e6			ld (os_word_scratch+1),a	 
1671				 
1671			 
1671				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1671 21 87 e6			ld hl, os_cli_cmd 
1674			 
1674 3e 00			ld a, 0		 ; init cli input 
1676 77				ld (hl), a 
1677 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1679			cli: 
1679				; show cli prompt 
1679				;push af 
1679				;ld a, 0 
1679				;ld de, prompt 
1679				;call str_at_display 
1679			 
1679				;call update_display 
1679				;pop af 
1679				;inc a 
1679				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1679 0e 00			ld c, 0 
167b 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
167d 1e 28			ld e, 40 
167f			 
167f 21 87 e6			ld hl, os_cli_cmd 
1682			 
1682				STACKFRAME OFF $fefe $9f9f 
1682				if DEBUG_STACK_IMB 
1682					if OFF 
1682						exx 
1682						ld de, $fefe 
1682						ld a, d 
1682						ld hl, curframe 
1682						call hexout 
1682						ld a, e 
1682						ld hl, curframe+2 
1682						call hexout 
1682						ld hl, $fefe 
1682						push hl 
1682						ld hl, $9f9f 
1682						push hl 
1682						exx 
1682					endif 
1682				endif 
1682			endm 
# End of macro STACKFRAME
1682			 
1682 cd df 0b			call input_str 
1685			 
1685				STACKFRAMECHK OFF $fefe $9f9f 
1685				if DEBUG_STACK_IMB 
1685					if OFF 
1685						exx 
1685						ld hl, $9f9f 
1685						pop de   ; $9f9f 
1685						call cmp16 
1685						jr nz, .spnosame 
1685						ld hl, $fefe 
1685						pop de   ; $fefe 
1685						call cmp16 
1685						jr z, .spfrsame 
1685						.spnosame: call showsperror 
1685						.spfrsame: nop 
1685						exx 
1685					endif 
1685				endif 
1685			endm 
# End of macro STACKFRAMECHK
1685			 
1685				; copy input to last command 
1685			 
1685 21 87 e6			ld hl, os_cli_cmd 
1688 11 86 e7			ld de, os_last_cmd 
168b 01 ff 00			ld bc, 255 
168e ed b0			ldir 
1690			 
1690				; wipe current buffer 
1690			 
1690			;	ld a, 0 
1690			;	ld hl, os_cli_cmd 
1690			;	ld de, os_cli_cmd+1 
1690			;	ld bc, 254 
1690			;	ldir 
1690				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1690			;	call strcpy 
1690			;	ld a, 0 
1690			;	ld (hl), a 
1690			;	inc hl 
1690			;	ld (hl), a 
1690			;	inc hl 
1690			;	ld (hl), a 
1690			 
1690				; switch frame buffer to program  
1690			 
1690 21 1f ed				ld hl, display_fb1 
1693 22 db eb				ld (display_fb_active), hl 
1696			 
1696			;	nop 
1696				STACKFRAME ON $fbfe $8f9f 
1696				if DEBUG_STACK_IMB 
1696					if ON 
1696						exx 
1696						ld de, $fbfe 
1696						ld a, d 
1696						ld hl, curframe 
1696						call hexout 
1696						ld a, e 
1696						ld hl, curframe+2 
1696						call hexout 
1696						ld hl, $fbfe 
1696						push hl 
1696						ld hl, $8f9f 
1696						push hl 
1696						exx 
1696					endif 
1696				endif 
1696			endm 
# End of macro STACKFRAME
1696				; first time into the parser so pass over the current scratch pad 
1696 21 87 e6			ld hl,os_cli_cmd 
1699				; tokenise the entered statement(s) in HL 
1699 cd 70 1d			call forthparse 
169c			        ; exec forth statements in top of return stack 
169c cd b0 1d			call forthexec 
169f				;call forthexec_cleanup 
169f			;	call parsenext 
169f			 
169f				STACKFRAMECHK ON $fbfe $8f9f 
169f				if DEBUG_STACK_IMB 
169f					if ON 
169f						exx 
169f						ld hl, $8f9f 
169f						pop de   ; $8f9f 
169f						call cmp16 
169f						jr nz, .spnosame 
169f						ld hl, $fbfe 
169f						pop de   ; $fbfe 
169f						call cmp16 
169f						jr z, .spfrsame 
169f						.spnosame: call showsperror 
169f						.spfrsame: nop 
169f						exx 
169f					endif 
169f				endif 
169f			endm 
# End of macro STACKFRAMECHK
169f				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
169f			 
169f 3e 78			ld a, display_row_4 
16a1 11 d3 16			ld de, endprog 
16a4			 
16a4 cd a8 09			call update_display		 
16a7			 
16a7 cd 31 19			call next_page_prompt 
16aa			 
16aa				; switch frame buffer to cli 
16aa			 
16aa 21 c0 ed				ld hl, display_fb0 
16ad 22 db eb				ld (display_fb_active), hl 
16b0			 
16b0			 
16b0 cd 85 09		        call clear_display 
16b3 cd a8 09			call update_display		 
16b6			 
16b6 21 87 e6			ld hl, os_cli_cmd 
16b9			 
16b9 3e 00			ld a, 0		 ; init cli input 
16bb 77				ld (hl), a 
16bc			 
16bc				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
16bc			 
16bc				; now on last line 
16bc			 
16bc				; TODO scroll screen up 
16bc			 
16bc				; TODO instead just clear screen and place at top of screen 
16bc			 
16bc			;	ld a, 0 
16bc			;	ld (f_cursor_ptr),a 
16bc			 
16bc				;call clear_display 
16bc				;call update_display 
16bc			 
16bc				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
16bc 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
16be c3 79 16			jp cli 
16c1			 
16c1 .. 00		freeram: db "Free bytes: $",0 
16cf ..			asc: db "1A2F" 
16d3 .. 00		endprog: db "End prog...",0 
16df			 
16df			testenter2:   
16df 21 92 e3			ld hl,scratch+50 
16e2 22 83 e6			ld (os_cur_ptr),hl 
16e5 c3 79 16			jp cli 
16e8			 
16e8			testenter:  
16e8			 
16e8 21 cf 16			ld hl,asc 
16eb			;	ld a,(hl) 
16eb			;	call nibble2val 
16eb cd 09 0f			call get_byte 
16ee			 
16ee			 
16ee			;	ld a,(hl) 
16ee			;	call atohex 
16ee			 
16ee			;	call fourehexhl 
16ee 32 92 e3			ld (scratch+50),a 
16f1			 
16f1			 
16f1			 
16f1 21 d1 16			ld hl,asc+2 
16f4			;	ld a, (hl) 
16f4			;	call nibble2val 
16f4 cd 09 0f			call get_byte 
16f7			 
16f7			;	call fourehexhl 
16f7 32 94 e3			ld (scratch+52),a 
16fa				 
16fa 21 92 e3			ld hl,scratch+50 
16fd 22 83 e6			ld (os_cur_ptr),hl 
1700 c3 79 16			jp cli 
1703			 
1703			enter:	 
1703 3a 64 e3			ld a,(scratch+4) 
1706 fe 00			cp 0 
1708 28 0c			jr z, .entercont 
170a				; no, not a null term line so has an address to work out.... 
170a			 
170a 21 62 e3			ld hl,scratch+2 
170d cd 69 0f			call get_word_hl 
1710			 
1710 22 83 e6			ld (os_cur_ptr),hl	 
1713 c3 79 16			jp cli 
1716			 
1716			 
1716			.entercont:  
1716			 
1716 21 62 e3			ld hl, scratch+2 
1719 cd 09 0f			call get_byte 
171c			 
171c 2a 83 e6		   	ld hl,(os_cur_ptr) 
171f 77					ld (hl),a 
1720 23					inc hl 
1721 22 83 e6				ld (os_cur_ptr),hl 
1724				 
1724			; get byte  
1724			 
1724			 
1724 c3 79 16			jp cli 
1727			 
1727			 
1727			; basic monitor support 
1727			 
1727			monitor: 
1727				;  
1727 cd 85 09			call clear_display 
172a 3e 00			ld a, 0 
172c 11 74 17			ld de, .monprompt 
172f cd 98 09			call str_at_display 
1732 cd a8 09			call update_display 
1735			 
1735				; get a monitor command 
1735			 
1735 0e 00			ld c, 0     ; entry at top left 
1737 16 64			ld d, 100   ; max buffer size 
1739 1e 0f			ld e, 15    ; input scroll area 
173b 3e 00			ld a, 0     ; init string 
173d 21 5e e5			ld hl, os_input 
1740 77				ld (hl), a 
1741 23				inc hl 
1742 77				ld (hl), a 
1743 21 5e e5			ld hl, os_input 
1746 3e 01			ld a, 1     ; init string 
1748 cd df 0b			call input_str 
174b			 
174b cd 85 09		        call clear_display 
174e cd a8 09			call update_display		 
1751			 
1751 3a 5e e5			ld a, (os_input) 
1754 cd 07 10			call toUpper 
1757 fe 48		        cp 'H' 
1759 28 6f		        jr z, .monhelp 
175b fe 44			cp 'D'		; dump 
175d ca eb 17			jp z, .mondump	 
1760 fe 43			cp 'C'		; dump 
1762 ca 05 18			jp z, .moncdump	 
1765 fe 4d			cp 'M'		; dump 
1767 ca 76 17			jp z, .moneditstart 
176a fe 55			cp 'U'		; dump 
176c 28 14			jr z, .monedit	 
176e fe 51			cp 'Q'		; dump 
1770 c8				ret z	 
1771			 
1771			 
1771				; TODO "S" to access symbol by name and not need the address 
1771				; TODO "F" to find a string in memory 
1771			 
1771 c3 27 17			jp monitor 
1774			 
1774 .. 00		.monprompt: db ">", 0 
1776			 
1776			.moneditstart: 
1776				; get starting address 
1776			 
1776 21 60 e5			ld hl,os_input+2 
1779 cd 69 0f			call get_word_hl 
177c			 
177c 22 83 e6			ld (os_cur_ptr),hl	 
177f			 
177f c3 27 17			jp monitor 
1782			 
1782			.monedit: 
1782				; get byte to load 
1782			 
1782 21 60 e5			ld hl,os_input+2 
1785 cd 09 0f			call get_byte 
1788			 
1788				; get address to update 
1788 2a 83 e6			ld hl, (os_cur_ptr) 
178b			 
178b				; update byte 
178b			 
178b 77				ld (hl), a 
178c			 
178c				; move to next address and save it 
178c			 
178c 23				inc hl 
178d 22 83 e6			ld (os_cur_ptr),hl	 
1790			 
1790 c3 27 17			jp monitor 
1793			 
1793			 
1793 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
17a7 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
17c3 .. 00		.monhelptext3:  db "Q-Quit",0 
17ca			        
17ca			.monhelp: 
17ca 3e 00			ld a, display_row_1 
17cc 11 93 17		        ld de, .monhelptext1 
17cf			 
17cf cd 98 09			call str_at_display 
17d2 3e 28			ld a, display_row_2 
17d4 11 a7 17		        ld de, .monhelptext2 
17d7					 
17d7 cd 98 09			call str_at_display 
17da 3e 50			ld a, display_row_3 
17dc 11 c3 17		        ld de, .monhelptext3 
17df					 
17df cd 98 09			call str_at_display 
17e2 cd a8 09			call update_display		 
17e5			 
17e5 cd 31 19			call next_page_prompt 
17e8 c3 27 17			jp monitor 
17eb			 
17eb			.mondump:    
17eb 21 60 e5			ld hl,os_input+2 
17ee cd 69 0f			call get_word_hl 
17f1			 
17f1 22 83 e6			ld (os_cur_ptr),hl	 
17f4 cd 39 18			call dumpcont 
17f7 3e 78			ld a, display_row_4 
17f9 11 d3 16			ld de, endprog 
17fc			 
17fc cd a8 09			call update_display		 
17ff			 
17ff cd 31 19			call next_page_prompt 
1802 c3 27 17			jp monitor 
1805			.moncdump: 
1805 cd 39 18			call dumpcont 
1808 3e 78			ld a, display_row_4 
180a 11 d3 16			ld de, endprog 
180d			 
180d cd a8 09			call update_display		 
1810			 
1810 cd 31 19			call next_page_prompt 
1813 c3 27 17			jp monitor 
1816			 
1816			 
1816			; TODO symbol access  
1816			 
1816			.symbols:     ;; A list of symbols that can be called up  
1816 c0 ed			dw display_fb0 
1818 .. 00			db "fb0",0  
181c 65 eb		     	dw store_page 
181e .. 00			db "store_page",0 
1829			 
1829			 
1829			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1829			 
1829 3a 61 e3			ld a,(scratch+1) 
182c fe 00			cp 0 
182e 28 09			jr z, dumpcont 
1830			 
1830				; no, not a null term line so has an address to work out.... 
1830			 
1830 21 62 e3			ld hl,scratch+2 
1833 cd 69 0f			call get_word_hl 
1836			 
1836 22 83 e6			ld (os_cur_ptr),hl	 
1839			 
1839			 
1839			 
1839			dumpcont: 
1839			 
1839				; dump bytes at ptr 
1839			 
1839			 
1839 3e 00			ld a, display_row_1 
183b 2a db eb			ld hl, (display_fb_active) 
183e cd b2 0b			call addatohl 
1841 cd 69 18			call .dumpbyterow 
1844			 
1844 3e 28			ld a, display_row_2 
1846 2a db eb			ld hl, (display_fb_active) 
1849 cd b2 0b			call addatohl 
184c cd 69 18			call .dumpbyterow 
184f			 
184f			 
184f 3e 50			ld a, display_row_3 
1851 2a db eb			ld hl, (display_fb_active) 
1854 cd b2 0b			call addatohl 
1857 cd 69 18			call .dumpbyterow 
185a			 
185a 3e 78			ld a, display_row_4 
185c 2a db eb			ld hl, (display_fb_active) 
185f cd b2 0b			call addatohl 
1862 cd 69 18			call .dumpbyterow 
1865			 
1865 cd a8 09			call update_display 
1868			;		jp cli 
1868 c9				ret 
1869			 
1869			.dumpbyterow: 
1869			 
1869				;push af 
1869			 
1869 e5				push hl 
186a			 
186a				; calc where to poke the ascii 
186a			if display_cols == 20 
186a				ld a, 16 
186a			else 
186a 3e 1f			ld a, 31 
186c			endif 
186c			 
186c cd b2 0b			call addatohl 
186f 22 65 e6			ld (os_word_scratch),hl  		; save pos for later 
1872			 
1872			 
1872			; display decoding address 
1872 2a 83 e6		   	ld hl,(os_cur_ptr) 
1875			 
1875 7c				ld a,h 
1876 e1				pop hl 
1877 e5				push hl 
1878			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1878 cd b3 0e			call hexout 
187b 2a 83 e6		   	ld hl,(os_cur_ptr) 
187e			 
187e 7d				ld a,l 
187f e1				pop hl 
1880 23				inc hl 
1881 23				inc hl 
1882 e5				push hl 
1883			;	ld hl, os_word_scratch+2 
1883 cd b3 0e			call hexout 
1886 e1				pop hl 
1887 23				inc hl 
1888 23				inc hl 
1889				;ld hl, os_word_scratch+4 
1889 3e 3a			ld a, ':' 
188b 77				ld (hl),a 
188c 23				inc hl 
188d				;ld a, 0 
188d				;ld (hl),a 
188d				;ld de, os_word_scratch 
188d				;pop af 
188d				;push af 
188d			;		ld a, display_row_2 
188d			;		call str_at_display 
188d			;		call update_display 
188d			 
188d			 
188d			;pop af 
188d			;	add 5 
188d			 
188d			if display_cols == 20 
188d				ld b, 4 
188d			else 
188d 06 08			ld b, 8 
188f			endif	 
188f			 
188f			.dumpbyte: 
188f c5				push bc 
1890 e5				push hl 
1891			 
1891			 
1891 2a 83 e6		   	ld hl,(os_cur_ptr) 
1894 7e					ld a,(hl) 
1895			 
1895					; poke the ascii to display 
1895 2a 65 e6				ld hl,(os_word_scratch) 
1898 77					ld (hl),a 
1899 23					inc hl 
189a 22 65 e6				ld (os_word_scratch),hl 
189d			 
189d					 
189d			 
189d			 
189d e1					pop hl 
189e e5					push hl 
189f			 
189f cd b3 0e				call hexout 
18a2			 
18a2					 
18a2 2a 83 e6		   	ld hl,(os_cur_ptr) 
18a5 23				inc hl 
18a6 22 83 e6		   	ld (os_cur_ptr),hl 
18a9			 
18a9 e1					pop hl 
18aa 23					inc hl 
18ab 23					inc hl 
18ac 23					inc hl 
18ad			 
18ad			 
18ad			 
18ad					;ld a,0 
18ad					;ld (os_word_scratch+2),a 
18ad					;pop af 
18ad					;push af 
18ad			 
18ad					;ld de, os_word_scratch 
18ad					;call str_at_display 
18ad			;		call update_display 
18ad			;		pop af 
18ad c1					pop bc 
18ae c6 03				add 3 
18b0 10 dd			djnz .dumpbyte 
18b2			 
18b2				 
18b2			 
18b2 c9				ret 
18b3			 
18b3			jump:	 
18b3			 
18b3 21 62 e3			ld hl,scratch+2 
18b6 cd 69 0f			call get_word_hl 
18b9				;ld hl,(scratch+2) 
18b9				;call fourehexhl 
18b9			 
18b9 22 83 e6			ld (os_cur_ptr),hl	 
18bc			 
18bc e9				jp (hl) 
18bd			 
18bd			 
18bd			 
18bd			; TODO implement a basic monitor mode to start with 
18bd			 
18bd			 
18bd			 
18bd			 
18bd			 
18bd			 
18bd			 
18bd			 
18bd			 
18bd			; testing and demo code during development 
18bd			 
18bd			 
18bd .. 00		str1: db "Enter some text...",0 
18d0 .. 00		clear: db "                    ",0 
18e5			 
18e5			demo: 
18e5			 
18e5			 
18e5			 
18e5			;	call update_display 
18e5			 
18e5				; init scratch input area for testing 
18e5 21 60 e3			ld hl, scratch	 
18e8 3e 00			ld a,0 
18ea 77				ld (hl),a 
18eb			 
18eb			 
18eb 3e 28		            LD   A, display_row_2 
18ed			;            CALL fLCD_Pos       ;Position cursor to location in A 
18ed 11 bd 18		            LD   DE, str1 
18f0 cd 98 09			call str_at_display 
18f3			 
18f3			;            CALL fLCD_Str       ;Display string pointed to by DE 
18f3			cloop:	 
18f3 3e 50		            LD   A, display_row_3 
18f5			;            CALL fLCD_Pos       ;Position cursor to location in A 
18f5 11 d0 18		            LD   DE, clear 
18f8			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
18f8 cd 98 09				call str_at_display 
18fb 3e 78			ld a, display_row_4 
18fd 11 2d 19			ld de, prompt 
1900			 
1900 cd 98 09				call str_at_display 
1903 cd a8 09			call update_display 
1906			 
1906 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1908 16 0a			ld d, 10 
190a 21 60 e3			ld hl, scratch	 
190d cd df 0b			call input_str 
1910			 
1910			;	call clear_display 
1910			;'	call update_display 
1910			 
1910 3e 00		            LD   A, display_row_1 
1912			;            CALL fLCD_Pos       ;Position cursor to location in A 
1912 11 d0 18		            LD   DE, clear 
1915 cd 98 09				call str_at_display 
1918			;            CALL fLCD_Str       ;Display string pointed to by DE 
1918 3e 00		            LD   A, display_row_1 
191a			;            CALL fLCD_Pos       ;Position cursor to location in A 
191a 11 60 e3		            LD   DE, scratch 
191d			;            CALL fLCD_Str       ;Display string pointed to by DE 
191d cd 98 09				call str_at_display 
1920 cd a8 09			call update_display 
1923			 
1923 3e 00				ld a,0 
1925 21 60 e3			ld hl, scratch 
1928 77				ld (hl),a 
1929			 
1929 00				nop 
192a c3 f3 18			jp cloop 
192d			 
192d			 
192d			 
192d			; OS Prompt 
192d			 
192d .. 00		prompt: db ">",0 
192f .. 00		endprg: db "?",0 
1931			 
1931			 
1931			; handy next page prompt 
1931			next_page_prompt: 
1931 e5				push hl 
1932 d5				push de 
1933 f5				push af 
1934 c5				push bc 
1935			 
1935 3e 9f			ld a,display_row_4 + display_cols - 1 
1937 11 2f 19		        ld de, endprg 
193a cd 98 09			call str_at_display 
193d cd a8 09			call update_display 
1940 cd 75 58			call cin_wait 
1943 c1				pop bc 
1944 f1				pop af 
1945 d1				pop de 
1946 e1				pop hl 
1947			 
1947			 
1947 c9				ret 
1948			 
1948			 
1948			; forth parser 
1948			 
1948			; My forth kernel 
1948			include "forth_kernel.asm" 
1948			; 
1948			; kernel to the forth OS 
1948			 
1948			DS_TYPE_STR: equ 1     ; string type 
1948			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1948			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1948			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1948			 
1948			FORTH_PARSEV1: equ 0 
1948			FORTH_PARSEV2: equ 0 
1948			FORTH_PARSEV3: equ 0 
1948			FORTH_PARSEV4: equ 0 
1948			FORTH_PARSEV5: equ 1 
1948			 
1948			;if FORTH_PARSEV5 
1948			;	FORTH_END_BUFFER: equ 0 
1948			;else 
1948			FORTH_END_BUFFER: equ 127 
1948			;endif 
1948			 
1948			FORTH_TRUE: equ 1 
1948			FORTH_FALSE: equ 0 
1948			 
1948			if FORTH_PARSEV4 
1948			include "forth_stackops.asm" 
1948			endif 
1948			 
1948			if FORTH_PARSEV5 
1948			include "forth_stackopsv5.asm" 
1948			 
1948			; Stack operations for v5 parser on wards 
1948			; * DATA stack 
1948			; * LOOP stack 
1948			; * RETURN stack 
1948			 
1948			 
1948			 
1948			FORTH_CHK_DSP_UNDER: macro 
1948				push hl 
1948				push de 
1948				ld hl,(cli_data_sp) 
1948				ld de, cli_data_stack 
1948				call cmp16 
1948				jp c, fault_dsp_under 
1948				pop de 
1948				pop hl 
1948				endm 
1948			 
1948			 
1948			FORTH_CHK_RSP_UNDER: macro 
1948				push hl 
1948				push de 
1948				ld hl,(cli_ret_sp) 
1948				ld de, cli_ret_stack 
1948				call cmp16 
1948				jp c, fault_rsp_under 
1948				pop de 
1948				pop hl 
1948				endm 
1948			 
1948			FORTH_CHK_LOOP_UNDER: macro 
1948				push hl 
1948				push de 
1948				ld hl,(cli_loop_sp) 
1948				ld de, cli_loop_stack 
1948				call cmp16 
1948				jp c, fault_loop_under 
1948				pop de 
1948				pop hl 
1948				endm 
1948			 
1948			FORTH_ERR_TOS_NOTSTR: macro 
1948				; TOSO might need more for checks when used 
1948				push af 
1948				ld a,(hl) 
1948				cp DS_TYPE_STR 
1948				jp nz, type_faultn   
1948				pop af 
1948				endm 
1948			 
1948			FORTH_ERR_TOS_NOTNUM: macro 
1948				push af 
1948				ld a,(hl) 
1948				cp DS_TYPE_INUM 
1948				jp nz, type_faultn   
1948				pop af 
1948				endm 
1948			 
1948			 
1948			; increase data stack pointer and save hl to it 
1948				 
1948			FORTH_DSP_NEXT: macro 
1948				call macro_forth_dsp_next 
1948				endm 
1948			 
1948			 
1948			macro_forth_dsp_next: 
1948				if DEBUG_FORTH_STACK_GUARD 
1948 cd 8d 55				call check_stacks 
194b				endif 
194b e5				push hl 
194c d5				push de 
194d eb				ex de,hl 
194e 2a 0d eb			ld hl,(cli_data_sp) 
1951 23				inc hl 
1952 23				inc hl 
1953			 
1953			; PARSEV5 
1953 23				inc hl 
1954 22 0d eb			ld (cli_data_sp),hl 
1957 73				ld (hl), e 
1958 23				inc hl 
1959 72				ld (hl), d 
195a d1				pop de 
195b e1				pop hl 
195c				if DEBUG_FORTH_STACK_GUARD 
195c cd 8d 55				call check_stacks 
195f				endif 
195f c9				ret 
1960			 
1960			 
1960			; increase ret stack pointer and save hl to it 
1960				 
1960			FORTH_RSP_NEXT: macro 
1960				call macro_forth_rsp_next 
1960				endm 
1960			 
1960			macro_forth_rsp_next: 
1960				if DEBUG_FORTH_STACK_GUARD 
1960 cd 8d 55				call check_stacks 
1963				endif 
1963 e5				push hl 
1964 d5				push de 
1965 eb				ex de,hl 
1966 2a 11 eb			ld hl,(cli_ret_sp) 
1969 23				inc hl 
196a 23				inc hl 
196b 22 11 eb			ld (cli_ret_sp),hl 
196e 73				ld (hl), e 
196f 23				inc hl 
1970 72				ld (hl), d 
1971 d1				pop de 
1972 e1				pop hl 
1973				if DEBUG_FORTH_STACK_GUARD 
1973 cd 8d 55				call check_stacks 
1976				endif 
1976 c9				ret 
1977			 
1977			; get current ret stack pointer and save to hl  
1977				 
1977			FORTH_RSP_TOS: macro 
1977				call macro_forth_rsp_tos 
1977				endm 
1977			 
1977			macro_forth_rsp_tos: 
1977				;push de 
1977 2a 11 eb			ld hl,(cli_ret_sp) 
197a cd b2 19			call loadhlptrtohl 
197d				;ld e, (hl) 
197d				;inc hl 
197d				;ld d, (hl) 
197d				;ex de, hl 
197d					if DEBUG_FORTH_WORDS 
197d			;			DMARK "RST" 
197d						CALLMONITOR 
197d cd 2c 14			call break_point_state  
1980				endm  
# End of macro CALLMONITOR
1980					endif 
1980				;pop de 
1980 c9				ret 
1981			 
1981			; pop ret stack pointer 
1981				 
1981			FORTH_RSP_POP: macro 
1981				call macro_forth_rsp_pop 
1981				endm 
1981			 
1981			 
1981			macro_forth_rsp_pop: 
1981				if DEBUG_FORTH_STACK_GUARD 
1981			;		DMARK "RPP" 
1981 cd 8d 55				call check_stacks 
1984					FORTH_CHK_RSP_UNDER 
1984 e5				push hl 
1985 d5				push de 
1986 2a 11 eb			ld hl,(cli_ret_sp) 
1989 11 cb ea			ld de, cli_ret_stack 
198c cd d0 0b			call cmp16 
198f da a1 56			jp c, fault_rsp_under 
1992 d1				pop de 
1993 e1				pop hl 
1994				endm 
# End of macro FORTH_CHK_RSP_UNDER
1994				endif 
1994 e5				push hl 
1995 2a 11 eb			ld hl,(cli_ret_sp) 
1998			 
1998			 
1998				if FORTH_ENABLE_FREE 
1998			 
1998					; get pointer 
1998			 
1998					push de 
1998					push hl 
1998			 
1998					ld e, (hl) 
1998					inc hl 
1998					ld d, (hl) 
1998			 
1998					ex de, hl 
1998					call free 
1998			 
1998					pop hl 
1998					pop de 
1998			 
1998			 
1998				endif 
1998			 
1998			 
1998 2b				dec hl 
1999 2b				dec hl 
199a 22 11 eb			ld (cli_ret_sp), hl 
199d				; do stack underflow checks 
199d e1				pop hl 
199e				if DEBUG_FORTH_STACK_GUARD 
199e cd 8d 55				call check_stacks 
19a1					FORTH_CHK_RSP_UNDER 
19a1 e5				push hl 
19a2 d5				push de 
19a3 2a 11 eb			ld hl,(cli_ret_sp) 
19a6 11 cb ea			ld de, cli_ret_stack 
19a9 cd d0 0b			call cmp16 
19ac da a1 56			jp c, fault_rsp_under 
19af d1				pop de 
19b0 e1				pop hl 
19b1				endm 
# End of macro FORTH_CHK_RSP_UNDER
19b1				endif 
19b1 c9				ret 
19b2			 
19b2			 
19b2			 
19b2			; routine to load word pointed to by hl into hl 
19b2			 
19b2			loadhlptrtohl: 
19b2			 
19b2 d5				push de 
19b3 5e				ld e, (hl) 
19b4 23				inc hl 
19b5 56				ld d, (hl) 
19b6 eb				ex de, hl 
19b7 d1				pop de 
19b8			 
19b8 c9				ret 
19b9			 
19b9			 
19b9			 
19b9			 
19b9			 
19b9			; push a number held in HL onto the data stack 
19b9			; entry point for pushing a value when already in hl used in function above 
19b9			 
19b9			forth_push_numhl: 
19b9			 
19b9 e5				push hl    ; save value to push 
19ba			 
19ba			if DEBUG_FORTH_PUSH 
19ba				; see if disabled 
19ba			 
19ba			 
19ba f5				push af 
19bb 3a 51 e3			ld a, (os_view_disable) 
19be fe 2a			cp '*' 
19c0 28 34			jr z, .pskip2 
19c2 e5				push hl 
19c3 e5			push hl 
19c4 cd 85 09			call clear_display 
19c7 e1			pop hl 
19c8 7c				ld a,h 
19c9 21 65 e6			ld hl, os_word_scratch 
19cc cd b3 0e			call hexout 
19cf e1				pop hl 
19d0 7d				ld a,l 
19d1 21 67 e6			ld hl, os_word_scratch+2 
19d4 cd b3 0e			call hexout 
19d7			 
19d7 21 69 e6			ld hl, os_word_scratch+4 
19da 3e 00			ld a,0 
19dc 77				ld (hl),a 
19dd 11 65 e6			ld de,os_word_scratch 
19e0 3e 28				ld a, display_row_2 
19e2 cd 98 09				call str_at_display 
19e5 11 9b 44			ld de, .push_num 
19e8 3e 00			ld a, display_row_1 
19ea			 
19ea cd 98 09				call str_at_display 
19ed			 
19ed			 
19ed cd a8 09			call update_display 
19f0 cd fa 08			call delay1s 
19f3 cd fa 08			call delay1s 
19f6			.pskip2:  
19f6			 
19f6 f1				pop af 
19f7			endif	 
19f7			 
19f7			 
19f7				FORTH_DSP_NEXT 
19f7 cd 48 19			call macro_forth_dsp_next 
19fa				endm 
# End of macro FORTH_DSP_NEXT
19fa			 
19fa 2a 0d eb			ld hl, (cli_data_sp) 
19fd			 
19fd				; save item type 
19fd 3e 02			ld a,  DS_TYPE_INUM 
19ff 77				ld (hl), a 
1a00 23				inc hl 
1a01			 
1a01				; get word off stack 
1a01 d1				pop de 
1a02 7b				ld a,e 
1a03 77				ld (hl), a 
1a04 23				inc hl 
1a05 7a				ld a,d 
1a06 77				ld (hl), a 
1a07			 
1a07			if DEBUG_FORTH_PUSH 
1a07 2b				dec hl 
1a08 2b				dec hl 
1a09 2b				dec hl 
1a0a						DMARK "PH5" 
1a0a f5				push af  
1a0b 3a 1f 1a			ld a, (.dmark)  
1a0e 32 7a ee			ld (debug_mark),a  
1a11 3a 20 1a			ld a, (.dmark+1)  
1a14 32 7b ee			ld (debug_mark+1),a  
1a17 3a 21 1a			ld a, (.dmark+2)  
1a1a 32 7c ee			ld (debug_mark+2),a  
1a1d 18 03			jr .pastdmark  
1a1f ..			.dmark: db "PH5"  
1a22 f1			.pastdmark: pop af  
1a23			endm  
# End of macro DMARK
1a23				CALLMONITOR 
1a23 cd 2c 14			call break_point_state  
1a26				endm  
# End of macro CALLMONITOR
1a26			endif	 
1a26			 
1a26 c9				ret 
1a27			 
1a27			 
1a27			; Push a string to stack pointed to by hl 
1a27			 
1a27			forth_push_str: 
1a27			 
1a27			if DEBUG_FORTH_PUSH 
1a27						DMARK "PSQ" 
1a27 f5				push af  
1a28 3a 3c 1a			ld a, (.dmark)  
1a2b 32 7a ee			ld (debug_mark),a  
1a2e 3a 3d 1a			ld a, (.dmark+1)  
1a31 32 7b ee			ld (debug_mark+1),a  
1a34 3a 3e 1a			ld a, (.dmark+2)  
1a37 32 7c ee			ld (debug_mark+2),a  
1a3a 18 03			jr .pastdmark  
1a3c ..			.dmark: db "PSQ"  
1a3f f1			.pastdmark: pop af  
1a40			endm  
# End of macro DMARK
1a40				CALLMONITOR 
1a40 cd 2c 14			call break_point_state  
1a43				endm  
# End of macro CALLMONITOR
1a43			endif	 
1a43			    
1a43 e5				push hl 
1a44 e5				push hl 
1a45			 
1a45			;	ld a, 0   ; find end of string 
1a45 cd 10 10			call strlenz 
1a48			if DEBUG_FORTH_PUSH 
1a48						DMARK "PQ2" 
1a48 f5				push af  
1a49 3a 5d 1a			ld a, (.dmark)  
1a4c 32 7a ee			ld (debug_mark),a  
1a4f 3a 5e 1a			ld a, (.dmark+1)  
1a52 32 7b ee			ld (debug_mark+1),a  
1a55 3a 5f 1a			ld a, (.dmark+2)  
1a58 32 7c ee			ld (debug_mark+2),a  
1a5b 18 03			jr .pastdmark  
1a5d ..			.dmark: db "PQ2"  
1a60 f1			.pastdmark: pop af  
1a61			endm  
# End of macro DMARK
1a61				CALLMONITOR 
1a61 cd 2c 14			call break_point_state  
1a64				endm  
# End of macro CALLMONITOR
1a64			endif	 
1a64 eb				ex de, hl 
1a65 e1				pop hl   ; get ptr to start of string 
1a66			if DEBUG_FORTH_PUSH 
1a66						DMARK "PQ3" 
1a66 f5				push af  
1a67 3a 7b 1a			ld a, (.dmark)  
1a6a 32 7a ee			ld (debug_mark),a  
1a6d 3a 7c 1a			ld a, (.dmark+1)  
1a70 32 7b ee			ld (debug_mark+1),a  
1a73 3a 7d 1a			ld a, (.dmark+2)  
1a76 32 7c ee			ld (debug_mark+2),a  
1a79 18 03			jr .pastdmark  
1a7b ..			.dmark: db "PQ3"  
1a7e f1			.pastdmark: pop af  
1a7f			endm  
# End of macro DMARK
1a7f				CALLMONITOR 
1a7f cd 2c 14			call break_point_state  
1a82				endm  
# End of macro CALLMONITOR
1a82			endif	 
1a82 19				add hl,de 
1a83			if DEBUG_FORTH_PUSH 
1a83						DMARK "PQE" 
1a83 f5				push af  
1a84 3a 98 1a			ld a, (.dmark)  
1a87 32 7a ee			ld (debug_mark),a  
1a8a 3a 99 1a			ld a, (.dmark+1)  
1a8d 32 7b ee			ld (debug_mark+1),a  
1a90 3a 9a 1a			ld a, (.dmark+2)  
1a93 32 7c ee			ld (debug_mark+2),a  
1a96 18 03			jr .pastdmark  
1a98 ..			.dmark: db "PQE"  
1a9b f1			.pastdmark: pop af  
1a9c			endm  
# End of macro DMARK
1a9c				CALLMONITOR 
1a9c cd 2c 14			call break_point_state  
1a9f				endm  
# End of macro CALLMONITOR
1a9f			endif	 
1a9f			 
1a9f 2b				dec hl    ; see if there is an optional trailing double quote 
1aa0 7e				ld a,(hl) 
1aa1 fe 22			cp '"' 
1aa3 20 03			jr nz, .strnoq 
1aa5 3e 00			ld a, 0      ; get rid of double quote 
1aa7 77				ld (hl), a 
1aa8 23			.strnoq: inc hl 
1aa9			 
1aa9 3e 00			ld a, 0 
1aab 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1aac			 
1aac 13				inc de ; add one for the type string 
1aad 13				inc de ; add one for null term??? 
1aae			 
1aae				; tos is get string pointer again 
1aae				; de contains space to allocate 
1aae				 
1aae d5				push de 
1aaf			 
1aaf eb				ex de, hl 
1ab0			 
1ab0				;push af 
1ab0			 
1ab0			if DEBUG_FORTH_PUSH 
1ab0						DMARK "PHm" 
1ab0 f5				push af  
1ab1 3a c5 1a			ld a, (.dmark)  
1ab4 32 7a ee			ld (debug_mark),a  
1ab7 3a c6 1a			ld a, (.dmark+1)  
1aba 32 7b ee			ld (debug_mark+1),a  
1abd 3a c7 1a			ld a, (.dmark+2)  
1ac0 32 7c ee			ld (debug_mark+2),a  
1ac3 18 03			jr .pastdmark  
1ac5 ..			.dmark: db "PHm"  
1ac8 f1			.pastdmark: pop af  
1ac9			endm  
# End of macro DMARK
1ac9				CALLMONITOR 
1ac9 cd 2c 14			call break_point_state  
1acc				endm  
# End of macro CALLMONITOR
1acc			endif	 
1acc cd 79 10			call malloc	; on ret hl now contains allocated memory 
1acf				if DEBUG_FORTH_MALLOC_GUARD 
1acf cc f3 44				call z,malloc_error 
1ad2				endif 
1ad2			 
1ad2				 
1ad2 c1				pop bc    ; get length 
1ad3 d1				pop de   ;  get string start    
1ad4			 
1ad4				; hl has destination from malloc 
1ad4			 
1ad4 eb				ex de, hl    ; prep for ldir 
1ad5			 
1ad5 d5				push de   ; save malloc area for DSP later 
1ad6				;push hl   ; save malloc area for DSP later 
1ad6			 
1ad6			if DEBUG_FORTH_PUSH 
1ad6						DMARK "PHc" 
1ad6 f5				push af  
1ad7 3a eb 1a			ld a, (.dmark)  
1ada 32 7a ee			ld (debug_mark),a  
1add 3a ec 1a			ld a, (.dmark+1)  
1ae0 32 7b ee			ld (debug_mark+1),a  
1ae3 3a ed 1a			ld a, (.dmark+2)  
1ae6 32 7c ee			ld (debug_mark+2),a  
1ae9 18 03			jr .pastdmark  
1aeb ..			.dmark: db "PHc"  
1aee f1			.pastdmark: pop af  
1aef			endm  
# End of macro DMARK
1aef				CALLMONITOR 
1aef cd 2c 14			call break_point_state  
1af2				endm  
# End of macro CALLMONITOR
1af2			endif	 
1af2			 
1af2			 
1af2 ed b0			ldir 
1af4			 
1af4			 
1af4				; push malloc to data stack     macro?????  
1af4			 
1af4				FORTH_DSP_NEXT 
1af4 cd 48 19			call macro_forth_dsp_next 
1af7				endm 
# End of macro FORTH_DSP_NEXT
1af7			 
1af7				; save value and type 
1af7			 
1af7 2a 0d eb			ld hl, (cli_data_sp) 
1afa			 
1afa				; save item type 
1afa 3e 01			ld a,  DS_TYPE_STR 
1afc 77				ld (hl), a 
1afd 23				inc hl 
1afe			 
1afe				; get malloc word off stack 
1afe d1				pop de 
1aff 73				ld (hl), e 
1b00 23				inc hl 
1b01 72				ld (hl), d 
1b02			 
1b02			 
1b02			 
1b02			if DEBUG_FORTH_PUSH 
1b02 2a 0d eb			ld hl, (cli_data_sp) 
1b05						DMARK "PHS" 
1b05 f5				push af  
1b06 3a 1a 1b			ld a, (.dmark)  
1b09 32 7a ee			ld (debug_mark),a  
1b0c 3a 1b 1b			ld a, (.dmark+1)  
1b0f 32 7b ee			ld (debug_mark+1),a  
1b12 3a 1c 1b			ld a, (.dmark+2)  
1b15 32 7c ee			ld (debug_mark+2),a  
1b18 18 03			jr .pastdmark  
1b1a ..			.dmark: db "PHS"  
1b1d f1			.pastdmark: pop af  
1b1e			endm  
# End of macro DMARK
1b1e				CALLMONITOR 
1b1e cd 2c 14			call break_point_state  
1b21				endm  
# End of macro CALLMONITOR
1b21			;	ex de,hl 
1b21			endif	 
1b21				; in case of spaces, skip the ptr past the copied string 
1b21				;pop af 
1b21				;ld (cli_origptr),hl 
1b21			 
1b21 c9				ret 
1b22			 
1b22			 
1b22			 
1b22			; TODO ascii push input onto stack given hl to start of input 
1b22			 
1b22			; identify type 
1b22			; if starts with a " then a string 
1b22			; otherwise it is a number 
1b22			;  
1b22			; if a string 
1b22			;     scan for ending " to get length of string to malloc for + 1 
1b22			;     malloc 
1b22			;     put pointer to string on stack first byte flags as string 
1b22			; 
1b22			; else a number 
1b22			;    look for number format identifier 
1b22			;    $xx hex 
1b22			;    %xxxxx bin 
1b22			;    xxxxx decimal 
1b22			;    convert number to 16bit word.  
1b22			;    malloc word + 1 with flag to identiy as num 
1b22			;    put pointer to number on stack 
1b22			;   
1b22			;  
1b22			  
1b22			forth_apush: 
1b22				; kernel push 
1b22			 
1b22			if DEBUG_FORTH_PUSH 
1b22						DMARK "PSH" 
1b22 f5				push af  
1b23 3a 37 1b			ld a, (.dmark)  
1b26 32 7a ee			ld (debug_mark),a  
1b29 3a 38 1b			ld a, (.dmark+1)  
1b2c 32 7b ee			ld (debug_mark+1),a  
1b2f 3a 39 1b			ld a, (.dmark+2)  
1b32 32 7c ee			ld (debug_mark+2),a  
1b35 18 03			jr .pastdmark  
1b37 ..			.dmark: db "PSH"  
1b3a f1			.pastdmark: pop af  
1b3b			endm  
# End of macro DMARK
1b3b				CALLMONITOR 
1b3b cd 2c 14			call break_point_state  
1b3e				endm  
# End of macro CALLMONITOR
1b3e			endif	 
1b3e				; identify input type 
1b3e			 
1b3e 7e				ld a,(hl) 
1b3f fe 22			cp '"' 
1b41 28 0a			jr z, .fapstr 
1b43 fe 24			cp '$' 
1b45 ca 6d 1b			jp z, .faphex 
1b48 fe 25			cp '%' 
1b4a ca 55 1b			jp z, .fapbin 
1b4d			;	cp 'b' 
1b4d			;	jp z, .fabin 
1b4d				; else decimal 
1b4d			 
1b4d				; TODO do decimal conversion 
1b4d				; decimal is stored as a 16bit word 
1b4d			 
1b4d				; by default everything is a string if type is not detected 
1b4d			.fapstr: ; 
1b4d fe 22			cp '"' 
1b4f 20 01			jr nz, .strnoqu 
1b51 23				inc hl 
1b52			.strnoqu: 
1b52 c3 27 1a			jp forth_push_str 
1b55			 
1b55			 
1b55			 
1b55			.fapbin:    ; push a binary string.  
1b55 11 00 00			ld de, 0   ; hold a 16bit value 
1b58			 
1b58 23			.fapbinshift:	inc hl  
1b59 7e				ld a,(hl) 
1b5a fe 00			cp 0     ; done scanning  
1b5c 28 0b			jr z, .fapbdone  	; got it in HL so push  
1b5e			 
1b5e				; left shift de 
1b5e eb				ex de, hl	 
1b5f 29				add hl, hl 
1b60			 
1b60				; is 1 
1b60 fe 31			cp '1' 
1b62 20 02			jr nz, .binzero 
1b64 cb 4d			bit 1, l 
1b66			.binzero: 
1b66 eb				ex de, hl	 ; save current de 
1b67 18 ef			jr .fapbinshift 
1b69			 
1b69			.fapbdone: 
1b69 eb				ex de, hl 
1b6a c3 b9 19			jp forth_push_numhl 
1b6d			 
1b6d			 
1b6d			.faphex:   ; hex is always stored as a 16bit word 
1b6d				; skip number prefix 
1b6d 23				inc hl 
1b6e				; turn ascii into number 
1b6e cd 69 0f			call get_word_hl	; ret 16bit word in hl 
1b71			 
1b71 c3 b9 19			jp forth_push_numhl 
1b74			 
1b74 00				 nop 
1b75			 
1b75			.fabin:   ; TODO bin conversion 
1b75			 
1b75			 
1b75 c9				ret 
1b76			 
1b76			 
1b76			; get either a string ptr or a 16bit word from the data stack 
1b76			 
1b76			FORTH_DSP: macro 
1b76				call macro_forth_dsp 
1b76				endm 
1b76			 
1b76			macro_forth_dsp: 
1b76				; data stack pointer points to current word on tos 
1b76			 
1b76 2a 0d eb			ld hl,(cli_data_sp) 
1b79			 
1b79				if DEBUG_FORTH_PUSH 
1b79						DMARK "DSP" 
1b79 f5				push af  
1b7a 3a 8e 1b			ld a, (.dmark)  
1b7d 32 7a ee			ld (debug_mark),a  
1b80 3a 8f 1b			ld a, (.dmark+1)  
1b83 32 7b ee			ld (debug_mark+1),a  
1b86 3a 90 1b			ld a, (.dmark+2)  
1b89 32 7c ee			ld (debug_mark+2),a  
1b8c 18 03			jr .pastdmark  
1b8e ..			.dmark: db "DSP"  
1b91 f1			.pastdmark: pop af  
1b92			endm  
# End of macro DMARK
1b92			 
1b92 cd 28 45				call display_data_sp 
1b95				;call break_point_state 
1b95				;rst 030h 
1b95				CALLMONITOR 
1b95 cd 2c 14			call break_point_state  
1b98				endm  
# End of macro CALLMONITOR
1b98				endif 
1b98			 
1b98 c9				ret 
1b99			 
1b99			; return hl to start of value on stack 
1b99			 
1b99			FORTH_DSP_VALUE: macro 
1b99				call macro_forth_dsp_value 
1b99				endm 
1b99			 
1b99			macro_forth_dsp_value: 
1b99			 
1b99				FORTH_DSP 
1b99 cd 76 1b			call macro_forth_dsp 
1b9c				endm 
# End of macro FORTH_DSP
1b9c			 
1b9c d5				push de 
1b9d			 
1b9d 23				inc hl ; skip type 
1b9e			 
1b9e 5e				ld e, (hl) 
1b9f 23				inc hl 
1ba0 56				ld d, (hl) 
1ba1 eb				ex de,hl  
1ba2			 
1ba2 d1				pop de 
1ba3			 
1ba3 c9				ret 
1ba4			 
1ba4			; return hl to start of value to second item on stack 
1ba4			 
1ba4			FORTH_DSP_VALUEM1: macro 
1ba4				call macro_forth_dsp_value_m1 
1ba4				endm 
1ba4			 
1ba4			macro_forth_dsp_value_m1: 
1ba4			 
1ba4				FORTH_DSP 
1ba4 cd 76 1b			call macro_forth_dsp 
1ba7				endm 
# End of macro FORTH_DSP
1ba7			 
1ba7 2b				dec hl 
1ba8 2b				dec hl 
1ba9			;	dec hl 
1ba9			 
1ba9 d5				push de 
1baa			 
1baa 5e				ld e, (hl) 
1bab 23				inc hl 
1bac 56				ld d, (hl) 
1bad eb				ex de,hl  
1bae			 
1bae d1				pop de 
1baf			 
1baf c9				ret 
1bb0			 
1bb0				 
1bb0			 
1bb0			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1bb0			 
1bb0			FORTH_DSP_POP: macro 
1bb0				call macro_forth_dsp_pop 
1bb0				endm 
1bb0			 
1bb0			 
1bb0			; get the tos data type 
1bb0			 
1bb0			FORTH_DSP_TYPE:   macro 
1bb0			 
1bb0				;FORTH_DSP_VALUE 
1bb0				FORTH_DSP 
1bb0				 
1bb0				; hl points to value 
1bb0				; check type 
1bb0			 
1bb0				ld a,(hl) 
1bb0			 
1bb0				endm 
1bb0			 
1bb0			; load the tos value into hl 
1bb0			 
1bb0			 
1bb0			FORTH_DSP_VALUEHL:  macro 
1bb0				call macro_dsp_valuehl 
1bb0				endm 
1bb0			 
1bb0			 
1bb0			 
1bb0			macro_dsp_valuehl: 
1bb0				FORTH_DSP_VALUE 
1bb0 cd 99 1b			call macro_forth_dsp_value 
1bb3				endm 
# End of macro FORTH_DSP_VALUE
1bb3			 
1bb3				;FORTH_ERR_TOS_NOTNUM 
1bb3			 
1bb3				;inc hl   ; skip type id 
1bb3			 
1bb3			;	push de 
1bb3			; 
1bb3			;	ld e, (hl) 
1bb3			;	inc hl 
1bb3			;	ld d, (hl) 
1bb3			;	ex de,hl  
1bb3			 
1bb3			;	pop de 
1bb3			 
1bb3				if DEBUG_FORTH_PUSH 
1bb3						DMARK "DVL" 
1bb3 f5				push af  
1bb4 3a c8 1b			ld a, (.dmark)  
1bb7 32 7a ee			ld (debug_mark),a  
1bba 3a c9 1b			ld a, (.dmark+1)  
1bbd 32 7b ee			ld (debug_mark+1),a  
1bc0 3a ca 1b			ld a, (.dmark+2)  
1bc3 32 7c ee			ld (debug_mark+2),a  
1bc6 18 03			jr .pastdmark  
1bc8 ..			.dmark: db "DVL"  
1bcb f1			.pastdmark: pop af  
1bcc			endm  
# End of macro DMARK
1bcc				CALLMONITOR 
1bcc cd 2c 14			call break_point_state  
1bcf				endm  
# End of macro CALLMONITOR
1bcf				endif 
1bcf c9				ret 
1bd0			 
1bd0			forth_apushstrhl:      
1bd0				; push of string requires use of cli_origptr 
1bd0				; bodge use 
1bd0			 
1bd0				; get current cli_origptr, save, update with temp pointer  
1bd0 ed 5b 29 eb		ld de, (cli_origptr) 
1bd4 22 29 eb			ld (cli_origptr), hl 
1bd7 d5				push de 
1bd8 cd 22 1b			call forth_apush 
1bdb d1				pop de 
1bdc ed 53 29 eb		ld (cli_origptr), de 
1be0 c9			        ret	 
1be1			 
1be1			 
1be1			; increase loop stack pointer and save hl to it 
1be1				 
1be1			FORTH_LOOP_NEXT: macro 
1be1				call macro_forth_loop_next 
1be1				;nop 
1be1				endm 
1be1			 
1be1			macro_forth_loop_next: 
1be1				if DEBUG_FORTH_STACK_GUARD 
1be1 cd 8d 55				call check_stacks 
1be4				endif 
1be4 e5				push hl 
1be5 d5				push de 
1be6 eb				ex de,hl 
1be7 2a 0f eb			ld hl,(cli_loop_sp) 
1bea 23				inc hl 
1beb 23				inc hl 
1bec					if DEBUG_FORTH_WORDS 
1bec						DMARK "LNX" 
1bec f5				push af  
1bed 3a 01 1c			ld a, (.dmark)  
1bf0 32 7a ee			ld (debug_mark),a  
1bf3 3a 02 1c			ld a, (.dmark+1)  
1bf6 32 7b ee			ld (debug_mark+1),a  
1bf9 3a 03 1c			ld a, (.dmark+2)  
1bfc 32 7c ee			ld (debug_mark+2),a  
1bff 18 03			jr .pastdmark  
1c01 ..			.dmark: db "LNX"  
1c04 f1			.pastdmark: pop af  
1c05			endm  
# End of macro DMARK
1c05						CALLMONITOR 
1c05 cd 2c 14			call break_point_state  
1c08				endm  
# End of macro CALLMONITOR
1c08					endif 
1c08 22 0f eb			ld (cli_loop_sp),hl 
1c0b 73				ld (hl), e 
1c0c 23				inc hl 
1c0d 72				ld (hl), d 
1c0e d1				pop de    ; been reversed so save a swap on restore 
1c0f e1				pop hl 
1c10				if DEBUG_FORTH_STACK_GUARD 
1c10 cd 8d 55				call check_stacks 
1c13				endif 
1c13 c9				ret 
1c14			 
1c14			; get current ret stack pointer and save to hl  
1c14				 
1c14			FORTH_LOOP_TOS: macro 
1c14				call macro_forth_loop_tos 
1c14				endm 
1c14			 
1c14			macro_forth_loop_tos: 
1c14 d5				push de 
1c15 2a 0f eb			ld hl,(cli_loop_sp) 
1c18 5e				ld e, (hl) 
1c19 23				inc hl 
1c1a 56				ld d, (hl) 
1c1b eb				ex de, hl 
1c1c d1				pop de 
1c1d c9				ret 
1c1e			 
1c1e			; pop loop stack pointer 
1c1e				 
1c1e			FORTH_LOOP_POP: macro 
1c1e				call macro_forth_loop_pop 
1c1e				endm 
1c1e			 
1c1e			 
1c1e			macro_forth_loop_pop: 
1c1e				if DEBUG_FORTH_STACK_GUARD 
1c1e					DMARK "LPP" 
1c1e f5				push af  
1c1f 3a 33 1c			ld a, (.dmark)  
1c22 32 7a ee			ld (debug_mark),a  
1c25 3a 34 1c			ld a, (.dmark+1)  
1c28 32 7b ee			ld (debug_mark+1),a  
1c2b 3a 35 1c			ld a, (.dmark+2)  
1c2e 32 7c ee			ld (debug_mark+2),a  
1c31 18 03			jr .pastdmark  
1c33 ..			.dmark: db "LPP"  
1c36 f1			.pastdmark: pop af  
1c37			endm  
# End of macro DMARK
1c37 cd 8d 55				call check_stacks 
1c3a					FORTH_CHK_LOOP_UNDER 
1c3a e5				push hl 
1c3b d5				push de 
1c3c 2a 0f eb			ld hl,(cli_loop_sp) 
1c3f 11 c9 e9			ld de, cli_loop_stack 
1c42 cd d0 0b			call cmp16 
1c45 da a7 56			jp c, fault_loop_under 
1c48 d1				pop de 
1c49 e1				pop hl 
1c4a				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1c4a				endif 
1c4a e5				push hl 
1c4b 2a 0f eb			ld hl,(cli_loop_sp) 
1c4e 2b				dec hl 
1c4f 2b				dec hl 
1c50 22 0f eb			ld (cli_loop_sp), hl 
1c53				; TODO do stack underflow checks 
1c53 e1				pop hl 
1c54				if DEBUG_FORTH_STACK_GUARD 
1c54 cd 8d 55				call check_stacks 
1c57					FORTH_CHK_LOOP_UNDER 
1c57 e5				push hl 
1c58 d5				push de 
1c59 2a 0f eb			ld hl,(cli_loop_sp) 
1c5c 11 c9 e9			ld de, cli_loop_stack 
1c5f cd d0 0b			call cmp16 
1c62 da a7 56			jp c, fault_loop_under 
1c65 d1				pop de 
1c66 e1				pop hl 
1c67				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1c67				endif 
1c67 c9				ret 
1c68			 
1c68			macro_forth_dsp_pop: 
1c68			 
1c68 e5				push hl 
1c69			 
1c69				; release malloc data 
1c69			 
1c69				if DEBUG_FORTH_STACK_GUARD 
1c69 cd 8d 55				call check_stacks 
1c6c					FORTH_CHK_DSP_UNDER 
1c6c e5				push hl 
1c6d d5				push de 
1c6e 2a 0d eb			ld hl,(cli_data_sp) 
1c71 11 c7 e8			ld de, cli_data_stack 
1c74 cd d0 0b			call cmp16 
1c77 da 9b 56			jp c, fault_dsp_under 
1c7a d1				pop de 
1c7b e1				pop hl 
1c7c				endm 
# End of macro FORTH_CHK_DSP_UNDER
1c7c				endif 
1c7c				;ld hl,(cli_data_sp) 
1c7c			if DEBUG_FORTH_DOT 
1c7c				DMARK "DPP" 
1c7c				CALLMONITOR 
1c7c			endif	 
1c7c			 
1c7c			 
1c7c			if FORTH_ENABLE_DSPPOPFREE 
1c7c			 
1c7c				FORTH_DSP 
1c7c cd 76 1b			call macro_forth_dsp 
1c7f				endm 
# End of macro FORTH_DSP
1c7f			 
1c7f 7e				ld a, (hl) 
1c80 fe 01			cp DS_TYPE_STR 
1c82 20 07			jr nz, .skippopfree 
1c84			 
1c84				FORTH_DSP_VALUEHL 
1c84 cd b0 1b			call macro_dsp_valuehl 
1c87				endm 
# End of macro FORTH_DSP_VALUEHL
1c87 00				nop 
1c88			if DEBUG_FORTH_DOT 
1c88				DMARK "DPf" 
1c88				CALLMONITOR 
1c88			endif	 
1c88 cd 43 11			call free 
1c8b			.skippopfree: 
1c8b				 
1c8b			 
1c8b			endif 
1c8b			 
1c8b			if DEBUG_FORTH_DOT_KEY 
1c8b				DMARK "DP2" 
1c8b				CALLMONITOR 
1c8b			endif	 
1c8b			 
1c8b				; move pointer down 
1c8b			 
1c8b 2a 0d eb			ld hl,(cli_data_sp) 
1c8e 2b				dec hl 
1c8f 2b				dec hl 
1c90			; PARSEV5 
1c90 2b				dec hl 
1c91 22 0d eb			ld (cli_data_sp), hl 
1c94			 
1c94				if DEBUG_FORTH_STACK_GUARD 
1c94 cd 8d 55				call check_stacks 
1c97					FORTH_CHK_DSP_UNDER 
1c97 e5				push hl 
1c98 d5				push de 
1c99 2a 0d eb			ld hl,(cli_data_sp) 
1c9c 11 c7 e8			ld de, cli_data_stack 
1c9f cd d0 0b			call cmp16 
1ca2 da 9b 56			jp c, fault_dsp_under 
1ca5 d1				pop de 
1ca6 e1				pop hl 
1ca7				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ca7				endif 
1ca7			 
1ca7 e1				pop hl 
1ca8			 
1ca8 c9				ret 
1ca9			 
1ca9			getwordathl: 
1ca9				; hl points to an address 
1ca9				; load hl with the word at that address 
1ca9			 
1ca9 d5				push de 
1caa			 
1caa 5e				ld e, (hl) 
1cab 23				inc hl 
1cac 56				ld d, (hl) 
1cad eb				ex de, hl 
1cae			 
1cae d1				pop de 
1caf c9				ret 
1cb0			 
1cb0			 
1cb0			 
1cb0			 
1cb0			 
1cb0			; eof 
1cb0			 
# End of file forth_stackopsv5.asm
1cb0			endif 
1cb0			 
1cb0			user_word_eol:  
1cb0				; hl contains the pointer to where to create a linked list item from the end 
1cb0				; of the user dict to continue on at the system word dict 
1cb0				 
1cb0				; poke the stub of the word list linked list to repoint to rom words 
1cb0			 
1cb0				; stub format 
1cb0				; db   word id 
1cb0				; dw    link to next word 
1cb0			        ; db char length of token 
1cb0				; db string + 0 term 
1cb0				; db exec code....  
1cb0			 
1cb0 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1cb2 77				ld (hl), a		; word id 
1cb3 23				inc hl 
1cb4			 
1cb4 11 7a 1e			ld de, sysdict 
1cb7 73				ld (hl), e		; next word link ie system dict 
1cb8 23				inc hl 
1cb9 72				ld (hl), d		; next word link ie system dict 
1cba 23				inc hl	 
1cbb			 
1cbb			;	ld (hl), sysdict		; next word link ie system dict 
1cbb			;	inc hl 
1cbb			;	inc hl 
1cbb			 
1cbb			;	inc hl 
1cbb			;	inc hl 
1cbb			 
1cbb 3e 02			ld a, 2			; word length is 0 
1cbd 77				ld (hl), a	 
1cbe 23				inc hl 
1cbf			 
1cbf 3e 7e			ld a, '~'			; word length is 0 
1cc1 77				ld (hl), a	 
1cc2 23				inc hl 
1cc3 3e 00			ld a, 0			; save empty word 
1cc5 77				ld (hl), a 
1cc6			 
1cc6 c9				ret 
1cc7			 
1cc7				 
1cc7			 
1cc7			forthexec_cleanup: 
1cc7				FORTH_RSP_POP 
1cc7 cd 81 19			call macro_forth_rsp_pop 
1cca				endm 
# End of macro FORTH_RSP_POP
1cca c9				ret 
1ccb			 
1ccb			forth_call_hl: 
1ccb				; taking hl 
1ccb e5				push hl 
1ccc c9				ret 
1ccd			 
1ccd			; this is called to reset Forth system but keep existing uwords etc 
1ccd			 
1ccd			forth_warmstart: 
1ccd				; setup stack over/under flow checks 
1ccd				if DEBUG_FORTH_STACK_GUARD 
1ccd cd 73 55				call chk_stk_init 
1cd0				endif 
1cd0			 
1cd0				; init stack pointers  - * these stacks go upwards *  
1cd0 21 cb ea			ld hl, cli_ret_stack 
1cd3 22 11 eb			ld (cli_ret_sp), hl	 
1cd6				; set bottom of stack 
1cd6 3e 00			ld a,0 
1cd8 77				ld (hl),a 
1cd9 23				inc hl 
1cda 77				ld (hl),a 
1cdb			 
1cdb 21 c7 e8			ld hl, cli_data_stack 
1cde 22 0d eb			ld (cli_data_sp), hl	 
1ce1				; set bottom of stack 
1ce1 3e 00			ld a,0 
1ce3 77				ld (hl),a 
1ce4 23				inc hl 
1ce5 77				ld (hl),a 
1ce6			 
1ce6 21 c9 e9			ld hl, cli_loop_stack 
1ce9 22 0f eb			ld (cli_loop_sp), hl	 
1cec				; set bottom of stack 
1cec 3e 00			ld a,0 
1cee 77				ld (hl),a 
1cef 23				inc hl 
1cf0 77				ld (hl),a 
1cf1			 
1cf1				; init extent of current open file 
1cf1			 
1cf1 3e 00			ld a, 0 
1cf3 32 5c eb			ld (store_openext), a 
1cf6			 
1cf6 c9				ret 
1cf7			 
1cf7			 
1cf7			; Cold Start - this is called to setup the whole Forth system 
1cf7			 
1cf7			forth_init: 
1cf7			 
1cf7				; setup stack over/under flow checks 
1cf7			 
1cf7			;	if DEBUG_FORTH_STACK_GUARD 
1cf7			;		call chk_stk_init 
1cf7			;	endif 
1cf7			 
1cf7				; enable auto display updates (slow.....) 
1cf7			 
1cf7 3e 01			ld a, 1 
1cf9 32 27 eb			ld (cli_autodisplay), a 
1cfc			 
1cfc			 
1cfc			 
1cfc				; show start up screen 
1cfc			 
1cfc cd 85 09			call clear_display 
1cff			 
1cff 3e 00			ld a,0 
1d01 32 49 eb			ld (f_cursor_ptr), a 
1d04			 
1d04				; set start of word list in start of ram - for use when creating user words 
1d04			 
1d04 21 96 58			ld hl, baseram 
1d07 22 5d e6			ld (os_last_new_uword), hl 
1d0a cd b0 1c			call user_word_eol 
1d0d				 
1d0d			;		call display_data_sp 
1d0d			;		call next_page_prompt 
1d0d			 
1d0d			 
1d0d			 
1d0d			 
1d0d c9				ret 
1d0e			 
1d0e .. 00		.bootforth: db " Forth Kernel Init ",0 
1d22			 
1d22			; TODO push to stack 
1d22			 
1d22			;  
1d22			 
1d22			if FORTH_PARSEV2 
1d22			 
1d22			 
1d22				include "forth_parserv2.asm" 
1d22			 
1d22			endif 
1d22			 
1d22			 
1d22			; parse cli version 1 
1d22			 
1d22			if FORTH_PARSEV1 
1d22			 
1d22			 
1d22			 
1d22			      include "forth_parserv1.asm" 
1d22			endif 
1d22				 
1d22			if FORTH_PARSEV3 
1d22			 
1d22			 
1d22			 
1d22			      include "forth_parserv3.asm" 
1d22				include "forth_wordsv3.asm" 
1d22			endif 
1d22			 
1d22			if FORTH_PARSEV4 
1d22			 
1d22			 
1d22			 
1d22			      include "forth_parserv4.asm" 
1d22				include "forth_wordsv4.asm" 
1d22			endif 
1d22			 
1d22			if FORTH_PARSEV5 
1d22			 
1d22			 
1d22			 
1d22			      include "forth_parserv5.asm" 
1d22			 
1d22			 
1d22			; A better parser without using malloc and string copies all over the place.  
1d22			; Exec in situ should be faster 
1d22			 
1d22			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1d22			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1d22			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1d22			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1d22			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1d22			WORD_SYS_END: equ 0   ; Opcode for all user words 
1d22			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1d22			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1d22			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1d22			 
1d22			; Core word preamble macro 
1d22			 
1d22			CWHEAD:   macro nxtword opcode lit len opflags 
1d22				db WORD_SYS_CORE+opcode             
1d22				; internal op code number 
1d22				dw nxtword            
1d22				; link to next dict word block 
1d22				db len + 1 
1d22				; literal length of dict word inc zero term 
1d22				db lit,0              
1d22				; literal dict word 
1d22			        ; TODO db opflags        
1d22				endm 
1d22			 
1d22			 
1d22			NEXTW: macro  
1d22				jp macro_next 
1d22				endm 
1d22			 
1d22			macro_next: 
1d22			if DEBUG_FORTH_PARSE_KEY 
1d22				DMARK "NXT" 
1d22				CALLMONITOR 
1d22			endif	 
1d22			;	inc hl  ; skip token null term  
1d22 ed 4b 2b eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1d26 ed 5b 29 eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1d2a 2a 61 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1d2d			if DEBUG_FORTH_PARSE_KEY 
1d2d				DMARK "}AA" 
1d2d				CALLMONITOR 
1d2d			endif	 
1d2d c3 30 1e			jp execnext 
1d30				;jp exec1 
1d30			       
1d30			 
1d30			 
1d30			; Another go at the parser to compile  
1d30			 
1d30			 
1d30			; TODO rework parser to change all of the string words to byte tokens 
1d30			; TODO do a search for  
1d30			 
1d30			; TODO first run normal parser to zero term sections 
1d30			; TODO for each word do a token look up to get the op code 
1d30			; TODO need some means to flag to the exec that this is a byte code form    
1d30			 
1d30			 
1d30			forthcompile: 
1d30			 
1d30			; 
1d30			; line parse: 
1d30			;       parse raw input buffer 
1d30			;       tokenise the words 
1d30			;       malloc new copy (for looping etc) 
1d30			;       copy to malloc + current pc in line to start of string and add line term 
1d30			;       save on new rsp 
1d30			; 
1d30			 
1d30			; hl to point to the line to tokenise 
1d30			 
1d30			;	push hl 
1d30 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1d33			 
1d33			;	ld a,0		; string term on input 
1d33			;	call strlent 
1d33			 
1d33			;	ld (os_tok_len), hl	 ; save string length 
1d33			 
1d33			;if DEBUG_FORTH_TOK 
1d33			;	ex de,hl		 
1d33			;endif 
1d33			 
1d33			;	pop hl 		; get back string pointer 
1d33			 
1d33			if DEBUG_FORTH_TOK 
1d33						DMARK "TOc" 
1d33				CALLMONITOR 
1d33			endif 
1d33 7e			.cptoken2:    ld a,(hl) 
1d34 23				inc hl 
1d35 fe 7f			cp FORTH_END_BUFFER 
1d37 28 29			jr z, .cptokendone2 
1d39 fe 00			cp 0 
1d3b 28 25			jr z, .cptokendone2 
1d3d fe 22			cp '"' 
1d3f 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1d41 fe 20			cp ' ' 
1d43 20 ee			jr nz,  .cptoken2 
1d45			 
1d45			; TODO consume comments held between ( and ) 
1d45			 
1d45				; we have a space so change to zero term for dict match later 
1d45 2b				dec hl 
1d46 3e 00			ld a,0 
1d48 77				ld (hl), a 
1d49 23				inc hl 
1d4a 18 e7			jr .cptoken2 
1d4c				 
1d4c			 
1d4c			.cptokenstr2: 
1d4c				; skip all white space until either eol (because forgot to term) or end double quote 
1d4c			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1d4c				;inc hl ; skip current double quote 
1d4c 7e				ld a,(hl) 
1d4d 23				inc hl 
1d4e fe 22			cp '"' 
1d50 28 e1			jr z, .cptoken2 
1d52 fe 7f			cp FORTH_END_BUFFER 
1d54 28 0c			jr z, .cptokendone2 
1d56 fe 00			cp 0 
1d58 28 08			jr z, .cptokendone2 
1d5a fe 20			cp ' ' 
1d5c 28 02			jr z, .cptmp2 
1d5e 18 ec			jr .cptokenstr2 
1d60			 
1d60			.cptmp2:	; we have a space so change to zero term for dict match later 
1d60				;dec hl 
1d60				;ld a,"-"	; TODO remove this when working 
1d60				;ld (hl), a 
1d60				;inc hl 
1d60 18 ea			jr .cptokenstr2 
1d62			 
1d62			.cptokendone2: 
1d62				;inc hl 
1d62 3e 7f			ld a, FORTH_END_BUFFER 
1d64 77				ld (hl),a 
1d65 23				inc hl 
1d66 3e 21			ld a, '!' 
1d68 77				ld (hl),a 
1d69			 
1d69 2a 61 e6			ld hl,(os_tok_ptr) 
1d6c			         
1d6c			if DEBUG_FORTH_TOK 
1d6c						DMARK "Tc1" 
1d6c				CALLMONITOR 
1d6c			endif 
1d6c			 
1d6c				; push exec string to top of return stack 
1d6c				FORTH_RSP_NEXT 
1d6c cd 60 19			call macro_forth_rsp_next 
1d6f				endm 
# End of macro FORTH_RSP_NEXT
1d6f c9				ret 
1d70			 
1d70			; Another go at the parser need to simplify the process 
1d70			 
1d70			forthparse: 
1d70			 
1d70			; 
1d70			; line parse: 
1d70			;       parse raw input buffer 
1d70			;       tokenise the words 
1d70			;       malloc new copy (for looping etc) 
1d70			;       copy to malloc + current pc in line to start of string and add line term 
1d70			;       save on new rsp 
1d70			; 
1d70			 
1d70			; hl to point to the line to tokenise 
1d70			 
1d70			;	push hl 
1d70 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1d73			 
1d73			;	ld a,0		; string term on input 
1d73			;	call strlent 
1d73			 
1d73			;	ld (os_tok_len), hl	 ; save string length 
1d73			 
1d73			;if DEBUG_FORTH_TOK 
1d73			;	ex de,hl		 
1d73			;endif 
1d73			 
1d73			;	pop hl 		; get back string pointer 
1d73			 
1d73			if DEBUG_FORTH_TOK 
1d73						DMARK "TOK" 
1d73				CALLMONITOR 
1d73			endif 
1d73 7e			.ptoken2:    ld a,(hl) 
1d74 23				inc hl 
1d75 fe 7f			cp FORTH_END_BUFFER 
1d77 28 29			jr z, .ptokendone2 
1d79 fe 00			cp 0 
1d7b 28 25			jr z, .ptokendone2 
1d7d fe 22			cp '"' 
1d7f 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1d81 fe 20			cp ' ' 
1d83 20 ee			jr nz,  .ptoken2 
1d85			 
1d85			; TODO consume comments held between ( and ) 
1d85			 
1d85				; we have a space so change to zero term for dict match later 
1d85 2b				dec hl 
1d86 3e 00			ld a,0 
1d88 77				ld (hl), a 
1d89 23				inc hl 
1d8a 18 e7			jr .ptoken2 
1d8c				 
1d8c			 
1d8c			.ptokenstr2: 
1d8c				; skip all white space until either eol (because forgot to term) or end double quote 
1d8c			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1d8c				;inc hl ; skip current double quote 
1d8c 7e				ld a,(hl) 
1d8d 23				inc hl 
1d8e fe 22			cp '"' 
1d90 28 e1			jr z, .ptoken2 
1d92 fe 7f			cp FORTH_END_BUFFER 
1d94 28 0c			jr z, .ptokendone2 
1d96 fe 00			cp 0 
1d98 28 08			jr z, .ptokendone2 
1d9a fe 20			cp ' ' 
1d9c 28 02			jr z, .ptmp2 
1d9e 18 ec			jr .ptokenstr2 
1da0			 
1da0			.ptmp2:	; we have a space so change to zero term for dict match later 
1da0				;dec hl 
1da0				;ld a,"-"	; TODO remove this when working 
1da0				;ld (hl), a 
1da0				;inc hl 
1da0 18 ea			jr .ptokenstr2 
1da2			 
1da2			.ptokendone2: 
1da2				;inc hl 
1da2 3e 7f			ld a, FORTH_END_BUFFER 
1da4 77				ld (hl),a 
1da5 23				inc hl 
1da6 3e 21			ld a, '!' 
1da8 77				ld (hl),a 
1da9			 
1da9 2a 61 e6			ld hl,(os_tok_ptr) 
1dac			         
1dac			if DEBUG_FORTH_TOK 
1dac						DMARK "TK1" 
1dac				CALLMONITOR 
1dac			endif 
1dac			 
1dac				; push exec string to top of return stack 
1dac				FORTH_RSP_NEXT 
1dac cd 60 19			call macro_forth_rsp_next 
1daf				endm 
# End of macro FORTH_RSP_NEXT
1daf c9				ret 
1db0			 
1db0			; 
1db0			;	; malloc size + buffer pointer + if is loop flag 
1db0			;	ld hl,(os_tok_len) 		 ; get string length 
1db0			; 
1db0			;	ld a,l 
1db0			; 
1db0			;	cp 0			; we dont want to use a null string 
1db0			;	ret z 
1db0			; 
1db0			;;	add 3    ; prefix malloc with buffer for current word ptr 
1db0			; 
1db0			;	add 5     ; TODO when certain not over writing memory remove 
1db0			; 
1db0			;		 
1db0			; 
1db0			;if DEBUG_FORTH_TOK 
1db0			;			DMARK "TKE" 
1db0			;	CALLMONITOR 
1db0			;endif 
1db0			; 
1db0			;	ld l,a 
1db0			;	ld h,0 
1db0			;;	push hl   ; save required space for the copy later 
1db0			;	call malloc 
1db0			;if DEBUG_FORTH_TOK 
1db0			;			DMARK "TKM" 
1db0			;	CALLMONITOR 
1db0			;endif 
1db0			;	if DEBUG_FORTH_MALLOC_GUARD 
1db0			;		push af 
1db0			;		call ishlzero 
1db0			;;		ld a, l 
1db0			;;		add h 
1db0			;;		cp 0 
1db0			;		pop af 
1db0			;		 
1db0			;		call z,malloc_error 
1db0			;	endif 
1db0			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1db0			; 
1db0			; 
1db0			;if DEBUG_FORTH_TOK 
1db0			;			DMARK "TKR" 
1db0			;	CALLMONITOR 
1db0			;endif 
1db0			; 
1db0			;	FORTH_RSP_NEXT 
1db0			; 
1db0			;	;inc hl	 ; go past current buffer pointer 
1db0			;	;inc hl 
1db0			;	;inc hl   ; and past if loop flag 
1db0			;		; TODO Need to set flag  
1db0			; 
1db0			;	 
1db0			;	 
1db0			;	ex de,hl	; malloc is dest 
1db0			;	ld hl, (os_tok_len) 
1db0			;;	pop bc 
1db0			;	ld c, l                
1db0			;	ld b,0 
1db0			;	ld hl, (os_tok_ptr) 
1db0			; 
1db0			;if DEBUG_FORTH_TOK 
1db0			;			DMARK "TKT" 
1db0			;	CALLMONITOR 
1db0			;endif 
1db0			; 
1db0			;	; do str cpy 
1db0			; 
1db0			;	ldir      ; copy byte in hl to de 
1db0			; 
1db0			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1db0			; 
1db0			;if DEBUG_FORTH_TOK 
1db0			; 
1db0			;			DMARK "TKY" 
1db0			;	CALLMONITOR 
1db0			;endif 
1db0			;	;ld a,0 
1db0			;	;ld a,FORTH_END_BUFFER 
1db0			;	ex de, hl 
1db0			;	;dec hl			 ; go back over the space delim at the end of word 
1db0			;	;ld (hl),a 
1db0			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1db0			;	ld a,FORTH_END_BUFFER 
1db0			;	ld (hl),a 
1db0			;	inc hl 
1db0			;	ld a,FORTH_END_BUFFER 
1db0			;	ld (hl),a 
1db0			; 
1db0			;	; init the malloc area data 
1db0			;	; set pc for in current area 
1db0			;	;ld hl, (os_tok_malloc) 
1db0			;	;inc hl 
1db0			;	;inc hl 
1db0			;	;inc hl 
1db0			;	;ex de,hl 
1db0			;	;ld hl, (os_tok_malloc) 
1db0			;	;ld (hl),e 
1db0			;	;inc hl 
1db0			;	;ld (hl),d 
1db0			; 
1db0			; 
1db0			;	ld hl,(os_tok_malloc) 
1db0			;if DEBUG_FORTH_PARSE_KEY 
1db0			;			DMARK "TKU" 
1db0			;	CALLMONITOR 
1db0			;endif 
1db0			; 
1db0			;	ret 
1db0			 
1db0			forthexec: 
1db0			 
1db0			; line exec: 
1db0			; forth parser 
1db0			 
1db0			; 
1db0			;       get current exec line on rsp 
1db0			 
1db0				FORTH_RSP_TOS 
1db0 cd 77 19			call macro_forth_rsp_tos 
1db3				endm 
# End of macro FORTH_RSP_TOS
1db3			 
1db3			;       restore current pc - hl points to malloc of data 
1db3			 
1db3				;ld e, (hl) 
1db3				;inc hl 
1db3				;ld d, (hl) 
1db3				;ex de,hl 
1db3			 
1db3			 
1db3			exec1: 
1db3 22 61 e6			ld (os_tok_ptr), hl 
1db6			 
1db6				; copy our PC to working vars  
1db6 22 2b eb			ld (cli_ptr), hl 
1db9 22 29 eb			ld (cli_origptr), hl 
1dbc			 
1dbc 7e				ld a,(hl) 
1dbd fe 7f			cp FORTH_END_BUFFER 
1dbf c8				ret z 
1dc0			 
1dc0				; skip any nulls 
1dc0			 
1dc0 fe 00			cp 0 
1dc2 20 03			jr nz, .execword 
1dc4 23				inc hl 
1dc5 18 ec			jr exec1 
1dc7			 
1dc7			 
1dc7			.execword: 
1dc7			 
1dc7			 
1dc7			 
1dc7			if DEBUG_FORTH_PARSE_KEY 
1dc7						DMARK "KYQ" 
1dc7				CALLMONITOR 
1dc7			endif 
1dc7			;       while at start of word: 
1dc7			; get start of dict (in user area first) 
1dc7			 
1dc7 21 96 58		ld hl, baseram 
1dca			;ld hl, sysdict 
1dca 22 2d eb		ld (cli_nextword),hl 
1dcd			;           match word at pc 
1dcd			;           exec word 
1dcd			;           or push to dsp 
1dcd			;           forward to next token 
1dcd			;           if line term pop rsp and exit 
1dcd			;        
1dcd			 
1dcd			if DEBUG_FORTH_PARSE_KEY 
1dcd						DMARK "KYq" 
1dcd				CALLMONITOR 
1dcd			endif 
1dcd			 
1dcd			; 
1dcd			; word comp 
1dcd			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1dcd			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1dcd			;    move to start of word  
1dcd			;    compare word to cli_token 
1dcd			 
1dcd			.execpnword:	; HL at start of a word in the dictionary to check 
1dcd			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1dcd			;	ld (cli_ptr), hl 
1dcd			 
1dcd 2a 2d eb			ld hl,(cli_nextword) 
1dd0			 
1dd0 cd 73 1e			call forth_tok_next 
1dd3			; tok next start here 
1dd3			;	; TODO skip compiled symbol for now 
1dd3			;	inc hl 
1dd3			; 
1dd3			;	; save pointer to next word 
1dd3			; 
1dd3			;	; hl now points to the address of the next word pointer  
1dd3			;	ld e, (hl) 
1dd3			;	inc hl 
1dd3			;	ld d, (hl) 
1dd3			;	inc l 
1dd3			; 
1dd3			;	ex de,hl 
1dd3			;if DEBUG_FORTH_PARSE_NEXTWORD 
1dd3			;	push bc 
1dd3			;	ld bc, (cli_nextword) 
1dd3			;			DMARK "NXW" 
1dd3			;	CALLMONITOR 
1dd3			;	pop bc 
1dd3			;endif 
1dd3			; tok next end here 
1dd3 22 2d eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
1dd6 eb				ex de, hl 
1dd7			 
1dd7			 
1dd7				; save the pointer of the current token - 1 to check against 
1dd7				 
1dd7 22 31 eb			ld (cli_token), hl   
1dda				; TODO maybe remove below save if no debug 
1dda				; save token string ptr for any debug later 
1dda 23				inc hl  
1ddb 22 33 eb			ld (cli_origtoken), hl 
1dde 2b				dec hl 
1ddf				; save pointer to the start of the next dictionay word 
1ddf 7e				ld a,(hl)   ; get string length 
1de0 47				ld b,a 
1de1			.execpnwordinc:  
1de1 23				inc hl 
1de2 10 fd			djnz .execpnwordinc 
1de4 22 2f eb			ld (cli_execword), hl      ; save start of this words code 
1de7			 
1de7				; now check the word token against the string being parsed 
1de7			 
1de7 2a 31 eb			ld hl,(cli_token) 
1dea 23				inc hl     ; skip string length (use zero term instead to end) 
1deb 22 31 eb			ld (cli_token), hl 
1dee			 
1dee			if DEBUG_FORTH_PARSE_KEY 
1dee						DMARK "KY2" 
1dee			endif 
1dee			if DEBUG_FORTH_PARSE_EXEC 
1dee				; see if disabled 
1dee			 
1dee				ld a, (os_view_disable) 
1dee				cp '*' 
1dee				jr z, .skip 
1dee			 
1dee				push hl 
1dee				push hl 
1dee				call clear_display 
1dee				ld de, .compword 
1dee				ld a, display_row_1 
1dee				call str_at_display 
1dee				pop de 
1dee				ld a, display_row_2 
1dee				call str_at_display 
1dee				ld hl,(cli_ptr) 
1dee				ld a,(hl) 
1dee			        ld hl, os_word_scratch 
1dee				ld (hl),a 
1dee				ld a,0 
1dee				inc hl 
1dee				ld (hl),a 	 
1dee				ld de, os_word_scratch 
1dee				ld a, display_row_2+10 
1dee				call str_at_display 
1dee				call update_display 
1dee				ld a, 100 
1dee				call aDelayInMS 
1dee				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1dee				call delay250ms 
1dee				endif 
1dee				pop hl 
1dee			.skip:  
1dee			endif	 
1dee			.execpnchar:    ; compare char between token and string to parse 
1dee			 
1dee			if DEBUG_FORTH_PARSE_KEY 
1dee						DMARK "Ky3" 
1dee			endif 
1dee			if DEBUG_FORTH_PARSE_EXEC 
1dee				; see if disabled 
1dee			 
1dee				ld a, (os_view_disable) 
1dee				cp '*' 
1dee				jr z, .skip2 
1dee			 
1dee			;	call clear_display 
1dee			ld hl,(cli_token) 
1dee			ld a,(hl) 
1dee			ld (os_word_scratch),a 
1dee				ld hl,(cli_ptr) 
1dee			ld a,(hl) 
1dee				ld (os_word_scratch+1),a 
1dee				ld a,0 
1dee				ld (os_word_scratch+2),a 
1dee				ld de,os_word_scratch 
1dee				ld a,display_row_4 
1dee				call str_at_display 
1dee				call update_display 
1dee			.skip2:  
1dee			endif 
1dee 2a 31 eb			ld hl,(cli_token) 
1df1 7e				ld a, (hl)	 ; char in word token 
1df2 23				inc hl 		; move to next char 
1df3 22 31 eb			ld (cli_token), hl ; and save it 
1df6 47				ld b,a 
1df7			 
1df7 2a 2b eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
1dfa 7e				ld a,(hl) 
1dfb 23				inc hl 
1dfc 22 2b eb			ld (cli_ptr), hl		; move to next char 
1dff cd 07 10			call toUpper 		; make sure the input string matches case 
1e02			 
1e02			if DEBUG_FORTH_PARSE 
1e02			endif 
1e02			 
1e02				; input stream end of token is a space so get rid of it 
1e02			 
1e02			;	cp ' ' 
1e02			;	jr nz, .pnskipspace 
1e02			; 
1e02			;	ld a, 0		; make same term as word token term 
1e02			; 
1e02			;.pnskipspace: 
1e02			 
1e02			if DEBUG_FORTH_PARSE_KEY 
1e02						DMARK "KY7" 
1e02			endif 
1e02 b8				cp b 
1e03 c2 19 1e			jp nz, .execpnskipword	 ; no match so move to next word 
1e06				 
1e06			;    if same 
1e06			;       scan for string terms 0 for token and 32 for input 
1e06			 
1e06				 
1e06			if DEBUG_FORTH_PARSE_KEY 
1e06						DMARK "KY8" 
1e06			endif 
1e06			 
1e06 80				add b			 
1e07 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1e09							; TODO need to make sure last word in zero term string is accounted for 
1e09 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1e0b			 
1e0b			 
1e0b				; at end of both strings so both are exact match 
1e0b			 
1e0b			;       skip ptr for next word 
1e0b			 
1e0b 2a 2b eb			ld hl,(cli_ptr) 	; at input string term 
1e0e 23				inc hl			 ; at next char 
1e0f 22 2b eb			ld (cli_ptr), hl     ; save for next round of the parser 
1e12 22 29 eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1e15				 
1e15				 
1e15			if DEBUG_FORTH_PARSE_KEY 
1e15						DMARK "KY3" 
1e15			endif 
1e15			 
1e15			 
1e15			 
1e15			;       exec code block 
1e15			if DEBUG_FORTH_JP 
1e15				call clear_display 
1e15				call update_display 
1e15				call delay1s 
1e15				ld hl, (cli_execword)     ; save for next check if no match on this word 
1e15				ld a,h 
1e15				ld hl, os_word_scratch 
1e15				call hexout 
1e15				ld hl, (cli_execword)     ; save for next check if no match on this word 
1e15				ld a,l 
1e15				ld hl, os_word_scratch+2 
1e15				call hexout 
1e15				ld hl, os_word_scratch+4 
1e15				ld a,0 
1e15				ld (hl),a 
1e15				ld de,os_word_scratch 
1e15				call str_at_display 
1e15					ld a, display_row_2 
1e15					call str_at_display 
1e15				ld de, (cli_origtoken) 
1e15				ld a, display_row_1+10 
1e15					call str_at_display 
1e15			 
1e15				ld a,display_row_1 
1e15				ld de, .foundword 
1e15				ld a, display_row_3 
1e15				call str_at_display 
1e15				call update_display 
1e15				call delay1s 
1e15				call delay1s 
1e15				call delay1s 
1e15			endif 
1e15			 
1e15			if DEBUG_FORTH_PARSE_KEY 
1e15						DMARK "KYj" 
1e15			endif 
1e15				; TODO save the word pointer in this exec 
1e15			 
1e15 2a 2f eb			ld hl,(cli_execword) 
1e18 e9				jp (hl) 
1e19			 
1e19			 
1e19			;    if not same 
1e19			;	scan for zero term 
1e19			;	get ptr for next word 
1e19			;	goto word comp 
1e19			 
1e19			.execpnskipword:	; get pointer to next word 
1e19 2a 2d eb			ld hl,(cli_nextword) 
1e1c			 
1e1c 7e				ld a,(hl) 
1e1d fe 00			cp WORD_SYS_END 
1e1f			;	cp 0 
1e1f 28 09			jr z, .execendofdict			 ; at end of words 
1e21			 
1e21			if DEBUG_FORTH_PARSE_KEY 
1e21						DMARK "KY4" 
1e21			endif 
1e21			if DEBUG_FORTH_PARSE_EXEC 
1e21			 
1e21				; see if disabled 
1e21			 
1e21				ld a, (os_view_disable) 
1e21				cp '*' 
1e21				jr z, .noskip 
1e21			 
1e21			 
1e21				ld de, .nowordfound 
1e21				ld a, display_row_3 
1e21				call str_at_display 
1e21				call update_display 
1e21				ld a, 100 
1e21				call aDelayInMS 
1e21				 
1e21				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1e21					call delay250ms 
1e21				endif 
1e21			.noskip:  
1e21			 
1e21			endif	 
1e21			 
1e21 2a 29 eb			ld hl,(cli_origptr) 
1e24 22 2b eb			ld (cli_ptr),hl 
1e27			 
1e27			if DEBUG_FORTH_PARSE_KEY 
1e27						DMARK "KY5" 
1e27			endif 
1e27 c3 cd 1d			jp .execpnword			; else go to next word 
1e2a			 
1e2a			.execendofdict:  
1e2a			 
1e2a			if DEBUG_FORTH_PARSE_KEY 
1e2a						DMARK "KYe" 
1e2a			endif 
1e2a			if DEBUG_FORTH_PARSE_EXEC 
1e2a				; see if disabled 
1e2a			 
1e2a				ld a, (os_view_disable) 
1e2a				cp '*' 
1e2a				jr z, .ispskip 
1e2a			 
1e2a				call clear_display 
1e2a				call update_display 
1e2a				call delay1s 
1e2a				ld de, (cli_origptr) 
1e2a				ld a, display_row_1 
1e2a				call str_at_display 
1e2a				 
1e2a				ld de, .enddict 
1e2a				ld a, display_row_3 
1e2a				call str_at_display 
1e2a				call update_display 
1e2a				ld a, 100 
1e2a				call aDelayInMS 
1e2a				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1e2a				call delay1s 
1e2a				call delay1s 
1e2a				call delay1s 
1e2a				endif 
1e2a			.ispskip:  
1e2a				 
1e2a			endif	 
1e2a			 
1e2a			 
1e2a			 
1e2a				; if the word is not a keyword then must be a literal so push it to stack 
1e2a			 
1e2a			; push token to stack to end of word 
1e2a			 
1e2a				STACKFRAME ON $1efe $2f9f 
1e2a				if DEBUG_STACK_IMB 
1e2a					if ON 
1e2a						exx 
1e2a						ld de, $1efe 
1e2a						ld a, d 
1e2a						ld hl, curframe 
1e2a						call hexout 
1e2a						ld a, e 
1e2a						ld hl, curframe+2 
1e2a						call hexout 
1e2a						ld hl, $1efe 
1e2a						push hl 
1e2a						ld hl, $2f9f 
1e2a						push hl 
1e2a						exx 
1e2a					endif 
1e2a				endif 
1e2a			endm 
# End of macro STACKFRAME
1e2a			 
1e2a 2a 61 e6		ld hl,(os_tok_ptr) 
1e2d cd 22 1b		call forth_apush 
1e30			 
1e30				STACKFRAMECHK ON $1efe $2f9f 
1e30				if DEBUG_STACK_IMB 
1e30					if ON 
1e30						exx 
1e30						ld hl, $2f9f 
1e30						pop de   ; $2f9f 
1e30						call cmp16 
1e30						jr nz, .spnosame 
1e30						ld hl, $1efe 
1e30						pop de   ; $1efe 
1e30						call cmp16 
1e30						jr z, .spfrsame 
1e30						.spnosame: call showsperror 
1e30						.spfrsame: nop 
1e30						exx 
1e30					endif 
1e30				endif 
1e30			endm 
# End of macro STACKFRAMECHK
1e30			 
1e30			execnext: 
1e30			 
1e30			if DEBUG_FORTH_PARSE_KEY 
1e30						DMARK "KY>" 
1e30			endif 
1e30			; move past token to next word 
1e30			 
1e30 2a 61 e6		ld hl, (os_tok_ptr) 
1e33 3e 00		ld a, 0 
1e35 01 ff 00		ld bc, 255     ; input buffer size 
1e38 ed b1		cpir 
1e3a			 
1e3a			if DEBUG_FORTH_PARSE_KEY 
1e3a						DMARK "KY!" 
1e3a				CALLMONITOR 
1e3a			endif	 
1e3a			; TODO this might place hl on the null, so will need to forward on??? 
1e3a			;inc hl   ; see if this gets onto the next item 
1e3a			 
1e3a			 
1e3a			; TODO pass a pointer to the buffer to push 
1e3a			; TODO call function to push 
1e3a			 
1e3a			; look for end of input 
1e3a			 
1e3a			;inc hl 
1e3a			;ld a,(hl) 
1e3a			;cp FORTH_END_BUFFER 
1e3a			;ret z 
1e3a			 
1e3a			 
1e3a c3 b3 1d		jp exec1 
1e3d			 
1e3d			 
1e3d			 
1e3d			 
1e3d			 
1e3d			 
1e3d			 
1e3d			 
1e3d			 
1e3d			findnexttok: 
1e3d			 
1e3d				; hl is pointer to move 
1e3d				; de is the token to locate 
1e3d			 
1e3d					if DEBUG_FORTH 
1e3d						DMARK "NTK" 
1e3d						CALLMONITOR 
1e3d					endif 
1e3d d5				push de 
1e3e			 
1e3e			.fnt1:	 
1e3e				; find first char of token to locate 
1e3e			 
1e3e 1a				ld a, (de) 
1e3f 4f				ld c,a 
1e40 7e				ld a,(hl) 
1e41 cd 07 10			call toUpper 
1e44					if DEBUG_FORTH 
1e44						DMARK "NT1" 
1e44						CALLMONITOR 
1e44					endif 
1e44 b9				cp c 
1e45			 
1e45 28 03			jr z, .fnt2cmpmorefirst	 
1e47			 
1e47				; first char not found move to next char 
1e47			 
1e47 23				inc hl 
1e48 18 f4			jr .fnt1 
1e4a			 
1e4a			.fnt2cmpmorefirst:	 
1e4a				; first char of token found.  
1e4a			 
1e4a e5				push hl     ; save start of token just in case it is the right one 
1e4b d9				exx 
1e4c e1				pop hl        ; save it to hl' 
1e4d d9				exx 
1e4e			 
1e4e			 
1e4e			.fnt2cmpmore:	 
1e4e				; compare the rest 
1e4e				 
1e4e 23				inc hl 
1e4f 13				inc de 
1e50				 
1e50 1a				ld a, (de) 
1e51 4f				ld c,a 
1e52 7e				ld a,(hl) 
1e53 cd 07 10			call toUpper 
1e56			 
1e56					if DEBUG_FORTH 
1e56						DMARK "NT2" 
1e56						CALLMONITOR 
1e56					endif 
1e56				; c has the token to find char 
1e56				; a has the mem to scan char 
1e56			 
1e56 b9				cp c 
1e57 28 04			jr z,.fntmatch1 
1e59			 
1e59				; they are not the same 
1e59			 
1e59					if DEBUG_FORTH 
1e59						DMARK "NT3" 
1e59						CALLMONITOR 
1e59					endif 
1e59 d1				pop de	; reset de token to look for 
1e5a d5				push de 
1e5b 18 e1			jr .fnt1 
1e5d				 
1e5d			.fntmatch1: 
1e5d			 
1e5d				; is the same char a null which means we might have a full hit? 
1e5d					if DEBUG_FORTH 
1e5d						DMARK "NT4" 
1e5d						CALLMONITOR 
1e5d					endif 
1e5d			 
1e5d fe 00			cp 0 
1e5f 28 0b			jr z, .fntmatchyes 
1e61			 
1e61				; are we at the end of the token to find? 
1e61			 
1e61					if DEBUG_FORTH 
1e61						DMARK "NT5" 
1e61						CALLMONITOR 
1e61					endif 
1e61 3e 00			ld a, 0 
1e63 b9				cp c 
1e64			 
1e64 c2 4e 1e			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1e67			 
1e67					if DEBUG_FORTH 
1e67						DMARK "NT6" 
1e67						CALLMONITOR 
1e67					endif 
1e67				; token to find is exhusted but no match to stream 
1e67			 
1e67				; restore tok pointer and continue on 
1e67 d1				pop de 
1e68 d5				push de 
1e69 c3 3e 1e			jp .fnt1 
1e6c			 
1e6c			 
1e6c			.fntmatchyes: 
1e6c			 
1e6c				; hl now contains the end of the found token 
1e6c			 
1e6c				; get rid of saved token pointer to find 
1e6c			 
1e6c d1				pop de 
1e6d			 
1e6d					if DEBUG_FORTH 
1e6d						DMARK "NT9" 
1e6d						CALLMONITOR 
1e6d					endif 
1e6d			 
1e6d				; hl will be on the null term so forward on 
1e6d			 
1e6d				; get back the saved start of the token 
1e6d			 
1e6d d9				exx 
1e6e e5				push hl     ; save start of token just in case it is the right one 
1e6f d9				exx 
1e70 e1				pop hl        ; save it to hl 
1e71			 
1e71 c9				ret 
1e72			 
1e72			 
1e72			; LIST needs to find a specific token   
1e72			; FORGET needs to find a spefici token 
1e72			 
1e72			; SAVE needs to find all tokens by flag 
1e72			; WORDS just needs to scan through all  by flag 
1e72			; UWORDS needs to scan through all by flag 
1e72			 
1e72			 
1e72			; given hl as pointer to start of dict look up string 
1e72			; return hl as pointer to start of word block 
1e72			; or 0 if not found 
1e72			 
1e72			forth_find_tok: 
1e72 c9				ret 
1e73			 
1e73			; given hl as pointer to dict structure 
1e73			; move to the next dict block structure 
1e73			 
1e73			forth_tok_next: 
1e73				; hl now points to the address of the next word pointer  
1e73				; TODO skip compiled symbol for now 
1e73			;	push de 
1e73 23				inc hl 
1e74 5e				ld e, (hl) 
1e75 23				inc hl 
1e76 56				ld d, (hl) 
1e77 23				inc hl 
1e78			 
1e78 eb				ex de,hl 
1e79			if DEBUG_FORTH_PARSE_NEXTWORD 
1e79				push bc 
1e79				ld bc, (cli_nextword) 
1e79						DMARK "NXW" 
1e79				CALLMONITOR 
1e79				pop bc 
1e79			endif 
1e79			;	pop de	 
1e79 c9				ret 
1e7a			 
1e7a			 
1e7a			 
1e7a			; eof 
# End of file forth_parserv5.asm
1e7a				include "forth_wordsv4.asm" 
1e7a			 
1e7a			; the core word dictionary v4 
1e7a			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1e7a			 
1e7a			; this is a linked list for each of the system words used 
1e7a			; user defined words will follow the same format but will be in ram 
1e7a			 
1e7a			 
1e7a			; 
1e7a			; 
1e7a			; define linked list: 
1e7a			; 
1e7a			; 1. compiled byte op code 
1e7a			; 2. len of text word 
1e7a			; 3. text word 
1e7a			; 4. ptr to next dictionary word 
1e7a			; 5. asm, calls etc for the word 
1e7a			; 
1e7a			;  if 1 == 0 then last word in dict  
1e7a			;   
1e7a			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1e7a			;  
1e7a			;  
1e7a			; create basic standard set of words 
1e7a			; 
1e7a			;  
1e7a			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1e7a			; 2DUP 2DROP 2SWAP  
1e7a			; @ C@ - get byte  
1e7a			; ! C! - store byte 
1e7a			; 0< true if less than zero 
1e7a			; 0= true if zero 
1e7a			; < >  
1e7a			; = true if same 
1e7a			; variables 
1e7a			 
1e7a			 
1e7a			; Hardware specific words I may need 
1e7a			; 
1e7a			; IN OUT  
1e7a			; calls to key util functions 
1e7a			; calls to hardward abstraction stuff 
1e7a			; easy control of frame buffers and lcd i/o 
1e7a			; keyboard  
1e7a			 
1e7a			 
1e7a			;DICT: macro 
1e7a			; op_code, len, word, next 
1e7a			;    word: 
1e7a			;    db op_code 
1e7a			;    ds word zero term 
1e7a			;    dw next 
1e7a			;    endm 
1e7a			 
1e7a			 
1e7a			 
1e7a			 
1e7a			; op code 1 is a flag for user define words which are to be handled differently 
1e7a			 
1e7a			 
1e7a			; 
1e7a			; 
1e7a			;    TODO on entry to a word this should be the expected environment 
1e7a			;    hl - tos value if number then held, if string this is the ptr 
1e7a			;    de -  
1e7a			 
1e7a			 
1e7a			; opcode ranges 
1e7a			; 0 - end of word dict 
1e7a			; 255 - user define words 
1e7a			 
1e7a			sysdict: 
1e7a			include "forth_opcodes.asm" 
1e7a			; op codes for forth keywords 
1e7a			; free to use code 0  
1e7a				OPCODE_HEAP: equ  1 
1e7a				OPCODE_EXEC: equ 2 
1e7a				OPCODE_DUP: equ 3 
1e7a				OPCODE_SWAP: equ 4 
1e7a				OPCODE_COLN: equ 5 
1e7a				OPCODE_SCOLN: equ 6 
1e7a				OPCODE_DROP: equ 7 
1e7a				OPCODE_DUP2: equ 8 
1e7a				OPCODE_DROP2: equ 9 
1e7a				OPCODE_SWAP2: equ 10 
1e7a				OPCODE_AT: equ 11 
1e7a				OPCODE_CAT: equ 12 
1e7a				OPCODE_BANG: equ 13 
1e7a				OPCODE_CBANG: equ 14 
1e7a				OPCODE_SCALL: equ 15 
1e7a				OPCODE_DEPTH: equ 16 
1e7a				OPCODE_OVER: equ 17 
1e7a				OPCODE_PAUSE: equ 18 
1e7a				OPCODE_PAUSES: equ 19 
1e7a				OPCODE_ROT: equ 20 
1e7a			;free to reuse	OPCODE_WORDS: equ 21 
1e7a			        OPCODE_NOT: equ 21 
1e7a				OPCODE_UWORDS: equ 22 
1e7a				OPCODE_BP: equ 23 
1e7a				OPCODE_MONITOR: equ 24  
1e7a				OPCODE_MALLOC: equ 25 
1e7a				OPCODE_FREE: equ 26 
1e7a				OPCODE_LIST: equ 27 
1e7a				OPCODE_FORGET: equ 28 
1e7a				OPCODE_NOP: equ 29 
1e7a				OPCODE_COMO: equ 30 
1e7a				OPCODE_COMC: equ 31 
1e7a			;free to reuse	OPCODE_ENDCORE: equ 32 
1e7a				OPCODE_AFTERSOUND: equ 33 
1e7a				OPCODE_GP2: equ 34 
1e7a				OPCODE_GP3: equ 35 
1e7a				OPCODE_GP4: equ 36 
1e7a				OPCODE_SIN: equ 37 
1e7a				OPCODE_SOUT: equ 38 
1e7a				OPCODE_SPIO: equ 39 
1e7a				OPCODE_SPICEH: equ 40 
1e7a				OPCODE_SPIOb: equ 41 
1e7a				OPCODE_SPII: equ 42 
1e7a				OPCODE_SESEL: equ 43 
1e7a				OPCODE_CARTDEV: equ 44 
1e7a			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1e7a				OPCODE_FB: equ 46 
1e7a				OPCODE_EMIT: equ 47 
1e7a				OPCODE_DOTH: equ 48 
1e7a				OPCODE_DOTF: equ 49 
1e7a				OPCODE_DOT: equ 50 
1e7a				OPCODE_CLS: equ 51 
1e7a				OPCODE_DRAW: equ 52 
1e7a				OPCODE_DUMP: equ 53 
1e7a				OPCODE_CDUMP: equ 54 
1e7a				OPCODE_DAT: equ 55 
1e7a				OPCODE_HOME: equ 56 
1e7a				OPCODE_SPACE: equ 57 
1e7a				OPCODE_SPACES: equ 58 
1e7a				OPCODE_SCROLL: equ 59 
1e7a				OPCODE_ATQ: equ 60 
1e7a				OPCODE_AUTODSP: equ 61 
1e7a				OPCODE_MENU: equ 62 
1e7a			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1e7a				OPCODE_THEN: equ 64 
1e7a				OPCODE_ELSE: equ 65 
1e7a				OPCODE_DO: equ 66 
1e7a				OPCODE_LOOP: equ 67 
1e7a				OPCODE_I: equ 68 
1e7a				OPCODE_DLOOP: equ 69  
1e7a				OPCODE_REPEAT: equ 70  
1e7a				OPCODE_UNTIL: equ 71 
1e7a				OPCODE_ENDFLOW: equ 72 
1e7a				OPCODE_WAITK: equ 73 
1e7a				OPCODE_ACCEPT: equ 74 
1e7a				OPCODE_EDIT: equ 75 
1e7a			;free to reuse	OPCODE_ENDKEY: equ 76 
1e7a				OPCODE_LZERO: equ 77 
1e7a				OPCODE_TZERO: equ 78 
1e7a				OPCODE_LESS: equ 79 
1e7a				OPCODE_GT: equ 80 
1e7a				OPCODE_EQUAL: equ 81  
1e7a			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1e7a				OPCODE_NEG: equ 83 
1e7a				OPCODE_DIV: equ 84 
1e7a				OPCODE_MUL: equ 85 
1e7a				OPCODE_MIN: equ 86 
1e7a				OPCODE_MAX: equ 87 
1e7a				OPCODE_RND16: equ 88 
1e7a				OPCODE_RND8: equ 89 
1e7a				OPCODE_RND: equ 90 
1e7a			;free to reuse	OPCODE_ENDMATHS: equ 91  
1e7a				OPCODE_BYNAME: equ 92 
1e7a				OPCODE_DIR: equ 93 
1e7a				OPCODE_SAVE: equ 94 
1e7a				OPCODE_LOAD: equ 95 
1e7a				OPCODE_BSAVE: equ 96 
1e7a				OPCODE_BLOAD: equ 97 
1e7a				OPCODE_SEO: equ 98  
1e7a				OPCODE_SEI: equ 99 
1e7a				OPCODE_SFREE: equ 100 
1e7a				OPCODE_SIZE: equ 101 
1e7a				OPCODE_CREATE: equ 102 
1e7a				OPCODE_APPEND: equ 103 
1e7a				OPCODE_SDEL: equ 104 
1e7a				OPCODE_OPEN: equ 105 
1e7a				OPCODE_READ: equ 106 
1e7a				OPCODE_EOF: equ 106 
1e7a				OPCODE_FORMAT: equ 107 
1e7a				OPCODE_LABEL: equ 108 
1e7a				OPCODE_LABELS: equ 109 
1e7a			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1e7a				OPCODE_UPPER: equ 111 
1e7a				OPCODE_LOWER: equ 112 
1e7a				OPCODE_SUBSTR: equ 113 
1e7a				OPCODE_LEFT: equ 114 
1e7a				OPCODE_RIGHT: equ 115 
1e7a				OPCODE_STR2NUM: equ 116 
1e7a				OPCODE_NUM2STR: equ 117 
1e7a				OPCODE_CONCAT: equ 118 
1e7a				OPCODE_FIND: equ 119 
1e7a				OPCODE_LEN: equ 120 
1e7a				OPCODE_CHAR: equ 121 
1e7a			; free to reuse	OPCODE_STRLEN: equ 122 
1e7a			; free to reuse	OPCODE_ENDSTR: equ 123 
1e7a				OPCODE_V0S: equ 124 
1e7a				OPCODE_V0Q: equ 125 
1e7a				OPCODE_V1S: equ 126 
1e7a				OPCODE_V1Q: equ 127 
1e7a				OPCODE_V2S: equ 128 
1e7a				OPCODE_V2Q: equ 129 
1e7a				OPCODE_V3S: equ 130 
1e7a				OPCODE_V3Q: equ 131 
1e7a			;free to reuse	OPCODE_END: equ 132 
1e7a				OPCODE_ZDUP: equ 133 
1e7a			 
1e7a			; eof 
# End of file forth_opcodes.asm
1e7a			 
1e7a			include "forth_words_core.asm" 
1e7a			 
1e7a			; | ## Core Words 
1e7a			 
1e7a			;if MALLOC_4 
1e7a			 
1e7a			.HEAP: 
1e7a				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1e7a 15				db WORD_SYS_CORE+OPCODE_HEAP             
1e7b b9 1e			dw .EXEC            
1e7d 05				db 4 + 1 
1e7e .. 00			db "HEAP",0              
1e83				endm 
# End of macro CWHEAD
1e83			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1e83			; | | u1 - Current number of bytes in the heap 
1e83			; | | u2 - Remaining bytes left on the heap 
1e83			; | |  
1e83			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1e83			 
1e83			 
1e83					if DEBUG_FORTH_WORDS_KEY 
1e83						DMARK "HEP" 
1e83 f5				push af  
1e84 3a 98 1e			ld a, (.dmark)  
1e87 32 7a ee			ld (debug_mark),a  
1e8a 3a 99 1e			ld a, (.dmark+1)  
1e8d 32 7b ee			ld (debug_mark+1),a  
1e90 3a 9a 1e			ld a, (.dmark+2)  
1e93 32 7c ee			ld (debug_mark+2),a  
1e96 18 03			jr .pastdmark  
1e98 ..			.dmark: db "HEP"  
1e9b f1			.pastdmark: pop af  
1e9c			endm  
# End of macro DMARK
1e9c						CALLMONITOR 
1e9c cd 2c 14			call break_point_state  
1e9f				endm  
# End of macro CALLMONITOR
1e9f					endif 
1e9f 2a a0 58				ld hl, (free_list )      
1ea2 11 a5 58				ld de, heap_start 
1ea5			 
1ea5 ed 52				sbc hl, de  
1ea7			 
1ea7 cd b9 19				call forth_push_numhl 
1eaa			 
1eaa			 
1eaa ed 5b a0 58			ld de, (free_list )      
1eae 21 46 e3				ld hl, heap_end 
1eb1			 
1eb1 ed 52				sbc hl, de 
1eb3			 
1eb3 cd b9 19				call forth_push_numhl 
1eb6					 
1eb6			 
1eb6					 
1eb6			 
1eb6			 
1eb6			 
1eb6					NEXTW 
1eb6 c3 22 1d			jp macro_next 
1eb9				endm 
# End of macro NEXTW
1eb9			;endif 
1eb9			 
1eb9			.EXEC: 
1eb9			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1eb9			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
1eb9			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1eb9			;; > > 
1eb9			;; > >   
1eb9			;	STACKFRAME OFF $5efe $5f9f 
1eb9			; 
1eb9			;		if DEBUG_FORTH_WORDS_KEY 
1eb9			;			DMARK "EXE" 
1eb9			;			CALLMONITOR 
1eb9			;		endif 
1eb9			; 
1eb9			;	FORTH_DSP_VALUEHL 
1eb9			; 
1eb9			;	FORTH_DSP_POP 
1eb9			; 
1eb9			;		if DEBUG_FORTH_WORDS 
1eb9			;			DMARK "EX1" 
1eb9			;			CALLMONITOR 
1eb9			;		endif 
1eb9			;;	ld e,(hl) 
1eb9			;;	inc hl 
1eb9			;;	ld d,(hl) 
1eb9			;;	ex de,hl 
1eb9			; 
1eb9			;;		if DEBUG_FORTH_WORDS 
1eb9			;;			DMARK "EX2" 
1eb9			;;			CALLMONITOR 
1eb9			;;		endif 
1eb9			;	push hl 
1eb9			; 
1eb9			;	;ld a, 0 
1eb9			;	;ld a, FORTH_END_BUFFER 
1eb9			;	call strlenz 
1eb9			;	inc hl   ; include zero term to copy 
1eb9			;	inc hl   ; include term 
1eb9			;	inc hl   ; include term 
1eb9			;	ld b,0 
1eb9			;	ld c,l 
1eb9			;	pop hl 
1eb9			;	ld de, execscratch 
1eb9			;		if DEBUG_FORTH_WORDS 
1eb9			;			DMARK "EX3" 
1eb9			;			CALLMONITOR 
1eb9			;		endif 
1eb9			;	ldir 
1eb9			; 
1eb9			; 
1eb9			;	ld hl, execscratch 
1eb9			; 
1eb9			;		if DEBUG_FORTH_WORDS 
1eb9			;			DMARK "EXe" 
1eb9			;			CALLMONITOR 
1eb9			;		endif 
1eb9			; 
1eb9			;	call forthparse 
1eb9			;	call forthexec 
1eb9			;;	call forthexec_cleanup 
1eb9			;;	call forthparse 
1eb9			;;	call forthexec 
1eb9			; 
1eb9			;	STACKFRAMECHK OFF $5efe $5f9f 
1eb9			; 
1eb9			;	; an immediate word so no need to process any more words 
1eb9			;	ret 
1eb9			;	NEXTW 
1eb9			 
1eb9			; dead code - old version  
1eb9			;	FORTH_RSP_NEXT 
1eb9			 
1eb9			;  
1eb9			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1eb9			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1eb9			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1eb9			;	push hl 
1eb9			;	push de 
1eb9			;	push bc 
1eb9			; 
1eb9			; 
1eb9			;		if DEBUG_FORTH_WORDS_KEY 
1eb9			;			DMARK "EXR" 
1eb9			;			CALLMONITOR 
1eb9			;		endif 
1eb9			; 
1eb9			; 
1eb9			; 
1eb9			;	;v5 FORTH_DSP_VALUE 
1eb9			;	FORTH_DSP_VALUEHL 
1eb9			; 
1eb9			;	; TODO do string type checks 
1eb9			; 
1eb9			;;v5	inc hl   ; skip type 
1eb9			; 
1eb9			;	push hl  ; source code  
1eb9			;		if DEBUG_FORTH_WORDS 
1eb9			;			DMARK "EX1" 
1eb9			;			CALLMONITOR 
1eb9			;		endif 
1eb9			;	ld a, 0 
1eb9			;	call strlent 
1eb9			; 
1eb9			;	inc hl 
1eb9			;	inc hl 
1eb9			;	inc hl 
1eb9			;	inc hl 
1eb9			; 
1eb9			;	push hl    ; size 
1eb9			; 
1eb9			;		if DEBUG_FORTH_WORDS 
1eb9			;			DMARK "EX2" 
1eb9			;			CALLMONITOR 
1eb9			;		endif 
1eb9			;	call malloc 
1eb9			; 
1eb9			;	ex de, hl    ; de now contains malloc area 
1eb9			;	pop bc   	; get byte count 
1eb9			;	pop hl      ; get string to copy 
1eb9			; 
1eb9			;	push de     ; save malloc for free later 
1eb9			; 
1eb9			;		if DEBUG_FORTH_WORDS 
1eb9			;			DMARK "EX3" 
1eb9			;			CALLMONITOR 
1eb9			;		endif 
1eb9			;	ldir       ; duplicate string 
1eb9			; 
1eb9			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1eb9			;	 
1eb9			;	; TODO fix the parse would be better than this...  
1eb9			;	ex de, hl 
1eb9			;	dec hl 
1eb9			;	ld a, 0 
1eb9			;	ld (hl), a 
1eb9			;	dec hl 
1eb9			;	ld a, ' ' 
1eb9			;	ld (hl), a 
1eb9			;	dec hl 
1eb9			;	ld (hl), a 
1eb9			; 
1eb9			;	dec hl 
1eb9			;	ld (hl), a 
1eb9			; 
1eb9			; 
1eb9			;	FORTH_DSP_POP  
1eb9			; 
1eb9			;	pop hl     
1eb9			;	push hl    ; save malloc area 
1eb9			; 
1eb9			;		if DEBUG_FORTH_WORDS 
1eb9			;			DMARK "EX4" 
1eb9			;			CALLMONITOR 
1eb9			;		endif 
1eb9			; 
1eb9			;	call forthparse 
1eb9			;	call forthexec 
1eb9			;	 
1eb9			;	pop hl 
1eb9			;	if DEBUG_FORTH_WORDS 
1eb9			;		DMARK "EX5" 
1eb9			;		CALLMONITOR 
1eb9			;	endif 
1eb9			; 
1eb9			;	if FORTH_ENABLE_FREE 
1eb9			;	call free 
1eb9			;	endif 
1eb9			; 
1eb9			;	if DEBUG_FORTH_WORDS 
1eb9			;		DMARK "EX6" 
1eb9			;		CALLMONITOR 
1eb9			;	endif 
1eb9			; 
1eb9			;	pop bc 
1eb9			;	pop de 
1eb9			;	pop hl 
1eb9			;;	FORTH_RSP_POP	  
1eb9			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1eb9			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1eb9			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1eb9			; 
1eb9			;	if DEBUG_FORTH_WORDS 
1eb9			;		DMARK "EX7" 
1eb9			;		CALLMONITOR 
1eb9			;	endif 
1eb9			;	NEXTW 
1eb9			 
1eb9			;.STKEXEC: 
1eb9			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1eb9			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
1eb9			; 
1eb9			; 
1eb9			;		if DEBUG_FORTH_WORDS_KEY 
1eb9			;			DMARK "STX" 
1eb9			;			CALLMONITOR 
1eb9			;		endif 
1eb9			; 
1eb9			;	FORTH_DSP_VALUEHL 
1eb9			; 
1eb9			;	ld (store_tmp1), hl    ; count 
1eb9			; 
1eb9			;	FORTH_DSP_POP 
1eb9			;.stkexec1: 
1eb9			;	ld hl, (store_tmp1)   ; count 
1eb9			;	ld a, 0 
1eb9			;	cp l 
1eb9			;	ret z 
1eb9			; 
1eb9			;	dec hl 
1eb9			;	ld (store_tmp1), hl    ; count 
1eb9			;	 
1eb9			;	FORTH_DSP_VALUEHL 
1eb9			;	push hl 
1eb9			;	 
1eb9			;		if DEBUG_FORTH_WORDS 
1eb9			;			DMARK "EXp" 
1eb9			;			CALLMONITOR 
1eb9			;		endif 
1eb9			;	FORTH_DSP_POP 
1eb9			; 
1eb9			;	call strlenz 
1eb9			;	inc hl   ; include zero term to copy 
1eb9			;	inc hl   ; include zero term to copy 
1eb9			;	inc hl   ; include zero term to copy 
1eb9			;	ld b,0 
1eb9			;	ld c,l 
1eb9			;	pop hl 
1eb9			;	ld de, execscratch 
1eb9			;		if DEBUG_FORTH_WORDS 
1eb9			;			DMARK "EX3" 
1eb9			;			CALLMONITOR 
1eb9			;		endif 
1eb9			;	ldir 
1eb9			; 
1eb9			; 
1eb9			;	ld hl, execscratch 
1eb9			; 
1eb9			;		if DEBUG_FORTH_WORDS 
1eb9			;			DMARK "EXP" 
1eb9			;			CALLMONITOR 
1eb9			;		endif 
1eb9			; 
1eb9			;	call forthparse 
1eb9			;	ld hl, execscratch 
1eb9			;		if DEBUG_FORTH_WORDS 
1eb9			;			DMARK "EXx" 
1eb9			;			CALLMONITOR 
1eb9			;		endif 
1eb9			;	call forthexec 
1eb9			; 
1eb9			;	jp .stkexec1 
1eb9			; 
1eb9			;	ret 
1eb9			 
1eb9			 
1eb9			.DUP: 
1eb9				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1eb9 17				db WORD_SYS_CORE+OPCODE_DUP             
1eba 2f 1f			dw .ZDUP            
1ebc 04				db 3 + 1 
1ebd .. 00			db "DUP",0              
1ec1				endm 
# End of macro CWHEAD
1ec1			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1ec1			 
1ec1					if DEBUG_FORTH_WORDS_KEY 
1ec1						DMARK "DUP" 
1ec1 f5				push af  
1ec2 3a d6 1e			ld a, (.dmark)  
1ec5 32 7a ee			ld (debug_mark),a  
1ec8 3a d7 1e			ld a, (.dmark+1)  
1ecb 32 7b ee			ld (debug_mark+1),a  
1ece 3a d8 1e			ld a, (.dmark+2)  
1ed1 32 7c ee			ld (debug_mark+2),a  
1ed4 18 03			jr .pastdmark  
1ed6 ..			.dmark: db "DUP"  
1ed9 f1			.pastdmark: pop af  
1eda			endm  
# End of macro DMARK
1eda						CALLMONITOR 
1eda cd 2c 14			call break_point_state  
1edd				endm  
# End of macro CALLMONITOR
1edd					endif 
1edd			 
1edd					FORTH_DSP 
1edd cd 76 1b			call macro_forth_dsp 
1ee0				endm 
# End of macro FORTH_DSP
1ee0			 
1ee0 7e					ld a, (HL) 
1ee1 fe 01				cp DS_TYPE_STR 
1ee3 20 25				jr nz, .dupinum 
1ee5			 
1ee5					; push another string 
1ee5			 
1ee5					FORTH_DSP_VALUEHL     		 
1ee5 cd b0 1b			call macro_dsp_valuehl 
1ee8				endm 
# End of macro FORTH_DSP_VALUEHL
1ee8			 
1ee8				if DEBUG_FORTH_WORDS 
1ee8					DMARK "DUs" 
1ee8 f5				push af  
1ee9 3a fd 1e			ld a, (.dmark)  
1eec 32 7a ee			ld (debug_mark),a  
1eef 3a fe 1e			ld a, (.dmark+1)  
1ef2 32 7b ee			ld (debug_mark+1),a  
1ef5 3a ff 1e			ld a, (.dmark+2)  
1ef8 32 7c ee			ld (debug_mark+2),a  
1efb 18 03			jr .pastdmark  
1efd ..			.dmark: db "DUs"  
1f00 f1			.pastdmark: pop af  
1f01			endm  
# End of macro DMARK
1f01					CALLMONITOR 
1f01 cd 2c 14			call break_point_state  
1f04				endm  
# End of macro CALLMONITOR
1f04				endif 
1f04 cd 27 1a				call forth_push_str 
1f07			 
1f07					NEXTW 
1f07 c3 22 1d			jp macro_next 
1f0a				endm 
# End of macro NEXTW
1f0a			 
1f0a			 
1f0a			.dupinum: 
1f0a					 
1f0a			 
1f0a			 
1f0a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f0a cd b0 1b			call macro_dsp_valuehl 
1f0d				endm 
# End of macro FORTH_DSP_VALUEHL
1f0d			 
1f0d				; TODO add floating point number detection 
1f0d			 
1f0d				if DEBUG_FORTH_WORDS 
1f0d					DMARK "DUi" 
1f0d f5				push af  
1f0e 3a 22 1f			ld a, (.dmark)  
1f11 32 7a ee			ld (debug_mark),a  
1f14 3a 23 1f			ld a, (.dmark+1)  
1f17 32 7b ee			ld (debug_mark+1),a  
1f1a 3a 24 1f			ld a, (.dmark+2)  
1f1d 32 7c ee			ld (debug_mark+2),a  
1f20 18 03			jr .pastdmark  
1f22 ..			.dmark: db "DUi"  
1f25 f1			.pastdmark: pop af  
1f26			endm  
# End of macro DMARK
1f26					CALLMONITOR 
1f26 cd 2c 14			call break_point_state  
1f29				endm  
# End of macro CALLMONITOR
1f29				endif 
1f29			 
1f29 cd b9 19				call forth_push_numhl 
1f2c					NEXTW 
1f2c c3 22 1d			jp macro_next 
1f2f				endm 
# End of macro NEXTW
1f2f			.ZDUP: 
1f2f				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
1f2f 99				db WORD_SYS_CORE+OPCODE_ZDUP             
1f30 67 1f			dw .SWAP            
1f32 05				db 4 + 1 
1f33 .. 00			db "?DUP",0              
1f38				endm 
# End of macro CWHEAD
1f38			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
1f38			 
1f38					if DEBUG_FORTH_WORDS_KEY 
1f38						DMARK "qDU" 
1f38 f5				push af  
1f39 3a 4d 1f			ld a, (.dmark)  
1f3c 32 7a ee			ld (debug_mark),a  
1f3f 3a 4e 1f			ld a, (.dmark+1)  
1f42 32 7b ee			ld (debug_mark+1),a  
1f45 3a 4f 1f			ld a, (.dmark+2)  
1f48 32 7c ee			ld (debug_mark+2),a  
1f4b 18 03			jr .pastdmark  
1f4d ..			.dmark: db "qDU"  
1f50 f1			.pastdmark: pop af  
1f51			endm  
# End of macro DMARK
1f51						CALLMONITOR 
1f51 cd 2c 14			call break_point_state  
1f54				endm  
# End of macro CALLMONITOR
1f54					endif 
1f54					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f54 cd b0 1b			call macro_dsp_valuehl 
1f57				endm 
# End of macro FORTH_DSP_VALUEHL
1f57			 
1f57 e5					push hl 
1f58			 
1f58					; is it a zero? 
1f58			 
1f58 3e 00				ld a, 0 
1f5a 84					add h 
1f5b 85					add l 
1f5c			 
1f5c e1					pop hl 
1f5d			 
1f5d fe 00				cp 0 
1f5f 28 03				jr z, .dup2orig 
1f61			 
1f61			 
1f61 cd b9 19				call forth_push_numhl 
1f64			 
1f64			 
1f64				; TODO add floating point number detection 
1f64			 
1f64			.dup2orig: 
1f64			 
1f64					NEXTW 
1f64 c3 22 1d			jp macro_next 
1f67				endm 
# End of macro NEXTW
1f67			.SWAP: 
1f67				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
1f67 18				db WORD_SYS_CORE+OPCODE_SWAP             
1f68 a6 1f			dw .COLN            
1f6a 05				db 4 + 1 
1f6b .. 00			db "SWAP",0              
1f70				endm 
# End of macro CWHEAD
1f70			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
1f70					if DEBUG_FORTH_WORDS_KEY 
1f70						DMARK "SWP" 
1f70 f5				push af  
1f71 3a 85 1f			ld a, (.dmark)  
1f74 32 7a ee			ld (debug_mark),a  
1f77 3a 86 1f			ld a, (.dmark+1)  
1f7a 32 7b ee			ld (debug_mark+1),a  
1f7d 3a 87 1f			ld a, (.dmark+2)  
1f80 32 7c ee			ld (debug_mark+2),a  
1f83 18 03			jr .pastdmark  
1f85 ..			.dmark: db "SWP"  
1f88 f1			.pastdmark: pop af  
1f89			endm  
# End of macro DMARK
1f89						CALLMONITOR 
1f89 cd 2c 14			call break_point_state  
1f8c				endm  
# End of macro CALLMONITOR
1f8c					endif 
1f8c			 
1f8c					FORTH_DSP_VALUEHL 
1f8c cd b0 1b			call macro_dsp_valuehl 
1f8f				endm 
# End of macro FORTH_DSP_VALUEHL
1f8f e5					push hl     ; w2 
1f90			 
1f90					FORTH_DSP_POP 
1f90 cd 68 1c			call macro_forth_dsp_pop 
1f93				endm 
# End of macro FORTH_DSP_POP
1f93			 
1f93					FORTH_DSP_VALUEHL 
1f93 cd b0 1b			call macro_dsp_valuehl 
1f96				endm 
# End of macro FORTH_DSP_VALUEHL
1f96			 
1f96					FORTH_DSP_POP 
1f96 cd 68 1c			call macro_forth_dsp_pop 
1f99				endm 
# End of macro FORTH_DSP_POP
1f99			 
1f99 d1					pop de     ; w2	, hl = w1 
1f9a			 
1f9a eb					ex de, hl 
1f9b d5					push de 
1f9c			 
1f9c cd b9 19				call forth_push_numhl 
1f9f			 
1f9f e1					pop hl 
1fa0			 
1fa0 cd b9 19				call forth_push_numhl 
1fa3					 
1fa3			 
1fa3					NEXTW 
1fa3 c3 22 1d			jp macro_next 
1fa6				endm 
# End of macro NEXTW
1fa6			.COLN: 
1fa6				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
1fa6 19				db WORD_SYS_CORE+OPCODE_COLN             
1fa7 32 21			dw .SCOLN            
1fa9 02				db 1 + 1 
1faa .. 00			db ":",0              
1fac				endm 
# End of macro CWHEAD
1fac			; | : ( -- )         Create new word | DONE 
1fac			 
1fac					if DEBUG_FORTH_WORDS_KEY 
1fac						DMARK "CLN" 
1fac f5				push af  
1fad 3a c1 1f			ld a, (.dmark)  
1fb0 32 7a ee			ld (debug_mark),a  
1fb3 3a c2 1f			ld a, (.dmark+1)  
1fb6 32 7b ee			ld (debug_mark+1),a  
1fb9 3a c3 1f			ld a, (.dmark+2)  
1fbc 32 7c ee			ld (debug_mark+2),a  
1fbf 18 03			jr .pastdmark  
1fc1 ..			.dmark: db "CLN"  
1fc4 f1			.pastdmark: pop af  
1fc5			endm  
# End of macro DMARK
1fc5						CALLMONITOR 
1fc5 cd 2c 14			call break_point_state  
1fc8				endm  
# End of macro CALLMONITOR
1fc8					endif 
1fc8				STACKFRAME OFF $8efe $989f 
1fc8				if DEBUG_STACK_IMB 
1fc8					if OFF 
1fc8						exx 
1fc8						ld de, $8efe 
1fc8						ld a, d 
1fc8						ld hl, curframe 
1fc8						call hexout 
1fc8						ld a, e 
1fc8						ld hl, curframe+2 
1fc8						call hexout 
1fc8						ld hl, $8efe 
1fc8						push hl 
1fc8						ld hl, $989f 
1fc8						push hl 
1fc8						exx 
1fc8					endif 
1fc8				endif 
1fc8			endm 
# End of macro STACKFRAME
1fc8				; get parser buffer length  of new word 
1fc8			 
1fc8				 
1fc8			 
1fc8					; move tok past this to start of name defintition 
1fc8					; TODO get word to define 
1fc8					; TODO Move past word token 
1fc8					; TODO get length of string up to the ';' 
1fc8			 
1fc8 2a 61 e6			ld hl, (os_tok_ptr) 
1fcb 23				inc hl 
1fcc 23				inc hl 
1fcd			 
1fcd 3e 3b			ld a, ';' 
1fcf cd 1b 10			call strlent 
1fd2			 
1fd2 7d				ld a,l 
1fd3 32 5c e3			ld (os_new_parse_len), a 
1fd6			 
1fd6			 
1fd6			if DEBUG_FORTH_UWORD 
1fd6 ed 5b 61 e6		ld de, (os_tok_ptr) 
1fda						DMARK ":01" 
1fda f5				push af  
1fdb 3a ef 1f			ld a, (.dmark)  
1fde 32 7a ee			ld (debug_mark),a  
1fe1 3a f0 1f			ld a, (.dmark+1)  
1fe4 32 7b ee			ld (debug_mark+1),a  
1fe7 3a f1 1f			ld a, (.dmark+2)  
1fea 32 7c ee			ld (debug_mark+2),a  
1fed 18 03			jr .pastdmark  
1fef ..			.dmark: db ":01"  
1ff2 f1			.pastdmark: pop af  
1ff3			endm  
# End of macro DMARK
1ff3				CALLMONITOR 
1ff3 cd 2c 14			call break_point_state  
1ff6				endm  
# End of macro CALLMONITOR
1ff6			endif 
1ff6			 
1ff6			; 
1ff6			;  new word memory layout: 
1ff6			;  
1ff6			;    : adg 6666 ;  
1ff6			; 
1ff6			;    db   1     ; user defined word  
1ff6 23				inc hl    
1ff7			;    dw   sysdict 
1ff7 23				inc hl 
1ff8 23				inc hl 
1ff9			;    db <word len>+1 (for null) 
1ff9 23				inc hl 
1ffa			;    db .... <word> 
1ffa			; 
1ffa			 
1ffa 23				inc hl    ; some extras for the word preamble before the above 
1ffb 23				inc hl 
1ffc 23				inc hl 
1ffd 23				inc hl 
1ffe 23				inc hl 
1fff 23				inc hl 
2000 23				inc hl  
2001 23				inc hl 
2002 23				inc hl 
2003 23				inc hl 
2004 23				inc hl 
2005 23				inc hl 
2006 23				inc hl 
2007 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2008			;       exec word buffer 
2008			;	<ptr word>   
2008 23				inc hl 
2009 23				inc hl 
200a			;       <word list><null term> 7F final term 
200a			 
200a			 
200a			if DEBUG_FORTH_UWORD 
200a						DMARK ":02" 
200a f5				push af  
200b 3a 1f 20			ld a, (.dmark)  
200e 32 7a ee			ld (debug_mark),a  
2011 3a 20 20			ld a, (.dmark+1)  
2014 32 7b ee			ld (debug_mark+1),a  
2017 3a 21 20			ld a, (.dmark+2)  
201a 32 7c ee			ld (debug_mark+2),a  
201d 18 03			jr .pastdmark  
201f ..			.dmark: db ":02"  
2022 f1			.pastdmark: pop af  
2023			endm  
# End of macro DMARK
2023				CALLMONITOR 
2023 cd 2c 14			call break_point_state  
2026				endm  
# End of macro CALLMONITOR
2026			endif 
2026			 
2026				 
2026					; malloc the size 
2026			 
2026 cd 79 10				call malloc 
2029 22 5e e3				ld (os_new_malloc), hl     ; save malloc start 
202c			 
202c			;    db   1     ; user defined word  
202c 3e 01				ld a, WORD_SYS_UWORD  
202e 77					ld (hl), a 
202f				 
202f 23				inc hl    
2030			;    dw   sysdict 
2030 11 7a 1e			ld de, sysdict       ; continue on with the scan to the system dict 
2033 73				ld (hl), e 
2034 23				inc hl 
2035 72				ld (hl), d 
2036 23				inc hl 
2037			 
2037			 
2037			;    Setup dict word 
2037			 
2037 23				inc hl 
2038 22 58 e3			ld (os_new_work_ptr), hl     ; save start of dict word  
203b			 
203b				; 1. get length of dict word 
203b			 
203b			 
203b 2a 61 e6			ld hl, (os_tok_ptr) 
203e 23				inc hl 
203f 23				inc hl    ; position to start of dict word 
2040 3e 00			ld a, 0 
2042 cd 1b 10			call strlent 
2045			 
2045			 
2045 23				inc hl    ; to include null??? 
2046			 
2046				; write length of dict word 
2046			 
2046 ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
204a 1b				dec de 
204b eb				ex de, hl 
204c 73				ld (hl), e 
204d eb				ex de, hl 
204e			 
204e				 
204e			 
204e				; copy  
204e 4d				ld c, l 
204f 06 00			ld b, 0 
2051 ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2055 2a 61 e6			ld hl, (os_tok_ptr) 
2058 23				inc hl 
2059 23				inc hl    ; position to start of dict word 
205a				 
205a			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
205a				 
205a				; TODO need to convert word to upper case 
205a			 
205a			ucasetok:	 
205a 7e				ld a,(hl) 
205b cd 07 10			call toUpper 
205e 77				ld (hl),a 
205f ed a0			ldi 
2061 f2 5a 20		 	jp p, ucasetok 
2064			 
2064			 
2064			 
2064				; de now points to start of where the word body code should be placed 
2064 ed 53 58 e3		ld (os_new_work_ptr), de 
2068				; hl now points to the words to throw at forthexec which needs to be copied 
2068 22 56 e3			ld (os_new_src_ptr), hl 
206b			 
206b				; TODO add 'call to forthexec' 
206b			 
206b			if DEBUG_FORTH_UWORD 
206b c5				push bc 
206c ed 4b 5e e3		ld bc, (os_new_malloc) 
2070						DMARK ":0x" 
2070 f5				push af  
2071 3a 85 20			ld a, (.dmark)  
2074 32 7a ee			ld (debug_mark),a  
2077 3a 86 20			ld a, (.dmark+1)  
207a 32 7b ee			ld (debug_mark+1),a  
207d 3a 87 20			ld a, (.dmark+2)  
2080 32 7c ee			ld (debug_mark+2),a  
2083 18 03			jr .pastdmark  
2085 ..			.dmark: db ":0x"  
2088 f1			.pastdmark: pop af  
2089			endm  
# End of macro DMARK
2089				CALLMONITOR 
2089 cd 2c 14			call break_point_state  
208c				endm  
# End of macro CALLMONITOR
208c c1				pop bc 
208d			endif 
208d			 
208d			 
208d				; create word preamble which should be: 
208d			 
208d			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
208d			 
208d				;    ld hl, <word code> 
208d				;    jp user_exec 
208d			        ;    <word code bytes> 
208d			 
208d			 
208d			;	inc de     ; TODO ??? or are we already past the word's null 
208d eb				ex de, hl 
208e			 
208e 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2090			 
2090 23				inc hl 
2091 22 52 e3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2094 23				inc hl 
2095			 
2095 23				inc hl 
2096 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2098			 
2098 01 21 44			ld bc, user_exec 
209b 23				inc hl 
209c 71				ld (hl), c     ; poke address of user_exec 
209d 23				inc hl 
209e 70				ld (hl), b     
209f			 ; 
209f			;	inc hl 
209f			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
209f			; 
209f			; 
209f			;	ld bc, macro_forth_rsp_next 
209f			;	inc hl 
209f			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
209f			;	inc hl 
209f			;	ld (hl), b     
209f			 ; 
209f			;	inc hl 
209f			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
209f			; 
209f			; 
209f			;	inc hl 
209f			;	ld bc, forthexec 
209f			;	ld (hl), c     ; poke address of forthexec 
209f			;	inc hl 
209f			;	ld (hl), b      
209f			; 
209f			;	inc hl 
209f			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
209f			; 
209f			;	ld bc, user_dict_next 
209f			;	inc hl 
209f			;	ld (hl), c     ; poke address of forthexec 
209f			;	inc hl 
209f			;	ld (hl), b      
209f			 
209f				; hl is now where we need to copy the word byte data to save this 
209f			 
209f 23				inc hl 
20a0 22 54 e3			ld (os_new_exec), hl 
20a3				 
20a3				; copy definition 
20a3			 
20a3 eb				ex de, hl 
20a4			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
20a4			;	inc de    ; skip the PC for this parse 
20a4 3a 5c e3			ld a, (os_new_parse_len) 
20a7 4f				ld c, a 
20a8 06 00			ld b, 0 
20aa ed b0			ldir		 ; copy defintion 
20ac			 
20ac			 
20ac				; poke the address of where the new word bytes live for forthexec 
20ac			 
20ac 2a 52 e3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
20af			 
20af ed 5b 54 e3		ld de, (os_new_exec)      
20b3				 
20b3 73				ld (hl), e 
20b4 23				inc hl 
20b5 72				ld (hl), d 
20b6			 
20b6					; TODO copy last user dict word next link to this word 
20b6					; TODO update last user dict word to point to this word 
20b6			; 
20b6			; hl f923 de 812a ; bc 811a 
20b6			 
20b6			if DEBUG_FORTH_UWORD 
20b6 c5				push bc 
20b7 ed 4b 5e e3		ld bc, (os_new_malloc) 
20bb						DMARK ":0A" 
20bb f5				push af  
20bc 3a d0 20			ld a, (.dmark)  
20bf 32 7a ee			ld (debug_mark),a  
20c2 3a d1 20			ld a, (.dmark+1)  
20c5 32 7b ee			ld (debug_mark+1),a  
20c8 3a d2 20			ld a, (.dmark+2)  
20cb 32 7c ee			ld (debug_mark+2),a  
20ce 18 03			jr .pastdmark  
20d0 ..			.dmark: db ":0A"  
20d3 f1			.pastdmark: pop af  
20d4			endm  
# End of macro DMARK
20d4				CALLMONITOR 
20d4 cd 2c 14			call break_point_state  
20d7				endm  
# End of macro CALLMONITOR
20d7 c1				pop bc 
20d8			endif 
20d8			if DEBUG_FORTH_UWORD 
20d8 c5				push bc 
20d9 ed 4b 5e e3		ld bc, (os_new_malloc) 
20dd 03				inc bc 
20de 03				inc bc 
20df 03				inc bc 
20e0 03				inc bc 
20e1 03				inc bc 
20e2 03				inc bc 
20e3 03				inc bc 
20e4 03				inc bc 
20e5			 
20e5						DMARK ":0B" 
20e5 f5				push af  
20e6 3a fa 20			ld a, (.dmark)  
20e9 32 7a ee			ld (debug_mark),a  
20ec 3a fb 20			ld a, (.dmark+1)  
20ef 32 7b ee			ld (debug_mark+1),a  
20f2 3a fc 20			ld a, (.dmark+2)  
20f5 32 7c ee			ld (debug_mark+2),a  
20f8 18 03			jr .pastdmark  
20fa ..			.dmark: db ":0B"  
20fd f1			.pastdmark: pop af  
20fe			endm  
# End of macro DMARK
20fe				CALLMONITOR 
20fe cd 2c 14			call break_point_state  
2101				endm  
# End of macro CALLMONITOR
2101 c1				pop bc 
2102			endif 
2102			 
2102			; update word dict linked list for new word 
2102			 
2102			 
2102 2a 5d e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2105 23			inc hl     ; move to next work linked list ptr 
2106			 
2106 ed 5b 5e e3	ld de, (os_new_malloc)		 ; new next word 
210a 73			ld (hl), e 
210b 23			inc hl 
210c 72			ld (hl), d 
210d			 
210d			if DEBUG_FORTH_UWORD 
210d ed 4b 5d e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2111			endif 
2111			 
2111 ed 53 5d e6	ld (os_last_new_uword), de      ; update last new uword ptr 
2115			 
2115			 
2115			if DEBUG_FORTH_UWORD 
2115						DMARK ":0+" 
2115 f5				push af  
2116 3a 2a 21			ld a, (.dmark)  
2119 32 7a ee			ld (debug_mark),a  
211c 3a 2b 21			ld a, (.dmark+1)  
211f 32 7b ee			ld (debug_mark+1),a  
2122 3a 2c 21			ld a, (.dmark+2)  
2125 32 7c ee			ld (debug_mark+2),a  
2128 18 03			jr .pastdmark  
212a ..			.dmark: db ":0+"  
212d f1			.pastdmark: pop af  
212e			endm  
# End of macro DMARK
212e				CALLMONITOR 
212e cd 2c 14			call break_point_state  
2131				endm  
# End of macro CALLMONITOR
2131			endif 
2131			 
2131				STACKFRAMECHK OFF $8efe $989f 
2131				if DEBUG_STACK_IMB 
2131					if OFF 
2131						exx 
2131						ld hl, $989f 
2131						pop de   ; $989f 
2131						call cmp16 
2131						jr nz, .spnosame 
2131						ld hl, $8efe 
2131						pop de   ; $8efe 
2131						call cmp16 
2131						jr z, .spfrsame 
2131						.spnosame: call showsperror 
2131						.spfrsame: nop 
2131						exx 
2131					endif 
2131				endif 
2131			endm 
# End of macro STACKFRAMECHK
2131			 
2131 c9			ret    ; dont process any remaining parser tokens as they form new word 
2132			 
2132			 
2132			 
2132			 
2132			;		NEXT 
2132			.SCOLN: 
2132			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2132 06				db OPCODE_SCOLN 
2133 7e 21			dw .DROP 
2135 02				db 2 
2136 .. 00			db ";",0           
2138			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2138					if DEBUG_FORTH_WORDS_KEY 
2138						DMARK "SCN" 
2138 f5				push af  
2139 3a 4d 21			ld a, (.dmark)  
213c 32 7a ee			ld (debug_mark),a  
213f 3a 4e 21			ld a, (.dmark+1)  
2142 32 7b ee			ld (debug_mark+1),a  
2145 3a 4f 21			ld a, (.dmark+2)  
2148 32 7c ee			ld (debug_mark+2),a  
214b 18 03			jr .pastdmark  
214d ..			.dmark: db "SCN"  
2150 f1			.pastdmark: pop af  
2151			endm  
# End of macro DMARK
2151						CALLMONITOR 
2151 cd 2c 14			call break_point_state  
2154				endm  
# End of macro CALLMONITOR
2154					endif 
2154					FORTH_RSP_TOS 
2154 cd 77 19			call macro_forth_rsp_tos 
2157				endm 
# End of macro FORTH_RSP_TOS
2157 e5					push hl 
2158					FORTH_RSP_POP 
2158 cd 81 19			call macro_forth_rsp_pop 
215b				endm 
# End of macro FORTH_RSP_POP
215b e1					pop hl 
215c			;		ex de,hl 
215c 22 61 e6				ld (os_tok_ptr),hl 
215f			 
215f			if DEBUG_FORTH_UWORD 
215f						DMARK "SCL" 
215f f5				push af  
2160 3a 74 21			ld a, (.dmark)  
2163 32 7a ee			ld (debug_mark),a  
2166 3a 75 21			ld a, (.dmark+1)  
2169 32 7b ee			ld (debug_mark+1),a  
216c 3a 76 21			ld a, (.dmark+2)  
216f 32 7c ee			ld (debug_mark+2),a  
2172 18 03			jr .pastdmark  
2174 ..			.dmark: db "SCL"  
2177 f1			.pastdmark: pop af  
2178			endm  
# End of macro DMARK
2178				CALLMONITOR 
2178 cd 2c 14			call break_point_state  
217b				endm  
# End of macro CALLMONITOR
217b			endif 
217b					NEXTW 
217b c3 22 1d			jp macro_next 
217e				endm 
# End of macro NEXTW
217e			 
217e			.DROP: 
217e				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
217e 1b				db WORD_SYS_CORE+OPCODE_DROP             
217f a9 21			dw .DUP2            
2181 05				db 4 + 1 
2182 .. 00			db "DROP",0              
2187				endm 
# End of macro CWHEAD
2187			; | DROP ( w -- )   drop the TOS item   | DONE 
2187					if DEBUG_FORTH_WORDS_KEY 
2187						DMARK "DRP" 
2187 f5				push af  
2188 3a 9c 21			ld a, (.dmark)  
218b 32 7a ee			ld (debug_mark),a  
218e 3a 9d 21			ld a, (.dmark+1)  
2191 32 7b ee			ld (debug_mark+1),a  
2194 3a 9e 21			ld a, (.dmark+2)  
2197 32 7c ee			ld (debug_mark+2),a  
219a 18 03			jr .pastdmark  
219c ..			.dmark: db "DRP"  
219f f1			.pastdmark: pop af  
21a0			endm  
# End of macro DMARK
21a0						CALLMONITOR 
21a0 cd 2c 14			call break_point_state  
21a3				endm  
# End of macro CALLMONITOR
21a3					endif 
21a3					FORTH_DSP_POP 
21a3 cd 68 1c			call macro_forth_dsp_pop 
21a6				endm 
# End of macro FORTH_DSP_POP
21a6					NEXTW 
21a6 c3 22 1d			jp macro_next 
21a9				endm 
# End of macro NEXTW
21a9			.DUP2: 
21a9				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
21a9 1c				db WORD_SYS_CORE+OPCODE_DUP2             
21aa ee 21			dw .DROP2            
21ac 05				db 4 + 1 
21ad .. 00			db "2DUP",0              
21b2				endm 
# End of macro CWHEAD
21b2			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
21b2					if DEBUG_FORTH_WORDS_KEY 
21b2						DMARK "2DU" 
21b2 f5				push af  
21b3 3a c7 21			ld a, (.dmark)  
21b6 32 7a ee			ld (debug_mark),a  
21b9 3a c8 21			ld a, (.dmark+1)  
21bc 32 7b ee			ld (debug_mark+1),a  
21bf 3a c9 21			ld a, (.dmark+2)  
21c2 32 7c ee			ld (debug_mark+2),a  
21c5 18 03			jr .pastdmark  
21c7 ..			.dmark: db "2DU"  
21ca f1			.pastdmark: pop af  
21cb			endm  
# End of macro DMARK
21cb						CALLMONITOR 
21cb cd 2c 14			call break_point_state  
21ce				endm  
# End of macro CALLMONITOR
21ce					endif 
21ce					FORTH_DSP_VALUEHL 
21ce cd b0 1b			call macro_dsp_valuehl 
21d1				endm 
# End of macro FORTH_DSP_VALUEHL
21d1 e5					push hl      ; 2 
21d2			 
21d2					FORTH_DSP_POP 
21d2 cd 68 1c			call macro_forth_dsp_pop 
21d5				endm 
# End of macro FORTH_DSP_POP
21d5					 
21d5					FORTH_DSP_VALUEHL 
21d5 cd b0 1b			call macro_dsp_valuehl 
21d8				endm 
# End of macro FORTH_DSP_VALUEHL
21d8			;		push hl      ; 1 
21d8			 
21d8					FORTH_DSP_POP 
21d8 cd 68 1c			call macro_forth_dsp_pop 
21db				endm 
# End of macro FORTH_DSP_POP
21db			 
21db			;		pop hl       ; 1 
21db d1					pop de       ; 2 
21dc			 
21dc cd b9 19				call forth_push_numhl 
21df eb					ex de, hl 
21e0 cd b9 19				call forth_push_numhl 
21e3			 
21e3					 
21e3 eb					ex de, hl 
21e4			 
21e4 cd b9 19				call forth_push_numhl 
21e7 eb					ex de, hl 
21e8 cd b9 19				call forth_push_numhl 
21eb			 
21eb			 
21eb					NEXTW 
21eb c3 22 1d			jp macro_next 
21ee				endm 
# End of macro NEXTW
21ee			.DROP2: 
21ee				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
21ee 1d				db WORD_SYS_CORE+OPCODE_DROP2             
21ef 1d 22			dw .SWAP2            
21f1 06				db 5 + 1 
21f2 .. 00			db "2DROP",0              
21f8				endm 
# End of macro CWHEAD
21f8			; | 2DROP ( w w -- )    Double drop | DONE 
21f8					if DEBUG_FORTH_WORDS_KEY 
21f8						DMARK "2DR" 
21f8 f5				push af  
21f9 3a 0d 22			ld a, (.dmark)  
21fc 32 7a ee			ld (debug_mark),a  
21ff 3a 0e 22			ld a, (.dmark+1)  
2202 32 7b ee			ld (debug_mark+1),a  
2205 3a 0f 22			ld a, (.dmark+2)  
2208 32 7c ee			ld (debug_mark+2),a  
220b 18 03			jr .pastdmark  
220d ..			.dmark: db "2DR"  
2210 f1			.pastdmark: pop af  
2211			endm  
# End of macro DMARK
2211						CALLMONITOR 
2211 cd 2c 14			call break_point_state  
2214				endm  
# End of macro CALLMONITOR
2214					endif 
2214					FORTH_DSP_POP 
2214 cd 68 1c			call macro_forth_dsp_pop 
2217				endm 
# End of macro FORTH_DSP_POP
2217					FORTH_DSP_POP 
2217 cd 68 1c			call macro_forth_dsp_pop 
221a				endm 
# End of macro FORTH_DSP_POP
221a					NEXTW 
221a c3 22 1d			jp macro_next 
221d				endm 
# End of macro NEXTW
221d			.SWAP2: 
221d				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
221d 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
221e 46 22			dw .AT            
2220 06				db 5 + 1 
2221 .. 00			db "2SWAP",0              
2227				endm 
# End of macro CWHEAD
2227			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2227					if DEBUG_FORTH_WORDS_KEY 
2227						DMARK "2SW" 
2227 f5				push af  
2228 3a 3c 22			ld a, (.dmark)  
222b 32 7a ee			ld (debug_mark),a  
222e 3a 3d 22			ld a, (.dmark+1)  
2231 32 7b ee			ld (debug_mark+1),a  
2234 3a 3e 22			ld a, (.dmark+2)  
2237 32 7c ee			ld (debug_mark+2),a  
223a 18 03			jr .pastdmark  
223c ..			.dmark: db "2SW"  
223f f1			.pastdmark: pop af  
2240			endm  
# End of macro DMARK
2240						CALLMONITOR 
2240 cd 2c 14			call break_point_state  
2243				endm  
# End of macro CALLMONITOR
2243					endif 
2243					NEXTW 
2243 c3 22 1d			jp macro_next 
2246				endm 
# End of macro NEXTW
2246			.AT: 
2246				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2246 1f				db WORD_SYS_CORE+OPCODE_AT             
2247 78 22			dw .CAT            
2249 02				db 1 + 1 
224a .. 00			db "@",0              
224c				endm 
# End of macro CWHEAD
224c			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
224c			 
224c					if DEBUG_FORTH_WORDS_KEY 
224c						DMARK "AT." 
224c f5				push af  
224d 3a 61 22			ld a, (.dmark)  
2250 32 7a ee			ld (debug_mark),a  
2253 3a 62 22			ld a, (.dmark+1)  
2256 32 7b ee			ld (debug_mark+1),a  
2259 3a 63 22			ld a, (.dmark+2)  
225c 32 7c ee			ld (debug_mark+2),a  
225f 18 03			jr .pastdmark  
2261 ..			.dmark: db "AT."  
2264 f1			.pastdmark: pop af  
2265			endm  
# End of macro DMARK
2265						CALLMONITOR 
2265 cd 2c 14			call break_point_state  
2268				endm  
# End of macro CALLMONITOR
2268					endif 
2268			.getbyteat:	 
2268					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2268 cd b0 1b			call macro_dsp_valuehl 
226b				endm 
# End of macro FORTH_DSP_VALUEHL
226b					 
226b			;		push hl 
226b				 
226b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
226b cd 68 1c			call macro_forth_dsp_pop 
226e				endm 
# End of macro FORTH_DSP_POP
226e			 
226e			;		pop hl 
226e			 
226e 7e					ld a, (hl) 
226f			 
226f 6f					ld l, a 
2270 26 00				ld h, 0 
2272 cd b9 19				call forth_push_numhl 
2275			 
2275					NEXTW 
2275 c3 22 1d			jp macro_next 
2278				endm 
# End of macro NEXTW
2278			.CAT: 
2278				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2278 20				db WORD_SYS_CORE+OPCODE_CAT             
2279 a1 22			dw .BANG            
227b 03				db 2 + 1 
227c .. 00			db "C@",0              
227f				endm 
# End of macro CWHEAD
227f			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
227f					if DEBUG_FORTH_WORDS_KEY 
227f						DMARK "CAA" 
227f f5				push af  
2280 3a 94 22			ld a, (.dmark)  
2283 32 7a ee			ld (debug_mark),a  
2286 3a 95 22			ld a, (.dmark+1)  
2289 32 7b ee			ld (debug_mark+1),a  
228c 3a 96 22			ld a, (.dmark+2)  
228f 32 7c ee			ld (debug_mark+2),a  
2292 18 03			jr .pastdmark  
2294 ..			.dmark: db "CAA"  
2297 f1			.pastdmark: pop af  
2298			endm  
# End of macro DMARK
2298						CALLMONITOR 
2298 cd 2c 14			call break_point_state  
229b				endm  
# End of macro CALLMONITOR
229b					endif 
229b c3 68 22				jp .getbyteat 
229e					NEXTW 
229e c3 22 1d			jp macro_next 
22a1				endm 
# End of macro NEXTW
22a1			.BANG: 
22a1				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
22a1 21				db WORD_SYS_CORE+OPCODE_BANG             
22a2 d7 22			dw .CBANG            
22a4 02				db 1 + 1 
22a5 .. 00			db "!",0              
22a7				endm 
# End of macro CWHEAD
22a7			; | ! ( x w -- ) Store x at address w      | DONE 
22a7					if DEBUG_FORTH_WORDS_KEY 
22a7						DMARK "BNG" 
22a7 f5				push af  
22a8 3a bc 22			ld a, (.dmark)  
22ab 32 7a ee			ld (debug_mark),a  
22ae 3a bd 22			ld a, (.dmark+1)  
22b1 32 7b ee			ld (debug_mark+1),a  
22b4 3a be 22			ld a, (.dmark+2)  
22b7 32 7c ee			ld (debug_mark+2),a  
22ba 18 03			jr .pastdmark  
22bc ..			.dmark: db "BNG"  
22bf f1			.pastdmark: pop af  
22c0			endm  
# End of macro DMARK
22c0						CALLMONITOR 
22c0 cd 2c 14			call break_point_state  
22c3				endm  
# End of macro CALLMONITOR
22c3					endif 
22c3			 
22c3			.storebyteat:		 
22c3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22c3 cd b0 1b			call macro_dsp_valuehl 
22c6				endm 
# End of macro FORTH_DSP_VALUEHL
22c6					 
22c6 e5					push hl 
22c7				 
22c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
22c7 cd 68 1c			call macro_forth_dsp_pop 
22ca				endm 
# End of macro FORTH_DSP_POP
22ca			 
22ca					; get byte to poke 
22ca			 
22ca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22ca cd b0 1b			call macro_dsp_valuehl 
22cd				endm 
# End of macro FORTH_DSP_VALUEHL
22cd e5					push hl 
22ce			 
22ce			 
22ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
22ce cd 68 1c			call macro_forth_dsp_pop 
22d1				endm 
# End of macro FORTH_DSP_POP
22d1			 
22d1			 
22d1 d1					pop de 
22d2 e1					pop hl 
22d3			 
22d3 73					ld (hl),e 
22d4			 
22d4			 
22d4					NEXTW 
22d4 c3 22 1d			jp macro_next 
22d7				endm 
# End of macro NEXTW
22d7			.CBANG: 
22d7				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
22d7 22				db WORD_SYS_CORE+OPCODE_CBANG             
22d8 00 23			dw .SCALL            
22da 03				db 2 + 1 
22db .. 00			db "C!",0              
22de				endm 
# End of macro CWHEAD
22de			; | C!  ( x w -- ) Store x at address w  | DONE 
22de					if DEBUG_FORTH_WORDS_KEY 
22de						DMARK "CBA" 
22de f5				push af  
22df 3a f3 22			ld a, (.dmark)  
22e2 32 7a ee			ld (debug_mark),a  
22e5 3a f4 22			ld a, (.dmark+1)  
22e8 32 7b ee			ld (debug_mark+1),a  
22eb 3a f5 22			ld a, (.dmark+2)  
22ee 32 7c ee			ld (debug_mark+2),a  
22f1 18 03			jr .pastdmark  
22f3 ..			.dmark: db "CBA"  
22f6 f1			.pastdmark: pop af  
22f7			endm  
# End of macro DMARK
22f7						CALLMONITOR 
22f7 cd 2c 14			call break_point_state  
22fa				endm  
# End of macro CALLMONITOR
22fa					endif 
22fa c3 c3 22				jp .storebyteat 
22fd					NEXTW 
22fd c3 22 1d			jp macro_next 
2300				endm 
# End of macro NEXTW
2300			.SCALL: 
2300				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2300 23				db WORD_SYS_CORE+OPCODE_SCALL             
2301 34 23			dw .DEPTH            
2303 05				db 4 + 1 
2304 .. 00			db "CALL",0              
2309				endm 
# End of macro CWHEAD
2309			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2309					if DEBUG_FORTH_WORDS_KEY 
2309						DMARK "CLL" 
2309 f5				push af  
230a 3a 1e 23			ld a, (.dmark)  
230d 32 7a ee			ld (debug_mark),a  
2310 3a 1f 23			ld a, (.dmark+1)  
2313 32 7b ee			ld (debug_mark+1),a  
2316 3a 20 23			ld a, (.dmark+2)  
2319 32 7c ee			ld (debug_mark+2),a  
231c 18 03			jr .pastdmark  
231e ..			.dmark: db "CLL"  
2321 f1			.pastdmark: pop af  
2322			endm  
# End of macro DMARK
2322						CALLMONITOR 
2322 cd 2c 14			call break_point_state  
2325				endm  
# End of macro CALLMONITOR
2325					endif 
2325			 
2325					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2325 cd b0 1b			call macro_dsp_valuehl 
2328				endm 
# End of macro FORTH_DSP_VALUEHL
2328			 
2328			;		push hl 
2328			 
2328					; destroy value TOS 
2328			 
2328					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2328 cd 68 1c			call macro_forth_dsp_pop 
232b				endm 
# End of macro FORTH_DSP_POP
232b			 
232b						 
232b			;		pop hl 
232b			 
232b					; how to do a call with hl???? save SP? 
232b cd cb 1c				call forth_call_hl 
232e			 
232e			 
232e					; TODO push value back onto stack for another op etc 
232e			 
232e cd b9 19				call forth_push_numhl 
2331					NEXTW 
2331 c3 22 1d			jp macro_next 
2334				endm 
# End of macro NEXTW
2334			.DEPTH: 
2334				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2334 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2335 71 23			dw .OVER            
2337 06				db 5 + 1 
2338 .. 00			db "DEPTH",0              
233e				endm 
# End of macro CWHEAD
233e			; | DEPTH ( -- u ) Push count of stack | DONE 
233e					; take current TOS and remove from base value div by two to get count 
233e					if DEBUG_FORTH_WORDS_KEY 
233e						DMARK "DEP" 
233e f5				push af  
233f 3a 53 23			ld a, (.dmark)  
2342 32 7a ee			ld (debug_mark),a  
2345 3a 54 23			ld a, (.dmark+1)  
2348 32 7b ee			ld (debug_mark+1),a  
234b 3a 55 23			ld a, (.dmark+2)  
234e 32 7c ee			ld (debug_mark+2),a  
2351 18 03			jr .pastdmark  
2353 ..			.dmark: db "DEP"  
2356 f1			.pastdmark: pop af  
2357			endm  
# End of macro DMARK
2357						CALLMONITOR 
2357 cd 2c 14			call break_point_state  
235a				endm  
# End of macro CALLMONITOR
235a					endif 
235a			 
235a			 
235a 2a 0d eb			ld hl, (cli_data_sp) 
235d 11 c7 e8			ld de, cli_data_stack 
2360 ed 52			sbc hl,de 
2362				 
2362				; div by size of stack item 
2362			 
2362 5d				ld e,l 
2363 0e 03			ld c, 3 
2365 cd 42 0b			call Div8 
2368			 
2368 6f				ld l,a 
2369 26 00			ld h,0 
236b			 
236b				;srl h 
236b				;rr l 
236b			 
236b cd b9 19				call forth_push_numhl 
236e					NEXTW 
236e c3 22 1d			jp macro_next 
2371				endm 
# End of macro NEXTW
2371			.OVER: 
2371				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2371 42				db WORD_SYS_CORE+46             
2372 b8 23			dw .PAUSE            
2374 05				db 4 + 1 
2375 .. 00			db "OVER",0              
237a				endm 
# End of macro CWHEAD
237a			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
237a					if DEBUG_FORTH_WORDS_KEY 
237a						DMARK "OVR" 
237a f5				push af  
237b 3a 8f 23			ld a, (.dmark)  
237e 32 7a ee			ld (debug_mark),a  
2381 3a 90 23			ld a, (.dmark+1)  
2384 32 7b ee			ld (debug_mark+1),a  
2387 3a 91 23			ld a, (.dmark+2)  
238a 32 7c ee			ld (debug_mark+2),a  
238d 18 03			jr .pastdmark  
238f ..			.dmark: db "OVR"  
2392 f1			.pastdmark: pop af  
2393			endm  
# End of macro DMARK
2393						CALLMONITOR 
2393 cd 2c 14			call break_point_state  
2396				endm  
# End of macro CALLMONITOR
2396					endif 
2396			 
2396					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2396 cd b0 1b			call macro_dsp_valuehl 
2399				endm 
# End of macro FORTH_DSP_VALUEHL
2399 e5					push hl    ; n2 
239a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
239a cd 68 1c			call macro_forth_dsp_pop 
239d				endm 
# End of macro FORTH_DSP_POP
239d			 
239d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
239d cd b0 1b			call macro_dsp_valuehl 
23a0				endm 
# End of macro FORTH_DSP_VALUEHL
23a0 e5					push hl    ; n1 
23a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23a1 cd 68 1c			call macro_forth_dsp_pop 
23a4				endm 
# End of macro FORTH_DSP_POP
23a4			 
23a4 d1					pop de     ; n1 
23a5 e1					pop hl     ; n2 
23a6			 
23a6 d5					push de 
23a7 e5					push hl 
23a8 d5					push de 
23a9			 
23a9					; push back  
23a9			 
23a9 e1					pop hl 
23aa cd b9 19				call forth_push_numhl 
23ad e1					pop hl 
23ae cd b9 19				call forth_push_numhl 
23b1 e1					pop hl 
23b2 cd b9 19				call forth_push_numhl 
23b5					NEXTW 
23b5 c3 22 1d			jp macro_next 
23b8				endm 
# End of macro NEXTW
23b8			 
23b8			.PAUSE: 
23b8				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
23b8 43				db WORD_SYS_CORE+47             
23b9 ed 23			dw .PAUSES            
23bb 08				db 7 + 1 
23bc .. 00			db "PAUSEMS",0              
23c4				endm 
# End of macro CWHEAD
23c4			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
23c4					if DEBUG_FORTH_WORDS_KEY 
23c4						DMARK "PMS" 
23c4 f5				push af  
23c5 3a d9 23			ld a, (.dmark)  
23c8 32 7a ee			ld (debug_mark),a  
23cb 3a da 23			ld a, (.dmark+1)  
23ce 32 7b ee			ld (debug_mark+1),a  
23d1 3a db 23			ld a, (.dmark+2)  
23d4 32 7c ee			ld (debug_mark+2),a  
23d7 18 03			jr .pastdmark  
23d9 ..			.dmark: db "PMS"  
23dc f1			.pastdmark: pop af  
23dd			endm  
# End of macro DMARK
23dd						CALLMONITOR 
23dd cd 2c 14			call break_point_state  
23e0				endm  
# End of macro CALLMONITOR
23e0					endif 
23e0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23e0 cd b0 1b			call macro_dsp_valuehl 
23e3				endm 
# End of macro FORTH_DSP_VALUEHL
23e3			;		push hl    ; n2 
23e3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23e3 cd 68 1c			call macro_forth_dsp_pop 
23e6				endm 
# End of macro FORTH_DSP_POP
23e6			;		pop hl 
23e6			 
23e6 7d					ld a, l 
23e7 cd df 08				call aDelayInMS 
23ea				       NEXTW 
23ea c3 22 1d			jp macro_next 
23ed				endm 
# End of macro NEXTW
23ed			.PAUSES:  
23ed				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
23ed 44				db WORD_SYS_CORE+48             
23ee 5c 24			dw .ROT            
23f0 06				db 5 + 1 
23f1 .. 00			db "PAUSE",0              
23f7				endm 
# End of macro CWHEAD
23f7			; | PAUSE ( n -- )  Pause for n seconds | DONE 
23f7					if DEBUG_FORTH_WORDS_KEY 
23f7						DMARK "PAU" 
23f7 f5				push af  
23f8 3a 0c 24			ld a, (.dmark)  
23fb 32 7a ee			ld (debug_mark),a  
23fe 3a 0d 24			ld a, (.dmark+1)  
2401 32 7b ee			ld (debug_mark+1),a  
2404 3a 0e 24			ld a, (.dmark+2)  
2407 32 7c ee			ld (debug_mark+2),a  
240a 18 03			jr .pastdmark  
240c ..			.dmark: db "PAU"  
240f f1			.pastdmark: pop af  
2410			endm  
# End of macro DMARK
2410						CALLMONITOR 
2410 cd 2c 14			call break_point_state  
2413				endm  
# End of macro CALLMONITOR
2413					endif 
2413					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2413 cd b0 1b			call macro_dsp_valuehl 
2416				endm 
# End of macro FORTH_DSP_VALUEHL
2416			;		push hl    ; n2 
2416					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2416 cd 68 1c			call macro_forth_dsp_pop 
2419				endm 
# End of macro FORTH_DSP_POP
2419			;		pop hl 
2419 45					ld b, l 
241a					if DEBUG_FORTH_WORDS 
241a						DMARK "PAU" 
241a f5				push af  
241b 3a 2f 24			ld a, (.dmark)  
241e 32 7a ee			ld (debug_mark),a  
2421 3a 30 24			ld a, (.dmark+1)  
2424 32 7b ee			ld (debug_mark+1),a  
2427 3a 31 24			ld a, (.dmark+2)  
242a 32 7c ee			ld (debug_mark+2),a  
242d 18 03			jr .pastdmark  
242f ..			.dmark: db "PAU"  
2432 f1			.pastdmark: pop af  
2433			endm  
# End of macro DMARK
2433						CALLMONITOR 
2433 cd 2c 14			call break_point_state  
2436				endm  
# End of macro CALLMONITOR
2436					endif 
2436 c5			.pauses1:	push bc 
2437 cd fa 08				call delay1s 
243a c1					pop bc 
243b					if DEBUG_FORTH_WORDS 
243b						DMARK "PA1" 
243b f5				push af  
243c 3a 50 24			ld a, (.dmark)  
243f 32 7a ee			ld (debug_mark),a  
2442 3a 51 24			ld a, (.dmark+1)  
2445 32 7b ee			ld (debug_mark+1),a  
2448 3a 52 24			ld a, (.dmark+2)  
244b 32 7c ee			ld (debug_mark+2),a  
244e 18 03			jr .pastdmark  
2450 ..			.dmark: db "PA1"  
2453 f1			.pastdmark: pop af  
2454			endm  
# End of macro DMARK
2454						CALLMONITOR 
2454 cd 2c 14			call break_point_state  
2457				endm  
# End of macro CALLMONITOR
2457					endif 
2457 10 dd				djnz .pauses1 
2459			 
2459				       NEXTW 
2459 c3 22 1d			jp macro_next 
245c				endm 
# End of macro NEXTW
245c			.ROT: 
245c				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
245c 45				db WORD_SYS_CORE+49             
245d aa 24			dw .UWORDS            
245f 04				db 3 + 1 
2460 .. 00			db "ROT",0              
2464				endm 
# End of macro CWHEAD
2464			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2464					if DEBUG_FORTH_WORDS_KEY 
2464						DMARK "ROT" 
2464 f5				push af  
2465 3a 79 24			ld a, (.dmark)  
2468 32 7a ee			ld (debug_mark),a  
246b 3a 7a 24			ld a, (.dmark+1)  
246e 32 7b ee			ld (debug_mark+1),a  
2471 3a 7b 24			ld a, (.dmark+2)  
2474 32 7c ee			ld (debug_mark+2),a  
2477 18 03			jr .pastdmark  
2479 ..			.dmark: db "ROT"  
247c f1			.pastdmark: pop af  
247d			endm  
# End of macro DMARK
247d						CALLMONITOR 
247d cd 2c 14			call break_point_state  
2480				endm  
# End of macro CALLMONITOR
2480					endif 
2480			 
2480					FORTH_DSP_VALUEHL 
2480 cd b0 1b			call macro_dsp_valuehl 
2483				endm 
# End of macro FORTH_DSP_VALUEHL
2483 e5					push hl    ; u3  
2484			 
2484					FORTH_DSP_POP 
2484 cd 68 1c			call macro_forth_dsp_pop 
2487				endm 
# End of macro FORTH_DSP_POP
2487			   
2487					FORTH_DSP_VALUEHL 
2487 cd b0 1b			call macro_dsp_valuehl 
248a				endm 
# End of macro FORTH_DSP_VALUEHL
248a e5					push hl     ; u2 
248b			 
248b					FORTH_DSP_POP 
248b cd 68 1c			call macro_forth_dsp_pop 
248e				endm 
# End of macro FORTH_DSP_POP
248e			 
248e					FORTH_DSP_VALUEHL 
248e cd b0 1b			call macro_dsp_valuehl 
2491				endm 
# End of macro FORTH_DSP_VALUEHL
2491 e5					push hl     ; u1 
2492			 
2492					FORTH_DSP_POP 
2492 cd 68 1c			call macro_forth_dsp_pop 
2495				endm 
# End of macro FORTH_DSP_POP
2495			 
2495 c1					pop bc      ; u1 
2496 e1					pop hl      ; u2 
2497 d1					pop de      ; u3 
2498			 
2498			 
2498 c5					push bc 
2499 d5					push de 
249a e5					push hl 
249b			 
249b			 
249b e1					pop hl 
249c cd b9 19				call forth_push_numhl 
249f			 
249f e1					pop hl 
24a0 cd b9 19				call forth_push_numhl 
24a3			 
24a3 e1					pop hl 
24a4 cd b9 19				call forth_push_numhl 
24a7					 
24a7			 
24a7			 
24a7			 
24a7			 
24a7			 
24a7				       NEXTW 
24a7 c3 22 1d			jp macro_next 
24aa				endm 
# End of macro NEXTW
24aa			 
24aa			.UWORDS: 
24aa				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
24aa 50				db WORD_SYS_CORE+60             
24ab 6c 25			dw .BP            
24ad 07				db 6 + 1 
24ae .. 00			db "UWORDS",0              
24b5				endm 
# End of macro CWHEAD
24b5			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
24b5			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
24b5			; | | Following the count are the individual words. 
24b5			; | | 
24b5			; | | e.g. UWORDS 
24b5			; | | BOX DIRLIST 2 
24b5			; | |  
24b5			; | | Can be used to save the words to storage via: 
24b5			; | | UWORDS $01 DO $01 APPEND LOOP 
24b5				if DEBUG_FORTH_WORDS_KEY 
24b5					DMARK "UWR" 
24b5 f5				push af  
24b6 3a ca 24			ld a, (.dmark)  
24b9 32 7a ee			ld (debug_mark),a  
24bc 3a cb 24			ld a, (.dmark+1)  
24bf 32 7b ee			ld (debug_mark+1),a  
24c2 3a cc 24			ld a, (.dmark+2)  
24c5 32 7c ee			ld (debug_mark+2),a  
24c8 18 03			jr .pastdmark  
24ca ..			.dmark: db "UWR"  
24cd f1			.pastdmark: pop af  
24ce			endm  
# End of macro DMARK
24ce					CALLMONITOR 
24ce cd 2c 14			call break_point_state  
24d1				endm  
# End of macro CALLMONITOR
24d1				endif 
24d1 21 96 58				ld hl, baseram 
24d4					;ld hl, baseusermem 
24d4 01 00 00				ld bc, 0    ; start a counter 
24d7			 
24d7				; skip dict stub 
24d7			 
24d7 cd 73 1e				call forth_tok_next 
24da			 
24da			 
24da			; while we have words to look for 
24da			 
24da 7e			.douscan:	ld a, (hl)      
24db				if DEBUG_FORTH_WORDS 
24db					DMARK "UWs" 
24db f5				push af  
24dc 3a f0 24			ld a, (.dmark)  
24df 32 7a ee			ld (debug_mark),a  
24e2 3a f1 24			ld a, (.dmark+1)  
24e5 32 7b ee			ld (debug_mark+1),a  
24e8 3a f2 24			ld a, (.dmark+2)  
24eb 32 7c ee			ld (debug_mark+2),a  
24ee 18 03			jr .pastdmark  
24f0 ..			.dmark: db "UWs"  
24f3 f1			.pastdmark: pop af  
24f4			endm  
# End of macro DMARK
24f4					CALLMONITOR 
24f4 cd 2c 14			call break_point_state  
24f7				endm  
# End of macro CALLMONITOR
24f7				endif 
24f7 fe 00				cp WORD_SYS_END 
24f9 28 4d				jr z, .udone 
24fb fe 01				cp WORD_SYS_UWORD 
24fd 20 44				jr nz, .nuword 
24ff			 
24ff				if DEBUG_FORTH_WORDS 
24ff					DMARK "UWu" 
24ff f5				push af  
2500 3a 14 25			ld a, (.dmark)  
2503 32 7a ee			ld (debug_mark),a  
2506 3a 15 25			ld a, (.dmark+1)  
2509 32 7b ee			ld (debug_mark+1),a  
250c 3a 16 25			ld a, (.dmark+2)  
250f 32 7c ee			ld (debug_mark+2),a  
2512 18 03			jr .pastdmark  
2514 ..			.dmark: db "UWu"  
2517 f1			.pastdmark: pop af  
2518			endm  
# End of macro DMARK
2518					CALLMONITOR 
2518 cd 2c 14			call break_point_state  
251b				endm  
# End of macro CALLMONITOR
251b				endif 
251b					; we have a uword so push its name to the stack 
251b			 
251b e5				   	push hl  ; save so we can move to next dict block 
251c			 
251c					; skip opcode 
251c 23					inc hl  
251d					; skip next ptr 
251d 23					inc hl  
251e 23					inc hl 
251f					; skip len 
251f 23					inc hl 
2520				if DEBUG_FORTH_WORDS 
2520					DMARK "UWt" 
2520 f5				push af  
2521 3a 35 25			ld a, (.dmark)  
2524 32 7a ee			ld (debug_mark),a  
2527 3a 36 25			ld a, (.dmark+1)  
252a 32 7b ee			ld (debug_mark+1),a  
252d 3a 37 25			ld a, (.dmark+2)  
2530 32 7c ee			ld (debug_mark+2),a  
2533 18 03			jr .pastdmark  
2535 ..			.dmark: db "UWt"  
2538 f1			.pastdmark: pop af  
2539			endm  
# End of macro DMARK
2539					CALLMONITOR 
2539 cd 2c 14			call break_point_state  
253c				endm  
# End of macro CALLMONITOR
253c				endif 
253c 03					inc bc 
253d			 
253d c5					push bc 
253e cd 27 1a				call forth_push_str 
2541 c1					pop bc 
2542			 
2542 e1					pop hl 	 
2543			 
2543 cd 73 1e		.nuword:	call forth_tok_next 
2546 18 92				jr .douscan  
2548			 
2548			.udone:		 ; push count of uwords found 
2548 c5					push bc 
2549 e1					pop hl 
254a			 
254a				if DEBUG_FORTH_WORDS 
254a					DMARK "UWc" 
254a f5				push af  
254b 3a 5f 25			ld a, (.dmark)  
254e 32 7a ee			ld (debug_mark),a  
2551 3a 60 25			ld a, (.dmark+1)  
2554 32 7b ee			ld (debug_mark+1),a  
2557 3a 61 25			ld a, (.dmark+2)  
255a 32 7c ee			ld (debug_mark+2),a  
255d 18 03			jr .pastdmark  
255f ..			.dmark: db "UWc"  
2562 f1			.pastdmark: pop af  
2563			endm  
# End of macro DMARK
2563					CALLMONITOR 
2563 cd 2c 14			call break_point_state  
2566				endm  
# End of macro CALLMONITOR
2566				endif 
2566 cd b9 19				call forth_push_numhl 
2569			 
2569			 
2569				       NEXTW 
2569 c3 22 1d			jp macro_next 
256c				endm 
# End of macro NEXTW
256c			 
256c			.BP: 
256c				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
256c 54				db WORD_SYS_CORE+64             
256d a2 25			dw .MONITOR            
256f 03				db 2 + 1 
2570 .. 00			db "BP",0              
2573				endm 
# End of macro CWHEAD
2573			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2573			; | | $00 Will enable the break points within specific code paths 
2573			; | | $01 Will disable break points 
2573			; | |  
2573			; | | By default break points are off. Either the above can be used to enable them 
2573			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2573			; | | and on release of the pressed key a message will be disaplayed to notify 
2573			; | | that break points are enabled. Pressing any key will then continue boot process. 
2573					; get byte count 
2573					if DEBUG_FORTH_WORDS_KEY 
2573						DMARK "BP." 
2573 f5				push af  
2574 3a 88 25			ld a, (.dmark)  
2577 32 7a ee			ld (debug_mark),a  
257a 3a 89 25			ld a, (.dmark+1)  
257d 32 7b ee			ld (debug_mark+1),a  
2580 3a 8a 25			ld a, (.dmark+2)  
2583 32 7c ee			ld (debug_mark+2),a  
2586 18 03			jr .pastdmark  
2588 ..			.dmark: db "BP."  
258b f1			.pastdmark: pop af  
258c			endm  
# End of macro DMARK
258c						CALLMONITOR 
258c cd 2c 14			call break_point_state  
258f				endm  
# End of macro CALLMONITOR
258f					endif 
258f			 
258f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
258f cd b0 1b			call macro_dsp_valuehl 
2592				endm 
# End of macro FORTH_DSP_VALUEHL
2592			 
2592			;		push hl 
2592			 
2592					; destroy value TOS 
2592			 
2592					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2592 cd 68 1c			call macro_forth_dsp_pop 
2595				endm 
# End of macro FORTH_DSP_POP
2595			 
2595			;		pop hl 
2595			 
2595 3e 00				ld a,0 
2597 bd					cp l 
2598 28 02				jr z, .bpset 
259a 3e 2a				ld a, '*' 
259c			 
259c 32 51 e3		.bpset:		ld (os_view_disable), a 
259f			 
259f			 
259f					NEXTW 
259f c3 22 1d			jp macro_next 
25a2				endm 
# End of macro NEXTW
25a2			 
25a2			 
25a2			.MONITOR: 
25a2				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
25a2 55				db WORD_SYS_CORE+65             
25a3 d5 25			dw .MALLOC            
25a5 08				db 7 + 1 
25a6 .. 00			db "MONITOR",0              
25ae				endm 
# End of macro CWHEAD
25ae			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
25ae			; | | At start the current various registers will be displayed with contents. 
25ae			; | | Top right corner will show the most recent debug marker seen. 
25ae			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
25ae			; | | and the return stack pointer (RSP). 
25ae			; | | Pressing: 
25ae			; | |    1 - Initial screen 
25ae			; | |    2 - Display a data dump of HL 
25ae			; | |    3 - Display a data dump of DE 
25ae			; | |    4 - Display a data dump of BC 
25ae			; | |    5 - Display a data dump of HL 
25ae			; | |    6 - Display a data dump of DSP 
25ae			; | |    7 - Display a data dump of RSP 
25ae			; | |    8 - Display a data dump of what is at DSP 
25ae			; | |    9 - Display a data dump of what is at RSP 
25ae			; | |    0 - Exit monitor and continue running. This will also enable break points 
25ae			; | |    * - Disable break points 
25ae			; | |    # - Enter traditional monitor mode 
25ae			; | | 
25ae			; | | Monitor Mode 
25ae			; | | ------------ 
25ae			; | | A prompt of '>' will be shown for various commands: 
25ae			; | |    D xxxx - Display a data dump starting from hex address xxxx 
25ae			; | |    C - Continue display a data dump from the last set address 
25ae			; | |    M xxxx - Set start of memory edit at address xx 
25ae			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
25ae			; | |    Q - Return to previous 
25ae					if DEBUG_FORTH_WORDS_KEY 
25ae						DMARK "MON" 
25ae f5				push af  
25af 3a c3 25			ld a, (.dmark)  
25b2 32 7a ee			ld (debug_mark),a  
25b5 3a c4 25			ld a, (.dmark+1)  
25b8 32 7b ee			ld (debug_mark+1),a  
25bb 3a c5 25			ld a, (.dmark+2)  
25be 32 7c ee			ld (debug_mark+2),a  
25c1 18 03			jr .pastdmark  
25c3 ..			.dmark: db "MON"  
25c6 f1			.pastdmark: pop af  
25c7			endm  
# End of macro DMARK
25c7						CALLMONITOR 
25c7 cd 2c 14			call break_point_state  
25ca				endm  
# End of macro CALLMONITOR
25ca					endif 
25ca 3e 00				ld a, 0 
25cc 32 51 e3				ld (os_view_disable), a 
25cf			 
25cf					CALLMONITOR 
25cf cd 2c 14			call break_point_state  
25d2				endm  
# End of macro CALLMONITOR
25d2			 
25d2			;	call monitor 
25d2			 
25d2					NEXTW 
25d2 c3 22 1d			jp macro_next 
25d5				endm 
# End of macro NEXTW
25d5			 
25d5			 
25d5			.MALLOC: 
25d5				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
25d5 56				db WORD_SYS_CORE+66             
25d6 fe 25			dw .MALLOC2            
25d8 06				db 5 + 1 
25d9 .. 00			db "ALLOT",0              
25df				endm 
# End of macro CWHEAD
25df			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
25df					if DEBUG_FORTH_WORDS_KEY 
25df						DMARK "ALL" 
25df f5				push af  
25e0 3a f4 25			ld a, (.dmark)  
25e3 32 7a ee			ld (debug_mark),a  
25e6 3a f5 25			ld a, (.dmark+1)  
25e9 32 7b ee			ld (debug_mark+1),a  
25ec 3a f6 25			ld a, (.dmark+2)  
25ef 32 7c ee			ld (debug_mark+2),a  
25f2 18 03			jr .pastdmark  
25f4 ..			.dmark: db "ALL"  
25f7 f1			.pastdmark: pop af  
25f8			endm  
# End of macro DMARK
25f8						CALLMONITOR 
25f8 cd 2c 14			call break_point_state  
25fb				endm  
# End of macro CALLMONITOR
25fb					endif 
25fb c3 25 26				jp .mallocc 
25fe			.MALLOC2: 
25fe				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
25fe 56				db WORD_SYS_CORE+66             
25ff 3c 26			dw .FREE            
2601 07				db 6 + 1 
2602 .. 00			db "MALLOC",0              
2609				endm 
# End of macro CWHEAD
2609			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2609					; get byte count 
2609					if DEBUG_FORTH_WORDS_KEY 
2609						DMARK "MAL" 
2609 f5				push af  
260a 3a 1e 26			ld a, (.dmark)  
260d 32 7a ee			ld (debug_mark),a  
2610 3a 1f 26			ld a, (.dmark+1)  
2613 32 7b ee			ld (debug_mark+1),a  
2616 3a 20 26			ld a, (.dmark+2)  
2619 32 7c ee			ld (debug_mark+2),a  
261c 18 03			jr .pastdmark  
261e ..			.dmark: db "MAL"  
2621 f1			.pastdmark: pop af  
2622			endm  
# End of macro DMARK
2622						CALLMONITOR 
2622 cd 2c 14			call break_point_state  
2625				endm  
# End of macro CALLMONITOR
2625					endif 
2625			.mallocc: 
2625					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2625 cd b0 1b			call macro_dsp_valuehl 
2628				endm 
# End of macro FORTH_DSP_VALUEHL
2628			 
2628			;		push hl 
2628			 
2628					; destroy value TOS 
2628			 
2628					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2628 cd 68 1c			call macro_forth_dsp_pop 
262b				endm 
# End of macro FORTH_DSP_POP
262b			 
262b			;		pop hl 
262b cd 79 10				call malloc 
262e				if DEBUG_FORTH_MALLOC_GUARD 
262e f5					push af 
262f cd db 0b				call ishlzero 
2632			;		ld a, l 
2632			;		add h 
2632			;		cp 0 
2632 f1					pop af 
2633					 
2633 cc f3 44				call z,malloc_error 
2636				endif 
2636			 
2636 cd b9 19				call forth_push_numhl 
2639					NEXTW 
2639 c3 22 1d			jp macro_next 
263c				endm 
# End of macro NEXTW
263c			 
263c			.FREE: 
263c				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
263c 57				db WORD_SYS_CORE+67             
263d 6d 26			dw .LIST            
263f 05				db 4 + 1 
2640 .. 00			db "FREE",0              
2645				endm 
# End of macro CWHEAD
2645			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2645					if DEBUG_FORTH_WORDS_KEY 
2645						DMARK "FRE" 
2645 f5				push af  
2646 3a 5a 26			ld a, (.dmark)  
2649 32 7a ee			ld (debug_mark),a  
264c 3a 5b 26			ld a, (.dmark+1)  
264f 32 7b ee			ld (debug_mark+1),a  
2652 3a 5c 26			ld a, (.dmark+2)  
2655 32 7c ee			ld (debug_mark+2),a  
2658 18 03			jr .pastdmark  
265a ..			.dmark: db "FRE"  
265d f1			.pastdmark: pop af  
265e			endm  
# End of macro DMARK
265e						CALLMONITOR 
265e cd 2c 14			call break_point_state  
2661				endm  
# End of macro CALLMONITOR
2661					endif 
2661					; get address 
2661			 
2661					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2661 cd b0 1b			call macro_dsp_valuehl 
2664				endm 
# End of macro FORTH_DSP_VALUEHL
2664			 
2664			;		push hl 
2664			 
2664					; destroy value TOS 
2664			 
2664					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2664 cd 68 1c			call macro_forth_dsp_pop 
2667				endm 
# End of macro FORTH_DSP_POP
2667			 
2667			;		pop hl 
2667			if FORTH_ENABLE_MALLOCFREE 
2667 cd 43 11				call free 
266a			endif 
266a					NEXTW 
266a c3 22 1d			jp macro_next 
266d				endm 
# End of macro NEXTW
266d			.LIST: 
266d				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
266d 5c				db WORD_SYS_CORE+72             
266e 30 28			dw .FORGET            
2670 05				db 4 + 1 
2671 .. 00			db "LIST",0              
2676				endm 
# End of macro CWHEAD
2676			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2676			; | | The quoted word must be in upper case. 
2676				if DEBUG_FORTH_WORDS_KEY 
2676					DMARK "LST" 
2676 f5				push af  
2677 3a 8b 26			ld a, (.dmark)  
267a 32 7a ee			ld (debug_mark),a  
267d 3a 8c 26			ld a, (.dmark+1)  
2680 32 7b ee			ld (debug_mark+1),a  
2683 3a 8d 26			ld a, (.dmark+2)  
2686 32 7c ee			ld (debug_mark+2),a  
2689 18 03			jr .pastdmark  
268b ..			.dmark: db "LST"  
268e f1			.pastdmark: pop af  
268f			endm  
# End of macro DMARK
268f					CALLMONITOR 
268f cd 2c 14			call break_point_state  
2692				endm  
# End of macro CALLMONITOR
2692				endif 
2692			 
2692					FORTH_DSP_VALUEHL 
2692 cd b0 1b			call macro_dsp_valuehl 
2695				endm 
# End of macro FORTH_DSP_VALUEHL
2695			 
2695 e5					push hl 
2696 c1					pop bc 
2697			 
2697			; Start format of scratch string 
2697			 
2697 21 60 e3				ld hl, scratch 
269a			 
269a 3e 3a				ld a, ':' 
269c 77					ld (hl),a 
269d 23					inc hl 
269e 3e 20				ld a, ' ' 
26a0 77					ld (hl), a 
26a1			 
26a1					; Get ptr to the word we need to look up 
26a1			 
26a1			;		FORTH_DSP_VALUEHL 
26a1					;v5 FORTH_DSP_VALUE 
26a1				; TODO type check 
26a1			;		inc hl    ; Skip type check  
26a1			;		push hl 
26a1			;		ex de, hl    ; put into DE 
26a1			 
26a1			 
26a1 21 96 58				ld hl, baseram 
26a4					;ld hl, baseusermem 
26a4			 
26a4 e5			push hl   ; sacreifical push 
26a5			 
26a5			.ldouscanm: 
26a5 e1				pop hl 
26a6			.ldouscan: 
26a6				if DEBUG_FORTH_WORDS 
26a6					DMARK "LSs" 
26a6 f5				push af  
26a7 3a bb 26			ld a, (.dmark)  
26aa 32 7a ee			ld (debug_mark),a  
26ad 3a bc 26			ld a, (.dmark+1)  
26b0 32 7b ee			ld (debug_mark+1),a  
26b3 3a bd 26			ld a, (.dmark+2)  
26b6 32 7c ee			ld (debug_mark+2),a  
26b9 18 03			jr .pastdmark  
26bb ..			.dmark: db "LSs"  
26be f1			.pastdmark: pop af  
26bf			endm  
# End of macro DMARK
26bf					CALLMONITOR 
26bf cd 2c 14			call break_point_state  
26c2				endm  
# End of macro CALLMONITOR
26c2				endif 
26c2				; skip dict stub 
26c2 cd 73 1e				call forth_tok_next 
26c5			 
26c5			 
26c5			; while we have words to look for 
26c5			 
26c5 7e				ld a, (hl)      
26c6				if DEBUG_FORTH_WORDS 
26c6					DMARK "LSk" 
26c6 f5				push af  
26c7 3a db 26			ld a, (.dmark)  
26ca 32 7a ee			ld (debug_mark),a  
26cd 3a dc 26			ld a, (.dmark+1)  
26d0 32 7b ee			ld (debug_mark+1),a  
26d3 3a dd 26			ld a, (.dmark+2)  
26d6 32 7c ee			ld (debug_mark+2),a  
26d9 18 03			jr .pastdmark  
26db ..			.dmark: db "LSk"  
26de f1			.pastdmark: pop af  
26df			endm  
# End of macro DMARK
26df					CALLMONITOR 
26df cd 2c 14			call break_point_state  
26e2				endm  
# End of macro CALLMONITOR
26e2				endif 
26e2 fe 00				cp WORD_SYS_END 
26e4 ca 17 28				jp z, .lunotfound 
26e7 fe 01				cp WORD_SYS_UWORD 
26e9 c2 a6 26				jp nz, .ldouscan 
26ec			 
26ec				if DEBUG_FORTH_WORDS 
26ec					DMARK "LSu" 
26ec f5				push af  
26ed 3a 01 27			ld a, (.dmark)  
26f0 32 7a ee			ld (debug_mark),a  
26f3 3a 02 27			ld a, (.dmark+1)  
26f6 32 7b ee			ld (debug_mark+1),a  
26f9 3a 03 27			ld a, (.dmark+2)  
26fc 32 7c ee			ld (debug_mark+2),a  
26ff 18 03			jr .pastdmark  
2701 ..			.dmark: db "LSu"  
2704 f1			.pastdmark: pop af  
2705			endm  
# End of macro DMARK
2705					CALLMONITOR 
2705 cd 2c 14			call break_point_state  
2708				endm  
# End of macro CALLMONITOR
2708				endif 
2708			 
2708					; found a uword but is it the one we want... 
2708			 
2708 c5					push bc     ; uword to find is on bc 
2709 d1					pop de 
270a			 
270a e5					push hl  ; to save the ptr 
270b			 
270b					; skip opcode 
270b 23					inc hl  
270c					; skip next ptr 
270c 23					inc hl  
270d 23					inc hl 
270e					; skip len 
270e 23					inc hl 
270f			 
270f				if DEBUG_FORTH_WORDS 
270f					DMARK "LSc" 
270f f5				push af  
2710 3a 24 27			ld a, (.dmark)  
2713 32 7a ee			ld (debug_mark),a  
2716 3a 25 27			ld a, (.dmark+1)  
2719 32 7b ee			ld (debug_mark+1),a  
271c 3a 26 27			ld a, (.dmark+2)  
271f 32 7c ee			ld (debug_mark+2),a  
2722 18 03			jr .pastdmark  
2724 ..			.dmark: db "LSc"  
2727 f1			.pastdmark: pop af  
2728			endm  
# End of macro DMARK
2728					CALLMONITOR 
2728 cd 2c 14			call break_point_state  
272b				endm  
# End of macro CALLMONITOR
272b				endif 
272b cd 48 10				call strcmp 
272e c2 a5 26				jp nz, .ldouscanm 
2731				 
2731			 
2731			 
2731					; we have a uword so push its name to the stack 
2731			 
2731			;	   	push hl  ; save so we can move to next dict block 
2731 e1			pop hl 
2732			 
2732				if DEBUG_FORTH_WORDS 
2732					DMARK "LSm" 
2732 f5				push af  
2733 3a 47 27			ld a, (.dmark)  
2736 32 7a ee			ld (debug_mark),a  
2739 3a 48 27			ld a, (.dmark+1)  
273c 32 7b ee			ld (debug_mark+1),a  
273f 3a 49 27			ld a, (.dmark+2)  
2742 32 7c ee			ld (debug_mark+2),a  
2745 18 03			jr .pastdmark  
2747 ..			.dmark: db "LSm"  
274a f1			.pastdmark: pop af  
274b			endm  
# End of macro DMARK
274b					CALLMONITOR 
274b cd 2c 14			call break_point_state  
274e				endm  
# End of macro CALLMONITOR
274e				endif 
274e			 
274e					; skip opcode 
274e 23					inc hl  
274f					; skip next ptr 
274f 23					inc hl  
2750 23					inc hl 
2751					; skip len 
2751 7e					ld a, (hl)   ; save length to add 
2752				if DEBUG_FORTH_WORDS 
2752					DMARK "LS2" 
2752 f5				push af  
2753 3a 67 27			ld a, (.dmark)  
2756 32 7a ee			ld (debug_mark),a  
2759 3a 68 27			ld a, (.dmark+1)  
275c 32 7b ee			ld (debug_mark+1),a  
275f 3a 69 27			ld a, (.dmark+2)  
2762 32 7c ee			ld (debug_mark+2),a  
2765 18 03			jr .pastdmark  
2767 ..			.dmark: db "LS2"  
276a f1			.pastdmark: pop af  
276b			endm  
# End of macro DMARK
276b					CALLMONITOR 
276b cd 2c 14			call break_point_state  
276e				endm  
# End of macro CALLMONITOR
276e				endif 
276e			 
276e					; save this location 
276e				 
276e e5					push hl 
276f			 
276f 23					inc hl 
2770 11 62 e3				ld de, scratch+2 
2773 4f					ld c, a 
2774 06 00				ld b, 0 
2776			 
2776				if DEBUG_FORTH_WORDS 
2776					DMARK "LSn" 
2776 f5				push af  
2777 3a 8b 27			ld a, (.dmark)  
277a 32 7a ee			ld (debug_mark),a  
277d 3a 8c 27			ld a, (.dmark+1)  
2780 32 7b ee			ld (debug_mark+1),a  
2783 3a 8d 27			ld a, (.dmark+2)  
2786 32 7c ee			ld (debug_mark+2),a  
2789 18 03			jr .pastdmark  
278b ..			.dmark: db "LSn"  
278e f1			.pastdmark: pop af  
278f			endm  
# End of macro DMARK
278f					CALLMONITOR 
278f cd 2c 14			call break_point_state  
2792				endm  
# End of macro CALLMONITOR
2792				endif 
2792			 
2792					; copy uword name to scratch 
2792			 
2792 ed b0				ldir 
2794			 
2794 1b					dec de 
2795 3e 20				ld a, ' '    ; change null to space 
2797 12					ld (de), a 
2798			 
2798 13					inc de 
2799			 
2799 d5					push de 
279a c1					pop bc     ; move scratch pointer to end of word name and save it 
279b			 
279b e1					pop hl 
279c 7e					ld a, (hl) 
279d					;inc hl 
279d					; skip word string 
279d cd b2 0b				call addatohl 
27a0			 
27a0 23					inc hl 
27a1			 
27a1				if DEBUG_FORTH_WORDS 
27a1					DMARK "LS3" 
27a1 f5				push af  
27a2 3a b6 27			ld a, (.dmark)  
27a5 32 7a ee			ld (debug_mark),a  
27a8 3a b7 27			ld a, (.dmark+1)  
27ab 32 7b ee			ld (debug_mark+1),a  
27ae 3a b8 27			ld a, (.dmark+2)  
27b1 32 7c ee			ld (debug_mark+2),a  
27b4 18 03			jr .pastdmark  
27b6 ..			.dmark: db "LS3"  
27b9 f1			.pastdmark: pop af  
27ba			endm  
# End of macro DMARK
27ba					CALLMONITOR 
27ba cd 2c 14			call break_point_state  
27bd				endm  
# End of macro CALLMONITOR
27bd				endif 
27bd					; should now be at the start of the machine code to setup the eval of the uword 
27bd					; now locate the ptr to the string defintion 
27bd			 
27bd					; skip ld hl, 
27bd					; then load the ptr 
27bd			 
27bd 23					inc hl 
27be 5e					ld e, (hl) 
27bf 23					inc hl 
27c0 56					ld d, (hl) 
27c1 eb					ex de, hl 
27c2			 
27c2			 
27c2				if DEBUG_FORTH_WORDS 
27c2					DMARK "LSt" 
27c2 f5				push af  
27c3 3a d7 27			ld a, (.dmark)  
27c6 32 7a ee			ld (debug_mark),a  
27c9 3a d8 27			ld a, (.dmark+1)  
27cc 32 7b ee			ld (debug_mark+1),a  
27cf 3a d9 27			ld a, (.dmark+2)  
27d2 32 7c ee			ld (debug_mark+2),a  
27d5 18 03			jr .pastdmark  
27d7 ..			.dmark: db "LSt"  
27da f1			.pastdmark: pop af  
27db			endm  
# End of macro DMARK
27db					CALLMONITOR 
27db cd 2c 14			call break_point_state  
27de				endm  
# End of macro CALLMONITOR
27de				endif 
27de			 
27de			; cant push right now due to tokenised strings  
27de			 
27de			; get the destination of where to copy this definition to. 
27de			 
27de c5					push bc 
27df d1					pop de 
27e0			 
27e0 7e			.listl:         ld a,(hl) 
27e1 fe 00				cp 0 
27e3 28 09				jr z, .lreplsp     ; replace zero with space 
27e5 fe 7f				cp FORTH_END_BUFFER 
27e7 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
27e9				 
27e9					; just copy this char as is then 
27e9			 
27e9 12					ld (de), a 
27ea			 
27ea 23			.listnxt:	inc hl 
27eb 13					inc de 
27ec 18 f2				jr .listl 
27ee			 
27ee 3e 20		.lreplsp:	ld a,' ' 
27f0 12					ld (de), a 
27f1 18 f7				jr .listnxt 
27f3			 
27f3			; close up uword def 
27f3			 
27f3			.listdone: 
27f3 3e 00				ld a, 0 
27f5 12					ld (de), a 
27f6			 
27f6			; now have def so clean up and push to stack 
27f6			 
27f6 21 60 e3				ld hl, scratch 
27f9				if DEBUG_FORTH_WORDS 
27f9					DMARK "Ltp" 
27f9 f5				push af  
27fa 3a 0e 28			ld a, (.dmark)  
27fd 32 7a ee			ld (debug_mark),a  
2800 3a 0f 28			ld a, (.dmark+1)  
2803 32 7b ee			ld (debug_mark+1),a  
2806 3a 10 28			ld a, (.dmark+2)  
2809 32 7c ee			ld (debug_mark+2),a  
280c 18 03			jr .pastdmark  
280e ..			.dmark: db "Ltp"  
2811 f1			.pastdmark: pop af  
2812			endm  
# End of macro DMARK
2812					CALLMONITOR 
2812 cd 2c 14			call break_point_state  
2815				endm  
# End of macro CALLMONITOR
2815				endif 
2815			 
2815 18 06			jr .listpush 
2817			 
2817			;.lnuword:	pop hl 
2817			;		call forth_tok_next 
2817			;		jp .ldouscan  
2817			 
2817			.lunotfound:		  
2817			 
2817			 
2817					 
2817					FORTH_DSP_POP 
2817 cd 68 1c			call macro_forth_dsp_pop 
281a				endm 
# End of macro FORTH_DSP_POP
281a 21 23 28				ld hl, .luno 
281d						 
281d			 
281d			.listpush: 
281d cd 27 1a				call forth_push_str 
2820			 
2820			 
2820			 
2820					NEXTW 
2820 c3 22 1d			jp macro_next 
2823				endm 
# End of macro NEXTW
2823			 
2823 .. 00		.luno:    db "Not found",0 
282d			 
282d			 
282d			 
282d			 
282d			 
282d			;		push hl   ; save pointer to start of uword def string 
282d			; 
282d			;; look for FORTH_EOL_LINE 
282d			;		ld a, FORTH_END_BUFFER 
282d			;		call strlent 
282d			; 
282d			;		inc hl		 ; space for coln def 
282d			;		inc hl 
282d			;		inc hl          ; space for terms 
282d			;		inc hl 
282d			; 
282d			;		ld a, 20   ; TODO get actual length 
282d			;		call addatohl    ; include a random amount of room for the uword name 
282d			; 
282d			;		 
282d			;	if DEBUG_FORTH_WORDS 
282d			;		DMARK "Lt1" 
282d			;		CALLMONITOR 
282d			;	endif 
282d			;		 
282d			; 
282d			;; malloc space for the string because we cant change it 
282d			; 
282d			;		call malloc 
282d			;	if DEBUG_FORTH_MALLOC_GUARD 
282d			;		push af 
282d			;		call ishlzero 
282d			;		pop af 
282d			;		 
282d			;		call z,malloc_error 
282d			;	endif 
282d			; 
282d			;	if DEBUG_FORTH_WORDS 
282d			;		DMARK "Lt2" 
282d			;		CALLMONITOR 
282d			;	endif 
282d			;		pop de 
282d			;		push hl    ; push the malloc to release later 
282d			;		push hl   ;  push back a copy for the later stack push 
282d			;		 
282d			;; copy the string swapping out the zero terms for spaces 
282d			; 
282d			;		; de has our source 
282d			;		; hl has our dest 
282d			; 
282d			;; add the coln def 
282d			; 
282d			;		ld a, ':' 
282d			;		ld (hl), a 
282d			;		inc hl 
282d			;		ld a, ' ' 
282d			;		ld (hl), a 
282d			;		inc hl 
282d			; 
282d			;; add the uname word 
282d			;		push de   ; save our string for now 
282d			;		ex de, hl 
282d			; 
282d			;		FORTH_DSP_VALUE 
282d			;		;v5 FORTH_DSP_VALUE 
282d			; 
282d			;		inc hl   ; skip type but we know by now this is OK 
282d			; 
282d			;.luword:	ld a,(hl) 
282d			;		cp 0 
282d			;		jr z, .luword2 
282d			;		ld (de), a 
282d			;		inc de 
282d			;		inc hl 
282d			;		jr .luword 
282d			; 
282d			;.luword2:	ld a, ' ' 
282d			;		ld (de), a 
282d			;;		inc hl 
282d			;;		inc de 
282d			;;		ld (de), a 
282d			;;		inc hl 
282d			;		inc de 
282d			; 
282d			;		ex de, hl 
282d			;		pop de 
282d			;		 
282d			;		 
282d			; 
282d			;; detoken that string and copy it 
282d			; 
282d			;	if DEBUG_FORTH_WORDS 
282d			;		DMARK "Lt2" 
282d			;		CALLMONITOR 
282d			;	endif 
282d			;.ldetok:	ld a, (de) 
282d			;		cp FORTH_END_BUFFER 
282d			;		jr z, .ldetokend 
282d			;		; swap out any zero term for space 
282d			;		cp 0 
282d			;		jr nz, .ldetoknext 
282d			;		ld a, ' ' 
282d			; 
282d			;	if DEBUG_FORTH_WORDS 
282d			;		DMARK "LtS" 
282d			;		CALLMONITOR 
282d			;	endif 
282d			;.ldetoknext:	ld (hl), a 
282d			;		inc de 
282d			;		inc hl 
282d			;		jr .ldetok 
282d			; 
282d			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
282d			;		ld (hl), a  
282d			; 
282d			;; free that temp malloc 
282d			; 
282d			;		pop hl    
282d			; 
282d			;	if DEBUG_FORTH_WORDS 
282d			;		DMARK "Lt4" 
282d			;		CALLMONITOR 
282d			;	endif 
282d			;		call forth_apushstrhl 
282d			; 
282d			;		; get rid of temp malloc area 
282d			; 
282d			;		pop hl 
282d			;		call free 
282d			; 
282d			;		jr .ludone 
282d			; 
282d			;.lnuword:	pop hl 
282d			;		call forth_tok_next 
282d			;		jp .ldouscan  
282d			; 
282d			;.ludone:		 pop hl 
282d			; 
282d					NEXTW 
282d c3 22 1d			jp macro_next 
2830				endm 
# End of macro NEXTW
2830			 
2830			.FORGET: 
2830				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2830 5d				db WORD_SYS_CORE+73             
2831 a9 28			dw .NOP            
2833 07				db 6 + 1 
2834 .. 00			db "FORGET",0              
283b				endm 
# End of macro CWHEAD
283b			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
283b			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
283b			; | |  
283b			; | | e.g. "MORE" forget 
283b					if DEBUG_FORTH_WORDS_KEY 
283b						DMARK "FRG" 
283b f5				push af  
283c 3a 50 28			ld a, (.dmark)  
283f 32 7a ee			ld (debug_mark),a  
2842 3a 51 28			ld a, (.dmark+1)  
2845 32 7b ee			ld (debug_mark+1),a  
2848 3a 52 28			ld a, (.dmark+2)  
284b 32 7c ee			ld (debug_mark+2),a  
284e 18 03			jr .pastdmark  
2850 ..			.dmark: db "FRG"  
2853 f1			.pastdmark: pop af  
2854			endm  
# End of macro DMARK
2854						CALLMONITOR 
2854 cd 2c 14			call break_point_state  
2857				endm  
# End of macro CALLMONITOR
2857					endif 
2857			 
2857				; find uword 
2857			        ; update start of word with "_" 
2857				; replace uword with deleted flag 
2857			 
2857			 
2857			;	if DEBUG_FORTH_WORDS 
2857			;		DMARK "FOG" 
2857			;		CALLMONITOR 
2857			;	endif 
2857			 
2857			 
2857					; Get ptr to the word we need to look up 
2857			 
2857					FORTH_DSP_VALUEHL 
2857 cd b0 1b			call macro_dsp_valuehl 
285a				endm 
# End of macro FORTH_DSP_VALUEHL
285a					;v5 FORTH_DSP_VALUE 
285a				; TODO type check 
285a			;		inc hl    ; Skip type check  
285a e5					push hl 
285b c1					pop bc 
285c			;		ex de, hl    ; put into DE 
285c			 
285c			 
285c 21 96 58				ld hl, baseram 
285f					;ld hl, baseusermem 
285f			 
285f				; skip dict stub 
285f			;	call forth_tok_next 
285f e5			push hl   ; sacreifical push 
2860			 
2860			.fldouscanm: 
2860 e1				pop hl 
2861			.fldouscan: 
2861			;	if DEBUG_FORTH_WORDS 
2861			;		DMARK "LSs" 
2861			;		CALLMONITOR 
2861			;	endif 
2861				; skip dict stub 
2861 cd 73 1e				call forth_tok_next 
2864			 
2864			 
2864			; while we have words to look for 
2864			 
2864 7e				ld a, (hl)      
2865			;	if DEBUG_FORTH_WORDS 
2865			;		DMARK "LSk" 
2865			;		CALLMONITOR 
2865			;	endif 
2865 fe 00				cp WORD_SYS_END 
2867 ca a3 28				jp z, .flunotfound 
286a fe 01				cp WORD_SYS_UWORD 
286c c2 61 28				jp nz, .fldouscan 
286f			 
286f			;	if DEBUG_FORTH_WORDS 
286f			;		DMARK "LSu" 
286f			;		CALLMONITOR 
286f			;	endif 
286f			 
286f					; found a uword but is it the one we want... 
286f			 
286f c5					push bc     ; uword to find is on bc 
2870 d1					pop de 
2871			 
2871 e5					push hl  ; to save the ptr 
2872			 
2872					; skip opcode 
2872 23					inc hl  
2873					; skip next ptr 
2873 23					inc hl  
2874 23					inc hl 
2875					; skip len 
2875 23					inc hl 
2876			 
2876			;	if DEBUG_FORTH_WORDS 
2876			;		DMARK "LSc" 
2876			;		CALLMONITOR 
2876			;	endif 
2876 cd 48 10				call strcmp 
2879 c2 60 28				jp nz, .fldouscanm 
287c			; 
287c			; 
287c			;; while we have words to look for 
287c			; 
287c			;.fdouscan:	ld a, (hl)      
287c			;	if DEBUG_FORTH_WORDS 
287c			;		DMARK "LSs" 
287c			;		CALLMONITOR 
287c			;	endif 
287c			;		cp WORD_SYS_END 
287c			;		jp z, .fudone 
287c			;		cp WORD_SYS_UWORD 
287c			;		jp nz, .fnuword 
287c			; 
287c			;	if DEBUG_FORTH_WORDS 
287c			;		DMARK "FGu" 
287c			;		CALLMONITOR 
287c			;	endif 
287c			; 
287c			;		; found a uword but is it the one we want... 
287c			; 
287c			; 
287c			;	        pop de   ; get back the dsp name 
287c			;		push de 
287c			; 
287c			;		push hl  ; to save the ptr 
287c			; 
287c			;		; skip opcode 
287c			;		inc hl  
287c			;		; skip next ptr 
287c			;		inc hl  
287c			;		inc hl 
287c			;		; skip len 
287c			;		inc hl 
287c			; 
287c			;	if DEBUG_FORTH_WORDS 
287c			;		DMARK "FGc" 
287c			;		CALLMONITOR 
287c			;	endif 
287c			;		call strcmp 
287c			;		jp nz, .fnuword 
287c			 
287c			 
287c e1			pop hl 
287d			 
287d				 
287d				if DEBUG_FORTH_WORDS 
287d					DMARK "FGm" 
287d f5				push af  
287e 3a 92 28			ld a, (.dmark)  
2881 32 7a ee			ld (debug_mark),a  
2884 3a 93 28			ld a, (.dmark+1)  
2887 32 7b ee			ld (debug_mark+1),a  
288a 3a 94 28			ld a, (.dmark+2)  
288d 32 7c ee			ld (debug_mark+2),a  
2890 18 03			jr .pastdmark  
2892 ..			.dmark: db "FGm"  
2895 f1			.pastdmark: pop af  
2896			endm  
# End of macro DMARK
2896					CALLMONITOR 
2896 cd 2c 14			call break_point_state  
2899				endm  
# End of macro CALLMONITOR
2899				endif 
2899			 
2899			 
2899			 
2899					; we have a uword so push its name to the stack 
2899			 
2899			;	   	push hl  ; save so we can move to next dict block 
2899			;pop hl 
2899			 
2899					; update opcode to deleted 
2899 3e 03				ld a, WORD_SYS_DELETED 
289b 77					ld (hl), a 
289c			 
289c 23					inc hl  
289d					; skip next ptr 
289d 23					inc hl  
289e 23					inc hl 
289f					; skip len 
289f 23					inc hl 
28a0			 
28a0					; TODO change parser to skip deleted words but for now mark it out 
28a0 3e 5f				ld a, "_" 
28a2 77					ld  (hl),a 
28a3			 
28a3			;		jr .fudone 
28a3			; 
28a3			;.fnuword:	pop hl 
28a3			;		call forth_tok_next 
28a3			;		jp .fdouscan  
28a3			 
28a3			.flunotfound:		  
28a3			 
28a3			 
28a3					 
28a3					FORTH_DSP_POP 
28a3 cd 68 1c			call macro_forth_dsp_pop 
28a6				endm 
# End of macro FORTH_DSP_POP
28a6			;		ld hl, .luno 
28a6			;.fudone:		 pop hl 
28a6					NEXTW 
28a6 c3 22 1d			jp macro_next 
28a9				endm 
# End of macro NEXTW
28a9			.NOP: 
28a9				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
28a9 61				db WORD_SYS_CORE+77             
28aa d0 28			dw .COMO            
28ac 04				db 3 + 1 
28ad .. 00			db "NOP",0              
28b1				endm 
# End of macro CWHEAD
28b1			; | NOP (  --  ) Do nothing | DONE 
28b1					if DEBUG_FORTH_WORDS_KEY 
28b1						DMARK "NOP" 
28b1 f5				push af  
28b2 3a c6 28			ld a, (.dmark)  
28b5 32 7a ee			ld (debug_mark),a  
28b8 3a c7 28			ld a, (.dmark+1)  
28bb 32 7b ee			ld (debug_mark+1),a  
28be 3a c8 28			ld a, (.dmark+2)  
28c1 32 7c ee			ld (debug_mark+2),a  
28c4 18 03			jr .pastdmark  
28c6 ..			.dmark: db "NOP"  
28c9 f1			.pastdmark: pop af  
28ca			endm  
# End of macro DMARK
28ca						CALLMONITOR 
28ca cd 2c 14			call break_point_state  
28cd				endm  
# End of macro CALLMONITOR
28cd					endif 
28cd				       NEXTW 
28cd c3 22 1d			jp macro_next 
28d0				endm 
# End of macro NEXTW
28d0			.COMO: 
28d0				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
28d0 6e				db WORD_SYS_CORE+90             
28d1 22 29			dw .COMC            
28d3 02				db 1 + 1 
28d4 .. 00			db "(",0              
28d6				endm 
# End of macro CWHEAD
28d6			; | ( ( -- )  Start of comment | DONE 
28d6			 
28d6			 
28d6 2a 61 e6				ld hl, ( os_tok_ptr) 
28d9 11 1d 29			ld de, .closepar 
28dc					 
28dc					if DEBUG_FORTH_WORDS 
28dc						DMARK ").." 
28dc f5				push af  
28dd 3a f1 28			ld a, (.dmark)  
28e0 32 7a ee			ld (debug_mark),a  
28e3 3a f2 28			ld a, (.dmark+1)  
28e6 32 7b ee			ld (debug_mark+1),a  
28e9 3a f3 28			ld a, (.dmark+2)  
28ec 32 7c ee			ld (debug_mark+2),a  
28ef 18 03			jr .pastdmark  
28f1 ..			.dmark: db ").."  
28f4 f1			.pastdmark: pop af  
28f5			endm  
# End of macro DMARK
28f5						CALLMONITOR 
28f5 cd 2c 14			call break_point_state  
28f8				endm  
# End of macro CALLMONITOR
28f8					endif 
28f8 cd 3d 1e			call findnexttok  
28fb			 
28fb					if DEBUG_FORTH_WORDS 
28fb						DMARK "IF5" 
28fb f5				push af  
28fc 3a 10 29			ld a, (.dmark)  
28ff 32 7a ee			ld (debug_mark),a  
2902 3a 11 29			ld a, (.dmark+1)  
2905 32 7b ee			ld (debug_mark+1),a  
2908 3a 12 29			ld a, (.dmark+2)  
290b 32 7c ee			ld (debug_mark+2),a  
290e 18 03			jr .pastdmark  
2910 ..			.dmark: db "IF5"  
2913 f1			.pastdmark: pop af  
2914			endm  
# End of macro DMARK
2914						CALLMONITOR 
2914 cd 2c 14			call break_point_state  
2917				endm  
# End of macro CALLMONITOR
2917					endif 
2917				; replace below with ) exec using tok_ptr 
2917 22 61 e6			ld (os_tok_ptr), hl 
291a c3 b3 1d			jp exec1 
291d			 
291d .. 00			.closepar:   db ")",0 
291f			 
291f				       NEXTW 
291f c3 22 1d			jp macro_next 
2922				endm 
# End of macro NEXTW
2922			.COMC: 
2922				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2922 6f				db WORD_SYS_CORE+91             
2923 2b 29			dw .SCRATCH            
2925 02				db 1 + 1 
2926 .. 00			db ")",0              
2928				endm 
# End of macro CWHEAD
2928			; | ) ( -- )  End of comment |  DONE  
2928				       NEXTW 
2928 c3 22 1d			jp macro_next 
292b				endm 
# End of macro NEXTW
292b			 
292b			.SCRATCH: 
292b				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
292b 6f				db WORD_SYS_CORE+91             
292c 66 29			dw .INC            
292e 08				db 7 + 1 
292f .. 00			db "SCRATCH",0              
2937				endm 
# End of macro CWHEAD
2937			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2937			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2937			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2937			; | |  
2937			; | | e.g.    : score $00 scratch ; 
2937			; | |  
2937			; | | $00 score ! 
2937			; | | $01 score +! 
2937			; | |  
2937			; | | e.g.   : varword $0a scratch ;  
2937			; | | 
2937			; | | $8000 varword ! 
2937					if DEBUG_FORTH_WORDS_KEY 
2937						DMARK "SCR" 
2937 f5				push af  
2938 3a 4c 29			ld a, (.dmark)  
293b 32 7a ee			ld (debug_mark),a  
293e 3a 4d 29			ld a, (.dmark+1)  
2941 32 7b ee			ld (debug_mark+1),a  
2944 3a 4e 29			ld a, (.dmark+2)  
2947 32 7c ee			ld (debug_mark+2),a  
294a 18 03			jr .pastdmark  
294c ..			.dmark: db "SCR"  
294f f1			.pastdmark: pop af  
2950			endm  
# End of macro DMARK
2950						CALLMONITOR 
2950 cd 2c 14			call break_point_state  
2953				endm  
# End of macro CALLMONITOR
2953					endif 
2953			 
2953					FORTH_DSP_VALUEHL 
2953 cd b0 1b			call macro_dsp_valuehl 
2956				endm 
# End of macro FORTH_DSP_VALUEHL
2956				 
2956					FORTH_DSP_POP 
2956 cd 68 1c			call macro_forth_dsp_pop 
2959				endm 
# End of macro FORTH_DSP_POP
2959			 
2959 7d					ld a, l 
295a 21 85 e8				ld hl, os_var_array 
295d cd b2 0b				call addatohl 
2960			 
2960 cd b9 19				call forth_push_numhl 
2963			 
2963				       NEXTW 
2963 c3 22 1d			jp macro_next 
2966				endm 
# End of macro NEXTW
2966			 
2966			.INC: 
2966				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2966 6f				db WORD_SYS_CORE+91             
2967 ba 29			dw .DEC            
2969 03				db 2 + 1 
296a .. 00			db "+!",0              
296d				endm 
# End of macro CWHEAD
296d			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
296d					if DEBUG_FORTH_WORDS_KEY 
296d						DMARK "+s_" 
296d f5				push af  
296e 3a 82 29			ld a, (.dmark)  
2971 32 7a ee			ld (debug_mark),a  
2974 3a 83 29			ld a, (.dmark+1)  
2977 32 7b ee			ld (debug_mark+1),a  
297a 3a 84 29			ld a, (.dmark+2)  
297d 32 7c ee			ld (debug_mark+2),a  
2980 18 03			jr .pastdmark  
2982 ..			.dmark: db "+s_"  
2985 f1			.pastdmark: pop af  
2986			endm  
# End of macro DMARK
2986						CALLMONITOR 
2986 cd 2c 14			call break_point_state  
2989				endm  
# End of macro CALLMONITOR
2989					endif 
2989			 
2989					FORTH_DSP_VALUEHL 
2989 cd b0 1b			call macro_dsp_valuehl 
298c				endm 
# End of macro FORTH_DSP_VALUEHL
298c			 
298c e5					push hl   ; save address 
298d			 
298d					FORTH_DSP_POP 
298d cd 68 1c			call macro_forth_dsp_pop 
2990				endm 
# End of macro FORTH_DSP_POP
2990			 
2990					FORTH_DSP_VALUEHL 
2990 cd b0 1b			call macro_dsp_valuehl 
2993				endm 
# End of macro FORTH_DSP_VALUEHL
2993			 
2993					FORTH_DSP_POP 
2993 cd 68 1c			call macro_forth_dsp_pop 
2996				endm 
# End of macro FORTH_DSP_POP
2996			 
2996					; hl contains value to add to byte at a 
2996				 
2996 eb					ex de, hl 
2997			 
2997 e1					pop hl 
2998			 
2998					if DEBUG_FORTH_WORDS 
2998						DMARK "INC" 
2998 f5				push af  
2999 3a ad 29			ld a, (.dmark)  
299c 32 7a ee			ld (debug_mark),a  
299f 3a ae 29			ld a, (.dmark+1)  
29a2 32 7b ee			ld (debug_mark+1),a  
29a5 3a af 29			ld a, (.dmark+2)  
29a8 32 7c ee			ld (debug_mark+2),a  
29ab 18 03			jr .pastdmark  
29ad ..			.dmark: db "INC"  
29b0 f1			.pastdmark: pop af  
29b1			endm  
# End of macro DMARK
29b1						CALLMONITOR 
29b1 cd 2c 14			call break_point_state  
29b4				endm  
# End of macro CALLMONITOR
29b4					endif 
29b4			 
29b4 7e					ld a,(hl) 
29b5 83					add e 
29b6 77					ld (hl),a 
29b7			 
29b7			 
29b7			 
29b7				       NEXTW 
29b7 c3 22 1d			jp macro_next 
29ba				endm 
# End of macro NEXTW
29ba			 
29ba			.DEC: 
29ba				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
29ba 6f				db WORD_SYS_CORE+91             
29bb 0b 2a			dw .INC2            
29bd 03				db 2 + 1 
29be .. 00			db "-!",0              
29c1				endm 
# End of macro CWHEAD
29c1			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
29c1					if DEBUG_FORTH_WORDS_KEY 
29c1						DMARK "-s_" 
29c1 f5				push af  
29c2 3a d6 29			ld a, (.dmark)  
29c5 32 7a ee			ld (debug_mark),a  
29c8 3a d7 29			ld a, (.dmark+1)  
29cb 32 7b ee			ld (debug_mark+1),a  
29ce 3a d8 29			ld a, (.dmark+2)  
29d1 32 7c ee			ld (debug_mark+2),a  
29d4 18 03			jr .pastdmark  
29d6 ..			.dmark: db "-s_"  
29d9 f1			.pastdmark: pop af  
29da			endm  
# End of macro DMARK
29da						CALLMONITOR 
29da cd 2c 14			call break_point_state  
29dd				endm  
# End of macro CALLMONITOR
29dd					endif 
29dd			 
29dd					FORTH_DSP_VALUEHL 
29dd cd b0 1b			call macro_dsp_valuehl 
29e0				endm 
# End of macro FORTH_DSP_VALUEHL
29e0			 
29e0 e5					push hl   ; save address 
29e1			 
29e1					FORTH_DSP_POP 
29e1 cd 68 1c			call macro_forth_dsp_pop 
29e4				endm 
# End of macro FORTH_DSP_POP
29e4			 
29e4					FORTH_DSP_VALUEHL 
29e4 cd b0 1b			call macro_dsp_valuehl 
29e7				endm 
# End of macro FORTH_DSP_VALUEHL
29e7			 
29e7					; hl contains value to add to byte at a 
29e7				 
29e7 eb					ex de, hl 
29e8			 
29e8 e1					pop hl 
29e9			 
29e9					if DEBUG_FORTH_WORDS 
29e9						DMARK "DEC" 
29e9 f5				push af  
29ea 3a fe 29			ld a, (.dmark)  
29ed 32 7a ee			ld (debug_mark),a  
29f0 3a ff 29			ld a, (.dmark+1)  
29f3 32 7b ee			ld (debug_mark+1),a  
29f6 3a 00 2a			ld a, (.dmark+2)  
29f9 32 7c ee			ld (debug_mark+2),a  
29fc 18 03			jr .pastdmark  
29fe ..			.dmark: db "DEC"  
2a01 f1			.pastdmark: pop af  
2a02			endm  
# End of macro DMARK
2a02						CALLMONITOR 
2a02 cd 2c 14			call break_point_state  
2a05				endm  
# End of macro CALLMONITOR
2a05					endif 
2a05			 
2a05 7e					ld a,(hl) 
2a06 93					sub e 
2a07 77					ld (hl),a 
2a08			 
2a08			 
2a08			 
2a08				       NEXTW 
2a08 c3 22 1d			jp macro_next 
2a0b				endm 
# End of macro NEXTW
2a0b			 
2a0b			.INC2: 
2a0b				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2a0b 6f				db WORD_SYS_CORE+91             
2a0c b5 2a			dw .DEC2            
2a0e 04				db 3 + 1 
2a0f .. 00			db "+2!",0              
2a13				endm 
# End of macro CWHEAD
2a13			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2a13			 
2a13					if DEBUG_FORTH_WORDS_KEY 
2a13						DMARK "+2s" 
2a13 f5				push af  
2a14 3a 28 2a			ld a, (.dmark)  
2a17 32 7a ee			ld (debug_mark),a  
2a1a 3a 29 2a			ld a, (.dmark+1)  
2a1d 32 7b ee			ld (debug_mark+1),a  
2a20 3a 2a 2a			ld a, (.dmark+2)  
2a23 32 7c ee			ld (debug_mark+2),a  
2a26 18 03			jr .pastdmark  
2a28 ..			.dmark: db "+2s"  
2a2b f1			.pastdmark: pop af  
2a2c			endm  
# End of macro DMARK
2a2c						CALLMONITOR 
2a2c cd 2c 14			call break_point_state  
2a2f				endm  
# End of macro CALLMONITOR
2a2f					endif 
2a2f			 
2a2f					; Address 
2a2f			 
2a2f					FORTH_DSP_VALUEHL 
2a2f cd b0 1b			call macro_dsp_valuehl 
2a32				endm 
# End of macro FORTH_DSP_VALUEHL
2a32			 
2a32 e5					push hl    ; save address 
2a33			 
2a33					; load content into de 
2a33			 
2a33 5e					ld e,(hl) 
2a34 23					inc hl 
2a35 56					ld d, (hl) 
2a36			 
2a36					if DEBUG_FORTH_WORDS 
2a36						DMARK "+2a" 
2a36 f5				push af  
2a37 3a 4b 2a			ld a, (.dmark)  
2a3a 32 7a ee			ld (debug_mark),a  
2a3d 3a 4c 2a			ld a, (.dmark+1)  
2a40 32 7b ee			ld (debug_mark+1),a  
2a43 3a 4d 2a			ld a, (.dmark+2)  
2a46 32 7c ee			ld (debug_mark+2),a  
2a49 18 03			jr .pastdmark  
2a4b ..			.dmark: db "+2a"  
2a4e f1			.pastdmark: pop af  
2a4f			endm  
# End of macro DMARK
2a4f						CALLMONITOR 
2a4f cd 2c 14			call break_point_state  
2a52				endm  
# End of macro CALLMONITOR
2a52					endif 
2a52			 
2a52					FORTH_DSP_POP 
2a52 cd 68 1c			call macro_forth_dsp_pop 
2a55				endm 
# End of macro FORTH_DSP_POP
2a55			 
2a55					; Get value to add 
2a55			 
2a55					FORTH_DSP_VALUE 
2a55 cd 99 1b			call macro_forth_dsp_value 
2a58				endm 
# End of macro FORTH_DSP_VALUE
2a58			 
2a58					if DEBUG_FORTH_WORDS 
2a58						DMARK "+2v" 
2a58 f5				push af  
2a59 3a 6d 2a			ld a, (.dmark)  
2a5c 32 7a ee			ld (debug_mark),a  
2a5f 3a 6e 2a			ld a, (.dmark+1)  
2a62 32 7b ee			ld (debug_mark+1),a  
2a65 3a 6f 2a			ld a, (.dmark+2)  
2a68 32 7c ee			ld (debug_mark+2),a  
2a6b 18 03			jr .pastdmark  
2a6d ..			.dmark: db "+2v"  
2a70 f1			.pastdmark: pop af  
2a71			endm  
# End of macro DMARK
2a71						CALLMONITOR 
2a71 cd 2c 14			call break_point_state  
2a74				endm  
# End of macro CALLMONITOR
2a74					endif 
2a74			 
2a74 19					add hl, de 
2a75			 
2a75					if DEBUG_FORTH_WORDS 
2a75						DMARK "+2+" 
2a75 f5				push af  
2a76 3a 8a 2a			ld a, (.dmark)  
2a79 32 7a ee			ld (debug_mark),a  
2a7c 3a 8b 2a			ld a, (.dmark+1)  
2a7f 32 7b ee			ld (debug_mark+1),a  
2a82 3a 8c 2a			ld a, (.dmark+2)  
2a85 32 7c ee			ld (debug_mark+2),a  
2a88 18 03			jr .pastdmark  
2a8a ..			.dmark: db "+2+"  
2a8d f1			.pastdmark: pop af  
2a8e			endm  
# End of macro DMARK
2a8e						CALLMONITOR 
2a8e cd 2c 14			call break_point_state  
2a91				endm  
# End of macro CALLMONITOR
2a91					endif 
2a91			 
2a91					; move result to de 
2a91			 
2a91 eb					ex de, hl 
2a92			 
2a92					; Address 
2a92			 
2a92 e1					pop hl 
2a93			 
2a93					; save it back 
2a93			 
2a93 73					ld (hl), e 
2a94 23					inc hl 
2a95 72					ld (hl), d 
2a96			 
2a96					if DEBUG_FORTH_WORDS 
2a96						DMARK "+2e" 
2a96 f5				push af  
2a97 3a ab 2a			ld a, (.dmark)  
2a9a 32 7a ee			ld (debug_mark),a  
2a9d 3a ac 2a			ld a, (.dmark+1)  
2aa0 32 7b ee			ld (debug_mark+1),a  
2aa3 3a ad 2a			ld a, (.dmark+2)  
2aa6 32 7c ee			ld (debug_mark+2),a  
2aa9 18 03			jr .pastdmark  
2aab ..			.dmark: db "+2e"  
2aae f1			.pastdmark: pop af  
2aaf			endm  
# End of macro DMARK
2aaf						CALLMONITOR 
2aaf cd 2c 14			call break_point_state  
2ab2				endm  
# End of macro CALLMONITOR
2ab2					endif 
2ab2			 
2ab2			 
2ab2			 
2ab2			 
2ab2			 
2ab2				       NEXTW 
2ab2 c3 22 1d			jp macro_next 
2ab5				endm 
# End of macro NEXTW
2ab5			 
2ab5			.DEC2: 
2ab5				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2ab5 6f				db WORD_SYS_CORE+91             
2ab6 61 2b			dw .GET2            
2ab8 04				db 3 + 1 
2ab9 .. 00			db "-2!",0              
2abd				endm 
# End of macro CWHEAD
2abd			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2abd			 
2abd			 
2abd					if DEBUG_FORTH_WORDS_KEY 
2abd						DMARK "-2s" 
2abd f5				push af  
2abe 3a d2 2a			ld a, (.dmark)  
2ac1 32 7a ee			ld (debug_mark),a  
2ac4 3a d3 2a			ld a, (.dmark+1)  
2ac7 32 7b ee			ld (debug_mark+1),a  
2aca 3a d4 2a			ld a, (.dmark+2)  
2acd 32 7c ee			ld (debug_mark+2),a  
2ad0 18 03			jr .pastdmark  
2ad2 ..			.dmark: db "-2s"  
2ad5 f1			.pastdmark: pop af  
2ad6			endm  
# End of macro DMARK
2ad6						CALLMONITOR 
2ad6 cd 2c 14			call break_point_state  
2ad9				endm  
# End of macro CALLMONITOR
2ad9					endif 
2ad9			 
2ad9					; Address 
2ad9			 
2ad9					FORTH_DSP_VALUEHL 
2ad9 cd b0 1b			call macro_dsp_valuehl 
2adc				endm 
# End of macro FORTH_DSP_VALUEHL
2adc			 
2adc e5					push hl    ; save address 
2add			 
2add					; load content into de 
2add			 
2add 5e					ld e,(hl) 
2ade 23					inc hl 
2adf 56					ld d, (hl) 
2ae0			 
2ae0					if DEBUG_FORTH_WORDS 
2ae0						DMARK "-2a" 
2ae0 f5				push af  
2ae1 3a f5 2a			ld a, (.dmark)  
2ae4 32 7a ee			ld (debug_mark),a  
2ae7 3a f6 2a			ld a, (.dmark+1)  
2aea 32 7b ee			ld (debug_mark+1),a  
2aed 3a f7 2a			ld a, (.dmark+2)  
2af0 32 7c ee			ld (debug_mark+2),a  
2af3 18 03			jr .pastdmark  
2af5 ..			.dmark: db "-2a"  
2af8 f1			.pastdmark: pop af  
2af9			endm  
# End of macro DMARK
2af9						CALLMONITOR 
2af9 cd 2c 14			call break_point_state  
2afc				endm  
# End of macro CALLMONITOR
2afc					endif 
2afc			 
2afc					FORTH_DSP_POP 
2afc cd 68 1c			call macro_forth_dsp_pop 
2aff				endm 
# End of macro FORTH_DSP_POP
2aff			 
2aff					; Get value to remove 
2aff			 
2aff					FORTH_DSP_VALUE 
2aff cd 99 1b			call macro_forth_dsp_value 
2b02				endm 
# End of macro FORTH_DSP_VALUE
2b02			 
2b02					if DEBUG_FORTH_WORDS 
2b02						DMARK "-2v" 
2b02 f5				push af  
2b03 3a 17 2b			ld a, (.dmark)  
2b06 32 7a ee			ld (debug_mark),a  
2b09 3a 18 2b			ld a, (.dmark+1)  
2b0c 32 7b ee			ld (debug_mark+1),a  
2b0f 3a 19 2b			ld a, (.dmark+2)  
2b12 32 7c ee			ld (debug_mark+2),a  
2b15 18 03			jr .pastdmark  
2b17 ..			.dmark: db "-2v"  
2b1a f1			.pastdmark: pop af  
2b1b			endm  
# End of macro DMARK
2b1b						CALLMONITOR 
2b1b cd 2c 14			call break_point_state  
2b1e				endm  
# End of macro CALLMONITOR
2b1e					endif 
2b1e			 
2b1e eb					ex de, hl 
2b1f ed 52				sbc hl, de 
2b21			 
2b21					if DEBUG_FORTH_WORDS 
2b21						DMARK "-2d" 
2b21 f5				push af  
2b22 3a 36 2b			ld a, (.dmark)  
2b25 32 7a ee			ld (debug_mark),a  
2b28 3a 37 2b			ld a, (.dmark+1)  
2b2b 32 7b ee			ld (debug_mark+1),a  
2b2e 3a 38 2b			ld a, (.dmark+2)  
2b31 32 7c ee			ld (debug_mark+2),a  
2b34 18 03			jr .pastdmark  
2b36 ..			.dmark: db "-2d"  
2b39 f1			.pastdmark: pop af  
2b3a			endm  
# End of macro DMARK
2b3a						CALLMONITOR 
2b3a cd 2c 14			call break_point_state  
2b3d				endm  
# End of macro CALLMONITOR
2b3d					endif 
2b3d			 
2b3d					; move result to de 
2b3d			 
2b3d eb					ex de, hl 
2b3e			 
2b3e					; Address 
2b3e			 
2b3e e1					pop hl 
2b3f			 
2b3f					; save it back 
2b3f			 
2b3f 73					ld (hl), e 
2b40 23					inc hl 
2b41 72					ld (hl), d 
2b42			 
2b42					if DEBUG_FORTH_WORDS 
2b42						DMARK "-2e" 
2b42 f5				push af  
2b43 3a 57 2b			ld a, (.dmark)  
2b46 32 7a ee			ld (debug_mark),a  
2b49 3a 58 2b			ld a, (.dmark+1)  
2b4c 32 7b ee			ld (debug_mark+1),a  
2b4f 3a 59 2b			ld a, (.dmark+2)  
2b52 32 7c ee			ld (debug_mark+2),a  
2b55 18 03			jr .pastdmark  
2b57 ..			.dmark: db "-2e"  
2b5a f1			.pastdmark: pop af  
2b5b			endm  
# End of macro DMARK
2b5b						CALLMONITOR 
2b5b cd 2c 14			call break_point_state  
2b5e				endm  
# End of macro CALLMONITOR
2b5e					endif 
2b5e			 
2b5e			 
2b5e			 
2b5e			 
2b5e			 
2b5e				       NEXTW 
2b5e c3 22 1d			jp macro_next 
2b61				endm 
# End of macro NEXTW
2b61			.GET2: 
2b61				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2b61 6f				db WORD_SYS_CORE+91             
2b62 91 2b			dw .BANG2            
2b64 03				db 2 + 1 
2b65 .. 00			db "2@",0              
2b68				endm 
# End of macro CWHEAD
2b68			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2b68					if DEBUG_FORTH_WORDS_KEY 
2b68						DMARK "2A_" 
2b68 f5				push af  
2b69 3a 7d 2b			ld a, (.dmark)  
2b6c 32 7a ee			ld (debug_mark),a  
2b6f 3a 7e 2b			ld a, (.dmark+1)  
2b72 32 7b ee			ld (debug_mark+1),a  
2b75 3a 7f 2b			ld a, (.dmark+2)  
2b78 32 7c ee			ld (debug_mark+2),a  
2b7b 18 03			jr .pastdmark  
2b7d ..			.dmark: db "2A_"  
2b80 f1			.pastdmark: pop af  
2b81			endm  
# End of macro DMARK
2b81						CALLMONITOR 
2b81 cd 2c 14			call break_point_state  
2b84				endm  
# End of macro CALLMONITOR
2b84					endif 
2b84			 
2b84					FORTH_DSP_VALUEHL 
2b84 cd b0 1b			call macro_dsp_valuehl 
2b87				endm 
# End of macro FORTH_DSP_VALUEHL
2b87			 
2b87 5e					ld e, (hl) 
2b88 23					inc hl 
2b89 56					ld d, (hl) 
2b8a			 
2b8a eb					ex de, hl 
2b8b			 
2b8b cd b9 19				call forth_push_numhl 
2b8e			 
2b8e				       NEXTW 
2b8e c3 22 1d			jp macro_next 
2b91				endm 
# End of macro NEXTW
2b91			.BANG2: 
2b91				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2b91 6f				db WORD_SYS_CORE+91             
2b92 c9 2b			dw .CONFIG            
2b94 03				db 2 + 1 
2b95 .. 00			db "2!",0              
2b98				endm 
# End of macro CWHEAD
2b98			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2b98					if DEBUG_FORTH_WORDS_KEY 
2b98						DMARK "2S_" 
2b98 f5				push af  
2b99 3a ad 2b			ld a, (.dmark)  
2b9c 32 7a ee			ld (debug_mark),a  
2b9f 3a ae 2b			ld a, (.dmark+1)  
2ba2 32 7b ee			ld (debug_mark+1),a  
2ba5 3a af 2b			ld a, (.dmark+2)  
2ba8 32 7c ee			ld (debug_mark+2),a  
2bab 18 03			jr .pastdmark  
2bad ..			.dmark: db "2S_"  
2bb0 f1			.pastdmark: pop af  
2bb1			endm  
# End of macro DMARK
2bb1						CALLMONITOR 
2bb1 cd 2c 14			call break_point_state  
2bb4				endm  
# End of macro CALLMONITOR
2bb4					endif 
2bb4			 
2bb4					FORTH_DSP_VALUEHL 
2bb4 cd b0 1b			call macro_dsp_valuehl 
2bb7				endm 
# End of macro FORTH_DSP_VALUEHL
2bb7			 
2bb7 e5					push hl   ; save address 
2bb8			 
2bb8			 
2bb8					FORTH_DSP_POP 
2bb8 cd 68 1c			call macro_forth_dsp_pop 
2bbb				endm 
# End of macro FORTH_DSP_POP
2bbb			 
2bbb					 
2bbb					FORTH_DSP_VALUEHL 
2bbb cd b0 1b			call macro_dsp_valuehl 
2bbe				endm 
# End of macro FORTH_DSP_VALUEHL
2bbe			 
2bbe					FORTH_DSP_POP 
2bbe cd 68 1c			call macro_forth_dsp_pop 
2bc1				endm 
# End of macro FORTH_DSP_POP
2bc1			 
2bc1 eb					ex de, hl    ; value now in de 
2bc2			 
2bc2 e1					pop hl 
2bc3			 
2bc3 73					ld (hl), e 
2bc4			 
2bc4 23					inc hl 
2bc5			 
2bc5 72					ld (hl), d 
2bc6			 
2bc6			 
2bc6				       NEXTW 
2bc6 c3 22 1d			jp macro_next 
2bc9				endm 
# End of macro NEXTW
2bc9			.CONFIG: 
2bc9				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2bc9 6f				db WORD_SYS_CORE+91             
2bca da 2b			dw .ENDCORE            
2bcc 07				db 6 + 1 
2bcd .. 00			db "CONFIG",0              
2bd4				endm 
# End of macro CWHEAD
2bd4			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
2bd4			 
2bd4 cd 12 12				call config 
2bd7					NEXTW 
2bd7 c3 22 1d			jp macro_next 
2bda				endm 
# End of macro NEXTW
2bda			.ENDCORE: 
2bda			 
2bda			; eof 
2bda			 
2bda			 
# End of file forth_words_core.asm
2bda			include "forth_words_flow.asm" 
2bda			 
2bda			; | ## Program Flow Words 
2bda			 
2bda			.IF: 
2bda				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2bda 1e				db WORD_SYS_CORE+10             
2bdb cf 2c			dw .THEN            
2bdd 03				db 2 + 1 
2bde .. 00			db "IF",0              
2be1				endm 
# End of macro CWHEAD
2be1			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2be1			; 
2be1					if DEBUG_FORTH_WORDS_KEY 
2be1						DMARK "IF." 
2be1 f5				push af  
2be2 3a f6 2b			ld a, (.dmark)  
2be5 32 7a ee			ld (debug_mark),a  
2be8 3a f7 2b			ld a, (.dmark+1)  
2beb 32 7b ee			ld (debug_mark+1),a  
2bee 3a f8 2b			ld a, (.dmark+2)  
2bf1 32 7c ee			ld (debug_mark+2),a  
2bf4 18 03			jr .pastdmark  
2bf6 ..			.dmark: db "IF."  
2bf9 f1			.pastdmark: pop af  
2bfa			endm  
# End of macro DMARK
2bfa						CALLMONITOR 
2bfa cd 2c 14			call break_point_state  
2bfd				endm  
# End of macro CALLMONITOR
2bfd					endif 
2bfd			; eval TOS 
2bfd			 
2bfd				FORTH_DSP_VALUEHL 
2bfd cd b0 1b			call macro_dsp_valuehl 
2c00				endm 
# End of macro FORTH_DSP_VALUEHL
2c00			 
2c00			;	push hl 
2c00				FORTH_DSP_POP 
2c00 cd 68 1c			call macro_forth_dsp_pop 
2c03				endm 
# End of macro FORTH_DSP_POP
2c03			;	pop hl 
2c03			 
2c03					if DEBUG_FORTH_WORDS 
2c03						DMARK "IF1" 
2c03 f5				push af  
2c04 3a 18 2c			ld a, (.dmark)  
2c07 32 7a ee			ld (debug_mark),a  
2c0a 3a 19 2c			ld a, (.dmark+1)  
2c0d 32 7b ee			ld (debug_mark+1),a  
2c10 3a 1a 2c			ld a, (.dmark+2)  
2c13 32 7c ee			ld (debug_mark+2),a  
2c16 18 03			jr .pastdmark  
2c18 ..			.dmark: db "IF1"  
2c1b f1			.pastdmark: pop af  
2c1c			endm  
# End of macro DMARK
2c1c						CALLMONITOR 
2c1c cd 2c 14			call break_point_state  
2c1f				endm  
# End of macro CALLMONITOR
2c1f					endif 
2c1f b7				or a        ; clear carry flag 
2c20 11 00 00			ld de, 0 
2c23 eb				ex de,hl 
2c24 ed 52			sbc hl, de 
2c26 c2 b0 2c			jp nz, .iftrue 
2c29			 
2c29					if DEBUG_FORTH_WORDS 
2c29						DMARK "IF2" 
2c29 f5				push af  
2c2a 3a 3e 2c			ld a, (.dmark)  
2c2d 32 7a ee			ld (debug_mark),a  
2c30 3a 3f 2c			ld a, (.dmark+1)  
2c33 32 7b ee			ld (debug_mark+1),a  
2c36 3a 40 2c			ld a, (.dmark+2)  
2c39 32 7c ee			ld (debug_mark+2),a  
2c3c 18 03			jr .pastdmark  
2c3e ..			.dmark: db "IF2"  
2c41 f1			.pastdmark: pop af  
2c42			endm  
# End of macro DMARK
2c42						CALLMONITOR 
2c42 cd 2c 14			call break_point_state  
2c45				endm  
# End of macro CALLMONITOR
2c45					endif 
2c45			 
2c45			; if not true then skip to THEN 
2c45			 
2c45				; TODO get tok_ptr 
2c45				; TODO consume toks until we get to THEN 
2c45			 
2c45 2a 61 e6			ld hl, (os_tok_ptr) 
2c48					if DEBUG_FORTH_WORDS 
2c48						DMARK "IF3" 
2c48 f5				push af  
2c49 3a 5d 2c			ld a, (.dmark)  
2c4c 32 7a ee			ld (debug_mark),a  
2c4f 3a 5e 2c			ld a, (.dmark+1)  
2c52 32 7b ee			ld (debug_mark+1),a  
2c55 3a 5f 2c			ld a, (.dmark+2)  
2c58 32 7c ee			ld (debug_mark+2),a  
2c5b 18 03			jr .pastdmark  
2c5d ..			.dmark: db "IF3"  
2c60 f1			.pastdmark: pop af  
2c61			endm  
# End of macro DMARK
2c61						CALLMONITOR 
2c61 cd 2c 14			call break_point_state  
2c64				endm  
# End of macro CALLMONITOR
2c64						 
2c64					endif 
2c64 11 ab 2c			ld de, .ifthen 
2c67					if DEBUG_FORTH_WORDS 
2c67						DMARK "IF4" 
2c67 f5				push af  
2c68 3a 7c 2c			ld a, (.dmark)  
2c6b 32 7a ee			ld (debug_mark),a  
2c6e 3a 7d 2c			ld a, (.dmark+1)  
2c71 32 7b ee			ld (debug_mark+1),a  
2c74 3a 7e 2c			ld a, (.dmark+2)  
2c77 32 7c ee			ld (debug_mark+2),a  
2c7a 18 03			jr .pastdmark  
2c7c ..			.dmark: db "IF4"  
2c7f f1			.pastdmark: pop af  
2c80			endm  
# End of macro DMARK
2c80						CALLMONITOR 
2c80 cd 2c 14			call break_point_state  
2c83				endm  
# End of macro CALLMONITOR
2c83					endif 
2c83 cd 3d 1e			call findnexttok  
2c86			 
2c86					if DEBUG_FORTH_WORDS 
2c86						DMARK "IF5" 
2c86 f5				push af  
2c87 3a 9b 2c			ld a, (.dmark)  
2c8a 32 7a ee			ld (debug_mark),a  
2c8d 3a 9c 2c			ld a, (.dmark+1)  
2c90 32 7b ee			ld (debug_mark+1),a  
2c93 3a 9d 2c			ld a, (.dmark+2)  
2c96 32 7c ee			ld (debug_mark+2),a  
2c99 18 03			jr .pastdmark  
2c9b ..			.dmark: db "IF5"  
2c9e f1			.pastdmark: pop af  
2c9f			endm  
# End of macro DMARK
2c9f						CALLMONITOR 
2c9f cd 2c 14			call break_point_state  
2ca2				endm  
# End of macro CALLMONITOR
2ca2					endif 
2ca2				; TODO replace below with ; exec using tok_ptr 
2ca2 22 61 e6			ld (os_tok_ptr), hl 
2ca5 c3 b3 1d			jp exec1 
2ca8				NEXTW 
2ca8 c3 22 1d			jp macro_next 
2cab				endm 
# End of macro NEXTW
2cab			 
2cab .. 00		.ifthen:  db "THEN",0 
2cb0			 
2cb0			.iftrue:		 
2cb0				; Exec next words normally 
2cb0			 
2cb0				; if true then exec following IF as normal 
2cb0					if DEBUG_FORTH_WORDS 
2cb0						DMARK "IFT" 
2cb0 f5				push af  
2cb1 3a c5 2c			ld a, (.dmark)  
2cb4 32 7a ee			ld (debug_mark),a  
2cb7 3a c6 2c			ld a, (.dmark+1)  
2cba 32 7b ee			ld (debug_mark+1),a  
2cbd 3a c7 2c			ld a, (.dmark+2)  
2cc0 32 7c ee			ld (debug_mark+2),a  
2cc3 18 03			jr .pastdmark  
2cc5 ..			.dmark: db "IFT"  
2cc8 f1			.pastdmark: pop af  
2cc9			endm  
# End of macro DMARK
2cc9						CALLMONITOR 
2cc9 cd 2c 14			call break_point_state  
2ccc				endm  
# End of macro CALLMONITOR
2ccc					endif 
2ccc			 
2ccc					NEXTW 
2ccc c3 22 1d			jp macro_next 
2ccf				endm 
# End of macro NEXTW
2ccf			.THEN: 
2ccf				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2ccf 1f				db WORD_SYS_CORE+11             
2cd0 f7 2c			dw .ELSE            
2cd2 05				db 4 + 1 
2cd3 .. 00			db "THEN",0              
2cd8				endm 
# End of macro CWHEAD
2cd8			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2cd8					if DEBUG_FORTH_WORDS_KEY 
2cd8						DMARK "THN" 
2cd8 f5				push af  
2cd9 3a ed 2c			ld a, (.dmark)  
2cdc 32 7a ee			ld (debug_mark),a  
2cdf 3a ee 2c			ld a, (.dmark+1)  
2ce2 32 7b ee			ld (debug_mark+1),a  
2ce5 3a ef 2c			ld a, (.dmark+2)  
2ce8 32 7c ee			ld (debug_mark+2),a  
2ceb 18 03			jr .pastdmark  
2ced ..			.dmark: db "THN"  
2cf0 f1			.pastdmark: pop af  
2cf1			endm  
# End of macro DMARK
2cf1						CALLMONITOR 
2cf1 cd 2c 14			call break_point_state  
2cf4				endm  
# End of macro CALLMONITOR
2cf4					endif 
2cf4					NEXTW 
2cf4 c3 22 1d			jp macro_next 
2cf7				endm 
# End of macro NEXTW
2cf7			.ELSE: 
2cf7				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2cf7 20				db WORD_SYS_CORE+12             
2cf8 1f 2d			dw .DO            
2cfa 03				db 2 + 1 
2cfb .. 00			db "ELSE",0              
2d00				endm 
# End of macro CWHEAD
2d00			; | ELSE ( -- ) Not supported - does nothing | TODO 
2d00			 
2d00					if DEBUG_FORTH_WORDS_KEY 
2d00						DMARK "ELS" 
2d00 f5				push af  
2d01 3a 15 2d			ld a, (.dmark)  
2d04 32 7a ee			ld (debug_mark),a  
2d07 3a 16 2d			ld a, (.dmark+1)  
2d0a 32 7b ee			ld (debug_mark+1),a  
2d0d 3a 17 2d			ld a, (.dmark+2)  
2d10 32 7c ee			ld (debug_mark+2),a  
2d13 18 03			jr .pastdmark  
2d15 ..			.dmark: db "ELS"  
2d18 f1			.pastdmark: pop af  
2d19			endm  
# End of macro DMARK
2d19						CALLMONITOR 
2d19 cd 2c 14			call break_point_state  
2d1c				endm  
# End of macro CALLMONITOR
2d1c					endif 
2d1c			 
2d1c			 
2d1c					NEXTW 
2d1c c3 22 1d			jp macro_next 
2d1f				endm 
# End of macro NEXTW
2d1f			.DO: 
2d1f				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2d1f 21				db WORD_SYS_CORE+13             
2d20 46 2e			dw .LOOP            
2d22 03				db 2 + 1 
2d23 .. 00			db "DO",0              
2d26				endm 
# End of macro CWHEAD
2d26			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2d26			 
2d26					if DEBUG_FORTH_WORDS_KEY 
2d26						DMARK "DO." 
2d26 f5				push af  
2d27 3a 3b 2d			ld a, (.dmark)  
2d2a 32 7a ee			ld (debug_mark),a  
2d2d 3a 3c 2d			ld a, (.dmark+1)  
2d30 32 7b ee			ld (debug_mark+1),a  
2d33 3a 3d 2d			ld a, (.dmark+2)  
2d36 32 7c ee			ld (debug_mark+2),a  
2d39 18 03			jr .pastdmark  
2d3b ..			.dmark: db "DO."  
2d3e f1			.pastdmark: pop af  
2d3f			endm  
# End of macro DMARK
2d3f						CALLMONITOR 
2d3f cd 2c 14			call break_point_state  
2d42				endm  
# End of macro CALLMONITOR
2d42					endif 
2d42			;  push pc to rsp stack past the DO 
2d42			 
2d42 2a 61 e6				ld hl, (os_tok_ptr) 
2d45 23					inc hl   ; D 
2d46 23					inc hl  ; O 
2d47 23					inc hl   ; null 
2d48					if DEBUG_FORTH_WORDS 
2d48						DMARK "DO2" 
2d48 f5				push af  
2d49 3a 5d 2d			ld a, (.dmark)  
2d4c 32 7a ee			ld (debug_mark),a  
2d4f 3a 5e 2d			ld a, (.dmark+1)  
2d52 32 7b ee			ld (debug_mark+1),a  
2d55 3a 5f 2d			ld a, (.dmark+2)  
2d58 32 7c ee			ld (debug_mark+2),a  
2d5b 18 03			jr .pastdmark  
2d5d ..			.dmark: db "DO2"  
2d60 f1			.pastdmark: pop af  
2d61			endm  
# End of macro DMARK
2d61						CALLMONITOR 
2d61 cd 2c 14			call break_point_state  
2d64				endm  
# End of macro CALLMONITOR
2d64					endif 
2d64					FORTH_RSP_NEXT 
2d64 cd 60 19			call macro_forth_rsp_next 
2d67				endm 
# End of macro FORTH_RSP_NEXT
2d67					if DEBUG_FORTH_WORDS 
2d67						DMARK "DO3" 
2d67 f5				push af  
2d68 3a 7c 2d			ld a, (.dmark)  
2d6b 32 7a ee			ld (debug_mark),a  
2d6e 3a 7d 2d			ld a, (.dmark+1)  
2d71 32 7b ee			ld (debug_mark+1),a  
2d74 3a 7e 2d			ld a, (.dmark+2)  
2d77 32 7c ee			ld (debug_mark+2),a  
2d7a 18 03			jr .pastdmark  
2d7c ..			.dmark: db "DO3"  
2d7f f1			.pastdmark: pop af  
2d80			endm  
# End of macro DMARK
2d80						CALLMONITOR 
2d80 cd 2c 14			call break_point_state  
2d83				endm  
# End of macro CALLMONITOR
2d83					endif 
2d83			 
2d83					;if DEBUG_FORTH_WORDS 
2d83				;		push hl 
2d83			;		endif  
2d83			 
2d83			; get counters from data stack 
2d83			 
2d83			 
2d83					FORTH_DSP_VALUEHL 
2d83 cd b0 1b			call macro_dsp_valuehl 
2d86				endm 
# End of macro FORTH_DSP_VALUEHL
2d86 e5					push hl		 ; hl now has starting counter which needs to be tos 
2d87			 
2d87					if DEBUG_FORTH_WORDS 
2d87						DMARK "DO4" 
2d87 f5				push af  
2d88 3a 9c 2d			ld a, (.dmark)  
2d8b 32 7a ee			ld (debug_mark),a  
2d8e 3a 9d 2d			ld a, (.dmark+1)  
2d91 32 7b ee			ld (debug_mark+1),a  
2d94 3a 9e 2d			ld a, (.dmark+2)  
2d97 32 7c ee			ld (debug_mark+2),a  
2d9a 18 03			jr .pastdmark  
2d9c ..			.dmark: db "DO4"  
2d9f f1			.pastdmark: pop af  
2da0			endm  
# End of macro DMARK
2da0						CALLMONITOR 
2da0 cd 2c 14			call break_point_state  
2da3				endm  
# End of macro CALLMONITOR
2da3					endif 
2da3					FORTH_DSP_POP 
2da3 cd 68 1c			call macro_forth_dsp_pop 
2da6				endm 
# End of macro FORTH_DSP_POP
2da6			 
2da6					if DEBUG_FORTH_WORDS 
2da6						DMARK "DO5" 
2da6 f5				push af  
2da7 3a bb 2d			ld a, (.dmark)  
2daa 32 7a ee			ld (debug_mark),a  
2dad 3a bc 2d			ld a, (.dmark+1)  
2db0 32 7b ee			ld (debug_mark+1),a  
2db3 3a bd 2d			ld a, (.dmark+2)  
2db6 32 7c ee			ld (debug_mark+2),a  
2db9 18 03			jr .pastdmark  
2dbb ..			.dmark: db "DO5"  
2dbe f1			.pastdmark: pop af  
2dbf			endm  
# End of macro DMARK
2dbf						CALLMONITOR 
2dbf cd 2c 14			call break_point_state  
2dc2				endm  
# End of macro CALLMONITOR
2dc2					endif 
2dc2			 
2dc2					FORTH_DSP_VALUEHL 
2dc2 cd b0 1b			call macro_dsp_valuehl 
2dc5				endm 
# End of macro FORTH_DSP_VALUEHL
2dc5			;		push hl		 ; hl now has starting limit counter 
2dc5			 
2dc5					if DEBUG_FORTH_WORDS 
2dc5						DMARK "DO6" 
2dc5 f5				push af  
2dc6 3a da 2d			ld a, (.dmark)  
2dc9 32 7a ee			ld (debug_mark),a  
2dcc 3a db 2d			ld a, (.dmark+1)  
2dcf 32 7b ee			ld (debug_mark+1),a  
2dd2 3a dc 2d			ld a, (.dmark+2)  
2dd5 32 7c ee			ld (debug_mark+2),a  
2dd8 18 03			jr .pastdmark  
2dda ..			.dmark: db "DO6"  
2ddd f1			.pastdmark: pop af  
2dde			endm  
# End of macro DMARK
2dde						CALLMONITOR 
2dde cd 2c 14			call break_point_state  
2de1				endm  
# End of macro CALLMONITOR
2de1					endif 
2de1					FORTH_DSP_POP 
2de1 cd 68 1c			call macro_forth_dsp_pop 
2de4				endm 
# End of macro FORTH_DSP_POP
2de4			 
2de4			; put counters on the loop stack 
2de4			 
2de4			;		pop hl			 ; limit counter 
2de4 d1					pop de			; start counter 
2de5			 
2de5					; push limit counter 
2de5			 
2de5					if DEBUG_FORTH_WORDS 
2de5						DMARK "DO7" 
2de5 f5				push af  
2de6 3a fa 2d			ld a, (.dmark)  
2de9 32 7a ee			ld (debug_mark),a  
2dec 3a fb 2d			ld a, (.dmark+1)  
2def 32 7b ee			ld (debug_mark+1),a  
2df2 3a fc 2d			ld a, (.dmark+2)  
2df5 32 7c ee			ld (debug_mark+2),a  
2df8 18 03			jr .pastdmark  
2dfa ..			.dmark: db "DO7"  
2dfd f1			.pastdmark: pop af  
2dfe			endm  
# End of macro DMARK
2dfe						CALLMONITOR 
2dfe cd 2c 14			call break_point_state  
2e01				endm  
# End of macro CALLMONITOR
2e01					endif 
2e01					FORTH_LOOP_NEXT 
2e01 cd e1 1b			call macro_forth_loop_next 
2e04				endm 
# End of macro FORTH_LOOP_NEXT
2e04			 
2e04					; push start counter 
2e04			 
2e04 eb					ex de, hl 
2e05					if DEBUG_FORTH_WORDS 
2e05						DMARK "DO7" 
2e05 f5				push af  
2e06 3a 1a 2e			ld a, (.dmark)  
2e09 32 7a ee			ld (debug_mark),a  
2e0c 3a 1b 2e			ld a, (.dmark+1)  
2e0f 32 7b ee			ld (debug_mark+1),a  
2e12 3a 1c 2e			ld a, (.dmark+2)  
2e15 32 7c ee			ld (debug_mark+2),a  
2e18 18 03			jr .pastdmark  
2e1a ..			.dmark: db "DO7"  
2e1d f1			.pastdmark: pop af  
2e1e			endm  
# End of macro DMARK
2e1e						CALLMONITOR 
2e1e cd 2c 14			call break_point_state  
2e21				endm  
# End of macro CALLMONITOR
2e21					endif 
2e21					FORTH_LOOP_NEXT 
2e21 cd e1 1b			call macro_forth_loop_next 
2e24				endm 
# End of macro FORTH_LOOP_NEXT
2e24			 
2e24			 
2e24					; init first round of I counter 
2e24			 
2e24 22 85 e6				ld (os_current_i), hl 
2e27			 
2e27					if DEBUG_FORTH_WORDS 
2e27						DMARK "DO8" 
2e27 f5				push af  
2e28 3a 3c 2e			ld a, (.dmark)  
2e2b 32 7a ee			ld (debug_mark),a  
2e2e 3a 3d 2e			ld a, (.dmark+1)  
2e31 32 7b ee			ld (debug_mark+1),a  
2e34 3a 3e 2e			ld a, (.dmark+2)  
2e37 32 7c ee			ld (debug_mark+2),a  
2e3a 18 03			jr .pastdmark  
2e3c ..			.dmark: db "DO8"  
2e3f f1			.pastdmark: pop af  
2e40			endm  
# End of macro DMARK
2e40						CALLMONITOR 
2e40 cd 2c 14			call break_point_state  
2e43				endm  
# End of macro CALLMONITOR
2e43					endif 
2e43			 
2e43					NEXTW 
2e43 c3 22 1d			jp macro_next 
2e46				endm 
# End of macro NEXTW
2e46			.LOOP: 
2e46				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2e46 22				db WORD_SYS_CORE+14             
2e47 5e 2f			dw .I            
2e49 05				db 4 + 1 
2e4a .. 00			db "LOOP",0              
2e4f				endm 
# End of macro CWHEAD
2e4f			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2e4f			 
2e4f				; pop tos as current loop count to hl 
2e4f			 
2e4f				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2e4f			 
2e4f				FORTH_LOOP_TOS 
2e4f cd 14 1c			call macro_forth_loop_tos 
2e52				endm 
# End of macro FORTH_LOOP_TOS
2e52 e5				push hl 
2e53			 
2e53					if DEBUG_FORTH_WORDS_KEY 
2e53						DMARK "LOP" 
2e53 f5				push af  
2e54 3a 68 2e			ld a, (.dmark)  
2e57 32 7a ee			ld (debug_mark),a  
2e5a 3a 69 2e			ld a, (.dmark+1)  
2e5d 32 7b ee			ld (debug_mark+1),a  
2e60 3a 6a 2e			ld a, (.dmark+2)  
2e63 32 7c ee			ld (debug_mark+2),a  
2e66 18 03			jr .pastdmark  
2e68 ..			.dmark: db "LOP"  
2e6b f1			.pastdmark: pop af  
2e6c			endm  
# End of macro DMARK
2e6c						CALLMONITOR 
2e6c cd 2c 14			call break_point_state  
2e6f				endm  
# End of macro CALLMONITOR
2e6f					endif 
2e6f				; next item on the stack is the limit. get it 
2e6f			 
2e6f			 
2e6f				FORTH_LOOP_POP 
2e6f cd 1e 1c			call macro_forth_loop_pop 
2e72				endm 
# End of macro FORTH_LOOP_POP
2e72			 
2e72				FORTH_LOOP_TOS 
2e72 cd 14 1c			call macro_forth_loop_tos 
2e75				endm 
# End of macro FORTH_LOOP_TOS
2e75			 
2e75 d1				pop de		 ; de = i, hl = limit 
2e76			 
2e76					if DEBUG_FORTH_WORDS 
2e76						DMARK "LP1" 
2e76 f5				push af  
2e77 3a 8b 2e			ld a, (.dmark)  
2e7a 32 7a ee			ld (debug_mark),a  
2e7d 3a 8c 2e			ld a, (.dmark+1)  
2e80 32 7b ee			ld (debug_mark+1),a  
2e83 3a 8d 2e			ld a, (.dmark+2)  
2e86 32 7c ee			ld (debug_mark+2),a  
2e89 18 03			jr .pastdmark  
2e8b ..			.dmark: db "LP1"  
2e8e f1			.pastdmark: pop af  
2e8f			endm  
# End of macro DMARK
2e8f						CALLMONITOR 
2e8f cd 2c 14			call break_point_state  
2e92				endm  
# End of macro CALLMONITOR
2e92					endif 
2e92			 
2e92				; go back to previous word 
2e92			 
2e92 d5				push de    ; save I for inc later 
2e93			 
2e93			 
2e93				; get limit 
2e93				;  is I at limit? 
2e93			 
2e93			 
2e93					if DEBUG_FORTH_WORDS 
2e93						DMARK "LP1" 
2e93 f5				push af  
2e94 3a a8 2e			ld a, (.dmark)  
2e97 32 7a ee			ld (debug_mark),a  
2e9a 3a a9 2e			ld a, (.dmark+1)  
2e9d 32 7b ee			ld (debug_mark+1),a  
2ea0 3a aa 2e			ld a, (.dmark+2)  
2ea3 32 7c ee			ld (debug_mark+2),a  
2ea6 18 03			jr .pastdmark  
2ea8 ..			.dmark: db "LP1"  
2eab f1			.pastdmark: pop af  
2eac			endm  
# End of macro DMARK
2eac						CALLMONITOR 
2eac cd 2c 14			call break_point_state  
2eaf				endm  
# End of macro CALLMONITOR
2eaf					endif 
2eaf			 
2eaf ed 52			sbc hl, de 
2eb1			 
2eb1			 
2eb1				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2eb1			 
2eb1 20 26				jr nz, .loopnotdone 
2eb3			 
2eb3 e1				pop hl   ; get rid of saved I 
2eb4				FORTH_LOOP_POP     ; get rid of limit 
2eb4 cd 1e 1c			call macro_forth_loop_pop 
2eb7				endm 
# End of macro FORTH_LOOP_POP
2eb7			 
2eb7				FORTH_RSP_POP     ; get rid of DO ptr 
2eb7 cd 81 19			call macro_forth_rsp_pop 
2eba				endm 
# End of macro FORTH_RSP_POP
2eba			 
2eba			if DEBUG_FORTH_WORDS 
2eba						DMARK "LP>" 
2eba f5				push af  
2ebb 3a cf 2e			ld a, (.dmark)  
2ebe 32 7a ee			ld (debug_mark),a  
2ec1 3a d0 2e			ld a, (.dmark+1)  
2ec4 32 7b ee			ld (debug_mark+1),a  
2ec7 3a d1 2e			ld a, (.dmark+2)  
2eca 32 7c ee			ld (debug_mark+2),a  
2ecd 18 03			jr .pastdmark  
2ecf ..			.dmark: db "LP>"  
2ed2 f1			.pastdmark: pop af  
2ed3			endm  
# End of macro DMARK
2ed3				CALLMONITOR 
2ed3 cd 2c 14			call break_point_state  
2ed6				endm  
# End of macro CALLMONITOR
2ed6			endif 
2ed6			 
2ed6					NEXTW 
2ed6 c3 22 1d			jp macro_next 
2ed9				endm 
# End of macro NEXTW
2ed9				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2ed9			 
2ed9			.loopnotdone: 
2ed9			 
2ed9 e1				pop hl    ; get I 
2eda 23				inc hl 
2edb			 
2edb			   	; save new I 
2edb			 
2edb			 
2edb					; set I counter 
2edb			 
2edb 22 85 e6				ld (os_current_i), hl 
2ede			 
2ede					if DEBUG_FORTH_WORDS 
2ede						DMARK "LPN" 
2ede f5				push af  
2edf 3a f3 2e			ld a, (.dmark)  
2ee2 32 7a ee			ld (debug_mark),a  
2ee5 3a f4 2e			ld a, (.dmark+1)  
2ee8 32 7b ee			ld (debug_mark+1),a  
2eeb 3a f5 2e			ld a, (.dmark+2)  
2eee 32 7c ee			ld (debug_mark+2),a  
2ef1 18 03			jr .pastdmark  
2ef3 ..			.dmark: db "LPN"  
2ef6 f1			.pastdmark: pop af  
2ef7			endm  
# End of macro DMARK
2ef7					CALLMONITOR 
2ef7 cd 2c 14			call break_point_state  
2efa				endm  
# End of macro CALLMONITOR
2efa					endif 
2efa					 
2efa				FORTH_LOOP_NEXT 
2efa cd e1 1b			call macro_forth_loop_next 
2efd				endm 
# End of macro FORTH_LOOP_NEXT
2efd			 
2efd			 
2efd					if DEBUG_FORTH_WORDS 
2efd eb						ex de,hl 
2efe					endif 
2efe			 
2efe			;	; get DO ptr 
2efe			; 
2efe					if DEBUG_FORTH_WORDS 
2efe						DMARK "LP7" 
2efe f5				push af  
2eff 3a 13 2f			ld a, (.dmark)  
2f02 32 7a ee			ld (debug_mark),a  
2f05 3a 14 2f			ld a, (.dmark+1)  
2f08 32 7b ee			ld (debug_mark+1),a  
2f0b 3a 15 2f			ld a, (.dmark+2)  
2f0e 32 7c ee			ld (debug_mark+2),a  
2f11 18 03			jr .pastdmark  
2f13 ..			.dmark: db "LP7"  
2f16 f1			.pastdmark: pop af  
2f17			endm  
# End of macro DMARK
2f17					CALLMONITOR 
2f17 cd 2c 14			call break_point_state  
2f1a				endm  
# End of macro CALLMONITOR
2f1a					endif 
2f1a				FORTH_RSP_TOS 
2f1a cd 77 19			call macro_forth_rsp_tos 
2f1d				endm 
# End of macro FORTH_RSP_TOS
2f1d			 
2f1d					if DEBUG_FORTH_WORDS 
2f1d						DMARK "LP8" 
2f1d f5				push af  
2f1e 3a 32 2f			ld a, (.dmark)  
2f21 32 7a ee			ld (debug_mark),a  
2f24 3a 33 2f			ld a, (.dmark+1)  
2f27 32 7b ee			ld (debug_mark+1),a  
2f2a 3a 34 2f			ld a, (.dmark+2)  
2f2d 32 7c ee			ld (debug_mark+2),a  
2f30 18 03			jr .pastdmark  
2f32 ..			.dmark: db "LP8"  
2f35 f1			.pastdmark: pop af  
2f36			endm  
# End of macro DMARK
2f36					CALLMONITOR 
2f36 cd 2c 14			call break_point_state  
2f39				endm  
# End of macro CALLMONITOR
2f39					endif 
2f39				;push hl 
2f39			 
2f39				; not going to DO any more 
2f39				; get rid of the RSP pointer as DO will add it back in 
2f39				;FORTH_RSP_POP 
2f39				;pop hl 
2f39			 
2f39				;ld hl,(cli_ret_sp) 
2f39				;ld e, (hl) 
2f39				;inc hl 
2f39				;ld d, (hl) 
2f39				;ex de,hl 
2f39 22 61 e6			ld (os_tok_ptr), hl 
2f3c					if DEBUG_FORTH_WORDS 
2f3c						DMARK "LP<" 
2f3c f5				push af  
2f3d 3a 51 2f			ld a, (.dmark)  
2f40 32 7a ee			ld (debug_mark),a  
2f43 3a 52 2f			ld a, (.dmark+1)  
2f46 32 7b ee			ld (debug_mark+1),a  
2f49 3a 53 2f			ld a, (.dmark+2)  
2f4c 32 7c ee			ld (debug_mark+2),a  
2f4f 18 03			jr .pastdmark  
2f51 ..			.dmark: db "LP<"  
2f54 f1			.pastdmark: pop af  
2f55			endm  
# End of macro DMARK
2f55					CALLMONITOR 
2f55 cd 2c 14			call break_point_state  
2f58				endm  
# End of macro CALLMONITOR
2f58				endif 
2f58 c3 b3 1d			jp exec1 
2f5b			 
2f5b					 
2f5b			 
2f5b			 
2f5b					NEXTW 
2f5b c3 22 1d			jp macro_next 
2f5e				endm 
# End of macro NEXTW
2f5e			.I:  
2f5e			 
2f5e				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
2f5e 5e				db WORD_SYS_CORE+74             
2f5f 89 2f			dw .DLOOP            
2f61 02				db 1 + 1 
2f62 .. 00			db "I",0              
2f64				endm 
# End of macro CWHEAD
2f64			; | I ( -- ) Current loop counter | DONE 
2f64					if DEBUG_FORTH_WORDS_KEY 
2f64						DMARK "I.." 
2f64 f5				push af  
2f65 3a 79 2f			ld a, (.dmark)  
2f68 32 7a ee			ld (debug_mark),a  
2f6b 3a 7a 2f			ld a, (.dmark+1)  
2f6e 32 7b ee			ld (debug_mark+1),a  
2f71 3a 7b 2f			ld a, (.dmark+2)  
2f74 32 7c ee			ld (debug_mark+2),a  
2f77 18 03			jr .pastdmark  
2f79 ..			.dmark: db "I.."  
2f7c f1			.pastdmark: pop af  
2f7d			endm  
# End of macro DMARK
2f7d						CALLMONITOR 
2f7d cd 2c 14			call break_point_state  
2f80				endm  
# End of macro CALLMONITOR
2f80					endif 
2f80			 
2f80 2a 85 e6				ld hl,(os_current_i) 
2f83 cd b9 19				call forth_push_numhl 
2f86			 
2f86					NEXTW 
2f86 c3 22 1d			jp macro_next 
2f89				endm 
# End of macro NEXTW
2f89			.DLOOP: 
2f89				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
2f89 5f				db WORD_SYS_CORE+75             
2f8a 6a 30			dw .REPEAT            
2f8c 06				db 5 + 1 
2f8d .. 00			db "-LOOP",0              
2f93				endm 
# End of macro CWHEAD
2f93			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
2f93				; pop tos as current loop count to hl 
2f93					if DEBUG_FORTH_WORDS_KEY 
2f93						DMARK "-LP" 
2f93 f5				push af  
2f94 3a a8 2f			ld a, (.dmark)  
2f97 32 7a ee			ld (debug_mark),a  
2f9a 3a a9 2f			ld a, (.dmark+1)  
2f9d 32 7b ee			ld (debug_mark+1),a  
2fa0 3a aa 2f			ld a, (.dmark+2)  
2fa3 32 7c ee			ld (debug_mark+2),a  
2fa6 18 03			jr .pastdmark  
2fa8 ..			.dmark: db "-LP"  
2fab f1			.pastdmark: pop af  
2fac			endm  
# End of macro DMARK
2fac						CALLMONITOR 
2fac cd 2c 14			call break_point_state  
2faf				endm  
# End of macro CALLMONITOR
2faf					endif 
2faf			 
2faf				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2faf			 
2faf				FORTH_LOOP_TOS 
2faf cd 14 1c			call macro_forth_loop_tos 
2fb2				endm 
# End of macro FORTH_LOOP_TOS
2fb2 e5				push hl 
2fb3			 
2fb3					if DEBUG_FORTH_WORDS 
2fb3						DMARK "-LP" 
2fb3 f5				push af  
2fb4 3a c8 2f			ld a, (.dmark)  
2fb7 32 7a ee			ld (debug_mark),a  
2fba 3a c9 2f			ld a, (.dmark+1)  
2fbd 32 7b ee			ld (debug_mark+1),a  
2fc0 3a ca 2f			ld a, (.dmark+2)  
2fc3 32 7c ee			ld (debug_mark+2),a  
2fc6 18 03			jr .pastdmark  
2fc8 ..			.dmark: db "-LP"  
2fcb f1			.pastdmark: pop af  
2fcc			endm  
# End of macro DMARK
2fcc						CALLMONITOR 
2fcc cd 2c 14			call break_point_state  
2fcf				endm  
# End of macro CALLMONITOR
2fcf					endif 
2fcf				; next item on the stack is the limit. get it 
2fcf			 
2fcf			 
2fcf				FORTH_LOOP_POP 
2fcf cd 1e 1c			call macro_forth_loop_pop 
2fd2				endm 
# End of macro FORTH_LOOP_POP
2fd2			 
2fd2				FORTH_LOOP_TOS 
2fd2 cd 14 1c			call macro_forth_loop_tos 
2fd5				endm 
# End of macro FORTH_LOOP_TOS
2fd5			 
2fd5 d1				pop de		 ; de = i, hl = limit 
2fd6			 
2fd6					if DEBUG_FORTH_WORDS 
2fd6						DMARK "-L1" 
2fd6 f5				push af  
2fd7 3a eb 2f			ld a, (.dmark)  
2fda 32 7a ee			ld (debug_mark),a  
2fdd 3a ec 2f			ld a, (.dmark+1)  
2fe0 32 7b ee			ld (debug_mark+1),a  
2fe3 3a ed 2f			ld a, (.dmark+2)  
2fe6 32 7c ee			ld (debug_mark+2),a  
2fe9 18 03			jr .pastdmark  
2feb ..			.dmark: db "-L1"  
2fee f1			.pastdmark: pop af  
2fef			endm  
# End of macro DMARK
2fef						CALLMONITOR 
2fef cd 2c 14			call break_point_state  
2ff2				endm  
# End of macro CALLMONITOR
2ff2					endif 
2ff2			 
2ff2				; go back to previous word 
2ff2			 
2ff2 d5				push de    ; save I for inc later 
2ff3			 
2ff3			 
2ff3				; get limit 
2ff3				;  is I at limit? 
2ff3			 
2ff3			 
2ff3					if DEBUG_FORTH_WORDS 
2ff3						DMARK "-L1" 
2ff3 f5				push af  
2ff4 3a 08 30			ld a, (.dmark)  
2ff7 32 7a ee			ld (debug_mark),a  
2ffa 3a 09 30			ld a, (.dmark+1)  
2ffd 32 7b ee			ld (debug_mark+1),a  
3000 3a 0a 30			ld a, (.dmark+2)  
3003 32 7c ee			ld (debug_mark+2),a  
3006 18 03			jr .pastdmark  
3008 ..			.dmark: db "-L1"  
300b f1			.pastdmark: pop af  
300c			endm  
# End of macro DMARK
300c						CALLMONITOR 
300c cd 2c 14			call break_point_state  
300f				endm  
# End of macro CALLMONITOR
300f					endif 
300f			 
300f ed 52			sbc hl, de 
3011			 
3011			 
3011				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3011			 
3011 20 26				jr nz, .mloopnotdone 
3013			 
3013 e1				pop hl   ; get rid of saved I 
3014				FORTH_LOOP_POP     ; get rid of limit 
3014 cd 1e 1c			call macro_forth_loop_pop 
3017				endm 
# End of macro FORTH_LOOP_POP
3017			 
3017				FORTH_RSP_POP     ; get rid of DO ptr 
3017 cd 81 19			call macro_forth_rsp_pop 
301a				endm 
# End of macro FORTH_RSP_POP
301a			 
301a			if DEBUG_FORTH_WORDS 
301a						DMARK "-L>" 
301a f5				push af  
301b 3a 2f 30			ld a, (.dmark)  
301e 32 7a ee			ld (debug_mark),a  
3021 3a 30 30			ld a, (.dmark+1)  
3024 32 7b ee			ld (debug_mark+1),a  
3027 3a 31 30			ld a, (.dmark+2)  
302a 32 7c ee			ld (debug_mark+2),a  
302d 18 03			jr .pastdmark  
302f ..			.dmark: db "-L>"  
3032 f1			.pastdmark: pop af  
3033			endm  
# End of macro DMARK
3033				CALLMONITOR 
3033 cd 2c 14			call break_point_state  
3036				endm  
# End of macro CALLMONITOR
3036			endif 
3036			 
3036					NEXTW 
3036 c3 22 1d			jp macro_next 
3039				endm 
# End of macro NEXTW
3039				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3039			 
3039			.mloopnotdone: 
3039			 
3039 e1				pop hl    ; get I 
303a 2b				dec hl 
303b			 
303b			   	; save new I 
303b			 
303b			 
303b					; set I counter 
303b			 
303b 22 85 e6				ld (os_current_i), hl 
303e			 
303e					 
303e				FORTH_LOOP_NEXT 
303e cd e1 1b			call macro_forth_loop_next 
3041				endm 
# End of macro FORTH_LOOP_NEXT
3041			 
3041			 
3041					if DEBUG_FORTH_WORDS 
3041 eb						ex de,hl 
3042					endif 
3042			 
3042			;	; get DO ptr 
3042			; 
3042				FORTH_RSP_TOS 
3042 cd 77 19			call macro_forth_rsp_tos 
3045				endm 
# End of macro FORTH_RSP_TOS
3045			 
3045				;push hl 
3045			 
3045				; not going to DO any more 
3045				; get rid of the RSP pointer as DO will add it back in 
3045				;FORTH_RSP_POP 
3045				;pop hl 
3045			 
3045			 
3045 22 61 e6			ld (os_tok_ptr), hl 
3048					if DEBUG_FORTH_WORDS 
3048						DMARK "-L<" 
3048 f5				push af  
3049 3a 5d 30			ld a, (.dmark)  
304c 32 7a ee			ld (debug_mark),a  
304f 3a 5e 30			ld a, (.dmark+1)  
3052 32 7b ee			ld (debug_mark+1),a  
3055 3a 5f 30			ld a, (.dmark+2)  
3058 32 7c ee			ld (debug_mark+2),a  
305b 18 03			jr .pastdmark  
305d ..			.dmark: db "-L<"  
3060 f1			.pastdmark: pop af  
3061			endm  
# End of macro DMARK
3061					CALLMONITOR 
3061 cd 2c 14			call break_point_state  
3064				endm  
# End of macro CALLMONITOR
3064				endif 
3064 c3 b3 1d			jp exec1 
3067			 
3067					 
3067			 
3067			 
3067			 
3067				NEXTW 
3067 c3 22 1d			jp macro_next 
306a				endm 
# End of macro NEXTW
306a			 
306a			 
306a			 
306a			 
306a			.REPEAT: 
306a				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
306a 71				db WORD_SYS_CORE+93             
306b bd 30			dw .UNTIL            
306d 06				db 5 + 1 
306e .. 00			db "REPEAT",0              
3075				endm 
# End of macro CWHEAD
3075			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3075			;  push pc to rsp stack past the REPEAT 
3075					if DEBUG_FORTH_WORDS_KEY 
3075						DMARK "REP" 
3075 f5				push af  
3076 3a 8a 30			ld a, (.dmark)  
3079 32 7a ee			ld (debug_mark),a  
307c 3a 8b 30			ld a, (.dmark+1)  
307f 32 7b ee			ld (debug_mark+1),a  
3082 3a 8c 30			ld a, (.dmark+2)  
3085 32 7c ee			ld (debug_mark+2),a  
3088 18 03			jr .pastdmark  
308a ..			.dmark: db "REP"  
308d f1			.pastdmark: pop af  
308e			endm  
# End of macro DMARK
308e						CALLMONITOR 
308e cd 2c 14			call break_point_state  
3091				endm  
# End of macro CALLMONITOR
3091					endif 
3091			 
3091 2a 61 e6				ld hl, (os_tok_ptr) 
3094 23					inc hl   ; R 
3095 23					inc hl  ; E 
3096 23					inc hl   ; P 
3097 23					inc hl   ; E 
3098 23					inc hl   ; A 
3099 23					inc hl   ; T 
309a 23					inc hl   ; zero 
309b					FORTH_RSP_NEXT 
309b cd 60 19			call macro_forth_rsp_next 
309e				endm 
# End of macro FORTH_RSP_NEXT
309e			 
309e			 
309e					if DEBUG_FORTH_WORDS 
309e						DMARK "REP" 
309e f5				push af  
309f 3a b3 30			ld a, (.dmark)  
30a2 32 7a ee			ld (debug_mark),a  
30a5 3a b4 30			ld a, (.dmark+1)  
30a8 32 7b ee			ld (debug_mark+1),a  
30ab 3a b5 30			ld a, (.dmark+2)  
30ae 32 7c ee			ld (debug_mark+2),a  
30b1 18 03			jr .pastdmark  
30b3 ..			.dmark: db "REP"  
30b6 f1			.pastdmark: pop af  
30b7			endm  
# End of macro DMARK
30b7						;pop bc    ; TODO BUG ?????? what is this for???? 
30b7						CALLMONITOR 
30b7 cd 2c 14			call break_point_state  
30ba				endm  
# End of macro CALLMONITOR
30ba					endif 
30ba			 
30ba					NEXTW 
30ba c3 22 1d			jp macro_next 
30bd				endm 
# End of macro NEXTW
30bd			;	       NEXTW 
30bd			 
30bd			.UNTIL: 
30bd				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
30bd 72				db WORD_SYS_CORE+94             
30be 54 31			dw .ENDFLOW            
30c0 06				db 5 + 1 
30c1 .. 00			db "UNTIL",0              
30c7				endm 
# End of macro CWHEAD
30c7			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
30c7			 
30c7				; pop tos as check 
30c7			 
30c7				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
30c7			 
30c7				FORTH_DSP_VALUEHL 
30c7 cd b0 1b			call macro_dsp_valuehl 
30ca				endm 
# End of macro FORTH_DSP_VALUEHL
30ca			 
30ca					if DEBUG_FORTH_WORDS_KEY 
30ca						DMARK "UNT" 
30ca f5				push af  
30cb 3a df 30			ld a, (.dmark)  
30ce 32 7a ee			ld (debug_mark),a  
30d1 3a e0 30			ld a, (.dmark+1)  
30d4 32 7b ee			ld (debug_mark+1),a  
30d7 3a e1 30			ld a, (.dmark+2)  
30da 32 7c ee			ld (debug_mark+2),a  
30dd 18 03			jr .pastdmark  
30df ..			.dmark: db "UNT"  
30e2 f1			.pastdmark: pop af  
30e3			endm  
# End of macro DMARK
30e3						CALLMONITOR 
30e3 cd 2c 14			call break_point_state  
30e6				endm  
# End of macro CALLMONITOR
30e6					endif 
30e6			 
30e6			;	push hl 
30e6				FORTH_DSP_POP 
30e6 cd 68 1c			call macro_forth_dsp_pop 
30e9				endm 
# End of macro FORTH_DSP_POP
30e9			 
30e9			;	pop hl 
30e9			 
30e9				; test if true 
30e9			 
30e9 cd db 0b			call ishlzero 
30ec			;	ld a,l 
30ec			;	add h 
30ec			; 
30ec			;	cp 0 
30ec			 
30ec 20 3e			jr nz, .untilnotdone 
30ee			 
30ee					if DEBUG_FORTH_WORDS 
30ee						DMARK "UNf" 
30ee f5				push af  
30ef 3a 03 31			ld a, (.dmark)  
30f2 32 7a ee			ld (debug_mark),a  
30f5 3a 04 31			ld a, (.dmark+1)  
30f8 32 7b ee			ld (debug_mark+1),a  
30fb 3a 05 31			ld a, (.dmark+2)  
30fe 32 7c ee			ld (debug_mark+2),a  
3101 18 03			jr .pastdmark  
3103 ..			.dmark: db "UNf"  
3106 f1			.pastdmark: pop af  
3107			endm  
# End of macro DMARK
3107						CALLMONITOR 
3107 cd 2c 14			call break_point_state  
310a				endm  
# End of macro CALLMONITOR
310a					endif 
310a			 
310a			 
310a			 
310a				FORTH_RSP_POP     ; get rid of DO ptr 
310a cd 81 19			call macro_forth_rsp_pop 
310d				endm 
# End of macro FORTH_RSP_POP
310d			 
310d			if DEBUG_FORTH_WORDS 
310d						DMARK "UN>" 
310d f5				push af  
310e 3a 22 31			ld a, (.dmark)  
3111 32 7a ee			ld (debug_mark),a  
3114 3a 23 31			ld a, (.dmark+1)  
3117 32 7b ee			ld (debug_mark+1),a  
311a 3a 24 31			ld a, (.dmark+2)  
311d 32 7c ee			ld (debug_mark+2),a  
3120 18 03			jr .pastdmark  
3122 ..			.dmark: db "UN>"  
3125 f1			.pastdmark: pop af  
3126			endm  
# End of macro DMARK
3126				CALLMONITOR 
3126 cd 2c 14			call break_point_state  
3129				endm  
# End of macro CALLMONITOR
3129			endif 
3129			 
3129					NEXTW 
3129 c3 22 1d			jp macro_next 
312c				endm 
# End of macro NEXTW
312c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
312c			 
312c			.untilnotdone: 
312c			 
312c			 
312c			;	; get DO ptr 
312c			; 
312c				FORTH_RSP_TOS 
312c cd 77 19			call macro_forth_rsp_tos 
312f				endm 
# End of macro FORTH_RSP_TOS
312f			 
312f				;push hl 
312f			 
312f				; not going to DO any more 
312f				; get rid of the RSP pointer as DO will add it back in 
312f				;FORTH_RSP_POP 
312f				;pop hl 
312f			 
312f			 
312f 22 61 e6			ld (os_tok_ptr), hl 
3132					if DEBUG_FORTH_WORDS 
3132						DMARK "UN<" 
3132 f5				push af  
3133 3a 47 31			ld a, (.dmark)  
3136 32 7a ee			ld (debug_mark),a  
3139 3a 48 31			ld a, (.dmark+1)  
313c 32 7b ee			ld (debug_mark+1),a  
313f 3a 49 31			ld a, (.dmark+2)  
3142 32 7c ee			ld (debug_mark+2),a  
3145 18 03			jr .pastdmark  
3147 ..			.dmark: db "UN<"  
314a f1			.pastdmark: pop af  
314b			endm  
# End of macro DMARK
314b					CALLMONITOR 
314b cd 2c 14			call break_point_state  
314e				endm  
# End of macro CALLMONITOR
314e				endif 
314e c3 b3 1d			jp exec1 
3151			 
3151					 
3151			 
3151			 
3151					NEXTW 
3151 c3 22 1d			jp macro_next 
3154				endm 
# End of macro NEXTW
3154			 
3154			 
3154			.ENDFLOW: 
3154			 
3154			; eof 
3154			 
# End of file forth_words_flow.asm
3154			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3154			include "forth_words_logic.asm" 
3154			 
3154			; | ## Logic Words 
3154			 
3154			.NOT: 
3154				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3154 2d				db WORD_SYS_CORE+25             
3155 9c 31			dw .IS            
3157 04				db 3 + 1 
3158 .. 00			db "NOT",0              
315c				endm 
# End of macro CWHEAD
315c			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
315c					if DEBUG_FORTH_WORDS_KEY 
315c						DMARK "NOT" 
315c f5				push af  
315d 3a 71 31			ld a, (.dmark)  
3160 32 7a ee			ld (debug_mark),a  
3163 3a 72 31			ld a, (.dmark+1)  
3166 32 7b ee			ld (debug_mark+1),a  
3169 3a 73 31			ld a, (.dmark+2)  
316c 32 7c ee			ld (debug_mark+2),a  
316f 18 03			jr .pastdmark  
3171 ..			.dmark: db "NOT"  
3174 f1			.pastdmark: pop af  
3175			endm  
# End of macro DMARK
3175						CALLMONITOR 
3175 cd 2c 14			call break_point_state  
3178				endm  
# End of macro CALLMONITOR
3178					endif 
3178					FORTH_DSP 
3178 cd 76 1b			call macro_forth_dsp 
317b				endm 
# End of macro FORTH_DSP
317b 7e					ld a,(hl)	; get type of value on TOS 
317c fe 02				cp DS_TYPE_INUM  
317e 28 03				jr z, .noti 
3180					NEXTW 
3180 c3 22 1d			jp macro_next 
3183				endm 
# End of macro NEXTW
3183			.noti:          FORTH_DSP_VALUEHL 
3183 cd b0 1b			call macro_dsp_valuehl 
3186				endm 
# End of macro FORTH_DSP_VALUEHL
3186			;		push hl 
3186					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3186 cd 68 1c			call macro_forth_dsp_pop 
3189				endm 
# End of macro FORTH_DSP_POP
3189			;		pop hl 
3189 3e 00				ld a,0 
318b bd					cp l 
318c 28 04				jr z, .not2t 
318e 2e 00				ld l, 0 
3190 18 02				jr .notip 
3192			 
3192 2e ff		.not2t:		ld l, 255 
3194			 
3194 26 00		.notip:		ld h, 0	 
3196			 
3196 cd b9 19				call forth_push_numhl 
3199					NEXTW 
3199 c3 22 1d			jp macro_next 
319c				endm 
# End of macro NEXTW
319c			 
319c			.IS: 
319c				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
319c 2d				db WORD_SYS_CORE+25             
319d c2 31			dw .LZERO            
319f 03				db 2 + 1 
31a0 .. 00			db "IS",0              
31a3				endm 
# End of macro CWHEAD
31a3			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
31a3					if DEBUG_FORTH_WORDS_KEY 
31a3						DMARK "IS." 
31a3 f5				push af  
31a4 3a b8 31			ld a, (.dmark)  
31a7 32 7a ee			ld (debug_mark),a  
31aa 3a b9 31			ld a, (.dmark+1)  
31ad 32 7b ee			ld (debug_mark+1),a  
31b0 3a ba 31			ld a, (.dmark+2)  
31b3 32 7c ee			ld (debug_mark+2),a  
31b6 18 03			jr .pastdmark  
31b8 ..			.dmark: db "IS."  
31bb f1			.pastdmark: pop af  
31bc			endm  
# End of macro DMARK
31bc						CALLMONITOR 
31bc cd 2c 14			call break_point_state  
31bf				endm  
# End of macro CALLMONITOR
31bf					endif 
31bf					NEXTW 
31bf c3 22 1d			jp macro_next 
31c2				endm 
# End of macro NEXTW
31c2			.LZERO: 
31c2				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
31c2 2d				db WORD_SYS_CORE+25             
31c3 cc 31			dw .TZERO            
31c5 03				db 2 + 1 
31c6 .. 00			db "0<",0              
31c9				endm 
# End of macro CWHEAD
31c9			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
31c9					NEXTW 
31c9 c3 22 1d			jp macro_next 
31cc				endm 
# End of macro NEXTW
31cc			.TZERO: 
31cc				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
31cc 2e				db WORD_SYS_CORE+26             
31cd 13 32			dw .LESS            
31cf 03				db 2 + 1 
31d0 .. 00			db "0=",0              
31d3				endm 
# End of macro CWHEAD
31d3			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
31d3				; TODO add floating point number detection 
31d3					;v5 FORTH_DSP_VALUE 
31d3					if DEBUG_FORTH_WORDS_KEY 
31d3						DMARK "0=." 
31d3 f5				push af  
31d4 3a e8 31			ld a, (.dmark)  
31d7 32 7a ee			ld (debug_mark),a  
31da 3a e9 31			ld a, (.dmark+1)  
31dd 32 7b ee			ld (debug_mark+1),a  
31e0 3a ea 31			ld a, (.dmark+2)  
31e3 32 7c ee			ld (debug_mark+2),a  
31e6 18 03			jr .pastdmark  
31e8 ..			.dmark: db "0=."  
31eb f1			.pastdmark: pop af  
31ec			endm  
# End of macro DMARK
31ec						CALLMONITOR 
31ec cd 2c 14			call break_point_state  
31ef				endm  
# End of macro CALLMONITOR
31ef					endif 
31ef					FORTH_DSP 
31ef cd 76 1b			call macro_forth_dsp 
31f2				endm 
# End of macro FORTH_DSP
31f2 7e					ld a,(hl)	; get type of value on TOS 
31f3 fe 02				cp DS_TYPE_INUM  
31f5 28 00				jr z, .tz_inum 
31f7			 
31f7				if FORTH_ENABLE_FLOATMATH 
31f7					jr .tz_done 
31f7			 
31f7				endif 
31f7					 
31f7			 
31f7			.tz_inum: 
31f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
31f7 cd b0 1b			call macro_dsp_valuehl 
31fa				endm 
# End of macro FORTH_DSP_VALUEHL
31fa			 
31fa			;		push hl 
31fa			 
31fa					; destroy value TOS 
31fa			 
31fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
31fa cd 68 1c			call macro_forth_dsp_pop 
31fd				endm 
# End of macro FORTH_DSP_POP
31fd			 
31fd			;		pop hl 
31fd			 
31fd 3e 00				ld a,0 
31ff			 
31ff bd					cp l 
3200 20 08				jr nz, .tz_notzero 
3202			 
3202 bc					cp h 
3203			 
3203 20 05				jr nz, .tz_notzero 
3205			 
3205			 
3205 21 01 00				ld hl, FORTH_TRUE 
3208 18 03				jr .tz_done 
320a			 
320a 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
320d			 
320d					; push value back onto stack for another op etc 
320d			 
320d			.tz_done: 
320d cd b9 19				call forth_push_numhl 
3210			 
3210					NEXTW 
3210 c3 22 1d			jp macro_next 
3213				endm 
# End of macro NEXTW
3213			.LESS: 
3213				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3213 2f				db WORD_SYS_CORE+27             
3214 7c 32			dw .GT            
3216 02				db 1 + 1 
3217 .. 00			db "<",0              
3219				endm 
# End of macro CWHEAD
3219			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3219				; TODO add floating point number detection 
3219					if DEBUG_FORTH_WORDS_KEY 
3219						DMARK "LES" 
3219 f5				push af  
321a 3a 2e 32			ld a, (.dmark)  
321d 32 7a ee			ld (debug_mark),a  
3220 3a 2f 32			ld a, (.dmark+1)  
3223 32 7b ee			ld (debug_mark+1),a  
3226 3a 30 32			ld a, (.dmark+2)  
3229 32 7c ee			ld (debug_mark+2),a  
322c 18 03			jr .pastdmark  
322e ..			.dmark: db "LES"  
3231 f1			.pastdmark: pop af  
3232			endm  
# End of macro DMARK
3232						CALLMONITOR 
3232 cd 2c 14			call break_point_state  
3235				endm  
# End of macro CALLMONITOR
3235					endif 
3235					FORTH_DSP 
3235 cd 76 1b			call macro_forth_dsp 
3238				endm 
# End of macro FORTH_DSP
3238					;v5 FORTH_DSP_VALUE 
3238 7e					ld a,(hl)	; get type of value on TOS 
3239 fe 02				cp DS_TYPE_INUM  
323b 28 00				jr z, .less_inum 
323d			 
323d				if FORTH_ENABLE_FLOATMATH 
323d					jr .less_done 
323d			 
323d				endif 
323d					 
323d			 
323d			.less_inum: 
323d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
323d cd b0 1b			call macro_dsp_valuehl 
3240				endm 
# End of macro FORTH_DSP_VALUEHL
3240			 
3240 e5					push hl  ; u2 
3241			 
3241					; destroy value TOS 
3241			 
3241					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3241 cd 68 1c			call macro_forth_dsp_pop 
3244				endm 
# End of macro FORTH_DSP_POP
3244			 
3244			 
3244					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3244 cd b0 1b			call macro_dsp_valuehl 
3247				endm 
# End of macro FORTH_DSP_VALUEHL
3247			 
3247 e5					push hl    ; u1 
3248			 
3248					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3248 cd 68 1c			call macro_forth_dsp_pop 
324b				endm 
# End of macro FORTH_DSP_POP
324b			 
324b			 
324b b7			 or a      ;clear carry flag 
324c 01 00 00		 ld bc, FORTH_FALSE 
324f e1			  pop hl    ; u1 
3250 d1			  pop de    ; u2 
3251 ed 52		  sbc hl,de 
3253 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3255			 
3255 01 01 00		 ld bc, FORTH_TRUE 
3258			.lscont:  
3258 c5					push bc 
3259 e1					pop hl 
325a			 
325a					if DEBUG_FORTH_WORDS 
325a						DMARK "LT1" 
325a f5				push af  
325b 3a 6f 32			ld a, (.dmark)  
325e 32 7a ee			ld (debug_mark),a  
3261 3a 70 32			ld a, (.dmark+1)  
3264 32 7b ee			ld (debug_mark+1),a  
3267 3a 71 32			ld a, (.dmark+2)  
326a 32 7c ee			ld (debug_mark+2),a  
326d 18 03			jr .pastdmark  
326f ..			.dmark: db "LT1"  
3272 f1			.pastdmark: pop af  
3273			endm  
# End of macro DMARK
3273						CALLMONITOR 
3273 cd 2c 14			call break_point_state  
3276				endm  
# End of macro CALLMONITOR
3276					endif 
3276 cd b9 19				call forth_push_numhl 
3279			 
3279					NEXTW 
3279 c3 22 1d			jp macro_next 
327c				endm 
# End of macro NEXTW
327c			.GT: 
327c				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
327c 30				db WORD_SYS_CORE+28             
327d e5 32			dw .EQUAL            
327f 02				db 1 + 1 
3280 .. 00			db ">",0              
3282				endm 
# End of macro CWHEAD
3282			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3282				; TODO add floating point number detection 
3282					if DEBUG_FORTH_WORDS_KEY 
3282						DMARK "GRT" 
3282 f5				push af  
3283 3a 97 32			ld a, (.dmark)  
3286 32 7a ee			ld (debug_mark),a  
3289 3a 98 32			ld a, (.dmark+1)  
328c 32 7b ee			ld (debug_mark+1),a  
328f 3a 99 32			ld a, (.dmark+2)  
3292 32 7c ee			ld (debug_mark+2),a  
3295 18 03			jr .pastdmark  
3297 ..			.dmark: db "GRT"  
329a f1			.pastdmark: pop af  
329b			endm  
# End of macro DMARK
329b						CALLMONITOR 
329b cd 2c 14			call break_point_state  
329e				endm  
# End of macro CALLMONITOR
329e					endif 
329e					FORTH_DSP 
329e cd 76 1b			call macro_forth_dsp 
32a1				endm 
# End of macro FORTH_DSP
32a1					;FORTH_DSP_VALUE 
32a1 7e					ld a,(hl)	; get type of value on TOS 
32a2 fe 02				cp DS_TYPE_INUM  
32a4 28 00				jr z, .gt_inum 
32a6			 
32a6				if FORTH_ENABLE_FLOATMATH 
32a6					jr .gt_done 
32a6			 
32a6				endif 
32a6					 
32a6			 
32a6			.gt_inum: 
32a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32a6 cd b0 1b			call macro_dsp_valuehl 
32a9				endm 
# End of macro FORTH_DSP_VALUEHL
32a9			 
32a9 e5					push hl  ; u2 
32aa			 
32aa					; destroy value TOS 
32aa			 
32aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32aa cd 68 1c			call macro_forth_dsp_pop 
32ad				endm 
# End of macro FORTH_DSP_POP
32ad			 
32ad			 
32ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32ad cd b0 1b			call macro_dsp_valuehl 
32b0				endm 
# End of macro FORTH_DSP_VALUEHL
32b0			 
32b0 e5					push hl    ; u1 
32b1			 
32b1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32b1 cd 68 1c			call macro_forth_dsp_pop 
32b4				endm 
# End of macro FORTH_DSP_POP
32b4			 
32b4			 
32b4 b7			 or a      ;clear carry flag 
32b5 01 00 00		 ld bc, FORTH_FALSE 
32b8 e1			  pop hl    ; u1 
32b9 d1			  pop de    ; u2 
32ba ed 52		  sbc hl,de 
32bc 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
32be			 
32be 01 01 00		 ld bc, FORTH_TRUE 
32c1			.gtcont:  
32c1 c5					push bc 
32c2 e1					pop hl 
32c3			 
32c3					if DEBUG_FORTH_WORDS 
32c3						DMARK "GT1" 
32c3 f5				push af  
32c4 3a d8 32			ld a, (.dmark)  
32c7 32 7a ee			ld (debug_mark),a  
32ca 3a d9 32			ld a, (.dmark+1)  
32cd 32 7b ee			ld (debug_mark+1),a  
32d0 3a da 32			ld a, (.dmark+2)  
32d3 32 7c ee			ld (debug_mark+2),a  
32d6 18 03			jr .pastdmark  
32d8 ..			.dmark: db "GT1"  
32db f1			.pastdmark: pop af  
32dc			endm  
# End of macro DMARK
32dc						CALLMONITOR 
32dc cd 2c 14			call break_point_state  
32df				endm  
# End of macro CALLMONITOR
32df					endif 
32df cd b9 19				call forth_push_numhl 
32e2			 
32e2					NEXTW 
32e2 c3 22 1d			jp macro_next 
32e5				endm 
# End of macro NEXTW
32e5			.EQUAL: 
32e5				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
32e5 31				db WORD_SYS_CORE+29             
32e6 50 33			dw .ENDLOGIC            
32e8 02				db 1 + 1 
32e9 .. 00			db "=",0              
32eb				endm 
# End of macro CWHEAD
32eb			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
32eb				; TODO add floating point number detection 
32eb					if DEBUG_FORTH_WORDS_KEY 
32eb						DMARK "EQ." 
32eb f5				push af  
32ec 3a 00 33			ld a, (.dmark)  
32ef 32 7a ee			ld (debug_mark),a  
32f2 3a 01 33			ld a, (.dmark+1)  
32f5 32 7b ee			ld (debug_mark+1),a  
32f8 3a 02 33			ld a, (.dmark+2)  
32fb 32 7c ee			ld (debug_mark+2),a  
32fe 18 03			jr .pastdmark  
3300 ..			.dmark: db "EQ."  
3303 f1			.pastdmark: pop af  
3304			endm  
# End of macro DMARK
3304						CALLMONITOR 
3304 cd 2c 14			call break_point_state  
3307				endm  
# End of macro CALLMONITOR
3307					endif 
3307					FORTH_DSP 
3307 cd 76 1b			call macro_forth_dsp 
330a				endm 
# End of macro FORTH_DSP
330a					;v5 FORTH_DSP_VALUE 
330a 7e					ld a,(hl)	; get type of value on TOS 
330b fe 02				cp DS_TYPE_INUM  
330d 28 00				jr z, .eq_inum 
330f			 
330f				if FORTH_ENABLE_FLOATMATH 
330f					jr .eq_done 
330f			 
330f				endif 
330f					 
330f			 
330f			.eq_inum: 
330f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
330f cd b0 1b			call macro_dsp_valuehl 
3312				endm 
# End of macro FORTH_DSP_VALUEHL
3312			 
3312 e5					push hl 
3313			 
3313					; destroy value TOS 
3313			 
3313					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3313 cd 68 1c			call macro_forth_dsp_pop 
3316				endm 
# End of macro FORTH_DSP_POP
3316			 
3316			 
3316					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3316 cd b0 1b			call macro_dsp_valuehl 
3319				endm 
# End of macro FORTH_DSP_VALUEHL
3319			 
3319					; one value on hl get other one back 
3319			 
3319 e5					push hl 
331a			 
331a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
331a cd 68 1c			call macro_forth_dsp_pop 
331d				endm 
# End of macro FORTH_DSP_POP
331d			 
331d 0e 00				ld c, FORTH_FALSE 
331f			 
331f e1					pop hl 
3320 d1					pop de 
3321			 
3321 7b					ld a, e 
3322 bd					cp l 
3323			 
3323 20 06				jr nz, .eq_done 
3325			 
3325 7a					ld a, d 
3326 bc					cp h 
3327			 
3327 20 02				jr nz, .eq_done 
3329			 
3329 0e 01				ld c, FORTH_TRUE 
332b					 
332b			 
332b			 
332b			.eq_done: 
332b			 
332b					; TODO push value back onto stack for another op etc 
332b			 
332b 26 00				ld h, 0 
332d 69					ld l, c 
332e					if DEBUG_FORTH_WORDS 
332e						DMARK "EQ1" 
332e f5				push af  
332f 3a 43 33			ld a, (.dmark)  
3332 32 7a ee			ld (debug_mark),a  
3335 3a 44 33			ld a, (.dmark+1)  
3338 32 7b ee			ld (debug_mark+1),a  
333b 3a 45 33			ld a, (.dmark+2)  
333e 32 7c ee			ld (debug_mark+2),a  
3341 18 03			jr .pastdmark  
3343 ..			.dmark: db "EQ1"  
3346 f1			.pastdmark: pop af  
3347			endm  
# End of macro DMARK
3347						CALLMONITOR 
3347 cd 2c 14			call break_point_state  
334a				endm  
# End of macro CALLMONITOR
334a					endif 
334a cd b9 19				call forth_push_numhl 
334d			 
334d					NEXTW 
334d c3 22 1d			jp macro_next 
3350				endm 
# End of macro NEXTW
3350			 
3350			 
3350			.ENDLOGIC: 
3350			; eof 
3350			 
3350			 
# End of file forth_words_logic.asm
3350			include "forth_words_maths.asm" 
3350			 
3350			; | ## Maths Words 
3350			 
3350			.PLUS:	 
3350				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3350 15				db WORD_SYS_CORE+1             
3351 92 33			dw .NEG            
3353 02				db 1 + 1 
3354 .. 00			db "+",0              
3356				endm 
# End of macro CWHEAD
3356			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3356					if DEBUG_FORTH_WORDS_KEY 
3356						DMARK "PLU" 
3356 f5				push af  
3357 3a 6b 33			ld a, (.dmark)  
335a 32 7a ee			ld (debug_mark),a  
335d 3a 6c 33			ld a, (.dmark+1)  
3360 32 7b ee			ld (debug_mark+1),a  
3363 3a 6d 33			ld a, (.dmark+2)  
3366 32 7c ee			ld (debug_mark+2),a  
3369 18 03			jr .pastdmark  
336b ..			.dmark: db "PLU"  
336e f1			.pastdmark: pop af  
336f			endm  
# End of macro DMARK
336f						CALLMONITOR 
336f cd 2c 14			call break_point_state  
3372				endm  
# End of macro CALLMONITOR
3372					endif 
3372					; add top two values and push back result 
3372			 
3372					;for v5 FORTH_DSP_VALUE 
3372					FORTH_DSP 
3372 cd 76 1b			call macro_forth_dsp 
3375				endm 
# End of macro FORTH_DSP
3375 7e					ld a,(hl)	; get type of value on TOS 
3376 fe 02				cp DS_TYPE_INUM  
3378 28 03				jr z, .dot_inum 
337a			 
337a					NEXTW 
337a c3 22 1d			jp macro_next 
337d				endm 
# End of macro NEXTW
337d			 
337d			; float maths 
337d			 
337d				if FORTH_ENABLE_FLOATMATH 
337d						inc hl      ; now at start of numeric as string 
337d			 
337d					if DEBUG_FORTH_MATHS 
337d						DMARK "ADD" 
337d				CALLMONITOR 
337d					endif 
337d			 
337d					;ld ix, hl 
337d					call CON 
337d			 
337d			 
337d					push hl 
337d					 
337d					 
337d			 
337d						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
337d			 
337d					; get next number 
337d			 
337d						FORTH_DSP_VALUE 
337d			 
337d						inc hl      ; now at start of numeric as string 
337d			 
337d					;ld ix, hl 
337d					call CON 
337d			 
337d					push hl 
337d			 
337d			 
337d						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
337d			 
337d						; TODO do add 
337d			 
337d						call IADD 
337d			 
337d						; TODO get result back as ascii 
337d			 
337d						; TODO push result  
337d			 
337d			 
337d			 
337d						jr .dot_done 
337d				endif 
337d			 
337d			.dot_inum: 
337d			 
337d			 
337d					if DEBUG_FORTH_DOT 
337d						DMARK "+IT" 
337d				CALLMONITOR 
337d					endif 
337d			 
337d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
337d cd b0 1b			call macro_dsp_valuehl 
3380				endm 
# End of macro FORTH_DSP_VALUEHL
3380			 
3380				; TODO add floating point number detection 
3380			 
3380 e5					push hl 
3381			 
3381					; destroy value TOS 
3381			 
3381					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3381 cd 68 1c			call macro_forth_dsp_pop 
3384				endm 
# End of macro FORTH_DSP_POP
3384			 
3384			 
3384					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3384 cd b0 1b			call macro_dsp_valuehl 
3387				endm 
# End of macro FORTH_DSP_VALUEHL
3387			 
3387					; one value on hl get other one back 
3387			 
3387 d1					pop de 
3388			 
3388					; do the add 
3388			 
3388 19					add hl,de 
3389			 
3389					; save it 
3389			 
3389			;		push hl	 
3389			 
3389					; 
3389			 
3389					; destroy value TOS 
3389			 
3389					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3389 cd 68 1c			call macro_forth_dsp_pop 
338c				endm 
# End of macro FORTH_DSP_POP
338c			 
338c					; TODO push value back onto stack for another op etc 
338c			 
338c			;		pop hl 
338c			 
338c			.dot_done: 
338c cd b9 19				call forth_push_numhl 
338f			 
338f					NEXTW 
338f c3 22 1d			jp macro_next 
3392				endm 
# End of macro NEXTW
3392			.NEG: 
3392			 
3392				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3392 17				db WORD_SYS_CORE+3             
3393 d5 33			dw .DIV            
3395 02				db 1 + 1 
3396 .. 00			db "-",0              
3398				endm 
# End of macro CWHEAD
3398			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3398					if DEBUG_FORTH_WORDS_KEY 
3398						DMARK "SUB" 
3398 f5				push af  
3399 3a ad 33			ld a, (.dmark)  
339c 32 7a ee			ld (debug_mark),a  
339f 3a ae 33			ld a, (.dmark+1)  
33a2 32 7b ee			ld (debug_mark+1),a  
33a5 3a af 33			ld a, (.dmark+2)  
33a8 32 7c ee			ld (debug_mark+2),a  
33ab 18 03			jr .pastdmark  
33ad ..			.dmark: db "SUB"  
33b0 f1			.pastdmark: pop af  
33b1			endm  
# End of macro DMARK
33b1						CALLMONITOR 
33b1 cd 2c 14			call break_point_state  
33b4				endm  
# End of macro CALLMONITOR
33b4					endif 
33b4			 
33b4			 
33b4				; TODO add floating point number detection 
33b4					; v5 FORTH_DSP_VALUE 
33b4					FORTH_DSP 
33b4 cd 76 1b			call macro_forth_dsp 
33b7				endm 
# End of macro FORTH_DSP
33b7 7e					ld a,(hl)	; get type of value on TOS 
33b8 fe 02				cp DS_TYPE_INUM  
33ba 28 03				jr z, .neg_inum 
33bc			 
33bc					NEXTW 
33bc c3 22 1d			jp macro_next 
33bf				endm 
# End of macro NEXTW
33bf			 
33bf			; float maths 
33bf			 
33bf				if FORTH_ENABLE_FLOATMATH 
33bf					jr .neg_done 
33bf			 
33bf				endif 
33bf					 
33bf			 
33bf			.neg_inum: 
33bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33bf cd b0 1b			call macro_dsp_valuehl 
33c2				endm 
# End of macro FORTH_DSP_VALUEHL
33c2			 
33c2 e5					push hl 
33c3			 
33c3					; destroy value TOS 
33c3			 
33c3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33c3 cd 68 1c			call macro_forth_dsp_pop 
33c6				endm 
# End of macro FORTH_DSP_POP
33c6			 
33c6			 
33c6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33c6 cd b0 1b			call macro_dsp_valuehl 
33c9				endm 
# End of macro FORTH_DSP_VALUEHL
33c9			 
33c9					; one value on hl get other one back 
33c9			 
33c9 d1					pop de 
33ca			 
33ca					; do the sub 
33ca			;		ex de, hl 
33ca			 
33ca ed 52				sbc hl,de 
33cc			 
33cc					; save it 
33cc			 
33cc			;		push hl	 
33cc			 
33cc					; 
33cc			 
33cc					; destroy value TOS 
33cc			 
33cc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33cc cd 68 1c			call macro_forth_dsp_pop 
33cf				endm 
# End of macro FORTH_DSP_POP
33cf			 
33cf					; TODO push value back onto stack for another op etc 
33cf			 
33cf			;		pop hl 
33cf			 
33cf cd b9 19				call forth_push_numhl 
33d2			.neg_done: 
33d2			 
33d2					NEXTW 
33d2 c3 22 1d			jp macro_next 
33d5				endm 
# End of macro NEXTW
33d5			.DIV: 
33d5				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
33d5 18				db WORD_SYS_CORE+4             
33d6 22 34			dw .MUL            
33d8 02				db 1 + 1 
33d9 .. 00			db "/",0              
33db				endm 
# End of macro CWHEAD
33db			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
33db					if DEBUG_FORTH_WORDS_KEY 
33db						DMARK "DIV" 
33db f5				push af  
33dc 3a f0 33			ld a, (.dmark)  
33df 32 7a ee			ld (debug_mark),a  
33e2 3a f1 33			ld a, (.dmark+1)  
33e5 32 7b ee			ld (debug_mark+1),a  
33e8 3a f2 33			ld a, (.dmark+2)  
33eb 32 7c ee			ld (debug_mark+2),a  
33ee 18 03			jr .pastdmark  
33f0 ..			.dmark: db "DIV"  
33f3 f1			.pastdmark: pop af  
33f4			endm  
# End of macro DMARK
33f4						CALLMONITOR 
33f4 cd 2c 14			call break_point_state  
33f7				endm  
# End of macro CALLMONITOR
33f7					endif 
33f7				; TODO add floating point number detection 
33f7					; v5 FORTH_DSP_VALUE 
33f7					FORTH_DSP 
33f7 cd 76 1b			call macro_forth_dsp 
33fa				endm 
# End of macro FORTH_DSP
33fa 7e					ld a,(hl)	; get type of value on TOS 
33fb fe 02				cp DS_TYPE_INUM  
33fd 28 03				jr z, .div_inum 
33ff			 
33ff				if FORTH_ENABLE_FLOATMATH 
33ff					jr .div_done 
33ff			 
33ff				endif 
33ff					NEXTW 
33ff c3 22 1d			jp macro_next 
3402				endm 
# End of macro NEXTW
3402			.div_inum: 
3402			 
3402					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3402 cd b0 1b			call macro_dsp_valuehl 
3405				endm 
# End of macro FORTH_DSP_VALUEHL
3405			 
3405 e5					push hl    ; to go to bc 
3406			 
3406					; destroy value TOS 
3406			 
3406					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3406 cd 68 1c			call macro_forth_dsp_pop 
3409				endm 
# End of macro FORTH_DSP_POP
3409			 
3409			 
3409					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3409 cd b0 1b			call macro_dsp_valuehl 
340c				endm 
# End of macro FORTH_DSP_VALUEHL
340c			 
340c					; hl to go to de 
340c			 
340c e5					push hl 
340d			 
340d c1					pop bc 
340e d1					pop de		 
340f			 
340f			 
340f					if DEBUG_FORTH_MATHS 
340f						DMARK "DIV" 
340f				CALLMONITOR 
340f					endif 
340f					; one value on hl but move to a get other one back 
340f			 
340f			        
340f cd 0f 0b			call Div16 
3412			 
3412			;	push af	 
3412 e5				push hl 
3413 c5				push bc 
3414			 
3414					if DEBUG_FORTH_MATHS 
3414						DMARK "DI1" 
3414				CALLMONITOR 
3414					endif 
3414			 
3414					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3414 cd 68 1c			call macro_forth_dsp_pop 
3417				endm 
# End of macro FORTH_DSP_POP
3417			 
3417			 
3417			 
3417 e1					pop hl    ; result 
3418			 
3418 cd b9 19				call forth_push_numhl 
341b			 
341b e1					pop hl    ; reminder 
341c			;		ld h,0 
341c			;		ld l,d 
341c			 
341c cd b9 19				call forth_push_numhl 
341f			.div_done: 
341f					NEXTW 
341f c3 22 1d			jp macro_next 
3422				endm 
# End of macro NEXTW
3422			.MUL: 
3422				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3422 19				db WORD_SYS_CORE+5             
3423 67 34			dw .MIN            
3425 02				db 1 + 1 
3426 .. 00			db "*",0              
3428				endm 
# End of macro CWHEAD
3428			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3428				; TODO add floating point number detection 
3428					if DEBUG_FORTH_WORDS_KEY 
3428						DMARK "MUL" 
3428 f5				push af  
3429 3a 3d 34			ld a, (.dmark)  
342c 32 7a ee			ld (debug_mark),a  
342f 3a 3e 34			ld a, (.dmark+1)  
3432 32 7b ee			ld (debug_mark+1),a  
3435 3a 3f 34			ld a, (.dmark+2)  
3438 32 7c ee			ld (debug_mark+2),a  
343b 18 03			jr .pastdmark  
343d ..			.dmark: db "MUL"  
3440 f1			.pastdmark: pop af  
3441			endm  
# End of macro DMARK
3441						CALLMONITOR 
3441 cd 2c 14			call break_point_state  
3444				endm  
# End of macro CALLMONITOR
3444					endif 
3444					FORTH_DSP 
3444 cd 76 1b			call macro_forth_dsp 
3447				endm 
# End of macro FORTH_DSP
3447					; v5 FORTH_DSP_VALUE 
3447 7e					ld a,(hl)	; get type of value on TOS 
3448 fe 02				cp DS_TYPE_INUM  
344a 28 03				jr z, .mul_inum 
344c			 
344c				if FORTH_ENABLE_FLOATMATH 
344c					jr .mul_done 
344c			 
344c				endif 
344c			 
344c					NEXTW 
344c c3 22 1d			jp macro_next 
344f				endm 
# End of macro NEXTW
344f			.mul_inum:	 
344f			 
344f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
344f cd b0 1b			call macro_dsp_valuehl 
3452				endm 
# End of macro FORTH_DSP_VALUEHL
3452			 
3452 e5					push hl 
3453			 
3453					; destroy value TOS 
3453			 
3453					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3453 cd 68 1c			call macro_forth_dsp_pop 
3456				endm 
# End of macro FORTH_DSP_POP
3456			 
3456			 
3456					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3456 cd b0 1b			call macro_dsp_valuehl 
3459				endm 
# End of macro FORTH_DSP_VALUEHL
3459			 
3459					; one value on hl but move to a get other one back 
3459			 
3459 7d					ld a, l 
345a			 
345a d1					pop de 
345b			 
345b					; do the mull 
345b			;		ex de, hl 
345b			 
345b cd 35 0b				call Mult16 
345e					; save it 
345e			 
345e			;		push hl	 
345e			 
345e					; 
345e			 
345e					; destroy value TOS 
345e			 
345e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
345e cd 68 1c			call macro_forth_dsp_pop 
3461				endm 
# End of macro FORTH_DSP_POP
3461			 
3461					; TODO push value back onto stack for another op etc 
3461			 
3461			;		pop hl 
3461			 
3461 cd b9 19				call forth_push_numhl 
3464			 
3464			.mul_done: 
3464					NEXTW 
3464 c3 22 1d			jp macro_next 
3467				endm 
# End of macro NEXTW
3467			 
3467			 
3467			 
3467			 
3467			.MIN: 
3467				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3467 49				db WORD_SYS_CORE+53             
3468 e8 34			dw .MAX            
346a 04				db 3 + 1 
346b .. 00			db "MIN",0              
346f				endm 
# End of macro CWHEAD
346f			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
346f					if DEBUG_FORTH_WORDS_KEY 
346f						DMARK "MIN" 
346f f5				push af  
3470 3a 84 34			ld a, (.dmark)  
3473 32 7a ee			ld (debug_mark),a  
3476 3a 85 34			ld a, (.dmark+1)  
3479 32 7b ee			ld (debug_mark+1),a  
347c 3a 86 34			ld a, (.dmark+2)  
347f 32 7c ee			ld (debug_mark+2),a  
3482 18 03			jr .pastdmark  
3484 ..			.dmark: db "MIN"  
3487 f1			.pastdmark: pop af  
3488			endm  
# End of macro DMARK
3488						CALLMONITOR 
3488 cd 2c 14			call break_point_state  
348b				endm  
# End of macro CALLMONITOR
348b					endif 
348b					; get u2 
348b			 
348b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
348b cd b0 1b			call macro_dsp_valuehl 
348e				endm 
# End of macro FORTH_DSP_VALUEHL
348e			 
348e e5					push hl   ; u2 
348f			 
348f					; destroy value TOS 
348f			 
348f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
348f cd 68 1c			call macro_forth_dsp_pop 
3492				endm 
# End of macro FORTH_DSP_POP
3492			 
3492					; get u1 
3492			 
3492					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3492 cd b0 1b			call macro_dsp_valuehl 
3495				endm 
# End of macro FORTH_DSP_VALUEHL
3495			 
3495 e5					push hl  ; u1 
3496			 
3496					; destroy value TOS 
3496			 
3496					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3496 cd 68 1c			call macro_forth_dsp_pop 
3499				endm 
# End of macro FORTH_DSP_POP
3499			 
3499 b7			 or a      ;clear carry flag 
349a e1			  pop hl    ; u1 
349b d1			  pop de    ; u2 
349c e5				push hl   ; saved in case hl is lowest 
349d ed 52		  sbc hl,de 
349f 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
34a1			 
34a1 e1				pop hl 
34a2					if DEBUG_FORTH_WORDS 
34a2						DMARK "MIN" 
34a2 f5				push af  
34a3 3a b7 34			ld a, (.dmark)  
34a6 32 7a ee			ld (debug_mark),a  
34a9 3a b8 34			ld a, (.dmark+1)  
34ac 32 7b ee			ld (debug_mark+1),a  
34af 3a b9 34			ld a, (.dmark+2)  
34b2 32 7c ee			ld (debug_mark+2),a  
34b5 18 03			jr .pastdmark  
34b7 ..			.dmark: db "MIN"  
34ba f1			.pastdmark: pop af  
34bb			endm  
# End of macro DMARK
34bb						CALLMONITOR 
34bb cd 2c 14			call break_point_state  
34be				endm  
# End of macro CALLMONITOR
34be					endif 
34be cd b9 19				call forth_push_numhl 
34c1			 
34c1				       NEXTW 
34c1 c3 22 1d			jp macro_next 
34c4				endm 
# End of macro NEXTW
34c4			 
34c4			.mincont:  
34c4 c1				pop bc   ; tidy up 
34c5 eb				ex de , hl  
34c6					if DEBUG_FORTH_WORDS 
34c6						DMARK "MI1" 
34c6 f5				push af  
34c7 3a db 34			ld a, (.dmark)  
34ca 32 7a ee			ld (debug_mark),a  
34cd 3a dc 34			ld a, (.dmark+1)  
34d0 32 7b ee			ld (debug_mark+1),a  
34d3 3a dd 34			ld a, (.dmark+2)  
34d6 32 7c ee			ld (debug_mark+2),a  
34d9 18 03			jr .pastdmark  
34db ..			.dmark: db "MI1"  
34de f1			.pastdmark: pop af  
34df			endm  
# End of macro DMARK
34df						CALLMONITOR 
34df cd 2c 14			call break_point_state  
34e2				endm  
# End of macro CALLMONITOR
34e2					endif 
34e2 cd b9 19				call forth_push_numhl 
34e5			 
34e5				       NEXTW 
34e5 c3 22 1d			jp macro_next 
34e8				endm 
# End of macro NEXTW
34e8			.MAX: 
34e8				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
34e8 4a				db WORD_SYS_CORE+54             
34e9 69 35			dw .RND16            
34eb 04				db 3 + 1 
34ec .. 00			db "MAX",0              
34f0				endm 
# End of macro CWHEAD
34f0			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
34f0					if DEBUG_FORTH_WORDS_KEY 
34f0						DMARK "MAX" 
34f0 f5				push af  
34f1 3a 05 35			ld a, (.dmark)  
34f4 32 7a ee			ld (debug_mark),a  
34f7 3a 06 35			ld a, (.dmark+1)  
34fa 32 7b ee			ld (debug_mark+1),a  
34fd 3a 07 35			ld a, (.dmark+2)  
3500 32 7c ee			ld (debug_mark+2),a  
3503 18 03			jr .pastdmark  
3505 ..			.dmark: db "MAX"  
3508 f1			.pastdmark: pop af  
3509			endm  
# End of macro DMARK
3509						CALLMONITOR 
3509 cd 2c 14			call break_point_state  
350c				endm  
# End of macro CALLMONITOR
350c					endif 
350c					; get u2 
350c			 
350c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
350c cd b0 1b			call macro_dsp_valuehl 
350f				endm 
# End of macro FORTH_DSP_VALUEHL
350f			 
350f e5					push hl   ; u2 
3510			 
3510					; destroy value TOS 
3510			 
3510					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3510 cd 68 1c			call macro_forth_dsp_pop 
3513				endm 
# End of macro FORTH_DSP_POP
3513			 
3513					; get u1 
3513			 
3513					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3513 cd b0 1b			call macro_dsp_valuehl 
3516				endm 
# End of macro FORTH_DSP_VALUEHL
3516			 
3516 e5					push hl  ; u1 
3517			 
3517					; destroy value TOS 
3517			 
3517					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3517 cd 68 1c			call macro_forth_dsp_pop 
351a				endm 
# End of macro FORTH_DSP_POP
351a			 
351a b7			 or a      ;clear carry flag 
351b e1			  pop hl    ; u1 
351c d1			  pop de    ; u2 
351d e5				push hl   ; saved in case hl is lowest 
351e ed 52		  sbc hl,de 
3520 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3522			 
3522 e1				pop hl 
3523					if DEBUG_FORTH_WORDS 
3523						DMARK "MAX" 
3523 f5				push af  
3524 3a 38 35			ld a, (.dmark)  
3527 32 7a ee			ld (debug_mark),a  
352a 3a 39 35			ld a, (.dmark+1)  
352d 32 7b ee			ld (debug_mark+1),a  
3530 3a 3a 35			ld a, (.dmark+2)  
3533 32 7c ee			ld (debug_mark+2),a  
3536 18 03			jr .pastdmark  
3538 ..			.dmark: db "MAX"  
353b f1			.pastdmark: pop af  
353c			endm  
# End of macro DMARK
353c						CALLMONITOR 
353c cd 2c 14			call break_point_state  
353f				endm  
# End of macro CALLMONITOR
353f					endif 
353f cd b9 19				call forth_push_numhl 
3542			 
3542				       NEXTW 
3542 c3 22 1d			jp macro_next 
3545				endm 
# End of macro NEXTW
3545			 
3545			.maxcont:  
3545 c1				pop bc   ; tidy up 
3546 eb				ex de , hl  
3547					if DEBUG_FORTH_WORDS 
3547						DMARK "MA1" 
3547 f5				push af  
3548 3a 5c 35			ld a, (.dmark)  
354b 32 7a ee			ld (debug_mark),a  
354e 3a 5d 35			ld a, (.dmark+1)  
3551 32 7b ee			ld (debug_mark+1),a  
3554 3a 5e 35			ld a, (.dmark+2)  
3557 32 7c ee			ld (debug_mark+2),a  
355a 18 03			jr .pastdmark  
355c ..			.dmark: db "MA1"  
355f f1			.pastdmark: pop af  
3560			endm  
# End of macro DMARK
3560						CALLMONITOR 
3560 cd 2c 14			call break_point_state  
3563				endm  
# End of macro CALLMONITOR
3563					endif 
3563 cd b9 19				call forth_push_numhl 
3566				       NEXTW 
3566 c3 22 1d			jp macro_next 
3569				endm 
# End of macro NEXTW
3569			 
3569			.RND16: 
3569				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3569 4e				db WORD_SYS_CORE+58             
356a 98 35			dw .RND8            
356c 06				db 5 + 1 
356d .. 00			db "RND16",0              
3573				endm 
# End of macro CWHEAD
3573			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3573					if DEBUG_FORTH_WORDS_KEY 
3573						DMARK "R16" 
3573 f5				push af  
3574 3a 88 35			ld a, (.dmark)  
3577 32 7a ee			ld (debug_mark),a  
357a 3a 89 35			ld a, (.dmark+1)  
357d 32 7b ee			ld (debug_mark+1),a  
3580 3a 8a 35			ld a, (.dmark+2)  
3583 32 7c ee			ld (debug_mark+2),a  
3586 18 03			jr .pastdmark  
3588 ..			.dmark: db "R16"  
358b f1			.pastdmark: pop af  
358c			endm  
# End of macro DMARK
358c						CALLMONITOR 
358c cd 2c 14			call break_point_state  
358f				endm  
# End of macro CALLMONITOR
358f					endif 
358f cd d9 0a				call prng16  
3592 cd b9 19				call forth_push_numhl 
3595				       NEXTW 
3595 c3 22 1d			jp macro_next 
3598				endm 
# End of macro NEXTW
3598			.RND8: 
3598				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3598 60				db WORD_SYS_CORE+76             
3599 cd 35			dw .RND            
359b 05				db 4 + 1 
359c .. 00			db "RND8",0              
35a1				endm 
# End of macro CWHEAD
35a1			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
35a1					if DEBUG_FORTH_WORDS_KEY 
35a1						DMARK "RN8" 
35a1 f5				push af  
35a2 3a b6 35			ld a, (.dmark)  
35a5 32 7a ee			ld (debug_mark),a  
35a8 3a b7 35			ld a, (.dmark+1)  
35ab 32 7b ee			ld (debug_mark+1),a  
35ae 3a b8 35			ld a, (.dmark+2)  
35b1 32 7c ee			ld (debug_mark+2),a  
35b4 18 03			jr .pastdmark  
35b6 ..			.dmark: db "RN8"  
35b9 f1			.pastdmark: pop af  
35ba			endm  
# End of macro DMARK
35ba						CALLMONITOR 
35ba cd 2c 14			call break_point_state  
35bd				endm  
# End of macro CALLMONITOR
35bd					endif 
35bd 2a bb eb				ld hl,(xrandc) 
35c0 23					inc hl 
35c1 cd f3 0a				call xrnd 
35c4 6f					ld l,a	 
35c5 26 00				ld h,0 
35c7 cd b9 19				call forth_push_numhl 
35ca				       NEXTW 
35ca c3 22 1d			jp macro_next 
35cd				endm 
# End of macro NEXTW
35cd			.RND: 
35cd				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
35cd 60				db WORD_SYS_CORE+76             
35ce d3 36			dw .ENDMATHS            
35d0 04				db 3 + 1 
35d1 .. 00			db "RND",0              
35d5				endm 
# End of macro CWHEAD
35d5			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
35d5			 
35d5					if DEBUG_FORTH_WORDS_KEY 
35d5						DMARK "RND" 
35d5 f5				push af  
35d6 3a ea 35			ld a, (.dmark)  
35d9 32 7a ee			ld (debug_mark),a  
35dc 3a eb 35			ld a, (.dmark+1)  
35df 32 7b ee			ld (debug_mark+1),a  
35e2 3a ec 35			ld a, (.dmark+2)  
35e5 32 7c ee			ld (debug_mark+2),a  
35e8 18 03			jr .pastdmark  
35ea ..			.dmark: db "RND"  
35ed f1			.pastdmark: pop af  
35ee			endm  
# End of macro DMARK
35ee						CALLMONITOR 
35ee cd 2c 14			call break_point_state  
35f1				endm  
# End of macro CALLMONITOR
35f1					endif 
35f1					 
35f1					FORTH_DSP_VALUEHL    ; upper range 
35f1 cd b0 1b			call macro_dsp_valuehl 
35f4				endm 
# End of macro FORTH_DSP_VALUEHL
35f4			 
35f4 22 bf eb				ld (LFSRSeed), hl	 
35f7			 
35f7					if DEBUG_FORTH_WORDS 
35f7						DMARK "RN1" 
35f7 f5				push af  
35f8 3a 0c 36			ld a, (.dmark)  
35fb 32 7a ee			ld (debug_mark),a  
35fe 3a 0d 36			ld a, (.dmark+1)  
3601 32 7b ee			ld (debug_mark+1),a  
3604 3a 0e 36			ld a, (.dmark+2)  
3607 32 7c ee			ld (debug_mark+2),a  
360a 18 03			jr .pastdmark  
360c ..			.dmark: db "RN1"  
360f f1			.pastdmark: pop af  
3610			endm  
# End of macro DMARK
3610						CALLMONITOR 
3610 cd 2c 14			call break_point_state  
3613				endm  
# End of macro CALLMONITOR
3613					endif 
3613					FORTH_DSP_POP 
3613 cd 68 1c			call macro_forth_dsp_pop 
3616				endm 
# End of macro FORTH_DSP_POP
3616			 
3616					FORTH_DSP_VALUEHL    ; low range 
3616 cd b0 1b			call macro_dsp_valuehl 
3619				endm 
# End of macro FORTH_DSP_VALUEHL
3619			 
3619					if DEBUG_FORTH_WORDS 
3619						DMARK "RN2" 
3619 f5				push af  
361a 3a 2e 36			ld a, (.dmark)  
361d 32 7a ee			ld (debug_mark),a  
3620 3a 2f 36			ld a, (.dmark+1)  
3623 32 7b ee			ld (debug_mark+1),a  
3626 3a 30 36			ld a, (.dmark+2)  
3629 32 7c ee			ld (debug_mark+2),a  
362c 18 03			jr .pastdmark  
362e ..			.dmark: db "RN2"  
3631 f1			.pastdmark: pop af  
3632			endm  
# End of macro DMARK
3632						CALLMONITOR 
3632 cd 2c 14			call break_point_state  
3635				endm  
# End of macro CALLMONITOR
3635					endif 
3635 22 c1 eb				ld (LFSRSeed+2), hl 
3638			 
3638					FORTH_DSP_POP 
3638 cd 68 1c			call macro_forth_dsp_pop 
363b				endm 
# End of macro FORTH_DSP_POP
363b			 
363b e5					push hl 
363c			 
363c e1			.inrange:	pop hl 
363d cd d9 0a				call prng16  
3640					if DEBUG_FORTH_WORDS 
3640						DMARK "RN3" 
3640 f5				push af  
3641 3a 55 36			ld a, (.dmark)  
3644 32 7a ee			ld (debug_mark),a  
3647 3a 56 36			ld a, (.dmark+1)  
364a 32 7b ee			ld (debug_mark+1),a  
364d 3a 57 36			ld a, (.dmark+2)  
3650 32 7c ee			ld (debug_mark+2),a  
3653 18 03			jr .pastdmark  
3655 ..			.dmark: db "RN3"  
3658 f1			.pastdmark: pop af  
3659			endm  
# End of macro DMARK
3659						CALLMONITOR 
3659 cd 2c 14			call break_point_state  
365c				endm  
# End of macro CALLMONITOR
365c					endif 
365c					 
365c					; if the range is 8bit knock out the high byte 
365c			 
365c ed 5b bf eb			ld de, (LFSRSeed)     ; check high level 
3660			 
3660 3e 00				ld a, 0 
3662 ba					cp d  
3663 20 1e				jr nz, .hirange 
3665 26 00				ld h, 0   ; knock it down to 8bit 
3667			 
3667					if DEBUG_FORTH_WORDS 
3667						DMARK "RNk" 
3667 f5				push af  
3668 3a 7c 36			ld a, (.dmark)  
366b 32 7a ee			ld (debug_mark),a  
366e 3a 7d 36			ld a, (.dmark+1)  
3671 32 7b ee			ld (debug_mark+1),a  
3674 3a 7e 36			ld a, (.dmark+2)  
3677 32 7c ee			ld (debug_mark+2),a  
367a 18 03			jr .pastdmark  
367c ..			.dmark: db "RNk"  
367f f1			.pastdmark: pop af  
3680			endm  
# End of macro DMARK
3680						CALLMONITOR 
3680 cd 2c 14			call break_point_state  
3683				endm  
# End of macro CALLMONITOR
3683					endif 
3683			.hirange:   
3683 e5					push hl  
3684 b7					or a  
3685 ed 52		                sbc hl, de 
3687			 
3687					;call cmp16 
3687			 
3687 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3689 e1					pop hl 
368a e5					push hl 
368b			 
368b					if DEBUG_FORTH_WORDS 
368b						DMARK "RN4" 
368b f5				push af  
368c 3a a0 36			ld a, (.dmark)  
368f 32 7a ee			ld (debug_mark),a  
3692 3a a1 36			ld a, (.dmark+1)  
3695 32 7b ee			ld (debug_mark+1),a  
3698 3a a2 36			ld a, (.dmark+2)  
369b 32 7c ee			ld (debug_mark+2),a  
369e 18 03			jr .pastdmark  
36a0 ..			.dmark: db "RN4"  
36a3 f1			.pastdmark: pop af  
36a4			endm  
# End of macro DMARK
36a4						CALLMONITOR 
36a4 cd 2c 14			call break_point_state  
36a7				endm  
# End of macro CALLMONITOR
36a7					endif 
36a7 ed 5b c1 eb			ld de, (LFSRSeed+2)   ; check low range 
36ab					;call cmp16 
36ab				 
36ab b7					or a  
36ac ed 52		                sbc hl, de 
36ae 38 8c				jr c, .inrange 
36b0			 
36b0 e1					pop hl 
36b1					 
36b1					if DEBUG_FORTH_WORDS 
36b1						DMARK "RNd" 
36b1 f5				push af  
36b2 3a c6 36			ld a, (.dmark)  
36b5 32 7a ee			ld (debug_mark),a  
36b8 3a c7 36			ld a, (.dmark+1)  
36bb 32 7b ee			ld (debug_mark+1),a  
36be 3a c8 36			ld a, (.dmark+2)  
36c1 32 7c ee			ld (debug_mark+2),a  
36c4 18 03			jr .pastdmark  
36c6 ..			.dmark: db "RNd"  
36c9 f1			.pastdmark: pop af  
36ca			endm  
# End of macro DMARK
36ca						CALLMONITOR 
36ca cd 2c 14			call break_point_state  
36cd				endm  
# End of macro CALLMONITOR
36cd					endif 
36cd			 
36cd			 
36cd cd b9 19				call forth_push_numhl 
36d0				       NEXTW 
36d0 c3 22 1d			jp macro_next 
36d3				endm 
# End of macro NEXTW
36d3			 
36d3			.ENDMATHS: 
36d3			 
36d3			; eof 
36d3			 
# End of file forth_words_maths.asm
36d3			include "forth_words_display.asm" 
36d3			 
36d3			; | ## Display Words 
36d3			 
36d3			.ATP: 
36d3				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
36d3 62				db WORD_SYS_CORE+78             
36d4 4a 37			dw .FB            
36d6 04				db 3 + 1 
36d7 .. 00			db "AT?",0              
36db				endm 
# End of macro CWHEAD
36db			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
36db					if DEBUG_FORTH_WORDS_KEY 
36db						DMARK "AT?" 
36db f5				push af  
36dc 3a f0 36			ld a, (.dmark)  
36df 32 7a ee			ld (debug_mark),a  
36e2 3a f1 36			ld a, (.dmark+1)  
36e5 32 7b ee			ld (debug_mark+1),a  
36e8 3a f2 36			ld a, (.dmark+2)  
36eb 32 7c ee			ld (debug_mark+2),a  
36ee 18 03			jr .pastdmark  
36f0 ..			.dmark: db "AT?"  
36f3 f1			.pastdmark: pop af  
36f4			endm  
# End of macro DMARK
36f4						CALLMONITOR 
36f4 cd 2c 14			call break_point_state  
36f7				endm  
# End of macro CALLMONITOR
36f7					endif 
36f7 3a 49 eb				ld a, (f_cursor_ptr) 
36fa			 
36fa			if DEBUG_FORTH_WORDS 
36fa				DMARK "AT?" 
36fa f5				push af  
36fb 3a 0f 37			ld a, (.dmark)  
36fe 32 7a ee			ld (debug_mark),a  
3701 3a 10 37			ld a, (.dmark+1)  
3704 32 7b ee			ld (debug_mark+1),a  
3707 3a 11 37			ld a, (.dmark+2)  
370a 32 7c ee			ld (debug_mark+2),a  
370d 18 03			jr .pastdmark  
370f ..			.dmark: db "AT?"  
3712 f1			.pastdmark: pop af  
3713			endm  
# End of macro DMARK
3713				CALLMONITOR 
3713 cd 2c 14			call break_point_state  
3716				endm  
# End of macro CALLMONITOR
3716			endif	 
3716					; count the number of rows 
3716			 
3716 06 00				ld b, 0 
3718 4f			.atpr:		ld c, a    ; save in case we go below zero 
3719 d6 28				sub display_cols 
371b f2 21 37				jp p, .atprunder 
371e 04					inc b 
371f 18 f7				jr .atpr 
3721			.atprunder:	 
3721			if DEBUG_FORTH_WORDS 
3721				DMARK "A?2" 
3721 f5				push af  
3722 3a 36 37			ld a, (.dmark)  
3725 32 7a ee			ld (debug_mark),a  
3728 3a 37 37			ld a, (.dmark+1)  
372b 32 7b ee			ld (debug_mark+1),a  
372e 3a 38 37			ld a, (.dmark+2)  
3731 32 7c ee			ld (debug_mark+2),a  
3734 18 03			jr .pastdmark  
3736 ..			.dmark: db "A?2"  
3739 f1			.pastdmark: pop af  
373a			endm  
# End of macro DMARK
373a				CALLMONITOR 
373a cd 2c 14			call break_point_state  
373d				endm  
# End of macro CALLMONITOR
373d			endif	 
373d 26 00				ld h, 0 
373f 69					ld l, c 
3740 cd b9 19				call forth_push_numhl 
3743 68					ld l, b  
3744 cd b9 19				call forth_push_numhl 
3747			 
3747			 
3747				NEXTW 
3747 c3 22 1d			jp macro_next 
374a				endm 
# End of macro NEXTW
374a			 
374a			.FB: 
374a				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
374a 1b				db WORD_SYS_CORE+7             
374b 98 37			dw .EMIT            
374d 03				db 2 + 1 
374e .. 00			db "FB",0              
3751				endm 
# End of macro CWHEAD
3751			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3751			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3751			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3751			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3751					if DEBUG_FORTH_WORDS_KEY 
3751						DMARK "FB." 
3751 f5				push af  
3752 3a 66 37			ld a, (.dmark)  
3755 32 7a ee			ld (debug_mark),a  
3758 3a 67 37			ld a, (.dmark+1)  
375b 32 7b ee			ld (debug_mark+1),a  
375e 3a 68 37			ld a, (.dmark+2)  
3761 32 7c ee			ld (debug_mark+2),a  
3764 18 03			jr .pastdmark  
3766 ..			.dmark: db "FB."  
3769 f1			.pastdmark: pop af  
376a			endm  
# End of macro DMARK
376a						CALLMONITOR 
376a cd 2c 14			call break_point_state  
376d				endm  
# End of macro CALLMONITOR
376d					endif 
376d			 
376d					FORTH_DSP_VALUEHL 
376d cd b0 1b			call macro_dsp_valuehl 
3770				endm 
# End of macro FORTH_DSP_VALUEHL
3770			 
3770 7d					ld a, l 
3771 fe 01				cp 1 
3773 20 05				jr nz, .fbn1 
3775 21 1f ed				ld hl, display_fb1 
3778 18 15				jr .fbset 
377a fe 02		.fbn1:		cp 2 
377c 20 05				jr nz, .fbn2 
377e 21 dd eb				ld hl, display_fb2 
3781 18 0c				jr .fbset 
3783 fe 03		.fbn2:		cp 3 
3785 20 05				jr nz, .fbn3 
3787 21 7e ec				ld hl, display_fb3 
378a 18 03				jr .fbset 
378c			.fbn3:		 ; if invalid number select first 
378c 21 1f ed				ld hl, display_fb1 
378f 22 db eb		.fbset:		ld (display_fb_active), hl 
3792			 
3792					FORTH_DSP_POP 
3792 cd 68 1c			call macro_forth_dsp_pop 
3795				endm 
# End of macro FORTH_DSP_POP
3795			 
3795					NEXTW 
3795 c3 22 1d			jp macro_next 
3798				endm 
# End of macro NEXTW
3798			 
3798			 
3798			.EMIT: 
3798				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3798 1b				db WORD_SYS_CORE+7             
3799 e9 37			dw .DOTH            
379b 05				db 4 + 1 
379c .. 00			db "EMIT",0              
37a1				endm 
# End of macro CWHEAD
37a1			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
37a1					; get value off TOS and display it 
37a1			 
37a1					if DEBUG_FORTH_WORDS_KEY 
37a1						DMARK "EMT" 
37a1 f5				push af  
37a2 3a b6 37			ld a, (.dmark)  
37a5 32 7a ee			ld (debug_mark),a  
37a8 3a b7 37			ld a, (.dmark+1)  
37ab 32 7b ee			ld (debug_mark+1),a  
37ae 3a b8 37			ld a, (.dmark+2)  
37b1 32 7c ee			ld (debug_mark+2),a  
37b4 18 03			jr .pastdmark  
37b6 ..			.dmark: db "EMT"  
37b9 f1			.pastdmark: pop af  
37ba			endm  
# End of macro DMARK
37ba						CALLMONITOR 
37ba cd 2c 14			call break_point_state  
37bd				endm  
# End of macro CALLMONITOR
37bd					endif 
37bd			 
37bd					FORTH_DSP_VALUEHL 
37bd cd b0 1b			call macro_dsp_valuehl 
37c0				endm 
# End of macro FORTH_DSP_VALUEHL
37c0			 
37c0 7d					ld a,l 
37c1			 
37c1					; TODO write to display 
37c1			 
37c1 32 5e e5				ld (os_input), a 
37c4 3e 00				ld a, 0 
37c6 32 5f e5				ld (os_input+1), a 
37c9					 
37c9 3a 49 eb				ld a, (f_cursor_ptr) 
37cc 11 5e e5				ld de, os_input 
37cf cd 98 09				call str_at_display 
37d2			 
37d2			 
37d2 3a 27 eb				ld a,(cli_autodisplay) 
37d5 fe 00				cp 0 
37d7 28 03				jr z, .enoupdate 
37d9 cd a8 09						call update_display 
37dc					.enoupdate: 
37dc			 
37dc 3a 49 eb				ld a, (f_cursor_ptr) 
37df 3c					inc a 
37e0 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
37e3			 
37e3			 
37e3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37e3 cd 68 1c			call macro_forth_dsp_pop 
37e6				endm 
# End of macro FORTH_DSP_POP
37e6			  
37e6			 
37e6					NEXTW 
37e6 c3 22 1d			jp macro_next 
37e9				endm 
# End of macro NEXTW
37e9			.DOTH: 
37e9				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
37e9 1c				db WORD_SYS_CORE+8             
37ea 19 38			dw .DOTF            
37ec 03				db 2 + 1 
37ed .. 00			db ".-",0              
37f0				endm 
# End of macro CWHEAD
37f0			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
37f0					; get value off TOS and display it 
37f0					if DEBUG_FORTH_WORDS_KEY 
37f0						DMARK "DTD" 
37f0 f5				push af  
37f1 3a 05 38			ld a, (.dmark)  
37f4 32 7a ee			ld (debug_mark),a  
37f7 3a 06 38			ld a, (.dmark+1)  
37fa 32 7b ee			ld (debug_mark+1),a  
37fd 3a 07 38			ld a, (.dmark+2)  
3800 32 7c ee			ld (debug_mark+2),a  
3803 18 03			jr .pastdmark  
3805 ..			.dmark: db "DTD"  
3808 f1			.pastdmark: pop af  
3809			endm  
# End of macro DMARK
3809						CALLMONITOR 
3809 cd 2c 14			call break_point_state  
380c				endm  
# End of macro CALLMONITOR
380c					endif 
380c 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
380e 3e 00			ld a, 0 
3810 32 28 eb			ld (cli_mvdot), a 
3813 c3 70 38			jp .dotgo 
3816				NEXTW 
3816 c3 22 1d			jp macro_next 
3819				endm 
# End of macro NEXTW
3819			.DOTF: 
3819				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3819 1c				db WORD_SYS_CORE+8             
381a 47 38			dw .DOT            
381c 03				db 2 + 1 
381d .. 00			db ".>",0              
3820				endm 
# End of macro CWHEAD
3820			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3820					; get value off TOS and display it 
3820			        ; TODO BUG adds extra spaces 
3820			        ; TODO BUG handle numerics? 
3820					if DEBUG_FORTH_WORDS_KEY 
3820						DMARK "DTC" 
3820 f5				push af  
3821 3a 35 38			ld a, (.dmark)  
3824 32 7a ee			ld (debug_mark),a  
3827 3a 36 38			ld a, (.dmark+1)  
382a 32 7b ee			ld (debug_mark+1),a  
382d 3a 37 38			ld a, (.dmark+2)  
3830 32 7c ee			ld (debug_mark+2),a  
3833 18 03			jr .pastdmark  
3835 ..			.dmark: db "DTC"  
3838 f1			.pastdmark: pop af  
3839			endm  
# End of macro DMARK
3839						CALLMONITOR 
3839 cd 2c 14			call break_point_state  
383c				endm  
# End of macro CALLMONITOR
383c					endif 
383c 3e 01			ld a, 1 
383e 32 28 eb			ld (cli_mvdot), a 
3841 c3 70 38			jp .dotgo 
3844				NEXTW 
3844 c3 22 1d			jp macro_next 
3847				endm 
# End of macro NEXTW
3847			 
3847			.DOT: 
3847				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3847 1c				db WORD_SYS_CORE+8             
3848 d3 38			dw .CLS            
384a 02				db 1 + 1 
384b .. 00			db ".",0              
384d				endm 
# End of macro CWHEAD
384d			        ; | . ( u -- ) Display TOS | DONE 
384d					; get value off TOS and display it 
384d			 
384d					if DEBUG_FORTH_WORDS_KEY 
384d						DMARK "DOT" 
384d f5				push af  
384e 3a 62 38			ld a, (.dmark)  
3851 32 7a ee			ld (debug_mark),a  
3854 3a 63 38			ld a, (.dmark+1)  
3857 32 7b ee			ld (debug_mark+1),a  
385a 3a 64 38			ld a, (.dmark+2)  
385d 32 7c ee			ld (debug_mark+2),a  
3860 18 03			jr .pastdmark  
3862 ..			.dmark: db "DOT"  
3865 f1			.pastdmark: pop af  
3866			endm  
# End of macro DMARK
3866						CALLMONITOR 
3866 cd 2c 14			call break_point_state  
3869				endm  
# End of macro CALLMONITOR
3869					endif 
3869 3e 00			ld a, 0 
386b 32 28 eb			ld (cli_mvdot), a 
386e 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3870				 
3870			 
3870			.dotgo: 
3870			 
3870			; move up type to on stack for parserv5 
3870					FORTH_DSP 
3870 cd 76 1b			call macro_forth_dsp 
3873				endm 
# End of macro FORTH_DSP
3873				;FORTH_DSP_VALUE  
3873			 
3873			if DEBUG_FORTH_DOT 
3873				DMARK "DOT" 
3873				CALLMONITOR 
3873			endif	 
3873			;		.print: 
3873			 
3873 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3874 23				inc hl   ; position to the actual value 
3875 fe 01			cp DS_TYPE_STR 
3877 20 06			jr nz, .dotnum1  
3879			 
3879			; display string 
3879				FORTH_DSP_VALUE  
3879 cd 99 1b			call macro_forth_dsp_value 
387c				endm 
# End of macro FORTH_DSP_VALUE
387c eb				ex de,hl 
387d 18 11			jr .dotwrite 
387f			 
387f			.dotnum1: 
387f fe 02			cp DS_TYPE_INUM 
3881 20 0c			jr nz, .dotflot 
3883			 
3883			 
3883			; display number 
3883			 
3883			;	push hl 
3883			;	call clear_display 
3883			;	pop hl 
3883			 
3883 5e				ld e, (hl) 
3884 23				inc hl 
3885 56				ld d, (hl) 
3886 21 60 e3			ld hl, scratch 
3889			if DEBUG_FORTH_DOT 
3889				DMARK "DT1" 
3889				CALLMONITOR 
3889			endif	 
3889			 
3889 cd bf 0f			call uitoa_16 
388c eb				ex de,hl 
388d			 
388d			if DEBUG_FORTH_DOT 
388d				DMARK "DT2" 
388d				CALLMONITOR 
388d			endif	 
388d			 
388d			;	ld de, os_word_scratch 
388d 18 01			jr .dotwrite 
388f			 
388f 00			.dotflot:   nop 
3890			; TODO print floating point number 
3890			 
3890			.dotwrite:		 
3890			 
3890					; if c is set then set all '-' to spaces 
3890					; need to also take into account .>  
3890			 
3890 3e 01				ld a, 1 
3892 b9					cp c 
3893 20 13				jr nz, .nodashswap 
3895			 
3895					; DE has the string to write, working with HL 
3895			 
3895 06 ff				ld b, 255 
3897 d5					push de 
3898 e1					pop hl 
3899			 
3899			if DEBUG_FORTH_DOT 
3899				DMARK "DT-" 
3899				CALLMONITOR 
3899			endif	 
3899 7e			.dashscan:	ld a, (hl) 
389a fe 00				cp 0 
389c 28 0a				jr z, .nodashswap 
389e fe 2d				cp '-' 
38a0 20 03				jr nz, .dashskip 
38a2 3e 20				ld a, ' ' 
38a4 77					ld (hl), a 
38a5 23			.dashskip:	inc hl 
38a6			if DEBUG_FORTH_DOT 
38a6				DMARK "D-2" 
38a6				CALLMONITOR 
38a6			endif	 
38a6 10 f1				djnz .dashscan 
38a8			 
38a8			if DEBUG_FORTH_DOT 
38a8				DMARK "D-1" 
38a8				CALLMONITOR 
38a8			endif	 
38a8			 
38a8			.nodashswap: 
38a8			 
38a8 e5					push hl   ; save string start in case we need to advance print 
38a9			 
38a9 3a 49 eb				ld a, (f_cursor_ptr) 
38ac cd 98 09				call str_at_display 
38af 3a 27 eb				ld a,(cli_autodisplay) 
38b2 fe 00				cp 0 
38b4 28 03				jr z, .noupdate 
38b6 cd a8 09						call update_display 
38b9					.noupdate: 
38b9			 
38b9			 
38b9					; see if we need to advance the print position 
38b9			 
38b9 e1					pop hl   ; get back string 
38ba			 
38ba 3a 28 eb				ld a, (cli_mvdot) 
38bd			if DEBUG_FORTH_DOT 
38bd					ld e,a 
38bd				DMARK "D>1" 
38bd				CALLMONITOR 
38bd			endif	 
38bd fe 00				cp 0 
38bf 28 0c				jr z, .noadv 
38c1					; yes, lets advance the print position 
38c1 3e 00				ld a, 0 
38c3 cd 1b 10				call strlent 
38c6 3a 49 eb				ld a, (f_cursor_ptr) 
38c9 85					add a,l 
38ca					;call addatohl 
38ca					;ld a, l 
38ca 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
38cd			 
38cd			if DEBUG_FORTH_DOT 
38cd				DMARK "D->" 
38cd				CALLMONITOR 
38cd			endif	 
38cd			 
38cd			.noadv:	 
38cd			 
38cd					if DEBUG_FORTH_DOT_WAIT 
38cd							call next_page_prompt 
38cd					endif	 
38cd			; TODO this pop off the stack causes a crash. i dont know why 
38cd			 
38cd			 
38cd			if DEBUG_FORTH_DOT 
38cd				DMARK "DTh" 
38cd				CALLMONITOR 
38cd			endif	 
38cd			 
38cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38cd cd 68 1c			call macro_forth_dsp_pop 
38d0				endm 
# End of macro FORTH_DSP_POP
38d0			 
38d0			if DEBUG_FORTH_DOT 
38d0				DMARK "DTi" 
38d0				CALLMONITOR 
38d0			endif	 
38d0			 
38d0			 
38d0					NEXTW 
38d0 c3 22 1d			jp macro_next 
38d3				endm 
# End of macro NEXTW
38d3			 
38d3			.CLS: 
38d3				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
38d3 35				db WORD_SYS_CORE+33             
38d4 00 39			dw .DRAW            
38d6 04				db 3 + 1 
38d7 .. 00			db "CLS",0              
38db				endm 
# End of macro CWHEAD
38db			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
38db					if DEBUG_FORTH_WORDS_KEY 
38db						DMARK "CLS" 
38db f5				push af  
38dc 3a f0 38			ld a, (.dmark)  
38df 32 7a ee			ld (debug_mark),a  
38e2 3a f1 38			ld a, (.dmark+1)  
38e5 32 7b ee			ld (debug_mark+1),a  
38e8 3a f2 38			ld a, (.dmark+2)  
38eb 32 7c ee			ld (debug_mark+2),a  
38ee 18 03			jr .pastdmark  
38f0 ..			.dmark: db "CLS"  
38f3 f1			.pastdmark: pop af  
38f4			endm  
# End of macro DMARK
38f4						CALLMONITOR 
38f4 cd 2c 14			call break_point_state  
38f7				endm  
# End of macro CALLMONITOR
38f7					endif 
38f7 cd 85 09				call clear_display 
38fa c3 0e 3a				jp .home		; and home cursor 
38fd					NEXTW 
38fd c3 22 1d			jp macro_next 
3900				endm 
# End of macro NEXTW
3900			 
3900			.DRAW: 
3900				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3900 36				db WORD_SYS_CORE+34             
3901 2b 39			dw .DUMP            
3903 05				db 4 + 1 
3904 .. 00			db "DRAW",0              
3909				endm 
# End of macro CWHEAD
3909			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3909					if DEBUG_FORTH_WORDS_KEY 
3909						DMARK "DRW" 
3909 f5				push af  
390a 3a 1e 39			ld a, (.dmark)  
390d 32 7a ee			ld (debug_mark),a  
3910 3a 1f 39			ld a, (.dmark+1)  
3913 32 7b ee			ld (debug_mark+1),a  
3916 3a 20 39			ld a, (.dmark+2)  
3919 32 7c ee			ld (debug_mark+2),a  
391c 18 03			jr .pastdmark  
391e ..			.dmark: db "DRW"  
3921 f1			.pastdmark: pop af  
3922			endm  
# End of macro DMARK
3922						CALLMONITOR 
3922 cd 2c 14			call break_point_state  
3925				endm  
# End of macro CALLMONITOR
3925					endif 
3925 cd a8 09				call update_display 
3928					NEXTW 
3928 c3 22 1d			jp macro_next 
392b				endm 
# End of macro NEXTW
392b			 
392b			.DUMP: 
392b				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
392b 37				db WORD_SYS_CORE+35             
392c 63 39			dw .CDUMP            
392e 05				db 4 + 1 
392f .. 00			db "DUMP",0              
3934				endm 
# End of macro CWHEAD
3934			; | DUMP ( x -- ) With address x display dump   | DONE 
3934			; TODO pop address to use off of the stack 
3934					if DEBUG_FORTH_WORDS_KEY 
3934						DMARK "DUM" 
3934 f5				push af  
3935 3a 49 39			ld a, (.dmark)  
3938 32 7a ee			ld (debug_mark),a  
393b 3a 4a 39			ld a, (.dmark+1)  
393e 32 7b ee			ld (debug_mark+1),a  
3941 3a 4b 39			ld a, (.dmark+2)  
3944 32 7c ee			ld (debug_mark+2),a  
3947 18 03			jr .pastdmark  
3949 ..			.dmark: db "DUM"  
394c f1			.pastdmark: pop af  
394d			endm  
# End of macro DMARK
394d						CALLMONITOR 
394d cd 2c 14			call break_point_state  
3950				endm  
# End of macro CALLMONITOR
3950					endif 
3950 cd 85 09				call clear_display 
3953			 
3953					; get address 
3953			 
3953					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3953 cd b0 1b			call macro_dsp_valuehl 
3956				endm 
# End of macro FORTH_DSP_VALUEHL
3956				 
3956					; save it for cdump 
3956			 
3956 22 83 e6				ld (os_cur_ptr),hl 
3959			 
3959					; destroy value TOS 
3959			 
3959					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3959 cd 68 1c			call macro_forth_dsp_pop 
395c				endm 
# End of macro FORTH_DSP_POP
395c			 
395c cd 39 18				call dumpcont	; skip old style of param parsing	 
395f c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3960					NEXTW 
3960 c3 22 1d			jp macro_next 
3963				endm 
# End of macro NEXTW
3963			.CDUMP: 
3963				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3963 38				db WORD_SYS_CORE+36             
3964 93 39			dw .DAT            
3966 06				db 5 + 1 
3967 .. 00			db "CDUMP",0              
396d				endm 
# End of macro CWHEAD
396d			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
396d					if DEBUG_FORTH_WORDS_KEY 
396d						DMARK "CDP" 
396d f5				push af  
396e 3a 82 39			ld a, (.dmark)  
3971 32 7a ee			ld (debug_mark),a  
3974 3a 83 39			ld a, (.dmark+1)  
3977 32 7b ee			ld (debug_mark+1),a  
397a 3a 84 39			ld a, (.dmark+2)  
397d 32 7c ee			ld (debug_mark+2),a  
3980 18 03			jr .pastdmark  
3982 ..			.dmark: db "CDP"  
3985 f1			.pastdmark: pop af  
3986			endm  
# End of macro DMARK
3986						CALLMONITOR 
3986 cd 2c 14			call break_point_state  
3989				endm  
# End of macro CALLMONITOR
3989					endif 
3989 cd 85 09				call clear_display 
398c cd 39 18				call dumpcont	 
398f c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3990					NEXTW 
3990 c3 22 1d			jp macro_next 
3993				endm 
# End of macro NEXTW
3993			 
3993			 
3993			 
3993			 
3993			.DAT: 
3993				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3993 3d				db WORD_SYS_CORE+41             
3994 e9 39			dw .HOME            
3996 03				db 2 + 1 
3997 .. 00			db "AT",0              
399a				endm 
# End of macro CWHEAD
399a			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
399a					if DEBUG_FORTH_WORDS_KEY 
399a						DMARK "AT." 
399a f5				push af  
399b 3a af 39			ld a, (.dmark)  
399e 32 7a ee			ld (debug_mark),a  
39a1 3a b0 39			ld a, (.dmark+1)  
39a4 32 7b ee			ld (debug_mark+1),a  
39a7 3a b1 39			ld a, (.dmark+2)  
39aa 32 7c ee			ld (debug_mark+2),a  
39ad 18 03			jr .pastdmark  
39af ..			.dmark: db "AT."  
39b2 f1			.pastdmark: pop af  
39b3			endm  
# End of macro DMARK
39b3						CALLMONITOR 
39b3 cd 2c 14			call break_point_state  
39b6				endm  
# End of macro CALLMONITOR
39b6					endif 
39b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39b6 cd b0 1b			call macro_dsp_valuehl 
39b9				endm 
# End of macro FORTH_DSP_VALUEHL
39b9			 
39b9			 
39b9					; TODO save cursor row 
39b9 7d					ld a,l 
39ba fe 02				cp 2 
39bc 20 04				jr nz, .crow3 
39be 3e 28				ld a, display_row_2 
39c0 18 12				jr .ccol1 
39c2 fe 03		.crow3:		cp 3 
39c4 20 04				jr nz, .crow4 
39c6 3e 50				ld a, display_row_3 
39c8 18 0a				jr .ccol1 
39ca fe 04		.crow4:		cp 4 
39cc 20 04				jr nz, .crow1 
39ce 3e 78				ld a, display_row_4 
39d0 18 02				jr .ccol1 
39d2 3e 00		.crow1:		ld a,display_row_1 
39d4 f5			.ccol1:		push af			; got row offset 
39d5 6f					ld l,a 
39d6 26 00				ld h,0 
39d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39d8 cd 68 1c			call macro_forth_dsp_pop 
39db				endm 
# End of macro FORTH_DSP_POP
39db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39db cd b0 1b			call macro_dsp_valuehl 
39de				endm 
# End of macro FORTH_DSP_VALUEHL
39de					; TODO save cursor col 
39de f1					pop af 
39df 85					add l		; add col offset 
39e0 32 49 eb				ld (f_cursor_ptr), a 
39e3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39e3 cd 68 1c			call macro_forth_dsp_pop 
39e6				endm 
# End of macro FORTH_DSP_POP
39e6			 
39e6					; calculate  
39e6			 
39e6					NEXTW 
39e6 c3 22 1d			jp macro_next 
39e9				endm 
# End of macro NEXTW
39e9			 
39e9			 
39e9			.HOME: 
39e9				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
39e9 41				db WORD_SYS_CORE+45             
39ea 16 3a			dw .SPACE            
39ec 05				db 4 + 1 
39ed .. 00			db "HOME",0              
39f2				endm 
# End of macro CWHEAD
39f2			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
39f2					if DEBUG_FORTH_WORDS_KEY 
39f2						DMARK "HOM" 
39f2 f5				push af  
39f3 3a 07 3a			ld a, (.dmark)  
39f6 32 7a ee			ld (debug_mark),a  
39f9 3a 08 3a			ld a, (.dmark+1)  
39fc 32 7b ee			ld (debug_mark+1),a  
39ff 3a 09 3a			ld a, (.dmark+2)  
3a02 32 7c ee			ld (debug_mark+2),a  
3a05 18 03			jr .pastdmark  
3a07 ..			.dmark: db "HOM"  
3a0a f1			.pastdmark: pop af  
3a0b			endm  
# End of macro DMARK
3a0b						CALLMONITOR 
3a0b cd 2c 14			call break_point_state  
3a0e				endm  
# End of macro CALLMONITOR
3a0e					endif 
3a0e 3e 00		.home:		ld a, 0		; and home cursor 
3a10 32 49 eb				ld (f_cursor_ptr), a 
3a13					NEXTW 
3a13 c3 22 1d			jp macro_next 
3a16				endm 
# End of macro NEXTW
3a16			 
3a16			 
3a16			.SPACE: 
3a16				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3a16 46				db WORD_SYS_CORE+50             
3a17 44 3a			dw .SPACES            
3a19 03				db 2 + 1 
3a1a .. 00			db "BL",0              
3a1d				endm 
# End of macro CWHEAD
3a1d			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3a1d					if DEBUG_FORTH_WORDS_KEY 
3a1d						DMARK "BL." 
3a1d f5				push af  
3a1e 3a 32 3a			ld a, (.dmark)  
3a21 32 7a ee			ld (debug_mark),a  
3a24 3a 33 3a			ld a, (.dmark+1)  
3a27 32 7b ee			ld (debug_mark+1),a  
3a2a 3a 34 3a			ld a, (.dmark+2)  
3a2d 32 7c ee			ld (debug_mark+2),a  
3a30 18 03			jr .pastdmark  
3a32 ..			.dmark: db "BL."  
3a35 f1			.pastdmark: pop af  
3a36			endm  
# End of macro DMARK
3a36						CALLMONITOR 
3a36 cd 2c 14			call break_point_state  
3a39				endm  
# End of macro CALLMONITOR
3a39					endif 
3a39 21 42 3a				ld hl, .blstr 
3a3c cd 27 1a				call forth_push_str 
3a3f					 
3a3f				       NEXTW 
3a3f c3 22 1d			jp macro_next 
3a42				endm 
# End of macro NEXTW
3a42			 
3a42 .. 00		.blstr: db " ", 0 
3a44			 
3a44			.SPACES: 
3a44				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3a44 47				db WORD_SYS_CORE+51             
3a45 df 3a			dw .SCROLL            
3a47 07				db 6 + 1 
3a48 .. 00			db "SPACES",0              
3a4f				endm 
# End of macro CWHEAD
3a4f			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3a4f					if DEBUG_FORTH_WORDS_KEY 
3a4f						DMARK "SPS" 
3a4f f5				push af  
3a50 3a 64 3a			ld a, (.dmark)  
3a53 32 7a ee			ld (debug_mark),a  
3a56 3a 65 3a			ld a, (.dmark+1)  
3a59 32 7b ee			ld (debug_mark+1),a  
3a5c 3a 66 3a			ld a, (.dmark+2)  
3a5f 32 7c ee			ld (debug_mark+2),a  
3a62 18 03			jr .pastdmark  
3a64 ..			.dmark: db "SPS"  
3a67 f1			.pastdmark: pop af  
3a68			endm  
# End of macro DMARK
3a68						CALLMONITOR 
3a68 cd 2c 14			call break_point_state  
3a6b				endm  
# End of macro CALLMONITOR
3a6b					endif 
3a6b			 
3a6b			 
3a6b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a6b cd b0 1b			call macro_dsp_valuehl 
3a6e				endm 
# End of macro FORTH_DSP_VALUEHL
3a6e			 
3a6e			;		push hl    ; u 
3a6e					if DEBUG_FORTH_WORDS 
3a6e						DMARK "SPA" 
3a6e f5				push af  
3a6f 3a 83 3a			ld a, (.dmark)  
3a72 32 7a ee			ld (debug_mark),a  
3a75 3a 84 3a			ld a, (.dmark+1)  
3a78 32 7b ee			ld (debug_mark+1),a  
3a7b 3a 85 3a			ld a, (.dmark+2)  
3a7e 32 7c ee			ld (debug_mark+2),a  
3a81 18 03			jr .pastdmark  
3a83 ..			.dmark: db "SPA"  
3a86 f1			.pastdmark: pop af  
3a87			endm  
# End of macro DMARK
3a87						CALLMONITOR 
3a87 cd 2c 14			call break_point_state  
3a8a				endm  
# End of macro CALLMONITOR
3a8a					endif 
3a8a			 
3a8a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a8a cd 68 1c			call macro_forth_dsp_pop 
3a8d				endm 
# End of macro FORTH_DSP_POP
3a8d			;		pop hl 
3a8d 4d					ld c, l 
3a8e 06 00				ld b, 0 
3a90 21 60 e3				ld hl, scratch  
3a93			 
3a93					if DEBUG_FORTH_WORDS 
3a93						DMARK "SP2" 
3a93 f5				push af  
3a94 3a a8 3a			ld a, (.dmark)  
3a97 32 7a ee			ld (debug_mark),a  
3a9a 3a a9 3a			ld a, (.dmark+1)  
3a9d 32 7b ee			ld (debug_mark+1),a  
3aa0 3a aa 3a			ld a, (.dmark+2)  
3aa3 32 7c ee			ld (debug_mark+2),a  
3aa6 18 03			jr .pastdmark  
3aa8 ..			.dmark: db "SP2"  
3aab f1			.pastdmark: pop af  
3aac			endm  
# End of macro DMARK
3aac						CALLMONITOR 
3aac cd 2c 14			call break_point_state  
3aaf				endm  
# End of macro CALLMONITOR
3aaf					endif 
3aaf 3e 20				ld a, ' ' 
3ab1 c5			.spaces1:	push bc 
3ab2 77					ld (hl),a 
3ab3 23					inc hl 
3ab4 c1					pop bc 
3ab5 10 fa				djnz .spaces1 
3ab7 3e 00				ld a,0 
3ab9 77					ld (hl),a 
3aba 21 60 e3				ld hl, scratch 
3abd					if DEBUG_FORTH_WORDS 
3abd						DMARK "SP3" 
3abd f5				push af  
3abe 3a d2 3a			ld a, (.dmark)  
3ac1 32 7a ee			ld (debug_mark),a  
3ac4 3a d3 3a			ld a, (.dmark+1)  
3ac7 32 7b ee			ld (debug_mark+1),a  
3aca 3a d4 3a			ld a, (.dmark+2)  
3acd 32 7c ee			ld (debug_mark+2),a  
3ad0 18 03			jr .pastdmark  
3ad2 ..			.dmark: db "SP3"  
3ad5 f1			.pastdmark: pop af  
3ad6			endm  
# End of macro DMARK
3ad6						CALLMONITOR 
3ad6 cd 2c 14			call break_point_state  
3ad9				endm  
# End of macro CALLMONITOR
3ad9					endif 
3ad9 cd 22 1b				call forth_apush 
3adc			 
3adc				       NEXTW 
3adc c3 22 1d			jp macro_next 
3adf				endm 
# End of macro NEXTW
3adf			 
3adf			 
3adf			 
3adf			.SCROLL: 
3adf				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3adf 53				db WORD_SYS_CORE+63             
3ae0 0c 3b			dw .SCROLLD            
3ae2 07				db 6 + 1 
3ae3 .. 00			db "SCROLL",0              
3aea				endm 
# End of macro CWHEAD
3aea			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3aea					if DEBUG_FORTH_WORDS_KEY 
3aea						DMARK "SCR" 
3aea f5				push af  
3aeb 3a ff 3a			ld a, (.dmark)  
3aee 32 7a ee			ld (debug_mark),a  
3af1 3a 00 3b			ld a, (.dmark+1)  
3af4 32 7b ee			ld (debug_mark+1),a  
3af7 3a 01 3b			ld a, (.dmark+2)  
3afa 32 7c ee			ld (debug_mark+2),a  
3afd 18 03			jr .pastdmark  
3aff ..			.dmark: db "SCR"  
3b02 f1			.pastdmark: pop af  
3b03			endm  
# End of macro DMARK
3b03						CALLMONITOR 
3b03 cd 2c 14			call break_point_state  
3b06				endm  
# End of macro CALLMONITOR
3b06					endif 
3b06			 
3b06 cd 47 09			call scroll_up 
3b09			;	call update_display 
3b09			 
3b09					NEXTW 
3b09 c3 22 1d			jp macro_next 
3b0c				endm 
# End of macro NEXTW
3b0c			 
3b0c			 
3b0c			 
3b0c			;		; get dir 
3b0c			; 
3b0c			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b0c			; 
3b0c			;		push hl 
3b0c			; 
3b0c			;		; destroy value TOS 
3b0c			; 
3b0c			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b0c			; 
3b0c			;		; get count 
3b0c			; 
3b0c			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b0c			; 
3b0c			;		push hl 
3b0c			; 
3b0c			;		; destroy value TOS 
3b0c			; 
3b0c			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b0c			; 
3b0c			;		; one value on hl get other one back 
3b0c			; 
3b0c			;		pop bc    ; count 
3b0c			; 
3b0c			;		pop de   ; dir 
3b0c			; 
3b0c			; 
3b0c			;		ld b, c 
3b0c			; 
3b0c			;.scrolldir:     push bc 
3b0c			;		push de 
3b0c			; 
3b0c			;		ld a, 0 
3b0c			;		cp e 
3b0c			;		jr z, .scrollup  
3b0c			;		call scroll_down 
3b0c			;		jr .scrollnext 
3b0c			;.scrollup:	call scroll_up 
3b0c			; 
3b0c			;		 
3b0c			;.scrollnext: 
3b0c			;		pop de 
3b0c			;		pop bc 
3b0c			;		djnz .scrolldir 
3b0c			; 
3b0c			; 
3b0c			; 
3b0c			; 
3b0c			; 
3b0c			;		NEXTW 
3b0c			 
3b0c			.SCROLLD: 
3b0c				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3b0c 53				db WORD_SYS_CORE+63             
3b0d 3a 3b			dw .ATQ            
3b0f 08				db 7 + 1 
3b10 .. 00			db "SCROLLD",0              
3b18				endm 
# End of macro CWHEAD
3b18			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3b18					if DEBUG_FORTH_WORDS_KEY 
3b18						DMARK "SCD" 
3b18 f5				push af  
3b19 3a 2d 3b			ld a, (.dmark)  
3b1c 32 7a ee			ld (debug_mark),a  
3b1f 3a 2e 3b			ld a, (.dmark+1)  
3b22 32 7b ee			ld (debug_mark+1),a  
3b25 3a 2f 3b			ld a, (.dmark+2)  
3b28 32 7c ee			ld (debug_mark+2),a  
3b2b 18 03			jr .pastdmark  
3b2d ..			.dmark: db "SCD"  
3b30 f1			.pastdmark: pop af  
3b31			endm  
# End of macro DMARK
3b31						CALLMONITOR 
3b31 cd 2c 14			call break_point_state  
3b34				endm  
# End of macro CALLMONITOR
3b34					endif 
3b34			 
3b34 cd 6b 09			call scroll_down 
3b37			;	call update_display 
3b37			 
3b37					NEXTW 
3b37 c3 22 1d			jp macro_next 
3b3a				endm 
# End of macro NEXTW
3b3a			 
3b3a			 
3b3a			.ATQ: 
3b3a				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3b3a 62				db WORD_SYS_CORE+78             
3b3b 98 3b			dw .AUTODSP            
3b3d 04				db 3 + 1 
3b3e .. 00			db "AT@",0              
3b42				endm 
# End of macro CWHEAD
3b42			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3b42					if DEBUG_FORTH_WORDS_KEY 
3b42						DMARK "ATA" 
3b42 f5				push af  
3b43 3a 57 3b			ld a, (.dmark)  
3b46 32 7a ee			ld (debug_mark),a  
3b49 3a 58 3b			ld a, (.dmark+1)  
3b4c 32 7b ee			ld (debug_mark+1),a  
3b4f 3a 59 3b			ld a, (.dmark+2)  
3b52 32 7c ee			ld (debug_mark+2),a  
3b55 18 03			jr .pastdmark  
3b57 ..			.dmark: db "ATA"  
3b5a f1			.pastdmark: pop af  
3b5b			endm  
# End of macro DMARK
3b5b						CALLMONITOR 
3b5b cd 2c 14			call break_point_state  
3b5e				endm  
# End of macro CALLMONITOR
3b5e					endif 
3b5e			 
3b5e			 
3b5e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b5e cd b0 1b			call macro_dsp_valuehl 
3b61				endm 
# End of macro FORTH_DSP_VALUEHL
3b61			 
3b61					; TODO save cursor row 
3b61 7d					ld a,l 
3b62 fe 02				cp 2 
3b64 20 04				jr nz, .crow3aq 
3b66 3e 28				ld a, display_row_2 
3b68 18 12				jr .ccol1aq 
3b6a fe 03		.crow3aq:		cp 3 
3b6c 20 04				jr nz, .crow4aq 
3b6e 3e 50				ld a, display_row_3 
3b70 18 0a				jr .ccol1aq 
3b72 fe 04		.crow4aq:		cp 4 
3b74 20 04				jr nz, .crow1aq 
3b76 3e 78				ld a, display_row_4 
3b78 18 02				jr .ccol1aq 
3b7a 3e 00		.crow1aq:		ld a,display_row_1 
3b7c f5			.ccol1aq:		push af			; got row offset 
3b7d 6f					ld l,a 
3b7e 26 00				ld h,0 
3b80					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b80 cd 68 1c			call macro_forth_dsp_pop 
3b83				endm 
# End of macro FORTH_DSP_POP
3b83					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b83 cd b0 1b			call macro_dsp_valuehl 
3b86				endm 
# End of macro FORTH_DSP_VALUEHL
3b86					; TODO save cursor col 
3b86 f1					pop af 
3b87 85					add l		; add col offset 
3b88			 
3b88					; add current frame buffer address 
3b88 2a db eb				ld hl, (display_fb_active) 
3b8b cd b2 0b				call addatohl 
3b8e			 
3b8e			 
3b8e			 
3b8e			 
3b8e					; get char frame buffer location offset in hl 
3b8e			 
3b8e 7e					ld a,(hl) 
3b8f 26 00				ld h, 0 
3b91 6f					ld l, a 
3b92			 
3b92 cd b9 19				call forth_push_numhl 
3b95			 
3b95			 
3b95					NEXTW 
3b95 c3 22 1d			jp macro_next 
3b98				endm 
# End of macro NEXTW
3b98			 
3b98			.AUTODSP: 
3b98				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3b98 63				db WORD_SYS_CORE+79             
3b99 ae 3b			dw .MENU            
3b9b 05				db 4 + 1 
3b9c .. 00			db "ADSP",0              
3ba1				endm 
# End of macro CWHEAD
3ba1			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3ba1			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3ba1			 
3ba1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ba1 cd b0 1b			call macro_dsp_valuehl 
3ba4				endm 
# End of macro FORTH_DSP_VALUEHL
3ba4			 
3ba4			;		push hl 
3ba4			 
3ba4					; destroy value TOS 
3ba4			 
3ba4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ba4 cd 68 1c			call macro_forth_dsp_pop 
3ba7				endm 
# End of macro FORTH_DSP_POP
3ba7			 
3ba7			;		pop hl 
3ba7			 
3ba7 7d					ld a,l 
3ba8 32 27 eb				ld (cli_autodisplay), a 
3bab				       NEXTW 
3bab c3 22 1d			jp macro_next 
3bae				endm 
# End of macro NEXTW
3bae			 
3bae			.MENU: 
3bae				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3bae 70				db WORD_SYS_CORE+92             
3baf 57 3c			dw .ENDDISPLAY            
3bb1 05				db 4 + 1 
3bb2 .. 00			db "MENU",0              
3bb7				endm 
# End of macro CWHEAD
3bb7			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3bb7			 
3bb7			;		; get number of items on the stack 
3bb7			; 
3bb7				 
3bb7					FORTH_DSP_VALUEHL 
3bb7 cd b0 1b			call macro_dsp_valuehl 
3bba				endm 
# End of macro FORTH_DSP_VALUEHL
3bba				 
3bba					if DEBUG_FORTH_WORDS_KEY 
3bba						DMARK "MNU" 
3bba f5				push af  
3bbb 3a cf 3b			ld a, (.dmark)  
3bbe 32 7a ee			ld (debug_mark),a  
3bc1 3a d0 3b			ld a, (.dmark+1)  
3bc4 32 7b ee			ld (debug_mark+1),a  
3bc7 3a d1 3b			ld a, (.dmark+2)  
3bca 32 7c ee			ld (debug_mark+2),a  
3bcd 18 03			jr .pastdmark  
3bcf ..			.dmark: db "MNU"  
3bd2 f1			.pastdmark: pop af  
3bd3			endm  
# End of macro DMARK
3bd3						CALLMONITOR 
3bd3 cd 2c 14			call break_point_state  
3bd6				endm  
# End of macro CALLMONITOR
3bd6					endif 
3bd6			 
3bd6 45					ld b, l	 
3bd7 05					dec b 
3bd8			 
3bd8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bd8 cd 68 1c			call macro_forth_dsp_pop 
3bdb				endm 
# End of macro FORTH_DSP_POP
3bdb			 
3bdb			 
3bdb					; go directly through the stack to pluck out the string pointers and build an array 
3bdb			 
3bdb			;		FORTH_DSP 
3bdb			 
3bdb					; hl contains top most stack item 
3bdb				 
3bdb 11 60 e3				ld de, scratch 
3bde			 
3bde			.mbuild: 
3bde			 
3bde					FORTH_DSP_VALUEHL 
3bde cd b0 1b			call macro_dsp_valuehl 
3be1				endm 
# End of macro FORTH_DSP_VALUEHL
3be1			 
3be1					if DEBUG_FORTH_WORDS 
3be1						DMARK "MN3" 
3be1 f5				push af  
3be2 3a f6 3b			ld a, (.dmark)  
3be5 32 7a ee			ld (debug_mark),a  
3be8 3a f7 3b			ld a, (.dmark+1)  
3beb 32 7b ee			ld (debug_mark+1),a  
3bee 3a f8 3b			ld a, (.dmark+2)  
3bf1 32 7c ee			ld (debug_mark+2),a  
3bf4 18 03			jr .pastdmark  
3bf6 ..			.dmark: db "MN3"  
3bf9 f1			.pastdmark: pop af  
3bfa			endm  
# End of macro DMARK
3bfa						CALLMONITOR 
3bfa cd 2c 14			call break_point_state  
3bfd				endm  
# End of macro CALLMONITOR
3bfd					endif 
3bfd eb					ex de, hl 
3bfe 73					ld (hl), e 
3bff 23					inc hl 
3c00 72					ld (hl), d 
3c01 23					inc hl 
3c02 eb					ex de, hl 
3c03			 
3c03					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c03 cd 68 1c			call macro_forth_dsp_pop 
3c06				endm 
# End of macro FORTH_DSP_POP
3c06			 
3c06 10 d6				djnz .mbuild 
3c08			 
3c08					; done add term 
3c08			 
3c08 eb					ex de, hl 
3c09 36 00				ld (hl), 0 
3c0b 23					inc hl 
3c0c 36 00				ld (hl), 0 
3c0e			 
3c0e				 
3c0e					 
3c0e 21 60 e3				ld hl, scratch 
3c11			 
3c11					if DEBUG_FORTH_WORDS 
3c11						DMARK "MNx" 
3c11 f5				push af  
3c12 3a 26 3c			ld a, (.dmark)  
3c15 32 7a ee			ld (debug_mark),a  
3c18 3a 27 3c			ld a, (.dmark+1)  
3c1b 32 7b ee			ld (debug_mark+1),a  
3c1e 3a 28 3c			ld a, (.dmark+2)  
3c21 32 7c ee			ld (debug_mark+2),a  
3c24 18 03			jr .pastdmark  
3c26 ..			.dmark: db "MNx"  
3c29 f1			.pastdmark: pop af  
3c2a			endm  
# End of macro DMARK
3c2a						CALLMONITOR 
3c2a cd 2c 14			call break_point_state  
3c2d				endm  
# End of macro CALLMONITOR
3c2d					endif 
3c2d			 
3c2d			 
3c2d			 
3c2d 3e 00				ld a, 0 
3c2f cd b6 09				call menu 
3c32			 
3c32			 
3c32 6f					ld l, a 
3c33 26 00				ld h, 0 
3c35			 
3c35					if DEBUG_FORTH_WORDS 
3c35						DMARK "MNr" 
3c35 f5				push af  
3c36 3a 4a 3c			ld a, (.dmark)  
3c39 32 7a ee			ld (debug_mark),a  
3c3c 3a 4b 3c			ld a, (.dmark+1)  
3c3f 32 7b ee			ld (debug_mark+1),a  
3c42 3a 4c 3c			ld a, (.dmark+2)  
3c45 32 7c ee			ld (debug_mark+2),a  
3c48 18 03			jr .pastdmark  
3c4a ..			.dmark: db "MNr"  
3c4d f1			.pastdmark: pop af  
3c4e			endm  
# End of macro DMARK
3c4e						CALLMONITOR 
3c4e cd 2c 14			call break_point_state  
3c51				endm  
# End of macro CALLMONITOR
3c51					endif 
3c51			 
3c51 cd b9 19				call forth_push_numhl 
3c54			 
3c54			 
3c54			 
3c54			 
3c54				       NEXTW 
3c54 c3 22 1d			jp macro_next 
3c57				endm 
# End of macro NEXTW
3c57			 
3c57			 
3c57			.ENDDISPLAY: 
3c57			 
3c57			; eof 
# End of file forth_words_display.asm
3c57			include "forth_words_str.asm" 
3c57			 
3c57			; | ## String Words 
3c57			 
3c57			.PTR:   
3c57			 
3c57				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3c57 48				db WORD_SYS_CORE+52             
3c58 84 3c			dw .STYPE            
3c5a 04				db 3 + 1 
3c5b .. 00			db "PTR",0              
3c5f				endm 
# End of macro CWHEAD
3c5f			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3c5f			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3c5f			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3c5f			 
3c5f					if DEBUG_FORTH_WORDS_KEY 
3c5f						DMARK "PTR" 
3c5f f5				push af  
3c60 3a 74 3c			ld a, (.dmark)  
3c63 32 7a ee			ld (debug_mark),a  
3c66 3a 75 3c			ld a, (.dmark+1)  
3c69 32 7b ee			ld (debug_mark+1),a  
3c6c 3a 76 3c			ld a, (.dmark+2)  
3c6f 32 7c ee			ld (debug_mark+2),a  
3c72 18 03			jr .pastdmark  
3c74 ..			.dmark: db "PTR"  
3c77 f1			.pastdmark: pop af  
3c78			endm  
# End of macro DMARK
3c78						CALLMONITOR 
3c78 cd 2c 14			call break_point_state  
3c7b				endm  
# End of macro CALLMONITOR
3c7b					endif 
3c7b					FORTH_DSP_VALUEHL 
3c7b cd b0 1b			call macro_dsp_valuehl 
3c7e				endm 
# End of macro FORTH_DSP_VALUEHL
3c7e cd b9 19				call forth_push_numhl 
3c81			 
3c81			 
3c81					NEXTW 
3c81 c3 22 1d			jp macro_next 
3c84				endm 
# End of macro NEXTW
3c84			.STYPE: 
3c84				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3c84 48				db WORD_SYS_CORE+52             
3c85 d3 3c			dw .UPPER            
3c87 06				db 5 + 1 
3c88 .. 00			db "STYPE",0              
3c8e				endm 
# End of macro CWHEAD
3c8e			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3c8e					if DEBUG_FORTH_WORDS_KEY 
3c8e						DMARK "STY" 
3c8e f5				push af  
3c8f 3a a3 3c			ld a, (.dmark)  
3c92 32 7a ee			ld (debug_mark),a  
3c95 3a a4 3c			ld a, (.dmark+1)  
3c98 32 7b ee			ld (debug_mark+1),a  
3c9b 3a a5 3c			ld a, (.dmark+2)  
3c9e 32 7c ee			ld (debug_mark+2),a  
3ca1 18 03			jr .pastdmark  
3ca3 ..			.dmark: db "STY"  
3ca6 f1			.pastdmark: pop af  
3ca7			endm  
# End of macro DMARK
3ca7						CALLMONITOR 
3ca7 cd 2c 14			call break_point_state  
3caa				endm  
# End of macro CALLMONITOR
3caa					endif 
3caa					FORTH_DSP 
3caa cd 76 1b			call macro_forth_dsp 
3cad				endm 
# End of macro FORTH_DSP
3cad					;v5 FORTH_DSP_VALUE 
3cad			 
3cad 7e					ld a, (hl) 
3cae			 
3cae f5					push af 
3caf			 
3caf			; Dont destroy TOS		FORTH_DSP_POP 
3caf			 
3caf f1					pop af 
3cb0			 
3cb0 fe 01				cp DS_TYPE_STR 
3cb2 28 09				jr z, .typestr 
3cb4			 
3cb4 fe 02				cp DS_TYPE_INUM 
3cb6 28 0a				jr z, .typeinum 
3cb8			 
3cb8 21 d1 3c				ld hl, .tna 
3cbb 18 0a				jr .tpush 
3cbd			 
3cbd 21 cd 3c		.typestr:	ld hl, .tstr 
3cc0 18 05				jr .tpush 
3cc2 21 cf 3c		.typeinum:	ld hl, .tinum 
3cc5 18 00				jr .tpush 
3cc7			 
3cc7			.tpush: 
3cc7			 
3cc7 cd 27 1a				call forth_push_str 
3cca			 
3cca					NEXTW 
3cca c3 22 1d			jp macro_next 
3ccd				endm 
# End of macro NEXTW
3ccd .. 00		.tstr:	db "s",0 
3ccf .. 00		.tinum:  db "i",0 
3cd1 .. 00		.tna:   db "?", 0 
3cd3			 
3cd3			 
3cd3			.UPPER: 
3cd3				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3cd3 48				db WORD_SYS_CORE+52             
3cd4 0e 3d			dw .LOWER            
3cd6 06				db 5 + 1 
3cd7 .. 00			db "UPPER",0              
3cdd				endm 
# End of macro CWHEAD
3cdd			; | UPPER ( s -- s ) Upper case string s  | DONE 
3cdd					if DEBUG_FORTH_WORDS_KEY 
3cdd						DMARK "UPR" 
3cdd f5				push af  
3cde 3a f2 3c			ld a, (.dmark)  
3ce1 32 7a ee			ld (debug_mark),a  
3ce4 3a f3 3c			ld a, (.dmark+1)  
3ce7 32 7b ee			ld (debug_mark+1),a  
3cea 3a f4 3c			ld a, (.dmark+2)  
3ced 32 7c ee			ld (debug_mark+2),a  
3cf0 18 03			jr .pastdmark  
3cf2 ..			.dmark: db "UPR"  
3cf5 f1			.pastdmark: pop af  
3cf6			endm  
# End of macro DMARK
3cf6						CALLMONITOR 
3cf6 cd 2c 14			call break_point_state  
3cf9				endm  
# End of macro CALLMONITOR
3cf9					endif 
3cf9			 
3cf9					FORTH_DSP 
3cf9 cd 76 1b			call macro_forth_dsp 
3cfc				endm 
# End of macro FORTH_DSP
3cfc					 
3cfc			; TODO check is string type 
3cfc			 
3cfc					FORTH_DSP_VALUEHL 
3cfc cd b0 1b			call macro_dsp_valuehl 
3cff				endm 
# End of macro FORTH_DSP_VALUEHL
3cff			; get pointer to string in hl 
3cff			 
3cff 7e			.toup:		ld a, (hl) 
3d00 fe 00				cp 0 
3d02 28 07				jr z, .toupdone 
3d04			 
3d04 cd 1f 0f				call to_upper 
3d07			 
3d07 77					ld (hl), a 
3d08 23					inc hl 
3d09 18 f4				jr .toup 
3d0b			 
3d0b					 
3d0b			 
3d0b			 
3d0b			; for each char convert to upper 
3d0b					 
3d0b			.toupdone: 
3d0b			 
3d0b			 
3d0b					NEXTW 
3d0b c3 22 1d			jp macro_next 
3d0e				endm 
# End of macro NEXTW
3d0e			.LOWER: 
3d0e				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3d0e 48				db WORD_SYS_CORE+52             
3d0f 49 3d			dw .TCASE            
3d11 06				db 5 + 1 
3d12 .. 00			db "LOWER",0              
3d18				endm 
# End of macro CWHEAD
3d18			; | LOWER ( s -- s ) Lower case string s  | DONE 
3d18					if DEBUG_FORTH_WORDS_KEY 
3d18						DMARK "LWR" 
3d18 f5				push af  
3d19 3a 2d 3d			ld a, (.dmark)  
3d1c 32 7a ee			ld (debug_mark),a  
3d1f 3a 2e 3d			ld a, (.dmark+1)  
3d22 32 7b ee			ld (debug_mark+1),a  
3d25 3a 2f 3d			ld a, (.dmark+2)  
3d28 32 7c ee			ld (debug_mark+2),a  
3d2b 18 03			jr .pastdmark  
3d2d ..			.dmark: db "LWR"  
3d30 f1			.pastdmark: pop af  
3d31			endm  
# End of macro DMARK
3d31						CALLMONITOR 
3d31 cd 2c 14			call break_point_state  
3d34				endm  
# End of macro CALLMONITOR
3d34					endif 
3d34			 
3d34					FORTH_DSP 
3d34 cd 76 1b			call macro_forth_dsp 
3d37				endm 
# End of macro FORTH_DSP
3d37					 
3d37			; TODO check is string type 
3d37			 
3d37					FORTH_DSP_VALUEHL 
3d37 cd b0 1b			call macro_dsp_valuehl 
3d3a				endm 
# End of macro FORTH_DSP_VALUEHL
3d3a			; get pointer to string in hl 
3d3a			 
3d3a 7e			.tolow:		ld a, (hl) 
3d3b fe 00				cp 0 
3d3d 28 07				jr z, .tolowdone 
3d3f			 
3d3f cd 28 0f				call to_lower 
3d42			 
3d42 77					ld (hl), a 
3d43 23					inc hl 
3d44 18 f4				jr .tolow 
3d46			 
3d46					 
3d46			 
3d46			 
3d46			; for each char convert to low 
3d46					 
3d46			.tolowdone: 
3d46					NEXTW 
3d46 c3 22 1d			jp macro_next 
3d49				endm 
# End of macro NEXTW
3d49			.TCASE: 
3d49				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3d49 48				db WORD_SYS_CORE+52             
3d4a 7f 3e			dw .SUBSTR            
3d4c 06				db 5 + 1 
3d4d .. 00			db "TCASE",0              
3d53				endm 
# End of macro CWHEAD
3d53			; | TCASE ( s -- s ) Title case string s  | DONE 
3d53					if DEBUG_FORTH_WORDS_KEY 
3d53						DMARK "TCS" 
3d53 f5				push af  
3d54 3a 68 3d			ld a, (.dmark)  
3d57 32 7a ee			ld (debug_mark),a  
3d5a 3a 69 3d			ld a, (.dmark+1)  
3d5d 32 7b ee			ld (debug_mark+1),a  
3d60 3a 6a 3d			ld a, (.dmark+2)  
3d63 32 7c ee			ld (debug_mark+2),a  
3d66 18 03			jr .pastdmark  
3d68 ..			.dmark: db "TCS"  
3d6b f1			.pastdmark: pop af  
3d6c			endm  
# End of macro DMARK
3d6c						CALLMONITOR 
3d6c cd 2c 14			call break_point_state  
3d6f				endm  
# End of macro CALLMONITOR
3d6f					endif 
3d6f			 
3d6f					FORTH_DSP 
3d6f cd 76 1b			call macro_forth_dsp 
3d72				endm 
# End of macro FORTH_DSP
3d72					 
3d72			; TODO check is string type 
3d72			 
3d72					FORTH_DSP_VALUEHL 
3d72 cd b0 1b			call macro_dsp_valuehl 
3d75				endm 
# End of macro FORTH_DSP_VALUEHL
3d75			; get pointer to string in hl 
3d75			 
3d75					if DEBUG_FORTH_WORDS 
3d75						DMARK "TC1" 
3d75 f5				push af  
3d76 3a 8a 3d			ld a, (.dmark)  
3d79 32 7a ee			ld (debug_mark),a  
3d7c 3a 8b 3d			ld a, (.dmark+1)  
3d7f 32 7b ee			ld (debug_mark+1),a  
3d82 3a 8c 3d			ld a, (.dmark+2)  
3d85 32 7c ee			ld (debug_mark+2),a  
3d88 18 03			jr .pastdmark  
3d8a ..			.dmark: db "TC1"  
3d8d f1			.pastdmark: pop af  
3d8e			endm  
# End of macro DMARK
3d8e						CALLMONITOR 
3d8e cd 2c 14			call break_point_state  
3d91				endm  
# End of macro CALLMONITOR
3d91					endif 
3d91			 
3d91					; first time in turn to upper case first char 
3d91			 
3d91 7e					ld a, (hl) 
3d92 c3 1c 3e				jp .totsiptou 
3d95			 
3d95			 
3d95 7e			.tot:		ld a, (hl) 
3d96 fe 00				cp 0 
3d98 ca 60 3e				jp z, .totdone 
3d9b			 
3d9b					if DEBUG_FORTH_WORDS 
3d9b						DMARK "TC2" 
3d9b f5				push af  
3d9c 3a b0 3d			ld a, (.dmark)  
3d9f 32 7a ee			ld (debug_mark),a  
3da2 3a b1 3d			ld a, (.dmark+1)  
3da5 32 7b ee			ld (debug_mark+1),a  
3da8 3a b2 3d			ld a, (.dmark+2)  
3dab 32 7c ee			ld (debug_mark+2),a  
3dae 18 03			jr .pastdmark  
3db0 ..			.dmark: db "TC2"  
3db3 f1			.pastdmark: pop af  
3db4			endm  
# End of macro DMARK
3db4						CALLMONITOR 
3db4 cd 2c 14			call break_point_state  
3db7				endm  
# End of macro CALLMONITOR
3db7					endif 
3db7					; check to see if current char is a space 
3db7			 
3db7 fe 20				cp ' ' 
3db9 28 21				jr z, .totsp 
3dbb cd 28 0f				call to_lower 
3dbe					if DEBUG_FORTH_WORDS 
3dbe						DMARK "TC3" 
3dbe f5				push af  
3dbf 3a d3 3d			ld a, (.dmark)  
3dc2 32 7a ee			ld (debug_mark),a  
3dc5 3a d4 3d			ld a, (.dmark+1)  
3dc8 32 7b ee			ld (debug_mark+1),a  
3dcb 3a d5 3d			ld a, (.dmark+2)  
3dce 32 7c ee			ld (debug_mark+2),a  
3dd1 18 03			jr .pastdmark  
3dd3 ..			.dmark: db "TC3"  
3dd6 f1			.pastdmark: pop af  
3dd7			endm  
# End of macro DMARK
3dd7						CALLMONITOR 
3dd7 cd 2c 14			call break_point_state  
3dda				endm  
# End of macro CALLMONITOR
3dda					endif 
3dda 18 63				jr .totnxt 
3ddc			 
3ddc			.totsp:         ; on a space, find next char which should be upper 
3ddc			 
3ddc					if DEBUG_FORTH_WORDS 
3ddc						DMARK "TC4" 
3ddc f5				push af  
3ddd 3a f1 3d			ld a, (.dmark)  
3de0 32 7a ee			ld (debug_mark),a  
3de3 3a f2 3d			ld a, (.dmark+1)  
3de6 32 7b ee			ld (debug_mark+1),a  
3de9 3a f3 3d			ld a, (.dmark+2)  
3dec 32 7c ee			ld (debug_mark+2),a  
3def 18 03			jr .pastdmark  
3df1 ..			.dmark: db "TC4"  
3df4 f1			.pastdmark: pop af  
3df5			endm  
# End of macro DMARK
3df5						CALLMONITOR 
3df5 cd 2c 14			call break_point_state  
3df8				endm  
# End of macro CALLMONITOR
3df8					endif 
3df8					;; 
3df8			 
3df8 fe 20				cp ' ' 
3dfa 20 20				jr nz, .totsiptou 
3dfc 23					inc hl 
3dfd 7e					ld a, (hl) 
3dfe					if DEBUG_FORTH_WORDS 
3dfe						DMARK "TC5" 
3dfe f5				push af  
3dff 3a 13 3e			ld a, (.dmark)  
3e02 32 7a ee			ld (debug_mark),a  
3e05 3a 14 3e			ld a, (.dmark+1)  
3e08 32 7b ee			ld (debug_mark+1),a  
3e0b 3a 15 3e			ld a, (.dmark+2)  
3e0e 32 7c ee			ld (debug_mark+2),a  
3e11 18 03			jr .pastdmark  
3e13 ..			.dmark: db "TC5"  
3e16 f1			.pastdmark: pop af  
3e17			endm  
# End of macro DMARK
3e17						CALLMONITOR 
3e17 cd 2c 14			call break_point_state  
3e1a				endm  
# End of macro CALLMONITOR
3e1a					endif 
3e1a 18 c0				jr .totsp 
3e1c fe 00		.totsiptou:    cp 0 
3e1e 28 40				jr z, .totdone 
3e20					; not space and not zero term so upper case it 
3e20 cd 1f 0f				call to_upper 
3e23			 
3e23					if DEBUG_FORTH_WORDS 
3e23						DMARK "TC6" 
3e23 f5				push af  
3e24 3a 38 3e			ld a, (.dmark)  
3e27 32 7a ee			ld (debug_mark),a  
3e2a 3a 39 3e			ld a, (.dmark+1)  
3e2d 32 7b ee			ld (debug_mark+1),a  
3e30 3a 3a 3e			ld a, (.dmark+2)  
3e33 32 7c ee			ld (debug_mark+2),a  
3e36 18 03			jr .pastdmark  
3e38 ..			.dmark: db "TC6"  
3e3b f1			.pastdmark: pop af  
3e3c			endm  
# End of macro DMARK
3e3c						CALLMONITOR 
3e3c cd 2c 14			call break_point_state  
3e3f				endm  
# End of macro CALLMONITOR
3e3f					endif 
3e3f			 
3e3f			 
3e3f			.totnxt: 
3e3f			 
3e3f 77					ld (hl), a 
3e40 23					inc hl 
3e41					if DEBUG_FORTH_WORDS 
3e41						DMARK "TC7" 
3e41 f5				push af  
3e42 3a 56 3e			ld a, (.dmark)  
3e45 32 7a ee			ld (debug_mark),a  
3e48 3a 57 3e			ld a, (.dmark+1)  
3e4b 32 7b ee			ld (debug_mark+1),a  
3e4e 3a 58 3e			ld a, (.dmark+2)  
3e51 32 7c ee			ld (debug_mark+2),a  
3e54 18 03			jr .pastdmark  
3e56 ..			.dmark: db "TC7"  
3e59 f1			.pastdmark: pop af  
3e5a			endm  
# End of macro DMARK
3e5a						CALLMONITOR 
3e5a cd 2c 14			call break_point_state  
3e5d				endm  
# End of macro CALLMONITOR
3e5d					endif 
3e5d c3 95 3d				jp .tot 
3e60			 
3e60					 
3e60			 
3e60			 
3e60			; for each char convert to low 
3e60					 
3e60			.totdone: 
3e60					if DEBUG_FORTH_WORDS 
3e60						DMARK "TCd" 
3e60 f5				push af  
3e61 3a 75 3e			ld a, (.dmark)  
3e64 32 7a ee			ld (debug_mark),a  
3e67 3a 76 3e			ld a, (.dmark+1)  
3e6a 32 7b ee			ld (debug_mark+1),a  
3e6d 3a 77 3e			ld a, (.dmark+2)  
3e70 32 7c ee			ld (debug_mark+2),a  
3e73 18 03			jr .pastdmark  
3e75 ..			.dmark: db "TCd"  
3e78 f1			.pastdmark: pop af  
3e79			endm  
# End of macro DMARK
3e79						CALLMONITOR 
3e79 cd 2c 14			call break_point_state  
3e7c				endm  
# End of macro CALLMONITOR
3e7c					endif 
3e7c					NEXTW 
3e7c c3 22 1d			jp macro_next 
3e7f				endm 
# End of macro NEXTW
3e7f			 
3e7f			.SUBSTR: 
3e7f				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
3e7f 48				db WORD_SYS_CORE+52             
3e80 dd 3e			dw .LEFT            
3e82 07				db 6 + 1 
3e83 .. 00			db "SUBSTR",0              
3e8a				endm 
# End of macro CWHEAD
3e8a			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3e8a			 
3e8a					if DEBUG_FORTH_WORDS_KEY 
3e8a						DMARK "SST" 
3e8a f5				push af  
3e8b 3a 9f 3e			ld a, (.dmark)  
3e8e 32 7a ee			ld (debug_mark),a  
3e91 3a a0 3e			ld a, (.dmark+1)  
3e94 32 7b ee			ld (debug_mark+1),a  
3e97 3a a1 3e			ld a, (.dmark+2)  
3e9a 32 7c ee			ld (debug_mark+2),a  
3e9d 18 03			jr .pastdmark  
3e9f ..			.dmark: db "SST"  
3ea2 f1			.pastdmark: pop af  
3ea3			endm  
# End of macro DMARK
3ea3						CALLMONITOR 
3ea3 cd 2c 14			call break_point_state  
3ea6				endm  
# End of macro CALLMONITOR
3ea6					endif 
3ea6			; TODO check string type 
3ea6					FORTH_DSP_VALUEHL 
3ea6 cd b0 1b			call macro_dsp_valuehl 
3ea9				endm 
# End of macro FORTH_DSP_VALUEHL
3ea9			 
3ea9 e5					push hl      ; string length 
3eaa			 
3eaa					FORTH_DSP_POP 
3eaa cd 68 1c			call macro_forth_dsp_pop 
3ead				endm 
# End of macro FORTH_DSP_POP
3ead			 
3ead					FORTH_DSP_VALUEHL 
3ead cd b0 1b			call macro_dsp_valuehl 
3eb0				endm 
# End of macro FORTH_DSP_VALUEHL
3eb0			 
3eb0 e5					push hl     ; start char 
3eb1			 
3eb1					FORTH_DSP_POP 
3eb1 cd 68 1c			call macro_forth_dsp_pop 
3eb4				endm 
# End of macro FORTH_DSP_POP
3eb4			 
3eb4			 
3eb4					FORTH_DSP_VALUE 
3eb4 cd 99 1b			call macro_forth_dsp_value 
3eb7				endm 
# End of macro FORTH_DSP_VALUE
3eb7			 
3eb7 d1					pop de    ; get start post offset 
3eb8			 
3eb8 19					add hl, de    ; starting offset 
3eb9			 
3eb9 c1					pop bc 
3eba c5					push bc      ; grab size of string 
3ebb			 
3ebb e5					push hl    ; save string start  
3ebc			 
3ebc 26 00				ld h, 0 
3ebe 69					ld l, c 
3ebf 23					inc hl 
3ec0 23					inc hl 
3ec1			 
3ec1 cd 79 10				call malloc 
3ec4				if DEBUG_FORTH_MALLOC_GUARD 
3ec4 cc f3 44				call z,malloc_error 
3ec7				endif 
3ec7			 
3ec7 eb					ex de, hl      ; save malloc area for string copy 
3ec8 e1					pop hl    ; get back source 
3ec9 c1					pop bc    ; get length of string back 
3eca			 
3eca d5					push de    ; save malloc area for after we push 
3ecb ed b0				ldir     ; copy substr 
3ecd			 
3ecd			 
3ecd eb					ex de, hl 
3ece 3e 00				ld a, 0 
3ed0 77					ld (hl), a   ; term substr 
3ed1			 
3ed1					 
3ed1 e1					pop hl    ; get malloc so we can push it 
3ed2 e5					push hl   ; save so we can free it afterwards 
3ed3			 
3ed3 cd 27 1a				call forth_push_str 
3ed6			 
3ed6 e1					pop hl 
3ed7 cd 43 11				call free 
3eda			 
3eda					 
3eda					 
3eda			 
3eda			 
3eda					NEXTW 
3eda c3 22 1d			jp macro_next 
3edd				endm 
# End of macro NEXTW
3edd			 
3edd			.LEFT: 
3edd				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
3edd 48				db WORD_SYS_CORE+52             
3ede 05 3f			dw .RIGHT            
3ee0 05				db 4 + 1 
3ee1 .. 00			db "LEFT",0              
3ee6				endm 
# End of macro CWHEAD
3ee6			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
3ee6					if DEBUG_FORTH_WORDS_KEY 
3ee6						DMARK "LEF" 
3ee6 f5				push af  
3ee7 3a fb 3e			ld a, (.dmark)  
3eea 32 7a ee			ld (debug_mark),a  
3eed 3a fc 3e			ld a, (.dmark+1)  
3ef0 32 7b ee			ld (debug_mark+1),a  
3ef3 3a fd 3e			ld a, (.dmark+2)  
3ef6 32 7c ee			ld (debug_mark+2),a  
3ef9 18 03			jr .pastdmark  
3efb ..			.dmark: db "LEF"  
3efe f1			.pastdmark: pop af  
3eff			endm  
# End of macro DMARK
3eff						CALLMONITOR 
3eff cd 2c 14			call break_point_state  
3f02				endm  
# End of macro CALLMONITOR
3f02					endif 
3f02			 
3f02					NEXTW 
3f02 c3 22 1d			jp macro_next 
3f05				endm 
# End of macro NEXTW
3f05			.RIGHT: 
3f05				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
3f05 48				db WORD_SYS_CORE+52             
3f06 2e 3f			dw .STR2NUM            
3f08 06				db 5 + 1 
3f09 .. 00			db "RIGHT",0              
3f0f				endm 
# End of macro CWHEAD
3f0f			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
3f0f					if DEBUG_FORTH_WORDS_KEY 
3f0f						DMARK "RIG" 
3f0f f5				push af  
3f10 3a 24 3f			ld a, (.dmark)  
3f13 32 7a ee			ld (debug_mark),a  
3f16 3a 25 3f			ld a, (.dmark+1)  
3f19 32 7b ee			ld (debug_mark+1),a  
3f1c 3a 26 3f			ld a, (.dmark+2)  
3f1f 32 7c ee			ld (debug_mark+2),a  
3f22 18 03			jr .pastdmark  
3f24 ..			.dmark: db "RIG"  
3f27 f1			.pastdmark: pop af  
3f28			endm  
# End of macro DMARK
3f28						CALLMONITOR 
3f28 cd 2c 14			call break_point_state  
3f2b				endm  
# End of macro CALLMONITOR
3f2b					endif 
3f2b			 
3f2b					NEXTW 
3f2b c3 22 1d			jp macro_next 
3f2e				endm 
# End of macro NEXTW
3f2e			 
3f2e			 
3f2e			.STR2NUM: 
3f2e				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
3f2e 48				db WORD_SYS_CORE+52             
3f2f ba 3f			dw .NUM2STR            
3f31 08				db 7 + 1 
3f32 .. 00			db "STR2NUM",0              
3f3a				endm 
# End of macro CWHEAD
3f3a			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
3f3a			 
3f3a			 
3f3a			; TODO STR type check to do 
3f3a					if DEBUG_FORTH_WORDS_KEY 
3f3a						DMARK "S2N" 
3f3a f5				push af  
3f3b 3a 4f 3f			ld a, (.dmark)  
3f3e 32 7a ee			ld (debug_mark),a  
3f41 3a 50 3f			ld a, (.dmark+1)  
3f44 32 7b ee			ld (debug_mark+1),a  
3f47 3a 51 3f			ld a, (.dmark+2)  
3f4a 32 7c ee			ld (debug_mark+2),a  
3f4d 18 03			jr .pastdmark  
3f4f ..			.dmark: db "S2N"  
3f52 f1			.pastdmark: pop af  
3f53			endm  
# End of macro DMARK
3f53						CALLMONITOR 
3f53 cd 2c 14			call break_point_state  
3f56				endm  
# End of macro CALLMONITOR
3f56					endif 
3f56			 
3f56					;FORTH_DSP 
3f56					FORTH_DSP_VALUE 
3f56 cd 99 1b			call macro_forth_dsp_value 
3f59				endm 
# End of macro FORTH_DSP_VALUE
3f59					;inc hl 
3f59			 
3f59 eb					ex de, hl 
3f5a					if DEBUG_FORTH_WORDS 
3f5a						DMARK "S2a" 
3f5a f5				push af  
3f5b 3a 6f 3f			ld a, (.dmark)  
3f5e 32 7a ee			ld (debug_mark),a  
3f61 3a 70 3f			ld a, (.dmark+1)  
3f64 32 7b ee			ld (debug_mark+1),a  
3f67 3a 71 3f			ld a, (.dmark+2)  
3f6a 32 7c ee			ld (debug_mark+2),a  
3f6d 18 03			jr .pastdmark  
3f6f ..			.dmark: db "S2a"  
3f72 f1			.pastdmark: pop af  
3f73			endm  
# End of macro DMARK
3f73						CALLMONITOR 
3f73 cd 2c 14			call break_point_state  
3f76				endm  
# End of macro CALLMONITOR
3f76					endif 
3f76 cd a7 0f				call string_to_uint16 
3f79			 
3f79					if DEBUG_FORTH_WORDS 
3f79						DMARK "S2b" 
3f79 f5				push af  
3f7a 3a 8e 3f			ld a, (.dmark)  
3f7d 32 7a ee			ld (debug_mark),a  
3f80 3a 8f 3f			ld a, (.dmark+1)  
3f83 32 7b ee			ld (debug_mark+1),a  
3f86 3a 90 3f			ld a, (.dmark+2)  
3f89 32 7c ee			ld (debug_mark+2),a  
3f8c 18 03			jr .pastdmark  
3f8e ..			.dmark: db "S2b"  
3f91 f1			.pastdmark: pop af  
3f92			endm  
# End of macro DMARK
3f92						CALLMONITOR 
3f92 cd 2c 14			call break_point_state  
3f95				endm  
# End of macro CALLMONITOR
3f95					endif 
3f95			;		push hl 
3f95					FORTH_DSP_POP 
3f95 cd 68 1c			call macro_forth_dsp_pop 
3f98				endm 
# End of macro FORTH_DSP_POP
3f98			;		pop hl 
3f98					 
3f98					if DEBUG_FORTH_WORDS 
3f98						DMARK "S2b" 
3f98 f5				push af  
3f99 3a ad 3f			ld a, (.dmark)  
3f9c 32 7a ee			ld (debug_mark),a  
3f9f 3a ae 3f			ld a, (.dmark+1)  
3fa2 32 7b ee			ld (debug_mark+1),a  
3fa5 3a af 3f			ld a, (.dmark+2)  
3fa8 32 7c ee			ld (debug_mark+2),a  
3fab 18 03			jr .pastdmark  
3fad ..			.dmark: db "S2b"  
3fb0 f1			.pastdmark: pop af  
3fb1			endm  
# End of macro DMARK
3fb1						CALLMONITOR 
3fb1 cd 2c 14			call break_point_state  
3fb4				endm  
# End of macro CALLMONITOR
3fb4					endif 
3fb4 cd b9 19				call forth_push_numhl	 
3fb7			 
3fb7				 
3fb7				       NEXTW 
3fb7 c3 22 1d			jp macro_next 
3fba				endm 
# End of macro NEXTW
3fba			.NUM2STR: 
3fba				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
3fba 48				db WORD_SYS_CORE+52             
3fbb c9 3f			dw .CONCAT            
3fbd 08				db 7 + 1 
3fbe .. 00			db "NUM2STR",0              
3fc6				endm 
# End of macro CWHEAD
3fc6			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
3fc6			 
3fc6			;		; malloc a string to target 
3fc6			;		ld hl, 10     ; TODO max string size should be fine 
3fc6			;		call malloc 
3fc6			;		push hl    ; save malloc location 
3fc6			; 
3fc6			; 
3fc6			;; TODO check int type 
3fc6			;		FORTH_DSP_VALUEHL 
3fc6			;		ld a, l 
3fc6			;		call DispAToASCII   
3fc6			;;TODO need to chage above call to dump into string 
3fc6			; 
3fc6			; 
3fc6			 
3fc6				       NEXTW 
3fc6 c3 22 1d			jp macro_next 
3fc9				endm 
# End of macro NEXTW
3fc9			 
3fc9			.CONCAT: 
3fc9				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
3fc9 48				db WORD_SYS_CORE+52             
3fca 7c 40			dw .FIND            
3fcc 07				db 6 + 1 
3fcd .. 00			db "CONCAT",0              
3fd4				endm 
# End of macro CWHEAD
3fd4			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
3fd4			 
3fd4			; TODO check string type 
3fd4			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
3fd4			 
3fd4					if DEBUG_FORTH_WORDS_KEY 
3fd4						DMARK "CON" 
3fd4 f5				push af  
3fd5 3a e9 3f			ld a, (.dmark)  
3fd8 32 7a ee			ld (debug_mark),a  
3fdb 3a ea 3f			ld a, (.dmark+1)  
3fde 32 7b ee			ld (debug_mark+1),a  
3fe1 3a eb 3f			ld a, (.dmark+2)  
3fe4 32 7c ee			ld (debug_mark+2),a  
3fe7 18 03			jr .pastdmark  
3fe9 ..			.dmark: db "CON"  
3fec f1			.pastdmark: pop af  
3fed			endm  
# End of macro DMARK
3fed						CALLMONITOR 
3fed cd 2c 14			call break_point_state  
3ff0				endm  
# End of macro CALLMONITOR
3ff0					endif 
3ff0			 
3ff0			 
3ff0					FORTH_DSP_VALUE 
3ff0 cd 99 1b			call macro_forth_dsp_value 
3ff3				endm 
# End of macro FORTH_DSP_VALUE
3ff3 e5					push hl   ; s2 
3ff4			 
3ff4					FORTH_DSP_POP 
3ff4 cd 68 1c			call macro_forth_dsp_pop 
3ff7				endm 
# End of macro FORTH_DSP_POP
3ff7			 
3ff7					FORTH_DSP_VALUE 
3ff7 cd 99 1b			call macro_forth_dsp_value 
3ffa				endm 
# End of macro FORTH_DSP_VALUE
3ffa			 
3ffa e5					push hl   ; s1 
3ffb			 
3ffb					FORTH_DSP_POP 
3ffb cd 68 1c			call macro_forth_dsp_pop 
3ffe				endm 
# End of macro FORTH_DSP_POP
3ffe					 
3ffe			 
3ffe					; copy s1 
3ffe			 
3ffe				 
3ffe					; save ptr 
3ffe e1					pop hl  
3fff e5					push hl 
4000 3e 00				ld a, 0 
4002 cd 1b 10				call strlent 
4005					;inc hl    ; zer0 
4005 06 00				ld b, 0 
4007 4d					ld c, l 
4008 e1					pop hl		 
4009 11 60 e3				ld de, scratch	 
400c					if DEBUG_FORTH_WORDS 
400c						DMARK "CO1" 
400c f5				push af  
400d 3a 21 40			ld a, (.dmark)  
4010 32 7a ee			ld (debug_mark),a  
4013 3a 22 40			ld a, (.dmark+1)  
4016 32 7b ee			ld (debug_mark+1),a  
4019 3a 23 40			ld a, (.dmark+2)  
401c 32 7c ee			ld (debug_mark+2),a  
401f 18 03			jr .pastdmark  
4021 ..			.dmark: db "CO1"  
4024 f1			.pastdmark: pop af  
4025			endm  
# End of macro DMARK
4025						CALLMONITOR 
4025 cd 2c 14			call break_point_state  
4028				endm  
# End of macro CALLMONITOR
4028					endif 
4028 ed b0				ldir 
402a			 
402a e1					pop hl 
402b e5					push hl 
402c d5					push de 
402d			 
402d			 
402d 3e 00				ld a, 0 
402f cd 1b 10				call strlent 
4032 23					inc hl    ; zer0 
4033 23					inc hl 
4034 06 00				ld b, 0 
4036 4d					ld c, l 
4037 d1					pop de 
4038 e1					pop hl		 
4039					if DEBUG_FORTH_WORDS 
4039						DMARK "CO2" 
4039 f5				push af  
403a 3a 4e 40			ld a, (.dmark)  
403d 32 7a ee			ld (debug_mark),a  
4040 3a 4f 40			ld a, (.dmark+1)  
4043 32 7b ee			ld (debug_mark+1),a  
4046 3a 50 40			ld a, (.dmark+2)  
4049 32 7c ee			ld (debug_mark+2),a  
404c 18 03			jr .pastdmark  
404e ..			.dmark: db "CO2"  
4051 f1			.pastdmark: pop af  
4052			endm  
# End of macro DMARK
4052						CALLMONITOR 
4052 cd 2c 14			call break_point_state  
4055				endm  
# End of macro CALLMONITOR
4055					endif 
4055 ed b0				ldir 
4057			 
4057			 
4057			 
4057 21 60 e3				ld hl, scratch 
405a					if DEBUG_FORTH_WORDS 
405a						DMARK "CO5" 
405a f5				push af  
405b 3a 6f 40			ld a, (.dmark)  
405e 32 7a ee			ld (debug_mark),a  
4061 3a 70 40			ld a, (.dmark+1)  
4064 32 7b ee			ld (debug_mark+1),a  
4067 3a 71 40			ld a, (.dmark+2)  
406a 32 7c ee			ld (debug_mark+2),a  
406d 18 03			jr .pastdmark  
406f ..			.dmark: db "CO5"  
4072 f1			.pastdmark: pop af  
4073			endm  
# End of macro DMARK
4073						CALLMONITOR 
4073 cd 2c 14			call break_point_state  
4076				endm  
# End of macro CALLMONITOR
4076					endif 
4076			 
4076 cd 27 1a				call forth_push_str 
4079			 
4079			 
4079			 
4079			 
4079				       NEXTW 
4079 c3 22 1d			jp macro_next 
407c				endm 
# End of macro NEXTW
407c			 
407c			 
407c			.FIND: 
407c				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
407c 4b				db WORD_SYS_CORE+55             
407d 3a 41			dw .LEN            
407f 05				db 4 + 1 
4080 .. 00			db "FIND",0              
4085				endm 
# End of macro CWHEAD
4085			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4085			 
4085					if DEBUG_FORTH_WORDS_KEY 
4085						DMARK "FND" 
4085 f5				push af  
4086 3a 9a 40			ld a, (.dmark)  
4089 32 7a ee			ld (debug_mark),a  
408c 3a 9b 40			ld a, (.dmark+1)  
408f 32 7b ee			ld (debug_mark+1),a  
4092 3a 9c 40			ld a, (.dmark+2)  
4095 32 7c ee			ld (debug_mark+2),a  
4098 18 03			jr .pastdmark  
409a ..			.dmark: db "FND"  
409d f1			.pastdmark: pop af  
409e			endm  
# End of macro DMARK
409e						CALLMONITOR 
409e cd 2c 14			call break_point_state  
40a1				endm  
# End of macro CALLMONITOR
40a1					endif 
40a1			 
40a1			; TODO check string type 
40a1					FORTH_DSP_VALUE 
40a1 cd 99 1b			call macro_forth_dsp_value 
40a4				endm 
# End of macro FORTH_DSP_VALUE
40a4			 
40a4 e5					push hl    
40a5 7e					ld a,(hl)    ; char to find   
40a6			; TODO change char to substr 
40a6			 
40a6 f5					push af 
40a7					 
40a7			 
40a7			 
40a7					if DEBUG_FORTH_WORDS 
40a7						DMARK "FN1" 
40a7 f5				push af  
40a8 3a bc 40			ld a, (.dmark)  
40ab 32 7a ee			ld (debug_mark),a  
40ae 3a bd 40			ld a, (.dmark+1)  
40b1 32 7b ee			ld (debug_mark+1),a  
40b4 3a be 40			ld a, (.dmark+2)  
40b7 32 7c ee			ld (debug_mark+2),a  
40ba 18 03			jr .pastdmark  
40bc ..			.dmark: db "FN1"  
40bf f1			.pastdmark: pop af  
40c0			endm  
# End of macro DMARK
40c0						CALLMONITOR 
40c0 cd 2c 14			call break_point_state  
40c3				endm  
# End of macro CALLMONITOR
40c3					endif 
40c3			 
40c3					FORTH_DSP_POP 
40c3 cd 68 1c			call macro_forth_dsp_pop 
40c6				endm 
# End of macro FORTH_DSP_POP
40c6			 
40c6					; string to search 
40c6			 
40c6					FORTH_DSP_VALUE 
40c6 cd 99 1b			call macro_forth_dsp_value 
40c9				endm 
# End of macro FORTH_DSP_VALUE
40c9			 
40c9 d1					pop de  ; d is char to find  
40ca			 
40ca					if DEBUG_FORTH_WORDS 
40ca						DMARK "FN2" 
40ca f5				push af  
40cb 3a df 40			ld a, (.dmark)  
40ce 32 7a ee			ld (debug_mark),a  
40d1 3a e0 40			ld a, (.dmark+1)  
40d4 32 7b ee			ld (debug_mark+1),a  
40d7 3a e1 40			ld a, (.dmark+2)  
40da 32 7c ee			ld (debug_mark+2),a  
40dd 18 03			jr .pastdmark  
40df ..			.dmark: db "FN2"  
40e2 f1			.pastdmark: pop af  
40e3			endm  
# End of macro DMARK
40e3						CALLMONITOR 
40e3 cd 2c 14			call break_point_state  
40e6				endm  
# End of macro CALLMONITOR
40e6					endif 
40e6					 
40e6 01 00 00				ld bc, 0 
40e9 7e			.findchar:      ld a,(hl) 
40ea fe 00				cp 0   		 
40ec 28 27				jr z, .finddone     
40ee ba					cp d 
40ef 28 20				jr z, .foundchar 
40f1 03					inc bc 
40f2 23					inc hl 
40f3					if DEBUG_FORTH_WORDS 
40f3						DMARK "FN3" 
40f3 f5				push af  
40f4 3a 08 41			ld a, (.dmark)  
40f7 32 7a ee			ld (debug_mark),a  
40fa 3a 09 41			ld a, (.dmark+1)  
40fd 32 7b ee			ld (debug_mark+1),a  
4100 3a 0a 41			ld a, (.dmark+2)  
4103 32 7c ee			ld (debug_mark+2),a  
4106 18 03			jr .pastdmark  
4108 ..			.dmark: db "FN3"  
410b f1			.pastdmark: pop af  
410c			endm  
# End of macro DMARK
410c						CALLMONITOR 
410c cd 2c 14			call break_point_state  
410f				endm  
# End of macro CALLMONITOR
410f					endif 
410f 18 d8				jr .findchar 
4111			 
4111			 
4111 c5			.foundchar:	push bc 
4112 e1					pop hl 
4113 18 03				jr .findexit 
4115			 
4115			 
4115							 
4115			 
4115			.finddone:     ; got to end of string with no find 
4115 21 00 00				ld hl, 0 
4118			.findexit: 
4118			 
4118					if DEBUG_FORTH_WORDS 
4118						DMARK "FNd" 
4118 f5				push af  
4119 3a 2d 41			ld a, (.dmark)  
411c 32 7a ee			ld (debug_mark),a  
411f 3a 2e 41			ld a, (.dmark+1)  
4122 32 7b ee			ld (debug_mark+1),a  
4125 3a 2f 41			ld a, (.dmark+2)  
4128 32 7c ee			ld (debug_mark+2),a  
412b 18 03			jr .pastdmark  
412d ..			.dmark: db "FNd"  
4130 f1			.pastdmark: pop af  
4131			endm  
# End of macro DMARK
4131						CALLMONITOR 
4131 cd 2c 14			call break_point_state  
4134				endm  
# End of macro CALLMONITOR
4134					endif 
4134 cd b9 19			call forth_push_numhl 
4137			 
4137				       NEXTW 
4137 c3 22 1d			jp macro_next 
413a				endm 
# End of macro NEXTW
413a			 
413a			.LEN: 
413a				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
413a 4c				db WORD_SYS_CORE+56             
413b 6f 41			dw .CHAR            
413d 06				db 5 + 1 
413e .. 00			db "COUNT",0              
4144				endm 
# End of macro CWHEAD
4144			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
4144			 
4144					if DEBUG_FORTH_WORDS_KEY 
4144						DMARK "CNT" 
4144 f5				push af  
4145 3a 59 41			ld a, (.dmark)  
4148 32 7a ee			ld (debug_mark),a  
414b 3a 5a 41			ld a, (.dmark+1)  
414e 32 7b ee			ld (debug_mark+1),a  
4151 3a 5b 41			ld a, (.dmark+2)  
4154 32 7c ee			ld (debug_mark+2),a  
4157 18 03			jr .pastdmark  
4159 ..			.dmark: db "CNT"  
415c f1			.pastdmark: pop af  
415d			endm  
# End of macro DMARK
415d						CALLMONITOR 
415d cd 2c 14			call break_point_state  
4160				endm  
# End of macro CALLMONITOR
4160					endif 
4160			; TODO check string type 
4160					FORTH_DSP 
4160 cd 76 1b			call macro_forth_dsp 
4163				endm 
# End of macro FORTH_DSP
4163					;v5FORTH_DSP_VALUE 
4163			 
4163 23					inc hl 
4164			 
4164 3e 00				ld a, 0 
4166 cd 1b 10				call strlent 
4169			 
4169 cd b9 19				call forth_push_numhl 
416c			 
416c			 
416c			 
416c				       NEXTW 
416c c3 22 1d			jp macro_next 
416f				endm 
# End of macro NEXTW
416f			.CHAR: 
416f				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
416f 4d				db WORD_SYS_CORE+57             
4170 a5 41			dw .ENDSTR            
4172 05				db 4 + 1 
4173 .. 00			db "CHAR",0              
4178				endm 
# End of macro CWHEAD
4178			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4178					if DEBUG_FORTH_WORDS_KEY 
4178						DMARK "CHR" 
4178 f5				push af  
4179 3a 8d 41			ld a, (.dmark)  
417c 32 7a ee			ld (debug_mark),a  
417f 3a 8e 41			ld a, (.dmark+1)  
4182 32 7b ee			ld (debug_mark+1),a  
4185 3a 8f 41			ld a, (.dmark+2)  
4188 32 7c ee			ld (debug_mark+2),a  
418b 18 03			jr .pastdmark  
418d ..			.dmark: db "CHR"  
4190 f1			.pastdmark: pop af  
4191			endm  
# End of macro DMARK
4191						CALLMONITOR 
4191 cd 2c 14			call break_point_state  
4194				endm  
# End of macro CALLMONITOR
4194					endif 
4194					FORTH_DSP 
4194 cd 76 1b			call macro_forth_dsp 
4197				endm 
# End of macro FORTH_DSP
4197					;v5 FORTH_DSP_VALUE 
4197 23					inc hl      ; now at start of numeric as string 
4198			 
4198			;		push hl 
4198			 
4198					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4198 cd 68 1c			call macro_forth_dsp_pop 
419b				endm 
# End of macro FORTH_DSP_POP
419b			 
419b			;		pop hl 
419b			 
419b					; push the content of a onto the stack as a value 
419b			 
419b 7e					ld a,(hl)   ; get char 
419c 26 00				ld h,0 
419e 6f					ld l,a 
419f cd b9 19				call forth_push_numhl 
41a2			 
41a2				       NEXTW 
41a2 c3 22 1d			jp macro_next 
41a5				endm 
# End of macro NEXTW
41a5			 
41a5			 
41a5			 
41a5			 
41a5			.ENDSTR: 
41a5			; eof 
41a5			 
# End of file forth_words_str.asm
41a5			include "forth_words_key.asm" 
41a5			 
41a5			; | ## Keyboard Words 
41a5			 
41a5			.KEY: 
41a5				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
41a5 3e				db WORD_SYS_CORE+42             
41a6 d5 41			dw .WAITK            
41a8 04				db 3 + 1 
41a9 .. 00			db "KEY",0              
41ad				endm 
# End of macro CWHEAD
41ad			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
41ad			 
41ad					if DEBUG_FORTH_WORDS_KEY 
41ad						DMARK "KEY" 
41ad f5				push af  
41ae 3a c2 41			ld a, (.dmark)  
41b1 32 7a ee			ld (debug_mark),a  
41b4 3a c3 41			ld a, (.dmark+1)  
41b7 32 7b ee			ld (debug_mark+1),a  
41ba 3a c4 41			ld a, (.dmark+2)  
41bd 32 7c ee			ld (debug_mark+2),a  
41c0 18 03			jr .pastdmark  
41c2 ..			.dmark: db "KEY"  
41c5 f1			.pastdmark: pop af  
41c6			endm  
# End of macro DMARK
41c6						CALLMONITOR 
41c6 cd 2c 14			call break_point_state  
41c9				endm  
# End of macro CALLMONITOR
41c9					endif 
41c9			; TODO currently waits 
41c9 cd 7d 58				call cin 
41cc					;call cin_wait 
41cc 6f					ld l, a 
41cd 26 00				ld h, 0 
41cf cd b9 19				call forth_push_numhl 
41d2					NEXTW 
41d2 c3 22 1d			jp macro_next 
41d5				endm 
# End of macro NEXTW
41d5			.WAITK: 
41d5				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
41d5 3f				db WORD_SYS_CORE+43             
41d6 07 42			dw .ACCEPT            
41d8 06				db 5 + 1 
41d9 .. 00			db "WAITK",0              
41df				endm 
# End of macro CWHEAD
41df			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
41df					if DEBUG_FORTH_WORDS_KEY 
41df						DMARK "WAI" 
41df f5				push af  
41e0 3a f4 41			ld a, (.dmark)  
41e3 32 7a ee			ld (debug_mark),a  
41e6 3a f5 41			ld a, (.dmark+1)  
41e9 32 7b ee			ld (debug_mark+1),a  
41ec 3a f6 41			ld a, (.dmark+2)  
41ef 32 7c ee			ld (debug_mark+2),a  
41f2 18 03			jr .pastdmark  
41f4 ..			.dmark: db "WAI"  
41f7 f1			.pastdmark: pop af  
41f8			endm  
# End of macro DMARK
41f8						CALLMONITOR 
41f8 cd 2c 14			call break_point_state  
41fb				endm  
# End of macro CALLMONITOR
41fb					endif 
41fb cd 75 58				call cin_wait 
41fe 6f					ld l, a 
41ff 26 00				ld h, 0 
4201 cd b9 19				call forth_push_numhl 
4204					NEXTW 
4204 c3 22 1d			jp macro_next 
4207				endm 
# End of macro NEXTW
4207			.ACCEPT: 
4207				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4207 40				db WORD_SYS_CORE+44             
4208 65 42			dw .EDIT            
420a 07				db 6 + 1 
420b .. 00			db "ACCEPT",0              
4212				endm 
# End of macro CWHEAD
4212			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4212					; TODO crashes on push 
4212					if DEBUG_FORTH_WORDS_KEY 
4212						DMARK "ACC" 
4212 f5				push af  
4213 3a 27 42			ld a, (.dmark)  
4216 32 7a ee			ld (debug_mark),a  
4219 3a 28 42			ld a, (.dmark+1)  
421c 32 7b ee			ld (debug_mark+1),a  
421f 3a 29 42			ld a, (.dmark+2)  
4222 32 7c ee			ld (debug_mark+2),a  
4225 18 03			jr .pastdmark  
4227 ..			.dmark: db "ACC"  
422a f1			.pastdmark: pop af  
422b			endm  
# End of macro DMARK
422b						CALLMONITOR 
422b cd 2c 14			call break_point_state  
422e				endm  
# End of macro CALLMONITOR
422e					endif 
422e 21 5e e5				ld hl, os_input 
4231 3e 00				ld a, 0 
4233 77					ld (hl),a 
4234 3a 49 eb				ld a,(f_cursor_ptr) 
4237 16 64				ld d, 100 
4239 0e 00				ld c, 0 
423b 1e 28				ld e, 40 
423d cd df 0b				call input_str 
4240					; TODO perhaps do a type check and wrap in quotes if not a number 
4240 21 5e e5				ld hl, os_input 
4243					if DEBUG_FORTH_WORDS 
4243						DMARK "AC1" 
4243 f5				push af  
4244 3a 58 42			ld a, (.dmark)  
4247 32 7a ee			ld (debug_mark),a  
424a 3a 59 42			ld a, (.dmark+1)  
424d 32 7b ee			ld (debug_mark+1),a  
4250 3a 5a 42			ld a, (.dmark+2)  
4253 32 7c ee			ld (debug_mark+2),a  
4256 18 03			jr .pastdmark  
4258 ..			.dmark: db "AC1"  
425b f1			.pastdmark: pop af  
425c			endm  
# End of macro DMARK
425c						CALLMONITOR 
425c cd 2c 14			call break_point_state  
425f				endm  
# End of macro CALLMONITOR
425f					endif 
425f cd 27 1a				call forth_push_str 
4262					NEXTW 
4262 c3 22 1d			jp macro_next 
4265				endm 
# End of macro NEXTW
4265			 
4265			.EDIT: 
4265				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4265 40				db WORD_SYS_CORE+44             
4266 ee 42			dw .ENDKEY            
4268 05				db 4 + 1 
4269 .. 00			db "EDIT",0              
426e				endm 
# End of macro CWHEAD
426e			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
426e			 
426e					; TODO does not copy from stack 
426e					if DEBUG_FORTH_WORDS_KEY 
426e						DMARK "EDT" 
426e f5				push af  
426f 3a 83 42			ld a, (.dmark)  
4272 32 7a ee			ld (debug_mark),a  
4275 3a 84 42			ld a, (.dmark+1)  
4278 32 7b ee			ld (debug_mark+1),a  
427b 3a 85 42			ld a, (.dmark+2)  
427e 32 7c ee			ld (debug_mark+2),a  
4281 18 03			jr .pastdmark  
4283 ..			.dmark: db "EDT"  
4286 f1			.pastdmark: pop af  
4287			endm  
# End of macro DMARK
4287						CALLMONITOR 
4287 cd 2c 14			call break_point_state  
428a				endm  
# End of macro CALLMONITOR
428a					endif 
428a			 
428a					FORTH_DSP 
428a cd 76 1b			call macro_forth_dsp 
428d				endm 
# End of macro FORTH_DSP
428d					;v5 FORTH_DSP_VALUE 
428d 23					inc hl    ; TODO do type check 
428e			 
428e e5					push hl 
428f 3e 00				ld a, 0 
4291 cd 1b 10				call strlent 
4294 23					inc hl 
4295			 
4295 06 00				ld b, 0 
4297 4d					ld c, l 
4298			 
4298 e1					pop hl 
4299 11 5e e5				ld de, os_input 
429c					if DEBUG_FORTH_WORDS_KEY 
429c						DMARK "EDc" 
429c f5				push af  
429d 3a b1 42			ld a, (.dmark)  
42a0 32 7a ee			ld (debug_mark),a  
42a3 3a b2 42			ld a, (.dmark+1)  
42a6 32 7b ee			ld (debug_mark+1),a  
42a9 3a b3 42			ld a, (.dmark+2)  
42ac 32 7c ee			ld (debug_mark+2),a  
42af 18 03			jr .pastdmark  
42b1 ..			.dmark: db "EDc"  
42b4 f1			.pastdmark: pop af  
42b5			endm  
# End of macro DMARK
42b5						CALLMONITOR 
42b5 cd 2c 14			call break_point_state  
42b8				endm  
# End of macro CALLMONITOR
42b8					endif 
42b8 ed b0				ldir 
42ba			 
42ba			 
42ba 21 5e e5				ld hl, os_input 
42bd					;ld a, 0 
42bd					;ld (hl),a 
42bd 3a 49 eb				ld a,(f_cursor_ptr) 
42c0 16 64				ld d, 100 
42c2 0e 00				ld c, 0 
42c4 1e 28				ld e, 40 
42c6 cd df 0b				call input_str 
42c9					; TODO perhaps do a type check and wrap in quotes if not a number 
42c9 21 5e e5				ld hl, os_input 
42cc					if DEBUG_FORTH_WORDS 
42cc						DMARK "ED1" 
42cc f5				push af  
42cd 3a e1 42			ld a, (.dmark)  
42d0 32 7a ee			ld (debug_mark),a  
42d3 3a e2 42			ld a, (.dmark+1)  
42d6 32 7b ee			ld (debug_mark+1),a  
42d9 3a e3 42			ld a, (.dmark+2)  
42dc 32 7c ee			ld (debug_mark+2),a  
42df 18 03			jr .pastdmark  
42e1 ..			.dmark: db "ED1"  
42e4 f1			.pastdmark: pop af  
42e5			endm  
# End of macro DMARK
42e5						CALLMONITOR 
42e5 cd 2c 14			call break_point_state  
42e8				endm  
# End of macro CALLMONITOR
42e8					endif 
42e8 cd 27 1a				call forth_push_str 
42eb					NEXTW 
42eb c3 22 1d			jp macro_next 
42ee				endm 
# End of macro NEXTW
42ee			 
42ee			 
42ee			 
42ee			.ENDKEY: 
42ee			; eof 
42ee			 
# End of file forth_words_key.asm
42ee			 
42ee			if STORAGE_SE 
42ee			   	include "forth_words_storage.asm" 
42ee			endif 
42ee				include "forth_words_device.asm" 
42ee			; Device related words 
42ee			 
42ee			; | ## Device Words 
42ee			 
42ee			if SOUND_ENABLE 
42ee			.NOTE: 
42ee				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
42ee			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
42ee					if DEBUG_FORTH_WORDS_KEY 
42ee						DMARK "NTE" 
42ee						CALLMONITOR 
42ee					endif 
42ee			 
42ee				 
42ee			 
42ee					NEXTW 
42ee			.AFTERSOUND: 
42ee			endif 
42ee			 
42ee			 
42ee			USE_GPIO: equ 0 
42ee			 
42ee			if USE_GPIO 
42ee			.GP1: 
42ee				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
42ee			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
42ee					NEXTW 
42ee			.GP2: 
42ee				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
42ee			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
42ee			 
42ee					NEXTW 
42ee			 
42ee			.GP3: 
42ee				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
42ee			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
42ee			 
42ee					NEXTW 
42ee			 
42ee			.GP4: 
42ee				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
42ee			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
42ee			 
42ee					NEXTW 
42ee			.SIN: 
42ee			 
42ee			 
42ee			endif 
42ee			 
42ee			 
42ee				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
42ee 33				db WORD_SYS_CORE+31             
42ef 23 43			dw .SOUT            
42f1 03				db 2 + 1 
42f2 .. 00			db "IN",0              
42f5				endm 
# End of macro CWHEAD
42f5			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
42f5					if DEBUG_FORTH_WORDS_KEY 
42f5						DMARK "IN." 
42f5 f5				push af  
42f6 3a 0a 43			ld a, (.dmark)  
42f9 32 7a ee			ld (debug_mark),a  
42fc 3a 0b 43			ld a, (.dmark+1)  
42ff 32 7b ee			ld (debug_mark+1),a  
4302 3a 0c 43			ld a, (.dmark+2)  
4305 32 7c ee			ld (debug_mark+2),a  
4308 18 03			jr .pastdmark  
430a ..			.dmark: db "IN."  
430d f1			.pastdmark: pop af  
430e			endm  
# End of macro DMARK
430e						CALLMONITOR 
430e cd 2c 14			call break_point_state  
4311				endm  
# End of macro CALLMONITOR
4311					endif 
4311					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4311 cd b0 1b			call macro_dsp_valuehl 
4314				endm 
# End of macro FORTH_DSP_VALUEHL
4314			 
4314 e5					push hl 
4315			 
4315					; destroy value TOS 
4315			 
4315					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4315 cd 68 1c			call macro_forth_dsp_pop 
4318				endm 
# End of macro FORTH_DSP_POP
4318			 
4318					; one value on hl get other one back 
4318			 
4318 c1					pop bc 
4319			 
4319					; do the sub 
4319			;		ex de, hl 
4319			 
4319 ed 68				in l,(c) 
431b			 
431b					; save it 
431b			 
431b 26 00				ld h,0 
431d			 
431d					; TODO push value back onto stack for another op etc 
431d			 
431d cd b9 19				call forth_push_numhl 
4320					NEXTW 
4320 c3 22 1d			jp macro_next 
4323				endm 
# End of macro NEXTW
4323			.SOUT: 
4323				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4323 34				db WORD_SYS_CORE+32             
4324 76 43			dw .SPIO            
4326 04				db 3 + 1 
4327 .. 00			db "OUT",0              
432b				endm 
# End of macro CWHEAD
432b			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
432b					if DEBUG_FORTH_WORDS_KEY 
432b						DMARK "OUT" 
432b f5				push af  
432c 3a 40 43			ld a, (.dmark)  
432f 32 7a ee			ld (debug_mark),a  
4332 3a 41 43			ld a, (.dmark+1)  
4335 32 7b ee			ld (debug_mark+1),a  
4338 3a 42 43			ld a, (.dmark+2)  
433b 32 7c ee			ld (debug_mark+2),a  
433e 18 03			jr .pastdmark  
4340 ..			.dmark: db "OUT"  
4343 f1			.pastdmark: pop af  
4344			endm  
# End of macro DMARK
4344						CALLMONITOR 
4344 cd 2c 14			call break_point_state  
4347				endm  
# End of macro CALLMONITOR
4347					endif 
4347			 
4347					; get port 
4347			 
4347					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4347 cd b0 1b			call macro_dsp_valuehl 
434a				endm 
# End of macro FORTH_DSP_VALUEHL
434a			 
434a e5					push hl 
434b			 
434b					; destroy value TOS 
434b			 
434b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
434b cd 68 1c			call macro_forth_dsp_pop 
434e				endm 
# End of macro FORTH_DSP_POP
434e			 
434e					; get byte to send 
434e			 
434e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
434e cd b0 1b			call macro_dsp_valuehl 
4351				endm 
# End of macro FORTH_DSP_VALUEHL
4351			 
4351			;		push hl 
4351			 
4351					; destroy value TOS 
4351			 
4351					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4351 cd 68 1c			call macro_forth_dsp_pop 
4354				endm 
# End of macro FORTH_DSP_POP
4354			 
4354					; one value on hl get other one back 
4354			 
4354			;		pop hl 
4354			 
4354 c1					pop bc 
4355			 
4355					if DEBUG_FORTH_WORDS 
4355						DMARK "OUT" 
4355 f5				push af  
4356 3a 6a 43			ld a, (.dmark)  
4359 32 7a ee			ld (debug_mark),a  
435c 3a 6b 43			ld a, (.dmark+1)  
435f 32 7b ee			ld (debug_mark+1),a  
4362 3a 6c 43			ld a, (.dmark+2)  
4365 32 7c ee			ld (debug_mark+2),a  
4368 18 03			jr .pastdmark  
436a ..			.dmark: db "OUT"  
436d f1			.pastdmark: pop af  
436e			endm  
# End of macro DMARK
436e						CALLMONITOR 
436e cd 2c 14			call break_point_state  
4371				endm  
# End of macro CALLMONITOR
4371					endif 
4371			 
4371 ed 69				out (c), l 
4373			 
4373					NEXTW 
4373 c3 22 1d			jp macro_next 
4376				endm 
# End of macro NEXTW
4376			 
4376			 
4376			.SPIO: 
4376			 
4376			if STORAGE_SE 
4376				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4376			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4376			 
4376					call spi_ce_low 
4376			    NEXTW 
4376			 
4376			.SPICEH: 
4376				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4376			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4376			 
4376					call spi_ce_high 
4376			    NEXTW 
4376			 
4376			 
4376			.SPIOb: 
4376			 
4376				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4376			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4376			 
4376					; get port 
4376			 
4376			 
4376					; get byte to send 
4376			 
4376					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4376			 
4376			;		push hl    ; u1  
4376			 
4376					; destroy value TOS 
4376			 
4376					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4376			 
4376					; one value on hl get other one back 
4376			 
4376			;		pop hl   ; u2 - addr 
4376			 
4376					; TODO Send SPI byte 
4376			 
4376					ld a, l 
4376					call spi_send_byte 
4376			 
4376					NEXTW 
4376			 
4376			.SPII: 
4376				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4376			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4376			 
4376					; TODO Get SPI byte 
4376			 
4376					call spi_read_byte 
4376			 
4376					ld h, 0 
4376					ld l, a 
4376					call forth_push_numhl 
4376			 
4376					NEXTW 
4376			 
4376			 
4376			 
4376			.SESEL: 
4376				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4376			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4376					if DEBUG_FORTH_WORDS_KEY 
4376						DMARK "BNK" 
4376						CALLMONITOR 
4376					endif 
4376			 
4376					ld a, 255 
4376					ld (spi_cartdev), a 
4376			 
4376					; get bank 
4376			 
4376					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4376			 
4376			;		push hl 
4376			 
4376					; destroy value TOS 
4376			 
4376					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4376			 
4376					; one value on hl get other one back 
4376			 
4376			;		pop hl 
4376			 
4376			 
4376					ld c, SPI_CE_HIGH 
4376					ld b, '0'    ; human readable bank number 
4376			 
4376					ld a, l 
4376			 
4376					if DEBUG_FORTH_WORDS 
4376						DMARK "BNK" 
4376						CALLMONITOR 
4376					endif 
4376			 
4376					; active low 
4376			 
4376					cp 0 
4376					jr z, .bset 
4376					cp 1 
4376					jr nz, .b2 
4376					res 0, c 
4376					ld b, '1'    ; human readable bank number 
4376			.b2:		cp 2 
4376					jr nz, .b3 
4376					res 1, c 
4376					ld b, '2'    ; human readable bank number 
4376			.b3:		cp 3 
4376					jr nz, .b4 
4376					res 2, c 
4376					ld b, '3'    ; human readable bank number 
4376			.b4:		cp 4 
4376					jr nz, .b5 
4376					res 3, c 
4376					ld b, '4'    ; human readable bank number 
4376			.b5:		cp 5 
4376					jr nz, .bset 
4376					res 4, c 
4376					ld b, '5'    ; human readable bank number 
4376			 
4376			.bset: 
4376					ld a, c 
4376					ld (spi_device),a 
4376					ld a, b 
4376					ld (spi_device_id),a 
4376					if DEBUG_FORTH_WORDS 
4376						DMARK "BN2" 
4376						CALLMONITOR 
4376					endif 
4376			 
4376					NEXTW 
4376			 
4376			.CARTDEV: 
4376				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4376			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4376					if DEBUG_FORTH_WORDS_KEY 
4376						DMARK "CDV" 
4376						CALLMONITOR 
4376					endif 
4376			 
4376					; disable se storage bank selection 
4376			 
4376					ld a, SPI_CE_HIGH		; ce high 
4376					ld (spi_device), a 
4376			 
4376					; get bank 
4376			 
4376					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4376			 
4376			;		push hl 
4376			 
4376					; destroy value TOS 
4376			 
4376					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4376			 
4376					; one value on hl get other one back 
4376			 
4376			;		pop hl 
4376			 
4376					; active low 
4376			 
4376					ld c, 255 
4376			 
4376					ld a, l 
4376					if DEBUG_FORTH_WORDS 
4376						DMARK "CDV" 
4376						CALLMONITOR 
4376					endif 
4376					cp 0 
4376					jr z, .cset 
4376					cp 1 
4376					jr nz, .c2 
4376					res 0, c 
4376			.c2:		cp 2 
4376					jr nz, .c3 
4376					res 1, c 
4376			.c3:		cp 3 
4376					jr nz, .c4 
4376					res 2, c 
4376			.c4:		cp 4 
4376					jr nz, .c5 
4376					res 3, c 
4376			.c5:		cp 5 
4376					jr nz, .c6 
4376					res 4, c 
4376			.c6:		cp 6 
4376					jr nz, .c7 
4376					res 5, c 
4376			.c7:		cp 7 
4376					jr nz, .c8 
4376					res 6, c 
4376			.c8:		cp 8 
4376					jr nz, .cset 
4376					res 7, c 
4376			.cset:		ld a, c 
4376					ld (spi_cartdev),a 
4376			 
4376					if DEBUG_FORTH_WORDS 
4376						DMARK "CD2" 
4376						CALLMONITOR 
4376					endif 
4376					NEXTW 
4376			endif 
4376			 
4376			.ENDDEVICE: 
4376			; eof 
4376			 
# End of file forth_words_device.asm
4376			 
4376			; var handler 
4376			 
4376			 
4376			.VARS: 
4376				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4376 78				db WORD_SYS_CORE+100             
4377 8e 43			dw .V0Q            
4379 04				db 3 + 1 
437a .. 00			db "V0!",0              
437e				endm 
# End of macro CWHEAD
437e			;| V0! ( u1 -- )  Store value to v0  | DONE 
437e			 
437e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
437e cd b0 1b			call macro_dsp_valuehl 
4381				endm 
# End of macro FORTH_DSP_VALUEHL
4381			 
4381 11 13 eb				ld de, cli_var_array 
4384			 
4384 eb					ex de, hl 
4385 73					ld (hl), e 
4386 23					inc hl 
4387 72					ld (hl), d 
4388			 
4388					; destroy value TOS 
4388			 
4388					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4388 cd 68 1c			call macro_forth_dsp_pop 
438b				endm 
# End of macro FORTH_DSP_POP
438b			 
438b				       NEXTW 
438b c3 22 1d			jp macro_next 
438e				endm 
# End of macro NEXTW
438e			.V0Q: 
438e				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
438e 79				db WORD_SYS_CORE+101             
438f 9f 43			dw .V1S            
4391 04				db 3 + 1 
4392 .. 00			db "V0@",0              
4396				endm 
# End of macro CWHEAD
4396			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4396 2a 13 eb				ld hl, (cli_var_array) 
4399 cd b9 19				call forth_push_numhl 
439c			 
439c				       NEXTW 
439c c3 22 1d			jp macro_next 
439f				endm 
# End of macro NEXTW
439f			.V1S: 
439f				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
439f 7a				db WORD_SYS_CORE+102             
43a0 b7 43			dw .V1Q            
43a2 04				db 3 + 1 
43a3 .. 00			db "V1!",0              
43a7				endm 
# End of macro CWHEAD
43a7			;| V1! ( u1 -- )  Store value to v1 | DONE 
43a7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43a7 cd b0 1b			call macro_dsp_valuehl 
43aa				endm 
# End of macro FORTH_DSP_VALUEHL
43aa			 
43aa 11 15 eb				ld de, cli_var_array+2 
43ad				 
43ad eb					ex de, hl 
43ae 73					ld (hl), e 
43af 23					inc hl 
43b0 72					ld (hl), d 
43b1			 
43b1					; destroy value TOS 
43b1			 
43b1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43b1 cd 68 1c			call macro_forth_dsp_pop 
43b4				endm 
# End of macro FORTH_DSP_POP
43b4				       NEXTW 
43b4 c3 22 1d			jp macro_next 
43b7				endm 
# End of macro NEXTW
43b7			.V1Q: 
43b7				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
43b7 7b				db WORD_SYS_CORE+103             
43b8 c8 43			dw .V2S            
43ba 04				db 3 + 1 
43bb .. 00			db "V1@",0              
43bf				endm 
# End of macro CWHEAD
43bf			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
43bf 2a 15 eb				ld hl, (cli_var_array+2) 
43c2 cd b9 19				call forth_push_numhl 
43c5				       NEXTW 
43c5 c3 22 1d			jp macro_next 
43c8				endm 
# End of macro NEXTW
43c8			.V2S: 
43c8				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
43c8 7c				db WORD_SYS_CORE+104             
43c9 e0 43			dw .V2Q            
43cb 04				db 3 + 1 
43cc .. 00			db "V2!",0              
43d0				endm 
# End of macro CWHEAD
43d0			;| V2! ( u1 -- )  Store value to v2 | DONE 
43d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43d0 cd b0 1b			call macro_dsp_valuehl 
43d3				endm 
# End of macro FORTH_DSP_VALUEHL
43d3			 
43d3 11 17 eb				ld de, cli_var_array+4 
43d6				 
43d6 eb					ex de, hl 
43d7 73					ld (hl), e 
43d8 23					inc hl 
43d9 72					ld (hl), d 
43da			 
43da					; destroy value TOS 
43da			 
43da					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43da cd 68 1c			call macro_forth_dsp_pop 
43dd				endm 
# End of macro FORTH_DSP_POP
43dd				       NEXTW 
43dd c3 22 1d			jp macro_next 
43e0				endm 
# End of macro NEXTW
43e0			.V2Q: 
43e0				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
43e0 7d				db WORD_SYS_CORE+105             
43e1 f1 43			dw .V3S            
43e3 04				db 3 + 1 
43e4 .. 00			db "V2@",0              
43e8				endm 
# End of macro CWHEAD
43e8			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
43e8 2a 17 eb				ld hl, (cli_var_array+4) 
43eb cd b9 19				call forth_push_numhl 
43ee				       NEXTW 
43ee c3 22 1d			jp macro_next 
43f1				endm 
# End of macro NEXTW
43f1			.V3S: 
43f1				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
43f1 7c				db WORD_SYS_CORE+104             
43f2 09 44			dw .V3Q            
43f4 04				db 3 + 1 
43f5 .. 00			db "V3!",0              
43f9				endm 
# End of macro CWHEAD
43f9			;| V3! ( u1 -- )  Store value to v3 | DONE 
43f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43f9 cd b0 1b			call macro_dsp_valuehl 
43fc				endm 
# End of macro FORTH_DSP_VALUEHL
43fc			 
43fc 11 19 eb				ld de, cli_var_array+6 
43ff				 
43ff eb					ex de, hl 
4400 73					ld (hl), e 
4401 23					inc hl 
4402 72					ld (hl), d 
4403			 
4403					; destroy value TOS 
4403			 
4403					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4403 cd 68 1c			call macro_forth_dsp_pop 
4406				endm 
# End of macro FORTH_DSP_POP
4406				       NEXTW 
4406 c3 22 1d			jp macro_next 
4409				endm 
# End of macro NEXTW
4409			.V3Q: 
4409				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4409 7d				db WORD_SYS_CORE+105             
440a 1a 44			dw .END            
440c 04				db 3 + 1 
440d .. 00			db "V3@",0              
4411				endm 
# End of macro CWHEAD
4411			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4411 2a 19 eb				ld hl, (cli_var_array+6) 
4414 cd b9 19				call forth_push_numhl 
4417				       NEXTW 
4417 c3 22 1d			jp macro_next 
441a				endm 
# End of macro NEXTW
441a			 
441a			 
441a			 
441a			 
441a			 
441a			; end of dict marker 
441a			 
441a 00			.END:    db WORD_SYS_END 
441b 00 00			dw 0 
441d 00				db 0 
441e			 
441e			; use to jp here for user dict words to save on macro expansion  
441e			 
441e			user_dict_next: 
441e				NEXTW 
441e c3 22 1d			jp macro_next 
4421				endm 
# End of macro NEXTW
4421			 
4421			 
4421			user_exec: 
4421				;    ld hl, <word code> 
4421				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4421				;    call forthexec 
4421				;    jp user_dict_next   (NEXT) 
4421			        ;    <word code bytes> 
4421 eb				ex de, hl 
4422 2a 61 e6			ld hl,(os_tok_ptr) 
4425				 
4425				FORTH_RSP_NEXT 
4425 cd 60 19			call macro_forth_rsp_next 
4428				endm 
# End of macro FORTH_RSP_NEXT
4428			 
4428			if DEBUG_FORTH_UWORD 
4428						DMARK "UEX" 
4428 f5				push af  
4429 3a 3d 44			ld a, (.dmark)  
442c 32 7a ee			ld (debug_mark),a  
442f 3a 3e 44			ld a, (.dmark+1)  
4432 32 7b ee			ld (debug_mark+1),a  
4435 3a 3f 44			ld a, (.dmark+2)  
4438 32 7c ee			ld (debug_mark+2),a  
443b 18 03			jr .pastdmark  
443d ..			.dmark: db "UEX"  
4440 f1			.pastdmark: pop af  
4441			endm  
# End of macro DMARK
4441				CALLMONITOR 
4441 cd 2c 14			call break_point_state  
4444				endm  
# End of macro CALLMONITOR
4444			endif 
4444			 
4444			 
4444			 
4444 eb				ex de, hl 
4445 22 61 e6			ld (os_tok_ptr), hl 
4448				 
4448				; Don't use next - Skips the first word in uword. 
4448			 
4448 c3 b3 1d			jp exec1 
444b			;	NEXT 
444b			 
444b			 
444b			; eof 
# End of file forth_wordsv4.asm
444b			endif 
444b			;;;;;;;;;;;;;; Debug code 
444b			 
444b			 
444b			;if DEBUG_FORTH_PARSE 
444b .. 00		.nowordfound: db "No match",0 
4454 .. 00		.compword:	db "Comparing word ",0 
4464 .. 00		.nextwordat:	db "Next word at",0 
4471 .. 00		.charmatch:	db "Char match",0 
447c			;endif 
447c			if DEBUG_FORTH_JP 
447c			.foundword:	db "Word match. Exec..",0 
447c			endif 
447c			;if DEBUG_FORTH_PUSH 
447c .. 00		.enddict:	db "Dict end. Push.",0 
448c .. 00		.push_str:	db "Pushing string",0 
449b .. 00		.push_num:	db "Pushing number",0 
44aa .. 00		.data_sp:	db "SP:",0 
44ae .. 00		.wordinhl:	db "Word in HL (2/0):",0 
44c0 .. 00		.wordinde:	db "Word in DE (3/0):",0 
44d2 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
44e4			;endif 
44e4			;if DEBUG_FORTH_MALLOC 
44e4 .. 00		.push_malloc:	db "Malloc address",0 
44f3			;endif 
44f3			 
44f3			 
44f3			 
44f3			; display malloc address and current data stack pointer  
44f3			 
44f3			malloc_error: 
44f3 d5				push de 
44f4 f5				push af 
44f5 e5				push hl 
44f6 cd 85 09			call clear_display 
44f9 11 1b 45			ld de, .mallocerr 
44fc 3e 00			ld a,0 
44fe			;	ld de,os_word_scratch 
44fe cd 98 09			call str_at_display 
4501 3e 11			ld a, display_row_1+17 
4503 11 7a ee			ld de, debug_mark 
4506 cd 98 09			call str_at_display 
4509 cd a8 09			call update_display 
450c				;call break_point_state 
450c cd 75 58			call cin_wait 
450f			 
450f 3e 20			ld a, ' ' 
4511 32 51 e3			ld (os_view_disable), a 
4514 e1				pop hl 
4515 f1				pop af 
4516 d1				pop de	 
4517				CALLMONITOR 
4517 cd 2c 14			call break_point_state  
451a				endm  
# End of macro CALLMONITOR
451a c9				ret 
451b			 
451b .. 00		.mallocerr: 	db "Malloc Error",0 
4528			;if DEBUG_FORTH_PUSH 
4528			display_data_sp: 
4528 f5				push af 
4529			 
4529				; see if disabled 
4529			 
4529 3a 51 e3			ld a, (os_view_disable) 
452c fe 2a			cp '*' 
452e 28 67			jr z, .skipdsp 
4530			 
4530 e5				push hl 
4531 e5				push hl 
4532 e5			push hl 
4533 cd 85 09			call clear_display 
4536 e1			pop hl 
4537 7c				ld a,h 
4538 21 65 e6			ld hl, os_word_scratch 
453b cd b3 0e			call hexout 
453e e1				pop hl 
453f 7d				ld a,l 
4540 21 67 e6			ld hl, os_word_scratch+2 
4543 cd b3 0e			call hexout 
4546 21 69 e6			ld hl, os_word_scratch+4 
4549 3e 00			ld a,0 
454b 77				ld (hl),a 
454c 11 65 e6			ld de,os_word_scratch 
454f 3e 28				ld a, display_row_2 
4551 cd 98 09				call str_at_display 
4554 11 ae 44			ld de, .wordinhl 
4557 3e 00			ld a, display_row_1 
4559			 
4559 cd 98 09				call str_at_display 
455c 11 7a ee			ld de, debug_mark 
455f 3e 11			ld a, display_row_1+17 
4561			 
4561 cd 98 09				call str_at_display 
4564			 
4564				; display current data stack pointer 
4564 11 aa 44			ld de,.data_sp 
4567 3e 30				ld a, display_row_2 + 8 
4569 cd 98 09				call str_at_display 
456c			 
456c 2a 0d eb			ld hl,(cli_data_sp) 
456f e5				push hl 
4570 7c				ld a,h 
4571 21 65 e6			ld hl, os_word_scratch 
4574 cd b3 0e			call hexout 
4577 e1				pop hl 
4578 7d				ld a,l 
4579 21 67 e6			ld hl, os_word_scratch+2 
457c cd b3 0e			call hexout 
457f 21 69 e6			ld hl, os_word_scratch+4 
4582 3e 00			ld a,0 
4584 77				ld (hl),a 
4585 11 65 e6			ld de,os_word_scratch 
4588 3e 33				ld a, display_row_2 + 11 
458a cd 98 09				call str_at_display 
458d			 
458d			 
458d cd a8 09			call update_display 
4590 cd fa 08			call delay1s 
4593 cd fa 08			call delay1s 
4596 e1				pop hl 
4597			.skipdsp: 
4597 f1				pop af 
4598 c9				ret 
4599			 
4599			display_data_malloc: 
4599			 
4599 f5				push af 
459a e5				push hl 
459b e5				push hl 
459c e5			push hl 
459d cd 85 09			call clear_display 
45a0 e1			pop hl 
45a1 7c				ld a,h 
45a2 21 65 e6			ld hl, os_word_scratch 
45a5 cd b3 0e			call hexout 
45a8 e1				pop hl 
45a9 7d				ld a,l 
45aa 21 67 e6			ld hl, os_word_scratch+2 
45ad cd b3 0e			call hexout 
45b0 21 69 e6			ld hl, os_word_scratch+4 
45b3 3e 00			ld a,0 
45b5 77				ld (hl),a 
45b6 11 65 e6			ld de,os_word_scratch 
45b9 3e 28				ld a, display_row_2 
45bb cd 98 09				call str_at_display 
45be 11 e4 44			ld de, .push_malloc 
45c1 3e 00			ld a, display_row_1 
45c3			 
45c3 cd 98 09				call str_at_display 
45c6			 
45c6				; display current data stack pointer 
45c6 11 aa 44			ld de,.data_sp 
45c9 3e 30				ld a, display_row_2 + 8 
45cb cd 98 09				call str_at_display 
45ce			 
45ce 2a 0d eb			ld hl,(cli_data_sp) 
45d1 e5				push hl 
45d2 7c				ld a,h 
45d3 21 65 e6			ld hl, os_word_scratch 
45d6 cd b3 0e			call hexout 
45d9 e1				pop hl 
45da 7d				ld a,l 
45db 21 67 e6			ld hl, os_word_scratch+2 
45de cd b3 0e			call hexout 
45e1 21 69 e6			ld hl, os_word_scratch+4 
45e4 3e 00			ld a,0 
45e6 77				ld (hl),a 
45e7 11 65 e6			ld de,os_word_scratch 
45ea 3e 33				ld a, display_row_2 + 11 
45ec cd 98 09				call str_at_display 
45ef			 
45ef cd a8 09			call update_display 
45f2 cd fa 08			call delay1s 
45f5 cd fa 08			call delay1s 
45f8 e1				pop hl 
45f9 f1				pop af 
45fa c9				ret 
45fb			;endif 
45fb			 
45fb			include "forth_autostart.asm" 
45fb			; list of commands to perform at system start up 
45fb			 
45fb			startcmds: 
45fb			;	dw test11 
45fb			;	dw test12 
45fb			;	dw test13 
45fb			;	dw test14 
45fb			;	dw test15 
45fb			;	dw test16 
45fb			;	dw test17 
45fb			;	dw ifthtest1 
45fb			;	dw ifthtest2 
45fb			;	dw ifthtest3 
45fb			;	dw mmtest1 
45fb			;	dw mmtest2 
45fb			;	dw mmtest3 
45fb			;	dw mmtest4 
45fb			;	dw mmtest5 
45fb			;	dw mmtest6 
45fb			;	dw iftest1 
45fb			;	dw iftest2 
45fb			;	dw iftest3 
45fb			;	dw looptest1 
45fb			;	dw looptest2 
45fb			;	dw test1 
45fb			;	dw test2 
45fb			;	dw test3 
45fb			;	dw test4 
45fb			;	dw game2r 
45fb			;	dw game2b1 
45fb			;	dw game2b2 
45fb			 
45fb				; start up words that are actually useful 
45fb			 
45fb 59 46			dw clrstack 
45fd 8c 46			dw type 
45ff 4d 48			dw stest 
4601 b0 46			dw strncpy 
4603 ee 47			dw list 
4605 11 47			dw start1 
4607 23 47			dw start2 
4609			;	dw start3 
4609 36 47			dw start3b 
460b 8e 47			dw start3c 
460d			 
460d				; (unit) testing words 
460d			 
460d c4 48			dw mtesta 
460f 79 49			dw mtestb 
4611 1c 4a			dw mtestc 
4613 d1 4a			dw mtestd 
4615 75 4b			dw mteste 
4617			 
4617				; demo/game words 
4617			 
4617 81 52		        dw game3w 
4619 af 52		        dw game3p 
461b cd 52		        dw game3sc 
461d fe 52		        dw game3vsi 
461f 2a 53		        dw game3vs 
4621				 
4621 74 50			dw game2b 
4623 e2 50			dw game2bf 
4625 2c 51			dw game2mba 
4627 c2 51			dw game2mbas 
4629 04 52			dw game2mb 
462b			 
462b 35 4d			dw game1 
462d 46 4d			dw game1a 
462f a8 4d			dw game1b 
4631 dd 4d			dw game1c 
4633 13 4e			dw game1d 
4635 44 4e			dw game1s 
4637 58 4e			dw game1t 
4639 6d 4e			dw game1f 
463b a1 4e			dw game1z 
463d e5 4e			dw game1zz 
463f			 
463f 2b 4c			dw test5 
4641 63 4c			dw test6 
4643 9b 4c			dw test7 
4645 af 4c			dw test8 
4647 db 4c			dw test9 
4649 f1 4c			dw test10 
464b				 
464b bc 4f		        dw ssv5 
464d a0 4f		        dw ssv4 
464f 84 4f		        dw ssv3 
4651 4e 4f		        dw ssv2 
4653 d5 4f		        dw ssv1 
4655 1d 50		        dw ssv1cpm 
4657			;	dw keyup 
4657			;	dw keydown 
4657			;	dw keyleft 
4657			;	dw keyright 
4657			;	dw 	keyf1 
4657			;	dw keyf2 
4657			;	dw keyf3 
4657			;	dw keyf4 
4657			;	dw keyf5 
4657			;	dw keyf6 
4657			;	dw keyf7 
4657			;	dw keyf8 
4657			;	dw keyf9 
4657			;	dw keyf10 
4657			;	dw keyf11 
4657			;	dw keyf12 
4657			;	dw keytab 
4657			;	dw keycr 
4657			;	dw keyhome 
4657			;	dw keyend 
4657			;	dw keybs 
4657 00 00			db 0, 0	 
4659			 
4659			 
4659			; clear stack  
4659			 
4659 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
468c			 
468c			; type ( addr count - ) 
468c .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
46b0			 
46b0			; some direct memory words 
46b0			; strncpy ( len t f -- t ) 
46b0			 
46b0 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
4711			 
4711 .. 00		start1:     	db ": bpon $0000 bp ;",0 
4723 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
4736			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
4736 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
478e .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
47ee			 
47ee			 
47ee			; a handy word to list items on the stack 
47ee			 
47ee .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
484d			 
484d			 
484d			; test stack  
484d			; rnd8 stest 
484d			 
484d .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
48c4			 
48c4			; random malloc and free cycles 
48c4			 
48c4 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4979			 
4979			; fixed malloc and free cycles 
4979			 
4979 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4a1c			 
4a1c			; fixed double string push and drop cycle  
4a1c			 
4a1c .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
4ad1			 
4ad1			; consistent fixed string push and drop cycle  
4ad1			 
4ad1 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4b75			 
4b75 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4c2b			 
4c2b			;test1:		db ": aa 1 2 3 ;", 0 
4c2b			;test2:     	db "111 aa 888 999",0 
4c2b			;test3:     	db ": bb 77 ;",0 
4c2b			;test4:     	db "$02 $01 do i . loop bb",0 
4c2b			 
4c2b .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
4c63 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
4c9b .. 00		test7:     	db ": box hline vline ;",0 
4caf .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
4cdb .. 00		test9:     	db ": sw $01 adsp world ;",0 
4cf1 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
4d16 .. 00		test11:     	db "hello create .",0 
4d25 .. 00		test12:     	db "hello2 create .",0 
4d35			 
4d35			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
4d35			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
4d35			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
4d35			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
4d35			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
4d35			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
4d35			 
4d35			;iftest1:     	db "$0001 IF cls .",0 
4d35			;iftest2:     	db "$0000 IF cls .",0 
4d35			;iftest3:     	db "$0002 $0003 - IF cls .",0 
4d35			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
4d35			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
4d35			 
4d35			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4d35			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4d35			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4d35			 
4d35			 
4d35			 
4d35			; a small guess the number game 
4d35			 
4d35 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
4d46 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
4da8			 
4da8 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
4ddd .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
4e13 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
4e44 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
4e58 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
4e6d .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
4ea1 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
4ee5			 
4ee5			; Using 'ga' save a high score across multiple runs using external storage 
4ee5			 
4ee5 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
4f4e			 
4f4e			 
4f4e			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
4f4e			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
4f4e			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
4f4e			 
4f4e			; simple screen saver to test code memory reuse to destruction 
4f4e			 
4f4e .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
4f84 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
4fa0 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
4fbc .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
4fd5 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
501d .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5074			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5074			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5074			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5074			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5074			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5074			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5074			 
5074			 
5074			 
5074			; minesweeper/battleship finding game 
5074			; draws a game board of random ship/mine positions 
5074			; user enters coords to see if it hits on 
5074			; game ends when all are hit 
5074			; when hit or miss says how many may be in the area 
5074			 
5074			; setup the game board and then hide it 
5074 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
50e2 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
512c			; prompt for where to target 
512c .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
51c2 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
51e7			; TODO see if the entered coords hits or misses pushes char hit of miss 
51e7 .. 00		game2mbht:      db ": mbckht nop ;",0 
51f6 .. 00		game2mbms:      db ": mbcms nop ;",0 
5204			; TODO how many might be near by 
5204 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5281			 
5281			; Game 3 
5281			 
5281			; Vert scroller ski game - avoid the trees! 
5281			 
5281			; v0 score (ie turns) 
5281			; v1 player pos 
5281			; v2 left wall 
5281			; v3 right wall 
5281			 
5281			; Draw side walls randomly 
5281			 
5281 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
52af			 
52af			; Draw player 
52af .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
52cd			 
52cd			; TODO Get Key 
52cd			 
52cd			; TODO Move left right 
52cd			 
52cd			; scroll and move walls a bit 
52cd			 
52cd .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
52fe			 
52fe			; main game loop 
52fe			 
52fe .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
532a .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5369			 
5369			; key board defs 
5369			 
5369 .. 00		keyup:       db ": keyup $05 ;",0 
5377 .. 00		keydown:       db ": keydown $0a ;",0 
5387 .. 00		keyleft:       db ": keyleft $0b ;",0 
5397 .. 00		keyright:       db ": keyright $0c ;",0 
53a8 .. 00		keyf1:       db ": keyf1 $10 ;",0 
53b6 .. 00		keyf2:       db ": keyf2 $11 ;",0 
53c4 .. 00		keyf3:       db ": keyf3 $12 ;",0 
53d2 .. 00		keyf4:       db ": keyf4 $13 ;",0 
53e0 .. 00		keyf5:       db ": keyf5 $14 ;",0 
53ee .. 00		keyf6:       db ": keyf6 $15 ;",0 
53fc .. 00		keyf7:       db ": keyf7 $16 ;",0 
540a .. 00		keyf8:       db ": keyf8 $17 ;",0 
5418 .. 00		keyf9:       db ": keyf9 $18 ;",0 
5426 .. 00		keyf10:       db ": keyf10 $19 ;",0 
5435 .. 00		keyf11:       db ": keyf11 $1a ;",0 
5444 .. 00		keyf12:       db ": keyf12 $1b ;",0 
5453			 
5453 .. 00		keytab:       db ": keytab $09 ;",0 
5462 .. 00		keycr:       db ": keycr $0d ;",0 
5470 .. 00		keyhome:       db ": keyhome $0e ;",0 
5480 .. 00		keyend:       db ": keyend $0f ;",0 
548f .. 00		keybs:       db ": keybs $08 ;",0 
549d			 
549d			   
549d			 
549d			 
549d			 
549d			; eof 
# End of file forth_autostart.asm
549d			 
549d .. 00		sprompt1: db "Startup load...",0 
54ad .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
54c3			 
54c3			 
54c3			 
54c3			 
54c3			forth_startup: 
54c3 21 fb 45			ld hl, startcmds 
54c6 3e 00			ld a, 0 
54c8 32 86 e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
54cb			 
54cb e5			.start1:	push hl 
54cc cd 85 09			call clear_display 
54cf 11 9d 54			ld de, sprompt1 
54d2 3e 00		        ld a, display_row_1 
54d4 cd 98 09			call str_at_display 
54d7 11 ad 54			ld de, sprompt2 
54da 3e 28		        ld a, display_row_2 
54dc cd 98 09			call str_at_display 
54df e1				pop hl 
54e0 e5				push hl 
54e1 5e				ld e,(hl) 
54e2 23				inc hl 
54e3 56				ld d,(hl) 
54e4 3e 50		        ld a, display_row_3 
54e6 cd 98 09			call str_at_display 
54e9 cd a8 09			call update_display 
54ec			 
54ec			 
54ec 3a 86 e7			ld a, (os_last_cmd) 
54ef fe 00			cp 0 
54f1 28 05			jr z, .startprompt 
54f3 cd ee 08			call delay250ms 
54f6 18 24			jr .startdo 
54f8				 
54f8				 
54f8			 
54f8			.startprompt: 
54f8			 
54f8 3e 9f			ld a,display_row_4 + display_cols - 1 
54fa 11 2f 19		        ld de, endprg 
54fd cd 98 09			call str_at_display 
5500 cd a8 09			call update_display 
5503 cd fa 08			call delay1s 
5506 cd 75 58			call cin_wait 
5509						 
5509 fe 2a			cp '*' 
550b 28 5e			jr z, .startupend1 
550d fe 23			cp '#' 
550f 20 07			jr nz, .startno 
5511 3e 01			ld a, 1 
5513 32 86 e7			ld (os_last_cmd),a 
5516 18 04			jr .startdo 
5518 fe 31		.startno:	cp '1' 
551a 28 3a			jr z,.startnxt  
551c			 
551c				; exec startup line 
551c			.startdo:	 
551c e1				pop hl 
551d e5				push hl 
551e				 
551e 5e				ld e,(hl) 
551f 23				inc hl 
5520 56				ld d,(hl) 
5521 eb				ex de,hl 
5522			 
5522 e5				push hl 
5523			 
5523 3e 00			ld a, 0 
5525				;ld a, FORTH_END_BUFFER 
5525 cd 1b 10			call strlent 
5528 23				inc hl   ; include zero term to copy 
5529 06 00			ld b,0 
552b 4d				ld c,l 
552c e1				pop hl 
552d 11 60 e3			ld de, scratch 
5530 ed b0			ldir 
5532			 
5532			 
5532 21 60 e3			ld hl, scratch 
5535 cd 70 1d			call forthparse 
5538 cd b0 1d			call forthexec 
553b cd c7 1c			call forthexec_cleanup 
553e			 
553e 3e 78			ld a, display_row_4 
5540 11 d3 16			ld de, endprog 
5543			 
5543 cd a8 09			call update_display		 
5546			 
5546 3a 86 e7			ld a, (os_last_cmd) 
5549 fe 00			cp 0 
554b 20 09			jr nz, .startnxt 
554d cd 31 19			call next_page_prompt 
5550 cd 85 09		        call clear_display 
5553 cd a8 09			call update_display		 
5556			 
5556				; move onto next startup line? 
5556			.startnxt: 
5556			 
5556 cd ee 08			call delay250ms 
5559 e1				pop hl 
555a			 
555a 23				inc hl 
555b 23				inc hl 
555c			 
555c e5				push hl 
555d 5e				ld e, (hl) 
555e 23				inc hl 
555f 56				ld d, (hl) 
5560 e1				pop hl 
5561				; TODO replace 0 test 
5561			 
5561 eb				ex de, hl 
5562 cd db 0b			call ishlzero 
5565			;	ld a,e 
5565			;	add d 
5565			;	cp 0    ; any left to do? 
5565 eb				ex de, hl 
5566 c2 cb 54			jp nz, .start1 
5569 18 01			jr .startupend 
556b			 
556b e1			.startupend1: pop hl 
556c			.startupend: 
556c			 
556c cd 85 09			call clear_display 
556f cd a8 09			call update_display 
5572 c9				ret 
5573			 
5573			 
5573			; stack over and underflow checks 
5573			 
5573			; init the words to detect the under/overflow 
5573			 
5573			chk_stk_init: 
5573				; a vague random number to check so we dont get any "lucky" hits 
5573 3e 2d			ld a, 45 
5575 6f				ld l, a 
5576 00				nop 
5577 3e 17			ld a, 23 
5579 67				ld h, a 
557a			 
557a 22 47 e3			ld (chk_word), hl     ; the word we need to check against 
557d			 
557d			;	ld (chk_stund), hl	; stack points.... 
557d 22 00 ef			ld (chk_stovr), hl 
5580 22 0b eb			ld (chk_ret_und), hl 
5583 22 c9 ea			ld (chk_ret_ovr), hl 
5586 22 c7 e9			ld (chk_loop_ovr), hl 
5589 22 c5 e8			ld (chk_data_ovr), hl 
558c c9				ret 
558d				 
558d			check_stacks: 
558d				; check all stack words 
558d			 
558d e5				push hl 
558e d5				push de 
558f			 
558f			;	ld de,(chk_word) 
558f			;	ld hl, (chk_stund)	; stack points.... 
558f			;	if DEBUG_STK_FAULT 
558f			;		DMARK "FAa" 
558f			;		CALLMONITOR 
558f			;	endif 
558f			;	call cmp16 
558f			;	jp z, .chk_faulta 
558f			; 
558f			;	ld de, sfaultsu 
558f			;	jp .chk_fault 
558f			 
558f 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
5592 ed 5b 47 e3		ld de,(chk_word) 
5596				if DEBUG_STK_FAULT 
5596					DMARK "FAb" 
5596					CALLMONITOR 
5596				endif 
5596 cd d0 0b			call cmp16 
5599 28 06			jr z, .chk_fault1 
559b 11 3c 56			ld de, sfaultso 
559e c3 f0 55			jp .chk_fault 
55a1			.chk_fault1:  
55a1 2a 0b eb			ld hl, (chk_ret_und) 
55a4 ed 5b 47 e3		ld de,(chk_word) 
55a8				if DEBUG_STK_FAULT 
55a8					DMARK "FAU" 
55a8					CALLMONITOR 
55a8				endif 
55a8 cd d0 0b			call cmp16 
55ab ca b4 55			jp z, .chk_fault2 
55ae 11 4c 56			ld de, sfaultru 
55b1 c3 f0 55			jp .chk_fault 
55b4			.chk_fault2:  
55b4 2a c9 ea			ld hl, (chk_ret_ovr) 
55b7 ed 5b 47 e3		ld de,(chk_word) 
55bb				if DEBUG_STK_FAULT 
55bb					DMARK "FA1" 
55bb					CALLMONITOR 
55bb				endif 
55bb cd d0 0b			call cmp16 
55be ca c7 55			jp z, .chk_fault3 
55c1 11 5a 56			ld de, sfaultro 
55c4 c3 f0 55			jp .chk_fault 
55c7			.chk_fault3:  
55c7 2a c7 e9			ld hl, (chk_loop_ovr) 
55ca ed 5b 47 e3		ld de,(chk_word) 
55ce				if DEBUG_STK_FAULT 
55ce					DMARK "FA2" 
55ce					CALLMONITOR 
55ce				endif 
55ce cd d0 0b			call cmp16 
55d1 ca da 55			jp z, .chk_fault4 
55d4 11 74 56			ld de, sfaultlo 
55d7 c3 f0 55			jp .chk_fault 
55da			.chk_fault4:  
55da 2a c5 e8			ld hl, (chk_data_ovr) 
55dd ed 5b 47 e3		ld de,(chk_word) 
55e1				if DEBUG_STK_FAULT 
55e1					DMARK "FA3" 
55e1					CALLMONITOR 
55e1				endif 
55e1 cd d0 0b			call cmp16 
55e4 ca ed 55			jp z, .chk_fault5 
55e7 11 8e 56			ld de, sfaultdo 
55ea c3 f0 55			jp .chk_fault 
55ed			 
55ed			 
55ed			.chk_fault5:  
55ed d1				pop de 
55ee e1				pop hl 
55ef			 
55ef c9				ret 
55f0			 
55f0 cd 85 09		.chk_fault: 	call clear_display 
55f3 3e 28				ld a, display_row_2 
55f5 cd 98 09				call str_at_display 
55f8 11 1e 56				   ld de, .stackfault 
55fb 3e 00				ld a, display_row_1 
55fd cd 98 09				call str_at_display 
5600 11 7a ee				    ld de, debug_mark 
5603 3e 11				ld a, display_row_1+17 
5605 cd 98 09				call str_at_display 
5608 cd a8 09				call update_display 
560b			 
560b				; prompt before entering montior for investigating issue 
560b			 
560b 3e 78			ld a, display_row_4 
560d 11 d3 16			ld de, endprog 
5610			 
5610 cd a8 09			call update_display		 
5613			 
5613 cd 31 19			call next_page_prompt 
5616			 
5616 d1				pop de 
5617 e1				pop hl 
5618 cd 27 17				call monitor 
561b c3 21 16				jp warmstart 
561e					;jp 0 
561e					;halt 
561e			 
561e			 
561e			 
561e .. 00		.stackfault: 	db "Stack fault:",0 
562b			 
562b .. 00		sfaultsu: 	db	"Stack under flow",0 
563c .. 00		sfaultso: 	db	"Stack over flow",0 
564c .. 00		sfaultru:	db "RTS underflow",0 
565a .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
5674 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
568e .. 00		sfaultdo:	db "DTS overflow", 0 
569b			 
569b			 
569b			fault_dsp_under: 
569b 11 ad 56			ld de, .dsp_under 
569e c3 5d 57			jp .show_fault 
56a1			 
56a1			fault_rsp_under: 
56a1 11 bb 56			ld de, .rsp_under 
56a4 c3 5d 57			jp .show_fault 
56a7			fault_loop_under: 
56a7 11 c9 56			ld de, .loop_under 
56aa c3 5d 57			jp .show_fault 
56ad			 
56ad .. 00		.dsp_under: db "DSP Underflow",0 
56bb .. 00		.rsp_under: db "RSP Underflow",0 
56c9 .. 00		.loop_under: db "LOOP Underflow",0 
56d8			 
56d8			 
56d8 d5			type_faultn: 	push de 
56d9 e5					push hl 
56da cd 85 09				call clear_display 
56dd 11 04 57				   ld de, .typefaultn 
56e0 3e 00				ld a, display_row_1 
56e2 cd 98 09				call str_at_display 
56e5 11 7a ee				    ld de, debug_mark 
56e8 3e 11				ld a, display_row_1+17 
56ea cd 98 09				call str_at_display 
56ed cd a8 09				call update_display 
56f0			 
56f0				; prompt before entering montior for investigating issue 
56f0			 
56f0 3e 78			ld a, display_row_4 
56f2 11 d3 16			ld de, endprog 
56f5			 
56f5 cd a8 09			call update_display		 
56f8			 
56f8 cd 31 19			call next_page_prompt 
56fb			 
56fb e5					push hl 
56fc d5					push de 
56fd cd 27 17				call monitor 
5700 c3 21 16				jp warmstart 
5703 76					halt 
5704			 
5704			 
5704 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
571b			 
571b d5			type_faults: 	push de 
571c e5					push hl 
571d cd 85 09				call clear_display 
5720 11 46 57				   ld de, .typefaults 
5723 3e 00				ld a, display_row_1 
5725 cd 98 09				call str_at_display 
5728 11 7a ee				    ld de, debug_mark 
572b 3e 11				ld a, display_row_1+17 
572d cd 98 09				call str_at_display 
5730 cd a8 09				call update_display 
5733			 
5733				; prompt before entering montior for investigating issue 
5733			 
5733 3e 78			ld a, display_row_4 
5735 11 d3 16			ld de, endprog 
5738			 
5738 cd a8 09			call update_display		 
573b			 
573b cd 31 19			call next_page_prompt 
573e			 
573e e1					pop hl 
573f d1					pop de 
5740 cd 27 17				call monitor 
5743 c3 21 16				jp warmstart 
5746			 
5746			 
5746 .. 00		.typefaults: db "STR Type Expected TOS!",0 
575d			 
575d			.show_fault: 	 
575d d5					push de 
575e cd 85 09				call clear_display 
5761 d1					pop de 
5762 3e 00				ld a, display_row_1 
5764 cd 98 09				call str_at_display 
5767 11 7a ee				    ld de, debug_mark 
576a 3e 11				ld a, display_row_1+17 
576c cd 98 09				call str_at_display 
576f cd a8 09				call update_display 
5772			 
5772				; prompt before entering montior for investigating issue 
5772			 
5772 3e 78			ld a, display_row_4 
5774 11 d3 16			ld de, endprog 
5777			 
5777 cd a8 09			call update_display		 
577a			 
577a cd 31 19			call next_page_prompt 
577d			 
577d e1					pop hl 
577e d1					pop de 
577f cd 27 17				call monitor 
5782			; do a dump to cli and not warmstart so we preserve all of the uwords.  
5782			; TODO Make optional fault restart to cli or warm boot? 
5782					;jp warmstart 
5782 c3 79 16				jp cli 
5785 76					halt 
5786			 
5786			; handle the auto run of code from files in storage 
5786			 
5786			 
5786			if STORAGE_SE 
5786			 
5786			sprompt3: db "Loading from start-up file?:",0 
5786			sprompt4: db "(Y=Any key/N=No)",0 
5786			 
5786			 
5786			forth_autoload: 
5786			 
5786				; load block 0 of store 1 
5786				 
5786				ld a, $fe      ; bit 0 clear 
5786				ld (spi_device), a 
5786			 
5786				call storage_get_block_0 
5786			 
5786				ld a, (store_page+STORE_0_AUTOFILE) 
5786			 
5786				cp 0 
5786				ret z     ; auto start not enabled 
5786			 
5786				call clear_display 
5786			 
5786				; set bank 
5786			 
5786					ld a, (store_page+STORE_0_BANKRUN) 
5786					ld (spi_device), a 
5786			 
5786				; get file id to load from and get the file name to display 
5786			 
5786					ld a, (store_page+STORE_0_FILERUN) 
5786			 
5786					ld l, 0 
5786					ld h, a 
5786					ld de, store_page 
5786			 
5786					if DEBUG_FORTH_WORDS 
5786						DMARK "ASp" 
5786						CALLMONITOR 
5786					endif 
5786					call storage_read 
5786			 
5786					if DEBUG_FORTH_WORDS 
5786						DMARK "ASr" 
5786						CALLMONITOR 
5786					endif 
5786			 
5786					call ishlzero 
5786					ret z             ; file not found 
5786			 
5786					ld a, display_row_2 + 10 
5786					ld de, store_page+3 
5786					call str_at_display 
5786				 
5786			; 
5786			 
5786				ld a, display_row_1+5 
5786				ld de, sprompt3 
5786				call str_at_display 
5786				ld a, display_row_3+15 
5786				ld de, sprompt4 
5786				call str_at_display 
5786			 
5786				call update_display 
5786			 
5786				call cin_wait 
5786				cp 'n' 
5786				ret z 
5786				cp 'N' 
5786				ret z 
5786			 
5786				call delay1s 
5786			 
5786				ld a, (store_page+2) 
5786				ld (store_openmaxext), a    ; save count of ext 
5786				ld a, 1  
5786				ld (store_openext), a    ; save count of ext 
5786			 
5786			.autof:  
5786				ld l , a 
5786				 
5786				ld a, (store_page) 
5786				ld h, a	 
5786				ld de, store_page 
5786					if DEBUG_FORTH_WORDS 
5786						DMARK "ASl" 
5786						CALLMONITOR 
5786					endif 
5786					call storage_read 
5786				call ishlzero 
5786				ret z 
5786			 
5786					if DEBUG_FORTH_WORDS 
5786						DMARK "ASc" 
5786						CALLMONITOR 
5786					endif 
5786				ld de, store_page+2 
5786				ld a, display_row_4 
5786				call str_at_display 
5786			 
5786				call update_display 
5786				call delay250ms 
5786			 
5786			 
5786			 
5786				ld hl, store_page+2 
5786				call forthparse 
5786				call forthexec 
5786				call forthexec_cleanup 
5786			 
5786				 
5786				ld a, (store_openext) 
5786				inc a 
5786				ld (store_openext), a    ; save count of ext 
5786			 
5786				jr .autof 
5786			 
5786			;.autofdone: 
5786			; 
5786			;		if DEBUG_FORTH_WORDS 
5786			;			DMARK "ASx" 
5786			;			CALLMONITOR 
5786			;		endif 
5786			;;	call clear_display 
5786			;	ret 
5786			 
5786			 
5786			 
5786			endif 
5786			 
5786			 
5786			; eof 
# End of file forth_kernel.asm
5786			;include "nascombasic.asm" 
5786			 
5786			 
5786			; find out where the code ends if loaded into RAM (for SC114) 
5786			;endofcode:  
5786			;	nop 
5786			 
5786			 
5786			; eof 
5786			 
# End of file main.asm
5786			;include "firmware_lcd_4x40.asm" 
5786			;;include "firmware_lcd_4x20.asm" 
5786			include "firmware_cpm_display.asm" 
5786			 
5786			; Serial display interface for SC114 
5786			 
5786			 
5786			display_row_1: equ 0 
5786			display_row_2: equ display_row_1+display_cols 
5786			display_row_3: equ display_row_2 + display_cols 
5786			display_row_4: equ display_row_3 + display_cols 
5786			 
5786			kLCDWidth:  EQU display_cols             ;Width in characters 
5786			kLCD_Line1: EQU 0x00  
5786			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
5786			; E1 
5786			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
5786			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
5786			 
5786			lcd_init: 
5786				; no init as handled by the SCM bios 
5786 c9				ret 
5787			 
5787			 
5787			; low level functions for direct screen writes 
5787			 
5787			; output char at pos? 
5787			fLCD_Str: 
5787			        ;out (SC114_SIO_1_OUT),a 
5787 c5				push bc 
5788 d5				push de 
5789 5f				ld e, a 
578a			; TODO Replace with CP/M BIOS call 
578a 0e 02			ld c, $02 
578c cd 05 00			call 5 
578f d1				pop de 
5790 c1				pop bc 
5791 c9				ret 
5792			 
5792			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
5792			fLCD_Pos: 
5792				; use ASCII escape to position 
5792			        ;out (SC114_SIO_1_OUT),a 
5792 c5				push bc 
5793 d5				push de 
5794 5f				ld e, a 
5795 0e 02			ld c, $02 
5797			; TODO Replace with CP/M BIOS call 
5797 cd 05 00			call 5 
579a d1				pop de 
579b c1				pop bc 
579c			 
579c c9				ret 
579d			 
579d			; output char at pos 
579d			fLCD_Data: 
579d			      ;  out (SC114_SIO_1_OUT),a 
579d c5				push bc 
579e d5				push de 
579f 0e 02			ld c, $02 
57a1 5f				ld e, a 
57a2			; TODO Replace with CP/M BIOS call 
57a2 cd 05 00			call 5 
57a5 d1				pop de 
57a6 c1				pop bc 
57a7			 
57a7 c9				ret 
57a8			 
57a8			; ascii cls  
57a8			 
57a8 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
57ac			 
57ac 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
57c3			;.clscpm: db 3, $3c,"$" 
57c3			 
57c3			; write the frame buffer given in hl to hardware  
57c3			write_display: 
57c3			 
57c3			API: equ 0 
57c3			 
57c3			if API 
57c3				push bc 
57c3				ld b, 4 
57c3			 
57c3			        ld (display_write_tmp), hl 	  
57c3			 
57c3				; clear and home cursor 
57c3			 
57c3				ld c, 9 
57c3				ld de, .cls 
57c3			; TODO Replace with CP/M BIOS call 
57c3				call 5 
57c3			 
57c3			 
57c3			.writeln: 
57c3			 
57c3				ld de, (display_write_tmp) 
57c3				ld c, 6 
57c3			; TODO Replace with CP/M BIOS call 
57c3				rst $30 
57c3				ld c, 7 
57c3				rst $30 
57c3			 
57c3				ld hl, (display_write_tmp) 
57c3				ld de, display_cols 
57c3				add hl,de 
57c3				ld (display_write_tmp),hl 
57c3			 
57c3				djnz  .writeln 
57c3			 
57c3				pop bc 
57c3			 
57c3			 
57c3				ret 
57c3			endif 
57c3 e5				push hl 
57c4 c5				push bc 
57c5 d5				push de 
57c6			 
57c6			;	ld c, 2 
57c6			;	;ld de, .cls 
57c6			;	ld a, 27 
57c6			;	rst $30 
57c6			;	ld c, 2 
57c6			;	;ld de, .cls 
57c6			;	ld a, '[' 
57c6			;	rst $30 
57c6			; 
57c6			;	ld c, 2 
57c6			;	;ld de, .cls 
57c6			;	ld a, 'H' 
57c6			;	rst $30 
57c6			; 
57c6			 
57c6			 
57c6			; lots of CR/LF 
57c6			;	ld c, 9 
57c6			;	ld de, .clscpm 
57c6			;	call 5 
57c6			 
57c6			; xterm cls 
57c6 0e 02			ld c, 2 
57c8 1e 1b			ld e, 27 
57ca cd 05 00			call 5 
57cd			; cls causes too much flicker 
57cd			;	ld c, 2 
57cd			;	ld e, 'c' 
57cd			;	call 5 
57cd			 
57cd			; use xterm home instead 
57cd 0e 02			ld c, 2 
57cf 1e 5b			ld e, '[' 
57d1 cd 05 00			call 5 
57d4 0e 02			ld c, 2 
57d6 1e 48			ld e, 'H' 
57d8 cd 05 00			call 5 
57db			LLL: equ 0 
57db			 
57db			if LLL 
57db			 
57db				ld c, 2 
57db				;ld de, .cls 
57db				ld e, 27 
57db			; TODO Replace with CP/M BIOS call 
57db				call 5 
57db			 
57db			 
57db				ld c, 2 
57db				;ld de, .cls 
57db				ld e, '[' 
57db			; TODO Replace with CP/M BIOS call 
57db				call 5 
57db				ld c, 2 
57db				;ld de, .cls 
57db				ld e, '2' 
57db			; TODO Replace with CP/M BIOS call 
57db				call 5 
57db				ld c, 2 
57db				;ld de, .cls 
57db				ld e, 'J' 
57db			; TODO Replace with CP/M BIOS call 
57db				call 5 
57db			 
57db			endif 
57db			 
57db d1				pop de 
57dc c1				pop bc 
57dd e1				pop hl 
57de			 
57de			 
57de 22 d8 eb		        ld (display_write_tmp), hl 	  
57e1 3e 00			ld a, kLCD_Line1 
57e3			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
57e3 06 28			ld b, display_cols 
57e5 ed 5b d8 eb		ld de, (display_write_tmp) 
57e9 cd 6c 58			call write_len_string 
57ec				 
57ec			 
57ec e5			push hl 
57ed d5			push de 
57ee c5			push bc 
57ef 0e 02			ld c, 2 
57f1 1e 0a			ld e, 10 
57f3 cd 05 00			call 5 
57f6 0e 02			ld c, 2 
57f8 1e 0d			ld e, 13 
57fa cd 05 00			call 5 
57fd			; TODO Replace with CP/M BIOS call 
57fd				;rst $30 
57fd c1			pop bc 
57fe d1			pop de 
57ff e1			pop hl 
5800			 
5800				 
5800 2a d8 eb			ld hl, (display_write_tmp) 
5803 11 28 00			ld de, display_cols 
5806 19				add hl,de 
5807 22 d8 eb			ld (display_write_tmp),hl 
580a			 
580a				 
580a 3e 28			ld a, kLCD_Line2 
580c			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
580c 06 28			ld b, display_cols 
580e ed 5b d8 eb		ld de, (display_write_tmp) 
5812 cd 6c 58			call write_len_string 
5815				 
5815 2a d8 eb			ld hl, (display_write_tmp) 
5818 11 28 00			ld de, display_cols 
581b 19				add hl,de 
581c 22 d8 eb			ld (display_write_tmp),hl 
581f			 
581f e5			push hl 
5820 d5			push de 
5821 c5			push bc 
5822 0e 07			ld c, 7 
5824			; TODO Replace with CP/M BIOS call 
5824				;rst $30 
5824 0e 02			ld c, 2 
5826 1e 0a			ld e, 10 
5828 cd 05 00			call 5 
582b 0e 02			ld c, 2 
582d 1e 0d			ld e, 13 
582f cd 05 00			call 5 
5832 c1			pop bc 
5833 d1			pop de 
5834 e1			pop hl 
5835			 
5835				 
5835 3e 50			ld a, kLCD_Line3 
5837			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
5837 06 28			ld b, display_cols 
5839 ed 5b d8 eb		ld de, (display_write_tmp) 
583d cd 6c 58			call write_len_string 
5840				 
5840 2a d8 eb			ld hl, (display_write_tmp) 
5843 11 28 00			ld de, display_cols 
5846 19				add hl,de 
5847 22 d8 eb			ld (display_write_tmp),hl 
584a			 
584a e5			push hl 
584b d5			push de 
584c c5			push bc 
584d 0e 07			ld c, 7 
584f			; TODO Replace with CP/M BIOS call 
584f				;rst $30 
584f 0e 02			ld c, 2 
5851 1e 0a			ld e, 10 
5853 cd 05 00			call 5 
5856 0e 02			ld c, 2 
5858 1e 0d			ld e, 13 
585a cd 05 00			call 5 
585d c1			pop bc 
585e d1			pop de 
585f e1			pop hl 
5860			 
5860				 
5860 3e 78			ld a, kLCD_Line4 
5862			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
5862 06 28			ld b, display_cols 
5864 ed 5b d8 eb		ld de, (display_write_tmp) 
5868 cd 6c 58			call write_len_string 
586b c9					ret 
586c			 
586c			 
586c				; write out a fixed length string given in b from de 
586c			 
586c 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
586d cd 9d 57		            CALL fLCD_Data      ;Write character to display 
5870 13				inc de 
5871 10 f9			djnz write_len_string 
5873 c9				ret 
5874			 
5874			 
5874			; eof 
# End of file firmware_cpm_display.asm
5874			;include "firmware_key_5x10.asm" 
5874			;;include "firmware_key_4x10.asm" 
5874			include "firmware_key_cpm.asm" 
5874			; Serial keyboard interface for SC114 
5874			 
5874			 
5874			key_init: 
5874				; no init as handled by the SCM bios 
5874 c9				ret 
5875			 
5875			 
5875			cin_wait: 
5875			;	ld a, 0 
5875			;	ret 
5875			 
5875				;in a,(SC114_SIO_1_IN) 
5875			        ; Use SCM API to get from whatever console device we are using 
5875			 
5875			; TODO Replace with CP/M BIOS call 
5875 c5				push bc 
5876 0e 01			ld c, $01 
5878 cd 05 00			call 5 
587b c1				pop bc 
587c c9				ret 
587d			 
587d			cin: 
587d			 
587d			 
587d c5				push bc 
587e			 
587e				; any key waiting to process? 
587e			; TODO Replace with CP/M BIOS call 
587e 0e 06			ld c, $06 
5880 cd 05 00			call 5 
5883 28 0d			jr z, .cin_skip 
5885			 
5885				; yep, get it 
5885			 
5885 0e 01			ld c, $01 
5887			; TODO Replace with CP/M BIOS call 
5887 cd 05 00			call 5 
588a			 
588a fe 7f			cp $7f     ; back space 
588c 20 02			jr nz, .skipbs 
588e 3e 08			ld a, KEY_BS 
5890			.skipbs: 
5890			 
5890 c1				pop bc 
5891 c9				ret 
5892			.cin_skip: 
5892 3e 00			ld a, 0 
5894 c1				pop bc 
5895 c9				ret 
5896			 
5896			 
5896			 
5896			 
# End of file firmware_key_cpm.asm
5896			endofcode:  
5896			baseram:  
5896 00				nop 
5897			 
5897			heap_start: equ baseram+15  ; Starting address of heap 
5897			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
5897			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
5897			;VDU:  EQU     endofcode           ; BASIC Work space 
5897			; eof 
5897			 
# End of file os_mega_cpm.asm
5897
