# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 51 18			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
011c			 
011c			 
011c			;        nop  
011c			;        nop 
011c			;;	org 05h		; null out bdos call 
011c			; 
011c			;        nop  
011c			;        nop  
011c			;        nop 
011c			;;	org 08h 
011c			;;; 
011c			;;	jp cin		; rst 8 - char in 
011c			;;; 
011c			; 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;	org 010h 
011c			;; 
011c			;	jp cout		; rest 010h  - char out 
011c			;; 
011c			;	org 01bh   
011c			; 
011c			;	;jp  		; rst 01bh   - write string to display 
011c			;	jp str_at_display 
011c			; 
011c			; 
011c			;	org 020h 
011c			; 
011c			;	; jp		 ; rst 020h - read char at screen location 
011c			; 
011c			;	org 028h 
011c			 
011c				; jp		 ; rst 028h  - storage i/o 
011c			 
011c			; 	org 030h 
011c			;	jp break_point_state 
011c			  
011c			; $30  
011c			; org 038h 
011c			; $38 
011c			 
011c			; TODO any more important entry points to add to jump table for easier coding use? 
011c			 
011c			 
011c			include "firmware.asm" 
011c			  
011c			; main constants (used here and in firmware)  
011c			  
011c			; TODO have page 0 of storage as bios  
011c			  
011c			Device_A: equ 0h  
011c			Device_B: equ 040h          ; Sound  
011c			  
011c			if BASE_KEV  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_SC114  
011c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			; TODO fixup for CPM  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			Device_D: equ 0c0h             ; Keyboard and LCD  
011c			  
011c			; Odd specific debug points for testing hardware dev  
011c			  
011c			DEBUG_SOUND: equ 1  
011c			DEBUG_STK_FAULT: equ 0  
011c			DEBUG_INPUT: equ 0     ; Debug input entry code  
011c			DEBUG_KEYCINWAIT: equ 0  
011c			DEBUG_KEYCIN: equ 0  
011c			DEBUG_KEY: equ 0  
011c			DEBUG_KEY_MATRIX: equ 0  
011c			DEBUG_STORECF: equ 0  
011c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011c			DEBUG_SPI: equ 0    ; low level spi tests  
011c			  
011c			; Enable many break points  
011c			  
011c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011c			DEBUG_FORTH_JP: equ 0    ; 4  
011c			DEBUG_FORTH_MALLOC: equ 0  
011c			DEBUG_FORTH_MALLOC_INT: equ 0  
011c			DEBUG_FORTH_DOT: equ 1  
011c			DEBUG_FORTH_DOT_WAIT: equ 0  
011c			DEBUG_FORTH_MATHS: equ 0  
011c			DEBUG_FORTH_TOK: equ 0    ; 4  
011c			DEBUG_FORTH_PARSE: equ 0    ; 3  
011c			DEBUG_FORTH: equ 0  ;2  
011c			DEBUG_FORTH_WORDS: equ 1   ; 1  
011c			DEBUG_FORTH_PUSH: equ 1   ; 1  
011c			DEBUG_FORTH_UWORD: equ 1   ; 1  
011c			  
011c			; Enable key point breakpoints  
011c			  
011c			DEBUG_FORTH_DOT_KEY: equ 0  
011c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011c			  
011c			; Debug stack imbalances  
011c			  
011c			ON: equ 1  
011c			OFF: equ 0  
011c			  
011c			DEBUG_STACK_IMB: equ 0  
011c			STACK_IMB_STORE: equ 20  
011c			  
011c			; House keeping and protections  
011c			  
011c			DEBUG_FORTH_STACK_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011c			FORTH_ENABLE_FREE: equ 0  
011c			FORTH_ENABLE_MALLOCFREE: equ 1  
011c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011c			FORTH_ENABLE_FLOATMATH: equ 0  
011c			  
011c			  
011c			CALLMONITOR: macro  
011c				call break_point_state  
011c				endm  
011c			  
011c			MALLOC_1: equ 1        ; from dk88   
011c			MALLOC_2: equ 0           ; broke  
011c			MALLOC_3: equ 0           ; really broke  
011c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011c			  
011c			if BASE_KEV   
011c			stacksize: equ 256  
011c			  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 512  
011c			endif  
011c			if BASE_SC114  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			;if STORAGE_SE == 0  
011c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011c			;endif  
011c			  
011c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011c			  
011c			STORE_0_AUTORUN: equ $20  
011c			  
011c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011c			  
011c			STORE_0_AUTOFILE: equ $21  
011c			STORE_0_BANKRUN: equ $23  
011c			STORE_0_FILERUN: equ $24  
011c			  
011c			; Block 0 offsets for settings  
011c			  
011c			; if set then skip prompt for start up and accept all  
011c			  
011c			STORE_0_QUICKSTART: equ $25  
011c			  
011c			; Blocks where directory table is held  
011c			  
011c			; Reducing the number of entries increases the max file size  
011c			  
011c			;STORE_DIR_START: equ 1  
011c			;STORE_DIR_END: equ 33  
011c			  
011c			; Blocks from where file data is stored  
011c			  
011c			;STORE_DATA_START: equ STORE_DIR_END + 1  
011c			  
011c			; Block indicators (<32 are data files)  
011c			  
011c			;STORE_BLOCK_CFG: equ $8f       ; config block  
011c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011c			;STORE_BLOCK_FREE: equ $85       ; data block free  
011c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011c			  
011c			  
011c			  
011c			; Directory entry flags  
011c			  
011c			;STORE_DIR_FREE: equ 0  
011c			;STORE_DIR_FILE:  equ 1  
011c			  
011c			; Structure offsets to directory entries  
011c			;STORE_DE_FLAG: equ 0  
011c			;STORE_DE_MAXEXT: equ 1  
011c			;STORE_DE_FILENAME: equ 2  
011c			  
011c			; Structure offsets to block 0  
011c			  
011c			;STORE_BK0_ISFOR: equ 1  
011c			;STORE_BK0_LABEL: equ 3  
011c			  
011c			; memory allocation   
011c			  
011c			chk_stund: equ tos+2           ; underflow check word  
011c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011c			  
011c			; keyscan table needs rows x cols buffer  
011c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011c			  
011c			keyscan_table_row1: equ chk_stovr -key_cols-1  
011c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011c			keyscan_scancol: equ keyscan_table-key_cols  
011c			;keyscan_table_len: equ key_rows*key_cols  
011c			;keybufptr: equ keyscan_table - 2  
011c			;keysymbol: equ keybufptr - 1  
011c			key_held: equ keyscan_scancol-1	; currently held  
011c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011c			key_fa: equ key_repeat_ct -1 ;  
011c			key_fb: equ key_fa -1 ;  
011c			key_fc: equ key_fb -1 ;  
011c			key_fd: equ key_fc -1 ;  
011c			key_face_held: equ key_fd - 1   
011c			  
011c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011c			  
011c			hardware_config: equ key_face_held - 10  
011c			  
011c			; hardware config switches  
011c			; TODO add bitmasks on includes for hardware  
011c			; high byte for expansion ids  
011c			;     0000 0000  no card inserted  
011c			;     0000 0001  storage card inserted  
011c			;     0000 0010  spi sd card active  
011c			  
011c			;       
011c			; low byte:  
011c			;     0000 0001   4x4 keypad  
011c			;     0000 0010   full keyboard  
011c			;     0000 0011   spi/ext keyboard  
011c			;     0000 0100   20x4 lcd  
011c			;     0000 1000   40x4 lcd  
011c			;     0000 1100   spi/ext display  
011c			;     0001 0000   ide interface available  
011c			  
011c			hardware_word: equ hardware_config - 2  
011c			  
011c			; debug marker - optional display of debug point on the debug screens  
011c			  
011c			debug_mark: equ hardware_word - 4  
011c			  
011c			; input_str vars  
011c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011c			input_size: equ input_start -1  ; number of chars  
011c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011c			input_len: equ input_cur_onoff - 5 ; length of current input  
011c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011c			  
011c			CUR_BLINK_RATE: equ 15  
011c			  
011c			key_actual_pressed: equ input_cursor - 1   
011c			key_symbol: equ key_actual_pressed - 1   
011c			key_shift: equ key_symbol - 1   
011c			  
011c			; Display allocation  
011c			  
011c			;display_rows: equ 4     ; move out to mini and mega files  
011c			;display_cols: equ 20  
011c			  
011c			display_fb_len: equ display_rows*display_cols  
011c			  
011c			; primary frame buffer     
011c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011c			; working frame buffers  
011c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011c			display_fb3: equ  display_fb1-display_fb_len - 1  
011c			display_fb2: equ  display_fb3-display_fb_len - 1  
011c			;  
011c			; pointer to active frame buffer  
011c			display_fb_active: equ display_fb2 - 2  
011c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011c			display_write_tmp: equ display_lcde1e2 - 2  
011c			  
011c			  
011c			;  
011c			  
011c			;; can load into de directory  
011c			cursor_col: equ display_write_tmp-1  
011c			cursor_row: equ cursor_col-1  
011c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011c			  
011c			; maths vars  
011c			  
011c			LFSRSeed: equ cursor_shape -20   
011c			randData: equ LFSRSeed - 2  
011c			xrandc: equ randData - 2  
011c			stackstore: equ xrandc - 2  
011c			seed1: equ  stackstore -2   
011c			seed2: equ seed1 - 2  
011c			  
011c			; cf storage vars  
011c			  
011c			iErrorNum:  equ seed2-1         ;Error number  
011c			iErrorReg:  equ iErrorNum -1              ;Error register  
011c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011c			  
011c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011c			  
011c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011c			  
011c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011c			store_tmpid: equ store_tmp3 - 1		; page temp id  
011c			store_tmpext: equ store_tmpid - 1		; file extent temp  
011c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011c			;  
011c			; spi vars  
011c			  
011c			  
011c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011c			spi_device_id: equ spi_device - 1    ; human readable bank number  
011c			  
011c			;;;;; forth cli params  
011c			  
011c			; TODO use a different frame buffer for forth???  
011c			  
011c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011c			  
011c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011c			  
011c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011c			  
011c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011c			  
011c			; os/forth token vars  
011c			  
011c			os_last_cmd: equ os_var_array-255  
011c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011c			os_current_i: equ os_cli_cmd-2  
011c			os_cur_ptr: equ os_current_i-2  
011c			os_word_scratch: equ os_cur_ptr-30  
011c			os_tok_len: equ os_word_scratch - 2  
011c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011c			os_tok_malloc: equ os_tok_ptr - 2  
011c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011c			execscratch: equ os_input-255        ; exec cmd eval buffer  
011c			scratch: equ execscratch-255  
011c			  
011c			  
011c			; temp locations for new word processing to save on adding more   
011c			  
011c			os_new_malloc: equ scratch-2  
011c			os_new_parse_len: equ os_new_malloc - 2  
011c			os_new_word_len: equ os_new_parse_len - 2  
011c			os_new_work_ptr: equ os_new_word_len - 2  
011c			os_new_src_ptr: equ os_new_work_ptr - 2  
011c			os_new_exec: equ os_new_src_ptr - 2  
011c			os_new_exec_ptr: equ os_new_exec - 2  
011c			  
011c			; resume memory alloocations....  
011c			  
011c			os_view_disable: equ os_new_exec_ptr - 1  
011c			os_view_af: equ os_view_disable - 2  
011c			os_view_hl: equ os_view_af -2  
011c			os_view_de: equ os_view_hl - 2  
011c			os_view_bc: equ os_view_de - 2  
011c			  
011c			; stack checksum word  
011c			if DEBUG_STACK_IMB  
011c				curframe: equ  os_view_de - 5  
011c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			else  
011c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			endif  
011c			  
011c			; with data stack could see memory filled with junk. need some memory management   
011c			; malloc and free entry points added  
011c			  
011c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			;heap_end: equ free_list-1  ; Starting address of heap  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			heap_end: equ chk_word-1  ; Starting address of heap  
011c			  
011c			  
011c			;if BASE_KEV   
011c			;heap_start: equ 0800eh  ; Starting address of heap  
011c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;heap_start: equ baseram+15  ; Starting address of heap  
011c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;endif  
011c			  
011c			  
011c			;;;;  
011c			  
011c			  
011c			; change below to point to last memory alloc above  
011c			topusermem:  equ   heap_start  
011c			  
011c			;if BASE_KEV   
011c			;baseusermem: equ 08000h  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;;aseusermem:     equ    12  
011c			;baseusermem:     equ    prompt  
011c			;;baseusermem:     equ    endofcode  
011c			;endif  
011c			  
011c			  
011c			; **********************************************************************  
011c			; **  Constants  
011c			; **********************************************************************  
011c			  
011c			; Constants used by this code module  
011c			kDataReg:   EQU Device_D           ;PIO port A data register  
011c			kContReg:   EQU Device_D+2           ;PIO port A control register  
011c			  
011c			  
011c			portbdata:  equ Device_D+1    ; port b data  
011c			portbctl:   equ Device_D+3    ; port b control  
011c			  
011c			  
011c			;KEY_SHIFT:   equ 5  
011c			;KEY_SYMBOLSHIFT:  equ 6  
011c			  
011c			KEY_SHIFTLOCK: equ 4  
011c			  
011c			  
011c			KEY_UP: equ 5  
011c			KEY_NEXTWORD: equ 6  
011c			KEY_PREVWORD: equ 7  
011c			KEY_BS: equ 8  
011c			KEY_TAB:  equ 9  
011c			KEY_DOWN: equ 10  
011c			KEY_LEFT: equ 11  
011c			KEY_RIGHT: equ 12  
011c			KEY_CR:   equ 13  
011c			KEY_HOME: equ 14  
011c			KEY_END: equ 15  
011c			  
011c			KEY_F1: equ 16  
011c			KEY_F2: equ 17  
011c			KEY_F3: equ 18  
011c			KEY_F4: equ 19  
011c			  
011c			KEY_F5: equ 20  
011c			KEY_F6: equ 21  
011c			KEY_F7: equ 22  
011c			KEY_F8: equ 23  
011c			  
011c			KEY_F9: equ 24  
011c			KEY_F10: equ 25  
011c			KEY_F11: equ 26  
011c			KEY_F12: equ 27  
011c			  
011c			;if DEBUG_KEY  
011c			;	KEY_MATRIX_NO_PRESS: equ '.'  
011c			;	KEY_SHIFT:   equ '.'  
011c			;	KEY_SYMBOLSHIFT:  equ '.'  
011c			;else  
011c				KEY_SHIFT:   equ '~'  
011c				KEY_SYMBOLSHIFT:  equ '~'  
011c				KEY_MATRIX_NO_PRESS: equ '~'  
011c			;endi  
011c			  
011c			  
011c			  
011c			  
011c			; Macro to make adding debug marks easier  
011c			  
011c			DMARK: macro str  
011c				push af  
011c				ld a, (.dmark)  
011c				ld (debug_mark),a  
011c				ld a, (.dmark+1)  
011c				ld (debug_mark+1),a  
011c				ld a, (.dmark+2)  
011c				ld (debug_mark+2),a  
011c				jr .pastdmark  
011c			.dmark: db str  
011c			.pastdmark: pop af  
011c			  
011c			endm  
011c			  
011c			  
011c			; macro to detect for stack imbalances  
011c			  
011c			include "stackimbal.asm"  
011c			; Macro and code to detect stock imbalances 
011c			 
011c			SPPUSH: equ 0 
011c			 
011c			; Add a stack frame which can be checked before return 
011c			 
011c			STACKFRAME: macro onoff frame1 frame2 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c						exx 
011c			 
011c						ld de, frame1 
011c						ld a, d 
011c						ld hl, curframe 
011c						call hexout 
011c						ld a, e 
011c						ld hl, curframe+2 
011c						call hexout 
011c			  
011c						ld hl, frame1 
011c						push hl 
011c						ld hl, frame2 
011c						push hl 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			endm 
011c			 
011c			STACKFRAMECHK: macro onoff frame1 frame2 
011c			 
011c					 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						exx 
011c						; check stack frame SP 
011c			 
011c						ld hl, frame2 
011c						pop de   ; frame2 
011c			 
011c						call cmp16 
011c						jr nz, .spnosame 
011c						 
011c			 
011c						ld hl, frame1 
011c						pop de   ; frame1 
011c			 
011c						call cmp16 
011c						jr z, .spfrsame 
011c			 
011c						.spnosame: call showsperror 
011c			 
011c						.spfrsame: nop 
011c			 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			 
011c			 
011c			endm 
011c			 
011c			 
011c			; for a sub routine, wrap SP collection and comparisons 
011c			 
011c			; Usage: 
011c			; 
011c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011c			 
011c			SAVESP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c			 
011c						ld (store_sp+(storeword*4)), sp 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			CHECKSP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c			 
011c						; save SP after last save 
011c				 
011c						ld (store_sp+(storeword*4)+2), sp 
011c			 
011c						push hl 
011c						ld hl, store_sp+(storeword*4) 
011c						call check_stack_sp  
011c						pop hl 
011c			 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			if DEBUG_STACK_IMB 
011c			 
011c			check_stack_sp: 
011c					push de 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					push de 
011c			 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					pop hl 
011c			 
011c			 
011c					; check to see if the same 
011c			 
011c					call cmp16 
011c					jr z, .spsame 
011c			 
011c					; not same 
011c			 
011c					call showsperror 
011c			.spsame: 
011c			 
011c					pop de 
011c			 
011c					ret 
011c			 
011c			.sperr:  db "Stack imbalance",0 
011c			 
011c			 
011c			showsperror: 
011c			 
011c			 
011c				push hl 
011c				push af 
011c				push de 
011c				call clear_display 
011c				ld de, .sperr 
011c				ld a,0 
011c			;	ld de,os_word_scratch 
011c				call str_at_display 
011c				ld a, display_row_1+17 
011c				ld de, debug_mark 
011c				call str_at_display 
011c				ld a, 0 
011c				ld (curframe+4),a 
011c				ld hl, curframe 
011c				ld de, os_word_scratch 
011c				ld a, display_row_4 
011c				call str_at_display 
011c				call update_display 
011c				;call break_point_state 
011c				call cin_wait 
011c			 
011c				ld a, ' ' 
011c				ld (os_view_disable), a 
011c				pop de	 
011c				pop af 
011c				pop hl 
011c				CALLMONITOR 
011c				ret 
011c			 
011c			endif 
011c			 
011c			 
011c			 
011c			; eof 
# End of file stackimbal.asm
011c			  
011c			;TODO macro to calc col and row offset into screen  
011c			  
011c			  
011c			  
011c			hardware_init:  
011c			  
011c				  
011c			  
011c					;ld a, 0  
011c					;ld (hardware_diag), a  
011c			  
011c					; clear all the buffers  
011c			  
011c 21 16 ed				ld hl, display_fb1  
011f 22 d2 eb				ld (display_fb_active), hl  
0122			  
0122 cd 80 0b				call clear_display  
0125			  
0125 21 d4 eb				ld hl, display_fb2  
0128 22 d2 eb				ld (display_fb_active), hl  
012b			  
012b cd 80 0b				call clear_display  
012e			  
012e					; init primary frame buffer area  
012e 21 b7 ed				ld hl, display_fb0  
0131 22 d2 eb				ld (display_fb_active), hl  
0134			  
0134 cd 80 0b				call clear_display  
0137			  
0137			  
0137 cd ae 60				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013a			  
013a cd 9c 61			call key_init  
013d cd 9f 01			call storage_init  
0140			  
0140				; setup malloc functions  
0140			  
0140				if MALLOC_1  
0140 cd 50 12				call  heap_init  
0143				endif  
0143				if MALLOC_4  
0143					call  heap_init  
0143				endif  
0143			  
0143				; init sound hardware if present  
0143			  
0143				if SOUND_ENABLE  
0143					call sound_init  
0143				endif  
0143			  
0143				; lcd test sequence  
0143					  
0143 cd a3 0b			call update_display  
0146 cd f2 0a			call delay1s  
0149 3e 2b			ld a,'+'  
014b cd 85 0b			call fill_display  
014e cd a3 0b			call update_display  
0151 cd f2 0a			call delay1s  
0154 3e 2a			ld a,'*'  
0156 cd 85 0b			call fill_display  
0159 cd a3 0b			call update_display  
015c cd f2 0a			call delay1s  
015f 3e 2d			ld a,'-'  
0161 cd 85 0b			call fill_display  
0164 cd a3 0b			call update_display  
0167 cd f2 0a			call delay1s  
016a			  
016a			; boot splash screen  
016a			if display_cols == 20	  
016a			        ld a, display_row_1    
016a			else  
016a 3e 0a		        ld a, display_row_1 +10   
016c			endif  
016c 11 84 17			ld de, prom_bootmsg  
016f cd 93 0b			call str_at_display  
0172 cd a3 0b			call update_display  
0175			  
0175			  
0175 cd f2 0a			call delay1s  
0178 cd f2 0a			call delay1s  
017b			if display_cols == 20	  
017b			            LD   A, display_row_3+2  
017b			else  
017b 3e 5c		            LD   A, display_row_3+12  
017d			endif  
017d 11 99 17			ld de, prom_bootmsg1  
0180 cd 93 0b			call str_at_display  
0183 cd a3 0b			call update_display  
0186 cd f2 0a			call delay1s  
0189 cd f2 0a			call delay1s  
018c			  
018c			;	ld a, display_row_4+3  
018c			;	ld de, bootmsg2  
018c			;	call str_at_display  
018c			;	call update_display  
018c			;	call delay1s  
018c			;	call delay1s  
018c			  
018c			; debug mark setup  
018c			  
018c 3e 5f		ld a, '_'  
018e 32 71 ee		ld (debug_mark),a  
0191 32 72 ee		ld (debug_mark+1),a  
0194 32 73 ee		ld (debug_mark+2),a  
0197 3e 00		ld a,0  
0199 32 74 ee		ld (debug_mark+3),a  
019c			  
019c c9					ret  
019d			  
019d			  
019d			;bootmsg2:	db "Firmware v0.1",0  
019d			  
019d			; a 4x20 lcd  
019d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019d			  
019d			;if display_cols == 20  
019d			;	include "firmware_lcd_4x20.asm"  
019d			;endif  
019d			  
019d			;if display_cols == 40  
019d			;	include "firmware_lcd_4x40.asm"  
019d			;endif  
019d			  
019d			;  
019d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019d			; TODO abstract the bit bang video out interface for dual display  
019d			; TODO wire video out to tx pin on rc2014 bus  
019d			  
019d			; must supply cin, and cin_wait for low level hardware abstraction   
019d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019d			; test scancode  
019d			  
019d			;;;;;  
019d			;;;  
019d			; Moved out to mini and maxi versions  
019d			;  
019d			; include "firmware_key_4x4.asm"  
019d			; using existing 4 wire x 4 resistor array for input  
019d			;include "firmware_key_4x10.asm"  
019d			; need to mod the board for 5 rows due to resistor array  
019d			;include "firmware_key_5x10.asm"  
019d			  
019d			; storage hardware interface  
019d			  
019d			; use microchip serial eeprom for storage  
019d			  
019d			  
019d			if STORAGE_SE  
019d				include "firmware_spi.asm"  
019d				include "firmware_seeprom.asm"  
019d			else  
019d			   ; create some stubs for the labels  
019d c9			se_readbyte: ret  
019e c9			se_writebyte: ret  
019f c9			storage_init: ret  
01a0			  
01a0			endif  
01a0			  
01a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01a0			;include "firmware_cf.asm"  
01a0			  
01a0			; load up high level storage hardward abstractions  
01a0			include "firmware_storage.asm"  
01a0			 
01a0			; persisent storage hardware abstraction layer  
01a0			 
01a0			 
01a0			 
01a0			; Block 0 on storage is a config state 
01a0			 
01a0			 
01a0			 
01a0			; TODO add read phy block and write phy block functions 
01a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01a0			 
01a0			; Abstraction layer  
01a0			 
01a0			; Logocial block size is same size as physical size - using tape concept 
01a0			 
01a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01a0			 
01a0			 
01a0			 
01a0			; Filesystem layout (Logical layout) 
01a0			; 
01a0			; Block 0 - Bank config  
01a0			; 
01a0			;      Byte - 0 file id counter 
01a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01a0			;      Byte - 3-20 zero terminated bank label 
01a0			; 
01a0			; Block 1 > File storage 
01a0			; 
01a0			;      Byte 0 file id    - block 0 file details 
01a0			;      Byte 1 block id - block 0 is file  
01a0			;            Byte 2-15 - File name 
01a0			; 
01a0			;       - to end of block data 
01a0			; 
01a0			 
01a0			; Get ID for the file named in pointer held HL 
01a0			; Returns ID in HL = 255 if no file found 
01a0			 
01a0			storage_getid: 
01a0			 
01a0 22 7d ea			ld (store_tmp1), hl 
01a3			 
01a3				if DEBUG_STORESE 
01a3					DMARK "SGI" 
01a3 f5				push af  
01a4 3a b8 01			ld a, (.dmark)  
01a7 32 71 ee			ld (debug_mark),a  
01aa 3a b9 01			ld a, (.dmark+1)  
01ad 32 72 ee			ld (debug_mark+1),a  
01b0 3a ba 01			ld a, (.dmark+2)  
01b3 32 73 ee			ld (debug_mark+2),a  
01b6 18 03			jr .pastdmark  
01b8 ..			.dmark: db "SGI"  
01bb f1			.pastdmark: pop af  
01bc			endm  
# End of macro DMARK
01bc					CALLMONITOR 
01bc cd ae 15			call break_point_state  
01bf				endm  
# End of macro CALLMONITOR
01bf				endif 
01bf				; get block 0 and set counter for number of files to scan 
01bf			 
01bf cd 2a 03			call storage_get_block_0 
01c2			 
01c2 3a 84 ea			ld a, (store_page) 
01c5 47				ld b, a 
01c6			 
01c6				; get extent 0 of each file id 
01c6			 
01c6				if DEBUG_STORESE 
01c6					DMARK "SGc" 
01c6 f5				push af  
01c7 3a db 01			ld a, (.dmark)  
01ca 32 71 ee			ld (debug_mark),a  
01cd 3a dc 01			ld a, (.dmark+1)  
01d0 32 72 ee			ld (debug_mark+1),a  
01d3 3a dd 01			ld a, (.dmark+2)  
01d6 32 73 ee			ld (debug_mark+2),a  
01d9 18 03			jr .pastdmark  
01db ..			.dmark: db "SGc"  
01de f1			.pastdmark: pop af  
01df			endm  
# End of macro DMARK
01df					CALLMONITOR 
01df cd ae 15			call break_point_state  
01e2				endm  
# End of macro CALLMONITOR
01e2				endif 
01e2 60			.getloop:	ld h, b 
01e3 2e 00				ld l, 0 
01e5 c5					push bc 
01e6			 
01e6 11 84 ea				ld de, store_page 
01e9				if DEBUG_STORESE 
01e9					DMARK "SGr" 
01e9 f5				push af  
01ea 3a fe 01			ld a, (.dmark)  
01ed 32 71 ee			ld (debug_mark),a  
01f0 3a ff 01			ld a, (.dmark+1)  
01f3 32 72 ee			ld (debug_mark+1),a  
01f6 3a 00 02			ld a, (.dmark+2)  
01f9 32 73 ee			ld (debug_mark+2),a  
01fc 18 03			jr .pastdmark  
01fe ..			.dmark: db "SGr"  
0201 f1			.pastdmark: pop af  
0202			endm  
# End of macro DMARK
0202					CALLMONITOR 
0202 cd ae 15			call break_point_state  
0205				endm  
# End of macro CALLMONITOR
0205				endif 
0205 cd d2 07				call storage_read 
0208 cd d6 0d				call ishlzero 
020b 28 2d				jr z, .gap 
020d					 
020d					; have a file name read. Is it one we want. 
020d			 
020d 2a 7d ea				ld hl, (store_tmp1) 
0210 11 87 ea				ld de, store_page+3   ; file name 
0213			 
0213				if DEBUG_STORESE 
0213					DMARK "SGc" 
0213 f5				push af  
0214 3a 28 02			ld a, (.dmark)  
0217 32 71 ee			ld (debug_mark),a  
021a 3a 29 02			ld a, (.dmark+1)  
021d 32 72 ee			ld (debug_mark+1),a  
0220 3a 2a 02			ld a, (.dmark+2)  
0223 32 73 ee			ld (debug_mark+2),a  
0226 18 03			jr .pastdmark  
0228 ..			.dmark: db "SGc"  
022b f1			.pastdmark: pop af  
022c			endm  
# End of macro DMARK
022c					CALLMONITOR 
022c cd ae 15			call break_point_state  
022f				endm  
# End of macro CALLMONITOR
022f				endif 
022f cd 43 12				call strcmp 
0232 20 06				jr nz, .gap   ; not this one 
0234			 
0234 c1				        pop bc 
0235			 
0235 26 00				ld h, 0 
0237 68					ld l, b 
0238 18 22				jr .getdone 
023a						 
023a			 
023a			 
023a			 
023a			.gap: 
023a				if DEBUG_STORESE 
023a					DMARK "SGg" 
023a f5				push af  
023b 3a 4f 02			ld a, (.dmark)  
023e 32 71 ee			ld (debug_mark),a  
0241 3a 50 02			ld a, (.dmark+1)  
0244 32 72 ee			ld (debug_mark+1),a  
0247 3a 51 02			ld a, (.dmark+2)  
024a 32 73 ee			ld (debug_mark+2),a  
024d 18 03			jr .pastdmark  
024f ..			.dmark: db "SGg"  
0252 f1			.pastdmark: pop af  
0253			endm  
# End of macro DMARK
0253					CALLMONITOR 
0253 cd ae 15			call break_point_state  
0256				endm  
# End of macro CALLMONITOR
0256				endif 
0256			 
0256 c1					pop bc 
0257 10 89				djnz .getloop 
0259 21 ff 00				ld hl, 255 
025c			.getdone: 
025c			 
025c				if DEBUG_STORESE 
025c					DMARK "SGe" 
025c f5				push af  
025d 3a 71 02			ld a, (.dmark)  
0260 32 71 ee			ld (debug_mark),a  
0263 3a 72 02			ld a, (.dmark+1)  
0266 32 72 ee			ld (debug_mark+1),a  
0269 3a 73 02			ld a, (.dmark+2)  
026c 32 73 ee			ld (debug_mark+2),a  
026f 18 03			jr .pastdmark  
0271 ..			.dmark: db "SGe"  
0274 f1			.pastdmark: pop af  
0275			endm  
# End of macro DMARK
0275					CALLMONITOR 
0275 cd ae 15			call break_point_state  
0278				endm  
# End of macro CALLMONITOR
0278				endif 
0278			 
0278 c9				ret 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			; Read Block 
0279			; ---------- 
0279			; 
0279			; With current bank 
0279			;  
0279			; Get block number to read 
0279			; Load physical blocks starting at start block into buffer 
0279			 
0279			; de points to buffer to use 
0279			; hl holds logical block number  
0279			 
0279			storage_read_block: 
0279			 
0279				; TODO bank selection 
0279			 
0279				; for each of the physical blocks read it into the buffer 
0279 06 40			ld b, STORE_BLOCK_PHY 
027b			 
027b				if DEBUG_STORESE 
027b d5					push de 
027c				endif 
027c				 
027c			.rl1:    
027c			 
027c				; read physical block at hl into de 
027c			        ; increment hl and de to next read position on exit 
027c			 
027c e5				push hl 
027d d5				push de	 
027e c5				push bc 
027f			;	if DEBUG_STORESE 
027f			;		push af 
027f			;		ld a, 'R' 
027f			;		ld (debug_mark),a 
027f			;		pop af 
027f			;		CALLMONITOR 
027f			;	endif 
027f cd 9d 01			call se_readbyte 
0282			;	if DEBUG_STORESE 
0282			;		ld a,(spi_portbyte) 
0282			;		ld l, a 
0282			;		push af 
0282			;		ld a, '1' 
0282			;		ld (debug_mark),a 
0282			;		pop af 
0282			;		CALLMONITOR 
0282			;	endif 
0282 c1				pop bc 
0283 d1				pop de 
0284 e1				pop hl 
0285 12				ld (de),a 
0286 23				inc hl 
0287 13				inc de 
0288			 
0288			;	if DEBUG_STORESE 
0288			;		push af 
0288			;		ld a, 'r' 
0288			;		ld (debug_mark),a 
0288			;		pop af 
0288			;		CALLMONITOR 
0288			;	endif 
0288			 
0288 10 f2			djnz .rl1 
028a			 
028a				if DEBUG_STORESE 
028a					DMARK "SRB" 
028a f5				push af  
028b 3a 9f 02			ld a, (.dmark)  
028e 32 71 ee			ld (debug_mark),a  
0291 3a a0 02			ld a, (.dmark+1)  
0294 32 72 ee			ld (debug_mark+1),a  
0297 3a a1 02			ld a, (.dmark+2)  
029a 32 73 ee			ld (debug_mark+2),a  
029d 18 03			jr .pastdmark  
029f ..			.dmark: db "SRB"  
02a2 f1			.pastdmark: pop af  
02a3			endm  
# End of macro DMARK
02a3 d1					pop de 
02a4			; 
02a4			;		push af 
02a4			;		ld a, 'R' 
02a4			;		ld (debug_mark),a 
02a4			;		pop af 
02a4					CALLMONITOR 
02a4 cd ae 15			call break_point_state  
02a7				endm  
# End of macro CALLMONITOR
02a7				endif 
02a7 c9				ret	 
02a8				 
02a8			 
02a8			; File Size 
02a8			; --------- 
02a8			; 
02a8			;   hl file id 
02a8			; 
02a8			;  returns in hl the number of blocks 
02a8			 
02a8			storage_file_size: 
02a8 5d				ld e, l 
02a9 16 00			ld d, 0 
02ab 21 40 00			ld hl, STORE_BLOCK_PHY 
02ae					if DEBUG_FORTH_WORDS 
02ae						DMARK "SIZ" 
02ae f5				push af  
02af 3a c3 02			ld a, (.dmark)  
02b2 32 71 ee			ld (debug_mark),a  
02b5 3a c4 02			ld a, (.dmark+1)  
02b8 32 72 ee			ld (debug_mark+1),a  
02bb 3a c5 02			ld a, (.dmark+2)  
02be 32 73 ee			ld (debug_mark+2),a  
02c1 18 03			jr .pastdmark  
02c3 ..			.dmark: db "SIZ"  
02c6 f1			.pastdmark: pop af  
02c7			endm  
# End of macro DMARK
02c7						CALLMONITOR 
02c7 cd ae 15			call break_point_state  
02ca				endm  
# End of macro CALLMONITOR
02ca					endif 
02ca cd ac 05			call storage_findnextid 
02cd			 
02cd cd d6 0d			call ishlzero 
02d0			;	ld a, l 
02d0			;	add h 
02d0			;	cp 0 
02d0 c8				ret z			; block not found so EOF 
02d1			 
02d1 11 84 ea			ld de, store_page 
02d4 cd 79 02			call storage_read_block 
02d7			 
02d7 3a 86 ea			ld a, (store_page+2)	 ; get extent count 
02da 6f				ld l, a 
02db 26 00			ld h, 0 
02dd c9			 	ret 
02de			 
02de			 
02de			; Write Block 
02de			; ----------- 
02de			; 
02de			; With current bank 
02de			;  
02de			; Get block number to write 
02de			; Write physical blocks starting at start block from buffer 
02de			  
02de			storage_write_block: 
02de				; TODO bank selection 
02de			 
02de				; for each of the physical blocks read it into the buffer 
02de 06 40			ld b, STORE_BLOCK_PHY 
02e0			 
02e0				if DEBUG_STORESE 
02e0					DMARK "SWB" 
02e0 f5				push af  
02e1 3a f5 02			ld a, (.dmark)  
02e4 32 71 ee			ld (debug_mark),a  
02e7 3a f6 02			ld a, (.dmark+1)  
02ea 32 72 ee			ld (debug_mark+1),a  
02ed 3a f7 02			ld a, (.dmark+2)  
02f0 32 73 ee			ld (debug_mark+2),a  
02f3 18 03			jr .pastdmark  
02f5 ..			.dmark: db "SWB"  
02f8 f1			.pastdmark: pop af  
02f9			endm  
# End of macro DMARK
02f9			 
02f9					;push af 
02f9					;ld a, 'W' 
02f9					;ld (debug_mark),a 
02f9					;pop af 
02f9					CALLMONITOR 
02f9 cd ae 15			call break_point_state  
02fc				endm  
# End of macro CALLMONITOR
02fc				endif 
02fc			 
02fc			; might not be working 
02fc			;	call se_writepage 
02fc			 
02fc			;	ret 
02fc			; 
02fc			 
02fc			 
02fc			 
02fc			.wl1:    
02fc			 
02fc				; read physical block at hl into de 
02fc			        ; increment hl and de to next read position on exit 
02fc			 
02fc e5				push hl 
02fd d5				push de	 
02fe c5				push bc 
02ff 1a				ld a,(de) 
0300				;if DEBUG_STORESE 
0300			;		push af 
0300			;		ld a, 'W' 
0300			;		ld (debug_mark),a 
0300			;		pop af 
0300			;		CALLMONITOR 
0300			;	endif 
0300 cd 9e 01			call se_writebyte 
0303			;	call delay250ms 
0303 00				nop 
0304 00				nop 
0305 00				nop 
0306			;	if DEBUG_STORESE 
0306			;		push af 
0306			;		ld a, 'w' 
0306			;		ld (debug_mark),a 
0306			;		pop af 
0306			;		CALLMONITOR 
0306			;	endif 
0306 c1				pop bc 
0307 d1				pop de 
0308 e1				pop hl 
0309 23				inc hl 
030a 13				inc de 
030b			 
030b			 
030b 10 ef			djnz .wl1 
030d			 
030d				if DEBUG_STORESE 
030d					DMARK "SW2" 
030d f5				push af  
030e 3a 22 03			ld a, (.dmark)  
0311 32 71 ee			ld (debug_mark),a  
0314 3a 23 03			ld a, (.dmark+1)  
0317 32 72 ee			ld (debug_mark+1),a  
031a 3a 24 03			ld a, (.dmark+2)  
031d 32 73 ee			ld (debug_mark+2),a  
0320 18 03			jr .pastdmark  
0322 ..			.dmark: db "SW2"  
0325 f1			.pastdmark: pop af  
0326			endm  
# End of macro DMARK
0326			 
0326					;push af 
0326					;ld a, 'W' 
0326					;ld (debug_mark),a 
0326					;pop af 
0326					CALLMONITOR 
0326 cd ae 15			call break_point_state  
0329				endm  
# End of macro CALLMONITOR
0329				endif 
0329 c9				ret	 
032a			 
032a			; Init bank 
032a			; --------- 
032a			; 
032a			; With current bank 
032a			; 
032a			; Setup block 0 config 
032a			;     Set 0 file id counter 
032a			;     Set formatted byte pattern 
032a			;     Zero out bank label 
032a			;      
032a			; For every logical block write 0-1 byte as null 
032a			 
032a			storage_get_block_0: 
032a			 
032a				; TODO check presence 
032a			 
032a				; get block 0 config 
032a			 
032a 21 00 00			ld hl, 0 
032d 11 84 ea			ld de, store_page 
0330 cd 79 02			call storage_read_block 
0333			 
0333				if DEBUG_STORESE 
0333					DMARK "SB0" 
0333 f5				push af  
0334 3a 48 03			ld a, (.dmark)  
0337 32 71 ee			ld (debug_mark),a  
033a 3a 49 03			ld a, (.dmark+1)  
033d 32 72 ee			ld (debug_mark+1),a  
0340 3a 4a 03			ld a, (.dmark+2)  
0343 32 73 ee			ld (debug_mark+2),a  
0346 18 03			jr .pastdmark  
0348 ..			.dmark: db "SB0"  
034b f1			.pastdmark: pop af  
034c			endm  
# End of macro DMARK
034c 11 84 ea				ld de, store_page 
034f			;		push af 
034f			;		ld a, 'i' 
034f			;		ld (debug_mark),a 
034f			;		pop af 
034f					CALLMONITOR 
034f cd ae 15			call break_point_state  
0352				endm  
# End of macro CALLMONITOR
0352				endif 
0352			 
0352				; is this area formatted? 
0352			 
0352			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0352 2a 85 ea			ld hl, (store_page+1) 
0355 3e 80			ld a,0x80 
0357 bd				cp l 
0358 20 22			jr nz, .ininotformatted 
035a				; do a double check 
035a 3e 27			ld a, 0x27 
035c bc				cp h 
035d 20 1d			jr nz, .ininotformatted 
035f			 
035f				; formatted then 
035f			 
035f				if DEBUG_STORESE 
035f					DMARK "SB1" 
035f f5				push af  
0360 3a 74 03			ld a, (.dmark)  
0363 32 71 ee			ld (debug_mark),a  
0366 3a 75 03			ld a, (.dmark+1)  
0369 32 72 ee			ld (debug_mark+1),a  
036c 3a 76 03			ld a, (.dmark+2)  
036f 32 73 ee			ld (debug_mark+2),a  
0372 18 03			jr .pastdmark  
0374 ..			.dmark: db "SB1"  
0377 f1			.pastdmark: pop af  
0378			endm  
# End of macro DMARK
0378					;push af 
0378					;ld a, 'I' 
0378					;ld (debug_mark),a 
0378					;pop af 
0378					CALLMONITOR 
0378 cd ae 15			call break_point_state  
037b				endm  
# End of macro CALLMONITOR
037b				endif 
037b c9				ret 
037c			 
037c			.ininotformatted: 
037c				; bank not formatted so poke various bits to make sure 
037c			 
037c				if DEBUG_STORESE 
037c					DMARK "SB2" 
037c f5				push af  
037d 3a 91 03			ld a, (.dmark)  
0380 32 71 ee			ld (debug_mark),a  
0383 3a 92 03			ld a, (.dmark+1)  
0386 32 72 ee			ld (debug_mark+1),a  
0389 3a 93 03			ld a, (.dmark+2)  
038c 32 73 ee			ld (debug_mark+2),a  
038f 18 03			jr .pastdmark  
0391 ..			.dmark: db "SB2"  
0394 f1			.pastdmark: pop af  
0395			endm  
# End of macro DMARK
0395					;push af 
0395					;ld a, 'f' 
0395					;ld (debug_mark),a 
0395					;pop af 
0395					CALLMONITOR 
0395 cd ae 15			call break_point_state  
0398				endm  
# End of macro CALLMONITOR
0398				endif 
0398			 
0398 cd b5 0a			call storage_clear_page 
039b			 
039b 21 84 ea			ld hl, store_page 
039e 3e 00			ld a, 0 
03a0				 
03a0 77				ld (hl),a   ; reset file counter 
03a1			 
03a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a4 22 85 ea		 	ld (store_page+1), hl	 
03a7			 
03a7				; set default label 
03a7			 
03a7 21 43 04			ld hl, .defaultbanklabl 
03aa 11 87 ea		 	ld de, store_page+3 
03ad 01 0f 00			ld bc, 15 
03b0 ed b0			ldir 
03b2			 
03b2				; Append the current bank id 
03b2 21 90 ea			ld hl, store_page+3+9 
03b5 3a 69 ea			ld a, (spi_device_id) 
03b8 77				ld (hl), a 
03b9			 
03b9				; save default page 0 
03b9			 
03b9 21 00 00			ld hl, 0 
03bc 11 84 ea			ld de, store_page 
03bf				if DEBUG_STORESE 
03bf					DMARK "SB3" 
03bf f5				push af  
03c0 3a d4 03			ld a, (.dmark)  
03c3 32 71 ee			ld (debug_mark),a  
03c6 3a d5 03			ld a, (.dmark+1)  
03c9 32 72 ee			ld (debug_mark+1),a  
03cc 3a d6 03			ld a, (.dmark+2)  
03cf 32 73 ee			ld (debug_mark+2),a  
03d2 18 03			jr .pastdmark  
03d4 ..			.dmark: db "SB3"  
03d7 f1			.pastdmark: pop af  
03d8			endm  
# End of macro DMARK
03d8			;		push af 
03d8			;		ld a, 'F' 
03d8			;		ld (debug_mark),a 
03d8			;		pop af 
03d8					CALLMONITOR 
03d8 cd ae 15			call break_point_state  
03db				endm  
# End of macro CALLMONITOR
03db				endif 
03db cd de 02			call storage_write_block 
03de				if DEBUG_STORESE 
03de					DMARK "SB4" 
03de f5				push af  
03df 3a f3 03			ld a, (.dmark)  
03e2 32 71 ee			ld (debug_mark),a  
03e5 3a f4 03			ld a, (.dmark+1)  
03e8 32 72 ee			ld (debug_mark+1),a  
03eb 3a f5 03			ld a, (.dmark+2)  
03ee 32 73 ee			ld (debug_mark+2),a  
03f1 18 03			jr .pastdmark  
03f3 ..			.dmark: db "SB4"  
03f6 f1			.pastdmark: pop af  
03f7			endm  
# End of macro DMARK
03f7			;		push af 
03f7			;		ld a, '>' 
03f7			;		ld (debug_mark),a 
03f7			;		pop af 
03f7					CALLMONITOR 
03f7 cd ae 15			call break_point_state  
03fa				endm  
# End of macro CALLMONITOR
03fa				endif 
03fa			 
03fa 00				nop 
03fb 00				nop 
03fc 00				nop 
03fd			 
03fd				; now set 0 in every page to mark as a free block 
03fd			 
03fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03ff 21 40 00			ld hl, STORE_BLOCK_PHY 
0402			 
0402 3e 00		.setmark1:   	ld a,0 
0404 e5					push hl 
0405 c5					push bc 
0406 cd 9e 01				call se_writebyte 
0409 3e 0a			ld a, 10 
040b cd d7 0a			call aDelayInMS 
040e 23				inc hl 
040f cd 9e 01				call se_writebyte 
0412 3e 0a			ld a, 10 
0414 cd d7 0a			call aDelayInMS 
0417 2b				dec hl 
0418 c1					pop bc 
0419 e1					pop hl 
041a 3e 40				ld a, STORE_BLOCK_PHY 
041c cd ad 0d				call addatohl 
041f 10 e1				djnz .setmark1 
0421			 
0421 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0423 3e 00		.setmark2:   	ld a,0 
0425 e5					push hl 
0426 c5					push bc 
0427 cd 9e 01				call se_writebyte 
042a 3e 0a			ld a, 10 
042c cd d7 0a			call aDelayInMS 
042f 23				inc hl 
0430 cd 9e 01				call se_writebyte 
0433 3e 0a			ld a, 10 
0435 cd d7 0a			call aDelayInMS 
0438 2b				dec hl 
0439 c1					pop bc 
043a e1					pop hl 
043b 3e 40				ld a, STORE_BLOCK_PHY 
043d cd ad 0d				call addatohl 
0440 10 e1				djnz .setmark2 
0442			 
0442					 
0442			 
0442			 
0442 c9				ret 
0443			 
0443			 
0443			 
0443			 
0443 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044e			 
044e			 
044e			 
044e			; Label Bank 
044e			; ---------- 
044e			; 
044e			; With current bank 
044e			; Read block 0 
044e			; Set label 
044e			; Write block 0 
044e			 
044e			; label str pointer in hl 
044e			 
044e			storage_label:     
044e			 
044e				if DEBUG_STORESE 
044e					DMARK "LBL" 
044e f5				push af  
044f 3a 63 04			ld a, (.dmark)  
0452 32 71 ee			ld (debug_mark),a  
0455 3a 64 04			ld a, (.dmark+1)  
0458 32 72 ee			ld (debug_mark+1),a  
045b 3a 65 04			ld a, (.dmark+2)  
045e 32 73 ee			ld (debug_mark+2),a  
0461 18 03			jr .pastdmark  
0463 ..			.dmark: db "LBL"  
0466 f1			.pastdmark: pop af  
0467			endm  
# End of macro DMARK
0467					CALLMONITOR 
0467 cd ae 15			call break_point_state  
046a				endm  
# End of macro CALLMONITOR
046a				endif 
046a			 
046a e5				push hl 
046b			 
046b cd 2a 03			call storage_get_block_0 
046e			 
046e				; set default label 
046e			 
046e e1				pop hl 
046f			 
046f 11 87 ea		 	ld de, store_page+3 
0472 01 0f 00			ld bc, 15 
0475				if DEBUG_STORESE 
0475					DMARK "LB3" 
0475 f5				push af  
0476 3a 8a 04			ld a, (.dmark)  
0479 32 71 ee			ld (debug_mark),a  
047c 3a 8b 04			ld a, (.dmark+1)  
047f 32 72 ee			ld (debug_mark+1),a  
0482 3a 8c 04			ld a, (.dmark+2)  
0485 32 73 ee			ld (debug_mark+2),a  
0488 18 03			jr .pastdmark  
048a ..			.dmark: db "LB3"  
048d f1			.pastdmark: pop af  
048e			endm  
# End of macro DMARK
048e					CALLMONITOR 
048e cd ae 15			call break_point_state  
0491				endm  
# End of macro CALLMONITOR
0491				endif 
0491 ed b0			ldir 
0493				; save default page 0 
0493			 
0493 21 00 00			ld hl, 0 
0496 11 84 ea			ld de, store_page 
0499				if DEBUG_STORESE 
0499					DMARK "LBW" 
0499 f5				push af  
049a 3a ae 04			ld a, (.dmark)  
049d 32 71 ee			ld (debug_mark),a  
04a0 3a af 04			ld a, (.dmark+1)  
04a3 32 72 ee			ld (debug_mark+1),a  
04a6 3a b0 04			ld a, (.dmark+2)  
04a9 32 73 ee			ld (debug_mark+2),a  
04ac 18 03			jr .pastdmark  
04ae ..			.dmark: db "LBW"  
04b1 f1			.pastdmark: pop af  
04b2			endm  
# End of macro DMARK
04b2					CALLMONITOR 
04b2 cd ae 15			call break_point_state  
04b5				endm  
# End of macro CALLMONITOR
04b5				endif 
04b5 cd de 02			call storage_write_block 
04b8			 
04b8 c9				ret 
04b9			 
04b9			 
04b9			 
04b9			; Read Block 0 - Config 
04b9			; --------------------- 
04b9			; 
04b9			; With current bank 
04b9			; Call presence test 
04b9			;    If not present format/init bank  
04b9			; Read block 0  
04b9			;  
04b9			 
04b9			 
04b9			; Dir 
04b9			; --- 
04b9			; 
04b9			; With current bank 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block read byte 2 
04b9			;      if first block of file 
04b9			;         Display file name 
04b9			;         Display type flags for file 
04b9			;        
04b9			 
04b9			; moving to words as this requires stack control 
04b9			 
04b9			 
04b9			; Delete File 
04b9			; ----------- 
04b9			; 
04b9			; With current bank 
04b9			; 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block file id 
04b9			;      If first block of file and dont have file id 
04b9			;         if file to delete 
04b9			;         Save file id 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			;      If file id is one saved 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			 
04b9			 
04b9			.se_done: 
04b9 e1				pop hl 
04ba c9				ret 
04bb			 
04bb			storage_erase: 
04bb			 
04bb				; hl contains the file id 
04bb			 
04bb 5d				ld e, l 
04bc 16 00			ld d, 0 
04be 21 40 00			ld hl, STORE_BLOCK_PHY 
04c1					if DEBUG_FORTH_WORDS 
04c1						DMARK "ERA" 
04c1 f5				push af  
04c2 3a d6 04			ld a, (.dmark)  
04c5 32 71 ee			ld (debug_mark),a  
04c8 3a d7 04			ld a, (.dmark+1)  
04cb 32 72 ee			ld (debug_mark+1),a  
04ce 3a d8 04			ld a, (.dmark+2)  
04d1 32 73 ee			ld (debug_mark+2),a  
04d4 18 03			jr .pastdmark  
04d6 ..			.dmark: db "ERA"  
04d9 f1			.pastdmark: pop af  
04da			endm  
# End of macro DMARK
04da						CALLMONITOR 
04da cd ae 15			call break_point_state  
04dd				endm  
# End of macro CALLMONITOR
04dd					endif 
04dd cd ac 05			call storage_findnextid 
04e0 cd d6 0d			call ishlzero 
04e3 c8				ret z 
04e4			 
04e4 e5				push hl 
04e5			 
04e5				; TODO check file not found 
04e5			 
04e5 11 84 ea			ld de, store_page 
04e8 cd 79 02			call storage_read_block 
04eb			 
04eb cd d6 0d			call ishlzero 
04ee ca b9 04			jp z,.se_done 
04f1			 
04f1					if DEBUG_FORTH_WORDS 
04f1						DMARK "ER1" 
04f1 f5				push af  
04f2 3a 06 05			ld a, (.dmark)  
04f5 32 71 ee			ld (debug_mark),a  
04f8 3a 07 05			ld a, (.dmark+1)  
04fb 32 72 ee			ld (debug_mark+1),a  
04fe 3a 08 05			ld a, (.dmark+2)  
0501 32 73 ee			ld (debug_mark+2),a  
0504 18 03			jr .pastdmark  
0506 ..			.dmark: db "ER1"  
0509 f1			.pastdmark: pop af  
050a			endm  
# End of macro DMARK
050a						CALLMONITOR 
050a cd ae 15			call break_point_state  
050d				endm  
# End of macro CALLMONITOR
050d					endif 
050d 3a 84 ea			ld a, (store_page)	; get file id 
0510 32 78 ea			ld (store_tmpid), a 
0513			 
0513 3a 86 ea			ld a, (store_page+2)    ; get count of extends 
0516 32 77 ea			ld (store_tmpext), a 
0519			 
0519				; wipe file header 
0519			 
0519 e1				pop hl 
051a 3e 00			ld a, 0 
051c 32 84 ea			ld (store_page), a 
051f 32 85 ea			ld (store_page+1),a 
0522 11 84 ea			ld de, store_page 
0525					if DEBUG_FORTH_WORDS 
0525						DMARK "ER2" 
0525 f5				push af  
0526 3a 3a 05			ld a, (.dmark)  
0529 32 71 ee			ld (debug_mark),a  
052c 3a 3b 05			ld a, (.dmark+1)  
052f 32 72 ee			ld (debug_mark+1),a  
0532 3a 3c 05			ld a, (.dmark+2)  
0535 32 73 ee			ld (debug_mark+2),a  
0538 18 03			jr .pastdmark  
053a ..			.dmark: db "ER2"  
053d f1			.pastdmark: pop af  
053e			endm  
# End of macro DMARK
053e						CALLMONITOR 
053e cd ae 15			call break_point_state  
0541				endm  
# End of macro CALLMONITOR
0541					endif 
0541 cd de 02			call storage_write_block 
0544			 
0544			 
0544				; wipe file extents 
0544			 
0544 3a 77 ea			ld a, (store_tmpext) 
0547 47				ld b, a 
0548			 
0548			.eraext:	  
0548 c5				push bc 
0549			 
0549 21 40 00			ld hl, STORE_BLOCK_PHY 
054c 3a 78 ea			ld a,(store_tmpid) 
054f 5f				ld e, a 
0550 50				ld d, b	 
0551					if DEBUG_FORTH_WORDS 
0551						DMARK "ER3" 
0551 f5				push af  
0552 3a 66 05			ld a, (.dmark)  
0555 32 71 ee			ld (debug_mark),a  
0558 3a 67 05			ld a, (.dmark+1)  
055b 32 72 ee			ld (debug_mark+1),a  
055e 3a 68 05			ld a, (.dmark+2)  
0561 32 73 ee			ld (debug_mark+2),a  
0564 18 03			jr .pastdmark  
0566 ..			.dmark: db "ER3"  
0569 f1			.pastdmark: pop af  
056a			endm  
# End of macro DMARK
056a						CALLMONITOR 
056a cd ae 15			call break_point_state  
056d				endm  
# End of macro CALLMONITOR
056d					endif 
056d cd ac 05			call storage_findnextid 
0570 cd d6 0d			call ishlzero 
0573 ca b9 04			jp z,.se_done 
0576			 
0576 e5				push hl 
0577 11 84 ea			ld de, store_page 
057a cd 79 02			call storage_read_block 
057d			 
057d				; free block	 
057d			 
057d 3e 00			ld a, 0 
057f 32 84 ea			ld (store_page), a 
0582 32 85 ea			ld (store_page+1),a 
0585 11 84 ea			ld de, store_page 
0588 e1				pop hl 
0589					if DEBUG_FORTH_WORDS 
0589						DMARK "ER4" 
0589 f5				push af  
058a 3a 9e 05			ld a, (.dmark)  
058d 32 71 ee			ld (debug_mark),a  
0590 3a 9f 05			ld a, (.dmark+1)  
0593 32 72 ee			ld (debug_mark+1),a  
0596 3a a0 05			ld a, (.dmark+2)  
0599 32 73 ee			ld (debug_mark+2),a  
059c 18 03			jr .pastdmark  
059e ..			.dmark: db "ER4"  
05a1 f1			.pastdmark: pop af  
05a2			endm  
# End of macro DMARK
05a2						CALLMONITOR 
05a2 cd ae 15			call break_point_state  
05a5				endm  
# End of macro CALLMONITOR
05a5					endif 
05a5 cd de 02			call storage_write_block 
05a8			 
05a8 c1				pop bc 
05a9 10 9d			djnz .eraext 
05ab			 
05ab c9				ret 
05ac			 
05ac			 
05ac			; Find Free Block 
05ac			; --------------- 
05ac			; 
05ac			; With current bank 
05ac			;  
05ac			; From given starting logical block 
05ac			;    Read block  
05ac			;    If no file id 
05ac			;         Return block id 
05ac			 
05ac			 
05ac			; hl starting page number 
05ac			; hl contains free page number or zero if no pages free 
05ac			; e contains the file id to locate 
05ac			; d contains the block number 
05ac			 
05ac			; TODO change to find file id and use zero for free block 
05ac			 
05ac			storage_findnextid: 
05ac			 
05ac				; now locate first 0 page to mark as a free block 
05ac			 
05ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ae			;	ld hl, STORE_BLOCK_PHY 
05ae			 
05ae					if DEBUG_FORTH_WORDS 
05ae					DMARK "FNI" 
05ae f5				push af  
05af 3a c3 05			ld a, (.dmark)  
05b2 32 71 ee			ld (debug_mark),a  
05b5 3a c4 05			ld a, (.dmark+1)  
05b8 32 72 ee			ld (debug_mark+1),a  
05bb 3a c5 05			ld a, (.dmark+2)  
05be 32 73 ee			ld (debug_mark+2),a  
05c1 18 03			jr .pastdmark  
05c3 ..			.dmark: db "FNI"  
05c6 f1			.pastdmark: pop af  
05c7			endm  
# End of macro DMARK
05c7						CALLMONITOR 
05c7 cd ae 15			call break_point_state  
05ca				endm  
# End of macro CALLMONITOR
05ca					endif 
05ca			.ff1:   	 
05ca e5					push hl 
05cb c5					push bc 
05cc d5					push de 
05cd cd 9d 01				call se_readbyte 
05d0 5f					ld e,a 
05d1 23					inc hl 
05d2 cd 9d 01				call se_readbyte 
05d5 57					ld d, a 
05d6 e1					pop hl 
05d7 e5					push hl 
05d8 cd cb 0d				call cmp16 
05db 28 49				jr z, .fffound 
05dd			 
05dd d1					pop de 
05de c1					pop bc 
05df e1					pop hl 
05e0			 
05e0					; is found? 
05e0					;cp e 
05e0					;ret z 
05e0			 
05e0 3e 40				ld a, STORE_BLOCK_PHY 
05e2 cd ad 0d				call addatohl 
05e5 10 e3				djnz .ff1 
05e7			 
05e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e9			.ff2:   	 
05e9			 
05e9 e5					push hl 
05ea c5					push bc 
05eb d5					push de 
05ec cd 9d 01				call se_readbyte 
05ef 5f					ld e,a 
05f0 23					inc hl 
05f1 cd 9d 01				call se_readbyte 
05f4 57					ld d, a 
05f5			 
05f5 e1					pop hl 
05f6 e5					push hl 
05f7 cd cb 0d				call cmp16 
05fa 28 2a				jr z, .fffound 
05fc			 
05fc d1					pop de 
05fd c1					pop bc 
05fe e1					pop hl 
05ff					; is found? 
05ff					;cp e 
05ff					;ret z 
05ff			 
05ff 3e 40				ld a, STORE_BLOCK_PHY 
0601 cd ad 0d				call addatohl 
0604 10 e3				djnz .ff2 
0606			 
0606			 
0606					if DEBUG_FORTH_WORDS 
0606					DMARK "FN-" 
0606 f5				push af  
0607 3a 1b 06			ld a, (.dmark)  
060a 32 71 ee			ld (debug_mark),a  
060d 3a 1c 06			ld a, (.dmark+1)  
0610 32 72 ee			ld (debug_mark+1),a  
0613 3a 1d 06			ld a, (.dmark+2)  
0616 32 73 ee			ld (debug_mark+2),a  
0619 18 03			jr .pastdmark  
061b ..			.dmark: db "FN-"  
061e f1			.pastdmark: pop af  
061f			endm  
# End of macro DMARK
061f					;	push af 
061f					;	ld a, 'n' 
061f					;	ld (debug_mark),a 
061f					;	pop af 
061f						CALLMONITOR 
061f cd ae 15			call break_point_state  
0622				endm  
# End of macro CALLMONITOR
0622					endif 
0622				; no free marks! 
0622 21 00 00				ld hl, 0 
0625 c9				ret 
0626			.fffound: 
0626				 
0626			 
0626 d1					pop de 
0627 c1					pop bc 
0628 e1					pop hl 
0629					if DEBUG_FORTH_WORDS 
0629					DMARK "FNF" 
0629 f5				push af  
062a 3a 3e 06			ld a, (.dmark)  
062d 32 71 ee			ld (debug_mark),a  
0630 3a 3f 06			ld a, (.dmark+1)  
0633 32 72 ee			ld (debug_mark+1),a  
0636 3a 40 06			ld a, (.dmark+2)  
0639 32 73 ee			ld (debug_mark+2),a  
063c 18 03			jr .pastdmark  
063e ..			.dmark: db "FNF"  
0641 f1			.pastdmark: pop af  
0642			endm  
# End of macro DMARK
0642					;	push af 
0642					;	ld a, 'n' 
0642					;	ld (debug_mark),a 
0642					;	pop af 
0642						CALLMONITOR 
0642 cd ae 15			call break_point_state  
0645				endm  
# End of macro CALLMONITOR
0645					endif 
0645 c9				ret 
0646			 
0646			 
0646			 
0646			; Free Space 
0646			; ---------- 
0646			; 
0646			; With current bank 
0646			; 
0646			; Set block count to zero 
0646			; Starting with first logical block 
0646			;      Find free block  
0646			;      If block id given, increment block count 
0646			; 
0646			;  
0646			 
0646			 
0646			; hl contains count of free blocks 
0646			 
0646			storage_freeblocks: 
0646			 
0646				; now locate first 0 page to mark as a free block 
0646			 
0646 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0648 21 40 00			ld hl, STORE_BLOCK_PHY 
064b 11 00 00			ld de, 0 
064e			 
064e			.fb1:   	 
064e e5					push hl 
064f c5					push bc 
0650 d5					push de 
0651 cd 9d 01				call se_readbyte 
0654 d1					pop de 
0655 c1					pop bc 
0656 e1					pop hl 
0657			 
0657					; is free? 
0657 fe 00				cp 0 
0659 20 01				jr nz, .ff1cont 
065b 13					inc de 
065c			 
065c			.ff1cont: 
065c			 
065c			 
065c 3e 40				ld a, STORE_BLOCK_PHY 
065e cd ad 0d				call addatohl 
0661 10 eb				djnz .fb1 
0663			 
0663 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0665			.fb2:   	 
0665 e5					push hl 
0666 c5					push bc 
0667 d5					push de 
0668 cd 9d 01				call se_readbyte 
066b d1					pop de 
066c c1					pop bc 
066d e1					pop hl 
066e			 
066e					; is free? 
066e fe 00				cp 0 
0670 20 01				jr nz, .ff2cont 
0672 13					inc de 
0673			 
0673			.ff2cont: 
0673			 
0673 3e 40				ld a, STORE_BLOCK_PHY 
0675 cd ad 0d				call addatohl 
0678 10 eb				djnz .fb2 
067a			 
067a eb				ex de, hl 
067b c9				ret 
067c			 
067c			; Get File ID 
067c			; ----------- 
067c			; 
067c			; With current bank 
067c			;  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; For each logical block 
067c			;    Read block file id 
067c			;      If first block of file and dont have file id 
067c			;         if file get id and exit 
067c			 
067c			 
067c			 
067c			 
067c			; Create File 
067c			; ----------- 
067c			; 
067c			; With current bank  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; Increment file id number 
067c			; Save Config 
067c			; Find free block 
067c			; Set buffer with file name and file id 
067c			; Write buffer to free block  
067c			 
067c			 
067c			; hl point to file name 
067c			; hl returns file id 
067c			 
067c			; file format: 
067c			; byte 0 - file id 
067c			; byte 1 - extent number 
067c			; byte 2-> data 
067c			 
067c			; format for extent number 0: 
067c			; 
067c			; byte 0 - file id 
067c			; byte 1 - extent 0 
067c			; byte 2 - extent count 
067c			; byte 3 -> file name and meta data 
067c			 
067c			 
067c			storage_create: 
067c				if DEBUG_STORESE 
067c					DMARK "SCR" 
067c f5				push af  
067d 3a 91 06			ld a, (.dmark)  
0680 32 71 ee			ld (debug_mark),a  
0683 3a 92 06			ld a, (.dmark+1)  
0686 32 72 ee			ld (debug_mark+1),a  
0689 3a 93 06			ld a, (.dmark+2)  
068c 32 73 ee			ld (debug_mark+2),a  
068f 18 03			jr .pastdmark  
0691 ..			.dmark: db "SCR"  
0694 f1			.pastdmark: pop af  
0695			endm  
# End of macro DMARK
0695					CALLMONITOR 
0695 cd ae 15			call break_point_state  
0698				endm  
# End of macro CALLMONITOR
0698				endif 
0698			 
0698 e5				push hl		; save file name pointer 
0699			 
0699 cd 2a 03			call storage_get_block_0 
069c			 
069c 3a 84 ea			ld a,(store_page)	; get current file id 
069f 3c				inc a 
06a0 32 84 ea			ld (store_page),a 
06a3				 
06a3 32 78 ea			ld (store_tmpid),a			; save id 
06a6			 
06a6 21 00 00			ld hl, 0 
06a9 11 84 ea			ld de, store_page 
06ac				if DEBUG_STORESE 
06ac					DMARK "SCw" 
06ac f5				push af  
06ad 3a c1 06			ld a, (.dmark)  
06b0 32 71 ee			ld (debug_mark),a  
06b3 3a c2 06			ld a, (.dmark+1)  
06b6 32 72 ee			ld (debug_mark+1),a  
06b9 3a c3 06			ld a, (.dmark+2)  
06bc 32 73 ee			ld (debug_mark+2),a  
06bf 18 03			jr .pastdmark  
06c1 ..			.dmark: db "SCw"  
06c4 f1			.pastdmark: pop af  
06c5			endm  
# End of macro DMARK
06c5					CALLMONITOR 
06c5 cd ae 15			call break_point_state  
06c8				endm  
# End of macro CALLMONITOR
06c8				endif 
06c8 cd de 02			call storage_write_block	 ; save update 
06cb			 
06cb				if DEBUG_STORESE 
06cb 11 84 ea				ld de, store_page 
06ce					DMARK "SCC" 
06ce f5				push af  
06cf 3a e3 06			ld a, (.dmark)  
06d2 32 71 ee			ld (debug_mark),a  
06d5 3a e4 06			ld a, (.dmark+1)  
06d8 32 72 ee			ld (debug_mark+1),a  
06db 3a e5 06			ld a, (.dmark+2)  
06de 32 73 ee			ld (debug_mark+2),a  
06e1 18 03			jr .pastdmark  
06e3 ..			.dmark: db "SCC"  
06e6 f1			.pastdmark: pop af  
06e7			endm  
# End of macro DMARK
06e7					CALLMONITOR 
06e7 cd ae 15			call break_point_state  
06ea				endm  
# End of macro CALLMONITOR
06ea				endif 
06ea				;  
06ea				 
06ea 21 40 00			ld hl, STORE_BLOCK_PHY 
06ed 11 00 00			ld de, 0 
06f0 cd ac 05			call storage_findnextid 
06f3			 
06f3 22 6f ea			ld (store_tmppageid), hl    ; save page to use  
06f6			 
06f6				; TODO detect 0 = no spare blocks 
06f6			 
06f6				; hl now contains the free page to use for the file header page 
06f6			 
06f6				if DEBUG_STORESE 
06f6				DMARK "SCF" 
06f6 f5				push af  
06f7 3a 0b 07			ld a, (.dmark)  
06fa 32 71 ee			ld (debug_mark),a  
06fd 3a 0c 07			ld a, (.dmark+1)  
0700 32 72 ee			ld (debug_mark+1),a  
0703 3a 0d 07			ld a, (.dmark+2)  
0706 32 73 ee			ld (debug_mark+2),a  
0709 18 03			jr .pastdmark  
070b ..			.dmark: db "SCF"  
070e f1			.pastdmark: pop af  
070f			endm  
# End of macro DMARK
070f					CALLMONITOR 
070f cd ae 15			call break_point_state  
0712				endm  
# End of macro CALLMONITOR
0712				endif 
0712			 
0712 22 6f ea			ld (store_tmppageid), hl 
0715				 
0715 3a 78 ea			ld a,(store_tmpid)    ; get file id 
0718			;	ld a, (store_filecache)			; save to cache 
0718			 
0718 32 84 ea			ld (store_page),a    ; set page id 
071b 3e 00			ld a, 0			 ; extent 0 is file header 
071d 32 85 ea			ld (store_page+1), a   ; set file extent 
0720			 
0720 32 86 ea			ld (store_page+2), a   ; extent count for the file 
0723			 
0723			;	inc hl 		; init block 0 of file 
0723			;	inc hl   		; skip file and extent id 
0723			 ;       ld a, 0 
0723			;	ld (hl),a 
0723			;	ld a, (store_filecache+1)  	; save to cache 
0723			 
0723			;	inc hl    ; file name 
0723				 
0723				 
0723 11 87 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0726				if DEBUG_STORESE 
0726					DMARK "SCc" 
0726 f5				push af  
0727 3a 3b 07			ld a, (.dmark)  
072a 32 71 ee			ld (debug_mark),a  
072d 3a 3c 07			ld a, (.dmark+1)  
0730 32 72 ee			ld (debug_mark+1),a  
0733 3a 3d 07			ld a, (.dmark+2)  
0736 32 73 ee			ld (debug_mark+2),a  
0739 18 03			jr .pastdmark  
073b ..			.dmark: db "SCc"  
073e f1			.pastdmark: pop af  
073f			endm  
# End of macro DMARK
073f					CALLMONITOR 
073f cd ae 15			call break_point_state  
0742				endm  
# End of macro CALLMONITOR
0742				endif 
0742 e1				pop hl    ; get zero term string 
0743 e5				push hl 
0744 3e 00			ld a, 0 
0746 cd 16 12			call strlent 
0749 23				inc hl   ; cover zero term 
074a 06 00			ld b,0 
074c 4d				ld c,l 
074d e1				pop hl 
074e				;ex de, hl 
074e				if DEBUG_STORESE 
074e					DMARK "SCa" 
074e f5				push af  
074f 3a 63 07			ld a, (.dmark)  
0752 32 71 ee			ld (debug_mark),a  
0755 3a 64 07			ld a, (.dmark+1)  
0758 32 72 ee			ld (debug_mark+1),a  
075b 3a 65 07			ld a, (.dmark+2)  
075e 32 73 ee			ld (debug_mark+2),a  
0761 18 03			jr .pastdmark  
0763 ..			.dmark: db "SCa"  
0766 f1			.pastdmark: pop af  
0767			endm  
# End of macro DMARK
0767					;push af 
0767					;ld a, 'a' 
0767					;ld (debug_mark),a 
0767					;pop af 
0767					CALLMONITOR 
0767 cd ae 15			call break_point_state  
076a				endm  
# End of macro CALLMONITOR
076a				endif 
076a ed b0			ldir    ; copy zero term string 
076c				if DEBUG_STORESE 
076c					DMARK "SCA" 
076c f5				push af  
076d 3a 81 07			ld a, (.dmark)  
0770 32 71 ee			ld (debug_mark),a  
0773 3a 82 07			ld a, (.dmark+1)  
0776 32 72 ee			ld (debug_mark+1),a  
0779 3a 83 07			ld a, (.dmark+2)  
077c 32 73 ee			ld (debug_mark+2),a  
077f 18 03			jr .pastdmark  
0781 ..			.dmark: db "SCA"  
0784 f1			.pastdmark: pop af  
0785			endm  
# End of macro DMARK
0785					CALLMONITOR 
0785 cd ae 15			call break_point_state  
0788				endm  
# End of macro CALLMONITOR
0788				endif 
0788			 
0788				; write file header page 
0788			 
0788 2a 6f ea			ld hl,(store_tmppageid) 
078b 11 84 ea			ld de, store_page 
078e				if DEBUG_STORESE 
078e					DMARK "SCb" 
078e f5				push af  
078f 3a a3 07			ld a, (.dmark)  
0792 32 71 ee			ld (debug_mark),a  
0795 3a a4 07			ld a, (.dmark+1)  
0798 32 72 ee			ld (debug_mark+1),a  
079b 3a a5 07			ld a, (.dmark+2)  
079e 32 73 ee			ld (debug_mark+2),a  
07a1 18 03			jr .pastdmark  
07a3 ..			.dmark: db "SCb"  
07a6 f1			.pastdmark: pop af  
07a7			endm  
# End of macro DMARK
07a7					;push af 
07a7					;ld a, 'b' 
07a7					;ld (debug_mark),a 
07a7					;pop af 
07a7					CALLMONITOR 
07a7 cd ae 15			call break_point_state  
07aa				endm  
# End of macro CALLMONITOR
07aa				endif 
07aa cd de 02			call storage_write_block 
07ad			 
07ad 3a 78 ea			ld a, (store_tmpid) 
07b0 6f				ld l, a 
07b1 26 00			ld h,0 
07b3				if DEBUG_STORESE 
07b3					DMARK "SCz" 
07b3 f5				push af  
07b4 3a c8 07			ld a, (.dmark)  
07b7 32 71 ee			ld (debug_mark),a  
07ba 3a c9 07			ld a, (.dmark+1)  
07bd 32 72 ee			ld (debug_mark+1),a  
07c0 3a ca 07			ld a, (.dmark+2)  
07c3 32 73 ee			ld (debug_mark+2),a  
07c6 18 03			jr .pastdmark  
07c8 ..			.dmark: db "SCz"  
07cb f1			.pastdmark: pop af  
07cc			endm  
# End of macro DMARK
07cc					CALLMONITOR 
07cc cd ae 15			call break_point_state  
07cf				endm  
# End of macro CALLMONITOR
07cf				endif 
07cf c9				ret 
07d0				 
07d0			 
07d0			 
07d0			; 
07d0			; Read File 
07d0			; 
07d0			; h - file id to locate 
07d0			; l - extent to locate 
07d0			; de - pointer to string to read into 
07d0			; 
07d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07d0			 
07d0			.sr_fail: 
07d0 d1				pop de 
07d1 c9				ret 
07d2			 
07d2			storage_read: 
07d2			 
07d2			 
07d2 d5				push de 
07d3			 
07d3			; TODO BUG the above push is it popped before the RET Z? 
07d3			 
07d3			; TODO how to handle multiple part blocks 
07d3			 
07d3				; locate file extent to read 
07d3			 
07d3 5c				ld e, h 
07d4 55				ld d, l 
07d5			 
07d5			.srext: 
07d5 22 82 ea			ld (store_readptr), hl     ; save the current extent to load 
07d8 ed 53 80 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07dc			 
07dc 21 40 00			ld hl, STORE_BLOCK_PHY 
07df				if DEBUG_STORESE 
07df					DMARK "sre" 
07df f5				push af  
07e0 3a f4 07			ld a, (.dmark)  
07e3 32 71 ee			ld (debug_mark),a  
07e6 3a f5 07			ld a, (.dmark+1)  
07e9 32 72 ee			ld (debug_mark+1),a  
07ec 3a f6 07			ld a, (.dmark+2)  
07ef 32 73 ee			ld (debug_mark+2),a  
07f2 18 03			jr .pastdmark  
07f4 ..			.dmark: db "sre"  
07f7 f1			.pastdmark: pop af  
07f8			endm  
# End of macro DMARK
07f8					CALLMONITOR 
07f8 cd ae 15			call break_point_state  
07fb				endm  
# End of macro CALLMONITOR
07fb				endif 
07fb cd ac 05			call storage_findnextid 
07fe			 
07fe				if DEBUG_STORESE 
07fe					DMARK "srf" 
07fe f5				push af  
07ff 3a 13 08			ld a, (.dmark)  
0802 32 71 ee			ld (debug_mark),a  
0805 3a 14 08			ld a, (.dmark+1)  
0808 32 72 ee			ld (debug_mark+1),a  
080b 3a 15 08			ld a, (.dmark+2)  
080e 32 73 ee			ld (debug_mark+2),a  
0811 18 03			jr .pastdmark  
0813 ..			.dmark: db "srf"  
0816 f1			.pastdmark: pop af  
0817			endm  
# End of macro DMARK
0817					CALLMONITOR 
0817 cd ae 15			call break_point_state  
081a				endm  
# End of macro CALLMONITOR
081a				endif 
081a cd d6 0d			call ishlzero 
081d			;	ld a, l 
081d			;	add h 
081d			;	cp 0 
081d 28 b1			jr z,.sr_fail			; block not found so EOF 
081f			 
081f				; save current address for use by higher level words etc 
081f			 
081f 22 75 ea			ld (store_openaddr),hl 
0822			 
0822			 
0822				; hl contains page number to load 
0822 d1				pop de   ; get storage 
0823 ed 53 80 ea		ld (store_readbuf), de     ; current buffer to load in to 
0827 d5				push de 
0828				if DEBUG_STORESE 
0828					DMARK "srg" 
0828 f5				push af  
0829 3a 3d 08			ld a, (.dmark)  
082c 32 71 ee			ld (debug_mark),a  
082f 3a 3e 08			ld a, (.dmark+1)  
0832 32 72 ee			ld (debug_mark+1),a  
0835 3a 3f 08			ld a, (.dmark+2)  
0838 32 73 ee			ld (debug_mark+2),a  
083b 18 03			jr .pastdmark  
083d ..			.dmark: db "srg"  
0840 f1			.pastdmark: pop af  
0841			endm  
# End of macro DMARK
0841					CALLMONITOR 
0841 cd ae 15			call break_point_state  
0844				endm  
# End of macro CALLMONITOR
0844				endif 
0844 cd 79 02			call storage_read_block 
0847			 
0847				; if this a continuation read??? 
0847			 
0847 2a 80 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
084a			 
084a 3e 3f			ld a, STORE_BLOCK_PHY-1 
084c cd ad 0d			call addatohl 
084f 7e				ld a,(hl) 
0850 fe 00			cp 0 
0852 28 02			jr z, .markiscont 
0854 3e ff			ld a, 255 
0856			 
0856			.markiscont: 
0856 32 77 ea			ld (store_readcont), a 
0859			 
0859				if DEBUG_STORESE 
0859					DMARK "srC" 
0859 f5				push af  
085a 3a 6e 08			ld a, (.dmark)  
085d 32 71 ee			ld (debug_mark),a  
0860 3a 6f 08			ld a, (.dmark+1)  
0863 32 72 ee			ld (debug_mark+1),a  
0866 3a 70 08			ld a, (.dmark+2)  
0869 32 73 ee			ld (debug_mark+2),a  
086c 18 03			jr .pastdmark  
086e ..			.dmark: db "srC"  
0871 f1			.pastdmark: pop af  
0872			endm  
# End of macro DMARK
0872					CALLMONITOR 
0872 cd ae 15			call break_point_state  
0875				endm  
# End of macro CALLMONITOR
0875				endif 
0875				; only short reads enabled 
0875			 
0875 3a 7f ea			ld a, (store_longread) 
0878 fe 00			cp 0 
087a ca 47 09			jp z, .readdone 
087d			 
087d			; TODO if block has no zeros then need to read next block  
087d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
087d			; check last byte of physical block. 
087d			; if not zero then the next block needs to be loaded 
087d			 
087d			 
087d 2a 80 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0880			 
0880 3e 3f			ld a, STORE_BLOCK_PHY-1 
0882 cd ad 0d			call addatohl 
0885				;dec hl 
0885 7e				ld a,(hl) 
0886				if DEBUG_STORESE 
0886					DMARK "sr?" 
0886 f5				push af  
0887 3a 9b 08			ld a, (.dmark)  
088a 32 71 ee			ld (debug_mark),a  
088d 3a 9c 08			ld a, (.dmark+1)  
0890 32 72 ee			ld (debug_mark+1),a  
0893 3a 9d 08			ld a, (.dmark+2)  
0896 32 73 ee			ld (debug_mark+2),a  
0899 18 03			jr .pastdmark  
089b ..			.dmark: db "sr?"  
089e f1			.pastdmark: pop af  
089f			endm  
# End of macro DMARK
089f					CALLMONITOR 
089f cd ae 15			call break_point_state  
08a2				endm  
# End of macro CALLMONITOR
08a2				endif 
08a2 fe 00			cp 0 
08a4 ca 47 09			jp z, .readdone 
08a7			 
08a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a7			 
08a7 23				inc hl 
08a8			 
08a8 22 80 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08ab			 
08ab ed 5b 82 ea		ld de, (store_readptr)     ; save the current extent to load 
08af			 
08af eb				ex de, hl 
08b0			 
08b0				; next ext 
08b0			 
08b0 23				inc hl 
08b1 22 82 ea			ld  (store_readptr), hl     ; save the current extent to load 
08b4			 
08b4				if DEBUG_STORESE 
08b4					DMARK "sF2" 
08b4 f5				push af  
08b5 3a c9 08			ld a, (.dmark)  
08b8 32 71 ee			ld (debug_mark),a  
08bb 3a ca 08			ld a, (.dmark+1)  
08be 32 72 ee			ld (debug_mark+1),a  
08c1 3a cb 08			ld a, (.dmark+2)  
08c4 32 73 ee			ld (debug_mark+2),a  
08c7 18 03			jr .pastdmark  
08c9 ..			.dmark: db "sF2"  
08cc f1			.pastdmark: pop af  
08cd			endm  
# End of macro DMARK
08cd					CALLMONITOR 
08cd cd ae 15			call break_point_state  
08d0				endm  
# End of macro CALLMONITOR
08d0				endif 
08d0			 
08d0				; get and load block 
08d0			 
08d0 cd ac 05			call storage_findnextid 
08d3			 
08d3				if DEBUG_STORESE 
08d3					DMARK "sf2" 
08d3 f5				push af  
08d4 3a e8 08			ld a, (.dmark)  
08d7 32 71 ee			ld (debug_mark),a  
08da 3a e9 08			ld a, (.dmark+1)  
08dd 32 72 ee			ld (debug_mark+1),a  
08e0 3a ea 08			ld a, (.dmark+2)  
08e3 32 73 ee			ld (debug_mark+2),a  
08e6 18 03			jr .pastdmark  
08e8 ..			.dmark: db "sf2"  
08eb f1			.pastdmark: pop af  
08ec			endm  
# End of macro DMARK
08ec					CALLMONITOR 
08ec cd ae 15			call break_point_state  
08ef				endm  
# End of macro CALLMONITOR
08ef				endif 
08ef cd d6 0d			call ishlzero 
08f2			;	ld a, l 
08f2			;	add h 
08f2			;	cp 0 
08f2 ca d0 07			jp z,.sr_fail			; block not found so EOF 
08f5				 
08f5				; save current address for use by higher level words etc 
08f5			 
08f5 22 75 ea			ld (store_openaddr),hl 
08f8			 
08f8 cd 79 02			call storage_read_block 
08fb			 
08fb				; on a continuation block, we now have the file id and ext in the middle of the block 
08fb				; we need to pull everything back  
08fb			 
08fb ed 5b 80 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
08ff 2a 80 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0902 23				inc hl 
0903 23				inc hl     ; skip id and ext 
0904 01 40 00			ld bc, STORE_BLOCK_PHY 
0907				if DEBUG_STORESE 
0907					DMARK "SR<" 
0907 f5				push af  
0908 3a 1c 09			ld a, (.dmark)  
090b 32 71 ee			ld (debug_mark),a  
090e 3a 1d 09			ld a, (.dmark+1)  
0911 32 72 ee			ld (debug_mark+1),a  
0914 3a 1e 09			ld a, (.dmark+2)  
0917 32 73 ee			ld (debug_mark+2),a  
091a 18 03			jr .pastdmark  
091c ..			.dmark: db "SR<"  
091f f1			.pastdmark: pop af  
0920			endm  
# End of macro DMARK
0920					CALLMONITOR 
0920 cd ae 15			call break_point_state  
0923				endm  
# End of macro CALLMONITOR
0923				endif 
0923 ed b0			ldir     ; copy data 
0925			 
0925				; move the pointer back and pretend we have a full buffer for next recheck 
0925			 
0925 1b				dec de 
0926 1b				dec de 
0927			 
0927			; TODO do pop below now short circuit loop????? 
0927 c1				pop bc     ; get rid of spare de on stack 
0928				if DEBUG_STORESE 
0928					DMARK "SR>" 
0928 f5				push af  
0929 3a 3d 09			ld a, (.dmark)  
092c 32 71 ee			ld (debug_mark),a  
092f 3a 3e 09			ld a, (.dmark+1)  
0932 32 72 ee			ld (debug_mark+1),a  
0935 3a 3f 09			ld a, (.dmark+2)  
0938 32 73 ee			ld (debug_mark+2),a  
093b 18 03			jr .pastdmark  
093d ..			.dmark: db "SR>"  
0940 f1			.pastdmark: pop af  
0941			endm  
# End of macro DMARK
0941					CALLMONITOR 
0941 cd ae 15			call break_point_state  
0944				endm  
# End of macro CALLMONITOR
0944				endif 
0944 c3 d5 07			jp .srext 
0947			 
0947			 
0947			 
0947			 
0947			 
0947			.readdone:		 
0947 e1				pop hl 		 ; return start of data to show as not EOF 
0948 23				inc hl   ; past file id 
0949 23				inc hl   ; past ext 
094a				if DEBUG_STORESE 
094a					DMARK "SRe" 
094a f5				push af  
094b 3a 5f 09			ld a, (.dmark)  
094e 32 71 ee			ld (debug_mark),a  
0951 3a 60 09			ld a, (.dmark+1)  
0954 32 72 ee			ld (debug_mark+1),a  
0957 3a 61 09			ld a, (.dmark+2)  
095a 32 73 ee			ld (debug_mark+2),a  
095d 18 03			jr .pastdmark  
095f ..			.dmark: db "SRe"  
0962 f1			.pastdmark: pop af  
0963			endm  
# End of macro DMARK
0963					CALLMONITOR 
0963 cd ae 15			call break_point_state  
0966				endm  
# End of macro CALLMONITOR
0966				endif 
0966 c9					ret 
0967			 
0967			 
0967			 
0967			; 
0967			; Append File 
0967			; 
0967			; hl - file id to locate 
0967			; de - pointer to (multi block) string to write 
0967			 
0967			.sa_notfound: 
0967 d1				pop de 
0968 c9				ret 
0969			 
0969			 
0969			storage_append: 
0969				; hl -  file id to append to 
0969				; de - string to append 
0969			 
0969 d5				push de 
096a				 
096a				if DEBUG_STORESE 
096a					DMARK "AP1" 
096a f5				push af  
096b 3a 7f 09			ld a, (.dmark)  
096e 32 71 ee			ld (debug_mark),a  
0971 3a 80 09			ld a, (.dmark+1)  
0974 32 72 ee			ld (debug_mark+1),a  
0977 3a 81 09			ld a, (.dmark+2)  
097a 32 73 ee			ld (debug_mark+2),a  
097d 18 03			jr .pastdmark  
097f ..			.dmark: db "AP1"  
0982 f1			.pastdmark: pop af  
0983			endm  
# End of macro DMARK
0983					CALLMONITOR 
0983 cd ae 15			call break_point_state  
0986				endm  
# End of macro CALLMONITOR
0986				endif 
0986			 
0986 7d				ld a, l 
0987 32 78 ea			ld (store_tmpid), a 
098a			 
098a				; get file header  
098a			 
098a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098c 3a 78 ea			ld a, (store_tmpid) 
098f 5f				ld e, a 
0990			 
0990 21 40 00				ld hl, STORE_BLOCK_PHY 
0993 cd ac 05				call storage_findnextid 
0996			 
0996 cd d6 0d			call ishlzero 
0999 28 cc			jr z, .sa_notfound 
099b			 
099b 22 6f ea			ld (store_tmppageid), hl 
099e			 
099e				; TODO handle file id not found 
099e			 
099e				if DEBUG_STORESE 
099e					DMARK "AP2" 
099e f5				push af  
099f 3a b3 09			ld a, (.dmark)  
09a2 32 71 ee			ld (debug_mark),a  
09a5 3a b4 09			ld a, (.dmark+1)  
09a8 32 72 ee			ld (debug_mark+1),a  
09ab 3a b5 09			ld a, (.dmark+2)  
09ae 32 73 ee			ld (debug_mark+2),a  
09b1 18 03			jr .pastdmark  
09b3 ..			.dmark: db "AP2"  
09b6 f1			.pastdmark: pop af  
09b7			endm  
# End of macro DMARK
09b7					CALLMONITOR 
09b7 cd ae 15			call break_point_state  
09ba				endm  
# End of macro CALLMONITOR
09ba				endif 
09ba			 
09ba				; update file extent count 
09ba			 
09ba 11 84 ea			ld de, store_page 
09bd			 
09bd cd 79 02			call storage_read_block 
09c0			 
09c0				if DEBUG_STORESE 
09c0					DMARK "AP3" 
09c0 f5				push af  
09c1 3a d5 09			ld a, (.dmark)  
09c4 32 71 ee			ld (debug_mark),a  
09c7 3a d6 09			ld a, (.dmark+1)  
09ca 32 72 ee			ld (debug_mark+1),a  
09cd 3a d7 09			ld a, (.dmark+2)  
09d0 32 73 ee			ld (debug_mark+2),a  
09d3 18 03			jr .pastdmark  
09d5 ..			.dmark: db "AP3"  
09d8 f1			.pastdmark: pop af  
09d9			endm  
# End of macro DMARK
09d9					CALLMONITOR 
09d9 cd ae 15			call break_point_state  
09dc				endm  
# End of macro CALLMONITOR
09dc				endif 
09dc			;	ld (store_tmppageid), hl 
09dc			 
09dc 3a 86 ea			ld a, (store_page+2) 
09df 3c				inc a 
09e0 32 86 ea			ld (store_page+2), a 
09e3 32 77 ea			ld (store_tmpext), a 
09e6				 
09e6				if DEBUG_STORESE 
09e6					DMARK "AP3" 
09e6 f5				push af  
09e7 3a fb 09			ld a, (.dmark)  
09ea 32 71 ee			ld (debug_mark),a  
09ed 3a fc 09			ld a, (.dmark+1)  
09f0 32 72 ee			ld (debug_mark+1),a  
09f3 3a fd 09			ld a, (.dmark+2)  
09f6 32 73 ee			ld (debug_mark+2),a  
09f9 18 03			jr .pastdmark  
09fb ..			.dmark: db "AP3"  
09fe f1			.pastdmark: pop af  
09ff			endm  
# End of macro DMARK
09ff					CALLMONITOR 
09ff cd ae 15			call break_point_state  
0a02				endm  
# End of macro CALLMONITOR
0a02				endif 
0a02 2a 6f ea			ld hl, (store_tmppageid) 
0a05 11 84 ea			ld de, store_page 
0a08 cd de 02			call storage_write_block 
0a0b			 
0a0b				; find free block 
0a0b			 
0a0b 11 00 00			ld de, 0			 ; file extent to locate 
0a0e			 
0a0e 21 40 00				ld hl, STORE_BLOCK_PHY 
0a11 cd ac 05				call storage_findnextid 
0a14 cd d6 0d			call ishlzero 
0a17 ca 67 09			jp z, .sa_notfound 
0a1a			 
0a1a					; TODO handle no space left 
0a1a					 
0a1a 22 6f ea				ld (store_tmppageid), hl 
0a1d			 
0a1d				if DEBUG_STORESE 
0a1d					DMARK "AP4" 
0a1d f5				push af  
0a1e 3a 32 0a			ld a, (.dmark)  
0a21 32 71 ee			ld (debug_mark),a  
0a24 3a 33 0a			ld a, (.dmark+1)  
0a27 32 72 ee			ld (debug_mark+1),a  
0a2a 3a 34 0a			ld a, (.dmark+2)  
0a2d 32 73 ee			ld (debug_mark+2),a  
0a30 18 03			jr .pastdmark  
0a32 ..			.dmark: db "AP4"  
0a35 f1			.pastdmark: pop af  
0a36			endm  
# End of macro DMARK
0a36					CALLMONITOR 
0a36 cd ae 15			call break_point_state  
0a39				endm  
# End of macro CALLMONITOR
0a39				endif 
0a39					; init the buffer with zeros so we can id if the buffer is full or not 
0a39			 
0a39 e5					push hl 
0a3a c5					push bc 
0a3b			 
0a3b 21 84 ea				ld hl, store_page 
0a3e 06 40				ld b, STORE_BLOCK_PHY 
0a40 3e 00				ld a, 0 
0a42 77			.zeroblock:	ld (hl), a 
0a43 23					inc hl 
0a44 10 fc				djnz .zeroblock 
0a46			 
0a46 c1					pop bc 
0a47 e1					pop hl 
0a48			 
0a48					; construct block 
0a48			 
0a48 3a 78 ea				ld a, (store_tmpid) 
0a4b 32 84 ea				ld (store_page), a   ; file id 
0a4e 3a 77 ea				ld a, (store_tmpext)   ; extent for this block 
0a51 32 85 ea				ld (store_page+1), a 
0a54			 
0a54 e1					pop hl    ; get string to write 
0a55 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a57 11 86 ea				ld de, store_page+2 
0a5a			 
0a5a				if DEBUG_STORESE 
0a5a					DMARK "AP5" 
0a5a f5				push af  
0a5b 3a 6f 0a			ld a, (.dmark)  
0a5e 32 71 ee			ld (debug_mark),a  
0a61 3a 70 0a			ld a, (.dmark+1)  
0a64 32 72 ee			ld (debug_mark+1),a  
0a67 3a 71 0a			ld a, (.dmark+2)  
0a6a 32 73 ee			ld (debug_mark+2),a  
0a6d 18 03			jr .pastdmark  
0a6f ..			.dmark: db "AP5"  
0a72 f1			.pastdmark: pop af  
0a73			endm  
# End of macro DMARK
0a73					CALLMONITOR 
0a73 cd ae 15			call break_point_state  
0a76				endm  
# End of macro CALLMONITOR
0a76				endif 
0a76			 
0a76			 
0a76			 
0a76					; fill buffer with data until end of string or full block 
0a76			 
0a76 7e			.appd:		ld a, (hl) 
0a77 12					ld (de), a 
0a78 fe 00				cp 0 
0a7a 28 04				jr z, .appdone 
0a7c 23					inc hl 
0a7d 13					inc de 
0a7e 10 f6				djnz .appd 
0a80			 
0a80 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a81 f5					push af   		; save last byte dumped 
0a82			 
0a82			 
0a82 2a 6f ea			ld hl, (store_tmppageid) 
0a85 11 84 ea			ld de, store_page 
0a88				if DEBUG_STORESE 
0a88					DMARK "AP6" 
0a88 f5				push af  
0a89 3a 9d 0a			ld a, (.dmark)  
0a8c 32 71 ee			ld (debug_mark),a  
0a8f 3a 9e 0a			ld a, (.dmark+1)  
0a92 32 72 ee			ld (debug_mark+1),a  
0a95 3a 9f 0a			ld a, (.dmark+2)  
0a98 32 73 ee			ld (debug_mark+2),a  
0a9b 18 03			jr .pastdmark  
0a9d ..			.dmark: db "AP6"  
0aa0 f1			.pastdmark: pop af  
0aa1			endm  
# End of macro DMARK
0aa1					CALLMONITOR 
0aa1 cd ae 15			call break_point_state  
0aa4				endm  
# End of macro CALLMONITOR
0aa4				endif 
0aa4 cd de 02				call storage_write_block 
0aa7			 
0aa7			 
0aa7				; was that a full block of data written? 
0aa7				; any more to write out? 
0aa7			 
0aa7				; if yes then set vars and jump to start of function again 
0aa7			 
0aa7 f1					pop af 
0aa8 d1					pop de 
0aa9			 
0aa9 fe 00				cp 0		 ; no, string was fully written 
0aab c8					ret z 
0aac			 
0aac					; setup vars for next cycle 
0aac			 
0aac 3a 78 ea				ld a, (store_tmpid) 
0aaf 6f					ld l, a 
0ab0 26 00				ld h, 0 
0ab2			 
0ab2 c3 69 09			 	jp storage_append	 ; yes, need to write out some more 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			if DEBUG_STORECF 
0ab5			storageput:	 
0ab5					ret 
0ab5			storageread: 
0ab5					ld hl, store_page 
0ab5					ld b, 200 
0ab5					ld a,0 
0ab5			.src:		ld (hl),a 
0ab5					inc hl 
0ab5					djnz .src 
0ab5					 
0ab5			 
0ab5					ld de, 0 
0ab5					ld bc, 1 
0ab5					ld hl, store_page 
0ab5					call cfRead 
0ab5			 
0ab5				call cfGetError 
0ab5				ld hl,scratch 
0ab5				call hexout 
0ab5				ld hl, scratch+2 
0ab5				ld a, 0 
0ab5				ld (hl),a 
0ab5				ld de, scratch 
0ab5				ld a,display_row_1 
0ab5				call str_at_display 
0ab5				call update_display 
0ab5			 
0ab5					ld hl, store_page 
0ab5					ld (os_cur_ptr),hl 
0ab5			 
0ab5					ret 
0ab5			endif 
0ab5			 
0ab5			 
0ab5			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab5			 
0ab5			storage_clear_page: 
0ab5 e5				push hl 
0ab6 d5				push de 
0ab7 c5				push bc 
0ab8 21 84 ea			ld hl, store_page 
0abb 3e 00			ld a, 0 
0abd 77				ld (hl), a 
0abe			 
0abe 11 85 ea			ld de, store_page+1 
0ac1 01 18 01			ld bc, STORE_BLOCK_LOG 
0ac4			 
0ac4 ed b0			ldir 
0ac6				 
0ac6 c1				pop bc 
0ac7 d1				pop de 
0ac8 e1				pop hl 
0ac9 c9				ret 
0aca			 
0aca			; eof 
# End of file firmware_storage.asm
0aca			  
0aca			; support routines for above hardware abstraction layer  
0aca			  
0aca			include "firmware_general.asm"        ; general support functions  
0aca			 
0aca			; word look up 
0aca			 
0aca			; in 
0aca			; a is the index 
0aca			; hl is pointer start of array 
0aca			; 
0aca			; returns 
0aca			; hl to the word 
0aca			; 
0aca			 
0aca			table_lookup:  
0aca d5					push de 
0acb eb					ex de, hl 
0acc			 
0acc 6f					ld l, a 
0acd 26 00				ld h, 0 
0acf 29					add hl, hl 
0ad0 19					add hl, de 
0ad1 7e					ld a, (hl) 
0ad2 23					inc hl 
0ad3 66					ld h,(hl) 
0ad4 6f					ld l, a 
0ad5			 
0ad5 d1					pop de 
0ad6 c9					ret 
0ad7			 
0ad7			; Delay loops 
0ad7			 
0ad7			 
0ad7			 
0ad7			aDelayInMS: 
0ad7 c5				push bc 
0ad8 47				ld b,a 
0ad9			msdelay: 
0ad9 c5				push bc 
0ada				 
0ada			 
0ada 01 41 00			ld bc,041h 
0add cd f5 0a			call delayloop 
0ae0 c1				pop bc 
0ae1 05				dec b 
0ae2 20 f5			jr nz,msdelay 
0ae4			 
0ae4			;if CPU_CLOCK_8MHZ 
0ae4			;msdelay8: 
0ae4			;	push bc 
0ae4			;	 
0ae4			; 
0ae4			;	ld bc,041h 
0ae4			;	call delayloop 
0ae4			;	pop bc 
0ae4			;	dec b 
0ae4			;	jr nz,msdelay8 
0ae4			;endif 
0ae4			 
0ae4			 
0ae4 c1				pop bc 
0ae5 c9				ret 
0ae6			 
0ae6			 
0ae6			delay250ms: 
0ae6				;push de 
0ae6 01 00 40			ld bc, 04000h 
0ae9 c3 f5 0a			jp delayloop 
0aec			delay500ms: 
0aec				;push de 
0aec 01 00 80			ld bc, 08000h 
0aef c3 f5 0a			jp delayloop 
0af2			delay1s: 
0af2				;push bc 
0af2			   ; Clobbers A, d and e 
0af2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af5			delayloop: 
0af5 c5			    push bc 
0af6			 
0af6			if BASE_CPM 
0af6 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af9			.cpmloop: 
0af9 c5				push bc 
0afa			 
0afa			endif 
0afa			 
0afa			 
0afa			 
0afa			delayloopi: 
0afa			;	push bc 
0afa			;.dl: 
0afa cb 47		    bit     0,a    	; 8 
0afc cb 47		    bit     0,a    	; 8 
0afe cb 47		    bit     0,a    	; 8 
0b00 e6 ff		    and     255  	; 7 
0b02 0b			    dec     bc      	; 6 
0b03 79			    ld      a,c     	; 4 
0b04 b0			    or      b     	; 4 
0b05 c2 fa 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b08			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b08				;pop de 
0b08			;pop bc 
0b08			 
0b08			if BASE_CPM 
0b08 c1				pop bc 
0b09				 
0b09 0b			    dec     bc      	; 6 
0b0a 79			    ld      a,c     	; 4 
0b0b b0			    or      b     	; 4 
0b0c c2 f9 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0f				 
0b0f			 
0b0f			endif 
0b0f			;if CPU_CLOCK_8MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f			 
0b0f			;if CPU_CLOCK_10MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f c1			    pop bc 
0b10			 
0b10 c9				ret 
0b11			 
0b11			 
0b11			 
0b11			; eof 
# End of file firmware_general.asm
0b11			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b11			; display routines that use the physical hardware abstraction layer 
0b11			 
0b11			 
0b11			; information window 
0b11			 
0b11			; pass hl with 1st string to display 
0b11			; pass de with 2nd string to display 
0b11			 
0b11			info_panel: 
0b11 e5				push hl 
0b12			 
0b12 2a d2 eb			ld hl, (display_fb_active) 
0b15 e5				push hl    ; future de destination 
0b16 21 b7 ed				ld hl, display_fb0 
0b19 22 d2 eb				ld (display_fb_active), hl 
0b1c			 
0b1c			;	call clear_display 
0b1c			 
0b1c				if BASE_CPM 
0b1c 3e 2e			ld a, '.' 
0b1e				else 
0b1e				ld a, 165 
0b1e				endif 
0b1e cd 85 0b			call fill_display 
0b21			 
0b21			 
0b21 3e 55			ld a, display_row_3 + 5 
0b23 cd 93 0b			call str_at_display 
0b26			 
0b26 e1				pop hl 
0b27 d1				pop de 
0b28			 
0b28 e5				push hl 
0b29			 
0b29			 
0b29 3e 2d			ld a, display_row_2 + 5 
0b2b cd 93 0b			call str_at_display 
0b2e			 
0b2e			 
0b2e cd a3 0b			call update_display 
0b31 cd 97 1b			call next_page_prompt 
0b34 cd 80 0b			call clear_display 
0b37			 
0b37				 
0b37 21 16 ed				ld hl, display_fb1 
0b3a 22 d2 eb				ld (display_fb_active), hl 
0b3d cd a3 0b			call update_display 
0b40			 
0b40 e1				pop hl 
0b41			 
0b41 c9				ret 
0b42			 
0b42			 
0b42			 
0b42			 
0b42			; TODO windowing? 
0b42			 
0b42			; TODO scroll line up 
0b42			 
0b42			scroll_up: 
0b42			 
0b42 e5				push hl 
0b43 d5				push de 
0b44 c5				push bc 
0b45			 
0b45				; get frame buffer  
0b45			 
0b45 2a d2 eb			ld hl, (display_fb_active) 
0b48 e5				push hl    ; future de destination 
0b49			 
0b49 11 28 00			ld  de, display_cols 
0b4c 19				add hl, de 
0b4d			 
0b4d d1				pop de 
0b4e			 
0b4e				;ex de, hl 
0b4e 01 9f 00			ld bc, display_fb_len -1  
0b51			;if DEBUG_FORTH_WORDS 
0b51			;	DMARK "SCL" 
0b51			;	CALLMONITOR 
0b51			;endif	 
0b51 ed b0			ldir 
0b53			 
0b53				; wipe bottom row 
0b53			 
0b53			 
0b53 2a d2 eb			ld hl, (display_fb_active) 
0b56 11 a0 00			ld de, display_cols*display_rows 
0b59 19				add hl, de 
0b5a 06 28			ld b, display_cols 
0b5c 3e 20			ld a, ' ' 
0b5e			.scwipe: 
0b5e 77				ld (hl), a 
0b5f 2b				dec hl 
0b60 10 fc			djnz .scwipe 
0b62			 
0b62				;pop hl 
0b62			 
0b62 c1				pop bc 
0b63 d1				pop de 
0b64 e1				pop hl 
0b65			 
0b65 c9				ret 
0b66			 
0b66			 
0b66			;scroll_upo: 
0b66			;	ld de, display_row_1 
0b66			 ;	ld hl, display_row_2 
0b66			;	ld bc, display_cols 
0b66			;	ldir 
0b66			;	ld de, display_row_2 
0b66			 ;	ld hl, display_row_3 
0b66			;	ld bc, display_cols 
0b66			;	ldir 
0b66			;	ld de, display_row_3 
0b66			 ;	ld hl, display_row_4 
0b66			;	ld bc, display_cols 
0b66			;	ldir 
0b66			 
0b66			; TODO clear row 4 
0b66			 
0b66			;	ret 
0b66			 
0b66				 
0b66			scroll_down: 
0b66			 
0b66 e5				push hl 
0b67 d5				push de 
0b68 c5				push bc 
0b69			 
0b69				; get frame buffer  
0b69			 
0b69 2a d2 eb			ld hl, (display_fb_active) 
0b6c			 
0b6c 11 9f 00			ld de, display_fb_len - 1 
0b6f 19				add hl, de 
0b70			 
0b70 e5			push hl    ; future de destination 
0b71			 
0b71 11 28 00			ld  de, display_cols 
0b74 ed 52			sbc hl, de 
0b76			 
0b76			 
0b76 d1				pop de 
0b77			 
0b77			;	ex de, hl 
0b77 01 9f 00			ld bc, display_fb_len -1  
0b7a			 
0b7a			 
0b7a				 
0b7a			 
0b7a ed b0			ldir 
0b7c			 
0b7c				; wipe bottom row 
0b7c			 
0b7c			 
0b7c			;	ld hl, (display_fb_active) 
0b7c			;;	ld de, display_cols*display_rows 
0b7c			;;	add hl, de 
0b7c			;	ld b, display_cols 
0b7c			;	ld a, ' ' 
0b7c			;.scwiped: 
0b7c			;	ld (hl), a 
0b7c			;	dec hl 
0b7c			;	djnz .scwiped 
0b7c			 
0b7c				;pop hl 
0b7c			 
0b7c c1				pop bc 
0b7d d1				pop de 
0b7e e1				pop hl 
0b7f			 
0b7f c9				ret 
0b80			;scroll_down: 
0b80			;	ld de, display_row_4 
0b80			;	ld hl, display_row_3 
0b80			;	ld bc, display_cols 
0b80			;	ldir 
0b80			;	ld de, display_row_3 
0b80			; 	ld hl, display_row_2 
0b80			;	ld bc, display_cols 
0b80			;	ldir 
0b80			;	ld de, display_row_2 
0b80			;	ld hl, display_row_1 
0b80			;	ld bc, display_cols 
0b80			;	ldir 
0b80			;;; TODO clear row 1 
0b80			;	ret 
0b80			 
0b80			 
0b80			 
0b80			 
0b80			 
0b80			; clear active frame buffer 
0b80			 
0b80			clear_display: 
0b80 3e 20			ld a, ' ' 
0b82 c3 85 0b			jp fill_display 
0b85			 
0b85			; fill active frame buffer with a char in A 
0b85			 
0b85			fill_display: 
0b85 06 a0			ld b,display_fb_len 
0b87 2a d2 eb			ld hl, (display_fb_active) 
0b8a 77			.fd1:	ld (hl),a 
0b8b 23				inc hl 
0b8c 10 fc			djnz .fd1 
0b8e 23				inc hl 
0b8f 3e 00			ld a,0 
0b91 77				ld (hl),a 
0b92			 
0b92			 
0b92 c9				ret 
0b93			; Write string (DE) at pos (A) to active frame buffer 
0b93			 
0b93 2a d2 eb		str_at_display:    ld hl,(display_fb_active) 
0b96 06 00					ld b,0 
0b98 4f					ld c,a 
0b99 09					add hl,bc 
0b9a 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0b9b b7			            OR   A              ;Null terminator? 
0b9c c8			            RET  Z              ;Yes, so finished 
0b9d 77					ld (hl),a 
0b9e 23				inc hl 
0b9f 13			            INC  DE             ;Point to next character 
0ba0 18 f8		            JR   .sad1     ;Repeat 
0ba2 c9					ret 
0ba3			 
0ba3			; using current frame buffer write to physical display 
0ba3			 
0ba3			update_display: 
0ba3 e5				push hl 
0ba4 2a d2 eb			ld hl, (display_fb_active) 
0ba7 cd eb 60			call write_display 
0baa e1				pop hl 
0bab c9				ret 
0bac			 
0bac			; TODO scrolling 
0bac			 
0bac			 
0bac			; move cursor right one char 
0bac			cursor_right: 
0bac			 
0bac				; TODO shift right 
0bac				; TODO if beyond max col 
0bac				; TODO       cursor_next_line 
0bac			 
0bac c9				ret 
0bad			 
0bad			 
0bad			cursor_next_line: 
0bad				; TODO first char 
0bad				; TODO line down 
0bad				; TODO if past last row 
0bad				; TODO    scroll up 
0bad			 
0bad c9				ret 
0bae			 
0bae			cursor_left: 
0bae				; TODO shift left 
0bae				; TODO if beyond left  
0bae				; TODO     cursor prev line 
0bae				 
0bae c9				ret 
0baf			 
0baf			cursor_prev_line: 
0baf				; TODO last char 
0baf				; TODO line up 
0baf				; TODO if past first row 
0baf				; TODO   scroll down 
0baf			 
0baf c9				ret 
0bb0			 
0bb0			 
0bb0			cout: 
0bb0				; A - char 
0bb0 c9				ret 
0bb1			 
0bb1			 
0bb1			; Display a menu and allow item selection (optional toggle items) 
0bb1			; 
0bb1			; format: 
0bb1			; hl pointer to word array with zero term for items 
0bb1			; e.g.    db item1 
0bb1			;         db .... 
0bb1			;         db 0 
0bb1			; 
0bb1			; a = starting menu item  
0bb1			; 
0bb1			; de = pointer item toggle array   (todo) 
0bb1			; 
0bb1			; returns item selected in a 1-... 
0bb1			; returns 0 if back button pressed 
0bb1			; 
0bb1			; NOTE: Uses system frame buffer to display 
0bb1			; 
0bb1			; LEFT, Q = go back 
0bb1			; RIGHT, SPACE, CR = select 
0bb1			; UP, A - Up 
0bb1			; DOWN, Z - Down 
0bb1			 
0bb1			 
0bb1			 
0bb1			 
0bb1			 
0bb1			menu: 
0bb1			 
0bb1					; keep array pointer 
0bb1			 
0bb1 22 7d ea				ld (store_tmp1), hl 
0bb4 32 7b ea				ld (store_tmp2), a 
0bb7			 
0bb7					; check for key bounce 
0bb7			 
0bb7			if BASE_KEV 
0bb7			 
0bb7			.mbounce:	call cin 
0bb7					cp 0 
0bb7					jr nz, .mbounce 
0bb7			endif 
0bb7					; for ease use ex 
0bb7			 
0bb7					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bb7 21 b7 ed				ld hl, display_fb0 
0bba 22 d2 eb				ld (display_fb_active), hl 
0bbd			 
0bbd cd 80 0b		.mloop:		call clear_display 
0bc0 cd a3 0b				call update_display 
0bc3			 
0bc3					; draw selection id '>' at 1 
0bc3			 
0bc3					; init start of list display 
0bc3			 
0bc3 3e 05				ld a, 5 
0bc5 32 79 ea				ld (store_tmp3), a   ; display row count 
0bc8 3a 7b ea				ld a,( store_tmp2) 
0bcb 32 7c ea				ld (store_tmp2+1), a   ; display item count 
0bce			 
0bce					 
0bce			.mitem:	 
0bce			 
0bce			 
0bce 3a 7c ea				ld a,(store_tmp2+1) 
0bd1 6f					ld l, a 
0bd2 26 00				ld h, 0 
0bd4 29					add hl, hl 
0bd5 ed 5b 7d ea			ld de, (store_tmp1) 
0bd9 19					add hl, de 
0bda 7e					ld a, (hl) 
0bdb 23					inc hl 
0bdc 66					ld h,(hl) 
0bdd 6f					ld l, a 
0bde			 
0bde cd d6 0d				call ishlzero 
0be1 28 1a				jr z, .mdone 
0be3			 
0be3 eb					ex de, hl 
0be4 3a 79 ea				ld a, (store_tmp3) 
0be7 cd 93 0b				call str_at_display 
0bea					 
0bea			 
0bea					; next item 
0bea 3a 7c ea				ld a, (store_tmp2+1) 
0bed 3c					inc a 
0bee 32 7c ea				ld (store_tmp2+1), a   ; display item count 
0bf1			 
0bf1			 		; next row 
0bf1			 
0bf1 3a 79 ea				ld a, (store_tmp3) 
0bf4 c6 28				add display_cols 
0bf6 32 79 ea				ld (store_tmp3), a 
0bf9			 
0bf9					; at end of screen? 
0bf9			 
0bf9 fe 10				cp display_rows*4 
0bfb 20 d1				jr nz, .mitem 
0bfd			 
0bfd			 
0bfd			.mdone: 
0bfd cd d6 0d				call ishlzero 
0c00 28 08				jr z, .nodn 
0c02			 
0c02 3e 78				ld a, display_row_4 
0c04 11 83 0c				ld de, .mdown 
0c07 cd 93 0b				call str_at_display 
0c0a			 
0c0a					; draw options to fill the screens with active item on line 1 
0c0a					; if current option is 2 or more then display ^ in top 
0c0a			 
0c0a 3a 7b ea		.nodn:		ld a, (store_tmp2) 
0c0d fe 00				cp 0 
0c0f 28 08				jr z, .noup 
0c11			 
0c11 3e 00				ld a, 0 
0c13 11 81 0c				ld de, .mup 
0c16 cd 93 0b				call str_at_display 
0c19			 
0c19 3e 02		.noup:		ld a, 2 
0c1b 11 7f 0c				ld de, .msel 
0c1e cd 93 0b				call str_at_display 
0c21			 
0c21					; if current option + 1 is not null then display V in bottom 
0c21					; get key 
0c21 cd a3 0b				call update_display 
0c24			 
0c24			 
0c24					; handle key 
0c24			 
0c24 cd 9d 61				call cin_wait 
0c27			 
0c27 fe 05				cp KEY_UP 
0c29 28 2b				jr z, .mgoup 
0c2b fe 61				cp 'a' 
0c2d 28 27				jr z, .mgoup 
0c2f fe 0a				cp KEY_DOWN 
0c31 28 32				jr z, .mgod 
0c33 fe 7a				cp 'z' 
0c35 28 2e				jr z, .mgod 
0c37 fe 20				cp ' ' 
0c39 28 34				jr z, .goend 
0c3b fe 0c				cp KEY_RIGHT 
0c3d 28 30				jr z, .goend 
0c3f fe 0d				cp KEY_CR 
0c41 28 2c				jr z, .goend 
0c43 fe 71				cp 'q' 
0c45 28 0b				jr z, .goback 
0c47			 
0c47 fe 0b				cp KEY_LEFT 
0c49 28 07				jr z, .goback 
0c4b fe 08				cp KEY_BS 
0c4d 28 03				jr z, .goback 
0c4f c3 bd 0b				jp .mloop 
0c52			 
0c52			.goback: 
0c52 3e 00			ld a, 0 
0c54 18 1d			jr .goend2 
0c56			 
0c56				; move up one 
0c56			.mgoup: 
0c56 3a 7b ea				ld a, (store_tmp2) 
0c59 fe 00				cp 0 
0c5b ca bd 0b				jp z, .mloop 
0c5e 3d					dec a 
0c5f 32 7b ea				ld (store_tmp2), a 
0c62 c3 bd 0b				jp .mloop 
0c65			 
0c65				; move down one 
0c65			.mgod: 
0c65 3a 7b ea				ld a, (store_tmp2) 
0c68 3c					inc a 
0c69 32 7b ea				ld (store_tmp2), a 
0c6c c3 bd 0b				jp .mloop 
0c6f			 
0c6f			 
0c6f			.goend: 
0c6f					; get selected item number 
0c6f			 
0c6f 3a 7b ea				ld a, (store_tmp2) 
0c72 3c					inc a 
0c73			 
0c73			.goend2: 
0c73 f5					push af 
0c74			 
0c74					; restore active fb 
0c74					; TODO BUG assumes fb1 
0c74			 
0c74 21 16 ed				ld hl, display_fb1 
0c77 22 d2 eb				ld (display_fb_active), hl 
0c7a			 
0c7a					; restore main regs 
0c7a			 
0c7a			 
0c7a cd a3 0b				call update_display 
0c7d			 
0c7d f1					pop af 
0c7e			 
0c7e c9				ret 
0c7f			 
0c7f .. 00		.msel:   db ">",0 
0c81 .. 00		.mup:   db "^",0 
0c83 .. 00		.mdown:   db "v",0 
0c85			 
0c85			 
0c85			; eof 
0c85			 
# End of file firmware_display.asm
0c85			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0c85			; random number generators 
0c85			 
0c85			 
0c85			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0c85			 
0c85			 
0c85			;-----> Generate a random number 
0c85			; output a=answer 0<=a<=255 
0c85			; all registers are preserved except: af 
0c85			random: 
0c85 e5			        push    hl 
0c86 d5			        push    de 
0c87 2a b4 eb		        ld      hl,(randData) 
0c8a ed 5f		        ld      a,r 
0c8c 57			        ld      d,a 
0c8d 5e			        ld      e,(hl) 
0c8e 19			        add     hl,de 
0c8f 85			        add     a,l 
0c90 ac			        xor     h 
0c91 22 b4 eb		        ld      (randData),hl 
0c94 d1			        pop     de 
0c95 e1			        pop     hl 
0c96 c9			        ret 
0c97			 
0c97			 
0c97			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0c97			 
0c97			 
0c97			 
0c97			;------LFSR------ 
0c97			;James Montelongo 
0c97			;optimized by Spencer Putt 
0c97			;out: 
0c97			; a = 8 bit random number 
0c97			RandLFSR: 
0c97 21 ba eb		        ld hl,LFSRSeed+4 
0c9a 5e			        ld e,(hl) 
0c9b 23			        inc hl 
0c9c 56			        ld d,(hl) 
0c9d 23			        inc hl 
0c9e 4e			        ld c,(hl) 
0c9f 23			        inc hl 
0ca0 7e			        ld a,(hl) 
0ca1 47			        ld b,a 
0ca2 cb 13		        rl e  
0ca4 cb 12			rl d 
0ca6 cb 11		        rl c  
0ca8 17				rla 
0ca9 cb 13		        rl e  
0cab cb 12			rl d 
0cad cb 11		        rl c  
0caf 17				rla 
0cb0 cb 13		        rl e  
0cb2 cb 12			rl d 
0cb4 cb 11		        rl c  
0cb6 17				rla 
0cb7 67			        ld h,a 
0cb8 cb 13		        rl e  
0cba cb 12			rl d 
0cbc cb 11		        rl c  
0cbe 17				rla 
0cbf a8			        xor b 
0cc0 cb 13		        rl e  
0cc2 cb 12			rl d 
0cc4 ac			        xor h 
0cc5 a9			        xor c 
0cc6 aa			        xor d 
0cc7 21 bc eb		        ld hl,LFSRSeed+6 
0cca 11 bd eb		        ld de,LFSRSeed+7 
0ccd 01 07 00		        ld bc,7 
0cd0 ed b8		        lddr 
0cd2 12			        ld (de),a 
0cd3 c9			        ret 
0cd4			 
0cd4			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0cd4			 
0cd4			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0cd4			 
0cd4			 
0cd4			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0cd4			 
0cd4			prng16: 
0cd4			;Inputs: 
0cd4			;   (seed1) contains a 16-bit seed value 
0cd4			;   (seed2) contains a NON-ZERO 16-bit seed value 
0cd4			;Outputs: 
0cd4			;   HL is the result 
0cd4			;   BC is the result of the LCG, so not that great of quality 
0cd4			;   DE is preserved 
0cd4			;Destroys: 
0cd4			;   AF 
0cd4			;cycle: 4,294,901,760 (almost 4.3 billion) 
0cd4			;160cc 
0cd4			;26 bytes 
0cd4 2a ae eb		    ld hl,(seed1) 
0cd7 44			    ld b,h 
0cd8 4d			    ld c,l 
0cd9 29			    add hl,hl 
0cda 29			    add hl,hl 
0cdb 2c			    inc l 
0cdc 09			    add hl,bc 
0cdd 22 ae eb		    ld (seed1),hl 
0ce0 2a ac eb		    ld hl,(seed2) 
0ce3 29			    add hl,hl 
0ce4 9f			    sbc a,a 
0ce5 e6 2d		    and %00101101 
0ce7 ad			    xor l 
0ce8 6f			    ld l,a 
0ce9 22 ac eb		    ld (seed2),hl 
0cec 09			    add hl,bc 
0ced c9			    ret 
0cee			 
0cee			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0cee			 
0cee			rand32: 
0cee			;Inputs: 
0cee			;   (seed1_0) holds the lower 16 bits of the first seed 
0cee			;   (seed1_1) holds the upper 16 bits of the first seed 
0cee			;   (seed2_0) holds the lower 16 bits of the second seed 
0cee			;   (seed2_1) holds the upper 16 bits of the second seed 
0cee			;   **NOTE: seed2 must be non-zero 
0cee			;Outputs: 
0cee			;   HL is the result 
0cee			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0cee			;Destroys: 
0cee			;   AF 
0cee			;Tested and passes all CAcert tests 
0cee			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0cee			;it has a period of 18,446,744,069,414,584,320 
0cee			;roughly 18.4 quintillion. 
0cee			;LFSR taps: 0,2,6,7  = 11000101 
0cee			;291cc 
0cee			;seed1_0=$+1 
0cee			;    ld hl,12345 
0cee			;seed1_1=$+1 
0cee			;    ld de,6789 
0cee			;    ld b,h 
0cee			;    ld c,l 
0cee			;    add hl,hl \ rl e \ rl d 
0cee			;    add hl,hl \ rl e \ rl d 
0cee			;    inc l 
0cee			;    add hl,bc 
0cee			;    ld (seed1_0),hl 
0cee			;    ld hl,(seed1_1) 
0cee			;    adc hl,de 
0cee			;    ld (seed1_1),hl 
0cee			;    ex de,hl 
0cee			;seed2_0=$+1 
0cee			;    ld hl,9876 
0cee			;seed2_1=$+1 
0cee			;    ld bc,54321 
0cee			;    add hl,hl \ rl c \ rl b 
0cee			;    ld (seed2_1),bc 
0cee			;    sbc a,a 
0cee			;    and %11000101 
0cee			;    xor l 
0cee			;    ld l,a 
0cee			;    ld (seed2_0),hl 
0cee			;    ex de,hl 
0cee			;    add hl,bc 
0cee			;    ret 
0cee			; 
0cee			 
0cee			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0cee			; 20 bytes, 86 cycles (excluding ret) 
0cee			 
0cee			; returns   hl = pseudorandom number 
0cee			; corrupts   a 
0cee			 
0cee			; generates 16-bit pseudorandom numbers with a period of 65535 
0cee			; using the xorshift method: 
0cee			 
0cee			; hl ^= hl << 7 
0cee			; hl ^= hl >> 9 
0cee			; hl ^= hl << 8 
0cee			 
0cee			; some alternative shift triplets which also perform well are: 
0cee			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0cee			 
0cee			;  org 32768 
0cee			 
0cee			xrnd: 
0cee 2a b2 eb		  ld hl,(xrandc)       ; seed must not be 0 
0cf1 3e 00		  ld a,0 
0cf3 bd			  cp l 
0cf4 20 02		  jr nz, .xrnd1 
0cf6 2e 01		  ld l, 1 
0cf8			.xrnd1: 
0cf8			 
0cf8 7c			  ld a,h 
0cf9 1f			  rra 
0cfa 7d			  ld a,l 
0cfb 1f			  rra 
0cfc ac			  xor h 
0cfd 67			  ld h,a 
0cfe 7d			  ld a,l 
0cff 1f			  rra 
0d00 7c			  ld a,h 
0d01 1f			  rra 
0d02 ad			  xor l 
0d03 6f			  ld l,a 
0d04 ac			  xor h 
0d05 67			  ld h,a 
0d06			 
0d06 22 b2 eb		  ld (xrandc),hl 
0d09			 
0d09 c9			  ret 
0d0a			;  
0d0a			 
0d0a			 
0d0a			;;;; int maths 
0d0a			 
0d0a			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d0a			; Divide 16-bit values (with 16-bit result) 
0d0a			; In: Divide BC by divider DE 
0d0a			; Out: BC = result, HL = rest 
0d0a			; 
0d0a			Div16: 
0d0a 21 00 00		    ld hl,0 
0d0d 78			    ld a,b 
0d0e 06 08		    ld b,8 
0d10			Div16_Loop1: 
0d10 17			    rla 
0d11 ed 6a		    adc hl,hl 
0d13 ed 52		    sbc hl,de 
0d15 30 01		    jr nc,Div16_NoAdd1 
0d17 19			    add hl,de 
0d18			Div16_NoAdd1: 
0d18 10 f6		    djnz Div16_Loop1 
0d1a 17			    rla 
0d1b 2f			    cpl 
0d1c 47			    ld b,a 
0d1d 79			    ld a,c 
0d1e 48			    ld c,b 
0d1f 06 08		    ld b,8 
0d21			Div16_Loop2: 
0d21 17			    rla 
0d22 ed 6a		    adc hl,hl 
0d24 ed 52		    sbc hl,de 
0d26 30 01		    jr nc,Div16_NoAdd2 
0d28 19			    add hl,de 
0d29			Div16_NoAdd2: 
0d29 10 f6		    djnz Div16_Loop2 
0d2b 17			    rla 
0d2c 2f			    cpl 
0d2d 41			    ld b,c 
0d2e 4f			    ld c,a 
0d2f c9			ret 
0d30			 
0d30			 
0d30			;http://z80-heaven.wikidot.com/math 
0d30			; 
0d30			;Inputs: 
0d30			;     DE and A are factors 
0d30			;Outputs: 
0d30			;     A is not changed 
0d30			;     B is 0 
0d30			;     C is not changed 
0d30			;     DE is not changed 
0d30			;     HL is the product 
0d30			;Time: 
0d30			;     342+6x 
0d30			; 
0d30			Mult16: 
0d30			 
0d30 06 08		     ld b,8          ;7           7 
0d32 21 00 00		     ld hl,0         ;10         10 
0d35 29			       add hl,hl     ;11*8       88 
0d36 07			       rlca          ;4*8        32 
0d37 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d39 19			         add hl,de   ;--         -- 
0d3a 10 f9		       djnz $-5      ;13*7+8     99 
0d3c c9			ret 
0d3d			 
0d3d			; 
0d3d			; Square root of 16-bit value 
0d3d			; In:  HL = value 
0d3d			; Out:  D = result (rounded down) 
0d3d			; 
0d3d			;Sqr16: 
0d3d			;    ld de,#0040 
0d3d			;    ld a,l 
0d3d			;    ld l,h 
0d3d			;    ld h,d 
0d3d			;    or a 
0d3d			;    ld b,8 
0d3d			;Sqr16_Loop: 
0d3d			;    sbc hl,de 
0d3d			;    jr nc,Sqr16_Skip 
0d3d			;    add hl,de 
0d3d			;Sqr16_Skip: 
0d3d			;    ccf 
0d3d			;    rl d 
0d3d			;    add a,a 
0d3d			;    adc hl,hl 
0d3d			;    add a,a 
0d3d			;    adc hl,hl 
0d3d			;    djnz Sqr16_Loop 
0d3d			;    ret 
0d3d			; 
0d3d			; 
0d3d			; Divide 8-bit values 
0d3d			; In: Divide E by divider C 
0d3d			; Out: A = result, B = rest 
0d3d			; 
0d3d			Div8: 
0d3d af			    xor a 
0d3e 06 08		    ld b,8 
0d40			Div8_Loop: 
0d40 cb 13		    rl e 
0d42 17			    rla 
0d43 91			    sub c 
0d44 30 01		    jr nc,Div8_NoAdd 
0d46 81			    add a,c 
0d47			Div8_NoAdd: 
0d47 10 f7		    djnz Div8_Loop 
0d49 47			    ld b,a 
0d4a 7b			    ld a,e 
0d4b 17			    rla 
0d4c 2f			    cpl 
0d4d c9			    ret 
0d4e			 
0d4e			; 
0d4e			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d4e			; In: Multiply A with DE 
0d4e			; Out: HL = result 
0d4e			; 
0d4e			Mult12U: 
0d4e 2e 00		    ld l,0 
0d50 87			    add a,a 
0d51 30 01		    jr nc,Mult12U_NoAdd0 
0d53 19			    add hl,de 
0d54			Mult12U_NoAdd0: 
0d54 29			    add hl,hl 
0d55 87			    add a,a 
0d56 30 01		    jr nc,Mult12U_NoAdd1 
0d58 19			    add hl,de 
0d59			Mult12U_NoAdd1: 
0d59 29			    add hl,hl 
0d5a 87			    add a,a 
0d5b 30 01		    jr nc,Mult12U_NoAdd2 
0d5d 19			    add hl,de 
0d5e			Mult12U_NoAdd2: 
0d5e 29			    add hl,hl 
0d5f 87			    add a,a 
0d60 30 01		    jr nc,Mult12U_NoAdd3 
0d62 19			    add hl,de 
0d63			Mult12U_NoAdd3: 
0d63 29			    add hl,hl 
0d64 87			    add a,a 
0d65 30 01		    jr nc,Mult12U_NoAdd4 
0d67 19			    add hl,de 
0d68			Mult12U_NoAdd4: 
0d68 29			    add hl,hl 
0d69 87			    add a,a 
0d6a 30 01		    jr nc,Mult12U_NoAdd5 
0d6c 19			    add hl,de 
0d6d			Mult12U_NoAdd5: 
0d6d 29			    add hl,hl 
0d6e 87			    add a,a 
0d6f 30 01		    jr nc,Mult12U_NoAdd6 
0d71 19			    add hl,de 
0d72			Mult12U_NoAdd6: 
0d72 29			    add hl,hl 
0d73 87			    add a,a 
0d74 d0			    ret nc 
0d75 19			    add hl,de 
0d76 c9			    ret 
0d77			 
0d77			; 
0d77			; Multiply 8-bit value with a 16-bit value (right rotating) 
0d77			; In: Multiply A with DE 
0d77			;      Put lowest value in A for most efficient calculation 
0d77			; Out: HL = result 
0d77			; 
0d77			Mult12R: 
0d77 21 00 00		    ld hl,0 
0d7a			Mult12R_Loop: 
0d7a cb 3f		    srl a 
0d7c 30 01		    jr nc,Mult12R_NoAdd 
0d7e 19			    add hl,de 
0d7f			Mult12R_NoAdd: 
0d7f cb 23		    sla e 
0d81 cb 12		    rl d 
0d83 b7			    or a 
0d84 c2 7a 0d		    jp nz,Mult12R_Loop 
0d87 c9			    ret 
0d88			 
0d88			; 
0d88			; Multiply 16-bit values (with 32-bit result) 
0d88			; In: Multiply BC with DE 
0d88			; Out: BCHL = result 
0d88			; 
0d88			Mult32: 
0d88 79			    ld a,c 
0d89 48			    ld c,b 
0d8a 21 00 00		    ld hl,0 
0d8d 06 10		    ld b,16 
0d8f			Mult32_Loop: 
0d8f 29			    add hl,hl 
0d90 17			    rla 
0d91 cb 11		    rl c 
0d93 30 07		    jr nc,Mult32_NoAdd 
0d95 19			    add hl,de 
0d96 ce 00		    adc a,0 
0d98 d2 9c 0d		    jp nc,Mult32_NoAdd 
0d9b 0c			    inc c 
0d9c			Mult32_NoAdd: 
0d9c 10 f1		    djnz Mult32_Loop 
0d9e 41			    ld b,c 
0d9f 4f			    ld c,a 
0da0 c9			    ret 
0da1			 
0da1			 
0da1			 
0da1			; 
0da1			; Multiply 8-bit values 
0da1			; In:  Multiply H with E 
0da1			; Out: HL = result 
0da1			; 
0da1			Mult8: 
0da1 16 00		    ld d,0 
0da3 6a			    ld l,d 
0da4 06 08		    ld b,8 
0da6			Mult8_Loop: 
0da6 29			    add hl,hl 
0da7 30 01		    jr nc,Mult8_NoAdd 
0da9 19			    add hl,de 
0daa			Mult8_NoAdd: 
0daa 10 fa		    djnz Mult8_Loop 
0dac c9			    ret 
0dad			 
0dad			 
0dad			 
0dad			 
0dad			 
0dad			 
0dad			 
0dad			 
0dad			;;http://z80-heaven.wikidot.com/math 
0dad			;;This divides DE by BC, storing the result in DE, remainder in HL 
0dad			; 
0dad			;DE_Div_BC:          ;1281-2x, x is at most 16 
0dad			;     ld a,16        ;7 
0dad			;     ld hl,0        ;10 
0dad			;     jp $+5         ;10 
0dad			;.DivLoop: 
0dad			;       add hl,bc    ;-- 
0dad			;       dec a        ;64 
0dad			;       jr z,.DivLoopEnd        ;86 
0dad			; 
0dad			;       sla e        ;128 
0dad			;       rl d         ;128 
0dad			;       adc hl,hl    ;240 
0dad			;       sbc hl,bc    ;240 
0dad			;       jr nc,.DivLoop ;23|21 
0dad			;       inc e        ;-- 
0dad			;       jp .DivLoop+1 
0dad			; 
0dad			;.DivLoopEnd: 
0dad			 
0dad			;HL_Div_C: 
0dad			;Inputs: 
0dad			;     HL is the numerator 
0dad			;     C is the denominator 
0dad			;Outputs: 
0dad			;     A is the remainder 
0dad			;     B is 0 
0dad			;     C is not changed 
0dad			;     DE is not changed 
0dad			;     HL is the quotient 
0dad			; 
0dad			;       ld b,16 
0dad			;       xor a 
0dad			;         add hl,hl 
0dad			;         rla 
0dad			;         cp c 
0dad			;         jr c,$+4 
0dad			;           inc l 
0dad			;           sub c 
0dad			;         djnz $-7 
0dad			 
0dad			; https://plutiedev.com/z80-add-8bit-to-16bit 
0dad			 
0dad			addatohl: 
0dad 85			    add   a, l    ; A = A+L 
0dae 6f			    ld    l, a    ; L = A+L 
0daf 8c			    adc   a, h    ; A = A+L+H+carry 
0db0 95			    sub   l       ; A = H+carry 
0db1 67			    ld    h, a    ; H = H+carry 
0db2 c9			ret 
0db3			 
0db3			addatode: 
0db3 83			    add   a, e    ; A = A+L 
0db4 5f			    ld    e, a    ; L = A+L 
0db5 8a			    adc   a, d    ; A = A+L+H+carry 
0db6 93			    sub   e       ; A = H+carry 
0db7 57			    ld    d, a    ; H = H+carry 
0db8 c9			ret 
0db9			 
0db9			 
0db9			addatobc: 
0db9 81			    add   a, c    ; A = A+L 
0dba 4f			    ld    c, a    ; L = A+L 
0dbb 88			    adc   a, b    ; A = A+L+H+carry 
0dbc 91			    sub   c       ; A = H+carry 
0dbd 47			    ld    b, a    ; H = H+carry 
0dbe c9			ret 
0dbf			 
0dbf			subafromhl: 
0dbf			   ; If A=0 do nothing 
0dbf			    ; Otherwise flip A's sign. Since 
0dbf			    ; the upper byte becomes -1, also 
0dbf			    ; substract 1 from H. 
0dbf ed 44		    neg 
0dc1 ca ca 0d		    jp    z, Skip 
0dc4 25			    dec   h 
0dc5			     
0dc5			    ; Now add the low byte as usual 
0dc5			    ; Two's complement takes care of 
0dc5			    ; ensuring the result is correct 
0dc5 85			    add   a, l 
0dc6 6f			    ld    l, a 
0dc7 8c			    adc   a, h 
0dc8 95			    sub   l 
0dc9 67			    ld    h, a 
0dca			Skip: 
0dca c9				ret 
0dcb			 
0dcb			 
0dcb			; compare hl and de 
0dcb			; returns:  
0dcb			; if hl = de, z=1, s=0, c0=0 
0dcb			; if hl > de, z=0, s=0, c=0 
0dcb			; if hl < de, z=0, s=1, c=1 
0dcb			cmp16:	 
0dcb b7				or a 
0dcc ed 52			sbc hl,de 
0dce e0				ret po 
0dcf 7c				ld a,h 
0dd0 1f				rra 
0dd1 ee 40			xor 01000000B 
0dd3 37				scf 
0dd4 8f				adc a,a 
0dd5 c9				ret 
0dd6			 
0dd6			 
0dd6			; test if hl contains zero   - A is destroyed 
0dd6			 
0dd6			ishlzero:    
0dd6 b7				or a     ; reset flags 
0dd7 7c				ld a, h 
0dd8 b5				or l        	 
0dd9			 
0dd9 c9				ret 
0dda			 
0dda			 
0dda			 
0dda			 
0dda			if FORTH_ENABLE_FLOATMATH 
0dda			;include "float/bbcmath.z80" 
0dda			include "float/lpfpcalc.asm" 
0dda			endif 
0dda			 
0dda			 
0dda			; eof 
0dda			 
# End of file firmware_maths.asm
0dda			include "firmware_strings.asm"   ; string handling  
0dda			 
0dda			 
0dda			; TODO string len 
0dda			; input text string, end on cr with zero term 
0dda			; a offset into frame buffer to start prompt 
0dda			; d is max length 
0dda			; e is display size TODO 
0dda			; c is current cursor position 
0dda			; hl is ptr to where string will be stored 
0dda			 
0dda			 
0dda			; TODO check limit of buffer for new inserts 
0dda			; TODO check insert does not push beyond buffer 
0dda			; TODO scroll in a limited display area 
0dda			; TODO scroll whole screen on page wrap 
0dda			 
0dda			 
0dda			; TODO handle KEY_PREVWORD 
0dda			; TODO handle KEY_NEXTWORD 
0dda			; TODO handle KEY_HOME 
0dda			; TODO handle KEY_END 
0dda			; TODO use LCD cursor? 
0dda			 
0dda 32 6a ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0ddd 81					add c 
0dde 32 68 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0de1 22 6d ee				ld (input_start), hl     ; save ptr to buffer 
0de4 79					ld a, c 
0de5 cd ad 0d				call addatohl 
0de8 22 6f ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0deb 7a					ld a,d 
0dec 32 6c ee			        ld (input_size), a       ; save length of input area 
0def 79					ld a, c 
0df0 32 5b ee				ld (input_cursor),a      ; init cursor start position  
0df3 7b					ld a,e 
0df4 32 6b ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0df7					 
0df7					 
0df7			 
0df7			;		ld a,(input_ptr) 
0df7			;		ld (input_under_cursor),a 	; save what is under the cursor 
0df7			 
0df7			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0df7					; init cursor shape if not set by the cin routines 
0df7 21 ca eb				ld hl, cursor_shape 
0dfa 3e ff				ld a, 255 
0dfc 77					ld (hl), a 
0dfd 23					inc hl 
0dfe 3e 00				ld a, 0 
0e00 77					ld (hl), a 
0e01			 
0e01 3e 0f				ld a, CUR_BLINK_RATE 
0e03 32 66 ee				ld (input_cur_flash), a 
0e06 3e 01				ld a, 1 
0e08 32 65 ee				ld (input_cur_onoff),a 
0e0b			 
0e0b			;	if DEBUG_INPUT 
0e0b			;		push af 
0e0b			;		ld a, 'I' 
0e0b			;		ld (debug_mark),a 
0e0b			;		pop af 
0e0b			;		CALLMONITOR 
0e0b			;	endif 
0e0b			.is1:		; main entry loop 
0e0b			 
0e0b			 
0e0b			 
0e0b					; pause 1ms 
0e0b			 
0e0b 3e 01				ld a, 1 
0e0d cd d7 0a				call aDelayInMS 
0e10			 
0e10					; dec flash counter 
0e10 3a 66 ee				ld a, (input_cur_flash) 
0e13 3d					dec a 
0e14 32 66 ee				ld (input_cur_flash), a 
0e17 fe 00				cp 0 
0e19 20 0d				jr nz, .nochgstate 
0e1b			 
0e1b			 
0e1b					; change state 
0e1b 3a 65 ee				ld a,(input_cur_onoff) 
0e1e ed 44				neg 
0e20 32 65 ee				ld (input_cur_onoff),a 
0e23			 
0e23			 
0e23					; reset on change of state 
0e23 3e 0f				ld a, CUR_BLINK_RATE 
0e25 32 66 ee				ld (input_cur_flash), a 
0e28			 
0e28			.nochgstate: 
0e28					 
0e28					 
0e28			 
0e28					; display cursor  
0e28			 
0e28			;		ld hl, (input_start) 
0e28			;		ld a, (input_cursor) 
0e28			;		call addatohl 
0e28			 
0e28					; get char under cursor and replace with cursor 
0e28 2a 6f ee		ld hl, (input_ptr) 
0e2b			;		ld a, (hl) 
0e2b			;		ld (input_under_cursor),a 
0e2b			;		ld a, '_' 
0e2b			;		ld (hl), a 
0e2b			 
0e2b					; display string 
0e2b			 
0e2b ed 5b 6d ee			ld de, (input_start) 
0e2f 3a 6a ee				ld a, (input_at_pos) 
0e32 cd 93 0b				call str_at_display 
0e35			;	        call update_display 
0e35			 
0e35					; find place to put the cursor 
0e35			;		add h 
0e35			;		ld l, display_row_1 
0e35			;		sub l 
0e35			; (input_at_pos) 
0e35					;ld c, a 
0e35			;		ld a, (input_cursor) 
0e35			;		ld l, (input_at_pos) 
0e35			;		;ld b, h 
0e35			;		add l 
0e35			;		ld (input_at_cursor),a 
0e35					;ld l,h 
0e35			 
0e35			;		ld h, 0 
0e35			;		ld l,(input_at_pos) 
0e35			;		ld a, (input_cursor) 
0e35			;		call addatohl 
0e35			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0e35			;		call subafromhl 
0e35			;		ld a,l 
0e35			;		ld (input_at_cursor), a 
0e35			 
0e35				if DEBUG_INPUT 
0e35					ld a, (hardware_diag) 
0e35					cp 0 
0e35					jr z, .skip_input_diag 
0e35			 
0e35					ld a,(input_at_pos) 
0e35					ld hl, LFSRSeed 
0e35					call hexout 
0e35					ld a, (input_cursor) 
0e35					ld hl, LFSRSeed+2 
0e35					call hexout 
0e35					ld a,(input_at_cursor) 
0e35					ld hl, LFSRSeed+4 
0e35					call hexout 
0e35			 
0e35					ld a,(input_cur_onoff) 
0e35					ld hl, LFSRSeed+6 
0e35					call hexout 
0e35			 
0e35					ld a,(input_cur_flash) 
0e35					ld hl, LFSRSeed+8 
0e35					call hexout 
0e35			 
0e35					ld a,(input_len) 
0e35					ld hl, LFSRSeed+10 
0e35					call hexout 
0e35					ld hl, LFSRSeed+12 
0e35					ld a, 0 
0e35					ld (hl),a 
0e35					ld a, display_row_4 
0e35					ld de, LFSRSeed 
0e35					call str_at_display 
0e35					.skip_input_diag: 
0e35				endif 
0e35			 
0e35					; decide on if we are showing the cursor this time round 
0e35			 
0e35 3a 65 ee				ld a, (input_cur_onoff) 
0e38 fe ff				cp 255 
0e3a 28 13				jr z, .skipcur 
0e3c			 
0e3c			 
0e3c 3a 68 ee				ld a,(input_at_cursor) 
0e3f 11 ca eb				ld de, cursor_shape 
0e42 cd 93 0b				call str_at_display 
0e45			 
0e45					; save length of current input string 
0e45 2a 6d ee				ld hl, (input_start) 
0e48 cd 0b 12				call strlenz 
0e4b 7d					ld a,l 
0e4c 32 60 ee				ld (input_len),a 
0e4f			 
0e4f			.skipcur: 
0e4f			 
0e4f cd a3 0b			        call update_display 
0e52					 
0e52			 
0e52			 
0e52					; wait 
0e52				 
0e52					; TODO loop without wait to flash the cursor and char under cursor	 
0e52 cd a5 61				call cin    ; _wait 
0e55			 
0e55 fe 00				cp 0 
0e57 ca 0b 0e				jp z, .is1 
0e5a			 
0e5a					; get ptr to char to input into 
0e5a			 
0e5a 4f					ld c,a 
0e5b 2a 6d ee				ld hl, (input_start) 
0e5e 3a 5b ee				ld a, (input_cursor) 
0e61 cd ad 0d				call addatohl 
0e64 22 6f ee				ld (input_ptr), hl 
0e67 79					ld a,c 
0e68			 
0e68					; replace char under cursor 
0e68			 
0e68			;		ld hl, (input_ptr) 
0e68			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0e68			;		ld (hl), a 
0e68			 
0e68			;	if DEBUG_INPUT 
0e68			;		push af 
0e68			;		ld a, 'i' 
0e68			;		ld (debug_mark),a 
0e68			;		pop af 
0e68			;		CALLMONITOR 
0e68			;	endif 
0e68 fe 0e				cp KEY_HOME 
0e6a 20 0e				jr nz, .iske 
0e6c			 
0e6c 3a 6a ee				ld a, (input_at_pos) 
0e6f 32 68 ee				ld (input_at_cursor),a 
0e72 3e 00				ld a, 0 
0e74 32 5b ee				ld (input_cursor), a 
0e77 c3 0b 0e				jp .is1 
0e7a					 
0e7a fe 0f		.iske:		cp KEY_END 
0e7c 20 03				jr nz, .isknw 
0e7e c3 0b 0e				jp .is1 
0e81			 
0e81 fe 06		.isknw:		cp KEY_NEXTWORD 
0e83 20 1b				jr nz, .iskpw 
0e85			 
0e85 2a 6f ee		.isknwm:	ld hl, (input_ptr) 
0e88 7e					ld a,(hl)	 
0e89 fe 00				cp 0 
0e8b ca 0b 0e				jp z, .is1    ; end of string 
0e8e fe 20				cp ' ' 
0e90 ca 0b 0e				jp z, .is1    ; end of word 
0e93 23					inc hl 
0e94 22 6f ee				ld (input_ptr), hl 
0e97 3a 68 ee				ld a, (input_at_cursor) 
0e9a 3c					inc a 
0e9b 32 68 ee				ld (input_at_cursor), a 
0e9e 18 e5				jr .isknwm 
0ea0			 
0ea0 fe 07		.iskpw:		cp KEY_PREVWORD 
0ea2 20 1b				jr nz, .iskl 
0ea4			.iskpwm:	 
0ea4 2a 6f ee				ld hl, (input_ptr) 
0ea7 7e					ld a,(hl)	 
0ea8 fe 00				cp 0  
0eaa ca 0b 0e				jp z, .is1    ; end of string 
0ead fe 20				cp ' ' 
0eaf ca 0b 0e				jp z, .is1    ; end of word 
0eb2 2b					dec hl 
0eb3 22 6f ee				ld (input_ptr), hl 
0eb6 3a 68 ee				ld a, (input_at_cursor) 
0eb9 3d					dec a 
0eba 32 68 ee				ld (input_at_cursor), a 
0ebd 18 e5				jr .iskpwm 
0ebf			 
0ebf			 
0ebf fe 0b		.iskl:		cp KEY_LEFT 
0ec1 20 27				jr nz, .isk1 
0ec3			 
0ec3 3a 5b ee				ld a, (input_cursor) 
0ec6			 
0ec6 fe 00				cp 0 
0ec8 ca 0b 0e				jp z, .is1 		; at start of line to ignore  
0ecb			 
0ecb 3d					dec  a 		; TODO check underflow 
0ecc 32 5b ee				ld (input_cursor), a 
0ecf			 
0ecf 2a 6f ee				ld hl, (input_ptr) 
0ed2 2b					dec hl 
0ed3 22 6f ee				ld (input_ptr), hl 
0ed6					 
0ed6 3a 68 ee				ld a, (input_at_cursor) 
0ed9 3d					dec a 
0eda 32 68 ee				ld (input_at_cursor), a 
0edd			 
0edd 3e 01				ld a, 1		; show cursor moving 
0edf 32 65 ee				ld (input_cur_onoff),a 
0ee2 3e 0f				ld a, CUR_BLINK_RATE 
0ee4 32 66 ee				ld (input_cur_flash), a 
0ee7			 
0ee7 c3 0b 0e				jp .is1 
0eea			 
0eea fe 0c		.isk1:		cp KEY_RIGHT 
0eec 20 2a				jr nz, .isk2 
0eee			 
0eee 3a 60 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0ef1 5f					ld e,a 
0ef2 3a 5b ee				ld a, (input_cursor) 
0ef5 bb					cp e 
0ef6 ca 0b 0e				jp z, .is1		; at the end of string so dont go right 
0ef9			 
0ef9 3c					inc  a 		; TODO check overflow 
0efa 32 5b ee				ld (input_cursor), a 
0efd			 
0efd 3a 68 ee				ld a, (input_at_cursor) 
0f00 3c					inc a 
0f01 32 68 ee				ld (input_at_cursor), a 
0f04			 
0f04 2a 6f ee				ld hl, (input_ptr) 
0f07 23					inc hl 
0f08 22 6f ee				ld (input_ptr), hl 
0f0b			 
0f0b 3e 01				ld a, 1		; show cursor moving 
0f0d 32 65 ee				ld (input_cur_onoff),a 
0f10 3e 0f				ld a, CUR_BLINK_RATE 
0f12 32 66 ee				ld (input_cur_flash), a 
0f15			 
0f15 c3 0b 0e				jp .is1 
0f18			 
0f18 fe 05		.isk2:		cp KEY_UP 
0f1a			 
0f1a 20 26				jr nz, .isk3 
0f1c			 
0f1c					; swap last command with the current on 
0f1c			 
0f1c					; move cursor to start of string 
0f1c 2a 6d ee				ld hl, (input_start) 
0f1f 22 6f ee				ld (input_ptr), hl 
0f22			 
0f22 3a 6a ee				ld a, (input_at_pos) 
0f25 32 68 ee				ld (input_at_cursor), a 
0f28			 
0f28 3e 00				ld a, 0 
0f2a 32 5b ee				ld (input_cursor), a 
0f2d					 
0f2d					; swap input and last command buffers 
0f2d			 
0f2d 21 f2 e5				ld hl, os_cli_cmd 
0f30 11 f1 e6				ld de, os_last_cmd 
0f33 06 ff				ld b, 255 
0f35 7e			.swap1:		ld a, (hl) 
0f36 4f					ld c,a 
0f37 1a					ld a, (de) 
0f38 77					ld (hl), a 
0f39 79					ld a,c 
0f3a 12					ld (de),a 
0f3b 23					inc hl 
0f3c 13					inc de 
0f3d 10 f6				djnz .swap1 
0f3f			 
0f3f			 
0f3f			 
0f3f			 
0f3f			 
0f3f c3 0b 0e				jp .is1 
0f42			 
0f42 fe 08		.isk3:		cp KEY_BS 
0f44 20 3c				jr nz, .isk4 
0f46			 
0f46 3a 5b ee				ld a, (input_cursor) 
0f49			 
0f49 fe 00				cp 0 
0f4b ca 0b 0e				jp z, .is1 		; at start of line to ignore  
0f4e			 
0f4e 3d					dec  a 		; TODO check underflow 
0f4f 32 5b ee				ld (input_cursor), a 
0f52			 
0f52					; hl is source 
0f52					; de needs to be source - 1 
0f52			 
0f52			;		ld a, 0 
0f52			;		dec hl 
0f52			;		ld (hl), a 
0f52			 
0f52 2a 6f ee				ld hl, (input_ptr) 
0f55 2b					dec hl 
0f56 22 6f ee				ld (input_ptr), hl 
0f59			 
0f59					; shift all data 
0f59			 
0f59 e5					push hl 
0f5a 23					inc hl 
0f5b d1					pop de 
0f5c 3a 60 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0f5f 4f					ld c,a 
0f60 06 00				ld b,0 
0f62 ed b0				ldir  
0f64			 
0f64			 
0f64			 
0f64			 
0f64 3a 68 ee				ld a, (input_at_cursor) 
0f67 3d					dec a 
0f68 32 68 ee				ld (input_at_cursor), a 
0f6b			 
0f6b			 
0f6b 3e 01				ld a, 1		; show cursor moving 
0f6d 32 65 ee				ld (input_cur_onoff),a 
0f70 3e 0f				ld a, CUR_BLINK_RATE 
0f72 32 66 ee				ld (input_cur_flash), a 
0f75			 
0f75					; remove char 
0f75 3a 68 ee				ld a, (input_at_cursor) 
0f78 3c					inc a 
0f79 11 03 10				ld de,.iblank 
0f7c cd 93 0b				call str_at_display 
0f7f			 
0f7f c3 0b 0e				jp .is1 
0f82			 
0f82 fe 0d		.isk4:		cp KEY_CR 
0f84 28 6c				jr z, .endinput 
0f86			 
0f86					; else add the key press to the end 
0f86			 
0f86 4f					ld c, a			; save key pressed 
0f87			 
0f87 7e					ld a,(hl)		; get what is currently under char 
0f88			 
0f88 fe 00				cp 0			; we are at the end of the string 
0f8a 20 2f				jr nz, .onchar 
0f8c					 
0f8c					; add a char to the end of the string 
0f8c				 
0f8c 71					ld (hl),c 
0f8d 23					inc hl 
0f8e			;		ld a,' ' 
0f8e			;		ld (hl),a 
0f8e			;		inc hl 
0f8e 3e 00				ld a,0 
0f90 77					ld (hl),a 
0f91 2b					dec hl 
0f92			 
0f92 3a 5b ee				ld a, (input_cursor) 
0f95 3c					inc a				; TODO check max string length and scroll  
0f96 32 5b ee				ld (input_cursor), a		; inc cursor pos 
0f99							 
0f99 3a 68 ee				ld a, (input_at_cursor) 
0f9c 3c					inc a 
0f9d 32 68 ee				ld (input_at_cursor), a 
0fa0			 
0fa0 2a 6f ee				ld hl, (input_ptr) 
0fa3 23					inc hl 
0fa4 22 6f ee				ld (input_ptr), hl 
0fa7			 
0fa7 2a 6f ee				ld hl, (input_ptr) 
0faa 23					inc hl 
0fab 22 6f ee				ld (input_ptr), hl 
0fae			;	if DEBUG_INPUT 
0fae			;		push af 
0fae			;		ld a, '+' 
0fae			;		ld (debug_mark),a 
0fae			;		pop af 
0fae			;		CALLMONITOR 
0fae			;	endif 
0fae 3e 01				ld a, 1		; show cursor moving 
0fb0 32 65 ee				ld (input_cur_onoff),a 
0fb3 3e 0f				ld a, CUR_BLINK_RATE 
0fb5 32 66 ee				ld (input_cur_flash), a 
0fb8 c3 0b 0e				jp .is1 
0fbb					 
0fbb			 
0fbb			 
0fbb					; if on a char then insert 
0fbb			.onchar: 
0fbb			 
0fbb					; TODO over flow check: make sure insert does not blow out buffer 
0fbb			 
0fbb					; need to do some maths to use lddr 
0fbb			 
0fbb e5					push hl   ; save char pos 
0fbc c5					push bc 
0fbd			 
0fbd 2a 6d ee				ld hl, (input_start) 
0fc0 3a 60 ee				ld a, (input_len) 
0fc3 cd ad 0d				call addatohl  		; end of string 
0fc6 23					inc hl 
0fc7 23					inc hl		; past zero term 
0fc8 e5					push hl 
0fc9 23					inc hl 
0fca e5					push hl  
0fcb			 
0fcb								; start and end of lddr set, now how much to move? 
0fcb			 
0fcb							 
0fcb 3a 5b ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0fce 47					ld b,a 
0fcf 3a 60 ee				ld a,(input_len) 
0fd2 5f					ld e,a 
0fd3 90					sub b 
0fd4 3c					inc a		;?? 
0fd5 3c					inc a		;?? 
0fd6 3c					inc a		;?? 
0fd7			 
0fd7 06 00				ld b,0 
0fd9 4f					ld c,a 
0fda			 
0fda				if DEBUG_INPUT 
0fda					push af 
0fda					ld a, 'i' 
0fda					ld (debug_mark),a 
0fda					pop af 
0fda			;		CALLMONITOR 
0fda				endif 
0fda d1					pop de 
0fdb e1					pop hl 
0fdc				if DEBUG_INPUT 
0fdc					push af 
0fdc					ld a, 'I' 
0fdc					ld (debug_mark),a 
0fdc					pop af 
0fdc			;		CALLMONITOR 
0fdc				endif 
0fdc ed b8				lddr 
0fde				 
0fde			 
0fde			 
0fde					; TODO have a key for insert/overwrite mode???? 
0fde c1					pop bc 
0fdf e1					pop hl 
0fe0 71					ld (hl), c		; otherwise overwrite current char 
0fe1					 
0fe1			 
0fe1			 
0fe1			 
0fe1 3a 5b ee				ld a, (input_cursor) 
0fe4 3c					inc  a 		; TODO check overflow 
0fe5 32 5b ee				ld (input_cursor), a 
0fe8			 
0fe8 3a 68 ee				ld a, (input_at_cursor) 
0feb 3c					inc a 
0fec 32 68 ee				ld (input_at_cursor), a 
0fef			 
0fef c3 0b 0e				jp .is1 
0ff2			 
0ff2			.endinput:	; TODO look for end of string 
0ff2			 
0ff2					; add trailing space for end of token 
0ff2			 
0ff2 2a 6d ee				ld hl, (input_start) 
0ff5 3a 60 ee				ld a,(input_len) 
0ff8 cd ad 0d				call addatohl 
0ffb 3e 20				ld a, ' ' 
0ffd 77					ld (hl),a 
0ffe					; TODO eof of parse marker 
0ffe			 
0ffe 23					inc hl 
0fff 3e 00				ld a, 0 
1001 77					ld (hl),a 
1002			 
1002			 
1002 c9					ret 
1003			 
1003 .. 00		.iblank: db " ",0 
1005			 
1005			 
1005 32 6a ee		input_str_prev:	ld (input_at_pos), a 
1008 22 6d ee				ld (input_start), hl 
100b 3e 01				ld a,1			; add cursor 
100d 77					ld (hl),a 
100e 23					inc hl 
100f 3e 00				ld a,0 
1011 77					ld (hl),a 
1012 22 6f ee				ld (input_ptr), hl 
1015 7a					ld a,d 
1016 32 6c ee				ld (input_size), a 
1019 3e 00				ld a,0 
101b 32 5b ee				ld (input_cursor),a 
101e			.instr1:	 
101e			 
101e					; TODO do block cursor 
101e					; TODO switch cursor depending on the modifer key 
101e			 
101e					; update cursor shape change on key hold 
101e			 
101e 2a 6f ee				ld hl, (input_ptr) 
1021 2b					dec hl 
1022 3a ca eb				ld a,(cursor_shape) 
1025 77					ld (hl), a 
1026			 
1026					; display entered text 
1026 3a 6a ee				ld a,(input_at_pos) 
1029 cd ba 60		            	CALL fLCD_Pos       ;Position cursor to location in A 
102c ed 5b 6d ee	            	LD   de, (input_start) 
1030 cd af 60		            	CALL fLCD_Str       ;Display string pointed to by DE 
1033			 
1033 cd a5 61				call cin 
1036 fe 00				cp 0 
1038 28 e4				jr z, .instr1 
103a			 
103a					; proecess keyboard controls first 
103a			 
103a 2a 6f ee				ld hl,(input_ptr) 
103d			 
103d fe 0d				cp KEY_CR	 ; pressing enter ends input 
103f 28 5a				jr z, .instrcr 
1041			 
1041 fe 08				cp KEY_BS 	; back space 
1043 20 0f				jr nz, .instr2 
1045					; process back space 
1045			 
1045					; TODO stop back space if at start of string 
1045 2b					dec hl 
1046 2b					dec hl ; to over write cursor 
1047 3a ca eb				ld a,(cursor_shape) 
104a					;ld a,0 
104a 77					ld (hl),a 
104b 23					inc hl 
104c 3e 20				ld a," " 
104e 77					ld (hl),a 
104f 22 6f ee				ld (input_ptr),hl 
1052					 
1052			 
1052 18 ca				jr .instr1 
1054			 
1054 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1056 20 06				jr nz, .instr3 
1058 2b					dec hl 
1059 22 6f ee				ld (input_ptr),hl 
105c 18 c0				jr .instr1 
105e				 
105e fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
1060 20 06				jr nz, .instr4 
1062 23					inc hl 
1063 22 6f ee				ld (input_ptr),hl 
1066 18 b6				jr .instr1 
1068			 
1068 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
106a 20 06				jr nz, .instr5 
106c 2b					dec hl 
106d 22 6f ee				ld (input_ptr),hl 
1070 18 ac				jr .instr1 
1072			 
1072 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1074 20 06				jr nz, .instr6 
1076 2b					dec hl 
1077 22 6f ee				ld (input_ptr),hl 
107a 18 a2				jr .instr1 
107c fe 05		.instr6:        cp KEY_UP      ; recall last command 
107e 20 0b				jr nz, .instrnew 
1080			 
1080 21 cb e2			ld hl, scratch 
1083 11 f1 e6			ld de, os_last_cmd 
1086 cd a4 10			call strcpy 
1089 18 93				jr .instr1 
108b			 
108b			 
108b			.instrnew:	; no special key pressed to see if we have room to store it 
108b			 
108b					; TODO do string size test 
108b			 
108b 2b					dec hl ; to over write cursor 
108c 77					ld (hl),a 
108d 23					inc hl 
108e 3a ca eb				ld a,(cursor_shape) 
1091 77					ld (hl),a 
1092 23					inc hl 
1093 3e 00				ld a,0 
1095 77					ld (hl),a 
1096			 
1096 22 6f ee				ld (input_ptr),hl 
1099					 
1099 18 83				jr .instr1 
109b 2b			.instrcr:	dec hl		; remove cursor 
109c 3e 20				ld a,' '	; TODO add a trailing space for safety 
109e 77					ld (hl),a 
109f 23					inc hl 
10a0 3e 00				ld a,0 
10a2 77					ld (hl),a 
10a3			 
10a3			 
10a3					; if at end of line scroll up    
10a3					; TODO detecting only end of line 4 for scroll up  
10a3			 
10a3					;ld   
10a3			 
10a3 c9					ret 
10a4			 
10a4			 
10a4			; strcpy hl = dest, de source 
10a4			 
10a4 1a			strcpy:   LD   A, (DE)        ;Get character from string 
10a5 b7			            OR   A              ;Null terminator? 
10a6 c8			            RET  Z              ;Yes, so finished 
10a7 1a					ld a,(de) 
10a8 77					ld (hl),a 
10a9 13			            INC  DE             ;Point to next character 
10aa 23					inc hl 
10ab 18 f7		            JR   strcpy       ;Repeat 
10ad c9					ret 
10ae			 
10ae			 
10ae			; TODO string_at  
10ae			; pass string which starts with lcd offset address and then null term string 
10ae			 
10ae			; TODO string to dec 
10ae			; TODO string to hex 
10ae			; TODO byte to string hex 
10ae			; TODO byte to string dec 
10ae			 
10ae			 
10ae			 
10ae			; from z80uartmonitor 
10ae			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10ae			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
10ae			; pass hl for where to put the text 
10ae			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10ae c5			hexout:	PUSH BC 
10af f5					PUSH AF 
10b0 47					LD B, A 
10b1					; Upper nybble 
10b1 cb 3f				SRL A 
10b3 cb 3f				SRL A 
10b5 cb 3f				SRL A 
10b7 cb 3f				SRL A 
10b9 cd c9 10				CALL tohex 
10bc 77					ld (hl),a 
10bd 23					inc hl	 
10be					 
10be					; Lower nybble 
10be 78					LD A, B 
10bf e6 0f				AND 0FH 
10c1 cd c9 10				CALL tohex 
10c4 77					ld (hl),a 
10c5 23					inc hl	 
10c6					 
10c6 f1					POP AF 
10c7 c1					POP BC 
10c8 c9					RET 
10c9					 
10c9			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10c9			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
10c9			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10c9			tohex: 
10c9 e5					PUSH HL 
10ca d5					PUSH DE 
10cb 16 00				LD D, 0 
10cd 5f					LD E, A 
10ce 21 d6 10				LD HL, .DATA 
10d1 19					ADD HL, DE 
10d2 7e					LD A, (HL) 
10d3 d1					POP DE 
10d4 e1					POP HL 
10d5 c9					RET 
10d6			 
10d6			.DATA: 
10d6 30					DEFB	30h	; 0 
10d7 31					DEFB	31h	; 1 
10d8 32					DEFB	32h	; 2 
10d9 33					DEFB	33h	; 3 
10da 34					DEFB	34h	; 4 
10db 35					DEFB	35h	; 5 
10dc 36					DEFB	36h	; 6 
10dd 37					DEFB	37h	; 7 
10de 38					DEFB	38h	; 8 
10df 39					DEFB	39h	; 9 
10e0 41					DEFB	41h	; A 
10e1 42					DEFB	42h	; B 
10e2 43					DEFB	43h	; C 
10e3 44					DEFB	44h	; D 
10e4 45					DEFB	45h	; E 
10e5 46					DEFB	46h	; F 
10e6			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
10e6			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
10e6			;;    subtract $30, if result > 9 then subtract $7 more 
10e6			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
10e6			atohex: 
10e6 d6 30				SUB $30 
10e8 fe 0a				CP 10 
10ea f8					RET M		; If result negative it was 0-9 so we're done 
10eb d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
10ed c9					RET		 
10ee			 
10ee			 
10ee			 
10ee			 
10ee			; Get 2 ASCII characters as hex byte from pointer in hl 
10ee			 
10ee			BYTERD: 
10ee 16 00			LD	D,00h		;Set up 
10f0 cd f8 10			CALL	HEXCON		;Get byte and convert to hex 
10f3 87				ADD	A,A		;First nibble so 
10f4 87				ADD	A,A		;multiply by 16 
10f5 87				ADD	A,A		; 
10f6 87				ADD	A,A		; 
10f7 57				LD	D,A		;Save hi nibble in D 
10f8			HEXCON: 
10f8 7e				ld a, (hl)		;Get next chr 
10f9 23				inc hl 
10fa d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
10fc fe 0a			CP	00Ah		;Is it 0-9 ? 
10fe 38 02			JR	C,NALPHA	;If so miss next bit 
1100 d6 07			SUB	007h		;Else convert alpha 
1102			NALPHA: 
1102 b2				OR	D		;Add hi nibble back 
1103 c9				RET			; 
1104			 
1104			 
1104			; 
1104			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1104			; Since the routines get_byte and therefore get_nibble are called, only valid 
1104			; characters (0-9a-f) are accepted. 
1104			; 
1104			;get_word        push    af 
1104			;                call    get_byte        ; Get the upper byte 
1104			;                ld      h, a 
1104			;                call    get_byte        ; Get the lower byte 
1104			;                ld      l, a 
1104			;                pop     af 
1104			;                ret 
1104			; 
1104			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1104			; the routine get_nibble is used only valid characters are accepted - the  
1104			; input routine only accepts characters 0-9a-f. 
1104			; 
1104 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1105 7e					ld a,(hl) 
1106 23					inc hl 
1107 cd 2c 11		                call    nibble2val      ; Get upper nibble 
110a cb 07		                rlc     a 
110c cb 07		                rlc     a 
110e cb 07		                rlc     a 
1110 cb 07		                rlc     a 
1112 47			                ld      b, a            ; Save upper four bits 
1113 7e					ld a,(hl) 
1114 cd 2c 11		                call    nibble2val      ; Get lower nibble 
1117 b0			                or      b               ; Combine both nibbles 
1118 c1			                pop     bc              ; Restore B (and C) 
1119 c9			                ret 
111a			; 
111a			; Get a hexadecimal digit from the serial line. This routine blocks until 
111a			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
111a			; to the serial line interface. The lower 4 bits of A contain the value of  
111a			; that particular digit. 
111a			; 
111a			;get_nibble      ld a,(hl)           ; Read a character 
111a			;                call    to_upper        ; Convert to upper case 
111a			;                call    is_hex          ; Was it a hex digit? 
111a			;                jr      nc, get_nibble  ; No, get another character 
111a			 ;               call    nibble2val      ; Convert nibble to value 
111a			 ;               call    print_nibble 
111a			 ;               ret 
111a			; 
111a			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
111a			; A valid hexadecimal digit is denoted by a set C flag. 
111a			; 
111a			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
111a			;                ret     nc              ; Yes 
111a			;                cp      '0'             ; Less than '0'? 
111a			;                jr      nc, is_hex_1    ; No, continue 
111a			;                ccf                     ; Complement carry (i.e. clear it) 
111a			;                ret 
111a			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
111a			;                ret     c               ; Yes 
111a			;                cp      'A'             ; Less than 'A'? 
111a			;                jr      nc, is_hex_2    ; No, continue 
111a			;                ccf                     ; Yes - clear carry and return 
111a			;                ret 
111a			;is_hex_2        scf                     ; Set carry 
111a			;                ret 
111a			; 
111a			; Convert a single character contained in A to upper case: 
111a			; 
111a fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
111c d8			                ret     c 
111d fe 7b		                cp      'z' + 1         ; > 'z'? 
111f d0			                ret     nc              ; Nothing to do, either 
1120 e6 5f		                and     $5f             ; Convert to upper case 
1122 c9			                ret 
1123			 
1123			 
1123			to_lower: 
1123			 
1123			   ; if char is in [A-Z] make it lower case 
1123			 
1123			   ; enter : a = char 
1123			   ; exit  : a = lower case char 
1123			   ; uses  : af 
1123			 
1123 fe 41		   cp 'A' 
1125 d8			   ret c 
1126			    
1126 fe 5b		   cp 'Z'+1 
1128 d0			   ret nc 
1129			    
1129 f6 20		   or $20 
112b c9			   ret 
112c			 
112c			; 
112c			; Expects a hexadecimal digit (upper case!) in A and returns the 
112c			; corresponding value in A. 
112c			; 
112c fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
112e 38 02		                jr      c, nibble2val_1 ; Yes 
1130 d6 07		                sub     7               ; Adjust for A-F 
1132 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1134 e6 0f		                and     $f              ; Only return lower 4 bits 
1136 c9			                ret 
1137			; 
1137			; Print_nibble prints a single hex nibble which is contained in the lower  
1137			; four bits of A: 
1137			; 
1137			;print_nibble    push    af              ; We won't destroy the contents of A 
1137			;                and     $f              ; Just in case... 
1137			;                add     a, '0'             ; If we have a digit we are done here. 
1137			;                cp      '9' + 1         ; Is the result > 9? 
1137			;                jr      c, print_nibble_1 
1137			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1137			;print_nibble_1  call    putc            ; Print the nibble and 
1137			;                pop     af              ; restore the original value of A 
1137			;                ret 
1137			;; 
1137			;; Send a CR/LF pair: 
1137			; 
1137			;crlf            push    af 
1137			;                ld      a, cr 
1137			;                call    putc 
1137			;                ld      a, lf 
1137			;                call    putc 
1137			;                pop     af 
1137			;                ret 
1137			; 
1137			; Print_word prints the four hex digits of a word to the serial line. The  
1137			; word is expected to be in HL. 
1137			; 
1137			;print_word      push    hl 
1137			;                push    af 
1137			;                ld      a, h 
1137			;                call    print_byte 
1137			;                ld      a, l 
1137			;                call    print_byte 
1137			;                pop     af 
1137			;                pop     hl 
1137			;                ret 
1137			; 
1137			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1137			; The byte to be printed is expected to be in A. 
1137			; 
1137			;print_byte      push    af              ; Save the contents of the registers 
1137			;                push    bc 
1137			;                ld      b, a 
1137			;                rrca 
1137			;                rrca 
1137			;                rrca 
1137			;                rrca 
1137			;                call    print_nibble    ; Print high nibble 
1137			;                ld      a, b 
1137			;                call    print_nibble    ; Print low nibble 
1137			;                pop     bc              ; Restore original register contents 
1137			;                pop     af 
1137			;                ret 
1137			 
1137			 
1137			 
1137			 
1137			 
1137			fourehexhl:  
1137 7e				ld a,(hl) 
1138 cd e6 10			call atohex 
113b cb 3f				SRL A 
113d cb 3f				SRL A 
113f cb 3f				SRL A 
1141 cb 3f				SRL A 
1143 47				ld b, a 
1144 23				inc hl 
1145 7e				ld a,(hl) 
1146 23				inc hl 
1147 cd e6 10			call atohex 
114a 80				add b 
114b 57				ld d,a 
114c 7e				ld a,(hl) 
114d cd e6 10			call atohex 
1150 cb 3f				SRL A 
1152 cb 3f				SRL A 
1154 cb 3f				SRL A 
1156 cb 3f				SRL A 
1158 47				ld b, a 
1159 23				inc hl 
115a 7e				ld a,(hl) 
115b 23				inc hl 
115c cd e6 10			call atohex 
115f 80				add b 
1160 5f				ld e, a 
1161 d5				push de 
1162 e1				pop hl 
1163 c9				ret 
1164			 
1164			; pass hl. returns z set if the byte at hl is a digit 
1164			;isdigithl:  
1164			;	push bc 
1164			;	ld a,(hl) 
1164			;	cp ':' 
1164			;	jr nc, .isdf 		; > 
1164			;	cp '0' 
1164			;	jr c, .isdf		; < 
1164			; 
1164			;	; TODO find a better way to set z 
1164			; 
1164			;	ld b,a 
1164			;	cp b 
1164			;	pop bc 
1164			;	ret 
1164			; 
1164			;.isdf:	; not digit so clear z 
1164			; 
1164			;	; TODO find a better way to unset z 
1164			; 
1164			;	ld b,a 
1164			;	inc b 
1164			;	cp b 
1164			; 
1164			;	pop bc 
1164			;	ret 
1164				 
1164				 
1164			 
1164			 
1164			; pass hl as the four byte address to load 
1164			 
1164			get_word_hl:  
1164 e5				push hl 
1165 cd 04 11			call get_byte 
1168				 
1168 47				ld b, a 
1169			 
1169 e1				pop hl 
116a 23				inc hl 
116b 23				inc hl 
116c			 
116c			; TODO not able to handle a-f  
116c 7e				ld a,(hl) 
116d			;	;cp ':' 
116d			;	cp 'g' 
116d			;	jr nc, .single_byte_hl 		; > 
116d			;	cp 'G' 
116d			;	jr nc, .single_byte_hl 		; > 
116d			;	cp '0' 
116d			;	jr c, .single_byte_hl		; < 
116d			 
116d				;call isdigithl 
116d fe 00			cp 0 
116f 28 06			jr z, .single_byte_hl 
1171			 
1171			.getwhln:   ; hex word so get next byte 
1171			 
1171 cd 04 11			call get_byte 
1174 6f				ld l, a 
1175 60				ld h,b 
1176 c9				ret 
1177 68			.single_byte_hl:   ld l,b 
1178 26 00				ld h,0 
117a c9					ret 
117b			 
117b			 
117b			 
117b			 
117b 21 36 19			ld hl,asc+1 
117e			;	ld a, (hl) 
117e			;	call nibble2val 
117e cd 04 11			call get_byte 
1181			 
1181			;	call fourehexhl 
1181 32 ff e2			ld (scratch+52),a 
1184				 
1184 21 fd e2			ld hl,scratch+50 
1187 22 ee e5			ld (os_cur_ptr),hl 
118a			 
118a c9				ret 
118b			 
118b			 
118b			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
118b			 
118b			; Decimal Unsigned Version 
118b			 
118b			;Number in a to decimal ASCII 
118b			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
118b			;Example: display a=56 as "056" 
118b			;input: a = number 
118b			;Output: a=0,value of a in the screen 
118b			;destroys af,bc (don't know about hl and de) 
118b			DispAToASCII: 
118b 0e 9c			ld	c,-100 
118d cd 97 11			call	.Na1 
1190 0e f6			ld	c,-10 
1192 cd 97 11			call	.Na1 
1195 0e ff			ld	c,-1 
1197 06 2f		.Na1:	ld	b,'0'-1 
1199 04			.Na2:	inc	b 
119a 81				add	a,c 
119b 38 fc			jr	c,.Na2 
119d 91				sub	c		;works as add 100/10/1 
119e f5				push af		;safer than ld c,a 
119f 78				ld	a,b		;char is in b 
11a0			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
11a0 f1				pop af		;safer than ld a,c 
11a1 c9				ret 
11a2			 
11a2			; Decimal Signed Version 
11a2			 
11a2			; DispA 
11a2			; -------------------------------------------------------------- 
11a2			; Converts a signed integer value to a zero-terminated ASCII 
11a2			; string representative of that value (using radix 10). 
11a2			; -------------------------------------------------------------- 
11a2			; INPUTS: 
11a2			;     HL     Value to convert (two's complement integer). 
11a2			;     DE     Base address of string destination. (pointer). 
11a2			; -------------------------------------------------------------- 
11a2			; OUTPUTS: 
11a2			;     None 
11a2			; -------------------------------------------------------------- 
11a2			; REGISTERS/MEMORY DESTROYED 
11a2			; AF HL 
11a2			; -------------------------------------------------------------- 
11a2			 
11a2			;DispHLToASCII: 
11a2			;   push    de 
11a2			;   push    bc 
11a2			; 
11a2			;; Detect sign of HL. 
11a2			;    bit    7, h 
11a2			;    jr     z, ._DoConvert 
11a2			; 
11a2			;; HL is negative. Output '-' to string and negate HL. 
11a2			;    ld     a, '-' 
11a2			;    ld     (de), a 
11a2			;    inc    de 
11a2			; 
11a2			;; Negate HL (using two's complement) 
11a2			;    xor    a 
11a2			;    sub    l 
11a2			;    ld     l, a 
11a2			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
11a2			;    sbc    a, h 
11a2			;    ld     h, a 
11a2			; 
11a2			;; Convert HL to digit characters 
11a2			;._DoConvert: 
11a2			;    ld     b, 0     ; B will count character length of number 
11a2			;-   ld     a, 10 
11a2			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
11a2			;    push   af 
11a2			;    inc    b 
11a2			;    ld     a, h 
11a2			;    or     l 
11a2			;    jr     nz, - 
11a2			; 
11a2			;; Retrieve digits from stack 
11a2			;-   pop    af 
11a2			;    or     $30 
11a2			;    ld     (de), a 
11a2			;    inc    de 
11a2			;    djnz   - 
11a2			; 
11a2			;; Terminate string with NULL 
11a2			;    xor    a 
11a2			;    ld     (de), a 
11a2			; 
11a2			;    pop    bc 
11a2			;    pop    de 
11a2			;    ret 
11a2			 
11a2			;Comments 
11a2			; 
11a2			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
11a2			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
11a2			;    Note that the output string will not be fixed-width. 
11a2			; 
11a2			;Example Usage 
11a2			; 
11a2			;    ld    hl, -1004 
11a2			;    ld    de, OP1 
11a2			;    call  DispA 
11a2			;    ld    hl, OP1 
11a2			;    syscall  PutS 
11a2			 
11a2			 
11a2			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11a2			 
11a2			 
11a2			;Converts an ASCII string to an unsigned 16-bit integer 
11a2			;Quits when it reaches a non-decimal digit 
11a2			 
11a2			string_to_uint16: 
11a2			atoui_16: 
11a2			;Input: 
11a2			;     DE points to the string 
11a2			;Outputs: 
11a2			;     HL is the result 
11a2			;     A is the 8-bit value of the number 
11a2			;     DE points to the byte after the number 
11a2			;Destroys: 
11a2			;     BC 
11a2			;       if the string is non-empty, BC is HL/10 
11a2			;Size:  24 bytes 
11a2			;Speed: 42+d(104+{0,9}) 
11a2			;       d is the number of digits in the number 
11a2			;       max is 640 cycles for a 5 digit number 
11a2			;Assuming no leading zeros: 
11a2			;1 digit:  146cc 
11a2			;2 digit:  250cc 
11a2			;3 digit:  354cc or 363cc (avg: 354.126cc) 
11a2			;4 digit:  458cc or 467cc (avg: 458.27cc) 
11a2			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
11a2			;avg: 544.81158447265625cc (544+13297/16384) 
11a2			;=============================================================== 
11a2 21 00 00		  ld hl,0 
11a5			.u16a: 
11a5 1a			  ld a,(de) 
11a6 d6 30		  sub 30h 
11a8 fe 0a		  cp 10 
11aa d0			  ret nc 
11ab 13			  inc de 
11ac 44			  ld b,h 
11ad 4d			  ld c,l 
11ae 29			  add hl,hl 
11af 29			  add hl,hl 
11b0 09			  add hl,bc 
11b1 29			  add hl,hl 
11b2 85			  add a,l 
11b3 6f			  ld l,a 
11b4 30 ef		  jr nc,.u16a 
11b6 24			  inc h 
11b7 c3 a5 11		  jp .u16a 
11ba			 
11ba			 
11ba			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11ba			 
11ba			;written by Zeda 
11ba			;Converts a 16-bit unsigned integer to an ASCII string. 
11ba			 
11ba			uitoa_16: 
11ba			;Input: 
11ba			;   DE is the number to convert 
11ba			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
11ba			;Output: 
11ba			;   HL points to the null-terminated ASCII string 
11ba			;      NOTE: This isn't necessarily the same as the input HL. 
11ba d5			  push de 
11bb c5			  push bc 
11bc f5			  push af 
11bd eb			  ex de,hl 
11be			 
11be 01 f0 d8		  ld bc,-10000 
11c1 3e 2f		  ld a,'0'-1 
11c3 3c			  inc a 
11c4 09			  add hl,bc  
11c5 38 fc		   jr c,$-2 
11c7 12			  ld (de),a 
11c8 13			  inc de 
11c9			 
11c9 01 e8 03		  ld bc,1000 
11cc 3e 3a		  ld a,'9'+1 
11ce 3d			  dec a  
11cf 09			  add hl,bc  
11d0 30 fc		   jr nc,$-2 
11d2 12			  ld (de),a 
11d3 13			  inc de 
11d4			 
11d4 01 9c ff		  ld bc,-100 
11d7 3e 2f		  ld a,'0'-1 
11d9 3c			  inc a  
11da 09			  add hl,bc  
11db 38 fc		   jr c,$-2 
11dd 12			  ld (de),a 
11de 13			  inc de 
11df			 
11df 7d			  ld a,l 
11e0 26 3a		  ld h,'9'+1 
11e2 25			  dec h  
11e3 c6 0a		  add a,10  
11e5 30 fb		   jr nc,$-3 
11e7 c6 30		  add a,'0' 
11e9 eb			  ex de,hl 
11ea 72			  ld (hl),d 
11eb 23			  inc hl 
11ec 77			  ld (hl),a 
11ed 23			  inc hl 
11ee 36 00		  ld (hl),0 
11f0			 
11f0			;Now strip the leading zeros 
11f0 0e fa		  ld c,-6 
11f2 09			  add hl,bc 
11f3 3e 30		  ld a,'0' 
11f5 23			  inc hl  
11f6 be			  cp (hl)  
11f7 28 fc		  jr z,$-2 
11f9			 
11f9			;Make sure that the string is non-empty! 
11f9 7e			  ld a,(hl) 
11fa b7			  or a 
11fb 20 01		  jr nz,.atoub 
11fd 2b			  dec hl 
11fe			.atoub: 
11fe			 
11fe f1			  pop af 
11ff c1			  pop bc 
1200 d1			  pop de 
1201 c9			  ret 
1202			 
1202			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1202			 
1202			toUpper: 
1202			;A is the char. 
1202			;If A is a lowercase letter, this sets it to the matching uppercase 
1202			;18cc or 30cc or 41cc 
1202			;avg: 26.75cc 
1202 fe 61		  cp 'a' 
1204 d8			  ret c 
1205 fe 7b		  cp 'z'+1 
1207 d0			  ret nc 
1208 d6 20		  sub 'a'-'A' 
120a c9			  ret 
120b			 
120b			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
120b			 
120b			; String Length 
120b			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
120b			 
120b			; Get the length of the null-terminated string starting at $8000 hl 
120b			;    LD     HL, $8000 
120b			 
120b			strlenz: 
120b			 
120b af			    XOR    A               ; Zero is the value we are looking for. 
120c 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
120d 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
120e			                           ; 65, 536 bytes (the entire addressable memory space). 
120e ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1210			 
1210			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1210 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1211 6f			    LD     L, A             ; number of bytes 
1212 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1214 2b			    DEC    HL              ; Compensate for null. 
1215 c9				ret 
1216			 
1216			; Get the length of the A terminated string starting at $8000 hl 
1216			;    LD     HL, $8000 
1216			 
1216			strlent: 
1216			 
1216			                  ; A is the value we are looking for. 
1216 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1218 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
121a			                           ; 65, 536 bytes (the entire addressable memory space). 
121a ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
121c			 
121c			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
121c 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
121e 2e 00		    LD     L, 0             ; number of bytes 
1220 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1222 2b			    DEC    HL              ; Compensate for null. 
1223 c9				ret 
1224			 
1224			 
1224			;Comparing Strings 
1224			 
1224			;IN    HL     Address of string1. 
1224			;      DE     Address of string2. 
1224			 
1224			; doc given but wrong??? 
1224			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1224			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1224			; tested 
1224			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1224			 
1224			strcmp_old: 
1224 e5			    PUSH   HL 
1225 d5			    PUSH   DE 
1226			 
1226 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1227 be			    CP     (HL)            ; (want to minimize work). 
1228 38 01		    JR     C, Str1IsBigger 
122a 7e			    LD     A, (HL) 
122b			 
122b			Str1IsBigger: 
122b 4f			    LD     C, A             ; Put length in BC 
122c 06 00		    LD     B, 0 
122e 13			    INC    DE              ; Increment pointers to meat of string. 
122f 23			    INC    HL 
1230			 
1230			CmpLoop: 
1230 1a			    LD     A, (DE)          ; Compare bytes. 
1231 ed a1		    CPI 
1233 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1235 13			    INC    DE              ; Update pointer. 
1236 ea 30 12		    JP     PE, CmpLoop 
1239			 
1239 d1			    POP    DE 
123a e1			    POP    HL 
123b 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
123c be			    CP     (HL) 
123d c9			    RET 
123e			 
123e			NoMatch: 
123e 2b			    DEC    HL 
123f be			    CP     (HL)            ; Compare again to affect carry. 
1240 d1			    POP    DE 
1241 e1			    POP    HL 
1242 c9			    RET 
1243			 
1243			;; test strmp 
1243			; 
1243			;ld de, .str1 
1243			;ld hl, .str2 
1243			;call strcmp 
1243			;jr z, .z1 
1243			;;this 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "NZ1" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			;.z1: 
1243			; 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "ZZ1" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			; 
1243			;ld de, .str1 
1243			;ld hl, .str1 
1243			;call strcmp 
1243			;jr z, .z2 
1243			;;this 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "NZ2" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			;.z2: 
1243			; 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "ZZ2" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			; 
1243			;ld de, .str1 
1243			;ld hl, .str2 
1243			;call strcmp 
1243			;jr c, .c1 
1243			; 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "Nc1" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			;.c1: 
1243			;;this 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "cc1" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			; 
1243			;ld de, .str1 
1243			;ld hl, .str1 
1243			;call strcmp 
1243			;jr c, .c2 
1243			;;this 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "Nc2" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			;.c2: 
1243			; 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "cc2" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			;	NEXTW 
1243			;.str1:   db "string1",0 
1243			;.str2:   db "string2",0 
1243			 
1243			; only care about direct match or not 
1243			; hl and de strings 
1243			; zero set if the same 
1243			 
1243			strcmp: 
1243 1a				ld a, (de) 
1244 be				cp (hl) 
1245 28 02			jr z, .ssame 
1247 b7				or a 
1248 c9				ret 
1249			 
1249			.ssame:  
1249 fe 00			cp 0 
124b c8				ret z 
124c			 
124c 23				inc hl 
124d 13				inc de 
124e 18 f3			jr strcmp 
1250				 
1250				 
1250			 
1250			 
1250			 
1250			 
1250			; eof 
1250			 
1250			 
1250			 
1250			 
1250			 
1250			 
# End of file firmware_strings.asm
1250			include "firmware_memory.asm"   ; malloc and free  
1250			 
1250			if DEBUG_FORTH_MALLOC_HIGH 
1250			.mallocsize: db "Wants malloc >256",0 
1250			.mallocasize: db "MALLOC gives >256",0 
1250			.malloczero: db "MALLOC gives zero",0 
1250			 
1250			malloc_guard_zerolen: 
1250				push hl 
1250				push de 
1250				push af 
1250			 
1250				ld de, 0 
1250			        call cmp16 
1250				jr nz, .lowalloz 
1250			 
1250				push hl 
1250				push de 
1250					ld hl, display_fb0 
1250					ld (display_fb_active), hl 
1250				call clear_display 
1250				ld a, 0 
1250				ld de, .malloczero 
1250				call str_at_display 
1250				call update_display 
1250				call delay1s 
1250				call delay1s 
1250				ld a, 0 
1250				ld (os_view_disable), a 
1250			 
1250				pop de 
1250				pop hl 
1250			 
1250				 
1250			 
1250				CALLMONITOR 
1250			.lowalloz: 
1250			 
1250			 
1250				pop af 
1250				pop de 
1250				pop hl 
1250			ret 
1250			 
1250			malloc_guard_entry: 
1250				push hl 
1250				push de 
1250				push af 
1250			 
1250			 	or a      ;clear carry flag 
1250				push hl 
1250				ld de, 255 
1250				sbc hl, de 
1250				jr c, .lowalloc 
1250			 
1250				push de 
1250					ld hl, display_fb0 
1250					ld (display_fb_active), hl 
1250				call clear_display 
1250				ld a, 0 
1250				ld de, .mallocsize 
1250				call str_at_display 
1250				call update_display 
1250				call delay1s 
1250				call delay1s 
1250				ld a, 0 
1250				ld (os_view_disable), a 
1250			 
1250				pop de 
1250				pop hl 
1250			 
1250				 
1250			 
1250				CALLMONITOR 
1250				jr .lowdone 
1250			.lowalloc: 
1250			 
1250			 
1250				pop hl 
1250			.lowdone:	pop af 
1250				pop de 
1250				pop hl 
1250			ret 
1250			 
1250			malloc_guard_exit: 
1250				push hl 
1250				push de 
1250				push af 
1250			 
1250			 	or a      ;clear carry flag 
1250				push hl 
1250				ld de, 255 
1250				sbc hl, de 
1250				jr c, .lowallocx 
1250			 
1250				push de 
1250					ld hl, display_fb0 
1250					ld (display_fb_active), hl 
1250				call clear_display 
1250				ld a, 0 
1250				ld de, .mallocasize 
1250				call str_at_display 
1250				call update_display 
1250				call delay1s 
1250				call delay1s 
1250				ld a, 0 
1250				ld (os_view_disable), a 
1250				pop de 
1250				pop hl 
1250			 
1250				CALLMONITOR 
1250				jr .lowdonex 
1250			.lowallocx: 
1250			 
1250				pop hl 
1250			.lowdonex:	pop af 
1250				pop de 
1250				pop hl 
1250			ret 
1250			endif 
1250			 
1250			if MALLOC_2 
1250			; Z80 Malloc and Free Functions 
1250			 
1250			; Malloc Function: 
1250			; Input: 
1250			;   HL: Size of block to allocate 
1250			; Output: 
1250			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1250			 
1250			malloc: 
1250				 
1250			if DEBUG_FORTH_MALLOC_HIGH 
1250			call malloc_guard_entry 
1250			endif 
1250			 
1250			 
1250			 
1250			 
1250					if DEBUG_FORTH_MALLOC 
1250						DMARK "mal" 
1250						CALLMONITOR 
1250					endif 
1250			    push af            ; Save AF register 
1250			    ld a, l            ; Load low byte of size into A 
1250			    or h               ; Check if size is zero 
1250			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1250			 
1250			    ; Allocate memory 
1250			    ld hl, (heap_start) ; Load start of heap into HL 
1250					if DEBUG_FORTH_MALLOC 
1250						DMARK "ma1" 
1250						CALLMONITOR 
1250					endif 
1250			    call malloc_internal ; Call internal malloc function 
1250			    pop af             ; Restore AF register 
1250			if DEBUG_FORTH_MALLOC_HIGH 
1250			call malloc_guard_exit 
1250			call malloc_guard_zerolen 
1250			endif 
1250			    ret                ; Return 
1250			 
1250			; Free Function: 
1250			; Input: 
1250			;   HL: Pointer to memory block to free 
1250			; Output: 
1250			;   None 
1250			 
1250			free: 
1250			    push af            ; Save AF register 
1250			    ld a, l            ; Load low byte of pointer into A 
1250			    or h               ; Check if pointer is NULL 
1250			    jp z, free_exit    ; If pointer is NULL, exit 
1250			 
1250			    ; Free memory 
1250			    ld hl, (heap_start) ; Load start of heap into HL 
1250			    call free_internal  ; Call internal free function 
1250			    pop af             ; Restore AF register 
1250			    ret                ; Return 
1250			 
1250			; Internal Malloc Function: 
1250			; Input: 
1250			;   HL: Size of block to allocate 
1250			; Output: 
1250			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1250			 
1250			malloc_internal: 
1250			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1250			    add hl, bc         ; Add management overhead to requested size 
1250			    ex de, hl          ; Save total size in DE, and keep it in HL 
1250					if DEBUG_FORTH_MALLOC 
1250						DMARK "ma2" 
1250						CALLMONITOR 
1250					endif 
1250			 
1250			    ; Search for free memory block 
1250			    ld de, (heap_end)  ; Load end of heap into DE 
1250			    ld bc, 0           ; Initialize counter 
1250			 
1250					if DEBUG_FORTH_MALLOC 
1250						DMARK "ma2" 
1250						CALLMONITOR 
1250					endif 
1250			malloc_search_loop: 
1250			    ; Check if current block is free 
1250			    ld a, (hl)         ; Load current block's status (free or used) 
1250			    cp 0               ; Compare with zero (free) 
1250			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1250			 
1250			    ; Check if current block is large enough 
1250			    ld a, (hl+1)       ; Load high byte of block size 
1250			    cp l               ; Compare with low byte of requested size 
1250			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1250			 
1250			    ld a, (hl+2)       ; Load low byte of block size 
1250			    cp h               ; Compare with high byte of requested size 
1250			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1250			 
1250			    ; Mark block as used 
1250			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1250			 
1250			    ; Calculate remaining space in block 
1250			    ld bc, 0           ; Clear BC 
1250			    add hl, bc         ; Increment HL to point to start of data block 
1250			    add hl, de         ; HL = HL + DE (total size) 
1250			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1250			    add hl, bc         ; Add management overhead to start of data block 
1250			 
1250			    ; Save pointer to allocated block in HL 
1250			if DEBUG_FORTH_MALLOC_HIGH 
1250						DMARK "ma5" 
1250			call malloc_guard_exit 
1250			call malloc_guard_zerolen 
1250			endif 
1250			    ret 
1250			 
1250			malloc_skip_block_check: 
1250			    ; Move to the next block 
1250			    ld bc, 3           ; Size of management overhead 
1250			    add hl, bc         ; Move to the next block 
1250			    inc de             ; Increment counter 
1250			 
1250			    ; Check if we have reached the end of heap 
1250			    ld a, e            ; Load low byte of heap end address 
1250			    cp (hl)            ; Compare with low byte of current address 
1250			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1250			    ld a, d            ; Load high byte of heap end address 
1250			    cp 0               ; Check if it's zero (end of memory) 
1250			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1250			 
1250			    ; If we reached here, allocation failed 
1250			    xor a              ; Set result to NULL 
1250			if DEBUG_FORTH_MALLOC_HIGH 
1250						DMARK "ma6" 
1250			call malloc_guard_exit 
1250			call malloc_guard_zerolen 
1250			endif 
1250			    ret 
1250			malloc_exit: 
1250			if DEBUG_FORTH_MALLOC_HIGH 
1250						DMARK "ma7" 
1250			call malloc_guard_exit 
1250			call malloc_guard_zerolen 
1250			endif 
1250			    ret 
1250			 
1250			; Internal Free Function: 
1250			; Input: 
1250			;   HL: Pointer to memory block to free 
1250			; Output: 
1250			;   None 
1250			 
1250			free_internal: 
1250			    ld de, (heap_start) ; Load start of heap into DE 
1250			    ld bc, 0            ; Initialize counter 
1250			 
1250			free_search_loop: 
1250			    ; Check if current block contains the pointer 
1250			    ld a, l             ; Load low byte of pointer 
1250			    cp (hl+1)           ; Compare with high byte of current block's address 
1250			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1250			    ld a, h             ; Load high byte of pointer 
1250			    cp (hl+2)           ; Compare with low byte of current block's address 
1250			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1250			 
1250			    ; Mark block as free 
1250			    ld (hl), 0          ; Set status byte to indicate free block 
1250			    ret                 ; Return 
1250			 
1250			free_skip_block_check: 
1250			    ; Move to the next block 
1250			    ld bc, 3            ; Size of management overhead 
1250			    add hl, bc          ; Move to the next block 
1250			    inc de              ; Increment counter 
1250			 
1250			    ; Check if we have reached the end of heap 
1250			    ld a, e             ; Load low byte of heap end address 
1250			    cp (hl)             ; Compare with low byte of current address 
1250			    jr nz, free_search_loop  ; If not equal, continue searching 
1250			    ld a, d             ; Load high byte of heap end address 
1250			    cp 0                ; Check if it's zero (end of memory) 
1250			    jr nz, free_search_loop  ; If not zero, continue searching 
1250			 
1250			    ; If we reached here, pointer is not found in heap 
1250			    ret 
1250			 
1250			free_exit: 
1250			    ret                 ; Return 
1250			 
1250			; Define heap start and end addresses 
1250			;heap_start:    .dw 0xC000   ; Start of heap 
1250			;heap_end:      .dw 0xE000   ; End of heap 
1250			 
1250			endif 
1250			 
1250			 
1250			if MALLOC_1 
1250			 
1250			 
1250			 
1250			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1250			 
1250			;moved to firmware.asm 
1250			;heap_start        .equ  0x9000      ; Starting address of heap 
1250			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1250			 
1250			;      .org 0 
1250			;      jp    main 
1250			 
1250			 
1250			;      .org  0x100 
1250			;main: 
1250			;      ld    HL, 0x8100 
1250			;      ld    SP, HL 
1250			; 
1250			;      call  heap_init 
1250			; 
1250			;      ; Make some allocations 
1250			;      ld    HL, 12 
1250			;      call  malloc            ; Allocates 0x9004 
1250			; 
1250			;      ld    HL, 12 
1250			;      call  malloc            ; Allocates 0x9014 
1250			; 
1250			;      ld    HL, 12 
1250			;      call  malloc            ; Allocates 0x9024 
1250			; 
1250			;      ; Free some allocations 
1250			;      ld    HL, 0x9014 
1250			;      call  free 
1250			; 
1250			;      ld    HL, 0x9004 
1250			;      call  free 
1250			; 
1250			;      ld    HL, 0x9024 
1250			;      call  free 
1250			; 
1250			; 
1250			;      halt 
1250			 
1250			 
1250			;------------------------------------------------------------------------------ 
1250			;     heap_init                                                               : 
1250			;                                                                             : 
1250			; Description                                                                 : 
1250			;     Initialise the heap and make it ready for malloc and free operations.   : 
1250			;                                                                             : 
1250			;     The heap is maintained as a linked list, starting with an initial       : 
1250			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1250			;     the first free block in the heap. Each block then points to the next    : 
1250			;     free block within the heap, and the free list ends at the first block   : 
1250			;     with a null pointer to the next free block.                             : 
1250			;                                                                             : 
1250			; Parameters                                                                  : 
1250			;     Inputs are compile-time only. Two defines which specify the starting    : 
1250			;     address of the heap and its size are required, along with a memory      : 
1250			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1250			;     principally stores a pointer to the first free block in the heap.       : 
1250			;                                                                             : 
1250			; Returns                                                                     : 
1250			;     Nothing                                                                 : 
1250			;------------------------------------------------------------------------------ 
1250			heap_init: 
1250 e5			      push  HL 
1251			 
1251			      ; Initialise free list struct 
1251 21 cd 61		      ld    HL, heap_start 
1254 22 c8 61		      ld    (free_list), HL 
1257 21 00 00		      ld    HL, 0 
125a 22 ca 61		      ld    (free_list+2), HL 
125d			 
125d			      ; Insert first free block at bottom of heap, consumes entire heap 
125d 21 ad e2		      ld    HL, heap_start+heap_size-4 
1260 22 cd 61		      ld    (heap_start), HL        ; Next block (end of free list) 
1263 21 e0 80		      ld    HL, heap_size-4 
1266 22 cf 61		      ld    (heap_start+2), HL      ; Block size 
1269			 
1269			      ; Insert end of free list block at top of heap - two null words will 
1269			      ; terminate the free list 
1269 21 00 00		      ld    HL, 0 
126c 22 af e2		      ld    (heap_start+heap_size-2), HL 
126f 22 ad e2		      ld    (heap_start+heap_size-4), HL 
1272			 
1272 e1			      pop   HL 
1273			 
1273 c9			      ret 
1274			 
1274			 
1274			;------------------------------------------------------------------------------ 
1274			;     malloc                                                                  : 
1274			;                                                                             : 
1274			; Description                                                                 : 
1274			;     Allocates the wanted space from the heap and returns the address of the : 
1274			;     first useable byte of the allocation.                                   : 
1274			;                                                                             : 
1274			;     Allocations can happen in one of two ways:                              : 
1274			;                                                                             : 
1274			;     1. A free block may be found which is the exact size wanted. In this    : 
1274			;        case the block is removed from the free list and retuedn to the      : 
1274			;        caller.                                                              : 
1274			;     2. A free block may be found which is larger than the size wanted. In   : 
1274			;        this case, the larger block is split into two. The first portion of  : 
1274			;        this block will become the requested space by the malloc call and    : 
1274			;        is returned to the caller. The second portion becomes a new free     : 
1274			;        block, and the free list is adjusted to maintain continuity via this : 
1274			;        newly created block.                                                 : 
1274			;                                                                             : 
1274			;     malloc does not set any initial value in the allocated space, the       : 
1274			;     caller is required to do this as required.                              : 
1274			;                                                                             : 
1274			;     This implementation of malloc uses the stack exclusively, and is        : 
1274			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1274			;     advisable to disable interrupts before calling malloc, and recommended  : 
1274			;     to avoid the use of malloc inside ISRs in general.                      : 
1274			;                                                                             : 
1274			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1274			;                                                                             : 
1274			; Parameters                                                                  : 
1274			;     HL  Number of bytes wanted                                              : 
1274			;                                                                             : 
1274			; Returns                                                                     : 
1274			;     HL  Address of the first useable byte of the allocation                 : 
1274			;                                                                             : 
1274			; Flags                                                                       : 
1274			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1274			;                                                                             : 
1274			; Stack frame                                                                 : 
1274			;       |             |                                                       : 
1274			;       +-------------+                                                       : 
1274			;       |     BC      |                                                       : 
1274			;       +-------------+                                                       : 
1274			;       |     DE      |                                                       : 
1274			;       +-------------+                                                       : 
1274			;       |     IX      |                                                       : 
1274			;       +-------------+                                                       : 
1274			;       |  prev_free  |                                                       : 
1274			;   +4  +-------------+                                                       : 
1274			;       |  this_free  |                                                       : 
1274			;   +2  +-------------+                                                       : 
1274			;       |  next_free  |                                                       : 
1274			;   +0  +-------------+                                                       : 
1274			;       |             |                                                       : 
1274			;                                                                             : 
1274			;------------------------------------------------------------------------------ 
1274			 
1274			 
1274			;malloc: 
1274			; 
1274			;	SAVESP ON 1 
1274			; 
1274			;	call malloc_code 
1274			; 
1274			;	CHECKSP ON 1 
1274			;	ret 
1274			 
1274			 
1274			malloc: 
1274 c5			      push  BC 
1275 d5			      push  DE 
1276 dd e5		      push  IX 
1278			if DEBUG_FORTH_MALLOC_HIGH 
1278			call malloc_guard_entry 
1278			endif 
1278			 
1278					if DEBUG_FORTH_MALLOC 
1278						DMARK "mal" 
1278						CALLMONITOR 
1278					endif 
1278 7c			      ld    A, H                    ; Exit if no space requested 
1279 b5			      or    L 
127a ca 39 13		      jp    Z, malloc_early_exit 
127d			 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			; 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			 
127d			 
127d			 
127d			 
127d					if DEBUG_FORTH_MALLOC 
127d						DMARK "maA" 
127d						CALLMONITOR 
127d					endif 
127d			      ; Set up stack frame 
127d eb			      ex    DE, HL 
127e 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1281 39			      add   HL, SP 
1282 f9			      ld    SP, HL 
1283 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1287 dd 39		      add   IX, SP 
1289			 
1289			      ; Setup initial state 
1289 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
128c 19			      add   HL, DE 
128d			 
128d 44			      ld    B, H                    ; Move want to BC 
128e 4d			      ld    C, L 
128f			 
128f 21 c8 61		      ld    HL, free_list           ; Store prev_free ptr to stack 
1292 dd 75 04		      ld    (IX+4), L 
1295 dd 74 05		      ld    (IX+5), H 
1298			 
1298 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1299 23			      inc   HL 
129a 56			      ld    D, (HL) 
129b dd 73 02		      ld    (IX+2), E 
129e dd 72 03		      ld    (IX+3), D 
12a1 eb			      ex    DE, HL                  ; this_free ptr into HL 
12a2			 
12a2					if DEBUG_FORTH_MALLOC 
12a2						DMARK "maB" 
12a2						CALLMONITOR 
12a2					endif 
12a2			      ; Loop through free block list to find some space 
12a2			malloc_find_space: 
12a2 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
12a3 23			      inc   HL 
12a4 56			      ld    D, (HL) 
12a5			 
12a5 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
12a6 b3			      or    E 
12a7 ca 33 13		      jp    Z, malloc_no_space 
12aa			 
12aa dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
12ad dd 72 01		      ld    (IX+1), D 
12b0			 
12b0			      ; Does this block have enough space to make the allocation? 
12b0 23			      inc   HL                      ; Load free block size into DE 
12b1 5e			      ld    E, (HL) 
12b2 23			      inc   HL 
12b3 56			      ld    D, (HL) 
12b4			 
12b4 eb			      ex    DE, HL                  ; Check size of block against want 
12b5 b7			      or    A                       ; Ensure carry flag clear 
12b6 ed 42		      sbc   HL, BC 
12b8 e5			      push  HL                      ; Store the result for later (new block size) 
12b9			 
12b9 ca 08 13		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
12bc 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
12be			 
12be			      ; this_free block is not big enough, setup ptrs to test next free block 
12be e1			      pop   HL                      ; Discard previous result 
12bf			 
12bf dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
12c2 dd 66 03		      ld    H, (IX+3) 
12c5 dd 75 04		      ld    (IX+4), L 
12c8 dd 74 05		      ld    (IX+5), H 
12cb			 
12cb dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
12ce dd 66 01		      ld    H, (IX+1) 
12d1 dd 75 02		      ld    (IX+2), L 
12d4 dd 74 03		      ld    (IX+3), H 
12d7			 
12d7					if DEBUG_FORTH_MALLOC 
12d7						DMARK "MA>" 
12d7						CALLMONITOR 
12d7					endif 
12d7 18 c9		      jr    malloc_find_space 
12d9			 
12d9			      ; split a bigger block into two - requested size and remaining size 
12d9			malloc_alloc_split: 
12d9					if DEBUG_FORTH_MALLOC 
12d9						DMARK "MAs" 
12d9						CALLMONITOR 
12d9					endif 
12d9 eb			      ex    DE, HL                  ; Calculate address of new free block 
12da 2b			      dec   HL 
12db 2b			      dec   HL 
12dc 2b			      dec   HL 
12dd 09			      add   HL, BC 
12de			 
12de			      ; Create a new block and point it at next_free 
12de dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
12e1 dd 56 01		      ld    D, (IX+1) 
12e4			 
12e4 73			      ld    (HL), E                 ; Store next_free ptr into new block 
12e5 23			      inc   HL 
12e6 72			      ld    (HL), D 
12e7			 
12e7 d1			      pop   DE                      ; Store size of new block into new block 
12e8 23			      inc   HL 
12e9 73			      ld    (HL), E 
12ea 23			      inc   HL 
12eb 72			      ld    (HL), D 
12ec			 
12ec			      ; Update this_free ptr to point to new block 
12ec 2b			      dec   HL 
12ed 2b			      dec   HL 
12ee 2b			      dec   HL 
12ef			 
12ef dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
12f2 dd 56 03		      ld    D, (IX+3) 
12f5			 
12f5 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
12f8 dd 74 03		      ld    (IX+3), H 
12fb			 
12fb			      ; Modify this_free block to be allocation 
12fb eb			      ex    DE, HL 
12fc af			      xor   A                       ; Null the next block ptr of allocated block 
12fd 77			      ld    (HL), A 
12fe 23			      inc   HL 
12ff 77			      ld    (HL), A 
1300			 
1300 23			      inc   HL                      ; Store want size into allocated block 
1301 71			      ld    (HL), C 
1302 23			      inc   HL 
1303 70			      ld    (HL), B 
1304 23			      inc   HL 
1305 e5			      push  HL                      ; Address of allocation to return 
1306			 
1306 18 19		      jr    malloc_update_links 
1308			 
1308			malloc_alloc_fit: 
1308 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1309			 
1309					if DEBUG_FORTH_MALLOC 
1309						DMARK "MAf" 
1309						CALLMONITOR 
1309					endif 
1309			      ; Modify this_free block to be allocation 
1309 eb			      ex    DE, HL 
130a 2b			      dec   HL 
130b 2b			      dec   HL 
130c 2b			      dec   HL 
130d			 
130d af			      xor   A                       ; Null the next block ptr of allocated block 
130e 77			      ld    (HL), A 
130f 23			      inc   HL 
1310 77			      ld    (HL), A 
1311			 
1311 23			      inc   HL                      ; Store address of allocation to return 
1312 23			      inc   HL 
1313 23			      inc   HL 
1314 e5			      push  HL 
1315			 
1315			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1315 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1318 dd 66 01		      ld    H, (IX+1) 
131b			 
131b dd 75 02		      ld    (IX+2), L               ; HL to this_free 
131e dd 74 03		      ld    (IX+3), H 
1321			 
1321			 
1321			malloc_update_links: 
1321			      ; Update prev_free ptr to point to this_free 
1321 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1324 dd 66 05		      ld    H, (IX+5) 
1327			 
1327 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
132a dd 56 03		      ld    D, (IX+3) 
132d			 
132d 73			      ld    (HL), E                 ; this_free ptr into prev_free 
132e 23			      inc   HL 
132f 72			      ld    (HL), D 
1330			 
1330					if DEBUG_FORTH_MALLOC 
1330						DMARK "Mul" 
1330						CALLMONITOR 
1330					endif 
1330			      ; Clear the Z flag to indicate successful allocation 
1330 7a			      ld    A, D 
1331 b3			      or    E 
1332			 
1332 d1			      pop   DE                      ; Address of allocation 
1333					if DEBUG_FORTH_MALLOC 
1333						DMARK "MAu" 
1333						CALLMONITOR 
1333					endif 
1333			 
1333			malloc_no_space: 
1333 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1336 39			      add   HL, SP 
1337 f9			      ld    SP, HL 
1338			 
1338 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1339					if DEBUG_FORTH_MALLOC 
1339						DMARK "MAN" 
1339						CALLMONITOR 
1339					endif 
1339			 
1339			malloc_early_exit: 
1339					if DEBUG_FORTH_MALLOC 
1339						DMARK "MAx" 
1339						CALLMONITOR 
1339					endif 
1339 dd e1		      pop   IX 
133b d1			      pop   DE 
133c c1			      pop   BC 
133d			 
133d			if DEBUG_FORTH_MALLOC_HIGH 
133d			call malloc_guard_exit 
133d			call malloc_guard_zerolen 
133d			endif 
133d c9			      ret 
133e			 
133e			 
133e			;------------------------------------------------------------------------------ 
133e			;     free                                                                    : 
133e			;                                                                             : 
133e			; Description                                                                 : 
133e			;     Return the space pointed to by HL to the heap. HL must be an address as : 
133e			;     returned by malloc, otherwise the behaviour is undefined.               : 
133e			;                                                                             : 
133e			;     Where possible, directly adjacent free blocks will be merged together   : 
133e			;     into larger blocks to help ensure that the heap does not become         : 
133e			;     excessively fragmented.                                                 : 
133e			;                                                                             : 
133e			;     free does not clear or set any other value into the freed space, and    : 
133e			;     therefore its contents may be visible through subsequent malloc's. The  : 
133e			;     caller should clear the freed space as required.                        : 
133e			;                                                                             : 
133e			;     This implementation of free uses the stack exclusively, and is          : 
133e			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
133e			;     advisable to disable interrupts before calling free, and recommended    : 
133e			;     to avoid the use of free inside ISRs in general.                        : 
133e			;                                                                             : 
133e			;     NOTE: heap_init must be called before malloc and free can be used.      : 
133e			;                                                                             : 
133e			; Parameters                                                                  : 
133e			;     HL  Pointer to address of first byte of allocation to be freed          : 
133e			;                                                                             : 
133e			; Returns                                                                     : 
133e			;     Nothing                                                                 : 
133e			;                                                                             : 
133e			; Stack frame                                                                 : 
133e			;       |             |                                                       : 
133e			;       +-------------+                                                       : 
133e			;       |     BC      |                                                       : 
133e			;       +-------------+                                                       : 
133e			;       |     DE      |                                                       : 
133e			;       +-------------+                                                       : 
133e			;       |     IX      |                                                       : 
133e			;       +-------------+                                                       : 
133e			;       |  prev_free  |                                                       : 
133e			;   +2  +-------------+                                                       : 
133e			;       |  next_free  |                                                       : 
133e			;   +0  +-------------+                                                       : 
133e			;       |             |                                                       : 
133e			;                                                                             : 
133e			;------------------------------------------------------------------------------ 
133e			free: 
133e c5			      push  BC 
133f d5			      push  DE 
1340 dd e5		      push  IX 
1342			 
1342 7c			      ld    A, H                    ; Exit if ptr is null 
1343 b5			      or    L 
1344 ca 08 14		      jp    Z, free_early_exit 
1347			 
1347			      ; Set up stack frame 
1347 eb			      ex    DE, HL 
1348 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
134b 39			      add   HL, SP 
134c f9			      ld    SP, HL 
134d dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1351 dd 39		      add   IX, SP 
1353			 
1353			      ; The address in HL points to the start of the useable allocated space, 
1353			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1353			      ; address of the block itself. 
1353 eb			      ex    DE, HL 
1354 11 fc ff		      ld    DE, -4 
1357 19			      add   HL, DE 
1358			 
1358			      ; An allocated block must have a null next block pointer in it 
1358 7e			      ld    A, (HL) 
1359 23			      inc   HL 
135a b6			      or    (HL) 
135b c2 03 14		      jp    NZ, free_done 
135e			 
135e 2b			      dec   HL 
135f			 
135f 44			      ld    B, H                    ; Copy HL to BC 
1360 4d			      ld    C, L 
1361			 
1361			      ; Loop through the free list to find the first block with an address 
1361			      ; higher than the block being freed 
1361 21 c8 61		      ld    HL, free_list 
1364			 
1364			free_find_higher_block: 
1364 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1365 23			      inc   HL 
1366 56			      ld    D, (HL) 
1367 2b			      dec   HL 
1368			 
1368 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
136b dd 72 01		      ld    (IX+1), D 
136e dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1371 dd 74 03		      ld    (IX+3), H 
1374			 
1374 78			      ld    A, B                    ; Check if DE is greater than BC 
1375 ba			      cp    D                       ; Compare MSB first 
1376 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1378 30 04		      jr    NC, free_find_higher_block_skip 
137a 79			      ld    A, C 
137b bb			      cp    E                       ; Then compare LSB 
137c 38 08		      jr    C, free_found_higher_block 
137e			 
137e			free_find_higher_block_skip: 
137e 7a			      ld    A, D                    ; Reached the end of the free list? 
137f b3			      or    E 
1380 ca 03 14		      jp    Z, free_done 
1383			 
1383 eb			      ex    DE, HL 
1384			 
1384 18 de		      jr    free_find_higher_block 
1386			 
1386			free_found_higher_block: 
1386			      ; Insert freed block between prev and next free blocks 
1386 71			      ld    (HL), C                 ; Point prev free block to freed block 
1387 23			      inc   HL 
1388 70			      ld    (HL), B 
1389			 
1389 60			      ld    H, B                    ; Point freed block at next free block 
138a 69			      ld    L, C 
138b 73			      ld    (HL), E 
138c 23			      inc   HL 
138d 72			      ld    (HL), D 
138e			 
138e			      ; Check if the freed block is adjacent to the next free block 
138e 23			      inc   HL                      ; Load size of freed block into HL 
138f 5e			      ld    E, (HL) 
1390 23			      inc   HL 
1391 56			      ld    D, (HL) 
1392 eb			      ex    DE, HL 
1393			 
1393 09			      add   HL, BC                  ; Add addr of freed block and its size 
1394			 
1394 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1397 dd 56 01		      ld    D, (IX+1) 
139a			 
139a b7			      or    A                       ; Clear the carry flag 
139b ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
139d 20 22		      jr    NZ, free_check_adjacent_to_prev 
139f			 
139f			      ; Freed block is adjacent to next, merge into one bigger block 
139f eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
13a0 5e			      ld    E, (HL) 
13a1 23			      inc   HL 
13a2 56			      ld    D, (HL) 
13a3 e5			      push  HL                      ; Save ptr to next block for later 
13a4			 
13a4 60			      ld    H, B                    ; Store ptr from next block into freed block 
13a5 69			      ld    L, C 
13a6 73			      ld    (HL), E 
13a7 23			      inc   HL 
13a8 72			      ld    (HL), D 
13a9			 
13a9 e1			      pop   HL                      ; Restore ptr to next block 
13aa 23			      inc   HL                      ; Load size of next block into DE 
13ab 5e			      ld    E, (HL) 
13ac 23			      inc   HL 
13ad 56			      ld    D, (HL) 
13ae d5			      push  DE                      ; Save next block size for later 
13af			 
13af 60			      ld    H, B                    ; Load size of freed block into HL 
13b0 69			      ld    L, C 
13b1 23			      inc   HL 
13b2 23			      inc   HL 
13b3 5e			      ld    E, (HL) 
13b4 23			      inc   HL 
13b5 56			      ld    D, (HL) 
13b6 eb			      ex    DE, HL 
13b7			 
13b7 d1			      pop   DE                      ; Restore size of next block 
13b8 19			      add   HL, DE                  ; Add sizes of both blocks 
13b9 eb			      ex    DE, HL 
13ba			 
13ba 60			      ld    H, B                    ; Store new bigger size into freed block 
13bb 69			      ld    L, C 
13bc 23			      inc   HL 
13bd 23			      inc   HL 
13be 73			      ld    (HL), E 
13bf 23			      inc   HL 
13c0 72			      ld    (HL), D 
13c1			 
13c1			free_check_adjacent_to_prev: 
13c1			      ; Check if the freed block is adjacent to the prev free block 
13c1 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
13c4 dd 66 03		      ld    H, (IX+3) 
13c7			 
13c7 23			      inc   HL                      ; Size of prev free block into DE 
13c8 23			      inc   HL 
13c9 5e			      ld    E, (HL) 
13ca 23			      inc   HL 
13cb 56			      ld    D, (HL) 
13cc 2b			      dec   HL 
13cd 2b			      dec   HL 
13ce 2b			      dec   HL 
13cf			 
13cf 19			      add   HL, DE                  ; Add prev block addr and size 
13d0			 
13d0 b7			      or    A                       ; Clear the carry flag 
13d1 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
13d3 20 2e		      jr    NZ, free_done 
13d5			 
13d5			      ; Freed block is adjacent to prev, merge into one bigger block 
13d5 60			      ld    H, B                    ; Load next ptr from freed block into DE 
13d6 69			      ld    L, C 
13d7 5e			      ld    E, (HL) 
13d8 23			      inc   HL 
13d9 56			      ld    D, (HL) 
13da e5			      push  HL                      ; Save freed block ptr for later 
13db			 
13db dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
13de dd 66 03		      ld    H, (IX+3) 
13e1 73			      ld    (HL), E 
13e2 23			      inc   HL 
13e3 72			      ld    (HL), D 
13e4			 
13e4 e1			      pop   HL                      ; Restore freed block ptr 
13e5 23			      inc   HL                      ; Load size of freed block into DE 
13e6 5e			      ld    E, (HL) 
13e7 23			      inc   HL 
13e8 56			      ld    D, (HL) 
13e9 d5			      push  DE                      ; Save freed block size for later 
13ea			 
13ea dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
13ed dd 66 03		      ld    H, (IX+3) 
13f0 23			      inc   HL 
13f1 23			      inc   HL 
13f2 5e			      ld    E, (HL) 
13f3 23			      inc   HL 
13f4 56			      ld    D, (HL) 
13f5			 
13f5 e1			      pop   HL                      ; Add sizes of both blocks 
13f6 19			      add   HL, DE 
13f7 eb			      ex    DE, HL 
13f8			 
13f8 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
13fb dd 66 03		      ld    H, (IX+3) 
13fe 23			      inc   HL 
13ff 23			      inc   HL 
1400 73			      ld    (HL), E 
1401 23			      inc   HL 
1402 72			      ld    (HL), D 
1403			 
1403			free_done: 
1403 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1406 39			      add   HL, SP 
1407 f9			      ld    SP, HL 
1408			 
1408			free_early_exit: 
1408 dd e1		      pop   IX 
140a d1			      pop   DE 
140b c1			      pop   BC 
140c			 
140c c9			      ret 
140d			 
140d			; moved to firmware.asm 
140d			; 
140d			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
140d			;                  .dw   0 
140d			 
140d			 
140d			endif 
140d			 
140d			 
140d			if MALLOC_3 
140d			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
140d			;heap_start        .equ  0x9000      ; Starting address of heap 
140d			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
140d			; 
140d			 ;     .org 0 
140d			  ;    jp    main 
140d			; 
140d			; 
140d			 ;     .org  0x100 
140d			;main: 
140d			 ;     ld    HL, 0x8100 
140d			  ;    ld    SP, HL 
140d			; 
140d			;      call  heap_init 
140d			 
140d			      ; Make some allocations 
140d			;      ld    HL, 12 
140d			;      call  malloc            ; Allocates 0x9004 
140d			; 
140d			 ;     ld    HL, 12 
140d			;      call  malloc            ; Allocates 0x9014 
140d			 
140d			;      ld    HL, 12 
140d			;      call  malloc            ; Allocates 0x9024 
140d			 
140d			      ; Free some allocations 
140d			;      ld    HL, 0x9014 
140d			;      call  free 
140d			 
140d			;      ld    HL, 0x9004 
140d			;      call  free 
140d			; 
140d			;      ld    HL, 0x9024 
140d			;      call  free 
140d			 
140d			 
140d			 ;     halt 
140d			 
140d			 
140d			;------------------------------------------------------------------------------ 
140d			;     heap_init                                                               : 
140d			;                                                                             : 
140d			; Description                                                                 : 
140d			;     Initialise the heap and make it ready for malloc and free operations.   : 
140d			;                                                                             : 
140d			;     The heap is maintained as a linked list, starting with an initial       : 
140d			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
140d			;     the first free block in the heap. Each block then points to the next    : 
140d			;     free block within the heap, and the free list ends at the first block   : 
140d			;     with a null pointer to the next free block.                             : 
140d			;                                                                             : 
140d			; Parameters                                                                  : 
140d			;     Inputs are compile-time only. Two defines which specify the starting    : 
140d			;     address of the heap and its size are required, along with a memory      : 
140d			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
140d			;     principally stores a pointer to the first free block in the heap.       : 
140d			;                                                                             : 
140d			; Returns                                                                     : 
140d			;     Nothing                                                                 : 
140d			;------------------------------------------------------------------------------ 
140d			heap_init: 
140d			      push  HL 
140d			 
140d			      ; Initialise free list struct 
140d			      ld    HL, heap_start 
140d			      ld    (free_list), HL 
140d			      ld    HL, 0 
140d			      ld    (free_list+2), HL 
140d			 
140d			      ; Insert first free block at bottom of heap, consumes entire heap 
140d			      ld    HL, heap_start+heap_size-4 
140d			      ld    (heap_start), HL        ; Next block (end of free list) 
140d			      ld    HL, heap_size-4 
140d			      ld    (heap_start+2), HL      ; Block size 
140d			 
140d			      ; Insert end of free list block at top of heap - two null words will 
140d			      ; terminate the free list 
140d			      ld    HL, 0 
140d			      ld    (heap_start+heap_size-2), HL 
140d			      ld    (heap_start+heap_size-4), HL 
140d			 
140d			      pop   HL 
140d			 
140d			      ret 
140d			 
140d			 
140d			;------------------------------------------------------------------------------ 
140d			;     malloc                                                                  : 
140d			;                                                                             : 
140d			; Description                                                                 : 
140d			;     Allocates the wanted space from the heap and returns the address of the : 
140d			;     first useable byte of the allocation.                                   : 
140d			;                                                                             : 
140d			;     Allocations can happen in one of two ways:                              : 
140d			;                                                                             : 
140d			;     1. A free block may be found which is the exact size wanted. In this    : 
140d			;        case the block is removed from the free list and retuedn to the      : 
140d			;        caller.                                                              : 
140d			;     2. A free block may be found which is larger than the size wanted. In   : 
140d			;        this case, the larger block is split into two. The first portion of  : 
140d			;        this block will become the requested space by the malloc call and    : 
140d			;        is returned to the caller. The second portion becomes a new free     : 
140d			;        block, and the free list is adjusted to maintain continuity via this : 
140d			;        newly created block.                                                 : 
140d			;                                                                             : 
140d			;     malloc does not set any initial value in the allocated space, the       : 
140d			;     caller is required to do this as required.                              : 
140d			;                                                                             : 
140d			;     This implementation of malloc uses the stack exclusively, and is        : 
140d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
140d			;     advisable to disable interrupts before calling malloc, and recommended  : 
140d			;     to avoid the use of malloc inside ISRs in general.                      : 
140d			;                                                                             : 
140d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
140d			;                                                                             : 
140d			; Parameters                                                                  : 
140d			;     HL  Number of bytes wanted                                              : 
140d			;                                                                             : 
140d			; Returns                                                                     : 
140d			;     HL  Address of the first useable byte of the allocation                 : 
140d			;                                                                             : 
140d			; Flags                                                                       : 
140d			;     Z   Set if the allocation did not succeed, clear otherwise              : 
140d			;                                                                             : 
140d			; Stack frame                                                                 : 
140d			;       |             |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |     BC      |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |     DE      |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |     IX      |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |  prev_free  |                                                       : 
140d			;   +4  +-------------+                                                       : 
140d			;       |  this_free  |                                                       : 
140d			;   +2  +-------------+                                                       : 
140d			;       |  next_free  |                                                       : 
140d			;   +0  +-------------+                                                       : 
140d			;       |             |                                                       : 
140d			;                                                                             : 
140d			;------------------------------------------------------------------------------ 
140d			malloc: 
140d			      push  BC 
140d			      push  DE 
140d			      push  IX 
140d			 
140d			      ld    A, H                    ; Exit if no space requested 
140d			      or    L 
140d			      jp    Z, malloc_early_exit 
140d			 
140d			      ; Set up stack frame 
140d			      ex    DE, HL 
140d			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
140d			      add   HL, SP 
140d			      ld    SP, HL 
140d			      ld    IX, 0                   ; Use IX as a frame pointer 
140d			      add   IX, SP 
140d			 
140d			      ; Setup initial state 
140d			      ld    HL, 4                   ; want must also include space used by block struct 
140d			      add   HL, DE 
140d			 
140d			      ld    B, H                    ; Move want to BC 
140d			      ld    C, L 
140d			 
140d			      ld    HL, free_list           ; Store prev_free ptr to stack 
140d			      ld    (IX+4), L 
140d			      ld    (IX+5), H 
140d			 
140d			      ld    E, (HL)                 ; Store this_free ptr to stack 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      ld    (IX+2), E 
140d			      ld    (IX+3), D 
140d			      ex    DE, HL                  ; this_free ptr into HL 
140d			 
140d			      ; Loop through free block list to find some space 
140d			malloc_find_space: 
140d			      ld    E, (HL)                 ; Load next_free ptr into DE 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			 
140d			      ld    A, D                    ; Check for null next_free ptr - end of free list 
140d			      or    E 
140d			      jp    Z, malloc_no_space 
140d			 
140d			      ld    (IX+0), E               ; Store next_free ptr to stack 
140d			      ld    (IX+1), D 
140d			 
140d			      ; Does this block have enough space to make the allocation? 
140d			      inc   HL                      ; Load free block size into DE 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			 
140d			      ex    DE, HL                  ; Check size of block against want 
140d			      or    A                       ; Ensure carry flag clear 
140d			      sbc   HL, BC 
140d			      push  HL                      ; Store the result for later (new block size) 
140d			 
140d			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
140d			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
140d			 
140d			      ; this_free block is not big enough, setup ptrs to test next free block 
140d			      pop   HL                      ; Discard previous result 
140d			 
140d			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
140d			      ld    H, (IX+3) 
140d			      ld    (IX+4), L 
140d			      ld    (IX+5), H 
140d			 
140d			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
140d			      ld    H, (IX+1) 
140d			      ld    (IX+2), L 
140d			      ld    (IX+3), H 
140d			 
140d			      jr    malloc_find_space 
140d			 
140d			      ; split a bigger block into two - requested size and remaining size 
140d			malloc_alloc_split: 
140d			      ex    DE, HL                  ; Calculate address of new free block 
140d			      dec   HL 
140d			      dec   HL 
140d			      dec   HL 
140d			      add   HL, BC 
140d			 
140d			      ; Create a new block and point it at next_free 
140d			      ld    E, (IX+0)               ; Load next_free ptr into DE 
140d			      ld    D, (IX+1) 
140d			 
140d			      ld    (HL), E                 ; Store next_free ptr into new block 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			      pop   DE                      ; Store size of new block into new block 
140d			      inc   HL 
140d			      ld    (HL), E 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			      ; Update this_free ptr to point to new block 
140d			      dec   HL 
140d			      dec   HL 
140d			      dec   HL 
140d			 
140d			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
140d			      ld    D, (IX+3) 
140d			 
140d			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
140d			      ld    (IX+3), H 
140d			 
140d			      ; Modify this_free block to be allocation 
140d			      ex    DE, HL 
140d			      xor   A                       ; Null the next block ptr of allocated block 
140d			      ld    (HL), A 
140d			      inc   HL 
140d			      ld    (HL), A 
140d			 
140d			      inc   HL                      ; Store want size into allocated block 
140d			      ld    (HL), C 
140d			      inc   HL 
140d			      ld    (HL), B 
140d			      inc   HL 
140d			      push  HL                      ; Address of allocation to return 
140d			 
140d			      jr    malloc_update_links 
140d			 
140d			malloc_alloc_fit: 
140d			      pop   HL                      ; Dont need new block size, want is exact fit 
140d			 
140d			      ; Modify this_free block to be allocation 
140d			      ex    DE, HL 
140d			      dec   HL 
140d			      dec   HL 
140d			      dec   HL 
140d			 
140d			      xor   A                       ; Null the next block ptr of allocated block 
140d			      ld    (HL), A 
140d			      inc   HL 
140d			      ld    (HL), A 
140d			 
140d			      inc   HL                      ; Store address of allocation to return 
140d			      inc   HL 
140d			      inc   HL 
140d			      push  HL 
140d			 
140d			      ; Copy next_free ptr to this_free, remove allocated block from free list 
140d			      ld    L, (IX+0)               ; next_free to HL 
140d			      ld    H, (IX+1) 
140d			 
140d			      ld    (IX+2), L               ; HL to this_free 
140d			      ld    (IX+3), H 
140d			 
140d			 
140d			malloc_update_links: 
140d			      ; Update prev_free ptr to point to this_free 
140d			      ld    L, (IX+4)               ; prev_free ptr to HL 
140d			      ld    H, (IX+5) 
140d			 
140d			      ld    E, (IX+2)               ; this_free ptr to DE 
140d			      ld    D, (IX+3) 
140d			 
140d			      ld    (HL), E                 ; this_free ptr into prev_free 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			      ; Clear the Z flag to indicate successful allocation 
140d			      ld    A, D 
140d			      or    E 
140d			 
140d			      pop   DE                      ; Address of allocation 
140d			 
140d			malloc_no_space: 
140d			      ld    HL, 6                   ; Clean up stack frame 
140d			      add   HL, SP 
140d			      ld    SP, HL 
140d			 
140d			      ex    DE, HL                  ; Alloc addr into HL for return 
140d			 
140d			malloc_early_exit: 
140d			      pop   IX 
140d			      pop   DE 
140d			      pop   BC 
140d			 
140d			      ret 
140d			 
140d			 
140d			;------------------------------------------------------------------------------ 
140d			;     free                                                                    : 
140d			;                                                                             : 
140d			; Description                                                                 : 
140d			;     Return the space pointed to by HL to the heap. HL must be an address as : 
140d			;     returned by malloc, otherwise the behaviour is undefined.               : 
140d			;                                                                             : 
140d			;     Where possible, directly adjacent free blocks will be merged together   : 
140d			;     into larger blocks to help ensure that the heap does not become         : 
140d			;     excessively fragmented.                                                 : 
140d			;                                                                             : 
140d			;     free does not clear or set any other value into the freed space, and    : 
140d			;     therefore its contents may be visible through subsequent malloc's. The  : 
140d			;     caller should clear the freed space as required.                        : 
140d			;                                                                             : 
140d			;     This implementation of free uses the stack exclusively, and is          : 
140d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
140d			;     advisable to disable interrupts before calling free, and recommended    : 
140d			;     to avoid the use of free inside ISRs in general.                        : 
140d			;                                                                             : 
140d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
140d			;                                                                             : 
140d			; Parameters                                                                  : 
140d			;     HL  Pointer to address of first byte of allocation to be freed          : 
140d			;                                                                             : 
140d			; Returns                                                                     : 
140d			;     Nothing                                                                 : 
140d			;                                                                             : 
140d			; Stack frame                                                                 : 
140d			;       |             |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |     BC      |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |     DE      |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |     IX      |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |  prev_free  |                                                       : 
140d			;   +2  +-------------+                                                       : 
140d			;       |  next_free  |                                                       : 
140d			;   +0  +-------------+                                                       : 
140d			;       |             |                                                       : 
140d			;                                                                             : 
140d			;------------------------------------------------------------------------------ 
140d			free: 
140d			      push  BC 
140d			      push  DE 
140d			      push  IX 
140d			 
140d			      ld    A, H                    ; Exit if ptr is null 
140d			      or    L 
140d			      jp    Z, free_early_exit 
140d			 
140d			      ; Set up stack frame 
140d			      ex    DE, HL 
140d			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
140d			      add   HL, SP 
140d			      ld    SP, HL 
140d			      ld    IX, 0                   ; Use IX as a frame pointer 
140d			      add   IX, SP 
140d			 
140d			      ; The address in HL points to the start of the useable allocated space, 
140d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
140d			      ; address of the block itself. 
140d			      ex    DE, HL 
140d			      ld    DE, -4 
140d			      add   HL, DE 
140d			 
140d			      ; An allocated block must have a null next block pointer in it 
140d			      ld    A, (HL) 
140d			      inc   HL 
140d			      or    (HL) 
140d			      jp    NZ, free_done 
140d			 
140d			      dec   HL 
140d			 
140d			      ld    B, H                    ; Copy HL to BC 
140d			      ld    C, L 
140d			 
140d			      ; Loop through the free list to find the first block with an address 
140d			      ; higher than the block being freed 
140d			      ld    HL, free_list 
140d			 
140d			free_find_higher_block: 
140d			      ld    E, (HL)                 ; Load next ptr from free block 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      dec   HL 
140d			 
140d			      ld    (IX+0), E               ; Save ptr to next free block 
140d			      ld    (IX+1), D 
140d			      ld    (IX+2), L               ; Save ptr to prev free block 
140d			      ld    (IX+3), H 
140d			 
140d			      ld    A, B                    ; Check if DE is greater than BC 
140d			      cp    D                       ; Compare MSB first 
140d			      jr    Z, $+4                  ; MSB the same, compare LSB 
140d			      jr    NC, free_find_higher_block_skip 
140d			      ld    A, C 
140d			      cp    E                       ; Then compare LSB 
140d			      jr    C, free_found_higher_block 
140d			 
140d			free_find_higher_block_skip: 
140d			      ld    A, D                    ; Reached the end of the free list? 
140d			      or    E 
140d			      jp    Z, free_done 
140d			 
140d			      ex    DE, HL 
140d			 
140d			      jr    free_find_higher_block 
140d			 
140d			free_found_higher_block: 
140d			      ; Insert freed block between prev and next free blocks 
140d			      ld    (HL), C                 ; Point prev free block to freed block 
140d			      inc   HL 
140d			      ld    (HL), B 
140d			 
140d			      ld    H, B                    ; Point freed block at next free block 
140d			      ld    L, C 
140d			      ld    (HL), E 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			      ; Check if the freed block is adjacent to the next free block 
140d			      inc   HL                      ; Load size of freed block into HL 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      ex    DE, HL 
140d			 
140d			      add   HL, BC                  ; Add addr of freed block and its size 
140d			 
140d			      ld    E, (IX+0)               ; Load addr of next free block into DE 
140d			      ld    D, (IX+1) 
140d			 
140d			      or    A                       ; Clear the carry flag 
140d			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
140d			      jr    NZ, free_check_adjacent_to_prev 
140d			 
140d			      ; Freed block is adjacent to next, merge into one bigger block 
140d			      ex    DE, HL                  ; Load next ptr from next block into DE 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      push  HL                      ; Save ptr to next block for later 
140d			 
140d			      ld    H, B                    ; Store ptr from next block into freed block 
140d			      ld    L, C 
140d			      ld    (HL), E 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			      pop   HL                      ; Restore ptr to next block 
140d			      inc   HL                      ; Load size of next block into DE 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      push  DE                      ; Save next block size for later 
140d			 
140d			      ld    H, B                    ; Load size of freed block into HL 
140d			      ld    L, C 
140d			      inc   HL 
140d			      inc   HL 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      ex    DE, HL 
140d			 
140d			      pop   DE                      ; Restore size of next block 
140d			      add   HL, DE                  ; Add sizes of both blocks 
140d			      ex    DE, HL 
140d			 
140d			      ld    H, B                    ; Store new bigger size into freed block 
140d			      ld    L, C 
140d			      inc   HL 
140d			      inc   HL 
140d			      ld    (HL), E 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			free_check_adjacent_to_prev: 
140d			      ; Check if the freed block is adjacent to the prev free block 
140d			      ld    L, (IX+2)               ; Prev free block ptr into HL 
140d			      ld    H, (IX+3) 
140d			 
140d			      inc   HL                      ; Size of prev free block into DE 
140d			      inc   HL 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      dec   HL 
140d			      dec   HL 
140d			      dec   HL 
140d			 
140d			      add   HL, DE                  ; Add prev block addr and size 
140d			 
140d			      or    A                       ; Clear the carry flag 
140d			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
140d			      jr    NZ, free_done 
140d			 
140d			      ; Freed block is adjacent to prev, merge into one bigger block 
140d			      ld    H, B                    ; Load next ptr from freed block into DE 
140d			      ld    L, C 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      push  HL                      ; Save freed block ptr for later 
140d			 
140d			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
140d			      ld    H, (IX+3) 
140d			      ld    (HL), E 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			      pop   HL                      ; Restore freed block ptr 
140d			      inc   HL                      ; Load size of freed block into DE 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      push  DE                      ; Save freed block size for later 
140d			 
140d			      ld    L, (IX+2)               ; Load size of prev block into DE 
140d			      ld    H, (IX+3) 
140d			      inc   HL 
140d			      inc   HL 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			 
140d			      pop   HL                      ; Add sizes of both blocks 
140d			      add   HL, DE 
140d			      ex    DE, HL 
140d			 
140d			      ld    L, (IX+2)               ; Store new bigger size into prev block 
140d			      ld    H, (IX+3) 
140d			      inc   HL 
140d			      inc   HL 
140d			      ld    (HL), E 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			free_done: 
140d			      ld    HL, 4                   ; Clean up stack frame 
140d			      add   HL, SP 
140d			      ld    SP, HL 
140d			 
140d			free_early_exit: 
140d			      pop   IX 
140d			      pop   DE 
140d			      pop   BC 
140d			 
140d			      ret 
140d			 
140d			 
140d			;      .org 0x8000 
140d			; 
140d			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
140d			 ;                 .dw   0 
140d			 
140d			endif 
140d			 
140d			 
140d			if MALLOC_4 
140d			 
140d			; My memory allocation code. Very very simple.... 
140d			; allocate space under 250 chars 
140d			 
140d			heap_init: 
140d				; init start of heap as zero 
140d				;  
140d			 
140d				ld hl, heap_start 
140d				ld a, 0 
140d				ld (hl), a      ; empty block 
140d				inc hl 
140d				ld a, 0 
140d				ld (hl), a      ; length of block 
140d				; write end of list 
140d				inc hl 
140d				ld a,(hl) 
140d				inc hl 
140d				ld a,(hl) 
140d				 
140d			 
140d				; init some malloc vars 
140d			 
140d				ld hl, 0 
140d				ld (free_list), hl       ; store last malloc location 
140d			 
140d				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
140d				ld a, 0 
140d				ld (hl), a 
140d			 
140d			 
140d				ld hl, heap_start 
140d				;  
140d				  
140d				ret 
140d			 
140d			 
140d			;    free block marker 
140d			;    requested size  
140d			;    pointer to next block 
140d			;    .... 
140d			;    next block marker 
140d			 
140d			 
140d			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
140d			; 
140d			 
140d			 
140d			malloc:  
140d				push de 
140d				push bc 
140d				push af 
140d			 
140d				; hl space required 
140d				 
140d				ld c, l    ; hold space   (TODO only a max of 255) 
140d			 
140d			;	inc c     ; TODO BUG need to fix memory leak on push str 
140d			;	inc c 
140d			;	inc c 
140d			;	inc c 
140d			;	inc c 
140d			;	inc c 
140d			;	inc c 
140d			 
140d			 
140d			 
140d				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
140d			 
140d				ld a, (free_list+3) 
140d				cp 0 
140d				jr z, .contheap 
140d			 
140d				ld hl, (free_list)     ; get last alloc 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "mrs" 
140d						CALLMONITOR 
140d					endif 
140d				jr .startalloc 
140d			 
140d			.contheap: 
140d				ld hl, heap_start 
140d			 
140d			.startalloc: 
140d			 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "mym" 
140d						CALLMONITOR 
140d					endif 
140d			.findblock: 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "mmf" 
140d						CALLMONITOR 
140d					endif 
140d			 
140d				ld a,(hl)  
140d				; if byte is zero then clear to use 
140d			 
140d				cp 0 
140d				jr z, .foundemptyblock 
140d			 
140d				; if byte is not clear 
140d				;     then byte is offset to next block 
140d			 
140d				inc hl 
140d				ld a, (hl) ; get size 
140d			.nextblock:	inc hl 
140d					ld e, (hl) 
140d					inc hl 
140d					ld d, (hl) 
140d					ex de, hl 
140d			;	inc hl  ; move past the store space 
140d			;	inc hl  ; move past zero index  
140d			 
140d				; TODO detect no more space 
140d			 
140d				push hl 
140d				ld de, heap_end 
140d				call cmp16 
140d				pop hl 
140d				jr nc, .nospace 
140d			 
140d				jr .findblock 
140d			 
140d			.nospace: ld hl, 0 
140d				jp .exit 
140d			 
140d			 
140d			.foundemptyblock:	 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "mme" 
140d						CALLMONITOR 
140d					endif 
140d			 
140d			; TODO has block enough space if reusing??? 
140d			 
140d				;  
140d			 
140d			; see if this block has been previously used 
140d				inc hl 
140d				ld a, (hl) 
140d				dec hl 
140d				cp 0 
140d				jr z, .newblock 
140d			 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "meR" 
140d						CALLMONITOR 
140d					endif 
140d			 
140d			; no reusing previously allocated block 
140d			 
140d			; is it smaller than previously used? 
140d				 
140d				inc hl    ; move to size 
140d				ld a, c 
140d				sub (hl)        ; we want c < (hl) 
140d				dec hl    ; move back to marker 
140d			        jr z, .findblock 
140d			 
140d				; update with the new size which should be lower 
140d			 
140d			        ;inc  hl   ; negate next move. move back to size  
140d			 
140d			.newblock: 
140d				; need to be at marker here 
140d			 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "meN" 
140d						CALLMONITOR 
140d					endif 
140d			 
140d			 
140d				ld a, c 
140d			 
140d				ld (free_list+3), a	 ; flag resume from last malloc  
140d				ld (free_list), hl    ; save out last location 
140d			 
140d			 
140d				;inc a     ; space for length byte 
140d				ld (hl), a     ; save block in use marker 
140d			 
140d				inc hl   ; move to space marker 
140d				ld (hl), a    ; save new space 
140d			 
140d				inc hl   ; move to start of allocated area 
140d				 
140d			;	push hl     ; save where we are - 1  
140d			 
140d			;	inc hl  ; move past zero index  
140d				; skip space to set down new marker 
140d			 
140d				; provide some extra space for now 
140d			 
140d				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
140d				inc a 
140d				inc a 
140d			 
140d				push hl   ; save where we are in the node block 
140d			 
140d				call addatohl 
140d			 
140d				; write linked list point 
140d			 
140d				pop de     ; get our node position 
140d				ex de, hl 
140d			 
140d				ld (hl), e 
140d				inc hl 
140d				ld (hl), d 
140d			 
140d				inc hl 
140d			 
140d				; now at start of allocated data so save pointer 
140d			 
140d				push hl 
140d			 
140d				; jump to position of next node and setup empty header in DE 
140d			 
140d				ex de, hl 
140d			 
140d			;	inc hl ; move past end of block 
140d			 
140d				ld a, 0 
140d				ld (hl), a   ; empty marker 
140d				inc hl 
140d				ld (hl), a   ; size 
140d				inc hl  
140d				ld (hl), a   ; ptr 
140d				inc hl 
140d				ld (hl), a   ; ptr 
140d			 
140d			 
140d				pop hl 
140d			 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "mmr" 
140d						CALLMONITOR 
140d					endif 
140d			 
140d			.exit: 
140d				pop af 
140d				pop bc 
140d				pop de  
140d				ret 
140d			 
140d			 
140d			 
140d			 
140d			free:  
140d				push hl 
140d				push af 
140d				; get address in hl 
140d			 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "fre" 
140d						CALLMONITOR 
140d					endif 
140d				; data is at hl - move to block count 
140d				dec hl 
140d				dec hl    ; get past pointer 
140d				dec hl 
140d			 
140d				ld a, (hl)    ; need this for a validation check 
140d			 
140d				dec hl    ; move to block marker 
140d			 
140d				; now check that the block count and block marker are the same  
140d			        ; this checks that we are on a malloc node and not random memory 
140d			        ; OK a faint chance this could be a problem but rare - famous last words! 
140d			 
140d				ld c, a 
140d				ld a, (hl)    
140d			 
140d				cp c 
140d				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
140d			 
140d				; yes good chance we are on a malloc node 
140d			 
140d				ld a, 0      
140d				ld (hl), a   ; mark as free 
140d			 
140d				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
140d			 
140d			.freeignore:  
140d			 
140d				pop af 
140d				pop hl 
140d			 
140d				ret 
140d			 
140d			 
140d			 
140d			endif 
140d			 
140d			; eof 
# End of file firmware_memory.asm
140d			  
140d			; device C  
140d			if SOUND_ENABLE  
140d				include "firmware_sound.asm"  
140d			endif  
140d			  
140d			include "firmware_diags.asm"  
140d			; Hardware diags menu 
140d			 
140d			 
140d			config: 
140d			 
140d 3e 00			ld a, 0 
140f 21 3d 14			ld hl, .configmn 
1412 cd b1 0b			call menu 
1415			 
1415 fe 00			cp 0 
1417 c8				ret z 
1418			 
1418 fe 01			cp 1 
141a cc 6b 14			call z, .savetostore 
141d			 
141d fe 02			cp 2 
141f cc 57 14			call z, .selautoload 
1422 fe 03			cp 3 
1424 cc 4d 14			call z, .disautoload 
1427 fe 04			cp 4 
1429 cc 61 14			call z, .selbank 
142c fe 05			cp 5 
142e cc 75 14			call z, .debug_tog 
1431 fe 06			cp 6 
1433 cc b8 15			call z, .bpsgo 
1436 fe 07			cp 7 
1438 cc 9b 14			call z, hardware_diags 
143b			 
143b 18 d0			jr config 
143d			 
143d			.configmn: 
143d a9 17			dw prom_c3 
143f c0 17			dw prom_c2 
1441 d5 17			dw prom_c2a 
1443 eb 17			dw prom_c2b 
1445			;	dw prom_c4 
1445 08 18			dw prom_m4 
1447 23 18			dw prom_m4b 
1449 2b 18			dw prom_c1 
144b 00 00			dw 0 
144d				 
144d			 
144d			 
144d			 
144d			.disautoload: 
144d				if STORAGE_SE 
144d				ld a, $fe      ; bit 0 clear 
144d				ld (spi_device), a 
144d			 
144d				call storage_get_block_0 
144d			 
144d				ld a, 0 
144d				ld (store_page+STORE_0_AUTOFILE), a 
144d			 
144d					ld hl, 0 
144d					ld de, store_page 
144d				call storage_write_block	 ; save update 
144d				else 
144d			 
144d 21 3a 18			ld hl, prom_notav 
1450 11 50 18			ld de, prom_empty 
1453 cd 11 0b			call info_panel 
1456				endif 
1456			 
1456			 
1456 c9				ret 
1457			 
1457			 
1457			 
1457			; Select auto start 
1457			 
1457			.selautoload: 
1457			 
1457				 
1457				if STORAGE_SE 
1457			 
1457					call config_dir 
1457				        ld hl, scratch 
1457					ld a, 0 
1457					call menu 
1457			 
1457					cp 0 
1457					ret z 
1457			 
1457					dec a 
1457			 
1457			 
1457					; locate menu option 
1457			 
1457					ld hl, scratch 
1457					call table_lookup 
1457			 
1457					if DEBUG_FORTH_WORDS 
1457						DMARK "ALl" 
1457						CALLMONITOR 
1457					endif 
1457					; with the pointer to the menu it, the byte following the zero term is the file id 
1457			 
1457					ld a, 0 
1457					ld bc, 50   ; max of bytes to look at 
1457					cpir  
1457			 
1457					if DEBUG_FORTH_WORDS 
1457						DMARK "ALb" 
1457						CALLMONITOR 
1457					endif 
1457					;inc hl 
1457			 
1457					ld a, (hl)   ; file id 
1457					 
1457				        ; save bank and file ids 
1457			 
1457					push af 
1457			 
1457			; TODO need to save to block 0 on bank 1	 
1457			 
1457					call storage_get_block_0 
1457			 
1457					if DEBUG_FORTH_WORDS 
1457						DMARK "AL0" 
1457						CALLMONITOR 
1457					endif 
1457					pop af 
1457			 
1457					ld (store_page+STORE_0_FILERUN),a 
1457					 
1457					; save bank id 
1457			 
1457					ld a,(spi_device) 
1457					ld (store_page+STORE_0_BANKRUN),a 
1457			 
1457					; enable auto run of store file 
1457			 
1457					ld a, 1 
1457					ld (store_page+STORE_0_AUTOFILE),a 
1457			 
1457					; save buffer 
1457			 
1457					ld hl, 0 
1457					ld de, store_page 
1457					if DEBUG_FORTH_WORDS 
1457						DMARK "ALw" 
1457						CALLMONITOR 
1457					endif 
1457				call storage_write_block	 ; save update 
1457			  
1457			 
1457			 
1457			 
1457					ld hl, scratch 
1457					call config_fdir 
1457			 
1457				else 
1457			 
1457 21 3a 18			ld hl, prom_notav 
145a 11 50 18			ld de, prom_empty 
145d cd 11 0b			call info_panel 
1460			 
1460				endif 
1460 c9				ret 
1461			 
1461			 
1461			 
1461			; Select storage bank 
1461			 
1461			.selbank: 
1461			 
1461				if STORAGE_SE 
1461				else 
1461			 
1461 21 3a 18			ld hl, prom_notav 
1464 11 50 18			ld de, prom_empty 
1467 cd 11 0b			call info_panel 
146a				endif 
146a				 
146a c9				ret 
146b			 
146b			if STORAGE_SE 
146b			 
146b			.config_ldir:   
146b				; Load storage bank labels into menu array 
146b			 
146b				 
146b			 
146b			 
146b				ret 
146b			 
146b			 
146b			endif 
146b			 
146b			 
146b			; Save user words to storage 
146b			 
146b			.savetostore: 
146b			 
146b				if STORAGE_SE 
146b			 
146b					call config_dir 
146b				        ld hl, scratch 
146b					ld a, 0 
146b					call menu 
146b					 
146b					ld hl, scratch 
146b					call config_fdir 
146b			 
146b				else 
146b			 
146b 21 3a 18			ld hl, prom_notav 
146e 11 50 18			ld de, prom_empty 
1471 cd 11 0b			call info_panel 
1474			 
1474				endif 
1474			 
1474 c9				ret 
1475			 
1475			 
1475			 
1475			if STORAGE_SE 
1475			 
1475			config_fdir: 
1475				; using the scratch dir go through and release the memory allocated for each string 
1475				 
1475				ld hl, scratch 
1475			.cfdir:	ld e,(hl) 
1475				inc hl 
1475				ld d,(hl) 
1475				inc hl 
1475			 
1475				ex de, hl 
1475				call ishlzero 
1475				ret z     ; return on null pointer 
1475				call free 
1475				ex de, hl 
1475				jr .cfdir 
1475			 
1475			 
1475				ret 
1475			 
1475			 
1475			config_dir: 
1475			 
1475				; for the config menus that need to build a directory of storage call this routine 
1475				; it will construct a menu in scratch to pass to menu 
1475			 
1475				; open storage device 
1475			 
1475				; execute DIR to build a list of files and their ids into scratch in menu format 
1475				; once the menu has finished then will need to call config_fdir to release the strings 
1475				 
1475				; c = number items 
1475			 
1475				 
1475				call storage_get_block_0 
1475			 
1475				ld hl, store_page     ; get current id count 
1475				ld b, (hl) 
1475				ld c, 0    ; count of files   
1475			 
1475			 
1475				ld hl, scratch 
1475				ld (store_tmp2), hl    ; location to poke strings 
1475			 
1475				; check for empty drive 
1475			 
1475				ld a, 0 
1475				cp b 
1475				jp z, .dirdone 
1475			 
1475				 
1475					if DEBUG_FORTH_WORDS 
1475						DMARK "Cdc" 
1475						CALLMONITOR 
1475					endif 
1475			 
1475			 
1475			.diritem:	 
1475				push bc 
1475				; for each of the current ids do a search for them and if found push to stack 
1475			 
1475					ld hl, STORE_BLOCK_PHY 
1475					ld d, 0		 ; look for extent 0 of block id as this contains file name 
1475					ld e,b 
1475			 
1475					call storage_findnextid 
1475			 
1475			 
1475					; if found hl will be non zero 
1475			 
1475					call ishlzero 
1475					jr z, .dirnotfound 
1475			 
1475					; increase count 
1475			 
1475					pop bc	 
1475					inc c 
1475					push bc 
1475					 
1475			 
1475					; get file header and push the file name 
1475			 
1475					ld de, store_page 
1475					call storage_read_block 
1475			 
1475					; push file id to stack 
1475				 
1475					ld a, (store_page) 
1475					ld h, 0 
1475					ld l, a 
1475			 
1475					;call forth_push_numhl 
1475					; TODO store id 
1475			 
1475					push hl 
1475			 
1475					; push extent count to stack  
1475				 
1475					ld hl, store_page+3 
1475			 
1475					; get file name length 
1475			 
1475					call strlenz   
1475			 
1475					inc hl   ; cover zero term 
1475					inc hl  ; stick the id at the end of the area 
1475			 
1475					push hl 
1475					pop bc    ; move length to bc 
1475			 
1475					call malloc 
1475			 
1475					; TODO save malloc area to scratch 
1475			 
1475					ex de, hl 
1475					ld hl, (store_tmp2) 
1475					ld (hl), e 
1475					inc hl 
1475					ld (hl), d 
1475					inc hl 
1475					ld (store_tmp2), hl 
1475			 
1475					 
1475			 
1475					;pop hl   ; get source 
1475			;		ex de, hl    ; swap aronund	 
1475			 
1475					ld hl, store_page+3 
1475					if DEBUG_FORTH_WORDS 
1475						DMARK "CFd" 
1475						CALLMONITOR 
1475					endif 
1475					ldir 
1475			 
1475					; de is past string, move back one and store id 
1475					 
1475					dec de 
1475			 
1475					; store file id 
1475			 
1475					pop hl 
1475					ex de,hl 
1475					ld (hl), e 
1475			 
1475					if DEBUG_FORTH_WORDS 
1475						DMARK "Cdi" 
1475						CALLMONITOR 
1475					endif 
1475					 
1475			.dirnotfound: 
1475					pop bc     
1475					djnz .diritem 
1475				 
1475			.dirdone:	 
1475			 
1475					ld a, 0 
1475					ld hl, (store_tmp2) 
1475					ld (hl), a 
1475					inc hl 
1475					ld (hl), a 
1475					inc hl 
1475					; push a count of the dir items found 
1475			 
1475			;		ld h, 0 
1475			;		ld l, c 
1475			 
1475				ret 
1475			 
1475			endif 
1475			 
1475			 
1475			; Settings 
1475			; Run  
1475			 
1475			 
1475			 
1475			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1475			;;hd_menu2:   db "        2: Editor",0   
1475			;hd_menu2:   db "        2: Editor       6: Menu",0   
1475			;hd_menu3:   db "        3: Storage",0 
1475			;hd_menu4:   db "0=quit  4: Debug",0 
1475			;hd_don:     db "ON",0 
1475			;hd_doff:     db "OFF",0 
1475			; 
1475			; 
1475			; 
1475			;hardware_diags_old:       
1475			; 
1475			;.diagmenu: 
1475			;	call clear_display 
1475			;	ld a, display_row_1 
1475			;	ld de, hd_menu1 
1475			;	call str_at_display 
1475			; 
1475			;	ld a, display_row_2 
1475			;	ld de, hd_menu2 
1475			;	call str_at_display 
1475			; 
1475			;	ld a, display_row_3 
1475			;	ld de, hd_menu3 
1475			;	call str_at_display 
1475			; 
1475			;	ld a,  display_row_4 
1475			;	ld de, hd_menu4 
1475			;	call str_at_display 
1475			; 
1475			;	; display debug state 
1475			; 
1475			;	ld de, hd_don 
1475			;	ld a, (os_view_disable) 
1475			;	cp 0 
1475			;	jr z, .distog 
1475			;	ld de, hd_doff 
1475			;.distog: ld a, display_row_4+17 
1475			;	call str_at_display 
1475			; 
1475			;	call update_display 
1475			; 
1475			;	call cin_wait 
1475			; 
1475			; 
1475			; 
1475			;	cp '4' 
1475			;	jr nz, .diagn1 
1475			; 
1475			;	; debug toggle 
1475			; 
1475			;	ld a, (os_view_disable) 
1475			;	ld b, '*' 
1475			;	cp 0 
1475			;	jr z, .debtog 
1475			;	ld b, 0 
1475			;.debtog:	 
1475			;	ld a,b 
1475			;	ld (os_view_disable),a 
1475			; 
1475			;.diagn1: cp '0' 
1475			;	 ret z 
1475			; 
1475			;;	cp '1' 
1475			;;       jp z, matrix	 
1475			;;   TODO keyboard matrix test 
1475			; 
1475			;	cp '2' 
1475			;	jp z, .diagedit 
1475			; 
1475			;;	cp '6' 
1475			;;	jp z, .menutest 
1475			;;if ENABLE_BASIC 
1475			;;	cp '6' 
1475			;;	jp z, basic 
1475			;;endif 
1475			 ; 
1475			;	jp .diagmenu 
1475			; 
1475			; 
1475			;	ret 
1475			 
1475			 
1475			.debug_tog: 
1475 21 bc 14			ld hl, .menudebug 
1478				 
1478 3a bc e2			ld a, (os_view_disable) 
147b fe 2a			cp '*' 
147d 20 04			jr nz,.tdon  
147f 3e 01			ld a, 1 
1481 18 02			jr .tog1 
1483 3e 00		.tdon: ld a, 0 
1485			 
1485			.tog1: 
1485 cd b1 0b			call menu 
1488 fe 00			cp 0 
148a c8				ret z 
148b fe 01			cp 1    ; disable debug 
148d 28 04			jr z, .dtog0 
148f 3e 2a			ld a, '*' 
1491 18 02			jr .dtogset 
1493 3e 00		.dtog0: ld a, 0 
1495 32 bc e2		.dtogset:  ld (os_view_disable), a 
1498 c3 75 14			jp .debug_tog 
149b			 
149b			 
149b			hardware_diags:       
149b			 
149b			.diagm: 
149b 21 ae 14			ld hl, .menuitems 
149e 3e 00			ld a, 0 
14a0 cd b1 0b			call menu 
14a3			 
14a3 fe 00		         cp 0 
14a5 c8				 ret z 
14a6			 
14a6 fe 02			cp 2 
14a8 ca 07 15			jp z, .diagedit 
14ab			 
14ab			;	cp '6' 
14ab			;	jp z, .menutest 
14ab			;if ENABLE_BASIC 
14ab			;	cp '6' 
14ab			;	jp z, basic 
14ab			;endif 
14ab			  
14ab c3 9b 14			jp .diagm 
14ae			 
14ae				 
14ae c2 14		.menuitems:   	dw .m1 
14b0 cd 14				dw .m2 
14b2 d4 14				dw .m3 
14b4 dc 14				dw .m5 
14b6 e2 14				dw .m5a 
14b8 eb 14				dw .m5b 
14ba 00 00				dw 0 
14bc			 
14bc			.menudebug: 
14bc f4 14				dw .m6 
14be fd 14				dw .m7 
14c0 00 00				dw 0 
14c2			 
14c2 .. 00		.m1:   db "Key Matrix",0 
14cd .. 00		.m2:   db "Editor",0 
14d4 .. 00		.m3:   db "Storage",0 
14dc .. 00		.m5:   db "Sound",0 
14e2 .. 00		.m5a:  db "RAM Test",0 
14eb .. 00		.m5b:  db "LCD Test",0 
14f4			 
14f4 .. 00		.m6:   db "Debug ON",0 
14fd .. 00		.m7:   db "Debug OFF",0 
1507			 
1507			; debug editor 
1507			 
1507			.diagedit: 
1507			 
1507 21 cb e2			ld hl, scratch 
150a			;	ld bc, 250 
150a			;	ldir 
150a				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
150a 3e 00			ld a, 0 
150c 77				ld (hl), a 
150d 23				inc hl 
150e 77				ld (hl), a 
150f 23				inc hl 
1510 77				ld (hl), a 
1511			 
1511 cd 80 0b		        call clear_display 
1514 cd a3 0b			call update_display 
1517				;ld a, 1 
1517				;ld (hardware_diag), a 
1517			.diloop: 
1517 3e 00			ld a, display_row_1 
1519 0e 00			ld c, 0 
151b 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
151d 1e 28			ld e, 40 
151f			 
151f 21 cb e2			ld hl, scratch	 
1522 cd da 0d			call input_str 
1525			 
1525 3e 28			ld a, display_row_2 
1527 11 cb e2			ld de, scratch 
152a cd 93 0b			call str_at_display 
152d cd a3 0b			call update_display 
1530			 
1530 c3 17 15			jp .diloop 
1533			 
1533			 
1533			; pass word in hl 
1533			; a has display location 
1533			display_word_at: 
1533 f5				push af 
1534 e5				push hl 
1535 7c				ld a,h 
1536 21 d0 e5			ld hl, os_word_scratch 
1539 cd ae 10			call hexout 
153c e1				pop hl 
153d 7d				ld a,l 
153e 21 d2 e5			ld hl, os_word_scratch+2 
1541 cd ae 10			call hexout 
1544 21 d4 e5			ld hl, os_word_scratch+4 
1547 3e 00			ld a,0 
1549 77				ld (hl),a 
154a 11 d0 e5			ld de,os_word_scratch 
154d f1				pop af 
154e cd 93 0b				call str_at_display 
1551 c9				ret 
1552			 
1552			display_ptr_state: 
1552			 
1552				; to restore afterwards 
1552			 
1552 d5				push de 
1553 c5				push bc 
1554 e5				push hl 
1555 f5				push af 
1556			 
1556				; for use in here 
1556			 
1556			;	push bc 
1556			;	push de 
1556			;	push hl 
1556			;	push af 
1556			 
1556 cd 80 0b			call clear_display 
1559			 
1559 11 2c 17			ld de, .ptrstate 
155c 3e 00			ld a, display_row_1 
155e cd 93 0b			call str_at_display 
1561			 
1561				; display debug step 
1561			 
1561			 
1561 11 71 ee			ld de, debug_mark 
1564 3e 26			ld a, display_row_1+display_cols-2 
1566 cd 93 0b			call str_at_display 
1569			 
1569				; display a 
1569 11 36 17			ld de, .ptrcliptr 
156c 3e 28			ld a, display_row_2 
156e cd 93 0b			call str_at_display 
1571			 
1571 f1				pop af 
1572 2a 4a ea			ld hl,(cli_ptr) 
1575 3e 30			ld a, display_row_2+8 
1577 cd 33 15			call display_word_at 
157a			 
157a			 
157a				; display hl 
157a			 
157a			 
157a 11 3e 17			ld de, .ptrclioptr 
157d 3e 32			ld a, display_row_2+10 
157f cd 93 0b			call str_at_display 
1582			; 
1582			;	pop hl 
1582 3e 35			ld a, display_row_2+13 
1584 2a 48 ea			ld hl,(cli_origptr) 
1587 cd 33 15			call display_word_at 
158a			; 
158a			;	 
158a			;	; display de 
158a			 
158a			;	ld de, .regstatede 
158a			;	ld a, display_row_3 
158a			;	call str_at_display 
158a			 
158a			;	pop de 
158a			;	ld h,d 
158a			;	ld l, e 
158a			;	ld a, display_row_3+3 
158a			;	call display_word_at 
158a			 
158a			 
158a				; display bc 
158a			 
158a			;	ld de, .regstatebc 
158a			;	ld a, display_row_3+10 
158a			;	call str_at_display 
158a			 
158a			;	pop bc 
158a			;	ld h,b 
158a			;	ld l, c 
158a			;	ld a, display_row_3+13 
158a			;	call display_word_at 
158a			 
158a			 
158a				; display dsp 
158a			 
158a			;	ld de, .regstatedsp 
158a			;	ld a, display_row_4 
158a			;	call str_at_display 
158a			 
158a				 
158a			;	ld hl,(cli_data_sp) 
158a			;	ld a, display_row_4+4 
158a			;	call display_word_at 
158a			 
158a				; display rsp 
158a			 
158a 11 6d 17			ld de, .regstatersp 
158d 3e 82			ld a, display_row_4+10 
158f cd 93 0b			call str_at_display 
1592			 
1592				 
1592 2a fc e9			ld hl,(cli_ret_sp) 
1595 3e 86			ld a, display_row_4+14 
1597 cd 33 15			call display_word_at 
159a			 
159a cd a3 0b			call update_display 
159d			 
159d cd f2 0a			call delay1s 
15a0 cd f2 0a			call delay1s 
15a3 cd f2 0a			call delay1s 
15a6			 
15a6			 
15a6 cd 97 1b			call next_page_prompt 
15a9			 
15a9				; restore  
15a9			 
15a9 f1				pop af 
15aa e1				pop hl 
15ab c1				pop bc 
15ac d1				pop de 
15ad c9				ret 
15ae			 
15ae			break_point_state: 
15ae f5				push af 
15af			 
15af				; see if disabled 
15af			 
15af 3a bc e2			ld a, (os_view_disable) 
15b2 fe 2a			cp '*' 
15b4 20 02			jr nz, .bpsgo 
15b6 f1				pop af 
15b7 c9				ret 
15b8			 
15b8			.bpsgo: 
15b8 f1				pop af 
15b9 f5				push af 
15ba 22 b8 e2			ld (os_view_hl), hl 
15bd ed 53 b6 e2		ld (os_view_de), de 
15c1 ed 43 b4 e2		ld (os_view_bc), bc 
15c5 e5				push hl 
15c6 6f				ld l, a 
15c7 26 00			ld h, 0 
15c9 22 ba e2			ld (os_view_af),hl 
15cc			 
15cc 21 b7 ed				ld hl, display_fb0 
15cf 22 d2 eb				ld (display_fb_active), hl 
15d2 e1				pop hl	 
15d3			 
15d3 3e 31			ld a, '1' 
15d5 fe 2a		.bps1:  cp '*' 
15d7 20 03			jr nz, .bps1b 
15d9 32 bc e2			ld (os_view_disable),a 
15dc fe 31		.bps1b:  cp '1' 
15de 20 14			jr nz, .bps2 
15e0			 
15e0				; display reg 
15e0			 
15e0				 
15e0			 
15e0 3a ba e2			ld a, (os_view_af) 
15e3 2a b8 e2			ld hl, (os_view_hl) 
15e6 ed 5b b6 e2		ld de, (os_view_de) 
15ea ed 4b b4 e2		ld bc, (os_view_bc) 
15ee cd 88 16			call display_reg_state 
15f1 c3 74 16			jp .bpschk 
15f4			 
15f4 fe 32		.bps2:  cp '2' 
15f6 20 08			jr nz, .bps3 
15f8				 
15f8				; display hl 
15f8 2a b8 e2			ld hl, (os_view_hl) 
15fb cd 72 17			call display_dump_at_hl 
15fe			 
15fe 18 74			jr .bpschk 
1600			 
1600 fe 33		.bps3:  cp '3' 
1602 20 08			jr nz, .bps4 
1604			 
1604			        ; display de 
1604 2a b6 e2			ld hl, (os_view_de) 
1607 cd 72 17			call display_dump_at_hl 
160a			 
160a 18 68			jr .bpschk 
160c fe 34		.bps4:  cp '4' 
160e 20 08			jr nz, .bps5 
1610			 
1610			        ; display bc 
1610 2a b4 e2			ld hl, (os_view_bc) 
1613 cd 72 17			call display_dump_at_hl 
1616			 
1616 18 5c			jr .bpschk 
1618 fe 35		.bps5:  cp '5' 
161a 20 08		        jr nz, .bps7 
161c			 
161c				; display cur ptr 
161c 2a 4a ea			ld hl, (cli_ptr) 
161f cd 72 17			call display_dump_at_hl 
1622			 
1622 18 50			jr .bpschk 
1624 fe 36		.bps7:  cp '6' 
1626 20 08			jr nz, .bps8b 
1628				 
1628				; display cur orig ptr 
1628 2a 48 ea			ld hl, (cli_origptr) 
162b cd 72 17			call display_dump_at_hl 
162e 18 44			jr .bpschk 
1630 fe 37		.bps8b:  cp '7' 
1632 20 08			jr nz, .bps9 
1634				 
1634				; display dsp 
1634 2a f8 e9			ld hl, (cli_data_sp) 
1637 cd 72 17			call display_dump_at_hl 
163a			 
163a 18 38			jr .bpschk 
163c fe 39		.bps9:  cp '9' 
163e 20 05			jr nz, .bps8c 
1640				 
1640				; display SP 
1640			;	ld hl, sp 
1640 cd 72 17			call display_dump_at_hl 
1643			 
1643 18 2f			jr .bpschk 
1645 fe 38		.bps8c:  cp '8' 
1647 20 08			jr nz, .bps8d 
1649				 
1649				; display rsp 
1649 2a fc e9			ld hl, (cli_ret_sp) 
164c cd 72 17			call display_dump_at_hl 
164f			 
164f 18 23			jr .bpschk 
1651 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1653 20 05			jr nz, .bps8 
1655 cd 8d 19			call monitor 
1658			 
1658 18 1a			jr .bpschk 
165a fe 30		.bps8:  cp '0' 
165c 20 16			jr nz, .bpschk 
165e			 
165e 21 16 ed				ld hl, display_fb1 
1661 22 d2 eb				ld (display_fb_active), hl 
1664 cd a3 0b				call update_display 
1667			 
1667				;ld a, (os_view_af) 
1667 2a b8 e2			ld hl, (os_view_hl) 
166a ed 5b b6 e2		ld de, (os_view_de) 
166e ed 4b b4 e2		ld bc, (os_view_bc) 
1672 f1				pop af 
1673 c9				ret 
1674			 
1674			.bpschk:   
1674 cd f2 0a			call delay1s 
1677 3e 9f		ld a,display_row_4 + display_cols - 1 
1679 11 95 1b		        ld de, endprg 
167c cd 93 0b			call str_at_display 
167f cd a3 0b			call update_display 
1682 cd 9d 61			call cin_wait 
1685			 
1685 c3 d5 15			jp .bps1 
1688			 
1688			 
1688			display_reg_state: 
1688			 
1688				; to restore afterwards 
1688			 
1688 d5				push de 
1689 c5				push bc 
168a e5				push hl 
168b f5				push af 
168c			 
168c				; for use in here 
168c			 
168c c5				push bc 
168d d5				push de 
168e e5				push hl 
168f f5				push af 
1690			 
1690 cd 80 0b			call clear_display 
1693			 
1693 11 48 17			ld de, .regstate 
1696 3e 00			ld a, display_row_1 
1698 cd 93 0b			call str_at_display 
169b			 
169b				; display debug step 
169b			 
169b			 
169b 11 71 ee			ld de, debug_mark 
169e 3e 25			ld a, display_row_1+display_cols-3 
16a0 cd 93 0b			call str_at_display 
16a3			 
16a3				; display a 
16a3 11 64 17			ld de, .regstatea 
16a6 3e 28			ld a, display_row_2 
16a8 cd 93 0b			call str_at_display 
16ab			 
16ab e1				pop hl 
16ac			;	ld h,0 
16ac			;	ld l, a 
16ac 3e 2b			ld a, display_row_2+3 
16ae cd 33 15			call display_word_at 
16b1			 
16b1			 
16b1				; display hl 
16b1			 
16b1			 
16b1 11 58 17			ld de, .regstatehl 
16b4 3e 32			ld a, display_row_2+10 
16b6 cd 93 0b			call str_at_display 
16b9			 
16b9 e1				pop hl 
16ba 3e 35			ld a, display_row_2+13 
16bc cd 33 15			call display_word_at 
16bf			 
16bf				 
16bf				; display de 
16bf			 
16bf 11 5c 17			ld de, .regstatede 
16c2 3e 50			ld a, display_row_3 
16c4 cd 93 0b			call str_at_display 
16c7			 
16c7 e1				pop hl 
16c8			;	ld h,d 
16c8			;	ld l, e 
16c8 3e 53			ld a, display_row_3+3 
16ca cd 33 15			call display_word_at 
16cd			 
16cd			 
16cd				; display bc 
16cd			 
16cd 11 60 17			ld de, .regstatebc 
16d0 3e 5a			ld a, display_row_3+10 
16d2 cd 93 0b			call str_at_display 
16d5			 
16d5 e1				pop hl 
16d6			;	ld h,b 
16d6			;	ld l, c 
16d6 3e 5d			ld a, display_row_3+13 
16d8 cd 33 15			call display_word_at 
16db			 
16db			 
16db				; display dsp 
16db			 
16db 11 68 17			ld de, .regstatedsp 
16de 3e 78			ld a, display_row_4 
16e0 cd 93 0b			call str_at_display 
16e3			 
16e3				 
16e3 2a f8 e9			ld hl,(cli_data_sp) 
16e6 3e 7c			ld a, display_row_4+4 
16e8 cd 33 15			call display_word_at 
16eb			 
16eb				; display rsp 
16eb			 
16eb 11 6d 17			ld de, .regstatersp 
16ee 3e 82			ld a, display_row_4+10 
16f0 cd 93 0b			call str_at_display 
16f3			 
16f3				 
16f3 2a fc e9			ld hl,(cli_ret_sp) 
16f6 3e 86			ld a, display_row_4+14 
16f8 cd 33 15			call display_word_at 
16fb			 
16fb cd a3 0b			call update_display 
16fe			 
16fe			;	call delay1s 
16fe			;	call delay1s 
16fe			;	call delay1s 
16fe			 
16fe			 
16fe			;	call next_page_prompt 
16fe			 
16fe				; restore  
16fe			 
16fe f1				pop af 
16ff e1				pop hl 
1700 c1				pop bc 
1701 d1				pop de 
1702 c9				ret 
1703			 
1703 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1717 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
172c .. 00		.ptrstate:	db "Ptr State",0 
1736 .. 00		.ptrcliptr:     db "cli_ptr",0 
173e .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1748 .. 00		.regstate:	db "Reg State (1/0)",0 
1758 .. 00		.regstatehl:	db "HL:",0 
175c .. 00		.regstatede:	db "DE:",0 
1760 .. 00		.regstatebc:	db "BC:",0 
1764 .. 00		.regstatea:	db "A :",0 
1768 .. 00		.regstatedsp:	db "DSP:",0 
176d .. 00		.regstatersp:	db "RSP:",0 
1772			 
1772			display_dump_at_hl: 
1772 e5				push hl 
1773 d5				push de 
1774 c5				push bc 
1775 f5				push af 
1776			 
1776 22 ee e5			ld (os_cur_ptr),hl	 
1779 cd 80 0b			call clear_display 
177c cd 9f 1a			call dumpcont 
177f			;	call delay1s 
177f			;	call next_page_prompt 
177f			 
177f			 
177f f1				pop af 
1780 c1				pop bc 
1781 d1				pop de 
1782 e1				pop hl 
1783 c9				ret 
1784			 
1784			;if ENABLE_BASIC 
1784			;	include "nascombasic.asm" 
1784			;	basic: 
1784			;	include "forth/FORTH.ASM" 
1784			;endif 
1784			 
1784			; eof 
1784			 
1784			 
# End of file firmware_diags.asm
1784			  
1784			include "firmware_prompts.asm"  
1784			; Prompts  
1784			 
1784			; boot messages 
1784			 
1784 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1799 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
17a9			 
17a9			 
17a9			; config menus 
17a9			 
17a9 .. 00		prom_c3: db "Add Dictionary To File",0 
17c0 .. 00		prom_c2: db "Select Autoload File",0 
17d5 .. 00		prom_c2a: db "Disable Autoload File", 0 
17eb .. 00		prom_c2b: db "Select Storage Bank",0 
17ff .. 00		prom_c4: db "Settings",0 
1808 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1823 .. 00		prom_m4b:   db "Monitor",0 
182b .. 00		prom_c1: db "Hardware Diags",0 
183a			 
183a			 
183a .. 00		prom_notav:    db "Feature not available",0 
1850 .. 00		prom_empty:    db "",0 
1851			 
1851			; eof 
1851			 
# End of file firmware_prompts.asm
1851			  
1851			  
1851			; eof  
1851			  
# End of file firmware.asm
1851			 
1851			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1851			;if BASE_KEV  
1851			;baseram: equ 08000h 
1851			;endif 
1851			 
1851			;if BASE_SC114 
1851			;baseram:     equ    endofcode 
1851			;endif 
1851			 
1851			 
1851			; start system 
1851			 
1851			coldstart: 
1851				; set sp 
1851				; di/ei 
1851			 
1851 f3				di 
1852 31 00 f0			ld sp, tos 
1855			;	ei 
1855			 
1855			 
1855				; disable breakpoint by default 
1855			 
1855 3e 2a			ld a,'*' 
1857 32 bc e2			ld (os_view_disable),a 
185a			 
185a				; init hardware 
185a			 
185a				; init keyboard and screen hardware 
185a			 
185a cd 1c 01			call hardware_init 
185d			 
185d			 
185d cd f2 0a			call delay1s 
1860 3e 58			ld a, display_row_3+8 
1862 11 03 01			ld de, buildtime 
1865 cd 93 0b			call str_at_display 
1868 cd a3 0b			call update_display 
186b			 
186b cd f2 0a			call delay1s 
186e cd f2 0a			call delay1s 
1871 cd f2 0a			call delay1s 
1874			 
1874				; detect if any keys are held down to enable breakpoints at start up 
1874			 
1874 cd a5 61			call cin  
1877 fe 00			cp 0 
1879 28 03			jr z, .nokeys 
187b			 
187b				;call hardware_diags 
187b cd 0d 14			call config 
187e			 
187e			;	ld de, .bpen 
187e			;	ld a, display_row_4 
187e			;	call str_at_display 
187e			;	call update_display 
187e			; 
187e			;	ld a,0 
187e			;	ld (os_view_disable),a 
187e			; 
187e			;.bpwait: 
187e			;	call cin 
187e			;	cp 0 
187e			;	jr z, .bpwait 
187e			;	jr .nokeys 
187e			; 
187e			; 
187e			;.bpen:  db "Break points enabled!",0 
187e			 
187e			 
187e			 
187e			 
187e			 
187e			 
187e			.nokeys: 
187e			 
187e			 
187e				 
187e			 
187e			;jp  testkey 
187e			 
187e			;call storage_get_block_0 
187e			; 
187e			;ld hl, 0 
187e			;ld de, store_page 
187e			;call storage_read_block 
187e			 
187e				 
187e			;ld hl, 10 
187e			;ld de, store_page 
187e			;call storage_read_block 
187e			 
187e			 
187e			 
187e			 
187e			 
187e			;stop:	nop 
187e			;	jp stop 
187e			 
187e			 
187e			 
187e			main: 
187e cd 80 0b			call clear_display 
1881 cd a3 0b			call update_display 
1884			 
1884			 
1884			 
1884			;	call testlcd 
1884			 
1884			 
1884			 
1884 cd 95 1f			call forth_init 
1887			 
1887			 
1887			warmstart: 
1887 cd 6b 1f			call forth_warmstart 
188a			 
188a				; run startup word load 
188a			        ; TODO prevent this running at warmstart after crash  
188a			 
188a				if STARTUP_ENABLE 
188a					if STORAGE_SE 
188a						call forth_autoload 
188a					endif 
188a cd eb 5d				call forth_startup 
188d			 
188d			 
188d				endif 
188d			 
188d				; show free memory after boot 
188d 11 27 19			ld de, freeram 
1890 3e 00			ld a, display_row_1 
1892 cd 93 0b			call str_at_display 
1895			 
1895			; Or use heap_size word???? 
1895 21 b1 e2			ld hl, heap_end 
1898 11 cd 61			ld de, heap_start 
189b ed 52			sbc hl, de 
189d e5				push hl 
189e 7c				ld a,h	         	 
189f 21 d0 e5			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
18a2 cd ae 10			call hexout 
18a5 e1			   	pop hl 
18a6			 
18a6 7d				ld a,l 
18a7 21 d2 e5			ld hl, os_word_scratch+2 
18aa cd ae 10			call hexout 
18ad 21 d4 e5			ld hl, os_word_scratch+4 
18b0 3e 00			ld a, 0 
18b2 77				ld (hl),a 
18b3 11 d0 e5			ld de, os_word_scratch 
18b6 3e 0d			ld a, display_row_1 + 13 
18b8 cd 93 0b			call str_at_display 
18bb cd a3 0b			call update_display 
18be			 
18be			 
18be				;call demo 
18be			 
18be			 
18be				; init scratch input area for cli commands 
18be			 
18be 21 f2 e5			ld hl, os_cli_cmd 
18c1 3e 00			ld a,0 
18c3 77				ld (hl),a 
18c4 23				inc hl 
18c5 77				ld (hl),a 
18c6			 
18c6 3e 00			ld a,0 
18c8 32 f1 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
18cb			 
18cb 32 ee e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
18ce 32 ef e5			ld (os_cur_ptr+1),a	 
18d1			 
18d1 32 d0 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
18d4 32 d1 e5			ld (os_word_scratch+1),a	 
18d7				 
18d7			 
18d7				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18d7 21 f2 e5			ld hl, os_cli_cmd 
18da			 
18da 3e 00			ld a, 0		 ; init cli input 
18dc 77				ld (hl), a 
18dd 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18df			cli: 
18df				; show cli prompt 
18df				;push af 
18df				;ld a, 0 
18df				;ld de, prompt 
18df				;call str_at_display 
18df			 
18df				;call update_display 
18df				;pop af 
18df				;inc a 
18df				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18df 0e 00			ld c, 0 
18e1 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18e3 1e 28			ld e, 40 
18e5			 
18e5 21 f2 e5			ld hl, os_cli_cmd 
18e8			 
18e8				STACKFRAME OFF $fefe $9f9f 
18e8				if DEBUG_STACK_IMB 
18e8					if OFF 
18e8						exx 
18e8						ld de, $fefe 
18e8						ld a, d 
18e8						ld hl, curframe 
18e8						call hexout 
18e8						ld a, e 
18e8						ld hl, curframe+2 
18e8						call hexout 
18e8						ld hl, $fefe 
18e8						push hl 
18e8						ld hl, $9f9f 
18e8						push hl 
18e8						exx 
18e8					endif 
18e8				endif 
18e8			endm 
# End of macro STACKFRAME
18e8			 
18e8 cd da 0d			call input_str 
18eb			 
18eb				STACKFRAMECHK OFF $fefe $9f9f 
18eb				if DEBUG_STACK_IMB 
18eb					if OFF 
18eb						exx 
18eb						ld hl, $9f9f 
18eb						pop de   ; $9f9f 
18eb						call cmp16 
18eb						jr nz, .spnosame 
18eb						ld hl, $fefe 
18eb						pop de   ; $fefe 
18eb						call cmp16 
18eb						jr z, .spfrsame 
18eb						.spnosame: call showsperror 
18eb						.spfrsame: nop 
18eb						exx 
18eb					endif 
18eb				endif 
18eb			endm 
# End of macro STACKFRAMECHK
18eb			 
18eb				; copy input to last command 
18eb			 
18eb 21 f2 e5			ld hl, os_cli_cmd 
18ee 11 f1 e6			ld de, os_last_cmd 
18f1 01 ff 00			ld bc, 255 
18f4 ed b0			ldir 
18f6			 
18f6				; wipe current buffer 
18f6			 
18f6			;	ld a, 0 
18f6			;	ld hl, os_cli_cmd 
18f6			;	ld de, os_cli_cmd+1 
18f6			;	ld bc, 254 
18f6			;	ldir 
18f6				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18f6			;	call strcpy 
18f6			;	ld a, 0 
18f6			;	ld (hl), a 
18f6			;	inc hl 
18f6			;	ld (hl), a 
18f6			;	inc hl 
18f6			;	ld (hl), a 
18f6			 
18f6				; switch frame buffer to program  
18f6			 
18f6 21 16 ed				ld hl, display_fb1 
18f9 22 d2 eb				ld (display_fb_active), hl 
18fc			 
18fc			;	nop 
18fc				STACKFRAME ON $fbfe $8f9f 
18fc				if DEBUG_STACK_IMB 
18fc					if ON 
18fc						exx 
18fc						ld de, $fbfe 
18fc						ld a, d 
18fc						ld hl, curframe 
18fc						call hexout 
18fc						ld a, e 
18fc						ld hl, curframe+2 
18fc						call hexout 
18fc						ld hl, $fbfe 
18fc						push hl 
18fc						ld hl, $8f9f 
18fc						push hl 
18fc						exx 
18fc					endif 
18fc				endif 
18fc			endm 
# End of macro STACKFRAME
18fc				; first time into the parser so pass over the current scratch pad 
18fc 21 f2 e5			ld hl,os_cli_cmd 
18ff				; tokenise the entered statement(s) in HL 
18ff cd 13 20			call forthparse 
1902			        ; exec forth statements in top of return stack 
1902 cd 53 20			call forthexec 
1905				;call forthexec_cleanup 
1905			;	call parsenext 
1905			 
1905				STACKFRAMECHK ON $fbfe $8f9f 
1905				if DEBUG_STACK_IMB 
1905					if ON 
1905						exx 
1905						ld hl, $8f9f 
1905						pop de   ; $8f9f 
1905						call cmp16 
1905						jr nz, .spnosame 
1905						ld hl, $fbfe 
1905						pop de   ; $fbfe 
1905						call cmp16 
1905						jr z, .spfrsame 
1905						.spnosame: call showsperror 
1905						.spfrsame: nop 
1905						exx 
1905					endif 
1905				endif 
1905			endm 
# End of macro STACKFRAMECHK
1905				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1905			 
1905 3e 78			ld a, display_row_4 
1907 11 39 19			ld de, endprog 
190a			 
190a cd a3 0b			call update_display		 
190d			 
190d cd 97 1b			call next_page_prompt 
1910			 
1910				; switch frame buffer to cli 
1910			 
1910 21 b7 ed				ld hl, display_fb0 
1913 22 d2 eb				ld (display_fb_active), hl 
1916			 
1916			 
1916 cd 80 0b		        call clear_display 
1919 cd a3 0b			call update_display		 
191c			 
191c 21 f2 e5			ld hl, os_cli_cmd 
191f			 
191f 3e 00			ld a, 0		 ; init cli input 
1921 77				ld (hl), a 
1922			 
1922				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1922			 
1922				; now on last line 
1922			 
1922				; TODO scroll screen up 
1922			 
1922				; TODO instead just clear screen and place at top of screen 
1922			 
1922			;	ld a, 0 
1922			;	ld (f_cursor_ptr),a 
1922			 
1922				;call clear_display 
1922				;call update_display 
1922			 
1922				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1922 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1924 c3 df 18			jp cli 
1927			 
1927 .. 00		freeram: db "Free bytes: $",0 
1935 ..			asc: db "1A2F" 
1939 .. 00		endprog: db "End prog...",0 
1945			 
1945			testenter2:   
1945 21 fd e2			ld hl,scratch+50 
1948 22 ee e5			ld (os_cur_ptr),hl 
194b c3 df 18			jp cli 
194e			 
194e			testenter:  
194e			 
194e 21 35 19			ld hl,asc 
1951			;	ld a,(hl) 
1951			;	call nibble2val 
1951 cd 04 11			call get_byte 
1954			 
1954			 
1954			;	ld a,(hl) 
1954			;	call atohex 
1954			 
1954			;	call fourehexhl 
1954 32 fd e2			ld (scratch+50),a 
1957			 
1957			 
1957			 
1957 21 37 19			ld hl,asc+2 
195a			;	ld a, (hl) 
195a			;	call nibble2val 
195a cd 04 11			call get_byte 
195d			 
195d			;	call fourehexhl 
195d 32 ff e2			ld (scratch+52),a 
1960				 
1960 21 fd e2			ld hl,scratch+50 
1963 22 ee e5			ld (os_cur_ptr),hl 
1966 c3 df 18			jp cli 
1969			 
1969			enter:	 
1969 3a cf e2			ld a,(scratch+4) 
196c fe 00			cp 0 
196e 28 0c			jr z, .entercont 
1970				; no, not a null term line so has an address to work out.... 
1970			 
1970 21 cd e2			ld hl,scratch+2 
1973 cd 64 11			call get_word_hl 
1976			 
1976 22 ee e5			ld (os_cur_ptr),hl	 
1979 c3 df 18			jp cli 
197c			 
197c			 
197c			.entercont:  
197c			 
197c 21 cd e2			ld hl, scratch+2 
197f cd 04 11			call get_byte 
1982			 
1982 2a ee e5		   	ld hl,(os_cur_ptr) 
1985 77					ld (hl),a 
1986 23					inc hl 
1987 22 ee e5				ld (os_cur_ptr),hl 
198a				 
198a			; get byte  
198a			 
198a			 
198a c3 df 18			jp cli 
198d			 
198d			 
198d			; basic monitor support 
198d			 
198d			monitor: 
198d				;  
198d cd 80 0b			call clear_display 
1990 3e 00			ld a, 0 
1992 11 da 19			ld de, .monprompt 
1995 cd 93 0b			call str_at_display 
1998 cd a3 0b			call update_display 
199b			 
199b				; get a monitor command 
199b			 
199b 0e 00			ld c, 0     ; entry at top left 
199d 16 64			ld d, 100   ; max buffer size 
199f 1e 0f			ld e, 15    ; input scroll area 
19a1 3e 00			ld a, 0     ; init string 
19a3 21 c9 e4			ld hl, os_input 
19a6 77				ld (hl), a 
19a7 23				inc hl 
19a8 77				ld (hl), a 
19a9 21 c9 e4			ld hl, os_input 
19ac 3e 01			ld a, 1     ; init string 
19ae cd da 0d			call input_str 
19b1			 
19b1 cd 80 0b		        call clear_display 
19b4 cd a3 0b			call update_display		 
19b7			 
19b7 3a c9 e4			ld a, (os_input) 
19ba cd 02 12			call toUpper 
19bd fe 48		        cp 'H' 
19bf 28 6f		        jr z, .monhelp 
19c1 fe 44			cp 'D'		; dump 
19c3 ca 51 1a			jp z, .mondump	 
19c6 fe 43			cp 'C'		; dump 
19c8 ca 6b 1a			jp z, .moncdump	 
19cb fe 4d			cp 'M'		; dump 
19cd ca dc 19			jp z, .moneditstart 
19d0 fe 55			cp 'U'		; dump 
19d2 28 14			jr z, .monedit	 
19d4 fe 51			cp 'Q'		; dump 
19d6 c8				ret z	 
19d7			 
19d7			 
19d7				; TODO "S" to access symbol by name and not need the address 
19d7				; TODO "F" to find a string in memory 
19d7			 
19d7 c3 8d 19			jp monitor 
19da			 
19da .. 00		.monprompt: db ">", 0 
19dc			 
19dc			.moneditstart: 
19dc				; get starting address 
19dc			 
19dc 21 cb e4			ld hl,os_input+2 
19df cd 64 11			call get_word_hl 
19e2			 
19e2 22 ee e5			ld (os_cur_ptr),hl	 
19e5			 
19e5 c3 8d 19			jp monitor 
19e8			 
19e8			.monedit: 
19e8				; get byte to load 
19e8			 
19e8 21 cb e4			ld hl,os_input+2 
19eb cd 04 11			call get_byte 
19ee			 
19ee				; get address to update 
19ee 2a ee e5			ld hl, (os_cur_ptr) 
19f1			 
19f1				; update byte 
19f1			 
19f1 77				ld (hl), a 
19f2			 
19f2				; move to next address and save it 
19f2			 
19f2 23				inc hl 
19f3 22 ee e5			ld (os_cur_ptr),hl	 
19f6			 
19f6 c3 8d 19			jp monitor 
19f9			 
19f9			 
19f9 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1a0d .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1a29 .. 00		.monhelptext3:  db "Q-Quit",0 
1a30			        
1a30			.monhelp: 
1a30 3e 00			ld a, display_row_1 
1a32 11 f9 19		        ld de, .monhelptext1 
1a35			 
1a35 cd 93 0b			call str_at_display 
1a38 3e 28			ld a, display_row_2 
1a3a 11 0d 1a		        ld de, .monhelptext2 
1a3d					 
1a3d cd 93 0b			call str_at_display 
1a40 3e 50			ld a, display_row_3 
1a42 11 29 1a		        ld de, .monhelptext3 
1a45					 
1a45 cd 93 0b			call str_at_display 
1a48 cd a3 0b			call update_display		 
1a4b			 
1a4b cd 97 1b			call next_page_prompt 
1a4e c3 8d 19			jp monitor 
1a51			 
1a51			.mondump:    
1a51 21 cb e4			ld hl,os_input+2 
1a54 cd 64 11			call get_word_hl 
1a57			 
1a57 22 ee e5			ld (os_cur_ptr),hl	 
1a5a cd 9f 1a			call dumpcont 
1a5d 3e 78			ld a, display_row_4 
1a5f 11 39 19			ld de, endprog 
1a62			 
1a62 cd a3 0b			call update_display		 
1a65			 
1a65 cd 97 1b			call next_page_prompt 
1a68 c3 8d 19			jp monitor 
1a6b			.moncdump: 
1a6b cd 9f 1a			call dumpcont 
1a6e 3e 78			ld a, display_row_4 
1a70 11 39 19			ld de, endprog 
1a73			 
1a73 cd a3 0b			call update_display		 
1a76			 
1a76 cd 97 1b			call next_page_prompt 
1a79 c3 8d 19			jp monitor 
1a7c			 
1a7c			 
1a7c			; TODO symbol access  
1a7c			 
1a7c			.symbols:     ;; A list of symbols that can be called up  
1a7c b7 ed			dw display_fb0 
1a7e .. 00			db "fb0",0  
1a82 84 ea		     	dw store_page 
1a84 .. 00			db "store_page",0 
1a8f			 
1a8f			 
1a8f			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1a8f			 
1a8f 3a cc e2			ld a,(scratch+1) 
1a92 fe 00			cp 0 
1a94 28 09			jr z, dumpcont 
1a96			 
1a96				; no, not a null term line so has an address to work out.... 
1a96			 
1a96 21 cd e2			ld hl,scratch+2 
1a99 cd 64 11			call get_word_hl 
1a9c			 
1a9c 22 ee e5			ld (os_cur_ptr),hl	 
1a9f			 
1a9f			 
1a9f			 
1a9f			dumpcont: 
1a9f			 
1a9f				; dump bytes at ptr 
1a9f			 
1a9f			 
1a9f 3e 00			ld a, display_row_1 
1aa1 2a d2 eb			ld hl, (display_fb_active) 
1aa4 cd ad 0d			call addatohl 
1aa7 cd cf 1a			call .dumpbyterow 
1aaa			 
1aaa 3e 28			ld a, display_row_2 
1aac 2a d2 eb			ld hl, (display_fb_active) 
1aaf cd ad 0d			call addatohl 
1ab2 cd cf 1a			call .dumpbyterow 
1ab5			 
1ab5			 
1ab5 3e 50			ld a, display_row_3 
1ab7 2a d2 eb			ld hl, (display_fb_active) 
1aba cd ad 0d			call addatohl 
1abd cd cf 1a			call .dumpbyterow 
1ac0			 
1ac0 3e 78			ld a, display_row_4 
1ac2 2a d2 eb			ld hl, (display_fb_active) 
1ac5 cd ad 0d			call addatohl 
1ac8 cd cf 1a			call .dumpbyterow 
1acb			 
1acb cd a3 0b			call update_display 
1ace			;		jp cli 
1ace c9				ret 
1acf			 
1acf			.dumpbyterow: 
1acf			 
1acf				;push af 
1acf			 
1acf e5				push hl 
1ad0			 
1ad0				; calc where to poke the ascii 
1ad0			if display_cols == 20 
1ad0				ld a, 16 
1ad0			else 
1ad0 3e 1f			ld a, 31 
1ad2			endif 
1ad2			 
1ad2 cd ad 0d			call addatohl 
1ad5 22 d0 e5			ld (os_word_scratch),hl  		; save pos for later 
1ad8			 
1ad8			 
1ad8			; display decoding address 
1ad8 2a ee e5		   	ld hl,(os_cur_ptr) 
1adb			 
1adb 7c				ld a,h 
1adc e1				pop hl 
1add e5				push hl 
1ade			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1ade cd ae 10			call hexout 
1ae1 2a ee e5		   	ld hl,(os_cur_ptr) 
1ae4			 
1ae4 7d				ld a,l 
1ae5 e1				pop hl 
1ae6 23				inc hl 
1ae7 23				inc hl 
1ae8 e5				push hl 
1ae9			;	ld hl, os_word_scratch+2 
1ae9 cd ae 10			call hexout 
1aec e1				pop hl 
1aed 23				inc hl 
1aee 23				inc hl 
1aef				;ld hl, os_word_scratch+4 
1aef 3e 3a			ld a, ':' 
1af1 77				ld (hl),a 
1af2 23				inc hl 
1af3				;ld a, 0 
1af3				;ld (hl),a 
1af3				;ld de, os_word_scratch 
1af3				;pop af 
1af3				;push af 
1af3			;		ld a, display_row_2 
1af3			;		call str_at_display 
1af3			;		call update_display 
1af3			 
1af3			 
1af3			;pop af 
1af3			;	add 5 
1af3			 
1af3			if display_cols == 20 
1af3				ld b, 4 
1af3			else 
1af3 06 08			ld b, 8 
1af5			endif	 
1af5			 
1af5			.dumpbyte: 
1af5 c5				push bc 
1af6 e5				push hl 
1af7			 
1af7			 
1af7 2a ee e5		   	ld hl,(os_cur_ptr) 
1afa 7e					ld a,(hl) 
1afb			 
1afb					; poke the ascii to display 
1afb 2a d0 e5				ld hl,(os_word_scratch) 
1afe 77					ld (hl),a 
1aff 23					inc hl 
1b00 22 d0 e5				ld (os_word_scratch),hl 
1b03			 
1b03					 
1b03			 
1b03			 
1b03 e1					pop hl 
1b04 e5					push hl 
1b05			 
1b05 cd ae 10				call hexout 
1b08			 
1b08					 
1b08 2a ee e5		   	ld hl,(os_cur_ptr) 
1b0b 23				inc hl 
1b0c 22 ee e5		   	ld (os_cur_ptr),hl 
1b0f			 
1b0f e1					pop hl 
1b10 23					inc hl 
1b11 23					inc hl 
1b12 23					inc hl 
1b13			 
1b13			 
1b13			 
1b13					;ld a,0 
1b13					;ld (os_word_scratch+2),a 
1b13					;pop af 
1b13					;push af 
1b13			 
1b13					;ld de, os_word_scratch 
1b13					;call str_at_display 
1b13			;		call update_display 
1b13			;		pop af 
1b13 c1					pop bc 
1b14 c6 03				add 3 
1b16 10 dd			djnz .dumpbyte 
1b18			 
1b18				 
1b18			 
1b18 c9				ret 
1b19			 
1b19			jump:	 
1b19			 
1b19 21 cd e2			ld hl,scratch+2 
1b1c cd 64 11			call get_word_hl 
1b1f				;ld hl,(scratch+2) 
1b1f				;call fourehexhl 
1b1f			 
1b1f 22 ee e5			ld (os_cur_ptr),hl	 
1b22			 
1b22 e9				jp (hl) 
1b23			 
1b23			 
1b23			 
1b23			; TODO implement a basic monitor mode to start with 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			; testing and demo code during development 
1b23			 
1b23			 
1b23 .. 00		str1: db "Enter some text...",0 
1b36 .. 00		clear: db "                    ",0 
1b4b			 
1b4b			demo: 
1b4b			 
1b4b			 
1b4b			 
1b4b			;	call update_display 
1b4b			 
1b4b				; init scratch input area for testing 
1b4b 21 cb e2			ld hl, scratch	 
1b4e 3e 00			ld a,0 
1b50 77				ld (hl),a 
1b51			 
1b51			 
1b51 3e 28		            LD   A, display_row_2 
1b53			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b53 11 23 1b		            LD   DE, str1 
1b56 cd 93 0b			call str_at_display 
1b59			 
1b59			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b59			cloop:	 
1b59 3e 50		            LD   A, display_row_3 
1b5b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b5b 11 36 1b		            LD   DE, clear 
1b5e			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1b5e cd 93 0b				call str_at_display 
1b61 3e 78			ld a, display_row_4 
1b63 11 93 1b			ld de, prompt 
1b66			 
1b66 cd 93 0b				call str_at_display 
1b69 cd a3 0b			call update_display 
1b6c			 
1b6c 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1b6e 16 0a			ld d, 10 
1b70 21 cb e2			ld hl, scratch	 
1b73 cd da 0d			call input_str 
1b76			 
1b76			;	call clear_display 
1b76			;'	call update_display 
1b76			 
1b76 3e 00		            LD   A, display_row_1 
1b78			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b78 11 36 1b		            LD   DE, clear 
1b7b cd 93 0b				call str_at_display 
1b7e			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b7e 3e 00		            LD   A, display_row_1 
1b80			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b80 11 cb e2		            LD   DE, scratch 
1b83			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b83 cd 93 0b				call str_at_display 
1b86 cd a3 0b			call update_display 
1b89			 
1b89 3e 00				ld a,0 
1b8b 21 cb e2			ld hl, scratch 
1b8e 77				ld (hl),a 
1b8f			 
1b8f 00				nop 
1b90 c3 59 1b			jp cloop 
1b93			 
1b93			 
1b93			 
1b93			; OS Prompt 
1b93			 
1b93 .. 00		prompt: db ">",0 
1b95 .. 00		endprg: db "?",0 
1b97			 
1b97			 
1b97			; handy next page prompt 
1b97			next_page_prompt: 
1b97 e5				push hl 
1b98 d5				push de 
1b99 f5				push af 
1b9a c5				push bc 
1b9b			 
1b9b 3e 9f			ld a,display_row_4 + display_cols - 1 
1b9d 11 95 1b		        ld de, endprg 
1ba0 cd 93 0b			call str_at_display 
1ba3 cd a3 0b			call update_display 
1ba6 cd 9d 61			call cin_wait 
1ba9 c1				pop bc 
1baa f1				pop af 
1bab d1				pop de 
1bac e1				pop hl 
1bad			 
1bad			 
1bad c9				ret 
1bae			 
1bae			 
1bae			; forth parser 
1bae			 
1bae			; My forth kernel 
1bae			include "forth_kernel.asm" 
1bae			; 
1bae			; kernel to the forth OS 
1bae			 
1bae			DS_TYPE_STR: equ 1     ; string type 
1bae			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1bae			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1bae			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1bae			 
1bae			FORTH_PARSEV1: equ 0 
1bae			FORTH_PARSEV2: equ 0 
1bae			FORTH_PARSEV3: equ 0 
1bae			FORTH_PARSEV4: equ 0 
1bae			FORTH_PARSEV5: equ 1 
1bae			 
1bae			;if FORTH_PARSEV5 
1bae			;	FORTH_END_BUFFER: equ 0 
1bae			;else 
1bae			FORTH_END_BUFFER: equ 127 
1bae			;endif 
1bae			 
1bae			FORTH_TRUE: equ 1 
1bae			FORTH_FALSE: equ 0 
1bae			 
1bae			if FORTH_PARSEV4 
1bae			include "forth_stackops.asm" 
1bae			endif 
1bae			 
1bae			if FORTH_PARSEV5 
1bae			include "forth_stackopsv5.asm" 
1bae			 
1bae			; Stack operations for v5 parser on wards 
1bae			; * DATA stack 
1bae			; * LOOP stack 
1bae			; * RETURN stack 
1bae			 
1bae			 
1bae			 
1bae			FORTH_CHK_DSP_UNDER: macro 
1bae				push hl 
1bae				push de 
1bae				ld hl,(cli_data_sp) 
1bae				ld de, cli_data_stack 
1bae				call cmp16 
1bae				jp c, fault_dsp_under 
1bae				pop de 
1bae				pop hl 
1bae				endm 
1bae			 
1bae			 
1bae			FORTH_CHK_RSP_UNDER: macro 
1bae				push hl 
1bae				push de 
1bae				ld hl,(cli_ret_sp) 
1bae				ld de, cli_ret_stack 
1bae				call cmp16 
1bae				jp c, fault_rsp_under 
1bae				pop de 
1bae				pop hl 
1bae				endm 
1bae			 
1bae			FORTH_CHK_LOOP_UNDER: macro 
1bae				push hl 
1bae				push de 
1bae				ld hl,(cli_loop_sp) 
1bae				ld de, cli_loop_stack 
1bae				call cmp16 
1bae				jp c, fault_loop_under 
1bae				pop de 
1bae				pop hl 
1bae				endm 
1bae			 
1bae			FORTH_ERR_TOS_NOTSTR: macro 
1bae				; TOSO might need more for checks when used 
1bae				push af 
1bae				ld a,(hl) 
1bae				cp DS_TYPE_STR 
1bae				jp nz, type_faultn   
1bae				pop af 
1bae				endm 
1bae			 
1bae			FORTH_ERR_TOS_NOTNUM: macro 
1bae				push af 
1bae				ld a,(hl) 
1bae				cp DS_TYPE_INUM 
1bae				jp nz, type_faultn   
1bae				pop af 
1bae				endm 
1bae			 
1bae			 
1bae			; increase data stack pointer and save hl to it 
1bae				 
1bae			FORTH_DSP_NEXT: macro 
1bae				call macro_forth_dsp_next 
1bae				endm 
1bae			 
1bae			 
1bae			macro_forth_dsp_next: 
1bae				if DEBUG_FORTH_STACK_GUARD 
1bae cd b5 5e				call check_stacks 
1bb1				endif 
1bb1 e5				push hl 
1bb2 d5				push de 
1bb3 eb				ex de,hl 
1bb4 2a f8 e9			ld hl,(cli_data_sp) 
1bb7 23				inc hl 
1bb8 23				inc hl 
1bb9			 
1bb9			; PARSEV5 
1bb9 23				inc hl 
1bba 22 f8 e9			ld (cli_data_sp),hl 
1bbd 73				ld (hl), e 
1bbe 23				inc hl 
1bbf 72				ld (hl), d 
1bc0 d1				pop de 
1bc1 e1				pop hl 
1bc2				if DEBUG_FORTH_STACK_GUARD 
1bc2 cd b5 5e				call check_stacks 
1bc5				endif 
1bc5 c9				ret 
1bc6			 
1bc6			 
1bc6			; increase ret stack pointer and save hl to it 
1bc6				 
1bc6			FORTH_RSP_NEXT: macro 
1bc6				call macro_forth_rsp_next 
1bc6				endm 
1bc6			 
1bc6			macro_forth_rsp_next: 
1bc6				if DEBUG_FORTH_STACK_GUARD 
1bc6 cd b5 5e				call check_stacks 
1bc9				endif 
1bc9 e5				push hl 
1bca d5				push de 
1bcb eb				ex de,hl 
1bcc 2a fc e9			ld hl,(cli_ret_sp) 
1bcf 23				inc hl 
1bd0 23				inc hl 
1bd1 22 fc e9			ld (cli_ret_sp),hl 
1bd4 73				ld (hl), e 
1bd5 23				inc hl 
1bd6 72				ld (hl), d 
1bd7 d1				pop de 
1bd8 e1				pop hl 
1bd9				if DEBUG_FORTH_STACK_GUARD 
1bd9 cd b5 5e				call check_stacks 
1bdc				endif 
1bdc c9				ret 
1bdd			 
1bdd			; get current ret stack pointer and save to hl  
1bdd				 
1bdd			FORTH_RSP_TOS: macro 
1bdd				call macro_forth_rsp_tos 
1bdd				endm 
1bdd			 
1bdd			macro_forth_rsp_tos: 
1bdd				;push de 
1bdd 2a fc e9			ld hl,(cli_ret_sp) 
1be0 cd 18 1c			call loadhlptrtohl 
1be3				;ld e, (hl) 
1be3				;inc hl 
1be3				;ld d, (hl) 
1be3				;ex de, hl 
1be3					if DEBUG_FORTH_WORDS 
1be3			;			DMARK "RST" 
1be3						CALLMONITOR 
1be3 cd ae 15			call break_point_state  
1be6				endm  
# End of macro CALLMONITOR
1be6					endif 
1be6				;pop de 
1be6 c9				ret 
1be7			 
1be7			; pop ret stack pointer 
1be7				 
1be7			FORTH_RSP_POP: macro 
1be7				call macro_forth_rsp_pop 
1be7				endm 
1be7			 
1be7			 
1be7			macro_forth_rsp_pop: 
1be7				if DEBUG_FORTH_STACK_GUARD 
1be7			;		DMARK "RPP" 
1be7 cd b5 5e				call check_stacks 
1bea					FORTH_CHK_RSP_UNDER 
1bea e5				push hl 
1beb d5				push de 
1bec 2a fc e9			ld hl,(cli_ret_sp) 
1bef 11 b6 e9			ld de, cli_ret_stack 
1bf2 cd cb 0d			call cmp16 
1bf5 da c9 5f			jp c, fault_rsp_under 
1bf8 d1				pop de 
1bf9 e1				pop hl 
1bfa				endm 
# End of macro FORTH_CHK_RSP_UNDER
1bfa				endif 
1bfa e5				push hl 
1bfb 2a fc e9			ld hl,(cli_ret_sp) 
1bfe			 
1bfe			 
1bfe				if FORTH_ENABLE_FREE 
1bfe			 
1bfe					; get pointer 
1bfe			 
1bfe					push de 
1bfe					push hl 
1bfe			 
1bfe					ld e, (hl) 
1bfe					inc hl 
1bfe					ld d, (hl) 
1bfe			 
1bfe					ex de, hl 
1bfe					call free 
1bfe			 
1bfe					pop hl 
1bfe					pop de 
1bfe			 
1bfe			 
1bfe				endif 
1bfe			 
1bfe			 
1bfe 2b				dec hl 
1bff 2b				dec hl 
1c00 22 fc e9			ld (cli_ret_sp), hl 
1c03				; do stack underflow checks 
1c03 e1				pop hl 
1c04				if DEBUG_FORTH_STACK_GUARD 
1c04 cd b5 5e				call check_stacks 
1c07					FORTH_CHK_RSP_UNDER 
1c07 e5				push hl 
1c08 d5				push de 
1c09 2a fc e9			ld hl,(cli_ret_sp) 
1c0c 11 b6 e9			ld de, cli_ret_stack 
1c0f cd cb 0d			call cmp16 
1c12 da c9 5f			jp c, fault_rsp_under 
1c15 d1				pop de 
1c16 e1				pop hl 
1c17				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c17				endif 
1c17 c9				ret 
1c18			 
1c18			 
1c18			 
1c18			; routine to load word pointed to by hl into hl 
1c18			 
1c18			loadhlptrtohl: 
1c18			 
1c18 d5				push de 
1c19 5e				ld e, (hl) 
1c1a 23				inc hl 
1c1b 56				ld d, (hl) 
1c1c eb				ex de, hl 
1c1d d1				pop de 
1c1e			 
1c1e c9				ret 
1c1f			 
1c1f			 
1c1f			 
1c1f			 
1c1f			 
1c1f			; push a number held in HL onto the data stack 
1c1f			; entry point for pushing a value when already in hl used in function above 
1c1f			 
1c1f			forth_push_numhl: 
1c1f			 
1c1f e5				push hl    ; save value to push 
1c20			 
1c20			if DEBUG_FORTH_PUSH 
1c20				; see if disabled 
1c20			 
1c20			 
1c20 f5				push af 
1c21 3a bc e2			ld a, (os_view_disable) 
1c24 fe 2a			cp '*' 
1c26 28 34			jr z, .pskip2 
1c28 e5				push hl 
1c29 e5			push hl 
1c2a cd 80 0b			call clear_display 
1c2d e1			pop hl 
1c2e 7c				ld a,h 
1c2f 21 d0 e5			ld hl, os_word_scratch 
1c32 cd ae 10			call hexout 
1c35 e1				pop hl 
1c36 7d				ld a,l 
1c37 21 d2 e5			ld hl, os_word_scratch+2 
1c3a cd ae 10			call hexout 
1c3d			 
1c3d 21 d4 e5			ld hl, os_word_scratch+4 
1c40 3e 00			ld a,0 
1c42 77				ld (hl),a 
1c43 11 d0 e5			ld de,os_word_scratch 
1c46 3e 28				ld a, display_row_2 
1c48 cd 93 0b				call str_at_display 
1c4b 11 51 4a			ld de, .push_num 
1c4e 3e 00			ld a, display_row_1 
1c50			 
1c50 cd 93 0b				call str_at_display 
1c53			 
1c53			 
1c53 cd a3 0b			call update_display 
1c56 cd f2 0a			call delay1s 
1c59 cd f2 0a			call delay1s 
1c5c			.pskip2:  
1c5c			 
1c5c f1				pop af 
1c5d			endif	 
1c5d			 
1c5d			 
1c5d				FORTH_DSP_NEXT 
1c5d cd ae 1b			call macro_forth_dsp_next 
1c60				endm 
# End of macro FORTH_DSP_NEXT
1c60			 
1c60 2a f8 e9			ld hl, (cli_data_sp) 
1c63			 
1c63				; save item type 
1c63 3e 02			ld a,  DS_TYPE_INUM 
1c65 77				ld (hl), a 
1c66 23				inc hl 
1c67			 
1c67				; get word off stack 
1c67 d1				pop de 
1c68 7b				ld a,e 
1c69 77				ld (hl), a 
1c6a 23				inc hl 
1c6b 7a				ld a,d 
1c6c 77				ld (hl), a 
1c6d			 
1c6d			if DEBUG_FORTH_PUSH 
1c6d 2b				dec hl 
1c6e 2b				dec hl 
1c6f 2b				dec hl 
1c70						DMARK "PH5" 
1c70 f5				push af  
1c71 3a 85 1c			ld a, (.dmark)  
1c74 32 71 ee			ld (debug_mark),a  
1c77 3a 86 1c			ld a, (.dmark+1)  
1c7a 32 72 ee			ld (debug_mark+1),a  
1c7d 3a 87 1c			ld a, (.dmark+2)  
1c80 32 73 ee			ld (debug_mark+2),a  
1c83 18 03			jr .pastdmark  
1c85 ..			.dmark: db "PH5"  
1c88 f1			.pastdmark: pop af  
1c89			endm  
# End of macro DMARK
1c89				CALLMONITOR 
1c89 cd ae 15			call break_point_state  
1c8c				endm  
# End of macro CALLMONITOR
1c8c			endif	 
1c8c			 
1c8c c9				ret 
1c8d			 
1c8d			 
1c8d			; Push a string to stack pointed to by hl 
1c8d			 
1c8d			forth_push_str: 
1c8d			 
1c8d			if DEBUG_FORTH_PUSH 
1c8d						DMARK "PSQ" 
1c8d f5				push af  
1c8e 3a a2 1c			ld a, (.dmark)  
1c91 32 71 ee			ld (debug_mark),a  
1c94 3a a3 1c			ld a, (.dmark+1)  
1c97 32 72 ee			ld (debug_mark+1),a  
1c9a 3a a4 1c			ld a, (.dmark+2)  
1c9d 32 73 ee			ld (debug_mark+2),a  
1ca0 18 03			jr .pastdmark  
1ca2 ..			.dmark: db "PSQ"  
1ca5 f1			.pastdmark: pop af  
1ca6			endm  
# End of macro DMARK
1ca6				CALLMONITOR 
1ca6 cd ae 15			call break_point_state  
1ca9				endm  
# End of macro CALLMONITOR
1ca9			endif	 
1ca9			    
1ca9 e5				push hl 
1caa e5				push hl 
1cab			 
1cab			;	ld a, 0   ; find end of string 
1cab cd 0b 12			call strlenz 
1cae			if DEBUG_FORTH_PUSH 
1cae						DMARK "PQ2" 
1cae f5				push af  
1caf 3a c3 1c			ld a, (.dmark)  
1cb2 32 71 ee			ld (debug_mark),a  
1cb5 3a c4 1c			ld a, (.dmark+1)  
1cb8 32 72 ee			ld (debug_mark+1),a  
1cbb 3a c5 1c			ld a, (.dmark+2)  
1cbe 32 73 ee			ld (debug_mark+2),a  
1cc1 18 03			jr .pastdmark  
1cc3 ..			.dmark: db "PQ2"  
1cc6 f1			.pastdmark: pop af  
1cc7			endm  
# End of macro DMARK
1cc7				CALLMONITOR 
1cc7 cd ae 15			call break_point_state  
1cca				endm  
# End of macro CALLMONITOR
1cca			endif	 
1cca eb				ex de, hl 
1ccb e1				pop hl   ; get ptr to start of string 
1ccc			if DEBUG_FORTH_PUSH 
1ccc						DMARK "PQ3" 
1ccc f5				push af  
1ccd 3a e1 1c			ld a, (.dmark)  
1cd0 32 71 ee			ld (debug_mark),a  
1cd3 3a e2 1c			ld a, (.dmark+1)  
1cd6 32 72 ee			ld (debug_mark+1),a  
1cd9 3a e3 1c			ld a, (.dmark+2)  
1cdc 32 73 ee			ld (debug_mark+2),a  
1cdf 18 03			jr .pastdmark  
1ce1 ..			.dmark: db "PQ3"  
1ce4 f1			.pastdmark: pop af  
1ce5			endm  
# End of macro DMARK
1ce5				CALLMONITOR 
1ce5 cd ae 15			call break_point_state  
1ce8				endm  
# End of macro CALLMONITOR
1ce8			endif	 
1ce8 19				add hl,de 
1ce9			if DEBUG_FORTH_PUSH 
1ce9						DMARK "PQE" 
1ce9 f5				push af  
1cea 3a fe 1c			ld a, (.dmark)  
1ced 32 71 ee			ld (debug_mark),a  
1cf0 3a ff 1c			ld a, (.dmark+1)  
1cf3 32 72 ee			ld (debug_mark+1),a  
1cf6 3a 00 1d			ld a, (.dmark+2)  
1cf9 32 73 ee			ld (debug_mark+2),a  
1cfc 18 03			jr .pastdmark  
1cfe ..			.dmark: db "PQE"  
1d01 f1			.pastdmark: pop af  
1d02			endm  
# End of macro DMARK
1d02				CALLMONITOR 
1d02 cd ae 15			call break_point_state  
1d05				endm  
# End of macro CALLMONITOR
1d05			endif	 
1d05			 
1d05 2b				dec hl    ; see if there is an optional trailing double quote 
1d06 7e				ld a,(hl) 
1d07 fe 22			cp '"' 
1d09 20 03			jr nz, .strnoq 
1d0b 3e 00			ld a, 0      ; get rid of double quote 
1d0d 77				ld (hl), a 
1d0e 23			.strnoq: inc hl 
1d0f			 
1d0f 3e 00			ld a, 0 
1d11 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1d12			 
1d12 13				inc de ; add one for the type string 
1d13 13				inc de ; add one for null term??? 
1d14			 
1d14				; tos is get string pointer again 
1d14				; de contains space to allocate 
1d14				 
1d14 d5				push de 
1d15			 
1d15 eb				ex de, hl 
1d16			 
1d16				;push af 
1d16			 
1d16			if DEBUG_FORTH_PUSH 
1d16						DMARK "PHm" 
1d16 f5				push af  
1d17 3a 2b 1d			ld a, (.dmark)  
1d1a 32 71 ee			ld (debug_mark),a  
1d1d 3a 2c 1d			ld a, (.dmark+1)  
1d20 32 72 ee			ld (debug_mark+1),a  
1d23 3a 2d 1d			ld a, (.dmark+2)  
1d26 32 73 ee			ld (debug_mark+2),a  
1d29 18 03			jr .pastdmark  
1d2b ..			.dmark: db "PHm"  
1d2e f1			.pastdmark: pop af  
1d2f			endm  
# End of macro DMARK
1d2f				CALLMONITOR 
1d2f cd ae 15			call break_point_state  
1d32				endm  
# End of macro CALLMONITOR
1d32			endif	 
1d32 cd 74 12			call malloc	; on ret hl now contains allocated memory 
1d35				if DEBUG_FORTH_MALLOC_GUARD 
1d35 cc a9 4a				call z,malloc_error 
1d38				endif 
1d38			 
1d38				 
1d38 c1				pop bc    ; get length 
1d39 d1				pop de   ;  get string start    
1d3a			 
1d3a				; hl has destination from malloc 
1d3a			 
1d3a eb				ex de, hl    ; prep for ldir 
1d3b			 
1d3b d5				push de   ; save malloc area for DSP later 
1d3c				;push hl   ; save malloc area for DSP later 
1d3c			 
1d3c			if DEBUG_FORTH_PUSH 
1d3c						DMARK "PHc" 
1d3c f5				push af  
1d3d 3a 51 1d			ld a, (.dmark)  
1d40 32 71 ee			ld (debug_mark),a  
1d43 3a 52 1d			ld a, (.dmark+1)  
1d46 32 72 ee			ld (debug_mark+1),a  
1d49 3a 53 1d			ld a, (.dmark+2)  
1d4c 32 73 ee			ld (debug_mark+2),a  
1d4f 18 03			jr .pastdmark  
1d51 ..			.dmark: db "PHc"  
1d54 f1			.pastdmark: pop af  
1d55			endm  
# End of macro DMARK
1d55				CALLMONITOR 
1d55 cd ae 15			call break_point_state  
1d58				endm  
# End of macro CALLMONITOR
1d58			endif	 
1d58			 
1d58			 
1d58 ed b0			ldir 
1d5a			 
1d5a			 
1d5a				; push malloc to data stack     macro?????  
1d5a			 
1d5a				FORTH_DSP_NEXT 
1d5a cd ae 1b			call macro_forth_dsp_next 
1d5d				endm 
# End of macro FORTH_DSP_NEXT
1d5d			 
1d5d				; save value and type 
1d5d			 
1d5d 2a f8 e9			ld hl, (cli_data_sp) 
1d60			 
1d60				; save item type 
1d60 3e 01			ld a,  DS_TYPE_STR 
1d62 77				ld (hl), a 
1d63 23				inc hl 
1d64			 
1d64				; get malloc word off stack 
1d64 d1				pop de 
1d65 73				ld (hl), e 
1d66 23				inc hl 
1d67 72				ld (hl), d 
1d68			 
1d68			 
1d68			 
1d68			if DEBUG_FORTH_PUSH 
1d68 2a f8 e9			ld hl, (cli_data_sp) 
1d6b						DMARK "PHS" 
1d6b f5				push af  
1d6c 3a 80 1d			ld a, (.dmark)  
1d6f 32 71 ee			ld (debug_mark),a  
1d72 3a 81 1d			ld a, (.dmark+1)  
1d75 32 72 ee			ld (debug_mark+1),a  
1d78 3a 82 1d			ld a, (.dmark+2)  
1d7b 32 73 ee			ld (debug_mark+2),a  
1d7e 18 03			jr .pastdmark  
1d80 ..			.dmark: db "PHS"  
1d83 f1			.pastdmark: pop af  
1d84			endm  
# End of macro DMARK
1d84				CALLMONITOR 
1d84 cd ae 15			call break_point_state  
1d87				endm  
# End of macro CALLMONITOR
1d87			;	ex de,hl 
1d87			endif	 
1d87				; in case of spaces, skip the ptr past the copied string 
1d87				;pop af 
1d87				;ld (cli_origptr),hl 
1d87			 
1d87 c9				ret 
1d88			 
1d88			 
1d88			 
1d88			; TODO ascii push input onto stack given hl to start of input 
1d88			 
1d88			; identify type 
1d88			; if starts with a " then a string 
1d88			; otherwise it is a number 
1d88			;  
1d88			; if a string 
1d88			;     scan for ending " to get length of string to malloc for + 1 
1d88			;     malloc 
1d88			;     put pointer to string on stack first byte flags as string 
1d88			; 
1d88			; else a number 
1d88			;    look for number format identifier 
1d88			;    $xx hex 
1d88			;    %xxxxx bin 
1d88			;    xxxxx decimal 
1d88			;    convert number to 16bit word.  
1d88			;    malloc word + 1 with flag to identiy as num 
1d88			;    put pointer to number on stack 
1d88			;   
1d88			;  
1d88			  
1d88			forth_apush: 
1d88				; kernel push 
1d88			 
1d88			if DEBUG_FORTH_PUSH 
1d88						DMARK "PSH" 
1d88 f5				push af  
1d89 3a 9d 1d			ld a, (.dmark)  
1d8c 32 71 ee			ld (debug_mark),a  
1d8f 3a 9e 1d			ld a, (.dmark+1)  
1d92 32 72 ee			ld (debug_mark+1),a  
1d95 3a 9f 1d			ld a, (.dmark+2)  
1d98 32 73 ee			ld (debug_mark+2),a  
1d9b 18 03			jr .pastdmark  
1d9d ..			.dmark: db "PSH"  
1da0 f1			.pastdmark: pop af  
1da1			endm  
# End of macro DMARK
1da1				CALLMONITOR 
1da1 cd ae 15			call break_point_state  
1da4				endm  
# End of macro CALLMONITOR
1da4			endif	 
1da4				; identify input type 
1da4			 
1da4 7e				ld a,(hl) 
1da5 fe 22			cp '"' 
1da7 28 0a			jr z, .fapstr 
1da9 fe 24			cp '$' 
1dab ca d3 1d			jp z, .faphex 
1dae fe 25			cp '%' 
1db0 ca bb 1d			jp z, .fapbin 
1db3			;	cp 'b' 
1db3			;	jp z, .fabin 
1db3				; else decimal 
1db3			 
1db3				; TODO do decimal conversion 
1db3				; decimal is stored as a 16bit word 
1db3			 
1db3				; by default everything is a string if type is not detected 
1db3			.fapstr: ; 
1db3 fe 22			cp '"' 
1db5 20 01			jr nz, .strnoqu 
1db7 23				inc hl 
1db8			.strnoqu: 
1db8 c3 8d 1c			jp forth_push_str 
1dbb			 
1dbb			 
1dbb			 
1dbb			.fapbin:    ; push a binary string.  
1dbb 11 00 00			ld de, 0   ; hold a 16bit value 
1dbe			 
1dbe 23			.fapbinshift:	inc hl  
1dbf 7e				ld a,(hl) 
1dc0 fe 00			cp 0     ; done scanning  
1dc2 28 0b			jr z, .fapbdone  	; got it in HL so push  
1dc4			 
1dc4				; left shift de 
1dc4 eb				ex de, hl	 
1dc5 29				add hl, hl 
1dc6			 
1dc6				; is 1 
1dc6 fe 31			cp '1' 
1dc8 20 02			jr nz, .binzero 
1dca cb 4d			bit 1, l 
1dcc			.binzero: 
1dcc eb				ex de, hl	 ; save current de 
1dcd 18 ef			jr .fapbinshift 
1dcf			 
1dcf			.fapbdone: 
1dcf eb				ex de, hl 
1dd0 c3 1f 1c			jp forth_push_numhl 
1dd3			 
1dd3			 
1dd3			.faphex:   ; hex is always stored as a 16bit word 
1dd3				; skip number prefix 
1dd3 23				inc hl 
1dd4				; turn ascii into number 
1dd4 cd 64 11			call get_word_hl	; ret 16bit word in hl 
1dd7			 
1dd7 c3 1f 1c			jp forth_push_numhl 
1dda			 
1dda 00				 nop 
1ddb			 
1ddb			.fabin:   ; TODO bin conversion 
1ddb			 
1ddb			 
1ddb c9				ret 
1ddc			 
1ddc			 
1ddc			; get either a string ptr or a 16bit word from the data stack 
1ddc			 
1ddc			FORTH_DSP: macro 
1ddc				call macro_forth_dsp 
1ddc				endm 
1ddc			 
1ddc			macro_forth_dsp: 
1ddc				; data stack pointer points to current word on tos 
1ddc			 
1ddc 2a f8 e9			ld hl,(cli_data_sp) 
1ddf			 
1ddf				if DEBUG_FORTH_PUSH 
1ddf						DMARK "DSP" 
1ddf f5				push af  
1de0 3a f4 1d			ld a, (.dmark)  
1de3 32 71 ee			ld (debug_mark),a  
1de6 3a f5 1d			ld a, (.dmark+1)  
1de9 32 72 ee			ld (debug_mark+1),a  
1dec 3a f6 1d			ld a, (.dmark+2)  
1def 32 73 ee			ld (debug_mark+2),a  
1df2 18 03			jr .pastdmark  
1df4 ..			.dmark: db "DSP"  
1df7 f1			.pastdmark: pop af  
1df8			endm  
# End of macro DMARK
1df8			 
1df8 cd de 4a				call display_data_sp 
1dfb				;call break_point_state 
1dfb				;rst 030h 
1dfb				CALLMONITOR 
1dfb cd ae 15			call break_point_state  
1dfe				endm  
# End of macro CALLMONITOR
1dfe				endif 
1dfe			 
1dfe c9				ret 
1dff			 
1dff			; return hl to start of value on stack 
1dff			 
1dff			FORTH_DSP_VALUE: macro 
1dff				call macro_forth_dsp_value 
1dff				endm 
1dff			 
1dff			macro_forth_dsp_value: 
1dff			 
1dff				FORTH_DSP 
1dff cd dc 1d			call macro_forth_dsp 
1e02				endm 
# End of macro FORTH_DSP
1e02			 
1e02 d5				push de 
1e03			 
1e03 23				inc hl ; skip type 
1e04			 
1e04 5e				ld e, (hl) 
1e05 23				inc hl 
1e06 56				ld d, (hl) 
1e07 eb				ex de,hl  
1e08			 
1e08 d1				pop de 
1e09			 
1e09 c9				ret 
1e0a			 
1e0a			; return hl to start of value to second item on stack 
1e0a			 
1e0a			FORTH_DSP_VALUEM1: macro 
1e0a				call macro_forth_dsp_value_m1 
1e0a				endm 
1e0a			 
1e0a			macro_forth_dsp_value_m1: 
1e0a			 
1e0a				FORTH_DSP 
1e0a cd dc 1d			call macro_forth_dsp 
1e0d				endm 
# End of macro FORTH_DSP
1e0d			 
1e0d 2b				dec hl 
1e0e 2b				dec hl 
1e0f			;	dec hl 
1e0f			 
1e0f d5				push de 
1e10			 
1e10 5e				ld e, (hl) 
1e11 23				inc hl 
1e12 56				ld d, (hl) 
1e13 eb				ex de,hl  
1e14			 
1e14 d1				pop de 
1e15			 
1e15 c9				ret 
1e16			 
1e16				 
1e16			 
1e16			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1e16			 
1e16			FORTH_DSP_POP: macro 
1e16				call macro_forth_dsp_pop 
1e16				endm 
1e16			 
1e16			 
1e16			; get the tos data type 
1e16			 
1e16			FORTH_DSP_TYPE:   macro 
1e16			 
1e16				;FORTH_DSP_VALUE 
1e16				FORTH_DSP 
1e16				 
1e16				; hl points to value 
1e16				; check type 
1e16			 
1e16				ld a,(hl) 
1e16			 
1e16				endm 
1e16			 
1e16			; load the tos value into hl 
1e16			 
1e16			 
1e16			FORTH_DSP_VALUEHL:  macro 
1e16				call macro_dsp_valuehl 
1e16				endm 
1e16			 
1e16			 
1e16			 
1e16			macro_dsp_valuehl: 
1e16				FORTH_DSP_VALUE 
1e16 cd ff 1d			call macro_forth_dsp_value 
1e19				endm 
# End of macro FORTH_DSP_VALUE
1e19			 
1e19				;FORTH_ERR_TOS_NOTNUM 
1e19			 
1e19				;inc hl   ; skip type id 
1e19			 
1e19			;	push de 
1e19			; 
1e19			;	ld e, (hl) 
1e19			;	inc hl 
1e19			;	ld d, (hl) 
1e19			;	ex de,hl  
1e19			 
1e19			;	pop de 
1e19			 
1e19				if DEBUG_FORTH_PUSH 
1e19						DMARK "DVL" 
1e19 f5				push af  
1e1a 3a 2e 1e			ld a, (.dmark)  
1e1d 32 71 ee			ld (debug_mark),a  
1e20 3a 2f 1e			ld a, (.dmark+1)  
1e23 32 72 ee			ld (debug_mark+1),a  
1e26 3a 30 1e			ld a, (.dmark+2)  
1e29 32 73 ee			ld (debug_mark+2),a  
1e2c 18 03			jr .pastdmark  
1e2e ..			.dmark: db "DVL"  
1e31 f1			.pastdmark: pop af  
1e32			endm  
# End of macro DMARK
1e32				CALLMONITOR 
1e32 cd ae 15			call break_point_state  
1e35				endm  
# End of macro CALLMONITOR
1e35				endif 
1e35 c9				ret 
1e36			 
1e36			forth_apushstrhl:      
1e36				; push of string requires use of cli_origptr 
1e36				; bodge use 
1e36			 
1e36				; get current cli_origptr, save, update with temp pointer  
1e36 ed 5b 48 ea		ld de, (cli_origptr) 
1e3a 22 48 ea			ld (cli_origptr), hl 
1e3d d5				push de 
1e3e cd 88 1d			call forth_apush 
1e41 d1				pop de 
1e42 ed 53 48 ea		ld (cli_origptr), de 
1e46 c9			        ret	 
1e47			 
1e47			 
1e47			; increase loop stack pointer and save hl to it 
1e47				 
1e47			FORTH_LOOP_NEXT: macro 
1e47				call macro_forth_loop_next 
1e47				;nop 
1e47				endm 
1e47			 
1e47			macro_forth_loop_next: 
1e47				if DEBUG_FORTH_STACK_GUARD 
1e47 cd b5 5e				call check_stacks 
1e4a				endif 
1e4a e5				push hl 
1e4b d5				push de 
1e4c eb				ex de,hl 
1e4d 2a fa e9			ld hl,(cli_loop_sp) 
1e50 23				inc hl 
1e51 23				inc hl 
1e52					if DEBUG_FORTH_WORDS 
1e52						DMARK "LNX" 
1e52 f5				push af  
1e53 3a 67 1e			ld a, (.dmark)  
1e56 32 71 ee			ld (debug_mark),a  
1e59 3a 68 1e			ld a, (.dmark+1)  
1e5c 32 72 ee			ld (debug_mark+1),a  
1e5f 3a 69 1e			ld a, (.dmark+2)  
1e62 32 73 ee			ld (debug_mark+2),a  
1e65 18 03			jr .pastdmark  
1e67 ..			.dmark: db "LNX"  
1e6a f1			.pastdmark: pop af  
1e6b			endm  
# End of macro DMARK
1e6b						CALLMONITOR 
1e6b cd ae 15			call break_point_state  
1e6e				endm  
# End of macro CALLMONITOR
1e6e					endif 
1e6e 22 fa e9			ld (cli_loop_sp),hl 
1e71 73				ld (hl), e 
1e72 23				inc hl 
1e73 72				ld (hl), d 
1e74 d1				pop de    ; been reversed so save a swap on restore 
1e75 e1				pop hl 
1e76				if DEBUG_FORTH_STACK_GUARD 
1e76 cd b5 5e				call check_stacks 
1e79				endif 
1e79 c9				ret 
1e7a			 
1e7a			; get current ret stack pointer and save to hl  
1e7a				 
1e7a			FORTH_LOOP_TOS: macro 
1e7a				call macro_forth_loop_tos 
1e7a				endm 
1e7a			 
1e7a			macro_forth_loop_tos: 
1e7a d5				push de 
1e7b 2a fa e9			ld hl,(cli_loop_sp) 
1e7e 5e				ld e, (hl) 
1e7f 23				inc hl 
1e80 56				ld d, (hl) 
1e81 eb				ex de, hl 
1e82 d1				pop de 
1e83 c9				ret 
1e84			 
1e84			; pop loop stack pointer 
1e84				 
1e84			FORTH_LOOP_POP: macro 
1e84				call macro_forth_loop_pop 
1e84				endm 
1e84			 
1e84			 
1e84			macro_forth_loop_pop: 
1e84				if DEBUG_FORTH_STACK_GUARD 
1e84					DMARK "LPP" 
1e84 f5				push af  
1e85 3a 99 1e			ld a, (.dmark)  
1e88 32 71 ee			ld (debug_mark),a  
1e8b 3a 9a 1e			ld a, (.dmark+1)  
1e8e 32 72 ee			ld (debug_mark+1),a  
1e91 3a 9b 1e			ld a, (.dmark+2)  
1e94 32 73 ee			ld (debug_mark+2),a  
1e97 18 03			jr .pastdmark  
1e99 ..			.dmark: db "LPP"  
1e9c f1			.pastdmark: pop af  
1e9d			endm  
# End of macro DMARK
1e9d cd b5 5e				call check_stacks 
1ea0					FORTH_CHK_LOOP_UNDER 
1ea0 e5				push hl 
1ea1 d5				push de 
1ea2 2a fa e9			ld hl,(cli_loop_sp) 
1ea5 11 34 e9			ld de, cli_loop_stack 
1ea8 cd cb 0d			call cmp16 
1eab da cf 5f			jp c, fault_loop_under 
1eae d1				pop de 
1eaf e1				pop hl 
1eb0				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1eb0				endif 
1eb0 e5				push hl 
1eb1 2a fa e9			ld hl,(cli_loop_sp) 
1eb4 2b				dec hl 
1eb5 2b				dec hl 
1eb6 22 fa e9			ld (cli_loop_sp), hl 
1eb9				; TODO do stack underflow checks 
1eb9 e1				pop hl 
1eba				if DEBUG_FORTH_STACK_GUARD 
1eba cd b5 5e				call check_stacks 
1ebd					FORTH_CHK_LOOP_UNDER 
1ebd e5				push hl 
1ebe d5				push de 
1ebf 2a fa e9			ld hl,(cli_loop_sp) 
1ec2 11 34 e9			ld de, cli_loop_stack 
1ec5 cd cb 0d			call cmp16 
1ec8 da cf 5f			jp c, fault_loop_under 
1ecb d1				pop de 
1ecc e1				pop hl 
1ecd				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ecd				endif 
1ecd c9				ret 
1ece			 
1ece			macro_forth_dsp_pop: 
1ece			 
1ece e5				push hl 
1ecf			 
1ecf				; release malloc data 
1ecf			 
1ecf				if DEBUG_FORTH_STACK_GUARD 
1ecf cd b5 5e				call check_stacks 
1ed2					FORTH_CHK_DSP_UNDER 
1ed2 e5				push hl 
1ed3 d5				push de 
1ed4 2a f8 e9			ld hl,(cli_data_sp) 
1ed7 11 32 e8			ld de, cli_data_stack 
1eda cd cb 0d			call cmp16 
1edd da c3 5f			jp c, fault_dsp_under 
1ee0 d1				pop de 
1ee1 e1				pop hl 
1ee2				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ee2				endif 
1ee2				;ld hl,(cli_data_sp) 
1ee2			if DEBUG_FORTH_DOT 
1ee2				DMARK "DPP" 
1ee2 f5				push af  
1ee3 3a f7 1e			ld a, (.dmark)  
1ee6 32 71 ee			ld (debug_mark),a  
1ee9 3a f8 1e			ld a, (.dmark+1)  
1eec 32 72 ee			ld (debug_mark+1),a  
1eef 3a f9 1e			ld a, (.dmark+2)  
1ef2 32 73 ee			ld (debug_mark+2),a  
1ef5 18 03			jr .pastdmark  
1ef7 ..			.dmark: db "DPP"  
1efa f1			.pastdmark: pop af  
1efb			endm  
# End of macro DMARK
1efb				CALLMONITOR 
1efb cd ae 15			call break_point_state  
1efe				endm  
# End of macro CALLMONITOR
1efe			endif	 
1efe			 
1efe			 
1efe			if FORTH_ENABLE_DSPPOPFREE 
1efe			 
1efe				FORTH_DSP 
1efe cd dc 1d			call macro_forth_dsp 
1f01				endm 
# End of macro FORTH_DSP
1f01			 
1f01 7e				ld a, (hl) 
1f02 fe 01			cp DS_TYPE_STR 
1f04 20 23			jr nz, .skippopfree 
1f06			 
1f06				FORTH_DSP_VALUEHL 
1f06 cd 16 1e			call macro_dsp_valuehl 
1f09				endm 
# End of macro FORTH_DSP_VALUEHL
1f09 00				nop 
1f0a			if DEBUG_FORTH_DOT 
1f0a				DMARK "DPf" 
1f0a f5				push af  
1f0b 3a 1f 1f			ld a, (.dmark)  
1f0e 32 71 ee			ld (debug_mark),a  
1f11 3a 20 1f			ld a, (.dmark+1)  
1f14 32 72 ee			ld (debug_mark+1),a  
1f17 3a 21 1f			ld a, (.dmark+2)  
1f1a 32 73 ee			ld (debug_mark+2),a  
1f1d 18 03			jr .pastdmark  
1f1f ..			.dmark: db "DPf"  
1f22 f1			.pastdmark: pop af  
1f23			endm  
# End of macro DMARK
1f23				CALLMONITOR 
1f23 cd ae 15			call break_point_state  
1f26				endm  
# End of macro CALLMONITOR
1f26			endif	 
1f26 cd 3e 13			call free 
1f29			.skippopfree: 
1f29				 
1f29			 
1f29			endif 
1f29			 
1f29			if DEBUG_FORTH_DOT_KEY 
1f29				DMARK "DP2" 
1f29				CALLMONITOR 
1f29			endif	 
1f29			 
1f29				; move pointer down 
1f29			 
1f29 2a f8 e9			ld hl,(cli_data_sp) 
1f2c 2b				dec hl 
1f2d 2b				dec hl 
1f2e			; PARSEV5 
1f2e 2b				dec hl 
1f2f 22 f8 e9			ld (cli_data_sp), hl 
1f32			 
1f32				if DEBUG_FORTH_STACK_GUARD 
1f32 cd b5 5e				call check_stacks 
1f35					FORTH_CHK_DSP_UNDER 
1f35 e5				push hl 
1f36 d5				push de 
1f37 2a f8 e9			ld hl,(cli_data_sp) 
1f3a 11 32 e8			ld de, cli_data_stack 
1f3d cd cb 0d			call cmp16 
1f40 da c3 5f			jp c, fault_dsp_under 
1f43 d1				pop de 
1f44 e1				pop hl 
1f45				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f45				endif 
1f45			 
1f45 e1				pop hl 
1f46			 
1f46 c9				ret 
1f47			 
1f47			getwordathl: 
1f47				; hl points to an address 
1f47				; load hl with the word at that address 
1f47			 
1f47 d5				push de 
1f48			 
1f48 5e				ld e, (hl) 
1f49 23				inc hl 
1f4a 56				ld d, (hl) 
1f4b eb				ex de, hl 
1f4c			 
1f4c d1				pop de 
1f4d c9				ret 
1f4e			 
1f4e			 
1f4e			 
1f4e			 
1f4e			 
1f4e			; eof 
1f4e			 
# End of file forth_stackopsv5.asm
1f4e			endif 
1f4e			 
1f4e			user_word_eol:  
1f4e				; hl contains the pointer to where to create a linked list item from the end 
1f4e				; of the user dict to continue on at the system word dict 
1f4e				 
1f4e				; poke the stub of the word list linked list to repoint to rom words 
1f4e			 
1f4e				; stub format 
1f4e				; db   word id 
1f4e				; dw    link to next word 
1f4e			        ; db char length of token 
1f4e				; db string + 0 term 
1f4e				; db exec code....  
1f4e			 
1f4e 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1f50 77				ld (hl), a		; word id 
1f51 23				inc hl 
1f52			 
1f52 11 1d 21			ld de, sysdict 
1f55 73				ld (hl), e		; next word link ie system dict 
1f56 23				inc hl 
1f57 72				ld (hl), d		; next word link ie system dict 
1f58 23				inc hl	 
1f59			 
1f59			;	ld (hl), sysdict		; next word link ie system dict 
1f59			;	inc hl 
1f59			;	inc hl 
1f59			 
1f59			;	inc hl 
1f59			;	inc hl 
1f59			 
1f59 3e 02			ld a, 2			; word length is 0 
1f5b 77				ld (hl), a	 
1f5c 23				inc hl 
1f5d			 
1f5d 3e 7e			ld a, '~'			; word length is 0 
1f5f 77				ld (hl), a	 
1f60 23				inc hl 
1f61 3e 00			ld a, 0			; save empty word 
1f63 77				ld (hl), a 
1f64			 
1f64 c9				ret 
1f65			 
1f65				 
1f65			 
1f65			forthexec_cleanup: 
1f65				FORTH_RSP_POP 
1f65 cd e7 1b			call macro_forth_rsp_pop 
1f68				endm 
# End of macro FORTH_RSP_POP
1f68 c9				ret 
1f69			 
1f69			forth_call_hl: 
1f69				; taking hl 
1f69 e5				push hl 
1f6a c9				ret 
1f6b			 
1f6b			; this is called to reset Forth system but keep existing uwords etc 
1f6b			 
1f6b			forth_warmstart: 
1f6b				; setup stack over/under flow checks 
1f6b				if DEBUG_FORTH_STACK_GUARD 
1f6b cd 9b 5e				call chk_stk_init 
1f6e				endif 
1f6e			 
1f6e				; init stack pointers  - * these stacks go upwards *  
1f6e 21 b6 e9			ld hl, cli_ret_stack 
1f71 22 fc e9			ld (cli_ret_sp), hl	 
1f74				; set bottom of stack 
1f74 3e 00			ld a,0 
1f76 77				ld (hl),a 
1f77 23				inc hl 
1f78 77				ld (hl),a 
1f79			 
1f79 21 32 e8			ld hl, cli_data_stack 
1f7c 22 f8 e9			ld (cli_data_sp), hl	 
1f7f				; set bottom of stack 
1f7f 3e 00			ld a,0 
1f81 77				ld (hl),a 
1f82 23				inc hl 
1f83 77				ld (hl),a 
1f84			 
1f84 21 34 e9			ld hl, cli_loop_stack 
1f87 22 fa e9			ld (cli_loop_sp), hl	 
1f8a				; set bottom of stack 
1f8a 3e 00			ld a,0 
1f8c 77				ld (hl),a 
1f8d 23				inc hl 
1f8e 77				ld (hl),a 
1f8f			 
1f8f				; init extent of current open file 
1f8f			 
1f8f 3e 00			ld a, 0 
1f91 32 74 ea			ld (store_openext), a 
1f94			 
1f94 c9				ret 
1f95			 
1f95			 
1f95			; Cold Start - this is called to setup the whole Forth system 
1f95			 
1f95			forth_init: 
1f95			 
1f95				; setup stack over/under flow checks 
1f95			 
1f95			;	if DEBUG_FORTH_STACK_GUARD 
1f95			;		call chk_stk_init 
1f95			;	endif 
1f95			 
1f95				; enable auto display updates (slow.....) 
1f95			 
1f95 3e 01			ld a, 1 
1f97 32 46 ea			ld (cli_autodisplay), a 
1f9a			 
1f9a				; if storage is in use disable long reads for now 
1f9a 3e 00			ld a, 0 
1f9c 32 7f ea			ld (store_longread), a 
1f9f			 
1f9f			 
1f9f				; show start up screen 
1f9f			 
1f9f cd 80 0b			call clear_display 
1fa2			 
1fa2 3e 00			ld a,0 
1fa4 32 68 ea			ld (f_cursor_ptr), a 
1fa7			 
1fa7				; set start of word list in start of ram - for use when creating user words 
1fa7			 
1fa7 21 be 61			ld hl, baseram 
1faa 22 c8 e5			ld (os_last_new_uword), hl 
1fad cd 4e 1f			call user_word_eol 
1fb0				 
1fb0			;		call display_data_sp 
1fb0			;		call next_page_prompt 
1fb0			 
1fb0			 
1fb0			 
1fb0			 
1fb0 c9				ret 
1fb1			 
1fb1 .. 00		.bootforth: db " Forth Kernel Init ",0 
1fc5			 
1fc5			; TODO push to stack 
1fc5			 
1fc5			;  
1fc5			 
1fc5			if FORTH_PARSEV2 
1fc5			 
1fc5			 
1fc5				include "forth_parserv2.asm" 
1fc5			 
1fc5			endif 
1fc5			 
1fc5			 
1fc5			; parse cli version 1 
1fc5			 
1fc5			if FORTH_PARSEV1 
1fc5			 
1fc5			 
1fc5			 
1fc5			      include "forth_parserv1.asm" 
1fc5			endif 
1fc5				 
1fc5			if FORTH_PARSEV3 
1fc5			 
1fc5			 
1fc5			 
1fc5			      include "forth_parserv3.asm" 
1fc5				include "forth_wordsv3.asm" 
1fc5			endif 
1fc5			 
1fc5			if FORTH_PARSEV4 
1fc5			 
1fc5			 
1fc5			 
1fc5			      include "forth_parserv4.asm" 
1fc5				include "forth_wordsv4.asm" 
1fc5			endif 
1fc5			 
1fc5			if FORTH_PARSEV5 
1fc5			 
1fc5			 
1fc5			 
1fc5			      include "forth_parserv5.asm" 
1fc5			 
1fc5			 
1fc5			; A better parser without using malloc and string copies all over the place.  
1fc5			; Exec in situ should be faster 
1fc5			 
1fc5			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1fc5			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1fc5			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1fc5			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1fc5			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1fc5			WORD_SYS_END: equ 0   ; Opcode for all user words 
1fc5			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1fc5			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1fc5			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1fc5			 
1fc5			; Core word preamble macro 
1fc5			 
1fc5			CWHEAD:   macro nxtword opcode lit len opflags 
1fc5				db WORD_SYS_CORE+opcode             
1fc5				; internal op code number 
1fc5				dw nxtword            
1fc5				; link to next dict word block 
1fc5				db len + 1 
1fc5				; literal length of dict word inc zero term 
1fc5				db lit,0              
1fc5				; literal dict word 
1fc5			        ; TODO db opflags        
1fc5				endm 
1fc5			 
1fc5			 
1fc5			NEXTW: macro  
1fc5				jp macro_next 
1fc5				endm 
1fc5			 
1fc5			macro_next: 
1fc5			if DEBUG_FORTH_PARSE_KEY 
1fc5				DMARK "NXT" 
1fc5				CALLMONITOR 
1fc5			endif	 
1fc5			;	inc hl  ; skip token null term  
1fc5 ed 4b 4a ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1fc9 ed 5b 48 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1fcd 2a cc e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1fd0			if DEBUG_FORTH_PARSE_KEY 
1fd0				DMARK "}AA" 
1fd0				CALLMONITOR 
1fd0			endif	 
1fd0 c3 d3 20			jp execnext 
1fd3				;jp exec1 
1fd3			       
1fd3			 
1fd3			 
1fd3			; Another go at the parser to compile  
1fd3			 
1fd3			 
1fd3			; TODO rework parser to change all of the string words to byte tokens 
1fd3			; TODO do a search for  
1fd3			 
1fd3			; TODO first run normal parser to zero term sections 
1fd3			; TODO for each word do a token look up to get the op code 
1fd3			; TODO need some means to flag to the exec that this is a byte code form    
1fd3			 
1fd3			 
1fd3			forthcompile: 
1fd3			 
1fd3			; 
1fd3			; line parse: 
1fd3			;       parse raw input buffer 
1fd3			;       tokenise the words 
1fd3			;       malloc new copy (for looping etc) 
1fd3			;       copy to malloc + current pc in line to start of string and add line term 
1fd3			;       save on new rsp 
1fd3			; 
1fd3			 
1fd3			; hl to point to the line to tokenise 
1fd3			 
1fd3			;	push hl 
1fd3 22 cc e5			ld (os_tok_ptr), hl  ; save ptr to string 
1fd6			 
1fd6			;	ld a,0		; string term on input 
1fd6			;	call strlent 
1fd6			 
1fd6			;	ld (os_tok_len), hl	 ; save string length 
1fd6			 
1fd6			;if DEBUG_FORTH_TOK 
1fd6			;	ex de,hl		 
1fd6			;endif 
1fd6			 
1fd6			;	pop hl 		; get back string pointer 
1fd6			 
1fd6			if DEBUG_FORTH_TOK 
1fd6						DMARK "TOc" 
1fd6				CALLMONITOR 
1fd6			endif 
1fd6 7e			.cptoken2:    ld a,(hl) 
1fd7 23				inc hl 
1fd8 fe 7f			cp FORTH_END_BUFFER 
1fda 28 29			jr z, .cptokendone2 
1fdc fe 00			cp 0 
1fde 28 25			jr z, .cptokendone2 
1fe0 fe 22			cp '"' 
1fe2 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1fe4 fe 20			cp ' ' 
1fe6 20 ee			jr nz,  .cptoken2 
1fe8			 
1fe8			; TODO consume comments held between ( and ) 
1fe8			 
1fe8				; we have a space so change to zero term for dict match later 
1fe8 2b				dec hl 
1fe9 3e 00			ld a,0 
1feb 77				ld (hl), a 
1fec 23				inc hl 
1fed 18 e7			jr .cptoken2 
1fef				 
1fef			 
1fef			.cptokenstr2: 
1fef				; skip all white space until either eol (because forgot to term) or end double quote 
1fef			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1fef				;inc hl ; skip current double quote 
1fef 7e				ld a,(hl) 
1ff0 23				inc hl 
1ff1 fe 22			cp '"' 
1ff3 28 e1			jr z, .cptoken2 
1ff5 fe 7f			cp FORTH_END_BUFFER 
1ff7 28 0c			jr z, .cptokendone2 
1ff9 fe 00			cp 0 
1ffb 28 08			jr z, .cptokendone2 
1ffd fe 20			cp ' ' 
1fff 28 02			jr z, .cptmp2 
2001 18 ec			jr .cptokenstr2 
2003			 
2003			.cptmp2:	; we have a space so change to zero term for dict match later 
2003				;dec hl 
2003				;ld a,"-"	; TODO remove this when working 
2003				;ld (hl), a 
2003				;inc hl 
2003 18 ea			jr .cptokenstr2 
2005			 
2005			.cptokendone2: 
2005				;inc hl 
2005 3e 7f			ld a, FORTH_END_BUFFER 
2007 77				ld (hl),a 
2008 23				inc hl 
2009 3e 21			ld a, '!' 
200b 77				ld (hl),a 
200c			 
200c 2a cc e5			ld hl,(os_tok_ptr) 
200f			         
200f			if DEBUG_FORTH_TOK 
200f						DMARK "Tc1" 
200f				CALLMONITOR 
200f			endif 
200f			 
200f				; push exec string to top of return stack 
200f				FORTH_RSP_NEXT 
200f cd c6 1b			call macro_forth_rsp_next 
2012				endm 
# End of macro FORTH_RSP_NEXT
2012 c9				ret 
2013			 
2013			; Another go at the parser need to simplify the process 
2013			 
2013			forthparse: 
2013			 
2013			; 
2013			; line parse: 
2013			;       parse raw input buffer 
2013			;       tokenise the words 
2013			;       malloc new copy (for looping etc) 
2013			;       copy to malloc + current pc in line to start of string and add line term 
2013			;       save on new rsp 
2013			; 
2013			 
2013			; hl to point to the line to tokenise 
2013			 
2013			;	push hl 
2013 22 cc e5			ld (os_tok_ptr), hl  ; save ptr to string 
2016			 
2016			;	ld a,0		; string term on input 
2016			;	call strlent 
2016			 
2016			;	ld (os_tok_len), hl	 ; save string length 
2016			 
2016			;if DEBUG_FORTH_TOK 
2016			;	ex de,hl		 
2016			;endif 
2016			 
2016			;	pop hl 		; get back string pointer 
2016			 
2016			if DEBUG_FORTH_TOK 
2016						DMARK "TOK" 
2016				CALLMONITOR 
2016			endif 
2016 7e			.ptoken2:    ld a,(hl) 
2017 23				inc hl 
2018 fe 7f			cp FORTH_END_BUFFER 
201a 28 29			jr z, .ptokendone2 
201c fe 00			cp 0 
201e 28 25			jr z, .ptokendone2 
2020 fe 22			cp '"' 
2022 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2024 fe 20			cp ' ' 
2026 20 ee			jr nz,  .ptoken2 
2028			 
2028			; TODO consume comments held between ( and ) 
2028			 
2028				; we have a space so change to zero term for dict match later 
2028 2b				dec hl 
2029 3e 00			ld a,0 
202b 77				ld (hl), a 
202c 23				inc hl 
202d 18 e7			jr .ptoken2 
202f				 
202f			 
202f			.ptokenstr2: 
202f				; skip all white space until either eol (because forgot to term) or end double quote 
202f			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
202f				;inc hl ; skip current double quote 
202f 7e				ld a,(hl) 
2030 23				inc hl 
2031 fe 22			cp '"' 
2033 28 e1			jr z, .ptoken2 
2035 fe 7f			cp FORTH_END_BUFFER 
2037 28 0c			jr z, .ptokendone2 
2039 fe 00			cp 0 
203b 28 08			jr z, .ptokendone2 
203d fe 20			cp ' ' 
203f 28 02			jr z, .ptmp2 
2041 18 ec			jr .ptokenstr2 
2043			 
2043			.ptmp2:	; we have a space so change to zero term for dict match later 
2043				;dec hl 
2043				;ld a,"-"	; TODO remove this when working 
2043				;ld (hl), a 
2043				;inc hl 
2043 18 ea			jr .ptokenstr2 
2045			 
2045			.ptokendone2: 
2045				;inc hl 
2045 3e 7f			ld a, FORTH_END_BUFFER 
2047 77				ld (hl),a 
2048 23				inc hl 
2049 3e 21			ld a, '!' 
204b 77				ld (hl),a 
204c			 
204c 2a cc e5			ld hl,(os_tok_ptr) 
204f			         
204f			if DEBUG_FORTH_TOK 
204f						DMARK "TK1" 
204f				CALLMONITOR 
204f			endif 
204f			 
204f				; push exec string to top of return stack 
204f				FORTH_RSP_NEXT 
204f cd c6 1b			call macro_forth_rsp_next 
2052				endm 
# End of macro FORTH_RSP_NEXT
2052 c9				ret 
2053			 
2053			; 
2053			;	; malloc size + buffer pointer + if is loop flag 
2053			;	ld hl,(os_tok_len) 		 ; get string length 
2053			; 
2053			;	ld a,l 
2053			; 
2053			;	cp 0			; we dont want to use a null string 
2053			;	ret z 
2053			; 
2053			;;	add 3    ; prefix malloc with buffer for current word ptr 
2053			; 
2053			;	add 5     ; TODO when certain not over writing memory remove 
2053			; 
2053			;		 
2053			; 
2053			;if DEBUG_FORTH_TOK 
2053			;			DMARK "TKE" 
2053			;	CALLMONITOR 
2053			;endif 
2053			; 
2053			;	ld l,a 
2053			;	ld h,0 
2053			;;	push hl   ; save required space for the copy later 
2053			;	call malloc 
2053			;if DEBUG_FORTH_TOK 
2053			;			DMARK "TKM" 
2053			;	CALLMONITOR 
2053			;endif 
2053			;	if DEBUG_FORTH_MALLOC_GUARD 
2053			;		push af 
2053			;		call ishlzero 
2053			;;		ld a, l 
2053			;;		add h 
2053			;;		cp 0 
2053			;		pop af 
2053			;		 
2053			;		call z,malloc_error 
2053			;	endif 
2053			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2053			; 
2053			; 
2053			;if DEBUG_FORTH_TOK 
2053			;			DMARK "TKR" 
2053			;	CALLMONITOR 
2053			;endif 
2053			; 
2053			;	FORTH_RSP_NEXT 
2053			; 
2053			;	;inc hl	 ; go past current buffer pointer 
2053			;	;inc hl 
2053			;	;inc hl   ; and past if loop flag 
2053			;		; TODO Need to set flag  
2053			; 
2053			;	 
2053			;	 
2053			;	ex de,hl	; malloc is dest 
2053			;	ld hl, (os_tok_len) 
2053			;;	pop bc 
2053			;	ld c, l                
2053			;	ld b,0 
2053			;	ld hl, (os_tok_ptr) 
2053			; 
2053			;if DEBUG_FORTH_TOK 
2053			;			DMARK "TKT" 
2053			;	CALLMONITOR 
2053			;endif 
2053			; 
2053			;	; do str cpy 
2053			; 
2053			;	ldir      ; copy byte in hl to de 
2053			; 
2053			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2053			; 
2053			;if DEBUG_FORTH_TOK 
2053			; 
2053			;			DMARK "TKY" 
2053			;	CALLMONITOR 
2053			;endif 
2053			;	;ld a,0 
2053			;	;ld a,FORTH_END_BUFFER 
2053			;	ex de, hl 
2053			;	;dec hl			 ; go back over the space delim at the end of word 
2053			;	;ld (hl),a 
2053			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2053			;	ld a,FORTH_END_BUFFER 
2053			;	ld (hl),a 
2053			;	inc hl 
2053			;	ld a,FORTH_END_BUFFER 
2053			;	ld (hl),a 
2053			; 
2053			;	; init the malloc area data 
2053			;	; set pc for in current area 
2053			;	;ld hl, (os_tok_malloc) 
2053			;	;inc hl 
2053			;	;inc hl 
2053			;	;inc hl 
2053			;	;ex de,hl 
2053			;	;ld hl, (os_tok_malloc) 
2053			;	;ld (hl),e 
2053			;	;inc hl 
2053			;	;ld (hl),d 
2053			; 
2053			; 
2053			;	ld hl,(os_tok_malloc) 
2053			;if DEBUG_FORTH_PARSE_KEY 
2053			;			DMARK "TKU" 
2053			;	CALLMONITOR 
2053			;endif 
2053			; 
2053			;	ret 
2053			 
2053			forthexec: 
2053			 
2053			; line exec: 
2053			; forth parser 
2053			 
2053			; 
2053			;       get current exec line on rsp 
2053			 
2053				FORTH_RSP_TOS 
2053 cd dd 1b			call macro_forth_rsp_tos 
2056				endm 
# End of macro FORTH_RSP_TOS
2056			 
2056			;       restore current pc - hl points to malloc of data 
2056			 
2056				;ld e, (hl) 
2056				;inc hl 
2056				;ld d, (hl) 
2056				;ex de,hl 
2056			 
2056			 
2056			exec1: 
2056 22 cc e5			ld (os_tok_ptr), hl 
2059			 
2059				; copy our PC to working vars  
2059 22 4a ea			ld (cli_ptr), hl 
205c 22 48 ea			ld (cli_origptr), hl 
205f			 
205f 7e				ld a,(hl) 
2060 fe 7f			cp FORTH_END_BUFFER 
2062 c8				ret z 
2063			 
2063				; skip any nulls 
2063			 
2063 fe 00			cp 0 
2065 20 03			jr nz, .execword 
2067 23				inc hl 
2068 18 ec			jr exec1 
206a			 
206a			 
206a			.execword: 
206a			 
206a			 
206a			 
206a			if DEBUG_FORTH_PARSE_KEY 
206a						DMARK "KYQ" 
206a				CALLMONITOR 
206a			endif 
206a			;       while at start of word: 
206a			; get start of dict (in user area first) 
206a			 
206a 21 be 61		ld hl, baseram 
206d			;ld hl, sysdict 
206d 22 4c ea		ld (cli_nextword),hl 
2070			;           match word at pc 
2070			;           exec word 
2070			;           or push to dsp 
2070			;           forward to next token 
2070			;           if line term pop rsp and exit 
2070			;        
2070			 
2070			if DEBUG_FORTH_PARSE_KEY 
2070						DMARK "KYq" 
2070				CALLMONITOR 
2070			endif 
2070			 
2070			; 
2070			; word comp 
2070			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2070			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2070			;    move to start of word  
2070			;    compare word to cli_token 
2070			 
2070			.execpnword:	; HL at start of a word in the dictionary to check 
2070			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2070			;	ld (cli_ptr), hl 
2070			 
2070 2a 4c ea			ld hl,(cli_nextword) 
2073			 
2073 cd 16 21			call forth_tok_next 
2076			; tok next start here 
2076			;	; TODO skip compiled symbol for now 
2076			;	inc hl 
2076			; 
2076			;	; save pointer to next word 
2076			; 
2076			;	; hl now points to the address of the next word pointer  
2076			;	ld e, (hl) 
2076			;	inc hl 
2076			;	ld d, (hl) 
2076			;	inc l 
2076			; 
2076			;	ex de,hl 
2076			;if DEBUG_FORTH_PARSE_NEXTWORD 
2076			;	push bc 
2076			;	ld bc, (cli_nextword) 
2076			;			DMARK "NXW" 
2076			;	CALLMONITOR 
2076			;	pop bc 
2076			;endif 
2076			; tok next end here 
2076 22 4c ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
2079 eb				ex de, hl 
207a			 
207a			 
207a				; save the pointer of the current token - 1 to check against 
207a				 
207a 22 50 ea			ld (cli_token), hl   
207d				; TODO maybe remove below save if no debug 
207d				; save token string ptr for any debug later 
207d 23				inc hl  
207e 22 52 ea			ld (cli_origtoken), hl 
2081 2b				dec hl 
2082				; save pointer to the start of the next dictionay word 
2082 7e				ld a,(hl)   ; get string length 
2083 47				ld b,a 
2084			.execpnwordinc:  
2084 23				inc hl 
2085 10 fd			djnz .execpnwordinc 
2087 22 4e ea			ld (cli_execword), hl      ; save start of this words code 
208a			 
208a				; now check the word token against the string being parsed 
208a			 
208a 2a 50 ea			ld hl,(cli_token) 
208d 23				inc hl     ; skip string length (use zero term instead to end) 
208e 22 50 ea			ld (cli_token), hl 
2091			 
2091			if DEBUG_FORTH_PARSE_KEY 
2091						DMARK "KY2" 
2091			endif 
2091			if DEBUG_FORTH_PARSE_EXEC 
2091				; see if disabled 
2091			 
2091				ld a, (os_view_disable) 
2091				cp '*' 
2091				jr z, .skip 
2091			 
2091				push hl 
2091				push hl 
2091				call clear_display 
2091				ld de, .compword 
2091				ld a, display_row_1 
2091				call str_at_display 
2091				pop de 
2091				ld a, display_row_2 
2091				call str_at_display 
2091				ld hl,(cli_ptr) 
2091				ld a,(hl) 
2091			        ld hl, os_word_scratch 
2091				ld (hl),a 
2091				ld a,0 
2091				inc hl 
2091				ld (hl),a 	 
2091				ld de, os_word_scratch 
2091				ld a, display_row_2+10 
2091				call str_at_display 
2091				call update_display 
2091				ld a, 100 
2091				call aDelayInMS 
2091				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2091				call delay250ms 
2091				endif 
2091				pop hl 
2091			.skip:  
2091			endif	 
2091			.execpnchar:    ; compare char between token and string to parse 
2091			 
2091			if DEBUG_FORTH_PARSE_KEY 
2091						DMARK "Ky3" 
2091			endif 
2091			if DEBUG_FORTH_PARSE_EXEC 
2091				; see if disabled 
2091			 
2091				ld a, (os_view_disable) 
2091				cp '*' 
2091				jr z, .skip2 
2091			 
2091			;	call clear_display 
2091			ld hl,(cli_token) 
2091			ld a,(hl) 
2091			ld (os_word_scratch),a 
2091				ld hl,(cli_ptr) 
2091			ld a,(hl) 
2091				ld (os_word_scratch+1),a 
2091				ld a,0 
2091				ld (os_word_scratch+2),a 
2091				ld de,os_word_scratch 
2091				ld a,display_row_4 
2091				call str_at_display 
2091				call update_display 
2091			.skip2:  
2091			endif 
2091 2a 50 ea			ld hl,(cli_token) 
2094 7e				ld a, (hl)	 ; char in word token 
2095 23				inc hl 		; move to next char 
2096 22 50 ea			ld (cli_token), hl ; and save it 
2099 47				ld b,a 
209a			 
209a 2a 4a ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
209d 7e				ld a,(hl) 
209e 23				inc hl 
209f 22 4a ea			ld (cli_ptr), hl		; move to next char 
20a2 cd 02 12			call toUpper 		; make sure the input string matches case 
20a5			 
20a5			if DEBUG_FORTH_PARSE 
20a5			endif 
20a5			 
20a5				; input stream end of token is a space so get rid of it 
20a5			 
20a5			;	cp ' ' 
20a5			;	jr nz, .pnskipspace 
20a5			; 
20a5			;	ld a, 0		; make same term as word token term 
20a5			; 
20a5			;.pnskipspace: 
20a5			 
20a5			if DEBUG_FORTH_PARSE_KEY 
20a5						DMARK "KY7" 
20a5			endif 
20a5 b8				cp b 
20a6 c2 bc 20			jp nz, .execpnskipword	 ; no match so move to next word 
20a9				 
20a9			;    if same 
20a9			;       scan for string terms 0 for token and 32 for input 
20a9			 
20a9				 
20a9			if DEBUG_FORTH_PARSE_KEY 
20a9						DMARK "KY8" 
20a9			endif 
20a9			 
20a9 80				add b			 
20aa fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
20ac							; TODO need to make sure last word in zero term string is accounted for 
20ac 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
20ae			 
20ae			 
20ae				; at end of both strings so both are exact match 
20ae			 
20ae			;       skip ptr for next word 
20ae			 
20ae 2a 4a ea			ld hl,(cli_ptr) 	; at input string term 
20b1 23				inc hl			 ; at next char 
20b2 22 4a ea			ld (cli_ptr), hl     ; save for next round of the parser 
20b5 22 48 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
20b8				 
20b8				 
20b8			if DEBUG_FORTH_PARSE_KEY 
20b8						DMARK "KY3" 
20b8			endif 
20b8			 
20b8			 
20b8			 
20b8			;       exec code block 
20b8			if DEBUG_FORTH_JP 
20b8				call clear_display 
20b8				call update_display 
20b8				call delay1s 
20b8				ld hl, (cli_execword)     ; save for next check if no match on this word 
20b8				ld a,h 
20b8				ld hl, os_word_scratch 
20b8				call hexout 
20b8				ld hl, (cli_execword)     ; save for next check if no match on this word 
20b8				ld a,l 
20b8				ld hl, os_word_scratch+2 
20b8				call hexout 
20b8				ld hl, os_word_scratch+4 
20b8				ld a,0 
20b8				ld (hl),a 
20b8				ld de,os_word_scratch 
20b8				call str_at_display 
20b8					ld a, display_row_2 
20b8					call str_at_display 
20b8				ld de, (cli_origtoken) 
20b8				ld a, display_row_1+10 
20b8					call str_at_display 
20b8			 
20b8				ld a,display_row_1 
20b8				ld de, .foundword 
20b8				ld a, display_row_3 
20b8				call str_at_display 
20b8				call update_display 
20b8				call delay1s 
20b8				call delay1s 
20b8				call delay1s 
20b8			endif 
20b8			 
20b8			if DEBUG_FORTH_PARSE_KEY 
20b8						DMARK "KYj" 
20b8			endif 
20b8				; TODO save the word pointer in this exec 
20b8			 
20b8 2a 4e ea			ld hl,(cli_execword) 
20bb e9				jp (hl) 
20bc			 
20bc			 
20bc			;    if not same 
20bc			;	scan for zero term 
20bc			;	get ptr for next word 
20bc			;	goto word comp 
20bc			 
20bc			.execpnskipword:	; get pointer to next word 
20bc 2a 4c ea			ld hl,(cli_nextword) 
20bf			 
20bf 7e				ld a,(hl) 
20c0 fe 00			cp WORD_SYS_END 
20c2			;	cp 0 
20c2 28 09			jr z, .execendofdict			 ; at end of words 
20c4			 
20c4			if DEBUG_FORTH_PARSE_KEY 
20c4						DMARK "KY4" 
20c4			endif 
20c4			if DEBUG_FORTH_PARSE_EXEC 
20c4			 
20c4				; see if disabled 
20c4			 
20c4				ld a, (os_view_disable) 
20c4				cp '*' 
20c4				jr z, .noskip 
20c4			 
20c4			 
20c4				ld de, .nowordfound 
20c4				ld a, display_row_3 
20c4				call str_at_display 
20c4				call update_display 
20c4				ld a, 100 
20c4				call aDelayInMS 
20c4				 
20c4				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20c4					call delay250ms 
20c4				endif 
20c4			.noskip:  
20c4			 
20c4			endif	 
20c4			 
20c4 2a 48 ea			ld hl,(cli_origptr) 
20c7 22 4a ea			ld (cli_ptr),hl 
20ca			 
20ca			if DEBUG_FORTH_PARSE_KEY 
20ca						DMARK "KY5" 
20ca			endif 
20ca c3 70 20			jp .execpnword			; else go to next word 
20cd			 
20cd			.execendofdict:  
20cd			 
20cd			if DEBUG_FORTH_PARSE_KEY 
20cd						DMARK "KYe" 
20cd			endif 
20cd			if DEBUG_FORTH_PARSE_EXEC 
20cd				; see if disabled 
20cd			 
20cd				ld a, (os_view_disable) 
20cd				cp '*' 
20cd				jr z, .ispskip 
20cd			 
20cd				call clear_display 
20cd				call update_display 
20cd				call delay1s 
20cd				ld de, (cli_origptr) 
20cd				ld a, display_row_1 
20cd				call str_at_display 
20cd				 
20cd				ld de, .enddict 
20cd				ld a, display_row_3 
20cd				call str_at_display 
20cd				call update_display 
20cd				ld a, 100 
20cd				call aDelayInMS 
20cd				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20cd				call delay1s 
20cd				call delay1s 
20cd				call delay1s 
20cd				endif 
20cd			.ispskip:  
20cd				 
20cd			endif	 
20cd			 
20cd			 
20cd			 
20cd				; if the word is not a keyword then must be a literal so push it to stack 
20cd			 
20cd			; push token to stack to end of word 
20cd			 
20cd				STACKFRAME ON $1efe $2f9f 
20cd				if DEBUG_STACK_IMB 
20cd					if ON 
20cd						exx 
20cd						ld de, $1efe 
20cd						ld a, d 
20cd						ld hl, curframe 
20cd						call hexout 
20cd						ld a, e 
20cd						ld hl, curframe+2 
20cd						call hexout 
20cd						ld hl, $1efe 
20cd						push hl 
20cd						ld hl, $2f9f 
20cd						push hl 
20cd						exx 
20cd					endif 
20cd				endif 
20cd			endm 
# End of macro STACKFRAME
20cd			 
20cd 2a cc e5		ld hl,(os_tok_ptr) 
20d0 cd 88 1d		call forth_apush 
20d3			 
20d3				STACKFRAMECHK ON $1efe $2f9f 
20d3				if DEBUG_STACK_IMB 
20d3					if ON 
20d3						exx 
20d3						ld hl, $2f9f 
20d3						pop de   ; $2f9f 
20d3						call cmp16 
20d3						jr nz, .spnosame 
20d3						ld hl, $1efe 
20d3						pop de   ; $1efe 
20d3						call cmp16 
20d3						jr z, .spfrsame 
20d3						.spnosame: call showsperror 
20d3						.spfrsame: nop 
20d3						exx 
20d3					endif 
20d3				endif 
20d3			endm 
# End of macro STACKFRAMECHK
20d3			 
20d3			execnext: 
20d3			 
20d3			if DEBUG_FORTH_PARSE_KEY 
20d3						DMARK "KY>" 
20d3			endif 
20d3			; move past token to next word 
20d3			 
20d3 2a cc e5		ld hl, (os_tok_ptr) 
20d6 3e 00		ld a, 0 
20d8 01 ff 00		ld bc, 255     ; input buffer size 
20db ed b1		cpir 
20dd			 
20dd			if DEBUG_FORTH_PARSE_KEY 
20dd						DMARK "KY!" 
20dd				CALLMONITOR 
20dd			endif	 
20dd			; TODO this might place hl on the null, so will need to forward on??? 
20dd			;inc hl   ; see if this gets onto the next item 
20dd			 
20dd			 
20dd			; TODO pass a pointer to the buffer to push 
20dd			; TODO call function to push 
20dd			 
20dd			; look for end of input 
20dd			 
20dd			;inc hl 
20dd			;ld a,(hl) 
20dd			;cp FORTH_END_BUFFER 
20dd			;ret z 
20dd			 
20dd			 
20dd c3 56 20		jp exec1 
20e0			 
20e0			 
20e0			 
20e0			 
20e0			 
20e0			 
20e0			 
20e0			 
20e0			 
20e0			findnexttok: 
20e0			 
20e0				; hl is pointer to move 
20e0				; de is the token to locate 
20e0			 
20e0					if DEBUG_FORTH 
20e0						DMARK "NTK" 
20e0						CALLMONITOR 
20e0					endif 
20e0 d5				push de 
20e1			 
20e1			.fnt1:	 
20e1				; find first char of token to locate 
20e1			 
20e1 1a				ld a, (de) 
20e2 4f				ld c,a 
20e3 7e				ld a,(hl) 
20e4 cd 02 12			call toUpper 
20e7					if DEBUG_FORTH 
20e7						DMARK "NT1" 
20e7						CALLMONITOR 
20e7					endif 
20e7 b9				cp c 
20e8			 
20e8 28 03			jr z, .fnt2cmpmorefirst	 
20ea			 
20ea				; first char not found move to next char 
20ea			 
20ea 23				inc hl 
20eb 18 f4			jr .fnt1 
20ed			 
20ed			.fnt2cmpmorefirst:	 
20ed				; first char of token found.  
20ed			 
20ed e5				push hl     ; save start of token just in case it is the right one 
20ee d9				exx 
20ef e1				pop hl        ; save it to hl' 
20f0 d9				exx 
20f1			 
20f1			 
20f1			.fnt2cmpmore:	 
20f1				; compare the rest 
20f1				 
20f1 23				inc hl 
20f2 13				inc de 
20f3				 
20f3 1a				ld a, (de) 
20f4 4f				ld c,a 
20f5 7e				ld a,(hl) 
20f6 cd 02 12			call toUpper 
20f9			 
20f9					if DEBUG_FORTH 
20f9						DMARK "NT2" 
20f9						CALLMONITOR 
20f9					endif 
20f9				; c has the token to find char 
20f9				; a has the mem to scan char 
20f9			 
20f9 b9				cp c 
20fa 28 04			jr z,.fntmatch1 
20fc			 
20fc				; they are not the same 
20fc			 
20fc					if DEBUG_FORTH 
20fc						DMARK "NT3" 
20fc						CALLMONITOR 
20fc					endif 
20fc d1				pop de	; reset de token to look for 
20fd d5				push de 
20fe 18 e1			jr .fnt1 
2100				 
2100			.fntmatch1: 
2100			 
2100				; is the same char a null which means we might have a full hit? 
2100					if DEBUG_FORTH 
2100						DMARK "NT4" 
2100						CALLMONITOR 
2100					endif 
2100			 
2100 fe 00			cp 0 
2102 28 0b			jr z, .fntmatchyes 
2104			 
2104				; are we at the end of the token to find? 
2104			 
2104					if DEBUG_FORTH 
2104						DMARK "NT5" 
2104						CALLMONITOR 
2104					endif 
2104 3e 00			ld a, 0 
2106 b9				cp c 
2107			 
2107 c2 f1 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
210a			 
210a					if DEBUG_FORTH 
210a						DMARK "NT6" 
210a						CALLMONITOR 
210a					endif 
210a				; token to find is exhusted but no match to stream 
210a			 
210a				; restore tok pointer and continue on 
210a d1				pop de 
210b d5				push de 
210c c3 e1 20			jp .fnt1 
210f			 
210f			 
210f			.fntmatchyes: 
210f			 
210f				; hl now contains the end of the found token 
210f			 
210f				; get rid of saved token pointer to find 
210f			 
210f d1				pop de 
2110			 
2110					if DEBUG_FORTH 
2110						DMARK "NT9" 
2110						CALLMONITOR 
2110					endif 
2110			 
2110				; hl will be on the null term so forward on 
2110			 
2110				; get back the saved start of the token 
2110			 
2110 d9				exx 
2111 e5				push hl     ; save start of token just in case it is the right one 
2112 d9				exx 
2113 e1				pop hl        ; save it to hl 
2114			 
2114 c9				ret 
2115			 
2115			 
2115			; LIST needs to find a specific token   
2115			; FORGET needs to find a spefici token 
2115			 
2115			; SAVE needs to find all tokens by flag 
2115			; WORDS just needs to scan through all  by flag 
2115			; UWORDS needs to scan through all by flag 
2115			 
2115			 
2115			; given hl as pointer to start of dict look up string 
2115			; return hl as pointer to start of word block 
2115			; or 0 if not found 
2115			 
2115			forth_find_tok: 
2115 c9				ret 
2116			 
2116			; given hl as pointer to dict structure 
2116			; move to the next dict block structure 
2116			 
2116			forth_tok_next: 
2116				; hl now points to the address of the next word pointer  
2116				; TODO skip compiled symbol for now 
2116			;	push de 
2116 23				inc hl 
2117 5e				ld e, (hl) 
2118 23				inc hl 
2119 56				ld d, (hl) 
211a 23				inc hl 
211b			 
211b eb				ex de,hl 
211c			if DEBUG_FORTH_PARSE_NEXTWORD 
211c				push bc 
211c				ld bc, (cli_nextword) 
211c						DMARK "NXW" 
211c				CALLMONITOR 
211c				pop bc 
211c			endif 
211c			;	pop de	 
211c c9				ret 
211d			 
211d			 
211d			 
211d			; eof 
# End of file forth_parserv5.asm
211d				include "forth_wordsv4.asm" 
211d			 
211d			; the core word dictionary v4 
211d			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
211d			 
211d			; this is a linked list for each of the system words used 
211d			; user defined words will follow the same format but will be in ram 
211d			 
211d			 
211d			; 
211d			; 
211d			; define linked list: 
211d			; 
211d			; 1. compiled byte op code 
211d			; 2. len of text word 
211d			; 3. text word 
211d			; 4. ptr to next dictionary word 
211d			; 5. asm, calls etc for the word 
211d			; 
211d			;  if 1 == 0 then last word in dict  
211d			;   
211d			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
211d			;  
211d			;  
211d			; create basic standard set of words 
211d			; 
211d			;  
211d			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
211d			; 2DUP 2DROP 2SWAP  
211d			; @ C@ - get byte  
211d			; ! C! - store byte 
211d			; 0< true if less than zero 
211d			; 0= true if zero 
211d			; < >  
211d			; = true if same 
211d			; variables 
211d			 
211d			 
211d			; Hardware specific words I may need 
211d			; 
211d			; IN OUT  
211d			; calls to key util functions 
211d			; calls to hardward abstraction stuff 
211d			; easy control of frame buffers and lcd i/o 
211d			; keyboard  
211d			 
211d			 
211d			;DICT: macro 
211d			; op_code, len, word, next 
211d			;    word: 
211d			;    db op_code 
211d			;    ds word zero term 
211d			;    dw next 
211d			;    endm 
211d			 
211d			 
211d			 
211d			 
211d			; op code 1 is a flag for user define words which are to be handled differently 
211d			 
211d			 
211d			; 
211d			; 
211d			;    TODO on entry to a word this should be the expected environment 
211d			;    hl - tos value if number then held, if string this is the ptr 
211d			;    de -  
211d			 
211d			 
211d			; opcode ranges 
211d			; 0 - end of word dict 
211d			; 255 - user define words 
211d			 
211d			sysdict: 
211d			include "forth_opcodes.asm" 
211d			; op codes for forth keywords 
211d			; free to use code 0  
211d				OPCODE_HEAP: equ  1 
211d				OPCODE_EXEC: equ 2 
211d				OPCODE_DUP: equ 3 
211d				OPCODE_SWAP: equ 4 
211d				OPCODE_COLN: equ 5 
211d				OPCODE_SCOLN: equ 6 
211d				OPCODE_DROP: equ 7 
211d				OPCODE_DUP2: equ 8 
211d				OPCODE_DROP2: equ 9 
211d				OPCODE_SWAP2: equ 10 
211d				OPCODE_AT: equ 11 
211d				OPCODE_CAT: equ 12 
211d				OPCODE_BANG: equ 13 
211d				OPCODE_CBANG: equ 14 
211d				OPCODE_SCALL: equ 15 
211d				OPCODE_DEPTH: equ 16 
211d				OPCODE_OVER: equ 17 
211d				OPCODE_PAUSE: equ 18 
211d				OPCODE_PAUSES: equ 19 
211d				OPCODE_ROT: equ 20 
211d			;free to reuse	OPCODE_WORDS: equ 21 
211d			        OPCODE_NOT: equ 21 
211d				OPCODE_UWORDS: equ 22 
211d				OPCODE_BP: equ 23 
211d				OPCODE_MONITOR: equ 24  
211d				OPCODE_MALLOC: equ 25 
211d				OPCODE_FREE: equ 26 
211d				OPCODE_LIST: equ 27 
211d				OPCODE_FORGET: equ 28 
211d				OPCODE_NOP: equ 29 
211d				OPCODE_COMO: equ 30 
211d				OPCODE_COMC: equ 31 
211d			;free to reuse	OPCODE_ENDCORE: equ 32 
211d				OPCODE_AFTERSOUND: equ 33 
211d				OPCODE_GP2: equ 34 
211d				OPCODE_GP3: equ 35 
211d				OPCODE_GP4: equ 36 
211d				OPCODE_SIN: equ 37 
211d				OPCODE_SOUT: equ 38 
211d				OPCODE_SPIO: equ 39 
211d				OPCODE_SPICEH: equ 40 
211d				OPCODE_SPIOb: equ 41 
211d				OPCODE_SPII: equ 42 
211d				OPCODE_SESEL: equ 43 
211d				OPCODE_CARTDEV: equ 44 
211d			; free to reuse	OPCODE_ENDDEVICE: equ 45 
211d				OPCODE_FB: equ 46 
211d				OPCODE_EMIT: equ 47 
211d				OPCODE_DOTH: equ 48 
211d				OPCODE_DOTF: equ 49 
211d				OPCODE_DOT: equ 50 
211d				OPCODE_CLS: equ 51 
211d				OPCODE_DRAW: equ 52 
211d				OPCODE_DUMP: equ 53 
211d				OPCODE_CDUMP: equ 54 
211d				OPCODE_DAT: equ 55 
211d				OPCODE_HOME: equ 56 
211d				OPCODE_SPACE: equ 57 
211d				OPCODE_SPACES: equ 58 
211d				OPCODE_SCROLL: equ 59 
211d				OPCODE_ATQ: equ 60 
211d				OPCODE_AUTODSP: equ 61 
211d				OPCODE_MENU: equ 62 
211d			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
211d				OPCODE_THEN: equ 64 
211d				OPCODE_ELSE: equ 65 
211d				OPCODE_DO: equ 66 
211d				OPCODE_LOOP: equ 67 
211d				OPCODE_I: equ 68 
211d				OPCODE_DLOOP: equ 69  
211d				OPCODE_REPEAT: equ 70  
211d				OPCODE_UNTIL: equ 71 
211d				OPCODE_ENDFLOW: equ 72 
211d				OPCODE_WAITK: equ 73 
211d				OPCODE_ACCEPT: equ 74 
211d				OPCODE_EDIT: equ 75 
211d			;free to reuse	OPCODE_ENDKEY: equ 76 
211d				OPCODE_LZERO: equ 77 
211d				OPCODE_TZERO: equ 78 
211d				OPCODE_LESS: equ 79 
211d				OPCODE_GT: equ 80 
211d				OPCODE_EQUAL: equ 81  
211d			;free to reuse	OPCODE_ENDLOGIC: equ 82 
211d				OPCODE_NEG: equ 83 
211d				OPCODE_DIV: equ 84 
211d				OPCODE_MUL: equ 85 
211d				OPCODE_MIN: equ 86 
211d				OPCODE_MAX: equ 87 
211d				OPCODE_RND16: equ 88 
211d				OPCODE_RND8: equ 89 
211d				OPCODE_RND: equ 90 
211d			;free to reuse	OPCODE_ENDMATHS: equ 91  
211d				OPCODE_BYNAME: equ 92 
211d				OPCODE_DIR: equ 93 
211d				OPCODE_SAVE: equ 94 
211d				OPCODE_LOAD: equ 95 
211d				OPCODE_BSAVE: equ 96 
211d				OPCODE_BLOAD: equ 97 
211d				OPCODE_SEO: equ 98  
211d				OPCODE_SEI: equ 99 
211d				OPCODE_SFREE: equ 100 
211d				OPCODE_SIZE: equ 101 
211d				OPCODE_CREATE: equ 102 
211d				OPCODE_APPEND: equ 103 
211d				OPCODE_SDEL: equ 104 
211d				OPCODE_OPEN: equ 105 
211d				OPCODE_READ: equ 106 
211d				OPCODE_EOF: equ 106 
211d				OPCODE_FORMAT: equ 107 
211d				OPCODE_LABEL: equ 108 
211d				OPCODE_LABELS: equ 109 
211d			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
211d				OPCODE_UPPER: equ 111 
211d				OPCODE_LOWER: equ 112 
211d				OPCODE_SUBSTR: equ 113 
211d				OPCODE_LEFT: equ 114 
211d				OPCODE_RIGHT: equ 115 
211d				OPCODE_STR2NUM: equ 116 
211d				OPCODE_NUM2STR: equ 117 
211d				OPCODE_CONCAT: equ 118 
211d				OPCODE_FIND: equ 119 
211d				OPCODE_LEN: equ 120 
211d				OPCODE_CHAR: equ 121 
211d			; free to reuse	OPCODE_STRLEN: equ 122 
211d			; free to reuse	OPCODE_ENDSTR: equ 123 
211d				OPCODE_V0S: equ 124 
211d				OPCODE_V0Q: equ 125 
211d				OPCODE_V1S: equ 126 
211d				OPCODE_V1Q: equ 127 
211d				OPCODE_V2S: equ 128 
211d				OPCODE_V2Q: equ 129 
211d				OPCODE_V3S: equ 130 
211d				OPCODE_V3Q: equ 131 
211d			;free to reuse	OPCODE_END: equ 132 
211d				OPCODE_ZDUP: equ 133 
211d			 
211d			; eof 
# End of file forth_opcodes.asm
211d			 
211d			include "forth_words_core.asm" 
211d			 
211d			; | ## Core Words 
211d			 
211d			;if MALLOC_4 
211d			 
211d			.HEAP: 
211d				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
211d 15				db WORD_SYS_CORE+OPCODE_HEAP             
211e 5c 21			dw .EXEC            
2120 05				db 4 + 1 
2121 .. 00			db "HEAP",0              
2126				endm 
# End of macro CWHEAD
2126			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2126			; | | u1 - Current number of bytes in the heap 
2126			; | | u2 - Remaining bytes left on the heap 
2126			; | |  
2126			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2126			 
2126			 
2126					if DEBUG_FORTH_WORDS_KEY 
2126						DMARK "HEP" 
2126 f5				push af  
2127 3a 3b 21			ld a, (.dmark)  
212a 32 71 ee			ld (debug_mark),a  
212d 3a 3c 21			ld a, (.dmark+1)  
2130 32 72 ee			ld (debug_mark+1),a  
2133 3a 3d 21			ld a, (.dmark+2)  
2136 32 73 ee			ld (debug_mark+2),a  
2139 18 03			jr .pastdmark  
213b ..			.dmark: db "HEP"  
213e f1			.pastdmark: pop af  
213f			endm  
# End of macro DMARK
213f						CALLMONITOR 
213f cd ae 15			call break_point_state  
2142				endm  
# End of macro CALLMONITOR
2142					endif 
2142 2a c8 61				ld hl, (free_list )      
2145 11 cd 61				ld de, heap_start 
2148			 
2148 ed 52				sbc hl, de  
214a			 
214a cd 1f 1c				call forth_push_numhl 
214d			 
214d			 
214d ed 5b c8 61			ld de, (free_list )      
2151 21 b1 e2				ld hl, heap_end 
2154			 
2154 ed 52				sbc hl, de 
2156			 
2156 cd 1f 1c				call forth_push_numhl 
2159					 
2159			 
2159					 
2159			 
2159			 
2159			 
2159					NEXTW 
2159 c3 c5 1f			jp macro_next 
215c				endm 
# End of macro NEXTW
215c			;endif 
215c			 
215c			.EXEC: 
215c			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
215c			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
215c			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
215c			;; > > 
215c			;; > >   
215c			;	STACKFRAME OFF $5efe $5f9f 
215c			; 
215c			;		if DEBUG_FORTH_WORDS_KEY 
215c			;			DMARK "EXE" 
215c			;			CALLMONITOR 
215c			;		endif 
215c			; 
215c			;	FORTH_DSP_VALUEHL 
215c			; 
215c			;	FORTH_DSP_POP 
215c			; 
215c			;		if DEBUG_FORTH_WORDS 
215c			;			DMARK "EX1" 
215c			;			CALLMONITOR 
215c			;		endif 
215c			;;	ld e,(hl) 
215c			;;	inc hl 
215c			;;	ld d,(hl) 
215c			;;	ex de,hl 
215c			; 
215c			;;		if DEBUG_FORTH_WORDS 
215c			;;			DMARK "EX2" 
215c			;;			CALLMONITOR 
215c			;;		endif 
215c			;	push hl 
215c			; 
215c			;	;ld a, 0 
215c			;	;ld a, FORTH_END_BUFFER 
215c			;	call strlenz 
215c			;	inc hl   ; include zero term to copy 
215c			;	inc hl   ; include term 
215c			;	inc hl   ; include term 
215c			;	ld b,0 
215c			;	ld c,l 
215c			;	pop hl 
215c			;	ld de, execscratch 
215c			;		if DEBUG_FORTH_WORDS 
215c			;			DMARK "EX3" 
215c			;			CALLMONITOR 
215c			;		endif 
215c			;	ldir 
215c			; 
215c			; 
215c			;	ld hl, execscratch 
215c			; 
215c			;		if DEBUG_FORTH_WORDS 
215c			;			DMARK "EXe" 
215c			;			CALLMONITOR 
215c			;		endif 
215c			; 
215c			;	call forthparse 
215c			;	call forthexec 
215c			;;	call forthexec_cleanup 
215c			;;	call forthparse 
215c			;;	call forthexec 
215c			; 
215c			;	STACKFRAMECHK OFF $5efe $5f9f 
215c			; 
215c			;	; an immediate word so no need to process any more words 
215c			;	ret 
215c			;	NEXTW 
215c			 
215c			; dead code - old version  
215c			;	FORTH_RSP_NEXT 
215c			 
215c			;  
215c			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
215c			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
215c			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
215c			;	push hl 
215c			;	push de 
215c			;	push bc 
215c			; 
215c			; 
215c			;		if DEBUG_FORTH_WORDS_KEY 
215c			;			DMARK "EXR" 
215c			;			CALLMONITOR 
215c			;		endif 
215c			; 
215c			; 
215c			; 
215c			;	;v5 FORTH_DSP_VALUE 
215c			;	FORTH_DSP_VALUEHL 
215c			; 
215c			;	; TODO do string type checks 
215c			; 
215c			;;v5	inc hl   ; skip type 
215c			; 
215c			;	push hl  ; source code  
215c			;		if DEBUG_FORTH_WORDS 
215c			;			DMARK "EX1" 
215c			;			CALLMONITOR 
215c			;		endif 
215c			;	ld a, 0 
215c			;	call strlent 
215c			; 
215c			;	inc hl 
215c			;	inc hl 
215c			;	inc hl 
215c			;	inc hl 
215c			; 
215c			;	push hl    ; size 
215c			; 
215c			;		if DEBUG_FORTH_WORDS 
215c			;			DMARK "EX2" 
215c			;			CALLMONITOR 
215c			;		endif 
215c			;	call malloc 
215c			; 
215c			;	ex de, hl    ; de now contains malloc area 
215c			;	pop bc   	; get byte count 
215c			;	pop hl      ; get string to copy 
215c			; 
215c			;	push de     ; save malloc for free later 
215c			; 
215c			;		if DEBUG_FORTH_WORDS 
215c			;			DMARK "EX3" 
215c			;			CALLMONITOR 
215c			;		endif 
215c			;	ldir       ; duplicate string 
215c			; 
215c			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
215c			;	 
215c			;	; TODO fix the parse would be better than this...  
215c			;	ex de, hl 
215c			;	dec hl 
215c			;	ld a, 0 
215c			;	ld (hl), a 
215c			;	dec hl 
215c			;	ld a, ' ' 
215c			;	ld (hl), a 
215c			;	dec hl 
215c			;	ld (hl), a 
215c			; 
215c			;	dec hl 
215c			;	ld (hl), a 
215c			; 
215c			; 
215c			;	FORTH_DSP_POP  
215c			; 
215c			;	pop hl     
215c			;	push hl    ; save malloc area 
215c			; 
215c			;		if DEBUG_FORTH_WORDS 
215c			;			DMARK "EX4" 
215c			;			CALLMONITOR 
215c			;		endif 
215c			; 
215c			;	call forthparse 
215c			;	call forthexec 
215c			;	 
215c			;	pop hl 
215c			;	if DEBUG_FORTH_WORDS 
215c			;		DMARK "EX5" 
215c			;		CALLMONITOR 
215c			;	endif 
215c			; 
215c			;	if FORTH_ENABLE_FREE 
215c			;	call free 
215c			;	endif 
215c			; 
215c			;	if DEBUG_FORTH_WORDS 
215c			;		DMARK "EX6" 
215c			;		CALLMONITOR 
215c			;	endif 
215c			; 
215c			;	pop bc 
215c			;	pop de 
215c			;	pop hl 
215c			;;	FORTH_RSP_POP	  
215c			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
215c			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
215c			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
215c			; 
215c			;	if DEBUG_FORTH_WORDS 
215c			;		DMARK "EX7" 
215c			;		CALLMONITOR 
215c			;	endif 
215c			;	NEXTW 
215c			 
215c			;.STKEXEC: 
215c			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
215c			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
215c			; 
215c			; 
215c			;		if DEBUG_FORTH_WORDS_KEY 
215c			;			DMARK "STX" 
215c			;			CALLMONITOR 
215c			;		endif 
215c			; 
215c			;	FORTH_DSP_VALUEHL 
215c			; 
215c			;	ld (store_tmp1), hl    ; count 
215c			; 
215c			;	FORTH_DSP_POP 
215c			;.stkexec1: 
215c			;	ld hl, (store_tmp1)   ; count 
215c			;	ld a, 0 
215c			;	cp l 
215c			;	ret z 
215c			; 
215c			;	dec hl 
215c			;	ld (store_tmp1), hl    ; count 
215c			;	 
215c			;	FORTH_DSP_VALUEHL 
215c			;	push hl 
215c			;	 
215c			;		if DEBUG_FORTH_WORDS 
215c			;			DMARK "EXp" 
215c			;			CALLMONITOR 
215c			;		endif 
215c			;	FORTH_DSP_POP 
215c			; 
215c			;	call strlenz 
215c			;	inc hl   ; include zero term to copy 
215c			;	inc hl   ; include zero term to copy 
215c			;	inc hl   ; include zero term to copy 
215c			;	ld b,0 
215c			;	ld c,l 
215c			;	pop hl 
215c			;	ld de, execscratch 
215c			;		if DEBUG_FORTH_WORDS 
215c			;			DMARK "EX3" 
215c			;			CALLMONITOR 
215c			;		endif 
215c			;	ldir 
215c			; 
215c			; 
215c			;	ld hl, execscratch 
215c			; 
215c			;		if DEBUG_FORTH_WORDS 
215c			;			DMARK "EXP" 
215c			;			CALLMONITOR 
215c			;		endif 
215c			; 
215c			;	call forthparse 
215c			;	ld hl, execscratch 
215c			;		if DEBUG_FORTH_WORDS 
215c			;			DMARK "EXx" 
215c			;			CALLMONITOR 
215c			;		endif 
215c			;	call forthexec 
215c			; 
215c			;	jp .stkexec1 
215c			; 
215c			;	ret 
215c			 
215c			 
215c			.DUP: 
215c				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
215c 17				db WORD_SYS_CORE+OPCODE_DUP             
215d d2 21			dw .ZDUP            
215f 04				db 3 + 1 
2160 .. 00			db "DUP",0              
2164				endm 
# End of macro CWHEAD
2164			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2164			 
2164					if DEBUG_FORTH_WORDS_KEY 
2164						DMARK "DUP" 
2164 f5				push af  
2165 3a 79 21			ld a, (.dmark)  
2168 32 71 ee			ld (debug_mark),a  
216b 3a 7a 21			ld a, (.dmark+1)  
216e 32 72 ee			ld (debug_mark+1),a  
2171 3a 7b 21			ld a, (.dmark+2)  
2174 32 73 ee			ld (debug_mark+2),a  
2177 18 03			jr .pastdmark  
2179 ..			.dmark: db "DUP"  
217c f1			.pastdmark: pop af  
217d			endm  
# End of macro DMARK
217d						CALLMONITOR 
217d cd ae 15			call break_point_state  
2180				endm  
# End of macro CALLMONITOR
2180					endif 
2180			 
2180					FORTH_DSP 
2180 cd dc 1d			call macro_forth_dsp 
2183				endm 
# End of macro FORTH_DSP
2183			 
2183 7e					ld a, (HL) 
2184 fe 01				cp DS_TYPE_STR 
2186 20 25				jr nz, .dupinum 
2188			 
2188					; push another string 
2188			 
2188					FORTH_DSP_VALUEHL     		 
2188 cd 16 1e			call macro_dsp_valuehl 
218b				endm 
# End of macro FORTH_DSP_VALUEHL
218b			 
218b				if DEBUG_FORTH_WORDS 
218b					DMARK "DUs" 
218b f5				push af  
218c 3a a0 21			ld a, (.dmark)  
218f 32 71 ee			ld (debug_mark),a  
2192 3a a1 21			ld a, (.dmark+1)  
2195 32 72 ee			ld (debug_mark+1),a  
2198 3a a2 21			ld a, (.dmark+2)  
219b 32 73 ee			ld (debug_mark+2),a  
219e 18 03			jr .pastdmark  
21a0 ..			.dmark: db "DUs"  
21a3 f1			.pastdmark: pop af  
21a4			endm  
# End of macro DMARK
21a4					CALLMONITOR 
21a4 cd ae 15			call break_point_state  
21a7				endm  
# End of macro CALLMONITOR
21a7				endif 
21a7 cd 8d 1c				call forth_push_str 
21aa			 
21aa					NEXTW 
21aa c3 c5 1f			jp macro_next 
21ad				endm 
# End of macro NEXTW
21ad			 
21ad			 
21ad			.dupinum: 
21ad					 
21ad			 
21ad			 
21ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21ad cd 16 1e			call macro_dsp_valuehl 
21b0				endm 
# End of macro FORTH_DSP_VALUEHL
21b0			 
21b0				; TODO add floating point number detection 
21b0			 
21b0				if DEBUG_FORTH_WORDS 
21b0					DMARK "DUi" 
21b0 f5				push af  
21b1 3a c5 21			ld a, (.dmark)  
21b4 32 71 ee			ld (debug_mark),a  
21b7 3a c6 21			ld a, (.dmark+1)  
21ba 32 72 ee			ld (debug_mark+1),a  
21bd 3a c7 21			ld a, (.dmark+2)  
21c0 32 73 ee			ld (debug_mark+2),a  
21c3 18 03			jr .pastdmark  
21c5 ..			.dmark: db "DUi"  
21c8 f1			.pastdmark: pop af  
21c9			endm  
# End of macro DMARK
21c9					CALLMONITOR 
21c9 cd ae 15			call break_point_state  
21cc				endm  
# End of macro CALLMONITOR
21cc				endif 
21cc			 
21cc cd 1f 1c				call forth_push_numhl 
21cf					NEXTW 
21cf c3 c5 1f			jp macro_next 
21d2				endm 
# End of macro NEXTW
21d2			.ZDUP: 
21d2				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
21d2 99				db WORD_SYS_CORE+OPCODE_ZDUP             
21d3 0a 22			dw .SWAP            
21d5 05				db 4 + 1 
21d6 .. 00			db "?DUP",0              
21db				endm 
# End of macro CWHEAD
21db			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
21db			 
21db					if DEBUG_FORTH_WORDS_KEY 
21db						DMARK "qDU" 
21db f5				push af  
21dc 3a f0 21			ld a, (.dmark)  
21df 32 71 ee			ld (debug_mark),a  
21e2 3a f1 21			ld a, (.dmark+1)  
21e5 32 72 ee			ld (debug_mark+1),a  
21e8 3a f2 21			ld a, (.dmark+2)  
21eb 32 73 ee			ld (debug_mark+2),a  
21ee 18 03			jr .pastdmark  
21f0 ..			.dmark: db "qDU"  
21f3 f1			.pastdmark: pop af  
21f4			endm  
# End of macro DMARK
21f4						CALLMONITOR 
21f4 cd ae 15			call break_point_state  
21f7				endm  
# End of macro CALLMONITOR
21f7					endif 
21f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21f7 cd 16 1e			call macro_dsp_valuehl 
21fa				endm 
# End of macro FORTH_DSP_VALUEHL
21fa			 
21fa e5					push hl 
21fb			 
21fb					; is it a zero? 
21fb			 
21fb 3e 00				ld a, 0 
21fd 84					add h 
21fe 85					add l 
21ff			 
21ff e1					pop hl 
2200			 
2200 fe 00				cp 0 
2202 28 03				jr z, .dup2orig 
2204			 
2204			 
2204 cd 1f 1c				call forth_push_numhl 
2207			 
2207			 
2207				; TODO add floating point number detection 
2207			 
2207			.dup2orig: 
2207			 
2207					NEXTW 
2207 c3 c5 1f			jp macro_next 
220a				endm 
# End of macro NEXTW
220a			.SWAP: 
220a				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
220a 18				db WORD_SYS_CORE+OPCODE_SWAP             
220b 49 22			dw .COLN            
220d 05				db 4 + 1 
220e .. 00			db "SWAP",0              
2213				endm 
# End of macro CWHEAD
2213			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2213					if DEBUG_FORTH_WORDS_KEY 
2213						DMARK "SWP" 
2213 f5				push af  
2214 3a 28 22			ld a, (.dmark)  
2217 32 71 ee			ld (debug_mark),a  
221a 3a 29 22			ld a, (.dmark+1)  
221d 32 72 ee			ld (debug_mark+1),a  
2220 3a 2a 22			ld a, (.dmark+2)  
2223 32 73 ee			ld (debug_mark+2),a  
2226 18 03			jr .pastdmark  
2228 ..			.dmark: db "SWP"  
222b f1			.pastdmark: pop af  
222c			endm  
# End of macro DMARK
222c						CALLMONITOR 
222c cd ae 15			call break_point_state  
222f				endm  
# End of macro CALLMONITOR
222f					endif 
222f			 
222f					FORTH_DSP_VALUEHL 
222f cd 16 1e			call macro_dsp_valuehl 
2232				endm 
# End of macro FORTH_DSP_VALUEHL
2232 e5					push hl     ; w2 
2233			 
2233					FORTH_DSP_POP 
2233 cd ce 1e			call macro_forth_dsp_pop 
2236				endm 
# End of macro FORTH_DSP_POP
2236			 
2236					FORTH_DSP_VALUEHL 
2236 cd 16 1e			call macro_dsp_valuehl 
2239				endm 
# End of macro FORTH_DSP_VALUEHL
2239			 
2239					FORTH_DSP_POP 
2239 cd ce 1e			call macro_forth_dsp_pop 
223c				endm 
# End of macro FORTH_DSP_POP
223c			 
223c d1					pop de     ; w2	, hl = w1 
223d			 
223d eb					ex de, hl 
223e d5					push de 
223f			 
223f cd 1f 1c				call forth_push_numhl 
2242			 
2242 e1					pop hl 
2243			 
2243 cd 1f 1c				call forth_push_numhl 
2246					 
2246			 
2246					NEXTW 
2246 c3 c5 1f			jp macro_next 
2249				endm 
# End of macro NEXTW
2249			.COLN: 
2249				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2249 19				db WORD_SYS_CORE+OPCODE_COLN             
224a d5 23			dw .SCOLN            
224c 02				db 1 + 1 
224d .. 00			db ":",0              
224f				endm 
# End of macro CWHEAD
224f			; | : ( -- )         Create new word | DONE 
224f			 
224f					if DEBUG_FORTH_WORDS_KEY 
224f						DMARK "CLN" 
224f f5				push af  
2250 3a 64 22			ld a, (.dmark)  
2253 32 71 ee			ld (debug_mark),a  
2256 3a 65 22			ld a, (.dmark+1)  
2259 32 72 ee			ld (debug_mark+1),a  
225c 3a 66 22			ld a, (.dmark+2)  
225f 32 73 ee			ld (debug_mark+2),a  
2262 18 03			jr .pastdmark  
2264 ..			.dmark: db "CLN"  
2267 f1			.pastdmark: pop af  
2268			endm  
# End of macro DMARK
2268						CALLMONITOR 
2268 cd ae 15			call break_point_state  
226b				endm  
# End of macro CALLMONITOR
226b					endif 
226b				STACKFRAME OFF $8efe $989f 
226b				if DEBUG_STACK_IMB 
226b					if OFF 
226b						exx 
226b						ld de, $8efe 
226b						ld a, d 
226b						ld hl, curframe 
226b						call hexout 
226b						ld a, e 
226b						ld hl, curframe+2 
226b						call hexout 
226b						ld hl, $8efe 
226b						push hl 
226b						ld hl, $989f 
226b						push hl 
226b						exx 
226b					endif 
226b				endif 
226b			endm 
# End of macro STACKFRAME
226b				; get parser buffer length  of new word 
226b			 
226b				 
226b			 
226b					; move tok past this to start of name defintition 
226b					; TODO get word to define 
226b					; TODO Move past word token 
226b					; TODO get length of string up to the ';' 
226b			 
226b 2a cc e5			ld hl, (os_tok_ptr) 
226e 23				inc hl 
226f 23				inc hl 
2270			 
2270 3e 3b			ld a, ';' 
2272 cd 16 12			call strlent 
2275			 
2275 7d				ld a,l 
2276 32 c7 e2			ld (os_new_parse_len), a 
2279			 
2279			 
2279			if DEBUG_FORTH_UWORD 
2279 ed 5b cc e5		ld de, (os_tok_ptr) 
227d						DMARK ":01" 
227d f5				push af  
227e 3a 92 22			ld a, (.dmark)  
2281 32 71 ee			ld (debug_mark),a  
2284 3a 93 22			ld a, (.dmark+1)  
2287 32 72 ee			ld (debug_mark+1),a  
228a 3a 94 22			ld a, (.dmark+2)  
228d 32 73 ee			ld (debug_mark+2),a  
2290 18 03			jr .pastdmark  
2292 ..			.dmark: db ":01"  
2295 f1			.pastdmark: pop af  
2296			endm  
# End of macro DMARK
2296				CALLMONITOR 
2296 cd ae 15			call break_point_state  
2299				endm  
# End of macro CALLMONITOR
2299			endif 
2299			 
2299			; 
2299			;  new word memory layout: 
2299			;  
2299			;    : adg 6666 ;  
2299			; 
2299			;    db   1     ; user defined word  
2299 23				inc hl    
229a			;    dw   sysdict 
229a 23				inc hl 
229b 23				inc hl 
229c			;    db <word len>+1 (for null) 
229c 23				inc hl 
229d			;    db .... <word> 
229d			; 
229d			 
229d 23				inc hl    ; some extras for the word preamble before the above 
229e 23				inc hl 
229f 23				inc hl 
22a0 23				inc hl 
22a1 23				inc hl 
22a2 23				inc hl 
22a3 23				inc hl  
22a4 23				inc hl 
22a5 23				inc hl 
22a6 23				inc hl 
22a7 23				inc hl 
22a8 23				inc hl 
22a9 23				inc hl 
22aa 23				inc hl     ; TODO how many do we really need?     maybe only 6 
22ab			;       exec word buffer 
22ab			;	<ptr word>   
22ab 23				inc hl 
22ac 23				inc hl 
22ad			;       <word list><null term> 7F final term 
22ad			 
22ad			 
22ad			if DEBUG_FORTH_UWORD 
22ad						DMARK ":02" 
22ad f5				push af  
22ae 3a c2 22			ld a, (.dmark)  
22b1 32 71 ee			ld (debug_mark),a  
22b4 3a c3 22			ld a, (.dmark+1)  
22b7 32 72 ee			ld (debug_mark+1),a  
22ba 3a c4 22			ld a, (.dmark+2)  
22bd 32 73 ee			ld (debug_mark+2),a  
22c0 18 03			jr .pastdmark  
22c2 ..			.dmark: db ":02"  
22c5 f1			.pastdmark: pop af  
22c6			endm  
# End of macro DMARK
22c6				CALLMONITOR 
22c6 cd ae 15			call break_point_state  
22c9				endm  
# End of macro CALLMONITOR
22c9			endif 
22c9			 
22c9				 
22c9					; malloc the size 
22c9			 
22c9 cd 74 12				call malloc 
22cc 22 c9 e2				ld (os_new_malloc), hl     ; save malloc start 
22cf			 
22cf			;    db   1     ; user defined word  
22cf 3e 01				ld a, WORD_SYS_UWORD  
22d1 77					ld (hl), a 
22d2				 
22d2 23				inc hl    
22d3			;    dw   sysdict 
22d3 11 1d 21			ld de, sysdict       ; continue on with the scan to the system dict 
22d6 73				ld (hl), e 
22d7 23				inc hl 
22d8 72				ld (hl), d 
22d9 23				inc hl 
22da			 
22da			 
22da			;    Setup dict word 
22da			 
22da 23				inc hl 
22db 22 c3 e2			ld (os_new_work_ptr), hl     ; save start of dict word  
22de			 
22de				; 1. get length of dict word 
22de			 
22de			 
22de 2a cc e5			ld hl, (os_tok_ptr) 
22e1 23				inc hl 
22e2 23				inc hl    ; position to start of dict word 
22e3 3e 00			ld a, 0 
22e5 cd 16 12			call strlent 
22e8			 
22e8			 
22e8 23				inc hl    ; to include null??? 
22e9			 
22e9				; write length of dict word 
22e9			 
22e9 ed 5b c3 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
22ed 1b				dec de 
22ee eb				ex de, hl 
22ef 73				ld (hl), e 
22f0 eb				ex de, hl 
22f1			 
22f1				 
22f1			 
22f1				; copy  
22f1 4d				ld c, l 
22f2 06 00			ld b, 0 
22f4 ed 5b c3 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
22f8 2a cc e5			ld hl, (os_tok_ptr) 
22fb 23				inc hl 
22fc 23				inc hl    ; position to start of dict word 
22fd				 
22fd			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
22fd				 
22fd				; TODO need to convert word to upper case 
22fd			 
22fd			ucasetok:	 
22fd 7e				ld a,(hl) 
22fe cd 02 12			call toUpper 
2301 77				ld (hl),a 
2302 ed a0			ldi 
2304 f2 fd 22		 	jp p, ucasetok 
2307			 
2307			 
2307			 
2307				; de now points to start of where the word body code should be placed 
2307 ed 53 c3 e2		ld (os_new_work_ptr), de 
230b				; hl now points to the words to throw at forthexec which needs to be copied 
230b 22 c1 e2			ld (os_new_src_ptr), hl 
230e			 
230e				; TODO add 'call to forthexec' 
230e			 
230e			if DEBUG_FORTH_UWORD 
230e c5				push bc 
230f ed 4b c9 e2		ld bc, (os_new_malloc) 
2313						DMARK ":0x" 
2313 f5				push af  
2314 3a 28 23			ld a, (.dmark)  
2317 32 71 ee			ld (debug_mark),a  
231a 3a 29 23			ld a, (.dmark+1)  
231d 32 72 ee			ld (debug_mark+1),a  
2320 3a 2a 23			ld a, (.dmark+2)  
2323 32 73 ee			ld (debug_mark+2),a  
2326 18 03			jr .pastdmark  
2328 ..			.dmark: db ":0x"  
232b f1			.pastdmark: pop af  
232c			endm  
# End of macro DMARK
232c				CALLMONITOR 
232c cd ae 15			call break_point_state  
232f				endm  
# End of macro CALLMONITOR
232f c1				pop bc 
2330			endif 
2330			 
2330			 
2330				; create word preamble which should be: 
2330			 
2330			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2330			 
2330				;    ld hl, <word code> 
2330				;    jp user_exec 
2330			        ;    <word code bytes> 
2330			 
2330			 
2330			;	inc de     ; TODO ??? or are we already past the word's null 
2330 eb				ex de, hl 
2331			 
2331 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2333			 
2333 23				inc hl 
2334 22 bd e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2337 23				inc hl 
2338			 
2338 23				inc hl 
2339 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
233b			 
233b 01 d7 49			ld bc, user_exec 
233e 23				inc hl 
233f 71				ld (hl), c     ; poke address of user_exec 
2340 23				inc hl 
2341 70				ld (hl), b     
2342			 ; 
2342			;	inc hl 
2342			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2342			; 
2342			; 
2342			;	ld bc, macro_forth_rsp_next 
2342			;	inc hl 
2342			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2342			;	inc hl 
2342			;	ld (hl), b     
2342			 ; 
2342			;	inc hl 
2342			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2342			; 
2342			; 
2342			;	inc hl 
2342			;	ld bc, forthexec 
2342			;	ld (hl), c     ; poke address of forthexec 
2342			;	inc hl 
2342			;	ld (hl), b      
2342			; 
2342			;	inc hl 
2342			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2342			; 
2342			;	ld bc, user_dict_next 
2342			;	inc hl 
2342			;	ld (hl), c     ; poke address of forthexec 
2342			;	inc hl 
2342			;	ld (hl), b      
2342			 
2342				; hl is now where we need to copy the word byte data to save this 
2342			 
2342 23				inc hl 
2343 22 bf e2			ld (os_new_exec), hl 
2346				 
2346				; copy definition 
2346			 
2346 eb				ex de, hl 
2347			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2347			;	inc de    ; skip the PC for this parse 
2347 3a c7 e2			ld a, (os_new_parse_len) 
234a 4f				ld c, a 
234b 06 00			ld b, 0 
234d ed b0			ldir		 ; copy defintion 
234f			 
234f			 
234f				; poke the address of where the new word bytes live for forthexec 
234f			 
234f 2a bd e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2352			 
2352 ed 5b bf e2		ld de, (os_new_exec)      
2356				 
2356 73				ld (hl), e 
2357 23				inc hl 
2358 72				ld (hl), d 
2359			 
2359					; TODO copy last user dict word next link to this word 
2359					; TODO update last user dict word to point to this word 
2359			; 
2359			; hl f923 de 812a ; bc 811a 
2359			 
2359			if DEBUG_FORTH_UWORD 
2359 c5				push bc 
235a ed 4b c9 e2		ld bc, (os_new_malloc) 
235e						DMARK ":0A" 
235e f5				push af  
235f 3a 73 23			ld a, (.dmark)  
2362 32 71 ee			ld (debug_mark),a  
2365 3a 74 23			ld a, (.dmark+1)  
2368 32 72 ee			ld (debug_mark+1),a  
236b 3a 75 23			ld a, (.dmark+2)  
236e 32 73 ee			ld (debug_mark+2),a  
2371 18 03			jr .pastdmark  
2373 ..			.dmark: db ":0A"  
2376 f1			.pastdmark: pop af  
2377			endm  
# End of macro DMARK
2377				CALLMONITOR 
2377 cd ae 15			call break_point_state  
237a				endm  
# End of macro CALLMONITOR
237a c1				pop bc 
237b			endif 
237b			if DEBUG_FORTH_UWORD 
237b c5				push bc 
237c ed 4b c9 e2		ld bc, (os_new_malloc) 
2380 03				inc bc 
2381 03				inc bc 
2382 03				inc bc 
2383 03				inc bc 
2384 03				inc bc 
2385 03				inc bc 
2386 03				inc bc 
2387 03				inc bc 
2388			 
2388						DMARK ":0B" 
2388 f5				push af  
2389 3a 9d 23			ld a, (.dmark)  
238c 32 71 ee			ld (debug_mark),a  
238f 3a 9e 23			ld a, (.dmark+1)  
2392 32 72 ee			ld (debug_mark+1),a  
2395 3a 9f 23			ld a, (.dmark+2)  
2398 32 73 ee			ld (debug_mark+2),a  
239b 18 03			jr .pastdmark  
239d ..			.dmark: db ":0B"  
23a0 f1			.pastdmark: pop af  
23a1			endm  
# End of macro DMARK
23a1				CALLMONITOR 
23a1 cd ae 15			call break_point_state  
23a4				endm  
# End of macro CALLMONITOR
23a4 c1				pop bc 
23a5			endif 
23a5			 
23a5			; update word dict linked list for new word 
23a5			 
23a5			 
23a5 2a c8 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
23a8 23			inc hl     ; move to next work linked list ptr 
23a9			 
23a9 ed 5b c9 e2	ld de, (os_new_malloc)		 ; new next word 
23ad 73			ld (hl), e 
23ae 23			inc hl 
23af 72			ld (hl), d 
23b0			 
23b0			if DEBUG_FORTH_UWORD 
23b0 ed 4b c8 e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
23b4			endif 
23b4			 
23b4 ed 53 c8 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
23b8			 
23b8			 
23b8			if DEBUG_FORTH_UWORD 
23b8						DMARK ":0+" 
23b8 f5				push af  
23b9 3a cd 23			ld a, (.dmark)  
23bc 32 71 ee			ld (debug_mark),a  
23bf 3a ce 23			ld a, (.dmark+1)  
23c2 32 72 ee			ld (debug_mark+1),a  
23c5 3a cf 23			ld a, (.dmark+2)  
23c8 32 73 ee			ld (debug_mark+2),a  
23cb 18 03			jr .pastdmark  
23cd ..			.dmark: db ":0+"  
23d0 f1			.pastdmark: pop af  
23d1			endm  
# End of macro DMARK
23d1				CALLMONITOR 
23d1 cd ae 15			call break_point_state  
23d4				endm  
# End of macro CALLMONITOR
23d4			endif 
23d4			 
23d4				STACKFRAMECHK OFF $8efe $989f 
23d4				if DEBUG_STACK_IMB 
23d4					if OFF 
23d4						exx 
23d4						ld hl, $989f 
23d4						pop de   ; $989f 
23d4						call cmp16 
23d4						jr nz, .spnosame 
23d4						ld hl, $8efe 
23d4						pop de   ; $8efe 
23d4						call cmp16 
23d4						jr z, .spfrsame 
23d4						.spnosame: call showsperror 
23d4						.spfrsame: nop 
23d4						exx 
23d4					endif 
23d4				endif 
23d4			endm 
# End of macro STACKFRAMECHK
23d4			 
23d4 c9			ret    ; dont process any remaining parser tokens as they form new word 
23d5			 
23d5			 
23d5			 
23d5			 
23d5			;		NEXT 
23d5			.SCOLN: 
23d5			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
23d5 06				db OPCODE_SCOLN 
23d6 21 24			dw .DROP 
23d8 02				db 2 
23d9 .. 00			db ";",0           
23db			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
23db					if DEBUG_FORTH_WORDS_KEY 
23db						DMARK "SCN" 
23db f5				push af  
23dc 3a f0 23			ld a, (.dmark)  
23df 32 71 ee			ld (debug_mark),a  
23e2 3a f1 23			ld a, (.dmark+1)  
23e5 32 72 ee			ld (debug_mark+1),a  
23e8 3a f2 23			ld a, (.dmark+2)  
23eb 32 73 ee			ld (debug_mark+2),a  
23ee 18 03			jr .pastdmark  
23f0 ..			.dmark: db "SCN"  
23f3 f1			.pastdmark: pop af  
23f4			endm  
# End of macro DMARK
23f4						CALLMONITOR 
23f4 cd ae 15			call break_point_state  
23f7				endm  
# End of macro CALLMONITOR
23f7					endif 
23f7					FORTH_RSP_TOS 
23f7 cd dd 1b			call macro_forth_rsp_tos 
23fa				endm 
# End of macro FORTH_RSP_TOS
23fa e5					push hl 
23fb					FORTH_RSP_POP 
23fb cd e7 1b			call macro_forth_rsp_pop 
23fe				endm 
# End of macro FORTH_RSP_POP
23fe e1					pop hl 
23ff			;		ex de,hl 
23ff 22 cc e5				ld (os_tok_ptr),hl 
2402			 
2402			if DEBUG_FORTH_UWORD 
2402						DMARK "SCL" 
2402 f5				push af  
2403 3a 17 24			ld a, (.dmark)  
2406 32 71 ee			ld (debug_mark),a  
2409 3a 18 24			ld a, (.dmark+1)  
240c 32 72 ee			ld (debug_mark+1),a  
240f 3a 19 24			ld a, (.dmark+2)  
2412 32 73 ee			ld (debug_mark+2),a  
2415 18 03			jr .pastdmark  
2417 ..			.dmark: db "SCL"  
241a f1			.pastdmark: pop af  
241b			endm  
# End of macro DMARK
241b				CALLMONITOR 
241b cd ae 15			call break_point_state  
241e				endm  
# End of macro CALLMONITOR
241e			endif 
241e					NEXTW 
241e c3 c5 1f			jp macro_next 
2421				endm 
# End of macro NEXTW
2421			 
2421			.DROP: 
2421				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2421 1b				db WORD_SYS_CORE+OPCODE_DROP             
2422 4c 24			dw .DUP2            
2424 05				db 4 + 1 
2425 .. 00			db "DROP",0              
242a				endm 
# End of macro CWHEAD
242a			; | DROP ( w -- )   drop the TOS item   | DONE 
242a					if DEBUG_FORTH_WORDS_KEY 
242a						DMARK "DRP" 
242a f5				push af  
242b 3a 3f 24			ld a, (.dmark)  
242e 32 71 ee			ld (debug_mark),a  
2431 3a 40 24			ld a, (.dmark+1)  
2434 32 72 ee			ld (debug_mark+1),a  
2437 3a 41 24			ld a, (.dmark+2)  
243a 32 73 ee			ld (debug_mark+2),a  
243d 18 03			jr .pastdmark  
243f ..			.dmark: db "DRP"  
2442 f1			.pastdmark: pop af  
2443			endm  
# End of macro DMARK
2443						CALLMONITOR 
2443 cd ae 15			call break_point_state  
2446				endm  
# End of macro CALLMONITOR
2446					endif 
2446					FORTH_DSP_POP 
2446 cd ce 1e			call macro_forth_dsp_pop 
2449				endm 
# End of macro FORTH_DSP_POP
2449					NEXTW 
2449 c3 c5 1f			jp macro_next 
244c				endm 
# End of macro NEXTW
244c			.DUP2: 
244c				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
244c 1c				db WORD_SYS_CORE+OPCODE_DUP2             
244d 91 24			dw .DROP2            
244f 05				db 4 + 1 
2450 .. 00			db "2DUP",0              
2455				endm 
# End of macro CWHEAD
2455			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2455					if DEBUG_FORTH_WORDS_KEY 
2455						DMARK "2DU" 
2455 f5				push af  
2456 3a 6a 24			ld a, (.dmark)  
2459 32 71 ee			ld (debug_mark),a  
245c 3a 6b 24			ld a, (.dmark+1)  
245f 32 72 ee			ld (debug_mark+1),a  
2462 3a 6c 24			ld a, (.dmark+2)  
2465 32 73 ee			ld (debug_mark+2),a  
2468 18 03			jr .pastdmark  
246a ..			.dmark: db "2DU"  
246d f1			.pastdmark: pop af  
246e			endm  
# End of macro DMARK
246e						CALLMONITOR 
246e cd ae 15			call break_point_state  
2471				endm  
# End of macro CALLMONITOR
2471					endif 
2471					FORTH_DSP_VALUEHL 
2471 cd 16 1e			call macro_dsp_valuehl 
2474				endm 
# End of macro FORTH_DSP_VALUEHL
2474 e5					push hl      ; 2 
2475			 
2475					FORTH_DSP_POP 
2475 cd ce 1e			call macro_forth_dsp_pop 
2478				endm 
# End of macro FORTH_DSP_POP
2478					 
2478					FORTH_DSP_VALUEHL 
2478 cd 16 1e			call macro_dsp_valuehl 
247b				endm 
# End of macro FORTH_DSP_VALUEHL
247b			;		push hl      ; 1 
247b			 
247b					FORTH_DSP_POP 
247b cd ce 1e			call macro_forth_dsp_pop 
247e				endm 
# End of macro FORTH_DSP_POP
247e			 
247e			;		pop hl       ; 1 
247e d1					pop de       ; 2 
247f			 
247f cd 1f 1c				call forth_push_numhl 
2482 eb					ex de, hl 
2483 cd 1f 1c				call forth_push_numhl 
2486			 
2486					 
2486 eb					ex de, hl 
2487			 
2487 cd 1f 1c				call forth_push_numhl 
248a eb					ex de, hl 
248b cd 1f 1c				call forth_push_numhl 
248e			 
248e			 
248e					NEXTW 
248e c3 c5 1f			jp macro_next 
2491				endm 
# End of macro NEXTW
2491			.DROP2: 
2491				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2491 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2492 c0 24			dw .SWAP2            
2494 06				db 5 + 1 
2495 .. 00			db "2DROP",0              
249b				endm 
# End of macro CWHEAD
249b			; | 2DROP ( w w -- )    Double drop | DONE 
249b					if DEBUG_FORTH_WORDS_KEY 
249b						DMARK "2DR" 
249b f5				push af  
249c 3a b0 24			ld a, (.dmark)  
249f 32 71 ee			ld (debug_mark),a  
24a2 3a b1 24			ld a, (.dmark+1)  
24a5 32 72 ee			ld (debug_mark+1),a  
24a8 3a b2 24			ld a, (.dmark+2)  
24ab 32 73 ee			ld (debug_mark+2),a  
24ae 18 03			jr .pastdmark  
24b0 ..			.dmark: db "2DR"  
24b3 f1			.pastdmark: pop af  
24b4			endm  
# End of macro DMARK
24b4						CALLMONITOR 
24b4 cd ae 15			call break_point_state  
24b7				endm  
# End of macro CALLMONITOR
24b7					endif 
24b7					FORTH_DSP_POP 
24b7 cd ce 1e			call macro_forth_dsp_pop 
24ba				endm 
# End of macro FORTH_DSP_POP
24ba					FORTH_DSP_POP 
24ba cd ce 1e			call macro_forth_dsp_pop 
24bd				endm 
# End of macro FORTH_DSP_POP
24bd					NEXTW 
24bd c3 c5 1f			jp macro_next 
24c0				endm 
# End of macro NEXTW
24c0			.SWAP2: 
24c0				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
24c0 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
24c1 e9 24			dw .AT            
24c3 06				db 5 + 1 
24c4 .. 00			db "2SWAP",0              
24ca				endm 
# End of macro CWHEAD
24ca			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
24ca					if DEBUG_FORTH_WORDS_KEY 
24ca						DMARK "2SW" 
24ca f5				push af  
24cb 3a df 24			ld a, (.dmark)  
24ce 32 71 ee			ld (debug_mark),a  
24d1 3a e0 24			ld a, (.dmark+1)  
24d4 32 72 ee			ld (debug_mark+1),a  
24d7 3a e1 24			ld a, (.dmark+2)  
24da 32 73 ee			ld (debug_mark+2),a  
24dd 18 03			jr .pastdmark  
24df ..			.dmark: db "2SW"  
24e2 f1			.pastdmark: pop af  
24e3			endm  
# End of macro DMARK
24e3						CALLMONITOR 
24e3 cd ae 15			call break_point_state  
24e6				endm  
# End of macro CALLMONITOR
24e6					endif 
24e6					NEXTW 
24e6 c3 c5 1f			jp macro_next 
24e9				endm 
# End of macro NEXTW
24e9			.AT: 
24e9				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
24e9 1f				db WORD_SYS_CORE+OPCODE_AT             
24ea 1b 25			dw .CAT            
24ec 02				db 1 + 1 
24ed .. 00			db "@",0              
24ef				endm 
# End of macro CWHEAD
24ef			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
24ef			 
24ef					if DEBUG_FORTH_WORDS_KEY 
24ef						DMARK "AT." 
24ef f5				push af  
24f0 3a 04 25			ld a, (.dmark)  
24f3 32 71 ee			ld (debug_mark),a  
24f6 3a 05 25			ld a, (.dmark+1)  
24f9 32 72 ee			ld (debug_mark+1),a  
24fc 3a 06 25			ld a, (.dmark+2)  
24ff 32 73 ee			ld (debug_mark+2),a  
2502 18 03			jr .pastdmark  
2504 ..			.dmark: db "AT."  
2507 f1			.pastdmark: pop af  
2508			endm  
# End of macro DMARK
2508						CALLMONITOR 
2508 cd ae 15			call break_point_state  
250b				endm  
# End of macro CALLMONITOR
250b					endif 
250b			.getbyteat:	 
250b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
250b cd 16 1e			call macro_dsp_valuehl 
250e				endm 
# End of macro FORTH_DSP_VALUEHL
250e					 
250e			;		push hl 
250e				 
250e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
250e cd ce 1e			call macro_forth_dsp_pop 
2511				endm 
# End of macro FORTH_DSP_POP
2511			 
2511			;		pop hl 
2511			 
2511 7e					ld a, (hl) 
2512			 
2512 6f					ld l, a 
2513 26 00				ld h, 0 
2515 cd 1f 1c				call forth_push_numhl 
2518			 
2518					NEXTW 
2518 c3 c5 1f			jp macro_next 
251b				endm 
# End of macro NEXTW
251b			.CAT: 
251b				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
251b 20				db WORD_SYS_CORE+OPCODE_CAT             
251c 44 25			dw .BANG            
251e 03				db 2 + 1 
251f .. 00			db "C@",0              
2522				endm 
# End of macro CWHEAD
2522			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2522					if DEBUG_FORTH_WORDS_KEY 
2522						DMARK "CAA" 
2522 f5				push af  
2523 3a 37 25			ld a, (.dmark)  
2526 32 71 ee			ld (debug_mark),a  
2529 3a 38 25			ld a, (.dmark+1)  
252c 32 72 ee			ld (debug_mark+1),a  
252f 3a 39 25			ld a, (.dmark+2)  
2532 32 73 ee			ld (debug_mark+2),a  
2535 18 03			jr .pastdmark  
2537 ..			.dmark: db "CAA"  
253a f1			.pastdmark: pop af  
253b			endm  
# End of macro DMARK
253b						CALLMONITOR 
253b cd ae 15			call break_point_state  
253e				endm  
# End of macro CALLMONITOR
253e					endif 
253e c3 0b 25				jp .getbyteat 
2541					NEXTW 
2541 c3 c5 1f			jp macro_next 
2544				endm 
# End of macro NEXTW
2544			.BANG: 
2544				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2544 21				db WORD_SYS_CORE+OPCODE_BANG             
2545 7a 25			dw .CBANG            
2547 02				db 1 + 1 
2548 .. 00			db "!",0              
254a				endm 
# End of macro CWHEAD
254a			; | ! ( x w -- ) Store x at address w      | DONE 
254a					if DEBUG_FORTH_WORDS_KEY 
254a						DMARK "BNG" 
254a f5				push af  
254b 3a 5f 25			ld a, (.dmark)  
254e 32 71 ee			ld (debug_mark),a  
2551 3a 60 25			ld a, (.dmark+1)  
2554 32 72 ee			ld (debug_mark+1),a  
2557 3a 61 25			ld a, (.dmark+2)  
255a 32 73 ee			ld (debug_mark+2),a  
255d 18 03			jr .pastdmark  
255f ..			.dmark: db "BNG"  
2562 f1			.pastdmark: pop af  
2563			endm  
# End of macro DMARK
2563						CALLMONITOR 
2563 cd ae 15			call break_point_state  
2566				endm  
# End of macro CALLMONITOR
2566					endif 
2566			 
2566			.storebyteat:		 
2566					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2566 cd 16 1e			call macro_dsp_valuehl 
2569				endm 
# End of macro FORTH_DSP_VALUEHL
2569					 
2569 e5					push hl 
256a				 
256a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
256a cd ce 1e			call macro_forth_dsp_pop 
256d				endm 
# End of macro FORTH_DSP_POP
256d			 
256d					; get byte to poke 
256d			 
256d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
256d cd 16 1e			call macro_dsp_valuehl 
2570				endm 
# End of macro FORTH_DSP_VALUEHL
2570 e5					push hl 
2571			 
2571			 
2571					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2571 cd ce 1e			call macro_forth_dsp_pop 
2574				endm 
# End of macro FORTH_DSP_POP
2574			 
2574			 
2574 d1					pop de 
2575 e1					pop hl 
2576			 
2576 73					ld (hl),e 
2577			 
2577			 
2577					NEXTW 
2577 c3 c5 1f			jp macro_next 
257a				endm 
# End of macro NEXTW
257a			.CBANG: 
257a				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
257a 22				db WORD_SYS_CORE+OPCODE_CBANG             
257b a3 25			dw .SCALL            
257d 03				db 2 + 1 
257e .. 00			db "C!",0              
2581				endm 
# End of macro CWHEAD
2581			; | C!  ( x w -- ) Store x at address w  | DONE 
2581					if DEBUG_FORTH_WORDS_KEY 
2581						DMARK "CBA" 
2581 f5				push af  
2582 3a 96 25			ld a, (.dmark)  
2585 32 71 ee			ld (debug_mark),a  
2588 3a 97 25			ld a, (.dmark+1)  
258b 32 72 ee			ld (debug_mark+1),a  
258e 3a 98 25			ld a, (.dmark+2)  
2591 32 73 ee			ld (debug_mark+2),a  
2594 18 03			jr .pastdmark  
2596 ..			.dmark: db "CBA"  
2599 f1			.pastdmark: pop af  
259a			endm  
# End of macro DMARK
259a						CALLMONITOR 
259a cd ae 15			call break_point_state  
259d				endm  
# End of macro CALLMONITOR
259d					endif 
259d c3 66 25				jp .storebyteat 
25a0					NEXTW 
25a0 c3 c5 1f			jp macro_next 
25a3				endm 
# End of macro NEXTW
25a3			.SCALL: 
25a3				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
25a3 23				db WORD_SYS_CORE+OPCODE_SCALL             
25a4 d7 25			dw .DEPTH            
25a6 05				db 4 + 1 
25a7 .. 00			db "CALL",0              
25ac				endm 
# End of macro CWHEAD
25ac			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
25ac					if DEBUG_FORTH_WORDS_KEY 
25ac						DMARK "CLL" 
25ac f5				push af  
25ad 3a c1 25			ld a, (.dmark)  
25b0 32 71 ee			ld (debug_mark),a  
25b3 3a c2 25			ld a, (.dmark+1)  
25b6 32 72 ee			ld (debug_mark+1),a  
25b9 3a c3 25			ld a, (.dmark+2)  
25bc 32 73 ee			ld (debug_mark+2),a  
25bf 18 03			jr .pastdmark  
25c1 ..			.dmark: db "CLL"  
25c4 f1			.pastdmark: pop af  
25c5			endm  
# End of macro DMARK
25c5						CALLMONITOR 
25c5 cd ae 15			call break_point_state  
25c8				endm  
# End of macro CALLMONITOR
25c8					endif 
25c8			 
25c8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25c8 cd 16 1e			call macro_dsp_valuehl 
25cb				endm 
# End of macro FORTH_DSP_VALUEHL
25cb			 
25cb			;		push hl 
25cb			 
25cb					; destroy value TOS 
25cb			 
25cb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25cb cd ce 1e			call macro_forth_dsp_pop 
25ce				endm 
# End of macro FORTH_DSP_POP
25ce			 
25ce						 
25ce			;		pop hl 
25ce			 
25ce					; how to do a call with hl???? save SP? 
25ce cd 69 1f				call forth_call_hl 
25d1			 
25d1			 
25d1					; TODO push value back onto stack for another op etc 
25d1			 
25d1 cd 1f 1c				call forth_push_numhl 
25d4					NEXTW 
25d4 c3 c5 1f			jp macro_next 
25d7				endm 
# End of macro NEXTW
25d7			.DEPTH: 
25d7				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
25d7 24				db WORD_SYS_CORE+OPCODE_DEPTH             
25d8 14 26			dw .OVER            
25da 06				db 5 + 1 
25db .. 00			db "DEPTH",0              
25e1				endm 
# End of macro CWHEAD
25e1			; | DEPTH ( -- u ) Push count of stack | DONE 
25e1					; take current TOS and remove from base value div by two to get count 
25e1					if DEBUG_FORTH_WORDS_KEY 
25e1						DMARK "DEP" 
25e1 f5				push af  
25e2 3a f6 25			ld a, (.dmark)  
25e5 32 71 ee			ld (debug_mark),a  
25e8 3a f7 25			ld a, (.dmark+1)  
25eb 32 72 ee			ld (debug_mark+1),a  
25ee 3a f8 25			ld a, (.dmark+2)  
25f1 32 73 ee			ld (debug_mark+2),a  
25f4 18 03			jr .pastdmark  
25f6 ..			.dmark: db "DEP"  
25f9 f1			.pastdmark: pop af  
25fa			endm  
# End of macro DMARK
25fa						CALLMONITOR 
25fa cd ae 15			call break_point_state  
25fd				endm  
# End of macro CALLMONITOR
25fd					endif 
25fd			 
25fd			 
25fd 2a f8 e9			ld hl, (cli_data_sp) 
2600 11 32 e8			ld de, cli_data_stack 
2603 ed 52			sbc hl,de 
2605				 
2605				; div by size of stack item 
2605			 
2605 5d				ld e,l 
2606 0e 03			ld c, 3 
2608 cd 3d 0d			call Div8 
260b			 
260b 6f				ld l,a 
260c 26 00			ld h,0 
260e			 
260e				;srl h 
260e				;rr l 
260e			 
260e cd 1f 1c				call forth_push_numhl 
2611					NEXTW 
2611 c3 c5 1f			jp macro_next 
2614				endm 
# End of macro NEXTW
2614			.OVER: 
2614				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2614 42				db WORD_SYS_CORE+46             
2615 5b 26			dw .PAUSE            
2617 05				db 4 + 1 
2618 .. 00			db "OVER",0              
261d				endm 
# End of macro CWHEAD
261d			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
261d					if DEBUG_FORTH_WORDS_KEY 
261d						DMARK "OVR" 
261d f5				push af  
261e 3a 32 26			ld a, (.dmark)  
2621 32 71 ee			ld (debug_mark),a  
2624 3a 33 26			ld a, (.dmark+1)  
2627 32 72 ee			ld (debug_mark+1),a  
262a 3a 34 26			ld a, (.dmark+2)  
262d 32 73 ee			ld (debug_mark+2),a  
2630 18 03			jr .pastdmark  
2632 ..			.dmark: db "OVR"  
2635 f1			.pastdmark: pop af  
2636			endm  
# End of macro DMARK
2636						CALLMONITOR 
2636 cd ae 15			call break_point_state  
2639				endm  
# End of macro CALLMONITOR
2639					endif 
2639			 
2639					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2639 cd 16 1e			call macro_dsp_valuehl 
263c				endm 
# End of macro FORTH_DSP_VALUEHL
263c e5					push hl    ; n2 
263d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
263d cd ce 1e			call macro_forth_dsp_pop 
2640				endm 
# End of macro FORTH_DSP_POP
2640			 
2640					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2640 cd 16 1e			call macro_dsp_valuehl 
2643				endm 
# End of macro FORTH_DSP_VALUEHL
2643 e5					push hl    ; n1 
2644					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2644 cd ce 1e			call macro_forth_dsp_pop 
2647				endm 
# End of macro FORTH_DSP_POP
2647			 
2647 d1					pop de     ; n1 
2648 e1					pop hl     ; n2 
2649			 
2649 d5					push de 
264a e5					push hl 
264b d5					push de 
264c			 
264c					; push back  
264c			 
264c e1					pop hl 
264d cd 1f 1c				call forth_push_numhl 
2650 e1					pop hl 
2651 cd 1f 1c				call forth_push_numhl 
2654 e1					pop hl 
2655 cd 1f 1c				call forth_push_numhl 
2658					NEXTW 
2658 c3 c5 1f			jp macro_next 
265b				endm 
# End of macro NEXTW
265b			 
265b			.PAUSE: 
265b				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
265b 43				db WORD_SYS_CORE+47             
265c 90 26			dw .PAUSES            
265e 08				db 7 + 1 
265f .. 00			db "PAUSEMS",0              
2667				endm 
# End of macro CWHEAD
2667			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2667					if DEBUG_FORTH_WORDS_KEY 
2667						DMARK "PMS" 
2667 f5				push af  
2668 3a 7c 26			ld a, (.dmark)  
266b 32 71 ee			ld (debug_mark),a  
266e 3a 7d 26			ld a, (.dmark+1)  
2671 32 72 ee			ld (debug_mark+1),a  
2674 3a 7e 26			ld a, (.dmark+2)  
2677 32 73 ee			ld (debug_mark+2),a  
267a 18 03			jr .pastdmark  
267c ..			.dmark: db "PMS"  
267f f1			.pastdmark: pop af  
2680			endm  
# End of macro DMARK
2680						CALLMONITOR 
2680 cd ae 15			call break_point_state  
2683				endm  
# End of macro CALLMONITOR
2683					endif 
2683					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2683 cd 16 1e			call macro_dsp_valuehl 
2686				endm 
# End of macro FORTH_DSP_VALUEHL
2686			;		push hl    ; n2 
2686					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2686 cd ce 1e			call macro_forth_dsp_pop 
2689				endm 
# End of macro FORTH_DSP_POP
2689			;		pop hl 
2689			 
2689 7d					ld a, l 
268a cd d7 0a				call aDelayInMS 
268d				       NEXTW 
268d c3 c5 1f			jp macro_next 
2690				endm 
# End of macro NEXTW
2690			.PAUSES:  
2690				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2690 44				db WORD_SYS_CORE+48             
2691 ff 26			dw .ROT            
2693 06				db 5 + 1 
2694 .. 00			db "PAUSE",0              
269a				endm 
# End of macro CWHEAD
269a			; | PAUSE ( n -- )  Pause for n seconds | DONE 
269a					if DEBUG_FORTH_WORDS_KEY 
269a						DMARK "PAU" 
269a f5				push af  
269b 3a af 26			ld a, (.dmark)  
269e 32 71 ee			ld (debug_mark),a  
26a1 3a b0 26			ld a, (.dmark+1)  
26a4 32 72 ee			ld (debug_mark+1),a  
26a7 3a b1 26			ld a, (.dmark+2)  
26aa 32 73 ee			ld (debug_mark+2),a  
26ad 18 03			jr .pastdmark  
26af ..			.dmark: db "PAU"  
26b2 f1			.pastdmark: pop af  
26b3			endm  
# End of macro DMARK
26b3						CALLMONITOR 
26b3 cd ae 15			call break_point_state  
26b6				endm  
# End of macro CALLMONITOR
26b6					endif 
26b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26b6 cd 16 1e			call macro_dsp_valuehl 
26b9				endm 
# End of macro FORTH_DSP_VALUEHL
26b9			;		push hl    ; n2 
26b9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26b9 cd ce 1e			call macro_forth_dsp_pop 
26bc				endm 
# End of macro FORTH_DSP_POP
26bc			;		pop hl 
26bc 45					ld b, l 
26bd					if DEBUG_FORTH_WORDS 
26bd						DMARK "PAU" 
26bd f5				push af  
26be 3a d2 26			ld a, (.dmark)  
26c1 32 71 ee			ld (debug_mark),a  
26c4 3a d3 26			ld a, (.dmark+1)  
26c7 32 72 ee			ld (debug_mark+1),a  
26ca 3a d4 26			ld a, (.dmark+2)  
26cd 32 73 ee			ld (debug_mark+2),a  
26d0 18 03			jr .pastdmark  
26d2 ..			.dmark: db "PAU"  
26d5 f1			.pastdmark: pop af  
26d6			endm  
# End of macro DMARK
26d6						CALLMONITOR 
26d6 cd ae 15			call break_point_state  
26d9				endm  
# End of macro CALLMONITOR
26d9					endif 
26d9 c5			.pauses1:	push bc 
26da cd f2 0a				call delay1s 
26dd c1					pop bc 
26de					if DEBUG_FORTH_WORDS 
26de						DMARK "PA1" 
26de f5				push af  
26df 3a f3 26			ld a, (.dmark)  
26e2 32 71 ee			ld (debug_mark),a  
26e5 3a f4 26			ld a, (.dmark+1)  
26e8 32 72 ee			ld (debug_mark+1),a  
26eb 3a f5 26			ld a, (.dmark+2)  
26ee 32 73 ee			ld (debug_mark+2),a  
26f1 18 03			jr .pastdmark  
26f3 ..			.dmark: db "PA1"  
26f6 f1			.pastdmark: pop af  
26f7			endm  
# End of macro DMARK
26f7						CALLMONITOR 
26f7 cd ae 15			call break_point_state  
26fa				endm  
# End of macro CALLMONITOR
26fa					endif 
26fa 10 dd				djnz .pauses1 
26fc			 
26fc				       NEXTW 
26fc c3 c5 1f			jp macro_next 
26ff				endm 
# End of macro NEXTW
26ff			.ROT: 
26ff				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
26ff 45				db WORD_SYS_CORE+49             
2700 4d 27			dw .UWORDS            
2702 04				db 3 + 1 
2703 .. 00			db "ROT",0              
2707				endm 
# End of macro CWHEAD
2707			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2707					if DEBUG_FORTH_WORDS_KEY 
2707						DMARK "ROT" 
2707 f5				push af  
2708 3a 1c 27			ld a, (.dmark)  
270b 32 71 ee			ld (debug_mark),a  
270e 3a 1d 27			ld a, (.dmark+1)  
2711 32 72 ee			ld (debug_mark+1),a  
2714 3a 1e 27			ld a, (.dmark+2)  
2717 32 73 ee			ld (debug_mark+2),a  
271a 18 03			jr .pastdmark  
271c ..			.dmark: db "ROT"  
271f f1			.pastdmark: pop af  
2720			endm  
# End of macro DMARK
2720						CALLMONITOR 
2720 cd ae 15			call break_point_state  
2723				endm  
# End of macro CALLMONITOR
2723					endif 
2723			 
2723					FORTH_DSP_VALUEHL 
2723 cd 16 1e			call macro_dsp_valuehl 
2726				endm 
# End of macro FORTH_DSP_VALUEHL
2726 e5					push hl    ; u3  
2727			 
2727					FORTH_DSP_POP 
2727 cd ce 1e			call macro_forth_dsp_pop 
272a				endm 
# End of macro FORTH_DSP_POP
272a			   
272a					FORTH_DSP_VALUEHL 
272a cd 16 1e			call macro_dsp_valuehl 
272d				endm 
# End of macro FORTH_DSP_VALUEHL
272d e5					push hl     ; u2 
272e			 
272e					FORTH_DSP_POP 
272e cd ce 1e			call macro_forth_dsp_pop 
2731				endm 
# End of macro FORTH_DSP_POP
2731			 
2731					FORTH_DSP_VALUEHL 
2731 cd 16 1e			call macro_dsp_valuehl 
2734				endm 
# End of macro FORTH_DSP_VALUEHL
2734 e5					push hl     ; u1 
2735			 
2735					FORTH_DSP_POP 
2735 cd ce 1e			call macro_forth_dsp_pop 
2738				endm 
# End of macro FORTH_DSP_POP
2738			 
2738 c1					pop bc      ; u1 
2739 e1					pop hl      ; u2 
273a d1					pop de      ; u3 
273b			 
273b			 
273b c5					push bc 
273c d5					push de 
273d e5					push hl 
273e			 
273e			 
273e e1					pop hl 
273f cd 1f 1c				call forth_push_numhl 
2742			 
2742 e1					pop hl 
2743 cd 1f 1c				call forth_push_numhl 
2746			 
2746 e1					pop hl 
2747 cd 1f 1c				call forth_push_numhl 
274a					 
274a			 
274a			 
274a			 
274a			 
274a			 
274a				       NEXTW 
274a c3 c5 1f			jp macro_next 
274d				endm 
# End of macro NEXTW
274d			 
274d			.UWORDS: 
274d				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
274d 50				db WORD_SYS_CORE+60             
274e 0f 28			dw .BP            
2750 07				db 6 + 1 
2751 .. 00			db "UWORDS",0              
2758				endm 
# End of macro CWHEAD
2758			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2758			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2758			; | | Following the count are the individual words. 
2758			; | | 
2758			; | | e.g. UWORDS 
2758			; | | BOX DIRLIST 2 
2758			; | |  
2758			; | | Can be used to save the words to storage via: 
2758			; | | UWORDS $01 DO $01 APPEND LOOP 
2758				if DEBUG_FORTH_WORDS_KEY 
2758					DMARK "UWR" 
2758 f5				push af  
2759 3a 6d 27			ld a, (.dmark)  
275c 32 71 ee			ld (debug_mark),a  
275f 3a 6e 27			ld a, (.dmark+1)  
2762 32 72 ee			ld (debug_mark+1),a  
2765 3a 6f 27			ld a, (.dmark+2)  
2768 32 73 ee			ld (debug_mark+2),a  
276b 18 03			jr .pastdmark  
276d ..			.dmark: db "UWR"  
2770 f1			.pastdmark: pop af  
2771			endm  
# End of macro DMARK
2771					CALLMONITOR 
2771 cd ae 15			call break_point_state  
2774				endm  
# End of macro CALLMONITOR
2774				endif 
2774 21 be 61				ld hl, baseram 
2777					;ld hl, baseusermem 
2777 01 00 00				ld bc, 0    ; start a counter 
277a			 
277a				; skip dict stub 
277a			 
277a cd 16 21				call forth_tok_next 
277d			 
277d			 
277d			; while we have words to look for 
277d			 
277d 7e			.douscan:	ld a, (hl)      
277e				if DEBUG_FORTH_WORDS 
277e					DMARK "UWs" 
277e f5				push af  
277f 3a 93 27			ld a, (.dmark)  
2782 32 71 ee			ld (debug_mark),a  
2785 3a 94 27			ld a, (.dmark+1)  
2788 32 72 ee			ld (debug_mark+1),a  
278b 3a 95 27			ld a, (.dmark+2)  
278e 32 73 ee			ld (debug_mark+2),a  
2791 18 03			jr .pastdmark  
2793 ..			.dmark: db "UWs"  
2796 f1			.pastdmark: pop af  
2797			endm  
# End of macro DMARK
2797					CALLMONITOR 
2797 cd ae 15			call break_point_state  
279a				endm  
# End of macro CALLMONITOR
279a				endif 
279a fe 00				cp WORD_SYS_END 
279c 28 4d				jr z, .udone 
279e fe 01				cp WORD_SYS_UWORD 
27a0 20 44				jr nz, .nuword 
27a2			 
27a2				if DEBUG_FORTH_WORDS 
27a2					DMARK "UWu" 
27a2 f5				push af  
27a3 3a b7 27			ld a, (.dmark)  
27a6 32 71 ee			ld (debug_mark),a  
27a9 3a b8 27			ld a, (.dmark+1)  
27ac 32 72 ee			ld (debug_mark+1),a  
27af 3a b9 27			ld a, (.dmark+2)  
27b2 32 73 ee			ld (debug_mark+2),a  
27b5 18 03			jr .pastdmark  
27b7 ..			.dmark: db "UWu"  
27ba f1			.pastdmark: pop af  
27bb			endm  
# End of macro DMARK
27bb					CALLMONITOR 
27bb cd ae 15			call break_point_state  
27be				endm  
# End of macro CALLMONITOR
27be				endif 
27be					; we have a uword so push its name to the stack 
27be			 
27be e5				   	push hl  ; save so we can move to next dict block 
27bf			 
27bf					; skip opcode 
27bf 23					inc hl  
27c0					; skip next ptr 
27c0 23					inc hl  
27c1 23					inc hl 
27c2					; skip len 
27c2 23					inc hl 
27c3				if DEBUG_FORTH_WORDS 
27c3					DMARK "UWt" 
27c3 f5				push af  
27c4 3a d8 27			ld a, (.dmark)  
27c7 32 71 ee			ld (debug_mark),a  
27ca 3a d9 27			ld a, (.dmark+1)  
27cd 32 72 ee			ld (debug_mark+1),a  
27d0 3a da 27			ld a, (.dmark+2)  
27d3 32 73 ee			ld (debug_mark+2),a  
27d6 18 03			jr .pastdmark  
27d8 ..			.dmark: db "UWt"  
27db f1			.pastdmark: pop af  
27dc			endm  
# End of macro DMARK
27dc					CALLMONITOR 
27dc cd ae 15			call break_point_state  
27df				endm  
# End of macro CALLMONITOR
27df				endif 
27df 03					inc bc 
27e0			 
27e0 c5					push bc 
27e1 cd 8d 1c				call forth_push_str 
27e4 c1					pop bc 
27e5			 
27e5 e1					pop hl 	 
27e6			 
27e6 cd 16 21		.nuword:	call forth_tok_next 
27e9 18 92				jr .douscan  
27eb			 
27eb			.udone:		 ; push count of uwords found 
27eb c5					push bc 
27ec e1					pop hl 
27ed			 
27ed				if DEBUG_FORTH_WORDS 
27ed					DMARK "UWc" 
27ed f5				push af  
27ee 3a 02 28			ld a, (.dmark)  
27f1 32 71 ee			ld (debug_mark),a  
27f4 3a 03 28			ld a, (.dmark+1)  
27f7 32 72 ee			ld (debug_mark+1),a  
27fa 3a 04 28			ld a, (.dmark+2)  
27fd 32 73 ee			ld (debug_mark+2),a  
2800 18 03			jr .pastdmark  
2802 ..			.dmark: db "UWc"  
2805 f1			.pastdmark: pop af  
2806			endm  
# End of macro DMARK
2806					CALLMONITOR 
2806 cd ae 15			call break_point_state  
2809				endm  
# End of macro CALLMONITOR
2809				endif 
2809 cd 1f 1c				call forth_push_numhl 
280c			 
280c			 
280c				       NEXTW 
280c c3 c5 1f			jp macro_next 
280f				endm 
# End of macro NEXTW
280f			 
280f			.BP: 
280f				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
280f 54				db WORD_SYS_CORE+64             
2810 45 28			dw .MONITOR            
2812 03				db 2 + 1 
2813 .. 00			db "BP",0              
2816				endm 
# End of macro CWHEAD
2816			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2816			; | | $00 Will enable the break points within specific code paths 
2816			; | | $01 Will disable break points 
2816			; | |  
2816			; | | By default break points are off. Either the above can be used to enable them 
2816			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2816			; | | and on release of the pressed key a message will be disaplayed to notify 
2816			; | | that break points are enabled. Pressing any key will then continue boot process. 
2816					; get byte count 
2816					if DEBUG_FORTH_WORDS_KEY 
2816						DMARK "BP." 
2816 f5				push af  
2817 3a 2b 28			ld a, (.dmark)  
281a 32 71 ee			ld (debug_mark),a  
281d 3a 2c 28			ld a, (.dmark+1)  
2820 32 72 ee			ld (debug_mark+1),a  
2823 3a 2d 28			ld a, (.dmark+2)  
2826 32 73 ee			ld (debug_mark+2),a  
2829 18 03			jr .pastdmark  
282b ..			.dmark: db "BP."  
282e f1			.pastdmark: pop af  
282f			endm  
# End of macro DMARK
282f						CALLMONITOR 
282f cd ae 15			call break_point_state  
2832				endm  
# End of macro CALLMONITOR
2832					endif 
2832			 
2832					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2832 cd 16 1e			call macro_dsp_valuehl 
2835				endm 
# End of macro FORTH_DSP_VALUEHL
2835			 
2835			;		push hl 
2835			 
2835					; destroy value TOS 
2835			 
2835					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2835 cd ce 1e			call macro_forth_dsp_pop 
2838				endm 
# End of macro FORTH_DSP_POP
2838			 
2838			;		pop hl 
2838			 
2838 3e 00				ld a,0 
283a bd					cp l 
283b 28 02				jr z, .bpset 
283d 3e 2a				ld a, '*' 
283f			 
283f 32 bc e2		.bpset:		ld (os_view_disable), a 
2842			 
2842			 
2842					NEXTW 
2842 c3 c5 1f			jp macro_next 
2845				endm 
# End of macro NEXTW
2845			 
2845			 
2845			.MONITOR: 
2845				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2845 55				db WORD_SYS_CORE+65             
2846 78 28			dw .MALLOC            
2848 08				db 7 + 1 
2849 .. 00			db "MONITOR",0              
2851				endm 
# End of macro CWHEAD
2851			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2851			; | | At start the current various registers will be displayed with contents. 
2851			; | | Top right corner will show the most recent debug marker seen. 
2851			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2851			; | | and the return stack pointer (RSP). 
2851			; | | Pressing: 
2851			; | |    1 - Initial screen 
2851			; | |    2 - Display a data dump of HL 
2851			; | |    3 - Display a data dump of DE 
2851			; | |    4 - Display a data dump of BC 
2851			; | |    5 - Display a data dump of HL 
2851			; | |    6 - Display a data dump of DSP 
2851			; | |    7 - Display a data dump of RSP 
2851			; | |    8 - Display a data dump of what is at DSP 
2851			; | |    9 - Display a data dump of what is at RSP 
2851			; | |    0 - Exit monitor and continue running. This will also enable break points 
2851			; | |    * - Disable break points 
2851			; | |    # - Enter traditional monitor mode 
2851			; | | 
2851			; | | Monitor Mode 
2851			; | | ------------ 
2851			; | | A prompt of '>' will be shown for various commands: 
2851			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2851			; | |    C - Continue display a data dump from the last set address 
2851			; | |    M xxxx - Set start of memory edit at address xx 
2851			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2851			; | |    Q - Return to previous 
2851					if DEBUG_FORTH_WORDS_KEY 
2851						DMARK "MON" 
2851 f5				push af  
2852 3a 66 28			ld a, (.dmark)  
2855 32 71 ee			ld (debug_mark),a  
2858 3a 67 28			ld a, (.dmark+1)  
285b 32 72 ee			ld (debug_mark+1),a  
285e 3a 68 28			ld a, (.dmark+2)  
2861 32 73 ee			ld (debug_mark+2),a  
2864 18 03			jr .pastdmark  
2866 ..			.dmark: db "MON"  
2869 f1			.pastdmark: pop af  
286a			endm  
# End of macro DMARK
286a						CALLMONITOR 
286a cd ae 15			call break_point_state  
286d				endm  
# End of macro CALLMONITOR
286d					endif 
286d 3e 00				ld a, 0 
286f 32 bc e2				ld (os_view_disable), a 
2872			 
2872					CALLMONITOR 
2872 cd ae 15			call break_point_state  
2875				endm  
# End of macro CALLMONITOR
2875			 
2875			;	call monitor 
2875			 
2875					NEXTW 
2875 c3 c5 1f			jp macro_next 
2878				endm 
# End of macro NEXTW
2878			 
2878			 
2878			.MALLOC: 
2878				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2878 56				db WORD_SYS_CORE+66             
2879 a1 28			dw .MALLOC2            
287b 06				db 5 + 1 
287c .. 00			db "ALLOT",0              
2882				endm 
# End of macro CWHEAD
2882			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2882					if DEBUG_FORTH_WORDS_KEY 
2882						DMARK "ALL" 
2882 f5				push af  
2883 3a 97 28			ld a, (.dmark)  
2886 32 71 ee			ld (debug_mark),a  
2889 3a 98 28			ld a, (.dmark+1)  
288c 32 72 ee			ld (debug_mark+1),a  
288f 3a 99 28			ld a, (.dmark+2)  
2892 32 73 ee			ld (debug_mark+2),a  
2895 18 03			jr .pastdmark  
2897 ..			.dmark: db "ALL"  
289a f1			.pastdmark: pop af  
289b			endm  
# End of macro DMARK
289b						CALLMONITOR 
289b cd ae 15			call break_point_state  
289e				endm  
# End of macro CALLMONITOR
289e					endif 
289e c3 c8 28				jp .mallocc 
28a1			.MALLOC2: 
28a1				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
28a1 56				db WORD_SYS_CORE+66             
28a2 df 28			dw .FREE            
28a4 07				db 6 + 1 
28a5 .. 00			db "MALLOC",0              
28ac				endm 
# End of macro CWHEAD
28ac			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28ac					; get byte count 
28ac					if DEBUG_FORTH_WORDS_KEY 
28ac						DMARK "MAL" 
28ac f5				push af  
28ad 3a c1 28			ld a, (.dmark)  
28b0 32 71 ee			ld (debug_mark),a  
28b3 3a c2 28			ld a, (.dmark+1)  
28b6 32 72 ee			ld (debug_mark+1),a  
28b9 3a c3 28			ld a, (.dmark+2)  
28bc 32 73 ee			ld (debug_mark+2),a  
28bf 18 03			jr .pastdmark  
28c1 ..			.dmark: db "MAL"  
28c4 f1			.pastdmark: pop af  
28c5			endm  
# End of macro DMARK
28c5						CALLMONITOR 
28c5 cd ae 15			call break_point_state  
28c8				endm  
# End of macro CALLMONITOR
28c8					endif 
28c8			.mallocc: 
28c8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28c8 cd 16 1e			call macro_dsp_valuehl 
28cb				endm 
# End of macro FORTH_DSP_VALUEHL
28cb			 
28cb			;		push hl 
28cb			 
28cb					; destroy value TOS 
28cb			 
28cb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28cb cd ce 1e			call macro_forth_dsp_pop 
28ce				endm 
# End of macro FORTH_DSP_POP
28ce			 
28ce			;		pop hl 
28ce cd 74 12				call malloc 
28d1				if DEBUG_FORTH_MALLOC_GUARD 
28d1 f5					push af 
28d2 cd d6 0d				call ishlzero 
28d5			;		ld a, l 
28d5			;		add h 
28d5			;		cp 0 
28d5 f1					pop af 
28d6					 
28d6 cc a9 4a				call z,malloc_error 
28d9				endif 
28d9			 
28d9 cd 1f 1c				call forth_push_numhl 
28dc					NEXTW 
28dc c3 c5 1f			jp macro_next 
28df				endm 
# End of macro NEXTW
28df			 
28df			.FREE: 
28df				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
28df 57				db WORD_SYS_CORE+67             
28e0 10 29			dw .LIST            
28e2 05				db 4 + 1 
28e3 .. 00			db "FREE",0              
28e8				endm 
# End of macro CWHEAD
28e8			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
28e8					if DEBUG_FORTH_WORDS_KEY 
28e8						DMARK "FRE" 
28e8 f5				push af  
28e9 3a fd 28			ld a, (.dmark)  
28ec 32 71 ee			ld (debug_mark),a  
28ef 3a fe 28			ld a, (.dmark+1)  
28f2 32 72 ee			ld (debug_mark+1),a  
28f5 3a ff 28			ld a, (.dmark+2)  
28f8 32 73 ee			ld (debug_mark+2),a  
28fb 18 03			jr .pastdmark  
28fd ..			.dmark: db "FRE"  
2900 f1			.pastdmark: pop af  
2901			endm  
# End of macro DMARK
2901						CALLMONITOR 
2901 cd ae 15			call break_point_state  
2904				endm  
# End of macro CALLMONITOR
2904					endif 
2904					; get address 
2904			 
2904					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2904 cd 16 1e			call macro_dsp_valuehl 
2907				endm 
# End of macro FORTH_DSP_VALUEHL
2907			 
2907			;		push hl 
2907			 
2907					; destroy value TOS 
2907			 
2907					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2907 cd ce 1e			call macro_forth_dsp_pop 
290a				endm 
# End of macro FORTH_DSP_POP
290a			 
290a			;		pop hl 
290a			if FORTH_ENABLE_MALLOCFREE 
290a cd 3e 13				call free 
290d			endif 
290d					NEXTW 
290d c3 c5 1f			jp macro_next 
2910				endm 
# End of macro NEXTW
2910			.LIST: 
2910				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2910 5c				db WORD_SYS_CORE+72             
2911 fe 2a			dw .FORGET            
2913 05				db 4 + 1 
2914 .. 00			db "LIST",0              
2919				endm 
# End of macro CWHEAD
2919			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2919			; | | The quoted word must be in upper case. 
2919				if DEBUG_FORTH_WORDS_KEY 
2919					DMARK "LST" 
2919 f5				push af  
291a 3a 2e 29			ld a, (.dmark)  
291d 32 71 ee			ld (debug_mark),a  
2920 3a 2f 29			ld a, (.dmark+1)  
2923 32 72 ee			ld (debug_mark+1),a  
2926 3a 30 29			ld a, (.dmark+2)  
2929 32 73 ee			ld (debug_mark+2),a  
292c 18 03			jr .pastdmark  
292e ..			.dmark: db "LST"  
2931 f1			.pastdmark: pop af  
2932			endm  
# End of macro DMARK
2932					CALLMONITOR 
2932 cd ae 15			call break_point_state  
2935				endm  
# End of macro CALLMONITOR
2935				endif 
2935			 
2935					FORTH_DSP_VALUEHL 
2935 cd 16 1e			call macro_dsp_valuehl 
2938				endm 
# End of macro FORTH_DSP_VALUEHL
2938			 
2938 e5					push hl 
2939					FORTH_DSP_POP 
2939 cd ce 1e			call macro_forth_dsp_pop 
293c				endm 
# End of macro FORTH_DSP_POP
293c c1					pop bc 
293d			 
293d			; Start format of scratch string 
293d			 
293d 21 cb e2				ld hl, scratch 
2940			 
2940 3e 3a				ld a, ':' 
2942 77					ld (hl),a 
2943 23					inc hl 
2944 3e 20				ld a, ' ' 
2946 77					ld (hl), a 
2947			 
2947					; Get ptr to the word we need to look up 
2947			 
2947			;		FORTH_DSP_VALUEHL 
2947					;v5 FORTH_DSP_VALUE 
2947				; TODO type check 
2947			;		inc hl    ; Skip type check  
2947			;		push hl 
2947			;		ex de, hl    ; put into DE 
2947			 
2947			 
2947 21 be 61				ld hl, baseram 
294a					;ld hl, baseusermem 
294a			 
294a e5			push hl   ; sacreifical push 
294b			 
294b			.ldouscanm: 
294b e1				pop hl 
294c			.ldouscan: 
294c				if DEBUG_FORTH_WORDS 
294c					DMARK "LSs" 
294c f5				push af  
294d 3a 61 29			ld a, (.dmark)  
2950 32 71 ee			ld (debug_mark),a  
2953 3a 62 29			ld a, (.dmark+1)  
2956 32 72 ee			ld (debug_mark+1),a  
2959 3a 63 29			ld a, (.dmark+2)  
295c 32 73 ee			ld (debug_mark+2),a  
295f 18 03			jr .pastdmark  
2961 ..			.dmark: db "LSs"  
2964 f1			.pastdmark: pop af  
2965			endm  
# End of macro DMARK
2965					CALLMONITOR 
2965 cd ae 15			call break_point_state  
2968				endm  
# End of macro CALLMONITOR
2968				endif 
2968				; skip dict stub 
2968 cd 16 21				call forth_tok_next 
296b			 
296b			 
296b			; while we have words to look for 
296b			 
296b 7e				ld a, (hl)      
296c				if DEBUG_FORTH_WORDS 
296c					DMARK "LSk" 
296c f5				push af  
296d 3a 81 29			ld a, (.dmark)  
2970 32 71 ee			ld (debug_mark),a  
2973 3a 82 29			ld a, (.dmark+1)  
2976 32 72 ee			ld (debug_mark+1),a  
2979 3a 83 29			ld a, (.dmark+2)  
297c 32 73 ee			ld (debug_mark+2),a  
297f 18 03			jr .pastdmark  
2981 ..			.dmark: db "LSk"  
2984 f1			.pastdmark: pop af  
2985			endm  
# End of macro DMARK
2985					CALLMONITOR 
2985 cd ae 15			call break_point_state  
2988				endm  
# End of macro CALLMONITOR
2988				endif 
2988					;cp WORD_SYS_END 
2988					;jp z, .lunotfound 
2988			 
2988					; if we hit non uwords then gone too far 
2988 fe 01				cp WORD_SYS_UWORD 
298a c2 ba 2a				jp nz, .lunotfound 
298d			 
298d				if DEBUG_FORTH_WORDS 
298d					DMARK "LSu" 
298d f5				push af  
298e 3a a2 29			ld a, (.dmark)  
2991 32 71 ee			ld (debug_mark),a  
2994 3a a3 29			ld a, (.dmark+1)  
2997 32 72 ee			ld (debug_mark+1),a  
299a 3a a4 29			ld a, (.dmark+2)  
299d 32 73 ee			ld (debug_mark+2),a  
29a0 18 03			jr .pastdmark  
29a2 ..			.dmark: db "LSu"  
29a5 f1			.pastdmark: pop af  
29a6			endm  
# End of macro DMARK
29a6					CALLMONITOR 
29a6 cd ae 15			call break_point_state  
29a9				endm  
# End of macro CALLMONITOR
29a9				endif 
29a9			 
29a9					; found a uword but is it the one we want... 
29a9			 
29a9 c5					push bc     ; uword to find is on bc 
29aa d1					pop de 
29ab			 
29ab e5					push hl  ; to save the ptr 
29ac			 
29ac					; skip opcode 
29ac 23					inc hl  
29ad					; skip next ptr 
29ad 23					inc hl  
29ae 23					inc hl 
29af					; skip len 
29af 23					inc hl 
29b0			 
29b0				if DEBUG_FORTH_WORDS 
29b0					DMARK "LSc" 
29b0 f5				push af  
29b1 3a c5 29			ld a, (.dmark)  
29b4 32 71 ee			ld (debug_mark),a  
29b7 3a c6 29			ld a, (.dmark+1)  
29ba 32 72 ee			ld (debug_mark+1),a  
29bd 3a c7 29			ld a, (.dmark+2)  
29c0 32 73 ee			ld (debug_mark+2),a  
29c3 18 03			jr .pastdmark  
29c5 ..			.dmark: db "LSc"  
29c8 f1			.pastdmark: pop af  
29c9			endm  
# End of macro DMARK
29c9					CALLMONITOR 
29c9 cd ae 15			call break_point_state  
29cc				endm  
# End of macro CALLMONITOR
29cc				endif 
29cc cd 43 12				call strcmp 
29cf c2 4b 29				jp nz, .ldouscanm 
29d2				 
29d2			 
29d2			 
29d2					; we have a uword so push its name to the stack 
29d2			 
29d2			;	   	push hl  ; save so we can move to next dict block 
29d2 e1			pop hl 
29d3			 
29d3				if DEBUG_FORTH_WORDS 
29d3					DMARK "LSm" 
29d3 f5				push af  
29d4 3a e8 29			ld a, (.dmark)  
29d7 32 71 ee			ld (debug_mark),a  
29da 3a e9 29			ld a, (.dmark+1)  
29dd 32 72 ee			ld (debug_mark+1),a  
29e0 3a ea 29			ld a, (.dmark+2)  
29e3 32 73 ee			ld (debug_mark+2),a  
29e6 18 03			jr .pastdmark  
29e8 ..			.dmark: db "LSm"  
29eb f1			.pastdmark: pop af  
29ec			endm  
# End of macro DMARK
29ec					CALLMONITOR 
29ec cd ae 15			call break_point_state  
29ef				endm  
# End of macro CALLMONITOR
29ef				endif 
29ef			 
29ef					; skip opcode 
29ef 23					inc hl  
29f0					; skip next ptr 
29f0 23					inc hl  
29f1 23					inc hl 
29f2					; skip len 
29f2 7e					ld a, (hl)   ; save length to add 
29f3				if DEBUG_FORTH_WORDS 
29f3					DMARK "LS2" 
29f3 f5				push af  
29f4 3a 08 2a			ld a, (.dmark)  
29f7 32 71 ee			ld (debug_mark),a  
29fa 3a 09 2a			ld a, (.dmark+1)  
29fd 32 72 ee			ld (debug_mark+1),a  
2a00 3a 0a 2a			ld a, (.dmark+2)  
2a03 32 73 ee			ld (debug_mark+2),a  
2a06 18 03			jr .pastdmark  
2a08 ..			.dmark: db "LS2"  
2a0b f1			.pastdmark: pop af  
2a0c			endm  
# End of macro DMARK
2a0c					CALLMONITOR 
2a0c cd ae 15			call break_point_state  
2a0f				endm  
# End of macro CALLMONITOR
2a0f				endif 
2a0f			 
2a0f					; save this location 
2a0f				 
2a0f e5					push hl 
2a10			 
2a10 23					inc hl 
2a11 11 cd e2				ld de, scratch+2 
2a14 4f					ld c, a 
2a15 06 00				ld b, 0 
2a17			 
2a17				if DEBUG_FORTH_WORDS 
2a17					DMARK "LSn" 
2a17 f5				push af  
2a18 3a 2c 2a			ld a, (.dmark)  
2a1b 32 71 ee			ld (debug_mark),a  
2a1e 3a 2d 2a			ld a, (.dmark+1)  
2a21 32 72 ee			ld (debug_mark+1),a  
2a24 3a 2e 2a			ld a, (.dmark+2)  
2a27 32 73 ee			ld (debug_mark+2),a  
2a2a 18 03			jr .pastdmark  
2a2c ..			.dmark: db "LSn"  
2a2f f1			.pastdmark: pop af  
2a30			endm  
# End of macro DMARK
2a30					CALLMONITOR 
2a30 cd ae 15			call break_point_state  
2a33				endm  
# End of macro CALLMONITOR
2a33				endif 
2a33			 
2a33					; copy uword name to scratch 
2a33			 
2a33 ed b0				ldir 
2a35			 
2a35 1b					dec de 
2a36 3e 20				ld a, ' '    ; change null to space 
2a38 12					ld (de), a 
2a39			 
2a39 13					inc de 
2a3a			 
2a3a d5					push de 
2a3b c1					pop bc     ; move scratch pointer to end of word name and save it 
2a3c			 
2a3c e1					pop hl 
2a3d 7e					ld a, (hl) 
2a3e					;inc hl 
2a3e					; skip word string 
2a3e cd ad 0d				call addatohl 
2a41			 
2a41 23					inc hl 
2a42			 
2a42				if DEBUG_FORTH_WORDS 
2a42					DMARK "LS3" 
2a42 f5				push af  
2a43 3a 57 2a			ld a, (.dmark)  
2a46 32 71 ee			ld (debug_mark),a  
2a49 3a 58 2a			ld a, (.dmark+1)  
2a4c 32 72 ee			ld (debug_mark+1),a  
2a4f 3a 59 2a			ld a, (.dmark+2)  
2a52 32 73 ee			ld (debug_mark+2),a  
2a55 18 03			jr .pastdmark  
2a57 ..			.dmark: db "LS3"  
2a5a f1			.pastdmark: pop af  
2a5b			endm  
# End of macro DMARK
2a5b					CALLMONITOR 
2a5b cd ae 15			call break_point_state  
2a5e				endm  
# End of macro CALLMONITOR
2a5e				endif 
2a5e					; should now be at the start of the machine code to setup the eval of the uword 
2a5e					; now locate the ptr to the string defintion 
2a5e			 
2a5e					; skip ld hl, 
2a5e					; then load the ptr 
2a5e			; TODO use get from hl ptr 
2a5e 23					inc hl 
2a5f 5e					ld e, (hl) 
2a60 23					inc hl 
2a61 56					ld d, (hl) 
2a62 eb					ex de, hl 
2a63			 
2a63			 
2a63				if DEBUG_FORTH_WORDS 
2a63					DMARK "LSt" 
2a63 f5				push af  
2a64 3a 78 2a			ld a, (.dmark)  
2a67 32 71 ee			ld (debug_mark),a  
2a6a 3a 79 2a			ld a, (.dmark+1)  
2a6d 32 72 ee			ld (debug_mark+1),a  
2a70 3a 7a 2a			ld a, (.dmark+2)  
2a73 32 73 ee			ld (debug_mark+2),a  
2a76 18 03			jr .pastdmark  
2a78 ..			.dmark: db "LSt"  
2a7b f1			.pastdmark: pop af  
2a7c			endm  
# End of macro DMARK
2a7c					CALLMONITOR 
2a7c cd ae 15			call break_point_state  
2a7f				endm  
# End of macro CALLMONITOR
2a7f				endif 
2a7f			 
2a7f			; cant push right now due to tokenised strings  
2a7f			 
2a7f			; get the destination of where to copy this definition to. 
2a7f			 
2a7f c5					push bc 
2a80 d1					pop de 
2a81			 
2a81 7e			.listl:         ld a,(hl) 
2a82 fe 00				cp 0 
2a84 28 09				jr z, .lreplsp     ; replace zero with space 
2a86					;cp FORTH_END_BUFFER 
2a86 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2a88 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2a8a				 
2a8a					; just copy this char as is then 
2a8a			 
2a8a 12					ld (de), a 
2a8b			 
2a8b 23			.listnxt:	inc hl 
2a8c 13					inc de 
2a8d 18 f2				jr .listl 
2a8f			 
2a8f 3e 20		.lreplsp:	ld a,' ' 
2a91 12					ld (de), a 
2a92 18 f7				jr .listnxt 
2a94			 
2a94			; close up uword def 
2a94			 
2a94			.listdone: 
2a94 12					ld (de), a 
2a95 13					inc de 
2a96 3e 00				ld a, 0 
2a98 12					ld (de), a 
2a99			 
2a99			; now have def so clean up and push to stack 
2a99			 
2a99 21 cb e2				ld hl, scratch 
2a9c				if DEBUG_FORTH_WORDS 
2a9c					DMARK "Ltp" 
2a9c f5				push af  
2a9d 3a b1 2a			ld a, (.dmark)  
2aa0 32 71 ee			ld (debug_mark),a  
2aa3 3a b2 2a			ld a, (.dmark+1)  
2aa6 32 72 ee			ld (debug_mark+1),a  
2aa9 3a b3 2a			ld a, (.dmark+2)  
2aac 32 73 ee			ld (debug_mark+2),a  
2aaf 18 03			jr .pastdmark  
2ab1 ..			.dmark: db "Ltp"  
2ab4 f1			.pastdmark: pop af  
2ab5			endm  
# End of macro DMARK
2ab5					CALLMONITOR 
2ab5 cd ae 15			call break_point_state  
2ab8				endm  
# End of macro CALLMONITOR
2ab8				endif 
2ab8			 
2ab8 18 1f			jr .listpush 
2aba			 
2aba			;.lnuword:	pop hl 
2aba			;		call forth_tok_next 
2aba			;		jp .ldouscan  
2aba			 
2aba			.lunotfound:		  
2aba			 
2aba				if DEBUG_FORTH_WORDS 
2aba					DMARK "LSn" 
2aba f5				push af  
2abb 3a cf 2a			ld a, (.dmark)  
2abe 32 71 ee			ld (debug_mark),a  
2ac1 3a d0 2a			ld a, (.dmark+1)  
2ac4 32 72 ee			ld (debug_mark+1),a  
2ac7 3a d1 2a			ld a, (.dmark+2)  
2aca 32 73 ee			ld (debug_mark+2),a  
2acd 18 03			jr .pastdmark  
2acf ..			.dmark: db "LSn"  
2ad2 f1			.pastdmark: pop af  
2ad3			endm  
# End of macro DMARK
2ad3					CALLMONITOR 
2ad3 cd ae 15			call break_point_state  
2ad6				endm  
# End of macro CALLMONITOR
2ad6				endif 
2ad6			 
2ad6					 
2ad6			;		FORTH_DSP_POP 
2ad6			;		ld hl, .luno 
2ad6			 
2ad6					NEXTW			 
2ad6 c3 c5 1f			jp macro_next 
2ad9				endm 
# End of macro NEXTW
2ad9			 
2ad9			.listpush: 
2ad9				if DEBUG_FORTH_WORDS 
2ad9					DMARK "LS>" 
2ad9 f5				push af  
2ada 3a ee 2a			ld a, (.dmark)  
2add 32 71 ee			ld (debug_mark),a  
2ae0 3a ef 2a			ld a, (.dmark+1)  
2ae3 32 72 ee			ld (debug_mark+1),a  
2ae6 3a f0 2a			ld a, (.dmark+2)  
2ae9 32 73 ee			ld (debug_mark+2),a  
2aec 18 03			jr .pastdmark  
2aee ..			.dmark: db "LS>"  
2af1 f1			.pastdmark: pop af  
2af2			endm  
# End of macro DMARK
2af2					CALLMONITOR 
2af2 cd ae 15			call break_point_state  
2af5				endm  
# End of macro CALLMONITOR
2af5				endif 
2af5 cd 8d 1c				call forth_push_str 
2af8			 
2af8			 
2af8			 
2af8					NEXTW 
2af8 c3 c5 1f			jp macro_next 
2afb				endm 
# End of macro NEXTW
2afb			 
2afb			;.luno:    db "Word not found",0 
2afb			 
2afb			 
2afb			 
2afb			 
2afb			 
2afb			;		push hl   ; save pointer to start of uword def string 
2afb			; 
2afb			;; look for FORTH_EOL_LINE 
2afb			;		ld a, FORTH_END_BUFFER 
2afb			;		call strlent 
2afb			; 
2afb			;		inc hl		 ; space for coln def 
2afb			;		inc hl 
2afb			;		inc hl          ; space for terms 
2afb			;		inc hl 
2afb			; 
2afb			;		ld a, 20   ; TODO get actual length 
2afb			;		call addatohl    ; include a random amount of room for the uword name 
2afb			; 
2afb			;		 
2afb			;	if DEBUG_FORTH_WORDS 
2afb			;		DMARK "Lt1" 
2afb			;		CALLMONITOR 
2afb			;	endif 
2afb			;		 
2afb			; 
2afb			;; malloc space for the string because we cant change it 
2afb			; 
2afb			;		call malloc 
2afb			;	if DEBUG_FORTH_MALLOC_GUARD 
2afb			;		push af 
2afb			;		call ishlzero 
2afb			;		pop af 
2afb			;		 
2afb			;		call z,malloc_error 
2afb			;	endif 
2afb			; 
2afb			;	if DEBUG_FORTH_WORDS 
2afb			;		DMARK "Lt2" 
2afb			;		CALLMONITOR 
2afb			;	endif 
2afb			;		pop de 
2afb			;		push hl    ; push the malloc to release later 
2afb			;		push hl   ;  push back a copy for the later stack push 
2afb			;		 
2afb			;; copy the string swapping out the zero terms for spaces 
2afb			; 
2afb			;		; de has our source 
2afb			;		; hl has our dest 
2afb			; 
2afb			;; add the coln def 
2afb			; 
2afb			;		ld a, ':' 
2afb			;		ld (hl), a 
2afb			;		inc hl 
2afb			;		ld a, ' ' 
2afb			;		ld (hl), a 
2afb			;		inc hl 
2afb			; 
2afb			;; add the uname word 
2afb			;		push de   ; save our string for now 
2afb			;		ex de, hl 
2afb			; 
2afb			;		FORTH_DSP_VALUE 
2afb			;		;v5 FORTH_DSP_VALUE 
2afb			; 
2afb			;		inc hl   ; skip type but we know by now this is OK 
2afb			; 
2afb			;.luword:	ld a,(hl) 
2afb			;		cp 0 
2afb			;		jr z, .luword2 
2afb			;		ld (de), a 
2afb			;		inc de 
2afb			;		inc hl 
2afb			;		jr .luword 
2afb			; 
2afb			;.luword2:	ld a, ' ' 
2afb			;		ld (de), a 
2afb			;;		inc hl 
2afb			;;		inc de 
2afb			;;		ld (de), a 
2afb			;;		inc hl 
2afb			;		inc de 
2afb			; 
2afb			;		ex de, hl 
2afb			;		pop de 
2afb			;		 
2afb			;		 
2afb			; 
2afb			;; detoken that string and copy it 
2afb			; 
2afb			;	if DEBUG_FORTH_WORDS 
2afb			;		DMARK "Lt2" 
2afb			;		CALLMONITOR 
2afb			;	endif 
2afb			;.ldetok:	ld a, (de) 
2afb			;		cp FORTH_END_BUFFER 
2afb			;		jr z, .ldetokend 
2afb			;		; swap out any zero term for space 
2afb			;		cp 0 
2afb			;		jr nz, .ldetoknext 
2afb			;		ld a, ' ' 
2afb			; 
2afb			;	if DEBUG_FORTH_WORDS 
2afb			;		DMARK "LtS" 
2afb			;		CALLMONITOR 
2afb			;	endif 
2afb			;.ldetoknext:	ld (hl), a 
2afb			;		inc de 
2afb			;		inc hl 
2afb			;		jr .ldetok 
2afb			; 
2afb			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2afb			;		ld (hl), a  
2afb			; 
2afb			;; free that temp malloc 
2afb			; 
2afb			;		pop hl    
2afb			; 
2afb			;	if DEBUG_FORTH_WORDS 
2afb			;		DMARK "Lt4" 
2afb			;		CALLMONITOR 
2afb			;	endif 
2afb			;		call forth_apushstrhl 
2afb			; 
2afb			;		; get rid of temp malloc area 
2afb			; 
2afb			;		pop hl 
2afb			;		call free 
2afb			; 
2afb			;		jr .ludone 
2afb			; 
2afb			;.lnuword:	pop hl 
2afb			;		call forth_tok_next 
2afb			;		jp .ldouscan  
2afb			; 
2afb			;.ludone:		 pop hl 
2afb			; 
2afb					NEXTW 
2afb c3 c5 1f			jp macro_next 
2afe				endm 
# End of macro NEXTW
2afe			 
2afe			.FORGET: 
2afe				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2afe 5d				db WORD_SYS_CORE+73             
2aff 77 2b			dw .NOP            
2b01 07				db 6 + 1 
2b02 .. 00			db "FORGET",0              
2b09				endm 
# End of macro CWHEAD
2b09			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b09			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b09			; | |  
2b09			; | | e.g. "MORE" forget 
2b09					if DEBUG_FORTH_WORDS_KEY 
2b09						DMARK "FRG" 
2b09 f5				push af  
2b0a 3a 1e 2b			ld a, (.dmark)  
2b0d 32 71 ee			ld (debug_mark),a  
2b10 3a 1f 2b			ld a, (.dmark+1)  
2b13 32 72 ee			ld (debug_mark+1),a  
2b16 3a 20 2b			ld a, (.dmark+2)  
2b19 32 73 ee			ld (debug_mark+2),a  
2b1c 18 03			jr .pastdmark  
2b1e ..			.dmark: db "FRG"  
2b21 f1			.pastdmark: pop af  
2b22			endm  
# End of macro DMARK
2b22						CALLMONITOR 
2b22 cd ae 15			call break_point_state  
2b25				endm  
# End of macro CALLMONITOR
2b25					endif 
2b25			 
2b25				; find uword 
2b25			        ; update start of word with "_" 
2b25				; replace uword with deleted flag 
2b25			 
2b25			 
2b25			;	if DEBUG_FORTH_WORDS 
2b25			;		DMARK "FOG" 
2b25			;		CALLMONITOR 
2b25			;	endif 
2b25			 
2b25			 
2b25					; Get ptr to the word we need to look up 
2b25			 
2b25					FORTH_DSP_VALUEHL 
2b25 cd 16 1e			call macro_dsp_valuehl 
2b28				endm 
# End of macro FORTH_DSP_VALUEHL
2b28					;v5 FORTH_DSP_VALUE 
2b28				; TODO type check 
2b28			;		inc hl    ; Skip type check  
2b28 e5					push hl 
2b29 c1					pop bc 
2b2a			;		ex de, hl    ; put into DE 
2b2a			 
2b2a			 
2b2a 21 be 61				ld hl, baseram 
2b2d					;ld hl, baseusermem 
2b2d			 
2b2d				; skip dict stub 
2b2d			;	call forth_tok_next 
2b2d e5			push hl   ; sacreifical push 
2b2e			 
2b2e			.fldouscanm: 
2b2e e1				pop hl 
2b2f			.fldouscan: 
2b2f			;	if DEBUG_FORTH_WORDS 
2b2f			;		DMARK "LSs" 
2b2f			;		CALLMONITOR 
2b2f			;	endif 
2b2f				; skip dict stub 
2b2f cd 16 21				call forth_tok_next 
2b32			 
2b32			 
2b32			; while we have words to look for 
2b32			 
2b32 7e				ld a, (hl)      
2b33			;	if DEBUG_FORTH_WORDS 
2b33			;		DMARK "LSk" 
2b33			;		CALLMONITOR 
2b33			;	endif 
2b33 fe 00				cp WORD_SYS_END 
2b35 ca 71 2b				jp z, .flunotfound 
2b38 fe 01				cp WORD_SYS_UWORD 
2b3a c2 2f 2b				jp nz, .fldouscan 
2b3d			 
2b3d			;	if DEBUG_FORTH_WORDS 
2b3d			;		DMARK "LSu" 
2b3d			;		CALLMONITOR 
2b3d			;	endif 
2b3d			 
2b3d					; found a uword but is it the one we want... 
2b3d			 
2b3d c5					push bc     ; uword to find is on bc 
2b3e d1					pop de 
2b3f			 
2b3f e5					push hl  ; to save the ptr 
2b40			 
2b40					; skip opcode 
2b40 23					inc hl  
2b41					; skip next ptr 
2b41 23					inc hl  
2b42 23					inc hl 
2b43					; skip len 
2b43 23					inc hl 
2b44			 
2b44			;	if DEBUG_FORTH_WORDS 
2b44			;		DMARK "LSc" 
2b44			;		CALLMONITOR 
2b44			;	endif 
2b44 cd 43 12				call strcmp 
2b47 c2 2e 2b				jp nz, .fldouscanm 
2b4a			; 
2b4a			; 
2b4a			;; while we have words to look for 
2b4a			; 
2b4a			;.fdouscan:	ld a, (hl)      
2b4a			;	if DEBUG_FORTH_WORDS 
2b4a			;		DMARK "LSs" 
2b4a			;		CALLMONITOR 
2b4a			;	endif 
2b4a			;		cp WORD_SYS_END 
2b4a			;		jp z, .fudone 
2b4a			;		cp WORD_SYS_UWORD 
2b4a			;		jp nz, .fnuword 
2b4a			; 
2b4a			;	if DEBUG_FORTH_WORDS 
2b4a			;		DMARK "FGu" 
2b4a			;		CALLMONITOR 
2b4a			;	endif 
2b4a			; 
2b4a			;		; found a uword but is it the one we want... 
2b4a			; 
2b4a			; 
2b4a			;	        pop de   ; get back the dsp name 
2b4a			;		push de 
2b4a			; 
2b4a			;		push hl  ; to save the ptr 
2b4a			; 
2b4a			;		; skip opcode 
2b4a			;		inc hl  
2b4a			;		; skip next ptr 
2b4a			;		inc hl  
2b4a			;		inc hl 
2b4a			;		; skip len 
2b4a			;		inc hl 
2b4a			; 
2b4a			;	if DEBUG_FORTH_WORDS 
2b4a			;		DMARK "FGc" 
2b4a			;		CALLMONITOR 
2b4a			;	endif 
2b4a			;		call strcmp 
2b4a			;		jp nz, .fnuword 
2b4a			 
2b4a			 
2b4a e1			pop hl 
2b4b			 
2b4b				 
2b4b				if DEBUG_FORTH_WORDS 
2b4b					DMARK "FGm" 
2b4b f5				push af  
2b4c 3a 60 2b			ld a, (.dmark)  
2b4f 32 71 ee			ld (debug_mark),a  
2b52 3a 61 2b			ld a, (.dmark+1)  
2b55 32 72 ee			ld (debug_mark+1),a  
2b58 3a 62 2b			ld a, (.dmark+2)  
2b5b 32 73 ee			ld (debug_mark+2),a  
2b5e 18 03			jr .pastdmark  
2b60 ..			.dmark: db "FGm"  
2b63 f1			.pastdmark: pop af  
2b64			endm  
# End of macro DMARK
2b64					CALLMONITOR 
2b64 cd ae 15			call break_point_state  
2b67				endm  
# End of macro CALLMONITOR
2b67				endif 
2b67			 
2b67			 
2b67			 
2b67					; we have a uword so push its name to the stack 
2b67			 
2b67			;	   	push hl  ; save so we can move to next dict block 
2b67			;pop hl 
2b67			 
2b67					; update opcode to deleted 
2b67 3e 03				ld a, WORD_SYS_DELETED 
2b69 77					ld (hl), a 
2b6a			 
2b6a 23					inc hl  
2b6b					; skip next ptr 
2b6b 23					inc hl  
2b6c 23					inc hl 
2b6d					; skip len 
2b6d 23					inc hl 
2b6e			 
2b6e					; TODO change parser to skip deleted words but for now mark it out 
2b6e 3e 5f				ld a, "_" 
2b70 77					ld  (hl),a 
2b71			 
2b71			;		jr .fudone 
2b71			; 
2b71			;.fnuword:	pop hl 
2b71			;		call forth_tok_next 
2b71			;		jp .fdouscan  
2b71			 
2b71			.flunotfound:		  
2b71			 
2b71			 
2b71					 
2b71					FORTH_DSP_POP 
2b71 cd ce 1e			call macro_forth_dsp_pop 
2b74				endm 
# End of macro FORTH_DSP_POP
2b74			;		ld hl, .luno 
2b74			;.fudone:		 pop hl 
2b74					NEXTW 
2b74 c3 c5 1f			jp macro_next 
2b77				endm 
# End of macro NEXTW
2b77			.NOP: 
2b77				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2b77 61				db WORD_SYS_CORE+77             
2b78 9e 2b			dw .COMO            
2b7a 04				db 3 + 1 
2b7b .. 00			db "NOP",0              
2b7f				endm 
# End of macro CWHEAD
2b7f			; | NOP (  --  ) Do nothing | DONE 
2b7f					if DEBUG_FORTH_WORDS_KEY 
2b7f						DMARK "NOP" 
2b7f f5				push af  
2b80 3a 94 2b			ld a, (.dmark)  
2b83 32 71 ee			ld (debug_mark),a  
2b86 3a 95 2b			ld a, (.dmark+1)  
2b89 32 72 ee			ld (debug_mark+1),a  
2b8c 3a 96 2b			ld a, (.dmark+2)  
2b8f 32 73 ee			ld (debug_mark+2),a  
2b92 18 03			jr .pastdmark  
2b94 ..			.dmark: db "NOP"  
2b97 f1			.pastdmark: pop af  
2b98			endm  
# End of macro DMARK
2b98						CALLMONITOR 
2b98 cd ae 15			call break_point_state  
2b9b				endm  
# End of macro CALLMONITOR
2b9b					endif 
2b9b				       NEXTW 
2b9b c3 c5 1f			jp macro_next 
2b9e				endm 
# End of macro NEXTW
2b9e			.COMO: 
2b9e				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2b9e 6e				db WORD_SYS_CORE+90             
2b9f f0 2b			dw .COMC            
2ba1 02				db 1 + 1 
2ba2 .. 00			db "(",0              
2ba4				endm 
# End of macro CWHEAD
2ba4			; | ( ( -- )  Start of comment | DONE 
2ba4			 
2ba4			 
2ba4 2a cc e5				ld hl, ( os_tok_ptr) 
2ba7 11 eb 2b			ld de, .closepar 
2baa					 
2baa					if DEBUG_FORTH_WORDS 
2baa						DMARK ").." 
2baa f5				push af  
2bab 3a bf 2b			ld a, (.dmark)  
2bae 32 71 ee			ld (debug_mark),a  
2bb1 3a c0 2b			ld a, (.dmark+1)  
2bb4 32 72 ee			ld (debug_mark+1),a  
2bb7 3a c1 2b			ld a, (.dmark+2)  
2bba 32 73 ee			ld (debug_mark+2),a  
2bbd 18 03			jr .pastdmark  
2bbf ..			.dmark: db ").."  
2bc2 f1			.pastdmark: pop af  
2bc3			endm  
# End of macro DMARK
2bc3						CALLMONITOR 
2bc3 cd ae 15			call break_point_state  
2bc6				endm  
# End of macro CALLMONITOR
2bc6					endif 
2bc6 cd e0 20			call findnexttok  
2bc9			 
2bc9					if DEBUG_FORTH_WORDS 
2bc9						DMARK "IF5" 
2bc9 f5				push af  
2bca 3a de 2b			ld a, (.dmark)  
2bcd 32 71 ee			ld (debug_mark),a  
2bd0 3a df 2b			ld a, (.dmark+1)  
2bd3 32 72 ee			ld (debug_mark+1),a  
2bd6 3a e0 2b			ld a, (.dmark+2)  
2bd9 32 73 ee			ld (debug_mark+2),a  
2bdc 18 03			jr .pastdmark  
2bde ..			.dmark: db "IF5"  
2be1 f1			.pastdmark: pop af  
2be2			endm  
# End of macro DMARK
2be2						CALLMONITOR 
2be2 cd ae 15			call break_point_state  
2be5				endm  
# End of macro CALLMONITOR
2be5					endif 
2be5				; replace below with ) exec using tok_ptr 
2be5 22 cc e5			ld (os_tok_ptr), hl 
2be8 c3 56 20			jp exec1 
2beb			 
2beb .. 00			.closepar:   db ")",0 
2bed			 
2bed				       NEXTW 
2bed c3 c5 1f			jp macro_next 
2bf0				endm 
# End of macro NEXTW
2bf0			.COMC: 
2bf0				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2bf0 6f				db WORD_SYS_CORE+91             
2bf1 f9 2b			dw .SCRATCH            
2bf3 02				db 1 + 1 
2bf4 .. 00			db ")",0              
2bf6				endm 
# End of macro CWHEAD
2bf6			; | ) ( -- )  End of comment |  DONE  
2bf6				       NEXTW 
2bf6 c3 c5 1f			jp macro_next 
2bf9				endm 
# End of macro NEXTW
2bf9			 
2bf9			.SCRATCH: 
2bf9				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2bf9 6f				db WORD_SYS_CORE+91             
2bfa 34 2c			dw .INC            
2bfc 08				db 7 + 1 
2bfd .. 00			db "SCRATCH",0              
2c05				endm 
# End of macro CWHEAD
2c05			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c05			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c05			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c05			; | |  
2c05			; | | e.g.    : score $00 scratch ; 
2c05			; | |  
2c05			; | | $00 score ! 
2c05			; | | $01 score +! 
2c05			; | |  
2c05			; | | e.g.   : varword $0a scratch ;  
2c05			; | | 
2c05			; | | $8000 varword ! 
2c05					if DEBUG_FORTH_WORDS_KEY 
2c05						DMARK "SCR" 
2c05 f5				push af  
2c06 3a 1a 2c			ld a, (.dmark)  
2c09 32 71 ee			ld (debug_mark),a  
2c0c 3a 1b 2c			ld a, (.dmark+1)  
2c0f 32 72 ee			ld (debug_mark+1),a  
2c12 3a 1c 2c			ld a, (.dmark+2)  
2c15 32 73 ee			ld (debug_mark+2),a  
2c18 18 03			jr .pastdmark  
2c1a ..			.dmark: db "SCR"  
2c1d f1			.pastdmark: pop af  
2c1e			endm  
# End of macro DMARK
2c1e						CALLMONITOR 
2c1e cd ae 15			call break_point_state  
2c21				endm  
# End of macro CALLMONITOR
2c21					endif 
2c21			 
2c21					FORTH_DSP_VALUEHL 
2c21 cd 16 1e			call macro_dsp_valuehl 
2c24				endm 
# End of macro FORTH_DSP_VALUEHL
2c24				 
2c24					FORTH_DSP_POP 
2c24 cd ce 1e			call macro_forth_dsp_pop 
2c27				endm 
# End of macro FORTH_DSP_POP
2c27			 
2c27 7d					ld a, l 
2c28 21 f0 e7				ld hl, os_var_array 
2c2b cd ad 0d				call addatohl 
2c2e			 
2c2e cd 1f 1c				call forth_push_numhl 
2c31			 
2c31				       NEXTW 
2c31 c3 c5 1f			jp macro_next 
2c34				endm 
# End of macro NEXTW
2c34			 
2c34			.INC: 
2c34				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2c34 6f				db WORD_SYS_CORE+91             
2c35 88 2c			dw .DEC            
2c37 03				db 2 + 1 
2c38 .. 00			db "+!",0              
2c3b				endm 
# End of macro CWHEAD
2c3b			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2c3b					if DEBUG_FORTH_WORDS_KEY 
2c3b						DMARK "+s_" 
2c3b f5				push af  
2c3c 3a 50 2c			ld a, (.dmark)  
2c3f 32 71 ee			ld (debug_mark),a  
2c42 3a 51 2c			ld a, (.dmark+1)  
2c45 32 72 ee			ld (debug_mark+1),a  
2c48 3a 52 2c			ld a, (.dmark+2)  
2c4b 32 73 ee			ld (debug_mark+2),a  
2c4e 18 03			jr .pastdmark  
2c50 ..			.dmark: db "+s_"  
2c53 f1			.pastdmark: pop af  
2c54			endm  
# End of macro DMARK
2c54						CALLMONITOR 
2c54 cd ae 15			call break_point_state  
2c57				endm  
# End of macro CALLMONITOR
2c57					endif 
2c57			 
2c57					FORTH_DSP_VALUEHL 
2c57 cd 16 1e			call macro_dsp_valuehl 
2c5a				endm 
# End of macro FORTH_DSP_VALUEHL
2c5a			 
2c5a e5					push hl   ; save address 
2c5b			 
2c5b					FORTH_DSP_POP 
2c5b cd ce 1e			call macro_forth_dsp_pop 
2c5e				endm 
# End of macro FORTH_DSP_POP
2c5e			 
2c5e					FORTH_DSP_VALUEHL 
2c5e cd 16 1e			call macro_dsp_valuehl 
2c61				endm 
# End of macro FORTH_DSP_VALUEHL
2c61			 
2c61					FORTH_DSP_POP 
2c61 cd ce 1e			call macro_forth_dsp_pop 
2c64				endm 
# End of macro FORTH_DSP_POP
2c64			 
2c64					; hl contains value to add to byte at a 
2c64				 
2c64 eb					ex de, hl 
2c65			 
2c65 e1					pop hl 
2c66			 
2c66					if DEBUG_FORTH_WORDS 
2c66						DMARK "INC" 
2c66 f5				push af  
2c67 3a 7b 2c			ld a, (.dmark)  
2c6a 32 71 ee			ld (debug_mark),a  
2c6d 3a 7c 2c			ld a, (.dmark+1)  
2c70 32 72 ee			ld (debug_mark+1),a  
2c73 3a 7d 2c			ld a, (.dmark+2)  
2c76 32 73 ee			ld (debug_mark+2),a  
2c79 18 03			jr .pastdmark  
2c7b ..			.dmark: db "INC"  
2c7e f1			.pastdmark: pop af  
2c7f			endm  
# End of macro DMARK
2c7f						CALLMONITOR 
2c7f cd ae 15			call break_point_state  
2c82				endm  
# End of macro CALLMONITOR
2c82					endif 
2c82			 
2c82 7e					ld a,(hl) 
2c83 83					add e 
2c84 77					ld (hl),a 
2c85			 
2c85			 
2c85			 
2c85				       NEXTW 
2c85 c3 c5 1f			jp macro_next 
2c88				endm 
# End of macro NEXTW
2c88			 
2c88			.DEC: 
2c88				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2c88 6f				db WORD_SYS_CORE+91             
2c89 d9 2c			dw .INC2            
2c8b 03				db 2 + 1 
2c8c .. 00			db "-!",0              
2c8f				endm 
# End of macro CWHEAD
2c8f			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2c8f					if DEBUG_FORTH_WORDS_KEY 
2c8f						DMARK "-s_" 
2c8f f5				push af  
2c90 3a a4 2c			ld a, (.dmark)  
2c93 32 71 ee			ld (debug_mark),a  
2c96 3a a5 2c			ld a, (.dmark+1)  
2c99 32 72 ee			ld (debug_mark+1),a  
2c9c 3a a6 2c			ld a, (.dmark+2)  
2c9f 32 73 ee			ld (debug_mark+2),a  
2ca2 18 03			jr .pastdmark  
2ca4 ..			.dmark: db "-s_"  
2ca7 f1			.pastdmark: pop af  
2ca8			endm  
# End of macro DMARK
2ca8						CALLMONITOR 
2ca8 cd ae 15			call break_point_state  
2cab				endm  
# End of macro CALLMONITOR
2cab					endif 
2cab			 
2cab					FORTH_DSP_VALUEHL 
2cab cd 16 1e			call macro_dsp_valuehl 
2cae				endm 
# End of macro FORTH_DSP_VALUEHL
2cae			 
2cae e5					push hl   ; save address 
2caf			 
2caf					FORTH_DSP_POP 
2caf cd ce 1e			call macro_forth_dsp_pop 
2cb2				endm 
# End of macro FORTH_DSP_POP
2cb2			 
2cb2					FORTH_DSP_VALUEHL 
2cb2 cd 16 1e			call macro_dsp_valuehl 
2cb5				endm 
# End of macro FORTH_DSP_VALUEHL
2cb5			 
2cb5					; hl contains value to add to byte at a 
2cb5				 
2cb5 eb					ex de, hl 
2cb6			 
2cb6 e1					pop hl 
2cb7			 
2cb7					if DEBUG_FORTH_WORDS 
2cb7						DMARK "DEC" 
2cb7 f5				push af  
2cb8 3a cc 2c			ld a, (.dmark)  
2cbb 32 71 ee			ld (debug_mark),a  
2cbe 3a cd 2c			ld a, (.dmark+1)  
2cc1 32 72 ee			ld (debug_mark+1),a  
2cc4 3a ce 2c			ld a, (.dmark+2)  
2cc7 32 73 ee			ld (debug_mark+2),a  
2cca 18 03			jr .pastdmark  
2ccc ..			.dmark: db "DEC"  
2ccf f1			.pastdmark: pop af  
2cd0			endm  
# End of macro DMARK
2cd0						CALLMONITOR 
2cd0 cd ae 15			call break_point_state  
2cd3				endm  
# End of macro CALLMONITOR
2cd3					endif 
2cd3			 
2cd3 7e					ld a,(hl) 
2cd4 93					sub e 
2cd5 77					ld (hl),a 
2cd6			 
2cd6			 
2cd6			 
2cd6				       NEXTW 
2cd6 c3 c5 1f			jp macro_next 
2cd9				endm 
# End of macro NEXTW
2cd9			 
2cd9			.INC2: 
2cd9				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2cd9 6f				db WORD_SYS_CORE+91             
2cda 83 2d			dw .DEC2            
2cdc 04				db 3 + 1 
2cdd .. 00			db "+2!",0              
2ce1				endm 
# End of macro CWHEAD
2ce1			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2ce1			 
2ce1					if DEBUG_FORTH_WORDS_KEY 
2ce1						DMARK "+2s" 
2ce1 f5				push af  
2ce2 3a f6 2c			ld a, (.dmark)  
2ce5 32 71 ee			ld (debug_mark),a  
2ce8 3a f7 2c			ld a, (.dmark+1)  
2ceb 32 72 ee			ld (debug_mark+1),a  
2cee 3a f8 2c			ld a, (.dmark+2)  
2cf1 32 73 ee			ld (debug_mark+2),a  
2cf4 18 03			jr .pastdmark  
2cf6 ..			.dmark: db "+2s"  
2cf9 f1			.pastdmark: pop af  
2cfa			endm  
# End of macro DMARK
2cfa						CALLMONITOR 
2cfa cd ae 15			call break_point_state  
2cfd				endm  
# End of macro CALLMONITOR
2cfd					endif 
2cfd			 
2cfd					; Address 
2cfd			 
2cfd					FORTH_DSP_VALUEHL 
2cfd cd 16 1e			call macro_dsp_valuehl 
2d00				endm 
# End of macro FORTH_DSP_VALUEHL
2d00			 
2d00 e5					push hl    ; save address 
2d01			 
2d01					; load content into de 
2d01			 
2d01 5e					ld e,(hl) 
2d02 23					inc hl 
2d03 56					ld d, (hl) 
2d04			 
2d04					if DEBUG_FORTH_WORDS 
2d04						DMARK "+2a" 
2d04 f5				push af  
2d05 3a 19 2d			ld a, (.dmark)  
2d08 32 71 ee			ld (debug_mark),a  
2d0b 3a 1a 2d			ld a, (.dmark+1)  
2d0e 32 72 ee			ld (debug_mark+1),a  
2d11 3a 1b 2d			ld a, (.dmark+2)  
2d14 32 73 ee			ld (debug_mark+2),a  
2d17 18 03			jr .pastdmark  
2d19 ..			.dmark: db "+2a"  
2d1c f1			.pastdmark: pop af  
2d1d			endm  
# End of macro DMARK
2d1d						CALLMONITOR 
2d1d cd ae 15			call break_point_state  
2d20				endm  
# End of macro CALLMONITOR
2d20					endif 
2d20			 
2d20					FORTH_DSP_POP 
2d20 cd ce 1e			call macro_forth_dsp_pop 
2d23				endm 
# End of macro FORTH_DSP_POP
2d23			 
2d23					; Get value to add 
2d23			 
2d23					FORTH_DSP_VALUE 
2d23 cd ff 1d			call macro_forth_dsp_value 
2d26				endm 
# End of macro FORTH_DSP_VALUE
2d26			 
2d26					if DEBUG_FORTH_WORDS 
2d26						DMARK "+2v" 
2d26 f5				push af  
2d27 3a 3b 2d			ld a, (.dmark)  
2d2a 32 71 ee			ld (debug_mark),a  
2d2d 3a 3c 2d			ld a, (.dmark+1)  
2d30 32 72 ee			ld (debug_mark+1),a  
2d33 3a 3d 2d			ld a, (.dmark+2)  
2d36 32 73 ee			ld (debug_mark+2),a  
2d39 18 03			jr .pastdmark  
2d3b ..			.dmark: db "+2v"  
2d3e f1			.pastdmark: pop af  
2d3f			endm  
# End of macro DMARK
2d3f						CALLMONITOR 
2d3f cd ae 15			call break_point_state  
2d42				endm  
# End of macro CALLMONITOR
2d42					endif 
2d42			 
2d42 19					add hl, de 
2d43			 
2d43					if DEBUG_FORTH_WORDS 
2d43						DMARK "+2+" 
2d43 f5				push af  
2d44 3a 58 2d			ld a, (.dmark)  
2d47 32 71 ee			ld (debug_mark),a  
2d4a 3a 59 2d			ld a, (.dmark+1)  
2d4d 32 72 ee			ld (debug_mark+1),a  
2d50 3a 5a 2d			ld a, (.dmark+2)  
2d53 32 73 ee			ld (debug_mark+2),a  
2d56 18 03			jr .pastdmark  
2d58 ..			.dmark: db "+2+"  
2d5b f1			.pastdmark: pop af  
2d5c			endm  
# End of macro DMARK
2d5c						CALLMONITOR 
2d5c cd ae 15			call break_point_state  
2d5f				endm  
# End of macro CALLMONITOR
2d5f					endif 
2d5f			 
2d5f					; move result to de 
2d5f			 
2d5f eb					ex de, hl 
2d60			 
2d60					; Address 
2d60			 
2d60 e1					pop hl 
2d61			 
2d61					; save it back 
2d61			 
2d61 73					ld (hl), e 
2d62 23					inc hl 
2d63 72					ld (hl), d 
2d64			 
2d64					if DEBUG_FORTH_WORDS 
2d64						DMARK "+2e" 
2d64 f5				push af  
2d65 3a 79 2d			ld a, (.dmark)  
2d68 32 71 ee			ld (debug_mark),a  
2d6b 3a 7a 2d			ld a, (.dmark+1)  
2d6e 32 72 ee			ld (debug_mark+1),a  
2d71 3a 7b 2d			ld a, (.dmark+2)  
2d74 32 73 ee			ld (debug_mark+2),a  
2d77 18 03			jr .pastdmark  
2d79 ..			.dmark: db "+2e"  
2d7c f1			.pastdmark: pop af  
2d7d			endm  
# End of macro DMARK
2d7d						CALLMONITOR 
2d7d cd ae 15			call break_point_state  
2d80				endm  
# End of macro CALLMONITOR
2d80					endif 
2d80			 
2d80			 
2d80			 
2d80			 
2d80			 
2d80				       NEXTW 
2d80 c3 c5 1f			jp macro_next 
2d83				endm 
# End of macro NEXTW
2d83			 
2d83			.DEC2: 
2d83				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2d83 6f				db WORD_SYS_CORE+91             
2d84 2f 2e			dw .GET2            
2d86 04				db 3 + 1 
2d87 .. 00			db "-2!",0              
2d8b				endm 
# End of macro CWHEAD
2d8b			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2d8b			 
2d8b			 
2d8b					if DEBUG_FORTH_WORDS_KEY 
2d8b						DMARK "-2s" 
2d8b f5				push af  
2d8c 3a a0 2d			ld a, (.dmark)  
2d8f 32 71 ee			ld (debug_mark),a  
2d92 3a a1 2d			ld a, (.dmark+1)  
2d95 32 72 ee			ld (debug_mark+1),a  
2d98 3a a2 2d			ld a, (.dmark+2)  
2d9b 32 73 ee			ld (debug_mark+2),a  
2d9e 18 03			jr .pastdmark  
2da0 ..			.dmark: db "-2s"  
2da3 f1			.pastdmark: pop af  
2da4			endm  
# End of macro DMARK
2da4						CALLMONITOR 
2da4 cd ae 15			call break_point_state  
2da7				endm  
# End of macro CALLMONITOR
2da7					endif 
2da7			 
2da7					; Address 
2da7			 
2da7					FORTH_DSP_VALUEHL 
2da7 cd 16 1e			call macro_dsp_valuehl 
2daa				endm 
# End of macro FORTH_DSP_VALUEHL
2daa			 
2daa e5					push hl    ; save address 
2dab			 
2dab					; load content into de 
2dab			 
2dab 5e					ld e,(hl) 
2dac 23					inc hl 
2dad 56					ld d, (hl) 
2dae			 
2dae					if DEBUG_FORTH_WORDS 
2dae						DMARK "-2a" 
2dae f5				push af  
2daf 3a c3 2d			ld a, (.dmark)  
2db2 32 71 ee			ld (debug_mark),a  
2db5 3a c4 2d			ld a, (.dmark+1)  
2db8 32 72 ee			ld (debug_mark+1),a  
2dbb 3a c5 2d			ld a, (.dmark+2)  
2dbe 32 73 ee			ld (debug_mark+2),a  
2dc1 18 03			jr .pastdmark  
2dc3 ..			.dmark: db "-2a"  
2dc6 f1			.pastdmark: pop af  
2dc7			endm  
# End of macro DMARK
2dc7						CALLMONITOR 
2dc7 cd ae 15			call break_point_state  
2dca				endm  
# End of macro CALLMONITOR
2dca					endif 
2dca			 
2dca					FORTH_DSP_POP 
2dca cd ce 1e			call macro_forth_dsp_pop 
2dcd				endm 
# End of macro FORTH_DSP_POP
2dcd			 
2dcd					; Get value to remove 
2dcd			 
2dcd					FORTH_DSP_VALUE 
2dcd cd ff 1d			call macro_forth_dsp_value 
2dd0				endm 
# End of macro FORTH_DSP_VALUE
2dd0			 
2dd0					if DEBUG_FORTH_WORDS 
2dd0						DMARK "-2v" 
2dd0 f5				push af  
2dd1 3a e5 2d			ld a, (.dmark)  
2dd4 32 71 ee			ld (debug_mark),a  
2dd7 3a e6 2d			ld a, (.dmark+1)  
2dda 32 72 ee			ld (debug_mark+1),a  
2ddd 3a e7 2d			ld a, (.dmark+2)  
2de0 32 73 ee			ld (debug_mark+2),a  
2de3 18 03			jr .pastdmark  
2de5 ..			.dmark: db "-2v"  
2de8 f1			.pastdmark: pop af  
2de9			endm  
# End of macro DMARK
2de9						CALLMONITOR 
2de9 cd ae 15			call break_point_state  
2dec				endm  
# End of macro CALLMONITOR
2dec					endif 
2dec			 
2dec eb					ex de, hl 
2ded ed 52				sbc hl, de 
2def			 
2def					if DEBUG_FORTH_WORDS 
2def						DMARK "-2d" 
2def f5				push af  
2df0 3a 04 2e			ld a, (.dmark)  
2df3 32 71 ee			ld (debug_mark),a  
2df6 3a 05 2e			ld a, (.dmark+1)  
2df9 32 72 ee			ld (debug_mark+1),a  
2dfc 3a 06 2e			ld a, (.dmark+2)  
2dff 32 73 ee			ld (debug_mark+2),a  
2e02 18 03			jr .pastdmark  
2e04 ..			.dmark: db "-2d"  
2e07 f1			.pastdmark: pop af  
2e08			endm  
# End of macro DMARK
2e08						CALLMONITOR 
2e08 cd ae 15			call break_point_state  
2e0b				endm  
# End of macro CALLMONITOR
2e0b					endif 
2e0b			 
2e0b					; move result to de 
2e0b			 
2e0b eb					ex de, hl 
2e0c			 
2e0c					; Address 
2e0c			 
2e0c e1					pop hl 
2e0d			 
2e0d					; save it back 
2e0d			 
2e0d 73					ld (hl), e 
2e0e 23					inc hl 
2e0f 72					ld (hl), d 
2e10			 
2e10					if DEBUG_FORTH_WORDS 
2e10						DMARK "-2e" 
2e10 f5				push af  
2e11 3a 25 2e			ld a, (.dmark)  
2e14 32 71 ee			ld (debug_mark),a  
2e17 3a 26 2e			ld a, (.dmark+1)  
2e1a 32 72 ee			ld (debug_mark+1),a  
2e1d 3a 27 2e			ld a, (.dmark+2)  
2e20 32 73 ee			ld (debug_mark+2),a  
2e23 18 03			jr .pastdmark  
2e25 ..			.dmark: db "-2e"  
2e28 f1			.pastdmark: pop af  
2e29			endm  
# End of macro DMARK
2e29						CALLMONITOR 
2e29 cd ae 15			call break_point_state  
2e2c				endm  
# End of macro CALLMONITOR
2e2c					endif 
2e2c			 
2e2c			 
2e2c			 
2e2c			 
2e2c			 
2e2c				       NEXTW 
2e2c c3 c5 1f			jp macro_next 
2e2f				endm 
# End of macro NEXTW
2e2f			.GET2: 
2e2f				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2e2f 6f				db WORD_SYS_CORE+91             
2e30 5f 2e			dw .BANG2            
2e32 03				db 2 + 1 
2e33 .. 00			db "2@",0              
2e36				endm 
# End of macro CWHEAD
2e36			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2e36					if DEBUG_FORTH_WORDS_KEY 
2e36						DMARK "2A_" 
2e36 f5				push af  
2e37 3a 4b 2e			ld a, (.dmark)  
2e3a 32 71 ee			ld (debug_mark),a  
2e3d 3a 4c 2e			ld a, (.dmark+1)  
2e40 32 72 ee			ld (debug_mark+1),a  
2e43 3a 4d 2e			ld a, (.dmark+2)  
2e46 32 73 ee			ld (debug_mark+2),a  
2e49 18 03			jr .pastdmark  
2e4b ..			.dmark: db "2A_"  
2e4e f1			.pastdmark: pop af  
2e4f			endm  
# End of macro DMARK
2e4f						CALLMONITOR 
2e4f cd ae 15			call break_point_state  
2e52				endm  
# End of macro CALLMONITOR
2e52					endif 
2e52			 
2e52					FORTH_DSP_VALUEHL 
2e52 cd 16 1e			call macro_dsp_valuehl 
2e55				endm 
# End of macro FORTH_DSP_VALUEHL
2e55			 
2e55 5e					ld e, (hl) 
2e56 23					inc hl 
2e57 56					ld d, (hl) 
2e58			 
2e58 eb					ex de, hl 
2e59			 
2e59 cd 1f 1c				call forth_push_numhl 
2e5c			 
2e5c				       NEXTW 
2e5c c3 c5 1f			jp macro_next 
2e5f				endm 
# End of macro NEXTW
2e5f			.BANG2: 
2e5f				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2e5f 6f				db WORD_SYS_CORE+91             
2e60 97 2e			dw .CONFIG            
2e62 03				db 2 + 1 
2e63 .. 00			db "2!",0              
2e66				endm 
# End of macro CWHEAD
2e66			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2e66					if DEBUG_FORTH_WORDS_KEY 
2e66						DMARK "2S_" 
2e66 f5				push af  
2e67 3a 7b 2e			ld a, (.dmark)  
2e6a 32 71 ee			ld (debug_mark),a  
2e6d 3a 7c 2e			ld a, (.dmark+1)  
2e70 32 72 ee			ld (debug_mark+1),a  
2e73 3a 7d 2e			ld a, (.dmark+2)  
2e76 32 73 ee			ld (debug_mark+2),a  
2e79 18 03			jr .pastdmark  
2e7b ..			.dmark: db "2S_"  
2e7e f1			.pastdmark: pop af  
2e7f			endm  
# End of macro DMARK
2e7f						CALLMONITOR 
2e7f cd ae 15			call break_point_state  
2e82				endm  
# End of macro CALLMONITOR
2e82					endif 
2e82			 
2e82					FORTH_DSP_VALUEHL 
2e82 cd 16 1e			call macro_dsp_valuehl 
2e85				endm 
# End of macro FORTH_DSP_VALUEHL
2e85			 
2e85 e5					push hl   ; save address 
2e86			 
2e86			 
2e86					FORTH_DSP_POP 
2e86 cd ce 1e			call macro_forth_dsp_pop 
2e89				endm 
# End of macro FORTH_DSP_POP
2e89			 
2e89					 
2e89					FORTH_DSP_VALUEHL 
2e89 cd 16 1e			call macro_dsp_valuehl 
2e8c				endm 
# End of macro FORTH_DSP_VALUEHL
2e8c			 
2e8c					FORTH_DSP_POP 
2e8c cd ce 1e			call macro_forth_dsp_pop 
2e8f				endm 
# End of macro FORTH_DSP_POP
2e8f			 
2e8f eb					ex de, hl    ; value now in de 
2e90			 
2e90 e1					pop hl 
2e91			 
2e91 73					ld (hl), e 
2e92			 
2e92 23					inc hl 
2e93			 
2e93 72					ld (hl), d 
2e94			 
2e94			 
2e94				       NEXTW 
2e94 c3 c5 1f			jp macro_next 
2e97				endm 
# End of macro NEXTW
2e97			.CONFIG: 
2e97				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2e97 6f				db WORD_SYS_CORE+91             
2e98 a8 2e			dw .ENDCORE            
2e9a 07				db 6 + 1 
2e9b .. 00			db "CONFIG",0              
2ea2				endm 
# End of macro CWHEAD
2ea2			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2ea2			 
2ea2 cd 0d 14				call config 
2ea5					NEXTW 
2ea5 c3 c5 1f			jp macro_next 
2ea8				endm 
# End of macro NEXTW
2ea8			.ENDCORE: 
2ea8			 
2ea8			; eof 
2ea8			 
2ea8			 
# End of file forth_words_core.asm
2ea8			include "forth_words_flow.asm" 
2ea8			 
2ea8			; | ## Program Flow Words 
2ea8			 
2ea8			.IF: 
2ea8				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2ea8 1e				db WORD_SYS_CORE+10             
2ea9 9d 2f			dw .THEN            
2eab 03				db 2 + 1 
2eac .. 00			db "IF",0              
2eaf				endm 
# End of macro CWHEAD
2eaf			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2eaf			; 
2eaf					if DEBUG_FORTH_WORDS_KEY 
2eaf						DMARK "IF." 
2eaf f5				push af  
2eb0 3a c4 2e			ld a, (.dmark)  
2eb3 32 71 ee			ld (debug_mark),a  
2eb6 3a c5 2e			ld a, (.dmark+1)  
2eb9 32 72 ee			ld (debug_mark+1),a  
2ebc 3a c6 2e			ld a, (.dmark+2)  
2ebf 32 73 ee			ld (debug_mark+2),a  
2ec2 18 03			jr .pastdmark  
2ec4 ..			.dmark: db "IF."  
2ec7 f1			.pastdmark: pop af  
2ec8			endm  
# End of macro DMARK
2ec8						CALLMONITOR 
2ec8 cd ae 15			call break_point_state  
2ecb				endm  
# End of macro CALLMONITOR
2ecb					endif 
2ecb			; eval TOS 
2ecb			 
2ecb				FORTH_DSP_VALUEHL 
2ecb cd 16 1e			call macro_dsp_valuehl 
2ece				endm 
# End of macro FORTH_DSP_VALUEHL
2ece			 
2ece			;	push hl 
2ece				FORTH_DSP_POP 
2ece cd ce 1e			call macro_forth_dsp_pop 
2ed1				endm 
# End of macro FORTH_DSP_POP
2ed1			;	pop hl 
2ed1			 
2ed1					if DEBUG_FORTH_WORDS 
2ed1						DMARK "IF1" 
2ed1 f5				push af  
2ed2 3a e6 2e			ld a, (.dmark)  
2ed5 32 71 ee			ld (debug_mark),a  
2ed8 3a e7 2e			ld a, (.dmark+1)  
2edb 32 72 ee			ld (debug_mark+1),a  
2ede 3a e8 2e			ld a, (.dmark+2)  
2ee1 32 73 ee			ld (debug_mark+2),a  
2ee4 18 03			jr .pastdmark  
2ee6 ..			.dmark: db "IF1"  
2ee9 f1			.pastdmark: pop af  
2eea			endm  
# End of macro DMARK
2eea						CALLMONITOR 
2eea cd ae 15			call break_point_state  
2eed				endm  
# End of macro CALLMONITOR
2eed					endif 
2eed b7				or a        ; clear carry flag 
2eee 11 00 00			ld de, 0 
2ef1 eb				ex de,hl 
2ef2 ed 52			sbc hl, de 
2ef4 c2 7e 2f			jp nz, .iftrue 
2ef7			 
2ef7					if DEBUG_FORTH_WORDS 
2ef7						DMARK "IF2" 
2ef7 f5				push af  
2ef8 3a 0c 2f			ld a, (.dmark)  
2efb 32 71 ee			ld (debug_mark),a  
2efe 3a 0d 2f			ld a, (.dmark+1)  
2f01 32 72 ee			ld (debug_mark+1),a  
2f04 3a 0e 2f			ld a, (.dmark+2)  
2f07 32 73 ee			ld (debug_mark+2),a  
2f0a 18 03			jr .pastdmark  
2f0c ..			.dmark: db "IF2"  
2f0f f1			.pastdmark: pop af  
2f10			endm  
# End of macro DMARK
2f10						CALLMONITOR 
2f10 cd ae 15			call break_point_state  
2f13				endm  
# End of macro CALLMONITOR
2f13					endif 
2f13			 
2f13			; if not true then skip to THEN 
2f13			 
2f13				; TODO get tok_ptr 
2f13				; TODO consume toks until we get to THEN 
2f13			 
2f13 2a cc e5			ld hl, (os_tok_ptr) 
2f16					if DEBUG_FORTH_WORDS 
2f16						DMARK "IF3" 
2f16 f5				push af  
2f17 3a 2b 2f			ld a, (.dmark)  
2f1a 32 71 ee			ld (debug_mark),a  
2f1d 3a 2c 2f			ld a, (.dmark+1)  
2f20 32 72 ee			ld (debug_mark+1),a  
2f23 3a 2d 2f			ld a, (.dmark+2)  
2f26 32 73 ee			ld (debug_mark+2),a  
2f29 18 03			jr .pastdmark  
2f2b ..			.dmark: db "IF3"  
2f2e f1			.pastdmark: pop af  
2f2f			endm  
# End of macro DMARK
2f2f						CALLMONITOR 
2f2f cd ae 15			call break_point_state  
2f32				endm  
# End of macro CALLMONITOR
2f32						 
2f32					endif 
2f32 11 79 2f			ld de, .ifthen 
2f35					if DEBUG_FORTH_WORDS 
2f35						DMARK "IF4" 
2f35 f5				push af  
2f36 3a 4a 2f			ld a, (.dmark)  
2f39 32 71 ee			ld (debug_mark),a  
2f3c 3a 4b 2f			ld a, (.dmark+1)  
2f3f 32 72 ee			ld (debug_mark+1),a  
2f42 3a 4c 2f			ld a, (.dmark+2)  
2f45 32 73 ee			ld (debug_mark+2),a  
2f48 18 03			jr .pastdmark  
2f4a ..			.dmark: db "IF4"  
2f4d f1			.pastdmark: pop af  
2f4e			endm  
# End of macro DMARK
2f4e						CALLMONITOR 
2f4e cd ae 15			call break_point_state  
2f51				endm  
# End of macro CALLMONITOR
2f51					endif 
2f51 cd e0 20			call findnexttok  
2f54			 
2f54					if DEBUG_FORTH_WORDS 
2f54						DMARK "IF5" 
2f54 f5				push af  
2f55 3a 69 2f			ld a, (.dmark)  
2f58 32 71 ee			ld (debug_mark),a  
2f5b 3a 6a 2f			ld a, (.dmark+1)  
2f5e 32 72 ee			ld (debug_mark+1),a  
2f61 3a 6b 2f			ld a, (.dmark+2)  
2f64 32 73 ee			ld (debug_mark+2),a  
2f67 18 03			jr .pastdmark  
2f69 ..			.dmark: db "IF5"  
2f6c f1			.pastdmark: pop af  
2f6d			endm  
# End of macro DMARK
2f6d						CALLMONITOR 
2f6d cd ae 15			call break_point_state  
2f70				endm  
# End of macro CALLMONITOR
2f70					endif 
2f70				; TODO replace below with ; exec using tok_ptr 
2f70 22 cc e5			ld (os_tok_ptr), hl 
2f73 c3 56 20			jp exec1 
2f76				NEXTW 
2f76 c3 c5 1f			jp macro_next 
2f79				endm 
# End of macro NEXTW
2f79			 
2f79 .. 00		.ifthen:  db "THEN",0 
2f7e			 
2f7e			.iftrue:		 
2f7e				; Exec next words normally 
2f7e			 
2f7e				; if true then exec following IF as normal 
2f7e					if DEBUG_FORTH_WORDS 
2f7e						DMARK "IFT" 
2f7e f5				push af  
2f7f 3a 93 2f			ld a, (.dmark)  
2f82 32 71 ee			ld (debug_mark),a  
2f85 3a 94 2f			ld a, (.dmark+1)  
2f88 32 72 ee			ld (debug_mark+1),a  
2f8b 3a 95 2f			ld a, (.dmark+2)  
2f8e 32 73 ee			ld (debug_mark+2),a  
2f91 18 03			jr .pastdmark  
2f93 ..			.dmark: db "IFT"  
2f96 f1			.pastdmark: pop af  
2f97			endm  
# End of macro DMARK
2f97						CALLMONITOR 
2f97 cd ae 15			call break_point_state  
2f9a				endm  
# End of macro CALLMONITOR
2f9a					endif 
2f9a			 
2f9a					NEXTW 
2f9a c3 c5 1f			jp macro_next 
2f9d				endm 
# End of macro NEXTW
2f9d			.THEN: 
2f9d				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2f9d 1f				db WORD_SYS_CORE+11             
2f9e c5 2f			dw .ELSE            
2fa0 05				db 4 + 1 
2fa1 .. 00			db "THEN",0              
2fa6				endm 
# End of macro CWHEAD
2fa6			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2fa6					if DEBUG_FORTH_WORDS_KEY 
2fa6						DMARK "THN" 
2fa6 f5				push af  
2fa7 3a bb 2f			ld a, (.dmark)  
2faa 32 71 ee			ld (debug_mark),a  
2fad 3a bc 2f			ld a, (.dmark+1)  
2fb0 32 72 ee			ld (debug_mark+1),a  
2fb3 3a bd 2f			ld a, (.dmark+2)  
2fb6 32 73 ee			ld (debug_mark+2),a  
2fb9 18 03			jr .pastdmark  
2fbb ..			.dmark: db "THN"  
2fbe f1			.pastdmark: pop af  
2fbf			endm  
# End of macro DMARK
2fbf						CALLMONITOR 
2fbf cd ae 15			call break_point_state  
2fc2				endm  
# End of macro CALLMONITOR
2fc2					endif 
2fc2					NEXTW 
2fc2 c3 c5 1f			jp macro_next 
2fc5				endm 
# End of macro NEXTW
2fc5			.ELSE: 
2fc5				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2fc5 20				db WORD_SYS_CORE+12             
2fc6 ed 2f			dw .DO            
2fc8 03				db 2 + 1 
2fc9 .. 00			db "ELSE",0              
2fce				endm 
# End of macro CWHEAD
2fce			; | ELSE ( -- ) Not supported - does nothing | TODO 
2fce			 
2fce					if DEBUG_FORTH_WORDS_KEY 
2fce						DMARK "ELS" 
2fce f5				push af  
2fcf 3a e3 2f			ld a, (.dmark)  
2fd2 32 71 ee			ld (debug_mark),a  
2fd5 3a e4 2f			ld a, (.dmark+1)  
2fd8 32 72 ee			ld (debug_mark+1),a  
2fdb 3a e5 2f			ld a, (.dmark+2)  
2fde 32 73 ee			ld (debug_mark+2),a  
2fe1 18 03			jr .pastdmark  
2fe3 ..			.dmark: db "ELS"  
2fe6 f1			.pastdmark: pop af  
2fe7			endm  
# End of macro DMARK
2fe7						CALLMONITOR 
2fe7 cd ae 15			call break_point_state  
2fea				endm  
# End of macro CALLMONITOR
2fea					endif 
2fea			 
2fea			 
2fea					NEXTW 
2fea c3 c5 1f			jp macro_next 
2fed				endm 
# End of macro NEXTW
2fed			.DO: 
2fed				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2fed 21				db WORD_SYS_CORE+13             
2fee 14 31			dw .LOOP            
2ff0 03				db 2 + 1 
2ff1 .. 00			db "DO",0              
2ff4				endm 
# End of macro CWHEAD
2ff4			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2ff4			 
2ff4					if DEBUG_FORTH_WORDS_KEY 
2ff4						DMARK "DO." 
2ff4 f5				push af  
2ff5 3a 09 30			ld a, (.dmark)  
2ff8 32 71 ee			ld (debug_mark),a  
2ffb 3a 0a 30			ld a, (.dmark+1)  
2ffe 32 72 ee			ld (debug_mark+1),a  
3001 3a 0b 30			ld a, (.dmark+2)  
3004 32 73 ee			ld (debug_mark+2),a  
3007 18 03			jr .pastdmark  
3009 ..			.dmark: db "DO."  
300c f1			.pastdmark: pop af  
300d			endm  
# End of macro DMARK
300d						CALLMONITOR 
300d cd ae 15			call break_point_state  
3010				endm  
# End of macro CALLMONITOR
3010					endif 
3010			;  push pc to rsp stack past the DO 
3010			 
3010 2a cc e5				ld hl, (os_tok_ptr) 
3013 23					inc hl   ; D 
3014 23					inc hl  ; O 
3015 23					inc hl   ; null 
3016					if DEBUG_FORTH_WORDS 
3016						DMARK "DO2" 
3016 f5				push af  
3017 3a 2b 30			ld a, (.dmark)  
301a 32 71 ee			ld (debug_mark),a  
301d 3a 2c 30			ld a, (.dmark+1)  
3020 32 72 ee			ld (debug_mark+1),a  
3023 3a 2d 30			ld a, (.dmark+2)  
3026 32 73 ee			ld (debug_mark+2),a  
3029 18 03			jr .pastdmark  
302b ..			.dmark: db "DO2"  
302e f1			.pastdmark: pop af  
302f			endm  
# End of macro DMARK
302f						CALLMONITOR 
302f cd ae 15			call break_point_state  
3032				endm  
# End of macro CALLMONITOR
3032					endif 
3032					FORTH_RSP_NEXT 
3032 cd c6 1b			call macro_forth_rsp_next 
3035				endm 
# End of macro FORTH_RSP_NEXT
3035					if DEBUG_FORTH_WORDS 
3035						DMARK "DO3" 
3035 f5				push af  
3036 3a 4a 30			ld a, (.dmark)  
3039 32 71 ee			ld (debug_mark),a  
303c 3a 4b 30			ld a, (.dmark+1)  
303f 32 72 ee			ld (debug_mark+1),a  
3042 3a 4c 30			ld a, (.dmark+2)  
3045 32 73 ee			ld (debug_mark+2),a  
3048 18 03			jr .pastdmark  
304a ..			.dmark: db "DO3"  
304d f1			.pastdmark: pop af  
304e			endm  
# End of macro DMARK
304e						CALLMONITOR 
304e cd ae 15			call break_point_state  
3051				endm  
# End of macro CALLMONITOR
3051					endif 
3051			 
3051					;if DEBUG_FORTH_WORDS 
3051				;		push hl 
3051			;		endif  
3051			 
3051			; get counters from data stack 
3051			 
3051			 
3051					FORTH_DSP_VALUEHL 
3051 cd 16 1e			call macro_dsp_valuehl 
3054				endm 
# End of macro FORTH_DSP_VALUEHL
3054 e5					push hl		 ; hl now has starting counter which needs to be tos 
3055			 
3055					if DEBUG_FORTH_WORDS 
3055						DMARK "DO4" 
3055 f5				push af  
3056 3a 6a 30			ld a, (.dmark)  
3059 32 71 ee			ld (debug_mark),a  
305c 3a 6b 30			ld a, (.dmark+1)  
305f 32 72 ee			ld (debug_mark+1),a  
3062 3a 6c 30			ld a, (.dmark+2)  
3065 32 73 ee			ld (debug_mark+2),a  
3068 18 03			jr .pastdmark  
306a ..			.dmark: db "DO4"  
306d f1			.pastdmark: pop af  
306e			endm  
# End of macro DMARK
306e						CALLMONITOR 
306e cd ae 15			call break_point_state  
3071				endm  
# End of macro CALLMONITOR
3071					endif 
3071					FORTH_DSP_POP 
3071 cd ce 1e			call macro_forth_dsp_pop 
3074				endm 
# End of macro FORTH_DSP_POP
3074			 
3074					if DEBUG_FORTH_WORDS 
3074						DMARK "DO5" 
3074 f5				push af  
3075 3a 89 30			ld a, (.dmark)  
3078 32 71 ee			ld (debug_mark),a  
307b 3a 8a 30			ld a, (.dmark+1)  
307e 32 72 ee			ld (debug_mark+1),a  
3081 3a 8b 30			ld a, (.dmark+2)  
3084 32 73 ee			ld (debug_mark+2),a  
3087 18 03			jr .pastdmark  
3089 ..			.dmark: db "DO5"  
308c f1			.pastdmark: pop af  
308d			endm  
# End of macro DMARK
308d						CALLMONITOR 
308d cd ae 15			call break_point_state  
3090				endm  
# End of macro CALLMONITOR
3090					endif 
3090			 
3090					FORTH_DSP_VALUEHL 
3090 cd 16 1e			call macro_dsp_valuehl 
3093				endm 
# End of macro FORTH_DSP_VALUEHL
3093			;		push hl		 ; hl now has starting limit counter 
3093			 
3093					if DEBUG_FORTH_WORDS 
3093						DMARK "DO6" 
3093 f5				push af  
3094 3a a8 30			ld a, (.dmark)  
3097 32 71 ee			ld (debug_mark),a  
309a 3a a9 30			ld a, (.dmark+1)  
309d 32 72 ee			ld (debug_mark+1),a  
30a0 3a aa 30			ld a, (.dmark+2)  
30a3 32 73 ee			ld (debug_mark+2),a  
30a6 18 03			jr .pastdmark  
30a8 ..			.dmark: db "DO6"  
30ab f1			.pastdmark: pop af  
30ac			endm  
# End of macro DMARK
30ac						CALLMONITOR 
30ac cd ae 15			call break_point_state  
30af				endm  
# End of macro CALLMONITOR
30af					endif 
30af					FORTH_DSP_POP 
30af cd ce 1e			call macro_forth_dsp_pop 
30b2				endm 
# End of macro FORTH_DSP_POP
30b2			 
30b2			; put counters on the loop stack 
30b2			 
30b2			;		pop hl			 ; limit counter 
30b2 d1					pop de			; start counter 
30b3			 
30b3					; push limit counter 
30b3			 
30b3					if DEBUG_FORTH_WORDS 
30b3						DMARK "DO7" 
30b3 f5				push af  
30b4 3a c8 30			ld a, (.dmark)  
30b7 32 71 ee			ld (debug_mark),a  
30ba 3a c9 30			ld a, (.dmark+1)  
30bd 32 72 ee			ld (debug_mark+1),a  
30c0 3a ca 30			ld a, (.dmark+2)  
30c3 32 73 ee			ld (debug_mark+2),a  
30c6 18 03			jr .pastdmark  
30c8 ..			.dmark: db "DO7"  
30cb f1			.pastdmark: pop af  
30cc			endm  
# End of macro DMARK
30cc						CALLMONITOR 
30cc cd ae 15			call break_point_state  
30cf				endm  
# End of macro CALLMONITOR
30cf					endif 
30cf					FORTH_LOOP_NEXT 
30cf cd 47 1e			call macro_forth_loop_next 
30d2				endm 
# End of macro FORTH_LOOP_NEXT
30d2			 
30d2					; push start counter 
30d2			 
30d2 eb					ex de, hl 
30d3					if DEBUG_FORTH_WORDS 
30d3						DMARK "DO7" 
30d3 f5				push af  
30d4 3a e8 30			ld a, (.dmark)  
30d7 32 71 ee			ld (debug_mark),a  
30da 3a e9 30			ld a, (.dmark+1)  
30dd 32 72 ee			ld (debug_mark+1),a  
30e0 3a ea 30			ld a, (.dmark+2)  
30e3 32 73 ee			ld (debug_mark+2),a  
30e6 18 03			jr .pastdmark  
30e8 ..			.dmark: db "DO7"  
30eb f1			.pastdmark: pop af  
30ec			endm  
# End of macro DMARK
30ec						CALLMONITOR 
30ec cd ae 15			call break_point_state  
30ef				endm  
# End of macro CALLMONITOR
30ef					endif 
30ef					FORTH_LOOP_NEXT 
30ef cd 47 1e			call macro_forth_loop_next 
30f2				endm 
# End of macro FORTH_LOOP_NEXT
30f2			 
30f2			 
30f2					; init first round of I counter 
30f2			 
30f2 22 f0 e5				ld (os_current_i), hl 
30f5			 
30f5					if DEBUG_FORTH_WORDS 
30f5						DMARK "DO8" 
30f5 f5				push af  
30f6 3a 0a 31			ld a, (.dmark)  
30f9 32 71 ee			ld (debug_mark),a  
30fc 3a 0b 31			ld a, (.dmark+1)  
30ff 32 72 ee			ld (debug_mark+1),a  
3102 3a 0c 31			ld a, (.dmark+2)  
3105 32 73 ee			ld (debug_mark+2),a  
3108 18 03			jr .pastdmark  
310a ..			.dmark: db "DO8"  
310d f1			.pastdmark: pop af  
310e			endm  
# End of macro DMARK
310e						CALLMONITOR 
310e cd ae 15			call break_point_state  
3111				endm  
# End of macro CALLMONITOR
3111					endif 
3111			 
3111					NEXTW 
3111 c3 c5 1f			jp macro_next 
3114				endm 
# End of macro NEXTW
3114			.LOOP: 
3114				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3114 22				db WORD_SYS_CORE+14             
3115 2c 32			dw .I            
3117 05				db 4 + 1 
3118 .. 00			db "LOOP",0              
311d				endm 
# End of macro CWHEAD
311d			; | LOOP ( -- ) Increment and test loop counter  | DONE 
311d			 
311d				; pop tos as current loop count to hl 
311d			 
311d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
311d			 
311d				FORTH_LOOP_TOS 
311d cd 7a 1e			call macro_forth_loop_tos 
3120				endm 
# End of macro FORTH_LOOP_TOS
3120 e5				push hl 
3121			 
3121					if DEBUG_FORTH_WORDS_KEY 
3121						DMARK "LOP" 
3121 f5				push af  
3122 3a 36 31			ld a, (.dmark)  
3125 32 71 ee			ld (debug_mark),a  
3128 3a 37 31			ld a, (.dmark+1)  
312b 32 72 ee			ld (debug_mark+1),a  
312e 3a 38 31			ld a, (.dmark+2)  
3131 32 73 ee			ld (debug_mark+2),a  
3134 18 03			jr .pastdmark  
3136 ..			.dmark: db "LOP"  
3139 f1			.pastdmark: pop af  
313a			endm  
# End of macro DMARK
313a						CALLMONITOR 
313a cd ae 15			call break_point_state  
313d				endm  
# End of macro CALLMONITOR
313d					endif 
313d				; next item on the stack is the limit. get it 
313d			 
313d			 
313d				FORTH_LOOP_POP 
313d cd 84 1e			call macro_forth_loop_pop 
3140				endm 
# End of macro FORTH_LOOP_POP
3140			 
3140				FORTH_LOOP_TOS 
3140 cd 7a 1e			call macro_forth_loop_tos 
3143				endm 
# End of macro FORTH_LOOP_TOS
3143			 
3143 d1				pop de		 ; de = i, hl = limit 
3144			 
3144					if DEBUG_FORTH_WORDS 
3144						DMARK "LP1" 
3144 f5				push af  
3145 3a 59 31			ld a, (.dmark)  
3148 32 71 ee			ld (debug_mark),a  
314b 3a 5a 31			ld a, (.dmark+1)  
314e 32 72 ee			ld (debug_mark+1),a  
3151 3a 5b 31			ld a, (.dmark+2)  
3154 32 73 ee			ld (debug_mark+2),a  
3157 18 03			jr .pastdmark  
3159 ..			.dmark: db "LP1"  
315c f1			.pastdmark: pop af  
315d			endm  
# End of macro DMARK
315d						CALLMONITOR 
315d cd ae 15			call break_point_state  
3160				endm  
# End of macro CALLMONITOR
3160					endif 
3160			 
3160				; go back to previous word 
3160			 
3160 d5				push de    ; save I for inc later 
3161			 
3161			 
3161				; get limit 
3161				;  is I at limit? 
3161			 
3161			 
3161					if DEBUG_FORTH_WORDS 
3161						DMARK "LP1" 
3161 f5				push af  
3162 3a 76 31			ld a, (.dmark)  
3165 32 71 ee			ld (debug_mark),a  
3168 3a 77 31			ld a, (.dmark+1)  
316b 32 72 ee			ld (debug_mark+1),a  
316e 3a 78 31			ld a, (.dmark+2)  
3171 32 73 ee			ld (debug_mark+2),a  
3174 18 03			jr .pastdmark  
3176 ..			.dmark: db "LP1"  
3179 f1			.pastdmark: pop af  
317a			endm  
# End of macro DMARK
317a						CALLMONITOR 
317a cd ae 15			call break_point_state  
317d				endm  
# End of macro CALLMONITOR
317d					endif 
317d			 
317d ed 52			sbc hl, de 
317f			 
317f			 
317f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
317f			 
317f 20 26				jr nz, .loopnotdone 
3181			 
3181 e1				pop hl   ; get rid of saved I 
3182				FORTH_LOOP_POP     ; get rid of limit 
3182 cd 84 1e			call macro_forth_loop_pop 
3185				endm 
# End of macro FORTH_LOOP_POP
3185			 
3185				FORTH_RSP_POP     ; get rid of DO ptr 
3185 cd e7 1b			call macro_forth_rsp_pop 
3188				endm 
# End of macro FORTH_RSP_POP
3188			 
3188			if DEBUG_FORTH_WORDS 
3188						DMARK "LP>" 
3188 f5				push af  
3189 3a 9d 31			ld a, (.dmark)  
318c 32 71 ee			ld (debug_mark),a  
318f 3a 9e 31			ld a, (.dmark+1)  
3192 32 72 ee			ld (debug_mark+1),a  
3195 3a 9f 31			ld a, (.dmark+2)  
3198 32 73 ee			ld (debug_mark+2),a  
319b 18 03			jr .pastdmark  
319d ..			.dmark: db "LP>"  
31a0 f1			.pastdmark: pop af  
31a1			endm  
# End of macro DMARK
31a1				CALLMONITOR 
31a1 cd ae 15			call break_point_state  
31a4				endm  
# End of macro CALLMONITOR
31a4			endif 
31a4			 
31a4					NEXTW 
31a4 c3 c5 1f			jp macro_next 
31a7				endm 
# End of macro NEXTW
31a7				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
31a7			 
31a7			.loopnotdone: 
31a7			 
31a7 e1				pop hl    ; get I 
31a8 23				inc hl 
31a9			 
31a9			   	; save new I 
31a9			 
31a9			 
31a9					; set I counter 
31a9			 
31a9 22 f0 e5				ld (os_current_i), hl 
31ac			 
31ac					if DEBUG_FORTH_WORDS 
31ac						DMARK "LPN" 
31ac f5				push af  
31ad 3a c1 31			ld a, (.dmark)  
31b0 32 71 ee			ld (debug_mark),a  
31b3 3a c2 31			ld a, (.dmark+1)  
31b6 32 72 ee			ld (debug_mark+1),a  
31b9 3a c3 31			ld a, (.dmark+2)  
31bc 32 73 ee			ld (debug_mark+2),a  
31bf 18 03			jr .pastdmark  
31c1 ..			.dmark: db "LPN"  
31c4 f1			.pastdmark: pop af  
31c5			endm  
# End of macro DMARK
31c5					CALLMONITOR 
31c5 cd ae 15			call break_point_state  
31c8				endm  
# End of macro CALLMONITOR
31c8					endif 
31c8					 
31c8				FORTH_LOOP_NEXT 
31c8 cd 47 1e			call macro_forth_loop_next 
31cb				endm 
# End of macro FORTH_LOOP_NEXT
31cb			 
31cb			 
31cb					if DEBUG_FORTH_WORDS 
31cb eb						ex de,hl 
31cc					endif 
31cc			 
31cc			;	; get DO ptr 
31cc			; 
31cc					if DEBUG_FORTH_WORDS 
31cc						DMARK "LP7" 
31cc f5				push af  
31cd 3a e1 31			ld a, (.dmark)  
31d0 32 71 ee			ld (debug_mark),a  
31d3 3a e2 31			ld a, (.dmark+1)  
31d6 32 72 ee			ld (debug_mark+1),a  
31d9 3a e3 31			ld a, (.dmark+2)  
31dc 32 73 ee			ld (debug_mark+2),a  
31df 18 03			jr .pastdmark  
31e1 ..			.dmark: db "LP7"  
31e4 f1			.pastdmark: pop af  
31e5			endm  
# End of macro DMARK
31e5					CALLMONITOR 
31e5 cd ae 15			call break_point_state  
31e8				endm  
# End of macro CALLMONITOR
31e8					endif 
31e8				FORTH_RSP_TOS 
31e8 cd dd 1b			call macro_forth_rsp_tos 
31eb				endm 
# End of macro FORTH_RSP_TOS
31eb			 
31eb					if DEBUG_FORTH_WORDS 
31eb						DMARK "LP8" 
31eb f5				push af  
31ec 3a 00 32			ld a, (.dmark)  
31ef 32 71 ee			ld (debug_mark),a  
31f2 3a 01 32			ld a, (.dmark+1)  
31f5 32 72 ee			ld (debug_mark+1),a  
31f8 3a 02 32			ld a, (.dmark+2)  
31fb 32 73 ee			ld (debug_mark+2),a  
31fe 18 03			jr .pastdmark  
3200 ..			.dmark: db "LP8"  
3203 f1			.pastdmark: pop af  
3204			endm  
# End of macro DMARK
3204					CALLMONITOR 
3204 cd ae 15			call break_point_state  
3207				endm  
# End of macro CALLMONITOR
3207					endif 
3207				;push hl 
3207			 
3207				; not going to DO any more 
3207				; get rid of the RSP pointer as DO will add it back in 
3207				;FORTH_RSP_POP 
3207				;pop hl 
3207			 
3207				;ld hl,(cli_ret_sp) 
3207				;ld e, (hl) 
3207				;inc hl 
3207				;ld d, (hl) 
3207				;ex de,hl 
3207 22 cc e5			ld (os_tok_ptr), hl 
320a					if DEBUG_FORTH_WORDS 
320a						DMARK "LP<" 
320a f5				push af  
320b 3a 1f 32			ld a, (.dmark)  
320e 32 71 ee			ld (debug_mark),a  
3211 3a 20 32			ld a, (.dmark+1)  
3214 32 72 ee			ld (debug_mark+1),a  
3217 3a 21 32			ld a, (.dmark+2)  
321a 32 73 ee			ld (debug_mark+2),a  
321d 18 03			jr .pastdmark  
321f ..			.dmark: db "LP<"  
3222 f1			.pastdmark: pop af  
3223			endm  
# End of macro DMARK
3223					CALLMONITOR 
3223 cd ae 15			call break_point_state  
3226				endm  
# End of macro CALLMONITOR
3226				endif 
3226 c3 56 20			jp exec1 
3229			 
3229					 
3229			 
3229			 
3229					NEXTW 
3229 c3 c5 1f			jp macro_next 
322c				endm 
# End of macro NEXTW
322c			.I:  
322c			 
322c				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
322c 5e				db WORD_SYS_CORE+74             
322d 57 32			dw .DLOOP            
322f 02				db 1 + 1 
3230 .. 00			db "I",0              
3232				endm 
# End of macro CWHEAD
3232			; | I ( -- ) Current loop counter | DONE 
3232					if DEBUG_FORTH_WORDS_KEY 
3232						DMARK "I.." 
3232 f5				push af  
3233 3a 47 32			ld a, (.dmark)  
3236 32 71 ee			ld (debug_mark),a  
3239 3a 48 32			ld a, (.dmark+1)  
323c 32 72 ee			ld (debug_mark+1),a  
323f 3a 49 32			ld a, (.dmark+2)  
3242 32 73 ee			ld (debug_mark+2),a  
3245 18 03			jr .pastdmark  
3247 ..			.dmark: db "I.."  
324a f1			.pastdmark: pop af  
324b			endm  
# End of macro DMARK
324b						CALLMONITOR 
324b cd ae 15			call break_point_state  
324e				endm  
# End of macro CALLMONITOR
324e					endif 
324e			 
324e 2a f0 e5				ld hl,(os_current_i) 
3251 cd 1f 1c				call forth_push_numhl 
3254			 
3254					NEXTW 
3254 c3 c5 1f			jp macro_next 
3257				endm 
# End of macro NEXTW
3257			.DLOOP: 
3257				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3257 5f				db WORD_SYS_CORE+75             
3258 38 33			dw .REPEAT            
325a 06				db 5 + 1 
325b .. 00			db "-LOOP",0              
3261				endm 
# End of macro CWHEAD
3261			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3261				; pop tos as current loop count to hl 
3261					if DEBUG_FORTH_WORDS_KEY 
3261						DMARK "-LP" 
3261 f5				push af  
3262 3a 76 32			ld a, (.dmark)  
3265 32 71 ee			ld (debug_mark),a  
3268 3a 77 32			ld a, (.dmark+1)  
326b 32 72 ee			ld (debug_mark+1),a  
326e 3a 78 32			ld a, (.dmark+2)  
3271 32 73 ee			ld (debug_mark+2),a  
3274 18 03			jr .pastdmark  
3276 ..			.dmark: db "-LP"  
3279 f1			.pastdmark: pop af  
327a			endm  
# End of macro DMARK
327a						CALLMONITOR 
327a cd ae 15			call break_point_state  
327d				endm  
# End of macro CALLMONITOR
327d					endif 
327d			 
327d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
327d			 
327d				FORTH_LOOP_TOS 
327d cd 7a 1e			call macro_forth_loop_tos 
3280				endm 
# End of macro FORTH_LOOP_TOS
3280 e5				push hl 
3281			 
3281					if DEBUG_FORTH_WORDS 
3281						DMARK "-LP" 
3281 f5				push af  
3282 3a 96 32			ld a, (.dmark)  
3285 32 71 ee			ld (debug_mark),a  
3288 3a 97 32			ld a, (.dmark+1)  
328b 32 72 ee			ld (debug_mark+1),a  
328e 3a 98 32			ld a, (.dmark+2)  
3291 32 73 ee			ld (debug_mark+2),a  
3294 18 03			jr .pastdmark  
3296 ..			.dmark: db "-LP"  
3299 f1			.pastdmark: pop af  
329a			endm  
# End of macro DMARK
329a						CALLMONITOR 
329a cd ae 15			call break_point_state  
329d				endm  
# End of macro CALLMONITOR
329d					endif 
329d				; next item on the stack is the limit. get it 
329d			 
329d			 
329d				FORTH_LOOP_POP 
329d cd 84 1e			call macro_forth_loop_pop 
32a0				endm 
# End of macro FORTH_LOOP_POP
32a0			 
32a0				FORTH_LOOP_TOS 
32a0 cd 7a 1e			call macro_forth_loop_tos 
32a3				endm 
# End of macro FORTH_LOOP_TOS
32a3			 
32a3 d1				pop de		 ; de = i, hl = limit 
32a4			 
32a4					if DEBUG_FORTH_WORDS 
32a4						DMARK "-L1" 
32a4 f5				push af  
32a5 3a b9 32			ld a, (.dmark)  
32a8 32 71 ee			ld (debug_mark),a  
32ab 3a ba 32			ld a, (.dmark+1)  
32ae 32 72 ee			ld (debug_mark+1),a  
32b1 3a bb 32			ld a, (.dmark+2)  
32b4 32 73 ee			ld (debug_mark+2),a  
32b7 18 03			jr .pastdmark  
32b9 ..			.dmark: db "-L1"  
32bc f1			.pastdmark: pop af  
32bd			endm  
# End of macro DMARK
32bd						CALLMONITOR 
32bd cd ae 15			call break_point_state  
32c0				endm  
# End of macro CALLMONITOR
32c0					endif 
32c0			 
32c0				; go back to previous word 
32c0			 
32c0 d5				push de    ; save I for inc later 
32c1			 
32c1			 
32c1				; get limit 
32c1				;  is I at limit? 
32c1			 
32c1			 
32c1					if DEBUG_FORTH_WORDS 
32c1						DMARK "-L1" 
32c1 f5				push af  
32c2 3a d6 32			ld a, (.dmark)  
32c5 32 71 ee			ld (debug_mark),a  
32c8 3a d7 32			ld a, (.dmark+1)  
32cb 32 72 ee			ld (debug_mark+1),a  
32ce 3a d8 32			ld a, (.dmark+2)  
32d1 32 73 ee			ld (debug_mark+2),a  
32d4 18 03			jr .pastdmark  
32d6 ..			.dmark: db "-L1"  
32d9 f1			.pastdmark: pop af  
32da			endm  
# End of macro DMARK
32da						CALLMONITOR 
32da cd ae 15			call break_point_state  
32dd				endm  
# End of macro CALLMONITOR
32dd					endif 
32dd			 
32dd ed 52			sbc hl, de 
32df			 
32df			 
32df				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
32df			 
32df 20 26				jr nz, .mloopnotdone 
32e1			 
32e1 e1				pop hl   ; get rid of saved I 
32e2				FORTH_LOOP_POP     ; get rid of limit 
32e2 cd 84 1e			call macro_forth_loop_pop 
32e5				endm 
# End of macro FORTH_LOOP_POP
32e5			 
32e5				FORTH_RSP_POP     ; get rid of DO ptr 
32e5 cd e7 1b			call macro_forth_rsp_pop 
32e8				endm 
# End of macro FORTH_RSP_POP
32e8			 
32e8			if DEBUG_FORTH_WORDS 
32e8						DMARK "-L>" 
32e8 f5				push af  
32e9 3a fd 32			ld a, (.dmark)  
32ec 32 71 ee			ld (debug_mark),a  
32ef 3a fe 32			ld a, (.dmark+1)  
32f2 32 72 ee			ld (debug_mark+1),a  
32f5 3a ff 32			ld a, (.dmark+2)  
32f8 32 73 ee			ld (debug_mark+2),a  
32fb 18 03			jr .pastdmark  
32fd ..			.dmark: db "-L>"  
3300 f1			.pastdmark: pop af  
3301			endm  
# End of macro DMARK
3301				CALLMONITOR 
3301 cd ae 15			call break_point_state  
3304				endm  
# End of macro CALLMONITOR
3304			endif 
3304			 
3304					NEXTW 
3304 c3 c5 1f			jp macro_next 
3307				endm 
# End of macro NEXTW
3307				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3307			 
3307			.mloopnotdone: 
3307			 
3307 e1				pop hl    ; get I 
3308 2b				dec hl 
3309			 
3309			   	; save new I 
3309			 
3309			 
3309					; set I counter 
3309			 
3309 22 f0 e5				ld (os_current_i), hl 
330c			 
330c					 
330c				FORTH_LOOP_NEXT 
330c cd 47 1e			call macro_forth_loop_next 
330f				endm 
# End of macro FORTH_LOOP_NEXT
330f			 
330f			 
330f					if DEBUG_FORTH_WORDS 
330f eb						ex de,hl 
3310					endif 
3310			 
3310			;	; get DO ptr 
3310			; 
3310				FORTH_RSP_TOS 
3310 cd dd 1b			call macro_forth_rsp_tos 
3313				endm 
# End of macro FORTH_RSP_TOS
3313			 
3313				;push hl 
3313			 
3313				; not going to DO any more 
3313				; get rid of the RSP pointer as DO will add it back in 
3313				;FORTH_RSP_POP 
3313				;pop hl 
3313			 
3313			 
3313 22 cc e5			ld (os_tok_ptr), hl 
3316					if DEBUG_FORTH_WORDS 
3316						DMARK "-L<" 
3316 f5				push af  
3317 3a 2b 33			ld a, (.dmark)  
331a 32 71 ee			ld (debug_mark),a  
331d 3a 2c 33			ld a, (.dmark+1)  
3320 32 72 ee			ld (debug_mark+1),a  
3323 3a 2d 33			ld a, (.dmark+2)  
3326 32 73 ee			ld (debug_mark+2),a  
3329 18 03			jr .pastdmark  
332b ..			.dmark: db "-L<"  
332e f1			.pastdmark: pop af  
332f			endm  
# End of macro DMARK
332f					CALLMONITOR 
332f cd ae 15			call break_point_state  
3332				endm  
# End of macro CALLMONITOR
3332				endif 
3332 c3 56 20			jp exec1 
3335			 
3335					 
3335			 
3335			 
3335			 
3335				NEXTW 
3335 c3 c5 1f			jp macro_next 
3338				endm 
# End of macro NEXTW
3338			 
3338			 
3338			 
3338			 
3338			.REPEAT: 
3338				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3338 71				db WORD_SYS_CORE+93             
3339 8b 33			dw .UNTIL            
333b 06				db 5 + 1 
333c .. 00			db "REPEAT",0              
3343				endm 
# End of macro CWHEAD
3343			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3343			;  push pc to rsp stack past the REPEAT 
3343					if DEBUG_FORTH_WORDS_KEY 
3343						DMARK "REP" 
3343 f5				push af  
3344 3a 58 33			ld a, (.dmark)  
3347 32 71 ee			ld (debug_mark),a  
334a 3a 59 33			ld a, (.dmark+1)  
334d 32 72 ee			ld (debug_mark+1),a  
3350 3a 5a 33			ld a, (.dmark+2)  
3353 32 73 ee			ld (debug_mark+2),a  
3356 18 03			jr .pastdmark  
3358 ..			.dmark: db "REP"  
335b f1			.pastdmark: pop af  
335c			endm  
# End of macro DMARK
335c						CALLMONITOR 
335c cd ae 15			call break_point_state  
335f				endm  
# End of macro CALLMONITOR
335f					endif 
335f			 
335f 2a cc e5				ld hl, (os_tok_ptr) 
3362 23					inc hl   ; R 
3363 23					inc hl  ; E 
3364 23					inc hl   ; P 
3365 23					inc hl   ; E 
3366 23					inc hl   ; A 
3367 23					inc hl   ; T 
3368 23					inc hl   ; zero 
3369					FORTH_RSP_NEXT 
3369 cd c6 1b			call macro_forth_rsp_next 
336c				endm 
# End of macro FORTH_RSP_NEXT
336c			 
336c			 
336c					if DEBUG_FORTH_WORDS 
336c						DMARK "REP" 
336c f5				push af  
336d 3a 81 33			ld a, (.dmark)  
3370 32 71 ee			ld (debug_mark),a  
3373 3a 82 33			ld a, (.dmark+1)  
3376 32 72 ee			ld (debug_mark+1),a  
3379 3a 83 33			ld a, (.dmark+2)  
337c 32 73 ee			ld (debug_mark+2),a  
337f 18 03			jr .pastdmark  
3381 ..			.dmark: db "REP"  
3384 f1			.pastdmark: pop af  
3385			endm  
# End of macro DMARK
3385						;pop bc    ; TODO BUG ?????? what is this for???? 
3385						CALLMONITOR 
3385 cd ae 15			call break_point_state  
3388				endm  
# End of macro CALLMONITOR
3388					endif 
3388			 
3388					NEXTW 
3388 c3 c5 1f			jp macro_next 
338b				endm 
# End of macro NEXTW
338b			;	       NEXTW 
338b			 
338b			.UNTIL: 
338b				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
338b 72				db WORD_SYS_CORE+94             
338c 22 34			dw .ENDFLOW            
338e 06				db 5 + 1 
338f .. 00			db "UNTIL",0              
3395				endm 
# End of macro CWHEAD
3395			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3395			 
3395				; pop tos as check 
3395			 
3395				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3395			 
3395				FORTH_DSP_VALUEHL 
3395 cd 16 1e			call macro_dsp_valuehl 
3398				endm 
# End of macro FORTH_DSP_VALUEHL
3398			 
3398					if DEBUG_FORTH_WORDS_KEY 
3398						DMARK "UNT" 
3398 f5				push af  
3399 3a ad 33			ld a, (.dmark)  
339c 32 71 ee			ld (debug_mark),a  
339f 3a ae 33			ld a, (.dmark+1)  
33a2 32 72 ee			ld (debug_mark+1),a  
33a5 3a af 33			ld a, (.dmark+2)  
33a8 32 73 ee			ld (debug_mark+2),a  
33ab 18 03			jr .pastdmark  
33ad ..			.dmark: db "UNT"  
33b0 f1			.pastdmark: pop af  
33b1			endm  
# End of macro DMARK
33b1						CALLMONITOR 
33b1 cd ae 15			call break_point_state  
33b4				endm  
# End of macro CALLMONITOR
33b4					endif 
33b4			 
33b4			;	push hl 
33b4				FORTH_DSP_POP 
33b4 cd ce 1e			call macro_forth_dsp_pop 
33b7				endm 
# End of macro FORTH_DSP_POP
33b7			 
33b7			;	pop hl 
33b7			 
33b7				; test if true 
33b7			 
33b7 cd d6 0d			call ishlzero 
33ba			;	ld a,l 
33ba			;	add h 
33ba			; 
33ba			;	cp 0 
33ba			 
33ba 20 3e			jr nz, .untilnotdone 
33bc			 
33bc					if DEBUG_FORTH_WORDS 
33bc						DMARK "UNf" 
33bc f5				push af  
33bd 3a d1 33			ld a, (.dmark)  
33c0 32 71 ee			ld (debug_mark),a  
33c3 3a d2 33			ld a, (.dmark+1)  
33c6 32 72 ee			ld (debug_mark+1),a  
33c9 3a d3 33			ld a, (.dmark+2)  
33cc 32 73 ee			ld (debug_mark+2),a  
33cf 18 03			jr .pastdmark  
33d1 ..			.dmark: db "UNf"  
33d4 f1			.pastdmark: pop af  
33d5			endm  
# End of macro DMARK
33d5						CALLMONITOR 
33d5 cd ae 15			call break_point_state  
33d8				endm  
# End of macro CALLMONITOR
33d8					endif 
33d8			 
33d8			 
33d8			 
33d8				FORTH_RSP_POP     ; get rid of DO ptr 
33d8 cd e7 1b			call macro_forth_rsp_pop 
33db				endm 
# End of macro FORTH_RSP_POP
33db			 
33db			if DEBUG_FORTH_WORDS 
33db						DMARK "UN>" 
33db f5				push af  
33dc 3a f0 33			ld a, (.dmark)  
33df 32 71 ee			ld (debug_mark),a  
33e2 3a f1 33			ld a, (.dmark+1)  
33e5 32 72 ee			ld (debug_mark+1),a  
33e8 3a f2 33			ld a, (.dmark+2)  
33eb 32 73 ee			ld (debug_mark+2),a  
33ee 18 03			jr .pastdmark  
33f0 ..			.dmark: db "UN>"  
33f3 f1			.pastdmark: pop af  
33f4			endm  
# End of macro DMARK
33f4				CALLMONITOR 
33f4 cd ae 15			call break_point_state  
33f7				endm  
# End of macro CALLMONITOR
33f7			endif 
33f7			 
33f7					NEXTW 
33f7 c3 c5 1f			jp macro_next 
33fa				endm 
# End of macro NEXTW
33fa				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
33fa			 
33fa			.untilnotdone: 
33fa			 
33fa			 
33fa			;	; get DO ptr 
33fa			; 
33fa				FORTH_RSP_TOS 
33fa cd dd 1b			call macro_forth_rsp_tos 
33fd				endm 
# End of macro FORTH_RSP_TOS
33fd			 
33fd				;push hl 
33fd			 
33fd				; not going to DO any more 
33fd				; get rid of the RSP pointer as DO will add it back in 
33fd				;FORTH_RSP_POP 
33fd				;pop hl 
33fd			 
33fd			 
33fd 22 cc e5			ld (os_tok_ptr), hl 
3400					if DEBUG_FORTH_WORDS 
3400						DMARK "UN<" 
3400 f5				push af  
3401 3a 15 34			ld a, (.dmark)  
3404 32 71 ee			ld (debug_mark),a  
3407 3a 16 34			ld a, (.dmark+1)  
340a 32 72 ee			ld (debug_mark+1),a  
340d 3a 17 34			ld a, (.dmark+2)  
3410 32 73 ee			ld (debug_mark+2),a  
3413 18 03			jr .pastdmark  
3415 ..			.dmark: db "UN<"  
3418 f1			.pastdmark: pop af  
3419			endm  
# End of macro DMARK
3419					CALLMONITOR 
3419 cd ae 15			call break_point_state  
341c				endm  
# End of macro CALLMONITOR
341c				endif 
341c c3 56 20			jp exec1 
341f			 
341f					 
341f			 
341f			 
341f					NEXTW 
341f c3 c5 1f			jp macro_next 
3422				endm 
# End of macro NEXTW
3422			 
3422			 
3422			.ENDFLOW: 
3422			 
3422			; eof 
3422			 
# End of file forth_words_flow.asm
3422			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3422			include "forth_words_logic.asm" 
3422			 
3422			; | ## Logic Words 
3422			 
3422			.NOT: 
3422				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3422 2d				db WORD_SYS_CORE+25             
3423 6a 34			dw .IS            
3425 04				db 3 + 1 
3426 .. 00			db "NOT",0              
342a				endm 
# End of macro CWHEAD
342a			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
342a					if DEBUG_FORTH_WORDS_KEY 
342a						DMARK "NOT" 
342a f5				push af  
342b 3a 3f 34			ld a, (.dmark)  
342e 32 71 ee			ld (debug_mark),a  
3431 3a 40 34			ld a, (.dmark+1)  
3434 32 72 ee			ld (debug_mark+1),a  
3437 3a 41 34			ld a, (.dmark+2)  
343a 32 73 ee			ld (debug_mark+2),a  
343d 18 03			jr .pastdmark  
343f ..			.dmark: db "NOT"  
3442 f1			.pastdmark: pop af  
3443			endm  
# End of macro DMARK
3443						CALLMONITOR 
3443 cd ae 15			call break_point_state  
3446				endm  
# End of macro CALLMONITOR
3446					endif 
3446					FORTH_DSP 
3446 cd dc 1d			call macro_forth_dsp 
3449				endm 
# End of macro FORTH_DSP
3449 7e					ld a,(hl)	; get type of value on TOS 
344a fe 02				cp DS_TYPE_INUM  
344c 28 03				jr z, .noti 
344e					NEXTW 
344e c3 c5 1f			jp macro_next 
3451				endm 
# End of macro NEXTW
3451			.noti:          FORTH_DSP_VALUEHL 
3451 cd 16 1e			call macro_dsp_valuehl 
3454				endm 
# End of macro FORTH_DSP_VALUEHL
3454			;		push hl 
3454					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3454 cd ce 1e			call macro_forth_dsp_pop 
3457				endm 
# End of macro FORTH_DSP_POP
3457			;		pop hl 
3457 3e 00				ld a,0 
3459 bd					cp l 
345a 28 04				jr z, .not2t 
345c 2e 00				ld l, 0 
345e 18 02				jr .notip 
3460			 
3460 2e ff		.not2t:		ld l, 255 
3462			 
3462 26 00		.notip:		ld h, 0	 
3464			 
3464 cd 1f 1c				call forth_push_numhl 
3467					NEXTW 
3467 c3 c5 1f			jp macro_next 
346a				endm 
# End of macro NEXTW
346a			 
346a			.IS: 
346a				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
346a 2d				db WORD_SYS_CORE+25             
346b 90 34			dw .LZERO            
346d 03				db 2 + 1 
346e .. 00			db "IS",0              
3471				endm 
# End of macro CWHEAD
3471			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3471					if DEBUG_FORTH_WORDS_KEY 
3471						DMARK "IS." 
3471 f5				push af  
3472 3a 86 34			ld a, (.dmark)  
3475 32 71 ee			ld (debug_mark),a  
3478 3a 87 34			ld a, (.dmark+1)  
347b 32 72 ee			ld (debug_mark+1),a  
347e 3a 88 34			ld a, (.dmark+2)  
3481 32 73 ee			ld (debug_mark+2),a  
3484 18 03			jr .pastdmark  
3486 ..			.dmark: db "IS."  
3489 f1			.pastdmark: pop af  
348a			endm  
# End of macro DMARK
348a						CALLMONITOR 
348a cd ae 15			call break_point_state  
348d				endm  
# End of macro CALLMONITOR
348d					endif 
348d					NEXTW 
348d c3 c5 1f			jp macro_next 
3490				endm 
# End of macro NEXTW
3490			.LZERO: 
3490				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3490 2d				db WORD_SYS_CORE+25             
3491 9a 34			dw .TZERO            
3493 03				db 2 + 1 
3494 .. 00			db "0<",0              
3497				endm 
# End of macro CWHEAD
3497			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3497					NEXTW 
3497 c3 c5 1f			jp macro_next 
349a				endm 
# End of macro NEXTW
349a			.TZERO: 
349a				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
349a 2e				db WORD_SYS_CORE+26             
349b e1 34			dw .LESS            
349d 03				db 2 + 1 
349e .. 00			db "0=",0              
34a1				endm 
# End of macro CWHEAD
34a1			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
34a1				; TODO add floating point number detection 
34a1					;v5 FORTH_DSP_VALUE 
34a1					if DEBUG_FORTH_WORDS_KEY 
34a1						DMARK "0=." 
34a1 f5				push af  
34a2 3a b6 34			ld a, (.dmark)  
34a5 32 71 ee			ld (debug_mark),a  
34a8 3a b7 34			ld a, (.dmark+1)  
34ab 32 72 ee			ld (debug_mark+1),a  
34ae 3a b8 34			ld a, (.dmark+2)  
34b1 32 73 ee			ld (debug_mark+2),a  
34b4 18 03			jr .pastdmark  
34b6 ..			.dmark: db "0=."  
34b9 f1			.pastdmark: pop af  
34ba			endm  
# End of macro DMARK
34ba						CALLMONITOR 
34ba cd ae 15			call break_point_state  
34bd				endm  
# End of macro CALLMONITOR
34bd					endif 
34bd					FORTH_DSP 
34bd cd dc 1d			call macro_forth_dsp 
34c0				endm 
# End of macro FORTH_DSP
34c0 7e					ld a,(hl)	; get type of value on TOS 
34c1 fe 02				cp DS_TYPE_INUM  
34c3 28 00				jr z, .tz_inum 
34c5			 
34c5				if FORTH_ENABLE_FLOATMATH 
34c5					jr .tz_done 
34c5			 
34c5				endif 
34c5					 
34c5			 
34c5			.tz_inum: 
34c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34c5 cd 16 1e			call macro_dsp_valuehl 
34c8				endm 
# End of macro FORTH_DSP_VALUEHL
34c8			 
34c8			;		push hl 
34c8			 
34c8					; destroy value TOS 
34c8			 
34c8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34c8 cd ce 1e			call macro_forth_dsp_pop 
34cb				endm 
# End of macro FORTH_DSP_POP
34cb			 
34cb			;		pop hl 
34cb			 
34cb 3e 00				ld a,0 
34cd			 
34cd bd					cp l 
34ce 20 08				jr nz, .tz_notzero 
34d0			 
34d0 bc					cp h 
34d1			 
34d1 20 05				jr nz, .tz_notzero 
34d3			 
34d3			 
34d3 21 01 00				ld hl, FORTH_TRUE 
34d6 18 03				jr .tz_done 
34d8			 
34d8 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
34db			 
34db					; push value back onto stack for another op etc 
34db			 
34db			.tz_done: 
34db cd 1f 1c				call forth_push_numhl 
34de			 
34de					NEXTW 
34de c3 c5 1f			jp macro_next 
34e1				endm 
# End of macro NEXTW
34e1			.LESS: 
34e1				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
34e1 2f				db WORD_SYS_CORE+27             
34e2 4a 35			dw .GT            
34e4 02				db 1 + 1 
34e5 .. 00			db "<",0              
34e7				endm 
# End of macro CWHEAD
34e7			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
34e7				; TODO add floating point number detection 
34e7					if DEBUG_FORTH_WORDS_KEY 
34e7						DMARK "LES" 
34e7 f5				push af  
34e8 3a fc 34			ld a, (.dmark)  
34eb 32 71 ee			ld (debug_mark),a  
34ee 3a fd 34			ld a, (.dmark+1)  
34f1 32 72 ee			ld (debug_mark+1),a  
34f4 3a fe 34			ld a, (.dmark+2)  
34f7 32 73 ee			ld (debug_mark+2),a  
34fa 18 03			jr .pastdmark  
34fc ..			.dmark: db "LES"  
34ff f1			.pastdmark: pop af  
3500			endm  
# End of macro DMARK
3500						CALLMONITOR 
3500 cd ae 15			call break_point_state  
3503				endm  
# End of macro CALLMONITOR
3503					endif 
3503					FORTH_DSP 
3503 cd dc 1d			call macro_forth_dsp 
3506				endm 
# End of macro FORTH_DSP
3506					;v5 FORTH_DSP_VALUE 
3506 7e					ld a,(hl)	; get type of value on TOS 
3507 fe 02				cp DS_TYPE_INUM  
3509 28 00				jr z, .less_inum 
350b			 
350b				if FORTH_ENABLE_FLOATMATH 
350b					jr .less_done 
350b			 
350b				endif 
350b					 
350b			 
350b			.less_inum: 
350b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
350b cd 16 1e			call macro_dsp_valuehl 
350e				endm 
# End of macro FORTH_DSP_VALUEHL
350e			 
350e e5					push hl  ; u2 
350f			 
350f					; destroy value TOS 
350f			 
350f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
350f cd ce 1e			call macro_forth_dsp_pop 
3512				endm 
# End of macro FORTH_DSP_POP
3512			 
3512			 
3512					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3512 cd 16 1e			call macro_dsp_valuehl 
3515				endm 
# End of macro FORTH_DSP_VALUEHL
3515			 
3515 e5					push hl    ; u1 
3516			 
3516					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3516 cd ce 1e			call macro_forth_dsp_pop 
3519				endm 
# End of macro FORTH_DSP_POP
3519			 
3519			 
3519 b7			 or a      ;clear carry flag 
351a 01 00 00		 ld bc, FORTH_FALSE 
351d e1			  pop hl    ; u1 
351e d1			  pop de    ; u2 
351f ed 52		  sbc hl,de 
3521 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3523			 
3523 01 01 00		 ld bc, FORTH_TRUE 
3526			.lscont:  
3526 c5					push bc 
3527 e1					pop hl 
3528			 
3528					if DEBUG_FORTH_WORDS 
3528						DMARK "LT1" 
3528 f5				push af  
3529 3a 3d 35			ld a, (.dmark)  
352c 32 71 ee			ld (debug_mark),a  
352f 3a 3e 35			ld a, (.dmark+1)  
3532 32 72 ee			ld (debug_mark+1),a  
3535 3a 3f 35			ld a, (.dmark+2)  
3538 32 73 ee			ld (debug_mark+2),a  
353b 18 03			jr .pastdmark  
353d ..			.dmark: db "LT1"  
3540 f1			.pastdmark: pop af  
3541			endm  
# End of macro DMARK
3541						CALLMONITOR 
3541 cd ae 15			call break_point_state  
3544				endm  
# End of macro CALLMONITOR
3544					endif 
3544 cd 1f 1c				call forth_push_numhl 
3547			 
3547					NEXTW 
3547 c3 c5 1f			jp macro_next 
354a				endm 
# End of macro NEXTW
354a			.GT: 
354a				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
354a 30				db WORD_SYS_CORE+28             
354b b3 35			dw .EQUAL            
354d 02				db 1 + 1 
354e .. 00			db ">",0              
3550				endm 
# End of macro CWHEAD
3550			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3550				; TODO add floating point number detection 
3550					if DEBUG_FORTH_WORDS_KEY 
3550						DMARK "GRT" 
3550 f5				push af  
3551 3a 65 35			ld a, (.dmark)  
3554 32 71 ee			ld (debug_mark),a  
3557 3a 66 35			ld a, (.dmark+1)  
355a 32 72 ee			ld (debug_mark+1),a  
355d 3a 67 35			ld a, (.dmark+2)  
3560 32 73 ee			ld (debug_mark+2),a  
3563 18 03			jr .pastdmark  
3565 ..			.dmark: db "GRT"  
3568 f1			.pastdmark: pop af  
3569			endm  
# End of macro DMARK
3569						CALLMONITOR 
3569 cd ae 15			call break_point_state  
356c				endm  
# End of macro CALLMONITOR
356c					endif 
356c					FORTH_DSP 
356c cd dc 1d			call macro_forth_dsp 
356f				endm 
# End of macro FORTH_DSP
356f					;FORTH_DSP_VALUE 
356f 7e					ld a,(hl)	; get type of value on TOS 
3570 fe 02				cp DS_TYPE_INUM  
3572 28 00				jr z, .gt_inum 
3574			 
3574				if FORTH_ENABLE_FLOATMATH 
3574					jr .gt_done 
3574			 
3574				endif 
3574					 
3574			 
3574			.gt_inum: 
3574					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3574 cd 16 1e			call macro_dsp_valuehl 
3577				endm 
# End of macro FORTH_DSP_VALUEHL
3577			 
3577 e5					push hl  ; u2 
3578			 
3578					; destroy value TOS 
3578			 
3578					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3578 cd ce 1e			call macro_forth_dsp_pop 
357b				endm 
# End of macro FORTH_DSP_POP
357b			 
357b			 
357b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
357b cd 16 1e			call macro_dsp_valuehl 
357e				endm 
# End of macro FORTH_DSP_VALUEHL
357e			 
357e e5					push hl    ; u1 
357f			 
357f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
357f cd ce 1e			call macro_forth_dsp_pop 
3582				endm 
# End of macro FORTH_DSP_POP
3582			 
3582			 
3582 b7			 or a      ;clear carry flag 
3583 01 00 00		 ld bc, FORTH_FALSE 
3586 e1			  pop hl    ; u1 
3587 d1			  pop de    ; u2 
3588 ed 52		  sbc hl,de 
358a 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
358c			 
358c 01 01 00		 ld bc, FORTH_TRUE 
358f			.gtcont:  
358f c5					push bc 
3590 e1					pop hl 
3591			 
3591					if DEBUG_FORTH_WORDS 
3591						DMARK "GT1" 
3591 f5				push af  
3592 3a a6 35			ld a, (.dmark)  
3595 32 71 ee			ld (debug_mark),a  
3598 3a a7 35			ld a, (.dmark+1)  
359b 32 72 ee			ld (debug_mark+1),a  
359e 3a a8 35			ld a, (.dmark+2)  
35a1 32 73 ee			ld (debug_mark+2),a  
35a4 18 03			jr .pastdmark  
35a6 ..			.dmark: db "GT1"  
35a9 f1			.pastdmark: pop af  
35aa			endm  
# End of macro DMARK
35aa						CALLMONITOR 
35aa cd ae 15			call break_point_state  
35ad				endm  
# End of macro CALLMONITOR
35ad					endif 
35ad cd 1f 1c				call forth_push_numhl 
35b0			 
35b0					NEXTW 
35b0 c3 c5 1f			jp macro_next 
35b3				endm 
# End of macro NEXTW
35b3			.EQUAL: 
35b3				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
35b3 31				db WORD_SYS_CORE+29             
35b4 1e 36			dw .ENDLOGIC            
35b6 02				db 1 + 1 
35b7 .. 00			db "=",0              
35b9				endm 
# End of macro CWHEAD
35b9			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
35b9				; TODO add floating point number detection 
35b9					if DEBUG_FORTH_WORDS_KEY 
35b9						DMARK "EQ." 
35b9 f5				push af  
35ba 3a ce 35			ld a, (.dmark)  
35bd 32 71 ee			ld (debug_mark),a  
35c0 3a cf 35			ld a, (.dmark+1)  
35c3 32 72 ee			ld (debug_mark+1),a  
35c6 3a d0 35			ld a, (.dmark+2)  
35c9 32 73 ee			ld (debug_mark+2),a  
35cc 18 03			jr .pastdmark  
35ce ..			.dmark: db "EQ."  
35d1 f1			.pastdmark: pop af  
35d2			endm  
# End of macro DMARK
35d2						CALLMONITOR 
35d2 cd ae 15			call break_point_state  
35d5				endm  
# End of macro CALLMONITOR
35d5					endif 
35d5					FORTH_DSP 
35d5 cd dc 1d			call macro_forth_dsp 
35d8				endm 
# End of macro FORTH_DSP
35d8					;v5 FORTH_DSP_VALUE 
35d8 7e					ld a,(hl)	; get type of value on TOS 
35d9 fe 02				cp DS_TYPE_INUM  
35db 28 00				jr z, .eq_inum 
35dd			 
35dd				if FORTH_ENABLE_FLOATMATH 
35dd					jr .eq_done 
35dd			 
35dd				endif 
35dd					 
35dd			 
35dd			.eq_inum: 
35dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35dd cd 16 1e			call macro_dsp_valuehl 
35e0				endm 
# End of macro FORTH_DSP_VALUEHL
35e0			 
35e0 e5					push hl 
35e1			 
35e1					; destroy value TOS 
35e1			 
35e1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35e1 cd ce 1e			call macro_forth_dsp_pop 
35e4				endm 
# End of macro FORTH_DSP_POP
35e4			 
35e4			 
35e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35e4 cd 16 1e			call macro_dsp_valuehl 
35e7				endm 
# End of macro FORTH_DSP_VALUEHL
35e7			 
35e7					; one value on hl get other one back 
35e7			 
35e7 e5					push hl 
35e8			 
35e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35e8 cd ce 1e			call macro_forth_dsp_pop 
35eb				endm 
# End of macro FORTH_DSP_POP
35eb			 
35eb 0e 00				ld c, FORTH_FALSE 
35ed			 
35ed e1					pop hl 
35ee d1					pop de 
35ef			 
35ef 7b					ld a, e 
35f0 bd					cp l 
35f1			 
35f1 20 06				jr nz, .eq_done 
35f3			 
35f3 7a					ld a, d 
35f4 bc					cp h 
35f5			 
35f5 20 02				jr nz, .eq_done 
35f7			 
35f7 0e 01				ld c, FORTH_TRUE 
35f9					 
35f9			 
35f9			 
35f9			.eq_done: 
35f9			 
35f9					; TODO push value back onto stack for another op etc 
35f9			 
35f9 26 00				ld h, 0 
35fb 69					ld l, c 
35fc					if DEBUG_FORTH_WORDS 
35fc						DMARK "EQ1" 
35fc f5				push af  
35fd 3a 11 36			ld a, (.dmark)  
3600 32 71 ee			ld (debug_mark),a  
3603 3a 12 36			ld a, (.dmark+1)  
3606 32 72 ee			ld (debug_mark+1),a  
3609 3a 13 36			ld a, (.dmark+2)  
360c 32 73 ee			ld (debug_mark+2),a  
360f 18 03			jr .pastdmark  
3611 ..			.dmark: db "EQ1"  
3614 f1			.pastdmark: pop af  
3615			endm  
# End of macro DMARK
3615						CALLMONITOR 
3615 cd ae 15			call break_point_state  
3618				endm  
# End of macro CALLMONITOR
3618					endif 
3618 cd 1f 1c				call forth_push_numhl 
361b			 
361b					NEXTW 
361b c3 c5 1f			jp macro_next 
361e				endm 
# End of macro NEXTW
361e			 
361e			 
361e			.ENDLOGIC: 
361e			; eof 
361e			 
361e			 
# End of file forth_words_logic.asm
361e			include "forth_words_maths.asm" 
361e			 
361e			; | ## Maths Words 
361e			 
361e			.PLUS:	 
361e				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
361e 15				db WORD_SYS_CORE+1             
361f 7c 36			dw .NEG            
3621 02				db 1 + 1 
3622 .. 00			db "+",0              
3624				endm 
# End of macro CWHEAD
3624			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3624					if DEBUG_FORTH_WORDS_KEY 
3624						DMARK "PLU" 
3624 f5				push af  
3625 3a 39 36			ld a, (.dmark)  
3628 32 71 ee			ld (debug_mark),a  
362b 3a 3a 36			ld a, (.dmark+1)  
362e 32 72 ee			ld (debug_mark+1),a  
3631 3a 3b 36			ld a, (.dmark+2)  
3634 32 73 ee			ld (debug_mark+2),a  
3637 18 03			jr .pastdmark  
3639 ..			.dmark: db "PLU"  
363c f1			.pastdmark: pop af  
363d			endm  
# End of macro DMARK
363d						CALLMONITOR 
363d cd ae 15			call break_point_state  
3640				endm  
# End of macro CALLMONITOR
3640					endif 
3640					; add top two values and push back result 
3640			 
3640					;for v5 FORTH_DSP_VALUE 
3640					FORTH_DSP 
3640 cd dc 1d			call macro_forth_dsp 
3643				endm 
# End of macro FORTH_DSP
3643 7e					ld a,(hl)	; get type of value on TOS 
3644 fe 02				cp DS_TYPE_INUM  
3646 28 03				jr z, .dot_inum 
3648			 
3648					NEXTW 
3648 c3 c5 1f			jp macro_next 
364b				endm 
# End of macro NEXTW
364b			 
364b			; float maths 
364b			 
364b				if FORTH_ENABLE_FLOATMATH 
364b						inc hl      ; now at start of numeric as string 
364b			 
364b					if DEBUG_FORTH_MATHS 
364b						DMARK "ADD" 
364b				CALLMONITOR 
364b					endif 
364b			 
364b					;ld ix, hl 
364b					call CON 
364b			 
364b			 
364b					push hl 
364b					 
364b					 
364b			 
364b						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
364b			 
364b					; get next number 
364b			 
364b						FORTH_DSP_VALUE 
364b			 
364b						inc hl      ; now at start of numeric as string 
364b			 
364b					;ld ix, hl 
364b					call CON 
364b			 
364b					push hl 
364b			 
364b			 
364b						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
364b			 
364b						; TODO do add 
364b			 
364b						call IADD 
364b			 
364b						; TODO get result back as ascii 
364b			 
364b						; TODO push result  
364b			 
364b			 
364b			 
364b						jr .dot_done 
364b				endif 
364b			 
364b			.dot_inum: 
364b			 
364b			 
364b					if DEBUG_FORTH_DOT 
364b						DMARK "+IT" 
364b f5				push af  
364c 3a 60 36			ld a, (.dmark)  
364f 32 71 ee			ld (debug_mark),a  
3652 3a 61 36			ld a, (.dmark+1)  
3655 32 72 ee			ld (debug_mark+1),a  
3658 3a 62 36			ld a, (.dmark+2)  
365b 32 73 ee			ld (debug_mark+2),a  
365e 18 03			jr .pastdmark  
3660 ..			.dmark: db "+IT"  
3663 f1			.pastdmark: pop af  
3664			endm  
# End of macro DMARK
3664				CALLMONITOR 
3664 cd ae 15			call break_point_state  
3667				endm  
# End of macro CALLMONITOR
3667					endif 
3667			 
3667					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3667 cd 16 1e			call macro_dsp_valuehl 
366a				endm 
# End of macro FORTH_DSP_VALUEHL
366a			 
366a				; TODO add floating point number detection 
366a			 
366a e5					push hl 
366b			 
366b					; destroy value TOS 
366b			 
366b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
366b cd ce 1e			call macro_forth_dsp_pop 
366e				endm 
# End of macro FORTH_DSP_POP
366e			 
366e			 
366e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
366e cd 16 1e			call macro_dsp_valuehl 
3671				endm 
# End of macro FORTH_DSP_VALUEHL
3671			 
3671					; one value on hl get other one back 
3671			 
3671 d1					pop de 
3672			 
3672					; do the add 
3672			 
3672 19					add hl,de 
3673			 
3673					; save it 
3673			 
3673			;		push hl	 
3673			 
3673					; 
3673			 
3673					; destroy value TOS 
3673			 
3673					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3673 cd ce 1e			call macro_forth_dsp_pop 
3676				endm 
# End of macro FORTH_DSP_POP
3676			 
3676					; TODO push value back onto stack for another op etc 
3676			 
3676			;		pop hl 
3676			 
3676			.dot_done: 
3676 cd 1f 1c				call forth_push_numhl 
3679			 
3679					NEXTW 
3679 c3 c5 1f			jp macro_next 
367c				endm 
# End of macro NEXTW
367c			.NEG: 
367c			 
367c				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
367c 17				db WORD_SYS_CORE+3             
367d bf 36			dw .DIV            
367f 02				db 1 + 1 
3680 .. 00			db "-",0              
3682				endm 
# End of macro CWHEAD
3682			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3682					if DEBUG_FORTH_WORDS_KEY 
3682						DMARK "SUB" 
3682 f5				push af  
3683 3a 97 36			ld a, (.dmark)  
3686 32 71 ee			ld (debug_mark),a  
3689 3a 98 36			ld a, (.dmark+1)  
368c 32 72 ee			ld (debug_mark+1),a  
368f 3a 99 36			ld a, (.dmark+2)  
3692 32 73 ee			ld (debug_mark+2),a  
3695 18 03			jr .pastdmark  
3697 ..			.dmark: db "SUB"  
369a f1			.pastdmark: pop af  
369b			endm  
# End of macro DMARK
369b						CALLMONITOR 
369b cd ae 15			call break_point_state  
369e				endm  
# End of macro CALLMONITOR
369e					endif 
369e			 
369e			 
369e				; TODO add floating point number detection 
369e					; v5 FORTH_DSP_VALUE 
369e					FORTH_DSP 
369e cd dc 1d			call macro_forth_dsp 
36a1				endm 
# End of macro FORTH_DSP
36a1 7e					ld a,(hl)	; get type of value on TOS 
36a2 fe 02				cp DS_TYPE_INUM  
36a4 28 03				jr z, .neg_inum 
36a6			 
36a6					NEXTW 
36a6 c3 c5 1f			jp macro_next 
36a9				endm 
# End of macro NEXTW
36a9			 
36a9			; float maths 
36a9			 
36a9				if FORTH_ENABLE_FLOATMATH 
36a9					jr .neg_done 
36a9			 
36a9				endif 
36a9					 
36a9			 
36a9			.neg_inum: 
36a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36a9 cd 16 1e			call macro_dsp_valuehl 
36ac				endm 
# End of macro FORTH_DSP_VALUEHL
36ac			 
36ac e5					push hl 
36ad			 
36ad					; destroy value TOS 
36ad			 
36ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ad cd ce 1e			call macro_forth_dsp_pop 
36b0				endm 
# End of macro FORTH_DSP_POP
36b0			 
36b0			 
36b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36b0 cd 16 1e			call macro_dsp_valuehl 
36b3				endm 
# End of macro FORTH_DSP_VALUEHL
36b3			 
36b3					; one value on hl get other one back 
36b3			 
36b3 d1					pop de 
36b4			 
36b4					; do the sub 
36b4			;		ex de, hl 
36b4			 
36b4 ed 52				sbc hl,de 
36b6			 
36b6					; save it 
36b6			 
36b6			;		push hl	 
36b6			 
36b6					; 
36b6			 
36b6					; destroy value TOS 
36b6			 
36b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36b6 cd ce 1e			call macro_forth_dsp_pop 
36b9				endm 
# End of macro FORTH_DSP_POP
36b9			 
36b9					; TODO push value back onto stack for another op etc 
36b9			 
36b9			;		pop hl 
36b9			 
36b9 cd 1f 1c				call forth_push_numhl 
36bc			.neg_done: 
36bc			 
36bc					NEXTW 
36bc c3 c5 1f			jp macro_next 
36bf				endm 
# End of macro NEXTW
36bf			.DIV: 
36bf				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
36bf 18				db WORD_SYS_CORE+4             
36c0 0c 37			dw .MUL            
36c2 02				db 1 + 1 
36c3 .. 00			db "/",0              
36c5				endm 
# End of macro CWHEAD
36c5			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
36c5					if DEBUG_FORTH_WORDS_KEY 
36c5						DMARK "DIV" 
36c5 f5				push af  
36c6 3a da 36			ld a, (.dmark)  
36c9 32 71 ee			ld (debug_mark),a  
36cc 3a db 36			ld a, (.dmark+1)  
36cf 32 72 ee			ld (debug_mark+1),a  
36d2 3a dc 36			ld a, (.dmark+2)  
36d5 32 73 ee			ld (debug_mark+2),a  
36d8 18 03			jr .pastdmark  
36da ..			.dmark: db "DIV"  
36dd f1			.pastdmark: pop af  
36de			endm  
# End of macro DMARK
36de						CALLMONITOR 
36de cd ae 15			call break_point_state  
36e1				endm  
# End of macro CALLMONITOR
36e1					endif 
36e1				; TODO add floating point number detection 
36e1					; v5 FORTH_DSP_VALUE 
36e1					FORTH_DSP 
36e1 cd dc 1d			call macro_forth_dsp 
36e4				endm 
# End of macro FORTH_DSP
36e4 7e					ld a,(hl)	; get type of value on TOS 
36e5 fe 02				cp DS_TYPE_INUM  
36e7 28 03				jr z, .div_inum 
36e9			 
36e9				if FORTH_ENABLE_FLOATMATH 
36e9					jr .div_done 
36e9			 
36e9				endif 
36e9					NEXTW 
36e9 c3 c5 1f			jp macro_next 
36ec				endm 
# End of macro NEXTW
36ec			.div_inum: 
36ec			 
36ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36ec cd 16 1e			call macro_dsp_valuehl 
36ef				endm 
# End of macro FORTH_DSP_VALUEHL
36ef			 
36ef e5					push hl    ; to go to bc 
36f0			 
36f0					; destroy value TOS 
36f0			 
36f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36f0 cd ce 1e			call macro_forth_dsp_pop 
36f3				endm 
# End of macro FORTH_DSP_POP
36f3			 
36f3			 
36f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36f3 cd 16 1e			call macro_dsp_valuehl 
36f6				endm 
# End of macro FORTH_DSP_VALUEHL
36f6			 
36f6					; hl to go to de 
36f6			 
36f6 e5					push hl 
36f7			 
36f7 c1					pop bc 
36f8 d1					pop de		 
36f9			 
36f9			 
36f9					if DEBUG_FORTH_MATHS 
36f9						DMARK "DIV" 
36f9				CALLMONITOR 
36f9					endif 
36f9					; one value on hl but move to a get other one back 
36f9			 
36f9			        
36f9 cd 0a 0d			call Div16 
36fc			 
36fc			;	push af	 
36fc e5				push hl 
36fd c5				push bc 
36fe			 
36fe					if DEBUG_FORTH_MATHS 
36fe						DMARK "DI1" 
36fe				CALLMONITOR 
36fe					endif 
36fe			 
36fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36fe cd ce 1e			call macro_forth_dsp_pop 
3701				endm 
# End of macro FORTH_DSP_POP
3701			 
3701			 
3701			 
3701 e1					pop hl    ; result 
3702			 
3702 cd 1f 1c				call forth_push_numhl 
3705			 
3705 e1					pop hl    ; reminder 
3706			;		ld h,0 
3706			;		ld l,d 
3706			 
3706 cd 1f 1c				call forth_push_numhl 
3709			.div_done: 
3709					NEXTW 
3709 c3 c5 1f			jp macro_next 
370c				endm 
# End of macro NEXTW
370c			.MUL: 
370c				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
370c 19				db WORD_SYS_CORE+5             
370d 51 37			dw .MIN            
370f 02				db 1 + 1 
3710 .. 00			db "*",0              
3712				endm 
# End of macro CWHEAD
3712			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3712				; TODO add floating point number detection 
3712					if DEBUG_FORTH_WORDS_KEY 
3712						DMARK "MUL" 
3712 f5				push af  
3713 3a 27 37			ld a, (.dmark)  
3716 32 71 ee			ld (debug_mark),a  
3719 3a 28 37			ld a, (.dmark+1)  
371c 32 72 ee			ld (debug_mark+1),a  
371f 3a 29 37			ld a, (.dmark+2)  
3722 32 73 ee			ld (debug_mark+2),a  
3725 18 03			jr .pastdmark  
3727 ..			.dmark: db "MUL"  
372a f1			.pastdmark: pop af  
372b			endm  
# End of macro DMARK
372b						CALLMONITOR 
372b cd ae 15			call break_point_state  
372e				endm  
# End of macro CALLMONITOR
372e					endif 
372e					FORTH_DSP 
372e cd dc 1d			call macro_forth_dsp 
3731				endm 
# End of macro FORTH_DSP
3731					; v5 FORTH_DSP_VALUE 
3731 7e					ld a,(hl)	; get type of value on TOS 
3732 fe 02				cp DS_TYPE_INUM  
3734 28 03				jr z, .mul_inum 
3736			 
3736				if FORTH_ENABLE_FLOATMATH 
3736					jr .mul_done 
3736			 
3736				endif 
3736			 
3736					NEXTW 
3736 c3 c5 1f			jp macro_next 
3739				endm 
# End of macro NEXTW
3739			.mul_inum:	 
3739			 
3739					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3739 cd 16 1e			call macro_dsp_valuehl 
373c				endm 
# End of macro FORTH_DSP_VALUEHL
373c			 
373c e5					push hl 
373d			 
373d					; destroy value TOS 
373d			 
373d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
373d cd ce 1e			call macro_forth_dsp_pop 
3740				endm 
# End of macro FORTH_DSP_POP
3740			 
3740			 
3740					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3740 cd 16 1e			call macro_dsp_valuehl 
3743				endm 
# End of macro FORTH_DSP_VALUEHL
3743			 
3743					; one value on hl but move to a get other one back 
3743			 
3743 7d					ld a, l 
3744			 
3744 d1					pop de 
3745			 
3745					; do the mull 
3745			;		ex de, hl 
3745			 
3745 cd 30 0d				call Mult16 
3748					; save it 
3748			 
3748			;		push hl	 
3748			 
3748					; 
3748			 
3748					; destroy value TOS 
3748			 
3748					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3748 cd ce 1e			call macro_forth_dsp_pop 
374b				endm 
# End of macro FORTH_DSP_POP
374b			 
374b					; TODO push value back onto stack for another op etc 
374b			 
374b			;		pop hl 
374b			 
374b cd 1f 1c				call forth_push_numhl 
374e			 
374e			.mul_done: 
374e					NEXTW 
374e c3 c5 1f			jp macro_next 
3751				endm 
# End of macro NEXTW
3751			 
3751			 
3751			 
3751			 
3751			.MIN: 
3751				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3751 49				db WORD_SYS_CORE+53             
3752 d2 37			dw .MAX            
3754 04				db 3 + 1 
3755 .. 00			db "MIN",0              
3759				endm 
# End of macro CWHEAD
3759			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3759					if DEBUG_FORTH_WORDS_KEY 
3759						DMARK "MIN" 
3759 f5				push af  
375a 3a 6e 37			ld a, (.dmark)  
375d 32 71 ee			ld (debug_mark),a  
3760 3a 6f 37			ld a, (.dmark+1)  
3763 32 72 ee			ld (debug_mark+1),a  
3766 3a 70 37			ld a, (.dmark+2)  
3769 32 73 ee			ld (debug_mark+2),a  
376c 18 03			jr .pastdmark  
376e ..			.dmark: db "MIN"  
3771 f1			.pastdmark: pop af  
3772			endm  
# End of macro DMARK
3772						CALLMONITOR 
3772 cd ae 15			call break_point_state  
3775				endm  
# End of macro CALLMONITOR
3775					endif 
3775					; get u2 
3775			 
3775					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3775 cd 16 1e			call macro_dsp_valuehl 
3778				endm 
# End of macro FORTH_DSP_VALUEHL
3778			 
3778 e5					push hl   ; u2 
3779			 
3779					; destroy value TOS 
3779			 
3779					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3779 cd ce 1e			call macro_forth_dsp_pop 
377c				endm 
# End of macro FORTH_DSP_POP
377c			 
377c					; get u1 
377c			 
377c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
377c cd 16 1e			call macro_dsp_valuehl 
377f				endm 
# End of macro FORTH_DSP_VALUEHL
377f			 
377f e5					push hl  ; u1 
3780			 
3780					; destroy value TOS 
3780			 
3780					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3780 cd ce 1e			call macro_forth_dsp_pop 
3783				endm 
# End of macro FORTH_DSP_POP
3783			 
3783 b7			 or a      ;clear carry flag 
3784 e1			  pop hl    ; u1 
3785 d1			  pop de    ; u2 
3786 e5				push hl   ; saved in case hl is lowest 
3787 ed 52		  sbc hl,de 
3789 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
378b			 
378b e1				pop hl 
378c					if DEBUG_FORTH_WORDS 
378c						DMARK "MIN" 
378c f5				push af  
378d 3a a1 37			ld a, (.dmark)  
3790 32 71 ee			ld (debug_mark),a  
3793 3a a2 37			ld a, (.dmark+1)  
3796 32 72 ee			ld (debug_mark+1),a  
3799 3a a3 37			ld a, (.dmark+2)  
379c 32 73 ee			ld (debug_mark+2),a  
379f 18 03			jr .pastdmark  
37a1 ..			.dmark: db "MIN"  
37a4 f1			.pastdmark: pop af  
37a5			endm  
# End of macro DMARK
37a5						CALLMONITOR 
37a5 cd ae 15			call break_point_state  
37a8				endm  
# End of macro CALLMONITOR
37a8					endif 
37a8 cd 1f 1c				call forth_push_numhl 
37ab			 
37ab				       NEXTW 
37ab c3 c5 1f			jp macro_next 
37ae				endm 
# End of macro NEXTW
37ae			 
37ae			.mincont:  
37ae c1				pop bc   ; tidy up 
37af eb				ex de , hl  
37b0					if DEBUG_FORTH_WORDS 
37b0						DMARK "MI1" 
37b0 f5				push af  
37b1 3a c5 37			ld a, (.dmark)  
37b4 32 71 ee			ld (debug_mark),a  
37b7 3a c6 37			ld a, (.dmark+1)  
37ba 32 72 ee			ld (debug_mark+1),a  
37bd 3a c7 37			ld a, (.dmark+2)  
37c0 32 73 ee			ld (debug_mark+2),a  
37c3 18 03			jr .pastdmark  
37c5 ..			.dmark: db "MI1"  
37c8 f1			.pastdmark: pop af  
37c9			endm  
# End of macro DMARK
37c9						CALLMONITOR 
37c9 cd ae 15			call break_point_state  
37cc				endm  
# End of macro CALLMONITOR
37cc					endif 
37cc cd 1f 1c				call forth_push_numhl 
37cf			 
37cf				       NEXTW 
37cf c3 c5 1f			jp macro_next 
37d2				endm 
# End of macro NEXTW
37d2			.MAX: 
37d2				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
37d2 4a				db WORD_SYS_CORE+54             
37d3 53 38			dw .RND16            
37d5 04				db 3 + 1 
37d6 .. 00			db "MAX",0              
37da				endm 
# End of macro CWHEAD
37da			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
37da					if DEBUG_FORTH_WORDS_KEY 
37da						DMARK "MAX" 
37da f5				push af  
37db 3a ef 37			ld a, (.dmark)  
37de 32 71 ee			ld (debug_mark),a  
37e1 3a f0 37			ld a, (.dmark+1)  
37e4 32 72 ee			ld (debug_mark+1),a  
37e7 3a f1 37			ld a, (.dmark+2)  
37ea 32 73 ee			ld (debug_mark+2),a  
37ed 18 03			jr .pastdmark  
37ef ..			.dmark: db "MAX"  
37f2 f1			.pastdmark: pop af  
37f3			endm  
# End of macro DMARK
37f3						CALLMONITOR 
37f3 cd ae 15			call break_point_state  
37f6				endm  
# End of macro CALLMONITOR
37f6					endif 
37f6					; get u2 
37f6			 
37f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37f6 cd 16 1e			call macro_dsp_valuehl 
37f9				endm 
# End of macro FORTH_DSP_VALUEHL
37f9			 
37f9 e5					push hl   ; u2 
37fa			 
37fa					; destroy value TOS 
37fa			 
37fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37fa cd ce 1e			call macro_forth_dsp_pop 
37fd				endm 
# End of macro FORTH_DSP_POP
37fd			 
37fd					; get u1 
37fd			 
37fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37fd cd 16 1e			call macro_dsp_valuehl 
3800				endm 
# End of macro FORTH_DSP_VALUEHL
3800			 
3800 e5					push hl  ; u1 
3801			 
3801					; destroy value TOS 
3801			 
3801					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3801 cd ce 1e			call macro_forth_dsp_pop 
3804				endm 
# End of macro FORTH_DSP_POP
3804			 
3804 b7			 or a      ;clear carry flag 
3805 e1			  pop hl    ; u1 
3806 d1			  pop de    ; u2 
3807 e5				push hl   ; saved in case hl is lowest 
3808 ed 52		  sbc hl,de 
380a 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
380c			 
380c e1				pop hl 
380d					if DEBUG_FORTH_WORDS 
380d						DMARK "MAX" 
380d f5				push af  
380e 3a 22 38			ld a, (.dmark)  
3811 32 71 ee			ld (debug_mark),a  
3814 3a 23 38			ld a, (.dmark+1)  
3817 32 72 ee			ld (debug_mark+1),a  
381a 3a 24 38			ld a, (.dmark+2)  
381d 32 73 ee			ld (debug_mark+2),a  
3820 18 03			jr .pastdmark  
3822 ..			.dmark: db "MAX"  
3825 f1			.pastdmark: pop af  
3826			endm  
# End of macro DMARK
3826						CALLMONITOR 
3826 cd ae 15			call break_point_state  
3829				endm  
# End of macro CALLMONITOR
3829					endif 
3829 cd 1f 1c				call forth_push_numhl 
382c			 
382c				       NEXTW 
382c c3 c5 1f			jp macro_next 
382f				endm 
# End of macro NEXTW
382f			 
382f			.maxcont:  
382f c1				pop bc   ; tidy up 
3830 eb				ex de , hl  
3831					if DEBUG_FORTH_WORDS 
3831						DMARK "MA1" 
3831 f5				push af  
3832 3a 46 38			ld a, (.dmark)  
3835 32 71 ee			ld (debug_mark),a  
3838 3a 47 38			ld a, (.dmark+1)  
383b 32 72 ee			ld (debug_mark+1),a  
383e 3a 48 38			ld a, (.dmark+2)  
3841 32 73 ee			ld (debug_mark+2),a  
3844 18 03			jr .pastdmark  
3846 ..			.dmark: db "MA1"  
3849 f1			.pastdmark: pop af  
384a			endm  
# End of macro DMARK
384a						CALLMONITOR 
384a cd ae 15			call break_point_state  
384d				endm  
# End of macro CALLMONITOR
384d					endif 
384d cd 1f 1c				call forth_push_numhl 
3850				       NEXTW 
3850 c3 c5 1f			jp macro_next 
3853				endm 
# End of macro NEXTW
3853			 
3853			.RND16: 
3853				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3853 4e				db WORD_SYS_CORE+58             
3854 82 38			dw .RND8            
3856 06				db 5 + 1 
3857 .. 00			db "RND16",0              
385d				endm 
# End of macro CWHEAD
385d			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
385d					if DEBUG_FORTH_WORDS_KEY 
385d						DMARK "R16" 
385d f5				push af  
385e 3a 72 38			ld a, (.dmark)  
3861 32 71 ee			ld (debug_mark),a  
3864 3a 73 38			ld a, (.dmark+1)  
3867 32 72 ee			ld (debug_mark+1),a  
386a 3a 74 38			ld a, (.dmark+2)  
386d 32 73 ee			ld (debug_mark+2),a  
3870 18 03			jr .pastdmark  
3872 ..			.dmark: db "R16"  
3875 f1			.pastdmark: pop af  
3876			endm  
# End of macro DMARK
3876						CALLMONITOR 
3876 cd ae 15			call break_point_state  
3879				endm  
# End of macro CALLMONITOR
3879					endif 
3879 cd d4 0c				call prng16  
387c cd 1f 1c				call forth_push_numhl 
387f				       NEXTW 
387f c3 c5 1f			jp macro_next 
3882				endm 
# End of macro NEXTW
3882			.RND8: 
3882				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3882 60				db WORD_SYS_CORE+76             
3883 b7 38			dw .RND            
3885 05				db 4 + 1 
3886 .. 00			db "RND8",0              
388b				endm 
# End of macro CWHEAD
388b			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
388b					if DEBUG_FORTH_WORDS_KEY 
388b						DMARK "RN8" 
388b f5				push af  
388c 3a a0 38			ld a, (.dmark)  
388f 32 71 ee			ld (debug_mark),a  
3892 3a a1 38			ld a, (.dmark+1)  
3895 32 72 ee			ld (debug_mark+1),a  
3898 3a a2 38			ld a, (.dmark+2)  
389b 32 73 ee			ld (debug_mark+2),a  
389e 18 03			jr .pastdmark  
38a0 ..			.dmark: db "RN8"  
38a3 f1			.pastdmark: pop af  
38a4			endm  
# End of macro DMARK
38a4						CALLMONITOR 
38a4 cd ae 15			call break_point_state  
38a7				endm  
# End of macro CALLMONITOR
38a7					endif 
38a7 2a b2 eb				ld hl,(xrandc) 
38aa 23					inc hl 
38ab cd ee 0c				call xrnd 
38ae 6f					ld l,a	 
38af 26 00				ld h,0 
38b1 cd 1f 1c				call forth_push_numhl 
38b4				       NEXTW 
38b4 c3 c5 1f			jp macro_next 
38b7				endm 
# End of macro NEXTW
38b7			.RND: 
38b7				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
38b7 60				db WORD_SYS_CORE+76             
38b8 bd 39			dw .ENDMATHS            
38ba 04				db 3 + 1 
38bb .. 00			db "RND",0              
38bf				endm 
# End of macro CWHEAD
38bf			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
38bf			 
38bf					if DEBUG_FORTH_WORDS_KEY 
38bf						DMARK "RND" 
38bf f5				push af  
38c0 3a d4 38			ld a, (.dmark)  
38c3 32 71 ee			ld (debug_mark),a  
38c6 3a d5 38			ld a, (.dmark+1)  
38c9 32 72 ee			ld (debug_mark+1),a  
38cc 3a d6 38			ld a, (.dmark+2)  
38cf 32 73 ee			ld (debug_mark+2),a  
38d2 18 03			jr .pastdmark  
38d4 ..			.dmark: db "RND"  
38d7 f1			.pastdmark: pop af  
38d8			endm  
# End of macro DMARK
38d8						CALLMONITOR 
38d8 cd ae 15			call break_point_state  
38db				endm  
# End of macro CALLMONITOR
38db					endif 
38db					 
38db					FORTH_DSP_VALUEHL    ; upper range 
38db cd 16 1e			call macro_dsp_valuehl 
38de				endm 
# End of macro FORTH_DSP_VALUEHL
38de			 
38de 22 b6 eb				ld (LFSRSeed), hl	 
38e1			 
38e1					if DEBUG_FORTH_WORDS 
38e1						DMARK "RN1" 
38e1 f5				push af  
38e2 3a f6 38			ld a, (.dmark)  
38e5 32 71 ee			ld (debug_mark),a  
38e8 3a f7 38			ld a, (.dmark+1)  
38eb 32 72 ee			ld (debug_mark+1),a  
38ee 3a f8 38			ld a, (.dmark+2)  
38f1 32 73 ee			ld (debug_mark+2),a  
38f4 18 03			jr .pastdmark  
38f6 ..			.dmark: db "RN1"  
38f9 f1			.pastdmark: pop af  
38fa			endm  
# End of macro DMARK
38fa						CALLMONITOR 
38fa cd ae 15			call break_point_state  
38fd				endm  
# End of macro CALLMONITOR
38fd					endif 
38fd					FORTH_DSP_POP 
38fd cd ce 1e			call macro_forth_dsp_pop 
3900				endm 
# End of macro FORTH_DSP_POP
3900			 
3900					FORTH_DSP_VALUEHL    ; low range 
3900 cd 16 1e			call macro_dsp_valuehl 
3903				endm 
# End of macro FORTH_DSP_VALUEHL
3903			 
3903					if DEBUG_FORTH_WORDS 
3903						DMARK "RN2" 
3903 f5				push af  
3904 3a 18 39			ld a, (.dmark)  
3907 32 71 ee			ld (debug_mark),a  
390a 3a 19 39			ld a, (.dmark+1)  
390d 32 72 ee			ld (debug_mark+1),a  
3910 3a 1a 39			ld a, (.dmark+2)  
3913 32 73 ee			ld (debug_mark+2),a  
3916 18 03			jr .pastdmark  
3918 ..			.dmark: db "RN2"  
391b f1			.pastdmark: pop af  
391c			endm  
# End of macro DMARK
391c						CALLMONITOR 
391c cd ae 15			call break_point_state  
391f				endm  
# End of macro CALLMONITOR
391f					endif 
391f 22 b8 eb				ld (LFSRSeed+2), hl 
3922			 
3922					FORTH_DSP_POP 
3922 cd ce 1e			call macro_forth_dsp_pop 
3925				endm 
# End of macro FORTH_DSP_POP
3925			 
3925 e5					push hl 
3926			 
3926 e1			.inrange:	pop hl 
3927 cd d4 0c				call prng16  
392a					if DEBUG_FORTH_WORDS 
392a						DMARK "RN3" 
392a f5				push af  
392b 3a 3f 39			ld a, (.dmark)  
392e 32 71 ee			ld (debug_mark),a  
3931 3a 40 39			ld a, (.dmark+1)  
3934 32 72 ee			ld (debug_mark+1),a  
3937 3a 41 39			ld a, (.dmark+2)  
393a 32 73 ee			ld (debug_mark+2),a  
393d 18 03			jr .pastdmark  
393f ..			.dmark: db "RN3"  
3942 f1			.pastdmark: pop af  
3943			endm  
# End of macro DMARK
3943						CALLMONITOR 
3943 cd ae 15			call break_point_state  
3946				endm  
# End of macro CALLMONITOR
3946					endif 
3946					 
3946					; if the range is 8bit knock out the high byte 
3946			 
3946 ed 5b b6 eb			ld de, (LFSRSeed)     ; check high level 
394a			 
394a 3e 00				ld a, 0 
394c ba					cp d  
394d 20 1e				jr nz, .hirange 
394f 26 00				ld h, 0   ; knock it down to 8bit 
3951			 
3951					if DEBUG_FORTH_WORDS 
3951						DMARK "RNk" 
3951 f5				push af  
3952 3a 66 39			ld a, (.dmark)  
3955 32 71 ee			ld (debug_mark),a  
3958 3a 67 39			ld a, (.dmark+1)  
395b 32 72 ee			ld (debug_mark+1),a  
395e 3a 68 39			ld a, (.dmark+2)  
3961 32 73 ee			ld (debug_mark+2),a  
3964 18 03			jr .pastdmark  
3966 ..			.dmark: db "RNk"  
3969 f1			.pastdmark: pop af  
396a			endm  
# End of macro DMARK
396a						CALLMONITOR 
396a cd ae 15			call break_point_state  
396d				endm  
# End of macro CALLMONITOR
396d					endif 
396d			.hirange:   
396d e5					push hl  
396e b7					or a  
396f ed 52		                sbc hl, de 
3971			 
3971					;call cmp16 
3971			 
3971 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3973 e1					pop hl 
3974 e5					push hl 
3975			 
3975					if DEBUG_FORTH_WORDS 
3975						DMARK "RN4" 
3975 f5				push af  
3976 3a 8a 39			ld a, (.dmark)  
3979 32 71 ee			ld (debug_mark),a  
397c 3a 8b 39			ld a, (.dmark+1)  
397f 32 72 ee			ld (debug_mark+1),a  
3982 3a 8c 39			ld a, (.dmark+2)  
3985 32 73 ee			ld (debug_mark+2),a  
3988 18 03			jr .pastdmark  
398a ..			.dmark: db "RN4"  
398d f1			.pastdmark: pop af  
398e			endm  
# End of macro DMARK
398e						CALLMONITOR 
398e cd ae 15			call break_point_state  
3991				endm  
# End of macro CALLMONITOR
3991					endif 
3991 ed 5b b8 eb			ld de, (LFSRSeed+2)   ; check low range 
3995					;call cmp16 
3995				 
3995 b7					or a  
3996 ed 52		                sbc hl, de 
3998 38 8c				jr c, .inrange 
399a			 
399a e1					pop hl 
399b					 
399b					if DEBUG_FORTH_WORDS 
399b						DMARK "RNd" 
399b f5				push af  
399c 3a b0 39			ld a, (.dmark)  
399f 32 71 ee			ld (debug_mark),a  
39a2 3a b1 39			ld a, (.dmark+1)  
39a5 32 72 ee			ld (debug_mark+1),a  
39a8 3a b2 39			ld a, (.dmark+2)  
39ab 32 73 ee			ld (debug_mark+2),a  
39ae 18 03			jr .pastdmark  
39b0 ..			.dmark: db "RNd"  
39b3 f1			.pastdmark: pop af  
39b4			endm  
# End of macro DMARK
39b4						CALLMONITOR 
39b4 cd ae 15			call break_point_state  
39b7				endm  
# End of macro CALLMONITOR
39b7					endif 
39b7			 
39b7			 
39b7 cd 1f 1c				call forth_push_numhl 
39ba				       NEXTW 
39ba c3 c5 1f			jp macro_next 
39bd				endm 
# End of macro NEXTW
39bd			 
39bd			.ENDMATHS: 
39bd			 
39bd			; eof 
39bd			 
# End of file forth_words_maths.asm
39bd			include "forth_words_display.asm" 
39bd			 
39bd			; | ## Display Words 
39bd			 
39bd			.INFO: 
39bd			 
39bd				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
39bd 62				db WORD_SYS_CORE+78             
39be da 39			dw .ATP            
39c0 05				db 4 + 1 
39c1 .. 00			db "INFO",0              
39c6				endm 
# End of macro CWHEAD
39c6			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
39c6					FORTH_DSP_VALUEHL 
39c6 cd 16 1e			call macro_dsp_valuehl 
39c9				endm 
# End of macro FORTH_DSP_VALUEHL
39c9			 
39c9					FORTH_DSP_POP 
39c9 cd ce 1e			call macro_forth_dsp_pop 
39cc				endm 
# End of macro FORTH_DSP_POP
39cc			 
39cc e5					push hl 
39cd			 
39cd					FORTH_DSP_VALUEHL 
39cd cd 16 1e			call macro_dsp_valuehl 
39d0				endm 
# End of macro FORTH_DSP_VALUEHL
39d0			 
39d0					FORTH_DSP_POP 
39d0 cd ce 1e			call macro_forth_dsp_pop 
39d3				endm 
# End of macro FORTH_DSP_POP
39d3			 
39d3 d1					pop de 
39d4			 
39d4 cd 11 0b				call info_panel 
39d7			 
39d7			 
39d7					NEXTW 
39d7 c3 c5 1f			jp macro_next 
39da				endm 
# End of macro NEXTW
39da			.ATP: 
39da				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
39da 62				db WORD_SYS_CORE+78             
39db 51 3a			dw .FB            
39dd 04				db 3 + 1 
39de .. 00			db "AT?",0              
39e2				endm 
# End of macro CWHEAD
39e2			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
39e2					if DEBUG_FORTH_WORDS_KEY 
39e2						DMARK "AT?" 
39e2 f5				push af  
39e3 3a f7 39			ld a, (.dmark)  
39e6 32 71 ee			ld (debug_mark),a  
39e9 3a f8 39			ld a, (.dmark+1)  
39ec 32 72 ee			ld (debug_mark+1),a  
39ef 3a f9 39			ld a, (.dmark+2)  
39f2 32 73 ee			ld (debug_mark+2),a  
39f5 18 03			jr .pastdmark  
39f7 ..			.dmark: db "AT?"  
39fa f1			.pastdmark: pop af  
39fb			endm  
# End of macro DMARK
39fb						CALLMONITOR 
39fb cd ae 15			call break_point_state  
39fe				endm  
# End of macro CALLMONITOR
39fe					endif 
39fe 3a 68 ea				ld a, (f_cursor_ptr) 
3a01			 
3a01			if DEBUG_FORTH_WORDS 
3a01				DMARK "AT?" 
3a01 f5				push af  
3a02 3a 16 3a			ld a, (.dmark)  
3a05 32 71 ee			ld (debug_mark),a  
3a08 3a 17 3a			ld a, (.dmark+1)  
3a0b 32 72 ee			ld (debug_mark+1),a  
3a0e 3a 18 3a			ld a, (.dmark+2)  
3a11 32 73 ee			ld (debug_mark+2),a  
3a14 18 03			jr .pastdmark  
3a16 ..			.dmark: db "AT?"  
3a19 f1			.pastdmark: pop af  
3a1a			endm  
# End of macro DMARK
3a1a				CALLMONITOR 
3a1a cd ae 15			call break_point_state  
3a1d				endm  
# End of macro CALLMONITOR
3a1d			endif	 
3a1d					; count the number of rows 
3a1d			 
3a1d 06 00				ld b, 0 
3a1f 4f			.atpr:		ld c, a    ; save in case we go below zero 
3a20 d6 28				sub display_cols 
3a22 f2 28 3a				jp p, .atprunder 
3a25 04					inc b 
3a26 18 f7				jr .atpr 
3a28			.atprunder:	 
3a28			if DEBUG_FORTH_WORDS 
3a28				DMARK "A?2" 
3a28 f5				push af  
3a29 3a 3d 3a			ld a, (.dmark)  
3a2c 32 71 ee			ld (debug_mark),a  
3a2f 3a 3e 3a			ld a, (.dmark+1)  
3a32 32 72 ee			ld (debug_mark+1),a  
3a35 3a 3f 3a			ld a, (.dmark+2)  
3a38 32 73 ee			ld (debug_mark+2),a  
3a3b 18 03			jr .pastdmark  
3a3d ..			.dmark: db "A?2"  
3a40 f1			.pastdmark: pop af  
3a41			endm  
# End of macro DMARK
3a41				CALLMONITOR 
3a41 cd ae 15			call break_point_state  
3a44				endm  
# End of macro CALLMONITOR
3a44			endif	 
3a44 26 00				ld h, 0 
3a46 69					ld l, c 
3a47 cd 1f 1c				call forth_push_numhl 
3a4a 68					ld l, b  
3a4b cd 1f 1c				call forth_push_numhl 
3a4e			 
3a4e			 
3a4e				NEXTW 
3a4e c3 c5 1f			jp macro_next 
3a51				endm 
# End of macro NEXTW
3a51			 
3a51			.FB: 
3a51				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3a51 1b				db WORD_SYS_CORE+7             
3a52 9f 3a			dw .EMIT            
3a54 03				db 2 + 1 
3a55 .. 00			db "FB",0              
3a58				endm 
# End of macro CWHEAD
3a58			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3a58			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3a58			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3a58			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3a58					if DEBUG_FORTH_WORDS_KEY 
3a58						DMARK "FB." 
3a58 f5				push af  
3a59 3a 6d 3a			ld a, (.dmark)  
3a5c 32 71 ee			ld (debug_mark),a  
3a5f 3a 6e 3a			ld a, (.dmark+1)  
3a62 32 72 ee			ld (debug_mark+1),a  
3a65 3a 6f 3a			ld a, (.dmark+2)  
3a68 32 73 ee			ld (debug_mark+2),a  
3a6b 18 03			jr .pastdmark  
3a6d ..			.dmark: db "FB."  
3a70 f1			.pastdmark: pop af  
3a71			endm  
# End of macro DMARK
3a71						CALLMONITOR 
3a71 cd ae 15			call break_point_state  
3a74				endm  
# End of macro CALLMONITOR
3a74					endif 
3a74			 
3a74					FORTH_DSP_VALUEHL 
3a74 cd 16 1e			call macro_dsp_valuehl 
3a77				endm 
# End of macro FORTH_DSP_VALUEHL
3a77			 
3a77 7d					ld a, l 
3a78 fe 01				cp 1 
3a7a 20 05				jr nz, .fbn1 
3a7c 21 16 ed				ld hl, display_fb1 
3a7f 18 15				jr .fbset 
3a81 fe 02		.fbn1:		cp 2 
3a83 20 05				jr nz, .fbn2 
3a85 21 d4 eb				ld hl, display_fb2 
3a88 18 0c				jr .fbset 
3a8a fe 03		.fbn2:		cp 3 
3a8c 20 05				jr nz, .fbn3 
3a8e 21 75 ec				ld hl, display_fb3 
3a91 18 03				jr .fbset 
3a93			.fbn3:		 ; if invalid number select first 
3a93 21 16 ed				ld hl, display_fb1 
3a96 22 d2 eb		.fbset:		ld (display_fb_active), hl 
3a99			 
3a99					FORTH_DSP_POP 
3a99 cd ce 1e			call macro_forth_dsp_pop 
3a9c				endm 
# End of macro FORTH_DSP_POP
3a9c			 
3a9c					NEXTW 
3a9c c3 c5 1f			jp macro_next 
3a9f				endm 
# End of macro NEXTW
3a9f			 
3a9f			 
3a9f			.EMIT: 
3a9f				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3a9f 1b				db WORD_SYS_CORE+7             
3aa0 f0 3a			dw .DOTH            
3aa2 05				db 4 + 1 
3aa3 .. 00			db "EMIT",0              
3aa8				endm 
# End of macro CWHEAD
3aa8			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3aa8					; get value off TOS and display it 
3aa8			 
3aa8					if DEBUG_FORTH_WORDS_KEY 
3aa8						DMARK "EMT" 
3aa8 f5				push af  
3aa9 3a bd 3a			ld a, (.dmark)  
3aac 32 71 ee			ld (debug_mark),a  
3aaf 3a be 3a			ld a, (.dmark+1)  
3ab2 32 72 ee			ld (debug_mark+1),a  
3ab5 3a bf 3a			ld a, (.dmark+2)  
3ab8 32 73 ee			ld (debug_mark+2),a  
3abb 18 03			jr .pastdmark  
3abd ..			.dmark: db "EMT"  
3ac0 f1			.pastdmark: pop af  
3ac1			endm  
# End of macro DMARK
3ac1						CALLMONITOR 
3ac1 cd ae 15			call break_point_state  
3ac4				endm  
# End of macro CALLMONITOR
3ac4					endif 
3ac4			 
3ac4					FORTH_DSP_VALUEHL 
3ac4 cd 16 1e			call macro_dsp_valuehl 
3ac7				endm 
# End of macro FORTH_DSP_VALUEHL
3ac7			 
3ac7 7d					ld a,l 
3ac8			 
3ac8					; TODO write to display 
3ac8			 
3ac8 32 c9 e4				ld (os_input), a 
3acb 3e 00				ld a, 0 
3acd 32 ca e4				ld (os_input+1), a 
3ad0					 
3ad0 3a 68 ea				ld a, (f_cursor_ptr) 
3ad3 11 c9 e4				ld de, os_input 
3ad6 cd 93 0b				call str_at_display 
3ad9			 
3ad9			 
3ad9 3a 46 ea				ld a,(cli_autodisplay) 
3adc fe 00				cp 0 
3ade 28 03				jr z, .enoupdate 
3ae0 cd a3 0b						call update_display 
3ae3					.enoupdate: 
3ae3			 
3ae3 3a 68 ea				ld a, (f_cursor_ptr) 
3ae6 3c					inc a 
3ae7 32 68 ea				ld (f_cursor_ptr), a   ; save new pos 
3aea			 
3aea			 
3aea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aea cd ce 1e			call macro_forth_dsp_pop 
3aed				endm 
# End of macro FORTH_DSP_POP
3aed			  
3aed			 
3aed					NEXTW 
3aed c3 c5 1f			jp macro_next 
3af0				endm 
# End of macro NEXTW
3af0			.DOTH: 
3af0				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3af0 1c				db WORD_SYS_CORE+8             
3af1 20 3b			dw .DOTF            
3af3 03				db 2 + 1 
3af4 .. 00			db ".-",0              
3af7				endm 
# End of macro CWHEAD
3af7			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3af7					; get value off TOS and display it 
3af7					if DEBUG_FORTH_WORDS_KEY 
3af7						DMARK "DTD" 
3af7 f5				push af  
3af8 3a 0c 3b			ld a, (.dmark)  
3afb 32 71 ee			ld (debug_mark),a  
3afe 3a 0d 3b			ld a, (.dmark+1)  
3b01 32 72 ee			ld (debug_mark+1),a  
3b04 3a 0e 3b			ld a, (.dmark+2)  
3b07 32 73 ee			ld (debug_mark+2),a  
3b0a 18 03			jr .pastdmark  
3b0c ..			.dmark: db "DTD"  
3b0f f1			.pastdmark: pop af  
3b10			endm  
# End of macro DMARK
3b10						CALLMONITOR 
3b10 cd ae 15			call break_point_state  
3b13				endm  
# End of macro CALLMONITOR
3b13					endif 
3b13 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3b15 3e 00			ld a, 0 
3b17 32 47 ea			ld (cli_mvdot), a 
3b1a c3 77 3b			jp .dotgo 
3b1d				NEXTW 
3b1d c3 c5 1f			jp macro_next 
3b20				endm 
# End of macro NEXTW
3b20			.DOTF: 
3b20				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3b20 1c				db WORD_SYS_CORE+8             
3b21 4e 3b			dw .DOT            
3b23 03				db 2 + 1 
3b24 .. 00			db ".>",0              
3b27				endm 
# End of macro CWHEAD
3b27			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3b27					; get value off TOS and display it 
3b27			        ; TODO BUG adds extra spaces 
3b27			        ; TODO BUG handle numerics? 
3b27					if DEBUG_FORTH_WORDS_KEY 
3b27						DMARK "DTC" 
3b27 f5				push af  
3b28 3a 3c 3b			ld a, (.dmark)  
3b2b 32 71 ee			ld (debug_mark),a  
3b2e 3a 3d 3b			ld a, (.dmark+1)  
3b31 32 72 ee			ld (debug_mark+1),a  
3b34 3a 3e 3b			ld a, (.dmark+2)  
3b37 32 73 ee			ld (debug_mark+2),a  
3b3a 18 03			jr .pastdmark  
3b3c ..			.dmark: db "DTC"  
3b3f f1			.pastdmark: pop af  
3b40			endm  
# End of macro DMARK
3b40						CALLMONITOR 
3b40 cd ae 15			call break_point_state  
3b43				endm  
# End of macro CALLMONITOR
3b43					endif 
3b43 3e 01			ld a, 1 
3b45 32 47 ea			ld (cli_mvdot), a 
3b48 c3 77 3b			jp .dotgo 
3b4b				NEXTW 
3b4b c3 c5 1f			jp macro_next 
3b4e				endm 
# End of macro NEXTW
3b4e			 
3b4e			.DOT: 
3b4e				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3b4e 1c				db WORD_SYS_CORE+8             
3b4f 2a 3d			dw .CLS            
3b51 02				db 1 + 1 
3b52 .. 00			db ".",0              
3b54				endm 
# End of macro CWHEAD
3b54			        ; | . ( u -- ) Display TOS | DONE 
3b54					; get value off TOS and display it 
3b54			 
3b54					if DEBUG_FORTH_WORDS_KEY 
3b54						DMARK "DOT" 
3b54 f5				push af  
3b55 3a 69 3b			ld a, (.dmark)  
3b58 32 71 ee			ld (debug_mark),a  
3b5b 3a 6a 3b			ld a, (.dmark+1)  
3b5e 32 72 ee			ld (debug_mark+1),a  
3b61 3a 6b 3b			ld a, (.dmark+2)  
3b64 32 73 ee			ld (debug_mark+2),a  
3b67 18 03			jr .pastdmark  
3b69 ..			.dmark: db "DOT"  
3b6c f1			.pastdmark: pop af  
3b6d			endm  
# End of macro DMARK
3b6d						CALLMONITOR 
3b6d cd ae 15			call break_point_state  
3b70				endm  
# End of macro CALLMONITOR
3b70					endif 
3b70 3e 00			ld a, 0 
3b72 32 47 ea			ld (cli_mvdot), a 
3b75 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3b77				 
3b77			 
3b77			.dotgo: 
3b77			 
3b77			; move up type to on stack for parserv5 
3b77					FORTH_DSP 
3b77 cd dc 1d			call macro_forth_dsp 
3b7a				endm 
# End of macro FORTH_DSP
3b7a				;FORTH_DSP_VALUE  
3b7a			 
3b7a			if DEBUG_FORTH_DOT 
3b7a				DMARK "DOT" 
3b7a f5				push af  
3b7b 3a 8f 3b			ld a, (.dmark)  
3b7e 32 71 ee			ld (debug_mark),a  
3b81 3a 90 3b			ld a, (.dmark+1)  
3b84 32 72 ee			ld (debug_mark+1),a  
3b87 3a 91 3b			ld a, (.dmark+2)  
3b8a 32 73 ee			ld (debug_mark+2),a  
3b8d 18 03			jr .pastdmark  
3b8f ..			.dmark: db "DOT"  
3b92 f1			.pastdmark: pop af  
3b93			endm  
# End of macro DMARK
3b93				CALLMONITOR 
3b93 cd ae 15			call break_point_state  
3b96				endm  
# End of macro CALLMONITOR
3b96			endif	 
3b96			;		.print: 
3b96			 
3b96 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3b97 23				inc hl   ; position to the actual value 
3b98 fe 01			cp DS_TYPE_STR 
3b9a 20 06			jr nz, .dotnum1  
3b9c			 
3b9c			; display string 
3b9c				FORTH_DSP_VALUE  
3b9c cd ff 1d			call macro_forth_dsp_value 
3b9f				endm 
# End of macro FORTH_DSP_VALUE
3b9f eb				ex de,hl 
3ba0 18 49			jr .dotwrite 
3ba2			 
3ba2			.dotnum1: 
3ba2 fe 02			cp DS_TYPE_INUM 
3ba4 20 44			jr nz, .dotflot 
3ba6			 
3ba6			 
3ba6			; display number 
3ba6			 
3ba6			;	push hl 
3ba6			;	call clear_display 
3ba6			;	pop hl 
3ba6			 
3ba6 5e				ld e, (hl) 
3ba7 23				inc hl 
3ba8 56				ld d, (hl) 
3ba9 21 cb e2			ld hl, scratch 
3bac			if DEBUG_FORTH_DOT 
3bac				DMARK "DT1" 
3bac f5				push af  
3bad 3a c1 3b			ld a, (.dmark)  
3bb0 32 71 ee			ld (debug_mark),a  
3bb3 3a c2 3b			ld a, (.dmark+1)  
3bb6 32 72 ee			ld (debug_mark+1),a  
3bb9 3a c3 3b			ld a, (.dmark+2)  
3bbc 32 73 ee			ld (debug_mark+2),a  
3bbf 18 03			jr .pastdmark  
3bc1 ..			.dmark: db "DT1"  
3bc4 f1			.pastdmark: pop af  
3bc5			endm  
# End of macro DMARK
3bc5				CALLMONITOR 
3bc5 cd ae 15			call break_point_state  
3bc8				endm  
# End of macro CALLMONITOR
3bc8			endif	 
3bc8			 
3bc8 cd ba 11			call uitoa_16 
3bcb eb				ex de,hl 
3bcc			 
3bcc			if DEBUG_FORTH_DOT 
3bcc				DMARK "DT2" 
3bcc f5				push af  
3bcd 3a e1 3b			ld a, (.dmark)  
3bd0 32 71 ee			ld (debug_mark),a  
3bd3 3a e2 3b			ld a, (.dmark+1)  
3bd6 32 72 ee			ld (debug_mark+1),a  
3bd9 3a e3 3b			ld a, (.dmark+2)  
3bdc 32 73 ee			ld (debug_mark+2),a  
3bdf 18 03			jr .pastdmark  
3be1 ..			.dmark: db "DT2"  
3be4 f1			.pastdmark: pop af  
3be5			endm  
# End of macro DMARK
3be5				CALLMONITOR 
3be5 cd ae 15			call break_point_state  
3be8				endm  
# End of macro CALLMONITOR
3be8			endif	 
3be8			 
3be8			;	ld de, os_word_scratch 
3be8 18 01			jr .dotwrite 
3bea			 
3bea 00			.dotflot:   nop 
3beb			; TODO print floating point number 
3beb			 
3beb			.dotwrite:		 
3beb			 
3beb					; if c is set then set all '-' to spaces 
3beb					; need to also take into account .>  
3beb			 
3beb 3e 01				ld a, 1 
3bed b9					cp c 
3bee 20 67				jr nz, .nodashswap 
3bf0			 
3bf0					; DE has the string to write, working with HL 
3bf0			 
3bf0 06 ff				ld b, 255 
3bf2 d5					push de 
3bf3 e1					pop hl 
3bf4			 
3bf4			if DEBUG_FORTH_DOT 
3bf4				DMARK "DT-" 
3bf4 f5				push af  
3bf5 3a 09 3c			ld a, (.dmark)  
3bf8 32 71 ee			ld (debug_mark),a  
3bfb 3a 0a 3c			ld a, (.dmark+1)  
3bfe 32 72 ee			ld (debug_mark+1),a  
3c01 3a 0b 3c			ld a, (.dmark+2)  
3c04 32 73 ee			ld (debug_mark+2),a  
3c07 18 03			jr .pastdmark  
3c09 ..			.dmark: db "DT-"  
3c0c f1			.pastdmark: pop af  
3c0d			endm  
# End of macro DMARK
3c0d				CALLMONITOR 
3c0d cd ae 15			call break_point_state  
3c10				endm  
# End of macro CALLMONITOR
3c10			endif	 
3c10 7e			.dashscan:	ld a, (hl) 
3c11 fe 00				cp 0 
3c13 28 42				jr z, .nodashswap 
3c15 fe 2d				cp '-' 
3c17 20 03				jr nz, .dashskip 
3c19 3e 20				ld a, ' ' 
3c1b 77					ld (hl), a 
3c1c 23			.dashskip:	inc hl 
3c1d			if DEBUG_FORTH_DOT 
3c1d				DMARK "D-2" 
3c1d f5				push af  
3c1e 3a 32 3c			ld a, (.dmark)  
3c21 32 71 ee			ld (debug_mark),a  
3c24 3a 33 3c			ld a, (.dmark+1)  
3c27 32 72 ee			ld (debug_mark+1),a  
3c2a 3a 34 3c			ld a, (.dmark+2)  
3c2d 32 73 ee			ld (debug_mark+2),a  
3c30 18 03			jr .pastdmark  
3c32 ..			.dmark: db "D-2"  
3c35 f1			.pastdmark: pop af  
3c36			endm  
# End of macro DMARK
3c36				CALLMONITOR 
3c36 cd ae 15			call break_point_state  
3c39				endm  
# End of macro CALLMONITOR
3c39			endif	 
3c39 10 d5				djnz .dashscan 
3c3b			 
3c3b			if DEBUG_FORTH_DOT 
3c3b				DMARK "D-1" 
3c3b f5				push af  
3c3c 3a 50 3c			ld a, (.dmark)  
3c3f 32 71 ee			ld (debug_mark),a  
3c42 3a 51 3c			ld a, (.dmark+1)  
3c45 32 72 ee			ld (debug_mark+1),a  
3c48 3a 52 3c			ld a, (.dmark+2)  
3c4b 32 73 ee			ld (debug_mark+2),a  
3c4e 18 03			jr .pastdmark  
3c50 ..			.dmark: db "D-1"  
3c53 f1			.pastdmark: pop af  
3c54			endm  
# End of macro DMARK
3c54				CALLMONITOR 
3c54 cd ae 15			call break_point_state  
3c57				endm  
# End of macro CALLMONITOR
3c57			endif	 
3c57			 
3c57			.nodashswap: 
3c57			 
3c57			if DEBUG_FORTH_DOT 
3c57				DMARK "D-o" 
3c57 f5				push af  
3c58 3a 6c 3c			ld a, (.dmark)  
3c5b 32 71 ee			ld (debug_mark),a  
3c5e 3a 6d 3c			ld a, (.dmark+1)  
3c61 32 72 ee			ld (debug_mark+1),a  
3c64 3a 6e 3c			ld a, (.dmark+2)  
3c67 32 73 ee			ld (debug_mark+2),a  
3c6a 18 03			jr .pastdmark  
3c6c ..			.dmark: db "D-o"  
3c6f f1			.pastdmark: pop af  
3c70			endm  
# End of macro DMARK
3c70				CALLMONITOR 
3c70 cd ae 15			call break_point_state  
3c73				endm  
# End of macro CALLMONITOR
3c73			endif	 
3c73			 
3c73 d5					push de   ; save string start in case we need to advance print 
3c74			 
3c74 3a 68 ea				ld a, (f_cursor_ptr) 
3c77 cd 93 0b				call str_at_display 
3c7a 3a 46 ea				ld a,(cli_autodisplay) 
3c7d fe 00				cp 0 
3c7f 28 03				jr z, .noupdate 
3c81 cd a3 0b						call update_display 
3c84					.noupdate: 
3c84			 
3c84			 
3c84					; see if we need to advance the print position 
3c84			 
3c84 e1					pop hl   ; get back string 
3c85			;		ex de,hl 
3c85			 
3c85 3a 47 ea				ld a, (cli_mvdot) 
3c88			if DEBUG_FORTH_DOT 
3c88			;		ld e,a 
3c88				DMARK "D>1" 
3c88 f5				push af  
3c89 3a 9d 3c			ld a, (.dmark)  
3c8c 32 71 ee			ld (debug_mark),a  
3c8f 3a 9e 3c			ld a, (.dmark+1)  
3c92 32 72 ee			ld (debug_mark+1),a  
3c95 3a 9f 3c			ld a, (.dmark+2)  
3c98 32 73 ee			ld (debug_mark+2),a  
3c9b 18 03			jr .pastdmark  
3c9d ..			.dmark: db "D>1"  
3ca0 f1			.pastdmark: pop af  
3ca1			endm  
# End of macro DMARK
3ca1				CALLMONITOR 
3ca1 cd ae 15			call break_point_state  
3ca4				endm  
# End of macro CALLMONITOR
3ca4			endif	 
3ca4 fe 00				cp 0 
3ca6 28 44				jr z, .noadv 
3ca8					; yes, lets advance the print position 
3ca8 3e 00				ld a, 0 
3caa cd 16 12				call strlent 
3cad			if DEBUG_FORTH_DOT 
3cad				DMARK "D-?" 
3cad f5				push af  
3cae 3a c2 3c			ld a, (.dmark)  
3cb1 32 71 ee			ld (debug_mark),a  
3cb4 3a c3 3c			ld a, (.dmark+1)  
3cb7 32 72 ee			ld (debug_mark+1),a  
3cba 3a c4 3c			ld a, (.dmark+2)  
3cbd 32 73 ee			ld (debug_mark+2),a  
3cc0 18 03			jr .pastdmark  
3cc2 ..			.dmark: db "D-?"  
3cc5 f1			.pastdmark: pop af  
3cc6			endm  
# End of macro DMARK
3cc6				CALLMONITOR 
3cc6 cd ae 15			call break_point_state  
3cc9				endm  
# End of macro CALLMONITOR
3cc9			endif	 
3cc9 3a 68 ea				ld a, (f_cursor_ptr) 
3ccc 85					add a,l 
3ccd					;call addatohl 
3ccd					;ld a, l 
3ccd 32 68 ea				ld (f_cursor_ptr), a   ; save new pos 
3cd0			 
3cd0			if DEBUG_FORTH_DOT 
3cd0				DMARK "D->" 
3cd0 f5				push af  
3cd1 3a e5 3c			ld a, (.dmark)  
3cd4 32 71 ee			ld (debug_mark),a  
3cd7 3a e6 3c			ld a, (.dmark+1)  
3cda 32 72 ee			ld (debug_mark+1),a  
3cdd 3a e7 3c			ld a, (.dmark+2)  
3ce0 32 73 ee			ld (debug_mark+2),a  
3ce3 18 03			jr .pastdmark  
3ce5 ..			.dmark: db "D->"  
3ce8 f1			.pastdmark: pop af  
3ce9			endm  
# End of macro DMARK
3ce9				CALLMONITOR 
3ce9 cd ae 15			call break_point_state  
3cec				endm  
# End of macro CALLMONITOR
3cec			endif	 
3cec			 
3cec			.noadv:	 
3cec			 
3cec					if DEBUG_FORTH_DOT_WAIT 
3cec							call next_page_prompt 
3cec					endif	 
3cec			; TODO this pop off the stack causes a crash. i dont know why 
3cec			 
3cec			 
3cec			if DEBUG_FORTH_DOT 
3cec				DMARK "DTh" 
3cec f5				push af  
3ced 3a 01 3d			ld a, (.dmark)  
3cf0 32 71 ee			ld (debug_mark),a  
3cf3 3a 02 3d			ld a, (.dmark+1)  
3cf6 32 72 ee			ld (debug_mark+1),a  
3cf9 3a 03 3d			ld a, (.dmark+2)  
3cfc 32 73 ee			ld (debug_mark+2),a  
3cff 18 03			jr .pastdmark  
3d01 ..			.dmark: db "DTh"  
3d04 f1			.pastdmark: pop af  
3d05			endm  
# End of macro DMARK
3d05				CALLMONITOR 
3d05 cd ae 15			call break_point_state  
3d08				endm  
# End of macro CALLMONITOR
3d08			endif	 
3d08			 
3d08					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d08 cd ce 1e			call macro_forth_dsp_pop 
3d0b				endm 
# End of macro FORTH_DSP_POP
3d0b			 
3d0b			if DEBUG_FORTH_DOT 
3d0b				DMARK "DTi" 
3d0b f5				push af  
3d0c 3a 20 3d			ld a, (.dmark)  
3d0f 32 71 ee			ld (debug_mark),a  
3d12 3a 21 3d			ld a, (.dmark+1)  
3d15 32 72 ee			ld (debug_mark+1),a  
3d18 3a 22 3d			ld a, (.dmark+2)  
3d1b 32 73 ee			ld (debug_mark+2),a  
3d1e 18 03			jr .pastdmark  
3d20 ..			.dmark: db "DTi"  
3d23 f1			.pastdmark: pop af  
3d24			endm  
# End of macro DMARK
3d24				CALLMONITOR 
3d24 cd ae 15			call break_point_state  
3d27				endm  
# End of macro CALLMONITOR
3d27			endif	 
3d27			 
3d27			 
3d27					NEXTW 
3d27 c3 c5 1f			jp macro_next 
3d2a				endm 
# End of macro NEXTW
3d2a			 
3d2a			.CLS: 
3d2a				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3d2a 35				db WORD_SYS_CORE+33             
3d2b 57 3d			dw .DRAW            
3d2d 04				db 3 + 1 
3d2e .. 00			db "CLS",0              
3d32				endm 
# End of macro CWHEAD
3d32			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3d32					if DEBUG_FORTH_WORDS_KEY 
3d32						DMARK "CLS" 
3d32 f5				push af  
3d33 3a 47 3d			ld a, (.dmark)  
3d36 32 71 ee			ld (debug_mark),a  
3d39 3a 48 3d			ld a, (.dmark+1)  
3d3c 32 72 ee			ld (debug_mark+1),a  
3d3f 3a 49 3d			ld a, (.dmark+2)  
3d42 32 73 ee			ld (debug_mark+2),a  
3d45 18 03			jr .pastdmark  
3d47 ..			.dmark: db "CLS"  
3d4a f1			.pastdmark: pop af  
3d4b			endm  
# End of macro DMARK
3d4b						CALLMONITOR 
3d4b cd ae 15			call break_point_state  
3d4e				endm  
# End of macro CALLMONITOR
3d4e					endif 
3d4e cd 80 0b				call clear_display 
3d51 c3 65 3e				jp .home		; and home cursor 
3d54					NEXTW 
3d54 c3 c5 1f			jp macro_next 
3d57				endm 
# End of macro NEXTW
3d57			 
3d57			.DRAW: 
3d57				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3d57 36				db WORD_SYS_CORE+34             
3d58 82 3d			dw .DUMP            
3d5a 05				db 4 + 1 
3d5b .. 00			db "DRAW",0              
3d60				endm 
# End of macro CWHEAD
3d60			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3d60					if DEBUG_FORTH_WORDS_KEY 
3d60						DMARK "DRW" 
3d60 f5				push af  
3d61 3a 75 3d			ld a, (.dmark)  
3d64 32 71 ee			ld (debug_mark),a  
3d67 3a 76 3d			ld a, (.dmark+1)  
3d6a 32 72 ee			ld (debug_mark+1),a  
3d6d 3a 77 3d			ld a, (.dmark+2)  
3d70 32 73 ee			ld (debug_mark+2),a  
3d73 18 03			jr .pastdmark  
3d75 ..			.dmark: db "DRW"  
3d78 f1			.pastdmark: pop af  
3d79			endm  
# End of macro DMARK
3d79						CALLMONITOR 
3d79 cd ae 15			call break_point_state  
3d7c				endm  
# End of macro CALLMONITOR
3d7c					endif 
3d7c cd a3 0b				call update_display 
3d7f					NEXTW 
3d7f c3 c5 1f			jp macro_next 
3d82				endm 
# End of macro NEXTW
3d82			 
3d82			.DUMP: 
3d82				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3d82 37				db WORD_SYS_CORE+35             
3d83 ba 3d			dw .CDUMP            
3d85 05				db 4 + 1 
3d86 .. 00			db "DUMP",0              
3d8b				endm 
# End of macro CWHEAD
3d8b			; | DUMP ( x -- ) With address x display dump   | DONE 
3d8b			; TODO pop address to use off of the stack 
3d8b					if DEBUG_FORTH_WORDS_KEY 
3d8b						DMARK "DUM" 
3d8b f5				push af  
3d8c 3a a0 3d			ld a, (.dmark)  
3d8f 32 71 ee			ld (debug_mark),a  
3d92 3a a1 3d			ld a, (.dmark+1)  
3d95 32 72 ee			ld (debug_mark+1),a  
3d98 3a a2 3d			ld a, (.dmark+2)  
3d9b 32 73 ee			ld (debug_mark+2),a  
3d9e 18 03			jr .pastdmark  
3da0 ..			.dmark: db "DUM"  
3da3 f1			.pastdmark: pop af  
3da4			endm  
# End of macro DMARK
3da4						CALLMONITOR 
3da4 cd ae 15			call break_point_state  
3da7				endm  
# End of macro CALLMONITOR
3da7					endif 
3da7 cd 80 0b				call clear_display 
3daa			 
3daa					; get address 
3daa			 
3daa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3daa cd 16 1e			call macro_dsp_valuehl 
3dad				endm 
# End of macro FORTH_DSP_VALUEHL
3dad				 
3dad					; save it for cdump 
3dad			 
3dad 22 ee e5				ld (os_cur_ptr),hl 
3db0			 
3db0					; destroy value TOS 
3db0			 
3db0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3db0 cd ce 1e			call macro_forth_dsp_pop 
3db3				endm 
# End of macro FORTH_DSP_POP
3db3			 
3db3 cd 9f 1a				call dumpcont	; skip old style of param parsing	 
3db6 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3db7					NEXTW 
3db7 c3 c5 1f			jp macro_next 
3dba				endm 
# End of macro NEXTW
3dba			.CDUMP: 
3dba				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3dba 38				db WORD_SYS_CORE+36             
3dbb ea 3d			dw .DAT            
3dbd 06				db 5 + 1 
3dbe .. 00			db "CDUMP",0              
3dc4				endm 
# End of macro CWHEAD
3dc4			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3dc4					if DEBUG_FORTH_WORDS_KEY 
3dc4						DMARK "CDP" 
3dc4 f5				push af  
3dc5 3a d9 3d			ld a, (.dmark)  
3dc8 32 71 ee			ld (debug_mark),a  
3dcb 3a da 3d			ld a, (.dmark+1)  
3dce 32 72 ee			ld (debug_mark+1),a  
3dd1 3a db 3d			ld a, (.dmark+2)  
3dd4 32 73 ee			ld (debug_mark+2),a  
3dd7 18 03			jr .pastdmark  
3dd9 ..			.dmark: db "CDP"  
3ddc f1			.pastdmark: pop af  
3ddd			endm  
# End of macro DMARK
3ddd						CALLMONITOR 
3ddd cd ae 15			call break_point_state  
3de0				endm  
# End of macro CALLMONITOR
3de0					endif 
3de0 cd 80 0b				call clear_display 
3de3 cd 9f 1a				call dumpcont	 
3de6 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3de7					NEXTW 
3de7 c3 c5 1f			jp macro_next 
3dea				endm 
# End of macro NEXTW
3dea			 
3dea			 
3dea			 
3dea			 
3dea			.DAT: 
3dea				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3dea 3d				db WORD_SYS_CORE+41             
3deb 40 3e			dw .HOME            
3ded 03				db 2 + 1 
3dee .. 00			db "AT",0              
3df1				endm 
# End of macro CWHEAD
3df1			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3df1					if DEBUG_FORTH_WORDS_KEY 
3df1						DMARK "AT." 
3df1 f5				push af  
3df2 3a 06 3e			ld a, (.dmark)  
3df5 32 71 ee			ld (debug_mark),a  
3df8 3a 07 3e			ld a, (.dmark+1)  
3dfb 32 72 ee			ld (debug_mark+1),a  
3dfe 3a 08 3e			ld a, (.dmark+2)  
3e01 32 73 ee			ld (debug_mark+2),a  
3e04 18 03			jr .pastdmark  
3e06 ..			.dmark: db "AT."  
3e09 f1			.pastdmark: pop af  
3e0a			endm  
# End of macro DMARK
3e0a						CALLMONITOR 
3e0a cd ae 15			call break_point_state  
3e0d				endm  
# End of macro CALLMONITOR
3e0d					endif 
3e0d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e0d cd 16 1e			call macro_dsp_valuehl 
3e10				endm 
# End of macro FORTH_DSP_VALUEHL
3e10			 
3e10			 
3e10					; TODO save cursor row 
3e10 7d					ld a,l 
3e11 fe 02				cp 2 
3e13 20 04				jr nz, .crow3 
3e15 3e 28				ld a, display_row_2 
3e17 18 12				jr .ccol1 
3e19 fe 03		.crow3:		cp 3 
3e1b 20 04				jr nz, .crow4 
3e1d 3e 50				ld a, display_row_3 
3e1f 18 0a				jr .ccol1 
3e21 fe 04		.crow4:		cp 4 
3e23 20 04				jr nz, .crow1 
3e25 3e 78				ld a, display_row_4 
3e27 18 02				jr .ccol1 
3e29 3e 00		.crow1:		ld a,display_row_1 
3e2b f5			.ccol1:		push af			; got row offset 
3e2c 6f					ld l,a 
3e2d 26 00				ld h,0 
3e2f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e2f cd ce 1e			call macro_forth_dsp_pop 
3e32				endm 
# End of macro FORTH_DSP_POP
3e32					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e32 cd 16 1e			call macro_dsp_valuehl 
3e35				endm 
# End of macro FORTH_DSP_VALUEHL
3e35					; TODO save cursor col 
3e35 f1					pop af 
3e36 85					add l		; add col offset 
3e37 32 68 ea				ld (f_cursor_ptr), a 
3e3a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e3a cd ce 1e			call macro_forth_dsp_pop 
3e3d				endm 
# End of macro FORTH_DSP_POP
3e3d			 
3e3d					; calculate  
3e3d			 
3e3d					NEXTW 
3e3d c3 c5 1f			jp macro_next 
3e40				endm 
# End of macro NEXTW
3e40			 
3e40			 
3e40			.HOME: 
3e40				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3e40 41				db WORD_SYS_CORE+45             
3e41 6d 3e			dw .SPACE            
3e43 05				db 4 + 1 
3e44 .. 00			db "HOME",0              
3e49				endm 
# End of macro CWHEAD
3e49			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3e49					if DEBUG_FORTH_WORDS_KEY 
3e49						DMARK "HOM" 
3e49 f5				push af  
3e4a 3a 5e 3e			ld a, (.dmark)  
3e4d 32 71 ee			ld (debug_mark),a  
3e50 3a 5f 3e			ld a, (.dmark+1)  
3e53 32 72 ee			ld (debug_mark+1),a  
3e56 3a 60 3e			ld a, (.dmark+2)  
3e59 32 73 ee			ld (debug_mark+2),a  
3e5c 18 03			jr .pastdmark  
3e5e ..			.dmark: db "HOM"  
3e61 f1			.pastdmark: pop af  
3e62			endm  
# End of macro DMARK
3e62						CALLMONITOR 
3e62 cd ae 15			call break_point_state  
3e65				endm  
# End of macro CALLMONITOR
3e65					endif 
3e65 3e 00		.home:		ld a, 0		; and home cursor 
3e67 32 68 ea				ld (f_cursor_ptr), a 
3e6a					NEXTW 
3e6a c3 c5 1f			jp macro_next 
3e6d				endm 
# End of macro NEXTW
3e6d			 
3e6d			 
3e6d			.SPACE: 
3e6d				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3e6d 46				db WORD_SYS_CORE+50             
3e6e 9b 3e			dw .SPACES            
3e70 03				db 2 + 1 
3e71 .. 00			db "BL",0              
3e74				endm 
# End of macro CWHEAD
3e74			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3e74					if DEBUG_FORTH_WORDS_KEY 
3e74						DMARK "BL." 
3e74 f5				push af  
3e75 3a 89 3e			ld a, (.dmark)  
3e78 32 71 ee			ld (debug_mark),a  
3e7b 3a 8a 3e			ld a, (.dmark+1)  
3e7e 32 72 ee			ld (debug_mark+1),a  
3e81 3a 8b 3e			ld a, (.dmark+2)  
3e84 32 73 ee			ld (debug_mark+2),a  
3e87 18 03			jr .pastdmark  
3e89 ..			.dmark: db "BL."  
3e8c f1			.pastdmark: pop af  
3e8d			endm  
# End of macro DMARK
3e8d						CALLMONITOR 
3e8d cd ae 15			call break_point_state  
3e90				endm  
# End of macro CALLMONITOR
3e90					endif 
3e90 21 99 3e				ld hl, .blstr 
3e93 cd 8d 1c				call forth_push_str 
3e96					 
3e96				       NEXTW 
3e96 c3 c5 1f			jp macro_next 
3e99				endm 
# End of macro NEXTW
3e99			 
3e99 .. 00		.blstr: db " ", 0 
3e9b			 
3e9b			.SPACES: 
3e9b				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3e9b 47				db WORD_SYS_CORE+51             
3e9c 36 3f			dw .SCROLL            
3e9e 07				db 6 + 1 
3e9f .. 00			db "SPACES",0              
3ea6				endm 
# End of macro CWHEAD
3ea6			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3ea6					if DEBUG_FORTH_WORDS_KEY 
3ea6						DMARK "SPS" 
3ea6 f5				push af  
3ea7 3a bb 3e			ld a, (.dmark)  
3eaa 32 71 ee			ld (debug_mark),a  
3ead 3a bc 3e			ld a, (.dmark+1)  
3eb0 32 72 ee			ld (debug_mark+1),a  
3eb3 3a bd 3e			ld a, (.dmark+2)  
3eb6 32 73 ee			ld (debug_mark+2),a  
3eb9 18 03			jr .pastdmark  
3ebb ..			.dmark: db "SPS"  
3ebe f1			.pastdmark: pop af  
3ebf			endm  
# End of macro DMARK
3ebf						CALLMONITOR 
3ebf cd ae 15			call break_point_state  
3ec2				endm  
# End of macro CALLMONITOR
3ec2					endif 
3ec2			 
3ec2			 
3ec2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ec2 cd 16 1e			call macro_dsp_valuehl 
3ec5				endm 
# End of macro FORTH_DSP_VALUEHL
3ec5			 
3ec5			;		push hl    ; u 
3ec5					if DEBUG_FORTH_WORDS 
3ec5						DMARK "SPA" 
3ec5 f5				push af  
3ec6 3a da 3e			ld a, (.dmark)  
3ec9 32 71 ee			ld (debug_mark),a  
3ecc 3a db 3e			ld a, (.dmark+1)  
3ecf 32 72 ee			ld (debug_mark+1),a  
3ed2 3a dc 3e			ld a, (.dmark+2)  
3ed5 32 73 ee			ld (debug_mark+2),a  
3ed8 18 03			jr .pastdmark  
3eda ..			.dmark: db "SPA"  
3edd f1			.pastdmark: pop af  
3ede			endm  
# End of macro DMARK
3ede						CALLMONITOR 
3ede cd ae 15			call break_point_state  
3ee1				endm  
# End of macro CALLMONITOR
3ee1					endif 
3ee1			 
3ee1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ee1 cd ce 1e			call macro_forth_dsp_pop 
3ee4				endm 
# End of macro FORTH_DSP_POP
3ee4			;		pop hl 
3ee4 4d					ld c, l 
3ee5 06 00				ld b, 0 
3ee7 21 cb e2				ld hl, scratch  
3eea			 
3eea					if DEBUG_FORTH_WORDS 
3eea						DMARK "SP2" 
3eea f5				push af  
3eeb 3a ff 3e			ld a, (.dmark)  
3eee 32 71 ee			ld (debug_mark),a  
3ef1 3a 00 3f			ld a, (.dmark+1)  
3ef4 32 72 ee			ld (debug_mark+1),a  
3ef7 3a 01 3f			ld a, (.dmark+2)  
3efa 32 73 ee			ld (debug_mark+2),a  
3efd 18 03			jr .pastdmark  
3eff ..			.dmark: db "SP2"  
3f02 f1			.pastdmark: pop af  
3f03			endm  
# End of macro DMARK
3f03						CALLMONITOR 
3f03 cd ae 15			call break_point_state  
3f06				endm  
# End of macro CALLMONITOR
3f06					endif 
3f06 3e 20				ld a, ' ' 
3f08 c5			.spaces1:	push bc 
3f09 77					ld (hl),a 
3f0a 23					inc hl 
3f0b c1					pop bc 
3f0c 10 fa				djnz .spaces1 
3f0e 3e 00				ld a,0 
3f10 77					ld (hl),a 
3f11 21 cb e2				ld hl, scratch 
3f14					if DEBUG_FORTH_WORDS 
3f14						DMARK "SP3" 
3f14 f5				push af  
3f15 3a 29 3f			ld a, (.dmark)  
3f18 32 71 ee			ld (debug_mark),a  
3f1b 3a 2a 3f			ld a, (.dmark+1)  
3f1e 32 72 ee			ld (debug_mark+1),a  
3f21 3a 2b 3f			ld a, (.dmark+2)  
3f24 32 73 ee			ld (debug_mark+2),a  
3f27 18 03			jr .pastdmark  
3f29 ..			.dmark: db "SP3"  
3f2c f1			.pastdmark: pop af  
3f2d			endm  
# End of macro DMARK
3f2d						CALLMONITOR 
3f2d cd ae 15			call break_point_state  
3f30				endm  
# End of macro CALLMONITOR
3f30					endif 
3f30 cd 88 1d				call forth_apush 
3f33			 
3f33				       NEXTW 
3f33 c3 c5 1f			jp macro_next 
3f36				endm 
# End of macro NEXTW
3f36			 
3f36			 
3f36			 
3f36			.SCROLL: 
3f36				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3f36 53				db WORD_SYS_CORE+63             
3f37 63 3f			dw .SCROLLD            
3f39 07				db 6 + 1 
3f3a .. 00			db "SCROLL",0              
3f41				endm 
# End of macro CWHEAD
3f41			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3f41					if DEBUG_FORTH_WORDS_KEY 
3f41						DMARK "SCR" 
3f41 f5				push af  
3f42 3a 56 3f			ld a, (.dmark)  
3f45 32 71 ee			ld (debug_mark),a  
3f48 3a 57 3f			ld a, (.dmark+1)  
3f4b 32 72 ee			ld (debug_mark+1),a  
3f4e 3a 58 3f			ld a, (.dmark+2)  
3f51 32 73 ee			ld (debug_mark+2),a  
3f54 18 03			jr .pastdmark  
3f56 ..			.dmark: db "SCR"  
3f59 f1			.pastdmark: pop af  
3f5a			endm  
# End of macro DMARK
3f5a						CALLMONITOR 
3f5a cd ae 15			call break_point_state  
3f5d				endm  
# End of macro CALLMONITOR
3f5d					endif 
3f5d			 
3f5d cd 42 0b			call scroll_up 
3f60			;	call update_display 
3f60			 
3f60					NEXTW 
3f60 c3 c5 1f			jp macro_next 
3f63				endm 
# End of macro NEXTW
3f63			 
3f63			 
3f63			 
3f63			;		; get dir 
3f63			; 
3f63			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f63			; 
3f63			;		push hl 
3f63			; 
3f63			;		; destroy value TOS 
3f63			; 
3f63			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f63			; 
3f63			;		; get count 
3f63			; 
3f63			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f63			; 
3f63			;		push hl 
3f63			; 
3f63			;		; destroy value TOS 
3f63			; 
3f63			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f63			; 
3f63			;		; one value on hl get other one back 
3f63			; 
3f63			;		pop bc    ; count 
3f63			; 
3f63			;		pop de   ; dir 
3f63			; 
3f63			; 
3f63			;		ld b, c 
3f63			; 
3f63			;.scrolldir:     push bc 
3f63			;		push de 
3f63			; 
3f63			;		ld a, 0 
3f63			;		cp e 
3f63			;		jr z, .scrollup  
3f63			;		call scroll_down 
3f63			;		jr .scrollnext 
3f63			;.scrollup:	call scroll_up 
3f63			; 
3f63			;		 
3f63			;.scrollnext: 
3f63			;		pop de 
3f63			;		pop bc 
3f63			;		djnz .scrolldir 
3f63			; 
3f63			; 
3f63			; 
3f63			; 
3f63			; 
3f63			;		NEXTW 
3f63			 
3f63			.SCROLLD: 
3f63				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3f63 53				db WORD_SYS_CORE+63             
3f64 91 3f			dw .ATQ            
3f66 08				db 7 + 1 
3f67 .. 00			db "SCROLLD",0              
3f6f				endm 
# End of macro CWHEAD
3f6f			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3f6f					if DEBUG_FORTH_WORDS_KEY 
3f6f						DMARK "SCD" 
3f6f f5				push af  
3f70 3a 84 3f			ld a, (.dmark)  
3f73 32 71 ee			ld (debug_mark),a  
3f76 3a 85 3f			ld a, (.dmark+1)  
3f79 32 72 ee			ld (debug_mark+1),a  
3f7c 3a 86 3f			ld a, (.dmark+2)  
3f7f 32 73 ee			ld (debug_mark+2),a  
3f82 18 03			jr .pastdmark  
3f84 ..			.dmark: db "SCD"  
3f87 f1			.pastdmark: pop af  
3f88			endm  
# End of macro DMARK
3f88						CALLMONITOR 
3f88 cd ae 15			call break_point_state  
3f8b				endm  
# End of macro CALLMONITOR
3f8b					endif 
3f8b			 
3f8b cd 66 0b			call scroll_down 
3f8e			;	call update_display 
3f8e			 
3f8e					NEXTW 
3f8e c3 c5 1f			jp macro_next 
3f91				endm 
# End of macro NEXTW
3f91			 
3f91			 
3f91			.ATQ: 
3f91				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3f91 62				db WORD_SYS_CORE+78             
3f92 ef 3f			dw .AUTODSP            
3f94 04				db 3 + 1 
3f95 .. 00			db "AT@",0              
3f99				endm 
# End of macro CWHEAD
3f99			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3f99					if DEBUG_FORTH_WORDS_KEY 
3f99						DMARK "ATA" 
3f99 f5				push af  
3f9a 3a ae 3f			ld a, (.dmark)  
3f9d 32 71 ee			ld (debug_mark),a  
3fa0 3a af 3f			ld a, (.dmark+1)  
3fa3 32 72 ee			ld (debug_mark+1),a  
3fa6 3a b0 3f			ld a, (.dmark+2)  
3fa9 32 73 ee			ld (debug_mark+2),a  
3fac 18 03			jr .pastdmark  
3fae ..			.dmark: db "ATA"  
3fb1 f1			.pastdmark: pop af  
3fb2			endm  
# End of macro DMARK
3fb2						CALLMONITOR 
3fb2 cd ae 15			call break_point_state  
3fb5				endm  
# End of macro CALLMONITOR
3fb5					endif 
3fb5			 
3fb5			 
3fb5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fb5 cd 16 1e			call macro_dsp_valuehl 
3fb8				endm 
# End of macro FORTH_DSP_VALUEHL
3fb8			 
3fb8					; TODO save cursor row 
3fb8 7d					ld a,l 
3fb9 fe 02				cp 2 
3fbb 20 04				jr nz, .crow3aq 
3fbd 3e 28				ld a, display_row_2 
3fbf 18 12				jr .ccol1aq 
3fc1 fe 03		.crow3aq:		cp 3 
3fc3 20 04				jr nz, .crow4aq 
3fc5 3e 50				ld a, display_row_3 
3fc7 18 0a				jr .ccol1aq 
3fc9 fe 04		.crow4aq:		cp 4 
3fcb 20 04				jr nz, .crow1aq 
3fcd 3e 78				ld a, display_row_4 
3fcf 18 02				jr .ccol1aq 
3fd1 3e 00		.crow1aq:		ld a,display_row_1 
3fd3 f5			.ccol1aq:		push af			; got row offset 
3fd4 6f					ld l,a 
3fd5 26 00				ld h,0 
3fd7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fd7 cd ce 1e			call macro_forth_dsp_pop 
3fda				endm 
# End of macro FORTH_DSP_POP
3fda					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fda cd 16 1e			call macro_dsp_valuehl 
3fdd				endm 
# End of macro FORTH_DSP_VALUEHL
3fdd					; TODO save cursor col 
3fdd f1					pop af 
3fde 85					add l		; add col offset 
3fdf			 
3fdf					; add current frame buffer address 
3fdf 2a d2 eb				ld hl, (display_fb_active) 
3fe2 cd ad 0d				call addatohl 
3fe5			 
3fe5			 
3fe5			 
3fe5			 
3fe5					; get char frame buffer location offset in hl 
3fe5			 
3fe5 7e					ld a,(hl) 
3fe6 26 00				ld h, 0 
3fe8 6f					ld l, a 
3fe9			 
3fe9 cd 1f 1c				call forth_push_numhl 
3fec			 
3fec			 
3fec					NEXTW 
3fec c3 c5 1f			jp macro_next 
3fef				endm 
# End of macro NEXTW
3fef			 
3fef			.AUTODSP: 
3fef				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3fef 63				db WORD_SYS_CORE+79             
3ff0 05 40			dw .MENU            
3ff2 05				db 4 + 1 
3ff3 .. 00			db "ADSP",0              
3ff8				endm 
# End of macro CWHEAD
3ff8			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3ff8			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3ff8			 
3ff8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ff8 cd 16 1e			call macro_dsp_valuehl 
3ffb				endm 
# End of macro FORTH_DSP_VALUEHL
3ffb			 
3ffb			;		push hl 
3ffb			 
3ffb					; destroy value TOS 
3ffb			 
3ffb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ffb cd ce 1e			call macro_forth_dsp_pop 
3ffe				endm 
# End of macro FORTH_DSP_POP
3ffe			 
3ffe			;		pop hl 
3ffe			 
3ffe 7d					ld a,l 
3fff 32 46 ea				ld (cli_autodisplay), a 
4002				       NEXTW 
4002 c3 c5 1f			jp macro_next 
4005				endm 
# End of macro NEXTW
4005			 
4005			.MENU: 
4005				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4005 70				db WORD_SYS_CORE+92             
4006 ae 40			dw .ENDDISPLAY            
4008 05				db 4 + 1 
4009 .. 00			db "MENU",0              
400e				endm 
# End of macro CWHEAD
400e			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
400e			 
400e			;		; get number of items on the stack 
400e			; 
400e				 
400e					FORTH_DSP_VALUEHL 
400e cd 16 1e			call macro_dsp_valuehl 
4011				endm 
# End of macro FORTH_DSP_VALUEHL
4011				 
4011					if DEBUG_FORTH_WORDS_KEY 
4011						DMARK "MNU" 
4011 f5				push af  
4012 3a 26 40			ld a, (.dmark)  
4015 32 71 ee			ld (debug_mark),a  
4018 3a 27 40			ld a, (.dmark+1)  
401b 32 72 ee			ld (debug_mark+1),a  
401e 3a 28 40			ld a, (.dmark+2)  
4021 32 73 ee			ld (debug_mark+2),a  
4024 18 03			jr .pastdmark  
4026 ..			.dmark: db "MNU"  
4029 f1			.pastdmark: pop af  
402a			endm  
# End of macro DMARK
402a						CALLMONITOR 
402a cd ae 15			call break_point_state  
402d				endm  
# End of macro CALLMONITOR
402d					endif 
402d			 
402d 45					ld b, l	 
402e 05					dec b 
402f			 
402f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
402f cd ce 1e			call macro_forth_dsp_pop 
4032				endm 
# End of macro FORTH_DSP_POP
4032			 
4032			 
4032					; go directly through the stack to pluck out the string pointers and build an array 
4032			 
4032			;		FORTH_DSP 
4032			 
4032					; hl contains top most stack item 
4032				 
4032 11 cb e2				ld de, scratch 
4035			 
4035			.mbuild: 
4035			 
4035					FORTH_DSP_VALUEHL 
4035 cd 16 1e			call macro_dsp_valuehl 
4038				endm 
# End of macro FORTH_DSP_VALUEHL
4038			 
4038					if DEBUG_FORTH_WORDS 
4038						DMARK "MN3" 
4038 f5				push af  
4039 3a 4d 40			ld a, (.dmark)  
403c 32 71 ee			ld (debug_mark),a  
403f 3a 4e 40			ld a, (.dmark+1)  
4042 32 72 ee			ld (debug_mark+1),a  
4045 3a 4f 40			ld a, (.dmark+2)  
4048 32 73 ee			ld (debug_mark+2),a  
404b 18 03			jr .pastdmark  
404d ..			.dmark: db "MN3"  
4050 f1			.pastdmark: pop af  
4051			endm  
# End of macro DMARK
4051						CALLMONITOR 
4051 cd ae 15			call break_point_state  
4054				endm  
# End of macro CALLMONITOR
4054					endif 
4054 eb					ex de, hl 
4055 73					ld (hl), e 
4056 23					inc hl 
4057 72					ld (hl), d 
4058 23					inc hl 
4059 eb					ex de, hl 
405a			 
405a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
405a cd ce 1e			call macro_forth_dsp_pop 
405d				endm 
# End of macro FORTH_DSP_POP
405d			 
405d 10 d6				djnz .mbuild 
405f			 
405f					; done add term 
405f			 
405f eb					ex de, hl 
4060 36 00				ld (hl), 0 
4062 23					inc hl 
4063 36 00				ld (hl), 0 
4065			 
4065				 
4065					 
4065 21 cb e2				ld hl, scratch 
4068			 
4068					if DEBUG_FORTH_WORDS 
4068						DMARK "MNx" 
4068 f5				push af  
4069 3a 7d 40			ld a, (.dmark)  
406c 32 71 ee			ld (debug_mark),a  
406f 3a 7e 40			ld a, (.dmark+1)  
4072 32 72 ee			ld (debug_mark+1),a  
4075 3a 7f 40			ld a, (.dmark+2)  
4078 32 73 ee			ld (debug_mark+2),a  
407b 18 03			jr .pastdmark  
407d ..			.dmark: db "MNx"  
4080 f1			.pastdmark: pop af  
4081			endm  
# End of macro DMARK
4081						CALLMONITOR 
4081 cd ae 15			call break_point_state  
4084				endm  
# End of macro CALLMONITOR
4084					endif 
4084			 
4084			 
4084			 
4084 3e 00				ld a, 0 
4086 cd b1 0b				call menu 
4089			 
4089			 
4089 6f					ld l, a 
408a 26 00				ld h, 0 
408c			 
408c					if DEBUG_FORTH_WORDS 
408c						DMARK "MNr" 
408c f5				push af  
408d 3a a1 40			ld a, (.dmark)  
4090 32 71 ee			ld (debug_mark),a  
4093 3a a2 40			ld a, (.dmark+1)  
4096 32 72 ee			ld (debug_mark+1),a  
4099 3a a3 40			ld a, (.dmark+2)  
409c 32 73 ee			ld (debug_mark+2),a  
409f 18 03			jr .pastdmark  
40a1 ..			.dmark: db "MNr"  
40a4 f1			.pastdmark: pop af  
40a5			endm  
# End of macro DMARK
40a5						CALLMONITOR 
40a5 cd ae 15			call break_point_state  
40a8				endm  
# End of macro CALLMONITOR
40a8					endif 
40a8			 
40a8 cd 1f 1c				call forth_push_numhl 
40ab			 
40ab			 
40ab			 
40ab			 
40ab				       NEXTW 
40ab c3 c5 1f			jp macro_next 
40ae				endm 
# End of macro NEXTW
40ae			 
40ae			 
40ae			.ENDDISPLAY: 
40ae			 
40ae			; eof 
# End of file forth_words_display.asm
40ae			include "forth_words_str.asm" 
40ae			 
40ae			; | ## String Words 
40ae			 
40ae			.PTR:   
40ae			 
40ae				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
40ae 48				db WORD_SYS_CORE+52             
40af db 40			dw .STYPE            
40b1 04				db 3 + 1 
40b2 .. 00			db "PTR",0              
40b6				endm 
# End of macro CWHEAD
40b6			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
40b6			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
40b6			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
40b6			 
40b6					if DEBUG_FORTH_WORDS_KEY 
40b6						DMARK "PTR" 
40b6 f5				push af  
40b7 3a cb 40			ld a, (.dmark)  
40ba 32 71 ee			ld (debug_mark),a  
40bd 3a cc 40			ld a, (.dmark+1)  
40c0 32 72 ee			ld (debug_mark+1),a  
40c3 3a cd 40			ld a, (.dmark+2)  
40c6 32 73 ee			ld (debug_mark+2),a  
40c9 18 03			jr .pastdmark  
40cb ..			.dmark: db "PTR"  
40ce f1			.pastdmark: pop af  
40cf			endm  
# End of macro DMARK
40cf						CALLMONITOR 
40cf cd ae 15			call break_point_state  
40d2				endm  
# End of macro CALLMONITOR
40d2					endif 
40d2					FORTH_DSP_VALUEHL 
40d2 cd 16 1e			call macro_dsp_valuehl 
40d5				endm 
# End of macro FORTH_DSP_VALUEHL
40d5 cd 1f 1c				call forth_push_numhl 
40d8			 
40d8			 
40d8					NEXTW 
40d8 c3 c5 1f			jp macro_next 
40db				endm 
# End of macro NEXTW
40db			.STYPE: 
40db				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
40db 48				db WORD_SYS_CORE+52             
40dc 2a 41			dw .UPPER            
40de 06				db 5 + 1 
40df .. 00			db "STYPE",0              
40e5				endm 
# End of macro CWHEAD
40e5			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
40e5					if DEBUG_FORTH_WORDS_KEY 
40e5						DMARK "STY" 
40e5 f5				push af  
40e6 3a fa 40			ld a, (.dmark)  
40e9 32 71 ee			ld (debug_mark),a  
40ec 3a fb 40			ld a, (.dmark+1)  
40ef 32 72 ee			ld (debug_mark+1),a  
40f2 3a fc 40			ld a, (.dmark+2)  
40f5 32 73 ee			ld (debug_mark+2),a  
40f8 18 03			jr .pastdmark  
40fa ..			.dmark: db "STY"  
40fd f1			.pastdmark: pop af  
40fe			endm  
# End of macro DMARK
40fe						CALLMONITOR 
40fe cd ae 15			call break_point_state  
4101				endm  
# End of macro CALLMONITOR
4101					endif 
4101					FORTH_DSP 
4101 cd dc 1d			call macro_forth_dsp 
4104				endm 
# End of macro FORTH_DSP
4104					;v5 FORTH_DSP_VALUE 
4104			 
4104 7e					ld a, (hl) 
4105			 
4105 f5					push af 
4106			 
4106			; Dont destroy TOS		FORTH_DSP_POP 
4106			 
4106 f1					pop af 
4107			 
4107 fe 01				cp DS_TYPE_STR 
4109 28 09				jr z, .typestr 
410b			 
410b fe 02				cp DS_TYPE_INUM 
410d 28 0a				jr z, .typeinum 
410f			 
410f 21 28 41				ld hl, .tna 
4112 18 0a				jr .tpush 
4114			 
4114 21 24 41		.typestr:	ld hl, .tstr 
4117 18 05				jr .tpush 
4119 21 26 41		.typeinum:	ld hl, .tinum 
411c 18 00				jr .tpush 
411e			 
411e			.tpush: 
411e			 
411e cd 8d 1c				call forth_push_str 
4121			 
4121					NEXTW 
4121 c3 c5 1f			jp macro_next 
4124				endm 
# End of macro NEXTW
4124 .. 00		.tstr:	db "s",0 
4126 .. 00		.tinum:  db "i",0 
4128 .. 00		.tna:   db "?", 0 
412a			 
412a			 
412a			.UPPER: 
412a				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
412a 48				db WORD_SYS_CORE+52             
412b 65 41			dw .LOWER            
412d 06				db 5 + 1 
412e .. 00			db "UPPER",0              
4134				endm 
# End of macro CWHEAD
4134			; | UPPER ( s -- s ) Upper case string s  | DONE 
4134					if DEBUG_FORTH_WORDS_KEY 
4134						DMARK "UPR" 
4134 f5				push af  
4135 3a 49 41			ld a, (.dmark)  
4138 32 71 ee			ld (debug_mark),a  
413b 3a 4a 41			ld a, (.dmark+1)  
413e 32 72 ee			ld (debug_mark+1),a  
4141 3a 4b 41			ld a, (.dmark+2)  
4144 32 73 ee			ld (debug_mark+2),a  
4147 18 03			jr .pastdmark  
4149 ..			.dmark: db "UPR"  
414c f1			.pastdmark: pop af  
414d			endm  
# End of macro DMARK
414d						CALLMONITOR 
414d cd ae 15			call break_point_state  
4150				endm  
# End of macro CALLMONITOR
4150					endif 
4150			 
4150					FORTH_DSP 
4150 cd dc 1d			call macro_forth_dsp 
4153				endm 
# End of macro FORTH_DSP
4153					 
4153			; TODO check is string type 
4153			 
4153					FORTH_DSP_VALUEHL 
4153 cd 16 1e			call macro_dsp_valuehl 
4156				endm 
# End of macro FORTH_DSP_VALUEHL
4156			; get pointer to string in hl 
4156			 
4156 7e			.toup:		ld a, (hl) 
4157 fe 00				cp 0 
4159 28 07				jr z, .toupdone 
415b			 
415b cd 1a 11				call to_upper 
415e			 
415e 77					ld (hl), a 
415f 23					inc hl 
4160 18 f4				jr .toup 
4162			 
4162					 
4162			 
4162			 
4162			; for each char convert to upper 
4162					 
4162			.toupdone: 
4162			 
4162			 
4162					NEXTW 
4162 c3 c5 1f			jp macro_next 
4165				endm 
# End of macro NEXTW
4165			.LOWER: 
4165				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4165 48				db WORD_SYS_CORE+52             
4166 a0 41			dw .TCASE            
4168 06				db 5 + 1 
4169 .. 00			db "LOWER",0              
416f				endm 
# End of macro CWHEAD
416f			; | LOWER ( s -- s ) Lower case string s  | DONE 
416f					if DEBUG_FORTH_WORDS_KEY 
416f						DMARK "LWR" 
416f f5				push af  
4170 3a 84 41			ld a, (.dmark)  
4173 32 71 ee			ld (debug_mark),a  
4176 3a 85 41			ld a, (.dmark+1)  
4179 32 72 ee			ld (debug_mark+1),a  
417c 3a 86 41			ld a, (.dmark+2)  
417f 32 73 ee			ld (debug_mark+2),a  
4182 18 03			jr .pastdmark  
4184 ..			.dmark: db "LWR"  
4187 f1			.pastdmark: pop af  
4188			endm  
# End of macro DMARK
4188						CALLMONITOR 
4188 cd ae 15			call break_point_state  
418b				endm  
# End of macro CALLMONITOR
418b					endif 
418b			 
418b					FORTH_DSP 
418b cd dc 1d			call macro_forth_dsp 
418e				endm 
# End of macro FORTH_DSP
418e					 
418e			; TODO check is string type 
418e			 
418e					FORTH_DSP_VALUEHL 
418e cd 16 1e			call macro_dsp_valuehl 
4191				endm 
# End of macro FORTH_DSP_VALUEHL
4191			; get pointer to string in hl 
4191			 
4191 7e			.tolow:		ld a, (hl) 
4192 fe 00				cp 0 
4194 28 07				jr z, .tolowdone 
4196			 
4196 cd 23 11				call to_lower 
4199			 
4199 77					ld (hl), a 
419a 23					inc hl 
419b 18 f4				jr .tolow 
419d			 
419d					 
419d			 
419d			 
419d			; for each char convert to low 
419d					 
419d			.tolowdone: 
419d					NEXTW 
419d c3 c5 1f			jp macro_next 
41a0				endm 
# End of macro NEXTW
41a0			.TCASE: 
41a0				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
41a0 48				db WORD_SYS_CORE+52             
41a1 d6 42			dw .SUBSTR            
41a3 06				db 5 + 1 
41a4 .. 00			db "TCASE",0              
41aa				endm 
# End of macro CWHEAD
41aa			; | TCASE ( s -- s ) Title case string s  | DONE 
41aa					if DEBUG_FORTH_WORDS_KEY 
41aa						DMARK "TCS" 
41aa f5				push af  
41ab 3a bf 41			ld a, (.dmark)  
41ae 32 71 ee			ld (debug_mark),a  
41b1 3a c0 41			ld a, (.dmark+1)  
41b4 32 72 ee			ld (debug_mark+1),a  
41b7 3a c1 41			ld a, (.dmark+2)  
41ba 32 73 ee			ld (debug_mark+2),a  
41bd 18 03			jr .pastdmark  
41bf ..			.dmark: db "TCS"  
41c2 f1			.pastdmark: pop af  
41c3			endm  
# End of macro DMARK
41c3						CALLMONITOR 
41c3 cd ae 15			call break_point_state  
41c6				endm  
# End of macro CALLMONITOR
41c6					endif 
41c6			 
41c6					FORTH_DSP 
41c6 cd dc 1d			call macro_forth_dsp 
41c9				endm 
# End of macro FORTH_DSP
41c9					 
41c9			; TODO check is string type 
41c9			 
41c9					FORTH_DSP_VALUEHL 
41c9 cd 16 1e			call macro_dsp_valuehl 
41cc				endm 
# End of macro FORTH_DSP_VALUEHL
41cc			; get pointer to string in hl 
41cc			 
41cc					if DEBUG_FORTH_WORDS 
41cc						DMARK "TC1" 
41cc f5				push af  
41cd 3a e1 41			ld a, (.dmark)  
41d0 32 71 ee			ld (debug_mark),a  
41d3 3a e2 41			ld a, (.dmark+1)  
41d6 32 72 ee			ld (debug_mark+1),a  
41d9 3a e3 41			ld a, (.dmark+2)  
41dc 32 73 ee			ld (debug_mark+2),a  
41df 18 03			jr .pastdmark  
41e1 ..			.dmark: db "TC1"  
41e4 f1			.pastdmark: pop af  
41e5			endm  
# End of macro DMARK
41e5						CALLMONITOR 
41e5 cd ae 15			call break_point_state  
41e8				endm  
# End of macro CALLMONITOR
41e8					endif 
41e8			 
41e8					; first time in turn to upper case first char 
41e8			 
41e8 7e					ld a, (hl) 
41e9 c3 73 42				jp .totsiptou 
41ec			 
41ec			 
41ec 7e			.tot:		ld a, (hl) 
41ed fe 00				cp 0 
41ef ca b7 42				jp z, .totdone 
41f2			 
41f2					if DEBUG_FORTH_WORDS 
41f2						DMARK "TC2" 
41f2 f5				push af  
41f3 3a 07 42			ld a, (.dmark)  
41f6 32 71 ee			ld (debug_mark),a  
41f9 3a 08 42			ld a, (.dmark+1)  
41fc 32 72 ee			ld (debug_mark+1),a  
41ff 3a 09 42			ld a, (.dmark+2)  
4202 32 73 ee			ld (debug_mark+2),a  
4205 18 03			jr .pastdmark  
4207 ..			.dmark: db "TC2"  
420a f1			.pastdmark: pop af  
420b			endm  
# End of macro DMARK
420b						CALLMONITOR 
420b cd ae 15			call break_point_state  
420e				endm  
# End of macro CALLMONITOR
420e					endif 
420e					; check to see if current char is a space 
420e			 
420e fe 20				cp ' ' 
4210 28 21				jr z, .totsp 
4212 cd 23 11				call to_lower 
4215					if DEBUG_FORTH_WORDS 
4215						DMARK "TC3" 
4215 f5				push af  
4216 3a 2a 42			ld a, (.dmark)  
4219 32 71 ee			ld (debug_mark),a  
421c 3a 2b 42			ld a, (.dmark+1)  
421f 32 72 ee			ld (debug_mark+1),a  
4222 3a 2c 42			ld a, (.dmark+2)  
4225 32 73 ee			ld (debug_mark+2),a  
4228 18 03			jr .pastdmark  
422a ..			.dmark: db "TC3"  
422d f1			.pastdmark: pop af  
422e			endm  
# End of macro DMARK
422e						CALLMONITOR 
422e cd ae 15			call break_point_state  
4231				endm  
# End of macro CALLMONITOR
4231					endif 
4231 18 63				jr .totnxt 
4233			 
4233			.totsp:         ; on a space, find next char which should be upper 
4233			 
4233					if DEBUG_FORTH_WORDS 
4233						DMARK "TC4" 
4233 f5				push af  
4234 3a 48 42			ld a, (.dmark)  
4237 32 71 ee			ld (debug_mark),a  
423a 3a 49 42			ld a, (.dmark+1)  
423d 32 72 ee			ld (debug_mark+1),a  
4240 3a 4a 42			ld a, (.dmark+2)  
4243 32 73 ee			ld (debug_mark+2),a  
4246 18 03			jr .pastdmark  
4248 ..			.dmark: db "TC4"  
424b f1			.pastdmark: pop af  
424c			endm  
# End of macro DMARK
424c						CALLMONITOR 
424c cd ae 15			call break_point_state  
424f				endm  
# End of macro CALLMONITOR
424f					endif 
424f					;; 
424f			 
424f fe 20				cp ' ' 
4251 20 20				jr nz, .totsiptou 
4253 23					inc hl 
4254 7e					ld a, (hl) 
4255					if DEBUG_FORTH_WORDS 
4255						DMARK "TC5" 
4255 f5				push af  
4256 3a 6a 42			ld a, (.dmark)  
4259 32 71 ee			ld (debug_mark),a  
425c 3a 6b 42			ld a, (.dmark+1)  
425f 32 72 ee			ld (debug_mark+1),a  
4262 3a 6c 42			ld a, (.dmark+2)  
4265 32 73 ee			ld (debug_mark+2),a  
4268 18 03			jr .pastdmark  
426a ..			.dmark: db "TC5"  
426d f1			.pastdmark: pop af  
426e			endm  
# End of macro DMARK
426e						CALLMONITOR 
426e cd ae 15			call break_point_state  
4271				endm  
# End of macro CALLMONITOR
4271					endif 
4271 18 c0				jr .totsp 
4273 fe 00		.totsiptou:    cp 0 
4275 28 40				jr z, .totdone 
4277					; not space and not zero term so upper case it 
4277 cd 1a 11				call to_upper 
427a			 
427a					if DEBUG_FORTH_WORDS 
427a						DMARK "TC6" 
427a f5				push af  
427b 3a 8f 42			ld a, (.dmark)  
427e 32 71 ee			ld (debug_mark),a  
4281 3a 90 42			ld a, (.dmark+1)  
4284 32 72 ee			ld (debug_mark+1),a  
4287 3a 91 42			ld a, (.dmark+2)  
428a 32 73 ee			ld (debug_mark+2),a  
428d 18 03			jr .pastdmark  
428f ..			.dmark: db "TC6"  
4292 f1			.pastdmark: pop af  
4293			endm  
# End of macro DMARK
4293						CALLMONITOR 
4293 cd ae 15			call break_point_state  
4296				endm  
# End of macro CALLMONITOR
4296					endif 
4296			 
4296			 
4296			.totnxt: 
4296			 
4296 77					ld (hl), a 
4297 23					inc hl 
4298					if DEBUG_FORTH_WORDS 
4298						DMARK "TC7" 
4298 f5				push af  
4299 3a ad 42			ld a, (.dmark)  
429c 32 71 ee			ld (debug_mark),a  
429f 3a ae 42			ld a, (.dmark+1)  
42a2 32 72 ee			ld (debug_mark+1),a  
42a5 3a af 42			ld a, (.dmark+2)  
42a8 32 73 ee			ld (debug_mark+2),a  
42ab 18 03			jr .pastdmark  
42ad ..			.dmark: db "TC7"  
42b0 f1			.pastdmark: pop af  
42b1			endm  
# End of macro DMARK
42b1						CALLMONITOR 
42b1 cd ae 15			call break_point_state  
42b4				endm  
# End of macro CALLMONITOR
42b4					endif 
42b4 c3 ec 41				jp .tot 
42b7			 
42b7					 
42b7			 
42b7			 
42b7			; for each char convert to low 
42b7					 
42b7			.totdone: 
42b7					if DEBUG_FORTH_WORDS 
42b7						DMARK "TCd" 
42b7 f5				push af  
42b8 3a cc 42			ld a, (.dmark)  
42bb 32 71 ee			ld (debug_mark),a  
42be 3a cd 42			ld a, (.dmark+1)  
42c1 32 72 ee			ld (debug_mark+1),a  
42c4 3a ce 42			ld a, (.dmark+2)  
42c7 32 73 ee			ld (debug_mark+2),a  
42ca 18 03			jr .pastdmark  
42cc ..			.dmark: db "TCd"  
42cf f1			.pastdmark: pop af  
42d0			endm  
# End of macro DMARK
42d0						CALLMONITOR 
42d0 cd ae 15			call break_point_state  
42d3				endm  
# End of macro CALLMONITOR
42d3					endif 
42d3					NEXTW 
42d3 c3 c5 1f			jp macro_next 
42d6				endm 
# End of macro NEXTW
42d6			 
42d6			.SUBSTR: 
42d6				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
42d6 48				db WORD_SYS_CORE+52             
42d7 34 43			dw .LEFT            
42d9 07				db 6 + 1 
42da .. 00			db "SUBSTR",0              
42e1				endm 
# End of macro CWHEAD
42e1			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
42e1			 
42e1					if DEBUG_FORTH_WORDS_KEY 
42e1						DMARK "SST" 
42e1 f5				push af  
42e2 3a f6 42			ld a, (.dmark)  
42e5 32 71 ee			ld (debug_mark),a  
42e8 3a f7 42			ld a, (.dmark+1)  
42eb 32 72 ee			ld (debug_mark+1),a  
42ee 3a f8 42			ld a, (.dmark+2)  
42f1 32 73 ee			ld (debug_mark+2),a  
42f4 18 03			jr .pastdmark  
42f6 ..			.dmark: db "SST"  
42f9 f1			.pastdmark: pop af  
42fa			endm  
# End of macro DMARK
42fa						CALLMONITOR 
42fa cd ae 15			call break_point_state  
42fd				endm  
# End of macro CALLMONITOR
42fd					endif 
42fd			; TODO check string type 
42fd					FORTH_DSP_VALUEHL 
42fd cd 16 1e			call macro_dsp_valuehl 
4300				endm 
# End of macro FORTH_DSP_VALUEHL
4300			 
4300 e5					push hl      ; string length 
4301			 
4301					FORTH_DSP_POP 
4301 cd ce 1e			call macro_forth_dsp_pop 
4304				endm 
# End of macro FORTH_DSP_POP
4304			 
4304					FORTH_DSP_VALUEHL 
4304 cd 16 1e			call macro_dsp_valuehl 
4307				endm 
# End of macro FORTH_DSP_VALUEHL
4307			 
4307 e5					push hl     ; start char 
4308			 
4308					FORTH_DSP_POP 
4308 cd ce 1e			call macro_forth_dsp_pop 
430b				endm 
# End of macro FORTH_DSP_POP
430b			 
430b			 
430b					FORTH_DSP_VALUE 
430b cd ff 1d			call macro_forth_dsp_value 
430e				endm 
# End of macro FORTH_DSP_VALUE
430e			 
430e d1					pop de    ; get start post offset 
430f			 
430f 19					add hl, de    ; starting offset 
4310			 
4310 c1					pop bc 
4311 c5					push bc      ; grab size of string 
4312			 
4312 e5					push hl    ; save string start  
4313			 
4313 26 00				ld h, 0 
4315 69					ld l, c 
4316 23					inc hl 
4317 23					inc hl 
4318			 
4318 cd 74 12				call malloc 
431b				if DEBUG_FORTH_MALLOC_GUARD 
431b cc a9 4a				call z,malloc_error 
431e				endif 
431e			 
431e eb					ex de, hl      ; save malloc area for string copy 
431f e1					pop hl    ; get back source 
4320 c1					pop bc    ; get length of string back 
4321			 
4321 d5					push de    ; save malloc area for after we push 
4322 ed b0				ldir     ; copy substr 
4324			 
4324			 
4324 eb					ex de, hl 
4325 3e 00				ld a, 0 
4327 77					ld (hl), a   ; term substr 
4328			 
4328					 
4328 e1					pop hl    ; get malloc so we can push it 
4329 e5					push hl   ; save so we can free it afterwards 
432a			 
432a cd 8d 1c				call forth_push_str 
432d			 
432d e1					pop hl 
432e cd 3e 13				call free 
4331			 
4331					 
4331					 
4331			 
4331			 
4331					NEXTW 
4331 c3 c5 1f			jp macro_next 
4334				endm 
# End of macro NEXTW
4334			 
4334			.LEFT: 
4334				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4334 48				db WORD_SYS_CORE+52             
4335 5c 43			dw .RIGHT            
4337 05				db 4 + 1 
4338 .. 00			db "LEFT",0              
433d				endm 
# End of macro CWHEAD
433d			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
433d					if DEBUG_FORTH_WORDS_KEY 
433d						DMARK "LEF" 
433d f5				push af  
433e 3a 52 43			ld a, (.dmark)  
4341 32 71 ee			ld (debug_mark),a  
4344 3a 53 43			ld a, (.dmark+1)  
4347 32 72 ee			ld (debug_mark+1),a  
434a 3a 54 43			ld a, (.dmark+2)  
434d 32 73 ee			ld (debug_mark+2),a  
4350 18 03			jr .pastdmark  
4352 ..			.dmark: db "LEF"  
4355 f1			.pastdmark: pop af  
4356			endm  
# End of macro DMARK
4356						CALLMONITOR 
4356 cd ae 15			call break_point_state  
4359				endm  
# End of macro CALLMONITOR
4359					endif 
4359			 
4359					NEXTW 
4359 c3 c5 1f			jp macro_next 
435c				endm 
# End of macro NEXTW
435c			.RIGHT: 
435c				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
435c 48				db WORD_SYS_CORE+52             
435d 85 43			dw .STR2NUM            
435f 06				db 5 + 1 
4360 .. 00			db "RIGHT",0              
4366				endm 
# End of macro CWHEAD
4366			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4366					if DEBUG_FORTH_WORDS_KEY 
4366						DMARK "RIG" 
4366 f5				push af  
4367 3a 7b 43			ld a, (.dmark)  
436a 32 71 ee			ld (debug_mark),a  
436d 3a 7c 43			ld a, (.dmark+1)  
4370 32 72 ee			ld (debug_mark+1),a  
4373 3a 7d 43			ld a, (.dmark+2)  
4376 32 73 ee			ld (debug_mark+2),a  
4379 18 03			jr .pastdmark  
437b ..			.dmark: db "RIG"  
437e f1			.pastdmark: pop af  
437f			endm  
# End of macro DMARK
437f						CALLMONITOR 
437f cd ae 15			call break_point_state  
4382				endm  
# End of macro CALLMONITOR
4382					endif 
4382			 
4382					NEXTW 
4382 c3 c5 1f			jp macro_next 
4385				endm 
# End of macro NEXTW
4385			 
4385			 
4385			.STR2NUM: 
4385				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4385 48				db WORD_SYS_CORE+52             
4386 11 44			dw .NUM2STR            
4388 08				db 7 + 1 
4389 .. 00			db "STR2NUM",0              
4391				endm 
# End of macro CWHEAD
4391			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4391			 
4391			 
4391			; TODO STR type check to do 
4391					if DEBUG_FORTH_WORDS_KEY 
4391						DMARK "S2N" 
4391 f5				push af  
4392 3a a6 43			ld a, (.dmark)  
4395 32 71 ee			ld (debug_mark),a  
4398 3a a7 43			ld a, (.dmark+1)  
439b 32 72 ee			ld (debug_mark+1),a  
439e 3a a8 43			ld a, (.dmark+2)  
43a1 32 73 ee			ld (debug_mark+2),a  
43a4 18 03			jr .pastdmark  
43a6 ..			.dmark: db "S2N"  
43a9 f1			.pastdmark: pop af  
43aa			endm  
# End of macro DMARK
43aa						CALLMONITOR 
43aa cd ae 15			call break_point_state  
43ad				endm  
# End of macro CALLMONITOR
43ad					endif 
43ad			 
43ad					;FORTH_DSP 
43ad					FORTH_DSP_VALUE 
43ad cd ff 1d			call macro_forth_dsp_value 
43b0				endm 
# End of macro FORTH_DSP_VALUE
43b0					;inc hl 
43b0			 
43b0 eb					ex de, hl 
43b1					if DEBUG_FORTH_WORDS 
43b1						DMARK "S2a" 
43b1 f5				push af  
43b2 3a c6 43			ld a, (.dmark)  
43b5 32 71 ee			ld (debug_mark),a  
43b8 3a c7 43			ld a, (.dmark+1)  
43bb 32 72 ee			ld (debug_mark+1),a  
43be 3a c8 43			ld a, (.dmark+2)  
43c1 32 73 ee			ld (debug_mark+2),a  
43c4 18 03			jr .pastdmark  
43c6 ..			.dmark: db "S2a"  
43c9 f1			.pastdmark: pop af  
43ca			endm  
# End of macro DMARK
43ca						CALLMONITOR 
43ca cd ae 15			call break_point_state  
43cd				endm  
# End of macro CALLMONITOR
43cd					endif 
43cd cd a2 11				call string_to_uint16 
43d0			 
43d0					if DEBUG_FORTH_WORDS 
43d0						DMARK "S2b" 
43d0 f5				push af  
43d1 3a e5 43			ld a, (.dmark)  
43d4 32 71 ee			ld (debug_mark),a  
43d7 3a e6 43			ld a, (.dmark+1)  
43da 32 72 ee			ld (debug_mark+1),a  
43dd 3a e7 43			ld a, (.dmark+2)  
43e0 32 73 ee			ld (debug_mark+2),a  
43e3 18 03			jr .pastdmark  
43e5 ..			.dmark: db "S2b"  
43e8 f1			.pastdmark: pop af  
43e9			endm  
# End of macro DMARK
43e9						CALLMONITOR 
43e9 cd ae 15			call break_point_state  
43ec				endm  
# End of macro CALLMONITOR
43ec					endif 
43ec			;		push hl 
43ec					FORTH_DSP_POP 
43ec cd ce 1e			call macro_forth_dsp_pop 
43ef				endm 
# End of macro FORTH_DSP_POP
43ef			;		pop hl 
43ef					 
43ef					if DEBUG_FORTH_WORDS 
43ef						DMARK "S2b" 
43ef f5				push af  
43f0 3a 04 44			ld a, (.dmark)  
43f3 32 71 ee			ld (debug_mark),a  
43f6 3a 05 44			ld a, (.dmark+1)  
43f9 32 72 ee			ld (debug_mark+1),a  
43fc 3a 06 44			ld a, (.dmark+2)  
43ff 32 73 ee			ld (debug_mark+2),a  
4402 18 03			jr .pastdmark  
4404 ..			.dmark: db "S2b"  
4407 f1			.pastdmark: pop af  
4408			endm  
# End of macro DMARK
4408						CALLMONITOR 
4408 cd ae 15			call break_point_state  
440b				endm  
# End of macro CALLMONITOR
440b					endif 
440b cd 1f 1c				call forth_push_numhl	 
440e			 
440e				 
440e				       NEXTW 
440e c3 c5 1f			jp macro_next 
4411				endm 
# End of macro NEXTW
4411			.NUM2STR: 
4411				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4411 48				db WORD_SYS_CORE+52             
4412 20 44			dw .CONCAT            
4414 08				db 7 + 1 
4415 .. 00			db "NUM2STR",0              
441d				endm 
# End of macro CWHEAD
441d			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
441d			 
441d			;		; malloc a string to target 
441d			;		ld hl, 10     ; TODO max string size should be fine 
441d			;		call malloc 
441d			;		push hl    ; save malloc location 
441d			; 
441d			; 
441d			;; TODO check int type 
441d			;		FORTH_DSP_VALUEHL 
441d			;		ld a, l 
441d			;		call DispAToASCII   
441d			;;TODO need to chage above call to dump into string 
441d			; 
441d			; 
441d			 
441d				       NEXTW 
441d c3 c5 1f			jp macro_next 
4420				endm 
# End of macro NEXTW
4420			 
4420			.CONCAT: 
4420				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4420 48				db WORD_SYS_CORE+52             
4421 d3 44			dw .FIND            
4423 07				db 6 + 1 
4424 .. 00			db "CONCAT",0              
442b				endm 
# End of macro CWHEAD
442b			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
442b			 
442b			; TODO check string type 
442b			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
442b			 
442b					if DEBUG_FORTH_WORDS_KEY 
442b						DMARK "CON" 
442b f5				push af  
442c 3a 40 44			ld a, (.dmark)  
442f 32 71 ee			ld (debug_mark),a  
4432 3a 41 44			ld a, (.dmark+1)  
4435 32 72 ee			ld (debug_mark+1),a  
4438 3a 42 44			ld a, (.dmark+2)  
443b 32 73 ee			ld (debug_mark+2),a  
443e 18 03			jr .pastdmark  
4440 ..			.dmark: db "CON"  
4443 f1			.pastdmark: pop af  
4444			endm  
# End of macro DMARK
4444						CALLMONITOR 
4444 cd ae 15			call break_point_state  
4447				endm  
# End of macro CALLMONITOR
4447					endif 
4447			 
4447			 
4447					FORTH_DSP_VALUE 
4447 cd ff 1d			call macro_forth_dsp_value 
444a				endm 
# End of macro FORTH_DSP_VALUE
444a e5					push hl   ; s2 
444b			 
444b					FORTH_DSP_POP 
444b cd ce 1e			call macro_forth_dsp_pop 
444e				endm 
# End of macro FORTH_DSP_POP
444e			 
444e					FORTH_DSP_VALUE 
444e cd ff 1d			call macro_forth_dsp_value 
4451				endm 
# End of macro FORTH_DSP_VALUE
4451			 
4451 e5					push hl   ; s1 
4452			 
4452					FORTH_DSP_POP 
4452 cd ce 1e			call macro_forth_dsp_pop 
4455				endm 
# End of macro FORTH_DSP_POP
4455					 
4455			 
4455					; copy s1 
4455			 
4455				 
4455					; save ptr 
4455 e1					pop hl  
4456 e5					push hl 
4457 3e 00				ld a, 0 
4459 cd 16 12				call strlent 
445c					;inc hl    ; zer0 
445c 06 00				ld b, 0 
445e 4d					ld c, l 
445f e1					pop hl		 
4460 11 cb e2				ld de, scratch	 
4463					if DEBUG_FORTH_WORDS 
4463						DMARK "CO1" 
4463 f5				push af  
4464 3a 78 44			ld a, (.dmark)  
4467 32 71 ee			ld (debug_mark),a  
446a 3a 79 44			ld a, (.dmark+1)  
446d 32 72 ee			ld (debug_mark+1),a  
4470 3a 7a 44			ld a, (.dmark+2)  
4473 32 73 ee			ld (debug_mark+2),a  
4476 18 03			jr .pastdmark  
4478 ..			.dmark: db "CO1"  
447b f1			.pastdmark: pop af  
447c			endm  
# End of macro DMARK
447c						CALLMONITOR 
447c cd ae 15			call break_point_state  
447f				endm  
# End of macro CALLMONITOR
447f					endif 
447f ed b0				ldir 
4481			 
4481 e1					pop hl 
4482 e5					push hl 
4483 d5					push de 
4484			 
4484			 
4484 3e 00				ld a, 0 
4486 cd 16 12				call strlent 
4489 23					inc hl    ; zer0 
448a 23					inc hl 
448b 06 00				ld b, 0 
448d 4d					ld c, l 
448e d1					pop de 
448f e1					pop hl		 
4490					if DEBUG_FORTH_WORDS 
4490						DMARK "CO2" 
4490 f5				push af  
4491 3a a5 44			ld a, (.dmark)  
4494 32 71 ee			ld (debug_mark),a  
4497 3a a6 44			ld a, (.dmark+1)  
449a 32 72 ee			ld (debug_mark+1),a  
449d 3a a7 44			ld a, (.dmark+2)  
44a0 32 73 ee			ld (debug_mark+2),a  
44a3 18 03			jr .pastdmark  
44a5 ..			.dmark: db "CO2"  
44a8 f1			.pastdmark: pop af  
44a9			endm  
# End of macro DMARK
44a9						CALLMONITOR 
44a9 cd ae 15			call break_point_state  
44ac				endm  
# End of macro CALLMONITOR
44ac					endif 
44ac ed b0				ldir 
44ae			 
44ae			 
44ae			 
44ae 21 cb e2				ld hl, scratch 
44b1					if DEBUG_FORTH_WORDS 
44b1						DMARK "CO5" 
44b1 f5				push af  
44b2 3a c6 44			ld a, (.dmark)  
44b5 32 71 ee			ld (debug_mark),a  
44b8 3a c7 44			ld a, (.dmark+1)  
44bb 32 72 ee			ld (debug_mark+1),a  
44be 3a c8 44			ld a, (.dmark+2)  
44c1 32 73 ee			ld (debug_mark+2),a  
44c4 18 03			jr .pastdmark  
44c6 ..			.dmark: db "CO5"  
44c9 f1			.pastdmark: pop af  
44ca			endm  
# End of macro DMARK
44ca						CALLMONITOR 
44ca cd ae 15			call break_point_state  
44cd				endm  
# End of macro CALLMONITOR
44cd					endif 
44cd			 
44cd cd 8d 1c				call forth_push_str 
44d0			 
44d0			 
44d0			 
44d0			 
44d0				       NEXTW 
44d0 c3 c5 1f			jp macro_next 
44d3				endm 
# End of macro NEXTW
44d3			 
44d3			 
44d3			.FIND: 
44d3				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
44d3 4b				db WORD_SYS_CORE+55             
44d4 91 45			dw .LEN            
44d6 05				db 4 + 1 
44d7 .. 00			db "FIND",0              
44dc				endm 
# End of macro CWHEAD
44dc			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
44dc			 
44dc					if DEBUG_FORTH_WORDS_KEY 
44dc						DMARK "FND" 
44dc f5				push af  
44dd 3a f1 44			ld a, (.dmark)  
44e0 32 71 ee			ld (debug_mark),a  
44e3 3a f2 44			ld a, (.dmark+1)  
44e6 32 72 ee			ld (debug_mark+1),a  
44e9 3a f3 44			ld a, (.dmark+2)  
44ec 32 73 ee			ld (debug_mark+2),a  
44ef 18 03			jr .pastdmark  
44f1 ..			.dmark: db "FND"  
44f4 f1			.pastdmark: pop af  
44f5			endm  
# End of macro DMARK
44f5						CALLMONITOR 
44f5 cd ae 15			call break_point_state  
44f8				endm  
# End of macro CALLMONITOR
44f8					endif 
44f8			 
44f8			; TODO check string type 
44f8					FORTH_DSP_VALUE 
44f8 cd ff 1d			call macro_forth_dsp_value 
44fb				endm 
# End of macro FORTH_DSP_VALUE
44fb			 
44fb e5					push hl    
44fc 7e					ld a,(hl)    ; char to find   
44fd			; TODO change char to substr 
44fd			 
44fd f5					push af 
44fe					 
44fe			 
44fe			 
44fe					if DEBUG_FORTH_WORDS 
44fe						DMARK "FN1" 
44fe f5				push af  
44ff 3a 13 45			ld a, (.dmark)  
4502 32 71 ee			ld (debug_mark),a  
4505 3a 14 45			ld a, (.dmark+1)  
4508 32 72 ee			ld (debug_mark+1),a  
450b 3a 15 45			ld a, (.dmark+2)  
450e 32 73 ee			ld (debug_mark+2),a  
4511 18 03			jr .pastdmark  
4513 ..			.dmark: db "FN1"  
4516 f1			.pastdmark: pop af  
4517			endm  
# End of macro DMARK
4517						CALLMONITOR 
4517 cd ae 15			call break_point_state  
451a				endm  
# End of macro CALLMONITOR
451a					endif 
451a			 
451a					FORTH_DSP_POP 
451a cd ce 1e			call macro_forth_dsp_pop 
451d				endm 
# End of macro FORTH_DSP_POP
451d			 
451d					; string to search 
451d			 
451d					FORTH_DSP_VALUE 
451d cd ff 1d			call macro_forth_dsp_value 
4520				endm 
# End of macro FORTH_DSP_VALUE
4520			 
4520 d1					pop de  ; d is char to find  
4521			 
4521					if DEBUG_FORTH_WORDS 
4521						DMARK "FN2" 
4521 f5				push af  
4522 3a 36 45			ld a, (.dmark)  
4525 32 71 ee			ld (debug_mark),a  
4528 3a 37 45			ld a, (.dmark+1)  
452b 32 72 ee			ld (debug_mark+1),a  
452e 3a 38 45			ld a, (.dmark+2)  
4531 32 73 ee			ld (debug_mark+2),a  
4534 18 03			jr .pastdmark  
4536 ..			.dmark: db "FN2"  
4539 f1			.pastdmark: pop af  
453a			endm  
# End of macro DMARK
453a						CALLMONITOR 
453a cd ae 15			call break_point_state  
453d				endm  
# End of macro CALLMONITOR
453d					endif 
453d					 
453d 01 00 00				ld bc, 0 
4540 7e			.findchar:      ld a,(hl) 
4541 fe 00				cp 0   		 
4543 28 27				jr z, .finddone     
4545 ba					cp d 
4546 28 20				jr z, .foundchar 
4548 03					inc bc 
4549 23					inc hl 
454a					if DEBUG_FORTH_WORDS 
454a						DMARK "FN3" 
454a f5				push af  
454b 3a 5f 45			ld a, (.dmark)  
454e 32 71 ee			ld (debug_mark),a  
4551 3a 60 45			ld a, (.dmark+1)  
4554 32 72 ee			ld (debug_mark+1),a  
4557 3a 61 45			ld a, (.dmark+2)  
455a 32 73 ee			ld (debug_mark+2),a  
455d 18 03			jr .pastdmark  
455f ..			.dmark: db "FN3"  
4562 f1			.pastdmark: pop af  
4563			endm  
# End of macro DMARK
4563						CALLMONITOR 
4563 cd ae 15			call break_point_state  
4566				endm  
# End of macro CALLMONITOR
4566					endif 
4566 18 d8				jr .findchar 
4568			 
4568			 
4568 c5			.foundchar:	push bc 
4569 e1					pop hl 
456a 18 03				jr .findexit 
456c			 
456c			 
456c							 
456c			 
456c			.finddone:     ; got to end of string with no find 
456c 21 00 00				ld hl, 0 
456f			.findexit: 
456f			 
456f					if DEBUG_FORTH_WORDS 
456f						DMARK "FNd" 
456f f5				push af  
4570 3a 84 45			ld a, (.dmark)  
4573 32 71 ee			ld (debug_mark),a  
4576 3a 85 45			ld a, (.dmark+1)  
4579 32 72 ee			ld (debug_mark+1),a  
457c 3a 86 45			ld a, (.dmark+2)  
457f 32 73 ee			ld (debug_mark+2),a  
4582 18 03			jr .pastdmark  
4584 ..			.dmark: db "FNd"  
4587 f1			.pastdmark: pop af  
4588			endm  
# End of macro DMARK
4588						CALLMONITOR 
4588 cd ae 15			call break_point_state  
458b				endm  
# End of macro CALLMONITOR
458b					endif 
458b cd 1f 1c			call forth_push_numhl 
458e			 
458e				       NEXTW 
458e c3 c5 1f			jp macro_next 
4591				endm 
# End of macro NEXTW
4591			 
4591			.LEN: 
4591				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4591 4c				db WORD_SYS_CORE+56             
4592 fb 45			dw .ASC            
4594 06				db 5 + 1 
4595 .. 00			db "COUNT",0              
459b				endm 
# End of macro CWHEAD
459b			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
459b			 
459b					if DEBUG_FORTH_WORDS_KEY 
459b						DMARK "CNT" 
459b f5				push af  
459c 3a b0 45			ld a, (.dmark)  
459f 32 71 ee			ld (debug_mark),a  
45a2 3a b1 45			ld a, (.dmark+1)  
45a5 32 72 ee			ld (debug_mark+1),a  
45a8 3a b2 45			ld a, (.dmark+2)  
45ab 32 73 ee			ld (debug_mark+2),a  
45ae 18 03			jr .pastdmark  
45b0 ..			.dmark: db "CNT"  
45b3 f1			.pastdmark: pop af  
45b4			endm  
# End of macro DMARK
45b4						CALLMONITOR 
45b4 cd ae 15			call break_point_state  
45b7				endm  
# End of macro CALLMONITOR
45b7					endif 
45b7			; TODO check string type 
45b7					FORTH_DSP_VALUE 
45b7 cd ff 1d			call macro_forth_dsp_value 
45ba				endm 
# End of macro FORTH_DSP_VALUE
45ba			 
45ba			 
45ba					if DEBUG_FORTH_WORDS 
45ba						DMARK "CN?" 
45ba f5				push af  
45bb 3a cf 45			ld a, (.dmark)  
45be 32 71 ee			ld (debug_mark),a  
45c1 3a d0 45			ld a, (.dmark+1)  
45c4 32 72 ee			ld (debug_mark+1),a  
45c7 3a d1 45			ld a, (.dmark+2)  
45ca 32 73 ee			ld (debug_mark+2),a  
45cd 18 03			jr .pastdmark  
45cf ..			.dmark: db "CN?"  
45d2 f1			.pastdmark: pop af  
45d3			endm  
# End of macro DMARK
45d3						CALLMONITOR 
45d3 cd ae 15			call break_point_state  
45d6				endm  
# End of macro CALLMONITOR
45d6					endif 
45d6 cd 0b 12				call strlenz 
45d9					if DEBUG_FORTH_WORDS 
45d9						DMARK "CNl" 
45d9 f5				push af  
45da 3a ee 45			ld a, (.dmark)  
45dd 32 71 ee			ld (debug_mark),a  
45e0 3a ef 45			ld a, (.dmark+1)  
45e3 32 72 ee			ld (debug_mark+1),a  
45e6 3a f0 45			ld a, (.dmark+2)  
45e9 32 73 ee			ld (debug_mark+2),a  
45ec 18 03			jr .pastdmark  
45ee ..			.dmark: db "CNl"  
45f1 f1			.pastdmark: pop af  
45f2			endm  
# End of macro DMARK
45f2						CALLMONITOR 
45f2 cd ae 15			call break_point_state  
45f5				endm  
# End of macro CALLMONITOR
45f5					endif 
45f5			 
45f5 cd 1f 1c				call forth_push_numhl 
45f8			 
45f8			 
45f8			 
45f8				       NEXTW 
45f8 c3 c5 1f			jp macro_next 
45fb				endm 
# End of macro NEXTW
45fb			.ASC: 
45fb				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
45fb 4d				db WORD_SYS_CORE+57             
45fc 30 46			dw .CHR            
45fe 04				db 3 + 1 
45ff .. 00			db "ASC",0              
4603				endm 
# End of macro CWHEAD
4603			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4603					if DEBUG_FORTH_WORDS_KEY 
4603						DMARK "ASC" 
4603 f5				push af  
4604 3a 18 46			ld a, (.dmark)  
4607 32 71 ee			ld (debug_mark),a  
460a 3a 19 46			ld a, (.dmark+1)  
460d 32 72 ee			ld (debug_mark+1),a  
4610 3a 1a 46			ld a, (.dmark+2)  
4613 32 73 ee			ld (debug_mark+2),a  
4616 18 03			jr .pastdmark  
4618 ..			.dmark: db "ASC"  
461b f1			.pastdmark: pop af  
461c			endm  
# End of macro DMARK
461c						CALLMONITOR 
461c cd ae 15			call break_point_state  
461f				endm  
# End of macro CALLMONITOR
461f					endif 
461f					FORTH_DSP 
461f cd dc 1d			call macro_forth_dsp 
4622				endm 
# End of macro FORTH_DSP
4622					;v5 FORTH_DSP_VALUE 
4622 23					inc hl      ; now at start of numeric as string 
4623			 
4623			;		push hl 
4623			 
4623					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4623 cd ce 1e			call macro_forth_dsp_pop 
4626				endm 
# End of macro FORTH_DSP_POP
4626			 
4626			;		pop hl 
4626			 
4626					; push the content of a onto the stack as a value 
4626			 
4626 7e					ld a,(hl)   ; get char 
4627 26 00				ld h,0 
4629 6f					ld l,a 
462a cd 1f 1c				call forth_push_numhl 
462d			 
462d				       NEXTW 
462d c3 c5 1f			jp macro_next 
4630				endm 
# End of macro NEXTW
4630			 
4630			.CHR: 
4630				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4630 4d				db WORD_SYS_CORE+57             
4631 6c 46			dw .ENDSTR            
4633 04				db 3 + 1 
4634 .. 00			db "CHR",0              
4638				endm 
# End of macro CWHEAD
4638			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4638					if DEBUG_FORTH_WORDS_KEY 
4638						DMARK "CHR" 
4638 f5				push af  
4639 3a 4d 46			ld a, (.dmark)  
463c 32 71 ee			ld (debug_mark),a  
463f 3a 4e 46			ld a, (.dmark+1)  
4642 32 72 ee			ld (debug_mark+1),a  
4645 3a 4f 46			ld a, (.dmark+2)  
4648 32 73 ee			ld (debug_mark+2),a  
464b 18 03			jr .pastdmark  
464d ..			.dmark: db "CHR"  
4650 f1			.pastdmark: pop af  
4651			endm  
# End of macro DMARK
4651						CALLMONITOR 
4651 cd ae 15			call break_point_state  
4654				endm  
# End of macro CALLMONITOR
4654					endif 
4654					FORTH_DSP_VALUEHL 
4654 cd 16 1e			call macro_dsp_valuehl 
4657				endm 
# End of macro FORTH_DSP_VALUEHL
4657			 
4657					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4657 cd ce 1e			call macro_forth_dsp_pop 
465a				endm 
# End of macro FORTH_DSP_POP
465a			 
465a					; save asci byte as a zero term string and push string 
465a			 
465a 7d					ld a,l 
465b 32 cb e2				ld (scratch), a 
465e			 
465e 3e 00				ld a, 0 
4660 32 cc e2				ld (scratch+1), a 
4663			 
4663 21 cb e2				ld hl, scratch 
4666 cd 8d 1c				call forth_push_str 
4669			 
4669			 
4669				       NEXTW 
4669 c3 c5 1f			jp macro_next 
466c				endm 
# End of macro NEXTW
466c			 
466c			 
466c			 
466c			 
466c			.ENDSTR: 
466c			; eof 
466c			 
# End of file forth_words_str.asm
466c			include "forth_words_key.asm" 
466c			 
466c			; | ## Keyboard Words 
466c			 
466c			.KEY: 
466c				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
466c 3e				db WORD_SYS_CORE+42             
466d 9c 46			dw .WAITK            
466f 04				db 3 + 1 
4670 .. 00			db "KEY",0              
4674				endm 
# End of macro CWHEAD
4674			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4674			 
4674					if DEBUG_FORTH_WORDS_KEY 
4674						DMARK "KEY" 
4674 f5				push af  
4675 3a 89 46			ld a, (.dmark)  
4678 32 71 ee			ld (debug_mark),a  
467b 3a 8a 46			ld a, (.dmark+1)  
467e 32 72 ee			ld (debug_mark+1),a  
4681 3a 8b 46			ld a, (.dmark+2)  
4684 32 73 ee			ld (debug_mark+2),a  
4687 18 03			jr .pastdmark  
4689 ..			.dmark: db "KEY"  
468c f1			.pastdmark: pop af  
468d			endm  
# End of macro DMARK
468d						CALLMONITOR 
468d cd ae 15			call break_point_state  
4690				endm  
# End of macro CALLMONITOR
4690					endif 
4690			; TODO currently waits 
4690 cd a5 61				call cin 
4693					;call cin_wait 
4693 6f					ld l, a 
4694 26 00				ld h, 0 
4696 cd 1f 1c				call forth_push_numhl 
4699					NEXTW 
4699 c3 c5 1f			jp macro_next 
469c				endm 
# End of macro NEXTW
469c			.WAITK: 
469c				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
469c 3f				db WORD_SYS_CORE+43             
469d ce 46			dw .ACCEPT            
469f 06				db 5 + 1 
46a0 .. 00			db "WAITK",0              
46a6				endm 
# End of macro CWHEAD
46a6			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
46a6					if DEBUG_FORTH_WORDS_KEY 
46a6						DMARK "WAI" 
46a6 f5				push af  
46a7 3a bb 46			ld a, (.dmark)  
46aa 32 71 ee			ld (debug_mark),a  
46ad 3a bc 46			ld a, (.dmark+1)  
46b0 32 72 ee			ld (debug_mark+1),a  
46b3 3a bd 46			ld a, (.dmark+2)  
46b6 32 73 ee			ld (debug_mark+2),a  
46b9 18 03			jr .pastdmark  
46bb ..			.dmark: db "WAI"  
46be f1			.pastdmark: pop af  
46bf			endm  
# End of macro DMARK
46bf						CALLMONITOR 
46bf cd ae 15			call break_point_state  
46c2				endm  
# End of macro CALLMONITOR
46c2					endif 
46c2 cd 9d 61				call cin_wait 
46c5 6f					ld l, a 
46c6 26 00				ld h, 0 
46c8 cd 1f 1c				call forth_push_numhl 
46cb					NEXTW 
46cb c3 c5 1f			jp macro_next 
46ce				endm 
# End of macro NEXTW
46ce			.ACCEPT: 
46ce				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
46ce 40				db WORD_SYS_CORE+44             
46cf 2c 47			dw .EDIT            
46d1 07				db 6 + 1 
46d2 .. 00			db "ACCEPT",0              
46d9				endm 
# End of macro CWHEAD
46d9			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
46d9					; TODO crashes on push 
46d9					if DEBUG_FORTH_WORDS_KEY 
46d9						DMARK "ACC" 
46d9 f5				push af  
46da 3a ee 46			ld a, (.dmark)  
46dd 32 71 ee			ld (debug_mark),a  
46e0 3a ef 46			ld a, (.dmark+1)  
46e3 32 72 ee			ld (debug_mark+1),a  
46e6 3a f0 46			ld a, (.dmark+2)  
46e9 32 73 ee			ld (debug_mark+2),a  
46ec 18 03			jr .pastdmark  
46ee ..			.dmark: db "ACC"  
46f1 f1			.pastdmark: pop af  
46f2			endm  
# End of macro DMARK
46f2						CALLMONITOR 
46f2 cd ae 15			call break_point_state  
46f5				endm  
# End of macro CALLMONITOR
46f5					endif 
46f5 21 c9 e4				ld hl, os_input 
46f8 3e 00				ld a, 0 
46fa 77					ld (hl),a 
46fb 3a 68 ea				ld a,(f_cursor_ptr) 
46fe 16 64				ld d, 100 
4700 0e 00				ld c, 0 
4702 1e 28				ld e, 40 
4704 cd da 0d				call input_str 
4707					; TODO perhaps do a type check and wrap in quotes if not a number 
4707 21 c9 e4				ld hl, os_input 
470a					if DEBUG_FORTH_WORDS 
470a						DMARK "AC1" 
470a f5				push af  
470b 3a 1f 47			ld a, (.dmark)  
470e 32 71 ee			ld (debug_mark),a  
4711 3a 20 47			ld a, (.dmark+1)  
4714 32 72 ee			ld (debug_mark+1),a  
4717 3a 21 47			ld a, (.dmark+2)  
471a 32 73 ee			ld (debug_mark+2),a  
471d 18 03			jr .pastdmark  
471f ..			.dmark: db "AC1"  
4722 f1			.pastdmark: pop af  
4723			endm  
# End of macro DMARK
4723						CALLMONITOR 
4723 cd ae 15			call break_point_state  
4726				endm  
# End of macro CALLMONITOR
4726					endif 
4726 cd 8d 1c				call forth_push_str 
4729					NEXTW 
4729 c3 c5 1f			jp macro_next 
472c				endm 
# End of macro NEXTW
472c			 
472c			.EDIT: 
472c				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
472c 40				db WORD_SYS_CORE+44             
472d ce 47			dw .ENDKEY            
472f 05				db 4 + 1 
4730 .. 00			db "EDIT",0              
4735				endm 
# End of macro CWHEAD
4735			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4735			 
4735					; TODO does not copy from stack 
4735					if DEBUG_FORTH_WORDS_KEY 
4735						DMARK "EDT" 
4735 f5				push af  
4736 3a 4a 47			ld a, (.dmark)  
4739 32 71 ee			ld (debug_mark),a  
473c 3a 4b 47			ld a, (.dmark+1)  
473f 32 72 ee			ld (debug_mark+1),a  
4742 3a 4c 47			ld a, (.dmark+2)  
4745 32 73 ee			ld (debug_mark+2),a  
4748 18 03			jr .pastdmark  
474a ..			.dmark: db "EDT"  
474d f1			.pastdmark: pop af  
474e			endm  
# End of macro DMARK
474e						CALLMONITOR 
474e cd ae 15			call break_point_state  
4751				endm  
# End of macro CALLMONITOR
4751					endif 
4751			 
4751					;FORTH_DSP 
4751					FORTH_DSP_VALUEHL 
4751 cd 16 1e			call macro_dsp_valuehl 
4754				endm 
# End of macro FORTH_DSP_VALUEHL
4754			;		inc hl    ; TODO do type check 
4754			 
4754			;		call get_word_hl 
4754 e5					push hl 
4755					if DEBUG_FORTH_WORDS 
4755						DMARK "EDp" 
4755 f5				push af  
4756 3a 6a 47			ld a, (.dmark)  
4759 32 71 ee			ld (debug_mark),a  
475c 3a 6b 47			ld a, (.dmark+1)  
475f 32 72 ee			ld (debug_mark+1),a  
4762 3a 6c 47			ld a, (.dmark+2)  
4765 32 73 ee			ld (debug_mark+2),a  
4768 18 03			jr .pastdmark  
476a ..			.dmark: db "EDp"  
476d f1			.pastdmark: pop af  
476e			endm  
# End of macro DMARK
476e						CALLMONITOR 
476e cd ae 15			call break_point_state  
4771				endm  
# End of macro CALLMONITOR
4771					endif 
4771				;	ld a, 0 
4771 cd 0b 12				call strlenz 
4774 23					inc hl 
4775			 
4775 06 00				ld b, 0 
4777 4d					ld c, l 
4778			 
4778 e1					pop hl 
4779 11 c9 e4				ld de, os_input 
477c					if DEBUG_FORTH_WORDS_KEY 
477c						DMARK "EDc" 
477c f5				push af  
477d 3a 91 47			ld a, (.dmark)  
4780 32 71 ee			ld (debug_mark),a  
4783 3a 92 47			ld a, (.dmark+1)  
4786 32 72 ee			ld (debug_mark+1),a  
4789 3a 93 47			ld a, (.dmark+2)  
478c 32 73 ee			ld (debug_mark+2),a  
478f 18 03			jr .pastdmark  
4791 ..			.dmark: db "EDc"  
4794 f1			.pastdmark: pop af  
4795			endm  
# End of macro DMARK
4795						CALLMONITOR 
4795 cd ae 15			call break_point_state  
4798				endm  
# End of macro CALLMONITOR
4798					endif 
4798 ed b0				ldir 
479a			 
479a			 
479a 21 c9 e4				ld hl, os_input 
479d					;ld a, 0 
479d					;ld (hl),a 
479d 3a 68 ea				ld a,(f_cursor_ptr) 
47a0 16 64				ld d, 100 
47a2 0e 00				ld c, 0 
47a4 1e 28				ld e, 40 
47a6 cd da 0d				call input_str 
47a9					; TODO perhaps do a type check and wrap in quotes if not a number 
47a9 21 c9 e4				ld hl, os_input 
47ac					if DEBUG_FORTH_WORDS 
47ac						DMARK "ED1" 
47ac f5				push af  
47ad 3a c1 47			ld a, (.dmark)  
47b0 32 71 ee			ld (debug_mark),a  
47b3 3a c2 47			ld a, (.dmark+1)  
47b6 32 72 ee			ld (debug_mark+1),a  
47b9 3a c3 47			ld a, (.dmark+2)  
47bc 32 73 ee			ld (debug_mark+2),a  
47bf 18 03			jr .pastdmark  
47c1 ..			.dmark: db "ED1"  
47c4 f1			.pastdmark: pop af  
47c5			endm  
# End of macro DMARK
47c5						CALLMONITOR 
47c5 cd ae 15			call break_point_state  
47c8				endm  
# End of macro CALLMONITOR
47c8					endif 
47c8 cd 8d 1c				call forth_push_str 
47cb					NEXTW 
47cb c3 c5 1f			jp macro_next 
47ce				endm 
# End of macro NEXTW
47ce			 
47ce			 
47ce			 
47ce			.ENDKEY: 
47ce			; eof 
47ce			 
# End of file forth_words_key.asm
47ce			include "forth_words_const.asm" 
47ce			 
47ce			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
47ce			 
47ce			 
47ce			.SPITIME: 
47ce				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
47ce 77				db WORD_SYS_CORE+99             
47cf e3 47			dw .VA            
47d1 08				db 7 + 1 
47d2 .. 00			db "SPITIME",0              
47da				endm 
# End of macro CWHEAD
47da			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
47da			; 
47da			; | If using BANK devices then leave as is. 
47da			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
47da			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
47da			 
47da 21 6e ea				ld hl, spi_clktime  
47dd cd 1f 1c				call forth_push_numhl 
47e0			 
47e0					NEXTW 
47e0 c3 c5 1f			jp macro_next 
47e3				endm 
# End of macro NEXTW
47e3			 
47e3			 
47e3			.VA: 
47e3				CWHEAD .ENDCONST 99 "VA" 2 WORD_FLAG_CODE 
47e3 77				db WORD_SYS_CORE+99             
47e4 f3 47			dw .ENDCONST            
47e6 03				db 2 + 1 
47e7 .. 00			db "VA",0              
47ea				endm 
# End of macro CWHEAD
47ea			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
47ea 21 32 ea				ld hl, cli_var_array 
47ed cd 1f 1c				call forth_push_numhl 
47f0			 
47f0					NEXTW 
47f0 c3 c5 1f			jp macro_next 
47f3				endm 
# End of macro NEXTW
47f3			 
47f3			 
47f3			;endif 
47f3			 
47f3			;LFSRSeed:	equ $fbb3 
47f3			;chk_data_ovr:	equ $f761 
47f3			;chk_loop_ovr:	equ $f963 
47f3			;chk_ret_ovr:	equ $f9e5 
47f3			;chk_ret_und:	equ $fa27 
47f3			;chk_stovr:	equ $fefd 
47f3			;chk_stund:	equ $ffff 
47f3			;cli_autodisplay:	equ $fa43 
47f3			;cli_buffer:	equ $fa51 
47f3			;cli_data_sp:	equ $fa29 
47f3			;cli_data_stack:	equ $f763 
47f3			;cli_execword:	equ $fa4b 
47f3			;cli_loop_sp:	equ $fa2b 
47f3			;cli_loop_stack:	equ $f965 
47f3			;cli_mvdot:	equ $fa44 
47f3			;cli_nextword:	equ $fa49 
47f3			;cli_origptr:	equ $fa45 
47f3			;cli_origtoken:	equ $fa4f 
47f3			;cli_ptr:	equ $fa47 
47f3			;cli_ret_sp:	equ $fa2d 
47f3			;cli_ret_stack:	equ $f9e7 
47f3			;cli_token:	equ $fa4d 
47f3			;cli_var_array:	equ $fa2f 
47f3			;cursor_col:	equ $fbcb 
47f3			;cursor_ptr:	equ $fbc9 
47f3			;cursor_row:	equ $fbca 
47f3			;cursor_shape:	equ $fbc7 
47f3			;debug_mark:	equ $fe6e 
47f3			;display_fb0:	equ $fdb4 
47f3			;display_fb1:	equ $fd13 
47f3			;display_fb2:	equ $fbd1 
47f3			;display_fb3:	equ $fc72 
47f3			;display_fb_active:	equ $fbcf 
47f3			;display_lcde1e2:	equ $fbce 
47f3			;execscratch:	equ $f2fb 
47f3			;f_cursor_ptr:	equ $fa65 
47f3			;hardware_word:	equ $fe72 
47f3			;heap_start:	equ $800e 
47f3			;iErrorNum:	equ $fba8 
47f3			;iErrorReg:	equ $fba7 
47f3			;iErrorVer:	equ $fba6 
47f3			;input_at_cursor:	equ $fe65 
47f3			;input_at_pos:	equ $fe67 
47f3			;input_cur_flash:	equ $fe63 
47f3			;input_cur_onoff:	equ $fe62 
47f3			;input_cursor:	equ $fe58 
47f3			;input_display_size:	equ $fe68 
47f3			;input_len:	equ $fe5d 
47f3			;input_ptr:	equ $fe6c 
47f3			;input_size:	equ $fe69 
47f3			;input_start:	equ $fe6a 
47f3			;input_str:	equ $0f79 
47f3			;input_under_cursor:	equ $fe66 
47f3			;key_actual_pressed:	equ $fe57 
47f3			;key_fa:	equ $fe82 
47f3			;key_face_held:	equ $fe7e 
47f3			;key_fb:	equ $fe81 
47f3			;key_fc:	equ $fe80 
47f3			;key_fd:	equ $fe7f 
47f3			;key_held:	equ $fe88 
47f3			;key_held_prev:	equ $fe87 
47f3			;key_init:	equ $7060 
47f3			;key_repeat_ct:	equ $fe83 
47f3			;key_rows:	equ $0005 
47f3			;key_shift:	equ $fe55 
47f3			;key_symbol:	equ $fe56 
47f3			;keyscan_scancol:	equ $fe89 
47f3			;keyscan_table:	equ $fe93 
47f3			;keyscan_table_row1:	equ $fef2 
47f3			;keyscan_table_row2:	equ $fee7 
47f3			;keyscan_table_row3:	equ $fedc 
47f3			;keyscan_table_row4:	equ $fed1 
47f3			;keyscan_table_row5:	equ $fec6 
47f3			;os_cli_cmd:	equ $f523 
47f3			;os_cur_ptr:	equ $f51f 
47f3			;os_current_i:	equ $f521 
47f3			;os_input:	equ $f3fa 
47f3			;os_last_cmd:	equ $f622 
47f3			;os_last_new_uword:	equ $f4f9 
47f3			;os_new_exec:	equ $f1f0 
47f3			;os_new_exec_ptr:	equ $f1ee 
47f3			;os_new_malloc:	equ $f1fa 
47f3			;os_new_parse_len:	equ $f1f8 
47f3			;os_new_src_ptr:	equ $f1f2 
47f3			;os_new_word_len:	equ $f1f6 
47f3			;os_new_work_ptr:	equ $f1f4 
47f3			;os_tok_len:	equ $f4ff 
47f3			;os_tok_malloc:	equ $f4fb 
47f3			;os_tok_ptr:	equ $f4fd 
47f3			;os_var_array:	equ $f721 
47f3			;os_view_af:	equ $f1eb 
47f3			;os_view_bc:	equ $f1e5 
47f3			;os_view_de:	equ $f1e7 
47f3			;os_view_disable:	equ $f1ed 
47f3			;os_view_hl:	equ $f1e9 
47f3			;os_word_scratch:	equ $f501 
47f3			;portbctl:	equ $00c3 
47f3			;portbdata:	equ $00c1 
47f3			;prng16:	equ $0e73 
47f3			;prom_bootmsg:	equ $1ac9 
47f3			;prom_bootmsg1:	equ $1ade 
47f3			;randData:	equ $fbb1 
47f3			;scratch:	equ $f1fc 
47f3			;seed1:	equ $fbab 
47f3			;seed2:	equ $fba9 
47f3			;spi_cartdev:	equ $fa6a 
47f3			;spi_cartdev2:	equ $fa69 
47f3			;spi_clktime:	equ $fa6b 
47f3			;spi_device:	equ $fa67 
47f3			;spi_device_id:	equ $fa66 
47f3			;spi_portbyte:	equ $fa68 
47f3			;stackstore:	equ $fbad 
47f3			;;start1:	equ $5bfc 
47f3			;;start2:	equ $5c0e 
47f3			;;start3b:	equ $5c21 
47f3			;;start3c:	equ $5c9d 
47f3			;;startcmds:	equ $57a3 
47f3			;;stest:	equ $5d67 
47f3			;;storage_actl:	equ $0082 
47f3			;;storage_adata:	equ $0080 
47f3			;;storage_append:	equ $0b0c 
47f3			;;storage_bctl:	equ $0083 
47f3			;store_bank_active:	equ $fb99 
47f3			;store_filecache:	equ $fa6e 
47f3			;store_longread:	equ $fa7c 
47f3			;store_openaddr:	equ $fa72 
47f3			;store_openext:	equ $fa71 
47f3			;store_openmaxext:	equ $fa70 
47f3			;store_page:	equ $fa81 
47f3			;store_readbuf:	equ $fa7d 
47f3			;store_readcont:	equ $fa74 
47f3			;store_readptr:	equ $fa7f 
47f3			;store_tmp1:	equ $fa7a 
47f3			;store_tmp2:	equ $fa78 
47f3			;store_tmp3:	equ $fa76 
47f3			;store_tmpext:	equ $fa74 
47f3			;store_tmpid:	equ $fa75 
47f3			;store_tmppageid:	equ $fa6c 
47f3			;tos:	equ $fffd 
47f3			;type:	equ $5b77 
47f3			;xrandc:	equ $fbaf 
47f3			 
47f3			 
47f3			.ENDCONST: 
47f3			 
47f3			; eof 
47f3			 
47f3			 
# End of file forth_words_const.asm
47f3			 
47f3			if STORAGE_SE 
47f3			   	include "forth_words_storage.asm" 
47f3			endif 
47f3				include "forth_words_device.asm" 
47f3			; Device related words 
47f3			 
47f3			; | ## Device Words 
47f3			 
47f3			if SOUND_ENABLE 
47f3			.NOTE: 
47f3				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
47f3			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
47f3					if DEBUG_FORTH_WORDS_KEY 
47f3						DMARK "NTE" 
47f3						CALLMONITOR 
47f3					endif 
47f3			 
47f3				 
47f3			 
47f3					NEXTW 
47f3			.AFTERSOUND: 
47f3			endif 
47f3			 
47f3			 
47f3			USE_GPIO: equ 0 
47f3			 
47f3			if USE_GPIO 
47f3			.GP1: 
47f3				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
47f3			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
47f3					NEXTW 
47f3			.GP2: 
47f3				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
47f3			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
47f3			 
47f3					NEXTW 
47f3			 
47f3			.GP3: 
47f3				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
47f3			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
47f3			 
47f3					NEXTW 
47f3			 
47f3			.GP4: 
47f3				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
47f3			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
47f3			 
47f3					NEXTW 
47f3			.SIN: 
47f3			 
47f3			 
47f3			endif 
47f3			 
47f3			 
47f3				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
47f3 33				db WORD_SYS_CORE+31             
47f4 28 48			dw .SOUT            
47f6 03				db 2 + 1 
47f7 .. 00			db "IN",0              
47fa				endm 
# End of macro CWHEAD
47fa			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
47fa					if DEBUG_FORTH_WORDS_KEY 
47fa						DMARK "IN." 
47fa f5				push af  
47fb 3a 0f 48			ld a, (.dmark)  
47fe 32 71 ee			ld (debug_mark),a  
4801 3a 10 48			ld a, (.dmark+1)  
4804 32 72 ee			ld (debug_mark+1),a  
4807 3a 11 48			ld a, (.dmark+2)  
480a 32 73 ee			ld (debug_mark+2),a  
480d 18 03			jr .pastdmark  
480f ..			.dmark: db "IN."  
4812 f1			.pastdmark: pop af  
4813			endm  
# End of macro DMARK
4813						CALLMONITOR 
4813 cd ae 15			call break_point_state  
4816				endm  
# End of macro CALLMONITOR
4816					endif 
4816					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4816 cd 16 1e			call macro_dsp_valuehl 
4819				endm 
# End of macro FORTH_DSP_VALUEHL
4819			 
4819 e5					push hl 
481a			 
481a					; destroy value TOS 
481a			 
481a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
481a cd ce 1e			call macro_forth_dsp_pop 
481d				endm 
# End of macro FORTH_DSP_POP
481d			 
481d					; one value on hl get other one back 
481d			 
481d c1					pop bc 
481e			 
481e					; do the sub 
481e			;		ex de, hl 
481e			 
481e ed 68				in l,(c) 
4820			 
4820					; save it 
4820			 
4820 26 00				ld h,0 
4822			 
4822					; TODO push value back onto stack for another op etc 
4822			 
4822 cd 1f 1c				call forth_push_numhl 
4825					NEXTW 
4825 c3 c5 1f			jp macro_next 
4828				endm 
# End of macro NEXTW
4828			.SOUT: 
4828				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4828 34				db WORD_SYS_CORE+32             
4829 7b 48			dw .SPIO            
482b 04				db 3 + 1 
482c .. 00			db "OUT",0              
4830				endm 
# End of macro CWHEAD
4830			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4830					if DEBUG_FORTH_WORDS_KEY 
4830						DMARK "OUT" 
4830 f5				push af  
4831 3a 45 48			ld a, (.dmark)  
4834 32 71 ee			ld (debug_mark),a  
4837 3a 46 48			ld a, (.dmark+1)  
483a 32 72 ee			ld (debug_mark+1),a  
483d 3a 47 48			ld a, (.dmark+2)  
4840 32 73 ee			ld (debug_mark+2),a  
4843 18 03			jr .pastdmark  
4845 ..			.dmark: db "OUT"  
4848 f1			.pastdmark: pop af  
4849			endm  
# End of macro DMARK
4849						CALLMONITOR 
4849 cd ae 15			call break_point_state  
484c				endm  
# End of macro CALLMONITOR
484c					endif 
484c			 
484c					; get port 
484c			 
484c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
484c cd 16 1e			call macro_dsp_valuehl 
484f				endm 
# End of macro FORTH_DSP_VALUEHL
484f			 
484f e5					push hl 
4850			 
4850					; destroy value TOS 
4850			 
4850					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4850 cd ce 1e			call macro_forth_dsp_pop 
4853				endm 
# End of macro FORTH_DSP_POP
4853			 
4853					; get byte to send 
4853			 
4853					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4853 cd 16 1e			call macro_dsp_valuehl 
4856				endm 
# End of macro FORTH_DSP_VALUEHL
4856			 
4856			;		push hl 
4856			 
4856					; destroy value TOS 
4856			 
4856					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4856 cd ce 1e			call macro_forth_dsp_pop 
4859				endm 
# End of macro FORTH_DSP_POP
4859			 
4859					; one value on hl get other one back 
4859			 
4859			;		pop hl 
4859			 
4859 c1					pop bc 
485a			 
485a					if DEBUG_FORTH_WORDS 
485a						DMARK "OUT" 
485a f5				push af  
485b 3a 6f 48			ld a, (.dmark)  
485e 32 71 ee			ld (debug_mark),a  
4861 3a 70 48			ld a, (.dmark+1)  
4864 32 72 ee			ld (debug_mark+1),a  
4867 3a 71 48			ld a, (.dmark+2)  
486a 32 73 ee			ld (debug_mark+2),a  
486d 18 03			jr .pastdmark  
486f ..			.dmark: db "OUT"  
4872 f1			.pastdmark: pop af  
4873			endm  
# End of macro DMARK
4873						CALLMONITOR 
4873 cd ae 15			call break_point_state  
4876				endm  
# End of macro CALLMONITOR
4876					endif 
4876			 
4876 ed 69				out (c), l 
4878			 
4878					NEXTW 
4878 c3 c5 1f			jp macro_next 
487b				endm 
# End of macro NEXTW
487b			 
487b			 
487b			.SPIO: 
487b			 
487b			if STORAGE_SE 
487b				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
487b			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
487b			 
487b					call spi_ce_low 
487b			    NEXTW 
487b			 
487b			.SPICEH: 
487b				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
487b			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
487b			 
487b					call spi_ce_high 
487b			    NEXTW 
487b			 
487b			 
487b			.SPIOb: 
487b			 
487b				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
487b			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
487b			 
487b					if DEBUG_FORTH_WORDS_KEY 
487b						DMARK "SPo" 
487b						CALLMONITOR 
487b					endif 
487b					; get port 
487b			 
487b			 
487b					; get byte to send 
487b			 
487b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
487b			 
487b			;		push hl    ; u1  
487b			 
487b					; destroy value TOS 
487b			 
487b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
487b			 
487b					; one value on hl get other one back 
487b			 
487b			;		pop hl   ; u2 - addr 
487b			 
487b					; TODO Send SPI byte 
487b			 
487b			;		push hl 
487b			;		call spi_ce_low 
487b			;		pop hl 
487b					ld a, l 
487b					call spi_send_byte 
487b			;		call spi_ce_high 
487b			 
487b					NEXTW 
487b			 
487b			.SPII: 
487b				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
487b			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
487b					if DEBUG_FORTH_WORDS_KEY 
487b						DMARK "SPi" 
487b						CALLMONITOR 
487b					endif 
487b			 
487b					; TODO Get SPI byte 
487b			 
487b					call spi_read_byte 
487b			 
487b					if DEBUG_FORTH_WORDS 
487b						DMARK "Si2" 
487b						CALLMONITOR 
487b					endif 
487b					ld h, 0 
487b					ld l, a 
487b					if DEBUG_FORTH_WORDS 
487b						DMARK "Si3" 
487b						CALLMONITOR 
487b					endif 
487b					call forth_push_numhl 
487b			 
487b					NEXTW 
487b			 
487b			 
487b			 
487b			.SESEL: 
487b				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
487b			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
487b					if DEBUG_FORTH_WORDS_KEY 
487b						DMARK "BNK" 
487b						CALLMONITOR 
487b					endif 
487b			 
487b					ld a, 255 
487b					ld (spi_cartdev), a 
487b			 
487b					; get bank 
487b			 
487b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
487b			 
487b			;		push hl 
487b			 
487b					; destroy value TOS 
487b			 
487b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
487b			 
487b					; one value on hl get other one back 
487b			 
487b			;		pop hl 
487b			 
487b			 
487b					ld c, SPI_CE_HIGH 
487b					ld b, '0'    ; human readable bank number 
487b			 
487b					ld a, l 
487b			 
487b					if DEBUG_FORTH_WORDS 
487b						DMARK "BNK" 
487b						CALLMONITOR 
487b					endif 
487b			 
487b					; active low 
487b			 
487b					cp 0 
487b					jr z, .bset 
487b					cp 1 
487b					jr nz, .b2 
487b					res 0, c 
487b					ld b, '1'    ; human readable bank number 
487b			.b2:		cp 2 
487b					jr nz, .b3 
487b					res 1, c 
487b					ld b, '2'    ; human readable bank number 
487b			.b3:		cp 3 
487b					jr nz, .b4 
487b					res 2, c 
487b					ld b, '3'    ; human readable bank number 
487b			.b4:		cp 4 
487b					jr nz, .b5 
487b					res 3, c 
487b					ld b, '4'    ; human readable bank number 
487b			.b5:		cp 5 
487b					jr nz, .bset 
487b					res 4, c 
487b					ld b, '5'    ; human readable bank number 
487b			 
487b			.bset: 
487b					ld a, c 
487b					ld (spi_device),a 
487b					ld a, b 
487b					ld (spi_device_id),a 
487b					if DEBUG_FORTH_WORDS 
487b						DMARK "BN2" 
487b						CALLMONITOR 
487b					endif 
487b			 
487b					; set default SPI clk pulse time as disabled for BANK use 
487b			 
487b					ld a, 0 
487b					ld (spi_clktime), a 
487b			 
487b					NEXTW 
487b			 
487b			.CARTDEV: 
487b				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
487b			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
487b					if DEBUG_FORTH_WORDS_KEY 
487b						DMARK "CDV" 
487b						CALLMONITOR 
487b					endif 
487b			 
487b					; disable se storage bank selection 
487b			 
487b					ld a, SPI_CE_HIGH		; ce high 
487b					ld (spi_device), a 
487b			 
487b					; get bank 
487b			 
487b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
487b			 
487b			;		push hl 
487b			 
487b					; destroy value TOS 
487b			 
487b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
487b			 
487b					; one value on hl get other one back 
487b			 
487b			;		pop hl 
487b			 
487b					; active low 
487b			 
487b					ld c, 255 
487b			 
487b					ld a, l 
487b					if DEBUG_FORTH_WORDS 
487b						DMARK "CDV" 
487b						CALLMONITOR 
487b					endif 
487b					cp 0 
487b					jr z, .cset 
487b					cp 1 
487b					jr nz, .c2 
487b					res 0, c 
487b			.c2:		cp 2 
487b					jr nz, .c3 
487b					res 1, c 
487b			.c3:		cp 3 
487b					jr nz, .c4 
487b					res 2, c 
487b			.c4:		cp 4 
487b					jr nz, .c5 
487b					res 3, c 
487b			.c5:		cp 5 
487b					jr nz, .c6 
487b					res 4, c 
487b			.c6:		cp 6 
487b					jr nz, .c7 
487b					res 5, c 
487b			.c7:		cp 7 
487b					jr nz, .c8 
487b					res 6, c 
487b			.c8:		cp 8 
487b					jr nz, .cset 
487b					res 7, c 
487b			.cset:		ld a, c 
487b					ld (spi_cartdev),a 
487b			 
487b					if DEBUG_FORTH_WORDS 
487b						DMARK "CD2" 
487b						CALLMONITOR 
487b					endif 
487b			 
487b					; set default SPI clk pulse time as 10ms for CARTDEV use 
487b			 
487b					ld a, $0a 
487b					ld (spi_clktime), a 
487b					NEXTW 
487b			endif 
487b			 
487b			.ENDDEVICE: 
487b			; eof 
487b			 
# End of file forth_words_device.asm
487b			 
487b			; var handler 
487b			 
487b			 
487b			.VARS: 
487b				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
487b 77				db WORD_SYS_CORE+99             
487c 2c 49			dw .V0            
487e 04				db 3 + 1 
487f .. 00			db "VAR",0              
4883				endm 
# End of macro CWHEAD
4883			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4883			;| 
4883			;| The variable name should consist of a single letter. e.g. "a" 
4883			;! If a full string is passed then only the first char is looked at 
4883			;| Any other char could exceed bounds checks!  
4883			 
4883					if DEBUG_FORTH_WORDS_KEY 
4883						DMARK "VAR" 
4883 f5				push af  
4884 3a 98 48			ld a, (.dmark)  
4887 32 71 ee			ld (debug_mark),a  
488a 3a 99 48			ld a, (.dmark+1)  
488d 32 72 ee			ld (debug_mark+1),a  
4890 3a 9a 48			ld a, (.dmark+2)  
4893 32 73 ee			ld (debug_mark+2),a  
4896 18 03			jr .pastdmark  
4898 ..			.dmark: db "VAR"  
489b f1			.pastdmark: pop af  
489c			endm  
# End of macro DMARK
489c						CALLMONITOR 
489c cd ae 15			call break_point_state  
489f				endm  
# End of macro CALLMONITOR
489f					endif 
489f			 
489f					FORTH_DSP_VALUEHL 
489f cd 16 1e			call macro_dsp_valuehl 
48a2				endm 
# End of macro FORTH_DSP_VALUEHL
48a2			 
48a2 7e					ld a, (hl)    ; get first char on of the string 
48a3			 
48a3			 
48a3					if DEBUG_FORTH_WORDS 
48a3						DMARK "VR1" 
48a3 f5				push af  
48a4 3a b8 48			ld a, (.dmark)  
48a7 32 71 ee			ld (debug_mark),a  
48aa 3a b9 48			ld a, (.dmark+1)  
48ad 32 72 ee			ld (debug_mark+1),a  
48b0 3a ba 48			ld a, (.dmark+2)  
48b3 32 73 ee			ld (debug_mark+2),a  
48b6 18 03			jr .pastdmark  
48b8 ..			.dmark: db "VR1"  
48bb f1			.pastdmark: pop af  
48bc			endm  
# End of macro DMARK
48bc						CALLMONITOR 
48bc cd ae 15			call break_point_state  
48bf				endm  
# End of macro CALLMONITOR
48bf					endif 
48bf					 
48bf f5					push af	 
48c0					FORTH_DSP_POP 
48c0 cd ce 1e			call macro_forth_dsp_pop 
48c3				endm 
# End of macro FORTH_DSP_POP
48c3 f1					pop af 
48c4			 
48c4					; convert to upper 
48c4			 
48c4 cd 1a 11				call to_upper 
48c7					if DEBUG_FORTH_WORDS 
48c7						DMARK "Vaa" 
48c7 f5				push af  
48c8 3a dc 48			ld a, (.dmark)  
48cb 32 71 ee			ld (debug_mark),a  
48ce 3a dd 48			ld a, (.dmark+1)  
48d1 32 72 ee			ld (debug_mark+1),a  
48d4 3a de 48			ld a, (.dmark+2)  
48d7 32 73 ee			ld (debug_mark+2),a  
48da 18 03			jr .pastdmark  
48dc ..			.dmark: db "Vaa"  
48df f1			.pastdmark: pop af  
48e0			endm  
# End of macro DMARK
48e0						CALLMONITOR 
48e0 cd ae 15			call break_point_state  
48e3				endm  
# End of macro CALLMONITOR
48e3					endif 
48e3 06 41				ld b, 'A' 
48e5 90					sub b			; set offset 
48e6					if DEBUG_FORTH_WORDS 
48e6						DMARK "Vbb" 
48e6 f5				push af  
48e7 3a fb 48			ld a, (.dmark)  
48ea 32 71 ee			ld (debug_mark),a  
48ed 3a fc 48			ld a, (.dmark+1)  
48f0 32 72 ee			ld (debug_mark+1),a  
48f3 3a fd 48			ld a, (.dmark+2)  
48f6 32 73 ee			ld (debug_mark+2),a  
48f9 18 03			jr .pastdmark  
48fb ..			.dmark: db "Vbb"  
48fe f1			.pastdmark: pop af  
48ff			endm  
# End of macro DMARK
48ff						CALLMONITOR 
48ff cd ae 15			call break_point_state  
4902				endm  
# End of macro CALLMONITOR
4902					endif 
4902 cb 27				sla a  
4904				 
4904					 
4904					if DEBUG_FORTH_WORDS 
4904						DMARK "VR2" 
4904 f5				push af  
4905 3a 19 49			ld a, (.dmark)  
4908 32 71 ee			ld (debug_mark),a  
490b 3a 1a 49			ld a, (.dmark+1)  
490e 32 72 ee			ld (debug_mark+1),a  
4911 3a 1b 49			ld a, (.dmark+2)  
4914 32 73 ee			ld (debug_mark+2),a  
4917 18 03			jr .pastdmark  
4919 ..			.dmark: db "VR2"  
491c f1			.pastdmark: pop af  
491d			endm  
# End of macro DMARK
491d						CALLMONITOR 
491d cd ae 15			call break_point_state  
4920				endm  
# End of macro CALLMONITOR
4920					endif 
4920			 
4920 21 fe e9				ld hl, cli_var_array2 
4923 cd ad 0d				call addatohl 
4926 cd 1f 1c				call forth_push_numhl 
4929			 
4929			 
4929				       NEXTW 
4929 c3 c5 1f			jp macro_next 
492c				endm 
# End of macro NEXTW
492c			.V0: 
492c				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
492c 78				db WORD_SYS_CORE+100             
492d 44 49			dw .V0Q            
492f 04				db 3 + 1 
4930 .. 00			db "V0!",0              
4934				endm 
# End of macro CWHEAD
4934			;| V0! ( u1 -- )  Store value to v0  | DONE 
4934			 
4934					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4934 cd 16 1e			call macro_dsp_valuehl 
4937				endm 
# End of macro FORTH_DSP_VALUEHL
4937			 
4937 11 32 ea				ld de, cli_var_array 
493a			 
493a eb					ex de, hl 
493b 73					ld (hl), e 
493c 23					inc hl 
493d 72					ld (hl), d 
493e			 
493e					; destroy value TOS 
493e			 
493e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
493e cd ce 1e			call macro_forth_dsp_pop 
4941				endm 
# End of macro FORTH_DSP_POP
4941			 
4941				       NEXTW 
4941 c3 c5 1f			jp macro_next 
4944				endm 
# End of macro NEXTW
4944			.V0Q: 
4944				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4944 79				db WORD_SYS_CORE+101             
4945 55 49			dw .V1S            
4947 04				db 3 + 1 
4948 .. 00			db "V0@",0              
494c				endm 
# End of macro CWHEAD
494c			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
494c 2a 32 ea				ld hl, (cli_var_array) 
494f cd 1f 1c				call forth_push_numhl 
4952			 
4952				       NEXTW 
4952 c3 c5 1f			jp macro_next 
4955				endm 
# End of macro NEXTW
4955			.V1S: 
4955				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4955 7a				db WORD_SYS_CORE+102             
4956 6d 49			dw .V1Q            
4958 04				db 3 + 1 
4959 .. 00			db "V1!",0              
495d				endm 
# End of macro CWHEAD
495d			;| V1! ( u1 -- )  Store value to v1 | DONE 
495d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
495d cd 16 1e			call macro_dsp_valuehl 
4960				endm 
# End of macro FORTH_DSP_VALUEHL
4960			 
4960 11 34 ea				ld de, cli_var_array+2 
4963				 
4963 eb					ex de, hl 
4964 73					ld (hl), e 
4965 23					inc hl 
4966 72					ld (hl), d 
4967			 
4967					; destroy value TOS 
4967			 
4967					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4967 cd ce 1e			call macro_forth_dsp_pop 
496a				endm 
# End of macro FORTH_DSP_POP
496a				       NEXTW 
496a c3 c5 1f			jp macro_next 
496d				endm 
# End of macro NEXTW
496d			.V1Q: 
496d				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
496d 7b				db WORD_SYS_CORE+103             
496e 7e 49			dw .V2S            
4970 04				db 3 + 1 
4971 .. 00			db "V1@",0              
4975				endm 
# End of macro CWHEAD
4975			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4975 2a 34 ea				ld hl, (cli_var_array+2) 
4978 cd 1f 1c				call forth_push_numhl 
497b				       NEXTW 
497b c3 c5 1f			jp macro_next 
497e				endm 
# End of macro NEXTW
497e			.V2S: 
497e				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
497e 7c				db WORD_SYS_CORE+104             
497f 96 49			dw .V2Q            
4981 04				db 3 + 1 
4982 .. 00			db "V2!",0              
4986				endm 
# End of macro CWHEAD
4986			;| V2! ( u1 -- )  Store value to v2 | DONE 
4986					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4986 cd 16 1e			call macro_dsp_valuehl 
4989				endm 
# End of macro FORTH_DSP_VALUEHL
4989			 
4989 11 36 ea				ld de, cli_var_array+4 
498c				 
498c eb					ex de, hl 
498d 73					ld (hl), e 
498e 23					inc hl 
498f 72					ld (hl), d 
4990			 
4990					; destroy value TOS 
4990			 
4990					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4990 cd ce 1e			call macro_forth_dsp_pop 
4993				endm 
# End of macro FORTH_DSP_POP
4993				       NEXTW 
4993 c3 c5 1f			jp macro_next 
4996				endm 
# End of macro NEXTW
4996			.V2Q: 
4996				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4996 7d				db WORD_SYS_CORE+105             
4997 a7 49			dw .V3S            
4999 04				db 3 + 1 
499a .. 00			db "V2@",0              
499e				endm 
# End of macro CWHEAD
499e			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
499e 2a 36 ea				ld hl, (cli_var_array+4) 
49a1 cd 1f 1c				call forth_push_numhl 
49a4				       NEXTW 
49a4 c3 c5 1f			jp macro_next 
49a7				endm 
# End of macro NEXTW
49a7			.V3S: 
49a7				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
49a7 7c				db WORD_SYS_CORE+104             
49a8 bf 49			dw .V3Q            
49aa 04				db 3 + 1 
49ab .. 00			db "V3!",0              
49af				endm 
# End of macro CWHEAD
49af			;| V3! ( u1 -- )  Store value to v3 | DONE 
49af					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
49af cd 16 1e			call macro_dsp_valuehl 
49b2				endm 
# End of macro FORTH_DSP_VALUEHL
49b2			 
49b2 11 38 ea				ld de, cli_var_array+6 
49b5				 
49b5 eb					ex de, hl 
49b6 73					ld (hl), e 
49b7 23					inc hl 
49b8 72					ld (hl), d 
49b9			 
49b9					; destroy value TOS 
49b9			 
49b9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
49b9 cd ce 1e			call macro_forth_dsp_pop 
49bc				endm 
# End of macro FORTH_DSP_POP
49bc				       NEXTW 
49bc c3 c5 1f			jp macro_next 
49bf				endm 
# End of macro NEXTW
49bf			.V3Q: 
49bf				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
49bf 7d				db WORD_SYS_CORE+105             
49c0 d0 49			dw .END            
49c2 04				db 3 + 1 
49c3 .. 00			db "V3@",0              
49c7				endm 
# End of macro CWHEAD
49c7			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
49c7 2a 38 ea				ld hl, (cli_var_array+6) 
49ca cd 1f 1c				call forth_push_numhl 
49cd				       NEXTW 
49cd c3 c5 1f			jp macro_next 
49d0				endm 
# End of macro NEXTW
49d0			 
49d0			 
49d0			 
49d0			 
49d0			 
49d0			; end of dict marker 
49d0			 
49d0 00			.END:    db WORD_SYS_END 
49d1 00 00			dw 0 
49d3 00				db 0 
49d4			 
49d4			; use to jp here for user dict words to save on macro expansion  
49d4			 
49d4			user_dict_next: 
49d4				NEXTW 
49d4 c3 c5 1f			jp macro_next 
49d7				endm 
# End of macro NEXTW
49d7			 
49d7			 
49d7			user_exec: 
49d7				;    ld hl, <word code> 
49d7				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
49d7				;    call forthexec 
49d7				;    jp user_dict_next   (NEXT) 
49d7			        ;    <word code bytes> 
49d7 eb				ex de, hl 
49d8 2a cc e5			ld hl,(os_tok_ptr) 
49db				 
49db				FORTH_RSP_NEXT 
49db cd c6 1b			call macro_forth_rsp_next 
49de				endm 
# End of macro FORTH_RSP_NEXT
49de			 
49de			if DEBUG_FORTH_UWORD 
49de						DMARK "UEX" 
49de f5				push af  
49df 3a f3 49			ld a, (.dmark)  
49e2 32 71 ee			ld (debug_mark),a  
49e5 3a f4 49			ld a, (.dmark+1)  
49e8 32 72 ee			ld (debug_mark+1),a  
49eb 3a f5 49			ld a, (.dmark+2)  
49ee 32 73 ee			ld (debug_mark+2),a  
49f1 18 03			jr .pastdmark  
49f3 ..			.dmark: db "UEX"  
49f6 f1			.pastdmark: pop af  
49f7			endm  
# End of macro DMARK
49f7				CALLMONITOR 
49f7 cd ae 15			call break_point_state  
49fa				endm  
# End of macro CALLMONITOR
49fa			endif 
49fa			 
49fa			 
49fa			 
49fa eb				ex de, hl 
49fb 22 cc e5			ld (os_tok_ptr), hl 
49fe				 
49fe				; Don't use next - Skips the first word in uword. 
49fe			 
49fe c3 56 20			jp exec1 
4a01			;	NEXT 
4a01			 
4a01			 
4a01			; eof 
# End of file forth_wordsv4.asm
4a01			endif 
4a01			;;;;;;;;;;;;;; Debug code 
4a01			 
4a01			 
4a01			;if DEBUG_FORTH_PARSE 
4a01 .. 00		.nowordfound: db "No match",0 
4a0a .. 00		.compword:	db "Comparing word ",0 
4a1a .. 00		.nextwordat:	db "Next word at",0 
4a27 .. 00		.charmatch:	db "Char match",0 
4a32			;endif 
4a32			if DEBUG_FORTH_JP 
4a32			.foundword:	db "Word match. Exec..",0 
4a32			endif 
4a32			;if DEBUG_FORTH_PUSH 
4a32 .. 00		.enddict:	db "Dict end. Push.",0 
4a42 .. 00		.push_str:	db "Pushing string",0 
4a51 .. 00		.push_num:	db "Pushing number",0 
4a60 .. 00		.data_sp:	db "SP:",0 
4a64 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4a76 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4a88 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4a9a			;endif 
4a9a			;if DEBUG_FORTH_MALLOC 
4a9a .. 00		.push_malloc:	db "Malloc address",0 
4aa9			;endif 
4aa9			 
4aa9			 
4aa9			 
4aa9			; display malloc address and current data stack pointer  
4aa9			 
4aa9			malloc_error: 
4aa9 d5				push de 
4aaa f5				push af 
4aab e5				push hl 
4aac cd 80 0b			call clear_display 
4aaf 11 d1 4a			ld de, .mallocerr 
4ab2 3e 00			ld a,0 
4ab4			;	ld de,os_word_scratch 
4ab4 cd 93 0b			call str_at_display 
4ab7 3e 11			ld a, display_row_1+17 
4ab9 11 71 ee			ld de, debug_mark 
4abc cd 93 0b			call str_at_display 
4abf cd a3 0b			call update_display 
4ac2				;call break_point_state 
4ac2 cd 9d 61			call cin_wait 
4ac5			 
4ac5 3e 20			ld a, ' ' 
4ac7 32 bc e2			ld (os_view_disable), a 
4aca e1				pop hl 
4acb f1				pop af 
4acc d1				pop de	 
4acd				CALLMONITOR 
4acd cd ae 15			call break_point_state  
4ad0				endm  
# End of macro CALLMONITOR
4ad0 c9				ret 
4ad1			 
4ad1 .. 00		.mallocerr: 	db "Malloc Error",0 
4ade			;if DEBUG_FORTH_PUSH 
4ade			display_data_sp: 
4ade f5				push af 
4adf			 
4adf				; see if disabled 
4adf			 
4adf 3a bc e2			ld a, (os_view_disable) 
4ae2 fe 2a			cp '*' 
4ae4 28 67			jr z, .skipdsp 
4ae6			 
4ae6 e5				push hl 
4ae7 e5				push hl 
4ae8 e5			push hl 
4ae9 cd 80 0b			call clear_display 
4aec e1			pop hl 
4aed 7c				ld a,h 
4aee 21 d0 e5			ld hl, os_word_scratch 
4af1 cd ae 10			call hexout 
4af4 e1				pop hl 
4af5 7d				ld a,l 
4af6 21 d2 e5			ld hl, os_word_scratch+2 
4af9 cd ae 10			call hexout 
4afc 21 d4 e5			ld hl, os_word_scratch+4 
4aff 3e 00			ld a,0 
4b01 77				ld (hl),a 
4b02 11 d0 e5			ld de,os_word_scratch 
4b05 3e 28				ld a, display_row_2 
4b07 cd 93 0b				call str_at_display 
4b0a 11 64 4a			ld de, .wordinhl 
4b0d 3e 00			ld a, display_row_1 
4b0f			 
4b0f cd 93 0b				call str_at_display 
4b12 11 71 ee			ld de, debug_mark 
4b15 3e 11			ld a, display_row_1+17 
4b17			 
4b17 cd 93 0b				call str_at_display 
4b1a			 
4b1a				; display current data stack pointer 
4b1a 11 60 4a			ld de,.data_sp 
4b1d 3e 30				ld a, display_row_2 + 8 
4b1f cd 93 0b				call str_at_display 
4b22			 
4b22 2a f8 e9			ld hl,(cli_data_sp) 
4b25 e5				push hl 
4b26 7c				ld a,h 
4b27 21 d0 e5			ld hl, os_word_scratch 
4b2a cd ae 10			call hexout 
4b2d e1				pop hl 
4b2e 7d				ld a,l 
4b2f 21 d2 e5			ld hl, os_word_scratch+2 
4b32 cd ae 10			call hexout 
4b35 21 d4 e5			ld hl, os_word_scratch+4 
4b38 3e 00			ld a,0 
4b3a 77				ld (hl),a 
4b3b 11 d0 e5			ld de,os_word_scratch 
4b3e 3e 33				ld a, display_row_2 + 11 
4b40 cd 93 0b				call str_at_display 
4b43			 
4b43			 
4b43 cd a3 0b			call update_display 
4b46 cd f2 0a			call delay1s 
4b49 cd f2 0a			call delay1s 
4b4c e1				pop hl 
4b4d			.skipdsp: 
4b4d f1				pop af 
4b4e c9				ret 
4b4f			 
4b4f			display_data_malloc: 
4b4f			 
4b4f f5				push af 
4b50 e5				push hl 
4b51 e5				push hl 
4b52 e5			push hl 
4b53 cd 80 0b			call clear_display 
4b56 e1			pop hl 
4b57 7c				ld a,h 
4b58 21 d0 e5			ld hl, os_word_scratch 
4b5b cd ae 10			call hexout 
4b5e e1				pop hl 
4b5f 7d				ld a,l 
4b60 21 d2 e5			ld hl, os_word_scratch+2 
4b63 cd ae 10			call hexout 
4b66 21 d4 e5			ld hl, os_word_scratch+4 
4b69 3e 00			ld a,0 
4b6b 77				ld (hl),a 
4b6c 11 d0 e5			ld de,os_word_scratch 
4b6f 3e 28				ld a, display_row_2 
4b71 cd 93 0b				call str_at_display 
4b74 11 9a 4a			ld de, .push_malloc 
4b77 3e 00			ld a, display_row_1 
4b79			 
4b79 cd 93 0b				call str_at_display 
4b7c			 
4b7c				; display current data stack pointer 
4b7c 11 60 4a			ld de,.data_sp 
4b7f 3e 30				ld a, display_row_2 + 8 
4b81 cd 93 0b				call str_at_display 
4b84			 
4b84 2a f8 e9			ld hl,(cli_data_sp) 
4b87 e5				push hl 
4b88 7c				ld a,h 
4b89 21 d0 e5			ld hl, os_word_scratch 
4b8c cd ae 10			call hexout 
4b8f e1				pop hl 
4b90 7d				ld a,l 
4b91 21 d2 e5			ld hl, os_word_scratch+2 
4b94 cd ae 10			call hexout 
4b97 21 d4 e5			ld hl, os_word_scratch+4 
4b9a 3e 00			ld a,0 
4b9c 77				ld (hl),a 
4b9d 11 d0 e5			ld de,os_word_scratch 
4ba0 3e 33				ld a, display_row_2 + 11 
4ba2 cd 93 0b				call str_at_display 
4ba5			 
4ba5 cd a3 0b			call update_display 
4ba8 cd f2 0a			call delay1s 
4bab cd f2 0a			call delay1s 
4bae e1				pop hl 
4baf f1				pop af 
4bb0 c9				ret 
4bb1			;endif 
4bb1			 
4bb1			include "forth_autostart.asm" 
4bb1			; list of commands to perform at system start up 
4bb1			 
4bb1			startcmds: 
4bb1			;	dw test11 
4bb1			;	dw test12 
4bb1			;	dw test13 
4bb1			;	dw test14 
4bb1			;	dw test15 
4bb1			;	dw test16 
4bb1			;	dw test17 
4bb1			;	dw ifthtest1 
4bb1			;	dw ifthtest2 
4bb1			;	dw ifthtest3 
4bb1			;	dw mmtest1 
4bb1			;	dw mmtest2 
4bb1			;	dw mmtest3 
4bb1			;	dw mmtest4 
4bb1			;	dw mmtest5 
4bb1			;	dw mmtest6 
4bb1			;	dw iftest1 
4bb1			;	dw iftest2 
4bb1			;	dw iftest3 
4bb1			;	dw looptest1 
4bb1			;	dw looptest2 
4bb1			;	dw test1 
4bb1			;	dw test2 
4bb1			;	dw test3 
4bb1			;	dw test4 
4bb1			;	dw game2r 
4bb1			;	dw game2b1 
4bb1			;	dw game2b2 
4bb1			 
4bb1				; start up words that are actually useful 
4bb1			 
4bb1 25 4c		    dw spi1 
4bb3 80 4c		    dw spi2 
4bb5 0e 4d		    dw spi3 
4bb7 b6 4c		    dw spi4 
4bb9 e1 4c		    dw spi5 
4bbb 74 4d		    dw spi6 
4bbd c9 4d		    dw spi7 
4bbf			 
4bbf 21 4e		    dw spi8 
4bc1 40 4e		    dw spi9 
4bc3 98 4e		    dw spi10 
4bc5			 
4bc5 0b 4f			dw longread 
4bc7 52 4f			dw clrstack 
4bc9 85 4f			dw type 
4bcb 75 51			dw stest 
4bcd a9 4f			dw strncpy 
4bcf 0b 51			dw list 
4bd1 0a 50			dw start1 
4bd3 1c 50			dw start2 
4bd5			;	dw start3 
4bd5 2f 50			dw start3b 
4bd7 ab 50			dw start3c 
4bd9			 
4bd9				; (unit) testing words 
4bd9			 
4bd9 ec 51			dw mtesta 
4bdb a1 52			dw mtestb 
4bdd 44 53			dw mtestc 
4bdf f9 53			dw mtestd 
4be1 9d 54			dw mteste 
4be3			 
4be3				; demo/game words 
4be3			 
4be3 a9 5b		        dw game3w 
4be5 d7 5b		        dw game3p 
4be7 f5 5b		        dw game3sc 
4be9 26 5c		        dw game3vsi 
4beb 52 5c		        dw game3vs 
4bed				 
4bed 9c 59			dw game2b 
4bef 0a 5a			dw game2bf 
4bf1 54 5a			dw game2mba 
4bf3 ea 5a			dw game2mbas 
4bf5 2c 5b			dw game2mb 
4bf7			 
4bf7 5d 56			dw game1 
4bf9 6e 56			dw game1a 
4bfb d0 56			dw game1b 
4bfd 05 57			dw game1c 
4bff 3b 57			dw game1d 
4c01 6c 57			dw game1s 
4c03 80 57			dw game1t 
4c05 95 57			dw game1f 
4c07 c9 57			dw game1z 
4c09 0d 58			dw game1zz 
4c0b			 
4c0b 53 55			dw test5 
4c0d 8b 55			dw test6 
4c0f c3 55			dw test7 
4c11 d7 55			dw test8 
4c13 03 56			dw test9 
4c15 19 56			dw test10 
4c17				 
4c17 e4 58		        dw ssv5 
4c19 c8 58		        dw ssv4 
4c1b ac 58		        dw ssv3 
4c1d 76 58		        dw ssv2 
4c1f fd 58		        dw ssv1 
4c21 45 59		        dw ssv1cpm 
4c23			;	dw keyup 
4c23			;	dw keydown 
4c23			;	dw keyleft 
4c23			;	dw keyright 
4c23			;	dw 	keyf1 
4c23			;	dw keyf2 
4c23			;	dw keyf3 
4c23			;	dw keyf4 
4c23			;	dw keyf5 
4c23			;	dw keyf6 
4c23			;	dw keyf7 
4c23			;	dw keyf8 
4c23			;	dw keyf9 
4c23			;	dw keyf10 
4c23			;	dw keyf11 
4c23			;	dw keyf12 
4c23			;	dw keytab 
4c23			;	dw keycr 
4c23			;	dw keyhome 
4c23			;	dw keyend 
4c23			;	dw keybs 
4c23 00 00			db 0, 0	 
4c25			 
4c25			; SPI Net support words 
4c25			 
4c25			; v0! = node to send to 
4c25			; ( str count - ) 
4c25 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
4c80			 
4c80			; spiputchr ( char node - ) 
4c80 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
4cb6			 
4cb6			; spigetchr ( - n ) 
4cb6 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
4ce1			 
4ce1			; getnode ( - n ) 
4ce1 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
4d0e			 
4d0e			; ( str node - )  
4d0e .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
4d74			; store string ( str i - ) 
4d74			 
4d74			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
4d74 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
4dc9			 
4dc9			; get string ( addr i -  )    TO FIX 
4dc9			 
4dc9 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
4e21			 
4e21			 
4e21			; NETCHAT (TODO) 
4e21			; Program to allow two nodes to chat with eachother 
4e21			; 
4e21			; v0 - target node 
4e21			;  
4e21			; accept input at 0,0 
4e21			; if input is string send spitype to target node 
4e21			; starting at row 2,0 , while spigetchr is not zero ->  
4e21			; 
4e21			; 
4e21			; TODO add paging of get request 
4e21			 
4e21			; ( node - ) 
4e21 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
4e40 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
4e98 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
4f0b			 
4f0b			 
4f0b			; Long read of currently open file 
4f0b .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
4f52			 
4f52			; clear stack  
4f52			 
4f52 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
4f85			 
4f85			; type ( addr count - ) 
4f85 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
4fa9			 
4fa9			; some direct memory words 
4fa9			; strncpy ( len t f -- t ) 
4fa9			 
4fa9 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
500a			 
500a .. 00		start1:     	db ": bpon $0000 bp ;",0 
501c .. 00		start2:     	db ": bpoff $0001 bp ;",0 
502f .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
50ab .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
510b			 
510b			 
510b			; a handy word to list items on the stack 
510b			 
510b .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5175			 
5175			 
5175			; test stack  
5175			; rnd8 stest 
5175			 
5175 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
51ec			 
51ec			; random malloc and free cycles 
51ec			 
51ec .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
52a1			 
52a1			; fixed malloc and free cycles 
52a1			 
52a1 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5344			 
5344			; fixed double string push and drop cycle  
5344			 
5344 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
53f9			 
53f9			; consistent fixed string push and drop cycle  
53f9			 
53f9 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
549d			 
549d .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5553			 
5553			;test1:		db ": aa 1 2 3 ;", 0 
5553			;test2:     	db "111 aa 888 999",0 
5553			;test3:     	db ": bb 77 ;",0 
5553			;test4:     	db "$02 $01 do i . loop bb",0 
5553			 
5553 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
558b .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
55c3 .. 00		test7:     	db ": box hline vline ;",0 
55d7 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5603 .. 00		test9:     	db ": sw $01 adsp world ;",0 
5619 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
563e .. 00		test11:     	db "hello create .",0 
564d .. 00		test12:     	db "hello2 create .",0 
565d			 
565d			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
565d			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
565d			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
565d			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
565d			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
565d			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
565d			 
565d			;iftest1:     	db "$0001 IF cls .",0 
565d			;iftest2:     	db "$0000 IF cls .",0 
565d			;iftest3:     	db "$0002 $0003 - IF cls .",0 
565d			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
565d			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
565d			 
565d			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
565d			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
565d			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
565d			 
565d			 
565d			 
565d			; a small guess the number game 
565d			 
565d .. 00		game1:          db ": gsn rnd8 v1! ;",0 
566e .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
56d0			 
56d0 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5705 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
573b .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
576c .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5780 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5795 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
57c9 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
580d			 
580d			; Using 'ga' save a high score across multiple runs using external storage 
580d			 
580d .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5876			 
5876			 
5876			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5876			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5876			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5876			 
5876			; simple screen saver to test code memory reuse to destruction 
5876			 
5876 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
58ac .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
58c8 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
58e4 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
58fd .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5945 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
599c			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
599c			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
599c			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
599c			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
599c			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
599c			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
599c			 
599c			 
599c			 
599c			; minesweeper/battleship finding game 
599c			; draws a game board of random ship/mine positions 
599c			; user enters coords to see if it hits on 
599c			; game ends when all are hit 
599c			; when hit or miss says how many may be in the area 
599c			 
599c			; setup the game board and then hide it 
599c .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5a0a .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5a54			; prompt for where to target 
5a54 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5aea .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5b0f			; TODO see if the entered coords hits or misses pushes char hit of miss 
5b0f .. 00		game2mbht:      db ": mbckht nop ;",0 
5b1e .. 00		game2mbms:      db ": mbcms nop ;",0 
5b2c			; TODO how many might be near by 
5b2c .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5ba9			 
5ba9			; Game 3 
5ba9			 
5ba9			; Vert scroller ski game - avoid the trees! 
5ba9			 
5ba9			; v0 score (ie turns) 
5ba9			; v1 player pos 
5ba9			; v2 left wall 
5ba9			; v3 right wall 
5ba9			 
5ba9			; Draw side walls randomly 
5ba9			 
5ba9 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5bd7			 
5bd7			; Draw player 
5bd7 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5bf5			 
5bf5			; TODO Get Key 
5bf5			 
5bf5			; TODO Move left right 
5bf5			 
5bf5			; scroll and move walls a bit 
5bf5			 
5bf5 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5c26			 
5c26			; main game loop 
5c26			 
5c26 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5c52 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5c91			 
5c91			; key board defs 
5c91			 
5c91 .. 00		keyup:       db ": keyup $05 ;",0 
5c9f .. 00		keydown:       db ": keydown $0a ;",0 
5caf .. 00		keyleft:       db ": keyleft $0b ;",0 
5cbf .. 00		keyright:       db ": keyright $0c ;",0 
5cd0 .. 00		keyf1:       db ": keyf1 $10 ;",0 
5cde .. 00		keyf2:       db ": keyf2 $11 ;",0 
5cec .. 00		keyf3:       db ": keyf3 $12 ;",0 
5cfa .. 00		keyf4:       db ": keyf4 $13 ;",0 
5d08 .. 00		keyf5:       db ": keyf5 $14 ;",0 
5d16 .. 00		keyf6:       db ": keyf6 $15 ;",0 
5d24 .. 00		keyf7:       db ": keyf7 $16 ;",0 
5d32 .. 00		keyf8:       db ": keyf8 $17 ;",0 
5d40 .. 00		keyf9:       db ": keyf9 $18 ;",0 
5d4e .. 00		keyf10:       db ": keyf10 $19 ;",0 
5d5d .. 00		keyf11:       db ": keyf11 $1a ;",0 
5d6c .. 00		keyf12:       db ": keyf12 $1b ;",0 
5d7b			 
5d7b .. 00		keytab:       db ": keytab $09 ;",0 
5d8a .. 00		keycr:       db ": keycr $0d ;",0 
5d98 .. 00		keyhome:       db ": keyhome $0e ;",0 
5da8 .. 00		keyend:       db ": keyend $0f ;",0 
5db7 .. 00		keybs:       db ": keybs $08 ;",0 
5dc5			 
5dc5			   
5dc5			 
5dc5			 
5dc5			 
5dc5			; eof 
# End of file forth_autostart.asm
5dc5			 
5dc5 .. 00		sprompt1: db "Startup load...",0 
5dd5 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5deb			 
5deb			 
5deb			 
5deb			 
5deb			forth_startup: 
5deb 21 b1 4b			ld hl, startcmds 
5dee 3e 00			ld a, 0 
5df0 32 f1 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
5df3			 
5df3 e5			.start1:	push hl 
5df4 cd 80 0b			call clear_display 
5df7 11 c5 5d			ld de, sprompt1 
5dfa 3e 00		        ld a, display_row_1 
5dfc cd 93 0b			call str_at_display 
5dff 11 d5 5d			ld de, sprompt2 
5e02 3e 28		        ld a, display_row_2 
5e04 cd 93 0b			call str_at_display 
5e07 e1				pop hl 
5e08 e5				push hl 
5e09 5e				ld e,(hl) 
5e0a 23				inc hl 
5e0b 56				ld d,(hl) 
5e0c 3e 50		        ld a, display_row_3 
5e0e cd 93 0b			call str_at_display 
5e11 cd a3 0b			call update_display 
5e14			 
5e14			 
5e14 3a f1 e6			ld a, (os_last_cmd) 
5e17 fe 00			cp 0 
5e19 28 05			jr z, .startprompt 
5e1b cd e6 0a			call delay250ms 
5e1e 18 24			jr .startdo 
5e20				 
5e20				 
5e20			 
5e20			.startprompt: 
5e20			 
5e20 3e 9f			ld a,display_row_4 + display_cols - 1 
5e22 11 95 1b		        ld de, endprg 
5e25 cd 93 0b			call str_at_display 
5e28 cd a3 0b			call update_display 
5e2b cd f2 0a			call delay1s 
5e2e cd 9d 61			call cin_wait 
5e31						 
5e31 fe 2a			cp '*' 
5e33 28 5e			jr z, .startupend1 
5e35 fe 23			cp '#' 
5e37 20 07			jr nz, .startno 
5e39 3e 01			ld a, 1 
5e3b 32 f1 e6			ld (os_last_cmd),a 
5e3e 18 04			jr .startdo 
5e40 fe 31		.startno:	cp '1' 
5e42 28 3a			jr z,.startnxt  
5e44			 
5e44				; exec startup line 
5e44			.startdo:	 
5e44 e1				pop hl 
5e45 e5				push hl 
5e46				 
5e46 5e				ld e,(hl) 
5e47 23				inc hl 
5e48 56				ld d,(hl) 
5e49 eb				ex de,hl 
5e4a			 
5e4a e5				push hl 
5e4b			 
5e4b 3e 00			ld a, 0 
5e4d				;ld a, FORTH_END_BUFFER 
5e4d cd 16 12			call strlent 
5e50 23				inc hl   ; include zero term to copy 
5e51 06 00			ld b,0 
5e53 4d				ld c,l 
5e54 e1				pop hl 
5e55 11 cb e2			ld de, scratch 
5e58 ed b0			ldir 
5e5a			 
5e5a			 
5e5a 21 cb e2			ld hl, scratch 
5e5d cd 13 20			call forthparse 
5e60 cd 53 20			call forthexec 
5e63 cd 65 1f			call forthexec_cleanup 
5e66			 
5e66 3e 78			ld a, display_row_4 
5e68 11 39 19			ld de, endprog 
5e6b			 
5e6b cd a3 0b			call update_display		 
5e6e			 
5e6e 3a f1 e6			ld a, (os_last_cmd) 
5e71 fe 00			cp 0 
5e73 20 09			jr nz, .startnxt 
5e75 cd 97 1b			call next_page_prompt 
5e78 cd 80 0b		        call clear_display 
5e7b cd a3 0b			call update_display		 
5e7e			 
5e7e				; move onto next startup line? 
5e7e			.startnxt: 
5e7e			 
5e7e cd e6 0a			call delay250ms 
5e81 e1				pop hl 
5e82			 
5e82 23				inc hl 
5e83 23				inc hl 
5e84			 
5e84 e5				push hl 
5e85 5e				ld e, (hl) 
5e86 23				inc hl 
5e87 56				ld d, (hl) 
5e88 e1				pop hl 
5e89				; TODO replace 0 test 
5e89			 
5e89 eb				ex de, hl 
5e8a cd d6 0d			call ishlzero 
5e8d			;	ld a,e 
5e8d			;	add d 
5e8d			;	cp 0    ; any left to do? 
5e8d eb				ex de, hl 
5e8e c2 f3 5d			jp nz, .start1 
5e91 18 01			jr .startupend 
5e93			 
5e93 e1			.startupend1: pop hl 
5e94			.startupend: 
5e94			 
5e94 cd 80 0b			call clear_display 
5e97 cd a3 0b			call update_display 
5e9a c9				ret 
5e9b			 
5e9b			 
5e9b			; stack over and underflow checks 
5e9b			 
5e9b			; init the words to detect the under/overflow 
5e9b			 
5e9b			chk_stk_init: 
5e9b				; a vague random number to check so we dont get any "lucky" hits 
5e9b 3e 2d			ld a, 45 
5e9d 6f				ld l, a 
5e9e 00				nop 
5e9f 3e 17			ld a, 23 
5ea1 67				ld h, a 
5ea2			 
5ea2 22 b2 e2			ld (chk_word), hl     ; the word we need to check against 
5ea5			 
5ea5			;	ld (chk_stund), hl	; stack points.... 
5ea5 22 00 ef			ld (chk_stovr), hl 
5ea8 22 f6 e9			ld (chk_ret_und), hl 
5eab 22 b4 e9			ld (chk_ret_ovr), hl 
5eae 22 32 e9			ld (chk_loop_ovr), hl 
5eb1 22 30 e8			ld (chk_data_ovr), hl 
5eb4 c9				ret 
5eb5				 
5eb5			check_stacks: 
5eb5				; check all stack words 
5eb5			 
5eb5 e5				push hl 
5eb6 d5				push de 
5eb7			 
5eb7			;	ld de,(chk_word) 
5eb7			;	ld hl, (chk_stund)	; stack points.... 
5eb7			;	if DEBUG_STK_FAULT 
5eb7			;		DMARK "FAa" 
5eb7			;		CALLMONITOR 
5eb7			;	endif 
5eb7			;	call cmp16 
5eb7			;	jp z, .chk_faulta 
5eb7			; 
5eb7			;	ld de, sfaultsu 
5eb7			;	jp .chk_fault 
5eb7			 
5eb7 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
5eba ed 5b b2 e2		ld de,(chk_word) 
5ebe				if DEBUG_STK_FAULT 
5ebe					DMARK "FAb" 
5ebe					CALLMONITOR 
5ebe				endif 
5ebe cd cb 0d			call cmp16 
5ec1 28 06			jr z, .chk_fault1 
5ec3 11 64 5f			ld de, sfaultso 
5ec6 c3 18 5f			jp .chk_fault 
5ec9			.chk_fault1:  
5ec9 2a f6 e9			ld hl, (chk_ret_und) 
5ecc ed 5b b2 e2		ld de,(chk_word) 
5ed0				if DEBUG_STK_FAULT 
5ed0					DMARK "FAU" 
5ed0					CALLMONITOR 
5ed0				endif 
5ed0 cd cb 0d			call cmp16 
5ed3 ca dc 5e			jp z, .chk_fault2 
5ed6 11 74 5f			ld de, sfaultru 
5ed9 c3 18 5f			jp .chk_fault 
5edc			.chk_fault2:  
5edc 2a b4 e9			ld hl, (chk_ret_ovr) 
5edf ed 5b b2 e2		ld de,(chk_word) 
5ee3				if DEBUG_STK_FAULT 
5ee3					DMARK "FA1" 
5ee3					CALLMONITOR 
5ee3				endif 
5ee3 cd cb 0d			call cmp16 
5ee6 ca ef 5e			jp z, .chk_fault3 
5ee9 11 82 5f			ld de, sfaultro 
5eec c3 18 5f			jp .chk_fault 
5eef			.chk_fault3:  
5eef 2a 32 e9			ld hl, (chk_loop_ovr) 
5ef2 ed 5b b2 e2		ld de,(chk_word) 
5ef6				if DEBUG_STK_FAULT 
5ef6					DMARK "FA2" 
5ef6					CALLMONITOR 
5ef6				endif 
5ef6 cd cb 0d			call cmp16 
5ef9 ca 02 5f			jp z, .chk_fault4 
5efc 11 9c 5f			ld de, sfaultlo 
5eff c3 18 5f			jp .chk_fault 
5f02			.chk_fault4:  
5f02 2a 30 e8			ld hl, (chk_data_ovr) 
5f05 ed 5b b2 e2		ld de,(chk_word) 
5f09				if DEBUG_STK_FAULT 
5f09					DMARK "FA3" 
5f09					CALLMONITOR 
5f09				endif 
5f09 cd cb 0d			call cmp16 
5f0c ca 15 5f			jp z, .chk_fault5 
5f0f 11 b6 5f			ld de, sfaultdo 
5f12 c3 18 5f			jp .chk_fault 
5f15			 
5f15			 
5f15			.chk_fault5:  
5f15 d1				pop de 
5f16 e1				pop hl 
5f17			 
5f17 c9				ret 
5f18			 
5f18 cd 80 0b		.chk_fault: 	call clear_display 
5f1b 3e 28				ld a, display_row_2 
5f1d cd 93 0b				call str_at_display 
5f20 11 46 5f				   ld de, .stackfault 
5f23 3e 00				ld a, display_row_1 
5f25 cd 93 0b				call str_at_display 
5f28 11 71 ee				    ld de, debug_mark 
5f2b 3e 11				ld a, display_row_1+17 
5f2d cd 93 0b				call str_at_display 
5f30 cd a3 0b				call update_display 
5f33			 
5f33				; prompt before entering montior for investigating issue 
5f33			 
5f33 3e 78			ld a, display_row_4 
5f35 11 39 19			ld de, endprog 
5f38			 
5f38 cd a3 0b			call update_display		 
5f3b			 
5f3b cd 97 1b			call next_page_prompt 
5f3e			 
5f3e d1				pop de 
5f3f e1				pop hl 
5f40 cd 8d 19				call monitor 
5f43 c3 87 18				jp warmstart 
5f46					;jp 0 
5f46					;halt 
5f46			 
5f46			 
5f46			 
5f46 .. 00		.stackfault: 	db "Stack fault:",0 
5f53			 
5f53 .. 00		sfaultsu: 	db	"Stack under flow",0 
5f64 .. 00		sfaultso: 	db	"Stack over flow",0 
5f74 .. 00		sfaultru:	db "RTS underflow",0 
5f82 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
5f9c .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
5fb6 .. 00		sfaultdo:	db "DTS overflow", 0 
5fc3			 
5fc3			 
5fc3			fault_dsp_under: 
5fc3 11 d5 5f			ld de, .dsp_under 
5fc6 c3 85 60			jp .show_fault 
5fc9			 
5fc9			fault_rsp_under: 
5fc9 11 e3 5f			ld de, .rsp_under 
5fcc c3 85 60			jp .show_fault 
5fcf			fault_loop_under: 
5fcf 11 f1 5f			ld de, .loop_under 
5fd2 c3 85 60			jp .show_fault 
5fd5			 
5fd5 .. 00		.dsp_under: db "DSP Underflow",0 
5fe3 .. 00		.rsp_under: db "RSP Underflow",0 
5ff1 .. 00		.loop_under: db "LOOP Underflow",0 
6000			 
6000			 
6000 d5			type_faultn: 	push de 
6001 e5					push hl 
6002 cd 80 0b				call clear_display 
6005 11 2c 60				   ld de, .typefaultn 
6008 3e 00				ld a, display_row_1 
600a cd 93 0b				call str_at_display 
600d 11 71 ee				    ld de, debug_mark 
6010 3e 11				ld a, display_row_1+17 
6012 cd 93 0b				call str_at_display 
6015 cd a3 0b				call update_display 
6018			 
6018				; prompt before entering montior for investigating issue 
6018			 
6018 3e 78			ld a, display_row_4 
601a 11 39 19			ld de, endprog 
601d			 
601d cd a3 0b			call update_display		 
6020			 
6020 cd 97 1b			call next_page_prompt 
6023			 
6023 e5					push hl 
6024 d5					push de 
6025 cd 8d 19				call monitor 
6028 c3 87 18				jp warmstart 
602b 76					halt 
602c			 
602c			 
602c .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6043			 
6043 d5			type_faults: 	push de 
6044 e5					push hl 
6045 cd 80 0b				call clear_display 
6048 11 6e 60				   ld de, .typefaults 
604b 3e 00				ld a, display_row_1 
604d cd 93 0b				call str_at_display 
6050 11 71 ee				    ld de, debug_mark 
6053 3e 11				ld a, display_row_1+17 
6055 cd 93 0b				call str_at_display 
6058 cd a3 0b				call update_display 
605b			 
605b				; prompt before entering montior for investigating issue 
605b			 
605b 3e 78			ld a, display_row_4 
605d 11 39 19			ld de, endprog 
6060			 
6060 cd a3 0b			call update_display		 
6063			 
6063 cd 97 1b			call next_page_prompt 
6066			 
6066 e1					pop hl 
6067 d1					pop de 
6068 cd 8d 19				call monitor 
606b c3 87 18				jp warmstart 
606e			 
606e			 
606e .. 00		.typefaults: db "STR Type Expected TOS!",0 
6085			 
6085			.show_fault: 	 
6085 d5					push de 
6086 cd 80 0b				call clear_display 
6089 d1					pop de 
608a 3e 00				ld a, display_row_1 
608c cd 93 0b				call str_at_display 
608f 11 71 ee				    ld de, debug_mark 
6092 3e 11				ld a, display_row_1+17 
6094 cd 93 0b				call str_at_display 
6097 cd a3 0b				call update_display 
609a			 
609a				; prompt before entering montior for investigating issue 
609a			 
609a 3e 78			ld a, display_row_4 
609c 11 39 19			ld de, endprog 
609f			 
609f cd a3 0b			call update_display		 
60a2			 
60a2 cd 97 1b			call next_page_prompt 
60a5			 
60a5 e1					pop hl 
60a6 d1					pop de 
60a7 cd 8d 19				call monitor 
60aa			; do a dump to cli and not warmstart so we preserve all of the uwords.  
60aa			; TODO Make optional fault restart to cli or warm boot? 
60aa					;jp warmstart 
60aa c3 df 18				jp cli 
60ad 76					halt 
60ae			 
60ae			; handle the auto run of code from files in storage 
60ae			 
60ae			 
60ae			if STORAGE_SE 
60ae			 
60ae			sprompt3: db "Loading from start-up file?:",0 
60ae			sprompt4: db "(Y=Any key/N=No)",0 
60ae			 
60ae			 
60ae			forth_autoload: 
60ae			 
60ae				; load block 0 of store 1 
60ae				 
60ae				ld a, $fe      ; bit 0 clear 
60ae				ld (spi_device), a 
60ae			 
60ae				call storage_get_block_0 
60ae			 
60ae				ld a, (store_page+STORE_0_AUTOFILE) 
60ae			 
60ae				cp 0 
60ae				ret z     ; auto start not enabled 
60ae			 
60ae				call clear_display 
60ae			 
60ae				; set bank 
60ae			 
60ae					ld a, (store_page+STORE_0_BANKRUN) 
60ae					ld (spi_device), a 
60ae			 
60ae				; get file id to load from and get the file name to display 
60ae			 
60ae					ld a, (store_page+STORE_0_FILERUN) 
60ae			 
60ae					ld l, 0 
60ae					ld h, a 
60ae					ld de, store_page 
60ae			 
60ae					if DEBUG_FORTH_WORDS 
60ae						DMARK "ASp" 
60ae						CALLMONITOR 
60ae					endif 
60ae					call storage_read 
60ae			 
60ae					if DEBUG_FORTH_WORDS 
60ae						DMARK "ASr" 
60ae						CALLMONITOR 
60ae					endif 
60ae			 
60ae					call ishlzero 
60ae					ret z             ; file not found 
60ae			 
60ae					ld a, display_row_2 + 10 
60ae					ld de, store_page+3 
60ae					call str_at_display 
60ae				 
60ae			; 
60ae			 
60ae				ld a, display_row_1+5 
60ae				ld de, sprompt3 
60ae				call str_at_display 
60ae				ld a, display_row_3+15 
60ae				ld de, sprompt4 
60ae				call str_at_display 
60ae			 
60ae				call update_display 
60ae			 
60ae				call cin_wait 
60ae				cp 'n' 
60ae				ret z 
60ae				cp 'N' 
60ae				ret z 
60ae			 
60ae				call delay1s 
60ae			 
60ae				ld a, (store_page+2) 
60ae				ld (store_openmaxext), a    ; save count of ext 
60ae				ld a, 1  
60ae				ld (store_openext), a    ; save count of ext 
60ae			 
60ae			.autof:  
60ae				ld l , a 
60ae				 
60ae				ld a, (store_page) 
60ae				ld h, a	 
60ae				ld de, store_page 
60ae					if DEBUG_FORTH_WORDS 
60ae						DMARK "ASl" 
60ae						CALLMONITOR 
60ae					endif 
60ae					call storage_read 
60ae				call ishlzero 
60ae				ret z 
60ae			;	jr z, .autoend 
60ae			 
60ae					if DEBUG_FORTH_WORDS 
60ae						DMARK "ASc" 
60ae						CALLMONITOR 
60ae					endif 
60ae				ld de, store_page+2 
60ae				ld a, display_row_4 
60ae				call str_at_display 
60ae			 
60ae				call update_display 
60ae				call delay250ms 
60ae			 
60ae			 
60ae			 
60ae				ld hl, store_page+2 
60ae				call forthparse 
60ae				call forthexec 
60ae				call forthexec_cleanup 
60ae			 
60ae				 
60ae				ld a, (store_openext) 
60ae				inc a 
60ae				ld (store_openext), a    ; save count of ext 
60ae			 
60ae				jr .autof 
60ae			;.autofdone: 
60ae			; 
60ae			;		if DEBUG_FORTH_WORDS 
60ae			;			DMARK "ASx" 
60ae			;			CALLMONITOR 
60ae			;		endif 
60ae			;;	call clear_display 
60ae			;	ret 
60ae			 
60ae			 
60ae			 
60ae			endif 
60ae			 
60ae			 
60ae			; eof 
# End of file forth_kernel.asm
60ae			;include "nascombasic.asm" 
60ae			 
60ae			 
60ae			; find out where the code ends if loaded into RAM (for SC114) 
60ae			;endofcode:  
60ae			;	nop 
60ae			 
60ae			 
60ae			; eof 
60ae			 
# End of file main.asm
60ae			;include "firmware_lcd_4x40.asm" 
60ae			;;include "firmware_lcd_4x20.asm" 
60ae			include "firmware_cpm_display.asm" 
60ae			 
60ae			; Serial display interface for SC114 
60ae			 
60ae			 
60ae			display_row_1: equ 0 
60ae			display_row_2: equ display_row_1+display_cols 
60ae			display_row_3: equ display_row_2 + display_cols 
60ae			display_row_4: equ display_row_3 + display_cols 
60ae			 
60ae			kLCDWidth:  EQU display_cols             ;Width in characters 
60ae			kLCD_Line1: EQU 0x00  
60ae			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
60ae			; E1 
60ae			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
60ae			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
60ae			 
60ae			lcd_init: 
60ae				; no init as handled by the SCM bios 
60ae c9				ret 
60af			 
60af			 
60af			; low level functions for direct screen writes 
60af			 
60af			; output char at pos? 
60af			fLCD_Str: 
60af			        ;out (SC114_SIO_1_OUT),a 
60af c5				push bc 
60b0 d5				push de 
60b1 5f				ld e, a 
60b2			; TODO Replace with CP/M BIOS call 
60b2 0e 02			ld c, $02 
60b4 cd 05 00			call 5 
60b7 d1				pop de 
60b8 c1				pop bc 
60b9 c9				ret 
60ba			 
60ba			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
60ba			fLCD_Pos: 
60ba				; use ASCII escape to position 
60ba			        ;out (SC114_SIO_1_OUT),a 
60ba c5				push bc 
60bb d5				push de 
60bc 5f				ld e, a 
60bd 0e 02			ld c, $02 
60bf			; TODO Replace with CP/M BIOS call 
60bf cd 05 00			call 5 
60c2 d1				pop de 
60c3 c1				pop bc 
60c4			 
60c4 c9				ret 
60c5			 
60c5			; output char at pos 
60c5			fLCD_Data: 
60c5			      ;  out (SC114_SIO_1_OUT),a 
60c5 c5				push bc 
60c6 d5				push de 
60c7 0e 02			ld c, $02 
60c9 5f				ld e, a 
60ca			; TODO Replace with CP/M BIOS call 
60ca cd 05 00			call 5 
60cd d1				pop de 
60ce c1				pop bc 
60cf			 
60cf c9				ret 
60d0			 
60d0			; ascii cls  
60d0			 
60d0 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
60d4			 
60d4 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
60eb			;.clscpm: db 3, $3c,"$" 
60eb			 
60eb			; write the frame buffer given in hl to hardware  
60eb			write_display: 
60eb			 
60eb			API: equ 0 
60eb			 
60eb			if API 
60eb				push bc 
60eb				ld b, 4 
60eb			 
60eb			        ld (display_write_tmp), hl 	  
60eb			 
60eb				; clear and home cursor 
60eb			 
60eb				ld c, 9 
60eb				ld de, .cls 
60eb			; TODO Replace with CP/M BIOS call 
60eb				call 5 
60eb			 
60eb			 
60eb			.writeln: 
60eb			 
60eb				ld de, (display_write_tmp) 
60eb				ld c, 6 
60eb			; TODO Replace with CP/M BIOS call 
60eb				rst $30 
60eb				ld c, 7 
60eb				rst $30 
60eb			 
60eb				ld hl, (display_write_tmp) 
60eb				ld de, display_cols 
60eb				add hl,de 
60eb				ld (display_write_tmp),hl 
60eb			 
60eb				djnz  .writeln 
60eb			 
60eb				pop bc 
60eb			 
60eb			 
60eb				ret 
60eb			endif 
60eb e5				push hl 
60ec c5				push bc 
60ed d5				push de 
60ee			 
60ee			;	ld c, 2 
60ee			;	;ld de, .cls 
60ee			;	ld a, 27 
60ee			;	rst $30 
60ee			;	ld c, 2 
60ee			;	;ld de, .cls 
60ee			;	ld a, '[' 
60ee			;	rst $30 
60ee			; 
60ee			;	ld c, 2 
60ee			;	;ld de, .cls 
60ee			;	ld a, 'H' 
60ee			;	rst $30 
60ee			; 
60ee			 
60ee			 
60ee			; lots of CR/LF 
60ee			;	ld c, 9 
60ee			;	ld de, .clscpm 
60ee			;	call 5 
60ee			 
60ee			; xterm cls 
60ee 0e 02			ld c, 2 
60f0 1e 1b			ld e, 27 
60f2 cd 05 00			call 5 
60f5			; cls causes too much flicker 
60f5			;	ld c, 2 
60f5			;	ld e, 'c' 
60f5			;	call 5 
60f5			 
60f5			; use xterm home instead 
60f5 0e 02			ld c, 2 
60f7 1e 5b			ld e, '[' 
60f9 cd 05 00			call 5 
60fc 0e 02			ld c, 2 
60fe 1e 48			ld e, 'H' 
6100 cd 05 00			call 5 
6103			LLL: equ 0 
6103			 
6103			if LLL 
6103			 
6103				ld c, 2 
6103				;ld de, .cls 
6103				ld e, 27 
6103			; TODO Replace with CP/M BIOS call 
6103				call 5 
6103			 
6103			 
6103				ld c, 2 
6103				;ld de, .cls 
6103				ld e, '[' 
6103			; TODO Replace with CP/M BIOS call 
6103				call 5 
6103				ld c, 2 
6103				;ld de, .cls 
6103				ld e, '2' 
6103			; TODO Replace with CP/M BIOS call 
6103				call 5 
6103				ld c, 2 
6103				;ld de, .cls 
6103				ld e, 'J' 
6103			; TODO Replace with CP/M BIOS call 
6103				call 5 
6103			 
6103			endif 
6103			 
6103 d1				pop de 
6104 c1				pop bc 
6105 e1				pop hl 
6106			 
6106			 
6106 22 cf eb		        ld (display_write_tmp), hl 	  
6109 3e 00			ld a, kLCD_Line1 
610b			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
610b 06 28			ld b, display_cols 
610d ed 5b cf eb		ld de, (display_write_tmp) 
6111 cd 94 61			call write_len_string 
6114				 
6114			 
6114 e5			push hl 
6115 d5			push de 
6116 c5			push bc 
6117 0e 02			ld c, 2 
6119 1e 0a			ld e, 10 
611b cd 05 00			call 5 
611e 0e 02			ld c, 2 
6120 1e 0d			ld e, 13 
6122 cd 05 00			call 5 
6125			; TODO Replace with CP/M BIOS call 
6125				;rst $30 
6125 c1			pop bc 
6126 d1			pop de 
6127 e1			pop hl 
6128			 
6128				 
6128 2a cf eb			ld hl, (display_write_tmp) 
612b 11 28 00			ld de, display_cols 
612e 19				add hl,de 
612f 22 cf eb			ld (display_write_tmp),hl 
6132			 
6132				 
6132 3e 28			ld a, kLCD_Line2 
6134			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
6134 06 28			ld b, display_cols 
6136 ed 5b cf eb		ld de, (display_write_tmp) 
613a cd 94 61			call write_len_string 
613d				 
613d 2a cf eb			ld hl, (display_write_tmp) 
6140 11 28 00			ld de, display_cols 
6143 19				add hl,de 
6144 22 cf eb			ld (display_write_tmp),hl 
6147			 
6147 e5			push hl 
6148 d5			push de 
6149 c5			push bc 
614a 0e 07			ld c, 7 
614c			; TODO Replace with CP/M BIOS call 
614c				;rst $30 
614c 0e 02			ld c, 2 
614e 1e 0a			ld e, 10 
6150 cd 05 00			call 5 
6153 0e 02			ld c, 2 
6155 1e 0d			ld e, 13 
6157 cd 05 00			call 5 
615a c1			pop bc 
615b d1			pop de 
615c e1			pop hl 
615d			 
615d				 
615d 3e 50			ld a, kLCD_Line3 
615f			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
615f 06 28			ld b, display_cols 
6161 ed 5b cf eb		ld de, (display_write_tmp) 
6165 cd 94 61			call write_len_string 
6168				 
6168 2a cf eb			ld hl, (display_write_tmp) 
616b 11 28 00			ld de, display_cols 
616e 19				add hl,de 
616f 22 cf eb			ld (display_write_tmp),hl 
6172			 
6172 e5			push hl 
6173 d5			push de 
6174 c5			push bc 
6175 0e 07			ld c, 7 
6177			; TODO Replace with CP/M BIOS call 
6177				;rst $30 
6177 0e 02			ld c, 2 
6179 1e 0a			ld e, 10 
617b cd 05 00			call 5 
617e 0e 02			ld c, 2 
6180 1e 0d			ld e, 13 
6182 cd 05 00			call 5 
6185 c1			pop bc 
6186 d1			pop de 
6187 e1			pop hl 
6188			 
6188				 
6188 3e 78			ld a, kLCD_Line4 
618a			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
618a 06 28			ld b, display_cols 
618c ed 5b cf eb		ld de, (display_write_tmp) 
6190 cd 94 61			call write_len_string 
6193 c9					ret 
6194			 
6194			 
6194				; write out a fixed length string given in b from de 
6194			 
6194 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
6195 cd c5 60		            CALL fLCD_Data      ;Write character to display 
6198 13				inc de 
6199 10 f9			djnz write_len_string 
619b c9				ret 
619c			 
619c			 
619c			; eof 
# End of file firmware_cpm_display.asm
619c			;include "firmware_key_5x10.asm" 
619c			;;include "firmware_key_4x10.asm" 
619c			include "firmware_key_cpm.asm" 
619c			; Serial keyboard interface for SC114 
619c			 
619c			 
619c			key_init: 
619c				; no init as handled by the SCM bios 
619c c9				ret 
619d			 
619d			 
619d			cin_wait: 
619d			;	ld a, 0 
619d			;	ret 
619d			 
619d				;in a,(SC114_SIO_1_IN) 
619d			        ; Use SCM API to get from whatever console device we are using 
619d			 
619d			; TODO Replace with CP/M BIOS call 
619d c5				push bc 
619e 0e 01			ld c, $01 
61a0 cd 05 00			call 5 
61a3 c1				pop bc 
61a4 c9				ret 
61a5			 
61a5			cin: 
61a5			 
61a5			 
61a5 c5				push bc 
61a6			 
61a6				; any key waiting to process? 
61a6			; TODO Replace with CP/M BIOS call 
61a6 0e 06			ld c, $06 
61a8 cd 05 00			call 5 
61ab 28 0d			jr z, .cin_skip 
61ad			 
61ad				; yep, get it 
61ad			 
61ad 0e 01			ld c, $01 
61af			; TODO Replace with CP/M BIOS call 
61af cd 05 00			call 5 
61b2			 
61b2 fe 7f			cp $7f     ; back space 
61b4 20 02			jr nz, .skipbs 
61b6 3e 08			ld a, KEY_BS 
61b8			.skipbs: 
61b8			 
61b8 c1				pop bc 
61b9 c9				ret 
61ba			.cin_skip: 
61ba 3e 00			ld a, 0 
61bc c1				pop bc 
61bd c9				ret 
61be			 
61be			 
61be			 
61be			 
# End of file firmware_key_cpm.asm
61be			endofcode:  
61be			baseram:  
61be 00				nop 
61bf			 
61bf			heap_start: equ baseram+15  ; Starting address of heap 
61bf			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
61bf			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
61bf			;VDU:  EQU     endofcode           ; BASIC Work space 
61bf			; eof 
61bf			 
# End of file os_mega_cpm.asm
61bf
