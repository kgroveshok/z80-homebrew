# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 55 92			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			;        nop  
8003			;        nop 
8003			;;	org 05h		; null out bdos call 
8003			; 
8003			;        nop  
8003			;        nop  
8003			;        nop 
8003			;;	org 08h 
8003			;;; 
8003			;;	jp cin		; rst 8 - char in 
8003			;;; 
8003			; 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;	org 010h 
8003			;; 
8003			;	jp cout		; rest 010h  - char out 
8003			;; 
8003			;	org 01bh   
8003			; 
8003			;	;jp  		; rst 01bh   - write string to display 
8003			;	jp str_at_display 
8003			; 
8003			; 
8003			;	org 020h 
8003			; 
8003			;	; jp		 ; rst 020h - read char at screen location 
8003			; 
8003			;	org 028h 
8003			 
8003				; jp		 ; rst 028h  - storage i/o 
8003			 
8003			; 	org 030h 
8003			;	jp break_point_state 
8003			  
8003			; $30  
8003			; org 038h 
8003			; $38 
8003			 
8003			; TODO any more important entry points to add to jump table for easier coding use? 
8003			 
8003			 
8003			include "firmware.asm" 
8003			  
8003			; main constants (used here and in firmware)  
8003			  
8003			; TODO have page 0 of storage as bios  
8003			  
8003			Device_A: equ 0h  
8003			Device_B: equ 040h          ; Sound  
8003			  
8003			if BASE_KEV  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_SC114  
8003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			; TODO fixup for CPM  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			Device_D: equ 0c0h             ; Keyboard and LCD  
8003			  
8003			; Odd specific debug points for testing hardware dev  
8003			  
8003			DEBUG_SOUND: equ 1  
8003			DEBUG_STK_FAULT: equ 0  
8003			DEBUG_INPUT: equ 0     ; Debug input entry code  
8003			DEBUG_KEYCINWAIT: equ 0  
8003			DEBUG_KEYCIN: equ 0  
8003			DEBUG_KEY: equ 0  
8003			DEBUG_KEY_MATRIX: equ 0  
8003			DEBUG_STORECF: equ 0  
8003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
8003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
8003			DEBUG_SPI: equ 0    ; low level spi tests  
8003			  
8003			; Enable many break points  
8003			  
8003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
8003			DEBUG_FORTH_JP: equ 0    ; 4  
8003			DEBUG_FORTH_MALLOC: equ 0  
8003			DEBUG_FORTH_MALLOC_INT: equ 0  
8003			DEBUG_FORTH_DOT: equ 0  
8003			DEBUG_FORTH_DOT_WAIT: equ 0  
8003			DEBUG_FORTH_MATHS: equ 0  
8003			DEBUG_FORTH_TOK: equ 0    ; 4  
8003			DEBUG_FORTH_PARSE: equ 0    ; 3  
8003			DEBUG_FORTH: equ 0  ;2  
8003			DEBUG_FORTH_WORDS: equ 0   ; 1  
8003			DEBUG_FORTH_PUSH: equ 0   ; 1  
8003			DEBUG_FORTH_UWORD: equ 0   ; 1  
8003			  
8003			; Enable key point breakpoints  
8003			  
8003			DEBUG_FORTH_DOT_KEY: equ 0  
8003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
8003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
8003			  
8003			; Debug stack imbalances  
8003			  
8003			ON: equ 1  
8003			OFF: equ 0  
8003			  
8003			DEBUG_STACK_IMB: equ 0  
8003			STACK_IMB_STORE: equ 20  
8003			  
8003			; House keeping and protections  
8003			  
8003			DEBUG_FORTH_STACK_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
8003			FORTH_ENABLE_FREE: equ 0  
8003			FORTH_ENABLE_MALLOCFREE: equ 1  
8003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
8003			FORTH_ENABLE_FLOATMATH: equ 0  
8003			  
8003			  
8003			CALLMONITOR: macro  
8003				call break_point_state  
8003				endm  
8003			  
8003			MALLOC_1: equ 1        ; from dk88   
8003			MALLOC_2: equ 0           ; broke  
8003			MALLOC_3: equ 0           ; really broke  
8003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
8003			  
8003			if BASE_KEV   
8003			stacksize: equ 512*2  
8003			  
8003			STACK_RET_SIZE: equ 128  
8003			STACK_LOOP_SIZE: equ 512  
8003			STACK_DATA_SIZE: equ 512  
8003			endif  
8003			if BASE_SC114  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			;if STORAGE_SE == 0  
8003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
8003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
8003			;endif  
8003			  
8003			; Blocks where directory table is held  
8003			  
8003			; Reducing the number of entries increases the max file size  
8003			  
8003			;STORE_DIR_START: equ 1  
8003			;STORE_DIR_END: equ 33  
8003			  
8003			; Blocks from where file data is stored  
8003			  
8003			;STORE_DATA_START: equ STORE_DIR_END + 1  
8003			  
8003			; Block indicators (<32 are data files)  
8003			  
8003			;STORE_BLOCK_CFG: equ $8f       ; config block  
8003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
8003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
8003			;STORE_BLOCK_FREE: equ $85       ; data block free  
8003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
8003			  
8003			  
8003			  
8003			; Directory entry flags  
8003			  
8003			;STORE_DIR_FREE: equ 0  
8003			;STORE_DIR_FILE:  equ 1  
8003			  
8003			; Structure offsets to directory entries  
8003			;STORE_DE_FLAG: equ 0  
8003			;STORE_DE_MAXEXT: equ 1  
8003			;STORE_DE_FILENAME: equ 2  
8003			  
8003			; Structure offsets to block 0  
8003			  
8003			;STORE_BK0_ISFOR: equ 1  
8003			;STORE_BK0_LABEL: equ 3  
8003			  
8003			; memory allocation   
8003			  
8003			chk_stund: equ tos+2           ; underflow check word  
8003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
8003			  
8003			; keyscan table needs rows x cols buffer  
8003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
8003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
8003			  
8003			keyscan_table_row1: equ chk_stovr -key_cols-1  
8003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
8003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
8003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
8003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
8003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
8003			keyscan_scancol: equ keyscan_table-key_cols  
8003			;keyscan_table_len: equ key_rows*key_cols  
8003			;keybufptr: equ keyscan_table - 2  
8003			;keysymbol: equ keybufptr - 1  
8003			key_held: equ keyscan_scancol-1	; currently held  
8003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
8003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
8003			key_fa: equ key_repeat_ct -1 ;  
8003			key_fb: equ key_fa -1 ;  
8003			key_fc: equ key_fb -1 ;  
8003			key_fd: equ key_fc -1 ;  
8003			key_face_held: equ key_fd - 1   
8003			  
8003			; flag for enabling/disabling various hardware diags   
8003			  
8003			hardware_diag: equ key_face_held - 1  
8003			  
8003			; hardware config switches  
8003			; TODO add bitmasks on includes for hardware  
8003			; high byte for expansion ids  
8003			;     0000 0000  no card inserted  
8003			;     0000 0001  storage card inserted  
8003			;     0000 0010  spi sd card active  
8003			  
8003			;       
8003			; low byte:  
8003			;     0000 0001   4x4 keypad  
8003			;     0000 0010   full keyboard  
8003			;     0000 0011   spi/ext keyboard  
8003			;     0000 0100   20x4 lcd  
8003			;     0000 1000   40x4 lcd  
8003			;     0000 1100   spi/ext display  
8003			;     0001 0000   ide interface available  
8003			  
8003			hardware_word: equ hardware_diag - 2  
8003			  
8003			; debug marker - optional display of debug point on the debug screens  
8003			  
8003			debug_mark: equ hardware_word - 4  
8003			  
8003			; input_str vars  
8003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
8003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
8003			input_size: equ input_start -1  ; number of chars  
8003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
8003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
8003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
8003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
8003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
8003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
8003			input_len: equ input_cur_onoff - 5 ; length of current input  
8003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
8003			  
8003			CUR_BLINK_RATE: equ 15  
8003			  
8003			key_actual_pressed: equ input_cursor - 1   
8003			key_symbol: equ key_actual_pressed - 1   
8003			key_shift: equ key_symbol - 1   
8003			  
8003			; Display allocation  
8003			  
8003			;display_rows: equ 4     ; move out to mini and mega files  
8003			;display_cols: equ 20  
8003			  
8003			display_fb_len: equ display_rows*display_cols  
8003			  
8003			; primary frame buffer     
8003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
8003			; working frame buffers  
8003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
8003			display_fb3: equ  display_fb1-display_fb_len - 1  
8003			display_fb2: equ  display_fb3-display_fb_len - 1  
8003			;  
8003			; pointer to active frame buffer  
8003			display_fb_active: equ display_fb2 - 2  
8003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
8003			display_write_tmp: equ display_lcde1e2 - 2  
8003			  
8003			  
8003			;  
8003			  
8003			;; can load into de directory  
8003			cursor_col: equ display_write_tmp-1  
8003			cursor_row: equ cursor_col-1  
8003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
8003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
8003			  
8003			; maths vars  
8003			  
8003			LFSRSeed: equ cursor_shape -20   
8003			randData: equ LFSRSeed - 2  
8003			xrandc: equ randData - 2  
8003			stackstore: equ xrandc - 2  
8003			seed1: equ  stackstore -2   
8003			seed2: equ seed1 - 2  
8003			  
8003			; cf storage vars  
8003			  
8003			iErrorNum:  equ seed2-1         ;Error number  
8003			iErrorReg:  equ iErrorNum -1              ;Error register  
8003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
8003			  
8003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
8003			  
8003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
8003			  
8003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
8003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
8003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
8003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
8003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
8003			store_tmpid: equ store_tmp3 - 1		; page temp id  
8003			store_tmpext: equ store_tmpid - 1		; file extent temp  
8003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
8003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
8003			store_filecache: equ store_openmaxext+(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
8003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
8003			;  
8003			; spi vars  
8003			  
8003			  
8003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
8003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
8003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
8003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
8003			  
8003			;;;;; forth cli params  
8003			  
8003			; TODO use a different frame buffer for forth???  
8003			  
8003			f_cursor_ptr:  equ spi_device - 1  ; offset into frame buffer for any . or EMIT output  
8003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
8003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
8003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
8003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
8003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
8003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
8003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
8003			  
8003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
8003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
8003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
8003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
8003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
8003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
8003			  
8003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
8003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
8003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
8003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
8003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
8003			  
8003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
8003			  
8003			; os/forth token vars  
8003			  
8003			os_last_cmd: equ os_var_array-255  
8003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
8003			os_current_i: equ os_cli_cmd-2  
8003			os_cur_ptr: equ os_current_i-2  
8003			os_word_scratch: equ os_cur_ptr-30  
8003			os_tok_len: equ os_word_scratch - 2  
8003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
8003			os_tok_malloc: equ os_tok_ptr - 2  
8003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
8003			os_input: equ os_last_new_uword-255  
8003			execscratch: equ os_input-255        ; exec cmd eval buffer  
8003			scratch: equ execscratch-255  
8003			  
8003			  
8003			; temp locations for new word processing to save on adding more   
8003			  
8003			os_new_malloc: equ os_input  
8003			os_new_parse_len: equ os_new_malloc + 2  
8003			os_new_word_len: equ os_new_parse_len + 2  
8003			os_new_work_ptr: equ os_new_word_len + 2  
8003			os_new_src_ptr: equ os_new_work_ptr + 2  
8003			os_new_exec: equ os_new_src_ptr + 2  
8003			os_new_exec_ptr: equ os_new_exec + 2  
8003			  
8003			; resume memory alloocations....  
8003			  
8003			os_view_disable: equ scratch - 1  
8003			os_view_af: equ os_view_disable - 2  
8003			os_view_hl: equ os_view_af -2  
8003			os_view_de: equ os_view_hl - 2  
8003			os_view_bc: equ os_view_de - 2  
8003			  
8003			; stack checksum word  
8003			if DEBUG_STACK_IMB  
8003				curframe: equ  os_view_de - 5  
8003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
8003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			else  
8003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			endif  
8003			  
8003			; with data stack could see memory filled with junk. need some memory management   
8003			; malloc and free entry points added  
8003			  
8003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
8003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			;heap_end: equ free_list-1  ; Starting address of heap  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			heap_end: equ chk_word-1  ; Starting address of heap  
8003			  
8003			  
8003			;if BASE_KEV   
8003			;heap_start: equ 0800eh  ; Starting address of heap  
8003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;heap_start: equ baseram+15  ; Starting address of heap  
8003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;endif  
8003			  
8003			  
8003			;;;;  
8003			  
8003			  
8003			; change below to point to last memory alloc above  
8003			topusermem:  equ   heap_start  
8003			  
8003			;if BASE_KEV   
8003			;baseusermem: equ 08000h  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;;aseusermem:     equ    12  
8003			;baseusermem:     equ    prompt  
8003			;;baseusermem:     equ    endofcode  
8003			;endif  
8003			  
8003			  
8003			; **********************************************************************  
8003			; **  Constants  
8003			; **********************************************************************  
8003			  
8003			; Constants used by this code module  
8003			kDataReg:   EQU Device_D           ;PIO port A data register  
8003			kContReg:   EQU Device_D+2           ;PIO port A control register  
8003			  
8003			  
8003			portbdata:  equ Device_D+1    ; port b data  
8003			portbctl:   equ Device_D+3    ; port b control  
8003			  
8003			  
8003			;KEY_SHIFT:   equ 5  
8003			;KEY_SYMBOLSHIFT:  equ 6  
8003			  
8003			KEY_SHIFTLOCK: equ 4  
8003			  
8003			  
8003			KEY_UP: equ 5  
8003			KEY_NEXTWORD: equ 6  
8003			KEY_PREVWORD: equ 7  
8003			KEY_BS: equ 8  
8003			KEY_TAB:  equ 9  
8003			KEY_DOWN: equ 10  
8003			KEY_LEFT: equ 11  
8003			KEY_RIGHT: equ 12  
8003			KEY_CR:   equ 13  
8003			KEY_HOME: equ 14  
8003			KEY_END: equ 15  
8003			  
8003			KEY_F1: equ 16  
8003			KEY_F2: equ 17  
8003			KEY_F3: equ 18  
8003			KEY_F4: equ 19  
8003			  
8003			KEY_F5: equ 20  
8003			KEY_F6: equ 21  
8003			KEY_F7: equ 22  
8003			KEY_F8: equ 23  
8003			  
8003			KEY_F9: equ 24  
8003			KEY_F10: equ 25  
8003			KEY_F11: equ 26  
8003			KEY_F12: equ 27  
8003			  
8003			;if DEBUG_KEY  
8003			;	KEY_MATRIX_NO_PRESS: equ '.'  
8003			;	KEY_SHIFT:   equ '.'  
8003			;	KEY_SYMBOLSHIFT:  equ '.'  
8003			;else  
8003				KEY_SHIFT:   equ '~'  
8003				KEY_SYMBOLSHIFT:  equ '~'  
8003				KEY_MATRIX_NO_PRESS: equ '~'  
8003			;endi  
8003			  
8003			  
8003			  
8003			  
8003			; Macro to make adding debug marks easier  
8003			  
8003			DMARK: macro str  
8003				push af  
8003				ld a, (.dmark)  
8003				ld (debug_mark),a  
8003				ld a, (.dmark+1)  
8003				ld (debug_mark+1),a  
8003				ld a, (.dmark+2)  
8003				ld (debug_mark+2),a  
8003				jr .pastdmark  
8003			.dmark: db str  
8003			.pastdmark: pop af  
8003			  
8003			endm  
8003			  
8003			  
8003			; macro to detect for stack imbalances  
8003			  
8003			include "stackimbal.asm"  
8003			; Macro and code to detect stock imbalances 
8003			 
8003			SPPUSH: equ 0 
8003			 
8003			; Add a stack frame which can be checked before return 
8003			 
8003			STACKFRAME: macro onoff frame1 frame2 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003						exx 
8003			 
8003						ld de, frame1 
8003						ld a, d 
8003						ld hl, curframe 
8003						call hexout 
8003						ld a, e 
8003						ld hl, curframe+2 
8003						call hexout 
8003			  
8003						ld hl, frame1 
8003						push hl 
8003						ld hl, frame2 
8003						push hl 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			endm 
8003			 
8003			STACKFRAMECHK: macro onoff frame1 frame2 
8003			 
8003					 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						exx 
8003						; check stack frame SP 
8003			 
8003						ld hl, frame2 
8003						pop de   ; frame2 
8003			 
8003						call cmp16 
8003						jr nz, .spnosame 
8003						 
8003			 
8003						ld hl, frame1 
8003						pop de   ; frame1 
8003			 
8003						call cmp16 
8003						jr z, .spfrsame 
8003			 
8003						.spnosame: call showsperror 
8003			 
8003						.spfrsame: nop 
8003			 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			 
8003			 
8003			endm 
8003			 
8003			 
8003			; for a sub routine, wrap SP collection and comparisons 
8003			 
8003			; Usage: 
8003			; 
8003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
8003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
8003			 
8003			SAVESP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003			 
8003						ld (store_sp+(storeword*4)), sp 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			CHECKSP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003			 
8003						; save SP after last save 
8003				 
8003						ld (store_sp+(storeword*4)+2), sp 
8003			 
8003						push hl 
8003						ld hl, store_sp+(storeword*4) 
8003						call check_stack_sp  
8003						pop hl 
8003			 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			if DEBUG_STACK_IMB 
8003			 
8003			check_stack_sp: 
8003					push de 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					push de 
8003			 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					pop hl 
8003			 
8003			 
8003					; check to see if the same 
8003			 
8003					call cmp16 
8003					jr z, .spsame 
8003			 
8003					; not same 
8003			 
8003					call showsperror 
8003			.spsame: 
8003			 
8003					pop de 
8003			 
8003					ret 
8003			 
8003			.sperr:  db "Stack imbalance",0 
8003			 
8003			 
8003			showsperror: 
8003			 
8003			 
8003				push hl 
8003				push af 
8003				push de 
8003				call clear_display 
8003				ld de, .sperr 
8003				ld a,0 
8003			;	ld de,os_word_scratch 
8003				call str_at_display 
8003				ld a, display_row_1+17 
8003				ld de, debug_mark 
8003				call str_at_display 
8003				ld a, 0 
8003				ld (curframe+4),a 
8003				ld hl, curframe 
8003				ld de, os_word_scratch 
8003				ld a, display_row_4 
8003				call str_at_display 
8003				call update_display 
8003				;call break_point_state 
8003				call cin_wait 
8003			 
8003				ld a, ' ' 
8003				ld (os_view_disable), a 
8003				pop de	 
8003				pop af 
8003				pop hl 
8003				CALLMONITOR 
8003				ret 
8003			 
8003			endif 
8003			 
8003			 
8003			 
8003			; eof 
# End of file stackimbal.asm
8003			  
8003			;TODO macro to calc col and row offset into screen  
8003			  
8003			  
8003			  
8003			hardware_init:  
8003			  
8003 3e 00				ld a, 0  
8005 32 80 ee				ld (hardware_diag), a  
8008			  
8008					; clear all the buffers  
8008			  
8008 21 1f ed				ld hl, display_fb1  
800b 22 db eb				ld (display_fb_active), hl  
800e			  
800e cd 62 87				call clear_display  
8011			  
8011 21 dd eb				ld hl, display_fb2  
8014 22 db eb				ld (display_fb_active), hl  
8017			  
8017 cd 62 87				call clear_display  
801a			  
801a					; init primary frame buffer area  
801a 21 c0 ed				ld hl, display_fb0  
801d 22 db eb				ld (display_fb_active), hl  
8020			  
8020 cd 62 87				call clear_display  
8023			  
8023			  
8023 cd fc c5				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8026			  
8026 cd 9e c6			call key_init  
8029 cd b0 80			call storage_init  
802c			  
802c				; setup malloc functions  
802c			  
802c				if MALLOC_1  
802c cd 5e 8d				call  heap_init  
802f				endif  
802f				if MALLOC_4  
802f					call  heap_init  
802f				endif  
802f			  
802f				; init sound hardware if present  
802f			  
802f				if SOUND_ENABLE  
802f					call sound_init  
802f				endif  
802f			  
802f				; lcd test sequence  
802f					  
802f cd 85 87			call update_display  
8032 cd e6 86			call delay1s  
8035 3e 2b			ld a,'+'  
8037 cd 67 87			call fill_display  
803a cd 85 87			call update_display  
803d cd e6 86			call delay1s  
8040 3e 2a			ld a,'*'  
8042 cd 67 87			call fill_display  
8045 cd 85 87			call update_display  
8048 cd e6 86			call delay1s  
804b 3e 2d			ld a,'-'  
804d cd 67 87			call fill_display  
8050 cd 85 87			call update_display  
8053 cd e6 86			call delay1s  
8056			  
8056			; boot splash screen  
8056			if display_cols == 20	  
8056			        ld a, display_row_1    
8056			else  
8056 3e 0a		        ld a, display_row_1 +10   
8058			endif  
8058 11 89 80			ld de, bootmsg  
805b cd 75 87			call str_at_display  
805e cd 85 87			call update_display  
8061			  
8061			  
8061 cd e6 86			call delay1s  
8064 cd e6 86			call delay1s  
8067			if display_cols == 20	  
8067			            LD   A, display_row_3+2  
8067			else  
8067 3e 5c		            LD   A, display_row_3+12  
8069			endif  
8069 11 9e 80			ld de, bootmsg1  
806c cd 75 87			call str_at_display  
806f cd 85 87			call update_display  
8072 cd e6 86			call delay1s  
8075 cd e6 86			call delay1s  
8078			  
8078			;	ld a, display_row_4+3  
8078			;	ld de, bootmsg2  
8078			;	call str_at_display  
8078			;	call update_display  
8078			;	call delay1s  
8078			;	call delay1s  
8078			  
8078			; debug mark setup  
8078			  
8078 3e 5f		ld a, '_'  
807a 32 7a ee		ld (debug_mark),a  
807d 32 7b ee		ld (debug_mark+1),a  
8080 32 7c ee		ld (debug_mark+2),a  
8083 3e 00		ld a,0  
8085 32 7d ee		ld (debug_mark+3),a  
8088			  
8088 c9					ret  
8089			  
8089			  
8089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
809e .. 00		bootmsg1:	db "by Kevin Groves",0  
80ae			;bootmsg2:	db "Firmware v0.1",0  
80ae			  
80ae			; a 4x20 lcd  
80ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
80ae			  
80ae			;if display_cols == 20  
80ae			;	include "firmware_lcd_4x20.asm"  
80ae			;endif  
80ae			  
80ae			;if display_cols == 40  
80ae			;	include "firmware_lcd_4x40.asm"  
80ae			;endif  
80ae			  
80ae			;  
80ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
80ae			; TODO abstract the bit bang video out interface for dual display  
80ae			; TODO wire video out to tx pin on rc2014 bus  
80ae			  
80ae			; must supply cin, and cin_wait for low level hardware abstraction   
80ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
80ae			; test scancode  
80ae			  
80ae			;;;;;  
80ae			;;;  
80ae			; Moved out to mini and maxi versions  
80ae			;  
80ae			; include "firmware_key_4x4.asm"  
80ae			; using existing 4 wire x 4 resistor array for input  
80ae			;include "firmware_key_4x10.asm"  
80ae			; need to mod the board for 5 rows due to resistor array  
80ae			;include "firmware_key_5x10.asm"  
80ae			  
80ae			; storage hardware interface  
80ae			  
80ae			; use microchip serial eeprom for storage  
80ae			  
80ae			  
80ae			if STORAGE_SE  
80ae				include "firmware_spi.asm"  
80ae				include "firmware_seeprom.asm"  
80ae			else  
80ae			   ; create some stubs for the labels  
80ae c9			se_readbyte: ret  
80af c9			se_writebyte: ret  
80b0 c9			storage_init: ret  
80b1			  
80b1			endif  
80b1			  
80b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80b1			;include "firmware_cf.asm"  
80b1			  
80b1			; load up high level storage hardward abstractions  
80b1			include "firmware_storage.asm"  
80b1			 
80b1			; persisent storage hardware abstraction layer  
80b1			 
80b1			 
80b1			 
80b1			; Block 0 on storage is a config state 
80b1			 
80b1			 
80b1			 
80b1			; TODO add read phy block and write phy block functions 
80b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80b1			 
80b1			; Abstraction layer  
80b1			 
80b1			; Logocial block size is same size as physical size - using tape concept 
80b1			 
80b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80b1			 
80b1			 
80b1			 
80b1			; Filesystem layout (Logical layout) 
80b1			; 
80b1			; Block 0 - Bank config  
80b1			; 
80b1			;      Byte - 0 file id counter 
80b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80b1			;      Byte - 3-20 zero terminated bank label 
80b1			; 
80b1			; Block 1 > File storage 
80b1			; 
80b1			;      Byte 0 file id    - block 0 file details 
80b1			;      Byte 1 block id - block 0 is file  
80b1			;            Byte 2-15 - File name 
80b1			; 
80b1			;       - to end of block data 
80b1			; 
80b1			 
80b1			 
80b1			; Read Block 
80b1			; ---------- 
80b1			; 
80b1			; With current bank 
80b1			;  
80b1			; Get block number to read 
80b1			; Load physical blocks starting at start block into buffer 
80b1			 
80b1			; de points to buffer to use 
80b1			; hl holds logical block number  
80b1			 
80b1			storage_read_block: 
80b1			 
80b1				; TODO bank selection 
80b1			 
80b1				; for each of the physical blocks read it into the buffer 
80b1 06 40			ld b, STORE_BLOCK_PHY 
80b3			 
80b3				if DEBUG_STORESE 
80b3 d5					push de 
80b4				endif 
80b4				 
80b4			.rl1:    
80b4			 
80b4				; read physical block at hl into de 
80b4			        ; increment hl and de to next read position on exit 
80b4			 
80b4 e5				push hl 
80b5 d5				push de	 
80b6 c5				push bc 
80b7			;	if DEBUG_STORESE 
80b7			;		push af 
80b7			;		ld a, 'R' 
80b7			;		ld (debug_mark),a 
80b7			;		pop af 
80b7			;		CALLMONITOR 
80b7			;	endif 
80b7 cd ae 80			call se_readbyte 
80ba			;	if DEBUG_STORESE 
80ba			;		ld a,(spi_portbyte) 
80ba			;		ld l, a 
80ba			;		push af 
80ba			;		ld a, '1' 
80ba			;		ld (debug_mark),a 
80ba			;		pop af 
80ba			;		CALLMONITOR 
80ba			;	endif 
80ba c1				pop bc 
80bb d1				pop de 
80bc e1				pop hl 
80bd 12				ld (de),a 
80be 23				inc hl 
80bf 13				inc de 
80c0			 
80c0			;	if DEBUG_STORESE 
80c0			;		push af 
80c0			;		ld a, 'r' 
80c0			;		ld (debug_mark),a 
80c0			;		pop af 
80c0			;		CALLMONITOR 
80c0			;	endif 
80c0			 
80c0 10 f2			djnz .rl1 
80c2			 
80c2				if DEBUG_STORESE 
80c2					DMARK "SRB" 
80c2 f5				push af  
80c3 3a d7 80			ld a, (.dmark)  
80c6 32 7a ee			ld (debug_mark),a  
80c9 3a d8 80			ld a, (.dmark+1)  
80cc 32 7b ee			ld (debug_mark+1),a  
80cf 3a d9 80			ld a, (.dmark+2)  
80d2 32 7c ee			ld (debug_mark+2),a  
80d5 18 03			jr .pastdmark  
80d7 ..			.dmark: db "SRB"  
80da f1			.pastdmark: pop af  
80db			endm  
# End of macro DMARK
80db d1					pop de 
80dc			; 
80dc			;		push af 
80dc			;		ld a, 'R' 
80dc			;		ld (debug_mark),a 
80dc			;		pop af 
80dc					CALLMONITOR 
80dc cd 7f 90			call break_point_state  
80df				endm  
# End of macro CALLMONITOR
80df				endif 
80df c9				ret	 
80e0				 
80e0			 
80e0			; File Size 
80e0			; --------- 
80e0			; 
80e0			;   hl file id 
80e0			; 
80e0			;  returns in hl the number of blocks 
80e0			 
80e0			storage_file_size: 
80e0 5d				ld e, l 
80e1 16 00			ld d, 0 
80e3 21 40 00			ld hl, STORE_BLOCK_PHY 
80e6					if DEBUG_FORTH_WORDS 
80e6						DMARK "SIZ" 
80e6						CALLMONITOR 
80e6					endif 
80e6 cd 1f 83			call storage_findnextid 
80e9			 
80e9 cd e4 88			call ishlzero 
80ec			;	ld a, l 
80ec			;	add h 
80ec			;	cp 0 
80ec c8				ret z			; block not found so EOF 
80ed			 
80ed 11 65 eb			ld de, store_page 
80f0 cd b1 80			call storage_read_block 
80f3			 
80f3 3a 67 eb			ld a, (store_page+2)	 ; get extent count 
80f6 6f				ld l, a 
80f7 26 00			ld h, 0 
80f9 c9			 	ret 
80fa			 
80fa			 
80fa			; Write Block 
80fa			; ----------- 
80fa			; 
80fa			; With current bank 
80fa			;  
80fa			; Get block number to write 
80fa			; Write physical blocks starting at start block from buffer 
80fa			  
80fa			storage_write_block: 
80fa				; TODO bank selection 
80fa			 
80fa				; for each of the physical blocks read it into the buffer 
80fa 06 40			ld b, STORE_BLOCK_PHY 
80fc			 
80fc				if DEBUG_STORESE 
80fc					DMARK "SWB" 
80fc f5				push af  
80fd 3a 11 81			ld a, (.dmark)  
8100 32 7a ee			ld (debug_mark),a  
8103 3a 12 81			ld a, (.dmark+1)  
8106 32 7b ee			ld (debug_mark+1),a  
8109 3a 13 81			ld a, (.dmark+2)  
810c 32 7c ee			ld (debug_mark+2),a  
810f 18 03			jr .pastdmark  
8111 ..			.dmark: db "SWB"  
8114 f1			.pastdmark: pop af  
8115			endm  
# End of macro DMARK
8115			 
8115					;push af 
8115					;ld a, 'W' 
8115					;ld (debug_mark),a 
8115					;pop af 
8115					CALLMONITOR 
8115 cd 7f 90			call break_point_state  
8118				endm  
# End of macro CALLMONITOR
8118				endif 
8118			 
8118			; might not be working 
8118			;	call se_writepage 
8118			 
8118			;	ret 
8118			; 
8118			 
8118			 
8118			 
8118			.wl1:    
8118			 
8118				; read physical block at hl into de 
8118			        ; increment hl and de to next read position on exit 
8118			 
8118 e5				push hl 
8119 d5				push de	 
811a c5				push bc 
811b 1a				ld a,(de) 
811c				;if DEBUG_STORESE 
811c			;		push af 
811c			;		ld a, 'W' 
811c			;		ld (debug_mark),a 
811c			;		pop af 
811c			;		CALLMONITOR 
811c			;	endif 
811c cd af 80			call se_writebyte 
811f			;	call delay250ms 
811f 00				nop 
8120 00				nop 
8121 00				nop 
8122			;	if DEBUG_STORESE 
8122			;		push af 
8122			;		ld a, 'w' 
8122			;		ld (debug_mark),a 
8122			;		pop af 
8122			;		CALLMONITOR 
8122			;	endif 
8122 c1				pop bc 
8123 d1				pop de 
8124 e1				pop hl 
8125 23				inc hl 
8126 13				inc de 
8127			 
8127			 
8127 10 ef			djnz .wl1 
8129			 
8129				if DEBUG_STORESE 
8129					DMARK "SW2" 
8129 f5				push af  
812a 3a 3e 81			ld a, (.dmark)  
812d 32 7a ee			ld (debug_mark),a  
8130 3a 3f 81			ld a, (.dmark+1)  
8133 32 7b ee			ld (debug_mark+1),a  
8136 3a 40 81			ld a, (.dmark+2)  
8139 32 7c ee			ld (debug_mark+2),a  
813c 18 03			jr .pastdmark  
813e ..			.dmark: db "SW2"  
8141 f1			.pastdmark: pop af  
8142			endm  
# End of macro DMARK
8142			 
8142					;push af 
8142					;ld a, 'W' 
8142					;ld (debug_mark),a 
8142					;pop af 
8142					CALLMONITOR 
8142 cd 7f 90			call break_point_state  
8145				endm  
# End of macro CALLMONITOR
8145				endif 
8145 c9				ret	 
8146			 
8146			; Init bank 
8146			; --------- 
8146			; 
8146			; With current bank 
8146			; 
8146			; Setup block 0 config 
8146			;     Set 0 file id counter 
8146			;     Set formatted byte pattern 
8146			;     Zero out bank label 
8146			;      
8146			; For every logical block write 0-1 byte as null 
8146			 
8146			storage_get_block_0: 
8146			 
8146				; TODO check presence 
8146			 
8146				; get block 0 config 
8146			 
8146 21 00 00			ld hl, 0 
8149 11 65 eb			ld de, store_page 
814c cd b1 80			call storage_read_block 
814f			 
814f				if DEBUG_STORESE 
814f					DMARK "SB0" 
814f f5				push af  
8150 3a 64 81			ld a, (.dmark)  
8153 32 7a ee			ld (debug_mark),a  
8156 3a 65 81			ld a, (.dmark+1)  
8159 32 7b ee			ld (debug_mark+1),a  
815c 3a 66 81			ld a, (.dmark+2)  
815f 32 7c ee			ld (debug_mark+2),a  
8162 18 03			jr .pastdmark  
8164 ..			.dmark: db "SB0"  
8167 f1			.pastdmark: pop af  
8168			endm  
# End of macro DMARK
8168 11 65 eb				ld de, store_page 
816b			;		push af 
816b			;		ld a, 'i' 
816b			;		ld (debug_mark),a 
816b			;		pop af 
816b					CALLMONITOR 
816b cd 7f 90			call break_point_state  
816e				endm  
# End of macro CALLMONITOR
816e				endif 
816e			 
816e				; is this area formatted? 
816e			 
816e			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
816e 2a 66 eb			ld hl, (store_page+1) 
8171 3e 80			ld a,0x80 
8173 bd				cp l 
8174 20 22			jr nz, .ininotformatted 
8176				; do a double check 
8176 3e 27			ld a, 0x27 
8178 bc				cp h 
8179 20 1d			jr nz, .ininotformatted 
817b			 
817b				; formatted then 
817b			 
817b				if DEBUG_STORESE 
817b					DMARK "SB1" 
817b f5				push af  
817c 3a 90 81			ld a, (.dmark)  
817f 32 7a ee			ld (debug_mark),a  
8182 3a 91 81			ld a, (.dmark+1)  
8185 32 7b ee			ld (debug_mark+1),a  
8188 3a 92 81			ld a, (.dmark+2)  
818b 32 7c ee			ld (debug_mark+2),a  
818e 18 03			jr .pastdmark  
8190 ..			.dmark: db "SB1"  
8193 f1			.pastdmark: pop af  
8194			endm  
# End of macro DMARK
8194					;push af 
8194					;ld a, 'I' 
8194					;ld (debug_mark),a 
8194					;pop af 
8194					CALLMONITOR 
8194 cd 7f 90			call break_point_state  
8197				endm  
# End of macro CALLMONITOR
8197				endif 
8197 c9				ret 
8198			 
8198			.ininotformatted: 
8198				; bank not formatted so poke various bits to make sure 
8198			 
8198				if DEBUG_STORESE 
8198					DMARK "SB2" 
8198 f5				push af  
8199 3a ad 81			ld a, (.dmark)  
819c 32 7a ee			ld (debug_mark),a  
819f 3a ae 81			ld a, (.dmark+1)  
81a2 32 7b ee			ld (debug_mark+1),a  
81a5 3a af 81			ld a, (.dmark+2)  
81a8 32 7c ee			ld (debug_mark+2),a  
81ab 18 03			jr .pastdmark  
81ad ..			.dmark: db "SB2"  
81b0 f1			.pastdmark: pop af  
81b1			endm  
# End of macro DMARK
81b1					;push af 
81b1					;ld a, 'f' 
81b1					;ld (debug_mark),a 
81b1					;pop af 
81b1					CALLMONITOR 
81b1 cd 7f 90			call break_point_state  
81b4				endm  
# End of macro CALLMONITOR
81b4				endif 
81b4			 
81b4 21 65 eb			ld hl, store_page 
81b7 3e 00			ld a, 0 
81b9				 
81b9 77				ld (hl),a   ; reset file counter 
81ba			 
81ba 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
81bd 22 66 eb		 	ld (store_page+1), hl	 
81c0			 
81c0				; set default label 
81c0			 
81c0 21 55 82			ld hl, .defaultbanklabl 
81c3 11 68 eb		 	ld de, store_page+3 
81c6 01 0f 00			ld bc, 15 
81c9 ed b0			ldir 
81cb			 
81cb				; save default page 0 
81cb			 
81cb 21 00 00			ld hl, 0 
81ce 11 65 eb			ld de, store_page 
81d1				if DEBUG_STORESE 
81d1					DMARK "SB3" 
81d1 f5				push af  
81d2 3a e6 81			ld a, (.dmark)  
81d5 32 7a ee			ld (debug_mark),a  
81d8 3a e7 81			ld a, (.dmark+1)  
81db 32 7b ee			ld (debug_mark+1),a  
81de 3a e8 81			ld a, (.dmark+2)  
81e1 32 7c ee			ld (debug_mark+2),a  
81e4 18 03			jr .pastdmark  
81e6 ..			.dmark: db "SB3"  
81e9 f1			.pastdmark: pop af  
81ea			endm  
# End of macro DMARK
81ea			;		push af 
81ea			;		ld a, 'F' 
81ea			;		ld (debug_mark),a 
81ea			;		pop af 
81ea					CALLMONITOR 
81ea cd 7f 90			call break_point_state  
81ed				endm  
# End of macro CALLMONITOR
81ed				endif 
81ed cd fa 80			call storage_write_block 
81f0				if DEBUG_STORESE 
81f0					DMARK "SB4" 
81f0 f5				push af  
81f1 3a 05 82			ld a, (.dmark)  
81f4 32 7a ee			ld (debug_mark),a  
81f7 3a 06 82			ld a, (.dmark+1)  
81fa 32 7b ee			ld (debug_mark+1),a  
81fd 3a 07 82			ld a, (.dmark+2)  
8200 32 7c ee			ld (debug_mark+2),a  
8203 18 03			jr .pastdmark  
8205 ..			.dmark: db "SB4"  
8208 f1			.pastdmark: pop af  
8209			endm  
# End of macro DMARK
8209			;		push af 
8209			;		ld a, '>' 
8209			;		ld (debug_mark),a 
8209			;		pop af 
8209					CALLMONITOR 
8209 cd 7f 90			call break_point_state  
820c				endm  
# End of macro CALLMONITOR
820c				endif 
820c			 
820c 00				nop 
820d 00				nop 
820e 00				nop 
820f			 
820f				; now set 0 in every page to mark as a free block 
820f			 
820f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8211 21 40 00			ld hl, STORE_BLOCK_PHY 
8214			 
8214 3e 00		.setmark1:   	ld a,0 
8216 e5					push hl 
8217 c5					push bc 
8218 cd af 80				call se_writebyte 
821b 3e 0a			ld a, 10 
821d cd cb 86			call aDelayInMS 
8220 23				inc hl 
8221 cd af 80				call se_writebyte 
8224 3e 0a			ld a, 10 
8226 cd cb 86			call aDelayInMS 
8229 2b				dec hl 
822a c1					pop bc 
822b e1					pop hl 
822c 3e 40				ld a, STORE_BLOCK_PHY 
822e cd bb 88				call addatohl 
8231 10 e1				djnz .setmark1 
8233			 
8233 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8235 3e 00		.setmark2:   	ld a,0 
8237 e5					push hl 
8238 c5					push bc 
8239 cd af 80				call se_writebyte 
823c 3e 0a			ld a, 10 
823e cd cb 86			call aDelayInMS 
8241 23				inc hl 
8242 cd af 80				call se_writebyte 
8245 3e 0a			ld a, 10 
8247 cd cb 86			call aDelayInMS 
824a 2b				dec hl 
824b c1					pop bc 
824c e1					pop hl 
824d 3e 40				ld a, STORE_BLOCK_PHY 
824f cd bb 88				call addatohl 
8252 10 e1				djnz .setmark2 
8254			 
8254					 
8254			 
8254			 
8254 c9				ret 
8255			 
8255			 
8255			 
8255			 
8255 .. 00		.defaultbanklabl:   db "BankLabel",0 
825f			 
825f			 
825f			 
825f			; Label Bank 
825f			; ---------- 
825f			; 
825f			; With current bank 
825f			; Read block 0 
825f			; Set label 
825f			; Write block 0 
825f			 
825f			; label str pointer in hl 
825f			 
825f			storage_label:     
825f			 
825f				if DEBUG_STORESE 
825f					DMARK "LBL" 
825f f5				push af  
8260 3a 74 82			ld a, (.dmark)  
8263 32 7a ee			ld (debug_mark),a  
8266 3a 75 82			ld a, (.dmark+1)  
8269 32 7b ee			ld (debug_mark+1),a  
826c 3a 76 82			ld a, (.dmark+2)  
826f 32 7c ee			ld (debug_mark+2),a  
8272 18 03			jr .pastdmark  
8274 ..			.dmark: db "LBL"  
8277 f1			.pastdmark: pop af  
8278			endm  
# End of macro DMARK
8278					CALLMONITOR 
8278 cd 7f 90			call break_point_state  
827b				endm  
# End of macro CALLMONITOR
827b				endif 
827b			 
827b e5				push hl 
827c			 
827c cd 46 81			call storage_get_block_0 
827f			 
827f				; set default label 
827f			 
827f e1				pop hl 
8280			 
8280 11 68 eb		 	ld de, store_page+3 
8283 01 0f 00			ld bc, 15 
8286				if DEBUG_STORESE 
8286					DMARK "LB3" 
8286 f5				push af  
8287 3a 9b 82			ld a, (.dmark)  
828a 32 7a ee			ld (debug_mark),a  
828d 3a 9c 82			ld a, (.dmark+1)  
8290 32 7b ee			ld (debug_mark+1),a  
8293 3a 9d 82			ld a, (.dmark+2)  
8296 32 7c ee			ld (debug_mark+2),a  
8299 18 03			jr .pastdmark  
829b ..			.dmark: db "LB3"  
829e f1			.pastdmark: pop af  
829f			endm  
# End of macro DMARK
829f					CALLMONITOR 
829f cd 7f 90			call break_point_state  
82a2				endm  
# End of macro CALLMONITOR
82a2				endif 
82a2 ed b0			ldir 
82a4				; save default page 0 
82a4			 
82a4 21 00 00			ld hl, 0 
82a7 11 65 eb			ld de, store_page 
82aa				if DEBUG_STORESE 
82aa					DMARK "LBW" 
82aa f5				push af  
82ab 3a bf 82			ld a, (.dmark)  
82ae 32 7a ee			ld (debug_mark),a  
82b1 3a c0 82			ld a, (.dmark+1)  
82b4 32 7b ee			ld (debug_mark+1),a  
82b7 3a c1 82			ld a, (.dmark+2)  
82ba 32 7c ee			ld (debug_mark+2),a  
82bd 18 03			jr .pastdmark  
82bf ..			.dmark: db "LBW"  
82c2 f1			.pastdmark: pop af  
82c3			endm  
# End of macro DMARK
82c3					CALLMONITOR 
82c3 cd 7f 90			call break_point_state  
82c6				endm  
# End of macro CALLMONITOR
82c6				endif 
82c6 cd fa 80			call storage_write_block 
82c9			 
82c9 c9				ret 
82ca			 
82ca			 
82ca			 
82ca			; Read Block 0 - Config 
82ca			; --------------------- 
82ca			; 
82ca			; With current bank 
82ca			; Call presence test 
82ca			;    If not present format/init bank  
82ca			; Read block 0  
82ca			;  
82ca			 
82ca			 
82ca			; Dir 
82ca			; --- 
82ca			; 
82ca			; With current bank 
82ca			; Load Block 0 Config 
82ca			; Get max file id number 
82ca			; For each logical block 
82ca			;    Read block read byte 2 
82ca			;      if first block of file 
82ca			;         Display file name 
82ca			;         Display type flags for file 
82ca			;        
82ca			 
82ca			; moving to words as this requires stack control 
82ca			 
82ca			 
82ca			; Delete File 
82ca			; ----------- 
82ca			; 
82ca			; With current bank 
82ca			; 
82ca			; Load Block 0 Config 
82ca			; Get max file id number 
82ca			; For each logical block 
82ca			;    Read block file id 
82ca			;      If first block of file and dont have file id 
82ca			;         if file to delete 
82ca			;         Save file id 
82ca			;         Null file id 
82ca			;         Write this block back 
82ca			;      If file id is one saved 
82ca			;         Null file id 
82ca			;         Write this block back 
82ca			 
82ca			storage_erase: 
82ca			 
82ca				; hl contains the file id 
82ca			 
82ca 5d				ld e, l 
82cb 16 00			ld d, 0 
82cd 21 40 00			ld hl, STORE_BLOCK_PHY 
82d0					if DEBUG_FORTH_WORDS 
82d0						DMARK "ERA" 
82d0						CALLMONITOR 
82d0					endif 
82d0 cd 1f 83			call storage_findnextid 
82d3			 
82d3 e5				push hl 
82d4			 
82d4				; TODO check file not found 
82d4			 
82d4 11 65 eb			ld de, store_page 
82d7 cd b1 80			call storage_read_block 
82da			 
82da					if DEBUG_FORTH_WORDS 
82da						DMARK "ER1" 
82da						CALLMONITOR 
82da					endif 
82da 3a 65 eb			ld a, (store_page)	; get file id 
82dd 32 5e eb			ld (store_tmpid), a 
82e0			 
82e0 3a 67 eb			ld a, (store_page+2)    ; get count of extends 
82e3 32 5d eb			ld (store_tmpext), a 
82e6			 
82e6				; wipe file header 
82e6			 
82e6 e1				pop hl 
82e7 3e 00			ld a, 0 
82e9 32 65 eb			ld (store_page), a 
82ec 32 66 eb			ld (store_page+1),a 
82ef 11 65 eb			ld de, store_page 
82f2					if DEBUG_FORTH_WORDS 
82f2						DMARK "ER2" 
82f2						CALLMONITOR 
82f2					endif 
82f2 cd fa 80			call storage_write_block 
82f5			 
82f5			 
82f5				; wipe file extents 
82f5			 
82f5 3a 5d eb			ld a, (store_tmpext) 
82f8 47				ld b, a 
82f9			 
82f9			.eraext:	  
82f9 c5				push bc 
82fa			 
82fa 21 40 00			ld hl, STORE_BLOCK_PHY 
82fd 3a 5e eb			ld a,(store_tmpid) 
8300 5f				ld e, a 
8301 50				ld d, b	 
8302					if DEBUG_FORTH_WORDS 
8302						DMARK "ER3" 
8302						CALLMONITOR 
8302					endif 
8302 cd 1f 83			call storage_findnextid 
8305			 
8305 e5				push hl 
8306 11 65 eb			ld de, store_page 
8309 cd b1 80			call storage_read_block 
830c			 
830c				; free block	 
830c			 
830c 3e 00			ld a, 0 
830e 32 65 eb			ld (store_page), a 
8311 32 66 eb			ld (store_page+1),a 
8314 11 65 eb			ld de, store_page 
8317 e1				pop hl 
8318					if DEBUG_FORTH_WORDS 
8318						DMARK "ER4" 
8318						CALLMONITOR 
8318					endif 
8318 cd fa 80			call storage_write_block 
831b			 
831b c1				pop bc 
831c 10 db			djnz .eraext 
831e			 
831e c9				ret 
831f			 
831f			 
831f			; Find Free Block 
831f			; --------------- 
831f			; 
831f			; With current bank 
831f			;  
831f			; From given starting logical block 
831f			;    Read block  
831f			;    If no file id 
831f			;         Return block id 
831f			 
831f			 
831f			; hl starting page number 
831f			; hl contains free page number or zero if no pages free 
831f			; e contains the file id to locate 
831f			; d contains the block number 
831f			 
831f			; TODO change to find file id and use zero for free block 
831f			 
831f			storage_findnextid: 
831f			 
831f				; now locate first 0 page to mark as a free block 
831f			 
831f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8321			;	ld hl, STORE_BLOCK_PHY 
8321			 
8321					if DEBUG_FORTH_WORDS 
8321					DMARK "FNI" 
8321						CALLMONITOR 
8321					endif 
8321			.ff1:   	 
8321 e5					push hl 
8322 c5					push bc 
8323 d5					push de 
8324 cd ae 80				call se_readbyte 
8327 5f					ld e,a 
8328 23					inc hl 
8329 cd ae 80				call se_readbyte 
832c 57					ld d, a 
832d e1					pop hl 
832e e5					push hl 
832f cd d9 88				call cmp16 
8332 28 2d				jr z, .fffound 
8334			 
8334 d1					pop de 
8335 c1					pop bc 
8336 e1					pop hl 
8337			 
8337					; is found? 
8337					;cp e 
8337					;ret z 
8337			 
8337 3e 40				ld a, STORE_BLOCK_PHY 
8339 cd bb 88				call addatohl 
833c 10 e3				djnz .ff1 
833e			 
833e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8340			.ff2:   	 
8340			 
8340 e5					push hl 
8341 c5					push bc 
8342 d5					push de 
8343 cd ae 80				call se_readbyte 
8346 5f					ld e,a 
8347 23					inc hl 
8348 cd ae 80				call se_readbyte 
834b 57					ld d, a 
834c			 
834c e1					pop hl 
834d e5					push hl 
834e cd d9 88				call cmp16 
8351 28 0e				jr z, .fffound 
8353			 
8353 d1					pop de 
8354 c1					pop bc 
8355 e1					pop hl 
8356					; is found? 
8356					;cp e 
8356					;ret z 
8356			 
8356 3e 40				ld a, STORE_BLOCK_PHY 
8358 cd bb 88				call addatohl 
835b 10 e3				djnz .ff2 
835d			 
835d			 
835d					if DEBUG_FORTH_WORDS 
835d					DMARK "FN-" 
835d					;	push af 
835d					;	ld a, 'n' 
835d					;	ld (debug_mark),a 
835d					;	pop af 
835d						CALLMONITOR 
835d					endif 
835d				; no free marks! 
835d 21 00 00				ld hl, 0 
8360 c9				ret 
8361			.fffound: 
8361				 
8361			 
8361 d1					pop de 
8362 c1					pop bc 
8363 e1					pop hl 
8364					if DEBUG_FORTH_WORDS 
8364					DMARK "FNF" 
8364					;	push af 
8364					;	ld a, 'n' 
8364					;	ld (debug_mark),a 
8364					;	pop af 
8364						CALLMONITOR 
8364					endif 
8364 c9				ret 
8365			 
8365			 
8365			 
8365			; Free Space 
8365			; ---------- 
8365			; 
8365			; With current bank 
8365			; 
8365			; Set block count to zero 
8365			; Starting with first logical block 
8365			;      Find free block  
8365			;      If block id given, increment block count 
8365			; 
8365			;  
8365			 
8365			 
8365			; hl contains count of free blocks 
8365			 
8365			storage_freeblocks: 
8365			 
8365				; now locate first 0 page to mark as a free block 
8365			 
8365 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8367 21 40 00			ld hl, STORE_BLOCK_PHY 
836a 11 00 00			ld de, 0 
836d			 
836d			.fb1:   	 
836d e5					push hl 
836e c5					push bc 
836f d5					push de 
8370 cd ae 80				call se_readbyte 
8373 d1					pop de 
8374 c1					pop bc 
8375 e1					pop hl 
8376			 
8376					; is free? 
8376 fe 00				cp 0 
8378 20 01				jr nz, .ff1cont 
837a 13					inc de 
837b			 
837b			.ff1cont: 
837b			 
837b			 
837b 3e 40				ld a, STORE_BLOCK_PHY 
837d cd bb 88				call addatohl 
8380 10 eb				djnz .fb1 
8382			 
8382 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8384			.fb2:   	 
8384 e5					push hl 
8385 c5					push bc 
8386 d5					push de 
8387 cd ae 80				call se_readbyte 
838a d1					pop de 
838b c1					pop bc 
838c e1					pop hl 
838d			 
838d					; is free? 
838d fe 00				cp 0 
838f 20 01				jr nz, .ff2cont 
8391 13					inc de 
8392			 
8392			.ff2cont: 
8392			 
8392 3e 40				ld a, STORE_BLOCK_PHY 
8394 cd bb 88				call addatohl 
8397 10 eb				djnz .fb2 
8399			 
8399 eb				ex de, hl 
839a c9				ret 
839b			 
839b			; Get File ID 
839b			; ----------- 
839b			; 
839b			; With current bank 
839b			;  
839b			; Load Block 0 Config 
839b			; Get max file id number 
839b			; For each logical block 
839b			;    Read block file id 
839b			;      If first block of file and dont have file id 
839b			;         if file get id and exit 
839b			 
839b			 
839b			 
839b			 
839b			; Create File 
839b			; ----------- 
839b			; 
839b			; With current bank  
839b			; Load Block 0 Config 
839b			; Get max file id number 
839b			; Increment file id number 
839b			; Save Config 
839b			; Find free block 
839b			; Set buffer with file name and file id 
839b			; Write buffer to free block  
839b			 
839b			 
839b			; hl point to file name 
839b			; hl returns file id 
839b			 
839b			; file format: 
839b			; byte 0 - file id 
839b			; byte 1 - extent number 
839b			; byte 2-> data 
839b			 
839b			; format for extent number 0: 
839b			; 
839b			; byte 0 - file id 
839b			; byte 1 - extent 0 
839b			; byte 2 - extent count 
839b			; byte 3 -> file name and meta data 
839b			 
839b			 
839b			storage_create: 
839b				if DEBUG_STORESE 
839b					DMARK "SCR" 
839b f5				push af  
839c 3a b0 83			ld a, (.dmark)  
839f 32 7a ee			ld (debug_mark),a  
83a2 3a b1 83			ld a, (.dmark+1)  
83a5 32 7b ee			ld (debug_mark+1),a  
83a8 3a b2 83			ld a, (.dmark+2)  
83ab 32 7c ee			ld (debug_mark+2),a  
83ae 18 03			jr .pastdmark  
83b0 ..			.dmark: db "SCR"  
83b3 f1			.pastdmark: pop af  
83b4			endm  
# End of macro DMARK
83b4					CALLMONITOR 
83b4 cd 7f 90			call break_point_state  
83b7				endm  
# End of macro CALLMONITOR
83b7				endif 
83b7			 
83b7 e5				push hl		; save file name pointer 
83b8			 
83b8 cd 46 81			call storage_get_block_0 
83bb			 
83bb 3a 65 eb			ld a,(store_page)	; get current file id 
83be 3c				inc a 
83bf 32 65 eb			ld (store_page),a 
83c2				 
83c2 32 5e eb			ld (store_tmpid),a			; save id 
83c5			 
83c5 21 00 00			ld hl, 0 
83c8 11 65 eb			ld de, store_page 
83cb				if DEBUG_STORESE 
83cb					DMARK "SCw" 
83cb f5				push af  
83cc 3a e0 83			ld a, (.dmark)  
83cf 32 7a ee			ld (debug_mark),a  
83d2 3a e1 83			ld a, (.dmark+1)  
83d5 32 7b ee			ld (debug_mark+1),a  
83d8 3a e2 83			ld a, (.dmark+2)  
83db 32 7c ee			ld (debug_mark+2),a  
83de 18 03			jr .pastdmark  
83e0 ..			.dmark: db "SCw"  
83e3 f1			.pastdmark: pop af  
83e4			endm  
# End of macro DMARK
83e4					CALLMONITOR 
83e4 cd 7f 90			call break_point_state  
83e7				endm  
# End of macro CALLMONITOR
83e7				endif 
83e7 cd fa 80			call storage_write_block	 ; save update 
83ea			 
83ea				if DEBUG_STORESE 
83ea 11 65 eb				ld de, store_page 
83ed					DMARK "SCC" 
83ed f5				push af  
83ee 3a 02 84			ld a, (.dmark)  
83f1 32 7a ee			ld (debug_mark),a  
83f4 3a 03 84			ld a, (.dmark+1)  
83f7 32 7b ee			ld (debug_mark+1),a  
83fa 3a 04 84			ld a, (.dmark+2)  
83fd 32 7c ee			ld (debug_mark+2),a  
8400 18 03			jr .pastdmark  
8402 ..			.dmark: db "SCC"  
8405 f1			.pastdmark: pop af  
8406			endm  
# End of macro DMARK
8406					CALLMONITOR 
8406 cd 7f 90			call break_point_state  
8409				endm  
# End of macro CALLMONITOR
8409				endif 
8409				;  
8409				 
8409 21 40 00			ld hl, STORE_BLOCK_PHY 
840c 11 00 00			ld de, 0 
840f cd 1f 83			call storage_findnextid 
8412			 
8412 22 63 eb			ld (store_tmppageid), hl    ; save page to use  
8415			 
8415				; TODO detect 0 = no spare blocks 
8415			 
8415				; hl now contains the free page to use for the file header page 
8415			 
8415				if DEBUG_STORESE 
8415				DMARK "SCF" 
8415 f5				push af  
8416 3a 2a 84			ld a, (.dmark)  
8419 32 7a ee			ld (debug_mark),a  
841c 3a 2b 84			ld a, (.dmark+1)  
841f 32 7b ee			ld (debug_mark+1),a  
8422 3a 2c 84			ld a, (.dmark+2)  
8425 32 7c ee			ld (debug_mark+2),a  
8428 18 03			jr .pastdmark  
842a ..			.dmark: db "SCF"  
842d f1			.pastdmark: pop af  
842e			endm  
# End of macro DMARK
842e					CALLMONITOR 
842e cd 7f 90			call break_point_state  
8431				endm  
# End of macro CALLMONITOR
8431				endif 
8431			 
8431 22 63 eb			ld (store_tmppageid), hl 
8434				 
8434 3a 5e eb			ld a,(store_tmpid)    ; get file id 
8437			;	ld a, (store_filecache)			; save to cache 
8437			 
8437 32 65 eb			ld (store_page),a    ; set page id 
843a 3e 00			ld a, 0			 ; extent 0 is file header 
843c 32 66 eb			ld (store_page+1), a   ; set file extent 
843f			 
843f 32 67 eb			ld (store_page+2), a   ; extent count for the file 
8442			 
8442			;	inc hl 		; init block 0 of file 
8442			;	inc hl   		; skip file and extent id 
8442			 ;       ld a, 0 
8442			;	ld (hl),a 
8442			;	ld a, (store_filecache+1)  	; save to cache 
8442			 
8442			;	inc hl    ; file name 
8442				 
8442				 
8442 11 68 eb			ld de, store_page+3    ; get buffer for term string to use as file name 
8445				if DEBUG_STORESE 
8445					DMARK "SCc" 
8445 f5				push af  
8446 3a 5a 84			ld a, (.dmark)  
8449 32 7a ee			ld (debug_mark),a  
844c 3a 5b 84			ld a, (.dmark+1)  
844f 32 7b ee			ld (debug_mark+1),a  
8452 3a 5c 84			ld a, (.dmark+2)  
8455 32 7c ee			ld (debug_mark+2),a  
8458 18 03			jr .pastdmark  
845a ..			.dmark: db "SCc"  
845d f1			.pastdmark: pop af  
845e			endm  
# End of macro DMARK
845e					CALLMONITOR 
845e cd 7f 90			call break_point_state  
8461				endm  
# End of macro CALLMONITOR
8461				endif 
8461 e1				pop hl    ; get zero term string 
8462 e5				push hl 
8463 3e 00			ld a, 0 
8465 cd 24 8d			call strlent 
8468 23				inc hl   ; cover zero term 
8469 06 00			ld b,0 
846b 4d				ld c,l 
846c e1				pop hl 
846d				;ex de, hl 
846d				if DEBUG_STORESE 
846d					DMARK "SCa" 
846d f5				push af  
846e 3a 82 84			ld a, (.dmark)  
8471 32 7a ee			ld (debug_mark),a  
8474 3a 83 84			ld a, (.dmark+1)  
8477 32 7b ee			ld (debug_mark+1),a  
847a 3a 84 84			ld a, (.dmark+2)  
847d 32 7c ee			ld (debug_mark+2),a  
8480 18 03			jr .pastdmark  
8482 ..			.dmark: db "SCa"  
8485 f1			.pastdmark: pop af  
8486			endm  
# End of macro DMARK
8486					;push af 
8486					;ld a, 'a' 
8486					;ld (debug_mark),a 
8486					;pop af 
8486					CALLMONITOR 
8486 cd 7f 90			call break_point_state  
8489				endm  
# End of macro CALLMONITOR
8489				endif 
8489 ed b0			ldir    ; copy zero term string 
848b				if DEBUG_STORESE 
848b					DMARK "SCA" 
848b f5				push af  
848c 3a a0 84			ld a, (.dmark)  
848f 32 7a ee			ld (debug_mark),a  
8492 3a a1 84			ld a, (.dmark+1)  
8495 32 7b ee			ld (debug_mark+1),a  
8498 3a a2 84			ld a, (.dmark+2)  
849b 32 7c ee			ld (debug_mark+2),a  
849e 18 03			jr .pastdmark  
84a0 ..			.dmark: db "SCA"  
84a3 f1			.pastdmark: pop af  
84a4			endm  
# End of macro DMARK
84a4					CALLMONITOR 
84a4 cd 7f 90			call break_point_state  
84a7				endm  
# End of macro CALLMONITOR
84a7				endif 
84a7			 
84a7				; write file header page 
84a7			 
84a7 2a 63 eb			ld hl,(store_tmppageid) 
84aa 11 65 eb			ld de, store_page 
84ad				if DEBUG_STORESE 
84ad					DMARK "SCb" 
84ad f5				push af  
84ae 3a c2 84			ld a, (.dmark)  
84b1 32 7a ee			ld (debug_mark),a  
84b4 3a c3 84			ld a, (.dmark+1)  
84b7 32 7b ee			ld (debug_mark+1),a  
84ba 3a c4 84			ld a, (.dmark+2)  
84bd 32 7c ee			ld (debug_mark+2),a  
84c0 18 03			jr .pastdmark  
84c2 ..			.dmark: db "SCb"  
84c5 f1			.pastdmark: pop af  
84c6			endm  
# End of macro DMARK
84c6					;push af 
84c6					;ld a, 'b' 
84c6					;ld (debug_mark),a 
84c6					;pop af 
84c6					CALLMONITOR 
84c6 cd 7f 90			call break_point_state  
84c9				endm  
# End of macro CALLMONITOR
84c9				endif 
84c9 cd fa 80			call storage_write_block 
84cc			 
84cc 3a 5e eb			ld a, (store_tmpid) 
84cf 6f				ld l, a 
84d0 26 00			ld h,0 
84d2				if DEBUG_STORESE 
84d2					DMARK "SCz" 
84d2 f5				push af  
84d3 3a e7 84			ld a, (.dmark)  
84d6 32 7a ee			ld (debug_mark),a  
84d9 3a e8 84			ld a, (.dmark+1)  
84dc 32 7b ee			ld (debug_mark+1),a  
84df 3a e9 84			ld a, (.dmark+2)  
84e2 32 7c ee			ld (debug_mark+2),a  
84e5 18 03			jr .pastdmark  
84e7 ..			.dmark: db "SCz"  
84ea f1			.pastdmark: pop af  
84eb			endm  
# End of macro DMARK
84eb					CALLMONITOR 
84eb cd 7f 90			call break_point_state  
84ee				endm  
# End of macro CALLMONITOR
84ee				endif 
84ee c9				ret 
84ef				 
84ef			 
84ef			 
84ef			; 
84ef			; Read File 
84ef			; 
84ef			; h - file id to locate 
84ef			; l - extent to locate 
84ef			; de - pointer to string to read into 
84ef			; 
84ef			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
84ef			storage_read: 
84ef d5				push de 
84f0			 
84f0			; TODO BUG the above push is it popped before the RET Z? 
84f0			 
84f0			; TODO how to handle multiple part blocks 
84f0			 
84f0				; locate file extent to read 
84f0			 
84f0 5c				ld e, h 
84f1 55				ld d, l 
84f2 21 40 00			ld hl, STORE_BLOCK_PHY 
84f5				if DEBUG_STORESE 
84f5					DMARK "SRE" 
84f5 f5				push af  
84f6 3a 0a 85			ld a, (.dmark)  
84f9 32 7a ee			ld (debug_mark),a  
84fc 3a 0b 85			ld a, (.dmark+1)  
84ff 32 7b ee			ld (debug_mark+1),a  
8502 3a 0c 85			ld a, (.dmark+2)  
8505 32 7c ee			ld (debug_mark+2),a  
8508 18 03			jr .pastdmark  
850a ..			.dmark: db "SRE"  
850d f1			.pastdmark: pop af  
850e			endm  
# End of macro DMARK
850e					CALLMONITOR 
850e cd 7f 90			call break_point_state  
8511				endm  
# End of macro CALLMONITOR
8511				endif 
8511 cd 1f 83			call storage_findnextid 
8514			 
8514				if DEBUG_STORESE 
8514					DMARK "SRf" 
8514 f5				push af  
8515 3a 29 85			ld a, (.dmark)  
8518 32 7a ee			ld (debug_mark),a  
851b 3a 2a 85			ld a, (.dmark+1)  
851e 32 7b ee			ld (debug_mark+1),a  
8521 3a 2b 85			ld a, (.dmark+2)  
8524 32 7c ee			ld (debug_mark+2),a  
8527 18 03			jr .pastdmark  
8529 ..			.dmark: db "SRf"  
852c f1			.pastdmark: pop af  
852d			endm  
# End of macro DMARK
852d					CALLMONITOR 
852d cd 7f 90			call break_point_state  
8530				endm  
# End of macro CALLMONITOR
8530				endif 
8530 cd e4 88			call ishlzero 
8533			;	ld a, l 
8533			;	add h 
8533			;	cp 0 
8533 c8				ret z			; block not found so EOF 
8534			 
8534				; hl contains page number to load 
8534 d1				pop de   ; get storage 
8535 d5				push de 
8536				if DEBUG_STORESE 
8536					DMARK "SRg" 
8536 f5				push af  
8537 3a 4b 85			ld a, (.dmark)  
853a 32 7a ee			ld (debug_mark),a  
853d 3a 4c 85			ld a, (.dmark+1)  
8540 32 7b ee			ld (debug_mark+1),a  
8543 3a 4d 85			ld a, (.dmark+2)  
8546 32 7c ee			ld (debug_mark+2),a  
8549 18 03			jr .pastdmark  
854b ..			.dmark: db "SRg"  
854e f1			.pastdmark: pop af  
854f			endm  
# End of macro DMARK
854f					CALLMONITOR 
854f cd 7f 90			call break_point_state  
8552				endm  
# End of macro CALLMONITOR
8552				endif 
8552 cd b1 80			call storage_read_block 
8555			 
8555			 
8555			; TODO if block has no zeros then need to read next block  
8555			 
8555			 
8555					 
8555 e1				pop hl 		 ; return start of data to show as not EOF 
8556 23				inc hl   ; past file id 
8557 23				inc hl   ; past ext 
8558				if DEBUG_STORESE 
8558					DMARK "SRe" 
8558 f5				push af  
8559 3a 6d 85			ld a, (.dmark)  
855c 32 7a ee			ld (debug_mark),a  
855f 3a 6e 85			ld a, (.dmark+1)  
8562 32 7b ee			ld (debug_mark+1),a  
8565 3a 6f 85			ld a, (.dmark+2)  
8568 32 7c ee			ld (debug_mark+2),a  
856b 18 03			jr .pastdmark  
856d ..			.dmark: db "SRe"  
8570 f1			.pastdmark: pop af  
8571			endm  
# End of macro DMARK
8571					CALLMONITOR 
8571 cd 7f 90			call break_point_state  
8574				endm  
# End of macro CALLMONITOR
8574				endif 
8574 c9					ret 
8575			 
8575			 
8575			 
8575			; 
8575			; Append File 
8575			; 
8575			; hl - file id to locate 
8575			; de - pointer to (multi block) string to write 
8575			 
8575			 
8575			storage_append: 
8575				; hl -  file id to append to 
8575				; de - string to append 
8575			 
8575 d5				push de 
8576				 
8576				if DEBUG_STORESE 
8576					DMARK "AP1" 
8576 f5				push af  
8577 3a 8b 85			ld a, (.dmark)  
857a 32 7a ee			ld (debug_mark),a  
857d 3a 8c 85			ld a, (.dmark+1)  
8580 32 7b ee			ld (debug_mark+1),a  
8583 3a 8d 85			ld a, (.dmark+2)  
8586 32 7c ee			ld (debug_mark+2),a  
8589 18 03			jr .pastdmark  
858b ..			.dmark: db "AP1"  
858e f1			.pastdmark: pop af  
858f			endm  
# End of macro DMARK
858f					CALLMONITOR 
858f cd 7f 90			call break_point_state  
8592				endm  
# End of macro CALLMONITOR
8592				endif 
8592			 
8592 7d				ld a, l 
8593 32 5e eb			ld (store_tmpid), a 
8596			 
8596				; get file header  
8596			 
8596 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
8598 3a 5e eb			ld a, (store_tmpid) 
859b 5f				ld e, a 
859c			 
859c 21 40 00				ld hl, STORE_BLOCK_PHY 
859f cd 1f 83				call storage_findnextid 
85a2			 
85a2 22 63 eb			ld (store_tmppageid), hl 
85a5			 
85a5				; TODO handle file id not found 
85a5			 
85a5				if DEBUG_STORESE 
85a5					DMARK "AP2" 
85a5 f5				push af  
85a6 3a ba 85			ld a, (.dmark)  
85a9 32 7a ee			ld (debug_mark),a  
85ac 3a bb 85			ld a, (.dmark+1)  
85af 32 7b ee			ld (debug_mark+1),a  
85b2 3a bc 85			ld a, (.dmark+2)  
85b5 32 7c ee			ld (debug_mark+2),a  
85b8 18 03			jr .pastdmark  
85ba ..			.dmark: db "AP2"  
85bd f1			.pastdmark: pop af  
85be			endm  
# End of macro DMARK
85be					CALLMONITOR 
85be cd 7f 90			call break_point_state  
85c1				endm  
# End of macro CALLMONITOR
85c1				endif 
85c1			 
85c1				; update file extent count 
85c1			 
85c1 11 65 eb			ld de, store_page 
85c4			 
85c4 cd b1 80			call storage_read_block 
85c7			 
85c7				if DEBUG_STORESE 
85c7					DMARK "AP3" 
85c7 f5				push af  
85c8 3a dc 85			ld a, (.dmark)  
85cb 32 7a ee			ld (debug_mark),a  
85ce 3a dd 85			ld a, (.dmark+1)  
85d1 32 7b ee			ld (debug_mark+1),a  
85d4 3a de 85			ld a, (.dmark+2)  
85d7 32 7c ee			ld (debug_mark+2),a  
85da 18 03			jr .pastdmark  
85dc ..			.dmark: db "AP3"  
85df f1			.pastdmark: pop af  
85e0			endm  
# End of macro DMARK
85e0					CALLMONITOR 
85e0 cd 7f 90			call break_point_state  
85e3				endm  
# End of macro CALLMONITOR
85e3				endif 
85e3			;	ld (store_tmppageid), hl 
85e3			 
85e3 3a 67 eb			ld a, (store_page+2) 
85e6 3c				inc a 
85e7 32 67 eb			ld (store_page+2), a 
85ea 32 5d eb			ld (store_tmpext), a 
85ed				 
85ed				if DEBUG_STORESE 
85ed					DMARK "AP3" 
85ed f5				push af  
85ee 3a 02 86			ld a, (.dmark)  
85f1 32 7a ee			ld (debug_mark),a  
85f4 3a 03 86			ld a, (.dmark+1)  
85f7 32 7b ee			ld (debug_mark+1),a  
85fa 3a 04 86			ld a, (.dmark+2)  
85fd 32 7c ee			ld (debug_mark+2),a  
8600 18 03			jr .pastdmark  
8602 ..			.dmark: db "AP3"  
8605 f1			.pastdmark: pop af  
8606			endm  
# End of macro DMARK
8606					CALLMONITOR 
8606 cd 7f 90			call break_point_state  
8609				endm  
# End of macro CALLMONITOR
8609				endif 
8609 2a 63 eb			ld hl, (store_tmppageid) 
860c 11 65 eb			ld de, store_page 
860f cd fa 80			call storage_write_block 
8612			 
8612				; find free block 
8612			 
8612 11 00 00			ld de, 0			 ; file extent to locate 
8615			 
8615 21 40 00				ld hl, STORE_BLOCK_PHY 
8618 cd 1f 83				call storage_findnextid 
861b			 
861b					; TODO handle no space left 
861b					 
861b 22 63 eb				ld (store_tmppageid), hl 
861e			 
861e				if DEBUG_STORESE 
861e					DMARK "AP4" 
861e f5				push af  
861f 3a 33 86			ld a, (.dmark)  
8622 32 7a ee			ld (debug_mark),a  
8625 3a 34 86			ld a, (.dmark+1)  
8628 32 7b ee			ld (debug_mark+1),a  
862b 3a 35 86			ld a, (.dmark+2)  
862e 32 7c ee			ld (debug_mark+2),a  
8631 18 03			jr .pastdmark  
8633 ..			.dmark: db "AP4"  
8636 f1			.pastdmark: pop af  
8637			endm  
# End of macro DMARK
8637					CALLMONITOR 
8637 cd 7f 90			call break_point_state  
863a				endm  
# End of macro CALLMONITOR
863a				endif 
863a					; init the buffer with zeros so we can id if the buffer is full or not 
863a			 
863a e5					push hl 
863b c5					push bc 
863c			 
863c 21 65 eb				ld hl, store_page 
863f 06 40				ld b, STORE_BLOCK_PHY 
8641 3e 00				ld a, 0 
8643 77			.zeroblock:	ld (hl), a 
8644 23					inc hl 
8645 10 fc				djnz .zeroblock 
8647			 
8647 c1					pop bc 
8648 e1					pop hl 
8649			 
8649					; construct block 
8649			 
8649 3a 5e eb				ld a, (store_tmpid) 
864c 32 65 eb				ld (store_page), a   ; file id 
864f 3a 5d eb				ld a, (store_tmpext)   ; extent for this block 
8652 32 66 eb				ld (store_page+1), a 
8655			 
8655 e1					pop hl    ; get string to write 
8656 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8658 11 67 eb				ld de, store_page+2 
865b			 
865b				if DEBUG_STORESE 
865b					DMARK "AP5" 
865b f5				push af  
865c 3a 70 86			ld a, (.dmark)  
865f 32 7a ee			ld (debug_mark),a  
8662 3a 71 86			ld a, (.dmark+1)  
8665 32 7b ee			ld (debug_mark+1),a  
8668 3a 72 86			ld a, (.dmark+2)  
866b 32 7c ee			ld (debug_mark+2),a  
866e 18 03			jr .pastdmark  
8670 ..			.dmark: db "AP5"  
8673 f1			.pastdmark: pop af  
8674			endm  
# End of macro DMARK
8674					CALLMONITOR 
8674 cd 7f 90			call break_point_state  
8677				endm  
# End of macro CALLMONITOR
8677				endif 
8677			 
8677			 
8677			 
8677					; fill buffer with data until end of string or full block 
8677			 
8677 7e			.appd:		ld a, (hl) 
8678 12					ld (de), a 
8679 fe 00				cp 0 
867b 28 04				jr z, .appdone 
867d 23					inc hl 
867e 13					inc de 
867f 10 f6				djnz .appd 
8681			 
8681 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8682 f5					push af   		; save last byte dumped 
8683			 
8683			 
8683 2a 63 eb			ld hl, (store_tmppageid) 
8686 11 65 eb			ld de, store_page 
8689				if DEBUG_STORESE 
8689					DMARK "AP6" 
8689 f5				push af  
868a 3a 9e 86			ld a, (.dmark)  
868d 32 7a ee			ld (debug_mark),a  
8690 3a 9f 86			ld a, (.dmark+1)  
8693 32 7b ee			ld (debug_mark+1),a  
8696 3a a0 86			ld a, (.dmark+2)  
8699 32 7c ee			ld (debug_mark+2),a  
869c 18 03			jr .pastdmark  
869e ..			.dmark: db "AP6"  
86a1 f1			.pastdmark: pop af  
86a2			endm  
# End of macro DMARK
86a2					CALLMONITOR 
86a2 cd 7f 90			call break_point_state  
86a5				endm  
# End of macro CALLMONITOR
86a5				endif 
86a5 cd fa 80				call storage_write_block 
86a8			 
86a8			 
86a8				; was that a full block of data written? 
86a8				; any more to write out? 
86a8			 
86a8				; if yes then set vars and jump to start of function again 
86a8			 
86a8 f1					pop af 
86a9 d1					pop de 
86aa			 
86aa fe 00				cp 0		 ; no, string was fully written 
86ac c8					ret z 
86ad			 
86ad					; setup vars for next cycle 
86ad			 
86ad 3a 5e eb				ld a, (store_tmpid) 
86b0 6f					ld l, a 
86b1 26 00				ld h, 0 
86b3			 
86b3 c3 75 85			 	jp storage_append	 ; yes, need to write out some more 
86b6			 
86b6			 
86b6			 
86b6			 
86b6			 
86b6			 
86b6			 
86b6			if DEBUG_STORECF 
86b6			storageput:	 
86b6					ret 
86b6			storageread: 
86b6					ld hl, store_page 
86b6					ld b, 200 
86b6					ld a,0 
86b6			.src:		ld (hl),a 
86b6					inc hl 
86b6					djnz .src 
86b6					 
86b6			 
86b6					ld de, 0 
86b6					ld bc, 1 
86b6					ld hl, store_page 
86b6					call cfRead 
86b6			 
86b6				call cfGetError 
86b6				ld hl,scratch 
86b6				call hexout 
86b6				ld hl, scratch+2 
86b6				ld a, 0 
86b6				ld (hl),a 
86b6				ld de, scratch 
86b6				ld a,display_row_1 
86b6				call str_at_display 
86b6				call update_display 
86b6			 
86b6					ld hl, store_page 
86b6					ld (os_cur_ptr),hl 
86b6			 
86b6					ret 
86b6			endif 
86b6			 
86b6			 
86b6			; Clear out the main buffer store (used to remove junk before writing a new block) 
86b6			 
86b6			storage_clear_page: 
86b6 e5				push hl 
86b7 d5				push de 
86b8 c5				push bc 
86b9 21 65 eb			ld hl, store_page 
86bc 3e 00			ld a, 0 
86be 77				ld (hl), a 
86bf			 
86bf 11 66 eb			ld de, store_page+1 
86c2 01 40 00			ld bc, STORE_BLOCK_PHY 
86c5			 
86c5 ed b0			ldir 
86c7				 
86c7 c1				pop bc 
86c8 d1				pop de 
86c9 e1				pop hl 
86ca c9				ret 
86cb			 
86cb			; eof 
# End of file firmware_storage.asm
86cb			  
86cb			; support routines for above hardware abstraction layer  
86cb			  
86cb			include "firmware_general.asm"        ; general support functions  
86cb			 
86cb			 
86cb			 
86cb			; Delay loops 
86cb			 
86cb			 
86cb			 
86cb			aDelayInMS: 
86cb c5				push bc 
86cc 47				ld b,a 
86cd			msdelay: 
86cd c5				push bc 
86ce				 
86ce			 
86ce 01 41 00			ld bc,041h 
86d1 cd e9 86			call delayloop 
86d4 c1				pop bc 
86d5 05				dec b 
86d6 20 f5			jr nz,msdelay 
86d8			 
86d8			;if CPU_CLOCK_8MHZ 
86d8			;msdelay8: 
86d8			;	push bc 
86d8			;	 
86d8			; 
86d8			;	ld bc,041h 
86d8			;	call delayloop 
86d8			;	pop bc 
86d8			;	dec b 
86d8			;	jr nz,msdelay8 
86d8			;endif 
86d8			 
86d8			 
86d8 c1				pop bc 
86d9 c9				ret 
86da			 
86da			 
86da			delay250ms: 
86da				;push de 
86da 01 00 40			ld bc, 04000h 
86dd c3 e9 86			jp delayloop 
86e0			delay500ms: 
86e0				;push de 
86e0 01 00 80			ld bc, 08000h 
86e3 c3 e9 86			jp delayloop 
86e6			delay1s: 
86e6				;push bc 
86e6			   ; Clobbers A, d and e 
86e6 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
86e9			delayloop: 
86e9 c5			    push bc 
86ea			 
86ea			if BASE_CPM 
86ea				ld bc, CPM_DELAY_TUNE 
86ea			.cpmloop: 
86ea				push bc 
86ea			 
86ea			endif 
86ea			 
86ea			 
86ea			 
86ea			delayloopi: 
86ea			;	push bc 
86ea			;.dl: 
86ea cb 47		    bit     0,a    	; 8 
86ec cb 47		    bit     0,a    	; 8 
86ee cb 47		    bit     0,a    	; 8 
86f0 e6 ff		    and     255  	; 7 
86f2 0b			    dec     bc      	; 6 
86f3 79			    ld      a,c     	; 4 
86f4 b0			    or      b     	; 4 
86f5 c2 ea 86		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
86f8			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
86f8				;pop de 
86f8			;pop bc 
86f8			 
86f8			if BASE_CPM 
86f8				pop bc 
86f8				 
86f8			    dec     bc      	; 6 
86f8			    ld      a,c     	; 4 
86f8			    or      b     	; 4 
86f8			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
86f8				 
86f8			 
86f8			endif 
86f8			;if CPU_CLOCK_8MHZ 
86f8			;    pop bc 
86f8			;    push bc 
86f8			;.dl8: 
86f8			;    bit     0,a    	; 8 
86f8			;    bit     0,a    	; 8 
86f8			;    bit     0,a    	; 8 
86f8			;    and     255  	; 7 
86f8			;    dec     bc      	; 6 
86f8			;    ld      a,c     	; 4 
86f8			;    or      b     	; 4 
86f8			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
86f8			;endif 
86f8			 
86f8			;if CPU_CLOCK_10MHZ 
86f8			;    pop bc 
86f8			;    push bc 
86f8			;.dl8: 
86f8			;    bit     0,a    	; 8 
86f8			;    bit     0,a    	; 8 
86f8			;    bit     0,a    	; 8 
86f8			;    and     255  	; 7 
86f8			;    dec     bc      	; 6 
86f8			;    ld      a,c     	; 4 
86f8			;    or      b     	; 4 
86f8			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
86f8			;endif 
86f8 c1			    pop bc 
86f9			 
86f9 c9				ret 
86fa			 
86fa			 
86fa			 
86fa			; eof 
# End of file firmware_general.asm
86fa			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
86fa			; display routines that use the physical hardware abstraction layer 
86fa			 
86fa			 
86fa			; TODO windowing? 
86fa			 
86fa			; TODO scroll line up 
86fa			 
86fa			scroll_up: 
86fa			 
86fa e5				push hl 
86fb d5				push de 
86fc c5				push bc 
86fd			 
86fd				; get frame buffer  
86fd			 
86fd 2a db eb			ld hl, (display_fb_active) 
8700 e5				push hl    ; future de destination 
8701			 
8701 11 28 00			ld  de, display_cols 
8704 19				add hl, de 
8705			 
8705 d1				pop de 
8706			 
8706				;ex de, hl 
8706 01 9f 00			ld bc, display_fb_len -1  
8709			;if DEBUG_FORTH_WORDS 
8709			;	DMARK "SCL" 
8709			;	CALLMONITOR 
8709			;endif	 
8709 ed b0			ldir 
870b			 
870b				; wipe bottom row 
870b			 
870b			 
870b 2a db eb			ld hl, (display_fb_active) 
870e 11 a0 00			ld de, display_cols*display_rows 
8711 19				add hl, de 
8712 06 28			ld b, display_cols 
8714 3e 20			ld a, ' ' 
8716			.scwipe: 
8716 77				ld (hl), a 
8717 2b				dec hl 
8718 10 fc			djnz .scwipe 
871a			 
871a				;pop hl 
871a			 
871a c1				pop bc 
871b d1				pop de 
871c e1				pop hl 
871d			 
871d c9				ret 
871e			 
871e			 
871e			scroll_upo: 
871e 11 00 00			ld de, display_row_1 
8721 21 28 00		 	ld hl, display_row_2 
8724 01 28 00			ld bc, display_cols 
8727 ed b0			ldir 
8729 11 28 00			ld de, display_row_2 
872c 21 50 00		 	ld hl, display_row_3 
872f 01 28 00			ld bc, display_cols 
8732 ed b0			ldir 
8734 11 50 00			ld de, display_row_3 
8737 21 78 00		 	ld hl, display_row_4 
873a 01 28 00			ld bc, display_cols 
873d ed b0			ldir 
873f			 
873f			; TODO clear row 4 
873f			 
873f c9				ret 
8740				 
8740			scroll_down: 
8740 11 78 00			ld de, display_row_4 
8743 21 50 00		 	ld hl, display_row_3 
8746 01 28 00			ld bc, display_cols 
8749 ed b0			ldir 
874b 11 50 00			ld de, display_row_3 
874e 21 28 00		 	ld hl, display_row_2 
8751 01 28 00			ld bc, display_cols 
8754 ed b0			ldir 
8756 11 28 00			ld de, display_row_2 
8759 21 00 00		 	ld hl, display_row_1 
875c 01 28 00			ld bc, display_cols 
875f ed b0			ldir 
8761			; TODO clear row 1 
8761 c9				ret 
8762			 
8762			 
8762			 
8762			 
8762			 
8762			; clear active frame buffer 
8762			 
8762			clear_display: 
8762 3e 20			ld a, ' ' 
8764 c3 67 87			jp fill_display 
8767			 
8767			; fill active frame buffer with a char in A 
8767			 
8767			fill_display: 
8767 06 a0			ld b,display_fb_len 
8769 2a db eb			ld hl, (display_fb_active) 
876c 77			.fd1:	ld (hl),a 
876d 23				inc hl 
876e 10 fc			djnz .fd1 
8770 23				inc hl 
8771 3e 00			ld a,0 
8773 77				ld (hl),a 
8774			 
8774			 
8774 c9				ret 
8775			; Write string (DE) at pos (A) to active frame buffer 
8775			 
8775 2a db eb		str_at_display:    ld hl,(display_fb_active) 
8778 06 00					ld b,0 
877a 4f					ld c,a 
877b 09					add hl,bc 
877c 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
877d b7			            OR   A              ;Null terminator? 
877e c8			            RET  Z              ;Yes, so finished 
877f 77					ld (hl),a 
8780 23				inc hl 
8781 13			            INC  DE             ;Point to next character 
8782 18 f8		            JR   .sad1     ;Repeat 
8784 c9					ret 
8785			 
8785			; using current frame buffer write to physical display 
8785			 
8785			update_display: 
8785 e5				push hl 
8786 2a db eb			ld hl, (display_fb_active) 
8789 cd 13 c6			call write_display 
878c e1				pop hl 
878d c9				ret 
878e			 
878e			; TODO scrolling 
878e			 
878e			 
878e			; move cursor right one char 
878e			cursor_right: 
878e			 
878e				; TODO shift right 
878e				; TODO if beyond max col 
878e				; TODO       cursor_next_line 
878e			 
878e c9				ret 
878f			 
878f			 
878f			cursor_next_line: 
878f				; TODO first char 
878f				; TODO line down 
878f				; TODO if past last row 
878f				; TODO    scroll up 
878f			 
878f c9				ret 
8790			 
8790			cursor_left: 
8790				; TODO shift left 
8790				; TODO if beyond left  
8790				; TODO     cursor prev line 
8790				 
8790 c9				ret 
8791			 
8791			cursor_prev_line: 
8791				; TODO last char 
8791				; TODO line up 
8791				; TODO if past first row 
8791				; TODO   scroll down 
8791			 
8791 c9				ret 
8792			 
8792			 
8792			cout: 
8792				; A - char 
8792 c9				ret 
8793			 
8793			; eof 
8793			 
# End of file firmware_display.asm
8793			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8793			; random number generators 
8793			 
8793			 
8793			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8793			 
8793			 
8793			;-----> Generate a random number 
8793			; output a=answer 0<=a<=255 
8793			; all registers are preserved except: af 
8793			random: 
8793 e5			        push    hl 
8794 d5			        push    de 
8795 2a bd eb		        ld      hl,(randData) 
8798 ed 5f		        ld      a,r 
879a 57			        ld      d,a 
879b 5e			        ld      e,(hl) 
879c 19			        add     hl,de 
879d 85			        add     a,l 
879e ac			        xor     h 
879f 22 bd eb		        ld      (randData),hl 
87a2 d1			        pop     de 
87a3 e1			        pop     hl 
87a4 c9			        ret 
87a5			 
87a5			 
87a5			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
87a5			 
87a5			 
87a5			 
87a5			;------LFSR------ 
87a5			;James Montelongo 
87a5			;optimized by Spencer Putt 
87a5			;out: 
87a5			; a = 8 bit random number 
87a5			RandLFSR: 
87a5 21 c3 eb		        ld hl,LFSRSeed+4 
87a8 5e			        ld e,(hl) 
87a9 23			        inc hl 
87aa 56			        ld d,(hl) 
87ab 23			        inc hl 
87ac 4e			        ld c,(hl) 
87ad 23			        inc hl 
87ae 7e			        ld a,(hl) 
87af 47			        ld b,a 
87b0 cb 13		        rl e  
87b2 cb 12			rl d 
87b4 cb 11		        rl c  
87b6 17				rla 
87b7 cb 13		        rl e  
87b9 cb 12			rl d 
87bb cb 11		        rl c  
87bd 17				rla 
87be cb 13		        rl e  
87c0 cb 12			rl d 
87c2 cb 11		        rl c  
87c4 17				rla 
87c5 67			        ld h,a 
87c6 cb 13		        rl e  
87c8 cb 12			rl d 
87ca cb 11		        rl c  
87cc 17				rla 
87cd a8			        xor b 
87ce cb 13		        rl e  
87d0 cb 12			rl d 
87d2 ac			        xor h 
87d3 a9			        xor c 
87d4 aa			        xor d 
87d5 21 c5 eb		        ld hl,LFSRSeed+6 
87d8 11 c6 eb		        ld de,LFSRSeed+7 
87db 01 07 00		        ld bc,7 
87de ed b8		        lddr 
87e0 12			        ld (de),a 
87e1 c9			        ret 
87e2			 
87e2			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
87e2			 
87e2			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
87e2			 
87e2			 
87e2			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
87e2			 
87e2			prng16: 
87e2			;Inputs: 
87e2			;   (seed1) contains a 16-bit seed value 
87e2			;   (seed2) contains a NON-ZERO 16-bit seed value 
87e2			;Outputs: 
87e2			;   HL is the result 
87e2			;   BC is the result of the LCG, so not that great of quality 
87e2			;   DE is preserved 
87e2			;Destroys: 
87e2			;   AF 
87e2			;cycle: 4,294,901,760 (almost 4.3 billion) 
87e2			;160cc 
87e2			;26 bytes 
87e2 2a b7 eb		    ld hl,(seed1) 
87e5 44			    ld b,h 
87e6 4d			    ld c,l 
87e7 29			    add hl,hl 
87e8 29			    add hl,hl 
87e9 2c			    inc l 
87ea 09			    add hl,bc 
87eb 22 b7 eb		    ld (seed1),hl 
87ee 2a b5 eb		    ld hl,(seed2) 
87f1 29			    add hl,hl 
87f2 9f			    sbc a,a 
87f3 e6 2d		    and %00101101 
87f5 ad			    xor l 
87f6 6f			    ld l,a 
87f7 22 b5 eb		    ld (seed2),hl 
87fa 09			    add hl,bc 
87fb c9			    ret 
87fc			 
87fc			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
87fc			 
87fc			rand32: 
87fc			;Inputs: 
87fc			;   (seed1_0) holds the lower 16 bits of the first seed 
87fc			;   (seed1_1) holds the upper 16 bits of the first seed 
87fc			;   (seed2_0) holds the lower 16 bits of the second seed 
87fc			;   (seed2_1) holds the upper 16 bits of the second seed 
87fc			;   **NOTE: seed2 must be non-zero 
87fc			;Outputs: 
87fc			;   HL is the result 
87fc			;   BC,DE can be used as lower quality values, but are not independent of HL. 
87fc			;Destroys: 
87fc			;   AF 
87fc			;Tested and passes all CAcert tests 
87fc			;Uses a very simple 32-bit LCG and 32-bit LFSR 
87fc			;it has a period of 18,446,744,069,414,584,320 
87fc			;roughly 18.4 quintillion. 
87fc			;LFSR taps: 0,2,6,7  = 11000101 
87fc			;291cc 
87fc			;seed1_0=$+1 
87fc			;    ld hl,12345 
87fc			;seed1_1=$+1 
87fc			;    ld de,6789 
87fc			;    ld b,h 
87fc			;    ld c,l 
87fc			;    add hl,hl \ rl e \ rl d 
87fc			;    add hl,hl \ rl e \ rl d 
87fc			;    inc l 
87fc			;    add hl,bc 
87fc			;    ld (seed1_0),hl 
87fc			;    ld hl,(seed1_1) 
87fc			;    adc hl,de 
87fc			;    ld (seed1_1),hl 
87fc			;    ex de,hl 
87fc			;seed2_0=$+1 
87fc			;    ld hl,9876 
87fc			;seed2_1=$+1 
87fc			;    ld bc,54321 
87fc			;    add hl,hl \ rl c \ rl b 
87fc			;    ld (seed2_1),bc 
87fc			;    sbc a,a 
87fc			;    and %11000101 
87fc			;    xor l 
87fc			;    ld l,a 
87fc			;    ld (seed2_0),hl 
87fc			;    ex de,hl 
87fc			;    add hl,bc 
87fc			;    ret 
87fc			; 
87fc			 
87fc			; 16-bit xorshift pseudorandom number generator by John Metcalf 
87fc			; 20 bytes, 86 cycles (excluding ret) 
87fc			 
87fc			; returns   hl = pseudorandom number 
87fc			; corrupts   a 
87fc			 
87fc			; generates 16-bit pseudorandom numbers with a period of 65535 
87fc			; using the xorshift method: 
87fc			 
87fc			; hl ^= hl << 7 
87fc			; hl ^= hl >> 9 
87fc			; hl ^= hl << 8 
87fc			 
87fc			; some alternative shift triplets which also perform well are: 
87fc			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
87fc			 
87fc			;  org 32768 
87fc			 
87fc			xrnd: 
87fc 2a bb eb		  ld hl,(xrandc)       ; seed must not be 0 
87ff 3e 00		  ld a,0 
8801 bd			  cp l 
8802 20 02		  jr nz, .xrnd1 
8804 2e 01		  ld l, 1 
8806			.xrnd1: 
8806			 
8806 7c			  ld a,h 
8807 1f			  rra 
8808 7d			  ld a,l 
8809 1f			  rra 
880a ac			  xor h 
880b 67			  ld h,a 
880c 7d			  ld a,l 
880d 1f			  rra 
880e 7c			  ld a,h 
880f 1f			  rra 
8810 ad			  xor l 
8811 6f			  ld l,a 
8812 ac			  xor h 
8813 67			  ld h,a 
8814			 
8814 22 bb eb		  ld (xrandc),hl 
8817			 
8817 c9			  ret 
8818			;  
8818			 
8818			 
8818			;;;; int maths 
8818			 
8818			; https://map.grauw.nl/articles/mult_div_shifts.php 
8818			; Divide 16-bit values (with 16-bit result) 
8818			; In: Divide BC by divider DE 
8818			; Out: BC = result, HL = rest 
8818			; 
8818			Div16: 
8818 21 00 00		    ld hl,0 
881b 78			    ld a,b 
881c 06 08		    ld b,8 
881e			Div16_Loop1: 
881e 17			    rla 
881f ed 6a		    adc hl,hl 
8821 ed 52		    sbc hl,de 
8823 30 01		    jr nc,Div16_NoAdd1 
8825 19			    add hl,de 
8826			Div16_NoAdd1: 
8826 10 f6		    djnz Div16_Loop1 
8828 17			    rla 
8829 2f			    cpl 
882a 47			    ld b,a 
882b 79			    ld a,c 
882c 48			    ld c,b 
882d 06 08		    ld b,8 
882f			Div16_Loop2: 
882f 17			    rla 
8830 ed 6a		    adc hl,hl 
8832 ed 52		    sbc hl,de 
8834 30 01		    jr nc,Div16_NoAdd2 
8836 19			    add hl,de 
8837			Div16_NoAdd2: 
8837 10 f6		    djnz Div16_Loop2 
8839 17			    rla 
883a 2f			    cpl 
883b 41			    ld b,c 
883c 4f			    ld c,a 
883d c9			ret 
883e			 
883e			 
883e			;http://z80-heaven.wikidot.com/math 
883e			; 
883e			;Inputs: 
883e			;     DE and A are factors 
883e			;Outputs: 
883e			;     A is not changed 
883e			;     B is 0 
883e			;     C is not changed 
883e			;     DE is not changed 
883e			;     HL is the product 
883e			;Time: 
883e			;     342+6x 
883e			; 
883e			Mult16: 
883e			 
883e 06 08		     ld b,8          ;7           7 
8840 21 00 00		     ld hl,0         ;10         10 
8843 29			       add hl,hl     ;11*8       88 
8844 07			       rlca          ;4*8        32 
8845 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8847 19			         add hl,de   ;--         -- 
8848 10 f9		       djnz $-5      ;13*7+8     99 
884a c9			ret 
884b			 
884b			; 
884b			; Square root of 16-bit value 
884b			; In:  HL = value 
884b			; Out:  D = result (rounded down) 
884b			; 
884b			;Sqr16: 
884b			;    ld de,#0040 
884b			;    ld a,l 
884b			;    ld l,h 
884b			;    ld h,d 
884b			;    or a 
884b			;    ld b,8 
884b			;Sqr16_Loop: 
884b			;    sbc hl,de 
884b			;    jr nc,Sqr16_Skip 
884b			;    add hl,de 
884b			;Sqr16_Skip: 
884b			;    ccf 
884b			;    rl d 
884b			;    add a,a 
884b			;    adc hl,hl 
884b			;    add a,a 
884b			;    adc hl,hl 
884b			;    djnz Sqr16_Loop 
884b			;    ret 
884b			; 
884b			; 
884b			; Divide 8-bit values 
884b			; In: Divide E by divider C 
884b			; Out: A = result, B = rest 
884b			; 
884b			Div8: 
884b af			    xor a 
884c 06 08		    ld b,8 
884e			Div8_Loop: 
884e cb 13		    rl e 
8850 17			    rla 
8851 91			    sub c 
8852 30 01		    jr nc,Div8_NoAdd 
8854 81			    add a,c 
8855			Div8_NoAdd: 
8855 10 f7		    djnz Div8_Loop 
8857 47			    ld b,a 
8858 7b			    ld a,e 
8859 17			    rla 
885a 2f			    cpl 
885b c9			    ret 
885c			 
885c			; 
885c			; Multiply 8-bit value with a 16-bit value (unrolled) 
885c			; In: Multiply A with DE 
885c			; Out: HL = result 
885c			; 
885c			Mult12U: 
885c 2e 00		    ld l,0 
885e 87			    add a,a 
885f 30 01		    jr nc,Mult12U_NoAdd0 
8861 19			    add hl,de 
8862			Mult12U_NoAdd0: 
8862 29			    add hl,hl 
8863 87			    add a,a 
8864 30 01		    jr nc,Mult12U_NoAdd1 
8866 19			    add hl,de 
8867			Mult12U_NoAdd1: 
8867 29			    add hl,hl 
8868 87			    add a,a 
8869 30 01		    jr nc,Mult12U_NoAdd2 
886b 19			    add hl,de 
886c			Mult12U_NoAdd2: 
886c 29			    add hl,hl 
886d 87			    add a,a 
886e 30 01		    jr nc,Mult12U_NoAdd3 
8870 19			    add hl,de 
8871			Mult12U_NoAdd3: 
8871 29			    add hl,hl 
8872 87			    add a,a 
8873 30 01		    jr nc,Mult12U_NoAdd4 
8875 19			    add hl,de 
8876			Mult12U_NoAdd4: 
8876 29			    add hl,hl 
8877 87			    add a,a 
8878 30 01		    jr nc,Mult12U_NoAdd5 
887a 19			    add hl,de 
887b			Mult12U_NoAdd5: 
887b 29			    add hl,hl 
887c 87			    add a,a 
887d 30 01		    jr nc,Mult12U_NoAdd6 
887f 19			    add hl,de 
8880			Mult12U_NoAdd6: 
8880 29			    add hl,hl 
8881 87			    add a,a 
8882 d0			    ret nc 
8883 19			    add hl,de 
8884 c9			    ret 
8885			 
8885			; 
8885			; Multiply 8-bit value with a 16-bit value (right rotating) 
8885			; In: Multiply A with DE 
8885			;      Put lowest value in A for most efficient calculation 
8885			; Out: HL = result 
8885			; 
8885			Mult12R: 
8885 21 00 00		    ld hl,0 
8888			Mult12R_Loop: 
8888 cb 3f		    srl a 
888a 30 01		    jr nc,Mult12R_NoAdd 
888c 19			    add hl,de 
888d			Mult12R_NoAdd: 
888d cb 23		    sla e 
888f cb 12		    rl d 
8891 b7			    or a 
8892 c2 88 88		    jp nz,Mult12R_Loop 
8895 c9			    ret 
8896			 
8896			; 
8896			; Multiply 16-bit values (with 32-bit result) 
8896			; In: Multiply BC with DE 
8896			; Out: BCHL = result 
8896			; 
8896			Mult32: 
8896 79			    ld a,c 
8897 48			    ld c,b 
8898 21 00 00		    ld hl,0 
889b 06 10		    ld b,16 
889d			Mult32_Loop: 
889d 29			    add hl,hl 
889e 17			    rla 
889f cb 11		    rl c 
88a1 30 07		    jr nc,Mult32_NoAdd 
88a3 19			    add hl,de 
88a4 ce 00		    adc a,0 
88a6 d2 aa 88		    jp nc,Mult32_NoAdd 
88a9 0c			    inc c 
88aa			Mult32_NoAdd: 
88aa 10 f1		    djnz Mult32_Loop 
88ac 41			    ld b,c 
88ad 4f			    ld c,a 
88ae c9			    ret 
88af			 
88af			 
88af			 
88af			; 
88af			; Multiply 8-bit values 
88af			; In:  Multiply H with E 
88af			; Out: HL = result 
88af			; 
88af			Mult8: 
88af 16 00		    ld d,0 
88b1 6a			    ld l,d 
88b2 06 08		    ld b,8 
88b4			Mult8_Loop: 
88b4 29			    add hl,hl 
88b5 30 01		    jr nc,Mult8_NoAdd 
88b7 19			    add hl,de 
88b8			Mult8_NoAdd: 
88b8 10 fa		    djnz Mult8_Loop 
88ba c9			    ret 
88bb			 
88bb			 
88bb			 
88bb			 
88bb			 
88bb			 
88bb			 
88bb			 
88bb			;;http://z80-heaven.wikidot.com/math 
88bb			;;This divides DE by BC, storing the result in DE, remainder in HL 
88bb			; 
88bb			;DE_Div_BC:          ;1281-2x, x is at most 16 
88bb			;     ld a,16        ;7 
88bb			;     ld hl,0        ;10 
88bb			;     jp $+5         ;10 
88bb			;.DivLoop: 
88bb			;       add hl,bc    ;-- 
88bb			;       dec a        ;64 
88bb			;       jr z,.DivLoopEnd        ;86 
88bb			; 
88bb			;       sla e        ;128 
88bb			;       rl d         ;128 
88bb			;       adc hl,hl    ;240 
88bb			;       sbc hl,bc    ;240 
88bb			;       jr nc,.DivLoop ;23|21 
88bb			;       inc e        ;-- 
88bb			;       jp .DivLoop+1 
88bb			; 
88bb			;.DivLoopEnd: 
88bb			 
88bb			;HL_Div_C: 
88bb			;Inputs: 
88bb			;     HL is the numerator 
88bb			;     C is the denominator 
88bb			;Outputs: 
88bb			;     A is the remainder 
88bb			;     B is 0 
88bb			;     C is not changed 
88bb			;     DE is not changed 
88bb			;     HL is the quotient 
88bb			; 
88bb			;       ld b,16 
88bb			;       xor a 
88bb			;         add hl,hl 
88bb			;         rla 
88bb			;         cp c 
88bb			;         jr c,$+4 
88bb			;           inc l 
88bb			;           sub c 
88bb			;         djnz $-7 
88bb			 
88bb			; https://plutiedev.com/z80-add-8bit-to-16bit 
88bb			 
88bb			addatohl: 
88bb 85			    add   a, l    ; A = A+L 
88bc 6f			    ld    l, a    ; L = A+L 
88bd 8c			    adc   a, h    ; A = A+L+H+carry 
88be 95			    sub   l       ; A = H+carry 
88bf 67			    ld    h, a    ; H = H+carry 
88c0 c9			ret 
88c1			 
88c1			addatode: 
88c1 83			    add   a, e    ; A = A+L 
88c2 5f			    ld    e, a    ; L = A+L 
88c3 8a			    adc   a, d    ; A = A+L+H+carry 
88c4 93			    sub   e       ; A = H+carry 
88c5 57			    ld    d, a    ; H = H+carry 
88c6 c9			ret 
88c7			 
88c7			 
88c7			addatobc: 
88c7 81			    add   a, c    ; A = A+L 
88c8 4f			    ld    c, a    ; L = A+L 
88c9 88			    adc   a, b    ; A = A+L+H+carry 
88ca 91			    sub   c       ; A = H+carry 
88cb 47			    ld    b, a    ; H = H+carry 
88cc c9			ret 
88cd			 
88cd			subafromhl: 
88cd			   ; If A=0 do nothing 
88cd			    ; Otherwise flip A's sign. Since 
88cd			    ; the upper byte becomes -1, also 
88cd			    ; substract 1 from H. 
88cd ed 44		    neg 
88cf ca d8 88		    jp    z, Skip 
88d2 25			    dec   h 
88d3			     
88d3			    ; Now add the low byte as usual 
88d3			    ; Two's complement takes care of 
88d3			    ; ensuring the result is correct 
88d3 85			    add   a, l 
88d4 6f			    ld    l, a 
88d5 8c			    adc   a, h 
88d6 95			    sub   l 
88d7 67			    ld    h, a 
88d8			Skip: 
88d8 c9				ret 
88d9			 
88d9			 
88d9			; compare hl and de 
88d9			; returns:  
88d9			; if hl = de, z=1, s=0, c0=0 
88d9			; if hl > de, z=0, s=0, c=0 
88d9			; if hl < de, z=0, s=1, c=1 
88d9			cmp16:	 
88d9 b7				or a 
88da ed 52			sbc hl,de 
88dc e0				ret po 
88dd 7c				ld a,h 
88de 1f				rra 
88df ee 40			xor 01000000B 
88e1 37				scf 
88e2 8f				adc a,a 
88e3 c9				ret 
88e4			 
88e4			 
88e4			; test if hl contains zero   - A is destroyed 
88e4			 
88e4			ishlzero:    
88e4 b7				or a     ; reset flags 
88e5 7c				ld a, h 
88e6 b5				or l        	 
88e7			 
88e7 c9				ret 
88e8			 
88e8			 
88e8			 
88e8			 
88e8			if FORTH_ENABLE_FLOATMATH 
88e8			include "float/bbcmath.z80" 
88e8			endif 
88e8			 
88e8			 
88e8			; eof 
88e8			 
# End of file firmware_maths.asm
88e8			include "firmware_strings.asm"   ; string handling  
88e8			 
88e8			 
88e8			; TODO string len 
88e8			; input text string, end on cr with zero term 
88e8			; a offset into frame buffer to start prompt 
88e8			; d is max length 
88e8			; e is display size TODO 
88e8			; c is current cursor position 
88e8			; hl is ptr to where string will be stored 
88e8			 
88e8			 
88e8			; TODO check limit of buffer for new inserts 
88e8			; TODO check insert does not push beyond buffer 
88e8			; TODO scroll in a limited display area 
88e8			; TODO scroll whole screen on page wrap 
88e8			 
88e8			 
88e8			; TODO handle KEY_PREVWORD 
88e8			; TODO handle KEY_NEXTWORD 
88e8			; TODO handle KEY_HOME 
88e8			; TODO handle KEY_END 
88e8			; TODO use LCD cursor? 
88e8			 
88e8 32 73 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
88eb 81					add c 
88ec 32 71 ee				ld (input_at_cursor),a	; save draw pos of cursor 
88ef 22 76 ee				ld (input_start), hl     ; save ptr to buffer 
88f2 79					ld a, c 
88f3 cd bb 88				call addatohl 
88f6 22 78 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
88f9 7a					ld a,d 
88fa 32 75 ee			        ld (input_size), a       ; save length of input area 
88fd 79					ld a, c 
88fe 32 64 ee				ld (input_cursor),a      ; init cursor start position  
8901 7b					ld a,e 
8902 32 74 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8905					 
8905					 
8905			 
8905			;		ld a,(input_ptr) 
8905			;		ld (input_under_cursor),a 	; save what is under the cursor 
8905			 
8905			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8905					; init cursor shape if not set by the cin routines 
8905 21 d3 eb				ld hl, cursor_shape 
8908 3e ff				ld a, 255 
890a 77					ld (hl), a 
890b 23					inc hl 
890c 3e 00				ld a, 0 
890e 77					ld (hl), a 
890f			 
890f 3e 0f				ld a, CUR_BLINK_RATE 
8911 32 6f ee				ld (input_cur_flash), a 
8914 3e 01				ld a, 1 
8916 32 6e ee				ld (input_cur_onoff),a 
8919			 
8919			;	if DEBUG_INPUT 
8919			;		push af 
8919			;		ld a, 'I' 
8919			;		ld (debug_mark),a 
8919			;		pop af 
8919			;		CALLMONITOR 
8919			;	endif 
8919			.is1:		; main entry loop 
8919			 
8919			 
8919			 
8919					; pause 1ms 
8919			 
8919 3e 01				ld a, 1 
891b cd cb 86				call aDelayInMS 
891e			 
891e					; dec flash counter 
891e 3a 6f ee				ld a, (input_cur_flash) 
8921 3d					dec a 
8922 32 6f ee				ld (input_cur_flash), a 
8925 fe 00				cp 0 
8927 20 0d				jr nz, .nochgstate 
8929			 
8929			 
8929					; change state 
8929 3a 6e ee				ld a,(input_cur_onoff) 
892c ed 44				neg 
892e 32 6e ee				ld (input_cur_onoff),a 
8931			 
8931			 
8931					; reset on change of state 
8931 3e 0f				ld a, CUR_BLINK_RATE 
8933 32 6f ee				ld (input_cur_flash), a 
8936			 
8936			.nochgstate: 
8936					 
8936					 
8936			 
8936					; display cursor  
8936			 
8936			;		ld hl, (input_start) 
8936			;		ld a, (input_cursor) 
8936			;		call addatohl 
8936			 
8936					; get char under cursor and replace with cursor 
8936 2a 78 ee		ld hl, (input_ptr) 
8939			;		ld a, (hl) 
8939			;		ld (input_under_cursor),a 
8939			;		ld a, '_' 
8939			;		ld (hl), a 
8939			 
8939					; display string 
8939			 
8939 ed 5b 76 ee			ld de, (input_start) 
893d 3a 73 ee				ld a, (input_at_pos) 
8940 cd 75 87				call str_at_display 
8943			;	        call update_display 
8943			 
8943					; find place to put the cursor 
8943			;		add h 
8943			;		ld l, display_row_1 
8943			;		sub l 
8943			; (input_at_pos) 
8943					;ld c, a 
8943			;		ld a, (input_cursor) 
8943			;		ld l, (input_at_pos) 
8943			;		;ld b, h 
8943			;		add l 
8943			;		ld (input_at_cursor),a 
8943					;ld l,h 
8943			 
8943			;		ld h, 0 
8943			;		ld l,(input_at_pos) 
8943			;		ld a, (input_cursor) 
8943			;		call addatohl 
8943			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8943			;		call subafromhl 
8943			;		ld a,l 
8943			;		ld (input_at_cursor), a 
8943			 
8943				if DEBUG_INPUT 
8943					ld a, (hardware_diag) 
8943					cp 0 
8943					jr z, .skip_input_diag 
8943			 
8943					ld a,(input_at_pos) 
8943					ld hl, LFSRSeed 
8943					call hexout 
8943					ld a, (input_cursor) 
8943					ld hl, LFSRSeed+2 
8943					call hexout 
8943					ld a,(input_at_cursor) 
8943					ld hl, LFSRSeed+4 
8943					call hexout 
8943			 
8943					ld a,(input_cur_onoff) 
8943					ld hl, LFSRSeed+6 
8943					call hexout 
8943			 
8943					ld a,(input_cur_flash) 
8943					ld hl, LFSRSeed+8 
8943					call hexout 
8943			 
8943					ld a,(input_len) 
8943					ld hl, LFSRSeed+10 
8943					call hexout 
8943					ld hl, LFSRSeed+12 
8943					ld a, 0 
8943					ld (hl),a 
8943					ld a, display_row_4 
8943					ld de, LFSRSeed 
8943					call str_at_display 
8943					.skip_input_diag: 
8943				endif 
8943			 
8943					; decide on if we are showing the cursor this time round 
8943			 
8943 3a 6e ee				ld a, (input_cur_onoff) 
8946 fe ff				cp 255 
8948 28 13				jr z, .skipcur 
894a			 
894a			 
894a 3a 71 ee				ld a,(input_at_cursor) 
894d 11 d3 eb				ld de, cursor_shape 
8950 cd 75 87				call str_at_display 
8953			 
8953					; save length of current input string 
8953 2a 76 ee				ld hl, (input_start) 
8956 cd 19 8d				call strlenz 
8959 7d					ld a,l 
895a 32 69 ee				ld (input_len),a 
895d			 
895d			.skipcur: 
895d			 
895d cd 85 87			        call update_display 
8960					 
8960			 
8960			 
8960					; wait 
8960				 
8960					; TODO loop without wait to flash the cursor and char under cursor	 
8960 cd a5 c6				call cin    ; _wait 
8963			 
8963 fe 00				cp 0 
8965 ca 19 89				jp z, .is1 
8968			 
8968					; get ptr to char to input into 
8968			 
8968 4f					ld c,a 
8969 2a 76 ee				ld hl, (input_start) 
896c 3a 64 ee				ld a, (input_cursor) 
896f cd bb 88				call addatohl 
8972 22 78 ee				ld (input_ptr), hl 
8975 79					ld a,c 
8976			 
8976					; replace char under cursor 
8976			 
8976			;		ld hl, (input_ptr) 
8976			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8976			;		ld (hl), a 
8976			 
8976			;	if DEBUG_INPUT 
8976			;		push af 
8976			;		ld a, 'i' 
8976			;		ld (debug_mark),a 
8976			;		pop af 
8976			;		CALLMONITOR 
8976			;	endif 
8976 fe 0e				cp KEY_HOME 
8978 20 0e				jr nz, .iske 
897a			 
897a 3a 73 ee				ld a, (input_at_pos) 
897d 32 71 ee				ld (input_at_cursor),a 
8980 3e 00				ld a, 0 
8982 32 64 ee				ld (input_cursor), a 
8985 c3 19 89				jp .is1 
8988					 
8988 fe 0f		.iske:		cp KEY_END 
898a 20 03				jr nz, .isknw 
898c c3 19 89				jp .is1 
898f			 
898f fe 06		.isknw:		cp KEY_NEXTWORD 
8991 20 1b				jr nz, .iskpw 
8993			 
8993 2a 78 ee		.isknwm:	ld hl, (input_ptr) 
8996 7e					ld a,(hl)	 
8997 fe 00				cp 0 
8999 ca 19 89				jp z, .is1    ; end of string 
899c fe 20				cp ' ' 
899e ca 19 89				jp z, .is1    ; end of word 
89a1 23					inc hl 
89a2 22 78 ee				ld (input_ptr), hl 
89a5 3a 71 ee				ld a, (input_at_cursor) 
89a8 3c					inc a 
89a9 32 71 ee				ld (input_at_cursor), a 
89ac 18 e5				jr .isknwm 
89ae			 
89ae fe 07		.iskpw:		cp KEY_PREVWORD 
89b0 20 1b				jr nz, .iskl 
89b2			.iskpwm:	 
89b2 2a 78 ee				ld hl, (input_ptr) 
89b5 7e					ld a,(hl)	 
89b6 fe 00				cp 0  
89b8 ca 19 89				jp z, .is1    ; end of string 
89bb fe 20				cp ' ' 
89bd ca 19 89				jp z, .is1    ; end of word 
89c0 2b					dec hl 
89c1 22 78 ee				ld (input_ptr), hl 
89c4 3a 71 ee				ld a, (input_at_cursor) 
89c7 3d					dec a 
89c8 32 71 ee				ld (input_at_cursor), a 
89cb 18 e5				jr .iskpwm 
89cd			 
89cd			 
89cd fe 0b		.iskl:		cp KEY_LEFT 
89cf 20 27				jr nz, .isk1 
89d1			 
89d1 3a 64 ee				ld a, (input_cursor) 
89d4			 
89d4 fe 00				cp 0 
89d6 ca 19 89				jp z, .is1 		; at start of line to ignore  
89d9			 
89d9 3d					dec  a 		; TODO check underflow 
89da 32 64 ee				ld (input_cursor), a 
89dd			 
89dd 2a 78 ee				ld hl, (input_ptr) 
89e0 2b					dec hl 
89e1 22 78 ee				ld (input_ptr), hl 
89e4					 
89e4 3a 71 ee				ld a, (input_at_cursor) 
89e7 3d					dec a 
89e8 32 71 ee				ld (input_at_cursor), a 
89eb			 
89eb 3e 01				ld a, 1		; show cursor moving 
89ed 32 6e ee				ld (input_cur_onoff),a 
89f0 3e 0f				ld a, CUR_BLINK_RATE 
89f2 32 6f ee				ld (input_cur_flash), a 
89f5			 
89f5 c3 19 89				jp .is1 
89f8			 
89f8 fe 0c		.isk1:		cp KEY_RIGHT 
89fa 20 2a				jr nz, .isk2 
89fc			 
89fc 3a 69 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
89ff 5f					ld e,a 
8a00 3a 64 ee				ld a, (input_cursor) 
8a03 bb					cp e 
8a04 ca 19 89				jp z, .is1		; at the end of string so dont go right 
8a07			 
8a07 3c					inc  a 		; TODO check overflow 
8a08 32 64 ee				ld (input_cursor), a 
8a0b			 
8a0b 3a 71 ee				ld a, (input_at_cursor) 
8a0e 3c					inc a 
8a0f 32 71 ee				ld (input_at_cursor), a 
8a12			 
8a12 2a 78 ee				ld hl, (input_ptr) 
8a15 23					inc hl 
8a16 22 78 ee				ld (input_ptr), hl 
8a19			 
8a19 3e 01				ld a, 1		; show cursor moving 
8a1b 32 6e ee				ld (input_cur_onoff),a 
8a1e 3e 0f				ld a, CUR_BLINK_RATE 
8a20 32 6f ee				ld (input_cur_flash), a 
8a23			 
8a23 c3 19 89				jp .is1 
8a26			 
8a26 fe 05		.isk2:		cp KEY_UP 
8a28			 
8a28 20 26				jr nz, .isk3 
8a2a			 
8a2a					; swap last command with the current on 
8a2a			 
8a2a					; move cursor to start of string 
8a2a 2a 76 ee				ld hl, (input_start) 
8a2d 22 78 ee				ld (input_ptr), hl 
8a30			 
8a30 3a 73 ee				ld a, (input_at_pos) 
8a33 32 71 ee				ld (input_at_cursor), a 
8a36			 
8a36 3e 00				ld a, 0 
8a38 32 64 ee				ld (input_cursor), a 
8a3b					 
8a3b					; swap input and last command buffers 
8a3b			 
8a3b 21 9c e6				ld hl, os_cli_cmd 
8a3e 11 9b e7				ld de, os_last_cmd 
8a41 06 ff				ld b, 255 
8a43 7e			.swap1:		ld a, (hl) 
8a44 4f					ld c,a 
8a45 1a					ld a, (de) 
8a46 77					ld (hl), a 
8a47 79					ld a,c 
8a48 12					ld (de),a 
8a49 23					inc hl 
8a4a 13					inc de 
8a4b 10 f6				djnz .swap1 
8a4d			 
8a4d			 
8a4d			 
8a4d			 
8a4d			 
8a4d c3 19 89				jp .is1 
8a50			 
8a50 fe 08		.isk3:		cp KEY_BS 
8a52 20 3c				jr nz, .isk4 
8a54			 
8a54 3a 64 ee				ld a, (input_cursor) 
8a57			 
8a57 fe 00				cp 0 
8a59 ca 19 89				jp z, .is1 		; at start of line to ignore  
8a5c			 
8a5c 3d					dec  a 		; TODO check underflow 
8a5d 32 64 ee				ld (input_cursor), a 
8a60			 
8a60					; hl is source 
8a60					; de needs to be source - 1 
8a60			 
8a60			;		ld a, 0 
8a60			;		dec hl 
8a60			;		ld (hl), a 
8a60			 
8a60 2a 78 ee				ld hl, (input_ptr) 
8a63 2b					dec hl 
8a64 22 78 ee				ld (input_ptr), hl 
8a67			 
8a67					; shift all data 
8a67			 
8a67 e5					push hl 
8a68 23					inc hl 
8a69 d1					pop de 
8a6a 3a 69 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8a6d 4f					ld c,a 
8a6e 06 00				ld b,0 
8a70 ed b0				ldir  
8a72			 
8a72			 
8a72			 
8a72			 
8a72 3a 71 ee				ld a, (input_at_cursor) 
8a75 3d					dec a 
8a76 32 71 ee				ld (input_at_cursor), a 
8a79			 
8a79			 
8a79 3e 01				ld a, 1		; show cursor moving 
8a7b 32 6e ee				ld (input_cur_onoff),a 
8a7e 3e 0f				ld a, CUR_BLINK_RATE 
8a80 32 6f ee				ld (input_cur_flash), a 
8a83			 
8a83					; remove char 
8a83 3a 71 ee				ld a, (input_at_cursor) 
8a86 3c					inc a 
8a87 11 11 8b				ld de,.iblank 
8a8a cd 75 87				call str_at_display 
8a8d			 
8a8d c3 19 89				jp .is1 
8a90			 
8a90 fe 0d		.isk4:		cp KEY_CR 
8a92 28 6c				jr z, .endinput 
8a94			 
8a94					; else add the key press to the end 
8a94			 
8a94 4f					ld c, a			; save key pressed 
8a95			 
8a95 7e					ld a,(hl)		; get what is currently under char 
8a96			 
8a96 fe 00				cp 0			; we are at the end of the string 
8a98 20 2f				jr nz, .onchar 
8a9a					 
8a9a					; add a char to the end of the string 
8a9a				 
8a9a 71					ld (hl),c 
8a9b 23					inc hl 
8a9c			;		ld a,' ' 
8a9c			;		ld (hl),a 
8a9c			;		inc hl 
8a9c 3e 00				ld a,0 
8a9e 77					ld (hl),a 
8a9f 2b					dec hl 
8aa0			 
8aa0 3a 64 ee				ld a, (input_cursor) 
8aa3 3c					inc a				; TODO check max string length and scroll  
8aa4 32 64 ee				ld (input_cursor), a		; inc cursor pos 
8aa7							 
8aa7 3a 71 ee				ld a, (input_at_cursor) 
8aaa 3c					inc a 
8aab 32 71 ee				ld (input_at_cursor), a 
8aae			 
8aae 2a 78 ee				ld hl, (input_ptr) 
8ab1 23					inc hl 
8ab2 22 78 ee				ld (input_ptr), hl 
8ab5			 
8ab5 2a 78 ee				ld hl, (input_ptr) 
8ab8 23					inc hl 
8ab9 22 78 ee				ld (input_ptr), hl 
8abc			;	if DEBUG_INPUT 
8abc			;		push af 
8abc			;		ld a, '+' 
8abc			;		ld (debug_mark),a 
8abc			;		pop af 
8abc			;		CALLMONITOR 
8abc			;	endif 
8abc 3e 01				ld a, 1		; show cursor moving 
8abe 32 6e ee				ld (input_cur_onoff),a 
8ac1 3e 0f				ld a, CUR_BLINK_RATE 
8ac3 32 6f ee				ld (input_cur_flash), a 
8ac6 c3 19 89				jp .is1 
8ac9					 
8ac9			 
8ac9			 
8ac9					; if on a char then insert 
8ac9			.onchar: 
8ac9			 
8ac9					; TODO over flow check: make sure insert does not blow out buffer 
8ac9			 
8ac9					; need to do some maths to use lddr 
8ac9			 
8ac9 e5					push hl   ; save char pos 
8aca c5					push bc 
8acb			 
8acb 2a 76 ee				ld hl, (input_start) 
8ace 3a 69 ee				ld a, (input_len) 
8ad1 cd bb 88				call addatohl  		; end of string 
8ad4 23					inc hl 
8ad5 23					inc hl		; past zero term 
8ad6 e5					push hl 
8ad7 23					inc hl 
8ad8 e5					push hl  
8ad9			 
8ad9								; start and end of lddr set, now how much to move? 
8ad9			 
8ad9							 
8ad9 3a 64 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8adc 47					ld b,a 
8add 3a 69 ee				ld a,(input_len) 
8ae0 5f					ld e,a 
8ae1 90					sub b 
8ae2 3c					inc a		;?? 
8ae3 3c					inc a		;?? 
8ae4 3c					inc a		;?? 
8ae5			 
8ae5 06 00				ld b,0 
8ae7 4f					ld c,a 
8ae8			 
8ae8				if DEBUG_INPUT 
8ae8					push af 
8ae8					ld a, 'i' 
8ae8					ld (debug_mark),a 
8ae8					pop af 
8ae8			;		CALLMONITOR 
8ae8				endif 
8ae8 d1					pop de 
8ae9 e1					pop hl 
8aea				if DEBUG_INPUT 
8aea					push af 
8aea					ld a, 'I' 
8aea					ld (debug_mark),a 
8aea					pop af 
8aea			;		CALLMONITOR 
8aea				endif 
8aea ed b8				lddr 
8aec				 
8aec			 
8aec			 
8aec					; TODO have a key for insert/overwrite mode???? 
8aec c1					pop bc 
8aed e1					pop hl 
8aee 71					ld (hl), c		; otherwise overwrite current char 
8aef					 
8aef			 
8aef			 
8aef			 
8aef 3a 64 ee				ld a, (input_cursor) 
8af2 3c					inc  a 		; TODO check overflow 
8af3 32 64 ee				ld (input_cursor), a 
8af6			 
8af6 3a 71 ee				ld a, (input_at_cursor) 
8af9 3c					inc a 
8afa 32 71 ee				ld (input_at_cursor), a 
8afd			 
8afd c3 19 89				jp .is1 
8b00			 
8b00			.endinput:	; TODO look for end of string 
8b00			 
8b00					; add trailing space for end of token 
8b00			 
8b00 2a 76 ee				ld hl, (input_start) 
8b03 3a 69 ee				ld a,(input_len) 
8b06 cd bb 88				call addatohl 
8b09 3e 20				ld a, ' ' 
8b0b 77					ld (hl),a 
8b0c					; TODO eof of parse marker 
8b0c			 
8b0c 23					inc hl 
8b0d 3e 00				ld a, 0 
8b0f 77					ld (hl),a 
8b10			 
8b10			 
8b10 c9					ret 
8b11			 
8b11 .. 00		.iblank: db " ",0 
8b13			 
8b13			 
8b13 32 73 ee		input_str_prev:	ld (input_at_pos), a 
8b16 22 76 ee				ld (input_start), hl 
8b19 3e 01				ld a,1			; add cursor 
8b1b 77					ld (hl),a 
8b1c 23					inc hl 
8b1d 3e 00				ld a,0 
8b1f 77					ld (hl),a 
8b20 22 78 ee				ld (input_ptr), hl 
8b23 7a					ld a,d 
8b24 32 75 ee				ld (input_size), a 
8b27 3e 00				ld a,0 
8b29 32 64 ee				ld (input_cursor),a 
8b2c			.instr1:	 
8b2c			 
8b2c					; TODO do block cursor 
8b2c					; TODO switch cursor depending on the modifer key 
8b2c			 
8b2c					; update cursor shape change on key hold 
8b2c			 
8b2c 2a 78 ee				ld hl, (input_ptr) 
8b2f 2b					dec hl 
8b30 3a d3 eb				ld a,(cursor_shape) 
8b33 77					ld (hl), a 
8b34			 
8b34					; display entered text 
8b34 3a 73 ee				ld a,(input_at_pos) 
8b37 cd 03 c6		            	CALL fLCD_Pos       ;Position cursor to location in A 
8b3a ed 5b 76 ee	            	LD   de, (input_start) 
8b3e cd fd c5		            	CALL fLCD_Str       ;Display string pointed to by DE 
8b41			 
8b41 cd a5 c6				call cin 
8b44 fe 00				cp 0 
8b46 28 e4				jr z, .instr1 
8b48			 
8b48					; proecess keyboard controls first 
8b48			 
8b48 2a 78 ee				ld hl,(input_ptr) 
8b4b			 
8b4b fe 0d				cp KEY_CR	 ; pressing enter ends input 
8b4d 28 5a				jr z, .instrcr 
8b4f			 
8b4f fe 08				cp KEY_BS 	; back space 
8b51 20 0f				jr nz, .instr2 
8b53					; process back space 
8b53			 
8b53					; TODO stop back space if at start of string 
8b53 2b					dec hl 
8b54 2b					dec hl ; to over write cursor 
8b55 3a d3 eb				ld a,(cursor_shape) 
8b58					;ld a,0 
8b58 77					ld (hl),a 
8b59 23					inc hl 
8b5a 3e 20				ld a," " 
8b5c 77					ld (hl),a 
8b5d 22 78 ee				ld (input_ptr),hl 
8b60					 
8b60			 
8b60 18 ca				jr .instr1 
8b62			 
8b62 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8b64 20 06				jr nz, .instr3 
8b66 2b					dec hl 
8b67 22 78 ee				ld (input_ptr),hl 
8b6a 18 c0				jr .instr1 
8b6c				 
8b6c fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8b6e 20 06				jr nz, .instr4 
8b70 23					inc hl 
8b71 22 78 ee				ld (input_ptr),hl 
8b74 18 b6				jr .instr1 
8b76			 
8b76 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8b78 20 06				jr nz, .instr5 
8b7a 2b					dec hl 
8b7b 22 78 ee				ld (input_ptr),hl 
8b7e 18 ac				jr .instr1 
8b80			 
8b80 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8b82 20 06				jr nz, .instr6 
8b84 2b					dec hl 
8b85 22 78 ee				ld (input_ptr),hl 
8b88 18 a2				jr .instr1 
8b8a fe 05		.instr6:        cp KEY_UP      ; recall last command 
8b8c 20 0b				jr nz, .instrnew 
8b8e			 
8b8e 21 75 e3			ld hl, scratch 
8b91 11 9b e7			ld de, os_last_cmd 
8b94 cd b2 8b			call strcpy 
8b97 18 93				jr .instr1 
8b99			 
8b99			 
8b99			.instrnew:	; no special key pressed to see if we have room to store it 
8b99			 
8b99					; TODO do string size test 
8b99			 
8b99 2b					dec hl ; to over write cursor 
8b9a 77					ld (hl),a 
8b9b 23					inc hl 
8b9c 3a d3 eb				ld a,(cursor_shape) 
8b9f 77					ld (hl),a 
8ba0 23					inc hl 
8ba1 3e 00				ld a,0 
8ba3 77					ld (hl),a 
8ba4			 
8ba4 22 78 ee				ld (input_ptr),hl 
8ba7					 
8ba7 18 83				jr .instr1 
8ba9 2b			.instrcr:	dec hl		; remove cursor 
8baa 3e 20				ld a,' '	; TODO add a trailing space for safety 
8bac 77					ld (hl),a 
8bad 23					inc hl 
8bae 3e 00				ld a,0 
8bb0 77					ld (hl),a 
8bb1			 
8bb1			 
8bb1					; if at end of line scroll up    
8bb1					; TODO detecting only end of line 4 for scroll up  
8bb1			 
8bb1					;ld   
8bb1			 
8bb1 c9					ret 
8bb2			 
8bb2			 
8bb2			; strcpy hl = dest, de source 
8bb2			 
8bb2 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8bb3 b7			            OR   A              ;Null terminator? 
8bb4 c8			            RET  Z              ;Yes, so finished 
8bb5 1a					ld a,(de) 
8bb6 77					ld (hl),a 
8bb7 13			            INC  DE             ;Point to next character 
8bb8 23					inc hl 
8bb9 18 f7		            JR   strcpy       ;Repeat 
8bbb c9					ret 
8bbc			 
8bbc			 
8bbc			; TODO string_at  
8bbc			; pass string which starts with lcd offset address and then null term string 
8bbc			 
8bbc			; TODO string to dec 
8bbc			; TODO string to hex 
8bbc			; TODO byte to string hex 
8bbc			; TODO byte to string dec 
8bbc			 
8bbc			 
8bbc			 
8bbc			; from z80uartmonitor 
8bbc			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8bbc			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8bbc			; pass hl for where to put the text 
8bbc			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8bbc c5			hexout:	PUSH BC 
8bbd f5					PUSH AF 
8bbe 47					LD B, A 
8bbf					; Upper nybble 
8bbf cb 3f				SRL A 
8bc1 cb 3f				SRL A 
8bc3 cb 3f				SRL A 
8bc5 cb 3f				SRL A 
8bc7 cd d7 8b				CALL tohex 
8bca 77					ld (hl),a 
8bcb 23					inc hl	 
8bcc					 
8bcc					; Lower nybble 
8bcc 78					LD A, B 
8bcd e6 0f				AND 0FH 
8bcf cd d7 8b				CALL tohex 
8bd2 77					ld (hl),a 
8bd3 23					inc hl	 
8bd4					 
8bd4 f1					POP AF 
8bd5 c1					POP BC 
8bd6 c9					RET 
8bd7					 
8bd7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8bd7			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8bd7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8bd7			tohex: 
8bd7 e5					PUSH HL 
8bd8 d5					PUSH DE 
8bd9 16 00				LD D, 0 
8bdb 5f					LD E, A 
8bdc 21 e4 8b				LD HL, .DATA 
8bdf 19					ADD HL, DE 
8be0 7e					LD A, (HL) 
8be1 d1					POP DE 
8be2 e1					POP HL 
8be3 c9					RET 
8be4			 
8be4			.DATA: 
8be4 30					DEFB	30h	; 0 
8be5 31					DEFB	31h	; 1 
8be6 32					DEFB	32h	; 2 
8be7 33					DEFB	33h	; 3 
8be8 34					DEFB	34h	; 4 
8be9 35					DEFB	35h	; 5 
8bea 36					DEFB	36h	; 6 
8beb 37					DEFB	37h	; 7 
8bec 38					DEFB	38h	; 8 
8bed 39					DEFB	39h	; 9 
8bee 41					DEFB	41h	; A 
8bef 42					DEFB	42h	; B 
8bf0 43					DEFB	43h	; C 
8bf1 44					DEFB	44h	; D 
8bf2 45					DEFB	45h	; E 
8bf3 46					DEFB	46h	; F 
8bf4			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8bf4			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8bf4			;;    subtract $30, if result > 9 then subtract $7 more 
8bf4			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8bf4			atohex: 
8bf4 d6 30				SUB $30 
8bf6 fe 0a				CP 10 
8bf8 f8					RET M		; If result negative it was 0-9 so we're done 
8bf9 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8bfb c9					RET		 
8bfc			 
8bfc			 
8bfc			 
8bfc			 
8bfc			; Get 2 ASCII characters as hex byte from pointer in hl 
8bfc			 
8bfc			BYTERD: 
8bfc 16 00			LD	D,00h		;Set up 
8bfe cd 06 8c			CALL	HEXCON		;Get byte and convert to hex 
8c01 87				ADD	A,A		;First nibble so 
8c02 87				ADD	A,A		;multiply by 16 
8c03 87				ADD	A,A		; 
8c04 87				ADD	A,A		; 
8c05 57				LD	D,A		;Save hi nibble in D 
8c06			HEXCON: 
8c06 7e				ld a, (hl)		;Get next chr 
8c07 23				inc hl 
8c08 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8c0a fe 0a			CP	00Ah		;Is it 0-9 ? 
8c0c 38 02			JR	C,NALPHA	;If so miss next bit 
8c0e d6 07			SUB	007h		;Else convert alpha 
8c10			NALPHA: 
8c10 b2				OR	D		;Add hi nibble back 
8c11 c9				RET			; 
8c12			 
8c12			 
8c12			; 
8c12			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8c12			; Since the routines get_byte and therefore get_nibble are called, only valid 
8c12			; characters (0-9a-f) are accepted. 
8c12			; 
8c12			;get_word        push    af 
8c12			;                call    get_byte        ; Get the upper byte 
8c12			;                ld      h, a 
8c12			;                call    get_byte        ; Get the lower byte 
8c12			;                ld      l, a 
8c12			;                pop     af 
8c12			;                ret 
8c12			; 
8c12			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8c12			; the routine get_nibble is used only valid characters are accepted - the  
8c12			; input routine only accepts characters 0-9a-f. 
8c12			; 
8c12 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8c13 7e					ld a,(hl) 
8c14 23					inc hl 
8c15 cd 3a 8c		                call    nibble2val      ; Get upper nibble 
8c18 cb 07		                rlc     a 
8c1a cb 07		                rlc     a 
8c1c cb 07		                rlc     a 
8c1e cb 07		                rlc     a 
8c20 47			                ld      b, a            ; Save upper four bits 
8c21 7e					ld a,(hl) 
8c22 cd 3a 8c		                call    nibble2val      ; Get lower nibble 
8c25 b0			                or      b               ; Combine both nibbles 
8c26 c1			                pop     bc              ; Restore B (and C) 
8c27 c9			                ret 
8c28			; 
8c28			; Get a hexadecimal digit from the serial line. This routine blocks until 
8c28			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8c28			; to the serial line interface. The lower 4 bits of A contain the value of  
8c28			; that particular digit. 
8c28			; 
8c28			;get_nibble      ld a,(hl)           ; Read a character 
8c28			;                call    to_upper        ; Convert to upper case 
8c28			;                call    is_hex          ; Was it a hex digit? 
8c28			;                jr      nc, get_nibble  ; No, get another character 
8c28			 ;               call    nibble2val      ; Convert nibble to value 
8c28			 ;               call    print_nibble 
8c28			 ;               ret 
8c28			; 
8c28			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8c28			; A valid hexadecimal digit is denoted by a set C flag. 
8c28			; 
8c28			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8c28			;                ret     nc              ; Yes 
8c28			;                cp      '0'             ; Less than '0'? 
8c28			;                jr      nc, is_hex_1    ; No, continue 
8c28			;                ccf                     ; Complement carry (i.e. clear it) 
8c28			;                ret 
8c28			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8c28			;                ret     c               ; Yes 
8c28			;                cp      'A'             ; Less than 'A'? 
8c28			;                jr      nc, is_hex_2    ; No, continue 
8c28			;                ccf                     ; Yes - clear carry and return 
8c28			;                ret 
8c28			;is_hex_2        scf                     ; Set carry 
8c28			;                ret 
8c28			; 
8c28			; Convert a single character contained in A to upper case: 
8c28			; 
8c28 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8c2a d8			                ret     c 
8c2b fe 7b		                cp      'z' + 1         ; > 'z'? 
8c2d d0			                ret     nc              ; Nothing to do, either 
8c2e e6 5f		                and     $5f             ; Convert to upper case 
8c30 c9			                ret 
8c31			 
8c31			 
8c31			to_lower: 
8c31			 
8c31			   ; if char is in [A-Z] make it lower case 
8c31			 
8c31			   ; enter : a = char 
8c31			   ; exit  : a = lower case char 
8c31			   ; uses  : af 
8c31			 
8c31 fe 41		   cp 'A' 
8c33 d8			   ret c 
8c34			    
8c34 fe 5b		   cp 'Z'+1 
8c36 d0			   ret nc 
8c37			    
8c37 f6 20		   or $20 
8c39 c9			   ret 
8c3a			 
8c3a			; 
8c3a			; Expects a hexadecimal digit (upper case!) in A and returns the 
8c3a			; corresponding value in A. 
8c3a			; 
8c3a fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8c3c 38 02		                jr      c, nibble2val_1 ; Yes 
8c3e d6 07		                sub     7               ; Adjust for A-F 
8c40 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8c42 e6 0f		                and     $f              ; Only return lower 4 bits 
8c44 c9			                ret 
8c45			; 
8c45			; Print_nibble prints a single hex nibble which is contained in the lower  
8c45			; four bits of A: 
8c45			; 
8c45			;print_nibble    push    af              ; We won't destroy the contents of A 
8c45			;                and     $f              ; Just in case... 
8c45			;                add     a, '0'             ; If we have a digit we are done here. 
8c45			;                cp      '9' + 1         ; Is the result > 9? 
8c45			;                jr      c, print_nibble_1 
8c45			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8c45			;print_nibble_1  call    putc            ; Print the nibble and 
8c45			;                pop     af              ; restore the original value of A 
8c45			;                ret 
8c45			;; 
8c45			;; Send a CR/LF pair: 
8c45			; 
8c45			;crlf            push    af 
8c45			;                ld      a, cr 
8c45			;                call    putc 
8c45			;                ld      a, lf 
8c45			;                call    putc 
8c45			;                pop     af 
8c45			;                ret 
8c45			; 
8c45			; Print_word prints the four hex digits of a word to the serial line. The  
8c45			; word is expected to be in HL. 
8c45			; 
8c45			;print_word      push    hl 
8c45			;                push    af 
8c45			;                ld      a, h 
8c45			;                call    print_byte 
8c45			;                ld      a, l 
8c45			;                call    print_byte 
8c45			;                pop     af 
8c45			;                pop     hl 
8c45			;                ret 
8c45			; 
8c45			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8c45			; The byte to be printed is expected to be in A. 
8c45			; 
8c45			;print_byte      push    af              ; Save the contents of the registers 
8c45			;                push    bc 
8c45			;                ld      b, a 
8c45			;                rrca 
8c45			;                rrca 
8c45			;                rrca 
8c45			;                rrca 
8c45			;                call    print_nibble    ; Print high nibble 
8c45			;                ld      a, b 
8c45			;                call    print_nibble    ; Print low nibble 
8c45			;                pop     bc              ; Restore original register contents 
8c45			;                pop     af 
8c45			;                ret 
8c45			 
8c45			 
8c45			 
8c45			 
8c45			 
8c45			fourehexhl:  
8c45 7e				ld a,(hl) 
8c46 cd f4 8b			call atohex 
8c49 cb 3f				SRL A 
8c4b cb 3f				SRL A 
8c4d cb 3f				SRL A 
8c4f cb 3f				SRL A 
8c51 47				ld b, a 
8c52 23				inc hl 
8c53 7e				ld a,(hl) 
8c54 23				inc hl 
8c55 cd f4 8b			call atohex 
8c58 80				add b 
8c59 57				ld d,a 
8c5a 7e				ld a,(hl) 
8c5b cd f4 8b			call atohex 
8c5e cb 3f				SRL A 
8c60 cb 3f				SRL A 
8c62 cb 3f				SRL A 
8c64 cb 3f				SRL A 
8c66 47				ld b, a 
8c67 23				inc hl 
8c68 7e				ld a,(hl) 
8c69 23				inc hl 
8c6a cd f4 8b			call atohex 
8c6d 80				add b 
8c6e 5f				ld e, a 
8c6f d5				push de 
8c70 e1				pop hl 
8c71 c9				ret 
8c72			 
8c72			; pass hl. returns z set if the byte at hl is a digit 
8c72			;isdigithl:  
8c72			;	push bc 
8c72			;	ld a,(hl) 
8c72			;	cp ':' 
8c72			;	jr nc, .isdf 		; > 
8c72			;	cp '0' 
8c72			;	jr c, .isdf		; < 
8c72			; 
8c72			;	; TODO find a better way to set z 
8c72			; 
8c72			;	ld b,a 
8c72			;	cp b 
8c72			;	pop bc 
8c72			;	ret 
8c72			; 
8c72			;.isdf:	; not digit so clear z 
8c72			; 
8c72			;	; TODO find a better way to unset z 
8c72			; 
8c72			;	ld b,a 
8c72			;	inc b 
8c72			;	cp b 
8c72			; 
8c72			;	pop bc 
8c72			;	ret 
8c72				 
8c72				 
8c72			 
8c72			 
8c72			; pass hl as the four byte address to load 
8c72			 
8c72			get_word_hl:  
8c72 e5				push hl 
8c73 cd 12 8c			call get_byte 
8c76				 
8c76 47				ld b, a 
8c77			 
8c77 e1				pop hl 
8c78 23				inc hl 
8c79 23				inc hl 
8c7a			 
8c7a			; TODO not able to handle a-f  
8c7a 7e				ld a,(hl) 
8c7b			;	;cp ':' 
8c7b			;	cp 'g' 
8c7b			;	jr nc, .single_byte_hl 		; > 
8c7b			;	cp 'G' 
8c7b			;	jr nc, .single_byte_hl 		; > 
8c7b			;	cp '0' 
8c7b			;	jr c, .single_byte_hl		; < 
8c7b			 
8c7b				;call isdigithl 
8c7b fe 00			cp 0 
8c7d 28 06			jr z, .single_byte_hl 
8c7f			 
8c7f			.getwhln:   ; hex word so get next byte 
8c7f			 
8c7f cd 12 8c			call get_byte 
8c82 6f				ld l, a 
8c83 60				ld h,b 
8c84 c9				ret 
8c85 68			.single_byte_hl:   ld l,b 
8c86 26 00				ld h,0 
8c88 c9					ret 
8c89			 
8c89			 
8c89			 
8c89			 
8c89 21 23 93			ld hl,asc+1 
8c8c			;	ld a, (hl) 
8c8c			;	call nibble2val 
8c8c cd 12 8c			call get_byte 
8c8f			 
8c8f			;	call fourehexhl 
8c8f 32 a9 e3			ld (scratch+52),a 
8c92				 
8c92 21 a7 e3			ld hl,scratch+50 
8c95 22 98 e6			ld (os_cur_ptr),hl 
8c98			 
8c98 c9				ret 
8c99			 
8c99			 
8c99			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8c99			 
8c99			; Decimal Unsigned Version 
8c99			 
8c99			;Number in a to decimal ASCII 
8c99			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8c99			;Example: display a=56 as "056" 
8c99			;input: a = number 
8c99			;Output: a=0,value of a in the screen 
8c99			;destroys af,bc (don't know about hl and de) 
8c99			DispAToASCII: 
8c99 0e 9c			ld	c,-100 
8c9b cd a5 8c			call	.Na1 
8c9e 0e f6			ld	c,-10 
8ca0 cd a5 8c			call	.Na1 
8ca3 0e ff			ld	c,-1 
8ca5 06 2f		.Na1:	ld	b,'0'-1 
8ca7 04			.Na2:	inc	b 
8ca8 81				add	a,c 
8ca9 38 fc			jr	c,.Na2 
8cab 91				sub	c		;works as add 100/10/1 
8cac f5				push af		;safer than ld c,a 
8cad 78				ld	a,b		;char is in b 
8cae			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8cae f1				pop af		;safer than ld a,c 
8caf c9				ret 
8cb0			 
8cb0			; Decimal Signed Version 
8cb0			 
8cb0			; DispA 
8cb0			; -------------------------------------------------------------- 
8cb0			; Converts a signed integer value to a zero-terminated ASCII 
8cb0			; string representative of that value (using radix 10). 
8cb0			; -------------------------------------------------------------- 
8cb0			; INPUTS: 
8cb0			;     HL     Value to convert (two's complement integer). 
8cb0			;     DE     Base address of string destination. (pointer). 
8cb0			; -------------------------------------------------------------- 
8cb0			; OUTPUTS: 
8cb0			;     None 
8cb0			; -------------------------------------------------------------- 
8cb0			; REGISTERS/MEMORY DESTROYED 
8cb0			; AF HL 
8cb0			; -------------------------------------------------------------- 
8cb0			 
8cb0			;DispHLToASCII: 
8cb0			;   push    de 
8cb0			;   push    bc 
8cb0			; 
8cb0			;; Detect sign of HL. 
8cb0			;    bit    7, h 
8cb0			;    jr     z, ._DoConvert 
8cb0			; 
8cb0			;; HL is negative. Output '-' to string and negate HL. 
8cb0			;    ld     a, '-' 
8cb0			;    ld     (de), a 
8cb0			;    inc    de 
8cb0			; 
8cb0			;; Negate HL (using two's complement) 
8cb0			;    xor    a 
8cb0			;    sub    l 
8cb0			;    ld     l, a 
8cb0			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8cb0			;    sbc    a, h 
8cb0			;    ld     h, a 
8cb0			; 
8cb0			;; Convert HL to digit characters 
8cb0			;._DoConvert: 
8cb0			;    ld     b, 0     ; B will count character length of number 
8cb0			;-   ld     a, 10 
8cb0			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8cb0			;    push   af 
8cb0			;    inc    b 
8cb0			;    ld     a, h 
8cb0			;    or     l 
8cb0			;    jr     nz, - 
8cb0			; 
8cb0			;; Retrieve digits from stack 
8cb0			;-   pop    af 
8cb0			;    or     $30 
8cb0			;    ld     (de), a 
8cb0			;    inc    de 
8cb0			;    djnz   - 
8cb0			; 
8cb0			;; Terminate string with NULL 
8cb0			;    xor    a 
8cb0			;    ld     (de), a 
8cb0			; 
8cb0			;    pop    bc 
8cb0			;    pop    de 
8cb0			;    ret 
8cb0			 
8cb0			;Comments 
8cb0			; 
8cb0			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8cb0			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8cb0			;    Note that the output string will not be fixed-width. 
8cb0			; 
8cb0			;Example Usage 
8cb0			; 
8cb0			;    ld    hl, -1004 
8cb0			;    ld    de, OP1 
8cb0			;    call  DispA 
8cb0			;    ld    hl, OP1 
8cb0			;    syscall  PutS 
8cb0			 
8cb0			 
8cb0			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8cb0			 
8cb0			 
8cb0			;Converts an ASCII string to an unsigned 16-bit integer 
8cb0			;Quits when it reaches a non-decimal digit 
8cb0			 
8cb0			string_to_uint16: 
8cb0			atoui_16: 
8cb0			;Input: 
8cb0			;     DE points to the string 
8cb0			;Outputs: 
8cb0			;     HL is the result 
8cb0			;     A is the 8-bit value of the number 
8cb0			;     DE points to the byte after the number 
8cb0			;Destroys: 
8cb0			;     BC 
8cb0			;       if the string is non-empty, BC is HL/10 
8cb0			;Size:  24 bytes 
8cb0			;Speed: 42+d(104+{0,9}) 
8cb0			;       d is the number of digits in the number 
8cb0			;       max is 640 cycles for a 5 digit number 
8cb0			;Assuming no leading zeros: 
8cb0			;1 digit:  146cc 
8cb0			;2 digit:  250cc 
8cb0			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8cb0			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8cb0			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8cb0			;avg: 544.81158447265625cc (544+13297/16384) 
8cb0			;=============================================================== 
8cb0 21 00 00		  ld hl,0 
8cb3			.u16a: 
8cb3 1a			  ld a,(de) 
8cb4 d6 30		  sub 30h 
8cb6 fe 0a		  cp 10 
8cb8 d0			  ret nc 
8cb9 13			  inc de 
8cba 44			  ld b,h 
8cbb 4d			  ld c,l 
8cbc 29			  add hl,hl 
8cbd 29			  add hl,hl 
8cbe 09			  add hl,bc 
8cbf 29			  add hl,hl 
8cc0 85			  add a,l 
8cc1 6f			  ld l,a 
8cc2 30 ef		  jr nc,.u16a 
8cc4 24			  inc h 
8cc5 c3 b3 8c		  jp .u16a 
8cc8			 
8cc8			 
8cc8			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8cc8			 
8cc8			;written by Zeda 
8cc8			;Converts a 16-bit unsigned integer to an ASCII string. 
8cc8			 
8cc8			uitoa_16: 
8cc8			;Input: 
8cc8			;   DE is the number to convert 
8cc8			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8cc8			;Output: 
8cc8			;   HL points to the null-terminated ASCII string 
8cc8			;      NOTE: This isn't necessarily the same as the input HL. 
8cc8 d5			  push de 
8cc9 c5			  push bc 
8cca f5			  push af 
8ccb eb			  ex de,hl 
8ccc			 
8ccc 01 f0 d8		  ld bc,-10000 
8ccf 3e 2f		  ld a,'0'-1 
8cd1 3c			  inc a 
8cd2 09			  add hl,bc  
8cd3 38 fc		   jr c,$-2 
8cd5 12			  ld (de),a 
8cd6 13			  inc de 
8cd7			 
8cd7 01 e8 03		  ld bc,1000 
8cda 3e 3a		  ld a,'9'+1 
8cdc 3d			  dec a  
8cdd 09			  add hl,bc  
8cde 30 fc		   jr nc,$-2 
8ce0 12			  ld (de),a 
8ce1 13			  inc de 
8ce2			 
8ce2 01 9c ff		  ld bc,-100 
8ce5 3e 2f		  ld a,'0'-1 
8ce7 3c			  inc a  
8ce8 09			  add hl,bc  
8ce9 38 fc		   jr c,$-2 
8ceb 12			  ld (de),a 
8cec 13			  inc de 
8ced			 
8ced 7d			  ld a,l 
8cee 26 3a		  ld h,'9'+1 
8cf0 25			  dec h  
8cf1 c6 0a		  add a,10  
8cf3 30 fb		   jr nc,$-3 
8cf5 c6 30		  add a,'0' 
8cf7 eb			  ex de,hl 
8cf8 72			  ld (hl),d 
8cf9 23			  inc hl 
8cfa 77			  ld (hl),a 
8cfb 23			  inc hl 
8cfc 36 00		  ld (hl),0 
8cfe			 
8cfe			;Now strip the leading zeros 
8cfe 0e fa		  ld c,-6 
8d00 09			  add hl,bc 
8d01 3e 30		  ld a,'0' 
8d03 23			  inc hl  
8d04 be			  cp (hl)  
8d05 28 fc		  jr z,$-2 
8d07			 
8d07			;Make sure that the string is non-empty! 
8d07 7e			  ld a,(hl) 
8d08 b7			  or a 
8d09 20 01		  jr nz,.atoub 
8d0b 2b			  dec hl 
8d0c			.atoub: 
8d0c			 
8d0c f1			  pop af 
8d0d c1			  pop bc 
8d0e d1			  pop de 
8d0f c9			  ret 
8d10			 
8d10			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
8d10			 
8d10			toUpper: 
8d10			;A is the char. 
8d10			;If A is a lowercase letter, this sets it to the matching uppercase 
8d10			;18cc or 30cc or 41cc 
8d10			;avg: 26.75cc 
8d10 fe 61		  cp 'a' 
8d12 d8			  ret c 
8d13 fe 7b		  cp 'z'+1 
8d15 d0			  ret nc 
8d16 d6 20		  sub 'a'-'A' 
8d18 c9			  ret 
8d19			 
8d19			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
8d19			 
8d19			; String Length 
8d19			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
8d19			 
8d19			; Get the length of the null-terminated string starting at $8000 hl 
8d19			;    LD     HL, $8000 
8d19			 
8d19			strlenz: 
8d19			 
8d19 af			    XOR    A               ; Zero is the value we are looking for. 
8d1a 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
8d1b 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
8d1c			                           ; 65, 536 bytes (the entire addressable memory space). 
8d1c ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8d1e			 
8d1e			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8d1e 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
8d1f 6f			    LD     L, A             ; number of bytes 
8d20 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8d22 2b			    DEC    HL              ; Compensate for null. 
8d23 c9				ret 
8d24			 
8d24			; Get the length of the A terminated string starting at $8000 hl 
8d24			;    LD     HL, $8000 
8d24			 
8d24			strlent: 
8d24			 
8d24			                  ; A is the value we are looking for. 
8d24 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
8d26 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
8d28			                           ; 65, 536 bytes (the entire addressable memory space). 
8d28 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8d2a			 
8d2a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8d2a 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
8d2c 2e 00		    LD     L, 0             ; number of bytes 
8d2e ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8d30 2b			    DEC    HL              ; Compensate for null. 
8d31 c9				ret 
8d32			 
8d32			 
8d32			;Comparing Strings 
8d32			 
8d32			;IN    HL     Address of string1. 
8d32			;      DE     Address of string2. 
8d32			 
8d32			; doc given but wrong??? 
8d32			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
8d32			;      carry  Set if string1 > string2, reset if string1 <= string2. 
8d32			; tested 
8d32			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
8d32			 
8d32			strcmp_old: 
8d32 e5			    PUSH   HL 
8d33 d5			    PUSH   DE 
8d34			 
8d34 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
8d35 be			    CP     (HL)            ; (want to minimize work). 
8d36 38 01		    JR     C, Str1IsBigger 
8d38 7e			    LD     A, (HL) 
8d39			 
8d39			Str1IsBigger: 
8d39 4f			    LD     C, A             ; Put length in BC 
8d3a 06 00		    LD     B, 0 
8d3c 13			    INC    DE              ; Increment pointers to meat of string. 
8d3d 23			    INC    HL 
8d3e			 
8d3e			CmpLoop: 
8d3e 1a			    LD     A, (DE)          ; Compare bytes. 
8d3f ed a1		    CPI 
8d41 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
8d43 13			    INC    DE              ; Update pointer. 
8d44 ea 3e 8d		    JP     PE, CmpLoop 
8d47			 
8d47 d1			    POP    DE 
8d48 e1			    POP    HL 
8d49 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
8d4a be			    CP     (HL) 
8d4b c9			    RET 
8d4c			 
8d4c			NoMatch: 
8d4c 2b			    DEC    HL 
8d4d be			    CP     (HL)            ; Compare again to affect carry. 
8d4e d1			    POP    DE 
8d4f e1			    POP    HL 
8d50 c9			    RET 
8d51			 
8d51			;; test strmp 
8d51			; 
8d51			;ld de, .str1 
8d51			;ld hl, .str2 
8d51			;call strcmp 
8d51			;jr z, .z1 
8d51			;;this 
8d51			;	if DEBUG_FORTH_WORDS 
8d51			;		DMARK "NZ1" 
8d51			;		CALLMONITOR 
8d51			;	endif 
8d51			;.z1: 
8d51			; 
8d51			;	if DEBUG_FORTH_WORDS 
8d51			;		DMARK "ZZ1" 
8d51			;		CALLMONITOR 
8d51			;	endif 
8d51			; 
8d51			;ld de, .str1 
8d51			;ld hl, .str1 
8d51			;call strcmp 
8d51			;jr z, .z2 
8d51			;;this 
8d51			;	if DEBUG_FORTH_WORDS 
8d51			;		DMARK "NZ2" 
8d51			;		CALLMONITOR 
8d51			;	endif 
8d51			;.z2: 
8d51			; 
8d51			;	if DEBUG_FORTH_WORDS 
8d51			;		DMARK "ZZ2" 
8d51			;		CALLMONITOR 
8d51			;	endif 
8d51			; 
8d51			;ld de, .str1 
8d51			;ld hl, .str2 
8d51			;call strcmp 
8d51			;jr c, .c1 
8d51			; 
8d51			;	if DEBUG_FORTH_WORDS 
8d51			;		DMARK "Nc1" 
8d51			;		CALLMONITOR 
8d51			;	endif 
8d51			;.c1: 
8d51			;;this 
8d51			;	if DEBUG_FORTH_WORDS 
8d51			;		DMARK "cc1" 
8d51			;		CALLMONITOR 
8d51			;	endif 
8d51			; 
8d51			;ld de, .str1 
8d51			;ld hl, .str1 
8d51			;call strcmp 
8d51			;jr c, .c2 
8d51			;;this 
8d51			;	if DEBUG_FORTH_WORDS 
8d51			;		DMARK "Nc2" 
8d51			;		CALLMONITOR 
8d51			;	endif 
8d51			;.c2: 
8d51			; 
8d51			;	if DEBUG_FORTH_WORDS 
8d51			;		DMARK "cc2" 
8d51			;		CALLMONITOR 
8d51			;	endif 
8d51			;	NEXTW 
8d51			;.str1:   db "string1",0 
8d51			;.str2:   db "string2",0 
8d51			 
8d51			; only care about direct match or not 
8d51			; hl and de strings 
8d51			; zero set if the same 
8d51			 
8d51			strcmp: 
8d51 1a				ld a, (de) 
8d52 be				cp (hl) 
8d53 28 02			jr z, .ssame 
8d55 b7				or a 
8d56 c9				ret 
8d57			 
8d57			.ssame:  
8d57 fe 00			cp 0 
8d59 c8				ret z 
8d5a			 
8d5a 23				inc hl 
8d5b 13				inc de 
8d5c 18 f3			jr strcmp 
8d5e				 
8d5e				 
8d5e			 
8d5e			 
8d5e			 
8d5e			 
8d5e			; eof 
8d5e			 
8d5e			 
8d5e			 
8d5e			 
8d5e			 
8d5e			 
# End of file firmware_strings.asm
8d5e			include "firmware_memory.asm"   ; malloc and free  
8d5e			 
8d5e			if DEBUG_FORTH_MALLOC_HIGH 
8d5e			.mallocsize: db "Wants malloc >256",0 
8d5e			.mallocasize: db "MALLOC gives >256",0 
8d5e			.malloczero: db "MALLOC gives zero",0 
8d5e			 
8d5e			malloc_guard_zerolen: 
8d5e				push hl 
8d5e				push de 
8d5e				push af 
8d5e			 
8d5e				ld de, 0 
8d5e			        call cmp16 
8d5e				jr nz, .lowalloz 
8d5e			 
8d5e				push hl 
8d5e				push de 
8d5e					ld hl, display_fb0 
8d5e					ld (display_fb_active), hl 
8d5e				call clear_display 
8d5e				ld a, 0 
8d5e				ld de, .malloczero 
8d5e				call str_at_display 
8d5e				call update_display 
8d5e				call delay1s 
8d5e				call delay1s 
8d5e				ld a, 0 
8d5e				ld (os_view_disable), a 
8d5e			 
8d5e				pop de 
8d5e				pop hl 
8d5e			 
8d5e				 
8d5e			 
8d5e				CALLMONITOR 
8d5e			.lowalloz: 
8d5e			 
8d5e			 
8d5e				pop af 
8d5e				pop de 
8d5e				pop hl 
8d5e			ret 
8d5e			 
8d5e			malloc_guard_entry: 
8d5e				push hl 
8d5e				push de 
8d5e				push af 
8d5e			 
8d5e			 	or a      ;clear carry flag 
8d5e				push hl 
8d5e				ld de, 255 
8d5e				sbc hl, de 
8d5e				jr c, .lowalloc 
8d5e			 
8d5e				push de 
8d5e					ld hl, display_fb0 
8d5e					ld (display_fb_active), hl 
8d5e				call clear_display 
8d5e				ld a, 0 
8d5e				ld de, .mallocsize 
8d5e				call str_at_display 
8d5e				call update_display 
8d5e				call delay1s 
8d5e				call delay1s 
8d5e				ld a, 0 
8d5e				ld (os_view_disable), a 
8d5e			 
8d5e				pop de 
8d5e				pop hl 
8d5e			 
8d5e				 
8d5e			 
8d5e				CALLMONITOR 
8d5e				jr .lowdone 
8d5e			.lowalloc: 
8d5e			 
8d5e			 
8d5e				pop hl 
8d5e			.lowdone:	pop af 
8d5e				pop de 
8d5e				pop hl 
8d5e			ret 
8d5e			 
8d5e			malloc_guard_exit: 
8d5e				push hl 
8d5e				push de 
8d5e				push af 
8d5e			 
8d5e			 	or a      ;clear carry flag 
8d5e				push hl 
8d5e				ld de, 255 
8d5e				sbc hl, de 
8d5e				jr c, .lowallocx 
8d5e			 
8d5e				push de 
8d5e					ld hl, display_fb0 
8d5e					ld (display_fb_active), hl 
8d5e				call clear_display 
8d5e				ld a, 0 
8d5e				ld de, .mallocasize 
8d5e				call str_at_display 
8d5e				call update_display 
8d5e				call delay1s 
8d5e				call delay1s 
8d5e				ld a, 0 
8d5e				ld (os_view_disable), a 
8d5e				pop de 
8d5e				pop hl 
8d5e			 
8d5e				CALLMONITOR 
8d5e				jr .lowdonex 
8d5e			.lowallocx: 
8d5e			 
8d5e				pop hl 
8d5e			.lowdonex:	pop af 
8d5e				pop de 
8d5e				pop hl 
8d5e			ret 
8d5e			endif 
8d5e			 
8d5e			if MALLOC_2 
8d5e			; Z80 Malloc and Free Functions 
8d5e			 
8d5e			; Malloc Function: 
8d5e			; Input: 
8d5e			;   HL: Size of block to allocate 
8d5e			; Output: 
8d5e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8d5e			 
8d5e			malloc: 
8d5e				 
8d5e			if DEBUG_FORTH_MALLOC_HIGH 
8d5e			call malloc_guard_entry 
8d5e			endif 
8d5e			 
8d5e			 
8d5e			 
8d5e			 
8d5e					if DEBUG_FORTH_MALLOC 
8d5e						DMARK "mal" 
8d5e						CALLMONITOR 
8d5e					endif 
8d5e			    push af            ; Save AF register 
8d5e			    ld a, l            ; Load low byte of size into A 
8d5e			    or h               ; Check if size is zero 
8d5e			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
8d5e			 
8d5e			    ; Allocate memory 
8d5e			    ld hl, (heap_start) ; Load start of heap into HL 
8d5e					if DEBUG_FORTH_MALLOC 
8d5e						DMARK "ma1" 
8d5e						CALLMONITOR 
8d5e					endif 
8d5e			    call malloc_internal ; Call internal malloc function 
8d5e			    pop af             ; Restore AF register 
8d5e			if DEBUG_FORTH_MALLOC_HIGH 
8d5e			call malloc_guard_exit 
8d5e			call malloc_guard_zerolen 
8d5e			endif 
8d5e			    ret                ; Return 
8d5e			 
8d5e			; Free Function: 
8d5e			; Input: 
8d5e			;   HL: Pointer to memory block to free 
8d5e			; Output: 
8d5e			;   None 
8d5e			 
8d5e			free: 
8d5e			    push af            ; Save AF register 
8d5e			    ld a, l            ; Load low byte of pointer into A 
8d5e			    or h               ; Check if pointer is NULL 
8d5e			    jp z, free_exit    ; If pointer is NULL, exit 
8d5e			 
8d5e			    ; Free memory 
8d5e			    ld hl, (heap_start) ; Load start of heap into HL 
8d5e			    call free_internal  ; Call internal free function 
8d5e			    pop af             ; Restore AF register 
8d5e			    ret                ; Return 
8d5e			 
8d5e			; Internal Malloc Function: 
8d5e			; Input: 
8d5e			;   HL: Size of block to allocate 
8d5e			; Output: 
8d5e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8d5e			 
8d5e			malloc_internal: 
8d5e			    ld bc, 2           ; Number of bytes to allocate for management overhead 
8d5e			    add hl, bc         ; Add management overhead to requested size 
8d5e			    ex de, hl          ; Save total size in DE, and keep it in HL 
8d5e					if DEBUG_FORTH_MALLOC 
8d5e						DMARK "ma2" 
8d5e						CALLMONITOR 
8d5e					endif 
8d5e			 
8d5e			    ; Search for free memory block 
8d5e			    ld de, (heap_end)  ; Load end of heap into DE 
8d5e			    ld bc, 0           ; Initialize counter 
8d5e			 
8d5e					if DEBUG_FORTH_MALLOC 
8d5e						DMARK "ma2" 
8d5e						CALLMONITOR 
8d5e					endif 
8d5e			malloc_search_loop: 
8d5e			    ; Check if current block is free 
8d5e			    ld a, (hl)         ; Load current block's status (free or used) 
8d5e			    cp 0               ; Compare with zero (free) 
8d5e			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
8d5e			 
8d5e			    ; Check if current block is large enough 
8d5e			    ld a, (hl+1)       ; Load high byte of block size 
8d5e			    cp l               ; Compare with low byte of requested size 
8d5e			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
8d5e			 
8d5e			    ld a, (hl+2)       ; Load low byte of block size 
8d5e			    cp h               ; Compare with high byte of requested size 
8d5e			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
8d5e			 
8d5e			    ; Mark block as used 
8d5e			    ld (hl), 0xFF      ; Set status byte to indicate used block 
8d5e			 
8d5e			    ; Calculate remaining space in block 
8d5e			    ld bc, 0           ; Clear BC 
8d5e			    add hl, bc         ; Increment HL to point to start of data block 
8d5e			    add hl, de         ; HL = HL + DE (total size) 
8d5e			    ld bc, 1           ; Number of bytes to allocate for management overhead 
8d5e			    add hl, bc         ; Add management overhead to start of data block 
8d5e			 
8d5e			    ; Save pointer to allocated block in HL 
8d5e			if DEBUG_FORTH_MALLOC_HIGH 
8d5e						DMARK "ma5" 
8d5e			call malloc_guard_exit 
8d5e			call malloc_guard_zerolen 
8d5e			endif 
8d5e			    ret 
8d5e			 
8d5e			malloc_skip_block_check: 
8d5e			    ; Move to the next block 
8d5e			    ld bc, 3           ; Size of management overhead 
8d5e			    add hl, bc         ; Move to the next block 
8d5e			    inc de             ; Increment counter 
8d5e			 
8d5e			    ; Check if we have reached the end of heap 
8d5e			    ld a, e            ; Load low byte of heap end address 
8d5e			    cp (hl)            ; Compare with low byte of current address 
8d5e			    jr nz, malloc_search_loop  ; If not equal, continue searching 
8d5e			    ld a, d            ; Load high byte of heap end address 
8d5e			    cp 0               ; Check if it's zero (end of memory) 
8d5e			    jr nz, malloc_search_loop  ; If not zero, continue searching 
8d5e			 
8d5e			    ; If we reached here, allocation failed 
8d5e			    xor a              ; Set result to NULL 
8d5e			if DEBUG_FORTH_MALLOC_HIGH 
8d5e						DMARK "ma6" 
8d5e			call malloc_guard_exit 
8d5e			call malloc_guard_zerolen 
8d5e			endif 
8d5e			    ret 
8d5e			malloc_exit: 
8d5e			if DEBUG_FORTH_MALLOC_HIGH 
8d5e						DMARK "ma7" 
8d5e			call malloc_guard_exit 
8d5e			call malloc_guard_zerolen 
8d5e			endif 
8d5e			    ret 
8d5e			 
8d5e			; Internal Free Function: 
8d5e			; Input: 
8d5e			;   HL: Pointer to memory block to free 
8d5e			; Output: 
8d5e			;   None 
8d5e			 
8d5e			free_internal: 
8d5e			    ld de, (heap_start) ; Load start of heap into DE 
8d5e			    ld bc, 0            ; Initialize counter 
8d5e			 
8d5e			free_search_loop: 
8d5e			    ; Check if current block contains the pointer 
8d5e			    ld a, l             ; Load low byte of pointer 
8d5e			    cp (hl+1)           ; Compare with high byte of current block's address 
8d5e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8d5e			    ld a, h             ; Load high byte of pointer 
8d5e			    cp (hl+2)           ; Compare with low byte of current block's address 
8d5e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8d5e			 
8d5e			    ; Mark block as free 
8d5e			    ld (hl), 0          ; Set status byte to indicate free block 
8d5e			    ret                 ; Return 
8d5e			 
8d5e			free_skip_block_check: 
8d5e			    ; Move to the next block 
8d5e			    ld bc, 3            ; Size of management overhead 
8d5e			    add hl, bc          ; Move to the next block 
8d5e			    inc de              ; Increment counter 
8d5e			 
8d5e			    ; Check if we have reached the end of heap 
8d5e			    ld a, e             ; Load low byte of heap end address 
8d5e			    cp (hl)             ; Compare with low byte of current address 
8d5e			    jr nz, free_search_loop  ; If not equal, continue searching 
8d5e			    ld a, d             ; Load high byte of heap end address 
8d5e			    cp 0                ; Check if it's zero (end of memory) 
8d5e			    jr nz, free_search_loop  ; If not zero, continue searching 
8d5e			 
8d5e			    ; If we reached here, pointer is not found in heap 
8d5e			    ret 
8d5e			 
8d5e			free_exit: 
8d5e			    ret                 ; Return 
8d5e			 
8d5e			; Define heap start and end addresses 
8d5e			;heap_start:    .dw 0xC000   ; Start of heap 
8d5e			;heap_end:      .dw 0xE000   ; End of heap 
8d5e			 
8d5e			endif 
8d5e			 
8d5e			 
8d5e			if MALLOC_1 
8d5e			 
8d5e			 
8d5e			 
8d5e			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
8d5e			 
8d5e			;moved to firmware.asm 
8d5e			;heap_start        .equ  0x9000      ; Starting address of heap 
8d5e			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
8d5e			 
8d5e			;      .org 0 
8d5e			;      jp    main 
8d5e			 
8d5e			 
8d5e			;      .org  0x100 
8d5e			;main: 
8d5e			;      ld    HL, 0x8100 
8d5e			;      ld    SP, HL 
8d5e			; 
8d5e			;      call  heap_init 
8d5e			; 
8d5e			;      ; Make some allocations 
8d5e			;      ld    HL, 12 
8d5e			;      call  malloc            ; Allocates 0x9004 
8d5e			; 
8d5e			;      ld    HL, 12 
8d5e			;      call  malloc            ; Allocates 0x9014 
8d5e			; 
8d5e			;      ld    HL, 12 
8d5e			;      call  malloc            ; Allocates 0x9024 
8d5e			; 
8d5e			;      ; Free some allocations 
8d5e			;      ld    HL, 0x9014 
8d5e			;      call  free 
8d5e			; 
8d5e			;      ld    HL, 0x9004 
8d5e			;      call  free 
8d5e			; 
8d5e			;      ld    HL, 0x9024 
8d5e			;      call  free 
8d5e			; 
8d5e			; 
8d5e			;      halt 
8d5e			 
8d5e			 
8d5e			;------------------------------------------------------------------------------ 
8d5e			;     heap_init                                                               : 
8d5e			;                                                                             : 
8d5e			; Description                                                                 : 
8d5e			;     Initialise the heap and make it ready for malloc and free operations.   : 
8d5e			;                                                                             : 
8d5e			;     The heap is maintained as a linked list, starting with an initial       : 
8d5e			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
8d5e			;     the first free block in the heap. Each block then points to the next    : 
8d5e			;     free block within the heap, and the free list ends at the first block   : 
8d5e			;     with a null pointer to the next free block.                             : 
8d5e			;                                                                             : 
8d5e			; Parameters                                                                  : 
8d5e			;     Inputs are compile-time only. Two defines which specify the starting    : 
8d5e			;     address of the heap and its size are required, along with a memory      : 
8d5e			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
8d5e			;     principally stores a pointer to the first free block in the heap.       : 
8d5e			;                                                                             : 
8d5e			; Returns                                                                     : 
8d5e			;     Nothing                                                                 : 
8d5e			;------------------------------------------------------------------------------ 
8d5e			heap_init: 
8d5e e5			      push  HL 
8d5f			 
8d5f			      ; Initialise free list struct 
8d5f 21 c3 c6		      ld    HL, heap_start 
8d62 22 be c6		      ld    (free_list), HL 
8d65 21 00 00		      ld    HL, 0 
8d68 22 c0 c6		      ld    (free_list+2), HL 
8d6b			 
8d6b			      ; Insert first free block at bottom of heap, consumes entire heap 
8d6b 21 65 e3		      ld    HL, heap_start+heap_size-4 
8d6e 22 c3 c6		      ld    (heap_start), HL        ; Next block (end of free list) 
8d71 21 a2 1c		      ld    HL, heap_size-4 
8d74 22 c5 c6		      ld    (heap_start+2), HL      ; Block size 
8d77			 
8d77			      ; Insert end of free list block at top of heap - two null words will 
8d77			      ; terminate the free list 
8d77 21 00 00		      ld    HL, 0 
8d7a 22 67 e3		      ld    (heap_start+heap_size-2), HL 
8d7d 22 65 e3		      ld    (heap_start+heap_size-4), HL 
8d80			 
8d80 e1			      pop   HL 
8d81			 
8d81 c9			      ret 
8d82			 
8d82			 
8d82			;------------------------------------------------------------------------------ 
8d82			;     malloc                                                                  : 
8d82			;                                                                             : 
8d82			; Description                                                                 : 
8d82			;     Allocates the wanted space from the heap and returns the address of the : 
8d82			;     first useable byte of the allocation.                                   : 
8d82			;                                                                             : 
8d82			;     Allocations can happen in one of two ways:                              : 
8d82			;                                                                             : 
8d82			;     1. A free block may be found which is the exact size wanted. In this    : 
8d82			;        case the block is removed from the free list and retuedn to the      : 
8d82			;        caller.                                                              : 
8d82			;     2. A free block may be found which is larger than the size wanted. In   : 
8d82			;        this case, the larger block is split into two. The first portion of  : 
8d82			;        this block will become the requested space by the malloc call and    : 
8d82			;        is returned to the caller. The second portion becomes a new free     : 
8d82			;        block, and the free list is adjusted to maintain continuity via this : 
8d82			;        newly created block.                                                 : 
8d82			;                                                                             : 
8d82			;     malloc does not set any initial value in the allocated space, the       : 
8d82			;     caller is required to do this as required.                              : 
8d82			;                                                                             : 
8d82			;     This implementation of malloc uses the stack exclusively, and is        : 
8d82			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
8d82			;     advisable to disable interrupts before calling malloc, and recommended  : 
8d82			;     to avoid the use of malloc inside ISRs in general.                      : 
8d82			;                                                                             : 
8d82			;     NOTE: heap_init must be called before malloc and free can be used.      : 
8d82			;                                                                             : 
8d82			; Parameters                                                                  : 
8d82			;     HL  Number of bytes wanted                                              : 
8d82			;                                                                             : 
8d82			; Returns                                                                     : 
8d82			;     HL  Address of the first useable byte of the allocation                 : 
8d82			;                                                                             : 
8d82			; Flags                                                                       : 
8d82			;     Z   Set if the allocation did not succeed, clear otherwise              : 
8d82			;                                                                             : 
8d82			; Stack frame                                                                 : 
8d82			;       |             |                                                       : 
8d82			;       +-------------+                                                       : 
8d82			;       |     BC      |                                                       : 
8d82			;       +-------------+                                                       : 
8d82			;       |     DE      |                                                       : 
8d82			;       +-------------+                                                       : 
8d82			;       |     IX      |                                                       : 
8d82			;       +-------------+                                                       : 
8d82			;       |  prev_free  |                                                       : 
8d82			;   +4  +-------------+                                                       : 
8d82			;       |  this_free  |                                                       : 
8d82			;   +2  +-------------+                                                       : 
8d82			;       |  next_free  |                                                       : 
8d82			;   +0  +-------------+                                                       : 
8d82			;       |             |                                                       : 
8d82			;                                                                             : 
8d82			;------------------------------------------------------------------------------ 
8d82			 
8d82			 
8d82			;malloc: 
8d82			; 
8d82			;	SAVESP ON 1 
8d82			; 
8d82			;	call malloc_code 
8d82			; 
8d82			;	CHECKSP ON 1 
8d82			;	ret 
8d82			 
8d82			 
8d82			malloc: 
8d82 c5			      push  BC 
8d83 d5			      push  DE 
8d84 dd e5		      push  IX 
8d86			if DEBUG_FORTH_MALLOC_HIGH 
8d86			call malloc_guard_entry 
8d86			endif 
8d86			 
8d86					if DEBUG_FORTH_MALLOC 
8d86						DMARK "mal" 
8d86						CALLMONITOR 
8d86					endif 
8d86 7c			      ld    A, H                    ; Exit if no space requested 
8d87 b5			      or    L 
8d88 ca 47 8e		      jp    Z, malloc_early_exit 
8d8b			 
8d8b			;inc hl 
8d8b			;inc hl 
8d8b			;inc hl 
8d8b			; 
8d8b			;inc hl 
8d8b			;inc hl 
8d8b			;inc hl 
8d8b			;inc hl 
8d8b			;inc hl 
8d8b			;inc hl 
8d8b			;inc hl 
8d8b			;inc hl 
8d8b			;inc hl 
8d8b			 
8d8b			 
8d8b			 
8d8b			 
8d8b					if DEBUG_FORTH_MALLOC 
8d8b						DMARK "maA" 
8d8b						CALLMONITOR 
8d8b					endif 
8d8b			      ; Set up stack frame 
8d8b eb			      ex    DE, HL 
8d8c 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
8d8f 39			      add   HL, SP 
8d90 f9			      ld    SP, HL 
8d91 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
8d95 dd 39		      add   IX, SP 
8d97			 
8d97			      ; Setup initial state 
8d97 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
8d9a 19			      add   HL, DE 
8d9b			 
8d9b 44			      ld    B, H                    ; Move want to BC 
8d9c 4d			      ld    C, L 
8d9d			 
8d9d 21 be c6		      ld    HL, free_list           ; Store prev_free ptr to stack 
8da0 dd 75 04		      ld    (IX+4), L 
8da3 dd 74 05		      ld    (IX+5), H 
8da6			 
8da6 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
8da7 23			      inc   HL 
8da8 56			      ld    D, (HL) 
8da9 dd 73 02		      ld    (IX+2), E 
8dac dd 72 03		      ld    (IX+3), D 
8daf eb			      ex    DE, HL                  ; this_free ptr into HL 
8db0			 
8db0					if DEBUG_FORTH_MALLOC 
8db0						DMARK "maB" 
8db0						CALLMONITOR 
8db0					endif 
8db0			      ; Loop through free block list to find some space 
8db0			malloc_find_space: 
8db0 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
8db1 23			      inc   HL 
8db2 56			      ld    D, (HL) 
8db3			 
8db3 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
8db4 b3			      or    E 
8db5 ca 41 8e		      jp    Z, malloc_no_space 
8db8			 
8db8 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
8dbb dd 72 01		      ld    (IX+1), D 
8dbe			 
8dbe			      ; Does this block have enough space to make the allocation? 
8dbe 23			      inc   HL                      ; Load free block size into DE 
8dbf 5e			      ld    E, (HL) 
8dc0 23			      inc   HL 
8dc1 56			      ld    D, (HL) 
8dc2			 
8dc2 eb			      ex    DE, HL                  ; Check size of block against want 
8dc3 b7			      or    A                       ; Ensure carry flag clear 
8dc4 ed 42		      sbc   HL, BC 
8dc6 e5			      push  HL                      ; Store the result for later (new block size) 
8dc7			 
8dc7 ca 16 8e		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
8dca 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
8dcc			 
8dcc			      ; this_free block is not big enough, setup ptrs to test next free block 
8dcc e1			      pop   HL                      ; Discard previous result 
8dcd			 
8dcd dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
8dd0 dd 66 03		      ld    H, (IX+3) 
8dd3 dd 75 04		      ld    (IX+4), L 
8dd6 dd 74 05		      ld    (IX+5), H 
8dd9			 
8dd9 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
8ddc dd 66 01		      ld    H, (IX+1) 
8ddf dd 75 02		      ld    (IX+2), L 
8de2 dd 74 03		      ld    (IX+3), H 
8de5			 
8de5					if DEBUG_FORTH_MALLOC 
8de5						DMARK "MA>" 
8de5						CALLMONITOR 
8de5					endif 
8de5 18 c9		      jr    malloc_find_space 
8de7			 
8de7			      ; split a bigger block into two - requested size and remaining size 
8de7			malloc_alloc_split: 
8de7					if DEBUG_FORTH_MALLOC 
8de7						DMARK "MAs" 
8de7						CALLMONITOR 
8de7					endif 
8de7 eb			      ex    DE, HL                  ; Calculate address of new free block 
8de8 2b			      dec   HL 
8de9 2b			      dec   HL 
8dea 2b			      dec   HL 
8deb 09			      add   HL, BC 
8dec			 
8dec			      ; Create a new block and point it at next_free 
8dec dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
8def dd 56 01		      ld    D, (IX+1) 
8df2			 
8df2 73			      ld    (HL), E                 ; Store next_free ptr into new block 
8df3 23			      inc   HL 
8df4 72			      ld    (HL), D 
8df5			 
8df5 d1			      pop   DE                      ; Store size of new block into new block 
8df6 23			      inc   HL 
8df7 73			      ld    (HL), E 
8df8 23			      inc   HL 
8df9 72			      ld    (HL), D 
8dfa			 
8dfa			      ; Update this_free ptr to point to new block 
8dfa 2b			      dec   HL 
8dfb 2b			      dec   HL 
8dfc 2b			      dec   HL 
8dfd			 
8dfd dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
8e00 dd 56 03		      ld    D, (IX+3) 
8e03			 
8e03 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
8e06 dd 74 03		      ld    (IX+3), H 
8e09			 
8e09			      ; Modify this_free block to be allocation 
8e09 eb			      ex    DE, HL 
8e0a af			      xor   A                       ; Null the next block ptr of allocated block 
8e0b 77			      ld    (HL), A 
8e0c 23			      inc   HL 
8e0d 77			      ld    (HL), A 
8e0e			 
8e0e 23			      inc   HL                      ; Store want size into allocated block 
8e0f 71			      ld    (HL), C 
8e10 23			      inc   HL 
8e11 70			      ld    (HL), B 
8e12 23			      inc   HL 
8e13 e5			      push  HL                      ; Address of allocation to return 
8e14			 
8e14 18 19		      jr    malloc_update_links 
8e16			 
8e16			malloc_alloc_fit: 
8e16 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
8e17			 
8e17					if DEBUG_FORTH_MALLOC 
8e17						DMARK "MAf" 
8e17						CALLMONITOR 
8e17					endif 
8e17			      ; Modify this_free block to be allocation 
8e17 eb			      ex    DE, HL 
8e18 2b			      dec   HL 
8e19 2b			      dec   HL 
8e1a 2b			      dec   HL 
8e1b			 
8e1b af			      xor   A                       ; Null the next block ptr of allocated block 
8e1c 77			      ld    (HL), A 
8e1d 23			      inc   HL 
8e1e 77			      ld    (HL), A 
8e1f			 
8e1f 23			      inc   HL                      ; Store address of allocation to return 
8e20 23			      inc   HL 
8e21 23			      inc   HL 
8e22 e5			      push  HL 
8e23			 
8e23			      ; Copy next_free ptr to this_free, remove allocated block from free list 
8e23 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
8e26 dd 66 01		      ld    H, (IX+1) 
8e29			 
8e29 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
8e2c dd 74 03		      ld    (IX+3), H 
8e2f			 
8e2f			 
8e2f			malloc_update_links: 
8e2f			      ; Update prev_free ptr to point to this_free 
8e2f dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
8e32 dd 66 05		      ld    H, (IX+5) 
8e35			 
8e35 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
8e38 dd 56 03		      ld    D, (IX+3) 
8e3b			 
8e3b 73			      ld    (HL), E                 ; this_free ptr into prev_free 
8e3c 23			      inc   HL 
8e3d 72			      ld    (HL), D 
8e3e			 
8e3e					if DEBUG_FORTH_MALLOC 
8e3e						DMARK "Mul" 
8e3e						CALLMONITOR 
8e3e					endif 
8e3e			      ; Clear the Z flag to indicate successful allocation 
8e3e 7a			      ld    A, D 
8e3f b3			      or    E 
8e40			 
8e40 d1			      pop   DE                      ; Address of allocation 
8e41					if DEBUG_FORTH_MALLOC 
8e41						DMARK "MAu" 
8e41						CALLMONITOR 
8e41					endif 
8e41			 
8e41			malloc_no_space: 
8e41 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
8e44 39			      add   HL, SP 
8e45 f9			      ld    SP, HL 
8e46			 
8e46 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
8e47					if DEBUG_FORTH_MALLOC 
8e47						DMARK "MAN" 
8e47						CALLMONITOR 
8e47					endif 
8e47			 
8e47			malloc_early_exit: 
8e47					if DEBUG_FORTH_MALLOC 
8e47						DMARK "MAx" 
8e47						CALLMONITOR 
8e47					endif 
8e47 dd e1		      pop   IX 
8e49 d1			      pop   DE 
8e4a c1			      pop   BC 
8e4b			 
8e4b			if DEBUG_FORTH_MALLOC_HIGH 
8e4b			call malloc_guard_exit 
8e4b			call malloc_guard_zerolen 
8e4b			endif 
8e4b c9			      ret 
8e4c			 
8e4c			 
8e4c			;------------------------------------------------------------------------------ 
8e4c			;     free                                                                    : 
8e4c			;                                                                             : 
8e4c			; Description                                                                 : 
8e4c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
8e4c			;     returned by malloc, otherwise the behaviour is undefined.               : 
8e4c			;                                                                             : 
8e4c			;     Where possible, directly adjacent free blocks will be merged together   : 
8e4c			;     into larger blocks to help ensure that the heap does not become         : 
8e4c			;     excessively fragmented.                                                 : 
8e4c			;                                                                             : 
8e4c			;     free does not clear or set any other value into the freed space, and    : 
8e4c			;     therefore its contents may be visible through subsequent malloc's. The  : 
8e4c			;     caller should clear the freed space as required.                        : 
8e4c			;                                                                             : 
8e4c			;     This implementation of free uses the stack exclusively, and is          : 
8e4c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
8e4c			;     advisable to disable interrupts before calling free, and recommended    : 
8e4c			;     to avoid the use of free inside ISRs in general.                        : 
8e4c			;                                                                             : 
8e4c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
8e4c			;                                                                             : 
8e4c			; Parameters                                                                  : 
8e4c			;     HL  Pointer to address of first byte of allocation to be freed          : 
8e4c			;                                                                             : 
8e4c			; Returns                                                                     : 
8e4c			;     Nothing                                                                 : 
8e4c			;                                                                             : 
8e4c			; Stack frame                                                                 : 
8e4c			;       |             |                                                       : 
8e4c			;       +-------------+                                                       : 
8e4c			;       |     BC      |                                                       : 
8e4c			;       +-------------+                                                       : 
8e4c			;       |     DE      |                                                       : 
8e4c			;       +-------------+                                                       : 
8e4c			;       |     IX      |                                                       : 
8e4c			;       +-------------+                                                       : 
8e4c			;       |  prev_free  |                                                       : 
8e4c			;   +2  +-------------+                                                       : 
8e4c			;       |  next_free  |                                                       : 
8e4c			;   +0  +-------------+                                                       : 
8e4c			;       |             |                                                       : 
8e4c			;                                                                             : 
8e4c			;------------------------------------------------------------------------------ 
8e4c			free: 
8e4c c5			      push  BC 
8e4d d5			      push  DE 
8e4e dd e5		      push  IX 
8e50			 
8e50 7c			      ld    A, H                    ; Exit if ptr is null 
8e51 b5			      or    L 
8e52 ca 16 8f		      jp    Z, free_early_exit 
8e55			 
8e55			      ; Set up stack frame 
8e55 eb			      ex    DE, HL 
8e56 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
8e59 39			      add   HL, SP 
8e5a f9			      ld    SP, HL 
8e5b dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
8e5f dd 39		      add   IX, SP 
8e61			 
8e61			      ; The address in HL points to the start of the useable allocated space, 
8e61			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
8e61			      ; address of the block itself. 
8e61 eb			      ex    DE, HL 
8e62 11 fc ff		      ld    DE, -4 
8e65 19			      add   HL, DE 
8e66			 
8e66			      ; An allocated block must have a null next block pointer in it 
8e66 7e			      ld    A, (HL) 
8e67 23			      inc   HL 
8e68 b6			      or    (HL) 
8e69 c2 11 8f		      jp    NZ, free_done 
8e6c			 
8e6c 2b			      dec   HL 
8e6d			 
8e6d 44			      ld    B, H                    ; Copy HL to BC 
8e6e 4d			      ld    C, L 
8e6f			 
8e6f			      ; Loop through the free list to find the first block with an address 
8e6f			      ; higher than the block being freed 
8e6f 21 be c6		      ld    HL, free_list 
8e72			 
8e72			free_find_higher_block: 
8e72 5e			      ld    E, (HL)                 ; Load next ptr from free block 
8e73 23			      inc   HL 
8e74 56			      ld    D, (HL) 
8e75 2b			      dec   HL 
8e76			 
8e76 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
8e79 dd 72 01		      ld    (IX+1), D 
8e7c dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
8e7f dd 74 03		      ld    (IX+3), H 
8e82			 
8e82 78			      ld    A, B                    ; Check if DE is greater than BC 
8e83 ba			      cp    D                       ; Compare MSB first 
8e84 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
8e86 30 04		      jr    NC, free_find_higher_block_skip 
8e88 79			      ld    A, C 
8e89 bb			      cp    E                       ; Then compare LSB 
8e8a 38 08		      jr    C, free_found_higher_block 
8e8c			 
8e8c			free_find_higher_block_skip: 
8e8c 7a			      ld    A, D                    ; Reached the end of the free list? 
8e8d b3			      or    E 
8e8e ca 11 8f		      jp    Z, free_done 
8e91			 
8e91 eb			      ex    DE, HL 
8e92			 
8e92 18 de		      jr    free_find_higher_block 
8e94			 
8e94			free_found_higher_block: 
8e94			      ; Insert freed block between prev and next free blocks 
8e94 71			      ld    (HL), C                 ; Point prev free block to freed block 
8e95 23			      inc   HL 
8e96 70			      ld    (HL), B 
8e97			 
8e97 60			      ld    H, B                    ; Point freed block at next free block 
8e98 69			      ld    L, C 
8e99 73			      ld    (HL), E 
8e9a 23			      inc   HL 
8e9b 72			      ld    (HL), D 
8e9c			 
8e9c			      ; Check if the freed block is adjacent to the next free block 
8e9c 23			      inc   HL                      ; Load size of freed block into HL 
8e9d 5e			      ld    E, (HL) 
8e9e 23			      inc   HL 
8e9f 56			      ld    D, (HL) 
8ea0 eb			      ex    DE, HL 
8ea1			 
8ea1 09			      add   HL, BC                  ; Add addr of freed block and its size 
8ea2			 
8ea2 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
8ea5 dd 56 01		      ld    D, (IX+1) 
8ea8			 
8ea8 b7			      or    A                       ; Clear the carry flag 
8ea9 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
8eab 20 22		      jr    NZ, free_check_adjacent_to_prev 
8ead			 
8ead			      ; Freed block is adjacent to next, merge into one bigger block 
8ead eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
8eae 5e			      ld    E, (HL) 
8eaf 23			      inc   HL 
8eb0 56			      ld    D, (HL) 
8eb1 e5			      push  HL                      ; Save ptr to next block for later 
8eb2			 
8eb2 60			      ld    H, B                    ; Store ptr from next block into freed block 
8eb3 69			      ld    L, C 
8eb4 73			      ld    (HL), E 
8eb5 23			      inc   HL 
8eb6 72			      ld    (HL), D 
8eb7			 
8eb7 e1			      pop   HL                      ; Restore ptr to next block 
8eb8 23			      inc   HL                      ; Load size of next block into DE 
8eb9 5e			      ld    E, (HL) 
8eba 23			      inc   HL 
8ebb 56			      ld    D, (HL) 
8ebc d5			      push  DE                      ; Save next block size for later 
8ebd			 
8ebd 60			      ld    H, B                    ; Load size of freed block into HL 
8ebe 69			      ld    L, C 
8ebf 23			      inc   HL 
8ec0 23			      inc   HL 
8ec1 5e			      ld    E, (HL) 
8ec2 23			      inc   HL 
8ec3 56			      ld    D, (HL) 
8ec4 eb			      ex    DE, HL 
8ec5			 
8ec5 d1			      pop   DE                      ; Restore size of next block 
8ec6 19			      add   HL, DE                  ; Add sizes of both blocks 
8ec7 eb			      ex    DE, HL 
8ec8			 
8ec8 60			      ld    H, B                    ; Store new bigger size into freed block 
8ec9 69			      ld    L, C 
8eca 23			      inc   HL 
8ecb 23			      inc   HL 
8ecc 73			      ld    (HL), E 
8ecd 23			      inc   HL 
8ece 72			      ld    (HL), D 
8ecf			 
8ecf			free_check_adjacent_to_prev: 
8ecf			      ; Check if the freed block is adjacent to the prev free block 
8ecf dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
8ed2 dd 66 03		      ld    H, (IX+3) 
8ed5			 
8ed5 23			      inc   HL                      ; Size of prev free block into DE 
8ed6 23			      inc   HL 
8ed7 5e			      ld    E, (HL) 
8ed8 23			      inc   HL 
8ed9 56			      ld    D, (HL) 
8eda 2b			      dec   HL 
8edb 2b			      dec   HL 
8edc 2b			      dec   HL 
8edd			 
8edd 19			      add   HL, DE                  ; Add prev block addr and size 
8ede			 
8ede b7			      or    A                       ; Clear the carry flag 
8edf ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
8ee1 20 2e		      jr    NZ, free_done 
8ee3			 
8ee3			      ; Freed block is adjacent to prev, merge into one bigger block 
8ee3 60			      ld    H, B                    ; Load next ptr from freed block into DE 
8ee4 69			      ld    L, C 
8ee5 5e			      ld    E, (HL) 
8ee6 23			      inc   HL 
8ee7 56			      ld    D, (HL) 
8ee8 e5			      push  HL                      ; Save freed block ptr for later 
8ee9			 
8ee9 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
8eec dd 66 03		      ld    H, (IX+3) 
8eef 73			      ld    (HL), E 
8ef0 23			      inc   HL 
8ef1 72			      ld    (HL), D 
8ef2			 
8ef2 e1			      pop   HL                      ; Restore freed block ptr 
8ef3 23			      inc   HL                      ; Load size of freed block into DE 
8ef4 5e			      ld    E, (HL) 
8ef5 23			      inc   HL 
8ef6 56			      ld    D, (HL) 
8ef7 d5			      push  DE                      ; Save freed block size for later 
8ef8			 
8ef8 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
8efb dd 66 03		      ld    H, (IX+3) 
8efe 23			      inc   HL 
8eff 23			      inc   HL 
8f00 5e			      ld    E, (HL) 
8f01 23			      inc   HL 
8f02 56			      ld    D, (HL) 
8f03			 
8f03 e1			      pop   HL                      ; Add sizes of both blocks 
8f04 19			      add   HL, DE 
8f05 eb			      ex    DE, HL 
8f06			 
8f06 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
8f09 dd 66 03		      ld    H, (IX+3) 
8f0c 23			      inc   HL 
8f0d 23			      inc   HL 
8f0e 73			      ld    (HL), E 
8f0f 23			      inc   HL 
8f10 72			      ld    (HL), D 
8f11			 
8f11			free_done: 
8f11 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
8f14 39			      add   HL, SP 
8f15 f9			      ld    SP, HL 
8f16			 
8f16			free_early_exit: 
8f16 dd e1		      pop   IX 
8f18 d1			      pop   DE 
8f19 c1			      pop   BC 
8f1a			 
8f1a c9			      ret 
8f1b			 
8f1b			; moved to firmware.asm 
8f1b			; 
8f1b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
8f1b			;                  .dw   0 
8f1b			 
8f1b			 
8f1b			endif 
8f1b			 
8f1b			 
8f1b			if MALLOC_3 
8f1b			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
8f1b			;heap_start        .equ  0x9000      ; Starting address of heap 
8f1b			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
8f1b			; 
8f1b			 ;     .org 0 
8f1b			  ;    jp    main 
8f1b			; 
8f1b			; 
8f1b			 ;     .org  0x100 
8f1b			;main: 
8f1b			 ;     ld    HL, 0x8100 
8f1b			  ;    ld    SP, HL 
8f1b			; 
8f1b			;      call  heap_init 
8f1b			 
8f1b			      ; Make some allocations 
8f1b			;      ld    HL, 12 
8f1b			;      call  malloc            ; Allocates 0x9004 
8f1b			; 
8f1b			 ;     ld    HL, 12 
8f1b			;      call  malloc            ; Allocates 0x9014 
8f1b			 
8f1b			;      ld    HL, 12 
8f1b			;      call  malloc            ; Allocates 0x9024 
8f1b			 
8f1b			      ; Free some allocations 
8f1b			;      ld    HL, 0x9014 
8f1b			;      call  free 
8f1b			 
8f1b			;      ld    HL, 0x9004 
8f1b			;      call  free 
8f1b			; 
8f1b			;      ld    HL, 0x9024 
8f1b			;      call  free 
8f1b			 
8f1b			 
8f1b			 ;     halt 
8f1b			 
8f1b			 
8f1b			;------------------------------------------------------------------------------ 
8f1b			;     heap_init                                                               : 
8f1b			;                                                                             : 
8f1b			; Description                                                                 : 
8f1b			;     Initialise the heap and make it ready for malloc and free operations.   : 
8f1b			;                                                                             : 
8f1b			;     The heap is maintained as a linked list, starting with an initial       : 
8f1b			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
8f1b			;     the first free block in the heap. Each block then points to the next    : 
8f1b			;     free block within the heap, and the free list ends at the first block   : 
8f1b			;     with a null pointer to the next free block.                             : 
8f1b			;                                                                             : 
8f1b			; Parameters                                                                  : 
8f1b			;     Inputs are compile-time only. Two defines which specify the starting    : 
8f1b			;     address of the heap and its size are required, along with a memory      : 
8f1b			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
8f1b			;     principally stores a pointer to the first free block in the heap.       : 
8f1b			;                                                                             : 
8f1b			; Returns                                                                     : 
8f1b			;     Nothing                                                                 : 
8f1b			;------------------------------------------------------------------------------ 
8f1b			heap_init: 
8f1b			      push  HL 
8f1b			 
8f1b			      ; Initialise free list struct 
8f1b			      ld    HL, heap_start 
8f1b			      ld    (free_list), HL 
8f1b			      ld    HL, 0 
8f1b			      ld    (free_list+2), HL 
8f1b			 
8f1b			      ; Insert first free block at bottom of heap, consumes entire heap 
8f1b			      ld    HL, heap_start+heap_size-4 
8f1b			      ld    (heap_start), HL        ; Next block (end of free list) 
8f1b			      ld    HL, heap_size-4 
8f1b			      ld    (heap_start+2), HL      ; Block size 
8f1b			 
8f1b			      ; Insert end of free list block at top of heap - two null words will 
8f1b			      ; terminate the free list 
8f1b			      ld    HL, 0 
8f1b			      ld    (heap_start+heap_size-2), HL 
8f1b			      ld    (heap_start+heap_size-4), HL 
8f1b			 
8f1b			      pop   HL 
8f1b			 
8f1b			      ret 
8f1b			 
8f1b			 
8f1b			;------------------------------------------------------------------------------ 
8f1b			;     malloc                                                                  : 
8f1b			;                                                                             : 
8f1b			; Description                                                                 : 
8f1b			;     Allocates the wanted space from the heap and returns the address of the : 
8f1b			;     first useable byte of the allocation.                                   : 
8f1b			;                                                                             : 
8f1b			;     Allocations can happen in one of two ways:                              : 
8f1b			;                                                                             : 
8f1b			;     1. A free block may be found which is the exact size wanted. In this    : 
8f1b			;        case the block is removed from the free list and retuedn to the      : 
8f1b			;        caller.                                                              : 
8f1b			;     2. A free block may be found which is larger than the size wanted. In   : 
8f1b			;        this case, the larger block is split into two. The first portion of  : 
8f1b			;        this block will become the requested space by the malloc call and    : 
8f1b			;        is returned to the caller. The second portion becomes a new free     : 
8f1b			;        block, and the free list is adjusted to maintain continuity via this : 
8f1b			;        newly created block.                                                 : 
8f1b			;                                                                             : 
8f1b			;     malloc does not set any initial value in the allocated space, the       : 
8f1b			;     caller is required to do this as required.                              : 
8f1b			;                                                                             : 
8f1b			;     This implementation of malloc uses the stack exclusively, and is        : 
8f1b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
8f1b			;     advisable to disable interrupts before calling malloc, and recommended  : 
8f1b			;     to avoid the use of malloc inside ISRs in general.                      : 
8f1b			;                                                                             : 
8f1b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
8f1b			;                                                                             : 
8f1b			; Parameters                                                                  : 
8f1b			;     HL  Number of bytes wanted                                              : 
8f1b			;                                                                             : 
8f1b			; Returns                                                                     : 
8f1b			;     HL  Address of the first useable byte of the allocation                 : 
8f1b			;                                                                             : 
8f1b			; Flags                                                                       : 
8f1b			;     Z   Set if the allocation did not succeed, clear otherwise              : 
8f1b			;                                                                             : 
8f1b			; Stack frame                                                                 : 
8f1b			;       |             |                                                       : 
8f1b			;       +-------------+                                                       : 
8f1b			;       |     BC      |                                                       : 
8f1b			;       +-------------+                                                       : 
8f1b			;       |     DE      |                                                       : 
8f1b			;       +-------------+                                                       : 
8f1b			;       |     IX      |                                                       : 
8f1b			;       +-------------+                                                       : 
8f1b			;       |  prev_free  |                                                       : 
8f1b			;   +4  +-------------+                                                       : 
8f1b			;       |  this_free  |                                                       : 
8f1b			;   +2  +-------------+                                                       : 
8f1b			;       |  next_free  |                                                       : 
8f1b			;   +0  +-------------+                                                       : 
8f1b			;       |             |                                                       : 
8f1b			;                                                                             : 
8f1b			;------------------------------------------------------------------------------ 
8f1b			malloc: 
8f1b			      push  BC 
8f1b			      push  DE 
8f1b			      push  IX 
8f1b			 
8f1b			      ld    A, H                    ; Exit if no space requested 
8f1b			      or    L 
8f1b			      jp    Z, malloc_early_exit 
8f1b			 
8f1b			      ; Set up stack frame 
8f1b			      ex    DE, HL 
8f1b			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
8f1b			      add   HL, SP 
8f1b			      ld    SP, HL 
8f1b			      ld    IX, 0                   ; Use IX as a frame pointer 
8f1b			      add   IX, SP 
8f1b			 
8f1b			      ; Setup initial state 
8f1b			      ld    HL, 4                   ; want must also include space used by block struct 
8f1b			      add   HL, DE 
8f1b			 
8f1b			      ld    B, H                    ; Move want to BC 
8f1b			      ld    C, L 
8f1b			 
8f1b			      ld    HL, free_list           ; Store prev_free ptr to stack 
8f1b			      ld    (IX+4), L 
8f1b			      ld    (IX+5), H 
8f1b			 
8f1b			      ld    E, (HL)                 ; Store this_free ptr to stack 
8f1b			      inc   HL 
8f1b			      ld    D, (HL) 
8f1b			      ld    (IX+2), E 
8f1b			      ld    (IX+3), D 
8f1b			      ex    DE, HL                  ; this_free ptr into HL 
8f1b			 
8f1b			      ; Loop through free block list to find some space 
8f1b			malloc_find_space: 
8f1b			      ld    E, (HL)                 ; Load next_free ptr into DE 
8f1b			      inc   HL 
8f1b			      ld    D, (HL) 
8f1b			 
8f1b			      ld    A, D                    ; Check for null next_free ptr - end of free list 
8f1b			      or    E 
8f1b			      jp    Z, malloc_no_space 
8f1b			 
8f1b			      ld    (IX+0), E               ; Store next_free ptr to stack 
8f1b			      ld    (IX+1), D 
8f1b			 
8f1b			      ; Does this block have enough space to make the allocation? 
8f1b			      inc   HL                      ; Load free block size into DE 
8f1b			      ld    E, (HL) 
8f1b			      inc   HL 
8f1b			      ld    D, (HL) 
8f1b			 
8f1b			      ex    DE, HL                  ; Check size of block against want 
8f1b			      or    A                       ; Ensure carry flag clear 
8f1b			      sbc   HL, BC 
8f1b			      push  HL                      ; Store the result for later (new block size) 
8f1b			 
8f1b			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
8f1b			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
8f1b			 
8f1b			      ; this_free block is not big enough, setup ptrs to test next free block 
8f1b			      pop   HL                      ; Discard previous result 
8f1b			 
8f1b			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
8f1b			      ld    H, (IX+3) 
8f1b			      ld    (IX+4), L 
8f1b			      ld    (IX+5), H 
8f1b			 
8f1b			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
8f1b			      ld    H, (IX+1) 
8f1b			      ld    (IX+2), L 
8f1b			      ld    (IX+3), H 
8f1b			 
8f1b			      jr    malloc_find_space 
8f1b			 
8f1b			      ; split a bigger block into two - requested size and remaining size 
8f1b			malloc_alloc_split: 
8f1b			      ex    DE, HL                  ; Calculate address of new free block 
8f1b			      dec   HL 
8f1b			      dec   HL 
8f1b			      dec   HL 
8f1b			      add   HL, BC 
8f1b			 
8f1b			      ; Create a new block and point it at next_free 
8f1b			      ld    E, (IX+0)               ; Load next_free ptr into DE 
8f1b			      ld    D, (IX+1) 
8f1b			 
8f1b			      ld    (HL), E                 ; Store next_free ptr into new block 
8f1b			      inc   HL 
8f1b			      ld    (HL), D 
8f1b			 
8f1b			      pop   DE                      ; Store size of new block into new block 
8f1b			      inc   HL 
8f1b			      ld    (HL), E 
8f1b			      inc   HL 
8f1b			      ld    (HL), D 
8f1b			 
8f1b			      ; Update this_free ptr to point to new block 
8f1b			      dec   HL 
8f1b			      dec   HL 
8f1b			      dec   HL 
8f1b			 
8f1b			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
8f1b			      ld    D, (IX+3) 
8f1b			 
8f1b			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
8f1b			      ld    (IX+3), H 
8f1b			 
8f1b			      ; Modify this_free block to be allocation 
8f1b			      ex    DE, HL 
8f1b			      xor   A                       ; Null the next block ptr of allocated block 
8f1b			      ld    (HL), A 
8f1b			      inc   HL 
8f1b			      ld    (HL), A 
8f1b			 
8f1b			      inc   HL                      ; Store want size into allocated block 
8f1b			      ld    (HL), C 
8f1b			      inc   HL 
8f1b			      ld    (HL), B 
8f1b			      inc   HL 
8f1b			      push  HL                      ; Address of allocation to return 
8f1b			 
8f1b			      jr    malloc_update_links 
8f1b			 
8f1b			malloc_alloc_fit: 
8f1b			      pop   HL                      ; Dont need new block size, want is exact fit 
8f1b			 
8f1b			      ; Modify this_free block to be allocation 
8f1b			      ex    DE, HL 
8f1b			      dec   HL 
8f1b			      dec   HL 
8f1b			      dec   HL 
8f1b			 
8f1b			      xor   A                       ; Null the next block ptr of allocated block 
8f1b			      ld    (HL), A 
8f1b			      inc   HL 
8f1b			      ld    (HL), A 
8f1b			 
8f1b			      inc   HL                      ; Store address of allocation to return 
8f1b			      inc   HL 
8f1b			      inc   HL 
8f1b			      push  HL 
8f1b			 
8f1b			      ; Copy next_free ptr to this_free, remove allocated block from free list 
8f1b			      ld    L, (IX+0)               ; next_free to HL 
8f1b			      ld    H, (IX+1) 
8f1b			 
8f1b			      ld    (IX+2), L               ; HL to this_free 
8f1b			      ld    (IX+3), H 
8f1b			 
8f1b			 
8f1b			malloc_update_links: 
8f1b			      ; Update prev_free ptr to point to this_free 
8f1b			      ld    L, (IX+4)               ; prev_free ptr to HL 
8f1b			      ld    H, (IX+5) 
8f1b			 
8f1b			      ld    E, (IX+2)               ; this_free ptr to DE 
8f1b			      ld    D, (IX+3) 
8f1b			 
8f1b			      ld    (HL), E                 ; this_free ptr into prev_free 
8f1b			      inc   HL 
8f1b			      ld    (HL), D 
8f1b			 
8f1b			      ; Clear the Z flag to indicate successful allocation 
8f1b			      ld    A, D 
8f1b			      or    E 
8f1b			 
8f1b			      pop   DE                      ; Address of allocation 
8f1b			 
8f1b			malloc_no_space: 
8f1b			      ld    HL, 6                   ; Clean up stack frame 
8f1b			      add   HL, SP 
8f1b			      ld    SP, HL 
8f1b			 
8f1b			      ex    DE, HL                  ; Alloc addr into HL for return 
8f1b			 
8f1b			malloc_early_exit: 
8f1b			      pop   IX 
8f1b			      pop   DE 
8f1b			      pop   BC 
8f1b			 
8f1b			      ret 
8f1b			 
8f1b			 
8f1b			;------------------------------------------------------------------------------ 
8f1b			;     free                                                                    : 
8f1b			;                                                                             : 
8f1b			; Description                                                                 : 
8f1b			;     Return the space pointed to by HL to the heap. HL must be an address as : 
8f1b			;     returned by malloc, otherwise the behaviour is undefined.               : 
8f1b			;                                                                             : 
8f1b			;     Where possible, directly adjacent free blocks will be merged together   : 
8f1b			;     into larger blocks to help ensure that the heap does not become         : 
8f1b			;     excessively fragmented.                                                 : 
8f1b			;                                                                             : 
8f1b			;     free does not clear or set any other value into the freed space, and    : 
8f1b			;     therefore its contents may be visible through subsequent malloc's. The  : 
8f1b			;     caller should clear the freed space as required.                        : 
8f1b			;                                                                             : 
8f1b			;     This implementation of free uses the stack exclusively, and is          : 
8f1b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
8f1b			;     advisable to disable interrupts before calling free, and recommended    : 
8f1b			;     to avoid the use of free inside ISRs in general.                        : 
8f1b			;                                                                             : 
8f1b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
8f1b			;                                                                             : 
8f1b			; Parameters                                                                  : 
8f1b			;     HL  Pointer to address of first byte of allocation to be freed          : 
8f1b			;                                                                             : 
8f1b			; Returns                                                                     : 
8f1b			;     Nothing                                                                 : 
8f1b			;                                                                             : 
8f1b			; Stack frame                                                                 : 
8f1b			;       |             |                                                       : 
8f1b			;       +-------------+                                                       : 
8f1b			;       |     BC      |                                                       : 
8f1b			;       +-------------+                                                       : 
8f1b			;       |     DE      |                                                       : 
8f1b			;       +-------------+                                                       : 
8f1b			;       |     IX      |                                                       : 
8f1b			;       +-------------+                                                       : 
8f1b			;       |  prev_free  |                                                       : 
8f1b			;   +2  +-------------+                                                       : 
8f1b			;       |  next_free  |                                                       : 
8f1b			;   +0  +-------------+                                                       : 
8f1b			;       |             |                                                       : 
8f1b			;                                                                             : 
8f1b			;------------------------------------------------------------------------------ 
8f1b			free: 
8f1b			      push  BC 
8f1b			      push  DE 
8f1b			      push  IX 
8f1b			 
8f1b			      ld    A, H                    ; Exit if ptr is null 
8f1b			      or    L 
8f1b			      jp    Z, free_early_exit 
8f1b			 
8f1b			      ; Set up stack frame 
8f1b			      ex    DE, HL 
8f1b			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
8f1b			      add   HL, SP 
8f1b			      ld    SP, HL 
8f1b			      ld    IX, 0                   ; Use IX as a frame pointer 
8f1b			      add   IX, SP 
8f1b			 
8f1b			      ; The address in HL points to the start of the useable allocated space, 
8f1b			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
8f1b			      ; address of the block itself. 
8f1b			      ex    DE, HL 
8f1b			      ld    DE, -4 
8f1b			      add   HL, DE 
8f1b			 
8f1b			      ; An allocated block must have a null next block pointer in it 
8f1b			      ld    A, (HL) 
8f1b			      inc   HL 
8f1b			      or    (HL) 
8f1b			      jp    NZ, free_done 
8f1b			 
8f1b			      dec   HL 
8f1b			 
8f1b			      ld    B, H                    ; Copy HL to BC 
8f1b			      ld    C, L 
8f1b			 
8f1b			      ; Loop through the free list to find the first block with an address 
8f1b			      ; higher than the block being freed 
8f1b			      ld    HL, free_list 
8f1b			 
8f1b			free_find_higher_block: 
8f1b			      ld    E, (HL)                 ; Load next ptr from free block 
8f1b			      inc   HL 
8f1b			      ld    D, (HL) 
8f1b			      dec   HL 
8f1b			 
8f1b			      ld    (IX+0), E               ; Save ptr to next free block 
8f1b			      ld    (IX+1), D 
8f1b			      ld    (IX+2), L               ; Save ptr to prev free block 
8f1b			      ld    (IX+3), H 
8f1b			 
8f1b			      ld    A, B                    ; Check if DE is greater than BC 
8f1b			      cp    D                       ; Compare MSB first 
8f1b			      jr    Z, $+4                  ; MSB the same, compare LSB 
8f1b			      jr    NC, free_find_higher_block_skip 
8f1b			      ld    A, C 
8f1b			      cp    E                       ; Then compare LSB 
8f1b			      jr    C, free_found_higher_block 
8f1b			 
8f1b			free_find_higher_block_skip: 
8f1b			      ld    A, D                    ; Reached the end of the free list? 
8f1b			      or    E 
8f1b			      jp    Z, free_done 
8f1b			 
8f1b			      ex    DE, HL 
8f1b			 
8f1b			      jr    free_find_higher_block 
8f1b			 
8f1b			free_found_higher_block: 
8f1b			      ; Insert freed block between prev and next free blocks 
8f1b			      ld    (HL), C                 ; Point prev free block to freed block 
8f1b			      inc   HL 
8f1b			      ld    (HL), B 
8f1b			 
8f1b			      ld    H, B                    ; Point freed block at next free block 
8f1b			      ld    L, C 
8f1b			      ld    (HL), E 
8f1b			      inc   HL 
8f1b			      ld    (HL), D 
8f1b			 
8f1b			      ; Check if the freed block is adjacent to the next free block 
8f1b			      inc   HL                      ; Load size of freed block into HL 
8f1b			      ld    E, (HL) 
8f1b			      inc   HL 
8f1b			      ld    D, (HL) 
8f1b			      ex    DE, HL 
8f1b			 
8f1b			      add   HL, BC                  ; Add addr of freed block and its size 
8f1b			 
8f1b			      ld    E, (IX+0)               ; Load addr of next free block into DE 
8f1b			      ld    D, (IX+1) 
8f1b			 
8f1b			      or    A                       ; Clear the carry flag 
8f1b			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
8f1b			      jr    NZ, free_check_adjacent_to_prev 
8f1b			 
8f1b			      ; Freed block is adjacent to next, merge into one bigger block 
8f1b			      ex    DE, HL                  ; Load next ptr from next block into DE 
8f1b			      ld    E, (HL) 
8f1b			      inc   HL 
8f1b			      ld    D, (HL) 
8f1b			      push  HL                      ; Save ptr to next block for later 
8f1b			 
8f1b			      ld    H, B                    ; Store ptr from next block into freed block 
8f1b			      ld    L, C 
8f1b			      ld    (HL), E 
8f1b			      inc   HL 
8f1b			      ld    (HL), D 
8f1b			 
8f1b			      pop   HL                      ; Restore ptr to next block 
8f1b			      inc   HL                      ; Load size of next block into DE 
8f1b			      ld    E, (HL) 
8f1b			      inc   HL 
8f1b			      ld    D, (HL) 
8f1b			      push  DE                      ; Save next block size for later 
8f1b			 
8f1b			      ld    H, B                    ; Load size of freed block into HL 
8f1b			      ld    L, C 
8f1b			      inc   HL 
8f1b			      inc   HL 
8f1b			      ld    E, (HL) 
8f1b			      inc   HL 
8f1b			      ld    D, (HL) 
8f1b			      ex    DE, HL 
8f1b			 
8f1b			      pop   DE                      ; Restore size of next block 
8f1b			      add   HL, DE                  ; Add sizes of both blocks 
8f1b			      ex    DE, HL 
8f1b			 
8f1b			      ld    H, B                    ; Store new bigger size into freed block 
8f1b			      ld    L, C 
8f1b			      inc   HL 
8f1b			      inc   HL 
8f1b			      ld    (HL), E 
8f1b			      inc   HL 
8f1b			      ld    (HL), D 
8f1b			 
8f1b			free_check_adjacent_to_prev: 
8f1b			      ; Check if the freed block is adjacent to the prev free block 
8f1b			      ld    L, (IX+2)               ; Prev free block ptr into HL 
8f1b			      ld    H, (IX+3) 
8f1b			 
8f1b			      inc   HL                      ; Size of prev free block into DE 
8f1b			      inc   HL 
8f1b			      ld    E, (HL) 
8f1b			      inc   HL 
8f1b			      ld    D, (HL) 
8f1b			      dec   HL 
8f1b			      dec   HL 
8f1b			      dec   HL 
8f1b			 
8f1b			      add   HL, DE                  ; Add prev block addr and size 
8f1b			 
8f1b			      or    A                       ; Clear the carry flag 
8f1b			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
8f1b			      jr    NZ, free_done 
8f1b			 
8f1b			      ; Freed block is adjacent to prev, merge into one bigger block 
8f1b			      ld    H, B                    ; Load next ptr from freed block into DE 
8f1b			      ld    L, C 
8f1b			      ld    E, (HL) 
8f1b			      inc   HL 
8f1b			      ld    D, (HL) 
8f1b			      push  HL                      ; Save freed block ptr for later 
8f1b			 
8f1b			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
8f1b			      ld    H, (IX+3) 
8f1b			      ld    (HL), E 
8f1b			      inc   HL 
8f1b			      ld    (HL), D 
8f1b			 
8f1b			      pop   HL                      ; Restore freed block ptr 
8f1b			      inc   HL                      ; Load size of freed block into DE 
8f1b			      ld    E, (HL) 
8f1b			      inc   HL 
8f1b			      ld    D, (HL) 
8f1b			      push  DE                      ; Save freed block size for later 
8f1b			 
8f1b			      ld    L, (IX+2)               ; Load size of prev block into DE 
8f1b			      ld    H, (IX+3) 
8f1b			      inc   HL 
8f1b			      inc   HL 
8f1b			      ld    E, (HL) 
8f1b			      inc   HL 
8f1b			      ld    D, (HL) 
8f1b			 
8f1b			      pop   HL                      ; Add sizes of both blocks 
8f1b			      add   HL, DE 
8f1b			      ex    DE, HL 
8f1b			 
8f1b			      ld    L, (IX+2)               ; Store new bigger size into prev block 
8f1b			      ld    H, (IX+3) 
8f1b			      inc   HL 
8f1b			      inc   HL 
8f1b			      ld    (HL), E 
8f1b			      inc   HL 
8f1b			      ld    (HL), D 
8f1b			 
8f1b			free_done: 
8f1b			      ld    HL, 4                   ; Clean up stack frame 
8f1b			      add   HL, SP 
8f1b			      ld    SP, HL 
8f1b			 
8f1b			free_early_exit: 
8f1b			      pop   IX 
8f1b			      pop   DE 
8f1b			      pop   BC 
8f1b			 
8f1b			      ret 
8f1b			 
8f1b			 
8f1b			;      .org 0x8000 
8f1b			; 
8f1b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
8f1b			 ;                 .dw   0 
8f1b			 
8f1b			endif 
8f1b			 
8f1b			 
8f1b			if MALLOC_4 
8f1b			 
8f1b			; My memory allocation code. Very very simple.... 
8f1b			; allocate space under 250 chars 
8f1b			 
8f1b			heap_init: 
8f1b				; init start of heap as zero 
8f1b				;  
8f1b			 
8f1b				ld hl, heap_start 
8f1b				ld a, 0 
8f1b				ld (hl), a      ; empty block 
8f1b				inc hl 
8f1b				ld a, 0 
8f1b				ld (hl), a      ; length of block 
8f1b				; write end of list 
8f1b				inc hl 
8f1b				ld a,(hl) 
8f1b				inc hl 
8f1b				ld a,(hl) 
8f1b				 
8f1b			 
8f1b				; init some malloc vars 
8f1b			 
8f1b				ld hl, 0 
8f1b				ld (free_list), hl       ; store last malloc location 
8f1b			 
8f1b				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
8f1b				ld a, 0 
8f1b				ld (hl), a 
8f1b			 
8f1b			 
8f1b				ld hl, heap_start 
8f1b				;  
8f1b				  
8f1b				ret 
8f1b			 
8f1b			 
8f1b			;    free block marker 
8f1b			;    requested size  
8f1b			;    pointer to next block 
8f1b			;    .... 
8f1b			;    next block marker 
8f1b			 
8f1b			 
8f1b			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
8f1b			; 
8f1b			 
8f1b			 
8f1b			malloc:  
8f1b				push de 
8f1b				push bc 
8f1b				push af 
8f1b			 
8f1b				; hl space required 
8f1b				 
8f1b				ld c, l    ; hold space   (TODO only a max of 255) 
8f1b			 
8f1b			;	inc c     ; TODO BUG need to fix memory leak on push str 
8f1b			;	inc c 
8f1b			;	inc c 
8f1b			;	inc c 
8f1b			;	inc c 
8f1b			;	inc c 
8f1b			;	inc c 
8f1b			 
8f1b			 
8f1b			 
8f1b				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
8f1b			 
8f1b				ld a, (free_list+3) 
8f1b				cp 0 
8f1b				jr z, .contheap 
8f1b			 
8f1b				ld hl, (free_list)     ; get last alloc 
8f1b					if DEBUG_FORTH_MALLOC_INT 
8f1b						DMARK "mrs" 
8f1b						CALLMONITOR 
8f1b					endif 
8f1b				jr .startalloc 
8f1b			 
8f1b			.contheap: 
8f1b				ld hl, heap_start 
8f1b			 
8f1b			.startalloc: 
8f1b			 
8f1b					if DEBUG_FORTH_MALLOC_INT 
8f1b						DMARK "mym" 
8f1b						CALLMONITOR 
8f1b					endif 
8f1b			.findblock: 
8f1b					if DEBUG_FORTH_MALLOC_INT 
8f1b						DMARK "mmf" 
8f1b						CALLMONITOR 
8f1b					endif 
8f1b			 
8f1b				ld a,(hl)  
8f1b				; if byte is zero then clear to use 
8f1b			 
8f1b				cp 0 
8f1b				jr z, .foundemptyblock 
8f1b			 
8f1b				; if byte is not clear 
8f1b				;     then byte is offset to next block 
8f1b			 
8f1b				inc hl 
8f1b				ld a, (hl) ; get size 
8f1b			.nextblock:	inc hl 
8f1b					ld e, (hl) 
8f1b					inc hl 
8f1b					ld d, (hl) 
8f1b					ex de, hl 
8f1b			;	inc hl  ; move past the store space 
8f1b			;	inc hl  ; move past zero index  
8f1b			 
8f1b				; TODO detect no more space 
8f1b			 
8f1b				push hl 
8f1b				ld de, heap_end 
8f1b				call cmp16 
8f1b				pop hl 
8f1b				jr nc, .nospace 
8f1b			 
8f1b				jr .findblock 
8f1b			 
8f1b			.nospace: ld hl, 0 
8f1b				jp .exit 
8f1b			 
8f1b			 
8f1b			.foundemptyblock:	 
8f1b					if DEBUG_FORTH_MALLOC_INT 
8f1b						DMARK "mme" 
8f1b						CALLMONITOR 
8f1b					endif 
8f1b			 
8f1b			; TODO has block enough space if reusing??? 
8f1b			 
8f1b				;  
8f1b			 
8f1b			; see if this block has been previously used 
8f1b				inc hl 
8f1b				ld a, (hl) 
8f1b				dec hl 
8f1b				cp 0 
8f1b				jr z, .newblock 
8f1b			 
8f1b					if DEBUG_FORTH_MALLOC_INT 
8f1b						DMARK "meR" 
8f1b						CALLMONITOR 
8f1b					endif 
8f1b			 
8f1b			; no reusing previously allocated block 
8f1b			 
8f1b			; is it smaller than previously used? 
8f1b				 
8f1b				inc hl    ; move to size 
8f1b				ld a, c 
8f1b				sub (hl)        ; we want c < (hl) 
8f1b				dec hl    ; move back to marker 
8f1b			        jr z, .findblock 
8f1b			 
8f1b				; update with the new size which should be lower 
8f1b			 
8f1b			        ;inc  hl   ; negate next move. move back to size  
8f1b			 
8f1b			.newblock: 
8f1b				; need to be at marker here 
8f1b			 
8f1b					if DEBUG_FORTH_MALLOC_INT 
8f1b						DMARK "meN" 
8f1b						CALLMONITOR 
8f1b					endif 
8f1b			 
8f1b			 
8f1b				ld a, c 
8f1b			 
8f1b				ld (free_list+3), a	 ; flag resume from last malloc  
8f1b				ld (free_list), hl    ; save out last location 
8f1b			 
8f1b			 
8f1b				;inc a     ; space for length byte 
8f1b				ld (hl), a     ; save block in use marker 
8f1b			 
8f1b				inc hl   ; move to space marker 
8f1b				ld (hl), a    ; save new space 
8f1b			 
8f1b				inc hl   ; move to start of allocated area 
8f1b				 
8f1b			;	push hl     ; save where we are - 1  
8f1b			 
8f1b			;	inc hl  ; move past zero index  
8f1b				; skip space to set down new marker 
8f1b			 
8f1b				; provide some extra space for now 
8f1b			 
8f1b				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
8f1b				inc a 
8f1b				inc a 
8f1b			 
8f1b				push hl   ; save where we are in the node block 
8f1b			 
8f1b				call addatohl 
8f1b			 
8f1b				; write linked list point 
8f1b			 
8f1b				pop de     ; get our node position 
8f1b				ex de, hl 
8f1b			 
8f1b				ld (hl), e 
8f1b				inc hl 
8f1b				ld (hl), d 
8f1b			 
8f1b				inc hl 
8f1b			 
8f1b				; now at start of allocated data so save pointer 
8f1b			 
8f1b				push hl 
8f1b			 
8f1b				; jump to position of next node and setup empty header in DE 
8f1b			 
8f1b				ex de, hl 
8f1b			 
8f1b			;	inc hl ; move past end of block 
8f1b			 
8f1b				ld a, 0 
8f1b				ld (hl), a   ; empty marker 
8f1b				inc hl 
8f1b				ld (hl), a   ; size 
8f1b				inc hl  
8f1b				ld (hl), a   ; ptr 
8f1b				inc hl 
8f1b				ld (hl), a   ; ptr 
8f1b			 
8f1b			 
8f1b				pop hl 
8f1b			 
8f1b					if DEBUG_FORTH_MALLOC_INT 
8f1b						DMARK "mmr" 
8f1b						CALLMONITOR 
8f1b					endif 
8f1b			 
8f1b			.exit: 
8f1b				pop af 
8f1b				pop bc 
8f1b				pop de  
8f1b				ret 
8f1b			 
8f1b			 
8f1b			 
8f1b			 
8f1b			free:  
8f1b				push hl 
8f1b				push af 
8f1b				; get address in hl 
8f1b			 
8f1b					if DEBUG_FORTH_MALLOC_INT 
8f1b						DMARK "fre" 
8f1b						CALLMONITOR 
8f1b					endif 
8f1b				; data is at hl - move to block count 
8f1b				dec hl 
8f1b				dec hl    ; get past pointer 
8f1b				dec hl 
8f1b			 
8f1b				ld a, (hl)    ; need this for a validation check 
8f1b			 
8f1b				dec hl    ; move to block marker 
8f1b			 
8f1b				; now check that the block count and block marker are the same  
8f1b			        ; this checks that we are on a malloc node and not random memory 
8f1b			        ; OK a faint chance this could be a problem but rare - famous last words! 
8f1b			 
8f1b				ld c, a 
8f1b				ld a, (hl)    
8f1b			 
8f1b				cp c 
8f1b				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
8f1b			 
8f1b				; yes good chance we are on a malloc node 
8f1b			 
8f1b				ld a, 0      
8f1b				ld (hl), a   ; mark as free 
8f1b			 
8f1b				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
8f1b			 
8f1b			.freeignore:  
8f1b			 
8f1b				pop af 
8f1b				pop hl 
8f1b			 
8f1b				ret 
8f1b			 
8f1b			 
8f1b			 
8f1b			endif 
8f1b			 
8f1b			; eof 
# End of file firmware_memory.asm
8f1b			  
8f1b			; device C  
8f1b			if SOUND_ENABLE  
8f1b				include "firmware_sound.asm"  
8f1b			endif  
8f1b			  
8f1b			include "firmware_diags.asm"  
8f1b			; Hardware diags menu 
8f1b			 
8f1b			 
8f1b .. 00		hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
8f3c .. 00		hd_menu2:   db "        2: Editor",0   
8f4e			;hd_menu2:   db "        2: Editor       6: BASIC",0   
8f4e .. 00		hd_menu3:   db "        3: Storage",0 
8f61 .. 00		hd_menu4:   db "0=quit  4: Debug",0 
8f72 .. 00		hd_don:     db "ON",0 
8f75 .. 00		hd_doff:     db "OFF",0 
8f79			 
8f79			 
8f79			 
8f79			hardware_diags:       
8f79			 
8f79			.diagmenu: 
8f79 cd 62 87			call clear_display 
8f7c 3e 00			ld a, display_row_1 
8f7e 11 1b 8f			ld de, hd_menu1 
8f81 cd 75 87			call str_at_display 
8f84			 
8f84 3e 28			ld a, display_row_2 
8f86 11 3c 8f			ld de, hd_menu2 
8f89 cd 75 87			call str_at_display 
8f8c			 
8f8c 3e 50			ld a, display_row_3 
8f8e 11 4e 8f			ld de, hd_menu3 
8f91 cd 75 87			call str_at_display 
8f94			 
8f94 3e 78			ld a,  display_row_4 
8f96 11 61 8f			ld de, hd_menu4 
8f99 cd 75 87			call str_at_display 
8f9c			 
8f9c				; display debug state 
8f9c			 
8f9c 11 72 8f			ld de, hd_don 
8f9f 3a 74 e3			ld a, (os_view_disable) 
8fa2 fe 00			cp 0 
8fa4 28 03			jr z, .distog 
8fa6 11 75 8f			ld de, hd_doff 
8fa9 3e 89		.distog: ld a, display_row_4+17 
8fab cd 75 87			call str_at_display 
8fae			 
8fae cd 85 87			call update_display 
8fb1			 
8fb1 cd 9f c6			call cin_wait 
8fb4			 
8fb4			 
8fb4			 
8fb4 fe 34			cp '4' 
8fb6 20 0f			jr nz, .diagn1 
8fb8			 
8fb8				; debug toggle 
8fb8			 
8fb8 3a 74 e3			ld a, (os_view_disable) 
8fbb 06 2a			ld b, '*' 
8fbd fe 00			cp 0 
8fbf 28 02			jr z, .debtog 
8fc1 06 00			ld b, 0 
8fc3			.debtog:	 
8fc3 78				ld a,b 
8fc4 32 74 e3			ld (os_view_disable),a 
8fc7			 
8fc7 fe 30		.diagn1: cp '0' 
8fc9 c8				 ret z 
8fca			 
8fca			;	cp '1' 
8fca			;       jp z, matrix	 
8fca			;   TODO keyboard matrix test 
8fca			 
8fca fe 32			cp '2' 
8fcc ca d3 8f			jp z, .diagedit 
8fcf			 
8fcf			;if ENABLE_BASIC 
8fcf			;	cp '6' 
8fcf			;	jp z, basic 
8fcf			;endif 
8fcf			  
8fcf c3 79 8f			jp .diagmenu 
8fd2			 
8fd2			 
8fd2 c9				ret 
8fd3			 
8fd3			; debug editor 
8fd3			 
8fd3			.diagedit: 
8fd3			 
8fd3 21 75 e3			ld hl, scratch 
8fd6			;	ld bc, 250 
8fd6			;	ldir 
8fd6				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
8fd6 3e 00			ld a, 0 
8fd8 77				ld (hl), a 
8fd9 23				inc hl 
8fda 77				ld (hl), a 
8fdb 23				inc hl 
8fdc 77				ld (hl), a 
8fdd			 
8fdd cd 62 87		        call clear_display 
8fe0 cd 85 87			call update_display 
8fe3 3e 01			ld a, 1 
8fe5 32 80 ee			ld (hardware_diag), a 
8fe8			.diloop: 
8fe8 3e 00			ld a, display_row_1 
8fea 0e 00			ld c, 0 
8fec 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
8fee 1e 28			ld e, 40 
8ff0			 
8ff0 21 75 e3			ld hl, scratch	 
8ff3 cd e8 88			call input_str 
8ff6			 
8ff6 3e 28			ld a, display_row_2 
8ff8 11 75 e3			ld de, scratch 
8ffb cd 75 87			call str_at_display 
8ffe cd 85 87			call update_display 
9001			 
9001 c3 e8 8f			jp .diloop 
9004			 
9004			 
9004			; pass word in hl 
9004			; a has display location 
9004			display_word_at: 
9004 f5				push af 
9005 e5				push hl 
9006 7c				ld a,h 
9007 21 7a e6			ld hl, os_word_scratch 
900a cd bc 8b			call hexout 
900d e1				pop hl 
900e 7d				ld a,l 
900f 21 7c e6			ld hl, os_word_scratch+2 
9012 cd bc 8b			call hexout 
9015 21 7e e6			ld hl, os_word_scratch+4 
9018 3e 00			ld a,0 
901a 77				ld (hl),a 
901b 11 7a e6			ld de,os_word_scratch 
901e f1				pop af 
901f cd 75 87				call str_at_display 
9022 c9				ret 
9023			 
9023			display_ptr_state: 
9023			 
9023				; to restore afterwards 
9023			 
9023 d5				push de 
9024 c5				push bc 
9025 e5				push hl 
9026 f5				push af 
9027			 
9027				; for use in here 
9027			 
9027			;	push bc 
9027			;	push de 
9027			;	push hl 
9027			;	push af 
9027			 
9027 cd 62 87			call clear_display 
902a			 
902a 11 fd 91			ld de, .ptrstate 
902d 3e 00			ld a, display_row_1 
902f cd 75 87			call str_at_display 
9032			 
9032				; display debug step 
9032			 
9032			 
9032 11 7a ee			ld de, debug_mark 
9035 3e 26			ld a, display_row_1+display_cols-2 
9037 cd 75 87			call str_at_display 
903a			 
903a				; display a 
903a 11 07 92			ld de, .ptrcliptr 
903d 3e 28			ld a, display_row_2 
903f cd 75 87			call str_at_display 
9042			 
9042 f1				pop af 
9043 2a 40 eb			ld hl,(cli_ptr) 
9046 3e 30			ld a, display_row_2+8 
9048 cd 04 90			call display_word_at 
904b			 
904b			 
904b				; display hl 
904b			 
904b			 
904b 11 0f 92			ld de, .ptrclioptr 
904e 3e 32			ld a, display_row_2+10 
9050 cd 75 87			call str_at_display 
9053			; 
9053			;	pop hl 
9053 3e 35			ld a, display_row_2+13 
9055 2a 3e eb			ld hl,(cli_origptr) 
9058 cd 04 90			call display_word_at 
905b			; 
905b			;	 
905b			;	; display de 
905b			 
905b			;	ld de, .regstatede 
905b			;	ld a, display_row_3 
905b			;	call str_at_display 
905b			 
905b			;	pop de 
905b			;	ld h,d 
905b			;	ld l, e 
905b			;	ld a, display_row_3+3 
905b			;	call display_word_at 
905b			 
905b			 
905b				; display bc 
905b			 
905b			;	ld de, .regstatebc 
905b			;	ld a, display_row_3+10 
905b			;	call str_at_display 
905b			 
905b			;	pop bc 
905b			;	ld h,b 
905b			;	ld l, c 
905b			;	ld a, display_row_3+13 
905b			;	call display_word_at 
905b			 
905b			 
905b				; display dsp 
905b			 
905b			;	ld de, .regstatedsp 
905b			;	ld a, display_row_4 
905b			;	call str_at_display 
905b			 
905b				 
905b			;	ld hl,(cli_data_sp) 
905b			;	ld a, display_row_4+4 
905b			;	call display_word_at 
905b			 
905b				; display rsp 
905b			 
905b 11 3e 92			ld de, .regstatersp 
905e 3e 82			ld a, display_row_4+10 
9060 cd 75 87			call str_at_display 
9063			 
9063				 
9063 2a 26 eb			ld hl,(cli_ret_sp) 
9066 3e 86			ld a, display_row_4+14 
9068 cd 04 90			call display_word_at 
906b			 
906b cd 85 87			call update_display 
906e			 
906e cd e6 86			call delay1s 
9071 cd e6 86			call delay1s 
9074 cd e6 86			call delay1s 
9077			 
9077			 
9077 cd 84 95			call next_page_prompt 
907a			 
907a				; restore  
907a			 
907a f1				pop af 
907b e1				pop hl 
907c c1				pop bc 
907d d1				pop de 
907e c9				ret 
907f			 
907f			break_point_state: 
907f f5				push af 
9080			 
9080				; see if disabled 
9080			 
9080 3a 74 e3			ld a, (os_view_disable) 
9083 fe 2a			cp '*' 
9085 20 02			jr nz, .bpsgo 
9087 f1				pop af 
9088 c9				ret 
9089			 
9089			.bpsgo: 
9089 f1				pop af 
908a f5				push af 
908b 22 70 e3			ld (os_view_hl), hl 
908e ed 53 6e e3		ld (os_view_de), de 
9092 ed 43 6c e3		ld (os_view_bc), bc 
9096 e5				push hl 
9097 6f				ld l, a 
9098 26 00			ld h, 0 
909a 22 72 e3			ld (os_view_af),hl 
909d			 
909d 21 c0 ed				ld hl, display_fb0 
90a0 22 db eb				ld (display_fb_active), hl 
90a3 e1				pop hl	 
90a4			 
90a4 3e 31			ld a, '1' 
90a6 fe 2a		.bps1:  cp '*' 
90a8 20 03			jr nz, .bps1b 
90aa 32 74 e3			ld (os_view_disable),a 
90ad fe 31		.bps1b:  cp '1' 
90af 20 14			jr nz, .bps2 
90b1			 
90b1				; display reg 
90b1			 
90b1				 
90b1			 
90b1 3a 72 e3			ld a, (os_view_af) 
90b4 2a 70 e3			ld hl, (os_view_hl) 
90b7 ed 5b 6e e3		ld de, (os_view_de) 
90bb ed 4b 6c e3		ld bc, (os_view_bc) 
90bf cd 59 91			call display_reg_state 
90c2 c3 45 91			jp .bpschk 
90c5			 
90c5 fe 32		.bps2:  cp '2' 
90c7 20 08			jr nz, .bps3 
90c9				 
90c9				; display hl 
90c9 2a 70 e3			ld hl, (os_view_hl) 
90cc cd 43 92			call display_dump_at_hl 
90cf			 
90cf 18 74			jr .bpschk 
90d1			 
90d1 fe 33		.bps3:  cp '3' 
90d3 20 08			jr nz, .bps4 
90d5			 
90d5			        ; display de 
90d5 2a 6e e3			ld hl, (os_view_de) 
90d8 cd 43 92			call display_dump_at_hl 
90db			 
90db 18 68			jr .bpschk 
90dd fe 34		.bps4:  cp '4' 
90df 20 08			jr nz, .bps5 
90e1			 
90e1			        ; display bc 
90e1 2a 6c e3			ld hl, (os_view_bc) 
90e4 cd 43 92			call display_dump_at_hl 
90e7			 
90e7 18 5c			jr .bpschk 
90e9 fe 35		.bps5:  cp '5' 
90eb 20 08		        jr nz, .bps7 
90ed			 
90ed				; display cur ptr 
90ed 2a 40 eb			ld hl, (cli_ptr) 
90f0 cd 43 92			call display_dump_at_hl 
90f3			 
90f3 18 50			jr .bpschk 
90f5 fe 36		.bps7:  cp '6' 
90f7 20 08			jr nz, .bps8b 
90f9				 
90f9				; display cur orig ptr 
90f9 2a 3e eb			ld hl, (cli_origptr) 
90fc cd 43 92			call display_dump_at_hl 
90ff 18 44			jr .bpschk 
9101 fe 37		.bps8b:  cp '7' 
9103 20 08			jr nz, .bps9 
9105				 
9105				; display dsp 
9105 2a 22 eb			ld hl, (cli_data_sp) 
9108 cd 43 92			call display_dump_at_hl 
910b			 
910b 18 38			jr .bpschk 
910d fe 39		.bps9:  cp '9' 
910f 20 05			jr nz, .bps8c 
9111				 
9111				; display SP 
9111			;	ld hl, sp 
9111 cd 43 92			call display_dump_at_hl 
9114			 
9114 18 2f			jr .bpschk 
9116 fe 38		.bps8c:  cp '8' 
9118 20 08			jr nz, .bps8d 
911a				 
911a				; display rsp 
911a 2a 26 eb			ld hl, (cli_ret_sp) 
911d cd 43 92			call display_dump_at_hl 
9120			 
9120 18 23			jr .bpschk 
9122 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
9124 20 05			jr nz, .bps8 
9126 cd 7a 93			call monitor 
9129			 
9129 18 1a			jr .bpschk 
912b fe 30		.bps8:  cp '0' 
912d 20 16			jr nz, .bpschk 
912f			 
912f 21 1f ed				ld hl, display_fb1 
9132 22 db eb				ld (display_fb_active), hl 
9135 cd 85 87				call update_display 
9138			 
9138				;ld a, (os_view_af) 
9138 2a 70 e3			ld hl, (os_view_hl) 
913b ed 5b 6e e3		ld de, (os_view_de) 
913f ed 4b 6c e3		ld bc, (os_view_bc) 
9143 f1				pop af 
9144 c9				ret 
9145			 
9145			.bpschk:   
9145 cd e6 86			call delay1s 
9148 3e 9f		ld a,display_row_4 + display_cols - 1 
914a 11 82 95		        ld de, endprg 
914d cd 75 87			call str_at_display 
9150 cd 85 87			call update_display 
9153 cd 9f c6			call cin_wait 
9156			 
9156 c3 a6 90			jp .bps1 
9159			 
9159			 
9159			display_reg_state: 
9159			 
9159				; to restore afterwards 
9159			 
9159 d5				push de 
915a c5				push bc 
915b e5				push hl 
915c f5				push af 
915d			 
915d				; for use in here 
915d			 
915d c5				push bc 
915e d5				push de 
915f e5				push hl 
9160 f5				push af 
9161			 
9161 cd 62 87			call clear_display 
9164			 
9164 11 19 92			ld de, .regstate 
9167 3e 00			ld a, display_row_1 
9169 cd 75 87			call str_at_display 
916c			 
916c				; display debug step 
916c			 
916c			 
916c 11 7a ee			ld de, debug_mark 
916f 3e 25			ld a, display_row_1+display_cols-3 
9171 cd 75 87			call str_at_display 
9174			 
9174				; display a 
9174 11 35 92			ld de, .regstatea 
9177 3e 28			ld a, display_row_2 
9179 cd 75 87			call str_at_display 
917c			 
917c e1				pop hl 
917d			;	ld h,0 
917d			;	ld l, a 
917d 3e 2b			ld a, display_row_2+3 
917f cd 04 90			call display_word_at 
9182			 
9182			 
9182				; display hl 
9182			 
9182			 
9182 11 29 92			ld de, .regstatehl 
9185 3e 32			ld a, display_row_2+10 
9187 cd 75 87			call str_at_display 
918a			 
918a e1				pop hl 
918b 3e 35			ld a, display_row_2+13 
918d cd 04 90			call display_word_at 
9190			 
9190				 
9190				; display de 
9190			 
9190 11 2d 92			ld de, .regstatede 
9193 3e 50			ld a, display_row_3 
9195 cd 75 87			call str_at_display 
9198			 
9198 e1				pop hl 
9199			;	ld h,d 
9199			;	ld l, e 
9199 3e 53			ld a, display_row_3+3 
919b cd 04 90			call display_word_at 
919e			 
919e			 
919e				; display bc 
919e			 
919e 11 31 92			ld de, .regstatebc 
91a1 3e 5a			ld a, display_row_3+10 
91a3 cd 75 87			call str_at_display 
91a6			 
91a6 e1				pop hl 
91a7			;	ld h,b 
91a7			;	ld l, c 
91a7 3e 5d			ld a, display_row_3+13 
91a9 cd 04 90			call display_word_at 
91ac			 
91ac			 
91ac				; display dsp 
91ac			 
91ac 11 39 92			ld de, .regstatedsp 
91af 3e 78			ld a, display_row_4 
91b1 cd 75 87			call str_at_display 
91b4			 
91b4				 
91b4 2a 22 eb			ld hl,(cli_data_sp) 
91b7 3e 7c			ld a, display_row_4+4 
91b9 cd 04 90			call display_word_at 
91bc			 
91bc				; display rsp 
91bc			 
91bc 11 3e 92			ld de, .regstatersp 
91bf 3e 82			ld a, display_row_4+10 
91c1 cd 75 87			call str_at_display 
91c4			 
91c4				 
91c4 2a 26 eb			ld hl,(cli_ret_sp) 
91c7 3e 86			ld a, display_row_4+14 
91c9 cd 04 90			call display_word_at 
91cc			 
91cc cd 85 87			call update_display 
91cf			 
91cf			;	call delay1s 
91cf			;	call delay1s 
91cf			;	call delay1s 
91cf			 
91cf			 
91cf			;	call next_page_prompt 
91cf			 
91cf				; restore  
91cf			 
91cf f1				pop af 
91d0 e1				pop hl 
91d1 c1				pop bc 
91d2 d1				pop de 
91d3 c9				ret 
91d4			 
91d4 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
91e8 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
91fd .. 00		.ptrstate:	db "Ptr State",0 
9207 .. 00		.ptrcliptr:     db "cli_ptr",0 
920f .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9219 .. 00		.regstate:	db "Reg State (1/0)",0 
9229 .. 00		.regstatehl:	db "HL:",0 
922d .. 00		.regstatede:	db "DE:",0 
9231 .. 00		.regstatebc:	db "BC:",0 
9235 .. 00		.regstatea:	db "A :",0 
9239 .. 00		.regstatedsp:	db "DSP:",0 
923e .. 00		.regstatersp:	db "RSP:",0 
9243			 
9243			display_dump_at_hl: 
9243 e5				push hl 
9244 d5				push de 
9245 c5				push bc 
9246 f5				push af 
9247			 
9247 22 98 e6			ld (os_cur_ptr),hl	 
924a cd 62 87			call clear_display 
924d cd 8c 94			call dumpcont 
9250			;	call delay1s 
9250			;	call next_page_prompt 
9250			 
9250			 
9250 f1				pop af 
9251 c1				pop bc 
9252 d1				pop de 
9253 e1				pop hl 
9254 c9				ret 
9255			 
9255			;if ENABLE_BASIC 
9255			;	include "nascombasic.asm" 
9255			;	basic: 
9255			;	include "forth/FORTH.ASM" 
9255			;endif 
9255			 
9255			; eof 
9255			 
9255			 
# End of file firmware_diags.asm
9255			  
9255			  
9255			  
9255			  
9255			; eof  
9255			  
# End of file firmware.asm
9255			 
9255			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9255			;if BASE_KEV  
9255			;baseram: equ 08000h 
9255			;endif 
9255			 
9255			;if BASE_SC114 
9255			;baseram:     equ    endofcode 
9255			;endif 
9255			 
9255			 
9255			; start system 
9255			 
9255			coldstart: 
9255				; set sp 
9255				; di/ei 
9255			 
9255 f3				di 
9256 31 00 f0			ld sp, tos 
9259			;	ei 
9259			 
9259			 
9259				; disable breakpoint by default 
9259			 
9259 3e 2a			ld a,'*' 
925b 32 74 e3			ld (os_view_disable),a 
925e			 
925e				; init hardware 
925e			 
925e				; init keyboard and screen hardware 
925e			 
925e cd 03 80			call hardware_init 
9261			 
9261			 
9261				; detect if any keys are held down to enable breakpoints at start up 
9261			 
9261 cd a5 c6			call cin  
9264 fe 00			cp 0 
9266 28 03			jr z, .nokeys 
9268			 
9268 cd 79 8f			call hardware_diags 
926b			 
926b			;	ld de, .bpen 
926b			;	ld a, display_row_4 
926b			;	call str_at_display 
926b			;	call update_display 
926b			; 
926b			;	ld a,0 
926b			;	ld (os_view_disable),a 
926b			; 
926b			;.bpwait: 
926b			;	call cin 
926b			;	cp 0 
926b			;	jr z, .bpwait 
926b			;	jr .nokeys 
926b			; 
926b			; 
926b			;.bpen:  db "Break points enabled!",0 
926b			 
926b			 
926b			 
926b			 
926b			 
926b			 
926b			.nokeys: 
926b			 
926b			 
926b				 
926b			 
926b			;jp  testkey 
926b			 
926b			;call storage_get_block_0 
926b			; 
926b			;ld hl, 0 
926b			;ld de, store_page 
926b			;call storage_read_block 
926b			 
926b				 
926b			;ld hl, 10 
926b			;ld de, store_page 
926b			;call storage_read_block 
926b			 
926b			 
926b			 
926b			 
926b			 
926b			;stop:	nop 
926b			;	jp stop 
926b			 
926b			 
926b			 
926b			main: 
926b cd 62 87			call clear_display 
926e cd 85 87			call update_display 
9271			 
9271			 
9271			 
9271			;	call testlcd 
9271			 
9271			 
9271			 
9271 cd b3 97			call forth_init 
9274			 
9274			 
9274			warmstart: 
9274 cd 89 97			call forth_warmstart 
9277			 
9277				; run startup word load 
9277			        ; TODO prevent this running at warmstart after crash  
9277			 
9277				if STARTUP_ENABLE 
9277 cd 39 c3				call forth_startup 
927a				endif 
927a			 
927a				; show free memory after boot 
927a 11 14 93			ld de, freeram 
927d 3e 00			ld a, display_row_1 
927f cd 75 87			call str_at_display 
9282			 
9282			; Or use heap_size word???? 
9282 21 69 e3			ld hl, heap_end 
9285 11 c3 c6			ld de, heap_start 
9288 ed 52			sbc hl, de 
928a e5				push hl 
928b 7c				ld a,h	         	 
928c 21 7a e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
928f cd bc 8b			call hexout 
9292 e1			   	pop hl 
9293			 
9293 7d				ld a,l 
9294 21 7c e6			ld hl, os_word_scratch+2 
9297 cd bc 8b			call hexout 
929a 21 7e e6			ld hl, os_word_scratch+4 
929d 3e 00			ld a, 0 
929f 77				ld (hl),a 
92a0 11 7a e6			ld de, os_word_scratch 
92a3 3e 0d			ld a, display_row_1 + 13 
92a5 cd 75 87			call str_at_display 
92a8 cd 85 87			call update_display 
92ab			 
92ab			 
92ab				;call demo 
92ab			 
92ab			 
92ab				; init scratch input area for cli commands 
92ab			 
92ab 21 9c e6			ld hl, os_cli_cmd 
92ae 3e 00			ld a,0 
92b0 77				ld (hl),a 
92b1 23				inc hl 
92b2 77				ld (hl),a 
92b3			 
92b3 3e 00			ld a,0 
92b5 32 9b e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
92b8			 
92b8 32 98 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
92bb 32 99 e6			ld (os_cur_ptr+1),a	 
92be			 
92be 32 7a e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
92c1 32 7b e6			ld (os_word_scratch+1),a	 
92c4				 
92c4			 
92c4				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
92c4 21 9c e6			ld hl, os_cli_cmd 
92c7			 
92c7 3e 00			ld a, 0		 ; init cli input 
92c9 77				ld (hl), a 
92ca 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
92cc			cli: 
92cc				; show cli prompt 
92cc				;push af 
92cc				;ld a, 0 
92cc				;ld de, prompt 
92cc				;call str_at_display 
92cc			 
92cc				;call update_display 
92cc				;pop af 
92cc				;inc a 
92cc				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
92cc 0e 00			ld c, 0 
92ce 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
92d0 1e 28			ld e, 40 
92d2			 
92d2 21 9c e6			ld hl, os_cli_cmd 
92d5			 
92d5				STACKFRAME OFF $fefe $9f9f 
92d5				if DEBUG_STACK_IMB 
92d5					if OFF 
92d5						exx 
92d5						ld de, $fefe 
92d5						ld a, d 
92d5						ld hl, curframe 
92d5						call hexout 
92d5						ld a, e 
92d5						ld hl, curframe+2 
92d5						call hexout 
92d5						ld hl, $fefe 
92d5						push hl 
92d5						ld hl, $9f9f 
92d5						push hl 
92d5						exx 
92d5					endif 
92d5				endif 
92d5			endm 
# End of macro STACKFRAME
92d5			 
92d5 cd e8 88			call input_str 
92d8			 
92d8				STACKFRAMECHK OFF $fefe $9f9f 
92d8				if DEBUG_STACK_IMB 
92d8					if OFF 
92d8						exx 
92d8						ld hl, $9f9f 
92d8						pop de   ; $9f9f 
92d8						call cmp16 
92d8						jr nz, .spnosame 
92d8						ld hl, $fefe 
92d8						pop de   ; $fefe 
92d8						call cmp16 
92d8						jr z, .spfrsame 
92d8						.spnosame: call showsperror 
92d8						.spfrsame: nop 
92d8						exx 
92d8					endif 
92d8				endif 
92d8			endm 
# End of macro STACKFRAMECHK
92d8			 
92d8				; copy input to last command 
92d8			 
92d8 21 9c e6			ld hl, os_cli_cmd 
92db 11 9b e7			ld de, os_last_cmd 
92de 01 ff 00			ld bc, 255 
92e1 ed b0			ldir 
92e3				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
92e3			;	call strcpy 
92e3			;	ld a, 0 
92e3			;	ld (hl), a 
92e3			;	inc hl 
92e3			;	ld (hl), a 
92e3			;	inc hl 
92e3			;	ld (hl), a 
92e3			 
92e3				; switch frame buffer to program  
92e3			 
92e3 21 1f ed				ld hl, display_fb1 
92e6 22 db eb				ld (display_fb_active), hl 
92e9			 
92e9			;	nop 
92e9				STACKFRAME ON $fbfe $8f9f 
92e9				if DEBUG_STACK_IMB 
92e9					if ON 
92e9						exx 
92e9						ld de, $fbfe 
92e9						ld a, d 
92e9						ld hl, curframe 
92e9						call hexout 
92e9						ld a, e 
92e9						ld hl, curframe+2 
92e9						call hexout 
92e9						ld hl, $fbfe 
92e9						push hl 
92e9						ld hl, $8f9f 
92e9						push hl 
92e9						exx 
92e9					endif 
92e9				endif 
92e9			endm 
# End of macro STACKFRAME
92e9				; first time into the parser so pass over the current scratch pad 
92e9 21 9c e6			ld hl,os_cli_cmd 
92ec				; tokenise the entered statement(s) in HL 
92ec cd 2c 98			call forthparse 
92ef			        ; exec forth statements in top of return stack 
92ef cd 6c 98			call forthexec 
92f2				;call forthexec_cleanup 
92f2			;	call parsenext 
92f2			 
92f2				STACKFRAMECHK ON $fbfe $8f9f 
92f2				if DEBUG_STACK_IMB 
92f2					if ON 
92f2						exx 
92f2						ld hl, $8f9f 
92f2						pop de   ; $8f9f 
92f2						call cmp16 
92f2						jr nz, .spnosame 
92f2						ld hl, $fbfe 
92f2						pop de   ; $fbfe 
92f2						call cmp16 
92f2						jr z, .spfrsame 
92f2						.spnosame: call showsperror 
92f2						.spfrsame: nop 
92f2						exx 
92f2					endif 
92f2				endif 
92f2			endm 
# End of macro STACKFRAMECHK
92f2				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
92f2			 
92f2 3e 78			ld a, display_row_4 
92f4 11 26 93			ld de, endprog 
92f7			 
92f7 cd 85 87			call update_display		 
92fa			 
92fa cd 84 95			call next_page_prompt 
92fd			 
92fd				; switch frame buffer to cli 
92fd			 
92fd 21 c0 ed				ld hl, display_fb0 
9300 22 db eb				ld (display_fb_active), hl 
9303			 
9303			 
9303 cd 62 87		        call clear_display 
9306 cd 85 87			call update_display		 
9309			 
9309 21 9c e6			ld hl, os_cli_cmd 
930c			 
930c 3e 00			ld a, 0		 ; init cli input 
930e 77				ld (hl), a 
930f			 
930f				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
930f			 
930f				; now on last line 
930f			 
930f				; TODO scroll screen up 
930f			 
930f				; TODO instead just clear screen and place at top of screen 
930f			 
930f			;	ld a, 0 
930f			;	ld (f_cursor_ptr),a 
930f			 
930f				;call clear_display 
930f				;call update_display 
930f			 
930f				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
930f 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9311 c3 cc 92			jp cli 
9314			 
9314 .. 00		freeram: db "Free bytes: $",0 
9322 ..			asc: db "1A2F" 
9326 .. 00		endprog: db "End prog...",0 
9332			 
9332			testenter2:   
9332 21 a7 e3			ld hl,scratch+50 
9335 22 98 e6			ld (os_cur_ptr),hl 
9338 c3 cc 92			jp cli 
933b			 
933b			testenter:  
933b			 
933b 21 22 93			ld hl,asc 
933e			;	ld a,(hl) 
933e			;	call nibble2val 
933e cd 12 8c			call get_byte 
9341			 
9341			 
9341			;	ld a,(hl) 
9341			;	call atohex 
9341			 
9341			;	call fourehexhl 
9341 32 a7 e3			ld (scratch+50),a 
9344			 
9344			 
9344			 
9344 21 24 93			ld hl,asc+2 
9347			;	ld a, (hl) 
9347			;	call nibble2val 
9347 cd 12 8c			call get_byte 
934a			 
934a			;	call fourehexhl 
934a 32 a9 e3			ld (scratch+52),a 
934d				 
934d 21 a7 e3			ld hl,scratch+50 
9350 22 98 e6			ld (os_cur_ptr),hl 
9353 c3 cc 92			jp cli 
9356			 
9356			enter:	 
9356 3a 79 e3			ld a,(scratch+4) 
9359 fe 00			cp 0 
935b 28 0c			jr z, .entercont 
935d				; no, not a null term line so has an address to work out.... 
935d			 
935d 21 77 e3			ld hl,scratch+2 
9360 cd 72 8c			call get_word_hl 
9363			 
9363 22 98 e6			ld (os_cur_ptr),hl	 
9366 c3 cc 92			jp cli 
9369			 
9369			 
9369			.entercont:  
9369			 
9369 21 77 e3			ld hl, scratch+2 
936c cd 12 8c			call get_byte 
936f			 
936f 2a 98 e6		   	ld hl,(os_cur_ptr) 
9372 77					ld (hl),a 
9373 23					inc hl 
9374 22 98 e6				ld (os_cur_ptr),hl 
9377				 
9377			; get byte  
9377			 
9377			 
9377 c3 cc 92			jp cli 
937a			 
937a			 
937a			; basic monitor support 
937a			 
937a			monitor: 
937a				;  
937a cd 62 87			call clear_display 
937d 3e 00			ld a, 0 
937f 11 c7 93			ld de, .monprompt 
9382 cd 75 87			call str_at_display 
9385 cd 85 87			call update_display 
9388			 
9388				; get a monitor command 
9388			 
9388 0e 00			ld c, 0     ; entry at top left 
938a 16 64			ld d, 100   ; max buffer size 
938c 1e 0f			ld e, 15    ; input scroll area 
938e 3e 00			ld a, 0     ; init string 
9390 21 73 e5			ld hl, os_input 
9393 77				ld (hl), a 
9394 23				inc hl 
9395 77				ld (hl), a 
9396 21 73 e5			ld hl, os_input 
9399 3e 01			ld a, 1     ; init string 
939b cd e8 88			call input_str 
939e			 
939e cd 62 87		        call clear_display 
93a1 cd 85 87			call update_display		 
93a4			 
93a4 3a 73 e5			ld a, (os_input) 
93a7 cd 10 8d			call toUpper 
93aa fe 48		        cp 'H' 
93ac 28 6f		        jr z, .monhelp 
93ae fe 44			cp 'D'		; dump 
93b0 ca 3e 94			jp z, .mondump	 
93b3 fe 43			cp 'C'		; dump 
93b5 ca 58 94			jp z, .moncdump	 
93b8 fe 4d			cp 'M'		; dump 
93ba ca c9 93			jp z, .moneditstart 
93bd fe 55			cp 'U'		; dump 
93bf 28 14			jr z, .monedit	 
93c1 fe 51			cp 'Q'		; dump 
93c3 c8				ret z	 
93c4			 
93c4			 
93c4				; TODO "S" to access symbol by name and not need the address 
93c4				; TODO "F" to find a string in memory 
93c4			 
93c4 c3 7a 93			jp monitor 
93c7			 
93c7 .. 00		.monprompt: db ">", 0 
93c9			 
93c9			.moneditstart: 
93c9				; get starting address 
93c9			 
93c9 21 75 e5			ld hl,os_input+2 
93cc cd 72 8c			call get_word_hl 
93cf			 
93cf 22 98 e6			ld (os_cur_ptr),hl	 
93d2			 
93d2 c3 7a 93			jp monitor 
93d5			 
93d5			.monedit: 
93d5				; get byte to load 
93d5			 
93d5 21 75 e5			ld hl,os_input+2 
93d8 cd 12 8c			call get_byte 
93db			 
93db				; get address to update 
93db 2a 98 e6			ld hl, (os_cur_ptr) 
93de			 
93de				; update byte 
93de			 
93de 77				ld (hl), a 
93df			 
93df				; move to next address and save it 
93df			 
93df 23				inc hl 
93e0 22 98 e6			ld (os_cur_ptr),hl	 
93e3			 
93e3 c3 7a 93			jp monitor 
93e6			 
93e6			 
93e6 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
93fa .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
9416 .. 00		.monhelptext3:  db "Q-Quit",0 
941d			        
941d			.monhelp: 
941d 3e 00			ld a, display_row_1 
941f 11 e6 93		        ld de, .monhelptext1 
9422			 
9422 cd 75 87			call str_at_display 
9425 3e 28			ld a, display_row_2 
9427 11 fa 93		        ld de, .monhelptext2 
942a					 
942a cd 75 87			call str_at_display 
942d 3e 50			ld a, display_row_3 
942f 11 16 94		        ld de, .monhelptext3 
9432					 
9432 cd 75 87			call str_at_display 
9435 cd 85 87			call update_display		 
9438			 
9438 cd 84 95			call next_page_prompt 
943b c3 7a 93			jp monitor 
943e			 
943e			.mondump:    
943e 21 75 e5			ld hl,os_input+2 
9441 cd 72 8c			call get_word_hl 
9444			 
9444 22 98 e6			ld (os_cur_ptr),hl	 
9447 cd 8c 94			call dumpcont 
944a 3e 78			ld a, display_row_4 
944c 11 26 93			ld de, endprog 
944f			 
944f cd 85 87			call update_display		 
9452			 
9452 cd 84 95			call next_page_prompt 
9455 c3 7a 93			jp monitor 
9458			.moncdump: 
9458 cd 8c 94			call dumpcont 
945b 3e 78			ld a, display_row_4 
945d 11 26 93			ld de, endprog 
9460			 
9460 cd 85 87			call update_display		 
9463			 
9463 cd 84 95			call next_page_prompt 
9466 c3 7a 93			jp monitor 
9469			 
9469			 
9469			; TODO symbol access  
9469			 
9469			.symbols:     ;; A list of symbols that can be called up  
9469 c0 ed			dw display_fb0 
946b .. 00			db "fb0",0  
946f 65 eb		     	dw store_page 
9471 .. 00			db "store_page",0 
947c			 
947c			 
947c			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
947c			 
947c 3a 76 e3			ld a,(scratch+1) 
947f fe 00			cp 0 
9481 28 09			jr z, dumpcont 
9483			 
9483				; no, not a null term line so has an address to work out.... 
9483			 
9483 21 77 e3			ld hl,scratch+2 
9486 cd 72 8c			call get_word_hl 
9489			 
9489 22 98 e6			ld (os_cur_ptr),hl	 
948c			 
948c			 
948c			 
948c			dumpcont: 
948c			 
948c				; dump bytes at ptr 
948c			 
948c			 
948c 3e 00			ld a, display_row_1 
948e 2a db eb			ld hl, (display_fb_active) 
9491 cd bb 88			call addatohl 
9494 cd bc 94			call .dumpbyterow 
9497			 
9497 3e 28			ld a, display_row_2 
9499 2a db eb			ld hl, (display_fb_active) 
949c cd bb 88			call addatohl 
949f cd bc 94			call .dumpbyterow 
94a2			 
94a2			 
94a2 3e 50			ld a, display_row_3 
94a4 2a db eb			ld hl, (display_fb_active) 
94a7 cd bb 88			call addatohl 
94aa cd bc 94			call .dumpbyterow 
94ad			 
94ad 3e 78			ld a, display_row_4 
94af 2a db eb			ld hl, (display_fb_active) 
94b2 cd bb 88			call addatohl 
94b5 cd bc 94			call .dumpbyterow 
94b8			 
94b8 cd 85 87			call update_display 
94bb			;		jp cli 
94bb c9				ret 
94bc			 
94bc			.dumpbyterow: 
94bc			 
94bc				;push af 
94bc			 
94bc e5				push hl 
94bd			 
94bd				; calc where to poke the ascii 
94bd			if display_cols == 20 
94bd				ld a, 16 
94bd			else 
94bd 3e 1f			ld a, 31 
94bf			endif 
94bf			 
94bf cd bb 88			call addatohl 
94c2 22 7a e6			ld (os_word_scratch),hl  		; save pos for later 
94c5			 
94c5			 
94c5			; display decoding address 
94c5 2a 98 e6		   	ld hl,(os_cur_ptr) 
94c8			 
94c8 7c				ld a,h 
94c9 e1				pop hl 
94ca e5				push hl 
94cb			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
94cb cd bc 8b			call hexout 
94ce 2a 98 e6		   	ld hl,(os_cur_ptr) 
94d1			 
94d1 7d				ld a,l 
94d2 e1				pop hl 
94d3 23				inc hl 
94d4 23				inc hl 
94d5 e5				push hl 
94d6			;	ld hl, os_word_scratch+2 
94d6 cd bc 8b			call hexout 
94d9 e1				pop hl 
94da 23				inc hl 
94db 23				inc hl 
94dc				;ld hl, os_word_scratch+4 
94dc 3e 3a			ld a, ':' 
94de 77				ld (hl),a 
94df 23				inc hl 
94e0				;ld a, 0 
94e0				;ld (hl),a 
94e0				;ld de, os_word_scratch 
94e0				;pop af 
94e0				;push af 
94e0			;		ld a, display_row_2 
94e0			;		call str_at_display 
94e0			;		call update_display 
94e0			 
94e0			 
94e0			;pop af 
94e0			;	add 5 
94e0			 
94e0			if display_cols == 20 
94e0				ld b, 4 
94e0			else 
94e0 06 08			ld b, 8 
94e2			endif	 
94e2			 
94e2			.dumpbyte: 
94e2 c5				push bc 
94e3 e5				push hl 
94e4			 
94e4			 
94e4 2a 98 e6		   	ld hl,(os_cur_ptr) 
94e7 7e					ld a,(hl) 
94e8			 
94e8					; poke the ascii to display 
94e8 2a 7a e6				ld hl,(os_word_scratch) 
94eb 77					ld (hl),a 
94ec 23					inc hl 
94ed 22 7a e6				ld (os_word_scratch),hl 
94f0			 
94f0					 
94f0			 
94f0			 
94f0 e1					pop hl 
94f1 e5					push hl 
94f2			 
94f2 cd bc 8b				call hexout 
94f5			 
94f5					 
94f5 2a 98 e6		   	ld hl,(os_cur_ptr) 
94f8 23				inc hl 
94f9 22 98 e6		   	ld (os_cur_ptr),hl 
94fc			 
94fc e1					pop hl 
94fd 23					inc hl 
94fe 23					inc hl 
94ff 23					inc hl 
9500			 
9500			 
9500			 
9500					;ld a,0 
9500					;ld (os_word_scratch+2),a 
9500					;pop af 
9500					;push af 
9500			 
9500					;ld de, os_word_scratch 
9500					;call str_at_display 
9500			;		call update_display 
9500			;		pop af 
9500 c1					pop bc 
9501 c6 03				add 3 
9503 10 dd			djnz .dumpbyte 
9505			 
9505				 
9505			 
9505 c9				ret 
9506			 
9506			jump:	 
9506			 
9506 21 77 e3			ld hl,scratch+2 
9509 cd 72 8c			call get_word_hl 
950c				;ld hl,(scratch+2) 
950c				;call fourehexhl 
950c			 
950c 22 98 e6			ld (os_cur_ptr),hl	 
950f			 
950f e9				jp (hl) 
9510			 
9510			 
9510			 
9510			; TODO implement a basic monitor mode to start with 
9510			 
9510			 
9510			 
9510			 
9510			 
9510			 
9510			 
9510			 
9510			 
9510			; testing and demo code during development 
9510			 
9510			 
9510 .. 00		str1: db "Enter some text...",0 
9523 .. 00		clear: db "                    ",0 
9538			 
9538			demo: 
9538			 
9538			 
9538			 
9538			;	call update_display 
9538			 
9538				; init scratch input area for testing 
9538 21 75 e3			ld hl, scratch	 
953b 3e 00			ld a,0 
953d 77				ld (hl),a 
953e			 
953e			 
953e 3e 28		            LD   A, display_row_2 
9540			;            CALL fLCD_Pos       ;Position cursor to location in A 
9540 11 10 95		            LD   DE, str1 
9543 cd 75 87			call str_at_display 
9546			 
9546			;            CALL fLCD_Str       ;Display string pointed to by DE 
9546			cloop:	 
9546 3e 50		            LD   A, display_row_3 
9548			;            CALL fLCD_Pos       ;Position cursor to location in A 
9548 11 23 95		            LD   DE, clear 
954b			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
954b cd 75 87				call str_at_display 
954e 3e 78			ld a, display_row_4 
9550 11 80 95			ld de, prompt 
9553			 
9553 cd 75 87				call str_at_display 
9556 cd 85 87			call update_display 
9559			 
9559 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
955b 16 0a			ld d, 10 
955d 21 75 e3			ld hl, scratch	 
9560 cd e8 88			call input_str 
9563			 
9563			;	call clear_display 
9563			;'	call update_display 
9563			 
9563 3e 00		            LD   A, display_row_1 
9565			;            CALL fLCD_Pos       ;Position cursor to location in A 
9565 11 23 95		            LD   DE, clear 
9568 cd 75 87				call str_at_display 
956b			;            CALL fLCD_Str       ;Display string pointed to by DE 
956b 3e 00		            LD   A, display_row_1 
956d			;            CALL fLCD_Pos       ;Position cursor to location in A 
956d 11 75 e3		            LD   DE, scratch 
9570			;            CALL fLCD_Str       ;Display string pointed to by DE 
9570 cd 75 87				call str_at_display 
9573 cd 85 87			call update_display 
9576			 
9576 3e 00				ld a,0 
9578 21 75 e3			ld hl, scratch 
957b 77				ld (hl),a 
957c			 
957c 00				nop 
957d c3 46 95			jp cloop 
9580			 
9580			 
9580			 
9580			; OS Prompt 
9580			 
9580 .. 00		prompt: db ">",0 
9582 .. 00		endprg: db "?",0 
9584			 
9584			 
9584			; handy next page prompt 
9584			next_page_prompt: 
9584 e5				push hl 
9585 d5				push de 
9586 f5				push af 
9587 c5				push bc 
9588			 
9588 3e 9f			ld a,display_row_4 + display_cols - 1 
958a 11 82 95		        ld de, endprg 
958d cd 75 87			call str_at_display 
9590 cd 85 87			call update_display 
9593 cd 9f c6			call cin_wait 
9596 c1				pop bc 
9597 f1				pop af 
9598 d1				pop de 
9599 e1				pop hl 
959a			 
959a			 
959a c9				ret 
959b			 
959b			 
959b			; forth parser 
959b			 
959b			; My forth kernel 
959b			include "forth_kernel.asm" 
959b			; 
959b			; kernel to the forth OS 
959b			 
959b			DS_TYPE_STR: equ 1     ; string type 
959b			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
959b			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
959b			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
959b			 
959b			FORTH_PARSEV1: equ 0 
959b			FORTH_PARSEV2: equ 0 
959b			FORTH_PARSEV3: equ 0 
959b			FORTH_PARSEV4: equ 0 
959b			FORTH_PARSEV5: equ 1 
959b			 
959b			;if FORTH_PARSEV5 
959b			;	FORTH_END_BUFFER: equ 0 
959b			;else 
959b			FORTH_END_BUFFER: equ 127 
959b			;endif 
959b			 
959b			FORTH_TRUE: equ 1 
959b			FORTH_FALSE: equ 0 
959b			 
959b			if FORTH_PARSEV4 
959b			include "forth_stackops.asm" 
959b			endif 
959b			 
959b			if FORTH_PARSEV5 
959b			include "forth_stackopsv5.asm" 
959b			 
959b			; Stack operations for v5 parser on wards 
959b			; * DATA stack 
959b			; * LOOP stack 
959b			; * RETURN stack 
959b			 
959b			 
959b			 
959b			FORTH_CHK_DSP_UNDER: macro 
959b				push hl 
959b				push de 
959b				ld hl,(cli_data_sp) 
959b				ld de, cli_data_stack 
959b				call cmp16 
959b				jp c, fault_dsp_under 
959b				pop de 
959b				pop hl 
959b				endm 
959b			 
959b			 
959b			FORTH_CHK_RSP_UNDER: macro 
959b				push hl 
959b				push de 
959b				ld hl,(cli_ret_sp) 
959b				ld de, cli_ret_stack 
959b				call cmp16 
959b				jp c, fault_rsp_under 
959b				pop de 
959b				pop hl 
959b				endm 
959b			 
959b			FORTH_CHK_LOOP_UNDER: macro 
959b				push hl 
959b				push de 
959b				ld hl,(cli_loop_sp) 
959b				ld de, cli_loop_stack 
959b				call cmp16 
959b				jp c, fault_loop_under 
959b				pop de 
959b				pop hl 
959b				endm 
959b			 
959b			FORTH_ERR_TOS_NOTSTR: macro 
959b				; TOSO might need more for checks when used 
959b				push af 
959b				ld a,(hl) 
959b				cp DS_TYPE_STR 
959b				jp nz, type_faultn   
959b				pop af 
959b				endm 
959b			 
959b			FORTH_ERR_TOS_NOTNUM: macro 
959b				push af 
959b				ld a,(hl) 
959b				cp DS_TYPE_INUM 
959b				jp nz, type_faultn   
959b				pop af 
959b				endm 
959b			 
959b			 
959b			; increase data stack pointer and save hl to it 
959b				 
959b			FORTH_DSP_NEXT: macro 
959b				call macro_forth_dsp_next 
959b				endm 
959b			 
959b			 
959b			macro_forth_dsp_next: 
959b				if DEBUG_FORTH_STACK_GUARD 
959b cd 03 c4				call check_stacks 
959e				endif 
959e e5				push hl 
959f d5				push de 
95a0 eb				ex de,hl 
95a1 2a 22 eb			ld hl,(cli_data_sp) 
95a4 23				inc hl 
95a5 23				inc hl 
95a6			 
95a6			; PARSEV5 
95a6 23				inc hl 
95a7 22 22 eb			ld (cli_data_sp),hl 
95aa 73				ld (hl), e 
95ab 23				inc hl 
95ac 72				ld (hl), d 
95ad d1				pop de 
95ae e1				pop hl 
95af				if DEBUG_FORTH_STACK_GUARD 
95af cd 03 c4				call check_stacks 
95b2				endif 
95b2 c9				ret 
95b3			 
95b3			 
95b3			; increase ret stack pointer and save hl to it 
95b3				 
95b3			FORTH_RSP_NEXT: macro 
95b3				call macro_forth_rsp_next 
95b3				endm 
95b3			 
95b3			macro_forth_rsp_next: 
95b3				if DEBUG_FORTH_STACK_GUARD 
95b3 cd 03 c4				call check_stacks 
95b6				endif 
95b6 e5				push hl 
95b7 d5				push de 
95b8 eb				ex de,hl 
95b9 2a 26 eb			ld hl,(cli_ret_sp) 
95bc 23				inc hl 
95bd 23				inc hl 
95be 22 26 eb			ld (cli_ret_sp),hl 
95c1 73				ld (hl), e 
95c2 23				inc hl 
95c3 72				ld (hl), d 
95c4 d1				pop de 
95c5 e1				pop hl 
95c6				if DEBUG_FORTH_STACK_GUARD 
95c6 cd 03 c4				call check_stacks 
95c9				endif 
95c9 c9				ret 
95ca			 
95ca			; get current ret stack pointer and save to hl  
95ca				 
95ca			FORTH_RSP_TOS: macro 
95ca				call macro_forth_rsp_tos 
95ca				endm 
95ca			 
95ca			macro_forth_rsp_tos: 
95ca				;push de 
95ca 2a 26 eb			ld hl,(cli_ret_sp) 
95cd cd 02 96			call loadhlptrtohl 
95d0				;ld e, (hl) 
95d0				;inc hl 
95d0				;ld d, (hl) 
95d0				;ex de, hl 
95d0					if DEBUG_FORTH_WORDS 
95d0			;			DMARK "RST" 
95d0						CALLMONITOR 
95d0					endif 
95d0				;pop de 
95d0 c9				ret 
95d1			 
95d1			; pop ret stack pointer 
95d1				 
95d1			FORTH_RSP_POP: macro 
95d1				call macro_forth_rsp_pop 
95d1				endm 
95d1			 
95d1			 
95d1			macro_forth_rsp_pop: 
95d1				if DEBUG_FORTH_STACK_GUARD 
95d1			;		DMARK "RPP" 
95d1 cd 03 c4				call check_stacks 
95d4					FORTH_CHK_RSP_UNDER 
95d4 e5				push hl 
95d5 d5				push de 
95d6 2a 26 eb			ld hl,(cli_ret_sp) 
95d9 11 e0 ea			ld de, cli_ret_stack 
95dc cd d9 88			call cmp16 
95df da 17 c5			jp c, fault_rsp_under 
95e2 d1				pop de 
95e3 e1				pop hl 
95e4				endm 
# End of macro FORTH_CHK_RSP_UNDER
95e4				endif 
95e4 e5				push hl 
95e5 2a 26 eb			ld hl,(cli_ret_sp) 
95e8			 
95e8			 
95e8				if FORTH_ENABLE_FREE 
95e8			 
95e8					; get pointer 
95e8			 
95e8					push de 
95e8					push hl 
95e8			 
95e8					ld e, (hl) 
95e8					inc hl 
95e8					ld d, (hl) 
95e8			 
95e8					ex de, hl 
95e8					call free 
95e8			 
95e8					pop hl 
95e8					pop de 
95e8			 
95e8			 
95e8				endif 
95e8			 
95e8			 
95e8 2b				dec hl 
95e9 2b				dec hl 
95ea 22 26 eb			ld (cli_ret_sp), hl 
95ed				; do stack underflow checks 
95ed e1				pop hl 
95ee				if DEBUG_FORTH_STACK_GUARD 
95ee cd 03 c4				call check_stacks 
95f1					FORTH_CHK_RSP_UNDER 
95f1 e5				push hl 
95f2 d5				push de 
95f3 2a 26 eb			ld hl,(cli_ret_sp) 
95f6 11 e0 ea			ld de, cli_ret_stack 
95f9 cd d9 88			call cmp16 
95fc da 17 c5			jp c, fault_rsp_under 
95ff d1				pop de 
9600 e1				pop hl 
9601				endm 
# End of macro FORTH_CHK_RSP_UNDER
9601				endif 
9601 c9				ret 
9602			 
9602			 
9602			 
9602			; routine to load word pointed to by hl into hl 
9602			 
9602			loadhlptrtohl: 
9602			 
9602 d5				push de 
9603 5e				ld e, (hl) 
9604 23				inc hl 
9605 56				ld d, (hl) 
9606 eb				ex de, hl 
9607 d1				pop de 
9608			 
9608 c9				ret 
9609			 
9609			 
9609			 
9609			 
9609			 
9609			; push a number held in HL onto the data stack 
9609			; entry point for pushing a value when already in hl used in function above 
9609			 
9609			forth_push_numhl: 
9609			 
9609 e5				push hl    ; save value to push 
960a			 
960a			if DEBUG_FORTH_PUSH 
960a				; see if disabled 
960a			 
960a			 
960a				push af 
960a				ld a, (os_view_disable) 
960a				cp '*' 
960a				jr z, .pskip2 
960a				push hl 
960a			push hl 
960a				call clear_display 
960a			pop hl 
960a				ld a,h 
960a				ld hl, os_word_scratch 
960a				call hexout 
960a				pop hl 
960a				ld a,l 
960a				ld hl, os_word_scratch+2 
960a				call hexout 
960a			 
960a				ld hl, os_word_scratch+4 
960a				ld a,0 
960a				ld (hl),a 
960a				ld de,os_word_scratch 
960a					ld a, display_row_2 
960a					call str_at_display 
960a				ld de, .push_num 
960a				ld a, display_row_1 
960a			 
960a					call str_at_display 
960a			 
960a			 
960a				call update_display 
960a				call delay1s 
960a				call delay1s 
960a			.pskip2:  
960a			 
960a				pop af 
960a			endif	 
960a			 
960a			 
960a				FORTH_DSP_NEXT 
960a cd 9b 95			call macro_forth_dsp_next 
960d				endm 
# End of macro FORTH_DSP_NEXT
960d			 
960d 2a 22 eb			ld hl, (cli_data_sp) 
9610			 
9610				; save item type 
9610 3e 02			ld a,  DS_TYPE_INUM 
9612 77				ld (hl), a 
9613 23				inc hl 
9614			 
9614				; get word off stack 
9614 d1				pop de 
9615 7b				ld a,e 
9616 77				ld (hl), a 
9617 23				inc hl 
9618 7a				ld a,d 
9619 77				ld (hl), a 
961a			 
961a			if DEBUG_FORTH_PUSH 
961a				dec hl 
961a				dec hl 
961a				dec hl 
961a						DMARK "PH5" 
961a				CALLMONITOR 
961a			endif	 
961a			 
961a c9				ret 
961b			 
961b			 
961b			; Push a string to stack pointed to by hl 
961b			 
961b			forth_push_str: 
961b			 
961b			if DEBUG_FORTH_PUSH 
961b						DMARK "PSQ" 
961b				CALLMONITOR 
961b			endif	 
961b			    
961b e5				push hl 
961c e5				push hl 
961d			 
961d 3e 00			ld a, 0   ; find end of string 
961f cd 24 8d			call strlent       
9622			if DEBUG_FORTH_PUSH 
9622						DMARK "PQ2" 
9622				CALLMONITOR 
9622			endif	 
9622 eb				ex de, hl 
9623 e1				pop hl   ; get ptr to start of string 
9624			if DEBUG_FORTH_PUSH 
9624						DMARK "PQ3" 
9624				CALLMONITOR 
9624			endif	 
9624 19				add hl,de 
9625			if DEBUG_FORTH_PUSH 
9625						DMARK "PQE" 
9625				CALLMONITOR 
9625			endif	 
9625			 
9625 2b				dec hl    ; see if there is an optional trailing double quote 
9626 7e				ld a,(hl) 
9627 fe 22			cp '"' 
9629 20 03			jr nz, .strnoq 
962b 3e 00			ld a, 0      ; get rid of double quote 
962d 77				ld (hl), a 
962e 23			.strnoq: inc hl 
962f			 
962f 3e 00			ld a, 0 
9631 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9632			 
9632 13				inc de ; add one for the type string 
9633 13				inc de ; add one for null term??? 
9634			 
9634				; tos is get string pointer again 
9634				; de contains space to allocate 
9634				 
9634 d5				push de 
9635			 
9635 eb				ex de, hl 
9636			 
9636				;push af 
9636			 
9636			if DEBUG_FORTH_PUSH 
9636						DMARK "PHm" 
9636				CALLMONITOR 
9636			endif	 
9636 cd 82 8d			call malloc	; on ret hl now contains allocated memory 
9639				if DEBUG_FORTH_MALLOC_GUARD 
9639 cc 82 b3				call z,malloc_error 
963c				endif 
963c			 
963c				 
963c c1				pop bc    ; get length 
963d d1				pop de   ;  get string start    
963e			 
963e				; hl has destination from malloc 
963e			 
963e eb				ex de, hl    ; prep for ldir 
963f			 
963f e5				push hl   ; save malloc area for DSP later 
9640			 
9640			if DEBUG_FORTH_PUSH 
9640						DMARK "PHc" 
9640				CALLMONITOR 
9640			endif	 
9640			 
9640			 
9640 ed b0			ldir 
9642			 
9642			 
9642				; push malloc to data stack     macro?????  
9642			 
9642				FORTH_DSP_NEXT 
9642 cd 9b 95			call macro_forth_dsp_next 
9645				endm 
# End of macro FORTH_DSP_NEXT
9645			 
9645				; save value and type 
9645			 
9645 2a 22 eb			ld hl, (cli_data_sp) 
9648			 
9648				; save item type 
9648 3e 01			ld a,  DS_TYPE_STR 
964a 77				ld (hl), a 
964b 23				inc hl 
964c			 
964c				; get malloc word off stack 
964c d1				pop de 
964d 73				ld (hl), e 
964e 23				inc hl 
964f 72				ld (hl), d 
9650			 
9650			 
9650			 
9650			if DEBUG_FORTH_PUSH 
9650				ld hl, (cli_data_sp) 
9650						DMARK "PHS" 
9650				CALLMONITOR 
9650			;	ex de,hl 
9650			endif	 
9650				; in case of spaces, skip the ptr past the copied string 
9650				;pop af 
9650				;ld (cli_origptr),hl 
9650			 
9650 c9				ret 
9651			 
9651			 
9651			 
9651			; TODO ascii push input onto stack given hl to start of input 
9651			 
9651			; identify type 
9651			; if starts with a " then a string 
9651			; otherwise it is a number 
9651			;  
9651			; if a string 
9651			;     scan for ending " to get length of string to malloc for + 1 
9651			;     malloc 
9651			;     put pointer to string on stack first byte flags as string 
9651			; 
9651			; else a number 
9651			;    look for number format identifier 
9651			;    $xx hex 
9651			;    %xxxxx bin 
9651			;    xxxxx decimal 
9651			;    convert number to 16bit word.  
9651			;    malloc word + 1 with flag to identiy as num 
9651			;    put pointer to number on stack 
9651			;   
9651			;  
9651			  
9651			forth_apush: 
9651				; kernel push 
9651			 
9651			if DEBUG_FORTH_PUSH 
9651						DMARK "PSH" 
9651				CALLMONITOR 
9651			endif	 
9651				; identify input type 
9651			 
9651 7e				ld a,(hl) 
9652 fe 22			cp '"' 
9654 28 0a			jr z, .fapstr 
9656 fe 24			cp '$' 
9658 ca 80 96			jp z, .faphex 
965b fe 25			cp '%' 
965d ca 68 96			jp z, .fapbin 
9660			;	cp 'b' 
9660			;	jp z, .fabin 
9660				; else decimal 
9660			 
9660				; TODO do decimal conversion 
9660				; decimal is stored as a 16bit word 
9660			 
9660				; by default everything is a string if type is not detected 
9660			.fapstr: ; 
9660 fe 22			cp '"' 
9662 20 01			jr nz, .strnoqu 
9664 23				inc hl 
9665			.strnoqu: 
9665 c3 1b 96			jp forth_push_str 
9668			 
9668			 
9668			 
9668			.fapbin:    ; push a binary string.  
9668 11 00 00			ld de, 0   ; hold a 16bit value 
966b			 
966b 23			.fapbinshift:	inc hl  
966c 7e				ld a,(hl) 
966d fe 00			cp 0     ; done scanning  
966f 28 0b			jr z, .fapbdone  	; got it in HL so push  
9671			 
9671				; left shift de 
9671 eb				ex de, hl	 
9672 29				add hl, hl 
9673			 
9673				; is 1 
9673 fe 31			cp '1' 
9675 20 02			jr nz, .binzero 
9677 cb 4d			bit 1, l 
9679			.binzero: 
9679 eb				ex de, hl	 ; save current de 
967a 18 ef			jr .fapbinshift 
967c			 
967c			.fapbdone: 
967c eb				ex de, hl 
967d c3 09 96			jp forth_push_numhl 
9680			 
9680			 
9680			.faphex:   ; hex is always stored as a 16bit word 
9680				; skip number prefix 
9680 23				inc hl 
9681				; turn ascii into number 
9681 cd 72 8c			call get_word_hl	; ret 16bit word in hl 
9684			 
9684 c3 09 96			jp forth_push_numhl 
9687			 
9687 00				 nop 
9688			 
9688			.fabin:   ; TODO bin conversion 
9688			 
9688			 
9688 c9				ret 
9689			 
9689			 
9689			; get either a string ptr or a 16bit word from the data stack 
9689			 
9689			FORTH_DSP: macro 
9689				call macro_forth_dsp 
9689				endm 
9689			 
9689			macro_forth_dsp: 
9689				; data stack pointer points to current word on tos 
9689			 
9689 2a 22 eb			ld hl,(cli_data_sp) 
968c			 
968c				if DEBUG_FORTH_PUSH 
968c						DMARK "DSP" 
968c			 
968c					call display_data_sp 
968c				;call break_point_state 
968c				;rst 030h 
968c				CALLMONITOR 
968c				endif 
968c			 
968c c9				ret 
968d			 
968d			; return hl to start of value on stack 
968d			 
968d			FORTH_DSP_VALUE: macro 
968d				call macro_forth_dsp_value 
968d				endm 
968d			 
968d			macro_forth_dsp_value: 
968d			 
968d				FORTH_DSP 
968d cd 89 96			call macro_forth_dsp 
9690				endm 
# End of macro FORTH_DSP
9690			 
9690 d5				push de 
9691			 
9691 23				inc hl ; skip type 
9692			 
9692 5e				ld e, (hl) 
9693 23				inc hl 
9694 56				ld d, (hl) 
9695 eb				ex de,hl  
9696			 
9696 d1				pop de 
9697			 
9697 c9				ret 
9698			 
9698			; return hl to start of value to second item on stack 
9698			 
9698			FORTH_DSP_VALUEM1: macro 
9698				call macro_forth_dsp_value_m1 
9698				endm 
9698			 
9698			macro_forth_dsp_value_m1: 
9698			 
9698				FORTH_DSP 
9698 cd 89 96			call macro_forth_dsp 
969b				endm 
# End of macro FORTH_DSP
969b			 
969b 2b				dec hl 
969c 2b				dec hl 
969d			;	dec hl 
969d			 
969d d5				push de 
969e			 
969e 5e				ld e, (hl) 
969f 23				inc hl 
96a0 56				ld d, (hl) 
96a1 eb				ex de,hl  
96a2			 
96a2 d1				pop de 
96a3			 
96a3 c9				ret 
96a4			 
96a4				 
96a4			 
96a4			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
96a4			 
96a4			FORTH_DSP_POP: macro 
96a4				call macro_forth_dsp_pop 
96a4				endm 
96a4			 
96a4			 
96a4			; get the tos data type 
96a4			 
96a4			FORTH_DSP_TYPE:   macro 
96a4			 
96a4				;FORTH_DSP_VALUE 
96a4				FORTH_DSP 
96a4				 
96a4				; hl points to value 
96a4				; check type 
96a4			 
96a4				ld a,(hl) 
96a4			 
96a4				endm 
96a4			 
96a4			; load the tos value into hl 
96a4			 
96a4			 
96a4			FORTH_DSP_VALUEHL:  macro 
96a4				call macro_dsp_valuehl 
96a4				endm 
96a4			 
96a4			 
96a4			 
96a4			macro_dsp_valuehl: 
96a4				FORTH_DSP_VALUE 
96a4 cd 8d 96			call macro_forth_dsp_value 
96a7				endm 
# End of macro FORTH_DSP_VALUE
96a7			 
96a7				;FORTH_ERR_TOS_NOTNUM 
96a7			 
96a7				;inc hl   ; skip type id 
96a7			 
96a7			;	push de 
96a7			; 
96a7			;	ld e, (hl) 
96a7			;	inc hl 
96a7			;	ld d, (hl) 
96a7			;	ex de,hl  
96a7			 
96a7			;	pop de 
96a7			 
96a7				if DEBUG_FORTH_PUSH 
96a7						DMARK "DVL" 
96a7				CALLMONITOR 
96a7				endif 
96a7 c9				ret 
96a8			 
96a8			forth_apushstrhl:      
96a8				; push of string requires use of cli_origptr 
96a8				; bodge use 
96a8			 
96a8				; get current cli_origptr, save, update with temp pointer  
96a8 ed 5b 3e eb		ld de, (cli_origptr) 
96ac 22 3e eb			ld (cli_origptr), hl 
96af d5				push de 
96b0 cd 51 96			call forth_apush 
96b3 d1				pop de 
96b4 ed 53 3e eb		ld (cli_origptr), de 
96b8 c9			        ret	 
96b9			 
96b9			 
96b9			; increase loop stack pointer and save hl to it 
96b9				 
96b9			FORTH_LOOP_NEXT: macro 
96b9				call macro_forth_loop_next 
96b9				;nop 
96b9				endm 
96b9			 
96b9			macro_forth_loop_next: 
96b9				if DEBUG_FORTH_STACK_GUARD 
96b9 cd 03 c4				call check_stacks 
96bc				endif 
96bc e5				push hl 
96bd d5				push de 
96be eb				ex de,hl 
96bf 2a 24 eb			ld hl,(cli_loop_sp) 
96c2 23				inc hl 
96c3 23				inc hl 
96c4					if DEBUG_FORTH_WORDS 
96c4						DMARK "LNX" 
96c4						CALLMONITOR 
96c4					endif 
96c4 22 24 eb			ld (cli_loop_sp),hl 
96c7 73				ld (hl), e 
96c8 23				inc hl 
96c9 72				ld (hl), d 
96ca d1				pop de    ; been reversed so save a swap on restore 
96cb e1				pop hl 
96cc				if DEBUG_FORTH_STACK_GUARD 
96cc cd 03 c4				call check_stacks 
96cf				endif 
96cf c9				ret 
96d0			 
96d0			; get current ret stack pointer and save to hl  
96d0				 
96d0			FORTH_LOOP_TOS: macro 
96d0				call macro_forth_loop_tos 
96d0				endm 
96d0			 
96d0			macro_forth_loop_tos: 
96d0 d5				push de 
96d1 2a 24 eb			ld hl,(cli_loop_sp) 
96d4 5e				ld e, (hl) 
96d5 23				inc hl 
96d6 56				ld d, (hl) 
96d7 eb				ex de, hl 
96d8 d1				pop de 
96d9 c9				ret 
96da			 
96da			; pop loop stack pointer 
96da				 
96da			FORTH_LOOP_POP: macro 
96da				call macro_forth_loop_pop 
96da				endm 
96da			 
96da			 
96da			macro_forth_loop_pop: 
96da				if DEBUG_FORTH_STACK_GUARD 
96da					DMARK "LPP" 
96da f5				push af  
96db 3a ef 96			ld a, (.dmark)  
96de 32 7a ee			ld (debug_mark),a  
96e1 3a f0 96			ld a, (.dmark+1)  
96e4 32 7b ee			ld (debug_mark+1),a  
96e7 3a f1 96			ld a, (.dmark+2)  
96ea 32 7c ee			ld (debug_mark+2),a  
96ed 18 03			jr .pastdmark  
96ef ..			.dmark: db "LPP"  
96f2 f1			.pastdmark: pop af  
96f3			endm  
# End of macro DMARK
96f3 cd 03 c4				call check_stacks 
96f6					FORTH_CHK_LOOP_UNDER 
96f6 e5				push hl 
96f7 d5				push de 
96f8 2a 24 eb			ld hl,(cli_loop_sp) 
96fb 11 de e9			ld de, cli_loop_stack 
96fe cd d9 88			call cmp16 
9701 da 1d c5			jp c, fault_loop_under 
9704 d1				pop de 
9705 e1				pop hl 
9706				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9706				endif 
9706 e5				push hl 
9707 2a 24 eb			ld hl,(cli_loop_sp) 
970a 2b				dec hl 
970b 2b				dec hl 
970c 22 24 eb			ld (cli_loop_sp), hl 
970f				; TODO do stack underflow checks 
970f e1				pop hl 
9710				if DEBUG_FORTH_STACK_GUARD 
9710 cd 03 c4				call check_stacks 
9713					FORTH_CHK_LOOP_UNDER 
9713 e5				push hl 
9714 d5				push de 
9715 2a 24 eb			ld hl,(cli_loop_sp) 
9718 11 de e9			ld de, cli_loop_stack 
971b cd d9 88			call cmp16 
971e da 1d c5			jp c, fault_loop_under 
9721 d1				pop de 
9722 e1				pop hl 
9723				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9723				endif 
9723 c9				ret 
9724			 
9724			macro_forth_dsp_pop: 
9724			 
9724 e5				push hl 
9725			 
9725				; release malloc data 
9725			 
9725				if DEBUG_FORTH_STACK_GUARD 
9725 cd 03 c4				call check_stacks 
9728					FORTH_CHK_DSP_UNDER 
9728 e5				push hl 
9729 d5				push de 
972a 2a 22 eb			ld hl,(cli_data_sp) 
972d 11 dc e8			ld de, cli_data_stack 
9730 cd d9 88			call cmp16 
9733 da 11 c5			jp c, fault_dsp_under 
9736 d1				pop de 
9737 e1				pop hl 
9738				endm 
# End of macro FORTH_CHK_DSP_UNDER
9738				endif 
9738				;ld hl,(cli_data_sp) 
9738			if DEBUG_FORTH_DOT 
9738				DMARK "DPP" 
9738				CALLMONITOR 
9738			endif	 
9738			 
9738			 
9738			if FORTH_ENABLE_DSPPOPFREE 
9738			 
9738				FORTH_DSP 
9738 cd 89 96			call macro_forth_dsp 
973b				endm 
# End of macro FORTH_DSP
973b			 
973b 7e				ld a, (hl) 
973c fe 01			cp DS_TYPE_STR 
973e 20 07			jr nz, .skippopfree 
9740			 
9740				FORTH_DSP_VALUEHL 
9740 cd a4 96			call macro_dsp_valuehl 
9743				endm 
# End of macro FORTH_DSP_VALUEHL
9743 00				nop 
9744			if DEBUG_FORTH_DOT 
9744				DMARK "DPf" 
9744				CALLMONITOR 
9744			endif	 
9744 cd 4c 8e			call free 
9747			.skippopfree: 
9747				 
9747			 
9747			endif 
9747			 
9747			if DEBUG_FORTH_DOT_KEY 
9747				DMARK "DP2" 
9747				CALLMONITOR 
9747			endif	 
9747			 
9747				; move pointer down 
9747			 
9747 2a 22 eb			ld hl,(cli_data_sp) 
974a 2b				dec hl 
974b 2b				dec hl 
974c			; PARSEV5 
974c 2b				dec hl 
974d 22 22 eb			ld (cli_data_sp), hl 
9750			 
9750				if DEBUG_FORTH_STACK_GUARD 
9750 cd 03 c4				call check_stacks 
9753					FORTH_CHK_DSP_UNDER 
9753 e5				push hl 
9754 d5				push de 
9755 2a 22 eb			ld hl,(cli_data_sp) 
9758 11 dc e8			ld de, cli_data_stack 
975b cd d9 88			call cmp16 
975e da 11 c5			jp c, fault_dsp_under 
9761 d1				pop de 
9762 e1				pop hl 
9763				endm 
# End of macro FORTH_CHK_DSP_UNDER
9763				endif 
9763			 
9763 e1				pop hl 
9764			 
9764 c9				ret 
9765			 
9765			getwordathl: 
9765				; hl points to an address 
9765				; load hl with the word at that address 
9765			 
9765 d5				push de 
9766			 
9766 5e				ld e, (hl) 
9767 23				inc hl 
9768 56				ld d, (hl) 
9769 eb				ex de, hl 
976a			 
976a d1				pop de 
976b c9				ret 
976c			 
976c			 
976c			 
976c			 
976c			 
976c			; eof 
976c			 
# End of file forth_stackopsv5.asm
976c			endif 
976c			 
976c			user_word_eol:  
976c				; hl contains the pointer to where to create a linked list item from the end 
976c				; of the user dict to continue on at the system word dict 
976c				 
976c				; poke the stub of the word list linked list to repoint to rom words 
976c			 
976c				; stub format 
976c				; db   word id 
976c				; dw    link to next word 
976c			        ; db char length of token 
976c				; db string + 0 term 
976c				; db exec code....  
976c			 
976c 3e 00			ld a, WORD_SYS_ROOT     ; root word 
976e 77				ld (hl), a		; word id 
976f 23				inc hl 
9770			 
9770 11 36 99			ld de, sysdict 
9773 73				ld (hl), e		; next word link ie system dict 
9774 23				inc hl 
9775 72				ld (hl), d		; next word link ie system dict 
9776 23				inc hl	 
9777			 
9777			;	ld (hl), sysdict		; next word link ie system dict 
9777			;	inc hl 
9777			;	inc hl 
9777			 
9777			;	inc hl 
9777			;	inc hl 
9777			 
9777 3e 02			ld a, 2			; word length is 0 
9779 77				ld (hl), a	 
977a 23				inc hl 
977b			 
977b 3e 7e			ld a, '~'			; word length is 0 
977d 77				ld (hl), a	 
977e 23				inc hl 
977f 3e 00			ld a, 0			; save empty word 
9781 77				ld (hl), a 
9782			 
9782 c9				ret 
9783			 
9783				 
9783			 
9783			forthexec_cleanup: 
9783				FORTH_RSP_POP 
9783 cd d1 95			call macro_forth_rsp_pop 
9786				endm 
# End of macro FORTH_RSP_POP
9786 c9				ret 
9787			 
9787			forth_call_hl: 
9787				; taking hl 
9787 e5				push hl 
9788 c9				ret 
9789			 
9789			; this is called to reset Forth system but keep existing uwords etc 
9789			 
9789			forth_warmstart: 
9789				; setup stack over/under flow checks 
9789				if DEBUG_FORTH_STACK_GUARD 
9789 cd e9 c3				call chk_stk_init 
978c				endif 
978c			 
978c				; init stack pointers  - * these stacks go upwards *  
978c 21 e0 ea			ld hl, cli_ret_stack 
978f 22 26 eb			ld (cli_ret_sp), hl	 
9792				; set bottom of stack 
9792 3e 00			ld a,0 
9794 77				ld (hl),a 
9795 23				inc hl 
9796 77				ld (hl),a 
9797			 
9797 21 dc e8			ld hl, cli_data_stack 
979a 22 22 eb			ld (cli_data_sp), hl	 
979d				; set bottom of stack 
979d 3e 00			ld a,0 
979f 77				ld (hl),a 
97a0 23				inc hl 
97a1 77				ld (hl),a 
97a2			 
97a2 21 de e9			ld hl, cli_loop_stack 
97a5 22 24 eb			ld (cli_loop_sp), hl	 
97a8				; set bottom of stack 
97a8 3e 00			ld a,0 
97aa 77				ld (hl),a 
97ab 23				inc hl 
97ac 77				ld (hl),a 
97ad			 
97ad				; init extent of current open file 
97ad			 
97ad 3e 00			ld a, 0 
97af 32 5c eb			ld (store_openext), a 
97b2			 
97b2 c9				ret 
97b3			 
97b3			 
97b3			; Cold Start - this is called to setup the whole Forth system 
97b3			 
97b3			forth_init: 
97b3			 
97b3				; setup stack over/under flow checks 
97b3			 
97b3			;	if DEBUG_FORTH_STACK_GUARD 
97b3			;		call chk_stk_init 
97b3			;	endif 
97b3			 
97b3				; enable auto display updates (slow.....) 
97b3			 
97b3 3e 01			ld a, 1 
97b5 32 3c eb			ld (cli_autodisplay), a 
97b8			 
97b8			 
97b8			 
97b8				; show start up screen 
97b8			 
97b8 cd 62 87			call clear_display 
97bb			 
97bb 3e 00			ld a,0 
97bd 32 5e eb			ld (f_cursor_ptr), a 
97c0			 
97c0				; set start of word list in start of ram - for use when creating user words 
97c0			 
97c0 21 b4 c6			ld hl, baseram 
97c3 22 72 e6			ld (os_last_new_uword), hl 
97c6 cd 6c 97			call user_word_eol 
97c9				 
97c9			;		call display_data_sp 
97c9			;		call next_page_prompt 
97c9			 
97c9			 
97c9			 
97c9			 
97c9 c9				ret 
97ca			 
97ca .. 00		.bootforth: db " Forth Kernel Init ",0 
97de			 
97de			; TODO push to stack 
97de			 
97de			;  
97de			 
97de			if FORTH_PARSEV2 
97de			 
97de			 
97de				include "forth_parserv2.asm" 
97de			 
97de			endif 
97de			 
97de			 
97de			; parse cli version 1 
97de			 
97de			if FORTH_PARSEV1 
97de			 
97de			 
97de			 
97de			      include "forth_parserv1.asm" 
97de			endif 
97de				 
97de			if FORTH_PARSEV3 
97de			 
97de			 
97de			 
97de			      include "forth_parserv3.asm" 
97de				include "forth_wordsv3.asm" 
97de			endif 
97de			 
97de			if FORTH_PARSEV4 
97de			 
97de			 
97de			 
97de			      include "forth_parserv4.asm" 
97de				include "forth_wordsv4.asm" 
97de			endif 
97de			 
97de			if FORTH_PARSEV5 
97de			 
97de			 
97de			 
97de			      include "forth_parserv5.asm" 
97de			 
97de			 
97de			; A better parser without using malloc and string copies all over the place.  
97de			; Exec in situ should be faster 
97de			 
97de			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
97de			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
97de			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
97de			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
97de			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
97de			WORD_SYS_END: equ 0   ; Opcode for all user words 
97de			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
97de			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
97de			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
97de			 
97de			; Core word preamble macro 
97de			 
97de			CWHEAD:   macro nxtword opcode lit len opflags 
97de				db WORD_SYS_CORE+opcode             
97de				; internal op code number 
97de				dw nxtword            
97de				; link to next dict word block 
97de				db len + 1 
97de				; literal length of dict word inc zero term 
97de				db lit,0              
97de				; literal dict word 
97de			        ; TODO db opflags        
97de				endm 
97de			 
97de			 
97de			NEXTW: macro  
97de				jp macro_next 
97de				endm 
97de			 
97de			macro_next: 
97de			if DEBUG_FORTH_PARSE_KEY 
97de				DMARK "NXT" 
97de				CALLMONITOR 
97de			endif	 
97de			;	inc hl  ; skip token null term  
97de ed 4b 40 eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
97e2 ed 5b 3e eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
97e6 2a 76 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
97e9			if DEBUG_FORTH_PARSE_KEY 
97e9				DMARK "}AA" 
97e9				CALLMONITOR 
97e9			endif	 
97e9 c3 ec 98			jp execnext 
97ec				;jp exec1 
97ec			       
97ec			 
97ec			 
97ec			; Another go at the parser to compile  
97ec			 
97ec			 
97ec			; TODO rework parser to change all of the string words to byte tokens 
97ec			; TODO do a search for  
97ec			 
97ec			; TODO first run normal parser to zero term sections 
97ec			; TODO for each word do a token look up to get the op code 
97ec			; TODO need some means to flag to the exec that this is a byte code form    
97ec			 
97ec			 
97ec			forthcompile: 
97ec			 
97ec			; 
97ec			; line parse: 
97ec			;       parse raw input buffer 
97ec			;       tokenise the words 
97ec			;       malloc new copy (for looping etc) 
97ec			;       copy to malloc + current pc in line to start of string and add line term 
97ec			;       save on new rsp 
97ec			; 
97ec			 
97ec			; hl to point to the line to tokenise 
97ec			 
97ec			;	push hl 
97ec 22 76 e6			ld (os_tok_ptr), hl  ; save ptr to string 
97ef			 
97ef			;	ld a,0		; string term on input 
97ef			;	call strlent 
97ef			 
97ef			;	ld (os_tok_len), hl	 ; save string length 
97ef			 
97ef			;if DEBUG_FORTH_TOK 
97ef			;	ex de,hl		 
97ef			;endif 
97ef			 
97ef			;	pop hl 		; get back string pointer 
97ef			 
97ef			if DEBUG_FORTH_TOK 
97ef						DMARK "TOc" 
97ef				CALLMONITOR 
97ef			endif 
97ef 7e			.cptoken2:    ld a,(hl) 
97f0 23				inc hl 
97f1 fe 7f			cp FORTH_END_BUFFER 
97f3 28 29			jr z, .cptokendone2 
97f5 fe 00			cp 0 
97f7 28 25			jr z, .cptokendone2 
97f9 fe 22			cp '"' 
97fb 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
97fd fe 20			cp ' ' 
97ff 20 ee			jr nz,  .cptoken2 
9801			 
9801			; TODO consume comments held between ( and ) 
9801			 
9801				; we have a space so change to zero term for dict match later 
9801 2b				dec hl 
9802 3e 00			ld a,0 
9804 77				ld (hl), a 
9805 23				inc hl 
9806 18 e7			jr .cptoken2 
9808				 
9808			 
9808			.cptokenstr2: 
9808				; skip all white space until either eol (because forgot to term) or end double quote 
9808			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9808				;inc hl ; skip current double quote 
9808 7e				ld a,(hl) 
9809 23				inc hl 
980a fe 22			cp '"' 
980c 28 e1			jr z, .cptoken2 
980e fe 7f			cp FORTH_END_BUFFER 
9810 28 0c			jr z, .cptokendone2 
9812 fe 00			cp 0 
9814 28 08			jr z, .cptokendone2 
9816 fe 20			cp ' ' 
9818 28 02			jr z, .cptmp2 
981a 18 ec			jr .cptokenstr2 
981c			 
981c			.cptmp2:	; we have a space so change to zero term for dict match later 
981c				;dec hl 
981c				;ld a,"-"	; TODO remove this when working 
981c				;ld (hl), a 
981c				;inc hl 
981c 18 ea			jr .cptokenstr2 
981e			 
981e			.cptokendone2: 
981e				;inc hl 
981e 3e 7f			ld a, FORTH_END_BUFFER 
9820 77				ld (hl),a 
9821 23				inc hl 
9822 3e 21			ld a, '!' 
9824 77				ld (hl),a 
9825			 
9825 2a 76 e6			ld hl,(os_tok_ptr) 
9828			         
9828			if DEBUG_FORTH_TOK 
9828						DMARK "Tc1" 
9828				CALLMONITOR 
9828			endif 
9828			 
9828				; push exec string to top of return stack 
9828				FORTH_RSP_NEXT 
9828 cd b3 95			call macro_forth_rsp_next 
982b				endm 
# End of macro FORTH_RSP_NEXT
982b c9				ret 
982c			 
982c			; Another go at the parser need to simplify the process 
982c			 
982c			forthparse: 
982c			 
982c			; 
982c			; line parse: 
982c			;       parse raw input buffer 
982c			;       tokenise the words 
982c			;       malloc new copy (for looping etc) 
982c			;       copy to malloc + current pc in line to start of string and add line term 
982c			;       save on new rsp 
982c			; 
982c			 
982c			; hl to point to the line to tokenise 
982c			 
982c			;	push hl 
982c 22 76 e6			ld (os_tok_ptr), hl  ; save ptr to string 
982f			 
982f			;	ld a,0		; string term on input 
982f			;	call strlent 
982f			 
982f			;	ld (os_tok_len), hl	 ; save string length 
982f			 
982f			;if DEBUG_FORTH_TOK 
982f			;	ex de,hl		 
982f			;endif 
982f			 
982f			;	pop hl 		; get back string pointer 
982f			 
982f			if DEBUG_FORTH_TOK 
982f						DMARK "TOK" 
982f				CALLMONITOR 
982f			endif 
982f 7e			.ptoken2:    ld a,(hl) 
9830 23				inc hl 
9831 fe 7f			cp FORTH_END_BUFFER 
9833 28 29			jr z, .ptokendone2 
9835 fe 00			cp 0 
9837 28 25			jr z, .ptokendone2 
9839 fe 22			cp '"' 
983b 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
983d fe 20			cp ' ' 
983f 20 ee			jr nz,  .ptoken2 
9841			 
9841			; TODO consume comments held between ( and ) 
9841			 
9841				; we have a space so change to zero term for dict match later 
9841 2b				dec hl 
9842 3e 00			ld a,0 
9844 77				ld (hl), a 
9845 23				inc hl 
9846 18 e7			jr .ptoken2 
9848				 
9848			 
9848			.ptokenstr2: 
9848				; skip all white space until either eol (because forgot to term) or end double quote 
9848			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9848				;inc hl ; skip current double quote 
9848 7e				ld a,(hl) 
9849 23				inc hl 
984a fe 22			cp '"' 
984c 28 e1			jr z, .ptoken2 
984e fe 7f			cp FORTH_END_BUFFER 
9850 28 0c			jr z, .ptokendone2 
9852 fe 00			cp 0 
9854 28 08			jr z, .ptokendone2 
9856 fe 20			cp ' ' 
9858 28 02			jr z, .ptmp2 
985a 18 ec			jr .ptokenstr2 
985c			 
985c			.ptmp2:	; we have a space so change to zero term for dict match later 
985c				;dec hl 
985c				;ld a,"-"	; TODO remove this when working 
985c				;ld (hl), a 
985c				;inc hl 
985c 18 ea			jr .ptokenstr2 
985e			 
985e			.ptokendone2: 
985e				;inc hl 
985e 3e 7f			ld a, FORTH_END_BUFFER 
9860 77				ld (hl),a 
9861 23				inc hl 
9862 3e 21			ld a, '!' 
9864 77				ld (hl),a 
9865			 
9865 2a 76 e6			ld hl,(os_tok_ptr) 
9868			         
9868			if DEBUG_FORTH_TOK 
9868						DMARK "TK1" 
9868				CALLMONITOR 
9868			endif 
9868			 
9868				; push exec string to top of return stack 
9868				FORTH_RSP_NEXT 
9868 cd b3 95			call macro_forth_rsp_next 
986b				endm 
# End of macro FORTH_RSP_NEXT
986b c9				ret 
986c			 
986c			; 
986c			;	; malloc size + buffer pointer + if is loop flag 
986c			;	ld hl,(os_tok_len) 		 ; get string length 
986c			; 
986c			;	ld a,l 
986c			; 
986c			;	cp 0			; we dont want to use a null string 
986c			;	ret z 
986c			; 
986c			;;	add 3    ; prefix malloc with buffer for current word ptr 
986c			; 
986c			;	add 5     ; TODO when certain not over writing memory remove 
986c			; 
986c			;		 
986c			; 
986c			;if DEBUG_FORTH_TOK 
986c			;			DMARK "TKE" 
986c			;	CALLMONITOR 
986c			;endif 
986c			; 
986c			;	ld l,a 
986c			;	ld h,0 
986c			;;	push hl   ; save required space for the copy later 
986c			;	call malloc 
986c			;if DEBUG_FORTH_TOK 
986c			;			DMARK "TKM" 
986c			;	CALLMONITOR 
986c			;endif 
986c			;	if DEBUG_FORTH_MALLOC_GUARD 
986c			;		push af 
986c			;		call ishlzero 
986c			;;		ld a, l 
986c			;;		add h 
986c			;;		cp 0 
986c			;		pop af 
986c			;		 
986c			;		call z,malloc_error 
986c			;	endif 
986c			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
986c			; 
986c			; 
986c			;if DEBUG_FORTH_TOK 
986c			;			DMARK "TKR" 
986c			;	CALLMONITOR 
986c			;endif 
986c			; 
986c			;	FORTH_RSP_NEXT 
986c			; 
986c			;	;inc hl	 ; go past current buffer pointer 
986c			;	;inc hl 
986c			;	;inc hl   ; and past if loop flag 
986c			;		; TODO Need to set flag  
986c			; 
986c			;	 
986c			;	 
986c			;	ex de,hl	; malloc is dest 
986c			;	ld hl, (os_tok_len) 
986c			;;	pop bc 
986c			;	ld c, l                
986c			;	ld b,0 
986c			;	ld hl, (os_tok_ptr) 
986c			; 
986c			;if DEBUG_FORTH_TOK 
986c			;			DMARK "TKT" 
986c			;	CALLMONITOR 
986c			;endif 
986c			; 
986c			;	; do str cpy 
986c			; 
986c			;	ldir      ; copy byte in hl to de 
986c			; 
986c			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
986c			; 
986c			;if DEBUG_FORTH_TOK 
986c			; 
986c			;			DMARK "TKY" 
986c			;	CALLMONITOR 
986c			;endif 
986c			;	;ld a,0 
986c			;	;ld a,FORTH_END_BUFFER 
986c			;	ex de, hl 
986c			;	;dec hl			 ; go back over the space delim at the end of word 
986c			;	;ld (hl),a 
986c			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
986c			;	ld a,FORTH_END_BUFFER 
986c			;	ld (hl),a 
986c			;	inc hl 
986c			;	ld a,FORTH_END_BUFFER 
986c			;	ld (hl),a 
986c			; 
986c			;	; init the malloc area data 
986c			;	; set pc for in current area 
986c			;	;ld hl, (os_tok_malloc) 
986c			;	;inc hl 
986c			;	;inc hl 
986c			;	;inc hl 
986c			;	;ex de,hl 
986c			;	;ld hl, (os_tok_malloc) 
986c			;	;ld (hl),e 
986c			;	;inc hl 
986c			;	;ld (hl),d 
986c			; 
986c			; 
986c			;	ld hl,(os_tok_malloc) 
986c			;if DEBUG_FORTH_PARSE_KEY 
986c			;			DMARK "TKU" 
986c			;	CALLMONITOR 
986c			;endif 
986c			; 
986c			;	ret 
986c			 
986c			forthexec: 
986c			 
986c			; line exec: 
986c			; forth parser 
986c			 
986c			; 
986c			;       get current exec line on rsp 
986c			 
986c				FORTH_RSP_TOS 
986c cd ca 95			call macro_forth_rsp_tos 
986f				endm 
# End of macro FORTH_RSP_TOS
986f			 
986f			;       restore current pc - hl points to malloc of data 
986f			 
986f				;ld e, (hl) 
986f				;inc hl 
986f				;ld d, (hl) 
986f				;ex de,hl 
986f			 
986f			 
986f			exec1: 
986f 22 76 e6			ld (os_tok_ptr), hl 
9872			 
9872				; copy our PC to working vars  
9872 22 40 eb			ld (cli_ptr), hl 
9875 22 3e eb			ld (cli_origptr), hl 
9878			 
9878 7e				ld a,(hl) 
9879 fe 7f			cp FORTH_END_BUFFER 
987b c8				ret z 
987c			 
987c				; skip any nulls 
987c			 
987c fe 00			cp 0 
987e 20 03			jr nz, .execword 
9880 23				inc hl 
9881 18 ec			jr exec1 
9883			 
9883			 
9883			.execword: 
9883			 
9883			 
9883			 
9883			if DEBUG_FORTH_PARSE_KEY 
9883						DMARK "KYQ" 
9883				CALLMONITOR 
9883			endif 
9883			;       while at start of word: 
9883			; get start of dict (in user area first) 
9883			 
9883 21 b4 c6		ld hl, baseram 
9886			;ld hl, sysdict 
9886 22 42 eb		ld (cli_nextword),hl 
9889			;           match word at pc 
9889			;           exec word 
9889			;           or push to dsp 
9889			;           forward to next token 
9889			;           if line term pop rsp and exit 
9889			;        
9889			 
9889			if DEBUG_FORTH_PARSE_KEY 
9889						DMARK "KYq" 
9889				CALLMONITOR 
9889			endif 
9889			 
9889			; 
9889			; word comp 
9889			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9889			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9889			;    move to start of word  
9889			;    compare word to cli_token 
9889			 
9889			.execpnword:	; HL at start of a word in the dictionary to check 
9889			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9889			;	ld (cli_ptr), hl 
9889			 
9889 2a 42 eb			ld hl,(cli_nextword) 
988c			 
988c cd 2f 99			call forth_tok_next 
988f			; tok next start here 
988f			;	; TODO skip compiled symbol for now 
988f			;	inc hl 
988f			; 
988f			;	; save pointer to next word 
988f			; 
988f			;	; hl now points to the address of the next word pointer  
988f			;	ld e, (hl) 
988f			;	inc hl 
988f			;	ld d, (hl) 
988f			;	inc l 
988f			; 
988f			;	ex de,hl 
988f			;if DEBUG_FORTH_PARSE_NEXTWORD 
988f			;	push bc 
988f			;	ld bc, (cli_nextword) 
988f			;			DMARK "NXW" 
988f			;	CALLMONITOR 
988f			;	pop bc 
988f			;endif 
988f			; tok next end here 
988f 22 42 eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
9892 eb				ex de, hl 
9893			 
9893			 
9893				; save the pointer of the current token - 1 to check against 
9893				 
9893 22 46 eb			ld (cli_token), hl   
9896				; TODO maybe remove below save if no debug 
9896				; save token string ptr for any debug later 
9896 23				inc hl  
9897 22 48 eb			ld (cli_origtoken), hl 
989a 2b				dec hl 
989b				; save pointer to the start of the next dictionay word 
989b 7e				ld a,(hl)   ; get string length 
989c 47				ld b,a 
989d			.execpnwordinc:  
989d 23				inc hl 
989e 10 fd			djnz .execpnwordinc 
98a0 22 44 eb			ld (cli_execword), hl      ; save start of this words code 
98a3			 
98a3				; now check the word token against the string being parsed 
98a3			 
98a3 2a 46 eb			ld hl,(cli_token) 
98a6 23				inc hl     ; skip string length (use zero term instead to end) 
98a7 22 46 eb			ld (cli_token), hl 
98aa			 
98aa			if DEBUG_FORTH_PARSE_KEY 
98aa						DMARK "KY2" 
98aa			endif 
98aa			if DEBUG_FORTH_PARSE_EXEC 
98aa				; see if disabled 
98aa			 
98aa				ld a, (os_view_disable) 
98aa				cp '*' 
98aa				jr z, .skip 
98aa			 
98aa				push hl 
98aa				push hl 
98aa				call clear_display 
98aa				ld de, .compword 
98aa				ld a, display_row_1 
98aa				call str_at_display 
98aa				pop de 
98aa				ld a, display_row_2 
98aa				call str_at_display 
98aa				ld hl,(cli_ptr) 
98aa				ld a,(hl) 
98aa			        ld hl, os_word_scratch 
98aa				ld (hl),a 
98aa				ld a,0 
98aa				inc hl 
98aa				ld (hl),a 	 
98aa				ld de, os_word_scratch 
98aa				ld a, display_row_2+10 
98aa				call str_at_display 
98aa				call update_display 
98aa				ld a, 100 
98aa				call aDelayInMS 
98aa				if DEBUG_FORTH_PARSE_EXEC_SLOW 
98aa				call delay250ms 
98aa				endif 
98aa				pop hl 
98aa			.skip:  
98aa			endif	 
98aa			.execpnchar:    ; compare char between token and string to parse 
98aa			 
98aa			if DEBUG_FORTH_PARSE_KEY 
98aa						DMARK "Ky3" 
98aa			endif 
98aa			if DEBUG_FORTH_PARSE_EXEC 
98aa				; see if disabled 
98aa			 
98aa				ld a, (os_view_disable) 
98aa				cp '*' 
98aa				jr z, .skip2 
98aa			 
98aa			;	call clear_display 
98aa			ld hl,(cli_token) 
98aa			ld a,(hl) 
98aa			ld (os_word_scratch),a 
98aa				ld hl,(cli_ptr) 
98aa			ld a,(hl) 
98aa				ld (os_word_scratch+1),a 
98aa				ld a,0 
98aa				ld (os_word_scratch+2),a 
98aa				ld de,os_word_scratch 
98aa				ld a,display_row_4 
98aa				call str_at_display 
98aa				call update_display 
98aa			.skip2:  
98aa			endif 
98aa 2a 46 eb			ld hl,(cli_token) 
98ad 7e				ld a, (hl)	 ; char in word token 
98ae 23				inc hl 		; move to next char 
98af 22 46 eb			ld (cli_token), hl ; and save it 
98b2 47				ld b,a 
98b3			 
98b3 2a 40 eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
98b6 7e				ld a,(hl) 
98b7 23				inc hl 
98b8 22 40 eb			ld (cli_ptr), hl		; move to next char 
98bb cd 10 8d			call toUpper 		; make sure the input string matches case 
98be			 
98be			if DEBUG_FORTH_PARSE 
98be			endif 
98be			 
98be				; input stream end of token is a space so get rid of it 
98be			 
98be			;	cp ' ' 
98be			;	jr nz, .pnskipspace 
98be			; 
98be			;	ld a, 0		; make same term as word token term 
98be			; 
98be			;.pnskipspace: 
98be			 
98be			if DEBUG_FORTH_PARSE_KEY 
98be						DMARK "KY7" 
98be			endif 
98be b8				cp b 
98bf c2 d5 98			jp nz, .execpnskipword	 ; no match so move to next word 
98c2				 
98c2			;    if same 
98c2			;       scan for string terms 0 for token and 32 for input 
98c2			 
98c2				 
98c2			if DEBUG_FORTH_PARSE_KEY 
98c2						DMARK "KY8" 
98c2			endif 
98c2			 
98c2 80				add b			 
98c3 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
98c5							; TODO need to make sure last word in zero term string is accounted for 
98c5 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
98c7			 
98c7			 
98c7				; at end of both strings so both are exact match 
98c7			 
98c7			;       skip ptr for next word 
98c7			 
98c7 2a 40 eb			ld hl,(cli_ptr) 	; at input string term 
98ca 23				inc hl			 ; at next char 
98cb 22 40 eb			ld (cli_ptr), hl     ; save for next round of the parser 
98ce 22 3e eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
98d1				 
98d1				 
98d1			if DEBUG_FORTH_PARSE_KEY 
98d1						DMARK "KY3" 
98d1			endif 
98d1			 
98d1			 
98d1			 
98d1			;       exec code block 
98d1			if DEBUG_FORTH_JP 
98d1				call clear_display 
98d1				call update_display 
98d1				call delay1s 
98d1				ld hl, (cli_execword)     ; save for next check if no match on this word 
98d1				ld a,h 
98d1				ld hl, os_word_scratch 
98d1				call hexout 
98d1				ld hl, (cli_execword)     ; save for next check if no match on this word 
98d1				ld a,l 
98d1				ld hl, os_word_scratch+2 
98d1				call hexout 
98d1				ld hl, os_word_scratch+4 
98d1				ld a,0 
98d1				ld (hl),a 
98d1				ld de,os_word_scratch 
98d1				call str_at_display 
98d1					ld a, display_row_2 
98d1					call str_at_display 
98d1				ld de, (cli_origtoken) 
98d1				ld a, display_row_1+10 
98d1					call str_at_display 
98d1			 
98d1				ld a,display_row_1 
98d1				ld de, .foundword 
98d1				ld a, display_row_3 
98d1				call str_at_display 
98d1				call update_display 
98d1				call delay1s 
98d1				call delay1s 
98d1				call delay1s 
98d1			endif 
98d1			 
98d1			if DEBUG_FORTH_PARSE_KEY 
98d1						DMARK "KYj" 
98d1			endif 
98d1				; TODO save the word pointer in this exec 
98d1			 
98d1 2a 44 eb			ld hl,(cli_execword) 
98d4 e9				jp (hl) 
98d5			 
98d5			 
98d5			;    if not same 
98d5			;	scan for zero term 
98d5			;	get ptr for next word 
98d5			;	goto word comp 
98d5			 
98d5			.execpnskipword:	; get pointer to next word 
98d5 2a 42 eb			ld hl,(cli_nextword) 
98d8			 
98d8 7e				ld a,(hl) 
98d9 fe 00			cp WORD_SYS_END 
98db			;	cp 0 
98db 28 09			jr z, .execendofdict			 ; at end of words 
98dd			 
98dd			if DEBUG_FORTH_PARSE_KEY 
98dd						DMARK "KY4" 
98dd			endif 
98dd			if DEBUG_FORTH_PARSE_EXEC 
98dd			 
98dd				; see if disabled 
98dd			 
98dd				ld a, (os_view_disable) 
98dd				cp '*' 
98dd				jr z, .noskip 
98dd			 
98dd			 
98dd				ld de, .nowordfound 
98dd				ld a, display_row_3 
98dd				call str_at_display 
98dd				call update_display 
98dd				ld a, 100 
98dd				call aDelayInMS 
98dd				 
98dd				if DEBUG_FORTH_PARSE_EXEC_SLOW 
98dd					call delay250ms 
98dd				endif 
98dd			.noskip:  
98dd			 
98dd			endif	 
98dd			 
98dd 2a 3e eb			ld hl,(cli_origptr) 
98e0 22 40 eb			ld (cli_ptr),hl 
98e3			 
98e3			if DEBUG_FORTH_PARSE_KEY 
98e3						DMARK "KY5" 
98e3			endif 
98e3 c3 89 98			jp .execpnword			; else go to next word 
98e6			 
98e6			.execendofdict:  
98e6			 
98e6			if DEBUG_FORTH_PARSE_KEY 
98e6						DMARK "KYe" 
98e6			endif 
98e6			if DEBUG_FORTH_PARSE_EXEC 
98e6				; see if disabled 
98e6			 
98e6				ld a, (os_view_disable) 
98e6				cp '*' 
98e6				jr z, .ispskip 
98e6			 
98e6				call clear_display 
98e6				call update_display 
98e6				call delay1s 
98e6				ld de, (cli_origptr) 
98e6				ld a, display_row_1 
98e6				call str_at_display 
98e6				 
98e6				ld de, .enddict 
98e6				ld a, display_row_3 
98e6				call str_at_display 
98e6				call update_display 
98e6				ld a, 100 
98e6				call aDelayInMS 
98e6				if DEBUG_FORTH_PARSE_EXEC_SLOW 
98e6				call delay1s 
98e6				call delay1s 
98e6				call delay1s 
98e6				endif 
98e6			.ispskip:  
98e6				 
98e6			endif	 
98e6			 
98e6			 
98e6			 
98e6				; if the word is not a keyword then must be a literal so push it to stack 
98e6			 
98e6			; push token to stack to end of word 
98e6			 
98e6				STACKFRAME ON $1efe $2f9f 
98e6				if DEBUG_STACK_IMB 
98e6					if ON 
98e6						exx 
98e6						ld de, $1efe 
98e6						ld a, d 
98e6						ld hl, curframe 
98e6						call hexout 
98e6						ld a, e 
98e6						ld hl, curframe+2 
98e6						call hexout 
98e6						ld hl, $1efe 
98e6						push hl 
98e6						ld hl, $2f9f 
98e6						push hl 
98e6						exx 
98e6					endif 
98e6				endif 
98e6			endm 
# End of macro STACKFRAME
98e6			 
98e6 2a 76 e6		ld hl,(os_tok_ptr) 
98e9 cd 51 96		call forth_apush 
98ec			 
98ec				STACKFRAMECHK ON $1efe $2f9f 
98ec				if DEBUG_STACK_IMB 
98ec					if ON 
98ec						exx 
98ec						ld hl, $2f9f 
98ec						pop de   ; $2f9f 
98ec						call cmp16 
98ec						jr nz, .spnosame 
98ec						ld hl, $1efe 
98ec						pop de   ; $1efe 
98ec						call cmp16 
98ec						jr z, .spfrsame 
98ec						.spnosame: call showsperror 
98ec						.spfrsame: nop 
98ec						exx 
98ec					endif 
98ec				endif 
98ec			endm 
# End of macro STACKFRAMECHK
98ec			 
98ec			execnext: 
98ec			 
98ec			if DEBUG_FORTH_PARSE_KEY 
98ec						DMARK "KY>" 
98ec			endif 
98ec			; move past token to next word 
98ec			 
98ec 2a 76 e6		ld hl, (os_tok_ptr) 
98ef 3e 00		ld a, 0 
98f1 01 ff 00		ld bc, 255     ; input buffer size 
98f4 ed b1		cpir 
98f6			 
98f6			if DEBUG_FORTH_PARSE_KEY 
98f6						DMARK "KY!" 
98f6				CALLMONITOR 
98f6			endif	 
98f6			; TODO this might place hl on the null, so will need to forward on??? 
98f6			;inc hl   ; see if this gets onto the next item 
98f6			 
98f6			 
98f6			; TODO pass a pointer to the buffer to push 
98f6			; TODO call function to push 
98f6			 
98f6			; look for end of input 
98f6			 
98f6			;inc hl 
98f6			;ld a,(hl) 
98f6			;cp FORTH_END_BUFFER 
98f6			;ret z 
98f6			 
98f6			 
98f6 c3 6f 98		jp exec1 
98f9			 
98f9			 
98f9			 
98f9			 
98f9			 
98f9			 
98f9			 
98f9			 
98f9			 
98f9			findnexttok: 
98f9			 
98f9				; hl is pointer to move 
98f9				; de is the token to locate 
98f9			 
98f9					if DEBUG_FORTH 
98f9						DMARK "NTK" 
98f9						CALLMONITOR 
98f9					endif 
98f9 d5				push de 
98fa			 
98fa			.fnt1:	 
98fa				; find first char of token to locate 
98fa			 
98fa 1a				ld a, (de) 
98fb 4f				ld c,a 
98fc 7e				ld a,(hl) 
98fd cd 10 8d			call toUpper 
9900					if DEBUG_FORTH 
9900						DMARK "NT1" 
9900						CALLMONITOR 
9900					endif 
9900 b9				cp c 
9901			 
9901 28 03			jr z, .fnt2cmpmorefirst	 
9903			 
9903				; first char not found move to next char 
9903			 
9903 23				inc hl 
9904 18 f4			jr .fnt1 
9906			 
9906			.fnt2cmpmorefirst:	 
9906				; first char of token found.  
9906			 
9906 e5				push hl     ; save start of token just in case it is the right one 
9907 d9				exx 
9908 e1				pop hl        ; save it to hl' 
9909 d9				exx 
990a			 
990a			 
990a			.fnt2cmpmore:	 
990a				; compare the rest 
990a				 
990a 23				inc hl 
990b 13				inc de 
990c				 
990c 1a				ld a, (de) 
990d 4f				ld c,a 
990e 7e				ld a,(hl) 
990f cd 10 8d			call toUpper 
9912			 
9912					if DEBUG_FORTH 
9912						DMARK "NT2" 
9912						CALLMONITOR 
9912					endif 
9912				; c has the token to find char 
9912				; a has the mem to scan char 
9912			 
9912 b9				cp c 
9913 28 04			jr z,.fntmatch1 
9915			 
9915				; they are not the same 
9915			 
9915					if DEBUG_FORTH 
9915						DMARK "NT3" 
9915						CALLMONITOR 
9915					endif 
9915 d1				pop de	; reset de token to look for 
9916 d5				push de 
9917 18 e1			jr .fnt1 
9919				 
9919			.fntmatch1: 
9919			 
9919				; is the same char a null which means we might have a full hit? 
9919					if DEBUG_FORTH 
9919						DMARK "NT4" 
9919						CALLMONITOR 
9919					endif 
9919			 
9919 fe 00			cp 0 
991b 28 0b			jr z, .fntmatchyes 
991d			 
991d				; are we at the end of the token to find? 
991d			 
991d					if DEBUG_FORTH 
991d						DMARK "NT5" 
991d						CALLMONITOR 
991d					endif 
991d 3e 00			ld a, 0 
991f b9				cp c 
9920			 
9920 c2 0a 99			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9923			 
9923					if DEBUG_FORTH 
9923						DMARK "NT6" 
9923						CALLMONITOR 
9923					endif 
9923				; token to find is exhusted but no match to stream 
9923			 
9923				; restore tok pointer and continue on 
9923 d1				pop de 
9924 d5				push de 
9925 c3 fa 98			jp .fnt1 
9928			 
9928			 
9928			.fntmatchyes: 
9928			 
9928				; hl now contains the end of the found token 
9928			 
9928				; get rid of saved token pointer to find 
9928			 
9928 d1				pop de 
9929			 
9929					if DEBUG_FORTH 
9929						DMARK "NT9" 
9929						CALLMONITOR 
9929					endif 
9929			 
9929				; hl will be on the null term so forward on 
9929			 
9929				; get back the saved start of the token 
9929			 
9929 d9				exx 
992a e5				push hl     ; save start of token just in case it is the right one 
992b d9				exx 
992c e1				pop hl        ; save it to hl 
992d			 
992d c9				ret 
992e			 
992e			 
992e			; LIST needs to find a specific token   
992e			; FORGET needs to find a spefici token 
992e			 
992e			; SAVE needs to find all tokens by flag 
992e			; WORDS just needs to scan through all  by flag 
992e			; UWORDS needs to scan through all by flag 
992e			 
992e			 
992e			; given hl as pointer to start of dict look up string 
992e			; return hl as pointer to start of word block 
992e			; or 0 if not found 
992e			 
992e			forth_find_tok: 
992e c9				ret 
992f			 
992f			; given hl as pointer to dict structure 
992f			; move to the next dict block structure 
992f			 
992f			forth_tok_next: 
992f				; hl now points to the address of the next word pointer  
992f				; TODO skip compiled symbol for now 
992f			;	push de 
992f 23				inc hl 
9930 5e				ld e, (hl) 
9931 23				inc hl 
9932 56				ld d, (hl) 
9933 23				inc hl 
9934			 
9934 eb				ex de,hl 
9935			if DEBUG_FORTH_PARSE_NEXTWORD 
9935				push bc 
9935				ld bc, (cli_nextword) 
9935						DMARK "NXW" 
9935				CALLMONITOR 
9935				pop bc 
9935			endif 
9935			;	pop de	 
9935 c9				ret 
9936			 
9936			 
9936			 
9936			; eof 
# End of file forth_parserv5.asm
9936				include "forth_wordsv4.asm" 
9936			 
9936			; the core word dictionary v4 
9936			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9936			 
9936			; this is a linked list for each of the system words used 
9936			; user defined words will follow the same format but will be in ram 
9936			 
9936			 
9936			; 
9936			; 
9936			; define linked list: 
9936			; 
9936			; 1. compiled byte op code 
9936			; 2. len of text word 
9936			; 3. text word 
9936			; 4. ptr to next dictionary word 
9936			; 5. asm, calls etc for the word 
9936			; 
9936			;  if 1 == 0 then last word in dict  
9936			;   
9936			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9936			;  
9936			;  
9936			; create basic standard set of words 
9936			; 
9936			;  
9936			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9936			; 2DUP 2DROP 2SWAP  
9936			; @ C@ - get byte  
9936			; ! C! - store byte 
9936			; 0< true if less than zero 
9936			; 0= true if zero 
9936			; < >  
9936			; = true if same 
9936			; variables 
9936			 
9936			 
9936			; Hardware specific words I may need 
9936			; 
9936			; IN OUT  
9936			; calls to key util functions 
9936			; calls to hardward abstraction stuff 
9936			; easy control of frame buffers and lcd i/o 
9936			; keyboard  
9936			 
9936			 
9936			;DICT: macro 
9936			; op_code, len, word, next 
9936			;    word: 
9936			;    db op_code 
9936			;    ds word zero term 
9936			;    dw next 
9936			;    endm 
9936			 
9936			 
9936			 
9936			 
9936			; op code 1 is a flag for user define words which are to be handled differently 
9936			 
9936			 
9936			; 
9936			; 
9936			;    TODO on entry to a word this should be the expected environment 
9936			;    hl - tos value if number then held, if string this is the ptr 
9936			;    de -  
9936			 
9936			 
9936			; opcode ranges 
9936			; 0 - end of word dict 
9936			; 255 - user define words 
9936			 
9936			sysdict: 
9936			include "forth_opcodes.asm" 
9936			; op codes for forth keywords 
9936			; free to use code 0  
9936				OPCODE_HEAP: equ  1 
9936				OPCODE_EXEC: equ 2 
9936				OPCODE_DUP: equ 3 
9936				OPCODE_SWAP: equ 4 
9936				OPCODE_COLN: equ 5 
9936				OPCODE_SCOLN: equ 6 
9936				OPCODE_DROP: equ 7 
9936				OPCODE_DUP2: equ 8 
9936				OPCODE_DROP2: equ 9 
9936				OPCODE_SWAP2: equ 10 
9936				OPCODE_AT: equ 11 
9936				OPCODE_CAT: equ 12 
9936				OPCODE_BANG: equ 13 
9936				OPCODE_CBANG: equ 14 
9936				OPCODE_SCALL: equ 15 
9936				OPCODE_DEPTH: equ 16 
9936				OPCODE_OVER: equ 17 
9936				OPCODE_PAUSE: equ 18 
9936				OPCODE_PAUSES: equ 19 
9936				OPCODE_ROT: equ 20 
9936			;free to reuse	OPCODE_WORDS: equ 21 
9936			        OPCODE_NOT: equ 21 
9936				OPCODE_UWORDS: equ 22 
9936				OPCODE_BP: equ 23 
9936				OPCODE_MONITOR: equ 24  
9936				OPCODE_MALLOC: equ 25 
9936				OPCODE_FREE: equ 26 
9936				OPCODE_LIST: equ 27 
9936				OPCODE_FORGET: equ 28 
9936				OPCODE_NOP: equ 29 
9936				OPCODE_COMO: equ 30 
9936				OPCODE_COMC: equ 31 
9936			;free to reuse	OPCODE_ENDCORE: equ 32 
9936				OPCODE_AFTERSOUND: equ 33 
9936				OPCODE_GP2: equ 34 
9936				OPCODE_GP3: equ 35 
9936				OPCODE_GP4: equ 36 
9936				OPCODE_SIN: equ 37 
9936				OPCODE_SOUT: equ 38 
9936				OPCODE_SPIO: equ 39 
9936				OPCODE_SPICEH: equ 40 
9936				OPCODE_SPIOb: equ 41 
9936				OPCODE_SPII: equ 42 
9936				OPCODE_SESEL: equ 43 
9936				OPCODE_CARTDEV: equ 44 
9936			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9936				OPCODE_FB: equ 46 
9936				OPCODE_EMIT: equ 47 
9936				OPCODE_DOTH: equ 48 
9936				OPCODE_DOTF: equ 49 
9936				OPCODE_DOT: equ 50 
9936				OPCODE_CLS: equ 51 
9936				OPCODE_DRAW: equ 52 
9936				OPCODE_DUMP: equ 53 
9936				OPCODE_CDUMP: equ 54 
9936				OPCODE_DAT: equ 55 
9936				OPCODE_HOME: equ 56 
9936				OPCODE_SPACE: equ 57 
9936				OPCODE_SPACES: equ 58 
9936				OPCODE_SCROLL: equ 59 
9936				OPCODE_ATQ: equ 60 
9936				OPCODE_AUTODSP: equ 61 
9936				OPCODE_MENU: equ 62 
9936			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9936				OPCODE_THEN: equ 64 
9936				OPCODE_ELSE: equ 65 
9936				OPCODE_DO: equ 66 
9936				OPCODE_LOOP: equ 67 
9936				OPCODE_I: equ 68 
9936				OPCODE_DLOOP: equ 69  
9936				OPCODE_REPEAT: equ 70  
9936				OPCODE_UNTIL: equ 71 
9936				OPCODE_ENDFLOW: equ 72 
9936				OPCODE_WAITK: equ 73 
9936				OPCODE_ACCEPT: equ 74 
9936				OPCODE_EDIT: equ 75 
9936			;free to reuse	OPCODE_ENDKEY: equ 76 
9936				OPCODE_LZERO: equ 77 
9936				OPCODE_TZERO: equ 78 
9936				OPCODE_LESS: equ 79 
9936				OPCODE_GT: equ 80 
9936				OPCODE_EQUAL: equ 81  
9936			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9936				OPCODE_NEG: equ 83 
9936				OPCODE_DIV: equ 84 
9936				OPCODE_MUL: equ 85 
9936				OPCODE_MIN: equ 86 
9936				OPCODE_MAX: equ 87 
9936				OPCODE_RND16: equ 88 
9936				OPCODE_RND8: equ 89 
9936				OPCODE_RND: equ 90 
9936			;free to reuse	OPCODE_ENDMATHS: equ 91  
9936				OPCODE_BYNAME: equ 92 
9936				OPCODE_DIR: equ 93 
9936				OPCODE_SAVE: equ 94 
9936				OPCODE_LOAD: equ 95 
9936				OPCODE_BSAVE: equ 96 
9936				OPCODE_BLOAD: equ 97 
9936				OPCODE_SEO: equ 98  
9936				OPCODE_SEI: equ 99 
9936				OPCODE_SFREE: equ 100 
9936				OPCODE_SIZE: equ 101 
9936				OPCODE_CREATE: equ 102 
9936				OPCODE_APPEND: equ 103 
9936				OPCODE_SDEL: equ 104 
9936				OPCODE_OPEN: equ 105 
9936				OPCODE_READ: equ 106 
9936				OPCODE_EOF: equ 106 
9936				OPCODE_FORMAT: equ 107 
9936				OPCODE_LABEL: equ 108 
9936				OPCODE_LABELS: equ 109 
9936			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9936				OPCODE_UPPER: equ 111 
9936				OPCODE_LOWER: equ 112 
9936				OPCODE_SUBSTR: equ 113 
9936				OPCODE_LEFT: equ 114 
9936				OPCODE_RIGHT: equ 115 
9936				OPCODE_STR2NUM: equ 116 
9936				OPCODE_NUM2STR: equ 117 
9936				OPCODE_CONCAT: equ 118 
9936				OPCODE_FIND: equ 119 
9936				OPCODE_LEN: equ 120 
9936				OPCODE_CHAR: equ 121 
9936			; free to reuse	OPCODE_STRLEN: equ 122 
9936			; free to reuse	OPCODE_ENDSTR: equ 123 
9936				OPCODE_V0S: equ 124 
9936				OPCODE_V0Q: equ 125 
9936				OPCODE_V1S: equ 126 
9936				OPCODE_V1Q: equ 127 
9936				OPCODE_V2S: equ 128 
9936				OPCODE_V2Q: equ 129 
9936				OPCODE_V3S: equ 130 
9936				OPCODE_V3Q: equ 131 
9936			;free to reuse	OPCODE_END: equ 132 
9936				OPCODE_ZDUP: equ 133 
9936			 
9936			; eof 
# End of file forth_opcodes.asm
9936			 
9936			include "forth_words_core.asm" 
9936			 
9936			; | ## Core Words 
9936			 
9936			;if MALLOC_4 
9936			 
9936			.HEAP: 
9936				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9936 15				db WORD_SYS_CORE+OPCODE_HEAP             
9937 75 99			dw .EXEC            
9939 05				db 4 + 1 
993a .. 00			db "HEAP",0              
993f				endm 
# End of macro CWHEAD
993f			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
993f			; | | u1 - Current number of bytes in the heap 
993f			; | | u2 - Remaining bytes left on the heap 
993f			; | |  
993f			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
993f			 
993f			 
993f					if DEBUG_FORTH_WORDS_KEY 
993f						DMARK "HEP" 
993f f5				push af  
9940 3a 54 99			ld a, (.dmark)  
9943 32 7a ee			ld (debug_mark),a  
9946 3a 55 99			ld a, (.dmark+1)  
9949 32 7b ee			ld (debug_mark+1),a  
994c 3a 56 99			ld a, (.dmark+2)  
994f 32 7c ee			ld (debug_mark+2),a  
9952 18 03			jr .pastdmark  
9954 ..			.dmark: db "HEP"  
9957 f1			.pastdmark: pop af  
9958			endm  
# End of macro DMARK
9958						CALLMONITOR 
9958 cd 7f 90			call break_point_state  
995b				endm  
# End of macro CALLMONITOR
995b					endif 
995b 2a be c6				ld hl, (free_list )      
995e 11 c3 c6				ld de, heap_start 
9961			 
9961 ed 52				sbc hl, de  
9963			 
9963 cd 09 96				call forth_push_numhl 
9966			 
9966			 
9966 ed 5b be c6			ld de, (free_list )      
996a 21 69 e3				ld hl, heap_end 
996d			 
996d ed 52				sbc hl, de 
996f			 
996f cd 09 96				call forth_push_numhl 
9972					 
9972			 
9972					 
9972			 
9972			 
9972			 
9972					NEXTW 
9972 c3 de 97			jp macro_next 
9975				endm 
# End of macro NEXTW
9975			;endif 
9975			 
9975			.EXEC: 
9975				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9975 16				db WORD_SYS_CORE+OPCODE_EXEC             
9976 bb 99			dw .STKEXEC            
9978 05				db 4 + 1 
9979 .. 00			db "EXEC",0              
997e				endm 
# End of macro CWHEAD
997e			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
997e			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
997e			; | | 
997e			; | |   
997e				STACKFRAME OFF $5efe $5f9f 
997e				if DEBUG_STACK_IMB 
997e					if OFF 
997e						exx 
997e						ld de, $5efe 
997e						ld a, d 
997e						ld hl, curframe 
997e						call hexout 
997e						ld a, e 
997e						ld hl, curframe+2 
997e						call hexout 
997e						ld hl, $5efe 
997e						push hl 
997e						ld hl, $5f9f 
997e						push hl 
997e						exx 
997e					endif 
997e				endif 
997e			endm 
# End of macro STACKFRAME
997e			 
997e					if DEBUG_FORTH_WORDS_KEY 
997e						DMARK "EXE" 
997e f5				push af  
997f 3a 93 99			ld a, (.dmark)  
9982 32 7a ee			ld (debug_mark),a  
9985 3a 94 99			ld a, (.dmark+1)  
9988 32 7b ee			ld (debug_mark+1),a  
998b 3a 95 99			ld a, (.dmark+2)  
998e 32 7c ee			ld (debug_mark+2),a  
9991 18 03			jr .pastdmark  
9993 ..			.dmark: db "EXE"  
9996 f1			.pastdmark: pop af  
9997			endm  
# End of macro DMARK
9997						CALLMONITOR 
9997 cd 7f 90			call break_point_state  
999a				endm  
# End of macro CALLMONITOR
999a					endif 
999a			 
999a				FORTH_DSP_VALUEHL 
999a cd a4 96			call macro_dsp_valuehl 
999d				endm 
# End of macro FORTH_DSP_VALUEHL
999d			 
999d				FORTH_DSP_POP 
999d cd 24 97			call macro_forth_dsp_pop 
99a0				endm 
# End of macro FORTH_DSP_POP
99a0			 
99a0					if DEBUG_FORTH_WORDS 
99a0						DMARK "EX1" 
99a0						CALLMONITOR 
99a0					endif 
99a0			;	ld e,(hl) 
99a0			;	inc hl 
99a0			;	ld d,(hl) 
99a0			;	ex de,hl 
99a0			 
99a0					if DEBUG_FORTH_WORDS 
99a0						DMARK "EX2" 
99a0						CALLMONITOR 
99a0					endif 
99a0 e5				push hl 
99a1			 
99a1				;ld a, 0 
99a1				;ld a, FORTH_END_BUFFER 
99a1 cd 19 8d			call strlenz 
99a4 23				inc hl   ; include zero term to copy 
99a5 06 00			ld b,0 
99a7 4d				ld c,l 
99a8 e1				pop hl 
99a9 11 74 e4			ld de, execscratch 
99ac					if DEBUG_FORTH_WORDS 
99ac						DMARK "EX3" 
99ac						CALLMONITOR 
99ac					endif 
99ac ed b0			ldir 
99ae			 
99ae			 
99ae 21 74 e4			ld hl, execscratch 
99b1			 
99b1					if DEBUG_FORTH_WORDS 
99b1						DMARK "EXe" 
99b1						CALLMONITOR 
99b1					endif 
99b1			 
99b1 cd 2c 98			call forthparse 
99b4 cd 6c 98			call forthexec 
99b7			;	call forthexec_cleanup 
99b7			;	call forthparse 
99b7			;	call forthexec 
99b7			 
99b7				STACKFRAMECHK OFF $5efe $5f9f 
99b7				if DEBUG_STACK_IMB 
99b7					if OFF 
99b7						exx 
99b7						ld hl, $5f9f 
99b7						pop de   ; $5f9f 
99b7						call cmp16 
99b7						jr nz, .spnosame 
99b7						ld hl, $5efe 
99b7						pop de   ; $5efe 
99b7						call cmp16 
99b7						jr z, .spfrsame 
99b7						.spnosame: call showsperror 
99b7						.spfrsame: nop 
99b7						exx 
99b7					endif 
99b7				endif 
99b7			endm 
# End of macro STACKFRAMECHK
99b7			 
99b7				; an immediate word so no need to process any more words 
99b7 c9				ret 
99b8				NEXTW 
99b8 c3 de 97			jp macro_next 
99bb				endm 
# End of macro NEXTW
99bb			 
99bb			; dead code - old version  
99bb			;	FORTH_RSP_NEXT 
99bb			 
99bb			;  
99bb			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
99bb			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
99bb			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
99bb			;	push hl 
99bb			;	push de 
99bb			;	push bc 
99bb			; 
99bb			; 
99bb			;		if DEBUG_FORTH_WORDS_KEY 
99bb			;			DMARK "EXR" 
99bb			;			CALLMONITOR 
99bb			;		endif 
99bb			; 
99bb			; 
99bb			; 
99bb			;	;v5 FORTH_DSP_VALUE 
99bb			;	FORTH_DSP_VALUEHL 
99bb			; 
99bb			;	; TODO do string type checks 
99bb			; 
99bb			;;v5	inc hl   ; skip type 
99bb			; 
99bb			;	push hl  ; source code  
99bb			;		if DEBUG_FORTH_WORDS 
99bb			;			DMARK "EX1" 
99bb			;			CALLMONITOR 
99bb			;		endif 
99bb			;	ld a, 0 
99bb			;	call strlent 
99bb			; 
99bb			;	inc hl 
99bb			;	inc hl 
99bb			;	inc hl 
99bb			;	inc hl 
99bb			; 
99bb			;	push hl    ; size 
99bb			; 
99bb			;		if DEBUG_FORTH_WORDS 
99bb			;			DMARK "EX2" 
99bb			;			CALLMONITOR 
99bb			;		endif 
99bb			;	call malloc 
99bb			; 
99bb			;	ex de, hl    ; de now contains malloc area 
99bb			;	pop bc   	; get byte count 
99bb			;	pop hl      ; get string to copy 
99bb			; 
99bb			;	push de     ; save malloc for free later 
99bb			; 
99bb			;		if DEBUG_FORTH_WORDS 
99bb			;			DMARK "EX3" 
99bb			;			CALLMONITOR 
99bb			;		endif 
99bb			;	ldir       ; duplicate string 
99bb			; 
99bb			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
99bb			;	 
99bb			;	; TODO fix the parse would be better than this...  
99bb			;	ex de, hl 
99bb			;	dec hl 
99bb			;	ld a, 0 
99bb			;	ld (hl), a 
99bb			;	dec hl 
99bb			;	ld a, ' ' 
99bb			;	ld (hl), a 
99bb			;	dec hl 
99bb			;	ld (hl), a 
99bb			; 
99bb			;	dec hl 
99bb			;	ld (hl), a 
99bb			; 
99bb			; 
99bb			;	FORTH_DSP_POP  
99bb			; 
99bb			;	pop hl     
99bb			;	push hl    ; save malloc area 
99bb			; 
99bb			;		if DEBUG_FORTH_WORDS 
99bb			;			DMARK "EX4" 
99bb			;			CALLMONITOR 
99bb			;		endif 
99bb			; 
99bb			;	call forthparse 
99bb			;	call forthexec 
99bb			;	 
99bb			;	pop hl 
99bb			;	if DEBUG_FORTH_WORDS 
99bb			;		DMARK "EX5" 
99bb			;		CALLMONITOR 
99bb			;	endif 
99bb			; 
99bb			;	if FORTH_ENABLE_FREE 
99bb			;	call free 
99bb			;	endif 
99bb			; 
99bb			;	if DEBUG_FORTH_WORDS 
99bb			;		DMARK "EX6" 
99bb			;		CALLMONITOR 
99bb			;	endif 
99bb			; 
99bb			;	pop bc 
99bb			;	pop de 
99bb			;	pop hl 
99bb			;;	FORTH_RSP_POP	  
99bb			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
99bb			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
99bb			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
99bb			; 
99bb			;	if DEBUG_FORTH_WORDS 
99bb			;		DMARK "EX7" 
99bb			;		CALLMONITOR 
99bb			;	endif 
99bb			;	NEXTW 
99bb			 
99bb			.STKEXEC: 
99bb				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
99bb 3f				db WORD_SYS_CORE+43             
99bc 56 9a			dw .ZDUP            
99be 08				db 7 + 1 
99bf .. 00			db "STKEXEC",0              
99c7				endm 
# End of macro CWHEAD
99c7			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
99c7			 
99c7			 
99c7					if DEBUG_FORTH_WORDS_KEY 
99c7						DMARK "STX" 
99c7 f5				push af  
99c8 3a dc 99			ld a, (.dmark)  
99cb 32 7a ee			ld (debug_mark),a  
99ce 3a dd 99			ld a, (.dmark+1)  
99d1 32 7b ee			ld (debug_mark+1),a  
99d4 3a de 99			ld a, (.dmark+2)  
99d7 32 7c ee			ld (debug_mark+2),a  
99da 18 03			jr .pastdmark  
99dc ..			.dmark: db "STX"  
99df f1			.pastdmark: pop af  
99e0			endm  
# End of macro DMARK
99e0						CALLMONITOR 
99e0 cd 7f 90			call break_point_state  
99e3				endm  
# End of macro CALLMONITOR
99e3					endif 
99e3			 
99e3				FORTH_DSP_VALUEHL 
99e3 cd a4 96			call macro_dsp_valuehl 
99e6				endm 
# End of macro FORTH_DSP_VALUEHL
99e6			 
99e6 22 63 eb			ld (store_tmp1), hl    ; count 
99e9			 
99e9				FORTH_DSP_POP 
99e9 cd 24 97			call macro_forth_dsp_pop 
99ec				endm 
# End of macro FORTH_DSP_POP
99ec			.stkexec1: 
99ec 2a 63 eb			ld hl, (store_tmp1)   ; count 
99ef 3e 00			ld a, 0 
99f1 bd				cp l 
99f2 c8				ret z 
99f3			 
99f3 2b				dec hl 
99f4 22 63 eb			ld (store_tmp1), hl    ; count 
99f7				 
99f7				FORTH_DSP_VALUEHL 
99f7 cd a4 96			call macro_dsp_valuehl 
99fa				endm 
# End of macro FORTH_DSP_VALUEHL
99fa e5				push hl 
99fb				 
99fb				FORTH_DSP_POP 
99fb cd 24 97			call macro_forth_dsp_pop 
99fe				endm 
# End of macro FORTH_DSP_POP
99fe			 
99fe cd 19 8d			call strlenz 
9a01 23				inc hl   ; include zero term to copy 
9a02 06 00			ld b,0 
9a04 4d				ld c,l 
9a05 e1				pop hl 
9a06 11 74 e4			ld de, execscratch 
9a09					if DEBUG_FORTH_WORDS 
9a09						DMARK "EX3" 
9a09						CALLMONITOR 
9a09					endif 
9a09 ed b0			ldir 
9a0b			 
9a0b			 
9a0b 21 74 e4			ld hl, execscratch 
9a0e			 
9a0e					if DEBUG_FORTH_WORDS 
9a0e						DMARK "EXe" 
9a0e						CALLMONITOR 
9a0e					endif 
9a0e			 
9a0e cd 2c 98			call forthparse 
9a11 cd 6c 98			call forthexec 
9a14			 
9a14 c3 ec 99			jp .stkexec1 
9a17			 
9a17 c9				ret 
9a18			 
9a18			 
9a18			.DUP: 
9a18				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9a18 17				db WORD_SYS_CORE+OPCODE_DUP             
9a19 56 9a			dw .ZDUP            
9a1b 04				db 3 + 1 
9a1c .. 00			db "DUP",0              
9a20				endm 
# End of macro CWHEAD
9a20			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9a20			 
9a20					if DEBUG_FORTH_WORDS_KEY 
9a20						DMARK "DUP" 
9a20 f5				push af  
9a21 3a 35 9a			ld a, (.dmark)  
9a24 32 7a ee			ld (debug_mark),a  
9a27 3a 36 9a			ld a, (.dmark+1)  
9a2a 32 7b ee			ld (debug_mark+1),a  
9a2d 3a 37 9a			ld a, (.dmark+2)  
9a30 32 7c ee			ld (debug_mark+2),a  
9a33 18 03			jr .pastdmark  
9a35 ..			.dmark: db "DUP"  
9a38 f1			.pastdmark: pop af  
9a39			endm  
# End of macro DMARK
9a39						CALLMONITOR 
9a39 cd 7f 90			call break_point_state  
9a3c				endm  
# End of macro CALLMONITOR
9a3c					endif 
9a3c			 
9a3c					FORTH_DSP 
9a3c cd 89 96			call macro_forth_dsp 
9a3f				endm 
# End of macro FORTH_DSP
9a3f			 
9a3f 7e					ld a, (HL) 
9a40 fe 01				cp DS_TYPE_STR 
9a42 20 09				jr nz, .dupinum 
9a44			 
9a44					; push another string 
9a44			 
9a44					FORTH_DSP_VALUEHL     		 
9a44 cd a4 96			call macro_dsp_valuehl 
9a47				endm 
# End of macro FORTH_DSP_VALUEHL
9a47			 
9a47				if DEBUG_FORTH_WORDS 
9a47					DMARK "DUs" 
9a47					CALLMONITOR 
9a47				endif 
9a47 cd 1b 96				call forth_push_str 
9a4a			 
9a4a					NEXTW 
9a4a c3 de 97			jp macro_next 
9a4d				endm 
# End of macro NEXTW
9a4d			 
9a4d			 
9a4d			.dupinum: 
9a4d					 
9a4d			 
9a4d			 
9a4d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9a4d cd a4 96			call macro_dsp_valuehl 
9a50				endm 
# End of macro FORTH_DSP_VALUEHL
9a50			 
9a50				; TODO add floating point number detection 
9a50			 
9a50				if DEBUG_FORTH_WORDS 
9a50					DMARK "DUi" 
9a50					CALLMONITOR 
9a50				endif 
9a50			 
9a50 cd 09 96				call forth_push_numhl 
9a53					NEXTW 
9a53 c3 de 97			jp macro_next 
9a56				endm 
# End of macro NEXTW
9a56			.ZDUP: 
9a56				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
9a56 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9a57 8e 9a			dw .SWAP            
9a59 05				db 4 + 1 
9a5a .. 00			db "?DUP",0              
9a5f				endm 
# End of macro CWHEAD
9a5f			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
9a5f			 
9a5f					if DEBUG_FORTH_WORDS_KEY 
9a5f						DMARK "qDU" 
9a5f f5				push af  
9a60 3a 74 9a			ld a, (.dmark)  
9a63 32 7a ee			ld (debug_mark),a  
9a66 3a 75 9a			ld a, (.dmark+1)  
9a69 32 7b ee			ld (debug_mark+1),a  
9a6c 3a 76 9a			ld a, (.dmark+2)  
9a6f 32 7c ee			ld (debug_mark+2),a  
9a72 18 03			jr .pastdmark  
9a74 ..			.dmark: db "qDU"  
9a77 f1			.pastdmark: pop af  
9a78			endm  
# End of macro DMARK
9a78						CALLMONITOR 
9a78 cd 7f 90			call break_point_state  
9a7b				endm  
# End of macro CALLMONITOR
9a7b					endif 
9a7b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9a7b cd a4 96			call macro_dsp_valuehl 
9a7e				endm 
# End of macro FORTH_DSP_VALUEHL
9a7e			 
9a7e e5					push hl 
9a7f			 
9a7f					; is it a zero? 
9a7f			 
9a7f 3e 00				ld a, 0 
9a81 84					add h 
9a82 85					add l 
9a83			 
9a83 e1					pop hl 
9a84			 
9a84 fe 00				cp 0 
9a86 28 03				jr z, .dup2orig 
9a88			 
9a88			 
9a88 cd 09 96				call forth_push_numhl 
9a8b			 
9a8b			 
9a8b				; TODO add floating point number detection 
9a8b			 
9a8b			.dup2orig: 
9a8b			 
9a8b					NEXTW 
9a8b c3 de 97			jp macro_next 
9a8e				endm 
# End of macro NEXTW
9a8e			.SWAP: 
9a8e				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
9a8e 18				db WORD_SYS_CORE+OPCODE_SWAP             
9a8f cd 9a			dw .COLN            
9a91 05				db 4 + 1 
9a92 .. 00			db "SWAP",0              
9a97				endm 
# End of macro CWHEAD
9a97			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
9a97					if DEBUG_FORTH_WORDS_KEY 
9a97						DMARK "SWP" 
9a97 f5				push af  
9a98 3a ac 9a			ld a, (.dmark)  
9a9b 32 7a ee			ld (debug_mark),a  
9a9e 3a ad 9a			ld a, (.dmark+1)  
9aa1 32 7b ee			ld (debug_mark+1),a  
9aa4 3a ae 9a			ld a, (.dmark+2)  
9aa7 32 7c ee			ld (debug_mark+2),a  
9aaa 18 03			jr .pastdmark  
9aac ..			.dmark: db "SWP"  
9aaf f1			.pastdmark: pop af  
9ab0			endm  
# End of macro DMARK
9ab0						CALLMONITOR 
9ab0 cd 7f 90			call break_point_state  
9ab3				endm  
# End of macro CALLMONITOR
9ab3					endif 
9ab3			 
9ab3					FORTH_DSP_VALUEHL 
9ab3 cd a4 96			call macro_dsp_valuehl 
9ab6				endm 
# End of macro FORTH_DSP_VALUEHL
9ab6 e5					push hl     ; w2 
9ab7			 
9ab7					FORTH_DSP_POP 
9ab7 cd 24 97			call macro_forth_dsp_pop 
9aba				endm 
# End of macro FORTH_DSP_POP
9aba			 
9aba					FORTH_DSP_VALUEHL 
9aba cd a4 96			call macro_dsp_valuehl 
9abd				endm 
# End of macro FORTH_DSP_VALUEHL
9abd			 
9abd					FORTH_DSP_POP 
9abd cd 24 97			call macro_forth_dsp_pop 
9ac0				endm 
# End of macro FORTH_DSP_POP
9ac0			 
9ac0 d1					pop de     ; w2	, hl = w1 
9ac1			 
9ac1 eb					ex de, hl 
9ac2 d5					push de 
9ac3			 
9ac3 cd 09 96				call forth_push_numhl 
9ac6			 
9ac6 e1					pop hl 
9ac7			 
9ac7 cd 09 96				call forth_push_numhl 
9aca					 
9aca			 
9aca					NEXTW 
9aca c3 de 97			jp macro_next 
9acd				endm 
# End of macro NEXTW
9acd			.COLN: 
9acd				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
9acd 19				db WORD_SYS_CORE+OPCODE_COLN             
9ace 8f 9b			dw .SCOLN            
9ad0 02				db 1 + 1 
9ad1 .. 00			db ":",0              
9ad3				endm 
# End of macro CWHEAD
9ad3			; | : ( -- )         Create new word | DONE 
9ad3			 
9ad3					if DEBUG_FORTH_WORDS_KEY 
9ad3						DMARK "CLN" 
9ad3 f5				push af  
9ad4 3a e8 9a			ld a, (.dmark)  
9ad7 32 7a ee			ld (debug_mark),a  
9ada 3a e9 9a			ld a, (.dmark+1)  
9add 32 7b ee			ld (debug_mark+1),a  
9ae0 3a ea 9a			ld a, (.dmark+2)  
9ae3 32 7c ee			ld (debug_mark+2),a  
9ae6 18 03			jr .pastdmark  
9ae8 ..			.dmark: db "CLN"  
9aeb f1			.pastdmark: pop af  
9aec			endm  
# End of macro DMARK
9aec						CALLMONITOR 
9aec cd 7f 90			call break_point_state  
9aef				endm  
# End of macro CALLMONITOR
9aef					endif 
9aef				STACKFRAME OFF $8efe $989f 
9aef				if DEBUG_STACK_IMB 
9aef					if OFF 
9aef						exx 
9aef						ld de, $8efe 
9aef						ld a, d 
9aef						ld hl, curframe 
9aef						call hexout 
9aef						ld a, e 
9aef						ld hl, curframe+2 
9aef						call hexout 
9aef						ld hl, $8efe 
9aef						push hl 
9aef						ld hl, $989f 
9aef						push hl 
9aef						exx 
9aef					endif 
9aef				endif 
9aef			endm 
# End of macro STACKFRAME
9aef				; get parser buffer length  of new word 
9aef			 
9aef				 
9aef			 
9aef					; move tok past this to start of name defintition 
9aef					; TODO get word to define 
9aef					; TODO Move past word token 
9aef					; TODO get length of string up to the ';' 
9aef			 
9aef 2a 76 e6			ld hl, (os_tok_ptr) 
9af2 23				inc hl 
9af3 23				inc hl 
9af4			 
9af4 3e 3b			ld a, ';' 
9af6 cd 24 8d			call strlent 
9af9			 
9af9 7d				ld a,l 
9afa 32 75 e5			ld (os_new_parse_len), a 
9afd			 
9afd			 
9afd			if DEBUG_FORTH_UWORD 
9afd				ld de, (os_tok_ptr) 
9afd						DMARK ":01" 
9afd				CALLMONITOR 
9afd			endif 
9afd			 
9afd			; 
9afd			;  new word memory layout: 
9afd			;  
9afd			;    : adg 6666 ;  
9afd			; 
9afd			;    db   1     ; user defined word  
9afd 23				inc hl    
9afe			;    dw   sysdict 
9afe 23				inc hl 
9aff 23				inc hl 
9b00			;    db <word len>+1 (for null) 
9b00 23				inc hl 
9b01			;    db .... <word> 
9b01			; 
9b01			 
9b01 23				inc hl    ; some extras for the word preamble before the above 
9b02 23				inc hl 
9b03 23				inc hl 
9b04 23				inc hl 
9b05 23				inc hl 
9b06 23				inc hl 
9b07 23				inc hl  
9b08 23				inc hl 
9b09 23				inc hl 
9b0a 23				inc hl 
9b0b 23				inc hl 
9b0c 23				inc hl 
9b0d 23				inc hl 
9b0e 23				inc hl     ; TODO how many do we really need?     maybe only 6 
9b0f			;       exec word buffer 
9b0f			;	<ptr word>   
9b0f 23				inc hl 
9b10 23				inc hl 
9b11			;       <word list><null term> 7F final term 
9b11			 
9b11			 
9b11			if DEBUG_FORTH_UWORD 
9b11						DMARK ":02" 
9b11				CALLMONITOR 
9b11			endif 
9b11			 
9b11				 
9b11					; malloc the size 
9b11			 
9b11 cd 82 8d				call malloc 
9b14 22 73 e5				ld (os_new_malloc), hl     ; save malloc start 
9b17			 
9b17			;    db   1     ; user defined word  
9b17 3e 01				ld a, WORD_SYS_UWORD  
9b19 77					ld (hl), a 
9b1a				 
9b1a 23				inc hl    
9b1b			;    dw   sysdict 
9b1b 11 36 99			ld de, sysdict       ; continue on with the scan to the system dict 
9b1e 73				ld (hl), e 
9b1f 23				inc hl 
9b20 72				ld (hl), d 
9b21 23				inc hl 
9b22			 
9b22			 
9b22			;    Setup dict word 
9b22			 
9b22 23				inc hl 
9b23 22 79 e5			ld (os_new_work_ptr), hl     ; save start of dict word  
9b26			 
9b26				; 1. get length of dict word 
9b26			 
9b26			 
9b26 2a 76 e6			ld hl, (os_tok_ptr) 
9b29 23				inc hl 
9b2a 23				inc hl    ; position to start of dict word 
9b2b 3e 00			ld a, 0 
9b2d cd 24 8d			call strlent 
9b30			 
9b30			 
9b30 23				inc hl    ; to include null??? 
9b31			 
9b31				; write length of dict word 
9b31			 
9b31 ed 5b 79 e5		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9b35 1b				dec de 
9b36 eb				ex de, hl 
9b37 73				ld (hl), e 
9b38 eb				ex de, hl 
9b39			 
9b39				 
9b39			 
9b39				; copy  
9b39 4d				ld c, l 
9b3a 06 00			ld b, 0 
9b3c ed 5b 79 e5		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9b40 2a 76 e6			ld hl, (os_tok_ptr) 
9b43 23				inc hl 
9b44 23				inc hl    ; position to start of dict word 
9b45				 
9b45			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
9b45				 
9b45				; TODO need to convert word to upper case 
9b45			 
9b45			ucasetok:	 
9b45 7e				ld a,(hl) 
9b46 cd 10 8d			call toUpper 
9b49 77				ld (hl),a 
9b4a ed a0			ldi 
9b4c f2 45 9b		 	jp p, ucasetok 
9b4f			 
9b4f			 
9b4f			 
9b4f				; de now points to start of where the word body code should be placed 
9b4f ed 53 79 e5		ld (os_new_work_ptr), de 
9b53				; hl now points to the words to throw at forthexec which needs to be copied 
9b53 22 7b e5			ld (os_new_src_ptr), hl 
9b56			 
9b56				; TODO add 'call to forthexec' 
9b56			 
9b56			if DEBUG_FORTH_UWORD 
9b56				push bc 
9b56				ld bc, (os_new_malloc) 
9b56						DMARK ":0x" 
9b56				CALLMONITOR 
9b56				pop bc 
9b56			endif 
9b56			 
9b56			 
9b56				; create word preamble which should be: 
9b56			 
9b56			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
9b56			 
9b56				;    ld hl, <word code> 
9b56				;    jp user_exec 
9b56			        ;    <word code bytes> 
9b56			 
9b56			 
9b56			;	inc de     ; TODO ??? or are we already past the word's null 
9b56 eb				ex de, hl 
9b57			 
9b57 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
9b59			 
9b59 23				inc hl 
9b5a 22 7f e5			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
9b5d 23				inc hl 
9b5e			 
9b5e 23				inc hl 
9b5f 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
9b61			 
9b61 01 cc b2			ld bc, user_exec 
9b64 23				inc hl 
9b65 71				ld (hl), c     ; poke address of user_exec 
9b66 23				inc hl 
9b67 70				ld (hl), b     
9b68			 ; 
9b68			;	inc hl 
9b68			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9b68			; 
9b68			; 
9b68			;	ld bc, macro_forth_rsp_next 
9b68			;	inc hl 
9b68			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
9b68			;	inc hl 
9b68			;	ld (hl), b     
9b68			 ; 
9b68			;	inc hl 
9b68			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9b68			; 
9b68			; 
9b68			;	inc hl 
9b68			;	ld bc, forthexec 
9b68			;	ld (hl), c     ; poke address of forthexec 
9b68			;	inc hl 
9b68			;	ld (hl), b      
9b68			; 
9b68			;	inc hl 
9b68			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
9b68			; 
9b68			;	ld bc, user_dict_next 
9b68			;	inc hl 
9b68			;	ld (hl), c     ; poke address of forthexec 
9b68			;	inc hl 
9b68			;	ld (hl), b      
9b68			 
9b68				; hl is now where we need to copy the word byte data to save this 
9b68			 
9b68 23				inc hl 
9b69 22 7d e5			ld (os_new_exec), hl 
9b6c				 
9b6c				; copy definition 
9b6c			 
9b6c eb				ex de, hl 
9b6d			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
9b6d			;	inc de    ; skip the PC for this parse 
9b6d 3a 75 e5			ld a, (os_new_parse_len) 
9b70 4f				ld c, a 
9b71 06 00			ld b, 0 
9b73 ed b0			ldir		 ; copy defintion 
9b75			 
9b75			 
9b75				; poke the address of where the new word bytes live for forthexec 
9b75			 
9b75 2a 7f e5			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
9b78			 
9b78 ed 5b 7d e5		ld de, (os_new_exec)      
9b7c				 
9b7c 73				ld (hl), e 
9b7d 23				inc hl 
9b7e 72				ld (hl), d 
9b7f			 
9b7f					; TODO copy last user dict word next link to this word 
9b7f					; TODO update last user dict word to point to this word 
9b7f			; 
9b7f			; hl f923 de 812a ; bc 811a 
9b7f			 
9b7f			if DEBUG_FORTH_UWORD 
9b7f				push bc 
9b7f				ld bc, (os_new_malloc) 
9b7f						DMARK ":0A" 
9b7f				CALLMONITOR 
9b7f				pop bc 
9b7f			endif 
9b7f			if DEBUG_FORTH_UWORD 
9b7f				push bc 
9b7f				ld bc, (os_new_malloc) 
9b7f				inc bc 
9b7f				inc bc 
9b7f				inc bc 
9b7f				inc bc 
9b7f				inc bc 
9b7f				inc bc 
9b7f				inc bc 
9b7f				inc bc 
9b7f			 
9b7f						DMARK ":0B" 
9b7f				CALLMONITOR 
9b7f				pop bc 
9b7f			endif 
9b7f			 
9b7f			; update word dict linked list for new word 
9b7f			 
9b7f			 
9b7f 2a 72 e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
9b82 23			inc hl     ; move to next work linked list ptr 
9b83			 
9b83 ed 5b 73 e5	ld de, (os_new_malloc)		 ; new next word 
9b87 73			ld (hl), e 
9b88 23			inc hl 
9b89 72			ld (hl), d 
9b8a			 
9b8a			if DEBUG_FORTH_UWORD 
9b8a				ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
9b8a			endif 
9b8a			 
9b8a ed 53 72 e6	ld (os_last_new_uword), de      ; update last new uword ptr 
9b8e			 
9b8e			 
9b8e			if DEBUG_FORTH_UWORD 
9b8e						DMARK ":0+" 
9b8e				CALLMONITOR 
9b8e			endif 
9b8e			 
9b8e				STACKFRAMECHK OFF $8efe $989f 
9b8e				if DEBUG_STACK_IMB 
9b8e					if OFF 
9b8e						exx 
9b8e						ld hl, $989f 
9b8e						pop de   ; $989f 
9b8e						call cmp16 
9b8e						jr nz, .spnosame 
9b8e						ld hl, $8efe 
9b8e						pop de   ; $8efe 
9b8e						call cmp16 
9b8e						jr z, .spfrsame 
9b8e						.spnosame: call showsperror 
9b8e						.spfrsame: nop 
9b8e						exx 
9b8e					endif 
9b8e				endif 
9b8e			endm 
# End of macro STACKFRAMECHK
9b8e			 
9b8e c9			ret    ; dont process any remaining parser tokens as they form new word 
9b8f			 
9b8f			 
9b8f			 
9b8f			 
9b8f			;		NEXT 
9b8f			.SCOLN: 
9b8f			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
9b8f 06				db OPCODE_SCOLN 
9b90 bf 9b			dw .DROP 
9b92 02				db 2 
9b93 .. 00			db ";",0           
9b95			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
9b95					if DEBUG_FORTH_WORDS_KEY 
9b95						DMARK "SCN" 
9b95 f5				push af  
9b96 3a aa 9b			ld a, (.dmark)  
9b99 32 7a ee			ld (debug_mark),a  
9b9c 3a ab 9b			ld a, (.dmark+1)  
9b9f 32 7b ee			ld (debug_mark+1),a  
9ba2 3a ac 9b			ld a, (.dmark+2)  
9ba5 32 7c ee			ld (debug_mark+2),a  
9ba8 18 03			jr .pastdmark  
9baa ..			.dmark: db "SCN"  
9bad f1			.pastdmark: pop af  
9bae			endm  
# End of macro DMARK
9bae						CALLMONITOR 
9bae cd 7f 90			call break_point_state  
9bb1				endm  
# End of macro CALLMONITOR
9bb1					endif 
9bb1					FORTH_RSP_TOS 
9bb1 cd ca 95			call macro_forth_rsp_tos 
9bb4				endm 
# End of macro FORTH_RSP_TOS
9bb4 e5					push hl 
9bb5					FORTH_RSP_POP 
9bb5 cd d1 95			call macro_forth_rsp_pop 
9bb8				endm 
# End of macro FORTH_RSP_POP
9bb8 e1					pop hl 
9bb9			;		ex de,hl 
9bb9 22 76 e6				ld (os_tok_ptr),hl 
9bbc			 
9bbc			if DEBUG_FORTH_UWORD 
9bbc						DMARK "SCL" 
9bbc				CALLMONITOR 
9bbc			endif 
9bbc					NEXTW 
9bbc c3 de 97			jp macro_next 
9bbf				endm 
# End of macro NEXTW
9bbf			 
9bbf			.DROP: 
9bbf				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
9bbf 1b				db WORD_SYS_CORE+OPCODE_DROP             
9bc0 ea 9b			dw .DUP2            
9bc2 05				db 4 + 1 
9bc3 .. 00			db "DROP",0              
9bc8				endm 
# End of macro CWHEAD
9bc8			; | DROP ( w -- )   drop the TOS item   | DONE 
9bc8					if DEBUG_FORTH_WORDS_KEY 
9bc8						DMARK "DRP" 
9bc8 f5				push af  
9bc9 3a dd 9b			ld a, (.dmark)  
9bcc 32 7a ee			ld (debug_mark),a  
9bcf 3a de 9b			ld a, (.dmark+1)  
9bd2 32 7b ee			ld (debug_mark+1),a  
9bd5 3a df 9b			ld a, (.dmark+2)  
9bd8 32 7c ee			ld (debug_mark+2),a  
9bdb 18 03			jr .pastdmark  
9bdd ..			.dmark: db "DRP"  
9be0 f1			.pastdmark: pop af  
9be1			endm  
# End of macro DMARK
9be1						CALLMONITOR 
9be1 cd 7f 90			call break_point_state  
9be4				endm  
# End of macro CALLMONITOR
9be4					endif 
9be4					FORTH_DSP_POP 
9be4 cd 24 97			call macro_forth_dsp_pop 
9be7				endm 
# End of macro FORTH_DSP_POP
9be7					NEXTW 
9be7 c3 de 97			jp macro_next 
9bea				endm 
# End of macro NEXTW
9bea			.DUP2: 
9bea				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
9bea 1c				db WORD_SYS_CORE+OPCODE_DUP2             
9beb 2f 9c			dw .DROP2            
9bed 05				db 4 + 1 
9bee .. 00			db "2DUP",0              
9bf3				endm 
# End of macro CWHEAD
9bf3			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
9bf3					if DEBUG_FORTH_WORDS_KEY 
9bf3						DMARK "2DU" 
9bf3 f5				push af  
9bf4 3a 08 9c			ld a, (.dmark)  
9bf7 32 7a ee			ld (debug_mark),a  
9bfa 3a 09 9c			ld a, (.dmark+1)  
9bfd 32 7b ee			ld (debug_mark+1),a  
9c00 3a 0a 9c			ld a, (.dmark+2)  
9c03 32 7c ee			ld (debug_mark+2),a  
9c06 18 03			jr .pastdmark  
9c08 ..			.dmark: db "2DU"  
9c0b f1			.pastdmark: pop af  
9c0c			endm  
# End of macro DMARK
9c0c						CALLMONITOR 
9c0c cd 7f 90			call break_point_state  
9c0f				endm  
# End of macro CALLMONITOR
9c0f					endif 
9c0f					FORTH_DSP_VALUEHL 
9c0f cd a4 96			call macro_dsp_valuehl 
9c12				endm 
# End of macro FORTH_DSP_VALUEHL
9c12 e5					push hl      ; 2 
9c13			 
9c13					FORTH_DSP_POP 
9c13 cd 24 97			call macro_forth_dsp_pop 
9c16				endm 
# End of macro FORTH_DSP_POP
9c16					 
9c16					FORTH_DSP_VALUEHL 
9c16 cd a4 96			call macro_dsp_valuehl 
9c19				endm 
# End of macro FORTH_DSP_VALUEHL
9c19			;		push hl      ; 1 
9c19			 
9c19					FORTH_DSP_POP 
9c19 cd 24 97			call macro_forth_dsp_pop 
9c1c				endm 
# End of macro FORTH_DSP_POP
9c1c			 
9c1c			;		pop hl       ; 1 
9c1c d1					pop de       ; 2 
9c1d			 
9c1d cd 09 96				call forth_push_numhl 
9c20 eb					ex de, hl 
9c21 cd 09 96				call forth_push_numhl 
9c24			 
9c24					 
9c24 eb					ex de, hl 
9c25			 
9c25 cd 09 96				call forth_push_numhl 
9c28 eb					ex de, hl 
9c29 cd 09 96				call forth_push_numhl 
9c2c			 
9c2c			 
9c2c					NEXTW 
9c2c c3 de 97			jp macro_next 
9c2f				endm 
# End of macro NEXTW
9c2f			.DROP2: 
9c2f				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
9c2f 1d				db WORD_SYS_CORE+OPCODE_DROP2             
9c30 5e 9c			dw .SWAP2            
9c32 06				db 5 + 1 
9c33 .. 00			db "2DROP",0              
9c39				endm 
# End of macro CWHEAD
9c39			; | 2DROP ( w w -- )    Double drop | DONE 
9c39					if DEBUG_FORTH_WORDS_KEY 
9c39						DMARK "2DR" 
9c39 f5				push af  
9c3a 3a 4e 9c			ld a, (.dmark)  
9c3d 32 7a ee			ld (debug_mark),a  
9c40 3a 4f 9c			ld a, (.dmark+1)  
9c43 32 7b ee			ld (debug_mark+1),a  
9c46 3a 50 9c			ld a, (.dmark+2)  
9c49 32 7c ee			ld (debug_mark+2),a  
9c4c 18 03			jr .pastdmark  
9c4e ..			.dmark: db "2DR"  
9c51 f1			.pastdmark: pop af  
9c52			endm  
# End of macro DMARK
9c52						CALLMONITOR 
9c52 cd 7f 90			call break_point_state  
9c55				endm  
# End of macro CALLMONITOR
9c55					endif 
9c55					FORTH_DSP_POP 
9c55 cd 24 97			call macro_forth_dsp_pop 
9c58				endm 
# End of macro FORTH_DSP_POP
9c58					FORTH_DSP_POP 
9c58 cd 24 97			call macro_forth_dsp_pop 
9c5b				endm 
# End of macro FORTH_DSP_POP
9c5b					NEXTW 
9c5b c3 de 97			jp macro_next 
9c5e				endm 
# End of macro NEXTW
9c5e			.SWAP2: 
9c5e				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
9c5e 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
9c5f 87 9c			dw .AT            
9c61 06				db 5 + 1 
9c62 .. 00			db "2SWAP",0              
9c68				endm 
# End of macro CWHEAD
9c68			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
9c68					if DEBUG_FORTH_WORDS_KEY 
9c68						DMARK "2SW" 
9c68 f5				push af  
9c69 3a 7d 9c			ld a, (.dmark)  
9c6c 32 7a ee			ld (debug_mark),a  
9c6f 3a 7e 9c			ld a, (.dmark+1)  
9c72 32 7b ee			ld (debug_mark+1),a  
9c75 3a 7f 9c			ld a, (.dmark+2)  
9c78 32 7c ee			ld (debug_mark+2),a  
9c7b 18 03			jr .pastdmark  
9c7d ..			.dmark: db "2SW"  
9c80 f1			.pastdmark: pop af  
9c81			endm  
# End of macro DMARK
9c81						CALLMONITOR 
9c81 cd 7f 90			call break_point_state  
9c84				endm  
# End of macro CALLMONITOR
9c84					endif 
9c84					NEXTW 
9c84 c3 de 97			jp macro_next 
9c87				endm 
# End of macro NEXTW
9c87			.AT: 
9c87				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
9c87 1f				db WORD_SYS_CORE+OPCODE_AT             
9c88 b9 9c			dw .CAT            
9c8a 02				db 1 + 1 
9c8b .. 00			db "@",0              
9c8d				endm 
# End of macro CWHEAD
9c8d			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
9c8d			 
9c8d					if DEBUG_FORTH_WORDS_KEY 
9c8d						DMARK "AT." 
9c8d f5				push af  
9c8e 3a a2 9c			ld a, (.dmark)  
9c91 32 7a ee			ld (debug_mark),a  
9c94 3a a3 9c			ld a, (.dmark+1)  
9c97 32 7b ee			ld (debug_mark+1),a  
9c9a 3a a4 9c			ld a, (.dmark+2)  
9c9d 32 7c ee			ld (debug_mark+2),a  
9ca0 18 03			jr .pastdmark  
9ca2 ..			.dmark: db "AT."  
9ca5 f1			.pastdmark: pop af  
9ca6			endm  
# End of macro DMARK
9ca6						CALLMONITOR 
9ca6 cd 7f 90			call break_point_state  
9ca9				endm  
# End of macro CALLMONITOR
9ca9					endif 
9ca9			.getbyteat:	 
9ca9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9ca9 cd a4 96			call macro_dsp_valuehl 
9cac				endm 
# End of macro FORTH_DSP_VALUEHL
9cac					 
9cac			;		push hl 
9cac				 
9cac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
9cac cd 24 97			call macro_forth_dsp_pop 
9caf				endm 
# End of macro FORTH_DSP_POP
9caf			 
9caf			;		pop hl 
9caf			 
9caf 7e					ld a, (hl) 
9cb0			 
9cb0 6f					ld l, a 
9cb1 26 00				ld h, 0 
9cb3 cd 09 96				call forth_push_numhl 
9cb6			 
9cb6					NEXTW 
9cb6 c3 de 97			jp macro_next 
9cb9				endm 
# End of macro NEXTW
9cb9			.CAT: 
9cb9				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
9cb9 20				db WORD_SYS_CORE+OPCODE_CAT             
9cba e2 9c			dw .BANG            
9cbc 03				db 2 + 1 
9cbd .. 00			db "C@",0              
9cc0				endm 
# End of macro CWHEAD
9cc0			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
9cc0					if DEBUG_FORTH_WORDS_KEY 
9cc0						DMARK "CAA" 
9cc0 f5				push af  
9cc1 3a d5 9c			ld a, (.dmark)  
9cc4 32 7a ee			ld (debug_mark),a  
9cc7 3a d6 9c			ld a, (.dmark+1)  
9cca 32 7b ee			ld (debug_mark+1),a  
9ccd 3a d7 9c			ld a, (.dmark+2)  
9cd0 32 7c ee			ld (debug_mark+2),a  
9cd3 18 03			jr .pastdmark  
9cd5 ..			.dmark: db "CAA"  
9cd8 f1			.pastdmark: pop af  
9cd9			endm  
# End of macro DMARK
9cd9						CALLMONITOR 
9cd9 cd 7f 90			call break_point_state  
9cdc				endm  
# End of macro CALLMONITOR
9cdc					endif 
9cdc c3 a9 9c				jp .getbyteat 
9cdf					NEXTW 
9cdf c3 de 97			jp macro_next 
9ce2				endm 
# End of macro NEXTW
9ce2			.BANG: 
9ce2				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
9ce2 21				db WORD_SYS_CORE+OPCODE_BANG             
9ce3 18 9d			dw .CBANG            
9ce5 02				db 1 + 1 
9ce6 .. 00			db "!",0              
9ce8				endm 
# End of macro CWHEAD
9ce8			; | ! ( x w -- ) Store x at address w      | DONE 
9ce8					if DEBUG_FORTH_WORDS_KEY 
9ce8						DMARK "BNG" 
9ce8 f5				push af  
9ce9 3a fd 9c			ld a, (.dmark)  
9cec 32 7a ee			ld (debug_mark),a  
9cef 3a fe 9c			ld a, (.dmark+1)  
9cf2 32 7b ee			ld (debug_mark+1),a  
9cf5 3a ff 9c			ld a, (.dmark+2)  
9cf8 32 7c ee			ld (debug_mark+2),a  
9cfb 18 03			jr .pastdmark  
9cfd ..			.dmark: db "BNG"  
9d00 f1			.pastdmark: pop af  
9d01			endm  
# End of macro DMARK
9d01						CALLMONITOR 
9d01 cd 7f 90			call break_point_state  
9d04				endm  
# End of macro CALLMONITOR
9d04					endif 
9d04			 
9d04			.storebyteat:		 
9d04					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9d04 cd a4 96			call macro_dsp_valuehl 
9d07				endm 
# End of macro FORTH_DSP_VALUEHL
9d07					 
9d07 e5					push hl 
9d08				 
9d08					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
9d08 cd 24 97			call macro_forth_dsp_pop 
9d0b				endm 
# End of macro FORTH_DSP_POP
9d0b			 
9d0b					; get byte to poke 
9d0b			 
9d0b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9d0b cd a4 96			call macro_dsp_valuehl 
9d0e				endm 
# End of macro FORTH_DSP_VALUEHL
9d0e e5					push hl 
9d0f			 
9d0f			 
9d0f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
9d0f cd 24 97			call macro_forth_dsp_pop 
9d12				endm 
# End of macro FORTH_DSP_POP
9d12			 
9d12			 
9d12 d1					pop de 
9d13 e1					pop hl 
9d14			 
9d14 73					ld (hl),e 
9d15			 
9d15			 
9d15					NEXTW 
9d15 c3 de 97			jp macro_next 
9d18				endm 
# End of macro NEXTW
9d18			.CBANG: 
9d18				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
9d18 22				db WORD_SYS_CORE+OPCODE_CBANG             
9d19 41 9d			dw .SCALL            
9d1b 03				db 2 + 1 
9d1c .. 00			db "C!",0              
9d1f				endm 
# End of macro CWHEAD
9d1f			; | C!  ( x w -- ) Store x at address w  | DONE 
9d1f					if DEBUG_FORTH_WORDS_KEY 
9d1f						DMARK "CBA" 
9d1f f5				push af  
9d20 3a 34 9d			ld a, (.dmark)  
9d23 32 7a ee			ld (debug_mark),a  
9d26 3a 35 9d			ld a, (.dmark+1)  
9d29 32 7b ee			ld (debug_mark+1),a  
9d2c 3a 36 9d			ld a, (.dmark+2)  
9d2f 32 7c ee			ld (debug_mark+2),a  
9d32 18 03			jr .pastdmark  
9d34 ..			.dmark: db "CBA"  
9d37 f1			.pastdmark: pop af  
9d38			endm  
# End of macro DMARK
9d38						CALLMONITOR 
9d38 cd 7f 90			call break_point_state  
9d3b				endm  
# End of macro CALLMONITOR
9d3b					endif 
9d3b c3 04 9d				jp .storebyteat 
9d3e					NEXTW 
9d3e c3 de 97			jp macro_next 
9d41				endm 
# End of macro NEXTW
9d41			.SCALL: 
9d41				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
9d41 23				db WORD_SYS_CORE+OPCODE_SCALL             
9d42 75 9d			dw .DEPTH            
9d44 05				db 4 + 1 
9d45 .. 00			db "CALL",0              
9d4a				endm 
# End of macro CWHEAD
9d4a			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
9d4a					if DEBUG_FORTH_WORDS_KEY 
9d4a						DMARK "CLL" 
9d4a f5				push af  
9d4b 3a 5f 9d			ld a, (.dmark)  
9d4e 32 7a ee			ld (debug_mark),a  
9d51 3a 60 9d			ld a, (.dmark+1)  
9d54 32 7b ee			ld (debug_mark+1),a  
9d57 3a 61 9d			ld a, (.dmark+2)  
9d5a 32 7c ee			ld (debug_mark+2),a  
9d5d 18 03			jr .pastdmark  
9d5f ..			.dmark: db "CLL"  
9d62 f1			.pastdmark: pop af  
9d63			endm  
# End of macro DMARK
9d63						CALLMONITOR 
9d63 cd 7f 90			call break_point_state  
9d66				endm  
# End of macro CALLMONITOR
9d66					endif 
9d66			 
9d66					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9d66 cd a4 96			call macro_dsp_valuehl 
9d69				endm 
# End of macro FORTH_DSP_VALUEHL
9d69			 
9d69			;		push hl 
9d69			 
9d69					; destroy value TOS 
9d69			 
9d69					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
9d69 cd 24 97			call macro_forth_dsp_pop 
9d6c				endm 
# End of macro FORTH_DSP_POP
9d6c			 
9d6c						 
9d6c			;		pop hl 
9d6c			 
9d6c					; how to do a call with hl???? save SP? 
9d6c cd 87 97				call forth_call_hl 
9d6f			 
9d6f			 
9d6f					; TODO push value back onto stack for another op etc 
9d6f			 
9d6f cd 09 96				call forth_push_numhl 
9d72					NEXTW 
9d72 c3 de 97			jp macro_next 
9d75				endm 
# End of macro NEXTW
9d75			.DEPTH: 
9d75				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
9d75 24				db WORD_SYS_CORE+OPCODE_DEPTH             
9d76 b2 9d			dw .OVER            
9d78 06				db 5 + 1 
9d79 .. 00			db "DEPTH",0              
9d7f				endm 
# End of macro CWHEAD
9d7f			; | DEPTH ( -- u ) Push count of stack | DONE 
9d7f					; take current TOS and remove from base value div by two to get count 
9d7f					if DEBUG_FORTH_WORDS_KEY 
9d7f						DMARK "DEP" 
9d7f f5				push af  
9d80 3a 94 9d			ld a, (.dmark)  
9d83 32 7a ee			ld (debug_mark),a  
9d86 3a 95 9d			ld a, (.dmark+1)  
9d89 32 7b ee			ld (debug_mark+1),a  
9d8c 3a 96 9d			ld a, (.dmark+2)  
9d8f 32 7c ee			ld (debug_mark+2),a  
9d92 18 03			jr .pastdmark  
9d94 ..			.dmark: db "DEP"  
9d97 f1			.pastdmark: pop af  
9d98			endm  
# End of macro DMARK
9d98						CALLMONITOR 
9d98 cd 7f 90			call break_point_state  
9d9b				endm  
# End of macro CALLMONITOR
9d9b					endif 
9d9b			 
9d9b			 
9d9b 2a 22 eb			ld hl, (cli_data_sp) 
9d9e 11 dc e8			ld de, cli_data_stack 
9da1 ed 52			sbc hl,de 
9da3				 
9da3				; div by size of stack item 
9da3			 
9da3 5d				ld e,l 
9da4 0e 03			ld c, 3 
9da6 cd 4b 88			call Div8 
9da9			 
9da9 6f				ld l,a 
9daa 26 00			ld h,0 
9dac			 
9dac				;srl h 
9dac				;rr l 
9dac			 
9dac cd 09 96				call forth_push_numhl 
9daf					NEXTW 
9daf c3 de 97			jp macro_next 
9db2				endm 
# End of macro NEXTW
9db2			.OVER: 
9db2				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
9db2 42				db WORD_SYS_CORE+46             
9db3 f9 9d			dw .PAUSE            
9db5 05				db 4 + 1 
9db6 .. 00			db "OVER",0              
9dbb				endm 
# End of macro CWHEAD
9dbb			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
9dbb					if DEBUG_FORTH_WORDS_KEY 
9dbb						DMARK "OVR" 
9dbb f5				push af  
9dbc 3a d0 9d			ld a, (.dmark)  
9dbf 32 7a ee			ld (debug_mark),a  
9dc2 3a d1 9d			ld a, (.dmark+1)  
9dc5 32 7b ee			ld (debug_mark+1),a  
9dc8 3a d2 9d			ld a, (.dmark+2)  
9dcb 32 7c ee			ld (debug_mark+2),a  
9dce 18 03			jr .pastdmark  
9dd0 ..			.dmark: db "OVR"  
9dd3 f1			.pastdmark: pop af  
9dd4			endm  
# End of macro DMARK
9dd4						CALLMONITOR 
9dd4 cd 7f 90			call break_point_state  
9dd7				endm  
# End of macro CALLMONITOR
9dd7					endif 
9dd7			 
9dd7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9dd7 cd a4 96			call macro_dsp_valuehl 
9dda				endm 
# End of macro FORTH_DSP_VALUEHL
9dda e5					push hl    ; n2 
9ddb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
9ddb cd 24 97			call macro_forth_dsp_pop 
9dde				endm 
# End of macro FORTH_DSP_POP
9dde			 
9dde					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9dde cd a4 96			call macro_dsp_valuehl 
9de1				endm 
# End of macro FORTH_DSP_VALUEHL
9de1 e5					push hl    ; n1 
9de2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
9de2 cd 24 97			call macro_forth_dsp_pop 
9de5				endm 
# End of macro FORTH_DSP_POP
9de5			 
9de5 d1					pop de     ; n1 
9de6 e1					pop hl     ; n2 
9de7			 
9de7 d5					push de 
9de8 e5					push hl 
9de9 d5					push de 
9dea			 
9dea					; push back  
9dea			 
9dea e1					pop hl 
9deb cd 09 96				call forth_push_numhl 
9dee e1					pop hl 
9def cd 09 96				call forth_push_numhl 
9df2 e1					pop hl 
9df3 cd 09 96				call forth_push_numhl 
9df6					NEXTW 
9df6 c3 de 97			jp macro_next 
9df9				endm 
# End of macro NEXTW
9df9			 
9df9			.PAUSE: 
9df9				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
9df9 43				db WORD_SYS_CORE+47             
9dfa 2e 9e			dw .PAUSES            
9dfc 08				db 7 + 1 
9dfd .. 00			db "PAUSEMS",0              
9e05				endm 
# End of macro CWHEAD
9e05			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
9e05					if DEBUG_FORTH_WORDS_KEY 
9e05						DMARK "PMS" 
9e05 f5				push af  
9e06 3a 1a 9e			ld a, (.dmark)  
9e09 32 7a ee			ld (debug_mark),a  
9e0c 3a 1b 9e			ld a, (.dmark+1)  
9e0f 32 7b ee			ld (debug_mark+1),a  
9e12 3a 1c 9e			ld a, (.dmark+2)  
9e15 32 7c ee			ld (debug_mark+2),a  
9e18 18 03			jr .pastdmark  
9e1a ..			.dmark: db "PMS"  
9e1d f1			.pastdmark: pop af  
9e1e			endm  
# End of macro DMARK
9e1e						CALLMONITOR 
9e1e cd 7f 90			call break_point_state  
9e21				endm  
# End of macro CALLMONITOR
9e21					endif 
9e21					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9e21 cd a4 96			call macro_dsp_valuehl 
9e24				endm 
# End of macro FORTH_DSP_VALUEHL
9e24			;		push hl    ; n2 
9e24					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
9e24 cd 24 97			call macro_forth_dsp_pop 
9e27				endm 
# End of macro FORTH_DSP_POP
9e27			;		pop hl 
9e27			 
9e27 7d					ld a, l 
9e28 cd cb 86				call aDelayInMS 
9e2b				       NEXTW 
9e2b c3 de 97			jp macro_next 
9e2e				endm 
# End of macro NEXTW
9e2e			.PAUSES:  
9e2e				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
9e2e 44				db WORD_SYS_CORE+48             
9e2f 65 9e			dw .ROT            
9e31 06				db 5 + 1 
9e32 .. 00			db "PAUSE",0              
9e38				endm 
# End of macro CWHEAD
9e38			; | PAUSE ( n -- )  Pause for n seconds | DONE 
9e38					if DEBUG_FORTH_WORDS_KEY 
9e38						DMARK "PAU" 
9e38 f5				push af  
9e39 3a 4d 9e			ld a, (.dmark)  
9e3c 32 7a ee			ld (debug_mark),a  
9e3f 3a 4e 9e			ld a, (.dmark+1)  
9e42 32 7b ee			ld (debug_mark+1),a  
9e45 3a 4f 9e			ld a, (.dmark+2)  
9e48 32 7c ee			ld (debug_mark+2),a  
9e4b 18 03			jr .pastdmark  
9e4d ..			.dmark: db "PAU"  
9e50 f1			.pastdmark: pop af  
9e51			endm  
# End of macro DMARK
9e51						CALLMONITOR 
9e51 cd 7f 90			call break_point_state  
9e54				endm  
# End of macro CALLMONITOR
9e54					endif 
9e54					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9e54 cd a4 96			call macro_dsp_valuehl 
9e57				endm 
# End of macro FORTH_DSP_VALUEHL
9e57			;		push hl    ; n2 
9e57					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
9e57 cd 24 97			call macro_forth_dsp_pop 
9e5a				endm 
# End of macro FORTH_DSP_POP
9e5a			;		pop hl 
9e5a 45					ld b, l 
9e5b					if DEBUG_FORTH_WORDS 
9e5b						DMARK "PAU" 
9e5b						CALLMONITOR 
9e5b					endif 
9e5b c5			.pauses1:	push bc 
9e5c cd e6 86				call delay1s 
9e5f c1					pop bc 
9e60					if DEBUG_FORTH_WORDS 
9e60						DMARK "PA1" 
9e60						CALLMONITOR 
9e60					endif 
9e60 10 f9				djnz .pauses1 
9e62			 
9e62				       NEXTW 
9e62 c3 de 97			jp macro_next 
9e65				endm 
# End of macro NEXTW
9e65			.ROT: 
9e65				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
9e65 45				db WORD_SYS_CORE+49             
9e66 b3 9e			dw .UWORDS            
9e68 04				db 3 + 1 
9e69 .. 00			db "ROT",0              
9e6d				endm 
# End of macro CWHEAD
9e6d			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
9e6d					if DEBUG_FORTH_WORDS_KEY 
9e6d						DMARK "ROT" 
9e6d f5				push af  
9e6e 3a 82 9e			ld a, (.dmark)  
9e71 32 7a ee			ld (debug_mark),a  
9e74 3a 83 9e			ld a, (.dmark+1)  
9e77 32 7b ee			ld (debug_mark+1),a  
9e7a 3a 84 9e			ld a, (.dmark+2)  
9e7d 32 7c ee			ld (debug_mark+2),a  
9e80 18 03			jr .pastdmark  
9e82 ..			.dmark: db "ROT"  
9e85 f1			.pastdmark: pop af  
9e86			endm  
# End of macro DMARK
9e86						CALLMONITOR 
9e86 cd 7f 90			call break_point_state  
9e89				endm  
# End of macro CALLMONITOR
9e89					endif 
9e89			 
9e89					FORTH_DSP_VALUEHL 
9e89 cd a4 96			call macro_dsp_valuehl 
9e8c				endm 
# End of macro FORTH_DSP_VALUEHL
9e8c e5					push hl    ; u3  
9e8d			 
9e8d					FORTH_DSP_POP 
9e8d cd 24 97			call macro_forth_dsp_pop 
9e90				endm 
# End of macro FORTH_DSP_POP
9e90			   
9e90					FORTH_DSP_VALUEHL 
9e90 cd a4 96			call macro_dsp_valuehl 
9e93				endm 
# End of macro FORTH_DSP_VALUEHL
9e93 e5					push hl     ; u2 
9e94			 
9e94					FORTH_DSP_POP 
9e94 cd 24 97			call macro_forth_dsp_pop 
9e97				endm 
# End of macro FORTH_DSP_POP
9e97			 
9e97					FORTH_DSP_VALUEHL 
9e97 cd a4 96			call macro_dsp_valuehl 
9e9a				endm 
# End of macro FORTH_DSP_VALUEHL
9e9a e5					push hl     ; u1 
9e9b			 
9e9b					FORTH_DSP_POP 
9e9b cd 24 97			call macro_forth_dsp_pop 
9e9e				endm 
# End of macro FORTH_DSP_POP
9e9e			 
9e9e c1					pop bc      ; u1 
9e9f e1					pop hl      ; u2 
9ea0 d1					pop de      ; u3 
9ea1			 
9ea1			 
9ea1 c5					push bc 
9ea2 d5					push de 
9ea3 e5					push hl 
9ea4			 
9ea4			 
9ea4 e1					pop hl 
9ea5 cd 09 96				call forth_push_numhl 
9ea8			 
9ea8 e1					pop hl 
9ea9 cd 09 96				call forth_push_numhl 
9eac			 
9eac e1					pop hl 
9ead cd 09 96				call forth_push_numhl 
9eb0					 
9eb0			 
9eb0			 
9eb0			 
9eb0			 
9eb0			 
9eb0				       NEXTW 
9eb0 c3 de 97			jp macro_next 
9eb3				endm 
# End of macro NEXTW
9eb3			 
9eb3			.UWORDS: 
9eb3				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
9eb3 50				db WORD_SYS_CORE+60             
9eb4 05 9f			dw .BP            
9eb6 07				db 6 + 1 
9eb7 .. 00			db "UWORDS",0              
9ebe				endm 
# End of macro CWHEAD
9ebe			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
9ebe			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
9ebe			; | | Following the count are the individual words. 
9ebe			; | | 
9ebe			; | | e.g. UWORDS 
9ebe			; | | BOX DIRLIST 2 
9ebe			; | |  
9ebe			; | | Can be used to save the words to storage via: 
9ebe			; | | UWORDS $01 DO $01 APPEND LOOP 
9ebe				if DEBUG_FORTH_WORDS_KEY 
9ebe					DMARK "UWR" 
9ebe f5				push af  
9ebf 3a d3 9e			ld a, (.dmark)  
9ec2 32 7a ee			ld (debug_mark),a  
9ec5 3a d4 9e			ld a, (.dmark+1)  
9ec8 32 7b ee			ld (debug_mark+1),a  
9ecb 3a d5 9e			ld a, (.dmark+2)  
9ece 32 7c ee			ld (debug_mark+2),a  
9ed1 18 03			jr .pastdmark  
9ed3 ..			.dmark: db "UWR"  
9ed6 f1			.pastdmark: pop af  
9ed7			endm  
# End of macro DMARK
9ed7					CALLMONITOR 
9ed7 cd 7f 90			call break_point_state  
9eda				endm  
# End of macro CALLMONITOR
9eda				endif 
9eda 21 b4 c6				ld hl, baseram 
9edd					;ld hl, baseusermem 
9edd 01 00 00				ld bc, 0    ; start a counter 
9ee0			 
9ee0				; skip dict stub 
9ee0			 
9ee0 cd 2f 99				call forth_tok_next 
9ee3			 
9ee3			 
9ee3			; while we have words to look for 
9ee3			 
9ee3 7e			.douscan:	ld a, (hl)      
9ee4				if DEBUG_FORTH_WORDS 
9ee4					DMARK "UWs" 
9ee4					CALLMONITOR 
9ee4				endif 
9ee4 fe 00				cp WORD_SYS_END 
9ee6 28 15				jr z, .udone 
9ee8 fe 01				cp WORD_SYS_UWORD 
9eea 20 0c				jr nz, .nuword 
9eec			 
9eec				if DEBUG_FORTH_WORDS 
9eec					DMARK "UWu" 
9eec					CALLMONITOR 
9eec				endif 
9eec					; we have a uword so push its name to the stack 
9eec			 
9eec e5				   	push hl  ; save so we can move to next dict block 
9eed			 
9eed					; skip opcode 
9eed 23					inc hl  
9eee					; skip next ptr 
9eee 23					inc hl  
9eef 23					inc hl 
9ef0					; skip len 
9ef0 23					inc hl 
9ef1				if DEBUG_FORTH_WORDS 
9ef1					DMARK "UWt" 
9ef1					CALLMONITOR 
9ef1				endif 
9ef1 03					inc bc 
9ef2			 
9ef2 c5					push bc 
9ef3 cd 1b 96				call forth_push_str 
9ef6 c1					pop bc 
9ef7			 
9ef7 e1					pop hl 	 
9ef8			 
9ef8 cd 2f 99		.nuword:	call forth_tok_next 
9efb 18 e6				jr .douscan  
9efd			 
9efd			.udone:		 ; push count of uwords found 
9efd c5					push bc 
9efe e1					pop hl 
9eff			 
9eff				if DEBUG_FORTH_WORDS 
9eff					DMARK "UWc" 
9eff					CALLMONITOR 
9eff				endif 
9eff cd 09 96				call forth_push_numhl 
9f02			 
9f02			 
9f02				       NEXTW 
9f02 c3 de 97			jp macro_next 
9f05				endm 
# End of macro NEXTW
9f05			 
9f05			.BP: 
9f05				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
9f05 54				db WORD_SYS_CORE+64             
9f06 3b 9f			dw .MONITOR            
9f08 03				db 2 + 1 
9f09 .. 00			db "BP",0              
9f0c				endm 
# End of macro CWHEAD
9f0c			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
9f0c			; | | $00 Will enable the break points within specific code paths 
9f0c			; | | $01 Will disable break points 
9f0c			; | |  
9f0c			; | | By default break points are off. Either the above can be used to enable them 
9f0c			; | | or if a key is held down during start up the spashscreen will appear to freeze 
9f0c			; | | and on release of the pressed key a message will be disaplayed to notify 
9f0c			; | | that break points are enabled. Pressing any key will then continue boot process. 
9f0c					; get byte count 
9f0c					if DEBUG_FORTH_WORDS_KEY 
9f0c						DMARK "BP." 
9f0c f5				push af  
9f0d 3a 21 9f			ld a, (.dmark)  
9f10 32 7a ee			ld (debug_mark),a  
9f13 3a 22 9f			ld a, (.dmark+1)  
9f16 32 7b ee			ld (debug_mark+1),a  
9f19 3a 23 9f			ld a, (.dmark+2)  
9f1c 32 7c ee			ld (debug_mark+2),a  
9f1f 18 03			jr .pastdmark  
9f21 ..			.dmark: db "BP."  
9f24 f1			.pastdmark: pop af  
9f25			endm  
# End of macro DMARK
9f25						CALLMONITOR 
9f25 cd 7f 90			call break_point_state  
9f28				endm  
# End of macro CALLMONITOR
9f28					endif 
9f28			 
9f28					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9f28 cd a4 96			call macro_dsp_valuehl 
9f2b				endm 
# End of macro FORTH_DSP_VALUEHL
9f2b			 
9f2b			;		push hl 
9f2b			 
9f2b					; destroy value TOS 
9f2b			 
9f2b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
9f2b cd 24 97			call macro_forth_dsp_pop 
9f2e				endm 
# End of macro FORTH_DSP_POP
9f2e			 
9f2e			;		pop hl 
9f2e			 
9f2e 3e 00				ld a,0 
9f30 bd					cp l 
9f31 28 02				jr z, .bpset 
9f33 3e 2a				ld a, '*' 
9f35			 
9f35 32 74 e3		.bpset:		ld (os_view_disable), a 
9f38			 
9f38			 
9f38					NEXTW 
9f38 c3 de 97			jp macro_next 
9f3b				endm 
# End of macro NEXTW
9f3b			 
9f3b			 
9f3b			.MONITOR: 
9f3b				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
9f3b 55				db WORD_SYS_CORE+65             
9f3c 6e 9f			dw .MALLOC            
9f3e 08				db 7 + 1 
9f3f .. 00			db "MONITOR",0              
9f47				endm 
# End of macro CWHEAD
9f47			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
9f47			; | | At start the current various registers will be displayed with contents. 
9f47			; | | Top right corner will show the most recent debug marker seen. 
9f47			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
9f47			; | | and the return stack pointer (RSP). 
9f47			; | | Pressing: 
9f47			; | |    1 - Initial screen 
9f47			; | |    2 - Display a data dump of HL 
9f47			; | |    3 - Display a data dump of DE 
9f47			; | |    4 - Display a data dump of BC 
9f47			; | |    5 - Display a data dump of HL 
9f47			; | |    6 - Display a data dump of DSP 
9f47			; | |    7 - Display a data dump of RSP 
9f47			; | |    8 - Display a data dump of what is at DSP 
9f47			; | |    9 - Display a data dump of what is at RSP 
9f47			; | |    0 - Exit monitor and continue running. This will also enable break points 
9f47			; | |    * - Disable break points 
9f47			; | |    # - Enter traditional monitor mode 
9f47			; | | 
9f47			; | | Monitor Mode 
9f47			; | | ------------ 
9f47			; | | A prompt of '>' will be shown for various commands: 
9f47			; | |    D xxxx - Display a data dump starting from hex address xxxx 
9f47			; | |    C - Continue display a data dump from the last set address 
9f47			; | |    M xxxx - Set start of memory edit at address xx 
9f47			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
9f47			; | |    Q - Return to previous 
9f47					if DEBUG_FORTH_WORDS_KEY 
9f47						DMARK "MON" 
9f47 f5				push af  
9f48 3a 5c 9f			ld a, (.dmark)  
9f4b 32 7a ee			ld (debug_mark),a  
9f4e 3a 5d 9f			ld a, (.dmark+1)  
9f51 32 7b ee			ld (debug_mark+1),a  
9f54 3a 5e 9f			ld a, (.dmark+2)  
9f57 32 7c ee			ld (debug_mark+2),a  
9f5a 18 03			jr .pastdmark  
9f5c ..			.dmark: db "MON"  
9f5f f1			.pastdmark: pop af  
9f60			endm  
# End of macro DMARK
9f60						CALLMONITOR 
9f60 cd 7f 90			call break_point_state  
9f63				endm  
# End of macro CALLMONITOR
9f63					endif 
9f63 3e 00				ld a, 0 
9f65 32 74 e3				ld (os_view_disable), a 
9f68			 
9f68					CALLMONITOR 
9f68 cd 7f 90			call break_point_state  
9f6b				endm  
# End of macro CALLMONITOR
9f6b			 
9f6b			;	call monitor 
9f6b			 
9f6b					NEXTW 
9f6b c3 de 97			jp macro_next 
9f6e				endm 
# End of macro NEXTW
9f6e			 
9f6e			 
9f6e			.MALLOC: 
9f6e				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
9f6e 56				db WORD_SYS_CORE+66             
9f6f 97 9f			dw .MALLOC2            
9f71 06				db 5 + 1 
9f72 .. 00			db "ALLOT",0              
9f78				endm 
# End of macro CWHEAD
9f78			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
9f78					if DEBUG_FORTH_WORDS_KEY 
9f78						DMARK "ALL" 
9f78 f5				push af  
9f79 3a 8d 9f			ld a, (.dmark)  
9f7c 32 7a ee			ld (debug_mark),a  
9f7f 3a 8e 9f			ld a, (.dmark+1)  
9f82 32 7b ee			ld (debug_mark+1),a  
9f85 3a 8f 9f			ld a, (.dmark+2)  
9f88 32 7c ee			ld (debug_mark+2),a  
9f8b 18 03			jr .pastdmark  
9f8d ..			.dmark: db "ALL"  
9f90 f1			.pastdmark: pop af  
9f91			endm  
# End of macro DMARK
9f91						CALLMONITOR 
9f91 cd 7f 90			call break_point_state  
9f94				endm  
# End of macro CALLMONITOR
9f94					endif 
9f94 c3 be 9f				jp .mallocc 
9f97			.MALLOC2: 
9f97				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
9f97 56				db WORD_SYS_CORE+66             
9f98 d5 9f			dw .FREE            
9f9a 07				db 6 + 1 
9f9b .. 00			db "MALLOC",0              
9fa2				endm 
# End of macro CWHEAD
9fa2			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
9fa2					; get byte count 
9fa2					if DEBUG_FORTH_WORDS_KEY 
9fa2						DMARK "MAL" 
9fa2 f5				push af  
9fa3 3a b7 9f			ld a, (.dmark)  
9fa6 32 7a ee			ld (debug_mark),a  
9fa9 3a b8 9f			ld a, (.dmark+1)  
9fac 32 7b ee			ld (debug_mark+1),a  
9faf 3a b9 9f			ld a, (.dmark+2)  
9fb2 32 7c ee			ld (debug_mark+2),a  
9fb5 18 03			jr .pastdmark  
9fb7 ..			.dmark: db "MAL"  
9fba f1			.pastdmark: pop af  
9fbb			endm  
# End of macro DMARK
9fbb						CALLMONITOR 
9fbb cd 7f 90			call break_point_state  
9fbe				endm  
# End of macro CALLMONITOR
9fbe					endif 
9fbe			.mallocc: 
9fbe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9fbe cd a4 96			call macro_dsp_valuehl 
9fc1				endm 
# End of macro FORTH_DSP_VALUEHL
9fc1			 
9fc1			;		push hl 
9fc1			 
9fc1					; destroy value TOS 
9fc1			 
9fc1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
9fc1 cd 24 97			call macro_forth_dsp_pop 
9fc4				endm 
# End of macro FORTH_DSP_POP
9fc4			 
9fc4			;		pop hl 
9fc4 cd 82 8d				call malloc 
9fc7				if DEBUG_FORTH_MALLOC_GUARD 
9fc7 f5					push af 
9fc8 cd e4 88				call ishlzero 
9fcb			;		ld a, l 
9fcb			;		add h 
9fcb			;		cp 0 
9fcb f1					pop af 
9fcc					 
9fcc cc 82 b3				call z,malloc_error 
9fcf				endif 
9fcf			 
9fcf cd 09 96				call forth_push_numhl 
9fd2					NEXTW 
9fd2 c3 de 97			jp macro_next 
9fd5				endm 
# End of macro NEXTW
9fd5			 
9fd5			.FREE: 
9fd5				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
9fd5 57				db WORD_SYS_CORE+67             
9fd6 06 a0			dw .LIST            
9fd8 05				db 4 + 1 
9fd9 .. 00			db "FREE",0              
9fde				endm 
# End of macro CWHEAD
9fde			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
9fde					if DEBUG_FORTH_WORDS_KEY 
9fde						DMARK "FRE" 
9fde f5				push af  
9fdf 3a f3 9f			ld a, (.dmark)  
9fe2 32 7a ee			ld (debug_mark),a  
9fe5 3a f4 9f			ld a, (.dmark+1)  
9fe8 32 7b ee			ld (debug_mark+1),a  
9feb 3a f5 9f			ld a, (.dmark+2)  
9fee 32 7c ee			ld (debug_mark+2),a  
9ff1 18 03			jr .pastdmark  
9ff3 ..			.dmark: db "FRE"  
9ff6 f1			.pastdmark: pop af  
9ff7			endm  
# End of macro DMARK
9ff7						CALLMONITOR 
9ff7 cd 7f 90			call break_point_state  
9ffa				endm  
# End of macro CALLMONITOR
9ffa					endif 
9ffa					; get address 
9ffa			 
9ffa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9ffa cd a4 96			call macro_dsp_valuehl 
9ffd				endm 
# End of macro FORTH_DSP_VALUEHL
9ffd			 
9ffd			;		push hl 
9ffd			 
9ffd					; destroy value TOS 
9ffd			 
9ffd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
9ffd cd 24 97			call macro_forth_dsp_pop 
a000				endm 
# End of macro FORTH_DSP_POP
a000			 
a000			;		pop hl 
a000			if FORTH_ENABLE_MALLOCFREE 
a000 cd 4c 8e				call free 
a003			endif 
a003					NEXTW 
a003 c3 de 97			jp macro_next 
a006				endm 
# End of macro NEXTW
a006			.LIST: 
a006				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a006 5c				db WORD_SYS_CORE+72             
a007 b1 a0			dw .FORGET            
a009 05				db 4 + 1 
a00a .. 00			db "LIST",0              
a00f				endm 
# End of macro CWHEAD
a00f			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a00f			; | | The quoted word must be in upper case. 
a00f				if DEBUG_FORTH_WORDS_KEY 
a00f					DMARK "LST" 
a00f f5				push af  
a010 3a 24 a0			ld a, (.dmark)  
a013 32 7a ee			ld (debug_mark),a  
a016 3a 25 a0			ld a, (.dmark+1)  
a019 32 7b ee			ld (debug_mark+1),a  
a01c 3a 26 a0			ld a, (.dmark+2)  
a01f 32 7c ee			ld (debug_mark+2),a  
a022 18 03			jr .pastdmark  
a024 ..			.dmark: db "LST"  
a027 f1			.pastdmark: pop af  
a028			endm  
# End of macro DMARK
a028					CALLMONITOR 
a028 cd 7f 90			call break_point_state  
a02b				endm  
# End of macro CALLMONITOR
a02b				endif 
a02b			 
a02b					FORTH_DSP_VALUEHL 
a02b cd a4 96			call macro_dsp_valuehl 
a02e				endm 
# End of macro FORTH_DSP_VALUEHL
a02e			 
a02e e5					push hl 
a02f c1					pop bc 
a030			 
a030			; Start format of scratch string 
a030			 
a030 21 75 e3				ld hl, scratch 
a033			 
a033 3e 3a				ld a, ':' 
a035 77					ld (hl),a 
a036 23					inc hl 
a037 3e 20				ld a, ' ' 
a039 77					ld (hl), a 
a03a			 
a03a					; Get ptr to the word we need to look up 
a03a			 
a03a			;		FORTH_DSP_VALUEHL 
a03a					;v5 FORTH_DSP_VALUE 
a03a				; TODO type check 
a03a			;		inc hl    ; Skip type check  
a03a			;		push hl 
a03a			;		ex de, hl    ; put into DE 
a03a			 
a03a			 
a03a 21 b4 c6				ld hl, baseram 
a03d					;ld hl, baseusermem 
a03d			 
a03d e5			push hl   ; sacreifical push 
a03e			 
a03e			.ldouscanm: 
a03e e1				pop hl 
a03f			.ldouscan: 
a03f				if DEBUG_FORTH_WORDS 
a03f					DMARK "LSs" 
a03f					CALLMONITOR 
a03f				endif 
a03f				; skip dict stub 
a03f cd 2f 99				call forth_tok_next 
a042			 
a042			 
a042			; while we have words to look for 
a042			 
a042 7e				ld a, (hl)      
a043				if DEBUG_FORTH_WORDS 
a043					DMARK "LSk" 
a043					CALLMONITOR 
a043				endif 
a043 fe 00				cp WORD_SYS_END 
a045 ca 98 a0				jp z, .lunotfound 
a048 fe 01				cp WORD_SYS_UWORD 
a04a c2 3f a0				jp nz, .ldouscan 
a04d			 
a04d				if DEBUG_FORTH_WORDS 
a04d					DMARK "LSu" 
a04d					CALLMONITOR 
a04d				endif 
a04d			 
a04d					; found a uword but is it the one we want... 
a04d			 
a04d c5					push bc     ; uword to find is on bc 
a04e d1					pop de 
a04f			 
a04f e5					push hl  ; to save the ptr 
a050			 
a050					; skip opcode 
a050 23					inc hl  
a051					; skip next ptr 
a051 23					inc hl  
a052 23					inc hl 
a053					; skip len 
a053 23					inc hl 
a054			 
a054				if DEBUG_FORTH_WORDS 
a054					DMARK "LSc" 
a054					CALLMONITOR 
a054				endif 
a054 cd 51 8d				call strcmp 
a057 c2 3e a0				jp nz, .ldouscanm 
a05a				 
a05a			 
a05a			 
a05a					; we have a uword so push its name to the stack 
a05a			 
a05a			;	   	push hl  ; save so we can move to next dict block 
a05a e1			pop hl 
a05b			 
a05b				if DEBUG_FORTH_WORDS 
a05b					DMARK "LSm" 
a05b					CALLMONITOR 
a05b				endif 
a05b			 
a05b					; skip opcode 
a05b 23					inc hl  
a05c					; skip next ptr 
a05c 23					inc hl  
a05d 23					inc hl 
a05e					; skip len 
a05e 7e					ld a, (hl)   ; save length to add 
a05f				if DEBUG_FORTH_WORDS 
a05f					DMARK "LS2" 
a05f					CALLMONITOR 
a05f				endif 
a05f			 
a05f					; save this location 
a05f				 
a05f e5					push hl 
a060			 
a060 23					inc hl 
a061 11 77 e3				ld de, scratch+2 
a064 4f					ld c, a 
a065 06 00				ld b, 0 
a067			 
a067				if DEBUG_FORTH_WORDS 
a067					DMARK "LSn" 
a067					CALLMONITOR 
a067				endif 
a067			 
a067					; copy uword name to scratch 
a067			 
a067 ed b0				ldir 
a069			 
a069 1b					dec de 
a06a 3e 20				ld a, ' '    ; change null to space 
a06c 12					ld (de), a 
a06d			 
a06d 13					inc de 
a06e			 
a06e d5					push de 
a06f c1					pop bc     ; move scratch pointer to end of word name and save it 
a070			 
a070 e1					pop hl 
a071 7e					ld a, (hl) 
a072					;inc hl 
a072					; skip word string 
a072 cd bb 88				call addatohl 
a075			 
a075 23					inc hl 
a076			 
a076				if DEBUG_FORTH_WORDS 
a076					DMARK "LS3" 
a076					CALLMONITOR 
a076				endif 
a076					; should now be at the start of the machine code to setup the eval of the uword 
a076					; now locate the ptr to the string defintion 
a076			 
a076					; skip ld hl, 
a076					; then load the ptr 
a076			 
a076 23					inc hl 
a077 5e					ld e, (hl) 
a078 23					inc hl 
a079 56					ld d, (hl) 
a07a eb					ex de, hl 
a07b			 
a07b			 
a07b				if DEBUG_FORTH_WORDS 
a07b					DMARK "LSt" 
a07b					CALLMONITOR 
a07b				endif 
a07b			 
a07b			; cant push right now due to tokenised strings  
a07b			 
a07b			; get the destination of where to copy this definition to. 
a07b			 
a07b c5					push bc 
a07c d1					pop de 
a07d			 
a07d 7e			.listl:         ld a,(hl) 
a07e fe 00				cp 0 
a080 28 09				jr z, .lreplsp     ; replace zero with space 
a082 fe 7f				cp FORTH_END_BUFFER 
a084 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a086				 
a086					; just copy this char as is then 
a086			 
a086 12					ld (de), a 
a087			 
a087 23			.listnxt:	inc hl 
a088 13					inc de 
a089 18 f2				jr .listl 
a08b			 
a08b 3e 20		.lreplsp:	ld a,' ' 
a08d 12					ld (de), a 
a08e 18 f7				jr .listnxt 
a090			 
a090			; close up uword def 
a090			 
a090			.listdone: 
a090 3e 00				ld a, 0 
a092 12					ld (de), a 
a093			 
a093			; now have def so clean up and push to stack 
a093			 
a093 21 75 e3				ld hl, scratch 
a096				if DEBUG_FORTH_WORDS 
a096					DMARK "Ltp" 
a096					CALLMONITOR 
a096				endif 
a096			 
a096 18 06			jr .listpush 
a098			 
a098			;.lnuword:	pop hl 
a098			;		call forth_tok_next 
a098			;		jp .ldouscan  
a098			 
a098			.lunotfound:		  
a098			 
a098			 
a098					 
a098					FORTH_DSP_POP 
a098 cd 24 97			call macro_forth_dsp_pop 
a09b				endm 
# End of macro FORTH_DSP_POP
a09b 21 a4 a0				ld hl, .luno 
a09e						 
a09e			 
a09e			.listpush: 
a09e cd 1b 96				call forth_push_str 
a0a1			 
a0a1			 
a0a1			 
a0a1					NEXTW 
a0a1 c3 de 97			jp macro_next 
a0a4				endm 
# End of macro NEXTW
a0a4			 
a0a4 .. 00		.luno:    db "Not found",0 
a0ae			 
a0ae			 
a0ae			 
a0ae			 
a0ae			 
a0ae			;		push hl   ; save pointer to start of uword def string 
a0ae			; 
a0ae			;; look for FORTH_EOL_LINE 
a0ae			;		ld a, FORTH_END_BUFFER 
a0ae			;		call strlent 
a0ae			; 
a0ae			;		inc hl		 ; space for coln def 
a0ae			;		inc hl 
a0ae			;		inc hl          ; space for terms 
a0ae			;		inc hl 
a0ae			; 
a0ae			;		ld a, 20   ; TODO get actual length 
a0ae			;		call addatohl    ; include a random amount of room for the uword name 
a0ae			; 
a0ae			;		 
a0ae			;	if DEBUG_FORTH_WORDS 
a0ae			;		DMARK "Lt1" 
a0ae			;		CALLMONITOR 
a0ae			;	endif 
a0ae			;		 
a0ae			; 
a0ae			;; malloc space for the string because we cant change it 
a0ae			; 
a0ae			;		call malloc 
a0ae			;	if DEBUG_FORTH_MALLOC_GUARD 
a0ae			;		push af 
a0ae			;		call ishlzero 
a0ae			;		pop af 
a0ae			;		 
a0ae			;		call z,malloc_error 
a0ae			;	endif 
a0ae			; 
a0ae			;	if DEBUG_FORTH_WORDS 
a0ae			;		DMARK "Lt2" 
a0ae			;		CALLMONITOR 
a0ae			;	endif 
a0ae			;		pop de 
a0ae			;		push hl    ; push the malloc to release later 
a0ae			;		push hl   ;  push back a copy for the later stack push 
a0ae			;		 
a0ae			;; copy the string swapping out the zero terms for spaces 
a0ae			; 
a0ae			;		; de has our source 
a0ae			;		; hl has our dest 
a0ae			; 
a0ae			;; add the coln def 
a0ae			; 
a0ae			;		ld a, ':' 
a0ae			;		ld (hl), a 
a0ae			;		inc hl 
a0ae			;		ld a, ' ' 
a0ae			;		ld (hl), a 
a0ae			;		inc hl 
a0ae			; 
a0ae			;; add the uname word 
a0ae			;		push de   ; save our string for now 
a0ae			;		ex de, hl 
a0ae			; 
a0ae			;		FORTH_DSP_VALUE 
a0ae			;		;v5 FORTH_DSP_VALUE 
a0ae			; 
a0ae			;		inc hl   ; skip type but we know by now this is OK 
a0ae			; 
a0ae			;.luword:	ld a,(hl) 
a0ae			;		cp 0 
a0ae			;		jr z, .luword2 
a0ae			;		ld (de), a 
a0ae			;		inc de 
a0ae			;		inc hl 
a0ae			;		jr .luword 
a0ae			; 
a0ae			;.luword2:	ld a, ' ' 
a0ae			;		ld (de), a 
a0ae			;;		inc hl 
a0ae			;;		inc de 
a0ae			;;		ld (de), a 
a0ae			;;		inc hl 
a0ae			;		inc de 
a0ae			; 
a0ae			;		ex de, hl 
a0ae			;		pop de 
a0ae			;		 
a0ae			;		 
a0ae			; 
a0ae			;; detoken that string and copy it 
a0ae			; 
a0ae			;	if DEBUG_FORTH_WORDS 
a0ae			;		DMARK "Lt2" 
a0ae			;		CALLMONITOR 
a0ae			;	endif 
a0ae			;.ldetok:	ld a, (de) 
a0ae			;		cp FORTH_END_BUFFER 
a0ae			;		jr z, .ldetokend 
a0ae			;		; swap out any zero term for space 
a0ae			;		cp 0 
a0ae			;		jr nz, .ldetoknext 
a0ae			;		ld a, ' ' 
a0ae			; 
a0ae			;	if DEBUG_FORTH_WORDS 
a0ae			;		DMARK "LtS" 
a0ae			;		CALLMONITOR 
a0ae			;	endif 
a0ae			;.ldetoknext:	ld (hl), a 
a0ae			;		inc de 
a0ae			;		inc hl 
a0ae			;		jr .ldetok 
a0ae			; 
a0ae			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a0ae			;		ld (hl), a  
a0ae			; 
a0ae			;; free that temp malloc 
a0ae			; 
a0ae			;		pop hl    
a0ae			; 
a0ae			;	if DEBUG_FORTH_WORDS 
a0ae			;		DMARK "Lt4" 
a0ae			;		CALLMONITOR 
a0ae			;	endif 
a0ae			;		call forth_apushstrhl 
a0ae			; 
a0ae			;		; get rid of temp malloc area 
a0ae			; 
a0ae			;		pop hl 
a0ae			;		call free 
a0ae			; 
a0ae			;		jr .ludone 
a0ae			; 
a0ae			;.lnuword:	pop hl 
a0ae			;		call forth_tok_next 
a0ae			;		jp .ldouscan  
a0ae			; 
a0ae			;.ludone:		 pop hl 
a0ae			; 
a0ae					NEXTW 
a0ae c3 de 97			jp macro_next 
a0b1				endm 
# End of macro NEXTW
a0b1			 
a0b1			.FORGET: 
a0b1				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a0b1 5d				db WORD_SYS_CORE+73             
a0b2 0e a1			dw .NOP            
a0b4 07				db 6 + 1 
a0b5 .. 00			db "FORGET",0              
a0bc				endm 
# End of macro CWHEAD
a0bc			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a0bc			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
a0bc			; | |  
a0bc			; | | e.g. "MORE" forget 
a0bc					if DEBUG_FORTH_WORDS_KEY 
a0bc						DMARK "FRG" 
a0bc f5				push af  
a0bd 3a d1 a0			ld a, (.dmark)  
a0c0 32 7a ee			ld (debug_mark),a  
a0c3 3a d2 a0			ld a, (.dmark+1)  
a0c6 32 7b ee			ld (debug_mark+1),a  
a0c9 3a d3 a0			ld a, (.dmark+2)  
a0cc 32 7c ee			ld (debug_mark+2),a  
a0cf 18 03			jr .pastdmark  
a0d1 ..			.dmark: db "FRG"  
a0d4 f1			.pastdmark: pop af  
a0d5			endm  
# End of macro DMARK
a0d5						CALLMONITOR 
a0d5 cd 7f 90			call break_point_state  
a0d8				endm  
# End of macro CALLMONITOR
a0d8					endif 
a0d8			 
a0d8				; find uword 
a0d8			        ; update start of word with "_" 
a0d8				; replace uword with deleted flag 
a0d8			 
a0d8			 
a0d8			;	if DEBUG_FORTH_WORDS 
a0d8			;		DMARK "FOG" 
a0d8			;		CALLMONITOR 
a0d8			;	endif 
a0d8			 
a0d8			 
a0d8					; Get ptr to the word we need to look up 
a0d8			 
a0d8					FORTH_DSP_VALUEHL 
a0d8 cd a4 96			call macro_dsp_valuehl 
a0db				endm 
# End of macro FORTH_DSP_VALUEHL
a0db					;v5 FORTH_DSP_VALUE 
a0db				; TODO type check 
a0db			;		inc hl    ; Skip type check  
a0db e5					push hl 
a0dc c1					pop bc 
a0dd			;		ex de, hl    ; put into DE 
a0dd			 
a0dd			 
a0dd 21 b4 c6				ld hl, baseram 
a0e0					;ld hl, baseusermem 
a0e0			 
a0e0				; skip dict stub 
a0e0			;	call forth_tok_next 
a0e0 e5			push hl   ; sacreifical push 
a0e1			 
a0e1			.fldouscanm: 
a0e1 e1				pop hl 
a0e2			.fldouscan: 
a0e2			;	if DEBUG_FORTH_WORDS 
a0e2			;		DMARK "LSs" 
a0e2			;		CALLMONITOR 
a0e2			;	endif 
a0e2				; skip dict stub 
a0e2 cd 2f 99				call forth_tok_next 
a0e5			 
a0e5			 
a0e5			; while we have words to look for 
a0e5			 
a0e5 7e				ld a, (hl)      
a0e6			;	if DEBUG_FORTH_WORDS 
a0e6			;		DMARK "LSk" 
a0e6			;		CALLMONITOR 
a0e6			;	endif 
a0e6 fe 00				cp WORD_SYS_END 
a0e8 ca 08 a1				jp z, .flunotfound 
a0eb fe 01				cp WORD_SYS_UWORD 
a0ed c2 e2 a0				jp nz, .fldouscan 
a0f0			 
a0f0			;	if DEBUG_FORTH_WORDS 
a0f0			;		DMARK "LSu" 
a0f0			;		CALLMONITOR 
a0f0			;	endif 
a0f0			 
a0f0					; found a uword but is it the one we want... 
a0f0			 
a0f0 c5					push bc     ; uword to find is on bc 
a0f1 d1					pop de 
a0f2			 
a0f2 e5					push hl  ; to save the ptr 
a0f3			 
a0f3					; skip opcode 
a0f3 23					inc hl  
a0f4					; skip next ptr 
a0f4 23					inc hl  
a0f5 23					inc hl 
a0f6					; skip len 
a0f6 23					inc hl 
a0f7			 
a0f7			;	if DEBUG_FORTH_WORDS 
a0f7			;		DMARK "LSc" 
a0f7			;		CALLMONITOR 
a0f7			;	endif 
a0f7 cd 51 8d				call strcmp 
a0fa c2 e1 a0				jp nz, .fldouscanm 
a0fd			; 
a0fd			; 
a0fd			;; while we have words to look for 
a0fd			; 
a0fd			;.fdouscan:	ld a, (hl)      
a0fd			;	if DEBUG_FORTH_WORDS 
a0fd			;		DMARK "LSs" 
a0fd			;		CALLMONITOR 
a0fd			;	endif 
a0fd			;		cp WORD_SYS_END 
a0fd			;		jp z, .fudone 
a0fd			;		cp WORD_SYS_UWORD 
a0fd			;		jp nz, .fnuword 
a0fd			; 
a0fd			;	if DEBUG_FORTH_WORDS 
a0fd			;		DMARK "FGu" 
a0fd			;		CALLMONITOR 
a0fd			;	endif 
a0fd			; 
a0fd			;		; found a uword but is it the one we want... 
a0fd			; 
a0fd			; 
a0fd			;	        pop de   ; get back the dsp name 
a0fd			;		push de 
a0fd			; 
a0fd			;		push hl  ; to save the ptr 
a0fd			; 
a0fd			;		; skip opcode 
a0fd			;		inc hl  
a0fd			;		; skip next ptr 
a0fd			;		inc hl  
a0fd			;		inc hl 
a0fd			;		; skip len 
a0fd			;		inc hl 
a0fd			; 
a0fd			;	if DEBUG_FORTH_WORDS 
a0fd			;		DMARK "FGc" 
a0fd			;		CALLMONITOR 
a0fd			;	endif 
a0fd			;		call strcmp 
a0fd			;		jp nz, .fnuword 
a0fd			 
a0fd			 
a0fd e1			pop hl 
a0fe			 
a0fe				 
a0fe				if DEBUG_FORTH_WORDS 
a0fe					DMARK "FGm" 
a0fe					CALLMONITOR 
a0fe				endif 
a0fe			 
a0fe			 
a0fe			 
a0fe					; we have a uword so push its name to the stack 
a0fe			 
a0fe			;	   	push hl  ; save so we can move to next dict block 
a0fe			;pop hl 
a0fe			 
a0fe					; update opcode to deleted 
a0fe 3e 03				ld a, WORD_SYS_DELETED 
a100 77					ld (hl), a 
a101			 
a101 23					inc hl  
a102					; skip next ptr 
a102 23					inc hl  
a103 23					inc hl 
a104					; skip len 
a104 23					inc hl 
a105			 
a105					; TODO change parser to skip deleted words but for now mark it out 
a105 3e 5f				ld a, "_" 
a107 77					ld  (hl),a 
a108			 
a108			;		jr .fudone 
a108			; 
a108			;.fnuword:	pop hl 
a108			;		call forth_tok_next 
a108			;		jp .fdouscan  
a108			 
a108			.flunotfound:		  
a108			 
a108			 
a108					 
a108					FORTH_DSP_POP 
a108 cd 24 97			call macro_forth_dsp_pop 
a10b				endm 
# End of macro FORTH_DSP_POP
a10b			;		ld hl, .luno 
a10b			;.fudone:		 pop hl 
a10b					NEXTW 
a10b c3 de 97			jp macro_next 
a10e				endm 
# End of macro NEXTW
a10e			.NOP: 
a10e				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
a10e 61				db WORD_SYS_CORE+77             
a10f 35 a1			dw .COMO            
a111 04				db 3 + 1 
a112 .. 00			db "NOP",0              
a116				endm 
# End of macro CWHEAD
a116			; | NOP (  --  ) Do nothing | DONE 
a116					if DEBUG_FORTH_WORDS_KEY 
a116						DMARK "NOP" 
a116 f5				push af  
a117 3a 2b a1			ld a, (.dmark)  
a11a 32 7a ee			ld (debug_mark),a  
a11d 3a 2c a1			ld a, (.dmark+1)  
a120 32 7b ee			ld (debug_mark+1),a  
a123 3a 2d a1			ld a, (.dmark+2)  
a126 32 7c ee			ld (debug_mark+2),a  
a129 18 03			jr .pastdmark  
a12b ..			.dmark: db "NOP"  
a12e f1			.pastdmark: pop af  
a12f			endm  
# End of macro DMARK
a12f						CALLMONITOR 
a12f cd 7f 90			call break_point_state  
a132				endm  
# End of macro CALLMONITOR
a132					endif 
a132				       NEXTW 
a132 c3 de 97			jp macro_next 
a135				endm 
# End of macro NEXTW
a135			.COMO: 
a135				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
a135 6e				db WORD_SYS_CORE+90             
a136 4f a1			dw .COMC            
a138 02				db 1 + 1 
a139 .. 00			db "(",0              
a13b				endm 
# End of macro CWHEAD
a13b			; | ( ( -- )  Start of comment | DONE 
a13b			 
a13b			 
a13b 2a 76 e6				ld hl, ( os_tok_ptr) 
a13e 11 4a a1			ld de, .closepar 
a141					 
a141					if DEBUG_FORTH_WORDS 
a141						DMARK ").." 
a141						CALLMONITOR 
a141					endif 
a141 cd f9 98			call findnexttok  
a144			 
a144					if DEBUG_FORTH_WORDS 
a144						DMARK "IF5" 
a144						CALLMONITOR 
a144					endif 
a144				; replace below with ) exec using tok_ptr 
a144 22 76 e6			ld (os_tok_ptr), hl 
a147 c3 6f 98			jp exec1 
a14a			 
a14a .. 00			.closepar:   db ")",0 
a14c			 
a14c				       NEXTW 
a14c c3 de 97			jp macro_next 
a14f				endm 
# End of macro NEXTW
a14f			.COMC: 
a14f				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
a14f 6f				db WORD_SYS_CORE+91             
a150 58 a1			dw .SCRATCH            
a152 02				db 1 + 1 
a153 .. 00			db ")",0              
a155				endm 
# End of macro CWHEAD
a155			; | ) ( -- )  End of comment |  DONE  
a155				       NEXTW 
a155 c3 de 97			jp macro_next 
a158				endm 
# End of macro NEXTW
a158			 
a158			.SCRATCH: 
a158				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
a158 6f				db WORD_SYS_CORE+91             
a159 93 a1			dw .INC            
a15b 08				db 7 + 1 
a15c .. 00			db "SCRATCH",0              
a164				endm 
# End of macro CWHEAD
a164			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
a164			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
a164			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
a164			; | |  
a164			; | | e.g.    : score $00 scratch ; 
a164			; | |  
a164			; | | $00 score ! 
a164			; | | $01 score +! 
a164			; | |  
a164			; | | e.g.   : varword $0a scratch ;  
a164			; | | 
a164			; | | $8000 varword ! 
a164					if DEBUG_FORTH_WORDS_KEY 
a164						DMARK "SCR" 
a164 f5				push af  
a165 3a 79 a1			ld a, (.dmark)  
a168 32 7a ee			ld (debug_mark),a  
a16b 3a 7a a1			ld a, (.dmark+1)  
a16e 32 7b ee			ld (debug_mark+1),a  
a171 3a 7b a1			ld a, (.dmark+2)  
a174 32 7c ee			ld (debug_mark+2),a  
a177 18 03			jr .pastdmark  
a179 ..			.dmark: db "SCR"  
a17c f1			.pastdmark: pop af  
a17d			endm  
# End of macro DMARK
a17d						CALLMONITOR 
a17d cd 7f 90			call break_point_state  
a180				endm  
# End of macro CALLMONITOR
a180					endif 
a180			 
a180					FORTH_DSP_VALUEHL 
a180 cd a4 96			call macro_dsp_valuehl 
a183				endm 
# End of macro FORTH_DSP_VALUEHL
a183				 
a183					FORTH_DSP_POP 
a183 cd 24 97			call macro_forth_dsp_pop 
a186				endm 
# End of macro FORTH_DSP_POP
a186			 
a186 7d					ld a, l 
a187 21 9a e8				ld hl, os_var_array 
a18a cd bb 88				call addatohl 
a18d			 
a18d cd 09 96				call forth_push_numhl 
a190			 
a190				       NEXTW 
a190 c3 de 97			jp macro_next 
a193				endm 
# End of macro NEXTW
a193			 
a193			.INC: 
a193				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
a193 6f				db WORD_SYS_CORE+91             
a194 cb a1			dw .DEC            
a196 03				db 2 + 1 
a197 .. 00			db "+!",0              
a19a				endm 
# End of macro CWHEAD
a19a			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
a19a					if DEBUG_FORTH_WORDS_KEY 
a19a						DMARK "+s_" 
a19a f5				push af  
a19b 3a af a1			ld a, (.dmark)  
a19e 32 7a ee			ld (debug_mark),a  
a1a1 3a b0 a1			ld a, (.dmark+1)  
a1a4 32 7b ee			ld (debug_mark+1),a  
a1a7 3a b1 a1			ld a, (.dmark+2)  
a1aa 32 7c ee			ld (debug_mark+2),a  
a1ad 18 03			jr .pastdmark  
a1af ..			.dmark: db "+s_"  
a1b2 f1			.pastdmark: pop af  
a1b3			endm  
# End of macro DMARK
a1b3						CALLMONITOR 
a1b3 cd 7f 90			call break_point_state  
a1b6				endm  
# End of macro CALLMONITOR
a1b6					endif 
a1b6			 
a1b6					FORTH_DSP_VALUEHL 
a1b6 cd a4 96			call macro_dsp_valuehl 
a1b9				endm 
# End of macro FORTH_DSP_VALUEHL
a1b9			 
a1b9 e5					push hl   ; save address 
a1ba			 
a1ba					FORTH_DSP_POP 
a1ba cd 24 97			call macro_forth_dsp_pop 
a1bd				endm 
# End of macro FORTH_DSP_POP
a1bd			 
a1bd					FORTH_DSP_VALUEHL 
a1bd cd a4 96			call macro_dsp_valuehl 
a1c0				endm 
# End of macro FORTH_DSP_VALUEHL
a1c0			 
a1c0					FORTH_DSP_POP 
a1c0 cd 24 97			call macro_forth_dsp_pop 
a1c3				endm 
# End of macro FORTH_DSP_POP
a1c3			 
a1c3					; hl contains value to add to byte at a 
a1c3				 
a1c3 eb					ex de, hl 
a1c4			 
a1c4 e1					pop hl 
a1c5			 
a1c5					if DEBUG_FORTH_WORDS 
a1c5						DMARK "INC" 
a1c5						CALLMONITOR 
a1c5					endif 
a1c5			 
a1c5 7e					ld a,(hl) 
a1c6 83					add e 
a1c7 77					ld (hl),a 
a1c8			 
a1c8			 
a1c8			 
a1c8				       NEXTW 
a1c8 c3 de 97			jp macro_next 
a1cb				endm 
# End of macro NEXTW
a1cb			 
a1cb			.DEC: 
a1cb				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
a1cb 6f				db WORD_SYS_CORE+91             
a1cc 00 a2			dw .INC2            
a1ce 03				db 2 + 1 
a1cf .. 00			db "-!",0              
a1d2				endm 
# End of macro CWHEAD
a1d2			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
a1d2					if DEBUG_FORTH_WORDS_KEY 
a1d2						DMARK "-s_" 
a1d2 f5				push af  
a1d3 3a e7 a1			ld a, (.dmark)  
a1d6 32 7a ee			ld (debug_mark),a  
a1d9 3a e8 a1			ld a, (.dmark+1)  
a1dc 32 7b ee			ld (debug_mark+1),a  
a1df 3a e9 a1			ld a, (.dmark+2)  
a1e2 32 7c ee			ld (debug_mark+2),a  
a1e5 18 03			jr .pastdmark  
a1e7 ..			.dmark: db "-s_"  
a1ea f1			.pastdmark: pop af  
a1eb			endm  
# End of macro DMARK
a1eb						CALLMONITOR 
a1eb cd 7f 90			call break_point_state  
a1ee				endm  
# End of macro CALLMONITOR
a1ee					endif 
a1ee			 
a1ee					FORTH_DSP_VALUEHL 
a1ee cd a4 96			call macro_dsp_valuehl 
a1f1				endm 
# End of macro FORTH_DSP_VALUEHL
a1f1			 
a1f1 e5					push hl   ; save address 
a1f2			 
a1f2					FORTH_DSP_POP 
a1f2 cd 24 97			call macro_forth_dsp_pop 
a1f5				endm 
# End of macro FORTH_DSP_POP
a1f5			 
a1f5					FORTH_DSP_VALUEHL 
a1f5 cd a4 96			call macro_dsp_valuehl 
a1f8				endm 
# End of macro FORTH_DSP_VALUEHL
a1f8			 
a1f8					; hl contains value to add to byte at a 
a1f8				 
a1f8 eb					ex de, hl 
a1f9			 
a1f9 e1					pop hl 
a1fa			 
a1fa					if DEBUG_FORTH_WORDS 
a1fa						DMARK "DEC" 
a1fa						CALLMONITOR 
a1fa					endif 
a1fa			 
a1fa 7e					ld a,(hl) 
a1fb 93					sub e 
a1fc 77					ld (hl),a 
a1fd			 
a1fd			 
a1fd			 
a1fd				       NEXTW 
a1fd c3 de 97			jp macro_next 
a200				endm 
# End of macro NEXTW
a200			 
a200			.INC2: 
a200				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
a200 6f				db WORD_SYS_CORE+91             
a201 3a a2			dw .DEC2            
a203 04				db 3 + 1 
a204 .. 00			db "+2!",0              
a208				endm 
# End of macro CWHEAD
a208			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
a208			 
a208					if DEBUG_FORTH_WORDS_KEY 
a208						DMARK "+2s" 
a208 f5				push af  
a209 3a 1d a2			ld a, (.dmark)  
a20c 32 7a ee			ld (debug_mark),a  
a20f 3a 1e a2			ld a, (.dmark+1)  
a212 32 7b ee			ld (debug_mark+1),a  
a215 3a 1f a2			ld a, (.dmark+2)  
a218 32 7c ee			ld (debug_mark+2),a  
a21b 18 03			jr .pastdmark  
a21d ..			.dmark: db "+2s"  
a220 f1			.pastdmark: pop af  
a221			endm  
# End of macro DMARK
a221						CALLMONITOR 
a221 cd 7f 90			call break_point_state  
a224				endm  
# End of macro CALLMONITOR
a224					endif 
a224			 
a224					; Address 
a224			 
a224					FORTH_DSP_VALUEHL 
a224 cd a4 96			call macro_dsp_valuehl 
a227				endm 
# End of macro FORTH_DSP_VALUEHL
a227			 
a227 e5					push hl    ; save address 
a228			 
a228					; load content into de 
a228			 
a228 5e					ld e,(hl) 
a229 23					inc hl 
a22a 56					ld d, (hl) 
a22b			 
a22b					if DEBUG_FORTH_WORDS 
a22b						DMARK "+2a" 
a22b						CALLMONITOR 
a22b					endif 
a22b			 
a22b					FORTH_DSP_POP 
a22b cd 24 97			call macro_forth_dsp_pop 
a22e				endm 
# End of macro FORTH_DSP_POP
a22e			 
a22e					; Get value to add 
a22e			 
a22e					FORTH_DSP_VALUE 
a22e cd 8d 96			call macro_forth_dsp_value 
a231				endm 
# End of macro FORTH_DSP_VALUE
a231			 
a231					if DEBUG_FORTH_WORDS 
a231						DMARK "+2v" 
a231						CALLMONITOR 
a231					endif 
a231			 
a231 19					add hl, de 
a232			 
a232					if DEBUG_FORTH_WORDS 
a232						DMARK "+2+" 
a232						CALLMONITOR 
a232					endif 
a232			 
a232					; move result to de 
a232			 
a232 eb					ex de, hl 
a233			 
a233					; Address 
a233			 
a233 e1					pop hl 
a234			 
a234					; save it back 
a234			 
a234 73					ld (hl), e 
a235 23					inc hl 
a236 72					ld (hl), d 
a237			 
a237					if DEBUG_FORTH_WORDS 
a237						DMARK "+2e" 
a237						CALLMONITOR 
a237					endif 
a237			 
a237			 
a237			 
a237			 
a237			 
a237				       NEXTW 
a237 c3 de 97			jp macro_next 
a23a				endm 
# End of macro NEXTW
a23a			 
a23a			.DEC2: 
a23a				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
a23a 6f				db WORD_SYS_CORE+91             
a23b 76 a2			dw .GET2            
a23d 04				db 3 + 1 
a23e .. 00			db "-2!",0              
a242				endm 
# End of macro CWHEAD
a242			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
a242			 
a242			 
a242					if DEBUG_FORTH_WORDS_KEY 
a242						DMARK "-2s" 
a242 f5				push af  
a243 3a 57 a2			ld a, (.dmark)  
a246 32 7a ee			ld (debug_mark),a  
a249 3a 58 a2			ld a, (.dmark+1)  
a24c 32 7b ee			ld (debug_mark+1),a  
a24f 3a 59 a2			ld a, (.dmark+2)  
a252 32 7c ee			ld (debug_mark+2),a  
a255 18 03			jr .pastdmark  
a257 ..			.dmark: db "-2s"  
a25a f1			.pastdmark: pop af  
a25b			endm  
# End of macro DMARK
a25b						CALLMONITOR 
a25b cd 7f 90			call break_point_state  
a25e				endm  
# End of macro CALLMONITOR
a25e					endif 
a25e			 
a25e					; Address 
a25e			 
a25e					FORTH_DSP_VALUEHL 
a25e cd a4 96			call macro_dsp_valuehl 
a261				endm 
# End of macro FORTH_DSP_VALUEHL
a261			 
a261 e5					push hl    ; save address 
a262			 
a262					; load content into de 
a262			 
a262 5e					ld e,(hl) 
a263 23					inc hl 
a264 56					ld d, (hl) 
a265			 
a265					if DEBUG_FORTH_WORDS 
a265						DMARK "-2a" 
a265						CALLMONITOR 
a265					endif 
a265			 
a265					FORTH_DSP_POP 
a265 cd 24 97			call macro_forth_dsp_pop 
a268				endm 
# End of macro FORTH_DSP_POP
a268			 
a268					; Get value to remove 
a268			 
a268					FORTH_DSP_VALUE 
a268 cd 8d 96			call macro_forth_dsp_value 
a26b				endm 
# End of macro FORTH_DSP_VALUE
a26b			 
a26b					if DEBUG_FORTH_WORDS 
a26b						DMARK "-2v" 
a26b						CALLMONITOR 
a26b					endif 
a26b			 
a26b eb					ex de, hl 
a26c ed 52				sbc hl, de 
a26e			 
a26e					if DEBUG_FORTH_WORDS 
a26e						DMARK "-2d" 
a26e						CALLMONITOR 
a26e					endif 
a26e			 
a26e					; move result to de 
a26e			 
a26e eb					ex de, hl 
a26f			 
a26f					; Address 
a26f			 
a26f e1					pop hl 
a270			 
a270					; save it back 
a270			 
a270 73					ld (hl), e 
a271 23					inc hl 
a272 72					ld (hl), d 
a273			 
a273					if DEBUG_FORTH_WORDS 
a273						DMARK "-2e" 
a273						CALLMONITOR 
a273					endif 
a273			 
a273			 
a273			 
a273			 
a273			 
a273				       NEXTW 
a273 c3 de 97			jp macro_next 
a276				endm 
# End of macro NEXTW
a276			.GET2: 
a276				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
a276 6f				db WORD_SYS_CORE+91             
a277 a6 a2			dw .BANG2            
a279 03				db 2 + 1 
a27a .. 00			db "2@",0              
a27d				endm 
# End of macro CWHEAD
a27d			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
a27d					if DEBUG_FORTH_WORDS_KEY 
a27d						DMARK "2A_" 
a27d f5				push af  
a27e 3a 92 a2			ld a, (.dmark)  
a281 32 7a ee			ld (debug_mark),a  
a284 3a 93 a2			ld a, (.dmark+1)  
a287 32 7b ee			ld (debug_mark+1),a  
a28a 3a 94 a2			ld a, (.dmark+2)  
a28d 32 7c ee			ld (debug_mark+2),a  
a290 18 03			jr .pastdmark  
a292 ..			.dmark: db "2A_"  
a295 f1			.pastdmark: pop af  
a296			endm  
# End of macro DMARK
a296						CALLMONITOR 
a296 cd 7f 90			call break_point_state  
a299				endm  
# End of macro CALLMONITOR
a299					endif 
a299			 
a299					FORTH_DSP_VALUEHL 
a299 cd a4 96			call macro_dsp_valuehl 
a29c				endm 
# End of macro FORTH_DSP_VALUEHL
a29c			 
a29c 5e					ld e, (hl) 
a29d 23					inc hl 
a29e 56					ld d, (hl) 
a29f			 
a29f eb					ex de, hl 
a2a0			 
a2a0 cd 09 96				call forth_push_numhl 
a2a3			 
a2a3				       NEXTW 
a2a3 c3 de 97			jp macro_next 
a2a6				endm 
# End of macro NEXTW
a2a6			.BANG2: 
a2a6				CWHEAD .ENDCORE 91 "2!" 2 WORD_FLAG_CODE 
a2a6 6f				db WORD_SYS_CORE+91             
a2a7 de a2			dw .ENDCORE            
a2a9 03				db 2 + 1 
a2aa .. 00			db "2!",0              
a2ad				endm 
# End of macro CWHEAD
a2ad			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
a2ad					if DEBUG_FORTH_WORDS_KEY 
a2ad						DMARK "2S_" 
a2ad f5				push af  
a2ae 3a c2 a2			ld a, (.dmark)  
a2b1 32 7a ee			ld (debug_mark),a  
a2b4 3a c3 a2			ld a, (.dmark+1)  
a2b7 32 7b ee			ld (debug_mark+1),a  
a2ba 3a c4 a2			ld a, (.dmark+2)  
a2bd 32 7c ee			ld (debug_mark+2),a  
a2c0 18 03			jr .pastdmark  
a2c2 ..			.dmark: db "2S_"  
a2c5 f1			.pastdmark: pop af  
a2c6			endm  
# End of macro DMARK
a2c6						CALLMONITOR 
a2c6 cd 7f 90			call break_point_state  
a2c9				endm  
# End of macro CALLMONITOR
a2c9					endif 
a2c9			 
a2c9					FORTH_DSP_VALUEHL 
a2c9 cd a4 96			call macro_dsp_valuehl 
a2cc				endm 
# End of macro FORTH_DSP_VALUEHL
a2cc			 
a2cc e5					push hl   ; save address 
a2cd			 
a2cd			 
a2cd					FORTH_DSP_POP 
a2cd cd 24 97			call macro_forth_dsp_pop 
a2d0				endm 
# End of macro FORTH_DSP_POP
a2d0			 
a2d0					 
a2d0					FORTH_DSP_VALUEHL 
a2d0 cd a4 96			call macro_dsp_valuehl 
a2d3				endm 
# End of macro FORTH_DSP_VALUEHL
a2d3			 
a2d3					FORTH_DSP_POP 
a2d3 cd 24 97			call macro_forth_dsp_pop 
a2d6				endm 
# End of macro FORTH_DSP_POP
a2d6			 
a2d6 eb					ex de, hl    ; value now in de 
a2d7			 
a2d7 e1					pop hl 
a2d8			 
a2d8 73					ld (hl), e 
a2d9			 
a2d9 23					inc hl 
a2da			 
a2da 72					ld (hl), d 
a2db			 
a2db			 
a2db				       NEXTW 
a2db c3 de 97			jp macro_next 
a2de				endm 
# End of macro NEXTW
a2de			.ENDCORE: 
a2de			 
a2de			; eof 
a2de			 
a2de			 
# End of file forth_words_core.asm
a2de			include "forth_words_flow.asm" 
a2de			 
a2de			; | ## Program Flow Words 
a2de			 
a2de			.IF: 
a2de				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
a2de 1e				db WORD_SYS_CORE+10             
a2df 2b a3			dw .THEN            
a2e1 03				db 2 + 1 
a2e2 .. 00			db "IF",0              
a2e5				endm 
# End of macro CWHEAD
a2e5			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
a2e5			; 
a2e5					if DEBUG_FORTH_WORDS_KEY 
a2e5						DMARK "IF." 
a2e5 f5				push af  
a2e6 3a fa a2			ld a, (.dmark)  
a2e9 32 7a ee			ld (debug_mark),a  
a2ec 3a fb a2			ld a, (.dmark+1)  
a2ef 32 7b ee			ld (debug_mark+1),a  
a2f2 3a fc a2			ld a, (.dmark+2)  
a2f5 32 7c ee			ld (debug_mark+2),a  
a2f8 18 03			jr .pastdmark  
a2fa ..			.dmark: db "IF."  
a2fd f1			.pastdmark: pop af  
a2fe			endm  
# End of macro DMARK
a2fe						CALLMONITOR 
a2fe cd 7f 90			call break_point_state  
a301				endm  
# End of macro CALLMONITOR
a301					endif 
a301			; eval TOS 
a301			 
a301				FORTH_DSP_VALUEHL 
a301 cd a4 96			call macro_dsp_valuehl 
a304				endm 
# End of macro FORTH_DSP_VALUEHL
a304			 
a304			;	push hl 
a304				FORTH_DSP_POP 
a304 cd 24 97			call macro_forth_dsp_pop 
a307				endm 
# End of macro FORTH_DSP_POP
a307			;	pop hl 
a307			 
a307					if DEBUG_FORTH_WORDS 
a307						DMARK "IF1" 
a307						CALLMONITOR 
a307					endif 
a307 b7				or a        ; clear carry flag 
a308 11 00 00			ld de, 0 
a30b eb				ex de,hl 
a30c ed 52			sbc hl, de 
a30e c2 28 a3			jp nz, .iftrue 
a311			 
a311					if DEBUG_FORTH_WORDS 
a311						DMARK "IF2" 
a311						CALLMONITOR 
a311					endif 
a311			 
a311			; if not true then skip to THEN 
a311			 
a311				; TODO get tok_ptr 
a311				; TODO consume toks until we get to THEN 
a311			 
a311 2a 76 e6			ld hl, (os_tok_ptr) 
a314					if DEBUG_FORTH_WORDS 
a314						DMARK "IF3" 
a314						CALLMONITOR 
a314						 
a314					endif 
a314 11 23 a3			ld de, .ifthen 
a317					if DEBUG_FORTH_WORDS 
a317						DMARK "IF4" 
a317						CALLMONITOR 
a317					endif 
a317 cd f9 98			call findnexttok  
a31a			 
a31a					if DEBUG_FORTH_WORDS 
a31a						DMARK "IF5" 
a31a						CALLMONITOR 
a31a					endif 
a31a				; TODO replace below with ; exec using tok_ptr 
a31a 22 76 e6			ld (os_tok_ptr), hl 
a31d c3 6f 98			jp exec1 
a320				NEXTW 
a320 c3 de 97			jp macro_next 
a323				endm 
# End of macro NEXTW
a323			 
a323 .. 00		.ifthen:  db "THEN",0 
a328			 
a328			.iftrue:		 
a328				; Exec next words normally 
a328			 
a328				; if true then exec following IF as normal 
a328					if DEBUG_FORTH_WORDS 
a328						DMARK "IFT" 
a328						CALLMONITOR 
a328					endif 
a328			 
a328					NEXTW 
a328 c3 de 97			jp macro_next 
a32b				endm 
# End of macro NEXTW
a32b			.THEN: 
a32b				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
a32b 1f				db WORD_SYS_CORE+11             
a32c 53 a3			dw .ELSE            
a32e 05				db 4 + 1 
a32f .. 00			db "THEN",0              
a334				endm 
# End of macro CWHEAD
a334			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
a334					if DEBUG_FORTH_WORDS_KEY 
a334						DMARK "THN" 
a334 f5				push af  
a335 3a 49 a3			ld a, (.dmark)  
a338 32 7a ee			ld (debug_mark),a  
a33b 3a 4a a3			ld a, (.dmark+1)  
a33e 32 7b ee			ld (debug_mark+1),a  
a341 3a 4b a3			ld a, (.dmark+2)  
a344 32 7c ee			ld (debug_mark+2),a  
a347 18 03			jr .pastdmark  
a349 ..			.dmark: db "THN"  
a34c f1			.pastdmark: pop af  
a34d			endm  
# End of macro DMARK
a34d						CALLMONITOR 
a34d cd 7f 90			call break_point_state  
a350				endm  
# End of macro CALLMONITOR
a350					endif 
a350					NEXTW 
a350 c3 de 97			jp macro_next 
a353				endm 
# End of macro NEXTW
a353			.ELSE: 
a353				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
a353 20				db WORD_SYS_CORE+12             
a354 7b a3			dw .DO            
a356 03				db 2 + 1 
a357 .. 00			db "ELSE",0              
a35c				endm 
# End of macro CWHEAD
a35c			; | ELSE ( -- ) Not supported - does nothing | TODO 
a35c			 
a35c					if DEBUG_FORTH_WORDS_KEY 
a35c						DMARK "ELS" 
a35c f5				push af  
a35d 3a 71 a3			ld a, (.dmark)  
a360 32 7a ee			ld (debug_mark),a  
a363 3a 72 a3			ld a, (.dmark+1)  
a366 32 7b ee			ld (debug_mark+1),a  
a369 3a 73 a3			ld a, (.dmark+2)  
a36c 32 7c ee			ld (debug_mark+2),a  
a36f 18 03			jr .pastdmark  
a371 ..			.dmark: db "ELS"  
a374 f1			.pastdmark: pop af  
a375			endm  
# End of macro DMARK
a375						CALLMONITOR 
a375 cd 7f 90			call break_point_state  
a378				endm  
# End of macro CALLMONITOR
a378					endif 
a378			 
a378			 
a378					NEXTW 
a378 c3 de 97			jp macro_next 
a37b				endm 
# End of macro NEXTW
a37b			.DO: 
a37b				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
a37b 21				db WORD_SYS_CORE+13             
a37c c2 a3			dw .LOOP            
a37e 03				db 2 + 1 
a37f .. 00			db "DO",0              
a382				endm 
# End of macro CWHEAD
a382			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
a382			 
a382					if DEBUG_FORTH_WORDS_KEY 
a382						DMARK "DO." 
a382 f5				push af  
a383 3a 97 a3			ld a, (.dmark)  
a386 32 7a ee			ld (debug_mark),a  
a389 3a 98 a3			ld a, (.dmark+1)  
a38c 32 7b ee			ld (debug_mark+1),a  
a38f 3a 99 a3			ld a, (.dmark+2)  
a392 32 7c ee			ld (debug_mark+2),a  
a395 18 03			jr .pastdmark  
a397 ..			.dmark: db "DO."  
a39a f1			.pastdmark: pop af  
a39b			endm  
# End of macro DMARK
a39b						CALLMONITOR 
a39b cd 7f 90			call break_point_state  
a39e				endm  
# End of macro CALLMONITOR
a39e					endif 
a39e			;  push pc to rsp stack past the DO 
a39e			 
a39e 2a 76 e6				ld hl, (os_tok_ptr) 
a3a1 23					inc hl   ; D 
a3a2 23					inc hl  ; O 
a3a3 23					inc hl   ; null 
a3a4					if DEBUG_FORTH_WORDS 
a3a4						DMARK "DO2" 
a3a4						CALLMONITOR 
a3a4					endif 
a3a4					FORTH_RSP_NEXT 
a3a4 cd b3 95			call macro_forth_rsp_next 
a3a7				endm 
# End of macro FORTH_RSP_NEXT
a3a7					if DEBUG_FORTH_WORDS 
a3a7						DMARK "DO3" 
a3a7						CALLMONITOR 
a3a7					endif 
a3a7			 
a3a7					;if DEBUG_FORTH_WORDS 
a3a7				;		push hl 
a3a7			;		endif  
a3a7			 
a3a7			; get counters from data stack 
a3a7			 
a3a7			 
a3a7					FORTH_DSP_VALUEHL 
a3a7 cd a4 96			call macro_dsp_valuehl 
a3aa				endm 
# End of macro FORTH_DSP_VALUEHL
a3aa e5					push hl		 ; hl now has starting counter which needs to be tos 
a3ab			 
a3ab					if DEBUG_FORTH_WORDS 
a3ab						DMARK "DO4" 
a3ab						CALLMONITOR 
a3ab					endif 
a3ab					FORTH_DSP_POP 
a3ab cd 24 97			call macro_forth_dsp_pop 
a3ae				endm 
# End of macro FORTH_DSP_POP
a3ae			 
a3ae					if DEBUG_FORTH_WORDS 
a3ae						DMARK "DO5" 
a3ae						CALLMONITOR 
a3ae					endif 
a3ae			 
a3ae					FORTH_DSP_VALUEHL 
a3ae cd a4 96			call macro_dsp_valuehl 
a3b1				endm 
# End of macro FORTH_DSP_VALUEHL
a3b1			;		push hl		 ; hl now has starting limit counter 
a3b1			 
a3b1					if DEBUG_FORTH_WORDS 
a3b1						DMARK "DO6" 
a3b1						CALLMONITOR 
a3b1					endif 
a3b1					FORTH_DSP_POP 
a3b1 cd 24 97			call macro_forth_dsp_pop 
a3b4				endm 
# End of macro FORTH_DSP_POP
a3b4			 
a3b4			; put counters on the loop stack 
a3b4			 
a3b4			;		pop hl			 ; limit counter 
a3b4 d1					pop de			; start counter 
a3b5			 
a3b5					; push limit counter 
a3b5			 
a3b5					if DEBUG_FORTH_WORDS 
a3b5						DMARK "DO7" 
a3b5						CALLMONITOR 
a3b5					endif 
a3b5					FORTH_LOOP_NEXT 
a3b5 cd b9 96			call macro_forth_loop_next 
a3b8				endm 
# End of macro FORTH_LOOP_NEXT
a3b8			 
a3b8					; push start counter 
a3b8			 
a3b8 eb					ex de, hl 
a3b9					if DEBUG_FORTH_WORDS 
a3b9						DMARK "DO7" 
a3b9						CALLMONITOR 
a3b9					endif 
a3b9					FORTH_LOOP_NEXT 
a3b9 cd b9 96			call macro_forth_loop_next 
a3bc				endm 
# End of macro FORTH_LOOP_NEXT
a3bc			 
a3bc			 
a3bc					; init first round of I counter 
a3bc			 
a3bc 22 9a e6				ld (os_current_i), hl 
a3bf			 
a3bf					if DEBUG_FORTH_WORDS 
a3bf						DMARK "DO8" 
a3bf						CALLMONITOR 
a3bf					endif 
a3bf			 
a3bf					NEXTW 
a3bf c3 de 97			jp macro_next 
a3c2				endm 
# End of macro NEXTW
a3c2			.LOOP: 
a3c2				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
a3c2 22				db WORD_SYS_CORE+14             
a3c3 15 a4			dw .I            
a3c5 05				db 4 + 1 
a3c6 .. 00			db "LOOP",0              
a3cb				endm 
# End of macro CWHEAD
a3cb			; | LOOP ( -- ) Increment and test loop counter  | DONE 
a3cb			 
a3cb				; pop tos as current loop count to hl 
a3cb			 
a3cb				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
a3cb			 
a3cb				FORTH_LOOP_TOS 
a3cb cd d0 96			call macro_forth_loop_tos 
a3ce				endm 
# End of macro FORTH_LOOP_TOS
a3ce e5				push hl 
a3cf			 
a3cf					if DEBUG_FORTH_WORDS_KEY 
a3cf						DMARK "LOP" 
a3cf f5				push af  
a3d0 3a e4 a3			ld a, (.dmark)  
a3d3 32 7a ee			ld (debug_mark),a  
a3d6 3a e5 a3			ld a, (.dmark+1)  
a3d9 32 7b ee			ld (debug_mark+1),a  
a3dc 3a e6 a3			ld a, (.dmark+2)  
a3df 32 7c ee			ld (debug_mark+2),a  
a3e2 18 03			jr .pastdmark  
a3e4 ..			.dmark: db "LOP"  
a3e7 f1			.pastdmark: pop af  
a3e8			endm  
# End of macro DMARK
a3e8						CALLMONITOR 
a3e8 cd 7f 90			call break_point_state  
a3eb				endm  
# End of macro CALLMONITOR
a3eb					endif 
a3eb				; next item on the stack is the limit. get it 
a3eb			 
a3eb			 
a3eb				FORTH_LOOP_POP 
a3eb cd da 96			call macro_forth_loop_pop 
a3ee				endm 
# End of macro FORTH_LOOP_POP
a3ee			 
a3ee				FORTH_LOOP_TOS 
a3ee cd d0 96			call macro_forth_loop_tos 
a3f1				endm 
# End of macro FORTH_LOOP_TOS
a3f1			 
a3f1 d1				pop de		 ; de = i, hl = limit 
a3f2			 
a3f2					if DEBUG_FORTH_WORDS 
a3f2						DMARK "LP1" 
a3f2						CALLMONITOR 
a3f2					endif 
a3f2			 
a3f2				; go back to previous word 
a3f2			 
a3f2 d5				push de    ; save I for inc later 
a3f3			 
a3f3			 
a3f3				; get limit 
a3f3				;  is I at limit? 
a3f3			 
a3f3			 
a3f3					if DEBUG_FORTH_WORDS 
a3f3						DMARK "LP1" 
a3f3						CALLMONITOR 
a3f3					endif 
a3f3			 
a3f3 ed 52			sbc hl, de 
a3f5			 
a3f5			 
a3f5				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
a3f5			 
a3f5 20 0a				jr nz, .loopnotdone 
a3f7			 
a3f7 e1				pop hl   ; get rid of saved I 
a3f8				FORTH_LOOP_POP     ; get rid of limit 
a3f8 cd da 96			call macro_forth_loop_pop 
a3fb				endm 
# End of macro FORTH_LOOP_POP
a3fb			 
a3fb				FORTH_RSP_POP     ; get rid of DO ptr 
a3fb cd d1 95			call macro_forth_rsp_pop 
a3fe				endm 
# End of macro FORTH_RSP_POP
a3fe			 
a3fe			if DEBUG_FORTH_WORDS 
a3fe						DMARK "LP>" 
a3fe				CALLMONITOR 
a3fe			endif 
a3fe			 
a3fe					NEXTW 
a3fe c3 de 97			jp macro_next 
a401				endm 
# End of macro NEXTW
a401				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
a401			 
a401			.loopnotdone: 
a401			 
a401 e1				pop hl    ; get I 
a402 23				inc hl 
a403			 
a403			   	; save new I 
a403			 
a403			 
a403					; set I counter 
a403			 
a403 22 9a e6				ld (os_current_i), hl 
a406			 
a406					if DEBUG_FORTH_WORDS 
a406						DMARK "LPN" 
a406					CALLMONITOR 
a406					endif 
a406					 
a406				FORTH_LOOP_NEXT 
a406 cd b9 96			call macro_forth_loop_next 
a409				endm 
# End of macro FORTH_LOOP_NEXT
a409			 
a409			 
a409					if DEBUG_FORTH_WORDS 
a409						ex de,hl 
a409					endif 
a409			 
a409			;	; get DO ptr 
a409			; 
a409					if DEBUG_FORTH_WORDS 
a409						DMARK "LP7" 
a409					CALLMONITOR 
a409					endif 
a409				FORTH_RSP_TOS 
a409 cd ca 95			call macro_forth_rsp_tos 
a40c				endm 
# End of macro FORTH_RSP_TOS
a40c			 
a40c					if DEBUG_FORTH_WORDS 
a40c						DMARK "LP8" 
a40c					CALLMONITOR 
a40c					endif 
a40c				;push hl 
a40c			 
a40c				; not going to DO any more 
a40c				; get rid of the RSP pointer as DO will add it back in 
a40c				;FORTH_RSP_POP 
a40c				;pop hl 
a40c			 
a40c				;ld hl,(cli_ret_sp) 
a40c				;ld e, (hl) 
a40c				;inc hl 
a40c				;ld d, (hl) 
a40c				;ex de,hl 
a40c 22 76 e6			ld (os_tok_ptr), hl 
a40f					if DEBUG_FORTH_WORDS 
a40f						DMARK "LP<" 
a40f					CALLMONITOR 
a40f				endif 
a40f c3 6f 98			jp exec1 
a412			 
a412					 
a412			 
a412			 
a412					NEXTW 
a412 c3 de 97			jp macro_next 
a415				endm 
# End of macro NEXTW
a415			.I:  
a415			 
a415				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
a415 5e				db WORD_SYS_CORE+74             
a416 40 a4			dw .DLOOP            
a418 02				db 1 + 1 
a419 .. 00			db "I",0              
a41b				endm 
# End of macro CWHEAD
a41b			; | I ( -- ) Current loop counter | DONE 
a41b					if DEBUG_FORTH_WORDS_KEY 
a41b						DMARK "I.." 
a41b f5				push af  
a41c 3a 30 a4			ld a, (.dmark)  
a41f 32 7a ee			ld (debug_mark),a  
a422 3a 31 a4			ld a, (.dmark+1)  
a425 32 7b ee			ld (debug_mark+1),a  
a428 3a 32 a4			ld a, (.dmark+2)  
a42b 32 7c ee			ld (debug_mark+2),a  
a42e 18 03			jr .pastdmark  
a430 ..			.dmark: db "I.."  
a433 f1			.pastdmark: pop af  
a434			endm  
# End of macro DMARK
a434						CALLMONITOR 
a434 cd 7f 90			call break_point_state  
a437				endm  
# End of macro CALLMONITOR
a437					endif 
a437			 
a437 2a 9a e6				ld hl,(os_current_i) 
a43a cd 09 96				call forth_push_numhl 
a43d			 
a43d					NEXTW 
a43d c3 de 97			jp macro_next 
a440				endm 
# End of macro NEXTW
a440			.DLOOP: 
a440				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
a440 5f				db WORD_SYS_CORE+75             
a441 94 a4			dw .REPEAT            
a443 06				db 5 + 1 
a444 .. 00			db "-LOOP",0              
a44a				endm 
# End of macro CWHEAD
a44a			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
a44a				; pop tos as current loop count to hl 
a44a					if DEBUG_FORTH_WORDS_KEY 
a44a						DMARK "-LP" 
a44a f5				push af  
a44b 3a 5f a4			ld a, (.dmark)  
a44e 32 7a ee			ld (debug_mark),a  
a451 3a 60 a4			ld a, (.dmark+1)  
a454 32 7b ee			ld (debug_mark+1),a  
a457 3a 61 a4			ld a, (.dmark+2)  
a45a 32 7c ee			ld (debug_mark+2),a  
a45d 18 03			jr .pastdmark  
a45f ..			.dmark: db "-LP"  
a462 f1			.pastdmark: pop af  
a463			endm  
# End of macro DMARK
a463						CALLMONITOR 
a463 cd 7f 90			call break_point_state  
a466				endm  
# End of macro CALLMONITOR
a466					endif 
a466			 
a466				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
a466			 
a466				FORTH_LOOP_TOS 
a466 cd d0 96			call macro_forth_loop_tos 
a469				endm 
# End of macro FORTH_LOOP_TOS
a469 e5				push hl 
a46a			 
a46a					if DEBUG_FORTH_WORDS 
a46a						DMARK "-LP" 
a46a						CALLMONITOR 
a46a					endif 
a46a				; next item on the stack is the limit. get it 
a46a			 
a46a			 
a46a				FORTH_LOOP_POP 
a46a cd da 96			call macro_forth_loop_pop 
a46d				endm 
# End of macro FORTH_LOOP_POP
a46d			 
a46d				FORTH_LOOP_TOS 
a46d cd d0 96			call macro_forth_loop_tos 
a470				endm 
# End of macro FORTH_LOOP_TOS
a470			 
a470 d1				pop de		 ; de = i, hl = limit 
a471			 
a471					if DEBUG_FORTH_WORDS 
a471						DMARK "-L1" 
a471						CALLMONITOR 
a471					endif 
a471			 
a471				; go back to previous word 
a471			 
a471 d5				push de    ; save I for inc later 
a472			 
a472			 
a472				; get limit 
a472				;  is I at limit? 
a472			 
a472			 
a472					if DEBUG_FORTH_WORDS 
a472						DMARK "-L1" 
a472						CALLMONITOR 
a472					endif 
a472			 
a472 ed 52			sbc hl, de 
a474			 
a474			 
a474				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
a474			 
a474 20 0a				jr nz, .mloopnotdone 
a476			 
a476 e1				pop hl   ; get rid of saved I 
a477				FORTH_LOOP_POP     ; get rid of limit 
a477 cd da 96			call macro_forth_loop_pop 
a47a				endm 
# End of macro FORTH_LOOP_POP
a47a			 
a47a				FORTH_RSP_POP     ; get rid of DO ptr 
a47a cd d1 95			call macro_forth_rsp_pop 
a47d				endm 
# End of macro FORTH_RSP_POP
a47d			 
a47d			if DEBUG_FORTH_WORDS 
a47d						DMARK "-L>" 
a47d				CALLMONITOR 
a47d			endif 
a47d			 
a47d					NEXTW 
a47d c3 de 97			jp macro_next 
a480				endm 
# End of macro NEXTW
a480				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
a480			 
a480			.mloopnotdone: 
a480			 
a480 e1				pop hl    ; get I 
a481 2b				dec hl 
a482			 
a482			   	; save new I 
a482			 
a482			 
a482					; set I counter 
a482			 
a482 22 9a e6				ld (os_current_i), hl 
a485			 
a485					 
a485				FORTH_LOOP_NEXT 
a485 cd b9 96			call macro_forth_loop_next 
a488				endm 
# End of macro FORTH_LOOP_NEXT
a488			 
a488			 
a488					if DEBUG_FORTH_WORDS 
a488						ex de,hl 
a488					endif 
a488			 
a488			;	; get DO ptr 
a488			; 
a488				FORTH_RSP_TOS 
a488 cd ca 95			call macro_forth_rsp_tos 
a48b				endm 
# End of macro FORTH_RSP_TOS
a48b			 
a48b				;push hl 
a48b			 
a48b				; not going to DO any more 
a48b				; get rid of the RSP pointer as DO will add it back in 
a48b				;FORTH_RSP_POP 
a48b				;pop hl 
a48b			 
a48b			 
a48b 22 76 e6			ld (os_tok_ptr), hl 
a48e					if DEBUG_FORTH_WORDS 
a48e						DMARK "-L<" 
a48e					CALLMONITOR 
a48e				endif 
a48e c3 6f 98			jp exec1 
a491			 
a491					 
a491			 
a491			 
a491			 
a491				NEXTW 
a491 c3 de 97			jp macro_next 
a494				endm 
# End of macro NEXTW
a494			 
a494			 
a494			 
a494			 
a494			.REPEAT: 
a494				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
a494 71				db WORD_SYS_CORE+93             
a495 cb a4			dw .UNTIL            
a497 06				db 5 + 1 
a498 .. 00			db "REPEAT",0              
a49f				endm 
# End of macro CWHEAD
a49f			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
a49f			;  push pc to rsp stack past the REPEAT 
a49f					if DEBUG_FORTH_WORDS_KEY 
a49f						DMARK "REP" 
a49f f5				push af  
a4a0 3a b4 a4			ld a, (.dmark)  
a4a3 32 7a ee			ld (debug_mark),a  
a4a6 3a b5 a4			ld a, (.dmark+1)  
a4a9 32 7b ee			ld (debug_mark+1),a  
a4ac 3a b6 a4			ld a, (.dmark+2)  
a4af 32 7c ee			ld (debug_mark+2),a  
a4b2 18 03			jr .pastdmark  
a4b4 ..			.dmark: db "REP"  
a4b7 f1			.pastdmark: pop af  
a4b8			endm  
# End of macro DMARK
a4b8						CALLMONITOR 
a4b8 cd 7f 90			call break_point_state  
a4bb				endm  
# End of macro CALLMONITOR
a4bb					endif 
a4bb			 
a4bb 2a 76 e6				ld hl, (os_tok_ptr) 
a4be 23					inc hl   ; R 
a4bf 23					inc hl  ; E 
a4c0 23					inc hl   ; P 
a4c1 23					inc hl   ; E 
a4c2 23					inc hl   ; A 
a4c3 23					inc hl   ; T 
a4c4 23					inc hl   ; zero 
a4c5					FORTH_RSP_NEXT 
a4c5 cd b3 95			call macro_forth_rsp_next 
a4c8				endm 
# End of macro FORTH_RSP_NEXT
a4c8			 
a4c8			 
a4c8					if DEBUG_FORTH_WORDS 
a4c8						DMARK "REP" 
a4c8						;pop bc    ; TODO BUG ?????? what is this for???? 
a4c8						CALLMONITOR 
a4c8					endif 
a4c8			 
a4c8					NEXTW 
a4c8 c3 de 97			jp macro_next 
a4cb				endm 
# End of macro NEXTW
a4cb			;	       NEXTW 
a4cb			 
a4cb			.UNTIL: 
a4cb				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
a4cb 72				db WORD_SYS_CORE+94             
a4cc 0e a5			dw .ENDFLOW            
a4ce 06				db 5 + 1 
a4cf .. 00			db "UNTIL",0              
a4d5				endm 
# End of macro CWHEAD
a4d5			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
a4d5			 
a4d5				; pop tos as check 
a4d5			 
a4d5				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
a4d5			 
a4d5				FORTH_DSP_VALUEHL 
a4d5 cd a4 96			call macro_dsp_valuehl 
a4d8				endm 
# End of macro FORTH_DSP_VALUEHL
a4d8			 
a4d8					if DEBUG_FORTH_WORDS_KEY 
a4d8						DMARK "UNT" 
a4d8 f5				push af  
a4d9 3a ed a4			ld a, (.dmark)  
a4dc 32 7a ee			ld (debug_mark),a  
a4df 3a ee a4			ld a, (.dmark+1)  
a4e2 32 7b ee			ld (debug_mark+1),a  
a4e5 3a ef a4			ld a, (.dmark+2)  
a4e8 32 7c ee			ld (debug_mark+2),a  
a4eb 18 03			jr .pastdmark  
a4ed ..			.dmark: db "UNT"  
a4f0 f1			.pastdmark: pop af  
a4f1			endm  
# End of macro DMARK
a4f1						CALLMONITOR 
a4f1 cd 7f 90			call break_point_state  
a4f4				endm  
# End of macro CALLMONITOR
a4f4					endif 
a4f4			 
a4f4			;	push hl 
a4f4				FORTH_DSP_POP 
a4f4 cd 24 97			call macro_forth_dsp_pop 
a4f7				endm 
# End of macro FORTH_DSP_POP
a4f7			 
a4f7			;	pop hl 
a4f7			 
a4f7				; test if true 
a4f7			 
a4f7 cd e4 88			call ishlzero 
a4fa			;	ld a,l 
a4fa			;	add h 
a4fa			; 
a4fa			;	cp 0 
a4fa			 
a4fa 20 06			jr nz, .untilnotdone 
a4fc			 
a4fc					if DEBUG_FORTH_WORDS 
a4fc						DMARK "UNf" 
a4fc						CALLMONITOR 
a4fc					endif 
a4fc			 
a4fc			 
a4fc			 
a4fc				FORTH_RSP_POP     ; get rid of DO ptr 
a4fc cd d1 95			call macro_forth_rsp_pop 
a4ff				endm 
# End of macro FORTH_RSP_POP
a4ff			 
a4ff			if DEBUG_FORTH_WORDS 
a4ff						DMARK "UN>" 
a4ff				CALLMONITOR 
a4ff			endif 
a4ff			 
a4ff					NEXTW 
a4ff c3 de 97			jp macro_next 
a502				endm 
# End of macro NEXTW
a502				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
a502			 
a502			.untilnotdone: 
a502			 
a502			 
a502			;	; get DO ptr 
a502			; 
a502				FORTH_RSP_TOS 
a502 cd ca 95			call macro_forth_rsp_tos 
a505				endm 
# End of macro FORTH_RSP_TOS
a505			 
a505				;push hl 
a505			 
a505				; not going to DO any more 
a505				; get rid of the RSP pointer as DO will add it back in 
a505				;FORTH_RSP_POP 
a505				;pop hl 
a505			 
a505			 
a505 22 76 e6			ld (os_tok_ptr), hl 
a508					if DEBUG_FORTH_WORDS 
a508						DMARK "UN<" 
a508					CALLMONITOR 
a508				endif 
a508 c3 6f 98			jp exec1 
a50b			 
a50b					 
a50b			 
a50b			 
a50b					NEXTW 
a50b c3 de 97			jp macro_next 
a50e				endm 
# End of macro NEXTW
a50e			 
a50e			 
a50e			.ENDFLOW: 
a50e			 
a50e			; eof 
a50e			 
# End of file forth_words_flow.asm
a50e			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
a50e			include "forth_words_logic.asm" 
a50e			 
a50e			; | ## Logic Words 
a50e			 
a50e			.NOT: 
a50e				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
a50e 2d				db WORD_SYS_CORE+25             
a50f 56 a5			dw .IS            
a511 04				db 3 + 1 
a512 .. 00			db "NOT",0              
a516				endm 
# End of macro CWHEAD
a516			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
a516					if DEBUG_FORTH_WORDS_KEY 
a516						DMARK "NOT" 
a516 f5				push af  
a517 3a 2b a5			ld a, (.dmark)  
a51a 32 7a ee			ld (debug_mark),a  
a51d 3a 2c a5			ld a, (.dmark+1)  
a520 32 7b ee			ld (debug_mark+1),a  
a523 3a 2d a5			ld a, (.dmark+2)  
a526 32 7c ee			ld (debug_mark+2),a  
a529 18 03			jr .pastdmark  
a52b ..			.dmark: db "NOT"  
a52e f1			.pastdmark: pop af  
a52f			endm  
# End of macro DMARK
a52f						CALLMONITOR 
a52f cd 7f 90			call break_point_state  
a532				endm  
# End of macro CALLMONITOR
a532					endif 
a532					FORTH_DSP 
a532 cd 89 96			call macro_forth_dsp 
a535				endm 
# End of macro FORTH_DSP
a535 7e					ld a,(hl)	; get type of value on TOS 
a536 fe 02				cp DS_TYPE_INUM  
a538 28 03				jr z, .noti 
a53a					NEXTW 
a53a c3 de 97			jp macro_next 
a53d				endm 
# End of macro NEXTW
a53d			.noti:          FORTH_DSP_VALUEHL 
a53d cd a4 96			call macro_dsp_valuehl 
a540				endm 
# End of macro FORTH_DSP_VALUEHL
a540			;		push hl 
a540					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a540 cd 24 97			call macro_forth_dsp_pop 
a543				endm 
# End of macro FORTH_DSP_POP
a543			;		pop hl 
a543 3e 00				ld a,0 
a545 bd					cp l 
a546 28 04				jr z, .not2t 
a548 2e 00				ld l, 0 
a54a 18 02				jr .notip 
a54c			 
a54c 2e ff		.not2t:		ld l, 255 
a54e			 
a54e 26 00		.notip:		ld h, 0	 
a550			 
a550 cd 09 96				call forth_push_numhl 
a553					NEXTW 
a553 c3 de 97			jp macro_next 
a556				endm 
# End of macro NEXTW
a556			 
a556			.IS: 
a556				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
a556 2d				db WORD_SYS_CORE+25             
a557 7c a5			dw .LZERO            
a559 03				db 2 + 1 
a55a .. 00			db "IS",0              
a55d				endm 
# End of macro CWHEAD
a55d			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
a55d					if DEBUG_FORTH_WORDS_KEY 
a55d						DMARK "IS." 
a55d f5				push af  
a55e 3a 72 a5			ld a, (.dmark)  
a561 32 7a ee			ld (debug_mark),a  
a564 3a 73 a5			ld a, (.dmark+1)  
a567 32 7b ee			ld (debug_mark+1),a  
a56a 3a 74 a5			ld a, (.dmark+2)  
a56d 32 7c ee			ld (debug_mark+2),a  
a570 18 03			jr .pastdmark  
a572 ..			.dmark: db "IS."  
a575 f1			.pastdmark: pop af  
a576			endm  
# End of macro DMARK
a576						CALLMONITOR 
a576 cd 7f 90			call break_point_state  
a579				endm  
# End of macro CALLMONITOR
a579					endif 
a579					NEXTW 
a579 c3 de 97			jp macro_next 
a57c				endm 
# End of macro NEXTW
a57c			.LZERO: 
a57c				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
a57c 2d				db WORD_SYS_CORE+25             
a57d 86 a5			dw .TZERO            
a57f 03				db 2 + 1 
a580 .. 00			db "0<",0              
a583				endm 
# End of macro CWHEAD
a583			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
a583					NEXTW 
a583 c3 de 97			jp macro_next 
a586				endm 
# End of macro NEXTW
a586			.TZERO: 
a586				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
a586 2e				db WORD_SYS_CORE+26             
a587 cd a5			dw .LESS            
a589 03				db 2 + 1 
a58a .. 00			db "0=",0              
a58d				endm 
# End of macro CWHEAD
a58d			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
a58d				; TODO add floating point number detection 
a58d					;v5 FORTH_DSP_VALUE 
a58d					if DEBUG_FORTH_WORDS_KEY 
a58d						DMARK "0=." 
a58d f5				push af  
a58e 3a a2 a5			ld a, (.dmark)  
a591 32 7a ee			ld (debug_mark),a  
a594 3a a3 a5			ld a, (.dmark+1)  
a597 32 7b ee			ld (debug_mark+1),a  
a59a 3a a4 a5			ld a, (.dmark+2)  
a59d 32 7c ee			ld (debug_mark+2),a  
a5a0 18 03			jr .pastdmark  
a5a2 ..			.dmark: db "0=."  
a5a5 f1			.pastdmark: pop af  
a5a6			endm  
# End of macro DMARK
a5a6						CALLMONITOR 
a5a6 cd 7f 90			call break_point_state  
a5a9				endm  
# End of macro CALLMONITOR
a5a9					endif 
a5a9					FORTH_DSP 
a5a9 cd 89 96			call macro_forth_dsp 
a5ac				endm 
# End of macro FORTH_DSP
a5ac 7e					ld a,(hl)	; get type of value on TOS 
a5ad fe 02				cp DS_TYPE_INUM  
a5af 28 00				jr z, .tz_inum 
a5b1			 
a5b1				if FORTH_ENABLE_FLOATMATH 
a5b1					jr .tz_done 
a5b1			 
a5b1				endif 
a5b1					 
a5b1			 
a5b1			.tz_inum: 
a5b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5b1 cd a4 96			call macro_dsp_valuehl 
a5b4				endm 
# End of macro FORTH_DSP_VALUEHL
a5b4			 
a5b4			;		push hl 
a5b4			 
a5b4					; destroy value TOS 
a5b4			 
a5b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5b4 cd 24 97			call macro_forth_dsp_pop 
a5b7				endm 
# End of macro FORTH_DSP_POP
a5b7			 
a5b7			;		pop hl 
a5b7			 
a5b7 3e 00				ld a,0 
a5b9			 
a5b9 bd					cp l 
a5ba 20 08				jr nz, .tz_notzero 
a5bc			 
a5bc bc					cp h 
a5bd			 
a5bd 20 05				jr nz, .tz_notzero 
a5bf			 
a5bf			 
a5bf 21 01 00				ld hl, FORTH_TRUE 
a5c2 18 03				jr .tz_done 
a5c4			 
a5c4 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
a5c7			 
a5c7					; push value back onto stack for another op etc 
a5c7			 
a5c7			.tz_done: 
a5c7 cd 09 96				call forth_push_numhl 
a5ca			 
a5ca					NEXTW 
a5ca c3 de 97			jp macro_next 
a5cd				endm 
# End of macro NEXTW
a5cd			.LESS: 
a5cd				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
a5cd 2f				db WORD_SYS_CORE+27             
a5ce 1a a6			dw .GT            
a5d0 02				db 1 + 1 
a5d1 .. 00			db "<",0              
a5d3				endm 
# End of macro CWHEAD
a5d3			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
a5d3				; TODO add floating point number detection 
a5d3					if DEBUG_FORTH_WORDS_KEY 
a5d3						DMARK "LES" 
a5d3 f5				push af  
a5d4 3a e8 a5			ld a, (.dmark)  
a5d7 32 7a ee			ld (debug_mark),a  
a5da 3a e9 a5			ld a, (.dmark+1)  
a5dd 32 7b ee			ld (debug_mark+1),a  
a5e0 3a ea a5			ld a, (.dmark+2)  
a5e3 32 7c ee			ld (debug_mark+2),a  
a5e6 18 03			jr .pastdmark  
a5e8 ..			.dmark: db "LES"  
a5eb f1			.pastdmark: pop af  
a5ec			endm  
# End of macro DMARK
a5ec						CALLMONITOR 
a5ec cd 7f 90			call break_point_state  
a5ef				endm  
# End of macro CALLMONITOR
a5ef					endif 
a5ef					FORTH_DSP 
a5ef cd 89 96			call macro_forth_dsp 
a5f2				endm 
# End of macro FORTH_DSP
a5f2					;v5 FORTH_DSP_VALUE 
a5f2 7e					ld a,(hl)	; get type of value on TOS 
a5f3 fe 02				cp DS_TYPE_INUM  
a5f5 28 00				jr z, .less_inum 
a5f7			 
a5f7				if FORTH_ENABLE_FLOATMATH 
a5f7					jr .less_done 
a5f7			 
a5f7				endif 
a5f7					 
a5f7			 
a5f7			.less_inum: 
a5f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5f7 cd a4 96			call macro_dsp_valuehl 
a5fa				endm 
# End of macro FORTH_DSP_VALUEHL
a5fa			 
a5fa e5					push hl  ; u2 
a5fb			 
a5fb					; destroy value TOS 
a5fb			 
a5fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5fb cd 24 97			call macro_forth_dsp_pop 
a5fe				endm 
# End of macro FORTH_DSP_POP
a5fe			 
a5fe			 
a5fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5fe cd a4 96			call macro_dsp_valuehl 
a601				endm 
# End of macro FORTH_DSP_VALUEHL
a601			 
a601 e5					push hl    ; u1 
a602			 
a602					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a602 cd 24 97			call macro_forth_dsp_pop 
a605				endm 
# End of macro FORTH_DSP_POP
a605			 
a605			 
a605 b7			 or a      ;clear carry flag 
a606 01 00 00		 ld bc, FORTH_FALSE 
a609 e1			  pop hl    ; u1 
a60a d1			  pop de    ; u2 
a60b ed 52		  sbc hl,de 
a60d 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
a60f			 
a60f 01 01 00		 ld bc, FORTH_TRUE 
a612			.lscont:  
a612 c5					push bc 
a613 e1					pop hl 
a614			 
a614					if DEBUG_FORTH_WORDS 
a614						DMARK "LT1" 
a614						CALLMONITOR 
a614					endif 
a614 cd 09 96				call forth_push_numhl 
a617			 
a617					NEXTW 
a617 c3 de 97			jp macro_next 
a61a				endm 
# End of macro NEXTW
a61a			.GT: 
a61a				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
a61a 30				db WORD_SYS_CORE+28             
a61b 67 a6			dw .EQUAL            
a61d 02				db 1 + 1 
a61e .. 00			db ">",0              
a620				endm 
# End of macro CWHEAD
a620			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
a620				; TODO add floating point number detection 
a620					if DEBUG_FORTH_WORDS_KEY 
a620						DMARK "GRT" 
a620 f5				push af  
a621 3a 35 a6			ld a, (.dmark)  
a624 32 7a ee			ld (debug_mark),a  
a627 3a 36 a6			ld a, (.dmark+1)  
a62a 32 7b ee			ld (debug_mark+1),a  
a62d 3a 37 a6			ld a, (.dmark+2)  
a630 32 7c ee			ld (debug_mark+2),a  
a633 18 03			jr .pastdmark  
a635 ..			.dmark: db "GRT"  
a638 f1			.pastdmark: pop af  
a639			endm  
# End of macro DMARK
a639						CALLMONITOR 
a639 cd 7f 90			call break_point_state  
a63c				endm  
# End of macro CALLMONITOR
a63c					endif 
a63c					FORTH_DSP 
a63c cd 89 96			call macro_forth_dsp 
a63f				endm 
# End of macro FORTH_DSP
a63f					;FORTH_DSP_VALUE 
a63f 7e					ld a,(hl)	; get type of value on TOS 
a640 fe 02				cp DS_TYPE_INUM  
a642 28 00				jr z, .gt_inum 
a644			 
a644				if FORTH_ENABLE_FLOATMATH 
a644					jr .gt_done 
a644			 
a644				endif 
a644					 
a644			 
a644			.gt_inum: 
a644					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a644 cd a4 96			call macro_dsp_valuehl 
a647				endm 
# End of macro FORTH_DSP_VALUEHL
a647			 
a647 e5					push hl  ; u2 
a648			 
a648					; destroy value TOS 
a648			 
a648					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a648 cd 24 97			call macro_forth_dsp_pop 
a64b				endm 
# End of macro FORTH_DSP_POP
a64b			 
a64b			 
a64b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a64b cd a4 96			call macro_dsp_valuehl 
a64e				endm 
# End of macro FORTH_DSP_VALUEHL
a64e			 
a64e e5					push hl    ; u1 
a64f			 
a64f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a64f cd 24 97			call macro_forth_dsp_pop 
a652				endm 
# End of macro FORTH_DSP_POP
a652			 
a652			 
a652 b7			 or a      ;clear carry flag 
a653 01 00 00		 ld bc, FORTH_FALSE 
a656 e1			  pop hl    ; u1 
a657 d1			  pop de    ; u2 
a658 ed 52		  sbc hl,de 
a65a 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
a65c			 
a65c 01 01 00		 ld bc, FORTH_TRUE 
a65f			.gtcont:  
a65f c5					push bc 
a660 e1					pop hl 
a661			 
a661					if DEBUG_FORTH_WORDS 
a661						DMARK "GT1" 
a661						CALLMONITOR 
a661					endif 
a661 cd 09 96				call forth_push_numhl 
a664			 
a664					NEXTW 
a664 c3 de 97			jp macro_next 
a667				endm 
# End of macro NEXTW
a667			.EQUAL: 
a667				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
a667 31				db WORD_SYS_CORE+29             
a668 b6 a6			dw .ENDLOGIC            
a66a 02				db 1 + 1 
a66b .. 00			db "=",0              
a66d				endm 
# End of macro CWHEAD
a66d			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
a66d				; TODO add floating point number detection 
a66d					if DEBUG_FORTH_WORDS_KEY 
a66d						DMARK "EQ." 
a66d f5				push af  
a66e 3a 82 a6			ld a, (.dmark)  
a671 32 7a ee			ld (debug_mark),a  
a674 3a 83 a6			ld a, (.dmark+1)  
a677 32 7b ee			ld (debug_mark+1),a  
a67a 3a 84 a6			ld a, (.dmark+2)  
a67d 32 7c ee			ld (debug_mark+2),a  
a680 18 03			jr .pastdmark  
a682 ..			.dmark: db "EQ."  
a685 f1			.pastdmark: pop af  
a686			endm  
# End of macro DMARK
a686						CALLMONITOR 
a686 cd 7f 90			call break_point_state  
a689				endm  
# End of macro CALLMONITOR
a689					endif 
a689					FORTH_DSP 
a689 cd 89 96			call macro_forth_dsp 
a68c				endm 
# End of macro FORTH_DSP
a68c					;v5 FORTH_DSP_VALUE 
a68c 7e					ld a,(hl)	; get type of value on TOS 
a68d fe 02				cp DS_TYPE_INUM  
a68f 28 00				jr z, .eq_inum 
a691			 
a691				if FORTH_ENABLE_FLOATMATH 
a691					jr .eq_done 
a691			 
a691				endif 
a691					 
a691			 
a691			.eq_inum: 
a691					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a691 cd a4 96			call macro_dsp_valuehl 
a694				endm 
# End of macro FORTH_DSP_VALUEHL
a694			 
a694 e5					push hl 
a695			 
a695					; destroy value TOS 
a695			 
a695					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a695 cd 24 97			call macro_forth_dsp_pop 
a698				endm 
# End of macro FORTH_DSP_POP
a698			 
a698			 
a698					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a698 cd a4 96			call macro_dsp_valuehl 
a69b				endm 
# End of macro FORTH_DSP_VALUEHL
a69b			 
a69b					; one value on hl get other one back 
a69b			 
a69b e5					push hl 
a69c			 
a69c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a69c cd 24 97			call macro_forth_dsp_pop 
a69f				endm 
# End of macro FORTH_DSP_POP
a69f			 
a69f 0e 00				ld c, FORTH_FALSE 
a6a1			 
a6a1 e1					pop hl 
a6a2 d1					pop de 
a6a3			 
a6a3 7b					ld a, e 
a6a4 bd					cp l 
a6a5			 
a6a5 20 06				jr nz, .eq_done 
a6a7			 
a6a7 7a					ld a, d 
a6a8 bc					cp h 
a6a9			 
a6a9 20 02				jr nz, .eq_done 
a6ab			 
a6ab 0e 01				ld c, FORTH_TRUE 
a6ad					 
a6ad			 
a6ad			 
a6ad			.eq_done: 
a6ad			 
a6ad					; TODO push value back onto stack for another op etc 
a6ad			 
a6ad 26 00				ld h, 0 
a6af 69					ld l, c 
a6b0					if DEBUG_FORTH_WORDS 
a6b0						DMARK "EQ1" 
a6b0						CALLMONITOR 
a6b0					endif 
a6b0 cd 09 96				call forth_push_numhl 
a6b3			 
a6b3					NEXTW 
a6b3 c3 de 97			jp macro_next 
a6b6				endm 
# End of macro NEXTW
a6b6			 
a6b6			 
a6b6			.ENDLOGIC: 
a6b6			; eof 
a6b6			 
a6b6			 
# End of file forth_words_logic.asm
a6b6			include "forth_words_maths.asm" 
a6b6			 
a6b6			; | ## Maths Words 
a6b6			 
a6b6			.PLUS:	 
a6b6				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
a6b6 15				db WORD_SYS_CORE+1             
a6b7 f8 a6			dw .NEG            
a6b9 02				db 1 + 1 
a6ba .. 00			db "+",0              
a6bc				endm 
# End of macro CWHEAD
a6bc			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
a6bc					if DEBUG_FORTH_WORDS_KEY 
a6bc						DMARK "PLU" 
a6bc f5				push af  
a6bd 3a d1 a6			ld a, (.dmark)  
a6c0 32 7a ee			ld (debug_mark),a  
a6c3 3a d2 a6			ld a, (.dmark+1)  
a6c6 32 7b ee			ld (debug_mark+1),a  
a6c9 3a d3 a6			ld a, (.dmark+2)  
a6cc 32 7c ee			ld (debug_mark+2),a  
a6cf 18 03			jr .pastdmark  
a6d1 ..			.dmark: db "PLU"  
a6d4 f1			.pastdmark: pop af  
a6d5			endm  
# End of macro DMARK
a6d5						CALLMONITOR 
a6d5 cd 7f 90			call break_point_state  
a6d8				endm  
# End of macro CALLMONITOR
a6d8					endif 
a6d8					; add top two values and push back result 
a6d8			 
a6d8					;for v5 FORTH_DSP_VALUE 
a6d8					FORTH_DSP 
a6d8 cd 89 96			call macro_forth_dsp 
a6db				endm 
# End of macro FORTH_DSP
a6db 7e					ld a,(hl)	; get type of value on TOS 
a6dc fe 02				cp DS_TYPE_INUM  
a6de 28 03				jr z, .dot_inum 
a6e0			 
a6e0					NEXTW 
a6e0 c3 de 97			jp macro_next 
a6e3				endm 
# End of macro NEXTW
a6e3			 
a6e3			; float maths 
a6e3			 
a6e3				if FORTH_ENABLE_FLOATMATH 
a6e3						inc hl      ; now at start of numeric as string 
a6e3			 
a6e3					if DEBUG_FORTH_MATHS 
a6e3						DMARK "ADD" 
a6e3				CALLMONITOR 
a6e3					endif 
a6e3			 
a6e3					;ld ix, hl 
a6e3					call CON 
a6e3			 
a6e3			 
a6e3					push hl 
a6e3					 
a6e3					 
a6e3			 
a6e3						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
a6e3			 
a6e3					; get next number 
a6e3			 
a6e3						FORTH_DSP_VALUE 
a6e3			 
a6e3						inc hl      ; now at start of numeric as string 
a6e3			 
a6e3					;ld ix, hl 
a6e3					call CON 
a6e3			 
a6e3					push hl 
a6e3			 
a6e3			 
a6e3						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a6e3			 
a6e3						; TODO do add 
a6e3			 
a6e3						call IADD 
a6e3			 
a6e3						; TODO get result back as ascii 
a6e3			 
a6e3						; TODO push result  
a6e3			 
a6e3			 
a6e3			 
a6e3						jr .dot_done 
a6e3				endif 
a6e3			 
a6e3			.dot_inum: 
a6e3			 
a6e3			 
a6e3					if DEBUG_FORTH_DOT 
a6e3						DMARK "+IT" 
a6e3				CALLMONITOR 
a6e3					endif 
a6e3			 
a6e3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a6e3 cd a4 96			call macro_dsp_valuehl 
a6e6				endm 
# End of macro FORTH_DSP_VALUEHL
a6e6			 
a6e6				; TODO add floating point number detection 
a6e6			 
a6e6 e5					push hl 
a6e7			 
a6e7					; destroy value TOS 
a6e7			 
a6e7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a6e7 cd 24 97			call macro_forth_dsp_pop 
a6ea				endm 
# End of macro FORTH_DSP_POP
a6ea			 
a6ea			 
a6ea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a6ea cd a4 96			call macro_dsp_valuehl 
a6ed				endm 
# End of macro FORTH_DSP_VALUEHL
a6ed			 
a6ed					; one value on hl get other one back 
a6ed			 
a6ed d1					pop de 
a6ee			 
a6ee					; do the add 
a6ee			 
a6ee 19					add hl,de 
a6ef			 
a6ef					; save it 
a6ef			 
a6ef			;		push hl	 
a6ef			 
a6ef					; 
a6ef			 
a6ef					; destroy value TOS 
a6ef			 
a6ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a6ef cd 24 97			call macro_forth_dsp_pop 
a6f2				endm 
# End of macro FORTH_DSP_POP
a6f2			 
a6f2					; TODO push value back onto stack for another op etc 
a6f2			 
a6f2			;		pop hl 
a6f2			 
a6f2			.dot_done: 
a6f2 cd 09 96				call forth_push_numhl 
a6f5			 
a6f5					NEXTW 
a6f5 c3 de 97			jp macro_next 
a6f8				endm 
# End of macro NEXTW
a6f8			.NEG: 
a6f8			 
a6f8				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
a6f8 17				db WORD_SYS_CORE+3             
a6f9 3b a7			dw .DIV            
a6fb 02				db 1 + 1 
a6fc .. 00			db "-",0              
a6fe				endm 
# End of macro CWHEAD
a6fe			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
a6fe					if DEBUG_FORTH_WORDS_KEY 
a6fe						DMARK "SUB" 
a6fe f5				push af  
a6ff 3a 13 a7			ld a, (.dmark)  
a702 32 7a ee			ld (debug_mark),a  
a705 3a 14 a7			ld a, (.dmark+1)  
a708 32 7b ee			ld (debug_mark+1),a  
a70b 3a 15 a7			ld a, (.dmark+2)  
a70e 32 7c ee			ld (debug_mark+2),a  
a711 18 03			jr .pastdmark  
a713 ..			.dmark: db "SUB"  
a716 f1			.pastdmark: pop af  
a717			endm  
# End of macro DMARK
a717						CALLMONITOR 
a717 cd 7f 90			call break_point_state  
a71a				endm  
# End of macro CALLMONITOR
a71a					endif 
a71a			 
a71a			 
a71a				; TODO add floating point number detection 
a71a					; v5 FORTH_DSP_VALUE 
a71a					FORTH_DSP 
a71a cd 89 96			call macro_forth_dsp 
a71d				endm 
# End of macro FORTH_DSP
a71d 7e					ld a,(hl)	; get type of value on TOS 
a71e fe 02				cp DS_TYPE_INUM  
a720 28 03				jr z, .neg_inum 
a722			 
a722					NEXTW 
a722 c3 de 97			jp macro_next 
a725				endm 
# End of macro NEXTW
a725			 
a725			; float maths 
a725			 
a725				if FORTH_ENABLE_FLOATMATH 
a725					jr .neg_done 
a725			 
a725				endif 
a725					 
a725			 
a725			.neg_inum: 
a725					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a725 cd a4 96			call macro_dsp_valuehl 
a728				endm 
# End of macro FORTH_DSP_VALUEHL
a728			 
a728 e5					push hl 
a729			 
a729					; destroy value TOS 
a729			 
a729					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a729 cd 24 97			call macro_forth_dsp_pop 
a72c				endm 
# End of macro FORTH_DSP_POP
a72c			 
a72c			 
a72c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a72c cd a4 96			call macro_dsp_valuehl 
a72f				endm 
# End of macro FORTH_DSP_VALUEHL
a72f			 
a72f					; one value on hl get other one back 
a72f			 
a72f d1					pop de 
a730			 
a730					; do the sub 
a730			;		ex de, hl 
a730			 
a730 ed 52				sbc hl,de 
a732			 
a732					; save it 
a732			 
a732			;		push hl	 
a732			 
a732					; 
a732			 
a732					; destroy value TOS 
a732			 
a732					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a732 cd 24 97			call macro_forth_dsp_pop 
a735				endm 
# End of macro FORTH_DSP_POP
a735			 
a735					; TODO push value back onto stack for another op etc 
a735			 
a735			;		pop hl 
a735			 
a735 cd 09 96				call forth_push_numhl 
a738			.neg_done: 
a738			 
a738					NEXTW 
a738 c3 de 97			jp macro_next 
a73b				endm 
# End of macro NEXTW
a73b			.DIV: 
a73b				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
a73b 18				db WORD_SYS_CORE+4             
a73c 88 a7			dw .MUL            
a73e 02				db 1 + 1 
a73f .. 00			db "/",0              
a741				endm 
# End of macro CWHEAD
a741			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
a741					if DEBUG_FORTH_WORDS_KEY 
a741						DMARK "DIV" 
a741 f5				push af  
a742 3a 56 a7			ld a, (.dmark)  
a745 32 7a ee			ld (debug_mark),a  
a748 3a 57 a7			ld a, (.dmark+1)  
a74b 32 7b ee			ld (debug_mark+1),a  
a74e 3a 58 a7			ld a, (.dmark+2)  
a751 32 7c ee			ld (debug_mark+2),a  
a754 18 03			jr .pastdmark  
a756 ..			.dmark: db "DIV"  
a759 f1			.pastdmark: pop af  
a75a			endm  
# End of macro DMARK
a75a						CALLMONITOR 
a75a cd 7f 90			call break_point_state  
a75d				endm  
# End of macro CALLMONITOR
a75d					endif 
a75d				; TODO add floating point number detection 
a75d					; v5 FORTH_DSP_VALUE 
a75d					FORTH_DSP 
a75d cd 89 96			call macro_forth_dsp 
a760				endm 
# End of macro FORTH_DSP
a760 7e					ld a,(hl)	; get type of value on TOS 
a761 fe 02				cp DS_TYPE_INUM  
a763 28 03				jr z, .div_inum 
a765			 
a765				if FORTH_ENABLE_FLOATMATH 
a765					jr .div_done 
a765			 
a765				endif 
a765					NEXTW 
a765 c3 de 97			jp macro_next 
a768				endm 
# End of macro NEXTW
a768			.div_inum: 
a768			 
a768					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a768 cd a4 96			call macro_dsp_valuehl 
a76b				endm 
# End of macro FORTH_DSP_VALUEHL
a76b			 
a76b e5					push hl    ; to go to bc 
a76c			 
a76c					; destroy value TOS 
a76c			 
a76c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a76c cd 24 97			call macro_forth_dsp_pop 
a76f				endm 
# End of macro FORTH_DSP_POP
a76f			 
a76f			 
a76f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a76f cd a4 96			call macro_dsp_valuehl 
a772				endm 
# End of macro FORTH_DSP_VALUEHL
a772			 
a772					; hl to go to de 
a772			 
a772 e5					push hl 
a773			 
a773 c1					pop bc 
a774 d1					pop de		 
a775			 
a775			 
a775					if DEBUG_FORTH_MATHS 
a775						DMARK "DIV" 
a775				CALLMONITOR 
a775					endif 
a775					; one value on hl but move to a get other one back 
a775			 
a775			        
a775 cd 18 88			call Div16 
a778			 
a778			;	push af	 
a778 e5				push hl 
a779 c5				push bc 
a77a			 
a77a					if DEBUG_FORTH_MATHS 
a77a						DMARK "DI1" 
a77a				CALLMONITOR 
a77a					endif 
a77a			 
a77a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a77a cd 24 97			call macro_forth_dsp_pop 
a77d				endm 
# End of macro FORTH_DSP_POP
a77d			 
a77d			 
a77d			 
a77d e1					pop hl    ; result 
a77e			 
a77e cd 09 96				call forth_push_numhl 
a781			 
a781 e1					pop hl    ; reminder 
a782			;		ld h,0 
a782			;		ld l,d 
a782			 
a782 cd 09 96				call forth_push_numhl 
a785			.div_done: 
a785					NEXTW 
a785 c3 de 97			jp macro_next 
a788				endm 
# End of macro NEXTW
a788			.MUL: 
a788				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
a788 19				db WORD_SYS_CORE+5             
a789 cd a7			dw .MIN            
a78b 02				db 1 + 1 
a78c .. 00			db "*",0              
a78e				endm 
# End of macro CWHEAD
a78e			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
a78e				; TODO add floating point number detection 
a78e					if DEBUG_FORTH_WORDS_KEY 
a78e						DMARK "MUL" 
a78e f5				push af  
a78f 3a a3 a7			ld a, (.dmark)  
a792 32 7a ee			ld (debug_mark),a  
a795 3a a4 a7			ld a, (.dmark+1)  
a798 32 7b ee			ld (debug_mark+1),a  
a79b 3a a5 a7			ld a, (.dmark+2)  
a79e 32 7c ee			ld (debug_mark+2),a  
a7a1 18 03			jr .pastdmark  
a7a3 ..			.dmark: db "MUL"  
a7a6 f1			.pastdmark: pop af  
a7a7			endm  
# End of macro DMARK
a7a7						CALLMONITOR 
a7a7 cd 7f 90			call break_point_state  
a7aa				endm  
# End of macro CALLMONITOR
a7aa					endif 
a7aa					FORTH_DSP 
a7aa cd 89 96			call macro_forth_dsp 
a7ad				endm 
# End of macro FORTH_DSP
a7ad					; v5 FORTH_DSP_VALUE 
a7ad 7e					ld a,(hl)	; get type of value on TOS 
a7ae fe 02				cp DS_TYPE_INUM  
a7b0 28 03				jr z, .mul_inum 
a7b2			 
a7b2				if FORTH_ENABLE_FLOATMATH 
a7b2					jr .mul_done 
a7b2			 
a7b2				endif 
a7b2			 
a7b2					NEXTW 
a7b2 c3 de 97			jp macro_next 
a7b5				endm 
# End of macro NEXTW
a7b5			.mul_inum:	 
a7b5			 
a7b5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a7b5 cd a4 96			call macro_dsp_valuehl 
a7b8				endm 
# End of macro FORTH_DSP_VALUEHL
a7b8			 
a7b8 e5					push hl 
a7b9			 
a7b9					; destroy value TOS 
a7b9			 
a7b9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a7b9 cd 24 97			call macro_forth_dsp_pop 
a7bc				endm 
# End of macro FORTH_DSP_POP
a7bc			 
a7bc			 
a7bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a7bc cd a4 96			call macro_dsp_valuehl 
a7bf				endm 
# End of macro FORTH_DSP_VALUEHL
a7bf			 
a7bf					; one value on hl but move to a get other one back 
a7bf			 
a7bf 7d					ld a, l 
a7c0			 
a7c0 d1					pop de 
a7c1			 
a7c1					; do the mull 
a7c1			;		ex de, hl 
a7c1			 
a7c1 cd 3e 88				call Mult16 
a7c4					; save it 
a7c4			 
a7c4			;		push hl	 
a7c4			 
a7c4					; 
a7c4			 
a7c4					; destroy value TOS 
a7c4			 
a7c4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a7c4 cd 24 97			call macro_forth_dsp_pop 
a7c7				endm 
# End of macro FORTH_DSP_POP
a7c7			 
a7c7					; TODO push value back onto stack for another op etc 
a7c7			 
a7c7			;		pop hl 
a7c7			 
a7c7 cd 09 96				call forth_push_numhl 
a7ca			 
a7ca			.mul_done: 
a7ca					NEXTW 
a7ca c3 de 97			jp macro_next 
a7cd				endm 
# End of macro NEXTW
a7cd			 
a7cd			 
a7cd			 
a7cd			 
a7cd			.MIN: 
a7cd				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
a7cd 49				db WORD_SYS_CORE+53             
a7ce 16 a8			dw .MAX            
a7d0 04				db 3 + 1 
a7d1 .. 00			db "MIN",0              
a7d5				endm 
# End of macro CWHEAD
a7d5			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
a7d5					if DEBUG_FORTH_WORDS_KEY 
a7d5						DMARK "MIN" 
a7d5 f5				push af  
a7d6 3a ea a7			ld a, (.dmark)  
a7d9 32 7a ee			ld (debug_mark),a  
a7dc 3a eb a7			ld a, (.dmark+1)  
a7df 32 7b ee			ld (debug_mark+1),a  
a7e2 3a ec a7			ld a, (.dmark+2)  
a7e5 32 7c ee			ld (debug_mark+2),a  
a7e8 18 03			jr .pastdmark  
a7ea ..			.dmark: db "MIN"  
a7ed f1			.pastdmark: pop af  
a7ee			endm  
# End of macro DMARK
a7ee						CALLMONITOR 
a7ee cd 7f 90			call break_point_state  
a7f1				endm  
# End of macro CALLMONITOR
a7f1					endif 
a7f1					; get u2 
a7f1			 
a7f1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a7f1 cd a4 96			call macro_dsp_valuehl 
a7f4				endm 
# End of macro FORTH_DSP_VALUEHL
a7f4			 
a7f4 e5					push hl   ; u2 
a7f5			 
a7f5					; destroy value TOS 
a7f5			 
a7f5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a7f5 cd 24 97			call macro_forth_dsp_pop 
a7f8				endm 
# End of macro FORTH_DSP_POP
a7f8			 
a7f8					; get u1 
a7f8			 
a7f8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a7f8 cd a4 96			call macro_dsp_valuehl 
a7fb				endm 
# End of macro FORTH_DSP_VALUEHL
a7fb			 
a7fb e5					push hl  ; u1 
a7fc			 
a7fc					; destroy value TOS 
a7fc			 
a7fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a7fc cd 24 97			call macro_forth_dsp_pop 
a7ff				endm 
# End of macro FORTH_DSP_POP
a7ff			 
a7ff b7			 or a      ;clear carry flag 
a800 e1			  pop hl    ; u1 
a801 d1			  pop de    ; u2 
a802 e5				push hl   ; saved in case hl is lowest 
a803 ed 52		  sbc hl,de 
a805 30 07		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
a807			 
a807 e1				pop hl 
a808					if DEBUG_FORTH_WORDS 
a808						DMARK "MIN" 
a808						CALLMONITOR 
a808					endif 
a808 cd 09 96				call forth_push_numhl 
a80b			 
a80b				       NEXTW 
a80b c3 de 97			jp macro_next 
a80e				endm 
# End of macro NEXTW
a80e			 
a80e			.mincont:  
a80e c1				pop bc   ; tidy up 
a80f eb				ex de , hl  
a810					if DEBUG_FORTH_WORDS 
a810						DMARK "MI1" 
a810						CALLMONITOR 
a810					endif 
a810 cd 09 96				call forth_push_numhl 
a813			 
a813				       NEXTW 
a813 c3 de 97			jp macro_next 
a816				endm 
# End of macro NEXTW
a816			.MAX: 
a816				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
a816 4a				db WORD_SYS_CORE+54             
a817 5f a8			dw .RND16            
a819 04				db 3 + 1 
a81a .. 00			db "MAX",0              
a81e				endm 
# End of macro CWHEAD
a81e			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
a81e					if DEBUG_FORTH_WORDS_KEY 
a81e						DMARK "MAX" 
a81e f5				push af  
a81f 3a 33 a8			ld a, (.dmark)  
a822 32 7a ee			ld (debug_mark),a  
a825 3a 34 a8			ld a, (.dmark+1)  
a828 32 7b ee			ld (debug_mark+1),a  
a82b 3a 35 a8			ld a, (.dmark+2)  
a82e 32 7c ee			ld (debug_mark+2),a  
a831 18 03			jr .pastdmark  
a833 ..			.dmark: db "MAX"  
a836 f1			.pastdmark: pop af  
a837			endm  
# End of macro DMARK
a837						CALLMONITOR 
a837 cd 7f 90			call break_point_state  
a83a				endm  
# End of macro CALLMONITOR
a83a					endif 
a83a					; get u2 
a83a			 
a83a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a83a cd a4 96			call macro_dsp_valuehl 
a83d				endm 
# End of macro FORTH_DSP_VALUEHL
a83d			 
a83d e5					push hl   ; u2 
a83e			 
a83e					; destroy value TOS 
a83e			 
a83e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a83e cd 24 97			call macro_forth_dsp_pop 
a841				endm 
# End of macro FORTH_DSP_POP
a841			 
a841					; get u1 
a841			 
a841					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a841 cd a4 96			call macro_dsp_valuehl 
a844				endm 
# End of macro FORTH_DSP_VALUEHL
a844			 
a844 e5					push hl  ; u1 
a845			 
a845					; destroy value TOS 
a845			 
a845					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a845 cd 24 97			call macro_forth_dsp_pop 
a848				endm 
# End of macro FORTH_DSP_POP
a848			 
a848 b7			 or a      ;clear carry flag 
a849 e1			  pop hl    ; u1 
a84a d1			  pop de    ; u2 
a84b e5				push hl   ; saved in case hl is lowest 
a84c ed 52		  sbc hl,de 
a84e 38 07		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
a850			 
a850 e1				pop hl 
a851					if DEBUG_FORTH_WORDS 
a851						DMARK "MAX" 
a851						CALLMONITOR 
a851					endif 
a851 cd 09 96				call forth_push_numhl 
a854			 
a854				       NEXTW 
a854 c3 de 97			jp macro_next 
a857				endm 
# End of macro NEXTW
a857			 
a857			.maxcont:  
a857 c1				pop bc   ; tidy up 
a858 eb				ex de , hl  
a859					if DEBUG_FORTH_WORDS 
a859						DMARK "MA1" 
a859						CALLMONITOR 
a859					endif 
a859 cd 09 96				call forth_push_numhl 
a85c				       NEXTW 
a85c c3 de 97			jp macro_next 
a85f				endm 
# End of macro NEXTW
a85f			 
a85f			.RND16: 
a85f				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
a85f 4e				db WORD_SYS_CORE+58             
a860 8e a8			dw .RND8            
a862 06				db 5 + 1 
a863 .. 00			db "RND16",0              
a869				endm 
# End of macro CWHEAD
a869			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
a869					if DEBUG_FORTH_WORDS_KEY 
a869						DMARK "R16" 
a869 f5				push af  
a86a 3a 7e a8			ld a, (.dmark)  
a86d 32 7a ee			ld (debug_mark),a  
a870 3a 7f a8			ld a, (.dmark+1)  
a873 32 7b ee			ld (debug_mark+1),a  
a876 3a 80 a8			ld a, (.dmark+2)  
a879 32 7c ee			ld (debug_mark+2),a  
a87c 18 03			jr .pastdmark  
a87e ..			.dmark: db "R16"  
a881 f1			.pastdmark: pop af  
a882			endm  
# End of macro DMARK
a882						CALLMONITOR 
a882 cd 7f 90			call break_point_state  
a885				endm  
# End of macro CALLMONITOR
a885					endif 
a885 cd e2 87				call prng16  
a888 cd 09 96				call forth_push_numhl 
a88b				       NEXTW 
a88b c3 de 97			jp macro_next 
a88e				endm 
# End of macro NEXTW
a88e			.RND8: 
a88e				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
a88e 60				db WORD_SYS_CORE+76             
a88f c3 a8			dw .RND            
a891 05				db 4 + 1 
a892 .. 00			db "RND8",0              
a897				endm 
# End of macro CWHEAD
a897			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
a897					if DEBUG_FORTH_WORDS_KEY 
a897						DMARK "RN8" 
a897 f5				push af  
a898 3a ac a8			ld a, (.dmark)  
a89b 32 7a ee			ld (debug_mark),a  
a89e 3a ad a8			ld a, (.dmark+1)  
a8a1 32 7b ee			ld (debug_mark+1),a  
a8a4 3a ae a8			ld a, (.dmark+2)  
a8a7 32 7c ee			ld (debug_mark+2),a  
a8aa 18 03			jr .pastdmark  
a8ac ..			.dmark: db "RN8"  
a8af f1			.pastdmark: pop af  
a8b0			endm  
# End of macro DMARK
a8b0						CALLMONITOR 
a8b0 cd 7f 90			call break_point_state  
a8b3				endm  
# End of macro CALLMONITOR
a8b3					endif 
a8b3 2a bb eb				ld hl,(xrandc) 
a8b6 23					inc hl 
a8b7 cd fc 87				call xrnd 
a8ba 6f					ld l,a	 
a8bb 26 00				ld h,0 
a8bd cd 09 96				call forth_push_numhl 
a8c0				       NEXTW 
a8c0 c3 de 97			jp macro_next 
a8c3				endm 
# End of macro NEXTW
a8c3			.RND: 
a8c3				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
a8c3 60				db WORD_SYS_CORE+76             
a8c4 21 a9			dw .ENDMATHS            
a8c6 04				db 3 + 1 
a8c7 .. 00			db "RND",0              
a8cb				endm 
# End of macro CWHEAD
a8cb			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
a8cb			 
a8cb					if DEBUG_FORTH_WORDS_KEY 
a8cb						DMARK "RND" 
a8cb f5				push af  
a8cc 3a e0 a8			ld a, (.dmark)  
a8cf 32 7a ee			ld (debug_mark),a  
a8d2 3a e1 a8			ld a, (.dmark+1)  
a8d5 32 7b ee			ld (debug_mark+1),a  
a8d8 3a e2 a8			ld a, (.dmark+2)  
a8db 32 7c ee			ld (debug_mark+2),a  
a8de 18 03			jr .pastdmark  
a8e0 ..			.dmark: db "RND"  
a8e3 f1			.pastdmark: pop af  
a8e4			endm  
# End of macro DMARK
a8e4						CALLMONITOR 
a8e4 cd 7f 90			call break_point_state  
a8e7				endm  
# End of macro CALLMONITOR
a8e7					endif 
a8e7					 
a8e7					FORTH_DSP_VALUEHL    ; upper range 
a8e7 cd a4 96			call macro_dsp_valuehl 
a8ea				endm 
# End of macro FORTH_DSP_VALUEHL
a8ea			 
a8ea 22 bf eb				ld (LFSRSeed), hl	 
a8ed			 
a8ed					if DEBUG_FORTH_WORDS 
a8ed						DMARK "RN1" 
a8ed						CALLMONITOR 
a8ed					endif 
a8ed					FORTH_DSP_POP 
a8ed cd 24 97			call macro_forth_dsp_pop 
a8f0				endm 
# End of macro FORTH_DSP_POP
a8f0			 
a8f0					FORTH_DSP_VALUEHL    ; low range 
a8f0 cd a4 96			call macro_dsp_valuehl 
a8f3				endm 
# End of macro FORTH_DSP_VALUEHL
a8f3			 
a8f3					if DEBUG_FORTH_WORDS 
a8f3						DMARK "RN2" 
a8f3						CALLMONITOR 
a8f3					endif 
a8f3 22 c1 eb				ld (LFSRSeed+2), hl 
a8f6			 
a8f6					FORTH_DSP_POP 
a8f6 cd 24 97			call macro_forth_dsp_pop 
a8f9				endm 
# End of macro FORTH_DSP_POP
a8f9			 
a8f9 e5					push hl 
a8fa			 
a8fa e1			.inrange:	pop hl 
a8fb cd e2 87				call prng16  
a8fe					if DEBUG_FORTH_WORDS 
a8fe						DMARK "RN3" 
a8fe						CALLMONITOR 
a8fe					endif 
a8fe					 
a8fe					; if the range is 8bit knock out the high byte 
a8fe			 
a8fe ed 5b bf eb			ld de, (LFSRSeed)     ; check high level 
a902			 
a902 3e 00				ld a, 0 
a904 ba					cp d  
a905 20 02				jr nz, .hirange 
a907 26 00				ld h, 0   ; knock it down to 8bit 
a909			 
a909					if DEBUG_FORTH_WORDS 
a909						DMARK "RNk" 
a909						CALLMONITOR 
a909					endif 
a909			.hirange:   
a909 e5					push hl  
a90a b7					or a  
a90b ed 52		                sbc hl, de 
a90d			 
a90d					;call cmp16 
a90d			 
a90d 30 eb				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
a90f e1					pop hl 
a910 e5					push hl 
a911			 
a911					if DEBUG_FORTH_WORDS 
a911						DMARK "RN4" 
a911						CALLMONITOR 
a911					endif 
a911 ed 5b c1 eb			ld de, (LFSRSeed+2)   ; check low range 
a915					;call cmp16 
a915				 
a915 b7					or a  
a916 ed 52		                sbc hl, de 
a918 38 e0				jr c, .inrange 
a91a			 
a91a e1					pop hl 
a91b					 
a91b					if DEBUG_FORTH_WORDS 
a91b						DMARK "RNd" 
a91b						CALLMONITOR 
a91b					endif 
a91b			 
a91b			 
a91b cd 09 96				call forth_push_numhl 
a91e				       NEXTW 
a91e c3 de 97			jp macro_next 
a921				endm 
# End of macro NEXTW
a921			 
a921			.ENDMATHS: 
a921			 
a921			; eof 
a921			 
# End of file forth_words_maths.asm
a921			include "forth_words_display.asm" 
a921			 
a921			; | ## Display Words 
a921			 
a921			.ATP: 
a921				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
a921 62				db WORD_SYS_CORE+78             
a922 60 a9			dw .FB            
a924 04				db 3 + 1 
a925 .. 00			db "AT?",0              
a929				endm 
# End of macro CWHEAD
a929			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
a929					if DEBUG_FORTH_WORDS_KEY 
a929						DMARK "AT?" 
a929 f5				push af  
a92a 3a 3e a9			ld a, (.dmark)  
a92d 32 7a ee			ld (debug_mark),a  
a930 3a 3f a9			ld a, (.dmark+1)  
a933 32 7b ee			ld (debug_mark+1),a  
a936 3a 40 a9			ld a, (.dmark+2)  
a939 32 7c ee			ld (debug_mark+2),a  
a93c 18 03			jr .pastdmark  
a93e ..			.dmark: db "AT?"  
a941 f1			.pastdmark: pop af  
a942			endm  
# End of macro DMARK
a942						CALLMONITOR 
a942 cd 7f 90			call break_point_state  
a945				endm  
# End of macro CALLMONITOR
a945					endif 
a945 3a 5e eb				ld a, (f_cursor_ptr) 
a948			 
a948			if DEBUG_FORTH_WORDS 
a948				DMARK "AT?" 
a948				CALLMONITOR 
a948			endif	 
a948					; count the number of rows 
a948			 
a948 06 00				ld b, 0 
a94a 4f			.atpr:		ld c, a    ; save in case we go below zero 
a94b d6 28				sub display_cols 
a94d f2 53 a9				jp p, .atprunder 
a950 04					inc b 
a951 18 f7				jr .atpr 
a953			.atprunder:	 
a953			if DEBUG_FORTH_WORDS 
a953				DMARK "A?2" 
a953				CALLMONITOR 
a953			endif	 
a953 26 00				ld h, 0 
a955 69					ld l, c 
a956 cd 09 96				call forth_push_numhl 
a959 68					ld l, b  
a95a cd 09 96				call forth_push_numhl 
a95d			 
a95d			 
a95d				NEXTW 
a95d c3 de 97			jp macro_next 
a960				endm 
# End of macro NEXTW
a960			 
a960			.FB: 
a960				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
a960 1b				db WORD_SYS_CORE+7             
a961 ae a9			dw .EMIT            
a963 03				db 2 + 1 
a964 .. 00			db "FB",0              
a967				endm 
# End of macro CWHEAD
a967			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
a967			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
a967			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
a967			; | | If automatic display is off then updates will not be shown until DRAW is used. 
a967					if DEBUG_FORTH_WORDS_KEY 
a967						DMARK "FB." 
a967 f5				push af  
a968 3a 7c a9			ld a, (.dmark)  
a96b 32 7a ee			ld (debug_mark),a  
a96e 3a 7d a9			ld a, (.dmark+1)  
a971 32 7b ee			ld (debug_mark+1),a  
a974 3a 7e a9			ld a, (.dmark+2)  
a977 32 7c ee			ld (debug_mark+2),a  
a97a 18 03			jr .pastdmark  
a97c ..			.dmark: db "FB."  
a97f f1			.pastdmark: pop af  
a980			endm  
# End of macro DMARK
a980						CALLMONITOR 
a980 cd 7f 90			call break_point_state  
a983				endm  
# End of macro CALLMONITOR
a983					endif 
a983			 
a983					FORTH_DSP_VALUEHL 
a983 cd a4 96			call macro_dsp_valuehl 
a986				endm 
# End of macro FORTH_DSP_VALUEHL
a986			 
a986 7d					ld a, l 
a987 fe 01				cp 1 
a989 20 05				jr nz, .fbn1 
a98b 21 1f ed				ld hl, display_fb1 
a98e 18 15				jr .fbset 
a990 fe 02		.fbn1:		cp 2 
a992 20 05				jr nz, .fbn2 
a994 21 dd eb				ld hl, display_fb2 
a997 18 0c				jr .fbset 
a999 fe 03		.fbn2:		cp 3 
a99b 20 05				jr nz, .fbn3 
a99d 21 7e ec				ld hl, display_fb3 
a9a0 18 03				jr .fbset 
a9a2			.fbn3:		 ; if invalid number select first 
a9a2 21 1f ed				ld hl, display_fb1 
a9a5 22 db eb		.fbset:		ld (display_fb_active), hl 
a9a8			 
a9a8					FORTH_DSP_POP 
a9a8 cd 24 97			call macro_forth_dsp_pop 
a9ab				endm 
# End of macro FORTH_DSP_POP
a9ab			 
a9ab					NEXTW 
a9ab c3 de 97			jp macro_next 
a9ae				endm 
# End of macro NEXTW
a9ae			 
a9ae			 
a9ae			.EMIT: 
a9ae				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
a9ae 1b				db WORD_SYS_CORE+7             
a9af ff a9			dw .DOTH            
a9b1 05				db 4 + 1 
a9b2 .. 00			db "EMIT",0              
a9b7				endm 
# End of macro CWHEAD
a9b7			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
a9b7					; get value off TOS and display it 
a9b7			 
a9b7					if DEBUG_FORTH_WORDS_KEY 
a9b7						DMARK "EMT" 
a9b7 f5				push af  
a9b8 3a cc a9			ld a, (.dmark)  
a9bb 32 7a ee			ld (debug_mark),a  
a9be 3a cd a9			ld a, (.dmark+1)  
a9c1 32 7b ee			ld (debug_mark+1),a  
a9c4 3a ce a9			ld a, (.dmark+2)  
a9c7 32 7c ee			ld (debug_mark+2),a  
a9ca 18 03			jr .pastdmark  
a9cc ..			.dmark: db "EMT"  
a9cf f1			.pastdmark: pop af  
a9d0			endm  
# End of macro DMARK
a9d0						CALLMONITOR 
a9d0 cd 7f 90			call break_point_state  
a9d3				endm  
# End of macro CALLMONITOR
a9d3					endif 
a9d3			 
a9d3					FORTH_DSP_VALUEHL 
a9d3 cd a4 96			call macro_dsp_valuehl 
a9d6				endm 
# End of macro FORTH_DSP_VALUEHL
a9d6			 
a9d6 7d					ld a,l 
a9d7			 
a9d7					; TODO write to display 
a9d7			 
a9d7 32 73 e5				ld (os_input), a 
a9da 3e 00				ld a, 0 
a9dc 32 74 e5				ld (os_input+1), a 
a9df					 
a9df 3a 5e eb				ld a, (f_cursor_ptr) 
a9e2 11 73 e5				ld de, os_input 
a9e5 cd 75 87				call str_at_display 
a9e8			 
a9e8			 
a9e8 3a 3c eb				ld a,(cli_autodisplay) 
a9eb fe 00				cp 0 
a9ed 28 03				jr z, .enoupdate 
a9ef cd 85 87						call update_display 
a9f2					.enoupdate: 
a9f2			 
a9f2 3a 5e eb				ld a, (f_cursor_ptr) 
a9f5 3c					inc a 
a9f6 32 5e eb				ld (f_cursor_ptr), a   ; save new pos 
a9f9			 
a9f9			 
a9f9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a9f9 cd 24 97			call macro_forth_dsp_pop 
a9fc				endm 
# End of macro FORTH_DSP_POP
a9fc			  
a9fc			 
a9fc					NEXTW 
a9fc c3 de 97			jp macro_next 
a9ff				endm 
# End of macro NEXTW
a9ff			.DOTH: 
a9ff				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
a9ff 1c				db WORD_SYS_CORE+8             
aa00 2f aa			dw .DOTF            
aa02 03				db 2 + 1 
aa03 .. 00			db ".-",0              
aa06				endm 
# End of macro CWHEAD
aa06			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
aa06					; get value off TOS and display it 
aa06					if DEBUG_FORTH_WORDS_KEY 
aa06						DMARK "DTD" 
aa06 f5				push af  
aa07 3a 1b aa			ld a, (.dmark)  
aa0a 32 7a ee			ld (debug_mark),a  
aa0d 3a 1c aa			ld a, (.dmark+1)  
aa10 32 7b ee			ld (debug_mark+1),a  
aa13 3a 1d aa			ld a, (.dmark+2)  
aa16 32 7c ee			ld (debug_mark+2),a  
aa19 18 03			jr .pastdmark  
aa1b ..			.dmark: db "DTD"  
aa1e f1			.pastdmark: pop af  
aa1f			endm  
# End of macro DMARK
aa1f						CALLMONITOR 
aa1f cd 7f 90			call break_point_state  
aa22				endm  
# End of macro CALLMONITOR
aa22					endif 
aa22 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
aa24 3e 00			ld a, 0 
aa26 32 3d eb			ld (cli_mvdot), a 
aa29 c3 86 aa			jp .dotgo 
aa2c				NEXTW 
aa2c c3 de 97			jp macro_next 
aa2f				endm 
# End of macro NEXTW
aa2f			.DOTF: 
aa2f				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
aa2f 1c				db WORD_SYS_CORE+8             
aa30 5d aa			dw .DOT            
aa32 03				db 2 + 1 
aa33 .. 00			db ".>",0              
aa36				endm 
# End of macro CWHEAD
aa36			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
aa36					; get value off TOS and display it 
aa36			        ; TODO BUG adds extra spaces 
aa36			        ; TODO BUG handle numerics? 
aa36					if DEBUG_FORTH_WORDS_KEY 
aa36						DMARK "DTC" 
aa36 f5				push af  
aa37 3a 4b aa			ld a, (.dmark)  
aa3a 32 7a ee			ld (debug_mark),a  
aa3d 3a 4c aa			ld a, (.dmark+1)  
aa40 32 7b ee			ld (debug_mark+1),a  
aa43 3a 4d aa			ld a, (.dmark+2)  
aa46 32 7c ee			ld (debug_mark+2),a  
aa49 18 03			jr .pastdmark  
aa4b ..			.dmark: db "DTC"  
aa4e f1			.pastdmark: pop af  
aa4f			endm  
# End of macro DMARK
aa4f						CALLMONITOR 
aa4f cd 7f 90			call break_point_state  
aa52				endm  
# End of macro CALLMONITOR
aa52					endif 
aa52 3e 01			ld a, 1 
aa54 32 3d eb			ld (cli_mvdot), a 
aa57 c3 86 aa			jp .dotgo 
aa5a				NEXTW 
aa5a c3 de 97			jp macro_next 
aa5d				endm 
# End of macro NEXTW
aa5d			 
aa5d			.DOT: 
aa5d				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
aa5d 1c				db WORD_SYS_CORE+8             
aa5e e9 aa			dw .CLS            
aa60 02				db 1 + 1 
aa61 .. 00			db ".",0              
aa63				endm 
# End of macro CWHEAD
aa63			        ; | . ( u -- ) Display TOS | DONE 
aa63					; get value off TOS and display it 
aa63			 
aa63					if DEBUG_FORTH_WORDS_KEY 
aa63						DMARK "DOT" 
aa63 f5				push af  
aa64 3a 78 aa			ld a, (.dmark)  
aa67 32 7a ee			ld (debug_mark),a  
aa6a 3a 79 aa			ld a, (.dmark+1)  
aa6d 32 7b ee			ld (debug_mark+1),a  
aa70 3a 7a aa			ld a, (.dmark+2)  
aa73 32 7c ee			ld (debug_mark+2),a  
aa76 18 03			jr .pastdmark  
aa78 ..			.dmark: db "DOT"  
aa7b f1			.pastdmark: pop af  
aa7c			endm  
# End of macro DMARK
aa7c						CALLMONITOR 
aa7c cd 7f 90			call break_point_state  
aa7f				endm  
# End of macro CALLMONITOR
aa7f					endif 
aa7f 3e 00			ld a, 0 
aa81 32 3d eb			ld (cli_mvdot), a 
aa84 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
aa86				 
aa86			 
aa86			.dotgo: 
aa86			 
aa86			; move up type to on stack for parserv5 
aa86					FORTH_DSP 
aa86 cd 89 96			call macro_forth_dsp 
aa89				endm 
# End of macro FORTH_DSP
aa89				;FORTH_DSP_VALUE  
aa89			 
aa89			if DEBUG_FORTH_DOT 
aa89				DMARK "DOT" 
aa89				CALLMONITOR 
aa89			endif	 
aa89			;		.print: 
aa89			 
aa89 7e				ld a,(hl)  ; work out what type of value is on the TOS 
aa8a 23				inc hl   ; position to the actual value 
aa8b fe 01			cp DS_TYPE_STR 
aa8d 20 06			jr nz, .dotnum1  
aa8f			 
aa8f			; display string 
aa8f				FORTH_DSP_VALUE  
aa8f cd 8d 96			call macro_forth_dsp_value 
aa92				endm 
# End of macro FORTH_DSP_VALUE
aa92 eb				ex de,hl 
aa93 18 11			jr .dotwrite 
aa95			 
aa95			.dotnum1: 
aa95 fe 02			cp DS_TYPE_INUM 
aa97 20 0c			jr nz, .dotflot 
aa99			 
aa99			 
aa99			; display number 
aa99			 
aa99			;	push hl 
aa99			;	call clear_display 
aa99			;	pop hl 
aa99			 
aa99 5e				ld e, (hl) 
aa9a 23				inc hl 
aa9b 56				ld d, (hl) 
aa9c 21 75 e3			ld hl, scratch 
aa9f			if DEBUG_FORTH_DOT 
aa9f				DMARK "DT1" 
aa9f				CALLMONITOR 
aa9f			endif	 
aa9f			 
aa9f cd c8 8c			call uitoa_16 
aaa2 eb				ex de,hl 
aaa3			 
aaa3			if DEBUG_FORTH_DOT 
aaa3				DMARK "DT2" 
aaa3				CALLMONITOR 
aaa3			endif	 
aaa3			 
aaa3			;	ld de, os_word_scratch 
aaa3 18 01			jr .dotwrite 
aaa5			 
aaa5 00			.dotflot:   nop 
aaa6			; TODO print floating point number 
aaa6			 
aaa6			.dotwrite:		 
aaa6			 
aaa6					; if c is set then set all '-' to spaces 
aaa6					; need to also take into account .>  
aaa6			 
aaa6 3e 01				ld a, 1 
aaa8 b9					cp c 
aaa9 20 13				jr nz, .nodashswap 
aaab			 
aaab					; DE has the string to write, working with HL 
aaab			 
aaab 06 ff				ld b, 255 
aaad d5					push de 
aaae e1					pop hl 
aaaf			 
aaaf			if DEBUG_FORTH_DOT 
aaaf				DMARK "DT-" 
aaaf				CALLMONITOR 
aaaf			endif	 
aaaf 7e			.dashscan:	ld a, (hl) 
aab0 fe 00				cp 0 
aab2 28 0a				jr z, .nodashswap 
aab4 fe 2d				cp '-' 
aab6 20 03				jr nz, .dashskip 
aab8 3e 20				ld a, ' ' 
aaba 77					ld (hl), a 
aabb 23			.dashskip:	inc hl 
aabc			if DEBUG_FORTH_DOT 
aabc				DMARK "D-2" 
aabc				CALLMONITOR 
aabc			endif	 
aabc 10 f1				djnz .dashscan 
aabe			 
aabe			if DEBUG_FORTH_DOT 
aabe				DMARK "D-1" 
aabe				CALLMONITOR 
aabe			endif	 
aabe			 
aabe			.nodashswap: 
aabe			 
aabe e5					push hl   ; save string start in case we need to advance print 
aabf			 
aabf 3a 5e eb				ld a, (f_cursor_ptr) 
aac2 cd 75 87				call str_at_display 
aac5 3a 3c eb				ld a,(cli_autodisplay) 
aac8 fe 00				cp 0 
aaca 28 03				jr z, .noupdate 
aacc cd 85 87						call update_display 
aacf					.noupdate: 
aacf			 
aacf			 
aacf					; see if we need to advance the print position 
aacf			 
aacf e1					pop hl   ; get back string 
aad0			 
aad0 3a 3d eb				ld a, (cli_mvdot) 
aad3			if DEBUG_FORTH_DOT 
aad3					ld e,a 
aad3				DMARK "D>1" 
aad3				CALLMONITOR 
aad3			endif	 
aad3 fe 00				cp 0 
aad5 28 0c				jr z, .noadv 
aad7					; yes, lets advance the print position 
aad7 3e 00				ld a, 0 
aad9 cd 24 8d				call strlent 
aadc 3a 5e eb				ld a, (f_cursor_ptr) 
aadf 85					add a,l 
aae0					;call addatohl 
aae0					;ld a, l 
aae0 32 5e eb				ld (f_cursor_ptr), a   ; save new pos 
aae3			 
aae3			if DEBUG_FORTH_DOT 
aae3				DMARK "D->" 
aae3				CALLMONITOR 
aae3			endif	 
aae3			 
aae3			.noadv:	 
aae3			 
aae3					if DEBUG_FORTH_DOT_WAIT 
aae3							call next_page_prompt 
aae3					endif	 
aae3			; TODO this pop off the stack causes a crash. i dont know why 
aae3			 
aae3			 
aae3			if DEBUG_FORTH_DOT 
aae3				DMARK "DTh" 
aae3				CALLMONITOR 
aae3			endif	 
aae3			 
aae3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
aae3 cd 24 97			call macro_forth_dsp_pop 
aae6				endm 
# End of macro FORTH_DSP_POP
aae6			 
aae6			if DEBUG_FORTH_DOT 
aae6				DMARK "DTi" 
aae6				CALLMONITOR 
aae6			endif	 
aae6			 
aae6			 
aae6					NEXTW 
aae6 c3 de 97			jp macro_next 
aae9				endm 
# End of macro NEXTW
aae9			 
aae9			.CLS: 
aae9				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
aae9 35				db WORD_SYS_CORE+33             
aaea 16 ab			dw .DRAW            
aaec 04				db 3 + 1 
aaed .. 00			db "CLS",0              
aaf1				endm 
# End of macro CWHEAD
aaf1			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
aaf1					if DEBUG_FORTH_WORDS_KEY 
aaf1						DMARK "CLS" 
aaf1 f5				push af  
aaf2 3a 06 ab			ld a, (.dmark)  
aaf5 32 7a ee			ld (debug_mark),a  
aaf8 3a 07 ab			ld a, (.dmark+1)  
aafb 32 7b ee			ld (debug_mark+1),a  
aafe 3a 08 ab			ld a, (.dmark+2)  
ab01 32 7c ee			ld (debug_mark+2),a  
ab04 18 03			jr .pastdmark  
ab06 ..			.dmark: db "CLS"  
ab09 f1			.pastdmark: pop af  
ab0a			endm  
# End of macro DMARK
ab0a						CALLMONITOR 
ab0a cd 7f 90			call break_point_state  
ab0d				endm  
# End of macro CALLMONITOR
ab0d					endif 
ab0d cd 62 87				call clear_display 
ab10 c3 24 ac				jp .home		; and home cursor 
ab13					NEXTW 
ab13 c3 de 97			jp macro_next 
ab16				endm 
# End of macro NEXTW
ab16			 
ab16			.DRAW: 
ab16				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
ab16 36				db WORD_SYS_CORE+34             
ab17 41 ab			dw .DUMP            
ab19 05				db 4 + 1 
ab1a .. 00			db "DRAW",0              
ab1f				endm 
# End of macro CWHEAD
ab1f			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
ab1f					if DEBUG_FORTH_WORDS_KEY 
ab1f						DMARK "DRW" 
ab1f f5				push af  
ab20 3a 34 ab			ld a, (.dmark)  
ab23 32 7a ee			ld (debug_mark),a  
ab26 3a 35 ab			ld a, (.dmark+1)  
ab29 32 7b ee			ld (debug_mark+1),a  
ab2c 3a 36 ab			ld a, (.dmark+2)  
ab2f 32 7c ee			ld (debug_mark+2),a  
ab32 18 03			jr .pastdmark  
ab34 ..			.dmark: db "DRW"  
ab37 f1			.pastdmark: pop af  
ab38			endm  
# End of macro DMARK
ab38						CALLMONITOR 
ab38 cd 7f 90			call break_point_state  
ab3b				endm  
# End of macro CALLMONITOR
ab3b					endif 
ab3b cd 85 87				call update_display 
ab3e					NEXTW 
ab3e c3 de 97			jp macro_next 
ab41				endm 
# End of macro NEXTW
ab41			 
ab41			.DUMP: 
ab41				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
ab41 37				db WORD_SYS_CORE+35             
ab42 79 ab			dw .CDUMP            
ab44 05				db 4 + 1 
ab45 .. 00			db "DUMP",0              
ab4a				endm 
# End of macro CWHEAD
ab4a			; | DUMP ( x -- ) With address x display dump   | DONE 
ab4a			; TODO pop address to use off of the stack 
ab4a					if DEBUG_FORTH_WORDS_KEY 
ab4a						DMARK "DUM" 
ab4a f5				push af  
ab4b 3a 5f ab			ld a, (.dmark)  
ab4e 32 7a ee			ld (debug_mark),a  
ab51 3a 60 ab			ld a, (.dmark+1)  
ab54 32 7b ee			ld (debug_mark+1),a  
ab57 3a 61 ab			ld a, (.dmark+2)  
ab5a 32 7c ee			ld (debug_mark+2),a  
ab5d 18 03			jr .pastdmark  
ab5f ..			.dmark: db "DUM"  
ab62 f1			.pastdmark: pop af  
ab63			endm  
# End of macro DMARK
ab63						CALLMONITOR 
ab63 cd 7f 90			call break_point_state  
ab66				endm  
# End of macro CALLMONITOR
ab66					endif 
ab66 cd 62 87				call clear_display 
ab69			 
ab69					; get address 
ab69			 
ab69					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ab69 cd a4 96			call macro_dsp_valuehl 
ab6c				endm 
# End of macro FORTH_DSP_VALUEHL
ab6c				 
ab6c					; save it for cdump 
ab6c			 
ab6c 22 98 e6				ld (os_cur_ptr),hl 
ab6f			 
ab6f					; destroy value TOS 
ab6f			 
ab6f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ab6f cd 24 97			call macro_forth_dsp_pop 
ab72				endm 
# End of macro FORTH_DSP_POP
ab72			 
ab72 cd 8c 94				call dumpcont	; skip old style of param parsing	 
ab75 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
ab76					NEXTW 
ab76 c3 de 97			jp macro_next 
ab79				endm 
# End of macro NEXTW
ab79			.CDUMP: 
ab79				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
ab79 38				db WORD_SYS_CORE+36             
ab7a a9 ab			dw .DAT            
ab7c 06				db 5 + 1 
ab7d .. 00			db "CDUMP",0              
ab83				endm 
# End of macro CWHEAD
ab83			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
ab83					if DEBUG_FORTH_WORDS_KEY 
ab83						DMARK "CDP" 
ab83 f5				push af  
ab84 3a 98 ab			ld a, (.dmark)  
ab87 32 7a ee			ld (debug_mark),a  
ab8a 3a 99 ab			ld a, (.dmark+1)  
ab8d 32 7b ee			ld (debug_mark+1),a  
ab90 3a 9a ab			ld a, (.dmark+2)  
ab93 32 7c ee			ld (debug_mark+2),a  
ab96 18 03			jr .pastdmark  
ab98 ..			.dmark: db "CDP"  
ab9b f1			.pastdmark: pop af  
ab9c			endm  
# End of macro DMARK
ab9c						CALLMONITOR 
ab9c cd 7f 90			call break_point_state  
ab9f				endm  
# End of macro CALLMONITOR
ab9f					endif 
ab9f cd 62 87				call clear_display 
aba2 cd 8c 94				call dumpcont	 
aba5 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
aba6					NEXTW 
aba6 c3 de 97			jp macro_next 
aba9				endm 
# End of macro NEXTW
aba9			 
aba9			 
aba9			 
aba9			 
aba9			.DAT: 
aba9				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
aba9 3d				db WORD_SYS_CORE+41             
abaa ff ab			dw .HOME            
abac 03				db 2 + 1 
abad .. 00			db "AT",0              
abb0				endm 
# End of macro CWHEAD
abb0			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
abb0					if DEBUG_FORTH_WORDS_KEY 
abb0						DMARK "AT." 
abb0 f5				push af  
abb1 3a c5 ab			ld a, (.dmark)  
abb4 32 7a ee			ld (debug_mark),a  
abb7 3a c6 ab			ld a, (.dmark+1)  
abba 32 7b ee			ld (debug_mark+1),a  
abbd 3a c7 ab			ld a, (.dmark+2)  
abc0 32 7c ee			ld (debug_mark+2),a  
abc3 18 03			jr .pastdmark  
abc5 ..			.dmark: db "AT."  
abc8 f1			.pastdmark: pop af  
abc9			endm  
# End of macro DMARK
abc9						CALLMONITOR 
abc9 cd 7f 90			call break_point_state  
abcc				endm  
# End of macro CALLMONITOR
abcc					endif 
abcc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
abcc cd a4 96			call macro_dsp_valuehl 
abcf				endm 
# End of macro FORTH_DSP_VALUEHL
abcf			 
abcf			 
abcf					; TODO save cursor row 
abcf 7d					ld a,l 
abd0 fe 02				cp 2 
abd2 20 04				jr nz, .crow3 
abd4 3e 28				ld a, display_row_2 
abd6 18 12				jr .ccol1 
abd8 fe 03		.crow3:		cp 3 
abda 20 04				jr nz, .crow4 
abdc 3e 50				ld a, display_row_3 
abde 18 0a				jr .ccol1 
abe0 fe 04		.crow4:		cp 4 
abe2 20 04				jr nz, .crow1 
abe4 3e 78				ld a, display_row_4 
abe6 18 02				jr .ccol1 
abe8 3e 00		.crow1:		ld a,display_row_1 
abea f5			.ccol1:		push af			; got row offset 
abeb 6f					ld l,a 
abec 26 00				ld h,0 
abee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
abee cd 24 97			call macro_forth_dsp_pop 
abf1				endm 
# End of macro FORTH_DSP_POP
abf1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
abf1 cd a4 96			call macro_dsp_valuehl 
abf4				endm 
# End of macro FORTH_DSP_VALUEHL
abf4					; TODO save cursor col 
abf4 f1					pop af 
abf5 85					add l		; add col offset 
abf6 32 5e eb				ld (f_cursor_ptr), a 
abf9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
abf9 cd 24 97			call macro_forth_dsp_pop 
abfc				endm 
# End of macro FORTH_DSP_POP
abfc			 
abfc					; calculate  
abfc			 
abfc					NEXTW 
abfc c3 de 97			jp macro_next 
abff				endm 
# End of macro NEXTW
abff			 
abff			 
abff			.HOME: 
abff				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
abff 41				db WORD_SYS_CORE+45             
ac00 2c ac			dw .SPACE            
ac02 05				db 4 + 1 
ac03 .. 00			db "HOME",0              
ac08				endm 
# End of macro CWHEAD
ac08			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
ac08					if DEBUG_FORTH_WORDS_KEY 
ac08						DMARK "HOM" 
ac08 f5				push af  
ac09 3a 1d ac			ld a, (.dmark)  
ac0c 32 7a ee			ld (debug_mark),a  
ac0f 3a 1e ac			ld a, (.dmark+1)  
ac12 32 7b ee			ld (debug_mark+1),a  
ac15 3a 1f ac			ld a, (.dmark+2)  
ac18 32 7c ee			ld (debug_mark+2),a  
ac1b 18 03			jr .pastdmark  
ac1d ..			.dmark: db "HOM"  
ac20 f1			.pastdmark: pop af  
ac21			endm  
# End of macro DMARK
ac21						CALLMONITOR 
ac21 cd 7f 90			call break_point_state  
ac24				endm  
# End of macro CALLMONITOR
ac24					endif 
ac24 3e 00		.home:		ld a, 0		; and home cursor 
ac26 32 5e eb				ld (f_cursor_ptr), a 
ac29					NEXTW 
ac29 c3 de 97			jp macro_next 
ac2c				endm 
# End of macro NEXTW
ac2c			 
ac2c			 
ac2c			.SPACE: 
ac2c				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
ac2c 46				db WORD_SYS_CORE+50             
ac2d 5a ac			dw .SPACES            
ac2f 03				db 2 + 1 
ac30 .. 00			db "BL",0              
ac33				endm 
# End of macro CWHEAD
ac33			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
ac33					if DEBUG_FORTH_WORDS_KEY 
ac33						DMARK "BL." 
ac33 f5				push af  
ac34 3a 48 ac			ld a, (.dmark)  
ac37 32 7a ee			ld (debug_mark),a  
ac3a 3a 49 ac			ld a, (.dmark+1)  
ac3d 32 7b ee			ld (debug_mark+1),a  
ac40 3a 4a ac			ld a, (.dmark+2)  
ac43 32 7c ee			ld (debug_mark+2),a  
ac46 18 03			jr .pastdmark  
ac48 ..			.dmark: db "BL."  
ac4b f1			.pastdmark: pop af  
ac4c			endm  
# End of macro DMARK
ac4c						CALLMONITOR 
ac4c cd 7f 90			call break_point_state  
ac4f				endm  
# End of macro CALLMONITOR
ac4f					endif 
ac4f 21 58 ac				ld hl, .blstr 
ac52 cd 1b 96				call forth_push_str 
ac55					 
ac55				       NEXTW 
ac55 c3 de 97			jp macro_next 
ac58				endm 
# End of macro NEXTW
ac58			 
ac58 .. 00		.blstr: db " ", 0 
ac5a			 
ac5a			.SPACES: 
ac5a				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
ac5a 47				db WORD_SYS_CORE+51             
ac5b a1 ac			dw .SCROLL            
ac5d 07				db 6 + 1 
ac5e .. 00			db "SPACES",0              
ac65				endm 
# End of macro CWHEAD
ac65			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
ac65					if DEBUG_FORTH_WORDS_KEY 
ac65						DMARK "SPS" 
ac65 f5				push af  
ac66 3a 7a ac			ld a, (.dmark)  
ac69 32 7a ee			ld (debug_mark),a  
ac6c 3a 7b ac			ld a, (.dmark+1)  
ac6f 32 7b ee			ld (debug_mark+1),a  
ac72 3a 7c ac			ld a, (.dmark+2)  
ac75 32 7c ee			ld (debug_mark+2),a  
ac78 18 03			jr .pastdmark  
ac7a ..			.dmark: db "SPS"  
ac7d f1			.pastdmark: pop af  
ac7e			endm  
# End of macro DMARK
ac7e						CALLMONITOR 
ac7e cd 7f 90			call break_point_state  
ac81				endm  
# End of macro CALLMONITOR
ac81					endif 
ac81			 
ac81			 
ac81					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ac81 cd a4 96			call macro_dsp_valuehl 
ac84				endm 
# End of macro FORTH_DSP_VALUEHL
ac84			 
ac84			;		push hl    ; u 
ac84					if DEBUG_FORTH_WORDS 
ac84						DMARK "SPA" 
ac84						CALLMONITOR 
ac84					endif 
ac84			 
ac84					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ac84 cd 24 97			call macro_forth_dsp_pop 
ac87				endm 
# End of macro FORTH_DSP_POP
ac87			;		pop hl 
ac87 4d					ld c, l 
ac88 06 00				ld b, 0 
ac8a 21 75 e3				ld hl, scratch  
ac8d			 
ac8d					if DEBUG_FORTH_WORDS 
ac8d						DMARK "SP2" 
ac8d						CALLMONITOR 
ac8d					endif 
ac8d 3e 20				ld a, ' ' 
ac8f c5			.spaces1:	push bc 
ac90 77					ld (hl),a 
ac91 23					inc hl 
ac92 c1					pop bc 
ac93 10 fa				djnz .spaces1 
ac95 3e 00				ld a,0 
ac97 77					ld (hl),a 
ac98 21 75 e3				ld hl, scratch 
ac9b					if DEBUG_FORTH_WORDS 
ac9b						DMARK "SP3" 
ac9b						CALLMONITOR 
ac9b					endif 
ac9b cd 51 96				call forth_apush 
ac9e			 
ac9e				       NEXTW 
ac9e c3 de 97			jp macro_next 
aca1				endm 
# End of macro NEXTW
aca1			 
aca1			 
aca1			 
aca1			.SCROLL: 
aca1				CWHEAD .ATQ 63 "SCROLL" 6 WORD_FLAG_CODE 
aca1 53				db WORD_SYS_CORE+63             
aca2 ce ac			dw .ATQ            
aca4 07				db 6 + 1 
aca5 .. 00			db "SCROLL",0              
acac				endm 
# End of macro CWHEAD
acac			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
acac					if DEBUG_FORTH_WORDS_KEY 
acac						DMARK "SCR" 
acac f5				push af  
acad 3a c1 ac			ld a, (.dmark)  
acb0 32 7a ee			ld (debug_mark),a  
acb3 3a c2 ac			ld a, (.dmark+1)  
acb6 32 7b ee			ld (debug_mark+1),a  
acb9 3a c3 ac			ld a, (.dmark+2)  
acbc 32 7c ee			ld (debug_mark+2),a  
acbf 18 03			jr .pastdmark  
acc1 ..			.dmark: db "SCR"  
acc4 f1			.pastdmark: pop af  
acc5			endm  
# End of macro DMARK
acc5						CALLMONITOR 
acc5 cd 7f 90			call break_point_state  
acc8				endm  
# End of macro CALLMONITOR
acc8					endif 
acc8			 
acc8 cd fa 86			call scroll_up 
accb			;	call update_display 
accb			 
accb					NEXTW 
accb c3 de 97			jp macro_next 
acce				endm 
# End of macro NEXTW
acce			 
acce			 
acce			 
acce			;		; get dir 
acce			; 
acce			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
acce			; 
acce			;		push hl 
acce			; 
acce			;		; destroy value TOS 
acce			; 
acce			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
acce			; 
acce			;		; get count 
acce			; 
acce			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
acce			; 
acce			;		push hl 
acce			; 
acce			;		; destroy value TOS 
acce			; 
acce			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
acce			; 
acce			;		; one value on hl get other one back 
acce			; 
acce			;		pop bc    ; count 
acce			; 
acce			;		pop de   ; dir 
acce			; 
acce			; 
acce			;		ld b, c 
acce			; 
acce			;.scrolldir:     push bc 
acce			;		push de 
acce			; 
acce			;		ld a, 0 
acce			;		cp e 
acce			;		jr z, .scrollup  
acce			;		call scroll_down 
acce			;		jr .scrollnext 
acce			;.scrollup:	call scroll_up 
acce			; 
acce			;		 
acce			;.scrollnext: 
acce			;		pop de 
acce			;		pop bc 
acce			;		djnz .scrolldir 
acce			; 
acce			; 
acce			; 
acce			; 
acce			; 
acce			;		NEXTW 
acce			 
acce			 
acce			 
acce			 
acce			.ATQ: 
acce				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
acce 62				db WORD_SYS_CORE+78             
accf 2c ad			dw .AUTODSP            
acd1 04				db 3 + 1 
acd2 .. 00			db "AT@",0              
acd6				endm 
# End of macro CWHEAD
acd6			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
acd6					if DEBUG_FORTH_WORDS_KEY 
acd6						DMARK "ATA" 
acd6 f5				push af  
acd7 3a eb ac			ld a, (.dmark)  
acda 32 7a ee			ld (debug_mark),a  
acdd 3a ec ac			ld a, (.dmark+1)  
ace0 32 7b ee			ld (debug_mark+1),a  
ace3 3a ed ac			ld a, (.dmark+2)  
ace6 32 7c ee			ld (debug_mark+2),a  
ace9 18 03			jr .pastdmark  
aceb ..			.dmark: db "ATA"  
acee f1			.pastdmark: pop af  
acef			endm  
# End of macro DMARK
acef						CALLMONITOR 
acef cd 7f 90			call break_point_state  
acf2				endm  
# End of macro CALLMONITOR
acf2					endif 
acf2			 
acf2			 
acf2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
acf2 cd a4 96			call macro_dsp_valuehl 
acf5				endm 
# End of macro FORTH_DSP_VALUEHL
acf5			 
acf5					; TODO save cursor row 
acf5 7d					ld a,l 
acf6 fe 02				cp 2 
acf8 20 04				jr nz, .crow3aq 
acfa 3e 28				ld a, display_row_2 
acfc 18 12				jr .ccol1aq 
acfe fe 03		.crow3aq:		cp 3 
ad00 20 04				jr nz, .crow4aq 
ad02 3e 50				ld a, display_row_3 
ad04 18 0a				jr .ccol1aq 
ad06 fe 04		.crow4aq:		cp 4 
ad08 20 04				jr nz, .crow1aq 
ad0a 3e 78				ld a, display_row_4 
ad0c 18 02				jr .ccol1aq 
ad0e 3e 00		.crow1aq:		ld a,display_row_1 
ad10 f5			.ccol1aq:		push af			; got row offset 
ad11 6f					ld l,a 
ad12 26 00				ld h,0 
ad14					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ad14 cd 24 97			call macro_forth_dsp_pop 
ad17				endm 
# End of macro FORTH_DSP_POP
ad17					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ad17 cd a4 96			call macro_dsp_valuehl 
ad1a				endm 
# End of macro FORTH_DSP_VALUEHL
ad1a					; TODO save cursor col 
ad1a f1					pop af 
ad1b 85					add l		; add col offset 
ad1c			 
ad1c					; add current frame buffer address 
ad1c 2a db eb				ld hl, (display_fb_active) 
ad1f cd bb 88				call addatohl 
ad22			 
ad22			 
ad22			 
ad22			 
ad22					; get char frame buffer location offset in hl 
ad22			 
ad22 7e					ld a,(hl) 
ad23 26 00				ld h, 0 
ad25 6f					ld l, a 
ad26			 
ad26 cd 09 96				call forth_push_numhl 
ad29			 
ad29			 
ad29					NEXTW 
ad29 c3 de 97			jp macro_next 
ad2c				endm 
# End of macro NEXTW
ad2c			 
ad2c			.AUTODSP: 
ad2c				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
ad2c 63				db WORD_SYS_CORE+79             
ad2d 42 ad			dw .MENU            
ad2f 05				db 4 + 1 
ad30 .. 00			db "ADSP",0              
ad35				endm 
# End of macro CWHEAD
ad35			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
ad35			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
ad35			 
ad35					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ad35 cd a4 96			call macro_dsp_valuehl 
ad38				endm 
# End of macro FORTH_DSP_VALUEHL
ad38			 
ad38			;		push hl 
ad38			 
ad38					; destroy value TOS 
ad38			 
ad38					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ad38 cd 24 97			call macro_forth_dsp_pop 
ad3b				endm 
# End of macro FORTH_DSP_POP
ad3b			 
ad3b			;		pop hl 
ad3b			 
ad3b 7d					ld a,l 
ad3c 32 3c eb				ld (cli_autodisplay), a 
ad3f				       NEXTW 
ad3f c3 de 97			jp macro_next 
ad42				endm 
# End of macro NEXTW
ad42			 
ad42			.MENU: 
ad42				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
ad42 70				db WORD_SYS_CORE+92             
ad43 4e ad			dw .ENDDISPLAY            
ad45 05				db 4 + 1 
ad46 .. 00			db "MENU",0              
ad4b				endm 
# End of macro CWHEAD
ad4b			; | MENU ( u1....ux n ut -- n ) Create a menu. Ut is the title, n is the number of menu items on stack. Push number selection to TOS | TODO 
ad4b			 
ad4b					; get the title address and save it 
ad4b			 
ad4b			;		FORTH_DSP_VALUEHL 
ad4b			;		push hl 
ad4b			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ad4b			; 
ad4b			;		; get number of items on the stack 
ad4b			; 
ad4b			;	 
ad4b			;		FORTH_DSP_VALUEHL 
ad4b			;		push hl 
ad4b			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ad4b			 
ad4b			 
ad4b			 
ad4b			 
ad4b				       NEXTW 
ad4b c3 de 97			jp macro_next 
ad4e				endm 
# End of macro NEXTW
ad4e			 
ad4e			 
ad4e			.ENDDISPLAY: 
ad4e			 
ad4e			; eof 
# End of file forth_words_display.asm
ad4e			include "forth_words_str.asm" 
ad4e			 
ad4e			; | ## String Words 
ad4e			 
ad4e			.PTR:   
ad4e			 
ad4e				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
ad4e 48				db WORD_SYS_CORE+52             
ad4f 7b ad			dw .STYPE            
ad51 04				db 3 + 1 
ad52 .. 00			db "PTR",0              
ad56				endm 
# End of macro CWHEAD
ad56			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
ad56			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
ad56			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
ad56			 
ad56					if DEBUG_FORTH_WORDS_KEY 
ad56						DMARK "PTR" 
ad56 f5				push af  
ad57 3a 6b ad			ld a, (.dmark)  
ad5a 32 7a ee			ld (debug_mark),a  
ad5d 3a 6c ad			ld a, (.dmark+1)  
ad60 32 7b ee			ld (debug_mark+1),a  
ad63 3a 6d ad			ld a, (.dmark+2)  
ad66 32 7c ee			ld (debug_mark+2),a  
ad69 18 03			jr .pastdmark  
ad6b ..			.dmark: db "PTR"  
ad6e f1			.pastdmark: pop af  
ad6f			endm  
# End of macro DMARK
ad6f						CALLMONITOR 
ad6f cd 7f 90			call break_point_state  
ad72				endm  
# End of macro CALLMONITOR
ad72					endif 
ad72					FORTH_DSP_VALUEHL 
ad72 cd a4 96			call macro_dsp_valuehl 
ad75				endm 
# End of macro FORTH_DSP_VALUEHL
ad75 cd 09 96				call forth_push_numhl 
ad78			 
ad78			 
ad78					NEXTW 
ad78 c3 de 97			jp macro_next 
ad7b				endm 
# End of macro NEXTW
ad7b			.STYPE: 
ad7b				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
ad7b 48				db WORD_SYS_CORE+52             
ad7c ca ad			dw .UPPER            
ad7e 06				db 5 + 1 
ad7f .. 00			db "STYPE",0              
ad85				endm 
# End of macro CWHEAD
ad85			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
ad85					if DEBUG_FORTH_WORDS_KEY 
ad85						DMARK "STY" 
ad85 f5				push af  
ad86 3a 9a ad			ld a, (.dmark)  
ad89 32 7a ee			ld (debug_mark),a  
ad8c 3a 9b ad			ld a, (.dmark+1)  
ad8f 32 7b ee			ld (debug_mark+1),a  
ad92 3a 9c ad			ld a, (.dmark+2)  
ad95 32 7c ee			ld (debug_mark+2),a  
ad98 18 03			jr .pastdmark  
ad9a ..			.dmark: db "STY"  
ad9d f1			.pastdmark: pop af  
ad9e			endm  
# End of macro DMARK
ad9e						CALLMONITOR 
ad9e cd 7f 90			call break_point_state  
ada1				endm  
# End of macro CALLMONITOR
ada1					endif 
ada1					FORTH_DSP 
ada1 cd 89 96			call macro_forth_dsp 
ada4				endm 
# End of macro FORTH_DSP
ada4					;v5 FORTH_DSP_VALUE 
ada4			 
ada4 7e					ld a, (hl) 
ada5			 
ada5 f5					push af 
ada6			 
ada6			; Dont destroy TOS		FORTH_DSP_POP 
ada6			 
ada6 f1					pop af 
ada7			 
ada7 fe 01				cp DS_TYPE_STR 
ada9 28 09				jr z, .typestr 
adab			 
adab fe 02				cp DS_TYPE_INUM 
adad 28 0a				jr z, .typeinum 
adaf			 
adaf 21 c8 ad				ld hl, .tna 
adb2 18 0a				jr .tpush 
adb4			 
adb4 21 c4 ad		.typestr:	ld hl, .tstr 
adb7 18 05				jr .tpush 
adb9 21 c6 ad		.typeinum:	ld hl, .tinum 
adbc 18 00				jr .tpush 
adbe			 
adbe			.tpush: 
adbe			 
adbe cd 1b 96				call forth_push_str 
adc1			 
adc1					NEXTW 
adc1 c3 de 97			jp macro_next 
adc4				endm 
# End of macro NEXTW
adc4 .. 00		.tstr:	db "s",0 
adc6 .. 00		.tinum:  db "i",0 
adc8 .. 00		.tna:   db "?", 0 
adca			 
adca			 
adca			.UPPER: 
adca				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
adca 48				db WORD_SYS_CORE+52             
adcb 05 ae			dw .LOWER            
adcd 06				db 5 + 1 
adce .. 00			db "UPPER",0              
add4				endm 
# End of macro CWHEAD
add4			; | UPPER ( s -- s ) Upper case string s  | DONE 
add4					if DEBUG_FORTH_WORDS_KEY 
add4						DMARK "UPR" 
add4 f5				push af  
add5 3a e9 ad			ld a, (.dmark)  
add8 32 7a ee			ld (debug_mark),a  
addb 3a ea ad			ld a, (.dmark+1)  
adde 32 7b ee			ld (debug_mark+1),a  
ade1 3a eb ad			ld a, (.dmark+2)  
ade4 32 7c ee			ld (debug_mark+2),a  
ade7 18 03			jr .pastdmark  
ade9 ..			.dmark: db "UPR"  
adec f1			.pastdmark: pop af  
aded			endm  
# End of macro DMARK
aded						CALLMONITOR 
aded cd 7f 90			call break_point_state  
adf0				endm  
# End of macro CALLMONITOR
adf0					endif 
adf0			 
adf0					FORTH_DSP 
adf0 cd 89 96			call macro_forth_dsp 
adf3				endm 
# End of macro FORTH_DSP
adf3					 
adf3			; TODO check is string type 
adf3			 
adf3					FORTH_DSP_VALUEHL 
adf3 cd a4 96			call macro_dsp_valuehl 
adf6				endm 
# End of macro FORTH_DSP_VALUEHL
adf6			; get pointer to string in hl 
adf6			 
adf6 7e			.toup:		ld a, (hl) 
adf7 fe 00				cp 0 
adf9 28 07				jr z, .toupdone 
adfb			 
adfb cd 28 8c				call to_upper 
adfe			 
adfe 77					ld (hl), a 
adff 23					inc hl 
ae00 18 f4				jr .toup 
ae02			 
ae02					 
ae02			 
ae02			 
ae02			; for each char convert to upper 
ae02					 
ae02			.toupdone: 
ae02			 
ae02			 
ae02					NEXTW 
ae02 c3 de 97			jp macro_next 
ae05				endm 
# End of macro NEXTW
ae05			.LOWER: 
ae05				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
ae05 48				db WORD_SYS_CORE+52             
ae06 40 ae			dw .TCASE            
ae08 06				db 5 + 1 
ae09 .. 00			db "LOWER",0              
ae0f				endm 
# End of macro CWHEAD
ae0f			; | LOWER ( s -- s ) Lower case string s  | DONE 
ae0f					if DEBUG_FORTH_WORDS_KEY 
ae0f						DMARK "LWR" 
ae0f f5				push af  
ae10 3a 24 ae			ld a, (.dmark)  
ae13 32 7a ee			ld (debug_mark),a  
ae16 3a 25 ae			ld a, (.dmark+1)  
ae19 32 7b ee			ld (debug_mark+1),a  
ae1c 3a 26 ae			ld a, (.dmark+2)  
ae1f 32 7c ee			ld (debug_mark+2),a  
ae22 18 03			jr .pastdmark  
ae24 ..			.dmark: db "LWR"  
ae27 f1			.pastdmark: pop af  
ae28			endm  
# End of macro DMARK
ae28						CALLMONITOR 
ae28 cd 7f 90			call break_point_state  
ae2b				endm  
# End of macro CALLMONITOR
ae2b					endif 
ae2b			 
ae2b					FORTH_DSP 
ae2b cd 89 96			call macro_forth_dsp 
ae2e				endm 
# End of macro FORTH_DSP
ae2e					 
ae2e			; TODO check is string type 
ae2e			 
ae2e					FORTH_DSP_VALUEHL 
ae2e cd a4 96			call macro_dsp_valuehl 
ae31				endm 
# End of macro FORTH_DSP_VALUEHL
ae31			; get pointer to string in hl 
ae31			 
ae31 7e			.tolow:		ld a, (hl) 
ae32 fe 00				cp 0 
ae34 28 07				jr z, .tolowdone 
ae36			 
ae36 cd 31 8c				call to_lower 
ae39			 
ae39 77					ld (hl), a 
ae3a 23					inc hl 
ae3b 18 f4				jr .tolow 
ae3d			 
ae3d					 
ae3d			 
ae3d			 
ae3d			; for each char convert to low 
ae3d					 
ae3d			.tolowdone: 
ae3d					NEXTW 
ae3d c3 de 97			jp macro_next 
ae40				endm 
# End of macro NEXTW
ae40			.TCASE: 
ae40				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
ae40 48				db WORD_SYS_CORE+52             
ae41 96 ae			dw .SUBSTR            
ae43 06				db 5 + 1 
ae44 .. 00			db "TCASE",0              
ae4a				endm 
# End of macro CWHEAD
ae4a			; | TCASE ( s -- s ) Title case string s  | DONE 
ae4a					if DEBUG_FORTH_WORDS_KEY 
ae4a						DMARK "TCS" 
ae4a f5				push af  
ae4b 3a 5f ae			ld a, (.dmark)  
ae4e 32 7a ee			ld (debug_mark),a  
ae51 3a 60 ae			ld a, (.dmark+1)  
ae54 32 7b ee			ld (debug_mark+1),a  
ae57 3a 61 ae			ld a, (.dmark+2)  
ae5a 32 7c ee			ld (debug_mark+2),a  
ae5d 18 03			jr .pastdmark  
ae5f ..			.dmark: db "TCS"  
ae62 f1			.pastdmark: pop af  
ae63			endm  
# End of macro DMARK
ae63						CALLMONITOR 
ae63 cd 7f 90			call break_point_state  
ae66				endm  
# End of macro CALLMONITOR
ae66					endif 
ae66			 
ae66					FORTH_DSP 
ae66 cd 89 96			call macro_forth_dsp 
ae69				endm 
# End of macro FORTH_DSP
ae69					 
ae69			; TODO check is string type 
ae69			 
ae69					FORTH_DSP_VALUEHL 
ae69 cd a4 96			call macro_dsp_valuehl 
ae6c				endm 
# End of macro FORTH_DSP_VALUEHL
ae6c			; get pointer to string in hl 
ae6c			 
ae6c					if DEBUG_FORTH_WORDS 
ae6c						DMARK "TC1" 
ae6c						CALLMONITOR 
ae6c					endif 
ae6c			 
ae6c					; first time in turn to upper case first char 
ae6c			 
ae6c 7e					ld a, (hl) 
ae6d c3 87 ae				jp .totsiptou 
ae70			 
ae70			 
ae70 7e			.tot:		ld a, (hl) 
ae71 fe 00				cp 0 
ae73 ca 93 ae				jp z, .totdone 
ae76			 
ae76					if DEBUG_FORTH_WORDS 
ae76						DMARK "TC2" 
ae76						CALLMONITOR 
ae76					endif 
ae76					; check to see if current char is a space 
ae76			 
ae76 fe 20				cp ' ' 
ae78 28 05				jr z, .totsp 
ae7a cd 31 8c				call to_lower 
ae7d					if DEBUG_FORTH_WORDS 
ae7d						DMARK "TC3" 
ae7d						CALLMONITOR 
ae7d					endif 
ae7d 18 0f				jr .totnxt 
ae7f			 
ae7f			.totsp:         ; on a space, find next char which should be upper 
ae7f			 
ae7f					if DEBUG_FORTH_WORDS 
ae7f						DMARK "TC4" 
ae7f						CALLMONITOR 
ae7f					endif 
ae7f					;; 
ae7f			 
ae7f fe 20				cp ' ' 
ae81 20 04				jr nz, .totsiptou 
ae83 23					inc hl 
ae84 7e					ld a, (hl) 
ae85					if DEBUG_FORTH_WORDS 
ae85						DMARK "TC5" 
ae85						CALLMONITOR 
ae85					endif 
ae85 18 f8				jr .totsp 
ae87 fe 00		.totsiptou:    cp 0 
ae89 28 08				jr z, .totdone 
ae8b					; not space and not zero term so upper case it 
ae8b cd 28 8c				call to_upper 
ae8e			 
ae8e					if DEBUG_FORTH_WORDS 
ae8e						DMARK "TC6" 
ae8e						CALLMONITOR 
ae8e					endif 
ae8e			 
ae8e			 
ae8e			.totnxt: 
ae8e			 
ae8e 77					ld (hl), a 
ae8f 23					inc hl 
ae90					if DEBUG_FORTH_WORDS 
ae90						DMARK "TC7" 
ae90						CALLMONITOR 
ae90					endif 
ae90 c3 70 ae				jp .tot 
ae93			 
ae93					 
ae93			 
ae93			 
ae93			; for each char convert to low 
ae93					 
ae93			.totdone: 
ae93					if DEBUG_FORTH_WORDS 
ae93						DMARK "TCd" 
ae93						CALLMONITOR 
ae93					endif 
ae93					NEXTW 
ae93 c3 de 97			jp macro_next 
ae96				endm 
# End of macro NEXTW
ae96			 
ae96			.SUBSTR: 
ae96				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
ae96 48				db WORD_SYS_CORE+52             
ae97 f4 ae			dw .LEFT            
ae99 07				db 6 + 1 
ae9a .. 00			db "SUBSTR",0              
aea1				endm 
# End of macro CWHEAD
aea1			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
aea1			 
aea1					if DEBUG_FORTH_WORDS_KEY 
aea1						DMARK "SST" 
aea1 f5				push af  
aea2 3a b6 ae			ld a, (.dmark)  
aea5 32 7a ee			ld (debug_mark),a  
aea8 3a b7 ae			ld a, (.dmark+1)  
aeab 32 7b ee			ld (debug_mark+1),a  
aeae 3a b8 ae			ld a, (.dmark+2)  
aeb1 32 7c ee			ld (debug_mark+2),a  
aeb4 18 03			jr .pastdmark  
aeb6 ..			.dmark: db "SST"  
aeb9 f1			.pastdmark: pop af  
aeba			endm  
# End of macro DMARK
aeba						CALLMONITOR 
aeba cd 7f 90			call break_point_state  
aebd				endm  
# End of macro CALLMONITOR
aebd					endif 
aebd			; TODO check string type 
aebd					FORTH_DSP_VALUEHL 
aebd cd a4 96			call macro_dsp_valuehl 
aec0				endm 
# End of macro FORTH_DSP_VALUEHL
aec0			 
aec0 e5					push hl      ; string length 
aec1			 
aec1					FORTH_DSP_POP 
aec1 cd 24 97			call macro_forth_dsp_pop 
aec4				endm 
# End of macro FORTH_DSP_POP
aec4			 
aec4					FORTH_DSP_VALUEHL 
aec4 cd a4 96			call macro_dsp_valuehl 
aec7				endm 
# End of macro FORTH_DSP_VALUEHL
aec7			 
aec7 e5					push hl     ; start char 
aec8			 
aec8					FORTH_DSP_POP 
aec8 cd 24 97			call macro_forth_dsp_pop 
aecb				endm 
# End of macro FORTH_DSP_POP
aecb			 
aecb			 
aecb					FORTH_DSP_VALUE 
aecb cd 8d 96			call macro_forth_dsp_value 
aece				endm 
# End of macro FORTH_DSP_VALUE
aece			 
aece d1					pop de    ; get start post offset 
aecf			 
aecf 19					add hl, de    ; starting offset 
aed0			 
aed0 c1					pop bc 
aed1 c5					push bc      ; grab size of string 
aed2			 
aed2 e5					push hl    ; save string start  
aed3			 
aed3 26 00				ld h, 0 
aed5 69					ld l, c 
aed6 23					inc hl 
aed7 23					inc hl 
aed8			 
aed8 cd 82 8d				call malloc 
aedb				if DEBUG_FORTH_MALLOC_GUARD 
aedb cc 82 b3				call z,malloc_error 
aede				endif 
aede			 
aede eb					ex de, hl      ; save malloc area for string copy 
aedf e1					pop hl    ; get back source 
aee0 c1					pop bc    ; get length of string back 
aee1			 
aee1 d5					push de    ; save malloc area for after we push 
aee2 ed b0				ldir     ; copy substr 
aee4			 
aee4			 
aee4 eb					ex de, hl 
aee5 3e 00				ld a, 0 
aee7 77					ld (hl), a   ; term substr 
aee8			 
aee8					 
aee8 e1					pop hl    ; get malloc so we can push it 
aee9 e5					push hl   ; save so we can free it afterwards 
aeea			 
aeea cd 1b 96				call forth_push_str 
aeed			 
aeed e1					pop hl 
aeee cd 4c 8e				call free 
aef1			 
aef1					 
aef1					 
aef1			 
aef1			 
aef1					NEXTW 
aef1 c3 de 97			jp macro_next 
aef4				endm 
# End of macro NEXTW
aef4			 
aef4			.LEFT: 
aef4				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
aef4 48				db WORD_SYS_CORE+52             
aef5 1c af			dw .RIGHT            
aef7 05				db 4 + 1 
aef8 .. 00			db "LEFT",0              
aefd				endm 
# End of macro CWHEAD
aefd			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
aefd					if DEBUG_FORTH_WORDS_KEY 
aefd						DMARK "LEF" 
aefd f5				push af  
aefe 3a 12 af			ld a, (.dmark)  
af01 32 7a ee			ld (debug_mark),a  
af04 3a 13 af			ld a, (.dmark+1)  
af07 32 7b ee			ld (debug_mark+1),a  
af0a 3a 14 af			ld a, (.dmark+2)  
af0d 32 7c ee			ld (debug_mark+2),a  
af10 18 03			jr .pastdmark  
af12 ..			.dmark: db "LEF"  
af15 f1			.pastdmark: pop af  
af16			endm  
# End of macro DMARK
af16						CALLMONITOR 
af16 cd 7f 90			call break_point_state  
af19				endm  
# End of macro CALLMONITOR
af19					endif 
af19			 
af19					NEXTW 
af19 c3 de 97			jp macro_next 
af1c				endm 
# End of macro NEXTW
af1c			.RIGHT: 
af1c				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
af1c 48				db WORD_SYS_CORE+52             
af1d 45 af			dw .STR2NUM            
af1f 06				db 5 + 1 
af20 .. 00			db "RIGHT",0              
af26				endm 
# End of macro CWHEAD
af26			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
af26					if DEBUG_FORTH_WORDS_KEY 
af26						DMARK "RIG" 
af26 f5				push af  
af27 3a 3b af			ld a, (.dmark)  
af2a 32 7a ee			ld (debug_mark),a  
af2d 3a 3c af			ld a, (.dmark+1)  
af30 32 7b ee			ld (debug_mark+1),a  
af33 3a 3d af			ld a, (.dmark+2)  
af36 32 7c ee			ld (debug_mark+2),a  
af39 18 03			jr .pastdmark  
af3b ..			.dmark: db "RIG"  
af3e f1			.pastdmark: pop af  
af3f			endm  
# End of macro DMARK
af3f						CALLMONITOR 
af3f cd 7f 90			call break_point_state  
af42				endm  
# End of macro CALLMONITOR
af42					endif 
af42			 
af42					NEXTW 
af42 c3 de 97			jp macro_next 
af45				endm 
# End of macro NEXTW
af45			 
af45			 
af45			.STR2NUM: 
af45				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
af45 48				db WORD_SYS_CORE+52             
af46 7d af			dw .NUM2STR            
af48 08				db 7 + 1 
af49 .. 00			db "STR2NUM",0              
af51				endm 
# End of macro CWHEAD
af51			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
af51			 
af51			 
af51			; TODO STR type check to do 
af51					if DEBUG_FORTH_WORDS_KEY 
af51						DMARK "S2N" 
af51 f5				push af  
af52 3a 66 af			ld a, (.dmark)  
af55 32 7a ee			ld (debug_mark),a  
af58 3a 67 af			ld a, (.dmark+1)  
af5b 32 7b ee			ld (debug_mark+1),a  
af5e 3a 68 af			ld a, (.dmark+2)  
af61 32 7c ee			ld (debug_mark+2),a  
af64 18 03			jr .pastdmark  
af66 ..			.dmark: db "S2N"  
af69 f1			.pastdmark: pop af  
af6a			endm  
# End of macro DMARK
af6a						CALLMONITOR 
af6a cd 7f 90			call break_point_state  
af6d				endm  
# End of macro CALLMONITOR
af6d					endif 
af6d			 
af6d					;FORTH_DSP 
af6d					FORTH_DSP_VALUE 
af6d cd 8d 96			call macro_forth_dsp_value 
af70				endm 
# End of macro FORTH_DSP_VALUE
af70					;inc hl 
af70			 
af70 eb					ex de, hl 
af71					if DEBUG_FORTH_WORDS 
af71						DMARK "S2a" 
af71						CALLMONITOR 
af71					endif 
af71 cd b0 8c				call string_to_uint16 
af74			 
af74					if DEBUG_FORTH_WORDS 
af74						DMARK "S2b" 
af74						CALLMONITOR 
af74					endif 
af74			;		push hl 
af74					FORTH_DSP_POP 
af74 cd 24 97			call macro_forth_dsp_pop 
af77				endm 
# End of macro FORTH_DSP_POP
af77			;		pop hl 
af77					 
af77					if DEBUG_FORTH_WORDS 
af77						DMARK "S2b" 
af77						CALLMONITOR 
af77					endif 
af77 cd 09 96				call forth_push_numhl	 
af7a			 
af7a				 
af7a				       NEXTW 
af7a c3 de 97			jp macro_next 
af7d				endm 
# End of macro NEXTW
af7d			.NUM2STR: 
af7d				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
af7d 48				db WORD_SYS_CORE+52             
af7e 8c af			dw .CONCAT            
af80 08				db 7 + 1 
af81 .. 00			db "NUM2STR",0              
af89				endm 
# End of macro CWHEAD
af89			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
af89			 
af89			;		; malloc a string to target 
af89			;		ld hl, 10     ; TODO max string size should be fine 
af89			;		call malloc 
af89			;		push hl    ; save malloc location 
af89			; 
af89			; 
af89			;; TODO check int type 
af89			;		FORTH_DSP_VALUEHL 
af89			;		ld a, l 
af89			;		call DispAToASCII   
af89			;;TODO need to chage above call to dump into string 
af89			; 
af89			; 
af89			 
af89				       NEXTW 
af89 c3 de 97			jp macro_next 
af8c				endm 
# End of macro NEXTW
af8c			 
af8c			.CONCAT: 
af8c				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
af8c 48				db WORD_SYS_CORE+52             
af8d eb af			dw .FIND            
af8f 07				db 6 + 1 
af90 .. 00			db "CONCAT",0              
af97				endm 
# End of macro CWHEAD
af97			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
af97			 
af97			; TODO check string type 
af97			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
af97			 
af97					if DEBUG_FORTH_WORDS_KEY 
af97						DMARK "CON" 
af97 f5				push af  
af98 3a ac af			ld a, (.dmark)  
af9b 32 7a ee			ld (debug_mark),a  
af9e 3a ad af			ld a, (.dmark+1)  
afa1 32 7b ee			ld (debug_mark+1),a  
afa4 3a ae af			ld a, (.dmark+2)  
afa7 32 7c ee			ld (debug_mark+2),a  
afaa 18 03			jr .pastdmark  
afac ..			.dmark: db "CON"  
afaf f1			.pastdmark: pop af  
afb0			endm  
# End of macro DMARK
afb0						CALLMONITOR 
afb0 cd 7f 90			call break_point_state  
afb3				endm  
# End of macro CALLMONITOR
afb3					endif 
afb3			 
afb3			 
afb3					FORTH_DSP_VALUE 
afb3 cd 8d 96			call macro_forth_dsp_value 
afb6				endm 
# End of macro FORTH_DSP_VALUE
afb6 e5					push hl   ; s2 
afb7			 
afb7					FORTH_DSP_POP 
afb7 cd 24 97			call macro_forth_dsp_pop 
afba				endm 
# End of macro FORTH_DSP_POP
afba			 
afba					FORTH_DSP_VALUE 
afba cd 8d 96			call macro_forth_dsp_value 
afbd				endm 
# End of macro FORTH_DSP_VALUE
afbd			 
afbd e5					push hl   ; s1 
afbe			 
afbe					FORTH_DSP_POP 
afbe cd 24 97			call macro_forth_dsp_pop 
afc1				endm 
# End of macro FORTH_DSP_POP
afc1					 
afc1			 
afc1					; copy s1 
afc1			 
afc1				 
afc1					; save ptr 
afc1 e1					pop hl  
afc2 e5					push hl 
afc3 3e 00				ld a, 0 
afc5 cd 24 8d				call strlent 
afc8					;inc hl    ; zer0 
afc8 06 00				ld b, 0 
afca 4d					ld c, l 
afcb e1					pop hl		 
afcc 11 75 e3				ld de, scratch	 
afcf					if DEBUG_FORTH_WORDS 
afcf						DMARK "CO1" 
afcf						CALLMONITOR 
afcf					endif 
afcf ed b0				ldir 
afd1			 
afd1 e1					pop hl 
afd2 e5					push hl 
afd3 d5					push de 
afd4			 
afd4			 
afd4 3e 00				ld a, 0 
afd6 cd 24 8d				call strlent 
afd9 23					inc hl    ; zer0 
afda 23					inc hl 
afdb 06 00				ld b, 0 
afdd 4d					ld c, l 
afde d1					pop de 
afdf e1					pop hl		 
afe0					if DEBUG_FORTH_WORDS 
afe0						DMARK "CO2" 
afe0						CALLMONITOR 
afe0					endif 
afe0 ed b0				ldir 
afe2			 
afe2			 
afe2			 
afe2 21 75 e3				ld hl, scratch 
afe5					if DEBUG_FORTH_WORDS 
afe5						DMARK "CO5" 
afe5						CALLMONITOR 
afe5					endif 
afe5			 
afe5 cd 1b 96				call forth_push_str 
afe8			 
afe8			 
afe8			 
afe8			 
afe8				       NEXTW 
afe8 c3 de 97			jp macro_next 
afeb				endm 
# End of macro NEXTW
afeb			 
afeb			 
afeb			.FIND: 
afeb				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
afeb 4b				db WORD_SYS_CORE+55             
afec 39 b0			dw .LEN            
afee 05				db 4 + 1 
afef .. 00			db "FIND",0              
aff4				endm 
# End of macro CWHEAD
aff4			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
aff4			 
aff4					if DEBUG_FORTH_WORDS_KEY 
aff4						DMARK "FND" 
aff4 f5				push af  
aff5 3a 09 b0			ld a, (.dmark)  
aff8 32 7a ee			ld (debug_mark),a  
affb 3a 0a b0			ld a, (.dmark+1)  
affe 32 7b ee			ld (debug_mark+1),a  
b001 3a 0b b0			ld a, (.dmark+2)  
b004 32 7c ee			ld (debug_mark+2),a  
b007 18 03			jr .pastdmark  
b009 ..			.dmark: db "FND"  
b00c f1			.pastdmark: pop af  
b00d			endm  
# End of macro DMARK
b00d						CALLMONITOR 
b00d cd 7f 90			call break_point_state  
b010				endm  
# End of macro CALLMONITOR
b010					endif 
b010			 
b010			; TODO check string type 
b010					FORTH_DSP_VALUE 
b010 cd 8d 96			call macro_forth_dsp_value 
b013				endm 
# End of macro FORTH_DSP_VALUE
b013			 
b013 e5					push hl    
b014 7e					ld a,(hl)    ; char to find   
b015			; TODO change char to substr 
b015			 
b015 f5					push af 
b016					 
b016			 
b016			 
b016					if DEBUG_FORTH_WORDS 
b016						DMARK "FN1" 
b016						CALLMONITOR 
b016					endif 
b016			 
b016					FORTH_DSP_POP 
b016 cd 24 97			call macro_forth_dsp_pop 
b019				endm 
# End of macro FORTH_DSP_POP
b019			 
b019					; string to search 
b019			 
b019					FORTH_DSP_VALUE 
b019 cd 8d 96			call macro_forth_dsp_value 
b01c				endm 
# End of macro FORTH_DSP_VALUE
b01c			 
b01c d1					pop de  ; d is char to find  
b01d			 
b01d					if DEBUG_FORTH_WORDS 
b01d						DMARK "FN2" 
b01d						CALLMONITOR 
b01d					endif 
b01d					 
b01d 01 00 00				ld bc, 0 
b020 7e			.findchar:      ld a,(hl) 
b021 fe 00				cp 0   		 
b023 28 0b				jr z, .finddone     
b025 ba					cp d 
b026 28 04				jr z, .foundchar 
b028 03					inc bc 
b029 23					inc hl 
b02a					if DEBUG_FORTH_WORDS 
b02a						DMARK "FN3" 
b02a						CALLMONITOR 
b02a					endif 
b02a 18 f4				jr .findchar 
b02c			 
b02c			 
b02c c5			.foundchar:	push bc 
b02d e1					pop hl 
b02e 18 03				jr .findexit 
b030			 
b030			 
b030							 
b030			 
b030			.finddone:     ; got to end of string with no find 
b030 21 00 00				ld hl, 0 
b033			.findexit: 
b033			 
b033					if DEBUG_FORTH_WORDS 
b033						DMARK "FNd" 
b033						CALLMONITOR 
b033					endif 
b033 cd 09 96			call forth_push_numhl 
b036			 
b036				       NEXTW 
b036 c3 de 97			jp macro_next 
b039				endm 
# End of macro NEXTW
b039			 
b039			.LEN: 
b039				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
b039 4c				db WORD_SYS_CORE+56             
b03a 6e b0			dw .CHAR            
b03c 06				db 5 + 1 
b03d .. 00			db "COUNT",0              
b043				endm 
# End of macro CWHEAD
b043			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
b043			 
b043					if DEBUG_FORTH_WORDS_KEY 
b043						DMARK "CNT" 
b043 f5				push af  
b044 3a 58 b0			ld a, (.dmark)  
b047 32 7a ee			ld (debug_mark),a  
b04a 3a 59 b0			ld a, (.dmark+1)  
b04d 32 7b ee			ld (debug_mark+1),a  
b050 3a 5a b0			ld a, (.dmark+2)  
b053 32 7c ee			ld (debug_mark+2),a  
b056 18 03			jr .pastdmark  
b058 ..			.dmark: db "CNT"  
b05b f1			.pastdmark: pop af  
b05c			endm  
# End of macro DMARK
b05c						CALLMONITOR 
b05c cd 7f 90			call break_point_state  
b05f				endm  
# End of macro CALLMONITOR
b05f					endif 
b05f			; TODO check string type 
b05f					FORTH_DSP 
b05f cd 89 96			call macro_forth_dsp 
b062				endm 
# End of macro FORTH_DSP
b062					;v5FORTH_DSP_VALUE 
b062			 
b062 23					inc hl 
b063			 
b063 3e 00				ld a, 0 
b065 cd 24 8d				call strlent 
b068			 
b068 cd 09 96				call forth_push_numhl 
b06b			 
b06b			 
b06b			 
b06b				       NEXTW 
b06b c3 de 97			jp macro_next 
b06e				endm 
# End of macro NEXTW
b06e			.CHAR: 
b06e				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
b06e 4d				db WORD_SYS_CORE+57             
b06f a4 b0			dw .ENDSTR            
b071 05				db 4 + 1 
b072 .. 00			db "CHAR",0              
b077				endm 
# End of macro CWHEAD
b077			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
b077					if DEBUG_FORTH_WORDS_KEY 
b077						DMARK "CHR" 
b077 f5				push af  
b078 3a 8c b0			ld a, (.dmark)  
b07b 32 7a ee			ld (debug_mark),a  
b07e 3a 8d b0			ld a, (.dmark+1)  
b081 32 7b ee			ld (debug_mark+1),a  
b084 3a 8e b0			ld a, (.dmark+2)  
b087 32 7c ee			ld (debug_mark+2),a  
b08a 18 03			jr .pastdmark  
b08c ..			.dmark: db "CHR"  
b08f f1			.pastdmark: pop af  
b090			endm  
# End of macro DMARK
b090						CALLMONITOR 
b090 cd 7f 90			call break_point_state  
b093				endm  
# End of macro CALLMONITOR
b093					endif 
b093					FORTH_DSP 
b093 cd 89 96			call macro_forth_dsp 
b096				endm 
# End of macro FORTH_DSP
b096					;v5 FORTH_DSP_VALUE 
b096 23					inc hl      ; now at start of numeric as string 
b097			 
b097			;		push hl 
b097			 
b097					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b097 cd 24 97			call macro_forth_dsp_pop 
b09a				endm 
# End of macro FORTH_DSP_POP
b09a			 
b09a			;		pop hl 
b09a			 
b09a					; push the content of a onto the stack as a value 
b09a			 
b09a 7e					ld a,(hl)   ; get char 
b09b 26 00				ld h,0 
b09d 6f					ld l,a 
b09e cd 09 96				call forth_push_numhl 
b0a1			 
b0a1				       NEXTW 
b0a1 c3 de 97			jp macro_next 
b0a4				endm 
# End of macro NEXTW
b0a4			 
b0a4			 
b0a4			 
b0a4			 
b0a4			.ENDSTR: 
b0a4			; eof 
b0a4			 
# End of file forth_words_str.asm
b0a4			include "forth_words_key.asm" 
b0a4			 
b0a4			; | ## Keyboard Words 
b0a4			 
b0a4			.KEY: 
b0a4				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
b0a4 3e				db WORD_SYS_CORE+42             
b0a5 d4 b0			dw .WAITK            
b0a7 04				db 3 + 1 
b0a8 .. 00			db "KEY",0              
b0ac				endm 
# End of macro CWHEAD
b0ac			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
b0ac			 
b0ac					if DEBUG_FORTH_WORDS_KEY 
b0ac						DMARK "KEY" 
b0ac f5				push af  
b0ad 3a c1 b0			ld a, (.dmark)  
b0b0 32 7a ee			ld (debug_mark),a  
b0b3 3a c2 b0			ld a, (.dmark+1)  
b0b6 32 7b ee			ld (debug_mark+1),a  
b0b9 3a c3 b0			ld a, (.dmark+2)  
b0bc 32 7c ee			ld (debug_mark+2),a  
b0bf 18 03			jr .pastdmark  
b0c1 ..			.dmark: db "KEY"  
b0c4 f1			.pastdmark: pop af  
b0c5			endm  
# End of macro DMARK
b0c5						CALLMONITOR 
b0c5 cd 7f 90			call break_point_state  
b0c8				endm  
# End of macro CALLMONITOR
b0c8					endif 
b0c8			; TODO currently waits 
b0c8 cd 9f c6				call cin_wait 
b0cb 6f					ld l, a 
b0cc 26 00				ld h, 0 
b0ce cd 09 96				call forth_push_numhl 
b0d1					NEXTW 
b0d1 c3 de 97			jp macro_next 
b0d4				endm 
# End of macro NEXTW
b0d4			.WAITK: 
b0d4				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
b0d4 3f				db WORD_SYS_CORE+43             
b0d5 06 b1			dw .ACCEPT            
b0d7 06				db 5 + 1 
b0d8 .. 00			db "WAITK",0              
b0de				endm 
# End of macro CWHEAD
b0de			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
b0de					if DEBUG_FORTH_WORDS_KEY 
b0de						DMARK "WAI" 
b0de f5				push af  
b0df 3a f3 b0			ld a, (.dmark)  
b0e2 32 7a ee			ld (debug_mark),a  
b0e5 3a f4 b0			ld a, (.dmark+1)  
b0e8 32 7b ee			ld (debug_mark+1),a  
b0eb 3a f5 b0			ld a, (.dmark+2)  
b0ee 32 7c ee			ld (debug_mark+2),a  
b0f1 18 03			jr .pastdmark  
b0f3 ..			.dmark: db "WAI"  
b0f6 f1			.pastdmark: pop af  
b0f7			endm  
# End of macro DMARK
b0f7						CALLMONITOR 
b0f7 cd 7f 90			call break_point_state  
b0fa				endm  
# End of macro CALLMONITOR
b0fa					endif 
b0fa cd 9f c6				call cin_wait 
b0fd 6f					ld l, a 
b0fe 26 00				ld h, 0 
b100 cd 09 96				call forth_push_numhl 
b103					NEXTW 
b103 c3 de 97			jp macro_next 
b106				endm 
# End of macro NEXTW
b106			.ACCEPT: 
b106				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
b106 40				db WORD_SYS_CORE+44             
b107 48 b1			dw .EDIT            
b109 07				db 6 + 1 
b10a .. 00			db "ACCEPT",0              
b111				endm 
# End of macro CWHEAD
b111			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
b111					; TODO crashes on push 
b111					if DEBUG_FORTH_WORDS_KEY 
b111						DMARK "ACC" 
b111 f5				push af  
b112 3a 26 b1			ld a, (.dmark)  
b115 32 7a ee			ld (debug_mark),a  
b118 3a 27 b1			ld a, (.dmark+1)  
b11b 32 7b ee			ld (debug_mark+1),a  
b11e 3a 28 b1			ld a, (.dmark+2)  
b121 32 7c ee			ld (debug_mark+2),a  
b124 18 03			jr .pastdmark  
b126 ..			.dmark: db "ACC"  
b129 f1			.pastdmark: pop af  
b12a			endm  
# End of macro DMARK
b12a						CALLMONITOR 
b12a cd 7f 90			call break_point_state  
b12d				endm  
# End of macro CALLMONITOR
b12d					endif 
b12d 21 73 e5				ld hl, os_input 
b130 3e 00				ld a, 0 
b132 77					ld (hl),a 
b133 3a 5e eb				ld a,(f_cursor_ptr) 
b136 16 64				ld d, 100 
b138 0e 00				ld c, 0 
b13a 1e 28				ld e, 40 
b13c cd e8 88				call input_str 
b13f					; TODO perhaps do a type check and wrap in quotes if not a number 
b13f 21 73 e5				ld hl, os_input 
b142					if DEBUG_FORTH_WORDS 
b142						DMARK "AC1" 
b142						CALLMONITOR 
b142					endif 
b142 cd 1b 96				call forth_push_str 
b145					NEXTW 
b145 c3 de 97			jp macro_next 
b148				endm 
# End of macro NEXTW
b148			 
b148			.EDIT: 
b148				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
b148 40				db WORD_SYS_CORE+44             
b149 b5 b1			dw .ENDKEY            
b14b 05				db 4 + 1 
b14c .. 00			db "EDIT",0              
b151				endm 
# End of macro CWHEAD
b151			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
b151			 
b151					; TODO does not copy from stack 
b151					if DEBUG_FORTH_WORDS_KEY 
b151						DMARK "EDT" 
b151 f5				push af  
b152 3a 66 b1			ld a, (.dmark)  
b155 32 7a ee			ld (debug_mark),a  
b158 3a 67 b1			ld a, (.dmark+1)  
b15b 32 7b ee			ld (debug_mark+1),a  
b15e 3a 68 b1			ld a, (.dmark+2)  
b161 32 7c ee			ld (debug_mark+2),a  
b164 18 03			jr .pastdmark  
b166 ..			.dmark: db "EDT"  
b169 f1			.pastdmark: pop af  
b16a			endm  
# End of macro DMARK
b16a						CALLMONITOR 
b16a cd 7f 90			call break_point_state  
b16d				endm  
# End of macro CALLMONITOR
b16d					endif 
b16d			 
b16d					FORTH_DSP 
b16d cd 89 96			call macro_forth_dsp 
b170				endm 
# End of macro FORTH_DSP
b170					;v5 FORTH_DSP_VALUE 
b170 23					inc hl    ; TODO do type check 
b171			 
b171 e5					push hl 
b172 3e 00				ld a, 0 
b174 cd 24 8d				call strlent 
b177 23					inc hl 
b178			 
b178 06 00				ld b, 0 
b17a 4d					ld c, l 
b17b			 
b17b e1					pop hl 
b17c 11 73 e5				ld de, os_input 
b17f					if DEBUG_FORTH_WORDS_KEY 
b17f						DMARK "EDc" 
b17f f5				push af  
b180 3a 94 b1			ld a, (.dmark)  
b183 32 7a ee			ld (debug_mark),a  
b186 3a 95 b1			ld a, (.dmark+1)  
b189 32 7b ee			ld (debug_mark+1),a  
b18c 3a 96 b1			ld a, (.dmark+2)  
b18f 32 7c ee			ld (debug_mark+2),a  
b192 18 03			jr .pastdmark  
b194 ..			.dmark: db "EDc"  
b197 f1			.pastdmark: pop af  
b198			endm  
# End of macro DMARK
b198						CALLMONITOR 
b198 cd 7f 90			call break_point_state  
b19b				endm  
# End of macro CALLMONITOR
b19b					endif 
b19b ed b0				ldir 
b19d			 
b19d			 
b19d 21 73 e5				ld hl, os_input 
b1a0					;ld a, 0 
b1a0					;ld (hl),a 
b1a0 3a 5e eb				ld a,(f_cursor_ptr) 
b1a3 16 64				ld d, 100 
b1a5 0e 00				ld c, 0 
b1a7 1e 28				ld e, 40 
b1a9 cd e8 88				call input_str 
b1ac					; TODO perhaps do a type check and wrap in quotes if not a number 
b1ac 21 73 e5				ld hl, os_input 
b1af					if DEBUG_FORTH_WORDS 
b1af						DMARK "ED1" 
b1af						CALLMONITOR 
b1af					endif 
b1af cd 1b 96				call forth_push_str 
b1b2					NEXTW 
b1b2 c3 de 97			jp macro_next 
b1b5				endm 
# End of macro NEXTW
b1b5			 
b1b5			 
b1b5			 
b1b5			.ENDKEY: 
b1b5			; eof 
b1b5			 
# End of file forth_words_key.asm
b1b5			 
b1b5			if STORAGE_SE 
b1b5			   	include "forth_words_storage.asm" 
b1b5			endif 
b1b5				include "forth_words_device.asm" 
b1b5			; Device related words 
b1b5			 
b1b5			; | ## Device Words 
b1b5			 
b1b5			if SOUND_ENABLE 
b1b5			.NOTE: 
b1b5				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
b1b5			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
b1b5					if DEBUG_FORTH_WORDS_KEY 
b1b5						DMARK "NTE" 
b1b5						CALLMONITOR 
b1b5					endif 
b1b5			 
b1b5				 
b1b5			 
b1b5					NEXTW 
b1b5			.AFTERSOUND: 
b1b5			endif 
b1b5			 
b1b5			 
b1b5			USE_GPIO: equ 0 
b1b5			 
b1b5			if USE_GPIO 
b1b5			.GP1: 
b1b5				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
b1b5			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
b1b5					NEXTW 
b1b5			.GP2: 
b1b5				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
b1b5			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
b1b5			 
b1b5					NEXTW 
b1b5			 
b1b5			.GP3: 
b1b5				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
b1b5			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
b1b5			 
b1b5					NEXTW 
b1b5			 
b1b5			.GP4: 
b1b5				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
b1b5			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
b1b5			 
b1b5					NEXTW 
b1b5			.SIN: 
b1b5			 
b1b5			 
b1b5			endif 
b1b5			 
b1b5			 
b1b5				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
b1b5 33				db WORD_SYS_CORE+31             
b1b6 ea b1			dw .SOUT            
b1b8 03				db 2 + 1 
b1b9 .. 00			db "IN",0              
b1bc				endm 
# End of macro CWHEAD
b1bc			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
b1bc					if DEBUG_FORTH_WORDS_KEY 
b1bc						DMARK "IN." 
b1bc f5				push af  
b1bd 3a d1 b1			ld a, (.dmark)  
b1c0 32 7a ee			ld (debug_mark),a  
b1c3 3a d2 b1			ld a, (.dmark+1)  
b1c6 32 7b ee			ld (debug_mark+1),a  
b1c9 3a d3 b1			ld a, (.dmark+2)  
b1cc 32 7c ee			ld (debug_mark+2),a  
b1cf 18 03			jr .pastdmark  
b1d1 ..			.dmark: db "IN."  
b1d4 f1			.pastdmark: pop af  
b1d5			endm  
# End of macro DMARK
b1d5						CALLMONITOR 
b1d5 cd 7f 90			call break_point_state  
b1d8				endm  
# End of macro CALLMONITOR
b1d8					endif 
b1d8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b1d8 cd a4 96			call macro_dsp_valuehl 
b1db				endm 
# End of macro FORTH_DSP_VALUEHL
b1db			 
b1db e5					push hl 
b1dc			 
b1dc					; destroy value TOS 
b1dc			 
b1dc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1dc cd 24 97			call macro_forth_dsp_pop 
b1df				endm 
# End of macro FORTH_DSP_POP
b1df			 
b1df					; one value on hl get other one back 
b1df			 
b1df c1					pop bc 
b1e0			 
b1e0					; do the sub 
b1e0			;		ex de, hl 
b1e0			 
b1e0 ed 68				in l,(c) 
b1e2			 
b1e2					; save it 
b1e2			 
b1e2 26 00				ld h,0 
b1e4			 
b1e4					; TODO push value back onto stack for another op etc 
b1e4			 
b1e4 cd 09 96				call forth_push_numhl 
b1e7					NEXTW 
b1e7 c3 de 97			jp macro_next 
b1ea				endm 
# End of macro NEXTW
b1ea			.SOUT: 
b1ea				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
b1ea 34				db WORD_SYS_CORE+32             
b1eb 21 b2			dw .SPIO            
b1ed 04				db 3 + 1 
b1ee .. 00			db "OUT",0              
b1f2				endm 
# End of macro CWHEAD
b1f2			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
b1f2					if DEBUG_FORTH_WORDS_KEY 
b1f2						DMARK "OUT" 
b1f2 f5				push af  
b1f3 3a 07 b2			ld a, (.dmark)  
b1f6 32 7a ee			ld (debug_mark),a  
b1f9 3a 08 b2			ld a, (.dmark+1)  
b1fc 32 7b ee			ld (debug_mark+1),a  
b1ff 3a 09 b2			ld a, (.dmark+2)  
b202 32 7c ee			ld (debug_mark+2),a  
b205 18 03			jr .pastdmark  
b207 ..			.dmark: db "OUT"  
b20a f1			.pastdmark: pop af  
b20b			endm  
# End of macro DMARK
b20b						CALLMONITOR 
b20b cd 7f 90			call break_point_state  
b20e				endm  
# End of macro CALLMONITOR
b20e					endif 
b20e			 
b20e					; get port 
b20e			 
b20e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b20e cd a4 96			call macro_dsp_valuehl 
b211				endm 
# End of macro FORTH_DSP_VALUEHL
b211			 
b211 e5					push hl 
b212			 
b212					; destroy value TOS 
b212			 
b212					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b212 cd 24 97			call macro_forth_dsp_pop 
b215				endm 
# End of macro FORTH_DSP_POP
b215			 
b215					; get byte to send 
b215			 
b215					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b215 cd a4 96			call macro_dsp_valuehl 
b218				endm 
# End of macro FORTH_DSP_VALUEHL
b218			 
b218			;		push hl 
b218			 
b218					; destroy value TOS 
b218			 
b218					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b218 cd 24 97			call macro_forth_dsp_pop 
b21b				endm 
# End of macro FORTH_DSP_POP
b21b			 
b21b					; one value on hl get other one back 
b21b			 
b21b			;		pop hl 
b21b			 
b21b c1					pop bc 
b21c			 
b21c					if DEBUG_FORTH_WORDS 
b21c						DMARK "OUT" 
b21c						CALLMONITOR 
b21c					endif 
b21c			 
b21c ed 69				out (c), l 
b21e			 
b21e					NEXTW 
b21e c3 de 97			jp macro_next 
b221				endm 
# End of macro NEXTW
b221			 
b221			 
b221			.SPIO: 
b221			 
b221			if STORAGE_SE 
b221				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
b221			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
b221			 
b221					call spi_ce_low 
b221			    NEXTW 
b221			 
b221			.SPICEH: 
b221				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
b221			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
b221			 
b221					call spi_ce_high 
b221			    NEXTW 
b221			 
b221			 
b221			.SPIOb: 
b221			 
b221				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
b221			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
b221			 
b221					; get port 
b221			 
b221			 
b221					; get byte to send 
b221			 
b221					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b221			 
b221			;		push hl    ; u1  
b221			 
b221					; destroy value TOS 
b221			 
b221					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b221			 
b221					; one value on hl get other one back 
b221			 
b221			;		pop hl   ; u2 - addr 
b221			 
b221					; TODO Send SPI byte 
b221			 
b221					ld a, l 
b221					call spi_send_byte 
b221			 
b221					NEXTW 
b221			 
b221			.SPII: 
b221				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
b221			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
b221			 
b221					; TODO Get SPI byte 
b221			 
b221					call spi_read_byte 
b221			 
b221					ld h, 0 
b221					ld l, a 
b221					call forth_push_numhl 
b221			 
b221					NEXTW 
b221			 
b221			 
b221			 
b221			.SESEL: 
b221				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
b221			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
b221					if DEBUG_FORTH_WORDS_KEY 
b221						DMARK "BNK" 
b221						CALLMONITOR 
b221					endif 
b221			 
b221					ld a, 255 
b221					ld (spi_cartdev), a 
b221			 
b221					; get bank 
b221			 
b221					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b221			 
b221			;		push hl 
b221			 
b221					; destroy value TOS 
b221			 
b221					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b221			 
b221					; one value on hl get other one back 
b221			 
b221			;		pop hl 
b221			 
b221			 
b221					ld c, SPI_CE_HIGH 
b221			 
b221					ld a, l 
b221			 
b221					if DEBUG_FORTH_WORDS 
b221						DMARK "BNK" 
b221						CALLMONITOR 
b221					endif 
b221			 
b221					; active low 
b221			 
b221					cp 0 
b221					jr z, .bset 
b221					cp 1 
b221					jr nz, .b2 
b221					res 0, c 
b221			.b2:		cp 2 
b221					jr nz, .b3 
b221					res 1, c 
b221			.b3:		cp 3 
b221					jr nz, .b4 
b221					res 2, c 
b221			.b4:		cp 4 
b221					jr nz, .b5 
b221					res 3, c 
b221			.b5:		cp 5 
b221					jr nz, .bset 
b221					res 4, c 
b221			 
b221			.bset: 
b221					ld a, c 
b221					ld (spi_device),a 
b221					if DEBUG_FORTH_WORDS 
b221						DMARK "BN2" 
b221						CALLMONITOR 
b221					endif 
b221			 
b221					NEXTW 
b221			 
b221			.CARTDEV: 
b221				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
b221			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
b221					if DEBUG_FORTH_WORDS_KEY 
b221						DMARK "CDV" 
b221						CALLMONITOR 
b221					endif 
b221			 
b221					; disable se storage bank selection 
b221			 
b221					ld a, SPI_CE_HIGH		; ce high 
b221					ld (spi_device), a 
b221			 
b221					; get bank 
b221			 
b221					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b221			 
b221			;		push hl 
b221			 
b221					; destroy value TOS 
b221			 
b221					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b221			 
b221					; one value on hl get other one back 
b221			 
b221			;		pop hl 
b221			 
b221					; active low 
b221			 
b221					ld c, 255 
b221			 
b221					ld a, l 
b221					if DEBUG_FORTH_WORDS 
b221						DMARK "CDV" 
b221						CALLMONITOR 
b221					endif 
b221					cp 0 
b221					jr z, .cset 
b221					cp 1 
b221					jr nz, .c2 
b221					res 0, c 
b221			.c2:		cp 2 
b221					jr nz, .c3 
b221					res 1, c 
b221			.c3:		cp 3 
b221					jr nz, .c4 
b221					res 2, c 
b221			.c4:		cp 4 
b221					jr nz, .c5 
b221					res 3, c 
b221			.c5:		cp 5 
b221					jr nz, .c6 
b221					res 4, c 
b221			.c6:		cp 6 
b221					jr nz, .c7 
b221					res 5, c 
b221			.c7:		cp 7 
b221					jr nz, .c8 
b221					res 6, c 
b221			.c8:		cp 8 
b221					jr nz, .cset 
b221					res 7, c 
b221			.cset:		ld a, c 
b221					ld (spi_cartdev),a 
b221			 
b221					if DEBUG_FORTH_WORDS 
b221						DMARK "CD2" 
b221						CALLMONITOR 
b221					endif 
b221					NEXTW 
b221			endif 
b221			 
b221			.ENDDEVICE: 
b221			; eof 
b221			 
# End of file forth_words_device.asm
b221			 
b221			; var handler 
b221			 
b221			 
b221			.VARS: 
b221				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
b221 78				db WORD_SYS_CORE+100             
b222 39 b2			dw .V0Q            
b224 04				db 3 + 1 
b225 .. 00			db "V0!",0              
b229				endm 
# End of macro CWHEAD
b229			;| V0! ( u1 -- )  Store value to v0  | DONE 
b229			 
b229					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b229 cd a4 96			call macro_dsp_valuehl 
b22c				endm 
# End of macro FORTH_DSP_VALUEHL
b22c			 
b22c 11 28 eb				ld de, cli_var_array 
b22f			 
b22f eb					ex de, hl 
b230 73					ld (hl), e 
b231 23					inc hl 
b232 72					ld (hl), d 
b233			 
b233					; destroy value TOS 
b233			 
b233					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b233 cd 24 97			call macro_forth_dsp_pop 
b236				endm 
# End of macro FORTH_DSP_POP
b236			 
b236				       NEXTW 
b236 c3 de 97			jp macro_next 
b239				endm 
# End of macro NEXTW
b239			.V0Q: 
b239				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
b239 79				db WORD_SYS_CORE+101             
b23a 4a b2			dw .V1S            
b23c 04				db 3 + 1 
b23d .. 00			db "V0@",0              
b241				endm 
# End of macro CWHEAD
b241			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
b241 2a 28 eb				ld hl, (cli_var_array) 
b244 cd 09 96				call forth_push_numhl 
b247			 
b247				       NEXTW 
b247 c3 de 97			jp macro_next 
b24a				endm 
# End of macro NEXTW
b24a			.V1S: 
b24a				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
b24a 7a				db WORD_SYS_CORE+102             
b24b 62 b2			dw .V1Q            
b24d 04				db 3 + 1 
b24e .. 00			db "V1!",0              
b252				endm 
# End of macro CWHEAD
b252			;| V1! ( u1 -- )  Store value to v1 | DONE 
b252					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b252 cd a4 96			call macro_dsp_valuehl 
b255				endm 
# End of macro FORTH_DSP_VALUEHL
b255			 
b255 11 2a eb				ld de, cli_var_array+2 
b258				 
b258 eb					ex de, hl 
b259 73					ld (hl), e 
b25a 23					inc hl 
b25b 72					ld (hl), d 
b25c			 
b25c					; destroy value TOS 
b25c			 
b25c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b25c cd 24 97			call macro_forth_dsp_pop 
b25f				endm 
# End of macro FORTH_DSP_POP
b25f				       NEXTW 
b25f c3 de 97			jp macro_next 
b262				endm 
# End of macro NEXTW
b262			.V1Q: 
b262				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
b262 7b				db WORD_SYS_CORE+103             
b263 73 b2			dw .V2S            
b265 04				db 3 + 1 
b266 .. 00			db "V1@",0              
b26a				endm 
# End of macro CWHEAD
b26a			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
b26a 2a 2a eb				ld hl, (cli_var_array+2) 
b26d cd 09 96				call forth_push_numhl 
b270				       NEXTW 
b270 c3 de 97			jp macro_next 
b273				endm 
# End of macro NEXTW
b273			.V2S: 
b273				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
b273 7c				db WORD_SYS_CORE+104             
b274 8b b2			dw .V2Q            
b276 04				db 3 + 1 
b277 .. 00			db "V2!",0              
b27b				endm 
# End of macro CWHEAD
b27b			;| V2! ( u1 -- )  Store value to v2 | DONE 
b27b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b27b cd a4 96			call macro_dsp_valuehl 
b27e				endm 
# End of macro FORTH_DSP_VALUEHL
b27e			 
b27e 11 2c eb				ld de, cli_var_array+4 
b281				 
b281 eb					ex de, hl 
b282 73					ld (hl), e 
b283 23					inc hl 
b284 72					ld (hl), d 
b285			 
b285					; destroy value TOS 
b285			 
b285					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b285 cd 24 97			call macro_forth_dsp_pop 
b288				endm 
# End of macro FORTH_DSP_POP
b288				       NEXTW 
b288 c3 de 97			jp macro_next 
b28b				endm 
# End of macro NEXTW
b28b			.V2Q: 
b28b				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
b28b 7d				db WORD_SYS_CORE+105             
b28c 9c b2			dw .V3S            
b28e 04				db 3 + 1 
b28f .. 00			db "V2@",0              
b293				endm 
# End of macro CWHEAD
b293			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
b293 2a 2c eb				ld hl, (cli_var_array+4) 
b296 cd 09 96				call forth_push_numhl 
b299				       NEXTW 
b299 c3 de 97			jp macro_next 
b29c				endm 
# End of macro NEXTW
b29c			.V3S: 
b29c				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
b29c 7c				db WORD_SYS_CORE+104             
b29d b4 b2			dw .V3Q            
b29f 04				db 3 + 1 
b2a0 .. 00			db "V3!",0              
b2a4				endm 
# End of macro CWHEAD
b2a4			;| V3! ( u1 -- )  Store value to v3 | DONE 
b2a4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2a4 cd a4 96			call macro_dsp_valuehl 
b2a7				endm 
# End of macro FORTH_DSP_VALUEHL
b2a7			 
b2a7 11 2e eb				ld de, cli_var_array+6 
b2aa				 
b2aa eb					ex de, hl 
b2ab 73					ld (hl), e 
b2ac 23					inc hl 
b2ad 72					ld (hl), d 
b2ae			 
b2ae					; destroy value TOS 
b2ae			 
b2ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2ae cd 24 97			call macro_forth_dsp_pop 
b2b1				endm 
# End of macro FORTH_DSP_POP
b2b1				       NEXTW 
b2b1 c3 de 97			jp macro_next 
b2b4				endm 
# End of macro NEXTW
b2b4			.V3Q: 
b2b4				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
b2b4 7d				db WORD_SYS_CORE+105             
b2b5 c5 b2			dw .END            
b2b7 04				db 3 + 1 
b2b8 .. 00			db "V3@",0              
b2bc				endm 
# End of macro CWHEAD
b2bc			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
b2bc 2a 2e eb				ld hl, (cli_var_array+6) 
b2bf cd 09 96				call forth_push_numhl 
b2c2				       NEXTW 
b2c2 c3 de 97			jp macro_next 
b2c5				endm 
# End of macro NEXTW
b2c5			 
b2c5			 
b2c5			 
b2c5			 
b2c5			 
b2c5			; end of dict marker 
b2c5			 
b2c5 00			.END:    db WORD_SYS_END 
b2c6 00 00			dw 0 
b2c8 00				db 0 
b2c9			 
b2c9			; use to jp here for user dict words to save on macro expansion  
b2c9			 
b2c9			user_dict_next: 
b2c9				NEXTW 
b2c9 c3 de 97			jp macro_next 
b2cc				endm 
# End of macro NEXTW
b2cc			 
b2cc			 
b2cc			user_exec: 
b2cc				;    ld hl, <word code> 
b2cc				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
b2cc				;    call forthexec 
b2cc				;    jp user_dict_next   (NEXT) 
b2cc			        ;    <word code bytes> 
b2cc eb				ex de, hl 
b2cd 2a 76 e6			ld hl,(os_tok_ptr) 
b2d0				 
b2d0				FORTH_RSP_NEXT 
b2d0 cd b3 95			call macro_forth_rsp_next 
b2d3				endm 
# End of macro FORTH_RSP_NEXT
b2d3			 
b2d3			if DEBUG_FORTH_UWORD 
b2d3						DMARK "UEX" 
b2d3				CALLMONITOR 
b2d3			endif 
b2d3			 
b2d3			 
b2d3			 
b2d3 eb				ex de, hl 
b2d4 22 76 e6			ld (os_tok_ptr), hl 
b2d7				 
b2d7				; Don't use next - Skips the first word in uword. 
b2d7			 
b2d7 c3 6f 98			jp exec1 
b2da			;	NEXT 
b2da			 
b2da			 
b2da			; eof 
# End of file forth_wordsv4.asm
b2da			endif 
b2da			;;;;;;;;;;;;;; Debug code 
b2da			 
b2da			 
b2da			;if DEBUG_FORTH_PARSE 
b2da .. 00		.nowordfound: db "No match",0 
b2e3 .. 00		.compword:	db "Comparing word ",0 
b2f3 .. 00		.nextwordat:	db "Next word at",0 
b300 .. 00		.charmatch:	db "Char match",0 
b30b			;endif 
b30b			if DEBUG_FORTH_JP 
b30b			.foundword:	db "Word match. Exec..",0 
b30b			endif 
b30b			;if DEBUG_FORTH_PUSH 
b30b .. 00		.enddict:	db "Dict end. Push.",0 
b31b .. 00		.push_str:	db "Pushing string",0 
b32a .. 00		.push_num:	db "Pushing number",0 
b339 .. 00		.data_sp:	db "SP:",0 
b33d .. 00		.wordinhl:	db "Word in HL (2/0):",0 
b34f .. 00		.wordinde:	db "Word in DE (3/0):",0 
b361 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
b373			;endif 
b373			;if DEBUG_FORTH_MALLOC 
b373 .. 00		.push_malloc:	db "Malloc address",0 
b382			;endif 
b382			 
b382			 
b382			 
b382			; display malloc address and current data stack pointer  
b382			 
b382			malloc_error: 
b382 d5				push de 
b383 f5				push af 
b384 e5				push hl 
b385 cd 62 87			call clear_display 
b388 11 aa b3			ld de, .mallocerr 
b38b 3e 00			ld a,0 
b38d			;	ld de,os_word_scratch 
b38d cd 75 87			call str_at_display 
b390 3e 11			ld a, display_row_1+17 
b392 11 7a ee			ld de, debug_mark 
b395 cd 75 87			call str_at_display 
b398 cd 85 87			call update_display 
b39b				;call break_point_state 
b39b cd 9f c6			call cin_wait 
b39e			 
b39e 3e 20			ld a, ' ' 
b3a0 32 74 e3			ld (os_view_disable), a 
b3a3 e1				pop hl 
b3a4 f1				pop af 
b3a5 d1				pop de	 
b3a6				CALLMONITOR 
b3a6 cd 7f 90			call break_point_state  
b3a9				endm  
# End of macro CALLMONITOR
b3a9 c9				ret 
b3aa			 
b3aa .. 00		.mallocerr: 	db "Malloc Error",0 
b3b7			;if DEBUG_FORTH_PUSH 
b3b7			display_data_sp: 
b3b7 f5				push af 
b3b8			 
b3b8				; see if disabled 
b3b8			 
b3b8 3a 74 e3			ld a, (os_view_disable) 
b3bb fe 2a			cp '*' 
b3bd 28 67			jr z, .skipdsp 
b3bf			 
b3bf e5				push hl 
b3c0 e5				push hl 
b3c1 e5			push hl 
b3c2 cd 62 87			call clear_display 
b3c5 e1			pop hl 
b3c6 7c				ld a,h 
b3c7 21 7a e6			ld hl, os_word_scratch 
b3ca cd bc 8b			call hexout 
b3cd e1				pop hl 
b3ce 7d				ld a,l 
b3cf 21 7c e6			ld hl, os_word_scratch+2 
b3d2 cd bc 8b			call hexout 
b3d5 21 7e e6			ld hl, os_word_scratch+4 
b3d8 3e 00			ld a,0 
b3da 77				ld (hl),a 
b3db 11 7a e6			ld de,os_word_scratch 
b3de 3e 28				ld a, display_row_2 
b3e0 cd 75 87				call str_at_display 
b3e3 11 3d b3			ld de, .wordinhl 
b3e6 3e 00			ld a, display_row_1 
b3e8			 
b3e8 cd 75 87				call str_at_display 
b3eb 11 7a ee			ld de, debug_mark 
b3ee 3e 11			ld a, display_row_1+17 
b3f0			 
b3f0 cd 75 87				call str_at_display 
b3f3			 
b3f3				; display current data stack pointer 
b3f3 11 39 b3			ld de,.data_sp 
b3f6 3e 30				ld a, display_row_2 + 8 
b3f8 cd 75 87				call str_at_display 
b3fb			 
b3fb 2a 22 eb			ld hl,(cli_data_sp) 
b3fe e5				push hl 
b3ff 7c				ld a,h 
b400 21 7a e6			ld hl, os_word_scratch 
b403 cd bc 8b			call hexout 
b406 e1				pop hl 
b407 7d				ld a,l 
b408 21 7c e6			ld hl, os_word_scratch+2 
b40b cd bc 8b			call hexout 
b40e 21 7e e6			ld hl, os_word_scratch+4 
b411 3e 00			ld a,0 
b413 77				ld (hl),a 
b414 11 7a e6			ld de,os_word_scratch 
b417 3e 33				ld a, display_row_2 + 11 
b419 cd 75 87				call str_at_display 
b41c			 
b41c			 
b41c cd 85 87			call update_display 
b41f cd e6 86			call delay1s 
b422 cd e6 86			call delay1s 
b425 e1				pop hl 
b426			.skipdsp: 
b426 f1				pop af 
b427 c9				ret 
b428			 
b428			display_data_malloc: 
b428			 
b428 f5				push af 
b429 e5				push hl 
b42a e5				push hl 
b42b e5			push hl 
b42c cd 62 87			call clear_display 
b42f e1			pop hl 
b430 7c				ld a,h 
b431 21 7a e6			ld hl, os_word_scratch 
b434 cd bc 8b			call hexout 
b437 e1				pop hl 
b438 7d				ld a,l 
b439 21 7c e6			ld hl, os_word_scratch+2 
b43c cd bc 8b			call hexout 
b43f 21 7e e6			ld hl, os_word_scratch+4 
b442 3e 00			ld a,0 
b444 77				ld (hl),a 
b445 11 7a e6			ld de,os_word_scratch 
b448 3e 28				ld a, display_row_2 
b44a cd 75 87				call str_at_display 
b44d 11 73 b3			ld de, .push_malloc 
b450 3e 00			ld a, display_row_1 
b452			 
b452 cd 75 87				call str_at_display 
b455			 
b455				; display current data stack pointer 
b455 11 39 b3			ld de,.data_sp 
b458 3e 30				ld a, display_row_2 + 8 
b45a cd 75 87				call str_at_display 
b45d			 
b45d 2a 22 eb			ld hl,(cli_data_sp) 
b460 e5				push hl 
b461 7c				ld a,h 
b462 21 7a e6			ld hl, os_word_scratch 
b465 cd bc 8b			call hexout 
b468 e1				pop hl 
b469 7d				ld a,l 
b46a 21 7c e6			ld hl, os_word_scratch+2 
b46d cd bc 8b			call hexout 
b470 21 7e e6			ld hl, os_word_scratch+4 
b473 3e 00			ld a,0 
b475 77				ld (hl),a 
b476 11 7a e6			ld de,os_word_scratch 
b479 3e 33				ld a, display_row_2 + 11 
b47b cd 75 87				call str_at_display 
b47e			 
b47e cd 85 87			call update_display 
b481 cd e6 86			call delay1s 
b484 cd e6 86			call delay1s 
b487 e1				pop hl 
b488 f1				pop af 
b489 c9				ret 
b48a			;endif 
b48a			 
b48a			include "forth_autostart.asm" 
b48a			; list of commands to perform at system start up 
b48a			 
b48a			startcmds: 
b48a			;	dw test11 
b48a			;	dw test12 
b48a			;	dw test13 
b48a			;	dw test14 
b48a			;	dw test15 
b48a			;	dw test16 
b48a			;	dw test17 
b48a			;	dw ifthtest1 
b48a			;	dw ifthtest2 
b48a			;	dw ifthtest3 
b48a			;	dw mmtest1 
b48a			;	dw mmtest2 
b48a			;	dw mmtest3 
b48a			;	dw mmtest4 
b48a			;	dw mmtest5 
b48a			;	dw mmtest6 
b48a			;	dw iftest1 
b48a			;	dw iftest2 
b48a			;	dw iftest3 
b48a			;	dw looptest1 
b48a			;	dw looptest2 
b48a			;	dw test1 
b48a			;	dw test2 
b48a			;	dw test3 
b48a			;	dw test4 
b48a			;	dw game2r 
b48a			;	dw game2b1 
b48a			;	dw game2b2 
b48a			 
b48a				; start up words that are actually useful 
b48a			 
b48a e8 b4			dw clrstack 
b48c 1b b5			dw type 
b48e dc b6			dw stest 
b490 3f b5			dw strncpy 
b492 7d b6			dw list 
b494 a0 b5			dw start1 
b496 b2 b5			dw start2 
b498			;	dw start3 
b498 c5 b5			dw start3b 
b49a 1d b6			dw start3c 
b49c			 
b49c				; (unit) testing words 
b49c			 
b49c 53 b7			dw mtesta 
b49e 08 b8			dw mtestb 
b4a0 ab b8			dw mtestc 
b4a2 60 b9			dw mtestd 
b4a4 04 ba			dw mteste 
b4a6			 
b4a6				; demo/game words 
b4a6			 
b4a6 f7 c0		        dw game3w 
b4a8 25 c1		        dw game3p 
b4aa 43 c1		        dw game3sc 
b4ac 74 c1		        dw game3vsi 
b4ae a0 c1		        dw game3vs 
b4b0				 
b4b0 ea be			dw game2b 
b4b2 58 bf			dw game2bf 
b4b4 a2 bf			dw game2mba 
b4b6 38 c0			dw game2mbas 
b4b8 7a c0			dw game2mb 
b4ba			 
b4ba c4 bb			dw game1 
b4bc d5 bb			dw game1a 
b4be 37 bc			dw game1b 
b4c0 6c bc			dw game1c 
b4c2 a2 bc			dw game1d 
b4c4 d3 bc			dw game1s 
b4c6 e7 bc			dw game1t 
b4c8 fc bc			dw game1f 
b4ca 30 bd			dw game1z 
b4cc 74 bd			dw game1zz 
b4ce			 
b4ce ba ba			dw test5 
b4d0 f2 ba			dw test6 
b4d2 2a bb			dw test7 
b4d4 3e bb			dw test8 
b4d6 6a bb			dw test9 
b4d8 80 bb			dw test10 
b4da				 
b4da 32 be		        dw ssv5 
b4dc 16 be		        dw ssv4 
b4de fa bd		        dw ssv3 
b4e0 c4 bd		        dw ssv2 
b4e2 4b be		        dw ssv1 
b4e4 93 be		        dw ssv1cpm 
b4e6			;	dw keyup 
b4e6			;	dw keydown 
b4e6			;	dw keyleft 
b4e6			;	dw keyright 
b4e6			;	dw 	keyf1 
b4e6			;	dw keyf2 
b4e6			;	dw keyf3 
b4e6			;	dw keyf4 
b4e6			;	dw keyf5 
b4e6			;	dw keyf6 
b4e6			;	dw keyf7 
b4e6			;	dw keyf8 
b4e6			;	dw keyf9 
b4e6			;	dw keyf10 
b4e6			;	dw keyf11 
b4e6			;	dw keyf12 
b4e6			;	dw keytab 
b4e6			;	dw keycr 
b4e6			;	dw keyhome 
b4e6			;	dw keyend 
b4e6			;	dw keybs 
b4e6 00 00			db 0, 0	 
b4e8			 
b4e8			 
b4e8			; clear stack  
b4e8			 
b4e8 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
b51b			 
b51b			; type ( addr count - ) 
b51b .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
b53f			 
b53f			; some direct memory words 
b53f			; strncpy ( len t f -- t ) 
b53f			 
b53f .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
b5a0			 
b5a0 .. 00		start1:     	db ": bpon $0000 bp ;",0 
b5b2 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
b5c5			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
b5c5 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
b61d .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
b67d			 
b67d			 
b67d			; a handy word to list items on the stack 
b67d			 
b67d .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
b6dc			 
b6dc			 
b6dc			; test stack  
b6dc			; rnd8 stest 
b6dc			 
b6dc .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
b753			 
b753			; random malloc and free cycles 
b753			 
b753 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
b808			 
b808			; fixed malloc and free cycles 
b808			 
b808 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
b8ab			 
b8ab			; fixed double string push and drop cycle  
b8ab			 
b8ab .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
b960			 
b960			; consistent fixed string push and drop cycle  
b960			 
b960 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
ba04			 
ba04 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
baba			 
baba			;test1:		db ": aa 1 2 3 ;", 0 
baba			;test2:     	db "111 aa 888 999",0 
baba			;test3:     	db ": bb 77 ;",0 
baba			;test4:     	db "$02 $01 do i . loop bb",0 
baba			 
baba .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
baf2 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
bb2a .. 00		test7:     	db ": box hline vline ;",0 
bb3e .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
bb6a .. 00		test9:     	db ": sw $01 adsp world ;",0 
bb80 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
bba5 .. 00		test11:     	db "hello create .",0 
bbb4 .. 00		test12:     	db "hello2 create .",0 
bbc4			 
bbc4			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
bbc4			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
bbc4			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
bbc4			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
bbc4			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
bbc4			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
bbc4			 
bbc4			;iftest1:     	db "$0001 IF cls .",0 
bbc4			;iftest2:     	db "$0000 IF cls .",0 
bbc4			;iftest3:     	db "$0002 $0003 - IF cls .",0 
bbc4			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
bbc4			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
bbc4			 
bbc4			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
bbc4			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
bbc4			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
bbc4			 
bbc4			 
bbc4			 
bbc4			; a small guess the number game 
bbc4			 
bbc4 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
bbd5 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
bc37			 
bc37 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
bc6c .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
bca2 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
bcd3 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
bce7 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
bcfc .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
bd30 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
bd74			 
bd74			; Using 'ga' save a high score across multiple runs using external storage 
bd74			 
bd74 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> . storepage v3@ $80 bupd ;",0 
bdc4			 
bdc4			 
bdc4			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
bdc4			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
bdc4			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
bdc4			 
bdc4			; simple screen saver to test code memory reuse to destruction 
bdc4			 
bdc4 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
bdfa .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
be16 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
be32 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
be4b .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
be93 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
beea			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
beea			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
beea			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
beea			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
beea			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
beea			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
beea			 
beea			 
beea			 
beea			; minesweeper/battleship finding game 
beea			; draws a game board of random ship/mine positions 
beea			; user enters coords to see if it hits on 
beea			; game ends when all are hit 
beea			; when hit or miss says how many may be in the area 
beea			 
beea			; setup the game board and then hide it 
beea .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
bf58 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
bfa2			; prompt for where to target 
bfa2 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
c038 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
c05d			; TODO see if the entered coords hits or misses pushes char hit of miss 
c05d .. 00		game2mbht:      db ": mbckht nop ;",0 
c06c .. 00		game2mbms:      db ": mbcms nop ;",0 
c07a			; TODO how many might be near by 
c07a .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
c0f7			 
c0f7			; Game 3 
c0f7			 
c0f7			; Vert scroller ski game - avoid the trees! 
c0f7			 
c0f7			; v0 score (ie turns) 
c0f7			; v1 player pos 
c0f7			; v2 left wall 
c0f7			; v3 right wall 
c0f7			 
c0f7			; Draw side walls randomly 
c0f7			 
c0f7 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
c125			 
c125			; Draw player 
c125 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
c143			 
c143			; TODO Get Key 
c143			 
c143			; TODO Move left right 
c143			 
c143			; scroll and move walls a bit 
c143			 
c143 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
c174			 
c174			; main game loop 
c174			 
c174 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
c1a0 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
c1df			 
c1df			; key board defs 
c1df			 
c1df .. 00		keyup:       db ": keyup $05 ;",0 
c1ed .. 00		keydown:       db ": keydown $0a ;",0 
c1fd .. 00		keyleft:       db ": keyleft $0b ;",0 
c20d .. 00		keyright:       db ": keyright $0c ;",0 
c21e .. 00		keyf1:       db ": keyf1 $10 ;",0 
c22c .. 00		keyf2:       db ": keyf2 $11 ;",0 
c23a .. 00		keyf3:       db ": keyf3 $12 ;",0 
c248 .. 00		keyf4:       db ": keyf4 $13 ;",0 
c256 .. 00		keyf5:       db ": keyf5 $14 ;",0 
c264 .. 00		keyf6:       db ": keyf6 $15 ;",0 
c272 .. 00		keyf7:       db ": keyf7 $16 ;",0 
c280 .. 00		keyf8:       db ": keyf8 $17 ;",0 
c28e .. 00		keyf9:       db ": keyf9 $18 ;",0 
c29c .. 00		keyf10:       db ": keyf10 $19 ;",0 
c2ab .. 00		keyf11:       db ": keyf11 $1a ;",0 
c2ba .. 00		keyf12:       db ": keyf12 $1b ;",0 
c2c9			 
c2c9 .. 00		keytab:       db ": keytab $09 ;",0 
c2d8 .. 00		keycr:       db ": keycr $0d ;",0 
c2e6 .. 00		keyhome:       db ": keyhome $0e ;",0 
c2f6 .. 00		keyend:       db ": keyend $0f ;",0 
c305 .. 00		keybs:       db ": keybs $08 ;",0 
c313			 
c313			   
c313			 
c313			 
c313			 
c313			; eof 
# End of file forth_autostart.asm
c313			 
c313 .. 00		sprompt1: db "Startup load...",0 
c323 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
c339			 
c339			forth_startup: 
c339 21 8a b4			ld hl, startcmds 
c33c 3e 00			ld a, 0 
c33e 32 9b e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
c341			 
c341 e5			.start1:	push hl 
c342 cd 62 87			call clear_display 
c345 11 13 c3			ld de, sprompt1 
c348 3e 00		        ld a, display_row_1 
c34a cd 75 87			call str_at_display 
c34d 11 23 c3			ld de, sprompt2 
c350 3e 28		        ld a, display_row_2 
c352 cd 75 87			call str_at_display 
c355 e1				pop hl 
c356 e5				push hl 
c357 5e				ld e,(hl) 
c358 23				inc hl 
c359 56				ld d,(hl) 
c35a 3e 50		        ld a, display_row_3 
c35c cd 75 87			call str_at_display 
c35f cd 85 87			call update_display 
c362			 
c362			 
c362 3a 9b e7			ld a, (os_last_cmd) 
c365 fe 00			cp 0 
c367 28 05			jr z, .startprompt 
c369 cd da 86			call delay250ms 
c36c 18 24			jr .startdo 
c36e				 
c36e				 
c36e			 
c36e			.startprompt: 
c36e			 
c36e 3e 9f			ld a,display_row_4 + display_cols - 1 
c370 11 82 95		        ld de, endprg 
c373 cd 75 87			call str_at_display 
c376 cd 85 87			call update_display 
c379 cd e6 86			call delay1s 
c37c cd 9f c6			call cin_wait 
c37f						 
c37f fe 2a			cp '*' 
c381 28 5e			jr z, .startupend1 
c383 fe 23			cp '#' 
c385 20 07			jr nz, .startno 
c387 3e 01			ld a, 1 
c389 32 9b e7			ld (os_last_cmd),a 
c38c 18 04			jr .startdo 
c38e fe 31		.startno:	cp '1' 
c390 28 3a			jr z,.startnxt  
c392			 
c392				; exec startup line 
c392			.startdo:	 
c392 e1				pop hl 
c393 e5				push hl 
c394				 
c394 5e				ld e,(hl) 
c395 23				inc hl 
c396 56				ld d,(hl) 
c397 eb				ex de,hl 
c398			 
c398 e5				push hl 
c399			 
c399 3e 00			ld a, 0 
c39b				;ld a, FORTH_END_BUFFER 
c39b cd 24 8d			call strlent 
c39e 23				inc hl   ; include zero term to copy 
c39f 06 00			ld b,0 
c3a1 4d				ld c,l 
c3a2 e1				pop hl 
c3a3 11 75 e3			ld de, scratch 
c3a6 ed b0			ldir 
c3a8			 
c3a8			 
c3a8 21 75 e3			ld hl, scratch 
c3ab cd 2c 98			call forthparse 
c3ae cd 6c 98			call forthexec 
c3b1 cd 83 97			call forthexec_cleanup 
c3b4			 
c3b4 3e 78			ld a, display_row_4 
c3b6 11 26 93			ld de, endprog 
c3b9			 
c3b9 cd 85 87			call update_display		 
c3bc			 
c3bc 3a 9b e7			ld a, (os_last_cmd) 
c3bf fe 00			cp 0 
c3c1 20 09			jr nz, .startnxt 
c3c3 cd 84 95			call next_page_prompt 
c3c6 cd 62 87		        call clear_display 
c3c9 cd 85 87			call update_display		 
c3cc			 
c3cc				; move onto next startup line? 
c3cc			.startnxt: 
c3cc			 
c3cc cd da 86			call delay250ms 
c3cf e1				pop hl 
c3d0			 
c3d0 23				inc hl 
c3d1 23				inc hl 
c3d2			 
c3d2 e5				push hl 
c3d3 5e				ld e, (hl) 
c3d4 23				inc hl 
c3d5 56				ld d, (hl) 
c3d6 e1				pop hl 
c3d7				; TODO replace 0 test 
c3d7			 
c3d7 eb				ex de, hl 
c3d8 cd e4 88			call ishlzero 
c3db			;	ld a,e 
c3db			;	add d 
c3db			;	cp 0    ; any left to do? 
c3db eb				ex de, hl 
c3dc c2 41 c3			jp nz, .start1 
c3df 18 01			jr .startupend 
c3e1			 
c3e1 e1			.startupend1: pop hl 
c3e2			.startupend: 
c3e2			 
c3e2 cd 62 87			call clear_display 
c3e5 cd 85 87			call update_display 
c3e8 c9				ret 
c3e9			 
c3e9			 
c3e9			; stack over and underflow checks 
c3e9			 
c3e9			; init the words to detect the under/overflow 
c3e9			 
c3e9			chk_stk_init: 
c3e9				; a vague random number to check so we dont get any "lucky" hits 
c3e9 3e 2d			ld a, 45 
c3eb 6f				ld l, a 
c3ec 00				nop 
c3ed 3e 17			ld a, 23 
c3ef 67				ld h, a 
c3f0			 
c3f0 22 6a e3			ld (chk_word), hl     ; the word we need to check against 
c3f3			 
c3f3			;	ld (chk_stund), hl	; stack points.... 
c3f3 22 00 ef			ld (chk_stovr), hl 
c3f6 22 20 eb			ld (chk_ret_und), hl 
c3f9 22 de ea			ld (chk_ret_ovr), hl 
c3fc 22 dc e9			ld (chk_loop_ovr), hl 
c3ff 22 da e8			ld (chk_data_ovr), hl 
c402 c9				ret 
c403				 
c403			check_stacks: 
c403				; check all stack words 
c403			 
c403 e5				push hl 
c404 d5				push de 
c405			 
c405			;	ld de,(chk_word) 
c405			;	ld hl, (chk_stund)	; stack points.... 
c405			;	if DEBUG_STK_FAULT 
c405			;		DMARK "FAa" 
c405			;		CALLMONITOR 
c405			;	endif 
c405			;	call cmp16 
c405			;	jp z, .chk_faulta 
c405			; 
c405			;	ld de, sfaultsu 
c405			;	jp .chk_fault 
c405			 
c405 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
c408 ed 5b 6a e3		ld de,(chk_word) 
c40c				if DEBUG_STK_FAULT 
c40c					DMARK "FAb" 
c40c					CALLMONITOR 
c40c				endif 
c40c cd d9 88			call cmp16 
c40f 28 06			jr z, .chk_fault1 
c411 11 b2 c4			ld de, sfaultso 
c414 c3 66 c4			jp .chk_fault 
c417			.chk_fault1:  
c417 2a 20 eb			ld hl, (chk_ret_und) 
c41a ed 5b 6a e3		ld de,(chk_word) 
c41e				if DEBUG_STK_FAULT 
c41e					DMARK "FAU" 
c41e					CALLMONITOR 
c41e				endif 
c41e cd d9 88			call cmp16 
c421 ca 2a c4			jp z, .chk_fault2 
c424 11 c2 c4			ld de, sfaultru 
c427 c3 66 c4			jp .chk_fault 
c42a			.chk_fault2:  
c42a 2a de ea			ld hl, (chk_ret_ovr) 
c42d ed 5b 6a e3		ld de,(chk_word) 
c431				if DEBUG_STK_FAULT 
c431					DMARK "FA1" 
c431					CALLMONITOR 
c431				endif 
c431 cd d9 88			call cmp16 
c434 ca 3d c4			jp z, .chk_fault3 
c437 11 d0 c4			ld de, sfaultro 
c43a c3 66 c4			jp .chk_fault 
c43d			.chk_fault3:  
c43d 2a dc e9			ld hl, (chk_loop_ovr) 
c440 ed 5b 6a e3		ld de,(chk_word) 
c444				if DEBUG_STK_FAULT 
c444					DMARK "FA2" 
c444					CALLMONITOR 
c444				endif 
c444 cd d9 88			call cmp16 
c447 ca 50 c4			jp z, .chk_fault4 
c44a 11 ea c4			ld de, sfaultlo 
c44d c3 66 c4			jp .chk_fault 
c450			.chk_fault4:  
c450 2a da e8			ld hl, (chk_data_ovr) 
c453 ed 5b 6a e3		ld de,(chk_word) 
c457				if DEBUG_STK_FAULT 
c457					DMARK "FA3" 
c457					CALLMONITOR 
c457				endif 
c457 cd d9 88			call cmp16 
c45a ca 63 c4			jp z, .chk_fault5 
c45d 11 04 c5			ld de, sfaultdo 
c460 c3 66 c4			jp .chk_fault 
c463			 
c463			 
c463			.chk_fault5:  
c463 d1				pop de 
c464 e1				pop hl 
c465			 
c465 c9				ret 
c466			 
c466 cd 62 87		.chk_fault: 	call clear_display 
c469 3e 28				ld a, display_row_2 
c46b cd 75 87				call str_at_display 
c46e 11 94 c4				   ld de, .stackfault 
c471 3e 00				ld a, display_row_1 
c473 cd 75 87				call str_at_display 
c476 11 7a ee				    ld de, debug_mark 
c479 3e 11				ld a, display_row_1+17 
c47b cd 75 87				call str_at_display 
c47e cd 85 87				call update_display 
c481			 
c481				; prompt before entering montior for investigating issue 
c481			 
c481 3e 78			ld a, display_row_4 
c483 11 26 93			ld de, endprog 
c486			 
c486 cd 85 87			call update_display		 
c489			 
c489 cd 84 95			call next_page_prompt 
c48c			 
c48c d1				pop de 
c48d e1				pop hl 
c48e cd 7a 93				call monitor 
c491 c3 74 92				jp warmstart 
c494					;jp 0 
c494					;halt 
c494			 
c494			 
c494			 
c494 .. 00		.stackfault: 	db "Stack fault:",0 
c4a1			 
c4a1 .. 00		sfaultsu: 	db	"Stack under flow",0 
c4b2 .. 00		sfaultso: 	db	"Stack over flow",0 
c4c2 .. 00		sfaultru:	db "RTS underflow",0 
c4d0 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
c4ea .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
c504 .. 00		sfaultdo:	db "DTS overflow", 0 
c511			 
c511			 
c511			fault_dsp_under: 
c511 11 23 c5			ld de, .dsp_under 
c514 c3 d3 c5			jp .show_fault 
c517			 
c517			fault_rsp_under: 
c517 11 31 c5			ld de, .rsp_under 
c51a c3 d3 c5			jp .show_fault 
c51d			fault_loop_under: 
c51d 11 3f c5			ld de, .loop_under 
c520 c3 d3 c5			jp .show_fault 
c523			 
c523 .. 00		.dsp_under: db "DSP Underflow",0 
c531 .. 00		.rsp_under: db "RSP Underflow",0 
c53f .. 00		.loop_under: db "LOOP Underflow",0 
c54e			 
c54e			 
c54e d5			type_faultn: 	push de 
c54f e5					push hl 
c550 cd 62 87				call clear_display 
c553 11 7a c5				   ld de, .typefaultn 
c556 3e 00				ld a, display_row_1 
c558 cd 75 87				call str_at_display 
c55b 11 7a ee				    ld de, debug_mark 
c55e 3e 11				ld a, display_row_1+17 
c560 cd 75 87				call str_at_display 
c563 cd 85 87				call update_display 
c566			 
c566				; prompt before entering montior for investigating issue 
c566			 
c566 3e 78			ld a, display_row_4 
c568 11 26 93			ld de, endprog 
c56b			 
c56b cd 85 87			call update_display		 
c56e			 
c56e cd 84 95			call next_page_prompt 
c571			 
c571 e5					push hl 
c572 d5					push de 
c573 cd 7a 93				call monitor 
c576 c3 74 92				jp warmstart 
c579 76					halt 
c57a			 
c57a			 
c57a .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
c591			 
c591 d5			type_faults: 	push de 
c592 e5					push hl 
c593 cd 62 87				call clear_display 
c596 11 bc c5				   ld de, .typefaults 
c599 3e 00				ld a, display_row_1 
c59b cd 75 87				call str_at_display 
c59e 11 7a ee				    ld de, debug_mark 
c5a1 3e 11				ld a, display_row_1+17 
c5a3 cd 75 87				call str_at_display 
c5a6 cd 85 87				call update_display 
c5a9			 
c5a9				; prompt before entering montior for investigating issue 
c5a9			 
c5a9 3e 78			ld a, display_row_4 
c5ab 11 26 93			ld de, endprog 
c5ae			 
c5ae cd 85 87			call update_display		 
c5b1			 
c5b1 cd 84 95			call next_page_prompt 
c5b4			 
c5b4 e1					pop hl 
c5b5 d1					pop de 
c5b6 cd 7a 93				call monitor 
c5b9 c3 74 92				jp warmstart 
c5bc			 
c5bc			 
c5bc .. 00		.typefaults: db "STR Type Expected TOS!",0 
c5d3			 
c5d3			.show_fault: 	 
c5d3 d5					push de 
c5d4 cd 62 87				call clear_display 
c5d7 d1					pop de 
c5d8 3e 00				ld a, display_row_1 
c5da cd 75 87				call str_at_display 
c5dd 11 7a ee				    ld de, debug_mark 
c5e0 3e 11				ld a, display_row_1+17 
c5e2 cd 75 87				call str_at_display 
c5e5 cd 85 87				call update_display 
c5e8			 
c5e8				; prompt before entering montior for investigating issue 
c5e8			 
c5e8 3e 78			ld a, display_row_4 
c5ea 11 26 93			ld de, endprog 
c5ed			 
c5ed cd 85 87			call update_display		 
c5f0			 
c5f0 cd 84 95			call next_page_prompt 
c5f3			 
c5f3 e1					pop hl 
c5f4 d1					pop de 
c5f5 cd 7a 93				call monitor 
c5f8			; do a dump to cli and not warmstart so we preserve all of the uwords.  
c5f8			; TODO Make optional fault restart to cli or warm boot? 
c5f8					;jp warmstart 
c5f8 c3 cc 92				jp cli 
c5fb 76					halt 
c5fc			; eof 
# End of file forth_kernel.asm
c5fc			;include "nascombasic.asm" 
c5fc			 
c5fc			 
c5fc			; find out where the code ends if loaded into RAM (for SC114) 
c5fc			;endofcode:  
c5fc			;	nop 
c5fc			 
c5fc			 
c5fc			; eof 
c5fc			 
# End of file main.asm
c5fc			;include "firmware_lcd_4x40.asm" 
c5fc			;;include "firmware_lcd_4x20.asm" 
c5fc			include "firmware_serial_display.asm" 
c5fc			 
c5fc			; Serial display interface for SC114 
c5fc			 
c5fc			 
c5fc			display_row_1: equ 0 
c5fc			display_row_2: equ display_row_1+display_cols 
c5fc			display_row_3: equ display_row_2 + display_cols 
c5fc			display_row_4: equ display_row_3 + display_cols 
c5fc			 
c5fc			kLCDWidth:  EQU display_cols             ;Width in characters 
c5fc			kLCD_Line1: EQU 0x00  
c5fc			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
c5fc			; E1 
c5fc			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
c5fc			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
c5fc			 
c5fc			lcd_init: 
c5fc				; no init as handled by the SCM bios 
c5fc c9				ret 
c5fd			 
c5fd			 
c5fd			; low level functions for direct screen writes 
c5fd			 
c5fd			; output char at pos? 
c5fd			fLCD_Str: 
c5fd			        ;out (SC114_SIO_1_OUT),a 
c5fd c5				push bc 
c5fe 0e 02			ld c, $02 
c600 f7				rst $30 
c601 c1				pop bc 
c602 c9				ret 
c603			 
c603			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
c603			fLCD_Pos: 
c603				; use ASCII escape to position 
c603			        ;out (SC114_SIO_1_OUT),a 
c603 c5				push bc 
c604 0e 02			ld c, $02 
c606 f7				rst $30 
c607 c1				pop bc 
c608			 
c608 c9				ret 
c609			 
c609			; output char at pos 
c609			fLCD_Data: 
c609			      ;  out (SC114_SIO_1_OUT),a 
c609 c5				push bc 
c60a 0e 02			ld c, $02 
c60c f7				rst $30 
c60d c1				pop bc 
c60e			 
c60e c9				ret 
c60f			 
c60f			; ascii cls  
c60f			 
c60f 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
c613			 
c613			; write the frame buffer given in hl to hardware  
c613			write_display: 
c613			 
c613			API: equ 0 
c613			 
c613			if API 
c613				push bc 
c613				ld b, 4 
c613			 
c613			        ld (display_write_tmp), hl 	  
c613			 
c613				; clear and home cursor 
c613			 
c613				ld c, 6 
c613				ld de, .cls 
c613				rst $30 
c613			 
c613			 
c613			.writeln: 
c613			 
c613				ld de, (display_write_tmp) 
c613				ld c, 6 
c613				rst $30 
c613				ld c, 7 
c613				rst $30 
c613			 
c613				ld hl, (display_write_tmp) 
c613				ld de, display_cols 
c613				add hl,de 
c613				ld (display_write_tmp),hl 
c613			 
c613				djnz  .writeln 
c613			 
c613				pop bc 
c613			 
c613			 
c613				ret 
c613			endif 
c613 e5				push hl 
c614 c5				push bc 
c615 d5				push de 
c616			 
c616			;	ld c, 2 
c616			;	;ld de, .cls 
c616			;	ld a, 27 
c616			;	rst $30 
c616			;	ld c, 2 
c616			;	;ld de, .cls 
c616			;	ld a, '[' 
c616			;	rst $30 
c616			; 
c616			;	ld c, 2 
c616			;	;ld de, .cls 
c616			;	ld a, 'H' 
c616			;	rst $30 
c616			; 
c616			 
c616 0e 02			ld c, 2 
c618				;ld de, .cls 
c618 3e 1b			ld a, 27 
c61a f7				rst $30 
c61b			 
c61b			 
c61b 0e 02			ld c, 2 
c61d				;ld de, .cls 
c61d 3e 5b			ld a, '[' 
c61f f7				rst $30 
c620 0e 02			ld c, 2 
c622				;ld de, .cls 
c622 3e 32			ld a, '2' 
c624 f7				rst $30 
c625 0e 02			ld c, 2 
c627				;ld de, .cls 
c627 3e 4a			ld a, 'J' 
c629 f7				rst $30 
c62a d1				pop de 
c62b c1				pop bc 
c62c e1				pop hl 
c62d			 
c62d			 
c62d 22 d8 eb		        ld (display_write_tmp), hl 	  
c630 3e 00			ld a, kLCD_Line1 
c632			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
c632 06 28			ld b, display_cols 
c634 ed 5b d8 eb		ld de, (display_write_tmp) 
c638 cd 96 c6			call write_len_string 
c63b				 
c63b			 
c63b e5			push hl 
c63c d5			push de 
c63d c5			push bc 
c63e 0e 07			ld c, 7 
c640 f7				rst $30 
c641 c1			pop bc 
c642 d1			pop de 
c643 e1			pop hl 
c644			 
c644				 
c644 2a d8 eb			ld hl, (display_write_tmp) 
c647 11 28 00			ld de, display_cols 
c64a 19				add hl,de 
c64b 22 d8 eb			ld (display_write_tmp),hl 
c64e			 
c64e				 
c64e 3e 28			ld a, kLCD_Line2 
c650			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
c650 06 28			ld b, display_cols 
c652 ed 5b d8 eb		ld de, (display_write_tmp) 
c656 cd 96 c6			call write_len_string 
c659				 
c659 2a d8 eb			ld hl, (display_write_tmp) 
c65c 11 28 00			ld de, display_cols 
c65f 19				add hl,de 
c660 22 d8 eb			ld (display_write_tmp),hl 
c663			 
c663 e5			push hl 
c664 d5			push de 
c665 c5			push bc 
c666 0e 07			ld c, 7 
c668 f7				rst $30 
c669 c1			pop bc 
c66a d1			pop de 
c66b e1			pop hl 
c66c			 
c66c				 
c66c 3e 50			ld a, kLCD_Line3 
c66e			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
c66e 06 28			ld b, display_cols 
c670 ed 5b d8 eb		ld de, (display_write_tmp) 
c674 cd 96 c6			call write_len_string 
c677				 
c677 2a d8 eb			ld hl, (display_write_tmp) 
c67a 11 28 00			ld de, display_cols 
c67d 19				add hl,de 
c67e 22 d8 eb			ld (display_write_tmp),hl 
c681			 
c681 e5			push hl 
c682 d5			push de 
c683 c5			push bc 
c684 0e 07			ld c, 7 
c686 f7				rst $30 
c687 c1			pop bc 
c688 d1			pop de 
c689 e1			pop hl 
c68a			 
c68a				 
c68a 3e 78			ld a, kLCD_Line4 
c68c			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
c68c 06 28			ld b, display_cols 
c68e ed 5b d8 eb		ld de, (display_write_tmp) 
c692 cd 96 c6			call write_len_string 
c695 c9					ret 
c696			 
c696			 
c696				; write out a fixed length string given in b from de 
c696			 
c696 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
c697 cd 09 c6		            CALL fLCD_Data      ;Write character to display 
c69a 13				inc de 
c69b 10 f9			djnz write_len_string 
c69d c9				ret 
c69e			 
c69e			 
c69e			; eof 
# End of file firmware_serial_display.asm
c69e			;include "firmware_key_5x10.asm" 
c69e			;;include "firmware_key_4x10.asm" 
c69e			include "firmware_key_serial.asm" 
c69e			; Serial keyboard interface for SC114 
c69e			 
c69e			key_init: 
c69e				; no init as handled by the SCM bios 
c69e c9				ret 
c69f			 
c69f			 
c69f			cin_wait: 
c69f			;	ld a, 0 
c69f			;	ret 
c69f			 
c69f				;in a,(SC114_SIO_1_IN) 
c69f			        ; Use SCM API to get from whatever console device we are using 
c69f c5				push bc 
c6a0 0e 01			ld c, $01 
c6a2 f7				rst $30 
c6a3 c1				pop bc 
c6a4 c9				ret 
c6a5			 
c6a5			cin: 
c6a5			 
c6a5			 
c6a5 c5				push bc 
c6a6			 
c6a6				; any key waiting to process? 
c6a6 0e 03			ld c, $03 
c6a8 f7				rst $30 
c6a9 28 05			jr z, .cin_skip 
c6ab			 
c6ab				; yep, get it 
c6ab			 
c6ab 0e 01			ld c, $01 
c6ad f7				rst $30 
c6ae c1				pop bc 
c6af c9				ret 
c6b0			.cin_skip: 
c6b0 3e 00			ld a, 0 
c6b2 c1				pop bc 
c6b3 c9				ret 
c6b4			 
c6b4			 
c6b4			 
c6b4			 
# End of file firmware_key_serial.asm
c6b4			endofcode:  
c6b4			baseram:  
c6b4 00				nop 
c6b5			 
c6b5			heap_start: equ baseram+15  ; Starting address of heap 
c6b5			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
c6b5			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
c6b5			;VDU:  EQU     endofcode           ; BASIC Work space 
c6b5			; eof 
c6b5			 
# End of file os_mega_sc114.asm
c6b5
