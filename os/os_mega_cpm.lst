# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 7a 17			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 ..			buildtime: db   "Build: " 
010a					include "romtimestamp.asm" 
010a ..			db '2025-08-09 10:42' 
# End of file romtimestamp.asm
011a 00				   db 0 
011b			 
011b			 
011b			 
011b			;        nop  
011b			;        nop 
011b			;;	org 05h		; null out bdos call 
011b			; 
011b			;        nop  
011b			;        nop  
011b			;        nop 
011b			;;	org 08h 
011b			;;; 
011b			;;	jp cin		; rst 8 - char in 
011b			;;; 
011b			; 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;	org 010h 
011b			;; 
011b			;	jp cout		; rest 010h  - char out 
011b			;; 
011b			;	org 01bh   
011b			; 
011b			;	;jp  		; rst 01bh   - write string to display 
011b			;	jp str_at_display 
011b			; 
011b			; 
011b			;	org 020h 
011b			; 
011b			;	; jp		 ; rst 020h - read char at screen location 
011b			; 
011b			;	org 028h 
011b			 
011b				; jp		 ; rst 028h  - storage i/o 
011b			 
011b			; 	org 030h 
011b			;	jp break_point_state 
011b			  
011b			; $30  
011b			; org 038h 
011b			; $38 
011b			 
011b			; TODO any more important entry points to add to jump table for easier coding use? 
011b			 
011b			if BASE_KEV = 1  
011b			 
011b				; need to be at $66 for nmi support 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255 
011b				jp nmi 
011b			endif 
011b			 
011b			include "firmware.asm" 
011b			  
011b			; main constants (used here and in firmware)  
011b			  
011b			; TODO have page 0 of storage as bios  
011b			  
011b			Device_A: equ 0h  
011b			Device_B: equ 040h          ; Sound  
011b			  
011b			if BASE_KEV  
011b			Device_C: equ 080h          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			if BASE_SC114  
011b			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			if BASE_CPM  
011b			; TODO fixup for CPM  
011b			Device_C: equ 080h          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			Device_D: equ 0c0h             ; Keyboard and LCD  
011b			  
011b			; Odd specific debug points for testing hardware dev  
011b			  
011b			DEBUG_SOUND: equ 0       
011b			DEBUG_STK_FAULT: equ 0  
011b			DEBUG_INPUT: equ 0     ; Debug input entry code  
011b			DEBUG_INPUTV2: equ 0     ; Debug input entry code  
011b			DEBUG_KEYCINWAIT: equ 0  
011b			DEBUG_KEYCIN: equ 0  
011b			DEBUG_KEY: equ 0  
011b			DEBUG_KEY_MATRIX: equ 0  
011b			DEBUG_STORECF: equ 0  
011b			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011b			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011b			DEBUG_SPI: equ 0    ; low level spi tests  
011b			  
011b			; Enable many break points  
011b			  
011b			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011b			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011b			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011b			DEBUG_FORTH_JP: equ 0    ; 4  
011b			DEBUG_FORTH_MALLOC: equ 0  
011b			DEBUG_FORTH_MALLOC_INT: equ 0  
011b			DEBUG_FORTH_DOT: equ 1  
011b			DEBUG_FORTH_DOT_WAIT: equ 0  
011b			DEBUG_FORTH_MATHS: equ 0  
011b			DEBUG_FORTH_TOK: equ 0    ; 4  
011b			DEBUG_FORTH_PARSE: equ 0    ; 3  
011b			DEBUG_FORTH: equ 0  ;2  
011b			DEBUG_FORTH_WORDS: equ 1   ; 1  
011b			DEBUG_FORTH_PUSH: equ 1   ; 1  
011b			DEBUG_FORTH_UWORD: equ 1   ; 1  
011b			  
011b			; Enable key point breakpoints  
011b			  
011b			DEBUG_FORTH_DOT_KEY: equ 0  
011b			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011b			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011b			  
011b			; Debug stack imbalances  
011b			  
011b			ON: equ 1  
011b			OFF: equ 0  
011b			  
011b			DEBUG_STACK_IMB: equ 0  
011b			STACK_IMB_STORE: equ 20  
011b			  
011b			; House keeping and protections  
011b			  
011b			DEBUG_FORTH_STACK_GUARD: equ 1  
011b			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011b			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011b			FORTH_ENABLE_FREE: equ 0  
011b			FORTH_ENABLE_MALLOCFREE: equ 1  
011b			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011b			FORTH_ENABLE_FLOATMATH: equ 0  
011b			  
011b			  
011b			CALLMONITOR: macro  
011b			;	call break_point_state  
011b			; now use the break point debug vector  
011b				call debug_vector  
011b				endm  
011b			  
011b			MALLOC_1: equ 1        ; from dk88   
011b			MALLOC_2: equ 0           ; broke  
011b			MALLOC_3: equ 0           ; really broke  
011b			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011b			  
011b			if BASE_KEV   
011b			;stacksize: equ 256  
011b			; each stack entry is three bytes (type + word)  
011b			stacksize: equ 3*150  
011b			  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 512  
011b			endif  
011b			if BASE_SC114  
011b			;tos:	equ 0f000h  
011b			stacksize: equ 256  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 256  
011b			endif  
011b			  
011b			if BASE_CPM  
011b			;tos:	equ 0f000h  
011b			stacksize: equ 256  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 256  
011b			endif  
011b			  
011b			;if STORAGE_SE == 0  
011b			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011b			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011b			;endif  
011b			  
011b			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011b			  
011b			STORE_0_AUTORUN: equ $20  
011b			  
011b			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011b			  
011b			STORE_0_AUTOFILE: equ $21  
011b			STORE_0_BANKRUN: equ $23  
011b			STORE_0_FILERUN: equ $24  
011b			  
011b			; Block 0 offsets for settings  
011b			  
011b			; if set then skip prompt for start up and accept all  
011b			  
011b			STORE_0_QUICKSTART: equ $25  
011b			  
011b			; Blocks where directory table is held  
011b			  
011b			; Reducing the number of entries increases the max file size  
011b			  
011b			;STORE_DIR_START: equ 1  
011b			;STORE_DIR_END: equ 33  
011b			  
011b			; Blocks from where file data is stored  
011b			  
011b			;STORE_DATA_START: equ STORE_DIR_END + 1  
011b			  
011b			; Block indicators (<32 are data files)  
011b			  
011b			;STORE_BLOCK_CFG: equ $8f       ; config block  
011b			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011b			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011b			;STORE_BLOCK_FREE: equ $85       ; data block free  
011b			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011b			  
011b			  
011b			  
011b			; Directory entry flags  
011b			  
011b			;STORE_DIR_FREE: equ 0  
011b			;STORE_DIR_FILE:  equ 1  
011b			  
011b			; Structure offsets to directory entries  
011b			;STORE_DE_FLAG: equ 0  
011b			;STORE_DE_MAXEXT: equ 1  
011b			;STORE_DE_FILENAME: equ 2  
011b			  
011b			; Structure offsets to block 0  
011b			  
011b			;STORE_BK0_ISFOR: equ 1  
011b			;STORE_BK0_LABEL: equ 3  
011b			  
011b			; memory allocation   
011b			  
011b			chk_stund: equ tos+2           ; underflow check word  
011b			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011b			  
011b			; keyscan table needs rows x cols buffer  
011b			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011b			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011b			  
011b			keyscan_table_row1: equ chk_stovr -key_cols-1  
011b			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011b			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011b			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011b			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011b			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011b			keyscan_scancol: equ keyscan_table-key_cols  
011b			;keyscan_table_len: equ key_rows*key_cols  
011b			;keybufptr: equ keyscan_table - 2  
011b			;keysymbol: equ keybufptr - 1  
011b			key_held: equ keyscan_scancol-1	; currently held  
011b			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011b			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011b			key_fa: equ key_repeat_ct -1 ;  
011b			key_fb: equ key_fa -1 ;  
011b			key_fc: equ key_fb -1 ;  
011b			key_fd: equ key_fc -1 ;  
011b			key_face_held: equ key_fd - 1   
011b			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011b			  
011b			hardware_config: equ key_face_held - 10  
011b			  
011b			; hardware config switches  
011b			; TODO add bitmasks on includes for hardware  
011b			; high byte for expansion ids  
011b			;     0000 0000  no card inserted  
011b			;     0000 0001  storage card inserted  
011b			;     0000 0010  spi sd card active  
011b			  
011b			;       
011b			; low byte:  
011b			;     0000 0001   4x4 keypad  
011b			;     0000 0010   full keyboard  
011b			;     0000 0011   spi/ext keyboard  
011b			;     0000 0100   20x4 lcd  
011b			;     0000 1000   40x4 lcd  
011b			;     0000 1100   spi/ext display  
011b			;     0001 0000   ide interface available  
011b			  
011b			hardware_word: equ hardware_config - 2  
011b			  
011b			; debug marker - optional display of debug point on the debug screens  
011b			  
011b			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011b			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011b			  
011b			debug_mark: equ debug_vector - 4  
011b			  
011b			; input_str vars  
011b			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011b			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011b			input_size: equ input_start -1  ; number of chars  
011b			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011b			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011b			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011b			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011b			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011b			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011b			input_len: equ input_cur_onoff - 5 ; length of current input  
011b			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011b			  
011b			; cursor blink rate  
011b			CUR_BLINK_RATE: equ $09  
011b			;CUR_BLINK_RATE: equ 15  
011b			  
011b			key_actual_pressed: equ input_cursor - 1   
011b			key_symbol: equ key_actual_pressed - 1   
011b			key_shift: equ key_symbol - 1   
011b			  
011b			; Display allocation  
011b			  
011b			;display_rows: equ 4     ; move out to mini and mega files  
011b			;display_cols: equ 20  
011b			  
011b			display_fb_len: equ display_rows*display_cols  
011b			  
011b			; primary frame buffer     
011b			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011b			; working frame buffers  
011b			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011b			display_fb3: equ  display_fb1-display_fb_len - 1  
011b			display_fb2: equ  display_fb3-display_fb_len - 1  
011b			;  
011b			; pointer to active frame buffer  
011b			display_fb_active: equ display_fb2 - 2  
011b			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011b			display_write_tmp: equ display_lcde1e2 - 2  
011b			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011b			  
011b			;  
011b			  
011b			;; can load into de directory  
011b			cursor_col: equ display_active-1  
011b			cursor_row: equ cursor_col-1  
011b			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011b			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011b			  
011b			; maths vars  
011b			  
011b			LFSRSeed: equ cursor_shape -20   
011b			randData: equ LFSRSeed - 2  
011b			xrandc: equ randData - 2  
011b			stackstore: equ xrandc - 2  
011b			seed1: equ  stackstore -2   
011b			seed2: equ seed1 - 2  
011b			  
011b			; cf storage vars  
011b			  
011b			iErrorNum:  equ seed2-1         ;Error number  
011b			iErrorReg:  equ iErrorNum -1              ;Error register  
011b			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011b			  
011b			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011b			  
011b			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011b			  
011b			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011b			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011b			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011b			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011b			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011b			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011b			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011b			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011b			store_tmpid: equ store_tmp3 - 1		; page temp id  
011b			store_tmpext: equ store_tmpid - 1		; file extent temp  
011b			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011b			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011b			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011b			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011b			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011b			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011b			;  
011b			; spi vars  
011b			  
011b			  
011b			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011b			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011b			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011b			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011b			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011b			spi_device_id: equ spi_device - 1    ; human readable bank number  
011b			  
011b			;;;;; forth cli params  
011b			  
011b			; TODO use a different frame buffer for forth???  
011b			  
011b			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011b			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011b			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011b			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011b			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011b			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011b			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011b			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011b			  
011b			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011b			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011b			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011b			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011b			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011b			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011b			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011b			  
011b			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011b			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011b			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011b			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011b			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011b			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011b			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011b			  
011b			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011b			  
011b			; os/forth token vars  
011b			  
011b			os_last_cmd: equ os_var_array-255  
011b			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011b			os_current_i: equ os_cli_cmd-2  
011b			os_cur_ptr: equ os_current_i-2  
011b			os_word_scratch: equ os_cur_ptr-30  
011b			os_tok_len: equ os_word_scratch - 2  
011b			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011b			os_tok_malloc: equ os_tok_ptr - 2  
011b			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011b			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011b			execscratch: equ os_input-255        ; exec cmd eval buffer  
011b			scratch: equ execscratch-255  
011b			  
011b			os_stack_1: equ scratch - 3       ; stack holding area 1  
011b			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
011b			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
011b			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
011b			  
011b			  
011b			; temp locations for new word processing to save on adding more   
011b			  
011b			os_new_malloc: equ os_stack_4-2  
011b			os_new_parse_len: equ os_new_malloc - 2  
011b			os_new_word_len: equ os_new_parse_len - 2  
011b			os_new_work_ptr: equ os_new_word_len - 2  
011b			os_new_src_ptr: equ os_new_work_ptr - 2  
011b			os_new_exec: equ os_new_src_ptr - 2  
011b			os_new_exec_ptr: equ os_new_exec - 2  
011b			  
011b			; resume memory alloocations....  
011b			  
011b			;os_view_disable: equ os_new_exec_ptr - 1  
011b			os_view_af: equ os_new_exec_ptr - 2  
011b			os_view_hl: equ os_view_af -2  
011b			os_view_de: equ os_view_hl - 2  
011b			os_view_bc: equ os_view_de - 2  
011b			  
011b			; stack checksum word  
011b			if DEBUG_STACK_IMB  
011b				curframe: equ  os_view_de - 5  
011b				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011b				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011b			else  
011b				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011b			endif  
011b			  
011b			; with data stack could see memory filled with junk. need some memory management   
011b			; malloc and free entry points added  
011b			  
011b			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011b			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011b			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			;heap_end: equ free_list-1  ; Starting address of heap  
011b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			  
011b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			heap_end: equ chk_word-1  ; Starting address of heap  
011b			  
011b			  
011b			;if BASE_KEV   
011b			;heap_start: equ 0800eh  ; Starting address of heap  
011b			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011b			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011b			;endif  
011b			  
011b			;if BASE_SC114  
011b			;heap_start: equ baseram+15  ; Starting address of heap  
011b			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011b			;endif  
011b			  
011b			  
011b			;;;;  
011b			  
011b			  
011b			; change below to point to last memory alloc above  
011b			topusermem:  equ   heap_start  
011b			  
011b			;if BASE_KEV   
011b			;baseusermem: equ 08000h  
011b			;endif  
011b			  
011b			;if BASE_SC114  
011b			;;aseusermem:     equ    12  
011b			;baseusermem:     equ    prompt  
011b			;;baseusermem:     equ    endofcode  
011b			;endif  
011b			  
011b			  
011b			; **********************************************************************  
011b			; **  Constants  
011b			; **********************************************************************  
011b			  
011b			; Constants used by this code module  
011b			kDataReg:   EQU Device_D           ;PIO port A data register  
011b			kContReg:   EQU Device_D+2           ;PIO port A control register  
011b			  
011b			  
011b			portbdata:  equ Device_D+1    ; port b data  
011b			portbctl:   equ Device_D+3    ; port b control  
011b			  
011b			  
011b			;KEY_SHIFT:   equ 5  
011b			;KEY_SYMBOLSHIFT:  equ 6  
011b			  
011b			KEY_SHIFTLOCK: equ 4  
011b			  
011b			  
011b			KEY_UP: equ 5  
011b			KEY_NEXTWORD: equ 6  
011b			KEY_PREVWORD: equ 7  
011b			KEY_BS: equ 8  
011b			KEY_TAB:  equ 9  
011b			KEY_DOWN: equ 10  
011b			KEY_LEFT: equ 11  
011b			KEY_RIGHT: equ 12  
011b			KEY_CR:   equ 13  
011b			KEY_HOME: equ 14  
011b			KEY_END: equ 15  
011b			  
011b			KEY_F1: equ 16  
011b			KEY_F2: equ 17  
011b			KEY_F3: equ 18  
011b			KEY_F4: equ 19  
011b			  
011b			KEY_F5: equ 20  
011b			KEY_F6: equ 21  
011b			KEY_F7: equ 22  
011b			KEY_F8: equ 23  
011b			  
011b			KEY_F9: equ 24  
011b			KEY_F10: equ 25  
011b			KEY_F11: equ 26  
011b			KEY_F12: equ 27  
011b			  
011b			;if DEBUG_KEY  
011b			;	KEY_MATRIX_NO_PRESS: equ '.'  
011b			;	KEY_SHIFT:   equ '.'  
011b			;	KEY_SYMBOLSHIFT:  equ '.'  
011b			;else  
011b				KEY_SHIFT:   equ '~'  
011b				KEY_SYMBOLSHIFT:  equ '~'  
011b				KEY_MATRIX_NO_PRESS: equ '~'  
011b			;endi  
011b			  
011b			  
011b			  
011b			  
011b			; Macro to make adding debug marks easier  
011b			  
011b			DMARK: macro str  
011b				push af  
011b				ld a, (.dmark)  
011b				ld (debug_mark),a  
011b				ld a, (.dmark+1)  
011b				ld (debug_mark+1),a  
011b				ld a, (.dmark+2)  
011b				ld (debug_mark+2),a  
011b				jr .pastdmark  
011b			.dmark: db str  
011b			.pastdmark: pop af  
011b			  
011b			endm  
011b			  
011b			  
011b			; macro to detect for stack imbalances  
011b			  
011b			include "stackimbal.asm"  
011b			; Macro and code to detect stock imbalances 
011b			 
011b			SPPUSH: equ 0 
011b			 
011b			; Add a stack frame which can be checked before return 
011b			 
011b			STACKFRAME: macro onoff frame1 frame2 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						; save current SP 
011b						exx 
011b			 
011b						ld de, frame1 
011b						ld a, d 
011b						ld hl, curframe 
011b						call hexout 
011b						ld a, e 
011b						ld hl, curframe+2 
011b						call hexout 
011b			  
011b						ld hl, frame1 
011b						push hl 
011b						ld hl, frame2 
011b						push hl 
011b						exx 
011b					endif 
011b					 
011b				endif 
011b			endm 
011b			 
011b			STACKFRAMECHK: macro onoff frame1 frame2 
011b			 
011b					 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						exx 
011b						; check stack frame SP 
011b			 
011b						ld hl, frame2 
011b						pop de   ; frame2 
011b			 
011b						call cmp16 
011b						jr nz, .spnosame 
011b						 
011b			 
011b						ld hl, frame1 
011b						pop de   ; frame1 
011b			 
011b						call cmp16 
011b						jr z, .spfrsame 
011b			 
011b						.spnosame: call showsperror 
011b			 
011b						.spfrsame: nop 
011b			 
011b						exx 
011b					endif 
011b					 
011b				endif 
011b			 
011b			 
011b			endm 
011b			 
011b			 
011b			; for a sub routine, wrap SP collection and comparisons 
011b			 
011b			; Usage: 
011b			; 
011b			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011b			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011b			 
011b			SAVESP: macro onoff storeword 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						; save current SP 
011b			 
011b						ld (store_sp+(storeword*4)), sp 
011b			 
011b					endif 
011b					 
011b				endif 
011b			 
011b			endm 
011b			 
011b			CHECKSP: macro onoff storeword 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b			 
011b						; save SP after last save 
011b				 
011b						ld (store_sp+(storeword*4)+2), sp 
011b			 
011b						push hl 
011b						ld hl, store_sp+(storeword*4) 
011b						call check_stack_sp  
011b						pop hl 
011b			 
011b			 
011b					endif 
011b					 
011b				endif 
011b			 
011b			endm 
011b			 
011b			if DEBUG_STACK_IMB 
011b			 
011b			check_stack_sp: 
011b					push de 
011b			 
011b					ld e, (hl) 
011b					inc hl 
011b					ld d, (hl) 
011b					inc hl 
011b			 
011b					push de 
011b			 
011b			 
011b					ld e, (hl) 
011b					inc hl 
011b					ld d, (hl) 
011b					inc hl 
011b			 
011b					pop hl 
011b			 
011b			 
011b					; check to see if the same 
011b			 
011b					call cmp16 
011b					jr z, .spsame 
011b			 
011b					; not same 
011b			 
011b					call showsperror 
011b			.spsame: 
011b			 
011b					pop de 
011b			 
011b					ret 
011b			 
011b			.sperr:  db "Stack imbalance",0 
011b			 
011b			 
011b			showsperror: 
011b			 
011b			 
011b				push hl 
011b				push af 
011b				push de 
011b				call clear_display 
011b				ld de, .sperr 
011b				ld a,0 
011b			;	ld de,os_word_scratch 
011b				call str_at_display 
011b				ld a, display_row_1+17 
011b				ld de, debug_mark 
011b				call str_at_display 
011b				ld a, 0 
011b				ld (curframe+4),a 
011b				ld hl, curframe 
011b				ld de, os_word_scratch 
011b				ld a, display_row_4 
011b				call str_at_display 
011b				call update_display 
011b				;call break_point_state 
011b				call cin_wait 
011b			 
011b			;	ld a, ' ' 
011b			;	ld (os_view_disable), a 
011b				call bp_on 
011b				pop de	 
011b				pop af 
011b				pop hl 
011b				CALLMONITOR 
011b				ret 
011b			 
011b			endif 
011b			 
011b			 
011b			 
011b			; eof 
# End of file stackimbal.asm
011b			  
011b			;TODO macro to calc col and row offset into screen  
011b			  
011b			  
011b			  
011b			hardware_init:  
011b			  
011b				  
011b			  
011b					;ld a, 0  
011b					;ld (hardware_diag), a  
011b			  
011b					; clear all the buffers  
011b			  
011b 21 10 ed				ld hl, display_fb1  
011e 22 cc eb				ld (display_fb_active), hl  
0121			  
0121 cd b9 0b				call clear_display  
0124			  
0124 21 ce eb				ld hl, display_fb2  
0127 22 cc eb				ld (display_fb_active), hl  
012a			  
012a cd b9 0b				call clear_display  
012d			  
012d					; init primary frame buffer area  
012d 21 b1 ed				ld hl, display_fb0  
0130 22 cc eb				ld (display_fb_active), hl  
0133			  
0133 cd b9 0b				call clear_display  
0136			  
0136			  
0136 cd 4c 64				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0139			  
0139 cd 3a 65			call key_init  
013c cd 9e 01			call storage_init  
013f			  
013f				; setup malloc functions  
013f			  
013f				if MALLOC_1  
013f cd aa 11				call  heap_init  
0142				endif  
0142				if MALLOC_4  
0142					call  heap_init  
0142				endif  
0142			  
0142				; init sound hardware if present  
0142			  
0142				if SOUND_ENABLE  
0142					call sound_init  
0142				endif  
0142			  
0142				; lcd test sequence  
0142					  
0142 cd dc 0b			call update_display  
0145 cd f1 0a			call delay1s  
0148 3e 2b			ld a,'+'  
014a cd be 0b			call fill_display  
014d cd dc 0b			call update_display  
0150 cd f1 0a			call delay1s  
0153 3e 2a			ld a,'*'  
0155 cd be 0b			call fill_display  
0158 cd dc 0b			call update_display  
015b cd f1 0a			call delay1s  
015e 3e 2d			ld a,'-'  
0160 cd be 0b			call fill_display  
0163 cd dc 0b			call update_display  
0166 cd f1 0a			call delay1s  
0169			  
0169			; boot splash screen  
0169			if display_cols == 20	  
0169			        ld a, display_row_1    
0169			else  
0169 3e 0a		        ld a, display_row_1 +10   
016b			endif  
016b 11 d8 16			ld de, prom_bootmsg  
016e cd cc 0b			call str_at_display  
0171 cd dc 0b			call update_display  
0174			  
0174			  
0174 cd f1 0a			call delay1s  
0177 cd f1 0a			call delay1s  
017a			if display_cols == 20	  
017a			            LD   A, display_row_3+2  
017a			else  
017a 3e 5c		            LD   A, display_row_3+12  
017c			endif  
017c 11 ed 16			ld de, prom_bootmsg1  
017f cd cc 0b			call str_at_display  
0182 cd dc 0b			call update_display  
0185 cd f1 0a			call delay1s  
0188 cd f1 0a			call delay1s  
018b			  
018b			;	ld a, display_row_4+3  
018b			;	ld de, bootmsg2  
018b			;	call str_at_display  
018b			;	call update_display  
018b			;	call delay1s  
018b			;	call delay1s  
018b			  
018b			; debug mark setup  
018b			  
018b 3e 5f		ld a, '_'  
018d 32 6b ee		ld (debug_mark),a  
0190 32 6c ee		ld (debug_mark+1),a  
0193 32 6d ee		ld (debug_mark+2),a  
0196 3e 00		ld a,0  
0198 32 6e ee		ld (debug_mark+3),a  
019b			  
019b c9					ret  
019c			  
019c			  
019c			;bootmsg2:	db "Firmware v0.1",0  
019c			  
019c			; a 4x20 lcd  
019c			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019c			  
019c			;if display_cols == 20  
019c			;	include "firmware_lcd_4x20.asm"  
019c			;endif  
019c			  
019c			;if display_cols == 40  
019c			;	include "firmware_lcd_4x40.asm"  
019c			;endif  
019c			  
019c			;  
019c			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019c			; TODO abstract the bit bang video out interface for dual display  
019c			; TODO wire video out to tx pin on rc2014 bus  
019c			  
019c			; must supply cin, and cin_wait for low level hardware abstraction   
019c			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019c			; test scancode  
019c			  
019c			;;;;;  
019c			;;;  
019c			; Moved out to mini and maxi versions  
019c			;  
019c			; include "firmware_key_4x4.asm"  
019c			; using existing 4 wire x 4 resistor array for input  
019c			;include "firmware_key_4x10.asm"  
019c			; need to mod the board for 5 rows due to resistor array  
019c			;include "firmware_key_5x10.asm"  
019c			  
019c			; storage hardware interface  
019c			  
019c			; use microchip serial eeprom for storage  
019c			  
019c			  
019c			if STORAGE_SE  
019c				include "firmware_spi.asm"  
019c				include "firmware_seeprom.asm"  
019c			else  
019c			   ; create some stubs for the labels  
019c c9			se_readbyte: ret  
019d c9			se_writebyte: ret  
019e c9			storage_init: ret  
019f			  
019f			endif  
019f			  
019f			; use cf card for storage - throwing timeout errors. Hardware or software?????  
019f			;include "firmware_cf.asm"  
019f			  
019f			; load up high level storage hardward abstractions  
019f			include "firmware_storage.asm"  
019f			 
019f			; persisent storage hardware abstraction layer  
019f			 
019f			 
019f			 
019f			; Block 0 on storage is a config state 
019f			 
019f			 
019f			 
019f			; TODO add read phy block and write phy block functions 
019f			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
019f			 
019f			; Abstraction layer  
019f			 
019f			; Logocial block size is same size as physical size - using tape concept 
019f			 
019f			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
019f			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
019f			 
019f			 
019f			 
019f			; Filesystem layout (Logical layout) 
019f			; 
019f			; Block 0 - Bank config  
019f			; 
019f			;      Byte - 0 file id counter 
019f			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
019f			;      Byte - 3-20 zero terminated bank label 
019f			; 
019f			; Block 1 > File storage 
019f			; 
019f			;      Byte 0 file id    - block 0 file details 
019f			;      Byte 1 block id - block 0 is file  
019f			;            Byte 2-15 - File name 
019f			; 
019f			;       - to end of block data 
019f			; 
019f			 
019f			; Get ID for the file named in pointer held HL 
019f			; Returns ID in HL = 255 if no file found 
019f			 
019f			storage_getid: 
019f			 
019f 22 73 ea			ld (store_tmp1), hl 
01a2			 
01a2				if DEBUG_STORESE 
01a2					DMARK "SGI" 
01a2 f5				push af  
01a3 3a b7 01			ld a, (.dmark)  
01a6 32 6b ee			ld (debug_mark),a  
01a9 3a b8 01			ld a, (.dmark+1)  
01ac 32 6c ee			ld (debug_mark+1),a  
01af 3a b9 01			ld a, (.dmark+2)  
01b2 32 6d ee			ld (debug_mark+2),a  
01b5 18 03			jr .pastdmark  
01b7 ..			.dmark: db "SGI"  
01ba f1			.pastdmark: pop af  
01bb			endm  
# End of macro DMARK
01bb					CALLMONITOR 
01bb cd 6f ee			call debug_vector  
01be				endm  
# End of macro CALLMONITOR
01be				endif 
01be				; get block 0 and set counter for number of files to scan 
01be			 
01be cd 29 03			call storage_get_block_0 
01c1			 
01c1 3a 7a ea			ld a, (store_page) 
01c4 47				ld b, a 
01c5			 
01c5				; get extent 0 of each file id 
01c5			 
01c5				if DEBUG_STORESE 
01c5					DMARK "SGc" 
01c5 f5				push af  
01c6 3a da 01			ld a, (.dmark)  
01c9 32 6b ee			ld (debug_mark),a  
01cc 3a db 01			ld a, (.dmark+1)  
01cf 32 6c ee			ld (debug_mark+1),a  
01d2 3a dc 01			ld a, (.dmark+2)  
01d5 32 6d ee			ld (debug_mark+2),a  
01d8 18 03			jr .pastdmark  
01da ..			.dmark: db "SGc"  
01dd f1			.pastdmark: pop af  
01de			endm  
# End of macro DMARK
01de					CALLMONITOR 
01de cd 6f ee			call debug_vector  
01e1				endm  
# End of macro CALLMONITOR
01e1				endif 
01e1 60			.getloop:	ld h, b 
01e2 2e 00				ld l, 0 
01e4 c5					push bc 
01e5			 
01e5 11 7a ea				ld de, store_page 
01e8				if DEBUG_STORESE 
01e8					DMARK "SGr" 
01e8 f5				push af  
01e9 3a fd 01			ld a, (.dmark)  
01ec 32 6b ee			ld (debug_mark),a  
01ef 3a fe 01			ld a, (.dmark+1)  
01f2 32 6c ee			ld (debug_mark+1),a  
01f5 3a ff 01			ld a, (.dmark+2)  
01f8 32 6d ee			ld (debug_mark+2),a  
01fb 18 03			jr .pastdmark  
01fd ..			.dmark: db "SGr"  
0200 f1			.pastdmark: pop af  
0201			endm  
# End of macro DMARK
0201					CALLMONITOR 
0201 cd 6f ee			call debug_vector  
0204				endm  
# End of macro CALLMONITOR
0204				endif 
0204 cd d1 07				call storage_read 
0207 cd 0f 0e				call ishlzero 
020a 28 2d				jr z, .gap 
020c					 
020c					; have a file name read. Is it one we want. 
020c			 
020c 2a 73 ea				ld hl, (store_tmp1) 
020f 11 7d ea				ld de, store_page+3   ; file name 
0212			 
0212				if DEBUG_STORESE 
0212					DMARK "SGc" 
0212 f5				push af  
0213 3a 27 02			ld a, (.dmark)  
0216 32 6b ee			ld (debug_mark),a  
0219 3a 28 02			ld a, (.dmark+1)  
021c 32 6c ee			ld (debug_mark+1),a  
021f 3a 29 02			ld a, (.dmark+2)  
0222 32 6d ee			ld (debug_mark+2),a  
0225 18 03			jr .pastdmark  
0227 ..			.dmark: db "SGc"  
022a f1			.pastdmark: pop af  
022b			endm  
# End of macro DMARK
022b					CALLMONITOR 
022b cd 6f ee			call debug_vector  
022e				endm  
# End of macro CALLMONITOR
022e				endif 
022e cd 91 11				call strcmp 
0231 20 06				jr nz, .gap   ; not this one 
0233			 
0233 c1				        pop bc 
0234			 
0234 26 00				ld h, 0 
0236 68					ld l, b 
0237 18 22				jr .getdone 
0239						 
0239			 
0239			 
0239			 
0239			.gap: 
0239				if DEBUG_STORESE 
0239					DMARK "SGg" 
0239 f5				push af  
023a 3a 4e 02			ld a, (.dmark)  
023d 32 6b ee			ld (debug_mark),a  
0240 3a 4f 02			ld a, (.dmark+1)  
0243 32 6c ee			ld (debug_mark+1),a  
0246 3a 50 02			ld a, (.dmark+2)  
0249 32 6d ee			ld (debug_mark+2),a  
024c 18 03			jr .pastdmark  
024e ..			.dmark: db "SGg"  
0251 f1			.pastdmark: pop af  
0252			endm  
# End of macro DMARK
0252					CALLMONITOR 
0252 cd 6f ee			call debug_vector  
0255				endm  
# End of macro CALLMONITOR
0255				endif 
0255			 
0255 c1					pop bc 
0256 10 89				djnz .getloop 
0258 21 ff 00				ld hl, 255 
025b			.getdone: 
025b			 
025b				if DEBUG_STORESE 
025b					DMARK "SGe" 
025b f5				push af  
025c 3a 70 02			ld a, (.dmark)  
025f 32 6b ee			ld (debug_mark),a  
0262 3a 71 02			ld a, (.dmark+1)  
0265 32 6c ee			ld (debug_mark+1),a  
0268 3a 72 02			ld a, (.dmark+2)  
026b 32 6d ee			ld (debug_mark+2),a  
026e 18 03			jr .pastdmark  
0270 ..			.dmark: db "SGe"  
0273 f1			.pastdmark: pop af  
0274			endm  
# End of macro DMARK
0274					CALLMONITOR 
0274 cd 6f ee			call debug_vector  
0277				endm  
# End of macro CALLMONITOR
0277				endif 
0277			 
0277 c9				ret 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			; Read Block 
0278			; ---------- 
0278			; 
0278			; With current bank 
0278			;  
0278			; Get block number to read 
0278			; Load physical blocks starting at start block into buffer 
0278			 
0278			; de points to buffer to use 
0278			; hl holds logical block number  
0278			 
0278			storage_read_block: 
0278			 
0278				; TODO bank selection 
0278			 
0278				; for each of the physical blocks read it into the buffer 
0278 06 40			ld b, STORE_BLOCK_PHY 
027a			 
027a				if DEBUG_STORESE 
027a d5					push de 
027b				endif 
027b				 
027b			.rl1:    
027b			 
027b				; read physical block at hl into de 
027b			        ; increment hl and de to next read position on exit 
027b			 
027b e5				push hl 
027c d5				push de	 
027d c5				push bc 
027e			;	if DEBUG_STORESE 
027e			;		push af 
027e			;		ld a, 'R' 
027e			;		ld (debug_mark),a 
027e			;		pop af 
027e			;		CALLMONITOR 
027e			;	endif 
027e cd 9c 01			call se_readbyte 
0281			;	if DEBUG_STORESE 
0281			;		ld a,(spi_portbyte) 
0281			;		ld l, a 
0281			;		push af 
0281			;		ld a, '1' 
0281			;		ld (debug_mark),a 
0281			;		pop af 
0281			;		CALLMONITOR 
0281			;	endif 
0281 c1				pop bc 
0282 d1				pop de 
0283 e1				pop hl 
0284 12				ld (de),a 
0285 23				inc hl 
0286 13				inc de 
0287			 
0287			;	if DEBUG_STORESE 
0287			;		push af 
0287			;		ld a, 'r' 
0287			;		ld (debug_mark),a 
0287			;		pop af 
0287			;		CALLMONITOR 
0287			;	endif 
0287			 
0287 10 f2			djnz .rl1 
0289			 
0289				if DEBUG_STORESE 
0289					DMARK "SRB" 
0289 f5				push af  
028a 3a 9e 02			ld a, (.dmark)  
028d 32 6b ee			ld (debug_mark),a  
0290 3a 9f 02			ld a, (.dmark+1)  
0293 32 6c ee			ld (debug_mark+1),a  
0296 3a a0 02			ld a, (.dmark+2)  
0299 32 6d ee			ld (debug_mark+2),a  
029c 18 03			jr .pastdmark  
029e ..			.dmark: db "SRB"  
02a1 f1			.pastdmark: pop af  
02a2			endm  
# End of macro DMARK
02a2 d1					pop de 
02a3			; 
02a3			;		push af 
02a3			;		ld a, 'R' 
02a3			;		ld (debug_mark),a 
02a3			;		pop af 
02a3					CALLMONITOR 
02a3 cd 6f ee			call debug_vector  
02a6				endm  
# End of macro CALLMONITOR
02a6				endif 
02a6 c9				ret	 
02a7				 
02a7			 
02a7			; File Size 
02a7			; --------- 
02a7			; 
02a7			;   hl file id 
02a7			; 
02a7			;  returns in hl the number of blocks 
02a7			 
02a7			storage_file_size: 
02a7 5d				ld e, l 
02a8 16 00			ld d, 0 
02aa 21 40 00			ld hl, STORE_BLOCK_PHY 
02ad					if DEBUG_FORTH_WORDS 
02ad						DMARK "SIZ" 
02ad f5				push af  
02ae 3a c2 02			ld a, (.dmark)  
02b1 32 6b ee			ld (debug_mark),a  
02b4 3a c3 02			ld a, (.dmark+1)  
02b7 32 6c ee			ld (debug_mark+1),a  
02ba 3a c4 02			ld a, (.dmark+2)  
02bd 32 6d ee			ld (debug_mark+2),a  
02c0 18 03			jr .pastdmark  
02c2 ..			.dmark: db "SIZ"  
02c5 f1			.pastdmark: pop af  
02c6			endm  
# End of macro DMARK
02c6						CALLMONITOR 
02c6 cd 6f ee			call debug_vector  
02c9				endm  
# End of macro CALLMONITOR
02c9					endif 
02c9 cd ab 05			call storage_findnextid 
02cc			 
02cc cd 0f 0e			call ishlzero 
02cf			;	ld a, l 
02cf			;	add h 
02cf			;	cp 0 
02cf c8				ret z			; block not found so EOF 
02d0			 
02d0 11 7a ea			ld de, store_page 
02d3 cd 78 02			call storage_read_block 
02d6			 
02d6 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
02d9 6f				ld l, a 
02da 26 00			ld h, 0 
02dc c9			 	ret 
02dd			 
02dd			 
02dd			; Write Block 
02dd			; ----------- 
02dd			; 
02dd			; With current bank 
02dd			;  
02dd			; Get block number to write 
02dd			; Write physical blocks starting at start block from buffer 
02dd			  
02dd			storage_write_block: 
02dd				; TODO bank selection 
02dd			 
02dd				; for each of the physical blocks read it into the buffer 
02dd 06 40			ld b, STORE_BLOCK_PHY 
02df			 
02df				if DEBUG_STORESE 
02df					DMARK "SWB" 
02df f5				push af  
02e0 3a f4 02			ld a, (.dmark)  
02e3 32 6b ee			ld (debug_mark),a  
02e6 3a f5 02			ld a, (.dmark+1)  
02e9 32 6c ee			ld (debug_mark+1),a  
02ec 3a f6 02			ld a, (.dmark+2)  
02ef 32 6d ee			ld (debug_mark+2),a  
02f2 18 03			jr .pastdmark  
02f4 ..			.dmark: db "SWB"  
02f7 f1			.pastdmark: pop af  
02f8			endm  
# End of macro DMARK
02f8			 
02f8					;push af 
02f8					;ld a, 'W' 
02f8					;ld (debug_mark),a 
02f8					;pop af 
02f8					CALLMONITOR 
02f8 cd 6f ee			call debug_vector  
02fb				endm  
# End of macro CALLMONITOR
02fb				endif 
02fb			 
02fb			; might not be working 
02fb			;	call se_writepage 
02fb			 
02fb			;	ret 
02fb			; 
02fb			 
02fb			 
02fb			 
02fb			.wl1:    
02fb			 
02fb				; read physical block at hl into de 
02fb			        ; increment hl and de to next read position on exit 
02fb			 
02fb e5				push hl 
02fc d5				push de	 
02fd c5				push bc 
02fe 1a				ld a,(de) 
02ff				;if DEBUG_STORESE 
02ff			;		push af 
02ff			;		ld a, 'W' 
02ff			;		ld (debug_mark),a 
02ff			;		pop af 
02ff			;		CALLMONITOR 
02ff			;	endif 
02ff cd 9d 01			call se_writebyte 
0302			;	call delay250ms 
0302 00				nop 
0303 00				nop 
0304 00				nop 
0305			;	if DEBUG_STORESE 
0305			;		push af 
0305			;		ld a, 'w' 
0305			;		ld (debug_mark),a 
0305			;		pop af 
0305			;		CALLMONITOR 
0305			;	endif 
0305 c1				pop bc 
0306 d1				pop de 
0307 e1				pop hl 
0308 23				inc hl 
0309 13				inc de 
030a			 
030a			 
030a 10 ef			djnz .wl1 
030c			 
030c				if DEBUG_STORESE 
030c					DMARK "SW2" 
030c f5				push af  
030d 3a 21 03			ld a, (.dmark)  
0310 32 6b ee			ld (debug_mark),a  
0313 3a 22 03			ld a, (.dmark+1)  
0316 32 6c ee			ld (debug_mark+1),a  
0319 3a 23 03			ld a, (.dmark+2)  
031c 32 6d ee			ld (debug_mark+2),a  
031f 18 03			jr .pastdmark  
0321 ..			.dmark: db "SW2"  
0324 f1			.pastdmark: pop af  
0325			endm  
# End of macro DMARK
0325			 
0325					;push af 
0325					;ld a, 'W' 
0325					;ld (debug_mark),a 
0325					;pop af 
0325					CALLMONITOR 
0325 cd 6f ee			call debug_vector  
0328				endm  
# End of macro CALLMONITOR
0328				endif 
0328 c9				ret	 
0329			 
0329			; Init bank 
0329			; --------- 
0329			; 
0329			; With current bank 
0329			; 
0329			; Setup block 0 config 
0329			;     Set 0 file id counter 
0329			;     Set formatted byte pattern 
0329			;     Zero out bank label 
0329			;      
0329			; For every logical block write 0-1 byte as null 
0329			 
0329			storage_get_block_0: 
0329			 
0329				; TODO check presence 
0329			 
0329				; get block 0 config 
0329			 
0329 21 00 00			ld hl, 0 
032c 11 7a ea			ld de, store_page 
032f cd 78 02			call storage_read_block 
0332			 
0332				if DEBUG_STORESE 
0332					DMARK "SB0" 
0332 f5				push af  
0333 3a 47 03			ld a, (.dmark)  
0336 32 6b ee			ld (debug_mark),a  
0339 3a 48 03			ld a, (.dmark+1)  
033c 32 6c ee			ld (debug_mark+1),a  
033f 3a 49 03			ld a, (.dmark+2)  
0342 32 6d ee			ld (debug_mark+2),a  
0345 18 03			jr .pastdmark  
0347 ..			.dmark: db "SB0"  
034a f1			.pastdmark: pop af  
034b			endm  
# End of macro DMARK
034b 11 7a ea				ld de, store_page 
034e			;		push af 
034e			;		ld a, 'i' 
034e			;		ld (debug_mark),a 
034e			;		pop af 
034e					CALLMONITOR 
034e cd 6f ee			call debug_vector  
0351				endm  
# End of macro CALLMONITOR
0351				endif 
0351			 
0351				; is this area formatted? 
0351			 
0351			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0351 2a 7b ea			ld hl, (store_page+1) 
0354 3e 80			ld a,0x80 
0356 bd				cp l 
0357 20 22			jr nz, .ininotformatted 
0359				; do a double check 
0359 3e 27			ld a, 0x27 
035b bc				cp h 
035c 20 1d			jr nz, .ininotformatted 
035e			 
035e				; formatted then 
035e			 
035e				if DEBUG_STORESE 
035e					DMARK "SB1" 
035e f5				push af  
035f 3a 73 03			ld a, (.dmark)  
0362 32 6b ee			ld (debug_mark),a  
0365 3a 74 03			ld a, (.dmark+1)  
0368 32 6c ee			ld (debug_mark+1),a  
036b 3a 75 03			ld a, (.dmark+2)  
036e 32 6d ee			ld (debug_mark+2),a  
0371 18 03			jr .pastdmark  
0373 ..			.dmark: db "SB1"  
0376 f1			.pastdmark: pop af  
0377			endm  
# End of macro DMARK
0377					;push af 
0377					;ld a, 'I' 
0377					;ld (debug_mark),a 
0377					;pop af 
0377					CALLMONITOR 
0377 cd 6f ee			call debug_vector  
037a				endm  
# End of macro CALLMONITOR
037a				endif 
037a c9				ret 
037b			 
037b			.ininotformatted: 
037b				; bank not formatted so poke various bits to make sure 
037b			 
037b				if DEBUG_STORESE 
037b					DMARK "SB2" 
037b f5				push af  
037c 3a 90 03			ld a, (.dmark)  
037f 32 6b ee			ld (debug_mark),a  
0382 3a 91 03			ld a, (.dmark+1)  
0385 32 6c ee			ld (debug_mark+1),a  
0388 3a 92 03			ld a, (.dmark+2)  
038b 32 6d ee			ld (debug_mark+2),a  
038e 18 03			jr .pastdmark  
0390 ..			.dmark: db "SB2"  
0393 f1			.pastdmark: pop af  
0394			endm  
# End of macro DMARK
0394					;push af 
0394					;ld a, 'f' 
0394					;ld (debug_mark),a 
0394					;pop af 
0394					CALLMONITOR 
0394 cd 6f ee			call debug_vector  
0397				endm  
# End of macro CALLMONITOR
0397				endif 
0397			 
0397 cd b4 0a			call storage_clear_page 
039a			 
039a 21 7a ea			ld hl, store_page 
039d 3e 00			ld a, 0 
039f				 
039f 77				ld (hl),a   ; reset file counter 
03a0			 
03a0 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a3 22 7b ea		 	ld (store_page+1), hl	 
03a6			 
03a6				; set default label 
03a6			 
03a6 21 42 04			ld hl, .defaultbanklabl 
03a9 11 7d ea		 	ld de, store_page+3 
03ac 01 0f 00			ld bc, 15 
03af ed b0			ldir 
03b1			 
03b1				; Append the current bank id 
03b1 21 86 ea			ld hl, store_page+3+9 
03b4 3a 5f ea			ld a, (spi_device_id) 
03b7 77				ld (hl), a 
03b8			 
03b8				; save default page 0 
03b8			 
03b8 21 00 00			ld hl, 0 
03bb 11 7a ea			ld de, store_page 
03be				if DEBUG_STORESE 
03be					DMARK "SB3" 
03be f5				push af  
03bf 3a d3 03			ld a, (.dmark)  
03c2 32 6b ee			ld (debug_mark),a  
03c5 3a d4 03			ld a, (.dmark+1)  
03c8 32 6c ee			ld (debug_mark+1),a  
03cb 3a d5 03			ld a, (.dmark+2)  
03ce 32 6d ee			ld (debug_mark+2),a  
03d1 18 03			jr .pastdmark  
03d3 ..			.dmark: db "SB3"  
03d6 f1			.pastdmark: pop af  
03d7			endm  
# End of macro DMARK
03d7			;		push af 
03d7			;		ld a, 'F' 
03d7			;		ld (debug_mark),a 
03d7			;		pop af 
03d7					CALLMONITOR 
03d7 cd 6f ee			call debug_vector  
03da				endm  
# End of macro CALLMONITOR
03da				endif 
03da cd dd 02			call storage_write_block 
03dd				if DEBUG_STORESE 
03dd					DMARK "SB4" 
03dd f5				push af  
03de 3a f2 03			ld a, (.dmark)  
03e1 32 6b ee			ld (debug_mark),a  
03e4 3a f3 03			ld a, (.dmark+1)  
03e7 32 6c ee			ld (debug_mark+1),a  
03ea 3a f4 03			ld a, (.dmark+2)  
03ed 32 6d ee			ld (debug_mark+2),a  
03f0 18 03			jr .pastdmark  
03f2 ..			.dmark: db "SB4"  
03f5 f1			.pastdmark: pop af  
03f6			endm  
# End of macro DMARK
03f6			;		push af 
03f6			;		ld a, '>' 
03f6			;		ld (debug_mark),a 
03f6			;		pop af 
03f6					CALLMONITOR 
03f6 cd 6f ee			call debug_vector  
03f9				endm  
# End of macro CALLMONITOR
03f9				endif 
03f9			 
03f9 00				nop 
03fa 00				nop 
03fb 00				nop 
03fc			 
03fc				; now set 0 in every page to mark as a free block 
03fc			 
03fc 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03fe 21 40 00			ld hl, STORE_BLOCK_PHY 
0401			 
0401 3e 00		.setmark1:   	ld a,0 
0403 e5					push hl 
0404 c5					push bc 
0405 cd 9d 01				call se_writebyte 
0408 3e 0a			ld a, 10 
040a cd d6 0a			call aDelayInMS 
040d 23				inc hl 
040e cd 9d 01				call se_writebyte 
0411 3e 0a			ld a, 10 
0413 cd d6 0a			call aDelayInMS 
0416 2b				dec hl 
0417 c1					pop bc 
0418 e1					pop hl 
0419 3e 40				ld a, STORE_BLOCK_PHY 
041b cd e6 0d				call addatohl 
041e 10 e1				djnz .setmark1 
0420			 
0420 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0422 3e 00		.setmark2:   	ld a,0 
0424 e5					push hl 
0425 c5					push bc 
0426 cd 9d 01				call se_writebyte 
0429 3e 0a			ld a, 10 
042b cd d6 0a			call aDelayInMS 
042e 23				inc hl 
042f cd 9d 01				call se_writebyte 
0432 3e 0a			ld a, 10 
0434 cd d6 0a			call aDelayInMS 
0437 2b				dec hl 
0438 c1					pop bc 
0439 e1					pop hl 
043a 3e 40				ld a, STORE_BLOCK_PHY 
043c cd e6 0d				call addatohl 
043f 10 e1				djnz .setmark2 
0441			 
0441					 
0441			 
0441			 
0441 c9				ret 
0442			 
0442			 
0442			 
0442			 
0442 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044d			 
044d			 
044d			 
044d			; Label Bank 
044d			; ---------- 
044d			; 
044d			; With current bank 
044d			; Read block 0 
044d			; Set label 
044d			; Write block 0 
044d			 
044d			; label str pointer in hl 
044d			 
044d			storage_label:     
044d			 
044d				if DEBUG_STORESE 
044d					DMARK "LBL" 
044d f5				push af  
044e 3a 62 04			ld a, (.dmark)  
0451 32 6b ee			ld (debug_mark),a  
0454 3a 63 04			ld a, (.dmark+1)  
0457 32 6c ee			ld (debug_mark+1),a  
045a 3a 64 04			ld a, (.dmark+2)  
045d 32 6d ee			ld (debug_mark+2),a  
0460 18 03			jr .pastdmark  
0462 ..			.dmark: db "LBL"  
0465 f1			.pastdmark: pop af  
0466			endm  
# End of macro DMARK
0466					CALLMONITOR 
0466 cd 6f ee			call debug_vector  
0469				endm  
# End of macro CALLMONITOR
0469				endif 
0469			 
0469 e5				push hl 
046a			 
046a cd 29 03			call storage_get_block_0 
046d			 
046d				; set default label 
046d			 
046d e1				pop hl 
046e			 
046e 11 7d ea		 	ld de, store_page+3 
0471 01 0f 00			ld bc, 15 
0474				if DEBUG_STORESE 
0474					DMARK "LB3" 
0474 f5				push af  
0475 3a 89 04			ld a, (.dmark)  
0478 32 6b ee			ld (debug_mark),a  
047b 3a 8a 04			ld a, (.dmark+1)  
047e 32 6c ee			ld (debug_mark+1),a  
0481 3a 8b 04			ld a, (.dmark+2)  
0484 32 6d ee			ld (debug_mark+2),a  
0487 18 03			jr .pastdmark  
0489 ..			.dmark: db "LB3"  
048c f1			.pastdmark: pop af  
048d			endm  
# End of macro DMARK
048d					CALLMONITOR 
048d cd 6f ee			call debug_vector  
0490				endm  
# End of macro CALLMONITOR
0490				endif 
0490 ed b0			ldir 
0492				; save default page 0 
0492			 
0492 21 00 00			ld hl, 0 
0495 11 7a ea			ld de, store_page 
0498				if DEBUG_STORESE 
0498					DMARK "LBW" 
0498 f5				push af  
0499 3a ad 04			ld a, (.dmark)  
049c 32 6b ee			ld (debug_mark),a  
049f 3a ae 04			ld a, (.dmark+1)  
04a2 32 6c ee			ld (debug_mark+1),a  
04a5 3a af 04			ld a, (.dmark+2)  
04a8 32 6d ee			ld (debug_mark+2),a  
04ab 18 03			jr .pastdmark  
04ad ..			.dmark: db "LBW"  
04b0 f1			.pastdmark: pop af  
04b1			endm  
# End of macro DMARK
04b1					CALLMONITOR 
04b1 cd 6f ee			call debug_vector  
04b4				endm  
# End of macro CALLMONITOR
04b4				endif 
04b4 cd dd 02			call storage_write_block 
04b7			 
04b7 c9				ret 
04b8			 
04b8			 
04b8			 
04b8			; Read Block 0 - Config 
04b8			; --------------------- 
04b8			; 
04b8			; With current bank 
04b8			; Call presence test 
04b8			;    If not present format/init bank  
04b8			; Read block 0  
04b8			;  
04b8			 
04b8			 
04b8			; Dir 
04b8			; --- 
04b8			; 
04b8			; With current bank 
04b8			; Load Block 0 Config 
04b8			; Get max file id number 
04b8			; For each logical block 
04b8			;    Read block read byte 2 
04b8			;      if first block of file 
04b8			;         Display file name 
04b8			;         Display type flags for file 
04b8			;        
04b8			 
04b8			; moving to words as this requires stack control 
04b8			 
04b8			 
04b8			; Delete File 
04b8			; ----------- 
04b8			; 
04b8			; With current bank 
04b8			; 
04b8			; Load Block 0 Config 
04b8			; Get max file id number 
04b8			; For each logical block 
04b8			;    Read block file id 
04b8			;      If first block of file and dont have file id 
04b8			;         if file to delete 
04b8			;         Save file id 
04b8			;         Null file id 
04b8			;         Write this block back 
04b8			;      If file id is one saved 
04b8			;         Null file id 
04b8			;         Write this block back 
04b8			 
04b8			 
04b8			.se_done: 
04b8 e1				pop hl 
04b9 c9				ret 
04ba			 
04ba			storage_erase: 
04ba			 
04ba				; hl contains the file id 
04ba			 
04ba 5d				ld e, l 
04bb 16 00			ld d, 0 
04bd 21 40 00			ld hl, STORE_BLOCK_PHY 
04c0					if DEBUG_FORTH_WORDS 
04c0						DMARK "ERA" 
04c0 f5				push af  
04c1 3a d5 04			ld a, (.dmark)  
04c4 32 6b ee			ld (debug_mark),a  
04c7 3a d6 04			ld a, (.dmark+1)  
04ca 32 6c ee			ld (debug_mark+1),a  
04cd 3a d7 04			ld a, (.dmark+2)  
04d0 32 6d ee			ld (debug_mark+2),a  
04d3 18 03			jr .pastdmark  
04d5 ..			.dmark: db "ERA"  
04d8 f1			.pastdmark: pop af  
04d9			endm  
# End of macro DMARK
04d9						CALLMONITOR 
04d9 cd 6f ee			call debug_vector  
04dc				endm  
# End of macro CALLMONITOR
04dc					endif 
04dc cd ab 05			call storage_findnextid 
04df cd 0f 0e			call ishlzero 
04e2 c8				ret z 
04e3			 
04e3 e5				push hl 
04e4			 
04e4				; TODO check file not found 
04e4			 
04e4 11 7a ea			ld de, store_page 
04e7 cd 78 02			call storage_read_block 
04ea			 
04ea cd 0f 0e			call ishlzero 
04ed ca b8 04			jp z,.se_done 
04f0			 
04f0					if DEBUG_FORTH_WORDS 
04f0						DMARK "ER1" 
04f0 f5				push af  
04f1 3a 05 05			ld a, (.dmark)  
04f4 32 6b ee			ld (debug_mark),a  
04f7 3a 06 05			ld a, (.dmark+1)  
04fa 32 6c ee			ld (debug_mark+1),a  
04fd 3a 07 05			ld a, (.dmark+2)  
0500 32 6d ee			ld (debug_mark+2),a  
0503 18 03			jr .pastdmark  
0505 ..			.dmark: db "ER1"  
0508 f1			.pastdmark: pop af  
0509			endm  
# End of macro DMARK
0509						CALLMONITOR 
0509 cd 6f ee			call debug_vector  
050c				endm  
# End of macro CALLMONITOR
050c					endif 
050c 3a 7a ea			ld a, (store_page)	; get file id 
050f 32 6e ea			ld (store_tmpid), a 
0512			 
0512 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
0515 32 6d ea			ld (store_tmpext), a 
0518			 
0518				; wipe file header 
0518			 
0518 e1				pop hl 
0519 3e 00			ld a, 0 
051b 32 7a ea			ld (store_page), a 
051e 32 7b ea			ld (store_page+1),a 
0521 11 7a ea			ld de, store_page 
0524					if DEBUG_FORTH_WORDS 
0524						DMARK "ER2" 
0524 f5				push af  
0525 3a 39 05			ld a, (.dmark)  
0528 32 6b ee			ld (debug_mark),a  
052b 3a 3a 05			ld a, (.dmark+1)  
052e 32 6c ee			ld (debug_mark+1),a  
0531 3a 3b 05			ld a, (.dmark+2)  
0534 32 6d ee			ld (debug_mark+2),a  
0537 18 03			jr .pastdmark  
0539 ..			.dmark: db "ER2"  
053c f1			.pastdmark: pop af  
053d			endm  
# End of macro DMARK
053d						CALLMONITOR 
053d cd 6f ee			call debug_vector  
0540				endm  
# End of macro CALLMONITOR
0540					endif 
0540 cd dd 02			call storage_write_block 
0543			 
0543			 
0543				; wipe file extents 
0543			 
0543 3a 6d ea			ld a, (store_tmpext) 
0546 47				ld b, a 
0547			 
0547			.eraext:	  
0547 c5				push bc 
0548			 
0548 21 40 00			ld hl, STORE_BLOCK_PHY 
054b 3a 6e ea			ld a,(store_tmpid) 
054e 5f				ld e, a 
054f 50				ld d, b	 
0550					if DEBUG_FORTH_WORDS 
0550						DMARK "ER3" 
0550 f5				push af  
0551 3a 65 05			ld a, (.dmark)  
0554 32 6b ee			ld (debug_mark),a  
0557 3a 66 05			ld a, (.dmark+1)  
055a 32 6c ee			ld (debug_mark+1),a  
055d 3a 67 05			ld a, (.dmark+2)  
0560 32 6d ee			ld (debug_mark+2),a  
0563 18 03			jr .pastdmark  
0565 ..			.dmark: db "ER3"  
0568 f1			.pastdmark: pop af  
0569			endm  
# End of macro DMARK
0569						CALLMONITOR 
0569 cd 6f ee			call debug_vector  
056c				endm  
# End of macro CALLMONITOR
056c					endif 
056c cd ab 05			call storage_findnextid 
056f cd 0f 0e			call ishlzero 
0572 ca b8 04			jp z,.se_done 
0575			 
0575 e5				push hl 
0576 11 7a ea			ld de, store_page 
0579 cd 78 02			call storage_read_block 
057c			 
057c				; free block	 
057c			 
057c 3e 00			ld a, 0 
057e 32 7a ea			ld (store_page), a 
0581 32 7b ea			ld (store_page+1),a 
0584 11 7a ea			ld de, store_page 
0587 e1				pop hl 
0588					if DEBUG_FORTH_WORDS 
0588						DMARK "ER4" 
0588 f5				push af  
0589 3a 9d 05			ld a, (.dmark)  
058c 32 6b ee			ld (debug_mark),a  
058f 3a 9e 05			ld a, (.dmark+1)  
0592 32 6c ee			ld (debug_mark+1),a  
0595 3a 9f 05			ld a, (.dmark+2)  
0598 32 6d ee			ld (debug_mark+2),a  
059b 18 03			jr .pastdmark  
059d ..			.dmark: db "ER4"  
05a0 f1			.pastdmark: pop af  
05a1			endm  
# End of macro DMARK
05a1						CALLMONITOR 
05a1 cd 6f ee			call debug_vector  
05a4				endm  
# End of macro CALLMONITOR
05a4					endif 
05a4 cd dd 02			call storage_write_block 
05a7			 
05a7 c1				pop bc 
05a8 10 9d			djnz .eraext 
05aa			 
05aa c9				ret 
05ab			 
05ab			 
05ab			; Find Free Block 
05ab			; --------------- 
05ab			; 
05ab			; With current bank 
05ab			;  
05ab			; From given starting logical block 
05ab			;    Read block  
05ab			;    If no file id 
05ab			;         Return block id 
05ab			 
05ab			 
05ab			; hl starting page number 
05ab			; hl contains free page number or zero if no pages free 
05ab			; e contains the file id to locate 
05ab			; d contains the block number 
05ab			 
05ab			; TODO change to find file id and use zero for free block 
05ab			 
05ab			storage_findnextid: 
05ab			 
05ab				; now locate first 0 page to mark as a free block 
05ab			 
05ab 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ad			;	ld hl, STORE_BLOCK_PHY 
05ad			 
05ad					if DEBUG_FORTH_WORDS 
05ad					DMARK "FNI" 
05ad f5				push af  
05ae 3a c2 05			ld a, (.dmark)  
05b1 32 6b ee			ld (debug_mark),a  
05b4 3a c3 05			ld a, (.dmark+1)  
05b7 32 6c ee			ld (debug_mark+1),a  
05ba 3a c4 05			ld a, (.dmark+2)  
05bd 32 6d ee			ld (debug_mark+2),a  
05c0 18 03			jr .pastdmark  
05c2 ..			.dmark: db "FNI"  
05c5 f1			.pastdmark: pop af  
05c6			endm  
# End of macro DMARK
05c6						CALLMONITOR 
05c6 cd 6f ee			call debug_vector  
05c9				endm  
# End of macro CALLMONITOR
05c9					endif 
05c9			.ff1:   	 
05c9 e5					push hl 
05ca c5					push bc 
05cb d5					push de 
05cc cd 9c 01				call se_readbyte 
05cf 5f					ld e,a 
05d0 23					inc hl 
05d1 cd 9c 01				call se_readbyte 
05d4 57					ld d, a 
05d5 e1					pop hl 
05d6 e5					push hl 
05d7 cd 04 0e				call cmp16 
05da 28 49				jr z, .fffound 
05dc			 
05dc d1					pop de 
05dd c1					pop bc 
05de e1					pop hl 
05df			 
05df					; is found? 
05df					;cp e 
05df					;ret z 
05df			 
05df 3e 40				ld a, STORE_BLOCK_PHY 
05e1 cd e6 0d				call addatohl 
05e4 10 e3				djnz .ff1 
05e6			 
05e6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e8			.ff2:   	 
05e8			 
05e8 e5					push hl 
05e9 c5					push bc 
05ea d5					push de 
05eb cd 9c 01				call se_readbyte 
05ee 5f					ld e,a 
05ef 23					inc hl 
05f0 cd 9c 01				call se_readbyte 
05f3 57					ld d, a 
05f4			 
05f4 e1					pop hl 
05f5 e5					push hl 
05f6 cd 04 0e				call cmp16 
05f9 28 2a				jr z, .fffound 
05fb			 
05fb d1					pop de 
05fc c1					pop bc 
05fd e1					pop hl 
05fe					; is found? 
05fe					;cp e 
05fe					;ret z 
05fe			 
05fe 3e 40				ld a, STORE_BLOCK_PHY 
0600 cd e6 0d				call addatohl 
0603 10 e3				djnz .ff2 
0605			 
0605			 
0605					if DEBUG_FORTH_WORDS 
0605					DMARK "FN-" 
0605 f5				push af  
0606 3a 1a 06			ld a, (.dmark)  
0609 32 6b ee			ld (debug_mark),a  
060c 3a 1b 06			ld a, (.dmark+1)  
060f 32 6c ee			ld (debug_mark+1),a  
0612 3a 1c 06			ld a, (.dmark+2)  
0615 32 6d ee			ld (debug_mark+2),a  
0618 18 03			jr .pastdmark  
061a ..			.dmark: db "FN-"  
061d f1			.pastdmark: pop af  
061e			endm  
# End of macro DMARK
061e					;	push af 
061e					;	ld a, 'n' 
061e					;	ld (debug_mark),a 
061e					;	pop af 
061e						CALLMONITOR 
061e cd 6f ee			call debug_vector  
0621				endm  
# End of macro CALLMONITOR
0621					endif 
0621				; no free marks! 
0621 21 00 00				ld hl, 0 
0624 c9				ret 
0625			.fffound: 
0625				 
0625			 
0625 d1					pop de 
0626 c1					pop bc 
0627 e1					pop hl 
0628					if DEBUG_FORTH_WORDS 
0628					DMARK "FNF" 
0628 f5				push af  
0629 3a 3d 06			ld a, (.dmark)  
062c 32 6b ee			ld (debug_mark),a  
062f 3a 3e 06			ld a, (.dmark+1)  
0632 32 6c ee			ld (debug_mark+1),a  
0635 3a 3f 06			ld a, (.dmark+2)  
0638 32 6d ee			ld (debug_mark+2),a  
063b 18 03			jr .pastdmark  
063d ..			.dmark: db "FNF"  
0640 f1			.pastdmark: pop af  
0641			endm  
# End of macro DMARK
0641					;	push af 
0641					;	ld a, 'n' 
0641					;	ld (debug_mark),a 
0641					;	pop af 
0641						CALLMONITOR 
0641 cd 6f ee			call debug_vector  
0644				endm  
# End of macro CALLMONITOR
0644					endif 
0644 c9				ret 
0645			 
0645			 
0645			 
0645			; Free Space 
0645			; ---------- 
0645			; 
0645			; With current bank 
0645			; 
0645			; Set block count to zero 
0645			; Starting with first logical block 
0645			;      Find free block  
0645			;      If block id given, increment block count 
0645			; 
0645			;  
0645			 
0645			 
0645			; hl contains count of free blocks 
0645			 
0645			storage_freeblocks: 
0645			 
0645				; now locate first 0 page to mark as a free block 
0645			 
0645 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0647 21 40 00			ld hl, STORE_BLOCK_PHY 
064a 11 00 00			ld de, 0 
064d			 
064d			.fb1:   	 
064d e5					push hl 
064e c5					push bc 
064f d5					push de 
0650 cd 9c 01				call se_readbyte 
0653 d1					pop de 
0654 c1					pop bc 
0655 e1					pop hl 
0656			 
0656					; is free? 
0656 fe 00				cp 0 
0658 20 01				jr nz, .ff1cont 
065a 13					inc de 
065b			 
065b			.ff1cont: 
065b			 
065b			 
065b 3e 40				ld a, STORE_BLOCK_PHY 
065d cd e6 0d				call addatohl 
0660 10 eb				djnz .fb1 
0662			 
0662 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0664			.fb2:   	 
0664 e5					push hl 
0665 c5					push bc 
0666 d5					push de 
0667 cd 9c 01				call se_readbyte 
066a d1					pop de 
066b c1					pop bc 
066c e1					pop hl 
066d			 
066d					; is free? 
066d fe 00				cp 0 
066f 20 01				jr nz, .ff2cont 
0671 13					inc de 
0672			 
0672			.ff2cont: 
0672			 
0672 3e 40				ld a, STORE_BLOCK_PHY 
0674 cd e6 0d				call addatohl 
0677 10 eb				djnz .fb2 
0679			 
0679 eb				ex de, hl 
067a c9				ret 
067b			 
067b			; Get File ID 
067b			; ----------- 
067b			; 
067b			; With current bank 
067b			;  
067b			; Load Block 0 Config 
067b			; Get max file id number 
067b			; For each logical block 
067b			;    Read block file id 
067b			;      If first block of file and dont have file id 
067b			;         if file get id and exit 
067b			 
067b			 
067b			 
067b			 
067b			; Create File 
067b			; ----------- 
067b			; 
067b			; With current bank  
067b			; Load Block 0 Config 
067b			; Get max file id number 
067b			; Increment file id number 
067b			; Save Config 
067b			; Find free block 
067b			; Set buffer with file name and file id 
067b			; Write buffer to free block  
067b			 
067b			 
067b			; hl point to file name 
067b			; hl returns file id 
067b			 
067b			; file format: 
067b			; byte 0 - file id 
067b			; byte 1 - extent number 
067b			; byte 2-> data 
067b			 
067b			; format for extent number 0: 
067b			; 
067b			; byte 0 - file id 
067b			; byte 1 - extent 0 
067b			; byte 2 - extent count 
067b			; byte 3 -> file name and meta data 
067b			 
067b			 
067b			storage_create: 
067b				if DEBUG_STORESE 
067b					DMARK "SCR" 
067b f5				push af  
067c 3a 90 06			ld a, (.dmark)  
067f 32 6b ee			ld (debug_mark),a  
0682 3a 91 06			ld a, (.dmark+1)  
0685 32 6c ee			ld (debug_mark+1),a  
0688 3a 92 06			ld a, (.dmark+2)  
068b 32 6d ee			ld (debug_mark+2),a  
068e 18 03			jr .pastdmark  
0690 ..			.dmark: db "SCR"  
0693 f1			.pastdmark: pop af  
0694			endm  
# End of macro DMARK
0694					CALLMONITOR 
0694 cd 6f ee			call debug_vector  
0697				endm  
# End of macro CALLMONITOR
0697				endif 
0697			 
0697 e5				push hl		; save file name pointer 
0698			 
0698 cd 29 03			call storage_get_block_0 
069b			 
069b 3a 7a ea			ld a,(store_page)	; get current file id 
069e 3c				inc a 
069f 32 7a ea			ld (store_page),a 
06a2				 
06a2 32 6e ea			ld (store_tmpid),a			; save id 
06a5			 
06a5 21 00 00			ld hl, 0 
06a8 11 7a ea			ld de, store_page 
06ab				if DEBUG_STORESE 
06ab					DMARK "SCw" 
06ab f5				push af  
06ac 3a c0 06			ld a, (.dmark)  
06af 32 6b ee			ld (debug_mark),a  
06b2 3a c1 06			ld a, (.dmark+1)  
06b5 32 6c ee			ld (debug_mark+1),a  
06b8 3a c2 06			ld a, (.dmark+2)  
06bb 32 6d ee			ld (debug_mark+2),a  
06be 18 03			jr .pastdmark  
06c0 ..			.dmark: db "SCw"  
06c3 f1			.pastdmark: pop af  
06c4			endm  
# End of macro DMARK
06c4					CALLMONITOR 
06c4 cd 6f ee			call debug_vector  
06c7				endm  
# End of macro CALLMONITOR
06c7				endif 
06c7 cd dd 02			call storage_write_block	 ; save update 
06ca			 
06ca				if DEBUG_STORESE 
06ca 11 7a ea				ld de, store_page 
06cd					DMARK "SCC" 
06cd f5				push af  
06ce 3a e2 06			ld a, (.dmark)  
06d1 32 6b ee			ld (debug_mark),a  
06d4 3a e3 06			ld a, (.dmark+1)  
06d7 32 6c ee			ld (debug_mark+1),a  
06da 3a e4 06			ld a, (.dmark+2)  
06dd 32 6d ee			ld (debug_mark+2),a  
06e0 18 03			jr .pastdmark  
06e2 ..			.dmark: db "SCC"  
06e5 f1			.pastdmark: pop af  
06e6			endm  
# End of macro DMARK
06e6					CALLMONITOR 
06e6 cd 6f ee			call debug_vector  
06e9				endm  
# End of macro CALLMONITOR
06e9				endif 
06e9				;  
06e9				 
06e9 21 40 00			ld hl, STORE_BLOCK_PHY 
06ec 11 00 00			ld de, 0 
06ef cd ab 05			call storage_findnextid 
06f2			 
06f2 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
06f5			 
06f5				; TODO detect 0 = no spare blocks 
06f5			 
06f5				; hl now contains the free page to use for the file header page 
06f5			 
06f5				if DEBUG_STORESE 
06f5				DMARK "SCF" 
06f5 f5				push af  
06f6 3a 0a 07			ld a, (.dmark)  
06f9 32 6b ee			ld (debug_mark),a  
06fc 3a 0b 07			ld a, (.dmark+1)  
06ff 32 6c ee			ld (debug_mark+1),a  
0702 3a 0c 07			ld a, (.dmark+2)  
0705 32 6d ee			ld (debug_mark+2),a  
0708 18 03			jr .pastdmark  
070a ..			.dmark: db "SCF"  
070d f1			.pastdmark: pop af  
070e			endm  
# End of macro DMARK
070e					CALLMONITOR 
070e cd 6f ee			call debug_vector  
0711				endm  
# End of macro CALLMONITOR
0711				endif 
0711			 
0711 22 65 ea			ld (store_tmppageid), hl 
0714				 
0714 3a 6e ea			ld a,(store_tmpid)    ; get file id 
0717			;	ld a, (store_filecache)			; save to cache 
0717			 
0717 32 7a ea			ld (store_page),a    ; set page id 
071a 3e 00			ld a, 0			 ; extent 0 is file header 
071c 32 7b ea			ld (store_page+1), a   ; set file extent 
071f			 
071f 32 7c ea			ld (store_page+2), a   ; extent count for the file 
0722			 
0722			;	inc hl 		; init block 0 of file 
0722			;	inc hl   		; skip file and extent id 
0722			 ;       ld a, 0 
0722			;	ld (hl),a 
0722			;	ld a, (store_filecache+1)  	; save to cache 
0722			 
0722			;	inc hl    ; file name 
0722				 
0722				 
0722 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0725				if DEBUG_STORESE 
0725					DMARK "SCc" 
0725 f5				push af  
0726 3a 3a 07			ld a, (.dmark)  
0729 32 6b ee			ld (debug_mark),a  
072c 3a 3b 07			ld a, (.dmark+1)  
072f 32 6c ee			ld (debug_mark+1),a  
0732 3a 3c 07			ld a, (.dmark+2)  
0735 32 6d ee			ld (debug_mark+2),a  
0738 18 03			jr .pastdmark  
073a ..			.dmark: db "SCc"  
073d f1			.pastdmark: pop af  
073e			endm  
# End of macro DMARK
073e					CALLMONITOR 
073e cd 6f ee			call debug_vector  
0741				endm  
# End of macro CALLMONITOR
0741				endif 
0741 e1				pop hl    ; get zero term string 
0742 e5				push hl 
0743 3e 00			ld a, 0 
0745 cd 64 11			call strlent 
0748 23				inc hl   ; cover zero term 
0749 06 00			ld b,0 
074b 4d				ld c,l 
074c e1				pop hl 
074d				;ex de, hl 
074d				if DEBUG_STORESE 
074d					DMARK "SCa" 
074d f5				push af  
074e 3a 62 07			ld a, (.dmark)  
0751 32 6b ee			ld (debug_mark),a  
0754 3a 63 07			ld a, (.dmark+1)  
0757 32 6c ee			ld (debug_mark+1),a  
075a 3a 64 07			ld a, (.dmark+2)  
075d 32 6d ee			ld (debug_mark+2),a  
0760 18 03			jr .pastdmark  
0762 ..			.dmark: db "SCa"  
0765 f1			.pastdmark: pop af  
0766			endm  
# End of macro DMARK
0766					;push af 
0766					;ld a, 'a' 
0766					;ld (debug_mark),a 
0766					;pop af 
0766					CALLMONITOR 
0766 cd 6f ee			call debug_vector  
0769				endm  
# End of macro CALLMONITOR
0769				endif 
0769 ed b0			ldir    ; copy zero term string 
076b				if DEBUG_STORESE 
076b					DMARK "SCA" 
076b f5				push af  
076c 3a 80 07			ld a, (.dmark)  
076f 32 6b ee			ld (debug_mark),a  
0772 3a 81 07			ld a, (.dmark+1)  
0775 32 6c ee			ld (debug_mark+1),a  
0778 3a 82 07			ld a, (.dmark+2)  
077b 32 6d ee			ld (debug_mark+2),a  
077e 18 03			jr .pastdmark  
0780 ..			.dmark: db "SCA"  
0783 f1			.pastdmark: pop af  
0784			endm  
# End of macro DMARK
0784					CALLMONITOR 
0784 cd 6f ee			call debug_vector  
0787				endm  
# End of macro CALLMONITOR
0787				endif 
0787			 
0787				; write file header page 
0787			 
0787 2a 65 ea			ld hl,(store_tmppageid) 
078a 11 7a ea			ld de, store_page 
078d				if DEBUG_STORESE 
078d					DMARK "SCb" 
078d f5				push af  
078e 3a a2 07			ld a, (.dmark)  
0791 32 6b ee			ld (debug_mark),a  
0794 3a a3 07			ld a, (.dmark+1)  
0797 32 6c ee			ld (debug_mark+1),a  
079a 3a a4 07			ld a, (.dmark+2)  
079d 32 6d ee			ld (debug_mark+2),a  
07a0 18 03			jr .pastdmark  
07a2 ..			.dmark: db "SCb"  
07a5 f1			.pastdmark: pop af  
07a6			endm  
# End of macro DMARK
07a6					;push af 
07a6					;ld a, 'b' 
07a6					;ld (debug_mark),a 
07a6					;pop af 
07a6					CALLMONITOR 
07a6 cd 6f ee			call debug_vector  
07a9				endm  
# End of macro CALLMONITOR
07a9				endif 
07a9 cd dd 02			call storage_write_block 
07ac			 
07ac 3a 6e ea			ld a, (store_tmpid) 
07af 6f				ld l, a 
07b0 26 00			ld h,0 
07b2				if DEBUG_STORESE 
07b2					DMARK "SCz" 
07b2 f5				push af  
07b3 3a c7 07			ld a, (.dmark)  
07b6 32 6b ee			ld (debug_mark),a  
07b9 3a c8 07			ld a, (.dmark+1)  
07bc 32 6c ee			ld (debug_mark+1),a  
07bf 3a c9 07			ld a, (.dmark+2)  
07c2 32 6d ee			ld (debug_mark+2),a  
07c5 18 03			jr .pastdmark  
07c7 ..			.dmark: db "SCz"  
07ca f1			.pastdmark: pop af  
07cb			endm  
# End of macro DMARK
07cb					CALLMONITOR 
07cb cd 6f ee			call debug_vector  
07ce				endm  
# End of macro CALLMONITOR
07ce				endif 
07ce c9				ret 
07cf				 
07cf			 
07cf			 
07cf			; 
07cf			; Read File 
07cf			; 
07cf			; h - file id to locate 
07cf			; l - extent to locate 
07cf			; de - pointer to string to read into 
07cf			; 
07cf			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07cf			 
07cf			.sr_fail: 
07cf d1				pop de 
07d0 c9				ret 
07d1			 
07d1			storage_read: 
07d1			 
07d1			 
07d1 d5				push de 
07d2			 
07d2			; TODO BUG the above push is it popped before the RET Z? 
07d2			 
07d2			; TODO how to handle multiple part blocks 
07d2			 
07d2				; locate file extent to read 
07d2			 
07d2 5c				ld e, h 
07d3 55				ld d, l 
07d4			 
07d4			.srext: 
07d4 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
07d7 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07db			 
07db 21 40 00			ld hl, STORE_BLOCK_PHY 
07de				if DEBUG_STORESE 
07de					DMARK "sre" 
07de f5				push af  
07df 3a f3 07			ld a, (.dmark)  
07e2 32 6b ee			ld (debug_mark),a  
07e5 3a f4 07			ld a, (.dmark+1)  
07e8 32 6c ee			ld (debug_mark+1),a  
07eb 3a f5 07			ld a, (.dmark+2)  
07ee 32 6d ee			ld (debug_mark+2),a  
07f1 18 03			jr .pastdmark  
07f3 ..			.dmark: db "sre"  
07f6 f1			.pastdmark: pop af  
07f7			endm  
# End of macro DMARK
07f7					CALLMONITOR 
07f7 cd 6f ee			call debug_vector  
07fa				endm  
# End of macro CALLMONITOR
07fa				endif 
07fa cd ab 05			call storage_findnextid 
07fd			 
07fd				if DEBUG_STORESE 
07fd					DMARK "srf" 
07fd f5				push af  
07fe 3a 12 08			ld a, (.dmark)  
0801 32 6b ee			ld (debug_mark),a  
0804 3a 13 08			ld a, (.dmark+1)  
0807 32 6c ee			ld (debug_mark+1),a  
080a 3a 14 08			ld a, (.dmark+2)  
080d 32 6d ee			ld (debug_mark+2),a  
0810 18 03			jr .pastdmark  
0812 ..			.dmark: db "srf"  
0815 f1			.pastdmark: pop af  
0816			endm  
# End of macro DMARK
0816					CALLMONITOR 
0816 cd 6f ee			call debug_vector  
0819				endm  
# End of macro CALLMONITOR
0819				endif 
0819 cd 0f 0e			call ishlzero 
081c			;	ld a, l 
081c			;	add h 
081c			;	cp 0 
081c 28 b1			jr z,.sr_fail			; block not found so EOF 
081e			 
081e				; save current address for use by higher level words etc 
081e			 
081e 22 6b ea			ld (store_openaddr),hl 
0821			 
0821			 
0821				; hl contains page number to load 
0821 d1				pop de   ; get storage 
0822 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
0826 d5				push de 
0827				if DEBUG_STORESE 
0827					DMARK "srg" 
0827 f5				push af  
0828 3a 3c 08			ld a, (.dmark)  
082b 32 6b ee			ld (debug_mark),a  
082e 3a 3d 08			ld a, (.dmark+1)  
0831 32 6c ee			ld (debug_mark+1),a  
0834 3a 3e 08			ld a, (.dmark+2)  
0837 32 6d ee			ld (debug_mark+2),a  
083a 18 03			jr .pastdmark  
083c ..			.dmark: db "srg"  
083f f1			.pastdmark: pop af  
0840			endm  
# End of macro DMARK
0840					CALLMONITOR 
0840 cd 6f ee			call debug_vector  
0843				endm  
# End of macro CALLMONITOR
0843				endif 
0843 cd 78 02			call storage_read_block 
0846			 
0846				; if this a continuation read??? 
0846			 
0846 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0849			 
0849 3e 3f			ld a, STORE_BLOCK_PHY-1 
084b cd e6 0d			call addatohl 
084e 7e				ld a,(hl) 
084f fe 00			cp 0 
0851 28 02			jr z, .markiscont 
0853 3e ff			ld a, 255 
0855			 
0855			.markiscont: 
0855 32 6d ea			ld (store_readcont), a 
0858			 
0858				if DEBUG_STORESE 
0858					DMARK "srC" 
0858 f5				push af  
0859 3a 6d 08			ld a, (.dmark)  
085c 32 6b ee			ld (debug_mark),a  
085f 3a 6e 08			ld a, (.dmark+1)  
0862 32 6c ee			ld (debug_mark+1),a  
0865 3a 6f 08			ld a, (.dmark+2)  
0868 32 6d ee			ld (debug_mark+2),a  
086b 18 03			jr .pastdmark  
086d ..			.dmark: db "srC"  
0870 f1			.pastdmark: pop af  
0871			endm  
# End of macro DMARK
0871					CALLMONITOR 
0871 cd 6f ee			call debug_vector  
0874				endm  
# End of macro CALLMONITOR
0874				endif 
0874				; only short reads enabled 
0874			 
0874 3a 75 ea			ld a, (store_longread) 
0877 fe 00			cp 0 
0879 ca 46 09			jp z, .readdone 
087c			 
087c			; TODO if block has no zeros then need to read next block  
087c			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
087c			; check last byte of physical block. 
087c			; if not zero then the next block needs to be loaded 
087c			 
087c			 
087c 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
087f			 
087f 3e 3f			ld a, STORE_BLOCK_PHY-1 
0881 cd e6 0d			call addatohl 
0884				;dec hl 
0884 7e				ld a,(hl) 
0885				if DEBUG_STORESE 
0885					DMARK "sr?" 
0885 f5				push af  
0886 3a 9a 08			ld a, (.dmark)  
0889 32 6b ee			ld (debug_mark),a  
088c 3a 9b 08			ld a, (.dmark+1)  
088f 32 6c ee			ld (debug_mark+1),a  
0892 3a 9c 08			ld a, (.dmark+2)  
0895 32 6d ee			ld (debug_mark+2),a  
0898 18 03			jr .pastdmark  
089a ..			.dmark: db "sr?"  
089d f1			.pastdmark: pop af  
089e			endm  
# End of macro DMARK
089e					CALLMONITOR 
089e cd 6f ee			call debug_vector  
08a1				endm  
# End of macro CALLMONITOR
08a1				endif 
08a1 fe 00			cp 0 
08a3 ca 46 09			jp z, .readdone 
08a6			 
08a6				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a6			 
08a6 23				inc hl 
08a7			 
08a7 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08aa			 
08aa ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
08ae			 
08ae eb				ex de, hl 
08af			 
08af				; next ext 
08af			 
08af 23				inc hl 
08b0 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
08b3			 
08b3				if DEBUG_STORESE 
08b3					DMARK "sF2" 
08b3 f5				push af  
08b4 3a c8 08			ld a, (.dmark)  
08b7 32 6b ee			ld (debug_mark),a  
08ba 3a c9 08			ld a, (.dmark+1)  
08bd 32 6c ee			ld (debug_mark+1),a  
08c0 3a ca 08			ld a, (.dmark+2)  
08c3 32 6d ee			ld (debug_mark+2),a  
08c6 18 03			jr .pastdmark  
08c8 ..			.dmark: db "sF2"  
08cb f1			.pastdmark: pop af  
08cc			endm  
# End of macro DMARK
08cc					CALLMONITOR 
08cc cd 6f ee			call debug_vector  
08cf				endm  
# End of macro CALLMONITOR
08cf				endif 
08cf			 
08cf				; get and load block 
08cf			 
08cf cd ab 05			call storage_findnextid 
08d2			 
08d2				if DEBUG_STORESE 
08d2					DMARK "sf2" 
08d2 f5				push af  
08d3 3a e7 08			ld a, (.dmark)  
08d6 32 6b ee			ld (debug_mark),a  
08d9 3a e8 08			ld a, (.dmark+1)  
08dc 32 6c ee			ld (debug_mark+1),a  
08df 3a e9 08			ld a, (.dmark+2)  
08e2 32 6d ee			ld (debug_mark+2),a  
08e5 18 03			jr .pastdmark  
08e7 ..			.dmark: db "sf2"  
08ea f1			.pastdmark: pop af  
08eb			endm  
# End of macro DMARK
08eb					CALLMONITOR 
08eb cd 6f ee			call debug_vector  
08ee				endm  
# End of macro CALLMONITOR
08ee				endif 
08ee cd 0f 0e			call ishlzero 
08f1			;	ld a, l 
08f1			;	add h 
08f1			;	cp 0 
08f1 ca cf 07			jp z,.sr_fail			; block not found so EOF 
08f4				 
08f4				; save current address for use by higher level words etc 
08f4			 
08f4 22 6b ea			ld (store_openaddr),hl 
08f7			 
08f7 cd 78 02			call storage_read_block 
08fa			 
08fa				; on a continuation block, we now have the file id and ext in the middle of the block 
08fa				; we need to pull everything back  
08fa			 
08fa ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
08fe 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0901 23				inc hl 
0902 23				inc hl     ; skip id and ext 
0903 01 40 00			ld bc, STORE_BLOCK_PHY 
0906				if DEBUG_STORESE 
0906					DMARK "SR<" 
0906 f5				push af  
0907 3a 1b 09			ld a, (.dmark)  
090a 32 6b ee			ld (debug_mark),a  
090d 3a 1c 09			ld a, (.dmark+1)  
0910 32 6c ee			ld (debug_mark+1),a  
0913 3a 1d 09			ld a, (.dmark+2)  
0916 32 6d ee			ld (debug_mark+2),a  
0919 18 03			jr .pastdmark  
091b ..			.dmark: db "SR<"  
091e f1			.pastdmark: pop af  
091f			endm  
# End of macro DMARK
091f					CALLMONITOR 
091f cd 6f ee			call debug_vector  
0922				endm  
# End of macro CALLMONITOR
0922				endif 
0922 ed b0			ldir     ; copy data 
0924			 
0924				; move the pointer back and pretend we have a full buffer for next recheck 
0924			 
0924 1b				dec de 
0925 1b				dec de 
0926			 
0926			; TODO do pop below now short circuit loop????? 
0926 c1				pop bc     ; get rid of spare de on stack 
0927				if DEBUG_STORESE 
0927					DMARK "SR>" 
0927 f5				push af  
0928 3a 3c 09			ld a, (.dmark)  
092b 32 6b ee			ld (debug_mark),a  
092e 3a 3d 09			ld a, (.dmark+1)  
0931 32 6c ee			ld (debug_mark+1),a  
0934 3a 3e 09			ld a, (.dmark+2)  
0937 32 6d ee			ld (debug_mark+2),a  
093a 18 03			jr .pastdmark  
093c ..			.dmark: db "SR>"  
093f f1			.pastdmark: pop af  
0940			endm  
# End of macro DMARK
0940					CALLMONITOR 
0940 cd 6f ee			call debug_vector  
0943				endm  
# End of macro CALLMONITOR
0943				endif 
0943 c3 d4 07			jp .srext 
0946			 
0946			 
0946			 
0946			 
0946			 
0946			.readdone:		 
0946 e1				pop hl 		 ; return start of data to show as not EOF 
0947 23				inc hl   ; past file id 
0948 23				inc hl   ; past ext 
0949				if DEBUG_STORESE 
0949					DMARK "SRe" 
0949 f5				push af  
094a 3a 5e 09			ld a, (.dmark)  
094d 32 6b ee			ld (debug_mark),a  
0950 3a 5f 09			ld a, (.dmark+1)  
0953 32 6c ee			ld (debug_mark+1),a  
0956 3a 60 09			ld a, (.dmark+2)  
0959 32 6d ee			ld (debug_mark+2),a  
095c 18 03			jr .pastdmark  
095e ..			.dmark: db "SRe"  
0961 f1			.pastdmark: pop af  
0962			endm  
# End of macro DMARK
0962					CALLMONITOR 
0962 cd 6f ee			call debug_vector  
0965				endm  
# End of macro CALLMONITOR
0965				endif 
0965 c9					ret 
0966			 
0966			 
0966			 
0966			; 
0966			; Append File 
0966			; 
0966			; hl - file id to locate 
0966			; de - pointer to (multi block) string to write 
0966			 
0966			.sa_notfound: 
0966 d1				pop de 
0967 c9				ret 
0968			 
0968			 
0968			storage_append: 
0968				; hl -  file id to append to 
0968				; de - string to append 
0968			 
0968 d5				push de 
0969				 
0969				if DEBUG_STORESE 
0969					DMARK "AP1" 
0969 f5				push af  
096a 3a 7e 09			ld a, (.dmark)  
096d 32 6b ee			ld (debug_mark),a  
0970 3a 7f 09			ld a, (.dmark+1)  
0973 32 6c ee			ld (debug_mark+1),a  
0976 3a 80 09			ld a, (.dmark+2)  
0979 32 6d ee			ld (debug_mark+2),a  
097c 18 03			jr .pastdmark  
097e ..			.dmark: db "AP1"  
0981 f1			.pastdmark: pop af  
0982			endm  
# End of macro DMARK
0982					CALLMONITOR 
0982 cd 6f ee			call debug_vector  
0985				endm  
# End of macro CALLMONITOR
0985				endif 
0985			 
0985 7d				ld a, l 
0986 32 6e ea			ld (store_tmpid), a 
0989			 
0989				; get file header  
0989			 
0989 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098b 3a 6e ea			ld a, (store_tmpid) 
098e 5f				ld e, a 
098f			 
098f 21 40 00				ld hl, STORE_BLOCK_PHY 
0992 cd ab 05				call storage_findnextid 
0995			 
0995 cd 0f 0e			call ishlzero 
0998 28 cc			jr z, .sa_notfound 
099a			 
099a 22 65 ea			ld (store_tmppageid), hl 
099d			 
099d				; TODO handle file id not found 
099d			 
099d				if DEBUG_STORESE 
099d					DMARK "AP2" 
099d f5				push af  
099e 3a b2 09			ld a, (.dmark)  
09a1 32 6b ee			ld (debug_mark),a  
09a4 3a b3 09			ld a, (.dmark+1)  
09a7 32 6c ee			ld (debug_mark+1),a  
09aa 3a b4 09			ld a, (.dmark+2)  
09ad 32 6d ee			ld (debug_mark+2),a  
09b0 18 03			jr .pastdmark  
09b2 ..			.dmark: db "AP2"  
09b5 f1			.pastdmark: pop af  
09b6			endm  
# End of macro DMARK
09b6					CALLMONITOR 
09b6 cd 6f ee			call debug_vector  
09b9				endm  
# End of macro CALLMONITOR
09b9				endif 
09b9			 
09b9				; update file extent count 
09b9			 
09b9 11 7a ea			ld de, store_page 
09bc			 
09bc cd 78 02			call storage_read_block 
09bf			 
09bf				if DEBUG_STORESE 
09bf					DMARK "AP3" 
09bf f5				push af  
09c0 3a d4 09			ld a, (.dmark)  
09c3 32 6b ee			ld (debug_mark),a  
09c6 3a d5 09			ld a, (.dmark+1)  
09c9 32 6c ee			ld (debug_mark+1),a  
09cc 3a d6 09			ld a, (.dmark+2)  
09cf 32 6d ee			ld (debug_mark+2),a  
09d2 18 03			jr .pastdmark  
09d4 ..			.dmark: db "AP3"  
09d7 f1			.pastdmark: pop af  
09d8			endm  
# End of macro DMARK
09d8					CALLMONITOR 
09d8 cd 6f ee			call debug_vector  
09db				endm  
# End of macro CALLMONITOR
09db				endif 
09db			;	ld (store_tmppageid), hl 
09db			 
09db 3a 7c ea			ld a, (store_page+2) 
09de 3c				inc a 
09df 32 7c ea			ld (store_page+2), a 
09e2 32 6d ea			ld (store_tmpext), a 
09e5				 
09e5				if DEBUG_STORESE 
09e5					DMARK "AP3" 
09e5 f5				push af  
09e6 3a fa 09			ld a, (.dmark)  
09e9 32 6b ee			ld (debug_mark),a  
09ec 3a fb 09			ld a, (.dmark+1)  
09ef 32 6c ee			ld (debug_mark+1),a  
09f2 3a fc 09			ld a, (.dmark+2)  
09f5 32 6d ee			ld (debug_mark+2),a  
09f8 18 03			jr .pastdmark  
09fa ..			.dmark: db "AP3"  
09fd f1			.pastdmark: pop af  
09fe			endm  
# End of macro DMARK
09fe					CALLMONITOR 
09fe cd 6f ee			call debug_vector  
0a01				endm  
# End of macro CALLMONITOR
0a01				endif 
0a01 2a 65 ea			ld hl, (store_tmppageid) 
0a04 11 7a ea			ld de, store_page 
0a07 cd dd 02			call storage_write_block 
0a0a			 
0a0a				; find free block 
0a0a			 
0a0a 11 00 00			ld de, 0			 ; file extent to locate 
0a0d			 
0a0d 21 40 00				ld hl, STORE_BLOCK_PHY 
0a10 cd ab 05				call storage_findnextid 
0a13 cd 0f 0e			call ishlzero 
0a16 ca 66 09			jp z, .sa_notfound 
0a19			 
0a19					; TODO handle no space left 
0a19					 
0a19 22 65 ea				ld (store_tmppageid), hl 
0a1c			 
0a1c				if DEBUG_STORESE 
0a1c					DMARK "AP4" 
0a1c f5				push af  
0a1d 3a 31 0a			ld a, (.dmark)  
0a20 32 6b ee			ld (debug_mark),a  
0a23 3a 32 0a			ld a, (.dmark+1)  
0a26 32 6c ee			ld (debug_mark+1),a  
0a29 3a 33 0a			ld a, (.dmark+2)  
0a2c 32 6d ee			ld (debug_mark+2),a  
0a2f 18 03			jr .pastdmark  
0a31 ..			.dmark: db "AP4"  
0a34 f1			.pastdmark: pop af  
0a35			endm  
# End of macro DMARK
0a35					CALLMONITOR 
0a35 cd 6f ee			call debug_vector  
0a38				endm  
# End of macro CALLMONITOR
0a38				endif 
0a38					; init the buffer with zeros so we can id if the buffer is full or not 
0a38			 
0a38 e5					push hl 
0a39 c5					push bc 
0a3a			 
0a3a 21 7a ea				ld hl, store_page 
0a3d 06 40				ld b, STORE_BLOCK_PHY 
0a3f 3e 00				ld a, 0 
0a41 77			.zeroblock:	ld (hl), a 
0a42 23					inc hl 
0a43 10 fc				djnz .zeroblock 
0a45			 
0a45 c1					pop bc 
0a46 e1					pop hl 
0a47			 
0a47					; construct block 
0a47			 
0a47 3a 6e ea				ld a, (store_tmpid) 
0a4a 32 7a ea				ld (store_page), a   ; file id 
0a4d 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
0a50 32 7b ea				ld (store_page+1), a 
0a53			 
0a53 e1					pop hl    ; get string to write 
0a54 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a56 11 7c ea				ld de, store_page+2 
0a59			 
0a59				if DEBUG_STORESE 
0a59					DMARK "AP5" 
0a59 f5				push af  
0a5a 3a 6e 0a			ld a, (.dmark)  
0a5d 32 6b ee			ld (debug_mark),a  
0a60 3a 6f 0a			ld a, (.dmark+1)  
0a63 32 6c ee			ld (debug_mark+1),a  
0a66 3a 70 0a			ld a, (.dmark+2)  
0a69 32 6d ee			ld (debug_mark+2),a  
0a6c 18 03			jr .pastdmark  
0a6e ..			.dmark: db "AP5"  
0a71 f1			.pastdmark: pop af  
0a72			endm  
# End of macro DMARK
0a72					CALLMONITOR 
0a72 cd 6f ee			call debug_vector  
0a75				endm  
# End of macro CALLMONITOR
0a75				endif 
0a75			 
0a75			 
0a75			 
0a75					; fill buffer with data until end of string or full block 
0a75			 
0a75 7e			.appd:		ld a, (hl) 
0a76 12					ld (de), a 
0a77 fe 00				cp 0 
0a79 28 04				jr z, .appdone 
0a7b 23					inc hl 
0a7c 13					inc de 
0a7d 10 f6				djnz .appd 
0a7f			 
0a7f e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a80 f5					push af   		; save last byte dumped 
0a81			 
0a81			 
0a81 2a 65 ea			ld hl, (store_tmppageid) 
0a84 11 7a ea			ld de, store_page 
0a87				if DEBUG_STORESE 
0a87					DMARK "AP6" 
0a87 f5				push af  
0a88 3a 9c 0a			ld a, (.dmark)  
0a8b 32 6b ee			ld (debug_mark),a  
0a8e 3a 9d 0a			ld a, (.dmark+1)  
0a91 32 6c ee			ld (debug_mark+1),a  
0a94 3a 9e 0a			ld a, (.dmark+2)  
0a97 32 6d ee			ld (debug_mark+2),a  
0a9a 18 03			jr .pastdmark  
0a9c ..			.dmark: db "AP6"  
0a9f f1			.pastdmark: pop af  
0aa0			endm  
# End of macro DMARK
0aa0					CALLMONITOR 
0aa0 cd 6f ee			call debug_vector  
0aa3				endm  
# End of macro CALLMONITOR
0aa3				endif 
0aa3 cd dd 02				call storage_write_block 
0aa6			 
0aa6			 
0aa6				; was that a full block of data written? 
0aa6				; any more to write out? 
0aa6			 
0aa6				; if yes then set vars and jump to start of function again 
0aa6			 
0aa6 f1					pop af 
0aa7 d1					pop de 
0aa8			 
0aa8 fe 00				cp 0		 ; no, string was fully written 
0aaa c8					ret z 
0aab			 
0aab					; setup vars for next cycle 
0aab			 
0aab 3a 6e ea				ld a, (store_tmpid) 
0aae 6f					ld l, a 
0aaf 26 00				ld h, 0 
0ab1			 
0ab1 c3 68 09			 	jp storage_append	 ; yes, need to write out some more 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			if DEBUG_STORECF 
0ab4			storageput:	 
0ab4					ret 
0ab4			storageread: 
0ab4					ld hl, store_page 
0ab4					ld b, 200 
0ab4					ld a,0 
0ab4			.src:		ld (hl),a 
0ab4					inc hl 
0ab4					djnz .src 
0ab4					 
0ab4			 
0ab4					ld de, 0 
0ab4					ld bc, 1 
0ab4					ld hl, store_page 
0ab4					call cfRead 
0ab4			 
0ab4				call cfGetError 
0ab4				ld hl,scratch 
0ab4				call hexout 
0ab4				ld hl, scratch+2 
0ab4				ld a, 0 
0ab4				ld (hl),a 
0ab4				ld de, scratch 
0ab4				ld a,display_row_1 
0ab4				call str_at_display 
0ab4				call update_display 
0ab4			 
0ab4					ld hl, store_page 
0ab4					ld (os_cur_ptr),hl 
0ab4			 
0ab4					ret 
0ab4			endif 
0ab4			 
0ab4			 
0ab4			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab4			 
0ab4			storage_clear_page: 
0ab4 e5				push hl 
0ab5 d5				push de 
0ab6 c5				push bc 
0ab7 21 7a ea			ld hl, store_page 
0aba 3e 00			ld a, 0 
0abc 77				ld (hl), a 
0abd			 
0abd 11 7b ea			ld de, store_page+1 
0ac0 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ac3			 
0ac3 ed b0			ldir 
0ac5				 
0ac5 c1				pop bc 
0ac6 d1				pop de 
0ac7 e1				pop hl 
0ac8 c9				ret 
0ac9			 
0ac9			; eof 
# End of file firmware_storage.asm
0ac9			  
0ac9			; support routines for above hardware abstraction layer  
0ac9			  
0ac9			include "firmware_general.asm"        ; general support functions  
0ac9			 
0ac9			; word look up 
0ac9			 
0ac9			; in 
0ac9			; a is the index 
0ac9			; hl is pointer start of array 
0ac9			; 
0ac9			; returns 
0ac9			; hl to the word 
0ac9			; 
0ac9			 
0ac9			table_lookup:  
0ac9 d5					push de 
0aca eb					ex de, hl 
0acb			 
0acb 6f					ld l, a 
0acc 26 00				ld h, 0 
0ace 29					add hl, hl 
0acf 19					add hl, de 
0ad0 7e					ld a, (hl) 
0ad1 23					inc hl 
0ad2 66					ld h,(hl) 
0ad3 6f					ld l, a 
0ad4			 
0ad4 d1					pop de 
0ad5 c9					ret 
0ad6			 
0ad6			; Delay loops 
0ad6			 
0ad6			 
0ad6			 
0ad6			aDelayInMS: 
0ad6 c5				push bc 
0ad7 47				ld b,a 
0ad8			msdelay: 
0ad8 c5				push bc 
0ad9				 
0ad9			 
0ad9 01 41 00			ld bc,041h 
0adc cd f4 0a			call delayloop 
0adf c1				pop bc 
0ae0 05				dec b 
0ae1 20 f5			jr nz,msdelay 
0ae3			 
0ae3			;if CPU_CLOCK_8MHZ 
0ae3			;msdelay8: 
0ae3			;	push bc 
0ae3			;	 
0ae3			; 
0ae3			;	ld bc,041h 
0ae3			;	call delayloop 
0ae3			;	pop bc 
0ae3			;	dec b 
0ae3			;	jr nz,msdelay8 
0ae3			;endif 
0ae3			 
0ae3			 
0ae3 c1				pop bc 
0ae4 c9				ret 
0ae5			 
0ae5			 
0ae5			delay250ms: 
0ae5				;push de 
0ae5 01 00 40			ld bc, 04000h 
0ae8 c3 f4 0a			jp delayloop 
0aeb			delay500ms: 
0aeb				;push de 
0aeb 01 00 80			ld bc, 08000h 
0aee c3 f4 0a			jp delayloop 
0af1			delay1s: 
0af1				;push bc 
0af1			   ; Clobbers A, d and e 
0af1 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af4			delayloop: 
0af4 c5			    push bc 
0af5			 
0af5			if BASE_CPM 
0af5 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af8			.cpmloop: 
0af8 c5				push bc 
0af9			 
0af9			endif 
0af9			 
0af9			 
0af9			 
0af9			delayloopi: 
0af9			;	push bc 
0af9			;.dl: 
0af9 cb 47		    bit     0,a    	; 8 
0afb cb 47		    bit     0,a    	; 8 
0afd cb 47		    bit     0,a    	; 8 
0aff e6 ff		    and     255  	; 7 
0b01 0b			    dec     bc      	; 6 
0b02 79			    ld      a,c     	; 4 
0b03 b0			    or      b     	; 4 
0b04 c2 f9 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b07			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b07				;pop de 
0b07			;pop bc 
0b07			 
0b07			if BASE_CPM 
0b07 c1				pop bc 
0b08				 
0b08 0b			    dec     bc      	; 6 
0b09 79			    ld      a,c     	; 4 
0b0a b0			    or      b     	; 4 
0b0b c2 f8 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0e				 
0b0e			 
0b0e			endif 
0b0e			;if CPU_CLOCK_8MHZ 
0b0e			;    pop bc 
0b0e			;    push bc 
0b0e			;.dl8: 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    and     255  	; 7 
0b0e			;    dec     bc      	; 6 
0b0e			;    ld      a,c     	; 4 
0b0e			;    or      b     	; 4 
0b0e			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0e			;endif 
0b0e			 
0b0e			;if CPU_CLOCK_10MHZ 
0b0e			;    pop bc 
0b0e			;    push bc 
0b0e			;.dl8: 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    and     255  	; 7 
0b0e			;    dec     bc      	; 6 
0b0e			;    ld      a,c     	; 4 
0b0e			;    or      b     	; 4 
0b0e			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0e			;endif 
0b0e c1			    pop bc 
0b0f			 
0b0f c9				ret 
0b10			 
0b10			 
0b10			 
0b10			; eof 
# End of file firmware_general.asm
0b10			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b10			; display routines that use the physical hardware abstraction layer 
0b10			 
0b10			 
0b10			; Display an activity indicator 
0b10			; Each call returns the new char pointed to in hl 
0b10			 
0b10			active: 
0b10 3a c6 eb			ld a, (display_active) 
0b13 fe 06			cp 6 
0b15			 
0b15 20 02			jr nz, .sne 
0b17				; gone past the last one reset sequence 
0b17 3e ff			ld a, 255 
0b19			 
0b19			.sne:   
0b19				; get the next char in seq 
0b19 3c				inc a 
0b1a 32 c6 eb			ld (display_active), a 
0b1d			 
0b1d				; look up the string in the table 
0b1d 21 34 0b			ld hl, actseq 
0b20 cb 27			sla a 
0b22 cd e6 0d			call addatohl 
0b25 cd 96 1e			call loadwordinhl 
0b28			 
0b28				; forth will write the to string when pushing so move from rom to ram 
0b28			 
0b28 11 c7 eb			ld de, display_active+1 
0b2b 01 02 00			ld bc, 2 
0b2e ed b0			ldir 
0b30			 
0b30 21 c7 eb			ld hl, display_active+1 
0b33 c9				ret 
0b34				 
0b34				 
0b34			 
0b34			 
0b34			;db "|/-\|-\" 
0b34			 
0b34			actseq: 
0b34			 
0b34 42 0b		dw spin0 
0b36 44 0b		dw spin1 
0b38 46 0b		dw spin2 
0b3a 48 0b		dw spin3 
0b3c 46 0b		dw spin2 
0b3e 44 0b		dw spin1 
0b40 42 0b		dw spin0 
0b42			 
0b42 .. 00		spin0: db " ", 0 
0b44 .. 00		spin1: db "-", 0 
0b46 .. 00		spin2: db "+", 0 
0b48 .. 00		spin3: db "#", 0 
0b4a			 
0b4a			 
0b4a			; information window 
0b4a			 
0b4a			; pass hl with 1st string to display 
0b4a			; pass de with 2nd string to display 
0b4a			 
0b4a			info_panel: 
0b4a e5				push hl 
0b4b			 
0b4b 2a cc eb			ld hl, (display_fb_active) 
0b4e e5				push hl    ; future de destination 
0b4f 21 b1 ed				ld hl, display_fb0 
0b52 22 cc eb				ld (display_fb_active), hl 
0b55			 
0b55			;	call clear_display 
0b55			 
0b55				if BASE_CPM 
0b55 3e 2e			ld a, '.' 
0b57				else 
0b57				ld a, 165 
0b57				endif 
0b57 cd be 0b			call fill_display 
0b5a			 
0b5a			 
0b5a 3e 55			ld a, display_row_3 + 5 
0b5c cd cc 0b			call str_at_display 
0b5f			 
0b5f e1				pop hl 
0b60 d1				pop de 
0b61			 
0b61 e5				push hl 
0b62			 
0b62			 
0b62 3e 2d			ld a, display_row_2 + 5 
0b64 cd cc 0b			call str_at_display 
0b67			 
0b67			 
0b67 cd dc 0b			call update_display 
0b6a cd df 1a			call next_page_prompt 
0b6d cd b9 0b			call clear_display 
0b70			 
0b70				 
0b70 21 10 ed				ld hl, display_fb1 
0b73 22 cc eb				ld (display_fb_active), hl 
0b76 cd dc 0b			call update_display 
0b79			 
0b79 e1				pop hl 
0b7a			 
0b7a c9				ret 
0b7b			 
0b7b			 
0b7b			 
0b7b			 
0b7b			; TODO windowing? 
0b7b			 
0b7b			; TODO scroll line up 
0b7b			 
0b7b			scroll_up: 
0b7b			 
0b7b e5				push hl 
0b7c d5				push de 
0b7d c5				push bc 
0b7e			 
0b7e				; get frame buffer  
0b7e			 
0b7e 2a cc eb			ld hl, (display_fb_active) 
0b81 e5				push hl    ; future de destination 
0b82			 
0b82 11 28 00			ld  de, display_cols 
0b85 19				add hl, de 
0b86			 
0b86 d1				pop de 
0b87			 
0b87				;ex de, hl 
0b87 01 9f 00			ld bc, display_fb_len -1  
0b8a			;if DEBUG_FORTH_WORDS 
0b8a			;	DMARK "SCL" 
0b8a			;	CALLMONITOR 
0b8a			;endif	 
0b8a ed b0			ldir 
0b8c			 
0b8c				; wipe bottom row 
0b8c			 
0b8c			 
0b8c 2a cc eb			ld hl, (display_fb_active) 
0b8f 11 a0 00			ld de, display_cols*display_rows 
0b92 19				add hl, de 
0b93 06 28			ld b, display_cols 
0b95 3e 20			ld a, ' ' 
0b97			.scwipe: 
0b97 77				ld (hl), a 
0b98 2b				dec hl 
0b99 10 fc			djnz .scwipe 
0b9b			 
0b9b				;pop hl 
0b9b			 
0b9b c1				pop bc 
0b9c d1				pop de 
0b9d e1				pop hl 
0b9e			 
0b9e c9				ret 
0b9f			 
0b9f			 
0b9f			;scroll_upo: 
0b9f			;	ld de, display_row_1 
0b9f			 ;	ld hl, display_row_2 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			;	ld de, display_row_2 
0b9f			 ;	ld hl, display_row_3 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			;	ld de, display_row_3 
0b9f			 ;	ld hl, display_row_4 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			 
0b9f			; TODO clear row 4 
0b9f			 
0b9f			;	ret 
0b9f			 
0b9f				 
0b9f			scroll_down: 
0b9f			 
0b9f e5				push hl 
0ba0 d5				push de 
0ba1 c5				push bc 
0ba2			 
0ba2				; get frame buffer  
0ba2			 
0ba2 2a cc eb			ld hl, (display_fb_active) 
0ba5			 
0ba5 11 9f 00			ld de, display_fb_len - 1 
0ba8 19				add hl, de 
0ba9			 
0ba9 e5			push hl    ; future de destination 
0baa			 
0baa 11 28 00			ld  de, display_cols 
0bad ed 52			sbc hl, de 
0baf			 
0baf			 
0baf d1				pop de 
0bb0			 
0bb0			;	ex de, hl 
0bb0 01 9f 00			ld bc, display_fb_len -1  
0bb3			 
0bb3			 
0bb3				 
0bb3			 
0bb3 ed b0			ldir 
0bb5			 
0bb5				; wipe bottom row 
0bb5			 
0bb5			 
0bb5			;	ld hl, (display_fb_active) 
0bb5			;;	ld de, display_cols*display_rows 
0bb5			;;	add hl, de 
0bb5			;	ld b, display_cols 
0bb5			;	ld a, ' ' 
0bb5			;.scwiped: 
0bb5			;	ld (hl), a 
0bb5			;	dec hl 
0bb5			;	djnz .scwiped 
0bb5			 
0bb5				;pop hl 
0bb5			 
0bb5 c1				pop bc 
0bb6 d1				pop de 
0bb7 e1				pop hl 
0bb8			 
0bb8 c9				ret 
0bb9			;scroll_down: 
0bb9			;	ld de, display_row_4 
0bb9			;	ld hl, display_row_3 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;	ld de, display_row_3 
0bb9			; 	ld hl, display_row_2 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;	ld de, display_row_2 
0bb9			;	ld hl, display_row_1 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;;; TODO clear row 1 
0bb9			;	ret 
0bb9			 
0bb9			 
0bb9			 
0bb9			 
0bb9			 
0bb9			; clear active frame buffer 
0bb9			 
0bb9			clear_display: 
0bb9 3e 20			ld a, ' ' 
0bbb c3 be 0b			jp fill_display 
0bbe			 
0bbe			; fill active frame buffer with a char in A 
0bbe			 
0bbe			fill_display: 
0bbe 06 a0			ld b,display_fb_len 
0bc0 2a cc eb			ld hl, (display_fb_active) 
0bc3 77			.fd1:	ld (hl),a 
0bc4 23				inc hl 
0bc5 10 fc			djnz .fd1 
0bc7 23				inc hl 
0bc8 3e 00			ld a,0 
0bca 77				ld (hl),a 
0bcb			 
0bcb			 
0bcb c9				ret 
0bcc			; Write string (DE) at pos (A) to active frame buffer 
0bcc			 
0bcc 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
0bcf 06 00					ld b,0 
0bd1 4f					ld c,a 
0bd2 09					add hl,bc 
0bd3 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bd4 b7			            OR   A              ;Null terminator? 
0bd5 c8			            RET  Z              ;Yes, so finished 
0bd6 77					ld (hl),a 
0bd7 23				inc hl 
0bd8 13			            INC  DE             ;Point to next character 
0bd9 18 f8		            JR   .sad1     ;Repeat 
0bdb c9					ret 
0bdc			 
0bdc			; using current frame buffer write to physical display 
0bdc			 
0bdc			update_display: 
0bdc e5				push hl 
0bdd 2a cc eb			ld hl, (display_fb_active) 
0be0 cd 89 64			call write_display 
0be3 e1				pop hl 
0be4 c9				ret 
0be5			 
0be5			; TODO scrolling 
0be5			 
0be5			 
0be5			; move cursor right one char 
0be5			cursor_right: 
0be5			 
0be5				; TODO shift right 
0be5				; TODO if beyond max col 
0be5				; TODO       cursor_next_line 
0be5			 
0be5 c9				ret 
0be6			 
0be6			 
0be6			cursor_next_line: 
0be6				; TODO first char 
0be6				; TODO line down 
0be6				; TODO if past last row 
0be6				; TODO    scroll up 
0be6			 
0be6 c9				ret 
0be7			 
0be7			cursor_left: 
0be7				; TODO shift left 
0be7				; TODO if beyond left  
0be7				; TODO     cursor prev line 
0be7				 
0be7 c9				ret 
0be8			 
0be8			cursor_prev_line: 
0be8				; TODO last char 
0be8				; TODO line up 
0be8				; TODO if past first row 
0be8				; TODO   scroll down 
0be8			 
0be8 c9				ret 
0be9			 
0be9			 
0be9			cout: 
0be9				; A - char 
0be9 c9				ret 
0bea			 
0bea			 
0bea			; Display a menu and allow item selection (optional toggle items) 
0bea			; 
0bea			; format: 
0bea			; hl pointer to word array with zero term for items 
0bea			; e.g.    db item1 
0bea			;         db .... 
0bea			;         db 0 
0bea			; 
0bea			; a = starting menu item  
0bea			; 
0bea			; de = pointer item toggle array   (todo) 
0bea			; 
0bea			; returns item selected in a 1-... 
0bea			; returns 0 if back button pressed 
0bea			; 
0bea			; NOTE: Uses system frame buffer to display 
0bea			; 
0bea			; LEFT, Q = go back 
0bea			; RIGHT, SPACE, CR = select 
0bea			; UP, A - Up 
0bea			; DOWN, Z - Down 
0bea			 
0bea			 
0bea			 
0bea			 
0bea			 
0bea			menu: 
0bea			 
0bea					; keep array pointer 
0bea			 
0bea 22 73 ea				ld (store_tmp1), hl 
0bed 32 71 ea				ld (store_tmp2), a 
0bf0			 
0bf0					; check for key bounce 
0bf0			 
0bf0			if BASE_KEV 
0bf0			 
0bf0			.mbounce:	call cin 
0bf0					cp 0 
0bf0					jr nz, .mbounce 
0bf0			endif 
0bf0					; for ease use ex 
0bf0			 
0bf0					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bf0 21 b1 ed				ld hl, display_fb0 
0bf3 22 cc eb				ld (display_fb_active), hl 
0bf6			 
0bf6 cd b9 0b		.mloop:		call clear_display 
0bf9 cd dc 0b				call update_display 
0bfc			 
0bfc					; draw selection id '>' at 1 
0bfc			 
0bfc					; init start of list display 
0bfc			 
0bfc 3e 05				ld a, 5 
0bfe 32 6f ea				ld (store_tmp3), a   ; display row count 
0c01 3a 71 ea				ld a,( store_tmp2) 
0c04 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c07			 
0c07					 
0c07			.mitem:	 
0c07			 
0c07			 
0c07 3a 72 ea				ld a,(store_tmp2+1) 
0c0a 6f					ld l, a 
0c0b 26 00				ld h, 0 
0c0d 29					add hl, hl 
0c0e ed 5b 73 ea			ld de, (store_tmp1) 
0c12 19					add hl, de 
0c13 7e					ld a, (hl) 
0c14 23					inc hl 
0c15 66					ld h,(hl) 
0c16 6f					ld l, a 
0c17			 
0c17 cd 0f 0e				call ishlzero 
0c1a 28 1a				jr z, .mdone 
0c1c			 
0c1c eb					ex de, hl 
0c1d 3a 6f ea				ld a, (store_tmp3) 
0c20 cd cc 0b				call str_at_display 
0c23					 
0c23			 
0c23					; next item 
0c23 3a 72 ea				ld a, (store_tmp2+1) 
0c26 3c					inc a 
0c27 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c2a			 
0c2a			 		; next row 
0c2a			 
0c2a 3a 6f ea				ld a, (store_tmp3) 
0c2d c6 28				add display_cols 
0c2f 32 6f ea				ld (store_tmp3), a 
0c32			 
0c32					; at end of screen? 
0c32			 
0c32 fe 10				cp display_rows*4 
0c34 20 d1				jr nz, .mitem 
0c36			 
0c36			 
0c36			.mdone: 
0c36 cd 0f 0e				call ishlzero 
0c39 28 08				jr z, .nodn 
0c3b			 
0c3b 3e 78				ld a, display_row_4 
0c3d 11 bc 0c				ld de, .mdown 
0c40 cd cc 0b				call str_at_display 
0c43			 
0c43					; draw options to fill the screens with active item on line 1 
0c43					; if current option is 2 or more then display ^ in top 
0c43			 
0c43 3a 71 ea		.nodn:		ld a, (store_tmp2) 
0c46 fe 00				cp 0 
0c48 28 08				jr z, .noup 
0c4a			 
0c4a 3e 00				ld a, 0 
0c4c 11 ba 0c				ld de, .mup 
0c4f cd cc 0b				call str_at_display 
0c52			 
0c52 3e 02		.noup:		ld a, 2 
0c54 11 b8 0c				ld de, .msel 
0c57 cd cc 0b				call str_at_display 
0c5a			 
0c5a					; if current option + 1 is not null then display V in bottom 
0c5a					; get key 
0c5a cd dc 0b				call update_display 
0c5d			 
0c5d			 
0c5d					; handle key 
0c5d			 
0c5d cd 3b 65				call cin_wait 
0c60			 
0c60 fe 05				cp KEY_UP 
0c62 28 2b				jr z, .mgoup 
0c64 fe 61				cp 'a' 
0c66 28 27				jr z, .mgoup 
0c68 fe 0a				cp KEY_DOWN 
0c6a 28 32				jr z, .mgod 
0c6c fe 7a				cp 'z' 
0c6e 28 2e				jr z, .mgod 
0c70 fe 20				cp ' ' 
0c72 28 34				jr z, .goend 
0c74 fe 0c				cp KEY_RIGHT 
0c76 28 30				jr z, .goend 
0c78 fe 0d				cp KEY_CR 
0c7a 28 2c				jr z, .goend 
0c7c fe 71				cp 'q' 
0c7e 28 0b				jr z, .goback 
0c80			 
0c80 fe 0b				cp KEY_LEFT 
0c82 28 07				jr z, .goback 
0c84 fe 08				cp KEY_BS 
0c86 28 03				jr z, .goback 
0c88 c3 f6 0b				jp .mloop 
0c8b			 
0c8b			.goback: 
0c8b 3e 00			ld a, 0 
0c8d 18 1d			jr .goend2 
0c8f			 
0c8f				; move up one 
0c8f			.mgoup: 
0c8f 3a 71 ea				ld a, (store_tmp2) 
0c92 fe 00				cp 0 
0c94 ca f6 0b				jp z, .mloop 
0c97 3d					dec a 
0c98 32 71 ea				ld (store_tmp2), a 
0c9b c3 f6 0b				jp .mloop 
0c9e			 
0c9e				; move down one 
0c9e			.mgod: 
0c9e 3a 71 ea				ld a, (store_tmp2) 
0ca1 3c					inc a 
0ca2 32 71 ea				ld (store_tmp2), a 
0ca5 c3 f6 0b				jp .mloop 
0ca8			 
0ca8			 
0ca8			.goend: 
0ca8					; get selected item number 
0ca8			 
0ca8 3a 71 ea				ld a, (store_tmp2) 
0cab 3c					inc a 
0cac			 
0cac			.goend2: 
0cac f5					push af 
0cad			 
0cad					; restore active fb 
0cad					; TODO BUG assumes fb1 
0cad			 
0cad 21 10 ed				ld hl, display_fb1 
0cb0 22 cc eb				ld (display_fb_active), hl 
0cb3			 
0cb3					; restore main regs 
0cb3			 
0cb3			 
0cb3 cd dc 0b				call update_display 
0cb6			 
0cb6 f1					pop af 
0cb7			 
0cb7 c9				ret 
0cb8			 
0cb8 .. 00		.msel:   db ">",0 
0cba .. 00		.mup:   db "^",0 
0cbc .. 00		.mdown:   db "v",0 
0cbe			 
0cbe			 
0cbe			; eof 
0cbe			 
# End of file firmware_display.asm
0cbe			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cbe			; random number generators 
0cbe			 
0cbe			 
0cbe			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cbe			 
0cbe			 
0cbe			;-----> Generate a random number 
0cbe			; output a=answer 0<=a<=255 
0cbe			; all registers are preserved except: af 
0cbe			random: 
0cbe e5			        push    hl 
0cbf d5			        push    de 
0cc0 2a ab eb		        ld      hl,(randData) 
0cc3 ed 5f		        ld      a,r 
0cc5 57			        ld      d,a 
0cc6 5e			        ld      e,(hl) 
0cc7 19			        add     hl,de 
0cc8 85			        add     a,l 
0cc9 ac			        xor     h 
0cca 22 ab eb		        ld      (randData),hl 
0ccd d1			        pop     de 
0cce e1			        pop     hl 
0ccf c9			        ret 
0cd0			 
0cd0			 
0cd0			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cd0			 
0cd0			 
0cd0			 
0cd0			;------LFSR------ 
0cd0			;James Montelongo 
0cd0			;optimized by Spencer Putt 
0cd0			;out: 
0cd0			; a = 8 bit random number 
0cd0			RandLFSR: 
0cd0 21 b1 eb		        ld hl,LFSRSeed+4 
0cd3 5e			        ld e,(hl) 
0cd4 23			        inc hl 
0cd5 56			        ld d,(hl) 
0cd6 23			        inc hl 
0cd7 4e			        ld c,(hl) 
0cd8 23			        inc hl 
0cd9 7e			        ld a,(hl) 
0cda 47			        ld b,a 
0cdb cb 13		        rl e  
0cdd cb 12			rl d 
0cdf cb 11		        rl c  
0ce1 17				rla 
0ce2 cb 13		        rl e  
0ce4 cb 12			rl d 
0ce6 cb 11		        rl c  
0ce8 17				rla 
0ce9 cb 13		        rl e  
0ceb cb 12			rl d 
0ced cb 11		        rl c  
0cef 17				rla 
0cf0 67			        ld h,a 
0cf1 cb 13		        rl e  
0cf3 cb 12			rl d 
0cf5 cb 11		        rl c  
0cf7 17				rla 
0cf8 a8			        xor b 
0cf9 cb 13		        rl e  
0cfb cb 12			rl d 
0cfd ac			        xor h 
0cfe a9			        xor c 
0cff aa			        xor d 
0d00 21 b3 eb		        ld hl,LFSRSeed+6 
0d03 11 b4 eb		        ld de,LFSRSeed+7 
0d06 01 07 00		        ld bc,7 
0d09 ed b8		        lddr 
0d0b 12			        ld (de),a 
0d0c c9			        ret 
0d0d			 
0d0d			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d0d			 
0d0d			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d0d			 
0d0d			 
0d0d			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d0d			 
0d0d			prng16: 
0d0d			;Inputs: 
0d0d			;   (seed1) contains a 16-bit seed value 
0d0d			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d0d			;Outputs: 
0d0d			;   HL is the result 
0d0d			;   BC is the result of the LCG, so not that great of quality 
0d0d			;   DE is preserved 
0d0d			;Destroys: 
0d0d			;   AF 
0d0d			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d0d			;160cc 
0d0d			;26 bytes 
0d0d 2a a5 eb		    ld hl,(seed1) 
0d10 44			    ld b,h 
0d11 4d			    ld c,l 
0d12 29			    add hl,hl 
0d13 29			    add hl,hl 
0d14 2c			    inc l 
0d15 09			    add hl,bc 
0d16 22 a5 eb		    ld (seed1),hl 
0d19 2a a3 eb		    ld hl,(seed2) 
0d1c 29			    add hl,hl 
0d1d 9f			    sbc a,a 
0d1e e6 2d		    and %00101101 
0d20 ad			    xor l 
0d21 6f			    ld l,a 
0d22 22 a3 eb		    ld (seed2),hl 
0d25 09			    add hl,bc 
0d26 c9			    ret 
0d27			 
0d27			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d27			 
0d27			rand32: 
0d27			;Inputs: 
0d27			;   (seed1_0) holds the lower 16 bits of the first seed 
0d27			;   (seed1_1) holds the upper 16 bits of the first seed 
0d27			;   (seed2_0) holds the lower 16 bits of the second seed 
0d27			;   (seed2_1) holds the upper 16 bits of the second seed 
0d27			;   **NOTE: seed2 must be non-zero 
0d27			;Outputs: 
0d27			;   HL is the result 
0d27			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d27			;Destroys: 
0d27			;   AF 
0d27			;Tested and passes all CAcert tests 
0d27			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d27			;it has a period of 18,446,744,069,414,584,320 
0d27			;roughly 18.4 quintillion. 
0d27			;LFSR taps: 0,2,6,7  = 11000101 
0d27			;291cc 
0d27			;seed1_0=$+1 
0d27			;    ld hl,12345 
0d27			;seed1_1=$+1 
0d27			;    ld de,6789 
0d27			;    ld b,h 
0d27			;    ld c,l 
0d27			;    add hl,hl \ rl e \ rl d 
0d27			;    add hl,hl \ rl e \ rl d 
0d27			;    inc l 
0d27			;    add hl,bc 
0d27			;    ld (seed1_0),hl 
0d27			;    ld hl,(seed1_1) 
0d27			;    adc hl,de 
0d27			;    ld (seed1_1),hl 
0d27			;    ex de,hl 
0d27			;seed2_0=$+1 
0d27			;    ld hl,9876 
0d27			;seed2_1=$+1 
0d27			;    ld bc,54321 
0d27			;    add hl,hl \ rl c \ rl b 
0d27			;    ld (seed2_1),bc 
0d27			;    sbc a,a 
0d27			;    and %11000101 
0d27			;    xor l 
0d27			;    ld l,a 
0d27			;    ld (seed2_0),hl 
0d27			;    ex de,hl 
0d27			;    add hl,bc 
0d27			;    ret 
0d27			; 
0d27			 
0d27			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d27			; 20 bytes, 86 cycles (excluding ret) 
0d27			 
0d27			; returns   hl = pseudorandom number 
0d27			; corrupts   a 
0d27			 
0d27			; generates 16-bit pseudorandom numbers with a period of 65535 
0d27			; using the xorshift method: 
0d27			 
0d27			; hl ^= hl << 7 
0d27			; hl ^= hl >> 9 
0d27			; hl ^= hl << 8 
0d27			 
0d27			; some alternative shift triplets which also perform well are: 
0d27			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d27			 
0d27			;  org 32768 
0d27			 
0d27			xrnd: 
0d27 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
0d2a 3e 00		  ld a,0 
0d2c bd			  cp l 
0d2d 20 02		  jr nz, .xrnd1 
0d2f 2e 01		  ld l, 1 
0d31			.xrnd1: 
0d31			 
0d31 7c			  ld a,h 
0d32 1f			  rra 
0d33 7d			  ld a,l 
0d34 1f			  rra 
0d35 ac			  xor h 
0d36 67			  ld h,a 
0d37 7d			  ld a,l 
0d38 1f			  rra 
0d39 7c			  ld a,h 
0d3a 1f			  rra 
0d3b ad			  xor l 
0d3c 6f			  ld l,a 
0d3d ac			  xor h 
0d3e 67			  ld h,a 
0d3f			 
0d3f 22 a9 eb		  ld (xrandc),hl 
0d42			 
0d42 c9			  ret 
0d43			;  
0d43			 
0d43			 
0d43			;;;; int maths 
0d43			 
0d43			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d43			; Divide 16-bit values (with 16-bit result) 
0d43			; In: Divide BC by divider DE 
0d43			; Out: BC = result, HL = rest 
0d43			; 
0d43			Div16: 
0d43 21 00 00		    ld hl,0 
0d46 78			    ld a,b 
0d47 06 08		    ld b,8 
0d49			Div16_Loop1: 
0d49 17			    rla 
0d4a ed 6a		    adc hl,hl 
0d4c ed 52		    sbc hl,de 
0d4e 30 01		    jr nc,Div16_NoAdd1 
0d50 19			    add hl,de 
0d51			Div16_NoAdd1: 
0d51 10 f6		    djnz Div16_Loop1 
0d53 17			    rla 
0d54 2f			    cpl 
0d55 47			    ld b,a 
0d56 79			    ld a,c 
0d57 48			    ld c,b 
0d58 06 08		    ld b,8 
0d5a			Div16_Loop2: 
0d5a 17			    rla 
0d5b ed 6a		    adc hl,hl 
0d5d ed 52		    sbc hl,de 
0d5f 30 01		    jr nc,Div16_NoAdd2 
0d61 19			    add hl,de 
0d62			Div16_NoAdd2: 
0d62 10 f6		    djnz Div16_Loop2 
0d64 17			    rla 
0d65 2f			    cpl 
0d66 41			    ld b,c 
0d67 4f			    ld c,a 
0d68 c9			ret 
0d69			 
0d69			 
0d69			;http://z80-heaven.wikidot.com/math 
0d69			; 
0d69			;Inputs: 
0d69			;     DE and A are factors 
0d69			;Outputs: 
0d69			;     A is not changed 
0d69			;     B is 0 
0d69			;     C is not changed 
0d69			;     DE is not changed 
0d69			;     HL is the product 
0d69			;Time: 
0d69			;     342+6x 
0d69			; 
0d69			Mult16: 
0d69			 
0d69 06 08		     ld b,8          ;7           7 
0d6b 21 00 00		     ld hl,0         ;10         10 
0d6e 29			       add hl,hl     ;11*8       88 
0d6f 07			       rlca          ;4*8        32 
0d70 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d72 19			         add hl,de   ;--         -- 
0d73 10 f9		       djnz $-5      ;13*7+8     99 
0d75 c9			ret 
0d76			 
0d76			; 
0d76			; Square root of 16-bit value 
0d76			; In:  HL = value 
0d76			; Out:  D = result (rounded down) 
0d76			; 
0d76			;Sqr16: 
0d76			;    ld de,#0040 
0d76			;    ld a,l 
0d76			;    ld l,h 
0d76			;    ld h,d 
0d76			;    or a 
0d76			;    ld b,8 
0d76			;Sqr16_Loop: 
0d76			;    sbc hl,de 
0d76			;    jr nc,Sqr16_Skip 
0d76			;    add hl,de 
0d76			;Sqr16_Skip: 
0d76			;    ccf 
0d76			;    rl d 
0d76			;    add a,a 
0d76			;    adc hl,hl 
0d76			;    add a,a 
0d76			;    adc hl,hl 
0d76			;    djnz Sqr16_Loop 
0d76			;    ret 
0d76			; 
0d76			; 
0d76			; Divide 8-bit values 
0d76			; In: Divide E by divider C 
0d76			; Out: A = result, B = rest 
0d76			; 
0d76			Div8: 
0d76 af			    xor a 
0d77 06 08		    ld b,8 
0d79			Div8_Loop: 
0d79 cb 13		    rl e 
0d7b 17			    rla 
0d7c 91			    sub c 
0d7d 30 01		    jr nc,Div8_NoAdd 
0d7f 81			    add a,c 
0d80			Div8_NoAdd: 
0d80 10 f7		    djnz Div8_Loop 
0d82 47			    ld b,a 
0d83 7b			    ld a,e 
0d84 17			    rla 
0d85 2f			    cpl 
0d86 c9			    ret 
0d87			 
0d87			; 
0d87			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d87			; In: Multiply A with DE 
0d87			; Out: HL = result 
0d87			; 
0d87			Mult12U: 
0d87 2e 00		    ld l,0 
0d89 87			    add a,a 
0d8a 30 01		    jr nc,Mult12U_NoAdd0 
0d8c 19			    add hl,de 
0d8d			Mult12U_NoAdd0: 
0d8d 29			    add hl,hl 
0d8e 87			    add a,a 
0d8f 30 01		    jr nc,Mult12U_NoAdd1 
0d91 19			    add hl,de 
0d92			Mult12U_NoAdd1: 
0d92 29			    add hl,hl 
0d93 87			    add a,a 
0d94 30 01		    jr nc,Mult12U_NoAdd2 
0d96 19			    add hl,de 
0d97			Mult12U_NoAdd2: 
0d97 29			    add hl,hl 
0d98 87			    add a,a 
0d99 30 01		    jr nc,Mult12U_NoAdd3 
0d9b 19			    add hl,de 
0d9c			Mult12U_NoAdd3: 
0d9c 29			    add hl,hl 
0d9d 87			    add a,a 
0d9e 30 01		    jr nc,Mult12U_NoAdd4 
0da0 19			    add hl,de 
0da1			Mult12U_NoAdd4: 
0da1 29			    add hl,hl 
0da2 87			    add a,a 
0da3 30 01		    jr nc,Mult12U_NoAdd5 
0da5 19			    add hl,de 
0da6			Mult12U_NoAdd5: 
0da6 29			    add hl,hl 
0da7 87			    add a,a 
0da8 30 01		    jr nc,Mult12U_NoAdd6 
0daa 19			    add hl,de 
0dab			Mult12U_NoAdd6: 
0dab 29			    add hl,hl 
0dac 87			    add a,a 
0dad d0			    ret nc 
0dae 19			    add hl,de 
0daf c9			    ret 
0db0			 
0db0			; 
0db0			; Multiply 8-bit value with a 16-bit value (right rotating) 
0db0			; In: Multiply A with DE 
0db0			;      Put lowest value in A for most efficient calculation 
0db0			; Out: HL = result 
0db0			; 
0db0			Mult12R: 
0db0 21 00 00		    ld hl,0 
0db3			Mult12R_Loop: 
0db3 cb 3f		    srl a 
0db5 30 01		    jr nc,Mult12R_NoAdd 
0db7 19			    add hl,de 
0db8			Mult12R_NoAdd: 
0db8 cb 23		    sla e 
0dba cb 12		    rl d 
0dbc b7			    or a 
0dbd c2 b3 0d		    jp nz,Mult12R_Loop 
0dc0 c9			    ret 
0dc1			 
0dc1			; 
0dc1			; Multiply 16-bit values (with 32-bit result) 
0dc1			; In: Multiply BC with DE 
0dc1			; Out: BCHL = result 
0dc1			; 
0dc1			Mult32: 
0dc1 79			    ld a,c 
0dc2 48			    ld c,b 
0dc3 21 00 00		    ld hl,0 
0dc6 06 10		    ld b,16 
0dc8			Mult32_Loop: 
0dc8 29			    add hl,hl 
0dc9 17			    rla 
0dca cb 11		    rl c 
0dcc 30 07		    jr nc,Mult32_NoAdd 
0dce 19			    add hl,de 
0dcf ce 00		    adc a,0 
0dd1 d2 d5 0d		    jp nc,Mult32_NoAdd 
0dd4 0c			    inc c 
0dd5			Mult32_NoAdd: 
0dd5 10 f1		    djnz Mult32_Loop 
0dd7 41			    ld b,c 
0dd8 4f			    ld c,a 
0dd9 c9			    ret 
0dda			 
0dda			 
0dda			 
0dda			; 
0dda			; Multiply 8-bit values 
0dda			; In:  Multiply H with E 
0dda			; Out: HL = result 
0dda			; 
0dda			Mult8: 
0dda 16 00		    ld d,0 
0ddc 6a			    ld l,d 
0ddd 06 08		    ld b,8 
0ddf			Mult8_Loop: 
0ddf 29			    add hl,hl 
0de0 30 01		    jr nc,Mult8_NoAdd 
0de2 19			    add hl,de 
0de3			Mult8_NoAdd: 
0de3 10 fa		    djnz Mult8_Loop 
0de5 c9			    ret 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			;;http://z80-heaven.wikidot.com/math 
0de6			;;This divides DE by BC, storing the result in DE, remainder in HL 
0de6			; 
0de6			;DE_Div_BC:          ;1281-2x, x is at most 16 
0de6			;     ld a,16        ;7 
0de6			;     ld hl,0        ;10 
0de6			;     jp $+5         ;10 
0de6			;.DivLoop: 
0de6			;       add hl,bc    ;-- 
0de6			;       dec a        ;64 
0de6			;       jr z,.DivLoopEnd        ;86 
0de6			; 
0de6			;       sla e        ;128 
0de6			;       rl d         ;128 
0de6			;       adc hl,hl    ;240 
0de6			;       sbc hl,bc    ;240 
0de6			;       jr nc,.DivLoop ;23|21 
0de6			;       inc e        ;-- 
0de6			;       jp .DivLoop+1 
0de6			; 
0de6			;.DivLoopEnd: 
0de6			 
0de6			;HL_Div_C: 
0de6			;Inputs: 
0de6			;     HL is the numerator 
0de6			;     C is the denominator 
0de6			;Outputs: 
0de6			;     A is the remainder 
0de6			;     B is 0 
0de6			;     C is not changed 
0de6			;     DE is not changed 
0de6			;     HL is the quotient 
0de6			; 
0de6			;       ld b,16 
0de6			;       xor a 
0de6			;         add hl,hl 
0de6			;         rla 
0de6			;         cp c 
0de6			;         jr c,$+4 
0de6			;           inc l 
0de6			;           sub c 
0de6			;         djnz $-7 
0de6			 
0de6			; https://plutiedev.com/z80-add-8bit-to-16bit 
0de6			 
0de6			addatohl: 
0de6 85			    add   a, l    ; A = A+L 
0de7 6f			    ld    l, a    ; L = A+L 
0de8 8c			    adc   a, h    ; A = A+L+H+carry 
0de9 95			    sub   l       ; A = H+carry 
0dea 67			    ld    h, a    ; H = H+carry 
0deb c9			ret 
0dec			 
0dec			addatode: 
0dec 83			    add   a, e    ; A = A+L 
0ded 5f			    ld    e, a    ; L = A+L 
0dee 8a			    adc   a, d    ; A = A+L+H+carry 
0def 93			    sub   e       ; A = H+carry 
0df0 57			    ld    d, a    ; H = H+carry 
0df1 c9			ret 
0df2			 
0df2			 
0df2			addatobc: 
0df2 81			    add   a, c    ; A = A+L 
0df3 4f			    ld    c, a    ; L = A+L 
0df4 88			    adc   a, b    ; A = A+L+H+carry 
0df5 91			    sub   c       ; A = H+carry 
0df6 47			    ld    b, a    ; H = H+carry 
0df7 c9			ret 
0df8			 
0df8			subafromhl: 
0df8			   ; If A=0 do nothing 
0df8			    ; Otherwise flip A's sign. Since 
0df8			    ; the upper byte becomes -1, also 
0df8			    ; substract 1 from H. 
0df8 ed 44		    neg 
0dfa ca 03 0e		    jp    z, Skip 
0dfd 25			    dec   h 
0dfe			     
0dfe			    ; Now add the low byte as usual 
0dfe			    ; Two's complement takes care of 
0dfe			    ; ensuring the result is correct 
0dfe 85			    add   a, l 
0dff 6f			    ld    l, a 
0e00 8c			    adc   a, h 
0e01 95			    sub   l 
0e02 67			    ld    h, a 
0e03			Skip: 
0e03 c9				ret 
0e04			 
0e04			 
0e04			; compare hl and de 
0e04			; returns:  
0e04			; if hl = de, z=1, s=0, c0=0 
0e04			; if hl > de, z=0, s=0, c=0 
0e04			; if hl < de, z=0, s=1, c=1 
0e04			cmp16:	 
0e04 b7				or a 
0e05 ed 52			sbc hl,de 
0e07 e0				ret po 
0e08 7c				ld a,h 
0e09 1f				rra 
0e0a ee 40			xor 01000000B 
0e0c 37				scf 
0e0d 8f				adc a,a 
0e0e c9				ret 
0e0f			 
0e0f			 
0e0f			; test if hl contains zero   - A is destroyed 
0e0f			 
0e0f			ishlzero:    
0e0f b7				or a     ; reset flags 
0e10 7c				ld a, h 
0e11 b5				or l        	 
0e12			 
0e12 c9				ret 
0e13			 
0e13			 
0e13			 
0e13			 
0e13			if FORTH_ENABLE_FLOATMATH 
0e13			;include "float/bbcmath.z80" 
0e13			include "float/lpfpcalc.asm" 
0e13			endif 
0e13			 
0e13			 
0e13			; eof 
0e13			 
# End of file firmware_maths.asm
0e13			include "firmware_strings.asm"   ; string handling  
0e13			 
0e13			 
0e13			; TODO string len 
0e13			; input text string, end on cr with zero term 
0e13			; a offset into frame buffer to start prompt 
0e13			; d is max length 
0e13			; e is display size TODO 
0e13			; c is current cursor position 
0e13			; hl is ptr to where string will be stored and edited directly 
0e13			 
0e13			 
0e13			; TODO check limit of buffer for new inserts 
0e13			; TODO check insert does not push beyond buffer 
0e13			; TODO scroll in a limited display area 
0e13			; TODO scroll whole screen on page wrap 
0e13			 
0e13			 
0e13			; TODO use LCD cursor? 
0e13			 
0e13			EDIT_V1: equ 0 
0e13			EDIT_V2: equ 1 
0e13			 
0e13			 
0e13			 
0e13			if EDIT_V2 
0e13			input_str: 
0e13			 
0e13 32 64 ee			    	ld (input_at_pos),a      ; save display position to start 
0e16			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0e16 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
0e19			;		ld a, c 
0e19			;		call addatohl 
0e19			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
0e19 7a					ld a,d 
0e1a 32 66 ee			        ld (input_size), a       ; save length of input area 
0e1d 79					ld a, c 
0e1e 32 55 ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
0e21 7b					ld a,e 
0e22 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e25			 
0e25			 
0e25					; add a trailing space to make screen refresh nicer 
0e25			 
0e25					;ld hl, (input_start) 
0e25					;push hl 
0e25					;ld a, 0 
0e25					;call strlent 
0e25					;ld a, l 
0e25					;pop hl 
0e25					;call addatohl 
0e25					;dec hl 
0e25					;ld a, ' ' 
0e25					;ld (hl), a 
0e25					;inc hl 
0e25					;ld (hl), a 
0e25					;inc hl 
0e25					;ld a, 0 
0e25					;ld (hl), a 
0e25			 
0e25			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e25					; init cursor shape if not set by the cin routines 
0e25 21 c1 eb				ld hl, cursor_shape 
0e28			if BASE_KEV 
0e28					ld a, 255 
0e28			else 
0e28 3e 23				ld a, '#' 
0e2a			endif 
0e2a 77					ld (hl), a 
0e2b 23					inc hl 
0e2c 3e 00				ld a, 0 
0e2e 77					ld (hl), a 
0e2f			 
0e2f 3e 09				ld a, CUR_BLINK_RATE 
0e31 32 60 ee				ld (input_cur_flash), a 
0e34 3e 01				ld a, 1 
0e36 32 5f ee				ld (input_cur_onoff),a 
0e39			.inmain:	 
0e39			 
0e39 cd 6e 0f				call input_disp_ref 
0e3c			 
0e3c					; save current length of string 
0e3c			 
0e3c 2a 67 ee				ld hl, (input_start) 
0e3f 3e 00				ld a, 0 
0e41 cd 64 11				call strlent 
0e44 7d					ld a,l 
0e45 32 5a ee				ld (input_len), a 
0e48			 
0e48					;call input_disp_oncur 
0e48			 
0e48					; display current state of input buffer 
0e48			 
0e48					; clean any backspace chars 
0e48			 
0e48 3e 20				ld a, " " 
0e4a 32 c1 e2				ld (scratch),a 
0e4d 3e 00				ld a, 0 
0e4f 32 c2 e2				ld (scratch+1),a 
0e52 3a 64 ee				ld a,(input_at_pos) 
0e55 85					add l 
0e56 11 c1 e2				ld de, scratch 
0e59 cd cc 0b				call str_at_display 
0e5c			 
0e5c					; pause 1ms 
0e5c			 
0e5c 3e 01				ld a, 1 
0e5e cd d6 0a				call aDelayInMS 
0e61			 
0e61			; display cursor if visible on this cycle 
0e61			 
0e61					; dec flash counter 
0e61 3a 60 ee				ld a, (input_cur_flash) 
0e64 3d					dec a 
0e65 32 60 ee				ld (input_cur_flash), a 
0e68 fe 00				cp 0 
0e6a 20 0d				jr nz, .inochgstate 
0e6c			 
0e6c			 
0e6c					; reset on change of state 
0e6c 3e 09				ld a, CUR_BLINK_RATE 
0e6e 32 60 ee				ld (input_cur_flash), a 
0e71			 
0e71					; change state 
0e71 3a 5f ee				ld a,(input_cur_onoff) 
0e74 ed 44				neg 
0e76 32 5f ee				ld (input_cur_onoff),a 
0e79			 
0e79			 
0e79			 
0e79			 
0e79					; TODO is cursor visible? 
0e79					; TODO if so then over write the char at curspos pos with the cursor shape 
0e79			 
0e79								 
0e79			 
0e79			.inochgstate: 
0e79 3a 5f ee				ld a,(input_cur_onoff) 
0e7c fe ff				cp 255 
0e7e 28 0e				jr z, .skipcursor 
0e80 3a 64 ee				ld a, (input_at_pos) 
0e83 47					ld b, a 
0e84 3a 55 ee				ld a, (input_cursor) 
0e87 80					add b 
0e88 11 c1 eb				ld de, cursor_shape 
0e8b					 
0e8b cd cc 0b				call str_at_display 
0e8e			 
0e8e			.skipcursor: 
0e8e				if DEBUG_INPUTV2 
0e8e			 
0e8e					ld a,(input_at_pos) 
0e8e					ld hl, LFSRSeed 
0e8e					call hexout 
0e8e					ld a, (input_cursor) 
0e8e					ld hl, LFSRSeed+2 
0e8e					call hexout 
0e8e					ld a,(input_size) 
0e8e					ld hl, LFSRSeed+4 
0e8e					call hexout 
0e8e			 
0e8e					ld a,(input_cur_onoff) 
0e8e					ld hl, LFSRSeed+6 
0e8e					call hexout 
0e8e			 
0e8e					ld a,(input_cur_flash) 
0e8e					ld hl, LFSRSeed+8 
0e8e					call hexout 
0e8e			 
0e8e					ld a,(input_len) 
0e8e					ld hl, LFSRSeed+10 
0e8e					call hexout 
0e8e					ld hl, LFSRSeed+12 
0e8e					ld a, 0 
0e8e					ld (hl),a 
0e8e					ld a, display_row_4 
0e8e					ld de, LFSRSeed 
0e8e					call str_at_display 
0e8e				endif 
0e8e cd dc 0b				call update_display 
0e91			 
0e91					; TODO keyboard processing 
0e91			 
0e91			if BASE_CPM 
0e91 cd 3b 65				call cin_wait 
0e94			else 
0e94					call cin    ; _wait 
0e94			endif 
0e94 fe 00				cp 0 
0e96 ca 39 0e				jp z, .inmain 
0e99			 
0e99 fe 0b				cp KEY_LEFT    ; cursor left 
0e9b ca 60 0f				jp z, input_left 
0e9e				 
0e9e fe 0c				cp KEY_RIGHT      ; cursor right 
0ea0 ca 67 0f				jp z, input_right 
0ea3			 
0ea3 fe 0d				cp KEY_CR 
0ea5 c8					ret z 
0ea6			 
0ea6 fe 08				cp KEY_BS 
0ea8 ca d5 0f				jp z, input_delchar 
0eab			 
0eab fe 06				cp KEY_NEXTWORD 
0ead ca e1 0e				jp z, input_nxtword 
0eb0			 
0eb0 fe 07				cp KEY_PREVWORD 
0eb2 ca 08 0f				jp z, input_prvword 
0eb5			 
0eb5 fe 0e				cp KEY_HOME    ; jump to start of line 
0eb7 20 08				jr nz, .ikh 
0eb9 3e 00				ld a, 0 
0ebb 32 55 ee				ld (input_cursor), a 
0ebe ca 39 0e				jp z, .inmain 
0ec1			.ikh: 
0ec1			 
0ec1 fe 0f				cp KEY_END     ; jump to end of line 
0ec3 20 09				jr nz, .ike 
0ec5 3a 5a ee				ld a, (input_len) 
0ec8 32 55 ee				ld (input_cursor),a 
0ecb ca 39 0e				jp z, .inmain 
0ece			.ike: 
0ece fe 05			        cp KEY_UP      ; recall last command 
0ed0 20 0c				jr nz, .irec 
0ed2			; TODO next word 
0ed2			; TODO prev word 
0ed2			;  
0ed2			; 
0ed2 21 c1 e2			ld hl, scratch 
0ed5 11 e7 e6			ld de, os_last_cmd 
0ed8 cd f2 0f			call strcpy 
0edb ca 39 0e				jp z, .inmain 
0ede			.irec: 
0ede			;		jr .instr1 
0ede			 
0ede			 
0ede					; if no special key then insert as a char 
0ede			 
0ede c3 a7 0f				jp input_inschr 
0ee1			 
0ee1				 
0ee1			input_nxtword: 
0ee1				; jump to start next word after the cursor 
0ee1			 
0ee1			.insknwn:	 
0ee1 cd 9d 0f				call input_curptr	 
0ee4 7e					ld a,(hl)	 
0ee5 fe 00				cp 0 
0ee7 ca 39 0e				jp z, .inmain    ; end of string 
0eea			 
0eea			; if we are on a word, then move off of it 
0eea			 
0eea fe 20				cp ' ' 
0eec 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
0eee 21 55 ee				ld hl, input_cursor 
0ef1 34					inc (hl) 
0ef2 18 ed				jr .insknwn 
0ef4			 
0ef4			.inspace: 
0ef4			 
0ef4 cd 9d 0f				call input_curptr	 
0ef7 7e					ld a,(hl)	 
0ef8 fe 00				cp 0 
0efa ca 39 0e				jp z, .inmain    ; end of string 
0efd			 
0efd			; if we are on a word, then move off of it 
0efd			 
0efd fe 20				cp ' ' 
0eff c2 39 0e				jp nz, .inmain     ; we are on non space so at next word 
0f02 21 55 ee				ld hl, input_cursor 
0f05 34					inc (hl) 
0f06 18 ec				jr .inspace 
0f08			 
0f08			 
0f08			 
0f08			 
0f08			input_prvword: 
0f08				; jump to the start of previous word before the cursor 
0f08			 
0f08			; where are we to start with currently? 
0f08			 
0f08 cd 9d 0f				call input_curptr	 
0f0b 7e					ld a, (hl) 
0f0c fe 20				cp ' ' 
0f0e 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
0f10			 
0f10			 
0f10			 
0f10			.inskpwn:	 
0f10 3a 55 ee				ld a,(input_cursor) 
0f13 fe 00				cp 0 
0f15 ca 39 0e				jp z, .inmain    ; start of string 
0f18			 
0f18			;if we are on a word, then move off of it 
0f18			 
0f18 cd 9d 0f				call input_curptr	 
0f1b 7e					ld a, (hl) 
0f1c fe 20				cp ' ' 
0f1e 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
0f20					;jp z, .inmain    ; start of string 
0f20 21 55 ee				ld hl, input_cursor 
0f23 35					dec (hl) 
0f24 18 ea				jr .inskpwn 
0f26			.iwstart: 
0f26 21 55 ee				ld hl, input_cursor 
0f29 34					inc (hl) 
0f2a c3 39 0e				jp .inmain 
0f2d					 
0f2d			 
0f2d			.inspacep: 
0f2d			 
0f2d					;jp .inmain    ; start of string 
0f2d			 
0f2d			 
0f2d			 
0f2d 3a 55 ee				ld a,(input_cursor) 
0f30 fe 00				cp 0 
0f32 ca 39 0e				jp z, .inmain    ; start of string 
0f35			 
0f35			; if we are on a word, then move off of it 
0f35			 
0f35 cd 9d 0f				call input_curptr	 
0f38 7e					ld a, (hl) 
0f39 fe 20				cp ' ' 
0f3b c2 44 0f				jp nz, .incharp     ; we are on non space so at end of prev word 
0f3e 21 55 ee				ld hl, input_cursor 
0f41 35					dec (hl) 
0f42 18 e9				jr .inspacep 
0f44			 
0f44			 
0f44			.incharp:	 
0f44					; eat the word to get to the start 
0f44 3a 55 ee				ld a,(input_cursor) 
0f47 fe 00				cp 0 
0f49 ca 39 0e				jp z, .inmain    ; start of string 
0f4c			 
0f4c			; if we are on a word, then move off of it 
0f4c			 
0f4c cd 9d 0f				call input_curptr	 
0f4f 7e					ld a, (hl) 
0f50 fe 20				cp ' ' 
0f52 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
0f54 21 55 ee				ld hl, input_cursor 
0f57 35					dec (hl) 
0f58 18 ea				jr .incharp 
0f5a			.ipwordst: 
0f5a					; at space before the prev word so reposition over it 
0f5a 21 55 ee				ld hl, input_cursor 
0f5d 34					inc (hl) 
0f5e 18 b0				jr .inskpwn 
0f60					 
0f60			 
0f60			 
0f60			input_left: 
0f60				; move cursor left 
0f60 21 55 ee			ld hl, input_cursor 
0f63 35				dec (hl) 
0f64			;	cp 0 
0f64			;	jp z, .inmain    ; ignore left as at the start of the string 
0f64 c3 39 0e			jp .inmain 
0f67			 
0f67			input_right: 
0f67				; move cursor right 
0f67				 
0f67				;ld a, (input_size) 
0f67				;ld b, a 
0f67 21 55 ee			ld hl, input_cursor 
0f6a 34				inc (hl) 
0f6b				;dec b 
0f6b				;cp 0 
0f6b				;jp z, .inmain   ; ignore as at end of the string buffer 
0f6b				;ld a, b 
0f6b				;inc a 
0f6b				;ld (input_cursor), a 
0f6b c3 39 0e			jp .inmain 
0f6e			 
0f6e			 
0f6e			 
0f6e			input_disp_ref: 
0f6e				; display the text from start of buffer (ie full refresh) 
0f6e 3a 64 ee			ld a, (input_at_pos) 
0f71 2a 67 ee			ld hl,(input_start) 
0f74 eb				ex de, hl 
0f75 cd cc 0b			call str_at_display  
0f78 c9				ret 
0f79			input_disp_oncur: 
0f79				; display the text from cursor position to end of buffer 
0f79				; TODO position start of string at cursor position on screen 
0f79				; TODO draw from that point on 
0f79 3a 55 ee			ld a, (input_cursor) 
0f7c 47				ld b, a 
0f7d 3a 64 ee			ld a, (input_at_pos) 
0f80 80				add b 
0f81 48				ld c, b     ; save a 
0f82 78				ld a, b     ; inc string start for cursor 
0f83 2a 67 ee			ld hl,(input_start) 
0f86 cd e6 0d			call addatohl 
0f89 eb				ex de, hl 
0f8a 79				ld a, c 
0f8b cd cc 0b			call str_at_display  
0f8e c9				ret 
0f8f			 
0f8f			input_nxtw: 
0f8f				; Find next word 
0f8f c9				ret 
0f90			 
0f90			input_prvw: 
0f90				; Find previous word 
0f90 c9				ret 
0f91			 
0f91			input_lenrem:   
0f91				; Calculate the length of string remaining from current cursor 
0f91				; position to end of buffer (exc null term) 
0f91				 
0f91 3a 55 ee			ld a, (input_cursor) 
0f94 4f				ld c, a 
0f95 3a 66 ee			ld a, (input_size) 
0f98 91				sub c 
0f99 06 00			ld b, 0 
0f9b 0d				dec c 
0f9c c9				ret	 
0f9d			 
0f9d			input_curptr: 
0f9d				; calc address of the character under the cursor 
0f9d				 
0f9d 2a 67 ee			ld hl, (input_start) 
0fa0 3a 55 ee			ld a, (input_cursor) 
0fa3 cd e6 0d			call addatohl 
0fa6 c9				ret 
0fa7			 
0fa7			input_inschr: 
0fa7				; Insert char at cursor position 
0fa7 f5				push af   ; save char 
0fa8				;call input_lenrem    ; get bc length of remaining string 
0fa8			 
0fa8				 
0fa8 cd 9d 0f			call input_curptr 
0fab			;	ld hl, (input_start) 
0fab			;	ld a, (input_cursor) 
0fab			;	call addatohl 
0fab				;push hl   ; save to come back to 
0fab			 
0fab				; shift everything up one to end of buffer 
0fab			 
0fab				;push hl 
0fab				;dec de 
0fab				;inc de 
0fab			;	ldir 
0fab				 
0fab				;pop hl 
0fab			 
0fab				; are we adding to the end of line? 
0fab			 
0fab 3a 55 ee			ld a, (input_cursor) 
0fae 47				ld b, a 
0faf 3a 5a ee			ld a, (input_len) 
0fb2 b8				cp b 
0fb3 20 09			jr nz, .insmid   ; no, insert in middle of text 
0fb5			 
0fb5				; tack on the end of the line 
0fb5 f1				pop af 
0fb6 77				ld (hl), a   ; save new char 
0fb7 23				inc hl 
0fb8 3e 00			ld a, 0 
0fba 77				ld (hl), a 
0fbb c3 67 0f			jp input_right 
0fbe				 
0fbe			.insmid: 
0fbe				; hl has insertion point so move everything up one to allow for insertion 
0fbe				;call input_shiftright 
0fbe f1				pop af 
0fbf			 
0fbf			.shufinsmid: 
0fbf 47				ld b, a     ; b contains new char, c prev char at this position  
0fc0 7e				ld a, (hl) 
0fc1			 
0fc1 fe 00			cp 0    ; at end of string need to then dump new char and add term 
0fc3 28 07			jr z, .endinsmid 
0fc5 4f				ld c, a 
0fc6 78				ld a, b 
0fc7 77				ld (hl), a 
0fc8 23				inc hl 
0fc9 79				ld a, c 
0fca 18 f3			jr .shufinsmid 
0fcc				 
0fcc			 
0fcc			 
0fcc			 
0fcc			.endinsmid: 
0fcc 78				ld a, b 
0fcd 77				ld (hl), a 
0fce 23				inc hl 
0fcf 3e 00			ld a, 0 
0fd1 77				ld (hl), a 
0fd2			 
0fd2			 
0fd2			;	ld (hl), a   ; save new char 
0fd2			 
0fd2 c3 67 0f			jp input_right 
0fd5			 
0fd5			;input_shiftright: 
0fd5			;	; shift text right at cursor, hl has shift start 
0fd5			;	push hl 
0fd5			;	push de 
0fd5			;	push bc 
0fd5			; 
0fd5			; 
0fd5			;	; move to end of string past zero term 
0fd5			;	ld hl,(input_start) 
0fd5			;	ld a, (input_len) 
0fd5			;	call addatohl 
0fd5			;	inc hl 
0fd5			;;	inc hl 
0fd5			;;	inc hl 
0fd5			;	ld a, 0 
0fd5			;	ld (hl), a 
0fd5			;;	dec hl 
0fd5			;	 
0fd5			;;	ld (hl), a 
0fd5			;;	dec hl 
0fd5			; 
0fd5			;	push hl 
0fd5			;	pop de 
0fd5			;	inc de 
0fd5			;	 
0fd5			; 
0fd5			;;	ld hl,(input_start) 
0fd5			;;	ld a, (input_cursor) 
0fd5			;;	call addatohl 
0fd5			; 
0fd5			; 
0fd5			;	; calc how many bytes from cursor pos to end of string we need to shift 
0fd5			;	call input_lenrem    ; get bc length of remaining string 
0fd5			;	;ld a, (input_cursor) 
0fd5			;	;ld c, a 
0fd5			;	ld a, (input_len) 
0fd5			;	cp 2 
0fd5			;	jr z, .iskipzero	 
0fd5			;	;sub c 
0fd5			;	;inc a 
0fd5			;	;ld c, a 
0fd5			;	;ld b, 0 
0fd5			;	inc c 
0fd5			;	inc c 
0fd5			;	; move data 
0fd5			;	lddr 
0fd5			;.iskipzero: 
0fd5			; 
0fd5			;	pop bc 
0fd5			;	pop de 
0fd5			;	pop hl 
0fd5			;	ret	 
0fd5			 
0fd5			input_delchar: 
0fd5				; Delete char at cursor position 
0fd5 cd 91 0f			call input_lenrem    ; get bc length of remaining string 
0fd8 2a 67 ee			ld hl, (input_start) 
0fdb 3a 55 ee			ld a, (input_cursor) 
0fde cd e6 0d			call addatohl 
0fe1			 
0fe1 e5				push hl 
0fe2 d1				pop de 
0fe3 1b				dec de 
0fe4			 
0fe4			.dl:	 
0fe4 ed a0			ldi  
0fe6 7e				ld a, (hl) 
0fe7 fe 00			cp 0 
0fe9 28 02			jr z, .dldone 
0feb 18 f7			jr .dl 
0fed			.dldone: 
0fed ed a0			ldi 
0fef			 
0fef c3 60 0f			jp input_left 
0ff2			 
0ff2			 
0ff2			endif 
0ff2			 
0ff2			 
0ff2			 
0ff2			if EDIT_V1 
0ff2			input_str: 
0ff2			 
0ff2				    	ld (input_at_pos),a      ; save display position to start 
0ff2					add c 
0ff2					ld (input_at_cursor),a	; save draw pos of cursor 
0ff2					ld (input_start), hl     ; save ptr to buffer 
0ff2					ld a, c 
0ff2					call addatohl 
0ff2					ld (input_ptr), hl     ; save ptr to point under the cursor 
0ff2					ld a,d 
0ff2				        ld (input_size), a       ; save length of input area 
0ff2					ld a, c 
0ff2					ld (input_cursor),a      ; init cursor start position  
0ff2					ld a,e 
0ff2				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0ff2					 
0ff2					 
0ff2			 
0ff2			;		ld a,(input_ptr) 
0ff2			;		ld (input_under_cursor),a 	; save what is under the cursor 
0ff2			 
0ff2			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0ff2					; init cursor shape if not set by the cin routines 
0ff2					ld hl, cursor_shape 
0ff2			if BASE_KEV 
0ff2					ld a, 255 
0ff2			else 
0ff2					ld a, '#' 
0ff2			endif 
0ff2					ld (hl), a 
0ff2					inc hl 
0ff2					ld a, 0 
0ff2					ld (hl), a 
0ff2			 
0ff2					ld a, CUR_BLINK_RATE 
0ff2					ld (input_cur_flash), a 
0ff2					ld a, 1 
0ff2					ld (input_cur_onoff),a 
0ff2			 
0ff2			;	if DEBUG_INPUT 
0ff2			;		push af 
0ff2			;		ld a, 'I' 
0ff2			;		ld (debug_mark),a 
0ff2			;		pop af 
0ff2			;		CALLMONITOR 
0ff2			;	endif 
0ff2			.is1:		; main entry loop 
0ff2			 
0ff2			 
0ff2			 
0ff2					; pause 1ms 
0ff2			 
0ff2					ld a, 1 
0ff2					call aDelayInMS 
0ff2			 
0ff2					; dec flash counter 
0ff2					ld a, (input_cur_flash) 
0ff2					dec a 
0ff2					ld (input_cur_flash), a 
0ff2					cp 0 
0ff2					jr nz, .nochgstate 
0ff2			 
0ff2			 
0ff2					; change state 
0ff2					ld a,(input_cur_onoff) 
0ff2					neg 
0ff2					ld (input_cur_onoff),a 
0ff2			 
0ff2			 
0ff2					; reset on change of state 
0ff2					ld a, CUR_BLINK_RATE 
0ff2					ld (input_cur_flash), a 
0ff2			 
0ff2			.nochgstate: 
0ff2					 
0ff2					 
0ff2			 
0ff2					; display cursor  
0ff2			 
0ff2			;		ld hl, (input_start) 
0ff2			;		ld a, (input_cursor) 
0ff2			;		call addatohl 
0ff2			 
0ff2					; get char under cursor and replace with cursor 
0ff2			ld hl, (input_ptr) 
0ff2			;		ld a, (hl) 
0ff2			;		ld (input_under_cursor),a 
0ff2			;		ld a, '_' 
0ff2			;		ld (hl), a 
0ff2			 
0ff2					; display string 
0ff2			 
0ff2					ld de, (input_start) 
0ff2					ld a, (input_at_pos) 
0ff2					call str_at_display 
0ff2			;	        call update_display 
0ff2			 
0ff2					; find place to put the cursor 
0ff2			;		add h 
0ff2			;		ld l, display_row_1 
0ff2			;		sub l 
0ff2			; (input_at_pos) 
0ff2					;ld c, a 
0ff2			;		ld a, (input_cursor) 
0ff2			;		ld l, (input_at_pos) 
0ff2			;		;ld b, h 
0ff2			;		add l 
0ff2			;		ld (input_at_cursor),a 
0ff2					;ld l,h 
0ff2			 
0ff2			;		ld h, 0 
0ff2			;		ld l,(input_at_pos) 
0ff2			;		ld a, (input_cursor) 
0ff2			;		call addatohl 
0ff2			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0ff2			;		call subafromhl 
0ff2			;		ld a,l 
0ff2			;		ld (input_at_cursor), a 
0ff2			 
0ff2				if DEBUG_INPUT 
0ff2					ld a, (hardware_diag) 
0ff2					cp 0 
0ff2					jr z, .skip_input_diag 
0ff2			 
0ff2					ld a,(input_at_pos) 
0ff2					ld hl, LFSRSeed 
0ff2					call hexout 
0ff2					ld a, (input_cursor) 
0ff2					ld hl, LFSRSeed+2 
0ff2					call hexout 
0ff2					ld a,(input_at_cursor) 
0ff2					ld hl, LFSRSeed+4 
0ff2					call hexout 
0ff2			 
0ff2					ld a,(input_cur_onoff) 
0ff2					ld hl, LFSRSeed+6 
0ff2					call hexout 
0ff2			 
0ff2					ld a,(input_cur_flash) 
0ff2					ld hl, LFSRSeed+8 
0ff2					call hexout 
0ff2			 
0ff2					ld a,(input_len) 
0ff2					ld hl, LFSRSeed+10 
0ff2					call hexout 
0ff2					ld hl, LFSRSeed+12 
0ff2					ld a, 0 
0ff2					ld (hl),a 
0ff2					ld a, display_row_4 
0ff2					ld de, LFSRSeed 
0ff2					call str_at_display 
0ff2					.skip_input_diag: 
0ff2				endif 
0ff2			 
0ff2					; decide on if we are showing the cursor this time round 
0ff2			 
0ff2					ld a, (input_cur_onoff) 
0ff2					cp 255 
0ff2					jr z, .skipcur 
0ff2			 
0ff2			 
0ff2					ld a,(input_at_cursor) 
0ff2					ld de, cursor_shape 
0ff2					call str_at_display 
0ff2			 
0ff2					; save length of current input string 
0ff2					ld hl, (input_start) 
0ff2					ld a, 0 
0ff2					call strlent 
0ff2					ld a,l 
0ff2					ld (input_len),a 
0ff2			 
0ff2			.skipcur: 
0ff2			 
0ff2				        call update_display 
0ff2					 
0ff2			 
0ff2			 
0ff2					; wait 
0ff2				 
0ff2					; TODO loop without wait to flash the cursor and char under cursor	 
0ff2					call cin    ; _wait 
0ff2			 
0ff2					cp 0 
0ff2					jp z, .is1 
0ff2			 
0ff2					; get ptr to char to input into 
0ff2			 
0ff2					ld c,a 
0ff2					ld hl, (input_start) 
0ff2					ld a, (input_cursor) 
0ff2					call addatohl 
0ff2					ld (input_ptr), hl 
0ff2					ld a,c 
0ff2			 
0ff2					; replace char under cursor 
0ff2			 
0ff2			;		ld hl, (input_ptr) 
0ff2			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0ff2			;		ld (hl), a 
0ff2			 
0ff2			;	if DEBUG_INPUT 
0ff2			;		push af 
0ff2			;		ld a, 'i' 
0ff2			;		ld (debug_mark),a 
0ff2			;		pop af 
0ff2			;		CALLMONITOR 
0ff2			;	endif 
0ff2					cp KEY_HOME 
0ff2					jr nz, .iske 
0ff2			 
0ff2					ld a, (input_at_pos) 
0ff2					ld (input_at_cursor),a 
0ff2					ld a, 0 
0ff2					ld (input_cursor), a 
0ff2					jp .is1 
0ff2					 
0ff2			.iske:		cp KEY_END 
0ff2					jr nz, .isknw 
0ff2					jp .is1 
0ff2			 
0ff2			.isknw:		cp KEY_NEXTWORD 
0ff2					jr nz, .iskpw 
0ff2			 
0ff2			.isknwm:	ld hl, (input_ptr) 
0ff2					ld a,(hl)	 
0ff2					cp 0 
0ff2					jp z, .is1    ; end of string 
0ff2					cp ' ' 
0ff2					jp z, .is1    ; end of word 
0ff2					inc hl 
0ff2					ld (input_ptr), hl 
0ff2					ld a, (input_at_cursor) 
0ff2					inc a 
0ff2					ld (input_at_cursor), a 
0ff2					jr .isknwm 
0ff2			 
0ff2			.iskpw:		cp KEY_PREVWORD 
0ff2					jr nz, .iskl 
0ff2			.iskpwm:	 
0ff2					ld hl, (input_ptr) 
0ff2					ld a,(hl)	 
0ff2					cp 0  
0ff2					jp z, .is1    ; end of string 
0ff2					cp ' ' 
0ff2					jp z, .is1    ; end of word 
0ff2					dec hl 
0ff2					ld (input_ptr), hl 
0ff2					ld a, (input_at_cursor) 
0ff2					dec a 
0ff2					ld (input_at_cursor), a 
0ff2					jr .iskpwm 
0ff2			 
0ff2			 
0ff2			.iskl:		cp KEY_LEFT 
0ff2					jr nz, .isk1 
0ff2			 
0ff2					ld a, (input_cursor) 
0ff2			 
0ff2					cp 0 
0ff2					jp z, .is1 		; at start of line to ignore  
0ff2			 
0ff2					dec  a 		; TODO check underflow 
0ff2					ld (input_cursor), a 
0ff2			 
0ff2					ld hl, (input_ptr) 
0ff2					dec hl 
0ff2					ld (input_ptr), hl 
0ff2					 
0ff2					ld a, (input_at_cursor) 
0ff2					dec a 
0ff2					ld (input_at_cursor), a 
0ff2			 
0ff2					ld a, 1		; show cursor moving 
0ff2					ld (input_cur_onoff),a 
0ff2					ld a, CUR_BLINK_RATE 
0ff2					ld (input_cur_flash), a 
0ff2			 
0ff2					jp .is1 
0ff2			 
0ff2			.isk1:		cp KEY_RIGHT 
0ff2					jr nz, .isk2 
0ff2			 
0ff2					ld a,(input_len)		; TODO BUG why cant i load e direct? 
0ff2					ld e,a 
0ff2					ld a, (input_cursor) 
0ff2					cp e 
0ff2					jp z, .is1		; at the end of string so dont go right 
0ff2			 
0ff2					inc  a 		; TODO check overflow 
0ff2					ld (input_cursor), a 
0ff2			 
0ff2					ld a, (input_at_cursor) 
0ff2					inc a 
0ff2					ld (input_at_cursor), a 
0ff2			 
0ff2					ld hl, (input_ptr) 
0ff2					inc hl 
0ff2					ld (input_ptr), hl 
0ff2			 
0ff2					ld a, 1		; show cursor moving 
0ff2					ld (input_cur_onoff),a 
0ff2					ld a, CUR_BLINK_RATE 
0ff2					ld (input_cur_flash), a 
0ff2			 
0ff2					jp .is1 
0ff2			 
0ff2			.isk2:		cp KEY_UP 
0ff2			 
0ff2					jr nz, .isk3 
0ff2			 
0ff2					; swap last command with the current on 
0ff2			 
0ff2					; move cursor to start of string 
0ff2					ld hl, (input_start) 
0ff2					ld (input_ptr), hl 
0ff2			 
0ff2					ld a, (input_at_pos) 
0ff2					ld (input_at_cursor), a 
0ff2			 
0ff2					ld a, 0 
0ff2					ld (input_cursor), a 
0ff2					 
0ff2					; swap input and last command buffers 
0ff2			 
0ff2					ld hl, os_cli_cmd 
0ff2					ld de, os_last_cmd 
0ff2					ld b, 255 
0ff2			.swap1:		ld a, (hl) 
0ff2					ld c,a 
0ff2					ld a, (de) 
0ff2					ld (hl), a 
0ff2					ld a,c 
0ff2					ld (de),a 
0ff2					inc hl 
0ff2					inc de 
0ff2					djnz .swap1 
0ff2			 
0ff2			 
0ff2			 
0ff2			 
0ff2			 
0ff2					jp .is1 
0ff2			 
0ff2			.isk3:		cp KEY_BS 
0ff2					jr nz, .isk4 
0ff2			 
0ff2					ld a, (input_cursor) 
0ff2			 
0ff2					cp 0 
0ff2					jp z, .is1 		; at start of line to ignore  
0ff2			 
0ff2					dec  a 		; TODO check underflow 
0ff2					ld (input_cursor), a 
0ff2			 
0ff2					; hl is source 
0ff2					; de needs to be source - 1 
0ff2			 
0ff2			;		ld a, 0 
0ff2			;		dec hl 
0ff2			;		ld (hl), a 
0ff2			 
0ff2					ld hl, (input_ptr) 
0ff2					dec hl 
0ff2					ld (input_ptr), hl 
0ff2			 
0ff2					; shift all data 
0ff2			 
0ff2					push hl 
0ff2					inc hl 
0ff2					pop de 
0ff2					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0ff2					ld c,a 
0ff2					ld b,0 
0ff2					ldir  
0ff2			 
0ff2			 
0ff2			 
0ff2			 
0ff2					ld a, (input_at_cursor) 
0ff2					dec a 
0ff2					ld (input_at_cursor), a 
0ff2			 
0ff2			 
0ff2					ld a, 1		; show cursor moving 
0ff2					ld (input_cur_onoff),a 
0ff2					ld a, CUR_BLINK_RATE 
0ff2					ld (input_cur_flash), a 
0ff2			 
0ff2					; remove char 
0ff2					ld a, (input_at_cursor) 
0ff2					inc a 
0ff2					ld de,.iblank 
0ff2					call str_at_display 
0ff2			 
0ff2					jp .is1 
0ff2			 
0ff2			.isk4:		cp KEY_CR 
0ff2					jr z, .endinput 
0ff2			 
0ff2					; else add the key press to the end 
0ff2			 
0ff2					ld c, a			; save key pressed 
0ff2			 
0ff2					ld a,(hl)		; get what is currently under char 
0ff2			 
0ff2					cp 0			; we are at the end of the string 
0ff2					jr nz, .onchar 
0ff2					 
0ff2					; add a char to the end of the string 
0ff2				 
0ff2					ld (hl),c 
0ff2					inc hl 
0ff2			;		ld a,' ' 
0ff2			;		ld (hl),a 
0ff2			;		inc hl 
0ff2					ld a,0 
0ff2					ld (hl),a 
0ff2					dec hl 
0ff2			 
0ff2					ld a, (input_cursor) 
0ff2					inc a				; TODO check max string length and scroll  
0ff2					ld (input_cursor), a		; inc cursor pos 
0ff2							 
0ff2					ld a, (input_at_cursor) 
0ff2					inc a 
0ff2					ld (input_at_cursor), a 
0ff2			 
0ff2					ld hl, (input_ptr) 
0ff2					inc hl 
0ff2					ld (input_ptr), hl 
0ff2			 
0ff2					ld hl, (input_ptr) 
0ff2					inc hl 
0ff2					ld (input_ptr), hl 
0ff2			;	if DEBUG_INPUT 
0ff2			;		push af 
0ff2			;		ld a, '+' 
0ff2			;		ld (debug_mark),a 
0ff2			;		pop af 
0ff2			;		CALLMONITOR 
0ff2			;	endif 
0ff2					ld a, 1		; show cursor moving 
0ff2					ld (input_cur_onoff),a 
0ff2					ld a, CUR_BLINK_RATE 
0ff2					ld (input_cur_flash), a 
0ff2					jp .is1 
0ff2					 
0ff2			 
0ff2			 
0ff2					; if on a char then insert 
0ff2			.onchar: 
0ff2			 
0ff2					; TODO over flow check: make sure insert does not blow out buffer 
0ff2			 
0ff2					; need to do some maths to use lddr 
0ff2			 
0ff2					push hl   ; save char pos 
0ff2					push bc 
0ff2			 
0ff2					ld hl, (input_start) 
0ff2					ld a, (input_len) 
0ff2					call addatohl  		; end of string 
0ff2					inc hl 
0ff2					inc hl		; past zero term 
0ff2					push hl 
0ff2					inc hl 
0ff2					push hl  
0ff2			 
0ff2								; start and end of lddr set, now how much to move? 
0ff2			 
0ff2							 
0ff2					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0ff2					ld b,a 
0ff2					ld a,(input_len) 
0ff2					ld e,a 
0ff2					sub b 
0ff2					inc a		;?? 
0ff2					inc a		;?? 
0ff2					inc a		;?? 
0ff2			 
0ff2					ld b,0 
0ff2					ld c,a 
0ff2			 
0ff2				if DEBUG_INPUT 
0ff2					push af 
0ff2					ld a, 'i' 
0ff2					ld (debug_mark),a 
0ff2					pop af 
0ff2			;		CALLMONITOR 
0ff2				endif 
0ff2					pop de 
0ff2					pop hl 
0ff2				if DEBUG_INPUT 
0ff2					push af 
0ff2					ld a, 'I' 
0ff2					ld (debug_mark),a 
0ff2					pop af 
0ff2			;		CALLMONITOR 
0ff2				endif 
0ff2					lddr 
0ff2				 
0ff2			 
0ff2			 
0ff2					; TODO have a key for insert/overwrite mode???? 
0ff2					pop bc 
0ff2					pop hl 
0ff2					ld (hl), c		; otherwise overwrite current char 
0ff2					 
0ff2			 
0ff2			 
0ff2			 
0ff2					ld a, (input_cursor) 
0ff2					inc  a 		; TODO check overflow 
0ff2					ld (input_cursor), a 
0ff2			 
0ff2					ld a, (input_at_cursor) 
0ff2					inc a 
0ff2					ld (input_at_cursor), a 
0ff2			 
0ff2					jp .is1 
0ff2			 
0ff2			.endinput:	; TODO look for end of string 
0ff2			 
0ff2					; add trailing space for end of token 
0ff2			 
0ff2					ld hl, (input_start) 
0ff2					ld a,(input_len) 
0ff2					call addatohl 
0ff2					ld a, ' ' 
0ff2					ld (hl),a 
0ff2					; TODO eof of parse marker 
0ff2			 
0ff2					inc hl 
0ff2					ld a, 0 
0ff2					ld (hl),a 
0ff2			 
0ff2			 
0ff2					ret 
0ff2			 
0ff2			.iblank: db " ",0 
0ff2			 
0ff2			 
0ff2			input_str_prev:	ld (input_at_pos), a 
0ff2					ld (input_start), hl 
0ff2					ld a,1			; add cursor 
0ff2					ld (hl),a 
0ff2					inc hl 
0ff2					ld a,0 
0ff2					ld (hl),a 
0ff2					ld (input_ptr), hl 
0ff2					ld a,d 
0ff2					ld (input_size), a 
0ff2					ld a,0 
0ff2					ld (input_cursor),a 
0ff2			.instr1:	 
0ff2			 
0ff2					; TODO do block cursor 
0ff2					; TODO switch cursor depending on the modifer key 
0ff2			 
0ff2					; update cursor shape change on key hold 
0ff2			 
0ff2					ld hl, (input_ptr) 
0ff2					dec hl 
0ff2					ld a,(cursor_shape) 
0ff2					ld (hl), a 
0ff2			 
0ff2					; display entered text 
0ff2					ld a,(input_at_pos) 
0ff2			            	CALL fLCD_Pos       ;Position cursor to location in A 
0ff2			            	LD   de, (input_start) 
0ff2			            	CALL fLCD_Str       ;Display string pointed to by DE 
0ff2			 
0ff2					call cin 
0ff2					cp 0 
0ff2					jr z, .instr1 
0ff2			 
0ff2					; proecess keyboard controls first 
0ff2			 
0ff2					ld hl,(input_ptr) 
0ff2			 
0ff2					cp KEY_CR	 ; pressing enter ends input 
0ff2					jr z, .instrcr 
0ff2			 
0ff2					cp KEY_BS 	; back space 
0ff2					jr nz, .instr2 
0ff2					; process back space 
0ff2			 
0ff2					; TODO stop back space if at start of string 
0ff2					dec hl 
0ff2					dec hl ; to over write cursor 
0ff2					ld a,(cursor_shape) 
0ff2					;ld a,0 
0ff2					ld (hl),a 
0ff2					inc hl 
0ff2					ld a," " 
0ff2					ld (hl),a 
0ff2					ld (input_ptr),hl 
0ff2					 
0ff2			 
0ff2					jr .instr1 
0ff2			 
0ff2			.instr2:	cp KEY_LEFT    ; cursor left 
0ff2					jr nz, .instr3 
0ff2					dec hl 
0ff2					ld (input_ptr),hl 
0ff2					jr .instr1 
0ff2				 
0ff2			.instr3:	cp KEY_RIGHT      ; cursor right 
0ff2					jr nz, .instr4 
0ff2					inc hl 
0ff2					ld (input_ptr),hl 
0ff2					jr .instr1 
0ff2			 
0ff2			.instr4:	cp KEY_HOME    ; jump to start of line 
0ff2					jr nz, .instr5 
0ff2					dec hl 
0ff2					ld (input_ptr),hl 
0ff2					jr .instr1 
0ff2			 
0ff2			.instr5:	cp KEY_END     ; jump to end of line 
0ff2					jr nz, .instr6 
0ff2					dec hl 
0ff2					ld (input_ptr),hl 
0ff2					jr .instr1 
0ff2			.instr6:        cp KEY_UP      ; recall last command 
0ff2					jr nz, .instrnew 
0ff2			 
0ff2				ld hl, scratch 
0ff2				ld de, os_last_cmd 
0ff2				call strcpy 
0ff2					jr .instr1 
0ff2			 
0ff2			 
0ff2			.instrnew:	; no special key pressed to see if we have room to store it 
0ff2			 
0ff2					; TODO do string size test 
0ff2			 
0ff2					dec hl ; to over write cursor 
0ff2					ld (hl),a 
0ff2					inc hl 
0ff2					ld a,(cursor_shape) 
0ff2					ld (hl),a 
0ff2					inc hl 
0ff2					ld a,0 
0ff2					ld (hl),a 
0ff2			 
0ff2					ld (input_ptr),hl 
0ff2					 
0ff2					jr .instr1 
0ff2			.instrcr:	dec hl		; remove cursor 
0ff2					ld a,' '	; TODO add a trailing space for safety 
0ff2					ld (hl),a 
0ff2					inc hl 
0ff2					ld a,0 
0ff2					ld (hl),a 
0ff2			 
0ff2			 
0ff2					; if at end of line scroll up    
0ff2					; TODO detecting only end of line 4 for scroll up  
0ff2			 
0ff2					;ld   
0ff2			 
0ff2					ret 
0ff2			 
0ff2			 
0ff2			endif 
0ff2			; strcpy hl = dest, de source 
0ff2			 
0ff2 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0ff3 b7			            OR   A              ;Null terminator? 
0ff4 c8			            RET  Z              ;Yes, so finished 
0ff5 1a					ld a,(de) 
0ff6 77					ld (hl),a 
0ff7 13			            INC  DE             ;Point to next character 
0ff8 23					inc hl 
0ff9 18 f7		            JR   strcpy       ;Repeat 
0ffb c9					ret 
0ffc			 
0ffc			 
0ffc			; TODO string_at  
0ffc			; pass string which starts with lcd offset address and then null term string 
0ffc			 
0ffc			; TODO string to dec 
0ffc			; TODO string to hex 
0ffc			; TODO byte to string hex 
0ffc			; TODO byte to string dec 
0ffc			 
0ffc			 
0ffc			 
0ffc			; from z80uartmonitor 
0ffc			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ffc			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0ffc			; pass hl for where to put the text 
0ffc			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ffc c5			hexout:	PUSH BC 
0ffd f5					PUSH AF 
0ffe 47					LD B, A 
0fff					; Upper nybble 
0fff cb 3f				SRL A 
1001 cb 3f				SRL A 
1003 cb 3f				SRL A 
1005 cb 3f				SRL A 
1007 cd 17 10				CALL tohex 
100a 77					ld (hl),a 
100b 23					inc hl	 
100c					 
100c					; Lower nybble 
100c 78					LD A, B 
100d e6 0f				AND 0FH 
100f cd 17 10				CALL tohex 
1012 77					ld (hl),a 
1013 23					inc hl	 
1014					 
1014 f1					POP AF 
1015 c1					POP BC 
1016 c9					RET 
1017					 
1017			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1017			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1017			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1017			tohex: 
1017 e5					PUSH HL 
1018 d5					PUSH DE 
1019 16 00				LD D, 0 
101b 5f					LD E, A 
101c 21 24 10				LD HL, .DATA 
101f 19					ADD HL, DE 
1020 7e					LD A, (HL) 
1021 d1					POP DE 
1022 e1					POP HL 
1023 c9					RET 
1024			 
1024			.DATA: 
1024 30					DEFB	30h	; 0 
1025 31					DEFB	31h	; 1 
1026 32					DEFB	32h	; 2 
1027 33					DEFB	33h	; 3 
1028 34					DEFB	34h	; 4 
1029 35					DEFB	35h	; 5 
102a 36					DEFB	36h	; 6 
102b 37					DEFB	37h	; 7 
102c 38					DEFB	38h	; 8 
102d 39					DEFB	39h	; 9 
102e 41					DEFB	41h	; A 
102f 42					DEFB	42h	; B 
1030 43					DEFB	43h	; C 
1031 44					DEFB	44h	; D 
1032 45					DEFB	45h	; E 
1033 46					DEFB	46h	; F 
1034			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1034			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1034			;;    subtract $30, if result > 9 then subtract $7 more 
1034			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1034			atohex: 
1034 d6 30				SUB $30 
1036 fe 0a				CP 10 
1038 f8					RET M		; If result negative it was 0-9 so we're done 
1039 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
103b c9					RET		 
103c			 
103c			 
103c			 
103c			 
103c			; Get 2 ASCII characters as hex byte from pointer in hl 
103c			 
103c			BYTERD: 
103c 16 00			LD	D,00h		;Set up 
103e cd 46 10			CALL	HEXCON		;Get byte and convert to hex 
1041 87				ADD	A,A		;First nibble so 
1042 87				ADD	A,A		;multiply by 16 
1043 87				ADD	A,A		; 
1044 87				ADD	A,A		; 
1045 57				LD	D,A		;Save hi nibble in D 
1046			HEXCON: 
1046 7e				ld a, (hl)		;Get next chr 
1047 23				inc hl 
1048 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
104a fe 0a			CP	00Ah		;Is it 0-9 ? 
104c 38 02			JR	C,NALPHA	;If so miss next bit 
104e d6 07			SUB	007h		;Else convert alpha 
1050			NALPHA: 
1050 b2				OR	D		;Add hi nibble back 
1051 c9				RET			; 
1052			 
1052			 
1052			; 
1052			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1052			; Since the routines get_byte and therefore get_nibble are called, only valid 
1052			; characters (0-9a-f) are accepted. 
1052			; 
1052			;get_word        push    af 
1052			;                call    get_byte        ; Get the upper byte 
1052			;                ld      h, a 
1052			;                call    get_byte        ; Get the lower byte 
1052			;                ld      l, a 
1052			;                pop     af 
1052			;                ret 
1052			; 
1052			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1052			; the routine get_nibble is used only valid characters are accepted - the  
1052			; input routine only accepts characters 0-9a-f. 
1052			; 
1052 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1053 7e					ld a,(hl) 
1054 23					inc hl 
1055 cd 7a 10		                call    nibble2val      ; Get upper nibble 
1058 cb 07		                rlc     a 
105a cb 07		                rlc     a 
105c cb 07		                rlc     a 
105e cb 07		                rlc     a 
1060 47			                ld      b, a            ; Save upper four bits 
1061 7e					ld a,(hl) 
1062 cd 7a 10		                call    nibble2val      ; Get lower nibble 
1065 b0			                or      b               ; Combine both nibbles 
1066 c1			                pop     bc              ; Restore B (and C) 
1067 c9			                ret 
1068			; 
1068			; Get a hexadecimal digit from the serial line. This routine blocks until 
1068			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1068			; to the serial line interface. The lower 4 bits of A contain the value of  
1068			; that particular digit. 
1068			; 
1068			;get_nibble      ld a,(hl)           ; Read a character 
1068			;                call    to_upper        ; Convert to upper case 
1068			;                call    is_hex          ; Was it a hex digit? 
1068			;                jr      nc, get_nibble  ; No, get another character 
1068			 ;               call    nibble2val      ; Convert nibble to value 
1068			 ;               call    print_nibble 
1068			 ;               ret 
1068			; 
1068			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1068			; A valid hexadecimal digit is denoted by a set C flag. 
1068			; 
1068			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1068			;                ret     nc              ; Yes 
1068			;                cp      '0'             ; Less than '0'? 
1068			;                jr      nc, is_hex_1    ; No, continue 
1068			;                ccf                     ; Complement carry (i.e. clear it) 
1068			;                ret 
1068			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1068			;                ret     c               ; Yes 
1068			;                cp      'A'             ; Less than 'A'? 
1068			;                jr      nc, is_hex_2    ; No, continue 
1068			;                ccf                     ; Yes - clear carry and return 
1068			;                ret 
1068			;is_hex_2        scf                     ; Set carry 
1068			;                ret 
1068			; 
1068			; Convert a single character contained in A to upper case: 
1068			; 
1068 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
106a d8			                ret     c 
106b fe 7b		                cp      'z' + 1         ; > 'z'? 
106d d0			                ret     nc              ; Nothing to do, either 
106e e6 5f		                and     $5f             ; Convert to upper case 
1070 c9			                ret 
1071			 
1071			 
1071			to_lower: 
1071			 
1071			   ; if char is in [A-Z] make it lower case 
1071			 
1071			   ; enter : a = char 
1071			   ; exit  : a = lower case char 
1071			   ; uses  : af 
1071			 
1071 fe 41		   cp 'A' 
1073 d8			   ret c 
1074			    
1074 fe 5b		   cp 'Z'+1 
1076 d0			   ret nc 
1077			    
1077 f6 20		   or $20 
1079 c9			   ret 
107a			 
107a			; 
107a			; Expects a hexadecimal digit (upper case!) in A and returns the 
107a			; corresponding value in A. 
107a			; 
107a fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
107c 38 02		                jr      c, nibble2val_1 ; Yes 
107e d6 07		                sub     7               ; Adjust for A-F 
1080 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1082 e6 0f		                and     $f              ; Only return lower 4 bits 
1084 c9			                ret 
1085			; 
1085			; Print_nibble prints a single hex nibble which is contained in the lower  
1085			; four bits of A: 
1085			; 
1085			;print_nibble    push    af              ; We won't destroy the contents of A 
1085			;                and     $f              ; Just in case... 
1085			;                add     a, '0'             ; If we have a digit we are done here. 
1085			;                cp      '9' + 1         ; Is the result > 9? 
1085			;                jr      c, print_nibble_1 
1085			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1085			;print_nibble_1  call    putc            ; Print the nibble and 
1085			;                pop     af              ; restore the original value of A 
1085			;                ret 
1085			;; 
1085			;; Send a CR/LF pair: 
1085			; 
1085			;crlf            push    af 
1085			;                ld      a, cr 
1085			;                call    putc 
1085			;                ld      a, lf 
1085			;                call    putc 
1085			;                pop     af 
1085			;                ret 
1085			; 
1085			; Print_word prints the four hex digits of a word to the serial line. The  
1085			; word is expected to be in HL. 
1085			; 
1085			;print_word      push    hl 
1085			;                push    af 
1085			;                ld      a, h 
1085			;                call    print_byte 
1085			;                ld      a, l 
1085			;                call    print_byte 
1085			;                pop     af 
1085			;                pop     hl 
1085			;                ret 
1085			; 
1085			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1085			; The byte to be printed is expected to be in A. 
1085			; 
1085			;print_byte      push    af              ; Save the contents of the registers 
1085			;                push    bc 
1085			;                ld      b, a 
1085			;                rrca 
1085			;                rrca 
1085			;                rrca 
1085			;                rrca 
1085			;                call    print_nibble    ; Print high nibble 
1085			;                ld      a, b 
1085			;                call    print_nibble    ; Print low nibble 
1085			;                pop     bc              ; Restore original register contents 
1085			;                pop     af 
1085			;                ret 
1085			 
1085			 
1085			 
1085			 
1085			 
1085			fourehexhl:  
1085 7e				ld a,(hl) 
1086 cd 34 10			call atohex 
1089 cb 3f				SRL A 
108b cb 3f				SRL A 
108d cb 3f				SRL A 
108f cb 3f				SRL A 
1091 47				ld b, a 
1092 23				inc hl 
1093 7e				ld a,(hl) 
1094 23				inc hl 
1095 cd 34 10			call atohex 
1098 80				add b 
1099 57				ld d,a 
109a 7e				ld a,(hl) 
109b cd 34 10			call atohex 
109e cb 3f				SRL A 
10a0 cb 3f				SRL A 
10a2 cb 3f				SRL A 
10a4 cb 3f				SRL A 
10a6 47				ld b, a 
10a7 23				inc hl 
10a8 7e				ld a,(hl) 
10a9 23				inc hl 
10aa cd 34 10			call atohex 
10ad 80				add b 
10ae 5f				ld e, a 
10af d5				push de 
10b0 e1				pop hl 
10b1 c9				ret 
10b2			 
10b2			; pass hl. returns z set if the byte at hl is a digit 
10b2			;isdigithl:  
10b2			;	push bc 
10b2			;	ld a,(hl) 
10b2			;	cp ':' 
10b2			;	jr nc, .isdf 		; > 
10b2			;	cp '0' 
10b2			;	jr c, .isdf		; < 
10b2			; 
10b2			;	; TODO find a better way to set z 
10b2			; 
10b2			;	ld b,a 
10b2			;	cp b 
10b2			;	pop bc 
10b2			;	ret 
10b2			; 
10b2			;.isdf:	; not digit so clear z 
10b2			; 
10b2			;	; TODO find a better way to unset z 
10b2			; 
10b2			;	ld b,a 
10b2			;	inc b 
10b2			;	cp b 
10b2			; 
10b2			;	pop bc 
10b2			;	ret 
10b2				 
10b2				 
10b2			 
10b2			 
10b2			; pass hl as the four byte address to load 
10b2			 
10b2			get_word_hl:  
10b2 e5				push hl 
10b3 cd 52 10			call get_byte 
10b6				 
10b6 47				ld b, a 
10b7			 
10b7 e1				pop hl 
10b8 23				inc hl 
10b9 23				inc hl 
10ba			 
10ba			; TODO not able to handle a-f  
10ba 7e				ld a,(hl) 
10bb			;	;cp ':' 
10bb			;	cp 'g' 
10bb			;	jr nc, .single_byte_hl 		; > 
10bb			;	cp 'G' 
10bb			;	jr nc, .single_byte_hl 		; > 
10bb			;	cp '0' 
10bb			;	jr c, .single_byte_hl		; < 
10bb			 
10bb				;call isdigithl 
10bb fe 00			cp 0 
10bd 28 06			jr z, .single_byte_hl 
10bf			 
10bf			.getwhln:   ; hex word so get next byte 
10bf			 
10bf cd 52 10			call get_byte 
10c2 6f				ld l, a 
10c3 60				ld h,b 
10c4 c9				ret 
10c5 68			.single_byte_hl:   ld l,b 
10c6 26 00				ld h,0 
10c8 c9					ret 
10c9			 
10c9			 
10c9			 
10c9			 
10c9 21 56 18			ld hl,asc+1 
10cc			;	ld a, (hl) 
10cc			;	call nibble2val 
10cc cd 52 10			call get_byte 
10cf			 
10cf			;	call fourehexhl 
10cf 32 f5 e2			ld (scratch+52),a 
10d2				 
10d2 21 f3 e2			ld hl,scratch+50 
10d5 22 e4 e5			ld (os_cur_ptr),hl 
10d8			 
10d8 c9				ret 
10d9			 
10d9			 
10d9			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10d9			 
10d9			; Decimal Unsigned Version 
10d9			 
10d9			;Number in a to decimal ASCII 
10d9			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10d9			;Example: display a=56 as "056" 
10d9			;input: a = number 
10d9			;Output: a=0,value of a in the screen 
10d9			;destroys af,bc (don't know about hl and de) 
10d9			DispAToASCII: 
10d9 0e 9c			ld	c,-100 
10db cd e5 10			call	.Na1 
10de 0e f6			ld	c,-10 
10e0 cd e5 10			call	.Na1 
10e3 0e ff			ld	c,-1 
10e5 06 2f		.Na1:	ld	b,'0'-1 
10e7 04			.Na2:	inc	b 
10e8 81				add	a,c 
10e9 38 fc			jr	c,.Na2 
10eb 91				sub	c		;works as add 100/10/1 
10ec f5				push af		;safer than ld c,a 
10ed 78				ld	a,b		;char is in b 
10ee			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10ee f1				pop af		;safer than ld a,c 
10ef c9				ret 
10f0			 
10f0			; Decimal Signed Version 
10f0			 
10f0			; DispA 
10f0			; -------------------------------------------------------------- 
10f0			; Converts a signed integer value to a zero-terminated ASCII 
10f0			; string representative of that value (using radix 10). 
10f0			; -------------------------------------------------------------- 
10f0			; INPUTS: 
10f0			;     HL     Value to convert (two's complement integer). 
10f0			;     DE     Base address of string destination. (pointer). 
10f0			; -------------------------------------------------------------- 
10f0			; OUTPUTS: 
10f0			;     None 
10f0			; -------------------------------------------------------------- 
10f0			; REGISTERS/MEMORY DESTROYED 
10f0			; AF HL 
10f0			; -------------------------------------------------------------- 
10f0			 
10f0			;DispHLToASCII: 
10f0			;   push    de 
10f0			;   push    bc 
10f0			; 
10f0			;; Detect sign of HL. 
10f0			;    bit    7, h 
10f0			;    jr     z, ._DoConvert 
10f0			; 
10f0			;; HL is negative. Output '-' to string and negate HL. 
10f0			;    ld     a, '-' 
10f0			;    ld     (de), a 
10f0			;    inc    de 
10f0			; 
10f0			;; Negate HL (using two's complement) 
10f0			;    xor    a 
10f0			;    sub    l 
10f0			;    ld     l, a 
10f0			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10f0			;    sbc    a, h 
10f0			;    ld     h, a 
10f0			; 
10f0			;; Convert HL to digit characters 
10f0			;._DoConvert: 
10f0			;    ld     b, 0     ; B will count character length of number 
10f0			;-   ld     a, 10 
10f0			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10f0			;    push   af 
10f0			;    inc    b 
10f0			;    ld     a, h 
10f0			;    or     l 
10f0			;    jr     nz, - 
10f0			; 
10f0			;; Retrieve digits from stack 
10f0			;-   pop    af 
10f0			;    or     $30 
10f0			;    ld     (de), a 
10f0			;    inc    de 
10f0			;    djnz   - 
10f0			; 
10f0			;; Terminate string with NULL 
10f0			;    xor    a 
10f0			;    ld     (de), a 
10f0			; 
10f0			;    pop    bc 
10f0			;    pop    de 
10f0			;    ret 
10f0			 
10f0			;Comments 
10f0			; 
10f0			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10f0			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10f0			;    Note that the output string will not be fixed-width. 
10f0			; 
10f0			;Example Usage 
10f0			; 
10f0			;    ld    hl, -1004 
10f0			;    ld    de, OP1 
10f0			;    call  DispA 
10f0			;    ld    hl, OP1 
10f0			;    syscall  PutS 
10f0			 
10f0			 
10f0			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10f0			 
10f0			 
10f0			;Converts an ASCII string to an unsigned 16-bit integer 
10f0			;Quits when it reaches a non-decimal digit 
10f0			 
10f0			string_to_uint16: 
10f0			atoui_16: 
10f0			;Input: 
10f0			;     DE points to the string 
10f0			;Outputs: 
10f0			;     HL is the result 
10f0			;     A is the 8-bit value of the number 
10f0			;     DE points to the byte after the number 
10f0			;Destroys: 
10f0			;     BC 
10f0			;       if the string is non-empty, BC is HL/10 
10f0			;Size:  24 bytes 
10f0			;Speed: 42+d(104+{0,9}) 
10f0			;       d is the number of digits in the number 
10f0			;       max is 640 cycles for a 5 digit number 
10f0			;Assuming no leading zeros: 
10f0			;1 digit:  146cc 
10f0			;2 digit:  250cc 
10f0			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10f0			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10f0			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10f0			;avg: 544.81158447265625cc (544+13297/16384) 
10f0			;=============================================================== 
10f0 21 00 00		  ld hl,0 
10f3			.u16a: 
10f3 1a			  ld a,(de) 
10f4 d6 30		  sub 30h 
10f6 fe 0a		  cp 10 
10f8 d0			  ret nc 
10f9 13			  inc de 
10fa 44			  ld b,h 
10fb 4d			  ld c,l 
10fc 29			  add hl,hl 
10fd 29			  add hl,hl 
10fe 09			  add hl,bc 
10ff 29			  add hl,hl 
1100 85			  add a,l 
1101 6f			  ld l,a 
1102 30 ef		  jr nc,.u16a 
1104 24			  inc h 
1105 c3 f3 10		  jp .u16a 
1108			 
1108			 
1108			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1108			 
1108			;written by Zeda 
1108			;Converts a 16-bit unsigned integer to an ASCII string. 
1108			 
1108			uitoa_16: 
1108			;Input: 
1108			;   DE is the number to convert 
1108			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1108			;Output: 
1108			;   HL points to the null-terminated ASCII string 
1108			;      NOTE: This isn't necessarily the same as the input HL. 
1108 d5			  push de 
1109 c5			  push bc 
110a f5			  push af 
110b eb			  ex de,hl 
110c			 
110c 01 f0 d8		  ld bc,-10000 
110f 3e 2f		  ld a,'0'-1 
1111 3c			  inc a 
1112 09			  add hl,bc  
1113 38 fc		   jr c,$-2 
1115 12			  ld (de),a 
1116 13			  inc de 
1117			 
1117 01 e8 03		  ld bc,1000 
111a 3e 3a		  ld a,'9'+1 
111c 3d			  dec a  
111d 09			  add hl,bc  
111e 30 fc		   jr nc,$-2 
1120 12			  ld (de),a 
1121 13			  inc de 
1122			 
1122 01 9c ff		  ld bc,-100 
1125 3e 2f		  ld a,'0'-1 
1127 3c			  inc a  
1128 09			  add hl,bc  
1129 38 fc		   jr c,$-2 
112b 12			  ld (de),a 
112c 13			  inc de 
112d			 
112d 7d			  ld a,l 
112e 26 3a		  ld h,'9'+1 
1130 25			  dec h  
1131 c6 0a		  add a,10  
1133 30 fb		   jr nc,$-3 
1135 c6 30		  add a,'0' 
1137 eb			  ex de,hl 
1138 72			  ld (hl),d 
1139 23			  inc hl 
113a 77			  ld (hl),a 
113b 23			  inc hl 
113c 36 00		  ld (hl),0 
113e			 
113e			;Now strip the leading zeros 
113e 0e fa		  ld c,-6 
1140 09			  add hl,bc 
1141 3e 30		  ld a,'0' 
1143 23			  inc hl  
1144 be			  cp (hl)  
1145 28 fc		  jr z,$-2 
1147			 
1147			;Make sure that the string is non-empty! 
1147 7e			  ld a,(hl) 
1148 b7			  or a 
1149 20 01		  jr nz,.atoub 
114b 2b			  dec hl 
114c			.atoub: 
114c			 
114c f1			  pop af 
114d c1			  pop bc 
114e d1			  pop de 
114f c9			  ret 
1150			 
1150			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1150			 
1150			toUpper: 
1150			;A is the char. 
1150			;If A is a lowercase letter, this sets it to the matching uppercase 
1150			;18cc or 30cc or 41cc 
1150			;avg: 26.75cc 
1150 fe 61		  cp 'a' 
1152 d8			  ret c 
1153 fe 7b		  cp 'z'+1 
1155 d0			  ret nc 
1156 d6 20		  sub 'a'-'A' 
1158 c9			  ret 
1159			 
1159			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1159			 
1159			; String Length 
1159			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1159			 
1159			; Get the length of the null-terminated string starting at $8000 hl 
1159			;    LD     HL, $8000 
1159			 
1159			strlenz: 
1159			 
1159 af			    XOR    A               ; Zero is the value we are looking for. 
115a 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
115b 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
115c			                           ; 65, 536 bytes (the entire addressable memory space). 
115c ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
115e			 
115e			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
115e 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
115f 6f			    LD     L, A             ; number of bytes 
1160 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1162 2b			    DEC    HL              ; Compensate for null. 
1163 c9				ret 
1164			 
1164			; Get the length of the A terminated string starting at $8000 hl 
1164			;    LD     HL, $8000 
1164			 
1164			strlent: 
1164			 
1164			                  ; A is the value we are looking for. 
1164 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1166 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1168			                           ; 65, 536 bytes (the entire addressable memory space). 
1168 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
116a			 
116a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
116a 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
116c 2e 00		    LD     L, 0             ; number of bytes 
116e ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1170 2b			    DEC    HL              ; Compensate for null. 
1171 c9				ret 
1172			 
1172			 
1172			;Comparing Strings 
1172			 
1172			;IN    HL     Address of string1. 
1172			;      DE     Address of string2. 
1172			 
1172			; doc given but wrong??? 
1172			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1172			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1172			; tested 
1172			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1172			 
1172			strcmp_old: 
1172 e5			    PUSH   HL 
1173 d5			    PUSH   DE 
1174			 
1174 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1175 be			    CP     (HL)            ; (want to minimize work). 
1176 38 01		    JR     C, Str1IsBigger 
1178 7e			    LD     A, (HL) 
1179			 
1179			Str1IsBigger: 
1179 4f			    LD     C, A             ; Put length in BC 
117a 06 00		    LD     B, 0 
117c 13			    INC    DE              ; Increment pointers to meat of string. 
117d 23			    INC    HL 
117e			 
117e			CmpLoop: 
117e 1a			    LD     A, (DE)          ; Compare bytes. 
117f ed a1		    CPI 
1181 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1183 13			    INC    DE              ; Update pointer. 
1184 ea 7e 11		    JP     PE, CmpLoop 
1187			 
1187 d1			    POP    DE 
1188 e1			    POP    HL 
1189 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
118a be			    CP     (HL) 
118b c9			    RET 
118c			 
118c			NoMatch: 
118c 2b			    DEC    HL 
118d be			    CP     (HL)            ; Compare again to affect carry. 
118e d1			    POP    DE 
118f e1			    POP    HL 
1190 c9			    RET 
1191			 
1191			;; test strmp 
1191			; 
1191			;ld de, .str1 
1191			;ld hl, .str2 
1191			;call strcmp 
1191			;jr z, .z1 
1191			;;this 
1191			;	if DEBUG_FORTH_WORDS 
1191			;		DMARK "NZ1" 
1191			;		CALLMONITOR 
1191			;	endif 
1191			;.z1: 
1191			; 
1191			;	if DEBUG_FORTH_WORDS 
1191			;		DMARK "ZZ1" 
1191			;		CALLMONITOR 
1191			;	endif 
1191			; 
1191			;ld de, .str1 
1191			;ld hl, .str1 
1191			;call strcmp 
1191			;jr z, .z2 
1191			;;this 
1191			;	if DEBUG_FORTH_WORDS 
1191			;		DMARK "NZ2" 
1191			;		CALLMONITOR 
1191			;	endif 
1191			;.z2: 
1191			; 
1191			;	if DEBUG_FORTH_WORDS 
1191			;		DMARK "ZZ2" 
1191			;		CALLMONITOR 
1191			;	endif 
1191			; 
1191			;ld de, .str1 
1191			;ld hl, .str2 
1191			;call strcmp 
1191			;jr c, .c1 
1191			; 
1191			;	if DEBUG_FORTH_WORDS 
1191			;		DMARK "Nc1" 
1191			;		CALLMONITOR 
1191			;	endif 
1191			;.c1: 
1191			;;this 
1191			;	if DEBUG_FORTH_WORDS 
1191			;		DMARK "cc1" 
1191			;		CALLMONITOR 
1191			;	endif 
1191			; 
1191			;ld de, .str1 
1191			;ld hl, .str1 
1191			;call strcmp 
1191			;jr c, .c2 
1191			;;this 
1191			;	if DEBUG_FORTH_WORDS 
1191			;		DMARK "Nc2" 
1191			;		CALLMONITOR 
1191			;	endif 
1191			;.c2: 
1191			; 
1191			;	if DEBUG_FORTH_WORDS 
1191			;		DMARK "cc2" 
1191			;		CALLMONITOR 
1191			;	endif 
1191			;	NEXTW 
1191			;.str1:   db "string1",0 
1191			;.str2:   db "string2",0 
1191			 
1191			; only care about direct match or not 
1191			; hl and de strings 
1191			; zero set if the same 
1191			 
1191			strcmp: 
1191 1a				ld a, (de) 
1192 be				cp (hl) 
1193 28 02			jr z, .ssame 
1195 b7				or a 
1196 c9				ret 
1197			 
1197			.ssame:  
1197 fe 00			cp 0 
1199 c8				ret z 
119a			 
119a 23				inc hl 
119b 13				inc de 
119c 18 f3			jr strcmp 
119e				 
119e				 
119e			 
119e			;Copyright (c) 2014, Luke Maurits 
119e			;All rights reserved. 
119e			; 
119e			;Redistribution and use in source and binary forms, with or without 
119e			;modification, are permitted provided that the following conditions are met: 
119e			; 
119e			;* Redistributions of source code must retain the above copyright notice, this 
119e			;  list of conditions and the following disclaimer. 
119e			; 
119e			;* Redistributions in binary form must reproduce the above copyright notice, 
119e			;  this list of conditions and the following disclaimer in the documentation 
119e			;  and/or other materials provided with the distribution. 
119e			; 
119e			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
119e			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
119e			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
119e			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
119e			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
119e			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
119e			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
119e			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
119e			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
119e			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
119e			 
119e			; https://github.com/lmaurits/lm512/blob/master/string.z80 
119e			 
119e			StrictStrCmp: 
119e				; Load next chars of each string 
119e 1a				ld a, (de) 
119f 47				ld b, a 
11a0 7e				ld a, (hl) 
11a1				; Compare 
11a1 b8				cp b 
11a2				; Return non-zero if chars don't match 
11a2 c0				ret nz 
11a3				; Check for end of both strings 
11a3 fe 00			cp "\0" 
11a5				; Return if strings have ended 
11a5 c8				ret z 
11a6				; Otherwise, advance to next chars 
11a6 23				inc hl 
11a7 13				inc de 
11a8 18 f4			jr StrictStrCmp 
11aa			 
11aa			;end 
11aa			; eof 
11aa			 
11aa			 
11aa			 
11aa			 
11aa			 
11aa			 
# End of file firmware_strings.asm
11aa			include "firmware_memory.asm"   ; malloc and free  
11aa			 
11aa			if DEBUG_FORTH_MALLOC_HIGH 
11aa			.mallocsize: db "Wants malloc >256",0 
11aa			.mallocasize: db "MALLOC gives >256",0 
11aa			.malloczero: db "MALLOC gives zero",0 
11aa			 
11aa			malloc_guard_zerolen: 
11aa				push hl 
11aa				push de 
11aa				push af 
11aa			 
11aa				ld de, 0 
11aa			        call cmp16 
11aa				jr nz, .lowalloz 
11aa			 
11aa				push hl 
11aa				push de 
11aa					ld hl, display_fb0 
11aa					ld (display_fb_active), hl 
11aa				call clear_display 
11aa				ld a, 0 
11aa				ld de, .malloczero 
11aa				call str_at_display 
11aa				call update_display 
11aa				call delay1s 
11aa				call delay1s 
11aa				call bp_on 
11aa			;	ld a, 0 
11aa			;	ld (os_view_disable), a 
11aa			 
11aa				pop de 
11aa				pop hl 
11aa			 
11aa				 
11aa			 
11aa				CALLMONITOR 
11aa			.lowalloz: 
11aa			 
11aa			 
11aa				pop af 
11aa				pop de 
11aa				pop hl 
11aa			ret 
11aa			 
11aa			malloc_guard_entry: 
11aa				push hl 
11aa				push de 
11aa				push af 
11aa			 
11aa			 	or a      ;clear carry flag 
11aa				push hl 
11aa				ld de, 255 
11aa				sbc hl, de 
11aa				jr c, .lowalloc 
11aa			 
11aa				push de 
11aa					ld hl, display_fb0 
11aa					ld (display_fb_active), hl 
11aa				call clear_display 
11aa				ld a, 0 
11aa				ld de, .mallocsize 
11aa				call str_at_display 
11aa				call update_display 
11aa				call delay1s 
11aa				call delay1s 
11aa			;	ld a, 0 
11aa			;	ld (os_view_disable), a 
11aa				call bp_on 
11aa			 
11aa				pop de 
11aa				pop hl 
11aa			 
11aa				 
11aa			 
11aa				CALLMONITOR 
11aa				jr .lowdone 
11aa			.lowalloc: 
11aa			 
11aa			 
11aa				pop hl 
11aa			.lowdone:	pop af 
11aa				pop de 
11aa				pop hl 
11aa			ret 
11aa			 
11aa			malloc_guard_exit: 
11aa				push hl 
11aa				push de 
11aa				push af 
11aa			 
11aa			 	or a      ;clear carry flag 
11aa				push hl 
11aa				ld de, 255 
11aa				sbc hl, de 
11aa				jr c, .lowallocx 
11aa			 
11aa				push de 
11aa					ld hl, display_fb0 
11aa					ld (display_fb_active), hl 
11aa				call clear_display 
11aa				ld a, 0 
11aa				ld de, .mallocasize 
11aa				call str_at_display 
11aa				call update_display 
11aa				call delay1s 
11aa				call delay1s 
11aa			;	ld a, 0 
11aa			;	ld (os_view_disable), a 
11aa				call bp_on 
11aa				pop de 
11aa				pop hl 
11aa			 
11aa				CALLMONITOR 
11aa				jr .lowdonex 
11aa			.lowallocx: 
11aa			 
11aa				pop hl 
11aa			.lowdonex:	pop af 
11aa				pop de 
11aa				pop hl 
11aa			ret 
11aa			endif 
11aa			 
11aa			if MALLOC_2 
11aa			; Z80 Malloc and Free Functions 
11aa			 
11aa			; Malloc Function: 
11aa			; Input: 
11aa			;   HL: Size of block to allocate 
11aa			; Output: 
11aa			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11aa			 
11aa			malloc: 
11aa				 
11aa			if DEBUG_FORTH_MALLOC_HIGH 
11aa			call malloc_guard_entry 
11aa			endif 
11aa			 
11aa			 
11aa			 
11aa			 
11aa					if DEBUG_FORTH_MALLOC 
11aa						DMARK "mal" 
11aa						CALLMONITOR 
11aa					endif 
11aa			    push af            ; Save AF register 
11aa			    ld a, l            ; Load low byte of size into A 
11aa			    or h               ; Check if size is zero 
11aa			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11aa			 
11aa			    ; Allocate memory 
11aa			    ld hl, (heap_start) ; Load start of heap into HL 
11aa					if DEBUG_FORTH_MALLOC 
11aa						DMARK "ma1" 
11aa						CALLMONITOR 
11aa					endif 
11aa			    call malloc_internal ; Call internal malloc function 
11aa			    pop af             ; Restore AF register 
11aa			if DEBUG_FORTH_MALLOC_HIGH 
11aa			call malloc_guard_exit 
11aa			call malloc_guard_zerolen 
11aa			endif 
11aa			    ret                ; Return 
11aa			 
11aa			; Free Function: 
11aa			; Input: 
11aa			;   HL: Pointer to memory block to free 
11aa			; Output: 
11aa			;   None 
11aa			 
11aa			free: 
11aa			    push af            ; Save AF register 
11aa			    ld a, l            ; Load low byte of pointer into A 
11aa			    or h               ; Check if pointer is NULL 
11aa			    jp z, free_exit    ; If pointer is NULL, exit 
11aa			 
11aa			    ; Free memory 
11aa			    ld hl, (heap_start) ; Load start of heap into HL 
11aa			    call free_internal  ; Call internal free function 
11aa			    pop af             ; Restore AF register 
11aa			    ret                ; Return 
11aa			 
11aa			; Internal Malloc Function: 
11aa			; Input: 
11aa			;   HL: Size of block to allocate 
11aa			; Output: 
11aa			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11aa			 
11aa			malloc_internal: 
11aa			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11aa			    add hl, bc         ; Add management overhead to requested size 
11aa			    ex de, hl          ; Save total size in DE, and keep it in HL 
11aa					if DEBUG_FORTH_MALLOC 
11aa						DMARK "ma2" 
11aa						CALLMONITOR 
11aa					endif 
11aa			 
11aa			    ; Search for free memory block 
11aa			    ld de, (heap_end)  ; Load end of heap into DE 
11aa			    ld bc, 0           ; Initialize counter 
11aa			 
11aa					if DEBUG_FORTH_MALLOC 
11aa						DMARK "ma2" 
11aa						CALLMONITOR 
11aa					endif 
11aa			malloc_search_loop: 
11aa			    ; Check if current block is free 
11aa			    ld a, (hl)         ; Load current block's status (free or used) 
11aa			    cp 0               ; Compare with zero (free) 
11aa			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11aa			 
11aa			    ; Check if current block is large enough 
11aa			    ld a, (hl+1)       ; Load high byte of block size 
11aa			    cp l               ; Compare with low byte of requested size 
11aa			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11aa			 
11aa			    ld a, (hl+2)       ; Load low byte of block size 
11aa			    cp h               ; Compare with high byte of requested size 
11aa			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11aa			 
11aa			    ; Mark block as used 
11aa			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11aa			 
11aa			    ; Calculate remaining space in block 
11aa			    ld bc, 0           ; Clear BC 
11aa			    add hl, bc         ; Increment HL to point to start of data block 
11aa			    add hl, de         ; HL = HL + DE (total size) 
11aa			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11aa			    add hl, bc         ; Add management overhead to start of data block 
11aa			 
11aa			    ; Save pointer to allocated block in HL 
11aa			if DEBUG_FORTH_MALLOC_HIGH 
11aa						DMARK "ma5" 
11aa			call malloc_guard_exit 
11aa			call malloc_guard_zerolen 
11aa			endif 
11aa			    ret 
11aa			 
11aa			malloc_skip_block_check: 
11aa			    ; Move to the next block 
11aa			    ld bc, 3           ; Size of management overhead 
11aa			    add hl, bc         ; Move to the next block 
11aa			    inc de             ; Increment counter 
11aa			 
11aa			    ; Check if we have reached the end of heap 
11aa			    ld a, e            ; Load low byte of heap end address 
11aa			    cp (hl)            ; Compare with low byte of current address 
11aa			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11aa			    ld a, d            ; Load high byte of heap end address 
11aa			    cp 0               ; Check if it's zero (end of memory) 
11aa			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11aa			 
11aa			    ; If we reached here, allocation failed 
11aa			    xor a              ; Set result to NULL 
11aa			if DEBUG_FORTH_MALLOC_HIGH 
11aa						DMARK "ma6" 
11aa			call malloc_guard_exit 
11aa			call malloc_guard_zerolen 
11aa			endif 
11aa			    ret 
11aa			malloc_exit: 
11aa			if DEBUG_FORTH_MALLOC_HIGH 
11aa						DMARK "ma7" 
11aa			call malloc_guard_exit 
11aa			call malloc_guard_zerolen 
11aa			endif 
11aa			    ret 
11aa			 
11aa			; Internal Free Function: 
11aa			; Input: 
11aa			;   HL: Pointer to memory block to free 
11aa			; Output: 
11aa			;   None 
11aa			 
11aa			free_internal: 
11aa			    ld de, (heap_start) ; Load start of heap into DE 
11aa			    ld bc, 0            ; Initialize counter 
11aa			 
11aa			free_search_loop: 
11aa			    ; Check if current block contains the pointer 
11aa			    ld a, l             ; Load low byte of pointer 
11aa			    cp (hl+1)           ; Compare with high byte of current block's address 
11aa			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11aa			    ld a, h             ; Load high byte of pointer 
11aa			    cp (hl+2)           ; Compare with low byte of current block's address 
11aa			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11aa			 
11aa			    ; Mark block as free 
11aa			    ld (hl), 0          ; Set status byte to indicate free block 
11aa			    ret                 ; Return 
11aa			 
11aa			free_skip_block_check: 
11aa			    ; Move to the next block 
11aa			    ld bc, 3            ; Size of management overhead 
11aa			    add hl, bc          ; Move to the next block 
11aa			    inc de              ; Increment counter 
11aa			 
11aa			    ; Check if we have reached the end of heap 
11aa			    ld a, e             ; Load low byte of heap end address 
11aa			    cp (hl)             ; Compare with low byte of current address 
11aa			    jr nz, free_search_loop  ; If not equal, continue searching 
11aa			    ld a, d             ; Load high byte of heap end address 
11aa			    cp 0                ; Check if it's zero (end of memory) 
11aa			    jr nz, free_search_loop  ; If not zero, continue searching 
11aa			 
11aa			    ; If we reached here, pointer is not found in heap 
11aa			    ret 
11aa			 
11aa			free_exit: 
11aa			    ret                 ; Return 
11aa			 
11aa			; Define heap start and end addresses 
11aa			;heap_start:    .dw 0xC000   ; Start of heap 
11aa			;heap_end:      .dw 0xE000   ; End of heap 
11aa			 
11aa			endif 
11aa			 
11aa			 
11aa			if MALLOC_1 
11aa			 
11aa			 
11aa			 
11aa			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11aa			 
11aa			;moved to firmware.asm 
11aa			;heap_start        .equ  0x9000      ; Starting address of heap 
11aa			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11aa			 
11aa			;      .org 0 
11aa			;      jp    main 
11aa			 
11aa			 
11aa			;      .org  0x100 
11aa			;main: 
11aa			;      ld    HL, 0x8100 
11aa			;      ld    SP, HL 
11aa			; 
11aa			;      call  heap_init 
11aa			; 
11aa			;      ; Make some allocations 
11aa			;      ld    HL, 12 
11aa			;      call  malloc            ; Allocates 0x9004 
11aa			; 
11aa			;      ld    HL, 12 
11aa			;      call  malloc            ; Allocates 0x9014 
11aa			; 
11aa			;      ld    HL, 12 
11aa			;      call  malloc            ; Allocates 0x9024 
11aa			; 
11aa			;      ; Free some allocations 
11aa			;      ld    HL, 0x9014 
11aa			;      call  free 
11aa			; 
11aa			;      ld    HL, 0x9004 
11aa			;      call  free 
11aa			; 
11aa			;      ld    HL, 0x9024 
11aa			;      call  free 
11aa			; 
11aa			; 
11aa			;      halt 
11aa			 
11aa			 
11aa			;------------------------------------------------------------------------------ 
11aa			;     heap_init                                                               : 
11aa			;                                                                             : 
11aa			; Description                                                                 : 
11aa			;     Initialise the heap and make it ready for malloc and free operations.   : 
11aa			;                                                                             : 
11aa			;     The heap is maintained as a linked list, starting with an initial       : 
11aa			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11aa			;     the first free block in the heap. Each block then points to the next    : 
11aa			;     free block within the heap, and the free list ends at the first block   : 
11aa			;     with a null pointer to the next free block.                             : 
11aa			;                                                                             : 
11aa			; Parameters                                                                  : 
11aa			;     Inputs are compile-time only. Two defines which specify the starting    : 
11aa			;     address of the heap and its size are required, along with a memory      : 
11aa			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11aa			;     principally stores a pointer to the first free block in the heap.       : 
11aa			;                                                                             : 
11aa			; Returns                                                                     : 
11aa			;     Nothing                                                                 : 
11aa			;------------------------------------------------------------------------------ 
11aa			heap_init: 
11aa e5			      push  HL 
11ab			 
11ab			      ; Initialise free list struct 
11ab 21 6b 65		      ld    HL, heap_start 
11ae 22 66 65		      ld    (free_list), HL 
11b1 21 00 00		      ld    HL, 0 
11b4 22 68 65		      ld    (free_list+2), HL 
11b7			 
11b7			      ; Insert first free block at bottom of heap, consumes entire heap 
11b7 21 98 e2		      ld    HL, heap_start+heap_size-4 
11ba 22 6b 65		      ld    (heap_start), HL        ; Next block (end of free list) 
11bd 21 2d 7d		      ld    HL, heap_size-4 
11c0 22 6d 65		      ld    (heap_start+2), HL      ; Block size 
11c3			 
11c3			      ; Insert end of free list block at top of heap - two null words will 
11c3			      ; terminate the free list 
11c3 21 00 00		      ld    HL, 0 
11c6 22 9a e2		      ld    (heap_start+heap_size-2), HL 
11c9 22 98 e2		      ld    (heap_start+heap_size-4), HL 
11cc			 
11cc e1			      pop   HL 
11cd			 
11cd c9			      ret 
11ce			 
11ce			 
11ce			;------------------------------------------------------------------------------ 
11ce			;     malloc                                                                  : 
11ce			;                                                                             : 
11ce			; Description                                                                 : 
11ce			;     Allocates the wanted space from the heap and returns the address of the : 
11ce			;     first useable byte of the allocation.                                   : 
11ce			;                                                                             : 
11ce			;     Allocations can happen in one of two ways:                              : 
11ce			;                                                                             : 
11ce			;     1. A free block may be found which is the exact size wanted. In this    : 
11ce			;        case the block is removed from the free list and retuedn to the      : 
11ce			;        caller.                                                              : 
11ce			;     2. A free block may be found which is larger than the size wanted. In   : 
11ce			;        this case, the larger block is split into two. The first portion of  : 
11ce			;        this block will become the requested space by the malloc call and    : 
11ce			;        is returned to the caller. The second portion becomes a new free     : 
11ce			;        block, and the free list is adjusted to maintain continuity via this : 
11ce			;        newly created block.                                                 : 
11ce			;                                                                             : 
11ce			;     malloc does not set any initial value in the allocated space, the       : 
11ce			;     caller is required to do this as required.                              : 
11ce			;                                                                             : 
11ce			;     This implementation of malloc uses the stack exclusively, and is        : 
11ce			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11ce			;     advisable to disable interrupts before calling malloc, and recommended  : 
11ce			;     to avoid the use of malloc inside ISRs in general.                      : 
11ce			;                                                                             : 
11ce			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11ce			;                                                                             : 
11ce			; Parameters                                                                  : 
11ce			;     HL  Number of bytes wanted                                              : 
11ce			;                                                                             : 
11ce			; Returns                                                                     : 
11ce			;     HL  Address of the first useable byte of the allocation                 : 
11ce			;                                                                             : 
11ce			; Flags                                                                       : 
11ce			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11ce			;                                                                             : 
11ce			; Stack frame                                                                 : 
11ce			;       |             |                                                       : 
11ce			;       +-------------+                                                       : 
11ce			;       |     BC      |                                                       : 
11ce			;       +-------------+                                                       : 
11ce			;       |     DE      |                                                       : 
11ce			;       +-------------+                                                       : 
11ce			;       |     IX      |                                                       : 
11ce			;       +-------------+                                                       : 
11ce			;       |  prev_free  |                                                       : 
11ce			;   +4  +-------------+                                                       : 
11ce			;       |  this_free  |                                                       : 
11ce			;   +2  +-------------+                                                       : 
11ce			;       |  next_free  |                                                       : 
11ce			;   +0  +-------------+                                                       : 
11ce			;       |             |                                                       : 
11ce			;                                                                             : 
11ce			;------------------------------------------------------------------------------ 
11ce			 
11ce			 
11ce			;malloc: 
11ce			; 
11ce			;	SAVESP ON 1 
11ce			; 
11ce			;	call malloc_code 
11ce			; 
11ce			;	CHECKSP ON 1 
11ce			;	ret 
11ce			 
11ce			 
11ce			malloc: 
11ce c5			      push  BC 
11cf d5			      push  DE 
11d0 dd e5		      push  IX 
11d2			if DEBUG_FORTH_MALLOC_HIGH 
11d2			call malloc_guard_entry 
11d2			endif 
11d2			 
11d2					if DEBUG_FORTH_MALLOC 
11d2						DMARK "mal" 
11d2						CALLMONITOR 
11d2					endif 
11d2 7c			      ld    A, H                    ; Exit if no space requested 
11d3 b5			      or    L 
11d4 ca 93 12		      jp    Z, malloc_early_exit 
11d7			 
11d7			;inc hl 
11d7			;inc hl 
11d7			;inc hl 
11d7			; 
11d7			;inc hl 
11d7			;inc hl 
11d7			;inc hl 
11d7			;inc hl 
11d7			;inc hl 
11d7			;inc hl 
11d7			;inc hl 
11d7			;inc hl 
11d7			;inc hl 
11d7			 
11d7			 
11d7			 
11d7			 
11d7					if DEBUG_FORTH_MALLOC 
11d7						DMARK "maA" 
11d7						CALLMONITOR 
11d7					endif 
11d7			      ; Set up stack frame 
11d7 eb			      ex    DE, HL 
11d8 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11db 39			      add   HL, SP 
11dc f9			      ld    SP, HL 
11dd dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11e1 dd 39		      add   IX, SP 
11e3			 
11e3			      ; Setup initial state 
11e3 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11e6 19			      add   HL, DE 
11e7			 
11e7 44			      ld    B, H                    ; Move want to BC 
11e8 4d			      ld    C, L 
11e9			 
11e9 21 66 65		      ld    HL, free_list           ; Store prev_free ptr to stack 
11ec dd 75 04		      ld    (IX+4), L 
11ef dd 74 05		      ld    (IX+5), H 
11f2			 
11f2 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11f3 23			      inc   HL 
11f4 56			      ld    D, (HL) 
11f5 dd 73 02		      ld    (IX+2), E 
11f8 dd 72 03		      ld    (IX+3), D 
11fb eb			      ex    DE, HL                  ; this_free ptr into HL 
11fc			 
11fc					if DEBUG_FORTH_MALLOC 
11fc						DMARK "maB" 
11fc						CALLMONITOR 
11fc					endif 
11fc			      ; Loop through free block list to find some space 
11fc			malloc_find_space: 
11fc 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11fd 23			      inc   HL 
11fe 56			      ld    D, (HL) 
11ff			 
11ff 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1200 b3			      or    E 
1201 ca 8d 12		      jp    Z, malloc_no_space 
1204			 
1204 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1207 dd 72 01		      ld    (IX+1), D 
120a			 
120a			      ; Does this block have enough space to make the allocation? 
120a 23			      inc   HL                      ; Load free block size into DE 
120b 5e			      ld    E, (HL) 
120c 23			      inc   HL 
120d 56			      ld    D, (HL) 
120e			 
120e eb			      ex    DE, HL                  ; Check size of block against want 
120f b7			      or    A                       ; Ensure carry flag clear 
1210 ed 42		      sbc   HL, BC 
1212 e5			      push  HL                      ; Store the result for later (new block size) 
1213			 
1213 ca 62 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1216 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1218			 
1218			      ; this_free block is not big enough, setup ptrs to test next free block 
1218 e1			      pop   HL                      ; Discard previous result 
1219			 
1219 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
121c dd 66 03		      ld    H, (IX+3) 
121f dd 75 04		      ld    (IX+4), L 
1222 dd 74 05		      ld    (IX+5), H 
1225			 
1225 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1228 dd 66 01		      ld    H, (IX+1) 
122b dd 75 02		      ld    (IX+2), L 
122e dd 74 03		      ld    (IX+3), H 
1231			 
1231					if DEBUG_FORTH_MALLOC 
1231						DMARK "MA>" 
1231						CALLMONITOR 
1231					endif 
1231 18 c9		      jr    malloc_find_space 
1233			 
1233			      ; split a bigger block into two - requested size and remaining size 
1233			malloc_alloc_split: 
1233					if DEBUG_FORTH_MALLOC 
1233						DMARK "MAs" 
1233						CALLMONITOR 
1233					endif 
1233 eb			      ex    DE, HL                  ; Calculate address of new free block 
1234 2b			      dec   HL 
1235 2b			      dec   HL 
1236 2b			      dec   HL 
1237 09			      add   HL, BC 
1238			 
1238			      ; Create a new block and point it at next_free 
1238 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
123b dd 56 01		      ld    D, (IX+1) 
123e			 
123e 73			      ld    (HL), E                 ; Store next_free ptr into new block 
123f 23			      inc   HL 
1240 72			      ld    (HL), D 
1241			 
1241 d1			      pop   DE                      ; Store size of new block into new block 
1242 23			      inc   HL 
1243 73			      ld    (HL), E 
1244 23			      inc   HL 
1245 72			      ld    (HL), D 
1246			 
1246			      ; Update this_free ptr to point to new block 
1246 2b			      dec   HL 
1247 2b			      dec   HL 
1248 2b			      dec   HL 
1249			 
1249 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
124c dd 56 03		      ld    D, (IX+3) 
124f			 
124f dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1252 dd 74 03		      ld    (IX+3), H 
1255			 
1255			      ; Modify this_free block to be allocation 
1255 eb			      ex    DE, HL 
1256 af			      xor   A                       ; Null the next block ptr of allocated block 
1257 77			      ld    (HL), A 
1258 23			      inc   HL 
1259 77			      ld    (HL), A 
125a			 
125a 23			      inc   HL                      ; Store want size into allocated block 
125b 71			      ld    (HL), C 
125c 23			      inc   HL 
125d 70			      ld    (HL), B 
125e 23			      inc   HL 
125f e5			      push  HL                      ; Address of allocation to return 
1260			 
1260 18 19		      jr    malloc_update_links 
1262			 
1262			malloc_alloc_fit: 
1262 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1263			 
1263					if DEBUG_FORTH_MALLOC 
1263						DMARK "MAf" 
1263						CALLMONITOR 
1263					endif 
1263			      ; Modify this_free block to be allocation 
1263 eb			      ex    DE, HL 
1264 2b			      dec   HL 
1265 2b			      dec   HL 
1266 2b			      dec   HL 
1267			 
1267 af			      xor   A                       ; Null the next block ptr of allocated block 
1268 77			      ld    (HL), A 
1269 23			      inc   HL 
126a 77			      ld    (HL), A 
126b			 
126b 23			      inc   HL                      ; Store address of allocation to return 
126c 23			      inc   HL 
126d 23			      inc   HL 
126e e5			      push  HL 
126f			 
126f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
126f dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1272 dd 66 01		      ld    H, (IX+1) 
1275			 
1275 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1278 dd 74 03		      ld    (IX+3), H 
127b			 
127b			 
127b			malloc_update_links: 
127b			      ; Update prev_free ptr to point to this_free 
127b dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
127e dd 66 05		      ld    H, (IX+5) 
1281			 
1281 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1284 dd 56 03		      ld    D, (IX+3) 
1287			 
1287 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1288 23			      inc   HL 
1289 72			      ld    (HL), D 
128a			 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "Mul" 
128a						CALLMONITOR 
128a					endif 
128a			      ; Clear the Z flag to indicate successful allocation 
128a 7a			      ld    A, D 
128b b3			      or    E 
128c			 
128c d1			      pop   DE                      ; Address of allocation 
128d					if DEBUG_FORTH_MALLOC 
128d						DMARK "MAu" 
128d						CALLMONITOR 
128d					endif 
128d			 
128d			malloc_no_space: 
128d 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1290 39			      add   HL, SP 
1291 f9			      ld    SP, HL 
1292			 
1292 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1293					if DEBUG_FORTH_MALLOC 
1293						DMARK "MAN" 
1293						CALLMONITOR 
1293					endif 
1293			 
1293			malloc_early_exit: 
1293					if DEBUG_FORTH_MALLOC 
1293						DMARK "MAx" 
1293						CALLMONITOR 
1293					endif 
1293 dd e1		      pop   IX 
1295 d1			      pop   DE 
1296 c1			      pop   BC 
1297			 
1297			if DEBUG_FORTH_MALLOC_HIGH 
1297			call malloc_guard_exit 
1297			call malloc_guard_zerolen 
1297			endif 
1297 c9			      ret 
1298			 
1298			 
1298			;------------------------------------------------------------------------------ 
1298			;     free                                                                    : 
1298			;                                                                             : 
1298			; Description                                                                 : 
1298			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1298			;     returned by malloc, otherwise the behaviour is undefined.               : 
1298			;                                                                             : 
1298			;     Where possible, directly adjacent free blocks will be merged together   : 
1298			;     into larger blocks to help ensure that the heap does not become         : 
1298			;     excessively fragmented.                                                 : 
1298			;                                                                             : 
1298			;     free does not clear or set any other value into the freed space, and    : 
1298			;     therefore its contents may be visible through subsequent malloc's. The  : 
1298			;     caller should clear the freed space as required.                        : 
1298			;                                                                             : 
1298			;     This implementation of free uses the stack exclusively, and is          : 
1298			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1298			;     advisable to disable interrupts before calling free, and recommended    : 
1298			;     to avoid the use of free inside ISRs in general.                        : 
1298			;                                                                             : 
1298			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1298			;                                                                             : 
1298			; Parameters                                                                  : 
1298			;     HL  Pointer to address of first byte of allocation to be freed          : 
1298			;                                                                             : 
1298			; Returns                                                                     : 
1298			;     Nothing                                                                 : 
1298			;                                                                             : 
1298			; Stack frame                                                                 : 
1298			;       |             |                                                       : 
1298			;       +-------------+                                                       : 
1298			;       |     BC      |                                                       : 
1298			;       +-------------+                                                       : 
1298			;       |     DE      |                                                       : 
1298			;       +-------------+                                                       : 
1298			;       |     IX      |                                                       : 
1298			;       +-------------+                                                       : 
1298			;       |  prev_free  |                                                       : 
1298			;   +2  +-------------+                                                       : 
1298			;       |  next_free  |                                                       : 
1298			;   +0  +-------------+                                                       : 
1298			;       |             |                                                       : 
1298			;                                                                             : 
1298			;------------------------------------------------------------------------------ 
1298			free: 
1298 c5			      push  BC 
1299 d5			      push  DE 
129a dd e5		      push  IX 
129c			 
129c 7c			      ld    A, H                    ; Exit if ptr is null 
129d b5			      or    L 
129e ca 62 13		      jp    Z, free_early_exit 
12a1			 
12a1			      ; Set up stack frame 
12a1 eb			      ex    DE, HL 
12a2 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12a5 39			      add   HL, SP 
12a6 f9			      ld    SP, HL 
12a7 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12ab dd 39		      add   IX, SP 
12ad			 
12ad			      ; The address in HL points to the start of the useable allocated space, 
12ad			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12ad			      ; address of the block itself. 
12ad eb			      ex    DE, HL 
12ae 11 fc ff		      ld    DE, -4 
12b1 19			      add   HL, DE 
12b2			 
12b2			      ; An allocated block must have a null next block pointer in it 
12b2 7e			      ld    A, (HL) 
12b3 23			      inc   HL 
12b4 b6			      or    (HL) 
12b5 c2 5d 13		      jp    NZ, free_done 
12b8			 
12b8 2b			      dec   HL 
12b9			 
12b9 44			      ld    B, H                    ; Copy HL to BC 
12ba 4d			      ld    C, L 
12bb			 
12bb			      ; Loop through the free list to find the first block with an address 
12bb			      ; higher than the block being freed 
12bb 21 66 65		      ld    HL, free_list 
12be			 
12be			free_find_higher_block: 
12be 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12bf 23			      inc   HL 
12c0 56			      ld    D, (HL) 
12c1 2b			      dec   HL 
12c2			 
12c2 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12c5 dd 72 01		      ld    (IX+1), D 
12c8 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12cb dd 74 03		      ld    (IX+3), H 
12ce			 
12ce 78			      ld    A, B                    ; Check if DE is greater than BC 
12cf ba			      cp    D                       ; Compare MSB first 
12d0 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12d2 30 04		      jr    NC, free_find_higher_block_skip 
12d4 79			      ld    A, C 
12d5 bb			      cp    E                       ; Then compare LSB 
12d6 38 08		      jr    C, free_found_higher_block 
12d8			 
12d8			free_find_higher_block_skip: 
12d8 7a			      ld    A, D                    ; Reached the end of the free list? 
12d9 b3			      or    E 
12da ca 5d 13		      jp    Z, free_done 
12dd			 
12dd eb			      ex    DE, HL 
12de			 
12de 18 de		      jr    free_find_higher_block 
12e0			 
12e0			free_found_higher_block: 
12e0			      ; Insert freed block between prev and next free blocks 
12e0 71			      ld    (HL), C                 ; Point prev free block to freed block 
12e1 23			      inc   HL 
12e2 70			      ld    (HL), B 
12e3			 
12e3 60			      ld    H, B                    ; Point freed block at next free block 
12e4 69			      ld    L, C 
12e5 73			      ld    (HL), E 
12e6 23			      inc   HL 
12e7 72			      ld    (HL), D 
12e8			 
12e8			      ; Check if the freed block is adjacent to the next free block 
12e8 23			      inc   HL                      ; Load size of freed block into HL 
12e9 5e			      ld    E, (HL) 
12ea 23			      inc   HL 
12eb 56			      ld    D, (HL) 
12ec eb			      ex    DE, HL 
12ed			 
12ed 09			      add   HL, BC                  ; Add addr of freed block and its size 
12ee			 
12ee dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12f1 dd 56 01		      ld    D, (IX+1) 
12f4			 
12f4 b7			      or    A                       ; Clear the carry flag 
12f5 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12f7 20 22		      jr    NZ, free_check_adjacent_to_prev 
12f9			 
12f9			      ; Freed block is adjacent to next, merge into one bigger block 
12f9 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12fa 5e			      ld    E, (HL) 
12fb 23			      inc   HL 
12fc 56			      ld    D, (HL) 
12fd e5			      push  HL                      ; Save ptr to next block for later 
12fe			 
12fe 60			      ld    H, B                    ; Store ptr from next block into freed block 
12ff 69			      ld    L, C 
1300 73			      ld    (HL), E 
1301 23			      inc   HL 
1302 72			      ld    (HL), D 
1303			 
1303 e1			      pop   HL                      ; Restore ptr to next block 
1304 23			      inc   HL                      ; Load size of next block into DE 
1305 5e			      ld    E, (HL) 
1306 23			      inc   HL 
1307 56			      ld    D, (HL) 
1308 d5			      push  DE                      ; Save next block size for later 
1309			 
1309 60			      ld    H, B                    ; Load size of freed block into HL 
130a 69			      ld    L, C 
130b 23			      inc   HL 
130c 23			      inc   HL 
130d 5e			      ld    E, (HL) 
130e 23			      inc   HL 
130f 56			      ld    D, (HL) 
1310 eb			      ex    DE, HL 
1311			 
1311 d1			      pop   DE                      ; Restore size of next block 
1312 19			      add   HL, DE                  ; Add sizes of both blocks 
1313 eb			      ex    DE, HL 
1314			 
1314 60			      ld    H, B                    ; Store new bigger size into freed block 
1315 69			      ld    L, C 
1316 23			      inc   HL 
1317 23			      inc   HL 
1318 73			      ld    (HL), E 
1319 23			      inc   HL 
131a 72			      ld    (HL), D 
131b			 
131b			free_check_adjacent_to_prev: 
131b			      ; Check if the freed block is adjacent to the prev free block 
131b dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
131e dd 66 03		      ld    H, (IX+3) 
1321			 
1321 23			      inc   HL                      ; Size of prev free block into DE 
1322 23			      inc   HL 
1323 5e			      ld    E, (HL) 
1324 23			      inc   HL 
1325 56			      ld    D, (HL) 
1326 2b			      dec   HL 
1327 2b			      dec   HL 
1328 2b			      dec   HL 
1329			 
1329 19			      add   HL, DE                  ; Add prev block addr and size 
132a			 
132a b7			      or    A                       ; Clear the carry flag 
132b ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
132d 20 2e		      jr    NZ, free_done 
132f			 
132f			      ; Freed block is adjacent to prev, merge into one bigger block 
132f 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1330 69			      ld    L, C 
1331 5e			      ld    E, (HL) 
1332 23			      inc   HL 
1333 56			      ld    D, (HL) 
1334 e5			      push  HL                      ; Save freed block ptr for later 
1335			 
1335 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1338 dd 66 03		      ld    H, (IX+3) 
133b 73			      ld    (HL), E 
133c 23			      inc   HL 
133d 72			      ld    (HL), D 
133e			 
133e e1			      pop   HL                      ; Restore freed block ptr 
133f 23			      inc   HL                      ; Load size of freed block into DE 
1340 5e			      ld    E, (HL) 
1341 23			      inc   HL 
1342 56			      ld    D, (HL) 
1343 d5			      push  DE                      ; Save freed block size for later 
1344			 
1344 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1347 dd 66 03		      ld    H, (IX+3) 
134a 23			      inc   HL 
134b 23			      inc   HL 
134c 5e			      ld    E, (HL) 
134d 23			      inc   HL 
134e 56			      ld    D, (HL) 
134f			 
134f e1			      pop   HL                      ; Add sizes of both blocks 
1350 19			      add   HL, DE 
1351 eb			      ex    DE, HL 
1352			 
1352 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1355 dd 66 03		      ld    H, (IX+3) 
1358 23			      inc   HL 
1359 23			      inc   HL 
135a 73			      ld    (HL), E 
135b 23			      inc   HL 
135c 72			      ld    (HL), D 
135d			 
135d			free_done: 
135d 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1360 39			      add   HL, SP 
1361 f9			      ld    SP, HL 
1362			 
1362			free_early_exit: 
1362 dd e1		      pop   IX 
1364 d1			      pop   DE 
1365 c1			      pop   BC 
1366			 
1366 c9			      ret 
1367			 
1367			; moved to firmware.asm 
1367			; 
1367			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1367			;                  .dw   0 
1367			 
1367			 
1367			endif 
1367			 
1367			 
1367			if MALLOC_3 
1367			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1367			;heap_start        .equ  0x9000      ; Starting address of heap 
1367			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1367			; 
1367			 ;     .org 0 
1367			  ;    jp    main 
1367			; 
1367			; 
1367			 ;     .org  0x100 
1367			;main: 
1367			 ;     ld    HL, 0x8100 
1367			  ;    ld    SP, HL 
1367			; 
1367			;      call  heap_init 
1367			 
1367			      ; Make some allocations 
1367			;      ld    HL, 12 
1367			;      call  malloc            ; Allocates 0x9004 
1367			; 
1367			 ;     ld    HL, 12 
1367			;      call  malloc            ; Allocates 0x9014 
1367			 
1367			;      ld    HL, 12 
1367			;      call  malloc            ; Allocates 0x9024 
1367			 
1367			      ; Free some allocations 
1367			;      ld    HL, 0x9014 
1367			;      call  free 
1367			 
1367			;      ld    HL, 0x9004 
1367			;      call  free 
1367			; 
1367			;      ld    HL, 0x9024 
1367			;      call  free 
1367			 
1367			 
1367			 ;     halt 
1367			 
1367			 
1367			;------------------------------------------------------------------------------ 
1367			;     heap_init                                                               : 
1367			;                                                                             : 
1367			; Description                                                                 : 
1367			;     Initialise the heap and make it ready for malloc and free operations.   : 
1367			;                                                                             : 
1367			;     The heap is maintained as a linked list, starting with an initial       : 
1367			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1367			;     the first free block in the heap. Each block then points to the next    : 
1367			;     free block within the heap, and the free list ends at the first block   : 
1367			;     with a null pointer to the next free block.                             : 
1367			;                                                                             : 
1367			; Parameters                                                                  : 
1367			;     Inputs are compile-time only. Two defines which specify the starting    : 
1367			;     address of the heap and its size are required, along with a memory      : 
1367			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1367			;     principally stores a pointer to the first free block in the heap.       : 
1367			;                                                                             : 
1367			; Returns                                                                     : 
1367			;     Nothing                                                                 : 
1367			;------------------------------------------------------------------------------ 
1367			heap_init: 
1367			      push  HL 
1367			 
1367			      ; Initialise free list struct 
1367			      ld    HL, heap_start 
1367			      ld    (free_list), HL 
1367			      ld    HL, 0 
1367			      ld    (free_list+2), HL 
1367			 
1367			      ; Insert first free block at bottom of heap, consumes entire heap 
1367			      ld    HL, heap_start+heap_size-4 
1367			      ld    (heap_start), HL        ; Next block (end of free list) 
1367			      ld    HL, heap_size-4 
1367			      ld    (heap_start+2), HL      ; Block size 
1367			 
1367			      ; Insert end of free list block at top of heap - two null words will 
1367			      ; terminate the free list 
1367			      ld    HL, 0 
1367			      ld    (heap_start+heap_size-2), HL 
1367			      ld    (heap_start+heap_size-4), HL 
1367			 
1367			      pop   HL 
1367			 
1367			      ret 
1367			 
1367			 
1367			;------------------------------------------------------------------------------ 
1367			;     malloc                                                                  : 
1367			;                                                                             : 
1367			; Description                                                                 : 
1367			;     Allocates the wanted space from the heap and returns the address of the : 
1367			;     first useable byte of the allocation.                                   : 
1367			;                                                                             : 
1367			;     Allocations can happen in one of two ways:                              : 
1367			;                                                                             : 
1367			;     1. A free block may be found which is the exact size wanted. In this    : 
1367			;        case the block is removed from the free list and retuedn to the      : 
1367			;        caller.                                                              : 
1367			;     2. A free block may be found which is larger than the size wanted. In   : 
1367			;        this case, the larger block is split into two. The first portion of  : 
1367			;        this block will become the requested space by the malloc call and    : 
1367			;        is returned to the caller. The second portion becomes a new free     : 
1367			;        block, and the free list is adjusted to maintain continuity via this : 
1367			;        newly created block.                                                 : 
1367			;                                                                             : 
1367			;     malloc does not set any initial value in the allocated space, the       : 
1367			;     caller is required to do this as required.                              : 
1367			;                                                                             : 
1367			;     This implementation of malloc uses the stack exclusively, and is        : 
1367			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1367			;     advisable to disable interrupts before calling malloc, and recommended  : 
1367			;     to avoid the use of malloc inside ISRs in general.                      : 
1367			;                                                                             : 
1367			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1367			;                                                                             : 
1367			; Parameters                                                                  : 
1367			;     HL  Number of bytes wanted                                              : 
1367			;                                                                             : 
1367			; Returns                                                                     : 
1367			;     HL  Address of the first useable byte of the allocation                 : 
1367			;                                                                             : 
1367			; Flags                                                                       : 
1367			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1367			;                                                                             : 
1367			; Stack frame                                                                 : 
1367			;       |             |                                                       : 
1367			;       +-------------+                                                       : 
1367			;       |     BC      |                                                       : 
1367			;       +-------------+                                                       : 
1367			;       |     DE      |                                                       : 
1367			;       +-------------+                                                       : 
1367			;       |     IX      |                                                       : 
1367			;       +-------------+                                                       : 
1367			;       |  prev_free  |                                                       : 
1367			;   +4  +-------------+                                                       : 
1367			;       |  this_free  |                                                       : 
1367			;   +2  +-------------+                                                       : 
1367			;       |  next_free  |                                                       : 
1367			;   +0  +-------------+                                                       : 
1367			;       |             |                                                       : 
1367			;                                                                             : 
1367			;------------------------------------------------------------------------------ 
1367			malloc: 
1367			      push  BC 
1367			      push  DE 
1367			      push  IX 
1367			 
1367			      ld    A, H                    ; Exit if no space requested 
1367			      or    L 
1367			      jp    Z, malloc_early_exit 
1367			 
1367			      ; Set up stack frame 
1367			      ex    DE, HL 
1367			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1367			      add   HL, SP 
1367			      ld    SP, HL 
1367			      ld    IX, 0                   ; Use IX as a frame pointer 
1367			      add   IX, SP 
1367			 
1367			      ; Setup initial state 
1367			      ld    HL, 4                   ; want must also include space used by block struct 
1367			      add   HL, DE 
1367			 
1367			      ld    B, H                    ; Move want to BC 
1367			      ld    C, L 
1367			 
1367			      ld    HL, free_list           ; Store prev_free ptr to stack 
1367			      ld    (IX+4), L 
1367			      ld    (IX+5), H 
1367			 
1367			      ld    E, (HL)                 ; Store this_free ptr to stack 
1367			      inc   HL 
1367			      ld    D, (HL) 
1367			      ld    (IX+2), E 
1367			      ld    (IX+3), D 
1367			      ex    DE, HL                  ; this_free ptr into HL 
1367			 
1367			      ; Loop through free block list to find some space 
1367			malloc_find_space: 
1367			      ld    E, (HL)                 ; Load next_free ptr into DE 
1367			      inc   HL 
1367			      ld    D, (HL) 
1367			 
1367			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1367			      or    E 
1367			      jp    Z, malloc_no_space 
1367			 
1367			      ld    (IX+0), E               ; Store next_free ptr to stack 
1367			      ld    (IX+1), D 
1367			 
1367			      ; Does this block have enough space to make the allocation? 
1367			      inc   HL                      ; Load free block size into DE 
1367			      ld    E, (HL) 
1367			      inc   HL 
1367			      ld    D, (HL) 
1367			 
1367			      ex    DE, HL                  ; Check size of block against want 
1367			      or    A                       ; Ensure carry flag clear 
1367			      sbc   HL, BC 
1367			      push  HL                      ; Store the result for later (new block size) 
1367			 
1367			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1367			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1367			 
1367			      ; this_free block is not big enough, setup ptrs to test next free block 
1367			      pop   HL                      ; Discard previous result 
1367			 
1367			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1367			      ld    H, (IX+3) 
1367			      ld    (IX+4), L 
1367			      ld    (IX+5), H 
1367			 
1367			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1367			      ld    H, (IX+1) 
1367			      ld    (IX+2), L 
1367			      ld    (IX+3), H 
1367			 
1367			      jr    malloc_find_space 
1367			 
1367			      ; split a bigger block into two - requested size and remaining size 
1367			malloc_alloc_split: 
1367			      ex    DE, HL                  ; Calculate address of new free block 
1367			      dec   HL 
1367			      dec   HL 
1367			      dec   HL 
1367			      add   HL, BC 
1367			 
1367			      ; Create a new block and point it at next_free 
1367			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1367			      ld    D, (IX+1) 
1367			 
1367			      ld    (HL), E                 ; Store next_free ptr into new block 
1367			      inc   HL 
1367			      ld    (HL), D 
1367			 
1367			      pop   DE                      ; Store size of new block into new block 
1367			      inc   HL 
1367			      ld    (HL), E 
1367			      inc   HL 
1367			      ld    (HL), D 
1367			 
1367			      ; Update this_free ptr to point to new block 
1367			      dec   HL 
1367			      dec   HL 
1367			      dec   HL 
1367			 
1367			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1367			      ld    D, (IX+3) 
1367			 
1367			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1367			      ld    (IX+3), H 
1367			 
1367			      ; Modify this_free block to be allocation 
1367			      ex    DE, HL 
1367			      xor   A                       ; Null the next block ptr of allocated block 
1367			      ld    (HL), A 
1367			      inc   HL 
1367			      ld    (HL), A 
1367			 
1367			      inc   HL                      ; Store want size into allocated block 
1367			      ld    (HL), C 
1367			      inc   HL 
1367			      ld    (HL), B 
1367			      inc   HL 
1367			      push  HL                      ; Address of allocation to return 
1367			 
1367			      jr    malloc_update_links 
1367			 
1367			malloc_alloc_fit: 
1367			      pop   HL                      ; Dont need new block size, want is exact fit 
1367			 
1367			      ; Modify this_free block to be allocation 
1367			      ex    DE, HL 
1367			      dec   HL 
1367			      dec   HL 
1367			      dec   HL 
1367			 
1367			      xor   A                       ; Null the next block ptr of allocated block 
1367			      ld    (HL), A 
1367			      inc   HL 
1367			      ld    (HL), A 
1367			 
1367			      inc   HL                      ; Store address of allocation to return 
1367			      inc   HL 
1367			      inc   HL 
1367			      push  HL 
1367			 
1367			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1367			      ld    L, (IX+0)               ; next_free to HL 
1367			      ld    H, (IX+1) 
1367			 
1367			      ld    (IX+2), L               ; HL to this_free 
1367			      ld    (IX+3), H 
1367			 
1367			 
1367			malloc_update_links: 
1367			      ; Update prev_free ptr to point to this_free 
1367			      ld    L, (IX+4)               ; prev_free ptr to HL 
1367			      ld    H, (IX+5) 
1367			 
1367			      ld    E, (IX+2)               ; this_free ptr to DE 
1367			      ld    D, (IX+3) 
1367			 
1367			      ld    (HL), E                 ; this_free ptr into prev_free 
1367			      inc   HL 
1367			      ld    (HL), D 
1367			 
1367			      ; Clear the Z flag to indicate successful allocation 
1367			      ld    A, D 
1367			      or    E 
1367			 
1367			      pop   DE                      ; Address of allocation 
1367			 
1367			malloc_no_space: 
1367			      ld    HL, 6                   ; Clean up stack frame 
1367			      add   HL, SP 
1367			      ld    SP, HL 
1367			 
1367			      ex    DE, HL                  ; Alloc addr into HL for return 
1367			 
1367			malloc_early_exit: 
1367			      pop   IX 
1367			      pop   DE 
1367			      pop   BC 
1367			 
1367			      ret 
1367			 
1367			 
1367			;------------------------------------------------------------------------------ 
1367			;     free                                                                    : 
1367			;                                                                             : 
1367			; Description                                                                 : 
1367			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1367			;     returned by malloc, otherwise the behaviour is undefined.               : 
1367			;                                                                             : 
1367			;     Where possible, directly adjacent free blocks will be merged together   : 
1367			;     into larger blocks to help ensure that the heap does not become         : 
1367			;     excessively fragmented.                                                 : 
1367			;                                                                             : 
1367			;     free does not clear or set any other value into the freed space, and    : 
1367			;     therefore its contents may be visible through subsequent malloc's. The  : 
1367			;     caller should clear the freed space as required.                        : 
1367			;                                                                             : 
1367			;     This implementation of free uses the stack exclusively, and is          : 
1367			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1367			;     advisable to disable interrupts before calling free, and recommended    : 
1367			;     to avoid the use of free inside ISRs in general.                        : 
1367			;                                                                             : 
1367			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1367			;                                                                             : 
1367			; Parameters                                                                  : 
1367			;     HL  Pointer to address of first byte of allocation to be freed          : 
1367			;                                                                             : 
1367			; Returns                                                                     : 
1367			;     Nothing                                                                 : 
1367			;                                                                             : 
1367			; Stack frame                                                                 : 
1367			;       |             |                                                       : 
1367			;       +-------------+                                                       : 
1367			;       |     BC      |                                                       : 
1367			;       +-------------+                                                       : 
1367			;       |     DE      |                                                       : 
1367			;       +-------------+                                                       : 
1367			;       |     IX      |                                                       : 
1367			;       +-------------+                                                       : 
1367			;       |  prev_free  |                                                       : 
1367			;   +2  +-------------+                                                       : 
1367			;       |  next_free  |                                                       : 
1367			;   +0  +-------------+                                                       : 
1367			;       |             |                                                       : 
1367			;                                                                             : 
1367			;------------------------------------------------------------------------------ 
1367			free: 
1367			      push  BC 
1367			      push  DE 
1367			      push  IX 
1367			 
1367			      ld    A, H                    ; Exit if ptr is null 
1367			      or    L 
1367			      jp    Z, free_early_exit 
1367			 
1367			      ; Set up stack frame 
1367			      ex    DE, HL 
1367			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1367			      add   HL, SP 
1367			      ld    SP, HL 
1367			      ld    IX, 0                   ; Use IX as a frame pointer 
1367			      add   IX, SP 
1367			 
1367			      ; The address in HL points to the start of the useable allocated space, 
1367			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1367			      ; address of the block itself. 
1367			      ex    DE, HL 
1367			      ld    DE, -4 
1367			      add   HL, DE 
1367			 
1367			      ; An allocated block must have a null next block pointer in it 
1367			      ld    A, (HL) 
1367			      inc   HL 
1367			      or    (HL) 
1367			      jp    NZ, free_done 
1367			 
1367			      dec   HL 
1367			 
1367			      ld    B, H                    ; Copy HL to BC 
1367			      ld    C, L 
1367			 
1367			      ; Loop through the free list to find the first block with an address 
1367			      ; higher than the block being freed 
1367			      ld    HL, free_list 
1367			 
1367			free_find_higher_block: 
1367			      ld    E, (HL)                 ; Load next ptr from free block 
1367			      inc   HL 
1367			      ld    D, (HL) 
1367			      dec   HL 
1367			 
1367			      ld    (IX+0), E               ; Save ptr to next free block 
1367			      ld    (IX+1), D 
1367			      ld    (IX+2), L               ; Save ptr to prev free block 
1367			      ld    (IX+3), H 
1367			 
1367			      ld    A, B                    ; Check if DE is greater than BC 
1367			      cp    D                       ; Compare MSB first 
1367			      jr    Z, $+4                  ; MSB the same, compare LSB 
1367			      jr    NC, free_find_higher_block_skip 
1367			      ld    A, C 
1367			      cp    E                       ; Then compare LSB 
1367			      jr    C, free_found_higher_block 
1367			 
1367			free_find_higher_block_skip: 
1367			      ld    A, D                    ; Reached the end of the free list? 
1367			      or    E 
1367			      jp    Z, free_done 
1367			 
1367			      ex    DE, HL 
1367			 
1367			      jr    free_find_higher_block 
1367			 
1367			free_found_higher_block: 
1367			      ; Insert freed block between prev and next free blocks 
1367			      ld    (HL), C                 ; Point prev free block to freed block 
1367			      inc   HL 
1367			      ld    (HL), B 
1367			 
1367			      ld    H, B                    ; Point freed block at next free block 
1367			      ld    L, C 
1367			      ld    (HL), E 
1367			      inc   HL 
1367			      ld    (HL), D 
1367			 
1367			      ; Check if the freed block is adjacent to the next free block 
1367			      inc   HL                      ; Load size of freed block into HL 
1367			      ld    E, (HL) 
1367			      inc   HL 
1367			      ld    D, (HL) 
1367			      ex    DE, HL 
1367			 
1367			      add   HL, BC                  ; Add addr of freed block and its size 
1367			 
1367			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1367			      ld    D, (IX+1) 
1367			 
1367			      or    A                       ; Clear the carry flag 
1367			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1367			      jr    NZ, free_check_adjacent_to_prev 
1367			 
1367			      ; Freed block is adjacent to next, merge into one bigger block 
1367			      ex    DE, HL                  ; Load next ptr from next block into DE 
1367			      ld    E, (HL) 
1367			      inc   HL 
1367			      ld    D, (HL) 
1367			      push  HL                      ; Save ptr to next block for later 
1367			 
1367			      ld    H, B                    ; Store ptr from next block into freed block 
1367			      ld    L, C 
1367			      ld    (HL), E 
1367			      inc   HL 
1367			      ld    (HL), D 
1367			 
1367			      pop   HL                      ; Restore ptr to next block 
1367			      inc   HL                      ; Load size of next block into DE 
1367			      ld    E, (HL) 
1367			      inc   HL 
1367			      ld    D, (HL) 
1367			      push  DE                      ; Save next block size for later 
1367			 
1367			      ld    H, B                    ; Load size of freed block into HL 
1367			      ld    L, C 
1367			      inc   HL 
1367			      inc   HL 
1367			      ld    E, (HL) 
1367			      inc   HL 
1367			      ld    D, (HL) 
1367			      ex    DE, HL 
1367			 
1367			      pop   DE                      ; Restore size of next block 
1367			      add   HL, DE                  ; Add sizes of both blocks 
1367			      ex    DE, HL 
1367			 
1367			      ld    H, B                    ; Store new bigger size into freed block 
1367			      ld    L, C 
1367			      inc   HL 
1367			      inc   HL 
1367			      ld    (HL), E 
1367			      inc   HL 
1367			      ld    (HL), D 
1367			 
1367			free_check_adjacent_to_prev: 
1367			      ; Check if the freed block is adjacent to the prev free block 
1367			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1367			      ld    H, (IX+3) 
1367			 
1367			      inc   HL                      ; Size of prev free block into DE 
1367			      inc   HL 
1367			      ld    E, (HL) 
1367			      inc   HL 
1367			      ld    D, (HL) 
1367			      dec   HL 
1367			      dec   HL 
1367			      dec   HL 
1367			 
1367			      add   HL, DE                  ; Add prev block addr and size 
1367			 
1367			      or    A                       ; Clear the carry flag 
1367			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1367			      jr    NZ, free_done 
1367			 
1367			      ; Freed block is adjacent to prev, merge into one bigger block 
1367			      ld    H, B                    ; Load next ptr from freed block into DE 
1367			      ld    L, C 
1367			      ld    E, (HL) 
1367			      inc   HL 
1367			      ld    D, (HL) 
1367			      push  HL                      ; Save freed block ptr for later 
1367			 
1367			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1367			      ld    H, (IX+3) 
1367			      ld    (HL), E 
1367			      inc   HL 
1367			      ld    (HL), D 
1367			 
1367			      pop   HL                      ; Restore freed block ptr 
1367			      inc   HL                      ; Load size of freed block into DE 
1367			      ld    E, (HL) 
1367			      inc   HL 
1367			      ld    D, (HL) 
1367			      push  DE                      ; Save freed block size for later 
1367			 
1367			      ld    L, (IX+2)               ; Load size of prev block into DE 
1367			      ld    H, (IX+3) 
1367			      inc   HL 
1367			      inc   HL 
1367			      ld    E, (HL) 
1367			      inc   HL 
1367			      ld    D, (HL) 
1367			 
1367			      pop   HL                      ; Add sizes of both blocks 
1367			      add   HL, DE 
1367			      ex    DE, HL 
1367			 
1367			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1367			      ld    H, (IX+3) 
1367			      inc   HL 
1367			      inc   HL 
1367			      ld    (HL), E 
1367			      inc   HL 
1367			      ld    (HL), D 
1367			 
1367			free_done: 
1367			      ld    HL, 4                   ; Clean up stack frame 
1367			      add   HL, SP 
1367			      ld    SP, HL 
1367			 
1367			free_early_exit: 
1367			      pop   IX 
1367			      pop   DE 
1367			      pop   BC 
1367			 
1367			      ret 
1367			 
1367			 
1367			;      .org 0x8000 
1367			; 
1367			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1367			 ;                 .dw   0 
1367			 
1367			endif 
1367			 
1367			 
1367			if MALLOC_4 
1367			 
1367			; My memory allocation code. Very very simple.... 
1367			; allocate space under 250 chars 
1367			 
1367			heap_init: 
1367				; init start of heap as zero 
1367				;  
1367			 
1367				ld hl, heap_start 
1367				ld a, 0 
1367				ld (hl), a      ; empty block 
1367				inc hl 
1367				ld a, 0 
1367				ld (hl), a      ; length of block 
1367				; write end of list 
1367				inc hl 
1367				ld a,(hl) 
1367				inc hl 
1367				ld a,(hl) 
1367				 
1367			 
1367				; init some malloc vars 
1367			 
1367				ld hl, 0 
1367				ld (free_list), hl       ; store last malloc location 
1367			 
1367				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1367				ld a, 0 
1367				ld (hl), a 
1367			 
1367			 
1367				ld hl, heap_start 
1367				;  
1367				  
1367				ret 
1367			 
1367			 
1367			;    free block marker 
1367			;    requested size  
1367			;    pointer to next block 
1367			;    .... 
1367			;    next block marker 
1367			 
1367			 
1367			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1367			; 
1367			 
1367			 
1367			malloc:  
1367				push de 
1367				push bc 
1367				push af 
1367			 
1367				; hl space required 
1367				 
1367				ld c, l    ; hold space   (TODO only a max of 255) 
1367			 
1367			;	inc c     ; TODO BUG need to fix memory leak on push str 
1367			;	inc c 
1367			;	inc c 
1367			;	inc c 
1367			;	inc c 
1367			;	inc c 
1367			;	inc c 
1367			 
1367			 
1367			 
1367				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1367			 
1367				ld a, (free_list+3) 
1367				cp 0 
1367				jr z, .contheap 
1367			 
1367				ld hl, (free_list)     ; get last alloc 
1367					if DEBUG_FORTH_MALLOC_INT 
1367						DMARK "mrs" 
1367						CALLMONITOR 
1367					endif 
1367				jr .startalloc 
1367			 
1367			.contheap: 
1367				ld hl, heap_start 
1367			 
1367			.startalloc: 
1367			 
1367					if DEBUG_FORTH_MALLOC_INT 
1367						DMARK "mym" 
1367						CALLMONITOR 
1367					endif 
1367			.findblock: 
1367					if DEBUG_FORTH_MALLOC_INT 
1367						DMARK "mmf" 
1367						CALLMONITOR 
1367					endif 
1367			 
1367				ld a,(hl)  
1367				; if byte is zero then clear to use 
1367			 
1367				cp 0 
1367				jr z, .foundemptyblock 
1367			 
1367				; if byte is not clear 
1367				;     then byte is offset to next block 
1367			 
1367				inc hl 
1367				ld a, (hl) ; get size 
1367			.nextblock:	inc hl 
1367					ld e, (hl) 
1367					inc hl 
1367					ld d, (hl) 
1367					ex de, hl 
1367			;	inc hl  ; move past the store space 
1367			;	inc hl  ; move past zero index  
1367			 
1367				; TODO detect no more space 
1367			 
1367				push hl 
1367				ld de, heap_end 
1367				call cmp16 
1367				pop hl 
1367				jr nc, .nospace 
1367			 
1367				jr .findblock 
1367			 
1367			.nospace: ld hl, 0 
1367				jp .exit 
1367			 
1367			 
1367			.foundemptyblock:	 
1367					if DEBUG_FORTH_MALLOC_INT 
1367						DMARK "mme" 
1367						CALLMONITOR 
1367					endif 
1367			 
1367			; TODO has block enough space if reusing??? 
1367			 
1367				;  
1367			 
1367			; see if this block has been previously used 
1367				inc hl 
1367				ld a, (hl) 
1367				dec hl 
1367				cp 0 
1367				jr z, .newblock 
1367			 
1367					if DEBUG_FORTH_MALLOC_INT 
1367						DMARK "meR" 
1367						CALLMONITOR 
1367					endif 
1367			 
1367			; no reusing previously allocated block 
1367			 
1367			; is it smaller than previously used? 
1367				 
1367				inc hl    ; move to size 
1367				ld a, c 
1367				sub (hl)        ; we want c < (hl) 
1367				dec hl    ; move back to marker 
1367			        jr z, .findblock 
1367			 
1367				; update with the new size which should be lower 
1367			 
1367			        ;inc  hl   ; negate next move. move back to size  
1367			 
1367			.newblock: 
1367				; need to be at marker here 
1367			 
1367					if DEBUG_FORTH_MALLOC_INT 
1367						DMARK "meN" 
1367						CALLMONITOR 
1367					endif 
1367			 
1367			 
1367				ld a, c 
1367			 
1367				ld (free_list+3), a	 ; flag resume from last malloc  
1367				ld (free_list), hl    ; save out last location 
1367			 
1367			 
1367				;inc a     ; space for length byte 
1367				ld (hl), a     ; save block in use marker 
1367			 
1367				inc hl   ; move to space marker 
1367				ld (hl), a    ; save new space 
1367			 
1367				inc hl   ; move to start of allocated area 
1367				 
1367			;	push hl     ; save where we are - 1  
1367			 
1367			;	inc hl  ; move past zero index  
1367				; skip space to set down new marker 
1367			 
1367				; provide some extra space for now 
1367			 
1367				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1367				inc a 
1367				inc a 
1367			 
1367				push hl   ; save where we are in the node block 
1367			 
1367				call addatohl 
1367			 
1367				; write linked list point 
1367			 
1367				pop de     ; get our node position 
1367				ex de, hl 
1367			 
1367				ld (hl), e 
1367				inc hl 
1367				ld (hl), d 
1367			 
1367				inc hl 
1367			 
1367				; now at start of allocated data so save pointer 
1367			 
1367				push hl 
1367			 
1367				; jump to position of next node and setup empty header in DE 
1367			 
1367				ex de, hl 
1367			 
1367			;	inc hl ; move past end of block 
1367			 
1367				ld a, 0 
1367				ld (hl), a   ; empty marker 
1367				inc hl 
1367				ld (hl), a   ; size 
1367				inc hl  
1367				ld (hl), a   ; ptr 
1367				inc hl 
1367				ld (hl), a   ; ptr 
1367			 
1367			 
1367				pop hl 
1367			 
1367					if DEBUG_FORTH_MALLOC_INT 
1367						DMARK "mmr" 
1367						CALLMONITOR 
1367					endif 
1367			 
1367			.exit: 
1367				pop af 
1367				pop bc 
1367				pop de  
1367				ret 
1367			 
1367			 
1367			 
1367			 
1367			free:  
1367				push hl 
1367				push af 
1367				; get address in hl 
1367			 
1367					if DEBUG_FORTH_MALLOC_INT 
1367						DMARK "fre" 
1367						CALLMONITOR 
1367					endif 
1367				; data is at hl - move to block count 
1367				dec hl 
1367				dec hl    ; get past pointer 
1367				dec hl 
1367			 
1367				ld a, (hl)    ; need this for a validation check 
1367			 
1367				dec hl    ; move to block marker 
1367			 
1367				; now check that the block count and block marker are the same  
1367			        ; this checks that we are on a malloc node and not random memory 
1367			        ; OK a faint chance this could be a problem but rare - famous last words! 
1367			 
1367				ld c, a 
1367				ld a, (hl)    
1367			 
1367				cp c 
1367				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1367			 
1367				; yes good chance we are on a malloc node 
1367			 
1367				ld a, 0      
1367				ld (hl), a   ; mark as free 
1367			 
1367				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1367			 
1367			.freeignore:  
1367			 
1367				pop af 
1367				pop hl 
1367			 
1367				ret 
1367			 
1367			 
1367			 
1367			endif 
1367			 
1367			; eof 
# End of file firmware_memory.asm
1367			  
1367			; device C  
1367			; Now handled by SPI  
1367			;if SOUND_ENABLE  
1367			;	include "firmware_sound.asm"  
1367			;endif  
1367			  
1367			include "firmware_diags.asm"  
1367			; Hardware diags menu 
1367			 
1367			 
1367			config: 
1367			 
1367 3e 00			ld a, 0 
1369 21 8d 13			ld hl, .configmn 
136c cd ea 0b			call menu 
136f			 
136f fe 00			cp 0 
1371 c8				ret z 
1372			 
1372			;	cp 1 
1372			;	call z, .savetostore 
1372			 
1372 fe 01			cp 1 
1374			if STARTUP_V1 
1374 cc a3 13			call z, .selautoload 
1377			endif 
1377			 
1377			if STARTUP_V2 
1377				call z, .enautoload 
1377			endif 
1377 fe 02			cp 2 
1379 cc 99 13			call z, .disautoload 
137c			;	cp 3 
137c			;	call z, .selbank 
137c fe 03			cp 3 
137e cc c1 13			call z, .debug_tog 
1381 fe 04			cp 4 
1383 cc 0f 15			call z, .bpsgo 
1386 fe 05			cp 5 
1388 cc ea 13			call z, hardware_diags 
138b			if STARTUP_V2 
138b				cp 6 
138b				call z, create_startup 
138b			endif 
138b 18 da			jr config 
138d			 
138d			.configmn: 
138d			;	dw prom_c3 
138d fd 16			dw prom_c2 
138f 12 17			dw prom_c2a 
1391			;	dw prom_c2b 
1391			;	dw prom_c4 
1391 31 17			dw prom_m4 
1393 4c 17			dw prom_m4b 
1395 54 17			dw prom_c1 
1397			if STARTUP_V2 
1397				dw prom_c9 
1397			endif 
1397 00 00			dw 0 
1399				 
1399			 
1399			if STARTUP_V2 
1399			.enautoload: 
1399				if STORAGE_SE 
1399				ld a, $fe      ; bit 0 clear 
1399				ld (spi_device), a 
1399			 
1399				call storage_get_block_0 
1399			 
1399				ld a, 1 
1399				ld (store_page+STORE_0_AUTOFILE), a 
1399			 
1399					ld hl, 0 
1399					ld de, store_page 
1399				call storage_write_block	 ; save update 
1399				else 
1399			 
1399				ld hl, prom_notav 
1399				ld de, prom_empty 
1399				call info_panel 
1399				endif 
1399			 
1399			 
1399				ret 
1399			endif 
1399			 
1399			.disautoload: 
1399				if STORAGE_SE 
1399				ld a, $fe      ; bit 0 clear 
1399				ld (spi_device), a 
1399			 
1399				call storage_get_block_0 
1399			 
1399				ld a, 0 
1399				ld (store_page+STORE_0_AUTOFILE), a 
1399			 
1399					ld hl, 0 
1399					ld de, store_page 
1399				call storage_write_block	 ; save update 
1399				else 
1399			 
1399 21 63 17			ld hl, prom_notav 
139c 11 79 17			ld de, prom_empty 
139f cd 4a 0b			call info_panel 
13a2				endif 
13a2			 
13a2			 
13a2 c9				ret 
13a3			 
13a3			if STARTUP_V1 
13a3			 
13a3			; Select auto start 
13a3			 
13a3			.selautoload: 
13a3			 
13a3				 
13a3				if STORAGE_SE 
13a3			 
13a3					call config_dir 
13a3				        ld hl, scratch 
13a3					ld a, 0 
13a3					call menu 
13a3			 
13a3					cp 0 
13a3					ret z 
13a3			 
13a3					dec a 
13a3			 
13a3			 
13a3					; locate menu option 
13a3			 
13a3					ld hl, scratch 
13a3					call table_lookup 
13a3			 
13a3					if DEBUG_FORTH_WORDS 
13a3						DMARK "ALl" 
13a3						CALLMONITOR 
13a3					endif 
13a3					; with the pointer to the menu it, the byte following the zero term is the file id 
13a3			 
13a3					ld a, 0 
13a3					ld bc, 50   ; max of bytes to look at 
13a3					cpir  
13a3			 
13a3					if DEBUG_FORTH_WORDS 
13a3						DMARK "ALb" 
13a3						CALLMONITOR 
13a3					endif 
13a3					;inc hl 
13a3			 
13a3					ld a, (hl)   ; file id 
13a3					 
13a3				        ; save bank and file ids 
13a3			 
13a3					push af 
13a3			 
13a3			; TODO need to save to block 0 on bank 1	 
13a3			 
13a3					call storage_get_block_0 
13a3			 
13a3					if DEBUG_FORTH_WORDS 
13a3						DMARK "AL0" 
13a3						CALLMONITOR 
13a3					endif 
13a3					pop af 
13a3			 
13a3					ld (store_page+STORE_0_FILERUN),a 
13a3					 
13a3					; save bank id 
13a3			 
13a3					ld a,(spi_device) 
13a3					ld (store_page+STORE_0_BANKRUN),a 
13a3			 
13a3					; enable auto run of store file 
13a3			 
13a3					ld a, 1 
13a3					ld (store_page+STORE_0_AUTOFILE),a 
13a3			 
13a3					; save buffer 
13a3			 
13a3					ld hl, 0 
13a3					ld de, store_page 
13a3					if DEBUG_FORTH_WORDS 
13a3						DMARK "ALw" 
13a3						CALLMONITOR 
13a3					endif 
13a3				call storage_write_block	 ; save update 
13a3			  
13a3			 
13a3			 
13a3			 
13a3					ld hl, scratch 
13a3					call config_fdir 
13a3			 
13a3				else 
13a3			 
13a3 21 63 17			ld hl, prom_notav 
13a6 11 79 17			ld de, prom_empty 
13a9 cd 4a 0b			call info_panel 
13ac			 
13ac				endif 
13ac c9				ret 
13ad			endif 
13ad			 
13ad			 
13ad			; Select storage bank 
13ad			 
13ad			.selbank: 
13ad			 
13ad			;	if STORAGE_SE 
13ad			;	else 
13ad			 
13ad 21 63 17			ld hl, prom_notav 
13b0 11 79 17			ld de, prom_empty 
13b3 cd 4a 0b			call info_panel 
13b6			;	endif 
13b6				 
13b6 c9				ret 
13b7			 
13b7			if STORAGE_SE 
13b7			 
13b7			.config_ldir:   
13b7				; Load storage bank labels into menu array 
13b7			 
13b7				 
13b7			 
13b7			 
13b7				ret 
13b7			 
13b7			 
13b7			endif 
13b7			 
13b7			 
13b7			; Save user words to storage 
13b7			 
13b7			.savetostore: 
13b7			 
13b7			;	if STORAGE_SE 
13b7			; 
13b7			;		call config_dir 
13b7			;	        ld hl, scratch 
13b7			;		ld a, 0 
13b7			;		call menu 
13b7			;		 
13b7			;		ld hl, scratch 
13b7			;		call config_fdir 
13b7			; 
13b7			;	else 
13b7			 
13b7 21 63 17			ld hl, prom_notav 
13ba 11 79 17			ld de, prom_empty 
13bd cd 4a 0b			call info_panel 
13c0			 
13c0			;	endif 
13c0			 
13c0 c9				ret 
13c1			 
13c1			if STARTUP_V2 
13c1			 
13c1			create_startup: 
13c1			 
13c1				ld a, 0 
13c1				ld hl, .crstart 
13c1				call menu 
13c1			 
13c1				cp 0 
13c1				ret z 
13c1			 
13c1				cp 1 
13c1				call z, .genlsword 
13c1				cp 2 
13c1				call z, .genedword 
13c1			 
13c1				cp 3 
13c1				call z, .gendemword 
13c1			 
13c1				cp 4 
13c1				call z, .genutlword 
13c1				cp 5 
13c1				call z, .genspiword 
13c1				cp 6 
13c1				call z, .genkeyword 
13c1				cp 7 
13c1				call z, .gensoundword 
13c1				jr create_startup 
13c1			 
13c1			.gensoundword: 
13c1				ld hl, crs_sound 
13c1				ld de, .soundworddef 
13c1				call .genfile 
13c1				ret 
13c1			.genlsword: 
13c1				ld hl, crs_s1 
13c1				ld de, .lsworddef 
13c1				call .genfile 
13c1				ret 
13c1			 
13c1			.genedword: 
13c1				ld de, .edworddef 
13c1				ld hl, crs_s2 
13c1				call .genfile 
13c1				ret 
13c1			 
13c1			.gendemword: 
13c1				ld de, .demoworddef 
13c1				ld hl, crs_s3 
13c1				call .genfile 
13c1				ret 
13c1			 
13c1			.genutlword: 
13c1				ld hl, crs_s4 
13c1				ld de, .utilwordef 
13c1				call .genfile 
13c1				ret 
13c1			.genspiword: 
13c1				ld hl, crs_s5 
13c1				ld de, .spiworddef 
13c1				call .genfile 
13c1				ret 
13c1			.genkeyword: 
13c1				ld hl, crs_s6 
13c1				ld de, .keyworddef 
13c1				call .genfile 
13c1				ret 
13c1			 
13c1			; hl - points to file name 
13c1			; de - points to strings to add to file 
13c1			 
13c1			.genfile: 
13c1				push hl 
13c1				push de 
13c1			 
13c1				call clear_display 
13c1				ld a, display_row_1 
13c1				ld de, .genfiletxt 
13c1				call str_at_display 
13c1				call update_display 
13c1			 
13c1				pop de 
13c1				pop hl 
13c1			 
13c1			 
13c1				push de 
13c1				call storage_create 
13c1				; id in hl 
13c1				pop de   ; table of strings to add 
13c1			 
13c1			.genloop: 
13c1			 
13c1				push hl ; save id for next time around 
13c1				push de ; save de for next time around 
13c1			 
13c1				ex de, hl 
13c1				call loadwordinhl 
13c1				ex de, hl 
13c1			 
13c1				; need hl to be the id 
13c1				; need de to be the string ptr 
13c1				 
13c1				call storage_append 
13c1			 
13c1				pop de 
13c1				pop hl 
13c1			 
13c1				inc de 
13c1				inc de 
13c1			 
13c1				ld a,(de) 
13c1				cp 0 
13c1				jr nz, .genloop 
13c1				inc de 
13c1				ld a, (de) 
13c1				dec de 
13c1				cp 0 
13c1				jr nz, .genloop	 
13c1			 
13c1				ret 
13c1			 
13c1			.genfiletxt:  db "Creating file...",0 
13c1			 
13c1			.soundworddef: 
13c1				dw sound1 
13c1				dw sound2 
13c1				dw sound3 
13c1				dw sound4 
13c1				dw sound5 
13c1				dw sound6 
13c1				dw sound7 
13c1				dw sound8 
13c1				dw sound9 
13c1				dw 0 
13c1			 
13c1			.utilwordef: 
13c1				dw strncpy 
13c1				dw type 
13c1				dw clrstack 
13c1				dw longread 
13c1				dw start1 
13c1				dw start2 
13c1			; duplicated 
13c1			;	dw start3b 
13c1			;	dw start3c 
13c1				dw list 
13c1				dw 0 
13c1			 
13c1			.lsworddef: 
13c1				dw start3b 
13c1				dw 0 
13c1			 
13c1			.edworddef: 
13c1				dw edit1 
13c1				dw edit2 
13c1				dw edit3 
13c1				dw 0 
13c1			 
13c1			.demoworddef: 
13c1				dw test5 
13c1				dw test6 
13c1				dw test7 
13c1				dw test8 
13c1				dw test9 
13c1				dw test10 
13c1				dw game1 
13c1				dw game1a 
13c1				dw game1b 
13c1				dw game1c 
13c1				dw game1d 
13c1				dw game1s 
13c1				dw game1t 
13c1				dw game1f 
13c1				dw game1z 
13c1				dw game1zz 
13c1				dw ssv2 
13c1				dw ssv3 
13c1				dw ssv4 
13c1				dw ssv5 
13c1				dw ssv1 
13c1				dw ssv1cpm	 
13c1				dw game2b 
13c1				dw game2bf 
13c1				dw game2mba 
13c1				dw game2mbas	 
13c1				dw game2mbht 
13c1				dw game2mbms 
13c1				dw game2mb 
13c1				dw game3w 
13c1				dw game3p 
13c1				dw game3sc 
13c1				dw game3vsi 
13c1				dw game3vs 
13c1				dw 0 
13c1			 
13c1			 
13c1			.spiworddef: 
13c1			 
13c1			    dw spi1 
13c1			    dw spi2 
13c1			    dw spi2b 
13c1			    dw spi3 
13c1			    dw spi4 
13c1			    dw spi5 
13c1			;    dw spi6 
13c1			;    dw spi7 
13c1			 
13c1			;    dw spi8 
13c1			;    dw spi9 
13c1			;    dw spi10 
13c1			    dw 0 
13c1			 
13c1			.keyworddef: 
13c1			 
13c1				dw keyup 
13c1				dw keydown 
13c1				dw keyleft 
13c1				dw keyright 
13c1				dw 	keyf1 
13c1				dw keyf2 
13c1				dw keyf3 
13c1				dw keyf4 
13c1				dw keyf5 
13c1				dw keyf6 
13c1				dw keyf7 
13c1				dw keyf8 
13c1				dw keyf9 
13c1				dw keyf10 
13c1				dw keyf11 
13c1				dw keyf12 
13c1				dw keytab 
13c1				dw keycr 
13c1				dw keyhome 
13c1				dw keyend 
13c1				dw keybs 
13c1				dw 0 
13c1			 
13c1			.crstart: 
13c1				dw crs_s1 
13c1				dw crs_s2 
13c1				dw crs_s3 
13c1				dw crs_s4 
13c1				dw crs_s5 
13c1				dw crs_s6 
13c1				dw crs_sound 
13c1				dw 0 
13c1			 
13c1			endif 
13c1			 
13c1			 
13c1			if STORAGE_SE 
13c1			 
13c1			config_fdir: 
13c1				; using the scratch dir go through and release the memory allocated for each string 
13c1				 
13c1				ld hl, scratch 
13c1			.cfdir:	ld e,(hl) 
13c1				inc hl 
13c1				ld d,(hl) 
13c1				inc hl 
13c1			 
13c1				ex de, hl 
13c1				call ishlzero 
13c1				ret z     ; return on null pointer 
13c1				call free 
13c1				ex de, hl 
13c1				jr .cfdir 
13c1			 
13c1			 
13c1				ret 
13c1			 
13c1			 
13c1			config_dir: 
13c1			 
13c1				; for the config menus that need to build a directory of storage call this routine 
13c1				; it will construct a menu in scratch to pass to menu 
13c1			 
13c1				; open storage device 
13c1			 
13c1				; execute DIR to build a list of files and their ids into scratch in menu format 
13c1				; once the menu has finished then will need to call config_fdir to release the strings 
13c1				 
13c1				; c = number items 
13c1			 
13c1				 
13c1				call storage_get_block_0 
13c1			 
13c1				ld hl, store_page     ; get current id count 
13c1				ld b, (hl) 
13c1				ld c, 0    ; count of files   
13c1			 
13c1			 
13c1				ld hl, scratch 
13c1				ld (store_tmp2), hl    ; location to poke strings 
13c1			 
13c1				; check for empty drive 
13c1			 
13c1				ld a, 0 
13c1				cp b 
13c1				jp z, .dirdone 
13c1			 
13c1				 
13c1					if DEBUG_FORTH_WORDS 
13c1						DMARK "Cdc" 
13c1						CALLMONITOR 
13c1					endif 
13c1			 
13c1			 
13c1			.diritem:	 
13c1				push bc 
13c1				; for each of the current ids do a search for them and if found push to stack 
13c1			 
13c1					ld hl, STORE_BLOCK_PHY 
13c1					ld d, 0		 ; look for extent 0 of block id as this contains file name 
13c1					ld e,b 
13c1			 
13c1					call storage_findnextid 
13c1			 
13c1			 
13c1					; if found hl will be non zero 
13c1			 
13c1					call ishlzero 
13c1					jr z, .dirnotfound 
13c1			 
13c1					; increase count 
13c1			 
13c1					pop bc	 
13c1					inc c 
13c1					push bc 
13c1					 
13c1			 
13c1					; get file header and push the file name 
13c1			 
13c1					ld de, store_page 
13c1					call storage_read_block 
13c1			 
13c1					; push file id to stack 
13c1				 
13c1					ld a, (store_page) 
13c1					ld h, 0 
13c1					ld l, a 
13c1			 
13c1					;call forth_push_numhl 
13c1					; TODO store id 
13c1			 
13c1					push hl 
13c1			 
13c1					; push extent count to stack  
13c1				 
13c1					ld hl, store_page+3 
13c1			 
13c1					; get file name length 
13c1			 
13c1					call strlenz   
13c1			 
13c1					inc hl   ; cover zero term 
13c1					inc hl  ; stick the id at the end of the area 
13c1			 
13c1					push hl 
13c1					pop bc    ; move length to bc 
13c1			 
13c1					call malloc 
13c1			 
13c1					; TODO save malloc area to scratch 
13c1			 
13c1					ex de, hl 
13c1					ld hl, (store_tmp2) 
13c1					ld (hl), e 
13c1					inc hl 
13c1					ld (hl), d 
13c1					inc hl 
13c1					ld (store_tmp2), hl 
13c1			 
13c1					 
13c1			 
13c1					;pop hl   ; get source 
13c1			;		ex de, hl    ; swap aronund	 
13c1			 
13c1					ld hl, store_page+3 
13c1					if DEBUG_FORTH_WORDS 
13c1						DMARK "CFd" 
13c1						CALLMONITOR 
13c1					endif 
13c1					ldir 
13c1			 
13c1					; de is past string, move back one and store id 
13c1					 
13c1					dec de 
13c1			 
13c1					; store file id 
13c1			 
13c1					pop hl 
13c1					ex de,hl 
13c1					ld (hl), e 
13c1			 
13c1					if DEBUG_FORTH_WORDS 
13c1						DMARK "Cdi" 
13c1						CALLMONITOR 
13c1					endif 
13c1					 
13c1			.dirnotfound: 
13c1					pop bc     
13c1					djnz .diritem 
13c1				 
13c1			.dirdone:	 
13c1			 
13c1					ld a, 0 
13c1					ld hl, (store_tmp2) 
13c1					ld (hl), a 
13c1					inc hl 
13c1					ld (hl), a 
13c1					inc hl 
13c1					; push a count of the dir items found 
13c1			 
13c1			;		ld h, 0 
13c1			;		ld l, c 
13c1			 
13c1				ret 
13c1			 
13c1			endif 
13c1			 
13c1			 
13c1			; Settings 
13c1			; Run  
13c1			 
13c1			 
13c1			 
13c1			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
13c1			;;hd_menu2:   db "        2: Editor",0   
13c1			;hd_menu2:   db "        2: Editor       6: Menu",0   
13c1			;hd_menu3:   db "        3: Storage",0 
13c1			;hd_menu4:   db "0=quit  4: Debug",0 
13c1			;hd_don:     db "ON",0 
13c1			;hd_doff:     db "OFF",0 
13c1			; 
13c1			; 
13c1			; 
13c1			;hardware_diags_old:       
13c1			; 
13c1			;.diagmenu: 
13c1			;	call clear_display 
13c1			;	ld a, display_row_1 
13c1			;	ld de, hd_menu1 
13c1			;	call str_at_display 
13c1			; 
13c1			;	ld a, display_row_2 
13c1			;	ld de, hd_menu2 
13c1			;	call str_at_display 
13c1			; 
13c1			;	ld a, display_row_3 
13c1			;	ld de, hd_menu3 
13c1			;	call str_at_display 
13c1			; 
13c1			;	ld a,  display_row_4 
13c1			;	ld de, hd_menu4 
13c1			;	call str_at_display 
13c1			; 
13c1			;	; display debug state 
13c1			; 
13c1			;	ld de, hd_don 
13c1			;	ld a, (os_view_disable) 
13c1			;	cp 0 
13c1			;	jr z, .distog 
13c1			;	ld de, hd_doff 
13c1			;.distog: ld a, display_row_4+17 
13c1			;	call str_at_display 
13c1			; 
13c1			;	call update_display 
13c1			; 
13c1			;	call cin_wait 
13c1			; 
13c1			; 
13c1			; 
13c1			;	cp '4' 
13c1			;	jr nz, .diagn1 
13c1			; 
13c1			;	; debug toggle 
13c1			; 
13c1			;	ld a, (os_view_disable) 
13c1			;	ld b, '*' 
13c1			;	cp 0 
13c1			;	jr z, .debtog 
13c1			;	ld b, 0 
13c1			;.debtog:	 
13c1			;	ld a,b 
13c1			;	ld (os_view_disable),a 
13c1			; 
13c1			;.diagn1: cp '0' 
13c1			;	 ret z 
13c1			; 
13c1			;;	cp '1' 
13c1			;;       jp z, matrix	 
13c1			;;   TODO keyboard matrix test 
13c1			; 
13c1			;	cp '2' 
13c1			;	jp z, .diagedit 
13c1			; 
13c1			;;	cp '6' 
13c1			;;	jp z, .menutest 
13c1			;;if ENABLE_BASIC 
13c1			;;	cp '6' 
13c1			;;	jp z, basic 
13c1			;;endif 
13c1			 ; 
13c1			;	jp .diagmenu 
13c1			; 
13c1			; 
13c1			;	ret 
13c1			 
13c1			 
13c1			.debug_tog: 
13c1 21 0b 14			ld hl, .menudebug 
13c4				 
13c4			;	ld a, (os_view_disable) 
13c4			;	cp '*' 
13c4 3a 6f ee			ld a,(debug_vector) 
13c7 fe c9			cp $C9   ; RET 
13c9 20 04			jr nz,.tdon  
13cb 3e 01			ld a, 1 
13cd 18 02			jr .tog1 
13cf 3e 00		.tdon: ld a, 0 
13d1			 
13d1			.tog1: 
13d1 cd ea 0b			call menu 
13d4 fe 00			cp 0 
13d6 c8				ret z 
13d7 fe 01			cp 1    ; disable debug 
13d9 28 04			jr z, .dtog0 
13db 3e 2a			ld a, '*' 
13dd 18 05			jr .dtogset 
13df			.dtog0:  
13df				;ld a, 0 
13df cd fd 14			call bp_on 
13e2 18 dd			jr .debug_tog 
13e4			.dtogset:  
13e4				; ld (os_view_disable), a 
13e4 cd 09 15			call bp_off 
13e7 c3 c1 13			jp .debug_tog 
13ea			 
13ea			 
13ea			hardware_diags:       
13ea			 
13ea			.diagm: 
13ea 21 fd 13			ld hl, .menuitems 
13ed 3e 00			ld a, 0 
13ef cd ea 0b			call menu 
13f2			 
13f2 fe 00		         cp 0 
13f4 c8				 ret z 
13f5			 
13f5 fe 02			cp 2 
13f7 ca 56 14			jp z, .diagedit 
13fa			 
13fa			;	cp '6' 
13fa			;	jp z, .menutest 
13fa			;if ENABLE_BASIC 
13fa			;	cp '6' 
13fa			;	jp z, basic 
13fa			;endif 
13fa			  
13fa c3 ea 13			jp .diagm 
13fd			 
13fd				 
13fd 11 14		.menuitems:   	dw .m1 
13ff 1c 14				dw .m2 
1401 23 14				dw .m3 
1403 2b 14				dw .m5 
1405 31 14				dw .m5a 
1407 3a 14				dw .m5b 
1409 00 00				dw 0 
140b			 
140b			.menudebug: 
140b 43 14				dw .m6 
140d 4c 14				dw .m7 
140f 00 00				dw 0 
1411			 
1411 .. 00		.m1:   db "Key Matrix",0 
141c .. 00		.m2:   db "Editor",0 
1423 .. 00		.m3:   db "Storage",0 
142b .. 00		.m5:   db "Sound",0 
1431 .. 00		.m5a:  db "RAM Test",0 
143a .. 00		.m5b:  db "LCD Test",0 
1443			 
1443 .. 00		.m6:   db "Debug ON",0 
144c .. 00		.m7:   db "Debug OFF",0 
1456			 
1456			; debug editor 
1456			 
1456			.diagedit: 
1456			 
1456 21 c1 e2			ld hl, scratch 
1459			;	ld bc, 250 
1459			;	ldir 
1459				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1459 3e 00			ld a, 0 
145b 77				ld (hl), a 
145c 23				inc hl 
145d 77				ld (hl), a 
145e 23				inc hl 
145f 77				ld (hl), a 
1460			 
1460 cd b9 0b		        call clear_display 
1463 cd dc 0b			call update_display 
1466				;ld a, 1 
1466				;ld (hardware_diag), a 
1466			.diloop: 
1466 3e 00			ld a, display_row_1 
1468 0e 00			ld c, 0 
146a 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
146c 1e 28			ld e, 40 
146e			 
146e 21 c1 e2			ld hl, scratch	 
1471 cd 13 0e			call input_str 
1474			 
1474 3e 28			ld a, display_row_2 
1476 11 c1 e2			ld de, scratch 
1479 cd cc 0b			call str_at_display 
147c cd dc 0b			call update_display 
147f			 
147f c3 66 14			jp .diloop 
1482			 
1482			 
1482			; pass word in hl 
1482			; a has display location 
1482			display_word_at: 
1482 f5				push af 
1483 e5				push hl 
1484 7c				ld a,h 
1485 21 c6 e5			ld hl, os_word_scratch 
1488 cd fc 0f			call hexout 
148b e1				pop hl 
148c 7d				ld a,l 
148d 21 c8 e5			ld hl, os_word_scratch+2 
1490 cd fc 0f			call hexout 
1493 21 ca e5			ld hl, os_word_scratch+4 
1496 3e 00			ld a,0 
1498 77				ld (hl),a 
1499 11 c6 e5			ld de,os_word_scratch 
149c f1				pop af 
149d cd cc 0b				call str_at_display 
14a0 c9				ret 
14a1			 
14a1			display_ptr_state: 
14a1			 
14a1				; to restore afterwards 
14a1			 
14a1 d5				push de 
14a2 c5				push bc 
14a3 e5				push hl 
14a4 f5				push af 
14a5			 
14a5				; for use in here 
14a5			 
14a5			;	push bc 
14a5			;	push de 
14a5			;	push hl 
14a5			;	push af 
14a5			 
14a5 cd b9 0b			call clear_display 
14a8			 
14a8 11 80 16			ld de, .ptrstate 
14ab 3e 00			ld a, display_row_1 
14ad cd cc 0b			call str_at_display 
14b0			 
14b0				; display debug step 
14b0			 
14b0			 
14b0 11 6b ee			ld de, debug_mark 
14b3 3e 26			ld a, display_row_1+display_cols-2 
14b5 cd cc 0b			call str_at_display 
14b8			 
14b8				; display a 
14b8 11 8a 16			ld de, .ptrcliptr 
14bb 3e 28			ld a, display_row_2 
14bd cd cc 0b			call str_at_display 
14c0			 
14c0 f1				pop af 
14c1 2a 40 ea			ld hl,(cli_ptr) 
14c4 3e 30			ld a, display_row_2+8 
14c6 cd 82 14			call display_word_at 
14c9			 
14c9			 
14c9				; display hl 
14c9			 
14c9			 
14c9 11 92 16			ld de, .ptrclioptr 
14cc 3e 32			ld a, display_row_2+10 
14ce cd cc 0b			call str_at_display 
14d1			; 
14d1			;	pop hl 
14d1 3e 35			ld a, display_row_2+13 
14d3 2a 3e ea			ld hl,(cli_origptr) 
14d6 cd 82 14			call display_word_at 
14d9			; 
14d9			;	 
14d9			;	; display de 
14d9			 
14d9			;	ld de, .regstatede 
14d9			;	ld a, display_row_3 
14d9			;	call str_at_display 
14d9			 
14d9			;	pop de 
14d9			;	ld h,d 
14d9			;	ld l, e 
14d9			;	ld a, display_row_3+3 
14d9			;	call display_word_at 
14d9			 
14d9			 
14d9				; display bc 
14d9			 
14d9			;	ld de, .regstatebc 
14d9			;	ld a, display_row_3+10 
14d9			;	call str_at_display 
14d9			 
14d9			;	pop bc 
14d9			;	ld h,b 
14d9			;	ld l, c 
14d9			;	ld a, display_row_3+13 
14d9			;	call display_word_at 
14d9			 
14d9			 
14d9				; display dsp 
14d9			 
14d9			;	ld de, .regstatedsp 
14d9			;	ld a, display_row_4 
14d9			;	call str_at_display 
14d9			 
14d9				 
14d9			;	ld hl,(cli_data_sp) 
14d9			;	ld a, display_row_4+4 
14d9			;	call display_word_at 
14d9			 
14d9				; display rsp 
14d9			 
14d9 11 c1 16			ld de, .regstatersp 
14dc 3e 82			ld a, display_row_4+10 
14de cd cc 0b			call str_at_display 
14e1			 
14e1				 
14e1 2a f2 e9			ld hl,(cli_ret_sp) 
14e4 3e 86			ld a, display_row_4+14 
14e6 cd 82 14			call display_word_at 
14e9			 
14e9 cd dc 0b			call update_display 
14ec			 
14ec cd f1 0a			call delay1s 
14ef cd f1 0a			call delay1s 
14f2 cd f1 0a			call delay1s 
14f5			 
14f5			 
14f5 cd df 1a			call next_page_prompt 
14f8			 
14f8				; restore  
14f8			 
14f8 f1				pop af 
14f9 e1				pop hl 
14fa c1				pop bc 
14fb d1				pop de 
14fc c9				ret 
14fd			 
14fd			; Update the break point vector so that the user can hook a new routine 
14fd			 
14fd			bp_on: 
14fd 3e c3			ld a, $c3    ; JP 
14ff 32 6f ee			ld (debug_vector), a 
1502 21 0f 15			ld hl, break_point_state 
1505 22 70 ee			ld (debug_vector+1), hl 
1508 c9				ret 
1509			 
1509			bp_off: 
1509 3e c9			ld a, $c9    ; RET 
150b 32 6f ee			ld (debug_vector), a 
150e c9				ret 
150f			 
150f			 
150f			break_point_state: 
150f			;	push af 
150f			; 
150f			;	; see if disabled 
150f			; 
150f			;	ld a, (os_view_disable) 
150f			;	cp '*' 
150f			;	jr nz, .bpsgo 
150f			;	pop af 
150f			;	ret 
150f			 
150f			.bpsgo: 
150f			;	pop af 
150f f5				push af 
1510 22 a3 e2			ld (os_view_hl), hl 
1513 ed 53 a1 e2		ld (os_view_de), de 
1517 ed 43 9f e2		ld (os_view_bc), bc 
151b e5				push hl 
151c 6f				ld l, a 
151d 26 00			ld h, 0 
151f 22 a5 e2			ld (os_view_af),hl 
1522			 
1522 21 b1 ed				ld hl, display_fb0 
1525 22 cc eb				ld (display_fb_active), hl 
1528 e1				pop hl	 
1529			 
1529 3e 31			ld a, '1' 
152b fe 2a		.bps1:  cp '*' 
152d cc 09 15			call z, bp_off 
1530			;	jr nz, .bps1b 
1530			;	ld (os_view_disable),a 
1530 fe 31		.bps1b:  cp '1' 
1532 20 14			jr nz, .bps2 
1534			 
1534				; display reg 
1534			 
1534				 
1534			 
1534 3a a5 e2			ld a, (os_view_af) 
1537 2a a3 e2			ld hl, (os_view_hl) 
153a ed 5b a1 e2		ld de, (os_view_de) 
153e ed 4b 9f e2		ld bc, (os_view_bc) 
1542 cd dc 15			call display_reg_state 
1545 c3 c8 15			jp .bpschk 
1548			 
1548 fe 32		.bps2:  cp '2' 
154a 20 08			jr nz, .bps3 
154c				 
154c				; display hl 
154c 2a a3 e2			ld hl, (os_view_hl) 
154f cd c6 16			call display_dump_at_hl 
1552			 
1552 18 74			jr .bpschk 
1554			 
1554 fe 33		.bps3:  cp '3' 
1556 20 08			jr nz, .bps4 
1558			 
1558			        ; display de 
1558 2a a1 e2			ld hl, (os_view_de) 
155b cd c6 16			call display_dump_at_hl 
155e			 
155e 18 68			jr .bpschk 
1560 fe 34		.bps4:  cp '4' 
1562 20 08			jr nz, .bps5 
1564			 
1564			        ; display bc 
1564 2a 9f e2			ld hl, (os_view_bc) 
1567 cd c6 16			call display_dump_at_hl 
156a			 
156a 18 5c			jr .bpschk 
156c fe 35		.bps5:  cp '5' 
156e 20 08		        jr nz, .bps7 
1570			 
1570				; display cur ptr 
1570 2a 40 ea			ld hl, (cli_ptr) 
1573 cd c6 16			call display_dump_at_hl 
1576			 
1576 18 50			jr .bpschk 
1578 fe 36		.bps7:  cp '6' 
157a 20 08			jr nz, .bps8b 
157c				 
157c				; display cur orig ptr 
157c 2a 3e ea			ld hl, (cli_origptr) 
157f cd c6 16			call display_dump_at_hl 
1582 18 44			jr .bpschk 
1584 fe 37		.bps8b:  cp '7' 
1586 20 08			jr nz, .bps9 
1588				 
1588				; display dsp 
1588 2a ee e9			ld hl, (cli_data_sp) 
158b cd c6 16			call display_dump_at_hl 
158e			 
158e 18 38			jr .bpschk 
1590 fe 39		.bps9:  cp '9' 
1592 20 05			jr nz, .bps8c 
1594				 
1594				; display SP 
1594			;	ld hl, sp 
1594 cd c6 16			call display_dump_at_hl 
1597			 
1597 18 2f			jr .bpschk 
1599 fe 38		.bps8c:  cp '8' 
159b 20 08			jr nz, .bps8d 
159d				 
159d				; display rsp 
159d 2a f2 e9			ld hl, (cli_ret_sp) 
15a0 cd c6 16			call display_dump_at_hl 
15a3			 
15a3 18 23			jr .bpschk 
15a5 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
15a7 20 05			jr nz, .bps8 
15a9 cd ad 18			call monitor 
15ac			 
15ac 18 1a			jr .bpschk 
15ae fe 30		.bps8:  cp '0' 
15b0 20 16			jr nz, .bpschk 
15b2			 
15b2 21 10 ed				ld hl, display_fb1 
15b5 22 cc eb				ld (display_fb_active), hl 
15b8 cd dc 0b				call update_display 
15bb			 
15bb				;ld a, (os_view_af) 
15bb 2a a3 e2			ld hl, (os_view_hl) 
15be ed 5b a1 e2		ld de, (os_view_de) 
15c2 ed 4b 9f e2		ld bc, (os_view_bc) 
15c6 f1				pop af 
15c7 c9				ret 
15c8			 
15c8			.bpschk:   
15c8 cd f1 0a			call delay1s 
15cb 3e 9f		ld a,display_row_4 + display_cols - 1 
15cd 11 dd 1a		        ld de, endprg 
15d0 cd cc 0b			call str_at_display 
15d3 cd dc 0b			call update_display 
15d6 cd 3b 65			call cin_wait 
15d9			 
15d9 c3 2b 15			jp .bps1 
15dc			 
15dc			 
15dc			display_reg_state: 
15dc			 
15dc				; to restore afterwards 
15dc			 
15dc d5				push de 
15dd c5				push bc 
15de e5				push hl 
15df f5				push af 
15e0			 
15e0				; for use in here 
15e0			 
15e0 c5				push bc 
15e1 d5				push de 
15e2 e5				push hl 
15e3 f5				push af 
15e4			 
15e4 cd b9 0b			call clear_display 
15e7			 
15e7 11 9c 16			ld de, .regstate 
15ea 3e 00			ld a, display_row_1 
15ec cd cc 0b			call str_at_display 
15ef			 
15ef				; display debug step 
15ef			 
15ef			 
15ef 11 6b ee			ld de, debug_mark 
15f2 3e 25			ld a, display_row_1+display_cols-3 
15f4 cd cc 0b			call str_at_display 
15f7			 
15f7				; display a 
15f7 11 b8 16			ld de, .regstatea 
15fa 3e 28			ld a, display_row_2 
15fc cd cc 0b			call str_at_display 
15ff			 
15ff e1				pop hl 
1600			;	ld h,0 
1600			;	ld l, a 
1600 3e 2b			ld a, display_row_2+3 
1602 cd 82 14			call display_word_at 
1605			 
1605			 
1605				; display hl 
1605			 
1605			 
1605 11 ac 16			ld de, .regstatehl 
1608 3e 32			ld a, display_row_2+10 
160a cd cc 0b			call str_at_display 
160d			 
160d e1				pop hl 
160e 3e 35			ld a, display_row_2+13 
1610 cd 82 14			call display_word_at 
1613			 
1613				 
1613				; display de 
1613			 
1613 11 b0 16			ld de, .regstatede 
1616 3e 50			ld a, display_row_3 
1618 cd cc 0b			call str_at_display 
161b			 
161b e1				pop hl 
161c			;	ld h,d 
161c			;	ld l, e 
161c 3e 53			ld a, display_row_3+3 
161e cd 82 14			call display_word_at 
1621			 
1621			 
1621				; display bc 
1621			 
1621 11 b4 16			ld de, .regstatebc 
1624 3e 5a			ld a, display_row_3+10 
1626 cd cc 0b			call str_at_display 
1629			 
1629 e1				pop hl 
162a			;	ld h,b 
162a			;	ld l, c 
162a 3e 5d			ld a, display_row_3+13 
162c cd 82 14			call display_word_at 
162f			 
162f			 
162f				; display dsp 
162f			 
162f 11 bc 16			ld de, .regstatedsp 
1632 3e 78			ld a, display_row_4 
1634 cd cc 0b			call str_at_display 
1637			 
1637				 
1637 2a ee e9			ld hl,(cli_data_sp) 
163a 3e 7c			ld a, display_row_4+4 
163c cd 82 14			call display_word_at 
163f			 
163f				; display rsp 
163f			 
163f 11 c1 16			ld de, .regstatersp 
1642 3e 82			ld a, display_row_4+10 
1644 cd cc 0b			call str_at_display 
1647			 
1647				 
1647 2a f2 e9			ld hl,(cli_ret_sp) 
164a 3e 86			ld a, display_row_4+14 
164c cd 82 14			call display_word_at 
164f			 
164f cd dc 0b			call update_display 
1652			 
1652			;	call delay1s 
1652			;	call delay1s 
1652			;	call delay1s 
1652			 
1652			 
1652			;	call next_page_prompt 
1652			 
1652				; restore  
1652			 
1652 f1				pop af 
1653 e1				pop hl 
1654 c1				pop bc 
1655 d1				pop de 
1656 c9				ret 
1657			 
1657 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
166b .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1680 .. 00		.ptrstate:	db "Ptr State",0 
168a .. 00		.ptrcliptr:     db "cli_ptr",0 
1692 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
169c .. 00		.regstate:	db "Reg State (1/0)",0 
16ac .. 00		.regstatehl:	db "HL:",0 
16b0 .. 00		.regstatede:	db "DE:",0 
16b4 .. 00		.regstatebc:	db "BC:",0 
16b8 .. 00		.regstatea:	db "A :",0 
16bc .. 00		.regstatedsp:	db "DSP:",0 
16c1 .. 00		.regstatersp:	db "RSP:",0 
16c6			 
16c6			display_dump_at_hl: 
16c6 e5				push hl 
16c7 d5				push de 
16c8 c5				push bc 
16c9 f5				push af 
16ca			 
16ca 22 e4 e5			ld (os_cur_ptr),hl	 
16cd cd b9 0b			call clear_display 
16d0 cd e7 19			call dumpcont 
16d3			;	call delay1s 
16d3			;	call next_page_prompt 
16d3			 
16d3			 
16d3 f1				pop af 
16d4 c1				pop bc 
16d5 d1				pop de 
16d6 e1				pop hl 
16d7 c9				ret 
16d8			 
16d8			;if ENABLE_BASIC 
16d8			;	include "nascombasic.asm" 
16d8			;	basic: 
16d8			;	include "forth/FORTH.ASM" 
16d8			;endif 
16d8			 
16d8			; eof 
16d8			 
16d8			 
# End of file firmware_diags.asm
16d8			  
16d8			include "firmware_prompts.asm"  
16d8			; Prompts  
16d8			 
16d8			; boot messages 
16d8			 
16d8 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
16ed .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
16fd			 
16fd			 
16fd			; config menus 
16fd			 
16fd			;prom_c3: db "Add Dictionary To File",0 
16fd			 
16fd			if STARTUP_V1 
16fd .. 00		prom_c2: db "Select Autoload File",0 
1712 .. 00		prom_c2a: db "Disable Autoload File", 0 
1728			endif 
1728			 
1728			if STARTUP_V2 
1728			prom_c2: db "Enable Autoload Files",0 
1728			prom_c2a: db "Disable Autoload Files", 0 
1728			 
1728			crs_s1: db "*ls-word", 0 
1728			crs_s2: db "*ed-word", 0 
1728			crs_s3: db "*Demo-Programs", 0 
1728			crs_s4: db "*Utils", 0 
1728			crs_s5: db "*SPI-Util", 0 
1728			crs_s6: db "*Key-constants", 0 
1728			crs_sound: db "*Sound-Util", 0 
1728			 
1728			 
1728			 
1728			endif 
1728			;prom_c2b: db "Select Storage Bank",0 
1728 .. 00		prom_c4: db "Settings",0 
1731 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
174c .. 00		prom_m4b:   db "Monitor",0 
1754 .. 00		prom_c1: db "Hardware Diags",0 
1763			 
1763			 
1763			if STARTUP_V2 
1763			prom_c9: db "Create Startup Files",0 
1763			endif 
1763			 
1763 .. 00		prom_notav:    db "Feature not available",0 
1779 .. 00		prom_empty:    db "",0 
177a			 
177a			; eof 
177a			 
# End of file firmware_prompts.asm
177a			  
177a			  
177a			; eof  
177a			  
# End of file firmware.asm
177a			 
177a			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
177a			;if BASE_KEV  
177a			;baseram: equ 08000h 
177a			;endif 
177a			 
177a			;if BASE_SC114 
177a			;baseram:     equ    endofcode 
177a			;endif 
177a			 
177a			 
177a			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
177a			 
177a			; start system 
177a			 
177a			coldstart: 
177a				; set sp 
177a				; di/ei 
177a			 
177a f3				di 
177b 31 00 f0			ld sp, tos 
177e cd 39 64			call init_nmi 
1781			;	ei 
1781			 
1781				; init spinner 
1781 3e 00			ld a,0 
1783 32 c6 eb			ld (display_active), a 
1786			 
1786				; disable breakpoint by default 
1786			 
1786				;ld a,'*' 
1786			;	ld a,' ' 
1786			;	ld (os_view_disable),a 
1786			 
1786				; set break point vector as new break point on or off 
1786 cd 09 15			call bp_off 
1789			 
1789				; init hardware 
1789			 
1789				; init keyboard and screen hardware 
1789			 
1789 cd 1b 01			call hardware_init 
178c			 
178c			 
178c cd f1 0a			call delay1s 
178f 3e 58			ld a, display_row_3+8 
1791 11 03 01			ld de, buildtime 
1794 cd cc 0b			call str_at_display 
1797 cd dc 0b			call update_display 
179a			 
179a cd f1 0a			call delay1s 
179d cd f1 0a			call delay1s 
17a0 cd f1 0a			call delay1s 
17a3			 
17a3				; detect if any keys are held down to enable breakpoints at start up 
17a3			 
17a3 cd 43 65			call cin  
17a6 fe 00			cp 0 
17a8 28 03			jr z, .nokeys 
17aa			 
17aa				;call hardware_diags 
17aa cd 67 13			call config 
17ad			 
17ad			;	ld de, .bpen 
17ad			;	ld a, display_row_4 
17ad			;	call str_at_display 
17ad			;	call update_display 
17ad			; 
17ad			;	ld a,0 
17ad			;	ld (os_view_disable),a 
17ad			; 
17ad			;.bpwait: 
17ad			;	call cin 
17ad			;	cp 0 
17ad			;	jr z, .bpwait 
17ad			;	jr .nokeys 
17ad			; 
17ad			; 
17ad			;.bpen:  db "Break points enabled!",0 
17ad			 
17ad			 
17ad			 
17ad			 
17ad			 
17ad			 
17ad			.nokeys: 
17ad			 
17ad			 
17ad				 
17ad			 
17ad			;jp  testkey 
17ad			 
17ad			;call storage_get_block_0 
17ad			; 
17ad			;ld hl, 0 
17ad			;ld de, store_page 
17ad			;call storage_read_block 
17ad			 
17ad				 
17ad			;ld hl, 10 
17ad			;ld de, store_page 
17ad			;call storage_read_block 
17ad			 
17ad			 
17ad			 
17ad			 
17ad			 
17ad			;stop:	nop 
17ad			;	jp stop 
17ad			 
17ad			 
17ad			 
17ad			main: 
17ad cd b9 0b			call clear_display 
17b0 cd dc 0b			call update_display 
17b3			 
17b3			 
17b3			 
17b3			;	call testlcd 
17b3			 
17b3			 
17b3			 
17b3 cd e4 1e			call forth_init 
17b6			 
17b6			 
17b6			warmstart: 
17b6 cd ba 1e			call forth_warmstart 
17b9			 
17b9				; run startup word load 
17b9			        ; TODO prevent this running at warmstart after crash  
17b9			 
17b9				if STARTUP_ENABLE 
17b9			 
17b9					if STARTUP_V1 
17b9			 
17b9						if STORAGE_SE 
17b9							call forth_autoload 
17b9						endif 
17b9 cd 89 63					call forth_startup 
17bc					endif 
17bc			 
17bc					if STARTUP_V2 
17bc			 
17bc						if STORAGE_SE 
17bc							call forth_autoload 
17bc						else 
17bc							call forth_startup 
17bc						endif 
17bc			 
17bc			 
17bc					endif 
17bc			 
17bc				endif 
17bc			 
17bc				; show free memory after boot 
17bc 11 48 18			ld de, freeram 
17bf 3e 00			ld a, display_row_1 
17c1 cd cc 0b			call str_at_display 
17c4			 
17c4				; get current heap start after loading any uwords 
17c4			 
17c4				;ld de, (os_last_new_uword) 
17c4				;ex de, hl 
17c4			 
17c4			; Or use heap_size word???? 
17c4				;ld hl, heap_end 
17c4				;ld hl, heap_size 
17c4				;ld de, topusermem 
17c4				;ld de, heap_start 
17c4 ed 5b 66 65			ld de, (free_list )      
17c8 21 9c e2				ld hl, heap_end 
17cb ed 52			sbc hl, de 
17cd				;push hl 
17cd				;ld a,h	         	 
17cd				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
17cd				;call hexout 
17cd			   	;pop hl 
17cd			; 
17cd			;	ld a,l 
17cd			;	ld hl, os_word_scratch+2 
17cd			;	call hexout 
17cd			;	ld hl, os_word_scratch+4 
17cd			;	ld a, 0 
17cd			;	ld (hl),a 
17cd eb				ex de, hl 
17ce 21 c6 e5			ld hl, os_word_scratch 
17d1 cd 08 11			call uitoa_16 
17d4			 
17d4			 
17d4 11 c6 e5			ld de, os_word_scratch 
17d7 3e 0d			ld a, display_row_1 + 13 
17d9 cd cc 0b			call str_at_display 
17dc cd dc 0b			call update_display 
17df			 
17df			 
17df				;call demo 
17df			 
17df			 
17df				; init scratch input area for cli commands 
17df			 
17df 21 e8 e5			ld hl, os_cli_cmd 
17e2 3e 00			ld a,0 
17e4 77				ld (hl),a 
17e5 23				inc hl 
17e6 77				ld (hl),a 
17e7			 
17e7 3e 00			ld a,0 
17e9 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
17ec			 
17ec 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
17ef 32 e5 e5			ld (os_cur_ptr+1),a	 
17f2			 
17f2 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
17f5 32 c7 e5			ld (os_word_scratch+1),a	 
17f8				 
17f8			 
17f8				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17f8 21 e8 e5			ld hl, os_cli_cmd 
17fb			 
17fb 3e 00			ld a, 0		 ; init cli input 
17fd 77				ld (hl), a 
17fe 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1800			cli: 
1800				; show cli prompt 
1800				;push af 
1800				;ld a, 0 
1800				;ld de, prompt 
1800				;call str_at_display 
1800			 
1800				;call update_display 
1800				;pop af 
1800				;inc a 
1800				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1800 0e 00			ld c, 0 
1802 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1804 1e 28			ld e, 40 
1806			 
1806 21 e8 e5			ld hl, os_cli_cmd 
1809			 
1809				STACKFRAME OFF $fefe $9f9f 
1809				if DEBUG_STACK_IMB 
1809					if OFF 
1809						exx 
1809						ld de, $fefe 
1809						ld a, d 
1809						ld hl, curframe 
1809						call hexout 
1809						ld a, e 
1809						ld hl, curframe+2 
1809						call hexout 
1809						ld hl, $fefe 
1809						push hl 
1809						ld hl, $9f9f 
1809						push hl 
1809						exx 
1809					endif 
1809				endif 
1809			endm 
# End of macro STACKFRAME
1809			 
1809 cd 13 0e			call input_str 
180c			 
180c				STACKFRAMECHK OFF $fefe $9f9f 
180c				if DEBUG_STACK_IMB 
180c					if OFF 
180c						exx 
180c						ld hl, $9f9f 
180c						pop de   ; $9f9f 
180c						call cmp16 
180c						jr nz, .spnosame 
180c						ld hl, $fefe 
180c						pop de   ; $fefe 
180c						call cmp16 
180c						jr z, .spfrsame 
180c						.spnosame: call showsperror 
180c						.spfrsame: nop 
180c						exx 
180c					endif 
180c				endif 
180c			endm 
# End of macro STACKFRAMECHK
180c			 
180c				; copy input to last command 
180c			 
180c 21 e8 e5			ld hl, os_cli_cmd 
180f 11 e7 e6			ld de, os_last_cmd 
1812 01 ff 00			ld bc, 255 
1815 ed b0			ldir 
1817			 
1817				; wipe current buffer 
1817			 
1817			;	ld a, 0 
1817			;	ld hl, os_cli_cmd 
1817			;	ld de, os_cli_cmd+1 
1817			;	ld bc, 254 
1817			;	ldir 
1817				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1817			;	call strcpy 
1817			;	ld a, 0 
1817			;	ld (hl), a 
1817			;	inc hl 
1817			;	ld (hl), a 
1817			;	inc hl 
1817			;	ld (hl), a 
1817			 
1817				; switch frame buffer to program  
1817			 
1817 21 10 ed				ld hl, display_fb1 
181a 22 cc eb				ld (display_fb_active), hl 
181d			 
181d			;	nop 
181d				STACKFRAME ON $fbfe $8f9f 
181d				if DEBUG_STACK_IMB 
181d					if ON 
181d						exx 
181d						ld de, $fbfe 
181d						ld a, d 
181d						ld hl, curframe 
181d						call hexout 
181d						ld a, e 
181d						ld hl, curframe+2 
181d						call hexout 
181d						ld hl, $fbfe 
181d						push hl 
181d						ld hl, $8f9f 
181d						push hl 
181d						exx 
181d					endif 
181d				endif 
181d			endm 
# End of macro STACKFRAME
181d				; first time into the parser so pass over the current scratch pad 
181d 21 e8 e5			ld hl,os_cli_cmd 
1820				; tokenise the entered statement(s) in HL 
1820 cd 62 1f			call forthparse 
1823			        ; exec forth statements in top of return stack 
1823 cd a2 1f			call forthexec 
1826				;call forthexec_cleanup 
1826			;	call parsenext 
1826			 
1826				STACKFRAMECHK ON $fbfe $8f9f 
1826				if DEBUG_STACK_IMB 
1826					if ON 
1826						exx 
1826						ld hl, $8f9f 
1826						pop de   ; $8f9f 
1826						call cmp16 
1826						jr nz, .spnosame 
1826						ld hl, $fbfe 
1826						pop de   ; $fbfe 
1826						call cmp16 
1826						jr z, .spfrsame 
1826						.spnosame: call showsperror 
1826						.spfrsame: nop 
1826						exx 
1826					endif 
1826				endif 
1826			endm 
# End of macro STACKFRAMECHK
1826				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1826			 
1826 3e 78			ld a, display_row_4 
1828 11 59 18			ld de, endprog 
182b			 
182b cd dc 0b			call update_display		 
182e			 
182e cd df 1a			call next_page_prompt 
1831			 
1831				; switch frame buffer to cli 
1831			 
1831 21 b1 ed				ld hl, display_fb0 
1834 22 cc eb				ld (display_fb_active), hl 
1837			 
1837			 
1837 cd b9 0b		        call clear_display 
183a cd dc 0b			call update_display		 
183d			 
183d 21 e8 e5			ld hl, os_cli_cmd 
1840			 
1840 3e 00			ld a, 0		 ; init cli input 
1842 77				ld (hl), a 
1843			 
1843				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1843			 
1843				; now on last line 
1843			 
1843				; TODO scroll screen up 
1843			 
1843				; TODO instead just clear screen and place at top of screen 
1843			 
1843			;	ld a, 0 
1843			;	ld (f_cursor_ptr),a 
1843			 
1843				;call clear_display 
1843				;call update_display 
1843			 
1843				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1843 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1845 c3 00 18			jp cli 
1848			 
1848 .. 00		freeram: db "Free bytes: ",0 
1855 ..			asc: db "1A2F" 
1859 .. 00		endprog: db "End prog...",0 
1865			 
1865			testenter2:   
1865 21 f3 e2			ld hl,scratch+50 
1868 22 e4 e5			ld (os_cur_ptr),hl 
186b c3 00 18			jp cli 
186e			 
186e			testenter:  
186e			 
186e 21 55 18			ld hl,asc 
1871			;	ld a,(hl) 
1871			;	call nibble2val 
1871 cd 52 10			call get_byte 
1874			 
1874			 
1874			;	ld a,(hl) 
1874			;	call atohex 
1874			 
1874			;	call fourehexhl 
1874 32 f3 e2			ld (scratch+50),a 
1877			 
1877			 
1877			 
1877 21 57 18			ld hl,asc+2 
187a			;	ld a, (hl) 
187a			;	call nibble2val 
187a cd 52 10			call get_byte 
187d			 
187d			;	call fourehexhl 
187d 32 f5 e2			ld (scratch+52),a 
1880				 
1880 21 f3 e2			ld hl,scratch+50 
1883 22 e4 e5			ld (os_cur_ptr),hl 
1886 c3 00 18			jp cli 
1889			 
1889			enter:	 
1889 3a c5 e2			ld a,(scratch+4) 
188c fe 00			cp 0 
188e 28 0c			jr z, .entercont 
1890				; no, not a null term line so has an address to work out.... 
1890			 
1890 21 c3 e2			ld hl,scratch+2 
1893 cd b2 10			call get_word_hl 
1896			 
1896 22 e4 e5			ld (os_cur_ptr),hl	 
1899 c3 00 18			jp cli 
189c			 
189c			 
189c			.entercont:  
189c			 
189c 21 c3 e2			ld hl, scratch+2 
189f cd 52 10			call get_byte 
18a2			 
18a2 2a e4 e5		   	ld hl,(os_cur_ptr) 
18a5 77					ld (hl),a 
18a6 23					inc hl 
18a7 22 e4 e5				ld (os_cur_ptr),hl 
18aa				 
18aa			; get byte  
18aa			 
18aa			 
18aa c3 00 18			jp cli 
18ad			 
18ad			 
18ad			; basic monitor support 
18ad			 
18ad			monitor: 
18ad				;  
18ad cd b9 0b			call clear_display 
18b0 3e 00			ld a, 0 
18b2 11 01 19			ld de, .monprompt 
18b5 cd cc 0b			call str_at_display 
18b8 cd dc 0b			call update_display 
18bb			 
18bb				; get a monitor command 
18bb			 
18bb 0e 00			ld c, 0     ; entry at top left 
18bd 16 64			ld d, 100   ; max buffer size 
18bf 1e 0f			ld e, 15    ; input scroll area 
18c1 3e 00			ld a, 0     ; init string 
18c3 21 bf e4			ld hl, os_input 
18c6 77				ld (hl), a 
18c7 23				inc hl 
18c8 77				ld (hl), a 
18c9 21 bf e4			ld hl, os_input 
18cc 3e 01			ld a, 1     ; init string 
18ce cd 13 0e			call input_str 
18d1			 
18d1 cd b9 0b		        call clear_display 
18d4 cd dc 0b			call update_display		 
18d7			 
18d7 3a bf e4			ld a, (os_input) 
18da cd 50 11			call toUpper 
18dd fe 48		        cp 'H' 
18df ca 66 19		        jp z, .monhelp 
18e2 fe 44			cp 'D'		; dump 
18e4 ca 99 19			jp z, .mondump	 
18e7 fe 43			cp 'C'		; dump 
18e9 ca b3 19			jp z, .moncdump	 
18ec fe 4d			cp 'M'		; dump 
18ee ca 03 19			jp z, .moneditstart 
18f1 fe 55			cp 'U'		; dump 
18f3 ca 0f 19			jp z, .monedit	 
18f6 fe 47			cp 'G'		; dump 
18f8 ca 8f 19			jp z, .monjump 
18fb fe 51			cp 'Q'		; dump 
18fd c8				ret z	 
18fe			 
18fe			 
18fe				; TODO "S" to access symbol by name and not need the address 
18fe				; TODO "F" to find a string in memory 
18fe			 
18fe c3 ad 18			jp monitor 
1901			 
1901 .. 00		.monprompt: db ">", 0 
1903			 
1903			.moneditstart: 
1903				; get starting address 
1903			 
1903 21 c1 e4			ld hl,os_input+2 
1906 cd b2 10			call get_word_hl 
1909			 
1909 22 e4 e5			ld (os_cur_ptr),hl	 
190c			 
190c c3 ad 18			jp monitor 
190f			 
190f			.monedit: 
190f				; get byte to load 
190f			 
190f 21 c1 e4			ld hl,os_input+2 
1912 cd 52 10			call get_byte 
1915			 
1915				; get address to update 
1915 2a e4 e5			ld hl, (os_cur_ptr) 
1918			 
1918				; update byte 
1918			 
1918 77				ld (hl), a 
1919			 
1919				; move to next address and save it 
1919			 
1919 23				inc hl 
191a 22 e4 e5			ld (os_cur_ptr),hl	 
191d			 
191d c3 ad 18			jp monitor 
1920			 
1920			 
1920 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1934 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1950 .. 00		.monhelptext3:  db "G-Call address",0 
195f .. 00		.monhelptext4:  db "Q-Quit",0 
1966			        
1966			.monhelp: 
1966 3e 00			ld a, display_row_1 
1968 11 20 19		        ld de, .monhelptext1 
196b			 
196b cd cc 0b			call str_at_display 
196e 3e 28			ld a, display_row_2 
1970 11 34 19		        ld de, .monhelptext2 
1973					 
1973 cd cc 0b			call str_at_display 
1976 3e 50			ld a, display_row_3 
1978 11 50 19		        ld de, .monhelptext3 
197b					 
197b cd cc 0b			call str_at_display 
197e 3e 78			ld a, display_row_4 
1980 11 5f 19		        ld de, .monhelptext4 
1983 cd cc 0b			call str_at_display 
1986			 
1986 cd dc 0b			call update_display		 
1989			 
1989 cd df 1a			call next_page_prompt 
198c c3 ad 18			jp monitor 
198f			 
198f			.monjump:    
198f 21 c1 e4			ld hl,os_input+2 
1992 cd b2 10			call get_word_hl 
1995			 
1995 e9				jp (hl) 
1996 c3 ad 18			jp monitor 
1999			 
1999			.mondump:    
1999 21 c1 e4			ld hl,os_input+2 
199c cd b2 10			call get_word_hl 
199f			 
199f 22 e4 e5			ld (os_cur_ptr),hl	 
19a2 cd e7 19			call dumpcont 
19a5 3e 78			ld a, display_row_4 
19a7 11 59 18			ld de, endprog 
19aa			 
19aa cd dc 0b			call update_display		 
19ad			 
19ad cd df 1a			call next_page_prompt 
19b0 c3 ad 18			jp monitor 
19b3			.moncdump: 
19b3 cd e7 19			call dumpcont 
19b6 3e 78			ld a, display_row_4 
19b8 11 59 18			ld de, endprog 
19bb			 
19bb cd dc 0b			call update_display		 
19be			 
19be cd df 1a			call next_page_prompt 
19c1 c3 ad 18			jp monitor 
19c4			 
19c4			 
19c4			; TODO symbol access  
19c4			 
19c4			.symbols:     ;; A list of symbols that can be called up  
19c4 b1 ed			dw display_fb0 
19c6 .. 00			db "fb0",0  
19ca 7a ea		     	dw store_page 
19cc .. 00			db "store_page",0 
19d7			 
19d7			 
19d7			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
19d7			 
19d7 3a c2 e2			ld a,(scratch+1) 
19da fe 00			cp 0 
19dc 28 09			jr z, dumpcont 
19de			 
19de				; no, not a null term line so has an address to work out.... 
19de			 
19de 21 c3 e2			ld hl,scratch+2 
19e1 cd b2 10			call get_word_hl 
19e4			 
19e4 22 e4 e5			ld (os_cur_ptr),hl	 
19e7			 
19e7			 
19e7			 
19e7			dumpcont: 
19e7			 
19e7				; dump bytes at ptr 
19e7			 
19e7			 
19e7 3e 00			ld a, display_row_1 
19e9 2a cc eb			ld hl, (display_fb_active) 
19ec cd e6 0d			call addatohl 
19ef cd 17 1a			call .dumpbyterow 
19f2			 
19f2 3e 28			ld a, display_row_2 
19f4 2a cc eb			ld hl, (display_fb_active) 
19f7 cd e6 0d			call addatohl 
19fa cd 17 1a			call .dumpbyterow 
19fd			 
19fd			 
19fd 3e 50			ld a, display_row_3 
19ff 2a cc eb			ld hl, (display_fb_active) 
1a02 cd e6 0d			call addatohl 
1a05 cd 17 1a			call .dumpbyterow 
1a08			 
1a08 3e 78			ld a, display_row_4 
1a0a 2a cc eb			ld hl, (display_fb_active) 
1a0d cd e6 0d			call addatohl 
1a10 cd 17 1a			call .dumpbyterow 
1a13			 
1a13 cd dc 0b			call update_display 
1a16			;		jp cli 
1a16 c9				ret 
1a17			 
1a17			.dumpbyterow: 
1a17			 
1a17				;push af 
1a17			 
1a17 e5				push hl 
1a18			 
1a18				; calc where to poke the ascii 
1a18			if display_cols == 20 
1a18				ld a, 16 
1a18			else 
1a18 3e 1f			ld a, 31 
1a1a			endif 
1a1a			 
1a1a cd e6 0d			call addatohl 
1a1d 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
1a20			 
1a20			 
1a20			; display decoding address 
1a20 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a23			 
1a23 7c				ld a,h 
1a24 e1				pop hl 
1a25 e5				push hl 
1a26			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1a26 cd fc 0f			call hexout 
1a29 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a2c			 
1a2c 7d				ld a,l 
1a2d e1				pop hl 
1a2e 23				inc hl 
1a2f 23				inc hl 
1a30 e5				push hl 
1a31			;	ld hl, os_word_scratch+2 
1a31 cd fc 0f			call hexout 
1a34 e1				pop hl 
1a35 23				inc hl 
1a36 23				inc hl 
1a37				;ld hl, os_word_scratch+4 
1a37 3e 3a			ld a, ':' 
1a39 77				ld (hl),a 
1a3a 23				inc hl 
1a3b				;ld a, 0 
1a3b				;ld (hl),a 
1a3b				;ld de, os_word_scratch 
1a3b				;pop af 
1a3b				;push af 
1a3b			;		ld a, display_row_2 
1a3b			;		call str_at_display 
1a3b			;		call update_display 
1a3b			 
1a3b			 
1a3b			;pop af 
1a3b			;	add 5 
1a3b			 
1a3b			if display_cols == 20 
1a3b				ld b, 4 
1a3b			else 
1a3b 06 08			ld b, 8 
1a3d			endif	 
1a3d			 
1a3d			.dumpbyte: 
1a3d c5				push bc 
1a3e e5				push hl 
1a3f			 
1a3f			 
1a3f 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a42 7e					ld a,(hl) 
1a43			 
1a43					; poke the ascii to display 
1a43 2a c6 e5				ld hl,(os_word_scratch) 
1a46 77					ld (hl),a 
1a47 23					inc hl 
1a48 22 c6 e5				ld (os_word_scratch),hl 
1a4b			 
1a4b					 
1a4b			 
1a4b			 
1a4b e1					pop hl 
1a4c e5					push hl 
1a4d			 
1a4d cd fc 0f				call hexout 
1a50			 
1a50					 
1a50 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a53 23				inc hl 
1a54 22 e4 e5		   	ld (os_cur_ptr),hl 
1a57			 
1a57 e1					pop hl 
1a58 23					inc hl 
1a59 23					inc hl 
1a5a 23					inc hl 
1a5b			 
1a5b			 
1a5b			 
1a5b					;ld a,0 
1a5b					;ld (os_word_scratch+2),a 
1a5b					;pop af 
1a5b					;push af 
1a5b			 
1a5b					;ld de, os_word_scratch 
1a5b					;call str_at_display 
1a5b			;		call update_display 
1a5b			;		pop af 
1a5b c1					pop bc 
1a5c c6 03				add 3 
1a5e 10 dd			djnz .dumpbyte 
1a60			 
1a60				 
1a60			 
1a60 c9				ret 
1a61			 
1a61			jump:	 
1a61			 
1a61 21 c3 e2			ld hl,scratch+2 
1a64 cd b2 10			call get_word_hl 
1a67				;ld hl,(scratch+2) 
1a67				;call fourehexhl 
1a67			 
1a67 22 e4 e5			ld (os_cur_ptr),hl	 
1a6a			 
1a6a e9				jp (hl) 
1a6b			 
1a6b			 
1a6b			 
1a6b			; TODO implement a basic monitor mode to start with 
1a6b			 
1a6b			 
1a6b			 
1a6b			 
1a6b			 
1a6b			 
1a6b			 
1a6b			 
1a6b			 
1a6b			; testing and demo code during development 
1a6b			 
1a6b			 
1a6b .. 00		str1: db "Enter some text...",0 
1a7e .. 00		clear: db "                    ",0 
1a93			 
1a93			demo: 
1a93			 
1a93			 
1a93			 
1a93			;	call update_display 
1a93			 
1a93				; init scratch input area for testing 
1a93 21 c1 e2			ld hl, scratch	 
1a96 3e 00			ld a,0 
1a98 77				ld (hl),a 
1a99			 
1a99			 
1a99 3e 28		            LD   A, display_row_2 
1a9b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a9b 11 6b 1a		            LD   DE, str1 
1a9e cd cc 0b			call str_at_display 
1aa1			 
1aa1			;            CALL fLCD_Str       ;Display string pointed to by DE 
1aa1			cloop:	 
1aa1 3e 50		            LD   A, display_row_3 
1aa3			;            CALL fLCD_Pos       ;Position cursor to location in A 
1aa3 11 7e 1a		            LD   DE, clear 
1aa6			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1aa6 cd cc 0b				call str_at_display 
1aa9 3e 78			ld a, display_row_4 
1aab 11 db 1a			ld de, prompt 
1aae			 
1aae cd cc 0b				call str_at_display 
1ab1 cd dc 0b			call update_display 
1ab4			 
1ab4 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1ab6 16 0a			ld d, 10 
1ab8 21 c1 e2			ld hl, scratch	 
1abb cd 13 0e			call input_str 
1abe			 
1abe			;	call clear_display 
1abe			;'	call update_display 
1abe			 
1abe 3e 00		            LD   A, display_row_1 
1ac0			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ac0 11 7e 1a		            LD   DE, clear 
1ac3 cd cc 0b				call str_at_display 
1ac6			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ac6 3e 00		            LD   A, display_row_1 
1ac8			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ac8 11 c1 e2		            LD   DE, scratch 
1acb			;            CALL fLCD_Str       ;Display string pointed to by DE 
1acb cd cc 0b				call str_at_display 
1ace cd dc 0b			call update_display 
1ad1			 
1ad1 3e 00				ld a,0 
1ad3 21 c1 e2			ld hl, scratch 
1ad6 77				ld (hl),a 
1ad7			 
1ad7 00				nop 
1ad8 c3 a1 1a			jp cloop 
1adb			 
1adb			 
1adb			 
1adb			; OS Prompt 
1adb			 
1adb .. 00		prompt: db ">",0 
1add .. 00		endprg: db "?",0 
1adf			 
1adf			 
1adf			; handy next page prompt 
1adf			next_page_prompt: 
1adf e5				push hl 
1ae0 d5				push de 
1ae1 f5				push af 
1ae2 c5				push bc 
1ae3			 
1ae3 3e 9f			ld a,display_row_4 + display_cols - 1 
1ae5 11 dd 1a		        ld de, endprg 
1ae8 cd cc 0b			call str_at_display 
1aeb cd dc 0b			call update_display 
1aee cd 3b 65			call cin_wait 
1af1 c1				pop bc 
1af2 f1				pop af 
1af3 d1				pop de 
1af4 e1				pop hl 
1af5			 
1af5			 
1af5 c9				ret 
1af6			 
1af6			 
1af6			; forth parser 
1af6			 
1af6			; My forth kernel 
1af6			include "forth_kernel.asm" 
1af6			; 
1af6			; kernel to the forth OS 
1af6			 
1af6			DS_TYPE_STR: equ 1     ; string type 
1af6			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1af6			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1af6			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1af6			 
1af6			FORTH_PARSEV1: equ 0 
1af6			FORTH_PARSEV2: equ 0 
1af6			FORTH_PARSEV3: equ 0 
1af6			FORTH_PARSEV4: equ 0 
1af6			FORTH_PARSEV5: equ 1 
1af6			 
1af6			;if FORTH_PARSEV5 
1af6			;	FORTH_END_BUFFER: equ 0 
1af6			;else 
1af6			FORTH_END_BUFFER: equ 127 
1af6			;endif 
1af6			 
1af6			FORTH_TRUE: equ 1 
1af6			FORTH_FALSE: equ 0 
1af6			 
1af6			if FORTH_PARSEV4 
1af6			include "forth_stackops.asm" 
1af6			endif 
1af6			 
1af6			if FORTH_PARSEV5 
1af6			include "forth_stackopsv5.asm" 
1af6			 
1af6			; Stack operations for v5 parser on wards 
1af6			; * DATA stack 
1af6			; * LOOP stack 
1af6			; * RETURN stack 
1af6			 
1af6			 
1af6			 
1af6			FORTH_CHK_DSP_UNDER: macro 
1af6				push hl 
1af6				push de 
1af6				ld hl,(cli_data_sp) 
1af6				ld de, cli_data_stack 
1af6				call cmp16 
1af6				jp c, fault_dsp_under 
1af6				pop de 
1af6				pop hl 
1af6				endm 
1af6			 
1af6			 
1af6			FORTH_CHK_RSP_UNDER: macro 
1af6				push hl 
1af6				push de 
1af6				ld hl,(cli_ret_sp) 
1af6				ld de, cli_ret_stack 
1af6				call cmp16 
1af6				jp c, fault_rsp_under 
1af6				pop de 
1af6				pop hl 
1af6				endm 
1af6			 
1af6			FORTH_CHK_LOOP_UNDER: macro 
1af6				push hl 
1af6				push de 
1af6				ld hl,(cli_loop_sp) 
1af6				ld de, cli_loop_stack 
1af6				call cmp16 
1af6				jp c, fault_loop_under 
1af6				pop de 
1af6				pop hl 
1af6				endm 
1af6			 
1af6			FORTH_ERR_TOS_NOTSTR: macro 
1af6				; TOSO might need more for checks when used 
1af6				push af 
1af6				ld a,(hl) 
1af6				cp DS_TYPE_STR 
1af6				jp nz, type_faultn   
1af6				pop af 
1af6				endm 
1af6			 
1af6			FORTH_ERR_TOS_NOTNUM: macro 
1af6				push af 
1af6				ld a,(hl) 
1af6				cp DS_TYPE_INUM 
1af6				jp nz, type_faultn   
1af6				pop af 
1af6				endm 
1af6			 
1af6			 
1af6			; increase data stack pointer and save hl to it 
1af6				 
1af6			FORTH_DSP_NEXT: macro 
1af6				call macro_forth_dsp_next 
1af6				endm 
1af6			 
1af6			 
1af6			macro_forth_dsp_next: 
1af6				if DEBUG_FORTH_STACK_GUARD 
1af6 cd 6a 61				call check_stacks 
1af9				endif 
1af9 e5				push hl 
1afa d5				push de 
1afb eb				ex de,hl 
1afc 2a ee e9			ld hl,(cli_data_sp) 
1aff 23				inc hl 
1b00 23				inc hl 
1b01			 
1b01			; PARSEV5 
1b01 23				inc hl 
1b02 22 ee e9			ld (cli_data_sp),hl 
1b05 73				ld (hl), e 
1b06 23				inc hl 
1b07 72				ld (hl), d 
1b08 d1				pop de 
1b09 e1				pop hl 
1b0a				if DEBUG_FORTH_STACK_GUARD 
1b0a cd 6a 61				call check_stacks 
1b0d				endif 
1b0d c9				ret 
1b0e			 
1b0e			 
1b0e			; increase ret stack pointer and save hl to it 
1b0e				 
1b0e			FORTH_RSP_NEXT: macro 
1b0e				call macro_forth_rsp_next 
1b0e				endm 
1b0e			 
1b0e			macro_forth_rsp_next: 
1b0e				if DEBUG_FORTH_STACK_GUARD 
1b0e cd 6a 61				call check_stacks 
1b11				endif 
1b11 e5				push hl 
1b12 d5				push de 
1b13 eb				ex de,hl 
1b14 2a f2 e9			ld hl,(cli_ret_sp) 
1b17 23				inc hl 
1b18 23				inc hl 
1b19 22 f2 e9			ld (cli_ret_sp),hl 
1b1c 73				ld (hl), e 
1b1d 23				inc hl 
1b1e 72				ld (hl), d 
1b1f d1				pop de 
1b20 e1				pop hl 
1b21				if DEBUG_FORTH_STACK_GUARD 
1b21 cd 6a 61				call check_stacks 
1b24				endif 
1b24 c9				ret 
1b25			 
1b25			; get current ret stack pointer and save to hl  
1b25				 
1b25			FORTH_RSP_TOS: macro 
1b25				call macro_forth_rsp_tos 
1b25				endm 
1b25			 
1b25			macro_forth_rsp_tos: 
1b25				;push de 
1b25 2a f2 e9			ld hl,(cli_ret_sp) 
1b28 cd 60 1b			call loadhlptrtohl 
1b2b				;ld e, (hl) 
1b2b				;inc hl 
1b2b				;ld d, (hl) 
1b2b				;ex de, hl 
1b2b					if DEBUG_FORTH_WORDS 
1b2b			;			DMARK "RST" 
1b2b						CALLMONITOR 
1b2b cd 6f ee			call debug_vector  
1b2e				endm  
# End of macro CALLMONITOR
1b2e					endif 
1b2e				;pop de 
1b2e c9				ret 
1b2f			 
1b2f			; pop ret stack pointer 
1b2f				 
1b2f			FORTH_RSP_POP: macro 
1b2f				call macro_forth_rsp_pop 
1b2f				endm 
1b2f			 
1b2f			 
1b2f			macro_forth_rsp_pop: 
1b2f				if DEBUG_FORTH_STACK_GUARD 
1b2f			;		DMARK "RPP" 
1b2f cd 6a 61				call check_stacks 
1b32					FORTH_CHK_RSP_UNDER 
1b32 e5				push hl 
1b33 d5				push de 
1b34 2a f2 e9			ld hl,(cli_ret_sp) 
1b37 11 ac e9			ld de, cli_ret_stack 
1b3a cd 04 0e			call cmp16 
1b3d da 7e 62			jp c, fault_rsp_under 
1b40 d1				pop de 
1b41 e1				pop hl 
1b42				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b42				endif 
1b42 e5				push hl 
1b43 2a f2 e9			ld hl,(cli_ret_sp) 
1b46			 
1b46			 
1b46				if FORTH_ENABLE_FREE 
1b46			 
1b46					; get pointer 
1b46			 
1b46					push de 
1b46					push hl 
1b46			 
1b46					ld e, (hl) 
1b46					inc hl 
1b46					ld d, (hl) 
1b46			 
1b46					ex de, hl 
1b46					call free 
1b46			 
1b46					pop hl 
1b46					pop de 
1b46			 
1b46			 
1b46				endif 
1b46			 
1b46			 
1b46 2b				dec hl 
1b47 2b				dec hl 
1b48 22 f2 e9			ld (cli_ret_sp), hl 
1b4b				; do stack underflow checks 
1b4b e1				pop hl 
1b4c				if DEBUG_FORTH_STACK_GUARD 
1b4c cd 6a 61				call check_stacks 
1b4f					FORTH_CHK_RSP_UNDER 
1b4f e5				push hl 
1b50 d5				push de 
1b51 2a f2 e9			ld hl,(cli_ret_sp) 
1b54 11 ac e9			ld de, cli_ret_stack 
1b57 cd 04 0e			call cmp16 
1b5a da 7e 62			jp c, fault_rsp_under 
1b5d d1				pop de 
1b5e e1				pop hl 
1b5f				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b5f				endif 
1b5f c9				ret 
1b60			 
1b60			 
1b60			 
1b60			; routine to load word pointed to by hl into hl 
1b60			 
1b60			loadhlptrtohl: 
1b60			 
1b60 d5				push de 
1b61 5e				ld e, (hl) 
1b62 23				inc hl 
1b63 56				ld d, (hl) 
1b64 eb				ex de, hl 
1b65 d1				pop de 
1b66			 
1b66 c9				ret 
1b67			 
1b67			 
1b67			 
1b67			 
1b67			 
1b67			; push a number held in HL onto the data stack 
1b67			; entry point for pushing a value when already in hl used in function above 
1b67			 
1b67			forth_push_numhl: 
1b67			 
1b67 e5				push hl    ; save value to push 
1b68			 
1b68			if DEBUG_FORTH_PUSH 
1b68				; see if disabled 
1b68			 
1b68			 
1b68 f5				push af 
1b69 3a 6f ee			ld a,(debug_vector) 
1b6c fe c9			cp $c9   ; ret 
1b6e			;	ld a, (os_view_disable) 
1b6e			;	cp '*' 
1b6e 28 34			jr z, .pskip2 
1b70 e5				push hl 
1b71 e5			push hl 
1b72 cd b9 0b			call clear_display 
1b75 e1			pop hl 
1b76 7c				ld a,h 
1b77 21 c6 e5			ld hl, os_word_scratch 
1b7a cd fc 0f			call hexout 
1b7d e1				pop hl 
1b7e 7d				ld a,l 
1b7f 21 c8 e5			ld hl, os_word_scratch+2 
1b82 cd fc 0f			call hexout 
1b85			 
1b85 21 ca e5			ld hl, os_word_scratch+4 
1b88 3e 00			ld a,0 
1b8a 77				ld (hl),a 
1b8b 11 c6 e5			ld de,os_word_scratch 
1b8e 3e 28				ld a, display_row_2 
1b90 cd cc 0b				call str_at_display 
1b93 11 7c 4c			ld de, .push_num 
1b96 3e 00			ld a, display_row_1 
1b98			 
1b98 cd cc 0b				call str_at_display 
1b9b			 
1b9b			 
1b9b cd dc 0b			call update_display 
1b9e cd f1 0a			call delay1s 
1ba1 cd f1 0a			call delay1s 
1ba4			.pskip2:  
1ba4			 
1ba4 f1				pop af 
1ba5			endif	 
1ba5			 
1ba5			 
1ba5				FORTH_DSP_NEXT 
1ba5 cd f6 1a			call macro_forth_dsp_next 
1ba8				endm 
# End of macro FORTH_DSP_NEXT
1ba8			 
1ba8 2a ee e9			ld hl, (cli_data_sp) 
1bab			 
1bab				; save item type 
1bab 3e 02			ld a,  DS_TYPE_INUM 
1bad 77				ld (hl), a 
1bae 23				inc hl 
1baf			 
1baf				; get word off stack 
1baf d1				pop de 
1bb0 7b				ld a,e 
1bb1 77				ld (hl), a 
1bb2 23				inc hl 
1bb3 7a				ld a,d 
1bb4 77				ld (hl), a 
1bb5			 
1bb5			if DEBUG_FORTH_PUSH 
1bb5 2b				dec hl 
1bb6 2b				dec hl 
1bb7 2b				dec hl 
1bb8						DMARK "PH5" 
1bb8 f5				push af  
1bb9 3a cd 1b			ld a, (.dmark)  
1bbc 32 6b ee			ld (debug_mark),a  
1bbf 3a ce 1b			ld a, (.dmark+1)  
1bc2 32 6c ee			ld (debug_mark+1),a  
1bc5 3a cf 1b			ld a, (.dmark+2)  
1bc8 32 6d ee			ld (debug_mark+2),a  
1bcb 18 03			jr .pastdmark  
1bcd ..			.dmark: db "PH5"  
1bd0 f1			.pastdmark: pop af  
1bd1			endm  
# End of macro DMARK
1bd1				CALLMONITOR 
1bd1 cd 6f ee			call debug_vector  
1bd4				endm  
# End of macro CALLMONITOR
1bd4			endif	 
1bd4			 
1bd4 c9				ret 
1bd5			 
1bd5			 
1bd5			; Push a string to stack pointed to by hl 
1bd5			 
1bd5			forth_push_str: 
1bd5			 
1bd5			if DEBUG_FORTH_PUSH 
1bd5						DMARK "PSQ" 
1bd5 f5				push af  
1bd6 3a ea 1b			ld a, (.dmark)  
1bd9 32 6b ee			ld (debug_mark),a  
1bdc 3a eb 1b			ld a, (.dmark+1)  
1bdf 32 6c ee			ld (debug_mark+1),a  
1be2 3a ec 1b			ld a, (.dmark+2)  
1be5 32 6d ee			ld (debug_mark+2),a  
1be8 18 03			jr .pastdmark  
1bea ..			.dmark: db "PSQ"  
1bed f1			.pastdmark: pop af  
1bee			endm  
# End of macro DMARK
1bee				CALLMONITOR 
1bee cd 6f ee			call debug_vector  
1bf1				endm  
# End of macro CALLMONITOR
1bf1			endif	 
1bf1			    
1bf1 e5				push hl 
1bf2 e5				push hl 
1bf3			 
1bf3			;	ld a, 0   ; find end of string 
1bf3 cd 59 11			call strlenz 
1bf6			if DEBUG_FORTH_PUSH 
1bf6						DMARK "PQ2" 
1bf6 f5				push af  
1bf7 3a 0b 1c			ld a, (.dmark)  
1bfa 32 6b ee			ld (debug_mark),a  
1bfd 3a 0c 1c			ld a, (.dmark+1)  
1c00 32 6c ee			ld (debug_mark+1),a  
1c03 3a 0d 1c			ld a, (.dmark+2)  
1c06 32 6d ee			ld (debug_mark+2),a  
1c09 18 03			jr .pastdmark  
1c0b ..			.dmark: db "PQ2"  
1c0e f1			.pastdmark: pop af  
1c0f			endm  
# End of macro DMARK
1c0f				CALLMONITOR 
1c0f cd 6f ee			call debug_vector  
1c12				endm  
# End of macro CALLMONITOR
1c12			endif	 
1c12 eb				ex de, hl 
1c13 e1				pop hl   ; get ptr to start of string 
1c14			if DEBUG_FORTH_PUSH 
1c14						DMARK "PQ3" 
1c14 f5				push af  
1c15 3a 29 1c			ld a, (.dmark)  
1c18 32 6b ee			ld (debug_mark),a  
1c1b 3a 2a 1c			ld a, (.dmark+1)  
1c1e 32 6c ee			ld (debug_mark+1),a  
1c21 3a 2b 1c			ld a, (.dmark+2)  
1c24 32 6d ee			ld (debug_mark+2),a  
1c27 18 03			jr .pastdmark  
1c29 ..			.dmark: db "PQ3"  
1c2c f1			.pastdmark: pop af  
1c2d			endm  
# End of macro DMARK
1c2d				CALLMONITOR 
1c2d cd 6f ee			call debug_vector  
1c30				endm  
# End of macro CALLMONITOR
1c30			endif	 
1c30 19				add hl,de 
1c31			if DEBUG_FORTH_PUSH 
1c31						DMARK "PQE" 
1c31 f5				push af  
1c32 3a 46 1c			ld a, (.dmark)  
1c35 32 6b ee			ld (debug_mark),a  
1c38 3a 47 1c			ld a, (.dmark+1)  
1c3b 32 6c ee			ld (debug_mark+1),a  
1c3e 3a 48 1c			ld a, (.dmark+2)  
1c41 32 6d ee			ld (debug_mark+2),a  
1c44 18 03			jr .pastdmark  
1c46 ..			.dmark: db "PQE"  
1c49 f1			.pastdmark: pop af  
1c4a			endm  
# End of macro DMARK
1c4a				CALLMONITOR 
1c4a cd 6f ee			call debug_vector  
1c4d				endm  
# End of macro CALLMONITOR
1c4d			endif	 
1c4d			 
1c4d 2b				dec hl    ; see if there is an optional trailing double quote 
1c4e 7e				ld a,(hl) 
1c4f fe 22			cp '"' 
1c51 20 03			jr nz, .strnoq 
1c53 3e 00			ld a, 0      ; get rid of double quote 
1c55 77				ld (hl), a 
1c56 23			.strnoq: inc hl 
1c57			 
1c57 3e 00			ld a, 0 
1c59 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1c5a			 
1c5a 13				inc de ; add one for the type string 
1c5b 13				inc de ; add one for null term??? 
1c5c			 
1c5c				; tos is get string pointer again 
1c5c				; de contains space to allocate 
1c5c				 
1c5c d5				push de 
1c5d			 
1c5d eb				ex de, hl 
1c5e			 
1c5e				;push af 
1c5e			 
1c5e			if DEBUG_FORTH_PUSH 
1c5e						DMARK "PHm" 
1c5e f5				push af  
1c5f 3a 73 1c			ld a, (.dmark)  
1c62 32 6b ee			ld (debug_mark),a  
1c65 3a 74 1c			ld a, (.dmark+1)  
1c68 32 6c ee			ld (debug_mark+1),a  
1c6b 3a 75 1c			ld a, (.dmark+2)  
1c6e 32 6d ee			ld (debug_mark+2),a  
1c71 18 03			jr .pastdmark  
1c73 ..			.dmark: db "PHm"  
1c76 f1			.pastdmark: pop af  
1c77			endm  
# End of macro DMARK
1c77				CALLMONITOR 
1c77 cd 6f ee			call debug_vector  
1c7a				endm  
# End of macro CALLMONITOR
1c7a			endif	 
1c7a cd ce 11			call malloc	; on ret hl now contains allocated memory 
1c7d				if DEBUG_FORTH_MALLOC_GUARD 
1c7d cc d4 4c				call z,malloc_error 
1c80				endif 
1c80			 
1c80				 
1c80 c1				pop bc    ; get length 
1c81 d1				pop de   ;  get string start    
1c82			 
1c82				; hl has destination from malloc 
1c82			 
1c82 eb				ex de, hl    ; prep for ldir 
1c83			 
1c83 d5				push de   ; save malloc area for DSP later 
1c84				;push hl   ; save malloc area for DSP later 
1c84			 
1c84			if DEBUG_FORTH_PUSH 
1c84						DMARK "PHc" 
1c84 f5				push af  
1c85 3a 99 1c			ld a, (.dmark)  
1c88 32 6b ee			ld (debug_mark),a  
1c8b 3a 9a 1c			ld a, (.dmark+1)  
1c8e 32 6c ee			ld (debug_mark+1),a  
1c91 3a 9b 1c			ld a, (.dmark+2)  
1c94 32 6d ee			ld (debug_mark+2),a  
1c97 18 03			jr .pastdmark  
1c99 ..			.dmark: db "PHc"  
1c9c f1			.pastdmark: pop af  
1c9d			endm  
# End of macro DMARK
1c9d				CALLMONITOR 
1c9d cd 6f ee			call debug_vector  
1ca0				endm  
# End of macro CALLMONITOR
1ca0			endif	 
1ca0			 
1ca0			 
1ca0 ed b0			ldir 
1ca2			 
1ca2			 
1ca2				; push malloc to data stack     macro?????  
1ca2			 
1ca2				FORTH_DSP_NEXT 
1ca2 cd f6 1a			call macro_forth_dsp_next 
1ca5				endm 
# End of macro FORTH_DSP_NEXT
1ca5			 
1ca5				; save value and type 
1ca5			 
1ca5 2a ee e9			ld hl, (cli_data_sp) 
1ca8			 
1ca8				; save item type 
1ca8 3e 01			ld a,  DS_TYPE_STR 
1caa 77				ld (hl), a 
1cab 23				inc hl 
1cac			 
1cac				; get malloc word off stack 
1cac d1				pop de 
1cad 73				ld (hl), e 
1cae 23				inc hl 
1caf 72				ld (hl), d 
1cb0			 
1cb0			 
1cb0			 
1cb0			if DEBUG_FORTH_PUSH 
1cb0 2a ee e9			ld hl, (cli_data_sp) 
1cb3						DMARK "PHS" 
1cb3 f5				push af  
1cb4 3a c8 1c			ld a, (.dmark)  
1cb7 32 6b ee			ld (debug_mark),a  
1cba 3a c9 1c			ld a, (.dmark+1)  
1cbd 32 6c ee			ld (debug_mark+1),a  
1cc0 3a ca 1c			ld a, (.dmark+2)  
1cc3 32 6d ee			ld (debug_mark+2),a  
1cc6 18 03			jr .pastdmark  
1cc8 ..			.dmark: db "PHS"  
1ccb f1			.pastdmark: pop af  
1ccc			endm  
# End of macro DMARK
1ccc				CALLMONITOR 
1ccc cd 6f ee			call debug_vector  
1ccf				endm  
# End of macro CALLMONITOR
1ccf			;	ex de,hl 
1ccf			endif	 
1ccf				; in case of spaces, skip the ptr past the copied string 
1ccf				;pop af 
1ccf				;ld (cli_origptr),hl 
1ccf			 
1ccf c9				ret 
1cd0			 
1cd0			 
1cd0			 
1cd0			; TODO ascii push input onto stack given hl to start of input 
1cd0			 
1cd0			; identify type 
1cd0			; if starts with a " then a string 
1cd0			; otherwise it is a number 
1cd0			;  
1cd0			; if a string 
1cd0			;     scan for ending " to get length of string to malloc for + 1 
1cd0			;     malloc 
1cd0			;     put pointer to string on stack first byte flags as string 
1cd0			; 
1cd0			; else a number 
1cd0			;    look for number format identifier 
1cd0			;    $xx hex 
1cd0			;    %xxxxx bin 
1cd0			;    xxxxx decimal 
1cd0			;    convert number to 16bit word.  
1cd0			;    malloc word + 1 with flag to identiy as num 
1cd0			;    put pointer to number on stack 
1cd0			;   
1cd0			;  
1cd0			  
1cd0			forth_apush: 
1cd0				; kernel push 
1cd0			 
1cd0			if DEBUG_FORTH_PUSH 
1cd0						DMARK "PSH" 
1cd0 f5				push af  
1cd1 3a e5 1c			ld a, (.dmark)  
1cd4 32 6b ee			ld (debug_mark),a  
1cd7 3a e6 1c			ld a, (.dmark+1)  
1cda 32 6c ee			ld (debug_mark+1),a  
1cdd 3a e7 1c			ld a, (.dmark+2)  
1ce0 32 6d ee			ld (debug_mark+2),a  
1ce3 18 03			jr .pastdmark  
1ce5 ..			.dmark: db "PSH"  
1ce8 f1			.pastdmark: pop af  
1ce9			endm  
# End of macro DMARK
1ce9				CALLMONITOR 
1ce9 cd 6f ee			call debug_vector  
1cec				endm  
# End of macro CALLMONITOR
1cec			endif	 
1cec				; identify input type 
1cec			 
1cec 7e				ld a,(hl) 
1ced fe 22			cp '"' 
1cef 28 0a			jr z, .fapstr 
1cf1 fe 24			cp '$' 
1cf3 ca 1b 1d			jp z, .faphex 
1cf6 fe 25			cp '%' 
1cf8 ca 03 1d			jp z, .fapbin 
1cfb			;	cp 'b' 
1cfb			;	jp z, .fabin 
1cfb				; else decimal 
1cfb			 
1cfb				; TODO do decimal conversion 
1cfb				; decimal is stored as a 16bit word 
1cfb			 
1cfb				; by default everything is a string if type is not detected 
1cfb			.fapstr: ; 
1cfb fe 22			cp '"' 
1cfd 20 01			jr nz, .strnoqu 
1cff 23				inc hl 
1d00			.strnoqu: 
1d00 c3 d5 1b			jp forth_push_str 
1d03			 
1d03			 
1d03			 
1d03			.fapbin:    ; push a binary string.  
1d03 11 00 00			ld de, 0   ; hold a 16bit value 
1d06			 
1d06 23			.fapbinshift:	inc hl  
1d07 7e				ld a,(hl) 
1d08 fe 00			cp 0     ; done scanning  
1d0a 28 0b			jr z, .fapbdone  	; got it in HL so push  
1d0c			 
1d0c				; left shift de 
1d0c eb				ex de, hl	 
1d0d 29				add hl, hl 
1d0e			 
1d0e				; is 1 
1d0e fe 31			cp '1' 
1d10 20 02			jr nz, .binzero 
1d12 cb 4d			bit 1, l 
1d14			.binzero: 
1d14 eb				ex de, hl	 ; save current de 
1d15 18 ef			jr .fapbinshift 
1d17			 
1d17			.fapbdone: 
1d17 eb				ex de, hl 
1d18 c3 67 1b			jp forth_push_numhl 
1d1b			 
1d1b			 
1d1b			.faphex:   ; hex is always stored as a 16bit word 
1d1b				; skip number prefix 
1d1b 23				inc hl 
1d1c				; turn ascii into number 
1d1c cd b2 10			call get_word_hl	; ret 16bit word in hl 
1d1f			 
1d1f c3 67 1b			jp forth_push_numhl 
1d22			 
1d22 00				 nop 
1d23			 
1d23			.fabin:   ; TODO bin conversion 
1d23			 
1d23			 
1d23 c9				ret 
1d24			 
1d24			 
1d24			; get either a string ptr or a 16bit word from the data stack 
1d24			 
1d24			FORTH_DSP: macro 
1d24				call macro_forth_dsp 
1d24				endm 
1d24			 
1d24			macro_forth_dsp: 
1d24				; data stack pointer points to current word on tos 
1d24			 
1d24 2a ee e9			ld hl,(cli_data_sp) 
1d27			 
1d27				if DEBUG_FORTH_PUSH 
1d27						DMARK "DSP" 
1d27 f5				push af  
1d28 3a 3c 1d			ld a, (.dmark)  
1d2b 32 6b ee			ld (debug_mark),a  
1d2e 3a 3d 1d			ld a, (.dmark+1)  
1d31 32 6c ee			ld (debug_mark+1),a  
1d34 3a 3e 1d			ld a, (.dmark+2)  
1d37 32 6d ee			ld (debug_mark+2),a  
1d3a 18 03			jr .pastdmark  
1d3c ..			.dmark: db "DSP"  
1d3f f1			.pastdmark: pop af  
1d40			endm  
# End of macro DMARK
1d40			 
1d40 cd 07 4d				call display_data_sp 
1d43				;call break_point_state 
1d43				;rst 030h 
1d43				CALLMONITOR 
1d43 cd 6f ee			call debug_vector  
1d46				endm  
# End of macro CALLMONITOR
1d46				endif 
1d46			 
1d46 c9				ret 
1d47			 
1d47			; return hl to start of value on stack 
1d47			 
1d47			FORTH_DSP_VALUE: macro 
1d47				call macro_forth_dsp_value 
1d47				endm 
1d47			 
1d47			macro_forth_dsp_value: 
1d47			 
1d47				FORTH_DSP 
1d47 cd 24 1d			call macro_forth_dsp 
1d4a				endm 
# End of macro FORTH_DSP
1d4a			 
1d4a d5				push de 
1d4b			 
1d4b 23				inc hl ; skip type 
1d4c			 
1d4c 5e				ld e, (hl) 
1d4d 23				inc hl 
1d4e 56				ld d, (hl) 
1d4f eb				ex de,hl  
1d50			 
1d50 d1				pop de 
1d51			 
1d51 c9				ret 
1d52			 
1d52			; return hl to start of value to second item on stack 
1d52			 
1d52			FORTH_DSP_VALUEM1: macro 
1d52				call macro_forth_dsp_value_m1 
1d52				endm 
1d52			 
1d52			macro_forth_dsp_value_m1: 
1d52			 
1d52				FORTH_DSP 
1d52 cd 24 1d			call macro_forth_dsp 
1d55				endm 
# End of macro FORTH_DSP
1d55			 
1d55 2b				dec hl 
1d56 2b				dec hl 
1d57			;	dec hl 
1d57			 
1d57 d5				push de 
1d58			 
1d58 5e				ld e, (hl) 
1d59 23				inc hl 
1d5a 56				ld d, (hl) 
1d5b eb				ex de,hl  
1d5c			 
1d5c d1				pop de 
1d5d			 
1d5d c9				ret 
1d5e			 
1d5e				 
1d5e			 
1d5e			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1d5e			 
1d5e			FORTH_DSP_POP: macro 
1d5e				call macro_forth_dsp_pop 
1d5e				endm 
1d5e			 
1d5e			 
1d5e			; get the tos data type 
1d5e			 
1d5e			FORTH_DSP_TYPE:   macro 
1d5e			 
1d5e				;FORTH_DSP_VALUE 
1d5e				FORTH_DSP 
1d5e				 
1d5e				; hl points to value 
1d5e				; check type 
1d5e			 
1d5e				ld a,(hl) 
1d5e			 
1d5e				endm 
1d5e			 
1d5e			; load the tos value into hl 
1d5e			 
1d5e			 
1d5e			FORTH_DSP_VALUEHL:  macro 
1d5e				call macro_dsp_valuehl 
1d5e				endm 
1d5e			 
1d5e			 
1d5e			 
1d5e			macro_dsp_valuehl: 
1d5e				FORTH_DSP_VALUE 
1d5e cd 47 1d			call macro_forth_dsp_value 
1d61				endm 
# End of macro FORTH_DSP_VALUE
1d61			 
1d61				;FORTH_ERR_TOS_NOTNUM 
1d61			 
1d61				;inc hl   ; skip type id 
1d61			 
1d61			;	push de 
1d61			; 
1d61			;	ld e, (hl) 
1d61			;	inc hl 
1d61			;	ld d, (hl) 
1d61			;	ex de,hl  
1d61			 
1d61			;	pop de 
1d61			 
1d61				if DEBUG_FORTH_PUSH 
1d61						DMARK "DVL" 
1d61 f5				push af  
1d62 3a 76 1d			ld a, (.dmark)  
1d65 32 6b ee			ld (debug_mark),a  
1d68 3a 77 1d			ld a, (.dmark+1)  
1d6b 32 6c ee			ld (debug_mark+1),a  
1d6e 3a 78 1d			ld a, (.dmark+2)  
1d71 32 6d ee			ld (debug_mark+2),a  
1d74 18 03			jr .pastdmark  
1d76 ..			.dmark: db "DVL"  
1d79 f1			.pastdmark: pop af  
1d7a			endm  
# End of macro DMARK
1d7a				CALLMONITOR 
1d7a cd 6f ee			call debug_vector  
1d7d				endm  
# End of macro CALLMONITOR
1d7d				endif 
1d7d c9				ret 
1d7e			 
1d7e			forth_apushstrhl:      
1d7e				; push of string requires use of cli_origptr 
1d7e				; bodge use 
1d7e			 
1d7e				; get current cli_origptr, save, update with temp pointer  
1d7e ed 5b 3e ea		ld de, (cli_origptr) 
1d82 22 3e ea			ld (cli_origptr), hl 
1d85 d5				push de 
1d86 cd d0 1c			call forth_apush 
1d89 d1				pop de 
1d8a ed 53 3e ea		ld (cli_origptr), de 
1d8e c9			        ret	 
1d8f			 
1d8f			 
1d8f			; increase loop stack pointer and save hl to it 
1d8f				 
1d8f			FORTH_LOOP_NEXT: macro 
1d8f				call macro_forth_loop_next 
1d8f				;nop 
1d8f				endm 
1d8f			 
1d8f			macro_forth_loop_next: 
1d8f				if DEBUG_FORTH_STACK_GUARD 
1d8f cd 6a 61				call check_stacks 
1d92				endif 
1d92 e5				push hl 
1d93 d5				push de 
1d94 eb				ex de,hl 
1d95 2a f0 e9			ld hl,(cli_loop_sp) 
1d98 23				inc hl 
1d99 23				inc hl 
1d9a					if DEBUG_FORTH_WORDS 
1d9a						DMARK "LNX" 
1d9a f5				push af  
1d9b 3a af 1d			ld a, (.dmark)  
1d9e 32 6b ee			ld (debug_mark),a  
1da1 3a b0 1d			ld a, (.dmark+1)  
1da4 32 6c ee			ld (debug_mark+1),a  
1da7 3a b1 1d			ld a, (.dmark+2)  
1daa 32 6d ee			ld (debug_mark+2),a  
1dad 18 03			jr .pastdmark  
1daf ..			.dmark: db "LNX"  
1db2 f1			.pastdmark: pop af  
1db3			endm  
# End of macro DMARK
1db3						CALLMONITOR 
1db3 cd 6f ee			call debug_vector  
1db6				endm  
# End of macro CALLMONITOR
1db6					endif 
1db6 22 f0 e9			ld (cli_loop_sp),hl 
1db9 73				ld (hl), e 
1dba 23				inc hl 
1dbb 72				ld (hl), d 
1dbc d1				pop de    ; been reversed so save a swap on restore 
1dbd e1				pop hl 
1dbe				if DEBUG_FORTH_STACK_GUARD 
1dbe cd 6a 61				call check_stacks 
1dc1				endif 
1dc1 c9				ret 
1dc2			 
1dc2			; get current ret stack pointer and save to hl  
1dc2				 
1dc2			FORTH_LOOP_TOS: macro 
1dc2				call macro_forth_loop_tos 
1dc2				endm 
1dc2			 
1dc2			macro_forth_loop_tos: 
1dc2 d5				push de 
1dc3 2a f0 e9			ld hl,(cli_loop_sp) 
1dc6 5e				ld e, (hl) 
1dc7 23				inc hl 
1dc8 56				ld d, (hl) 
1dc9 eb				ex de, hl 
1dca d1				pop de 
1dcb c9				ret 
1dcc			 
1dcc			; pop loop stack pointer 
1dcc				 
1dcc			FORTH_LOOP_POP: macro 
1dcc				call macro_forth_loop_pop 
1dcc				endm 
1dcc			 
1dcc			 
1dcc			macro_forth_loop_pop: 
1dcc				if DEBUG_FORTH_STACK_GUARD 
1dcc					DMARK "LPP" 
1dcc f5				push af  
1dcd 3a e1 1d			ld a, (.dmark)  
1dd0 32 6b ee			ld (debug_mark),a  
1dd3 3a e2 1d			ld a, (.dmark+1)  
1dd6 32 6c ee			ld (debug_mark+1),a  
1dd9 3a e3 1d			ld a, (.dmark+2)  
1ddc 32 6d ee			ld (debug_mark+2),a  
1ddf 18 03			jr .pastdmark  
1de1 ..			.dmark: db "LPP"  
1de4 f1			.pastdmark: pop af  
1de5			endm  
# End of macro DMARK
1de5 cd 6a 61				call check_stacks 
1de8					FORTH_CHK_LOOP_UNDER 
1de8 e5				push hl 
1de9 d5				push de 
1dea 2a f0 e9			ld hl,(cli_loop_sp) 
1ded 11 2a e9			ld de, cli_loop_stack 
1df0 cd 04 0e			call cmp16 
1df3 da 84 62			jp c, fault_loop_under 
1df6 d1				pop de 
1df7 e1				pop hl 
1df8				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1df8				endif 
1df8 e5				push hl 
1df9 2a f0 e9			ld hl,(cli_loop_sp) 
1dfc 2b				dec hl 
1dfd 2b				dec hl 
1dfe 22 f0 e9			ld (cli_loop_sp), hl 
1e01				; TODO do stack underflow checks 
1e01 e1				pop hl 
1e02				if DEBUG_FORTH_STACK_GUARD 
1e02 cd 6a 61				call check_stacks 
1e05					FORTH_CHK_LOOP_UNDER 
1e05 e5				push hl 
1e06 d5				push de 
1e07 2a f0 e9			ld hl,(cli_loop_sp) 
1e0a 11 2a e9			ld de, cli_loop_stack 
1e0d cd 04 0e			call cmp16 
1e10 da 84 62			jp c, fault_loop_under 
1e13 d1				pop de 
1e14 e1				pop hl 
1e15				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e15				endif 
1e15 c9				ret 
1e16			 
1e16			macro_forth_dsp_pop: 
1e16			 
1e16 e5				push hl 
1e17			 
1e17				; release malloc data 
1e17			 
1e17				if DEBUG_FORTH_STACK_GUARD 
1e17 cd 6a 61				call check_stacks 
1e1a					FORTH_CHK_DSP_UNDER 
1e1a e5				push hl 
1e1b d5				push de 
1e1c 2a ee e9			ld hl,(cli_data_sp) 
1e1f 11 28 e8			ld de, cli_data_stack 
1e22 cd 04 0e			call cmp16 
1e25 da 78 62			jp c, fault_dsp_under 
1e28 d1				pop de 
1e29 e1				pop hl 
1e2a				endm 
# End of macro FORTH_CHK_DSP_UNDER
1e2a				endif 
1e2a				;ld hl,(cli_data_sp) 
1e2a			if DEBUG_FORTH_DOT 
1e2a				DMARK "DPP" 
1e2a f5				push af  
1e2b 3a 3f 1e			ld a, (.dmark)  
1e2e 32 6b ee			ld (debug_mark),a  
1e31 3a 40 1e			ld a, (.dmark+1)  
1e34 32 6c ee			ld (debug_mark+1),a  
1e37 3a 41 1e			ld a, (.dmark+2)  
1e3a 32 6d ee			ld (debug_mark+2),a  
1e3d 18 03			jr .pastdmark  
1e3f ..			.dmark: db "DPP"  
1e42 f1			.pastdmark: pop af  
1e43			endm  
# End of macro DMARK
1e43				CALLMONITOR 
1e43 cd 6f ee			call debug_vector  
1e46				endm  
# End of macro CALLMONITOR
1e46			endif	 
1e46			 
1e46			 
1e46			if FORTH_ENABLE_DSPPOPFREE 
1e46			 
1e46				FORTH_DSP 
1e46 cd 24 1d			call macro_forth_dsp 
1e49				endm 
# End of macro FORTH_DSP
1e49			 
1e49 7e				ld a, (hl) 
1e4a fe 01			cp DS_TYPE_STR 
1e4c 20 23			jr nz, .skippopfree 
1e4e			 
1e4e				FORTH_DSP_VALUEHL 
1e4e cd 5e 1d			call macro_dsp_valuehl 
1e51				endm 
# End of macro FORTH_DSP_VALUEHL
1e51 00				nop 
1e52			if DEBUG_FORTH_DOT 
1e52				DMARK "DPf" 
1e52 f5				push af  
1e53 3a 67 1e			ld a, (.dmark)  
1e56 32 6b ee			ld (debug_mark),a  
1e59 3a 68 1e			ld a, (.dmark+1)  
1e5c 32 6c ee			ld (debug_mark+1),a  
1e5f 3a 69 1e			ld a, (.dmark+2)  
1e62 32 6d ee			ld (debug_mark+2),a  
1e65 18 03			jr .pastdmark  
1e67 ..			.dmark: db "DPf"  
1e6a f1			.pastdmark: pop af  
1e6b			endm  
# End of macro DMARK
1e6b				CALLMONITOR 
1e6b cd 6f ee			call debug_vector  
1e6e				endm  
# End of macro CALLMONITOR
1e6e			endif	 
1e6e cd 98 12			call free 
1e71			.skippopfree: 
1e71				 
1e71			 
1e71			endif 
1e71			 
1e71			if DEBUG_FORTH_DOT_KEY 
1e71				DMARK "DP2" 
1e71				CALLMONITOR 
1e71			endif	 
1e71			 
1e71				; move pointer down 
1e71			 
1e71 2a ee e9			ld hl,(cli_data_sp) 
1e74 2b				dec hl 
1e75 2b				dec hl 
1e76			; PARSEV5 
1e76 2b				dec hl 
1e77 22 ee e9			ld (cli_data_sp), hl 
1e7a			 
1e7a				if DEBUG_FORTH_STACK_GUARD 
1e7a cd 6a 61				call check_stacks 
1e7d					FORTH_CHK_DSP_UNDER 
1e7d e5				push hl 
1e7e d5				push de 
1e7f 2a ee e9			ld hl,(cli_data_sp) 
1e82 11 28 e8			ld de, cli_data_stack 
1e85 cd 04 0e			call cmp16 
1e88 da 78 62			jp c, fault_dsp_under 
1e8b d1				pop de 
1e8c e1				pop hl 
1e8d				endm 
# End of macro FORTH_CHK_DSP_UNDER
1e8d				endif 
1e8d			 
1e8d e1				pop hl 
1e8e			 
1e8e c9				ret 
1e8f			 
1e8f			getwordathl: 
1e8f				; hl points to an address 
1e8f				; load hl with the word at that address 
1e8f			 
1e8f d5				push de 
1e90			 
1e90 5e				ld e, (hl) 
1e91 23				inc hl 
1e92 56				ld d, (hl) 
1e93 eb				ex de, hl 
1e94			 
1e94 d1				pop de 
1e95 c9				ret 
1e96			 
1e96			 
1e96			 
1e96			 
1e96			 
1e96			; eof 
1e96			 
# End of file forth_stackopsv5.asm
1e96			endif 
1e96			 
1e96			loadwordinhl:	 
1e96			 
1e96 d5				push de 
1e97			 
1e97 5e				ld e, (hl) 
1e98 23				inc hl 
1e99 56				ld d, (hl) 
1e9a eb				ex de,hl  
1e9b			 
1e9b d1				pop de 
1e9c			 
1e9c c9				ret 
1e9d			 
1e9d			user_word_eol:  
1e9d				; hl contains the pointer to where to create a linked list item from the end 
1e9d				; of the user dict to continue on at the system word dict 
1e9d				 
1e9d				; poke the stub of the word list linked list to repoint to rom words 
1e9d			 
1e9d				; stub format 
1e9d				; db   word id 
1e9d				; dw    link to next word 
1e9d			        ; db char length of token 
1e9d				; db string + 0 term 
1e9d				; db exec code....  
1e9d			 
1e9d 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1e9f 77				ld (hl), a		; word id 
1ea0 23				inc hl 
1ea1			 
1ea1 11 6c 20			ld de, sysdict 
1ea4 73				ld (hl), e		; next word link ie system dict 
1ea5 23				inc hl 
1ea6 72				ld (hl), d		; next word link ie system dict 
1ea7 23				inc hl	 
1ea8			 
1ea8			;	ld (hl), sysdict		; next word link ie system dict 
1ea8			;	inc hl 
1ea8			;	inc hl 
1ea8			 
1ea8			;	inc hl 
1ea8			;	inc hl 
1ea8			 
1ea8 3e 02			ld a, 2			; word length is 0 
1eaa 77				ld (hl), a	 
1eab 23				inc hl 
1eac			 
1eac 3e 7e			ld a, '~'			; word length is 0 
1eae 77				ld (hl), a	 
1eaf 23				inc hl 
1eb0 3e 00			ld a, 0			; save empty word 
1eb2 77				ld (hl), a 
1eb3			 
1eb3 c9				ret 
1eb4			 
1eb4				 
1eb4			 
1eb4			forthexec_cleanup: 
1eb4				FORTH_RSP_POP 
1eb4 cd 2f 1b			call macro_forth_rsp_pop 
1eb7				endm 
# End of macro FORTH_RSP_POP
1eb7 c9				ret 
1eb8			 
1eb8			forth_call_hl: 
1eb8				; taking hl 
1eb8 e5				push hl 
1eb9 c9				ret 
1eba			 
1eba			; this is called to reset Forth system but keep existing uwords etc 
1eba			 
1eba			forth_warmstart: 
1eba				; setup stack over/under flow checks 
1eba				if DEBUG_FORTH_STACK_GUARD 
1eba cd 50 61				call chk_stk_init 
1ebd				endif 
1ebd			 
1ebd				; init stack pointers  - * these stacks go upwards *  
1ebd 21 ac e9			ld hl, cli_ret_stack 
1ec0 22 f2 e9			ld (cli_ret_sp), hl	 
1ec3				; set bottom of stack 
1ec3 3e 00			ld a,0 
1ec5 77				ld (hl),a 
1ec6 23				inc hl 
1ec7 77				ld (hl),a 
1ec8			 
1ec8 21 28 e8			ld hl, cli_data_stack 
1ecb 22 ee e9			ld (cli_data_sp), hl	 
1ece				; set bottom of stack 
1ece 3e 00			ld a,0 
1ed0 77				ld (hl),a 
1ed1 23				inc hl 
1ed2 77				ld (hl),a 
1ed3			 
1ed3 21 2a e9			ld hl, cli_loop_stack 
1ed6 22 f0 e9			ld (cli_loop_sp), hl	 
1ed9				; set bottom of stack 
1ed9 3e 00			ld a,0 
1edb 77				ld (hl),a 
1edc 23				inc hl 
1edd 77				ld (hl),a 
1ede			 
1ede				; init extent of current open file 
1ede			 
1ede 3e 00			ld a, 0 
1ee0 32 6a ea			ld (store_openext), a 
1ee3			 
1ee3 c9				ret 
1ee4			 
1ee4			 
1ee4			 
1ee4			; Cold Start - this is called to setup the whole Forth system 
1ee4			 
1ee4			forth_init: 
1ee4			 
1ee4				; setup stack over/under flow checks 
1ee4			 
1ee4			;	if DEBUG_FORTH_STACK_GUARD 
1ee4			;		call chk_stk_init 
1ee4			;	endif 
1ee4			 
1ee4				; enable auto display updates (slow.....) 
1ee4			 
1ee4 3e 01			ld a, 1 
1ee6 32 3c ea			ld (cli_autodisplay), a 
1ee9			 
1ee9				; if storage is in use disable long reads for now 
1ee9 3e 00			ld a, 0 
1eeb 32 75 ea			ld (store_longread), a 
1eee			 
1eee			 
1eee				; show start up screen 
1eee			 
1eee cd b9 0b			call clear_display 
1ef1			 
1ef1 3e 00			ld a,0 
1ef3 32 5e ea			ld (f_cursor_ptr), a 
1ef6			 
1ef6				; set start of word list in start of ram - for use when creating user words 
1ef6			 
1ef6 21 5c 65			ld hl, baseram 
1ef9 22 be e5			ld (os_last_new_uword), hl 
1efc cd 9d 1e			call user_word_eol 
1eff				 
1eff			;		call display_data_sp 
1eff			;		call next_page_prompt 
1eff			 
1eff			 
1eff			 
1eff			 
1eff c9				ret 
1f00			 
1f00 .. 00		.bootforth: db " Forth Kernel Init ",0 
1f14			 
1f14			; TODO push to stack 
1f14			 
1f14			;  
1f14			 
1f14			if FORTH_PARSEV2 
1f14			 
1f14			 
1f14				include "forth_parserv2.asm" 
1f14			 
1f14			endif 
1f14			 
1f14			 
1f14			; parse cli version 1 
1f14			 
1f14			if FORTH_PARSEV1 
1f14			 
1f14			 
1f14			 
1f14			      include "forth_parserv1.asm" 
1f14			endif 
1f14				 
1f14			if FORTH_PARSEV3 
1f14			 
1f14			 
1f14			 
1f14			      include "forth_parserv3.asm" 
1f14				include "forth_wordsv3.asm" 
1f14			endif 
1f14			 
1f14			if FORTH_PARSEV4 
1f14			 
1f14			 
1f14			 
1f14			      include "forth_parserv4.asm" 
1f14				include "forth_wordsv4.asm" 
1f14			endif 
1f14			 
1f14			if FORTH_PARSEV5 
1f14			 
1f14			 
1f14			 
1f14			      include "forth_parserv5.asm" 
1f14			 
1f14			 
1f14			; A better parser without using malloc and string copies all over the place.  
1f14			; Exec in situ should be faster 
1f14			 
1f14			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1f14			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1f14			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1f14			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1f14			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1f14			WORD_SYS_END: equ 0   ; Opcode for all user words 
1f14			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1f14			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1f14			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1f14			 
1f14			; Core word preamble macro 
1f14			 
1f14			CWHEAD:   macro nxtword opcode lit len opflags 
1f14				db WORD_SYS_CORE+opcode             
1f14				; internal op code number 
1f14				dw nxtword            
1f14				; link to next dict word block 
1f14				db len + 1 
1f14				; literal length of dict word inc zero term 
1f14				db lit,0              
1f14				; literal dict word 
1f14			        ; TODO db opflags        
1f14				endm 
1f14			 
1f14			 
1f14			NEXTW: macro  
1f14				jp macro_next 
1f14				endm 
1f14			 
1f14			macro_next: 
1f14			if DEBUG_FORTH_PARSE_KEY 
1f14				DMARK "NXT" 
1f14				CALLMONITOR 
1f14			endif	 
1f14			;	inc hl  ; skip token null term  
1f14 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f18 ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f1c 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f1f			if DEBUG_FORTH_PARSE_KEY 
1f1f				DMARK "}AA" 
1f1f				CALLMONITOR 
1f1f			endif	 
1f1f c3 22 20			jp execnext 
1f22				;jp exec1 
1f22			       
1f22			 
1f22			 
1f22			; Another go at the parser to compile  
1f22			 
1f22			 
1f22			; TODO rework parser to change all of the string words to byte tokens 
1f22			; TODO do a search for  
1f22			 
1f22			; TODO first run normal parser to zero term sections 
1f22			; TODO for each word do a token look up to get the op code 
1f22			; TODO need some means to flag to the exec that this is a byte code form    
1f22			 
1f22			 
1f22			forthcompile: 
1f22			 
1f22			; 
1f22			; line parse: 
1f22			;       parse raw input buffer 
1f22			;       tokenise the words 
1f22			;       malloc new copy (for looping etc) 
1f22			;       copy to malloc + current pc in line to start of string and add line term 
1f22			;       save on new rsp 
1f22			; 
1f22			 
1f22			; hl to point to the line to tokenise 
1f22			 
1f22			;	push hl 
1f22 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
1f25			 
1f25			;	ld a,0		; string term on input 
1f25			;	call strlent 
1f25			 
1f25			;	ld (os_tok_len), hl	 ; save string length 
1f25			 
1f25			;if DEBUG_FORTH_TOK 
1f25			;	ex de,hl		 
1f25			;endif 
1f25			 
1f25			;	pop hl 		; get back string pointer 
1f25			 
1f25			if DEBUG_FORTH_TOK 
1f25						DMARK "TOc" 
1f25				CALLMONITOR 
1f25			endif 
1f25 7e			.cptoken2:    ld a,(hl) 
1f26 23				inc hl 
1f27 fe 7f			cp FORTH_END_BUFFER 
1f29 28 29			jr z, .cptokendone2 
1f2b fe 00			cp 0 
1f2d 28 25			jr z, .cptokendone2 
1f2f fe 22			cp '"' 
1f31 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1f33 fe 20			cp ' ' 
1f35 20 ee			jr nz,  .cptoken2 
1f37			 
1f37			; TODO consume comments held between ( and ) 
1f37			 
1f37				; we have a space so change to zero term for dict match later 
1f37 2b				dec hl 
1f38 3e 00			ld a,0 
1f3a 77				ld (hl), a 
1f3b 23				inc hl 
1f3c 18 e7			jr .cptoken2 
1f3e				 
1f3e			 
1f3e			.cptokenstr2: 
1f3e				; skip all white space until either eol (because forgot to term) or end double quote 
1f3e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f3e				;inc hl ; skip current double quote 
1f3e 7e				ld a,(hl) 
1f3f 23				inc hl 
1f40 fe 22			cp '"' 
1f42 28 e1			jr z, .cptoken2 
1f44 fe 7f			cp FORTH_END_BUFFER 
1f46 28 0c			jr z, .cptokendone2 
1f48 fe 00			cp 0 
1f4a 28 08			jr z, .cptokendone2 
1f4c fe 20			cp ' ' 
1f4e 28 02			jr z, .cptmp2 
1f50 18 ec			jr .cptokenstr2 
1f52			 
1f52			.cptmp2:	; we have a space so change to zero term for dict match later 
1f52				;dec hl 
1f52				;ld a,"-"	; TODO remove this when working 
1f52				;ld (hl), a 
1f52				;inc hl 
1f52 18 ea			jr .cptokenstr2 
1f54			 
1f54			.cptokendone2: 
1f54				;inc hl 
1f54 3e 7f			ld a, FORTH_END_BUFFER 
1f56 77				ld (hl),a 
1f57 23				inc hl 
1f58 3e 21			ld a, '!' 
1f5a 77				ld (hl),a 
1f5b			 
1f5b 2a c2 e5			ld hl,(os_tok_ptr) 
1f5e			         
1f5e			if DEBUG_FORTH_TOK 
1f5e						DMARK "Tc1" 
1f5e				CALLMONITOR 
1f5e			endif 
1f5e			 
1f5e				; push exec string to top of return stack 
1f5e				FORTH_RSP_NEXT 
1f5e cd 0e 1b			call macro_forth_rsp_next 
1f61				endm 
# End of macro FORTH_RSP_NEXT
1f61 c9				ret 
1f62			 
1f62			; Another go at the parser need to simplify the process 
1f62			 
1f62			forthparse: 
1f62			 
1f62			; 
1f62			; line parse: 
1f62			;       parse raw input buffer 
1f62			;       tokenise the words 
1f62			;       malloc new copy (for looping etc) 
1f62			;       copy to malloc + current pc in line to start of string and add line term 
1f62			;       save on new rsp 
1f62			; 
1f62			 
1f62			; hl to point to the line to tokenise 
1f62			 
1f62			;	push hl 
1f62 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
1f65			 
1f65			;	ld a,0		; string term on input 
1f65			;	call strlent 
1f65			 
1f65			;	ld (os_tok_len), hl	 ; save string length 
1f65			 
1f65			;if DEBUG_FORTH_TOK 
1f65			;	ex de,hl		 
1f65			;endif 
1f65			 
1f65			;	pop hl 		; get back string pointer 
1f65			 
1f65			if DEBUG_FORTH_TOK 
1f65						DMARK "TOK" 
1f65				CALLMONITOR 
1f65			endif 
1f65 7e			.ptoken2:    ld a,(hl) 
1f66 23				inc hl 
1f67 fe 7f			cp FORTH_END_BUFFER 
1f69 28 29			jr z, .ptokendone2 
1f6b fe 00			cp 0 
1f6d 28 25			jr z, .ptokendone2 
1f6f fe 22			cp '"' 
1f71 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1f73 fe 20			cp ' ' 
1f75 20 ee			jr nz,  .ptoken2 
1f77			 
1f77			; TODO consume comments held between ( and ) 
1f77			 
1f77				; we have a space so change to zero term for dict match later 
1f77 2b				dec hl 
1f78 3e 00			ld a,0 
1f7a 77				ld (hl), a 
1f7b 23				inc hl 
1f7c 18 e7			jr .ptoken2 
1f7e				 
1f7e			 
1f7e			.ptokenstr2: 
1f7e				; skip all white space until either eol (because forgot to term) or end double quote 
1f7e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f7e				;inc hl ; skip current double quote 
1f7e 7e				ld a,(hl) 
1f7f 23				inc hl 
1f80 fe 22			cp '"' 
1f82 28 e1			jr z, .ptoken2 
1f84 fe 7f			cp FORTH_END_BUFFER 
1f86 28 0c			jr z, .ptokendone2 
1f88 fe 00			cp 0 
1f8a 28 08			jr z, .ptokendone2 
1f8c fe 20			cp ' ' 
1f8e 28 02			jr z, .ptmp2 
1f90 18 ec			jr .ptokenstr2 
1f92			 
1f92			.ptmp2:	; we have a space so change to zero term for dict match later 
1f92				;dec hl 
1f92				;ld a,"-"	; TODO remove this when working 
1f92				;ld (hl), a 
1f92				;inc hl 
1f92 18 ea			jr .ptokenstr2 
1f94			 
1f94			.ptokendone2: 
1f94				;inc hl 
1f94 3e 7f			ld a, FORTH_END_BUFFER 
1f96 77				ld (hl),a 
1f97 23				inc hl 
1f98 3e 21			ld a, '!' 
1f9a 77				ld (hl),a 
1f9b			 
1f9b 2a c2 e5			ld hl,(os_tok_ptr) 
1f9e			         
1f9e			if DEBUG_FORTH_TOK 
1f9e						DMARK "TK1" 
1f9e				CALLMONITOR 
1f9e			endif 
1f9e			 
1f9e				; push exec string to top of return stack 
1f9e				FORTH_RSP_NEXT 
1f9e cd 0e 1b			call macro_forth_rsp_next 
1fa1				endm 
# End of macro FORTH_RSP_NEXT
1fa1 c9				ret 
1fa2			 
1fa2			; 
1fa2			;	; malloc size + buffer pointer + if is loop flag 
1fa2			;	ld hl,(os_tok_len) 		 ; get string length 
1fa2			; 
1fa2			;	ld a,l 
1fa2			; 
1fa2			;	cp 0			; we dont want to use a null string 
1fa2			;	ret z 
1fa2			; 
1fa2			;;	add 3    ; prefix malloc with buffer for current word ptr 
1fa2			; 
1fa2			;	add 5     ; TODO when certain not over writing memory remove 
1fa2			; 
1fa2			;		 
1fa2			; 
1fa2			;if DEBUG_FORTH_TOK 
1fa2			;			DMARK "TKE" 
1fa2			;	CALLMONITOR 
1fa2			;endif 
1fa2			; 
1fa2			;	ld l,a 
1fa2			;	ld h,0 
1fa2			;;	push hl   ; save required space for the copy later 
1fa2			;	call malloc 
1fa2			;if DEBUG_FORTH_TOK 
1fa2			;			DMARK "TKM" 
1fa2			;	CALLMONITOR 
1fa2			;endif 
1fa2			;	if DEBUG_FORTH_MALLOC_GUARD 
1fa2			;		push af 
1fa2			;		call ishlzero 
1fa2			;;		ld a, l 
1fa2			;;		add h 
1fa2			;;		cp 0 
1fa2			;		pop af 
1fa2			;		 
1fa2			;		call z,malloc_error 
1fa2			;	endif 
1fa2			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1fa2			; 
1fa2			; 
1fa2			;if DEBUG_FORTH_TOK 
1fa2			;			DMARK "TKR" 
1fa2			;	CALLMONITOR 
1fa2			;endif 
1fa2			; 
1fa2			;	FORTH_RSP_NEXT 
1fa2			; 
1fa2			;	;inc hl	 ; go past current buffer pointer 
1fa2			;	;inc hl 
1fa2			;	;inc hl   ; and past if loop flag 
1fa2			;		; TODO Need to set flag  
1fa2			; 
1fa2			;	 
1fa2			;	 
1fa2			;	ex de,hl	; malloc is dest 
1fa2			;	ld hl, (os_tok_len) 
1fa2			;;	pop bc 
1fa2			;	ld c, l                
1fa2			;	ld b,0 
1fa2			;	ld hl, (os_tok_ptr) 
1fa2			; 
1fa2			;if DEBUG_FORTH_TOK 
1fa2			;			DMARK "TKT" 
1fa2			;	CALLMONITOR 
1fa2			;endif 
1fa2			; 
1fa2			;	; do str cpy 
1fa2			; 
1fa2			;	ldir      ; copy byte in hl to de 
1fa2			; 
1fa2			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1fa2			; 
1fa2			;if DEBUG_FORTH_TOK 
1fa2			; 
1fa2			;			DMARK "TKY" 
1fa2			;	CALLMONITOR 
1fa2			;endif 
1fa2			;	;ld a,0 
1fa2			;	;ld a,FORTH_END_BUFFER 
1fa2			;	ex de, hl 
1fa2			;	;dec hl			 ; go back over the space delim at the end of word 
1fa2			;	;ld (hl),a 
1fa2			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1fa2			;	ld a,FORTH_END_BUFFER 
1fa2			;	ld (hl),a 
1fa2			;	inc hl 
1fa2			;	ld a,FORTH_END_BUFFER 
1fa2			;	ld (hl),a 
1fa2			; 
1fa2			;	; init the malloc area data 
1fa2			;	; set pc for in current area 
1fa2			;	;ld hl, (os_tok_malloc) 
1fa2			;	;inc hl 
1fa2			;	;inc hl 
1fa2			;	;inc hl 
1fa2			;	;ex de,hl 
1fa2			;	;ld hl, (os_tok_malloc) 
1fa2			;	;ld (hl),e 
1fa2			;	;inc hl 
1fa2			;	;ld (hl),d 
1fa2			; 
1fa2			; 
1fa2			;	ld hl,(os_tok_malloc) 
1fa2			;if DEBUG_FORTH_PARSE_KEY 
1fa2			;			DMARK "TKU" 
1fa2			;	CALLMONITOR 
1fa2			;endif 
1fa2			; 
1fa2			;	ret 
1fa2			 
1fa2			forthexec: 
1fa2			 
1fa2			; line exec: 
1fa2			; forth parser 
1fa2			 
1fa2			; 
1fa2			;       get current exec line on rsp 
1fa2			 
1fa2				FORTH_RSP_TOS 
1fa2 cd 25 1b			call macro_forth_rsp_tos 
1fa5				endm 
# End of macro FORTH_RSP_TOS
1fa5			 
1fa5			;       restore current pc - hl points to malloc of data 
1fa5			 
1fa5				;ld e, (hl) 
1fa5				;inc hl 
1fa5				;ld d, (hl) 
1fa5				;ex de,hl 
1fa5			 
1fa5			 
1fa5			exec1: 
1fa5 22 c2 e5			ld (os_tok_ptr), hl 
1fa8			 
1fa8				; copy our PC to working vars  
1fa8 22 40 ea			ld (cli_ptr), hl 
1fab 22 3e ea			ld (cli_origptr), hl 
1fae			 
1fae 7e				ld a,(hl) 
1faf fe 7f			cp FORTH_END_BUFFER 
1fb1 c8				ret z 
1fb2			 
1fb2				; skip any nulls 
1fb2			 
1fb2 fe 00			cp 0 
1fb4 20 03			jr nz, .execword 
1fb6 23				inc hl 
1fb7 18 ec			jr exec1 
1fb9			 
1fb9			 
1fb9			.execword: 
1fb9			 
1fb9			 
1fb9			 
1fb9			if DEBUG_FORTH_PARSE_KEY 
1fb9						DMARK "KYQ" 
1fb9				CALLMONITOR 
1fb9			endif 
1fb9			;       while at start of word: 
1fb9			; get start of dict (in user area first) 
1fb9			 
1fb9 21 5c 65		ld hl, baseram 
1fbc			;ld hl, sysdict 
1fbc 22 42 ea		ld (cli_nextword),hl 
1fbf			;           match word at pc 
1fbf			;           exec word 
1fbf			;           or push to dsp 
1fbf			;           forward to next token 
1fbf			;           if line term pop rsp and exit 
1fbf			;        
1fbf			 
1fbf			if DEBUG_FORTH_PARSE_KEY 
1fbf						DMARK "KYq" 
1fbf				CALLMONITOR 
1fbf			endif 
1fbf			 
1fbf			; 
1fbf			; word comp 
1fbf			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1fbf			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1fbf			;    move to start of word  
1fbf			;    compare word to cli_token 
1fbf			 
1fbf			.execpnword:	; HL at start of a word in the dictionary to check 
1fbf			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1fbf			;	ld (cli_ptr), hl 
1fbf			 
1fbf 2a 42 ea			ld hl,(cli_nextword) 
1fc2			 
1fc2 cd 65 20			call forth_tok_next 
1fc5			; tok next start here 
1fc5			;	; TODO skip compiled symbol for now 
1fc5			;	inc hl 
1fc5			; 
1fc5			;	; save pointer to next word 
1fc5			; 
1fc5			;	; hl now points to the address of the next word pointer  
1fc5			;	ld e, (hl) 
1fc5			;	inc hl 
1fc5			;	ld d, (hl) 
1fc5			;	inc l 
1fc5			; 
1fc5			;	ex de,hl 
1fc5			;if DEBUG_FORTH_PARSE_NEXTWORD 
1fc5			;	push bc 
1fc5			;	ld bc, (cli_nextword) 
1fc5			;			DMARK "NXW" 
1fc5			;	CALLMONITOR 
1fc5			;	pop bc 
1fc5			;endif 
1fc5			; tok next end here 
1fc5 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
1fc8 eb				ex de, hl 
1fc9			 
1fc9			 
1fc9				; save the pointer of the current token - 1 to check against 
1fc9				 
1fc9 22 46 ea			ld (cli_token), hl   
1fcc				; TODO maybe remove below save if no debug 
1fcc				; save token string ptr for any debug later 
1fcc 23				inc hl  
1fcd 22 48 ea			ld (cli_origtoken), hl 
1fd0 2b				dec hl 
1fd1				; save pointer to the start of the next dictionay word 
1fd1 7e				ld a,(hl)   ; get string length 
1fd2 47				ld b,a 
1fd3			.execpnwordinc:  
1fd3 23				inc hl 
1fd4 10 fd			djnz .execpnwordinc 
1fd6 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
1fd9			 
1fd9				; now check the word token against the string being parsed 
1fd9			 
1fd9 2a 46 ea			ld hl,(cli_token) 
1fdc 23				inc hl     ; skip string length (use zero term instead to end) 
1fdd 22 46 ea			ld (cli_token), hl 
1fe0			 
1fe0			if DEBUG_FORTH_PARSE_KEY 
1fe0						DMARK "KY2" 
1fe0			endif 
1fe0			if DEBUG_FORTH_PARSE_EXEC 
1fe0				; see if disabled 
1fe0			 
1fe0			;	ld a, (os_view_disable) 
1fe0			;	cp '*' 
1fe0				ld a, (debug_vector) 
1fe0				cp $c9   ; RET  
1fe0				jr z, .skip 
1fe0			 
1fe0				push hl 
1fe0				push hl 
1fe0				call clear_display 
1fe0				ld de, .compword 
1fe0				ld a, display_row_1 
1fe0				call str_at_display 
1fe0				pop de 
1fe0				ld a, display_row_2 
1fe0				call str_at_display 
1fe0				ld hl,(cli_ptr) 
1fe0				ld a,(hl) 
1fe0			        ld hl, os_word_scratch 
1fe0				ld (hl),a 
1fe0				ld a,0 
1fe0				inc hl 
1fe0				ld (hl),a 	 
1fe0				ld de, os_word_scratch 
1fe0				ld a, display_row_2+10 
1fe0				call str_at_display 
1fe0				call update_display 
1fe0				ld a, 100 
1fe0				call aDelayInMS 
1fe0				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1fe0				call delay250ms 
1fe0				endif 
1fe0				pop hl 
1fe0			.skip:  
1fe0			endif	 
1fe0			.execpnchar:    ; compare char between token and string to parse 
1fe0			 
1fe0			if DEBUG_FORTH_PARSE_KEY 
1fe0						DMARK "Ky3" 
1fe0			endif 
1fe0			if DEBUG_FORTH_PARSE_EXEC 
1fe0				; see if disabled 
1fe0			 
1fe0			;	ld a, (os_view_disable) 
1fe0			;	cp '*' 
1fe0				ld a, (debug_vector) 
1fe0				cp $C9  ; RET 
1fe0				jr z, .skip2 
1fe0			 
1fe0			;	call clear_display 
1fe0			ld hl,(cli_token) 
1fe0			ld a,(hl) 
1fe0			ld (os_word_scratch),a 
1fe0				ld hl,(cli_ptr) 
1fe0			ld a,(hl) 
1fe0				ld (os_word_scratch+1),a 
1fe0				ld a,0 
1fe0				ld (os_word_scratch+2),a 
1fe0				ld de,os_word_scratch 
1fe0				ld a,display_row_4 
1fe0				call str_at_display 
1fe0				call update_display 
1fe0			.skip2:  
1fe0			endif 
1fe0 2a 46 ea			ld hl,(cli_token) 
1fe3 7e				ld a, (hl)	 ; char in word token 
1fe4 23				inc hl 		; move to next char 
1fe5 22 46 ea			ld (cli_token), hl ; and save it 
1fe8 47				ld b,a 
1fe9			 
1fe9 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
1fec 7e				ld a,(hl) 
1fed 23				inc hl 
1fee 22 40 ea			ld (cli_ptr), hl		; move to next char 
1ff1 cd 50 11			call toUpper 		; make sure the input string matches case 
1ff4			 
1ff4			if DEBUG_FORTH_PARSE 
1ff4			endif 
1ff4			 
1ff4				; input stream end of token is a space so get rid of it 
1ff4			 
1ff4			;	cp ' ' 
1ff4			;	jr nz, .pnskipspace 
1ff4			; 
1ff4			;	ld a, 0		; make same term as word token term 
1ff4			; 
1ff4			;.pnskipspace: 
1ff4			 
1ff4			if DEBUG_FORTH_PARSE_KEY 
1ff4						DMARK "KY7" 
1ff4			endif 
1ff4 b8				cp b 
1ff5 c2 0b 20			jp nz, .execpnskipword	 ; no match so move to next word 
1ff8				 
1ff8			;    if same 
1ff8			;       scan for string terms 0 for token and 32 for input 
1ff8			 
1ff8				 
1ff8			if DEBUG_FORTH_PARSE_KEY 
1ff8						DMARK "KY8" 
1ff8			endif 
1ff8			 
1ff8 80				add b			 
1ff9 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1ffb							; TODO need to make sure last word in zero term string is accounted for 
1ffb 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1ffd			 
1ffd			 
1ffd				; at end of both strings so both are exact match 
1ffd			 
1ffd			;       skip ptr for next word 
1ffd			 
1ffd 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
2000 23				inc hl			 ; at next char 
2001 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
2004 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2007				 
2007				 
2007			if DEBUG_FORTH_PARSE_KEY 
2007						DMARK "KY3" 
2007			endif 
2007			 
2007			 
2007			 
2007			;       exec code block 
2007			if DEBUG_FORTH_JP 
2007				call clear_display 
2007				call update_display 
2007				call delay1s 
2007				ld hl, (cli_execword)     ; save for next check if no match on this word 
2007				ld a,h 
2007				ld hl, os_word_scratch 
2007				call hexout 
2007				ld hl, (cli_execword)     ; save for next check if no match on this word 
2007				ld a,l 
2007				ld hl, os_word_scratch+2 
2007				call hexout 
2007				ld hl, os_word_scratch+4 
2007				ld a,0 
2007				ld (hl),a 
2007				ld de,os_word_scratch 
2007				call str_at_display 
2007					ld a, display_row_2 
2007					call str_at_display 
2007				ld de, (cli_origtoken) 
2007				ld a, display_row_1+10 
2007					call str_at_display 
2007			 
2007				ld a,display_row_1 
2007				ld de, .foundword 
2007				ld a, display_row_3 
2007				call str_at_display 
2007				call update_display 
2007				call delay1s 
2007				call delay1s 
2007				call delay1s 
2007			endif 
2007			 
2007			if DEBUG_FORTH_PARSE_KEY 
2007						DMARK "KYj" 
2007			endif 
2007				; TODO save the word pointer in this exec 
2007			 
2007 2a 44 ea			ld hl,(cli_execword) 
200a e9				jp (hl) 
200b			 
200b			 
200b			;    if not same 
200b			;	scan for zero term 
200b			;	get ptr for next word 
200b			;	goto word comp 
200b			 
200b			.execpnskipword:	; get pointer to next word 
200b 2a 42 ea			ld hl,(cli_nextword) 
200e			 
200e 7e				ld a,(hl) 
200f fe 00			cp WORD_SYS_END 
2011			;	cp 0 
2011 28 09			jr z, .execendofdict			 ; at end of words 
2013			 
2013			if DEBUG_FORTH_PARSE_KEY 
2013						DMARK "KY4" 
2013			endif 
2013			if DEBUG_FORTH_PARSE_EXEC 
2013			 
2013				; see if disabled 
2013			 
2013			;	ld a, (os_view_disable) 
2013			;	cp '*' 
2013				ld a,(debug_vector) 
2013				cp $c9   ; RET 
2013				jr z, .noskip 
2013			 
2013			 
2013				ld de, .nowordfound 
2013				ld a, display_row_3 
2013				call str_at_display 
2013				call update_display 
2013				ld a, 100 
2013				call aDelayInMS 
2013				 
2013				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2013					call delay250ms 
2013				endif 
2013			.noskip:  
2013			 
2013			endif	 
2013			 
2013 2a 3e ea			ld hl,(cli_origptr) 
2016 22 40 ea			ld (cli_ptr),hl 
2019			 
2019			if DEBUG_FORTH_PARSE_KEY 
2019						DMARK "KY5" 
2019			endif 
2019 c3 bf 1f			jp .execpnword			; else go to next word 
201c			 
201c			.execendofdict:  
201c			 
201c			if DEBUG_FORTH_PARSE_KEY 
201c						DMARK "KYe" 
201c			endif 
201c			if DEBUG_FORTH_PARSE_EXEC 
201c				; see if disabled 
201c			 
201c			;	ld a, (os_view_disable) 
201c			;	cp '*' 
201c				ld a,(debug_vector) 
201c				cp $c9   ; ret 
201c				jr z, .ispskip 
201c			 
201c				call clear_display 
201c				call update_display 
201c				call delay1s 
201c				ld de, (cli_origptr) 
201c				ld a, display_row_1 
201c				call str_at_display 
201c				 
201c				ld de, .enddict 
201c				ld a, display_row_3 
201c				call str_at_display 
201c				call update_display 
201c				ld a, 100 
201c				call aDelayInMS 
201c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
201c				call delay1s 
201c				call delay1s 
201c				call delay1s 
201c				endif 
201c			.ispskip:  
201c				 
201c			endif	 
201c			 
201c			 
201c			 
201c				; if the word is not a keyword then must be a literal so push it to stack 
201c			 
201c			; push token to stack to end of word 
201c			 
201c				STACKFRAME ON $1efe $2f9f 
201c				if DEBUG_STACK_IMB 
201c					if ON 
201c						exx 
201c						ld de, $1efe 
201c						ld a, d 
201c						ld hl, curframe 
201c						call hexout 
201c						ld a, e 
201c						ld hl, curframe+2 
201c						call hexout 
201c						ld hl, $1efe 
201c						push hl 
201c						ld hl, $2f9f 
201c						push hl 
201c						exx 
201c					endif 
201c				endif 
201c			endm 
# End of macro STACKFRAME
201c			 
201c 2a c2 e5		ld hl,(os_tok_ptr) 
201f cd d0 1c		call forth_apush 
2022			 
2022				STACKFRAMECHK ON $1efe $2f9f 
2022				if DEBUG_STACK_IMB 
2022					if ON 
2022						exx 
2022						ld hl, $2f9f 
2022						pop de   ; $2f9f 
2022						call cmp16 
2022						jr nz, .spnosame 
2022						ld hl, $1efe 
2022						pop de   ; $1efe 
2022						call cmp16 
2022						jr z, .spfrsame 
2022						.spnosame: call showsperror 
2022						.spfrsame: nop 
2022						exx 
2022					endif 
2022				endif 
2022			endm 
# End of macro STACKFRAMECHK
2022			 
2022			execnext: 
2022			 
2022			if DEBUG_FORTH_PARSE_KEY 
2022						DMARK "KY>" 
2022			endif 
2022			; move past token to next word 
2022			 
2022 2a c2 e5		ld hl, (os_tok_ptr) 
2025 3e 00		ld a, 0 
2027 01 ff 00		ld bc, 255     ; input buffer size 
202a ed b1		cpir 
202c			 
202c			if DEBUG_FORTH_PARSE_KEY 
202c						DMARK "KY!" 
202c				CALLMONITOR 
202c			endif	 
202c			; TODO this might place hl on the null, so will need to forward on??? 
202c			;inc hl   ; see if this gets onto the next item 
202c			 
202c			 
202c			; TODO pass a pointer to the buffer to push 
202c			; TODO call function to push 
202c			 
202c			; look for end of input 
202c			 
202c			;inc hl 
202c			;ld a,(hl) 
202c			;cp FORTH_END_BUFFER 
202c			;ret z 
202c			 
202c			 
202c c3 a5 1f		jp exec1 
202f			 
202f			 
202f			 
202f			 
202f			 
202f			 
202f			 
202f			 
202f			 
202f			findnexttok: 
202f			 
202f				; hl is pointer to move 
202f				; de is the token to locate 
202f			 
202f					if DEBUG_FORTH 
202f						DMARK "NTK" 
202f						CALLMONITOR 
202f					endif 
202f d5				push de 
2030			 
2030			.fnt1:	 
2030				; find first char of token to locate 
2030			 
2030 1a				ld a, (de) 
2031 4f				ld c,a 
2032 7e				ld a,(hl) 
2033 cd 50 11			call toUpper 
2036					if DEBUG_FORTH 
2036						DMARK "NT1" 
2036						CALLMONITOR 
2036					endif 
2036 b9				cp c 
2037			 
2037 28 03			jr z, .fnt2cmpmorefirst	 
2039			 
2039				; first char not found move to next char 
2039			 
2039 23				inc hl 
203a 18 f4			jr .fnt1 
203c			 
203c			.fnt2cmpmorefirst:	 
203c				; first char of token found.  
203c			 
203c e5				push hl     ; save start of token just in case it is the right one 
203d d9				exx 
203e e1				pop hl        ; save it to hl' 
203f d9				exx 
2040			 
2040			 
2040			.fnt2cmpmore:	 
2040				; compare the rest 
2040				 
2040 23				inc hl 
2041 13				inc de 
2042				 
2042 1a				ld a, (de) 
2043 4f				ld c,a 
2044 7e				ld a,(hl) 
2045 cd 50 11			call toUpper 
2048			 
2048					if DEBUG_FORTH 
2048						DMARK "NT2" 
2048						CALLMONITOR 
2048					endif 
2048				; c has the token to find char 
2048				; a has the mem to scan char 
2048			 
2048 b9				cp c 
2049 28 04			jr z,.fntmatch1 
204b			 
204b				; they are not the same 
204b			 
204b					if DEBUG_FORTH 
204b						DMARK "NT3" 
204b						CALLMONITOR 
204b					endif 
204b d1				pop de	; reset de token to look for 
204c d5				push de 
204d 18 e1			jr .fnt1 
204f				 
204f			.fntmatch1: 
204f			 
204f				; is the same char a null which means we might have a full hit? 
204f					if DEBUG_FORTH 
204f						DMARK "NT4" 
204f						CALLMONITOR 
204f					endif 
204f			 
204f fe 00			cp 0 
2051 28 0b			jr z, .fntmatchyes 
2053			 
2053				; are we at the end of the token to find? 
2053			 
2053					if DEBUG_FORTH 
2053						DMARK "NT5" 
2053						CALLMONITOR 
2053					endif 
2053 3e 00			ld a, 0 
2055 b9				cp c 
2056			 
2056 c2 40 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2059			 
2059					if DEBUG_FORTH 
2059						DMARK "NT6" 
2059						CALLMONITOR 
2059					endif 
2059				; token to find is exhusted but no match to stream 
2059			 
2059				; restore tok pointer and continue on 
2059 d1				pop de 
205a d5				push de 
205b c3 30 20			jp .fnt1 
205e			 
205e			 
205e			.fntmatchyes: 
205e			 
205e				; hl now contains the end of the found token 
205e			 
205e				; get rid of saved token pointer to find 
205e			 
205e d1				pop de 
205f			 
205f					if DEBUG_FORTH 
205f						DMARK "NT9" 
205f						CALLMONITOR 
205f					endif 
205f			 
205f				; hl will be on the null term so forward on 
205f			 
205f				; get back the saved start of the token 
205f			 
205f d9				exx 
2060 e5				push hl     ; save start of token just in case it is the right one 
2061 d9				exx 
2062 e1				pop hl        ; save it to hl 
2063			 
2063 c9				ret 
2064			 
2064			 
2064			; LIST needs to find a specific token   
2064			; FORGET needs to find a spefici token 
2064			 
2064			; SAVE needs to find all tokens by flag 
2064			; WORDS just needs to scan through all  by flag 
2064			; UWORDS needs to scan through all by flag 
2064			 
2064			 
2064			; given hl as pointer to start of dict look up string 
2064			; return hl as pointer to start of word block 
2064			; or 0 if not found 
2064			 
2064			forth_find_tok: 
2064 c9				ret 
2065			 
2065			; given hl as pointer to dict structure 
2065			; move to the next dict block structure 
2065			 
2065			forth_tok_next: 
2065				; hl now points to the address of the next word pointer  
2065				; TODO skip compiled symbol for now 
2065			;	push de 
2065 23				inc hl 
2066 5e				ld e, (hl) 
2067 23				inc hl 
2068 56				ld d, (hl) 
2069 23				inc hl 
206a			 
206a eb				ex de,hl 
206b			if DEBUG_FORTH_PARSE_NEXTWORD 
206b				push bc 
206b				ld bc, (cli_nextword) 
206b						DMARK "NXW" 
206b				CALLMONITOR 
206b				pop bc 
206b			endif 
206b			;	pop de	 
206b c9				ret 
206c			 
206c			 
206c			 
206c			; eof 
# End of file forth_parserv5.asm
206c				include "forth_wordsv4.asm" 
206c			 
206c			; the core word dictionary v4 
206c			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
206c			 
206c			; this is a linked list for each of the system words used 
206c			; user defined words will follow the same format but will be in ram 
206c			 
206c			 
206c			; 
206c			; 
206c			; define linked list: 
206c			; 
206c			; 1. compiled byte op code 
206c			; 2. len of text word 
206c			; 3. text word 
206c			; 4. ptr to next dictionary word 
206c			; 5. asm, calls etc for the word 
206c			; 
206c			;  if 1 == 0 then last word in dict  
206c			;   
206c			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
206c			;  
206c			;  
206c			; create basic standard set of words 
206c			; 
206c			;  
206c			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
206c			; 2DUP 2DROP 2SWAP  
206c			; @ C@ - get byte  
206c			; ! C! - store byte 
206c			; 0< true if less than zero 
206c			; 0= true if zero 
206c			; < >  
206c			; = true if same 
206c			; variables 
206c			 
206c			 
206c			; Hardware specific words I may need 
206c			; 
206c			; IN OUT  
206c			; calls to key util functions 
206c			; calls to hardward abstraction stuff 
206c			; easy control of frame buffers and lcd i/o 
206c			; keyboard  
206c			 
206c			 
206c			;DICT: macro 
206c			; op_code, len, word, next 
206c			;    word: 
206c			;    db op_code 
206c			;    ds word zero term 
206c			;    dw next 
206c			;    endm 
206c			 
206c			 
206c			 
206c			 
206c			; op code 1 is a flag for user define words which are to be handled differently 
206c			 
206c			 
206c			; 
206c			; 
206c			;    TODO on entry to a word this should be the expected environment 
206c			;    hl - tos value if number then held, if string this is the ptr 
206c			;    de -  
206c			 
206c			 
206c			; opcode ranges 
206c			; 0 - end of word dict 
206c			; 255 - user define words 
206c			 
206c			sysdict: 
206c			include "forth_opcodes.asm" 
206c			; op codes for forth keywords 
206c			; free to use code 0  
206c				OPCODE_HEAP: equ  1 
206c				OPCODE_EXEC: equ 2 
206c				OPCODE_DUP: equ 3 
206c				OPCODE_SWAP: equ 4 
206c				OPCODE_COLN: equ 5 
206c				OPCODE_SCOLN: equ 6 
206c				OPCODE_DROP: equ 7 
206c				OPCODE_DUP2: equ 8 
206c				OPCODE_DROP2: equ 9 
206c				OPCODE_SWAP2: equ 10 
206c				OPCODE_AT: equ 11 
206c				OPCODE_CAT: equ 12 
206c				OPCODE_BANG: equ 13 
206c				OPCODE_CBANG: equ 14 
206c				OPCODE_SCALL: equ 15 
206c				OPCODE_DEPTH: equ 16 
206c				OPCODE_OVER: equ 17 
206c				OPCODE_PAUSE: equ 18 
206c				OPCODE_PAUSES: equ 19 
206c				OPCODE_ROT: equ 20 
206c			;free to reuse	OPCODE_WORDS: equ 21 
206c			        OPCODE_NOT: equ 21 
206c				OPCODE_UWORDS: equ 22 
206c				OPCODE_BP: equ 23 
206c				OPCODE_MONITOR: equ 24  
206c				OPCODE_MALLOC: equ 25 
206c				OPCODE_FREE: equ 26 
206c				OPCODE_LIST: equ 27 
206c				OPCODE_FORGET: equ 28 
206c				OPCODE_NOP: equ 29 
206c				OPCODE_COMO: equ 30 
206c				OPCODE_COMC: equ 31 
206c			;free to reuse	OPCODE_ENDCORE: equ 32 
206c				OPCODE_AFTERSOUND: equ 33 
206c				OPCODE_GP2: equ 34 
206c				OPCODE_GP3: equ 35 
206c				OPCODE_GP4: equ 36 
206c				OPCODE_SIN: equ 37 
206c				OPCODE_SOUT: equ 38 
206c				OPCODE_SPIO: equ 39 
206c				OPCODE_SPICEH: equ 40 
206c				OPCODE_SPIOb: equ 41 
206c				OPCODE_SPII: equ 42 
206c				OPCODE_SESEL: equ 43 
206c				OPCODE_CARTDEV: equ 44 
206c			; free to reuse	OPCODE_ENDDEVICE: equ 45 
206c				OPCODE_FB: equ 46 
206c				OPCODE_EMIT: equ 47 
206c				OPCODE_DOTH: equ 48 
206c				OPCODE_DOTF: equ 49 
206c				OPCODE_DOT: equ 50 
206c				OPCODE_CLS: equ 51 
206c				OPCODE_DRAW: equ 52 
206c				OPCODE_DUMP: equ 53 
206c				OPCODE_CDUMP: equ 54 
206c				OPCODE_DAT: equ 55 
206c				OPCODE_HOME: equ 56 
206c				OPCODE_SPACE: equ 57 
206c				OPCODE_SPACES: equ 58 
206c				OPCODE_SCROLL: equ 59 
206c				OPCODE_ATQ: equ 60 
206c				OPCODE_AUTODSP: equ 61 
206c				OPCODE_MENU: equ 62 
206c			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
206c				OPCODE_THEN: equ 64 
206c				OPCODE_ELSE: equ 65 
206c				OPCODE_DO: equ 66 
206c				OPCODE_LOOP: equ 67 
206c				OPCODE_I: equ 68 
206c				OPCODE_DLOOP: equ 69  
206c				OPCODE_REPEAT: equ 70  
206c				OPCODE_UNTIL: equ 71 
206c				OPCODE_ENDFLOW: equ 72 
206c				OPCODE_WAITK: equ 73 
206c				OPCODE_ACCEPT: equ 74 
206c				OPCODE_EDIT: equ 75 
206c			;free to reuse	OPCODE_ENDKEY: equ 76 
206c				OPCODE_LZERO: equ 77 
206c				OPCODE_TZERO: equ 78 
206c				OPCODE_LESS: equ 79 
206c				OPCODE_GT: equ 80 
206c				OPCODE_EQUAL: equ 81  
206c			;free to reuse	OPCODE_ENDLOGIC: equ 82 
206c				OPCODE_NEG: equ 83 
206c				OPCODE_DIV: equ 84 
206c				OPCODE_MUL: equ 85 
206c				OPCODE_MIN: equ 86 
206c				OPCODE_MAX: equ 87 
206c				OPCODE_RND16: equ 88 
206c				OPCODE_RND8: equ 89 
206c				OPCODE_RND: equ 90 
206c			;free to reuse	OPCODE_ENDMATHS: equ 91  
206c				OPCODE_BYNAME: equ 92 
206c				OPCODE_DIR: equ 93 
206c				OPCODE_SAVE: equ 94 
206c				OPCODE_LOAD: equ 95 
206c				OPCODE_BSAVE: equ 96 
206c				OPCODE_BLOAD: equ 97 
206c				OPCODE_SEO: equ 98  
206c				OPCODE_SEI: equ 99 
206c				OPCODE_SFREE: equ 100 
206c				OPCODE_SIZE: equ 101 
206c				OPCODE_CREATE: equ 102 
206c				OPCODE_APPEND: equ 103 
206c				OPCODE_SDEL: equ 104 
206c				OPCODE_OPEN: equ 105 
206c				OPCODE_READ: equ 106 
206c				OPCODE_EOF: equ 106 
206c				OPCODE_FORMAT: equ 107 
206c				OPCODE_LABEL: equ 108 
206c				OPCODE_LABELS: equ 109 
206c			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
206c				OPCODE_UPPER: equ 111 
206c				OPCODE_LOWER: equ 112 
206c				OPCODE_SUBSTR: equ 113 
206c				OPCODE_LEFT: equ 114 
206c				OPCODE_RIGHT: equ 115 
206c				OPCODE_STR2NUM: equ 116 
206c				OPCODE_NUM2STR: equ 117 
206c				OPCODE_CONCAT: equ 118 
206c				OPCODE_FIND: equ 119 
206c				OPCODE_LEN: equ 120 
206c				OPCODE_CHAR: equ 121 
206c			; free to reuse	OPCODE_STRLEN: equ 122 
206c			; free to reuse	OPCODE_ENDSTR: equ 123 
206c				OPCODE_V0S: equ 124 
206c				OPCODE_V0Q: equ 125 
206c				OPCODE_V1S: equ 126 
206c				OPCODE_V1Q: equ 127 
206c				OPCODE_V2S: equ 128 
206c				OPCODE_V2Q: equ 129 
206c				OPCODE_V3S: equ 130 
206c				OPCODE_V3Q: equ 131 
206c			;free to reuse	OPCODE_END: equ 132 
206c				OPCODE_ZDUP: equ 133 
206c			 
206c			; eof 
# End of file forth_opcodes.asm
206c			 
206c			include "forth_words_core.asm" 
206c			 
206c			; | ## Core Words 
206c			 
206c			;if MALLOC_4 
206c			 
206c			.HEAP: 
206c			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
206c 15				db WORD_SYS_CORE+OPCODE_HEAP             
206d ab 20			dw .EXEC            
206f 05				db 4 + 1 
2070 .. 00			db "HEAP",0              
2075				endm 
# End of macro CWHEAD
2075			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2075			; | | u1 - Current number of bytes in the heap 
2075			; | | u2 - Remaining bytes left on the heap 
2075			; | |  
2075			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2075			 
2075			 
2075				if DEBUG_FORTH_WORDS_KEY 
2075					DMARK "HEP" 
2075 f5				push af  
2076 3a 8a 20			ld a, (.dmark)  
2079 32 6b ee			ld (debug_mark),a  
207c 3a 8b 20			ld a, (.dmark+1)  
207f 32 6c ee			ld (debug_mark+1),a  
2082 3a 8c 20			ld a, (.dmark+2)  
2085 32 6d ee			ld (debug_mark+2),a  
2088 18 03			jr .pastdmark  
208a ..			.dmark: db "HEP"  
208d f1			.pastdmark: pop af  
208e			endm  
# End of macro DMARK
208e					CALLMONITOR 
208e cd 6f ee			call debug_vector  
2091				endm  
# End of macro CALLMONITOR
2091				endif 
2091 2a 66 65			ld hl, (free_list )      
2094 11 6b 65			ld de, heap_start 
2097			 
2097 ed 52			sbc hl, de  
2099			 
2099 cd 67 1b			call forth_push_numhl 
209c			 
209c			 
209c ed 5b 66 65		ld de, (free_list )      
20a0 21 9c e2			ld hl, heap_end 
20a3			 
20a3 ed 52			sbc hl, de 
20a5			 
20a5 cd 67 1b			call forth_push_numhl 
20a8				 
20a8			 
20a8				 
20a8			 
20a8			 
20a8			 
20a8				NEXTW 
20a8 c3 14 1f			jp macro_next 
20ab				endm 
# End of macro NEXTW
20ab			;endif 
20ab			 
20ab			.EXEC: 
20ab			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
20ab			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
20ab			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
20ab			;; > > 
20ab			;; > >   
20ab			;	STACKFRAME OFF $5efe $5f9f 
20ab			; 
20ab			;		if DEBUG_FORTH_WORDS_KEY 
20ab			;			DMARK "EXE" 
20ab			;			CALLMONITOR 
20ab			;		endif 
20ab			; 
20ab			;	FORTH_DSP_VALUEHL 
20ab			; 
20ab			;	FORTH_DSP_POP 
20ab			; 
20ab			;		if DEBUG_FORTH_WORDS 
20ab			;			DMARK "EX1" 
20ab			;			CALLMONITOR 
20ab			;		endif 
20ab			;;	ld e,(hl) 
20ab			;;	inc hl 
20ab			;;	ld d,(hl) 
20ab			;;	ex de,hl 
20ab			; 
20ab			;;		if DEBUG_FORTH_WORDS 
20ab			;;			DMARK "EX2" 
20ab			;;			CALLMONITOR 
20ab			;;		endif 
20ab			;	push hl 
20ab			; 
20ab			;	;ld a, 0 
20ab			;	;ld a, FORTH_END_BUFFER 
20ab			;	call strlenz 
20ab			;	inc hl   ; include zero term to copy 
20ab			;	inc hl   ; include term 
20ab			;	inc hl   ; include term 
20ab			;	ld b,0 
20ab			;	ld c,l 
20ab			;	pop hl 
20ab			;	ld de, execscratch 
20ab			;		if DEBUG_FORTH_WORDS 
20ab			;			DMARK "EX3" 
20ab			;			CALLMONITOR 
20ab			;		endif 
20ab			;	ldir 
20ab			; 
20ab			; 
20ab			;	ld hl, execscratch 
20ab			; 
20ab			;		if DEBUG_FORTH_WORDS 
20ab			;			DMARK "EXe" 
20ab			;			CALLMONITOR 
20ab			;		endif 
20ab			; 
20ab			;	call forthparse 
20ab			;	call forthexec 
20ab			;;	call forthexec_cleanup 
20ab			;;	call forthparse 
20ab			;;	call forthexec 
20ab			; 
20ab			;	STACKFRAMECHK OFF $5efe $5f9f 
20ab			; 
20ab			;	; an immediate word so no need to process any more words 
20ab			;	ret 
20ab			;	NEXTW 
20ab			 
20ab			; dead code - old version  
20ab			;	FORTH_RSP_NEXT 
20ab			 
20ab			;  
20ab			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
20ab			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
20ab			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
20ab			;	push hl 
20ab			;	push de 
20ab			;	push bc 
20ab			; 
20ab			; 
20ab			;		if DEBUG_FORTH_WORDS_KEY 
20ab			;			DMARK "EXR" 
20ab			;			CALLMONITOR 
20ab			;		endif 
20ab			; 
20ab			; 
20ab			; 
20ab			;	;v5 FORTH_DSP_VALUE 
20ab			;	FORTH_DSP_VALUEHL 
20ab			; 
20ab			;	; TODO do string type checks 
20ab			; 
20ab			;;v5	inc hl   ; skip type 
20ab			; 
20ab			;	push hl  ; source code  
20ab			;		if DEBUG_FORTH_WORDS 
20ab			;			DMARK "EX1" 
20ab			;			CALLMONITOR 
20ab			;		endif 
20ab			;	ld a, 0 
20ab			;	call strlent 
20ab			; 
20ab			;	inc hl 
20ab			;	inc hl 
20ab			;	inc hl 
20ab			;	inc hl 
20ab			; 
20ab			;	push hl    ; size 
20ab			; 
20ab			;		if DEBUG_FORTH_WORDS 
20ab			;			DMARK "EX2" 
20ab			;			CALLMONITOR 
20ab			;		endif 
20ab			;	call malloc 
20ab			; 
20ab			;	ex de, hl    ; de now contains malloc area 
20ab			;	pop bc   	; get byte count 
20ab			;	pop hl      ; get string to copy 
20ab			; 
20ab			;	push de     ; save malloc for free later 
20ab			; 
20ab			;		if DEBUG_FORTH_WORDS 
20ab			;			DMARK "EX3" 
20ab			;			CALLMONITOR 
20ab			;		endif 
20ab			;	ldir       ; duplicate string 
20ab			; 
20ab			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
20ab			;	 
20ab			;	; TODO fix the parse would be better than this...  
20ab			;	ex de, hl 
20ab			;	dec hl 
20ab			;	ld a, 0 
20ab			;	ld (hl), a 
20ab			;	dec hl 
20ab			;	ld a, ' ' 
20ab			;	ld (hl), a 
20ab			;	dec hl 
20ab			;	ld (hl), a 
20ab			; 
20ab			;	dec hl 
20ab			;	ld (hl), a 
20ab			; 
20ab			; 
20ab			;	FORTH_DSP_POP  
20ab			; 
20ab			;	pop hl     
20ab			;	push hl    ; save malloc area 
20ab			; 
20ab			;		if DEBUG_FORTH_WORDS 
20ab			;			DMARK "EX4" 
20ab			;			CALLMONITOR 
20ab			;		endif 
20ab			; 
20ab			;	call forthparse 
20ab			;	call forthexec 
20ab			;	 
20ab			;	pop hl 
20ab			;	if DEBUG_FORTH_WORDS 
20ab			;		DMARK "EX5" 
20ab			;		CALLMONITOR 
20ab			;	endif 
20ab			; 
20ab			;	if FORTH_ENABLE_FREE 
20ab			;	call free 
20ab			;	endif 
20ab			; 
20ab			;	if DEBUG_FORTH_WORDS 
20ab			;		DMARK "EX6" 
20ab			;		CALLMONITOR 
20ab			;	endif 
20ab			; 
20ab			;	pop bc 
20ab			;	pop de 
20ab			;	pop hl 
20ab			;;	FORTH_RSP_POP	  
20ab			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
20ab			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
20ab			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
20ab			; 
20ab			;	if DEBUG_FORTH_WORDS 
20ab			;		DMARK "EX7" 
20ab			;		CALLMONITOR 
20ab			;	endif 
20ab			;	NEXTW 
20ab			 
20ab			;.STKEXEC: 
20ab			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
20ab			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
20ab			; 
20ab			; 
20ab			;		if DEBUG_FORTH_WORDS_KEY 
20ab			;			DMARK "STX" 
20ab			;			CALLMONITOR 
20ab			;		endif 
20ab			; 
20ab			;	FORTH_DSP_VALUEHL 
20ab			; 
20ab			;	ld (store_tmp1), hl    ; count 
20ab			; 
20ab			;	FORTH_DSP_POP 
20ab			;.stkexec1: 
20ab			;	ld hl, (store_tmp1)   ; count 
20ab			;	ld a, 0 
20ab			;	cp l 
20ab			;	ret z 
20ab			; 
20ab			;	dec hl 
20ab			;	ld (store_tmp1), hl    ; count 
20ab			;	 
20ab			;	FORTH_DSP_VALUEHL 
20ab			;	push hl 
20ab			;	 
20ab			;		if DEBUG_FORTH_WORDS 
20ab			;			DMARK "EXp" 
20ab			;			CALLMONITOR 
20ab			;		endif 
20ab			;	FORTH_DSP_POP 
20ab			; 
20ab			;	call strlenz 
20ab			;	inc hl   ; include zero term to copy 
20ab			;	inc hl   ; include zero term to copy 
20ab			;	inc hl   ; include zero term to copy 
20ab			;	ld b,0 
20ab			;	ld c,l 
20ab			;	pop hl 
20ab			;	ld de, execscratch 
20ab			;		if DEBUG_FORTH_WORDS 
20ab			;			DMARK "EX3" 
20ab			;			CALLMONITOR 
20ab			;		endif 
20ab			;	ldir 
20ab			; 
20ab			; 
20ab			;	ld hl, execscratch 
20ab			; 
20ab			;		if DEBUG_FORTH_WORDS 
20ab			;			DMARK "EXP" 
20ab			;			CALLMONITOR 
20ab			;		endif 
20ab			; 
20ab			;	call forthparse 
20ab			;	ld hl, execscratch 
20ab			;		if DEBUG_FORTH_WORDS 
20ab			;			DMARK "EXx" 
20ab			;			CALLMONITOR 
20ab			;		endif 
20ab			;	call forthexec 
20ab			; 
20ab			;	jp .stkexec1 
20ab			; 
20ab			;	ret 
20ab			 
20ab			 
20ab			.DUP: 
20ab			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
20ab 17				db WORD_SYS_CORE+OPCODE_DUP             
20ac 21 21			dw .ZDUP            
20ae 04				db 3 + 1 
20af .. 00			db "DUP",0              
20b3				endm 
# End of macro CWHEAD
20b3			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
20b3			 
20b3				if DEBUG_FORTH_WORDS_KEY 
20b3					DMARK "DUP" 
20b3 f5				push af  
20b4 3a c8 20			ld a, (.dmark)  
20b7 32 6b ee			ld (debug_mark),a  
20ba 3a c9 20			ld a, (.dmark+1)  
20bd 32 6c ee			ld (debug_mark+1),a  
20c0 3a ca 20			ld a, (.dmark+2)  
20c3 32 6d ee			ld (debug_mark+2),a  
20c6 18 03			jr .pastdmark  
20c8 ..			.dmark: db "DUP"  
20cb f1			.pastdmark: pop af  
20cc			endm  
# End of macro DMARK
20cc					CALLMONITOR 
20cc cd 6f ee			call debug_vector  
20cf				endm  
# End of macro CALLMONITOR
20cf				endif 
20cf			 
20cf				FORTH_DSP 
20cf cd 24 1d			call macro_forth_dsp 
20d2				endm 
# End of macro FORTH_DSP
20d2			 
20d2 7e				ld a, (HL) 
20d3 fe 01			cp DS_TYPE_STR 
20d5 20 25			jr nz, .dupinum 
20d7			 
20d7				; push another string 
20d7			 
20d7				FORTH_DSP_VALUEHL     		 
20d7 cd 5e 1d			call macro_dsp_valuehl 
20da				endm 
# End of macro FORTH_DSP_VALUEHL
20da			 
20da			if DEBUG_FORTH_WORDS 
20da				DMARK "DUs" 
20da f5				push af  
20db 3a ef 20			ld a, (.dmark)  
20de 32 6b ee			ld (debug_mark),a  
20e1 3a f0 20			ld a, (.dmark+1)  
20e4 32 6c ee			ld (debug_mark+1),a  
20e7 3a f1 20			ld a, (.dmark+2)  
20ea 32 6d ee			ld (debug_mark+2),a  
20ed 18 03			jr .pastdmark  
20ef ..			.dmark: db "DUs"  
20f2 f1			.pastdmark: pop af  
20f3			endm  
# End of macro DMARK
20f3				CALLMONITOR 
20f3 cd 6f ee			call debug_vector  
20f6				endm  
# End of macro CALLMONITOR
20f6			endif 
20f6 cd d5 1b			call forth_push_str 
20f9			 
20f9				NEXTW 
20f9 c3 14 1f			jp macro_next 
20fc				endm 
# End of macro NEXTW
20fc			 
20fc			 
20fc			.dupinum: 
20fc				 
20fc			 
20fc			 
20fc				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
20fc cd 5e 1d			call macro_dsp_valuehl 
20ff				endm 
# End of macro FORTH_DSP_VALUEHL
20ff			 
20ff			; TODO add floating point number detection 
20ff			 
20ff			if DEBUG_FORTH_WORDS 
20ff				DMARK "DUi" 
20ff f5				push af  
2100 3a 14 21			ld a, (.dmark)  
2103 32 6b ee			ld (debug_mark),a  
2106 3a 15 21			ld a, (.dmark+1)  
2109 32 6c ee			ld (debug_mark+1),a  
210c 3a 16 21			ld a, (.dmark+2)  
210f 32 6d ee			ld (debug_mark+2),a  
2112 18 03			jr .pastdmark  
2114 ..			.dmark: db "DUi"  
2117 f1			.pastdmark: pop af  
2118			endm  
# End of macro DMARK
2118				CALLMONITOR 
2118 cd 6f ee			call debug_vector  
211b				endm  
# End of macro CALLMONITOR
211b			endif 
211b			 
211b cd 67 1b			call forth_push_numhl 
211e				NEXTW 
211e c3 14 1f			jp macro_next 
2121				endm 
# End of macro NEXTW
2121			.ZDUP: 
2121			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2121 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2122 59 21			dw .SWAP            
2124 05				db 4 + 1 
2125 .. 00			db "?DUP",0              
212a				endm 
# End of macro CWHEAD
212a			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
212a			 
212a				if DEBUG_FORTH_WORDS_KEY 
212a					DMARK "qDU" 
212a f5				push af  
212b 3a 3f 21			ld a, (.dmark)  
212e 32 6b ee			ld (debug_mark),a  
2131 3a 40 21			ld a, (.dmark+1)  
2134 32 6c ee			ld (debug_mark+1),a  
2137 3a 41 21			ld a, (.dmark+2)  
213a 32 6d ee			ld (debug_mark+2),a  
213d 18 03			jr .pastdmark  
213f ..			.dmark: db "qDU"  
2142 f1			.pastdmark: pop af  
2143			endm  
# End of macro DMARK
2143					CALLMONITOR 
2143 cd 6f ee			call debug_vector  
2146				endm  
# End of macro CALLMONITOR
2146				endif 
2146				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2146 cd 5e 1d			call macro_dsp_valuehl 
2149				endm 
# End of macro FORTH_DSP_VALUEHL
2149			 
2149 e5				push hl 
214a			 
214a				; is it a zero? 
214a			 
214a 3e 00			ld a, 0 
214c 84				add h 
214d 85				add l 
214e			 
214e e1				pop hl 
214f			 
214f fe 00			cp 0 
2151 28 03			jr z, .dup2orig 
2153			 
2153			 
2153 cd 67 1b			call forth_push_numhl 
2156			 
2156			 
2156			; TODO add floating point number detection 
2156			 
2156			.dup2orig: 
2156			 
2156				NEXTW 
2156 c3 14 1f			jp macro_next 
2159				endm 
# End of macro NEXTW
2159			.SWAP: 
2159			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2159 18				db WORD_SYS_CORE+OPCODE_SWAP             
215a 98 21			dw .COLN            
215c 05				db 4 + 1 
215d .. 00			db "SWAP",0              
2162				endm 
# End of macro CWHEAD
2162			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2162				if DEBUG_FORTH_WORDS_KEY 
2162					DMARK "SWP" 
2162 f5				push af  
2163 3a 77 21			ld a, (.dmark)  
2166 32 6b ee			ld (debug_mark),a  
2169 3a 78 21			ld a, (.dmark+1)  
216c 32 6c ee			ld (debug_mark+1),a  
216f 3a 79 21			ld a, (.dmark+2)  
2172 32 6d ee			ld (debug_mark+2),a  
2175 18 03			jr .pastdmark  
2177 ..			.dmark: db "SWP"  
217a f1			.pastdmark: pop af  
217b			endm  
# End of macro DMARK
217b					CALLMONITOR 
217b cd 6f ee			call debug_vector  
217e				endm  
# End of macro CALLMONITOR
217e				endif 
217e			 
217e			; TODO Use os stack swap memory 
217e				FORTH_DSP_VALUEHL 
217e cd 5e 1d			call macro_dsp_valuehl 
2181				endm 
# End of macro FORTH_DSP_VALUEHL
2181 e5				push hl     ; w2 
2182			 
2182				FORTH_DSP_POP 
2182 cd 16 1e			call macro_forth_dsp_pop 
2185				endm 
# End of macro FORTH_DSP_POP
2185			 
2185				FORTH_DSP_VALUEHL 
2185 cd 5e 1d			call macro_dsp_valuehl 
2188				endm 
# End of macro FORTH_DSP_VALUEHL
2188			 
2188				FORTH_DSP_POP 
2188 cd 16 1e			call macro_forth_dsp_pop 
218b				endm 
# End of macro FORTH_DSP_POP
218b			 
218b d1				pop de     ; w2	, hl = w1 
218c			 
218c eb				ex de, hl 
218d d5				push de 
218e			 
218e cd 67 1b			call forth_push_numhl 
2191			 
2191 e1				pop hl 
2192			 
2192 cd 67 1b			call forth_push_numhl 
2195				 
2195			 
2195				NEXTW 
2195 c3 14 1f			jp macro_next 
2198				endm 
# End of macro NEXTW
2198			.COLN: 
2198			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2198 19				db WORD_SYS_CORE+OPCODE_COLN             
2199 24 23			dw .SCOLN            
219b 02				db 1 + 1 
219c .. 00			db ":",0              
219e				endm 
# End of macro CWHEAD
219e			; | : ( -- )         Create new word | DONE 
219e			 
219e				if DEBUG_FORTH_WORDS_KEY 
219e					DMARK "CLN" 
219e f5				push af  
219f 3a b3 21			ld a, (.dmark)  
21a2 32 6b ee			ld (debug_mark),a  
21a5 3a b4 21			ld a, (.dmark+1)  
21a8 32 6c ee			ld (debug_mark+1),a  
21ab 3a b5 21			ld a, (.dmark+2)  
21ae 32 6d ee			ld (debug_mark+2),a  
21b1 18 03			jr .pastdmark  
21b3 ..			.dmark: db "CLN"  
21b6 f1			.pastdmark: pop af  
21b7			endm  
# End of macro DMARK
21b7					CALLMONITOR 
21b7 cd 6f ee			call debug_vector  
21ba				endm  
# End of macro CALLMONITOR
21ba				endif 
21ba			STACKFRAME OFF $8efe $989f 
21ba				if DEBUG_STACK_IMB 
21ba					if OFF 
21ba						exx 
21ba						ld de, $8efe 
21ba						ld a, d 
21ba						ld hl, curframe 
21ba						call hexout 
21ba						ld a, e 
21ba						ld hl, curframe+2 
21ba						call hexout 
21ba						ld hl, $8efe 
21ba						push hl 
21ba						ld hl, $989f 
21ba						push hl 
21ba						exx 
21ba					endif 
21ba				endif 
21ba			endm 
# End of macro STACKFRAME
21ba			; get parser buffer length  of new word 
21ba			 
21ba			 
21ba			 
21ba				; move tok past this to start of name defintition 
21ba				; TODO get word to define 
21ba				; TODO Move past word token 
21ba				; TODO get length of string up to the ';' 
21ba			 
21ba 2a c2 e5		ld hl, (os_tok_ptr) 
21bd 23			inc hl 
21be 23			inc hl 
21bf			 
21bf 3e 3b		ld a, ';' 
21c1 cd 64 11		call strlent 
21c4			 
21c4 7d			ld a,l 
21c5 32 b1 e2		ld (os_new_parse_len), a 
21c8			 
21c8			 
21c8			if DEBUG_FORTH_UWORD 
21c8 ed 5b c2 e5	ld de, (os_tok_ptr) 
21cc					DMARK ":01" 
21cc f5				push af  
21cd 3a e1 21			ld a, (.dmark)  
21d0 32 6b ee			ld (debug_mark),a  
21d3 3a e2 21			ld a, (.dmark+1)  
21d6 32 6c ee			ld (debug_mark+1),a  
21d9 3a e3 21			ld a, (.dmark+2)  
21dc 32 6d ee			ld (debug_mark+2),a  
21df 18 03			jr .pastdmark  
21e1 ..			.dmark: db ":01"  
21e4 f1			.pastdmark: pop af  
21e5			endm  
# End of macro DMARK
21e5			CALLMONITOR 
21e5 cd 6f ee			call debug_vector  
21e8				endm  
# End of macro CALLMONITOR
21e8			endif 
21e8			 
21e8			; 
21e8			;  new word memory layout: 
21e8			;  
21e8			;    : adg 6666 ;  
21e8			; 
21e8			;    db   1     ; user defined word  
21e8 23			inc hl    
21e9			;    dw   sysdict 
21e9 23			inc hl 
21ea 23			inc hl 
21eb			;    db <word len>+1 (for null) 
21eb 23			inc hl 
21ec			;    db .... <word> 
21ec			; 
21ec			 
21ec 23			inc hl    ; some extras for the word preamble before the above 
21ed 23			inc hl 
21ee 23			inc hl 
21ef 23			inc hl 
21f0 23			inc hl 
21f1 23			inc hl 
21f2 23			inc hl  
21f3 23			inc hl 
21f4 23			inc hl 
21f5 23			inc hl 
21f6 23			inc hl 
21f7 23			inc hl 
21f8 23			inc hl 
21f9 23			inc hl     ; TODO how many do we really need?     maybe only 6 
21fa			;       exec word buffer 
21fa			;	<ptr word>   
21fa 23			inc hl 
21fb 23			inc hl 
21fc			;       <word list><null term> 7F final term 
21fc			 
21fc			 
21fc			if DEBUG_FORTH_UWORD 
21fc					DMARK ":02" 
21fc f5				push af  
21fd 3a 11 22			ld a, (.dmark)  
2200 32 6b ee			ld (debug_mark),a  
2203 3a 12 22			ld a, (.dmark+1)  
2206 32 6c ee			ld (debug_mark+1),a  
2209 3a 13 22			ld a, (.dmark+2)  
220c 32 6d ee			ld (debug_mark+2),a  
220f 18 03			jr .pastdmark  
2211 ..			.dmark: db ":02"  
2214 f1			.pastdmark: pop af  
2215			endm  
# End of macro DMARK
2215			CALLMONITOR 
2215 cd 6f ee			call debug_vector  
2218				endm  
# End of macro CALLMONITOR
2218			endif 
2218			 
2218			 
2218				; malloc the size 
2218			 
2218 cd ce 11			call malloc 
221b 22 b3 e2			ld (os_new_malloc), hl     ; save malloc start 
221e			 
221e			;    db   1     ; user defined word  
221e 3e 01			ld a, WORD_SYS_UWORD  
2220 77				ld (hl), a 
2221			 
2221 23			inc hl    
2222			;    dw   sysdict 
2222 11 6c 20		ld de, sysdict       ; continue on with the scan to the system dict 
2225 73			ld (hl), e 
2226 23			inc hl 
2227 72			ld (hl), d 
2228 23			inc hl 
2229			 
2229			 
2229			;    Setup dict word 
2229			 
2229 23			inc hl 
222a 22 ad e2		ld (os_new_work_ptr), hl     ; save start of dict word  
222d			 
222d			; 1. get length of dict word 
222d			 
222d			 
222d 2a c2 e5		ld hl, (os_tok_ptr) 
2230 23			inc hl 
2231 23			inc hl    ; position to start of dict word 
2232 3e 00		ld a, 0 
2234 cd 64 11		call strlent 
2237			 
2237			 
2237 23			inc hl    ; to include null??? 
2238			 
2238			; write length of dict word 
2238			 
2238 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
223c 1b			dec de 
223d eb			ex de, hl 
223e 73			ld (hl), e 
223f eb			ex de, hl 
2240			 
2240			 
2240			 
2240			; copy  
2240 4d			ld c, l 
2241 06 00		ld b, 0 
2243 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2247 2a c2 e5		ld hl, (os_tok_ptr) 
224a 23			inc hl 
224b 23			inc hl    ; position to start of dict word 
224c			 
224c			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
224c			 
224c			; TODO need to convert word to upper case 
224c			 
224c			ucasetok:	 
224c 7e			ld a,(hl) 
224d cd 50 11		call toUpper 
2250 77			ld (hl),a 
2251 ed a0		ldi 
2253 f2 4c 22		jp p, ucasetok 
2256			 
2256			 
2256			 
2256			; de now points to start of where the word body code should be placed 
2256 ed 53 ad e2	ld (os_new_work_ptr), de 
225a			; hl now points to the words to throw at forthexec which needs to be copied 
225a 22 ab e2		ld (os_new_src_ptr), hl 
225d			 
225d			; TODO add 'call to forthexec' 
225d			 
225d			if DEBUG_FORTH_UWORD 
225d c5			push bc 
225e ed 4b b3 e2	ld bc, (os_new_malloc) 
2262					DMARK ":0x" 
2262 f5				push af  
2263 3a 77 22			ld a, (.dmark)  
2266 32 6b ee			ld (debug_mark),a  
2269 3a 78 22			ld a, (.dmark+1)  
226c 32 6c ee			ld (debug_mark+1),a  
226f 3a 79 22			ld a, (.dmark+2)  
2272 32 6d ee			ld (debug_mark+2),a  
2275 18 03			jr .pastdmark  
2277 ..			.dmark: db ":0x"  
227a f1			.pastdmark: pop af  
227b			endm  
# End of macro DMARK
227b			CALLMONITOR 
227b cd 6f ee			call debug_vector  
227e				endm  
# End of macro CALLMONITOR
227e c1			pop bc 
227f			endif 
227f			 
227f			 
227f			; create word preamble which should be: 
227f			 
227f			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
227f			 
227f			;    ld hl, <word code> 
227f			;    jp user_exec 
227f			;    <word code bytes> 
227f			 
227f			 
227f			;	inc de     ; TODO ??? or are we already past the word's null 
227f eb			ex de, hl 
2280			 
2280 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2282			 
2282 23			inc hl 
2283 22 a7 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2286 23			inc hl 
2287			 
2287 23			inc hl 
2288 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
228a			 
228a 01 02 4c		ld bc, user_exec 
228d 23			inc hl 
228e 71			ld (hl), c     ; poke address of user_exec 
228f 23			inc hl 
2290 70			ld (hl), b     
2291			; 
2291			;	inc hl 
2291			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2291			; 
2291			; 
2291			;	ld bc, macro_forth_rsp_next 
2291			;	inc hl 
2291			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2291			;	inc hl 
2291			;	ld (hl), b     
2291			; 
2291			;	inc hl 
2291			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2291			; 
2291			; 
2291			;	inc hl 
2291			;	ld bc, forthexec 
2291			;	ld (hl), c     ; poke address of forthexec 
2291			;	inc hl 
2291			;	ld (hl), b      
2291			; 
2291			;	inc hl 
2291			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2291			; 
2291			;	ld bc, user_dict_next 
2291			;	inc hl 
2291			;	ld (hl), c     ; poke address of forthexec 
2291			;	inc hl 
2291			;	ld (hl), b      
2291			 
2291			; hl is now where we need to copy the word byte data to save this 
2291			 
2291 23			inc hl 
2292 22 a9 e2		ld (os_new_exec), hl 
2295			 
2295			; copy definition 
2295			 
2295 eb			ex de, hl 
2296			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2296			;	inc de    ; skip the PC for this parse 
2296 3a b1 e2		ld a, (os_new_parse_len) 
2299 4f			ld c, a 
229a 06 00		ld b, 0 
229c ed b0		ldir		 ; copy defintion 
229e			 
229e			 
229e			; poke the address of where the new word bytes live for forthexec 
229e			 
229e 2a a7 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
22a1			 
22a1 ed 5b a9 e2	ld de, (os_new_exec)      
22a5			 
22a5 73			ld (hl), e 
22a6 23			inc hl 
22a7 72			ld (hl), d 
22a8			 
22a8				; TODO copy last user dict word next link to this word 
22a8				; TODO update last user dict word to point to this word 
22a8			; 
22a8			; hl f923 de 812a ; bc 811a 
22a8			 
22a8			if DEBUG_FORTH_UWORD 
22a8 c5			push bc 
22a9 ed 4b b3 e2	ld bc, (os_new_malloc) 
22ad					DMARK ":0A" 
22ad f5				push af  
22ae 3a c2 22			ld a, (.dmark)  
22b1 32 6b ee			ld (debug_mark),a  
22b4 3a c3 22			ld a, (.dmark+1)  
22b7 32 6c ee			ld (debug_mark+1),a  
22ba 3a c4 22			ld a, (.dmark+2)  
22bd 32 6d ee			ld (debug_mark+2),a  
22c0 18 03			jr .pastdmark  
22c2 ..			.dmark: db ":0A"  
22c5 f1			.pastdmark: pop af  
22c6			endm  
# End of macro DMARK
22c6			CALLMONITOR 
22c6 cd 6f ee			call debug_vector  
22c9				endm  
# End of macro CALLMONITOR
22c9 c1			pop bc 
22ca			endif 
22ca			if DEBUG_FORTH_UWORD 
22ca c5			push bc 
22cb ed 4b b3 e2	ld bc, (os_new_malloc) 
22cf 03			inc bc 
22d0 03			inc bc 
22d1 03			inc bc 
22d2 03			inc bc 
22d3 03			inc bc 
22d4 03			inc bc 
22d5 03			inc bc 
22d6 03			inc bc 
22d7			 
22d7					DMARK ":0B" 
22d7 f5				push af  
22d8 3a ec 22			ld a, (.dmark)  
22db 32 6b ee			ld (debug_mark),a  
22de 3a ed 22			ld a, (.dmark+1)  
22e1 32 6c ee			ld (debug_mark+1),a  
22e4 3a ee 22			ld a, (.dmark+2)  
22e7 32 6d ee			ld (debug_mark+2),a  
22ea 18 03			jr .pastdmark  
22ec ..			.dmark: db ":0B"  
22ef f1			.pastdmark: pop af  
22f0			endm  
# End of macro DMARK
22f0			CALLMONITOR 
22f0 cd 6f ee			call debug_vector  
22f3				endm  
# End of macro CALLMONITOR
22f3 c1			pop bc 
22f4			endif 
22f4			 
22f4			; update word dict linked list for new word 
22f4			 
22f4			 
22f4 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
22f7 23			inc hl     ; move to next work linked list ptr 
22f8			 
22f8 ed 5b b3 e2	ld de, (os_new_malloc)		 ; new next word 
22fc 73			ld (hl), e 
22fd 23			inc hl 
22fe 72			ld (hl), d 
22ff			 
22ff			if DEBUG_FORTH_UWORD 
22ff ed 4b be e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2303			endif 
2303			 
2303 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
2307			 
2307			 
2307			if DEBUG_FORTH_UWORD 
2307					DMARK ":0+" 
2307 f5				push af  
2308 3a 1c 23			ld a, (.dmark)  
230b 32 6b ee			ld (debug_mark),a  
230e 3a 1d 23			ld a, (.dmark+1)  
2311 32 6c ee			ld (debug_mark+1),a  
2314 3a 1e 23			ld a, (.dmark+2)  
2317 32 6d ee			ld (debug_mark+2),a  
231a 18 03			jr .pastdmark  
231c ..			.dmark: db ":0+"  
231f f1			.pastdmark: pop af  
2320			endm  
# End of macro DMARK
2320			CALLMONITOR 
2320 cd 6f ee			call debug_vector  
2323				endm  
# End of macro CALLMONITOR
2323			endif 
2323			 
2323			STACKFRAMECHK OFF $8efe $989f 
2323				if DEBUG_STACK_IMB 
2323					if OFF 
2323						exx 
2323						ld hl, $989f 
2323						pop de   ; $989f 
2323						call cmp16 
2323						jr nz, .spnosame 
2323						ld hl, $8efe 
2323						pop de   ; $8efe 
2323						call cmp16 
2323						jr z, .spfrsame 
2323						.spnosame: call showsperror 
2323						.spfrsame: nop 
2323						exx 
2323					endif 
2323				endif 
2323			endm 
# End of macro STACKFRAMECHK
2323			 
2323 c9			ret    ; dont process any remaining parser tokens as they form new word 
2324			 
2324			 
2324			 
2324			 
2324			;		NEXT 
2324			.SCOLN: 
2324			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2324 06			db OPCODE_SCOLN 
2325 70 23		dw .DROP 
2327 02			db 2 
2328 .. 00		db ";",0           
232a			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
232a				if DEBUG_FORTH_WORDS_KEY 
232a					DMARK "SCN" 
232a f5				push af  
232b 3a 3f 23			ld a, (.dmark)  
232e 32 6b ee			ld (debug_mark),a  
2331 3a 40 23			ld a, (.dmark+1)  
2334 32 6c ee			ld (debug_mark+1),a  
2337 3a 41 23			ld a, (.dmark+2)  
233a 32 6d ee			ld (debug_mark+2),a  
233d 18 03			jr .pastdmark  
233f ..			.dmark: db "SCN"  
2342 f1			.pastdmark: pop af  
2343			endm  
# End of macro DMARK
2343					CALLMONITOR 
2343 cd 6f ee			call debug_vector  
2346				endm  
# End of macro CALLMONITOR
2346				endif 
2346				FORTH_RSP_TOS 
2346 cd 25 1b			call macro_forth_rsp_tos 
2349				endm 
# End of macro FORTH_RSP_TOS
2349 e5				push hl 
234a				FORTH_RSP_POP 
234a cd 2f 1b			call macro_forth_rsp_pop 
234d				endm 
# End of macro FORTH_RSP_POP
234d e1				pop hl 
234e			;		ex de,hl 
234e 22 c2 e5			ld (os_tok_ptr),hl 
2351			 
2351			if DEBUG_FORTH_UWORD 
2351					DMARK "SCL" 
2351 f5				push af  
2352 3a 66 23			ld a, (.dmark)  
2355 32 6b ee			ld (debug_mark),a  
2358 3a 67 23			ld a, (.dmark+1)  
235b 32 6c ee			ld (debug_mark+1),a  
235e 3a 68 23			ld a, (.dmark+2)  
2361 32 6d ee			ld (debug_mark+2),a  
2364 18 03			jr .pastdmark  
2366 ..			.dmark: db "SCL"  
2369 f1			.pastdmark: pop af  
236a			endm  
# End of macro DMARK
236a			CALLMONITOR 
236a cd 6f ee			call debug_vector  
236d				endm  
# End of macro CALLMONITOR
236d			endif 
236d				NEXTW 
236d c3 14 1f			jp macro_next 
2370				endm 
# End of macro NEXTW
2370			 
2370			.DROP: 
2370			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2370 1b				db WORD_SYS_CORE+OPCODE_DROP             
2371 9b 23			dw .DUP2            
2373 05				db 4 + 1 
2374 .. 00			db "DROP",0              
2379				endm 
# End of macro CWHEAD
2379			; | DROP ( w -- )   drop the TOS item   | DONE 
2379				if DEBUG_FORTH_WORDS_KEY 
2379					DMARK "DRP" 
2379 f5				push af  
237a 3a 8e 23			ld a, (.dmark)  
237d 32 6b ee			ld (debug_mark),a  
2380 3a 8f 23			ld a, (.dmark+1)  
2383 32 6c ee			ld (debug_mark+1),a  
2386 3a 90 23			ld a, (.dmark+2)  
2389 32 6d ee			ld (debug_mark+2),a  
238c 18 03			jr .pastdmark  
238e ..			.dmark: db "DRP"  
2391 f1			.pastdmark: pop af  
2392			endm  
# End of macro DMARK
2392					CALLMONITOR 
2392 cd 6f ee			call debug_vector  
2395				endm  
# End of macro CALLMONITOR
2395				endif 
2395				FORTH_DSP_POP 
2395 cd 16 1e			call macro_forth_dsp_pop 
2398				endm 
# End of macro FORTH_DSP_POP
2398				NEXTW 
2398 c3 14 1f			jp macro_next 
239b				endm 
# End of macro NEXTW
239b			.DUP2: 
239b			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
239b 1c				db WORD_SYS_CORE+OPCODE_DUP2             
239c e0 23			dw .DROP2            
239e 05				db 4 + 1 
239f .. 00			db "2DUP",0              
23a4				endm 
# End of macro CWHEAD
23a4			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
23a4				if DEBUG_FORTH_WORDS_KEY 
23a4					DMARK "2DU" 
23a4 f5				push af  
23a5 3a b9 23			ld a, (.dmark)  
23a8 32 6b ee			ld (debug_mark),a  
23ab 3a ba 23			ld a, (.dmark+1)  
23ae 32 6c ee			ld (debug_mark+1),a  
23b1 3a bb 23			ld a, (.dmark+2)  
23b4 32 6d ee			ld (debug_mark+2),a  
23b7 18 03			jr .pastdmark  
23b9 ..			.dmark: db "2DU"  
23bc f1			.pastdmark: pop af  
23bd			endm  
# End of macro DMARK
23bd					CALLMONITOR 
23bd cd 6f ee			call debug_vector  
23c0				endm  
# End of macro CALLMONITOR
23c0				endif 
23c0				FORTH_DSP_VALUEHL 
23c0 cd 5e 1d			call macro_dsp_valuehl 
23c3				endm 
# End of macro FORTH_DSP_VALUEHL
23c3 e5				push hl      ; 2 
23c4			 
23c4				FORTH_DSP_POP 
23c4 cd 16 1e			call macro_forth_dsp_pop 
23c7				endm 
# End of macro FORTH_DSP_POP
23c7				 
23c7				FORTH_DSP_VALUEHL 
23c7 cd 5e 1d			call macro_dsp_valuehl 
23ca				endm 
# End of macro FORTH_DSP_VALUEHL
23ca			;		push hl      ; 1 
23ca			 
23ca				FORTH_DSP_POP 
23ca cd 16 1e			call macro_forth_dsp_pop 
23cd				endm 
# End of macro FORTH_DSP_POP
23cd			 
23cd			;		pop hl       ; 1 
23cd d1				pop de       ; 2 
23ce			 
23ce cd 67 1b			call forth_push_numhl 
23d1 eb				ex de, hl 
23d2 cd 67 1b			call forth_push_numhl 
23d5			 
23d5				 
23d5 eb				ex de, hl 
23d6			 
23d6 cd 67 1b			call forth_push_numhl 
23d9 eb				ex de, hl 
23da cd 67 1b			call forth_push_numhl 
23dd			 
23dd			 
23dd				NEXTW 
23dd c3 14 1f			jp macro_next 
23e0				endm 
# End of macro NEXTW
23e0			.DROP2: 
23e0			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
23e0 1d				db WORD_SYS_CORE+OPCODE_DROP2             
23e1 0f 24			dw .SWAP2            
23e3 06				db 5 + 1 
23e4 .. 00			db "2DROP",0              
23ea				endm 
# End of macro CWHEAD
23ea			; | 2DROP ( w w -- )    Double drop | DONE 
23ea				if DEBUG_FORTH_WORDS_KEY 
23ea					DMARK "2DR" 
23ea f5				push af  
23eb 3a ff 23			ld a, (.dmark)  
23ee 32 6b ee			ld (debug_mark),a  
23f1 3a 00 24			ld a, (.dmark+1)  
23f4 32 6c ee			ld (debug_mark+1),a  
23f7 3a 01 24			ld a, (.dmark+2)  
23fa 32 6d ee			ld (debug_mark+2),a  
23fd 18 03			jr .pastdmark  
23ff ..			.dmark: db "2DR"  
2402 f1			.pastdmark: pop af  
2403			endm  
# End of macro DMARK
2403					CALLMONITOR 
2403 cd 6f ee			call debug_vector  
2406				endm  
# End of macro CALLMONITOR
2406				endif 
2406				FORTH_DSP_POP 
2406 cd 16 1e			call macro_forth_dsp_pop 
2409				endm 
# End of macro FORTH_DSP_POP
2409				FORTH_DSP_POP 
2409 cd 16 1e			call macro_forth_dsp_pop 
240c				endm 
# End of macro FORTH_DSP_POP
240c				NEXTW 
240c c3 14 1f			jp macro_next 
240f				endm 
# End of macro NEXTW
240f			.SWAP2: 
240f			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
240f 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2410 38 24			dw .AT            
2412 06				db 5 + 1 
2413 .. 00			db "2SWAP",0              
2419				endm 
# End of macro CWHEAD
2419			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2419				if DEBUG_FORTH_WORDS_KEY 
2419					DMARK "2SW" 
2419 f5				push af  
241a 3a 2e 24			ld a, (.dmark)  
241d 32 6b ee			ld (debug_mark),a  
2420 3a 2f 24			ld a, (.dmark+1)  
2423 32 6c ee			ld (debug_mark+1),a  
2426 3a 30 24			ld a, (.dmark+2)  
2429 32 6d ee			ld (debug_mark+2),a  
242c 18 03			jr .pastdmark  
242e ..			.dmark: db "2SW"  
2431 f1			.pastdmark: pop af  
2432			endm  
# End of macro DMARK
2432					CALLMONITOR 
2432 cd 6f ee			call debug_vector  
2435				endm  
# End of macro CALLMONITOR
2435				endif 
2435			; TODO Use os stack swap memory 
2435				NEXTW 
2435 c3 14 1f			jp macro_next 
2438				endm 
# End of macro NEXTW
2438			.AT: 
2438			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2438 1f				db WORD_SYS_CORE+OPCODE_AT             
2439 6a 24			dw .CAT            
243b 02				db 1 + 1 
243c .. 00			db "@",0              
243e				endm 
# End of macro CWHEAD
243e			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
243e			 
243e				if DEBUG_FORTH_WORDS_KEY 
243e					DMARK "AT." 
243e f5				push af  
243f 3a 53 24			ld a, (.dmark)  
2442 32 6b ee			ld (debug_mark),a  
2445 3a 54 24			ld a, (.dmark+1)  
2448 32 6c ee			ld (debug_mark+1),a  
244b 3a 55 24			ld a, (.dmark+2)  
244e 32 6d ee			ld (debug_mark+2),a  
2451 18 03			jr .pastdmark  
2453 ..			.dmark: db "AT."  
2456 f1			.pastdmark: pop af  
2457			endm  
# End of macro DMARK
2457					CALLMONITOR 
2457 cd 6f ee			call debug_vector  
245a				endm  
# End of macro CALLMONITOR
245a				endif 
245a			.getbyteat:	 
245a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
245a cd 5e 1d			call macro_dsp_valuehl 
245d				endm 
# End of macro FORTH_DSP_VALUEHL
245d				 
245d			;		push hl 
245d			 
245d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
245d cd 16 1e			call macro_forth_dsp_pop 
2460				endm 
# End of macro FORTH_DSP_POP
2460			 
2460			;		pop hl 
2460			 
2460 7e				ld a, (hl) 
2461			 
2461 6f				ld l, a 
2462 26 00			ld h, 0 
2464 cd 67 1b			call forth_push_numhl 
2467			 
2467				NEXTW 
2467 c3 14 1f			jp macro_next 
246a				endm 
# End of macro NEXTW
246a			.CAT: 
246a			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
246a 20				db WORD_SYS_CORE+OPCODE_CAT             
246b 93 24			dw .BANG            
246d 03				db 2 + 1 
246e .. 00			db "C@",0              
2471				endm 
# End of macro CWHEAD
2471			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2471				if DEBUG_FORTH_WORDS_KEY 
2471					DMARK "CAA" 
2471 f5				push af  
2472 3a 86 24			ld a, (.dmark)  
2475 32 6b ee			ld (debug_mark),a  
2478 3a 87 24			ld a, (.dmark+1)  
247b 32 6c ee			ld (debug_mark+1),a  
247e 3a 88 24			ld a, (.dmark+2)  
2481 32 6d ee			ld (debug_mark+2),a  
2484 18 03			jr .pastdmark  
2486 ..			.dmark: db "CAA"  
2489 f1			.pastdmark: pop af  
248a			endm  
# End of macro DMARK
248a					CALLMONITOR 
248a cd 6f ee			call debug_vector  
248d				endm  
# End of macro CALLMONITOR
248d				endif 
248d c3 5a 24			jp .getbyteat 
2490				NEXTW 
2490 c3 14 1f			jp macro_next 
2493				endm 
# End of macro NEXTW
2493			.BANG: 
2493			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2493 21				db WORD_SYS_CORE+OPCODE_BANG             
2494 c9 24			dw .CBANG            
2496 02				db 1 + 1 
2497 .. 00			db "!",0              
2499				endm 
# End of macro CWHEAD
2499			; | ! ( x w -- ) Store x at address w      | DONE 
2499				if DEBUG_FORTH_WORDS_KEY 
2499					DMARK "BNG" 
2499 f5				push af  
249a 3a ae 24			ld a, (.dmark)  
249d 32 6b ee			ld (debug_mark),a  
24a0 3a af 24			ld a, (.dmark+1)  
24a3 32 6c ee			ld (debug_mark+1),a  
24a6 3a b0 24			ld a, (.dmark+2)  
24a9 32 6d ee			ld (debug_mark+2),a  
24ac 18 03			jr .pastdmark  
24ae ..			.dmark: db "BNG"  
24b1 f1			.pastdmark: pop af  
24b2			endm  
# End of macro DMARK
24b2					CALLMONITOR 
24b2 cd 6f ee			call debug_vector  
24b5				endm  
# End of macro CALLMONITOR
24b5				endif 
24b5			 
24b5			.storebyteat:		 
24b5				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24b5 cd 5e 1d			call macro_dsp_valuehl 
24b8				endm 
# End of macro FORTH_DSP_VALUEHL
24b8				 
24b8 e5				push hl 
24b9			 
24b9				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24b9 cd 16 1e			call macro_forth_dsp_pop 
24bc				endm 
# End of macro FORTH_DSP_POP
24bc			 
24bc				; get byte to poke 
24bc			 
24bc				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24bc cd 5e 1d			call macro_dsp_valuehl 
24bf				endm 
# End of macro FORTH_DSP_VALUEHL
24bf e5				push hl 
24c0			 
24c0			 
24c0				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24c0 cd 16 1e			call macro_forth_dsp_pop 
24c3				endm 
# End of macro FORTH_DSP_POP
24c3			 
24c3			 
24c3 d1				pop de 
24c4 e1				pop hl 
24c5			 
24c5 73				ld (hl),e 
24c6			 
24c6			 
24c6				NEXTW 
24c6 c3 14 1f			jp macro_next 
24c9				endm 
# End of macro NEXTW
24c9			.CBANG: 
24c9			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
24c9 22				db WORD_SYS_CORE+OPCODE_CBANG             
24ca f2 24			dw .SCALL            
24cc 03				db 2 + 1 
24cd .. 00			db "C!",0              
24d0				endm 
# End of macro CWHEAD
24d0			; | C!  ( x w -- ) Store x at address w  | DONE 
24d0				if DEBUG_FORTH_WORDS_KEY 
24d0					DMARK "CBA" 
24d0 f5				push af  
24d1 3a e5 24			ld a, (.dmark)  
24d4 32 6b ee			ld (debug_mark),a  
24d7 3a e6 24			ld a, (.dmark+1)  
24da 32 6c ee			ld (debug_mark+1),a  
24dd 3a e7 24			ld a, (.dmark+2)  
24e0 32 6d ee			ld (debug_mark+2),a  
24e3 18 03			jr .pastdmark  
24e5 ..			.dmark: db "CBA"  
24e8 f1			.pastdmark: pop af  
24e9			endm  
# End of macro DMARK
24e9					CALLMONITOR 
24e9 cd 6f ee			call debug_vector  
24ec				endm  
# End of macro CALLMONITOR
24ec				endif 
24ec c3 b5 24			jp .storebyteat 
24ef				NEXTW 
24ef c3 14 1f			jp macro_next 
24f2				endm 
# End of macro NEXTW
24f2			.SCALL: 
24f2			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
24f2 23				db WORD_SYS_CORE+OPCODE_SCALL             
24f3 26 25			dw .DEPTH            
24f5 05				db 4 + 1 
24f6 .. 00			db "CALL",0              
24fb				endm 
# End of macro CWHEAD
24fb			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
24fb				if DEBUG_FORTH_WORDS_KEY 
24fb					DMARK "CLL" 
24fb f5				push af  
24fc 3a 10 25			ld a, (.dmark)  
24ff 32 6b ee			ld (debug_mark),a  
2502 3a 11 25			ld a, (.dmark+1)  
2505 32 6c ee			ld (debug_mark+1),a  
2508 3a 12 25			ld a, (.dmark+2)  
250b 32 6d ee			ld (debug_mark+2),a  
250e 18 03			jr .pastdmark  
2510 ..			.dmark: db "CLL"  
2513 f1			.pastdmark: pop af  
2514			endm  
# End of macro DMARK
2514					CALLMONITOR 
2514 cd 6f ee			call debug_vector  
2517				endm  
# End of macro CALLMONITOR
2517				endif 
2517			 
2517				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2517 cd 5e 1d			call macro_dsp_valuehl 
251a				endm 
# End of macro FORTH_DSP_VALUEHL
251a			 
251a			;		push hl 
251a			 
251a				; destroy value TOS 
251a			 
251a				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
251a cd 16 1e			call macro_forth_dsp_pop 
251d				endm 
# End of macro FORTH_DSP_POP
251d			 
251d					 
251d			;		pop hl 
251d			 
251d				; how to do a call with hl???? save SP? 
251d cd b8 1e			call forth_call_hl 
2520			 
2520			 
2520				; TODO push value back onto stack for another op etc 
2520			 
2520 cd 67 1b			call forth_push_numhl 
2523				NEXTW 
2523 c3 14 1f			jp macro_next 
2526				endm 
# End of macro NEXTW
2526			.DEPTH: 
2526			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2526 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2527 63 25			dw .OVER            
2529 06				db 5 + 1 
252a .. 00			db "DEPTH",0              
2530				endm 
# End of macro CWHEAD
2530			; | DEPTH ( -- u ) Push count of stack | DONE 
2530				; take current TOS and remove from base value div by two to get count 
2530				if DEBUG_FORTH_WORDS_KEY 
2530					DMARK "DEP" 
2530 f5				push af  
2531 3a 45 25			ld a, (.dmark)  
2534 32 6b ee			ld (debug_mark),a  
2537 3a 46 25			ld a, (.dmark+1)  
253a 32 6c ee			ld (debug_mark+1),a  
253d 3a 47 25			ld a, (.dmark+2)  
2540 32 6d ee			ld (debug_mark+2),a  
2543 18 03			jr .pastdmark  
2545 ..			.dmark: db "DEP"  
2548 f1			.pastdmark: pop af  
2549			endm  
# End of macro DMARK
2549					CALLMONITOR 
2549 cd 6f ee			call debug_vector  
254c				endm  
# End of macro CALLMONITOR
254c				endif 
254c			 
254c			 
254c 2a ee e9		ld hl, (cli_data_sp) 
254f 11 28 e8		ld de, cli_data_stack 
2552 ed 52		sbc hl,de 
2554			 
2554			; div by size of stack item 
2554			 
2554 5d			ld e,l 
2555 0e 03		ld c, 3 
2557 cd 76 0d		call Div8 
255a			 
255a 6f			ld l,a 
255b 26 00		ld h,0 
255d			 
255d			;srl h 
255d			;rr l 
255d			 
255d cd 67 1b			call forth_push_numhl 
2560				NEXTW 
2560 c3 14 1f			jp macro_next 
2563				endm 
# End of macro NEXTW
2563			.OVER: 
2563			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2563 42				db WORD_SYS_CORE+46             
2564 aa 25			dw .PAUSE            
2566 05				db 4 + 1 
2567 .. 00			db "OVER",0              
256c				endm 
# End of macro CWHEAD
256c			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
256c				if DEBUG_FORTH_WORDS_KEY 
256c					DMARK "OVR" 
256c f5				push af  
256d 3a 81 25			ld a, (.dmark)  
2570 32 6b ee			ld (debug_mark),a  
2573 3a 82 25			ld a, (.dmark+1)  
2576 32 6c ee			ld (debug_mark+1),a  
2579 3a 83 25			ld a, (.dmark+2)  
257c 32 6d ee			ld (debug_mark+2),a  
257f 18 03			jr .pastdmark  
2581 ..			.dmark: db "OVR"  
2584 f1			.pastdmark: pop af  
2585			endm  
# End of macro DMARK
2585					CALLMONITOR 
2585 cd 6f ee			call debug_vector  
2588				endm  
# End of macro CALLMONITOR
2588				endif 
2588			 
2588			; TODO Use os stack swap memory 
2588				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2588 cd 5e 1d			call macro_dsp_valuehl 
258b				endm 
# End of macro FORTH_DSP_VALUEHL
258b e5				push hl    ; n2 
258c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
258c cd 16 1e			call macro_forth_dsp_pop 
258f				endm 
# End of macro FORTH_DSP_POP
258f			 
258f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
258f cd 5e 1d			call macro_dsp_valuehl 
2592				endm 
# End of macro FORTH_DSP_VALUEHL
2592 e5				push hl    ; n1 
2593				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2593 cd 16 1e			call macro_forth_dsp_pop 
2596				endm 
# End of macro FORTH_DSP_POP
2596			 
2596 d1				pop de     ; n1 
2597 e1				pop hl     ; n2 
2598			 
2598 d5				push de 
2599 e5				push hl 
259a d5				push de 
259b			 
259b				; push back  
259b			 
259b e1				pop hl 
259c cd 67 1b			call forth_push_numhl 
259f e1				pop hl 
25a0 cd 67 1b			call forth_push_numhl 
25a3 e1				pop hl 
25a4 cd 67 1b			call forth_push_numhl 
25a7				NEXTW 
25a7 c3 14 1f			jp macro_next 
25aa				endm 
# End of macro NEXTW
25aa			 
25aa			.PAUSE: 
25aa			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
25aa 43				db WORD_SYS_CORE+47             
25ab df 25			dw .PAUSES            
25ad 08				db 7 + 1 
25ae .. 00			db "PAUSEMS",0              
25b6				endm 
# End of macro CWHEAD
25b6			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
25b6				if DEBUG_FORTH_WORDS_KEY 
25b6					DMARK "PMS" 
25b6 f5				push af  
25b7 3a cb 25			ld a, (.dmark)  
25ba 32 6b ee			ld (debug_mark),a  
25bd 3a cc 25			ld a, (.dmark+1)  
25c0 32 6c ee			ld (debug_mark+1),a  
25c3 3a cd 25			ld a, (.dmark+2)  
25c6 32 6d ee			ld (debug_mark+2),a  
25c9 18 03			jr .pastdmark  
25cb ..			.dmark: db "PMS"  
25ce f1			.pastdmark: pop af  
25cf			endm  
# End of macro DMARK
25cf					CALLMONITOR 
25cf cd 6f ee			call debug_vector  
25d2				endm  
# End of macro CALLMONITOR
25d2				endif 
25d2				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25d2 cd 5e 1d			call macro_dsp_valuehl 
25d5				endm 
# End of macro FORTH_DSP_VALUEHL
25d5			;		push hl    ; n2 
25d5				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25d5 cd 16 1e			call macro_forth_dsp_pop 
25d8				endm 
# End of macro FORTH_DSP_POP
25d8			;		pop hl 
25d8			 
25d8 7d				ld a, l 
25d9 cd d6 0a			call aDelayInMS 
25dc			       NEXTW 
25dc c3 14 1f			jp macro_next 
25df				endm 
# End of macro NEXTW
25df			.PAUSES:  
25df			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
25df 44				db WORD_SYS_CORE+48             
25e0 4e 26			dw .ROT            
25e2 06				db 5 + 1 
25e3 .. 00			db "PAUSE",0              
25e9				endm 
# End of macro CWHEAD
25e9			; | PAUSE ( n -- )  Pause for n seconds | DONE 
25e9				if DEBUG_FORTH_WORDS_KEY 
25e9					DMARK "PAU" 
25e9 f5				push af  
25ea 3a fe 25			ld a, (.dmark)  
25ed 32 6b ee			ld (debug_mark),a  
25f0 3a ff 25			ld a, (.dmark+1)  
25f3 32 6c ee			ld (debug_mark+1),a  
25f6 3a 00 26			ld a, (.dmark+2)  
25f9 32 6d ee			ld (debug_mark+2),a  
25fc 18 03			jr .pastdmark  
25fe ..			.dmark: db "PAU"  
2601 f1			.pastdmark: pop af  
2602			endm  
# End of macro DMARK
2602					CALLMONITOR 
2602 cd 6f ee			call debug_vector  
2605				endm  
# End of macro CALLMONITOR
2605				endif 
2605				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2605 cd 5e 1d			call macro_dsp_valuehl 
2608				endm 
# End of macro FORTH_DSP_VALUEHL
2608			;		push hl    ; n2 
2608				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2608 cd 16 1e			call macro_forth_dsp_pop 
260b				endm 
# End of macro FORTH_DSP_POP
260b			;		pop hl 
260b 45				ld b, l 
260c				if DEBUG_FORTH_WORDS 
260c					DMARK "PAU" 
260c f5				push af  
260d 3a 21 26			ld a, (.dmark)  
2610 32 6b ee			ld (debug_mark),a  
2613 3a 22 26			ld a, (.dmark+1)  
2616 32 6c ee			ld (debug_mark+1),a  
2619 3a 23 26			ld a, (.dmark+2)  
261c 32 6d ee			ld (debug_mark+2),a  
261f 18 03			jr .pastdmark  
2621 ..			.dmark: db "PAU"  
2624 f1			.pastdmark: pop af  
2625			endm  
# End of macro DMARK
2625					CALLMONITOR 
2625 cd 6f ee			call debug_vector  
2628				endm  
# End of macro CALLMONITOR
2628				endif 
2628 c5			.pauses1:	push bc 
2629 cd f1 0a			call delay1s 
262c c1				pop bc 
262d				if DEBUG_FORTH_WORDS 
262d					DMARK "PA1" 
262d f5				push af  
262e 3a 42 26			ld a, (.dmark)  
2631 32 6b ee			ld (debug_mark),a  
2634 3a 43 26			ld a, (.dmark+1)  
2637 32 6c ee			ld (debug_mark+1),a  
263a 3a 44 26			ld a, (.dmark+2)  
263d 32 6d ee			ld (debug_mark+2),a  
2640 18 03			jr .pastdmark  
2642 ..			.dmark: db "PA1"  
2645 f1			.pastdmark: pop af  
2646			endm  
# End of macro DMARK
2646					CALLMONITOR 
2646 cd 6f ee			call debug_vector  
2649				endm  
# End of macro CALLMONITOR
2649				endif 
2649 10 dd			djnz .pauses1 
264b			 
264b			       NEXTW 
264b c3 14 1f			jp macro_next 
264e				endm 
# End of macro NEXTW
264e			.ROT: 
264e			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
264e 45				db WORD_SYS_CORE+49             
264f 9c 26			dw .UWORDS            
2651 04				db 3 + 1 
2652 .. 00			db "ROT",0              
2656				endm 
# End of macro CWHEAD
2656			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2656				if DEBUG_FORTH_WORDS_KEY 
2656					DMARK "ROT" 
2656 f5				push af  
2657 3a 6b 26			ld a, (.dmark)  
265a 32 6b ee			ld (debug_mark),a  
265d 3a 6c 26			ld a, (.dmark+1)  
2660 32 6c ee			ld (debug_mark+1),a  
2663 3a 6d 26			ld a, (.dmark+2)  
2666 32 6d ee			ld (debug_mark+2),a  
2669 18 03			jr .pastdmark  
266b ..			.dmark: db "ROT"  
266e f1			.pastdmark: pop af  
266f			endm  
# End of macro DMARK
266f					CALLMONITOR 
266f cd 6f ee			call debug_vector  
2672				endm  
# End of macro CALLMONITOR
2672				endif 
2672			 
2672			; TODO Use os stack swap memory 
2672				FORTH_DSP_VALUEHL 
2672 cd 5e 1d			call macro_dsp_valuehl 
2675				endm 
# End of macro FORTH_DSP_VALUEHL
2675 e5				push hl    ; u3  
2676			 
2676				FORTH_DSP_POP 
2676 cd 16 1e			call macro_forth_dsp_pop 
2679				endm 
# End of macro FORTH_DSP_POP
2679			 
2679				FORTH_DSP_VALUEHL 
2679 cd 5e 1d			call macro_dsp_valuehl 
267c				endm 
# End of macro FORTH_DSP_VALUEHL
267c e5				push hl     ; u2 
267d			 
267d				FORTH_DSP_POP 
267d cd 16 1e			call macro_forth_dsp_pop 
2680				endm 
# End of macro FORTH_DSP_POP
2680			 
2680				FORTH_DSP_VALUEHL 
2680 cd 5e 1d			call macro_dsp_valuehl 
2683				endm 
# End of macro FORTH_DSP_VALUEHL
2683 e5				push hl     ; u1 
2684			 
2684				FORTH_DSP_POP 
2684 cd 16 1e			call macro_forth_dsp_pop 
2687				endm 
# End of macro FORTH_DSP_POP
2687			 
2687 c1				pop bc      ; u1 
2688 e1				pop hl      ; u2 
2689 d1				pop de      ; u3 
268a			 
268a			 
268a c5				push bc 
268b d5				push de 
268c e5				push hl 
268d			 
268d			 
268d e1				pop hl 
268e cd 67 1b			call forth_push_numhl 
2691			 
2691 e1				pop hl 
2692 cd 67 1b			call forth_push_numhl 
2695			 
2695 e1				pop hl 
2696 cd 67 1b			call forth_push_numhl 
2699				 
2699			 
2699			 
2699			 
2699			 
2699			 
2699			       NEXTW 
2699 c3 14 1f			jp macro_next 
269c				endm 
# End of macro NEXTW
269c			 
269c			.UWORDS: 
269c			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
269c 50				db WORD_SYS_CORE+60             
269d 5e 27			dw .BP            
269f 07				db 6 + 1 
26a0 .. 00			db "UWORDS",0              
26a7				endm 
# End of macro CWHEAD
26a7			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
26a7			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
26a7			; | | Following the count are the individual words. 
26a7			; | | 
26a7			; | | e.g. UWORDS 
26a7			; | | BOX DIRLIST 2 
26a7			; | |  
26a7			; | | Can be used to save the words to storage via: 
26a7			; | | UWORDS $01 DO $01 APPEND LOOP 
26a7			if DEBUG_FORTH_WORDS_KEY 
26a7				DMARK "UWR" 
26a7 f5				push af  
26a8 3a bc 26			ld a, (.dmark)  
26ab 32 6b ee			ld (debug_mark),a  
26ae 3a bd 26			ld a, (.dmark+1)  
26b1 32 6c ee			ld (debug_mark+1),a  
26b4 3a be 26			ld a, (.dmark+2)  
26b7 32 6d ee			ld (debug_mark+2),a  
26ba 18 03			jr .pastdmark  
26bc ..			.dmark: db "UWR"  
26bf f1			.pastdmark: pop af  
26c0			endm  
# End of macro DMARK
26c0				CALLMONITOR 
26c0 cd 6f ee			call debug_vector  
26c3				endm  
# End of macro CALLMONITOR
26c3			endif 
26c3 21 5c 65			ld hl, baseram 
26c6				;ld hl, baseusermem 
26c6 01 00 00			ld bc, 0    ; start a counter 
26c9			 
26c9			; skip dict stub 
26c9			 
26c9 cd 65 20			call forth_tok_next 
26cc			 
26cc			 
26cc			; while we have words to look for 
26cc			 
26cc 7e			.douscan:	ld a, (hl)      
26cd			if DEBUG_FORTH_WORDS 
26cd				DMARK "UWs" 
26cd f5				push af  
26ce 3a e2 26			ld a, (.dmark)  
26d1 32 6b ee			ld (debug_mark),a  
26d4 3a e3 26			ld a, (.dmark+1)  
26d7 32 6c ee			ld (debug_mark+1),a  
26da 3a e4 26			ld a, (.dmark+2)  
26dd 32 6d ee			ld (debug_mark+2),a  
26e0 18 03			jr .pastdmark  
26e2 ..			.dmark: db "UWs"  
26e5 f1			.pastdmark: pop af  
26e6			endm  
# End of macro DMARK
26e6				CALLMONITOR 
26e6 cd 6f ee			call debug_vector  
26e9				endm  
# End of macro CALLMONITOR
26e9			endif 
26e9 fe 00			cp WORD_SYS_END 
26eb 28 4d			jr z, .udone 
26ed fe 01			cp WORD_SYS_UWORD 
26ef 20 44			jr nz, .nuword 
26f1			 
26f1			if DEBUG_FORTH_WORDS 
26f1				DMARK "UWu" 
26f1 f5				push af  
26f2 3a 06 27			ld a, (.dmark)  
26f5 32 6b ee			ld (debug_mark),a  
26f8 3a 07 27			ld a, (.dmark+1)  
26fb 32 6c ee			ld (debug_mark+1),a  
26fe 3a 08 27			ld a, (.dmark+2)  
2701 32 6d ee			ld (debug_mark+2),a  
2704 18 03			jr .pastdmark  
2706 ..			.dmark: db "UWu"  
2709 f1			.pastdmark: pop af  
270a			endm  
# End of macro DMARK
270a				CALLMONITOR 
270a cd 6f ee			call debug_vector  
270d				endm  
# End of macro CALLMONITOR
270d			endif 
270d				; we have a uword so push its name to the stack 
270d			 
270d e5				push hl  ; save so we can move to next dict block 
270e			 
270e				; skip opcode 
270e 23				inc hl  
270f				; skip next ptr 
270f 23				inc hl  
2710 23				inc hl 
2711				; skip len 
2711 23				inc hl 
2712			if DEBUG_FORTH_WORDS 
2712				DMARK "UWt" 
2712 f5				push af  
2713 3a 27 27			ld a, (.dmark)  
2716 32 6b ee			ld (debug_mark),a  
2719 3a 28 27			ld a, (.dmark+1)  
271c 32 6c ee			ld (debug_mark+1),a  
271f 3a 29 27			ld a, (.dmark+2)  
2722 32 6d ee			ld (debug_mark+2),a  
2725 18 03			jr .pastdmark  
2727 ..			.dmark: db "UWt"  
272a f1			.pastdmark: pop af  
272b			endm  
# End of macro DMARK
272b				CALLMONITOR 
272b cd 6f ee			call debug_vector  
272e				endm  
# End of macro CALLMONITOR
272e			endif 
272e 03				inc bc 
272f			 
272f c5				push bc 
2730 cd d5 1b			call forth_push_str 
2733 c1				pop bc 
2734			 
2734 e1				pop hl 	 
2735			 
2735 cd 65 20		.nuword:	call forth_tok_next 
2738 18 92			jr .douscan  
273a			 
273a			.udone:		 ; push count of uwords found 
273a c5				push bc 
273b e1				pop hl 
273c			 
273c			if DEBUG_FORTH_WORDS 
273c				DMARK "UWc" 
273c f5				push af  
273d 3a 51 27			ld a, (.dmark)  
2740 32 6b ee			ld (debug_mark),a  
2743 3a 52 27			ld a, (.dmark+1)  
2746 32 6c ee			ld (debug_mark+1),a  
2749 3a 53 27			ld a, (.dmark+2)  
274c 32 6d ee			ld (debug_mark+2),a  
274f 18 03			jr .pastdmark  
2751 ..			.dmark: db "UWc"  
2754 f1			.pastdmark: pop af  
2755			endm  
# End of macro DMARK
2755				CALLMONITOR 
2755 cd 6f ee			call debug_vector  
2758				endm  
# End of macro CALLMONITOR
2758			endif 
2758 cd 67 1b			call forth_push_numhl 
275b			 
275b			 
275b			       NEXTW 
275b c3 14 1f			jp macro_next 
275e				endm 
# End of macro NEXTW
275e			 
275e			.BP: 
275e			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
275e 54				db WORD_SYS_CORE+64             
275f 98 27			dw .MONITOR            
2761 03				db 2 + 1 
2762 .. 00			db "BP",0              
2765				endm 
# End of macro CWHEAD
2765			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2765			; | | $00 Will enable the break points within specific code paths 
2765			; | | $01 Will disable break points 
2765			; | |  
2765			; | | By default break points are off. Either the above can be used to enable them 
2765			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2765			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2765			; | | can disable break points. Exiting will then continue boot process. 
2765				; get byte count 
2765				if DEBUG_FORTH_WORDS_KEY 
2765					DMARK "BP." 
2765 f5				push af  
2766 3a 7a 27			ld a, (.dmark)  
2769 32 6b ee			ld (debug_mark),a  
276c 3a 7b 27			ld a, (.dmark+1)  
276f 32 6c ee			ld (debug_mark+1),a  
2772 3a 7c 27			ld a, (.dmark+2)  
2775 32 6d ee			ld (debug_mark+2),a  
2778 18 03			jr .pastdmark  
277a ..			.dmark: db "BP."  
277d f1			.pastdmark: pop af  
277e			endm  
# End of macro DMARK
277e					CALLMONITOR 
277e cd 6f ee			call debug_vector  
2781				endm  
# End of macro CALLMONITOR
2781				endif 
2781			 
2781				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2781 cd 5e 1d			call macro_dsp_valuehl 
2784				endm 
# End of macro FORTH_DSP_VALUEHL
2784			 
2784			;		push hl 
2784			 
2784				; destroy value TOS 
2784			 
2784				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2784 cd 16 1e			call macro_forth_dsp_pop 
2787				endm 
# End of macro FORTH_DSP_POP
2787			 
2787			;		pop hl 
2787			 
2787 3e 00			ld a,0 
2789 bd				cp l 
278a 28 06			jr z, .bpset 
278c			;		ld a, '*' 
278c cd 09 15			call bp_off 
278f				NEXTW 
278f c3 14 1f			jp macro_next 
2792				endm 
# End of macro NEXTW
2792			 
2792			.bpset:	 
2792				;	ld (os_view_disable), a 
2792 cd fd 14			call bp_on 
2795			 
2795			 
2795				NEXTW 
2795 c3 14 1f			jp macro_next 
2798				endm 
# End of macro NEXTW
2798			 
2798			 
2798			.MONITOR: 
2798			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2798 55				db WORD_SYS_CORE+65             
2799 c9 27			dw .MALLOC            
279b 08				db 7 + 1 
279c .. 00			db "MONITOR",0              
27a4				endm 
# End of macro CWHEAD
27a4			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
27a4			; | | At start the current various registers will be displayed with contents. 
27a4			; | | Top right corner will show the most recent debug marker seen. 
27a4			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
27a4			; | | and the return stack pointer (RSP). 
27a4			; | | Pressing: 
27a4			; | |    1 - Initial screen 
27a4			; | |    2 - Display a data dump of HL 
27a4			; | |    3 - Display a data dump of DE 
27a4			; | |    4 - Display a data dump of BC 
27a4			; | |    5 - Display a data dump of HL 
27a4			; | |    6 - Display a data dump of DSP 
27a4			; | |    7 - Display a data dump of RSP 
27a4			; | |    8 - Display a data dump of what is at DSP 
27a4			; | |    9 - Display a data dump of what is at RSP 
27a4			; | |    0 - Exit monitor and continue running. This will also enable break points 
27a4			; | |    * - Disable break points 
27a4			; | |    # - Enter traditional monitor mode 
27a4			; | | 
27a4			; | | Monitor Mode 
27a4			; | | ------------ 
27a4			; | | A prompt of '>' will be shown for various commands: 
27a4			; | |    D xxxx - Display a data dump starting from hex address xxxx 
27a4			; | |    C - Continue display a data dump from the last set address 
27a4			; | |    M xxxx - Set start of memory edit at address xx 
27a4			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
27a4			; | |    G xxxx - Exec code at specific address 
27a4			; | |    Q - Return to previous 
27a4				if DEBUG_FORTH_WORDS_KEY 
27a4					DMARK "MON" 
27a4 f5				push af  
27a5 3a b9 27			ld a, (.dmark)  
27a8 32 6b ee			ld (debug_mark),a  
27ab 3a ba 27			ld a, (.dmark+1)  
27ae 32 6c ee			ld (debug_mark+1),a  
27b1 3a bb 27			ld a, (.dmark+2)  
27b4 32 6d ee			ld (debug_mark+2),a  
27b7 18 03			jr .pastdmark  
27b9 ..			.dmark: db "MON"  
27bc f1			.pastdmark: pop af  
27bd			endm  
# End of macro DMARK
27bd					CALLMONITOR 
27bd cd 6f ee			call debug_vector  
27c0				endm  
# End of macro CALLMONITOR
27c0				endif 
27c0			;		ld a, 0 
27c0			;		ld (os_view_disable), a 
27c0 cd fd 14			call bp_on 
27c3			 
27c3				CALLMONITOR 
27c3 cd 6f ee			call debug_vector  
27c6				endm  
# End of macro CALLMONITOR
27c6			 
27c6			;	call monitor 
27c6			 
27c6				NEXTW 
27c6 c3 14 1f			jp macro_next 
27c9				endm 
# End of macro NEXTW
27c9			 
27c9			 
27c9			.MALLOC: 
27c9			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
27c9 56				db WORD_SYS_CORE+66             
27ca f2 27			dw .MALLOC2            
27cc 06				db 5 + 1 
27cd .. 00			db "ALLOT",0              
27d3				endm 
# End of macro CWHEAD
27d3			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
27d3				if DEBUG_FORTH_WORDS_KEY 
27d3					DMARK "ALL" 
27d3 f5				push af  
27d4 3a e8 27			ld a, (.dmark)  
27d7 32 6b ee			ld (debug_mark),a  
27da 3a e9 27			ld a, (.dmark+1)  
27dd 32 6c ee			ld (debug_mark+1),a  
27e0 3a ea 27			ld a, (.dmark+2)  
27e3 32 6d ee			ld (debug_mark+2),a  
27e6 18 03			jr .pastdmark  
27e8 ..			.dmark: db "ALL"  
27eb f1			.pastdmark: pop af  
27ec			endm  
# End of macro DMARK
27ec					CALLMONITOR 
27ec cd 6f ee			call debug_vector  
27ef				endm  
# End of macro CALLMONITOR
27ef				endif 
27ef c3 19 28			jp .mallocc 
27f2			.MALLOC2: 
27f2			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
27f2 56				db WORD_SYS_CORE+66             
27f3 30 28			dw .FREE            
27f5 07				db 6 + 1 
27f6 .. 00			db "MALLOC",0              
27fd				endm 
# End of macro CWHEAD
27fd			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
27fd				; get byte count 
27fd				if DEBUG_FORTH_WORDS_KEY 
27fd					DMARK "MAL" 
27fd f5				push af  
27fe 3a 12 28			ld a, (.dmark)  
2801 32 6b ee			ld (debug_mark),a  
2804 3a 13 28			ld a, (.dmark+1)  
2807 32 6c ee			ld (debug_mark+1),a  
280a 3a 14 28			ld a, (.dmark+2)  
280d 32 6d ee			ld (debug_mark+2),a  
2810 18 03			jr .pastdmark  
2812 ..			.dmark: db "MAL"  
2815 f1			.pastdmark: pop af  
2816			endm  
# End of macro DMARK
2816					CALLMONITOR 
2816 cd 6f ee			call debug_vector  
2819				endm  
# End of macro CALLMONITOR
2819				endif 
2819			.mallocc: 
2819				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2819 cd 5e 1d			call macro_dsp_valuehl 
281c				endm 
# End of macro FORTH_DSP_VALUEHL
281c			 
281c			;		push hl 
281c			 
281c				; destroy value TOS 
281c			 
281c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
281c cd 16 1e			call macro_forth_dsp_pop 
281f				endm 
# End of macro FORTH_DSP_POP
281f			 
281f			;		pop hl 
281f cd ce 11			call malloc 
2822			if DEBUG_FORTH_MALLOC_GUARD 
2822 f5				push af 
2823 cd 0f 0e			call ishlzero 
2826			;		ld a, l 
2826			;		add h 
2826			;		cp 0 
2826 f1				pop af 
2827				 
2827 cc d4 4c			call z,malloc_error 
282a			endif 
282a			 
282a cd 67 1b			call forth_push_numhl 
282d				NEXTW 
282d c3 14 1f			jp macro_next 
2830				endm 
# End of macro NEXTW
2830			 
2830			.FREE: 
2830			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2830 57				db WORD_SYS_CORE+67             
2831 61 28			dw .LIST            
2833 05				db 4 + 1 
2834 .. 00			db "FREE",0              
2839				endm 
# End of macro CWHEAD
2839			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2839				if DEBUG_FORTH_WORDS_KEY 
2839					DMARK "FRE" 
2839 f5				push af  
283a 3a 4e 28			ld a, (.dmark)  
283d 32 6b ee			ld (debug_mark),a  
2840 3a 4f 28			ld a, (.dmark+1)  
2843 32 6c ee			ld (debug_mark+1),a  
2846 3a 50 28			ld a, (.dmark+2)  
2849 32 6d ee			ld (debug_mark+2),a  
284c 18 03			jr .pastdmark  
284e ..			.dmark: db "FRE"  
2851 f1			.pastdmark: pop af  
2852			endm  
# End of macro DMARK
2852					CALLMONITOR 
2852 cd 6f ee			call debug_vector  
2855				endm  
# End of macro CALLMONITOR
2855				endif 
2855				; get address 
2855			 
2855				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2855 cd 5e 1d			call macro_dsp_valuehl 
2858				endm 
# End of macro FORTH_DSP_VALUEHL
2858			 
2858			;		push hl 
2858			 
2858				; destroy value TOS 
2858			 
2858				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2858 cd 16 1e			call macro_forth_dsp_pop 
285b				endm 
# End of macro FORTH_DSP_POP
285b			 
285b			;		pop hl 
285b			if FORTH_ENABLE_MALLOCFREE 
285b cd 98 12			call free 
285e			endif 
285e				NEXTW 
285e c3 14 1f			jp macro_next 
2861				endm 
# End of macro NEXTW
2861			.LIST: 
2861			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2861 5c				db WORD_SYS_CORE+72             
2862 51 2a			dw .FORGET            
2864 05				db 4 + 1 
2865 .. 00			db "LIST",0              
286a				endm 
# End of macro CWHEAD
286a			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
286a			; | | The quoted word must be in upper case. 
286a			if DEBUG_FORTH_WORDS_KEY 
286a				DMARK "LST" 
286a f5				push af  
286b 3a 7f 28			ld a, (.dmark)  
286e 32 6b ee			ld (debug_mark),a  
2871 3a 80 28			ld a, (.dmark+1)  
2874 32 6c ee			ld (debug_mark+1),a  
2877 3a 81 28			ld a, (.dmark+2)  
287a 32 6d ee			ld (debug_mark+2),a  
287d 18 03			jr .pastdmark  
287f ..			.dmark: db "LST"  
2882 f1			.pastdmark: pop af  
2883			endm  
# End of macro DMARK
2883				CALLMONITOR 
2883 cd 6f ee			call debug_vector  
2886				endm  
# End of macro CALLMONITOR
2886			endif 
2886			 
2886				FORTH_DSP_VALUEHL 
2886 cd 5e 1d			call macro_dsp_valuehl 
2889				endm 
# End of macro FORTH_DSP_VALUEHL
2889			 
2889 e5				push hl 
288a				FORTH_DSP_POP 
288a cd 16 1e			call macro_forth_dsp_pop 
288d				endm 
# End of macro FORTH_DSP_POP
288d c1				pop bc 
288e			 
288e			; Start format of scratch string 
288e			 
288e 21 c1 e2			ld hl, scratch 
2891			 
2891 3e 3a			ld a, ':' 
2893 77				ld (hl),a 
2894 23				inc hl 
2895 3e 20			ld a, ' ' 
2897 77				ld (hl), a 
2898			 
2898				; Get ptr to the word we need to look up 
2898			 
2898			;		FORTH_DSP_VALUEHL 
2898				;v5 FORTH_DSP_VALUE 
2898			; TODO type check 
2898			;		inc hl    ; Skip type check  
2898			;		push hl 
2898			;		ex de, hl    ; put into DE 
2898			 
2898			 
2898 21 5c 65			ld hl, baseram 
289b				;ld hl, baseusermem 
289b			 
289b e5			push hl   ; sacreifical push 
289c			 
289c			.ldouscanm: 
289c e1			pop hl 
289d			.ldouscan: 
289d			if DEBUG_FORTH_WORDS 
289d				DMARK "LSs" 
289d f5				push af  
289e 3a b2 28			ld a, (.dmark)  
28a1 32 6b ee			ld (debug_mark),a  
28a4 3a b3 28			ld a, (.dmark+1)  
28a7 32 6c ee			ld (debug_mark+1),a  
28aa 3a b4 28			ld a, (.dmark+2)  
28ad 32 6d ee			ld (debug_mark+2),a  
28b0 18 03			jr .pastdmark  
28b2 ..			.dmark: db "LSs"  
28b5 f1			.pastdmark: pop af  
28b6			endm  
# End of macro DMARK
28b6				CALLMONITOR 
28b6 cd 6f ee			call debug_vector  
28b9				endm  
# End of macro CALLMONITOR
28b9			endif 
28b9			; skip dict stub 
28b9 cd 65 20			call forth_tok_next 
28bc			 
28bc			 
28bc			; while we have words to look for 
28bc			 
28bc 7e			ld a, (hl)      
28bd			if DEBUG_FORTH_WORDS 
28bd				DMARK "LSk" 
28bd f5				push af  
28be 3a d2 28			ld a, (.dmark)  
28c1 32 6b ee			ld (debug_mark),a  
28c4 3a d3 28			ld a, (.dmark+1)  
28c7 32 6c ee			ld (debug_mark+1),a  
28ca 3a d4 28			ld a, (.dmark+2)  
28cd 32 6d ee			ld (debug_mark+2),a  
28d0 18 03			jr .pastdmark  
28d2 ..			.dmark: db "LSk"  
28d5 f1			.pastdmark: pop af  
28d6			endm  
# End of macro DMARK
28d6				CALLMONITOR 
28d6 cd 6f ee			call debug_vector  
28d9				endm  
# End of macro CALLMONITOR
28d9			endif 
28d9				;cp WORD_SYS_END 
28d9				;jp z, .lunotfound 
28d9			 
28d9					; if we hit non uwords then gone too far 
28d9 fe 01				cp WORD_SYS_UWORD 
28db c2 0d 2a				jp nz, .lunotfound 
28de			 
28de				if DEBUG_FORTH_WORDS 
28de					DMARK "LSu" 
28de f5				push af  
28df 3a f3 28			ld a, (.dmark)  
28e2 32 6b ee			ld (debug_mark),a  
28e5 3a f4 28			ld a, (.dmark+1)  
28e8 32 6c ee			ld (debug_mark+1),a  
28eb 3a f5 28			ld a, (.dmark+2)  
28ee 32 6d ee			ld (debug_mark+2),a  
28f1 18 03			jr .pastdmark  
28f3 ..			.dmark: db "LSu"  
28f6 f1			.pastdmark: pop af  
28f7			endm  
# End of macro DMARK
28f7					CALLMONITOR 
28f7 cd 6f ee			call debug_vector  
28fa				endm  
# End of macro CALLMONITOR
28fa				endif 
28fa			 
28fa					; found a uword but is it the one we want... 
28fa			 
28fa c5					push bc     ; uword to find is on bc 
28fb d1					pop de 
28fc			 
28fc e5					push hl  ; to save the ptr 
28fd			 
28fd					; skip opcode 
28fd 23					inc hl  
28fe					; skip next ptr 
28fe 23					inc hl  
28ff 23					inc hl 
2900					; skip len 
2900 23					inc hl 
2901			 
2901				if DEBUG_FORTH_WORDS 
2901					DMARK "LSc" 
2901 f5				push af  
2902 3a 16 29			ld a, (.dmark)  
2905 32 6b ee			ld (debug_mark),a  
2908 3a 17 29			ld a, (.dmark+1)  
290b 32 6c ee			ld (debug_mark+1),a  
290e 3a 18 29			ld a, (.dmark+2)  
2911 32 6d ee			ld (debug_mark+2),a  
2914 18 03			jr .pastdmark  
2916 ..			.dmark: db "LSc"  
2919 f1			.pastdmark: pop af  
291a			endm  
# End of macro DMARK
291a					CALLMONITOR 
291a cd 6f ee			call debug_vector  
291d				endm  
# End of macro CALLMONITOR
291d				endif 
291d			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
291d			; ie. If WOO is defined first and then WO. Couldnt list WO. 
291d			; Nope that has gone the other way. It needs to be exact not on first zero 
291d			;		call strcmp 
291d c5					push bc 
291e cd 9e 11				call StrictStrCmp 
2921 c1					pop bc 
2922 c2 9c 28				jp nz, .ldouscanm 
2925				 
2925			 
2925			 
2925					; we have a uword so push its name to the stack 
2925			 
2925			;	   	push hl  ; save so we can move to next dict block 
2925 e1			pop hl 
2926			 
2926				if DEBUG_FORTH_WORDS 
2926					DMARK "LSm" 
2926 f5				push af  
2927 3a 3b 29			ld a, (.dmark)  
292a 32 6b ee			ld (debug_mark),a  
292d 3a 3c 29			ld a, (.dmark+1)  
2930 32 6c ee			ld (debug_mark+1),a  
2933 3a 3d 29			ld a, (.dmark+2)  
2936 32 6d ee			ld (debug_mark+2),a  
2939 18 03			jr .pastdmark  
293b ..			.dmark: db "LSm"  
293e f1			.pastdmark: pop af  
293f			endm  
# End of macro DMARK
293f					CALLMONITOR 
293f cd 6f ee			call debug_vector  
2942				endm  
# End of macro CALLMONITOR
2942				endif 
2942			 
2942					; skip opcode 
2942 23					inc hl  
2943					; skip next ptr 
2943 23					inc hl  
2944 23					inc hl 
2945					; skip len 
2945 7e					ld a, (hl)   ; save length to add 
2946				if DEBUG_FORTH_WORDS 
2946					DMARK "LS2" 
2946 f5				push af  
2947 3a 5b 29			ld a, (.dmark)  
294a 32 6b ee			ld (debug_mark),a  
294d 3a 5c 29			ld a, (.dmark+1)  
2950 32 6c ee			ld (debug_mark+1),a  
2953 3a 5d 29			ld a, (.dmark+2)  
2956 32 6d ee			ld (debug_mark+2),a  
2959 18 03			jr .pastdmark  
295b ..			.dmark: db "LS2"  
295e f1			.pastdmark: pop af  
295f			endm  
# End of macro DMARK
295f					CALLMONITOR 
295f cd 6f ee			call debug_vector  
2962				endm  
# End of macro CALLMONITOR
2962				endif 
2962			 
2962					; save this location 
2962				 
2962 e5					push hl 
2963			 
2963 23					inc hl 
2964 11 c3 e2				ld de, scratch+2 
2967 4f					ld c, a 
2968 06 00				ld b, 0 
296a			 
296a				if DEBUG_FORTH_WORDS 
296a					DMARK "LSn" 
296a f5				push af  
296b 3a 7f 29			ld a, (.dmark)  
296e 32 6b ee			ld (debug_mark),a  
2971 3a 80 29			ld a, (.dmark+1)  
2974 32 6c ee			ld (debug_mark+1),a  
2977 3a 81 29			ld a, (.dmark+2)  
297a 32 6d ee			ld (debug_mark+2),a  
297d 18 03			jr .pastdmark  
297f ..			.dmark: db "LSn"  
2982 f1			.pastdmark: pop af  
2983			endm  
# End of macro DMARK
2983					CALLMONITOR 
2983 cd 6f ee			call debug_vector  
2986				endm  
# End of macro CALLMONITOR
2986				endif 
2986			 
2986					; copy uword name to scratch 
2986			 
2986 ed b0				ldir 
2988			 
2988 1b					dec de 
2989 3e 20				ld a, ' '    ; change null to space 
298b 12					ld (de), a 
298c			 
298c 13					inc de 
298d			 
298d d5					push de 
298e c1					pop bc     ; move scratch pointer to end of word name and save it 
298f			 
298f e1					pop hl 
2990 7e					ld a, (hl) 
2991					;inc hl 
2991					; skip word string 
2991 cd e6 0d				call addatohl 
2994			 
2994 23					inc hl 
2995			 
2995				if DEBUG_FORTH_WORDS 
2995					DMARK "LS3" 
2995 f5				push af  
2996 3a aa 29			ld a, (.dmark)  
2999 32 6b ee			ld (debug_mark),a  
299c 3a ab 29			ld a, (.dmark+1)  
299f 32 6c ee			ld (debug_mark+1),a  
29a2 3a ac 29			ld a, (.dmark+2)  
29a5 32 6d ee			ld (debug_mark+2),a  
29a8 18 03			jr .pastdmark  
29aa ..			.dmark: db "LS3"  
29ad f1			.pastdmark: pop af  
29ae			endm  
# End of macro DMARK
29ae					CALLMONITOR 
29ae cd 6f ee			call debug_vector  
29b1				endm  
# End of macro CALLMONITOR
29b1				endif 
29b1					; should now be at the start of the machine code to setup the eval of the uword 
29b1					; now locate the ptr to the string defintion 
29b1			 
29b1					; skip ld hl, 
29b1					; then load the ptr 
29b1			; TODO use get from hl ptr 
29b1 23					inc hl 
29b2 5e					ld e, (hl) 
29b3 23					inc hl 
29b4 56					ld d, (hl) 
29b5 eb					ex de, hl 
29b6			 
29b6			 
29b6				if DEBUG_FORTH_WORDS 
29b6					DMARK "LSt" 
29b6 f5				push af  
29b7 3a cb 29			ld a, (.dmark)  
29ba 32 6b ee			ld (debug_mark),a  
29bd 3a cc 29			ld a, (.dmark+1)  
29c0 32 6c ee			ld (debug_mark+1),a  
29c3 3a cd 29			ld a, (.dmark+2)  
29c6 32 6d ee			ld (debug_mark+2),a  
29c9 18 03			jr .pastdmark  
29cb ..			.dmark: db "LSt"  
29ce f1			.pastdmark: pop af  
29cf			endm  
# End of macro DMARK
29cf					CALLMONITOR 
29cf cd 6f ee			call debug_vector  
29d2				endm  
# End of macro CALLMONITOR
29d2				endif 
29d2			 
29d2			; cant push right now due to tokenised strings  
29d2			 
29d2			; get the destination of where to copy this definition to. 
29d2			 
29d2 c5					push bc 
29d3 d1					pop de 
29d4			 
29d4 7e			.listl:         ld a,(hl) 
29d5 fe 00				cp 0 
29d7 28 09				jr z, .lreplsp     ; replace zero with space 
29d9					;cp FORTH_END_BUFFER 
29d9 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
29db 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
29dd				 
29dd					; just copy this char as is then 
29dd			 
29dd 12					ld (de), a 
29de			 
29de 23			.listnxt:	inc hl 
29df 13					inc de 
29e0 18 f2				jr .listl 
29e2			 
29e2 3e 20		.lreplsp:	ld a,' ' 
29e4 12					ld (de), a 
29e5 18 f7				jr .listnxt 
29e7			 
29e7			; close up uword def 
29e7			 
29e7			.listdone: 
29e7 12					ld (de), a 
29e8 13					inc de 
29e9 3e 00				ld a, 0 
29eb 12					ld (de), a 
29ec			 
29ec			; now have def so clean up and push to stack 
29ec			 
29ec 21 c1 e2				ld hl, scratch 
29ef				if DEBUG_FORTH_WORDS 
29ef					DMARK "Ltp" 
29ef f5				push af  
29f0 3a 04 2a			ld a, (.dmark)  
29f3 32 6b ee			ld (debug_mark),a  
29f6 3a 05 2a			ld a, (.dmark+1)  
29f9 32 6c ee			ld (debug_mark+1),a  
29fc 3a 06 2a			ld a, (.dmark+2)  
29ff 32 6d ee			ld (debug_mark+2),a  
2a02 18 03			jr .pastdmark  
2a04 ..			.dmark: db "Ltp"  
2a07 f1			.pastdmark: pop af  
2a08			endm  
# End of macro DMARK
2a08					CALLMONITOR 
2a08 cd 6f ee			call debug_vector  
2a0b				endm  
# End of macro CALLMONITOR
2a0b				endif 
2a0b			 
2a0b 18 1f			jr .listpush 
2a0d			 
2a0d			;.lnuword:	pop hl 
2a0d			;		call forth_tok_next 
2a0d			;		jp .ldouscan  
2a0d			 
2a0d			.lunotfound:		  
2a0d			 
2a0d				if DEBUG_FORTH_WORDS 
2a0d					DMARK "LSn" 
2a0d f5				push af  
2a0e 3a 22 2a			ld a, (.dmark)  
2a11 32 6b ee			ld (debug_mark),a  
2a14 3a 23 2a			ld a, (.dmark+1)  
2a17 32 6c ee			ld (debug_mark+1),a  
2a1a 3a 24 2a			ld a, (.dmark+2)  
2a1d 32 6d ee			ld (debug_mark+2),a  
2a20 18 03			jr .pastdmark  
2a22 ..			.dmark: db "LSn"  
2a25 f1			.pastdmark: pop af  
2a26			endm  
# End of macro DMARK
2a26					CALLMONITOR 
2a26 cd 6f ee			call debug_vector  
2a29				endm  
# End of macro CALLMONITOR
2a29				endif 
2a29			 
2a29					 
2a29			;		FORTH_DSP_POP 
2a29			;		ld hl, .luno 
2a29			 
2a29					NEXTW			 
2a29 c3 14 1f			jp macro_next 
2a2c				endm 
# End of macro NEXTW
2a2c			 
2a2c			.listpush: 
2a2c				if DEBUG_FORTH_WORDS 
2a2c					DMARK "LS>" 
2a2c f5				push af  
2a2d 3a 41 2a			ld a, (.dmark)  
2a30 32 6b ee			ld (debug_mark),a  
2a33 3a 42 2a			ld a, (.dmark+1)  
2a36 32 6c ee			ld (debug_mark+1),a  
2a39 3a 43 2a			ld a, (.dmark+2)  
2a3c 32 6d ee			ld (debug_mark+2),a  
2a3f 18 03			jr .pastdmark  
2a41 ..			.dmark: db "LS>"  
2a44 f1			.pastdmark: pop af  
2a45			endm  
# End of macro DMARK
2a45					CALLMONITOR 
2a45 cd 6f ee			call debug_vector  
2a48				endm  
# End of macro CALLMONITOR
2a48				endif 
2a48 cd d5 1b				call forth_push_str 
2a4b			 
2a4b			 
2a4b			 
2a4b					NEXTW 
2a4b c3 14 1f			jp macro_next 
2a4e				endm 
# End of macro NEXTW
2a4e			 
2a4e			;.luno:    db "Word not found",0 
2a4e			 
2a4e			 
2a4e			 
2a4e			 
2a4e			 
2a4e			;		push hl   ; save pointer to start of uword def string 
2a4e			; 
2a4e			;; look for FORTH_EOL_LINE 
2a4e			;		ld a, FORTH_END_BUFFER 
2a4e			;		call strlent 
2a4e			; 
2a4e			;		inc hl		 ; space for coln def 
2a4e			;		inc hl 
2a4e			;		inc hl          ; space for terms 
2a4e			;		inc hl 
2a4e			; 
2a4e			;		ld a, 20   ; TODO get actual length 
2a4e			;		call addatohl    ; include a random amount of room for the uword name 
2a4e			; 
2a4e			;		 
2a4e			;	if DEBUG_FORTH_WORDS 
2a4e			;		DMARK "Lt1" 
2a4e			;		CALLMONITOR 
2a4e			;	endif 
2a4e			;		 
2a4e			; 
2a4e			;; malloc space for the string because we cant change it 
2a4e			; 
2a4e			;		call malloc 
2a4e			;	if DEBUG_FORTH_MALLOC_GUARD 
2a4e			;		push af 
2a4e			;		call ishlzero 
2a4e			;		pop af 
2a4e			;		 
2a4e			;		call z,malloc_error 
2a4e			;	endif 
2a4e			; 
2a4e			;	if DEBUG_FORTH_WORDS 
2a4e			;		DMARK "Lt2" 
2a4e			;		CALLMONITOR 
2a4e			;	endif 
2a4e			;		pop de 
2a4e			;		push hl    ; push the malloc to release later 
2a4e			;		push hl   ;  push back a copy for the later stack push 
2a4e			;		 
2a4e			;; copy the string swapping out the zero terms for spaces 
2a4e			; 
2a4e			;		; de has our source 
2a4e			;		; hl has our dest 
2a4e			; 
2a4e			;; add the coln def 
2a4e			; 
2a4e			;		ld a, ':' 
2a4e			;		ld (hl), a 
2a4e			;		inc hl 
2a4e			;		ld a, ' ' 
2a4e			;		ld (hl), a 
2a4e			;		inc hl 
2a4e			; 
2a4e			;; add the uname word 
2a4e			;		push de   ; save our string for now 
2a4e			;		ex de, hl 
2a4e			; 
2a4e			;		FORTH_DSP_VALUE 
2a4e			;		;v5 FORTH_DSP_VALUE 
2a4e			; 
2a4e			;		inc hl   ; skip type but we know by now this is OK 
2a4e			; 
2a4e			;.luword:	ld a,(hl) 
2a4e			;		cp 0 
2a4e			;		jr z, .luword2 
2a4e			;		ld (de), a 
2a4e			;		inc de 
2a4e			;		inc hl 
2a4e			;		jr .luword 
2a4e			; 
2a4e			;.luword2:	ld a, ' ' 
2a4e			;		ld (de), a 
2a4e			;;		inc hl 
2a4e			;;		inc de 
2a4e			;;		ld (de), a 
2a4e			;;		inc hl 
2a4e			;		inc de 
2a4e			; 
2a4e			;		ex de, hl 
2a4e			;		pop de 
2a4e			;		 
2a4e			;		 
2a4e			; 
2a4e			;; detoken that string and copy it 
2a4e			; 
2a4e			;	if DEBUG_FORTH_WORDS 
2a4e			;		DMARK "Lt2" 
2a4e			;		CALLMONITOR 
2a4e			;	endif 
2a4e			;.ldetok:	ld a, (de) 
2a4e			;		cp FORTH_END_BUFFER 
2a4e			;		jr z, .ldetokend 
2a4e			;		; swap out any zero term for space 
2a4e			;		cp 0 
2a4e			;		jr nz, .ldetoknext 
2a4e			;		ld a, ' ' 
2a4e			; 
2a4e			;	if DEBUG_FORTH_WORDS 
2a4e			;		DMARK "LtS" 
2a4e			;		CALLMONITOR 
2a4e			;	endif 
2a4e			;.ldetoknext:	ld (hl), a 
2a4e			;		inc de 
2a4e			;		inc hl 
2a4e			;		jr .ldetok 
2a4e			; 
2a4e			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2a4e			;		ld (hl), a  
2a4e			; 
2a4e			;; free that temp malloc 
2a4e			; 
2a4e			;		pop hl    
2a4e			; 
2a4e			;	if DEBUG_FORTH_WORDS 
2a4e			;		DMARK "Lt4" 
2a4e			;		CALLMONITOR 
2a4e			;	endif 
2a4e			;		call forth_apushstrhl 
2a4e			; 
2a4e			;		; get rid of temp malloc area 
2a4e			; 
2a4e			;		pop hl 
2a4e			;		call free 
2a4e			; 
2a4e			;		jr .ludone 
2a4e			; 
2a4e			;.lnuword:	pop hl 
2a4e			;		call forth_tok_next 
2a4e			;		jp .ldouscan  
2a4e			; 
2a4e			;.ludone:		 pop hl 
2a4e			; 
2a4e					NEXTW 
2a4e c3 14 1f			jp macro_next 
2a51				endm 
# End of macro NEXTW
2a51			 
2a51			.FORGET: 
2a51				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2a51 5d				db WORD_SYS_CORE+73             
2a52 ca 2a			dw .NOP            
2a54 07				db 6 + 1 
2a55 .. 00			db "FORGET",0              
2a5c				endm 
# End of macro CWHEAD
2a5c			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2a5c			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2a5c			; | |  
2a5c			; | | e.g. "MORE" forget 
2a5c					if DEBUG_FORTH_WORDS_KEY 
2a5c						DMARK "FRG" 
2a5c f5				push af  
2a5d 3a 71 2a			ld a, (.dmark)  
2a60 32 6b ee			ld (debug_mark),a  
2a63 3a 72 2a			ld a, (.dmark+1)  
2a66 32 6c ee			ld (debug_mark+1),a  
2a69 3a 73 2a			ld a, (.dmark+2)  
2a6c 32 6d ee			ld (debug_mark+2),a  
2a6f 18 03			jr .pastdmark  
2a71 ..			.dmark: db "FRG"  
2a74 f1			.pastdmark: pop af  
2a75			endm  
# End of macro DMARK
2a75						CALLMONITOR 
2a75 cd 6f ee			call debug_vector  
2a78				endm  
# End of macro CALLMONITOR
2a78					endif 
2a78			 
2a78				; find uword 
2a78			        ; update start of word with "_" 
2a78				; replace uword with deleted flag 
2a78			 
2a78			 
2a78			;	if DEBUG_FORTH_WORDS 
2a78			;		DMARK "FOG" 
2a78			;		CALLMONITOR 
2a78			;	endif 
2a78			 
2a78			 
2a78					; Get ptr to the word we need to look up 
2a78			 
2a78					FORTH_DSP_VALUEHL 
2a78 cd 5e 1d			call macro_dsp_valuehl 
2a7b				endm 
# End of macro FORTH_DSP_VALUEHL
2a7b					;v5 FORTH_DSP_VALUE 
2a7b				; TODO type check 
2a7b			;		inc hl    ; Skip type check  
2a7b e5					push hl 
2a7c c1					pop bc 
2a7d			;		ex de, hl    ; put into DE 
2a7d			 
2a7d			 
2a7d 21 5c 65				ld hl, baseram 
2a80					;ld hl, baseusermem 
2a80			 
2a80				; skip dict stub 
2a80			;	call forth_tok_next 
2a80 e5			push hl   ; sacreifical push 
2a81			 
2a81			.fldouscanm: 
2a81 e1				pop hl 
2a82			.fldouscan: 
2a82			;	if DEBUG_FORTH_WORDS 
2a82			;		DMARK "LSs" 
2a82			;		CALLMONITOR 
2a82			;	endif 
2a82				; skip dict stub 
2a82 cd 65 20				call forth_tok_next 
2a85			 
2a85			 
2a85			; while we have words to look for 
2a85			 
2a85 7e				ld a, (hl)      
2a86			;	if DEBUG_FORTH_WORDS 
2a86			;		DMARK "LSk" 
2a86			;		CALLMONITOR 
2a86			;	endif 
2a86 fe 00				cp WORD_SYS_END 
2a88 ca c4 2a				jp z, .flunotfound 
2a8b fe 01				cp WORD_SYS_UWORD 
2a8d c2 82 2a				jp nz, .fldouscan 
2a90			 
2a90			;	if DEBUG_FORTH_WORDS 
2a90			;		DMARK "LSu" 
2a90			;		CALLMONITOR 
2a90			;	endif 
2a90			 
2a90					; found a uword but is it the one we want... 
2a90			 
2a90 c5					push bc     ; uword to find is on bc 
2a91 d1					pop de 
2a92			 
2a92 e5					push hl  ; to save the ptr 
2a93			 
2a93					; skip opcode 
2a93 23					inc hl  
2a94					; skip next ptr 
2a94 23					inc hl  
2a95 23					inc hl 
2a96					; skip len 
2a96 23					inc hl 
2a97			 
2a97			;	if DEBUG_FORTH_WORDS 
2a97			;		DMARK "LSc" 
2a97			;		CALLMONITOR 
2a97			;	endif 
2a97 cd 91 11				call strcmp 
2a9a c2 81 2a				jp nz, .fldouscanm 
2a9d			; 
2a9d			; 
2a9d			;; while we have words to look for 
2a9d			; 
2a9d			;.fdouscan:	ld a, (hl)      
2a9d			;	if DEBUG_FORTH_WORDS 
2a9d			;		DMARK "LSs" 
2a9d			;		CALLMONITOR 
2a9d			;	endif 
2a9d			;		cp WORD_SYS_END 
2a9d			;		jp z, .fudone 
2a9d			;		cp WORD_SYS_UWORD 
2a9d			;		jp nz, .fnuword 
2a9d			; 
2a9d			;	if DEBUG_FORTH_WORDS 
2a9d			;		DMARK "FGu" 
2a9d			;		CALLMONITOR 
2a9d			;	endif 
2a9d			; 
2a9d			;		; found a uword but is it the one we want... 
2a9d			; 
2a9d			; 
2a9d			;	        pop de   ; get back the dsp name 
2a9d			;		push de 
2a9d			; 
2a9d			;		push hl  ; to save the ptr 
2a9d			; 
2a9d			;		; skip opcode 
2a9d			;		inc hl  
2a9d			;		; skip next ptr 
2a9d			;		inc hl  
2a9d			;		inc hl 
2a9d			;		; skip len 
2a9d			;		inc hl 
2a9d			; 
2a9d			;	if DEBUG_FORTH_WORDS 
2a9d			;		DMARK "FGc" 
2a9d			;		CALLMONITOR 
2a9d			;	endif 
2a9d			;		call strcmp 
2a9d			;		jp nz, .fnuword 
2a9d			 
2a9d			 
2a9d e1			pop hl 
2a9e			 
2a9e				 
2a9e				if DEBUG_FORTH_WORDS 
2a9e					DMARK "FGm" 
2a9e f5				push af  
2a9f 3a b3 2a			ld a, (.dmark)  
2aa2 32 6b ee			ld (debug_mark),a  
2aa5 3a b4 2a			ld a, (.dmark+1)  
2aa8 32 6c ee			ld (debug_mark+1),a  
2aab 3a b5 2a			ld a, (.dmark+2)  
2aae 32 6d ee			ld (debug_mark+2),a  
2ab1 18 03			jr .pastdmark  
2ab3 ..			.dmark: db "FGm"  
2ab6 f1			.pastdmark: pop af  
2ab7			endm  
# End of macro DMARK
2ab7					CALLMONITOR 
2ab7 cd 6f ee			call debug_vector  
2aba				endm  
# End of macro CALLMONITOR
2aba				endif 
2aba			 
2aba			 
2aba			 
2aba					; we have a uword so push its name to the stack 
2aba			 
2aba			;	   	push hl  ; save so we can move to next dict block 
2aba			;pop hl 
2aba			 
2aba					; update opcode to deleted 
2aba 3e 03				ld a, WORD_SYS_DELETED 
2abc 77					ld (hl), a 
2abd			 
2abd 23					inc hl  
2abe					; skip next ptr 
2abe 23					inc hl  
2abf 23					inc hl 
2ac0					; skip len 
2ac0 23					inc hl 
2ac1			 
2ac1					; TODO change parser to skip deleted words but for now mark it out 
2ac1 3e 5f				ld a, "_" 
2ac3 77					ld  (hl),a 
2ac4			 
2ac4			;		jr .fudone 
2ac4			; 
2ac4			;.fnuword:	pop hl 
2ac4			;		call forth_tok_next 
2ac4			;		jp .fdouscan  
2ac4			 
2ac4			.flunotfound:		  
2ac4			 
2ac4			 
2ac4					 
2ac4					FORTH_DSP_POP 
2ac4 cd 16 1e			call macro_forth_dsp_pop 
2ac7				endm 
# End of macro FORTH_DSP_POP
2ac7			;		ld hl, .luno 
2ac7			;.fudone:		 pop hl 
2ac7					NEXTW 
2ac7 c3 14 1f			jp macro_next 
2aca				endm 
# End of macro NEXTW
2aca			.NOP: 
2aca				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2aca 61				db WORD_SYS_CORE+77             
2acb f1 2a			dw .COMO            
2acd 04				db 3 + 1 
2ace .. 00			db "NOP",0              
2ad2				endm 
# End of macro CWHEAD
2ad2			; | NOP (  --  ) Do nothing | DONE 
2ad2					if DEBUG_FORTH_WORDS_KEY 
2ad2						DMARK "NOP" 
2ad2 f5				push af  
2ad3 3a e7 2a			ld a, (.dmark)  
2ad6 32 6b ee			ld (debug_mark),a  
2ad9 3a e8 2a			ld a, (.dmark+1)  
2adc 32 6c ee			ld (debug_mark+1),a  
2adf 3a e9 2a			ld a, (.dmark+2)  
2ae2 32 6d ee			ld (debug_mark+2),a  
2ae5 18 03			jr .pastdmark  
2ae7 ..			.dmark: db "NOP"  
2aea f1			.pastdmark: pop af  
2aeb			endm  
# End of macro DMARK
2aeb						CALLMONITOR 
2aeb cd 6f ee			call debug_vector  
2aee				endm  
# End of macro CALLMONITOR
2aee					endif 
2aee				       NEXTW 
2aee c3 14 1f			jp macro_next 
2af1				endm 
# End of macro NEXTW
2af1			.COMO: 
2af1				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2af1 6e				db WORD_SYS_CORE+90             
2af2 43 2b			dw .COMC            
2af4 02				db 1 + 1 
2af5 .. 00			db "(",0              
2af7				endm 
# End of macro CWHEAD
2af7			; | ( ( -- )  Start of comment | DONE 
2af7			 
2af7			 
2af7 2a c2 e5				ld hl, ( os_tok_ptr) 
2afa 11 3e 2b			ld de, .closepar 
2afd					 
2afd					if DEBUG_FORTH_WORDS 
2afd						DMARK ").." 
2afd f5				push af  
2afe 3a 12 2b			ld a, (.dmark)  
2b01 32 6b ee			ld (debug_mark),a  
2b04 3a 13 2b			ld a, (.dmark+1)  
2b07 32 6c ee			ld (debug_mark+1),a  
2b0a 3a 14 2b			ld a, (.dmark+2)  
2b0d 32 6d ee			ld (debug_mark+2),a  
2b10 18 03			jr .pastdmark  
2b12 ..			.dmark: db ").."  
2b15 f1			.pastdmark: pop af  
2b16			endm  
# End of macro DMARK
2b16						CALLMONITOR 
2b16 cd 6f ee			call debug_vector  
2b19				endm  
# End of macro CALLMONITOR
2b19					endif 
2b19 cd 2f 20			call findnexttok  
2b1c			 
2b1c					if DEBUG_FORTH_WORDS 
2b1c						DMARK "IF5" 
2b1c f5				push af  
2b1d 3a 31 2b			ld a, (.dmark)  
2b20 32 6b ee			ld (debug_mark),a  
2b23 3a 32 2b			ld a, (.dmark+1)  
2b26 32 6c ee			ld (debug_mark+1),a  
2b29 3a 33 2b			ld a, (.dmark+2)  
2b2c 32 6d ee			ld (debug_mark+2),a  
2b2f 18 03			jr .pastdmark  
2b31 ..			.dmark: db "IF5"  
2b34 f1			.pastdmark: pop af  
2b35			endm  
# End of macro DMARK
2b35						CALLMONITOR 
2b35 cd 6f ee			call debug_vector  
2b38				endm  
# End of macro CALLMONITOR
2b38					endif 
2b38				; replace below with ) exec using tok_ptr 
2b38 22 c2 e5			ld (os_tok_ptr), hl 
2b3b c3 a5 1f			jp exec1 
2b3e			 
2b3e .. 00			.closepar:   db ")",0 
2b40			 
2b40				       NEXTW 
2b40 c3 14 1f			jp macro_next 
2b43				endm 
# End of macro NEXTW
2b43			.COMC: 
2b43				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2b43 6f				db WORD_SYS_CORE+91             
2b44 4c 2b			dw .SCRATCH            
2b46 02				db 1 + 1 
2b47 .. 00			db ")",0              
2b49				endm 
# End of macro CWHEAD
2b49			; | ) ( -- )  End of comment |  DONE  
2b49				       NEXTW 
2b49 c3 14 1f			jp macro_next 
2b4c				endm 
# End of macro NEXTW
2b4c			 
2b4c			.SCRATCH: 
2b4c				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2b4c 6f				db WORD_SYS_CORE+91             
2b4d 87 2b			dw .INC            
2b4f 08				db 7 + 1 
2b50 .. 00			db "SCRATCH",0              
2b58				endm 
# End of macro CWHEAD
2b58			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2b58			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2b58			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2b58			; | |  
2b58			; | | e.g.    : score $00 scratch ; 
2b58			; | |  
2b58			; | | $00 score ! 
2b58			; | | $01 score +! 
2b58			; | |  
2b58			; | | e.g.   : varword $0a scratch ;  
2b58			; | | 
2b58			; | | $8000 varword ! 
2b58					if DEBUG_FORTH_WORDS_KEY 
2b58						DMARK "SCR" 
2b58 f5				push af  
2b59 3a 6d 2b			ld a, (.dmark)  
2b5c 32 6b ee			ld (debug_mark),a  
2b5f 3a 6e 2b			ld a, (.dmark+1)  
2b62 32 6c ee			ld (debug_mark+1),a  
2b65 3a 6f 2b			ld a, (.dmark+2)  
2b68 32 6d ee			ld (debug_mark+2),a  
2b6b 18 03			jr .pastdmark  
2b6d ..			.dmark: db "SCR"  
2b70 f1			.pastdmark: pop af  
2b71			endm  
# End of macro DMARK
2b71						CALLMONITOR 
2b71 cd 6f ee			call debug_vector  
2b74				endm  
# End of macro CALLMONITOR
2b74					endif 
2b74			 
2b74					FORTH_DSP_VALUEHL 
2b74 cd 5e 1d			call macro_dsp_valuehl 
2b77				endm 
# End of macro FORTH_DSP_VALUEHL
2b77				 
2b77					FORTH_DSP_POP 
2b77 cd 16 1e			call macro_forth_dsp_pop 
2b7a				endm 
# End of macro FORTH_DSP_POP
2b7a			 
2b7a 7d					ld a, l 
2b7b 21 e6 e7				ld hl, os_var_array 
2b7e cd e6 0d				call addatohl 
2b81			 
2b81 cd 67 1b				call forth_push_numhl 
2b84			 
2b84				       NEXTW 
2b84 c3 14 1f			jp macro_next 
2b87				endm 
# End of macro NEXTW
2b87			 
2b87			.INC: 
2b87				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2b87 6f				db WORD_SYS_CORE+91             
2b88 dd 2b			dw .DEC            
2b8a 03				db 2 + 1 
2b8b .. 00			db "+!",0              
2b8e				endm 
# End of macro CWHEAD
2b8e			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2b8e					if DEBUG_FORTH_WORDS_KEY 
2b8e						DMARK "+s_" 
2b8e f5				push af  
2b8f 3a a3 2b			ld a, (.dmark)  
2b92 32 6b ee			ld (debug_mark),a  
2b95 3a a4 2b			ld a, (.dmark+1)  
2b98 32 6c ee			ld (debug_mark+1),a  
2b9b 3a a5 2b			ld a, (.dmark+2)  
2b9e 32 6d ee			ld (debug_mark+2),a  
2ba1 18 03			jr .pastdmark  
2ba3 ..			.dmark: db "+s_"  
2ba6 f1			.pastdmark: pop af  
2ba7			endm  
# End of macro DMARK
2ba7						CALLMONITOR 
2ba7 cd 6f ee			call debug_vector  
2baa				endm  
# End of macro CALLMONITOR
2baa					endif 
2baa			 
2baa					FORTH_DSP_VALUEHL 
2baa cd 5e 1d			call macro_dsp_valuehl 
2bad				endm 
# End of macro FORTH_DSP_VALUEHL
2bad			 
2bad e5					push hl   ; save address 
2bae			 
2bae					FORTH_DSP_POP 
2bae cd 16 1e			call macro_forth_dsp_pop 
2bb1				endm 
# End of macro FORTH_DSP_POP
2bb1			 
2bb1					FORTH_DSP_VALUEHL 
2bb1 cd 5e 1d			call macro_dsp_valuehl 
2bb4				endm 
# End of macro FORTH_DSP_VALUEHL
2bb4			 
2bb4 e5					push hl 
2bb5					FORTH_DSP_POP 
2bb5 cd 16 1e			call macro_forth_dsp_pop 
2bb8				endm 
# End of macro FORTH_DSP_POP
2bb8 e1					pop hl 
2bb9			 
2bb9					; hl contains value to add to byte at a 
2bb9				 
2bb9 eb					ex de, hl 
2bba			 
2bba e1					pop hl 
2bbb			 
2bbb					if DEBUG_FORTH_WORDS 
2bbb						DMARK "INC" 
2bbb f5				push af  
2bbc 3a d0 2b			ld a, (.dmark)  
2bbf 32 6b ee			ld (debug_mark),a  
2bc2 3a d1 2b			ld a, (.dmark+1)  
2bc5 32 6c ee			ld (debug_mark+1),a  
2bc8 3a d2 2b			ld a, (.dmark+2)  
2bcb 32 6d ee			ld (debug_mark+2),a  
2bce 18 03			jr .pastdmark  
2bd0 ..			.dmark: db "INC"  
2bd3 f1			.pastdmark: pop af  
2bd4			endm  
# End of macro DMARK
2bd4						CALLMONITOR 
2bd4 cd 6f ee			call debug_vector  
2bd7				endm  
# End of macro CALLMONITOR
2bd7					endif 
2bd7			 
2bd7 7e					ld a,(hl) 
2bd8 83					add e 
2bd9 77					ld (hl),a 
2bda			 
2bda			 
2bda			 
2bda				       NEXTW 
2bda c3 14 1f			jp macro_next 
2bdd				endm 
# End of macro NEXTW
2bdd			 
2bdd			.DEC: 
2bdd				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2bdd 6f				db WORD_SYS_CORE+91             
2bde 31 2c			dw .INC2            
2be0 03				db 2 + 1 
2be1 .. 00			db "-!",0              
2be4				endm 
# End of macro CWHEAD
2be4			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2be4					if DEBUG_FORTH_WORDS_KEY 
2be4						DMARK "-s_" 
2be4 f5				push af  
2be5 3a f9 2b			ld a, (.dmark)  
2be8 32 6b ee			ld (debug_mark),a  
2beb 3a fa 2b			ld a, (.dmark+1)  
2bee 32 6c ee			ld (debug_mark+1),a  
2bf1 3a fb 2b			ld a, (.dmark+2)  
2bf4 32 6d ee			ld (debug_mark+2),a  
2bf7 18 03			jr .pastdmark  
2bf9 ..			.dmark: db "-s_"  
2bfc f1			.pastdmark: pop af  
2bfd			endm  
# End of macro DMARK
2bfd						CALLMONITOR 
2bfd cd 6f ee			call debug_vector  
2c00				endm  
# End of macro CALLMONITOR
2c00					endif 
2c00			 
2c00					FORTH_DSP_VALUEHL 
2c00 cd 5e 1d			call macro_dsp_valuehl 
2c03				endm 
# End of macro FORTH_DSP_VALUEHL
2c03			 
2c03 e5					push hl   ; save address 
2c04			 
2c04					FORTH_DSP_POP 
2c04 cd 16 1e			call macro_forth_dsp_pop 
2c07				endm 
# End of macro FORTH_DSP_POP
2c07			 
2c07					FORTH_DSP_VALUEHL 
2c07 cd 5e 1d			call macro_dsp_valuehl 
2c0a				endm 
# End of macro FORTH_DSP_VALUEHL
2c0a			 
2c0a					; hl contains value to add to byte at a 
2c0a				 
2c0a eb					ex de, hl 
2c0b			 
2c0b e1					pop hl 
2c0c			 
2c0c					if DEBUG_FORTH_WORDS 
2c0c						DMARK "DEC" 
2c0c f5				push af  
2c0d 3a 21 2c			ld a, (.dmark)  
2c10 32 6b ee			ld (debug_mark),a  
2c13 3a 22 2c			ld a, (.dmark+1)  
2c16 32 6c ee			ld (debug_mark+1),a  
2c19 3a 23 2c			ld a, (.dmark+2)  
2c1c 32 6d ee			ld (debug_mark+2),a  
2c1f 18 03			jr .pastdmark  
2c21 ..			.dmark: db "DEC"  
2c24 f1			.pastdmark: pop af  
2c25			endm  
# End of macro DMARK
2c25						CALLMONITOR 
2c25 cd 6f ee			call debug_vector  
2c28				endm  
# End of macro CALLMONITOR
2c28					endif 
2c28			 
2c28 7e					ld a,(hl) 
2c29 93					sub e 
2c2a 77					ld (hl),a 
2c2b			 
2c2b			 
2c2b					FORTH_DSP_POP 
2c2b cd 16 1e			call macro_forth_dsp_pop 
2c2e				endm 
# End of macro FORTH_DSP_POP
2c2e			 
2c2e				       NEXTW 
2c2e c3 14 1f			jp macro_next 
2c31				endm 
# End of macro NEXTW
2c31			 
2c31			.INC2: 
2c31				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2c31 6f				db WORD_SYS_CORE+91             
2c32 de 2c			dw .DEC2            
2c34 04				db 3 + 1 
2c35 .. 00			db "+2!",0              
2c39				endm 
# End of macro CWHEAD
2c39			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2c39			 
2c39					if DEBUG_FORTH_WORDS_KEY 
2c39						DMARK "+2s" 
2c39 f5				push af  
2c3a 3a 4e 2c			ld a, (.dmark)  
2c3d 32 6b ee			ld (debug_mark),a  
2c40 3a 4f 2c			ld a, (.dmark+1)  
2c43 32 6c ee			ld (debug_mark+1),a  
2c46 3a 50 2c			ld a, (.dmark+2)  
2c49 32 6d ee			ld (debug_mark+2),a  
2c4c 18 03			jr .pastdmark  
2c4e ..			.dmark: db "+2s"  
2c51 f1			.pastdmark: pop af  
2c52			endm  
# End of macro DMARK
2c52						CALLMONITOR 
2c52 cd 6f ee			call debug_vector  
2c55				endm  
# End of macro CALLMONITOR
2c55					endif 
2c55			 
2c55					; Address 
2c55			 
2c55					FORTH_DSP_VALUEHL 
2c55 cd 5e 1d			call macro_dsp_valuehl 
2c58				endm 
# End of macro FORTH_DSP_VALUEHL
2c58			 
2c58 e5					push hl    ; save address 
2c59			 
2c59					; load content into de 
2c59			 
2c59 5e					ld e,(hl) 
2c5a 23					inc hl 
2c5b 56					ld d, (hl) 
2c5c			 
2c5c					if DEBUG_FORTH_WORDS 
2c5c						DMARK "+2a" 
2c5c f5				push af  
2c5d 3a 71 2c			ld a, (.dmark)  
2c60 32 6b ee			ld (debug_mark),a  
2c63 3a 72 2c			ld a, (.dmark+1)  
2c66 32 6c ee			ld (debug_mark+1),a  
2c69 3a 73 2c			ld a, (.dmark+2)  
2c6c 32 6d ee			ld (debug_mark+2),a  
2c6f 18 03			jr .pastdmark  
2c71 ..			.dmark: db "+2a"  
2c74 f1			.pastdmark: pop af  
2c75			endm  
# End of macro DMARK
2c75						CALLMONITOR 
2c75 cd 6f ee			call debug_vector  
2c78				endm  
# End of macro CALLMONITOR
2c78					endif 
2c78			 
2c78					FORTH_DSP_POP 
2c78 cd 16 1e			call macro_forth_dsp_pop 
2c7b				endm 
# End of macro FORTH_DSP_POP
2c7b			 
2c7b					; Get value to add 
2c7b			 
2c7b					FORTH_DSP_VALUE 
2c7b cd 47 1d			call macro_forth_dsp_value 
2c7e				endm 
# End of macro FORTH_DSP_VALUE
2c7e			 
2c7e					if DEBUG_FORTH_WORDS 
2c7e						DMARK "+2v" 
2c7e f5				push af  
2c7f 3a 93 2c			ld a, (.dmark)  
2c82 32 6b ee			ld (debug_mark),a  
2c85 3a 94 2c			ld a, (.dmark+1)  
2c88 32 6c ee			ld (debug_mark+1),a  
2c8b 3a 95 2c			ld a, (.dmark+2)  
2c8e 32 6d ee			ld (debug_mark+2),a  
2c91 18 03			jr .pastdmark  
2c93 ..			.dmark: db "+2v"  
2c96 f1			.pastdmark: pop af  
2c97			endm  
# End of macro DMARK
2c97						CALLMONITOR 
2c97 cd 6f ee			call debug_vector  
2c9a				endm  
# End of macro CALLMONITOR
2c9a					endif 
2c9a			 
2c9a 19					add hl, de 
2c9b			 
2c9b					if DEBUG_FORTH_WORDS 
2c9b						DMARK "+2+" 
2c9b f5				push af  
2c9c 3a b0 2c			ld a, (.dmark)  
2c9f 32 6b ee			ld (debug_mark),a  
2ca2 3a b1 2c			ld a, (.dmark+1)  
2ca5 32 6c ee			ld (debug_mark+1),a  
2ca8 3a b2 2c			ld a, (.dmark+2)  
2cab 32 6d ee			ld (debug_mark+2),a  
2cae 18 03			jr .pastdmark  
2cb0 ..			.dmark: db "+2+"  
2cb3 f1			.pastdmark: pop af  
2cb4			endm  
# End of macro DMARK
2cb4						CALLMONITOR 
2cb4 cd 6f ee			call debug_vector  
2cb7				endm  
# End of macro CALLMONITOR
2cb7					endif 
2cb7			 
2cb7					; move result to de 
2cb7			 
2cb7 eb					ex de, hl 
2cb8			 
2cb8					; Address 
2cb8			 
2cb8 e1					pop hl 
2cb9			 
2cb9					; save it back 
2cb9			 
2cb9 73					ld (hl), e 
2cba 23					inc hl 
2cbb 72					ld (hl), d 
2cbc			 
2cbc					if DEBUG_FORTH_WORDS 
2cbc						DMARK "+2e" 
2cbc f5				push af  
2cbd 3a d1 2c			ld a, (.dmark)  
2cc0 32 6b ee			ld (debug_mark),a  
2cc3 3a d2 2c			ld a, (.dmark+1)  
2cc6 32 6c ee			ld (debug_mark+1),a  
2cc9 3a d3 2c			ld a, (.dmark+2)  
2ccc 32 6d ee			ld (debug_mark+2),a  
2ccf 18 03			jr .pastdmark  
2cd1 ..			.dmark: db "+2e"  
2cd4 f1			.pastdmark: pop af  
2cd5			endm  
# End of macro DMARK
2cd5						CALLMONITOR 
2cd5 cd 6f ee			call debug_vector  
2cd8				endm  
# End of macro CALLMONITOR
2cd8					endif 
2cd8			 
2cd8			 
2cd8			 
2cd8					FORTH_DSP_POP 
2cd8 cd 16 1e			call macro_forth_dsp_pop 
2cdb				endm 
# End of macro FORTH_DSP_POP
2cdb			 
2cdb			 
2cdb				       NEXTW 
2cdb c3 14 1f			jp macro_next 
2cde				endm 
# End of macro NEXTW
2cde			 
2cde			.DEC2: 
2cde				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2cde 6f				db WORD_SYS_CORE+91             
2cdf 8d 2d			dw .GET2            
2ce1 04				db 3 + 1 
2ce2 .. 00			db "-2!",0              
2ce6				endm 
# End of macro CWHEAD
2ce6			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2ce6			 
2ce6			 
2ce6					if DEBUG_FORTH_WORDS_KEY 
2ce6						DMARK "-2s" 
2ce6 f5				push af  
2ce7 3a fb 2c			ld a, (.dmark)  
2cea 32 6b ee			ld (debug_mark),a  
2ced 3a fc 2c			ld a, (.dmark+1)  
2cf0 32 6c ee			ld (debug_mark+1),a  
2cf3 3a fd 2c			ld a, (.dmark+2)  
2cf6 32 6d ee			ld (debug_mark+2),a  
2cf9 18 03			jr .pastdmark  
2cfb ..			.dmark: db "-2s"  
2cfe f1			.pastdmark: pop af  
2cff			endm  
# End of macro DMARK
2cff						CALLMONITOR 
2cff cd 6f ee			call debug_vector  
2d02				endm  
# End of macro CALLMONITOR
2d02					endif 
2d02			 
2d02					; Address 
2d02			 
2d02					FORTH_DSP_VALUEHL 
2d02 cd 5e 1d			call macro_dsp_valuehl 
2d05				endm 
# End of macro FORTH_DSP_VALUEHL
2d05			 
2d05 e5					push hl    ; save address 
2d06			 
2d06					; load content into de 
2d06			 
2d06 5e					ld e,(hl) 
2d07 23					inc hl 
2d08 56					ld d, (hl) 
2d09			 
2d09					if DEBUG_FORTH_WORDS 
2d09						DMARK "-2a" 
2d09 f5				push af  
2d0a 3a 1e 2d			ld a, (.dmark)  
2d0d 32 6b ee			ld (debug_mark),a  
2d10 3a 1f 2d			ld a, (.dmark+1)  
2d13 32 6c ee			ld (debug_mark+1),a  
2d16 3a 20 2d			ld a, (.dmark+2)  
2d19 32 6d ee			ld (debug_mark+2),a  
2d1c 18 03			jr .pastdmark  
2d1e ..			.dmark: db "-2a"  
2d21 f1			.pastdmark: pop af  
2d22			endm  
# End of macro DMARK
2d22						CALLMONITOR 
2d22 cd 6f ee			call debug_vector  
2d25				endm  
# End of macro CALLMONITOR
2d25					endif 
2d25			 
2d25					FORTH_DSP_POP 
2d25 cd 16 1e			call macro_forth_dsp_pop 
2d28				endm 
# End of macro FORTH_DSP_POP
2d28			 
2d28					; Get value to remove 
2d28			 
2d28					FORTH_DSP_VALUE 
2d28 cd 47 1d			call macro_forth_dsp_value 
2d2b				endm 
# End of macro FORTH_DSP_VALUE
2d2b			 
2d2b					if DEBUG_FORTH_WORDS 
2d2b						DMARK "-2v" 
2d2b f5				push af  
2d2c 3a 40 2d			ld a, (.dmark)  
2d2f 32 6b ee			ld (debug_mark),a  
2d32 3a 41 2d			ld a, (.dmark+1)  
2d35 32 6c ee			ld (debug_mark+1),a  
2d38 3a 42 2d			ld a, (.dmark+2)  
2d3b 32 6d ee			ld (debug_mark+2),a  
2d3e 18 03			jr .pastdmark  
2d40 ..			.dmark: db "-2v"  
2d43 f1			.pastdmark: pop af  
2d44			endm  
# End of macro DMARK
2d44						CALLMONITOR 
2d44 cd 6f ee			call debug_vector  
2d47				endm  
# End of macro CALLMONITOR
2d47					endif 
2d47			 
2d47 eb					ex de, hl 
2d48 ed 52				sbc hl, de 
2d4a			 
2d4a					if DEBUG_FORTH_WORDS 
2d4a						DMARK "-2d" 
2d4a f5				push af  
2d4b 3a 5f 2d			ld a, (.dmark)  
2d4e 32 6b ee			ld (debug_mark),a  
2d51 3a 60 2d			ld a, (.dmark+1)  
2d54 32 6c ee			ld (debug_mark+1),a  
2d57 3a 61 2d			ld a, (.dmark+2)  
2d5a 32 6d ee			ld (debug_mark+2),a  
2d5d 18 03			jr .pastdmark  
2d5f ..			.dmark: db "-2d"  
2d62 f1			.pastdmark: pop af  
2d63			endm  
# End of macro DMARK
2d63						CALLMONITOR 
2d63 cd 6f ee			call debug_vector  
2d66				endm  
# End of macro CALLMONITOR
2d66					endif 
2d66			 
2d66					; move result to de 
2d66			 
2d66 eb					ex de, hl 
2d67			 
2d67					; Address 
2d67			 
2d67 e1					pop hl 
2d68			 
2d68					; save it back 
2d68			 
2d68 73					ld (hl), e 
2d69 23					inc hl 
2d6a 72					ld (hl), d 
2d6b			 
2d6b					if DEBUG_FORTH_WORDS 
2d6b						DMARK "-2e" 
2d6b f5				push af  
2d6c 3a 80 2d			ld a, (.dmark)  
2d6f 32 6b ee			ld (debug_mark),a  
2d72 3a 81 2d			ld a, (.dmark+1)  
2d75 32 6c ee			ld (debug_mark+1),a  
2d78 3a 82 2d			ld a, (.dmark+2)  
2d7b 32 6d ee			ld (debug_mark+2),a  
2d7e 18 03			jr .pastdmark  
2d80 ..			.dmark: db "-2e"  
2d83 f1			.pastdmark: pop af  
2d84			endm  
# End of macro DMARK
2d84						CALLMONITOR 
2d84 cd 6f ee			call debug_vector  
2d87				endm  
# End of macro CALLMONITOR
2d87					endif 
2d87			 
2d87			 
2d87					FORTH_DSP_POP 
2d87 cd 16 1e			call macro_forth_dsp_pop 
2d8a				endm 
# End of macro FORTH_DSP_POP
2d8a			 
2d8a			 
2d8a			 
2d8a				       NEXTW 
2d8a c3 14 1f			jp macro_next 
2d8d				endm 
# End of macro NEXTW
2d8d			.GET2: 
2d8d				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2d8d 6f				db WORD_SYS_CORE+91             
2d8e c2 2d			dw .BANG2            
2d90 03				db 2 + 1 
2d91 .. 00			db "2@",0              
2d94				endm 
# End of macro CWHEAD
2d94			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2d94					if DEBUG_FORTH_WORDS_KEY 
2d94						DMARK "2A_" 
2d94 f5				push af  
2d95 3a a9 2d			ld a, (.dmark)  
2d98 32 6b ee			ld (debug_mark),a  
2d9b 3a aa 2d			ld a, (.dmark+1)  
2d9e 32 6c ee			ld (debug_mark+1),a  
2da1 3a ab 2d			ld a, (.dmark+2)  
2da4 32 6d ee			ld (debug_mark+2),a  
2da7 18 03			jr .pastdmark  
2da9 ..			.dmark: db "2A_"  
2dac f1			.pastdmark: pop af  
2dad			endm  
# End of macro DMARK
2dad						CALLMONITOR 
2dad cd 6f ee			call debug_vector  
2db0				endm  
# End of macro CALLMONITOR
2db0					endif 
2db0			 
2db0					FORTH_DSP_VALUEHL 
2db0 cd 5e 1d			call macro_dsp_valuehl 
2db3				endm 
# End of macro FORTH_DSP_VALUEHL
2db3			 
2db3 e5					push hl   ; save address 
2db4			 
2db4					FORTH_DSP_POP 
2db4 cd 16 1e			call macro_forth_dsp_pop 
2db7				endm 
# End of macro FORTH_DSP_POP
2db7			 
2db7 e1					pop hl 
2db8			 
2db8 5e					ld e, (hl) 
2db9 23					inc hl 
2dba 56					ld d, (hl) 
2dbb			 
2dbb eb					ex de, hl 
2dbc			 
2dbc cd 67 1b				call forth_push_numhl 
2dbf			 
2dbf				       NEXTW 
2dbf c3 14 1f			jp macro_next 
2dc2				endm 
# End of macro NEXTW
2dc2			.BANG2: 
2dc2				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2dc2 6f				db WORD_SYS_CORE+91             
2dc3 fa 2d			dw .CONFIG            
2dc5 03				db 2 + 1 
2dc6 .. 00			db "2!",0              
2dc9				endm 
# End of macro CWHEAD
2dc9			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2dc9					if DEBUG_FORTH_WORDS_KEY 
2dc9						DMARK "2S_" 
2dc9 f5				push af  
2dca 3a de 2d			ld a, (.dmark)  
2dcd 32 6b ee			ld (debug_mark),a  
2dd0 3a df 2d			ld a, (.dmark+1)  
2dd3 32 6c ee			ld (debug_mark+1),a  
2dd6 3a e0 2d			ld a, (.dmark+2)  
2dd9 32 6d ee			ld (debug_mark+2),a  
2ddc 18 03			jr .pastdmark  
2dde ..			.dmark: db "2S_"  
2de1 f1			.pastdmark: pop af  
2de2			endm  
# End of macro DMARK
2de2						CALLMONITOR 
2de2 cd 6f ee			call debug_vector  
2de5				endm  
# End of macro CALLMONITOR
2de5					endif 
2de5			 
2de5					FORTH_DSP_VALUEHL 
2de5 cd 5e 1d			call macro_dsp_valuehl 
2de8				endm 
# End of macro FORTH_DSP_VALUEHL
2de8			 
2de8 e5					push hl   ; save address 
2de9			 
2de9			 
2de9					FORTH_DSP_POP 
2de9 cd 16 1e			call macro_forth_dsp_pop 
2dec				endm 
# End of macro FORTH_DSP_POP
2dec			 
2dec					 
2dec					FORTH_DSP_VALUEHL 
2dec cd 5e 1d			call macro_dsp_valuehl 
2def				endm 
# End of macro FORTH_DSP_VALUEHL
2def			 
2def					FORTH_DSP_POP 
2def cd 16 1e			call macro_forth_dsp_pop 
2df2				endm 
# End of macro FORTH_DSP_POP
2df2			 
2df2 eb					ex de, hl    ; value now in de 
2df3			 
2df3 e1					pop hl 
2df4			 
2df4 73					ld (hl), e 
2df5			 
2df5 23					inc hl 
2df6			 
2df6 72					ld (hl), d 
2df7			 
2df7			 
2df7				       NEXTW 
2df7 c3 14 1f			jp macro_next 
2dfa				endm 
# End of macro NEXTW
2dfa			.CONFIG: 
2dfa				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
2dfa 6f				db WORD_SYS_CORE+91             
2dfb 0b 2e			dw .ADTOS            
2dfd 07				db 6 + 1 
2dfe .. 00			db "CONFIG",0              
2e05				endm 
# End of macro CWHEAD
2e05			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2e05			 
2e05 cd 67 13				call config 
2e08					NEXTW 
2e08 c3 14 1f			jp macro_next 
2e0b				endm 
# End of macro NEXTW
2e0b			 
2e0b			.ADTOS: 
2e0b				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
2e0b 6f				db WORD_SYS_CORE+91             
2e0c 21 2e			dw .SBTOS            
2e0e 03				db 2 + 1 
2e0f .. 00			db "1+",0              
2e12				endm 
# End of macro CWHEAD
2e12			; | 1+ ( u -- u )  Increment value on TOS | DONE 
2e12			 
2e12					FORTH_DSP_VALUEHL 
2e12 cd 5e 1d			call macro_dsp_valuehl 
2e15				endm 
# End of macro FORTH_DSP_VALUEHL
2e15 e5					push hl 
2e16			 
2e16					FORTH_DSP_POP 
2e16 cd 16 1e			call macro_forth_dsp_pop 
2e19				endm 
# End of macro FORTH_DSP_POP
2e19 e1					pop hl 
2e1a			 
2e1a 23					inc hl 
2e1b cd 67 1b				call forth_push_numhl 
2e1e					 
2e1e					NEXTW 
2e1e c3 14 1f			jp macro_next 
2e21				endm 
# End of macro NEXTW
2e21			.SBTOS: 
2e21				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
2e21 6f				db WORD_SYS_CORE+91             
2e22 37 2e			dw .ADSTORE            
2e24 03				db 2 + 1 
2e25 .. 00			db "1-",0              
2e28				endm 
# End of macro CWHEAD
2e28			; | 1- ( u -- u )  Decrement value on TOS | DONE 
2e28			 
2e28					FORTH_DSP_VALUEHL 
2e28 cd 5e 1d			call macro_dsp_valuehl 
2e2b				endm 
# End of macro FORTH_DSP_VALUEHL
2e2b e5					push hl 
2e2c			 
2e2c					FORTH_DSP_POP 
2e2c cd 16 1e			call macro_forth_dsp_pop 
2e2f				endm 
# End of macro FORTH_DSP_POP
2e2f e1					pop hl 
2e30			 
2e30 2b					dec hl 
2e31 cd 67 1b				call forth_push_numhl 
2e34					 
2e34					NEXTW 
2e34 c3 14 1f			jp macro_next 
2e37				endm 
# End of macro NEXTW
2e37			.ADSTORE: 
2e37				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
2e37 6f				db WORD_SYS_CORE+91             
2e38 4d 2e			dw .ADWSTORE            
2e3a 04				db 3 + 1 
2e3b .. 00			db "1+!",0              
2e3f				endm 
# End of macro CWHEAD
2e3f			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
2e3f			 
2e3f					FORTH_DSP_VALUEHL 
2e3f cd 5e 1d			call macro_dsp_valuehl 
2e42				endm 
# End of macro FORTH_DSP_VALUEHL
2e42 e5					push hl 
2e43			 
2e43					FORTH_DSP_POP 
2e43 cd 16 1e			call macro_forth_dsp_pop 
2e46				endm 
# End of macro FORTH_DSP_POP
2e46 e1					pop hl 
2e47			 
2e47 7e					ld a, (hl) 
2e48 3c					inc a 
2e49 77					ld (hl), a 
2e4a					 
2e4a					NEXTW 
2e4a c3 14 1f			jp macro_next 
2e4d				endm 
# End of macro NEXTW
2e4d			.ADWSTORE: 
2e4d				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
2e4d 6f				db WORD_SYS_CORE+91             
2e4e 6b 2e			dw .SBSTORE            
2e50 05				db 4 + 1 
2e51 .. 00			db "1+2!",0              
2e56				endm 
# End of macro CWHEAD
2e56			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
2e56			 
2e56					FORTH_DSP_VALUEHL 
2e56 cd 5e 1d			call macro_dsp_valuehl 
2e59				endm 
# End of macro FORTH_DSP_VALUEHL
2e59 e5					push hl 
2e5a			 
2e5a					FORTH_DSP_POP 
2e5a cd 16 1e			call macro_forth_dsp_pop 
2e5d				endm 
# End of macro FORTH_DSP_POP
2e5d e1					pop hl 
2e5e			 
2e5e e5					push hl 
2e5f			 
2e5f cd 96 1e				call loadwordinhl 
2e62 23					inc hl 
2e63			 
2e63 d1					pop de 
2e64 eb					ex de, hl 
2e65 73					ld (hl), e 
2e66 23					inc hl 
2e67 72					ld (hl), d 
2e68					 
2e68					NEXTW 
2e68 c3 14 1f			jp macro_next 
2e6b				endm 
# End of macro NEXTW
2e6b			.SBSTORE: 
2e6b				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
2e6b 6f				db WORD_SYS_CORE+91             
2e6c 81 2e			dw .SBWSTORE            
2e6e 04				db 3 + 1 
2e6f .. 00			db "1-!",0              
2e73				endm 
# End of macro CWHEAD
2e73			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
2e73			 
2e73					FORTH_DSP_VALUEHL 
2e73 cd 5e 1d			call macro_dsp_valuehl 
2e76				endm 
# End of macro FORTH_DSP_VALUEHL
2e76 e5					push hl 
2e77			 
2e77					FORTH_DSP_POP 
2e77 cd 16 1e			call macro_forth_dsp_pop 
2e7a				endm 
# End of macro FORTH_DSP_POP
2e7a e1					pop hl 
2e7b			 
2e7b 7e					ld a, (hl) 
2e7c 3d					dec a 
2e7d 77					ld (hl), a 
2e7e					 
2e7e					NEXTW 
2e7e c3 14 1f			jp macro_next 
2e81				endm 
# End of macro NEXTW
2e81			.SBWSTORE: 
2e81				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
2e81 6f				db WORD_SYS_CORE+91             
2e82 9f 2e			dw .ENDCORE            
2e84 05				db 4 + 1 
2e85 .. 00			db "1-2!",0              
2e8a				endm 
# End of macro CWHEAD
2e8a			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
2e8a			 
2e8a					FORTH_DSP_VALUEHL 
2e8a cd 5e 1d			call macro_dsp_valuehl 
2e8d				endm 
# End of macro FORTH_DSP_VALUEHL
2e8d e5					push hl 
2e8e			 
2e8e					FORTH_DSP_POP 
2e8e cd 16 1e			call macro_forth_dsp_pop 
2e91				endm 
# End of macro FORTH_DSP_POP
2e91 e1					pop hl 
2e92			 
2e92 e5					push hl 
2e93			 
2e93 cd 96 1e				call loadwordinhl 
2e96 2b					dec hl 
2e97			 
2e97 d1					pop de 
2e98 eb					ex de, hl 
2e99 73					ld (hl), e 
2e9a 23					inc hl 
2e9b 72					ld (hl), d 
2e9c					 
2e9c					NEXTW 
2e9c c3 14 1f			jp macro_next 
2e9f				endm 
# End of macro NEXTW
2e9f			.ENDCORE: 
2e9f			 
2e9f			; eof 
2e9f			 
2e9f			 
# End of file forth_words_core.asm
2e9f			include "forth_words_flow.asm" 
2e9f			 
2e9f			; | ## Program Flow Words 
2e9f			 
2e9f			.IF: 
2e9f				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2e9f 1e				db WORD_SYS_CORE+10             
2ea0 94 2f			dw .THEN            
2ea2 03				db 2 + 1 
2ea3 .. 00			db "IF",0              
2ea6				endm 
# End of macro CWHEAD
2ea6			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2ea6			; 
2ea6					if DEBUG_FORTH_WORDS_KEY 
2ea6						DMARK "IF." 
2ea6 f5				push af  
2ea7 3a bb 2e			ld a, (.dmark)  
2eaa 32 6b ee			ld (debug_mark),a  
2ead 3a bc 2e			ld a, (.dmark+1)  
2eb0 32 6c ee			ld (debug_mark+1),a  
2eb3 3a bd 2e			ld a, (.dmark+2)  
2eb6 32 6d ee			ld (debug_mark+2),a  
2eb9 18 03			jr .pastdmark  
2ebb ..			.dmark: db "IF."  
2ebe f1			.pastdmark: pop af  
2ebf			endm  
# End of macro DMARK
2ebf						CALLMONITOR 
2ebf cd 6f ee			call debug_vector  
2ec2				endm  
# End of macro CALLMONITOR
2ec2					endif 
2ec2			; eval TOS 
2ec2			 
2ec2				FORTH_DSP_VALUEHL 
2ec2 cd 5e 1d			call macro_dsp_valuehl 
2ec5				endm 
# End of macro FORTH_DSP_VALUEHL
2ec5			 
2ec5			;	push hl 
2ec5				FORTH_DSP_POP 
2ec5 cd 16 1e			call macro_forth_dsp_pop 
2ec8				endm 
# End of macro FORTH_DSP_POP
2ec8			;	pop hl 
2ec8			 
2ec8					if DEBUG_FORTH_WORDS 
2ec8						DMARK "IF1" 
2ec8 f5				push af  
2ec9 3a dd 2e			ld a, (.dmark)  
2ecc 32 6b ee			ld (debug_mark),a  
2ecf 3a de 2e			ld a, (.dmark+1)  
2ed2 32 6c ee			ld (debug_mark+1),a  
2ed5 3a df 2e			ld a, (.dmark+2)  
2ed8 32 6d ee			ld (debug_mark+2),a  
2edb 18 03			jr .pastdmark  
2edd ..			.dmark: db "IF1"  
2ee0 f1			.pastdmark: pop af  
2ee1			endm  
# End of macro DMARK
2ee1						CALLMONITOR 
2ee1 cd 6f ee			call debug_vector  
2ee4				endm  
# End of macro CALLMONITOR
2ee4					endif 
2ee4 b7				or a        ; clear carry flag 
2ee5 11 00 00			ld de, 0 
2ee8 eb				ex de,hl 
2ee9 ed 52			sbc hl, de 
2eeb c2 75 2f			jp nz, .iftrue 
2eee			 
2eee					if DEBUG_FORTH_WORDS 
2eee						DMARK "IF2" 
2eee f5				push af  
2eef 3a 03 2f			ld a, (.dmark)  
2ef2 32 6b ee			ld (debug_mark),a  
2ef5 3a 04 2f			ld a, (.dmark+1)  
2ef8 32 6c ee			ld (debug_mark+1),a  
2efb 3a 05 2f			ld a, (.dmark+2)  
2efe 32 6d ee			ld (debug_mark+2),a  
2f01 18 03			jr .pastdmark  
2f03 ..			.dmark: db "IF2"  
2f06 f1			.pastdmark: pop af  
2f07			endm  
# End of macro DMARK
2f07						CALLMONITOR 
2f07 cd 6f ee			call debug_vector  
2f0a				endm  
# End of macro CALLMONITOR
2f0a					endif 
2f0a			 
2f0a			; if not true then skip to THEN 
2f0a			 
2f0a				; TODO get tok_ptr 
2f0a				; TODO consume toks until we get to THEN 
2f0a			 
2f0a 2a c2 e5			ld hl, (os_tok_ptr) 
2f0d					if DEBUG_FORTH_WORDS 
2f0d						DMARK "IF3" 
2f0d f5				push af  
2f0e 3a 22 2f			ld a, (.dmark)  
2f11 32 6b ee			ld (debug_mark),a  
2f14 3a 23 2f			ld a, (.dmark+1)  
2f17 32 6c ee			ld (debug_mark+1),a  
2f1a 3a 24 2f			ld a, (.dmark+2)  
2f1d 32 6d ee			ld (debug_mark+2),a  
2f20 18 03			jr .pastdmark  
2f22 ..			.dmark: db "IF3"  
2f25 f1			.pastdmark: pop af  
2f26			endm  
# End of macro DMARK
2f26						CALLMONITOR 
2f26 cd 6f ee			call debug_vector  
2f29				endm  
# End of macro CALLMONITOR
2f29						 
2f29					endif 
2f29 11 70 2f			ld de, .ifthen 
2f2c					if DEBUG_FORTH_WORDS 
2f2c						DMARK "IF4" 
2f2c f5				push af  
2f2d 3a 41 2f			ld a, (.dmark)  
2f30 32 6b ee			ld (debug_mark),a  
2f33 3a 42 2f			ld a, (.dmark+1)  
2f36 32 6c ee			ld (debug_mark+1),a  
2f39 3a 43 2f			ld a, (.dmark+2)  
2f3c 32 6d ee			ld (debug_mark+2),a  
2f3f 18 03			jr .pastdmark  
2f41 ..			.dmark: db "IF4"  
2f44 f1			.pastdmark: pop af  
2f45			endm  
# End of macro DMARK
2f45						CALLMONITOR 
2f45 cd 6f ee			call debug_vector  
2f48				endm  
# End of macro CALLMONITOR
2f48					endif 
2f48 cd 2f 20			call findnexttok  
2f4b			 
2f4b					if DEBUG_FORTH_WORDS 
2f4b						DMARK "IF5" 
2f4b f5				push af  
2f4c 3a 60 2f			ld a, (.dmark)  
2f4f 32 6b ee			ld (debug_mark),a  
2f52 3a 61 2f			ld a, (.dmark+1)  
2f55 32 6c ee			ld (debug_mark+1),a  
2f58 3a 62 2f			ld a, (.dmark+2)  
2f5b 32 6d ee			ld (debug_mark+2),a  
2f5e 18 03			jr .pastdmark  
2f60 ..			.dmark: db "IF5"  
2f63 f1			.pastdmark: pop af  
2f64			endm  
# End of macro DMARK
2f64						CALLMONITOR 
2f64 cd 6f ee			call debug_vector  
2f67				endm  
# End of macro CALLMONITOR
2f67					endif 
2f67				; TODO replace below with ; exec using tok_ptr 
2f67 22 c2 e5			ld (os_tok_ptr), hl 
2f6a c3 a5 1f			jp exec1 
2f6d				NEXTW 
2f6d c3 14 1f			jp macro_next 
2f70				endm 
# End of macro NEXTW
2f70			 
2f70 .. 00		.ifthen:  db "THEN",0 
2f75			 
2f75			.iftrue:		 
2f75				; Exec next words normally 
2f75			 
2f75				; if true then exec following IF as normal 
2f75					if DEBUG_FORTH_WORDS 
2f75						DMARK "IFT" 
2f75 f5				push af  
2f76 3a 8a 2f			ld a, (.dmark)  
2f79 32 6b ee			ld (debug_mark),a  
2f7c 3a 8b 2f			ld a, (.dmark+1)  
2f7f 32 6c ee			ld (debug_mark+1),a  
2f82 3a 8c 2f			ld a, (.dmark+2)  
2f85 32 6d ee			ld (debug_mark+2),a  
2f88 18 03			jr .pastdmark  
2f8a ..			.dmark: db "IFT"  
2f8d f1			.pastdmark: pop af  
2f8e			endm  
# End of macro DMARK
2f8e						CALLMONITOR 
2f8e cd 6f ee			call debug_vector  
2f91				endm  
# End of macro CALLMONITOR
2f91					endif 
2f91			 
2f91					NEXTW 
2f91 c3 14 1f			jp macro_next 
2f94				endm 
# End of macro NEXTW
2f94			.THEN: 
2f94				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2f94 1f				db WORD_SYS_CORE+11             
2f95 bc 2f			dw .ELSE            
2f97 05				db 4 + 1 
2f98 .. 00			db "THEN",0              
2f9d				endm 
# End of macro CWHEAD
2f9d			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2f9d					if DEBUG_FORTH_WORDS_KEY 
2f9d						DMARK "THN" 
2f9d f5				push af  
2f9e 3a b2 2f			ld a, (.dmark)  
2fa1 32 6b ee			ld (debug_mark),a  
2fa4 3a b3 2f			ld a, (.dmark+1)  
2fa7 32 6c ee			ld (debug_mark+1),a  
2faa 3a b4 2f			ld a, (.dmark+2)  
2fad 32 6d ee			ld (debug_mark+2),a  
2fb0 18 03			jr .pastdmark  
2fb2 ..			.dmark: db "THN"  
2fb5 f1			.pastdmark: pop af  
2fb6			endm  
# End of macro DMARK
2fb6						CALLMONITOR 
2fb6 cd 6f ee			call debug_vector  
2fb9				endm  
# End of macro CALLMONITOR
2fb9					endif 
2fb9					NEXTW 
2fb9 c3 14 1f			jp macro_next 
2fbc				endm 
# End of macro NEXTW
2fbc			.ELSE: 
2fbc				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2fbc 20				db WORD_SYS_CORE+12             
2fbd e4 2f			dw .DO            
2fbf 03				db 2 + 1 
2fc0 .. 00			db "ELSE",0              
2fc5				endm 
# End of macro CWHEAD
2fc5			; | ELSE ( -- ) Not supported - does nothing | TODO 
2fc5			 
2fc5					if DEBUG_FORTH_WORDS_KEY 
2fc5						DMARK "ELS" 
2fc5 f5				push af  
2fc6 3a da 2f			ld a, (.dmark)  
2fc9 32 6b ee			ld (debug_mark),a  
2fcc 3a db 2f			ld a, (.dmark+1)  
2fcf 32 6c ee			ld (debug_mark+1),a  
2fd2 3a dc 2f			ld a, (.dmark+2)  
2fd5 32 6d ee			ld (debug_mark+2),a  
2fd8 18 03			jr .pastdmark  
2fda ..			.dmark: db "ELS"  
2fdd f1			.pastdmark: pop af  
2fde			endm  
# End of macro DMARK
2fde						CALLMONITOR 
2fde cd 6f ee			call debug_vector  
2fe1				endm  
# End of macro CALLMONITOR
2fe1					endif 
2fe1			 
2fe1			 
2fe1					NEXTW 
2fe1 c3 14 1f			jp macro_next 
2fe4				endm 
# End of macro NEXTW
2fe4			.DO: 
2fe4				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2fe4 21				db WORD_SYS_CORE+13             
2fe5 0b 31			dw .LOOP            
2fe7 03				db 2 + 1 
2fe8 .. 00			db "DO",0              
2feb				endm 
# End of macro CWHEAD
2feb			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2feb			 
2feb					if DEBUG_FORTH_WORDS_KEY 
2feb						DMARK "DO." 
2feb f5				push af  
2fec 3a 00 30			ld a, (.dmark)  
2fef 32 6b ee			ld (debug_mark),a  
2ff2 3a 01 30			ld a, (.dmark+1)  
2ff5 32 6c ee			ld (debug_mark+1),a  
2ff8 3a 02 30			ld a, (.dmark+2)  
2ffb 32 6d ee			ld (debug_mark+2),a  
2ffe 18 03			jr .pastdmark  
3000 ..			.dmark: db "DO."  
3003 f1			.pastdmark: pop af  
3004			endm  
# End of macro DMARK
3004						CALLMONITOR 
3004 cd 6f ee			call debug_vector  
3007				endm  
# End of macro CALLMONITOR
3007					endif 
3007			;  push pc to rsp stack past the DO 
3007			 
3007 2a c2 e5				ld hl, (os_tok_ptr) 
300a 23					inc hl   ; D 
300b 23					inc hl  ; O 
300c 23					inc hl   ; null 
300d					if DEBUG_FORTH_WORDS 
300d						DMARK "DO2" 
300d f5				push af  
300e 3a 22 30			ld a, (.dmark)  
3011 32 6b ee			ld (debug_mark),a  
3014 3a 23 30			ld a, (.dmark+1)  
3017 32 6c ee			ld (debug_mark+1),a  
301a 3a 24 30			ld a, (.dmark+2)  
301d 32 6d ee			ld (debug_mark+2),a  
3020 18 03			jr .pastdmark  
3022 ..			.dmark: db "DO2"  
3025 f1			.pastdmark: pop af  
3026			endm  
# End of macro DMARK
3026						CALLMONITOR 
3026 cd 6f ee			call debug_vector  
3029				endm  
# End of macro CALLMONITOR
3029					endif 
3029					FORTH_RSP_NEXT 
3029 cd 0e 1b			call macro_forth_rsp_next 
302c				endm 
# End of macro FORTH_RSP_NEXT
302c					if DEBUG_FORTH_WORDS 
302c						DMARK "DO3" 
302c f5				push af  
302d 3a 41 30			ld a, (.dmark)  
3030 32 6b ee			ld (debug_mark),a  
3033 3a 42 30			ld a, (.dmark+1)  
3036 32 6c ee			ld (debug_mark+1),a  
3039 3a 43 30			ld a, (.dmark+2)  
303c 32 6d ee			ld (debug_mark+2),a  
303f 18 03			jr .pastdmark  
3041 ..			.dmark: db "DO3"  
3044 f1			.pastdmark: pop af  
3045			endm  
# End of macro DMARK
3045						CALLMONITOR 
3045 cd 6f ee			call debug_vector  
3048				endm  
# End of macro CALLMONITOR
3048					endif 
3048			 
3048					;if DEBUG_FORTH_WORDS 
3048				;		push hl 
3048			;		endif  
3048			 
3048			; get counters from data stack 
3048			 
3048			 
3048					FORTH_DSP_VALUEHL 
3048 cd 5e 1d			call macro_dsp_valuehl 
304b				endm 
# End of macro FORTH_DSP_VALUEHL
304b e5					push hl		 ; hl now has starting counter which needs to be tos 
304c			 
304c					if DEBUG_FORTH_WORDS 
304c						DMARK "DO4" 
304c f5				push af  
304d 3a 61 30			ld a, (.dmark)  
3050 32 6b ee			ld (debug_mark),a  
3053 3a 62 30			ld a, (.dmark+1)  
3056 32 6c ee			ld (debug_mark+1),a  
3059 3a 63 30			ld a, (.dmark+2)  
305c 32 6d ee			ld (debug_mark+2),a  
305f 18 03			jr .pastdmark  
3061 ..			.dmark: db "DO4"  
3064 f1			.pastdmark: pop af  
3065			endm  
# End of macro DMARK
3065						CALLMONITOR 
3065 cd 6f ee			call debug_vector  
3068				endm  
# End of macro CALLMONITOR
3068					endif 
3068					FORTH_DSP_POP 
3068 cd 16 1e			call macro_forth_dsp_pop 
306b				endm 
# End of macro FORTH_DSP_POP
306b			 
306b					if DEBUG_FORTH_WORDS 
306b						DMARK "DO5" 
306b f5				push af  
306c 3a 80 30			ld a, (.dmark)  
306f 32 6b ee			ld (debug_mark),a  
3072 3a 81 30			ld a, (.dmark+1)  
3075 32 6c ee			ld (debug_mark+1),a  
3078 3a 82 30			ld a, (.dmark+2)  
307b 32 6d ee			ld (debug_mark+2),a  
307e 18 03			jr .pastdmark  
3080 ..			.dmark: db "DO5"  
3083 f1			.pastdmark: pop af  
3084			endm  
# End of macro DMARK
3084						CALLMONITOR 
3084 cd 6f ee			call debug_vector  
3087				endm  
# End of macro CALLMONITOR
3087					endif 
3087			 
3087					FORTH_DSP_VALUEHL 
3087 cd 5e 1d			call macro_dsp_valuehl 
308a				endm 
# End of macro FORTH_DSP_VALUEHL
308a			;		push hl		 ; hl now has starting limit counter 
308a			 
308a					if DEBUG_FORTH_WORDS 
308a						DMARK "DO6" 
308a f5				push af  
308b 3a 9f 30			ld a, (.dmark)  
308e 32 6b ee			ld (debug_mark),a  
3091 3a a0 30			ld a, (.dmark+1)  
3094 32 6c ee			ld (debug_mark+1),a  
3097 3a a1 30			ld a, (.dmark+2)  
309a 32 6d ee			ld (debug_mark+2),a  
309d 18 03			jr .pastdmark  
309f ..			.dmark: db "DO6"  
30a2 f1			.pastdmark: pop af  
30a3			endm  
# End of macro DMARK
30a3						CALLMONITOR 
30a3 cd 6f ee			call debug_vector  
30a6				endm  
# End of macro CALLMONITOR
30a6					endif 
30a6					FORTH_DSP_POP 
30a6 cd 16 1e			call macro_forth_dsp_pop 
30a9				endm 
# End of macro FORTH_DSP_POP
30a9			 
30a9			; put counters on the loop stack 
30a9			 
30a9			;		pop hl			 ; limit counter 
30a9 d1					pop de			; start counter 
30aa			 
30aa					; push limit counter 
30aa			 
30aa					if DEBUG_FORTH_WORDS 
30aa						DMARK "DO7" 
30aa f5				push af  
30ab 3a bf 30			ld a, (.dmark)  
30ae 32 6b ee			ld (debug_mark),a  
30b1 3a c0 30			ld a, (.dmark+1)  
30b4 32 6c ee			ld (debug_mark+1),a  
30b7 3a c1 30			ld a, (.dmark+2)  
30ba 32 6d ee			ld (debug_mark+2),a  
30bd 18 03			jr .pastdmark  
30bf ..			.dmark: db "DO7"  
30c2 f1			.pastdmark: pop af  
30c3			endm  
# End of macro DMARK
30c3						CALLMONITOR 
30c3 cd 6f ee			call debug_vector  
30c6				endm  
# End of macro CALLMONITOR
30c6					endif 
30c6					FORTH_LOOP_NEXT 
30c6 cd 8f 1d			call macro_forth_loop_next 
30c9				endm 
# End of macro FORTH_LOOP_NEXT
30c9			 
30c9					; push start counter 
30c9			 
30c9 eb					ex de, hl 
30ca					if DEBUG_FORTH_WORDS 
30ca						DMARK "DO7" 
30ca f5				push af  
30cb 3a df 30			ld a, (.dmark)  
30ce 32 6b ee			ld (debug_mark),a  
30d1 3a e0 30			ld a, (.dmark+1)  
30d4 32 6c ee			ld (debug_mark+1),a  
30d7 3a e1 30			ld a, (.dmark+2)  
30da 32 6d ee			ld (debug_mark+2),a  
30dd 18 03			jr .pastdmark  
30df ..			.dmark: db "DO7"  
30e2 f1			.pastdmark: pop af  
30e3			endm  
# End of macro DMARK
30e3						CALLMONITOR 
30e3 cd 6f ee			call debug_vector  
30e6				endm  
# End of macro CALLMONITOR
30e6					endif 
30e6					FORTH_LOOP_NEXT 
30e6 cd 8f 1d			call macro_forth_loop_next 
30e9				endm 
# End of macro FORTH_LOOP_NEXT
30e9			 
30e9			 
30e9					; init first round of I counter 
30e9			 
30e9 22 e6 e5				ld (os_current_i), hl 
30ec			 
30ec					if DEBUG_FORTH_WORDS 
30ec						DMARK "DO8" 
30ec f5				push af  
30ed 3a 01 31			ld a, (.dmark)  
30f0 32 6b ee			ld (debug_mark),a  
30f3 3a 02 31			ld a, (.dmark+1)  
30f6 32 6c ee			ld (debug_mark+1),a  
30f9 3a 03 31			ld a, (.dmark+2)  
30fc 32 6d ee			ld (debug_mark+2),a  
30ff 18 03			jr .pastdmark  
3101 ..			.dmark: db "DO8"  
3104 f1			.pastdmark: pop af  
3105			endm  
# End of macro DMARK
3105						CALLMONITOR 
3105 cd 6f ee			call debug_vector  
3108				endm  
# End of macro CALLMONITOR
3108					endif 
3108			 
3108					NEXTW 
3108 c3 14 1f			jp macro_next 
310b				endm 
# End of macro NEXTW
310b			.LOOP: 
310b				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
310b 22				db WORD_SYS_CORE+14             
310c 23 32			dw .I            
310e 05				db 4 + 1 
310f .. 00			db "LOOP",0              
3114				endm 
# End of macro CWHEAD
3114			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3114			 
3114				; pop tos as current loop count to hl 
3114			 
3114				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3114			 
3114				FORTH_LOOP_TOS 
3114 cd c2 1d			call macro_forth_loop_tos 
3117				endm 
# End of macro FORTH_LOOP_TOS
3117 e5				push hl 
3118			 
3118					if DEBUG_FORTH_WORDS_KEY 
3118						DMARK "LOP" 
3118 f5				push af  
3119 3a 2d 31			ld a, (.dmark)  
311c 32 6b ee			ld (debug_mark),a  
311f 3a 2e 31			ld a, (.dmark+1)  
3122 32 6c ee			ld (debug_mark+1),a  
3125 3a 2f 31			ld a, (.dmark+2)  
3128 32 6d ee			ld (debug_mark+2),a  
312b 18 03			jr .pastdmark  
312d ..			.dmark: db "LOP"  
3130 f1			.pastdmark: pop af  
3131			endm  
# End of macro DMARK
3131						CALLMONITOR 
3131 cd 6f ee			call debug_vector  
3134				endm  
# End of macro CALLMONITOR
3134					endif 
3134				; next item on the stack is the limit. get it 
3134			 
3134			 
3134				FORTH_LOOP_POP 
3134 cd cc 1d			call macro_forth_loop_pop 
3137				endm 
# End of macro FORTH_LOOP_POP
3137			 
3137				FORTH_LOOP_TOS 
3137 cd c2 1d			call macro_forth_loop_tos 
313a				endm 
# End of macro FORTH_LOOP_TOS
313a			 
313a d1				pop de		 ; de = i, hl = limit 
313b			 
313b					if DEBUG_FORTH_WORDS 
313b						DMARK "LP1" 
313b f5				push af  
313c 3a 50 31			ld a, (.dmark)  
313f 32 6b ee			ld (debug_mark),a  
3142 3a 51 31			ld a, (.dmark+1)  
3145 32 6c ee			ld (debug_mark+1),a  
3148 3a 52 31			ld a, (.dmark+2)  
314b 32 6d ee			ld (debug_mark+2),a  
314e 18 03			jr .pastdmark  
3150 ..			.dmark: db "LP1"  
3153 f1			.pastdmark: pop af  
3154			endm  
# End of macro DMARK
3154						CALLMONITOR 
3154 cd 6f ee			call debug_vector  
3157				endm  
# End of macro CALLMONITOR
3157					endif 
3157			 
3157				; go back to previous word 
3157			 
3157 d5				push de    ; save I for inc later 
3158			 
3158			 
3158				; get limit 
3158				;  is I at limit? 
3158			 
3158			 
3158					if DEBUG_FORTH_WORDS 
3158						DMARK "LP1" 
3158 f5				push af  
3159 3a 6d 31			ld a, (.dmark)  
315c 32 6b ee			ld (debug_mark),a  
315f 3a 6e 31			ld a, (.dmark+1)  
3162 32 6c ee			ld (debug_mark+1),a  
3165 3a 6f 31			ld a, (.dmark+2)  
3168 32 6d ee			ld (debug_mark+2),a  
316b 18 03			jr .pastdmark  
316d ..			.dmark: db "LP1"  
3170 f1			.pastdmark: pop af  
3171			endm  
# End of macro DMARK
3171						CALLMONITOR 
3171 cd 6f ee			call debug_vector  
3174				endm  
# End of macro CALLMONITOR
3174					endif 
3174			 
3174 ed 52			sbc hl, de 
3176			 
3176			 
3176				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3176			 
3176 20 26				jr nz, .loopnotdone 
3178			 
3178 e1				pop hl   ; get rid of saved I 
3179				FORTH_LOOP_POP     ; get rid of limit 
3179 cd cc 1d			call macro_forth_loop_pop 
317c				endm 
# End of macro FORTH_LOOP_POP
317c			 
317c				FORTH_RSP_POP     ; get rid of DO ptr 
317c cd 2f 1b			call macro_forth_rsp_pop 
317f				endm 
# End of macro FORTH_RSP_POP
317f			 
317f			if DEBUG_FORTH_WORDS 
317f						DMARK "LP>" 
317f f5				push af  
3180 3a 94 31			ld a, (.dmark)  
3183 32 6b ee			ld (debug_mark),a  
3186 3a 95 31			ld a, (.dmark+1)  
3189 32 6c ee			ld (debug_mark+1),a  
318c 3a 96 31			ld a, (.dmark+2)  
318f 32 6d ee			ld (debug_mark+2),a  
3192 18 03			jr .pastdmark  
3194 ..			.dmark: db "LP>"  
3197 f1			.pastdmark: pop af  
3198			endm  
# End of macro DMARK
3198				CALLMONITOR 
3198 cd 6f ee			call debug_vector  
319b				endm  
# End of macro CALLMONITOR
319b			endif 
319b			 
319b					NEXTW 
319b c3 14 1f			jp macro_next 
319e				endm 
# End of macro NEXTW
319e				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
319e			 
319e			.loopnotdone: 
319e			 
319e e1				pop hl    ; get I 
319f 23				inc hl 
31a0			 
31a0			   	; save new I 
31a0			 
31a0			 
31a0					; set I counter 
31a0			 
31a0 22 e6 e5				ld (os_current_i), hl 
31a3			 
31a3					if DEBUG_FORTH_WORDS 
31a3						DMARK "LPN" 
31a3 f5				push af  
31a4 3a b8 31			ld a, (.dmark)  
31a7 32 6b ee			ld (debug_mark),a  
31aa 3a b9 31			ld a, (.dmark+1)  
31ad 32 6c ee			ld (debug_mark+1),a  
31b0 3a ba 31			ld a, (.dmark+2)  
31b3 32 6d ee			ld (debug_mark+2),a  
31b6 18 03			jr .pastdmark  
31b8 ..			.dmark: db "LPN"  
31bb f1			.pastdmark: pop af  
31bc			endm  
# End of macro DMARK
31bc					CALLMONITOR 
31bc cd 6f ee			call debug_vector  
31bf				endm  
# End of macro CALLMONITOR
31bf					endif 
31bf					 
31bf				FORTH_LOOP_NEXT 
31bf cd 8f 1d			call macro_forth_loop_next 
31c2				endm 
# End of macro FORTH_LOOP_NEXT
31c2			 
31c2			 
31c2					if DEBUG_FORTH_WORDS 
31c2 eb						ex de,hl 
31c3					endif 
31c3			 
31c3			;	; get DO ptr 
31c3			; 
31c3					if DEBUG_FORTH_WORDS 
31c3						DMARK "LP7" 
31c3 f5				push af  
31c4 3a d8 31			ld a, (.dmark)  
31c7 32 6b ee			ld (debug_mark),a  
31ca 3a d9 31			ld a, (.dmark+1)  
31cd 32 6c ee			ld (debug_mark+1),a  
31d0 3a da 31			ld a, (.dmark+2)  
31d3 32 6d ee			ld (debug_mark+2),a  
31d6 18 03			jr .pastdmark  
31d8 ..			.dmark: db "LP7"  
31db f1			.pastdmark: pop af  
31dc			endm  
# End of macro DMARK
31dc					CALLMONITOR 
31dc cd 6f ee			call debug_vector  
31df				endm  
# End of macro CALLMONITOR
31df					endif 
31df				FORTH_RSP_TOS 
31df cd 25 1b			call macro_forth_rsp_tos 
31e2				endm 
# End of macro FORTH_RSP_TOS
31e2			 
31e2					if DEBUG_FORTH_WORDS 
31e2						DMARK "LP8" 
31e2 f5				push af  
31e3 3a f7 31			ld a, (.dmark)  
31e6 32 6b ee			ld (debug_mark),a  
31e9 3a f8 31			ld a, (.dmark+1)  
31ec 32 6c ee			ld (debug_mark+1),a  
31ef 3a f9 31			ld a, (.dmark+2)  
31f2 32 6d ee			ld (debug_mark+2),a  
31f5 18 03			jr .pastdmark  
31f7 ..			.dmark: db "LP8"  
31fa f1			.pastdmark: pop af  
31fb			endm  
# End of macro DMARK
31fb					CALLMONITOR 
31fb cd 6f ee			call debug_vector  
31fe				endm  
# End of macro CALLMONITOR
31fe					endif 
31fe				;push hl 
31fe			 
31fe				; not going to DO any more 
31fe				; get rid of the RSP pointer as DO will add it back in 
31fe				;FORTH_RSP_POP 
31fe				;pop hl 
31fe			 
31fe				;ld hl,(cli_ret_sp) 
31fe				;ld e, (hl) 
31fe				;inc hl 
31fe				;ld d, (hl) 
31fe				;ex de,hl 
31fe 22 c2 e5			ld (os_tok_ptr), hl 
3201					if DEBUG_FORTH_WORDS 
3201						DMARK "LP<" 
3201 f5				push af  
3202 3a 16 32			ld a, (.dmark)  
3205 32 6b ee			ld (debug_mark),a  
3208 3a 17 32			ld a, (.dmark+1)  
320b 32 6c ee			ld (debug_mark+1),a  
320e 3a 18 32			ld a, (.dmark+2)  
3211 32 6d ee			ld (debug_mark+2),a  
3214 18 03			jr .pastdmark  
3216 ..			.dmark: db "LP<"  
3219 f1			.pastdmark: pop af  
321a			endm  
# End of macro DMARK
321a					CALLMONITOR 
321a cd 6f ee			call debug_vector  
321d				endm  
# End of macro CALLMONITOR
321d				endif 
321d c3 a5 1f			jp exec1 
3220			 
3220					 
3220			 
3220			 
3220					NEXTW 
3220 c3 14 1f			jp macro_next 
3223				endm 
# End of macro NEXTW
3223			.I:  
3223			 
3223				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3223 5e				db WORD_SYS_CORE+74             
3224 4e 32			dw .DLOOP            
3226 02				db 1 + 1 
3227 .. 00			db "I",0              
3229				endm 
# End of macro CWHEAD
3229			; | I ( -- ) Current loop counter | DONE 
3229					if DEBUG_FORTH_WORDS_KEY 
3229						DMARK "I.." 
3229 f5				push af  
322a 3a 3e 32			ld a, (.dmark)  
322d 32 6b ee			ld (debug_mark),a  
3230 3a 3f 32			ld a, (.dmark+1)  
3233 32 6c ee			ld (debug_mark+1),a  
3236 3a 40 32			ld a, (.dmark+2)  
3239 32 6d ee			ld (debug_mark+2),a  
323c 18 03			jr .pastdmark  
323e ..			.dmark: db "I.."  
3241 f1			.pastdmark: pop af  
3242			endm  
# End of macro DMARK
3242						CALLMONITOR 
3242 cd 6f ee			call debug_vector  
3245				endm  
# End of macro CALLMONITOR
3245					endif 
3245			 
3245 2a e6 e5				ld hl,(os_current_i) 
3248 cd 67 1b				call forth_push_numhl 
324b			 
324b					NEXTW 
324b c3 14 1f			jp macro_next 
324e				endm 
# End of macro NEXTW
324e			.DLOOP: 
324e				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
324e 5f				db WORD_SYS_CORE+75             
324f 2f 33			dw .REPEAT            
3251 06				db 5 + 1 
3252 .. 00			db "-LOOP",0              
3258				endm 
# End of macro CWHEAD
3258			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3258				; pop tos as current loop count to hl 
3258					if DEBUG_FORTH_WORDS_KEY 
3258						DMARK "-LP" 
3258 f5				push af  
3259 3a 6d 32			ld a, (.dmark)  
325c 32 6b ee			ld (debug_mark),a  
325f 3a 6e 32			ld a, (.dmark+1)  
3262 32 6c ee			ld (debug_mark+1),a  
3265 3a 6f 32			ld a, (.dmark+2)  
3268 32 6d ee			ld (debug_mark+2),a  
326b 18 03			jr .pastdmark  
326d ..			.dmark: db "-LP"  
3270 f1			.pastdmark: pop af  
3271			endm  
# End of macro DMARK
3271						CALLMONITOR 
3271 cd 6f ee			call debug_vector  
3274				endm  
# End of macro CALLMONITOR
3274					endif 
3274			 
3274				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3274			 
3274				FORTH_LOOP_TOS 
3274 cd c2 1d			call macro_forth_loop_tos 
3277				endm 
# End of macro FORTH_LOOP_TOS
3277 e5				push hl 
3278			 
3278					if DEBUG_FORTH_WORDS 
3278						DMARK "-LP" 
3278 f5				push af  
3279 3a 8d 32			ld a, (.dmark)  
327c 32 6b ee			ld (debug_mark),a  
327f 3a 8e 32			ld a, (.dmark+1)  
3282 32 6c ee			ld (debug_mark+1),a  
3285 3a 8f 32			ld a, (.dmark+2)  
3288 32 6d ee			ld (debug_mark+2),a  
328b 18 03			jr .pastdmark  
328d ..			.dmark: db "-LP"  
3290 f1			.pastdmark: pop af  
3291			endm  
# End of macro DMARK
3291						CALLMONITOR 
3291 cd 6f ee			call debug_vector  
3294				endm  
# End of macro CALLMONITOR
3294					endif 
3294				; next item on the stack is the limit. get it 
3294			 
3294			 
3294				FORTH_LOOP_POP 
3294 cd cc 1d			call macro_forth_loop_pop 
3297				endm 
# End of macro FORTH_LOOP_POP
3297			 
3297				FORTH_LOOP_TOS 
3297 cd c2 1d			call macro_forth_loop_tos 
329a				endm 
# End of macro FORTH_LOOP_TOS
329a			 
329a d1				pop de		 ; de = i, hl = limit 
329b			 
329b					if DEBUG_FORTH_WORDS 
329b						DMARK "-L1" 
329b f5				push af  
329c 3a b0 32			ld a, (.dmark)  
329f 32 6b ee			ld (debug_mark),a  
32a2 3a b1 32			ld a, (.dmark+1)  
32a5 32 6c ee			ld (debug_mark+1),a  
32a8 3a b2 32			ld a, (.dmark+2)  
32ab 32 6d ee			ld (debug_mark+2),a  
32ae 18 03			jr .pastdmark  
32b0 ..			.dmark: db "-L1"  
32b3 f1			.pastdmark: pop af  
32b4			endm  
# End of macro DMARK
32b4						CALLMONITOR 
32b4 cd 6f ee			call debug_vector  
32b7				endm  
# End of macro CALLMONITOR
32b7					endif 
32b7			 
32b7				; go back to previous word 
32b7			 
32b7 d5				push de    ; save I for inc later 
32b8			 
32b8			 
32b8				; get limit 
32b8				;  is I at limit? 
32b8			 
32b8			 
32b8					if DEBUG_FORTH_WORDS 
32b8						DMARK "-L1" 
32b8 f5				push af  
32b9 3a cd 32			ld a, (.dmark)  
32bc 32 6b ee			ld (debug_mark),a  
32bf 3a ce 32			ld a, (.dmark+1)  
32c2 32 6c ee			ld (debug_mark+1),a  
32c5 3a cf 32			ld a, (.dmark+2)  
32c8 32 6d ee			ld (debug_mark+2),a  
32cb 18 03			jr .pastdmark  
32cd ..			.dmark: db "-L1"  
32d0 f1			.pastdmark: pop af  
32d1			endm  
# End of macro DMARK
32d1						CALLMONITOR 
32d1 cd 6f ee			call debug_vector  
32d4				endm  
# End of macro CALLMONITOR
32d4					endif 
32d4			 
32d4 ed 52			sbc hl, de 
32d6			 
32d6			 
32d6				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
32d6			 
32d6 20 26				jr nz, .mloopnotdone 
32d8			 
32d8 e1				pop hl   ; get rid of saved I 
32d9				FORTH_LOOP_POP     ; get rid of limit 
32d9 cd cc 1d			call macro_forth_loop_pop 
32dc				endm 
# End of macro FORTH_LOOP_POP
32dc			 
32dc				FORTH_RSP_POP     ; get rid of DO ptr 
32dc cd 2f 1b			call macro_forth_rsp_pop 
32df				endm 
# End of macro FORTH_RSP_POP
32df			 
32df			if DEBUG_FORTH_WORDS 
32df						DMARK "-L>" 
32df f5				push af  
32e0 3a f4 32			ld a, (.dmark)  
32e3 32 6b ee			ld (debug_mark),a  
32e6 3a f5 32			ld a, (.dmark+1)  
32e9 32 6c ee			ld (debug_mark+1),a  
32ec 3a f6 32			ld a, (.dmark+2)  
32ef 32 6d ee			ld (debug_mark+2),a  
32f2 18 03			jr .pastdmark  
32f4 ..			.dmark: db "-L>"  
32f7 f1			.pastdmark: pop af  
32f8			endm  
# End of macro DMARK
32f8				CALLMONITOR 
32f8 cd 6f ee			call debug_vector  
32fb				endm  
# End of macro CALLMONITOR
32fb			endif 
32fb			 
32fb					NEXTW 
32fb c3 14 1f			jp macro_next 
32fe				endm 
# End of macro NEXTW
32fe				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
32fe			 
32fe			.mloopnotdone: 
32fe			 
32fe e1				pop hl    ; get I 
32ff 2b				dec hl 
3300			 
3300			   	; save new I 
3300			 
3300			 
3300					; set I counter 
3300			 
3300 22 e6 e5				ld (os_current_i), hl 
3303			 
3303					 
3303				FORTH_LOOP_NEXT 
3303 cd 8f 1d			call macro_forth_loop_next 
3306				endm 
# End of macro FORTH_LOOP_NEXT
3306			 
3306			 
3306					if DEBUG_FORTH_WORDS 
3306 eb						ex de,hl 
3307					endif 
3307			 
3307			;	; get DO ptr 
3307			; 
3307				FORTH_RSP_TOS 
3307 cd 25 1b			call macro_forth_rsp_tos 
330a				endm 
# End of macro FORTH_RSP_TOS
330a			 
330a				;push hl 
330a			 
330a				; not going to DO any more 
330a				; get rid of the RSP pointer as DO will add it back in 
330a				;FORTH_RSP_POP 
330a				;pop hl 
330a			 
330a			 
330a 22 c2 e5			ld (os_tok_ptr), hl 
330d					if DEBUG_FORTH_WORDS 
330d						DMARK "-L<" 
330d f5				push af  
330e 3a 22 33			ld a, (.dmark)  
3311 32 6b ee			ld (debug_mark),a  
3314 3a 23 33			ld a, (.dmark+1)  
3317 32 6c ee			ld (debug_mark+1),a  
331a 3a 24 33			ld a, (.dmark+2)  
331d 32 6d ee			ld (debug_mark+2),a  
3320 18 03			jr .pastdmark  
3322 ..			.dmark: db "-L<"  
3325 f1			.pastdmark: pop af  
3326			endm  
# End of macro DMARK
3326					CALLMONITOR 
3326 cd 6f ee			call debug_vector  
3329				endm  
# End of macro CALLMONITOR
3329				endif 
3329 c3 a5 1f			jp exec1 
332c			 
332c					 
332c			 
332c			 
332c			 
332c				NEXTW 
332c c3 14 1f			jp macro_next 
332f				endm 
# End of macro NEXTW
332f			 
332f			 
332f			 
332f			 
332f			.REPEAT: 
332f				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
332f 71				db WORD_SYS_CORE+93             
3330 82 33			dw .UNTIL            
3332 06				db 5 + 1 
3333 .. 00			db "REPEAT",0              
333a				endm 
# End of macro CWHEAD
333a			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
333a			;  push pc to rsp stack past the REPEAT 
333a					if DEBUG_FORTH_WORDS_KEY 
333a						DMARK "REP" 
333a f5				push af  
333b 3a 4f 33			ld a, (.dmark)  
333e 32 6b ee			ld (debug_mark),a  
3341 3a 50 33			ld a, (.dmark+1)  
3344 32 6c ee			ld (debug_mark+1),a  
3347 3a 51 33			ld a, (.dmark+2)  
334a 32 6d ee			ld (debug_mark+2),a  
334d 18 03			jr .pastdmark  
334f ..			.dmark: db "REP"  
3352 f1			.pastdmark: pop af  
3353			endm  
# End of macro DMARK
3353						CALLMONITOR 
3353 cd 6f ee			call debug_vector  
3356				endm  
# End of macro CALLMONITOR
3356					endif 
3356			 
3356 2a c2 e5				ld hl, (os_tok_ptr) 
3359 23					inc hl   ; R 
335a 23					inc hl  ; E 
335b 23					inc hl   ; P 
335c 23					inc hl   ; E 
335d 23					inc hl   ; A 
335e 23					inc hl   ; T 
335f 23					inc hl   ; zero 
3360					FORTH_RSP_NEXT 
3360 cd 0e 1b			call macro_forth_rsp_next 
3363				endm 
# End of macro FORTH_RSP_NEXT
3363			 
3363			 
3363					if DEBUG_FORTH_WORDS 
3363						DMARK "REP" 
3363 f5				push af  
3364 3a 78 33			ld a, (.dmark)  
3367 32 6b ee			ld (debug_mark),a  
336a 3a 79 33			ld a, (.dmark+1)  
336d 32 6c ee			ld (debug_mark+1),a  
3370 3a 7a 33			ld a, (.dmark+2)  
3373 32 6d ee			ld (debug_mark+2),a  
3376 18 03			jr .pastdmark  
3378 ..			.dmark: db "REP"  
337b f1			.pastdmark: pop af  
337c			endm  
# End of macro DMARK
337c						;pop bc    ; TODO BUG ?????? what is this for???? 
337c						CALLMONITOR 
337c cd 6f ee			call debug_vector  
337f				endm  
# End of macro CALLMONITOR
337f					endif 
337f			 
337f					NEXTW 
337f c3 14 1f			jp macro_next 
3382				endm 
# End of macro NEXTW
3382			;	       NEXTW 
3382			 
3382			.UNTIL: 
3382				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3382 72				db WORD_SYS_CORE+94             
3383 19 34			dw .ENDFLOW            
3385 06				db 5 + 1 
3386 .. 00			db "UNTIL",0              
338c				endm 
# End of macro CWHEAD
338c			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
338c			 
338c				; pop tos as check 
338c			 
338c				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
338c			 
338c				FORTH_DSP_VALUEHL 
338c cd 5e 1d			call macro_dsp_valuehl 
338f				endm 
# End of macro FORTH_DSP_VALUEHL
338f			 
338f					if DEBUG_FORTH_WORDS_KEY 
338f						DMARK "UNT" 
338f f5				push af  
3390 3a a4 33			ld a, (.dmark)  
3393 32 6b ee			ld (debug_mark),a  
3396 3a a5 33			ld a, (.dmark+1)  
3399 32 6c ee			ld (debug_mark+1),a  
339c 3a a6 33			ld a, (.dmark+2)  
339f 32 6d ee			ld (debug_mark+2),a  
33a2 18 03			jr .pastdmark  
33a4 ..			.dmark: db "UNT"  
33a7 f1			.pastdmark: pop af  
33a8			endm  
# End of macro DMARK
33a8						CALLMONITOR 
33a8 cd 6f ee			call debug_vector  
33ab				endm  
# End of macro CALLMONITOR
33ab					endif 
33ab			 
33ab			;	push hl 
33ab				FORTH_DSP_POP 
33ab cd 16 1e			call macro_forth_dsp_pop 
33ae				endm 
# End of macro FORTH_DSP_POP
33ae			 
33ae			;	pop hl 
33ae			 
33ae				; test if true 
33ae			 
33ae cd 0f 0e			call ishlzero 
33b1			;	ld a,l 
33b1			;	add h 
33b1			; 
33b1			;	cp 0 
33b1			 
33b1 20 3e			jr nz, .untilnotdone 
33b3			 
33b3					if DEBUG_FORTH_WORDS 
33b3						DMARK "UNf" 
33b3 f5				push af  
33b4 3a c8 33			ld a, (.dmark)  
33b7 32 6b ee			ld (debug_mark),a  
33ba 3a c9 33			ld a, (.dmark+1)  
33bd 32 6c ee			ld (debug_mark+1),a  
33c0 3a ca 33			ld a, (.dmark+2)  
33c3 32 6d ee			ld (debug_mark+2),a  
33c6 18 03			jr .pastdmark  
33c8 ..			.dmark: db "UNf"  
33cb f1			.pastdmark: pop af  
33cc			endm  
# End of macro DMARK
33cc						CALLMONITOR 
33cc cd 6f ee			call debug_vector  
33cf				endm  
# End of macro CALLMONITOR
33cf					endif 
33cf			 
33cf			 
33cf			 
33cf				FORTH_RSP_POP     ; get rid of DO ptr 
33cf cd 2f 1b			call macro_forth_rsp_pop 
33d2				endm 
# End of macro FORTH_RSP_POP
33d2			 
33d2			if DEBUG_FORTH_WORDS 
33d2						DMARK "UN>" 
33d2 f5				push af  
33d3 3a e7 33			ld a, (.dmark)  
33d6 32 6b ee			ld (debug_mark),a  
33d9 3a e8 33			ld a, (.dmark+1)  
33dc 32 6c ee			ld (debug_mark+1),a  
33df 3a e9 33			ld a, (.dmark+2)  
33e2 32 6d ee			ld (debug_mark+2),a  
33e5 18 03			jr .pastdmark  
33e7 ..			.dmark: db "UN>"  
33ea f1			.pastdmark: pop af  
33eb			endm  
# End of macro DMARK
33eb				CALLMONITOR 
33eb cd 6f ee			call debug_vector  
33ee				endm  
# End of macro CALLMONITOR
33ee			endif 
33ee			 
33ee					NEXTW 
33ee c3 14 1f			jp macro_next 
33f1				endm 
# End of macro NEXTW
33f1				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
33f1			 
33f1			.untilnotdone: 
33f1			 
33f1			 
33f1			;	; get DO ptr 
33f1			; 
33f1				FORTH_RSP_TOS 
33f1 cd 25 1b			call macro_forth_rsp_tos 
33f4				endm 
# End of macro FORTH_RSP_TOS
33f4			 
33f4				;push hl 
33f4			 
33f4				; not going to DO any more 
33f4				; get rid of the RSP pointer as DO will add it back in 
33f4				;FORTH_RSP_POP 
33f4				;pop hl 
33f4			 
33f4			 
33f4 22 c2 e5			ld (os_tok_ptr), hl 
33f7					if DEBUG_FORTH_WORDS 
33f7						DMARK "UN<" 
33f7 f5				push af  
33f8 3a 0c 34			ld a, (.dmark)  
33fb 32 6b ee			ld (debug_mark),a  
33fe 3a 0d 34			ld a, (.dmark+1)  
3401 32 6c ee			ld (debug_mark+1),a  
3404 3a 0e 34			ld a, (.dmark+2)  
3407 32 6d ee			ld (debug_mark+2),a  
340a 18 03			jr .pastdmark  
340c ..			.dmark: db "UN<"  
340f f1			.pastdmark: pop af  
3410			endm  
# End of macro DMARK
3410					CALLMONITOR 
3410 cd 6f ee			call debug_vector  
3413				endm  
# End of macro CALLMONITOR
3413				endif 
3413 c3 a5 1f			jp exec1 
3416			 
3416					 
3416			 
3416			 
3416					NEXTW 
3416 c3 14 1f			jp macro_next 
3419				endm 
# End of macro NEXTW
3419			 
3419			 
3419			.ENDFLOW: 
3419			 
3419			; eof 
3419			 
# End of file forth_words_flow.asm
3419			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3419			include "forth_words_logic.asm" 
3419			 
3419			; | ## Logic Words 
3419			 
3419			.NOT: 
3419				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3419 2d				db WORD_SYS_CORE+25             
341a 61 34			dw .IS            
341c 04				db 3 + 1 
341d .. 00			db "NOT",0              
3421				endm 
# End of macro CWHEAD
3421			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3421					if DEBUG_FORTH_WORDS_KEY 
3421						DMARK "NOT" 
3421 f5				push af  
3422 3a 36 34			ld a, (.dmark)  
3425 32 6b ee			ld (debug_mark),a  
3428 3a 37 34			ld a, (.dmark+1)  
342b 32 6c ee			ld (debug_mark+1),a  
342e 3a 38 34			ld a, (.dmark+2)  
3431 32 6d ee			ld (debug_mark+2),a  
3434 18 03			jr .pastdmark  
3436 ..			.dmark: db "NOT"  
3439 f1			.pastdmark: pop af  
343a			endm  
# End of macro DMARK
343a						CALLMONITOR 
343a cd 6f ee			call debug_vector  
343d				endm  
# End of macro CALLMONITOR
343d					endif 
343d					FORTH_DSP 
343d cd 24 1d			call macro_forth_dsp 
3440				endm 
# End of macro FORTH_DSP
3440 7e					ld a,(hl)	; get type of value on TOS 
3441 fe 02				cp DS_TYPE_INUM  
3443 28 03				jr z, .noti 
3445					NEXTW 
3445 c3 14 1f			jp macro_next 
3448				endm 
# End of macro NEXTW
3448			.noti:          FORTH_DSP_VALUEHL 
3448 cd 5e 1d			call macro_dsp_valuehl 
344b				endm 
# End of macro FORTH_DSP_VALUEHL
344b			;		push hl 
344b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
344b cd 16 1e			call macro_forth_dsp_pop 
344e				endm 
# End of macro FORTH_DSP_POP
344e			;		pop hl 
344e 3e 00				ld a,0 
3450 bd					cp l 
3451 28 04				jr z, .not2t 
3453 2e 00				ld l, 0 
3455 18 02				jr .notip 
3457			 
3457 2e ff		.not2t:		ld l, 255 
3459			 
3459 26 00		.notip:		ld h, 0	 
345b			 
345b cd 67 1b				call forth_push_numhl 
345e					NEXTW 
345e c3 14 1f			jp macro_next 
3461				endm 
# End of macro NEXTW
3461			 
3461			.IS: 
3461				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3461 2d				db WORD_SYS_CORE+25             
3462 87 34			dw .LZERO            
3464 03				db 2 + 1 
3465 .. 00			db "IS",0              
3468				endm 
# End of macro CWHEAD
3468			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3468					if DEBUG_FORTH_WORDS_KEY 
3468						DMARK "IS." 
3468 f5				push af  
3469 3a 7d 34			ld a, (.dmark)  
346c 32 6b ee			ld (debug_mark),a  
346f 3a 7e 34			ld a, (.dmark+1)  
3472 32 6c ee			ld (debug_mark+1),a  
3475 3a 7f 34			ld a, (.dmark+2)  
3478 32 6d ee			ld (debug_mark+2),a  
347b 18 03			jr .pastdmark  
347d ..			.dmark: db "IS."  
3480 f1			.pastdmark: pop af  
3481			endm  
# End of macro DMARK
3481						CALLMONITOR 
3481 cd 6f ee			call debug_vector  
3484				endm  
# End of macro CALLMONITOR
3484					endif 
3484					NEXTW 
3484 c3 14 1f			jp macro_next 
3487				endm 
# End of macro NEXTW
3487			.LZERO: 
3487				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3487 2d				db WORD_SYS_CORE+25             
3488 91 34			dw .TZERO            
348a 03				db 2 + 1 
348b .. 00			db "0<",0              
348e				endm 
# End of macro CWHEAD
348e			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
348e					NEXTW 
348e c3 14 1f			jp macro_next 
3491				endm 
# End of macro NEXTW
3491			.TZERO: 
3491				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3491 2e				db WORD_SYS_CORE+26             
3492 d8 34			dw .LESS            
3494 03				db 2 + 1 
3495 .. 00			db "0=",0              
3498				endm 
# End of macro CWHEAD
3498			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3498				; TODO add floating point number detection 
3498					;v5 FORTH_DSP_VALUE 
3498					if DEBUG_FORTH_WORDS_KEY 
3498						DMARK "0=." 
3498 f5				push af  
3499 3a ad 34			ld a, (.dmark)  
349c 32 6b ee			ld (debug_mark),a  
349f 3a ae 34			ld a, (.dmark+1)  
34a2 32 6c ee			ld (debug_mark+1),a  
34a5 3a af 34			ld a, (.dmark+2)  
34a8 32 6d ee			ld (debug_mark+2),a  
34ab 18 03			jr .pastdmark  
34ad ..			.dmark: db "0=."  
34b0 f1			.pastdmark: pop af  
34b1			endm  
# End of macro DMARK
34b1						CALLMONITOR 
34b1 cd 6f ee			call debug_vector  
34b4				endm  
# End of macro CALLMONITOR
34b4					endif 
34b4					FORTH_DSP 
34b4 cd 24 1d			call macro_forth_dsp 
34b7				endm 
# End of macro FORTH_DSP
34b7 7e					ld a,(hl)	; get type of value on TOS 
34b8 fe 02				cp DS_TYPE_INUM  
34ba 28 00				jr z, .tz_inum 
34bc			 
34bc				if FORTH_ENABLE_FLOATMATH 
34bc					jr .tz_done 
34bc			 
34bc				endif 
34bc					 
34bc			 
34bc			.tz_inum: 
34bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34bc cd 5e 1d			call macro_dsp_valuehl 
34bf				endm 
# End of macro FORTH_DSP_VALUEHL
34bf			 
34bf			;		push hl 
34bf			 
34bf					; destroy value TOS 
34bf			 
34bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34bf cd 16 1e			call macro_forth_dsp_pop 
34c2				endm 
# End of macro FORTH_DSP_POP
34c2			 
34c2			;		pop hl 
34c2			 
34c2 3e 00				ld a,0 
34c4			 
34c4 bd					cp l 
34c5 20 08				jr nz, .tz_notzero 
34c7			 
34c7 bc					cp h 
34c8			 
34c8 20 05				jr nz, .tz_notzero 
34ca			 
34ca			 
34ca 21 01 00				ld hl, FORTH_TRUE 
34cd 18 03				jr .tz_done 
34cf			 
34cf 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
34d2			 
34d2					; push value back onto stack for another op etc 
34d2			 
34d2			.tz_done: 
34d2 cd 67 1b				call forth_push_numhl 
34d5			 
34d5					NEXTW 
34d5 c3 14 1f			jp macro_next 
34d8				endm 
# End of macro NEXTW
34d8			.LESS: 
34d8				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
34d8 2f				db WORD_SYS_CORE+27             
34d9 41 35			dw .GT            
34db 02				db 1 + 1 
34dc .. 00			db "<",0              
34de				endm 
# End of macro CWHEAD
34de			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
34de				; TODO add floating point number detection 
34de					if DEBUG_FORTH_WORDS_KEY 
34de						DMARK "LES" 
34de f5				push af  
34df 3a f3 34			ld a, (.dmark)  
34e2 32 6b ee			ld (debug_mark),a  
34e5 3a f4 34			ld a, (.dmark+1)  
34e8 32 6c ee			ld (debug_mark+1),a  
34eb 3a f5 34			ld a, (.dmark+2)  
34ee 32 6d ee			ld (debug_mark+2),a  
34f1 18 03			jr .pastdmark  
34f3 ..			.dmark: db "LES"  
34f6 f1			.pastdmark: pop af  
34f7			endm  
# End of macro DMARK
34f7						CALLMONITOR 
34f7 cd 6f ee			call debug_vector  
34fa				endm  
# End of macro CALLMONITOR
34fa					endif 
34fa					FORTH_DSP 
34fa cd 24 1d			call macro_forth_dsp 
34fd				endm 
# End of macro FORTH_DSP
34fd					;v5 FORTH_DSP_VALUE 
34fd 7e					ld a,(hl)	; get type of value on TOS 
34fe fe 02				cp DS_TYPE_INUM  
3500 28 00				jr z, .less_inum 
3502			 
3502				if FORTH_ENABLE_FLOATMATH 
3502					jr .less_done 
3502			 
3502				endif 
3502					 
3502			 
3502			.less_inum: 
3502					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3502 cd 5e 1d			call macro_dsp_valuehl 
3505				endm 
# End of macro FORTH_DSP_VALUEHL
3505			 
3505 e5					push hl  ; u2 
3506			 
3506					; destroy value TOS 
3506			 
3506					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3506 cd 16 1e			call macro_forth_dsp_pop 
3509				endm 
# End of macro FORTH_DSP_POP
3509			 
3509			 
3509					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3509 cd 5e 1d			call macro_dsp_valuehl 
350c				endm 
# End of macro FORTH_DSP_VALUEHL
350c			 
350c e5					push hl    ; u1 
350d			 
350d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
350d cd 16 1e			call macro_forth_dsp_pop 
3510				endm 
# End of macro FORTH_DSP_POP
3510			 
3510			 
3510 b7			 or a      ;clear carry flag 
3511 01 00 00		 ld bc, FORTH_FALSE 
3514 e1			  pop hl    ; u1 
3515 d1			  pop de    ; u2 
3516 ed 52		  sbc hl,de 
3518 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
351a			 
351a 01 01 00		 ld bc, FORTH_TRUE 
351d			.lscont:  
351d c5					push bc 
351e e1					pop hl 
351f			 
351f					if DEBUG_FORTH_WORDS 
351f						DMARK "LT1" 
351f f5				push af  
3520 3a 34 35			ld a, (.dmark)  
3523 32 6b ee			ld (debug_mark),a  
3526 3a 35 35			ld a, (.dmark+1)  
3529 32 6c ee			ld (debug_mark+1),a  
352c 3a 36 35			ld a, (.dmark+2)  
352f 32 6d ee			ld (debug_mark+2),a  
3532 18 03			jr .pastdmark  
3534 ..			.dmark: db "LT1"  
3537 f1			.pastdmark: pop af  
3538			endm  
# End of macro DMARK
3538						CALLMONITOR 
3538 cd 6f ee			call debug_vector  
353b				endm  
# End of macro CALLMONITOR
353b					endif 
353b cd 67 1b				call forth_push_numhl 
353e			 
353e					NEXTW 
353e c3 14 1f			jp macro_next 
3541				endm 
# End of macro NEXTW
3541			.GT: 
3541				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3541 30				db WORD_SYS_CORE+28             
3542 aa 35			dw .EQUAL            
3544 02				db 1 + 1 
3545 .. 00			db ">",0              
3547				endm 
# End of macro CWHEAD
3547			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3547				; TODO add floating point number detection 
3547					if DEBUG_FORTH_WORDS_KEY 
3547						DMARK "GRT" 
3547 f5				push af  
3548 3a 5c 35			ld a, (.dmark)  
354b 32 6b ee			ld (debug_mark),a  
354e 3a 5d 35			ld a, (.dmark+1)  
3551 32 6c ee			ld (debug_mark+1),a  
3554 3a 5e 35			ld a, (.dmark+2)  
3557 32 6d ee			ld (debug_mark+2),a  
355a 18 03			jr .pastdmark  
355c ..			.dmark: db "GRT"  
355f f1			.pastdmark: pop af  
3560			endm  
# End of macro DMARK
3560						CALLMONITOR 
3560 cd 6f ee			call debug_vector  
3563				endm  
# End of macro CALLMONITOR
3563					endif 
3563					FORTH_DSP 
3563 cd 24 1d			call macro_forth_dsp 
3566				endm 
# End of macro FORTH_DSP
3566					;FORTH_DSP_VALUE 
3566 7e					ld a,(hl)	; get type of value on TOS 
3567 fe 02				cp DS_TYPE_INUM  
3569 28 00				jr z, .gt_inum 
356b			 
356b				if FORTH_ENABLE_FLOATMATH 
356b					jr .gt_done 
356b			 
356b				endif 
356b					 
356b			 
356b			.gt_inum: 
356b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
356b cd 5e 1d			call macro_dsp_valuehl 
356e				endm 
# End of macro FORTH_DSP_VALUEHL
356e			 
356e e5					push hl  ; u2 
356f			 
356f					; destroy value TOS 
356f			 
356f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
356f cd 16 1e			call macro_forth_dsp_pop 
3572				endm 
# End of macro FORTH_DSP_POP
3572			 
3572			 
3572					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3572 cd 5e 1d			call macro_dsp_valuehl 
3575				endm 
# End of macro FORTH_DSP_VALUEHL
3575			 
3575 e5					push hl    ; u1 
3576			 
3576					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3576 cd 16 1e			call macro_forth_dsp_pop 
3579				endm 
# End of macro FORTH_DSP_POP
3579			 
3579			 
3579 b7			 or a      ;clear carry flag 
357a 01 00 00		 ld bc, FORTH_FALSE 
357d e1			  pop hl    ; u1 
357e d1			  pop de    ; u2 
357f ed 52		  sbc hl,de 
3581 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3583			 
3583 01 01 00		 ld bc, FORTH_TRUE 
3586			.gtcont:  
3586 c5					push bc 
3587 e1					pop hl 
3588			 
3588					if DEBUG_FORTH_WORDS 
3588						DMARK "GT1" 
3588 f5				push af  
3589 3a 9d 35			ld a, (.dmark)  
358c 32 6b ee			ld (debug_mark),a  
358f 3a 9e 35			ld a, (.dmark+1)  
3592 32 6c ee			ld (debug_mark+1),a  
3595 3a 9f 35			ld a, (.dmark+2)  
3598 32 6d ee			ld (debug_mark+2),a  
359b 18 03			jr .pastdmark  
359d ..			.dmark: db "GT1"  
35a0 f1			.pastdmark: pop af  
35a1			endm  
# End of macro DMARK
35a1						CALLMONITOR 
35a1 cd 6f ee			call debug_vector  
35a4				endm  
# End of macro CALLMONITOR
35a4					endif 
35a4 cd 67 1b				call forth_push_numhl 
35a7			 
35a7					NEXTW 
35a7 c3 14 1f			jp macro_next 
35aa				endm 
# End of macro NEXTW
35aa			.EQUAL: 
35aa				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
35aa 31				db WORD_SYS_CORE+29             
35ab 15 36			dw .ENDLOGIC            
35ad 02				db 1 + 1 
35ae .. 00			db "=",0              
35b0				endm 
# End of macro CWHEAD
35b0			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
35b0				; TODO add floating point number detection 
35b0					if DEBUG_FORTH_WORDS_KEY 
35b0						DMARK "EQ." 
35b0 f5				push af  
35b1 3a c5 35			ld a, (.dmark)  
35b4 32 6b ee			ld (debug_mark),a  
35b7 3a c6 35			ld a, (.dmark+1)  
35ba 32 6c ee			ld (debug_mark+1),a  
35bd 3a c7 35			ld a, (.dmark+2)  
35c0 32 6d ee			ld (debug_mark+2),a  
35c3 18 03			jr .pastdmark  
35c5 ..			.dmark: db "EQ."  
35c8 f1			.pastdmark: pop af  
35c9			endm  
# End of macro DMARK
35c9						CALLMONITOR 
35c9 cd 6f ee			call debug_vector  
35cc				endm  
# End of macro CALLMONITOR
35cc					endif 
35cc					FORTH_DSP 
35cc cd 24 1d			call macro_forth_dsp 
35cf				endm 
# End of macro FORTH_DSP
35cf					;v5 FORTH_DSP_VALUE 
35cf 7e					ld a,(hl)	; get type of value on TOS 
35d0 fe 02				cp DS_TYPE_INUM  
35d2 28 00				jr z, .eq_inum 
35d4			 
35d4				if FORTH_ENABLE_FLOATMATH 
35d4					jr .eq_done 
35d4			 
35d4				endif 
35d4					 
35d4			 
35d4			.eq_inum: 
35d4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35d4 cd 5e 1d			call macro_dsp_valuehl 
35d7				endm 
# End of macro FORTH_DSP_VALUEHL
35d7			 
35d7 e5					push hl 
35d8			 
35d8					; destroy value TOS 
35d8			 
35d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35d8 cd 16 1e			call macro_forth_dsp_pop 
35db				endm 
# End of macro FORTH_DSP_POP
35db			 
35db			 
35db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35db cd 5e 1d			call macro_dsp_valuehl 
35de				endm 
# End of macro FORTH_DSP_VALUEHL
35de			 
35de					; one value on hl get other one back 
35de			 
35de e5					push hl 
35df			 
35df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35df cd 16 1e			call macro_forth_dsp_pop 
35e2				endm 
# End of macro FORTH_DSP_POP
35e2			 
35e2 0e 00				ld c, FORTH_FALSE 
35e4			 
35e4 e1					pop hl 
35e5 d1					pop de 
35e6			 
35e6 7b					ld a, e 
35e7 bd					cp l 
35e8			 
35e8 20 06				jr nz, .eq_done 
35ea			 
35ea 7a					ld a, d 
35eb bc					cp h 
35ec			 
35ec 20 02				jr nz, .eq_done 
35ee			 
35ee 0e 01				ld c, FORTH_TRUE 
35f0					 
35f0			 
35f0			 
35f0			.eq_done: 
35f0			 
35f0					; TODO push value back onto stack for another op etc 
35f0			 
35f0 26 00				ld h, 0 
35f2 69					ld l, c 
35f3					if DEBUG_FORTH_WORDS 
35f3						DMARK "EQ1" 
35f3 f5				push af  
35f4 3a 08 36			ld a, (.dmark)  
35f7 32 6b ee			ld (debug_mark),a  
35fa 3a 09 36			ld a, (.dmark+1)  
35fd 32 6c ee			ld (debug_mark+1),a  
3600 3a 0a 36			ld a, (.dmark+2)  
3603 32 6d ee			ld (debug_mark+2),a  
3606 18 03			jr .pastdmark  
3608 ..			.dmark: db "EQ1"  
360b f1			.pastdmark: pop af  
360c			endm  
# End of macro DMARK
360c						CALLMONITOR 
360c cd 6f ee			call debug_vector  
360f				endm  
# End of macro CALLMONITOR
360f					endif 
360f cd 67 1b				call forth_push_numhl 
3612			 
3612					NEXTW 
3612 c3 14 1f			jp macro_next 
3615				endm 
# End of macro NEXTW
3615			 
3615			 
3615			.ENDLOGIC: 
3615			; eof 
3615			 
3615			 
# End of file forth_words_logic.asm
3615			include "forth_words_maths.asm" 
3615			 
3615			; | ## Maths Words 
3615			 
3615			.PLUS:	 
3615				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3615 15				db WORD_SYS_CORE+1             
3616 73 36			dw .NEG            
3618 02				db 1 + 1 
3619 .. 00			db "+",0              
361b				endm 
# End of macro CWHEAD
361b			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
361b					if DEBUG_FORTH_WORDS_KEY 
361b						DMARK "PLU" 
361b f5				push af  
361c 3a 30 36			ld a, (.dmark)  
361f 32 6b ee			ld (debug_mark),a  
3622 3a 31 36			ld a, (.dmark+1)  
3625 32 6c ee			ld (debug_mark+1),a  
3628 3a 32 36			ld a, (.dmark+2)  
362b 32 6d ee			ld (debug_mark+2),a  
362e 18 03			jr .pastdmark  
3630 ..			.dmark: db "PLU"  
3633 f1			.pastdmark: pop af  
3634			endm  
# End of macro DMARK
3634						CALLMONITOR 
3634 cd 6f ee			call debug_vector  
3637				endm  
# End of macro CALLMONITOR
3637					endif 
3637					; add top two values and push back result 
3637			 
3637					;for v5 FORTH_DSP_VALUE 
3637					FORTH_DSP 
3637 cd 24 1d			call macro_forth_dsp 
363a				endm 
# End of macro FORTH_DSP
363a 7e					ld a,(hl)	; get type of value on TOS 
363b fe 02				cp DS_TYPE_INUM  
363d 28 03				jr z, .dot_inum 
363f			 
363f					NEXTW 
363f c3 14 1f			jp macro_next 
3642				endm 
# End of macro NEXTW
3642			 
3642			; float maths 
3642			 
3642				if FORTH_ENABLE_FLOATMATH 
3642						inc hl      ; now at start of numeric as string 
3642			 
3642					if DEBUG_FORTH_MATHS 
3642						DMARK "ADD" 
3642				CALLMONITOR 
3642					endif 
3642			 
3642					;ld ix, hl 
3642					call CON 
3642			 
3642			 
3642					push hl 
3642					 
3642					 
3642			 
3642						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3642			 
3642					; get next number 
3642			 
3642						FORTH_DSP_VALUE 
3642			 
3642						inc hl      ; now at start of numeric as string 
3642			 
3642					;ld ix, hl 
3642					call CON 
3642			 
3642					push hl 
3642			 
3642			 
3642						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3642			 
3642						; TODO do add 
3642			 
3642						call IADD 
3642			 
3642						; TODO get result back as ascii 
3642			 
3642						; TODO push result  
3642			 
3642			 
3642			 
3642						jr .dot_done 
3642				endif 
3642			 
3642			.dot_inum: 
3642			 
3642			 
3642					if DEBUG_FORTH_DOT 
3642						DMARK "+IT" 
3642 f5				push af  
3643 3a 57 36			ld a, (.dmark)  
3646 32 6b ee			ld (debug_mark),a  
3649 3a 58 36			ld a, (.dmark+1)  
364c 32 6c ee			ld (debug_mark+1),a  
364f 3a 59 36			ld a, (.dmark+2)  
3652 32 6d ee			ld (debug_mark+2),a  
3655 18 03			jr .pastdmark  
3657 ..			.dmark: db "+IT"  
365a f1			.pastdmark: pop af  
365b			endm  
# End of macro DMARK
365b				CALLMONITOR 
365b cd 6f ee			call debug_vector  
365e				endm  
# End of macro CALLMONITOR
365e					endif 
365e			 
365e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
365e cd 5e 1d			call macro_dsp_valuehl 
3661				endm 
# End of macro FORTH_DSP_VALUEHL
3661			 
3661				; TODO add floating point number detection 
3661			 
3661 e5					push hl 
3662			 
3662					; destroy value TOS 
3662			 
3662					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3662 cd 16 1e			call macro_forth_dsp_pop 
3665				endm 
# End of macro FORTH_DSP_POP
3665			 
3665			 
3665					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3665 cd 5e 1d			call macro_dsp_valuehl 
3668				endm 
# End of macro FORTH_DSP_VALUEHL
3668			 
3668					; one value on hl get other one back 
3668			 
3668 d1					pop de 
3669			 
3669					; do the add 
3669			 
3669 19					add hl,de 
366a			 
366a					; save it 
366a			 
366a			;		push hl	 
366a			 
366a					; 
366a			 
366a					; destroy value TOS 
366a			 
366a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
366a cd 16 1e			call macro_forth_dsp_pop 
366d				endm 
# End of macro FORTH_DSP_POP
366d			 
366d					; TODO push value back onto stack for another op etc 
366d			 
366d			;		pop hl 
366d			 
366d			.dot_done: 
366d cd 67 1b				call forth_push_numhl 
3670			 
3670					NEXTW 
3670 c3 14 1f			jp macro_next 
3673				endm 
# End of macro NEXTW
3673			.NEG: 
3673			 
3673				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3673 17				db WORD_SYS_CORE+3             
3674 b6 36			dw .DIV            
3676 02				db 1 + 1 
3677 .. 00			db "-",0              
3679				endm 
# End of macro CWHEAD
3679			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3679					if DEBUG_FORTH_WORDS_KEY 
3679						DMARK "SUB" 
3679 f5				push af  
367a 3a 8e 36			ld a, (.dmark)  
367d 32 6b ee			ld (debug_mark),a  
3680 3a 8f 36			ld a, (.dmark+1)  
3683 32 6c ee			ld (debug_mark+1),a  
3686 3a 90 36			ld a, (.dmark+2)  
3689 32 6d ee			ld (debug_mark+2),a  
368c 18 03			jr .pastdmark  
368e ..			.dmark: db "SUB"  
3691 f1			.pastdmark: pop af  
3692			endm  
# End of macro DMARK
3692						CALLMONITOR 
3692 cd 6f ee			call debug_vector  
3695				endm  
# End of macro CALLMONITOR
3695					endif 
3695			 
3695			 
3695				; TODO add floating point number detection 
3695					; v5 FORTH_DSP_VALUE 
3695					FORTH_DSP 
3695 cd 24 1d			call macro_forth_dsp 
3698				endm 
# End of macro FORTH_DSP
3698 7e					ld a,(hl)	; get type of value on TOS 
3699 fe 02				cp DS_TYPE_INUM  
369b 28 03				jr z, .neg_inum 
369d			 
369d					NEXTW 
369d c3 14 1f			jp macro_next 
36a0				endm 
# End of macro NEXTW
36a0			 
36a0			; float maths 
36a0			 
36a0				if FORTH_ENABLE_FLOATMATH 
36a0					jr .neg_done 
36a0			 
36a0				endif 
36a0					 
36a0			 
36a0			.neg_inum: 
36a0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36a0 cd 5e 1d			call macro_dsp_valuehl 
36a3				endm 
# End of macro FORTH_DSP_VALUEHL
36a3			 
36a3 e5					push hl 
36a4			 
36a4					; destroy value TOS 
36a4			 
36a4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36a4 cd 16 1e			call macro_forth_dsp_pop 
36a7				endm 
# End of macro FORTH_DSP_POP
36a7			 
36a7			 
36a7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36a7 cd 5e 1d			call macro_dsp_valuehl 
36aa				endm 
# End of macro FORTH_DSP_VALUEHL
36aa			 
36aa					; one value on hl get other one back 
36aa			 
36aa d1					pop de 
36ab			 
36ab					; do the sub 
36ab			;		ex de, hl 
36ab			 
36ab ed 52				sbc hl,de 
36ad			 
36ad					; save it 
36ad			 
36ad			;		push hl	 
36ad			 
36ad					; 
36ad			 
36ad					; destroy value TOS 
36ad			 
36ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ad cd 16 1e			call macro_forth_dsp_pop 
36b0				endm 
# End of macro FORTH_DSP_POP
36b0			 
36b0					; TODO push value back onto stack for another op etc 
36b0			 
36b0			;		pop hl 
36b0			 
36b0 cd 67 1b				call forth_push_numhl 
36b3			.neg_done: 
36b3			 
36b3					NEXTW 
36b3 c3 14 1f			jp macro_next 
36b6				endm 
# End of macro NEXTW
36b6			.DIV: 
36b6				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
36b6 18				db WORD_SYS_CORE+4             
36b7 03 37			dw .MUL            
36b9 02				db 1 + 1 
36ba .. 00			db "/",0              
36bc				endm 
# End of macro CWHEAD
36bc			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
36bc					if DEBUG_FORTH_WORDS_KEY 
36bc						DMARK "DIV" 
36bc f5				push af  
36bd 3a d1 36			ld a, (.dmark)  
36c0 32 6b ee			ld (debug_mark),a  
36c3 3a d2 36			ld a, (.dmark+1)  
36c6 32 6c ee			ld (debug_mark+1),a  
36c9 3a d3 36			ld a, (.dmark+2)  
36cc 32 6d ee			ld (debug_mark+2),a  
36cf 18 03			jr .pastdmark  
36d1 ..			.dmark: db "DIV"  
36d4 f1			.pastdmark: pop af  
36d5			endm  
# End of macro DMARK
36d5						CALLMONITOR 
36d5 cd 6f ee			call debug_vector  
36d8				endm  
# End of macro CALLMONITOR
36d8					endif 
36d8				; TODO add floating point number detection 
36d8					; v5 FORTH_DSP_VALUE 
36d8					FORTH_DSP 
36d8 cd 24 1d			call macro_forth_dsp 
36db				endm 
# End of macro FORTH_DSP
36db 7e					ld a,(hl)	; get type of value on TOS 
36dc fe 02				cp DS_TYPE_INUM  
36de 28 03				jr z, .div_inum 
36e0			 
36e0				if FORTH_ENABLE_FLOATMATH 
36e0					jr .div_done 
36e0			 
36e0				endif 
36e0					NEXTW 
36e0 c3 14 1f			jp macro_next 
36e3				endm 
# End of macro NEXTW
36e3			.div_inum: 
36e3			 
36e3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36e3 cd 5e 1d			call macro_dsp_valuehl 
36e6				endm 
# End of macro FORTH_DSP_VALUEHL
36e6			 
36e6 e5					push hl    ; to go to bc 
36e7			 
36e7					; destroy value TOS 
36e7			 
36e7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36e7 cd 16 1e			call macro_forth_dsp_pop 
36ea				endm 
# End of macro FORTH_DSP_POP
36ea			 
36ea			 
36ea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36ea cd 5e 1d			call macro_dsp_valuehl 
36ed				endm 
# End of macro FORTH_DSP_VALUEHL
36ed			 
36ed					; hl to go to de 
36ed			 
36ed e5					push hl 
36ee			 
36ee c1					pop bc 
36ef d1					pop de		 
36f0			 
36f0			 
36f0					if DEBUG_FORTH_MATHS 
36f0						DMARK "DIV" 
36f0				CALLMONITOR 
36f0					endif 
36f0					; one value on hl but move to a get other one back 
36f0			 
36f0			        
36f0 cd 43 0d			call Div16 
36f3			 
36f3			;	push af	 
36f3 e5				push hl 
36f4 c5				push bc 
36f5			 
36f5					if DEBUG_FORTH_MATHS 
36f5						DMARK "DI1" 
36f5				CALLMONITOR 
36f5					endif 
36f5			 
36f5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36f5 cd 16 1e			call macro_forth_dsp_pop 
36f8				endm 
# End of macro FORTH_DSP_POP
36f8			 
36f8			 
36f8			 
36f8 e1					pop hl    ; result 
36f9			 
36f9 cd 67 1b				call forth_push_numhl 
36fc			 
36fc e1					pop hl    ; reminder 
36fd			;		ld h,0 
36fd			;		ld l,d 
36fd			 
36fd cd 67 1b				call forth_push_numhl 
3700			.div_done: 
3700					NEXTW 
3700 c3 14 1f			jp macro_next 
3703				endm 
# End of macro NEXTW
3703			.MUL: 
3703				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3703 19				db WORD_SYS_CORE+5             
3704 48 37			dw .MIN            
3706 02				db 1 + 1 
3707 .. 00			db "*",0              
3709				endm 
# End of macro CWHEAD
3709			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3709				; TODO add floating point number detection 
3709					if DEBUG_FORTH_WORDS_KEY 
3709						DMARK "MUL" 
3709 f5				push af  
370a 3a 1e 37			ld a, (.dmark)  
370d 32 6b ee			ld (debug_mark),a  
3710 3a 1f 37			ld a, (.dmark+1)  
3713 32 6c ee			ld (debug_mark+1),a  
3716 3a 20 37			ld a, (.dmark+2)  
3719 32 6d ee			ld (debug_mark+2),a  
371c 18 03			jr .pastdmark  
371e ..			.dmark: db "MUL"  
3721 f1			.pastdmark: pop af  
3722			endm  
# End of macro DMARK
3722						CALLMONITOR 
3722 cd 6f ee			call debug_vector  
3725				endm  
# End of macro CALLMONITOR
3725					endif 
3725					FORTH_DSP 
3725 cd 24 1d			call macro_forth_dsp 
3728				endm 
# End of macro FORTH_DSP
3728					; v5 FORTH_DSP_VALUE 
3728 7e					ld a,(hl)	; get type of value on TOS 
3729 fe 02				cp DS_TYPE_INUM  
372b 28 03				jr z, .mul_inum 
372d			 
372d				if FORTH_ENABLE_FLOATMATH 
372d					jr .mul_done 
372d			 
372d				endif 
372d			 
372d					NEXTW 
372d c3 14 1f			jp macro_next 
3730				endm 
# End of macro NEXTW
3730			.mul_inum:	 
3730			 
3730					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3730 cd 5e 1d			call macro_dsp_valuehl 
3733				endm 
# End of macro FORTH_DSP_VALUEHL
3733			 
3733 e5					push hl 
3734			 
3734					; destroy value TOS 
3734			 
3734					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3734 cd 16 1e			call macro_forth_dsp_pop 
3737				endm 
# End of macro FORTH_DSP_POP
3737			 
3737			 
3737					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3737 cd 5e 1d			call macro_dsp_valuehl 
373a				endm 
# End of macro FORTH_DSP_VALUEHL
373a			 
373a					; one value on hl but move to a get other one back 
373a			 
373a 7d					ld a, l 
373b			 
373b d1					pop de 
373c			 
373c					; do the mull 
373c			;		ex de, hl 
373c			 
373c cd 69 0d				call Mult16 
373f					; save it 
373f			 
373f			;		push hl	 
373f			 
373f					; 
373f			 
373f					; destroy value TOS 
373f			 
373f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
373f cd 16 1e			call macro_forth_dsp_pop 
3742				endm 
# End of macro FORTH_DSP_POP
3742			 
3742					; TODO push value back onto stack for another op etc 
3742			 
3742			;		pop hl 
3742			 
3742 cd 67 1b				call forth_push_numhl 
3745			 
3745			.mul_done: 
3745					NEXTW 
3745 c3 14 1f			jp macro_next 
3748				endm 
# End of macro NEXTW
3748			 
3748			 
3748			 
3748			 
3748			.MIN: 
3748				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3748 49				db WORD_SYS_CORE+53             
3749 c9 37			dw .MAX            
374b 04				db 3 + 1 
374c .. 00			db "MIN",0              
3750				endm 
# End of macro CWHEAD
3750			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3750					if DEBUG_FORTH_WORDS_KEY 
3750						DMARK "MIN" 
3750 f5				push af  
3751 3a 65 37			ld a, (.dmark)  
3754 32 6b ee			ld (debug_mark),a  
3757 3a 66 37			ld a, (.dmark+1)  
375a 32 6c ee			ld (debug_mark+1),a  
375d 3a 67 37			ld a, (.dmark+2)  
3760 32 6d ee			ld (debug_mark+2),a  
3763 18 03			jr .pastdmark  
3765 ..			.dmark: db "MIN"  
3768 f1			.pastdmark: pop af  
3769			endm  
# End of macro DMARK
3769						CALLMONITOR 
3769 cd 6f ee			call debug_vector  
376c				endm  
# End of macro CALLMONITOR
376c					endif 
376c					; get u2 
376c			 
376c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
376c cd 5e 1d			call macro_dsp_valuehl 
376f				endm 
# End of macro FORTH_DSP_VALUEHL
376f			 
376f e5					push hl   ; u2 
3770			 
3770					; destroy value TOS 
3770			 
3770					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3770 cd 16 1e			call macro_forth_dsp_pop 
3773				endm 
# End of macro FORTH_DSP_POP
3773			 
3773					; get u1 
3773			 
3773					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3773 cd 5e 1d			call macro_dsp_valuehl 
3776				endm 
# End of macro FORTH_DSP_VALUEHL
3776			 
3776 e5					push hl  ; u1 
3777			 
3777					; destroy value TOS 
3777			 
3777					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3777 cd 16 1e			call macro_forth_dsp_pop 
377a				endm 
# End of macro FORTH_DSP_POP
377a			 
377a b7			 or a      ;clear carry flag 
377b e1			  pop hl    ; u1 
377c d1			  pop de    ; u2 
377d e5				push hl   ; saved in case hl is lowest 
377e ed 52		  sbc hl,de 
3780 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3782			 
3782 e1				pop hl 
3783					if DEBUG_FORTH_WORDS 
3783						DMARK "MIN" 
3783 f5				push af  
3784 3a 98 37			ld a, (.dmark)  
3787 32 6b ee			ld (debug_mark),a  
378a 3a 99 37			ld a, (.dmark+1)  
378d 32 6c ee			ld (debug_mark+1),a  
3790 3a 9a 37			ld a, (.dmark+2)  
3793 32 6d ee			ld (debug_mark+2),a  
3796 18 03			jr .pastdmark  
3798 ..			.dmark: db "MIN"  
379b f1			.pastdmark: pop af  
379c			endm  
# End of macro DMARK
379c						CALLMONITOR 
379c cd 6f ee			call debug_vector  
379f				endm  
# End of macro CALLMONITOR
379f					endif 
379f cd 67 1b				call forth_push_numhl 
37a2			 
37a2				       NEXTW 
37a2 c3 14 1f			jp macro_next 
37a5				endm 
# End of macro NEXTW
37a5			 
37a5			.mincont:  
37a5 c1				pop bc   ; tidy up 
37a6 eb				ex de , hl  
37a7					if DEBUG_FORTH_WORDS 
37a7						DMARK "MI1" 
37a7 f5				push af  
37a8 3a bc 37			ld a, (.dmark)  
37ab 32 6b ee			ld (debug_mark),a  
37ae 3a bd 37			ld a, (.dmark+1)  
37b1 32 6c ee			ld (debug_mark+1),a  
37b4 3a be 37			ld a, (.dmark+2)  
37b7 32 6d ee			ld (debug_mark+2),a  
37ba 18 03			jr .pastdmark  
37bc ..			.dmark: db "MI1"  
37bf f1			.pastdmark: pop af  
37c0			endm  
# End of macro DMARK
37c0						CALLMONITOR 
37c0 cd 6f ee			call debug_vector  
37c3				endm  
# End of macro CALLMONITOR
37c3					endif 
37c3 cd 67 1b				call forth_push_numhl 
37c6			 
37c6				       NEXTW 
37c6 c3 14 1f			jp macro_next 
37c9				endm 
# End of macro NEXTW
37c9			.MAX: 
37c9				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
37c9 4a				db WORD_SYS_CORE+54             
37ca 4a 38			dw .RND16            
37cc 04				db 3 + 1 
37cd .. 00			db "MAX",0              
37d1				endm 
# End of macro CWHEAD
37d1			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
37d1					if DEBUG_FORTH_WORDS_KEY 
37d1						DMARK "MAX" 
37d1 f5				push af  
37d2 3a e6 37			ld a, (.dmark)  
37d5 32 6b ee			ld (debug_mark),a  
37d8 3a e7 37			ld a, (.dmark+1)  
37db 32 6c ee			ld (debug_mark+1),a  
37de 3a e8 37			ld a, (.dmark+2)  
37e1 32 6d ee			ld (debug_mark+2),a  
37e4 18 03			jr .pastdmark  
37e6 ..			.dmark: db "MAX"  
37e9 f1			.pastdmark: pop af  
37ea			endm  
# End of macro DMARK
37ea						CALLMONITOR 
37ea cd 6f ee			call debug_vector  
37ed				endm  
# End of macro CALLMONITOR
37ed					endif 
37ed					; get u2 
37ed			 
37ed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37ed cd 5e 1d			call macro_dsp_valuehl 
37f0				endm 
# End of macro FORTH_DSP_VALUEHL
37f0			 
37f0 e5					push hl   ; u2 
37f1			 
37f1					; destroy value TOS 
37f1			 
37f1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37f1 cd 16 1e			call macro_forth_dsp_pop 
37f4				endm 
# End of macro FORTH_DSP_POP
37f4			 
37f4					; get u1 
37f4			 
37f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37f4 cd 5e 1d			call macro_dsp_valuehl 
37f7				endm 
# End of macro FORTH_DSP_VALUEHL
37f7			 
37f7 e5					push hl  ; u1 
37f8			 
37f8					; destroy value TOS 
37f8			 
37f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37f8 cd 16 1e			call macro_forth_dsp_pop 
37fb				endm 
# End of macro FORTH_DSP_POP
37fb			 
37fb b7			 or a      ;clear carry flag 
37fc e1			  pop hl    ; u1 
37fd d1			  pop de    ; u2 
37fe e5				push hl   ; saved in case hl is lowest 
37ff ed 52		  sbc hl,de 
3801 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3803			 
3803 e1				pop hl 
3804					if DEBUG_FORTH_WORDS 
3804						DMARK "MAX" 
3804 f5				push af  
3805 3a 19 38			ld a, (.dmark)  
3808 32 6b ee			ld (debug_mark),a  
380b 3a 1a 38			ld a, (.dmark+1)  
380e 32 6c ee			ld (debug_mark+1),a  
3811 3a 1b 38			ld a, (.dmark+2)  
3814 32 6d ee			ld (debug_mark+2),a  
3817 18 03			jr .pastdmark  
3819 ..			.dmark: db "MAX"  
381c f1			.pastdmark: pop af  
381d			endm  
# End of macro DMARK
381d						CALLMONITOR 
381d cd 6f ee			call debug_vector  
3820				endm  
# End of macro CALLMONITOR
3820					endif 
3820 cd 67 1b				call forth_push_numhl 
3823			 
3823				       NEXTW 
3823 c3 14 1f			jp macro_next 
3826				endm 
# End of macro NEXTW
3826			 
3826			.maxcont:  
3826 c1				pop bc   ; tidy up 
3827 eb				ex de , hl  
3828					if DEBUG_FORTH_WORDS 
3828						DMARK "MA1" 
3828 f5				push af  
3829 3a 3d 38			ld a, (.dmark)  
382c 32 6b ee			ld (debug_mark),a  
382f 3a 3e 38			ld a, (.dmark+1)  
3832 32 6c ee			ld (debug_mark+1),a  
3835 3a 3f 38			ld a, (.dmark+2)  
3838 32 6d ee			ld (debug_mark+2),a  
383b 18 03			jr .pastdmark  
383d ..			.dmark: db "MA1"  
3840 f1			.pastdmark: pop af  
3841			endm  
# End of macro DMARK
3841						CALLMONITOR 
3841 cd 6f ee			call debug_vector  
3844				endm  
# End of macro CALLMONITOR
3844					endif 
3844 cd 67 1b				call forth_push_numhl 
3847				       NEXTW 
3847 c3 14 1f			jp macro_next 
384a				endm 
# End of macro NEXTW
384a			 
384a			.RND16: 
384a				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
384a 4e				db WORD_SYS_CORE+58             
384b 79 38			dw .RND8            
384d 06				db 5 + 1 
384e .. 00			db "RND16",0              
3854				endm 
# End of macro CWHEAD
3854			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3854					if DEBUG_FORTH_WORDS_KEY 
3854						DMARK "R16" 
3854 f5				push af  
3855 3a 69 38			ld a, (.dmark)  
3858 32 6b ee			ld (debug_mark),a  
385b 3a 6a 38			ld a, (.dmark+1)  
385e 32 6c ee			ld (debug_mark+1),a  
3861 3a 6b 38			ld a, (.dmark+2)  
3864 32 6d ee			ld (debug_mark+2),a  
3867 18 03			jr .pastdmark  
3869 ..			.dmark: db "R16"  
386c f1			.pastdmark: pop af  
386d			endm  
# End of macro DMARK
386d						CALLMONITOR 
386d cd 6f ee			call debug_vector  
3870				endm  
# End of macro CALLMONITOR
3870					endif 
3870 cd 0d 0d				call prng16  
3873 cd 67 1b				call forth_push_numhl 
3876				       NEXTW 
3876 c3 14 1f			jp macro_next 
3879				endm 
# End of macro NEXTW
3879			.RND8: 
3879				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3879 60				db WORD_SYS_CORE+76             
387a ae 38			dw .RND            
387c 05				db 4 + 1 
387d .. 00			db "RND8",0              
3882				endm 
# End of macro CWHEAD
3882			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3882					if DEBUG_FORTH_WORDS_KEY 
3882						DMARK "RN8" 
3882 f5				push af  
3883 3a 97 38			ld a, (.dmark)  
3886 32 6b ee			ld (debug_mark),a  
3889 3a 98 38			ld a, (.dmark+1)  
388c 32 6c ee			ld (debug_mark+1),a  
388f 3a 99 38			ld a, (.dmark+2)  
3892 32 6d ee			ld (debug_mark+2),a  
3895 18 03			jr .pastdmark  
3897 ..			.dmark: db "RN8"  
389a f1			.pastdmark: pop af  
389b			endm  
# End of macro DMARK
389b						CALLMONITOR 
389b cd 6f ee			call debug_vector  
389e				endm  
# End of macro CALLMONITOR
389e					endif 
389e 2a a9 eb				ld hl,(xrandc) 
38a1 23					inc hl 
38a2 cd 27 0d				call xrnd 
38a5 6f					ld l,a	 
38a6 26 00				ld h,0 
38a8 cd 67 1b				call forth_push_numhl 
38ab				       NEXTW 
38ab c3 14 1f			jp macro_next 
38ae				endm 
# End of macro NEXTW
38ae			.RND: 
38ae				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
38ae 60				db WORD_SYS_CORE+76             
38af b4 39			dw .ENDMATHS            
38b1 04				db 3 + 1 
38b2 .. 00			db "RND",0              
38b6				endm 
# End of macro CWHEAD
38b6			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
38b6			 
38b6					if DEBUG_FORTH_WORDS_KEY 
38b6						DMARK "RND" 
38b6 f5				push af  
38b7 3a cb 38			ld a, (.dmark)  
38ba 32 6b ee			ld (debug_mark),a  
38bd 3a cc 38			ld a, (.dmark+1)  
38c0 32 6c ee			ld (debug_mark+1),a  
38c3 3a cd 38			ld a, (.dmark+2)  
38c6 32 6d ee			ld (debug_mark+2),a  
38c9 18 03			jr .pastdmark  
38cb ..			.dmark: db "RND"  
38ce f1			.pastdmark: pop af  
38cf			endm  
# End of macro DMARK
38cf						CALLMONITOR 
38cf cd 6f ee			call debug_vector  
38d2				endm  
# End of macro CALLMONITOR
38d2					endif 
38d2					 
38d2					FORTH_DSP_VALUEHL    ; upper range 
38d2 cd 5e 1d			call macro_dsp_valuehl 
38d5				endm 
# End of macro FORTH_DSP_VALUEHL
38d5			 
38d5 22 ad eb				ld (LFSRSeed), hl	 
38d8			 
38d8					if DEBUG_FORTH_WORDS 
38d8						DMARK "RN1" 
38d8 f5				push af  
38d9 3a ed 38			ld a, (.dmark)  
38dc 32 6b ee			ld (debug_mark),a  
38df 3a ee 38			ld a, (.dmark+1)  
38e2 32 6c ee			ld (debug_mark+1),a  
38e5 3a ef 38			ld a, (.dmark+2)  
38e8 32 6d ee			ld (debug_mark+2),a  
38eb 18 03			jr .pastdmark  
38ed ..			.dmark: db "RN1"  
38f0 f1			.pastdmark: pop af  
38f1			endm  
# End of macro DMARK
38f1						CALLMONITOR 
38f1 cd 6f ee			call debug_vector  
38f4				endm  
# End of macro CALLMONITOR
38f4					endif 
38f4					FORTH_DSP_POP 
38f4 cd 16 1e			call macro_forth_dsp_pop 
38f7				endm 
# End of macro FORTH_DSP_POP
38f7			 
38f7					FORTH_DSP_VALUEHL    ; low range 
38f7 cd 5e 1d			call macro_dsp_valuehl 
38fa				endm 
# End of macro FORTH_DSP_VALUEHL
38fa			 
38fa					if DEBUG_FORTH_WORDS 
38fa						DMARK "RN2" 
38fa f5				push af  
38fb 3a 0f 39			ld a, (.dmark)  
38fe 32 6b ee			ld (debug_mark),a  
3901 3a 10 39			ld a, (.dmark+1)  
3904 32 6c ee			ld (debug_mark+1),a  
3907 3a 11 39			ld a, (.dmark+2)  
390a 32 6d ee			ld (debug_mark+2),a  
390d 18 03			jr .pastdmark  
390f ..			.dmark: db "RN2"  
3912 f1			.pastdmark: pop af  
3913			endm  
# End of macro DMARK
3913						CALLMONITOR 
3913 cd 6f ee			call debug_vector  
3916				endm  
# End of macro CALLMONITOR
3916					endif 
3916 22 af eb				ld (LFSRSeed+2), hl 
3919			 
3919					FORTH_DSP_POP 
3919 cd 16 1e			call macro_forth_dsp_pop 
391c				endm 
# End of macro FORTH_DSP_POP
391c			 
391c e5					push hl 
391d			 
391d e1			.inrange:	pop hl 
391e cd 0d 0d				call prng16  
3921					if DEBUG_FORTH_WORDS 
3921						DMARK "RN3" 
3921 f5				push af  
3922 3a 36 39			ld a, (.dmark)  
3925 32 6b ee			ld (debug_mark),a  
3928 3a 37 39			ld a, (.dmark+1)  
392b 32 6c ee			ld (debug_mark+1),a  
392e 3a 38 39			ld a, (.dmark+2)  
3931 32 6d ee			ld (debug_mark+2),a  
3934 18 03			jr .pastdmark  
3936 ..			.dmark: db "RN3"  
3939 f1			.pastdmark: pop af  
393a			endm  
# End of macro DMARK
393a						CALLMONITOR 
393a cd 6f ee			call debug_vector  
393d				endm  
# End of macro CALLMONITOR
393d					endif 
393d					 
393d					; if the range is 8bit knock out the high byte 
393d			 
393d ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
3941			 
3941 3e 00				ld a, 0 
3943 ba					cp d  
3944 20 1e				jr nz, .hirange 
3946 26 00				ld h, 0   ; knock it down to 8bit 
3948			 
3948					if DEBUG_FORTH_WORDS 
3948						DMARK "RNk" 
3948 f5				push af  
3949 3a 5d 39			ld a, (.dmark)  
394c 32 6b ee			ld (debug_mark),a  
394f 3a 5e 39			ld a, (.dmark+1)  
3952 32 6c ee			ld (debug_mark+1),a  
3955 3a 5f 39			ld a, (.dmark+2)  
3958 32 6d ee			ld (debug_mark+2),a  
395b 18 03			jr .pastdmark  
395d ..			.dmark: db "RNk"  
3960 f1			.pastdmark: pop af  
3961			endm  
# End of macro DMARK
3961						CALLMONITOR 
3961 cd 6f ee			call debug_vector  
3964				endm  
# End of macro CALLMONITOR
3964					endif 
3964			.hirange:   
3964 e5					push hl  
3965 b7					or a  
3966 ed 52		                sbc hl, de 
3968			 
3968					;call cmp16 
3968			 
3968 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
396a e1					pop hl 
396b e5					push hl 
396c			 
396c					if DEBUG_FORTH_WORDS 
396c						DMARK "RN4" 
396c f5				push af  
396d 3a 81 39			ld a, (.dmark)  
3970 32 6b ee			ld (debug_mark),a  
3973 3a 82 39			ld a, (.dmark+1)  
3976 32 6c ee			ld (debug_mark+1),a  
3979 3a 83 39			ld a, (.dmark+2)  
397c 32 6d ee			ld (debug_mark+2),a  
397f 18 03			jr .pastdmark  
3981 ..			.dmark: db "RN4"  
3984 f1			.pastdmark: pop af  
3985			endm  
# End of macro DMARK
3985						CALLMONITOR 
3985 cd 6f ee			call debug_vector  
3988				endm  
# End of macro CALLMONITOR
3988					endif 
3988 ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
398c					;call cmp16 
398c				 
398c b7					or a  
398d ed 52		                sbc hl, de 
398f 38 8c				jr c, .inrange 
3991			 
3991 e1					pop hl 
3992					 
3992					if DEBUG_FORTH_WORDS 
3992						DMARK "RNd" 
3992 f5				push af  
3993 3a a7 39			ld a, (.dmark)  
3996 32 6b ee			ld (debug_mark),a  
3999 3a a8 39			ld a, (.dmark+1)  
399c 32 6c ee			ld (debug_mark+1),a  
399f 3a a9 39			ld a, (.dmark+2)  
39a2 32 6d ee			ld (debug_mark+2),a  
39a5 18 03			jr .pastdmark  
39a7 ..			.dmark: db "RNd"  
39aa f1			.pastdmark: pop af  
39ab			endm  
# End of macro DMARK
39ab						CALLMONITOR 
39ab cd 6f ee			call debug_vector  
39ae				endm  
# End of macro CALLMONITOR
39ae					endif 
39ae			 
39ae			 
39ae cd 67 1b				call forth_push_numhl 
39b1				       NEXTW 
39b1 c3 14 1f			jp macro_next 
39b4				endm 
# End of macro NEXTW
39b4			 
39b4			.ENDMATHS: 
39b4			 
39b4			; eof 
39b4			 
# End of file forth_words_maths.asm
39b4			include "forth_words_display.asm" 
39b4			 
39b4			; | ## Display Words 
39b4			 
39b4			.ACT: 
39b4			 
39b4				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
39b4 62				db WORD_SYS_CORE+78             
39b5 00 3a			dw .INFO            
39b7 07				db 6 + 1 
39b8 .. 00			db "ACTIVE",0              
39bf				endm 
# End of macro CWHEAD
39bf			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
39bf			;  
39bf			; | | To display a pulsing activity indicator in a processing loop do this... 
39bf			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
39bf			 
39bf					if DEBUG_FORTH_WORDS_KEY 
39bf						DMARK "ACT" 
39bf f5				push af  
39c0 3a d4 39			ld a, (.dmark)  
39c3 32 6b ee			ld (debug_mark),a  
39c6 3a d5 39			ld a, (.dmark+1)  
39c9 32 6c ee			ld (debug_mark+1),a  
39cc 3a d6 39			ld a, (.dmark+2)  
39cf 32 6d ee			ld (debug_mark+2),a  
39d2 18 03			jr .pastdmark  
39d4 ..			.dmark: db "ACT"  
39d7 f1			.pastdmark: pop af  
39d8			endm  
# End of macro DMARK
39d8						CALLMONITOR 
39d8 cd 6f ee			call debug_vector  
39db				endm  
# End of macro CALLMONITOR
39db					endif 
39db cd 10 0b				call active 
39de					if DEBUG_FORTH_WORDS 
39de						DMARK "ACp" 
39de f5				push af  
39df 3a f3 39			ld a, (.dmark)  
39e2 32 6b ee			ld (debug_mark),a  
39e5 3a f4 39			ld a, (.dmark+1)  
39e8 32 6c ee			ld (debug_mark+1),a  
39eb 3a f5 39			ld a, (.dmark+2)  
39ee 32 6d ee			ld (debug_mark+2),a  
39f1 18 03			jr .pastdmark  
39f3 ..			.dmark: db "ACp"  
39f6 f1			.pastdmark: pop af  
39f7			endm  
# End of macro DMARK
39f7						CALLMONITOR 
39f7 cd 6f ee			call debug_vector  
39fa				endm  
# End of macro CALLMONITOR
39fa					endif 
39fa cd d5 1b				call forth_push_str 
39fd			 
39fd					NEXTW 
39fd c3 14 1f			jp macro_next 
3a00				endm 
# End of macro NEXTW
3a00			.INFO: 
3a00			 
3a00				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3a00 62				db WORD_SYS_CORE+78             
3a01 1d 3a			dw .ATP            
3a03 05				db 4 + 1 
3a04 .. 00			db "INFO",0              
3a09				endm 
# End of macro CWHEAD
3a09			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3a09					FORTH_DSP_VALUEHL 
3a09 cd 5e 1d			call macro_dsp_valuehl 
3a0c				endm 
# End of macro FORTH_DSP_VALUEHL
3a0c			 
3a0c					FORTH_DSP_POP 
3a0c cd 16 1e			call macro_forth_dsp_pop 
3a0f				endm 
# End of macro FORTH_DSP_POP
3a0f			 
3a0f e5					push hl 
3a10			 
3a10					FORTH_DSP_VALUEHL 
3a10 cd 5e 1d			call macro_dsp_valuehl 
3a13				endm 
# End of macro FORTH_DSP_VALUEHL
3a13			 
3a13					FORTH_DSP_POP 
3a13 cd 16 1e			call macro_forth_dsp_pop 
3a16				endm 
# End of macro FORTH_DSP_POP
3a16			 
3a16 d1					pop de 
3a17			 
3a17 cd 4a 0b				call info_panel 
3a1a			 
3a1a			 
3a1a					NEXTW 
3a1a c3 14 1f			jp macro_next 
3a1d				endm 
# End of macro NEXTW
3a1d			.ATP: 
3a1d				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a1d 62				db WORD_SYS_CORE+78             
3a1e 94 3a			dw .FB            
3a20 04				db 3 + 1 
3a21 .. 00			db "AT?",0              
3a25				endm 
# End of macro CWHEAD
3a25			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a25					if DEBUG_FORTH_WORDS_KEY 
3a25						DMARK "AT?" 
3a25 f5				push af  
3a26 3a 3a 3a			ld a, (.dmark)  
3a29 32 6b ee			ld (debug_mark),a  
3a2c 3a 3b 3a			ld a, (.dmark+1)  
3a2f 32 6c ee			ld (debug_mark+1),a  
3a32 3a 3c 3a			ld a, (.dmark+2)  
3a35 32 6d ee			ld (debug_mark+2),a  
3a38 18 03			jr .pastdmark  
3a3a ..			.dmark: db "AT?"  
3a3d f1			.pastdmark: pop af  
3a3e			endm  
# End of macro DMARK
3a3e						CALLMONITOR 
3a3e cd 6f ee			call debug_vector  
3a41				endm  
# End of macro CALLMONITOR
3a41					endif 
3a41 3a 5e ea				ld a, (f_cursor_ptr) 
3a44			 
3a44			if DEBUG_FORTH_WORDS 
3a44				DMARK "AT?" 
3a44 f5				push af  
3a45 3a 59 3a			ld a, (.dmark)  
3a48 32 6b ee			ld (debug_mark),a  
3a4b 3a 5a 3a			ld a, (.dmark+1)  
3a4e 32 6c ee			ld (debug_mark+1),a  
3a51 3a 5b 3a			ld a, (.dmark+2)  
3a54 32 6d ee			ld (debug_mark+2),a  
3a57 18 03			jr .pastdmark  
3a59 ..			.dmark: db "AT?"  
3a5c f1			.pastdmark: pop af  
3a5d			endm  
# End of macro DMARK
3a5d				CALLMONITOR 
3a5d cd 6f ee			call debug_vector  
3a60				endm  
# End of macro CALLMONITOR
3a60			endif	 
3a60					; count the number of rows 
3a60			 
3a60 06 00				ld b, 0 
3a62 4f			.atpr:		ld c, a    ; save in case we go below zero 
3a63 d6 28				sub display_cols 
3a65 f2 6b 3a				jp p, .atprunder 
3a68 04					inc b 
3a69 18 f7				jr .atpr 
3a6b			.atprunder:	 
3a6b			if DEBUG_FORTH_WORDS 
3a6b				DMARK "A?2" 
3a6b f5				push af  
3a6c 3a 80 3a			ld a, (.dmark)  
3a6f 32 6b ee			ld (debug_mark),a  
3a72 3a 81 3a			ld a, (.dmark+1)  
3a75 32 6c ee			ld (debug_mark+1),a  
3a78 3a 82 3a			ld a, (.dmark+2)  
3a7b 32 6d ee			ld (debug_mark+2),a  
3a7e 18 03			jr .pastdmark  
3a80 ..			.dmark: db "A?2"  
3a83 f1			.pastdmark: pop af  
3a84			endm  
# End of macro DMARK
3a84				CALLMONITOR 
3a84 cd 6f ee			call debug_vector  
3a87				endm  
# End of macro CALLMONITOR
3a87			endif	 
3a87 26 00				ld h, 0 
3a89 69					ld l, c 
3a8a cd 67 1b				call forth_push_numhl 
3a8d 68					ld l, b  
3a8e cd 67 1b				call forth_push_numhl 
3a91			 
3a91			 
3a91				NEXTW 
3a91 c3 14 1f			jp macro_next 
3a94				endm 
# End of macro NEXTW
3a94			 
3a94			.FB: 
3a94				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3a94 1b				db WORD_SYS_CORE+7             
3a95 e2 3a			dw .EMIT            
3a97 03				db 2 + 1 
3a98 .. 00			db "FB",0              
3a9b				endm 
# End of macro CWHEAD
3a9b			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3a9b			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3a9b			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3a9b			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3a9b					if DEBUG_FORTH_WORDS_KEY 
3a9b						DMARK "FB." 
3a9b f5				push af  
3a9c 3a b0 3a			ld a, (.dmark)  
3a9f 32 6b ee			ld (debug_mark),a  
3aa2 3a b1 3a			ld a, (.dmark+1)  
3aa5 32 6c ee			ld (debug_mark+1),a  
3aa8 3a b2 3a			ld a, (.dmark+2)  
3aab 32 6d ee			ld (debug_mark+2),a  
3aae 18 03			jr .pastdmark  
3ab0 ..			.dmark: db "FB."  
3ab3 f1			.pastdmark: pop af  
3ab4			endm  
# End of macro DMARK
3ab4						CALLMONITOR 
3ab4 cd 6f ee			call debug_vector  
3ab7				endm  
# End of macro CALLMONITOR
3ab7					endif 
3ab7			 
3ab7					FORTH_DSP_VALUEHL 
3ab7 cd 5e 1d			call macro_dsp_valuehl 
3aba				endm 
# End of macro FORTH_DSP_VALUEHL
3aba			 
3aba 7d					ld a, l 
3abb fe 01				cp 1 
3abd 20 05				jr nz, .fbn1 
3abf 21 10 ed				ld hl, display_fb1 
3ac2 18 15				jr .fbset 
3ac4 fe 02		.fbn1:		cp 2 
3ac6 20 05				jr nz, .fbn2 
3ac8 21 ce eb				ld hl, display_fb2 
3acb 18 0c				jr .fbset 
3acd fe 03		.fbn2:		cp 3 
3acf 20 05				jr nz, .fbn3 
3ad1 21 6f ec				ld hl, display_fb3 
3ad4 18 03				jr .fbset 
3ad6			.fbn3:		 ; if invalid number select first 
3ad6 21 10 ed				ld hl, display_fb1 
3ad9 22 cc eb		.fbset:		ld (display_fb_active), hl 
3adc			 
3adc					FORTH_DSP_POP 
3adc cd 16 1e			call macro_forth_dsp_pop 
3adf				endm 
# End of macro FORTH_DSP_POP
3adf			 
3adf					NEXTW 
3adf c3 14 1f			jp macro_next 
3ae2				endm 
# End of macro NEXTW
3ae2			 
3ae2			 
3ae2			.EMIT: 
3ae2				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3ae2 1b				db WORD_SYS_CORE+7             
3ae3 33 3b			dw .DOTH            
3ae5 05				db 4 + 1 
3ae6 .. 00			db "EMIT",0              
3aeb				endm 
# End of macro CWHEAD
3aeb			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3aeb					; get value off TOS and display it 
3aeb			 
3aeb					if DEBUG_FORTH_WORDS_KEY 
3aeb						DMARK "EMT" 
3aeb f5				push af  
3aec 3a 00 3b			ld a, (.dmark)  
3aef 32 6b ee			ld (debug_mark),a  
3af2 3a 01 3b			ld a, (.dmark+1)  
3af5 32 6c ee			ld (debug_mark+1),a  
3af8 3a 02 3b			ld a, (.dmark+2)  
3afb 32 6d ee			ld (debug_mark+2),a  
3afe 18 03			jr .pastdmark  
3b00 ..			.dmark: db "EMT"  
3b03 f1			.pastdmark: pop af  
3b04			endm  
# End of macro DMARK
3b04						CALLMONITOR 
3b04 cd 6f ee			call debug_vector  
3b07				endm  
# End of macro CALLMONITOR
3b07					endif 
3b07			 
3b07					FORTH_DSP_VALUEHL 
3b07 cd 5e 1d			call macro_dsp_valuehl 
3b0a				endm 
# End of macro FORTH_DSP_VALUEHL
3b0a			 
3b0a 7d					ld a,l 
3b0b			 
3b0b					; TODO write to display 
3b0b			 
3b0b 32 bf e4				ld (os_input), a 
3b0e 3e 00				ld a, 0 
3b10 32 c0 e4				ld (os_input+1), a 
3b13					 
3b13 3a 5e ea				ld a, (f_cursor_ptr) 
3b16 11 bf e4				ld de, os_input 
3b19 cd cc 0b				call str_at_display 
3b1c			 
3b1c			 
3b1c 3a 3c ea				ld a,(cli_autodisplay) 
3b1f fe 00				cp 0 
3b21 28 03				jr z, .enoupdate 
3b23 cd dc 0b						call update_display 
3b26					.enoupdate: 
3b26			 
3b26 3a 5e ea				ld a, (f_cursor_ptr) 
3b29 3c					inc a 
3b2a 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3b2d			 
3b2d			 
3b2d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b2d cd 16 1e			call macro_forth_dsp_pop 
3b30				endm 
# End of macro FORTH_DSP_POP
3b30			  
3b30			 
3b30					NEXTW 
3b30 c3 14 1f			jp macro_next 
3b33				endm 
# End of macro NEXTW
3b33			.DOTH: 
3b33				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b33 1c				db WORD_SYS_CORE+8             
3b34 63 3b			dw .DOTF            
3b36 03				db 2 + 1 
3b37 .. 00			db ".-",0              
3b3a				endm 
# End of macro CWHEAD
3b3a			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b3a					; get value off TOS and display it 
3b3a					if DEBUG_FORTH_WORDS_KEY 
3b3a						DMARK "DTD" 
3b3a f5				push af  
3b3b 3a 4f 3b			ld a, (.dmark)  
3b3e 32 6b ee			ld (debug_mark),a  
3b41 3a 50 3b			ld a, (.dmark+1)  
3b44 32 6c ee			ld (debug_mark+1),a  
3b47 3a 51 3b			ld a, (.dmark+2)  
3b4a 32 6d ee			ld (debug_mark+2),a  
3b4d 18 03			jr .pastdmark  
3b4f ..			.dmark: db "DTD"  
3b52 f1			.pastdmark: pop af  
3b53			endm  
# End of macro DMARK
3b53						CALLMONITOR 
3b53 cd 6f ee			call debug_vector  
3b56				endm  
# End of macro CALLMONITOR
3b56					endif 
3b56 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3b58 3e 00			ld a, 0 
3b5a 32 3d ea			ld (cli_mvdot), a 
3b5d c3 ba 3b			jp .dotgo 
3b60				NEXTW 
3b60 c3 14 1f			jp macro_next 
3b63				endm 
# End of macro NEXTW
3b63			.DOTF: 
3b63				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3b63 1c				db WORD_SYS_CORE+8             
3b64 91 3b			dw .DOT            
3b66 03				db 2 + 1 
3b67 .. 00			db ".>",0              
3b6a				endm 
# End of macro CWHEAD
3b6a			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
3b6a					; get value off TOS and display it 
3b6a			        ; TODO BUG adds extra spaces 
3b6a			        ; TODO BUG handle numerics? 
3b6a					if DEBUG_FORTH_WORDS_KEY 
3b6a						DMARK "DTC" 
3b6a f5				push af  
3b6b 3a 7f 3b			ld a, (.dmark)  
3b6e 32 6b ee			ld (debug_mark),a  
3b71 3a 80 3b			ld a, (.dmark+1)  
3b74 32 6c ee			ld (debug_mark+1),a  
3b77 3a 81 3b			ld a, (.dmark+2)  
3b7a 32 6d ee			ld (debug_mark+2),a  
3b7d 18 03			jr .pastdmark  
3b7f ..			.dmark: db "DTC"  
3b82 f1			.pastdmark: pop af  
3b83			endm  
# End of macro DMARK
3b83						CALLMONITOR 
3b83 cd 6f ee			call debug_vector  
3b86				endm  
# End of macro CALLMONITOR
3b86					endif 
3b86 3e 01			ld a, 1 
3b88 32 3d ea			ld (cli_mvdot), a 
3b8b c3 ba 3b			jp .dotgo 
3b8e				NEXTW 
3b8e c3 14 1f			jp macro_next 
3b91				endm 
# End of macro NEXTW
3b91			 
3b91			.DOT: 
3b91				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3b91 1c				db WORD_SYS_CORE+8             
3b92 6d 3d			dw .CLS            
3b94 02				db 1 + 1 
3b95 .. 00			db ".",0              
3b97				endm 
# End of macro CWHEAD
3b97			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
3b97					; get value off TOS and display it 
3b97			 
3b97					if DEBUG_FORTH_WORDS_KEY 
3b97						DMARK "DOT" 
3b97 f5				push af  
3b98 3a ac 3b			ld a, (.dmark)  
3b9b 32 6b ee			ld (debug_mark),a  
3b9e 3a ad 3b			ld a, (.dmark+1)  
3ba1 32 6c ee			ld (debug_mark+1),a  
3ba4 3a ae 3b			ld a, (.dmark+2)  
3ba7 32 6d ee			ld (debug_mark+2),a  
3baa 18 03			jr .pastdmark  
3bac ..			.dmark: db "DOT"  
3baf f1			.pastdmark: pop af  
3bb0			endm  
# End of macro DMARK
3bb0						CALLMONITOR 
3bb0 cd 6f ee			call debug_vector  
3bb3				endm  
# End of macro CALLMONITOR
3bb3					endif 
3bb3 3e 00			ld a, 0 
3bb5 32 3d ea			ld (cli_mvdot), a 
3bb8 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3bba				 
3bba			 
3bba			.dotgo: 
3bba			 
3bba			; move up type to on stack for parserv5 
3bba					FORTH_DSP 
3bba cd 24 1d			call macro_forth_dsp 
3bbd				endm 
# End of macro FORTH_DSP
3bbd				;FORTH_DSP_VALUE  
3bbd			 
3bbd			if DEBUG_FORTH_DOT 
3bbd				DMARK "DOT" 
3bbd f5				push af  
3bbe 3a d2 3b			ld a, (.dmark)  
3bc1 32 6b ee			ld (debug_mark),a  
3bc4 3a d3 3b			ld a, (.dmark+1)  
3bc7 32 6c ee			ld (debug_mark+1),a  
3bca 3a d4 3b			ld a, (.dmark+2)  
3bcd 32 6d ee			ld (debug_mark+2),a  
3bd0 18 03			jr .pastdmark  
3bd2 ..			.dmark: db "DOT"  
3bd5 f1			.pastdmark: pop af  
3bd6			endm  
# End of macro DMARK
3bd6				CALLMONITOR 
3bd6 cd 6f ee			call debug_vector  
3bd9				endm  
# End of macro CALLMONITOR
3bd9			endif	 
3bd9			;		.print: 
3bd9			 
3bd9 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3bda 23				inc hl   ; position to the actual value 
3bdb fe 01			cp DS_TYPE_STR 
3bdd 20 06			jr nz, .dotnum1  
3bdf			 
3bdf			; display string 
3bdf				FORTH_DSP_VALUE  
3bdf cd 47 1d			call macro_forth_dsp_value 
3be2				endm 
# End of macro FORTH_DSP_VALUE
3be2 eb				ex de,hl 
3be3 18 49			jr .dotwrite 
3be5			 
3be5			.dotnum1: 
3be5 fe 02			cp DS_TYPE_INUM 
3be7 20 44			jr nz, .dotflot 
3be9			 
3be9			 
3be9			; display number 
3be9			 
3be9			;	push hl 
3be9			;	call clear_display 
3be9			;	pop hl 
3be9			 
3be9 5e				ld e, (hl) 
3bea 23				inc hl 
3beb 56				ld d, (hl) 
3bec 21 c1 e2			ld hl, scratch 
3bef			if DEBUG_FORTH_DOT 
3bef				DMARK "DT1" 
3bef f5				push af  
3bf0 3a 04 3c			ld a, (.dmark)  
3bf3 32 6b ee			ld (debug_mark),a  
3bf6 3a 05 3c			ld a, (.dmark+1)  
3bf9 32 6c ee			ld (debug_mark+1),a  
3bfc 3a 06 3c			ld a, (.dmark+2)  
3bff 32 6d ee			ld (debug_mark+2),a  
3c02 18 03			jr .pastdmark  
3c04 ..			.dmark: db "DT1"  
3c07 f1			.pastdmark: pop af  
3c08			endm  
# End of macro DMARK
3c08				CALLMONITOR 
3c08 cd 6f ee			call debug_vector  
3c0b				endm  
# End of macro CALLMONITOR
3c0b			endif	 
3c0b			 
3c0b cd 08 11			call uitoa_16 
3c0e eb				ex de,hl 
3c0f			 
3c0f			if DEBUG_FORTH_DOT 
3c0f				DMARK "DT2" 
3c0f f5				push af  
3c10 3a 24 3c			ld a, (.dmark)  
3c13 32 6b ee			ld (debug_mark),a  
3c16 3a 25 3c			ld a, (.dmark+1)  
3c19 32 6c ee			ld (debug_mark+1),a  
3c1c 3a 26 3c			ld a, (.dmark+2)  
3c1f 32 6d ee			ld (debug_mark+2),a  
3c22 18 03			jr .pastdmark  
3c24 ..			.dmark: db "DT2"  
3c27 f1			.pastdmark: pop af  
3c28			endm  
# End of macro DMARK
3c28				CALLMONITOR 
3c28 cd 6f ee			call debug_vector  
3c2b				endm  
# End of macro CALLMONITOR
3c2b			endif	 
3c2b			 
3c2b			;	ld de, os_word_scratch 
3c2b 18 01			jr .dotwrite 
3c2d			 
3c2d 00			.dotflot:   nop 
3c2e			; TODO print floating point number 
3c2e			 
3c2e			.dotwrite:		 
3c2e			 
3c2e					; if c is set then set all '-' to spaces 
3c2e					; need to also take into account .>  
3c2e			 
3c2e 3e 01				ld a, 1 
3c30 b9					cp c 
3c31 20 67				jr nz, .nodashswap 
3c33			 
3c33					; DE has the string to write, working with HL 
3c33			 
3c33 06 ff				ld b, 255 
3c35 d5					push de 
3c36 e1					pop hl 
3c37			 
3c37			if DEBUG_FORTH_DOT 
3c37				DMARK "DT-" 
3c37 f5				push af  
3c38 3a 4c 3c			ld a, (.dmark)  
3c3b 32 6b ee			ld (debug_mark),a  
3c3e 3a 4d 3c			ld a, (.dmark+1)  
3c41 32 6c ee			ld (debug_mark+1),a  
3c44 3a 4e 3c			ld a, (.dmark+2)  
3c47 32 6d ee			ld (debug_mark+2),a  
3c4a 18 03			jr .pastdmark  
3c4c ..			.dmark: db "DT-"  
3c4f f1			.pastdmark: pop af  
3c50			endm  
# End of macro DMARK
3c50				CALLMONITOR 
3c50 cd 6f ee			call debug_vector  
3c53				endm  
# End of macro CALLMONITOR
3c53			endif	 
3c53 7e			.dashscan:	ld a, (hl) 
3c54 fe 00				cp 0 
3c56 28 42				jr z, .nodashswap 
3c58 fe 2d				cp '-' 
3c5a 20 03				jr nz, .dashskip 
3c5c 3e 20				ld a, ' ' 
3c5e 77					ld (hl), a 
3c5f 23			.dashskip:	inc hl 
3c60			if DEBUG_FORTH_DOT 
3c60				DMARK "D-2" 
3c60 f5				push af  
3c61 3a 75 3c			ld a, (.dmark)  
3c64 32 6b ee			ld (debug_mark),a  
3c67 3a 76 3c			ld a, (.dmark+1)  
3c6a 32 6c ee			ld (debug_mark+1),a  
3c6d 3a 77 3c			ld a, (.dmark+2)  
3c70 32 6d ee			ld (debug_mark+2),a  
3c73 18 03			jr .pastdmark  
3c75 ..			.dmark: db "D-2"  
3c78 f1			.pastdmark: pop af  
3c79			endm  
# End of macro DMARK
3c79				CALLMONITOR 
3c79 cd 6f ee			call debug_vector  
3c7c				endm  
# End of macro CALLMONITOR
3c7c			endif	 
3c7c 10 d5				djnz .dashscan 
3c7e			 
3c7e			if DEBUG_FORTH_DOT 
3c7e				DMARK "D-1" 
3c7e f5				push af  
3c7f 3a 93 3c			ld a, (.dmark)  
3c82 32 6b ee			ld (debug_mark),a  
3c85 3a 94 3c			ld a, (.dmark+1)  
3c88 32 6c ee			ld (debug_mark+1),a  
3c8b 3a 95 3c			ld a, (.dmark+2)  
3c8e 32 6d ee			ld (debug_mark+2),a  
3c91 18 03			jr .pastdmark  
3c93 ..			.dmark: db "D-1"  
3c96 f1			.pastdmark: pop af  
3c97			endm  
# End of macro DMARK
3c97				CALLMONITOR 
3c97 cd 6f ee			call debug_vector  
3c9a				endm  
# End of macro CALLMONITOR
3c9a			endif	 
3c9a			 
3c9a			.nodashswap: 
3c9a			 
3c9a			if DEBUG_FORTH_DOT 
3c9a				DMARK "D-o" 
3c9a f5				push af  
3c9b 3a af 3c			ld a, (.dmark)  
3c9e 32 6b ee			ld (debug_mark),a  
3ca1 3a b0 3c			ld a, (.dmark+1)  
3ca4 32 6c ee			ld (debug_mark+1),a  
3ca7 3a b1 3c			ld a, (.dmark+2)  
3caa 32 6d ee			ld (debug_mark+2),a  
3cad 18 03			jr .pastdmark  
3caf ..			.dmark: db "D-o"  
3cb2 f1			.pastdmark: pop af  
3cb3			endm  
# End of macro DMARK
3cb3				CALLMONITOR 
3cb3 cd 6f ee			call debug_vector  
3cb6				endm  
# End of macro CALLMONITOR
3cb6			endif	 
3cb6			 
3cb6 d5					push de   ; save string start in case we need to advance print 
3cb7			 
3cb7 3a 5e ea				ld a, (f_cursor_ptr) 
3cba cd cc 0b				call str_at_display 
3cbd 3a 3c ea				ld a,(cli_autodisplay) 
3cc0 fe 00				cp 0 
3cc2 28 03				jr z, .noupdate 
3cc4 cd dc 0b						call update_display 
3cc7					.noupdate: 
3cc7			 
3cc7			 
3cc7					; see if we need to advance the print position 
3cc7			 
3cc7 e1					pop hl   ; get back string 
3cc8			;		ex de,hl 
3cc8			 
3cc8 3a 3d ea				ld a, (cli_mvdot) 
3ccb			if DEBUG_FORTH_DOT 
3ccb			;		ld e,a 
3ccb				DMARK "D>1" 
3ccb f5				push af  
3ccc 3a e0 3c			ld a, (.dmark)  
3ccf 32 6b ee			ld (debug_mark),a  
3cd2 3a e1 3c			ld a, (.dmark+1)  
3cd5 32 6c ee			ld (debug_mark+1),a  
3cd8 3a e2 3c			ld a, (.dmark+2)  
3cdb 32 6d ee			ld (debug_mark+2),a  
3cde 18 03			jr .pastdmark  
3ce0 ..			.dmark: db "D>1"  
3ce3 f1			.pastdmark: pop af  
3ce4			endm  
# End of macro DMARK
3ce4				CALLMONITOR 
3ce4 cd 6f ee			call debug_vector  
3ce7				endm  
# End of macro CALLMONITOR
3ce7			endif	 
3ce7 fe 00				cp 0 
3ce9 28 44				jr z, .noadv 
3ceb					; yes, lets advance the print position 
3ceb 3e 00				ld a, 0 
3ced cd 64 11				call strlent 
3cf0			if DEBUG_FORTH_DOT 
3cf0				DMARK "D-?" 
3cf0 f5				push af  
3cf1 3a 05 3d			ld a, (.dmark)  
3cf4 32 6b ee			ld (debug_mark),a  
3cf7 3a 06 3d			ld a, (.dmark+1)  
3cfa 32 6c ee			ld (debug_mark+1),a  
3cfd 3a 07 3d			ld a, (.dmark+2)  
3d00 32 6d ee			ld (debug_mark+2),a  
3d03 18 03			jr .pastdmark  
3d05 ..			.dmark: db "D-?"  
3d08 f1			.pastdmark: pop af  
3d09			endm  
# End of macro DMARK
3d09				CALLMONITOR 
3d09 cd 6f ee			call debug_vector  
3d0c				endm  
# End of macro CALLMONITOR
3d0c			endif	 
3d0c 3a 5e ea				ld a, (f_cursor_ptr) 
3d0f 85					add a,l 
3d10					;call addatohl 
3d10					;ld a, l 
3d10 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3d13			 
3d13			if DEBUG_FORTH_DOT 
3d13				DMARK "D->" 
3d13 f5				push af  
3d14 3a 28 3d			ld a, (.dmark)  
3d17 32 6b ee			ld (debug_mark),a  
3d1a 3a 29 3d			ld a, (.dmark+1)  
3d1d 32 6c ee			ld (debug_mark+1),a  
3d20 3a 2a 3d			ld a, (.dmark+2)  
3d23 32 6d ee			ld (debug_mark+2),a  
3d26 18 03			jr .pastdmark  
3d28 ..			.dmark: db "D->"  
3d2b f1			.pastdmark: pop af  
3d2c			endm  
# End of macro DMARK
3d2c				CALLMONITOR 
3d2c cd 6f ee			call debug_vector  
3d2f				endm  
# End of macro CALLMONITOR
3d2f			endif	 
3d2f			 
3d2f			.noadv:	 
3d2f			 
3d2f					if DEBUG_FORTH_DOT_WAIT 
3d2f							call next_page_prompt 
3d2f					endif	 
3d2f			; TODO this pop off the stack causes a crash. i dont know why 
3d2f			 
3d2f			 
3d2f			if DEBUG_FORTH_DOT 
3d2f				DMARK "DTh" 
3d2f f5				push af  
3d30 3a 44 3d			ld a, (.dmark)  
3d33 32 6b ee			ld (debug_mark),a  
3d36 3a 45 3d			ld a, (.dmark+1)  
3d39 32 6c ee			ld (debug_mark+1),a  
3d3c 3a 46 3d			ld a, (.dmark+2)  
3d3f 32 6d ee			ld (debug_mark+2),a  
3d42 18 03			jr .pastdmark  
3d44 ..			.dmark: db "DTh"  
3d47 f1			.pastdmark: pop af  
3d48			endm  
# End of macro DMARK
3d48				CALLMONITOR 
3d48 cd 6f ee			call debug_vector  
3d4b				endm  
# End of macro CALLMONITOR
3d4b			endif	 
3d4b			 
3d4b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d4b cd 16 1e			call macro_forth_dsp_pop 
3d4e				endm 
# End of macro FORTH_DSP_POP
3d4e			 
3d4e			if DEBUG_FORTH_DOT 
3d4e				DMARK "DTi" 
3d4e f5				push af  
3d4f 3a 63 3d			ld a, (.dmark)  
3d52 32 6b ee			ld (debug_mark),a  
3d55 3a 64 3d			ld a, (.dmark+1)  
3d58 32 6c ee			ld (debug_mark+1),a  
3d5b 3a 65 3d			ld a, (.dmark+2)  
3d5e 32 6d ee			ld (debug_mark+2),a  
3d61 18 03			jr .pastdmark  
3d63 ..			.dmark: db "DTi"  
3d66 f1			.pastdmark: pop af  
3d67			endm  
# End of macro DMARK
3d67				CALLMONITOR 
3d67 cd 6f ee			call debug_vector  
3d6a				endm  
# End of macro CALLMONITOR
3d6a			endif	 
3d6a			 
3d6a			 
3d6a					NEXTW 
3d6a c3 14 1f			jp macro_next 
3d6d				endm 
# End of macro NEXTW
3d6d			 
3d6d			.CLS: 
3d6d				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3d6d 35				db WORD_SYS_CORE+33             
3d6e 9a 3d			dw .DRAW            
3d70 04				db 3 + 1 
3d71 .. 00			db "CLS",0              
3d75				endm 
# End of macro CWHEAD
3d75			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3d75					if DEBUG_FORTH_WORDS_KEY 
3d75						DMARK "CLS" 
3d75 f5				push af  
3d76 3a 8a 3d			ld a, (.dmark)  
3d79 32 6b ee			ld (debug_mark),a  
3d7c 3a 8b 3d			ld a, (.dmark+1)  
3d7f 32 6c ee			ld (debug_mark+1),a  
3d82 3a 8c 3d			ld a, (.dmark+2)  
3d85 32 6d ee			ld (debug_mark+2),a  
3d88 18 03			jr .pastdmark  
3d8a ..			.dmark: db "CLS"  
3d8d f1			.pastdmark: pop af  
3d8e			endm  
# End of macro DMARK
3d8e						CALLMONITOR 
3d8e cd 6f ee			call debug_vector  
3d91				endm  
# End of macro CALLMONITOR
3d91					endif 
3d91 cd b9 0b				call clear_display 
3d94 c3 a8 3e				jp .home		; and home cursor 
3d97					NEXTW 
3d97 c3 14 1f			jp macro_next 
3d9a				endm 
# End of macro NEXTW
3d9a			 
3d9a			.DRAW: 
3d9a				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3d9a 36				db WORD_SYS_CORE+34             
3d9b c5 3d			dw .DUMP            
3d9d 05				db 4 + 1 
3d9e .. 00			db "DRAW",0              
3da3				endm 
# End of macro CWHEAD
3da3			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3da3					if DEBUG_FORTH_WORDS_KEY 
3da3						DMARK "DRW" 
3da3 f5				push af  
3da4 3a b8 3d			ld a, (.dmark)  
3da7 32 6b ee			ld (debug_mark),a  
3daa 3a b9 3d			ld a, (.dmark+1)  
3dad 32 6c ee			ld (debug_mark+1),a  
3db0 3a ba 3d			ld a, (.dmark+2)  
3db3 32 6d ee			ld (debug_mark+2),a  
3db6 18 03			jr .pastdmark  
3db8 ..			.dmark: db "DRW"  
3dbb f1			.pastdmark: pop af  
3dbc			endm  
# End of macro DMARK
3dbc						CALLMONITOR 
3dbc cd 6f ee			call debug_vector  
3dbf				endm  
# End of macro CALLMONITOR
3dbf					endif 
3dbf cd dc 0b				call update_display 
3dc2					NEXTW 
3dc2 c3 14 1f			jp macro_next 
3dc5				endm 
# End of macro NEXTW
3dc5			 
3dc5			.DUMP: 
3dc5				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3dc5 37				db WORD_SYS_CORE+35             
3dc6 fd 3d			dw .CDUMP            
3dc8 05				db 4 + 1 
3dc9 .. 00			db "DUMP",0              
3dce				endm 
# End of macro CWHEAD
3dce			; | DUMP ( x -- ) With address x display dump   | DONE 
3dce			; TODO pop address to use off of the stack 
3dce					if DEBUG_FORTH_WORDS_KEY 
3dce						DMARK "DUM" 
3dce f5				push af  
3dcf 3a e3 3d			ld a, (.dmark)  
3dd2 32 6b ee			ld (debug_mark),a  
3dd5 3a e4 3d			ld a, (.dmark+1)  
3dd8 32 6c ee			ld (debug_mark+1),a  
3ddb 3a e5 3d			ld a, (.dmark+2)  
3dde 32 6d ee			ld (debug_mark+2),a  
3de1 18 03			jr .pastdmark  
3de3 ..			.dmark: db "DUM"  
3de6 f1			.pastdmark: pop af  
3de7			endm  
# End of macro DMARK
3de7						CALLMONITOR 
3de7 cd 6f ee			call debug_vector  
3dea				endm  
# End of macro CALLMONITOR
3dea					endif 
3dea cd b9 0b				call clear_display 
3ded			 
3ded					; get address 
3ded			 
3ded					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ded cd 5e 1d			call macro_dsp_valuehl 
3df0				endm 
# End of macro FORTH_DSP_VALUEHL
3df0				 
3df0					; save it for cdump 
3df0			 
3df0 22 e4 e5				ld (os_cur_ptr),hl 
3df3			 
3df3					; destroy value TOS 
3df3			 
3df3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3df3 cd 16 1e			call macro_forth_dsp_pop 
3df6				endm 
# End of macro FORTH_DSP_POP
3df6			 
3df6 cd e7 19				call dumpcont	; skip old style of param parsing	 
3df9 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3dfa					NEXTW 
3dfa c3 14 1f			jp macro_next 
3dfd				endm 
# End of macro NEXTW
3dfd			.CDUMP: 
3dfd				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3dfd 38				db WORD_SYS_CORE+36             
3dfe 2d 3e			dw .DAT            
3e00 06				db 5 + 1 
3e01 .. 00			db "CDUMP",0              
3e07				endm 
# End of macro CWHEAD
3e07			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3e07					if DEBUG_FORTH_WORDS_KEY 
3e07						DMARK "CDP" 
3e07 f5				push af  
3e08 3a 1c 3e			ld a, (.dmark)  
3e0b 32 6b ee			ld (debug_mark),a  
3e0e 3a 1d 3e			ld a, (.dmark+1)  
3e11 32 6c ee			ld (debug_mark+1),a  
3e14 3a 1e 3e			ld a, (.dmark+2)  
3e17 32 6d ee			ld (debug_mark+2),a  
3e1a 18 03			jr .pastdmark  
3e1c ..			.dmark: db "CDP"  
3e1f f1			.pastdmark: pop af  
3e20			endm  
# End of macro DMARK
3e20						CALLMONITOR 
3e20 cd 6f ee			call debug_vector  
3e23				endm  
# End of macro CALLMONITOR
3e23					endif 
3e23 cd b9 0b				call clear_display 
3e26 cd e7 19				call dumpcont	 
3e29 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3e2a					NEXTW 
3e2a c3 14 1f			jp macro_next 
3e2d				endm 
# End of macro NEXTW
3e2d			 
3e2d			 
3e2d			 
3e2d			 
3e2d			.DAT: 
3e2d				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3e2d 3d				db WORD_SYS_CORE+41             
3e2e 83 3e			dw .HOME            
3e30 03				db 2 + 1 
3e31 .. 00			db "AT",0              
3e34				endm 
# End of macro CWHEAD
3e34			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3e34					if DEBUG_FORTH_WORDS_KEY 
3e34						DMARK "AT." 
3e34 f5				push af  
3e35 3a 49 3e			ld a, (.dmark)  
3e38 32 6b ee			ld (debug_mark),a  
3e3b 3a 4a 3e			ld a, (.dmark+1)  
3e3e 32 6c ee			ld (debug_mark+1),a  
3e41 3a 4b 3e			ld a, (.dmark+2)  
3e44 32 6d ee			ld (debug_mark+2),a  
3e47 18 03			jr .pastdmark  
3e49 ..			.dmark: db "AT."  
3e4c f1			.pastdmark: pop af  
3e4d			endm  
# End of macro DMARK
3e4d						CALLMONITOR 
3e4d cd 6f ee			call debug_vector  
3e50				endm  
# End of macro CALLMONITOR
3e50					endif 
3e50					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e50 cd 5e 1d			call macro_dsp_valuehl 
3e53				endm 
# End of macro FORTH_DSP_VALUEHL
3e53			 
3e53			 
3e53					; TODO save cursor row 
3e53 7d					ld a,l 
3e54 fe 02				cp 2 
3e56 20 04				jr nz, .crow3 
3e58 3e 28				ld a, display_row_2 
3e5a 18 12				jr .ccol1 
3e5c fe 03		.crow3:		cp 3 
3e5e 20 04				jr nz, .crow4 
3e60 3e 50				ld a, display_row_3 
3e62 18 0a				jr .ccol1 
3e64 fe 04		.crow4:		cp 4 
3e66 20 04				jr nz, .crow1 
3e68 3e 78				ld a, display_row_4 
3e6a 18 02				jr .ccol1 
3e6c 3e 00		.crow1:		ld a,display_row_1 
3e6e f5			.ccol1:		push af			; got row offset 
3e6f 6f					ld l,a 
3e70 26 00				ld h,0 
3e72					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e72 cd 16 1e			call macro_forth_dsp_pop 
3e75				endm 
# End of macro FORTH_DSP_POP
3e75					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e75 cd 5e 1d			call macro_dsp_valuehl 
3e78				endm 
# End of macro FORTH_DSP_VALUEHL
3e78					; TODO save cursor col 
3e78 f1					pop af 
3e79 85					add l		; add col offset 
3e7a 32 5e ea				ld (f_cursor_ptr), a 
3e7d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e7d cd 16 1e			call macro_forth_dsp_pop 
3e80				endm 
# End of macro FORTH_DSP_POP
3e80			 
3e80					; calculate  
3e80			 
3e80					NEXTW 
3e80 c3 14 1f			jp macro_next 
3e83				endm 
# End of macro NEXTW
3e83			 
3e83			 
3e83			.HOME: 
3e83				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
3e83 41				db WORD_SYS_CORE+45             
3e84 b0 3e			dw .CR            
3e86 05				db 4 + 1 
3e87 .. 00			db "HOME",0              
3e8c				endm 
# End of macro CWHEAD
3e8c			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3e8c					if DEBUG_FORTH_WORDS_KEY 
3e8c						DMARK "HOM" 
3e8c f5				push af  
3e8d 3a a1 3e			ld a, (.dmark)  
3e90 32 6b ee			ld (debug_mark),a  
3e93 3a a2 3e			ld a, (.dmark+1)  
3e96 32 6c ee			ld (debug_mark+1),a  
3e99 3a a3 3e			ld a, (.dmark+2)  
3e9c 32 6d ee			ld (debug_mark+2),a  
3e9f 18 03			jr .pastdmark  
3ea1 ..			.dmark: db "HOM"  
3ea4 f1			.pastdmark: pop af  
3ea5			endm  
# End of macro DMARK
3ea5						CALLMONITOR 
3ea5 cd 6f ee			call debug_vector  
3ea8				endm  
# End of macro CALLMONITOR
3ea8					endif 
3ea8 3e 00		.home:		ld a, 0		; and home cursor 
3eaa 32 5e ea				ld (f_cursor_ptr), a 
3ead					NEXTW 
3ead c3 14 1f			jp macro_next 
3eb0				endm 
# End of macro NEXTW
3eb0			 
3eb0			 
3eb0			.CR: 
3eb0				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
3eb0 46				db WORD_SYS_CORE+50             
3eb1 eb 3e			dw .SPACE            
3eb3 03				db 2 + 1 
3eb4 .. 00			db "CR",0              
3eb7				endm 
# End of macro CWHEAD
3eb7			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
3eb7					if DEBUG_FORTH_WORDS_KEY 
3eb7						DMARK "CR." 
3eb7 f5				push af  
3eb8 3a cc 3e			ld a, (.dmark)  
3ebb 32 6b ee			ld (debug_mark),a  
3ebe 3a cd 3e			ld a, (.dmark+1)  
3ec1 32 6c ee			ld (debug_mark+1),a  
3ec4 3a ce 3e			ld a, (.dmark+2)  
3ec7 32 6d ee			ld (debug_mark+2),a  
3eca 18 03			jr .pastdmark  
3ecc ..			.dmark: db "CR."  
3ecf f1			.pastdmark: pop af  
3ed0			endm  
# End of macro DMARK
3ed0						CALLMONITOR 
3ed0 cd 6f ee			call debug_vector  
3ed3				endm  
# End of macro CALLMONITOR
3ed3					endif 
3ed3 3e 0d				ld a, 13 
3ed5 32 c1 e2				ld (scratch),a 
3ed8 3e 0a				ld a, 10 
3eda 32 c2 e2				ld (scratch+1),a 
3edd 3e 00				ld a, 0 
3edf 32 c3 e2				ld (scratch+2),a 
3ee2 21 c1 e2				ld hl, scratch 
3ee5 cd d5 1b				call forth_push_str 
3ee8					 
3ee8				       NEXTW 
3ee8 c3 14 1f			jp macro_next 
3eeb				endm 
# End of macro NEXTW
3eeb			.SPACE: 
3eeb				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3eeb 46				db WORD_SYS_CORE+50             
3eec 21 3f			dw .SPACES            
3eee 03				db 2 + 1 
3eef .. 00			db "BL",0              
3ef2				endm 
# End of macro CWHEAD
3ef2			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3ef2					if DEBUG_FORTH_WORDS_KEY 
3ef2						DMARK "BL." 
3ef2 f5				push af  
3ef3 3a 07 3f			ld a, (.dmark)  
3ef6 32 6b ee			ld (debug_mark),a  
3ef9 3a 08 3f			ld a, (.dmark+1)  
3efc 32 6c ee			ld (debug_mark+1),a  
3eff 3a 09 3f			ld a, (.dmark+2)  
3f02 32 6d ee			ld (debug_mark+2),a  
3f05 18 03			jr .pastdmark  
3f07 ..			.dmark: db "BL."  
3f0a f1			.pastdmark: pop af  
3f0b			endm  
# End of macro DMARK
3f0b						CALLMONITOR 
3f0b cd 6f ee			call debug_vector  
3f0e				endm  
# End of macro CALLMONITOR
3f0e					endif 
3f0e 3e 20				ld a, " " 
3f10 32 c1 e2				ld (scratch),a 
3f13 3e 00				ld a, 0 
3f15 32 c2 e2				ld (scratch+1),a 
3f18 21 c1 e2				ld hl, scratch 
3f1b cd d5 1b				call forth_push_str 
3f1e					 
3f1e				       NEXTW 
3f1e c3 14 1f			jp macro_next 
3f21				endm 
# End of macro NEXTW
3f21			 
3f21			;.blstr: db " ", 0 
3f21			 
3f21			.SPACES: 
3f21				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3f21 47				db WORD_SYS_CORE+51             
3f22 bc 3f			dw .SCROLL            
3f24 07				db 6 + 1 
3f25 .. 00			db "SPACES",0              
3f2c				endm 
# End of macro CWHEAD
3f2c			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
3f2c					if DEBUG_FORTH_WORDS_KEY 
3f2c						DMARK "SPS" 
3f2c f5				push af  
3f2d 3a 41 3f			ld a, (.dmark)  
3f30 32 6b ee			ld (debug_mark),a  
3f33 3a 42 3f			ld a, (.dmark+1)  
3f36 32 6c ee			ld (debug_mark+1),a  
3f39 3a 43 3f			ld a, (.dmark+2)  
3f3c 32 6d ee			ld (debug_mark+2),a  
3f3f 18 03			jr .pastdmark  
3f41 ..			.dmark: db "SPS"  
3f44 f1			.pastdmark: pop af  
3f45			endm  
# End of macro DMARK
3f45						CALLMONITOR 
3f45 cd 6f ee			call debug_vector  
3f48				endm  
# End of macro CALLMONITOR
3f48					endif 
3f48			 
3f48			 
3f48					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f48 cd 5e 1d			call macro_dsp_valuehl 
3f4b				endm 
# End of macro FORTH_DSP_VALUEHL
3f4b			 
3f4b e5					push hl    ; u 
3f4c					if DEBUG_FORTH_WORDS 
3f4c						DMARK "SPA" 
3f4c f5				push af  
3f4d 3a 61 3f			ld a, (.dmark)  
3f50 32 6b ee			ld (debug_mark),a  
3f53 3a 62 3f			ld a, (.dmark+1)  
3f56 32 6c ee			ld (debug_mark+1),a  
3f59 3a 63 3f			ld a, (.dmark+2)  
3f5c 32 6d ee			ld (debug_mark+2),a  
3f5f 18 03			jr .pastdmark  
3f61 ..			.dmark: db "SPA"  
3f64 f1			.pastdmark: pop af  
3f65			endm  
# End of macro DMARK
3f65						CALLMONITOR 
3f65 cd 6f ee			call debug_vector  
3f68				endm  
# End of macro CALLMONITOR
3f68					endif 
3f68			 
3f68					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f68 cd 16 1e			call macro_forth_dsp_pop 
3f6b				endm 
# End of macro FORTH_DSP_POP
3f6b e1					pop hl 
3f6c 0e 00				ld c, 0 
3f6e 45					ld b, l 
3f6f 21 c1 e2				ld hl, scratch  
3f72			 
3f72					if DEBUG_FORTH_WORDS 
3f72						DMARK "SP2" 
3f72 f5				push af  
3f73 3a 87 3f			ld a, (.dmark)  
3f76 32 6b ee			ld (debug_mark),a  
3f79 3a 88 3f			ld a, (.dmark+1)  
3f7c 32 6c ee			ld (debug_mark+1),a  
3f7f 3a 89 3f			ld a, (.dmark+2)  
3f82 32 6d ee			ld (debug_mark+2),a  
3f85 18 03			jr .pastdmark  
3f87 ..			.dmark: db "SP2"  
3f8a f1			.pastdmark: pop af  
3f8b			endm  
# End of macro DMARK
3f8b						CALLMONITOR 
3f8b cd 6f ee			call debug_vector  
3f8e				endm  
# End of macro CALLMONITOR
3f8e					endif 
3f8e 3e 20				ld a, ' ' 
3f90			.spaces1:	 
3f90 77					ld (hl),a 
3f91 23					inc hl 
3f92					 
3f92 10 fc				djnz .spaces1 
3f94 3e 00				ld a,0 
3f96 77					ld (hl),a 
3f97 21 c1 e2				ld hl, scratch 
3f9a					if DEBUG_FORTH_WORDS 
3f9a						DMARK "SP3" 
3f9a f5				push af  
3f9b 3a af 3f			ld a, (.dmark)  
3f9e 32 6b ee			ld (debug_mark),a  
3fa1 3a b0 3f			ld a, (.dmark+1)  
3fa4 32 6c ee			ld (debug_mark+1),a  
3fa7 3a b1 3f			ld a, (.dmark+2)  
3faa 32 6d ee			ld (debug_mark+2),a  
3fad 18 03			jr .pastdmark  
3faf ..			.dmark: db "SP3"  
3fb2 f1			.pastdmark: pop af  
3fb3			endm  
# End of macro DMARK
3fb3						CALLMONITOR 
3fb3 cd 6f ee			call debug_vector  
3fb6				endm  
# End of macro CALLMONITOR
3fb6					endif 
3fb6 cd d5 1b				call forth_push_str 
3fb9			 
3fb9				       NEXTW 
3fb9 c3 14 1f			jp macro_next 
3fbc				endm 
# End of macro NEXTW
3fbc			 
3fbc			 
3fbc			 
3fbc			.SCROLL: 
3fbc				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3fbc 53				db WORD_SYS_CORE+63             
3fbd e9 3f			dw .SCROLLD            
3fbf 07				db 6 + 1 
3fc0 .. 00			db "SCROLL",0              
3fc7				endm 
# End of macro CWHEAD
3fc7			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3fc7					if DEBUG_FORTH_WORDS_KEY 
3fc7						DMARK "SCR" 
3fc7 f5				push af  
3fc8 3a dc 3f			ld a, (.dmark)  
3fcb 32 6b ee			ld (debug_mark),a  
3fce 3a dd 3f			ld a, (.dmark+1)  
3fd1 32 6c ee			ld (debug_mark+1),a  
3fd4 3a de 3f			ld a, (.dmark+2)  
3fd7 32 6d ee			ld (debug_mark+2),a  
3fda 18 03			jr .pastdmark  
3fdc ..			.dmark: db "SCR"  
3fdf f1			.pastdmark: pop af  
3fe0			endm  
# End of macro DMARK
3fe0						CALLMONITOR 
3fe0 cd 6f ee			call debug_vector  
3fe3				endm  
# End of macro CALLMONITOR
3fe3					endif 
3fe3			 
3fe3 cd 7b 0b			call scroll_up 
3fe6			;	call update_display 
3fe6			 
3fe6					NEXTW 
3fe6 c3 14 1f			jp macro_next 
3fe9				endm 
# End of macro NEXTW
3fe9			 
3fe9			 
3fe9			 
3fe9			;		; get dir 
3fe9			; 
3fe9			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fe9			; 
3fe9			;		push hl 
3fe9			; 
3fe9			;		; destroy value TOS 
3fe9			; 
3fe9			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fe9			; 
3fe9			;		; get count 
3fe9			; 
3fe9			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fe9			; 
3fe9			;		push hl 
3fe9			; 
3fe9			;		; destroy value TOS 
3fe9			; 
3fe9			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fe9			; 
3fe9			;		; one value on hl get other one back 
3fe9			; 
3fe9			;		pop bc    ; count 
3fe9			; 
3fe9			;		pop de   ; dir 
3fe9			; 
3fe9			; 
3fe9			;		ld b, c 
3fe9			; 
3fe9			;.scrolldir:     push bc 
3fe9			;		push de 
3fe9			; 
3fe9			;		ld a, 0 
3fe9			;		cp e 
3fe9			;		jr z, .scrollup  
3fe9			;		call scroll_down 
3fe9			;		jr .scrollnext 
3fe9			;.scrollup:	call scroll_up 
3fe9			; 
3fe9			;		 
3fe9			;.scrollnext: 
3fe9			;		pop de 
3fe9			;		pop bc 
3fe9			;		djnz .scrolldir 
3fe9			; 
3fe9			; 
3fe9			; 
3fe9			; 
3fe9			; 
3fe9			;		NEXTW 
3fe9			 
3fe9			.SCROLLD: 
3fe9				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3fe9 53				db WORD_SYS_CORE+63             
3fea 17 40			dw .ATQ            
3fec 08				db 7 + 1 
3fed .. 00			db "SCROLLD",0              
3ff5				endm 
# End of macro CWHEAD
3ff5			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3ff5					if DEBUG_FORTH_WORDS_KEY 
3ff5						DMARK "SCD" 
3ff5 f5				push af  
3ff6 3a 0a 40			ld a, (.dmark)  
3ff9 32 6b ee			ld (debug_mark),a  
3ffc 3a 0b 40			ld a, (.dmark+1)  
3fff 32 6c ee			ld (debug_mark+1),a  
4002 3a 0c 40			ld a, (.dmark+2)  
4005 32 6d ee			ld (debug_mark+2),a  
4008 18 03			jr .pastdmark  
400a ..			.dmark: db "SCD"  
400d f1			.pastdmark: pop af  
400e			endm  
# End of macro DMARK
400e						CALLMONITOR 
400e cd 6f ee			call debug_vector  
4011				endm  
# End of macro CALLMONITOR
4011					endif 
4011			 
4011 cd 9f 0b			call scroll_down 
4014			;	call update_display 
4014			 
4014					NEXTW 
4014 c3 14 1f			jp macro_next 
4017				endm 
# End of macro NEXTW
4017			 
4017			 
4017			.ATQ: 
4017				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4017 62				db WORD_SYS_CORE+78             
4018 75 40			dw .AUTODSP            
401a 04				db 3 + 1 
401b .. 00			db "AT@",0              
401f				endm 
# End of macro CWHEAD
401f			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
401f					if DEBUG_FORTH_WORDS_KEY 
401f						DMARK "ATA" 
401f f5				push af  
4020 3a 34 40			ld a, (.dmark)  
4023 32 6b ee			ld (debug_mark),a  
4026 3a 35 40			ld a, (.dmark+1)  
4029 32 6c ee			ld (debug_mark+1),a  
402c 3a 36 40			ld a, (.dmark+2)  
402f 32 6d ee			ld (debug_mark+2),a  
4032 18 03			jr .pastdmark  
4034 ..			.dmark: db "ATA"  
4037 f1			.pastdmark: pop af  
4038			endm  
# End of macro DMARK
4038						CALLMONITOR 
4038 cd 6f ee			call debug_vector  
403b				endm  
# End of macro CALLMONITOR
403b					endif 
403b			 
403b			 
403b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
403b cd 5e 1d			call macro_dsp_valuehl 
403e				endm 
# End of macro FORTH_DSP_VALUEHL
403e			 
403e					; TODO save cursor row 
403e 7d					ld a,l 
403f fe 02				cp 2 
4041 20 04				jr nz, .crow3aq 
4043 3e 28				ld a, display_row_2 
4045 18 12				jr .ccol1aq 
4047 fe 03		.crow3aq:		cp 3 
4049 20 04				jr nz, .crow4aq 
404b 3e 50				ld a, display_row_3 
404d 18 0a				jr .ccol1aq 
404f fe 04		.crow4aq:		cp 4 
4051 20 04				jr nz, .crow1aq 
4053 3e 78				ld a, display_row_4 
4055 18 02				jr .ccol1aq 
4057 3e 00		.crow1aq:		ld a,display_row_1 
4059 f5			.ccol1aq:		push af			; got row offset 
405a 6f					ld l,a 
405b 26 00				ld h,0 
405d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
405d cd 16 1e			call macro_forth_dsp_pop 
4060				endm 
# End of macro FORTH_DSP_POP
4060					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4060 cd 5e 1d			call macro_dsp_valuehl 
4063				endm 
# End of macro FORTH_DSP_VALUEHL
4063					; TODO save cursor col 
4063 f1					pop af 
4064 85					add l		; add col offset 
4065			 
4065					; add current frame buffer address 
4065 2a cc eb				ld hl, (display_fb_active) 
4068 cd e6 0d				call addatohl 
406b			 
406b			 
406b			 
406b			 
406b					; get char frame buffer location offset in hl 
406b			 
406b 7e					ld a,(hl) 
406c 26 00				ld h, 0 
406e 6f					ld l, a 
406f			 
406f cd 67 1b				call forth_push_numhl 
4072			 
4072			 
4072					NEXTW 
4072 c3 14 1f			jp macro_next 
4075				endm 
# End of macro NEXTW
4075			 
4075			.AUTODSP: 
4075				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4075 63				db WORD_SYS_CORE+79             
4076 8b 40			dw .MENU            
4078 05				db 4 + 1 
4079 .. 00			db "ADSP",0              
407e				endm 
# End of macro CWHEAD
407e			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
407e			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
407e			 
407e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
407e cd 5e 1d			call macro_dsp_valuehl 
4081				endm 
# End of macro FORTH_DSP_VALUEHL
4081			 
4081			;		push hl 
4081			 
4081					; destroy value TOS 
4081			 
4081					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4081 cd 16 1e			call macro_forth_dsp_pop 
4084				endm 
# End of macro FORTH_DSP_POP
4084			 
4084			;		pop hl 
4084			 
4084 7d					ld a,l 
4085 32 3c ea				ld (cli_autodisplay), a 
4088				       NEXTW 
4088 c3 14 1f			jp macro_next 
408b				endm 
# End of macro NEXTW
408b			 
408b			.MENU: 
408b				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
408b 70				db WORD_SYS_CORE+92             
408c 34 41			dw .ENDDISPLAY            
408e 05				db 4 + 1 
408f .. 00			db "MENU",0              
4094				endm 
# End of macro CWHEAD
4094			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
4094			 
4094			;		; get number of items on the stack 
4094			; 
4094				 
4094					FORTH_DSP_VALUEHL 
4094 cd 5e 1d			call macro_dsp_valuehl 
4097				endm 
# End of macro FORTH_DSP_VALUEHL
4097				 
4097					if DEBUG_FORTH_WORDS_KEY 
4097						DMARK "MNU" 
4097 f5				push af  
4098 3a ac 40			ld a, (.dmark)  
409b 32 6b ee			ld (debug_mark),a  
409e 3a ad 40			ld a, (.dmark+1)  
40a1 32 6c ee			ld (debug_mark+1),a  
40a4 3a ae 40			ld a, (.dmark+2)  
40a7 32 6d ee			ld (debug_mark+2),a  
40aa 18 03			jr .pastdmark  
40ac ..			.dmark: db "MNU"  
40af f1			.pastdmark: pop af  
40b0			endm  
# End of macro DMARK
40b0						CALLMONITOR 
40b0 cd 6f ee			call debug_vector  
40b3				endm  
# End of macro CALLMONITOR
40b3					endif 
40b3			 
40b3 45					ld b, l	 
40b4 05					dec b 
40b5			 
40b5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40b5 cd 16 1e			call macro_forth_dsp_pop 
40b8				endm 
# End of macro FORTH_DSP_POP
40b8			 
40b8			 
40b8					; go directly through the stack to pluck out the string pointers and build an array 
40b8			 
40b8			;		FORTH_DSP 
40b8			 
40b8					; hl contains top most stack item 
40b8				 
40b8 11 c1 e2				ld de, scratch 
40bb			 
40bb			.mbuild: 
40bb			 
40bb					FORTH_DSP_VALUEHL 
40bb cd 5e 1d			call macro_dsp_valuehl 
40be				endm 
# End of macro FORTH_DSP_VALUEHL
40be			 
40be					if DEBUG_FORTH_WORDS 
40be						DMARK "MN3" 
40be f5				push af  
40bf 3a d3 40			ld a, (.dmark)  
40c2 32 6b ee			ld (debug_mark),a  
40c5 3a d4 40			ld a, (.dmark+1)  
40c8 32 6c ee			ld (debug_mark+1),a  
40cb 3a d5 40			ld a, (.dmark+2)  
40ce 32 6d ee			ld (debug_mark+2),a  
40d1 18 03			jr .pastdmark  
40d3 ..			.dmark: db "MN3"  
40d6 f1			.pastdmark: pop af  
40d7			endm  
# End of macro DMARK
40d7						CALLMONITOR 
40d7 cd 6f ee			call debug_vector  
40da				endm  
# End of macro CALLMONITOR
40da					endif 
40da eb					ex de, hl 
40db 73					ld (hl), e 
40dc 23					inc hl 
40dd 72					ld (hl), d 
40de 23					inc hl 
40df eb					ex de, hl 
40e0			 
40e0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40e0 cd 16 1e			call macro_forth_dsp_pop 
40e3				endm 
# End of macro FORTH_DSP_POP
40e3			 
40e3 10 d6				djnz .mbuild 
40e5			 
40e5					; done add term 
40e5			 
40e5 eb					ex de, hl 
40e6 36 00				ld (hl), 0 
40e8 23					inc hl 
40e9 36 00				ld (hl), 0 
40eb			 
40eb				 
40eb					 
40eb 21 c1 e2				ld hl, scratch 
40ee			 
40ee					if DEBUG_FORTH_WORDS 
40ee						DMARK "MNx" 
40ee f5				push af  
40ef 3a 03 41			ld a, (.dmark)  
40f2 32 6b ee			ld (debug_mark),a  
40f5 3a 04 41			ld a, (.dmark+1)  
40f8 32 6c ee			ld (debug_mark+1),a  
40fb 3a 05 41			ld a, (.dmark+2)  
40fe 32 6d ee			ld (debug_mark+2),a  
4101 18 03			jr .pastdmark  
4103 ..			.dmark: db "MNx"  
4106 f1			.pastdmark: pop af  
4107			endm  
# End of macro DMARK
4107						CALLMONITOR 
4107 cd 6f ee			call debug_vector  
410a				endm  
# End of macro CALLMONITOR
410a					endif 
410a			 
410a			 
410a			 
410a 3e 00				ld a, 0 
410c cd ea 0b				call menu 
410f			 
410f			 
410f 6f					ld l, a 
4110 26 00				ld h, 0 
4112			 
4112					if DEBUG_FORTH_WORDS 
4112						DMARK "MNr" 
4112 f5				push af  
4113 3a 27 41			ld a, (.dmark)  
4116 32 6b ee			ld (debug_mark),a  
4119 3a 28 41			ld a, (.dmark+1)  
411c 32 6c ee			ld (debug_mark+1),a  
411f 3a 29 41			ld a, (.dmark+2)  
4122 32 6d ee			ld (debug_mark+2),a  
4125 18 03			jr .pastdmark  
4127 ..			.dmark: db "MNr"  
412a f1			.pastdmark: pop af  
412b			endm  
# End of macro DMARK
412b						CALLMONITOR 
412b cd 6f ee			call debug_vector  
412e				endm  
# End of macro CALLMONITOR
412e					endif 
412e			 
412e cd 67 1b				call forth_push_numhl 
4131			 
4131			 
4131			 
4131			 
4131				       NEXTW 
4131 c3 14 1f			jp macro_next 
4134				endm 
# End of macro NEXTW
4134			 
4134			 
4134			.ENDDISPLAY: 
4134			 
4134			; eof 
# End of file forth_words_display.asm
4134			include "forth_words_str.asm" 
4134			 
4134			; | ## String Words 
4134			 
4134			.PTR:   
4134			 
4134				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4134 48				db WORD_SYS_CORE+52             
4135 61 41			dw .STYPE            
4137 04				db 3 + 1 
4138 .. 00			db "PTR",0              
413c				endm 
# End of macro CWHEAD
413c			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
413c			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
413c			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
413c			 
413c					if DEBUG_FORTH_WORDS_KEY 
413c						DMARK "PTR" 
413c f5				push af  
413d 3a 51 41			ld a, (.dmark)  
4140 32 6b ee			ld (debug_mark),a  
4143 3a 52 41			ld a, (.dmark+1)  
4146 32 6c ee			ld (debug_mark+1),a  
4149 3a 53 41			ld a, (.dmark+2)  
414c 32 6d ee			ld (debug_mark+2),a  
414f 18 03			jr .pastdmark  
4151 ..			.dmark: db "PTR"  
4154 f1			.pastdmark: pop af  
4155			endm  
# End of macro DMARK
4155						CALLMONITOR 
4155 cd 6f ee			call debug_vector  
4158				endm  
# End of macro CALLMONITOR
4158					endif 
4158					FORTH_DSP_VALUEHL 
4158 cd 5e 1d			call macro_dsp_valuehl 
415b				endm 
# End of macro FORTH_DSP_VALUEHL
415b cd 67 1b				call forth_push_numhl 
415e			 
415e			 
415e					NEXTW 
415e c3 14 1f			jp macro_next 
4161				endm 
# End of macro NEXTW
4161			.STYPE: 
4161				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4161 48				db WORD_SYS_CORE+52             
4162 b0 41			dw .UPPER            
4164 06				db 5 + 1 
4165 .. 00			db "STYPE",0              
416b				endm 
# End of macro CWHEAD
416b			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
416b					if DEBUG_FORTH_WORDS_KEY 
416b						DMARK "STY" 
416b f5				push af  
416c 3a 80 41			ld a, (.dmark)  
416f 32 6b ee			ld (debug_mark),a  
4172 3a 81 41			ld a, (.dmark+1)  
4175 32 6c ee			ld (debug_mark+1),a  
4178 3a 82 41			ld a, (.dmark+2)  
417b 32 6d ee			ld (debug_mark+2),a  
417e 18 03			jr .pastdmark  
4180 ..			.dmark: db "STY"  
4183 f1			.pastdmark: pop af  
4184			endm  
# End of macro DMARK
4184						CALLMONITOR 
4184 cd 6f ee			call debug_vector  
4187				endm  
# End of macro CALLMONITOR
4187					endif 
4187					FORTH_DSP 
4187 cd 24 1d			call macro_forth_dsp 
418a				endm 
# End of macro FORTH_DSP
418a					;v5 FORTH_DSP_VALUE 
418a			 
418a 7e					ld a, (hl) 
418b			 
418b f5					push af 
418c			 
418c			; Dont destroy TOS		FORTH_DSP_POP 
418c			 
418c f1					pop af 
418d			 
418d fe 01				cp DS_TYPE_STR 
418f 28 09				jr z, .typestr 
4191			 
4191 fe 02				cp DS_TYPE_INUM 
4193 28 0a				jr z, .typeinum 
4195			 
4195 21 ae 41				ld hl, .tna 
4198 18 0a				jr .tpush 
419a			 
419a 21 aa 41		.typestr:	ld hl, .tstr 
419d 18 05				jr .tpush 
419f 21 ac 41		.typeinum:	ld hl, .tinum 
41a2 18 00				jr .tpush 
41a4			 
41a4			.tpush: 
41a4			 
41a4 cd d5 1b				call forth_push_str 
41a7			 
41a7					NEXTW 
41a7 c3 14 1f			jp macro_next 
41aa				endm 
# End of macro NEXTW
41aa .. 00		.tstr:	db "s",0 
41ac .. 00		.tinum:  db "i",0 
41ae .. 00		.tna:   db "?", 0 
41b0			 
41b0			 
41b0			.UPPER: 
41b0				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
41b0 48				db WORD_SYS_CORE+52             
41b1 eb 41			dw .LOWER            
41b3 06				db 5 + 1 
41b4 .. 00			db "UPPER",0              
41ba				endm 
# End of macro CWHEAD
41ba			; | UPPER ( s -- s ) Upper case string s  | DONE 
41ba					if DEBUG_FORTH_WORDS_KEY 
41ba						DMARK "UPR" 
41ba f5				push af  
41bb 3a cf 41			ld a, (.dmark)  
41be 32 6b ee			ld (debug_mark),a  
41c1 3a d0 41			ld a, (.dmark+1)  
41c4 32 6c ee			ld (debug_mark+1),a  
41c7 3a d1 41			ld a, (.dmark+2)  
41ca 32 6d ee			ld (debug_mark+2),a  
41cd 18 03			jr .pastdmark  
41cf ..			.dmark: db "UPR"  
41d2 f1			.pastdmark: pop af  
41d3			endm  
# End of macro DMARK
41d3						CALLMONITOR 
41d3 cd 6f ee			call debug_vector  
41d6				endm  
# End of macro CALLMONITOR
41d6					endif 
41d6			 
41d6					FORTH_DSP 
41d6 cd 24 1d			call macro_forth_dsp 
41d9				endm 
# End of macro FORTH_DSP
41d9					 
41d9			; TODO check is string type 
41d9			 
41d9					FORTH_DSP_VALUEHL 
41d9 cd 5e 1d			call macro_dsp_valuehl 
41dc				endm 
# End of macro FORTH_DSP_VALUEHL
41dc			; get pointer to string in hl 
41dc			 
41dc 7e			.toup:		ld a, (hl) 
41dd fe 00				cp 0 
41df 28 07				jr z, .toupdone 
41e1			 
41e1 cd 68 10				call to_upper 
41e4			 
41e4 77					ld (hl), a 
41e5 23					inc hl 
41e6 18 f4				jr .toup 
41e8			 
41e8					 
41e8			 
41e8			 
41e8			; for each char convert to upper 
41e8					 
41e8			.toupdone: 
41e8			 
41e8			 
41e8					NEXTW 
41e8 c3 14 1f			jp macro_next 
41eb				endm 
# End of macro NEXTW
41eb			.LOWER: 
41eb				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
41eb 48				db WORD_SYS_CORE+52             
41ec 26 42			dw .TCASE            
41ee 06				db 5 + 1 
41ef .. 00			db "LOWER",0              
41f5				endm 
# End of macro CWHEAD
41f5			; | LOWER ( s -- s ) Lower case string s  | DONE 
41f5					if DEBUG_FORTH_WORDS_KEY 
41f5						DMARK "LWR" 
41f5 f5				push af  
41f6 3a 0a 42			ld a, (.dmark)  
41f9 32 6b ee			ld (debug_mark),a  
41fc 3a 0b 42			ld a, (.dmark+1)  
41ff 32 6c ee			ld (debug_mark+1),a  
4202 3a 0c 42			ld a, (.dmark+2)  
4205 32 6d ee			ld (debug_mark+2),a  
4208 18 03			jr .pastdmark  
420a ..			.dmark: db "LWR"  
420d f1			.pastdmark: pop af  
420e			endm  
# End of macro DMARK
420e						CALLMONITOR 
420e cd 6f ee			call debug_vector  
4211				endm  
# End of macro CALLMONITOR
4211					endif 
4211			 
4211					FORTH_DSP 
4211 cd 24 1d			call macro_forth_dsp 
4214				endm 
# End of macro FORTH_DSP
4214					 
4214			; TODO check is string type 
4214			 
4214					FORTH_DSP_VALUEHL 
4214 cd 5e 1d			call macro_dsp_valuehl 
4217				endm 
# End of macro FORTH_DSP_VALUEHL
4217			; get pointer to string in hl 
4217			 
4217 7e			.tolow:		ld a, (hl) 
4218 fe 00				cp 0 
421a 28 07				jr z, .tolowdone 
421c			 
421c cd 71 10				call to_lower 
421f			 
421f 77					ld (hl), a 
4220 23					inc hl 
4221 18 f4				jr .tolow 
4223			 
4223					 
4223			 
4223			 
4223			; for each char convert to low 
4223					 
4223			.tolowdone: 
4223					NEXTW 
4223 c3 14 1f			jp macro_next 
4226				endm 
# End of macro NEXTW
4226			.TCASE: 
4226				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4226 48				db WORD_SYS_CORE+52             
4227 5c 43			dw .SUBSTR            
4229 06				db 5 + 1 
422a .. 00			db "TCASE",0              
4230				endm 
# End of macro CWHEAD
4230			; | TCASE ( s -- s ) Title case string s  | DONE 
4230					if DEBUG_FORTH_WORDS_KEY 
4230						DMARK "TCS" 
4230 f5				push af  
4231 3a 45 42			ld a, (.dmark)  
4234 32 6b ee			ld (debug_mark),a  
4237 3a 46 42			ld a, (.dmark+1)  
423a 32 6c ee			ld (debug_mark+1),a  
423d 3a 47 42			ld a, (.dmark+2)  
4240 32 6d ee			ld (debug_mark+2),a  
4243 18 03			jr .pastdmark  
4245 ..			.dmark: db "TCS"  
4248 f1			.pastdmark: pop af  
4249			endm  
# End of macro DMARK
4249						CALLMONITOR 
4249 cd 6f ee			call debug_vector  
424c				endm  
# End of macro CALLMONITOR
424c					endif 
424c			 
424c					FORTH_DSP 
424c cd 24 1d			call macro_forth_dsp 
424f				endm 
# End of macro FORTH_DSP
424f					 
424f			; TODO check is string type 
424f			 
424f					FORTH_DSP_VALUEHL 
424f cd 5e 1d			call macro_dsp_valuehl 
4252				endm 
# End of macro FORTH_DSP_VALUEHL
4252			; get pointer to string in hl 
4252			 
4252					if DEBUG_FORTH_WORDS 
4252						DMARK "TC1" 
4252 f5				push af  
4253 3a 67 42			ld a, (.dmark)  
4256 32 6b ee			ld (debug_mark),a  
4259 3a 68 42			ld a, (.dmark+1)  
425c 32 6c ee			ld (debug_mark+1),a  
425f 3a 69 42			ld a, (.dmark+2)  
4262 32 6d ee			ld (debug_mark+2),a  
4265 18 03			jr .pastdmark  
4267 ..			.dmark: db "TC1"  
426a f1			.pastdmark: pop af  
426b			endm  
# End of macro DMARK
426b						CALLMONITOR 
426b cd 6f ee			call debug_vector  
426e				endm  
# End of macro CALLMONITOR
426e					endif 
426e			 
426e					; first time in turn to upper case first char 
426e			 
426e 7e					ld a, (hl) 
426f c3 f9 42				jp .totsiptou 
4272			 
4272			 
4272 7e			.tot:		ld a, (hl) 
4273 fe 00				cp 0 
4275 ca 3d 43				jp z, .totdone 
4278			 
4278					if DEBUG_FORTH_WORDS 
4278						DMARK "TC2" 
4278 f5				push af  
4279 3a 8d 42			ld a, (.dmark)  
427c 32 6b ee			ld (debug_mark),a  
427f 3a 8e 42			ld a, (.dmark+1)  
4282 32 6c ee			ld (debug_mark+1),a  
4285 3a 8f 42			ld a, (.dmark+2)  
4288 32 6d ee			ld (debug_mark+2),a  
428b 18 03			jr .pastdmark  
428d ..			.dmark: db "TC2"  
4290 f1			.pastdmark: pop af  
4291			endm  
# End of macro DMARK
4291						CALLMONITOR 
4291 cd 6f ee			call debug_vector  
4294				endm  
# End of macro CALLMONITOR
4294					endif 
4294					; check to see if current char is a space 
4294			 
4294 fe 20				cp ' ' 
4296 28 21				jr z, .totsp 
4298 cd 71 10				call to_lower 
429b					if DEBUG_FORTH_WORDS 
429b						DMARK "TC3" 
429b f5				push af  
429c 3a b0 42			ld a, (.dmark)  
429f 32 6b ee			ld (debug_mark),a  
42a2 3a b1 42			ld a, (.dmark+1)  
42a5 32 6c ee			ld (debug_mark+1),a  
42a8 3a b2 42			ld a, (.dmark+2)  
42ab 32 6d ee			ld (debug_mark+2),a  
42ae 18 03			jr .pastdmark  
42b0 ..			.dmark: db "TC3"  
42b3 f1			.pastdmark: pop af  
42b4			endm  
# End of macro DMARK
42b4						CALLMONITOR 
42b4 cd 6f ee			call debug_vector  
42b7				endm  
# End of macro CALLMONITOR
42b7					endif 
42b7 18 63				jr .totnxt 
42b9			 
42b9			.totsp:         ; on a space, find next char which should be upper 
42b9			 
42b9					if DEBUG_FORTH_WORDS 
42b9						DMARK "TC4" 
42b9 f5				push af  
42ba 3a ce 42			ld a, (.dmark)  
42bd 32 6b ee			ld (debug_mark),a  
42c0 3a cf 42			ld a, (.dmark+1)  
42c3 32 6c ee			ld (debug_mark+1),a  
42c6 3a d0 42			ld a, (.dmark+2)  
42c9 32 6d ee			ld (debug_mark+2),a  
42cc 18 03			jr .pastdmark  
42ce ..			.dmark: db "TC4"  
42d1 f1			.pastdmark: pop af  
42d2			endm  
# End of macro DMARK
42d2						CALLMONITOR 
42d2 cd 6f ee			call debug_vector  
42d5				endm  
# End of macro CALLMONITOR
42d5					endif 
42d5					;; 
42d5			 
42d5 fe 20				cp ' ' 
42d7 20 20				jr nz, .totsiptou 
42d9 23					inc hl 
42da 7e					ld a, (hl) 
42db					if DEBUG_FORTH_WORDS 
42db						DMARK "TC5" 
42db f5				push af  
42dc 3a f0 42			ld a, (.dmark)  
42df 32 6b ee			ld (debug_mark),a  
42e2 3a f1 42			ld a, (.dmark+1)  
42e5 32 6c ee			ld (debug_mark+1),a  
42e8 3a f2 42			ld a, (.dmark+2)  
42eb 32 6d ee			ld (debug_mark+2),a  
42ee 18 03			jr .pastdmark  
42f0 ..			.dmark: db "TC5"  
42f3 f1			.pastdmark: pop af  
42f4			endm  
# End of macro DMARK
42f4						CALLMONITOR 
42f4 cd 6f ee			call debug_vector  
42f7				endm  
# End of macro CALLMONITOR
42f7					endif 
42f7 18 c0				jr .totsp 
42f9 fe 00		.totsiptou:    cp 0 
42fb 28 40				jr z, .totdone 
42fd					; not space and not zero term so upper case it 
42fd cd 68 10				call to_upper 
4300			 
4300					if DEBUG_FORTH_WORDS 
4300						DMARK "TC6" 
4300 f5				push af  
4301 3a 15 43			ld a, (.dmark)  
4304 32 6b ee			ld (debug_mark),a  
4307 3a 16 43			ld a, (.dmark+1)  
430a 32 6c ee			ld (debug_mark+1),a  
430d 3a 17 43			ld a, (.dmark+2)  
4310 32 6d ee			ld (debug_mark+2),a  
4313 18 03			jr .pastdmark  
4315 ..			.dmark: db "TC6"  
4318 f1			.pastdmark: pop af  
4319			endm  
# End of macro DMARK
4319						CALLMONITOR 
4319 cd 6f ee			call debug_vector  
431c				endm  
# End of macro CALLMONITOR
431c					endif 
431c			 
431c			 
431c			.totnxt: 
431c			 
431c 77					ld (hl), a 
431d 23					inc hl 
431e					if DEBUG_FORTH_WORDS 
431e						DMARK "TC7" 
431e f5				push af  
431f 3a 33 43			ld a, (.dmark)  
4322 32 6b ee			ld (debug_mark),a  
4325 3a 34 43			ld a, (.dmark+1)  
4328 32 6c ee			ld (debug_mark+1),a  
432b 3a 35 43			ld a, (.dmark+2)  
432e 32 6d ee			ld (debug_mark+2),a  
4331 18 03			jr .pastdmark  
4333 ..			.dmark: db "TC7"  
4336 f1			.pastdmark: pop af  
4337			endm  
# End of macro DMARK
4337						CALLMONITOR 
4337 cd 6f ee			call debug_vector  
433a				endm  
# End of macro CALLMONITOR
433a					endif 
433a c3 72 42				jp .tot 
433d			 
433d					 
433d			 
433d			 
433d			; for each char convert to low 
433d					 
433d			.totdone: 
433d					if DEBUG_FORTH_WORDS 
433d						DMARK "TCd" 
433d f5				push af  
433e 3a 52 43			ld a, (.dmark)  
4341 32 6b ee			ld (debug_mark),a  
4344 3a 53 43			ld a, (.dmark+1)  
4347 32 6c ee			ld (debug_mark+1),a  
434a 3a 54 43			ld a, (.dmark+2)  
434d 32 6d ee			ld (debug_mark+2),a  
4350 18 03			jr .pastdmark  
4352 ..			.dmark: db "TCd"  
4355 f1			.pastdmark: pop af  
4356			endm  
# End of macro DMARK
4356						CALLMONITOR 
4356 cd 6f ee			call debug_vector  
4359				endm  
# End of macro CALLMONITOR
4359					endif 
4359					NEXTW 
4359 c3 14 1f			jp macro_next 
435c				endm 
# End of macro NEXTW
435c			 
435c			.SUBSTR: 
435c				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
435c 48				db WORD_SYS_CORE+52             
435d ba 43			dw .LEFT            
435f 07				db 6 + 1 
4360 .. 00			db "SUBSTR",0              
4367				endm 
# End of macro CWHEAD
4367			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4367			 
4367					if DEBUG_FORTH_WORDS_KEY 
4367						DMARK "SST" 
4367 f5				push af  
4368 3a 7c 43			ld a, (.dmark)  
436b 32 6b ee			ld (debug_mark),a  
436e 3a 7d 43			ld a, (.dmark+1)  
4371 32 6c ee			ld (debug_mark+1),a  
4374 3a 7e 43			ld a, (.dmark+2)  
4377 32 6d ee			ld (debug_mark+2),a  
437a 18 03			jr .pastdmark  
437c ..			.dmark: db "SST"  
437f f1			.pastdmark: pop af  
4380			endm  
# End of macro DMARK
4380						CALLMONITOR 
4380 cd 6f ee			call debug_vector  
4383				endm  
# End of macro CALLMONITOR
4383					endif 
4383			; TODO check string type 
4383					FORTH_DSP_VALUEHL 
4383 cd 5e 1d			call macro_dsp_valuehl 
4386				endm 
# End of macro FORTH_DSP_VALUEHL
4386			 
4386 e5					push hl      ; string length 
4387			 
4387					FORTH_DSP_POP 
4387 cd 16 1e			call macro_forth_dsp_pop 
438a				endm 
# End of macro FORTH_DSP_POP
438a			 
438a					FORTH_DSP_VALUEHL 
438a cd 5e 1d			call macro_dsp_valuehl 
438d				endm 
# End of macro FORTH_DSP_VALUEHL
438d			 
438d e5					push hl     ; start char 
438e			 
438e					FORTH_DSP_POP 
438e cd 16 1e			call macro_forth_dsp_pop 
4391				endm 
# End of macro FORTH_DSP_POP
4391			 
4391			 
4391					FORTH_DSP_VALUE 
4391 cd 47 1d			call macro_forth_dsp_value 
4394				endm 
# End of macro FORTH_DSP_VALUE
4394			 
4394 d1					pop de    ; get start post offset 
4395			 
4395 19					add hl, de    ; starting offset 
4396			 
4396 c1					pop bc 
4397 c5					push bc      ; grab size of string 
4398			 
4398 e5					push hl    ; save string start  
4399			 
4399 26 00				ld h, 0 
439b 69					ld l, c 
439c 23					inc hl 
439d 23					inc hl 
439e			 
439e cd ce 11				call malloc 
43a1				if DEBUG_FORTH_MALLOC_GUARD 
43a1 cc d4 4c				call z,malloc_error 
43a4				endif 
43a4			 
43a4 eb					ex de, hl      ; save malloc area for string copy 
43a5 e1					pop hl    ; get back source 
43a6 c1					pop bc    ; get length of string back 
43a7			 
43a7 d5					push de    ; save malloc area for after we push 
43a8 ed b0				ldir     ; copy substr 
43aa			 
43aa			 
43aa eb					ex de, hl 
43ab 3e 00				ld a, 0 
43ad 77					ld (hl), a   ; term substr 
43ae			 
43ae					 
43ae e1					pop hl    ; get malloc so we can push it 
43af e5					push hl   ; save so we can free it afterwards 
43b0			 
43b0 cd d5 1b				call forth_push_str 
43b3			 
43b3 e1					pop hl 
43b4 cd 98 12				call free 
43b7			 
43b7					 
43b7					 
43b7			 
43b7			 
43b7					NEXTW 
43b7 c3 14 1f			jp macro_next 
43ba				endm 
# End of macro NEXTW
43ba			 
43ba			.LEFT: 
43ba				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
43ba 48				db WORD_SYS_CORE+52             
43bb e2 43			dw .RIGHT            
43bd 05				db 4 + 1 
43be .. 00			db "LEFT",0              
43c3				endm 
# End of macro CWHEAD
43c3			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
43c3					if DEBUG_FORTH_WORDS_KEY 
43c3						DMARK "LEF" 
43c3 f5				push af  
43c4 3a d8 43			ld a, (.dmark)  
43c7 32 6b ee			ld (debug_mark),a  
43ca 3a d9 43			ld a, (.dmark+1)  
43cd 32 6c ee			ld (debug_mark+1),a  
43d0 3a da 43			ld a, (.dmark+2)  
43d3 32 6d ee			ld (debug_mark+2),a  
43d6 18 03			jr .pastdmark  
43d8 ..			.dmark: db "LEF"  
43db f1			.pastdmark: pop af  
43dc			endm  
# End of macro DMARK
43dc						CALLMONITOR 
43dc cd 6f ee			call debug_vector  
43df				endm  
# End of macro CALLMONITOR
43df					endif 
43df			 
43df					NEXTW 
43df c3 14 1f			jp macro_next 
43e2				endm 
# End of macro NEXTW
43e2			.RIGHT: 
43e2				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
43e2 48				db WORD_SYS_CORE+52             
43e3 0b 44			dw .STR2NUM            
43e5 06				db 5 + 1 
43e6 .. 00			db "RIGHT",0              
43ec				endm 
# End of macro CWHEAD
43ec			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
43ec					if DEBUG_FORTH_WORDS_KEY 
43ec						DMARK "RIG" 
43ec f5				push af  
43ed 3a 01 44			ld a, (.dmark)  
43f0 32 6b ee			ld (debug_mark),a  
43f3 3a 02 44			ld a, (.dmark+1)  
43f6 32 6c ee			ld (debug_mark+1),a  
43f9 3a 03 44			ld a, (.dmark+2)  
43fc 32 6d ee			ld (debug_mark+2),a  
43ff 18 03			jr .pastdmark  
4401 ..			.dmark: db "RIG"  
4404 f1			.pastdmark: pop af  
4405			endm  
# End of macro DMARK
4405						CALLMONITOR 
4405 cd 6f ee			call debug_vector  
4408				endm  
# End of macro CALLMONITOR
4408					endif 
4408			 
4408					NEXTW 
4408 c3 14 1f			jp macro_next 
440b				endm 
# End of macro NEXTW
440b			 
440b			 
440b			.STR2NUM: 
440b				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
440b 48				db WORD_SYS_CORE+52             
440c 97 44			dw .NUM2STR            
440e 08				db 7 + 1 
440f .. 00			db "STR2NUM",0              
4417				endm 
# End of macro CWHEAD
4417			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4417			 
4417			 
4417			; TODO STR type check to do 
4417					if DEBUG_FORTH_WORDS_KEY 
4417						DMARK "S2N" 
4417 f5				push af  
4418 3a 2c 44			ld a, (.dmark)  
441b 32 6b ee			ld (debug_mark),a  
441e 3a 2d 44			ld a, (.dmark+1)  
4421 32 6c ee			ld (debug_mark+1),a  
4424 3a 2e 44			ld a, (.dmark+2)  
4427 32 6d ee			ld (debug_mark+2),a  
442a 18 03			jr .pastdmark  
442c ..			.dmark: db "S2N"  
442f f1			.pastdmark: pop af  
4430			endm  
# End of macro DMARK
4430						CALLMONITOR 
4430 cd 6f ee			call debug_vector  
4433				endm  
# End of macro CALLMONITOR
4433					endif 
4433			 
4433					;FORTH_DSP 
4433					FORTH_DSP_VALUE 
4433 cd 47 1d			call macro_forth_dsp_value 
4436				endm 
# End of macro FORTH_DSP_VALUE
4436					;inc hl 
4436			 
4436 eb					ex de, hl 
4437					if DEBUG_FORTH_WORDS 
4437						DMARK "S2a" 
4437 f5				push af  
4438 3a 4c 44			ld a, (.dmark)  
443b 32 6b ee			ld (debug_mark),a  
443e 3a 4d 44			ld a, (.dmark+1)  
4441 32 6c ee			ld (debug_mark+1),a  
4444 3a 4e 44			ld a, (.dmark+2)  
4447 32 6d ee			ld (debug_mark+2),a  
444a 18 03			jr .pastdmark  
444c ..			.dmark: db "S2a"  
444f f1			.pastdmark: pop af  
4450			endm  
# End of macro DMARK
4450						CALLMONITOR 
4450 cd 6f ee			call debug_vector  
4453				endm  
# End of macro CALLMONITOR
4453					endif 
4453 cd f0 10				call string_to_uint16 
4456			 
4456					if DEBUG_FORTH_WORDS 
4456						DMARK "S2b" 
4456 f5				push af  
4457 3a 6b 44			ld a, (.dmark)  
445a 32 6b ee			ld (debug_mark),a  
445d 3a 6c 44			ld a, (.dmark+1)  
4460 32 6c ee			ld (debug_mark+1),a  
4463 3a 6d 44			ld a, (.dmark+2)  
4466 32 6d ee			ld (debug_mark+2),a  
4469 18 03			jr .pastdmark  
446b ..			.dmark: db "S2b"  
446e f1			.pastdmark: pop af  
446f			endm  
# End of macro DMARK
446f						CALLMONITOR 
446f cd 6f ee			call debug_vector  
4472				endm  
# End of macro CALLMONITOR
4472					endif 
4472			;		push hl 
4472					FORTH_DSP_POP 
4472 cd 16 1e			call macro_forth_dsp_pop 
4475				endm 
# End of macro FORTH_DSP_POP
4475			;		pop hl 
4475					 
4475					if DEBUG_FORTH_WORDS 
4475						DMARK "S2b" 
4475 f5				push af  
4476 3a 8a 44			ld a, (.dmark)  
4479 32 6b ee			ld (debug_mark),a  
447c 3a 8b 44			ld a, (.dmark+1)  
447f 32 6c ee			ld (debug_mark+1),a  
4482 3a 8c 44			ld a, (.dmark+2)  
4485 32 6d ee			ld (debug_mark+2),a  
4488 18 03			jr .pastdmark  
448a ..			.dmark: db "S2b"  
448d f1			.pastdmark: pop af  
448e			endm  
# End of macro DMARK
448e						CALLMONITOR 
448e cd 6f ee			call debug_vector  
4491				endm  
# End of macro CALLMONITOR
4491					endif 
4491 cd 67 1b				call forth_push_numhl	 
4494			 
4494				 
4494				       NEXTW 
4494 c3 14 1f			jp macro_next 
4497				endm 
# End of macro NEXTW
4497			.NUM2STR: 
4497				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4497 48				db WORD_SYS_CORE+52             
4498 a6 44			dw .CONCAT            
449a 08				db 7 + 1 
449b .. 00			db "NUM2STR",0              
44a3				endm 
# End of macro CWHEAD
44a3			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
44a3			 
44a3			;		; malloc a string to target 
44a3			;		ld hl, 10     ; TODO max string size should be fine 
44a3			;		call malloc 
44a3			;		push hl    ; save malloc location 
44a3			; 
44a3			; 
44a3			;; TODO check int type 
44a3			;		FORTH_DSP_VALUEHL 
44a3			;		ld a, l 
44a3			;		call DispAToASCII   
44a3			;;TODO need to chage above call to dump into string 
44a3			; 
44a3			; 
44a3			 
44a3				       NEXTW 
44a3 c3 14 1f			jp macro_next 
44a6				endm 
# End of macro NEXTW
44a6			 
44a6			.CONCAT: 
44a6				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
44a6 48				db WORD_SYS_CORE+52             
44a7 59 45			dw .FIND            
44a9 07				db 6 + 1 
44aa .. 00			db "CONCAT",0              
44b1				endm 
# End of macro CWHEAD
44b1			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
44b1			 
44b1			; TODO check string type 
44b1			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
44b1			 
44b1					if DEBUG_FORTH_WORDS_KEY 
44b1						DMARK "CON" 
44b1 f5				push af  
44b2 3a c6 44			ld a, (.dmark)  
44b5 32 6b ee			ld (debug_mark),a  
44b8 3a c7 44			ld a, (.dmark+1)  
44bb 32 6c ee			ld (debug_mark+1),a  
44be 3a c8 44			ld a, (.dmark+2)  
44c1 32 6d ee			ld (debug_mark+2),a  
44c4 18 03			jr .pastdmark  
44c6 ..			.dmark: db "CON"  
44c9 f1			.pastdmark: pop af  
44ca			endm  
# End of macro DMARK
44ca						CALLMONITOR 
44ca cd 6f ee			call debug_vector  
44cd				endm  
# End of macro CALLMONITOR
44cd					endif 
44cd			 
44cd			 
44cd					FORTH_DSP_VALUE 
44cd cd 47 1d			call macro_forth_dsp_value 
44d0				endm 
# End of macro FORTH_DSP_VALUE
44d0 e5					push hl   ; s2 
44d1			 
44d1					FORTH_DSP_POP 
44d1 cd 16 1e			call macro_forth_dsp_pop 
44d4				endm 
# End of macro FORTH_DSP_POP
44d4			 
44d4					FORTH_DSP_VALUE 
44d4 cd 47 1d			call macro_forth_dsp_value 
44d7				endm 
# End of macro FORTH_DSP_VALUE
44d7			 
44d7 e5					push hl   ; s1 
44d8			 
44d8					FORTH_DSP_POP 
44d8 cd 16 1e			call macro_forth_dsp_pop 
44db				endm 
# End of macro FORTH_DSP_POP
44db					 
44db			 
44db					; copy s1 
44db			 
44db				 
44db					; save ptr 
44db e1					pop hl  
44dc e5					push hl 
44dd 3e 00				ld a, 0 
44df cd 64 11				call strlent 
44e2					;inc hl    ; zer0 
44e2 06 00				ld b, 0 
44e4 4d					ld c, l 
44e5 e1					pop hl		 
44e6 11 c1 e2				ld de, scratch	 
44e9					if DEBUG_FORTH_WORDS 
44e9						DMARK "CO1" 
44e9 f5				push af  
44ea 3a fe 44			ld a, (.dmark)  
44ed 32 6b ee			ld (debug_mark),a  
44f0 3a ff 44			ld a, (.dmark+1)  
44f3 32 6c ee			ld (debug_mark+1),a  
44f6 3a 00 45			ld a, (.dmark+2)  
44f9 32 6d ee			ld (debug_mark+2),a  
44fc 18 03			jr .pastdmark  
44fe ..			.dmark: db "CO1"  
4501 f1			.pastdmark: pop af  
4502			endm  
# End of macro DMARK
4502						CALLMONITOR 
4502 cd 6f ee			call debug_vector  
4505				endm  
# End of macro CALLMONITOR
4505					endif 
4505 ed b0				ldir 
4507			 
4507 e1					pop hl 
4508 e5					push hl 
4509 d5					push de 
450a			 
450a			 
450a 3e 00				ld a, 0 
450c cd 64 11				call strlent 
450f 23					inc hl    ; zer0 
4510 23					inc hl 
4511 06 00				ld b, 0 
4513 4d					ld c, l 
4514 d1					pop de 
4515 e1					pop hl		 
4516					if DEBUG_FORTH_WORDS 
4516						DMARK "CO2" 
4516 f5				push af  
4517 3a 2b 45			ld a, (.dmark)  
451a 32 6b ee			ld (debug_mark),a  
451d 3a 2c 45			ld a, (.dmark+1)  
4520 32 6c ee			ld (debug_mark+1),a  
4523 3a 2d 45			ld a, (.dmark+2)  
4526 32 6d ee			ld (debug_mark+2),a  
4529 18 03			jr .pastdmark  
452b ..			.dmark: db "CO2"  
452e f1			.pastdmark: pop af  
452f			endm  
# End of macro DMARK
452f						CALLMONITOR 
452f cd 6f ee			call debug_vector  
4532				endm  
# End of macro CALLMONITOR
4532					endif 
4532 ed b0				ldir 
4534			 
4534			 
4534			 
4534 21 c1 e2				ld hl, scratch 
4537					if DEBUG_FORTH_WORDS 
4537						DMARK "CO5" 
4537 f5				push af  
4538 3a 4c 45			ld a, (.dmark)  
453b 32 6b ee			ld (debug_mark),a  
453e 3a 4d 45			ld a, (.dmark+1)  
4541 32 6c ee			ld (debug_mark+1),a  
4544 3a 4e 45			ld a, (.dmark+2)  
4547 32 6d ee			ld (debug_mark+2),a  
454a 18 03			jr .pastdmark  
454c ..			.dmark: db "CO5"  
454f f1			.pastdmark: pop af  
4550			endm  
# End of macro DMARK
4550						CALLMONITOR 
4550 cd 6f ee			call debug_vector  
4553				endm  
# End of macro CALLMONITOR
4553					endif 
4553			 
4553 cd d5 1b				call forth_push_str 
4556			 
4556			 
4556			 
4556			 
4556				       NEXTW 
4556 c3 14 1f			jp macro_next 
4559				endm 
# End of macro NEXTW
4559			 
4559			 
4559			.FIND: 
4559				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4559 4b				db WORD_SYS_CORE+55             
455a 17 46			dw .LEN            
455c 05				db 4 + 1 
455d .. 00			db "FIND",0              
4562				endm 
# End of macro CWHEAD
4562			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4562			 
4562					if DEBUG_FORTH_WORDS_KEY 
4562						DMARK "FND" 
4562 f5				push af  
4563 3a 77 45			ld a, (.dmark)  
4566 32 6b ee			ld (debug_mark),a  
4569 3a 78 45			ld a, (.dmark+1)  
456c 32 6c ee			ld (debug_mark+1),a  
456f 3a 79 45			ld a, (.dmark+2)  
4572 32 6d ee			ld (debug_mark+2),a  
4575 18 03			jr .pastdmark  
4577 ..			.dmark: db "FND"  
457a f1			.pastdmark: pop af  
457b			endm  
# End of macro DMARK
457b						CALLMONITOR 
457b cd 6f ee			call debug_vector  
457e				endm  
# End of macro CALLMONITOR
457e					endif 
457e			 
457e			; TODO check string type 
457e					FORTH_DSP_VALUE 
457e cd 47 1d			call macro_forth_dsp_value 
4581				endm 
# End of macro FORTH_DSP_VALUE
4581			 
4581 e5					push hl    
4582 7e					ld a,(hl)    ; char to find   
4583			; TODO change char to substr 
4583			 
4583 f5					push af 
4584					 
4584			 
4584			 
4584					if DEBUG_FORTH_WORDS 
4584						DMARK "FN1" 
4584 f5				push af  
4585 3a 99 45			ld a, (.dmark)  
4588 32 6b ee			ld (debug_mark),a  
458b 3a 9a 45			ld a, (.dmark+1)  
458e 32 6c ee			ld (debug_mark+1),a  
4591 3a 9b 45			ld a, (.dmark+2)  
4594 32 6d ee			ld (debug_mark+2),a  
4597 18 03			jr .pastdmark  
4599 ..			.dmark: db "FN1"  
459c f1			.pastdmark: pop af  
459d			endm  
# End of macro DMARK
459d						CALLMONITOR 
459d cd 6f ee			call debug_vector  
45a0				endm  
# End of macro CALLMONITOR
45a0					endif 
45a0			 
45a0					FORTH_DSP_POP 
45a0 cd 16 1e			call macro_forth_dsp_pop 
45a3				endm 
# End of macro FORTH_DSP_POP
45a3			 
45a3					; string to search 
45a3			 
45a3					FORTH_DSP_VALUE 
45a3 cd 47 1d			call macro_forth_dsp_value 
45a6				endm 
# End of macro FORTH_DSP_VALUE
45a6			 
45a6 d1					pop de  ; d is char to find  
45a7			 
45a7					if DEBUG_FORTH_WORDS 
45a7						DMARK "FN2" 
45a7 f5				push af  
45a8 3a bc 45			ld a, (.dmark)  
45ab 32 6b ee			ld (debug_mark),a  
45ae 3a bd 45			ld a, (.dmark+1)  
45b1 32 6c ee			ld (debug_mark+1),a  
45b4 3a be 45			ld a, (.dmark+2)  
45b7 32 6d ee			ld (debug_mark+2),a  
45ba 18 03			jr .pastdmark  
45bc ..			.dmark: db "FN2"  
45bf f1			.pastdmark: pop af  
45c0			endm  
# End of macro DMARK
45c0						CALLMONITOR 
45c0 cd 6f ee			call debug_vector  
45c3				endm  
# End of macro CALLMONITOR
45c3					endif 
45c3					 
45c3 01 00 00				ld bc, 0 
45c6 7e			.findchar:      ld a,(hl) 
45c7 fe 00				cp 0   		 
45c9 28 27				jr z, .finddone     
45cb ba					cp d 
45cc 28 20				jr z, .foundchar 
45ce 03					inc bc 
45cf 23					inc hl 
45d0					if DEBUG_FORTH_WORDS 
45d0						DMARK "FN3" 
45d0 f5				push af  
45d1 3a e5 45			ld a, (.dmark)  
45d4 32 6b ee			ld (debug_mark),a  
45d7 3a e6 45			ld a, (.dmark+1)  
45da 32 6c ee			ld (debug_mark+1),a  
45dd 3a e7 45			ld a, (.dmark+2)  
45e0 32 6d ee			ld (debug_mark+2),a  
45e3 18 03			jr .pastdmark  
45e5 ..			.dmark: db "FN3"  
45e8 f1			.pastdmark: pop af  
45e9			endm  
# End of macro DMARK
45e9						CALLMONITOR 
45e9 cd 6f ee			call debug_vector  
45ec				endm  
# End of macro CALLMONITOR
45ec					endif 
45ec 18 d8				jr .findchar 
45ee			 
45ee			 
45ee c5			.foundchar:	push bc 
45ef e1					pop hl 
45f0 18 03				jr .findexit 
45f2			 
45f2			 
45f2							 
45f2			 
45f2			.finddone:     ; got to end of string with no find 
45f2 21 00 00				ld hl, 0 
45f5			.findexit: 
45f5			 
45f5					if DEBUG_FORTH_WORDS 
45f5						DMARK "FNd" 
45f5 f5				push af  
45f6 3a 0a 46			ld a, (.dmark)  
45f9 32 6b ee			ld (debug_mark),a  
45fc 3a 0b 46			ld a, (.dmark+1)  
45ff 32 6c ee			ld (debug_mark+1),a  
4602 3a 0c 46			ld a, (.dmark+2)  
4605 32 6d ee			ld (debug_mark+2),a  
4608 18 03			jr .pastdmark  
460a ..			.dmark: db "FNd"  
460d f1			.pastdmark: pop af  
460e			endm  
# End of macro DMARK
460e						CALLMONITOR 
460e cd 6f ee			call debug_vector  
4611				endm  
# End of macro CALLMONITOR
4611					endif 
4611 cd 67 1b			call forth_push_numhl 
4614			 
4614				       NEXTW 
4614 c3 14 1f			jp macro_next 
4617				endm 
# End of macro NEXTW
4617			 
4617			.LEN: 
4617				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4617 4c				db WORD_SYS_CORE+56             
4618 81 46			dw .ASC            
461a 06				db 5 + 1 
461b .. 00			db "COUNT",0              
4621				endm 
# End of macro CWHEAD
4621			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4621			 
4621					if DEBUG_FORTH_WORDS_KEY 
4621						DMARK "CNT" 
4621 f5				push af  
4622 3a 36 46			ld a, (.dmark)  
4625 32 6b ee			ld (debug_mark),a  
4628 3a 37 46			ld a, (.dmark+1)  
462b 32 6c ee			ld (debug_mark+1),a  
462e 3a 38 46			ld a, (.dmark+2)  
4631 32 6d ee			ld (debug_mark+2),a  
4634 18 03			jr .pastdmark  
4636 ..			.dmark: db "CNT"  
4639 f1			.pastdmark: pop af  
463a			endm  
# End of macro DMARK
463a						CALLMONITOR 
463a cd 6f ee			call debug_vector  
463d				endm  
# End of macro CALLMONITOR
463d					endif 
463d			; TODO check string type 
463d					FORTH_DSP_VALUE 
463d cd 47 1d			call macro_forth_dsp_value 
4640				endm 
# End of macro FORTH_DSP_VALUE
4640			 
4640			 
4640					if DEBUG_FORTH_WORDS 
4640						DMARK "CN?" 
4640 f5				push af  
4641 3a 55 46			ld a, (.dmark)  
4644 32 6b ee			ld (debug_mark),a  
4647 3a 56 46			ld a, (.dmark+1)  
464a 32 6c ee			ld (debug_mark+1),a  
464d 3a 57 46			ld a, (.dmark+2)  
4650 32 6d ee			ld (debug_mark+2),a  
4653 18 03			jr .pastdmark  
4655 ..			.dmark: db "CN?"  
4658 f1			.pastdmark: pop af  
4659			endm  
# End of macro DMARK
4659						CALLMONITOR 
4659 cd 6f ee			call debug_vector  
465c				endm  
# End of macro CALLMONITOR
465c					endif 
465c cd 59 11				call strlenz 
465f					if DEBUG_FORTH_WORDS 
465f						DMARK "CNl" 
465f f5				push af  
4660 3a 74 46			ld a, (.dmark)  
4663 32 6b ee			ld (debug_mark),a  
4666 3a 75 46			ld a, (.dmark+1)  
4669 32 6c ee			ld (debug_mark+1),a  
466c 3a 76 46			ld a, (.dmark+2)  
466f 32 6d ee			ld (debug_mark+2),a  
4672 18 03			jr .pastdmark  
4674 ..			.dmark: db "CNl"  
4677 f1			.pastdmark: pop af  
4678			endm  
# End of macro DMARK
4678						CALLMONITOR 
4678 cd 6f ee			call debug_vector  
467b				endm  
# End of macro CALLMONITOR
467b					endif 
467b			 
467b cd 67 1b				call forth_push_numhl 
467e			 
467e			 
467e			 
467e				       NEXTW 
467e c3 14 1f			jp macro_next 
4681				endm 
# End of macro NEXTW
4681			.ASC: 
4681				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4681 4d				db WORD_SYS_CORE+57             
4682 ef 46			dw .CHR            
4684 04				db 3 + 1 
4685 .. 00			db "ASC",0              
4689				endm 
# End of macro CWHEAD
4689			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4689					if DEBUG_FORTH_WORDS_KEY 
4689						DMARK "ASC" 
4689 f5				push af  
468a 3a 9e 46			ld a, (.dmark)  
468d 32 6b ee			ld (debug_mark),a  
4690 3a 9f 46			ld a, (.dmark+1)  
4693 32 6c ee			ld (debug_mark+1),a  
4696 3a a0 46			ld a, (.dmark+2)  
4699 32 6d ee			ld (debug_mark+2),a  
469c 18 03			jr .pastdmark  
469e ..			.dmark: db "ASC"  
46a1 f1			.pastdmark: pop af  
46a2			endm  
# End of macro DMARK
46a2						CALLMONITOR 
46a2 cd 6f ee			call debug_vector  
46a5				endm  
# End of macro CALLMONITOR
46a5					endif 
46a5					FORTH_DSP_VALUE 
46a5 cd 47 1d			call macro_forth_dsp_value 
46a8				endm 
# End of macro FORTH_DSP_VALUE
46a8					;v5 FORTH_DSP_VALUE 
46a8			;		inc hl      ; now at start of numeric as string 
46a8			 
46a8 e5					push hl 
46a9			 
46a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46a9 cd 16 1e			call macro_forth_dsp_pop 
46ac				endm 
# End of macro FORTH_DSP_POP
46ac			 
46ac e1					pop hl 
46ad			 
46ad					if DEBUG_FORTH_WORDS 
46ad						DMARK "AS1" 
46ad f5				push af  
46ae 3a c2 46			ld a, (.dmark)  
46b1 32 6b ee			ld (debug_mark),a  
46b4 3a c3 46			ld a, (.dmark+1)  
46b7 32 6c ee			ld (debug_mark+1),a  
46ba 3a c4 46			ld a, (.dmark+2)  
46bd 32 6d ee			ld (debug_mark+2),a  
46c0 18 03			jr .pastdmark  
46c2 ..			.dmark: db "AS1"  
46c5 f1			.pastdmark: pop af  
46c6			endm  
# End of macro DMARK
46c6						CALLMONITOR 
46c6 cd 6f ee			call debug_vector  
46c9				endm  
# End of macro CALLMONITOR
46c9					endif 
46c9					; push the content of a onto the stack as a value 
46c9			 
46c9 7e					ld a,(hl)   ; get char 
46ca 26 00				ld h,0 
46cc 6f					ld l,a 
46cd					if DEBUG_FORTH_WORDS 
46cd						DMARK "AS2" 
46cd f5				push af  
46ce 3a e2 46			ld a, (.dmark)  
46d1 32 6b ee			ld (debug_mark),a  
46d4 3a e3 46			ld a, (.dmark+1)  
46d7 32 6c ee			ld (debug_mark+1),a  
46da 3a e4 46			ld a, (.dmark+2)  
46dd 32 6d ee			ld (debug_mark+2),a  
46e0 18 03			jr .pastdmark  
46e2 ..			.dmark: db "AS2"  
46e5 f1			.pastdmark: pop af  
46e6			endm  
# End of macro DMARK
46e6						CALLMONITOR 
46e6 cd 6f ee			call debug_vector  
46e9				endm  
# End of macro CALLMONITOR
46e9					endif 
46e9 cd 67 1b				call forth_push_numhl 
46ec			 
46ec				       NEXTW 
46ec c3 14 1f			jp macro_next 
46ef				endm 
# End of macro NEXTW
46ef			 
46ef			.CHR: 
46ef				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
46ef 4d				db WORD_SYS_CORE+57             
46f0 2b 47			dw .ENDSTR            
46f2 04				db 3 + 1 
46f3 .. 00			db "CHR",0              
46f7				endm 
# End of macro CWHEAD
46f7			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
46f7					if DEBUG_FORTH_WORDS_KEY 
46f7						DMARK "CHR" 
46f7 f5				push af  
46f8 3a 0c 47			ld a, (.dmark)  
46fb 32 6b ee			ld (debug_mark),a  
46fe 3a 0d 47			ld a, (.dmark+1)  
4701 32 6c ee			ld (debug_mark+1),a  
4704 3a 0e 47			ld a, (.dmark+2)  
4707 32 6d ee			ld (debug_mark+2),a  
470a 18 03			jr .pastdmark  
470c ..			.dmark: db "CHR"  
470f f1			.pastdmark: pop af  
4710			endm  
# End of macro DMARK
4710						CALLMONITOR 
4710 cd 6f ee			call debug_vector  
4713				endm  
# End of macro CALLMONITOR
4713					endif 
4713					FORTH_DSP_VALUEHL 
4713 cd 5e 1d			call macro_dsp_valuehl 
4716				endm 
# End of macro FORTH_DSP_VALUEHL
4716			 
4716					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4716 cd 16 1e			call macro_forth_dsp_pop 
4719				endm 
# End of macro FORTH_DSP_POP
4719			 
4719					; save asci byte as a zero term string and push string 
4719			 
4719 7d					ld a,l 
471a 32 c1 e2				ld (scratch), a 
471d			 
471d 3e 00				ld a, 0 
471f 32 c2 e2				ld (scratch+1), a 
4722			 
4722 21 c1 e2				ld hl, scratch 
4725 cd d5 1b				call forth_push_str 
4728			 
4728			 
4728				       NEXTW 
4728 c3 14 1f			jp macro_next 
472b				endm 
# End of macro NEXTW
472b			 
472b			 
472b			 
472b			 
472b			.ENDSTR: 
472b			; eof 
472b			 
# End of file forth_words_str.asm
472b			include "forth_words_key.asm" 
472b			 
472b			; | ## Keyboard Words 
472b			 
472b			.KEY: 
472b				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
472b 3e				db WORD_SYS_CORE+42             
472c 5b 47			dw .WAITK            
472e 04				db 3 + 1 
472f .. 00			db "KEY",0              
4733				endm 
# End of macro CWHEAD
4733			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4733			 
4733					if DEBUG_FORTH_WORDS_KEY 
4733						DMARK "KEY" 
4733 f5				push af  
4734 3a 48 47			ld a, (.dmark)  
4737 32 6b ee			ld (debug_mark),a  
473a 3a 49 47			ld a, (.dmark+1)  
473d 32 6c ee			ld (debug_mark+1),a  
4740 3a 4a 47			ld a, (.dmark+2)  
4743 32 6d ee			ld (debug_mark+2),a  
4746 18 03			jr .pastdmark  
4748 ..			.dmark: db "KEY"  
474b f1			.pastdmark: pop af  
474c			endm  
# End of macro DMARK
474c						CALLMONITOR 
474c cd 6f ee			call debug_vector  
474f				endm  
# End of macro CALLMONITOR
474f					endif 
474f			; TODO currently waits 
474f cd 43 65				call cin 
4752					;call cin_wait 
4752 6f					ld l, a 
4753 26 00				ld h, 0 
4755 cd 67 1b				call forth_push_numhl 
4758					NEXTW 
4758 c3 14 1f			jp macro_next 
475b				endm 
# End of macro NEXTW
475b			.WAITK: 
475b				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
475b 3f				db WORD_SYS_CORE+43             
475c 8d 47			dw .ACCEPT            
475e 06				db 5 + 1 
475f .. 00			db "WAITK",0              
4765				endm 
# End of macro CWHEAD
4765			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4765					if DEBUG_FORTH_WORDS_KEY 
4765						DMARK "WAI" 
4765 f5				push af  
4766 3a 7a 47			ld a, (.dmark)  
4769 32 6b ee			ld (debug_mark),a  
476c 3a 7b 47			ld a, (.dmark+1)  
476f 32 6c ee			ld (debug_mark+1),a  
4772 3a 7c 47			ld a, (.dmark+2)  
4775 32 6d ee			ld (debug_mark+2),a  
4778 18 03			jr .pastdmark  
477a ..			.dmark: db "WAI"  
477d f1			.pastdmark: pop af  
477e			endm  
# End of macro DMARK
477e						CALLMONITOR 
477e cd 6f ee			call debug_vector  
4781				endm  
# End of macro CALLMONITOR
4781					endif 
4781 cd 3b 65				call cin_wait 
4784 6f					ld l, a 
4785 26 00				ld h, 0 
4787 cd 67 1b				call forth_push_numhl 
478a					NEXTW 
478a c3 14 1f			jp macro_next 
478d				endm 
# End of macro NEXTW
478d			.ACCEPT: 
478d				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
478d 40				db WORD_SYS_CORE+44             
478e eb 47			dw .EDIT            
4790 07				db 6 + 1 
4791 .. 00			db "ACCEPT",0              
4798				endm 
# End of macro CWHEAD
4798			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4798					; TODO crashes on push 
4798					if DEBUG_FORTH_WORDS_KEY 
4798						DMARK "ACC" 
4798 f5				push af  
4799 3a ad 47			ld a, (.dmark)  
479c 32 6b ee			ld (debug_mark),a  
479f 3a ae 47			ld a, (.dmark+1)  
47a2 32 6c ee			ld (debug_mark+1),a  
47a5 3a af 47			ld a, (.dmark+2)  
47a8 32 6d ee			ld (debug_mark+2),a  
47ab 18 03			jr .pastdmark  
47ad ..			.dmark: db "ACC"  
47b0 f1			.pastdmark: pop af  
47b1			endm  
# End of macro DMARK
47b1						CALLMONITOR 
47b1 cd 6f ee			call debug_vector  
47b4				endm  
# End of macro CALLMONITOR
47b4					endif 
47b4 21 bf e4				ld hl, os_input 
47b7 3e 00				ld a, 0 
47b9 77					ld (hl),a 
47ba 3a 5e ea				ld a,(f_cursor_ptr) 
47bd 16 64				ld d, 100 
47bf 0e 00				ld c, 0 
47c1 1e 28				ld e, 40 
47c3 cd 13 0e				call input_str 
47c6					; TODO perhaps do a type check and wrap in quotes if not a number 
47c6 21 bf e4				ld hl, os_input 
47c9					if DEBUG_FORTH_WORDS 
47c9						DMARK "AC1" 
47c9 f5				push af  
47ca 3a de 47			ld a, (.dmark)  
47cd 32 6b ee			ld (debug_mark),a  
47d0 3a df 47			ld a, (.dmark+1)  
47d3 32 6c ee			ld (debug_mark+1),a  
47d6 3a e0 47			ld a, (.dmark+2)  
47d9 32 6d ee			ld (debug_mark+2),a  
47dc 18 03			jr .pastdmark  
47de ..			.dmark: db "AC1"  
47e1 f1			.pastdmark: pop af  
47e2			endm  
# End of macro DMARK
47e2						CALLMONITOR 
47e2 cd 6f ee			call debug_vector  
47e5				endm  
# End of macro CALLMONITOR
47e5					endif 
47e5 cd d5 1b				call forth_push_str 
47e8					NEXTW 
47e8 c3 14 1f			jp macro_next 
47eb				endm 
# End of macro NEXTW
47eb			 
47eb			.EDIT: 
47eb				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
47eb 40				db WORD_SYS_CORE+44             
47ec 8d 48			dw .DEDIT            
47ee 05				db 4 + 1 
47ef .. 00			db "EDIT",0              
47f4				endm 
# End of macro CWHEAD
47f4			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
47f4			 
47f4					; TODO does not copy from stack 
47f4					if DEBUG_FORTH_WORDS_KEY 
47f4						DMARK "EDT" 
47f4 f5				push af  
47f5 3a 09 48			ld a, (.dmark)  
47f8 32 6b ee			ld (debug_mark),a  
47fb 3a 0a 48			ld a, (.dmark+1)  
47fe 32 6c ee			ld (debug_mark+1),a  
4801 3a 0b 48			ld a, (.dmark+2)  
4804 32 6d ee			ld (debug_mark+2),a  
4807 18 03			jr .pastdmark  
4809 ..			.dmark: db "EDT"  
480c f1			.pastdmark: pop af  
480d			endm  
# End of macro DMARK
480d						CALLMONITOR 
480d cd 6f ee			call debug_vector  
4810				endm  
# End of macro CALLMONITOR
4810					endif 
4810			 
4810					;FORTH_DSP 
4810					FORTH_DSP_VALUEHL 
4810 cd 5e 1d			call macro_dsp_valuehl 
4813				endm 
# End of macro FORTH_DSP_VALUEHL
4813			;		inc hl    ; TODO do type check 
4813			 
4813			;		call get_word_hl 
4813 e5					push hl 
4814					if DEBUG_FORTH_WORDS 
4814						DMARK "EDp" 
4814 f5				push af  
4815 3a 29 48			ld a, (.dmark)  
4818 32 6b ee			ld (debug_mark),a  
481b 3a 2a 48			ld a, (.dmark+1)  
481e 32 6c ee			ld (debug_mark+1),a  
4821 3a 2b 48			ld a, (.dmark+2)  
4824 32 6d ee			ld (debug_mark+2),a  
4827 18 03			jr .pastdmark  
4829 ..			.dmark: db "EDp"  
482c f1			.pastdmark: pop af  
482d			endm  
# End of macro DMARK
482d						CALLMONITOR 
482d cd 6f ee			call debug_vector  
4830				endm  
# End of macro CALLMONITOR
4830					endif 
4830				;	ld a, 0 
4830 cd 59 11				call strlenz 
4833 23					inc hl 
4834			 
4834 06 00				ld b, 0 
4836 4d					ld c, l 
4837			 
4837 e1					pop hl 
4838 11 bf e4				ld de, os_input 
483b					if DEBUG_FORTH_WORDS_KEY 
483b						DMARK "EDc" 
483b f5				push af  
483c 3a 50 48			ld a, (.dmark)  
483f 32 6b ee			ld (debug_mark),a  
4842 3a 51 48			ld a, (.dmark+1)  
4845 32 6c ee			ld (debug_mark+1),a  
4848 3a 52 48			ld a, (.dmark+2)  
484b 32 6d ee			ld (debug_mark+2),a  
484e 18 03			jr .pastdmark  
4850 ..			.dmark: db "EDc"  
4853 f1			.pastdmark: pop af  
4854			endm  
# End of macro DMARK
4854						CALLMONITOR 
4854 cd 6f ee			call debug_vector  
4857				endm  
# End of macro CALLMONITOR
4857					endif 
4857 ed b0				ldir 
4859			 
4859			 
4859 21 bf e4				ld hl, os_input 
485c					;ld a, 0 
485c					;ld (hl),a 
485c 3a 5e ea				ld a,(f_cursor_ptr) 
485f 16 64				ld d, 100 
4861 0e 00				ld c, 0 
4863 1e 28				ld e, 40 
4865 cd 13 0e				call input_str 
4868					; TODO perhaps do a type check and wrap in quotes if not a number 
4868 21 bf e4				ld hl, os_input 
486b					if DEBUG_FORTH_WORDS 
486b						DMARK "ED1" 
486b f5				push af  
486c 3a 80 48			ld a, (.dmark)  
486f 32 6b ee			ld (debug_mark),a  
4872 3a 81 48			ld a, (.dmark+1)  
4875 32 6c ee			ld (debug_mark+1),a  
4878 3a 82 48			ld a, (.dmark+2)  
487b 32 6d ee			ld (debug_mark+2),a  
487e 18 03			jr .pastdmark  
4880 ..			.dmark: db "ED1"  
4883 f1			.pastdmark: pop af  
4884			endm  
# End of macro DMARK
4884						CALLMONITOR 
4884 cd 6f ee			call debug_vector  
4887				endm  
# End of macro CALLMONITOR
4887					endif 
4887 cd d5 1b				call forth_push_str 
488a					NEXTW 
488a c3 14 1f			jp macro_next 
488d				endm 
# End of macro NEXTW
488d			 
488d			.DEDIT: 
488d				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
488d 40				db WORD_SYS_CORE+44             
488e ef 48			dw .ENDKEY            
4890 06				db 5 + 1 
4891 .. 00			db "DEDIT",0              
4897				endm 
# End of macro CWHEAD
4897			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4897			 
4897					; TODO does not copy from stack 
4897					if DEBUG_FORTH_WORDS_KEY 
4897						DMARK "DED" 
4897 f5				push af  
4898 3a ac 48			ld a, (.dmark)  
489b 32 6b ee			ld (debug_mark),a  
489e 3a ad 48			ld a, (.dmark+1)  
48a1 32 6c ee			ld (debug_mark+1),a  
48a4 3a ae 48			ld a, (.dmark+2)  
48a7 32 6d ee			ld (debug_mark+2),a  
48aa 18 03			jr .pastdmark  
48ac ..			.dmark: db "DED"  
48af f1			.pastdmark: pop af  
48b0			endm  
# End of macro DMARK
48b0						CALLMONITOR 
48b0 cd 6f ee			call debug_vector  
48b3				endm  
# End of macro CALLMONITOR
48b3					endif 
48b3			 
48b3					;FORTH_DSP 
48b3					FORTH_DSP_VALUEHL 
48b3 cd 5e 1d			call macro_dsp_valuehl 
48b6				endm 
# End of macro FORTH_DSP_VALUEHL
48b6			;		inc hl    ; TODO do type check 
48b6			 
48b6			;		call get_word_hl 
48b6 e5					push hl 
48b7 e5					push hl 
48b8					FORTH_DSP_POP 
48b8 cd 16 1e			call macro_forth_dsp_pop 
48bb				endm 
# End of macro FORTH_DSP_POP
48bb e1					pop hl 
48bc					if DEBUG_FORTH_WORDS 
48bc						DMARK "EDp" 
48bc f5				push af  
48bd 3a d1 48			ld a, (.dmark)  
48c0 32 6b ee			ld (debug_mark),a  
48c3 3a d2 48			ld a, (.dmark+1)  
48c6 32 6c ee			ld (debug_mark+1),a  
48c9 3a d3 48			ld a, (.dmark+2)  
48cc 32 6d ee			ld (debug_mark+2),a  
48cf 18 03			jr .pastdmark  
48d1 ..			.dmark: db "EDp"  
48d4 f1			.pastdmark: pop af  
48d5			endm  
# End of macro DMARK
48d5						CALLMONITOR 
48d5 cd 6f ee			call debug_vector  
48d8				endm  
# End of macro CALLMONITOR
48d8					endif 
48d8				;	ld a, 0 
48d8 cd 59 11				call strlenz 
48db 23					inc hl 
48dc			 
48dc 06 00				ld b, 0 
48de 4d					ld c, l 
48df			 
48df e1					pop hl 
48e0			 
48e0					;ld a, 0 
48e0					;ld (hl),a 
48e0 3a 5e ea				ld a,(f_cursor_ptr) 
48e3 16 64				ld d, 100 
48e5 0e 00				ld c, 0 
48e7 1e 28				ld e, 40 
48e9 cd 13 0e				call input_str 
48ec					; TODO perhaps do a type check and wrap in quotes if not a number 
48ec					NEXTW 
48ec c3 14 1f			jp macro_next 
48ef				endm 
# End of macro NEXTW
48ef			 
48ef			 
48ef			.ENDKEY: 
48ef			; eof 
48ef			 
# End of file forth_words_key.asm
48ef			include "forth_words_const.asm" 
48ef			 
48ef			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
48ef			 
48ef			 
48ef			.SPITIME: 
48ef				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
48ef 77				db WORD_SYS_CORE+99             
48f0 04 49			dw .VA            
48f2 08				db 7 + 1 
48f3 .. 00			db "SPITIME",0              
48fb				endm 
# End of macro CWHEAD
48fb			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
48fb			; 
48fb			; | | If using BANK devices then leave as is. 
48fb			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
48fb			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
48fb			 
48fb 21 64 ea				ld hl, spi_clktime  
48fe cd 67 1b				call forth_push_numhl 
4901			 
4901					NEXTW 
4901 c3 14 1f			jp macro_next 
4904				endm 
# End of macro NEXTW
4904			 
4904			 
4904			.VA: 
4904				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4904 77				db WORD_SYS_CORE+99             
4905 14 49			dw .SYMBOL            
4907 03				db 2 + 1 
4908 .. 00			db "VA",0              
490b				endm 
# End of macro CWHEAD
490b			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
490b 21 28 ea				ld hl, cli_var_array 
490e cd 67 1b				call forth_push_numhl 
4911			 
4911					NEXTW 
4911 c3 14 1f			jp macro_next 
4914				endm 
# End of macro NEXTW
4914			 
4914			.SYMBOL: 
4914				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4914 77				db WORD_SYS_CORE+99             
4915 1e 4a			dw .ENDCONST            
4917 07				db 6 + 1 
4918 .. 00			db "SYMBOL",0              
491f				endm 
# End of macro CWHEAD
491f			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
491f			; | 
491f			; | | The value is the number reference and the final address is pushed to stack 
491f			 
491f			; | | ``` 
491f			; | | dw sym_table 
491f			; | | dw nmi_vector 
491f			; | | dw cli_autodisplay 
491f			; | | dw cli_data_sp 
491f			; | | dw cli_data_stack 
491f			; | | dw cli_loop_sp 
491f			; | | dw cli_loop_stack 
491f			; | | dw cli_var_array 
491f			; | | dw cursor_col 
491f			; | | dw cursor_ptr 
491f			; | | ; 10 
491f			; | | dw cursor_row 
491f			; | | dw debug_mark 
491f			; | | dw display_fb0 
491f			; | | dw display_fb1 
491f			; | | dw display_fb2 
491f			; | | dw display_fb3 
491f			; | | dw display_fb_active 
491f			; | | dw execscratch 
491f			; | | dw f_cursor_ptr 
491f			; | | dw hardware_word 
491f			; | | ;20 
491f			; | | dw input_at_cursor 
491f			; | | dw input_at_pos 
491f			; | | dw input_cur_flash 
491f			; | | dw input_cur_onoff 
491f			; | | dw input_cursor 
491f			; | | dw input_display_size 
491f			; | | dw input_len 
491f			; | | dw input_ptr 
491f			; | | dw input_size 
491f			; | | dw input_start 
491f			; | | ; 30 
491f			; | | dw input_str 
491f			; | | dw input_under_cursor 
491f			; | | dw os_cli_cmd 
491f			; | | dw os_cur_ptr 
491f			; | | dw os_current_i 
491f			; | | dw os_input 
491f			; | | dw os_last_cmd 
491f			; | | dw os_last_new_uword 
491f			; | | dw debug_vector 
491f			; | | dw os_view_hl 
491f			; | | ;40 
491f			; | | dw os_word_scratch 
491f			; | | dw portbctl 
491f			; | | dw portbdata 
491f			; | | dw spi_cartdev 
491f			; | | dw spi_cartdev2 
491f			; | | dw spi_clktime 
491f			; | | dw spi_device 
491f			; | | dw spi_device_id 
491f			; | | dw spi_portbyte 
491f			; | | dw stackstore 
491f			; | | ; 50 
491f			; | | if STORAGE_SE 
491f			; | | dw storage_actl 
491f			; | | dw storage_adata 
491f			; | | else 
491f			; | | dw 0 
491f			; | | dw 0 
491f			; | | endif 
491f			; | | dw storage_append 
491f			; | | if STORAGE_SE 
491f			; | | dw storage_bctl 
491f			; | | else 
491f			; | | dw 0 
491f			; | | endif 
491f			; | | dw store_bank_active 
491f			; | | dw store_filecache 
491f			; | | dw store_longread 
491f			; | | dw store_openaddr 
491f			; | | dw store_openext 
491f			; | | dw store_openmaxext 
491f			; | | ; 60 
491f			; | | dw store_page 
491f			; | | dw store_readbuf 
491f			; | | dw store_readcont 
491f			; | | dw store_readptr 
491f			; | | dw store_tmpext 
491f			; | | dw store_tmpid 
491f			; | | dw store_tmppageid 
491f			; | | dw malloc 
491f			; | | dw free 
491f			; | | dw cin 
491f			; | | ; 70 
491f			; | | dw cin_wait 
491f			; | | dw forth_push_numhl 
491f			; | | dw forth_push_str 
491f			; | | ``` 
491f			 
491f					if DEBUG_FORTH_WORDS_KEY 
491f						DMARK "SYM" 
491f f5				push af  
4920 3a 34 49			ld a, (.dmark)  
4923 32 6b ee			ld (debug_mark),a  
4926 3a 35 49			ld a, (.dmark+1)  
4929 32 6c ee			ld (debug_mark+1),a  
492c 3a 36 49			ld a, (.dmark+2)  
492f 32 6d ee			ld (debug_mark+2),a  
4932 18 03			jr .pastdmark  
4934 ..			.dmark: db "SYM"  
4937 f1			.pastdmark: pop af  
4938			endm  
# End of macro DMARK
4938						CALLMONITOR 
4938 cd 6f ee			call debug_vector  
493b				endm  
# End of macro CALLMONITOR
493b					endif 
493b			 
493b					FORTH_DSP_VALUEHL 
493b cd 5e 1d			call macro_dsp_valuehl 
493e				endm 
# End of macro FORTH_DSP_VALUEHL
493e			 
493e 7d					ld a, l     
493f			 
493f			 
493f					if DEBUG_FORTH_WORDS 
493f						DMARK "SY1" 
493f f5				push af  
4940 3a 54 49			ld a, (.dmark)  
4943 32 6b ee			ld (debug_mark),a  
4946 3a 55 49			ld a, (.dmark+1)  
4949 32 6c ee			ld (debug_mark+1),a  
494c 3a 56 49			ld a, (.dmark+2)  
494f 32 6d ee			ld (debug_mark+2),a  
4952 18 03			jr .pastdmark  
4954 ..			.dmark: db "SY1"  
4957 f1			.pastdmark: pop af  
4958			endm  
# End of macro DMARK
4958						CALLMONITOR 
4958 cd 6f ee			call debug_vector  
495b				endm  
# End of macro CALLMONITOR
495b					endif 
495b					 
495b f5					push af	 
495c					FORTH_DSP_POP 
495c cd 16 1e			call macro_forth_dsp_pop 
495f				endm 
# End of macro FORTH_DSP_POP
495f f1					pop af 
4960			 
4960 cb 27				sla a  
4962				 
4962					 
4962					if DEBUG_FORTH_WORDS 
4962						DMARK "SY" 
4962 f5				push af  
4963 3a 77 49			ld a, (.dmark)  
4966 32 6b ee			ld (debug_mark),a  
4969 3a 78 49			ld a, (.dmark+1)  
496c 32 6c ee			ld (debug_mark+1),a  
496f 3a 79 49			ld a, (.dmark+2)  
4972 32 6d ee			ld (debug_mark+2),a  
4975 18 02			jr .pastdmark  
4977 ..			.dmark: db "SY"  
4979 f1			.pastdmark: pop af  
497a			endm  
# End of macro DMARK
497a						CALLMONITOR 
497a cd 6f ee			call debug_vector  
497d				endm  
# End of macro CALLMONITOR
497d					endif 
497d			 
497d 21 8c 49				ld hl, sym_table 
4980 cd e6 0d				call addatohl 
4983 cd 96 1e				call loadwordinhl 
4986 cd 67 1b				call forth_push_numhl 
4989			 
4989			 
4989				       NEXTW 
4989 c3 14 1f			jp macro_next 
498c				endm 
# End of macro NEXTW
498c			 
498c			sym_table: 
498c			 
498c			; 0 
498c 8c 49		dw sym_table 
498e 72 ee		dw nmi_vector 
4990 3c ea		dw cli_autodisplay 
4992 ee e9		dw cli_data_sp 
4994 28 e8		dw cli_data_stack 
4996 f0 e9		dw cli_loop_sp 
4998 2a e9		dw cli_loop_stack 
499a 28 ea		dw cli_var_array 
499c c5 eb		dw cursor_col 
499e c3 eb		dw cursor_ptr 
49a0			; 10 
49a0 c4 eb		dw cursor_row 
49a2 6b ee		dw debug_mark 
49a4 b1 ed		dw display_fb0 
49a6 10 ed		dw display_fb1 
49a8 ce eb		dw display_fb2 
49aa 6f ec		dw display_fb3 
49ac cc eb		dw display_fb_active 
49ae c0 e3		dw execscratch 
49b0 5e ea		dw f_cursor_ptr 
49b2 75 ee		dw hardware_word 
49b4			;20 
49b4 62 ee		dw input_at_cursor 
49b6 64 ee		dw input_at_pos 
49b8 60 ee		dw input_cur_flash 
49ba 5f ee		dw input_cur_onoff 
49bc 55 ee		dw input_cursor 
49be 65 ee		dw input_display_size 
49c0 5a ee		dw input_len 
49c2 69 ee		dw input_ptr 
49c4 66 ee		dw input_size 
49c6 67 ee		dw input_start 
49c8			; 30 
49c8 13 0e		dw input_str 
49ca 63 ee		dw input_under_cursor 
49cc e8 e5		dw os_cli_cmd 
49ce e4 e5		dw os_cur_ptr 
49d0 e6 e5		dw os_current_i 
49d2 bf e4		dw os_input 
49d4 e7 e6		dw os_last_cmd 
49d6 be e5		dw os_last_new_uword 
49d8 6f ee		dw debug_vector 
49da a3 e2		dw os_view_hl 
49dc			;40 
49dc c6 e5		dw os_word_scratch 
49de c3 00		dw portbctl 
49e0 c1 00		dw portbdata 
49e2 63 ea		dw spi_cartdev 
49e4 62 ea		dw spi_cartdev2 
49e6 64 ea		dw spi_clktime 
49e8 60 ea		dw spi_device 
49ea 5f ea		dw spi_device_id 
49ec 61 ea		dw spi_portbyte 
49ee a7 eb		dw stackstore 
49f0			; 50 
49f0			if STORAGE_SE 
49f0			dw storage_actl 
49f0			dw storage_adata 
49f0			else 
49f0 00 00		dw 0 
49f2 00 00		dw 0 
49f4			endif 
49f4 68 09		dw storage_append 
49f6			if STORAGE_SE 
49f6			dw storage_bctl 
49f6			else 
49f6 00 00		dw 0 
49f8			endif 
49f8 93 eb		dw store_bank_active 
49fa 67 ea		dw store_filecache 
49fc 75 ea		dw store_longread 
49fe 6b ea		dw store_openaddr 
4a00 6a ea		dw store_openext 
4a02 69 ea		dw store_openmaxext 
4a04			; 60 
4a04 7a ea		dw store_page 
4a06 76 ea		dw store_readbuf 
4a08 6d ea		dw store_readcont 
4a0a 78 ea		dw store_readptr 
4a0c 6d ea		dw store_tmpext 
4a0e 6e ea		dw store_tmpid 
4a10 65 ea		dw store_tmppageid 
4a12 ce 11		dw malloc 
4a14 98 12		dw free 
4a16 43 65		dw cin 
4a18			; 70 
4a18 3b 65		dw cin_wait 
4a1a 67 1b		dw forth_push_numhl 
4a1c d5 1b		dw forth_push_str 
4a1e			 
4a1e			 
4a1e			.ENDCONST: 
4a1e			 
4a1e			; eof 
4a1e			 
4a1e			 
# End of file forth_words_const.asm
4a1e			 
4a1e			if STORAGE_SE 
4a1e			   	include "forth_words_storage.asm" 
4a1e			endif 
4a1e				include "forth_words_device.asm" 
4a1e			; Device related words 
4a1e			 
4a1e			; | ## Device Words 
4a1e			 
4a1e			;if SOUND_ENABLE 
4a1e			;.NOTE: 
4a1e			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4a1e			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
4a1e			;		if DEBUG_FORTH_WORDS_KEY 
4a1e			;			DMARK "NTE" 
4a1e			;			CALLMONITOR 
4a1e			;		endif 
4a1e			; 
4a1e			;	 
4a1e			; 
4a1e			;		NEXTW 
4a1e			;.AFTERSOUND: 
4a1e			;endif 
4a1e			 
4a1e			 
4a1e			USE_GPIO: equ 0 
4a1e			 
4a1e			if USE_GPIO 
4a1e			.GP1: 
4a1e				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4a1e			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
4a1e					NEXTW 
4a1e			.GP2: 
4a1e				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4a1e			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
4a1e			 
4a1e					NEXTW 
4a1e			 
4a1e			.GP3: 
4a1e				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4a1e			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
4a1e			 
4a1e					NEXTW 
4a1e			 
4a1e			.GP4: 
4a1e				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4a1e			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
4a1e			 
4a1e					NEXTW 
4a1e			.SIN: 
4a1e			 
4a1e			 
4a1e			endif 
4a1e			 
4a1e			 
4a1e				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4a1e 33				db WORD_SYS_CORE+31             
4a1f 53 4a			dw .SOUT            
4a21 03				db 2 + 1 
4a22 .. 00			db "IN",0              
4a25				endm 
# End of macro CWHEAD
4a25			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4a25					if DEBUG_FORTH_WORDS_KEY 
4a25						DMARK "IN." 
4a25 f5				push af  
4a26 3a 3a 4a			ld a, (.dmark)  
4a29 32 6b ee			ld (debug_mark),a  
4a2c 3a 3b 4a			ld a, (.dmark+1)  
4a2f 32 6c ee			ld (debug_mark+1),a  
4a32 3a 3c 4a			ld a, (.dmark+2)  
4a35 32 6d ee			ld (debug_mark+2),a  
4a38 18 03			jr .pastdmark  
4a3a ..			.dmark: db "IN."  
4a3d f1			.pastdmark: pop af  
4a3e			endm  
# End of macro DMARK
4a3e						CALLMONITOR 
4a3e cd 6f ee			call debug_vector  
4a41				endm  
# End of macro CALLMONITOR
4a41					endif 
4a41					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a41 cd 5e 1d			call macro_dsp_valuehl 
4a44				endm 
# End of macro FORTH_DSP_VALUEHL
4a44			 
4a44 e5					push hl 
4a45			 
4a45					; destroy value TOS 
4a45			 
4a45					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a45 cd 16 1e			call macro_forth_dsp_pop 
4a48				endm 
# End of macro FORTH_DSP_POP
4a48			 
4a48					; one value on hl get other one back 
4a48			 
4a48 c1					pop bc 
4a49			 
4a49					; do the sub 
4a49			;		ex de, hl 
4a49			 
4a49 ed 68				in l,(c) 
4a4b			 
4a4b					; save it 
4a4b			 
4a4b 26 00				ld h,0 
4a4d			 
4a4d					; TODO push value back onto stack for another op etc 
4a4d			 
4a4d cd 67 1b				call forth_push_numhl 
4a50					NEXTW 
4a50 c3 14 1f			jp macro_next 
4a53				endm 
# End of macro NEXTW
4a53			.SOUT: 
4a53				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4a53 34				db WORD_SYS_CORE+32             
4a54 a6 4a			dw .SPIO            
4a56 04				db 3 + 1 
4a57 .. 00			db "OUT",0              
4a5b				endm 
# End of macro CWHEAD
4a5b			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4a5b					if DEBUG_FORTH_WORDS_KEY 
4a5b						DMARK "OUT" 
4a5b f5				push af  
4a5c 3a 70 4a			ld a, (.dmark)  
4a5f 32 6b ee			ld (debug_mark),a  
4a62 3a 71 4a			ld a, (.dmark+1)  
4a65 32 6c ee			ld (debug_mark+1),a  
4a68 3a 72 4a			ld a, (.dmark+2)  
4a6b 32 6d ee			ld (debug_mark+2),a  
4a6e 18 03			jr .pastdmark  
4a70 ..			.dmark: db "OUT"  
4a73 f1			.pastdmark: pop af  
4a74			endm  
# End of macro DMARK
4a74						CALLMONITOR 
4a74 cd 6f ee			call debug_vector  
4a77				endm  
# End of macro CALLMONITOR
4a77					endif 
4a77			 
4a77					; get port 
4a77			 
4a77					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a77 cd 5e 1d			call macro_dsp_valuehl 
4a7a				endm 
# End of macro FORTH_DSP_VALUEHL
4a7a			 
4a7a e5					push hl 
4a7b			 
4a7b					; destroy value TOS 
4a7b			 
4a7b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a7b cd 16 1e			call macro_forth_dsp_pop 
4a7e				endm 
# End of macro FORTH_DSP_POP
4a7e			 
4a7e					; get byte to send 
4a7e			 
4a7e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a7e cd 5e 1d			call macro_dsp_valuehl 
4a81				endm 
# End of macro FORTH_DSP_VALUEHL
4a81			 
4a81			;		push hl 
4a81			 
4a81					; destroy value TOS 
4a81			 
4a81					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a81 cd 16 1e			call macro_forth_dsp_pop 
4a84				endm 
# End of macro FORTH_DSP_POP
4a84			 
4a84					; one value on hl get other one back 
4a84			 
4a84			;		pop hl 
4a84			 
4a84 c1					pop bc 
4a85			 
4a85					if DEBUG_FORTH_WORDS 
4a85						DMARK "OUT" 
4a85 f5				push af  
4a86 3a 9a 4a			ld a, (.dmark)  
4a89 32 6b ee			ld (debug_mark),a  
4a8c 3a 9b 4a			ld a, (.dmark+1)  
4a8f 32 6c ee			ld (debug_mark+1),a  
4a92 3a 9c 4a			ld a, (.dmark+2)  
4a95 32 6d ee			ld (debug_mark+2),a  
4a98 18 03			jr .pastdmark  
4a9a ..			.dmark: db "OUT"  
4a9d f1			.pastdmark: pop af  
4a9e			endm  
# End of macro DMARK
4a9e						CALLMONITOR 
4a9e cd 6f ee			call debug_vector  
4aa1				endm  
# End of macro CALLMONITOR
4aa1					endif 
4aa1			 
4aa1 ed 69				out (c), l 
4aa3			 
4aa3					NEXTW 
4aa3 c3 14 1f			jp macro_next 
4aa6				endm 
# End of macro NEXTW
4aa6			 
4aa6			 
4aa6			.SPIO: 
4aa6			 
4aa6			if STORAGE_SE 
4aa6				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4aa6			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4aa6			 
4aa6					call spi_ce_low 
4aa6			    NEXTW 
4aa6			 
4aa6			.SPICEH: 
4aa6				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4aa6			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4aa6			 
4aa6					call spi_ce_high 
4aa6			    NEXTW 
4aa6			 
4aa6			 
4aa6			.SPIOb: 
4aa6			 
4aa6				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4aa6			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4aa6			 
4aa6					if DEBUG_FORTH_WORDS_KEY 
4aa6						DMARK "SPo" 
4aa6						CALLMONITOR 
4aa6					endif 
4aa6					; get port 
4aa6			 
4aa6			 
4aa6					; get byte to send 
4aa6			 
4aa6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aa6			 
4aa6			;		push hl    ; u1  
4aa6			 
4aa6					; destroy value TOS 
4aa6			 
4aa6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aa6			 
4aa6					; one value on hl get other one back 
4aa6			 
4aa6			;		pop hl   ; u2 - addr 
4aa6			 
4aa6					; TODO Send SPI byte 
4aa6			 
4aa6			;		push hl 
4aa6			;		call spi_ce_low 
4aa6			;		pop hl 
4aa6					ld a, l 
4aa6					call spi_send_byte 
4aa6			;		call spi_ce_high 
4aa6			 
4aa6					NEXTW 
4aa6			 
4aa6			.SPII: 
4aa6				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4aa6			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4aa6					if DEBUG_FORTH_WORDS_KEY 
4aa6						DMARK "SPi" 
4aa6						CALLMONITOR 
4aa6					endif 
4aa6			 
4aa6					; TODO Get SPI byte 
4aa6			 
4aa6					call spi_read_byte 
4aa6			 
4aa6					if DEBUG_FORTH_WORDS 
4aa6						DMARK "Si2" 
4aa6						CALLMONITOR 
4aa6					endif 
4aa6					ld h, 0 
4aa6					ld l, a 
4aa6					if DEBUG_FORTH_WORDS 
4aa6						DMARK "Si3" 
4aa6						CALLMONITOR 
4aa6					endif 
4aa6					call forth_push_numhl 
4aa6			 
4aa6					NEXTW 
4aa6			 
4aa6			 
4aa6			 
4aa6			.SESEL: 
4aa6				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4aa6			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4aa6					if DEBUG_FORTH_WORDS_KEY 
4aa6						DMARK "BNK" 
4aa6						CALLMONITOR 
4aa6					endif 
4aa6			 
4aa6					ld a, 255 
4aa6					ld (spi_cartdev), a 
4aa6			 
4aa6					; get bank 
4aa6			 
4aa6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aa6			 
4aa6			;		push hl 
4aa6			 
4aa6					; destroy value TOS 
4aa6			 
4aa6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aa6			 
4aa6					; one value on hl get other one back 
4aa6			 
4aa6			;		pop hl 
4aa6			 
4aa6			 
4aa6					ld c, SPI_CE_HIGH 
4aa6					ld b, '0'    ; human readable bank number 
4aa6			 
4aa6					ld a, l 
4aa6			 
4aa6					if DEBUG_FORTH_WORDS 
4aa6						DMARK "BNK" 
4aa6						CALLMONITOR 
4aa6					endif 
4aa6			 
4aa6					; active low 
4aa6			 
4aa6					cp 0 
4aa6					jr z, .bset 
4aa6					cp 1 
4aa6					jr nz, .b2 
4aa6					res 0, c 
4aa6					ld b, '1'    ; human readable bank number 
4aa6			.b2:		cp 2 
4aa6					jr nz, .b3 
4aa6					res 1, c 
4aa6					ld b, '2'    ; human readable bank number 
4aa6			.b3:		cp 3 
4aa6					jr nz, .b4 
4aa6					res 2, c 
4aa6					ld b, '3'    ; human readable bank number 
4aa6			.b4:		cp 4 
4aa6					jr nz, .b5 
4aa6					res 3, c 
4aa6					ld b, '4'    ; human readable bank number 
4aa6			.b5:		cp 5 
4aa6					jr nz, .bset 
4aa6					res 4, c 
4aa6					ld b, '5'    ; human readable bank number 
4aa6			 
4aa6			.bset: 
4aa6					ld a, c 
4aa6					ld (spi_device),a 
4aa6					ld a, b 
4aa6					ld (spi_device_id),a 
4aa6					if DEBUG_FORTH_WORDS 
4aa6						DMARK "BN2" 
4aa6						CALLMONITOR 
4aa6					endif 
4aa6			 
4aa6					; set default SPI clk pulse time as disabled for BANK use 
4aa6			 
4aa6					ld a, 0 
4aa6					ld (spi_clktime), a 
4aa6			 
4aa6					NEXTW 
4aa6			 
4aa6			.CARTDEV: 
4aa6				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4aa6			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4aa6					if DEBUG_FORTH_WORDS_KEY 
4aa6						DMARK "CDV" 
4aa6						CALLMONITOR 
4aa6					endif 
4aa6			 
4aa6					; disable se storage bank selection 
4aa6			 
4aa6					ld a, SPI_CE_HIGH		; ce high 
4aa6					ld (spi_device), a 
4aa6			 
4aa6					; get bank 
4aa6			 
4aa6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aa6			 
4aa6			;		push hl 
4aa6			 
4aa6					; destroy value TOS 
4aa6			 
4aa6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aa6			 
4aa6					; one value on hl get other one back 
4aa6			 
4aa6			;		pop hl 
4aa6			 
4aa6					; active low 
4aa6			 
4aa6					ld c, 255 
4aa6			 
4aa6					ld a, l 
4aa6					if DEBUG_FORTH_WORDS 
4aa6						DMARK "CDV" 
4aa6						CALLMONITOR 
4aa6					endif 
4aa6					cp 0 
4aa6					jr z, .cset 
4aa6					cp 1 
4aa6					jr nz, .c2 
4aa6					res 0, c 
4aa6			.c2:		cp 2 
4aa6					jr nz, .c3 
4aa6					res 1, c 
4aa6			.c3:		cp 3 
4aa6					jr nz, .c4 
4aa6					res 2, c 
4aa6			.c4:		cp 4 
4aa6					jr nz, .c5 
4aa6					res 3, c 
4aa6			.c5:		cp 5 
4aa6					jr nz, .c6 
4aa6					res 4, c 
4aa6			.c6:		cp 6 
4aa6					jr nz, .c7 
4aa6					res 5, c 
4aa6			.c7:		cp 7 
4aa6					jr nz, .c8 
4aa6					res 6, c 
4aa6			.c8:		cp 8 
4aa6					jr nz, .cset 
4aa6					res 7, c 
4aa6			.cset:		ld a, c 
4aa6					ld (spi_cartdev),a 
4aa6			 
4aa6					if DEBUG_FORTH_WORDS 
4aa6						DMARK "CD2" 
4aa6						CALLMONITOR 
4aa6					endif 
4aa6			 
4aa6					; set default SPI clk pulse time as 10ms for CARTDEV use 
4aa6			 
4aa6					ld a, $0a 
4aa6					ld (spi_clktime), a 
4aa6					NEXTW 
4aa6			endif 
4aa6			 
4aa6			.ENDDEVICE: 
4aa6			; eof 
4aa6			 
# End of file forth_words_device.asm
4aa6			 
4aa6			; var handler 
4aa6			 
4aa6			 
4aa6			.VARS: 
4aa6				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
4aa6 77				db WORD_SYS_CORE+99             
4aa7 57 4b			dw .V0            
4aa9 04				db 3 + 1 
4aaa .. 00			db "VAR",0              
4aae				endm 
# End of macro CWHEAD
4aae			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4aae			;| 
4aae			;| The variable name should consist of a single letter. e.g. "a" 
4aae			;! If a full string is passed then only the first char is looked at 
4aae			;| Any other char could exceed bounds checks!  
4aae			 
4aae					if DEBUG_FORTH_WORDS_KEY 
4aae						DMARK "VAR" 
4aae f5				push af  
4aaf 3a c3 4a			ld a, (.dmark)  
4ab2 32 6b ee			ld (debug_mark),a  
4ab5 3a c4 4a			ld a, (.dmark+1)  
4ab8 32 6c ee			ld (debug_mark+1),a  
4abb 3a c5 4a			ld a, (.dmark+2)  
4abe 32 6d ee			ld (debug_mark+2),a  
4ac1 18 03			jr .pastdmark  
4ac3 ..			.dmark: db "VAR"  
4ac6 f1			.pastdmark: pop af  
4ac7			endm  
# End of macro DMARK
4ac7						CALLMONITOR 
4ac7 cd 6f ee			call debug_vector  
4aca				endm  
# End of macro CALLMONITOR
4aca					endif 
4aca			 
4aca					FORTH_DSP_VALUEHL 
4aca cd 5e 1d			call macro_dsp_valuehl 
4acd				endm 
# End of macro FORTH_DSP_VALUEHL
4acd			 
4acd 7e					ld a, (hl)    ; get first char on of the string 
4ace			 
4ace			 
4ace					if DEBUG_FORTH_WORDS 
4ace						DMARK "VR1" 
4ace f5				push af  
4acf 3a e3 4a			ld a, (.dmark)  
4ad2 32 6b ee			ld (debug_mark),a  
4ad5 3a e4 4a			ld a, (.dmark+1)  
4ad8 32 6c ee			ld (debug_mark+1),a  
4adb 3a e5 4a			ld a, (.dmark+2)  
4ade 32 6d ee			ld (debug_mark+2),a  
4ae1 18 03			jr .pastdmark  
4ae3 ..			.dmark: db "VR1"  
4ae6 f1			.pastdmark: pop af  
4ae7			endm  
# End of macro DMARK
4ae7						CALLMONITOR 
4ae7 cd 6f ee			call debug_vector  
4aea				endm  
# End of macro CALLMONITOR
4aea					endif 
4aea					 
4aea f5					push af	 
4aeb					FORTH_DSP_POP 
4aeb cd 16 1e			call macro_forth_dsp_pop 
4aee				endm 
# End of macro FORTH_DSP_POP
4aee f1					pop af 
4aef			 
4aef					; convert to upper 
4aef			 
4aef cd 68 10				call to_upper 
4af2					if DEBUG_FORTH_WORDS 
4af2						DMARK "Vaa" 
4af2 f5				push af  
4af3 3a 07 4b			ld a, (.dmark)  
4af6 32 6b ee			ld (debug_mark),a  
4af9 3a 08 4b			ld a, (.dmark+1)  
4afc 32 6c ee			ld (debug_mark+1),a  
4aff 3a 09 4b			ld a, (.dmark+2)  
4b02 32 6d ee			ld (debug_mark+2),a  
4b05 18 03			jr .pastdmark  
4b07 ..			.dmark: db "Vaa"  
4b0a f1			.pastdmark: pop af  
4b0b			endm  
# End of macro DMARK
4b0b						CALLMONITOR 
4b0b cd 6f ee			call debug_vector  
4b0e				endm  
# End of macro CALLMONITOR
4b0e					endif 
4b0e 06 41				ld b, 'A' 
4b10 90					sub b			; set offset 
4b11					if DEBUG_FORTH_WORDS 
4b11						DMARK "Vbb" 
4b11 f5				push af  
4b12 3a 26 4b			ld a, (.dmark)  
4b15 32 6b ee			ld (debug_mark),a  
4b18 3a 27 4b			ld a, (.dmark+1)  
4b1b 32 6c ee			ld (debug_mark+1),a  
4b1e 3a 28 4b			ld a, (.dmark+2)  
4b21 32 6d ee			ld (debug_mark+2),a  
4b24 18 03			jr .pastdmark  
4b26 ..			.dmark: db "Vbb"  
4b29 f1			.pastdmark: pop af  
4b2a			endm  
# End of macro DMARK
4b2a						CALLMONITOR 
4b2a cd 6f ee			call debug_vector  
4b2d				endm  
# End of macro CALLMONITOR
4b2d					endif 
4b2d cb 27				sla a  
4b2f				 
4b2f					 
4b2f					if DEBUG_FORTH_WORDS 
4b2f						DMARK "VR2" 
4b2f f5				push af  
4b30 3a 44 4b			ld a, (.dmark)  
4b33 32 6b ee			ld (debug_mark),a  
4b36 3a 45 4b			ld a, (.dmark+1)  
4b39 32 6c ee			ld (debug_mark+1),a  
4b3c 3a 46 4b			ld a, (.dmark+2)  
4b3f 32 6d ee			ld (debug_mark+2),a  
4b42 18 03			jr .pastdmark  
4b44 ..			.dmark: db "VR2"  
4b47 f1			.pastdmark: pop af  
4b48			endm  
# End of macro DMARK
4b48						CALLMONITOR 
4b48 cd 6f ee			call debug_vector  
4b4b				endm  
# End of macro CALLMONITOR
4b4b					endif 
4b4b			 
4b4b 21 f4 e9				ld hl, cli_var_array2 
4b4e cd e6 0d				call addatohl 
4b51 cd 67 1b				call forth_push_numhl 
4b54			 
4b54			 
4b54				       NEXTW 
4b54 c3 14 1f			jp macro_next 
4b57				endm 
# End of macro NEXTW
4b57			.V0: 
4b57				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4b57 78				db WORD_SYS_CORE+100             
4b58 6f 4b			dw .V0Q            
4b5a 04				db 3 + 1 
4b5b .. 00			db "V0!",0              
4b5f				endm 
# End of macro CWHEAD
4b5f			;| V0! ( u1 -- )  Store value to v0  | DONE 
4b5f			 
4b5f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b5f cd 5e 1d			call macro_dsp_valuehl 
4b62				endm 
# End of macro FORTH_DSP_VALUEHL
4b62			 
4b62 11 28 ea				ld de, cli_var_array 
4b65			 
4b65 eb					ex de, hl 
4b66 73					ld (hl), e 
4b67 23					inc hl 
4b68 72					ld (hl), d 
4b69			 
4b69					; destroy value TOS 
4b69			 
4b69					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b69 cd 16 1e			call macro_forth_dsp_pop 
4b6c				endm 
# End of macro FORTH_DSP_POP
4b6c			 
4b6c				       NEXTW 
4b6c c3 14 1f			jp macro_next 
4b6f				endm 
# End of macro NEXTW
4b6f			.V0Q: 
4b6f				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4b6f 79				db WORD_SYS_CORE+101             
4b70 80 4b			dw .V1S            
4b72 04				db 3 + 1 
4b73 .. 00			db "V0@",0              
4b77				endm 
# End of macro CWHEAD
4b77			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4b77 2a 28 ea				ld hl, (cli_var_array) 
4b7a cd 67 1b				call forth_push_numhl 
4b7d			 
4b7d				       NEXTW 
4b7d c3 14 1f			jp macro_next 
4b80				endm 
# End of macro NEXTW
4b80			.V1S: 
4b80				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4b80 7a				db WORD_SYS_CORE+102             
4b81 98 4b			dw .V1Q            
4b83 04				db 3 + 1 
4b84 .. 00			db "V1!",0              
4b88				endm 
# End of macro CWHEAD
4b88			;| V1! ( u1 -- )  Store value to v1 | DONE 
4b88					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b88 cd 5e 1d			call macro_dsp_valuehl 
4b8b				endm 
# End of macro FORTH_DSP_VALUEHL
4b8b			 
4b8b 11 2a ea				ld de, cli_var_array+2 
4b8e				 
4b8e eb					ex de, hl 
4b8f 73					ld (hl), e 
4b90 23					inc hl 
4b91 72					ld (hl), d 
4b92			 
4b92					; destroy value TOS 
4b92			 
4b92					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b92 cd 16 1e			call macro_forth_dsp_pop 
4b95				endm 
# End of macro FORTH_DSP_POP
4b95				       NEXTW 
4b95 c3 14 1f			jp macro_next 
4b98				endm 
# End of macro NEXTW
4b98			.V1Q: 
4b98				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4b98 7b				db WORD_SYS_CORE+103             
4b99 a9 4b			dw .V2S            
4b9b 04				db 3 + 1 
4b9c .. 00			db "V1@",0              
4ba0				endm 
# End of macro CWHEAD
4ba0			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4ba0 2a 2a ea				ld hl, (cli_var_array+2) 
4ba3 cd 67 1b				call forth_push_numhl 
4ba6				       NEXTW 
4ba6 c3 14 1f			jp macro_next 
4ba9				endm 
# End of macro NEXTW
4ba9			.V2S: 
4ba9				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4ba9 7c				db WORD_SYS_CORE+104             
4baa c1 4b			dw .V2Q            
4bac 04				db 3 + 1 
4bad .. 00			db "V2!",0              
4bb1				endm 
# End of macro CWHEAD
4bb1			;| V2! ( u1 -- )  Store value to v2 | DONE 
4bb1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bb1 cd 5e 1d			call macro_dsp_valuehl 
4bb4				endm 
# End of macro FORTH_DSP_VALUEHL
4bb4			 
4bb4 11 2c ea				ld de, cli_var_array+4 
4bb7				 
4bb7 eb					ex de, hl 
4bb8 73					ld (hl), e 
4bb9 23					inc hl 
4bba 72					ld (hl), d 
4bbb			 
4bbb					; destroy value TOS 
4bbb			 
4bbb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bbb cd 16 1e			call macro_forth_dsp_pop 
4bbe				endm 
# End of macro FORTH_DSP_POP
4bbe				       NEXTW 
4bbe c3 14 1f			jp macro_next 
4bc1				endm 
# End of macro NEXTW
4bc1			.V2Q: 
4bc1				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4bc1 7d				db WORD_SYS_CORE+105             
4bc2 d2 4b			dw .V3S            
4bc4 04				db 3 + 1 
4bc5 .. 00			db "V2@",0              
4bc9				endm 
# End of macro CWHEAD
4bc9			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4bc9 2a 2c ea				ld hl, (cli_var_array+4) 
4bcc cd 67 1b				call forth_push_numhl 
4bcf				       NEXTW 
4bcf c3 14 1f			jp macro_next 
4bd2				endm 
# End of macro NEXTW
4bd2			.V3S: 
4bd2				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4bd2 7c				db WORD_SYS_CORE+104             
4bd3 ea 4b			dw .V3Q            
4bd5 04				db 3 + 1 
4bd6 .. 00			db "V3!",0              
4bda				endm 
# End of macro CWHEAD
4bda			;| V3! ( u1 -- )  Store value to v3 | DONE 
4bda					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bda cd 5e 1d			call macro_dsp_valuehl 
4bdd				endm 
# End of macro FORTH_DSP_VALUEHL
4bdd			 
4bdd 11 2e ea				ld de, cli_var_array+6 
4be0				 
4be0 eb					ex de, hl 
4be1 73					ld (hl), e 
4be2 23					inc hl 
4be3 72					ld (hl), d 
4be4			 
4be4					; destroy value TOS 
4be4			 
4be4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4be4 cd 16 1e			call macro_forth_dsp_pop 
4be7				endm 
# End of macro FORTH_DSP_POP
4be7				       NEXTW 
4be7 c3 14 1f			jp macro_next 
4bea				endm 
# End of macro NEXTW
4bea			.V3Q: 
4bea				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4bea 7d				db WORD_SYS_CORE+105             
4beb fb 4b			dw .END            
4bed 04				db 3 + 1 
4bee .. 00			db "V3@",0              
4bf2				endm 
# End of macro CWHEAD
4bf2			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4bf2 2a 2e ea				ld hl, (cli_var_array+6) 
4bf5 cd 67 1b				call forth_push_numhl 
4bf8				       NEXTW 
4bf8 c3 14 1f			jp macro_next 
4bfb				endm 
# End of macro NEXTW
4bfb			 
4bfb			 
4bfb			 
4bfb			 
4bfb			 
4bfb			; end of dict marker 
4bfb			 
4bfb 00			.END:    db WORD_SYS_END 
4bfc 00 00			dw 0 
4bfe 00				db 0 
4bff			 
4bff			; use to jp here for user dict words to save on macro expansion  
4bff			 
4bff			user_dict_next: 
4bff				NEXTW 
4bff c3 14 1f			jp macro_next 
4c02				endm 
# End of macro NEXTW
4c02			 
4c02			 
4c02			user_exec: 
4c02				;    ld hl, <word code> 
4c02				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4c02				;    call forthexec 
4c02				;    jp user_dict_next   (NEXT) 
4c02			        ;    <word code bytes> 
4c02 eb				ex de, hl 
4c03 2a c2 e5			ld hl,(os_tok_ptr) 
4c06				 
4c06				FORTH_RSP_NEXT 
4c06 cd 0e 1b			call macro_forth_rsp_next 
4c09				endm 
# End of macro FORTH_RSP_NEXT
4c09			 
4c09			if DEBUG_FORTH_UWORD 
4c09						DMARK "UEX" 
4c09 f5				push af  
4c0a 3a 1e 4c			ld a, (.dmark)  
4c0d 32 6b ee			ld (debug_mark),a  
4c10 3a 1f 4c			ld a, (.dmark+1)  
4c13 32 6c ee			ld (debug_mark+1),a  
4c16 3a 20 4c			ld a, (.dmark+2)  
4c19 32 6d ee			ld (debug_mark+2),a  
4c1c 18 03			jr .pastdmark  
4c1e ..			.dmark: db "UEX"  
4c21 f1			.pastdmark: pop af  
4c22			endm  
# End of macro DMARK
4c22				CALLMONITOR 
4c22 cd 6f ee			call debug_vector  
4c25				endm  
# End of macro CALLMONITOR
4c25			endif 
4c25			 
4c25			 
4c25			 
4c25 eb				ex de, hl 
4c26 22 c2 e5			ld (os_tok_ptr), hl 
4c29				 
4c29				; Don't use next - Skips the first word in uword. 
4c29			 
4c29 c3 a5 1f			jp exec1 
4c2c			;	NEXT 
4c2c			 
4c2c			 
4c2c			; eof 
# End of file forth_wordsv4.asm
4c2c			endif 
4c2c			;;;;;;;;;;;;;; Debug code 
4c2c			 
4c2c			 
4c2c			;if DEBUG_FORTH_PARSE 
4c2c .. 00		.nowordfound: db "No match",0 
4c35 .. 00		.compword:	db "Comparing word ",0 
4c45 .. 00		.nextwordat:	db "Next word at",0 
4c52 .. 00		.charmatch:	db "Char match",0 
4c5d			;endif 
4c5d			if DEBUG_FORTH_JP 
4c5d			.foundword:	db "Word match. Exec..",0 
4c5d			endif 
4c5d			;if DEBUG_FORTH_PUSH 
4c5d .. 00		.enddict:	db "Dict end. Push.",0 
4c6d .. 00		.push_str:	db "Pushing string",0 
4c7c .. 00		.push_num:	db "Pushing number",0 
4c8b .. 00		.data_sp:	db "SP:",0 
4c8f .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4ca1 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4cb3 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4cc5			;endif 
4cc5			;if DEBUG_FORTH_MALLOC 
4cc5 .. 00		.push_malloc:	db "Malloc address",0 
4cd4			;endif 
4cd4			 
4cd4			 
4cd4			 
4cd4			; display malloc address and current data stack pointer  
4cd4			 
4cd4			malloc_error: 
4cd4 d5				push de 
4cd5 f5				push af 
4cd6 e5				push hl 
4cd7 cd b9 0b			call clear_display 
4cda 11 fa 4c			ld de, .mallocerr 
4cdd 3e 00			ld a,0 
4cdf			;	ld de,os_word_scratch 
4cdf cd cc 0b			call str_at_display 
4ce2 3e 11			ld a, display_row_1+17 
4ce4 11 6b ee			ld de, debug_mark 
4ce7 cd cc 0b			call str_at_display 
4cea cd dc 0b			call update_display 
4ced				;call break_point_state 
4ced cd 3b 65			call cin_wait 
4cf0			 
4cf0			;	ld a, ' ' 
4cf0			;	ld (os_view_disable), a 
4cf0 cd fd 14			call bp_on 
4cf3 e1				pop hl 
4cf4 f1				pop af 
4cf5 d1				pop de	 
4cf6				CALLMONITOR 
4cf6 cd 6f ee			call debug_vector  
4cf9				endm  
# End of macro CALLMONITOR
4cf9 c9				ret 
4cfa			 
4cfa .. 00		.mallocerr: 	db "Malloc Error",0 
4d07			;if DEBUG_FORTH_PUSH 
4d07			display_data_sp: 
4d07 f5				push af 
4d08			 
4d08				; see if disabled 
4d08			 
4d08			 
4d08 3a 6f ee			ld a, (debug_vector) 
4d0b fe c9			cp $C9  ; RET 
4d0d				;ld a, (os_view_disable) 
4d0d				;cp '*' 
4d0d 28 67			jr z, .skipdsp 
4d0f			 
4d0f e5				push hl 
4d10 e5				push hl 
4d11 e5			push hl 
4d12 cd b9 0b			call clear_display 
4d15 e1			pop hl 
4d16 7c				ld a,h 
4d17 21 c6 e5			ld hl, os_word_scratch 
4d1a cd fc 0f			call hexout 
4d1d e1				pop hl 
4d1e 7d				ld a,l 
4d1f 21 c8 e5			ld hl, os_word_scratch+2 
4d22 cd fc 0f			call hexout 
4d25 21 ca e5			ld hl, os_word_scratch+4 
4d28 3e 00			ld a,0 
4d2a 77				ld (hl),a 
4d2b 11 c6 e5			ld de,os_word_scratch 
4d2e 3e 28				ld a, display_row_2 
4d30 cd cc 0b				call str_at_display 
4d33 11 8f 4c			ld de, .wordinhl 
4d36 3e 00			ld a, display_row_1 
4d38			 
4d38 cd cc 0b				call str_at_display 
4d3b 11 6b ee			ld de, debug_mark 
4d3e 3e 11			ld a, display_row_1+17 
4d40			 
4d40 cd cc 0b				call str_at_display 
4d43			 
4d43				; display current data stack pointer 
4d43 11 8b 4c			ld de,.data_sp 
4d46 3e 30				ld a, display_row_2 + 8 
4d48 cd cc 0b				call str_at_display 
4d4b			 
4d4b 2a ee e9			ld hl,(cli_data_sp) 
4d4e e5				push hl 
4d4f 7c				ld a,h 
4d50 21 c6 e5			ld hl, os_word_scratch 
4d53 cd fc 0f			call hexout 
4d56 e1				pop hl 
4d57 7d				ld a,l 
4d58 21 c8 e5			ld hl, os_word_scratch+2 
4d5b cd fc 0f			call hexout 
4d5e 21 ca e5			ld hl, os_word_scratch+4 
4d61 3e 00			ld a,0 
4d63 77				ld (hl),a 
4d64 11 c6 e5			ld de,os_word_scratch 
4d67 3e 33				ld a, display_row_2 + 11 
4d69 cd cc 0b				call str_at_display 
4d6c			 
4d6c			 
4d6c cd dc 0b			call update_display 
4d6f cd f1 0a			call delay1s 
4d72 cd f1 0a			call delay1s 
4d75 e1				pop hl 
4d76			.skipdsp: 
4d76 f1				pop af 
4d77 c9				ret 
4d78			 
4d78			display_data_malloc: 
4d78			 
4d78 f5				push af 
4d79 e5				push hl 
4d7a e5				push hl 
4d7b e5			push hl 
4d7c cd b9 0b			call clear_display 
4d7f e1			pop hl 
4d80 7c				ld a,h 
4d81 21 c6 e5			ld hl, os_word_scratch 
4d84 cd fc 0f			call hexout 
4d87 e1				pop hl 
4d88 7d				ld a,l 
4d89 21 c8 e5			ld hl, os_word_scratch+2 
4d8c cd fc 0f			call hexout 
4d8f 21 ca e5			ld hl, os_word_scratch+4 
4d92 3e 00			ld a,0 
4d94 77				ld (hl),a 
4d95 11 c6 e5			ld de,os_word_scratch 
4d98 3e 28				ld a, display_row_2 
4d9a cd cc 0b				call str_at_display 
4d9d 11 c5 4c			ld de, .push_malloc 
4da0 3e 00			ld a, display_row_1 
4da2			 
4da2 cd cc 0b				call str_at_display 
4da5			 
4da5				; display current data stack pointer 
4da5 11 8b 4c			ld de,.data_sp 
4da8 3e 30				ld a, display_row_2 + 8 
4daa cd cc 0b				call str_at_display 
4dad			 
4dad 2a ee e9			ld hl,(cli_data_sp) 
4db0 e5				push hl 
4db1 7c				ld a,h 
4db2 21 c6 e5			ld hl, os_word_scratch 
4db5 cd fc 0f			call hexout 
4db8 e1				pop hl 
4db9 7d				ld a,l 
4dba 21 c8 e5			ld hl, os_word_scratch+2 
4dbd cd fc 0f			call hexout 
4dc0 21 ca e5			ld hl, os_word_scratch+4 
4dc3 3e 00			ld a,0 
4dc5 77				ld (hl),a 
4dc6 11 c6 e5			ld de,os_word_scratch 
4dc9 3e 33				ld a, display_row_2 + 11 
4dcb cd cc 0b				call str_at_display 
4dce			 
4dce cd dc 0b			call update_display 
4dd1 cd f1 0a			call delay1s 
4dd4 cd f1 0a			call delay1s 
4dd7 e1				pop hl 
4dd8 f1				pop af 
4dd9 c9				ret 
4dda			;endif 
4dda			 
4dda			include "forth_autostart.asm" 
4dda			; list of commands to perform at system start up 
4dda			 
4dda			startcmds: 
4dda			;	dw test11 
4dda			;	dw test12 
4dda			;	dw test13 
4dda			;	dw test14 
4dda			;	dw test15 
4dda			;	dw test16 
4dda			;	dw test17 
4dda			;	dw ifthtest1 
4dda			;	dw ifthtest2 
4dda			;	dw ifthtest3 
4dda			;	dw mmtest1 
4dda			;	dw mmtest2 
4dda			;	dw mmtest3 
4dda			;	dw mmtest4 
4dda			;	dw mmtest5 
4dda			;	dw mmtest6 
4dda			;	dw iftest1 
4dda			;	dw iftest2 
4dda			;	dw iftest3 
4dda			;	dw looptest1 
4dda			;	dw looptest2 
4dda			;	dw test1 
4dda			;	dw test2 
4dda			;	dw test3 
4dda			;	dw test4 
4dda			;	dw game2r 
4dda			;	dw game2b1 
4dda			;	dw game2b2 
4dda			 
4dda				; start up words that are actually useful 
4dda			 
4dda			;    dw spi1 
4dda			;    dw spi2 
4dda			;    dw spi3 
4dda			;    dw spi4 
4dda			;    dw spi5 
4dda			;    dw spi6 
4dda			;    dw spi7 
4dda			; 
4dda			;    dw spi8 
4dda			;    dw spi9 
4dda			;    dw spi10 
4dda			 
4dda			; file editor 
4dda			;	dw edit1 
4dda			;	dw edit2 
4dda			;	dw edit3 
4dda			 
4dda			;	dw longread 
4dda 04 52			dw clrstack 
4ddc 38 52			dw type 
4dde			;	dw stest 
4dde 5d 52			dw strncpy 
4de0			;	dw list 
4de0 be 52			dw start1 
4de2 ce 52			dw start2 
4de4			;	dw start3 
4de4			;	dw start3b 
4de4			;	dw start3c 
4de4			 
4de4				; (unit) testing words 
4de4			 
4de4			;	dw mtesta 
4de4			;	dw mtestb 
4de4			;	dw mtestc 
4de4			;	dw mtestd 
4de4			;	dw mteste 
4de4			 
4de4				; demo/game words 
4de4			 
4de4			;        dw game3w 
4de4			;        dw game3p 
4de4			;        dw game3sc 
4de4			;        dw game3vsi 
4de4			;        dw game3vs 
4de4				 
4de4 27 5d			dw game2b 
4de6 95 5d			dw game2bf 
4de8 df 5d			dw game2mba 
4dea 75 5e			dw game2mbas 
4dec b7 5e			dw game2mb 
4dee			 
4dee e8 59			dw game1 
4df0 f9 59			dw game1a 
4df2 5b 5a			dw game1b 
4df4 90 5a			dw game1c 
4df6 c6 5a			dw game1d 
4df8 f7 5a			dw game1s 
4dfa 0b 5b			dw game1t 
4dfc 20 5b			dw game1f 
4dfe 54 5b			dw game1z 
4e00 98 5b			dw game1zz 
4e02			 
4e02 02 58			dw test5 
4e04 3a 58			dw test6 
4e06 72 58			dw test7 
4e08 86 58			dw test8 
4e0a b2 58			dw test9 
4e0c c8 58			dw test10 
4e0e				 
4e0e 6f 5c		        dw ssv5 
4e10 53 5c		        dw ssv4 
4e12 37 5c		        dw ssv3 
4e14 01 5c		        dw ssv2 
4e16 88 5c		        dw ssv1 
4e18 d0 5c		        dw ssv1cpm 
4e1a			;	dw keyup 
4e1a			;	dw keydown 
4e1a			;	dw keyleft 
4e1a			;	dw keyright 
4e1a			;	dw 	keyf1 
4e1a			;	dw keyf2 
4e1a			;	dw keyf3 
4e1a			;	dw keyf4 
4e1a			;	dw keyf5 
4e1a			;	dw keyf6 
4e1a			;	dw keyf7 
4e1a			;	dw keyf8 
4e1a			;	dw keyf9 
4e1a			;	dw keyf10 
4e1a			;	dw keyf11 
4e1a			;	dw keyf12 
4e1a			;	dw keytab 
4e1a			;	dw keycr 
4e1a			;	dw keyhome 
4e1a			;	dw keyend 
4e1a			;	dw keybs 
4e1a 00 00			db 0, 0	 
4e1c			 
4e1c			 
4e1c			; File Editor 
4e1c			 
4e1c			; ( id - ) use 'e' to edit the displayed line 
4e1c .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
4e3d .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4e72			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4e72 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
4eaa			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
4eaa			 
4eaa			; SPI Net support words 
4eaa			 
4eaa			; v0! = node to send to 
4eaa			; ( str count - ) 
4eaa .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
4f03			 
4f03			; spiputc ( char node - ) 
4f03 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
4f37			; spiputc ( u node - ) 
4f37 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
4f65			 
4f65			; spigetc ( - n ) 
4f65 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
4f8e			 
4f8e			; getnode ( - n ) 
4f8e .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
4fbb			 
4fbb			; ( str node - )  
4fbb .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5021			; store string ( str i - ) 
5021			 
5021			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5021 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
5076			 
5076			; get string ( addr i -  )    TO FIX 
5076			 
5076 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
50ce			 
50ce			 
50ce			; NETCHAT (TODO) 
50ce			; Program to allow two nodes to chat with eachother 
50ce			; 
50ce			; v0 - target node 
50ce			;  
50ce			; accept input at 0,0 
50ce			; if input is string send spitype to target node 
50ce			; starting at row 2,0 , while spigetchr is not zero ->  
50ce			; 
50ce			; 
50ce			; TODO add paging of get request 
50ce			 
50ce			; ( node - ) 
50ce .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
50ed .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5145 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
51bd			 
51bd			 
51bd			; Long read of currently open file 
51bd .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5204			 
5204			; clear stack  
5204			 
5204 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
5238			 
5238			; type ( addr count - ) 
5238 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
525d			 
525d			; some direct memory words 
525d			; strncpy ( len t f -- t ) 
525d			 
525d .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
52be			 
52be .. 00		start1:     	db ": bpon $00 bp ;",0 
52ce .. 00		start2:     	db ": bpoff $01 bp ;",0 
52df .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
535a .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
53ba			 
53ba			 
53ba			; a handy word to list items on the stack 
53ba			 
53ba .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5424			 
5424			 
5424			; test stack  
5424			; rnd8 stest 
5424			 
5424 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
549b			 
549b			; random malloc and free cycles 
549b			 
549b .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5550			 
5550			; fixed malloc and free cycles 
5550			 
5550 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
55f3			 
55f3			; fixed double string push and drop cycle  
55f3			 
55f3 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
56a8			 
56a8			; consistent fixed string push and drop cycle  
56a8			 
56a8 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
574c			 
574c .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5802			 
5802			;test1:		db ": aa 1 2 3 ;", 0 
5802			;test2:     	db "111 aa 888 999",0 
5802			;test3:     	db ": bb 77 ;",0 
5802			;test4:     	db "$02 $01 do i . loop bb",0 
5802			 
5802 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
583a .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5872 .. 00		test7:     	db ": box hline vline ;",0 
5886 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
58b2 .. 00		test9:     	db ": sw $01 adsp world ;",0 
58c8 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
58ed .. 00		test11:     	db "hello create .",0 
58fc .. 00		test12:     	db "hello2 create .",0 
590c			 
590c			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
590c			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
590c			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
590c			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
590c			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
590c			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
590c			 
590c			;iftest1:     	db "$0001 IF cls .",0 
590c			;iftest2:     	db "$0000 IF cls .",0 
590c			;iftest3:     	db "$0002 $0003 - IF cls .",0 
590c			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
590c			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
590c			 
590c			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
590c			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
590c			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
590c			 
590c			 
590c .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
5930 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
5960 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
5985 .. 00		sound4: db ": cha $00 ; ",0 
5992 .. 00		sound5: db ": chb $20 ; ",0 
599f .. 00		sound6: db ": chc $40 ; ",0 
59ac .. 00		sound7: db ": chd $60 ; ",0 
59b9 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
59d1 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
59e8			 
59e8			 
59e8			 
59e8			 
59e8			; a small guess the number game 
59e8			 
59e8 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
59f9 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5a5b			 
5a5b .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5a90 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5ac6 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5af7 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5b0b .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5b20 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5b54 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5b98			 
5b98			; Using 'ga' save a high score across multiple runs using external storage 
5b98			 
5b98 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5c01			 
5c01			 
5c01			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5c01			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c01			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c01			 
5c01			; simple screen saver to test code memory reuse to destruction 
5c01			 
5c01 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5c37 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5c53 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5c6f .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5c88 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5cd0 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5d27			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d27			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5d27			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5d27			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5d27			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5d27			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5d27			 
5d27			 
5d27			 
5d27			; minesweeper/battleship finding game 
5d27			; draws a game board of random ship/mine positions 
5d27			; user enters coords to see if it hits on 
5d27			; game ends when all are hit 
5d27			; when hit or miss says how many may be in the area 
5d27			 
5d27			; setup the game board and then hide it 
5d27 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5d95 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5ddf			; prompt for where to target 
5ddf .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5e75 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5e9a			; TODO see if the entered coords hits or misses pushes char hit of miss 
5e9a .. 00		game2mbht:      db ": mbckht nop ;",0 
5ea9 .. 00		game2mbms:      db ": mbcms nop ;",0 
5eb7			; TODO how many might be near by 
5eb7 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5f34			 
5f34			; Game 3 
5f34			 
5f34			; Vert scroller ski game - avoid the trees! 
5f34			 
5f34			; v0 score (ie turns) 
5f34			; v1 player pos 
5f34			; v2 left wall 
5f34			; v3 right wall 
5f34			 
5f34			; Draw side walls randomly 
5f34			 
5f34 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5f62			 
5f62			; Draw player 
5f62 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5f80			 
5f80			; TODO Get Key 
5f80			 
5f80			; TODO Move left right 
5f80			 
5f80			; scroll and move walls a bit 
5f80			 
5f80 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5fb1			 
5fb1			; main game loop 
5fb1			 
5fb1 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5fdd .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
601c			 
601c			; key board defs 
601c			 
601c .. 00		keyup:       db ": keyup $05 ;",0 
602a .. 00		keydown:       db ": keydown $0a ;",0 
603a .. 00		keyleft:       db ": keyleft $0b ;",0 
604a .. 00		keyright:       db ": keyright $0c ;",0 
605b .. 00		keyf1:       db ": keyf1 $10 ;",0 
6069 .. 00		keyf2:       db ": keyf2 $11 ;",0 
6077 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6085 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6093 .. 00		keyf5:       db ": keyf5 $14 ;",0 
60a1 .. 00		keyf6:       db ": keyf6 $15 ;",0 
60af .. 00		keyf7:       db ": keyf7 $16 ;",0 
60bd .. 00		keyf8:       db ": keyf8 $17 ;",0 
60cb .. 00		keyf9:       db ": keyf9 $18 ;",0 
60d9 .. 00		keyf10:       db ": keyf10 $19 ;",0 
60e8 .. 00		keyf11:       db ": keyf11 $1a ;",0 
60f7 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6106			 
6106 .. 00		keytab:       db ": keytab $09 ;",0 
6115 .. 00		keycr:       db ": keycr $0d ;",0 
6123 .. 00		keyhome:       db ": keyhome $0e ;",0 
6133 .. 00		keyend:       db ": keyend $0f ;",0 
6142 .. 00		keybs:       db ": keybs $08 ;",0 
6150			 
6150			   
6150			 
6150			 
6150			 
6150			; eof 
# End of file forth_autostart.asm
6150			 
6150			 
6150			 
6150			; stack over and underflow checks 
6150			 
6150			; init the words to detect the under/overflow 
6150			 
6150			chk_stk_init: 
6150				; a vague random number to check so we dont get any "lucky" hits 
6150 3e 2d			ld a, 45 
6152 6f				ld l, a 
6153 00				nop 
6154 3e 17			ld a, 23 
6156 67				ld h, a 
6157			 
6157 22 9d e2			ld (chk_word), hl     ; the word we need to check against 
615a			 
615a			;	ld (chk_stund), hl	; stack points.... 
615a 22 00 ef			ld (chk_stovr), hl 
615d 22 ec e9			ld (chk_ret_und), hl 
6160 22 aa e9			ld (chk_ret_ovr), hl 
6163 22 28 e9			ld (chk_loop_ovr), hl 
6166 22 26 e8			ld (chk_data_ovr), hl 
6169 c9				ret 
616a				 
616a			check_stacks: 
616a				; check all stack words 
616a			 
616a e5				push hl 
616b d5				push de 
616c			 
616c			;	ld de,(chk_word) 
616c			;	ld hl, (chk_stund)	; stack points.... 
616c			;	if DEBUG_STK_FAULT 
616c			;		DMARK "FAa" 
616c			;		CALLMONITOR 
616c			;	endif 
616c			;	call cmp16 
616c			;	jp z, .chk_faulta 
616c			; 
616c			;	ld de, sfaultsu 
616c			;	jp .chk_fault 
616c			 
616c 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
616f ed 5b 9d e2		ld de,(chk_word) 
6173				if DEBUG_STK_FAULT 
6173					DMARK "FAb" 
6173					CALLMONITOR 
6173				endif 
6173 cd 04 0e			call cmp16 
6176 28 06			jr z, .chk_fault1 
6178 11 19 62			ld de, sfaultso 
617b c3 cd 61			jp .chk_fault 
617e			.chk_fault1:  
617e 2a ec e9			ld hl, (chk_ret_und) 
6181 ed 5b 9d e2		ld de,(chk_word) 
6185				if DEBUG_STK_FAULT 
6185					DMARK "FAU" 
6185					CALLMONITOR 
6185				endif 
6185 cd 04 0e			call cmp16 
6188 ca 91 61			jp z, .chk_fault2 
618b 11 29 62			ld de, sfaultru 
618e c3 cd 61			jp .chk_fault 
6191			.chk_fault2:  
6191 2a aa e9			ld hl, (chk_ret_ovr) 
6194 ed 5b 9d e2		ld de,(chk_word) 
6198				if DEBUG_STK_FAULT 
6198					DMARK "FA1" 
6198					CALLMONITOR 
6198				endif 
6198 cd 04 0e			call cmp16 
619b ca a4 61			jp z, .chk_fault3 
619e 11 37 62			ld de, sfaultro 
61a1 c3 cd 61			jp .chk_fault 
61a4			.chk_fault3:  
61a4 2a 28 e9			ld hl, (chk_loop_ovr) 
61a7 ed 5b 9d e2		ld de,(chk_word) 
61ab				if DEBUG_STK_FAULT 
61ab					DMARK "FA2" 
61ab					CALLMONITOR 
61ab				endif 
61ab cd 04 0e			call cmp16 
61ae ca b7 61			jp z, .chk_fault4 
61b1 11 51 62			ld de, sfaultlo 
61b4 c3 cd 61			jp .chk_fault 
61b7			.chk_fault4:  
61b7 2a 26 e8			ld hl, (chk_data_ovr) 
61ba ed 5b 9d e2		ld de,(chk_word) 
61be				if DEBUG_STK_FAULT 
61be					DMARK "FA3" 
61be					CALLMONITOR 
61be				endif 
61be cd 04 0e			call cmp16 
61c1 ca ca 61			jp z, .chk_fault5 
61c4 11 6b 62			ld de, sfaultdo 
61c7 c3 cd 61			jp .chk_fault 
61ca			 
61ca			 
61ca			.chk_fault5:  
61ca d1				pop de 
61cb e1				pop hl 
61cc			 
61cc c9				ret 
61cd			 
61cd cd b9 0b		.chk_fault: 	call clear_display 
61d0 3e 28				ld a, display_row_2 
61d2 cd cc 0b				call str_at_display 
61d5 11 fb 61				   ld de, .stackfault 
61d8 3e 00				ld a, display_row_1 
61da cd cc 0b				call str_at_display 
61dd 11 6b ee				    ld de, debug_mark 
61e0 3e 11				ld a, display_row_1+17 
61e2 cd cc 0b				call str_at_display 
61e5 cd dc 0b				call update_display 
61e8			 
61e8				; prompt before entering montior for investigating issue 
61e8			 
61e8 3e 78			ld a, display_row_4 
61ea 11 59 18			ld de, endprog 
61ed			 
61ed cd dc 0b			call update_display		 
61f0			 
61f0 cd df 1a			call next_page_prompt 
61f3			 
61f3 d1				pop de 
61f4 e1				pop hl 
61f5 cd ad 18				call monitor 
61f8 c3 b6 17				jp warmstart 
61fb					;jp 0 
61fb					;halt 
61fb			 
61fb			 
61fb			 
61fb .. 00		.stackfault: 	db "Stack fault:",0 
6208			 
6208 .. 00		sfaultsu: 	db	"Stack under flow",0 
6219 .. 00		sfaultso: 	db	"Stack over flow",0 
6229 .. 00		sfaultru:	db "RTS underflow",0 
6237 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6251 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
626b .. 00		sfaultdo:	db "DTS overflow", 0 
6278			 
6278			 
6278			fault_dsp_under: 
6278 11 8a 62			ld de, .dsp_under 
627b c3 3a 63			jp .show_fault 
627e			 
627e			fault_rsp_under: 
627e 11 98 62			ld de, .rsp_under 
6281 c3 3a 63			jp .show_fault 
6284			fault_loop_under: 
6284 11 a6 62			ld de, .loop_under 
6287 c3 3a 63			jp .show_fault 
628a			 
628a .. 00		.dsp_under: db "DSP Underflow",0 
6298 .. 00		.rsp_under: db "RSP Underflow",0 
62a6 .. 00		.loop_under: db "LOOP Underflow",0 
62b5			 
62b5			 
62b5 d5			type_faultn: 	push de 
62b6 e5					push hl 
62b7 cd b9 0b				call clear_display 
62ba 11 e1 62				   ld de, .typefaultn 
62bd 3e 00				ld a, display_row_1 
62bf cd cc 0b				call str_at_display 
62c2 11 6b ee				    ld de, debug_mark 
62c5 3e 11				ld a, display_row_1+17 
62c7 cd cc 0b				call str_at_display 
62ca cd dc 0b				call update_display 
62cd			 
62cd				; prompt before entering montior for investigating issue 
62cd			 
62cd 3e 78			ld a, display_row_4 
62cf 11 59 18			ld de, endprog 
62d2			 
62d2 cd dc 0b			call update_display		 
62d5			 
62d5 cd df 1a			call next_page_prompt 
62d8			 
62d8 e5					push hl 
62d9 d5					push de 
62da cd ad 18				call monitor 
62dd c3 b6 17				jp warmstart 
62e0 76					halt 
62e1			 
62e1			 
62e1 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
62f8			 
62f8 d5			type_faults: 	push de 
62f9 e5					push hl 
62fa cd b9 0b				call clear_display 
62fd 11 23 63				   ld de, .typefaults 
6300 3e 00				ld a, display_row_1 
6302 cd cc 0b				call str_at_display 
6305 11 6b ee				    ld de, debug_mark 
6308 3e 11				ld a, display_row_1+17 
630a cd cc 0b				call str_at_display 
630d cd dc 0b				call update_display 
6310			 
6310				; prompt before entering montior for investigating issue 
6310			 
6310 3e 78			ld a, display_row_4 
6312 11 59 18			ld de, endprog 
6315			 
6315 cd dc 0b			call update_display		 
6318			 
6318 cd df 1a			call next_page_prompt 
631b			 
631b e1					pop hl 
631c d1					pop de 
631d cd ad 18				call monitor 
6320 c3 b6 17				jp warmstart 
6323			 
6323			 
6323 .. 00		.typefaults: db "STR Type Expected TOS!",0 
633a			 
633a			.show_fault: 	 
633a d5					push de 
633b cd b9 0b				call clear_display 
633e d1					pop de 
633f 3e 00				ld a, display_row_1 
6341 cd cc 0b				call str_at_display 
6344 11 6b ee				    ld de, debug_mark 
6347 3e 11				ld a, display_row_1+17 
6349 cd cc 0b				call str_at_display 
634c cd dc 0b				call update_display 
634f			 
634f				; prompt before entering montior for investigating issue 
634f			 
634f 3e 78			ld a, display_row_4 
6351 11 59 18			ld de, endprog 
6354			 
6354 cd dc 0b			call update_display		 
6357			 
6357 cd df 1a			call next_page_prompt 
635a			 
635a e1					pop hl 
635b d1					pop de 
635c cd ad 18				call monitor 
635f			; do a dump to cli and not warmstart so we preserve all of the uwords.  
635f			; TODO Make optional fault restart to cli or warm boot? 
635f					;jp warmstart 
635f c3 00 18				jp cli 
6362 76					halt 
6363			 
6363			; handle the auto run of code from files in storage 
6363			 
6363			 
6363			include "forth_startup.asm" 
6363			; Which startup method to use? 
6363			; 
6363			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
6363			; followed by loading of a list of scripts in eeprom 
6363			 
6363			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
6363			; from eeprom 
6363			 
6363			; Select with define in main stubs 
6363			 
6363			if STARTUP_V1 
6363				include "forth_startupv1.asm" 
6363			; Startup script loading version 1 
6363			 
6363			; If SE storage is available first stage is to use the selected file 
6363			; then go through the eeprom list 
6363			 
6363 .. 00		sprompt1: db "Startup load...",0 
6373 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6389			 
6389			 
6389			 
6389			 
6389			forth_startup: 
6389 21 da 4d			ld hl, startcmds 
638c 3e 00			ld a, 0 
638e 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6391			 
6391 e5			.start1:	push hl 
6392 cd b9 0b			call clear_display 
6395 11 63 63			ld de, sprompt1 
6398 3e 00		        ld a, display_row_1 
639a cd cc 0b			call str_at_display 
639d 11 73 63			ld de, sprompt2 
63a0 3e 28		        ld a, display_row_2 
63a2 cd cc 0b			call str_at_display 
63a5 e1				pop hl 
63a6 e5				push hl 
63a7 5e				ld e,(hl) 
63a8 23				inc hl 
63a9 56				ld d,(hl) 
63aa 3e 50		        ld a, display_row_3 
63ac cd cc 0b			call str_at_display 
63af cd dc 0b			call update_display 
63b2			 
63b2			 
63b2 3a e7 e6			ld a, (os_last_cmd) 
63b5 fe 00			cp 0 
63b7 28 05			jr z, .startprompt 
63b9 cd e5 0a			call delay250ms 
63bc 18 24			jr .startdo 
63be				 
63be				 
63be			 
63be			.startprompt: 
63be			 
63be 3e 9f			ld a,display_row_4 + display_cols - 1 
63c0 11 dd 1a		        ld de, endprg 
63c3 cd cc 0b			call str_at_display 
63c6 cd dc 0b			call update_display 
63c9 cd f1 0a			call delay1s 
63cc cd 3b 65			call cin_wait 
63cf						 
63cf fe 2a			cp '*' 
63d1 28 5e			jr z, .startupend1 
63d3 fe 23			cp '#' 
63d5 20 07			jr nz, .startno 
63d7 3e 01			ld a, 1 
63d9 32 e7 e6			ld (os_last_cmd),a 
63dc 18 04			jr .startdo 
63de fe 31		.startno:	cp '1' 
63e0 28 3a			jr z,.startnxt  
63e2			 
63e2				; exec startup line 
63e2			.startdo:	 
63e2 e1				pop hl 
63e3 e5				push hl 
63e4				 
63e4 5e				ld e,(hl) 
63e5 23				inc hl 
63e6 56				ld d,(hl) 
63e7 eb				ex de,hl 
63e8			 
63e8 e5				push hl 
63e9			 
63e9 3e 00			ld a, 0 
63eb				;ld a, FORTH_END_BUFFER 
63eb cd 64 11			call strlent 
63ee 23				inc hl   ; include zero term to copy 
63ef 06 00			ld b,0 
63f1 4d				ld c,l 
63f2 e1				pop hl 
63f3 11 c1 e2			ld de, scratch 
63f6 ed b0			ldir 
63f8			 
63f8			 
63f8 21 c1 e2			ld hl, scratch 
63fb cd 62 1f			call forthparse 
63fe cd a2 1f			call forthexec 
6401 cd b4 1e			call forthexec_cleanup 
6404			 
6404 3e 78			ld a, display_row_4 
6406 11 59 18			ld de, endprog 
6409			 
6409 cd dc 0b			call update_display		 
640c			 
640c 3a e7 e6			ld a, (os_last_cmd) 
640f fe 00			cp 0 
6411 20 09			jr nz, .startnxt 
6413 cd df 1a			call next_page_prompt 
6416 cd b9 0b		        call clear_display 
6419 cd dc 0b			call update_display		 
641c			 
641c				; move onto next startup line? 
641c			.startnxt: 
641c			 
641c cd e5 0a			call delay250ms 
641f e1				pop hl 
6420			 
6420 23				inc hl 
6421 23				inc hl 
6422			 
6422 e5				push hl 
6423 5e				ld e, (hl) 
6424 23				inc hl 
6425 56				ld d, (hl) 
6426 e1				pop hl 
6427				; TODO replace 0 test 
6427			 
6427 eb				ex de, hl 
6428 cd 0f 0e			call ishlzero 
642b			;	ld a,e 
642b			;	add d 
642b			;	cp 0    ; any left to do? 
642b eb				ex de, hl 
642c c2 91 63			jp nz, .start1 
642f 18 01			jr .startupend 
6431			 
6431 e1			.startupend1: pop hl 
6432			.startupend: 
6432			 
6432 cd b9 0b			call clear_display 
6435 cd dc 0b			call update_display 
6438 c9				ret 
6439			if STORAGE_SE 
6439			 
6439			sprompt3: db "Loading from start-up file?:",0 
6439			sprompt4: db "(Y=Any key/N=No)",0 
6439			 
6439			 
6439			forth_autoload: 
6439			 
6439				; load block 0 of store 1 
6439				 
6439				ld a, $fe      ; bit 0 clear 
6439				ld (spi_device), a 
6439			 
6439				call storage_get_block_0 
6439			 
6439				ld a, (store_page+STORE_0_AUTOFILE) 
6439			 
6439				cp 0 
6439				ret z     ; auto start not enabled 
6439			 
6439				call clear_display 
6439			 
6439				; set bank 
6439			 
6439					ld a, (store_page+STORE_0_BANKRUN) 
6439					ld (spi_device), a 
6439			 
6439				; get file id to load from and get the file name to display 
6439			 
6439					ld a, (store_page+STORE_0_FILERUN) 
6439			 
6439					ld l, 0 
6439					ld h, a 
6439					ld de, store_page 
6439			 
6439					if DEBUG_FORTH_WORDS 
6439						DMARK "ASp" 
6439						CALLMONITOR 
6439					endif 
6439					call storage_read 
6439			 
6439					if DEBUG_FORTH_WORDS 
6439						DMARK "ASr" 
6439						CALLMONITOR 
6439					endif 
6439			 
6439					call ishlzero 
6439					ret z             ; file not found 
6439			 
6439					ld a, display_row_2 + 10 
6439					ld de, store_page+3 
6439					call str_at_display 
6439				 
6439			; 
6439			 
6439				ld a, display_row_1+5 
6439				ld de, sprompt3 
6439				call str_at_display 
6439				ld a, display_row_3+15 
6439				ld de, sprompt4 
6439				call str_at_display 
6439			 
6439				call update_display 
6439			 
6439				call cin_wait 
6439				cp 'n' 
6439				ret z 
6439				cp 'N' 
6439				ret z 
6439			 
6439				call delay1s 
6439			 
6439				ld a, (store_page+2) 
6439				ld (store_openmaxext), a    ; save count of ext 
6439				ld a, 1  
6439				ld (store_openext), a    ; save count of ext 
6439			 
6439			.autof:  
6439				ld l , a 
6439				 
6439				ld a, (store_page) 
6439				ld h, a	 
6439				ld de, store_page 
6439					if DEBUG_FORTH_WORDS 
6439						DMARK "ASl" 
6439						CALLMONITOR 
6439					endif 
6439					call storage_read 
6439				call ishlzero 
6439				ret z 
6439			;	jr z, .autoend 
6439			 
6439					if DEBUG_FORTH_WORDS 
6439						DMARK "ASc" 
6439						CALLMONITOR 
6439					endif 
6439				ld de, store_page+2 
6439				ld a, display_row_4 
6439				call str_at_display 
6439			 
6439				call update_display 
6439				call delay250ms 
6439			 
6439			 
6439			 
6439				ld hl, store_page+2 
6439				call forthparse 
6439				call forthexec 
6439				call forthexec_cleanup 
6439			 
6439				 
6439				ld a, (store_openext) 
6439				inc a 
6439				ld (store_openext), a    ; save count of ext 
6439			 
6439				jr .autof 
6439			;.autofdone: 
6439			; 
6439			;		if DEBUG_FORTH_WORDS 
6439			;			DMARK "ASx" 
6439			;			CALLMONITOR 
6439			;		endif 
6439			;;	call clear_display 
6439			;	ret 
6439			 
6439			 
6439			 
6439			endif 
# End of file forth_startupv1.asm
6439			endif 
6439			if STARTUP_V2 
6439				include "forth_startupv2.asm" 
6439			endif 
6439			 
# End of file forth_startup.asm
6439			 
6439			; eof 
# End of file forth_kernel.asm
6439			;include "nascombasic.asm" 
6439			 
6439			 
6439			; find out where the code ends if loaded into RAM (for SC114) 
6439			;endofcode:  
6439			;	nop 
6439			 
6439			 
6439			; jump to nmi vector 
6439			 
6439			init_nmi: 
6439 3e c9			ld a, $c9   ; RET 
643b 32 72 ee			ld (nmi_vector), a 
643e c9				ret 
643f			nmi: 
643f e5				push hl 
6440 d5				push de 
6441 c5				push bc 
6442 f5				push af 
6443 cd 72 ee			call nmi_vector 
6446 f5				push af 
6447 c5				push bc 
6448 d5				push de 
6449 e5				push hl 
644a ed 4d			reti 
644c			 
644c			 
644c			; eof 
644c			 
# End of file main.asm
644c			;include "firmware_lcd_4x40.asm" 
644c			;;include "firmware_lcd_4x20.asm" 
644c			include "firmware_cpm_display.asm" 
644c			 
644c			; Serial display interface for SC114 
644c			 
644c			 
644c			display_row_1: equ 0 
644c			display_row_2: equ display_row_1+display_cols 
644c			display_row_3: equ display_row_2 + display_cols 
644c			display_row_4: equ display_row_3 + display_cols 
644c			 
644c			kLCDWidth:  EQU display_cols             ;Width in characters 
644c			kLCD_Line1: EQU 0x00  
644c			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
644c			; E1 
644c			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
644c			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
644c			 
644c			lcd_init: 
644c				; no init as handled by the SCM bios 
644c c9				ret 
644d			 
644d			 
644d			; low level functions for direct screen writes 
644d			 
644d			; output char at pos? 
644d			fLCD_Str: 
644d			        ;out (SC114_SIO_1_OUT),a 
644d c5				push bc 
644e d5				push de 
644f 5f				ld e, a 
6450			; TODO Replace with CP/M BIOS call 
6450 0e 02			ld c, $02 
6452 cd 05 00			call 5 
6455 d1				pop de 
6456 c1				pop bc 
6457 c9				ret 
6458			 
6458			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
6458			fLCD_Pos: 
6458				; use ASCII escape to position 
6458			        ;out (SC114_SIO_1_OUT),a 
6458 c5				push bc 
6459 d5				push de 
645a 5f				ld e, a 
645b 0e 02			ld c, $02 
645d			; TODO Replace with CP/M BIOS call 
645d cd 05 00			call 5 
6460 d1				pop de 
6461 c1				pop bc 
6462			 
6462 c9				ret 
6463			 
6463			; output char at pos 
6463			fLCD_Data: 
6463			      ;  out (SC114_SIO_1_OUT),a 
6463 c5				push bc 
6464 d5				push de 
6465 0e 02			ld c, $02 
6467 5f				ld e, a 
6468			; TODO Replace with CP/M BIOS call 
6468 cd 05 00			call 5 
646b d1				pop de 
646c c1				pop bc 
646d			 
646d c9				ret 
646e			 
646e			; ascii cls  
646e			 
646e 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
6472			 
6472 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
6489			;.clscpm: db 3, $3c,"$" 
6489			 
6489			; write the frame buffer given in hl to hardware  
6489			write_display: 
6489			 
6489			API: equ 0 
6489			 
6489			if API 
6489				push bc 
6489				ld b, 4 
6489			 
6489			        ld (display_write_tmp), hl 	  
6489			 
6489				; clear and home cursor 
6489			 
6489				ld c, 9 
6489				ld de, .cls 
6489			; TODO Replace with CP/M BIOS call 
6489				call 5 
6489			 
6489			 
6489			.writeln: 
6489			 
6489				ld de, (display_write_tmp) 
6489				ld c, 6 
6489			; TODO Replace with CP/M BIOS call 
6489				rst $30 
6489				ld c, 7 
6489				rst $30 
6489			 
6489				ld hl, (display_write_tmp) 
6489				ld de, display_cols 
6489				add hl,de 
6489				ld (display_write_tmp),hl 
6489			 
6489				djnz  .writeln 
6489			 
6489				pop bc 
6489			 
6489			 
6489				ret 
6489			endif 
6489 e5				push hl 
648a c5				push bc 
648b d5				push de 
648c			 
648c			;	ld c, 2 
648c			;	;ld de, .cls 
648c			;	ld a, 27 
648c			;	rst $30 
648c			;	ld c, 2 
648c			;	;ld de, .cls 
648c			;	ld a, '[' 
648c			;	rst $30 
648c			; 
648c			;	ld c, 2 
648c			;	;ld de, .cls 
648c			;	ld a, 'H' 
648c			;	rst $30 
648c			; 
648c			 
648c			 
648c			; lots of CR/LF 
648c			;	ld c, 9 
648c			;	ld de, .clscpm 
648c			;	call 5 
648c			 
648c			; xterm cls 
648c 0e 02			ld c, 2 
648e 1e 1b			ld e, 27 
6490 cd 05 00			call 5 
6493			; cls causes too much flicker 
6493			;	ld c, 2 
6493			;	ld e, 'c' 
6493			;	call 5 
6493			 
6493			; use xterm home instead 
6493 0e 02			ld c, 2 
6495 1e 5b			ld e, '[' 
6497 cd 05 00			call 5 
649a 0e 02			ld c, 2 
649c 1e 48			ld e, 'H' 
649e cd 05 00			call 5 
64a1			LLL: equ 0 
64a1			 
64a1			if LLL 
64a1			 
64a1				ld c, 2 
64a1				;ld de, .cls 
64a1				ld e, 27 
64a1			; TODO Replace with CP/M BIOS call 
64a1				call 5 
64a1			 
64a1			 
64a1				ld c, 2 
64a1				;ld de, .cls 
64a1				ld e, '[' 
64a1			; TODO Replace with CP/M BIOS call 
64a1				call 5 
64a1				ld c, 2 
64a1				;ld de, .cls 
64a1				ld e, '2' 
64a1			; TODO Replace with CP/M BIOS call 
64a1				call 5 
64a1				ld c, 2 
64a1				;ld de, .cls 
64a1				ld e, 'J' 
64a1			; TODO Replace with CP/M BIOS call 
64a1				call 5 
64a1			 
64a1			endif 
64a1			 
64a1 d1				pop de 
64a2 c1				pop bc 
64a3 e1				pop hl 
64a4			 
64a4			 
64a4 22 c9 eb		        ld (display_write_tmp), hl 	  
64a7 3e 00			ld a, kLCD_Line1 
64a9			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
64a9 06 28			ld b, display_cols 
64ab ed 5b c9 eb		ld de, (display_write_tmp) 
64af cd 32 65			call write_len_string 
64b2				 
64b2			 
64b2 e5			push hl 
64b3 d5			push de 
64b4 c5			push bc 
64b5 0e 02			ld c, 2 
64b7 1e 0a			ld e, 10 
64b9 cd 05 00			call 5 
64bc 0e 02			ld c, 2 
64be 1e 0d			ld e, 13 
64c0 cd 05 00			call 5 
64c3			; TODO Replace with CP/M BIOS call 
64c3				;rst $30 
64c3 c1			pop bc 
64c4 d1			pop de 
64c5 e1			pop hl 
64c6			 
64c6				 
64c6 2a c9 eb			ld hl, (display_write_tmp) 
64c9 11 28 00			ld de, display_cols 
64cc 19				add hl,de 
64cd 22 c9 eb			ld (display_write_tmp),hl 
64d0			 
64d0				 
64d0 3e 28			ld a, kLCD_Line2 
64d2			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
64d2 06 28			ld b, display_cols 
64d4 ed 5b c9 eb		ld de, (display_write_tmp) 
64d8 cd 32 65			call write_len_string 
64db				 
64db 2a c9 eb			ld hl, (display_write_tmp) 
64de 11 28 00			ld de, display_cols 
64e1 19				add hl,de 
64e2 22 c9 eb			ld (display_write_tmp),hl 
64e5			 
64e5 e5			push hl 
64e6 d5			push de 
64e7 c5			push bc 
64e8 0e 07			ld c, 7 
64ea			; TODO Replace with CP/M BIOS call 
64ea				;rst $30 
64ea 0e 02			ld c, 2 
64ec 1e 0a			ld e, 10 
64ee cd 05 00			call 5 
64f1 0e 02			ld c, 2 
64f3 1e 0d			ld e, 13 
64f5 cd 05 00			call 5 
64f8 c1			pop bc 
64f9 d1			pop de 
64fa e1			pop hl 
64fb			 
64fb				 
64fb 3e 50			ld a, kLCD_Line3 
64fd			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
64fd 06 28			ld b, display_cols 
64ff ed 5b c9 eb		ld de, (display_write_tmp) 
6503 cd 32 65			call write_len_string 
6506				 
6506 2a c9 eb			ld hl, (display_write_tmp) 
6509 11 28 00			ld de, display_cols 
650c 19				add hl,de 
650d 22 c9 eb			ld (display_write_tmp),hl 
6510			 
6510 e5			push hl 
6511 d5			push de 
6512 c5			push bc 
6513 0e 07			ld c, 7 
6515			; TODO Replace with CP/M BIOS call 
6515				;rst $30 
6515 0e 02			ld c, 2 
6517 1e 0a			ld e, 10 
6519 cd 05 00			call 5 
651c 0e 02			ld c, 2 
651e 1e 0d			ld e, 13 
6520 cd 05 00			call 5 
6523 c1			pop bc 
6524 d1			pop de 
6525 e1			pop hl 
6526			 
6526				 
6526 3e 78			ld a, kLCD_Line4 
6528			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
6528 06 28			ld b, display_cols 
652a ed 5b c9 eb		ld de, (display_write_tmp) 
652e cd 32 65			call write_len_string 
6531 c9					ret 
6532			 
6532			 
6532				; write out a fixed length string given in b from de 
6532			 
6532 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
6533 cd 63 64		            CALL fLCD_Data      ;Write character to display 
6536 13				inc de 
6537 10 f9			djnz write_len_string 
6539 c9				ret 
653a			 
653a			 
653a			; eof 
# End of file firmware_cpm_display.asm
653a			;include "firmware_key_5x10.asm" 
653a			;;include "firmware_key_4x10.asm" 
653a			include "firmware_key_cpm.asm" 
653a			; Serial keyboard interface for SC114 
653a			 
653a			 
653a			key_init: 
653a				; no init as handled by the SCM bios 
653a c9				ret 
653b			 
653b			 
653b			cin_wait: 
653b			;	ld a, 0 
653b			;	ret 
653b			 
653b				;in a,(SC114_SIO_1_IN) 
653b			        ; Use SCM API to get from whatever console device we are using 
653b			 
653b			; TODO Replace with CP/M BIOS call 
653b c5				push bc 
653c 0e 01			ld c, $01 
653e cd 05 00			call 5 
6541 c1				pop bc 
6542 c9				ret 
6543			 
6543			cin: 
6543			 
6543			 
6543 c5				push bc 
6544			 
6544				; any key waiting to process? 
6544			; TODO Replace with CP/M BIOS call 
6544 0e 06			ld c, $06 
6546 cd 05 00			call 5 
6549 28 0d			jr z, .cin_skip 
654b			 
654b				; yep, get it 
654b			 
654b 0e 01			ld c, $01 
654d			; TODO Replace with CP/M BIOS call 
654d cd 05 00			call 5 
6550			 
6550 fe 7f			cp $7f     ; back space 
6552 20 02			jr nz, .skipbs 
6554 3e 08			ld a, KEY_BS 
6556			.skipbs: 
6556			 
6556 c1				pop bc 
6557 c9				ret 
6558			.cin_skip: 
6558 3e 00			ld a, 0 
655a c1				pop bc 
655b c9				ret 
655c			 
655c			 
655c			 
655c			 
# End of file firmware_key_cpm.asm
655c			endofcode:  
655c			baseram:  
655c 00				nop 
655d			 
655d			heap_start: equ baseram+15  ; Starting address of heap 
655d			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
655d			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
655d			;VDU:  EQU     endofcode           ; BASIC Work space 
655d			; eof 
655d			 
# End of file os_mega_cpm.asm
655d
