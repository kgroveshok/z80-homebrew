# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 79 17			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 ..			buildtime: db   "Build: " 
010a					include "romtimestamp.asm" 
010a ..			db '2025-08-11 12:11' 
# End of file romtimestamp.asm
011a 00				   db 0 
011b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
011f			 
011f			 
011f			 
011f			;        nop  
011f			;        nop 
011f			;;	org 05h		; null out bdos call 
011f			; 
011f			;        nop  
011f			;        nop  
011f			;        nop 
011f			;;	org 08h 
011f			;;; 
011f			;;	jp cin		; rst 8 - char in 
011f			;;; 
011f			; 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;	org 010h 
011f			;; 
011f			;	jp cout		; rest 010h  - char out 
011f			;; 
011f			;	org 01bh   
011f			; 
011f			;	;jp  		; rst 01bh   - write string to display 
011f			;	jp str_at_display 
011f			; 
011f			; 
011f			;	org 020h 
011f			; 
011f			;	; jp		 ; rst 020h - read char at screen location 
011f			; 
011f			;	org 028h 
011f			 
011f				; jp		 ; rst 028h  - storage i/o 
011f			 
011f			; 	org 030h 
011f			;	jp break_point_state 
011f			  
011f			; $30  
011f			; org 038h 
011f			; $38 
011f			 
011f			; TODO any more important entry points to add to jump table for easier coding use? 
011f			 
011f			if BASE_KEV = 1  
011f			 
011f				; need to be at $66 for nmi support 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255 
011f				jp nmi 
011f			endif 
011f			 
011f			include "firmware.asm" 
011f			  
011f			; main constants (used here and in firmware)  
011f			  
011f			; TODO have page 0 of storage as bios  
011f			  
011f			Device_A: equ 0h  
011f			Device_B: equ 040h          ; Sound  
011f			  
011f			if BASE_KEV  
011f			Device_C: equ 080h          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			if BASE_SC114  
011f			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			if BASE_CPM  
011f			; TODO fixup for CPM  
011f			Device_C: equ 080h          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			Device_D: equ 0c0h             ; Keyboard and LCD  
011f			  
011f			; Odd specific debug points for testing hardware dev  
011f			  
011f			;if DEBUG_LEVEL0  
011f			;	include "debug_level0.asm"  
011f			;endif  
011f			;if DEBUG_LEVEL1  
011f			;	include "debug_level1.asm"  
011f			;endif  
011f			;if DEBUG_LEVEL2  
011f			;	include "debug_level2.asm"  
011f			;endif  
011f			  
011f			  
011f			CALLMONITOR: macro  
011f			;	call break_point_state  
011f			; now use the break point debug vector  
011f				call debug_vector  
011f				endm  
011f			  
011f			MALLOC_1: equ 1        ; from dk88   
011f			MALLOC_2: equ 0           ; broke  
011f			MALLOC_3: equ 0           ; really broke  
011f			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011f			  
011f			if BASE_KEV   
011f			;stacksize: equ 256  
011f			; each stack entry is three bytes (type + word)  
011f			stacksize: equ 3*150  
011f			  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 512  
011f			endif  
011f			if BASE_SC114  
011f			;tos:	equ 0f000h  
011f			stacksize: equ 256  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 256  
011f			endif  
011f			  
011f			if BASE_CPM  
011f			;tos:	equ 0f000h  
011f			stacksize: equ 256  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 256  
011f			endif  
011f			  
011f			;if STORAGE_SE == 0  
011f			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011f			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011f			;endif  
011f			  
011f			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011f			  
011f			STORE_0_AUTORUN: equ $20  
011f			  
011f			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011f			  
011f			STORE_0_AUTOFILE: equ $21  
011f			STORE_0_BANKRUN: equ $23  
011f			STORE_0_FILERUN: equ $24  
011f			  
011f			; Block 0 offsets for settings  
011f			  
011f			; if set then skip prompt for start up and accept all  
011f			  
011f			STORE_0_QUICKSTART: equ $25  
011f			  
011f			; Blocks where directory table is held  
011f			  
011f			; Reducing the number of entries increases the max file size  
011f			  
011f			;STORE_DIR_START: equ 1  
011f			;STORE_DIR_END: equ 33  
011f			  
011f			; Blocks from where file data is stored  
011f			  
011f			;STORE_DATA_START: equ STORE_DIR_END + 1  
011f			  
011f			; Block indicators (<32 are data files)  
011f			  
011f			;STORE_BLOCK_CFG: equ $8f       ; config block  
011f			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011f			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011f			;STORE_BLOCK_FREE: equ $85       ; data block free  
011f			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011f			  
011f			  
011f			  
011f			; Directory entry flags  
011f			  
011f			;STORE_DIR_FREE: equ 0  
011f			;STORE_DIR_FILE:  equ 1  
011f			  
011f			; Structure offsets to directory entries  
011f			;STORE_DE_FLAG: equ 0  
011f			;STORE_DE_MAXEXT: equ 1  
011f			;STORE_DE_FILENAME: equ 2  
011f			  
011f			; Structure offsets to block 0  
011f			  
011f			;STORE_BK0_ISFOR: equ 1  
011f			;STORE_BK0_LABEL: equ 3  
011f			  
011f			; memory allocation   
011f			  
011f			chk_stund: equ tos+2           ; underflow check word  
011f			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011f			  
011f			; keyscan table needs rows x cols buffer  
011f			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011f			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011f			  
011f			keyscan_table_row1: equ chk_stovr -key_cols-1  
011f			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011f			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011f			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011f			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011f			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011f			keyscan_scancol: equ keyscan_table-key_cols  
011f			;keyscan_table_len: equ key_rows*key_cols  
011f			;keybufptr: equ keyscan_table - 2  
011f			;keysymbol: equ keybufptr - 1  
011f			key_held: equ keyscan_scancol-1	; currently held  
011f			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011f			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011f			key_fa: equ key_repeat_ct -1 ;  
011f			key_fb: equ key_fa -1 ;  
011f			key_fc: equ key_fb -1 ;  
011f			key_fd: equ key_fc -1 ;  
011f			key_face_held: equ key_fd - 1   
011f			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011f			  
011f			hardware_config: equ key_face_held - 10  
011f			  
011f			; hardware config switches  
011f			; TODO add bitmasks on includes for hardware  
011f			; high byte for expansion ids  
011f			;     0000 0000  no card inserted  
011f			;     0000 0001  storage card inserted  
011f			;     0000 0010  spi sd card active  
011f			  
011f			;       
011f			; low byte:  
011f			;     0000 0001   4x4 keypad  
011f			;     0000 0010   full keyboard  
011f			;     0000 0011   spi/ext keyboard  
011f			;     0000 0100   20x4 lcd  
011f			;     0000 1000   40x4 lcd  
011f			;     0000 1100   spi/ext display  
011f			;     0001 0000   ide interface available  
011f			  
011f			hardware_word: equ hardware_config - 2  
011f			  
011f			; debug marker - optional display of debug point on the debug screens  
011f			  
011f			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011f			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011f			  
011f			debug_mark: equ debug_vector - 4  
011f			  
011f			; input_str vars  
011f			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011f			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011f			input_size: equ input_start -1  ; number of chars  
011f			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011f			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011f			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011f			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011f			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011f			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011f			input_len: equ input_cur_onoff - 5 ; length of current input  
011f			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011f			  
011f			; cursor blink rate  
011f			CUR_BLINK_RATE: equ $09  
011f			;CUR_BLINK_RATE: equ 15  
011f			  
011f			key_actual_pressed: equ input_cursor - 1   
011f			key_symbol: equ key_actual_pressed - 1   
011f			key_shift: equ key_symbol - 1   
011f			  
011f			; Display allocation  
011f			  
011f			;display_rows: equ 4     ; move out to mini and mega files  
011f			;display_cols: equ 20  
011f			  
011f			display_fb_len: equ display_rows*display_cols  
011f			  
011f			; primary frame buffer     
011f			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011f			; working frame buffers  
011f			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011f			display_fb3: equ  display_fb1-display_fb_len - 1  
011f			display_fb2: equ  display_fb3-display_fb_len - 1  
011f			;  
011f			; pointer to active frame buffer  
011f			display_fb_active: equ display_fb2 - 2  
011f			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011f			display_write_tmp: equ display_lcde1e2 - 2  
011f			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011f			  
011f			;  
011f			  
011f			;; can load into de directory  
011f			cursor_col: equ display_active-1  
011f			cursor_row: equ cursor_col-1  
011f			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011f			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011f			  
011f			; maths vars  
011f			  
011f			LFSRSeed: equ cursor_shape -20   
011f			randData: equ LFSRSeed - 2  
011f			xrandc: equ randData - 2  
011f			stackstore: equ xrandc - 2  
011f			seed1: equ  stackstore -2   
011f			seed2: equ seed1 - 2  
011f			  
011f			; cf storage vars  
011f			  
011f			iErrorNum:  equ seed2-1         ;Error number  
011f			iErrorReg:  equ iErrorNum -1              ;Error register  
011f			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011f			  
011f			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011f			  
011f			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011f			  
011f			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011f			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011f			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011f			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011f			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011f			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011f			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011f			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011f			store_tmpid: equ store_tmp3 - 1		; page temp id  
011f			store_tmpext: equ store_tmpid - 1		; file extent temp  
011f			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011f			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011f			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011f			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011f			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011f			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011f			;  
011f			; spi vars  
011f			  
011f			  
011f			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011f			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011f			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011f			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011f			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011f			spi_device_id: equ spi_device - 1    ; human readable bank number  
011f			  
011f			;;;;; forth cli params  
011f			  
011f			; TODO use a different frame buffer for forth???  
011f			  
011f			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011f			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011f			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011f			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011f			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011f			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011f			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011f			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011f			  
011f			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011f			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011f			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011f			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011f			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011f			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011f			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011f			  
011f			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011f			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011f			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011f			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011f			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011f			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011f			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011f			  
011f			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011f			  
011f			; os/forth token vars  
011f			  
011f			os_last_cmd: equ os_var_array-255  
011f			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011f			os_current_i: equ os_cli_cmd-2  
011f			os_cur_ptr: equ os_current_i-2  
011f			os_word_scratch: equ os_cur_ptr-30  
011f			os_tok_len: equ os_word_scratch - 2  
011f			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011f			os_tok_malloc: equ os_tok_ptr - 2  
011f			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011f			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011f			execscratch: equ os_input-255        ; exec cmd eval buffer  
011f			scratch: equ execscratch-255  
011f			  
011f			os_stack_1: equ scratch - 3       ; stack holding area 1  
011f			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
011f			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
011f			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
011f			  
011f			  
011f			; temp locations for new word processing to save on adding more   
011f			  
011f			os_new_malloc: equ os_stack_4-2  
011f			os_new_parse_len: equ os_new_malloc - 2  
011f			os_new_word_len: equ os_new_parse_len - 2  
011f			os_new_work_ptr: equ os_new_word_len - 2  
011f			os_new_src_ptr: equ os_new_work_ptr - 2  
011f			os_new_exec: equ os_new_src_ptr - 2  
011f			os_new_exec_ptr: equ os_new_exec - 2  
011f			  
011f			; resume memory alloocations....  
011f			  
011f			;os_view_disable: equ os_new_exec_ptr - 1  
011f			os_view_af: equ os_new_exec_ptr - 2  
011f			os_view_hl: equ os_view_af -2  
011f			os_view_de: equ os_view_hl - 2  
011f			os_view_bc: equ os_view_de - 2  
011f			  
011f			; stack checksum word  
011f			if DEBUG_STACK_IMB  
011f				curframe: equ  os_view_de - 5  
011f				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011f				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011f			else  
011f				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011f			endif  
011f			  
011f			; with data stack could see memory filled with junk. need some memory management   
011f			; malloc and free entry points added  
011f			  
011f			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011f			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011f			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			;heap_end: equ free_list-1  ; Starting address of heap  
011f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			  
011f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			heap_end: equ chk_word-1  ; Starting address of heap  
011f			  
011f			  
011f			;if BASE_KEV   
011f			;heap_start: equ 0800eh  ; Starting address of heap  
011f			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011f			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011f			;endif  
011f			  
011f			;if BASE_SC114  
011f			;heap_start: equ baseram+15  ; Starting address of heap  
011f			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011f			;endif  
011f			  
011f			  
011f			;;;;  
011f			  
011f			  
011f			; change below to point to last memory alloc above  
011f			topusermem:  equ   heap_start  
011f			  
011f			;if BASE_KEV   
011f			;baseusermem: equ 08000h  
011f			;endif  
011f			  
011f			;if BASE_SC114  
011f			;;aseusermem:     equ    12  
011f			;baseusermem:     equ    prompt  
011f			;;baseusermem:     equ    endofcode  
011f			;endif  
011f			  
011f			  
011f			; **********************************************************************  
011f			; **  Constants  
011f			; **********************************************************************  
011f			  
011f			; Constants used by this code module  
011f			kDataReg:   EQU Device_D           ;PIO port A data register  
011f			kContReg:   EQU Device_D+2           ;PIO port A control register  
011f			  
011f			  
011f			portbdata:  equ Device_D+1    ; port b data  
011f			portbctl:   equ Device_D+3    ; port b control  
011f			  
011f			  
011f			;KEY_SHIFT:   equ 5  
011f			;KEY_SYMBOLSHIFT:  equ 6  
011f			  
011f			KEY_SHIFTLOCK: equ 4  
011f			  
011f			  
011f			KEY_UP: equ 5  
011f			KEY_NEXTWORD: equ 6  
011f			KEY_PREVWORD: equ 7  
011f			KEY_BS: equ 8  
011f			KEY_TAB:  equ 9  
011f			KEY_DOWN: equ 10  
011f			KEY_LEFT: equ 11  
011f			KEY_RIGHT: equ 12  
011f			KEY_CR:   equ 13  
011f			KEY_HOME: equ 14  
011f			KEY_END: equ 15  
011f			  
011f			KEY_F1: equ 16  
011f			KEY_F2: equ 17  
011f			KEY_F3: equ 18  
011f			KEY_F4: equ 19  
011f			  
011f			KEY_F5: equ 20  
011f			KEY_F6: equ 21  
011f			KEY_F7: equ 22  
011f			KEY_F8: equ 23  
011f			  
011f			KEY_F9: equ 24  
011f			KEY_F10: equ 25  
011f			KEY_F11: equ 26  
011f			KEY_F12: equ 27  
011f			  
011f			;if DEBUG_KEY  
011f			;	KEY_MATRIX_NO_PRESS: equ '.'  
011f			;	KEY_SHIFT:   equ '.'  
011f			;	KEY_SYMBOLSHIFT:  equ '.'  
011f			;else  
011f				KEY_SHIFT:   equ '~'  
011f				KEY_SYMBOLSHIFT:  equ '~'  
011f				KEY_MATRIX_NO_PRESS: equ '~'  
011f			;endi  
011f			  
011f			  
011f			  
011f			  
011f			; Macro to make adding debug marks easier  
011f			  
011f			DMARK: macro str  
011f				push af  
011f				ld a, (.dmark)  
011f				ld (debug_mark),a  
011f				ld a, (.dmark+1)  
011f				ld (debug_mark+1),a  
011f				ld a, (.dmark+2)  
011f				ld (debug_mark+2),a  
011f				jr .pastdmark  
011f			.dmark: db str  
011f			.pastdmark: pop af  
011f			  
011f			endm  
011f			  
011f			  
011f			; macro to detect for stack imbalances  
011f			  
011f			include "stackimbal.asm"  
011f			; Macro and code to detect stock imbalances 
011f			 
011f			SPPUSH: equ 0 
011f			 
011f			; Add a stack frame which can be checked before return 
011f			 
011f			STACKFRAME: macro onoff frame1 frame2 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						; save current SP 
011f						exx 
011f			 
011f						ld de, frame1 
011f						ld a, d 
011f						ld hl, curframe 
011f						call hexout 
011f						ld a, e 
011f						ld hl, curframe+2 
011f						call hexout 
011f			  
011f						ld hl, frame1 
011f						push hl 
011f						ld hl, frame2 
011f						push hl 
011f						exx 
011f					endif 
011f					 
011f				endif 
011f			endm 
011f			 
011f			STACKFRAMECHK: macro onoff frame1 frame2 
011f			 
011f					 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						exx 
011f						; check stack frame SP 
011f			 
011f						ld hl, frame2 
011f						pop de   ; frame2 
011f			 
011f						call cmp16 
011f						jr nz, .spnosame 
011f						 
011f			 
011f						ld hl, frame1 
011f						pop de   ; frame1 
011f			 
011f						call cmp16 
011f						jr z, .spfrsame 
011f			 
011f						.spnosame: call showsperror 
011f			 
011f						.spfrsame: nop 
011f			 
011f						exx 
011f					endif 
011f					 
011f				endif 
011f			 
011f			 
011f			endm 
011f			 
011f			 
011f			; for a sub routine, wrap SP collection and comparisons 
011f			 
011f			; Usage: 
011f			; 
011f			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011f			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011f			 
011f			SAVESP: macro onoff storeword 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						; save current SP 
011f			 
011f						ld (store_sp+(storeword*4)), sp 
011f			 
011f					endif 
011f					 
011f				endif 
011f			 
011f			endm 
011f			 
011f			CHECKSP: macro onoff storeword 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f			 
011f						; save SP after last save 
011f				 
011f						ld (store_sp+(storeword*4)+2), sp 
011f			 
011f						push hl 
011f						ld hl, store_sp+(storeword*4) 
011f						call check_stack_sp  
011f						pop hl 
011f			 
011f			 
011f					endif 
011f					 
011f				endif 
011f			 
011f			endm 
011f			 
011f			if DEBUG_STACK_IMB 
011f			 
011f			check_stack_sp: 
011f					push de 
011f			 
011f					ld e, (hl) 
011f					inc hl 
011f					ld d, (hl) 
011f					inc hl 
011f			 
011f					push de 
011f			 
011f			 
011f					ld e, (hl) 
011f					inc hl 
011f					ld d, (hl) 
011f					inc hl 
011f			 
011f					pop hl 
011f			 
011f			 
011f					; check to see if the same 
011f			 
011f					call cmp16 
011f					jr z, .spsame 
011f			 
011f					; not same 
011f			 
011f					call showsperror 
011f			.spsame: 
011f			 
011f					pop de 
011f			 
011f					ret 
011f			 
011f			.sperr:  db "Stack imbalance",0 
011f			 
011f			 
011f			showsperror: 
011f			 
011f			 
011f				push hl 
011f				push af 
011f				push de 
011f				call clear_display 
011f				ld de, .sperr 
011f				ld a,0 
011f			;	ld de,os_word_scratch 
011f				call str_at_display 
011f				ld a, display_row_1+17 
011f				ld de, debug_mark 
011f				call str_at_display 
011f				ld a, 0 
011f				ld (curframe+4),a 
011f				ld hl, curframe 
011f				ld de, os_word_scratch 
011f				ld a, display_row_4 
011f				call str_at_display 
011f				call update_display 
011f				;call break_point_state 
011f				call cin_wait 
011f			 
011f			;	ld a, ' ' 
011f			;	ld (os_view_disable), a 
011f				call bp_on 
011f				pop de	 
011f				pop af 
011f				pop hl 
011f				CALLMONITOR 
011f				ret 
011f			 
011f			endif 
011f			 
011f			 
011f			 
011f			; eof 
# End of file stackimbal.asm
011f			  
011f			;TODO macro to calc col and row offset into screen  
011f			  
011f			  
011f			  
011f			hardware_init:  
011f			  
011f				  
011f			  
011f					;ld a, 0  
011f					;ld (hardware_diag), a  
011f			  
011f					; clear all the buffers  
011f			  
011f 21 10 ed				ld hl, display_fb1  
0122 22 cc eb				ld (display_fb_active), hl  
0125			  
0125 cd c5 0b				call clear_display  
0128			  
0128 21 ce eb				ld hl, display_fb2  
012b 22 cc eb				ld (display_fb_active), hl  
012e			  
012e cd c5 0b				call clear_display  
0131			  
0131					; init primary frame buffer area  
0131 21 b1 ed				ld hl, display_fb0  
0134 22 cc eb				ld (display_fb_active), hl  
0137			  
0137 cd c5 0b				call clear_display  
013a			  
013a			  
013a cd 79 5d				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013d			  
013d cd 67 5e			call key_init  
0140 cd aa 01			call storage_init  
0143			  
0143				; setup malloc functions  
0143			  
0143				if MALLOC_1  
0143 cd a9 11				call  heap_init  
0146				endif  
0146				if MALLOC_4  
0146					call  heap_init  
0146				endif  
0146			  
0146				; init sound hardware if present  
0146			  
0146				if SOUND_ENABLE  
0146					call sound_init  
0146				endif  
0146			  
0146				; lcd test sequence  
0146					  
0146 cd e8 0b			call update_display  
0149 cd fd 0a			call delay1s  
014c 3e 2b			ld a,'+'  
014e cd ca 0b			call fill_display  
0151 cd e8 0b			call update_display  
0154 cd fd 0a			call delay1s  
0157 3e 2a			ld a,'*'  
0159 cd ca 0b			call fill_display  
015c cd e8 0b			call update_display  
015f cd fd 0a			call delay1s  
0162 3e 2d			ld a,'-'  
0164 cd ca 0b			call fill_display  
0167 cd e8 0b			call update_display  
016a cd fd 0a			call delay1s  
016d			  
016d			; boot splash screen  
016d			if display_cols == 20	  
016d			        ld a, display_row_1    
016d			else  
016d 3e 0a		        ld a, display_row_1 +10   
016f			endif  
016f 11 d7 16			ld de, prom_bootmsg  
0172 cd d8 0b			call str_at_display  
0175 cd e8 0b			call update_display  
0178			  
0178			  
0178 cd fd 0a			call delay1s  
017b cd fd 0a			call delay1s  
017e			if display_cols == 20	  
017e			            LD   A, display_row_3+2  
017e			else  
017e 3e 5c		            LD   A, display_row_3+12  
0180			endif  
0180 11 ec 16			ld de, prom_bootmsg1  
0183 cd d8 0b			call str_at_display  
0186			; display debug level  
0186 3e 78		            LD   A, display_row_4  
0188 11 1b 01			ld de, debuglevel  
018b cd d8 0b			call str_at_display  
018e			  
018e cd e8 0b			call update_display  
0191 cd fd 0a			call delay1s  
0194 cd fd 0a			call delay1s  
0197			  
0197			;	ld a, display_row_4+3  
0197			;	ld de, bootmsg2  
0197			;	call str_at_display  
0197			;	call update_display  
0197			;	call delay1s  
0197			;	call delay1s  
0197			  
0197			; debug mark setup  
0197			  
0197 3e 5f		ld a, '_'  
0199 32 6b ee		ld (debug_mark),a  
019c 32 6c ee		ld (debug_mark+1),a  
019f 32 6d ee		ld (debug_mark+2),a  
01a2 3e 00		ld a,0  
01a4 32 6e ee		ld (debug_mark+3),a  
01a7			  
01a7 c9					ret  
01a8			  
01a8			  
01a8			;bootmsg2:	db "Firmware v0.1",0  
01a8			  
01a8			; a 4x20 lcd  
01a8			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01a8			  
01a8			;if display_cols == 20  
01a8			;	include "firmware_lcd_4x20.asm"  
01a8			;endif  
01a8			  
01a8			;if display_cols == 40  
01a8			;	include "firmware_lcd_4x40.asm"  
01a8			;endif  
01a8			  
01a8			;  
01a8			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01a8			; TODO abstract the bit bang video out interface for dual display  
01a8			; TODO wire video out to tx pin on rc2014 bus  
01a8			  
01a8			; must supply cin, and cin_wait for low level hardware abstraction   
01a8			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01a8			; test scancode  
01a8			  
01a8			;;;;;  
01a8			;;;  
01a8			; Moved out to mini and maxi versions  
01a8			;  
01a8			; include "firmware_key_4x4.asm"  
01a8			; using existing 4 wire x 4 resistor array for input  
01a8			;include "firmware_key_4x10.asm"  
01a8			; need to mod the board for 5 rows due to resistor array  
01a8			;include "firmware_key_5x10.asm"  
01a8			  
01a8			; storage hardware interface  
01a8			  
01a8			; use microchip serial eeprom for storage  
01a8			  
01a8			  
01a8			if STORAGE_SE  
01a8				include "firmware_spi.asm"  
01a8				include "firmware_seeprom.asm"  
01a8			else  
01a8			   ; create some stubs for the labels  
01a8 c9			se_readbyte: ret  
01a9 c9			se_writebyte: ret  
01aa c9			storage_init: ret  
01ab			  
01ab			endif  
01ab			  
01ab			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01ab			;include "firmware_cf.asm"  
01ab			  
01ab			; load up high level storage hardward abstractions  
01ab			include "firmware_storage.asm"  
01ab			 
01ab			; persisent storage hardware abstraction layer  
01ab			 
01ab			 
01ab			 
01ab			; Block 0 on storage is a config state 
01ab			 
01ab			 
01ab			 
01ab			; TODO add read phy block and write phy block functions 
01ab			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01ab			 
01ab			; Abstraction layer  
01ab			 
01ab			; Logocial block size is same size as physical size - using tape concept 
01ab			 
01ab			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01ab			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01ab			 
01ab			 
01ab			 
01ab			; Filesystem layout (Logical layout) 
01ab			; 
01ab			; Block 0 - Bank config  
01ab			; 
01ab			;      Byte - 0 file id counter 
01ab			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01ab			;      Byte - 3-20 zero terminated bank label 
01ab			; 
01ab			; Block 1 > File storage 
01ab			; 
01ab			;      Byte 0 file id    - block 0 file details 
01ab			;      Byte 1 block id - block 0 is file  
01ab			;            Byte 2-15 - File name 
01ab			; 
01ab			;       - to end of block data 
01ab			; 
01ab			 
01ab			; Get ID for the file named in pointer held HL 
01ab			; Returns ID in HL = 255 if no file found 
01ab			 
01ab			storage_getid: 
01ab			 
01ab 22 73 ea			ld (store_tmp1), hl 
01ae			 
01ae				if DEBUG_STORESE 
01ae					DMARK "SGI" 
01ae f5				push af  
01af 3a c3 01			ld a, (.dmark)  
01b2 32 6b ee			ld (debug_mark),a  
01b5 3a c4 01			ld a, (.dmark+1)  
01b8 32 6c ee			ld (debug_mark+1),a  
01bb 3a c5 01			ld a, (.dmark+2)  
01be 32 6d ee			ld (debug_mark+2),a  
01c1 18 03			jr .pastdmark  
01c3 ..			.dmark: db "SGI"  
01c6 f1			.pastdmark: pop af  
01c7			endm  
# End of macro DMARK
01c7					CALLMONITOR 
01c7 cd 6f ee			call debug_vector  
01ca				endm  
# End of macro CALLMONITOR
01ca				endif 
01ca				; get block 0 and set counter for number of files to scan 
01ca			 
01ca cd 35 03			call storage_get_block_0 
01cd			 
01cd 3a 7a ea			ld a, (store_page) 
01d0 47				ld b, a 
01d1			 
01d1				; get extent 0 of each file id 
01d1			 
01d1				if DEBUG_STORESE 
01d1					DMARK "SGc" 
01d1 f5				push af  
01d2 3a e6 01			ld a, (.dmark)  
01d5 32 6b ee			ld (debug_mark),a  
01d8 3a e7 01			ld a, (.dmark+1)  
01db 32 6c ee			ld (debug_mark+1),a  
01de 3a e8 01			ld a, (.dmark+2)  
01e1 32 6d ee			ld (debug_mark+2),a  
01e4 18 03			jr .pastdmark  
01e6 ..			.dmark: db "SGc"  
01e9 f1			.pastdmark: pop af  
01ea			endm  
# End of macro DMARK
01ea					CALLMONITOR 
01ea cd 6f ee			call debug_vector  
01ed				endm  
# End of macro CALLMONITOR
01ed				endif 
01ed 60			.getloop:	ld h, b 
01ee 2e 00				ld l, 0 
01f0 c5					push bc 
01f1			 
01f1 11 7a ea				ld de, store_page 
01f4				if DEBUG_STORESE 
01f4					DMARK "SGr" 
01f4 f5				push af  
01f5 3a 09 02			ld a, (.dmark)  
01f8 32 6b ee			ld (debug_mark),a  
01fb 3a 0a 02			ld a, (.dmark+1)  
01fe 32 6c ee			ld (debug_mark+1),a  
0201 3a 0b 02			ld a, (.dmark+2)  
0204 32 6d ee			ld (debug_mark+2),a  
0207 18 03			jr .pastdmark  
0209 ..			.dmark: db "SGr"  
020c f1			.pastdmark: pop af  
020d			endm  
# End of macro DMARK
020d					CALLMONITOR 
020d cd 6f ee			call debug_vector  
0210				endm  
# End of macro CALLMONITOR
0210				endif 
0210 cd dd 07				call storage_read 
0213 cd 1b 0e				call ishlzero 
0216 28 2d				jr z, .gap 
0218					 
0218					; have a file name read. Is it one we want. 
0218			 
0218 2a 73 ea				ld hl, (store_tmp1) 
021b 11 7d ea				ld de, store_page+3   ; file name 
021e			 
021e				if DEBUG_STORESE 
021e					DMARK "SGc" 
021e f5				push af  
021f 3a 33 02			ld a, (.dmark)  
0222 32 6b ee			ld (debug_mark),a  
0225 3a 34 02			ld a, (.dmark+1)  
0228 32 6c ee			ld (debug_mark+1),a  
022b 3a 35 02			ld a, (.dmark+2)  
022e 32 6d ee			ld (debug_mark+2),a  
0231 18 03			jr .pastdmark  
0233 ..			.dmark: db "SGc"  
0236 f1			.pastdmark: pop af  
0237			endm  
# End of macro DMARK
0237					CALLMONITOR 
0237 cd 6f ee			call debug_vector  
023a				endm  
# End of macro CALLMONITOR
023a				endif 
023a cd 90 11				call strcmp 
023d 20 06				jr nz, .gap   ; not this one 
023f			 
023f c1				        pop bc 
0240			 
0240 26 00				ld h, 0 
0242 68					ld l, b 
0243 18 22				jr .getdone 
0245						 
0245			 
0245			 
0245			 
0245			.gap: 
0245				if DEBUG_STORESE 
0245					DMARK "SGg" 
0245 f5				push af  
0246 3a 5a 02			ld a, (.dmark)  
0249 32 6b ee			ld (debug_mark),a  
024c 3a 5b 02			ld a, (.dmark+1)  
024f 32 6c ee			ld (debug_mark+1),a  
0252 3a 5c 02			ld a, (.dmark+2)  
0255 32 6d ee			ld (debug_mark+2),a  
0258 18 03			jr .pastdmark  
025a ..			.dmark: db "SGg"  
025d f1			.pastdmark: pop af  
025e			endm  
# End of macro DMARK
025e					CALLMONITOR 
025e cd 6f ee			call debug_vector  
0261				endm  
# End of macro CALLMONITOR
0261				endif 
0261			 
0261 c1					pop bc 
0262 10 89				djnz .getloop 
0264 21 ff 00				ld hl, 255 
0267			.getdone: 
0267			 
0267				if DEBUG_STORESE 
0267					DMARK "SGe" 
0267 f5				push af  
0268 3a 7c 02			ld a, (.dmark)  
026b 32 6b ee			ld (debug_mark),a  
026e 3a 7d 02			ld a, (.dmark+1)  
0271 32 6c ee			ld (debug_mark+1),a  
0274 3a 7e 02			ld a, (.dmark+2)  
0277 32 6d ee			ld (debug_mark+2),a  
027a 18 03			jr .pastdmark  
027c ..			.dmark: db "SGe"  
027f f1			.pastdmark: pop af  
0280			endm  
# End of macro DMARK
0280					CALLMONITOR 
0280 cd 6f ee			call debug_vector  
0283				endm  
# End of macro CALLMONITOR
0283				endif 
0283			 
0283 c9				ret 
0284			 
0284			 
0284			 
0284			 
0284			 
0284			 
0284			 
0284			 
0284			; Read Block 
0284			; ---------- 
0284			; 
0284			; With current bank 
0284			;  
0284			; Get block number to read 
0284			; Load physical blocks starting at start block into buffer 
0284			 
0284			; de points to buffer to use 
0284			; hl holds logical block number  
0284			 
0284			storage_read_block: 
0284			 
0284				; TODO bank selection 
0284			 
0284				; for each of the physical blocks read it into the buffer 
0284 06 40			ld b, STORE_BLOCK_PHY 
0286			 
0286				if DEBUG_STORESE 
0286 d5					push de 
0287				endif 
0287				 
0287			.rl1:    
0287			 
0287				; read physical block at hl into de 
0287			        ; increment hl and de to next read position on exit 
0287			 
0287 e5				push hl 
0288 d5				push de	 
0289 c5				push bc 
028a			;	if DEBUG_STORESE 
028a			;		push af 
028a			;		ld a, 'R' 
028a			;		ld (debug_mark),a 
028a			;		pop af 
028a			;		CALLMONITOR 
028a			;	endif 
028a cd a8 01			call se_readbyte 
028d			;	if DEBUG_STORESE 
028d			;		ld a,(spi_portbyte) 
028d			;		ld l, a 
028d			;		push af 
028d			;		ld a, '1' 
028d			;		ld (debug_mark),a 
028d			;		pop af 
028d			;		CALLMONITOR 
028d			;	endif 
028d c1				pop bc 
028e d1				pop de 
028f e1				pop hl 
0290 12				ld (de),a 
0291 23				inc hl 
0292 13				inc de 
0293			 
0293			;	if DEBUG_STORESE 
0293			;		push af 
0293			;		ld a, 'r' 
0293			;		ld (debug_mark),a 
0293			;		pop af 
0293			;		CALLMONITOR 
0293			;	endif 
0293			 
0293 10 f2			djnz .rl1 
0295			 
0295				if DEBUG_STORESE 
0295					DMARK "SRB" 
0295 f5				push af  
0296 3a aa 02			ld a, (.dmark)  
0299 32 6b ee			ld (debug_mark),a  
029c 3a ab 02			ld a, (.dmark+1)  
029f 32 6c ee			ld (debug_mark+1),a  
02a2 3a ac 02			ld a, (.dmark+2)  
02a5 32 6d ee			ld (debug_mark+2),a  
02a8 18 03			jr .pastdmark  
02aa ..			.dmark: db "SRB"  
02ad f1			.pastdmark: pop af  
02ae			endm  
# End of macro DMARK
02ae d1					pop de 
02af			; 
02af			;		push af 
02af			;		ld a, 'R' 
02af			;		ld (debug_mark),a 
02af			;		pop af 
02af					CALLMONITOR 
02af cd 6f ee			call debug_vector  
02b2				endm  
# End of macro CALLMONITOR
02b2				endif 
02b2 c9				ret	 
02b3				 
02b3			 
02b3			; File Size 
02b3			; --------- 
02b3			; 
02b3			;   hl file id 
02b3			; 
02b3			;  returns in hl the number of blocks 
02b3			 
02b3			storage_file_size: 
02b3 5d				ld e, l 
02b4 16 00			ld d, 0 
02b6 21 40 00			ld hl, STORE_BLOCK_PHY 
02b9					if DEBUG_FORTH_WORDS 
02b9						DMARK "SIZ" 
02b9 f5				push af  
02ba 3a ce 02			ld a, (.dmark)  
02bd 32 6b ee			ld (debug_mark),a  
02c0 3a cf 02			ld a, (.dmark+1)  
02c3 32 6c ee			ld (debug_mark+1),a  
02c6 3a d0 02			ld a, (.dmark+2)  
02c9 32 6d ee			ld (debug_mark+2),a  
02cc 18 03			jr .pastdmark  
02ce ..			.dmark: db "SIZ"  
02d1 f1			.pastdmark: pop af  
02d2			endm  
# End of macro DMARK
02d2						CALLMONITOR 
02d2 cd 6f ee			call debug_vector  
02d5				endm  
# End of macro CALLMONITOR
02d5					endif 
02d5 cd b7 05			call storage_findnextid 
02d8			 
02d8 cd 1b 0e			call ishlzero 
02db			;	ld a, l 
02db			;	add h 
02db			;	cp 0 
02db c8				ret z			; block not found so EOF 
02dc			 
02dc 11 7a ea			ld de, store_page 
02df cd 84 02			call storage_read_block 
02e2			 
02e2 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
02e5 6f				ld l, a 
02e6 26 00			ld h, 0 
02e8 c9			 	ret 
02e9			 
02e9			 
02e9			; Write Block 
02e9			; ----------- 
02e9			; 
02e9			; With current bank 
02e9			;  
02e9			; Get block number to write 
02e9			; Write physical blocks starting at start block from buffer 
02e9			  
02e9			storage_write_block: 
02e9				; TODO bank selection 
02e9			 
02e9				; for each of the physical blocks read it into the buffer 
02e9 06 40			ld b, STORE_BLOCK_PHY 
02eb			 
02eb				if DEBUG_STORESE 
02eb					DMARK "SWB" 
02eb f5				push af  
02ec 3a 00 03			ld a, (.dmark)  
02ef 32 6b ee			ld (debug_mark),a  
02f2 3a 01 03			ld a, (.dmark+1)  
02f5 32 6c ee			ld (debug_mark+1),a  
02f8 3a 02 03			ld a, (.dmark+2)  
02fb 32 6d ee			ld (debug_mark+2),a  
02fe 18 03			jr .pastdmark  
0300 ..			.dmark: db "SWB"  
0303 f1			.pastdmark: pop af  
0304			endm  
# End of macro DMARK
0304			 
0304					;push af 
0304					;ld a, 'W' 
0304					;ld (debug_mark),a 
0304					;pop af 
0304					CALLMONITOR 
0304 cd 6f ee			call debug_vector  
0307				endm  
# End of macro CALLMONITOR
0307				endif 
0307			 
0307			; might not be working 
0307			;	call se_writepage 
0307			 
0307			;	ret 
0307			; 
0307			 
0307			 
0307			 
0307			.wl1:    
0307			 
0307				; read physical block at hl into de 
0307			        ; increment hl and de to next read position on exit 
0307			 
0307 e5				push hl 
0308 d5				push de	 
0309 c5				push bc 
030a 1a				ld a,(de) 
030b				;if DEBUG_STORESE 
030b			;		push af 
030b			;		ld a, 'W' 
030b			;		ld (debug_mark),a 
030b			;		pop af 
030b			;		CALLMONITOR 
030b			;	endif 
030b cd a9 01			call se_writebyte 
030e			;	call delay250ms 
030e 00				nop 
030f 00				nop 
0310 00				nop 
0311			;	if DEBUG_STORESE 
0311			;		push af 
0311			;		ld a, 'w' 
0311			;		ld (debug_mark),a 
0311			;		pop af 
0311			;		CALLMONITOR 
0311			;	endif 
0311 c1				pop bc 
0312 d1				pop de 
0313 e1				pop hl 
0314 23				inc hl 
0315 13				inc de 
0316			 
0316			 
0316 10 ef			djnz .wl1 
0318			 
0318				if DEBUG_STORESE 
0318					DMARK "SW2" 
0318 f5				push af  
0319 3a 2d 03			ld a, (.dmark)  
031c 32 6b ee			ld (debug_mark),a  
031f 3a 2e 03			ld a, (.dmark+1)  
0322 32 6c ee			ld (debug_mark+1),a  
0325 3a 2f 03			ld a, (.dmark+2)  
0328 32 6d ee			ld (debug_mark+2),a  
032b 18 03			jr .pastdmark  
032d ..			.dmark: db "SW2"  
0330 f1			.pastdmark: pop af  
0331			endm  
# End of macro DMARK
0331			 
0331					;push af 
0331					;ld a, 'W' 
0331					;ld (debug_mark),a 
0331					;pop af 
0331					CALLMONITOR 
0331 cd 6f ee			call debug_vector  
0334				endm  
# End of macro CALLMONITOR
0334				endif 
0334 c9				ret	 
0335			 
0335			; Init bank 
0335			; --------- 
0335			; 
0335			; With current bank 
0335			; 
0335			; Setup block 0 config 
0335			;     Set 0 file id counter 
0335			;     Set formatted byte pattern 
0335			;     Zero out bank label 
0335			;      
0335			; For every logical block write 0-1 byte as null 
0335			 
0335			storage_get_block_0: 
0335			 
0335				; TODO check presence 
0335			 
0335				; get block 0 config 
0335			 
0335 21 00 00			ld hl, 0 
0338 11 7a ea			ld de, store_page 
033b cd 84 02			call storage_read_block 
033e			 
033e				if DEBUG_STORESE 
033e					DMARK "SB0" 
033e f5				push af  
033f 3a 53 03			ld a, (.dmark)  
0342 32 6b ee			ld (debug_mark),a  
0345 3a 54 03			ld a, (.dmark+1)  
0348 32 6c ee			ld (debug_mark+1),a  
034b 3a 55 03			ld a, (.dmark+2)  
034e 32 6d ee			ld (debug_mark+2),a  
0351 18 03			jr .pastdmark  
0353 ..			.dmark: db "SB0"  
0356 f1			.pastdmark: pop af  
0357			endm  
# End of macro DMARK
0357 11 7a ea				ld de, store_page 
035a			;		push af 
035a			;		ld a, 'i' 
035a			;		ld (debug_mark),a 
035a			;		pop af 
035a					CALLMONITOR 
035a cd 6f ee			call debug_vector  
035d				endm  
# End of macro CALLMONITOR
035d				endif 
035d			 
035d				; is this area formatted? 
035d			 
035d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
035d 2a 7b ea			ld hl, (store_page+1) 
0360 3e 80			ld a,0x80 
0362 bd				cp l 
0363 20 22			jr nz, .ininotformatted 
0365				; do a double check 
0365 3e 27			ld a, 0x27 
0367 bc				cp h 
0368 20 1d			jr nz, .ininotformatted 
036a			 
036a				; formatted then 
036a			 
036a				if DEBUG_STORESE 
036a					DMARK "SB1" 
036a f5				push af  
036b 3a 7f 03			ld a, (.dmark)  
036e 32 6b ee			ld (debug_mark),a  
0371 3a 80 03			ld a, (.dmark+1)  
0374 32 6c ee			ld (debug_mark+1),a  
0377 3a 81 03			ld a, (.dmark+2)  
037a 32 6d ee			ld (debug_mark+2),a  
037d 18 03			jr .pastdmark  
037f ..			.dmark: db "SB1"  
0382 f1			.pastdmark: pop af  
0383			endm  
# End of macro DMARK
0383					;push af 
0383					;ld a, 'I' 
0383					;ld (debug_mark),a 
0383					;pop af 
0383					CALLMONITOR 
0383 cd 6f ee			call debug_vector  
0386				endm  
# End of macro CALLMONITOR
0386				endif 
0386 c9				ret 
0387			 
0387			.ininotformatted: 
0387				; bank not formatted so poke various bits to make sure 
0387			 
0387				if DEBUG_STORESE 
0387					DMARK "SB2" 
0387 f5				push af  
0388 3a 9c 03			ld a, (.dmark)  
038b 32 6b ee			ld (debug_mark),a  
038e 3a 9d 03			ld a, (.dmark+1)  
0391 32 6c ee			ld (debug_mark+1),a  
0394 3a 9e 03			ld a, (.dmark+2)  
0397 32 6d ee			ld (debug_mark+2),a  
039a 18 03			jr .pastdmark  
039c ..			.dmark: db "SB2"  
039f f1			.pastdmark: pop af  
03a0			endm  
# End of macro DMARK
03a0					;push af 
03a0					;ld a, 'f' 
03a0					;ld (debug_mark),a 
03a0					;pop af 
03a0					CALLMONITOR 
03a0 cd 6f ee			call debug_vector  
03a3				endm  
# End of macro CALLMONITOR
03a3				endif 
03a3			 
03a3 cd c0 0a			call storage_clear_page 
03a6			 
03a6 21 7a ea			ld hl, store_page 
03a9 3e 00			ld a, 0 
03ab				 
03ab 77				ld (hl),a   ; reset file counter 
03ac			 
03ac 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03af 22 7b ea		 	ld (store_page+1), hl	 
03b2			 
03b2				; set default label 
03b2			 
03b2 21 4e 04			ld hl, .defaultbanklabl 
03b5 11 7d ea		 	ld de, store_page+3 
03b8 01 0f 00			ld bc, 15 
03bb ed b0			ldir 
03bd			 
03bd				; Append the current bank id 
03bd 21 86 ea			ld hl, store_page+3+9 
03c0 3a 5f ea			ld a, (spi_device_id) 
03c3 77				ld (hl), a 
03c4			 
03c4				; save default page 0 
03c4			 
03c4 21 00 00			ld hl, 0 
03c7 11 7a ea			ld de, store_page 
03ca				if DEBUG_STORESE 
03ca					DMARK "SB3" 
03ca f5				push af  
03cb 3a df 03			ld a, (.dmark)  
03ce 32 6b ee			ld (debug_mark),a  
03d1 3a e0 03			ld a, (.dmark+1)  
03d4 32 6c ee			ld (debug_mark+1),a  
03d7 3a e1 03			ld a, (.dmark+2)  
03da 32 6d ee			ld (debug_mark+2),a  
03dd 18 03			jr .pastdmark  
03df ..			.dmark: db "SB3"  
03e2 f1			.pastdmark: pop af  
03e3			endm  
# End of macro DMARK
03e3			;		push af 
03e3			;		ld a, 'F' 
03e3			;		ld (debug_mark),a 
03e3			;		pop af 
03e3					CALLMONITOR 
03e3 cd 6f ee			call debug_vector  
03e6				endm  
# End of macro CALLMONITOR
03e6				endif 
03e6 cd e9 02			call storage_write_block 
03e9				if DEBUG_STORESE 
03e9					DMARK "SB4" 
03e9 f5				push af  
03ea 3a fe 03			ld a, (.dmark)  
03ed 32 6b ee			ld (debug_mark),a  
03f0 3a ff 03			ld a, (.dmark+1)  
03f3 32 6c ee			ld (debug_mark+1),a  
03f6 3a 00 04			ld a, (.dmark+2)  
03f9 32 6d ee			ld (debug_mark+2),a  
03fc 18 03			jr .pastdmark  
03fe ..			.dmark: db "SB4"  
0401 f1			.pastdmark: pop af  
0402			endm  
# End of macro DMARK
0402			;		push af 
0402			;		ld a, '>' 
0402			;		ld (debug_mark),a 
0402			;		pop af 
0402					CALLMONITOR 
0402 cd 6f ee			call debug_vector  
0405				endm  
# End of macro CALLMONITOR
0405				endif 
0405			 
0405 00				nop 
0406 00				nop 
0407 00				nop 
0408			 
0408				; now set 0 in every page to mark as a free block 
0408			 
0408 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
040a 21 40 00			ld hl, STORE_BLOCK_PHY 
040d			 
040d 3e 00		.setmark1:   	ld a,0 
040f e5					push hl 
0410 c5					push bc 
0411 cd a9 01				call se_writebyte 
0414 3e 0a			ld a, 10 
0416 cd e2 0a			call aDelayInMS 
0419 23				inc hl 
041a cd a9 01				call se_writebyte 
041d 3e 0a			ld a, 10 
041f cd e2 0a			call aDelayInMS 
0422 2b				dec hl 
0423 c1					pop bc 
0424 e1					pop hl 
0425 3e 40				ld a, STORE_BLOCK_PHY 
0427 cd f2 0d				call addatohl 
042a 10 e1				djnz .setmark1 
042c			 
042c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
042e 3e 00		.setmark2:   	ld a,0 
0430 e5					push hl 
0431 c5					push bc 
0432 cd a9 01				call se_writebyte 
0435 3e 0a			ld a, 10 
0437 cd e2 0a			call aDelayInMS 
043a 23				inc hl 
043b cd a9 01				call se_writebyte 
043e 3e 0a			ld a, 10 
0440 cd e2 0a			call aDelayInMS 
0443 2b				dec hl 
0444 c1					pop bc 
0445 e1					pop hl 
0446 3e 40				ld a, STORE_BLOCK_PHY 
0448 cd f2 0d				call addatohl 
044b 10 e1				djnz .setmark2 
044d			 
044d					 
044d			 
044d			 
044d c9				ret 
044e			 
044e			 
044e			 
044e			 
044e .. 00		.defaultbanklabl:   db "BankLabel_",0 
0459			 
0459			 
0459			 
0459			; Label Bank 
0459			; ---------- 
0459			; 
0459			; With current bank 
0459			; Read block 0 
0459			; Set label 
0459			; Write block 0 
0459			 
0459			; label str pointer in hl 
0459			 
0459			storage_label:     
0459			 
0459				if DEBUG_STORESE 
0459					DMARK "LBL" 
0459 f5				push af  
045a 3a 6e 04			ld a, (.dmark)  
045d 32 6b ee			ld (debug_mark),a  
0460 3a 6f 04			ld a, (.dmark+1)  
0463 32 6c ee			ld (debug_mark+1),a  
0466 3a 70 04			ld a, (.dmark+2)  
0469 32 6d ee			ld (debug_mark+2),a  
046c 18 03			jr .pastdmark  
046e ..			.dmark: db "LBL"  
0471 f1			.pastdmark: pop af  
0472			endm  
# End of macro DMARK
0472					CALLMONITOR 
0472 cd 6f ee			call debug_vector  
0475				endm  
# End of macro CALLMONITOR
0475				endif 
0475			 
0475 e5				push hl 
0476			 
0476 cd 35 03			call storage_get_block_0 
0479			 
0479				; set default label 
0479			 
0479 e1				pop hl 
047a			 
047a 11 7d ea		 	ld de, store_page+3 
047d 01 0f 00			ld bc, 15 
0480				if DEBUG_STORESE 
0480					DMARK "LB3" 
0480 f5				push af  
0481 3a 95 04			ld a, (.dmark)  
0484 32 6b ee			ld (debug_mark),a  
0487 3a 96 04			ld a, (.dmark+1)  
048a 32 6c ee			ld (debug_mark+1),a  
048d 3a 97 04			ld a, (.dmark+2)  
0490 32 6d ee			ld (debug_mark+2),a  
0493 18 03			jr .pastdmark  
0495 ..			.dmark: db "LB3"  
0498 f1			.pastdmark: pop af  
0499			endm  
# End of macro DMARK
0499					CALLMONITOR 
0499 cd 6f ee			call debug_vector  
049c				endm  
# End of macro CALLMONITOR
049c				endif 
049c ed b0			ldir 
049e				; save default page 0 
049e			 
049e 21 00 00			ld hl, 0 
04a1 11 7a ea			ld de, store_page 
04a4				if DEBUG_STORESE 
04a4					DMARK "LBW" 
04a4 f5				push af  
04a5 3a b9 04			ld a, (.dmark)  
04a8 32 6b ee			ld (debug_mark),a  
04ab 3a ba 04			ld a, (.dmark+1)  
04ae 32 6c ee			ld (debug_mark+1),a  
04b1 3a bb 04			ld a, (.dmark+2)  
04b4 32 6d ee			ld (debug_mark+2),a  
04b7 18 03			jr .pastdmark  
04b9 ..			.dmark: db "LBW"  
04bc f1			.pastdmark: pop af  
04bd			endm  
# End of macro DMARK
04bd					CALLMONITOR 
04bd cd 6f ee			call debug_vector  
04c0				endm  
# End of macro CALLMONITOR
04c0				endif 
04c0 cd e9 02			call storage_write_block 
04c3			 
04c3 c9				ret 
04c4			 
04c4			 
04c4			 
04c4			; Read Block 0 - Config 
04c4			; --------------------- 
04c4			; 
04c4			; With current bank 
04c4			; Call presence test 
04c4			;    If not present format/init bank  
04c4			; Read block 0  
04c4			;  
04c4			 
04c4			 
04c4			; Dir 
04c4			; --- 
04c4			; 
04c4			; With current bank 
04c4			; Load Block 0 Config 
04c4			; Get max file id number 
04c4			; For each logical block 
04c4			;    Read block read byte 2 
04c4			;      if first block of file 
04c4			;         Display file name 
04c4			;         Display type flags for file 
04c4			;        
04c4			 
04c4			; moving to words as this requires stack control 
04c4			 
04c4			 
04c4			; Delete File 
04c4			; ----------- 
04c4			; 
04c4			; With current bank 
04c4			; 
04c4			; Load Block 0 Config 
04c4			; Get max file id number 
04c4			; For each logical block 
04c4			;    Read block file id 
04c4			;      If first block of file and dont have file id 
04c4			;         if file to delete 
04c4			;         Save file id 
04c4			;         Null file id 
04c4			;         Write this block back 
04c4			;      If file id is one saved 
04c4			;         Null file id 
04c4			;         Write this block back 
04c4			 
04c4			 
04c4			.se_done: 
04c4 e1				pop hl 
04c5 c9				ret 
04c6			 
04c6			storage_erase: 
04c6			 
04c6				; hl contains the file id 
04c6			 
04c6 5d				ld e, l 
04c7 16 00			ld d, 0 
04c9 21 40 00			ld hl, STORE_BLOCK_PHY 
04cc					if DEBUG_FORTH_WORDS 
04cc						DMARK "ERA" 
04cc f5				push af  
04cd 3a e1 04			ld a, (.dmark)  
04d0 32 6b ee			ld (debug_mark),a  
04d3 3a e2 04			ld a, (.dmark+1)  
04d6 32 6c ee			ld (debug_mark+1),a  
04d9 3a e3 04			ld a, (.dmark+2)  
04dc 32 6d ee			ld (debug_mark+2),a  
04df 18 03			jr .pastdmark  
04e1 ..			.dmark: db "ERA"  
04e4 f1			.pastdmark: pop af  
04e5			endm  
# End of macro DMARK
04e5						CALLMONITOR 
04e5 cd 6f ee			call debug_vector  
04e8				endm  
# End of macro CALLMONITOR
04e8					endif 
04e8 cd b7 05			call storage_findnextid 
04eb cd 1b 0e			call ishlzero 
04ee c8				ret z 
04ef			 
04ef e5				push hl 
04f0			 
04f0				; TODO check file not found 
04f0			 
04f0 11 7a ea			ld de, store_page 
04f3 cd 84 02			call storage_read_block 
04f6			 
04f6 cd 1b 0e			call ishlzero 
04f9 ca c4 04			jp z,.se_done 
04fc			 
04fc					if DEBUG_FORTH_WORDS 
04fc						DMARK "ER1" 
04fc f5				push af  
04fd 3a 11 05			ld a, (.dmark)  
0500 32 6b ee			ld (debug_mark),a  
0503 3a 12 05			ld a, (.dmark+1)  
0506 32 6c ee			ld (debug_mark+1),a  
0509 3a 13 05			ld a, (.dmark+2)  
050c 32 6d ee			ld (debug_mark+2),a  
050f 18 03			jr .pastdmark  
0511 ..			.dmark: db "ER1"  
0514 f1			.pastdmark: pop af  
0515			endm  
# End of macro DMARK
0515						CALLMONITOR 
0515 cd 6f ee			call debug_vector  
0518				endm  
# End of macro CALLMONITOR
0518					endif 
0518 3a 7a ea			ld a, (store_page)	; get file id 
051b 32 6e ea			ld (store_tmpid), a 
051e			 
051e 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
0521 32 6d ea			ld (store_tmpext), a 
0524			 
0524				; wipe file header 
0524			 
0524 e1				pop hl 
0525 3e 00			ld a, 0 
0527 32 7a ea			ld (store_page), a 
052a 32 7b ea			ld (store_page+1),a 
052d 11 7a ea			ld de, store_page 
0530					if DEBUG_FORTH_WORDS 
0530						DMARK "ER2" 
0530 f5				push af  
0531 3a 45 05			ld a, (.dmark)  
0534 32 6b ee			ld (debug_mark),a  
0537 3a 46 05			ld a, (.dmark+1)  
053a 32 6c ee			ld (debug_mark+1),a  
053d 3a 47 05			ld a, (.dmark+2)  
0540 32 6d ee			ld (debug_mark+2),a  
0543 18 03			jr .pastdmark  
0545 ..			.dmark: db "ER2"  
0548 f1			.pastdmark: pop af  
0549			endm  
# End of macro DMARK
0549						CALLMONITOR 
0549 cd 6f ee			call debug_vector  
054c				endm  
# End of macro CALLMONITOR
054c					endif 
054c cd e9 02			call storage_write_block 
054f			 
054f			 
054f				; wipe file extents 
054f			 
054f 3a 6d ea			ld a, (store_tmpext) 
0552 47				ld b, a 
0553			 
0553			.eraext:	  
0553 c5				push bc 
0554			 
0554 21 40 00			ld hl, STORE_BLOCK_PHY 
0557 3a 6e ea			ld a,(store_tmpid) 
055a 5f				ld e, a 
055b 50				ld d, b	 
055c					if DEBUG_FORTH_WORDS 
055c						DMARK "ER3" 
055c f5				push af  
055d 3a 71 05			ld a, (.dmark)  
0560 32 6b ee			ld (debug_mark),a  
0563 3a 72 05			ld a, (.dmark+1)  
0566 32 6c ee			ld (debug_mark+1),a  
0569 3a 73 05			ld a, (.dmark+2)  
056c 32 6d ee			ld (debug_mark+2),a  
056f 18 03			jr .pastdmark  
0571 ..			.dmark: db "ER3"  
0574 f1			.pastdmark: pop af  
0575			endm  
# End of macro DMARK
0575						CALLMONITOR 
0575 cd 6f ee			call debug_vector  
0578				endm  
# End of macro CALLMONITOR
0578					endif 
0578 cd b7 05			call storage_findnextid 
057b cd 1b 0e			call ishlzero 
057e ca c4 04			jp z,.se_done 
0581			 
0581 e5				push hl 
0582 11 7a ea			ld de, store_page 
0585 cd 84 02			call storage_read_block 
0588			 
0588				; free block	 
0588			 
0588 3e 00			ld a, 0 
058a 32 7a ea			ld (store_page), a 
058d 32 7b ea			ld (store_page+1),a 
0590 11 7a ea			ld de, store_page 
0593 e1				pop hl 
0594					if DEBUG_FORTH_WORDS 
0594						DMARK "ER4" 
0594 f5				push af  
0595 3a a9 05			ld a, (.dmark)  
0598 32 6b ee			ld (debug_mark),a  
059b 3a aa 05			ld a, (.dmark+1)  
059e 32 6c ee			ld (debug_mark+1),a  
05a1 3a ab 05			ld a, (.dmark+2)  
05a4 32 6d ee			ld (debug_mark+2),a  
05a7 18 03			jr .pastdmark  
05a9 ..			.dmark: db "ER4"  
05ac f1			.pastdmark: pop af  
05ad			endm  
# End of macro DMARK
05ad						CALLMONITOR 
05ad cd 6f ee			call debug_vector  
05b0				endm  
# End of macro CALLMONITOR
05b0					endif 
05b0 cd e9 02			call storage_write_block 
05b3			 
05b3 c1				pop bc 
05b4 10 9d			djnz .eraext 
05b6			 
05b6 c9				ret 
05b7			 
05b7			 
05b7			; Find Free Block 
05b7			; --------------- 
05b7			; 
05b7			; With current bank 
05b7			;  
05b7			; From given starting logical block 
05b7			;    Read block  
05b7			;    If no file id 
05b7			;         Return block id 
05b7			 
05b7			 
05b7			; hl starting page number 
05b7			; hl contains free page number or zero if no pages free 
05b7			; e contains the file id to locate 
05b7			; d contains the block number 
05b7			 
05b7			; TODO change to find file id and use zero for free block 
05b7			 
05b7			storage_findnextid: 
05b7			 
05b7				; now locate first 0 page to mark as a free block 
05b7			 
05b7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05b9			;	ld hl, STORE_BLOCK_PHY 
05b9			 
05b9					if DEBUG_FORTH_WORDS 
05b9					DMARK "FNI" 
05b9 f5				push af  
05ba 3a ce 05			ld a, (.dmark)  
05bd 32 6b ee			ld (debug_mark),a  
05c0 3a cf 05			ld a, (.dmark+1)  
05c3 32 6c ee			ld (debug_mark+1),a  
05c6 3a d0 05			ld a, (.dmark+2)  
05c9 32 6d ee			ld (debug_mark+2),a  
05cc 18 03			jr .pastdmark  
05ce ..			.dmark: db "FNI"  
05d1 f1			.pastdmark: pop af  
05d2			endm  
# End of macro DMARK
05d2						CALLMONITOR 
05d2 cd 6f ee			call debug_vector  
05d5				endm  
# End of macro CALLMONITOR
05d5					endif 
05d5			.ff1:   	 
05d5 e5					push hl 
05d6 c5					push bc 
05d7 d5					push de 
05d8 cd a8 01				call se_readbyte 
05db 5f					ld e,a 
05dc 23					inc hl 
05dd cd a8 01				call se_readbyte 
05e0 57					ld d, a 
05e1 e1					pop hl 
05e2 e5					push hl 
05e3 cd 10 0e				call cmp16 
05e6 28 49				jr z, .fffound 
05e8			 
05e8 d1					pop de 
05e9 c1					pop bc 
05ea e1					pop hl 
05eb			 
05eb					; is found? 
05eb					;cp e 
05eb					;ret z 
05eb			 
05eb 3e 40				ld a, STORE_BLOCK_PHY 
05ed cd f2 0d				call addatohl 
05f0 10 e3				djnz .ff1 
05f2			 
05f2 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05f4			.ff2:   	 
05f4			 
05f4 e5					push hl 
05f5 c5					push bc 
05f6 d5					push de 
05f7 cd a8 01				call se_readbyte 
05fa 5f					ld e,a 
05fb 23					inc hl 
05fc cd a8 01				call se_readbyte 
05ff 57					ld d, a 
0600			 
0600 e1					pop hl 
0601 e5					push hl 
0602 cd 10 0e				call cmp16 
0605 28 2a				jr z, .fffound 
0607			 
0607 d1					pop de 
0608 c1					pop bc 
0609 e1					pop hl 
060a					; is found? 
060a					;cp e 
060a					;ret z 
060a			 
060a 3e 40				ld a, STORE_BLOCK_PHY 
060c cd f2 0d				call addatohl 
060f 10 e3				djnz .ff2 
0611			 
0611			 
0611					if DEBUG_FORTH_WORDS 
0611					DMARK "FN-" 
0611 f5				push af  
0612 3a 26 06			ld a, (.dmark)  
0615 32 6b ee			ld (debug_mark),a  
0618 3a 27 06			ld a, (.dmark+1)  
061b 32 6c ee			ld (debug_mark+1),a  
061e 3a 28 06			ld a, (.dmark+2)  
0621 32 6d ee			ld (debug_mark+2),a  
0624 18 03			jr .pastdmark  
0626 ..			.dmark: db "FN-"  
0629 f1			.pastdmark: pop af  
062a			endm  
# End of macro DMARK
062a					;	push af 
062a					;	ld a, 'n' 
062a					;	ld (debug_mark),a 
062a					;	pop af 
062a						CALLMONITOR 
062a cd 6f ee			call debug_vector  
062d				endm  
# End of macro CALLMONITOR
062d					endif 
062d				; no free marks! 
062d 21 00 00				ld hl, 0 
0630 c9				ret 
0631			.fffound: 
0631				 
0631			 
0631 d1					pop de 
0632 c1					pop bc 
0633 e1					pop hl 
0634					if DEBUG_FORTH_WORDS 
0634					DMARK "FNF" 
0634 f5				push af  
0635 3a 49 06			ld a, (.dmark)  
0638 32 6b ee			ld (debug_mark),a  
063b 3a 4a 06			ld a, (.dmark+1)  
063e 32 6c ee			ld (debug_mark+1),a  
0641 3a 4b 06			ld a, (.dmark+2)  
0644 32 6d ee			ld (debug_mark+2),a  
0647 18 03			jr .pastdmark  
0649 ..			.dmark: db "FNF"  
064c f1			.pastdmark: pop af  
064d			endm  
# End of macro DMARK
064d					;	push af 
064d					;	ld a, 'n' 
064d					;	ld (debug_mark),a 
064d					;	pop af 
064d						CALLMONITOR 
064d cd 6f ee			call debug_vector  
0650				endm  
# End of macro CALLMONITOR
0650					endif 
0650 c9				ret 
0651			 
0651			 
0651			 
0651			; Free Space 
0651			; ---------- 
0651			; 
0651			; With current bank 
0651			; 
0651			; Set block count to zero 
0651			; Starting with first logical block 
0651			;      Find free block  
0651			;      If block id given, increment block count 
0651			; 
0651			;  
0651			 
0651			 
0651			; hl contains count of free blocks 
0651			 
0651			storage_freeblocks: 
0651			 
0651				; now locate first 0 page to mark as a free block 
0651			 
0651 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0653 21 40 00			ld hl, STORE_BLOCK_PHY 
0656 11 00 00			ld de, 0 
0659			 
0659			.fb1:   	 
0659 e5					push hl 
065a c5					push bc 
065b d5					push de 
065c cd a8 01				call se_readbyte 
065f d1					pop de 
0660 c1					pop bc 
0661 e1					pop hl 
0662			 
0662					; is free? 
0662 fe 00				cp 0 
0664 20 01				jr nz, .ff1cont 
0666 13					inc de 
0667			 
0667			.ff1cont: 
0667			 
0667			 
0667 3e 40				ld a, STORE_BLOCK_PHY 
0669 cd f2 0d				call addatohl 
066c 10 eb				djnz .fb1 
066e			 
066e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0670			.fb2:   	 
0670 e5					push hl 
0671 c5					push bc 
0672 d5					push de 
0673 cd a8 01				call se_readbyte 
0676 d1					pop de 
0677 c1					pop bc 
0678 e1					pop hl 
0679			 
0679					; is free? 
0679 fe 00				cp 0 
067b 20 01				jr nz, .ff2cont 
067d 13					inc de 
067e			 
067e			.ff2cont: 
067e			 
067e 3e 40				ld a, STORE_BLOCK_PHY 
0680 cd f2 0d				call addatohl 
0683 10 eb				djnz .fb2 
0685			 
0685 eb				ex de, hl 
0686 c9				ret 
0687			 
0687			; Get File ID 
0687			; ----------- 
0687			; 
0687			; With current bank 
0687			;  
0687			; Load Block 0 Config 
0687			; Get max file id number 
0687			; For each logical block 
0687			;    Read block file id 
0687			;      If first block of file and dont have file id 
0687			;         if file get id and exit 
0687			 
0687			 
0687			 
0687			 
0687			; Create File 
0687			; ----------- 
0687			; 
0687			; With current bank  
0687			; Load Block 0 Config 
0687			; Get max file id number 
0687			; Increment file id number 
0687			; Save Config 
0687			; Find free block 
0687			; Set buffer with file name and file id 
0687			; Write buffer to free block  
0687			 
0687			 
0687			; hl point to file name 
0687			; hl returns file id 
0687			 
0687			; file format: 
0687			; byte 0 - file id 
0687			; byte 1 - extent number 
0687			; byte 2-> data 
0687			 
0687			; format for extent number 0: 
0687			; 
0687			; byte 0 - file id 
0687			; byte 1 - extent 0 
0687			; byte 2 - extent count 
0687			; byte 3 -> file name and meta data 
0687			 
0687			 
0687			storage_create: 
0687				if DEBUG_STORESE 
0687					DMARK "SCR" 
0687 f5				push af  
0688 3a 9c 06			ld a, (.dmark)  
068b 32 6b ee			ld (debug_mark),a  
068e 3a 9d 06			ld a, (.dmark+1)  
0691 32 6c ee			ld (debug_mark+1),a  
0694 3a 9e 06			ld a, (.dmark+2)  
0697 32 6d ee			ld (debug_mark+2),a  
069a 18 03			jr .pastdmark  
069c ..			.dmark: db "SCR"  
069f f1			.pastdmark: pop af  
06a0			endm  
# End of macro DMARK
06a0					CALLMONITOR 
06a0 cd 6f ee			call debug_vector  
06a3				endm  
# End of macro CALLMONITOR
06a3				endif 
06a3			 
06a3 e5				push hl		; save file name pointer 
06a4			 
06a4 cd 35 03			call storage_get_block_0 
06a7			 
06a7 3a 7a ea			ld a,(store_page)	; get current file id 
06aa 3c				inc a 
06ab 32 7a ea			ld (store_page),a 
06ae				 
06ae 32 6e ea			ld (store_tmpid),a			; save id 
06b1			 
06b1 21 00 00			ld hl, 0 
06b4 11 7a ea			ld de, store_page 
06b7				if DEBUG_STORESE 
06b7					DMARK "SCw" 
06b7 f5				push af  
06b8 3a cc 06			ld a, (.dmark)  
06bb 32 6b ee			ld (debug_mark),a  
06be 3a cd 06			ld a, (.dmark+1)  
06c1 32 6c ee			ld (debug_mark+1),a  
06c4 3a ce 06			ld a, (.dmark+2)  
06c7 32 6d ee			ld (debug_mark+2),a  
06ca 18 03			jr .pastdmark  
06cc ..			.dmark: db "SCw"  
06cf f1			.pastdmark: pop af  
06d0			endm  
# End of macro DMARK
06d0					CALLMONITOR 
06d0 cd 6f ee			call debug_vector  
06d3				endm  
# End of macro CALLMONITOR
06d3				endif 
06d3 cd e9 02			call storage_write_block	 ; save update 
06d6			 
06d6				if DEBUG_STORESE 
06d6 11 7a ea				ld de, store_page 
06d9					DMARK "SCC" 
06d9 f5				push af  
06da 3a ee 06			ld a, (.dmark)  
06dd 32 6b ee			ld (debug_mark),a  
06e0 3a ef 06			ld a, (.dmark+1)  
06e3 32 6c ee			ld (debug_mark+1),a  
06e6 3a f0 06			ld a, (.dmark+2)  
06e9 32 6d ee			ld (debug_mark+2),a  
06ec 18 03			jr .pastdmark  
06ee ..			.dmark: db "SCC"  
06f1 f1			.pastdmark: pop af  
06f2			endm  
# End of macro DMARK
06f2					CALLMONITOR 
06f2 cd 6f ee			call debug_vector  
06f5				endm  
# End of macro CALLMONITOR
06f5				endif 
06f5				;  
06f5				 
06f5 21 40 00			ld hl, STORE_BLOCK_PHY 
06f8 11 00 00			ld de, 0 
06fb cd b7 05			call storage_findnextid 
06fe			 
06fe 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
0701			 
0701				; TODO detect 0 = no spare blocks 
0701			 
0701				; hl now contains the free page to use for the file header page 
0701			 
0701				if DEBUG_STORESE 
0701				DMARK "SCF" 
0701 f5				push af  
0702 3a 16 07			ld a, (.dmark)  
0705 32 6b ee			ld (debug_mark),a  
0708 3a 17 07			ld a, (.dmark+1)  
070b 32 6c ee			ld (debug_mark+1),a  
070e 3a 18 07			ld a, (.dmark+2)  
0711 32 6d ee			ld (debug_mark+2),a  
0714 18 03			jr .pastdmark  
0716 ..			.dmark: db "SCF"  
0719 f1			.pastdmark: pop af  
071a			endm  
# End of macro DMARK
071a					CALLMONITOR 
071a cd 6f ee			call debug_vector  
071d				endm  
# End of macro CALLMONITOR
071d				endif 
071d			 
071d 22 65 ea			ld (store_tmppageid), hl 
0720				 
0720 3a 6e ea			ld a,(store_tmpid)    ; get file id 
0723			;	ld a, (store_filecache)			; save to cache 
0723			 
0723 32 7a ea			ld (store_page),a    ; set page id 
0726 3e 00			ld a, 0			 ; extent 0 is file header 
0728 32 7b ea			ld (store_page+1), a   ; set file extent 
072b			 
072b 32 7c ea			ld (store_page+2), a   ; extent count for the file 
072e			 
072e			;	inc hl 		; init block 0 of file 
072e			;	inc hl   		; skip file and extent id 
072e			 ;       ld a, 0 
072e			;	ld (hl),a 
072e			;	ld a, (store_filecache+1)  	; save to cache 
072e			 
072e			;	inc hl    ; file name 
072e				 
072e				 
072e 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0731				if DEBUG_STORESE 
0731					DMARK "SCc" 
0731 f5				push af  
0732 3a 46 07			ld a, (.dmark)  
0735 32 6b ee			ld (debug_mark),a  
0738 3a 47 07			ld a, (.dmark+1)  
073b 32 6c ee			ld (debug_mark+1),a  
073e 3a 48 07			ld a, (.dmark+2)  
0741 32 6d ee			ld (debug_mark+2),a  
0744 18 03			jr .pastdmark  
0746 ..			.dmark: db "SCc"  
0749 f1			.pastdmark: pop af  
074a			endm  
# End of macro DMARK
074a					CALLMONITOR 
074a cd 6f ee			call debug_vector  
074d				endm  
# End of macro CALLMONITOR
074d				endif 
074d e1				pop hl    ; get zero term string 
074e e5				push hl 
074f 3e 00			ld a, 0 
0751 cd 63 11			call strlent 
0754 23				inc hl   ; cover zero term 
0755 06 00			ld b,0 
0757 4d				ld c,l 
0758 e1				pop hl 
0759				;ex de, hl 
0759				if DEBUG_STORESE 
0759					DMARK "SCa" 
0759 f5				push af  
075a 3a 6e 07			ld a, (.dmark)  
075d 32 6b ee			ld (debug_mark),a  
0760 3a 6f 07			ld a, (.dmark+1)  
0763 32 6c ee			ld (debug_mark+1),a  
0766 3a 70 07			ld a, (.dmark+2)  
0769 32 6d ee			ld (debug_mark+2),a  
076c 18 03			jr .pastdmark  
076e ..			.dmark: db "SCa"  
0771 f1			.pastdmark: pop af  
0772			endm  
# End of macro DMARK
0772					;push af 
0772					;ld a, 'a' 
0772					;ld (debug_mark),a 
0772					;pop af 
0772					CALLMONITOR 
0772 cd 6f ee			call debug_vector  
0775				endm  
# End of macro CALLMONITOR
0775				endif 
0775 ed b0			ldir    ; copy zero term string 
0777				if DEBUG_STORESE 
0777					DMARK "SCA" 
0777 f5				push af  
0778 3a 8c 07			ld a, (.dmark)  
077b 32 6b ee			ld (debug_mark),a  
077e 3a 8d 07			ld a, (.dmark+1)  
0781 32 6c ee			ld (debug_mark+1),a  
0784 3a 8e 07			ld a, (.dmark+2)  
0787 32 6d ee			ld (debug_mark+2),a  
078a 18 03			jr .pastdmark  
078c ..			.dmark: db "SCA"  
078f f1			.pastdmark: pop af  
0790			endm  
# End of macro DMARK
0790					CALLMONITOR 
0790 cd 6f ee			call debug_vector  
0793				endm  
# End of macro CALLMONITOR
0793				endif 
0793			 
0793				; write file header page 
0793			 
0793 2a 65 ea			ld hl,(store_tmppageid) 
0796 11 7a ea			ld de, store_page 
0799				if DEBUG_STORESE 
0799					DMARK "SCb" 
0799 f5				push af  
079a 3a ae 07			ld a, (.dmark)  
079d 32 6b ee			ld (debug_mark),a  
07a0 3a af 07			ld a, (.dmark+1)  
07a3 32 6c ee			ld (debug_mark+1),a  
07a6 3a b0 07			ld a, (.dmark+2)  
07a9 32 6d ee			ld (debug_mark+2),a  
07ac 18 03			jr .pastdmark  
07ae ..			.dmark: db "SCb"  
07b1 f1			.pastdmark: pop af  
07b2			endm  
# End of macro DMARK
07b2					;push af 
07b2					;ld a, 'b' 
07b2					;ld (debug_mark),a 
07b2					;pop af 
07b2					CALLMONITOR 
07b2 cd 6f ee			call debug_vector  
07b5				endm  
# End of macro CALLMONITOR
07b5				endif 
07b5 cd e9 02			call storage_write_block 
07b8			 
07b8 3a 6e ea			ld a, (store_tmpid) 
07bb 6f				ld l, a 
07bc 26 00			ld h,0 
07be				if DEBUG_STORESE 
07be					DMARK "SCz" 
07be f5				push af  
07bf 3a d3 07			ld a, (.dmark)  
07c2 32 6b ee			ld (debug_mark),a  
07c5 3a d4 07			ld a, (.dmark+1)  
07c8 32 6c ee			ld (debug_mark+1),a  
07cb 3a d5 07			ld a, (.dmark+2)  
07ce 32 6d ee			ld (debug_mark+2),a  
07d1 18 03			jr .pastdmark  
07d3 ..			.dmark: db "SCz"  
07d6 f1			.pastdmark: pop af  
07d7			endm  
# End of macro DMARK
07d7					CALLMONITOR 
07d7 cd 6f ee			call debug_vector  
07da				endm  
# End of macro CALLMONITOR
07da				endif 
07da c9				ret 
07db				 
07db			 
07db			 
07db			; 
07db			; Read File 
07db			; 
07db			; h - file id to locate 
07db			; l - extent to locate 
07db			; de - pointer to string to read into 
07db			; 
07db			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07db			 
07db			.sr_fail: 
07db d1				pop de 
07dc c9				ret 
07dd			 
07dd			storage_read: 
07dd			 
07dd			 
07dd d5				push de 
07de			 
07de			; TODO BUG the above push is it popped before the RET Z? 
07de			 
07de			; TODO how to handle multiple part blocks 
07de			 
07de				; locate file extent to read 
07de			 
07de 5c				ld e, h 
07df 55				ld d, l 
07e0			 
07e0			.srext: 
07e0 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
07e3 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07e7			 
07e7 21 40 00			ld hl, STORE_BLOCK_PHY 
07ea				if DEBUG_STORESE 
07ea					DMARK "sre" 
07ea f5				push af  
07eb 3a ff 07			ld a, (.dmark)  
07ee 32 6b ee			ld (debug_mark),a  
07f1 3a 00 08			ld a, (.dmark+1)  
07f4 32 6c ee			ld (debug_mark+1),a  
07f7 3a 01 08			ld a, (.dmark+2)  
07fa 32 6d ee			ld (debug_mark+2),a  
07fd 18 03			jr .pastdmark  
07ff ..			.dmark: db "sre"  
0802 f1			.pastdmark: pop af  
0803			endm  
# End of macro DMARK
0803					CALLMONITOR 
0803 cd 6f ee			call debug_vector  
0806				endm  
# End of macro CALLMONITOR
0806				endif 
0806 cd b7 05			call storage_findnextid 
0809			 
0809				if DEBUG_STORESE 
0809					DMARK "srf" 
0809 f5				push af  
080a 3a 1e 08			ld a, (.dmark)  
080d 32 6b ee			ld (debug_mark),a  
0810 3a 1f 08			ld a, (.dmark+1)  
0813 32 6c ee			ld (debug_mark+1),a  
0816 3a 20 08			ld a, (.dmark+2)  
0819 32 6d ee			ld (debug_mark+2),a  
081c 18 03			jr .pastdmark  
081e ..			.dmark: db "srf"  
0821 f1			.pastdmark: pop af  
0822			endm  
# End of macro DMARK
0822					CALLMONITOR 
0822 cd 6f ee			call debug_vector  
0825				endm  
# End of macro CALLMONITOR
0825				endif 
0825 cd 1b 0e			call ishlzero 
0828			;	ld a, l 
0828			;	add h 
0828			;	cp 0 
0828 28 b1			jr z,.sr_fail			; block not found so EOF 
082a			 
082a				; save current address for use by higher level words etc 
082a			 
082a 22 6b ea			ld (store_openaddr),hl 
082d			 
082d			 
082d				; hl contains page number to load 
082d d1				pop de   ; get storage 
082e ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
0832 d5				push de 
0833				if DEBUG_STORESE 
0833					DMARK "srg" 
0833 f5				push af  
0834 3a 48 08			ld a, (.dmark)  
0837 32 6b ee			ld (debug_mark),a  
083a 3a 49 08			ld a, (.dmark+1)  
083d 32 6c ee			ld (debug_mark+1),a  
0840 3a 4a 08			ld a, (.dmark+2)  
0843 32 6d ee			ld (debug_mark+2),a  
0846 18 03			jr .pastdmark  
0848 ..			.dmark: db "srg"  
084b f1			.pastdmark: pop af  
084c			endm  
# End of macro DMARK
084c					CALLMONITOR 
084c cd 6f ee			call debug_vector  
084f				endm  
# End of macro CALLMONITOR
084f				endif 
084f cd 84 02			call storage_read_block 
0852			 
0852				; if this a continuation read??? 
0852			 
0852 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0855			 
0855 3e 3f			ld a, STORE_BLOCK_PHY-1 
0857 cd f2 0d			call addatohl 
085a 7e				ld a,(hl) 
085b fe 00			cp 0 
085d 28 02			jr z, .markiscont 
085f 3e ff			ld a, 255 
0861			 
0861			.markiscont: 
0861 32 6d ea			ld (store_readcont), a 
0864			 
0864				if DEBUG_STORESE 
0864					DMARK "srC" 
0864 f5				push af  
0865 3a 79 08			ld a, (.dmark)  
0868 32 6b ee			ld (debug_mark),a  
086b 3a 7a 08			ld a, (.dmark+1)  
086e 32 6c ee			ld (debug_mark+1),a  
0871 3a 7b 08			ld a, (.dmark+2)  
0874 32 6d ee			ld (debug_mark+2),a  
0877 18 03			jr .pastdmark  
0879 ..			.dmark: db "srC"  
087c f1			.pastdmark: pop af  
087d			endm  
# End of macro DMARK
087d					CALLMONITOR 
087d cd 6f ee			call debug_vector  
0880				endm  
# End of macro CALLMONITOR
0880				endif 
0880				; only short reads enabled 
0880			 
0880 3a 75 ea			ld a, (store_longread) 
0883 fe 00			cp 0 
0885 ca 52 09			jp z, .readdone 
0888			 
0888			; TODO if block has no zeros then need to read next block  
0888			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0888			; check last byte of physical block. 
0888			; if not zero then the next block needs to be loaded 
0888			 
0888			 
0888 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
088b			 
088b 3e 3f			ld a, STORE_BLOCK_PHY-1 
088d cd f2 0d			call addatohl 
0890				;dec hl 
0890 7e				ld a,(hl) 
0891				if DEBUG_STORESE 
0891					DMARK "sr?" 
0891 f5				push af  
0892 3a a6 08			ld a, (.dmark)  
0895 32 6b ee			ld (debug_mark),a  
0898 3a a7 08			ld a, (.dmark+1)  
089b 32 6c ee			ld (debug_mark+1),a  
089e 3a a8 08			ld a, (.dmark+2)  
08a1 32 6d ee			ld (debug_mark+2),a  
08a4 18 03			jr .pastdmark  
08a6 ..			.dmark: db "sr?"  
08a9 f1			.pastdmark: pop af  
08aa			endm  
# End of macro DMARK
08aa					CALLMONITOR 
08aa cd 6f ee			call debug_vector  
08ad				endm  
# End of macro CALLMONITOR
08ad				endif 
08ad fe 00			cp 0 
08af ca 52 09			jp z, .readdone 
08b2			 
08b2				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08b2			 
08b2 23				inc hl 
08b3			 
08b3 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08b6			 
08b6 ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
08ba			 
08ba eb				ex de, hl 
08bb			 
08bb				; next ext 
08bb			 
08bb 23				inc hl 
08bc 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
08bf			 
08bf				if DEBUG_STORESE 
08bf					DMARK "sF2" 
08bf f5				push af  
08c0 3a d4 08			ld a, (.dmark)  
08c3 32 6b ee			ld (debug_mark),a  
08c6 3a d5 08			ld a, (.dmark+1)  
08c9 32 6c ee			ld (debug_mark+1),a  
08cc 3a d6 08			ld a, (.dmark+2)  
08cf 32 6d ee			ld (debug_mark+2),a  
08d2 18 03			jr .pastdmark  
08d4 ..			.dmark: db "sF2"  
08d7 f1			.pastdmark: pop af  
08d8			endm  
# End of macro DMARK
08d8					CALLMONITOR 
08d8 cd 6f ee			call debug_vector  
08db				endm  
# End of macro CALLMONITOR
08db				endif 
08db			 
08db				; get and load block 
08db			 
08db cd b7 05			call storage_findnextid 
08de			 
08de				if DEBUG_STORESE 
08de					DMARK "sf2" 
08de f5				push af  
08df 3a f3 08			ld a, (.dmark)  
08e2 32 6b ee			ld (debug_mark),a  
08e5 3a f4 08			ld a, (.dmark+1)  
08e8 32 6c ee			ld (debug_mark+1),a  
08eb 3a f5 08			ld a, (.dmark+2)  
08ee 32 6d ee			ld (debug_mark+2),a  
08f1 18 03			jr .pastdmark  
08f3 ..			.dmark: db "sf2"  
08f6 f1			.pastdmark: pop af  
08f7			endm  
# End of macro DMARK
08f7					CALLMONITOR 
08f7 cd 6f ee			call debug_vector  
08fa				endm  
# End of macro CALLMONITOR
08fa				endif 
08fa cd 1b 0e			call ishlzero 
08fd			;	ld a, l 
08fd			;	add h 
08fd			;	cp 0 
08fd ca db 07			jp z,.sr_fail			; block not found so EOF 
0900				 
0900				; save current address for use by higher level words etc 
0900			 
0900 22 6b ea			ld (store_openaddr),hl 
0903			 
0903 cd 84 02			call storage_read_block 
0906			 
0906				; on a continuation block, we now have the file id and ext in the middle of the block 
0906				; we need to pull everything back  
0906			 
0906 ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
090a 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
090d 23				inc hl 
090e 23				inc hl     ; skip id and ext 
090f 01 40 00			ld bc, STORE_BLOCK_PHY 
0912				if DEBUG_STORESE 
0912					DMARK "SR<" 
0912 f5				push af  
0913 3a 27 09			ld a, (.dmark)  
0916 32 6b ee			ld (debug_mark),a  
0919 3a 28 09			ld a, (.dmark+1)  
091c 32 6c ee			ld (debug_mark+1),a  
091f 3a 29 09			ld a, (.dmark+2)  
0922 32 6d ee			ld (debug_mark+2),a  
0925 18 03			jr .pastdmark  
0927 ..			.dmark: db "SR<"  
092a f1			.pastdmark: pop af  
092b			endm  
# End of macro DMARK
092b					CALLMONITOR 
092b cd 6f ee			call debug_vector  
092e				endm  
# End of macro CALLMONITOR
092e				endif 
092e ed b0			ldir     ; copy data 
0930			 
0930				; move the pointer back and pretend we have a full buffer for next recheck 
0930			 
0930 1b				dec de 
0931 1b				dec de 
0932			 
0932			; TODO do pop below now short circuit loop????? 
0932 c1				pop bc     ; get rid of spare de on stack 
0933				if DEBUG_STORESE 
0933					DMARK "SR>" 
0933 f5				push af  
0934 3a 48 09			ld a, (.dmark)  
0937 32 6b ee			ld (debug_mark),a  
093a 3a 49 09			ld a, (.dmark+1)  
093d 32 6c ee			ld (debug_mark+1),a  
0940 3a 4a 09			ld a, (.dmark+2)  
0943 32 6d ee			ld (debug_mark+2),a  
0946 18 03			jr .pastdmark  
0948 ..			.dmark: db "SR>"  
094b f1			.pastdmark: pop af  
094c			endm  
# End of macro DMARK
094c					CALLMONITOR 
094c cd 6f ee			call debug_vector  
094f				endm  
# End of macro CALLMONITOR
094f				endif 
094f c3 e0 07			jp .srext 
0952			 
0952			 
0952			 
0952			 
0952			 
0952			.readdone:		 
0952 e1				pop hl 		 ; return start of data to show as not EOF 
0953 23				inc hl   ; past file id 
0954 23				inc hl   ; past ext 
0955				if DEBUG_STORESE 
0955					DMARK "SRe" 
0955 f5				push af  
0956 3a 6a 09			ld a, (.dmark)  
0959 32 6b ee			ld (debug_mark),a  
095c 3a 6b 09			ld a, (.dmark+1)  
095f 32 6c ee			ld (debug_mark+1),a  
0962 3a 6c 09			ld a, (.dmark+2)  
0965 32 6d ee			ld (debug_mark+2),a  
0968 18 03			jr .pastdmark  
096a ..			.dmark: db "SRe"  
096d f1			.pastdmark: pop af  
096e			endm  
# End of macro DMARK
096e					CALLMONITOR 
096e cd 6f ee			call debug_vector  
0971				endm  
# End of macro CALLMONITOR
0971				endif 
0971 c9					ret 
0972			 
0972			 
0972			 
0972			; 
0972			; Append File 
0972			; 
0972			; hl - file id to locate 
0972			; de - pointer to (multi block) string to write 
0972			 
0972			.sa_notfound: 
0972 d1				pop de 
0973 c9				ret 
0974			 
0974			 
0974			storage_append: 
0974				; hl -  file id to append to 
0974				; de - string to append 
0974			 
0974 d5				push de 
0975				 
0975				if DEBUG_STORESE 
0975					DMARK "AP1" 
0975 f5				push af  
0976 3a 8a 09			ld a, (.dmark)  
0979 32 6b ee			ld (debug_mark),a  
097c 3a 8b 09			ld a, (.dmark+1)  
097f 32 6c ee			ld (debug_mark+1),a  
0982 3a 8c 09			ld a, (.dmark+2)  
0985 32 6d ee			ld (debug_mark+2),a  
0988 18 03			jr .pastdmark  
098a ..			.dmark: db "AP1"  
098d f1			.pastdmark: pop af  
098e			endm  
# End of macro DMARK
098e					CALLMONITOR 
098e cd 6f ee			call debug_vector  
0991				endm  
# End of macro CALLMONITOR
0991				endif 
0991			 
0991 7d				ld a, l 
0992 32 6e ea			ld (store_tmpid), a 
0995			 
0995				; get file header  
0995			 
0995 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0997 3a 6e ea			ld a, (store_tmpid) 
099a 5f				ld e, a 
099b			 
099b 21 40 00				ld hl, STORE_BLOCK_PHY 
099e cd b7 05				call storage_findnextid 
09a1			 
09a1 cd 1b 0e			call ishlzero 
09a4 28 cc			jr z, .sa_notfound 
09a6			 
09a6 22 65 ea			ld (store_tmppageid), hl 
09a9			 
09a9				; TODO handle file id not found 
09a9			 
09a9				if DEBUG_STORESE 
09a9					DMARK "AP2" 
09a9 f5				push af  
09aa 3a be 09			ld a, (.dmark)  
09ad 32 6b ee			ld (debug_mark),a  
09b0 3a bf 09			ld a, (.dmark+1)  
09b3 32 6c ee			ld (debug_mark+1),a  
09b6 3a c0 09			ld a, (.dmark+2)  
09b9 32 6d ee			ld (debug_mark+2),a  
09bc 18 03			jr .pastdmark  
09be ..			.dmark: db "AP2"  
09c1 f1			.pastdmark: pop af  
09c2			endm  
# End of macro DMARK
09c2					CALLMONITOR 
09c2 cd 6f ee			call debug_vector  
09c5				endm  
# End of macro CALLMONITOR
09c5				endif 
09c5			 
09c5				; update file extent count 
09c5			 
09c5 11 7a ea			ld de, store_page 
09c8			 
09c8 cd 84 02			call storage_read_block 
09cb			 
09cb				if DEBUG_STORESE 
09cb					DMARK "AP3" 
09cb f5				push af  
09cc 3a e0 09			ld a, (.dmark)  
09cf 32 6b ee			ld (debug_mark),a  
09d2 3a e1 09			ld a, (.dmark+1)  
09d5 32 6c ee			ld (debug_mark+1),a  
09d8 3a e2 09			ld a, (.dmark+2)  
09db 32 6d ee			ld (debug_mark+2),a  
09de 18 03			jr .pastdmark  
09e0 ..			.dmark: db "AP3"  
09e3 f1			.pastdmark: pop af  
09e4			endm  
# End of macro DMARK
09e4					CALLMONITOR 
09e4 cd 6f ee			call debug_vector  
09e7				endm  
# End of macro CALLMONITOR
09e7				endif 
09e7			;	ld (store_tmppageid), hl 
09e7			 
09e7 3a 7c ea			ld a, (store_page+2) 
09ea 3c				inc a 
09eb 32 7c ea			ld (store_page+2), a 
09ee 32 6d ea			ld (store_tmpext), a 
09f1				 
09f1				if DEBUG_STORESE 
09f1					DMARK "AP3" 
09f1 f5				push af  
09f2 3a 06 0a			ld a, (.dmark)  
09f5 32 6b ee			ld (debug_mark),a  
09f8 3a 07 0a			ld a, (.dmark+1)  
09fb 32 6c ee			ld (debug_mark+1),a  
09fe 3a 08 0a			ld a, (.dmark+2)  
0a01 32 6d ee			ld (debug_mark+2),a  
0a04 18 03			jr .pastdmark  
0a06 ..			.dmark: db "AP3"  
0a09 f1			.pastdmark: pop af  
0a0a			endm  
# End of macro DMARK
0a0a					CALLMONITOR 
0a0a cd 6f ee			call debug_vector  
0a0d				endm  
# End of macro CALLMONITOR
0a0d				endif 
0a0d 2a 65 ea			ld hl, (store_tmppageid) 
0a10 11 7a ea			ld de, store_page 
0a13 cd e9 02			call storage_write_block 
0a16			 
0a16				; find free block 
0a16			 
0a16 11 00 00			ld de, 0			 ; file extent to locate 
0a19			 
0a19 21 40 00				ld hl, STORE_BLOCK_PHY 
0a1c cd b7 05				call storage_findnextid 
0a1f cd 1b 0e			call ishlzero 
0a22 ca 72 09			jp z, .sa_notfound 
0a25			 
0a25					; TODO handle no space left 
0a25					 
0a25 22 65 ea				ld (store_tmppageid), hl 
0a28			 
0a28				if DEBUG_STORESE 
0a28					DMARK "AP4" 
0a28 f5				push af  
0a29 3a 3d 0a			ld a, (.dmark)  
0a2c 32 6b ee			ld (debug_mark),a  
0a2f 3a 3e 0a			ld a, (.dmark+1)  
0a32 32 6c ee			ld (debug_mark+1),a  
0a35 3a 3f 0a			ld a, (.dmark+2)  
0a38 32 6d ee			ld (debug_mark+2),a  
0a3b 18 03			jr .pastdmark  
0a3d ..			.dmark: db "AP4"  
0a40 f1			.pastdmark: pop af  
0a41			endm  
# End of macro DMARK
0a41					CALLMONITOR 
0a41 cd 6f ee			call debug_vector  
0a44				endm  
# End of macro CALLMONITOR
0a44				endif 
0a44					; init the buffer with zeros so we can id if the buffer is full or not 
0a44			 
0a44 e5					push hl 
0a45 c5					push bc 
0a46			 
0a46 21 7a ea				ld hl, store_page 
0a49 06 40				ld b, STORE_BLOCK_PHY 
0a4b 3e 00				ld a, 0 
0a4d 77			.zeroblock:	ld (hl), a 
0a4e 23					inc hl 
0a4f 10 fc				djnz .zeroblock 
0a51			 
0a51 c1					pop bc 
0a52 e1					pop hl 
0a53			 
0a53					; construct block 
0a53			 
0a53 3a 6e ea				ld a, (store_tmpid) 
0a56 32 7a ea				ld (store_page), a   ; file id 
0a59 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
0a5c 32 7b ea				ld (store_page+1), a 
0a5f			 
0a5f e1					pop hl    ; get string to write 
0a60 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a62 11 7c ea				ld de, store_page+2 
0a65			 
0a65				if DEBUG_STORESE 
0a65					DMARK "AP5" 
0a65 f5				push af  
0a66 3a 7a 0a			ld a, (.dmark)  
0a69 32 6b ee			ld (debug_mark),a  
0a6c 3a 7b 0a			ld a, (.dmark+1)  
0a6f 32 6c ee			ld (debug_mark+1),a  
0a72 3a 7c 0a			ld a, (.dmark+2)  
0a75 32 6d ee			ld (debug_mark+2),a  
0a78 18 03			jr .pastdmark  
0a7a ..			.dmark: db "AP5"  
0a7d f1			.pastdmark: pop af  
0a7e			endm  
# End of macro DMARK
0a7e					CALLMONITOR 
0a7e cd 6f ee			call debug_vector  
0a81				endm  
# End of macro CALLMONITOR
0a81				endif 
0a81			 
0a81			 
0a81			 
0a81					; fill buffer with data until end of string or full block 
0a81			 
0a81 7e			.appd:		ld a, (hl) 
0a82 12					ld (de), a 
0a83 fe 00				cp 0 
0a85 28 04				jr z, .appdone 
0a87 23					inc hl 
0a88 13					inc de 
0a89 10 f6				djnz .appd 
0a8b			 
0a8b e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a8c f5					push af   		; save last byte dumped 
0a8d			 
0a8d			 
0a8d 2a 65 ea			ld hl, (store_tmppageid) 
0a90 11 7a ea			ld de, store_page 
0a93				if DEBUG_STORESE 
0a93					DMARK "AP6" 
0a93 f5				push af  
0a94 3a a8 0a			ld a, (.dmark)  
0a97 32 6b ee			ld (debug_mark),a  
0a9a 3a a9 0a			ld a, (.dmark+1)  
0a9d 32 6c ee			ld (debug_mark+1),a  
0aa0 3a aa 0a			ld a, (.dmark+2)  
0aa3 32 6d ee			ld (debug_mark+2),a  
0aa6 18 03			jr .pastdmark  
0aa8 ..			.dmark: db "AP6"  
0aab f1			.pastdmark: pop af  
0aac			endm  
# End of macro DMARK
0aac					CALLMONITOR 
0aac cd 6f ee			call debug_vector  
0aaf				endm  
# End of macro CALLMONITOR
0aaf				endif 
0aaf cd e9 02				call storage_write_block 
0ab2			 
0ab2			 
0ab2				; was that a full block of data written? 
0ab2				; any more to write out? 
0ab2			 
0ab2				; if yes then set vars and jump to start of function again 
0ab2			 
0ab2 f1					pop af 
0ab3 d1					pop de 
0ab4			 
0ab4 fe 00				cp 0		 ; no, string was fully written 
0ab6 c8					ret z 
0ab7			 
0ab7					; setup vars for next cycle 
0ab7			 
0ab7 3a 6e ea				ld a, (store_tmpid) 
0aba 6f					ld l, a 
0abb 26 00				ld h, 0 
0abd			 
0abd c3 74 09			 	jp storage_append	 ; yes, need to write out some more 
0ac0			 
0ac0			 
0ac0			 
0ac0			 
0ac0			 
0ac0			 
0ac0			 
0ac0			if DEBUG_STORECF 
0ac0			storageput:	 
0ac0					ret 
0ac0			storageread: 
0ac0					ld hl, store_page 
0ac0					ld b, 200 
0ac0					ld a,0 
0ac0			.src:		ld (hl),a 
0ac0					inc hl 
0ac0					djnz .src 
0ac0					 
0ac0			 
0ac0					ld de, 0 
0ac0					ld bc, 1 
0ac0					ld hl, store_page 
0ac0					call cfRead 
0ac0			 
0ac0				call cfGetError 
0ac0				ld hl,scratch 
0ac0				call hexout 
0ac0				ld hl, scratch+2 
0ac0				ld a, 0 
0ac0				ld (hl),a 
0ac0				ld de, scratch 
0ac0				ld a,display_row_1 
0ac0				call str_at_display 
0ac0				call update_display 
0ac0			 
0ac0					ld hl, store_page 
0ac0					ld (os_cur_ptr),hl 
0ac0			 
0ac0					ret 
0ac0			endif 
0ac0			 
0ac0			 
0ac0			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ac0			 
0ac0			storage_clear_page: 
0ac0 e5				push hl 
0ac1 d5				push de 
0ac2 c5				push bc 
0ac3 21 7a ea			ld hl, store_page 
0ac6 3e 00			ld a, 0 
0ac8 77				ld (hl), a 
0ac9			 
0ac9 11 7b ea			ld de, store_page+1 
0acc 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0acf			 
0acf ed b0			ldir 
0ad1				 
0ad1 c1				pop bc 
0ad2 d1				pop de 
0ad3 e1				pop hl 
0ad4 c9				ret 
0ad5			 
0ad5			; eof 
# End of file firmware_storage.asm
0ad5			  
0ad5			; support routines for above hardware abstraction layer  
0ad5			  
0ad5			include "firmware_general.asm"        ; general support functions  
0ad5			 
0ad5			; word look up 
0ad5			 
0ad5			; in 
0ad5			; a is the index 
0ad5			; hl is pointer start of array 
0ad5			; 
0ad5			; returns 
0ad5			; hl to the word 
0ad5			; 
0ad5			 
0ad5			table_lookup:  
0ad5 d5					push de 
0ad6 eb					ex de, hl 
0ad7			 
0ad7 6f					ld l, a 
0ad8 26 00				ld h, 0 
0ada 29					add hl, hl 
0adb 19					add hl, de 
0adc 7e					ld a, (hl) 
0add 23					inc hl 
0ade 66					ld h,(hl) 
0adf 6f					ld l, a 
0ae0			 
0ae0 d1					pop de 
0ae1 c9					ret 
0ae2			 
0ae2			; Delay loops 
0ae2			 
0ae2			 
0ae2			 
0ae2			aDelayInMS: 
0ae2 c5				push bc 
0ae3 47				ld b,a 
0ae4			msdelay: 
0ae4 c5				push bc 
0ae5				 
0ae5			 
0ae5 01 41 00			ld bc,041h 
0ae8 cd 00 0b			call delayloop 
0aeb c1				pop bc 
0aec 05				dec b 
0aed 20 f5			jr nz,msdelay 
0aef			 
0aef			;if CPU_CLOCK_8MHZ 
0aef			;msdelay8: 
0aef			;	push bc 
0aef			;	 
0aef			; 
0aef			;	ld bc,041h 
0aef			;	call delayloop 
0aef			;	pop bc 
0aef			;	dec b 
0aef			;	jr nz,msdelay8 
0aef			;endif 
0aef			 
0aef			 
0aef c1				pop bc 
0af0 c9				ret 
0af1			 
0af1			 
0af1			delay250ms: 
0af1				;push de 
0af1 01 00 40			ld bc, 04000h 
0af4 c3 00 0b			jp delayloop 
0af7			delay500ms: 
0af7				;push de 
0af7 01 00 80			ld bc, 08000h 
0afa c3 00 0b			jp delayloop 
0afd			delay1s: 
0afd				;push bc 
0afd			   ; Clobbers A, d and e 
0afd 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0b00			delayloop: 
0b00 c5			    push bc 
0b01			 
0b01			if BASE_CPM 
0b01 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0b04			.cpmloop: 
0b04 c5				push bc 
0b05			 
0b05			endif 
0b05			 
0b05			 
0b05			 
0b05			delayloopi: 
0b05			;	push bc 
0b05			;.dl: 
0b05 cb 47		    bit     0,a    	; 8 
0b07 cb 47		    bit     0,a    	; 8 
0b09 cb 47		    bit     0,a    	; 8 
0b0b e6 ff		    and     255  	; 7 
0b0d 0b			    dec     bc      	; 6 
0b0e 79			    ld      a,c     	; 4 
0b0f b0			    or      b     	; 4 
0b10 c2 05 0b		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b13			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b13				;pop de 
0b13			;pop bc 
0b13			 
0b13			if BASE_CPM 
0b13 c1				pop bc 
0b14				 
0b14 0b			    dec     bc      	; 6 
0b15 79			    ld      a,c     	; 4 
0b16 b0			    or      b     	; 4 
0b17 c2 04 0b		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b1a				 
0b1a			 
0b1a			endif 
0b1a			;if CPU_CLOCK_8MHZ 
0b1a			;    pop bc 
0b1a			;    push bc 
0b1a			;.dl8: 
0b1a			;    bit     0,a    	; 8 
0b1a			;    bit     0,a    	; 8 
0b1a			;    bit     0,a    	; 8 
0b1a			;    and     255  	; 7 
0b1a			;    dec     bc      	; 6 
0b1a			;    ld      a,c     	; 4 
0b1a			;    or      b     	; 4 
0b1a			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b1a			;endif 
0b1a			 
0b1a			;if CPU_CLOCK_10MHZ 
0b1a			;    pop bc 
0b1a			;    push bc 
0b1a			;.dl8: 
0b1a			;    bit     0,a    	; 8 
0b1a			;    bit     0,a    	; 8 
0b1a			;    bit     0,a    	; 8 
0b1a			;    and     255  	; 7 
0b1a			;    dec     bc      	; 6 
0b1a			;    ld      a,c     	; 4 
0b1a			;    or      b     	; 4 
0b1a			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b1a			;endif 
0b1a c1			    pop bc 
0b1b			 
0b1b c9				ret 
0b1c			 
0b1c			 
0b1c			 
0b1c			; eof 
# End of file firmware_general.asm
0b1c			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b1c			; display routines that use the physical hardware abstraction layer 
0b1c			 
0b1c			 
0b1c			; Display an activity indicator 
0b1c			; Each call returns the new char pointed to in hl 
0b1c			 
0b1c			active: 
0b1c 3a c6 eb			ld a, (display_active) 
0b1f fe 06			cp 6 
0b21			 
0b21 20 02			jr nz, .sne 
0b23				; gone past the last one reset sequence 
0b23 3e ff			ld a, 255 
0b25			 
0b25			.sne:   
0b25				; get the next char in seq 
0b25 3c				inc a 
0b26 32 c6 eb			ld (display_active), a 
0b29			 
0b29				; look up the string in the table 
0b29 21 40 0b			ld hl, actseq 
0b2c cb 27			sla a 
0b2e cd f2 0d			call addatohl 
0b31 cd b6 1e			call loadwordinhl 
0b34			 
0b34				; forth will write the to string when pushing so move from rom to ram 
0b34			 
0b34 11 c7 eb			ld de, display_active+1 
0b37 01 02 00			ld bc, 2 
0b3a ed b0			ldir 
0b3c			 
0b3c 21 c7 eb			ld hl, display_active+1 
0b3f c9				ret 
0b40				 
0b40				 
0b40			 
0b40			 
0b40			;db "|/-\|-\" 
0b40			 
0b40			actseq: 
0b40			 
0b40 4e 0b		dw spin0 
0b42 50 0b		dw spin1 
0b44 52 0b		dw spin2 
0b46 54 0b		dw spin3 
0b48 52 0b		dw spin2 
0b4a 50 0b		dw spin1 
0b4c 4e 0b		dw spin0 
0b4e			 
0b4e .. 00		spin0: db " ", 0 
0b50 .. 00		spin1: db "-", 0 
0b52 .. 00		spin2: db "+", 0 
0b54 .. 00		spin3: db "#", 0 
0b56			 
0b56			 
0b56			; information window 
0b56			 
0b56			; pass hl with 1st string to display 
0b56			; pass de with 2nd string to display 
0b56			 
0b56			info_panel: 
0b56 e5				push hl 
0b57			 
0b57 2a cc eb			ld hl, (display_fb_active) 
0b5a e5				push hl    ; future de destination 
0b5b 21 b1 ed				ld hl, display_fb0 
0b5e 22 cc eb				ld (display_fb_active), hl 
0b61			 
0b61			;	call clear_display 
0b61			 
0b61				if BASE_CPM 
0b61 3e 2e			ld a, '.' 
0b63				else 
0b63				ld a, 165 
0b63				endif 
0b63 cd ca 0b			call fill_display 
0b66			 
0b66			 
0b66 3e 55			ld a, display_row_3 + 5 
0b68 cd d8 0b			call str_at_display 
0b6b			 
0b6b e1				pop hl 
0b6c d1				pop de 
0b6d			 
0b6d e5				push hl 
0b6e			 
0b6e			 
0b6e 3e 2d			ld a, display_row_2 + 5 
0b70 cd d8 0b			call str_at_display 
0b73			 
0b73			 
0b73 cd e8 0b			call update_display 
0b76 cd f1 1a			call next_page_prompt 
0b79 cd c5 0b			call clear_display 
0b7c			 
0b7c				 
0b7c 21 10 ed				ld hl, display_fb1 
0b7f 22 cc eb				ld (display_fb_active), hl 
0b82 cd e8 0b			call update_display 
0b85			 
0b85 e1				pop hl 
0b86			 
0b86 c9				ret 
0b87			 
0b87			 
0b87			 
0b87			 
0b87			; TODO windowing? 
0b87			 
0b87			; TODO scroll line up 
0b87			 
0b87			scroll_up: 
0b87			 
0b87 e5				push hl 
0b88 d5				push de 
0b89 c5				push bc 
0b8a			 
0b8a				; get frame buffer  
0b8a			 
0b8a 2a cc eb			ld hl, (display_fb_active) 
0b8d e5				push hl    ; future de destination 
0b8e			 
0b8e 11 28 00			ld  de, display_cols 
0b91 19				add hl, de 
0b92			 
0b92 d1				pop de 
0b93			 
0b93				;ex de, hl 
0b93 01 9f 00			ld bc, display_fb_len -1  
0b96			;if DEBUG_FORTH_WORDS 
0b96			;	DMARK "SCL" 
0b96			;	CALLMONITOR 
0b96			;endif	 
0b96 ed b0			ldir 
0b98			 
0b98				; wipe bottom row 
0b98			 
0b98			 
0b98 2a cc eb			ld hl, (display_fb_active) 
0b9b 11 a0 00			ld de, display_cols*display_rows 
0b9e 19				add hl, de 
0b9f 06 28			ld b, display_cols 
0ba1 3e 20			ld a, ' ' 
0ba3			.scwipe: 
0ba3 77				ld (hl), a 
0ba4 2b				dec hl 
0ba5 10 fc			djnz .scwipe 
0ba7			 
0ba7				;pop hl 
0ba7			 
0ba7 c1				pop bc 
0ba8 d1				pop de 
0ba9 e1				pop hl 
0baa			 
0baa c9				ret 
0bab			 
0bab			 
0bab			;scroll_upo: 
0bab			;	ld de, display_row_1 
0bab			 ;	ld hl, display_row_2 
0bab			;	ld bc, display_cols 
0bab			;	ldir 
0bab			;	ld de, display_row_2 
0bab			 ;	ld hl, display_row_3 
0bab			;	ld bc, display_cols 
0bab			;	ldir 
0bab			;	ld de, display_row_3 
0bab			 ;	ld hl, display_row_4 
0bab			;	ld bc, display_cols 
0bab			;	ldir 
0bab			 
0bab			; TODO clear row 4 
0bab			 
0bab			;	ret 
0bab			 
0bab				 
0bab			scroll_down: 
0bab			 
0bab e5				push hl 
0bac d5				push de 
0bad c5				push bc 
0bae			 
0bae				; get frame buffer  
0bae			 
0bae 2a cc eb			ld hl, (display_fb_active) 
0bb1			 
0bb1 11 9f 00			ld de, display_fb_len - 1 
0bb4 19				add hl, de 
0bb5			 
0bb5 e5			push hl    ; future de destination 
0bb6			 
0bb6 11 28 00			ld  de, display_cols 
0bb9 ed 52			sbc hl, de 
0bbb			 
0bbb			 
0bbb d1				pop de 
0bbc			 
0bbc			;	ex de, hl 
0bbc 01 9f 00			ld bc, display_fb_len -1  
0bbf			 
0bbf			 
0bbf				 
0bbf			 
0bbf ed b0			ldir 
0bc1			 
0bc1				; wipe bottom row 
0bc1			 
0bc1			 
0bc1			;	ld hl, (display_fb_active) 
0bc1			;;	ld de, display_cols*display_rows 
0bc1			;;	add hl, de 
0bc1			;	ld b, display_cols 
0bc1			;	ld a, ' ' 
0bc1			;.scwiped: 
0bc1			;	ld (hl), a 
0bc1			;	dec hl 
0bc1			;	djnz .scwiped 
0bc1			 
0bc1				;pop hl 
0bc1			 
0bc1 c1				pop bc 
0bc2 d1				pop de 
0bc3 e1				pop hl 
0bc4			 
0bc4 c9				ret 
0bc5			;scroll_down: 
0bc5			;	ld de, display_row_4 
0bc5			;	ld hl, display_row_3 
0bc5			;	ld bc, display_cols 
0bc5			;	ldir 
0bc5			;	ld de, display_row_3 
0bc5			; 	ld hl, display_row_2 
0bc5			;	ld bc, display_cols 
0bc5			;	ldir 
0bc5			;	ld de, display_row_2 
0bc5			;	ld hl, display_row_1 
0bc5			;	ld bc, display_cols 
0bc5			;	ldir 
0bc5			;;; TODO clear row 1 
0bc5			;	ret 
0bc5			 
0bc5			 
0bc5			 
0bc5			 
0bc5			 
0bc5			; clear active frame buffer 
0bc5			 
0bc5			clear_display: 
0bc5 3e 20			ld a, ' ' 
0bc7 c3 ca 0b			jp fill_display 
0bca			 
0bca			; fill active frame buffer with a char in A 
0bca			 
0bca			fill_display: 
0bca 06 a0			ld b,display_fb_len 
0bcc 2a cc eb			ld hl, (display_fb_active) 
0bcf 77			.fd1:	ld (hl),a 
0bd0 23				inc hl 
0bd1 10 fc			djnz .fd1 
0bd3 23				inc hl 
0bd4 3e 00			ld a,0 
0bd6 77				ld (hl),a 
0bd7			 
0bd7			 
0bd7 c9				ret 
0bd8			; Write string (DE) at pos (A) to active frame buffer 
0bd8			 
0bd8 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
0bdb 06 00					ld b,0 
0bdd 4f					ld c,a 
0bde 09					add hl,bc 
0bdf 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0be0 b7			            OR   A              ;Null terminator? 
0be1 c8			            RET  Z              ;Yes, so finished 
0be2 77					ld (hl),a 
0be3 23				inc hl 
0be4 13			            INC  DE             ;Point to next character 
0be5 18 f8		            JR   .sad1     ;Repeat 
0be7 c9					ret 
0be8			 
0be8			; using current frame buffer write to physical display 
0be8			 
0be8			update_display: 
0be8 e5				push hl 
0be9 2a cc eb			ld hl, (display_fb_active) 
0bec cd b6 5d			call write_display 
0bef e1				pop hl 
0bf0 c9				ret 
0bf1			 
0bf1			; TODO scrolling 
0bf1			 
0bf1			 
0bf1			; move cursor right one char 
0bf1			cursor_right: 
0bf1			 
0bf1				; TODO shift right 
0bf1				; TODO if beyond max col 
0bf1				; TODO       cursor_next_line 
0bf1			 
0bf1 c9				ret 
0bf2			 
0bf2			 
0bf2			cursor_next_line: 
0bf2				; TODO first char 
0bf2				; TODO line down 
0bf2				; TODO if past last row 
0bf2				; TODO    scroll up 
0bf2			 
0bf2 c9				ret 
0bf3			 
0bf3			cursor_left: 
0bf3				; TODO shift left 
0bf3				; TODO if beyond left  
0bf3				; TODO     cursor prev line 
0bf3				 
0bf3 c9				ret 
0bf4			 
0bf4			cursor_prev_line: 
0bf4				; TODO last char 
0bf4				; TODO line up 
0bf4				; TODO if past first row 
0bf4				; TODO   scroll down 
0bf4			 
0bf4 c9				ret 
0bf5			 
0bf5			 
0bf5			cout: 
0bf5				; A - char 
0bf5 c9				ret 
0bf6			 
0bf6			 
0bf6			; Display a menu and allow item selection (optional toggle items) 
0bf6			; 
0bf6			; format: 
0bf6			; hl pointer to word array with zero term for items 
0bf6			; e.g.    db item1 
0bf6			;         db .... 
0bf6			;         db 0 
0bf6			; 
0bf6			; a = starting menu item  
0bf6			; 
0bf6			; de = pointer item toggle array   (todo) 
0bf6			; 
0bf6			; returns item selected in a 1-... 
0bf6			; returns 0 if back button pressed 
0bf6			; 
0bf6			; NOTE: Uses system frame buffer to display 
0bf6			; 
0bf6			; LEFT, Q = go back 
0bf6			; RIGHT, SPACE, CR = select 
0bf6			; UP, A - Up 
0bf6			; DOWN, Z - Down 
0bf6			 
0bf6			 
0bf6			 
0bf6			 
0bf6			 
0bf6			menu: 
0bf6			 
0bf6					; keep array pointer 
0bf6			 
0bf6 22 73 ea				ld (store_tmp1), hl 
0bf9 32 71 ea				ld (store_tmp2), a 
0bfc			 
0bfc					; check for key bounce 
0bfc			 
0bfc			if BASE_KEV 
0bfc			 
0bfc			.mbounce:	call cin 
0bfc					cp 0 
0bfc					jr nz, .mbounce 
0bfc			endif 
0bfc					; for ease use ex 
0bfc			 
0bfc					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bfc 21 b1 ed				ld hl, display_fb0 
0bff 22 cc eb				ld (display_fb_active), hl 
0c02			 
0c02 cd c5 0b		.mloop:		call clear_display 
0c05 cd e8 0b				call update_display 
0c08			 
0c08					; draw selection id '>' at 1 
0c08			 
0c08					; init start of list display 
0c08			 
0c08 3e 05				ld a, 5 
0c0a 32 6f ea				ld (store_tmp3), a   ; display row count 
0c0d 3a 71 ea				ld a,( store_tmp2) 
0c10 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c13			 
0c13					 
0c13			.mitem:	 
0c13			 
0c13			 
0c13 3a 72 ea				ld a,(store_tmp2+1) 
0c16 6f					ld l, a 
0c17 26 00				ld h, 0 
0c19 29					add hl, hl 
0c1a ed 5b 73 ea			ld de, (store_tmp1) 
0c1e 19					add hl, de 
0c1f 7e					ld a, (hl) 
0c20 23					inc hl 
0c21 66					ld h,(hl) 
0c22 6f					ld l, a 
0c23			 
0c23 cd 1b 0e				call ishlzero 
0c26 28 1a				jr z, .mdone 
0c28			 
0c28 eb					ex de, hl 
0c29 3a 6f ea				ld a, (store_tmp3) 
0c2c cd d8 0b				call str_at_display 
0c2f					 
0c2f			 
0c2f					; next item 
0c2f 3a 72 ea				ld a, (store_tmp2+1) 
0c32 3c					inc a 
0c33 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c36			 
0c36			 		; next row 
0c36			 
0c36 3a 6f ea				ld a, (store_tmp3) 
0c39 c6 28				add display_cols 
0c3b 32 6f ea				ld (store_tmp3), a 
0c3e			 
0c3e					; at end of screen? 
0c3e			 
0c3e fe 10				cp display_rows*4 
0c40 20 d1				jr nz, .mitem 
0c42			 
0c42			 
0c42			.mdone: 
0c42 cd 1b 0e				call ishlzero 
0c45 28 08				jr z, .nodn 
0c47			 
0c47 3e 78				ld a, display_row_4 
0c49 11 c8 0c				ld de, .mdown 
0c4c cd d8 0b				call str_at_display 
0c4f			 
0c4f					; draw options to fill the screens with active item on line 1 
0c4f					; if current option is 2 or more then display ^ in top 
0c4f			 
0c4f 3a 71 ea		.nodn:		ld a, (store_tmp2) 
0c52 fe 00				cp 0 
0c54 28 08				jr z, .noup 
0c56			 
0c56 3e 00				ld a, 0 
0c58 11 c6 0c				ld de, .mup 
0c5b cd d8 0b				call str_at_display 
0c5e			 
0c5e 3e 02		.noup:		ld a, 2 
0c60 11 c4 0c				ld de, .msel 
0c63 cd d8 0b				call str_at_display 
0c66			 
0c66					; if current option + 1 is not null then display V in bottom 
0c66					; get key 
0c66 cd e8 0b				call update_display 
0c69			 
0c69			 
0c69					; handle key 
0c69			 
0c69 cd 68 5e				call cin_wait 
0c6c			 
0c6c fe 05				cp KEY_UP 
0c6e 28 2b				jr z, .mgoup 
0c70 fe 61				cp 'a' 
0c72 28 27				jr z, .mgoup 
0c74 fe 0a				cp KEY_DOWN 
0c76 28 32				jr z, .mgod 
0c78 fe 7a				cp 'z' 
0c7a 28 2e				jr z, .mgod 
0c7c fe 20				cp ' ' 
0c7e 28 34				jr z, .goend 
0c80 fe 0c				cp KEY_RIGHT 
0c82 28 30				jr z, .goend 
0c84 fe 0d				cp KEY_CR 
0c86 28 2c				jr z, .goend 
0c88 fe 71				cp 'q' 
0c8a 28 0b				jr z, .goback 
0c8c			 
0c8c fe 0b				cp KEY_LEFT 
0c8e 28 07				jr z, .goback 
0c90 fe 08				cp KEY_BS 
0c92 28 03				jr z, .goback 
0c94 c3 02 0c				jp .mloop 
0c97			 
0c97			.goback: 
0c97 3e 00			ld a, 0 
0c99 18 1d			jr .goend2 
0c9b			 
0c9b				; move up one 
0c9b			.mgoup: 
0c9b 3a 71 ea				ld a, (store_tmp2) 
0c9e fe 00				cp 0 
0ca0 ca 02 0c				jp z, .mloop 
0ca3 3d					dec a 
0ca4 32 71 ea				ld (store_tmp2), a 
0ca7 c3 02 0c				jp .mloop 
0caa			 
0caa				; move down one 
0caa			.mgod: 
0caa 3a 71 ea				ld a, (store_tmp2) 
0cad 3c					inc a 
0cae 32 71 ea				ld (store_tmp2), a 
0cb1 c3 02 0c				jp .mloop 
0cb4			 
0cb4			 
0cb4			.goend: 
0cb4					; get selected item number 
0cb4			 
0cb4 3a 71 ea				ld a, (store_tmp2) 
0cb7 3c					inc a 
0cb8			 
0cb8			.goend2: 
0cb8 f5					push af 
0cb9			 
0cb9					; restore active fb 
0cb9					; TODO BUG assumes fb1 
0cb9			 
0cb9 21 10 ed				ld hl, display_fb1 
0cbc 22 cc eb				ld (display_fb_active), hl 
0cbf			 
0cbf					; restore main regs 
0cbf			 
0cbf			 
0cbf cd e8 0b				call update_display 
0cc2			 
0cc2 f1					pop af 
0cc3			 
0cc3 c9				ret 
0cc4			 
0cc4 .. 00		.msel:   db ">",0 
0cc6 .. 00		.mup:   db "^",0 
0cc8 .. 00		.mdown:   db "v",0 
0cca			 
0cca			 
0cca			; eof 
0cca			 
# End of file firmware_display.asm
0cca			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cca			; random number generators 
0cca			 
0cca			 
0cca			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cca			 
0cca			 
0cca			;-----> Generate a random number 
0cca			; output a=answer 0<=a<=255 
0cca			; all registers are preserved except: af 
0cca			random: 
0cca e5			        push    hl 
0ccb d5			        push    de 
0ccc 2a ab eb		        ld      hl,(randData) 
0ccf ed 5f		        ld      a,r 
0cd1 57			        ld      d,a 
0cd2 5e			        ld      e,(hl) 
0cd3 19			        add     hl,de 
0cd4 85			        add     a,l 
0cd5 ac			        xor     h 
0cd6 22 ab eb		        ld      (randData),hl 
0cd9 d1			        pop     de 
0cda e1			        pop     hl 
0cdb c9			        ret 
0cdc			 
0cdc			 
0cdc			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cdc			 
0cdc			 
0cdc			 
0cdc			;------LFSR------ 
0cdc			;James Montelongo 
0cdc			;optimized by Spencer Putt 
0cdc			;out: 
0cdc			; a = 8 bit random number 
0cdc			RandLFSR: 
0cdc 21 b1 eb		        ld hl,LFSRSeed+4 
0cdf 5e			        ld e,(hl) 
0ce0 23			        inc hl 
0ce1 56			        ld d,(hl) 
0ce2 23			        inc hl 
0ce3 4e			        ld c,(hl) 
0ce4 23			        inc hl 
0ce5 7e			        ld a,(hl) 
0ce6 47			        ld b,a 
0ce7 cb 13		        rl e  
0ce9 cb 12			rl d 
0ceb cb 11		        rl c  
0ced 17				rla 
0cee cb 13		        rl e  
0cf0 cb 12			rl d 
0cf2 cb 11		        rl c  
0cf4 17				rla 
0cf5 cb 13		        rl e  
0cf7 cb 12			rl d 
0cf9 cb 11		        rl c  
0cfb 17				rla 
0cfc 67			        ld h,a 
0cfd cb 13		        rl e  
0cff cb 12			rl d 
0d01 cb 11		        rl c  
0d03 17				rla 
0d04 a8			        xor b 
0d05 cb 13		        rl e  
0d07 cb 12			rl d 
0d09 ac			        xor h 
0d0a a9			        xor c 
0d0b aa			        xor d 
0d0c 21 b3 eb		        ld hl,LFSRSeed+6 
0d0f 11 b4 eb		        ld de,LFSRSeed+7 
0d12 01 07 00		        ld bc,7 
0d15 ed b8		        lddr 
0d17 12			        ld (de),a 
0d18 c9			        ret 
0d19			 
0d19			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d19			 
0d19			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d19			 
0d19			 
0d19			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d19			 
0d19			prng16: 
0d19			;Inputs: 
0d19			;   (seed1) contains a 16-bit seed value 
0d19			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d19			;Outputs: 
0d19			;   HL is the result 
0d19			;   BC is the result of the LCG, so not that great of quality 
0d19			;   DE is preserved 
0d19			;Destroys: 
0d19			;   AF 
0d19			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d19			;160cc 
0d19			;26 bytes 
0d19 2a a5 eb		    ld hl,(seed1) 
0d1c 44			    ld b,h 
0d1d 4d			    ld c,l 
0d1e 29			    add hl,hl 
0d1f 29			    add hl,hl 
0d20 2c			    inc l 
0d21 09			    add hl,bc 
0d22 22 a5 eb		    ld (seed1),hl 
0d25 2a a3 eb		    ld hl,(seed2) 
0d28 29			    add hl,hl 
0d29 9f			    sbc a,a 
0d2a e6 2d		    and %00101101 
0d2c ad			    xor l 
0d2d 6f			    ld l,a 
0d2e 22 a3 eb		    ld (seed2),hl 
0d31 09			    add hl,bc 
0d32 c9			    ret 
0d33			 
0d33			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d33			 
0d33			rand32: 
0d33			;Inputs: 
0d33			;   (seed1_0) holds the lower 16 bits of the first seed 
0d33			;   (seed1_1) holds the upper 16 bits of the first seed 
0d33			;   (seed2_0) holds the lower 16 bits of the second seed 
0d33			;   (seed2_1) holds the upper 16 bits of the second seed 
0d33			;   **NOTE: seed2 must be non-zero 
0d33			;Outputs: 
0d33			;   HL is the result 
0d33			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d33			;Destroys: 
0d33			;   AF 
0d33			;Tested and passes all CAcert tests 
0d33			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d33			;it has a period of 18,446,744,069,414,584,320 
0d33			;roughly 18.4 quintillion. 
0d33			;LFSR taps: 0,2,6,7  = 11000101 
0d33			;291cc 
0d33			;seed1_0=$+1 
0d33			;    ld hl,12345 
0d33			;seed1_1=$+1 
0d33			;    ld de,6789 
0d33			;    ld b,h 
0d33			;    ld c,l 
0d33			;    add hl,hl \ rl e \ rl d 
0d33			;    add hl,hl \ rl e \ rl d 
0d33			;    inc l 
0d33			;    add hl,bc 
0d33			;    ld (seed1_0),hl 
0d33			;    ld hl,(seed1_1) 
0d33			;    adc hl,de 
0d33			;    ld (seed1_1),hl 
0d33			;    ex de,hl 
0d33			;seed2_0=$+1 
0d33			;    ld hl,9876 
0d33			;seed2_1=$+1 
0d33			;    ld bc,54321 
0d33			;    add hl,hl \ rl c \ rl b 
0d33			;    ld (seed2_1),bc 
0d33			;    sbc a,a 
0d33			;    and %11000101 
0d33			;    xor l 
0d33			;    ld l,a 
0d33			;    ld (seed2_0),hl 
0d33			;    ex de,hl 
0d33			;    add hl,bc 
0d33			;    ret 
0d33			; 
0d33			 
0d33			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d33			; 20 bytes, 86 cycles (excluding ret) 
0d33			 
0d33			; returns   hl = pseudorandom number 
0d33			; corrupts   a 
0d33			 
0d33			; generates 16-bit pseudorandom numbers with a period of 65535 
0d33			; using the xorshift method: 
0d33			 
0d33			; hl ^= hl << 7 
0d33			; hl ^= hl >> 9 
0d33			; hl ^= hl << 8 
0d33			 
0d33			; some alternative shift triplets which also perform well are: 
0d33			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d33			 
0d33			;  org 32768 
0d33			 
0d33			xrnd: 
0d33 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
0d36 3e 00		  ld a,0 
0d38 bd			  cp l 
0d39 20 02		  jr nz, .xrnd1 
0d3b 2e 01		  ld l, 1 
0d3d			.xrnd1: 
0d3d			 
0d3d 7c			  ld a,h 
0d3e 1f			  rra 
0d3f 7d			  ld a,l 
0d40 1f			  rra 
0d41 ac			  xor h 
0d42 67			  ld h,a 
0d43 7d			  ld a,l 
0d44 1f			  rra 
0d45 7c			  ld a,h 
0d46 1f			  rra 
0d47 ad			  xor l 
0d48 6f			  ld l,a 
0d49 ac			  xor h 
0d4a 67			  ld h,a 
0d4b			 
0d4b 22 a9 eb		  ld (xrandc),hl 
0d4e			 
0d4e c9			  ret 
0d4f			;  
0d4f			 
0d4f			 
0d4f			;;;; int maths 
0d4f			 
0d4f			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d4f			; Divide 16-bit values (with 16-bit result) 
0d4f			; In: Divide BC by divider DE 
0d4f			; Out: BC = result, HL = rest 
0d4f			; 
0d4f			Div16: 
0d4f 21 00 00		    ld hl,0 
0d52 78			    ld a,b 
0d53 06 08		    ld b,8 
0d55			Div16_Loop1: 
0d55 17			    rla 
0d56 ed 6a		    adc hl,hl 
0d58 ed 52		    sbc hl,de 
0d5a 30 01		    jr nc,Div16_NoAdd1 
0d5c 19			    add hl,de 
0d5d			Div16_NoAdd1: 
0d5d 10 f6		    djnz Div16_Loop1 
0d5f 17			    rla 
0d60 2f			    cpl 
0d61 47			    ld b,a 
0d62 79			    ld a,c 
0d63 48			    ld c,b 
0d64 06 08		    ld b,8 
0d66			Div16_Loop2: 
0d66 17			    rla 
0d67 ed 6a		    adc hl,hl 
0d69 ed 52		    sbc hl,de 
0d6b 30 01		    jr nc,Div16_NoAdd2 
0d6d 19			    add hl,de 
0d6e			Div16_NoAdd2: 
0d6e 10 f6		    djnz Div16_Loop2 
0d70 17			    rla 
0d71 2f			    cpl 
0d72 41			    ld b,c 
0d73 4f			    ld c,a 
0d74 c9			ret 
0d75			 
0d75			 
0d75			;http://z80-heaven.wikidot.com/math 
0d75			; 
0d75			;Inputs: 
0d75			;     DE and A are factors 
0d75			;Outputs: 
0d75			;     A is not changed 
0d75			;     B is 0 
0d75			;     C is not changed 
0d75			;     DE is not changed 
0d75			;     HL is the product 
0d75			;Time: 
0d75			;     342+6x 
0d75			; 
0d75			Mult16: 
0d75			 
0d75 06 08		     ld b,8          ;7           7 
0d77 21 00 00		     ld hl,0         ;10         10 
0d7a 29			       add hl,hl     ;11*8       88 
0d7b 07			       rlca          ;4*8        32 
0d7c 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d7e 19			         add hl,de   ;--         -- 
0d7f 10 f9		       djnz $-5      ;13*7+8     99 
0d81 c9			ret 
0d82			 
0d82			; 
0d82			; Square root of 16-bit value 
0d82			; In:  HL = value 
0d82			; Out:  D = result (rounded down) 
0d82			; 
0d82			;Sqr16: 
0d82			;    ld de,#0040 
0d82			;    ld a,l 
0d82			;    ld l,h 
0d82			;    ld h,d 
0d82			;    or a 
0d82			;    ld b,8 
0d82			;Sqr16_Loop: 
0d82			;    sbc hl,de 
0d82			;    jr nc,Sqr16_Skip 
0d82			;    add hl,de 
0d82			;Sqr16_Skip: 
0d82			;    ccf 
0d82			;    rl d 
0d82			;    add a,a 
0d82			;    adc hl,hl 
0d82			;    add a,a 
0d82			;    adc hl,hl 
0d82			;    djnz Sqr16_Loop 
0d82			;    ret 
0d82			; 
0d82			; 
0d82			; Divide 8-bit values 
0d82			; In: Divide E by divider C 
0d82			; Out: A = result, B = rest 
0d82			; 
0d82			Div8: 
0d82 af			    xor a 
0d83 06 08		    ld b,8 
0d85			Div8_Loop: 
0d85 cb 13		    rl e 
0d87 17			    rla 
0d88 91			    sub c 
0d89 30 01		    jr nc,Div8_NoAdd 
0d8b 81			    add a,c 
0d8c			Div8_NoAdd: 
0d8c 10 f7		    djnz Div8_Loop 
0d8e 47			    ld b,a 
0d8f 7b			    ld a,e 
0d90 17			    rla 
0d91 2f			    cpl 
0d92 c9			    ret 
0d93			 
0d93			; 
0d93			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d93			; In: Multiply A with DE 
0d93			; Out: HL = result 
0d93			; 
0d93			Mult12U: 
0d93 2e 00		    ld l,0 
0d95 87			    add a,a 
0d96 30 01		    jr nc,Mult12U_NoAdd0 
0d98 19			    add hl,de 
0d99			Mult12U_NoAdd0: 
0d99 29			    add hl,hl 
0d9a 87			    add a,a 
0d9b 30 01		    jr nc,Mult12U_NoAdd1 
0d9d 19			    add hl,de 
0d9e			Mult12U_NoAdd1: 
0d9e 29			    add hl,hl 
0d9f 87			    add a,a 
0da0 30 01		    jr nc,Mult12U_NoAdd2 
0da2 19			    add hl,de 
0da3			Mult12U_NoAdd2: 
0da3 29			    add hl,hl 
0da4 87			    add a,a 
0da5 30 01		    jr nc,Mult12U_NoAdd3 
0da7 19			    add hl,de 
0da8			Mult12U_NoAdd3: 
0da8 29			    add hl,hl 
0da9 87			    add a,a 
0daa 30 01		    jr nc,Mult12U_NoAdd4 
0dac 19			    add hl,de 
0dad			Mult12U_NoAdd4: 
0dad 29			    add hl,hl 
0dae 87			    add a,a 
0daf 30 01		    jr nc,Mult12U_NoAdd5 
0db1 19			    add hl,de 
0db2			Mult12U_NoAdd5: 
0db2 29			    add hl,hl 
0db3 87			    add a,a 
0db4 30 01		    jr nc,Mult12U_NoAdd6 
0db6 19			    add hl,de 
0db7			Mult12U_NoAdd6: 
0db7 29			    add hl,hl 
0db8 87			    add a,a 
0db9 d0			    ret nc 
0dba 19			    add hl,de 
0dbb c9			    ret 
0dbc			 
0dbc			; 
0dbc			; Multiply 8-bit value with a 16-bit value (right rotating) 
0dbc			; In: Multiply A with DE 
0dbc			;      Put lowest value in A for most efficient calculation 
0dbc			; Out: HL = result 
0dbc			; 
0dbc			Mult12R: 
0dbc 21 00 00		    ld hl,0 
0dbf			Mult12R_Loop: 
0dbf cb 3f		    srl a 
0dc1 30 01		    jr nc,Mult12R_NoAdd 
0dc3 19			    add hl,de 
0dc4			Mult12R_NoAdd: 
0dc4 cb 23		    sla e 
0dc6 cb 12		    rl d 
0dc8 b7			    or a 
0dc9 c2 bf 0d		    jp nz,Mult12R_Loop 
0dcc c9			    ret 
0dcd			 
0dcd			; 
0dcd			; Multiply 16-bit values (with 32-bit result) 
0dcd			; In: Multiply BC with DE 
0dcd			; Out: BCHL = result 
0dcd			; 
0dcd			Mult32: 
0dcd 79			    ld a,c 
0dce 48			    ld c,b 
0dcf 21 00 00		    ld hl,0 
0dd2 06 10		    ld b,16 
0dd4			Mult32_Loop: 
0dd4 29			    add hl,hl 
0dd5 17			    rla 
0dd6 cb 11		    rl c 
0dd8 30 07		    jr nc,Mult32_NoAdd 
0dda 19			    add hl,de 
0ddb ce 00		    adc a,0 
0ddd d2 e1 0d		    jp nc,Mult32_NoAdd 
0de0 0c			    inc c 
0de1			Mult32_NoAdd: 
0de1 10 f1		    djnz Mult32_Loop 
0de3 41			    ld b,c 
0de4 4f			    ld c,a 
0de5 c9			    ret 
0de6			 
0de6			 
0de6			 
0de6			; 
0de6			; Multiply 8-bit values 
0de6			; In:  Multiply H with E 
0de6			; Out: HL = result 
0de6			; 
0de6			Mult8: 
0de6 16 00		    ld d,0 
0de8 6a			    ld l,d 
0de9 06 08		    ld b,8 
0deb			Mult8_Loop: 
0deb 29			    add hl,hl 
0dec 30 01		    jr nc,Mult8_NoAdd 
0dee 19			    add hl,de 
0def			Mult8_NoAdd: 
0def 10 fa		    djnz Mult8_Loop 
0df1 c9			    ret 
0df2			 
0df2			 
0df2			 
0df2			 
0df2			 
0df2			 
0df2			 
0df2			 
0df2			;;http://z80-heaven.wikidot.com/math 
0df2			;;This divides DE by BC, storing the result in DE, remainder in HL 
0df2			; 
0df2			;DE_Div_BC:          ;1281-2x, x is at most 16 
0df2			;     ld a,16        ;7 
0df2			;     ld hl,0        ;10 
0df2			;     jp $+5         ;10 
0df2			;.DivLoop: 
0df2			;       add hl,bc    ;-- 
0df2			;       dec a        ;64 
0df2			;       jr z,.DivLoopEnd        ;86 
0df2			; 
0df2			;       sla e        ;128 
0df2			;       rl d         ;128 
0df2			;       adc hl,hl    ;240 
0df2			;       sbc hl,bc    ;240 
0df2			;       jr nc,.DivLoop ;23|21 
0df2			;       inc e        ;-- 
0df2			;       jp .DivLoop+1 
0df2			; 
0df2			;.DivLoopEnd: 
0df2			 
0df2			;HL_Div_C: 
0df2			;Inputs: 
0df2			;     HL is the numerator 
0df2			;     C is the denominator 
0df2			;Outputs: 
0df2			;     A is the remainder 
0df2			;     B is 0 
0df2			;     C is not changed 
0df2			;     DE is not changed 
0df2			;     HL is the quotient 
0df2			; 
0df2			;       ld b,16 
0df2			;       xor a 
0df2			;         add hl,hl 
0df2			;         rla 
0df2			;         cp c 
0df2			;         jr c,$+4 
0df2			;           inc l 
0df2			;           sub c 
0df2			;         djnz $-7 
0df2			 
0df2			; https://plutiedev.com/z80-add-8bit-to-16bit 
0df2			 
0df2			addatohl: 
0df2 85			    add   a, l    ; A = A+L 
0df3 6f			    ld    l, a    ; L = A+L 
0df4 8c			    adc   a, h    ; A = A+L+H+carry 
0df5 95			    sub   l       ; A = H+carry 
0df6 67			    ld    h, a    ; H = H+carry 
0df7 c9			ret 
0df8			 
0df8			addatode: 
0df8 83			    add   a, e    ; A = A+L 
0df9 5f			    ld    e, a    ; L = A+L 
0dfa 8a			    adc   a, d    ; A = A+L+H+carry 
0dfb 93			    sub   e       ; A = H+carry 
0dfc 57			    ld    d, a    ; H = H+carry 
0dfd c9			ret 
0dfe			 
0dfe			 
0dfe			addatobc: 
0dfe 81			    add   a, c    ; A = A+L 
0dff 4f			    ld    c, a    ; L = A+L 
0e00 88			    adc   a, b    ; A = A+L+H+carry 
0e01 91			    sub   c       ; A = H+carry 
0e02 47			    ld    b, a    ; H = H+carry 
0e03 c9			ret 
0e04			 
0e04			subafromhl: 
0e04			   ; If A=0 do nothing 
0e04			    ; Otherwise flip A's sign. Since 
0e04			    ; the upper byte becomes -1, also 
0e04			    ; substract 1 from H. 
0e04 ed 44		    neg 
0e06 ca 0f 0e		    jp    z, Skip 
0e09 25			    dec   h 
0e0a			     
0e0a			    ; Now add the low byte as usual 
0e0a			    ; Two's complement takes care of 
0e0a			    ; ensuring the result is correct 
0e0a 85			    add   a, l 
0e0b 6f			    ld    l, a 
0e0c 8c			    adc   a, h 
0e0d 95			    sub   l 
0e0e 67			    ld    h, a 
0e0f			Skip: 
0e0f c9				ret 
0e10			 
0e10			 
0e10			; compare hl and de 
0e10			; returns:  
0e10			; if hl = de, z=1, s=0, c0=0 
0e10			; if hl > de, z=0, s=0, c=0 
0e10			; if hl < de, z=0, s=1, c=1 
0e10			cmp16:	 
0e10 b7				or a 
0e11 ed 52			sbc hl,de 
0e13 e0				ret po 
0e14 7c				ld a,h 
0e15 1f				rra 
0e16 ee 40			xor 01000000B 
0e18 37				scf 
0e19 8f				adc a,a 
0e1a c9				ret 
0e1b			 
0e1b			 
0e1b			; test if hl contains zero   - A is destroyed 
0e1b			 
0e1b			ishlzero:    
0e1b b7				or a     ; reset flags 
0e1c 7c				ld a, h 
0e1d b5				or l        	 
0e1e			 
0e1e c9				ret 
0e1f			 
0e1f			 
0e1f			 
0e1f			 
0e1f			if FORTH_ENABLE_FLOATMATH 
0e1f			;include "float/bbcmath.z80" 
0e1f			include "float/lpfpcalc.asm" 
0e1f			endif 
0e1f			 
0e1f			 
0e1f			; eof 
0e1f			 
# End of file firmware_maths.asm
0e1f			include "firmware_strings.asm"   ; string handling  
0e1f			 
0e1f			 
0e1f			; TODO string len 
0e1f			; input text string, end on cr with zero term 
0e1f			; a offset into frame buffer to start prompt 
0e1f			; d is max length 
0e1f			; e is display size TODO 
0e1f			; c is current cursor position 
0e1f			; hl is ptr to where string will be stored and edited directly 
0e1f			 
0e1f			 
0e1f			; TODO check limit of buffer for new inserts 
0e1f			; TODO check insert does not push beyond buffer 
0e1f			; TODO scroll in a limited display area 
0e1f			; TODO scroll whole screen on page wrap 
0e1f			 
0e1f			 
0e1f			; TODO use LCD cursor? 
0e1f			 
0e1f			EDIT_V1: equ 0 
0e1f			EDIT_V2: equ 1 
0e1f			 
0e1f			 
0e1f			 
0e1f			if EDIT_V2 
0e1f			input_str: 
0e1f			 
0e1f 32 64 ee			    	ld (input_at_pos),a      ; save display position to start 
0e22			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0e22 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
0e25			;		ld a, c 
0e25			;		call addatohl 
0e25			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
0e25 7a					ld a,d 
0e26 32 66 ee			        ld (input_size), a       ; save length of input area 
0e29 79					ld a, c 
0e2a 32 55 ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
0e2d 7b					ld a,e 
0e2e 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e31			 
0e31			 
0e31					; add a trailing space to make screen refresh nicer 
0e31			 
0e31					;ld hl, (input_start) 
0e31					;push hl 
0e31					;ld a, 0 
0e31					;call strlent 
0e31					;ld a, l 
0e31					;pop hl 
0e31					;call addatohl 
0e31					;dec hl 
0e31					;ld a, ' ' 
0e31					;ld (hl), a 
0e31					;inc hl 
0e31					;ld (hl), a 
0e31					;inc hl 
0e31					;ld a, 0 
0e31					;ld (hl), a 
0e31			 
0e31			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e31					; init cursor shape if not set by the cin routines 
0e31 21 c1 eb				ld hl, cursor_shape 
0e34			if BASE_KEV 
0e34					ld a, 255 
0e34			else 
0e34 3e 23				ld a, '#' 
0e36			endif 
0e36 77					ld (hl), a 
0e37 23					inc hl 
0e38 3e 00				ld a, 0 
0e3a 77					ld (hl), a 
0e3b			 
0e3b 3e 09				ld a, CUR_BLINK_RATE 
0e3d 32 60 ee				ld (input_cur_flash), a 
0e40 3e 01				ld a, 1 
0e42 32 5f ee				ld (input_cur_onoff),a 
0e45			.inmain:	 
0e45			 
0e45 cd 6d 0f				call input_disp_ref 
0e48			 
0e48					; save current length of string 
0e48			 
0e48 2a 67 ee				ld hl, (input_start) 
0e4b 3e 00				ld a, 0 
0e4d cd 63 11				call strlent 
0e50 7d					ld a,l 
0e51 32 5a ee				ld (input_len), a 
0e54			 
0e54					;call input_disp_oncur 
0e54			 
0e54					; display current state of input buffer 
0e54			 
0e54					; clean any backspace chars 
0e54			 
0e54 3e 20				ld a, " " 
0e56 32 c1 e2				ld (scratch),a 
0e59 3e 00				ld a, 0 
0e5b 32 c2 e2				ld (scratch+1),a 
0e5e 3a 64 ee				ld a,(input_at_pos) 
0e61 85					add l 
0e62 11 c1 e2				ld de, scratch 
0e65 cd d8 0b				call str_at_display 
0e68			 
0e68					; pause 1ms 
0e68			 
0e68 3e 01				ld a, 1 
0e6a cd e2 0a				call aDelayInMS 
0e6d			 
0e6d			; display cursor if visible on this cycle 
0e6d			 
0e6d					; dec flash counter 
0e6d 3a 60 ee				ld a, (input_cur_flash) 
0e70 3d					dec a 
0e71 32 60 ee				ld (input_cur_flash), a 
0e74 fe 00				cp 0 
0e76 20 0d				jr nz, .inochgstate 
0e78			 
0e78			 
0e78					; reset on change of state 
0e78 3e 09				ld a, CUR_BLINK_RATE 
0e7a 32 60 ee				ld (input_cur_flash), a 
0e7d			 
0e7d					; change state 
0e7d 3a 5f ee				ld a,(input_cur_onoff) 
0e80 ed 44				neg 
0e82 32 5f ee				ld (input_cur_onoff),a 
0e85			 
0e85			 
0e85			 
0e85			 
0e85					; TODO is cursor visible? 
0e85					; TODO if so then over write the char at curspos pos with the cursor shape 
0e85			 
0e85								 
0e85			 
0e85			.inochgstate: 
0e85 3a 5f ee				ld a,(input_cur_onoff) 
0e88 fe ff				cp 255 
0e8a 28 0e				jr z, .skipcursor 
0e8c 3a 64 ee				ld a, (input_at_pos) 
0e8f 47					ld b, a 
0e90 3a 55 ee				ld a, (input_cursor) 
0e93 80					add b 
0e94 11 c1 eb				ld de, cursor_shape 
0e97					 
0e97 cd d8 0b				call str_at_display 
0e9a			 
0e9a			.skipcursor: 
0e9a				if DEBUG_INPUTV2 
0e9a			 
0e9a					ld a,(input_at_pos) 
0e9a					ld hl, LFSRSeed 
0e9a					call hexout 
0e9a					ld a, (input_cursor) 
0e9a					ld hl, LFSRSeed+2 
0e9a					call hexout 
0e9a					ld a,(input_size) 
0e9a					ld hl, LFSRSeed+4 
0e9a					call hexout 
0e9a			 
0e9a					ld a,(input_cur_onoff) 
0e9a					ld hl, LFSRSeed+6 
0e9a					call hexout 
0e9a			 
0e9a					ld a,(input_cur_flash) 
0e9a					ld hl, LFSRSeed+8 
0e9a					call hexout 
0e9a			 
0e9a					ld a,(input_len) 
0e9a					ld hl, LFSRSeed+10 
0e9a					call hexout 
0e9a					ld hl, LFSRSeed+12 
0e9a					ld a, 0 
0e9a					ld (hl),a 
0e9a					ld a, display_row_4 
0e9a					ld de, LFSRSeed 
0e9a					call str_at_display 
0e9a				endif 
0e9a cd e8 0b				call update_display 
0e9d			 
0e9d					; TODO keyboard processing 
0e9d			 
0e9d			if BASE_CPM 
0e9d cd 68 5e				call cin_wait 
0ea0			else 
0ea0					call cin    ; _wait 
0ea0			endif 
0ea0 fe 00				cp 0 
0ea2 ca 45 0e				jp z, .inmain 
0ea5			 
0ea5 fe 0b				cp KEY_LEFT    ; cursor left 
0ea7 ca 5f 0f				jp z, input_left 
0eaa				 
0eaa fe 0c				cp KEY_RIGHT      ; cursor right 
0eac ca 66 0f				jp z, input_right 
0eaf			 
0eaf fe 0d				cp KEY_CR 
0eb1 c8					ret z 
0eb2			 
0eb2 fe 08				cp KEY_BS 
0eb4 ca d4 0f				jp z, input_delchar 
0eb7			 
0eb7 fe 06				cp KEY_NEXTWORD 
0eb9 ca e0 0e				jp z, input_nxtword 
0ebc			 
0ebc fe 07				cp KEY_PREVWORD 
0ebe ca 07 0f				jp z, input_prvword 
0ec1			 
0ec1 fe 0e				cp KEY_HOME    ; jump to start of line 
0ec3 20 08				jr nz, .ikh 
0ec5 3e 00				ld a, 0 
0ec7 32 55 ee				ld (input_cursor), a 
0eca ca 45 0e				jp z, .inmain 
0ecd			.ikh: 
0ecd			 
0ecd fe 0f				cp KEY_END     ; jump to end of line 
0ecf 20 09				jr nz, .ike 
0ed1 3a 5a ee				ld a, (input_len) 
0ed4 32 55 ee				ld (input_cursor),a 
0ed7 ca 45 0e				jp z, .inmain 
0eda			.ike: 
0eda fe 05			        cp KEY_UP      ; recall last command 
0edc c8					ret z 
0edd			;jr nz, .irec 
0edd			; TODO next word 
0edd			; TODO prev word 
0edd			;  
0edd			; 
0edd			;	ld hl, scratch 
0edd			;	ld de, os_last_cmd 
0edd			;	call strcpy 
0edd			;		jp  .inmain 
0edd			.irec: 
0edd			;		jr .instr1 
0edd			 
0edd			 
0edd			 
0edd					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
0edd			 
0edd			; TODO return if any special keys are given 
0edd			;		ld l, a 
0edd			;		ld a, 28 ; KEY_F12   ; 27 
0edd			;		sub l 
0edd			;		ret m 
0edd			;		ld a, l 
0edd					; if no special key then insert as a char 
0edd			 
0edd c3 a6 0f				jp input_inschr 
0ee0			 
0ee0				 
0ee0			input_nxtword: 
0ee0				; jump to start next word after the cursor 
0ee0			 
0ee0			.insknwn:	 
0ee0 cd 9c 0f				call input_curptr	 
0ee3 7e					ld a,(hl)	 
0ee4 fe 00				cp 0 
0ee6 ca 45 0e				jp z, .inmain    ; end of string 
0ee9			 
0ee9			; if we are on a word, then move off of it 
0ee9			 
0ee9 fe 20				cp ' ' 
0eeb 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
0eed 21 55 ee				ld hl, input_cursor 
0ef0 34					inc (hl) 
0ef1 18 ed				jr .insknwn 
0ef3			 
0ef3			.inspace: 
0ef3			 
0ef3 cd 9c 0f				call input_curptr	 
0ef6 7e					ld a,(hl)	 
0ef7 fe 00				cp 0 
0ef9 ca 45 0e				jp z, .inmain    ; end of string 
0efc			 
0efc			; if we are on a word, then move off of it 
0efc			 
0efc fe 20				cp ' ' 
0efe c2 45 0e				jp nz, .inmain     ; we are on non space so at next word 
0f01 21 55 ee				ld hl, input_cursor 
0f04 34					inc (hl) 
0f05 18 ec				jr .inspace 
0f07			 
0f07			 
0f07			 
0f07			 
0f07			input_prvword: 
0f07				; jump to the start of previous word before the cursor 
0f07			 
0f07			; where are we to start with currently? 
0f07			 
0f07 cd 9c 0f				call input_curptr	 
0f0a 7e					ld a, (hl) 
0f0b fe 20				cp ' ' 
0f0d 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
0f0f			 
0f0f			 
0f0f			 
0f0f			.inskpwn:	 
0f0f 3a 55 ee				ld a,(input_cursor) 
0f12 fe 00				cp 0 
0f14 ca 45 0e				jp z, .inmain    ; start of string 
0f17			 
0f17			;if we are on a word, then move off of it 
0f17			 
0f17 cd 9c 0f				call input_curptr	 
0f1a 7e					ld a, (hl) 
0f1b fe 20				cp ' ' 
0f1d 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
0f1f					;jp z, .inmain    ; start of string 
0f1f 21 55 ee				ld hl, input_cursor 
0f22 35					dec (hl) 
0f23 18 ea				jr .inskpwn 
0f25			.iwstart: 
0f25 21 55 ee				ld hl, input_cursor 
0f28 34					inc (hl) 
0f29 c3 45 0e				jp .inmain 
0f2c					 
0f2c			 
0f2c			.inspacep: 
0f2c			 
0f2c					;jp .inmain    ; start of string 
0f2c			 
0f2c			 
0f2c			 
0f2c 3a 55 ee				ld a,(input_cursor) 
0f2f fe 00				cp 0 
0f31 ca 45 0e				jp z, .inmain    ; start of string 
0f34			 
0f34			; if we are on a word, then move off of it 
0f34			 
0f34 cd 9c 0f				call input_curptr	 
0f37 7e					ld a, (hl) 
0f38 fe 20				cp ' ' 
0f3a c2 43 0f				jp nz, .incharp     ; we are on non space so at end of prev word 
0f3d 21 55 ee				ld hl, input_cursor 
0f40 35					dec (hl) 
0f41 18 e9				jr .inspacep 
0f43			 
0f43			 
0f43			.incharp:	 
0f43					; eat the word to get to the start 
0f43 3a 55 ee				ld a,(input_cursor) 
0f46 fe 00				cp 0 
0f48 ca 45 0e				jp z, .inmain    ; start of string 
0f4b			 
0f4b			; if we are on a word, then move off of it 
0f4b			 
0f4b cd 9c 0f				call input_curptr	 
0f4e 7e					ld a, (hl) 
0f4f fe 20				cp ' ' 
0f51 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
0f53 21 55 ee				ld hl, input_cursor 
0f56 35					dec (hl) 
0f57 18 ea				jr .incharp 
0f59			.ipwordst: 
0f59					; at space before the prev word so reposition over it 
0f59 21 55 ee				ld hl, input_cursor 
0f5c 34					inc (hl) 
0f5d 18 b0				jr .inskpwn 
0f5f					 
0f5f			 
0f5f			 
0f5f			input_left: 
0f5f				; move cursor left 
0f5f 21 55 ee			ld hl, input_cursor 
0f62 35				dec (hl) 
0f63			;	cp 0 
0f63			;	jp z, .inmain    ; ignore left as at the start of the string 
0f63 c3 45 0e			jp .inmain 
0f66			 
0f66			input_right: 
0f66				; move cursor right 
0f66				 
0f66				;ld a, (input_size) 
0f66				;ld b, a 
0f66 21 55 ee			ld hl, input_cursor 
0f69 34				inc (hl) 
0f6a				;dec b 
0f6a				;cp 0 
0f6a				;jp z, .inmain   ; ignore as at end of the string buffer 
0f6a				;ld a, b 
0f6a				;inc a 
0f6a				;ld (input_cursor), a 
0f6a c3 45 0e			jp .inmain 
0f6d			 
0f6d			 
0f6d			 
0f6d			input_disp_ref: 
0f6d				; display the text from start of buffer (ie full refresh) 
0f6d 3a 64 ee			ld a, (input_at_pos) 
0f70 2a 67 ee			ld hl,(input_start) 
0f73 eb				ex de, hl 
0f74 cd d8 0b			call str_at_display  
0f77 c9				ret 
0f78			input_disp_oncur: 
0f78				; display the text from cursor position to end of buffer 
0f78				; TODO position start of string at cursor position on screen 
0f78				; TODO draw from that point on 
0f78 3a 55 ee			ld a, (input_cursor) 
0f7b 47				ld b, a 
0f7c 3a 64 ee			ld a, (input_at_pos) 
0f7f 80				add b 
0f80 48				ld c, b     ; save a 
0f81 78				ld a, b     ; inc string start for cursor 
0f82 2a 67 ee			ld hl,(input_start) 
0f85 cd f2 0d			call addatohl 
0f88 eb				ex de, hl 
0f89 79				ld a, c 
0f8a cd d8 0b			call str_at_display  
0f8d c9				ret 
0f8e			 
0f8e			input_nxtw: 
0f8e				; Find next word 
0f8e c9				ret 
0f8f			 
0f8f			input_prvw: 
0f8f				; Find previous word 
0f8f c9				ret 
0f90			 
0f90			input_lenrem:   
0f90				; Calculate the length of string remaining from current cursor 
0f90				; position to end of buffer (exc null term) 
0f90				 
0f90 3a 55 ee			ld a, (input_cursor) 
0f93 4f				ld c, a 
0f94 3a 66 ee			ld a, (input_size) 
0f97 91				sub c 
0f98 06 00			ld b, 0 
0f9a 0d				dec c 
0f9b c9				ret	 
0f9c			 
0f9c			input_curptr: 
0f9c				; calc address of the character under the cursor 
0f9c				 
0f9c 2a 67 ee			ld hl, (input_start) 
0f9f 3a 55 ee			ld a, (input_cursor) 
0fa2 cd f2 0d			call addatohl 
0fa5 c9				ret 
0fa6			 
0fa6			input_inschr: 
0fa6				; Insert char at cursor position 
0fa6 f5				push af   ; save char 
0fa7				;call input_lenrem    ; get bc length of remaining string 
0fa7			 
0fa7				 
0fa7 cd 9c 0f			call input_curptr 
0faa			;	ld hl, (input_start) 
0faa			;	ld a, (input_cursor) 
0faa			;	call addatohl 
0faa				;push hl   ; save to come back to 
0faa			 
0faa				; shift everything up one to end of buffer 
0faa			 
0faa				;push hl 
0faa				;dec de 
0faa				;inc de 
0faa			;	ldir 
0faa				 
0faa				;pop hl 
0faa			 
0faa				; are we adding to the end of line? 
0faa			 
0faa 3a 55 ee			ld a, (input_cursor) 
0fad 47				ld b, a 
0fae 3a 5a ee			ld a, (input_len) 
0fb1 b8				cp b 
0fb2 20 09			jr nz, .insmid   ; no, insert in middle of text 
0fb4			 
0fb4				; tack on the end of the line 
0fb4 f1				pop af 
0fb5 77				ld (hl), a   ; save new char 
0fb6 23				inc hl 
0fb7 3e 00			ld a, 0 
0fb9 77				ld (hl), a 
0fba c3 66 0f			jp input_right 
0fbd				 
0fbd			.insmid: 
0fbd				; hl has insertion point so move everything up one to allow for insertion 
0fbd				;call input_shiftright 
0fbd f1				pop af 
0fbe			 
0fbe			.shufinsmid: 
0fbe 47				ld b, a     ; b contains new char, c prev char at this position  
0fbf 7e				ld a, (hl) 
0fc0			 
0fc0 fe 00			cp 0    ; at end of string need to then dump new char and add term 
0fc2 28 07			jr z, .endinsmid 
0fc4 4f				ld c, a 
0fc5 78				ld a, b 
0fc6 77				ld (hl), a 
0fc7 23				inc hl 
0fc8 79				ld a, c 
0fc9 18 f3			jr .shufinsmid 
0fcb				 
0fcb			 
0fcb			 
0fcb			 
0fcb			.endinsmid: 
0fcb 78				ld a, b 
0fcc 77				ld (hl), a 
0fcd 23				inc hl 
0fce 3e 00			ld a, 0 
0fd0 77				ld (hl), a 
0fd1			 
0fd1			 
0fd1			;	ld (hl), a   ; save new char 
0fd1			 
0fd1 c3 66 0f			jp input_right 
0fd4			 
0fd4			;input_shiftright: 
0fd4			;	; shift text right at cursor, hl has shift start 
0fd4			;	push hl 
0fd4			;	push de 
0fd4			;	push bc 
0fd4			; 
0fd4			; 
0fd4			;	; move to end of string past zero term 
0fd4			;	ld hl,(input_start) 
0fd4			;	ld a, (input_len) 
0fd4			;	call addatohl 
0fd4			;	inc hl 
0fd4			;;	inc hl 
0fd4			;;	inc hl 
0fd4			;	ld a, 0 
0fd4			;	ld (hl), a 
0fd4			;;	dec hl 
0fd4			;	 
0fd4			;;	ld (hl), a 
0fd4			;;	dec hl 
0fd4			; 
0fd4			;	push hl 
0fd4			;	pop de 
0fd4			;	inc de 
0fd4			;	 
0fd4			; 
0fd4			;;	ld hl,(input_start) 
0fd4			;;	ld a, (input_cursor) 
0fd4			;;	call addatohl 
0fd4			; 
0fd4			; 
0fd4			;	; calc how many bytes from cursor pos to end of string we need to shift 
0fd4			;	call input_lenrem    ; get bc length of remaining string 
0fd4			;	;ld a, (input_cursor) 
0fd4			;	;ld c, a 
0fd4			;	ld a, (input_len) 
0fd4			;	cp 2 
0fd4			;	jr z, .iskipzero	 
0fd4			;	;sub c 
0fd4			;	;inc a 
0fd4			;	;ld c, a 
0fd4			;	;ld b, 0 
0fd4			;	inc c 
0fd4			;	inc c 
0fd4			;	; move data 
0fd4			;	lddr 
0fd4			;.iskipzero: 
0fd4			; 
0fd4			;	pop bc 
0fd4			;	pop de 
0fd4			;	pop hl 
0fd4			;	ret	 
0fd4			 
0fd4			input_delchar: 
0fd4				; Delete char at cursor position 
0fd4 cd 90 0f			call input_lenrem    ; get bc length of remaining string 
0fd7 2a 67 ee			ld hl, (input_start) 
0fda 3a 55 ee			ld a, (input_cursor) 
0fdd cd f2 0d			call addatohl 
0fe0			 
0fe0 e5				push hl 
0fe1 d1				pop de 
0fe2 1b				dec de 
0fe3			 
0fe3			.dl:	 
0fe3 ed a0			ldi  
0fe5 7e				ld a, (hl) 
0fe6 fe 00			cp 0 
0fe8 28 02			jr z, .dldone 
0fea 18 f7			jr .dl 
0fec			.dldone: 
0fec ed a0			ldi 
0fee			 
0fee c3 5f 0f			jp input_left 
0ff1			 
0ff1			 
0ff1			endif 
0ff1			 
0ff1			 
0ff1			 
0ff1			if EDIT_V1 
0ff1			input_str: 
0ff1			 
0ff1				    	ld (input_at_pos),a      ; save display position to start 
0ff1					add c 
0ff1					ld (input_at_cursor),a	; save draw pos of cursor 
0ff1					ld (input_start), hl     ; save ptr to buffer 
0ff1					ld a, c 
0ff1					call addatohl 
0ff1					ld (input_ptr), hl     ; save ptr to point under the cursor 
0ff1					ld a,d 
0ff1				        ld (input_size), a       ; save length of input area 
0ff1					ld a, c 
0ff1					ld (input_cursor),a      ; init cursor start position  
0ff1					ld a,e 
0ff1				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0ff1					 
0ff1					 
0ff1			 
0ff1			;		ld a,(input_ptr) 
0ff1			;		ld (input_under_cursor),a 	; save what is under the cursor 
0ff1			 
0ff1			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0ff1					; init cursor shape if not set by the cin routines 
0ff1					ld hl, cursor_shape 
0ff1			if BASE_KEV 
0ff1					ld a, 255 
0ff1			else 
0ff1					ld a, '#' 
0ff1			endif 
0ff1					ld (hl), a 
0ff1					inc hl 
0ff1					ld a, 0 
0ff1					ld (hl), a 
0ff1			 
0ff1					ld a, CUR_BLINK_RATE 
0ff1					ld (input_cur_flash), a 
0ff1					ld a, 1 
0ff1					ld (input_cur_onoff),a 
0ff1			 
0ff1			;	if DEBUG_INPUT 
0ff1			;		push af 
0ff1			;		ld a, 'I' 
0ff1			;		ld (debug_mark),a 
0ff1			;		pop af 
0ff1			;		CALLMONITOR 
0ff1			;	endif 
0ff1			.is1:		; main entry loop 
0ff1			 
0ff1			 
0ff1			 
0ff1					; pause 1ms 
0ff1			 
0ff1					ld a, 1 
0ff1					call aDelayInMS 
0ff1			 
0ff1					; dec flash counter 
0ff1					ld a, (input_cur_flash) 
0ff1					dec a 
0ff1					ld (input_cur_flash), a 
0ff1					cp 0 
0ff1					jr nz, .nochgstate 
0ff1			 
0ff1			 
0ff1					; change state 
0ff1					ld a,(input_cur_onoff) 
0ff1					neg 
0ff1					ld (input_cur_onoff),a 
0ff1			 
0ff1			 
0ff1					; reset on change of state 
0ff1					ld a, CUR_BLINK_RATE 
0ff1					ld (input_cur_flash), a 
0ff1			 
0ff1			.nochgstate: 
0ff1					 
0ff1					 
0ff1			 
0ff1					; display cursor  
0ff1			 
0ff1			;		ld hl, (input_start) 
0ff1			;		ld a, (input_cursor) 
0ff1			;		call addatohl 
0ff1			 
0ff1					; get char under cursor and replace with cursor 
0ff1			ld hl, (input_ptr) 
0ff1			;		ld a, (hl) 
0ff1			;		ld (input_under_cursor),a 
0ff1			;		ld a, '_' 
0ff1			;		ld (hl), a 
0ff1			 
0ff1					; display string 
0ff1			 
0ff1					ld de, (input_start) 
0ff1					ld a, (input_at_pos) 
0ff1					call str_at_display 
0ff1			;	        call update_display 
0ff1			 
0ff1					; find place to put the cursor 
0ff1			;		add h 
0ff1			;		ld l, display_row_1 
0ff1			;		sub l 
0ff1			; (input_at_pos) 
0ff1					;ld c, a 
0ff1			;		ld a, (input_cursor) 
0ff1			;		ld l, (input_at_pos) 
0ff1			;		;ld b, h 
0ff1			;		add l 
0ff1			;		ld (input_at_cursor),a 
0ff1					;ld l,h 
0ff1			 
0ff1			;		ld h, 0 
0ff1			;		ld l,(input_at_pos) 
0ff1			;		ld a, (input_cursor) 
0ff1			;		call addatohl 
0ff1			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0ff1			;		call subafromhl 
0ff1			;		ld a,l 
0ff1			;		ld (input_at_cursor), a 
0ff1			 
0ff1				if DEBUG_INPUT 
0ff1					ld a, (hardware_diag) 
0ff1					cp 0 
0ff1					jr z, .skip_input_diag 
0ff1			 
0ff1					ld a,(input_at_pos) 
0ff1					ld hl, LFSRSeed 
0ff1					call hexout 
0ff1					ld a, (input_cursor) 
0ff1					ld hl, LFSRSeed+2 
0ff1					call hexout 
0ff1					ld a,(input_at_cursor) 
0ff1					ld hl, LFSRSeed+4 
0ff1					call hexout 
0ff1			 
0ff1					ld a,(input_cur_onoff) 
0ff1					ld hl, LFSRSeed+6 
0ff1					call hexout 
0ff1			 
0ff1					ld a,(input_cur_flash) 
0ff1					ld hl, LFSRSeed+8 
0ff1					call hexout 
0ff1			 
0ff1					ld a,(input_len) 
0ff1					ld hl, LFSRSeed+10 
0ff1					call hexout 
0ff1					ld hl, LFSRSeed+12 
0ff1					ld a, 0 
0ff1					ld (hl),a 
0ff1					ld a, display_row_4 
0ff1					ld de, LFSRSeed 
0ff1					call str_at_display 
0ff1					.skip_input_diag: 
0ff1				endif 
0ff1			 
0ff1					; decide on if we are showing the cursor this time round 
0ff1			 
0ff1					ld a, (input_cur_onoff) 
0ff1					cp 255 
0ff1					jr z, .skipcur 
0ff1			 
0ff1			 
0ff1					ld a,(input_at_cursor) 
0ff1					ld de, cursor_shape 
0ff1					call str_at_display 
0ff1			 
0ff1					; save length of current input string 
0ff1					ld hl, (input_start) 
0ff1					ld a, 0 
0ff1					call strlent 
0ff1					ld a,l 
0ff1					ld (input_len),a 
0ff1			 
0ff1			.skipcur: 
0ff1			 
0ff1				        call update_display 
0ff1					 
0ff1			 
0ff1			 
0ff1					; wait 
0ff1				 
0ff1					; TODO loop without wait to flash the cursor and char under cursor	 
0ff1					call cin    ; _wait 
0ff1			 
0ff1					cp 0 
0ff1					jp z, .is1 
0ff1			 
0ff1					; get ptr to char to input into 
0ff1			 
0ff1					ld c,a 
0ff1					ld hl, (input_start) 
0ff1					ld a, (input_cursor) 
0ff1					call addatohl 
0ff1					ld (input_ptr), hl 
0ff1					ld a,c 
0ff1			 
0ff1					; replace char under cursor 
0ff1			 
0ff1			;		ld hl, (input_ptr) 
0ff1			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0ff1			;		ld (hl), a 
0ff1			 
0ff1			;	if DEBUG_INPUT 
0ff1			;		push af 
0ff1			;		ld a, 'i' 
0ff1			;		ld (debug_mark),a 
0ff1			;		pop af 
0ff1			;		CALLMONITOR 
0ff1			;	endif 
0ff1					cp KEY_HOME 
0ff1					jr nz, .iske 
0ff1			 
0ff1					ld a, (input_at_pos) 
0ff1					ld (input_at_cursor),a 
0ff1					ld a, 0 
0ff1					ld (input_cursor), a 
0ff1					jp .is1 
0ff1					 
0ff1			.iske:		cp KEY_END 
0ff1					jr nz, .isknw 
0ff1					jp .is1 
0ff1			 
0ff1			.isknw:		cp KEY_NEXTWORD 
0ff1					jr nz, .iskpw 
0ff1			 
0ff1			.isknwm:	ld hl, (input_ptr) 
0ff1					ld a,(hl)	 
0ff1					cp 0 
0ff1					jp z, .is1    ; end of string 
0ff1					cp ' ' 
0ff1					jp z, .is1    ; end of word 
0ff1					inc hl 
0ff1					ld (input_ptr), hl 
0ff1					ld a, (input_at_cursor) 
0ff1					inc a 
0ff1					ld (input_at_cursor), a 
0ff1					jr .isknwm 
0ff1			 
0ff1			.iskpw:		cp KEY_PREVWORD 
0ff1					jr nz, .iskl 
0ff1			.iskpwm:	 
0ff1					ld hl, (input_ptr) 
0ff1					ld a,(hl)	 
0ff1					cp 0  
0ff1					jp z, .is1    ; end of string 
0ff1					cp ' ' 
0ff1					jp z, .is1    ; end of word 
0ff1					dec hl 
0ff1					ld (input_ptr), hl 
0ff1					ld a, (input_at_cursor) 
0ff1					dec a 
0ff1					ld (input_at_cursor), a 
0ff1					jr .iskpwm 
0ff1			 
0ff1			 
0ff1			.iskl:		cp KEY_LEFT 
0ff1					jr nz, .isk1 
0ff1			 
0ff1					ld a, (input_cursor) 
0ff1			 
0ff1					cp 0 
0ff1					jp z, .is1 		; at start of line to ignore  
0ff1			 
0ff1					dec  a 		; TODO check underflow 
0ff1					ld (input_cursor), a 
0ff1			 
0ff1					ld hl, (input_ptr) 
0ff1					dec hl 
0ff1					ld (input_ptr), hl 
0ff1					 
0ff1					ld a, (input_at_cursor) 
0ff1					dec a 
0ff1					ld (input_at_cursor), a 
0ff1			 
0ff1					ld a, 1		; show cursor moving 
0ff1					ld (input_cur_onoff),a 
0ff1					ld a, CUR_BLINK_RATE 
0ff1					ld (input_cur_flash), a 
0ff1			 
0ff1					jp .is1 
0ff1			 
0ff1			.isk1:		cp KEY_RIGHT 
0ff1					jr nz, .isk2 
0ff1			 
0ff1					ld a,(input_len)		; TODO BUG why cant i load e direct? 
0ff1					ld e,a 
0ff1					ld a, (input_cursor) 
0ff1					cp e 
0ff1					jp z, .is1		; at the end of string so dont go right 
0ff1			 
0ff1					inc  a 		; TODO check overflow 
0ff1					ld (input_cursor), a 
0ff1			 
0ff1					ld a, (input_at_cursor) 
0ff1					inc a 
0ff1					ld (input_at_cursor), a 
0ff1			 
0ff1					ld hl, (input_ptr) 
0ff1					inc hl 
0ff1					ld (input_ptr), hl 
0ff1			 
0ff1					ld a, 1		; show cursor moving 
0ff1					ld (input_cur_onoff),a 
0ff1					ld a, CUR_BLINK_RATE 
0ff1					ld (input_cur_flash), a 
0ff1			 
0ff1					jp .is1 
0ff1			 
0ff1			.isk2:		cp KEY_UP 
0ff1			 
0ff1					jr nz, .isk3 
0ff1			 
0ff1					; swap last command with the current on 
0ff1			 
0ff1					; move cursor to start of string 
0ff1					ld hl, (input_start) 
0ff1					ld (input_ptr), hl 
0ff1			 
0ff1					ld a, (input_at_pos) 
0ff1					ld (input_at_cursor), a 
0ff1			 
0ff1					ld a, 0 
0ff1					ld (input_cursor), a 
0ff1					 
0ff1					; swap input and last command buffers 
0ff1			 
0ff1					ld hl, os_cli_cmd 
0ff1					ld de, os_last_cmd 
0ff1					ld b, 255 
0ff1			.swap1:		ld a, (hl) 
0ff1					ld c,a 
0ff1					ld a, (de) 
0ff1					ld (hl), a 
0ff1					ld a,c 
0ff1					ld (de),a 
0ff1					inc hl 
0ff1					inc de 
0ff1					djnz .swap1 
0ff1			 
0ff1			 
0ff1			 
0ff1			 
0ff1			 
0ff1					jp .is1 
0ff1			 
0ff1			.isk3:		cp KEY_BS 
0ff1					jr nz, .isk4 
0ff1			 
0ff1					ld a, (input_cursor) 
0ff1			 
0ff1					cp 0 
0ff1					jp z, .is1 		; at start of line to ignore  
0ff1			 
0ff1					dec  a 		; TODO check underflow 
0ff1					ld (input_cursor), a 
0ff1			 
0ff1					; hl is source 
0ff1					; de needs to be source - 1 
0ff1			 
0ff1			;		ld a, 0 
0ff1			;		dec hl 
0ff1			;		ld (hl), a 
0ff1			 
0ff1					ld hl, (input_ptr) 
0ff1					dec hl 
0ff1					ld (input_ptr), hl 
0ff1			 
0ff1					; shift all data 
0ff1			 
0ff1					push hl 
0ff1					inc hl 
0ff1					pop de 
0ff1					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0ff1					ld c,a 
0ff1					ld b,0 
0ff1					ldir  
0ff1			 
0ff1			 
0ff1			 
0ff1			 
0ff1					ld a, (input_at_cursor) 
0ff1					dec a 
0ff1					ld (input_at_cursor), a 
0ff1			 
0ff1			 
0ff1					ld a, 1		; show cursor moving 
0ff1					ld (input_cur_onoff),a 
0ff1					ld a, CUR_BLINK_RATE 
0ff1					ld (input_cur_flash), a 
0ff1			 
0ff1					; remove char 
0ff1					ld a, (input_at_cursor) 
0ff1					inc a 
0ff1					ld de,.iblank 
0ff1					call str_at_display 
0ff1			 
0ff1					jp .is1 
0ff1			 
0ff1			.isk4:		cp KEY_CR 
0ff1					jr z, .endinput 
0ff1			 
0ff1					; else add the key press to the end 
0ff1			 
0ff1					ld c, a			; save key pressed 
0ff1			 
0ff1					ld a,(hl)		; get what is currently under char 
0ff1			 
0ff1					cp 0			; we are at the end of the string 
0ff1					jr nz, .onchar 
0ff1					 
0ff1					; add a char to the end of the string 
0ff1				 
0ff1					ld (hl),c 
0ff1					inc hl 
0ff1			;		ld a,' ' 
0ff1			;		ld (hl),a 
0ff1			;		inc hl 
0ff1					ld a,0 
0ff1					ld (hl),a 
0ff1					dec hl 
0ff1			 
0ff1					ld a, (input_cursor) 
0ff1					inc a				; TODO check max string length and scroll  
0ff1					ld (input_cursor), a		; inc cursor pos 
0ff1							 
0ff1					ld a, (input_at_cursor) 
0ff1					inc a 
0ff1					ld (input_at_cursor), a 
0ff1			 
0ff1					ld hl, (input_ptr) 
0ff1					inc hl 
0ff1					ld (input_ptr), hl 
0ff1			 
0ff1					ld hl, (input_ptr) 
0ff1					inc hl 
0ff1					ld (input_ptr), hl 
0ff1			;	if DEBUG_INPUT 
0ff1			;		push af 
0ff1			;		ld a, '+' 
0ff1			;		ld (debug_mark),a 
0ff1			;		pop af 
0ff1			;		CALLMONITOR 
0ff1			;	endif 
0ff1					ld a, 1		; show cursor moving 
0ff1					ld (input_cur_onoff),a 
0ff1					ld a, CUR_BLINK_RATE 
0ff1					ld (input_cur_flash), a 
0ff1					jp .is1 
0ff1					 
0ff1			 
0ff1			 
0ff1					; if on a char then insert 
0ff1			.onchar: 
0ff1			 
0ff1					; TODO over flow check: make sure insert does not blow out buffer 
0ff1			 
0ff1					; need to do some maths to use lddr 
0ff1			 
0ff1					push hl   ; save char pos 
0ff1					push bc 
0ff1			 
0ff1					ld hl, (input_start) 
0ff1					ld a, (input_len) 
0ff1					call addatohl  		; end of string 
0ff1					inc hl 
0ff1					inc hl		; past zero term 
0ff1					push hl 
0ff1					inc hl 
0ff1					push hl  
0ff1			 
0ff1								; start and end of lddr set, now how much to move? 
0ff1			 
0ff1							 
0ff1					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0ff1					ld b,a 
0ff1					ld a,(input_len) 
0ff1					ld e,a 
0ff1					sub b 
0ff1					inc a		;?? 
0ff1					inc a		;?? 
0ff1					inc a		;?? 
0ff1			 
0ff1					ld b,0 
0ff1					ld c,a 
0ff1			 
0ff1				if DEBUG_INPUT 
0ff1					push af 
0ff1					ld a, 'i' 
0ff1					ld (debug_mark),a 
0ff1					pop af 
0ff1			;		CALLMONITOR 
0ff1				endif 
0ff1					pop de 
0ff1					pop hl 
0ff1				if DEBUG_INPUT 
0ff1					push af 
0ff1					ld a, 'I' 
0ff1					ld (debug_mark),a 
0ff1					pop af 
0ff1			;		CALLMONITOR 
0ff1				endif 
0ff1					lddr 
0ff1				 
0ff1			 
0ff1			 
0ff1					; TODO have a key for insert/overwrite mode???? 
0ff1					pop bc 
0ff1					pop hl 
0ff1					ld (hl), c		; otherwise overwrite current char 
0ff1					 
0ff1			 
0ff1			 
0ff1			 
0ff1					ld a, (input_cursor) 
0ff1					inc  a 		; TODO check overflow 
0ff1					ld (input_cursor), a 
0ff1			 
0ff1					ld a, (input_at_cursor) 
0ff1					inc a 
0ff1					ld (input_at_cursor), a 
0ff1			 
0ff1					jp .is1 
0ff1			 
0ff1			.endinput:	; TODO look for end of string 
0ff1			 
0ff1					; add trailing space for end of token 
0ff1			 
0ff1					ld hl, (input_start) 
0ff1					ld a,(input_len) 
0ff1					call addatohl 
0ff1					ld a, ' ' 
0ff1					ld (hl),a 
0ff1					; TODO eof of parse marker 
0ff1			 
0ff1					inc hl 
0ff1					ld a, 0 
0ff1					ld (hl),a 
0ff1			 
0ff1			 
0ff1					ret 
0ff1			 
0ff1			.iblank: db " ",0 
0ff1			 
0ff1			 
0ff1			input_str_prev:	ld (input_at_pos), a 
0ff1					ld (input_start), hl 
0ff1					ld a,1			; add cursor 
0ff1					ld (hl),a 
0ff1					inc hl 
0ff1					ld a,0 
0ff1					ld (hl),a 
0ff1					ld (input_ptr), hl 
0ff1					ld a,d 
0ff1					ld (input_size), a 
0ff1					ld a,0 
0ff1					ld (input_cursor),a 
0ff1			.instr1:	 
0ff1			 
0ff1					; TODO do block cursor 
0ff1					; TODO switch cursor depending on the modifer key 
0ff1			 
0ff1					; update cursor shape change on key hold 
0ff1			 
0ff1					ld hl, (input_ptr) 
0ff1					dec hl 
0ff1					ld a,(cursor_shape) 
0ff1					ld (hl), a 
0ff1			 
0ff1					; display entered text 
0ff1					ld a,(input_at_pos) 
0ff1			            	CALL fLCD_Pos       ;Position cursor to location in A 
0ff1			            	LD   de, (input_start) 
0ff1			            	CALL fLCD_Str       ;Display string pointed to by DE 
0ff1			 
0ff1					call cin 
0ff1					cp 0 
0ff1					jr z, .instr1 
0ff1			 
0ff1					; proecess keyboard controls first 
0ff1			 
0ff1					ld hl,(input_ptr) 
0ff1			 
0ff1					cp KEY_CR	 ; pressing enter ends input 
0ff1					jr z, .instrcr 
0ff1			 
0ff1					cp KEY_BS 	; back space 
0ff1					jr nz, .instr2 
0ff1					; process back space 
0ff1			 
0ff1					; TODO stop back space if at start of string 
0ff1					dec hl 
0ff1					dec hl ; to over write cursor 
0ff1					ld a,(cursor_shape) 
0ff1					;ld a,0 
0ff1					ld (hl),a 
0ff1					inc hl 
0ff1					ld a," " 
0ff1					ld (hl),a 
0ff1					ld (input_ptr),hl 
0ff1					 
0ff1			 
0ff1					jr .instr1 
0ff1			 
0ff1			.instr2:	cp KEY_LEFT    ; cursor left 
0ff1					jr nz, .instr3 
0ff1					dec hl 
0ff1					ld (input_ptr),hl 
0ff1					jr .instr1 
0ff1				 
0ff1			.instr3:	cp KEY_RIGHT      ; cursor right 
0ff1					jr nz, .instr4 
0ff1					inc hl 
0ff1					ld (input_ptr),hl 
0ff1					jr .instr1 
0ff1			 
0ff1			.instr4:	cp KEY_HOME    ; jump to start of line 
0ff1					jr nz, .instr5 
0ff1					dec hl 
0ff1					ld (input_ptr),hl 
0ff1					jr .instr1 
0ff1			 
0ff1			.instr5:	cp KEY_END     ; jump to end of line 
0ff1					jr nz, .instr6 
0ff1					dec hl 
0ff1					ld (input_ptr),hl 
0ff1					jr .instr1 
0ff1			.instr6:        cp KEY_UP      ; recall last command 
0ff1					jr nz, .instrnew 
0ff1			 
0ff1				ld hl, scratch 
0ff1				ld de, os_last_cmd 
0ff1				call strcpy 
0ff1					jr .instr1 
0ff1			 
0ff1			 
0ff1			.instrnew:	; no special key pressed to see if we have room to store it 
0ff1			 
0ff1					; TODO do string size test 
0ff1			 
0ff1					dec hl ; to over write cursor 
0ff1					ld (hl),a 
0ff1					inc hl 
0ff1					ld a,(cursor_shape) 
0ff1					ld (hl),a 
0ff1					inc hl 
0ff1					ld a,0 
0ff1					ld (hl),a 
0ff1			 
0ff1					ld (input_ptr),hl 
0ff1					 
0ff1					jr .instr1 
0ff1			.instrcr:	dec hl		; remove cursor 
0ff1					ld a,' '	; TODO add a trailing space for safety 
0ff1					ld (hl),a 
0ff1					inc hl 
0ff1					ld a,0 
0ff1					ld (hl),a 
0ff1			 
0ff1			 
0ff1					; if at end of line scroll up    
0ff1					; TODO detecting only end of line 4 for scroll up  
0ff1			 
0ff1					;ld   
0ff1			 
0ff1					ret 
0ff1			 
0ff1			 
0ff1			endif 
0ff1			; strcpy hl = dest, de source 
0ff1			 
0ff1 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0ff2 b7			            OR   A              ;Null terminator? 
0ff3 c8			            RET  Z              ;Yes, so finished 
0ff4 1a					ld a,(de) 
0ff5 77					ld (hl),a 
0ff6 13			            INC  DE             ;Point to next character 
0ff7 23					inc hl 
0ff8 18 f7		            JR   strcpy       ;Repeat 
0ffa c9					ret 
0ffb			 
0ffb			 
0ffb			; TODO string_at  
0ffb			; pass string which starts with lcd offset address and then null term string 
0ffb			 
0ffb			; TODO string to dec 
0ffb			; TODO string to hex 
0ffb			; TODO byte to string hex 
0ffb			; TODO byte to string dec 
0ffb			 
0ffb			 
0ffb			 
0ffb			; from z80uartmonitor 
0ffb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ffb			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0ffb			; pass hl for where to put the text 
0ffb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ffb c5			hexout:	PUSH BC 
0ffc f5					PUSH AF 
0ffd 47					LD B, A 
0ffe					; Upper nybble 
0ffe cb 3f				SRL A 
1000 cb 3f				SRL A 
1002 cb 3f				SRL A 
1004 cb 3f				SRL A 
1006 cd 16 10				CALL tohex 
1009 77					ld (hl),a 
100a 23					inc hl	 
100b					 
100b					; Lower nybble 
100b 78					LD A, B 
100c e6 0f				AND 0FH 
100e cd 16 10				CALL tohex 
1011 77					ld (hl),a 
1012 23					inc hl	 
1013					 
1013 f1					POP AF 
1014 c1					POP BC 
1015 c9					RET 
1016					 
1016			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1016			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1016			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1016			tohex: 
1016 e5					PUSH HL 
1017 d5					PUSH DE 
1018 16 00				LD D, 0 
101a 5f					LD E, A 
101b 21 23 10				LD HL, .DATA 
101e 19					ADD HL, DE 
101f 7e					LD A, (HL) 
1020 d1					POP DE 
1021 e1					POP HL 
1022 c9					RET 
1023			 
1023			.DATA: 
1023 30					DEFB	30h	; 0 
1024 31					DEFB	31h	; 1 
1025 32					DEFB	32h	; 2 
1026 33					DEFB	33h	; 3 
1027 34					DEFB	34h	; 4 
1028 35					DEFB	35h	; 5 
1029 36					DEFB	36h	; 6 
102a 37					DEFB	37h	; 7 
102b 38					DEFB	38h	; 8 
102c 39					DEFB	39h	; 9 
102d 41					DEFB	41h	; A 
102e 42					DEFB	42h	; B 
102f 43					DEFB	43h	; C 
1030 44					DEFB	44h	; D 
1031 45					DEFB	45h	; E 
1032 46					DEFB	46h	; F 
1033			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1033			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1033			;;    subtract $30, if result > 9 then subtract $7 more 
1033			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1033			atohex: 
1033 d6 30				SUB $30 
1035 fe 0a				CP 10 
1037 f8					RET M		; If result negative it was 0-9 so we're done 
1038 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
103a c9					RET		 
103b			 
103b			 
103b			 
103b			 
103b			; Get 2 ASCII characters as hex byte from pointer in hl 
103b			 
103b			BYTERD: 
103b 16 00			LD	D,00h		;Set up 
103d cd 45 10			CALL	HEXCON		;Get byte and convert to hex 
1040 87				ADD	A,A		;First nibble so 
1041 87				ADD	A,A		;multiply by 16 
1042 87				ADD	A,A		; 
1043 87				ADD	A,A		; 
1044 57				LD	D,A		;Save hi nibble in D 
1045			HEXCON: 
1045 7e				ld a, (hl)		;Get next chr 
1046 23				inc hl 
1047 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1049 fe 0a			CP	00Ah		;Is it 0-9 ? 
104b 38 02			JR	C,NALPHA	;If so miss next bit 
104d d6 07			SUB	007h		;Else convert alpha 
104f			NALPHA: 
104f b2				OR	D		;Add hi nibble back 
1050 c9				RET			; 
1051			 
1051			 
1051			; 
1051			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1051			; Since the routines get_byte and therefore get_nibble are called, only valid 
1051			; characters (0-9a-f) are accepted. 
1051			; 
1051			;get_word        push    af 
1051			;                call    get_byte        ; Get the upper byte 
1051			;                ld      h, a 
1051			;                call    get_byte        ; Get the lower byte 
1051			;                ld      l, a 
1051			;                pop     af 
1051			;                ret 
1051			; 
1051			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1051			; the routine get_nibble is used only valid characters are accepted - the  
1051			; input routine only accepts characters 0-9a-f. 
1051			; 
1051 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1052 7e					ld a,(hl) 
1053 23					inc hl 
1054 cd 79 10		                call    nibble2val      ; Get upper nibble 
1057 cb 07		                rlc     a 
1059 cb 07		                rlc     a 
105b cb 07		                rlc     a 
105d cb 07		                rlc     a 
105f 47			                ld      b, a            ; Save upper four bits 
1060 7e					ld a,(hl) 
1061 cd 79 10		                call    nibble2val      ; Get lower nibble 
1064 b0			                or      b               ; Combine both nibbles 
1065 c1			                pop     bc              ; Restore B (and C) 
1066 c9			                ret 
1067			; 
1067			; Get a hexadecimal digit from the serial line. This routine blocks until 
1067			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1067			; to the serial line interface. The lower 4 bits of A contain the value of  
1067			; that particular digit. 
1067			; 
1067			;get_nibble      ld a,(hl)           ; Read a character 
1067			;                call    to_upper        ; Convert to upper case 
1067			;                call    is_hex          ; Was it a hex digit? 
1067			;                jr      nc, get_nibble  ; No, get another character 
1067			 ;               call    nibble2val      ; Convert nibble to value 
1067			 ;               call    print_nibble 
1067			 ;               ret 
1067			; 
1067			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1067			; A valid hexadecimal digit is denoted by a set C flag. 
1067			; 
1067			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1067			;                ret     nc              ; Yes 
1067			;                cp      '0'             ; Less than '0'? 
1067			;                jr      nc, is_hex_1    ; No, continue 
1067			;                ccf                     ; Complement carry (i.e. clear it) 
1067			;                ret 
1067			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1067			;                ret     c               ; Yes 
1067			;                cp      'A'             ; Less than 'A'? 
1067			;                jr      nc, is_hex_2    ; No, continue 
1067			;                ccf                     ; Yes - clear carry and return 
1067			;                ret 
1067			;is_hex_2        scf                     ; Set carry 
1067			;                ret 
1067			; 
1067			; Convert a single character contained in A to upper case: 
1067			; 
1067 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1069 d8			                ret     c 
106a fe 7b		                cp      'z' + 1         ; > 'z'? 
106c d0			                ret     nc              ; Nothing to do, either 
106d e6 5f		                and     $5f             ; Convert to upper case 
106f c9			                ret 
1070			 
1070			 
1070			to_lower: 
1070			 
1070			   ; if char is in [A-Z] make it lower case 
1070			 
1070			   ; enter : a = char 
1070			   ; exit  : a = lower case char 
1070			   ; uses  : af 
1070			 
1070 fe 41		   cp 'A' 
1072 d8			   ret c 
1073			    
1073 fe 5b		   cp 'Z'+1 
1075 d0			   ret nc 
1076			    
1076 f6 20		   or $20 
1078 c9			   ret 
1079			 
1079			; 
1079			; Expects a hexadecimal digit (upper case!) in A and returns the 
1079			; corresponding value in A. 
1079			; 
1079 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
107b 38 02		                jr      c, nibble2val_1 ; Yes 
107d d6 07		                sub     7               ; Adjust for A-F 
107f d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1081 e6 0f		                and     $f              ; Only return lower 4 bits 
1083 c9			                ret 
1084			; 
1084			; Print_nibble prints a single hex nibble which is contained in the lower  
1084			; four bits of A: 
1084			; 
1084			;print_nibble    push    af              ; We won't destroy the contents of A 
1084			;                and     $f              ; Just in case... 
1084			;                add     a, '0'             ; If we have a digit we are done here. 
1084			;                cp      '9' + 1         ; Is the result > 9? 
1084			;                jr      c, print_nibble_1 
1084			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1084			;print_nibble_1  call    putc            ; Print the nibble and 
1084			;                pop     af              ; restore the original value of A 
1084			;                ret 
1084			;; 
1084			;; Send a CR/LF pair: 
1084			; 
1084			;crlf            push    af 
1084			;                ld      a, cr 
1084			;                call    putc 
1084			;                ld      a, lf 
1084			;                call    putc 
1084			;                pop     af 
1084			;                ret 
1084			; 
1084			; Print_word prints the four hex digits of a word to the serial line. The  
1084			; word is expected to be in HL. 
1084			; 
1084			;print_word      push    hl 
1084			;                push    af 
1084			;                ld      a, h 
1084			;                call    print_byte 
1084			;                ld      a, l 
1084			;                call    print_byte 
1084			;                pop     af 
1084			;                pop     hl 
1084			;                ret 
1084			; 
1084			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1084			; The byte to be printed is expected to be in A. 
1084			; 
1084			;print_byte      push    af              ; Save the contents of the registers 
1084			;                push    bc 
1084			;                ld      b, a 
1084			;                rrca 
1084			;                rrca 
1084			;                rrca 
1084			;                rrca 
1084			;                call    print_nibble    ; Print high nibble 
1084			;                ld      a, b 
1084			;                call    print_nibble    ; Print low nibble 
1084			;                pop     bc              ; Restore original register contents 
1084			;                pop     af 
1084			;                ret 
1084			 
1084			 
1084			 
1084			 
1084			 
1084			fourehexhl:  
1084 7e				ld a,(hl) 
1085 cd 33 10			call atohex 
1088 cb 3f				SRL A 
108a cb 3f				SRL A 
108c cb 3f				SRL A 
108e cb 3f				SRL A 
1090 47				ld b, a 
1091 23				inc hl 
1092 7e				ld a,(hl) 
1093 23				inc hl 
1094 cd 33 10			call atohex 
1097 80				add b 
1098 57				ld d,a 
1099 7e				ld a,(hl) 
109a cd 33 10			call atohex 
109d cb 3f				SRL A 
109f cb 3f				SRL A 
10a1 cb 3f				SRL A 
10a3 cb 3f				SRL A 
10a5 47				ld b, a 
10a6 23				inc hl 
10a7 7e				ld a,(hl) 
10a8 23				inc hl 
10a9 cd 33 10			call atohex 
10ac 80				add b 
10ad 5f				ld e, a 
10ae d5				push de 
10af e1				pop hl 
10b0 c9				ret 
10b1			 
10b1			; pass hl. returns z set if the byte at hl is a digit 
10b1			;isdigithl:  
10b1			;	push bc 
10b1			;	ld a,(hl) 
10b1			;	cp ':' 
10b1			;	jr nc, .isdf 		; > 
10b1			;	cp '0' 
10b1			;	jr c, .isdf		; < 
10b1			; 
10b1			;	; TODO find a better way to set z 
10b1			; 
10b1			;	ld b,a 
10b1			;	cp b 
10b1			;	pop bc 
10b1			;	ret 
10b1			; 
10b1			;.isdf:	; not digit so clear z 
10b1			; 
10b1			;	; TODO find a better way to unset z 
10b1			; 
10b1			;	ld b,a 
10b1			;	inc b 
10b1			;	cp b 
10b1			; 
10b1			;	pop bc 
10b1			;	ret 
10b1				 
10b1				 
10b1			 
10b1			 
10b1			; pass hl as the four byte address to load 
10b1			 
10b1			get_word_hl:  
10b1 e5				push hl 
10b2 cd 51 10			call get_byte 
10b5				 
10b5 47				ld b, a 
10b6			 
10b6 e1				pop hl 
10b7 23				inc hl 
10b8 23				inc hl 
10b9			 
10b9			; TODO not able to handle a-f  
10b9 7e				ld a,(hl) 
10ba			;	;cp ':' 
10ba			;	cp 'g' 
10ba			;	jr nc, .single_byte_hl 		; > 
10ba			;	cp 'G' 
10ba			;	jr nc, .single_byte_hl 		; > 
10ba			;	cp '0' 
10ba			;	jr c, .single_byte_hl		; < 
10ba			 
10ba				;call isdigithl 
10ba fe 00			cp 0 
10bc 28 06			jr z, .single_byte_hl 
10be			 
10be			.getwhln:   ; hex word so get next byte 
10be			 
10be cd 51 10			call get_byte 
10c1 6f				ld l, a 
10c2 60				ld h,b 
10c3 c9				ret 
10c4 68			.single_byte_hl:   ld l,b 
10c5 26 00				ld h,0 
10c7 c9					ret 
10c8			 
10c8			 
10c8			 
10c8			 
10c8 21 68 18			ld hl,asc+1 
10cb			;	ld a, (hl) 
10cb			;	call nibble2val 
10cb cd 51 10			call get_byte 
10ce			 
10ce			;	call fourehexhl 
10ce 32 f5 e2			ld (scratch+52),a 
10d1				 
10d1 21 f3 e2			ld hl,scratch+50 
10d4 22 e4 e5			ld (os_cur_ptr),hl 
10d7			 
10d7 c9				ret 
10d8			 
10d8			 
10d8			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10d8			 
10d8			; Decimal Unsigned Version 
10d8			 
10d8			;Number in a to decimal ASCII 
10d8			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10d8			;Example: display a=56 as "056" 
10d8			;input: a = number 
10d8			;Output: a=0,value of a in the screen 
10d8			;destroys af,bc (don't know about hl and de) 
10d8			DispAToASCII: 
10d8 0e 9c			ld	c,-100 
10da cd e4 10			call	.Na1 
10dd 0e f6			ld	c,-10 
10df cd e4 10			call	.Na1 
10e2 0e ff			ld	c,-1 
10e4 06 2f		.Na1:	ld	b,'0'-1 
10e6 04			.Na2:	inc	b 
10e7 81				add	a,c 
10e8 38 fc			jr	c,.Na2 
10ea 91				sub	c		;works as add 100/10/1 
10eb f5				push af		;safer than ld c,a 
10ec 78				ld	a,b		;char is in b 
10ed			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10ed f1				pop af		;safer than ld a,c 
10ee c9				ret 
10ef			 
10ef			; Decimal Signed Version 
10ef			 
10ef			; DispA 
10ef			; -------------------------------------------------------------- 
10ef			; Converts a signed integer value to a zero-terminated ASCII 
10ef			; string representative of that value (using radix 10). 
10ef			; -------------------------------------------------------------- 
10ef			; INPUTS: 
10ef			;     HL     Value to convert (two's complement integer). 
10ef			;     DE     Base address of string destination. (pointer). 
10ef			; -------------------------------------------------------------- 
10ef			; OUTPUTS: 
10ef			;     None 
10ef			; -------------------------------------------------------------- 
10ef			; REGISTERS/MEMORY DESTROYED 
10ef			; AF HL 
10ef			; -------------------------------------------------------------- 
10ef			 
10ef			;DispHLToASCII: 
10ef			;   push    de 
10ef			;   push    bc 
10ef			; 
10ef			;; Detect sign of HL. 
10ef			;    bit    7, h 
10ef			;    jr     z, ._DoConvert 
10ef			; 
10ef			;; HL is negative. Output '-' to string and negate HL. 
10ef			;    ld     a, '-' 
10ef			;    ld     (de), a 
10ef			;    inc    de 
10ef			; 
10ef			;; Negate HL (using two's complement) 
10ef			;    xor    a 
10ef			;    sub    l 
10ef			;    ld     l, a 
10ef			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10ef			;    sbc    a, h 
10ef			;    ld     h, a 
10ef			; 
10ef			;; Convert HL to digit characters 
10ef			;._DoConvert: 
10ef			;    ld     b, 0     ; B will count character length of number 
10ef			;-   ld     a, 10 
10ef			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10ef			;    push   af 
10ef			;    inc    b 
10ef			;    ld     a, h 
10ef			;    or     l 
10ef			;    jr     nz, - 
10ef			; 
10ef			;; Retrieve digits from stack 
10ef			;-   pop    af 
10ef			;    or     $30 
10ef			;    ld     (de), a 
10ef			;    inc    de 
10ef			;    djnz   - 
10ef			; 
10ef			;; Terminate string with NULL 
10ef			;    xor    a 
10ef			;    ld     (de), a 
10ef			; 
10ef			;    pop    bc 
10ef			;    pop    de 
10ef			;    ret 
10ef			 
10ef			;Comments 
10ef			; 
10ef			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10ef			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10ef			;    Note that the output string will not be fixed-width. 
10ef			; 
10ef			;Example Usage 
10ef			; 
10ef			;    ld    hl, -1004 
10ef			;    ld    de, OP1 
10ef			;    call  DispA 
10ef			;    ld    hl, OP1 
10ef			;    syscall  PutS 
10ef			 
10ef			 
10ef			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10ef			 
10ef			 
10ef			;Converts an ASCII string to an unsigned 16-bit integer 
10ef			;Quits when it reaches a non-decimal digit 
10ef			 
10ef			string_to_uint16: 
10ef			atoui_16: 
10ef			;Input: 
10ef			;     DE points to the string 
10ef			;Outputs: 
10ef			;     HL is the result 
10ef			;     A is the 8-bit value of the number 
10ef			;     DE points to the byte after the number 
10ef			;Destroys: 
10ef			;     BC 
10ef			;       if the string is non-empty, BC is HL/10 
10ef			;Size:  24 bytes 
10ef			;Speed: 42+d(104+{0,9}) 
10ef			;       d is the number of digits in the number 
10ef			;       max is 640 cycles for a 5 digit number 
10ef			;Assuming no leading zeros: 
10ef			;1 digit:  146cc 
10ef			;2 digit:  250cc 
10ef			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10ef			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10ef			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10ef			;avg: 544.81158447265625cc (544+13297/16384) 
10ef			;=============================================================== 
10ef 21 00 00		  ld hl,0 
10f2			.u16a: 
10f2 1a			  ld a,(de) 
10f3 d6 30		  sub 30h 
10f5 fe 0a		  cp 10 
10f7 d0			  ret nc 
10f8 13			  inc de 
10f9 44			  ld b,h 
10fa 4d			  ld c,l 
10fb 29			  add hl,hl 
10fc 29			  add hl,hl 
10fd 09			  add hl,bc 
10fe 29			  add hl,hl 
10ff 85			  add a,l 
1100 6f			  ld l,a 
1101 30 ef		  jr nc,.u16a 
1103 24			  inc h 
1104 c3 f2 10		  jp .u16a 
1107			 
1107			 
1107			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1107			 
1107			;written by Zeda 
1107			;Converts a 16-bit unsigned integer to an ASCII string. 
1107			 
1107			uitoa_16: 
1107			;Input: 
1107			;   DE is the number to convert 
1107			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1107			;Output: 
1107			;   HL points to the null-terminated ASCII string 
1107			;      NOTE: This isn't necessarily the same as the input HL. 
1107 d5			  push de 
1108 c5			  push bc 
1109 f5			  push af 
110a eb			  ex de,hl 
110b			 
110b 01 f0 d8		  ld bc,-10000 
110e 3e 2f		  ld a,'0'-1 
1110 3c			  inc a 
1111 09			  add hl,bc  
1112 38 fc		   jr c,$-2 
1114 12			  ld (de),a 
1115 13			  inc de 
1116			 
1116 01 e8 03		  ld bc,1000 
1119 3e 3a		  ld a,'9'+1 
111b 3d			  dec a  
111c 09			  add hl,bc  
111d 30 fc		   jr nc,$-2 
111f 12			  ld (de),a 
1120 13			  inc de 
1121			 
1121 01 9c ff		  ld bc,-100 
1124 3e 2f		  ld a,'0'-1 
1126 3c			  inc a  
1127 09			  add hl,bc  
1128 38 fc		   jr c,$-2 
112a 12			  ld (de),a 
112b 13			  inc de 
112c			 
112c 7d			  ld a,l 
112d 26 3a		  ld h,'9'+1 
112f 25			  dec h  
1130 c6 0a		  add a,10  
1132 30 fb		   jr nc,$-3 
1134 c6 30		  add a,'0' 
1136 eb			  ex de,hl 
1137 72			  ld (hl),d 
1138 23			  inc hl 
1139 77			  ld (hl),a 
113a 23			  inc hl 
113b 36 00		  ld (hl),0 
113d			 
113d			;Now strip the leading zeros 
113d 0e fa		  ld c,-6 
113f 09			  add hl,bc 
1140 3e 30		  ld a,'0' 
1142 23			  inc hl  
1143 be			  cp (hl)  
1144 28 fc		  jr z,$-2 
1146			 
1146			;Make sure that the string is non-empty! 
1146 7e			  ld a,(hl) 
1147 b7			  or a 
1148 20 01		  jr nz,.atoub 
114a 2b			  dec hl 
114b			.atoub: 
114b			 
114b f1			  pop af 
114c c1			  pop bc 
114d d1			  pop de 
114e c9			  ret 
114f			 
114f			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
114f			 
114f			toUpper: 
114f			;A is the char. 
114f			;If A is a lowercase letter, this sets it to the matching uppercase 
114f			;18cc or 30cc or 41cc 
114f			;avg: 26.75cc 
114f fe 61		  cp 'a' 
1151 d8			  ret c 
1152 fe 7b		  cp 'z'+1 
1154 d0			  ret nc 
1155 d6 20		  sub 'a'-'A' 
1157 c9			  ret 
1158			 
1158			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1158			 
1158			; String Length 
1158			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1158			 
1158			; Get the length of the null-terminated string starting at $8000 hl 
1158			;    LD     HL, $8000 
1158			 
1158			strlenz: 
1158			 
1158 af			    XOR    A               ; Zero is the value we are looking for. 
1159 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
115a 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
115b			                           ; 65, 536 bytes (the entire addressable memory space). 
115b ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
115d			 
115d			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
115d 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
115e 6f			    LD     L, A             ; number of bytes 
115f ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1161 2b			    DEC    HL              ; Compensate for null. 
1162 c9				ret 
1163			 
1163			; Get the length of the A terminated string starting at $8000 hl 
1163			;    LD     HL, $8000 
1163			 
1163			strlent: 
1163			 
1163			                  ; A is the value we are looking for. 
1163 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1165 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1167			                           ; 65, 536 bytes (the entire addressable memory space). 
1167 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1169			 
1169			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1169 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
116b 2e 00		    LD     L, 0             ; number of bytes 
116d ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
116f 2b			    DEC    HL              ; Compensate for null. 
1170 c9				ret 
1171			 
1171			 
1171			;Comparing Strings 
1171			 
1171			;IN    HL     Address of string1. 
1171			;      DE     Address of string2. 
1171			 
1171			; doc given but wrong??? 
1171			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1171			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1171			; tested 
1171			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1171			 
1171			strcmp_old: 
1171 e5			    PUSH   HL 
1172 d5			    PUSH   DE 
1173			 
1173 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1174 be			    CP     (HL)            ; (want to minimize work). 
1175 38 01		    JR     C, Str1IsBigger 
1177 7e			    LD     A, (HL) 
1178			 
1178			Str1IsBigger: 
1178 4f			    LD     C, A             ; Put length in BC 
1179 06 00		    LD     B, 0 
117b 13			    INC    DE              ; Increment pointers to meat of string. 
117c 23			    INC    HL 
117d			 
117d			CmpLoop: 
117d 1a			    LD     A, (DE)          ; Compare bytes. 
117e ed a1		    CPI 
1180 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1182 13			    INC    DE              ; Update pointer. 
1183 ea 7d 11		    JP     PE, CmpLoop 
1186			 
1186 d1			    POP    DE 
1187 e1			    POP    HL 
1188 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1189 be			    CP     (HL) 
118a c9			    RET 
118b			 
118b			NoMatch: 
118b 2b			    DEC    HL 
118c be			    CP     (HL)            ; Compare again to affect carry. 
118d d1			    POP    DE 
118e e1			    POP    HL 
118f c9			    RET 
1190			 
1190			;; test strmp 
1190			; 
1190			;ld de, .str1 
1190			;ld hl, .str2 
1190			;call strcmp 
1190			;jr z, .z1 
1190			;;this 
1190			;	if DEBUG_FORTH_WORDS 
1190			;		DMARK "NZ1" 
1190			;		CALLMONITOR 
1190			;	endif 
1190			;.z1: 
1190			; 
1190			;	if DEBUG_FORTH_WORDS 
1190			;		DMARK "ZZ1" 
1190			;		CALLMONITOR 
1190			;	endif 
1190			; 
1190			;ld de, .str1 
1190			;ld hl, .str1 
1190			;call strcmp 
1190			;jr z, .z2 
1190			;;this 
1190			;	if DEBUG_FORTH_WORDS 
1190			;		DMARK "NZ2" 
1190			;		CALLMONITOR 
1190			;	endif 
1190			;.z2: 
1190			; 
1190			;	if DEBUG_FORTH_WORDS 
1190			;		DMARK "ZZ2" 
1190			;		CALLMONITOR 
1190			;	endif 
1190			; 
1190			;ld de, .str1 
1190			;ld hl, .str2 
1190			;call strcmp 
1190			;jr c, .c1 
1190			; 
1190			;	if DEBUG_FORTH_WORDS 
1190			;		DMARK "Nc1" 
1190			;		CALLMONITOR 
1190			;	endif 
1190			;.c1: 
1190			;;this 
1190			;	if DEBUG_FORTH_WORDS 
1190			;		DMARK "cc1" 
1190			;		CALLMONITOR 
1190			;	endif 
1190			; 
1190			;ld de, .str1 
1190			;ld hl, .str1 
1190			;call strcmp 
1190			;jr c, .c2 
1190			;;this 
1190			;	if DEBUG_FORTH_WORDS 
1190			;		DMARK "Nc2" 
1190			;		CALLMONITOR 
1190			;	endif 
1190			;.c2: 
1190			; 
1190			;	if DEBUG_FORTH_WORDS 
1190			;		DMARK "cc2" 
1190			;		CALLMONITOR 
1190			;	endif 
1190			;	NEXTW 
1190			;.str1:   db "string1",0 
1190			;.str2:   db "string2",0 
1190			 
1190			; only care about direct match or not 
1190			; hl and de strings 
1190			; zero set if the same 
1190			 
1190			strcmp: 
1190 1a				ld a, (de) 
1191 be				cp (hl) 
1192 28 02			jr z, .ssame 
1194 b7				or a 
1195 c9				ret 
1196			 
1196			.ssame:  
1196 fe 00			cp 0 
1198 c8				ret z 
1199			 
1199 23				inc hl 
119a 13				inc de 
119b 18 f3			jr strcmp 
119d				 
119d				 
119d			 
119d			;Copyright (c) 2014, Luke Maurits 
119d			;All rights reserved. 
119d			; 
119d			;Redistribution and use in source and binary forms, with or without 
119d			;modification, are permitted provided that the following conditions are met: 
119d			; 
119d			;* Redistributions of source code must retain the above copyright notice, this 
119d			;  list of conditions and the following disclaimer. 
119d			; 
119d			;* Redistributions in binary form must reproduce the above copyright notice, 
119d			;  this list of conditions and the following disclaimer in the documentation 
119d			;  and/or other materials provided with the distribution. 
119d			; 
119d			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
119d			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
119d			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
119d			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
119d			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
119d			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
119d			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
119d			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
119d			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
119d			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
119d			 
119d			; https://github.com/lmaurits/lm512/blob/master/string.z80 
119d			 
119d			StrictStrCmp: 
119d				; Load next chars of each string 
119d 1a				ld a, (de) 
119e 47				ld b, a 
119f 7e				ld a, (hl) 
11a0				; Compare 
11a0 b8				cp b 
11a1				; Return non-zero if chars don't match 
11a1 c0				ret nz 
11a2				; Check for end of both strings 
11a2 fe 00			cp "\0" 
11a4				; Return if strings have ended 
11a4 c8				ret z 
11a5				; Otherwise, advance to next chars 
11a5 23				inc hl 
11a6 13				inc de 
11a7 18 f4			jr StrictStrCmp 
11a9			 
11a9			;end 
11a9			; eof 
11a9			 
11a9			 
11a9			 
11a9			 
11a9			 
11a9			 
# End of file firmware_strings.asm
11a9			include "firmware_memory.asm"   ; malloc and free  
11a9			 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9			.mallocsize: db "Wants malloc >256",0 
11a9			.mallocasize: db "MALLOC gives >256",0 
11a9			.malloczero: db "MALLOC gives zero",0 
11a9			 
11a9			malloc_guard_zerolen: 
11a9				push hl 
11a9				push de 
11a9				push af 
11a9			 
11a9				ld de, 0 
11a9			        call cmp16 
11a9				jr nz, .lowalloz 
11a9			 
11a9				push hl 
11a9				push de 
11a9					ld hl, display_fb0 
11a9					ld (display_fb_active), hl 
11a9				call clear_display 
11a9				ld a, 0 
11a9				ld de, .malloczero 
11a9				call str_at_display 
11a9				call update_display 
11a9				call delay1s 
11a9				call delay1s 
11a9				call bp_on 
11a9			;	ld a, 0 
11a9			;	ld (os_view_disable), a 
11a9			 
11a9				pop de 
11a9				pop hl 
11a9			 
11a9				 
11a9			 
11a9				CALLMONITOR 
11a9			.lowalloz: 
11a9			 
11a9			 
11a9				pop af 
11a9				pop de 
11a9				pop hl 
11a9			ret 
11a9			 
11a9			malloc_guard_entry: 
11a9				push hl 
11a9				push de 
11a9				push af 
11a9			 
11a9			 	or a      ;clear carry flag 
11a9				push hl 
11a9				ld de, 255 
11a9				sbc hl, de 
11a9				jr c, .lowalloc 
11a9			 
11a9				push de 
11a9					ld hl, display_fb0 
11a9					ld (display_fb_active), hl 
11a9				call clear_display 
11a9				ld a, 0 
11a9				ld de, .mallocsize 
11a9				call str_at_display 
11a9				call update_display 
11a9				call delay1s 
11a9				call delay1s 
11a9			;	ld a, 0 
11a9			;	ld (os_view_disable), a 
11a9				call bp_on 
11a9			 
11a9				pop de 
11a9				pop hl 
11a9			 
11a9				 
11a9			 
11a9				CALLMONITOR 
11a9				jr .lowdone 
11a9			.lowalloc: 
11a9			 
11a9			 
11a9				pop hl 
11a9			.lowdone:	pop af 
11a9				pop de 
11a9				pop hl 
11a9			ret 
11a9			 
11a9			malloc_guard_exit: 
11a9				push hl 
11a9				push de 
11a9				push af 
11a9			 
11a9			 	or a      ;clear carry flag 
11a9				push hl 
11a9				ld de, 255 
11a9				sbc hl, de 
11a9				jr c, .lowallocx 
11a9			 
11a9				push de 
11a9					ld hl, display_fb0 
11a9					ld (display_fb_active), hl 
11a9				call clear_display 
11a9				ld a, 0 
11a9				ld de, .mallocasize 
11a9				call str_at_display 
11a9				call update_display 
11a9				call delay1s 
11a9				call delay1s 
11a9			;	ld a, 0 
11a9			;	ld (os_view_disable), a 
11a9				call bp_on 
11a9				pop de 
11a9				pop hl 
11a9			 
11a9				CALLMONITOR 
11a9				jr .lowdonex 
11a9			.lowallocx: 
11a9			 
11a9				pop hl 
11a9			.lowdonex:	pop af 
11a9				pop de 
11a9				pop hl 
11a9			ret 
11a9			endif 
11a9			 
11a9			if MALLOC_2 
11a9			; Z80 Malloc and Free Functions 
11a9			 
11a9			; Malloc Function: 
11a9			; Input: 
11a9			;   HL: Size of block to allocate 
11a9			; Output: 
11a9			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11a9			 
11a9			malloc: 
11a9				 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9			call malloc_guard_entry 
11a9			endif 
11a9			 
11a9			 
11a9			 
11a9			 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "mal" 
11a9						CALLMONITOR 
11a9					endif 
11a9			    push af            ; Save AF register 
11a9			    ld a, l            ; Load low byte of size into A 
11a9			    or h               ; Check if size is zero 
11a9			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11a9			 
11a9			    ; Allocate memory 
11a9			    ld hl, (heap_start) ; Load start of heap into HL 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "ma1" 
11a9						CALLMONITOR 
11a9					endif 
11a9			    call malloc_internal ; Call internal malloc function 
11a9			    pop af             ; Restore AF register 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret                ; Return 
11a9			 
11a9			; Free Function: 
11a9			; Input: 
11a9			;   HL: Pointer to memory block to free 
11a9			; Output: 
11a9			;   None 
11a9			 
11a9			free: 
11a9			    push af            ; Save AF register 
11a9			    ld a, l            ; Load low byte of pointer into A 
11a9			    or h               ; Check if pointer is NULL 
11a9			    jp z, free_exit    ; If pointer is NULL, exit 
11a9			 
11a9			    ; Free memory 
11a9			    ld hl, (heap_start) ; Load start of heap into HL 
11a9			    call free_internal  ; Call internal free function 
11a9			    pop af             ; Restore AF register 
11a9			    ret                ; Return 
11a9			 
11a9			; Internal Malloc Function: 
11a9			; Input: 
11a9			;   HL: Size of block to allocate 
11a9			; Output: 
11a9			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11a9			 
11a9			malloc_internal: 
11a9			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11a9			    add hl, bc         ; Add management overhead to requested size 
11a9			    ex de, hl          ; Save total size in DE, and keep it in HL 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "ma2" 
11a9						CALLMONITOR 
11a9					endif 
11a9			 
11a9			    ; Search for free memory block 
11a9			    ld de, (heap_end)  ; Load end of heap into DE 
11a9			    ld bc, 0           ; Initialize counter 
11a9			 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "ma2" 
11a9						CALLMONITOR 
11a9					endif 
11a9			malloc_search_loop: 
11a9			    ; Check if current block is free 
11a9			    ld a, (hl)         ; Load current block's status (free or used) 
11a9			    cp 0               ; Compare with zero (free) 
11a9			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11a9			 
11a9			    ; Check if current block is large enough 
11a9			    ld a, (hl+1)       ; Load high byte of block size 
11a9			    cp l               ; Compare with low byte of requested size 
11a9			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11a9			 
11a9			    ld a, (hl+2)       ; Load low byte of block size 
11a9			    cp h               ; Compare with high byte of requested size 
11a9			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11a9			 
11a9			    ; Mark block as used 
11a9			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11a9			 
11a9			    ; Calculate remaining space in block 
11a9			    ld bc, 0           ; Clear BC 
11a9			    add hl, bc         ; Increment HL to point to start of data block 
11a9			    add hl, de         ; HL = HL + DE (total size) 
11a9			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11a9			    add hl, bc         ; Add management overhead to start of data block 
11a9			 
11a9			    ; Save pointer to allocated block in HL 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9						DMARK "ma5" 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret 
11a9			 
11a9			malloc_skip_block_check: 
11a9			    ; Move to the next block 
11a9			    ld bc, 3           ; Size of management overhead 
11a9			    add hl, bc         ; Move to the next block 
11a9			    inc de             ; Increment counter 
11a9			 
11a9			    ; Check if we have reached the end of heap 
11a9			    ld a, e            ; Load low byte of heap end address 
11a9			    cp (hl)            ; Compare with low byte of current address 
11a9			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11a9			    ld a, d            ; Load high byte of heap end address 
11a9			    cp 0               ; Check if it's zero (end of memory) 
11a9			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11a9			 
11a9			    ; If we reached here, allocation failed 
11a9			    xor a              ; Set result to NULL 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9						DMARK "ma6" 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret 
11a9			malloc_exit: 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9						DMARK "ma7" 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret 
11a9			 
11a9			; Internal Free Function: 
11a9			; Input: 
11a9			;   HL: Pointer to memory block to free 
11a9			; Output: 
11a9			;   None 
11a9			 
11a9			free_internal: 
11a9			    ld de, (heap_start) ; Load start of heap into DE 
11a9			    ld bc, 0            ; Initialize counter 
11a9			 
11a9			free_search_loop: 
11a9			    ; Check if current block contains the pointer 
11a9			    ld a, l             ; Load low byte of pointer 
11a9			    cp (hl+1)           ; Compare with high byte of current block's address 
11a9			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11a9			    ld a, h             ; Load high byte of pointer 
11a9			    cp (hl+2)           ; Compare with low byte of current block's address 
11a9			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11a9			 
11a9			    ; Mark block as free 
11a9			    ld (hl), 0          ; Set status byte to indicate free block 
11a9			    ret                 ; Return 
11a9			 
11a9			free_skip_block_check: 
11a9			    ; Move to the next block 
11a9			    ld bc, 3            ; Size of management overhead 
11a9			    add hl, bc          ; Move to the next block 
11a9			    inc de              ; Increment counter 
11a9			 
11a9			    ; Check if we have reached the end of heap 
11a9			    ld a, e             ; Load low byte of heap end address 
11a9			    cp (hl)             ; Compare with low byte of current address 
11a9			    jr nz, free_search_loop  ; If not equal, continue searching 
11a9			    ld a, d             ; Load high byte of heap end address 
11a9			    cp 0                ; Check if it's zero (end of memory) 
11a9			    jr nz, free_search_loop  ; If not zero, continue searching 
11a9			 
11a9			    ; If we reached here, pointer is not found in heap 
11a9			    ret 
11a9			 
11a9			free_exit: 
11a9			    ret                 ; Return 
11a9			 
11a9			; Define heap start and end addresses 
11a9			;heap_start:    .dw 0xC000   ; Start of heap 
11a9			;heap_end:      .dw 0xE000   ; End of heap 
11a9			 
11a9			endif 
11a9			 
11a9			 
11a9			if MALLOC_1 
11a9			 
11a9			 
11a9			 
11a9			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11a9			 
11a9			;moved to firmware.asm 
11a9			;heap_start        .equ  0x9000      ; Starting address of heap 
11a9			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11a9			 
11a9			;      .org 0 
11a9			;      jp    main 
11a9			 
11a9			 
11a9			;      .org  0x100 
11a9			;main: 
11a9			;      ld    HL, 0x8100 
11a9			;      ld    SP, HL 
11a9			; 
11a9			;      call  heap_init 
11a9			; 
11a9			;      ; Make some allocations 
11a9			;      ld    HL, 12 
11a9			;      call  malloc            ; Allocates 0x9004 
11a9			; 
11a9			;      ld    HL, 12 
11a9			;      call  malloc            ; Allocates 0x9014 
11a9			; 
11a9			;      ld    HL, 12 
11a9			;      call  malloc            ; Allocates 0x9024 
11a9			; 
11a9			;      ; Free some allocations 
11a9			;      ld    HL, 0x9014 
11a9			;      call  free 
11a9			; 
11a9			;      ld    HL, 0x9004 
11a9			;      call  free 
11a9			; 
11a9			;      ld    HL, 0x9024 
11a9			;      call  free 
11a9			; 
11a9			; 
11a9			;      halt 
11a9			 
11a9			 
11a9			;------------------------------------------------------------------------------ 
11a9			;     heap_init                                                               : 
11a9			;                                                                             : 
11a9			; Description                                                                 : 
11a9			;     Initialise the heap and make it ready for malloc and free operations.   : 
11a9			;                                                                             : 
11a9			;     The heap is maintained as a linked list, starting with an initial       : 
11a9			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11a9			;     the first free block in the heap. Each block then points to the next    : 
11a9			;     free block within the heap, and the free list ends at the first block   : 
11a9			;     with a null pointer to the next free block.                             : 
11a9			;                                                                             : 
11a9			; Parameters                                                                  : 
11a9			;     Inputs are compile-time only. Two defines which specify the starting    : 
11a9			;     address of the heap and its size are required, along with a memory      : 
11a9			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11a9			;     principally stores a pointer to the first free block in the heap.       : 
11a9			;                                                                             : 
11a9			; Returns                                                                     : 
11a9			;     Nothing                                                                 : 
11a9			;------------------------------------------------------------------------------ 
11a9			heap_init: 
11a9 e5			      push  HL 
11aa			 
11aa			      ; Initialise free list struct 
11aa 21 98 5e		      ld    HL, heap_start 
11ad 22 93 5e		      ld    (free_list), HL 
11b0 21 00 00		      ld    HL, 0 
11b3 22 95 5e		      ld    (free_list+2), HL 
11b6			 
11b6			      ; Insert first free block at bottom of heap, consumes entire heap 
11b6 21 98 e2		      ld    HL, heap_start+heap_size-4 
11b9 22 98 5e		      ld    (heap_start), HL        ; Next block (end of free list) 
11bc 21 00 84		      ld    HL, heap_size-4 
11bf 22 9a 5e		      ld    (heap_start+2), HL      ; Block size 
11c2			 
11c2			      ; Insert end of free list block at top of heap - two null words will 
11c2			      ; terminate the free list 
11c2 21 00 00		      ld    HL, 0 
11c5 22 9a e2		      ld    (heap_start+heap_size-2), HL 
11c8 22 98 e2		      ld    (heap_start+heap_size-4), HL 
11cb			 
11cb e1			      pop   HL 
11cc			 
11cc c9			      ret 
11cd			 
11cd			 
11cd			;------------------------------------------------------------------------------ 
11cd			;     malloc                                                                  : 
11cd			;                                                                             : 
11cd			; Description                                                                 : 
11cd			;     Allocates the wanted space from the heap and returns the address of the : 
11cd			;     first useable byte of the allocation.                                   : 
11cd			;                                                                             : 
11cd			;     Allocations can happen in one of two ways:                              : 
11cd			;                                                                             : 
11cd			;     1. A free block may be found which is the exact size wanted. In this    : 
11cd			;        case the block is removed from the free list and retuedn to the      : 
11cd			;        caller.                                                              : 
11cd			;     2. A free block may be found which is larger than the size wanted. In   : 
11cd			;        this case, the larger block is split into two. The first portion of  : 
11cd			;        this block will become the requested space by the malloc call and    : 
11cd			;        is returned to the caller. The second portion becomes a new free     : 
11cd			;        block, and the free list is adjusted to maintain continuity via this : 
11cd			;        newly created block.                                                 : 
11cd			;                                                                             : 
11cd			;     malloc does not set any initial value in the allocated space, the       : 
11cd			;     caller is required to do this as required.                              : 
11cd			;                                                                             : 
11cd			;     This implementation of malloc uses the stack exclusively, and is        : 
11cd			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11cd			;     advisable to disable interrupts before calling malloc, and recommended  : 
11cd			;     to avoid the use of malloc inside ISRs in general.                      : 
11cd			;                                                                             : 
11cd			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11cd			;                                                                             : 
11cd			; Parameters                                                                  : 
11cd			;     HL  Number of bytes wanted                                              : 
11cd			;                                                                             : 
11cd			; Returns                                                                     : 
11cd			;     HL  Address of the first useable byte of the allocation                 : 
11cd			;                                                                             : 
11cd			; Flags                                                                       : 
11cd			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11cd			;                                                                             : 
11cd			; Stack frame                                                                 : 
11cd			;       |             |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |     BC      |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |     DE      |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |     IX      |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |  prev_free  |                                                       : 
11cd			;   +4  +-------------+                                                       : 
11cd			;       |  this_free  |                                                       : 
11cd			;   +2  +-------------+                                                       : 
11cd			;       |  next_free  |                                                       : 
11cd			;   +0  +-------------+                                                       : 
11cd			;       |             |                                                       : 
11cd			;                                                                             : 
11cd			;------------------------------------------------------------------------------ 
11cd			 
11cd			 
11cd			;malloc: 
11cd			; 
11cd			;	SAVESP ON 1 
11cd			; 
11cd			;	call malloc_code 
11cd			; 
11cd			;	CHECKSP ON 1 
11cd			;	ret 
11cd			 
11cd			 
11cd			malloc: 
11cd c5			      push  BC 
11ce d5			      push  DE 
11cf dd e5		      push  IX 
11d1			if DEBUG_FORTH_MALLOC_HIGH 
11d1			call malloc_guard_entry 
11d1			endif 
11d1			 
11d1					if DEBUG_FORTH_MALLOC 
11d1						DMARK "mal" 
11d1						CALLMONITOR 
11d1					endif 
11d1 7c			      ld    A, H                    ; Exit if no space requested 
11d2 b5			      or    L 
11d3 ca 92 12		      jp    Z, malloc_early_exit 
11d6			 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			; 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			 
11d6			 
11d6			 
11d6			 
11d6					if DEBUG_FORTH_MALLOC 
11d6						DMARK "maA" 
11d6						CALLMONITOR 
11d6					endif 
11d6			      ; Set up stack frame 
11d6 eb			      ex    DE, HL 
11d7 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11da 39			      add   HL, SP 
11db f9			      ld    SP, HL 
11dc dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11e0 dd 39		      add   IX, SP 
11e2			 
11e2			      ; Setup initial state 
11e2 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11e5 19			      add   HL, DE 
11e6			 
11e6 44			      ld    B, H                    ; Move want to BC 
11e7 4d			      ld    C, L 
11e8			 
11e8 21 93 5e		      ld    HL, free_list           ; Store prev_free ptr to stack 
11eb dd 75 04		      ld    (IX+4), L 
11ee dd 74 05		      ld    (IX+5), H 
11f1			 
11f1 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11f2 23			      inc   HL 
11f3 56			      ld    D, (HL) 
11f4 dd 73 02		      ld    (IX+2), E 
11f7 dd 72 03		      ld    (IX+3), D 
11fa eb			      ex    DE, HL                  ; this_free ptr into HL 
11fb			 
11fb					if DEBUG_FORTH_MALLOC 
11fb						DMARK "maB" 
11fb						CALLMONITOR 
11fb					endif 
11fb			      ; Loop through free block list to find some space 
11fb			malloc_find_space: 
11fb 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11fc 23			      inc   HL 
11fd 56			      ld    D, (HL) 
11fe			 
11fe 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
11ff b3			      or    E 
1200 ca 8c 12		      jp    Z, malloc_no_space 
1203			 
1203 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1206 dd 72 01		      ld    (IX+1), D 
1209			 
1209			      ; Does this block have enough space to make the allocation? 
1209 23			      inc   HL                      ; Load free block size into DE 
120a 5e			      ld    E, (HL) 
120b 23			      inc   HL 
120c 56			      ld    D, (HL) 
120d			 
120d eb			      ex    DE, HL                  ; Check size of block against want 
120e b7			      or    A                       ; Ensure carry flag clear 
120f ed 42		      sbc   HL, BC 
1211 e5			      push  HL                      ; Store the result for later (new block size) 
1212			 
1212 ca 61 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1215 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1217			 
1217			      ; this_free block is not big enough, setup ptrs to test next free block 
1217 e1			      pop   HL                      ; Discard previous result 
1218			 
1218 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
121b dd 66 03		      ld    H, (IX+3) 
121e dd 75 04		      ld    (IX+4), L 
1221 dd 74 05		      ld    (IX+5), H 
1224			 
1224 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1227 dd 66 01		      ld    H, (IX+1) 
122a dd 75 02		      ld    (IX+2), L 
122d dd 74 03		      ld    (IX+3), H 
1230			 
1230					if DEBUG_FORTH_MALLOC 
1230						DMARK "MA>" 
1230						CALLMONITOR 
1230					endif 
1230 18 c9		      jr    malloc_find_space 
1232			 
1232			      ; split a bigger block into two - requested size and remaining size 
1232			malloc_alloc_split: 
1232					if DEBUG_FORTH_MALLOC 
1232						DMARK "MAs" 
1232						CALLMONITOR 
1232					endif 
1232 eb			      ex    DE, HL                  ; Calculate address of new free block 
1233 2b			      dec   HL 
1234 2b			      dec   HL 
1235 2b			      dec   HL 
1236 09			      add   HL, BC 
1237			 
1237			      ; Create a new block and point it at next_free 
1237 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
123a dd 56 01		      ld    D, (IX+1) 
123d			 
123d 73			      ld    (HL), E                 ; Store next_free ptr into new block 
123e 23			      inc   HL 
123f 72			      ld    (HL), D 
1240			 
1240 d1			      pop   DE                      ; Store size of new block into new block 
1241 23			      inc   HL 
1242 73			      ld    (HL), E 
1243 23			      inc   HL 
1244 72			      ld    (HL), D 
1245			 
1245			      ; Update this_free ptr to point to new block 
1245 2b			      dec   HL 
1246 2b			      dec   HL 
1247 2b			      dec   HL 
1248			 
1248 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
124b dd 56 03		      ld    D, (IX+3) 
124e			 
124e dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1251 dd 74 03		      ld    (IX+3), H 
1254			 
1254			      ; Modify this_free block to be allocation 
1254 eb			      ex    DE, HL 
1255 af			      xor   A                       ; Null the next block ptr of allocated block 
1256 77			      ld    (HL), A 
1257 23			      inc   HL 
1258 77			      ld    (HL), A 
1259			 
1259 23			      inc   HL                      ; Store want size into allocated block 
125a 71			      ld    (HL), C 
125b 23			      inc   HL 
125c 70			      ld    (HL), B 
125d 23			      inc   HL 
125e e5			      push  HL                      ; Address of allocation to return 
125f			 
125f 18 19		      jr    malloc_update_links 
1261			 
1261			malloc_alloc_fit: 
1261 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1262			 
1262					if DEBUG_FORTH_MALLOC 
1262						DMARK "MAf" 
1262						CALLMONITOR 
1262					endif 
1262			      ; Modify this_free block to be allocation 
1262 eb			      ex    DE, HL 
1263 2b			      dec   HL 
1264 2b			      dec   HL 
1265 2b			      dec   HL 
1266			 
1266 af			      xor   A                       ; Null the next block ptr of allocated block 
1267 77			      ld    (HL), A 
1268 23			      inc   HL 
1269 77			      ld    (HL), A 
126a			 
126a 23			      inc   HL                      ; Store address of allocation to return 
126b 23			      inc   HL 
126c 23			      inc   HL 
126d e5			      push  HL 
126e			 
126e			      ; Copy next_free ptr to this_free, remove allocated block from free list 
126e dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1271 dd 66 01		      ld    H, (IX+1) 
1274			 
1274 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1277 dd 74 03		      ld    (IX+3), H 
127a			 
127a			 
127a			malloc_update_links: 
127a			      ; Update prev_free ptr to point to this_free 
127a dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
127d dd 66 05		      ld    H, (IX+5) 
1280			 
1280 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1283 dd 56 03		      ld    D, (IX+3) 
1286			 
1286 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1287 23			      inc   HL 
1288 72			      ld    (HL), D 
1289			 
1289					if DEBUG_FORTH_MALLOC 
1289						DMARK "Mul" 
1289						CALLMONITOR 
1289					endif 
1289			      ; Clear the Z flag to indicate successful allocation 
1289 7a			      ld    A, D 
128a b3			      or    E 
128b			 
128b d1			      pop   DE                      ; Address of allocation 
128c					if DEBUG_FORTH_MALLOC 
128c						DMARK "MAu" 
128c						CALLMONITOR 
128c					endif 
128c			 
128c			malloc_no_space: 
128c 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
128f 39			      add   HL, SP 
1290 f9			      ld    SP, HL 
1291			 
1291 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1292					if DEBUG_FORTH_MALLOC 
1292						DMARK "MAN" 
1292						CALLMONITOR 
1292					endif 
1292			 
1292			malloc_early_exit: 
1292					if DEBUG_FORTH_MALLOC 
1292						DMARK "MAx" 
1292						CALLMONITOR 
1292					endif 
1292 dd e1		      pop   IX 
1294 d1			      pop   DE 
1295 c1			      pop   BC 
1296			 
1296			if DEBUG_FORTH_MALLOC_HIGH 
1296			call malloc_guard_exit 
1296			call malloc_guard_zerolen 
1296			endif 
1296 c9			      ret 
1297			 
1297			 
1297			;------------------------------------------------------------------------------ 
1297			;     free                                                                    : 
1297			;                                                                             : 
1297			; Description                                                                 : 
1297			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1297			;     returned by malloc, otherwise the behaviour is undefined.               : 
1297			;                                                                             : 
1297			;     Where possible, directly adjacent free blocks will be merged together   : 
1297			;     into larger blocks to help ensure that the heap does not become         : 
1297			;     excessively fragmented.                                                 : 
1297			;                                                                             : 
1297			;     free does not clear or set any other value into the freed space, and    : 
1297			;     therefore its contents may be visible through subsequent malloc's. The  : 
1297			;     caller should clear the freed space as required.                        : 
1297			;                                                                             : 
1297			;     This implementation of free uses the stack exclusively, and is          : 
1297			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1297			;     advisable to disable interrupts before calling free, and recommended    : 
1297			;     to avoid the use of free inside ISRs in general.                        : 
1297			;                                                                             : 
1297			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1297			;                                                                             : 
1297			; Parameters                                                                  : 
1297			;     HL  Pointer to address of first byte of allocation to be freed          : 
1297			;                                                                             : 
1297			; Returns                                                                     : 
1297			;     Nothing                                                                 : 
1297			;                                                                             : 
1297			; Stack frame                                                                 : 
1297			;       |             |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |     BC      |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |     DE      |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |     IX      |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |  prev_free  |                                                       : 
1297			;   +2  +-------------+                                                       : 
1297			;       |  next_free  |                                                       : 
1297			;   +0  +-------------+                                                       : 
1297			;       |             |                                                       : 
1297			;                                                                             : 
1297			;------------------------------------------------------------------------------ 
1297			free: 
1297 c5			      push  BC 
1298 d5			      push  DE 
1299 dd e5		      push  IX 
129b			 
129b 7c			      ld    A, H                    ; Exit if ptr is null 
129c b5			      or    L 
129d ca 61 13		      jp    Z, free_early_exit 
12a0			 
12a0			      ; Set up stack frame 
12a0 eb			      ex    DE, HL 
12a1 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12a4 39			      add   HL, SP 
12a5 f9			      ld    SP, HL 
12a6 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12aa dd 39		      add   IX, SP 
12ac			 
12ac			      ; The address in HL points to the start of the useable allocated space, 
12ac			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12ac			      ; address of the block itself. 
12ac eb			      ex    DE, HL 
12ad 11 fc ff		      ld    DE, -4 
12b0 19			      add   HL, DE 
12b1			 
12b1			      ; An allocated block must have a null next block pointer in it 
12b1 7e			      ld    A, (HL) 
12b2 23			      inc   HL 
12b3 b6			      or    (HL) 
12b4 c2 5c 13		      jp    NZ, free_done 
12b7			 
12b7 2b			      dec   HL 
12b8			 
12b8 44			      ld    B, H                    ; Copy HL to BC 
12b9 4d			      ld    C, L 
12ba			 
12ba			      ; Loop through the free list to find the first block with an address 
12ba			      ; higher than the block being freed 
12ba 21 93 5e		      ld    HL, free_list 
12bd			 
12bd			free_find_higher_block: 
12bd 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12be 23			      inc   HL 
12bf 56			      ld    D, (HL) 
12c0 2b			      dec   HL 
12c1			 
12c1 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12c4 dd 72 01		      ld    (IX+1), D 
12c7 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12ca dd 74 03		      ld    (IX+3), H 
12cd			 
12cd 78			      ld    A, B                    ; Check if DE is greater than BC 
12ce ba			      cp    D                       ; Compare MSB first 
12cf 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12d1 30 04		      jr    NC, free_find_higher_block_skip 
12d3 79			      ld    A, C 
12d4 bb			      cp    E                       ; Then compare LSB 
12d5 38 08		      jr    C, free_found_higher_block 
12d7			 
12d7			free_find_higher_block_skip: 
12d7 7a			      ld    A, D                    ; Reached the end of the free list? 
12d8 b3			      or    E 
12d9 ca 5c 13		      jp    Z, free_done 
12dc			 
12dc eb			      ex    DE, HL 
12dd			 
12dd 18 de		      jr    free_find_higher_block 
12df			 
12df			free_found_higher_block: 
12df			      ; Insert freed block between prev and next free blocks 
12df 71			      ld    (HL), C                 ; Point prev free block to freed block 
12e0 23			      inc   HL 
12e1 70			      ld    (HL), B 
12e2			 
12e2 60			      ld    H, B                    ; Point freed block at next free block 
12e3 69			      ld    L, C 
12e4 73			      ld    (HL), E 
12e5 23			      inc   HL 
12e6 72			      ld    (HL), D 
12e7			 
12e7			      ; Check if the freed block is adjacent to the next free block 
12e7 23			      inc   HL                      ; Load size of freed block into HL 
12e8 5e			      ld    E, (HL) 
12e9 23			      inc   HL 
12ea 56			      ld    D, (HL) 
12eb eb			      ex    DE, HL 
12ec			 
12ec 09			      add   HL, BC                  ; Add addr of freed block and its size 
12ed			 
12ed dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12f0 dd 56 01		      ld    D, (IX+1) 
12f3			 
12f3 b7			      or    A                       ; Clear the carry flag 
12f4 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12f6 20 22		      jr    NZ, free_check_adjacent_to_prev 
12f8			 
12f8			      ; Freed block is adjacent to next, merge into one bigger block 
12f8 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12f9 5e			      ld    E, (HL) 
12fa 23			      inc   HL 
12fb 56			      ld    D, (HL) 
12fc e5			      push  HL                      ; Save ptr to next block for later 
12fd			 
12fd 60			      ld    H, B                    ; Store ptr from next block into freed block 
12fe 69			      ld    L, C 
12ff 73			      ld    (HL), E 
1300 23			      inc   HL 
1301 72			      ld    (HL), D 
1302			 
1302 e1			      pop   HL                      ; Restore ptr to next block 
1303 23			      inc   HL                      ; Load size of next block into DE 
1304 5e			      ld    E, (HL) 
1305 23			      inc   HL 
1306 56			      ld    D, (HL) 
1307 d5			      push  DE                      ; Save next block size for later 
1308			 
1308 60			      ld    H, B                    ; Load size of freed block into HL 
1309 69			      ld    L, C 
130a 23			      inc   HL 
130b 23			      inc   HL 
130c 5e			      ld    E, (HL) 
130d 23			      inc   HL 
130e 56			      ld    D, (HL) 
130f eb			      ex    DE, HL 
1310			 
1310 d1			      pop   DE                      ; Restore size of next block 
1311 19			      add   HL, DE                  ; Add sizes of both blocks 
1312 eb			      ex    DE, HL 
1313			 
1313 60			      ld    H, B                    ; Store new bigger size into freed block 
1314 69			      ld    L, C 
1315 23			      inc   HL 
1316 23			      inc   HL 
1317 73			      ld    (HL), E 
1318 23			      inc   HL 
1319 72			      ld    (HL), D 
131a			 
131a			free_check_adjacent_to_prev: 
131a			      ; Check if the freed block is adjacent to the prev free block 
131a dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
131d dd 66 03		      ld    H, (IX+3) 
1320			 
1320 23			      inc   HL                      ; Size of prev free block into DE 
1321 23			      inc   HL 
1322 5e			      ld    E, (HL) 
1323 23			      inc   HL 
1324 56			      ld    D, (HL) 
1325 2b			      dec   HL 
1326 2b			      dec   HL 
1327 2b			      dec   HL 
1328			 
1328 19			      add   HL, DE                  ; Add prev block addr and size 
1329			 
1329 b7			      or    A                       ; Clear the carry flag 
132a ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
132c 20 2e		      jr    NZ, free_done 
132e			 
132e			      ; Freed block is adjacent to prev, merge into one bigger block 
132e 60			      ld    H, B                    ; Load next ptr from freed block into DE 
132f 69			      ld    L, C 
1330 5e			      ld    E, (HL) 
1331 23			      inc   HL 
1332 56			      ld    D, (HL) 
1333 e5			      push  HL                      ; Save freed block ptr for later 
1334			 
1334 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1337 dd 66 03		      ld    H, (IX+3) 
133a 73			      ld    (HL), E 
133b 23			      inc   HL 
133c 72			      ld    (HL), D 
133d			 
133d e1			      pop   HL                      ; Restore freed block ptr 
133e 23			      inc   HL                      ; Load size of freed block into DE 
133f 5e			      ld    E, (HL) 
1340 23			      inc   HL 
1341 56			      ld    D, (HL) 
1342 d5			      push  DE                      ; Save freed block size for later 
1343			 
1343 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1346 dd 66 03		      ld    H, (IX+3) 
1349 23			      inc   HL 
134a 23			      inc   HL 
134b 5e			      ld    E, (HL) 
134c 23			      inc   HL 
134d 56			      ld    D, (HL) 
134e			 
134e e1			      pop   HL                      ; Add sizes of both blocks 
134f 19			      add   HL, DE 
1350 eb			      ex    DE, HL 
1351			 
1351 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1354 dd 66 03		      ld    H, (IX+3) 
1357 23			      inc   HL 
1358 23			      inc   HL 
1359 73			      ld    (HL), E 
135a 23			      inc   HL 
135b 72			      ld    (HL), D 
135c			 
135c			free_done: 
135c 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
135f 39			      add   HL, SP 
1360 f9			      ld    SP, HL 
1361			 
1361			free_early_exit: 
1361 dd e1		      pop   IX 
1363 d1			      pop   DE 
1364 c1			      pop   BC 
1365			 
1365 c9			      ret 
1366			 
1366			; moved to firmware.asm 
1366			; 
1366			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1366			;                  .dw   0 
1366			 
1366			 
1366			endif 
1366			 
1366			 
1366			if MALLOC_3 
1366			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1366			;heap_start        .equ  0x9000      ; Starting address of heap 
1366			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1366			; 
1366			 ;     .org 0 
1366			  ;    jp    main 
1366			; 
1366			; 
1366			 ;     .org  0x100 
1366			;main: 
1366			 ;     ld    HL, 0x8100 
1366			  ;    ld    SP, HL 
1366			; 
1366			;      call  heap_init 
1366			 
1366			      ; Make some allocations 
1366			;      ld    HL, 12 
1366			;      call  malloc            ; Allocates 0x9004 
1366			; 
1366			 ;     ld    HL, 12 
1366			;      call  malloc            ; Allocates 0x9014 
1366			 
1366			;      ld    HL, 12 
1366			;      call  malloc            ; Allocates 0x9024 
1366			 
1366			      ; Free some allocations 
1366			;      ld    HL, 0x9014 
1366			;      call  free 
1366			 
1366			;      ld    HL, 0x9004 
1366			;      call  free 
1366			; 
1366			;      ld    HL, 0x9024 
1366			;      call  free 
1366			 
1366			 
1366			 ;     halt 
1366			 
1366			 
1366			;------------------------------------------------------------------------------ 
1366			;     heap_init                                                               : 
1366			;                                                                             : 
1366			; Description                                                                 : 
1366			;     Initialise the heap and make it ready for malloc and free operations.   : 
1366			;                                                                             : 
1366			;     The heap is maintained as a linked list, starting with an initial       : 
1366			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1366			;     the first free block in the heap. Each block then points to the next    : 
1366			;     free block within the heap, and the free list ends at the first block   : 
1366			;     with a null pointer to the next free block.                             : 
1366			;                                                                             : 
1366			; Parameters                                                                  : 
1366			;     Inputs are compile-time only. Two defines which specify the starting    : 
1366			;     address of the heap and its size are required, along with a memory      : 
1366			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1366			;     principally stores a pointer to the first free block in the heap.       : 
1366			;                                                                             : 
1366			; Returns                                                                     : 
1366			;     Nothing                                                                 : 
1366			;------------------------------------------------------------------------------ 
1366			heap_init: 
1366			      push  HL 
1366			 
1366			      ; Initialise free list struct 
1366			      ld    HL, heap_start 
1366			      ld    (free_list), HL 
1366			      ld    HL, 0 
1366			      ld    (free_list+2), HL 
1366			 
1366			      ; Insert first free block at bottom of heap, consumes entire heap 
1366			      ld    HL, heap_start+heap_size-4 
1366			      ld    (heap_start), HL        ; Next block (end of free list) 
1366			      ld    HL, heap_size-4 
1366			      ld    (heap_start+2), HL      ; Block size 
1366			 
1366			      ; Insert end of free list block at top of heap - two null words will 
1366			      ; terminate the free list 
1366			      ld    HL, 0 
1366			      ld    (heap_start+heap_size-2), HL 
1366			      ld    (heap_start+heap_size-4), HL 
1366			 
1366			      pop   HL 
1366			 
1366			      ret 
1366			 
1366			 
1366			;------------------------------------------------------------------------------ 
1366			;     malloc                                                                  : 
1366			;                                                                             : 
1366			; Description                                                                 : 
1366			;     Allocates the wanted space from the heap and returns the address of the : 
1366			;     first useable byte of the allocation.                                   : 
1366			;                                                                             : 
1366			;     Allocations can happen in one of two ways:                              : 
1366			;                                                                             : 
1366			;     1. A free block may be found which is the exact size wanted. In this    : 
1366			;        case the block is removed from the free list and retuedn to the      : 
1366			;        caller.                                                              : 
1366			;     2. A free block may be found which is larger than the size wanted. In   : 
1366			;        this case, the larger block is split into two. The first portion of  : 
1366			;        this block will become the requested space by the malloc call and    : 
1366			;        is returned to the caller. The second portion becomes a new free     : 
1366			;        block, and the free list is adjusted to maintain continuity via this : 
1366			;        newly created block.                                                 : 
1366			;                                                                             : 
1366			;     malloc does not set any initial value in the allocated space, the       : 
1366			;     caller is required to do this as required.                              : 
1366			;                                                                             : 
1366			;     This implementation of malloc uses the stack exclusively, and is        : 
1366			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1366			;     advisable to disable interrupts before calling malloc, and recommended  : 
1366			;     to avoid the use of malloc inside ISRs in general.                      : 
1366			;                                                                             : 
1366			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1366			;                                                                             : 
1366			; Parameters                                                                  : 
1366			;     HL  Number of bytes wanted                                              : 
1366			;                                                                             : 
1366			; Returns                                                                     : 
1366			;     HL  Address of the first useable byte of the allocation                 : 
1366			;                                                                             : 
1366			; Flags                                                                       : 
1366			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1366			;                                                                             : 
1366			; Stack frame                                                                 : 
1366			;       |             |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     BC      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     DE      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     IX      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |  prev_free  |                                                       : 
1366			;   +4  +-------------+                                                       : 
1366			;       |  this_free  |                                                       : 
1366			;   +2  +-------------+                                                       : 
1366			;       |  next_free  |                                                       : 
1366			;   +0  +-------------+                                                       : 
1366			;       |             |                                                       : 
1366			;                                                                             : 
1366			;------------------------------------------------------------------------------ 
1366			malloc: 
1366			      push  BC 
1366			      push  DE 
1366			      push  IX 
1366			 
1366			      ld    A, H                    ; Exit if no space requested 
1366			      or    L 
1366			      jp    Z, malloc_early_exit 
1366			 
1366			      ; Set up stack frame 
1366			      ex    DE, HL 
1366			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			      ld    IX, 0                   ; Use IX as a frame pointer 
1366			      add   IX, SP 
1366			 
1366			      ; Setup initial state 
1366			      ld    HL, 4                   ; want must also include space used by block struct 
1366			      add   HL, DE 
1366			 
1366			      ld    B, H                    ; Move want to BC 
1366			      ld    C, L 
1366			 
1366			      ld    HL, free_list           ; Store prev_free ptr to stack 
1366			      ld    (IX+4), L 
1366			      ld    (IX+5), H 
1366			 
1366			      ld    E, (HL)                 ; Store this_free ptr to stack 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      ld    (IX+2), E 
1366			      ld    (IX+3), D 
1366			      ex    DE, HL                  ; this_free ptr into HL 
1366			 
1366			      ; Loop through free block list to find some space 
1366			malloc_find_space: 
1366			      ld    E, (HL)                 ; Load next_free ptr into DE 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			 
1366			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1366			      or    E 
1366			      jp    Z, malloc_no_space 
1366			 
1366			      ld    (IX+0), E               ; Store next_free ptr to stack 
1366			      ld    (IX+1), D 
1366			 
1366			      ; Does this block have enough space to make the allocation? 
1366			      inc   HL                      ; Load free block size into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			 
1366			      ex    DE, HL                  ; Check size of block against want 
1366			      or    A                       ; Ensure carry flag clear 
1366			      sbc   HL, BC 
1366			      push  HL                      ; Store the result for later (new block size) 
1366			 
1366			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1366			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1366			 
1366			      ; this_free block is not big enough, setup ptrs to test next free block 
1366			      pop   HL                      ; Discard previous result 
1366			 
1366			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1366			      ld    H, (IX+3) 
1366			      ld    (IX+4), L 
1366			      ld    (IX+5), H 
1366			 
1366			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1366			      ld    H, (IX+1) 
1366			      ld    (IX+2), L 
1366			      ld    (IX+3), H 
1366			 
1366			      jr    malloc_find_space 
1366			 
1366			      ; split a bigger block into two - requested size and remaining size 
1366			malloc_alloc_split: 
1366			      ex    DE, HL                  ; Calculate address of new free block 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			      add   HL, BC 
1366			 
1366			      ; Create a new block and point it at next_free 
1366			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1366			      ld    D, (IX+1) 
1366			 
1366			      ld    (HL), E                 ; Store next_free ptr into new block 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      pop   DE                      ; Store size of new block into new block 
1366			      inc   HL 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      ; Update this_free ptr to point to new block 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			 
1366			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1366			      ld    D, (IX+3) 
1366			 
1366			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1366			      ld    (IX+3), H 
1366			 
1366			      ; Modify this_free block to be allocation 
1366			      ex    DE, HL 
1366			      xor   A                       ; Null the next block ptr of allocated block 
1366			      ld    (HL), A 
1366			      inc   HL 
1366			      ld    (HL), A 
1366			 
1366			      inc   HL                      ; Store want size into allocated block 
1366			      ld    (HL), C 
1366			      inc   HL 
1366			      ld    (HL), B 
1366			      inc   HL 
1366			      push  HL                      ; Address of allocation to return 
1366			 
1366			      jr    malloc_update_links 
1366			 
1366			malloc_alloc_fit: 
1366			      pop   HL                      ; Dont need new block size, want is exact fit 
1366			 
1366			      ; Modify this_free block to be allocation 
1366			      ex    DE, HL 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			 
1366			      xor   A                       ; Null the next block ptr of allocated block 
1366			      ld    (HL), A 
1366			      inc   HL 
1366			      ld    (HL), A 
1366			 
1366			      inc   HL                      ; Store address of allocation to return 
1366			      inc   HL 
1366			      inc   HL 
1366			      push  HL 
1366			 
1366			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1366			      ld    L, (IX+0)               ; next_free to HL 
1366			      ld    H, (IX+1) 
1366			 
1366			      ld    (IX+2), L               ; HL to this_free 
1366			      ld    (IX+3), H 
1366			 
1366			 
1366			malloc_update_links: 
1366			      ; Update prev_free ptr to point to this_free 
1366			      ld    L, (IX+4)               ; prev_free ptr to HL 
1366			      ld    H, (IX+5) 
1366			 
1366			      ld    E, (IX+2)               ; this_free ptr to DE 
1366			      ld    D, (IX+3) 
1366			 
1366			      ld    (HL), E                 ; this_free ptr into prev_free 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      ; Clear the Z flag to indicate successful allocation 
1366			      ld    A, D 
1366			      or    E 
1366			 
1366			      pop   DE                      ; Address of allocation 
1366			 
1366			malloc_no_space: 
1366			      ld    HL, 6                   ; Clean up stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			 
1366			      ex    DE, HL                  ; Alloc addr into HL for return 
1366			 
1366			malloc_early_exit: 
1366			      pop   IX 
1366			      pop   DE 
1366			      pop   BC 
1366			 
1366			      ret 
1366			 
1366			 
1366			;------------------------------------------------------------------------------ 
1366			;     free                                                                    : 
1366			;                                                                             : 
1366			; Description                                                                 : 
1366			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1366			;     returned by malloc, otherwise the behaviour is undefined.               : 
1366			;                                                                             : 
1366			;     Where possible, directly adjacent free blocks will be merged together   : 
1366			;     into larger blocks to help ensure that the heap does not become         : 
1366			;     excessively fragmented.                                                 : 
1366			;                                                                             : 
1366			;     free does not clear or set any other value into the freed space, and    : 
1366			;     therefore its contents may be visible through subsequent malloc's. The  : 
1366			;     caller should clear the freed space as required.                        : 
1366			;                                                                             : 
1366			;     This implementation of free uses the stack exclusively, and is          : 
1366			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1366			;     advisable to disable interrupts before calling free, and recommended    : 
1366			;     to avoid the use of free inside ISRs in general.                        : 
1366			;                                                                             : 
1366			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1366			;                                                                             : 
1366			; Parameters                                                                  : 
1366			;     HL  Pointer to address of first byte of allocation to be freed          : 
1366			;                                                                             : 
1366			; Returns                                                                     : 
1366			;     Nothing                                                                 : 
1366			;                                                                             : 
1366			; Stack frame                                                                 : 
1366			;       |             |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     BC      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     DE      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     IX      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |  prev_free  |                                                       : 
1366			;   +2  +-------------+                                                       : 
1366			;       |  next_free  |                                                       : 
1366			;   +0  +-------------+                                                       : 
1366			;       |             |                                                       : 
1366			;                                                                             : 
1366			;------------------------------------------------------------------------------ 
1366			free: 
1366			      push  BC 
1366			      push  DE 
1366			      push  IX 
1366			 
1366			      ld    A, H                    ; Exit if ptr is null 
1366			      or    L 
1366			      jp    Z, free_early_exit 
1366			 
1366			      ; Set up stack frame 
1366			      ex    DE, HL 
1366			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			      ld    IX, 0                   ; Use IX as a frame pointer 
1366			      add   IX, SP 
1366			 
1366			      ; The address in HL points to the start of the useable allocated space, 
1366			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1366			      ; address of the block itself. 
1366			      ex    DE, HL 
1366			      ld    DE, -4 
1366			      add   HL, DE 
1366			 
1366			      ; An allocated block must have a null next block pointer in it 
1366			      ld    A, (HL) 
1366			      inc   HL 
1366			      or    (HL) 
1366			      jp    NZ, free_done 
1366			 
1366			      dec   HL 
1366			 
1366			      ld    B, H                    ; Copy HL to BC 
1366			      ld    C, L 
1366			 
1366			      ; Loop through the free list to find the first block with an address 
1366			      ; higher than the block being freed 
1366			      ld    HL, free_list 
1366			 
1366			free_find_higher_block: 
1366			      ld    E, (HL)                 ; Load next ptr from free block 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      dec   HL 
1366			 
1366			      ld    (IX+0), E               ; Save ptr to next free block 
1366			      ld    (IX+1), D 
1366			      ld    (IX+2), L               ; Save ptr to prev free block 
1366			      ld    (IX+3), H 
1366			 
1366			      ld    A, B                    ; Check if DE is greater than BC 
1366			      cp    D                       ; Compare MSB first 
1366			      jr    Z, $+4                  ; MSB the same, compare LSB 
1366			      jr    NC, free_find_higher_block_skip 
1366			      ld    A, C 
1366			      cp    E                       ; Then compare LSB 
1366			      jr    C, free_found_higher_block 
1366			 
1366			free_find_higher_block_skip: 
1366			      ld    A, D                    ; Reached the end of the free list? 
1366			      or    E 
1366			      jp    Z, free_done 
1366			 
1366			      ex    DE, HL 
1366			 
1366			      jr    free_find_higher_block 
1366			 
1366			free_found_higher_block: 
1366			      ; Insert freed block between prev and next free blocks 
1366			      ld    (HL), C                 ; Point prev free block to freed block 
1366			      inc   HL 
1366			      ld    (HL), B 
1366			 
1366			      ld    H, B                    ; Point freed block at next free block 
1366			      ld    L, C 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      ; Check if the freed block is adjacent to the next free block 
1366			      inc   HL                      ; Load size of freed block into HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      ex    DE, HL 
1366			 
1366			      add   HL, BC                  ; Add addr of freed block and its size 
1366			 
1366			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1366			      ld    D, (IX+1) 
1366			 
1366			      or    A                       ; Clear the carry flag 
1366			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1366			      jr    NZ, free_check_adjacent_to_prev 
1366			 
1366			      ; Freed block is adjacent to next, merge into one bigger block 
1366			      ex    DE, HL                  ; Load next ptr from next block into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  HL                      ; Save ptr to next block for later 
1366			 
1366			      ld    H, B                    ; Store ptr from next block into freed block 
1366			      ld    L, C 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      pop   HL                      ; Restore ptr to next block 
1366			      inc   HL                      ; Load size of next block into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  DE                      ; Save next block size for later 
1366			 
1366			      ld    H, B                    ; Load size of freed block into HL 
1366			      ld    L, C 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      ex    DE, HL 
1366			 
1366			      pop   DE                      ; Restore size of next block 
1366			      add   HL, DE                  ; Add sizes of both blocks 
1366			      ex    DE, HL 
1366			 
1366			      ld    H, B                    ; Store new bigger size into freed block 
1366			      ld    L, C 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			free_check_adjacent_to_prev: 
1366			      ; Check if the freed block is adjacent to the prev free block 
1366			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1366			      ld    H, (IX+3) 
1366			 
1366			      inc   HL                      ; Size of prev free block into DE 
1366			      inc   HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			 
1366			      add   HL, DE                  ; Add prev block addr and size 
1366			 
1366			      or    A                       ; Clear the carry flag 
1366			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1366			      jr    NZ, free_done 
1366			 
1366			      ; Freed block is adjacent to prev, merge into one bigger block 
1366			      ld    H, B                    ; Load next ptr from freed block into DE 
1366			      ld    L, C 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  HL                      ; Save freed block ptr for later 
1366			 
1366			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1366			      ld    H, (IX+3) 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      pop   HL                      ; Restore freed block ptr 
1366			      inc   HL                      ; Load size of freed block into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  DE                      ; Save freed block size for later 
1366			 
1366			      ld    L, (IX+2)               ; Load size of prev block into DE 
1366			      ld    H, (IX+3) 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			 
1366			      pop   HL                      ; Add sizes of both blocks 
1366			      add   HL, DE 
1366			      ex    DE, HL 
1366			 
1366			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1366			      ld    H, (IX+3) 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			free_done: 
1366			      ld    HL, 4                   ; Clean up stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			 
1366			free_early_exit: 
1366			      pop   IX 
1366			      pop   DE 
1366			      pop   BC 
1366			 
1366			      ret 
1366			 
1366			 
1366			;      .org 0x8000 
1366			; 
1366			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1366			 ;                 .dw   0 
1366			 
1366			endif 
1366			 
1366			 
1366			if MALLOC_4 
1366			 
1366			; My memory allocation code. Very very simple.... 
1366			; allocate space under 250 chars 
1366			 
1366			heap_init: 
1366				; init start of heap as zero 
1366				;  
1366			 
1366				ld hl, heap_start 
1366				ld a, 0 
1366				ld (hl), a      ; empty block 
1366				inc hl 
1366				ld a, 0 
1366				ld (hl), a      ; length of block 
1366				; write end of list 
1366				inc hl 
1366				ld a,(hl) 
1366				inc hl 
1366				ld a,(hl) 
1366				 
1366			 
1366				; init some malloc vars 
1366			 
1366				ld hl, 0 
1366				ld (free_list), hl       ; store last malloc location 
1366			 
1366				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1366				ld a, 0 
1366				ld (hl), a 
1366			 
1366			 
1366				ld hl, heap_start 
1366				;  
1366				  
1366				ret 
1366			 
1366			 
1366			;    free block marker 
1366			;    requested size  
1366			;    pointer to next block 
1366			;    .... 
1366			;    next block marker 
1366			 
1366			 
1366			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1366			; 
1366			 
1366			 
1366			malloc:  
1366				push de 
1366				push bc 
1366				push af 
1366			 
1366				; hl space required 
1366				 
1366				ld c, l    ; hold space   (TODO only a max of 255) 
1366			 
1366			;	inc c     ; TODO BUG need to fix memory leak on push str 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			 
1366			 
1366			 
1366				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1366			 
1366				ld a, (free_list+3) 
1366				cp 0 
1366				jr z, .contheap 
1366			 
1366				ld hl, (free_list)     ; get last alloc 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mrs" 
1366						CALLMONITOR 
1366					endif 
1366				jr .startalloc 
1366			 
1366			.contheap: 
1366				ld hl, heap_start 
1366			 
1366			.startalloc: 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mym" 
1366						CALLMONITOR 
1366					endif 
1366			.findblock: 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mmf" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366				ld a,(hl)  
1366				; if byte is zero then clear to use 
1366			 
1366				cp 0 
1366				jr z, .foundemptyblock 
1366			 
1366				; if byte is not clear 
1366				;     then byte is offset to next block 
1366			 
1366				inc hl 
1366				ld a, (hl) ; get size 
1366			.nextblock:	inc hl 
1366					ld e, (hl) 
1366					inc hl 
1366					ld d, (hl) 
1366					ex de, hl 
1366			;	inc hl  ; move past the store space 
1366			;	inc hl  ; move past zero index  
1366			 
1366				; TODO detect no more space 
1366			 
1366				push hl 
1366				ld de, heap_end 
1366				call cmp16 
1366				pop hl 
1366				jr nc, .nospace 
1366			 
1366				jr .findblock 
1366			 
1366			.nospace: ld hl, 0 
1366				jp .exit 
1366			 
1366			 
1366			.foundemptyblock:	 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mme" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			; TODO has block enough space if reusing??? 
1366			 
1366				;  
1366			 
1366			; see if this block has been previously used 
1366				inc hl 
1366				ld a, (hl) 
1366				dec hl 
1366				cp 0 
1366				jr z, .newblock 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "meR" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			; no reusing previously allocated block 
1366			 
1366			; is it smaller than previously used? 
1366				 
1366				inc hl    ; move to size 
1366				ld a, c 
1366				sub (hl)        ; we want c < (hl) 
1366				dec hl    ; move back to marker 
1366			        jr z, .findblock 
1366			 
1366				; update with the new size which should be lower 
1366			 
1366			        ;inc  hl   ; negate next move. move back to size  
1366			 
1366			.newblock: 
1366				; need to be at marker here 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "meN" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			 
1366				ld a, c 
1366			 
1366				ld (free_list+3), a	 ; flag resume from last malloc  
1366				ld (free_list), hl    ; save out last location 
1366			 
1366			 
1366				;inc a     ; space for length byte 
1366				ld (hl), a     ; save block in use marker 
1366			 
1366				inc hl   ; move to space marker 
1366				ld (hl), a    ; save new space 
1366			 
1366				inc hl   ; move to start of allocated area 
1366				 
1366			;	push hl     ; save where we are - 1  
1366			 
1366			;	inc hl  ; move past zero index  
1366				; skip space to set down new marker 
1366			 
1366				; provide some extra space for now 
1366			 
1366				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1366				inc a 
1366				inc a 
1366			 
1366				push hl   ; save where we are in the node block 
1366			 
1366				call addatohl 
1366			 
1366				; write linked list point 
1366			 
1366				pop de     ; get our node position 
1366				ex de, hl 
1366			 
1366				ld (hl), e 
1366				inc hl 
1366				ld (hl), d 
1366			 
1366				inc hl 
1366			 
1366				; now at start of allocated data so save pointer 
1366			 
1366				push hl 
1366			 
1366				; jump to position of next node and setup empty header in DE 
1366			 
1366				ex de, hl 
1366			 
1366			;	inc hl ; move past end of block 
1366			 
1366				ld a, 0 
1366				ld (hl), a   ; empty marker 
1366				inc hl 
1366				ld (hl), a   ; size 
1366				inc hl  
1366				ld (hl), a   ; ptr 
1366				inc hl 
1366				ld (hl), a   ; ptr 
1366			 
1366			 
1366				pop hl 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mmr" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			.exit: 
1366				pop af 
1366				pop bc 
1366				pop de  
1366				ret 
1366			 
1366			 
1366			 
1366			 
1366			free:  
1366				push hl 
1366				push af 
1366				; get address in hl 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "fre" 
1366						CALLMONITOR 
1366					endif 
1366				; data is at hl - move to block count 
1366				dec hl 
1366				dec hl    ; get past pointer 
1366				dec hl 
1366			 
1366				ld a, (hl)    ; need this for a validation check 
1366			 
1366				dec hl    ; move to block marker 
1366			 
1366				; now check that the block count and block marker are the same  
1366			        ; this checks that we are on a malloc node and not random memory 
1366			        ; OK a faint chance this could be a problem but rare - famous last words! 
1366			 
1366				ld c, a 
1366				ld a, (hl)    
1366			 
1366				cp c 
1366				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1366			 
1366				; yes good chance we are on a malloc node 
1366			 
1366				ld a, 0      
1366				ld (hl), a   ; mark as free 
1366			 
1366				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1366			 
1366			.freeignore:  
1366			 
1366				pop af 
1366				pop hl 
1366			 
1366				ret 
1366			 
1366			 
1366			 
1366			endif 
1366			 
1366			; eof 
# End of file firmware_memory.asm
1366			  
1366			; device C  
1366			; Now handled by SPI  
1366			;if SOUND_ENABLE  
1366			;	include "firmware_sound.asm"  
1366			;endif  
1366			  
1366			include "firmware_diags.asm"  
1366			; Hardware diags menu 
1366			 
1366			 
1366			config: 
1366			 
1366 3e 00			ld a, 0 
1368 21 8c 13			ld hl, .configmn 
136b cd f6 0b			call menu 
136e			 
136e fe 00			cp 0 
1370 c8				ret z 
1371			 
1371			;	cp 1 
1371			;	call z, .savetostore 
1371			 
1371 fe 01			cp 1 
1373			if STARTUP_V1 
1373 cc a2 13			call z, .selautoload 
1376			endif 
1376			 
1376			if STARTUP_V2 
1376				call z, .enautoload 
1376			endif 
1376 fe 02			cp 2 
1378 cc 98 13			call z, .disautoload 
137b			;	cp 3 
137b			;	call z, .selbank 
137b fe 03			cp 3 
137d cc c0 13			call z, .debug_tog 
1380 fe 04			cp 4 
1382 cc 0e 15			call z, .bpsgo 
1385 fe 05			cp 5 
1387 cc e9 13			call z, hardware_diags 
138a			if STARTUP_V2 
138a				cp 6 
138a				call z, create_startup 
138a			endif 
138a 18 da			jr config 
138c			 
138c			.configmn: 
138c			;	dw prom_c3 
138c fc 16			dw prom_c2 
138e 11 17			dw prom_c2a 
1390			;	dw prom_c2b 
1390			;	dw prom_c4 
1390 30 17			dw prom_m4 
1392 4b 17			dw prom_m4b 
1394 53 17			dw prom_c1 
1396			if STARTUP_V2 
1396				dw prom_c9 
1396			endif 
1396 00 00			dw 0 
1398				 
1398			 
1398			if STARTUP_V2 
1398			.enautoload: 
1398				if STORAGE_SE 
1398				ld a, $fe      ; bit 0 clear 
1398				ld (spi_device), a 
1398			 
1398				call storage_get_block_0 
1398			 
1398				ld a, 1 
1398				ld (store_page+STORE_0_AUTOFILE), a 
1398			 
1398					ld hl, 0 
1398					ld de, store_page 
1398				call storage_write_block	 ; save update 
1398				else 
1398			 
1398				ld hl, prom_notav 
1398				ld de, prom_empty 
1398				call info_panel 
1398				endif 
1398			 
1398			 
1398				ret 
1398			endif 
1398			 
1398			.disautoload: 
1398				if STORAGE_SE 
1398				ld a, $fe      ; bit 0 clear 
1398				ld (spi_device), a 
1398			 
1398				call storage_get_block_0 
1398			 
1398				ld a, 0 
1398				ld (store_page+STORE_0_AUTOFILE), a 
1398			 
1398					ld hl, 0 
1398					ld de, store_page 
1398				call storage_write_block	 ; save update 
1398				else 
1398			 
1398 21 62 17			ld hl, prom_notav 
139b 11 78 17			ld de, prom_empty 
139e cd 56 0b			call info_panel 
13a1				endif 
13a1			 
13a1			 
13a1 c9				ret 
13a2			 
13a2			if STARTUP_V1 
13a2			 
13a2			; Select auto start 
13a2			 
13a2			.selautoload: 
13a2			 
13a2				 
13a2				if STORAGE_SE 
13a2			 
13a2					call config_dir 
13a2				        ld hl, scratch 
13a2					ld a, 0 
13a2					call menu 
13a2			 
13a2					cp 0 
13a2					ret z 
13a2			 
13a2					dec a 
13a2			 
13a2			 
13a2					; locate menu option 
13a2			 
13a2					ld hl, scratch 
13a2					call table_lookup 
13a2			 
13a2					if DEBUG_FORTH_WORDS 
13a2						DMARK "ALl" 
13a2						CALLMONITOR 
13a2					endif 
13a2					; with the pointer to the menu it, the byte following the zero term is the file id 
13a2			 
13a2					ld a, 0 
13a2					ld bc, 50   ; max of bytes to look at 
13a2					cpir  
13a2			 
13a2					if DEBUG_FORTH_WORDS 
13a2						DMARK "ALb" 
13a2						CALLMONITOR 
13a2					endif 
13a2					;inc hl 
13a2			 
13a2					ld a, (hl)   ; file id 
13a2					 
13a2				        ; save bank and file ids 
13a2			 
13a2					push af 
13a2			 
13a2			; TODO need to save to block 0 on bank 1	 
13a2			 
13a2					call storage_get_block_0 
13a2			 
13a2					if DEBUG_FORTH_WORDS 
13a2						DMARK "AL0" 
13a2						CALLMONITOR 
13a2					endif 
13a2					pop af 
13a2			 
13a2					ld (store_page+STORE_0_FILERUN),a 
13a2					 
13a2					; save bank id 
13a2			 
13a2					ld a,(spi_device) 
13a2					ld (store_page+STORE_0_BANKRUN),a 
13a2			 
13a2					; enable auto run of store file 
13a2			 
13a2					ld a, 1 
13a2					ld (store_page+STORE_0_AUTOFILE),a 
13a2			 
13a2					; save buffer 
13a2			 
13a2					ld hl, 0 
13a2					ld de, store_page 
13a2					if DEBUG_FORTH_WORDS 
13a2						DMARK "ALw" 
13a2						CALLMONITOR 
13a2					endif 
13a2				call storage_write_block	 ; save update 
13a2			  
13a2			 
13a2			 
13a2			 
13a2					ld hl, scratch 
13a2					call config_fdir 
13a2			 
13a2				else 
13a2			 
13a2 21 62 17			ld hl, prom_notav 
13a5 11 78 17			ld de, prom_empty 
13a8 cd 56 0b			call info_panel 
13ab			 
13ab				endif 
13ab c9				ret 
13ac			endif 
13ac			 
13ac			 
13ac			; Select storage bank 
13ac			 
13ac			.selbank: 
13ac			 
13ac			;	if STORAGE_SE 
13ac			;	else 
13ac			 
13ac 21 62 17			ld hl, prom_notav 
13af 11 78 17			ld de, prom_empty 
13b2 cd 56 0b			call info_panel 
13b5			;	endif 
13b5				 
13b5 c9				ret 
13b6			 
13b6			if STORAGE_SE 
13b6			 
13b6			.config_ldir:   
13b6				; Load storage bank labels into menu array 
13b6			 
13b6				 
13b6			 
13b6			 
13b6				ret 
13b6			 
13b6			 
13b6			endif 
13b6			 
13b6			 
13b6			; Save user words to storage 
13b6			 
13b6			.savetostore: 
13b6			 
13b6			;	if STORAGE_SE 
13b6			; 
13b6			;		call config_dir 
13b6			;	        ld hl, scratch 
13b6			;		ld a, 0 
13b6			;		call menu 
13b6			;		 
13b6			;		ld hl, scratch 
13b6			;		call config_fdir 
13b6			; 
13b6			;	else 
13b6			 
13b6 21 62 17			ld hl, prom_notav 
13b9 11 78 17			ld de, prom_empty 
13bc cd 56 0b			call info_panel 
13bf			 
13bf			;	endif 
13bf			 
13bf c9				ret 
13c0			 
13c0			if STARTUP_V2 
13c0			 
13c0			create_startup: 
13c0			 
13c0				ld a, 0 
13c0				ld hl, .crstart 
13c0				call menu 
13c0			 
13c0				cp 0 
13c0				ret z 
13c0			 
13c0				cp 1 
13c0				call z, .genlsword 
13c0				cp 2 
13c0				call z, .genedword 
13c0			 
13c0				cp 3 
13c0				call z, .gendemword 
13c0			 
13c0				cp 4 
13c0				call z, .genutlword 
13c0				cp 5 
13c0				call z, .genspiword 
13c0				cp 6 
13c0				call z, .genkeyword 
13c0				cp 7 
13c0				call z, .gensoundword 
13c0				cp 7 
13c0				call z, .genhwword 
13c0				jr create_startup 
13c0			 
13c0			.genhwword: 
13c0				ld hl, crs_hw 
13c0				ld de, .hwworddef 
13c0				call .genfile 
13c0				ret 
13c0			.gensoundword: 
13c0				ld hl, crs_sound 
13c0				ld de, .soundworddef 
13c0				call .genfile 
13c0				ret 
13c0			.genlsword: 
13c0				ld hl, crs_s1 
13c0				ld de, .lsworddef 
13c0				call .genfile 
13c0				ret 
13c0			 
13c0			.genedword: 
13c0				ld de, .edworddef 
13c0				ld hl, crs_s2 
13c0				call .genfile 
13c0				ret 
13c0			 
13c0			.gendemword: 
13c0				ld de, .demoworddef 
13c0				ld hl, crs_s3 
13c0				call .genfile 
13c0				ret 
13c0			 
13c0			.genutlword: 
13c0				ld hl, crs_s4 
13c0				ld de, .utilwordef 
13c0				call .genfile 
13c0				ret 
13c0			.genspiword: 
13c0				ld hl, crs_s5 
13c0				ld de, .spiworddef 
13c0				call .genfile 
13c0				ret 
13c0			.genkeyword: 
13c0				ld hl, crs_s6 
13c0				ld de, .keyworddef 
13c0				call .genfile 
13c0				ret 
13c0			 
13c0			; hl - points to file name 
13c0			; de - points to strings to add to file 
13c0			 
13c0			.genfile: 
13c0				push hl 
13c0				push de 
13c0			 
13c0				call clear_display 
13c0				ld a, display_row_1 
13c0				ld de, .genfiletxt 
13c0				call str_at_display 
13c0				call update_display 
13c0			 
13c0				pop de 
13c0				pop hl 
13c0			 
13c0			 
13c0				push de 
13c0				call storage_create 
13c0				; id in hl 
13c0				pop de   ; table of strings to add 
13c0			 
13c0			.genloop: 
13c0			 
13c0				push hl ; save id for next time around 
13c0				push de ; save de for next time around 
13c0			 
13c0				ex de, hl 
13c0				call loadwordinhl 
13c0				ex de, hl 
13c0			 
13c0				; need hl to be the id 
13c0				; need de to be the string ptr 
13c0				 
13c0				call storage_append 
13c0			 
13c0				pop de 
13c0				pop hl 
13c0			 
13c0				inc de 
13c0				inc de 
13c0			 
13c0				ld a,(de) 
13c0				cp 0 
13c0				jr nz, .genloop 
13c0				inc de 
13c0				ld a, (de) 
13c0				dec de 
13c0				cp 0 
13c0				jr nz, .genloop	 
13c0			 
13c0				ret 
13c0			 
13c0			.genfiletxt:  db "Creating file...",0 
13c0			 
13c0			.hwworddef: 
13c0				dw test5 
13c0				dw test6 
13c0				dw test7 
13c0				dw test8 
13c0				dw test9 
13c0				dw test10 
13c0				dw 0 
13c0			 
13c0			.soundworddef: 
13c0				dw sound1 
13c0				dw sound2 
13c0				dw sound3 
13c0				dw sound4 
13c0				dw sound5 
13c0				dw sound6 
13c0				dw sound7 
13c0				dw sound8 
13c0				dw sound9 
13c0				dw 0 
13c0			 
13c0			.utilwordef: 
13c0				dw strncpy 
13c0				dw type 
13c0				dw clrstack 
13c0				dw longread 
13c0				dw start1 
13c0				dw start2 
13c0			; duplicated 
13c0			;	dw start3b 
13c0			;	dw start3c 
13c0				dw list 
13c0				dw 0 
13c0			 
13c0			.lsworddef: 
13c0				dw start3b 
13c0				dw 0 
13c0			 
13c0			.edworddef: 
13c0				dw edit1 
13c0				dw edit2 
13c0				dw edit3 
13c0				dw 0 
13c0			 
13c0			.demoworddef: 
13c0				dw game1 
13c0				dw game1a 
13c0				dw game1b 
13c0				dw game1c 
13c0				dw game1d 
13c0				dw game1s 
13c0				dw game1t 
13c0				dw game1f 
13c0				dw game1z 
13c0				dw game1zz 
13c0				dw ssv2 
13c0				dw ssv3 
13c0				dw ssv4 
13c0				dw ssv5 
13c0				dw ssv1 
13c0				dw ssv1cpm	 
13c0			;	dw game2b 
13c0			;	dw game2bf 
13c0			;	dw game2mba 
13c0			;	dw game2mbas	 
13c0			;	dw game2mbht 
13c0			;	dw game2mbms 
13c0			;	dw game2mb 
13c0			;	dw game3w 
13c0			;	dw game3p 
13c0			;	dw game3sc 
13c0			;	dw game3vsi 
13c0			;	dw game3vs 
13c0				dw 0 
13c0			 
13c0			 
13c0			.spiworddef: 
13c0			 
13c0			    dw spi1 
13c0			    dw spi2 
13c0			    dw spi2b 
13c0			    dw spi3 
13c0			    dw spi4 
13c0			    dw spi5 
13c0			;    dw spi6 
13c0			;    dw spi7 
13c0			 
13c0			;    dw spi8 
13c0			;    dw spi9 
13c0			;    dw spi10 
13c0			    dw 0 
13c0			 
13c0			.keyworddef: 
13c0			 
13c0				dw keyup 
13c0				dw keydown 
13c0				dw keyleft 
13c0				dw keyright 
13c0				dw 	keyf1 
13c0				dw keyf2 
13c0				dw keyf3 
13c0				dw keyf4 
13c0				dw keyf5 
13c0				dw keyf6 
13c0				dw keyf7 
13c0				dw keyf8 
13c0				dw keyf9 
13c0				dw keyf10 
13c0				dw keyf11 
13c0				dw keyf12 
13c0				dw keytab 
13c0				dw keycr 
13c0				dw keyhome 
13c0				dw keyend 
13c0				dw keybs 
13c0				dw 0 
13c0			 
13c0			.crstart: 
13c0				dw crs_s1 
13c0				dw crs_s2 
13c0				dw crs_s3 
13c0				dw crs_s4 
13c0				dw crs_s5 
13c0				dw crs_s6 
13c0				dw crs_sound 
13c0				dw crs_hw 
13c0				dw 0 
13c0			 
13c0			endif 
13c0			 
13c0			 
13c0			if STORAGE_SE 
13c0			 
13c0			config_fdir: 
13c0				; using the scratch dir go through and release the memory allocated for each string 
13c0				 
13c0				ld hl, scratch 
13c0			.cfdir:	ld e,(hl) 
13c0				inc hl 
13c0				ld d,(hl) 
13c0				inc hl 
13c0			 
13c0				ex de, hl 
13c0				call ishlzero 
13c0				ret z     ; return on null pointer 
13c0				call free 
13c0				ex de, hl 
13c0				jr .cfdir 
13c0			 
13c0			 
13c0				ret 
13c0			 
13c0			 
13c0			config_dir: 
13c0			 
13c0				; for the config menus that need to build a directory of storage call this routine 
13c0				; it will construct a menu in scratch to pass to menu 
13c0			 
13c0				; open storage device 
13c0			 
13c0				; execute DIR to build a list of files and their ids into scratch in menu format 
13c0				; once the menu has finished then will need to call config_fdir to release the strings 
13c0				 
13c0				; c = number items 
13c0			 
13c0				 
13c0				call storage_get_block_0 
13c0			 
13c0				ld hl, store_page     ; get current id count 
13c0				ld b, (hl) 
13c0				ld c, 0    ; count of files   
13c0			 
13c0			 
13c0				ld hl, scratch 
13c0				ld (store_tmp2), hl    ; location to poke strings 
13c0			 
13c0				; check for empty drive 
13c0			 
13c0				ld a, 0 
13c0				cp b 
13c0				jp z, .dirdone 
13c0			 
13c0				 
13c0					if DEBUG_FORTH_WORDS 
13c0						DMARK "Cdc" 
13c0						CALLMONITOR 
13c0					endif 
13c0			 
13c0			 
13c0			.diritem:	 
13c0				push bc 
13c0				; for each of the current ids do a search for them and if found push to stack 
13c0			 
13c0					ld hl, STORE_BLOCK_PHY 
13c0					ld d, 0		 ; look for extent 0 of block id as this contains file name 
13c0					ld e,b 
13c0			 
13c0					call storage_findnextid 
13c0			 
13c0			 
13c0					; if found hl will be non zero 
13c0			 
13c0					call ishlzero 
13c0					jr z, .dirnotfound 
13c0			 
13c0					; increase count 
13c0			 
13c0					pop bc	 
13c0					inc c 
13c0					push bc 
13c0					 
13c0			 
13c0					; get file header and push the file name 
13c0			 
13c0					ld de, store_page 
13c0					call storage_read_block 
13c0			 
13c0					; push file id to stack 
13c0				 
13c0					ld a, (store_page) 
13c0					ld h, 0 
13c0					ld l, a 
13c0			 
13c0					;call forth_push_numhl 
13c0					; TODO store id 
13c0			 
13c0					push hl 
13c0			 
13c0					; push extent count to stack  
13c0				 
13c0					ld hl, store_page+3 
13c0			 
13c0					; get file name length 
13c0			 
13c0					call strlenz   
13c0			 
13c0					inc hl   ; cover zero term 
13c0					inc hl  ; stick the id at the end of the area 
13c0			 
13c0					push hl 
13c0					pop bc    ; move length to bc 
13c0			 
13c0					call malloc 
13c0			 
13c0					; TODO save malloc area to scratch 
13c0			 
13c0					ex de, hl 
13c0					ld hl, (store_tmp2) 
13c0					ld (hl), e 
13c0					inc hl 
13c0					ld (hl), d 
13c0					inc hl 
13c0					ld (store_tmp2), hl 
13c0			 
13c0					 
13c0			 
13c0					;pop hl   ; get source 
13c0			;		ex de, hl    ; swap aronund	 
13c0			 
13c0					ld hl, store_page+3 
13c0					if DEBUG_FORTH_WORDS 
13c0						DMARK "CFd" 
13c0						CALLMONITOR 
13c0					endif 
13c0					ldir 
13c0			 
13c0					; de is past string, move back one and store id 
13c0					 
13c0					dec de 
13c0			 
13c0					; store file id 
13c0			 
13c0					pop hl 
13c0					ex de,hl 
13c0					ld (hl), e 
13c0			 
13c0					if DEBUG_FORTH_WORDS 
13c0						DMARK "Cdi" 
13c0						CALLMONITOR 
13c0					endif 
13c0					 
13c0			.dirnotfound: 
13c0					pop bc     
13c0					djnz .diritem 
13c0				 
13c0			.dirdone:	 
13c0			 
13c0					ld a, 0 
13c0					ld hl, (store_tmp2) 
13c0					ld (hl), a 
13c0					inc hl 
13c0					ld (hl), a 
13c0					inc hl 
13c0					; push a count of the dir items found 
13c0			 
13c0			;		ld h, 0 
13c0			;		ld l, c 
13c0			 
13c0				ret 
13c0			 
13c0			endif 
13c0			 
13c0			 
13c0			; Settings 
13c0			; Run  
13c0			 
13c0			 
13c0			 
13c0			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
13c0			;;hd_menu2:   db "        2: Editor",0   
13c0			;hd_menu2:   db "        2: Editor       6: Menu",0   
13c0			;hd_menu3:   db "        3: Storage",0 
13c0			;hd_menu4:   db "0=quit  4: Debug",0 
13c0			;hd_don:     db "ON",0 
13c0			;hd_doff:     db "OFF",0 
13c0			; 
13c0			; 
13c0			; 
13c0			;hardware_diags_old:       
13c0			; 
13c0			;.diagmenu: 
13c0			;	call clear_display 
13c0			;	ld a, display_row_1 
13c0			;	ld de, hd_menu1 
13c0			;	call str_at_display 
13c0			; 
13c0			;	ld a, display_row_2 
13c0			;	ld de, hd_menu2 
13c0			;	call str_at_display 
13c0			; 
13c0			;	ld a, display_row_3 
13c0			;	ld de, hd_menu3 
13c0			;	call str_at_display 
13c0			; 
13c0			;	ld a,  display_row_4 
13c0			;	ld de, hd_menu4 
13c0			;	call str_at_display 
13c0			; 
13c0			;	; display debug state 
13c0			; 
13c0			;	ld de, hd_don 
13c0			;	ld a, (os_view_disable) 
13c0			;	cp 0 
13c0			;	jr z, .distog 
13c0			;	ld de, hd_doff 
13c0			;.distog: ld a, display_row_4+17 
13c0			;	call str_at_display 
13c0			; 
13c0			;	call update_display 
13c0			; 
13c0			;	call cin_wait 
13c0			; 
13c0			; 
13c0			; 
13c0			;	cp '4' 
13c0			;	jr nz, .diagn1 
13c0			; 
13c0			;	; debug toggle 
13c0			; 
13c0			;	ld a, (os_view_disable) 
13c0			;	ld b, '*' 
13c0			;	cp 0 
13c0			;	jr z, .debtog 
13c0			;	ld b, 0 
13c0			;.debtog:	 
13c0			;	ld a,b 
13c0			;	ld (os_view_disable),a 
13c0			; 
13c0			;.diagn1: cp '0' 
13c0			;	 ret z 
13c0			; 
13c0			;;	cp '1' 
13c0			;;       jp z, matrix	 
13c0			;;   TODO keyboard matrix test 
13c0			; 
13c0			;	cp '2' 
13c0			;	jp z, .diagedit 
13c0			; 
13c0			;;	cp '6' 
13c0			;;	jp z, .menutest 
13c0			;;if ENABLE_BASIC 
13c0			;;	cp '6' 
13c0			;;	jp z, basic 
13c0			;;endif 
13c0			 ; 
13c0			;	jp .diagmenu 
13c0			; 
13c0			; 
13c0			;	ret 
13c0			 
13c0			 
13c0			.debug_tog: 
13c0 21 0a 14			ld hl, .menudebug 
13c3				 
13c3			;	ld a, (os_view_disable) 
13c3			;	cp '*' 
13c3 3a 6f ee			ld a,(debug_vector) 
13c6 fe c9			cp $C9   ; RET 
13c8 20 04			jr nz,.tdon  
13ca 3e 01			ld a, 1 
13cc 18 02			jr .tog1 
13ce 3e 00		.tdon: ld a, 0 
13d0			 
13d0			.tog1: 
13d0 cd f6 0b			call menu 
13d3 fe 00			cp 0 
13d5 c8				ret z 
13d6 fe 01			cp 1    ; disable debug 
13d8 28 04			jr z, .dtog0 
13da 3e 2a			ld a, '*' 
13dc 18 05			jr .dtogset 
13de			.dtog0:  
13de				;ld a, 0 
13de cd fc 14			call bp_on 
13e1 18 dd			jr .debug_tog 
13e3			.dtogset:  
13e3				; ld (os_view_disable), a 
13e3 cd 08 15			call bp_off 
13e6 c3 c0 13			jp .debug_tog 
13e9			 
13e9			 
13e9			hardware_diags:       
13e9			 
13e9			.diagm: 
13e9 21 fc 13			ld hl, .menuitems 
13ec 3e 00			ld a, 0 
13ee cd f6 0b			call menu 
13f1			 
13f1 fe 00		         cp 0 
13f3 c8				 ret z 
13f4			 
13f4 fe 02			cp 2 
13f6 ca 55 14			jp z, .diagedit 
13f9			 
13f9			;	cp '6' 
13f9			;	jp z, .menutest 
13f9			;if ENABLE_BASIC 
13f9			;	cp '6' 
13f9			;	jp z, basic 
13f9			;endif 
13f9			  
13f9 c3 e9 13			jp .diagm 
13fc			 
13fc				 
13fc 10 14		.menuitems:   	dw .m1 
13fe 1b 14				dw .m2 
1400 22 14				dw .m3 
1402 2a 14				dw .m5 
1404 30 14				dw .m5a 
1406 39 14				dw .m5b 
1408 00 00				dw 0 
140a			 
140a			.menudebug: 
140a 42 14				dw .m6 
140c 4b 14				dw .m7 
140e 00 00				dw 0 
1410			 
1410 .. 00		.m1:   db "Key Matrix",0 
141b .. 00		.m2:   db "Editor",0 
1422 .. 00		.m3:   db "Storage",0 
142a .. 00		.m5:   db "Sound",0 
1430 .. 00		.m5a:  db "RAM Test",0 
1439 .. 00		.m5b:  db "LCD Test",0 
1442			 
1442 .. 00		.m6:   db "Debug ON",0 
144b .. 00		.m7:   db "Debug OFF",0 
1455			 
1455			; debug editor 
1455			 
1455			.diagedit: 
1455			 
1455 21 c1 e2			ld hl, scratch 
1458			;	ld bc, 250 
1458			;	ldir 
1458				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1458 3e 00			ld a, 0 
145a 77				ld (hl), a 
145b 23				inc hl 
145c 77				ld (hl), a 
145d 23				inc hl 
145e 77				ld (hl), a 
145f			 
145f cd c5 0b		        call clear_display 
1462 cd e8 0b			call update_display 
1465				;ld a, 1 
1465				;ld (hardware_diag), a 
1465			.diloop: 
1465 3e 00			ld a, display_row_1 
1467 0e 00			ld c, 0 
1469 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
146b 1e 28			ld e, 40 
146d			 
146d 21 c1 e2			ld hl, scratch	 
1470 cd 1f 0e			call input_str 
1473			 
1473 3e 28			ld a, display_row_2 
1475 11 c1 e2			ld de, scratch 
1478 cd d8 0b			call str_at_display 
147b cd e8 0b			call update_display 
147e			 
147e c3 65 14			jp .diloop 
1481			 
1481			 
1481			; pass word in hl 
1481			; a has display location 
1481			display_word_at: 
1481 f5				push af 
1482 e5				push hl 
1483 7c				ld a,h 
1484 21 c6 e5			ld hl, os_word_scratch 
1487 cd fb 0f			call hexout 
148a e1				pop hl 
148b 7d				ld a,l 
148c 21 c8 e5			ld hl, os_word_scratch+2 
148f cd fb 0f			call hexout 
1492 21 ca e5			ld hl, os_word_scratch+4 
1495 3e 00			ld a,0 
1497 77				ld (hl),a 
1498 11 c6 e5			ld de,os_word_scratch 
149b f1				pop af 
149c cd d8 0b				call str_at_display 
149f c9				ret 
14a0			 
14a0			display_ptr_state: 
14a0			 
14a0				; to restore afterwards 
14a0			 
14a0 d5				push de 
14a1 c5				push bc 
14a2 e5				push hl 
14a3 f5				push af 
14a4			 
14a4				; for use in here 
14a4			 
14a4			;	push bc 
14a4			;	push de 
14a4			;	push hl 
14a4			;	push af 
14a4			 
14a4 cd c5 0b			call clear_display 
14a7			 
14a7 11 7f 16			ld de, .ptrstate 
14aa 3e 00			ld a, display_row_1 
14ac cd d8 0b			call str_at_display 
14af			 
14af				; display debug step 
14af			 
14af			 
14af 11 6b ee			ld de, debug_mark 
14b2 3e 26			ld a, display_row_1+display_cols-2 
14b4 cd d8 0b			call str_at_display 
14b7			 
14b7				; display a 
14b7 11 89 16			ld de, .ptrcliptr 
14ba 3e 28			ld a, display_row_2 
14bc cd d8 0b			call str_at_display 
14bf			 
14bf f1				pop af 
14c0 2a 40 ea			ld hl,(cli_ptr) 
14c3 3e 30			ld a, display_row_2+8 
14c5 cd 81 14			call display_word_at 
14c8			 
14c8			 
14c8				; display hl 
14c8			 
14c8			 
14c8 11 91 16			ld de, .ptrclioptr 
14cb 3e 32			ld a, display_row_2+10 
14cd cd d8 0b			call str_at_display 
14d0			; 
14d0			;	pop hl 
14d0 3e 35			ld a, display_row_2+13 
14d2 2a 3e ea			ld hl,(cli_origptr) 
14d5 cd 81 14			call display_word_at 
14d8			; 
14d8			;	 
14d8			;	; display de 
14d8			 
14d8			;	ld de, .regstatede 
14d8			;	ld a, display_row_3 
14d8			;	call str_at_display 
14d8			 
14d8			;	pop de 
14d8			;	ld h,d 
14d8			;	ld l, e 
14d8			;	ld a, display_row_3+3 
14d8			;	call display_word_at 
14d8			 
14d8			 
14d8				; display bc 
14d8			 
14d8			;	ld de, .regstatebc 
14d8			;	ld a, display_row_3+10 
14d8			;	call str_at_display 
14d8			 
14d8			;	pop bc 
14d8			;	ld h,b 
14d8			;	ld l, c 
14d8			;	ld a, display_row_3+13 
14d8			;	call display_word_at 
14d8			 
14d8			 
14d8				; display dsp 
14d8			 
14d8			;	ld de, .regstatedsp 
14d8			;	ld a, display_row_4 
14d8			;	call str_at_display 
14d8			 
14d8				 
14d8			;	ld hl,(cli_data_sp) 
14d8			;	ld a, display_row_4+4 
14d8			;	call display_word_at 
14d8			 
14d8				; display rsp 
14d8			 
14d8 11 c0 16			ld de, .regstatersp 
14db 3e 82			ld a, display_row_4+10 
14dd cd d8 0b			call str_at_display 
14e0			 
14e0				 
14e0 2a f2 e9			ld hl,(cli_ret_sp) 
14e3 3e 86			ld a, display_row_4+14 
14e5 cd 81 14			call display_word_at 
14e8			 
14e8 cd e8 0b			call update_display 
14eb			 
14eb cd fd 0a			call delay1s 
14ee cd fd 0a			call delay1s 
14f1 cd fd 0a			call delay1s 
14f4			 
14f4			 
14f4 cd f1 1a			call next_page_prompt 
14f7			 
14f7				; restore  
14f7			 
14f7 f1				pop af 
14f8 e1				pop hl 
14f9 c1				pop bc 
14fa d1				pop de 
14fb c9				ret 
14fc			 
14fc			; Update the break point vector so that the user can hook a new routine 
14fc			 
14fc			bp_on: 
14fc 3e c3			ld a, $c3    ; JP 
14fe 32 6f ee			ld (debug_vector), a 
1501 21 0e 15			ld hl, break_point_state 
1504 22 70 ee			ld (debug_vector+1), hl 
1507 c9				ret 
1508			 
1508			bp_off: 
1508 3e c9			ld a, $c9    ; RET 
150a 32 6f ee			ld (debug_vector), a 
150d c9				ret 
150e			 
150e			 
150e			break_point_state: 
150e			;	push af 
150e			; 
150e			;	; see if disabled 
150e			; 
150e			;	ld a, (os_view_disable) 
150e			;	cp '*' 
150e			;	jr nz, .bpsgo 
150e			;	pop af 
150e			;	ret 
150e			 
150e			.bpsgo: 
150e			;	pop af 
150e f5				push af 
150f 22 a3 e2			ld (os_view_hl), hl 
1512 ed 53 a1 e2		ld (os_view_de), de 
1516 ed 43 9f e2		ld (os_view_bc), bc 
151a e5				push hl 
151b 6f				ld l, a 
151c 26 00			ld h, 0 
151e 22 a5 e2			ld (os_view_af),hl 
1521			 
1521 21 b1 ed				ld hl, display_fb0 
1524 22 cc eb				ld (display_fb_active), hl 
1527 e1				pop hl	 
1528			 
1528 3e 31			ld a, '1' 
152a fe 2a		.bps1:  cp '*' 
152c cc 08 15			call z, bp_off 
152f			;	jr nz, .bps1b 
152f			;	ld (os_view_disable),a 
152f fe 31		.bps1b:  cp '1' 
1531 20 14			jr nz, .bps2 
1533			 
1533				; display reg 
1533			 
1533				 
1533			 
1533 3a a5 e2			ld a, (os_view_af) 
1536 2a a3 e2			ld hl, (os_view_hl) 
1539 ed 5b a1 e2		ld de, (os_view_de) 
153d ed 4b 9f e2		ld bc, (os_view_bc) 
1541 cd db 15			call display_reg_state 
1544 c3 c7 15			jp .bpschk 
1547			 
1547 fe 32		.bps2:  cp '2' 
1549 20 08			jr nz, .bps3 
154b				 
154b				; display hl 
154b 2a a3 e2			ld hl, (os_view_hl) 
154e cd c5 16			call display_dump_at_hl 
1551			 
1551 18 74			jr .bpschk 
1553			 
1553 fe 33		.bps3:  cp '3' 
1555 20 08			jr nz, .bps4 
1557			 
1557			        ; display de 
1557 2a a1 e2			ld hl, (os_view_de) 
155a cd c5 16			call display_dump_at_hl 
155d			 
155d 18 68			jr .bpschk 
155f fe 34		.bps4:  cp '4' 
1561 20 08			jr nz, .bps5 
1563			 
1563			        ; display bc 
1563 2a 9f e2			ld hl, (os_view_bc) 
1566 cd c5 16			call display_dump_at_hl 
1569			 
1569 18 5c			jr .bpschk 
156b fe 35		.bps5:  cp '5' 
156d 20 08		        jr nz, .bps7 
156f			 
156f				; display cur ptr 
156f 2a 40 ea			ld hl, (cli_ptr) 
1572 cd c5 16			call display_dump_at_hl 
1575			 
1575 18 50			jr .bpschk 
1577 fe 36		.bps7:  cp '6' 
1579 20 08			jr nz, .bps8b 
157b				 
157b				; display cur orig ptr 
157b 2a 3e ea			ld hl, (cli_origptr) 
157e cd c5 16			call display_dump_at_hl 
1581 18 44			jr .bpschk 
1583 fe 37		.bps8b:  cp '7' 
1585 20 08			jr nz, .bps9 
1587				 
1587				; display dsp 
1587 2a ee e9			ld hl, (cli_data_sp) 
158a cd c5 16			call display_dump_at_hl 
158d			 
158d 18 38			jr .bpschk 
158f fe 39		.bps9:  cp '9' 
1591 20 05			jr nz, .bps8c 
1593				 
1593				; display SP 
1593			;	ld hl, sp 
1593 cd c5 16			call display_dump_at_hl 
1596			 
1596 18 2f			jr .bpschk 
1598 fe 38		.bps8c:  cp '8' 
159a 20 08			jr nz, .bps8d 
159c				 
159c				; display rsp 
159c 2a f2 e9			ld hl, (cli_ret_sp) 
159f cd c5 16			call display_dump_at_hl 
15a2			 
15a2 18 23			jr .bpschk 
15a4 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
15a6 20 05			jr nz, .bps8 
15a8 cd bf 18			call monitor 
15ab			 
15ab 18 1a			jr .bpschk 
15ad fe 30		.bps8:  cp '0' 
15af 20 16			jr nz, .bpschk 
15b1			 
15b1 21 10 ed				ld hl, display_fb1 
15b4 22 cc eb				ld (display_fb_active), hl 
15b7 cd e8 0b				call update_display 
15ba			 
15ba				;ld a, (os_view_af) 
15ba 2a a3 e2			ld hl, (os_view_hl) 
15bd ed 5b a1 e2		ld de, (os_view_de) 
15c1 ed 4b 9f e2		ld bc, (os_view_bc) 
15c5 f1				pop af 
15c6 c9				ret 
15c7			 
15c7			.bpschk:   
15c7 cd fd 0a			call delay1s 
15ca 3e 9f		ld a,display_row_4 + display_cols - 1 
15cc 11 ef 1a		        ld de, endprg 
15cf cd d8 0b			call str_at_display 
15d2 cd e8 0b			call update_display 
15d5 cd 68 5e			call cin_wait 
15d8			 
15d8 c3 2a 15			jp .bps1 
15db			 
15db			 
15db			display_reg_state: 
15db			 
15db				; to restore afterwards 
15db			 
15db d5				push de 
15dc c5				push bc 
15dd e5				push hl 
15de f5				push af 
15df			 
15df				; for use in here 
15df			 
15df c5				push bc 
15e0 d5				push de 
15e1 e5				push hl 
15e2 f5				push af 
15e3			 
15e3 cd c5 0b			call clear_display 
15e6			 
15e6 11 9b 16			ld de, .regstate 
15e9 3e 00			ld a, display_row_1 
15eb cd d8 0b			call str_at_display 
15ee			 
15ee				; display debug step 
15ee			 
15ee			 
15ee 11 6b ee			ld de, debug_mark 
15f1 3e 25			ld a, display_row_1+display_cols-3 
15f3 cd d8 0b			call str_at_display 
15f6			 
15f6				; display a 
15f6 11 b7 16			ld de, .regstatea 
15f9 3e 28			ld a, display_row_2 
15fb cd d8 0b			call str_at_display 
15fe			 
15fe e1				pop hl 
15ff			;	ld h,0 
15ff			;	ld l, a 
15ff 3e 2b			ld a, display_row_2+3 
1601 cd 81 14			call display_word_at 
1604			 
1604			 
1604				; display hl 
1604			 
1604			 
1604 11 ab 16			ld de, .regstatehl 
1607 3e 32			ld a, display_row_2+10 
1609 cd d8 0b			call str_at_display 
160c			 
160c e1				pop hl 
160d 3e 35			ld a, display_row_2+13 
160f cd 81 14			call display_word_at 
1612			 
1612				 
1612				; display de 
1612			 
1612 11 af 16			ld de, .regstatede 
1615 3e 50			ld a, display_row_3 
1617 cd d8 0b			call str_at_display 
161a			 
161a e1				pop hl 
161b			;	ld h,d 
161b			;	ld l, e 
161b 3e 53			ld a, display_row_3+3 
161d cd 81 14			call display_word_at 
1620			 
1620			 
1620				; display bc 
1620			 
1620 11 b3 16			ld de, .regstatebc 
1623 3e 5a			ld a, display_row_3+10 
1625 cd d8 0b			call str_at_display 
1628			 
1628 e1				pop hl 
1629			;	ld h,b 
1629			;	ld l, c 
1629 3e 5d			ld a, display_row_3+13 
162b cd 81 14			call display_word_at 
162e			 
162e			 
162e				; display dsp 
162e			 
162e 11 bb 16			ld de, .regstatedsp 
1631 3e 78			ld a, display_row_4 
1633 cd d8 0b			call str_at_display 
1636			 
1636				 
1636 2a ee e9			ld hl,(cli_data_sp) 
1639 3e 7c			ld a, display_row_4+4 
163b cd 81 14			call display_word_at 
163e			 
163e				; display rsp 
163e			 
163e 11 c0 16			ld de, .regstatersp 
1641 3e 82			ld a, display_row_4+10 
1643 cd d8 0b			call str_at_display 
1646			 
1646				 
1646 2a f2 e9			ld hl,(cli_ret_sp) 
1649 3e 86			ld a, display_row_4+14 
164b cd 81 14			call display_word_at 
164e			 
164e cd e8 0b			call update_display 
1651			 
1651			;	call delay1s 
1651			;	call delay1s 
1651			;	call delay1s 
1651			 
1651			 
1651			;	call next_page_prompt 
1651			 
1651				; restore  
1651			 
1651 f1				pop af 
1652 e1				pop hl 
1653 c1				pop bc 
1654 d1				pop de 
1655 c9				ret 
1656			 
1656 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
166a .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
167f .. 00		.ptrstate:	db "Ptr State",0 
1689 .. 00		.ptrcliptr:     db "cli_ptr",0 
1691 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
169b .. 00		.regstate:	db "Reg State (1/0)",0 
16ab .. 00		.regstatehl:	db "HL:",0 
16af .. 00		.regstatede:	db "DE:",0 
16b3 .. 00		.regstatebc:	db "BC:",0 
16b7 .. 00		.regstatea:	db "A :",0 
16bb .. 00		.regstatedsp:	db "DSP:",0 
16c0 .. 00		.regstatersp:	db "RSP:",0 
16c5			 
16c5			display_dump_at_hl: 
16c5 e5				push hl 
16c6 d5				push de 
16c7 c5				push bc 
16c8 f5				push af 
16c9			 
16c9 22 e4 e5			ld (os_cur_ptr),hl	 
16cc cd c5 0b			call clear_display 
16cf cd f9 19			call dumpcont 
16d2			;	call delay1s 
16d2			;	call next_page_prompt 
16d2			 
16d2			 
16d2 f1				pop af 
16d3 c1				pop bc 
16d4 d1				pop de 
16d5 e1				pop hl 
16d6 c9				ret 
16d7			 
16d7			;if ENABLE_BASIC 
16d7			;	include "nascombasic.asm" 
16d7			;	basic: 
16d7			;	include "forth/FORTH.ASM" 
16d7			;endif 
16d7			 
16d7			; eof 
16d7			 
16d7			 
# End of file firmware_diags.asm
16d7			  
16d7			include "firmware_prompts.asm"  
16d7			; Prompts  
16d7			 
16d7			; boot messages 
16d7			 
16d7 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
16ec .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
16fc			 
16fc			 
16fc			; config menus 
16fc			 
16fc			;prom_c3: db "Add Dictionary To File",0 
16fc			 
16fc			if STARTUP_V1 
16fc .. 00		prom_c2: db "Select Autoload File",0 
1711 .. 00		prom_c2a: db "Disable Autoload File", 0 
1727			endif 
1727			 
1727			if STARTUP_V2 
1727			prom_c2: db "Enable Autoload Files",0 
1727			prom_c2a: db "Disable Autoload Files", 0 
1727			 
1727			crs_s1: db "*ls-word", 0 
1727			crs_s2: db "*ed-word", 0 
1727			crs_s3: db "*Demo-Games", 0 
1727			crs_s4: db "*Utils", 0 
1727			crs_s5: db "*SPI-Util", 0 
1727			crs_s6: db "*Key-Constants", 0 
1727			crs_sound: db "*Sound-Util", 0 
1727			crs_hw: db "*Hello-World",0 
1727			 
1727			 
1727			 
1727			endif 
1727			;prom_c2b: db "Select Storage Bank",0 
1727 .. 00		prom_c4: db "Settings",0 
1730 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
174b .. 00		prom_m4b:   db "Monitor",0 
1753 .. 00		prom_c1: db "Hardware Diags",0 
1762			 
1762			 
1762			if STARTUP_V2 
1762			prom_c9: db "Create Startup Files",0 
1762			endif 
1762			 
1762 .. 00		prom_notav:    db "Feature not available",0 
1778 .. 00		prom_empty:    db "",0 
1779			 
1779			; eof 
1779			 
# End of file firmware_prompts.asm
1779			  
1779			  
1779			; eof  
1779			  
# End of file firmware.asm
1779			 
1779			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1779			;if BASE_KEV  
1779			;baseram: equ 08000h 
1779			;endif 
1779			 
1779			;if BASE_SC114 
1779			;baseram:     equ    endofcode 
1779			;endif 
1779			 
1779			 
1779			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1779			 
1779			; start system 
1779			 
1779			coldstart: 
1779				; set sp 
1779				; di/ei 
1779			 
1779 f3				di 
177a 31 00 f0			ld sp, tos 
177d cd 66 5d			call init_nmi 
1780			;	ei 
1780			 
1780				; init spinner 
1780 3e 00			ld a,0 
1782 32 c6 eb			ld (display_active), a 
1785			 
1785				; disable breakpoint by default 
1785			 
1785				;ld a,'*' 
1785			;	ld a,' ' 
1785			;	ld (os_view_disable),a 
1785			 
1785				; set break point vector as new break point on or off 
1785 cd 08 15			call bp_off 
1788			 
1788				; init hardware 
1788			 
1788				; init keyboard and screen hardware 
1788			 
1788 cd 1f 01			call hardware_init 
178b			 
178b			 
178b cd fd 0a			call delay1s 
178e 3e 58			ld a, display_row_3+8 
1790 11 03 01			ld de, buildtime 
1793 cd d8 0b			call str_at_display 
1796 cd e8 0b			call update_display 
1799			 
1799 cd fd 0a			call delay1s 
179c cd fd 0a			call delay1s 
179f cd fd 0a			call delay1s 
17a2			 
17a2				; detect if any keys are held down to enable breakpoints at start up 
17a2			 
17a2 cd 70 5e			call cin  
17a5 fe 00			cp 0 
17a7 28 03			jr z, .nokeys 
17a9			 
17a9				;call hardware_diags 
17a9 cd 66 13			call config 
17ac			 
17ac			;	ld de, .bpen 
17ac			;	ld a, display_row_4 
17ac			;	call str_at_display 
17ac			;	call update_display 
17ac			; 
17ac			;	ld a,0 
17ac			;	ld (os_view_disable),a 
17ac			; 
17ac			;.bpwait: 
17ac			;	call cin 
17ac			;	cp 0 
17ac			;	jr z, .bpwait 
17ac			;	jr .nokeys 
17ac			; 
17ac			; 
17ac			;.bpen:  db "Break points enabled!",0 
17ac			 
17ac			 
17ac			 
17ac			 
17ac			 
17ac			 
17ac			.nokeys: 
17ac			 
17ac			 
17ac				 
17ac			 
17ac			;jp  testkey 
17ac			 
17ac			;call storage_get_block_0 
17ac			; 
17ac			;ld hl, 0 
17ac			;ld de, store_page 
17ac			;call storage_read_block 
17ac			 
17ac				 
17ac			;ld hl, 10 
17ac			;ld de, store_page 
17ac			;call storage_read_block 
17ac			 
17ac			 
17ac			 
17ac			 
17ac			 
17ac			;stop:	nop 
17ac			;	jp stop 
17ac			 
17ac			 
17ac			 
17ac			main: 
17ac cd c5 0b			call clear_display 
17af cd e8 0b			call update_display 
17b2			 
17b2			 
17b2			 
17b2			;	call testlcd 
17b2			 
17b2			 
17b2			 
17b2 cd 04 1f			call forth_init 
17b5			 
17b5			 
17b5			warmstart: 
17b5 cd da 1e			call forth_warmstart 
17b8			 
17b8				; run startup word load 
17b8			        ; TODO prevent this running at warmstart after crash  
17b8			 
17b8				if STARTUP_ENABLE 
17b8			 
17b8					if STARTUP_V1 
17b8			 
17b8						if STORAGE_SE 
17b8							call forth_autoload 
17b8						endif 
17b8 cd b6 5c					call forth_startup 
17bb					endif 
17bb			 
17bb					if STARTUP_V2 
17bb			 
17bb						if STORAGE_SE 
17bb							call forth_autoload 
17bb						else 
17bb							call forth_startup 
17bb						endif 
17bb			 
17bb			 
17bb					endif 
17bb			 
17bb				endif 
17bb			 
17bb			warmstart_afterauto: 
17bb			 
17bb				; show free memory after boot 
17bb 11 5a 18			ld de, freeram 
17be 3e 00			ld a, display_row_1 
17c0 cd d8 0b			call str_at_display 
17c3			 
17c3				; get current heap start after loading any uwords 
17c3			 
17c3				;ld de, (os_last_new_uword) 
17c3				;ex de, hl 
17c3			 
17c3			; Or use heap_size word???? 
17c3				;ld hl, heap_end 
17c3				;ld hl, heap_size 
17c3				;ld de, topusermem 
17c3				;ld de, heap_start 
17c3 ed 5b 93 5e			ld de, (free_list )      
17c7 21 9c e2				ld hl, heap_end 
17ca ed 52			sbc hl, de 
17cc				;push hl 
17cc				;ld a,h	         	 
17cc				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
17cc				;call hexout 
17cc			   	;pop hl 
17cc			; 
17cc			;	ld a,l 
17cc			;	ld hl, os_word_scratch+2 
17cc			;	call hexout 
17cc			;	ld hl, os_word_scratch+4 
17cc			;	ld a, 0 
17cc			;	ld (hl),a 
17cc eb				ex de, hl 
17cd 21 c6 e5			ld hl, os_word_scratch 
17d0 cd 07 11			call uitoa_16 
17d3			 
17d3			 
17d3 11 c6 e5			ld de, os_word_scratch 
17d6 3e 0d			ld a, display_row_1 + 13 
17d8 cd d8 0b			call str_at_display 
17db cd e8 0b			call update_display 
17de			 
17de			 
17de				;call demo 
17de			 
17de			 
17de				; init scratch input area for cli commands 
17de			 
17de 21 e8 e5			ld hl, os_cli_cmd 
17e1 3e 00			ld a,0 
17e3 77				ld (hl),a 
17e4 23				inc hl 
17e5 77				ld (hl),a 
17e6			 
17e6 3e 00			ld a,0 
17e8 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
17eb			 
17eb 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
17ee 32 e5 e5			ld (os_cur_ptr+1),a	 
17f1			 
17f1 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
17f4 32 c7 e5			ld (os_word_scratch+1),a	 
17f7				 
17f7			 
17f7				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17f7 21 e8 e5			ld hl, os_cli_cmd 
17fa			 
17fa 3e 00			ld a, 0		 ; init cli input 
17fc 77				ld (hl), a 
17fd 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17ff			cli: 
17ff				; show cli prompt 
17ff				;push af 
17ff				;ld a, 0 
17ff				;ld de, prompt 
17ff				;call str_at_display 
17ff			 
17ff				;call update_display 
17ff				;pop af 
17ff				;inc a 
17ff				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
17ff			 
17ff			.lastrecall: 
17ff			 
17ff 0e 00			ld c, 0 
1801 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1803 1e 28			ld e, 40 
1805			 
1805 21 e8 e5			ld hl, os_cli_cmd 
1808			 
1808				STACKFRAME OFF $fefe $9f9f 
1808				if DEBUG_STACK_IMB 
1808					if OFF 
1808						exx 
1808						ld de, $fefe 
1808						ld a, d 
1808						ld hl, curframe 
1808						call hexout 
1808						ld a, e 
1808						ld hl, curframe+2 
1808						call hexout 
1808						ld hl, $fefe 
1808						push hl 
1808						ld hl, $9f9f 
1808						push hl 
1808						exx 
1808					endif 
1808				endif 
1808			endm 
# End of macro STACKFRAME
1808			 
1808 cd 1f 0e			call input_str 
180b			 
180b				STACKFRAMECHK OFF $fefe $9f9f 
180b				if DEBUG_STACK_IMB 
180b					if OFF 
180b						exx 
180b						ld hl, $9f9f 
180b						pop de   ; $9f9f 
180b						call cmp16 
180b						jr nz, .spnosame 
180b						ld hl, $fefe 
180b						pop de   ; $fefe 
180b						call cmp16 
180b						jr z, .spfrsame 
180b						.spnosame: call showsperror 
180b						.spfrsame: nop 
180b						exx 
180b					endif 
180b				endif 
180b			endm 
# End of macro STACKFRAMECHK
180b			 
180b			 
180b				; check to see if last line recall has been requested 
180b			 
180b			if EDIT_V2 
180b fe 05			cp KEY_UP 
180d 20 0f			jr nz, .noexecline 
180f			 
180f 11 e8 e5			ld de, os_cli_cmd 
1812 21 e7 e6			ld hl, os_last_cmd 
1815 01 ff 00			ld bc, 255 
1818 ed b0			ldir 
181a 3e 00			ld a, 0 
181c 18 e1			jr .lastrecall 
181e			endif 
181e			 
181e			.noexecline: 
181e				; no so exec the line		 
181e			 
181e				; copy input to last command 
181e			 
181e 21 e8 e5			ld hl, os_cli_cmd 
1821 11 e7 e6			ld de, os_last_cmd 
1824 01 ff 00			ld bc, 255 
1827 ed b0			ldir 
1829			 
1829				; wipe current buffer 
1829			 
1829			;	ld a, 0 
1829			;	ld hl, os_cli_cmd 
1829			;	ld de, os_cli_cmd+1 
1829			;	ld bc, 254 
1829			;	ldir 
1829				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1829			;	call strcpy 
1829			;	ld a, 0 
1829			;	ld (hl), a 
1829			;	inc hl 
1829			;	ld (hl), a 
1829			;	inc hl 
1829			;	ld (hl), a 
1829			 
1829				; switch frame buffer to program  
1829			 
1829 21 10 ed				ld hl, display_fb1 
182c 22 cc eb				ld (display_fb_active), hl 
182f			 
182f			;	nop 
182f				STACKFRAME ON $fbfe $8f9f 
182f				if DEBUG_STACK_IMB 
182f					if ON 
182f						exx 
182f						ld de, $fbfe 
182f						ld a, d 
182f						ld hl, curframe 
182f						call hexout 
182f						ld a, e 
182f						ld hl, curframe+2 
182f						call hexout 
182f						ld hl, $fbfe 
182f						push hl 
182f						ld hl, $8f9f 
182f						push hl 
182f						exx 
182f					endif 
182f				endif 
182f			endm 
# End of macro STACKFRAME
182f				; first time into the parser so pass over the current scratch pad 
182f 21 e8 e5			ld hl,os_cli_cmd 
1832				; tokenise the entered statement(s) in HL 
1832 cd 82 1f			call forthparse 
1835			        ; exec forth statements in top of return stack 
1835 cd c2 1f			call forthexec 
1838				;call forthexec_cleanup 
1838			;	call parsenext 
1838			 
1838				STACKFRAMECHK ON $fbfe $8f9f 
1838				if DEBUG_STACK_IMB 
1838					if ON 
1838						exx 
1838						ld hl, $8f9f 
1838						pop de   ; $8f9f 
1838						call cmp16 
1838						jr nz, .spnosame 
1838						ld hl, $fbfe 
1838						pop de   ; $fbfe 
1838						call cmp16 
1838						jr z, .spfrsame 
1838						.spnosame: call showsperror 
1838						.spfrsame: nop 
1838						exx 
1838					endif 
1838				endif 
1838			endm 
# End of macro STACKFRAMECHK
1838				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1838			 
1838 3e 78			ld a, display_row_4 
183a 11 6b 18			ld de, endprog 
183d			 
183d cd e8 0b			call update_display		 
1840			 
1840 cd f1 1a			call next_page_prompt 
1843			 
1843				; switch frame buffer to cli 
1843			 
1843 21 b1 ed				ld hl, display_fb0 
1846 22 cc eb				ld (display_fb_active), hl 
1849			 
1849			 
1849 cd c5 0b		        call clear_display 
184c cd e8 0b			call update_display		 
184f			 
184f 21 e8 e5			ld hl, os_cli_cmd 
1852			 
1852 3e 00			ld a, 0		 ; init cli input 
1854 77				ld (hl), a 
1855			 
1855				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1855			 
1855				; now on last line 
1855			 
1855				; TODO scroll screen up 
1855			 
1855				; TODO instead just clear screen and place at top of screen 
1855			 
1855			;	ld a, 0 
1855			;	ld (f_cursor_ptr),a 
1855			 
1855				;call clear_display 
1855				;call update_display 
1855			 
1855				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1855 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1857 c3 ff 17			jp cli 
185a			 
185a .. 00		freeram: db "Free bytes: ",0 
1867 ..			asc: db "1A2F" 
186b .. 00		endprog: db "End prog...",0 
1877			 
1877			testenter2:   
1877 21 f3 e2			ld hl,scratch+50 
187a 22 e4 e5			ld (os_cur_ptr),hl 
187d c3 ff 17			jp cli 
1880			 
1880			testenter:  
1880			 
1880 21 67 18			ld hl,asc 
1883			;	ld a,(hl) 
1883			;	call nibble2val 
1883 cd 51 10			call get_byte 
1886			 
1886			 
1886			;	ld a,(hl) 
1886			;	call atohex 
1886			 
1886			;	call fourehexhl 
1886 32 f3 e2			ld (scratch+50),a 
1889			 
1889			 
1889			 
1889 21 69 18			ld hl,asc+2 
188c			;	ld a, (hl) 
188c			;	call nibble2val 
188c cd 51 10			call get_byte 
188f			 
188f			;	call fourehexhl 
188f 32 f5 e2			ld (scratch+52),a 
1892				 
1892 21 f3 e2			ld hl,scratch+50 
1895 22 e4 e5			ld (os_cur_ptr),hl 
1898 c3 ff 17			jp cli 
189b			 
189b			enter:	 
189b 3a c5 e2			ld a,(scratch+4) 
189e fe 00			cp 0 
18a0 28 0c			jr z, .entercont 
18a2				; no, not a null term line so has an address to work out.... 
18a2			 
18a2 21 c3 e2			ld hl,scratch+2 
18a5 cd b1 10			call get_word_hl 
18a8			 
18a8 22 e4 e5			ld (os_cur_ptr),hl	 
18ab c3 ff 17			jp cli 
18ae			 
18ae			 
18ae			.entercont:  
18ae			 
18ae 21 c3 e2			ld hl, scratch+2 
18b1 cd 51 10			call get_byte 
18b4			 
18b4 2a e4 e5		   	ld hl,(os_cur_ptr) 
18b7 77					ld (hl),a 
18b8 23					inc hl 
18b9 22 e4 e5				ld (os_cur_ptr),hl 
18bc				 
18bc			; get byte  
18bc			 
18bc			 
18bc c3 ff 17			jp cli 
18bf			 
18bf			 
18bf			; basic monitor support 
18bf			 
18bf			monitor: 
18bf				;  
18bf cd c5 0b			call clear_display 
18c2 3e 00			ld a, 0 
18c4 11 13 19			ld de, .monprompt 
18c7 cd d8 0b			call str_at_display 
18ca cd e8 0b			call update_display 
18cd			 
18cd				; get a monitor command 
18cd			 
18cd 0e 00			ld c, 0     ; entry at top left 
18cf 16 64			ld d, 100   ; max buffer size 
18d1 1e 0f			ld e, 15    ; input scroll area 
18d3 3e 00			ld a, 0     ; init string 
18d5 21 bf e4			ld hl, os_input 
18d8 77				ld (hl), a 
18d9 23				inc hl 
18da 77				ld (hl), a 
18db 21 bf e4			ld hl, os_input 
18de 3e 01			ld a, 1     ; init string 
18e0 cd 1f 0e			call input_str 
18e3			 
18e3 cd c5 0b		        call clear_display 
18e6 cd e8 0b			call update_display		 
18e9			 
18e9 3a bf e4			ld a, (os_input) 
18ec cd 4f 11			call toUpper 
18ef fe 48		        cp 'H' 
18f1 ca 78 19		        jp z, .monhelp 
18f4 fe 44			cp 'D'		; dump 
18f6 ca ab 19			jp z, .mondump	 
18f9 fe 43			cp 'C'		; dump 
18fb ca c5 19			jp z, .moncdump	 
18fe fe 4d			cp 'M'		; dump 
1900 ca 15 19			jp z, .moneditstart 
1903 fe 55			cp 'U'		; dump 
1905 ca 21 19			jp z, .monedit	 
1908 fe 47			cp 'G'		; dump 
190a ca a1 19			jp z, .monjump 
190d fe 51			cp 'Q'		; dump 
190f c8				ret z	 
1910			 
1910			 
1910				; TODO "S" to access symbol by name and not need the address 
1910				; TODO "F" to find a string in memory 
1910			 
1910 c3 bf 18			jp monitor 
1913			 
1913 .. 00		.monprompt: db ">", 0 
1915			 
1915			.moneditstart: 
1915				; get starting address 
1915			 
1915 21 c1 e4			ld hl,os_input+2 
1918 cd b1 10			call get_word_hl 
191b			 
191b 22 e4 e5			ld (os_cur_ptr),hl	 
191e			 
191e c3 bf 18			jp monitor 
1921			 
1921			.monedit: 
1921				; get byte to load 
1921			 
1921 21 c1 e4			ld hl,os_input+2 
1924 cd 51 10			call get_byte 
1927			 
1927				; get address to update 
1927 2a e4 e5			ld hl, (os_cur_ptr) 
192a			 
192a				; update byte 
192a			 
192a 77				ld (hl), a 
192b			 
192b				; move to next address and save it 
192b			 
192b 23				inc hl 
192c 22 e4 e5			ld (os_cur_ptr),hl	 
192f			 
192f c3 bf 18			jp monitor 
1932			 
1932			 
1932 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1946 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1962 .. 00		.monhelptext3:  db "G-Call address",0 
1971 .. 00		.monhelptext4:  db "Q-Quit",0 
1978			        
1978			.monhelp: 
1978 3e 00			ld a, display_row_1 
197a 11 32 19		        ld de, .monhelptext1 
197d			 
197d cd d8 0b			call str_at_display 
1980 3e 28			ld a, display_row_2 
1982 11 46 19		        ld de, .monhelptext2 
1985					 
1985 cd d8 0b			call str_at_display 
1988 3e 50			ld a, display_row_3 
198a 11 62 19		        ld de, .monhelptext3 
198d					 
198d cd d8 0b			call str_at_display 
1990 3e 78			ld a, display_row_4 
1992 11 71 19		        ld de, .monhelptext4 
1995 cd d8 0b			call str_at_display 
1998			 
1998 cd e8 0b			call update_display		 
199b			 
199b cd f1 1a			call next_page_prompt 
199e c3 bf 18			jp monitor 
19a1			 
19a1			.monjump:    
19a1 21 c1 e4			ld hl,os_input+2 
19a4 cd b1 10			call get_word_hl 
19a7			 
19a7 e9				jp (hl) 
19a8 c3 bf 18			jp monitor 
19ab			 
19ab			.mondump:    
19ab 21 c1 e4			ld hl,os_input+2 
19ae cd b1 10			call get_word_hl 
19b1			 
19b1 22 e4 e5			ld (os_cur_ptr),hl	 
19b4 cd f9 19			call dumpcont 
19b7 3e 78			ld a, display_row_4 
19b9 11 6b 18			ld de, endprog 
19bc			 
19bc cd e8 0b			call update_display		 
19bf			 
19bf cd f1 1a			call next_page_prompt 
19c2 c3 bf 18			jp monitor 
19c5			.moncdump: 
19c5 cd f9 19			call dumpcont 
19c8 3e 78			ld a, display_row_4 
19ca 11 6b 18			ld de, endprog 
19cd			 
19cd cd e8 0b			call update_display		 
19d0			 
19d0 cd f1 1a			call next_page_prompt 
19d3 c3 bf 18			jp monitor 
19d6			 
19d6			 
19d6			; TODO symbol access  
19d6			 
19d6			.symbols:     ;; A list of symbols that can be called up  
19d6 b1 ed			dw display_fb0 
19d8 .. 00			db "fb0",0  
19dc 7a ea		     	dw store_page 
19de .. 00			db "store_page",0 
19e9			 
19e9			 
19e9			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
19e9			 
19e9 3a c2 e2			ld a,(scratch+1) 
19ec fe 00			cp 0 
19ee 28 09			jr z, dumpcont 
19f0			 
19f0				; no, not a null term line so has an address to work out.... 
19f0			 
19f0 21 c3 e2			ld hl,scratch+2 
19f3 cd b1 10			call get_word_hl 
19f6			 
19f6 22 e4 e5			ld (os_cur_ptr),hl	 
19f9			 
19f9			 
19f9			 
19f9			dumpcont: 
19f9			 
19f9				; dump bytes at ptr 
19f9			 
19f9			 
19f9 3e 00			ld a, display_row_1 
19fb 2a cc eb			ld hl, (display_fb_active) 
19fe cd f2 0d			call addatohl 
1a01 cd 29 1a			call .dumpbyterow 
1a04			 
1a04 3e 28			ld a, display_row_2 
1a06 2a cc eb			ld hl, (display_fb_active) 
1a09 cd f2 0d			call addatohl 
1a0c cd 29 1a			call .dumpbyterow 
1a0f			 
1a0f			 
1a0f 3e 50			ld a, display_row_3 
1a11 2a cc eb			ld hl, (display_fb_active) 
1a14 cd f2 0d			call addatohl 
1a17 cd 29 1a			call .dumpbyterow 
1a1a			 
1a1a 3e 78			ld a, display_row_4 
1a1c 2a cc eb			ld hl, (display_fb_active) 
1a1f cd f2 0d			call addatohl 
1a22 cd 29 1a			call .dumpbyterow 
1a25			 
1a25 cd e8 0b			call update_display 
1a28			;		jp cli 
1a28 c9				ret 
1a29			 
1a29			.dumpbyterow: 
1a29			 
1a29				;push af 
1a29			 
1a29 e5				push hl 
1a2a			 
1a2a				; calc where to poke the ascii 
1a2a			if display_cols == 20 
1a2a				ld a, 16 
1a2a			else 
1a2a 3e 1f			ld a, 31 
1a2c			endif 
1a2c			 
1a2c cd f2 0d			call addatohl 
1a2f 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
1a32			 
1a32			 
1a32			; display decoding address 
1a32 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a35			 
1a35 7c				ld a,h 
1a36 e1				pop hl 
1a37 e5				push hl 
1a38			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1a38 cd fb 0f			call hexout 
1a3b 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a3e			 
1a3e 7d				ld a,l 
1a3f e1				pop hl 
1a40 23				inc hl 
1a41 23				inc hl 
1a42 e5				push hl 
1a43			;	ld hl, os_word_scratch+2 
1a43 cd fb 0f			call hexout 
1a46 e1				pop hl 
1a47 23				inc hl 
1a48 23				inc hl 
1a49				;ld hl, os_word_scratch+4 
1a49 3e 3a			ld a, ':' 
1a4b 77				ld (hl),a 
1a4c 23				inc hl 
1a4d				;ld a, 0 
1a4d				;ld (hl),a 
1a4d				;ld de, os_word_scratch 
1a4d				;pop af 
1a4d				;push af 
1a4d			;		ld a, display_row_2 
1a4d			;		call str_at_display 
1a4d			;		call update_display 
1a4d			 
1a4d			 
1a4d			;pop af 
1a4d			;	add 5 
1a4d			 
1a4d			if display_cols == 20 
1a4d				ld b, 4 
1a4d			else 
1a4d 06 08			ld b, 8 
1a4f			endif	 
1a4f			 
1a4f			.dumpbyte: 
1a4f c5				push bc 
1a50 e5				push hl 
1a51			 
1a51			 
1a51 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a54 7e					ld a,(hl) 
1a55			 
1a55					; poke the ascii to display 
1a55 2a c6 e5				ld hl,(os_word_scratch) 
1a58 77					ld (hl),a 
1a59 23					inc hl 
1a5a 22 c6 e5				ld (os_word_scratch),hl 
1a5d			 
1a5d					 
1a5d			 
1a5d			 
1a5d e1					pop hl 
1a5e e5					push hl 
1a5f			 
1a5f cd fb 0f				call hexout 
1a62			 
1a62					 
1a62 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a65 23				inc hl 
1a66 22 e4 e5		   	ld (os_cur_ptr),hl 
1a69			 
1a69 e1					pop hl 
1a6a 23					inc hl 
1a6b 23					inc hl 
1a6c 23					inc hl 
1a6d			 
1a6d			 
1a6d			 
1a6d					;ld a,0 
1a6d					;ld (os_word_scratch+2),a 
1a6d					;pop af 
1a6d					;push af 
1a6d			 
1a6d					;ld de, os_word_scratch 
1a6d					;call str_at_display 
1a6d			;		call update_display 
1a6d			;		pop af 
1a6d c1					pop bc 
1a6e c6 03				add 3 
1a70 10 dd			djnz .dumpbyte 
1a72			 
1a72				 
1a72			 
1a72 c9				ret 
1a73			 
1a73			jump:	 
1a73			 
1a73 21 c3 e2			ld hl,scratch+2 
1a76 cd b1 10			call get_word_hl 
1a79				;ld hl,(scratch+2) 
1a79				;call fourehexhl 
1a79			 
1a79 22 e4 e5			ld (os_cur_ptr),hl	 
1a7c			 
1a7c e9				jp (hl) 
1a7d			 
1a7d			 
1a7d			 
1a7d			; TODO implement a basic monitor mode to start with 
1a7d			 
1a7d			 
1a7d			 
1a7d			 
1a7d			 
1a7d			 
1a7d			 
1a7d			 
1a7d			 
1a7d			; testing and demo code during development 
1a7d			 
1a7d			 
1a7d .. 00		str1: db "Enter some text...",0 
1a90 .. 00		clear: db "                    ",0 
1aa5			 
1aa5			demo: 
1aa5			 
1aa5			 
1aa5			 
1aa5			;	call update_display 
1aa5			 
1aa5				; init scratch input area for testing 
1aa5 21 c1 e2			ld hl, scratch	 
1aa8 3e 00			ld a,0 
1aaa 77				ld (hl),a 
1aab			 
1aab			 
1aab 3e 28		            LD   A, display_row_2 
1aad			;            CALL fLCD_Pos       ;Position cursor to location in A 
1aad 11 7d 1a		            LD   DE, str1 
1ab0 cd d8 0b			call str_at_display 
1ab3			 
1ab3			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ab3			cloop:	 
1ab3 3e 50		            LD   A, display_row_3 
1ab5			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ab5 11 90 1a		            LD   DE, clear 
1ab8			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1ab8 cd d8 0b				call str_at_display 
1abb 3e 78			ld a, display_row_4 
1abd 11 ed 1a			ld de, prompt 
1ac0			 
1ac0 cd d8 0b				call str_at_display 
1ac3 cd e8 0b			call update_display 
1ac6			 
1ac6 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1ac8 16 0a			ld d, 10 
1aca 21 c1 e2			ld hl, scratch	 
1acd cd 1f 0e			call input_str 
1ad0			 
1ad0			;	call clear_display 
1ad0			;'	call update_display 
1ad0			 
1ad0 3e 00		            LD   A, display_row_1 
1ad2			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ad2 11 90 1a		            LD   DE, clear 
1ad5 cd d8 0b				call str_at_display 
1ad8			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ad8 3e 00		            LD   A, display_row_1 
1ada			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ada 11 c1 e2		            LD   DE, scratch 
1add			;            CALL fLCD_Str       ;Display string pointed to by DE 
1add cd d8 0b				call str_at_display 
1ae0 cd e8 0b			call update_display 
1ae3			 
1ae3 3e 00				ld a,0 
1ae5 21 c1 e2			ld hl, scratch 
1ae8 77				ld (hl),a 
1ae9			 
1ae9 00				nop 
1aea c3 b3 1a			jp cloop 
1aed			 
1aed			 
1aed			 
1aed			; OS Prompt 
1aed			 
1aed .. 00		prompt: db ">",0 
1aef .. 00		endprg: db "?",0 
1af1			 
1af1			 
1af1			; handy next page prompt 
1af1			next_page_prompt: 
1af1 e5				push hl 
1af2 d5				push de 
1af3 f5				push af 
1af4 c5				push bc 
1af5			 
1af5 3e 9f			ld a,display_row_4 + display_cols - 1 
1af7 11 ef 1a		        ld de, endprg 
1afa cd d8 0b			call str_at_display 
1afd cd e8 0b			call update_display 
1b00 cd 68 5e			call cin_wait 
1b03 c1				pop bc 
1b04 f1				pop af 
1b05 d1				pop de 
1b06 e1				pop hl 
1b07			 
1b07			 
1b07 c9				ret 
1b08			 
1b08			 
1b08			; forth parser 
1b08			 
1b08			; My forth kernel 
1b08			include "forth_kernel.asm" 
1b08			; 
1b08			; kernel to the forth OS 
1b08			 
1b08			DS_TYPE_STR: equ 1     ; string type 
1b08			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1b08			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1b08			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1b08			 
1b08			FORTH_PARSEV1: equ 0 
1b08			FORTH_PARSEV2: equ 0 
1b08			FORTH_PARSEV3: equ 0 
1b08			FORTH_PARSEV4: equ 0 
1b08			FORTH_PARSEV5: equ 1 
1b08			 
1b08			;if FORTH_PARSEV5 
1b08			;	FORTH_END_BUFFER: equ 0 
1b08			;else 
1b08			FORTH_END_BUFFER: equ 127 
1b08			;endif 
1b08			 
1b08			FORTH_TRUE: equ 1 
1b08			FORTH_FALSE: equ 0 
1b08			 
1b08			if FORTH_PARSEV4 
1b08			include "forth_stackops.asm" 
1b08			endif 
1b08			 
1b08			if FORTH_PARSEV5 
1b08			include "forth_stackopsv5.asm" 
1b08			 
1b08			; Stack operations for v5 parser on wards 
1b08			; * DATA stack 
1b08			; * LOOP stack 
1b08			; * RETURN stack 
1b08			 
1b08			 
1b08			 
1b08			FORTH_CHK_DSP_UNDER: macro 
1b08				push hl 
1b08				push de 
1b08				ld hl,(cli_data_sp) 
1b08				ld de, cli_data_stack 
1b08				call cmp16 
1b08				jp c, fault_dsp_under 
1b08				pop de 
1b08				pop hl 
1b08				endm 
1b08			 
1b08			 
1b08			FORTH_CHK_RSP_UNDER: macro 
1b08				push hl 
1b08				push de 
1b08				ld hl,(cli_ret_sp) 
1b08				ld de, cli_ret_stack 
1b08				call cmp16 
1b08				jp c, fault_rsp_under 
1b08				pop de 
1b08				pop hl 
1b08				endm 
1b08			 
1b08			FORTH_CHK_LOOP_UNDER: macro 
1b08				push hl 
1b08				push de 
1b08				ld hl,(cli_loop_sp) 
1b08				ld de, cli_loop_stack 
1b08				call cmp16 
1b08				jp c, fault_loop_under 
1b08				pop de 
1b08				pop hl 
1b08				endm 
1b08			 
1b08			FORTH_ERR_TOS_NOTSTR: macro 
1b08				; TOSO might need more for checks when used 
1b08				push af 
1b08				ld a,(hl) 
1b08				cp DS_TYPE_STR 
1b08				jp nz, type_faultn   
1b08				pop af 
1b08				endm 
1b08			 
1b08			FORTH_ERR_TOS_NOTNUM: macro 
1b08				push af 
1b08				ld a,(hl) 
1b08				cp DS_TYPE_INUM 
1b08				jp nz, type_faultn   
1b08				pop af 
1b08				endm 
1b08			 
1b08			 
1b08			; increase data stack pointer and save hl to it 
1b08				 
1b08			FORTH_DSP_NEXT: macro 
1b08				call macro_forth_dsp_next 
1b08				endm 
1b08			 
1b08			 
1b08			macro_forth_dsp_next: 
1b08				if DEBUG_FORTH_STACK_GUARD 
1b08 cd 8e 5a				call check_stacks 
1b0b				endif 
1b0b e5				push hl 
1b0c d5				push de 
1b0d eb				ex de,hl 
1b0e 2a ee e9			ld hl,(cli_data_sp) 
1b11 23				inc hl 
1b12 23				inc hl 
1b13			 
1b13			; PARSEV5 
1b13 23				inc hl 
1b14 22 ee e9			ld (cli_data_sp),hl 
1b17 73				ld (hl), e 
1b18 23				inc hl 
1b19 72				ld (hl), d 
1b1a d1				pop de 
1b1b e1				pop hl 
1b1c				if DEBUG_FORTH_STACK_GUARD 
1b1c cd 8e 5a				call check_stacks 
1b1f				endif 
1b1f c9				ret 
1b20			 
1b20			 
1b20			; increase ret stack pointer and save hl to it 
1b20				 
1b20			FORTH_RSP_NEXT: macro 
1b20				call macro_forth_rsp_next 
1b20				endm 
1b20			 
1b20			macro_forth_rsp_next: 
1b20				if DEBUG_FORTH_STACK_GUARD 
1b20 cd 8e 5a				call check_stacks 
1b23				endif 
1b23 e5				push hl 
1b24 d5				push de 
1b25 eb				ex de,hl 
1b26 2a f2 e9			ld hl,(cli_ret_sp) 
1b29 23				inc hl 
1b2a 23				inc hl 
1b2b 22 f2 e9			ld (cli_ret_sp),hl 
1b2e 73				ld (hl), e 
1b2f 23				inc hl 
1b30 72				ld (hl), d 
1b31 d1				pop de 
1b32 e1				pop hl 
1b33				if DEBUG_FORTH_STACK_GUARD 
1b33 cd 8e 5a				call check_stacks 
1b36				endif 
1b36 c9				ret 
1b37			 
1b37			; get current ret stack pointer and save to hl  
1b37				 
1b37			FORTH_RSP_TOS: macro 
1b37				call macro_forth_rsp_tos 
1b37				endm 
1b37			 
1b37			macro_forth_rsp_tos: 
1b37				;push de 
1b37 2a f2 e9			ld hl,(cli_ret_sp) 
1b3a cd 72 1b			call loadhlptrtohl 
1b3d				;ld e, (hl) 
1b3d				;inc hl 
1b3d				;ld d, (hl) 
1b3d				;ex de, hl 
1b3d					if DEBUG_FORTH_WORDS 
1b3d			;			DMARK "RST" 
1b3d						CALLMONITOR 
1b3d cd 6f ee			call debug_vector  
1b40				endm  
# End of macro CALLMONITOR
1b40					endif 
1b40				;pop de 
1b40 c9				ret 
1b41			 
1b41			; pop ret stack pointer 
1b41				 
1b41			FORTH_RSP_POP: macro 
1b41				call macro_forth_rsp_pop 
1b41				endm 
1b41			 
1b41			 
1b41			macro_forth_rsp_pop: 
1b41				if DEBUG_FORTH_STACK_GUARD 
1b41			;		DMARK "RPP" 
1b41 cd 8e 5a				call check_stacks 
1b44					FORTH_CHK_RSP_UNDER 
1b44 e5				push hl 
1b45 d5				push de 
1b46 2a f2 e9			ld hl,(cli_ret_sp) 
1b49 11 ac e9			ld de, cli_ret_stack 
1b4c cd 10 0e			call cmp16 
1b4f da a5 5b			jp c, fault_rsp_under 
1b52 d1				pop de 
1b53 e1				pop hl 
1b54				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b54				endif 
1b54 e5				push hl 
1b55 2a f2 e9			ld hl,(cli_ret_sp) 
1b58			 
1b58			 
1b58				if FORTH_ENABLE_FREE 
1b58			 
1b58					; get pointer 
1b58			 
1b58					push de 
1b58					push hl 
1b58			 
1b58					ld e, (hl) 
1b58					inc hl 
1b58					ld d, (hl) 
1b58			 
1b58					ex de, hl 
1b58					call free 
1b58			 
1b58					pop hl 
1b58					pop de 
1b58			 
1b58			 
1b58				endif 
1b58			 
1b58			 
1b58 2b				dec hl 
1b59 2b				dec hl 
1b5a 22 f2 e9			ld (cli_ret_sp), hl 
1b5d				; do stack underflow checks 
1b5d e1				pop hl 
1b5e				if DEBUG_FORTH_STACK_GUARD 
1b5e cd 8e 5a				call check_stacks 
1b61					FORTH_CHK_RSP_UNDER 
1b61 e5				push hl 
1b62 d5				push de 
1b63 2a f2 e9			ld hl,(cli_ret_sp) 
1b66 11 ac e9			ld de, cli_ret_stack 
1b69 cd 10 0e			call cmp16 
1b6c da a5 5b			jp c, fault_rsp_under 
1b6f d1				pop de 
1b70 e1				pop hl 
1b71				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b71				endif 
1b71 c9				ret 
1b72			 
1b72			 
1b72			 
1b72			; routine to load word pointed to by hl into hl 
1b72			 
1b72			loadhlptrtohl: 
1b72			 
1b72 d5				push de 
1b73 5e				ld e, (hl) 
1b74 23				inc hl 
1b75 56				ld d, (hl) 
1b76 eb				ex de, hl 
1b77 d1				pop de 
1b78			 
1b78 c9				ret 
1b79			 
1b79			 
1b79			 
1b79			 
1b79			 
1b79			; push a number held in HL onto the data stack 
1b79			; entry point for pushing a value when already in hl used in function above 
1b79			 
1b79			forth_push_numhl: 
1b79			 
1b79 e5				push hl    ; save value to push 
1b7a			 
1b7a			if DEBUG_FORTH_PUSH 
1b7a				; see if disabled 
1b7a			 
1b7a			 
1b7a f5				push af 
1b7b 3a 6f ee			ld a,(debug_vector) 
1b7e fe c9			cp $c9   ; ret 
1b80			;	ld a, (os_view_disable) 
1b80			;	cp '*' 
1b80 28 34			jr z, .pskip2 
1b82 e5				push hl 
1b83 e5			push hl 
1b84 cd c5 0b			call clear_display 
1b87 e1			pop hl 
1b88 7c				ld a,h 
1b89 21 c6 e5			ld hl, os_word_scratch 
1b8c cd fb 0f			call hexout 
1b8f e1				pop hl 
1b90 7d				ld a,l 
1b91 21 c8 e5			ld hl, os_word_scratch+2 
1b94 cd fb 0f			call hexout 
1b97			 
1b97 21 ca e5			ld hl, os_word_scratch+4 
1b9a 3e 00			ld a,0 
1b9c 77				ld (hl),a 
1b9d 11 c6 e5			ld de,os_word_scratch 
1ba0 3e 28				ld a, display_row_2 
1ba2 cd d8 0b				call str_at_display 
1ba5 11 9c 4c			ld de, .push_num 
1ba8 3e 00			ld a, display_row_1 
1baa			 
1baa cd d8 0b				call str_at_display 
1bad			 
1bad			 
1bad cd e8 0b			call update_display 
1bb0 cd fd 0a			call delay1s 
1bb3 cd fd 0a			call delay1s 
1bb6			.pskip2:  
1bb6			 
1bb6 f1				pop af 
1bb7			endif	 
1bb7			 
1bb7			 
1bb7				FORTH_DSP_NEXT 
1bb7 cd 08 1b			call macro_forth_dsp_next 
1bba				endm 
# End of macro FORTH_DSP_NEXT
1bba			 
1bba 2a ee e9			ld hl, (cli_data_sp) 
1bbd			 
1bbd				; save item type 
1bbd 3e 02			ld a,  DS_TYPE_INUM 
1bbf 77				ld (hl), a 
1bc0 23				inc hl 
1bc1			 
1bc1				; get word off stack 
1bc1 d1				pop de 
1bc2 7b				ld a,e 
1bc3 77				ld (hl), a 
1bc4 23				inc hl 
1bc5 7a				ld a,d 
1bc6 77				ld (hl), a 
1bc7			 
1bc7			if DEBUG_FORTH_PUSH 
1bc7 2b				dec hl 
1bc8 2b				dec hl 
1bc9 2b				dec hl 
1bca						DMARK "PH5" 
1bca f5				push af  
1bcb 3a df 1b			ld a, (.dmark)  
1bce 32 6b ee			ld (debug_mark),a  
1bd1 3a e0 1b			ld a, (.dmark+1)  
1bd4 32 6c ee			ld (debug_mark+1),a  
1bd7 3a e1 1b			ld a, (.dmark+2)  
1bda 32 6d ee			ld (debug_mark+2),a  
1bdd 18 03			jr .pastdmark  
1bdf ..			.dmark: db "PH5"  
1be2 f1			.pastdmark: pop af  
1be3			endm  
# End of macro DMARK
1be3				CALLMONITOR 
1be3 cd 6f ee			call debug_vector  
1be6				endm  
# End of macro CALLMONITOR
1be6			endif	 
1be6			 
1be6 c9				ret 
1be7			 
1be7			 
1be7			; Push a string to stack pointed to by hl 
1be7			 
1be7			forth_push_str: 
1be7			 
1be7			if DEBUG_FORTH_PUSH 
1be7						DMARK "PSQ" 
1be7 f5				push af  
1be8 3a fc 1b			ld a, (.dmark)  
1beb 32 6b ee			ld (debug_mark),a  
1bee 3a fd 1b			ld a, (.dmark+1)  
1bf1 32 6c ee			ld (debug_mark+1),a  
1bf4 3a fe 1b			ld a, (.dmark+2)  
1bf7 32 6d ee			ld (debug_mark+2),a  
1bfa 18 03			jr .pastdmark  
1bfc ..			.dmark: db "PSQ"  
1bff f1			.pastdmark: pop af  
1c00			endm  
# End of macro DMARK
1c00				CALLMONITOR 
1c00 cd 6f ee			call debug_vector  
1c03				endm  
# End of macro CALLMONITOR
1c03			endif	 
1c03			 
1c03			 
1c03			    
1c03 e5				push hl 
1c04 e5				push hl 
1c05			 
1c05			;	ld a, 0   ; find end of string 
1c05 cd 58 11			call strlenz 
1c08			if DEBUG_FORTH_PUSH 
1c08						DMARK "PQ2" 
1c08 f5				push af  
1c09 3a 1d 1c			ld a, (.dmark)  
1c0c 32 6b ee			ld (debug_mark),a  
1c0f 3a 1e 1c			ld a, (.dmark+1)  
1c12 32 6c ee			ld (debug_mark+1),a  
1c15 3a 1f 1c			ld a, (.dmark+2)  
1c18 32 6d ee			ld (debug_mark+2),a  
1c1b 18 03			jr .pastdmark  
1c1d ..			.dmark: db "PQ2"  
1c20 f1			.pastdmark: pop af  
1c21			endm  
# End of macro DMARK
1c21				CALLMONITOR 
1c21 cd 6f ee			call debug_vector  
1c24				endm  
# End of macro CALLMONITOR
1c24			endif	 
1c24 eb				ex de, hl 
1c25 e1				pop hl   ; get ptr to start of string 
1c26			if DEBUG_FORTH_PUSH 
1c26						DMARK "PQ3" 
1c26 f5				push af  
1c27 3a 3b 1c			ld a, (.dmark)  
1c2a 32 6b ee			ld (debug_mark),a  
1c2d 3a 3c 1c			ld a, (.dmark+1)  
1c30 32 6c ee			ld (debug_mark+1),a  
1c33 3a 3d 1c			ld a, (.dmark+2)  
1c36 32 6d ee			ld (debug_mark+2),a  
1c39 18 03			jr .pastdmark  
1c3b ..			.dmark: db "PQ3"  
1c3e f1			.pastdmark: pop af  
1c3f			endm  
# End of macro DMARK
1c3f				CALLMONITOR 
1c3f cd 6f ee			call debug_vector  
1c42				endm  
# End of macro CALLMONITOR
1c42			endif	 
1c42 19				add hl,de 
1c43			if DEBUG_FORTH_PUSH 
1c43						DMARK "PQE" 
1c43 f5				push af  
1c44 3a 58 1c			ld a, (.dmark)  
1c47 32 6b ee			ld (debug_mark),a  
1c4a 3a 59 1c			ld a, (.dmark+1)  
1c4d 32 6c ee			ld (debug_mark+1),a  
1c50 3a 5a 1c			ld a, (.dmark+2)  
1c53 32 6d ee			ld (debug_mark+2),a  
1c56 18 03			jr .pastdmark  
1c58 ..			.dmark: db "PQE"  
1c5b f1			.pastdmark: pop af  
1c5c			endm  
# End of macro DMARK
1c5c				CALLMONITOR 
1c5c cd 6f ee			call debug_vector  
1c5f				endm  
# End of macro CALLMONITOR
1c5f			endif	 
1c5f			 
1c5f 2b				dec hl    ; see if there is an optional trailing double quote 
1c60 7e				ld a,(hl) 
1c61 fe 22			cp '"' 
1c63 20 03			jr nz, .strnoq 
1c65 3e 00			ld a, 0      ; get rid of double quote 
1c67 77				ld (hl), a 
1c68 23			.strnoq: inc hl 
1c69			 
1c69 3e 00			ld a, 0 
1c6b 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1c6c			 
1c6c 13				inc de ; add one for the type string 
1c6d 13				inc de ; add one for null term??? 
1c6e			 
1c6e				; tos is get string pointer again 
1c6e				; de contains space to allocate 
1c6e				 
1c6e d5				push de 
1c6f			 
1c6f eb				ex de, hl 
1c70			 
1c70				;push af 
1c70			 
1c70			if DEBUG_FORTH_PUSH 
1c70						DMARK "PHm" 
1c70 f5				push af  
1c71 3a 85 1c			ld a, (.dmark)  
1c74 32 6b ee			ld (debug_mark),a  
1c77 3a 86 1c			ld a, (.dmark+1)  
1c7a 32 6c ee			ld (debug_mark+1),a  
1c7d 3a 87 1c			ld a, (.dmark+2)  
1c80 32 6d ee			ld (debug_mark+2),a  
1c83 18 03			jr .pastdmark  
1c85 ..			.dmark: db "PHm"  
1c88 f1			.pastdmark: pop af  
1c89			endm  
# End of macro DMARK
1c89				CALLMONITOR 
1c89 cd 6f ee			call debug_vector  
1c8c				endm  
# End of macro CALLMONITOR
1c8c			endif	 
1c8c cd cd 11			call malloc	; on ret hl now contains allocated memory 
1c8f				if DEBUG_FORTH_MALLOC_GUARD 
1c8f cc f4 4c				call z,malloc_error 
1c92				endif 
1c92			 
1c92				 
1c92 c1				pop bc    ; get length 
1c93 d1				pop de   ;  get string start    
1c94			 
1c94				; hl has destination from malloc 
1c94			 
1c94 eb				ex de, hl    ; prep for ldir 
1c95			 
1c95 d5				push de   ; save malloc area for DSP later 
1c96				;push hl   ; save malloc area for DSP later 
1c96			 
1c96			if DEBUG_FORTH_PUSH 
1c96						DMARK "PHc" 
1c96 f5				push af  
1c97 3a ab 1c			ld a, (.dmark)  
1c9a 32 6b ee			ld (debug_mark),a  
1c9d 3a ac 1c			ld a, (.dmark+1)  
1ca0 32 6c ee			ld (debug_mark+1),a  
1ca3 3a ad 1c			ld a, (.dmark+2)  
1ca6 32 6d ee			ld (debug_mark+2),a  
1ca9 18 03			jr .pastdmark  
1cab ..			.dmark: db "PHc"  
1cae f1			.pastdmark: pop af  
1caf			endm  
# End of macro DMARK
1caf				CALLMONITOR 
1caf cd 6f ee			call debug_vector  
1cb2				endm  
# End of macro CALLMONITOR
1cb2			endif	 
1cb2			 
1cb2			 
1cb2 ed b0			ldir 
1cb4			 
1cb4			 
1cb4				; push malloc to data stack     macro?????  
1cb4			 
1cb4				FORTH_DSP_NEXT 
1cb4 cd 08 1b			call macro_forth_dsp_next 
1cb7				endm 
# End of macro FORTH_DSP_NEXT
1cb7			 
1cb7				; save value and type 
1cb7			 
1cb7 2a ee e9			ld hl, (cli_data_sp) 
1cba			 
1cba				; save item type 
1cba 3e 01			ld a,  DS_TYPE_STR 
1cbc 77				ld (hl), a 
1cbd 23				inc hl 
1cbe			 
1cbe				; get malloc word off stack 
1cbe d1				pop de 
1cbf 73				ld (hl), e 
1cc0 23				inc hl 
1cc1 72				ld (hl), d 
1cc2			 
1cc2			 
1cc2			 
1cc2			if DEBUG_FORTH_PUSH 
1cc2 2a ee e9			ld hl, (cli_data_sp) 
1cc5						DMARK "PHS" 
1cc5 f5				push af  
1cc6 3a da 1c			ld a, (.dmark)  
1cc9 32 6b ee			ld (debug_mark),a  
1ccc 3a db 1c			ld a, (.dmark+1)  
1ccf 32 6c ee			ld (debug_mark+1),a  
1cd2 3a dc 1c			ld a, (.dmark+2)  
1cd5 32 6d ee			ld (debug_mark+2),a  
1cd8 18 03			jr .pastdmark  
1cda ..			.dmark: db "PHS"  
1cdd f1			.pastdmark: pop af  
1cde			endm  
# End of macro DMARK
1cde				CALLMONITOR 
1cde cd 6f ee			call debug_vector  
1ce1				endm  
# End of macro CALLMONITOR
1ce1			;	ex de,hl 
1ce1			endif	 
1ce1				; in case of spaces, skip the ptr past the copied string 
1ce1				;pop af 
1ce1				;ld (cli_origptr),hl 
1ce1			 
1ce1 c9				ret 
1ce2			 
1ce2			 
1ce2			 
1ce2			; TODO ascii push input onto stack given hl to start of input 
1ce2			 
1ce2			; identify type 
1ce2			; if starts with a " then a string 
1ce2			; otherwise it is a number 
1ce2			;  
1ce2			; if a string 
1ce2			;     scan for ending " to get length of string to malloc for + 1 
1ce2			;     malloc 
1ce2			;     put pointer to string on stack first byte flags as string 
1ce2			; 
1ce2			; else a number 
1ce2			;    look for number format identifier 
1ce2			;    $xx hex 
1ce2			;    %xxxxx bin 
1ce2			;    xxxxx decimal 
1ce2			;    convert number to 16bit word.  
1ce2			;    malloc word + 1 with flag to identiy as num 
1ce2			;    put pointer to number on stack 
1ce2			;   
1ce2			;  
1ce2			  
1ce2			forth_apush: 
1ce2				; kernel push 
1ce2			 
1ce2			if DEBUG_FORTH_PUSH 
1ce2						DMARK "PSH" 
1ce2 f5				push af  
1ce3 3a f7 1c			ld a, (.dmark)  
1ce6 32 6b ee			ld (debug_mark),a  
1ce9 3a f8 1c			ld a, (.dmark+1)  
1cec 32 6c ee			ld (debug_mark+1),a  
1cef 3a f9 1c			ld a, (.dmark+2)  
1cf2 32 6d ee			ld (debug_mark+2),a  
1cf5 18 03			jr .pastdmark  
1cf7 ..			.dmark: db "PSH"  
1cfa f1			.pastdmark: pop af  
1cfb			endm  
# End of macro DMARK
1cfb				CALLMONITOR 
1cfb cd 6f ee			call debug_vector  
1cfe				endm  
# End of macro CALLMONITOR
1cfe			endif	 
1cfe				; identify input type 
1cfe			 
1cfe 7e				ld a,(hl) 
1cff			 
1cff fe 23			cp '#' 
1d01 ca 3b 1d			jp z, .fapdec 
1d04			 
1d04			 
1d04 fe 22			cp '"' 
1d06 28 0a			jr z, .fapstr 
1d08 fe 24			cp '$' 
1d0a ca 32 1d			jp z, .faphex 
1d0d fe 25			cp '%' 
1d0f ca 1a 1d			jp z, .fapbin 
1d12			;	cp 'b' 
1d12			;	jp z, .fabin 
1d12				; else decimal 
1d12			 
1d12				; TODO do decimal conversion 
1d12				; decimal is stored as a 16bit word 
1d12			 
1d12				; by default everything is a string if type is not detected 
1d12			.fapstr: ; 
1d12 fe 22			cp '"' 
1d14 20 01			jr nz, .strnoqu 
1d16 23				inc hl 
1d17			.strnoqu: 
1d17 c3 e7 1b			jp forth_push_str 
1d1a			 
1d1a			 
1d1a			 
1d1a			.fapbin:    ; push a binary string.  
1d1a 11 00 00			ld de, 0   ; hold a 16bit value 
1d1d			 
1d1d 23			.fapbinshift:	inc hl  
1d1e 7e				ld a,(hl) 
1d1f fe 00			cp 0     ; done scanning  
1d21 28 0b			jr z, .fapbdone  	; got it in HL so push  
1d23			 
1d23				; left shift de 
1d23 eb				ex de, hl	 
1d24 29				add hl, hl 
1d25			 
1d25				; is 1 
1d25 fe 31			cp '1' 
1d27 20 02			jr nz, .binzero 
1d29 cb 4d			bit 1, l 
1d2b			.binzero: 
1d2b eb				ex de, hl	 ; save current de 
1d2c 18 ef			jr .fapbinshift 
1d2e			 
1d2e			.fapbdone: 
1d2e eb				ex de, hl 
1d2f c3 79 1b			jp forth_push_numhl 
1d32			 
1d32			 
1d32			.faphex:   ; hex is always stored as a 16bit word 
1d32				; skip number prefix 
1d32 23				inc hl 
1d33				; turn ascii into number 
1d33 cd b1 10			call get_word_hl	; ret 16bit word in hl 
1d36			 
1d36 c3 79 1b			jp forth_push_numhl 
1d39			 
1d39 00				 nop 
1d3a			 
1d3a			.fabin:   ; TODO bin conversion 
1d3a			 
1d3a			 
1d3a c9				ret 
1d3b			.fapdec:	 
1d3b				; string to dec conversion 
1d3b 23				inc hl 
1d3c eb				ex de, hl 
1d3d cd ef 10			call string_to_uint16 
1d40 c3 79 1b			jp forth_push_numhl 
1d43 c9				ret 
1d44				 
1d44			;atoui_16: 
1d44			 
1d44			; get either a string ptr or a 16bit word from the data stack 
1d44			 
1d44			FORTH_DSP: macro 
1d44				call macro_forth_dsp 
1d44				endm 
1d44			 
1d44			macro_forth_dsp: 
1d44				; data stack pointer points to current word on tos 
1d44			 
1d44 2a ee e9			ld hl,(cli_data_sp) 
1d47			 
1d47				if DEBUG_FORTH_PUSH 
1d47						DMARK "DSP" 
1d47 f5				push af  
1d48 3a 5c 1d			ld a, (.dmark)  
1d4b 32 6b ee			ld (debug_mark),a  
1d4e 3a 5d 1d			ld a, (.dmark+1)  
1d51 32 6c ee			ld (debug_mark+1),a  
1d54 3a 5e 1d			ld a, (.dmark+2)  
1d57 32 6d ee			ld (debug_mark+2),a  
1d5a 18 03			jr .pastdmark  
1d5c ..			.dmark: db "DSP"  
1d5f f1			.pastdmark: pop af  
1d60			endm  
# End of macro DMARK
1d60			 
1d60 cd 27 4d				call display_data_sp 
1d63				;call break_point_state 
1d63				;rst 030h 
1d63				CALLMONITOR 
1d63 cd 6f ee			call debug_vector  
1d66				endm  
# End of macro CALLMONITOR
1d66				endif 
1d66			 
1d66 c9				ret 
1d67			 
1d67			; return hl to start of value on stack 
1d67			 
1d67			FORTH_DSP_VALUE: macro 
1d67				call macro_forth_dsp_value 
1d67				endm 
1d67			 
1d67			macro_forth_dsp_value: 
1d67			 
1d67				FORTH_DSP 
1d67 cd 44 1d			call macro_forth_dsp 
1d6a				endm 
# End of macro FORTH_DSP
1d6a			 
1d6a d5				push de 
1d6b			 
1d6b 23				inc hl ; skip type 
1d6c			 
1d6c 5e				ld e, (hl) 
1d6d 23				inc hl 
1d6e 56				ld d, (hl) 
1d6f eb				ex de,hl  
1d70			 
1d70 d1				pop de 
1d71			 
1d71 c9				ret 
1d72			 
1d72			; return hl to start of value to second item on stack 
1d72			 
1d72			FORTH_DSP_VALUEM1: macro 
1d72				call macro_forth_dsp_value_m1 
1d72				endm 
1d72			 
1d72			macro_forth_dsp_value_m1: 
1d72			 
1d72				FORTH_DSP 
1d72 cd 44 1d			call macro_forth_dsp 
1d75				endm 
# End of macro FORTH_DSP
1d75			 
1d75 2b				dec hl 
1d76 2b				dec hl 
1d77			;	dec hl 
1d77			 
1d77 d5				push de 
1d78			 
1d78 5e				ld e, (hl) 
1d79 23				inc hl 
1d7a 56				ld d, (hl) 
1d7b eb				ex de,hl  
1d7c			 
1d7c d1				pop de 
1d7d			 
1d7d c9				ret 
1d7e			 
1d7e				 
1d7e			 
1d7e			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1d7e			 
1d7e			FORTH_DSP_POP: macro 
1d7e				call macro_forth_dsp_pop 
1d7e				endm 
1d7e			 
1d7e			 
1d7e			; get the tos data type 
1d7e			 
1d7e			FORTH_DSP_TYPE:   macro 
1d7e			 
1d7e				;FORTH_DSP_VALUE 
1d7e				FORTH_DSP 
1d7e				 
1d7e				; hl points to value 
1d7e				; check type 
1d7e			 
1d7e				ld a,(hl) 
1d7e			 
1d7e				endm 
1d7e			 
1d7e			; load the tos value into hl 
1d7e			 
1d7e			 
1d7e			FORTH_DSP_VALUEHL:  macro 
1d7e				call macro_dsp_valuehl 
1d7e				endm 
1d7e			 
1d7e			 
1d7e			 
1d7e			macro_dsp_valuehl: 
1d7e				FORTH_DSP_VALUE 
1d7e cd 67 1d			call macro_forth_dsp_value 
1d81				endm 
# End of macro FORTH_DSP_VALUE
1d81			 
1d81				;FORTH_ERR_TOS_NOTNUM 
1d81			 
1d81				;inc hl   ; skip type id 
1d81			 
1d81			;	push de 
1d81			; 
1d81			;	ld e, (hl) 
1d81			;	inc hl 
1d81			;	ld d, (hl) 
1d81			;	ex de,hl  
1d81			 
1d81			;	pop de 
1d81			 
1d81				if DEBUG_FORTH_PUSH 
1d81						DMARK "DVL" 
1d81 f5				push af  
1d82 3a 96 1d			ld a, (.dmark)  
1d85 32 6b ee			ld (debug_mark),a  
1d88 3a 97 1d			ld a, (.dmark+1)  
1d8b 32 6c ee			ld (debug_mark+1),a  
1d8e 3a 98 1d			ld a, (.dmark+2)  
1d91 32 6d ee			ld (debug_mark+2),a  
1d94 18 03			jr .pastdmark  
1d96 ..			.dmark: db "DVL"  
1d99 f1			.pastdmark: pop af  
1d9a			endm  
# End of macro DMARK
1d9a				CALLMONITOR 
1d9a cd 6f ee			call debug_vector  
1d9d				endm  
# End of macro CALLMONITOR
1d9d				endif 
1d9d c9				ret 
1d9e			 
1d9e			forth_apushstrhl:      
1d9e				; push of string requires use of cli_origptr 
1d9e				; bodge use 
1d9e			 
1d9e				; get current cli_origptr, save, update with temp pointer  
1d9e ed 5b 3e ea		ld de, (cli_origptr) 
1da2 22 3e ea			ld (cli_origptr), hl 
1da5 d5				push de 
1da6 cd e2 1c			call forth_apush 
1da9 d1				pop de 
1daa ed 53 3e ea		ld (cli_origptr), de 
1dae c9			        ret	 
1daf			 
1daf			 
1daf			; increase loop stack pointer and save hl to it 
1daf				 
1daf			FORTH_LOOP_NEXT: macro 
1daf				call macro_forth_loop_next 
1daf				;nop 
1daf				endm 
1daf			 
1daf			macro_forth_loop_next: 
1daf				if DEBUG_FORTH_STACK_GUARD 
1daf cd 8e 5a				call check_stacks 
1db2				endif 
1db2 e5				push hl 
1db3 d5				push de 
1db4 eb				ex de,hl 
1db5 2a f0 e9			ld hl,(cli_loop_sp) 
1db8 23				inc hl 
1db9 23				inc hl 
1dba					if DEBUG_FORTH_WORDS 
1dba						DMARK "LNX" 
1dba f5				push af  
1dbb 3a cf 1d			ld a, (.dmark)  
1dbe 32 6b ee			ld (debug_mark),a  
1dc1 3a d0 1d			ld a, (.dmark+1)  
1dc4 32 6c ee			ld (debug_mark+1),a  
1dc7 3a d1 1d			ld a, (.dmark+2)  
1dca 32 6d ee			ld (debug_mark+2),a  
1dcd 18 03			jr .pastdmark  
1dcf ..			.dmark: db "LNX"  
1dd2 f1			.pastdmark: pop af  
1dd3			endm  
# End of macro DMARK
1dd3						CALLMONITOR 
1dd3 cd 6f ee			call debug_vector  
1dd6				endm  
# End of macro CALLMONITOR
1dd6					endif 
1dd6 22 f0 e9			ld (cli_loop_sp),hl 
1dd9 73				ld (hl), e 
1dda 23				inc hl 
1ddb 72				ld (hl), d 
1ddc d1				pop de    ; been reversed so save a swap on restore 
1ddd e1				pop hl 
1dde				if DEBUG_FORTH_STACK_GUARD 
1dde cd 8e 5a				call check_stacks 
1de1				endif 
1de1 c9				ret 
1de2			 
1de2			; get current ret stack pointer and save to hl  
1de2				 
1de2			FORTH_LOOP_TOS: macro 
1de2				call macro_forth_loop_tos 
1de2				endm 
1de2			 
1de2			macro_forth_loop_tos: 
1de2 d5				push de 
1de3 2a f0 e9			ld hl,(cli_loop_sp) 
1de6 5e				ld e, (hl) 
1de7 23				inc hl 
1de8 56				ld d, (hl) 
1de9 eb				ex de, hl 
1dea d1				pop de 
1deb c9				ret 
1dec			 
1dec			; pop loop stack pointer 
1dec				 
1dec			FORTH_LOOP_POP: macro 
1dec				call macro_forth_loop_pop 
1dec				endm 
1dec			 
1dec			 
1dec			macro_forth_loop_pop: 
1dec				if DEBUG_FORTH_STACK_GUARD 
1dec					DMARK "LPP" 
1dec f5				push af  
1ded 3a 01 1e			ld a, (.dmark)  
1df0 32 6b ee			ld (debug_mark),a  
1df3 3a 02 1e			ld a, (.dmark+1)  
1df6 32 6c ee			ld (debug_mark+1),a  
1df9 3a 03 1e			ld a, (.dmark+2)  
1dfc 32 6d ee			ld (debug_mark+2),a  
1dff 18 03			jr .pastdmark  
1e01 ..			.dmark: db "LPP"  
1e04 f1			.pastdmark: pop af  
1e05			endm  
# End of macro DMARK
1e05 cd 8e 5a				call check_stacks 
1e08					FORTH_CHK_LOOP_UNDER 
1e08 e5				push hl 
1e09 d5				push de 
1e0a 2a f0 e9			ld hl,(cli_loop_sp) 
1e0d 11 2a e9			ld de, cli_loop_stack 
1e10 cd 10 0e			call cmp16 
1e13 da ab 5b			jp c, fault_loop_under 
1e16 d1				pop de 
1e17 e1				pop hl 
1e18				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e18				endif 
1e18 e5				push hl 
1e19 2a f0 e9			ld hl,(cli_loop_sp) 
1e1c 2b				dec hl 
1e1d 2b				dec hl 
1e1e 22 f0 e9			ld (cli_loop_sp), hl 
1e21				; TODO do stack underflow checks 
1e21 e1				pop hl 
1e22				if DEBUG_FORTH_STACK_GUARD 
1e22 cd 8e 5a				call check_stacks 
1e25					FORTH_CHK_LOOP_UNDER 
1e25 e5				push hl 
1e26 d5				push de 
1e27 2a f0 e9			ld hl,(cli_loop_sp) 
1e2a 11 2a e9			ld de, cli_loop_stack 
1e2d cd 10 0e			call cmp16 
1e30 da ab 5b			jp c, fault_loop_under 
1e33 d1				pop de 
1e34 e1				pop hl 
1e35				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e35				endif 
1e35 c9				ret 
1e36			 
1e36			macro_forth_dsp_pop: 
1e36			 
1e36 e5				push hl 
1e37			 
1e37				; release malloc data 
1e37			 
1e37				if DEBUG_FORTH_STACK_GUARD 
1e37 cd 8e 5a				call check_stacks 
1e3a					FORTH_CHK_DSP_UNDER 
1e3a e5				push hl 
1e3b d5				push de 
1e3c 2a ee e9			ld hl,(cli_data_sp) 
1e3f 11 28 e8			ld de, cli_data_stack 
1e42 cd 10 0e			call cmp16 
1e45 da 9f 5b			jp c, fault_dsp_under 
1e48 d1				pop de 
1e49 e1				pop hl 
1e4a				endm 
# End of macro FORTH_CHK_DSP_UNDER
1e4a				endif 
1e4a				;ld hl,(cli_data_sp) 
1e4a			if DEBUG_FORTH_DOT 
1e4a				DMARK "DPP" 
1e4a f5				push af  
1e4b 3a 5f 1e			ld a, (.dmark)  
1e4e 32 6b ee			ld (debug_mark),a  
1e51 3a 60 1e			ld a, (.dmark+1)  
1e54 32 6c ee			ld (debug_mark+1),a  
1e57 3a 61 1e			ld a, (.dmark+2)  
1e5a 32 6d ee			ld (debug_mark+2),a  
1e5d 18 03			jr .pastdmark  
1e5f ..			.dmark: db "DPP"  
1e62 f1			.pastdmark: pop af  
1e63			endm  
# End of macro DMARK
1e63				CALLMONITOR 
1e63 cd 6f ee			call debug_vector  
1e66				endm  
# End of macro CALLMONITOR
1e66			endif	 
1e66			 
1e66			 
1e66			if FORTH_ENABLE_DSPPOPFREE 
1e66			 
1e66				FORTH_DSP 
1e66 cd 44 1d			call macro_forth_dsp 
1e69				endm 
# End of macro FORTH_DSP
1e69			 
1e69 7e				ld a, (hl) 
1e6a fe 01			cp DS_TYPE_STR 
1e6c 20 23			jr nz, .skippopfree 
1e6e			 
1e6e				FORTH_DSP_VALUEHL 
1e6e cd 7e 1d			call macro_dsp_valuehl 
1e71				endm 
# End of macro FORTH_DSP_VALUEHL
1e71 00				nop 
1e72			if DEBUG_FORTH_DOT 
1e72				DMARK "DPf" 
1e72 f5				push af  
1e73 3a 87 1e			ld a, (.dmark)  
1e76 32 6b ee			ld (debug_mark),a  
1e79 3a 88 1e			ld a, (.dmark+1)  
1e7c 32 6c ee			ld (debug_mark+1),a  
1e7f 3a 89 1e			ld a, (.dmark+2)  
1e82 32 6d ee			ld (debug_mark+2),a  
1e85 18 03			jr .pastdmark  
1e87 ..			.dmark: db "DPf"  
1e8a f1			.pastdmark: pop af  
1e8b			endm  
# End of macro DMARK
1e8b				CALLMONITOR 
1e8b cd 6f ee			call debug_vector  
1e8e				endm  
# End of macro CALLMONITOR
1e8e			endif	 
1e8e cd 97 12			call free 
1e91			.skippopfree: 
1e91				 
1e91			 
1e91			endif 
1e91			 
1e91			if DEBUG_FORTH_DOT_KEY 
1e91				DMARK "DP2" 
1e91				CALLMONITOR 
1e91			endif	 
1e91			 
1e91				; move pointer down 
1e91			 
1e91 2a ee e9			ld hl,(cli_data_sp) 
1e94 2b				dec hl 
1e95 2b				dec hl 
1e96			; PARSEV5 
1e96 2b				dec hl 
1e97 22 ee e9			ld (cli_data_sp), hl 
1e9a			 
1e9a				if DEBUG_FORTH_STACK_GUARD 
1e9a cd 8e 5a				call check_stacks 
1e9d					FORTH_CHK_DSP_UNDER 
1e9d e5				push hl 
1e9e d5				push de 
1e9f 2a ee e9			ld hl,(cli_data_sp) 
1ea2 11 28 e8			ld de, cli_data_stack 
1ea5 cd 10 0e			call cmp16 
1ea8 da 9f 5b			jp c, fault_dsp_under 
1eab d1				pop de 
1eac e1				pop hl 
1ead				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ead				endif 
1ead			 
1ead e1				pop hl 
1eae			 
1eae c9				ret 
1eaf			 
1eaf			getwordathl: 
1eaf				; hl points to an address 
1eaf				; load hl with the word at that address 
1eaf			 
1eaf d5				push de 
1eb0			 
1eb0 5e				ld e, (hl) 
1eb1 23				inc hl 
1eb2 56				ld d, (hl) 
1eb3 eb				ex de, hl 
1eb4			 
1eb4 d1				pop de 
1eb5 c9				ret 
1eb6			 
1eb6			 
1eb6			 
1eb6			 
1eb6			 
1eb6			; eof 
1eb6			 
# End of file forth_stackopsv5.asm
1eb6			endif 
1eb6			 
1eb6			loadwordinhl:	 
1eb6			 
1eb6 d5				push de 
1eb7			 
1eb7 5e				ld e, (hl) 
1eb8 23				inc hl 
1eb9 56				ld d, (hl) 
1eba eb				ex de,hl  
1ebb			 
1ebb d1				pop de 
1ebc			 
1ebc c9				ret 
1ebd			 
1ebd			user_word_eol:  
1ebd				; hl contains the pointer to where to create a linked list item from the end 
1ebd				; of the user dict to continue on at the system word dict 
1ebd				 
1ebd				; poke the stub of the word list linked list to repoint to rom words 
1ebd			 
1ebd				; stub format 
1ebd				; db   word id 
1ebd				; dw    link to next word 
1ebd			        ; db char length of token 
1ebd				; db string + 0 term 
1ebd				; db exec code....  
1ebd			 
1ebd 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1ebf 77				ld (hl), a		; word id 
1ec0 23				inc hl 
1ec1			 
1ec1 11 8c 20			ld de, sysdict 
1ec4 73				ld (hl), e		; next word link ie system dict 
1ec5 23				inc hl 
1ec6 72				ld (hl), d		; next word link ie system dict 
1ec7 23				inc hl	 
1ec8			 
1ec8			;	ld (hl), sysdict		; next word link ie system dict 
1ec8			;	inc hl 
1ec8			;	inc hl 
1ec8			 
1ec8			;	inc hl 
1ec8			;	inc hl 
1ec8			 
1ec8 3e 02			ld a, 2			; word length is 0 
1eca 77				ld (hl), a	 
1ecb 23				inc hl 
1ecc			 
1ecc 3e 7e			ld a, '~'			; word length is 0 
1ece 77				ld (hl), a	 
1ecf 23				inc hl 
1ed0 3e 00			ld a, 0			; save empty word 
1ed2 77				ld (hl), a 
1ed3			 
1ed3 c9				ret 
1ed4			 
1ed4				 
1ed4			 
1ed4			forthexec_cleanup: 
1ed4				FORTH_RSP_POP 
1ed4 cd 41 1b			call macro_forth_rsp_pop 
1ed7				endm 
# End of macro FORTH_RSP_POP
1ed7 c9				ret 
1ed8			 
1ed8			forth_call_hl: 
1ed8				; taking hl 
1ed8 e5				push hl 
1ed9 c9				ret 
1eda			 
1eda			; this is called to reset Forth system but keep existing uwords etc 
1eda			 
1eda			forth_warmstart: 
1eda				; setup stack over/under flow checks 
1eda				if DEBUG_FORTH_STACK_GUARD 
1eda cd 74 5a				call chk_stk_init 
1edd				endif 
1edd			 
1edd				; init stack pointers  - * these stacks go upwards *  
1edd 21 ac e9			ld hl, cli_ret_stack 
1ee0 22 f2 e9			ld (cli_ret_sp), hl	 
1ee3				; set bottom of stack 
1ee3 3e 00			ld a,0 
1ee5 77				ld (hl),a 
1ee6 23				inc hl 
1ee7 77				ld (hl),a 
1ee8			 
1ee8 21 28 e8			ld hl, cli_data_stack 
1eeb 22 ee e9			ld (cli_data_sp), hl	 
1eee				; set bottom of stack 
1eee 3e 00			ld a,0 
1ef0 77				ld (hl),a 
1ef1 23				inc hl 
1ef2 77				ld (hl),a 
1ef3			 
1ef3 21 2a e9			ld hl, cli_loop_stack 
1ef6 22 f0 e9			ld (cli_loop_sp), hl	 
1ef9				; set bottom of stack 
1ef9 3e 00			ld a,0 
1efb 77				ld (hl),a 
1efc 23				inc hl 
1efd 77				ld (hl),a 
1efe			 
1efe				; init extent of current open file 
1efe			 
1efe 3e 00			ld a, 0 
1f00 32 6a ea			ld (store_openext), a 
1f03			 
1f03 c9				ret 
1f04			 
1f04			 
1f04			 
1f04			; Cold Start - this is called to setup the whole Forth system 
1f04			 
1f04			forth_init: 
1f04			 
1f04				; setup stack over/under flow checks 
1f04			 
1f04			;	if DEBUG_FORTH_STACK_GUARD 
1f04			;		call chk_stk_init 
1f04			;	endif 
1f04			 
1f04				; enable auto display updates (slow.....) 
1f04			 
1f04 3e 01			ld a, 1 
1f06 32 3c ea			ld (cli_autodisplay), a 
1f09			 
1f09				; if storage is in use disable long reads for now 
1f09 3e 00			ld a, 0 
1f0b 32 75 ea			ld (store_longread), a 
1f0e			 
1f0e			 
1f0e				; show start up screen 
1f0e			 
1f0e cd c5 0b			call clear_display 
1f11			 
1f11 3e 00			ld a,0 
1f13 32 5e ea			ld (f_cursor_ptr), a 
1f16			 
1f16				; set start of word list in start of ram - for use when creating user words 
1f16			 
1f16 21 89 5e			ld hl, baseram 
1f19 22 be e5			ld (os_last_new_uword), hl 
1f1c cd bd 1e			call user_word_eol 
1f1f				 
1f1f			;		call display_data_sp 
1f1f			;		call next_page_prompt 
1f1f			 
1f1f			 
1f1f			 
1f1f			 
1f1f c9				ret 
1f20			 
1f20 .. 00		.bootforth: db " Forth Kernel Init ",0 
1f34			 
1f34			; TODO push to stack 
1f34			 
1f34			;  
1f34			 
1f34			if FORTH_PARSEV2 
1f34			 
1f34			 
1f34				include "forth_parserv2.asm" 
1f34			 
1f34			endif 
1f34			 
1f34			 
1f34			; parse cli version 1 
1f34			 
1f34			if FORTH_PARSEV1 
1f34			 
1f34			 
1f34			 
1f34			      include "forth_parserv1.asm" 
1f34			endif 
1f34				 
1f34			if FORTH_PARSEV3 
1f34			 
1f34			 
1f34			 
1f34			      include "forth_parserv3.asm" 
1f34				include "forth_wordsv3.asm" 
1f34			endif 
1f34			 
1f34			if FORTH_PARSEV4 
1f34			 
1f34			 
1f34			 
1f34			      include "forth_parserv4.asm" 
1f34				include "forth_wordsv4.asm" 
1f34			endif 
1f34			 
1f34			if FORTH_PARSEV5 
1f34			 
1f34			 
1f34			 
1f34			      include "forth_parserv5.asm" 
1f34			 
1f34			 
1f34			; A better parser without using malloc and string copies all over the place.  
1f34			; Exec in situ should be faster 
1f34			 
1f34			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1f34			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1f34			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1f34			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1f34			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1f34			WORD_SYS_END: equ 0   ; Opcode for all user words 
1f34			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1f34			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1f34			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1f34			 
1f34			; Core word preamble macro 
1f34			 
1f34			CWHEAD:   macro nxtword opcode lit len opflags 
1f34				db WORD_SYS_CORE+opcode             
1f34				; internal op code number 
1f34				dw nxtword            
1f34				; link to next dict word block 
1f34				db len + 1 
1f34				; literal length of dict word inc zero term 
1f34				db lit,0              
1f34				; literal dict word 
1f34			        ; TODO db opflags        
1f34				endm 
1f34			 
1f34			 
1f34			NEXTW: macro  
1f34				jp macro_next 
1f34				endm 
1f34			 
1f34			macro_next: 
1f34			if DEBUG_FORTH_PARSE_KEY 
1f34				DMARK "NXT" 
1f34				CALLMONITOR 
1f34			endif	 
1f34			;	inc hl  ; skip token null term  
1f34 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f38 ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f3c 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f3f			if DEBUG_FORTH_PARSE_KEY 
1f3f				DMARK "}AA" 
1f3f				CALLMONITOR 
1f3f			endif	 
1f3f c3 42 20			jp execnext 
1f42				;jp exec1 
1f42			       
1f42			 
1f42			 
1f42			; Another go at the parser to compile  
1f42			 
1f42			 
1f42			; TODO rework parser to change all of the string words to byte tokens 
1f42			; TODO do a search for  
1f42			 
1f42			; TODO first run normal parser to zero term sections 
1f42			; TODO for each word do a token look up to get the op code 
1f42			; TODO need some means to flag to the exec that this is a byte code form    
1f42			 
1f42			 
1f42			forthcompile: 
1f42			 
1f42			; 
1f42			; line parse: 
1f42			;       parse raw input buffer 
1f42			;       tokenise the words 
1f42			;       malloc new copy (for looping etc) 
1f42			;       copy to malloc + current pc in line to start of string and add line term 
1f42			;       save on new rsp 
1f42			; 
1f42			 
1f42			; hl to point to the line to tokenise 
1f42			 
1f42			;	push hl 
1f42 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
1f45			 
1f45			;	ld a,0		; string term on input 
1f45			;	call strlent 
1f45			 
1f45			;	ld (os_tok_len), hl	 ; save string length 
1f45			 
1f45			;if DEBUG_FORTH_TOK 
1f45			;	ex de,hl		 
1f45			;endif 
1f45			 
1f45			;	pop hl 		; get back string pointer 
1f45			 
1f45			if DEBUG_FORTH_TOK 
1f45						DMARK "TOc" 
1f45				CALLMONITOR 
1f45			endif 
1f45 7e			.cptoken2:    ld a,(hl) 
1f46 23				inc hl 
1f47 fe 7f			cp FORTH_END_BUFFER 
1f49 28 29			jr z, .cptokendone2 
1f4b fe 00			cp 0 
1f4d 28 25			jr z, .cptokendone2 
1f4f fe 22			cp '"' 
1f51 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1f53 fe 20			cp ' ' 
1f55 20 ee			jr nz,  .cptoken2 
1f57			 
1f57			; TODO consume comments held between ( and ) 
1f57			 
1f57				; we have a space so change to zero term for dict match later 
1f57 2b				dec hl 
1f58 3e 00			ld a,0 
1f5a 77				ld (hl), a 
1f5b 23				inc hl 
1f5c 18 e7			jr .cptoken2 
1f5e				 
1f5e			 
1f5e			.cptokenstr2: 
1f5e				; skip all white space until either eol (because forgot to term) or end double quote 
1f5e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f5e				;inc hl ; skip current double quote 
1f5e 7e				ld a,(hl) 
1f5f 23				inc hl 
1f60 fe 22			cp '"' 
1f62 28 e1			jr z, .cptoken2 
1f64 fe 7f			cp FORTH_END_BUFFER 
1f66 28 0c			jr z, .cptokendone2 
1f68 fe 00			cp 0 
1f6a 28 08			jr z, .cptokendone2 
1f6c fe 20			cp ' ' 
1f6e 28 02			jr z, .cptmp2 
1f70 18 ec			jr .cptokenstr2 
1f72			 
1f72			.cptmp2:	; we have a space so change to zero term for dict match later 
1f72				;dec hl 
1f72				;ld a,"-"	; TODO remove this when working 
1f72				;ld (hl), a 
1f72				;inc hl 
1f72 18 ea			jr .cptokenstr2 
1f74			 
1f74			.cptokendone2: 
1f74				;inc hl 
1f74 3e 7f			ld a, FORTH_END_BUFFER 
1f76 77				ld (hl),a 
1f77 23				inc hl 
1f78 3e 21			ld a, '!' 
1f7a 77				ld (hl),a 
1f7b			 
1f7b 2a c2 e5			ld hl,(os_tok_ptr) 
1f7e			         
1f7e			if DEBUG_FORTH_TOK 
1f7e						DMARK "Tc1" 
1f7e				CALLMONITOR 
1f7e			endif 
1f7e			 
1f7e				; push exec string to top of return stack 
1f7e				FORTH_RSP_NEXT 
1f7e cd 20 1b			call macro_forth_rsp_next 
1f81				endm 
# End of macro FORTH_RSP_NEXT
1f81 c9				ret 
1f82			 
1f82			; Another go at the parser need to simplify the process 
1f82			 
1f82			forthparse: 
1f82			 
1f82			; 
1f82			; line parse: 
1f82			;       parse raw input buffer 
1f82			;       tokenise the words 
1f82			;       malloc new copy (for looping etc) 
1f82			;       copy to malloc + current pc in line to start of string and add line term 
1f82			;       save on new rsp 
1f82			; 
1f82			 
1f82			; hl to point to the line to tokenise 
1f82			 
1f82			;	push hl 
1f82 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
1f85			 
1f85			;	ld a,0		; string term on input 
1f85			;	call strlent 
1f85			 
1f85			;	ld (os_tok_len), hl	 ; save string length 
1f85			 
1f85			;if DEBUG_FORTH_TOK 
1f85			;	ex de,hl		 
1f85			;endif 
1f85			 
1f85			;	pop hl 		; get back string pointer 
1f85			 
1f85			if DEBUG_FORTH_TOK 
1f85						DMARK "TOK" 
1f85				CALLMONITOR 
1f85			endif 
1f85 7e			.ptoken2:    ld a,(hl) 
1f86 23				inc hl 
1f87 fe 7f			cp FORTH_END_BUFFER 
1f89 28 29			jr z, .ptokendone2 
1f8b fe 00			cp 0 
1f8d 28 25			jr z, .ptokendone2 
1f8f fe 22			cp '"' 
1f91 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1f93 fe 20			cp ' ' 
1f95 20 ee			jr nz,  .ptoken2 
1f97			 
1f97			; TODO consume comments held between ( and ) 
1f97			 
1f97				; we have a space so change to zero term for dict match later 
1f97 2b				dec hl 
1f98 3e 00			ld a,0 
1f9a 77				ld (hl), a 
1f9b 23				inc hl 
1f9c 18 e7			jr .ptoken2 
1f9e				 
1f9e			 
1f9e			.ptokenstr2: 
1f9e				; skip all white space until either eol (because forgot to term) or end double quote 
1f9e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f9e				;inc hl ; skip current double quote 
1f9e 7e				ld a,(hl) 
1f9f 23				inc hl 
1fa0 fe 22			cp '"' 
1fa2 28 e1			jr z, .ptoken2 
1fa4 fe 7f			cp FORTH_END_BUFFER 
1fa6 28 0c			jr z, .ptokendone2 
1fa8 fe 00			cp 0 
1faa 28 08			jr z, .ptokendone2 
1fac fe 20			cp ' ' 
1fae 28 02			jr z, .ptmp2 
1fb0 18 ec			jr .ptokenstr2 
1fb2			 
1fb2			.ptmp2:	; we have a space so change to zero term for dict match later 
1fb2				;dec hl 
1fb2				;ld a,"-"	; TODO remove this when working 
1fb2				;ld (hl), a 
1fb2				;inc hl 
1fb2 18 ea			jr .ptokenstr2 
1fb4			 
1fb4			.ptokendone2: 
1fb4				;inc hl 
1fb4 3e 7f			ld a, FORTH_END_BUFFER 
1fb6 77				ld (hl),a 
1fb7 23				inc hl 
1fb8 3e 21			ld a, '!' 
1fba 77				ld (hl),a 
1fbb			 
1fbb 2a c2 e5			ld hl,(os_tok_ptr) 
1fbe			         
1fbe			if DEBUG_FORTH_TOK 
1fbe						DMARK "TK1" 
1fbe				CALLMONITOR 
1fbe			endif 
1fbe			 
1fbe				; push exec string to top of return stack 
1fbe				FORTH_RSP_NEXT 
1fbe cd 20 1b			call macro_forth_rsp_next 
1fc1				endm 
# End of macro FORTH_RSP_NEXT
1fc1 c9				ret 
1fc2			 
1fc2			; 
1fc2			;	; malloc size + buffer pointer + if is loop flag 
1fc2			;	ld hl,(os_tok_len) 		 ; get string length 
1fc2			; 
1fc2			;	ld a,l 
1fc2			; 
1fc2			;	cp 0			; we dont want to use a null string 
1fc2			;	ret z 
1fc2			; 
1fc2			;;	add 3    ; prefix malloc with buffer for current word ptr 
1fc2			; 
1fc2			;	add 5     ; TODO when certain not over writing memory remove 
1fc2			; 
1fc2			;		 
1fc2			; 
1fc2			;if DEBUG_FORTH_TOK 
1fc2			;			DMARK "TKE" 
1fc2			;	CALLMONITOR 
1fc2			;endif 
1fc2			; 
1fc2			;	ld l,a 
1fc2			;	ld h,0 
1fc2			;;	push hl   ; save required space for the copy later 
1fc2			;	call malloc 
1fc2			;if DEBUG_FORTH_TOK 
1fc2			;			DMARK "TKM" 
1fc2			;	CALLMONITOR 
1fc2			;endif 
1fc2			;	if DEBUG_FORTH_MALLOC_GUARD 
1fc2			;		push af 
1fc2			;		call ishlzero 
1fc2			;;		ld a, l 
1fc2			;;		add h 
1fc2			;;		cp 0 
1fc2			;		pop af 
1fc2			;		 
1fc2			;		call z,malloc_error 
1fc2			;	endif 
1fc2			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1fc2			; 
1fc2			; 
1fc2			;if DEBUG_FORTH_TOK 
1fc2			;			DMARK "TKR" 
1fc2			;	CALLMONITOR 
1fc2			;endif 
1fc2			; 
1fc2			;	FORTH_RSP_NEXT 
1fc2			; 
1fc2			;	;inc hl	 ; go past current buffer pointer 
1fc2			;	;inc hl 
1fc2			;	;inc hl   ; and past if loop flag 
1fc2			;		; TODO Need to set flag  
1fc2			; 
1fc2			;	 
1fc2			;	 
1fc2			;	ex de,hl	; malloc is dest 
1fc2			;	ld hl, (os_tok_len) 
1fc2			;;	pop bc 
1fc2			;	ld c, l                
1fc2			;	ld b,0 
1fc2			;	ld hl, (os_tok_ptr) 
1fc2			; 
1fc2			;if DEBUG_FORTH_TOK 
1fc2			;			DMARK "TKT" 
1fc2			;	CALLMONITOR 
1fc2			;endif 
1fc2			; 
1fc2			;	; do str cpy 
1fc2			; 
1fc2			;	ldir      ; copy byte in hl to de 
1fc2			; 
1fc2			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1fc2			; 
1fc2			;if DEBUG_FORTH_TOK 
1fc2			; 
1fc2			;			DMARK "TKY" 
1fc2			;	CALLMONITOR 
1fc2			;endif 
1fc2			;	;ld a,0 
1fc2			;	;ld a,FORTH_END_BUFFER 
1fc2			;	ex de, hl 
1fc2			;	;dec hl			 ; go back over the space delim at the end of word 
1fc2			;	;ld (hl),a 
1fc2			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1fc2			;	ld a,FORTH_END_BUFFER 
1fc2			;	ld (hl),a 
1fc2			;	inc hl 
1fc2			;	ld a,FORTH_END_BUFFER 
1fc2			;	ld (hl),a 
1fc2			; 
1fc2			;	; init the malloc area data 
1fc2			;	; set pc for in current area 
1fc2			;	;ld hl, (os_tok_malloc) 
1fc2			;	;inc hl 
1fc2			;	;inc hl 
1fc2			;	;inc hl 
1fc2			;	;ex de,hl 
1fc2			;	;ld hl, (os_tok_malloc) 
1fc2			;	;ld (hl),e 
1fc2			;	;inc hl 
1fc2			;	;ld (hl),d 
1fc2			; 
1fc2			; 
1fc2			;	ld hl,(os_tok_malloc) 
1fc2			;if DEBUG_FORTH_PARSE_KEY 
1fc2			;			DMARK "TKU" 
1fc2			;	CALLMONITOR 
1fc2			;endif 
1fc2			; 
1fc2			;	ret 
1fc2			 
1fc2			forthexec: 
1fc2			 
1fc2			; line exec: 
1fc2			; forth parser 
1fc2			 
1fc2			; 
1fc2			;       get current exec line on rsp 
1fc2			 
1fc2				FORTH_RSP_TOS 
1fc2 cd 37 1b			call macro_forth_rsp_tos 
1fc5				endm 
# End of macro FORTH_RSP_TOS
1fc5			 
1fc5			;       restore current pc - hl points to malloc of data 
1fc5			 
1fc5				;ld e, (hl) 
1fc5				;inc hl 
1fc5				;ld d, (hl) 
1fc5				;ex de,hl 
1fc5			 
1fc5			 
1fc5			exec1: 
1fc5 22 c2 e5			ld (os_tok_ptr), hl 
1fc8			 
1fc8				; copy our PC to working vars  
1fc8 22 40 ea			ld (cli_ptr), hl 
1fcb 22 3e ea			ld (cli_origptr), hl 
1fce			 
1fce 7e				ld a,(hl) 
1fcf fe 7f			cp FORTH_END_BUFFER 
1fd1 c8				ret z 
1fd2			 
1fd2				; skip any nulls 
1fd2			 
1fd2 fe 00			cp 0 
1fd4 20 03			jr nz, .execword 
1fd6 23				inc hl 
1fd7 18 ec			jr exec1 
1fd9			 
1fd9			 
1fd9			.execword: 
1fd9			 
1fd9			 
1fd9			 
1fd9			if DEBUG_FORTH_PARSE_KEY 
1fd9						DMARK "KYQ" 
1fd9				CALLMONITOR 
1fd9			endif 
1fd9			;       while at start of word: 
1fd9			; get start of dict (in user area first) 
1fd9			 
1fd9 21 89 5e		ld hl, baseram 
1fdc			;ld hl, sysdict 
1fdc 22 42 ea		ld (cli_nextword),hl 
1fdf			;           match word at pc 
1fdf			;           exec word 
1fdf			;           or push to dsp 
1fdf			;           forward to next token 
1fdf			;           if line term pop rsp and exit 
1fdf			;        
1fdf			 
1fdf			if DEBUG_FORTH_PARSE_KEY 
1fdf						DMARK "KYq" 
1fdf				CALLMONITOR 
1fdf			endif 
1fdf			 
1fdf			; 
1fdf			; word comp 
1fdf			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1fdf			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1fdf			;    move to start of word  
1fdf			;    compare word to cli_token 
1fdf			 
1fdf			.execpnword:	; HL at start of a word in the dictionary to check 
1fdf			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1fdf			;	ld (cli_ptr), hl 
1fdf			 
1fdf 2a 42 ea			ld hl,(cli_nextword) 
1fe2			 
1fe2 cd 85 20			call forth_tok_next 
1fe5			; tok next start here 
1fe5			;	; TODO skip compiled symbol for now 
1fe5			;	inc hl 
1fe5			; 
1fe5			;	; save pointer to next word 
1fe5			; 
1fe5			;	; hl now points to the address of the next word pointer  
1fe5			;	ld e, (hl) 
1fe5			;	inc hl 
1fe5			;	ld d, (hl) 
1fe5			;	inc l 
1fe5			; 
1fe5			;	ex de,hl 
1fe5			;if DEBUG_FORTH_PARSE_NEXTWORD 
1fe5			;	push bc 
1fe5			;	ld bc, (cli_nextword) 
1fe5			;			DMARK "NXW" 
1fe5			;	CALLMONITOR 
1fe5			;	pop bc 
1fe5			;endif 
1fe5			; tok next end here 
1fe5 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
1fe8 eb				ex de, hl 
1fe9			 
1fe9			 
1fe9				; save the pointer of the current token - 1 to check against 
1fe9				 
1fe9 22 46 ea			ld (cli_token), hl   
1fec				; TODO maybe remove below save if no debug 
1fec				; save token string ptr for any debug later 
1fec 23				inc hl  
1fed 22 48 ea			ld (cli_origtoken), hl 
1ff0 2b				dec hl 
1ff1				; save pointer to the start of the next dictionay word 
1ff1 7e				ld a,(hl)   ; get string length 
1ff2 47				ld b,a 
1ff3			.execpnwordinc:  
1ff3 23				inc hl 
1ff4 10 fd			djnz .execpnwordinc 
1ff6 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
1ff9			 
1ff9				; now check the word token against the string being parsed 
1ff9			 
1ff9 2a 46 ea			ld hl,(cli_token) 
1ffc 23				inc hl     ; skip string length (use zero term instead to end) 
1ffd 22 46 ea			ld (cli_token), hl 
2000			 
2000			if DEBUG_FORTH_PARSE_KEY 
2000						DMARK "KY2" 
2000			endif 
2000			if DEBUG_FORTH_PARSE_EXEC 
2000				; see if disabled 
2000			 
2000			;	ld a, (os_view_disable) 
2000			;	cp '*' 
2000				ld a, (debug_vector) 
2000				cp $c9   ; RET  
2000				jr z, .skip 
2000			 
2000				push hl 
2000				push hl 
2000				call clear_display 
2000				ld de, .compword 
2000				ld a, display_row_1 
2000				call str_at_display 
2000				pop de 
2000				ld a, display_row_2 
2000				call str_at_display 
2000				ld hl,(cli_ptr) 
2000				ld a,(hl) 
2000			        ld hl, os_word_scratch 
2000				ld (hl),a 
2000				ld a,0 
2000				inc hl 
2000				ld (hl),a 	 
2000				ld de, os_word_scratch 
2000				ld a, display_row_2+10 
2000				call str_at_display 
2000				call update_display 
2000				ld a, 100 
2000				call aDelayInMS 
2000				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2000				call delay250ms 
2000				endif 
2000				pop hl 
2000			.skip:  
2000			endif	 
2000			.execpnchar:    ; compare char between token and string to parse 
2000			 
2000			if DEBUG_FORTH_PARSE_KEY 
2000						DMARK "Ky3" 
2000			endif 
2000			if DEBUG_FORTH_PARSE_EXEC 
2000				; see if disabled 
2000			 
2000			;	ld a, (os_view_disable) 
2000			;	cp '*' 
2000				ld a, (debug_vector) 
2000				cp $C9  ; RET 
2000				jr z, .skip2 
2000			 
2000			;	call clear_display 
2000			ld hl,(cli_token) 
2000			ld a,(hl) 
2000			ld (os_word_scratch),a 
2000				ld hl,(cli_ptr) 
2000			ld a,(hl) 
2000				ld (os_word_scratch+1),a 
2000				ld a,0 
2000				ld (os_word_scratch+2),a 
2000				ld de,os_word_scratch 
2000				ld a,display_row_4 
2000				call str_at_display 
2000				call update_display 
2000			.skip2:  
2000			endif 
2000 2a 46 ea			ld hl,(cli_token) 
2003 7e				ld a, (hl)	 ; char in word token 
2004 23				inc hl 		; move to next char 
2005 22 46 ea			ld (cli_token), hl ; and save it 
2008 47				ld b,a 
2009			 
2009 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
200c 7e				ld a,(hl) 
200d 23				inc hl 
200e 22 40 ea			ld (cli_ptr), hl		; move to next char 
2011 cd 4f 11			call toUpper 		; make sure the input string matches case 
2014			 
2014			if DEBUG_FORTH_PARSE 
2014			endif 
2014			 
2014				; input stream end of token is a space so get rid of it 
2014			 
2014			;	cp ' ' 
2014			;	jr nz, .pnskipspace 
2014			; 
2014			;	ld a, 0		; make same term as word token term 
2014			; 
2014			;.pnskipspace: 
2014			 
2014			if DEBUG_FORTH_PARSE_KEY 
2014						DMARK "KY7" 
2014			endif 
2014 b8				cp b 
2015 c2 2b 20			jp nz, .execpnskipword	 ; no match so move to next word 
2018				 
2018			;    if same 
2018			;       scan for string terms 0 for token and 32 for input 
2018			 
2018				 
2018			if DEBUG_FORTH_PARSE_KEY 
2018						DMARK "KY8" 
2018			endif 
2018			 
2018 80				add b			 
2019 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
201b							; TODO need to make sure last word in zero term string is accounted for 
201b 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
201d			 
201d			 
201d				; at end of both strings so both are exact match 
201d			 
201d			;       skip ptr for next word 
201d			 
201d 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
2020 23				inc hl			 ; at next char 
2021 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
2024 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2027				 
2027				 
2027			if DEBUG_FORTH_PARSE_KEY 
2027						DMARK "KY3" 
2027			endif 
2027			 
2027			 
2027			 
2027			;       exec code block 
2027			if DEBUG_FORTH_JP 
2027				call clear_display 
2027				call update_display 
2027				call delay1s 
2027				ld hl, (cli_execword)     ; save for next check if no match on this word 
2027				ld a,h 
2027				ld hl, os_word_scratch 
2027				call hexout 
2027				ld hl, (cli_execword)     ; save for next check if no match on this word 
2027				ld a,l 
2027				ld hl, os_word_scratch+2 
2027				call hexout 
2027				ld hl, os_word_scratch+4 
2027				ld a,0 
2027				ld (hl),a 
2027				ld de,os_word_scratch 
2027				call str_at_display 
2027					ld a, display_row_2 
2027					call str_at_display 
2027				ld de, (cli_origtoken) 
2027				ld a, display_row_1+10 
2027					call str_at_display 
2027			 
2027				ld a,display_row_1 
2027				ld de, .foundword 
2027				ld a, display_row_3 
2027				call str_at_display 
2027				call update_display 
2027				call delay1s 
2027				call delay1s 
2027				call delay1s 
2027			endif 
2027			 
2027			if DEBUG_FORTH_PARSE_KEY 
2027						DMARK "KYj" 
2027			endif 
2027				; TODO save the word pointer in this exec 
2027			 
2027 2a 44 ea			ld hl,(cli_execword) 
202a e9				jp (hl) 
202b			 
202b			 
202b			;    if not same 
202b			;	scan for zero term 
202b			;	get ptr for next word 
202b			;	goto word comp 
202b			 
202b			.execpnskipword:	; get pointer to next word 
202b 2a 42 ea			ld hl,(cli_nextword) 
202e			 
202e 7e				ld a,(hl) 
202f fe 00			cp WORD_SYS_END 
2031			;	cp 0 
2031 28 09			jr z, .execendofdict			 ; at end of words 
2033			 
2033			if DEBUG_FORTH_PARSE_KEY 
2033						DMARK "KY4" 
2033			endif 
2033			if DEBUG_FORTH_PARSE_EXEC 
2033			 
2033				; see if disabled 
2033			 
2033			;	ld a, (os_view_disable) 
2033			;	cp '*' 
2033				ld a,(debug_vector) 
2033				cp $c9   ; RET 
2033				jr z, .noskip 
2033			 
2033			 
2033				ld de, .nowordfound 
2033				ld a, display_row_3 
2033				call str_at_display 
2033				call update_display 
2033				ld a, 100 
2033				call aDelayInMS 
2033				 
2033				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2033					call delay250ms 
2033				endif 
2033			.noskip:  
2033			 
2033			endif	 
2033			 
2033 2a 3e ea			ld hl,(cli_origptr) 
2036 22 40 ea			ld (cli_ptr),hl 
2039			 
2039			if DEBUG_FORTH_PARSE_KEY 
2039						DMARK "KY5" 
2039			endif 
2039 c3 df 1f			jp .execpnword			; else go to next word 
203c			 
203c			.execendofdict:  
203c			 
203c			if DEBUG_FORTH_PARSE_KEY 
203c						DMARK "KYe" 
203c			endif 
203c			if DEBUG_FORTH_PARSE_EXEC 
203c				; see if disabled 
203c			 
203c			;	ld a, (os_view_disable) 
203c			;	cp '*' 
203c				ld a,(debug_vector) 
203c				cp $c9   ; ret 
203c				jr z, .ispskip 
203c			 
203c				call clear_display 
203c				call update_display 
203c				call delay1s 
203c				ld de, (cli_origptr) 
203c				ld a, display_row_1 
203c				call str_at_display 
203c				 
203c				ld de, .enddict 
203c				ld a, display_row_3 
203c				call str_at_display 
203c				call update_display 
203c				ld a, 100 
203c				call aDelayInMS 
203c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
203c				call delay1s 
203c				call delay1s 
203c				call delay1s 
203c				endif 
203c			.ispskip:  
203c				 
203c			endif	 
203c			 
203c			 
203c			 
203c				; if the word is not a keyword then must be a literal so push it to stack 
203c			 
203c			; push token to stack to end of word 
203c			 
203c				STACKFRAME ON $1efe $2f9f 
203c				if DEBUG_STACK_IMB 
203c					if ON 
203c						exx 
203c						ld de, $1efe 
203c						ld a, d 
203c						ld hl, curframe 
203c						call hexout 
203c						ld a, e 
203c						ld hl, curframe+2 
203c						call hexout 
203c						ld hl, $1efe 
203c						push hl 
203c						ld hl, $2f9f 
203c						push hl 
203c						exx 
203c					endif 
203c				endif 
203c			endm 
# End of macro STACKFRAME
203c			 
203c 2a c2 e5		ld hl,(os_tok_ptr) 
203f cd e2 1c		call forth_apush 
2042			 
2042				STACKFRAMECHK ON $1efe $2f9f 
2042				if DEBUG_STACK_IMB 
2042					if ON 
2042						exx 
2042						ld hl, $2f9f 
2042						pop de   ; $2f9f 
2042						call cmp16 
2042						jr nz, .spnosame 
2042						ld hl, $1efe 
2042						pop de   ; $1efe 
2042						call cmp16 
2042						jr z, .spfrsame 
2042						.spnosame: call showsperror 
2042						.spfrsame: nop 
2042						exx 
2042					endif 
2042				endif 
2042			endm 
# End of macro STACKFRAMECHK
2042			 
2042			execnext: 
2042			 
2042			if DEBUG_FORTH_PARSE_KEY 
2042						DMARK "KY>" 
2042			endif 
2042			; move past token to next word 
2042			 
2042 2a c2 e5		ld hl, (os_tok_ptr) 
2045 3e 00		ld a, 0 
2047 01 ff 00		ld bc, 255     ; input buffer size 
204a ed b1		cpir 
204c			 
204c			if DEBUG_FORTH_PARSE_KEY 
204c						DMARK "KY!" 
204c				CALLMONITOR 
204c			endif	 
204c			; TODO this might place hl on the null, so will need to forward on??? 
204c			;inc hl   ; see if this gets onto the next item 
204c			 
204c			 
204c			; TODO pass a pointer to the buffer to push 
204c			; TODO call function to push 
204c			 
204c			; look for end of input 
204c			 
204c			;inc hl 
204c			;ld a,(hl) 
204c			;cp FORTH_END_BUFFER 
204c			;ret z 
204c			 
204c			 
204c c3 c5 1f		jp exec1 
204f			 
204f			 
204f			 
204f			 
204f			 
204f			 
204f			 
204f			 
204f			 
204f			findnexttok: 
204f			 
204f				; hl is pointer to move 
204f				; de is the token to locate 
204f			 
204f					if DEBUG_FORTH 
204f						DMARK "NTK" 
204f						CALLMONITOR 
204f					endif 
204f d5				push de 
2050			 
2050			.fnt1:	 
2050				; find first char of token to locate 
2050			 
2050 1a				ld a, (de) 
2051 4f				ld c,a 
2052 7e				ld a,(hl) 
2053 cd 4f 11			call toUpper 
2056					if DEBUG_FORTH 
2056						DMARK "NT1" 
2056						CALLMONITOR 
2056					endif 
2056 b9				cp c 
2057			 
2057 28 03			jr z, .fnt2cmpmorefirst	 
2059			 
2059				; first char not found move to next char 
2059			 
2059 23				inc hl 
205a 18 f4			jr .fnt1 
205c			 
205c			.fnt2cmpmorefirst:	 
205c				; first char of token found.  
205c			 
205c e5				push hl     ; save start of token just in case it is the right one 
205d d9				exx 
205e e1				pop hl        ; save it to hl' 
205f d9				exx 
2060			 
2060			 
2060			.fnt2cmpmore:	 
2060				; compare the rest 
2060				 
2060 23				inc hl 
2061 13				inc de 
2062				 
2062 1a				ld a, (de) 
2063 4f				ld c,a 
2064 7e				ld a,(hl) 
2065 cd 4f 11			call toUpper 
2068			 
2068					if DEBUG_FORTH 
2068						DMARK "NT2" 
2068						CALLMONITOR 
2068					endif 
2068				; c has the token to find char 
2068				; a has the mem to scan char 
2068			 
2068 b9				cp c 
2069 28 04			jr z,.fntmatch1 
206b			 
206b				; they are not the same 
206b			 
206b					if DEBUG_FORTH 
206b						DMARK "NT3" 
206b						CALLMONITOR 
206b					endif 
206b d1				pop de	; reset de token to look for 
206c d5				push de 
206d 18 e1			jr .fnt1 
206f				 
206f			.fntmatch1: 
206f			 
206f				; is the same char a null which means we might have a full hit? 
206f					if DEBUG_FORTH 
206f						DMARK "NT4" 
206f						CALLMONITOR 
206f					endif 
206f			 
206f fe 00			cp 0 
2071 28 0b			jr z, .fntmatchyes 
2073			 
2073				; are we at the end of the token to find? 
2073			 
2073					if DEBUG_FORTH 
2073						DMARK "NT5" 
2073						CALLMONITOR 
2073					endif 
2073 3e 00			ld a, 0 
2075 b9				cp c 
2076			 
2076 c2 60 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2079			 
2079					if DEBUG_FORTH 
2079						DMARK "NT6" 
2079						CALLMONITOR 
2079					endif 
2079				; token to find is exhusted but no match to stream 
2079			 
2079				; restore tok pointer and continue on 
2079 d1				pop de 
207a d5				push de 
207b c3 50 20			jp .fnt1 
207e			 
207e			 
207e			.fntmatchyes: 
207e			 
207e				; hl now contains the end of the found token 
207e			 
207e				; get rid of saved token pointer to find 
207e			 
207e d1				pop de 
207f			 
207f					if DEBUG_FORTH 
207f						DMARK "NT9" 
207f						CALLMONITOR 
207f					endif 
207f			 
207f				; hl will be on the null term so forward on 
207f			 
207f				; get back the saved start of the token 
207f			 
207f d9				exx 
2080 e5				push hl     ; save start of token just in case it is the right one 
2081 d9				exx 
2082 e1				pop hl        ; save it to hl 
2083			 
2083 c9				ret 
2084			 
2084			 
2084			; LIST needs to find a specific token   
2084			; FORGET needs to find a spefici token 
2084			 
2084			; SAVE needs to find all tokens by flag 
2084			; WORDS just needs to scan through all  by flag 
2084			; UWORDS needs to scan through all by flag 
2084			 
2084			 
2084			; given hl as pointer to start of dict look up string 
2084			; return hl as pointer to start of word block 
2084			; or 0 if not found 
2084			 
2084			forth_find_tok: 
2084 c9				ret 
2085			 
2085			; given hl as pointer to dict structure 
2085			; move to the next dict block structure 
2085			 
2085			forth_tok_next: 
2085				; hl now points to the address of the next word pointer  
2085				; TODO skip compiled symbol for now 
2085			;	push de 
2085 23				inc hl 
2086 5e				ld e, (hl) 
2087 23				inc hl 
2088 56				ld d, (hl) 
2089 23				inc hl 
208a			 
208a eb				ex de,hl 
208b			if DEBUG_FORTH_PARSE_NEXTWORD 
208b				push bc 
208b				ld bc, (cli_nextword) 
208b						DMARK "NXW" 
208b				CALLMONITOR 
208b				pop bc 
208b			endif 
208b			;	pop de	 
208b c9				ret 
208c			 
208c			 
208c			 
208c			; eof 
# End of file forth_parserv5.asm
208c				include "forth_wordsv4.asm" 
208c			 
208c			; the core word dictionary v4 
208c			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
208c			 
208c			; this is a linked list for each of the system words used 
208c			; user defined words will follow the same format but will be in ram 
208c			 
208c			 
208c			; 
208c			; 
208c			; define linked list: 
208c			; 
208c			; 1. compiled byte op code 
208c			; 2. len of text word 
208c			; 3. text word 
208c			; 4. ptr to next dictionary word 
208c			; 5. asm, calls etc for the word 
208c			; 
208c			;  if 1 == 0 then last word in dict  
208c			;   
208c			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
208c			;  
208c			;  
208c			; create basic standard set of words 
208c			; 
208c			;  
208c			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
208c			; 2DUP 2DROP 2SWAP  
208c			; @ C@ - get byte  
208c			; ! C! - store byte 
208c			; 0< true if less than zero 
208c			; 0= true if zero 
208c			; < >  
208c			; = true if same 
208c			; variables 
208c			 
208c			 
208c			; Hardware specific words I may need 
208c			; 
208c			; IN OUT  
208c			; calls to key util functions 
208c			; calls to hardward abstraction stuff 
208c			; easy control of frame buffers and lcd i/o 
208c			; keyboard  
208c			 
208c			 
208c			;DICT: macro 
208c			; op_code, len, word, next 
208c			;    word: 
208c			;    db op_code 
208c			;    ds word zero term 
208c			;    dw next 
208c			;    endm 
208c			 
208c			 
208c			 
208c			 
208c			; op code 1 is a flag for user define words which are to be handled differently 
208c			 
208c			 
208c			; 
208c			; 
208c			;    TODO on entry to a word this should be the expected environment 
208c			;    hl - tos value if number then held, if string this is the ptr 
208c			;    de -  
208c			 
208c			 
208c			; opcode ranges 
208c			; 0 - end of word dict 
208c			; 255 - user define words 
208c			 
208c			sysdict: 
208c			include "forth_opcodes.asm" 
208c			; op codes for forth keywords 
208c			; free to use code 0  
208c				OPCODE_HEAP: equ  1 
208c				OPCODE_EXEC: equ 2 
208c				OPCODE_DUP: equ 3 
208c				OPCODE_SWAP: equ 4 
208c				OPCODE_COLN: equ 5 
208c				OPCODE_SCOLN: equ 6 
208c				OPCODE_DROP: equ 7 
208c				OPCODE_DUP2: equ 8 
208c				OPCODE_DROP2: equ 9 
208c				OPCODE_SWAP2: equ 10 
208c				OPCODE_AT: equ 11 
208c				OPCODE_CAT: equ 12 
208c				OPCODE_BANG: equ 13 
208c				OPCODE_CBANG: equ 14 
208c				OPCODE_SCALL: equ 15 
208c				OPCODE_DEPTH: equ 16 
208c				OPCODE_OVER: equ 17 
208c				OPCODE_PAUSE: equ 18 
208c				OPCODE_PAUSES: equ 19 
208c				OPCODE_ROT: equ 20 
208c			;free to reuse	OPCODE_WORDS: equ 21 
208c			        OPCODE_NOT: equ 21 
208c				OPCODE_UWORDS: equ 22 
208c				OPCODE_BP: equ 23 
208c				OPCODE_MONITOR: equ 24  
208c				OPCODE_MALLOC: equ 25 
208c				OPCODE_FREE: equ 26 
208c				OPCODE_LIST: equ 27 
208c				OPCODE_FORGET: equ 28 
208c				OPCODE_NOP: equ 29 
208c				OPCODE_COMO: equ 30 
208c				OPCODE_COMC: equ 31 
208c			;free to reuse	OPCODE_ENDCORE: equ 32 
208c				OPCODE_AFTERSOUND: equ 33 
208c				OPCODE_GP2: equ 34 
208c				OPCODE_GP3: equ 35 
208c				OPCODE_GP4: equ 36 
208c				OPCODE_SIN: equ 37 
208c				OPCODE_SOUT: equ 38 
208c				OPCODE_SPIO: equ 39 
208c				OPCODE_SPICEH: equ 40 
208c				OPCODE_SPIOb: equ 41 
208c				OPCODE_SPII: equ 42 
208c				OPCODE_SESEL: equ 43 
208c				OPCODE_CARTDEV: equ 44 
208c			; free to reuse	OPCODE_ENDDEVICE: equ 45 
208c				OPCODE_FB: equ 46 
208c				OPCODE_EMIT: equ 47 
208c				OPCODE_DOTH: equ 48 
208c				OPCODE_DOTF: equ 49 
208c				OPCODE_DOT: equ 50 
208c				OPCODE_CLS: equ 51 
208c				OPCODE_DRAW: equ 52 
208c				OPCODE_DUMP: equ 53 
208c				OPCODE_CDUMP: equ 54 
208c				OPCODE_DAT: equ 55 
208c				OPCODE_HOME: equ 56 
208c				OPCODE_SPACE: equ 57 
208c				OPCODE_SPACES: equ 58 
208c				OPCODE_SCROLL: equ 59 
208c				OPCODE_ATQ: equ 60 
208c				OPCODE_AUTODSP: equ 61 
208c				OPCODE_MENU: equ 62 
208c			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
208c				OPCODE_THEN: equ 64 
208c				OPCODE_ELSE: equ 65 
208c				OPCODE_DO: equ 66 
208c				OPCODE_LOOP: equ 67 
208c				OPCODE_I: equ 68 
208c				OPCODE_DLOOP: equ 69  
208c				OPCODE_REPEAT: equ 70  
208c				OPCODE_UNTIL: equ 71 
208c				OPCODE_ENDFLOW: equ 72 
208c				OPCODE_WAITK: equ 73 
208c				OPCODE_ACCEPT: equ 74 
208c				OPCODE_EDIT: equ 75 
208c			;free to reuse	OPCODE_ENDKEY: equ 76 
208c				OPCODE_LZERO: equ 77 
208c				OPCODE_TZERO: equ 78 
208c				OPCODE_LESS: equ 79 
208c				OPCODE_GT: equ 80 
208c				OPCODE_EQUAL: equ 81  
208c			;free to reuse	OPCODE_ENDLOGIC: equ 82 
208c				OPCODE_NEG: equ 83 
208c				OPCODE_DIV: equ 84 
208c				OPCODE_MUL: equ 85 
208c				OPCODE_MIN: equ 86 
208c				OPCODE_MAX: equ 87 
208c				OPCODE_RND16: equ 88 
208c				OPCODE_RND8: equ 89 
208c				OPCODE_RND: equ 90 
208c			;free to reuse	OPCODE_ENDMATHS: equ 91  
208c				OPCODE_BYNAME: equ 92 
208c				OPCODE_DIR: equ 93 
208c				OPCODE_SAVE: equ 94 
208c				OPCODE_LOAD: equ 95 
208c				OPCODE_BSAVE: equ 96 
208c				OPCODE_BLOAD: equ 97 
208c				OPCODE_SEO: equ 98  
208c				OPCODE_SEI: equ 99 
208c				OPCODE_SFREE: equ 100 
208c				OPCODE_SIZE: equ 101 
208c				OPCODE_CREATE: equ 102 
208c				OPCODE_APPEND: equ 103 
208c				OPCODE_SDEL: equ 104 
208c				OPCODE_OPEN: equ 105 
208c				OPCODE_READ: equ 106 
208c				OPCODE_EOF: equ 106 
208c				OPCODE_FORMAT: equ 107 
208c				OPCODE_LABEL: equ 108 
208c				OPCODE_LABELS: equ 109 
208c			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
208c				OPCODE_UPPER: equ 111 
208c				OPCODE_LOWER: equ 112 
208c				OPCODE_SUBSTR: equ 113 
208c				OPCODE_LEFT: equ 114 
208c				OPCODE_RIGHT: equ 115 
208c				OPCODE_STR2NUM: equ 116 
208c				OPCODE_NUM2STR: equ 117 
208c				OPCODE_CONCAT: equ 118 
208c				OPCODE_FIND: equ 119 
208c				OPCODE_LEN: equ 120 
208c				OPCODE_CHAR: equ 121 
208c			; free to reuse	OPCODE_STRLEN: equ 122 
208c			; free to reuse	OPCODE_ENDSTR: equ 123 
208c				OPCODE_V0S: equ 124 
208c				OPCODE_V0Q: equ 125 
208c				OPCODE_V1S: equ 126 
208c				OPCODE_V1Q: equ 127 
208c				OPCODE_V2S: equ 128 
208c				OPCODE_V2Q: equ 129 
208c				OPCODE_V3S: equ 130 
208c				OPCODE_V3Q: equ 131 
208c			;free to reuse	OPCODE_END: equ 132 
208c				OPCODE_ZDUP: equ 133 
208c			 
208c			; eof 
# End of file forth_opcodes.asm
208c			 
208c			include "forth_words_core.asm" 
208c			 
208c			; | ## Core Words 
208c			 
208c			;if MALLOC_4 
208c			 
208c			.HEAP: 
208c			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
208c 15				db WORD_SYS_CORE+OPCODE_HEAP             
208d cb 20			dw .EXEC            
208f 05				db 4 + 1 
2090 .. 00			db "HEAP",0              
2095				endm 
# End of macro CWHEAD
2095			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2095			; | | u1 - Current number of bytes in the heap 
2095			; | | u2 - Remaining bytes left on the heap 
2095			; | |  
2095			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2095			 
2095			 
2095				if DEBUG_FORTH_WORDS_KEY 
2095					DMARK "HEP" 
2095 f5				push af  
2096 3a aa 20			ld a, (.dmark)  
2099 32 6b ee			ld (debug_mark),a  
209c 3a ab 20			ld a, (.dmark+1)  
209f 32 6c ee			ld (debug_mark+1),a  
20a2 3a ac 20			ld a, (.dmark+2)  
20a5 32 6d ee			ld (debug_mark+2),a  
20a8 18 03			jr .pastdmark  
20aa ..			.dmark: db "HEP"  
20ad f1			.pastdmark: pop af  
20ae			endm  
# End of macro DMARK
20ae					CALLMONITOR 
20ae cd 6f ee			call debug_vector  
20b1				endm  
# End of macro CALLMONITOR
20b1				endif 
20b1 2a 93 5e			ld hl, (free_list )      
20b4 11 98 5e			ld de, heap_start 
20b7			 
20b7 ed 52			sbc hl, de  
20b9			 
20b9 cd 79 1b			call forth_push_numhl 
20bc			 
20bc			 
20bc ed 5b 93 5e		ld de, (free_list )      
20c0 21 9c e2			ld hl, heap_end 
20c3			 
20c3 ed 52			sbc hl, de 
20c5			 
20c5 cd 79 1b			call forth_push_numhl 
20c8				 
20c8			 
20c8				 
20c8			 
20c8			 
20c8			 
20c8				NEXTW 
20c8 c3 34 1f			jp macro_next 
20cb				endm 
# End of macro NEXTW
20cb			;endif 
20cb			 
20cb			.EXEC: 
20cb			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
20cb			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
20cb			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
20cb			;; > > 
20cb			;; > >   
20cb			;	STACKFRAME OFF $5efe $5f9f 
20cb			; 
20cb			;		if DEBUG_FORTH_WORDS_KEY 
20cb			;			DMARK "EXE" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			; 
20cb			;	FORTH_DSP_VALUEHL 
20cb			; 
20cb			;	FORTH_DSP_POP 
20cb			; 
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EX1" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			;;	ld e,(hl) 
20cb			;;	inc hl 
20cb			;;	ld d,(hl) 
20cb			;;	ex de,hl 
20cb			; 
20cb			;;		if DEBUG_FORTH_WORDS 
20cb			;;			DMARK "EX2" 
20cb			;;			CALLMONITOR 
20cb			;;		endif 
20cb			;	push hl 
20cb			; 
20cb			;	;ld a, 0 
20cb			;	;ld a, FORTH_END_BUFFER 
20cb			;	call strlenz 
20cb			;	inc hl   ; include zero term to copy 
20cb			;	inc hl   ; include term 
20cb			;	inc hl   ; include term 
20cb			;	ld b,0 
20cb			;	ld c,l 
20cb			;	pop hl 
20cb			;	ld de, execscratch 
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EX3" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			;	ldir 
20cb			; 
20cb			; 
20cb			;	ld hl, execscratch 
20cb			; 
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EXe" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			; 
20cb			;	call forthparse 
20cb			;	call forthexec 
20cb			;;	call forthexec_cleanup 
20cb			;;	call forthparse 
20cb			;;	call forthexec 
20cb			; 
20cb			;	STACKFRAMECHK OFF $5efe $5f9f 
20cb			; 
20cb			;	; an immediate word so no need to process any more words 
20cb			;	ret 
20cb			;	NEXTW 
20cb			 
20cb			; dead code - old version  
20cb			;	FORTH_RSP_NEXT 
20cb			 
20cb			;  
20cb			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
20cb			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
20cb			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
20cb			;	push hl 
20cb			;	push de 
20cb			;	push bc 
20cb			; 
20cb			; 
20cb			;		if DEBUG_FORTH_WORDS_KEY 
20cb			;			DMARK "EXR" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			; 
20cb			; 
20cb			; 
20cb			;	;v5 FORTH_DSP_VALUE 
20cb			;	FORTH_DSP_VALUEHL 
20cb			; 
20cb			;	; TODO do string type checks 
20cb			; 
20cb			;;v5	inc hl   ; skip type 
20cb			; 
20cb			;	push hl  ; source code  
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EX1" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			;	ld a, 0 
20cb			;	call strlent 
20cb			; 
20cb			;	inc hl 
20cb			;	inc hl 
20cb			;	inc hl 
20cb			;	inc hl 
20cb			; 
20cb			;	push hl    ; size 
20cb			; 
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EX2" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			;	call malloc 
20cb			; 
20cb			;	ex de, hl    ; de now contains malloc area 
20cb			;	pop bc   	; get byte count 
20cb			;	pop hl      ; get string to copy 
20cb			; 
20cb			;	push de     ; save malloc for free later 
20cb			; 
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EX3" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			;	ldir       ; duplicate string 
20cb			; 
20cb			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
20cb			;	 
20cb			;	; TODO fix the parse would be better than this...  
20cb			;	ex de, hl 
20cb			;	dec hl 
20cb			;	ld a, 0 
20cb			;	ld (hl), a 
20cb			;	dec hl 
20cb			;	ld a, ' ' 
20cb			;	ld (hl), a 
20cb			;	dec hl 
20cb			;	ld (hl), a 
20cb			; 
20cb			;	dec hl 
20cb			;	ld (hl), a 
20cb			; 
20cb			; 
20cb			;	FORTH_DSP_POP  
20cb			; 
20cb			;	pop hl     
20cb			;	push hl    ; save malloc area 
20cb			; 
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EX4" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			; 
20cb			;	call forthparse 
20cb			;	call forthexec 
20cb			;	 
20cb			;	pop hl 
20cb			;	if DEBUG_FORTH_WORDS 
20cb			;		DMARK "EX5" 
20cb			;		CALLMONITOR 
20cb			;	endif 
20cb			; 
20cb			;	if FORTH_ENABLE_FREE 
20cb			;	call free 
20cb			;	endif 
20cb			; 
20cb			;	if DEBUG_FORTH_WORDS 
20cb			;		DMARK "EX6" 
20cb			;		CALLMONITOR 
20cb			;	endif 
20cb			; 
20cb			;	pop bc 
20cb			;	pop de 
20cb			;	pop hl 
20cb			;;	FORTH_RSP_POP	  
20cb			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
20cb			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
20cb			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
20cb			; 
20cb			;	if DEBUG_FORTH_WORDS 
20cb			;		DMARK "EX7" 
20cb			;		CALLMONITOR 
20cb			;	endif 
20cb			;	NEXTW 
20cb			 
20cb			;.STKEXEC: 
20cb			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
20cb			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
20cb			; 
20cb			; 
20cb			;		if DEBUG_FORTH_WORDS_KEY 
20cb			;			DMARK "STX" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			; 
20cb			;	FORTH_DSP_VALUEHL 
20cb			; 
20cb			;	ld (store_tmp1), hl    ; count 
20cb			; 
20cb			;	FORTH_DSP_POP 
20cb			;.stkexec1: 
20cb			;	ld hl, (store_tmp1)   ; count 
20cb			;	ld a, 0 
20cb			;	cp l 
20cb			;	ret z 
20cb			; 
20cb			;	dec hl 
20cb			;	ld (store_tmp1), hl    ; count 
20cb			;	 
20cb			;	FORTH_DSP_VALUEHL 
20cb			;	push hl 
20cb			;	 
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EXp" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			;	FORTH_DSP_POP 
20cb			; 
20cb			;	call strlenz 
20cb			;	inc hl   ; include zero term to copy 
20cb			;	inc hl   ; include zero term to copy 
20cb			;	inc hl   ; include zero term to copy 
20cb			;	ld b,0 
20cb			;	ld c,l 
20cb			;	pop hl 
20cb			;	ld de, execscratch 
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EX3" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			;	ldir 
20cb			; 
20cb			; 
20cb			;	ld hl, execscratch 
20cb			; 
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EXP" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			; 
20cb			;	call forthparse 
20cb			;	ld hl, execscratch 
20cb			;		if DEBUG_FORTH_WORDS 
20cb			;			DMARK "EXx" 
20cb			;			CALLMONITOR 
20cb			;		endif 
20cb			;	call forthexec 
20cb			; 
20cb			;	jp .stkexec1 
20cb			; 
20cb			;	ret 
20cb			 
20cb			 
20cb			.DUP: 
20cb			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
20cb 17				db WORD_SYS_CORE+OPCODE_DUP             
20cc 41 21			dw .ZDUP            
20ce 04				db 3 + 1 
20cf .. 00			db "DUP",0              
20d3				endm 
# End of macro CWHEAD
20d3			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
20d3			 
20d3				if DEBUG_FORTH_WORDS_KEY 
20d3					DMARK "DUP" 
20d3 f5				push af  
20d4 3a e8 20			ld a, (.dmark)  
20d7 32 6b ee			ld (debug_mark),a  
20da 3a e9 20			ld a, (.dmark+1)  
20dd 32 6c ee			ld (debug_mark+1),a  
20e0 3a ea 20			ld a, (.dmark+2)  
20e3 32 6d ee			ld (debug_mark+2),a  
20e6 18 03			jr .pastdmark  
20e8 ..			.dmark: db "DUP"  
20eb f1			.pastdmark: pop af  
20ec			endm  
# End of macro DMARK
20ec					CALLMONITOR 
20ec cd 6f ee			call debug_vector  
20ef				endm  
# End of macro CALLMONITOR
20ef				endif 
20ef			 
20ef				FORTH_DSP 
20ef cd 44 1d			call macro_forth_dsp 
20f2				endm 
# End of macro FORTH_DSP
20f2			 
20f2 7e				ld a, (HL) 
20f3 fe 01			cp DS_TYPE_STR 
20f5 20 25			jr nz, .dupinum 
20f7			 
20f7				; push another string 
20f7			 
20f7				FORTH_DSP_VALUEHL     		 
20f7 cd 7e 1d			call macro_dsp_valuehl 
20fa				endm 
# End of macro FORTH_DSP_VALUEHL
20fa			 
20fa			if DEBUG_FORTH_WORDS 
20fa				DMARK "DUs" 
20fa f5				push af  
20fb 3a 0f 21			ld a, (.dmark)  
20fe 32 6b ee			ld (debug_mark),a  
2101 3a 10 21			ld a, (.dmark+1)  
2104 32 6c ee			ld (debug_mark+1),a  
2107 3a 11 21			ld a, (.dmark+2)  
210a 32 6d ee			ld (debug_mark+2),a  
210d 18 03			jr .pastdmark  
210f ..			.dmark: db "DUs"  
2112 f1			.pastdmark: pop af  
2113			endm  
# End of macro DMARK
2113				CALLMONITOR 
2113 cd 6f ee			call debug_vector  
2116				endm  
# End of macro CALLMONITOR
2116			endif 
2116 cd e7 1b			call forth_push_str 
2119			 
2119				NEXTW 
2119 c3 34 1f			jp macro_next 
211c				endm 
# End of macro NEXTW
211c			 
211c			 
211c			.dupinum: 
211c				 
211c			 
211c			 
211c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
211c cd 7e 1d			call macro_dsp_valuehl 
211f				endm 
# End of macro FORTH_DSP_VALUEHL
211f			 
211f			; TODO add floating point number detection 
211f			 
211f			if DEBUG_FORTH_WORDS 
211f				DMARK "DUi" 
211f f5				push af  
2120 3a 34 21			ld a, (.dmark)  
2123 32 6b ee			ld (debug_mark),a  
2126 3a 35 21			ld a, (.dmark+1)  
2129 32 6c ee			ld (debug_mark+1),a  
212c 3a 36 21			ld a, (.dmark+2)  
212f 32 6d ee			ld (debug_mark+2),a  
2132 18 03			jr .pastdmark  
2134 ..			.dmark: db "DUi"  
2137 f1			.pastdmark: pop af  
2138			endm  
# End of macro DMARK
2138				CALLMONITOR 
2138 cd 6f ee			call debug_vector  
213b				endm  
# End of macro CALLMONITOR
213b			endif 
213b			 
213b cd 79 1b			call forth_push_numhl 
213e				NEXTW 
213e c3 34 1f			jp macro_next 
2141				endm 
# End of macro NEXTW
2141			.ZDUP: 
2141			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2141 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2142 79 21			dw .SWAP            
2144 05				db 4 + 1 
2145 .. 00			db "?DUP",0              
214a				endm 
# End of macro CWHEAD
214a			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
214a			 
214a				if DEBUG_FORTH_WORDS_KEY 
214a					DMARK "qDU" 
214a f5				push af  
214b 3a 5f 21			ld a, (.dmark)  
214e 32 6b ee			ld (debug_mark),a  
2151 3a 60 21			ld a, (.dmark+1)  
2154 32 6c ee			ld (debug_mark+1),a  
2157 3a 61 21			ld a, (.dmark+2)  
215a 32 6d ee			ld (debug_mark+2),a  
215d 18 03			jr .pastdmark  
215f ..			.dmark: db "qDU"  
2162 f1			.pastdmark: pop af  
2163			endm  
# End of macro DMARK
2163					CALLMONITOR 
2163 cd 6f ee			call debug_vector  
2166				endm  
# End of macro CALLMONITOR
2166				endif 
2166				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2166 cd 7e 1d			call macro_dsp_valuehl 
2169				endm 
# End of macro FORTH_DSP_VALUEHL
2169			 
2169 e5				push hl 
216a			 
216a				; is it a zero? 
216a			 
216a 3e 00			ld a, 0 
216c 84				add h 
216d 85				add l 
216e			 
216e e1				pop hl 
216f			 
216f fe 00			cp 0 
2171 28 03			jr z, .dup2orig 
2173			 
2173			 
2173 cd 79 1b			call forth_push_numhl 
2176			 
2176			 
2176			; TODO add floating point number detection 
2176			 
2176			.dup2orig: 
2176			 
2176				NEXTW 
2176 c3 34 1f			jp macro_next 
2179				endm 
# End of macro NEXTW
2179			.SWAP: 
2179			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2179 18				db WORD_SYS_CORE+OPCODE_SWAP             
217a b8 21			dw .COLN            
217c 05				db 4 + 1 
217d .. 00			db "SWAP",0              
2182				endm 
# End of macro CWHEAD
2182			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2182				if DEBUG_FORTH_WORDS_KEY 
2182					DMARK "SWP" 
2182 f5				push af  
2183 3a 97 21			ld a, (.dmark)  
2186 32 6b ee			ld (debug_mark),a  
2189 3a 98 21			ld a, (.dmark+1)  
218c 32 6c ee			ld (debug_mark+1),a  
218f 3a 99 21			ld a, (.dmark+2)  
2192 32 6d ee			ld (debug_mark+2),a  
2195 18 03			jr .pastdmark  
2197 ..			.dmark: db "SWP"  
219a f1			.pastdmark: pop af  
219b			endm  
# End of macro DMARK
219b					CALLMONITOR 
219b cd 6f ee			call debug_vector  
219e				endm  
# End of macro CALLMONITOR
219e				endif 
219e			 
219e			; TODO Use os stack swap memory 
219e				FORTH_DSP_VALUEHL 
219e cd 7e 1d			call macro_dsp_valuehl 
21a1				endm 
# End of macro FORTH_DSP_VALUEHL
21a1 e5				push hl     ; w2 
21a2			 
21a2				FORTH_DSP_POP 
21a2 cd 36 1e			call macro_forth_dsp_pop 
21a5				endm 
# End of macro FORTH_DSP_POP
21a5			 
21a5				FORTH_DSP_VALUEHL 
21a5 cd 7e 1d			call macro_dsp_valuehl 
21a8				endm 
# End of macro FORTH_DSP_VALUEHL
21a8			 
21a8				FORTH_DSP_POP 
21a8 cd 36 1e			call macro_forth_dsp_pop 
21ab				endm 
# End of macro FORTH_DSP_POP
21ab			 
21ab d1				pop de     ; w2	, hl = w1 
21ac			 
21ac eb				ex de, hl 
21ad d5				push de 
21ae			 
21ae cd 79 1b			call forth_push_numhl 
21b1			 
21b1 e1				pop hl 
21b2			 
21b2 cd 79 1b			call forth_push_numhl 
21b5				 
21b5			 
21b5				NEXTW 
21b5 c3 34 1f			jp macro_next 
21b8				endm 
# End of macro NEXTW
21b8			.COLN: 
21b8			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
21b8 19				db WORD_SYS_CORE+OPCODE_COLN             
21b9 44 23			dw .SCOLN            
21bb 02				db 1 + 1 
21bc .. 00			db ":",0              
21be				endm 
# End of macro CWHEAD
21be			; | : ( -- )         Create new word | DONE 
21be			 
21be				if DEBUG_FORTH_WORDS_KEY 
21be					DMARK "CLN" 
21be f5				push af  
21bf 3a d3 21			ld a, (.dmark)  
21c2 32 6b ee			ld (debug_mark),a  
21c5 3a d4 21			ld a, (.dmark+1)  
21c8 32 6c ee			ld (debug_mark+1),a  
21cb 3a d5 21			ld a, (.dmark+2)  
21ce 32 6d ee			ld (debug_mark+2),a  
21d1 18 03			jr .pastdmark  
21d3 ..			.dmark: db "CLN"  
21d6 f1			.pastdmark: pop af  
21d7			endm  
# End of macro DMARK
21d7					CALLMONITOR 
21d7 cd 6f ee			call debug_vector  
21da				endm  
# End of macro CALLMONITOR
21da				endif 
21da			STACKFRAME OFF $8efe $989f 
21da				if DEBUG_STACK_IMB 
21da					if OFF 
21da						exx 
21da						ld de, $8efe 
21da						ld a, d 
21da						ld hl, curframe 
21da						call hexout 
21da						ld a, e 
21da						ld hl, curframe+2 
21da						call hexout 
21da						ld hl, $8efe 
21da						push hl 
21da						ld hl, $989f 
21da						push hl 
21da						exx 
21da					endif 
21da				endif 
21da			endm 
# End of macro STACKFRAME
21da			; get parser buffer length  of new word 
21da			 
21da			 
21da			 
21da				; move tok past this to start of name defintition 
21da				; TODO get word to define 
21da				; TODO Move past word token 
21da				; TODO get length of string up to the ';' 
21da			 
21da 2a c2 e5		ld hl, (os_tok_ptr) 
21dd 23			inc hl 
21de 23			inc hl 
21df			 
21df 3e 3b		ld a, ';' 
21e1 cd 63 11		call strlent 
21e4			 
21e4 7d			ld a,l 
21e5 32 b1 e2		ld (os_new_parse_len), a 
21e8			 
21e8			 
21e8			if DEBUG_FORTH_UWORD 
21e8 ed 5b c2 e5	ld de, (os_tok_ptr) 
21ec					DMARK ":01" 
21ec f5				push af  
21ed 3a 01 22			ld a, (.dmark)  
21f0 32 6b ee			ld (debug_mark),a  
21f3 3a 02 22			ld a, (.dmark+1)  
21f6 32 6c ee			ld (debug_mark+1),a  
21f9 3a 03 22			ld a, (.dmark+2)  
21fc 32 6d ee			ld (debug_mark+2),a  
21ff 18 03			jr .pastdmark  
2201 ..			.dmark: db ":01"  
2204 f1			.pastdmark: pop af  
2205			endm  
# End of macro DMARK
2205			CALLMONITOR 
2205 cd 6f ee			call debug_vector  
2208				endm  
# End of macro CALLMONITOR
2208			endif 
2208			 
2208			; 
2208			;  new word memory layout: 
2208			;  
2208			;    : adg 6666 ;  
2208			; 
2208			;    db   1     ; user defined word  
2208 23			inc hl    
2209			;    dw   sysdict 
2209 23			inc hl 
220a 23			inc hl 
220b			;    db <word len>+1 (for null) 
220b 23			inc hl 
220c			;    db .... <word> 
220c			; 
220c			 
220c 23			inc hl    ; some extras for the word preamble before the above 
220d 23			inc hl 
220e 23			inc hl 
220f 23			inc hl 
2210 23			inc hl 
2211 23			inc hl 
2212 23			inc hl  
2213 23			inc hl 
2214 23			inc hl 
2215 23			inc hl 
2216 23			inc hl 
2217 23			inc hl 
2218 23			inc hl 
2219 23			inc hl     ; TODO how many do we really need?     maybe only 6 
221a			;       exec word buffer 
221a			;	<ptr word>   
221a 23			inc hl 
221b 23			inc hl 
221c			;       <word list><null term> 7F final term 
221c			 
221c			 
221c			if DEBUG_FORTH_UWORD 
221c					DMARK ":02" 
221c f5				push af  
221d 3a 31 22			ld a, (.dmark)  
2220 32 6b ee			ld (debug_mark),a  
2223 3a 32 22			ld a, (.dmark+1)  
2226 32 6c ee			ld (debug_mark+1),a  
2229 3a 33 22			ld a, (.dmark+2)  
222c 32 6d ee			ld (debug_mark+2),a  
222f 18 03			jr .pastdmark  
2231 ..			.dmark: db ":02"  
2234 f1			.pastdmark: pop af  
2235			endm  
# End of macro DMARK
2235			CALLMONITOR 
2235 cd 6f ee			call debug_vector  
2238				endm  
# End of macro CALLMONITOR
2238			endif 
2238			 
2238			 
2238				; malloc the size 
2238			 
2238 cd cd 11			call malloc 
223b 22 b3 e2			ld (os_new_malloc), hl     ; save malloc start 
223e			 
223e			;    db   1     ; user defined word  
223e 3e 01			ld a, WORD_SYS_UWORD  
2240 77				ld (hl), a 
2241			 
2241 23			inc hl    
2242			;    dw   sysdict 
2242 11 8c 20		ld de, sysdict       ; continue on with the scan to the system dict 
2245 73			ld (hl), e 
2246 23			inc hl 
2247 72			ld (hl), d 
2248 23			inc hl 
2249			 
2249			 
2249			;    Setup dict word 
2249			 
2249 23			inc hl 
224a 22 ad e2		ld (os_new_work_ptr), hl     ; save start of dict word  
224d			 
224d			; 1. get length of dict word 
224d			 
224d			 
224d 2a c2 e5		ld hl, (os_tok_ptr) 
2250 23			inc hl 
2251 23			inc hl    ; position to start of dict word 
2252 3e 00		ld a, 0 
2254 cd 63 11		call strlent 
2257			 
2257			 
2257 23			inc hl    ; to include null??? 
2258			 
2258			; write length of dict word 
2258			 
2258 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
225c 1b			dec de 
225d eb			ex de, hl 
225e 73			ld (hl), e 
225f eb			ex de, hl 
2260			 
2260			 
2260			 
2260			; copy  
2260 4d			ld c, l 
2261 06 00		ld b, 0 
2263 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2267 2a c2 e5		ld hl, (os_tok_ptr) 
226a 23			inc hl 
226b 23			inc hl    ; position to start of dict word 
226c			 
226c			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
226c			 
226c			; TODO need to convert word to upper case 
226c			 
226c			ucasetok:	 
226c 7e			ld a,(hl) 
226d cd 4f 11		call toUpper 
2270 77			ld (hl),a 
2271 ed a0		ldi 
2273 f2 6c 22		jp p, ucasetok 
2276			 
2276			 
2276			 
2276			; de now points to start of where the word body code should be placed 
2276 ed 53 ad e2	ld (os_new_work_ptr), de 
227a			; hl now points to the words to throw at forthexec which needs to be copied 
227a 22 ab e2		ld (os_new_src_ptr), hl 
227d			 
227d			; TODO add 'call to forthexec' 
227d			 
227d			if DEBUG_FORTH_UWORD 
227d c5			push bc 
227e ed 4b b3 e2	ld bc, (os_new_malloc) 
2282					DMARK ":0x" 
2282 f5				push af  
2283 3a 97 22			ld a, (.dmark)  
2286 32 6b ee			ld (debug_mark),a  
2289 3a 98 22			ld a, (.dmark+1)  
228c 32 6c ee			ld (debug_mark+1),a  
228f 3a 99 22			ld a, (.dmark+2)  
2292 32 6d ee			ld (debug_mark+2),a  
2295 18 03			jr .pastdmark  
2297 ..			.dmark: db ":0x"  
229a f1			.pastdmark: pop af  
229b			endm  
# End of macro DMARK
229b			CALLMONITOR 
229b cd 6f ee			call debug_vector  
229e				endm  
# End of macro CALLMONITOR
229e c1			pop bc 
229f			endif 
229f			 
229f			 
229f			; create word preamble which should be: 
229f			 
229f			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
229f			 
229f			;    ld hl, <word code> 
229f			;    jp user_exec 
229f			;    <word code bytes> 
229f			 
229f			 
229f			;	inc de     ; TODO ??? or are we already past the word's null 
229f eb			ex de, hl 
22a0			 
22a0 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
22a2			 
22a2 23			inc hl 
22a3 22 a7 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
22a6 23			inc hl 
22a7			 
22a7 23			inc hl 
22a8 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
22aa			 
22aa 01 22 4c		ld bc, user_exec 
22ad 23			inc hl 
22ae 71			ld (hl), c     ; poke address of user_exec 
22af 23			inc hl 
22b0 70			ld (hl), b     
22b1			; 
22b1			;	inc hl 
22b1			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
22b1			; 
22b1			; 
22b1			;	ld bc, macro_forth_rsp_next 
22b1			;	inc hl 
22b1			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
22b1			;	inc hl 
22b1			;	ld (hl), b     
22b1			; 
22b1			;	inc hl 
22b1			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
22b1			; 
22b1			; 
22b1			;	inc hl 
22b1			;	ld bc, forthexec 
22b1			;	ld (hl), c     ; poke address of forthexec 
22b1			;	inc hl 
22b1			;	ld (hl), b      
22b1			; 
22b1			;	inc hl 
22b1			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
22b1			; 
22b1			;	ld bc, user_dict_next 
22b1			;	inc hl 
22b1			;	ld (hl), c     ; poke address of forthexec 
22b1			;	inc hl 
22b1			;	ld (hl), b      
22b1			 
22b1			; hl is now where we need to copy the word byte data to save this 
22b1			 
22b1 23			inc hl 
22b2 22 a9 e2		ld (os_new_exec), hl 
22b5			 
22b5			; copy definition 
22b5			 
22b5 eb			ex de, hl 
22b6			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
22b6			;	inc de    ; skip the PC for this parse 
22b6 3a b1 e2		ld a, (os_new_parse_len) 
22b9 4f			ld c, a 
22ba 06 00		ld b, 0 
22bc ed b0		ldir		 ; copy defintion 
22be			 
22be			 
22be			; poke the address of where the new word bytes live for forthexec 
22be			 
22be 2a a7 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
22c1			 
22c1 ed 5b a9 e2	ld de, (os_new_exec)      
22c5			 
22c5 73			ld (hl), e 
22c6 23			inc hl 
22c7 72			ld (hl), d 
22c8			 
22c8				; TODO copy last user dict word next link to this word 
22c8				; TODO update last user dict word to point to this word 
22c8			; 
22c8			; hl f923 de 812a ; bc 811a 
22c8			 
22c8			if DEBUG_FORTH_UWORD 
22c8 c5			push bc 
22c9 ed 4b b3 e2	ld bc, (os_new_malloc) 
22cd					DMARK ":0A" 
22cd f5				push af  
22ce 3a e2 22			ld a, (.dmark)  
22d1 32 6b ee			ld (debug_mark),a  
22d4 3a e3 22			ld a, (.dmark+1)  
22d7 32 6c ee			ld (debug_mark+1),a  
22da 3a e4 22			ld a, (.dmark+2)  
22dd 32 6d ee			ld (debug_mark+2),a  
22e0 18 03			jr .pastdmark  
22e2 ..			.dmark: db ":0A"  
22e5 f1			.pastdmark: pop af  
22e6			endm  
# End of macro DMARK
22e6			CALLMONITOR 
22e6 cd 6f ee			call debug_vector  
22e9				endm  
# End of macro CALLMONITOR
22e9 c1			pop bc 
22ea			endif 
22ea			if DEBUG_FORTH_UWORD 
22ea c5			push bc 
22eb ed 4b b3 e2	ld bc, (os_new_malloc) 
22ef 03			inc bc 
22f0 03			inc bc 
22f1 03			inc bc 
22f2 03			inc bc 
22f3 03			inc bc 
22f4 03			inc bc 
22f5 03			inc bc 
22f6 03			inc bc 
22f7			 
22f7					DMARK ":0B" 
22f7 f5				push af  
22f8 3a 0c 23			ld a, (.dmark)  
22fb 32 6b ee			ld (debug_mark),a  
22fe 3a 0d 23			ld a, (.dmark+1)  
2301 32 6c ee			ld (debug_mark+1),a  
2304 3a 0e 23			ld a, (.dmark+2)  
2307 32 6d ee			ld (debug_mark+2),a  
230a 18 03			jr .pastdmark  
230c ..			.dmark: db ":0B"  
230f f1			.pastdmark: pop af  
2310			endm  
# End of macro DMARK
2310			CALLMONITOR 
2310 cd 6f ee			call debug_vector  
2313				endm  
# End of macro CALLMONITOR
2313 c1			pop bc 
2314			endif 
2314			 
2314			; update word dict linked list for new word 
2314			 
2314			 
2314 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2317 23			inc hl     ; move to next work linked list ptr 
2318			 
2318 ed 5b b3 e2	ld de, (os_new_malloc)		 ; new next word 
231c 73			ld (hl), e 
231d 23			inc hl 
231e 72			ld (hl), d 
231f			 
231f			if DEBUG_FORTH_UWORD 
231f ed 4b be e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2323			endif 
2323			 
2323 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
2327			 
2327			 
2327			if DEBUG_FORTH_UWORD 
2327					DMARK ":0+" 
2327 f5				push af  
2328 3a 3c 23			ld a, (.dmark)  
232b 32 6b ee			ld (debug_mark),a  
232e 3a 3d 23			ld a, (.dmark+1)  
2331 32 6c ee			ld (debug_mark+1),a  
2334 3a 3e 23			ld a, (.dmark+2)  
2337 32 6d ee			ld (debug_mark+2),a  
233a 18 03			jr .pastdmark  
233c ..			.dmark: db ":0+"  
233f f1			.pastdmark: pop af  
2340			endm  
# End of macro DMARK
2340			CALLMONITOR 
2340 cd 6f ee			call debug_vector  
2343				endm  
# End of macro CALLMONITOR
2343			endif 
2343			 
2343			STACKFRAMECHK OFF $8efe $989f 
2343				if DEBUG_STACK_IMB 
2343					if OFF 
2343						exx 
2343						ld hl, $989f 
2343						pop de   ; $989f 
2343						call cmp16 
2343						jr nz, .spnosame 
2343						ld hl, $8efe 
2343						pop de   ; $8efe 
2343						call cmp16 
2343						jr z, .spfrsame 
2343						.spnosame: call showsperror 
2343						.spfrsame: nop 
2343						exx 
2343					endif 
2343				endif 
2343			endm 
# End of macro STACKFRAMECHK
2343			 
2343 c9			ret    ; dont process any remaining parser tokens as they form new word 
2344			 
2344			 
2344			 
2344			 
2344			;		NEXT 
2344			.SCOLN: 
2344			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2344 06			db OPCODE_SCOLN 
2345 90 23		dw .DROP 
2347 02			db 2 
2348 .. 00		db ";",0           
234a			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
234a				if DEBUG_FORTH_WORDS_KEY 
234a					DMARK "SCN" 
234a f5				push af  
234b 3a 5f 23			ld a, (.dmark)  
234e 32 6b ee			ld (debug_mark),a  
2351 3a 60 23			ld a, (.dmark+1)  
2354 32 6c ee			ld (debug_mark+1),a  
2357 3a 61 23			ld a, (.dmark+2)  
235a 32 6d ee			ld (debug_mark+2),a  
235d 18 03			jr .pastdmark  
235f ..			.dmark: db "SCN"  
2362 f1			.pastdmark: pop af  
2363			endm  
# End of macro DMARK
2363					CALLMONITOR 
2363 cd 6f ee			call debug_vector  
2366				endm  
# End of macro CALLMONITOR
2366				endif 
2366				FORTH_RSP_TOS 
2366 cd 37 1b			call macro_forth_rsp_tos 
2369				endm 
# End of macro FORTH_RSP_TOS
2369 e5				push hl 
236a				FORTH_RSP_POP 
236a cd 41 1b			call macro_forth_rsp_pop 
236d				endm 
# End of macro FORTH_RSP_POP
236d e1				pop hl 
236e			;		ex de,hl 
236e 22 c2 e5			ld (os_tok_ptr),hl 
2371			 
2371			if DEBUG_FORTH_UWORD 
2371					DMARK "SCL" 
2371 f5				push af  
2372 3a 86 23			ld a, (.dmark)  
2375 32 6b ee			ld (debug_mark),a  
2378 3a 87 23			ld a, (.dmark+1)  
237b 32 6c ee			ld (debug_mark+1),a  
237e 3a 88 23			ld a, (.dmark+2)  
2381 32 6d ee			ld (debug_mark+2),a  
2384 18 03			jr .pastdmark  
2386 ..			.dmark: db "SCL"  
2389 f1			.pastdmark: pop af  
238a			endm  
# End of macro DMARK
238a			CALLMONITOR 
238a cd 6f ee			call debug_vector  
238d				endm  
# End of macro CALLMONITOR
238d			endif 
238d				NEXTW 
238d c3 34 1f			jp macro_next 
2390				endm 
# End of macro NEXTW
2390			 
2390			.DROP: 
2390			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2390 1b				db WORD_SYS_CORE+OPCODE_DROP             
2391 bb 23			dw .DUP2            
2393 05				db 4 + 1 
2394 .. 00			db "DROP",0              
2399				endm 
# End of macro CWHEAD
2399			; | DROP ( w -- )   drop the TOS item   | DONE 
2399				if DEBUG_FORTH_WORDS_KEY 
2399					DMARK "DRP" 
2399 f5				push af  
239a 3a ae 23			ld a, (.dmark)  
239d 32 6b ee			ld (debug_mark),a  
23a0 3a af 23			ld a, (.dmark+1)  
23a3 32 6c ee			ld (debug_mark+1),a  
23a6 3a b0 23			ld a, (.dmark+2)  
23a9 32 6d ee			ld (debug_mark+2),a  
23ac 18 03			jr .pastdmark  
23ae ..			.dmark: db "DRP"  
23b1 f1			.pastdmark: pop af  
23b2			endm  
# End of macro DMARK
23b2					CALLMONITOR 
23b2 cd 6f ee			call debug_vector  
23b5				endm  
# End of macro CALLMONITOR
23b5				endif 
23b5				FORTH_DSP_POP 
23b5 cd 36 1e			call macro_forth_dsp_pop 
23b8				endm 
# End of macro FORTH_DSP_POP
23b8				NEXTW 
23b8 c3 34 1f			jp macro_next 
23bb				endm 
# End of macro NEXTW
23bb			.DUP2: 
23bb			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
23bb 1c				db WORD_SYS_CORE+OPCODE_DUP2             
23bc 00 24			dw .DROP2            
23be 05				db 4 + 1 
23bf .. 00			db "2DUP",0              
23c4				endm 
# End of macro CWHEAD
23c4			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
23c4				if DEBUG_FORTH_WORDS_KEY 
23c4					DMARK "2DU" 
23c4 f5				push af  
23c5 3a d9 23			ld a, (.dmark)  
23c8 32 6b ee			ld (debug_mark),a  
23cb 3a da 23			ld a, (.dmark+1)  
23ce 32 6c ee			ld (debug_mark+1),a  
23d1 3a db 23			ld a, (.dmark+2)  
23d4 32 6d ee			ld (debug_mark+2),a  
23d7 18 03			jr .pastdmark  
23d9 ..			.dmark: db "2DU"  
23dc f1			.pastdmark: pop af  
23dd			endm  
# End of macro DMARK
23dd					CALLMONITOR 
23dd cd 6f ee			call debug_vector  
23e0				endm  
# End of macro CALLMONITOR
23e0				endif 
23e0				FORTH_DSP_VALUEHL 
23e0 cd 7e 1d			call macro_dsp_valuehl 
23e3				endm 
# End of macro FORTH_DSP_VALUEHL
23e3 e5				push hl      ; 2 
23e4			 
23e4				FORTH_DSP_POP 
23e4 cd 36 1e			call macro_forth_dsp_pop 
23e7				endm 
# End of macro FORTH_DSP_POP
23e7				 
23e7				FORTH_DSP_VALUEHL 
23e7 cd 7e 1d			call macro_dsp_valuehl 
23ea				endm 
# End of macro FORTH_DSP_VALUEHL
23ea			;		push hl      ; 1 
23ea			 
23ea				FORTH_DSP_POP 
23ea cd 36 1e			call macro_forth_dsp_pop 
23ed				endm 
# End of macro FORTH_DSP_POP
23ed			 
23ed			;		pop hl       ; 1 
23ed d1				pop de       ; 2 
23ee			 
23ee cd 79 1b			call forth_push_numhl 
23f1 eb				ex de, hl 
23f2 cd 79 1b			call forth_push_numhl 
23f5			 
23f5				 
23f5 eb				ex de, hl 
23f6			 
23f6 cd 79 1b			call forth_push_numhl 
23f9 eb				ex de, hl 
23fa cd 79 1b			call forth_push_numhl 
23fd			 
23fd			 
23fd				NEXTW 
23fd c3 34 1f			jp macro_next 
2400				endm 
# End of macro NEXTW
2400			.DROP2: 
2400			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2400 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2401 2f 24			dw .SWAP2            
2403 06				db 5 + 1 
2404 .. 00			db "2DROP",0              
240a				endm 
# End of macro CWHEAD
240a			; | 2DROP ( w w -- )    Double drop | DONE 
240a				if DEBUG_FORTH_WORDS_KEY 
240a					DMARK "2DR" 
240a f5				push af  
240b 3a 1f 24			ld a, (.dmark)  
240e 32 6b ee			ld (debug_mark),a  
2411 3a 20 24			ld a, (.dmark+1)  
2414 32 6c ee			ld (debug_mark+1),a  
2417 3a 21 24			ld a, (.dmark+2)  
241a 32 6d ee			ld (debug_mark+2),a  
241d 18 03			jr .pastdmark  
241f ..			.dmark: db "2DR"  
2422 f1			.pastdmark: pop af  
2423			endm  
# End of macro DMARK
2423					CALLMONITOR 
2423 cd 6f ee			call debug_vector  
2426				endm  
# End of macro CALLMONITOR
2426				endif 
2426				FORTH_DSP_POP 
2426 cd 36 1e			call macro_forth_dsp_pop 
2429				endm 
# End of macro FORTH_DSP_POP
2429				FORTH_DSP_POP 
2429 cd 36 1e			call macro_forth_dsp_pop 
242c				endm 
# End of macro FORTH_DSP_POP
242c				NEXTW 
242c c3 34 1f			jp macro_next 
242f				endm 
# End of macro NEXTW
242f			.SWAP2: 
242f			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
242f 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2430 58 24			dw .AT            
2432 06				db 5 + 1 
2433 .. 00			db "2SWAP",0              
2439				endm 
# End of macro CWHEAD
2439			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2439				if DEBUG_FORTH_WORDS_KEY 
2439					DMARK "2SW" 
2439 f5				push af  
243a 3a 4e 24			ld a, (.dmark)  
243d 32 6b ee			ld (debug_mark),a  
2440 3a 4f 24			ld a, (.dmark+1)  
2443 32 6c ee			ld (debug_mark+1),a  
2446 3a 50 24			ld a, (.dmark+2)  
2449 32 6d ee			ld (debug_mark+2),a  
244c 18 03			jr .pastdmark  
244e ..			.dmark: db "2SW"  
2451 f1			.pastdmark: pop af  
2452			endm  
# End of macro DMARK
2452					CALLMONITOR 
2452 cd 6f ee			call debug_vector  
2455				endm  
# End of macro CALLMONITOR
2455				endif 
2455			; TODO Use os stack swap memory 
2455				NEXTW 
2455 c3 34 1f			jp macro_next 
2458				endm 
# End of macro NEXTW
2458			.AT: 
2458			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2458 1f				db WORD_SYS_CORE+OPCODE_AT             
2459 8a 24			dw .CAT            
245b 02				db 1 + 1 
245c .. 00			db "@",0              
245e				endm 
# End of macro CWHEAD
245e			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
245e			 
245e				if DEBUG_FORTH_WORDS_KEY 
245e					DMARK "AT." 
245e f5				push af  
245f 3a 73 24			ld a, (.dmark)  
2462 32 6b ee			ld (debug_mark),a  
2465 3a 74 24			ld a, (.dmark+1)  
2468 32 6c ee			ld (debug_mark+1),a  
246b 3a 75 24			ld a, (.dmark+2)  
246e 32 6d ee			ld (debug_mark+2),a  
2471 18 03			jr .pastdmark  
2473 ..			.dmark: db "AT."  
2476 f1			.pastdmark: pop af  
2477			endm  
# End of macro DMARK
2477					CALLMONITOR 
2477 cd 6f ee			call debug_vector  
247a				endm  
# End of macro CALLMONITOR
247a				endif 
247a			.getbyteat:	 
247a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
247a cd 7e 1d			call macro_dsp_valuehl 
247d				endm 
# End of macro FORTH_DSP_VALUEHL
247d				 
247d			;		push hl 
247d			 
247d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
247d cd 36 1e			call macro_forth_dsp_pop 
2480				endm 
# End of macro FORTH_DSP_POP
2480			 
2480			;		pop hl 
2480			 
2480 7e				ld a, (hl) 
2481			 
2481 6f				ld l, a 
2482 26 00			ld h, 0 
2484 cd 79 1b			call forth_push_numhl 
2487			 
2487				NEXTW 
2487 c3 34 1f			jp macro_next 
248a				endm 
# End of macro NEXTW
248a			.CAT: 
248a			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
248a 20				db WORD_SYS_CORE+OPCODE_CAT             
248b b3 24			dw .BANG            
248d 03				db 2 + 1 
248e .. 00			db "C@",0              
2491				endm 
# End of macro CWHEAD
2491			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2491				if DEBUG_FORTH_WORDS_KEY 
2491					DMARK "CAA" 
2491 f5				push af  
2492 3a a6 24			ld a, (.dmark)  
2495 32 6b ee			ld (debug_mark),a  
2498 3a a7 24			ld a, (.dmark+1)  
249b 32 6c ee			ld (debug_mark+1),a  
249e 3a a8 24			ld a, (.dmark+2)  
24a1 32 6d ee			ld (debug_mark+2),a  
24a4 18 03			jr .pastdmark  
24a6 ..			.dmark: db "CAA"  
24a9 f1			.pastdmark: pop af  
24aa			endm  
# End of macro DMARK
24aa					CALLMONITOR 
24aa cd 6f ee			call debug_vector  
24ad				endm  
# End of macro CALLMONITOR
24ad				endif 
24ad c3 7a 24			jp .getbyteat 
24b0				NEXTW 
24b0 c3 34 1f			jp macro_next 
24b3				endm 
# End of macro NEXTW
24b3			.BANG: 
24b3			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
24b3 21				db WORD_SYS_CORE+OPCODE_BANG             
24b4 e9 24			dw .CBANG            
24b6 02				db 1 + 1 
24b7 .. 00			db "!",0              
24b9				endm 
# End of macro CWHEAD
24b9			; | ! ( x w -- ) Store x at address w      | DONE 
24b9				if DEBUG_FORTH_WORDS_KEY 
24b9					DMARK "BNG" 
24b9 f5				push af  
24ba 3a ce 24			ld a, (.dmark)  
24bd 32 6b ee			ld (debug_mark),a  
24c0 3a cf 24			ld a, (.dmark+1)  
24c3 32 6c ee			ld (debug_mark+1),a  
24c6 3a d0 24			ld a, (.dmark+2)  
24c9 32 6d ee			ld (debug_mark+2),a  
24cc 18 03			jr .pastdmark  
24ce ..			.dmark: db "BNG"  
24d1 f1			.pastdmark: pop af  
24d2			endm  
# End of macro DMARK
24d2					CALLMONITOR 
24d2 cd 6f ee			call debug_vector  
24d5				endm  
# End of macro CALLMONITOR
24d5				endif 
24d5			 
24d5			.storebyteat:		 
24d5				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24d5 cd 7e 1d			call macro_dsp_valuehl 
24d8				endm 
# End of macro FORTH_DSP_VALUEHL
24d8				 
24d8 e5				push hl 
24d9			 
24d9				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24d9 cd 36 1e			call macro_forth_dsp_pop 
24dc				endm 
# End of macro FORTH_DSP_POP
24dc			 
24dc				; get byte to poke 
24dc			 
24dc				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24dc cd 7e 1d			call macro_dsp_valuehl 
24df				endm 
# End of macro FORTH_DSP_VALUEHL
24df e5				push hl 
24e0			 
24e0			 
24e0				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24e0 cd 36 1e			call macro_forth_dsp_pop 
24e3				endm 
# End of macro FORTH_DSP_POP
24e3			 
24e3			 
24e3 d1				pop de 
24e4 e1				pop hl 
24e5			 
24e5 73				ld (hl),e 
24e6			 
24e6			 
24e6				NEXTW 
24e6 c3 34 1f			jp macro_next 
24e9				endm 
# End of macro NEXTW
24e9			.CBANG: 
24e9			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
24e9 22				db WORD_SYS_CORE+OPCODE_CBANG             
24ea 12 25			dw .SCALL            
24ec 03				db 2 + 1 
24ed .. 00			db "C!",0              
24f0				endm 
# End of macro CWHEAD
24f0			; | C!  ( x w -- ) Store x at address w  | DONE 
24f0				if DEBUG_FORTH_WORDS_KEY 
24f0					DMARK "CBA" 
24f0 f5				push af  
24f1 3a 05 25			ld a, (.dmark)  
24f4 32 6b ee			ld (debug_mark),a  
24f7 3a 06 25			ld a, (.dmark+1)  
24fa 32 6c ee			ld (debug_mark+1),a  
24fd 3a 07 25			ld a, (.dmark+2)  
2500 32 6d ee			ld (debug_mark+2),a  
2503 18 03			jr .pastdmark  
2505 ..			.dmark: db "CBA"  
2508 f1			.pastdmark: pop af  
2509			endm  
# End of macro DMARK
2509					CALLMONITOR 
2509 cd 6f ee			call debug_vector  
250c				endm  
# End of macro CALLMONITOR
250c				endif 
250c c3 d5 24			jp .storebyteat 
250f				NEXTW 
250f c3 34 1f			jp macro_next 
2512				endm 
# End of macro NEXTW
2512			.SCALL: 
2512			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2512 23				db WORD_SYS_CORE+OPCODE_SCALL             
2513 46 25			dw .DEPTH            
2515 05				db 4 + 1 
2516 .. 00			db "CALL",0              
251b				endm 
# End of macro CWHEAD
251b			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
251b				if DEBUG_FORTH_WORDS_KEY 
251b					DMARK "CLL" 
251b f5				push af  
251c 3a 30 25			ld a, (.dmark)  
251f 32 6b ee			ld (debug_mark),a  
2522 3a 31 25			ld a, (.dmark+1)  
2525 32 6c ee			ld (debug_mark+1),a  
2528 3a 32 25			ld a, (.dmark+2)  
252b 32 6d ee			ld (debug_mark+2),a  
252e 18 03			jr .pastdmark  
2530 ..			.dmark: db "CLL"  
2533 f1			.pastdmark: pop af  
2534			endm  
# End of macro DMARK
2534					CALLMONITOR 
2534 cd 6f ee			call debug_vector  
2537				endm  
# End of macro CALLMONITOR
2537				endif 
2537			 
2537				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2537 cd 7e 1d			call macro_dsp_valuehl 
253a				endm 
# End of macro FORTH_DSP_VALUEHL
253a			 
253a			;		push hl 
253a			 
253a				; destroy value TOS 
253a			 
253a				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
253a cd 36 1e			call macro_forth_dsp_pop 
253d				endm 
# End of macro FORTH_DSP_POP
253d			 
253d					 
253d			;		pop hl 
253d			 
253d				; how to do a call with hl???? save SP? 
253d cd d8 1e			call forth_call_hl 
2540			 
2540			 
2540				; TODO push value back onto stack for another op etc 
2540			 
2540 cd 79 1b			call forth_push_numhl 
2543				NEXTW 
2543 c3 34 1f			jp macro_next 
2546				endm 
# End of macro NEXTW
2546			.DEPTH: 
2546			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2546 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2547 83 25			dw .OVER            
2549 06				db 5 + 1 
254a .. 00			db "DEPTH",0              
2550				endm 
# End of macro CWHEAD
2550			; | DEPTH ( -- u ) Push count of stack | DONE 
2550				; take current TOS and remove from base value div by two to get count 
2550				if DEBUG_FORTH_WORDS_KEY 
2550					DMARK "DEP" 
2550 f5				push af  
2551 3a 65 25			ld a, (.dmark)  
2554 32 6b ee			ld (debug_mark),a  
2557 3a 66 25			ld a, (.dmark+1)  
255a 32 6c ee			ld (debug_mark+1),a  
255d 3a 67 25			ld a, (.dmark+2)  
2560 32 6d ee			ld (debug_mark+2),a  
2563 18 03			jr .pastdmark  
2565 ..			.dmark: db "DEP"  
2568 f1			.pastdmark: pop af  
2569			endm  
# End of macro DMARK
2569					CALLMONITOR 
2569 cd 6f ee			call debug_vector  
256c				endm  
# End of macro CALLMONITOR
256c				endif 
256c			 
256c			 
256c 2a ee e9		ld hl, (cli_data_sp) 
256f 11 28 e8		ld de, cli_data_stack 
2572 ed 52		sbc hl,de 
2574			 
2574			; div by size of stack item 
2574			 
2574 5d			ld e,l 
2575 0e 03		ld c, 3 
2577 cd 82 0d		call Div8 
257a			 
257a 6f			ld l,a 
257b 26 00		ld h,0 
257d			 
257d			;srl h 
257d			;rr l 
257d			 
257d cd 79 1b			call forth_push_numhl 
2580				NEXTW 
2580 c3 34 1f			jp macro_next 
2583				endm 
# End of macro NEXTW
2583			.OVER: 
2583			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2583 42				db WORD_SYS_CORE+46             
2584 ca 25			dw .PAUSE            
2586 05				db 4 + 1 
2587 .. 00			db "OVER",0              
258c				endm 
# End of macro CWHEAD
258c			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
258c				if DEBUG_FORTH_WORDS_KEY 
258c					DMARK "OVR" 
258c f5				push af  
258d 3a a1 25			ld a, (.dmark)  
2590 32 6b ee			ld (debug_mark),a  
2593 3a a2 25			ld a, (.dmark+1)  
2596 32 6c ee			ld (debug_mark+1),a  
2599 3a a3 25			ld a, (.dmark+2)  
259c 32 6d ee			ld (debug_mark+2),a  
259f 18 03			jr .pastdmark  
25a1 ..			.dmark: db "OVR"  
25a4 f1			.pastdmark: pop af  
25a5			endm  
# End of macro DMARK
25a5					CALLMONITOR 
25a5 cd 6f ee			call debug_vector  
25a8				endm  
# End of macro CALLMONITOR
25a8				endif 
25a8			 
25a8			; TODO Use os stack swap memory 
25a8				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25a8 cd 7e 1d			call macro_dsp_valuehl 
25ab				endm 
# End of macro FORTH_DSP_VALUEHL
25ab e5				push hl    ; n2 
25ac				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25ac cd 36 1e			call macro_forth_dsp_pop 
25af				endm 
# End of macro FORTH_DSP_POP
25af			 
25af				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25af cd 7e 1d			call macro_dsp_valuehl 
25b2				endm 
# End of macro FORTH_DSP_VALUEHL
25b2 e5				push hl    ; n1 
25b3				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25b3 cd 36 1e			call macro_forth_dsp_pop 
25b6				endm 
# End of macro FORTH_DSP_POP
25b6			 
25b6 d1				pop de     ; n1 
25b7 e1				pop hl     ; n2 
25b8			 
25b8 d5				push de 
25b9 e5				push hl 
25ba d5				push de 
25bb			 
25bb				; push back  
25bb			 
25bb e1				pop hl 
25bc cd 79 1b			call forth_push_numhl 
25bf e1				pop hl 
25c0 cd 79 1b			call forth_push_numhl 
25c3 e1				pop hl 
25c4 cd 79 1b			call forth_push_numhl 
25c7				NEXTW 
25c7 c3 34 1f			jp macro_next 
25ca				endm 
# End of macro NEXTW
25ca			 
25ca			.PAUSE: 
25ca			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
25ca 43				db WORD_SYS_CORE+47             
25cb ff 25			dw .PAUSES            
25cd 08				db 7 + 1 
25ce .. 00			db "PAUSEMS",0              
25d6				endm 
# End of macro CWHEAD
25d6			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
25d6				if DEBUG_FORTH_WORDS_KEY 
25d6					DMARK "PMS" 
25d6 f5				push af  
25d7 3a eb 25			ld a, (.dmark)  
25da 32 6b ee			ld (debug_mark),a  
25dd 3a ec 25			ld a, (.dmark+1)  
25e0 32 6c ee			ld (debug_mark+1),a  
25e3 3a ed 25			ld a, (.dmark+2)  
25e6 32 6d ee			ld (debug_mark+2),a  
25e9 18 03			jr .pastdmark  
25eb ..			.dmark: db "PMS"  
25ee f1			.pastdmark: pop af  
25ef			endm  
# End of macro DMARK
25ef					CALLMONITOR 
25ef cd 6f ee			call debug_vector  
25f2				endm  
# End of macro CALLMONITOR
25f2				endif 
25f2				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25f2 cd 7e 1d			call macro_dsp_valuehl 
25f5				endm 
# End of macro FORTH_DSP_VALUEHL
25f5			;		push hl    ; n2 
25f5				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25f5 cd 36 1e			call macro_forth_dsp_pop 
25f8				endm 
# End of macro FORTH_DSP_POP
25f8			;		pop hl 
25f8			 
25f8 7d				ld a, l 
25f9 cd e2 0a			call aDelayInMS 
25fc			       NEXTW 
25fc c3 34 1f			jp macro_next 
25ff				endm 
# End of macro NEXTW
25ff			.PAUSES:  
25ff			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
25ff 44				db WORD_SYS_CORE+48             
2600 6e 26			dw .ROT            
2602 06				db 5 + 1 
2603 .. 00			db "PAUSE",0              
2609				endm 
# End of macro CWHEAD
2609			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2609				if DEBUG_FORTH_WORDS_KEY 
2609					DMARK "PAU" 
2609 f5				push af  
260a 3a 1e 26			ld a, (.dmark)  
260d 32 6b ee			ld (debug_mark),a  
2610 3a 1f 26			ld a, (.dmark+1)  
2613 32 6c ee			ld (debug_mark+1),a  
2616 3a 20 26			ld a, (.dmark+2)  
2619 32 6d ee			ld (debug_mark+2),a  
261c 18 03			jr .pastdmark  
261e ..			.dmark: db "PAU"  
2621 f1			.pastdmark: pop af  
2622			endm  
# End of macro DMARK
2622					CALLMONITOR 
2622 cd 6f ee			call debug_vector  
2625				endm  
# End of macro CALLMONITOR
2625				endif 
2625				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2625 cd 7e 1d			call macro_dsp_valuehl 
2628				endm 
# End of macro FORTH_DSP_VALUEHL
2628			;		push hl    ; n2 
2628				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2628 cd 36 1e			call macro_forth_dsp_pop 
262b				endm 
# End of macro FORTH_DSP_POP
262b			;		pop hl 
262b 45				ld b, l 
262c				if DEBUG_FORTH_WORDS 
262c					DMARK "PAU" 
262c f5				push af  
262d 3a 41 26			ld a, (.dmark)  
2630 32 6b ee			ld (debug_mark),a  
2633 3a 42 26			ld a, (.dmark+1)  
2636 32 6c ee			ld (debug_mark+1),a  
2639 3a 43 26			ld a, (.dmark+2)  
263c 32 6d ee			ld (debug_mark+2),a  
263f 18 03			jr .pastdmark  
2641 ..			.dmark: db "PAU"  
2644 f1			.pastdmark: pop af  
2645			endm  
# End of macro DMARK
2645					CALLMONITOR 
2645 cd 6f ee			call debug_vector  
2648				endm  
# End of macro CALLMONITOR
2648				endif 
2648 c5			.pauses1:	push bc 
2649 cd fd 0a			call delay1s 
264c c1				pop bc 
264d				if DEBUG_FORTH_WORDS 
264d					DMARK "PA1" 
264d f5				push af  
264e 3a 62 26			ld a, (.dmark)  
2651 32 6b ee			ld (debug_mark),a  
2654 3a 63 26			ld a, (.dmark+1)  
2657 32 6c ee			ld (debug_mark+1),a  
265a 3a 64 26			ld a, (.dmark+2)  
265d 32 6d ee			ld (debug_mark+2),a  
2660 18 03			jr .pastdmark  
2662 ..			.dmark: db "PA1"  
2665 f1			.pastdmark: pop af  
2666			endm  
# End of macro DMARK
2666					CALLMONITOR 
2666 cd 6f ee			call debug_vector  
2669				endm  
# End of macro CALLMONITOR
2669				endif 
2669 10 dd			djnz .pauses1 
266b			 
266b			       NEXTW 
266b c3 34 1f			jp macro_next 
266e				endm 
# End of macro NEXTW
266e			.ROT: 
266e			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
266e 45				db WORD_SYS_CORE+49             
266f bc 26			dw .UWORDS            
2671 04				db 3 + 1 
2672 .. 00			db "ROT",0              
2676				endm 
# End of macro CWHEAD
2676			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2676				if DEBUG_FORTH_WORDS_KEY 
2676					DMARK "ROT" 
2676 f5				push af  
2677 3a 8b 26			ld a, (.dmark)  
267a 32 6b ee			ld (debug_mark),a  
267d 3a 8c 26			ld a, (.dmark+1)  
2680 32 6c ee			ld (debug_mark+1),a  
2683 3a 8d 26			ld a, (.dmark+2)  
2686 32 6d ee			ld (debug_mark+2),a  
2689 18 03			jr .pastdmark  
268b ..			.dmark: db "ROT"  
268e f1			.pastdmark: pop af  
268f			endm  
# End of macro DMARK
268f					CALLMONITOR 
268f cd 6f ee			call debug_vector  
2692				endm  
# End of macro CALLMONITOR
2692				endif 
2692			 
2692			; TODO Use os stack swap memory 
2692				FORTH_DSP_VALUEHL 
2692 cd 7e 1d			call macro_dsp_valuehl 
2695				endm 
# End of macro FORTH_DSP_VALUEHL
2695 e5				push hl    ; u3  
2696			 
2696				FORTH_DSP_POP 
2696 cd 36 1e			call macro_forth_dsp_pop 
2699				endm 
# End of macro FORTH_DSP_POP
2699			 
2699				FORTH_DSP_VALUEHL 
2699 cd 7e 1d			call macro_dsp_valuehl 
269c				endm 
# End of macro FORTH_DSP_VALUEHL
269c e5				push hl     ; u2 
269d			 
269d				FORTH_DSP_POP 
269d cd 36 1e			call macro_forth_dsp_pop 
26a0				endm 
# End of macro FORTH_DSP_POP
26a0			 
26a0				FORTH_DSP_VALUEHL 
26a0 cd 7e 1d			call macro_dsp_valuehl 
26a3				endm 
# End of macro FORTH_DSP_VALUEHL
26a3 e5				push hl     ; u1 
26a4			 
26a4				FORTH_DSP_POP 
26a4 cd 36 1e			call macro_forth_dsp_pop 
26a7				endm 
# End of macro FORTH_DSP_POP
26a7			 
26a7 c1				pop bc      ; u1 
26a8 e1				pop hl      ; u2 
26a9 d1				pop de      ; u3 
26aa			 
26aa			 
26aa c5				push bc 
26ab d5				push de 
26ac e5				push hl 
26ad			 
26ad			 
26ad e1				pop hl 
26ae cd 79 1b			call forth_push_numhl 
26b1			 
26b1 e1				pop hl 
26b2 cd 79 1b			call forth_push_numhl 
26b5			 
26b5 e1				pop hl 
26b6 cd 79 1b			call forth_push_numhl 
26b9				 
26b9			 
26b9			 
26b9			 
26b9			 
26b9			 
26b9			       NEXTW 
26b9 c3 34 1f			jp macro_next 
26bc				endm 
# End of macro NEXTW
26bc			 
26bc			.UWORDS: 
26bc			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
26bc 50				db WORD_SYS_CORE+60             
26bd 7e 27			dw .BP            
26bf 07				db 6 + 1 
26c0 .. 00			db "UWORDS",0              
26c7				endm 
# End of macro CWHEAD
26c7			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
26c7			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
26c7			; | | Following the count are the individual words. 
26c7			; | | 
26c7			; | | e.g. UWORDS 
26c7			; | | BOX DIRLIST 2 
26c7			; | |  
26c7			; | | Can be used to save the words to storage via: 
26c7			; | | UWORDS $01 DO $01 APPEND LOOP 
26c7			if DEBUG_FORTH_WORDS_KEY 
26c7				DMARK "UWR" 
26c7 f5				push af  
26c8 3a dc 26			ld a, (.dmark)  
26cb 32 6b ee			ld (debug_mark),a  
26ce 3a dd 26			ld a, (.dmark+1)  
26d1 32 6c ee			ld (debug_mark+1),a  
26d4 3a de 26			ld a, (.dmark+2)  
26d7 32 6d ee			ld (debug_mark+2),a  
26da 18 03			jr .pastdmark  
26dc ..			.dmark: db "UWR"  
26df f1			.pastdmark: pop af  
26e0			endm  
# End of macro DMARK
26e0				CALLMONITOR 
26e0 cd 6f ee			call debug_vector  
26e3				endm  
# End of macro CALLMONITOR
26e3			endif 
26e3 21 89 5e			ld hl, baseram 
26e6				;ld hl, baseusermem 
26e6 01 00 00			ld bc, 0    ; start a counter 
26e9			 
26e9			; skip dict stub 
26e9			 
26e9 cd 85 20			call forth_tok_next 
26ec			 
26ec			 
26ec			; while we have words to look for 
26ec			 
26ec 7e			.douscan:	ld a, (hl)      
26ed			if DEBUG_FORTH_WORDS 
26ed				DMARK "UWs" 
26ed f5				push af  
26ee 3a 02 27			ld a, (.dmark)  
26f1 32 6b ee			ld (debug_mark),a  
26f4 3a 03 27			ld a, (.dmark+1)  
26f7 32 6c ee			ld (debug_mark+1),a  
26fa 3a 04 27			ld a, (.dmark+2)  
26fd 32 6d ee			ld (debug_mark+2),a  
2700 18 03			jr .pastdmark  
2702 ..			.dmark: db "UWs"  
2705 f1			.pastdmark: pop af  
2706			endm  
# End of macro DMARK
2706				CALLMONITOR 
2706 cd 6f ee			call debug_vector  
2709				endm  
# End of macro CALLMONITOR
2709			endif 
2709 fe 00			cp WORD_SYS_END 
270b 28 4d			jr z, .udone 
270d fe 01			cp WORD_SYS_UWORD 
270f 20 44			jr nz, .nuword 
2711			 
2711			if DEBUG_FORTH_WORDS 
2711				DMARK "UWu" 
2711 f5				push af  
2712 3a 26 27			ld a, (.dmark)  
2715 32 6b ee			ld (debug_mark),a  
2718 3a 27 27			ld a, (.dmark+1)  
271b 32 6c ee			ld (debug_mark+1),a  
271e 3a 28 27			ld a, (.dmark+2)  
2721 32 6d ee			ld (debug_mark+2),a  
2724 18 03			jr .pastdmark  
2726 ..			.dmark: db "UWu"  
2729 f1			.pastdmark: pop af  
272a			endm  
# End of macro DMARK
272a				CALLMONITOR 
272a cd 6f ee			call debug_vector  
272d				endm  
# End of macro CALLMONITOR
272d			endif 
272d				; we have a uword so push its name to the stack 
272d			 
272d e5				push hl  ; save so we can move to next dict block 
272e			 
272e				; skip opcode 
272e 23				inc hl  
272f				; skip next ptr 
272f 23				inc hl  
2730 23				inc hl 
2731				; skip len 
2731 23				inc hl 
2732			if DEBUG_FORTH_WORDS 
2732				DMARK "UWt" 
2732 f5				push af  
2733 3a 47 27			ld a, (.dmark)  
2736 32 6b ee			ld (debug_mark),a  
2739 3a 48 27			ld a, (.dmark+1)  
273c 32 6c ee			ld (debug_mark+1),a  
273f 3a 49 27			ld a, (.dmark+2)  
2742 32 6d ee			ld (debug_mark+2),a  
2745 18 03			jr .pastdmark  
2747 ..			.dmark: db "UWt"  
274a f1			.pastdmark: pop af  
274b			endm  
# End of macro DMARK
274b				CALLMONITOR 
274b cd 6f ee			call debug_vector  
274e				endm  
# End of macro CALLMONITOR
274e			endif 
274e 03				inc bc 
274f			 
274f c5				push bc 
2750 cd e7 1b			call forth_push_str 
2753 c1				pop bc 
2754			 
2754 e1				pop hl 	 
2755			 
2755 cd 85 20		.nuword:	call forth_tok_next 
2758 18 92			jr .douscan  
275a			 
275a			.udone:		 ; push count of uwords found 
275a c5				push bc 
275b e1				pop hl 
275c			 
275c			if DEBUG_FORTH_WORDS 
275c				DMARK "UWc" 
275c f5				push af  
275d 3a 71 27			ld a, (.dmark)  
2760 32 6b ee			ld (debug_mark),a  
2763 3a 72 27			ld a, (.dmark+1)  
2766 32 6c ee			ld (debug_mark+1),a  
2769 3a 73 27			ld a, (.dmark+2)  
276c 32 6d ee			ld (debug_mark+2),a  
276f 18 03			jr .pastdmark  
2771 ..			.dmark: db "UWc"  
2774 f1			.pastdmark: pop af  
2775			endm  
# End of macro DMARK
2775				CALLMONITOR 
2775 cd 6f ee			call debug_vector  
2778				endm  
# End of macro CALLMONITOR
2778			endif 
2778 cd 79 1b			call forth_push_numhl 
277b			 
277b			 
277b			       NEXTW 
277b c3 34 1f			jp macro_next 
277e				endm 
# End of macro NEXTW
277e			 
277e			.BP: 
277e			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
277e 54				db WORD_SYS_CORE+64             
277f b8 27			dw .MONITOR            
2781 03				db 2 + 1 
2782 .. 00			db "BP",0              
2785				endm 
# End of macro CWHEAD
2785			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2785			; | | $00 Will enable the break points within specific code paths 
2785			; | | $01 Will disable break points 
2785			; | |  
2785			; | | By default break points are off. Either the above can be used to enable them 
2785			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2785			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2785			; | | can disable break points. Exiting will then continue boot process. 
2785				; get byte count 
2785				if DEBUG_FORTH_WORDS_KEY 
2785					DMARK "BP." 
2785 f5				push af  
2786 3a 9a 27			ld a, (.dmark)  
2789 32 6b ee			ld (debug_mark),a  
278c 3a 9b 27			ld a, (.dmark+1)  
278f 32 6c ee			ld (debug_mark+1),a  
2792 3a 9c 27			ld a, (.dmark+2)  
2795 32 6d ee			ld (debug_mark+2),a  
2798 18 03			jr .pastdmark  
279a ..			.dmark: db "BP."  
279d f1			.pastdmark: pop af  
279e			endm  
# End of macro DMARK
279e					CALLMONITOR 
279e cd 6f ee			call debug_vector  
27a1				endm  
# End of macro CALLMONITOR
27a1				endif 
27a1			 
27a1				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27a1 cd 7e 1d			call macro_dsp_valuehl 
27a4				endm 
# End of macro FORTH_DSP_VALUEHL
27a4			 
27a4			;		push hl 
27a4			 
27a4				; destroy value TOS 
27a4			 
27a4				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27a4 cd 36 1e			call macro_forth_dsp_pop 
27a7				endm 
# End of macro FORTH_DSP_POP
27a7			 
27a7			;		pop hl 
27a7			 
27a7 3e 00			ld a,0 
27a9 bd				cp l 
27aa 28 06			jr z, .bpset 
27ac			;		ld a, '*' 
27ac cd 08 15			call bp_off 
27af				NEXTW 
27af c3 34 1f			jp macro_next 
27b2				endm 
# End of macro NEXTW
27b2			 
27b2			.bpset:	 
27b2				;	ld (os_view_disable), a 
27b2 cd fc 14			call bp_on 
27b5			 
27b5			 
27b5				NEXTW 
27b5 c3 34 1f			jp macro_next 
27b8				endm 
# End of macro NEXTW
27b8			 
27b8			 
27b8			.MONITOR: 
27b8			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
27b8 55				db WORD_SYS_CORE+65             
27b9 e9 27			dw .MALLOC            
27bb 08				db 7 + 1 
27bc .. 00			db "MONITOR",0              
27c4				endm 
# End of macro CWHEAD
27c4			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
27c4			; | | At start the current various registers will be displayed with contents. 
27c4			; | | Top right corner will show the most recent debug marker seen. 
27c4			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
27c4			; | | and the return stack pointer (RSP). 
27c4			; | | Pressing: 
27c4			; | |    1 - Initial screen 
27c4			; | |    2 - Display a data dump of HL 
27c4			; | |    3 - Display a data dump of DE 
27c4			; | |    4 - Display a data dump of BC 
27c4			; | |    5 - Display a data dump of HL 
27c4			; | |    6 - Display a data dump of DSP 
27c4			; | |    7 - Display a data dump of RSP 
27c4			; | |    8 - Display a data dump of what is at DSP 
27c4			; | |    9 - Display a data dump of what is at RSP 
27c4			; | |    0 - Exit monitor and continue running. This will also enable break points 
27c4			; | |    * - Disable break points 
27c4			; | |    # - Enter traditional monitor mode 
27c4			; | | 
27c4			; | | Monitor Mode 
27c4			; | | ------------ 
27c4			; | | A prompt of '>' will be shown for various commands: 
27c4			; | |    D xxxx - Display a data dump starting from hex address xxxx 
27c4			; | |    C - Continue display a data dump from the last set address 
27c4			; | |    M xxxx - Set start of memory edit at address xx 
27c4			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
27c4			; | |    G xxxx - Exec code at specific address 
27c4			; | |    Q - Return to previous 
27c4				if DEBUG_FORTH_WORDS_KEY 
27c4					DMARK "MON" 
27c4 f5				push af  
27c5 3a d9 27			ld a, (.dmark)  
27c8 32 6b ee			ld (debug_mark),a  
27cb 3a da 27			ld a, (.dmark+1)  
27ce 32 6c ee			ld (debug_mark+1),a  
27d1 3a db 27			ld a, (.dmark+2)  
27d4 32 6d ee			ld (debug_mark+2),a  
27d7 18 03			jr .pastdmark  
27d9 ..			.dmark: db "MON"  
27dc f1			.pastdmark: pop af  
27dd			endm  
# End of macro DMARK
27dd					CALLMONITOR 
27dd cd 6f ee			call debug_vector  
27e0				endm  
# End of macro CALLMONITOR
27e0				endif 
27e0			;		ld a, 0 
27e0			;		ld (os_view_disable), a 
27e0 cd fc 14			call bp_on 
27e3			 
27e3				CALLMONITOR 
27e3 cd 6f ee			call debug_vector  
27e6				endm  
# End of macro CALLMONITOR
27e6			 
27e6			;	call monitor 
27e6			 
27e6				NEXTW 
27e6 c3 34 1f			jp macro_next 
27e9				endm 
# End of macro NEXTW
27e9			 
27e9			 
27e9			.MALLOC: 
27e9			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
27e9 56				db WORD_SYS_CORE+66             
27ea 12 28			dw .MALLOC2            
27ec 06				db 5 + 1 
27ed .. 00			db "ALLOT",0              
27f3				endm 
# End of macro CWHEAD
27f3			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
27f3				if DEBUG_FORTH_WORDS_KEY 
27f3					DMARK "ALL" 
27f3 f5				push af  
27f4 3a 08 28			ld a, (.dmark)  
27f7 32 6b ee			ld (debug_mark),a  
27fa 3a 09 28			ld a, (.dmark+1)  
27fd 32 6c ee			ld (debug_mark+1),a  
2800 3a 0a 28			ld a, (.dmark+2)  
2803 32 6d ee			ld (debug_mark+2),a  
2806 18 03			jr .pastdmark  
2808 ..			.dmark: db "ALL"  
280b f1			.pastdmark: pop af  
280c			endm  
# End of macro DMARK
280c					CALLMONITOR 
280c cd 6f ee			call debug_vector  
280f				endm  
# End of macro CALLMONITOR
280f				endif 
280f c3 39 28			jp .mallocc 
2812			.MALLOC2: 
2812			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2812 56				db WORD_SYS_CORE+66             
2813 50 28			dw .FREE            
2815 07				db 6 + 1 
2816 .. 00			db "MALLOC",0              
281d				endm 
# End of macro CWHEAD
281d			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
281d				; get byte count 
281d				if DEBUG_FORTH_WORDS_KEY 
281d					DMARK "MAL" 
281d f5				push af  
281e 3a 32 28			ld a, (.dmark)  
2821 32 6b ee			ld (debug_mark),a  
2824 3a 33 28			ld a, (.dmark+1)  
2827 32 6c ee			ld (debug_mark+1),a  
282a 3a 34 28			ld a, (.dmark+2)  
282d 32 6d ee			ld (debug_mark+2),a  
2830 18 03			jr .pastdmark  
2832 ..			.dmark: db "MAL"  
2835 f1			.pastdmark: pop af  
2836			endm  
# End of macro DMARK
2836					CALLMONITOR 
2836 cd 6f ee			call debug_vector  
2839				endm  
# End of macro CALLMONITOR
2839				endif 
2839			.mallocc: 
2839				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2839 cd 7e 1d			call macro_dsp_valuehl 
283c				endm 
# End of macro FORTH_DSP_VALUEHL
283c			 
283c			;		push hl 
283c			 
283c				; destroy value TOS 
283c			 
283c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
283c cd 36 1e			call macro_forth_dsp_pop 
283f				endm 
# End of macro FORTH_DSP_POP
283f			 
283f			;		pop hl 
283f cd cd 11			call malloc 
2842			if DEBUG_FORTH_MALLOC_GUARD 
2842 f5				push af 
2843 cd 1b 0e			call ishlzero 
2846			;		ld a, l 
2846			;		add h 
2846			;		cp 0 
2846 f1				pop af 
2847				 
2847 cc f4 4c			call z,malloc_error 
284a			endif 
284a			 
284a cd 79 1b			call forth_push_numhl 
284d				NEXTW 
284d c3 34 1f			jp macro_next 
2850				endm 
# End of macro NEXTW
2850			 
2850			.FREE: 
2850			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2850 57				db WORD_SYS_CORE+67             
2851 81 28			dw .LIST            
2853 05				db 4 + 1 
2854 .. 00			db "FREE",0              
2859				endm 
# End of macro CWHEAD
2859			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2859				if DEBUG_FORTH_WORDS_KEY 
2859					DMARK "FRE" 
2859 f5				push af  
285a 3a 6e 28			ld a, (.dmark)  
285d 32 6b ee			ld (debug_mark),a  
2860 3a 6f 28			ld a, (.dmark+1)  
2863 32 6c ee			ld (debug_mark+1),a  
2866 3a 70 28			ld a, (.dmark+2)  
2869 32 6d ee			ld (debug_mark+2),a  
286c 18 03			jr .pastdmark  
286e ..			.dmark: db "FRE"  
2871 f1			.pastdmark: pop af  
2872			endm  
# End of macro DMARK
2872					CALLMONITOR 
2872 cd 6f ee			call debug_vector  
2875				endm  
# End of macro CALLMONITOR
2875				endif 
2875				; get address 
2875			 
2875				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2875 cd 7e 1d			call macro_dsp_valuehl 
2878				endm 
# End of macro FORTH_DSP_VALUEHL
2878			 
2878			;		push hl 
2878			 
2878				; destroy value TOS 
2878			 
2878				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2878 cd 36 1e			call macro_forth_dsp_pop 
287b				endm 
# End of macro FORTH_DSP_POP
287b			 
287b			;		pop hl 
287b			if FORTH_ENABLE_MALLOCFREE 
287b cd 97 12			call free 
287e			endif 
287e				NEXTW 
287e c3 34 1f			jp macro_next 
2881				endm 
# End of macro NEXTW
2881			.LIST: 
2881			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2881 5c				db WORD_SYS_CORE+72             
2882 71 2a			dw .FORGET            
2884 05				db 4 + 1 
2885 .. 00			db "LIST",0              
288a				endm 
# End of macro CWHEAD
288a			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
288a			; | | The quoted word must be in upper case. 
288a			if DEBUG_FORTH_WORDS_KEY 
288a				DMARK "LST" 
288a f5				push af  
288b 3a 9f 28			ld a, (.dmark)  
288e 32 6b ee			ld (debug_mark),a  
2891 3a a0 28			ld a, (.dmark+1)  
2894 32 6c ee			ld (debug_mark+1),a  
2897 3a a1 28			ld a, (.dmark+2)  
289a 32 6d ee			ld (debug_mark+2),a  
289d 18 03			jr .pastdmark  
289f ..			.dmark: db "LST"  
28a2 f1			.pastdmark: pop af  
28a3			endm  
# End of macro DMARK
28a3				CALLMONITOR 
28a3 cd 6f ee			call debug_vector  
28a6				endm  
# End of macro CALLMONITOR
28a6			endif 
28a6			 
28a6				FORTH_DSP_VALUEHL 
28a6 cd 7e 1d			call macro_dsp_valuehl 
28a9				endm 
# End of macro FORTH_DSP_VALUEHL
28a9			 
28a9 e5				push hl 
28aa				FORTH_DSP_POP 
28aa cd 36 1e			call macro_forth_dsp_pop 
28ad				endm 
# End of macro FORTH_DSP_POP
28ad c1				pop bc 
28ae			 
28ae			; Start format of scratch string 
28ae			 
28ae 21 c1 e2			ld hl, scratch 
28b1			 
28b1 3e 3a			ld a, ':' 
28b3 77				ld (hl),a 
28b4 23				inc hl 
28b5 3e 20			ld a, ' ' 
28b7 77				ld (hl), a 
28b8			 
28b8				; Get ptr to the word we need to look up 
28b8			 
28b8			;		FORTH_DSP_VALUEHL 
28b8				;v5 FORTH_DSP_VALUE 
28b8			; TODO type check 
28b8			;		inc hl    ; Skip type check  
28b8			;		push hl 
28b8			;		ex de, hl    ; put into DE 
28b8			 
28b8			 
28b8 21 89 5e			ld hl, baseram 
28bb				;ld hl, baseusermem 
28bb			 
28bb e5			push hl   ; sacreifical push 
28bc			 
28bc			.ldouscanm: 
28bc e1			pop hl 
28bd			.ldouscan: 
28bd			if DEBUG_FORTH_WORDS 
28bd				DMARK "LSs" 
28bd f5				push af  
28be 3a d2 28			ld a, (.dmark)  
28c1 32 6b ee			ld (debug_mark),a  
28c4 3a d3 28			ld a, (.dmark+1)  
28c7 32 6c ee			ld (debug_mark+1),a  
28ca 3a d4 28			ld a, (.dmark+2)  
28cd 32 6d ee			ld (debug_mark+2),a  
28d0 18 03			jr .pastdmark  
28d2 ..			.dmark: db "LSs"  
28d5 f1			.pastdmark: pop af  
28d6			endm  
# End of macro DMARK
28d6				CALLMONITOR 
28d6 cd 6f ee			call debug_vector  
28d9				endm  
# End of macro CALLMONITOR
28d9			endif 
28d9			; skip dict stub 
28d9 cd 85 20			call forth_tok_next 
28dc			 
28dc			 
28dc			; while we have words to look for 
28dc			 
28dc 7e			ld a, (hl)      
28dd			if DEBUG_FORTH_WORDS 
28dd				DMARK "LSk" 
28dd f5				push af  
28de 3a f2 28			ld a, (.dmark)  
28e1 32 6b ee			ld (debug_mark),a  
28e4 3a f3 28			ld a, (.dmark+1)  
28e7 32 6c ee			ld (debug_mark+1),a  
28ea 3a f4 28			ld a, (.dmark+2)  
28ed 32 6d ee			ld (debug_mark+2),a  
28f0 18 03			jr .pastdmark  
28f2 ..			.dmark: db "LSk"  
28f5 f1			.pastdmark: pop af  
28f6			endm  
# End of macro DMARK
28f6				CALLMONITOR 
28f6 cd 6f ee			call debug_vector  
28f9				endm  
# End of macro CALLMONITOR
28f9			endif 
28f9				;cp WORD_SYS_END 
28f9				;jp z, .lunotfound 
28f9			 
28f9					; if we hit non uwords then gone too far 
28f9 fe 01				cp WORD_SYS_UWORD 
28fb c2 2d 2a				jp nz, .lunotfound 
28fe			 
28fe				if DEBUG_FORTH_WORDS 
28fe					DMARK "LSu" 
28fe f5				push af  
28ff 3a 13 29			ld a, (.dmark)  
2902 32 6b ee			ld (debug_mark),a  
2905 3a 14 29			ld a, (.dmark+1)  
2908 32 6c ee			ld (debug_mark+1),a  
290b 3a 15 29			ld a, (.dmark+2)  
290e 32 6d ee			ld (debug_mark+2),a  
2911 18 03			jr .pastdmark  
2913 ..			.dmark: db "LSu"  
2916 f1			.pastdmark: pop af  
2917			endm  
# End of macro DMARK
2917					CALLMONITOR 
2917 cd 6f ee			call debug_vector  
291a				endm  
# End of macro CALLMONITOR
291a				endif 
291a			 
291a					; found a uword but is it the one we want... 
291a			 
291a c5					push bc     ; uword to find is on bc 
291b d1					pop de 
291c			 
291c e5					push hl  ; to save the ptr 
291d			 
291d					; skip opcode 
291d 23					inc hl  
291e					; skip next ptr 
291e 23					inc hl  
291f 23					inc hl 
2920					; skip len 
2920 23					inc hl 
2921			 
2921				if DEBUG_FORTH_WORDS 
2921					DMARK "LSc" 
2921 f5				push af  
2922 3a 36 29			ld a, (.dmark)  
2925 32 6b ee			ld (debug_mark),a  
2928 3a 37 29			ld a, (.dmark+1)  
292b 32 6c ee			ld (debug_mark+1),a  
292e 3a 38 29			ld a, (.dmark+2)  
2931 32 6d ee			ld (debug_mark+2),a  
2934 18 03			jr .pastdmark  
2936 ..			.dmark: db "LSc"  
2939 f1			.pastdmark: pop af  
293a			endm  
# End of macro DMARK
293a					CALLMONITOR 
293a cd 6f ee			call debug_vector  
293d				endm  
# End of macro CALLMONITOR
293d				endif 
293d			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
293d			; ie. If WOO is defined first and then WO. Couldnt list WO. 
293d			; Nope that has gone the other way. It needs to be exact not on first zero 
293d			;		call strcmp 
293d c5					push bc 
293e cd 9d 11				call StrictStrCmp 
2941 c1					pop bc 
2942 c2 bc 28				jp nz, .ldouscanm 
2945				 
2945			 
2945			 
2945					; we have a uword so push its name to the stack 
2945			 
2945			;	   	push hl  ; save so we can move to next dict block 
2945 e1			pop hl 
2946			 
2946				if DEBUG_FORTH_WORDS 
2946					DMARK "LSm" 
2946 f5				push af  
2947 3a 5b 29			ld a, (.dmark)  
294a 32 6b ee			ld (debug_mark),a  
294d 3a 5c 29			ld a, (.dmark+1)  
2950 32 6c ee			ld (debug_mark+1),a  
2953 3a 5d 29			ld a, (.dmark+2)  
2956 32 6d ee			ld (debug_mark+2),a  
2959 18 03			jr .pastdmark  
295b ..			.dmark: db "LSm"  
295e f1			.pastdmark: pop af  
295f			endm  
# End of macro DMARK
295f					CALLMONITOR 
295f cd 6f ee			call debug_vector  
2962				endm  
# End of macro CALLMONITOR
2962				endif 
2962			 
2962					; skip opcode 
2962 23					inc hl  
2963					; skip next ptr 
2963 23					inc hl  
2964 23					inc hl 
2965					; skip len 
2965 7e					ld a, (hl)   ; save length to add 
2966				if DEBUG_FORTH_WORDS 
2966					DMARK "LS2" 
2966 f5				push af  
2967 3a 7b 29			ld a, (.dmark)  
296a 32 6b ee			ld (debug_mark),a  
296d 3a 7c 29			ld a, (.dmark+1)  
2970 32 6c ee			ld (debug_mark+1),a  
2973 3a 7d 29			ld a, (.dmark+2)  
2976 32 6d ee			ld (debug_mark+2),a  
2979 18 03			jr .pastdmark  
297b ..			.dmark: db "LS2"  
297e f1			.pastdmark: pop af  
297f			endm  
# End of macro DMARK
297f					CALLMONITOR 
297f cd 6f ee			call debug_vector  
2982				endm  
# End of macro CALLMONITOR
2982				endif 
2982			 
2982					; save this location 
2982				 
2982 e5					push hl 
2983			 
2983 23					inc hl 
2984 11 c3 e2				ld de, scratch+2 
2987 4f					ld c, a 
2988 06 00				ld b, 0 
298a			 
298a				if DEBUG_FORTH_WORDS 
298a					DMARK "LSn" 
298a f5				push af  
298b 3a 9f 29			ld a, (.dmark)  
298e 32 6b ee			ld (debug_mark),a  
2991 3a a0 29			ld a, (.dmark+1)  
2994 32 6c ee			ld (debug_mark+1),a  
2997 3a a1 29			ld a, (.dmark+2)  
299a 32 6d ee			ld (debug_mark+2),a  
299d 18 03			jr .pastdmark  
299f ..			.dmark: db "LSn"  
29a2 f1			.pastdmark: pop af  
29a3			endm  
# End of macro DMARK
29a3					CALLMONITOR 
29a3 cd 6f ee			call debug_vector  
29a6				endm  
# End of macro CALLMONITOR
29a6				endif 
29a6			 
29a6					; copy uword name to scratch 
29a6			 
29a6 ed b0				ldir 
29a8			 
29a8 1b					dec de 
29a9 3e 20				ld a, ' '    ; change null to space 
29ab 12					ld (de), a 
29ac			 
29ac 13					inc de 
29ad			 
29ad d5					push de 
29ae c1					pop bc     ; move scratch pointer to end of word name and save it 
29af			 
29af e1					pop hl 
29b0 7e					ld a, (hl) 
29b1					;inc hl 
29b1					; skip word string 
29b1 cd f2 0d				call addatohl 
29b4			 
29b4 23					inc hl 
29b5			 
29b5				if DEBUG_FORTH_WORDS 
29b5					DMARK "LS3" 
29b5 f5				push af  
29b6 3a ca 29			ld a, (.dmark)  
29b9 32 6b ee			ld (debug_mark),a  
29bc 3a cb 29			ld a, (.dmark+1)  
29bf 32 6c ee			ld (debug_mark+1),a  
29c2 3a cc 29			ld a, (.dmark+2)  
29c5 32 6d ee			ld (debug_mark+2),a  
29c8 18 03			jr .pastdmark  
29ca ..			.dmark: db "LS3"  
29cd f1			.pastdmark: pop af  
29ce			endm  
# End of macro DMARK
29ce					CALLMONITOR 
29ce cd 6f ee			call debug_vector  
29d1				endm  
# End of macro CALLMONITOR
29d1				endif 
29d1					; should now be at the start of the machine code to setup the eval of the uword 
29d1					; now locate the ptr to the string defintion 
29d1			 
29d1					; skip ld hl, 
29d1					; then load the ptr 
29d1			; TODO use get from hl ptr 
29d1 23					inc hl 
29d2 5e					ld e, (hl) 
29d3 23					inc hl 
29d4 56					ld d, (hl) 
29d5 eb					ex de, hl 
29d6			 
29d6			 
29d6				if DEBUG_FORTH_WORDS 
29d6					DMARK "LSt" 
29d6 f5				push af  
29d7 3a eb 29			ld a, (.dmark)  
29da 32 6b ee			ld (debug_mark),a  
29dd 3a ec 29			ld a, (.dmark+1)  
29e0 32 6c ee			ld (debug_mark+1),a  
29e3 3a ed 29			ld a, (.dmark+2)  
29e6 32 6d ee			ld (debug_mark+2),a  
29e9 18 03			jr .pastdmark  
29eb ..			.dmark: db "LSt"  
29ee f1			.pastdmark: pop af  
29ef			endm  
# End of macro DMARK
29ef					CALLMONITOR 
29ef cd 6f ee			call debug_vector  
29f2				endm  
# End of macro CALLMONITOR
29f2				endif 
29f2			 
29f2			; cant push right now due to tokenised strings  
29f2			 
29f2			; get the destination of where to copy this definition to. 
29f2			 
29f2 c5					push bc 
29f3 d1					pop de 
29f4			 
29f4 7e			.listl:         ld a,(hl) 
29f5 fe 00				cp 0 
29f7 28 09				jr z, .lreplsp     ; replace zero with space 
29f9					;cp FORTH_END_BUFFER 
29f9 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
29fb 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
29fd				 
29fd					; just copy this char as is then 
29fd			 
29fd 12					ld (de), a 
29fe			 
29fe 23			.listnxt:	inc hl 
29ff 13					inc de 
2a00 18 f2				jr .listl 
2a02			 
2a02 3e 20		.lreplsp:	ld a,' ' 
2a04 12					ld (de), a 
2a05 18 f7				jr .listnxt 
2a07			 
2a07			; close up uword def 
2a07			 
2a07			.listdone: 
2a07 12					ld (de), a 
2a08 13					inc de 
2a09 3e 00				ld a, 0 
2a0b 12					ld (de), a 
2a0c			 
2a0c			; now have def so clean up and push to stack 
2a0c			 
2a0c 21 c1 e2				ld hl, scratch 
2a0f				if DEBUG_FORTH_WORDS 
2a0f					DMARK "Ltp" 
2a0f f5				push af  
2a10 3a 24 2a			ld a, (.dmark)  
2a13 32 6b ee			ld (debug_mark),a  
2a16 3a 25 2a			ld a, (.dmark+1)  
2a19 32 6c ee			ld (debug_mark+1),a  
2a1c 3a 26 2a			ld a, (.dmark+2)  
2a1f 32 6d ee			ld (debug_mark+2),a  
2a22 18 03			jr .pastdmark  
2a24 ..			.dmark: db "Ltp"  
2a27 f1			.pastdmark: pop af  
2a28			endm  
# End of macro DMARK
2a28					CALLMONITOR 
2a28 cd 6f ee			call debug_vector  
2a2b				endm  
# End of macro CALLMONITOR
2a2b				endif 
2a2b			 
2a2b 18 1f			jr .listpush 
2a2d			 
2a2d			;.lnuword:	pop hl 
2a2d			;		call forth_tok_next 
2a2d			;		jp .ldouscan  
2a2d			 
2a2d			.lunotfound:		  
2a2d			 
2a2d				if DEBUG_FORTH_WORDS 
2a2d					DMARK "LSn" 
2a2d f5				push af  
2a2e 3a 42 2a			ld a, (.dmark)  
2a31 32 6b ee			ld (debug_mark),a  
2a34 3a 43 2a			ld a, (.dmark+1)  
2a37 32 6c ee			ld (debug_mark+1),a  
2a3a 3a 44 2a			ld a, (.dmark+2)  
2a3d 32 6d ee			ld (debug_mark+2),a  
2a40 18 03			jr .pastdmark  
2a42 ..			.dmark: db "LSn"  
2a45 f1			.pastdmark: pop af  
2a46			endm  
# End of macro DMARK
2a46					CALLMONITOR 
2a46 cd 6f ee			call debug_vector  
2a49				endm  
# End of macro CALLMONITOR
2a49				endif 
2a49			 
2a49					 
2a49			;		FORTH_DSP_POP 
2a49			;		ld hl, .luno 
2a49			 
2a49					NEXTW			 
2a49 c3 34 1f			jp macro_next 
2a4c				endm 
# End of macro NEXTW
2a4c			 
2a4c			.listpush: 
2a4c				if DEBUG_FORTH_WORDS 
2a4c					DMARK "LS>" 
2a4c f5				push af  
2a4d 3a 61 2a			ld a, (.dmark)  
2a50 32 6b ee			ld (debug_mark),a  
2a53 3a 62 2a			ld a, (.dmark+1)  
2a56 32 6c ee			ld (debug_mark+1),a  
2a59 3a 63 2a			ld a, (.dmark+2)  
2a5c 32 6d ee			ld (debug_mark+2),a  
2a5f 18 03			jr .pastdmark  
2a61 ..			.dmark: db "LS>"  
2a64 f1			.pastdmark: pop af  
2a65			endm  
# End of macro DMARK
2a65					CALLMONITOR 
2a65 cd 6f ee			call debug_vector  
2a68				endm  
# End of macro CALLMONITOR
2a68				endif 
2a68 cd e7 1b				call forth_push_str 
2a6b			 
2a6b			 
2a6b			 
2a6b					NEXTW 
2a6b c3 34 1f			jp macro_next 
2a6e				endm 
# End of macro NEXTW
2a6e			 
2a6e			;.luno:    db "Word not found",0 
2a6e			 
2a6e			 
2a6e			 
2a6e			 
2a6e			 
2a6e			;		push hl   ; save pointer to start of uword def string 
2a6e			; 
2a6e			;; look for FORTH_EOL_LINE 
2a6e			;		ld a, FORTH_END_BUFFER 
2a6e			;		call strlent 
2a6e			; 
2a6e			;		inc hl		 ; space for coln def 
2a6e			;		inc hl 
2a6e			;		inc hl          ; space for terms 
2a6e			;		inc hl 
2a6e			; 
2a6e			;		ld a, 20   ; TODO get actual length 
2a6e			;		call addatohl    ; include a random amount of room for the uword name 
2a6e			; 
2a6e			;		 
2a6e			;	if DEBUG_FORTH_WORDS 
2a6e			;		DMARK "Lt1" 
2a6e			;		CALLMONITOR 
2a6e			;	endif 
2a6e			;		 
2a6e			; 
2a6e			;; malloc space for the string because we cant change it 
2a6e			; 
2a6e			;		call malloc 
2a6e			;	if DEBUG_FORTH_MALLOC_GUARD 
2a6e			;		push af 
2a6e			;		call ishlzero 
2a6e			;		pop af 
2a6e			;		 
2a6e			;		call z,malloc_error 
2a6e			;	endif 
2a6e			; 
2a6e			;	if DEBUG_FORTH_WORDS 
2a6e			;		DMARK "Lt2" 
2a6e			;		CALLMONITOR 
2a6e			;	endif 
2a6e			;		pop de 
2a6e			;		push hl    ; push the malloc to release later 
2a6e			;		push hl   ;  push back a copy for the later stack push 
2a6e			;		 
2a6e			;; copy the string swapping out the zero terms for spaces 
2a6e			; 
2a6e			;		; de has our source 
2a6e			;		; hl has our dest 
2a6e			; 
2a6e			;; add the coln def 
2a6e			; 
2a6e			;		ld a, ':' 
2a6e			;		ld (hl), a 
2a6e			;		inc hl 
2a6e			;		ld a, ' ' 
2a6e			;		ld (hl), a 
2a6e			;		inc hl 
2a6e			; 
2a6e			;; add the uname word 
2a6e			;		push de   ; save our string for now 
2a6e			;		ex de, hl 
2a6e			; 
2a6e			;		FORTH_DSP_VALUE 
2a6e			;		;v5 FORTH_DSP_VALUE 
2a6e			; 
2a6e			;		inc hl   ; skip type but we know by now this is OK 
2a6e			; 
2a6e			;.luword:	ld a,(hl) 
2a6e			;		cp 0 
2a6e			;		jr z, .luword2 
2a6e			;		ld (de), a 
2a6e			;		inc de 
2a6e			;		inc hl 
2a6e			;		jr .luword 
2a6e			; 
2a6e			;.luword2:	ld a, ' ' 
2a6e			;		ld (de), a 
2a6e			;;		inc hl 
2a6e			;;		inc de 
2a6e			;;		ld (de), a 
2a6e			;;		inc hl 
2a6e			;		inc de 
2a6e			; 
2a6e			;		ex de, hl 
2a6e			;		pop de 
2a6e			;		 
2a6e			;		 
2a6e			; 
2a6e			;; detoken that string and copy it 
2a6e			; 
2a6e			;	if DEBUG_FORTH_WORDS 
2a6e			;		DMARK "Lt2" 
2a6e			;		CALLMONITOR 
2a6e			;	endif 
2a6e			;.ldetok:	ld a, (de) 
2a6e			;		cp FORTH_END_BUFFER 
2a6e			;		jr z, .ldetokend 
2a6e			;		; swap out any zero term for space 
2a6e			;		cp 0 
2a6e			;		jr nz, .ldetoknext 
2a6e			;		ld a, ' ' 
2a6e			; 
2a6e			;	if DEBUG_FORTH_WORDS 
2a6e			;		DMARK "LtS" 
2a6e			;		CALLMONITOR 
2a6e			;	endif 
2a6e			;.ldetoknext:	ld (hl), a 
2a6e			;		inc de 
2a6e			;		inc hl 
2a6e			;		jr .ldetok 
2a6e			; 
2a6e			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2a6e			;		ld (hl), a  
2a6e			; 
2a6e			;; free that temp malloc 
2a6e			; 
2a6e			;		pop hl    
2a6e			; 
2a6e			;	if DEBUG_FORTH_WORDS 
2a6e			;		DMARK "Lt4" 
2a6e			;		CALLMONITOR 
2a6e			;	endif 
2a6e			;		call forth_apushstrhl 
2a6e			; 
2a6e			;		; get rid of temp malloc area 
2a6e			; 
2a6e			;		pop hl 
2a6e			;		call free 
2a6e			; 
2a6e			;		jr .ludone 
2a6e			; 
2a6e			;.lnuword:	pop hl 
2a6e			;		call forth_tok_next 
2a6e			;		jp .ldouscan  
2a6e			; 
2a6e			;.ludone:		 pop hl 
2a6e			; 
2a6e					NEXTW 
2a6e c3 34 1f			jp macro_next 
2a71				endm 
# End of macro NEXTW
2a71			 
2a71			.FORGET: 
2a71				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2a71 5d				db WORD_SYS_CORE+73             
2a72 ea 2a			dw .NOP            
2a74 07				db 6 + 1 
2a75 .. 00			db "FORGET",0              
2a7c				endm 
# End of macro CWHEAD
2a7c			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2a7c			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2a7c			; | |  
2a7c			; | | e.g. "MORE" forget 
2a7c					if DEBUG_FORTH_WORDS_KEY 
2a7c						DMARK "FRG" 
2a7c f5				push af  
2a7d 3a 91 2a			ld a, (.dmark)  
2a80 32 6b ee			ld (debug_mark),a  
2a83 3a 92 2a			ld a, (.dmark+1)  
2a86 32 6c ee			ld (debug_mark+1),a  
2a89 3a 93 2a			ld a, (.dmark+2)  
2a8c 32 6d ee			ld (debug_mark+2),a  
2a8f 18 03			jr .pastdmark  
2a91 ..			.dmark: db "FRG"  
2a94 f1			.pastdmark: pop af  
2a95			endm  
# End of macro DMARK
2a95						CALLMONITOR 
2a95 cd 6f ee			call debug_vector  
2a98				endm  
# End of macro CALLMONITOR
2a98					endif 
2a98			 
2a98				; find uword 
2a98			        ; update start of word with "_" 
2a98				; replace uword with deleted flag 
2a98			 
2a98			 
2a98			;	if DEBUG_FORTH_WORDS 
2a98			;		DMARK "FOG" 
2a98			;		CALLMONITOR 
2a98			;	endif 
2a98			 
2a98			 
2a98					; Get ptr to the word we need to look up 
2a98			 
2a98					FORTH_DSP_VALUEHL 
2a98 cd 7e 1d			call macro_dsp_valuehl 
2a9b				endm 
# End of macro FORTH_DSP_VALUEHL
2a9b					;v5 FORTH_DSP_VALUE 
2a9b				; TODO type check 
2a9b			;		inc hl    ; Skip type check  
2a9b e5					push hl 
2a9c c1					pop bc 
2a9d			;		ex de, hl    ; put into DE 
2a9d			 
2a9d			 
2a9d 21 89 5e				ld hl, baseram 
2aa0					;ld hl, baseusermem 
2aa0			 
2aa0				; skip dict stub 
2aa0			;	call forth_tok_next 
2aa0 e5			push hl   ; sacreifical push 
2aa1			 
2aa1			.fldouscanm: 
2aa1 e1				pop hl 
2aa2			.fldouscan: 
2aa2			;	if DEBUG_FORTH_WORDS 
2aa2			;		DMARK "LSs" 
2aa2			;		CALLMONITOR 
2aa2			;	endif 
2aa2				; skip dict stub 
2aa2 cd 85 20				call forth_tok_next 
2aa5			 
2aa5			 
2aa5			; while we have words to look for 
2aa5			 
2aa5 7e				ld a, (hl)      
2aa6			;	if DEBUG_FORTH_WORDS 
2aa6			;		DMARK "LSk" 
2aa6			;		CALLMONITOR 
2aa6			;	endif 
2aa6 fe 00				cp WORD_SYS_END 
2aa8 ca e4 2a				jp z, .flunotfound 
2aab fe 01				cp WORD_SYS_UWORD 
2aad c2 a2 2a				jp nz, .fldouscan 
2ab0			 
2ab0			;	if DEBUG_FORTH_WORDS 
2ab0			;		DMARK "LSu" 
2ab0			;		CALLMONITOR 
2ab0			;	endif 
2ab0			 
2ab0					; found a uword but is it the one we want... 
2ab0			 
2ab0 c5					push bc     ; uword to find is on bc 
2ab1 d1					pop de 
2ab2			 
2ab2 e5					push hl  ; to save the ptr 
2ab3			 
2ab3					; skip opcode 
2ab3 23					inc hl  
2ab4					; skip next ptr 
2ab4 23					inc hl  
2ab5 23					inc hl 
2ab6					; skip len 
2ab6 23					inc hl 
2ab7			 
2ab7			;	if DEBUG_FORTH_WORDS 
2ab7			;		DMARK "LSc" 
2ab7			;		CALLMONITOR 
2ab7			;	endif 
2ab7 cd 90 11				call strcmp 
2aba c2 a1 2a				jp nz, .fldouscanm 
2abd			; 
2abd			; 
2abd			;; while we have words to look for 
2abd			; 
2abd			;.fdouscan:	ld a, (hl)      
2abd			;	if DEBUG_FORTH_WORDS 
2abd			;		DMARK "LSs" 
2abd			;		CALLMONITOR 
2abd			;	endif 
2abd			;		cp WORD_SYS_END 
2abd			;		jp z, .fudone 
2abd			;		cp WORD_SYS_UWORD 
2abd			;		jp nz, .fnuword 
2abd			; 
2abd			;	if DEBUG_FORTH_WORDS 
2abd			;		DMARK "FGu" 
2abd			;		CALLMONITOR 
2abd			;	endif 
2abd			; 
2abd			;		; found a uword but is it the one we want... 
2abd			; 
2abd			; 
2abd			;	        pop de   ; get back the dsp name 
2abd			;		push de 
2abd			; 
2abd			;		push hl  ; to save the ptr 
2abd			; 
2abd			;		; skip opcode 
2abd			;		inc hl  
2abd			;		; skip next ptr 
2abd			;		inc hl  
2abd			;		inc hl 
2abd			;		; skip len 
2abd			;		inc hl 
2abd			; 
2abd			;	if DEBUG_FORTH_WORDS 
2abd			;		DMARK "FGc" 
2abd			;		CALLMONITOR 
2abd			;	endif 
2abd			;		call strcmp 
2abd			;		jp nz, .fnuword 
2abd			 
2abd			 
2abd e1			pop hl 
2abe			 
2abe				 
2abe				if DEBUG_FORTH_WORDS 
2abe					DMARK "FGm" 
2abe f5				push af  
2abf 3a d3 2a			ld a, (.dmark)  
2ac2 32 6b ee			ld (debug_mark),a  
2ac5 3a d4 2a			ld a, (.dmark+1)  
2ac8 32 6c ee			ld (debug_mark+1),a  
2acb 3a d5 2a			ld a, (.dmark+2)  
2ace 32 6d ee			ld (debug_mark+2),a  
2ad1 18 03			jr .pastdmark  
2ad3 ..			.dmark: db "FGm"  
2ad6 f1			.pastdmark: pop af  
2ad7			endm  
# End of macro DMARK
2ad7					CALLMONITOR 
2ad7 cd 6f ee			call debug_vector  
2ada				endm  
# End of macro CALLMONITOR
2ada				endif 
2ada			 
2ada			 
2ada			 
2ada					; we have a uword so push its name to the stack 
2ada			 
2ada			;	   	push hl  ; save so we can move to next dict block 
2ada			;pop hl 
2ada			 
2ada					; update opcode to deleted 
2ada 3e 03				ld a, WORD_SYS_DELETED 
2adc 77					ld (hl), a 
2add			 
2add 23					inc hl  
2ade					; skip next ptr 
2ade 23					inc hl  
2adf 23					inc hl 
2ae0					; skip len 
2ae0 23					inc hl 
2ae1			 
2ae1					; TODO change parser to skip deleted words but for now mark it out 
2ae1 3e 5f				ld a, "_" 
2ae3 77					ld  (hl),a 
2ae4			 
2ae4			;		jr .fudone 
2ae4			; 
2ae4			;.fnuword:	pop hl 
2ae4			;		call forth_tok_next 
2ae4			;		jp .fdouscan  
2ae4			 
2ae4			.flunotfound:		  
2ae4			 
2ae4			 
2ae4					 
2ae4					FORTH_DSP_POP 
2ae4 cd 36 1e			call macro_forth_dsp_pop 
2ae7				endm 
# End of macro FORTH_DSP_POP
2ae7			;		ld hl, .luno 
2ae7			;.fudone:		 pop hl 
2ae7					NEXTW 
2ae7 c3 34 1f			jp macro_next 
2aea				endm 
# End of macro NEXTW
2aea			.NOP: 
2aea				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2aea 61				db WORD_SYS_CORE+77             
2aeb 11 2b			dw .COMO            
2aed 04				db 3 + 1 
2aee .. 00			db "NOP",0              
2af2				endm 
# End of macro CWHEAD
2af2			; | NOP (  --  ) Do nothing | DONE 
2af2					if DEBUG_FORTH_WORDS_KEY 
2af2						DMARK "NOP" 
2af2 f5				push af  
2af3 3a 07 2b			ld a, (.dmark)  
2af6 32 6b ee			ld (debug_mark),a  
2af9 3a 08 2b			ld a, (.dmark+1)  
2afc 32 6c ee			ld (debug_mark+1),a  
2aff 3a 09 2b			ld a, (.dmark+2)  
2b02 32 6d ee			ld (debug_mark+2),a  
2b05 18 03			jr .pastdmark  
2b07 ..			.dmark: db "NOP"  
2b0a f1			.pastdmark: pop af  
2b0b			endm  
# End of macro DMARK
2b0b						CALLMONITOR 
2b0b cd 6f ee			call debug_vector  
2b0e				endm  
# End of macro CALLMONITOR
2b0e					endif 
2b0e				       NEXTW 
2b0e c3 34 1f			jp macro_next 
2b11				endm 
# End of macro NEXTW
2b11			.COMO: 
2b11				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2b11 6e				db WORD_SYS_CORE+90             
2b12 63 2b			dw .COMC            
2b14 02				db 1 + 1 
2b15 .. 00			db "(",0              
2b17				endm 
# End of macro CWHEAD
2b17			; | ( ( -- )  Start of comment | DONE 
2b17			 
2b17			 
2b17 2a c2 e5				ld hl, ( os_tok_ptr) 
2b1a 11 5e 2b			ld de, .closepar 
2b1d					 
2b1d					if DEBUG_FORTH_WORDS 
2b1d						DMARK ").." 
2b1d f5				push af  
2b1e 3a 32 2b			ld a, (.dmark)  
2b21 32 6b ee			ld (debug_mark),a  
2b24 3a 33 2b			ld a, (.dmark+1)  
2b27 32 6c ee			ld (debug_mark+1),a  
2b2a 3a 34 2b			ld a, (.dmark+2)  
2b2d 32 6d ee			ld (debug_mark+2),a  
2b30 18 03			jr .pastdmark  
2b32 ..			.dmark: db ").."  
2b35 f1			.pastdmark: pop af  
2b36			endm  
# End of macro DMARK
2b36						CALLMONITOR 
2b36 cd 6f ee			call debug_vector  
2b39				endm  
# End of macro CALLMONITOR
2b39					endif 
2b39 cd 4f 20			call findnexttok  
2b3c			 
2b3c					if DEBUG_FORTH_WORDS 
2b3c						DMARK "IF5" 
2b3c f5				push af  
2b3d 3a 51 2b			ld a, (.dmark)  
2b40 32 6b ee			ld (debug_mark),a  
2b43 3a 52 2b			ld a, (.dmark+1)  
2b46 32 6c ee			ld (debug_mark+1),a  
2b49 3a 53 2b			ld a, (.dmark+2)  
2b4c 32 6d ee			ld (debug_mark+2),a  
2b4f 18 03			jr .pastdmark  
2b51 ..			.dmark: db "IF5"  
2b54 f1			.pastdmark: pop af  
2b55			endm  
# End of macro DMARK
2b55						CALLMONITOR 
2b55 cd 6f ee			call debug_vector  
2b58				endm  
# End of macro CALLMONITOR
2b58					endif 
2b58				; replace below with ) exec using tok_ptr 
2b58 22 c2 e5			ld (os_tok_ptr), hl 
2b5b c3 c5 1f			jp exec1 
2b5e			 
2b5e .. 00			.closepar:   db ")",0 
2b60			 
2b60				       NEXTW 
2b60 c3 34 1f			jp macro_next 
2b63				endm 
# End of macro NEXTW
2b63			.COMC: 
2b63				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2b63 6f				db WORD_SYS_CORE+91             
2b64 6c 2b			dw .SCRATCH            
2b66 02				db 1 + 1 
2b67 .. 00			db ")",0              
2b69				endm 
# End of macro CWHEAD
2b69			; | ) ( -- )  End of comment |  DONE  
2b69				       NEXTW 
2b69 c3 34 1f			jp macro_next 
2b6c				endm 
# End of macro NEXTW
2b6c			 
2b6c			.SCRATCH: 
2b6c				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2b6c 6f				db WORD_SYS_CORE+91             
2b6d a7 2b			dw .INC            
2b6f 08				db 7 + 1 
2b70 .. 00			db "SCRATCH",0              
2b78				endm 
# End of macro CWHEAD
2b78			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2b78			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2b78			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2b78			; | |  
2b78			; | | e.g.    : score $00 scratch ; 
2b78			; | |  
2b78			; | | $00 score ! 
2b78			; | | $01 score +! 
2b78			; | |  
2b78			; | | e.g.   : varword $0a scratch ;  
2b78			; | | 
2b78			; | | $8000 varword ! 
2b78					if DEBUG_FORTH_WORDS_KEY 
2b78						DMARK "SCR" 
2b78 f5				push af  
2b79 3a 8d 2b			ld a, (.dmark)  
2b7c 32 6b ee			ld (debug_mark),a  
2b7f 3a 8e 2b			ld a, (.dmark+1)  
2b82 32 6c ee			ld (debug_mark+1),a  
2b85 3a 8f 2b			ld a, (.dmark+2)  
2b88 32 6d ee			ld (debug_mark+2),a  
2b8b 18 03			jr .pastdmark  
2b8d ..			.dmark: db "SCR"  
2b90 f1			.pastdmark: pop af  
2b91			endm  
# End of macro DMARK
2b91						CALLMONITOR 
2b91 cd 6f ee			call debug_vector  
2b94				endm  
# End of macro CALLMONITOR
2b94					endif 
2b94			 
2b94					FORTH_DSP_VALUEHL 
2b94 cd 7e 1d			call macro_dsp_valuehl 
2b97				endm 
# End of macro FORTH_DSP_VALUEHL
2b97				 
2b97					FORTH_DSP_POP 
2b97 cd 36 1e			call macro_forth_dsp_pop 
2b9a				endm 
# End of macro FORTH_DSP_POP
2b9a			 
2b9a 7d					ld a, l 
2b9b 21 e6 e7				ld hl, os_var_array 
2b9e cd f2 0d				call addatohl 
2ba1			 
2ba1 cd 79 1b				call forth_push_numhl 
2ba4			 
2ba4				       NEXTW 
2ba4 c3 34 1f			jp macro_next 
2ba7				endm 
# End of macro NEXTW
2ba7			 
2ba7			.INC: 
2ba7				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2ba7 6f				db WORD_SYS_CORE+91             
2ba8 fd 2b			dw .DEC            
2baa 03				db 2 + 1 
2bab .. 00			db "+!",0              
2bae				endm 
# End of macro CWHEAD
2bae			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2bae					if DEBUG_FORTH_WORDS_KEY 
2bae						DMARK "+s_" 
2bae f5				push af  
2baf 3a c3 2b			ld a, (.dmark)  
2bb2 32 6b ee			ld (debug_mark),a  
2bb5 3a c4 2b			ld a, (.dmark+1)  
2bb8 32 6c ee			ld (debug_mark+1),a  
2bbb 3a c5 2b			ld a, (.dmark+2)  
2bbe 32 6d ee			ld (debug_mark+2),a  
2bc1 18 03			jr .pastdmark  
2bc3 ..			.dmark: db "+s_"  
2bc6 f1			.pastdmark: pop af  
2bc7			endm  
# End of macro DMARK
2bc7						CALLMONITOR 
2bc7 cd 6f ee			call debug_vector  
2bca				endm  
# End of macro CALLMONITOR
2bca					endif 
2bca			 
2bca					FORTH_DSP_VALUEHL 
2bca cd 7e 1d			call macro_dsp_valuehl 
2bcd				endm 
# End of macro FORTH_DSP_VALUEHL
2bcd			 
2bcd e5					push hl   ; save address 
2bce			 
2bce					FORTH_DSP_POP 
2bce cd 36 1e			call macro_forth_dsp_pop 
2bd1				endm 
# End of macro FORTH_DSP_POP
2bd1			 
2bd1					FORTH_DSP_VALUEHL 
2bd1 cd 7e 1d			call macro_dsp_valuehl 
2bd4				endm 
# End of macro FORTH_DSP_VALUEHL
2bd4			 
2bd4 e5					push hl 
2bd5					FORTH_DSP_POP 
2bd5 cd 36 1e			call macro_forth_dsp_pop 
2bd8				endm 
# End of macro FORTH_DSP_POP
2bd8 e1					pop hl 
2bd9			 
2bd9					; hl contains value to add to byte at a 
2bd9				 
2bd9 eb					ex de, hl 
2bda			 
2bda e1					pop hl 
2bdb			 
2bdb					if DEBUG_FORTH_WORDS 
2bdb						DMARK "INC" 
2bdb f5				push af  
2bdc 3a f0 2b			ld a, (.dmark)  
2bdf 32 6b ee			ld (debug_mark),a  
2be2 3a f1 2b			ld a, (.dmark+1)  
2be5 32 6c ee			ld (debug_mark+1),a  
2be8 3a f2 2b			ld a, (.dmark+2)  
2beb 32 6d ee			ld (debug_mark+2),a  
2bee 18 03			jr .pastdmark  
2bf0 ..			.dmark: db "INC"  
2bf3 f1			.pastdmark: pop af  
2bf4			endm  
# End of macro DMARK
2bf4						CALLMONITOR 
2bf4 cd 6f ee			call debug_vector  
2bf7				endm  
# End of macro CALLMONITOR
2bf7					endif 
2bf7			 
2bf7 7e					ld a,(hl) 
2bf8 83					add e 
2bf9 77					ld (hl),a 
2bfa			 
2bfa			 
2bfa			 
2bfa				       NEXTW 
2bfa c3 34 1f			jp macro_next 
2bfd				endm 
# End of macro NEXTW
2bfd			 
2bfd			.DEC: 
2bfd				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2bfd 6f				db WORD_SYS_CORE+91             
2bfe 51 2c			dw .INC2            
2c00 03				db 2 + 1 
2c01 .. 00			db "-!",0              
2c04				endm 
# End of macro CWHEAD
2c04			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2c04					if DEBUG_FORTH_WORDS_KEY 
2c04						DMARK "-s_" 
2c04 f5				push af  
2c05 3a 19 2c			ld a, (.dmark)  
2c08 32 6b ee			ld (debug_mark),a  
2c0b 3a 1a 2c			ld a, (.dmark+1)  
2c0e 32 6c ee			ld (debug_mark+1),a  
2c11 3a 1b 2c			ld a, (.dmark+2)  
2c14 32 6d ee			ld (debug_mark+2),a  
2c17 18 03			jr .pastdmark  
2c19 ..			.dmark: db "-s_"  
2c1c f1			.pastdmark: pop af  
2c1d			endm  
# End of macro DMARK
2c1d						CALLMONITOR 
2c1d cd 6f ee			call debug_vector  
2c20				endm  
# End of macro CALLMONITOR
2c20					endif 
2c20			 
2c20					FORTH_DSP_VALUEHL 
2c20 cd 7e 1d			call macro_dsp_valuehl 
2c23				endm 
# End of macro FORTH_DSP_VALUEHL
2c23			 
2c23 e5					push hl   ; save address 
2c24			 
2c24					FORTH_DSP_POP 
2c24 cd 36 1e			call macro_forth_dsp_pop 
2c27				endm 
# End of macro FORTH_DSP_POP
2c27			 
2c27					FORTH_DSP_VALUEHL 
2c27 cd 7e 1d			call macro_dsp_valuehl 
2c2a				endm 
# End of macro FORTH_DSP_VALUEHL
2c2a			 
2c2a					; hl contains value to add to byte at a 
2c2a				 
2c2a eb					ex de, hl 
2c2b			 
2c2b e1					pop hl 
2c2c			 
2c2c					if DEBUG_FORTH_WORDS 
2c2c						DMARK "DEC" 
2c2c f5				push af  
2c2d 3a 41 2c			ld a, (.dmark)  
2c30 32 6b ee			ld (debug_mark),a  
2c33 3a 42 2c			ld a, (.dmark+1)  
2c36 32 6c ee			ld (debug_mark+1),a  
2c39 3a 43 2c			ld a, (.dmark+2)  
2c3c 32 6d ee			ld (debug_mark+2),a  
2c3f 18 03			jr .pastdmark  
2c41 ..			.dmark: db "DEC"  
2c44 f1			.pastdmark: pop af  
2c45			endm  
# End of macro DMARK
2c45						CALLMONITOR 
2c45 cd 6f ee			call debug_vector  
2c48				endm  
# End of macro CALLMONITOR
2c48					endif 
2c48			 
2c48 7e					ld a,(hl) 
2c49 93					sub e 
2c4a 77					ld (hl),a 
2c4b			 
2c4b			 
2c4b					FORTH_DSP_POP 
2c4b cd 36 1e			call macro_forth_dsp_pop 
2c4e				endm 
# End of macro FORTH_DSP_POP
2c4e			 
2c4e				       NEXTW 
2c4e c3 34 1f			jp macro_next 
2c51				endm 
# End of macro NEXTW
2c51			 
2c51			.INC2: 
2c51				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2c51 6f				db WORD_SYS_CORE+91             
2c52 fe 2c			dw .DEC2            
2c54 04				db 3 + 1 
2c55 .. 00			db "+2!",0              
2c59				endm 
# End of macro CWHEAD
2c59			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2c59			 
2c59					if DEBUG_FORTH_WORDS_KEY 
2c59						DMARK "+2s" 
2c59 f5				push af  
2c5a 3a 6e 2c			ld a, (.dmark)  
2c5d 32 6b ee			ld (debug_mark),a  
2c60 3a 6f 2c			ld a, (.dmark+1)  
2c63 32 6c ee			ld (debug_mark+1),a  
2c66 3a 70 2c			ld a, (.dmark+2)  
2c69 32 6d ee			ld (debug_mark+2),a  
2c6c 18 03			jr .pastdmark  
2c6e ..			.dmark: db "+2s"  
2c71 f1			.pastdmark: pop af  
2c72			endm  
# End of macro DMARK
2c72						CALLMONITOR 
2c72 cd 6f ee			call debug_vector  
2c75				endm  
# End of macro CALLMONITOR
2c75					endif 
2c75			 
2c75					; Address 
2c75			 
2c75					FORTH_DSP_VALUEHL 
2c75 cd 7e 1d			call macro_dsp_valuehl 
2c78				endm 
# End of macro FORTH_DSP_VALUEHL
2c78			 
2c78 e5					push hl    ; save address 
2c79			 
2c79					; load content into de 
2c79			 
2c79 5e					ld e,(hl) 
2c7a 23					inc hl 
2c7b 56					ld d, (hl) 
2c7c			 
2c7c					if DEBUG_FORTH_WORDS 
2c7c						DMARK "+2a" 
2c7c f5				push af  
2c7d 3a 91 2c			ld a, (.dmark)  
2c80 32 6b ee			ld (debug_mark),a  
2c83 3a 92 2c			ld a, (.dmark+1)  
2c86 32 6c ee			ld (debug_mark+1),a  
2c89 3a 93 2c			ld a, (.dmark+2)  
2c8c 32 6d ee			ld (debug_mark+2),a  
2c8f 18 03			jr .pastdmark  
2c91 ..			.dmark: db "+2a"  
2c94 f1			.pastdmark: pop af  
2c95			endm  
# End of macro DMARK
2c95						CALLMONITOR 
2c95 cd 6f ee			call debug_vector  
2c98				endm  
# End of macro CALLMONITOR
2c98					endif 
2c98			 
2c98					FORTH_DSP_POP 
2c98 cd 36 1e			call macro_forth_dsp_pop 
2c9b				endm 
# End of macro FORTH_DSP_POP
2c9b			 
2c9b					; Get value to add 
2c9b			 
2c9b					FORTH_DSP_VALUE 
2c9b cd 67 1d			call macro_forth_dsp_value 
2c9e				endm 
# End of macro FORTH_DSP_VALUE
2c9e			 
2c9e					if DEBUG_FORTH_WORDS 
2c9e						DMARK "+2v" 
2c9e f5				push af  
2c9f 3a b3 2c			ld a, (.dmark)  
2ca2 32 6b ee			ld (debug_mark),a  
2ca5 3a b4 2c			ld a, (.dmark+1)  
2ca8 32 6c ee			ld (debug_mark+1),a  
2cab 3a b5 2c			ld a, (.dmark+2)  
2cae 32 6d ee			ld (debug_mark+2),a  
2cb1 18 03			jr .pastdmark  
2cb3 ..			.dmark: db "+2v"  
2cb6 f1			.pastdmark: pop af  
2cb7			endm  
# End of macro DMARK
2cb7						CALLMONITOR 
2cb7 cd 6f ee			call debug_vector  
2cba				endm  
# End of macro CALLMONITOR
2cba					endif 
2cba			 
2cba 19					add hl, de 
2cbb			 
2cbb					if DEBUG_FORTH_WORDS 
2cbb						DMARK "+2+" 
2cbb f5				push af  
2cbc 3a d0 2c			ld a, (.dmark)  
2cbf 32 6b ee			ld (debug_mark),a  
2cc2 3a d1 2c			ld a, (.dmark+1)  
2cc5 32 6c ee			ld (debug_mark+1),a  
2cc8 3a d2 2c			ld a, (.dmark+2)  
2ccb 32 6d ee			ld (debug_mark+2),a  
2cce 18 03			jr .pastdmark  
2cd0 ..			.dmark: db "+2+"  
2cd3 f1			.pastdmark: pop af  
2cd4			endm  
# End of macro DMARK
2cd4						CALLMONITOR 
2cd4 cd 6f ee			call debug_vector  
2cd7				endm  
# End of macro CALLMONITOR
2cd7					endif 
2cd7			 
2cd7					; move result to de 
2cd7			 
2cd7 eb					ex de, hl 
2cd8			 
2cd8					; Address 
2cd8			 
2cd8 e1					pop hl 
2cd9			 
2cd9					; save it back 
2cd9			 
2cd9 73					ld (hl), e 
2cda 23					inc hl 
2cdb 72					ld (hl), d 
2cdc			 
2cdc					if DEBUG_FORTH_WORDS 
2cdc						DMARK "+2e" 
2cdc f5				push af  
2cdd 3a f1 2c			ld a, (.dmark)  
2ce0 32 6b ee			ld (debug_mark),a  
2ce3 3a f2 2c			ld a, (.dmark+1)  
2ce6 32 6c ee			ld (debug_mark+1),a  
2ce9 3a f3 2c			ld a, (.dmark+2)  
2cec 32 6d ee			ld (debug_mark+2),a  
2cef 18 03			jr .pastdmark  
2cf1 ..			.dmark: db "+2e"  
2cf4 f1			.pastdmark: pop af  
2cf5			endm  
# End of macro DMARK
2cf5						CALLMONITOR 
2cf5 cd 6f ee			call debug_vector  
2cf8				endm  
# End of macro CALLMONITOR
2cf8					endif 
2cf8			 
2cf8			 
2cf8			 
2cf8					FORTH_DSP_POP 
2cf8 cd 36 1e			call macro_forth_dsp_pop 
2cfb				endm 
# End of macro FORTH_DSP_POP
2cfb			 
2cfb			 
2cfb				       NEXTW 
2cfb c3 34 1f			jp macro_next 
2cfe				endm 
# End of macro NEXTW
2cfe			 
2cfe			.DEC2: 
2cfe				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2cfe 6f				db WORD_SYS_CORE+91             
2cff ad 2d			dw .GET2            
2d01 04				db 3 + 1 
2d02 .. 00			db "-2!",0              
2d06				endm 
# End of macro CWHEAD
2d06			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2d06			 
2d06			 
2d06					if DEBUG_FORTH_WORDS_KEY 
2d06						DMARK "-2s" 
2d06 f5				push af  
2d07 3a 1b 2d			ld a, (.dmark)  
2d0a 32 6b ee			ld (debug_mark),a  
2d0d 3a 1c 2d			ld a, (.dmark+1)  
2d10 32 6c ee			ld (debug_mark+1),a  
2d13 3a 1d 2d			ld a, (.dmark+2)  
2d16 32 6d ee			ld (debug_mark+2),a  
2d19 18 03			jr .pastdmark  
2d1b ..			.dmark: db "-2s"  
2d1e f1			.pastdmark: pop af  
2d1f			endm  
# End of macro DMARK
2d1f						CALLMONITOR 
2d1f cd 6f ee			call debug_vector  
2d22				endm  
# End of macro CALLMONITOR
2d22					endif 
2d22			 
2d22					; Address 
2d22			 
2d22					FORTH_DSP_VALUEHL 
2d22 cd 7e 1d			call macro_dsp_valuehl 
2d25				endm 
# End of macro FORTH_DSP_VALUEHL
2d25			 
2d25 e5					push hl    ; save address 
2d26			 
2d26					; load content into de 
2d26			 
2d26 5e					ld e,(hl) 
2d27 23					inc hl 
2d28 56					ld d, (hl) 
2d29			 
2d29					if DEBUG_FORTH_WORDS 
2d29						DMARK "-2a" 
2d29 f5				push af  
2d2a 3a 3e 2d			ld a, (.dmark)  
2d2d 32 6b ee			ld (debug_mark),a  
2d30 3a 3f 2d			ld a, (.dmark+1)  
2d33 32 6c ee			ld (debug_mark+1),a  
2d36 3a 40 2d			ld a, (.dmark+2)  
2d39 32 6d ee			ld (debug_mark+2),a  
2d3c 18 03			jr .pastdmark  
2d3e ..			.dmark: db "-2a"  
2d41 f1			.pastdmark: pop af  
2d42			endm  
# End of macro DMARK
2d42						CALLMONITOR 
2d42 cd 6f ee			call debug_vector  
2d45				endm  
# End of macro CALLMONITOR
2d45					endif 
2d45			 
2d45					FORTH_DSP_POP 
2d45 cd 36 1e			call macro_forth_dsp_pop 
2d48				endm 
# End of macro FORTH_DSP_POP
2d48			 
2d48					; Get value to remove 
2d48			 
2d48					FORTH_DSP_VALUE 
2d48 cd 67 1d			call macro_forth_dsp_value 
2d4b				endm 
# End of macro FORTH_DSP_VALUE
2d4b			 
2d4b					if DEBUG_FORTH_WORDS 
2d4b						DMARK "-2v" 
2d4b f5				push af  
2d4c 3a 60 2d			ld a, (.dmark)  
2d4f 32 6b ee			ld (debug_mark),a  
2d52 3a 61 2d			ld a, (.dmark+1)  
2d55 32 6c ee			ld (debug_mark+1),a  
2d58 3a 62 2d			ld a, (.dmark+2)  
2d5b 32 6d ee			ld (debug_mark+2),a  
2d5e 18 03			jr .pastdmark  
2d60 ..			.dmark: db "-2v"  
2d63 f1			.pastdmark: pop af  
2d64			endm  
# End of macro DMARK
2d64						CALLMONITOR 
2d64 cd 6f ee			call debug_vector  
2d67				endm  
# End of macro CALLMONITOR
2d67					endif 
2d67			 
2d67 eb					ex de, hl 
2d68 ed 52				sbc hl, de 
2d6a			 
2d6a					if DEBUG_FORTH_WORDS 
2d6a						DMARK "-2d" 
2d6a f5				push af  
2d6b 3a 7f 2d			ld a, (.dmark)  
2d6e 32 6b ee			ld (debug_mark),a  
2d71 3a 80 2d			ld a, (.dmark+1)  
2d74 32 6c ee			ld (debug_mark+1),a  
2d77 3a 81 2d			ld a, (.dmark+2)  
2d7a 32 6d ee			ld (debug_mark+2),a  
2d7d 18 03			jr .pastdmark  
2d7f ..			.dmark: db "-2d"  
2d82 f1			.pastdmark: pop af  
2d83			endm  
# End of macro DMARK
2d83						CALLMONITOR 
2d83 cd 6f ee			call debug_vector  
2d86				endm  
# End of macro CALLMONITOR
2d86					endif 
2d86			 
2d86					; move result to de 
2d86			 
2d86 eb					ex de, hl 
2d87			 
2d87					; Address 
2d87			 
2d87 e1					pop hl 
2d88			 
2d88					; save it back 
2d88			 
2d88 73					ld (hl), e 
2d89 23					inc hl 
2d8a 72					ld (hl), d 
2d8b			 
2d8b					if DEBUG_FORTH_WORDS 
2d8b						DMARK "-2e" 
2d8b f5				push af  
2d8c 3a a0 2d			ld a, (.dmark)  
2d8f 32 6b ee			ld (debug_mark),a  
2d92 3a a1 2d			ld a, (.dmark+1)  
2d95 32 6c ee			ld (debug_mark+1),a  
2d98 3a a2 2d			ld a, (.dmark+2)  
2d9b 32 6d ee			ld (debug_mark+2),a  
2d9e 18 03			jr .pastdmark  
2da0 ..			.dmark: db "-2e"  
2da3 f1			.pastdmark: pop af  
2da4			endm  
# End of macro DMARK
2da4						CALLMONITOR 
2da4 cd 6f ee			call debug_vector  
2da7				endm  
# End of macro CALLMONITOR
2da7					endif 
2da7			 
2da7			 
2da7					FORTH_DSP_POP 
2da7 cd 36 1e			call macro_forth_dsp_pop 
2daa				endm 
# End of macro FORTH_DSP_POP
2daa			 
2daa			 
2daa			 
2daa				       NEXTW 
2daa c3 34 1f			jp macro_next 
2dad				endm 
# End of macro NEXTW
2dad			.GET2: 
2dad				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2dad 6f				db WORD_SYS_CORE+91             
2dae e2 2d			dw .BANG2            
2db0 03				db 2 + 1 
2db1 .. 00			db "2@",0              
2db4				endm 
# End of macro CWHEAD
2db4			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2db4					if DEBUG_FORTH_WORDS_KEY 
2db4						DMARK "2A_" 
2db4 f5				push af  
2db5 3a c9 2d			ld a, (.dmark)  
2db8 32 6b ee			ld (debug_mark),a  
2dbb 3a ca 2d			ld a, (.dmark+1)  
2dbe 32 6c ee			ld (debug_mark+1),a  
2dc1 3a cb 2d			ld a, (.dmark+2)  
2dc4 32 6d ee			ld (debug_mark+2),a  
2dc7 18 03			jr .pastdmark  
2dc9 ..			.dmark: db "2A_"  
2dcc f1			.pastdmark: pop af  
2dcd			endm  
# End of macro DMARK
2dcd						CALLMONITOR 
2dcd cd 6f ee			call debug_vector  
2dd0				endm  
# End of macro CALLMONITOR
2dd0					endif 
2dd0			 
2dd0					FORTH_DSP_VALUEHL 
2dd0 cd 7e 1d			call macro_dsp_valuehl 
2dd3				endm 
# End of macro FORTH_DSP_VALUEHL
2dd3			 
2dd3 e5					push hl   ; save address 
2dd4			 
2dd4					FORTH_DSP_POP 
2dd4 cd 36 1e			call macro_forth_dsp_pop 
2dd7				endm 
# End of macro FORTH_DSP_POP
2dd7			 
2dd7 e1					pop hl 
2dd8			 
2dd8 5e					ld e, (hl) 
2dd9 23					inc hl 
2dda 56					ld d, (hl) 
2ddb			 
2ddb eb					ex de, hl 
2ddc			 
2ddc cd 79 1b				call forth_push_numhl 
2ddf			 
2ddf				       NEXTW 
2ddf c3 34 1f			jp macro_next 
2de2				endm 
# End of macro NEXTW
2de2			.BANG2: 
2de2				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2de2 6f				db WORD_SYS_CORE+91             
2de3 1a 2e			dw .CONFIG            
2de5 03				db 2 + 1 
2de6 .. 00			db "2!",0              
2de9				endm 
# End of macro CWHEAD
2de9			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2de9					if DEBUG_FORTH_WORDS_KEY 
2de9						DMARK "2S_" 
2de9 f5				push af  
2dea 3a fe 2d			ld a, (.dmark)  
2ded 32 6b ee			ld (debug_mark),a  
2df0 3a ff 2d			ld a, (.dmark+1)  
2df3 32 6c ee			ld (debug_mark+1),a  
2df6 3a 00 2e			ld a, (.dmark+2)  
2df9 32 6d ee			ld (debug_mark+2),a  
2dfc 18 03			jr .pastdmark  
2dfe ..			.dmark: db "2S_"  
2e01 f1			.pastdmark: pop af  
2e02			endm  
# End of macro DMARK
2e02						CALLMONITOR 
2e02 cd 6f ee			call debug_vector  
2e05				endm  
# End of macro CALLMONITOR
2e05					endif 
2e05			 
2e05					FORTH_DSP_VALUEHL 
2e05 cd 7e 1d			call macro_dsp_valuehl 
2e08				endm 
# End of macro FORTH_DSP_VALUEHL
2e08			 
2e08 e5					push hl   ; save address 
2e09			 
2e09			 
2e09					FORTH_DSP_POP 
2e09 cd 36 1e			call macro_forth_dsp_pop 
2e0c				endm 
# End of macro FORTH_DSP_POP
2e0c			 
2e0c					 
2e0c					FORTH_DSP_VALUEHL 
2e0c cd 7e 1d			call macro_dsp_valuehl 
2e0f				endm 
# End of macro FORTH_DSP_VALUEHL
2e0f			 
2e0f					FORTH_DSP_POP 
2e0f cd 36 1e			call macro_forth_dsp_pop 
2e12				endm 
# End of macro FORTH_DSP_POP
2e12			 
2e12 eb					ex de, hl    ; value now in de 
2e13			 
2e13 e1					pop hl 
2e14			 
2e14 73					ld (hl), e 
2e15			 
2e15 23					inc hl 
2e16			 
2e16 72					ld (hl), d 
2e17			 
2e17			 
2e17				       NEXTW 
2e17 c3 34 1f			jp macro_next 
2e1a				endm 
# End of macro NEXTW
2e1a			.CONFIG: 
2e1a				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
2e1a 6f				db WORD_SYS_CORE+91             
2e1b 2b 2e			dw .ADTOS            
2e1d 07				db 6 + 1 
2e1e .. 00			db "CONFIG",0              
2e25				endm 
# End of macro CWHEAD
2e25			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2e25			 
2e25 cd 66 13				call config 
2e28					NEXTW 
2e28 c3 34 1f			jp macro_next 
2e2b				endm 
# End of macro NEXTW
2e2b			 
2e2b			.ADTOS: 
2e2b				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
2e2b 6f				db WORD_SYS_CORE+91             
2e2c 41 2e			dw .SBTOS            
2e2e 03				db 2 + 1 
2e2f .. 00			db "1+",0              
2e32				endm 
# End of macro CWHEAD
2e32			; | 1+ ( u -- u )  Increment value on TOS | DONE 
2e32			 
2e32					FORTH_DSP_VALUEHL 
2e32 cd 7e 1d			call macro_dsp_valuehl 
2e35				endm 
# End of macro FORTH_DSP_VALUEHL
2e35 e5					push hl 
2e36			 
2e36					FORTH_DSP_POP 
2e36 cd 36 1e			call macro_forth_dsp_pop 
2e39				endm 
# End of macro FORTH_DSP_POP
2e39 e1					pop hl 
2e3a			 
2e3a 23					inc hl 
2e3b cd 79 1b				call forth_push_numhl 
2e3e					 
2e3e					NEXTW 
2e3e c3 34 1f			jp macro_next 
2e41				endm 
# End of macro NEXTW
2e41			.SBTOS: 
2e41				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
2e41 6f				db WORD_SYS_CORE+91             
2e42 57 2e			dw .ADSTORE            
2e44 03				db 2 + 1 
2e45 .. 00			db "1-",0              
2e48				endm 
# End of macro CWHEAD
2e48			; | 1- ( u -- u )  Decrement value on TOS | DONE 
2e48			 
2e48					FORTH_DSP_VALUEHL 
2e48 cd 7e 1d			call macro_dsp_valuehl 
2e4b				endm 
# End of macro FORTH_DSP_VALUEHL
2e4b e5					push hl 
2e4c			 
2e4c					FORTH_DSP_POP 
2e4c cd 36 1e			call macro_forth_dsp_pop 
2e4f				endm 
# End of macro FORTH_DSP_POP
2e4f e1					pop hl 
2e50			 
2e50 2b					dec hl 
2e51 cd 79 1b				call forth_push_numhl 
2e54					 
2e54					NEXTW 
2e54 c3 34 1f			jp macro_next 
2e57				endm 
# End of macro NEXTW
2e57			.ADSTORE: 
2e57				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
2e57 6f				db WORD_SYS_CORE+91             
2e58 6d 2e			dw .ADWSTORE            
2e5a 04				db 3 + 1 
2e5b .. 00			db "1+!",0              
2e5f				endm 
# End of macro CWHEAD
2e5f			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
2e5f			 
2e5f					FORTH_DSP_VALUEHL 
2e5f cd 7e 1d			call macro_dsp_valuehl 
2e62				endm 
# End of macro FORTH_DSP_VALUEHL
2e62 e5					push hl 
2e63			 
2e63					FORTH_DSP_POP 
2e63 cd 36 1e			call macro_forth_dsp_pop 
2e66				endm 
# End of macro FORTH_DSP_POP
2e66 e1					pop hl 
2e67			 
2e67 7e					ld a, (hl) 
2e68 3c					inc a 
2e69 77					ld (hl), a 
2e6a					 
2e6a					NEXTW 
2e6a c3 34 1f			jp macro_next 
2e6d				endm 
# End of macro NEXTW
2e6d			.ADWSTORE: 
2e6d				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
2e6d 6f				db WORD_SYS_CORE+91             
2e6e 8b 2e			dw .SBSTORE            
2e70 05				db 4 + 1 
2e71 .. 00			db "1+2!",0              
2e76				endm 
# End of macro CWHEAD
2e76			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
2e76			 
2e76					FORTH_DSP_VALUEHL 
2e76 cd 7e 1d			call macro_dsp_valuehl 
2e79				endm 
# End of macro FORTH_DSP_VALUEHL
2e79 e5					push hl 
2e7a			 
2e7a					FORTH_DSP_POP 
2e7a cd 36 1e			call macro_forth_dsp_pop 
2e7d				endm 
# End of macro FORTH_DSP_POP
2e7d e1					pop hl 
2e7e			 
2e7e e5					push hl 
2e7f			 
2e7f cd b6 1e				call loadwordinhl 
2e82 23					inc hl 
2e83			 
2e83 d1					pop de 
2e84 eb					ex de, hl 
2e85 73					ld (hl), e 
2e86 23					inc hl 
2e87 72					ld (hl), d 
2e88					 
2e88					NEXTW 
2e88 c3 34 1f			jp macro_next 
2e8b				endm 
# End of macro NEXTW
2e8b			.SBSTORE: 
2e8b				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
2e8b 6f				db WORD_SYS_CORE+91             
2e8c a1 2e			dw .SBWSTORE            
2e8e 04				db 3 + 1 
2e8f .. 00			db "1-!",0              
2e93				endm 
# End of macro CWHEAD
2e93			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
2e93			 
2e93					FORTH_DSP_VALUEHL 
2e93 cd 7e 1d			call macro_dsp_valuehl 
2e96				endm 
# End of macro FORTH_DSP_VALUEHL
2e96 e5					push hl 
2e97			 
2e97					FORTH_DSP_POP 
2e97 cd 36 1e			call macro_forth_dsp_pop 
2e9a				endm 
# End of macro FORTH_DSP_POP
2e9a e1					pop hl 
2e9b			 
2e9b 7e					ld a, (hl) 
2e9c 3d					dec a 
2e9d 77					ld (hl), a 
2e9e					 
2e9e					NEXTW 
2e9e c3 34 1f			jp macro_next 
2ea1				endm 
# End of macro NEXTW
2ea1			.SBWSTORE: 
2ea1				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
2ea1 6f				db WORD_SYS_CORE+91             
2ea2 bf 2e			dw .ENDCORE            
2ea4 05				db 4 + 1 
2ea5 .. 00			db "1-2!",0              
2eaa				endm 
# End of macro CWHEAD
2eaa			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
2eaa			 
2eaa					FORTH_DSP_VALUEHL 
2eaa cd 7e 1d			call macro_dsp_valuehl 
2ead				endm 
# End of macro FORTH_DSP_VALUEHL
2ead e5					push hl 
2eae			 
2eae					FORTH_DSP_POP 
2eae cd 36 1e			call macro_forth_dsp_pop 
2eb1				endm 
# End of macro FORTH_DSP_POP
2eb1 e1					pop hl 
2eb2			 
2eb2 e5					push hl 
2eb3			 
2eb3 cd b6 1e				call loadwordinhl 
2eb6 2b					dec hl 
2eb7			 
2eb7 d1					pop de 
2eb8 eb					ex de, hl 
2eb9 73					ld (hl), e 
2eba 23					inc hl 
2ebb 72					ld (hl), d 
2ebc					 
2ebc					NEXTW 
2ebc c3 34 1f			jp macro_next 
2ebf				endm 
# End of macro NEXTW
2ebf			.ENDCORE: 
2ebf			 
2ebf			; eof 
2ebf			 
2ebf			 
# End of file forth_words_core.asm
2ebf			include "forth_words_flow.asm" 
2ebf			 
2ebf			; | ## Program Flow Words 
2ebf			 
2ebf			.IF: 
2ebf				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2ebf 1e				db WORD_SYS_CORE+10             
2ec0 b4 2f			dw .THEN            
2ec2 03				db 2 + 1 
2ec3 .. 00			db "IF",0              
2ec6				endm 
# End of macro CWHEAD
2ec6			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2ec6			; 
2ec6					if DEBUG_FORTH_WORDS_KEY 
2ec6						DMARK "IF." 
2ec6 f5				push af  
2ec7 3a db 2e			ld a, (.dmark)  
2eca 32 6b ee			ld (debug_mark),a  
2ecd 3a dc 2e			ld a, (.dmark+1)  
2ed0 32 6c ee			ld (debug_mark+1),a  
2ed3 3a dd 2e			ld a, (.dmark+2)  
2ed6 32 6d ee			ld (debug_mark+2),a  
2ed9 18 03			jr .pastdmark  
2edb ..			.dmark: db "IF."  
2ede f1			.pastdmark: pop af  
2edf			endm  
# End of macro DMARK
2edf						CALLMONITOR 
2edf cd 6f ee			call debug_vector  
2ee2				endm  
# End of macro CALLMONITOR
2ee2					endif 
2ee2			; eval TOS 
2ee2			 
2ee2				FORTH_DSP_VALUEHL 
2ee2 cd 7e 1d			call macro_dsp_valuehl 
2ee5				endm 
# End of macro FORTH_DSP_VALUEHL
2ee5			 
2ee5			;	push hl 
2ee5				FORTH_DSP_POP 
2ee5 cd 36 1e			call macro_forth_dsp_pop 
2ee8				endm 
# End of macro FORTH_DSP_POP
2ee8			;	pop hl 
2ee8			 
2ee8					if DEBUG_FORTH_WORDS 
2ee8						DMARK "IF1" 
2ee8 f5				push af  
2ee9 3a fd 2e			ld a, (.dmark)  
2eec 32 6b ee			ld (debug_mark),a  
2eef 3a fe 2e			ld a, (.dmark+1)  
2ef2 32 6c ee			ld (debug_mark+1),a  
2ef5 3a ff 2e			ld a, (.dmark+2)  
2ef8 32 6d ee			ld (debug_mark+2),a  
2efb 18 03			jr .pastdmark  
2efd ..			.dmark: db "IF1"  
2f00 f1			.pastdmark: pop af  
2f01			endm  
# End of macro DMARK
2f01						CALLMONITOR 
2f01 cd 6f ee			call debug_vector  
2f04				endm  
# End of macro CALLMONITOR
2f04					endif 
2f04 b7				or a        ; clear carry flag 
2f05 11 00 00			ld de, 0 
2f08 eb				ex de,hl 
2f09 ed 52			sbc hl, de 
2f0b c2 95 2f			jp nz, .iftrue 
2f0e			 
2f0e					if DEBUG_FORTH_WORDS 
2f0e						DMARK "IF2" 
2f0e f5				push af  
2f0f 3a 23 2f			ld a, (.dmark)  
2f12 32 6b ee			ld (debug_mark),a  
2f15 3a 24 2f			ld a, (.dmark+1)  
2f18 32 6c ee			ld (debug_mark+1),a  
2f1b 3a 25 2f			ld a, (.dmark+2)  
2f1e 32 6d ee			ld (debug_mark+2),a  
2f21 18 03			jr .pastdmark  
2f23 ..			.dmark: db "IF2"  
2f26 f1			.pastdmark: pop af  
2f27			endm  
# End of macro DMARK
2f27						CALLMONITOR 
2f27 cd 6f ee			call debug_vector  
2f2a				endm  
# End of macro CALLMONITOR
2f2a					endif 
2f2a			 
2f2a			; if not true then skip to THEN 
2f2a			 
2f2a				; TODO get tok_ptr 
2f2a				; TODO consume toks until we get to THEN 
2f2a			 
2f2a 2a c2 e5			ld hl, (os_tok_ptr) 
2f2d					if DEBUG_FORTH_WORDS 
2f2d						DMARK "IF3" 
2f2d f5				push af  
2f2e 3a 42 2f			ld a, (.dmark)  
2f31 32 6b ee			ld (debug_mark),a  
2f34 3a 43 2f			ld a, (.dmark+1)  
2f37 32 6c ee			ld (debug_mark+1),a  
2f3a 3a 44 2f			ld a, (.dmark+2)  
2f3d 32 6d ee			ld (debug_mark+2),a  
2f40 18 03			jr .pastdmark  
2f42 ..			.dmark: db "IF3"  
2f45 f1			.pastdmark: pop af  
2f46			endm  
# End of macro DMARK
2f46						CALLMONITOR 
2f46 cd 6f ee			call debug_vector  
2f49				endm  
# End of macro CALLMONITOR
2f49						 
2f49					endif 
2f49 11 90 2f			ld de, .ifthen 
2f4c					if DEBUG_FORTH_WORDS 
2f4c						DMARK "IF4" 
2f4c f5				push af  
2f4d 3a 61 2f			ld a, (.dmark)  
2f50 32 6b ee			ld (debug_mark),a  
2f53 3a 62 2f			ld a, (.dmark+1)  
2f56 32 6c ee			ld (debug_mark+1),a  
2f59 3a 63 2f			ld a, (.dmark+2)  
2f5c 32 6d ee			ld (debug_mark+2),a  
2f5f 18 03			jr .pastdmark  
2f61 ..			.dmark: db "IF4"  
2f64 f1			.pastdmark: pop af  
2f65			endm  
# End of macro DMARK
2f65						CALLMONITOR 
2f65 cd 6f ee			call debug_vector  
2f68				endm  
# End of macro CALLMONITOR
2f68					endif 
2f68 cd 4f 20			call findnexttok  
2f6b			 
2f6b					if DEBUG_FORTH_WORDS 
2f6b						DMARK "IF5" 
2f6b f5				push af  
2f6c 3a 80 2f			ld a, (.dmark)  
2f6f 32 6b ee			ld (debug_mark),a  
2f72 3a 81 2f			ld a, (.dmark+1)  
2f75 32 6c ee			ld (debug_mark+1),a  
2f78 3a 82 2f			ld a, (.dmark+2)  
2f7b 32 6d ee			ld (debug_mark+2),a  
2f7e 18 03			jr .pastdmark  
2f80 ..			.dmark: db "IF5"  
2f83 f1			.pastdmark: pop af  
2f84			endm  
# End of macro DMARK
2f84						CALLMONITOR 
2f84 cd 6f ee			call debug_vector  
2f87				endm  
# End of macro CALLMONITOR
2f87					endif 
2f87				; TODO replace below with ; exec using tok_ptr 
2f87 22 c2 e5			ld (os_tok_ptr), hl 
2f8a c3 c5 1f			jp exec1 
2f8d				NEXTW 
2f8d c3 34 1f			jp macro_next 
2f90				endm 
# End of macro NEXTW
2f90			 
2f90 .. 00		.ifthen:  db "THEN",0 
2f95			 
2f95			.iftrue:		 
2f95				; Exec next words normally 
2f95			 
2f95				; if true then exec following IF as normal 
2f95					if DEBUG_FORTH_WORDS 
2f95						DMARK "IFT" 
2f95 f5				push af  
2f96 3a aa 2f			ld a, (.dmark)  
2f99 32 6b ee			ld (debug_mark),a  
2f9c 3a ab 2f			ld a, (.dmark+1)  
2f9f 32 6c ee			ld (debug_mark+1),a  
2fa2 3a ac 2f			ld a, (.dmark+2)  
2fa5 32 6d ee			ld (debug_mark+2),a  
2fa8 18 03			jr .pastdmark  
2faa ..			.dmark: db "IFT"  
2fad f1			.pastdmark: pop af  
2fae			endm  
# End of macro DMARK
2fae						CALLMONITOR 
2fae cd 6f ee			call debug_vector  
2fb1				endm  
# End of macro CALLMONITOR
2fb1					endif 
2fb1			 
2fb1					NEXTW 
2fb1 c3 34 1f			jp macro_next 
2fb4				endm 
# End of macro NEXTW
2fb4			.THEN: 
2fb4				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2fb4 1f				db WORD_SYS_CORE+11             
2fb5 dc 2f			dw .ELSE            
2fb7 05				db 4 + 1 
2fb8 .. 00			db "THEN",0              
2fbd				endm 
# End of macro CWHEAD
2fbd			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2fbd					if DEBUG_FORTH_WORDS_KEY 
2fbd						DMARK "THN" 
2fbd f5				push af  
2fbe 3a d2 2f			ld a, (.dmark)  
2fc1 32 6b ee			ld (debug_mark),a  
2fc4 3a d3 2f			ld a, (.dmark+1)  
2fc7 32 6c ee			ld (debug_mark+1),a  
2fca 3a d4 2f			ld a, (.dmark+2)  
2fcd 32 6d ee			ld (debug_mark+2),a  
2fd0 18 03			jr .pastdmark  
2fd2 ..			.dmark: db "THN"  
2fd5 f1			.pastdmark: pop af  
2fd6			endm  
# End of macro DMARK
2fd6						CALLMONITOR 
2fd6 cd 6f ee			call debug_vector  
2fd9				endm  
# End of macro CALLMONITOR
2fd9					endif 
2fd9					NEXTW 
2fd9 c3 34 1f			jp macro_next 
2fdc				endm 
# End of macro NEXTW
2fdc			.ELSE: 
2fdc				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2fdc 20				db WORD_SYS_CORE+12             
2fdd 04 30			dw .DO            
2fdf 03				db 2 + 1 
2fe0 .. 00			db "ELSE",0              
2fe5				endm 
# End of macro CWHEAD
2fe5			; | ELSE ( -- ) Not supported - does nothing | TODO 
2fe5			 
2fe5					if DEBUG_FORTH_WORDS_KEY 
2fe5						DMARK "ELS" 
2fe5 f5				push af  
2fe6 3a fa 2f			ld a, (.dmark)  
2fe9 32 6b ee			ld (debug_mark),a  
2fec 3a fb 2f			ld a, (.dmark+1)  
2fef 32 6c ee			ld (debug_mark+1),a  
2ff2 3a fc 2f			ld a, (.dmark+2)  
2ff5 32 6d ee			ld (debug_mark+2),a  
2ff8 18 03			jr .pastdmark  
2ffa ..			.dmark: db "ELS"  
2ffd f1			.pastdmark: pop af  
2ffe			endm  
# End of macro DMARK
2ffe						CALLMONITOR 
2ffe cd 6f ee			call debug_vector  
3001				endm  
# End of macro CALLMONITOR
3001					endif 
3001			 
3001			 
3001					NEXTW 
3001 c3 34 1f			jp macro_next 
3004				endm 
# End of macro NEXTW
3004			.DO: 
3004				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3004 21				db WORD_SYS_CORE+13             
3005 2b 31			dw .LOOP            
3007 03				db 2 + 1 
3008 .. 00			db "DO",0              
300b				endm 
# End of macro CWHEAD
300b			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
300b			 
300b					if DEBUG_FORTH_WORDS_KEY 
300b						DMARK "DO." 
300b f5				push af  
300c 3a 20 30			ld a, (.dmark)  
300f 32 6b ee			ld (debug_mark),a  
3012 3a 21 30			ld a, (.dmark+1)  
3015 32 6c ee			ld (debug_mark+1),a  
3018 3a 22 30			ld a, (.dmark+2)  
301b 32 6d ee			ld (debug_mark+2),a  
301e 18 03			jr .pastdmark  
3020 ..			.dmark: db "DO."  
3023 f1			.pastdmark: pop af  
3024			endm  
# End of macro DMARK
3024						CALLMONITOR 
3024 cd 6f ee			call debug_vector  
3027				endm  
# End of macro CALLMONITOR
3027					endif 
3027			;  push pc to rsp stack past the DO 
3027			 
3027 2a c2 e5				ld hl, (os_tok_ptr) 
302a 23					inc hl   ; D 
302b 23					inc hl  ; O 
302c 23					inc hl   ; null 
302d					if DEBUG_FORTH_WORDS 
302d						DMARK "DO2" 
302d f5				push af  
302e 3a 42 30			ld a, (.dmark)  
3031 32 6b ee			ld (debug_mark),a  
3034 3a 43 30			ld a, (.dmark+1)  
3037 32 6c ee			ld (debug_mark+1),a  
303a 3a 44 30			ld a, (.dmark+2)  
303d 32 6d ee			ld (debug_mark+2),a  
3040 18 03			jr .pastdmark  
3042 ..			.dmark: db "DO2"  
3045 f1			.pastdmark: pop af  
3046			endm  
# End of macro DMARK
3046						CALLMONITOR 
3046 cd 6f ee			call debug_vector  
3049				endm  
# End of macro CALLMONITOR
3049					endif 
3049					FORTH_RSP_NEXT 
3049 cd 20 1b			call macro_forth_rsp_next 
304c				endm 
# End of macro FORTH_RSP_NEXT
304c					if DEBUG_FORTH_WORDS 
304c						DMARK "DO3" 
304c f5				push af  
304d 3a 61 30			ld a, (.dmark)  
3050 32 6b ee			ld (debug_mark),a  
3053 3a 62 30			ld a, (.dmark+1)  
3056 32 6c ee			ld (debug_mark+1),a  
3059 3a 63 30			ld a, (.dmark+2)  
305c 32 6d ee			ld (debug_mark+2),a  
305f 18 03			jr .pastdmark  
3061 ..			.dmark: db "DO3"  
3064 f1			.pastdmark: pop af  
3065			endm  
# End of macro DMARK
3065						CALLMONITOR 
3065 cd 6f ee			call debug_vector  
3068				endm  
# End of macro CALLMONITOR
3068					endif 
3068			 
3068					;if DEBUG_FORTH_WORDS 
3068				;		push hl 
3068			;		endif  
3068			 
3068			; get counters from data stack 
3068			 
3068			 
3068					FORTH_DSP_VALUEHL 
3068 cd 7e 1d			call macro_dsp_valuehl 
306b				endm 
# End of macro FORTH_DSP_VALUEHL
306b e5					push hl		 ; hl now has starting counter which needs to be tos 
306c			 
306c					if DEBUG_FORTH_WORDS 
306c						DMARK "DO4" 
306c f5				push af  
306d 3a 81 30			ld a, (.dmark)  
3070 32 6b ee			ld (debug_mark),a  
3073 3a 82 30			ld a, (.dmark+1)  
3076 32 6c ee			ld (debug_mark+1),a  
3079 3a 83 30			ld a, (.dmark+2)  
307c 32 6d ee			ld (debug_mark+2),a  
307f 18 03			jr .pastdmark  
3081 ..			.dmark: db "DO4"  
3084 f1			.pastdmark: pop af  
3085			endm  
# End of macro DMARK
3085						CALLMONITOR 
3085 cd 6f ee			call debug_vector  
3088				endm  
# End of macro CALLMONITOR
3088					endif 
3088					FORTH_DSP_POP 
3088 cd 36 1e			call macro_forth_dsp_pop 
308b				endm 
# End of macro FORTH_DSP_POP
308b			 
308b					if DEBUG_FORTH_WORDS 
308b						DMARK "DO5" 
308b f5				push af  
308c 3a a0 30			ld a, (.dmark)  
308f 32 6b ee			ld (debug_mark),a  
3092 3a a1 30			ld a, (.dmark+1)  
3095 32 6c ee			ld (debug_mark+1),a  
3098 3a a2 30			ld a, (.dmark+2)  
309b 32 6d ee			ld (debug_mark+2),a  
309e 18 03			jr .pastdmark  
30a0 ..			.dmark: db "DO5"  
30a3 f1			.pastdmark: pop af  
30a4			endm  
# End of macro DMARK
30a4						CALLMONITOR 
30a4 cd 6f ee			call debug_vector  
30a7				endm  
# End of macro CALLMONITOR
30a7					endif 
30a7			 
30a7					FORTH_DSP_VALUEHL 
30a7 cd 7e 1d			call macro_dsp_valuehl 
30aa				endm 
# End of macro FORTH_DSP_VALUEHL
30aa			;		push hl		 ; hl now has starting limit counter 
30aa			 
30aa					if DEBUG_FORTH_WORDS 
30aa						DMARK "DO6" 
30aa f5				push af  
30ab 3a bf 30			ld a, (.dmark)  
30ae 32 6b ee			ld (debug_mark),a  
30b1 3a c0 30			ld a, (.dmark+1)  
30b4 32 6c ee			ld (debug_mark+1),a  
30b7 3a c1 30			ld a, (.dmark+2)  
30ba 32 6d ee			ld (debug_mark+2),a  
30bd 18 03			jr .pastdmark  
30bf ..			.dmark: db "DO6"  
30c2 f1			.pastdmark: pop af  
30c3			endm  
# End of macro DMARK
30c3						CALLMONITOR 
30c3 cd 6f ee			call debug_vector  
30c6				endm  
# End of macro CALLMONITOR
30c6					endif 
30c6					FORTH_DSP_POP 
30c6 cd 36 1e			call macro_forth_dsp_pop 
30c9				endm 
# End of macro FORTH_DSP_POP
30c9			 
30c9			; put counters on the loop stack 
30c9			 
30c9			;		pop hl			 ; limit counter 
30c9 d1					pop de			; start counter 
30ca			 
30ca					; push limit counter 
30ca			 
30ca					if DEBUG_FORTH_WORDS 
30ca						DMARK "DO7" 
30ca f5				push af  
30cb 3a df 30			ld a, (.dmark)  
30ce 32 6b ee			ld (debug_mark),a  
30d1 3a e0 30			ld a, (.dmark+1)  
30d4 32 6c ee			ld (debug_mark+1),a  
30d7 3a e1 30			ld a, (.dmark+2)  
30da 32 6d ee			ld (debug_mark+2),a  
30dd 18 03			jr .pastdmark  
30df ..			.dmark: db "DO7"  
30e2 f1			.pastdmark: pop af  
30e3			endm  
# End of macro DMARK
30e3						CALLMONITOR 
30e3 cd 6f ee			call debug_vector  
30e6				endm  
# End of macro CALLMONITOR
30e6					endif 
30e6					FORTH_LOOP_NEXT 
30e6 cd af 1d			call macro_forth_loop_next 
30e9				endm 
# End of macro FORTH_LOOP_NEXT
30e9			 
30e9					; push start counter 
30e9			 
30e9 eb					ex de, hl 
30ea					if DEBUG_FORTH_WORDS 
30ea						DMARK "DO7" 
30ea f5				push af  
30eb 3a ff 30			ld a, (.dmark)  
30ee 32 6b ee			ld (debug_mark),a  
30f1 3a 00 31			ld a, (.dmark+1)  
30f4 32 6c ee			ld (debug_mark+1),a  
30f7 3a 01 31			ld a, (.dmark+2)  
30fa 32 6d ee			ld (debug_mark+2),a  
30fd 18 03			jr .pastdmark  
30ff ..			.dmark: db "DO7"  
3102 f1			.pastdmark: pop af  
3103			endm  
# End of macro DMARK
3103						CALLMONITOR 
3103 cd 6f ee			call debug_vector  
3106				endm  
# End of macro CALLMONITOR
3106					endif 
3106					FORTH_LOOP_NEXT 
3106 cd af 1d			call macro_forth_loop_next 
3109				endm 
# End of macro FORTH_LOOP_NEXT
3109			 
3109			 
3109					; init first round of I counter 
3109			 
3109 22 e6 e5				ld (os_current_i), hl 
310c			 
310c					if DEBUG_FORTH_WORDS 
310c						DMARK "DO8" 
310c f5				push af  
310d 3a 21 31			ld a, (.dmark)  
3110 32 6b ee			ld (debug_mark),a  
3113 3a 22 31			ld a, (.dmark+1)  
3116 32 6c ee			ld (debug_mark+1),a  
3119 3a 23 31			ld a, (.dmark+2)  
311c 32 6d ee			ld (debug_mark+2),a  
311f 18 03			jr .pastdmark  
3121 ..			.dmark: db "DO8"  
3124 f1			.pastdmark: pop af  
3125			endm  
# End of macro DMARK
3125						CALLMONITOR 
3125 cd 6f ee			call debug_vector  
3128				endm  
# End of macro CALLMONITOR
3128					endif 
3128			 
3128					NEXTW 
3128 c3 34 1f			jp macro_next 
312b				endm 
# End of macro NEXTW
312b			.LOOP: 
312b				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
312b 22				db WORD_SYS_CORE+14             
312c 43 32			dw .I            
312e 05				db 4 + 1 
312f .. 00			db "LOOP",0              
3134				endm 
# End of macro CWHEAD
3134			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3134			 
3134				; pop tos as current loop count to hl 
3134			 
3134				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3134			 
3134				FORTH_LOOP_TOS 
3134 cd e2 1d			call macro_forth_loop_tos 
3137				endm 
# End of macro FORTH_LOOP_TOS
3137 e5				push hl 
3138			 
3138					if DEBUG_FORTH_WORDS_KEY 
3138						DMARK "LOP" 
3138 f5				push af  
3139 3a 4d 31			ld a, (.dmark)  
313c 32 6b ee			ld (debug_mark),a  
313f 3a 4e 31			ld a, (.dmark+1)  
3142 32 6c ee			ld (debug_mark+1),a  
3145 3a 4f 31			ld a, (.dmark+2)  
3148 32 6d ee			ld (debug_mark+2),a  
314b 18 03			jr .pastdmark  
314d ..			.dmark: db "LOP"  
3150 f1			.pastdmark: pop af  
3151			endm  
# End of macro DMARK
3151						CALLMONITOR 
3151 cd 6f ee			call debug_vector  
3154				endm  
# End of macro CALLMONITOR
3154					endif 
3154				; next item on the stack is the limit. get it 
3154			 
3154			 
3154				FORTH_LOOP_POP 
3154 cd ec 1d			call macro_forth_loop_pop 
3157				endm 
# End of macro FORTH_LOOP_POP
3157			 
3157				FORTH_LOOP_TOS 
3157 cd e2 1d			call macro_forth_loop_tos 
315a				endm 
# End of macro FORTH_LOOP_TOS
315a			 
315a d1				pop de		 ; de = i, hl = limit 
315b			 
315b					if DEBUG_FORTH_WORDS 
315b						DMARK "LP1" 
315b f5				push af  
315c 3a 70 31			ld a, (.dmark)  
315f 32 6b ee			ld (debug_mark),a  
3162 3a 71 31			ld a, (.dmark+1)  
3165 32 6c ee			ld (debug_mark+1),a  
3168 3a 72 31			ld a, (.dmark+2)  
316b 32 6d ee			ld (debug_mark+2),a  
316e 18 03			jr .pastdmark  
3170 ..			.dmark: db "LP1"  
3173 f1			.pastdmark: pop af  
3174			endm  
# End of macro DMARK
3174						CALLMONITOR 
3174 cd 6f ee			call debug_vector  
3177				endm  
# End of macro CALLMONITOR
3177					endif 
3177			 
3177				; go back to previous word 
3177			 
3177 d5				push de    ; save I for inc later 
3178			 
3178			 
3178				; get limit 
3178				;  is I at limit? 
3178			 
3178			 
3178					if DEBUG_FORTH_WORDS 
3178						DMARK "LP1" 
3178 f5				push af  
3179 3a 8d 31			ld a, (.dmark)  
317c 32 6b ee			ld (debug_mark),a  
317f 3a 8e 31			ld a, (.dmark+1)  
3182 32 6c ee			ld (debug_mark+1),a  
3185 3a 8f 31			ld a, (.dmark+2)  
3188 32 6d ee			ld (debug_mark+2),a  
318b 18 03			jr .pastdmark  
318d ..			.dmark: db "LP1"  
3190 f1			.pastdmark: pop af  
3191			endm  
# End of macro DMARK
3191						CALLMONITOR 
3191 cd 6f ee			call debug_vector  
3194				endm  
# End of macro CALLMONITOR
3194					endif 
3194			 
3194 ed 52			sbc hl, de 
3196			 
3196			 
3196				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3196			 
3196 20 26				jr nz, .loopnotdone 
3198			 
3198 e1				pop hl   ; get rid of saved I 
3199				FORTH_LOOP_POP     ; get rid of limit 
3199 cd ec 1d			call macro_forth_loop_pop 
319c				endm 
# End of macro FORTH_LOOP_POP
319c			 
319c				FORTH_RSP_POP     ; get rid of DO ptr 
319c cd 41 1b			call macro_forth_rsp_pop 
319f				endm 
# End of macro FORTH_RSP_POP
319f			 
319f			if DEBUG_FORTH_WORDS 
319f						DMARK "LP>" 
319f f5				push af  
31a0 3a b4 31			ld a, (.dmark)  
31a3 32 6b ee			ld (debug_mark),a  
31a6 3a b5 31			ld a, (.dmark+1)  
31a9 32 6c ee			ld (debug_mark+1),a  
31ac 3a b6 31			ld a, (.dmark+2)  
31af 32 6d ee			ld (debug_mark+2),a  
31b2 18 03			jr .pastdmark  
31b4 ..			.dmark: db "LP>"  
31b7 f1			.pastdmark: pop af  
31b8			endm  
# End of macro DMARK
31b8				CALLMONITOR 
31b8 cd 6f ee			call debug_vector  
31bb				endm  
# End of macro CALLMONITOR
31bb			endif 
31bb			 
31bb					NEXTW 
31bb c3 34 1f			jp macro_next 
31be				endm 
# End of macro NEXTW
31be				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
31be			 
31be			.loopnotdone: 
31be			 
31be e1				pop hl    ; get I 
31bf 23				inc hl 
31c0			 
31c0			   	; save new I 
31c0			 
31c0			 
31c0					; set I counter 
31c0			 
31c0 22 e6 e5				ld (os_current_i), hl 
31c3			 
31c3					if DEBUG_FORTH_WORDS 
31c3						DMARK "LPN" 
31c3 f5				push af  
31c4 3a d8 31			ld a, (.dmark)  
31c7 32 6b ee			ld (debug_mark),a  
31ca 3a d9 31			ld a, (.dmark+1)  
31cd 32 6c ee			ld (debug_mark+1),a  
31d0 3a da 31			ld a, (.dmark+2)  
31d3 32 6d ee			ld (debug_mark+2),a  
31d6 18 03			jr .pastdmark  
31d8 ..			.dmark: db "LPN"  
31db f1			.pastdmark: pop af  
31dc			endm  
# End of macro DMARK
31dc					CALLMONITOR 
31dc cd 6f ee			call debug_vector  
31df				endm  
# End of macro CALLMONITOR
31df					endif 
31df					 
31df				FORTH_LOOP_NEXT 
31df cd af 1d			call macro_forth_loop_next 
31e2				endm 
# End of macro FORTH_LOOP_NEXT
31e2			 
31e2			 
31e2					if DEBUG_FORTH_WORDS 
31e2 eb						ex de,hl 
31e3					endif 
31e3			 
31e3			;	; get DO ptr 
31e3			; 
31e3					if DEBUG_FORTH_WORDS 
31e3						DMARK "LP7" 
31e3 f5				push af  
31e4 3a f8 31			ld a, (.dmark)  
31e7 32 6b ee			ld (debug_mark),a  
31ea 3a f9 31			ld a, (.dmark+1)  
31ed 32 6c ee			ld (debug_mark+1),a  
31f0 3a fa 31			ld a, (.dmark+2)  
31f3 32 6d ee			ld (debug_mark+2),a  
31f6 18 03			jr .pastdmark  
31f8 ..			.dmark: db "LP7"  
31fb f1			.pastdmark: pop af  
31fc			endm  
# End of macro DMARK
31fc					CALLMONITOR 
31fc cd 6f ee			call debug_vector  
31ff				endm  
# End of macro CALLMONITOR
31ff					endif 
31ff				FORTH_RSP_TOS 
31ff cd 37 1b			call macro_forth_rsp_tos 
3202				endm 
# End of macro FORTH_RSP_TOS
3202			 
3202					if DEBUG_FORTH_WORDS 
3202						DMARK "LP8" 
3202 f5				push af  
3203 3a 17 32			ld a, (.dmark)  
3206 32 6b ee			ld (debug_mark),a  
3209 3a 18 32			ld a, (.dmark+1)  
320c 32 6c ee			ld (debug_mark+1),a  
320f 3a 19 32			ld a, (.dmark+2)  
3212 32 6d ee			ld (debug_mark+2),a  
3215 18 03			jr .pastdmark  
3217 ..			.dmark: db "LP8"  
321a f1			.pastdmark: pop af  
321b			endm  
# End of macro DMARK
321b					CALLMONITOR 
321b cd 6f ee			call debug_vector  
321e				endm  
# End of macro CALLMONITOR
321e					endif 
321e				;push hl 
321e			 
321e				; not going to DO any more 
321e				; get rid of the RSP pointer as DO will add it back in 
321e				;FORTH_RSP_POP 
321e				;pop hl 
321e			 
321e				;ld hl,(cli_ret_sp) 
321e				;ld e, (hl) 
321e				;inc hl 
321e				;ld d, (hl) 
321e				;ex de,hl 
321e 22 c2 e5			ld (os_tok_ptr), hl 
3221					if DEBUG_FORTH_WORDS 
3221						DMARK "LP<" 
3221 f5				push af  
3222 3a 36 32			ld a, (.dmark)  
3225 32 6b ee			ld (debug_mark),a  
3228 3a 37 32			ld a, (.dmark+1)  
322b 32 6c ee			ld (debug_mark+1),a  
322e 3a 38 32			ld a, (.dmark+2)  
3231 32 6d ee			ld (debug_mark+2),a  
3234 18 03			jr .pastdmark  
3236 ..			.dmark: db "LP<"  
3239 f1			.pastdmark: pop af  
323a			endm  
# End of macro DMARK
323a					CALLMONITOR 
323a cd 6f ee			call debug_vector  
323d				endm  
# End of macro CALLMONITOR
323d				endif 
323d c3 c5 1f			jp exec1 
3240			 
3240					 
3240			 
3240			 
3240					NEXTW 
3240 c3 34 1f			jp macro_next 
3243				endm 
# End of macro NEXTW
3243			.I:  
3243			 
3243				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3243 5e				db WORD_SYS_CORE+74             
3244 6e 32			dw .DLOOP            
3246 02				db 1 + 1 
3247 .. 00			db "I",0              
3249				endm 
# End of macro CWHEAD
3249			; | I ( -- ) Current loop counter | DONE 
3249					if DEBUG_FORTH_WORDS_KEY 
3249						DMARK "I.." 
3249 f5				push af  
324a 3a 5e 32			ld a, (.dmark)  
324d 32 6b ee			ld (debug_mark),a  
3250 3a 5f 32			ld a, (.dmark+1)  
3253 32 6c ee			ld (debug_mark+1),a  
3256 3a 60 32			ld a, (.dmark+2)  
3259 32 6d ee			ld (debug_mark+2),a  
325c 18 03			jr .pastdmark  
325e ..			.dmark: db "I.."  
3261 f1			.pastdmark: pop af  
3262			endm  
# End of macro DMARK
3262						CALLMONITOR 
3262 cd 6f ee			call debug_vector  
3265				endm  
# End of macro CALLMONITOR
3265					endif 
3265			 
3265 2a e6 e5				ld hl,(os_current_i) 
3268 cd 79 1b				call forth_push_numhl 
326b			 
326b					NEXTW 
326b c3 34 1f			jp macro_next 
326e				endm 
# End of macro NEXTW
326e			.DLOOP: 
326e				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
326e 5f				db WORD_SYS_CORE+75             
326f 4f 33			dw .REPEAT            
3271 06				db 5 + 1 
3272 .. 00			db "-LOOP",0              
3278				endm 
# End of macro CWHEAD
3278			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3278				; pop tos as current loop count to hl 
3278					if DEBUG_FORTH_WORDS_KEY 
3278						DMARK "-LP" 
3278 f5				push af  
3279 3a 8d 32			ld a, (.dmark)  
327c 32 6b ee			ld (debug_mark),a  
327f 3a 8e 32			ld a, (.dmark+1)  
3282 32 6c ee			ld (debug_mark+1),a  
3285 3a 8f 32			ld a, (.dmark+2)  
3288 32 6d ee			ld (debug_mark+2),a  
328b 18 03			jr .pastdmark  
328d ..			.dmark: db "-LP"  
3290 f1			.pastdmark: pop af  
3291			endm  
# End of macro DMARK
3291						CALLMONITOR 
3291 cd 6f ee			call debug_vector  
3294				endm  
# End of macro CALLMONITOR
3294					endif 
3294			 
3294				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3294			 
3294				FORTH_LOOP_TOS 
3294 cd e2 1d			call macro_forth_loop_tos 
3297				endm 
# End of macro FORTH_LOOP_TOS
3297 e5				push hl 
3298			 
3298					if DEBUG_FORTH_WORDS 
3298						DMARK "-LP" 
3298 f5				push af  
3299 3a ad 32			ld a, (.dmark)  
329c 32 6b ee			ld (debug_mark),a  
329f 3a ae 32			ld a, (.dmark+1)  
32a2 32 6c ee			ld (debug_mark+1),a  
32a5 3a af 32			ld a, (.dmark+2)  
32a8 32 6d ee			ld (debug_mark+2),a  
32ab 18 03			jr .pastdmark  
32ad ..			.dmark: db "-LP"  
32b0 f1			.pastdmark: pop af  
32b1			endm  
# End of macro DMARK
32b1						CALLMONITOR 
32b1 cd 6f ee			call debug_vector  
32b4				endm  
# End of macro CALLMONITOR
32b4					endif 
32b4				; next item on the stack is the limit. get it 
32b4			 
32b4			 
32b4				FORTH_LOOP_POP 
32b4 cd ec 1d			call macro_forth_loop_pop 
32b7				endm 
# End of macro FORTH_LOOP_POP
32b7			 
32b7				FORTH_LOOP_TOS 
32b7 cd e2 1d			call macro_forth_loop_tos 
32ba				endm 
# End of macro FORTH_LOOP_TOS
32ba			 
32ba d1				pop de		 ; de = i, hl = limit 
32bb			 
32bb					if DEBUG_FORTH_WORDS 
32bb						DMARK "-L1" 
32bb f5				push af  
32bc 3a d0 32			ld a, (.dmark)  
32bf 32 6b ee			ld (debug_mark),a  
32c2 3a d1 32			ld a, (.dmark+1)  
32c5 32 6c ee			ld (debug_mark+1),a  
32c8 3a d2 32			ld a, (.dmark+2)  
32cb 32 6d ee			ld (debug_mark+2),a  
32ce 18 03			jr .pastdmark  
32d0 ..			.dmark: db "-L1"  
32d3 f1			.pastdmark: pop af  
32d4			endm  
# End of macro DMARK
32d4						CALLMONITOR 
32d4 cd 6f ee			call debug_vector  
32d7				endm  
# End of macro CALLMONITOR
32d7					endif 
32d7			 
32d7				; go back to previous word 
32d7			 
32d7 d5				push de    ; save I for inc later 
32d8			 
32d8			 
32d8				; get limit 
32d8				;  is I at limit? 
32d8			 
32d8			 
32d8					if DEBUG_FORTH_WORDS 
32d8						DMARK "-L1" 
32d8 f5				push af  
32d9 3a ed 32			ld a, (.dmark)  
32dc 32 6b ee			ld (debug_mark),a  
32df 3a ee 32			ld a, (.dmark+1)  
32e2 32 6c ee			ld (debug_mark+1),a  
32e5 3a ef 32			ld a, (.dmark+2)  
32e8 32 6d ee			ld (debug_mark+2),a  
32eb 18 03			jr .pastdmark  
32ed ..			.dmark: db "-L1"  
32f0 f1			.pastdmark: pop af  
32f1			endm  
# End of macro DMARK
32f1						CALLMONITOR 
32f1 cd 6f ee			call debug_vector  
32f4				endm  
# End of macro CALLMONITOR
32f4					endif 
32f4			 
32f4 ed 52			sbc hl, de 
32f6			 
32f6			 
32f6				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
32f6			 
32f6 20 26				jr nz, .mloopnotdone 
32f8			 
32f8 e1				pop hl   ; get rid of saved I 
32f9				FORTH_LOOP_POP     ; get rid of limit 
32f9 cd ec 1d			call macro_forth_loop_pop 
32fc				endm 
# End of macro FORTH_LOOP_POP
32fc			 
32fc				FORTH_RSP_POP     ; get rid of DO ptr 
32fc cd 41 1b			call macro_forth_rsp_pop 
32ff				endm 
# End of macro FORTH_RSP_POP
32ff			 
32ff			if DEBUG_FORTH_WORDS 
32ff						DMARK "-L>" 
32ff f5				push af  
3300 3a 14 33			ld a, (.dmark)  
3303 32 6b ee			ld (debug_mark),a  
3306 3a 15 33			ld a, (.dmark+1)  
3309 32 6c ee			ld (debug_mark+1),a  
330c 3a 16 33			ld a, (.dmark+2)  
330f 32 6d ee			ld (debug_mark+2),a  
3312 18 03			jr .pastdmark  
3314 ..			.dmark: db "-L>"  
3317 f1			.pastdmark: pop af  
3318			endm  
# End of macro DMARK
3318				CALLMONITOR 
3318 cd 6f ee			call debug_vector  
331b				endm  
# End of macro CALLMONITOR
331b			endif 
331b			 
331b					NEXTW 
331b c3 34 1f			jp macro_next 
331e				endm 
# End of macro NEXTW
331e				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
331e			 
331e			.mloopnotdone: 
331e			 
331e e1				pop hl    ; get I 
331f 2b				dec hl 
3320			 
3320			   	; save new I 
3320			 
3320			 
3320					; set I counter 
3320			 
3320 22 e6 e5				ld (os_current_i), hl 
3323			 
3323					 
3323				FORTH_LOOP_NEXT 
3323 cd af 1d			call macro_forth_loop_next 
3326				endm 
# End of macro FORTH_LOOP_NEXT
3326			 
3326			 
3326					if DEBUG_FORTH_WORDS 
3326 eb						ex de,hl 
3327					endif 
3327			 
3327			;	; get DO ptr 
3327			; 
3327				FORTH_RSP_TOS 
3327 cd 37 1b			call macro_forth_rsp_tos 
332a				endm 
# End of macro FORTH_RSP_TOS
332a			 
332a				;push hl 
332a			 
332a				; not going to DO any more 
332a				; get rid of the RSP pointer as DO will add it back in 
332a				;FORTH_RSP_POP 
332a				;pop hl 
332a			 
332a			 
332a 22 c2 e5			ld (os_tok_ptr), hl 
332d					if DEBUG_FORTH_WORDS 
332d						DMARK "-L<" 
332d f5				push af  
332e 3a 42 33			ld a, (.dmark)  
3331 32 6b ee			ld (debug_mark),a  
3334 3a 43 33			ld a, (.dmark+1)  
3337 32 6c ee			ld (debug_mark+1),a  
333a 3a 44 33			ld a, (.dmark+2)  
333d 32 6d ee			ld (debug_mark+2),a  
3340 18 03			jr .pastdmark  
3342 ..			.dmark: db "-L<"  
3345 f1			.pastdmark: pop af  
3346			endm  
# End of macro DMARK
3346					CALLMONITOR 
3346 cd 6f ee			call debug_vector  
3349				endm  
# End of macro CALLMONITOR
3349				endif 
3349 c3 c5 1f			jp exec1 
334c			 
334c					 
334c			 
334c			 
334c			 
334c				NEXTW 
334c c3 34 1f			jp macro_next 
334f				endm 
# End of macro NEXTW
334f			 
334f			 
334f			 
334f			 
334f			.REPEAT: 
334f				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
334f 71				db WORD_SYS_CORE+93             
3350 a2 33			dw .UNTIL            
3352 06				db 5 + 1 
3353 .. 00			db "REPEAT",0              
335a				endm 
# End of macro CWHEAD
335a			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
335a			;  push pc to rsp stack past the REPEAT 
335a					if DEBUG_FORTH_WORDS_KEY 
335a						DMARK "REP" 
335a f5				push af  
335b 3a 6f 33			ld a, (.dmark)  
335e 32 6b ee			ld (debug_mark),a  
3361 3a 70 33			ld a, (.dmark+1)  
3364 32 6c ee			ld (debug_mark+1),a  
3367 3a 71 33			ld a, (.dmark+2)  
336a 32 6d ee			ld (debug_mark+2),a  
336d 18 03			jr .pastdmark  
336f ..			.dmark: db "REP"  
3372 f1			.pastdmark: pop af  
3373			endm  
# End of macro DMARK
3373						CALLMONITOR 
3373 cd 6f ee			call debug_vector  
3376				endm  
# End of macro CALLMONITOR
3376					endif 
3376			 
3376 2a c2 e5				ld hl, (os_tok_ptr) 
3379 23					inc hl   ; R 
337a 23					inc hl  ; E 
337b 23					inc hl   ; P 
337c 23					inc hl   ; E 
337d 23					inc hl   ; A 
337e 23					inc hl   ; T 
337f 23					inc hl   ; zero 
3380					FORTH_RSP_NEXT 
3380 cd 20 1b			call macro_forth_rsp_next 
3383				endm 
# End of macro FORTH_RSP_NEXT
3383			 
3383			 
3383					if DEBUG_FORTH_WORDS 
3383						DMARK "REP" 
3383 f5				push af  
3384 3a 98 33			ld a, (.dmark)  
3387 32 6b ee			ld (debug_mark),a  
338a 3a 99 33			ld a, (.dmark+1)  
338d 32 6c ee			ld (debug_mark+1),a  
3390 3a 9a 33			ld a, (.dmark+2)  
3393 32 6d ee			ld (debug_mark+2),a  
3396 18 03			jr .pastdmark  
3398 ..			.dmark: db "REP"  
339b f1			.pastdmark: pop af  
339c			endm  
# End of macro DMARK
339c						;pop bc    ; TODO BUG ?????? what is this for???? 
339c						CALLMONITOR 
339c cd 6f ee			call debug_vector  
339f				endm  
# End of macro CALLMONITOR
339f					endif 
339f			 
339f					NEXTW 
339f c3 34 1f			jp macro_next 
33a2				endm 
# End of macro NEXTW
33a2			;	       NEXTW 
33a2			 
33a2			.UNTIL: 
33a2				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
33a2 72				db WORD_SYS_CORE+94             
33a3 39 34			dw .ENDFLOW            
33a5 06				db 5 + 1 
33a6 .. 00			db "UNTIL",0              
33ac				endm 
# End of macro CWHEAD
33ac			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
33ac			 
33ac				; pop tos as check 
33ac			 
33ac				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
33ac			 
33ac				FORTH_DSP_VALUEHL 
33ac cd 7e 1d			call macro_dsp_valuehl 
33af				endm 
# End of macro FORTH_DSP_VALUEHL
33af			 
33af					if DEBUG_FORTH_WORDS_KEY 
33af						DMARK "UNT" 
33af f5				push af  
33b0 3a c4 33			ld a, (.dmark)  
33b3 32 6b ee			ld (debug_mark),a  
33b6 3a c5 33			ld a, (.dmark+1)  
33b9 32 6c ee			ld (debug_mark+1),a  
33bc 3a c6 33			ld a, (.dmark+2)  
33bf 32 6d ee			ld (debug_mark+2),a  
33c2 18 03			jr .pastdmark  
33c4 ..			.dmark: db "UNT"  
33c7 f1			.pastdmark: pop af  
33c8			endm  
# End of macro DMARK
33c8						CALLMONITOR 
33c8 cd 6f ee			call debug_vector  
33cb				endm  
# End of macro CALLMONITOR
33cb					endif 
33cb			 
33cb			;	push hl 
33cb				FORTH_DSP_POP 
33cb cd 36 1e			call macro_forth_dsp_pop 
33ce				endm 
# End of macro FORTH_DSP_POP
33ce			 
33ce			;	pop hl 
33ce			 
33ce				; test if true 
33ce			 
33ce cd 1b 0e			call ishlzero 
33d1			;	ld a,l 
33d1			;	add h 
33d1			; 
33d1			;	cp 0 
33d1			 
33d1 20 3e			jr nz, .untilnotdone 
33d3			 
33d3					if DEBUG_FORTH_WORDS 
33d3						DMARK "UNf" 
33d3 f5				push af  
33d4 3a e8 33			ld a, (.dmark)  
33d7 32 6b ee			ld (debug_mark),a  
33da 3a e9 33			ld a, (.dmark+1)  
33dd 32 6c ee			ld (debug_mark+1),a  
33e0 3a ea 33			ld a, (.dmark+2)  
33e3 32 6d ee			ld (debug_mark+2),a  
33e6 18 03			jr .pastdmark  
33e8 ..			.dmark: db "UNf"  
33eb f1			.pastdmark: pop af  
33ec			endm  
# End of macro DMARK
33ec						CALLMONITOR 
33ec cd 6f ee			call debug_vector  
33ef				endm  
# End of macro CALLMONITOR
33ef					endif 
33ef			 
33ef			 
33ef			 
33ef				FORTH_RSP_POP     ; get rid of DO ptr 
33ef cd 41 1b			call macro_forth_rsp_pop 
33f2				endm 
# End of macro FORTH_RSP_POP
33f2			 
33f2			if DEBUG_FORTH_WORDS 
33f2						DMARK "UN>" 
33f2 f5				push af  
33f3 3a 07 34			ld a, (.dmark)  
33f6 32 6b ee			ld (debug_mark),a  
33f9 3a 08 34			ld a, (.dmark+1)  
33fc 32 6c ee			ld (debug_mark+1),a  
33ff 3a 09 34			ld a, (.dmark+2)  
3402 32 6d ee			ld (debug_mark+2),a  
3405 18 03			jr .pastdmark  
3407 ..			.dmark: db "UN>"  
340a f1			.pastdmark: pop af  
340b			endm  
# End of macro DMARK
340b				CALLMONITOR 
340b cd 6f ee			call debug_vector  
340e				endm  
# End of macro CALLMONITOR
340e			endif 
340e			 
340e					NEXTW 
340e c3 34 1f			jp macro_next 
3411				endm 
# End of macro NEXTW
3411				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3411			 
3411			.untilnotdone: 
3411			 
3411			 
3411			;	; get DO ptr 
3411			; 
3411				FORTH_RSP_TOS 
3411 cd 37 1b			call macro_forth_rsp_tos 
3414				endm 
# End of macro FORTH_RSP_TOS
3414			 
3414				;push hl 
3414			 
3414				; not going to DO any more 
3414				; get rid of the RSP pointer as DO will add it back in 
3414				;FORTH_RSP_POP 
3414				;pop hl 
3414			 
3414			 
3414 22 c2 e5			ld (os_tok_ptr), hl 
3417					if DEBUG_FORTH_WORDS 
3417						DMARK "UN<" 
3417 f5				push af  
3418 3a 2c 34			ld a, (.dmark)  
341b 32 6b ee			ld (debug_mark),a  
341e 3a 2d 34			ld a, (.dmark+1)  
3421 32 6c ee			ld (debug_mark+1),a  
3424 3a 2e 34			ld a, (.dmark+2)  
3427 32 6d ee			ld (debug_mark+2),a  
342a 18 03			jr .pastdmark  
342c ..			.dmark: db "UN<"  
342f f1			.pastdmark: pop af  
3430			endm  
# End of macro DMARK
3430					CALLMONITOR 
3430 cd 6f ee			call debug_vector  
3433				endm  
# End of macro CALLMONITOR
3433				endif 
3433 c3 c5 1f			jp exec1 
3436			 
3436					 
3436			 
3436			 
3436					NEXTW 
3436 c3 34 1f			jp macro_next 
3439				endm 
# End of macro NEXTW
3439			 
3439			 
3439			.ENDFLOW: 
3439			 
3439			; eof 
3439			 
# End of file forth_words_flow.asm
3439			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3439			include "forth_words_logic.asm" 
3439			 
3439			; | ## Logic Words 
3439			 
3439			.NOT: 
3439				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3439 2d				db WORD_SYS_CORE+25             
343a 81 34			dw .IS            
343c 04				db 3 + 1 
343d .. 00			db "NOT",0              
3441				endm 
# End of macro CWHEAD
3441			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3441					if DEBUG_FORTH_WORDS_KEY 
3441						DMARK "NOT" 
3441 f5				push af  
3442 3a 56 34			ld a, (.dmark)  
3445 32 6b ee			ld (debug_mark),a  
3448 3a 57 34			ld a, (.dmark+1)  
344b 32 6c ee			ld (debug_mark+1),a  
344e 3a 58 34			ld a, (.dmark+2)  
3451 32 6d ee			ld (debug_mark+2),a  
3454 18 03			jr .pastdmark  
3456 ..			.dmark: db "NOT"  
3459 f1			.pastdmark: pop af  
345a			endm  
# End of macro DMARK
345a						CALLMONITOR 
345a cd 6f ee			call debug_vector  
345d				endm  
# End of macro CALLMONITOR
345d					endif 
345d					FORTH_DSP 
345d cd 44 1d			call macro_forth_dsp 
3460				endm 
# End of macro FORTH_DSP
3460 7e					ld a,(hl)	; get type of value on TOS 
3461 fe 02				cp DS_TYPE_INUM  
3463 28 03				jr z, .noti 
3465					NEXTW 
3465 c3 34 1f			jp macro_next 
3468				endm 
# End of macro NEXTW
3468			.noti:          FORTH_DSP_VALUEHL 
3468 cd 7e 1d			call macro_dsp_valuehl 
346b				endm 
# End of macro FORTH_DSP_VALUEHL
346b			;		push hl 
346b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
346b cd 36 1e			call macro_forth_dsp_pop 
346e				endm 
# End of macro FORTH_DSP_POP
346e			;		pop hl 
346e 3e 00				ld a,0 
3470 bd					cp l 
3471 28 04				jr z, .not2t 
3473 2e 00				ld l, 0 
3475 18 02				jr .notip 
3477			 
3477 2e ff		.not2t:		ld l, 255 
3479			 
3479 26 00		.notip:		ld h, 0	 
347b			 
347b cd 79 1b				call forth_push_numhl 
347e					NEXTW 
347e c3 34 1f			jp macro_next 
3481				endm 
# End of macro NEXTW
3481			 
3481			.IS: 
3481				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3481 2d				db WORD_SYS_CORE+25             
3482 a7 34			dw .LZERO            
3484 03				db 2 + 1 
3485 .. 00			db "IS",0              
3488				endm 
# End of macro CWHEAD
3488			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3488					if DEBUG_FORTH_WORDS_KEY 
3488						DMARK "IS." 
3488 f5				push af  
3489 3a 9d 34			ld a, (.dmark)  
348c 32 6b ee			ld (debug_mark),a  
348f 3a 9e 34			ld a, (.dmark+1)  
3492 32 6c ee			ld (debug_mark+1),a  
3495 3a 9f 34			ld a, (.dmark+2)  
3498 32 6d ee			ld (debug_mark+2),a  
349b 18 03			jr .pastdmark  
349d ..			.dmark: db "IS."  
34a0 f1			.pastdmark: pop af  
34a1			endm  
# End of macro DMARK
34a1						CALLMONITOR 
34a1 cd 6f ee			call debug_vector  
34a4				endm  
# End of macro CALLMONITOR
34a4					endif 
34a4					NEXTW 
34a4 c3 34 1f			jp macro_next 
34a7				endm 
# End of macro NEXTW
34a7			.LZERO: 
34a7				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
34a7 2d				db WORD_SYS_CORE+25             
34a8 b1 34			dw .TZERO            
34aa 03				db 2 + 1 
34ab .. 00			db "0<",0              
34ae				endm 
# End of macro CWHEAD
34ae			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
34ae					NEXTW 
34ae c3 34 1f			jp macro_next 
34b1				endm 
# End of macro NEXTW
34b1			.TZERO: 
34b1				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
34b1 2e				db WORD_SYS_CORE+26             
34b2 f8 34			dw .LESS            
34b4 03				db 2 + 1 
34b5 .. 00			db "0=",0              
34b8				endm 
# End of macro CWHEAD
34b8			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
34b8				; TODO add floating point number detection 
34b8					;v5 FORTH_DSP_VALUE 
34b8					if DEBUG_FORTH_WORDS_KEY 
34b8						DMARK "0=." 
34b8 f5				push af  
34b9 3a cd 34			ld a, (.dmark)  
34bc 32 6b ee			ld (debug_mark),a  
34bf 3a ce 34			ld a, (.dmark+1)  
34c2 32 6c ee			ld (debug_mark+1),a  
34c5 3a cf 34			ld a, (.dmark+2)  
34c8 32 6d ee			ld (debug_mark+2),a  
34cb 18 03			jr .pastdmark  
34cd ..			.dmark: db "0=."  
34d0 f1			.pastdmark: pop af  
34d1			endm  
# End of macro DMARK
34d1						CALLMONITOR 
34d1 cd 6f ee			call debug_vector  
34d4				endm  
# End of macro CALLMONITOR
34d4					endif 
34d4					FORTH_DSP 
34d4 cd 44 1d			call macro_forth_dsp 
34d7				endm 
# End of macro FORTH_DSP
34d7 7e					ld a,(hl)	; get type of value on TOS 
34d8 fe 02				cp DS_TYPE_INUM  
34da 28 00				jr z, .tz_inum 
34dc			 
34dc				if FORTH_ENABLE_FLOATMATH 
34dc					jr .tz_done 
34dc			 
34dc				endif 
34dc					 
34dc			 
34dc			.tz_inum: 
34dc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34dc cd 7e 1d			call macro_dsp_valuehl 
34df				endm 
# End of macro FORTH_DSP_VALUEHL
34df			 
34df			;		push hl 
34df			 
34df					; destroy value TOS 
34df			 
34df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34df cd 36 1e			call macro_forth_dsp_pop 
34e2				endm 
# End of macro FORTH_DSP_POP
34e2			 
34e2			;		pop hl 
34e2			 
34e2 3e 00				ld a,0 
34e4			 
34e4 bd					cp l 
34e5 20 08				jr nz, .tz_notzero 
34e7			 
34e7 bc					cp h 
34e8			 
34e8 20 05				jr nz, .tz_notzero 
34ea			 
34ea			 
34ea 21 01 00				ld hl, FORTH_TRUE 
34ed 18 03				jr .tz_done 
34ef			 
34ef 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
34f2			 
34f2					; push value back onto stack for another op etc 
34f2			 
34f2			.tz_done: 
34f2 cd 79 1b				call forth_push_numhl 
34f5			 
34f5					NEXTW 
34f5 c3 34 1f			jp macro_next 
34f8				endm 
# End of macro NEXTW
34f8			.LESS: 
34f8				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
34f8 2f				db WORD_SYS_CORE+27             
34f9 61 35			dw .GT            
34fb 02				db 1 + 1 
34fc .. 00			db "<",0              
34fe				endm 
# End of macro CWHEAD
34fe			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
34fe				; TODO add floating point number detection 
34fe					if DEBUG_FORTH_WORDS_KEY 
34fe						DMARK "LES" 
34fe f5				push af  
34ff 3a 13 35			ld a, (.dmark)  
3502 32 6b ee			ld (debug_mark),a  
3505 3a 14 35			ld a, (.dmark+1)  
3508 32 6c ee			ld (debug_mark+1),a  
350b 3a 15 35			ld a, (.dmark+2)  
350e 32 6d ee			ld (debug_mark+2),a  
3511 18 03			jr .pastdmark  
3513 ..			.dmark: db "LES"  
3516 f1			.pastdmark: pop af  
3517			endm  
# End of macro DMARK
3517						CALLMONITOR 
3517 cd 6f ee			call debug_vector  
351a				endm  
# End of macro CALLMONITOR
351a					endif 
351a					FORTH_DSP 
351a cd 44 1d			call macro_forth_dsp 
351d				endm 
# End of macro FORTH_DSP
351d					;v5 FORTH_DSP_VALUE 
351d 7e					ld a,(hl)	; get type of value on TOS 
351e fe 02				cp DS_TYPE_INUM  
3520 28 00				jr z, .less_inum 
3522			 
3522				if FORTH_ENABLE_FLOATMATH 
3522					jr .less_done 
3522			 
3522				endif 
3522					 
3522			 
3522			.less_inum: 
3522					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3522 cd 7e 1d			call macro_dsp_valuehl 
3525				endm 
# End of macro FORTH_DSP_VALUEHL
3525			 
3525 e5					push hl  ; u2 
3526			 
3526					; destroy value TOS 
3526			 
3526					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3526 cd 36 1e			call macro_forth_dsp_pop 
3529				endm 
# End of macro FORTH_DSP_POP
3529			 
3529			 
3529					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3529 cd 7e 1d			call macro_dsp_valuehl 
352c				endm 
# End of macro FORTH_DSP_VALUEHL
352c			 
352c e5					push hl    ; u1 
352d			 
352d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
352d cd 36 1e			call macro_forth_dsp_pop 
3530				endm 
# End of macro FORTH_DSP_POP
3530			 
3530			 
3530 b7			 or a      ;clear carry flag 
3531 01 00 00		 ld bc, FORTH_FALSE 
3534 e1			  pop hl    ; u1 
3535 d1			  pop de    ; u2 
3536 ed 52		  sbc hl,de 
3538 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
353a			 
353a 01 01 00		 ld bc, FORTH_TRUE 
353d			.lscont:  
353d c5					push bc 
353e e1					pop hl 
353f			 
353f					if DEBUG_FORTH_WORDS 
353f						DMARK "LT1" 
353f f5				push af  
3540 3a 54 35			ld a, (.dmark)  
3543 32 6b ee			ld (debug_mark),a  
3546 3a 55 35			ld a, (.dmark+1)  
3549 32 6c ee			ld (debug_mark+1),a  
354c 3a 56 35			ld a, (.dmark+2)  
354f 32 6d ee			ld (debug_mark+2),a  
3552 18 03			jr .pastdmark  
3554 ..			.dmark: db "LT1"  
3557 f1			.pastdmark: pop af  
3558			endm  
# End of macro DMARK
3558						CALLMONITOR 
3558 cd 6f ee			call debug_vector  
355b				endm  
# End of macro CALLMONITOR
355b					endif 
355b cd 79 1b				call forth_push_numhl 
355e			 
355e					NEXTW 
355e c3 34 1f			jp macro_next 
3561				endm 
# End of macro NEXTW
3561			.GT: 
3561				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3561 30				db WORD_SYS_CORE+28             
3562 ca 35			dw .EQUAL            
3564 02				db 1 + 1 
3565 .. 00			db ">",0              
3567				endm 
# End of macro CWHEAD
3567			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3567				; TODO add floating point number detection 
3567					if DEBUG_FORTH_WORDS_KEY 
3567						DMARK "GRT" 
3567 f5				push af  
3568 3a 7c 35			ld a, (.dmark)  
356b 32 6b ee			ld (debug_mark),a  
356e 3a 7d 35			ld a, (.dmark+1)  
3571 32 6c ee			ld (debug_mark+1),a  
3574 3a 7e 35			ld a, (.dmark+2)  
3577 32 6d ee			ld (debug_mark+2),a  
357a 18 03			jr .pastdmark  
357c ..			.dmark: db "GRT"  
357f f1			.pastdmark: pop af  
3580			endm  
# End of macro DMARK
3580						CALLMONITOR 
3580 cd 6f ee			call debug_vector  
3583				endm  
# End of macro CALLMONITOR
3583					endif 
3583					FORTH_DSP 
3583 cd 44 1d			call macro_forth_dsp 
3586				endm 
# End of macro FORTH_DSP
3586					;FORTH_DSP_VALUE 
3586 7e					ld a,(hl)	; get type of value on TOS 
3587 fe 02				cp DS_TYPE_INUM  
3589 28 00				jr z, .gt_inum 
358b			 
358b				if FORTH_ENABLE_FLOATMATH 
358b					jr .gt_done 
358b			 
358b				endif 
358b					 
358b			 
358b			.gt_inum: 
358b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
358b cd 7e 1d			call macro_dsp_valuehl 
358e				endm 
# End of macro FORTH_DSP_VALUEHL
358e			 
358e e5					push hl  ; u2 
358f			 
358f					; destroy value TOS 
358f			 
358f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
358f cd 36 1e			call macro_forth_dsp_pop 
3592				endm 
# End of macro FORTH_DSP_POP
3592			 
3592			 
3592					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3592 cd 7e 1d			call macro_dsp_valuehl 
3595				endm 
# End of macro FORTH_DSP_VALUEHL
3595			 
3595 e5					push hl    ; u1 
3596			 
3596					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3596 cd 36 1e			call macro_forth_dsp_pop 
3599				endm 
# End of macro FORTH_DSP_POP
3599			 
3599			 
3599 b7			 or a      ;clear carry flag 
359a 01 00 00		 ld bc, FORTH_FALSE 
359d e1			  pop hl    ; u1 
359e d1			  pop de    ; u2 
359f ed 52		  sbc hl,de 
35a1 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
35a3			 
35a3 01 01 00		 ld bc, FORTH_TRUE 
35a6			.gtcont:  
35a6 c5					push bc 
35a7 e1					pop hl 
35a8			 
35a8					if DEBUG_FORTH_WORDS 
35a8						DMARK "GT1" 
35a8 f5				push af  
35a9 3a bd 35			ld a, (.dmark)  
35ac 32 6b ee			ld (debug_mark),a  
35af 3a be 35			ld a, (.dmark+1)  
35b2 32 6c ee			ld (debug_mark+1),a  
35b5 3a bf 35			ld a, (.dmark+2)  
35b8 32 6d ee			ld (debug_mark+2),a  
35bb 18 03			jr .pastdmark  
35bd ..			.dmark: db "GT1"  
35c0 f1			.pastdmark: pop af  
35c1			endm  
# End of macro DMARK
35c1						CALLMONITOR 
35c1 cd 6f ee			call debug_vector  
35c4				endm  
# End of macro CALLMONITOR
35c4					endif 
35c4 cd 79 1b				call forth_push_numhl 
35c7			 
35c7					NEXTW 
35c7 c3 34 1f			jp macro_next 
35ca				endm 
# End of macro NEXTW
35ca			.EQUAL: 
35ca				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
35ca 31				db WORD_SYS_CORE+29             
35cb 35 36			dw .ENDLOGIC            
35cd 02				db 1 + 1 
35ce .. 00			db "=",0              
35d0				endm 
# End of macro CWHEAD
35d0			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
35d0				; TODO add floating point number detection 
35d0					if DEBUG_FORTH_WORDS_KEY 
35d0						DMARK "EQ." 
35d0 f5				push af  
35d1 3a e5 35			ld a, (.dmark)  
35d4 32 6b ee			ld (debug_mark),a  
35d7 3a e6 35			ld a, (.dmark+1)  
35da 32 6c ee			ld (debug_mark+1),a  
35dd 3a e7 35			ld a, (.dmark+2)  
35e0 32 6d ee			ld (debug_mark+2),a  
35e3 18 03			jr .pastdmark  
35e5 ..			.dmark: db "EQ."  
35e8 f1			.pastdmark: pop af  
35e9			endm  
# End of macro DMARK
35e9						CALLMONITOR 
35e9 cd 6f ee			call debug_vector  
35ec				endm  
# End of macro CALLMONITOR
35ec					endif 
35ec					FORTH_DSP 
35ec cd 44 1d			call macro_forth_dsp 
35ef				endm 
# End of macro FORTH_DSP
35ef					;v5 FORTH_DSP_VALUE 
35ef 7e					ld a,(hl)	; get type of value on TOS 
35f0 fe 02				cp DS_TYPE_INUM  
35f2 28 00				jr z, .eq_inum 
35f4			 
35f4				if FORTH_ENABLE_FLOATMATH 
35f4					jr .eq_done 
35f4			 
35f4				endif 
35f4					 
35f4			 
35f4			.eq_inum: 
35f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35f4 cd 7e 1d			call macro_dsp_valuehl 
35f7				endm 
# End of macro FORTH_DSP_VALUEHL
35f7			 
35f7 e5					push hl 
35f8			 
35f8					; destroy value TOS 
35f8			 
35f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35f8 cd 36 1e			call macro_forth_dsp_pop 
35fb				endm 
# End of macro FORTH_DSP_POP
35fb			 
35fb			 
35fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35fb cd 7e 1d			call macro_dsp_valuehl 
35fe				endm 
# End of macro FORTH_DSP_VALUEHL
35fe			 
35fe					; one value on hl get other one back 
35fe			 
35fe e5					push hl 
35ff			 
35ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35ff cd 36 1e			call macro_forth_dsp_pop 
3602				endm 
# End of macro FORTH_DSP_POP
3602			 
3602 0e 00				ld c, FORTH_FALSE 
3604			 
3604 e1					pop hl 
3605 d1					pop de 
3606			 
3606 7b					ld a, e 
3607 bd					cp l 
3608			 
3608 20 06				jr nz, .eq_done 
360a			 
360a 7a					ld a, d 
360b bc					cp h 
360c			 
360c 20 02				jr nz, .eq_done 
360e			 
360e 0e 01				ld c, FORTH_TRUE 
3610					 
3610			 
3610			 
3610			.eq_done: 
3610			 
3610					; TODO push value back onto stack for another op etc 
3610			 
3610 26 00				ld h, 0 
3612 69					ld l, c 
3613					if DEBUG_FORTH_WORDS 
3613						DMARK "EQ1" 
3613 f5				push af  
3614 3a 28 36			ld a, (.dmark)  
3617 32 6b ee			ld (debug_mark),a  
361a 3a 29 36			ld a, (.dmark+1)  
361d 32 6c ee			ld (debug_mark+1),a  
3620 3a 2a 36			ld a, (.dmark+2)  
3623 32 6d ee			ld (debug_mark+2),a  
3626 18 03			jr .pastdmark  
3628 ..			.dmark: db "EQ1"  
362b f1			.pastdmark: pop af  
362c			endm  
# End of macro DMARK
362c						CALLMONITOR 
362c cd 6f ee			call debug_vector  
362f				endm  
# End of macro CALLMONITOR
362f					endif 
362f cd 79 1b				call forth_push_numhl 
3632			 
3632					NEXTW 
3632 c3 34 1f			jp macro_next 
3635				endm 
# End of macro NEXTW
3635			 
3635			 
3635			.ENDLOGIC: 
3635			; eof 
3635			 
3635			 
# End of file forth_words_logic.asm
3635			include "forth_words_maths.asm" 
3635			 
3635			; | ## Maths Words 
3635			 
3635			.PLUS:	 
3635				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3635 15				db WORD_SYS_CORE+1             
3636 93 36			dw .NEG            
3638 02				db 1 + 1 
3639 .. 00			db "+",0              
363b				endm 
# End of macro CWHEAD
363b			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
363b					if DEBUG_FORTH_WORDS_KEY 
363b						DMARK "PLU" 
363b f5				push af  
363c 3a 50 36			ld a, (.dmark)  
363f 32 6b ee			ld (debug_mark),a  
3642 3a 51 36			ld a, (.dmark+1)  
3645 32 6c ee			ld (debug_mark+1),a  
3648 3a 52 36			ld a, (.dmark+2)  
364b 32 6d ee			ld (debug_mark+2),a  
364e 18 03			jr .pastdmark  
3650 ..			.dmark: db "PLU"  
3653 f1			.pastdmark: pop af  
3654			endm  
# End of macro DMARK
3654						CALLMONITOR 
3654 cd 6f ee			call debug_vector  
3657				endm  
# End of macro CALLMONITOR
3657					endif 
3657					; add top two values and push back result 
3657			 
3657					;for v5 FORTH_DSP_VALUE 
3657					FORTH_DSP 
3657 cd 44 1d			call macro_forth_dsp 
365a				endm 
# End of macro FORTH_DSP
365a 7e					ld a,(hl)	; get type of value on TOS 
365b fe 02				cp DS_TYPE_INUM  
365d 28 03				jr z, .dot_inum 
365f			 
365f					NEXTW 
365f c3 34 1f			jp macro_next 
3662				endm 
# End of macro NEXTW
3662			 
3662			; float maths 
3662			 
3662				if FORTH_ENABLE_FLOATMATH 
3662						inc hl      ; now at start of numeric as string 
3662			 
3662					if DEBUG_FORTH_MATHS 
3662						DMARK "ADD" 
3662				CALLMONITOR 
3662					endif 
3662			 
3662					;ld ix, hl 
3662					call CON 
3662			 
3662			 
3662					push hl 
3662					 
3662					 
3662			 
3662						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3662			 
3662					; get next number 
3662			 
3662						FORTH_DSP_VALUE 
3662			 
3662						inc hl      ; now at start of numeric as string 
3662			 
3662					;ld ix, hl 
3662					call CON 
3662			 
3662					push hl 
3662			 
3662			 
3662						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3662			 
3662						; TODO do add 
3662			 
3662						call IADD 
3662			 
3662						; TODO get result back as ascii 
3662			 
3662						; TODO push result  
3662			 
3662			 
3662			 
3662						jr .dot_done 
3662				endif 
3662			 
3662			.dot_inum: 
3662			 
3662			 
3662					if DEBUG_FORTH_DOT 
3662						DMARK "+IT" 
3662 f5				push af  
3663 3a 77 36			ld a, (.dmark)  
3666 32 6b ee			ld (debug_mark),a  
3669 3a 78 36			ld a, (.dmark+1)  
366c 32 6c ee			ld (debug_mark+1),a  
366f 3a 79 36			ld a, (.dmark+2)  
3672 32 6d ee			ld (debug_mark+2),a  
3675 18 03			jr .pastdmark  
3677 ..			.dmark: db "+IT"  
367a f1			.pastdmark: pop af  
367b			endm  
# End of macro DMARK
367b				CALLMONITOR 
367b cd 6f ee			call debug_vector  
367e				endm  
# End of macro CALLMONITOR
367e					endif 
367e			 
367e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
367e cd 7e 1d			call macro_dsp_valuehl 
3681				endm 
# End of macro FORTH_DSP_VALUEHL
3681			 
3681				; TODO add floating point number detection 
3681			 
3681 e5					push hl 
3682			 
3682					; destroy value TOS 
3682			 
3682					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3682 cd 36 1e			call macro_forth_dsp_pop 
3685				endm 
# End of macro FORTH_DSP_POP
3685			 
3685			 
3685					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3685 cd 7e 1d			call macro_dsp_valuehl 
3688				endm 
# End of macro FORTH_DSP_VALUEHL
3688			 
3688					; one value on hl get other one back 
3688			 
3688 d1					pop de 
3689			 
3689					; do the add 
3689			 
3689 19					add hl,de 
368a			 
368a					; save it 
368a			 
368a			;		push hl	 
368a			 
368a					; 
368a			 
368a					; destroy value TOS 
368a			 
368a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
368a cd 36 1e			call macro_forth_dsp_pop 
368d				endm 
# End of macro FORTH_DSP_POP
368d			 
368d					; TODO push value back onto stack for another op etc 
368d			 
368d			;		pop hl 
368d			 
368d			.dot_done: 
368d cd 79 1b				call forth_push_numhl 
3690			 
3690					NEXTW 
3690 c3 34 1f			jp macro_next 
3693				endm 
# End of macro NEXTW
3693			.NEG: 
3693			 
3693				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3693 17				db WORD_SYS_CORE+3             
3694 d6 36			dw .DIV            
3696 02				db 1 + 1 
3697 .. 00			db "-",0              
3699				endm 
# End of macro CWHEAD
3699			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3699					if DEBUG_FORTH_WORDS_KEY 
3699						DMARK "SUB" 
3699 f5				push af  
369a 3a ae 36			ld a, (.dmark)  
369d 32 6b ee			ld (debug_mark),a  
36a0 3a af 36			ld a, (.dmark+1)  
36a3 32 6c ee			ld (debug_mark+1),a  
36a6 3a b0 36			ld a, (.dmark+2)  
36a9 32 6d ee			ld (debug_mark+2),a  
36ac 18 03			jr .pastdmark  
36ae ..			.dmark: db "SUB"  
36b1 f1			.pastdmark: pop af  
36b2			endm  
# End of macro DMARK
36b2						CALLMONITOR 
36b2 cd 6f ee			call debug_vector  
36b5				endm  
# End of macro CALLMONITOR
36b5					endif 
36b5			 
36b5			 
36b5				; TODO add floating point number detection 
36b5					; v5 FORTH_DSP_VALUE 
36b5					FORTH_DSP 
36b5 cd 44 1d			call macro_forth_dsp 
36b8				endm 
# End of macro FORTH_DSP
36b8 7e					ld a,(hl)	; get type of value on TOS 
36b9 fe 02				cp DS_TYPE_INUM  
36bb 28 03				jr z, .neg_inum 
36bd			 
36bd					NEXTW 
36bd c3 34 1f			jp macro_next 
36c0				endm 
# End of macro NEXTW
36c0			 
36c0			; float maths 
36c0			 
36c0				if FORTH_ENABLE_FLOATMATH 
36c0					jr .neg_done 
36c0			 
36c0				endif 
36c0					 
36c0			 
36c0			.neg_inum: 
36c0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36c0 cd 7e 1d			call macro_dsp_valuehl 
36c3				endm 
# End of macro FORTH_DSP_VALUEHL
36c3			 
36c3 e5					push hl 
36c4			 
36c4					; destroy value TOS 
36c4			 
36c4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36c4 cd 36 1e			call macro_forth_dsp_pop 
36c7				endm 
# End of macro FORTH_DSP_POP
36c7			 
36c7			 
36c7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36c7 cd 7e 1d			call macro_dsp_valuehl 
36ca				endm 
# End of macro FORTH_DSP_VALUEHL
36ca			 
36ca					; one value on hl get other one back 
36ca			 
36ca d1					pop de 
36cb			 
36cb					; do the sub 
36cb			;		ex de, hl 
36cb			 
36cb ed 52				sbc hl,de 
36cd			 
36cd					; save it 
36cd			 
36cd			;		push hl	 
36cd			 
36cd					; 
36cd			 
36cd					; destroy value TOS 
36cd			 
36cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36cd cd 36 1e			call macro_forth_dsp_pop 
36d0				endm 
# End of macro FORTH_DSP_POP
36d0			 
36d0					; TODO push value back onto stack for another op etc 
36d0			 
36d0			;		pop hl 
36d0			 
36d0 cd 79 1b				call forth_push_numhl 
36d3			.neg_done: 
36d3			 
36d3					NEXTW 
36d3 c3 34 1f			jp macro_next 
36d6				endm 
# End of macro NEXTW
36d6			.DIV: 
36d6				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
36d6 18				db WORD_SYS_CORE+4             
36d7 23 37			dw .MUL            
36d9 02				db 1 + 1 
36da .. 00			db "/",0              
36dc				endm 
# End of macro CWHEAD
36dc			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
36dc					if DEBUG_FORTH_WORDS_KEY 
36dc						DMARK "DIV" 
36dc f5				push af  
36dd 3a f1 36			ld a, (.dmark)  
36e0 32 6b ee			ld (debug_mark),a  
36e3 3a f2 36			ld a, (.dmark+1)  
36e6 32 6c ee			ld (debug_mark+1),a  
36e9 3a f3 36			ld a, (.dmark+2)  
36ec 32 6d ee			ld (debug_mark+2),a  
36ef 18 03			jr .pastdmark  
36f1 ..			.dmark: db "DIV"  
36f4 f1			.pastdmark: pop af  
36f5			endm  
# End of macro DMARK
36f5						CALLMONITOR 
36f5 cd 6f ee			call debug_vector  
36f8				endm  
# End of macro CALLMONITOR
36f8					endif 
36f8				; TODO add floating point number detection 
36f8					; v5 FORTH_DSP_VALUE 
36f8					FORTH_DSP 
36f8 cd 44 1d			call macro_forth_dsp 
36fb				endm 
# End of macro FORTH_DSP
36fb 7e					ld a,(hl)	; get type of value on TOS 
36fc fe 02				cp DS_TYPE_INUM  
36fe 28 03				jr z, .div_inum 
3700			 
3700				if FORTH_ENABLE_FLOATMATH 
3700					jr .div_done 
3700			 
3700				endif 
3700					NEXTW 
3700 c3 34 1f			jp macro_next 
3703				endm 
# End of macro NEXTW
3703			.div_inum: 
3703			 
3703					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3703 cd 7e 1d			call macro_dsp_valuehl 
3706				endm 
# End of macro FORTH_DSP_VALUEHL
3706			 
3706 e5					push hl    ; to go to bc 
3707			 
3707					; destroy value TOS 
3707			 
3707					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3707 cd 36 1e			call macro_forth_dsp_pop 
370a				endm 
# End of macro FORTH_DSP_POP
370a			 
370a			 
370a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
370a cd 7e 1d			call macro_dsp_valuehl 
370d				endm 
# End of macro FORTH_DSP_VALUEHL
370d			 
370d					; hl to go to de 
370d			 
370d e5					push hl 
370e			 
370e c1					pop bc 
370f d1					pop de		 
3710			 
3710			 
3710					if DEBUG_FORTH_MATHS 
3710						DMARK "DIV" 
3710				CALLMONITOR 
3710					endif 
3710					; one value on hl but move to a get other one back 
3710			 
3710			        
3710 cd 4f 0d			call Div16 
3713			 
3713			;	push af	 
3713 e5				push hl 
3714 c5				push bc 
3715			 
3715					if DEBUG_FORTH_MATHS 
3715						DMARK "DI1" 
3715				CALLMONITOR 
3715					endif 
3715			 
3715					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3715 cd 36 1e			call macro_forth_dsp_pop 
3718				endm 
# End of macro FORTH_DSP_POP
3718			 
3718			 
3718			 
3718 e1					pop hl    ; result 
3719			 
3719 cd 79 1b				call forth_push_numhl 
371c			 
371c e1					pop hl    ; reminder 
371d			;		ld h,0 
371d			;		ld l,d 
371d			 
371d cd 79 1b				call forth_push_numhl 
3720			.div_done: 
3720					NEXTW 
3720 c3 34 1f			jp macro_next 
3723				endm 
# End of macro NEXTW
3723			.MUL: 
3723				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3723 19				db WORD_SYS_CORE+5             
3724 68 37			dw .MIN            
3726 02				db 1 + 1 
3727 .. 00			db "*",0              
3729				endm 
# End of macro CWHEAD
3729			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3729				; TODO add floating point number detection 
3729					if DEBUG_FORTH_WORDS_KEY 
3729						DMARK "MUL" 
3729 f5				push af  
372a 3a 3e 37			ld a, (.dmark)  
372d 32 6b ee			ld (debug_mark),a  
3730 3a 3f 37			ld a, (.dmark+1)  
3733 32 6c ee			ld (debug_mark+1),a  
3736 3a 40 37			ld a, (.dmark+2)  
3739 32 6d ee			ld (debug_mark+2),a  
373c 18 03			jr .pastdmark  
373e ..			.dmark: db "MUL"  
3741 f1			.pastdmark: pop af  
3742			endm  
# End of macro DMARK
3742						CALLMONITOR 
3742 cd 6f ee			call debug_vector  
3745				endm  
# End of macro CALLMONITOR
3745					endif 
3745					FORTH_DSP 
3745 cd 44 1d			call macro_forth_dsp 
3748				endm 
# End of macro FORTH_DSP
3748					; v5 FORTH_DSP_VALUE 
3748 7e					ld a,(hl)	; get type of value on TOS 
3749 fe 02				cp DS_TYPE_INUM  
374b 28 03				jr z, .mul_inum 
374d			 
374d				if FORTH_ENABLE_FLOATMATH 
374d					jr .mul_done 
374d			 
374d				endif 
374d			 
374d					NEXTW 
374d c3 34 1f			jp macro_next 
3750				endm 
# End of macro NEXTW
3750			.mul_inum:	 
3750			 
3750					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3750 cd 7e 1d			call macro_dsp_valuehl 
3753				endm 
# End of macro FORTH_DSP_VALUEHL
3753			 
3753 e5					push hl 
3754			 
3754					; destroy value TOS 
3754			 
3754					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3754 cd 36 1e			call macro_forth_dsp_pop 
3757				endm 
# End of macro FORTH_DSP_POP
3757			 
3757			 
3757					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3757 cd 7e 1d			call macro_dsp_valuehl 
375a				endm 
# End of macro FORTH_DSP_VALUEHL
375a			 
375a					; one value on hl but move to a get other one back 
375a			 
375a 7d					ld a, l 
375b			 
375b d1					pop de 
375c			 
375c					; do the mull 
375c			;		ex de, hl 
375c			 
375c cd 75 0d				call Mult16 
375f					; save it 
375f			 
375f			;		push hl	 
375f			 
375f					; 
375f			 
375f					; destroy value TOS 
375f			 
375f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
375f cd 36 1e			call macro_forth_dsp_pop 
3762				endm 
# End of macro FORTH_DSP_POP
3762			 
3762					; TODO push value back onto stack for another op etc 
3762			 
3762			;		pop hl 
3762			 
3762 cd 79 1b				call forth_push_numhl 
3765			 
3765			.mul_done: 
3765					NEXTW 
3765 c3 34 1f			jp macro_next 
3768				endm 
# End of macro NEXTW
3768			 
3768			 
3768			 
3768			 
3768			.MIN: 
3768				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3768 49				db WORD_SYS_CORE+53             
3769 e9 37			dw .MAX            
376b 04				db 3 + 1 
376c .. 00			db "MIN",0              
3770				endm 
# End of macro CWHEAD
3770			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3770					if DEBUG_FORTH_WORDS_KEY 
3770						DMARK "MIN" 
3770 f5				push af  
3771 3a 85 37			ld a, (.dmark)  
3774 32 6b ee			ld (debug_mark),a  
3777 3a 86 37			ld a, (.dmark+1)  
377a 32 6c ee			ld (debug_mark+1),a  
377d 3a 87 37			ld a, (.dmark+2)  
3780 32 6d ee			ld (debug_mark+2),a  
3783 18 03			jr .pastdmark  
3785 ..			.dmark: db "MIN"  
3788 f1			.pastdmark: pop af  
3789			endm  
# End of macro DMARK
3789						CALLMONITOR 
3789 cd 6f ee			call debug_vector  
378c				endm  
# End of macro CALLMONITOR
378c					endif 
378c					; get u2 
378c			 
378c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
378c cd 7e 1d			call macro_dsp_valuehl 
378f				endm 
# End of macro FORTH_DSP_VALUEHL
378f			 
378f e5					push hl   ; u2 
3790			 
3790					; destroy value TOS 
3790			 
3790					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3790 cd 36 1e			call macro_forth_dsp_pop 
3793				endm 
# End of macro FORTH_DSP_POP
3793			 
3793					; get u1 
3793			 
3793					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3793 cd 7e 1d			call macro_dsp_valuehl 
3796				endm 
# End of macro FORTH_DSP_VALUEHL
3796			 
3796 e5					push hl  ; u1 
3797			 
3797					; destroy value TOS 
3797			 
3797					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3797 cd 36 1e			call macro_forth_dsp_pop 
379a				endm 
# End of macro FORTH_DSP_POP
379a			 
379a b7			 or a      ;clear carry flag 
379b e1			  pop hl    ; u1 
379c d1			  pop de    ; u2 
379d e5				push hl   ; saved in case hl is lowest 
379e ed 52		  sbc hl,de 
37a0 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
37a2			 
37a2 e1				pop hl 
37a3					if DEBUG_FORTH_WORDS 
37a3						DMARK "MIN" 
37a3 f5				push af  
37a4 3a b8 37			ld a, (.dmark)  
37a7 32 6b ee			ld (debug_mark),a  
37aa 3a b9 37			ld a, (.dmark+1)  
37ad 32 6c ee			ld (debug_mark+1),a  
37b0 3a ba 37			ld a, (.dmark+2)  
37b3 32 6d ee			ld (debug_mark+2),a  
37b6 18 03			jr .pastdmark  
37b8 ..			.dmark: db "MIN"  
37bb f1			.pastdmark: pop af  
37bc			endm  
# End of macro DMARK
37bc						CALLMONITOR 
37bc cd 6f ee			call debug_vector  
37bf				endm  
# End of macro CALLMONITOR
37bf					endif 
37bf cd 79 1b				call forth_push_numhl 
37c2			 
37c2				       NEXTW 
37c2 c3 34 1f			jp macro_next 
37c5				endm 
# End of macro NEXTW
37c5			 
37c5			.mincont:  
37c5 c1				pop bc   ; tidy up 
37c6 eb				ex de , hl  
37c7					if DEBUG_FORTH_WORDS 
37c7						DMARK "MI1" 
37c7 f5				push af  
37c8 3a dc 37			ld a, (.dmark)  
37cb 32 6b ee			ld (debug_mark),a  
37ce 3a dd 37			ld a, (.dmark+1)  
37d1 32 6c ee			ld (debug_mark+1),a  
37d4 3a de 37			ld a, (.dmark+2)  
37d7 32 6d ee			ld (debug_mark+2),a  
37da 18 03			jr .pastdmark  
37dc ..			.dmark: db "MI1"  
37df f1			.pastdmark: pop af  
37e0			endm  
# End of macro DMARK
37e0						CALLMONITOR 
37e0 cd 6f ee			call debug_vector  
37e3				endm  
# End of macro CALLMONITOR
37e3					endif 
37e3 cd 79 1b				call forth_push_numhl 
37e6			 
37e6				       NEXTW 
37e6 c3 34 1f			jp macro_next 
37e9				endm 
# End of macro NEXTW
37e9			.MAX: 
37e9				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
37e9 4a				db WORD_SYS_CORE+54             
37ea 6a 38			dw .RND16            
37ec 04				db 3 + 1 
37ed .. 00			db "MAX",0              
37f1				endm 
# End of macro CWHEAD
37f1			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
37f1					if DEBUG_FORTH_WORDS_KEY 
37f1						DMARK "MAX" 
37f1 f5				push af  
37f2 3a 06 38			ld a, (.dmark)  
37f5 32 6b ee			ld (debug_mark),a  
37f8 3a 07 38			ld a, (.dmark+1)  
37fb 32 6c ee			ld (debug_mark+1),a  
37fe 3a 08 38			ld a, (.dmark+2)  
3801 32 6d ee			ld (debug_mark+2),a  
3804 18 03			jr .pastdmark  
3806 ..			.dmark: db "MAX"  
3809 f1			.pastdmark: pop af  
380a			endm  
# End of macro DMARK
380a						CALLMONITOR 
380a cd 6f ee			call debug_vector  
380d				endm  
# End of macro CALLMONITOR
380d					endif 
380d					; get u2 
380d			 
380d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
380d cd 7e 1d			call macro_dsp_valuehl 
3810				endm 
# End of macro FORTH_DSP_VALUEHL
3810			 
3810 e5					push hl   ; u2 
3811			 
3811					; destroy value TOS 
3811			 
3811					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3811 cd 36 1e			call macro_forth_dsp_pop 
3814				endm 
# End of macro FORTH_DSP_POP
3814			 
3814					; get u1 
3814			 
3814					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3814 cd 7e 1d			call macro_dsp_valuehl 
3817				endm 
# End of macro FORTH_DSP_VALUEHL
3817			 
3817 e5					push hl  ; u1 
3818			 
3818					; destroy value TOS 
3818			 
3818					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3818 cd 36 1e			call macro_forth_dsp_pop 
381b				endm 
# End of macro FORTH_DSP_POP
381b			 
381b b7			 or a      ;clear carry flag 
381c e1			  pop hl    ; u1 
381d d1			  pop de    ; u2 
381e e5				push hl   ; saved in case hl is lowest 
381f ed 52		  sbc hl,de 
3821 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3823			 
3823 e1				pop hl 
3824					if DEBUG_FORTH_WORDS 
3824						DMARK "MAX" 
3824 f5				push af  
3825 3a 39 38			ld a, (.dmark)  
3828 32 6b ee			ld (debug_mark),a  
382b 3a 3a 38			ld a, (.dmark+1)  
382e 32 6c ee			ld (debug_mark+1),a  
3831 3a 3b 38			ld a, (.dmark+2)  
3834 32 6d ee			ld (debug_mark+2),a  
3837 18 03			jr .pastdmark  
3839 ..			.dmark: db "MAX"  
383c f1			.pastdmark: pop af  
383d			endm  
# End of macro DMARK
383d						CALLMONITOR 
383d cd 6f ee			call debug_vector  
3840				endm  
# End of macro CALLMONITOR
3840					endif 
3840 cd 79 1b				call forth_push_numhl 
3843			 
3843				       NEXTW 
3843 c3 34 1f			jp macro_next 
3846				endm 
# End of macro NEXTW
3846			 
3846			.maxcont:  
3846 c1				pop bc   ; tidy up 
3847 eb				ex de , hl  
3848					if DEBUG_FORTH_WORDS 
3848						DMARK "MA1" 
3848 f5				push af  
3849 3a 5d 38			ld a, (.dmark)  
384c 32 6b ee			ld (debug_mark),a  
384f 3a 5e 38			ld a, (.dmark+1)  
3852 32 6c ee			ld (debug_mark+1),a  
3855 3a 5f 38			ld a, (.dmark+2)  
3858 32 6d ee			ld (debug_mark+2),a  
385b 18 03			jr .pastdmark  
385d ..			.dmark: db "MA1"  
3860 f1			.pastdmark: pop af  
3861			endm  
# End of macro DMARK
3861						CALLMONITOR 
3861 cd 6f ee			call debug_vector  
3864				endm  
# End of macro CALLMONITOR
3864					endif 
3864 cd 79 1b				call forth_push_numhl 
3867				       NEXTW 
3867 c3 34 1f			jp macro_next 
386a				endm 
# End of macro NEXTW
386a			 
386a			.RND16: 
386a				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
386a 4e				db WORD_SYS_CORE+58             
386b 99 38			dw .RND8            
386d 06				db 5 + 1 
386e .. 00			db "RND16",0              
3874				endm 
# End of macro CWHEAD
3874			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3874					if DEBUG_FORTH_WORDS_KEY 
3874						DMARK "R16" 
3874 f5				push af  
3875 3a 89 38			ld a, (.dmark)  
3878 32 6b ee			ld (debug_mark),a  
387b 3a 8a 38			ld a, (.dmark+1)  
387e 32 6c ee			ld (debug_mark+1),a  
3881 3a 8b 38			ld a, (.dmark+2)  
3884 32 6d ee			ld (debug_mark+2),a  
3887 18 03			jr .pastdmark  
3889 ..			.dmark: db "R16"  
388c f1			.pastdmark: pop af  
388d			endm  
# End of macro DMARK
388d						CALLMONITOR 
388d cd 6f ee			call debug_vector  
3890				endm  
# End of macro CALLMONITOR
3890					endif 
3890 cd 19 0d				call prng16  
3893 cd 79 1b				call forth_push_numhl 
3896				       NEXTW 
3896 c3 34 1f			jp macro_next 
3899				endm 
# End of macro NEXTW
3899			.RND8: 
3899				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3899 60				db WORD_SYS_CORE+76             
389a ce 38			dw .RND            
389c 05				db 4 + 1 
389d .. 00			db "RND8",0              
38a2				endm 
# End of macro CWHEAD
38a2			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
38a2					if DEBUG_FORTH_WORDS_KEY 
38a2						DMARK "RN8" 
38a2 f5				push af  
38a3 3a b7 38			ld a, (.dmark)  
38a6 32 6b ee			ld (debug_mark),a  
38a9 3a b8 38			ld a, (.dmark+1)  
38ac 32 6c ee			ld (debug_mark+1),a  
38af 3a b9 38			ld a, (.dmark+2)  
38b2 32 6d ee			ld (debug_mark+2),a  
38b5 18 03			jr .pastdmark  
38b7 ..			.dmark: db "RN8"  
38ba f1			.pastdmark: pop af  
38bb			endm  
# End of macro DMARK
38bb						CALLMONITOR 
38bb cd 6f ee			call debug_vector  
38be				endm  
# End of macro CALLMONITOR
38be					endif 
38be 2a a9 eb				ld hl,(xrandc) 
38c1 23					inc hl 
38c2 cd 33 0d				call xrnd 
38c5 6f					ld l,a	 
38c6 26 00				ld h,0 
38c8 cd 79 1b				call forth_push_numhl 
38cb				       NEXTW 
38cb c3 34 1f			jp macro_next 
38ce				endm 
# End of macro NEXTW
38ce			.RND: 
38ce				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
38ce 60				db WORD_SYS_CORE+76             
38cf d4 39			dw .ENDMATHS            
38d1 04				db 3 + 1 
38d2 .. 00			db "RND",0              
38d6				endm 
# End of macro CWHEAD
38d6			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
38d6			 
38d6					if DEBUG_FORTH_WORDS_KEY 
38d6						DMARK "RND" 
38d6 f5				push af  
38d7 3a eb 38			ld a, (.dmark)  
38da 32 6b ee			ld (debug_mark),a  
38dd 3a ec 38			ld a, (.dmark+1)  
38e0 32 6c ee			ld (debug_mark+1),a  
38e3 3a ed 38			ld a, (.dmark+2)  
38e6 32 6d ee			ld (debug_mark+2),a  
38e9 18 03			jr .pastdmark  
38eb ..			.dmark: db "RND"  
38ee f1			.pastdmark: pop af  
38ef			endm  
# End of macro DMARK
38ef						CALLMONITOR 
38ef cd 6f ee			call debug_vector  
38f2				endm  
# End of macro CALLMONITOR
38f2					endif 
38f2					 
38f2					FORTH_DSP_VALUEHL    ; upper range 
38f2 cd 7e 1d			call macro_dsp_valuehl 
38f5				endm 
# End of macro FORTH_DSP_VALUEHL
38f5			 
38f5 22 ad eb				ld (LFSRSeed), hl	 
38f8			 
38f8					if DEBUG_FORTH_WORDS 
38f8						DMARK "RN1" 
38f8 f5				push af  
38f9 3a 0d 39			ld a, (.dmark)  
38fc 32 6b ee			ld (debug_mark),a  
38ff 3a 0e 39			ld a, (.dmark+1)  
3902 32 6c ee			ld (debug_mark+1),a  
3905 3a 0f 39			ld a, (.dmark+2)  
3908 32 6d ee			ld (debug_mark+2),a  
390b 18 03			jr .pastdmark  
390d ..			.dmark: db "RN1"  
3910 f1			.pastdmark: pop af  
3911			endm  
# End of macro DMARK
3911						CALLMONITOR 
3911 cd 6f ee			call debug_vector  
3914				endm  
# End of macro CALLMONITOR
3914					endif 
3914					FORTH_DSP_POP 
3914 cd 36 1e			call macro_forth_dsp_pop 
3917				endm 
# End of macro FORTH_DSP_POP
3917			 
3917					FORTH_DSP_VALUEHL    ; low range 
3917 cd 7e 1d			call macro_dsp_valuehl 
391a				endm 
# End of macro FORTH_DSP_VALUEHL
391a			 
391a					if DEBUG_FORTH_WORDS 
391a						DMARK "RN2" 
391a f5				push af  
391b 3a 2f 39			ld a, (.dmark)  
391e 32 6b ee			ld (debug_mark),a  
3921 3a 30 39			ld a, (.dmark+1)  
3924 32 6c ee			ld (debug_mark+1),a  
3927 3a 31 39			ld a, (.dmark+2)  
392a 32 6d ee			ld (debug_mark+2),a  
392d 18 03			jr .pastdmark  
392f ..			.dmark: db "RN2"  
3932 f1			.pastdmark: pop af  
3933			endm  
# End of macro DMARK
3933						CALLMONITOR 
3933 cd 6f ee			call debug_vector  
3936				endm  
# End of macro CALLMONITOR
3936					endif 
3936 22 af eb				ld (LFSRSeed+2), hl 
3939			 
3939					FORTH_DSP_POP 
3939 cd 36 1e			call macro_forth_dsp_pop 
393c				endm 
# End of macro FORTH_DSP_POP
393c			 
393c e5					push hl 
393d			 
393d e1			.inrange:	pop hl 
393e cd 19 0d				call prng16  
3941					if DEBUG_FORTH_WORDS 
3941						DMARK "RN3" 
3941 f5				push af  
3942 3a 56 39			ld a, (.dmark)  
3945 32 6b ee			ld (debug_mark),a  
3948 3a 57 39			ld a, (.dmark+1)  
394b 32 6c ee			ld (debug_mark+1),a  
394e 3a 58 39			ld a, (.dmark+2)  
3951 32 6d ee			ld (debug_mark+2),a  
3954 18 03			jr .pastdmark  
3956 ..			.dmark: db "RN3"  
3959 f1			.pastdmark: pop af  
395a			endm  
# End of macro DMARK
395a						CALLMONITOR 
395a cd 6f ee			call debug_vector  
395d				endm  
# End of macro CALLMONITOR
395d					endif 
395d					 
395d					; if the range is 8bit knock out the high byte 
395d			 
395d ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
3961			 
3961 3e 00				ld a, 0 
3963 ba					cp d  
3964 20 1e				jr nz, .hirange 
3966 26 00				ld h, 0   ; knock it down to 8bit 
3968			 
3968					if DEBUG_FORTH_WORDS 
3968						DMARK "RNk" 
3968 f5				push af  
3969 3a 7d 39			ld a, (.dmark)  
396c 32 6b ee			ld (debug_mark),a  
396f 3a 7e 39			ld a, (.dmark+1)  
3972 32 6c ee			ld (debug_mark+1),a  
3975 3a 7f 39			ld a, (.dmark+2)  
3978 32 6d ee			ld (debug_mark+2),a  
397b 18 03			jr .pastdmark  
397d ..			.dmark: db "RNk"  
3980 f1			.pastdmark: pop af  
3981			endm  
# End of macro DMARK
3981						CALLMONITOR 
3981 cd 6f ee			call debug_vector  
3984				endm  
# End of macro CALLMONITOR
3984					endif 
3984			.hirange:   
3984 e5					push hl  
3985 b7					or a  
3986 ed 52		                sbc hl, de 
3988			 
3988					;call cmp16 
3988			 
3988 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
398a e1					pop hl 
398b e5					push hl 
398c			 
398c					if DEBUG_FORTH_WORDS 
398c						DMARK "RN4" 
398c f5				push af  
398d 3a a1 39			ld a, (.dmark)  
3990 32 6b ee			ld (debug_mark),a  
3993 3a a2 39			ld a, (.dmark+1)  
3996 32 6c ee			ld (debug_mark+1),a  
3999 3a a3 39			ld a, (.dmark+2)  
399c 32 6d ee			ld (debug_mark+2),a  
399f 18 03			jr .pastdmark  
39a1 ..			.dmark: db "RN4"  
39a4 f1			.pastdmark: pop af  
39a5			endm  
# End of macro DMARK
39a5						CALLMONITOR 
39a5 cd 6f ee			call debug_vector  
39a8				endm  
# End of macro CALLMONITOR
39a8					endif 
39a8 ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
39ac					;call cmp16 
39ac				 
39ac b7					or a  
39ad ed 52		                sbc hl, de 
39af 38 8c				jr c, .inrange 
39b1			 
39b1 e1					pop hl 
39b2					 
39b2					if DEBUG_FORTH_WORDS 
39b2						DMARK "RNd" 
39b2 f5				push af  
39b3 3a c7 39			ld a, (.dmark)  
39b6 32 6b ee			ld (debug_mark),a  
39b9 3a c8 39			ld a, (.dmark+1)  
39bc 32 6c ee			ld (debug_mark+1),a  
39bf 3a c9 39			ld a, (.dmark+2)  
39c2 32 6d ee			ld (debug_mark+2),a  
39c5 18 03			jr .pastdmark  
39c7 ..			.dmark: db "RNd"  
39ca f1			.pastdmark: pop af  
39cb			endm  
# End of macro DMARK
39cb						CALLMONITOR 
39cb cd 6f ee			call debug_vector  
39ce				endm  
# End of macro CALLMONITOR
39ce					endif 
39ce			 
39ce			 
39ce cd 79 1b				call forth_push_numhl 
39d1				       NEXTW 
39d1 c3 34 1f			jp macro_next 
39d4				endm 
# End of macro NEXTW
39d4			 
39d4			.ENDMATHS: 
39d4			 
39d4			; eof 
39d4			 
# End of file forth_words_maths.asm
39d4			include "forth_words_display.asm" 
39d4			 
39d4			; | ## Display Words 
39d4			 
39d4			.ACT: 
39d4			 
39d4				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
39d4 62				db WORD_SYS_CORE+78             
39d5 20 3a			dw .INFO            
39d7 07				db 6 + 1 
39d8 .. 00			db "ACTIVE",0              
39df				endm 
# End of macro CWHEAD
39df			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
39df			;  
39df			; | | To display a pulsing activity indicator in a processing loop do this... 
39df			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
39df			 
39df					if DEBUG_FORTH_WORDS_KEY 
39df						DMARK "ACT" 
39df f5				push af  
39e0 3a f4 39			ld a, (.dmark)  
39e3 32 6b ee			ld (debug_mark),a  
39e6 3a f5 39			ld a, (.dmark+1)  
39e9 32 6c ee			ld (debug_mark+1),a  
39ec 3a f6 39			ld a, (.dmark+2)  
39ef 32 6d ee			ld (debug_mark+2),a  
39f2 18 03			jr .pastdmark  
39f4 ..			.dmark: db "ACT"  
39f7 f1			.pastdmark: pop af  
39f8			endm  
# End of macro DMARK
39f8						CALLMONITOR 
39f8 cd 6f ee			call debug_vector  
39fb				endm  
# End of macro CALLMONITOR
39fb					endif 
39fb cd 1c 0b				call active 
39fe					if DEBUG_FORTH_WORDS 
39fe						DMARK "ACp" 
39fe f5				push af  
39ff 3a 13 3a			ld a, (.dmark)  
3a02 32 6b ee			ld (debug_mark),a  
3a05 3a 14 3a			ld a, (.dmark+1)  
3a08 32 6c ee			ld (debug_mark+1),a  
3a0b 3a 15 3a			ld a, (.dmark+2)  
3a0e 32 6d ee			ld (debug_mark+2),a  
3a11 18 03			jr .pastdmark  
3a13 ..			.dmark: db "ACp"  
3a16 f1			.pastdmark: pop af  
3a17			endm  
# End of macro DMARK
3a17						CALLMONITOR 
3a17 cd 6f ee			call debug_vector  
3a1a				endm  
# End of macro CALLMONITOR
3a1a					endif 
3a1a cd e7 1b				call forth_push_str 
3a1d			 
3a1d					NEXTW 
3a1d c3 34 1f			jp macro_next 
3a20				endm 
# End of macro NEXTW
3a20			.INFO: 
3a20			 
3a20				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3a20 62				db WORD_SYS_CORE+78             
3a21 3d 3a			dw .ATP            
3a23 05				db 4 + 1 
3a24 .. 00			db "INFO",0              
3a29				endm 
# End of macro CWHEAD
3a29			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3a29					FORTH_DSP_VALUEHL 
3a29 cd 7e 1d			call macro_dsp_valuehl 
3a2c				endm 
# End of macro FORTH_DSP_VALUEHL
3a2c			 
3a2c					FORTH_DSP_POP 
3a2c cd 36 1e			call macro_forth_dsp_pop 
3a2f				endm 
# End of macro FORTH_DSP_POP
3a2f			 
3a2f e5					push hl 
3a30			 
3a30					FORTH_DSP_VALUEHL 
3a30 cd 7e 1d			call macro_dsp_valuehl 
3a33				endm 
# End of macro FORTH_DSP_VALUEHL
3a33			 
3a33					FORTH_DSP_POP 
3a33 cd 36 1e			call macro_forth_dsp_pop 
3a36				endm 
# End of macro FORTH_DSP_POP
3a36			 
3a36 d1					pop de 
3a37			 
3a37 cd 56 0b				call info_panel 
3a3a			 
3a3a			 
3a3a					NEXTW 
3a3a c3 34 1f			jp macro_next 
3a3d				endm 
# End of macro NEXTW
3a3d			.ATP: 
3a3d				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a3d 62				db WORD_SYS_CORE+78             
3a3e b4 3a			dw .FB            
3a40 04				db 3 + 1 
3a41 .. 00			db "AT?",0              
3a45				endm 
# End of macro CWHEAD
3a45			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a45					if DEBUG_FORTH_WORDS_KEY 
3a45						DMARK "AT?" 
3a45 f5				push af  
3a46 3a 5a 3a			ld a, (.dmark)  
3a49 32 6b ee			ld (debug_mark),a  
3a4c 3a 5b 3a			ld a, (.dmark+1)  
3a4f 32 6c ee			ld (debug_mark+1),a  
3a52 3a 5c 3a			ld a, (.dmark+2)  
3a55 32 6d ee			ld (debug_mark+2),a  
3a58 18 03			jr .pastdmark  
3a5a ..			.dmark: db "AT?"  
3a5d f1			.pastdmark: pop af  
3a5e			endm  
# End of macro DMARK
3a5e						CALLMONITOR 
3a5e cd 6f ee			call debug_vector  
3a61				endm  
# End of macro CALLMONITOR
3a61					endif 
3a61 3a 5e ea				ld a, (f_cursor_ptr) 
3a64			 
3a64			if DEBUG_FORTH_WORDS 
3a64				DMARK "AT?" 
3a64 f5				push af  
3a65 3a 79 3a			ld a, (.dmark)  
3a68 32 6b ee			ld (debug_mark),a  
3a6b 3a 7a 3a			ld a, (.dmark+1)  
3a6e 32 6c ee			ld (debug_mark+1),a  
3a71 3a 7b 3a			ld a, (.dmark+2)  
3a74 32 6d ee			ld (debug_mark+2),a  
3a77 18 03			jr .pastdmark  
3a79 ..			.dmark: db "AT?"  
3a7c f1			.pastdmark: pop af  
3a7d			endm  
# End of macro DMARK
3a7d				CALLMONITOR 
3a7d cd 6f ee			call debug_vector  
3a80				endm  
# End of macro CALLMONITOR
3a80			endif	 
3a80					; count the number of rows 
3a80			 
3a80 06 00				ld b, 0 
3a82 4f			.atpr:		ld c, a    ; save in case we go below zero 
3a83 d6 28				sub display_cols 
3a85 f2 8b 3a				jp p, .atprunder 
3a88 04					inc b 
3a89 18 f7				jr .atpr 
3a8b			.atprunder:	 
3a8b			if DEBUG_FORTH_WORDS 
3a8b				DMARK "A?2" 
3a8b f5				push af  
3a8c 3a a0 3a			ld a, (.dmark)  
3a8f 32 6b ee			ld (debug_mark),a  
3a92 3a a1 3a			ld a, (.dmark+1)  
3a95 32 6c ee			ld (debug_mark+1),a  
3a98 3a a2 3a			ld a, (.dmark+2)  
3a9b 32 6d ee			ld (debug_mark+2),a  
3a9e 18 03			jr .pastdmark  
3aa0 ..			.dmark: db "A?2"  
3aa3 f1			.pastdmark: pop af  
3aa4			endm  
# End of macro DMARK
3aa4				CALLMONITOR 
3aa4 cd 6f ee			call debug_vector  
3aa7				endm  
# End of macro CALLMONITOR
3aa7			endif	 
3aa7 26 00				ld h, 0 
3aa9 69					ld l, c 
3aaa cd 79 1b				call forth_push_numhl 
3aad 68					ld l, b  
3aae cd 79 1b				call forth_push_numhl 
3ab1			 
3ab1			 
3ab1				NEXTW 
3ab1 c3 34 1f			jp macro_next 
3ab4				endm 
# End of macro NEXTW
3ab4			 
3ab4			.FB: 
3ab4				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3ab4 1b				db WORD_SYS_CORE+7             
3ab5 02 3b			dw .EMIT            
3ab7 03				db 2 + 1 
3ab8 .. 00			db "FB",0              
3abb				endm 
# End of macro CWHEAD
3abb			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3abb			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3abb			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3abb			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3abb					if DEBUG_FORTH_WORDS_KEY 
3abb						DMARK "FB." 
3abb f5				push af  
3abc 3a d0 3a			ld a, (.dmark)  
3abf 32 6b ee			ld (debug_mark),a  
3ac2 3a d1 3a			ld a, (.dmark+1)  
3ac5 32 6c ee			ld (debug_mark+1),a  
3ac8 3a d2 3a			ld a, (.dmark+2)  
3acb 32 6d ee			ld (debug_mark+2),a  
3ace 18 03			jr .pastdmark  
3ad0 ..			.dmark: db "FB."  
3ad3 f1			.pastdmark: pop af  
3ad4			endm  
# End of macro DMARK
3ad4						CALLMONITOR 
3ad4 cd 6f ee			call debug_vector  
3ad7				endm  
# End of macro CALLMONITOR
3ad7					endif 
3ad7			 
3ad7					FORTH_DSP_VALUEHL 
3ad7 cd 7e 1d			call macro_dsp_valuehl 
3ada				endm 
# End of macro FORTH_DSP_VALUEHL
3ada			 
3ada 7d					ld a, l 
3adb fe 01				cp 1 
3add 20 05				jr nz, .fbn1 
3adf 21 10 ed				ld hl, display_fb1 
3ae2 18 15				jr .fbset 
3ae4 fe 02		.fbn1:		cp 2 
3ae6 20 05				jr nz, .fbn2 
3ae8 21 ce eb				ld hl, display_fb2 
3aeb 18 0c				jr .fbset 
3aed fe 03		.fbn2:		cp 3 
3aef 20 05				jr nz, .fbn3 
3af1 21 6f ec				ld hl, display_fb3 
3af4 18 03				jr .fbset 
3af6			.fbn3:		 ; if invalid number select first 
3af6 21 10 ed				ld hl, display_fb1 
3af9 22 cc eb		.fbset:		ld (display_fb_active), hl 
3afc			 
3afc					FORTH_DSP_POP 
3afc cd 36 1e			call macro_forth_dsp_pop 
3aff				endm 
# End of macro FORTH_DSP_POP
3aff			 
3aff					NEXTW 
3aff c3 34 1f			jp macro_next 
3b02				endm 
# End of macro NEXTW
3b02			 
3b02			 
3b02			.EMIT: 
3b02				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3b02 1b				db WORD_SYS_CORE+7             
3b03 53 3b			dw .DOTH            
3b05 05				db 4 + 1 
3b06 .. 00			db "EMIT",0              
3b0b				endm 
# End of macro CWHEAD
3b0b			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b0b					; get value off TOS and display it 
3b0b			 
3b0b					if DEBUG_FORTH_WORDS_KEY 
3b0b						DMARK "EMT" 
3b0b f5				push af  
3b0c 3a 20 3b			ld a, (.dmark)  
3b0f 32 6b ee			ld (debug_mark),a  
3b12 3a 21 3b			ld a, (.dmark+1)  
3b15 32 6c ee			ld (debug_mark+1),a  
3b18 3a 22 3b			ld a, (.dmark+2)  
3b1b 32 6d ee			ld (debug_mark+2),a  
3b1e 18 03			jr .pastdmark  
3b20 ..			.dmark: db "EMT"  
3b23 f1			.pastdmark: pop af  
3b24			endm  
# End of macro DMARK
3b24						CALLMONITOR 
3b24 cd 6f ee			call debug_vector  
3b27				endm  
# End of macro CALLMONITOR
3b27					endif 
3b27			 
3b27					FORTH_DSP_VALUEHL 
3b27 cd 7e 1d			call macro_dsp_valuehl 
3b2a				endm 
# End of macro FORTH_DSP_VALUEHL
3b2a			 
3b2a 7d					ld a,l 
3b2b			 
3b2b					; TODO write to display 
3b2b			 
3b2b 32 bf e4				ld (os_input), a 
3b2e 3e 00				ld a, 0 
3b30 32 c0 e4				ld (os_input+1), a 
3b33					 
3b33 3a 5e ea				ld a, (f_cursor_ptr) 
3b36 11 bf e4				ld de, os_input 
3b39 cd d8 0b				call str_at_display 
3b3c			 
3b3c			 
3b3c 3a 3c ea				ld a,(cli_autodisplay) 
3b3f fe 00				cp 0 
3b41 28 03				jr z, .enoupdate 
3b43 cd e8 0b						call update_display 
3b46					.enoupdate: 
3b46			 
3b46 3a 5e ea				ld a, (f_cursor_ptr) 
3b49 3c					inc a 
3b4a 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3b4d			 
3b4d			 
3b4d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b4d cd 36 1e			call macro_forth_dsp_pop 
3b50				endm 
# End of macro FORTH_DSP_POP
3b50			  
3b50			 
3b50					NEXTW 
3b50 c3 34 1f			jp macro_next 
3b53				endm 
# End of macro NEXTW
3b53			.DOTH: 
3b53				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b53 1c				db WORD_SYS_CORE+8             
3b54 83 3b			dw .DOTF            
3b56 03				db 2 + 1 
3b57 .. 00			db ".-",0              
3b5a				endm 
# End of macro CWHEAD
3b5a			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b5a					; get value off TOS and display it 
3b5a					if DEBUG_FORTH_WORDS_KEY 
3b5a						DMARK "DTD" 
3b5a f5				push af  
3b5b 3a 6f 3b			ld a, (.dmark)  
3b5e 32 6b ee			ld (debug_mark),a  
3b61 3a 70 3b			ld a, (.dmark+1)  
3b64 32 6c ee			ld (debug_mark+1),a  
3b67 3a 71 3b			ld a, (.dmark+2)  
3b6a 32 6d ee			ld (debug_mark+2),a  
3b6d 18 03			jr .pastdmark  
3b6f ..			.dmark: db "DTD"  
3b72 f1			.pastdmark: pop af  
3b73			endm  
# End of macro DMARK
3b73						CALLMONITOR 
3b73 cd 6f ee			call debug_vector  
3b76				endm  
# End of macro CALLMONITOR
3b76					endif 
3b76 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3b78 3e 00			ld a, 0 
3b7a 32 3d ea			ld (cli_mvdot), a 
3b7d c3 da 3b			jp .dotgo 
3b80				NEXTW 
3b80 c3 34 1f			jp macro_next 
3b83				endm 
# End of macro NEXTW
3b83			.DOTF: 
3b83				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3b83 1c				db WORD_SYS_CORE+8             
3b84 b1 3b			dw .DOT            
3b86 03				db 2 + 1 
3b87 .. 00			db ".>",0              
3b8a				endm 
# End of macro CWHEAD
3b8a			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
3b8a					; get value off TOS and display it 
3b8a			        ; TODO BUG adds extra spaces 
3b8a			        ; TODO BUG handle numerics? 
3b8a					if DEBUG_FORTH_WORDS_KEY 
3b8a						DMARK "DTC" 
3b8a f5				push af  
3b8b 3a 9f 3b			ld a, (.dmark)  
3b8e 32 6b ee			ld (debug_mark),a  
3b91 3a a0 3b			ld a, (.dmark+1)  
3b94 32 6c ee			ld (debug_mark+1),a  
3b97 3a a1 3b			ld a, (.dmark+2)  
3b9a 32 6d ee			ld (debug_mark+2),a  
3b9d 18 03			jr .pastdmark  
3b9f ..			.dmark: db "DTC"  
3ba2 f1			.pastdmark: pop af  
3ba3			endm  
# End of macro DMARK
3ba3						CALLMONITOR 
3ba3 cd 6f ee			call debug_vector  
3ba6				endm  
# End of macro CALLMONITOR
3ba6					endif 
3ba6 3e 01			ld a, 1 
3ba8 32 3d ea			ld (cli_mvdot), a 
3bab c3 da 3b			jp .dotgo 
3bae				NEXTW 
3bae c3 34 1f			jp macro_next 
3bb1				endm 
# End of macro NEXTW
3bb1			 
3bb1			.DOT: 
3bb1				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3bb1 1c				db WORD_SYS_CORE+8             
3bb2 8d 3d			dw .CLS            
3bb4 02				db 1 + 1 
3bb5 .. 00			db ".",0              
3bb7				endm 
# End of macro CWHEAD
3bb7			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
3bb7					; get value off TOS and display it 
3bb7			 
3bb7					if DEBUG_FORTH_WORDS_KEY 
3bb7						DMARK "DOT" 
3bb7 f5				push af  
3bb8 3a cc 3b			ld a, (.dmark)  
3bbb 32 6b ee			ld (debug_mark),a  
3bbe 3a cd 3b			ld a, (.dmark+1)  
3bc1 32 6c ee			ld (debug_mark+1),a  
3bc4 3a ce 3b			ld a, (.dmark+2)  
3bc7 32 6d ee			ld (debug_mark+2),a  
3bca 18 03			jr .pastdmark  
3bcc ..			.dmark: db "DOT"  
3bcf f1			.pastdmark: pop af  
3bd0			endm  
# End of macro DMARK
3bd0						CALLMONITOR 
3bd0 cd 6f ee			call debug_vector  
3bd3				endm  
# End of macro CALLMONITOR
3bd3					endif 
3bd3 3e 00			ld a, 0 
3bd5 32 3d ea			ld (cli_mvdot), a 
3bd8 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3bda				 
3bda			 
3bda			.dotgo: 
3bda			 
3bda			; move up type to on stack for parserv5 
3bda					FORTH_DSP 
3bda cd 44 1d			call macro_forth_dsp 
3bdd				endm 
# End of macro FORTH_DSP
3bdd				;FORTH_DSP_VALUE  
3bdd			 
3bdd			if DEBUG_FORTH_DOT 
3bdd				DMARK "DOT" 
3bdd f5				push af  
3bde 3a f2 3b			ld a, (.dmark)  
3be1 32 6b ee			ld (debug_mark),a  
3be4 3a f3 3b			ld a, (.dmark+1)  
3be7 32 6c ee			ld (debug_mark+1),a  
3bea 3a f4 3b			ld a, (.dmark+2)  
3bed 32 6d ee			ld (debug_mark+2),a  
3bf0 18 03			jr .pastdmark  
3bf2 ..			.dmark: db "DOT"  
3bf5 f1			.pastdmark: pop af  
3bf6			endm  
# End of macro DMARK
3bf6				CALLMONITOR 
3bf6 cd 6f ee			call debug_vector  
3bf9				endm  
# End of macro CALLMONITOR
3bf9			endif	 
3bf9			;		.print: 
3bf9			 
3bf9 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3bfa 23				inc hl   ; position to the actual value 
3bfb fe 01			cp DS_TYPE_STR 
3bfd 20 06			jr nz, .dotnum1  
3bff			 
3bff			; display string 
3bff				FORTH_DSP_VALUE  
3bff cd 67 1d			call macro_forth_dsp_value 
3c02				endm 
# End of macro FORTH_DSP_VALUE
3c02 eb				ex de,hl 
3c03 18 49			jr .dotwrite 
3c05			 
3c05			.dotnum1: 
3c05 fe 02			cp DS_TYPE_INUM 
3c07 20 44			jr nz, .dotflot 
3c09			 
3c09			 
3c09			; display number 
3c09			 
3c09			;	push hl 
3c09			;	call clear_display 
3c09			;	pop hl 
3c09			 
3c09 5e				ld e, (hl) 
3c0a 23				inc hl 
3c0b 56				ld d, (hl) 
3c0c 21 c1 e2			ld hl, scratch 
3c0f			if DEBUG_FORTH_DOT 
3c0f				DMARK "DT1" 
3c0f f5				push af  
3c10 3a 24 3c			ld a, (.dmark)  
3c13 32 6b ee			ld (debug_mark),a  
3c16 3a 25 3c			ld a, (.dmark+1)  
3c19 32 6c ee			ld (debug_mark+1),a  
3c1c 3a 26 3c			ld a, (.dmark+2)  
3c1f 32 6d ee			ld (debug_mark+2),a  
3c22 18 03			jr .pastdmark  
3c24 ..			.dmark: db "DT1"  
3c27 f1			.pastdmark: pop af  
3c28			endm  
# End of macro DMARK
3c28				CALLMONITOR 
3c28 cd 6f ee			call debug_vector  
3c2b				endm  
# End of macro CALLMONITOR
3c2b			endif	 
3c2b			 
3c2b cd 07 11			call uitoa_16 
3c2e eb				ex de,hl 
3c2f			 
3c2f			if DEBUG_FORTH_DOT 
3c2f				DMARK "DT2" 
3c2f f5				push af  
3c30 3a 44 3c			ld a, (.dmark)  
3c33 32 6b ee			ld (debug_mark),a  
3c36 3a 45 3c			ld a, (.dmark+1)  
3c39 32 6c ee			ld (debug_mark+1),a  
3c3c 3a 46 3c			ld a, (.dmark+2)  
3c3f 32 6d ee			ld (debug_mark+2),a  
3c42 18 03			jr .pastdmark  
3c44 ..			.dmark: db "DT2"  
3c47 f1			.pastdmark: pop af  
3c48			endm  
# End of macro DMARK
3c48				CALLMONITOR 
3c48 cd 6f ee			call debug_vector  
3c4b				endm  
# End of macro CALLMONITOR
3c4b			endif	 
3c4b			 
3c4b			;	ld de, os_word_scratch 
3c4b 18 01			jr .dotwrite 
3c4d			 
3c4d 00			.dotflot:   nop 
3c4e			; TODO print floating point number 
3c4e			 
3c4e			.dotwrite:		 
3c4e			 
3c4e					; if c is set then set all '-' to spaces 
3c4e					; need to also take into account .>  
3c4e			 
3c4e 3e 01				ld a, 1 
3c50 b9					cp c 
3c51 20 67				jr nz, .nodashswap 
3c53			 
3c53					; DE has the string to write, working with HL 
3c53			 
3c53 06 ff				ld b, 255 
3c55 d5					push de 
3c56 e1					pop hl 
3c57			 
3c57			if DEBUG_FORTH_DOT 
3c57				DMARK "DT-" 
3c57 f5				push af  
3c58 3a 6c 3c			ld a, (.dmark)  
3c5b 32 6b ee			ld (debug_mark),a  
3c5e 3a 6d 3c			ld a, (.dmark+1)  
3c61 32 6c ee			ld (debug_mark+1),a  
3c64 3a 6e 3c			ld a, (.dmark+2)  
3c67 32 6d ee			ld (debug_mark+2),a  
3c6a 18 03			jr .pastdmark  
3c6c ..			.dmark: db "DT-"  
3c6f f1			.pastdmark: pop af  
3c70			endm  
# End of macro DMARK
3c70				CALLMONITOR 
3c70 cd 6f ee			call debug_vector  
3c73				endm  
# End of macro CALLMONITOR
3c73			endif	 
3c73 7e			.dashscan:	ld a, (hl) 
3c74 fe 00				cp 0 
3c76 28 42				jr z, .nodashswap 
3c78 fe 2d				cp '-' 
3c7a 20 03				jr nz, .dashskip 
3c7c 3e 20				ld a, ' ' 
3c7e 77					ld (hl), a 
3c7f 23			.dashskip:	inc hl 
3c80			if DEBUG_FORTH_DOT 
3c80				DMARK "D-2" 
3c80 f5				push af  
3c81 3a 95 3c			ld a, (.dmark)  
3c84 32 6b ee			ld (debug_mark),a  
3c87 3a 96 3c			ld a, (.dmark+1)  
3c8a 32 6c ee			ld (debug_mark+1),a  
3c8d 3a 97 3c			ld a, (.dmark+2)  
3c90 32 6d ee			ld (debug_mark+2),a  
3c93 18 03			jr .pastdmark  
3c95 ..			.dmark: db "D-2"  
3c98 f1			.pastdmark: pop af  
3c99			endm  
# End of macro DMARK
3c99				CALLMONITOR 
3c99 cd 6f ee			call debug_vector  
3c9c				endm  
# End of macro CALLMONITOR
3c9c			endif	 
3c9c 10 d5				djnz .dashscan 
3c9e			 
3c9e			if DEBUG_FORTH_DOT 
3c9e				DMARK "D-1" 
3c9e f5				push af  
3c9f 3a b3 3c			ld a, (.dmark)  
3ca2 32 6b ee			ld (debug_mark),a  
3ca5 3a b4 3c			ld a, (.dmark+1)  
3ca8 32 6c ee			ld (debug_mark+1),a  
3cab 3a b5 3c			ld a, (.dmark+2)  
3cae 32 6d ee			ld (debug_mark+2),a  
3cb1 18 03			jr .pastdmark  
3cb3 ..			.dmark: db "D-1"  
3cb6 f1			.pastdmark: pop af  
3cb7			endm  
# End of macro DMARK
3cb7				CALLMONITOR 
3cb7 cd 6f ee			call debug_vector  
3cba				endm  
# End of macro CALLMONITOR
3cba			endif	 
3cba			 
3cba			.nodashswap: 
3cba			 
3cba			if DEBUG_FORTH_DOT 
3cba				DMARK "D-o" 
3cba f5				push af  
3cbb 3a cf 3c			ld a, (.dmark)  
3cbe 32 6b ee			ld (debug_mark),a  
3cc1 3a d0 3c			ld a, (.dmark+1)  
3cc4 32 6c ee			ld (debug_mark+1),a  
3cc7 3a d1 3c			ld a, (.dmark+2)  
3cca 32 6d ee			ld (debug_mark+2),a  
3ccd 18 03			jr .pastdmark  
3ccf ..			.dmark: db "D-o"  
3cd2 f1			.pastdmark: pop af  
3cd3			endm  
# End of macro DMARK
3cd3				CALLMONITOR 
3cd3 cd 6f ee			call debug_vector  
3cd6				endm  
# End of macro CALLMONITOR
3cd6			endif	 
3cd6			 
3cd6 d5					push de   ; save string start in case we need to advance print 
3cd7			 
3cd7 3a 5e ea				ld a, (f_cursor_ptr) 
3cda cd d8 0b				call str_at_display 
3cdd 3a 3c ea				ld a,(cli_autodisplay) 
3ce0 fe 00				cp 0 
3ce2 28 03				jr z, .noupdate 
3ce4 cd e8 0b						call update_display 
3ce7					.noupdate: 
3ce7			 
3ce7			 
3ce7					; see if we need to advance the print position 
3ce7			 
3ce7 e1					pop hl   ; get back string 
3ce8			;		ex de,hl 
3ce8			 
3ce8 3a 3d ea				ld a, (cli_mvdot) 
3ceb			if DEBUG_FORTH_DOT 
3ceb			;		ld e,a 
3ceb				DMARK "D>1" 
3ceb f5				push af  
3cec 3a 00 3d			ld a, (.dmark)  
3cef 32 6b ee			ld (debug_mark),a  
3cf2 3a 01 3d			ld a, (.dmark+1)  
3cf5 32 6c ee			ld (debug_mark+1),a  
3cf8 3a 02 3d			ld a, (.dmark+2)  
3cfb 32 6d ee			ld (debug_mark+2),a  
3cfe 18 03			jr .pastdmark  
3d00 ..			.dmark: db "D>1"  
3d03 f1			.pastdmark: pop af  
3d04			endm  
# End of macro DMARK
3d04				CALLMONITOR 
3d04 cd 6f ee			call debug_vector  
3d07				endm  
# End of macro CALLMONITOR
3d07			endif	 
3d07 fe 00				cp 0 
3d09 28 44				jr z, .noadv 
3d0b					; yes, lets advance the print position 
3d0b 3e 00				ld a, 0 
3d0d cd 63 11				call strlent 
3d10			if DEBUG_FORTH_DOT 
3d10				DMARK "D-?" 
3d10 f5				push af  
3d11 3a 25 3d			ld a, (.dmark)  
3d14 32 6b ee			ld (debug_mark),a  
3d17 3a 26 3d			ld a, (.dmark+1)  
3d1a 32 6c ee			ld (debug_mark+1),a  
3d1d 3a 27 3d			ld a, (.dmark+2)  
3d20 32 6d ee			ld (debug_mark+2),a  
3d23 18 03			jr .pastdmark  
3d25 ..			.dmark: db "D-?"  
3d28 f1			.pastdmark: pop af  
3d29			endm  
# End of macro DMARK
3d29				CALLMONITOR 
3d29 cd 6f ee			call debug_vector  
3d2c				endm  
# End of macro CALLMONITOR
3d2c			endif	 
3d2c 3a 5e ea				ld a, (f_cursor_ptr) 
3d2f 85					add a,l 
3d30					;call addatohl 
3d30					;ld a, l 
3d30 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3d33			 
3d33			if DEBUG_FORTH_DOT 
3d33				DMARK "D->" 
3d33 f5				push af  
3d34 3a 48 3d			ld a, (.dmark)  
3d37 32 6b ee			ld (debug_mark),a  
3d3a 3a 49 3d			ld a, (.dmark+1)  
3d3d 32 6c ee			ld (debug_mark+1),a  
3d40 3a 4a 3d			ld a, (.dmark+2)  
3d43 32 6d ee			ld (debug_mark+2),a  
3d46 18 03			jr .pastdmark  
3d48 ..			.dmark: db "D->"  
3d4b f1			.pastdmark: pop af  
3d4c			endm  
# End of macro DMARK
3d4c				CALLMONITOR 
3d4c cd 6f ee			call debug_vector  
3d4f				endm  
# End of macro CALLMONITOR
3d4f			endif	 
3d4f			 
3d4f			.noadv:	 
3d4f			 
3d4f					if DEBUG_FORTH_DOT_WAIT 
3d4f							call next_page_prompt 
3d4f					endif	 
3d4f			; TODO this pop off the stack causes a crash. i dont know why 
3d4f			 
3d4f			 
3d4f			if DEBUG_FORTH_DOT 
3d4f				DMARK "DTh" 
3d4f f5				push af  
3d50 3a 64 3d			ld a, (.dmark)  
3d53 32 6b ee			ld (debug_mark),a  
3d56 3a 65 3d			ld a, (.dmark+1)  
3d59 32 6c ee			ld (debug_mark+1),a  
3d5c 3a 66 3d			ld a, (.dmark+2)  
3d5f 32 6d ee			ld (debug_mark+2),a  
3d62 18 03			jr .pastdmark  
3d64 ..			.dmark: db "DTh"  
3d67 f1			.pastdmark: pop af  
3d68			endm  
# End of macro DMARK
3d68				CALLMONITOR 
3d68 cd 6f ee			call debug_vector  
3d6b				endm  
# End of macro CALLMONITOR
3d6b			endif	 
3d6b			 
3d6b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d6b cd 36 1e			call macro_forth_dsp_pop 
3d6e				endm 
# End of macro FORTH_DSP_POP
3d6e			 
3d6e			if DEBUG_FORTH_DOT 
3d6e				DMARK "DTi" 
3d6e f5				push af  
3d6f 3a 83 3d			ld a, (.dmark)  
3d72 32 6b ee			ld (debug_mark),a  
3d75 3a 84 3d			ld a, (.dmark+1)  
3d78 32 6c ee			ld (debug_mark+1),a  
3d7b 3a 85 3d			ld a, (.dmark+2)  
3d7e 32 6d ee			ld (debug_mark+2),a  
3d81 18 03			jr .pastdmark  
3d83 ..			.dmark: db "DTi"  
3d86 f1			.pastdmark: pop af  
3d87			endm  
# End of macro DMARK
3d87				CALLMONITOR 
3d87 cd 6f ee			call debug_vector  
3d8a				endm  
# End of macro CALLMONITOR
3d8a			endif	 
3d8a			 
3d8a			 
3d8a					NEXTW 
3d8a c3 34 1f			jp macro_next 
3d8d				endm 
# End of macro NEXTW
3d8d			 
3d8d			.CLS: 
3d8d				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3d8d 35				db WORD_SYS_CORE+33             
3d8e ba 3d			dw .DRAW            
3d90 04				db 3 + 1 
3d91 .. 00			db "CLS",0              
3d95				endm 
# End of macro CWHEAD
3d95			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3d95					if DEBUG_FORTH_WORDS_KEY 
3d95						DMARK "CLS" 
3d95 f5				push af  
3d96 3a aa 3d			ld a, (.dmark)  
3d99 32 6b ee			ld (debug_mark),a  
3d9c 3a ab 3d			ld a, (.dmark+1)  
3d9f 32 6c ee			ld (debug_mark+1),a  
3da2 3a ac 3d			ld a, (.dmark+2)  
3da5 32 6d ee			ld (debug_mark+2),a  
3da8 18 03			jr .pastdmark  
3daa ..			.dmark: db "CLS"  
3dad f1			.pastdmark: pop af  
3dae			endm  
# End of macro DMARK
3dae						CALLMONITOR 
3dae cd 6f ee			call debug_vector  
3db1				endm  
# End of macro CALLMONITOR
3db1					endif 
3db1 cd c5 0b				call clear_display 
3db4 c3 c8 3e				jp .home		; and home cursor 
3db7					NEXTW 
3db7 c3 34 1f			jp macro_next 
3dba				endm 
# End of macro NEXTW
3dba			 
3dba			.DRAW: 
3dba				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3dba 36				db WORD_SYS_CORE+34             
3dbb e5 3d			dw .DUMP            
3dbd 05				db 4 + 1 
3dbe .. 00			db "DRAW",0              
3dc3				endm 
# End of macro CWHEAD
3dc3			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3dc3					if DEBUG_FORTH_WORDS_KEY 
3dc3						DMARK "DRW" 
3dc3 f5				push af  
3dc4 3a d8 3d			ld a, (.dmark)  
3dc7 32 6b ee			ld (debug_mark),a  
3dca 3a d9 3d			ld a, (.dmark+1)  
3dcd 32 6c ee			ld (debug_mark+1),a  
3dd0 3a da 3d			ld a, (.dmark+2)  
3dd3 32 6d ee			ld (debug_mark+2),a  
3dd6 18 03			jr .pastdmark  
3dd8 ..			.dmark: db "DRW"  
3ddb f1			.pastdmark: pop af  
3ddc			endm  
# End of macro DMARK
3ddc						CALLMONITOR 
3ddc cd 6f ee			call debug_vector  
3ddf				endm  
# End of macro CALLMONITOR
3ddf					endif 
3ddf cd e8 0b				call update_display 
3de2					NEXTW 
3de2 c3 34 1f			jp macro_next 
3de5				endm 
# End of macro NEXTW
3de5			 
3de5			.DUMP: 
3de5				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3de5 37				db WORD_SYS_CORE+35             
3de6 1d 3e			dw .CDUMP            
3de8 05				db 4 + 1 
3de9 .. 00			db "DUMP",0              
3dee				endm 
# End of macro CWHEAD
3dee			; | DUMP ( x -- ) With address x display dump   | DONE 
3dee			; TODO pop address to use off of the stack 
3dee					if DEBUG_FORTH_WORDS_KEY 
3dee						DMARK "DUM" 
3dee f5				push af  
3def 3a 03 3e			ld a, (.dmark)  
3df2 32 6b ee			ld (debug_mark),a  
3df5 3a 04 3e			ld a, (.dmark+1)  
3df8 32 6c ee			ld (debug_mark+1),a  
3dfb 3a 05 3e			ld a, (.dmark+2)  
3dfe 32 6d ee			ld (debug_mark+2),a  
3e01 18 03			jr .pastdmark  
3e03 ..			.dmark: db "DUM"  
3e06 f1			.pastdmark: pop af  
3e07			endm  
# End of macro DMARK
3e07						CALLMONITOR 
3e07 cd 6f ee			call debug_vector  
3e0a				endm  
# End of macro CALLMONITOR
3e0a					endif 
3e0a cd c5 0b				call clear_display 
3e0d			 
3e0d					; get address 
3e0d			 
3e0d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e0d cd 7e 1d			call macro_dsp_valuehl 
3e10				endm 
# End of macro FORTH_DSP_VALUEHL
3e10				 
3e10					; save it for cdump 
3e10			 
3e10 22 e4 e5				ld (os_cur_ptr),hl 
3e13			 
3e13					; destroy value TOS 
3e13			 
3e13					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e13 cd 36 1e			call macro_forth_dsp_pop 
3e16				endm 
# End of macro FORTH_DSP_POP
3e16			 
3e16 cd f9 19				call dumpcont	; skip old style of param parsing	 
3e19 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3e1a					NEXTW 
3e1a c3 34 1f			jp macro_next 
3e1d				endm 
# End of macro NEXTW
3e1d			.CDUMP: 
3e1d				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3e1d 38				db WORD_SYS_CORE+36             
3e1e 4d 3e			dw .DAT            
3e20 06				db 5 + 1 
3e21 .. 00			db "CDUMP",0              
3e27				endm 
# End of macro CWHEAD
3e27			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3e27					if DEBUG_FORTH_WORDS_KEY 
3e27						DMARK "CDP" 
3e27 f5				push af  
3e28 3a 3c 3e			ld a, (.dmark)  
3e2b 32 6b ee			ld (debug_mark),a  
3e2e 3a 3d 3e			ld a, (.dmark+1)  
3e31 32 6c ee			ld (debug_mark+1),a  
3e34 3a 3e 3e			ld a, (.dmark+2)  
3e37 32 6d ee			ld (debug_mark+2),a  
3e3a 18 03			jr .pastdmark  
3e3c ..			.dmark: db "CDP"  
3e3f f1			.pastdmark: pop af  
3e40			endm  
# End of macro DMARK
3e40						CALLMONITOR 
3e40 cd 6f ee			call debug_vector  
3e43				endm  
# End of macro CALLMONITOR
3e43					endif 
3e43 cd c5 0b				call clear_display 
3e46 cd f9 19				call dumpcont	 
3e49 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3e4a					NEXTW 
3e4a c3 34 1f			jp macro_next 
3e4d				endm 
# End of macro NEXTW
3e4d			 
3e4d			 
3e4d			 
3e4d			 
3e4d			.DAT: 
3e4d				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3e4d 3d				db WORD_SYS_CORE+41             
3e4e a3 3e			dw .HOME            
3e50 03				db 2 + 1 
3e51 .. 00			db "AT",0              
3e54				endm 
# End of macro CWHEAD
3e54			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3e54					if DEBUG_FORTH_WORDS_KEY 
3e54						DMARK "AT." 
3e54 f5				push af  
3e55 3a 69 3e			ld a, (.dmark)  
3e58 32 6b ee			ld (debug_mark),a  
3e5b 3a 6a 3e			ld a, (.dmark+1)  
3e5e 32 6c ee			ld (debug_mark+1),a  
3e61 3a 6b 3e			ld a, (.dmark+2)  
3e64 32 6d ee			ld (debug_mark+2),a  
3e67 18 03			jr .pastdmark  
3e69 ..			.dmark: db "AT."  
3e6c f1			.pastdmark: pop af  
3e6d			endm  
# End of macro DMARK
3e6d						CALLMONITOR 
3e6d cd 6f ee			call debug_vector  
3e70				endm  
# End of macro CALLMONITOR
3e70					endif 
3e70					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e70 cd 7e 1d			call macro_dsp_valuehl 
3e73				endm 
# End of macro FORTH_DSP_VALUEHL
3e73			 
3e73			 
3e73					; TODO save cursor row 
3e73 7d					ld a,l 
3e74 fe 02				cp 2 
3e76 20 04				jr nz, .crow3 
3e78 3e 28				ld a, display_row_2 
3e7a 18 12				jr .ccol1 
3e7c fe 03		.crow3:		cp 3 
3e7e 20 04				jr nz, .crow4 
3e80 3e 50				ld a, display_row_3 
3e82 18 0a				jr .ccol1 
3e84 fe 04		.crow4:		cp 4 
3e86 20 04				jr nz, .crow1 
3e88 3e 78				ld a, display_row_4 
3e8a 18 02				jr .ccol1 
3e8c 3e 00		.crow1:		ld a,display_row_1 
3e8e f5			.ccol1:		push af			; got row offset 
3e8f 6f					ld l,a 
3e90 26 00				ld h,0 
3e92					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e92 cd 36 1e			call macro_forth_dsp_pop 
3e95				endm 
# End of macro FORTH_DSP_POP
3e95					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e95 cd 7e 1d			call macro_dsp_valuehl 
3e98				endm 
# End of macro FORTH_DSP_VALUEHL
3e98					; TODO save cursor col 
3e98 f1					pop af 
3e99 85					add l		; add col offset 
3e9a 32 5e ea				ld (f_cursor_ptr), a 
3e9d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e9d cd 36 1e			call macro_forth_dsp_pop 
3ea0				endm 
# End of macro FORTH_DSP_POP
3ea0			 
3ea0					; calculate  
3ea0			 
3ea0					NEXTW 
3ea0 c3 34 1f			jp macro_next 
3ea3				endm 
# End of macro NEXTW
3ea3			 
3ea3			 
3ea3			.HOME: 
3ea3				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
3ea3 41				db WORD_SYS_CORE+45             
3ea4 d0 3e			dw .CR            
3ea6 05				db 4 + 1 
3ea7 .. 00			db "HOME",0              
3eac				endm 
# End of macro CWHEAD
3eac			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3eac					if DEBUG_FORTH_WORDS_KEY 
3eac						DMARK "HOM" 
3eac f5				push af  
3ead 3a c1 3e			ld a, (.dmark)  
3eb0 32 6b ee			ld (debug_mark),a  
3eb3 3a c2 3e			ld a, (.dmark+1)  
3eb6 32 6c ee			ld (debug_mark+1),a  
3eb9 3a c3 3e			ld a, (.dmark+2)  
3ebc 32 6d ee			ld (debug_mark+2),a  
3ebf 18 03			jr .pastdmark  
3ec1 ..			.dmark: db "HOM"  
3ec4 f1			.pastdmark: pop af  
3ec5			endm  
# End of macro DMARK
3ec5						CALLMONITOR 
3ec5 cd 6f ee			call debug_vector  
3ec8				endm  
# End of macro CALLMONITOR
3ec8					endif 
3ec8 3e 00		.home:		ld a, 0		; and home cursor 
3eca 32 5e ea				ld (f_cursor_ptr), a 
3ecd					NEXTW 
3ecd c3 34 1f			jp macro_next 
3ed0				endm 
# End of macro NEXTW
3ed0			 
3ed0			 
3ed0			.CR: 
3ed0				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
3ed0 46				db WORD_SYS_CORE+50             
3ed1 0b 3f			dw .SPACE            
3ed3 03				db 2 + 1 
3ed4 .. 00			db "CR",0              
3ed7				endm 
# End of macro CWHEAD
3ed7			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
3ed7					if DEBUG_FORTH_WORDS_KEY 
3ed7						DMARK "CR." 
3ed7 f5				push af  
3ed8 3a ec 3e			ld a, (.dmark)  
3edb 32 6b ee			ld (debug_mark),a  
3ede 3a ed 3e			ld a, (.dmark+1)  
3ee1 32 6c ee			ld (debug_mark+1),a  
3ee4 3a ee 3e			ld a, (.dmark+2)  
3ee7 32 6d ee			ld (debug_mark+2),a  
3eea 18 03			jr .pastdmark  
3eec ..			.dmark: db "CR."  
3eef f1			.pastdmark: pop af  
3ef0			endm  
# End of macro DMARK
3ef0						CALLMONITOR 
3ef0 cd 6f ee			call debug_vector  
3ef3				endm  
# End of macro CALLMONITOR
3ef3					endif 
3ef3 3e 0d				ld a, 13 
3ef5 32 c1 e2				ld (scratch),a 
3ef8 3e 0a				ld a, 10 
3efa 32 c2 e2				ld (scratch+1),a 
3efd 3e 00				ld a, 0 
3eff 32 c3 e2				ld (scratch+2),a 
3f02 21 c1 e2				ld hl, scratch 
3f05 cd e7 1b				call forth_push_str 
3f08					 
3f08				       NEXTW 
3f08 c3 34 1f			jp macro_next 
3f0b				endm 
# End of macro NEXTW
3f0b			.SPACE: 
3f0b				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3f0b 46				db WORD_SYS_CORE+50             
3f0c 41 3f			dw .SPACES            
3f0e 03				db 2 + 1 
3f0f .. 00			db "BL",0              
3f12				endm 
# End of macro CWHEAD
3f12			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3f12					if DEBUG_FORTH_WORDS_KEY 
3f12						DMARK "BL." 
3f12 f5				push af  
3f13 3a 27 3f			ld a, (.dmark)  
3f16 32 6b ee			ld (debug_mark),a  
3f19 3a 28 3f			ld a, (.dmark+1)  
3f1c 32 6c ee			ld (debug_mark+1),a  
3f1f 3a 29 3f			ld a, (.dmark+2)  
3f22 32 6d ee			ld (debug_mark+2),a  
3f25 18 03			jr .pastdmark  
3f27 ..			.dmark: db "BL."  
3f2a f1			.pastdmark: pop af  
3f2b			endm  
# End of macro DMARK
3f2b						CALLMONITOR 
3f2b cd 6f ee			call debug_vector  
3f2e				endm  
# End of macro CALLMONITOR
3f2e					endif 
3f2e 3e 20				ld a, " " 
3f30 32 c1 e2				ld (scratch),a 
3f33 3e 00				ld a, 0 
3f35 32 c2 e2				ld (scratch+1),a 
3f38 21 c1 e2				ld hl, scratch 
3f3b cd e7 1b				call forth_push_str 
3f3e					 
3f3e				       NEXTW 
3f3e c3 34 1f			jp macro_next 
3f41				endm 
# End of macro NEXTW
3f41			 
3f41			;.blstr: db " ", 0 
3f41			 
3f41			.SPACES: 
3f41				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3f41 47				db WORD_SYS_CORE+51             
3f42 dc 3f			dw .SCROLL            
3f44 07				db 6 + 1 
3f45 .. 00			db "SPACES",0              
3f4c				endm 
# End of macro CWHEAD
3f4c			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
3f4c					if DEBUG_FORTH_WORDS_KEY 
3f4c						DMARK "SPS" 
3f4c f5				push af  
3f4d 3a 61 3f			ld a, (.dmark)  
3f50 32 6b ee			ld (debug_mark),a  
3f53 3a 62 3f			ld a, (.dmark+1)  
3f56 32 6c ee			ld (debug_mark+1),a  
3f59 3a 63 3f			ld a, (.dmark+2)  
3f5c 32 6d ee			ld (debug_mark+2),a  
3f5f 18 03			jr .pastdmark  
3f61 ..			.dmark: db "SPS"  
3f64 f1			.pastdmark: pop af  
3f65			endm  
# End of macro DMARK
3f65						CALLMONITOR 
3f65 cd 6f ee			call debug_vector  
3f68				endm  
# End of macro CALLMONITOR
3f68					endif 
3f68			 
3f68			 
3f68					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f68 cd 7e 1d			call macro_dsp_valuehl 
3f6b				endm 
# End of macro FORTH_DSP_VALUEHL
3f6b			 
3f6b e5					push hl    ; u 
3f6c					if DEBUG_FORTH_WORDS 
3f6c						DMARK "SPA" 
3f6c f5				push af  
3f6d 3a 81 3f			ld a, (.dmark)  
3f70 32 6b ee			ld (debug_mark),a  
3f73 3a 82 3f			ld a, (.dmark+1)  
3f76 32 6c ee			ld (debug_mark+1),a  
3f79 3a 83 3f			ld a, (.dmark+2)  
3f7c 32 6d ee			ld (debug_mark+2),a  
3f7f 18 03			jr .pastdmark  
3f81 ..			.dmark: db "SPA"  
3f84 f1			.pastdmark: pop af  
3f85			endm  
# End of macro DMARK
3f85						CALLMONITOR 
3f85 cd 6f ee			call debug_vector  
3f88				endm  
# End of macro CALLMONITOR
3f88					endif 
3f88			 
3f88					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f88 cd 36 1e			call macro_forth_dsp_pop 
3f8b				endm 
# End of macro FORTH_DSP_POP
3f8b e1					pop hl 
3f8c 0e 00				ld c, 0 
3f8e 45					ld b, l 
3f8f 21 c1 e2				ld hl, scratch  
3f92			 
3f92					if DEBUG_FORTH_WORDS 
3f92						DMARK "SP2" 
3f92 f5				push af  
3f93 3a a7 3f			ld a, (.dmark)  
3f96 32 6b ee			ld (debug_mark),a  
3f99 3a a8 3f			ld a, (.dmark+1)  
3f9c 32 6c ee			ld (debug_mark+1),a  
3f9f 3a a9 3f			ld a, (.dmark+2)  
3fa2 32 6d ee			ld (debug_mark+2),a  
3fa5 18 03			jr .pastdmark  
3fa7 ..			.dmark: db "SP2"  
3faa f1			.pastdmark: pop af  
3fab			endm  
# End of macro DMARK
3fab						CALLMONITOR 
3fab cd 6f ee			call debug_vector  
3fae				endm  
# End of macro CALLMONITOR
3fae					endif 
3fae 3e 20				ld a, ' ' 
3fb0			.spaces1:	 
3fb0 77					ld (hl),a 
3fb1 23					inc hl 
3fb2					 
3fb2 10 fc				djnz .spaces1 
3fb4 3e 00				ld a,0 
3fb6 77					ld (hl),a 
3fb7 21 c1 e2				ld hl, scratch 
3fba					if DEBUG_FORTH_WORDS 
3fba						DMARK "SP3" 
3fba f5				push af  
3fbb 3a cf 3f			ld a, (.dmark)  
3fbe 32 6b ee			ld (debug_mark),a  
3fc1 3a d0 3f			ld a, (.dmark+1)  
3fc4 32 6c ee			ld (debug_mark+1),a  
3fc7 3a d1 3f			ld a, (.dmark+2)  
3fca 32 6d ee			ld (debug_mark+2),a  
3fcd 18 03			jr .pastdmark  
3fcf ..			.dmark: db "SP3"  
3fd2 f1			.pastdmark: pop af  
3fd3			endm  
# End of macro DMARK
3fd3						CALLMONITOR 
3fd3 cd 6f ee			call debug_vector  
3fd6				endm  
# End of macro CALLMONITOR
3fd6					endif 
3fd6 cd e7 1b				call forth_push_str 
3fd9			 
3fd9				       NEXTW 
3fd9 c3 34 1f			jp macro_next 
3fdc				endm 
# End of macro NEXTW
3fdc			 
3fdc			 
3fdc			 
3fdc			.SCROLL: 
3fdc				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3fdc 53				db WORD_SYS_CORE+63             
3fdd 09 40			dw .SCROLLD            
3fdf 07				db 6 + 1 
3fe0 .. 00			db "SCROLL",0              
3fe7				endm 
# End of macro CWHEAD
3fe7			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3fe7					if DEBUG_FORTH_WORDS_KEY 
3fe7						DMARK "SCR" 
3fe7 f5				push af  
3fe8 3a fc 3f			ld a, (.dmark)  
3feb 32 6b ee			ld (debug_mark),a  
3fee 3a fd 3f			ld a, (.dmark+1)  
3ff1 32 6c ee			ld (debug_mark+1),a  
3ff4 3a fe 3f			ld a, (.dmark+2)  
3ff7 32 6d ee			ld (debug_mark+2),a  
3ffa 18 03			jr .pastdmark  
3ffc ..			.dmark: db "SCR"  
3fff f1			.pastdmark: pop af  
4000			endm  
# End of macro DMARK
4000						CALLMONITOR 
4000 cd 6f ee			call debug_vector  
4003				endm  
# End of macro CALLMONITOR
4003					endif 
4003			 
4003 cd 87 0b			call scroll_up 
4006			;	call update_display 
4006			 
4006					NEXTW 
4006 c3 34 1f			jp macro_next 
4009				endm 
# End of macro NEXTW
4009			 
4009			 
4009			 
4009			;		; get dir 
4009			; 
4009			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4009			; 
4009			;		push hl 
4009			; 
4009			;		; destroy value TOS 
4009			; 
4009			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4009			; 
4009			;		; get count 
4009			; 
4009			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4009			; 
4009			;		push hl 
4009			; 
4009			;		; destroy value TOS 
4009			; 
4009			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4009			; 
4009			;		; one value on hl get other one back 
4009			; 
4009			;		pop bc    ; count 
4009			; 
4009			;		pop de   ; dir 
4009			; 
4009			; 
4009			;		ld b, c 
4009			; 
4009			;.scrolldir:     push bc 
4009			;		push de 
4009			; 
4009			;		ld a, 0 
4009			;		cp e 
4009			;		jr z, .scrollup  
4009			;		call scroll_down 
4009			;		jr .scrollnext 
4009			;.scrollup:	call scroll_up 
4009			; 
4009			;		 
4009			;.scrollnext: 
4009			;		pop de 
4009			;		pop bc 
4009			;		djnz .scrolldir 
4009			; 
4009			; 
4009			; 
4009			; 
4009			; 
4009			;		NEXTW 
4009			 
4009			.SCROLLD: 
4009				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4009 53				db WORD_SYS_CORE+63             
400a 37 40			dw .ATQ            
400c 08				db 7 + 1 
400d .. 00			db "SCROLLD",0              
4015				endm 
# End of macro CWHEAD
4015			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4015					if DEBUG_FORTH_WORDS_KEY 
4015						DMARK "SCD" 
4015 f5				push af  
4016 3a 2a 40			ld a, (.dmark)  
4019 32 6b ee			ld (debug_mark),a  
401c 3a 2b 40			ld a, (.dmark+1)  
401f 32 6c ee			ld (debug_mark+1),a  
4022 3a 2c 40			ld a, (.dmark+2)  
4025 32 6d ee			ld (debug_mark+2),a  
4028 18 03			jr .pastdmark  
402a ..			.dmark: db "SCD"  
402d f1			.pastdmark: pop af  
402e			endm  
# End of macro DMARK
402e						CALLMONITOR 
402e cd 6f ee			call debug_vector  
4031				endm  
# End of macro CALLMONITOR
4031					endif 
4031			 
4031 cd ab 0b			call scroll_down 
4034			;	call update_display 
4034			 
4034					NEXTW 
4034 c3 34 1f			jp macro_next 
4037				endm 
# End of macro NEXTW
4037			 
4037			 
4037			.ATQ: 
4037				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4037 62				db WORD_SYS_CORE+78             
4038 95 40			dw .AUTODSP            
403a 04				db 3 + 1 
403b .. 00			db "AT@",0              
403f				endm 
# End of macro CWHEAD
403f			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
403f					if DEBUG_FORTH_WORDS_KEY 
403f						DMARK "ATA" 
403f f5				push af  
4040 3a 54 40			ld a, (.dmark)  
4043 32 6b ee			ld (debug_mark),a  
4046 3a 55 40			ld a, (.dmark+1)  
4049 32 6c ee			ld (debug_mark+1),a  
404c 3a 56 40			ld a, (.dmark+2)  
404f 32 6d ee			ld (debug_mark+2),a  
4052 18 03			jr .pastdmark  
4054 ..			.dmark: db "ATA"  
4057 f1			.pastdmark: pop af  
4058			endm  
# End of macro DMARK
4058						CALLMONITOR 
4058 cd 6f ee			call debug_vector  
405b				endm  
# End of macro CALLMONITOR
405b					endif 
405b			 
405b			 
405b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
405b cd 7e 1d			call macro_dsp_valuehl 
405e				endm 
# End of macro FORTH_DSP_VALUEHL
405e			 
405e					; TODO save cursor row 
405e 7d					ld a,l 
405f fe 02				cp 2 
4061 20 04				jr nz, .crow3aq 
4063 3e 28				ld a, display_row_2 
4065 18 12				jr .ccol1aq 
4067 fe 03		.crow3aq:		cp 3 
4069 20 04				jr nz, .crow4aq 
406b 3e 50				ld a, display_row_3 
406d 18 0a				jr .ccol1aq 
406f fe 04		.crow4aq:		cp 4 
4071 20 04				jr nz, .crow1aq 
4073 3e 78				ld a, display_row_4 
4075 18 02				jr .ccol1aq 
4077 3e 00		.crow1aq:		ld a,display_row_1 
4079 f5			.ccol1aq:		push af			; got row offset 
407a 6f					ld l,a 
407b 26 00				ld h,0 
407d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
407d cd 36 1e			call macro_forth_dsp_pop 
4080				endm 
# End of macro FORTH_DSP_POP
4080					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4080 cd 7e 1d			call macro_dsp_valuehl 
4083				endm 
# End of macro FORTH_DSP_VALUEHL
4083					; TODO save cursor col 
4083 f1					pop af 
4084 85					add l		; add col offset 
4085			 
4085					; add current frame buffer address 
4085 2a cc eb				ld hl, (display_fb_active) 
4088 cd f2 0d				call addatohl 
408b			 
408b			 
408b			 
408b			 
408b					; get char frame buffer location offset in hl 
408b			 
408b 7e					ld a,(hl) 
408c 26 00				ld h, 0 
408e 6f					ld l, a 
408f			 
408f cd 79 1b				call forth_push_numhl 
4092			 
4092			 
4092					NEXTW 
4092 c3 34 1f			jp macro_next 
4095				endm 
# End of macro NEXTW
4095			 
4095			.AUTODSP: 
4095				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4095 63				db WORD_SYS_CORE+79             
4096 ab 40			dw .MENU            
4098 05				db 4 + 1 
4099 .. 00			db "ADSP",0              
409e				endm 
# End of macro CWHEAD
409e			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
409e			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
409e			 
409e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
409e cd 7e 1d			call macro_dsp_valuehl 
40a1				endm 
# End of macro FORTH_DSP_VALUEHL
40a1			 
40a1			;		push hl 
40a1			 
40a1					; destroy value TOS 
40a1			 
40a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40a1 cd 36 1e			call macro_forth_dsp_pop 
40a4				endm 
# End of macro FORTH_DSP_POP
40a4			 
40a4			;		pop hl 
40a4			 
40a4 7d					ld a,l 
40a5 32 3c ea				ld (cli_autodisplay), a 
40a8				       NEXTW 
40a8 c3 34 1f			jp macro_next 
40ab				endm 
# End of macro NEXTW
40ab			 
40ab			.MENU: 
40ab				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
40ab 70				db WORD_SYS_CORE+92             
40ac 54 41			dw .ENDDISPLAY            
40ae 05				db 4 + 1 
40af .. 00			db "MENU",0              
40b4				endm 
# End of macro CWHEAD
40b4			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
40b4			 
40b4			;		; get number of items on the stack 
40b4			; 
40b4				 
40b4					FORTH_DSP_VALUEHL 
40b4 cd 7e 1d			call macro_dsp_valuehl 
40b7				endm 
# End of macro FORTH_DSP_VALUEHL
40b7				 
40b7					if DEBUG_FORTH_WORDS_KEY 
40b7						DMARK "MNU" 
40b7 f5				push af  
40b8 3a cc 40			ld a, (.dmark)  
40bb 32 6b ee			ld (debug_mark),a  
40be 3a cd 40			ld a, (.dmark+1)  
40c1 32 6c ee			ld (debug_mark+1),a  
40c4 3a ce 40			ld a, (.dmark+2)  
40c7 32 6d ee			ld (debug_mark+2),a  
40ca 18 03			jr .pastdmark  
40cc ..			.dmark: db "MNU"  
40cf f1			.pastdmark: pop af  
40d0			endm  
# End of macro DMARK
40d0						CALLMONITOR 
40d0 cd 6f ee			call debug_vector  
40d3				endm  
# End of macro CALLMONITOR
40d3					endif 
40d3			 
40d3 45					ld b, l	 
40d4 05					dec b 
40d5			 
40d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40d5 cd 36 1e			call macro_forth_dsp_pop 
40d8				endm 
# End of macro FORTH_DSP_POP
40d8			 
40d8			 
40d8					; go directly through the stack to pluck out the string pointers and build an array 
40d8			 
40d8			;		FORTH_DSP 
40d8			 
40d8					; hl contains top most stack item 
40d8				 
40d8 11 c1 e2				ld de, scratch 
40db			 
40db			.mbuild: 
40db			 
40db					FORTH_DSP_VALUEHL 
40db cd 7e 1d			call macro_dsp_valuehl 
40de				endm 
# End of macro FORTH_DSP_VALUEHL
40de			 
40de					if DEBUG_FORTH_WORDS 
40de						DMARK "MN3" 
40de f5				push af  
40df 3a f3 40			ld a, (.dmark)  
40e2 32 6b ee			ld (debug_mark),a  
40e5 3a f4 40			ld a, (.dmark+1)  
40e8 32 6c ee			ld (debug_mark+1),a  
40eb 3a f5 40			ld a, (.dmark+2)  
40ee 32 6d ee			ld (debug_mark+2),a  
40f1 18 03			jr .pastdmark  
40f3 ..			.dmark: db "MN3"  
40f6 f1			.pastdmark: pop af  
40f7			endm  
# End of macro DMARK
40f7						CALLMONITOR 
40f7 cd 6f ee			call debug_vector  
40fa				endm  
# End of macro CALLMONITOR
40fa					endif 
40fa eb					ex de, hl 
40fb 73					ld (hl), e 
40fc 23					inc hl 
40fd 72					ld (hl), d 
40fe 23					inc hl 
40ff eb					ex de, hl 
4100			 
4100					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4100 cd 36 1e			call macro_forth_dsp_pop 
4103				endm 
# End of macro FORTH_DSP_POP
4103			 
4103 10 d6				djnz .mbuild 
4105			 
4105					; done add term 
4105			 
4105 eb					ex de, hl 
4106 36 00				ld (hl), 0 
4108 23					inc hl 
4109 36 00				ld (hl), 0 
410b			 
410b				 
410b					 
410b 21 c1 e2				ld hl, scratch 
410e			 
410e					if DEBUG_FORTH_WORDS 
410e						DMARK "MNx" 
410e f5				push af  
410f 3a 23 41			ld a, (.dmark)  
4112 32 6b ee			ld (debug_mark),a  
4115 3a 24 41			ld a, (.dmark+1)  
4118 32 6c ee			ld (debug_mark+1),a  
411b 3a 25 41			ld a, (.dmark+2)  
411e 32 6d ee			ld (debug_mark+2),a  
4121 18 03			jr .pastdmark  
4123 ..			.dmark: db "MNx"  
4126 f1			.pastdmark: pop af  
4127			endm  
# End of macro DMARK
4127						CALLMONITOR 
4127 cd 6f ee			call debug_vector  
412a				endm  
# End of macro CALLMONITOR
412a					endif 
412a			 
412a			 
412a			 
412a 3e 00				ld a, 0 
412c cd f6 0b				call menu 
412f			 
412f			 
412f 6f					ld l, a 
4130 26 00				ld h, 0 
4132			 
4132					if DEBUG_FORTH_WORDS 
4132						DMARK "MNr" 
4132 f5				push af  
4133 3a 47 41			ld a, (.dmark)  
4136 32 6b ee			ld (debug_mark),a  
4139 3a 48 41			ld a, (.dmark+1)  
413c 32 6c ee			ld (debug_mark+1),a  
413f 3a 49 41			ld a, (.dmark+2)  
4142 32 6d ee			ld (debug_mark+2),a  
4145 18 03			jr .pastdmark  
4147 ..			.dmark: db "MNr"  
414a f1			.pastdmark: pop af  
414b			endm  
# End of macro DMARK
414b						CALLMONITOR 
414b cd 6f ee			call debug_vector  
414e				endm  
# End of macro CALLMONITOR
414e					endif 
414e			 
414e cd 79 1b				call forth_push_numhl 
4151			 
4151			 
4151			 
4151			 
4151				       NEXTW 
4151 c3 34 1f			jp macro_next 
4154				endm 
# End of macro NEXTW
4154			 
4154			 
4154			.ENDDISPLAY: 
4154			 
4154			; eof 
# End of file forth_words_display.asm
4154			include "forth_words_str.asm" 
4154			 
4154			; | ## String Words 
4154			 
4154			.PTR:   
4154			 
4154				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4154 48				db WORD_SYS_CORE+52             
4155 81 41			dw .STYPE            
4157 04				db 3 + 1 
4158 .. 00			db "PTR",0              
415c				endm 
# End of macro CWHEAD
415c			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
415c			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
415c			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
415c			 
415c					if DEBUG_FORTH_WORDS_KEY 
415c						DMARK "PTR" 
415c f5				push af  
415d 3a 71 41			ld a, (.dmark)  
4160 32 6b ee			ld (debug_mark),a  
4163 3a 72 41			ld a, (.dmark+1)  
4166 32 6c ee			ld (debug_mark+1),a  
4169 3a 73 41			ld a, (.dmark+2)  
416c 32 6d ee			ld (debug_mark+2),a  
416f 18 03			jr .pastdmark  
4171 ..			.dmark: db "PTR"  
4174 f1			.pastdmark: pop af  
4175			endm  
# End of macro DMARK
4175						CALLMONITOR 
4175 cd 6f ee			call debug_vector  
4178				endm  
# End of macro CALLMONITOR
4178					endif 
4178					FORTH_DSP_VALUEHL 
4178 cd 7e 1d			call macro_dsp_valuehl 
417b				endm 
# End of macro FORTH_DSP_VALUEHL
417b cd 79 1b				call forth_push_numhl 
417e			 
417e			 
417e					NEXTW 
417e c3 34 1f			jp macro_next 
4181				endm 
# End of macro NEXTW
4181			.STYPE: 
4181				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4181 48				db WORD_SYS_CORE+52             
4182 d0 41			dw .UPPER            
4184 06				db 5 + 1 
4185 .. 00			db "STYPE",0              
418b				endm 
# End of macro CWHEAD
418b			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
418b					if DEBUG_FORTH_WORDS_KEY 
418b						DMARK "STY" 
418b f5				push af  
418c 3a a0 41			ld a, (.dmark)  
418f 32 6b ee			ld (debug_mark),a  
4192 3a a1 41			ld a, (.dmark+1)  
4195 32 6c ee			ld (debug_mark+1),a  
4198 3a a2 41			ld a, (.dmark+2)  
419b 32 6d ee			ld (debug_mark+2),a  
419e 18 03			jr .pastdmark  
41a0 ..			.dmark: db "STY"  
41a3 f1			.pastdmark: pop af  
41a4			endm  
# End of macro DMARK
41a4						CALLMONITOR 
41a4 cd 6f ee			call debug_vector  
41a7				endm  
# End of macro CALLMONITOR
41a7					endif 
41a7					FORTH_DSP 
41a7 cd 44 1d			call macro_forth_dsp 
41aa				endm 
# End of macro FORTH_DSP
41aa					;v5 FORTH_DSP_VALUE 
41aa			 
41aa 7e					ld a, (hl) 
41ab			 
41ab f5					push af 
41ac			 
41ac			; Dont destroy TOS		FORTH_DSP_POP 
41ac			 
41ac f1					pop af 
41ad			 
41ad fe 01				cp DS_TYPE_STR 
41af 28 09				jr z, .typestr 
41b1			 
41b1 fe 02				cp DS_TYPE_INUM 
41b3 28 0a				jr z, .typeinum 
41b5			 
41b5 21 ce 41				ld hl, .tna 
41b8 18 0a				jr .tpush 
41ba			 
41ba 21 ca 41		.typestr:	ld hl, .tstr 
41bd 18 05				jr .tpush 
41bf 21 cc 41		.typeinum:	ld hl, .tinum 
41c2 18 00				jr .tpush 
41c4			 
41c4			.tpush: 
41c4			 
41c4 cd e7 1b				call forth_push_str 
41c7			 
41c7					NEXTW 
41c7 c3 34 1f			jp macro_next 
41ca				endm 
# End of macro NEXTW
41ca .. 00		.tstr:	db "s",0 
41cc .. 00		.tinum:  db "i",0 
41ce .. 00		.tna:   db "?", 0 
41d0			 
41d0			 
41d0			.UPPER: 
41d0				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
41d0 48				db WORD_SYS_CORE+52             
41d1 0b 42			dw .LOWER            
41d3 06				db 5 + 1 
41d4 .. 00			db "UPPER",0              
41da				endm 
# End of macro CWHEAD
41da			; | UPPER ( s -- s ) Upper case string s  | DONE 
41da					if DEBUG_FORTH_WORDS_KEY 
41da						DMARK "UPR" 
41da f5				push af  
41db 3a ef 41			ld a, (.dmark)  
41de 32 6b ee			ld (debug_mark),a  
41e1 3a f0 41			ld a, (.dmark+1)  
41e4 32 6c ee			ld (debug_mark+1),a  
41e7 3a f1 41			ld a, (.dmark+2)  
41ea 32 6d ee			ld (debug_mark+2),a  
41ed 18 03			jr .pastdmark  
41ef ..			.dmark: db "UPR"  
41f2 f1			.pastdmark: pop af  
41f3			endm  
# End of macro DMARK
41f3						CALLMONITOR 
41f3 cd 6f ee			call debug_vector  
41f6				endm  
# End of macro CALLMONITOR
41f6					endif 
41f6			 
41f6					FORTH_DSP 
41f6 cd 44 1d			call macro_forth_dsp 
41f9				endm 
# End of macro FORTH_DSP
41f9					 
41f9			; TODO check is string type 
41f9			 
41f9					FORTH_DSP_VALUEHL 
41f9 cd 7e 1d			call macro_dsp_valuehl 
41fc				endm 
# End of macro FORTH_DSP_VALUEHL
41fc			; get pointer to string in hl 
41fc			 
41fc 7e			.toup:		ld a, (hl) 
41fd fe 00				cp 0 
41ff 28 07				jr z, .toupdone 
4201			 
4201 cd 67 10				call to_upper 
4204			 
4204 77					ld (hl), a 
4205 23					inc hl 
4206 18 f4				jr .toup 
4208			 
4208					 
4208			 
4208			 
4208			; for each char convert to upper 
4208					 
4208			.toupdone: 
4208			 
4208			 
4208					NEXTW 
4208 c3 34 1f			jp macro_next 
420b				endm 
# End of macro NEXTW
420b			.LOWER: 
420b				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
420b 48				db WORD_SYS_CORE+52             
420c 46 42			dw .TCASE            
420e 06				db 5 + 1 
420f .. 00			db "LOWER",0              
4215				endm 
# End of macro CWHEAD
4215			; | LOWER ( s -- s ) Lower case string s  | DONE 
4215					if DEBUG_FORTH_WORDS_KEY 
4215						DMARK "LWR" 
4215 f5				push af  
4216 3a 2a 42			ld a, (.dmark)  
4219 32 6b ee			ld (debug_mark),a  
421c 3a 2b 42			ld a, (.dmark+1)  
421f 32 6c ee			ld (debug_mark+1),a  
4222 3a 2c 42			ld a, (.dmark+2)  
4225 32 6d ee			ld (debug_mark+2),a  
4228 18 03			jr .pastdmark  
422a ..			.dmark: db "LWR"  
422d f1			.pastdmark: pop af  
422e			endm  
# End of macro DMARK
422e						CALLMONITOR 
422e cd 6f ee			call debug_vector  
4231				endm  
# End of macro CALLMONITOR
4231					endif 
4231			 
4231					FORTH_DSP 
4231 cd 44 1d			call macro_forth_dsp 
4234				endm 
# End of macro FORTH_DSP
4234					 
4234			; TODO check is string type 
4234			 
4234					FORTH_DSP_VALUEHL 
4234 cd 7e 1d			call macro_dsp_valuehl 
4237				endm 
# End of macro FORTH_DSP_VALUEHL
4237			; get pointer to string in hl 
4237			 
4237 7e			.tolow:		ld a, (hl) 
4238 fe 00				cp 0 
423a 28 07				jr z, .tolowdone 
423c			 
423c cd 70 10				call to_lower 
423f			 
423f 77					ld (hl), a 
4240 23					inc hl 
4241 18 f4				jr .tolow 
4243			 
4243					 
4243			 
4243			 
4243			; for each char convert to low 
4243					 
4243			.tolowdone: 
4243					NEXTW 
4243 c3 34 1f			jp macro_next 
4246				endm 
# End of macro NEXTW
4246			.TCASE: 
4246				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4246 48				db WORD_SYS_CORE+52             
4247 7c 43			dw .SUBSTR            
4249 06				db 5 + 1 
424a .. 00			db "TCASE",0              
4250				endm 
# End of macro CWHEAD
4250			; | TCASE ( s -- s ) Title case string s  | DONE 
4250					if DEBUG_FORTH_WORDS_KEY 
4250						DMARK "TCS" 
4250 f5				push af  
4251 3a 65 42			ld a, (.dmark)  
4254 32 6b ee			ld (debug_mark),a  
4257 3a 66 42			ld a, (.dmark+1)  
425a 32 6c ee			ld (debug_mark+1),a  
425d 3a 67 42			ld a, (.dmark+2)  
4260 32 6d ee			ld (debug_mark+2),a  
4263 18 03			jr .pastdmark  
4265 ..			.dmark: db "TCS"  
4268 f1			.pastdmark: pop af  
4269			endm  
# End of macro DMARK
4269						CALLMONITOR 
4269 cd 6f ee			call debug_vector  
426c				endm  
# End of macro CALLMONITOR
426c					endif 
426c			 
426c					FORTH_DSP 
426c cd 44 1d			call macro_forth_dsp 
426f				endm 
# End of macro FORTH_DSP
426f					 
426f			; TODO check is string type 
426f			 
426f					FORTH_DSP_VALUEHL 
426f cd 7e 1d			call macro_dsp_valuehl 
4272				endm 
# End of macro FORTH_DSP_VALUEHL
4272			; get pointer to string in hl 
4272			 
4272					if DEBUG_FORTH_WORDS 
4272						DMARK "TC1" 
4272 f5				push af  
4273 3a 87 42			ld a, (.dmark)  
4276 32 6b ee			ld (debug_mark),a  
4279 3a 88 42			ld a, (.dmark+1)  
427c 32 6c ee			ld (debug_mark+1),a  
427f 3a 89 42			ld a, (.dmark+2)  
4282 32 6d ee			ld (debug_mark+2),a  
4285 18 03			jr .pastdmark  
4287 ..			.dmark: db "TC1"  
428a f1			.pastdmark: pop af  
428b			endm  
# End of macro DMARK
428b						CALLMONITOR 
428b cd 6f ee			call debug_vector  
428e				endm  
# End of macro CALLMONITOR
428e					endif 
428e			 
428e					; first time in turn to upper case first char 
428e			 
428e 7e					ld a, (hl) 
428f c3 19 43				jp .totsiptou 
4292			 
4292			 
4292 7e			.tot:		ld a, (hl) 
4293 fe 00				cp 0 
4295 ca 5d 43				jp z, .totdone 
4298			 
4298					if DEBUG_FORTH_WORDS 
4298						DMARK "TC2" 
4298 f5				push af  
4299 3a ad 42			ld a, (.dmark)  
429c 32 6b ee			ld (debug_mark),a  
429f 3a ae 42			ld a, (.dmark+1)  
42a2 32 6c ee			ld (debug_mark+1),a  
42a5 3a af 42			ld a, (.dmark+2)  
42a8 32 6d ee			ld (debug_mark+2),a  
42ab 18 03			jr .pastdmark  
42ad ..			.dmark: db "TC2"  
42b0 f1			.pastdmark: pop af  
42b1			endm  
# End of macro DMARK
42b1						CALLMONITOR 
42b1 cd 6f ee			call debug_vector  
42b4				endm  
# End of macro CALLMONITOR
42b4					endif 
42b4					; check to see if current char is a space 
42b4			 
42b4 fe 20				cp ' ' 
42b6 28 21				jr z, .totsp 
42b8 cd 70 10				call to_lower 
42bb					if DEBUG_FORTH_WORDS 
42bb						DMARK "TC3" 
42bb f5				push af  
42bc 3a d0 42			ld a, (.dmark)  
42bf 32 6b ee			ld (debug_mark),a  
42c2 3a d1 42			ld a, (.dmark+1)  
42c5 32 6c ee			ld (debug_mark+1),a  
42c8 3a d2 42			ld a, (.dmark+2)  
42cb 32 6d ee			ld (debug_mark+2),a  
42ce 18 03			jr .pastdmark  
42d0 ..			.dmark: db "TC3"  
42d3 f1			.pastdmark: pop af  
42d4			endm  
# End of macro DMARK
42d4						CALLMONITOR 
42d4 cd 6f ee			call debug_vector  
42d7				endm  
# End of macro CALLMONITOR
42d7					endif 
42d7 18 63				jr .totnxt 
42d9			 
42d9			.totsp:         ; on a space, find next char which should be upper 
42d9			 
42d9					if DEBUG_FORTH_WORDS 
42d9						DMARK "TC4" 
42d9 f5				push af  
42da 3a ee 42			ld a, (.dmark)  
42dd 32 6b ee			ld (debug_mark),a  
42e0 3a ef 42			ld a, (.dmark+1)  
42e3 32 6c ee			ld (debug_mark+1),a  
42e6 3a f0 42			ld a, (.dmark+2)  
42e9 32 6d ee			ld (debug_mark+2),a  
42ec 18 03			jr .pastdmark  
42ee ..			.dmark: db "TC4"  
42f1 f1			.pastdmark: pop af  
42f2			endm  
# End of macro DMARK
42f2						CALLMONITOR 
42f2 cd 6f ee			call debug_vector  
42f5				endm  
# End of macro CALLMONITOR
42f5					endif 
42f5					;; 
42f5			 
42f5 fe 20				cp ' ' 
42f7 20 20				jr nz, .totsiptou 
42f9 23					inc hl 
42fa 7e					ld a, (hl) 
42fb					if DEBUG_FORTH_WORDS 
42fb						DMARK "TC5" 
42fb f5				push af  
42fc 3a 10 43			ld a, (.dmark)  
42ff 32 6b ee			ld (debug_mark),a  
4302 3a 11 43			ld a, (.dmark+1)  
4305 32 6c ee			ld (debug_mark+1),a  
4308 3a 12 43			ld a, (.dmark+2)  
430b 32 6d ee			ld (debug_mark+2),a  
430e 18 03			jr .pastdmark  
4310 ..			.dmark: db "TC5"  
4313 f1			.pastdmark: pop af  
4314			endm  
# End of macro DMARK
4314						CALLMONITOR 
4314 cd 6f ee			call debug_vector  
4317				endm  
# End of macro CALLMONITOR
4317					endif 
4317 18 c0				jr .totsp 
4319 fe 00		.totsiptou:    cp 0 
431b 28 40				jr z, .totdone 
431d					; not space and not zero term so upper case it 
431d cd 67 10				call to_upper 
4320			 
4320					if DEBUG_FORTH_WORDS 
4320						DMARK "TC6" 
4320 f5				push af  
4321 3a 35 43			ld a, (.dmark)  
4324 32 6b ee			ld (debug_mark),a  
4327 3a 36 43			ld a, (.dmark+1)  
432a 32 6c ee			ld (debug_mark+1),a  
432d 3a 37 43			ld a, (.dmark+2)  
4330 32 6d ee			ld (debug_mark+2),a  
4333 18 03			jr .pastdmark  
4335 ..			.dmark: db "TC6"  
4338 f1			.pastdmark: pop af  
4339			endm  
# End of macro DMARK
4339						CALLMONITOR 
4339 cd 6f ee			call debug_vector  
433c				endm  
# End of macro CALLMONITOR
433c					endif 
433c			 
433c			 
433c			.totnxt: 
433c			 
433c 77					ld (hl), a 
433d 23					inc hl 
433e					if DEBUG_FORTH_WORDS 
433e						DMARK "TC7" 
433e f5				push af  
433f 3a 53 43			ld a, (.dmark)  
4342 32 6b ee			ld (debug_mark),a  
4345 3a 54 43			ld a, (.dmark+1)  
4348 32 6c ee			ld (debug_mark+1),a  
434b 3a 55 43			ld a, (.dmark+2)  
434e 32 6d ee			ld (debug_mark+2),a  
4351 18 03			jr .pastdmark  
4353 ..			.dmark: db "TC7"  
4356 f1			.pastdmark: pop af  
4357			endm  
# End of macro DMARK
4357						CALLMONITOR 
4357 cd 6f ee			call debug_vector  
435a				endm  
# End of macro CALLMONITOR
435a					endif 
435a c3 92 42				jp .tot 
435d			 
435d					 
435d			 
435d			 
435d			; for each char convert to low 
435d					 
435d			.totdone: 
435d					if DEBUG_FORTH_WORDS 
435d						DMARK "TCd" 
435d f5				push af  
435e 3a 72 43			ld a, (.dmark)  
4361 32 6b ee			ld (debug_mark),a  
4364 3a 73 43			ld a, (.dmark+1)  
4367 32 6c ee			ld (debug_mark+1),a  
436a 3a 74 43			ld a, (.dmark+2)  
436d 32 6d ee			ld (debug_mark+2),a  
4370 18 03			jr .pastdmark  
4372 ..			.dmark: db "TCd"  
4375 f1			.pastdmark: pop af  
4376			endm  
# End of macro DMARK
4376						CALLMONITOR 
4376 cd 6f ee			call debug_vector  
4379				endm  
# End of macro CALLMONITOR
4379					endif 
4379					NEXTW 
4379 c3 34 1f			jp macro_next 
437c				endm 
# End of macro NEXTW
437c			 
437c			.SUBSTR: 
437c				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
437c 48				db WORD_SYS_CORE+52             
437d da 43			dw .LEFT            
437f 07				db 6 + 1 
4380 .. 00			db "SUBSTR",0              
4387				endm 
# End of macro CWHEAD
4387			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4387			 
4387					if DEBUG_FORTH_WORDS_KEY 
4387						DMARK "SST" 
4387 f5				push af  
4388 3a 9c 43			ld a, (.dmark)  
438b 32 6b ee			ld (debug_mark),a  
438e 3a 9d 43			ld a, (.dmark+1)  
4391 32 6c ee			ld (debug_mark+1),a  
4394 3a 9e 43			ld a, (.dmark+2)  
4397 32 6d ee			ld (debug_mark+2),a  
439a 18 03			jr .pastdmark  
439c ..			.dmark: db "SST"  
439f f1			.pastdmark: pop af  
43a0			endm  
# End of macro DMARK
43a0						CALLMONITOR 
43a0 cd 6f ee			call debug_vector  
43a3				endm  
# End of macro CALLMONITOR
43a3					endif 
43a3			; TODO check string type 
43a3					FORTH_DSP_VALUEHL 
43a3 cd 7e 1d			call macro_dsp_valuehl 
43a6				endm 
# End of macro FORTH_DSP_VALUEHL
43a6			 
43a6 e5					push hl      ; string length 
43a7			 
43a7					FORTH_DSP_POP 
43a7 cd 36 1e			call macro_forth_dsp_pop 
43aa				endm 
# End of macro FORTH_DSP_POP
43aa			 
43aa					FORTH_DSP_VALUEHL 
43aa cd 7e 1d			call macro_dsp_valuehl 
43ad				endm 
# End of macro FORTH_DSP_VALUEHL
43ad			 
43ad e5					push hl     ; start char 
43ae			 
43ae					FORTH_DSP_POP 
43ae cd 36 1e			call macro_forth_dsp_pop 
43b1				endm 
# End of macro FORTH_DSP_POP
43b1			 
43b1			 
43b1					FORTH_DSP_VALUE 
43b1 cd 67 1d			call macro_forth_dsp_value 
43b4				endm 
# End of macro FORTH_DSP_VALUE
43b4			 
43b4 d1					pop de    ; get start post offset 
43b5			 
43b5 19					add hl, de    ; starting offset 
43b6			 
43b6 c1					pop bc 
43b7 c5					push bc      ; grab size of string 
43b8			 
43b8 e5					push hl    ; save string start  
43b9			 
43b9 26 00				ld h, 0 
43bb 69					ld l, c 
43bc 23					inc hl 
43bd 23					inc hl 
43be			 
43be cd cd 11				call malloc 
43c1				if DEBUG_FORTH_MALLOC_GUARD 
43c1 cc f4 4c				call z,malloc_error 
43c4				endif 
43c4			 
43c4 eb					ex de, hl      ; save malloc area for string copy 
43c5 e1					pop hl    ; get back source 
43c6 c1					pop bc    ; get length of string back 
43c7			 
43c7 d5					push de    ; save malloc area for after we push 
43c8 ed b0				ldir     ; copy substr 
43ca			 
43ca			 
43ca eb					ex de, hl 
43cb 3e 00				ld a, 0 
43cd 77					ld (hl), a   ; term substr 
43ce			 
43ce					 
43ce e1					pop hl    ; get malloc so we can push it 
43cf e5					push hl   ; save so we can free it afterwards 
43d0			 
43d0 cd e7 1b				call forth_push_str 
43d3			 
43d3 e1					pop hl 
43d4 cd 97 12				call free 
43d7			 
43d7					 
43d7					 
43d7			 
43d7			 
43d7					NEXTW 
43d7 c3 34 1f			jp macro_next 
43da				endm 
# End of macro NEXTW
43da			 
43da			.LEFT: 
43da				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
43da 48				db WORD_SYS_CORE+52             
43db 02 44			dw .RIGHT            
43dd 05				db 4 + 1 
43de .. 00			db "LEFT",0              
43e3				endm 
# End of macro CWHEAD
43e3			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
43e3					if DEBUG_FORTH_WORDS_KEY 
43e3						DMARK "LEF" 
43e3 f5				push af  
43e4 3a f8 43			ld a, (.dmark)  
43e7 32 6b ee			ld (debug_mark),a  
43ea 3a f9 43			ld a, (.dmark+1)  
43ed 32 6c ee			ld (debug_mark+1),a  
43f0 3a fa 43			ld a, (.dmark+2)  
43f3 32 6d ee			ld (debug_mark+2),a  
43f6 18 03			jr .pastdmark  
43f8 ..			.dmark: db "LEF"  
43fb f1			.pastdmark: pop af  
43fc			endm  
# End of macro DMARK
43fc						CALLMONITOR 
43fc cd 6f ee			call debug_vector  
43ff				endm  
# End of macro CALLMONITOR
43ff					endif 
43ff			 
43ff					NEXTW 
43ff c3 34 1f			jp macro_next 
4402				endm 
# End of macro NEXTW
4402			.RIGHT: 
4402				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4402 48				db WORD_SYS_CORE+52             
4403 2b 44			dw .STR2NUM            
4405 06				db 5 + 1 
4406 .. 00			db "RIGHT",0              
440c				endm 
# End of macro CWHEAD
440c			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
440c					if DEBUG_FORTH_WORDS_KEY 
440c						DMARK "RIG" 
440c f5				push af  
440d 3a 21 44			ld a, (.dmark)  
4410 32 6b ee			ld (debug_mark),a  
4413 3a 22 44			ld a, (.dmark+1)  
4416 32 6c ee			ld (debug_mark+1),a  
4419 3a 23 44			ld a, (.dmark+2)  
441c 32 6d ee			ld (debug_mark+2),a  
441f 18 03			jr .pastdmark  
4421 ..			.dmark: db "RIG"  
4424 f1			.pastdmark: pop af  
4425			endm  
# End of macro DMARK
4425						CALLMONITOR 
4425 cd 6f ee			call debug_vector  
4428				endm  
# End of macro CALLMONITOR
4428					endif 
4428			 
4428					NEXTW 
4428 c3 34 1f			jp macro_next 
442b				endm 
# End of macro NEXTW
442b			 
442b			 
442b			.STR2NUM: 
442b				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
442b 48				db WORD_SYS_CORE+52             
442c b7 44			dw .NUM2STR            
442e 08				db 7 + 1 
442f .. 00			db "STR2NUM",0              
4437				endm 
# End of macro CWHEAD
4437			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4437			 
4437			 
4437			; TODO STR type check to do 
4437					if DEBUG_FORTH_WORDS_KEY 
4437						DMARK "S2N" 
4437 f5				push af  
4438 3a 4c 44			ld a, (.dmark)  
443b 32 6b ee			ld (debug_mark),a  
443e 3a 4d 44			ld a, (.dmark+1)  
4441 32 6c ee			ld (debug_mark+1),a  
4444 3a 4e 44			ld a, (.dmark+2)  
4447 32 6d ee			ld (debug_mark+2),a  
444a 18 03			jr .pastdmark  
444c ..			.dmark: db "S2N"  
444f f1			.pastdmark: pop af  
4450			endm  
# End of macro DMARK
4450						CALLMONITOR 
4450 cd 6f ee			call debug_vector  
4453				endm  
# End of macro CALLMONITOR
4453					endif 
4453			 
4453					;FORTH_DSP 
4453					FORTH_DSP_VALUE 
4453 cd 67 1d			call macro_forth_dsp_value 
4456				endm 
# End of macro FORTH_DSP_VALUE
4456					;inc hl 
4456			 
4456 eb					ex de, hl 
4457					if DEBUG_FORTH_WORDS 
4457						DMARK "S2a" 
4457 f5				push af  
4458 3a 6c 44			ld a, (.dmark)  
445b 32 6b ee			ld (debug_mark),a  
445e 3a 6d 44			ld a, (.dmark+1)  
4461 32 6c ee			ld (debug_mark+1),a  
4464 3a 6e 44			ld a, (.dmark+2)  
4467 32 6d ee			ld (debug_mark+2),a  
446a 18 03			jr .pastdmark  
446c ..			.dmark: db "S2a"  
446f f1			.pastdmark: pop af  
4470			endm  
# End of macro DMARK
4470						CALLMONITOR 
4470 cd 6f ee			call debug_vector  
4473				endm  
# End of macro CALLMONITOR
4473					endif 
4473 cd ef 10				call string_to_uint16 
4476			 
4476					if DEBUG_FORTH_WORDS 
4476						DMARK "S2b" 
4476 f5				push af  
4477 3a 8b 44			ld a, (.dmark)  
447a 32 6b ee			ld (debug_mark),a  
447d 3a 8c 44			ld a, (.dmark+1)  
4480 32 6c ee			ld (debug_mark+1),a  
4483 3a 8d 44			ld a, (.dmark+2)  
4486 32 6d ee			ld (debug_mark+2),a  
4489 18 03			jr .pastdmark  
448b ..			.dmark: db "S2b"  
448e f1			.pastdmark: pop af  
448f			endm  
# End of macro DMARK
448f						CALLMONITOR 
448f cd 6f ee			call debug_vector  
4492				endm  
# End of macro CALLMONITOR
4492					endif 
4492			;		push hl 
4492					FORTH_DSP_POP 
4492 cd 36 1e			call macro_forth_dsp_pop 
4495				endm 
# End of macro FORTH_DSP_POP
4495			;		pop hl 
4495					 
4495					if DEBUG_FORTH_WORDS 
4495						DMARK "S2b" 
4495 f5				push af  
4496 3a aa 44			ld a, (.dmark)  
4499 32 6b ee			ld (debug_mark),a  
449c 3a ab 44			ld a, (.dmark+1)  
449f 32 6c ee			ld (debug_mark+1),a  
44a2 3a ac 44			ld a, (.dmark+2)  
44a5 32 6d ee			ld (debug_mark+2),a  
44a8 18 03			jr .pastdmark  
44aa ..			.dmark: db "S2b"  
44ad f1			.pastdmark: pop af  
44ae			endm  
# End of macro DMARK
44ae						CALLMONITOR 
44ae cd 6f ee			call debug_vector  
44b1				endm  
# End of macro CALLMONITOR
44b1					endif 
44b1 cd 79 1b				call forth_push_numhl	 
44b4			 
44b4				 
44b4				       NEXTW 
44b4 c3 34 1f			jp macro_next 
44b7				endm 
# End of macro NEXTW
44b7			.NUM2STR: 
44b7				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
44b7 48				db WORD_SYS_CORE+52             
44b8 c6 44			dw .CONCAT            
44ba 08				db 7 + 1 
44bb .. 00			db "NUM2STR",0              
44c3				endm 
# End of macro CWHEAD
44c3			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
44c3			 
44c3			;		; malloc a string to target 
44c3			;		ld hl, 10     ; TODO max string size should be fine 
44c3			;		call malloc 
44c3			;		push hl    ; save malloc location 
44c3			; 
44c3			; 
44c3			;; TODO check int type 
44c3			;		FORTH_DSP_VALUEHL 
44c3			;		ld a, l 
44c3			;		call DispAToASCII   
44c3			;;TODO need to chage above call to dump into string 
44c3			; 
44c3			; 
44c3			 
44c3				       NEXTW 
44c3 c3 34 1f			jp macro_next 
44c6				endm 
# End of macro NEXTW
44c6			 
44c6			.CONCAT: 
44c6				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
44c6 48				db WORD_SYS_CORE+52             
44c7 79 45			dw .FIND            
44c9 07				db 6 + 1 
44ca .. 00			db "CONCAT",0              
44d1				endm 
# End of macro CWHEAD
44d1			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
44d1			 
44d1			; TODO check string type 
44d1			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
44d1			 
44d1					if DEBUG_FORTH_WORDS_KEY 
44d1						DMARK "CON" 
44d1 f5				push af  
44d2 3a e6 44			ld a, (.dmark)  
44d5 32 6b ee			ld (debug_mark),a  
44d8 3a e7 44			ld a, (.dmark+1)  
44db 32 6c ee			ld (debug_mark+1),a  
44de 3a e8 44			ld a, (.dmark+2)  
44e1 32 6d ee			ld (debug_mark+2),a  
44e4 18 03			jr .pastdmark  
44e6 ..			.dmark: db "CON"  
44e9 f1			.pastdmark: pop af  
44ea			endm  
# End of macro DMARK
44ea						CALLMONITOR 
44ea cd 6f ee			call debug_vector  
44ed				endm  
# End of macro CALLMONITOR
44ed					endif 
44ed			 
44ed			 
44ed					FORTH_DSP_VALUE 
44ed cd 67 1d			call macro_forth_dsp_value 
44f0				endm 
# End of macro FORTH_DSP_VALUE
44f0 e5					push hl   ; s2 
44f1			 
44f1					FORTH_DSP_POP 
44f1 cd 36 1e			call macro_forth_dsp_pop 
44f4				endm 
# End of macro FORTH_DSP_POP
44f4			 
44f4					FORTH_DSP_VALUE 
44f4 cd 67 1d			call macro_forth_dsp_value 
44f7				endm 
# End of macro FORTH_DSP_VALUE
44f7			 
44f7 e5					push hl   ; s1 
44f8			 
44f8					FORTH_DSP_POP 
44f8 cd 36 1e			call macro_forth_dsp_pop 
44fb				endm 
# End of macro FORTH_DSP_POP
44fb					 
44fb			 
44fb					; copy s1 
44fb			 
44fb				 
44fb					; save ptr 
44fb e1					pop hl  
44fc e5					push hl 
44fd 3e 00				ld a, 0 
44ff cd 63 11				call strlent 
4502					;inc hl    ; zer0 
4502 06 00				ld b, 0 
4504 4d					ld c, l 
4505 e1					pop hl		 
4506 11 c1 e2				ld de, scratch	 
4509					if DEBUG_FORTH_WORDS 
4509						DMARK "CO1" 
4509 f5				push af  
450a 3a 1e 45			ld a, (.dmark)  
450d 32 6b ee			ld (debug_mark),a  
4510 3a 1f 45			ld a, (.dmark+1)  
4513 32 6c ee			ld (debug_mark+1),a  
4516 3a 20 45			ld a, (.dmark+2)  
4519 32 6d ee			ld (debug_mark+2),a  
451c 18 03			jr .pastdmark  
451e ..			.dmark: db "CO1"  
4521 f1			.pastdmark: pop af  
4522			endm  
# End of macro DMARK
4522						CALLMONITOR 
4522 cd 6f ee			call debug_vector  
4525				endm  
# End of macro CALLMONITOR
4525					endif 
4525 ed b0				ldir 
4527			 
4527 e1					pop hl 
4528 e5					push hl 
4529 d5					push de 
452a			 
452a			 
452a 3e 00				ld a, 0 
452c cd 63 11				call strlent 
452f 23					inc hl    ; zer0 
4530 23					inc hl 
4531 06 00				ld b, 0 
4533 4d					ld c, l 
4534 d1					pop de 
4535 e1					pop hl		 
4536					if DEBUG_FORTH_WORDS 
4536						DMARK "CO2" 
4536 f5				push af  
4537 3a 4b 45			ld a, (.dmark)  
453a 32 6b ee			ld (debug_mark),a  
453d 3a 4c 45			ld a, (.dmark+1)  
4540 32 6c ee			ld (debug_mark+1),a  
4543 3a 4d 45			ld a, (.dmark+2)  
4546 32 6d ee			ld (debug_mark+2),a  
4549 18 03			jr .pastdmark  
454b ..			.dmark: db "CO2"  
454e f1			.pastdmark: pop af  
454f			endm  
# End of macro DMARK
454f						CALLMONITOR 
454f cd 6f ee			call debug_vector  
4552				endm  
# End of macro CALLMONITOR
4552					endif 
4552 ed b0				ldir 
4554			 
4554			 
4554			 
4554 21 c1 e2				ld hl, scratch 
4557					if DEBUG_FORTH_WORDS 
4557						DMARK "CO5" 
4557 f5				push af  
4558 3a 6c 45			ld a, (.dmark)  
455b 32 6b ee			ld (debug_mark),a  
455e 3a 6d 45			ld a, (.dmark+1)  
4561 32 6c ee			ld (debug_mark+1),a  
4564 3a 6e 45			ld a, (.dmark+2)  
4567 32 6d ee			ld (debug_mark+2),a  
456a 18 03			jr .pastdmark  
456c ..			.dmark: db "CO5"  
456f f1			.pastdmark: pop af  
4570			endm  
# End of macro DMARK
4570						CALLMONITOR 
4570 cd 6f ee			call debug_vector  
4573				endm  
# End of macro CALLMONITOR
4573					endif 
4573			 
4573 cd e7 1b				call forth_push_str 
4576			 
4576			 
4576			 
4576			 
4576				       NEXTW 
4576 c3 34 1f			jp macro_next 
4579				endm 
# End of macro NEXTW
4579			 
4579			 
4579			.FIND: 
4579				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4579 4b				db WORD_SYS_CORE+55             
457a 37 46			dw .LEN            
457c 05				db 4 + 1 
457d .. 00			db "FIND",0              
4582				endm 
# End of macro CWHEAD
4582			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4582			 
4582					if DEBUG_FORTH_WORDS_KEY 
4582						DMARK "FND" 
4582 f5				push af  
4583 3a 97 45			ld a, (.dmark)  
4586 32 6b ee			ld (debug_mark),a  
4589 3a 98 45			ld a, (.dmark+1)  
458c 32 6c ee			ld (debug_mark+1),a  
458f 3a 99 45			ld a, (.dmark+2)  
4592 32 6d ee			ld (debug_mark+2),a  
4595 18 03			jr .pastdmark  
4597 ..			.dmark: db "FND"  
459a f1			.pastdmark: pop af  
459b			endm  
# End of macro DMARK
459b						CALLMONITOR 
459b cd 6f ee			call debug_vector  
459e				endm  
# End of macro CALLMONITOR
459e					endif 
459e			 
459e			; TODO check string type 
459e					FORTH_DSP_VALUE 
459e cd 67 1d			call macro_forth_dsp_value 
45a1				endm 
# End of macro FORTH_DSP_VALUE
45a1			 
45a1 e5					push hl    
45a2 7e					ld a,(hl)    ; char to find   
45a3			; TODO change char to substr 
45a3			 
45a3 f5					push af 
45a4					 
45a4			 
45a4			 
45a4					if DEBUG_FORTH_WORDS 
45a4						DMARK "FN1" 
45a4 f5				push af  
45a5 3a b9 45			ld a, (.dmark)  
45a8 32 6b ee			ld (debug_mark),a  
45ab 3a ba 45			ld a, (.dmark+1)  
45ae 32 6c ee			ld (debug_mark+1),a  
45b1 3a bb 45			ld a, (.dmark+2)  
45b4 32 6d ee			ld (debug_mark+2),a  
45b7 18 03			jr .pastdmark  
45b9 ..			.dmark: db "FN1"  
45bc f1			.pastdmark: pop af  
45bd			endm  
# End of macro DMARK
45bd						CALLMONITOR 
45bd cd 6f ee			call debug_vector  
45c0				endm  
# End of macro CALLMONITOR
45c0					endif 
45c0			 
45c0					FORTH_DSP_POP 
45c0 cd 36 1e			call macro_forth_dsp_pop 
45c3				endm 
# End of macro FORTH_DSP_POP
45c3			 
45c3					; string to search 
45c3			 
45c3					FORTH_DSP_VALUE 
45c3 cd 67 1d			call macro_forth_dsp_value 
45c6				endm 
# End of macro FORTH_DSP_VALUE
45c6			 
45c6 d1					pop de  ; d is char to find  
45c7			 
45c7					if DEBUG_FORTH_WORDS 
45c7						DMARK "FN2" 
45c7 f5				push af  
45c8 3a dc 45			ld a, (.dmark)  
45cb 32 6b ee			ld (debug_mark),a  
45ce 3a dd 45			ld a, (.dmark+1)  
45d1 32 6c ee			ld (debug_mark+1),a  
45d4 3a de 45			ld a, (.dmark+2)  
45d7 32 6d ee			ld (debug_mark+2),a  
45da 18 03			jr .pastdmark  
45dc ..			.dmark: db "FN2"  
45df f1			.pastdmark: pop af  
45e0			endm  
# End of macro DMARK
45e0						CALLMONITOR 
45e0 cd 6f ee			call debug_vector  
45e3				endm  
# End of macro CALLMONITOR
45e3					endif 
45e3					 
45e3 01 00 00				ld bc, 0 
45e6 7e			.findchar:      ld a,(hl) 
45e7 fe 00				cp 0   		 
45e9 28 27				jr z, .finddone     
45eb ba					cp d 
45ec 28 20				jr z, .foundchar 
45ee 03					inc bc 
45ef 23					inc hl 
45f0					if DEBUG_FORTH_WORDS 
45f0						DMARK "FN3" 
45f0 f5				push af  
45f1 3a 05 46			ld a, (.dmark)  
45f4 32 6b ee			ld (debug_mark),a  
45f7 3a 06 46			ld a, (.dmark+1)  
45fa 32 6c ee			ld (debug_mark+1),a  
45fd 3a 07 46			ld a, (.dmark+2)  
4600 32 6d ee			ld (debug_mark+2),a  
4603 18 03			jr .pastdmark  
4605 ..			.dmark: db "FN3"  
4608 f1			.pastdmark: pop af  
4609			endm  
# End of macro DMARK
4609						CALLMONITOR 
4609 cd 6f ee			call debug_vector  
460c				endm  
# End of macro CALLMONITOR
460c					endif 
460c 18 d8				jr .findchar 
460e			 
460e			 
460e c5			.foundchar:	push bc 
460f e1					pop hl 
4610 18 03				jr .findexit 
4612			 
4612			 
4612							 
4612			 
4612			.finddone:     ; got to end of string with no find 
4612 21 00 00				ld hl, 0 
4615			.findexit: 
4615			 
4615					if DEBUG_FORTH_WORDS 
4615						DMARK "FNd" 
4615 f5				push af  
4616 3a 2a 46			ld a, (.dmark)  
4619 32 6b ee			ld (debug_mark),a  
461c 3a 2b 46			ld a, (.dmark+1)  
461f 32 6c ee			ld (debug_mark+1),a  
4622 3a 2c 46			ld a, (.dmark+2)  
4625 32 6d ee			ld (debug_mark+2),a  
4628 18 03			jr .pastdmark  
462a ..			.dmark: db "FNd"  
462d f1			.pastdmark: pop af  
462e			endm  
# End of macro DMARK
462e						CALLMONITOR 
462e cd 6f ee			call debug_vector  
4631				endm  
# End of macro CALLMONITOR
4631					endif 
4631 cd 79 1b			call forth_push_numhl 
4634			 
4634				       NEXTW 
4634 c3 34 1f			jp macro_next 
4637				endm 
# End of macro NEXTW
4637			 
4637			.LEN: 
4637				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4637 4c				db WORD_SYS_CORE+56             
4638 a1 46			dw .ASC            
463a 06				db 5 + 1 
463b .. 00			db "COUNT",0              
4641				endm 
# End of macro CWHEAD
4641			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4641			 
4641					if DEBUG_FORTH_WORDS_KEY 
4641						DMARK "CNT" 
4641 f5				push af  
4642 3a 56 46			ld a, (.dmark)  
4645 32 6b ee			ld (debug_mark),a  
4648 3a 57 46			ld a, (.dmark+1)  
464b 32 6c ee			ld (debug_mark+1),a  
464e 3a 58 46			ld a, (.dmark+2)  
4651 32 6d ee			ld (debug_mark+2),a  
4654 18 03			jr .pastdmark  
4656 ..			.dmark: db "CNT"  
4659 f1			.pastdmark: pop af  
465a			endm  
# End of macro DMARK
465a						CALLMONITOR 
465a cd 6f ee			call debug_vector  
465d				endm  
# End of macro CALLMONITOR
465d					endif 
465d			; TODO check string type 
465d					FORTH_DSP_VALUE 
465d cd 67 1d			call macro_forth_dsp_value 
4660				endm 
# End of macro FORTH_DSP_VALUE
4660			 
4660			 
4660					if DEBUG_FORTH_WORDS 
4660						DMARK "CN?" 
4660 f5				push af  
4661 3a 75 46			ld a, (.dmark)  
4664 32 6b ee			ld (debug_mark),a  
4667 3a 76 46			ld a, (.dmark+1)  
466a 32 6c ee			ld (debug_mark+1),a  
466d 3a 77 46			ld a, (.dmark+2)  
4670 32 6d ee			ld (debug_mark+2),a  
4673 18 03			jr .pastdmark  
4675 ..			.dmark: db "CN?"  
4678 f1			.pastdmark: pop af  
4679			endm  
# End of macro DMARK
4679						CALLMONITOR 
4679 cd 6f ee			call debug_vector  
467c				endm  
# End of macro CALLMONITOR
467c					endif 
467c cd 58 11				call strlenz 
467f					if DEBUG_FORTH_WORDS 
467f						DMARK "CNl" 
467f f5				push af  
4680 3a 94 46			ld a, (.dmark)  
4683 32 6b ee			ld (debug_mark),a  
4686 3a 95 46			ld a, (.dmark+1)  
4689 32 6c ee			ld (debug_mark+1),a  
468c 3a 96 46			ld a, (.dmark+2)  
468f 32 6d ee			ld (debug_mark+2),a  
4692 18 03			jr .pastdmark  
4694 ..			.dmark: db "CNl"  
4697 f1			.pastdmark: pop af  
4698			endm  
# End of macro DMARK
4698						CALLMONITOR 
4698 cd 6f ee			call debug_vector  
469b				endm  
# End of macro CALLMONITOR
469b					endif 
469b			 
469b cd 79 1b				call forth_push_numhl 
469e			 
469e			 
469e			 
469e				       NEXTW 
469e c3 34 1f			jp macro_next 
46a1				endm 
# End of macro NEXTW
46a1			.ASC: 
46a1				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
46a1 4d				db WORD_SYS_CORE+57             
46a2 0f 47			dw .CHR            
46a4 04				db 3 + 1 
46a5 .. 00			db "ASC",0              
46a9				endm 
# End of macro CWHEAD
46a9			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
46a9					if DEBUG_FORTH_WORDS_KEY 
46a9						DMARK "ASC" 
46a9 f5				push af  
46aa 3a be 46			ld a, (.dmark)  
46ad 32 6b ee			ld (debug_mark),a  
46b0 3a bf 46			ld a, (.dmark+1)  
46b3 32 6c ee			ld (debug_mark+1),a  
46b6 3a c0 46			ld a, (.dmark+2)  
46b9 32 6d ee			ld (debug_mark+2),a  
46bc 18 03			jr .pastdmark  
46be ..			.dmark: db "ASC"  
46c1 f1			.pastdmark: pop af  
46c2			endm  
# End of macro DMARK
46c2						CALLMONITOR 
46c2 cd 6f ee			call debug_vector  
46c5				endm  
# End of macro CALLMONITOR
46c5					endif 
46c5					FORTH_DSP_VALUE 
46c5 cd 67 1d			call macro_forth_dsp_value 
46c8				endm 
# End of macro FORTH_DSP_VALUE
46c8					;v5 FORTH_DSP_VALUE 
46c8			;		inc hl      ; now at start of numeric as string 
46c8			 
46c8 e5					push hl 
46c9			 
46c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46c9 cd 36 1e			call macro_forth_dsp_pop 
46cc				endm 
# End of macro FORTH_DSP_POP
46cc			 
46cc e1					pop hl 
46cd			 
46cd					if DEBUG_FORTH_WORDS 
46cd						DMARK "AS1" 
46cd f5				push af  
46ce 3a e2 46			ld a, (.dmark)  
46d1 32 6b ee			ld (debug_mark),a  
46d4 3a e3 46			ld a, (.dmark+1)  
46d7 32 6c ee			ld (debug_mark+1),a  
46da 3a e4 46			ld a, (.dmark+2)  
46dd 32 6d ee			ld (debug_mark+2),a  
46e0 18 03			jr .pastdmark  
46e2 ..			.dmark: db "AS1"  
46e5 f1			.pastdmark: pop af  
46e6			endm  
# End of macro DMARK
46e6						CALLMONITOR 
46e6 cd 6f ee			call debug_vector  
46e9				endm  
# End of macro CALLMONITOR
46e9					endif 
46e9					; push the content of a onto the stack as a value 
46e9			 
46e9 7e					ld a,(hl)   ; get char 
46ea 26 00				ld h,0 
46ec 6f					ld l,a 
46ed					if DEBUG_FORTH_WORDS 
46ed						DMARK "AS2" 
46ed f5				push af  
46ee 3a 02 47			ld a, (.dmark)  
46f1 32 6b ee			ld (debug_mark),a  
46f4 3a 03 47			ld a, (.dmark+1)  
46f7 32 6c ee			ld (debug_mark+1),a  
46fa 3a 04 47			ld a, (.dmark+2)  
46fd 32 6d ee			ld (debug_mark+2),a  
4700 18 03			jr .pastdmark  
4702 ..			.dmark: db "AS2"  
4705 f1			.pastdmark: pop af  
4706			endm  
# End of macro DMARK
4706						CALLMONITOR 
4706 cd 6f ee			call debug_vector  
4709				endm  
# End of macro CALLMONITOR
4709					endif 
4709 cd 79 1b				call forth_push_numhl 
470c			 
470c				       NEXTW 
470c c3 34 1f			jp macro_next 
470f				endm 
# End of macro NEXTW
470f			 
470f			.CHR: 
470f				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
470f 4d				db WORD_SYS_CORE+57             
4710 4b 47			dw .ENDSTR            
4712 04				db 3 + 1 
4713 .. 00			db "CHR",0              
4717				endm 
# End of macro CWHEAD
4717			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4717					if DEBUG_FORTH_WORDS_KEY 
4717						DMARK "CHR" 
4717 f5				push af  
4718 3a 2c 47			ld a, (.dmark)  
471b 32 6b ee			ld (debug_mark),a  
471e 3a 2d 47			ld a, (.dmark+1)  
4721 32 6c ee			ld (debug_mark+1),a  
4724 3a 2e 47			ld a, (.dmark+2)  
4727 32 6d ee			ld (debug_mark+2),a  
472a 18 03			jr .pastdmark  
472c ..			.dmark: db "CHR"  
472f f1			.pastdmark: pop af  
4730			endm  
# End of macro DMARK
4730						CALLMONITOR 
4730 cd 6f ee			call debug_vector  
4733				endm  
# End of macro CALLMONITOR
4733					endif 
4733					FORTH_DSP_VALUEHL 
4733 cd 7e 1d			call macro_dsp_valuehl 
4736				endm 
# End of macro FORTH_DSP_VALUEHL
4736			 
4736					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4736 cd 36 1e			call macro_forth_dsp_pop 
4739				endm 
# End of macro FORTH_DSP_POP
4739			 
4739					; save asci byte as a zero term string and push string 
4739			 
4739 7d					ld a,l 
473a 32 c1 e2				ld (scratch), a 
473d			 
473d 3e 00				ld a, 0 
473f 32 c2 e2				ld (scratch+1), a 
4742			 
4742 21 c1 e2				ld hl, scratch 
4745 cd e7 1b				call forth_push_str 
4748			 
4748			 
4748				       NEXTW 
4748 c3 34 1f			jp macro_next 
474b				endm 
# End of macro NEXTW
474b			 
474b			 
474b			 
474b			 
474b			.ENDSTR: 
474b			; eof 
474b			 
# End of file forth_words_str.asm
474b			include "forth_words_key.asm" 
474b			 
474b			; | ## Keyboard Words 
474b			 
474b			.KEY: 
474b				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
474b 3e				db WORD_SYS_CORE+42             
474c 7b 47			dw .WAITK            
474e 04				db 3 + 1 
474f .. 00			db "KEY",0              
4753				endm 
# End of macro CWHEAD
4753			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
4753			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
4753			; | | Can use something like this to process: 
4753			; | | > repeat active . key ?dup if emit then #1 until  
4753			 
4753					if DEBUG_FORTH_WORDS_KEY 
4753						DMARK "KEY" 
4753 f5				push af  
4754 3a 68 47			ld a, (.dmark)  
4757 32 6b ee			ld (debug_mark),a  
475a 3a 69 47			ld a, (.dmark+1)  
475d 32 6c ee			ld (debug_mark+1),a  
4760 3a 6a 47			ld a, (.dmark+2)  
4763 32 6d ee			ld (debug_mark+2),a  
4766 18 03			jr .pastdmark  
4768 ..			.dmark: db "KEY"  
476b f1			.pastdmark: pop af  
476c			endm  
# End of macro DMARK
476c						CALLMONITOR 
476c cd 6f ee			call debug_vector  
476f				endm  
# End of macro CALLMONITOR
476f					endif 
476f			; TODO currently waits 
476f cd 70 5e				call cin 
4772					;call cin_wait 
4772 6f					ld l, a 
4773 26 00				ld h, 0 
4775 cd 79 1b				call forth_push_numhl 
4778					NEXTW 
4778 c3 34 1f			jp macro_next 
477b				endm 
# End of macro NEXTW
477b			.WAITK: 
477b				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
477b 3f				db WORD_SYS_CORE+43             
477c ad 47			dw .ACCEPT            
477e 06				db 5 + 1 
477f .. 00			db "WAITK",0              
4785				endm 
# End of macro CWHEAD
4785			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4785					if DEBUG_FORTH_WORDS_KEY 
4785						DMARK "WAI" 
4785 f5				push af  
4786 3a 9a 47			ld a, (.dmark)  
4789 32 6b ee			ld (debug_mark),a  
478c 3a 9b 47			ld a, (.dmark+1)  
478f 32 6c ee			ld (debug_mark+1),a  
4792 3a 9c 47			ld a, (.dmark+2)  
4795 32 6d ee			ld (debug_mark+2),a  
4798 18 03			jr .pastdmark  
479a ..			.dmark: db "WAI"  
479d f1			.pastdmark: pop af  
479e			endm  
# End of macro DMARK
479e						CALLMONITOR 
479e cd 6f ee			call debug_vector  
47a1				endm  
# End of macro CALLMONITOR
47a1					endif 
47a1 cd 68 5e				call cin_wait 
47a4 6f					ld l, a 
47a5 26 00				ld h, 0 
47a7 cd 79 1b				call forth_push_numhl 
47aa					NEXTW 
47aa c3 34 1f			jp macro_next 
47ad				endm 
# End of macro NEXTW
47ad			.ACCEPT: 
47ad				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
47ad 40				db WORD_SYS_CORE+44             
47ae 0b 48			dw .EDIT            
47b0 07				db 6 + 1 
47b1 .. 00			db "ACCEPT",0              
47b8				endm 
# End of macro CWHEAD
47b8			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
47b8					; TODO crashes on push 
47b8					if DEBUG_FORTH_WORDS_KEY 
47b8						DMARK "ACC" 
47b8 f5				push af  
47b9 3a cd 47			ld a, (.dmark)  
47bc 32 6b ee			ld (debug_mark),a  
47bf 3a ce 47			ld a, (.dmark+1)  
47c2 32 6c ee			ld (debug_mark+1),a  
47c5 3a cf 47			ld a, (.dmark+2)  
47c8 32 6d ee			ld (debug_mark+2),a  
47cb 18 03			jr .pastdmark  
47cd ..			.dmark: db "ACC"  
47d0 f1			.pastdmark: pop af  
47d1			endm  
# End of macro DMARK
47d1						CALLMONITOR 
47d1 cd 6f ee			call debug_vector  
47d4				endm  
# End of macro CALLMONITOR
47d4					endif 
47d4 21 bf e4				ld hl, os_input 
47d7 3e 00				ld a, 0 
47d9 77					ld (hl),a 
47da 3a 5e ea				ld a,(f_cursor_ptr) 
47dd 16 64				ld d, 100 
47df 0e 00				ld c, 0 
47e1 1e 28				ld e, 40 
47e3 cd 1f 0e				call input_str 
47e6					; TODO perhaps do a type check and wrap in quotes if not a number 
47e6 21 bf e4				ld hl, os_input 
47e9					if DEBUG_FORTH_WORDS 
47e9						DMARK "AC1" 
47e9 f5				push af  
47ea 3a fe 47			ld a, (.dmark)  
47ed 32 6b ee			ld (debug_mark),a  
47f0 3a ff 47			ld a, (.dmark+1)  
47f3 32 6c ee			ld (debug_mark+1),a  
47f6 3a 00 48			ld a, (.dmark+2)  
47f9 32 6d ee			ld (debug_mark+2),a  
47fc 18 03			jr .pastdmark  
47fe ..			.dmark: db "AC1"  
4801 f1			.pastdmark: pop af  
4802			endm  
# End of macro DMARK
4802						CALLMONITOR 
4802 cd 6f ee			call debug_vector  
4805				endm  
# End of macro CALLMONITOR
4805					endif 
4805 cd e7 1b				call forth_push_str 
4808					NEXTW 
4808 c3 34 1f			jp macro_next 
480b				endm 
# End of macro NEXTW
480b			 
480b			.EDIT: 
480b				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
480b 40				db WORD_SYS_CORE+44             
480c ad 48			dw .DEDIT            
480e 05				db 4 + 1 
480f .. 00			db "EDIT",0              
4814				endm 
# End of macro CWHEAD
4814			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4814			 
4814					; TODO does not copy from stack 
4814					if DEBUG_FORTH_WORDS_KEY 
4814						DMARK "EDT" 
4814 f5				push af  
4815 3a 29 48			ld a, (.dmark)  
4818 32 6b ee			ld (debug_mark),a  
481b 3a 2a 48			ld a, (.dmark+1)  
481e 32 6c ee			ld (debug_mark+1),a  
4821 3a 2b 48			ld a, (.dmark+2)  
4824 32 6d ee			ld (debug_mark+2),a  
4827 18 03			jr .pastdmark  
4829 ..			.dmark: db "EDT"  
482c f1			.pastdmark: pop af  
482d			endm  
# End of macro DMARK
482d						CALLMONITOR 
482d cd 6f ee			call debug_vector  
4830				endm  
# End of macro CALLMONITOR
4830					endif 
4830			 
4830					;FORTH_DSP 
4830					FORTH_DSP_VALUEHL 
4830 cd 7e 1d			call macro_dsp_valuehl 
4833				endm 
# End of macro FORTH_DSP_VALUEHL
4833			;		inc hl    ; TODO do type check 
4833			 
4833			;		call get_word_hl 
4833 e5					push hl 
4834					if DEBUG_FORTH_WORDS 
4834						DMARK "EDp" 
4834 f5				push af  
4835 3a 49 48			ld a, (.dmark)  
4838 32 6b ee			ld (debug_mark),a  
483b 3a 4a 48			ld a, (.dmark+1)  
483e 32 6c ee			ld (debug_mark+1),a  
4841 3a 4b 48			ld a, (.dmark+2)  
4844 32 6d ee			ld (debug_mark+2),a  
4847 18 03			jr .pastdmark  
4849 ..			.dmark: db "EDp"  
484c f1			.pastdmark: pop af  
484d			endm  
# End of macro DMARK
484d						CALLMONITOR 
484d cd 6f ee			call debug_vector  
4850				endm  
# End of macro CALLMONITOR
4850					endif 
4850				;	ld a, 0 
4850 cd 58 11				call strlenz 
4853 23					inc hl 
4854			 
4854 06 00				ld b, 0 
4856 4d					ld c, l 
4857			 
4857 e1					pop hl 
4858 11 bf e4				ld de, os_input 
485b					if DEBUG_FORTH_WORDS_KEY 
485b						DMARK "EDc" 
485b f5				push af  
485c 3a 70 48			ld a, (.dmark)  
485f 32 6b ee			ld (debug_mark),a  
4862 3a 71 48			ld a, (.dmark+1)  
4865 32 6c ee			ld (debug_mark+1),a  
4868 3a 72 48			ld a, (.dmark+2)  
486b 32 6d ee			ld (debug_mark+2),a  
486e 18 03			jr .pastdmark  
4870 ..			.dmark: db "EDc"  
4873 f1			.pastdmark: pop af  
4874			endm  
# End of macro DMARK
4874						CALLMONITOR 
4874 cd 6f ee			call debug_vector  
4877				endm  
# End of macro CALLMONITOR
4877					endif 
4877 ed b0				ldir 
4879			 
4879			 
4879 21 bf e4				ld hl, os_input 
487c					;ld a, 0 
487c					;ld (hl),a 
487c 3a 5e ea				ld a,(f_cursor_ptr) 
487f 16 64				ld d, 100 
4881 0e 00				ld c, 0 
4883 1e 28				ld e, 40 
4885 cd 1f 0e				call input_str 
4888					; TODO perhaps do a type check and wrap in quotes if not a number 
4888 21 bf e4				ld hl, os_input 
488b					if DEBUG_FORTH_WORDS 
488b						DMARK "ED1" 
488b f5				push af  
488c 3a a0 48			ld a, (.dmark)  
488f 32 6b ee			ld (debug_mark),a  
4892 3a a1 48			ld a, (.dmark+1)  
4895 32 6c ee			ld (debug_mark+1),a  
4898 3a a2 48			ld a, (.dmark+2)  
489b 32 6d ee			ld (debug_mark+2),a  
489e 18 03			jr .pastdmark  
48a0 ..			.dmark: db "ED1"  
48a3 f1			.pastdmark: pop af  
48a4			endm  
# End of macro DMARK
48a4						CALLMONITOR 
48a4 cd 6f ee			call debug_vector  
48a7				endm  
# End of macro CALLMONITOR
48a7					endif 
48a7 cd e7 1b				call forth_push_str 
48aa					NEXTW 
48aa c3 34 1f			jp macro_next 
48ad				endm 
# End of macro NEXTW
48ad			 
48ad			.DEDIT: 
48ad				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
48ad 40				db WORD_SYS_CORE+44             
48ae 0f 49			dw .ENDKEY            
48b0 06				db 5 + 1 
48b1 .. 00			db "DEDIT",0              
48b7				endm 
# End of macro CWHEAD
48b7			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
48b7			 
48b7					; TODO does not copy from stack 
48b7					if DEBUG_FORTH_WORDS_KEY 
48b7						DMARK "DED" 
48b7 f5				push af  
48b8 3a cc 48			ld a, (.dmark)  
48bb 32 6b ee			ld (debug_mark),a  
48be 3a cd 48			ld a, (.dmark+1)  
48c1 32 6c ee			ld (debug_mark+1),a  
48c4 3a ce 48			ld a, (.dmark+2)  
48c7 32 6d ee			ld (debug_mark+2),a  
48ca 18 03			jr .pastdmark  
48cc ..			.dmark: db "DED"  
48cf f1			.pastdmark: pop af  
48d0			endm  
# End of macro DMARK
48d0						CALLMONITOR 
48d0 cd 6f ee			call debug_vector  
48d3				endm  
# End of macro CALLMONITOR
48d3					endif 
48d3			 
48d3					;FORTH_DSP 
48d3					FORTH_DSP_VALUEHL 
48d3 cd 7e 1d			call macro_dsp_valuehl 
48d6				endm 
# End of macro FORTH_DSP_VALUEHL
48d6			;		inc hl    ; TODO do type check 
48d6			 
48d6			;		call get_word_hl 
48d6 e5					push hl 
48d7 e5					push hl 
48d8					FORTH_DSP_POP 
48d8 cd 36 1e			call macro_forth_dsp_pop 
48db				endm 
# End of macro FORTH_DSP_POP
48db e1					pop hl 
48dc					if DEBUG_FORTH_WORDS 
48dc						DMARK "EDp" 
48dc f5				push af  
48dd 3a f1 48			ld a, (.dmark)  
48e0 32 6b ee			ld (debug_mark),a  
48e3 3a f2 48			ld a, (.dmark+1)  
48e6 32 6c ee			ld (debug_mark+1),a  
48e9 3a f3 48			ld a, (.dmark+2)  
48ec 32 6d ee			ld (debug_mark+2),a  
48ef 18 03			jr .pastdmark  
48f1 ..			.dmark: db "EDp"  
48f4 f1			.pastdmark: pop af  
48f5			endm  
# End of macro DMARK
48f5						CALLMONITOR 
48f5 cd 6f ee			call debug_vector  
48f8				endm  
# End of macro CALLMONITOR
48f8					endif 
48f8				;	ld a, 0 
48f8 cd 58 11				call strlenz 
48fb 23					inc hl 
48fc			 
48fc 06 00				ld b, 0 
48fe 4d					ld c, l 
48ff			 
48ff e1					pop hl 
4900			 
4900					;ld a, 0 
4900					;ld (hl),a 
4900 3a 5e ea				ld a,(f_cursor_ptr) 
4903 16 64				ld d, 100 
4905 0e 00				ld c, 0 
4907 1e 28				ld e, 40 
4909 cd 1f 0e				call input_str 
490c					; TODO perhaps do a type check and wrap in quotes if not a number 
490c					NEXTW 
490c c3 34 1f			jp macro_next 
490f				endm 
# End of macro NEXTW
490f			 
490f			 
490f			.ENDKEY: 
490f			; eof 
490f			 
# End of file forth_words_key.asm
490f			include "forth_words_const.asm" 
490f			 
490f			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
490f			 
490f			 
490f			.SPITIME: 
490f				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
490f 77				db WORD_SYS_CORE+99             
4910 24 49			dw .VA            
4912 08				db 7 + 1 
4913 .. 00			db "SPITIME",0              
491b				endm 
# End of macro CWHEAD
491b			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
491b			; 
491b			; | | If using BANK devices then leave as is. 
491b			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
491b			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
491b			 
491b 21 64 ea				ld hl, spi_clktime  
491e cd 79 1b				call forth_push_numhl 
4921			 
4921					NEXTW 
4921 c3 34 1f			jp macro_next 
4924				endm 
# End of macro NEXTW
4924			 
4924			 
4924			.VA: 
4924				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4924 77				db WORD_SYS_CORE+99             
4925 34 49			dw .SYMBOL            
4927 03				db 2 + 1 
4928 .. 00			db "VA",0              
492b				endm 
# End of macro CWHEAD
492b			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
492b 21 28 ea				ld hl, cli_var_array 
492e cd 79 1b				call forth_push_numhl 
4931			 
4931					NEXTW 
4931 c3 34 1f			jp macro_next 
4934				endm 
# End of macro NEXTW
4934			 
4934			.SYMBOL: 
4934				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4934 77				db WORD_SYS_CORE+99             
4935 3e 4a			dw .ENDCONST            
4937 07				db 6 + 1 
4938 .. 00			db "SYMBOL",0              
493f				endm 
# End of macro CWHEAD
493f			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
493f			; | 
493f			; | | The value is the number reference and the final address is pushed to stack 
493f			 
493f			; | | ``` 
493f			; | | dw sym_table 
493f			; | | dw nmi_vector 
493f			; | | dw cli_autodisplay 
493f			; | | dw cli_data_sp 
493f			; | | dw cli_data_stack 
493f			; | | dw cli_loop_sp 
493f			; | | dw cli_loop_stack 
493f			; | | dw cli_var_array 
493f			; | | dw cursor_col 
493f			; | | dw cursor_ptr 
493f			; | | ; 10 
493f			; | | dw cursor_row 
493f			; | | dw debug_mark 
493f			; | | dw display_fb0 
493f			; | | dw display_fb1 
493f			; | | dw display_fb2 
493f			; | | dw display_fb3 
493f			; | | dw display_fb_active 
493f			; | | dw execscratch 
493f			; | | dw f_cursor_ptr 
493f			; | | dw hardware_word 
493f			; | | ;20 
493f			; | | dw input_at_cursor 
493f			; | | dw input_at_pos 
493f			; | | dw input_cur_flash 
493f			; | | dw input_cur_onoff 
493f			; | | dw input_cursor 
493f			; | | dw input_display_size 
493f			; | | dw input_len 
493f			; | | dw input_ptr 
493f			; | | dw input_size 
493f			; | | dw input_start 
493f			; | | ; 30 
493f			; | | dw input_str 
493f			; | | dw input_under_cursor 
493f			; | | dw os_cli_cmd 
493f			; | | dw os_cur_ptr 
493f			; | | dw os_current_i 
493f			; | | dw os_input 
493f			; | | dw os_last_cmd 
493f			; | | dw os_last_new_uword 
493f			; | | dw debug_vector 
493f			; | | dw os_view_hl 
493f			; | | ;40 
493f			; | | dw os_word_scratch 
493f			; | | dw portbctl 
493f			; | | dw portbdata 
493f			; | | dw spi_cartdev 
493f			; | | dw spi_cartdev2 
493f			; | | dw spi_clktime 
493f			; | | dw spi_device 
493f			; | | dw spi_device_id 
493f			; | | dw spi_portbyte 
493f			; | | dw stackstore 
493f			; | | ; 50 
493f			; | | if STORAGE_SE 
493f			; | | dw storage_actl 
493f			; | | dw storage_adata 
493f			; | | else 
493f			; | | dw 0 
493f			; | | dw 0 
493f			; | | endif 
493f			; | | dw storage_append 
493f			; | | if STORAGE_SE 
493f			; | | dw storage_bctl 
493f			; | | else 
493f			; | | dw 0 
493f			; | | endif 
493f			; | | dw store_bank_active 
493f			; | | dw store_filecache 
493f			; | | dw store_longread 
493f			; | | dw store_openaddr 
493f			; | | dw store_openext 
493f			; | | dw store_openmaxext 
493f			; | | ; 60 
493f			; | | dw store_page 
493f			; | | dw store_readbuf 
493f			; | | dw store_readcont 
493f			; | | dw store_readptr 
493f			; | | dw store_tmpext 
493f			; | | dw store_tmpid 
493f			; | | dw store_tmppageid 
493f			; | | dw malloc 
493f			; | | dw free 
493f			; | | dw cin 
493f			; | | ; 70 
493f			; | | dw cin_wait 
493f			; | | dw forth_push_numhl 
493f			; | | dw forth_push_str 
493f			; | | ``` 
493f			 
493f					if DEBUG_FORTH_WORDS_KEY 
493f						DMARK "SYM" 
493f f5				push af  
4940 3a 54 49			ld a, (.dmark)  
4943 32 6b ee			ld (debug_mark),a  
4946 3a 55 49			ld a, (.dmark+1)  
4949 32 6c ee			ld (debug_mark+1),a  
494c 3a 56 49			ld a, (.dmark+2)  
494f 32 6d ee			ld (debug_mark+2),a  
4952 18 03			jr .pastdmark  
4954 ..			.dmark: db "SYM"  
4957 f1			.pastdmark: pop af  
4958			endm  
# End of macro DMARK
4958						CALLMONITOR 
4958 cd 6f ee			call debug_vector  
495b				endm  
# End of macro CALLMONITOR
495b					endif 
495b			 
495b					FORTH_DSP_VALUEHL 
495b cd 7e 1d			call macro_dsp_valuehl 
495e				endm 
# End of macro FORTH_DSP_VALUEHL
495e			 
495e 7d					ld a, l     
495f			 
495f			 
495f					if DEBUG_FORTH_WORDS 
495f						DMARK "SY1" 
495f f5				push af  
4960 3a 74 49			ld a, (.dmark)  
4963 32 6b ee			ld (debug_mark),a  
4966 3a 75 49			ld a, (.dmark+1)  
4969 32 6c ee			ld (debug_mark+1),a  
496c 3a 76 49			ld a, (.dmark+2)  
496f 32 6d ee			ld (debug_mark+2),a  
4972 18 03			jr .pastdmark  
4974 ..			.dmark: db "SY1"  
4977 f1			.pastdmark: pop af  
4978			endm  
# End of macro DMARK
4978						CALLMONITOR 
4978 cd 6f ee			call debug_vector  
497b				endm  
# End of macro CALLMONITOR
497b					endif 
497b					 
497b f5					push af	 
497c					FORTH_DSP_POP 
497c cd 36 1e			call macro_forth_dsp_pop 
497f				endm 
# End of macro FORTH_DSP_POP
497f f1					pop af 
4980			 
4980 cb 27				sla a  
4982				 
4982					 
4982					if DEBUG_FORTH_WORDS 
4982						DMARK "SY" 
4982 f5				push af  
4983 3a 97 49			ld a, (.dmark)  
4986 32 6b ee			ld (debug_mark),a  
4989 3a 98 49			ld a, (.dmark+1)  
498c 32 6c ee			ld (debug_mark+1),a  
498f 3a 99 49			ld a, (.dmark+2)  
4992 32 6d ee			ld (debug_mark+2),a  
4995 18 02			jr .pastdmark  
4997 ..			.dmark: db "SY"  
4999 f1			.pastdmark: pop af  
499a			endm  
# End of macro DMARK
499a						CALLMONITOR 
499a cd 6f ee			call debug_vector  
499d				endm  
# End of macro CALLMONITOR
499d					endif 
499d			 
499d 21 ac 49				ld hl, sym_table 
49a0 cd f2 0d				call addatohl 
49a3 cd b6 1e				call loadwordinhl 
49a6 cd 79 1b				call forth_push_numhl 
49a9			 
49a9			 
49a9				       NEXTW 
49a9 c3 34 1f			jp macro_next 
49ac				endm 
# End of macro NEXTW
49ac			 
49ac			sym_table: 
49ac			 
49ac			; 0 
49ac ac 49		dw sym_table 
49ae 72 ee		dw nmi_vector 
49b0 3c ea		dw cli_autodisplay 
49b2 ee e9		dw cli_data_sp 
49b4 28 e8		dw cli_data_stack 
49b6 f0 e9		dw cli_loop_sp 
49b8 2a e9		dw cli_loop_stack 
49ba 28 ea		dw cli_var_array 
49bc c5 eb		dw cursor_col 
49be c3 eb		dw cursor_ptr 
49c0			; 10 
49c0 c4 eb		dw cursor_row 
49c2 6b ee		dw debug_mark 
49c4 b1 ed		dw display_fb0 
49c6 10 ed		dw display_fb1 
49c8 ce eb		dw display_fb2 
49ca 6f ec		dw display_fb3 
49cc cc eb		dw display_fb_active 
49ce c0 e3		dw execscratch 
49d0 5e ea		dw f_cursor_ptr 
49d2 75 ee		dw hardware_word 
49d4			;20 
49d4 62 ee		dw input_at_cursor 
49d6 64 ee		dw input_at_pos 
49d8 60 ee		dw input_cur_flash 
49da 5f ee		dw input_cur_onoff 
49dc 55 ee		dw input_cursor 
49de 65 ee		dw input_display_size 
49e0 5a ee		dw input_len 
49e2 69 ee		dw input_ptr 
49e4 66 ee		dw input_size 
49e6 67 ee		dw input_start 
49e8			; 30 
49e8 1f 0e		dw input_str 
49ea 63 ee		dw input_under_cursor 
49ec e8 e5		dw os_cli_cmd 
49ee e4 e5		dw os_cur_ptr 
49f0 e6 e5		dw os_current_i 
49f2 bf e4		dw os_input 
49f4 e7 e6		dw os_last_cmd 
49f6 be e5		dw os_last_new_uword 
49f8 6f ee		dw debug_vector 
49fa a3 e2		dw os_view_hl 
49fc			;40 
49fc c6 e5		dw os_word_scratch 
49fe c3 00		dw portbctl 
4a00 c1 00		dw portbdata 
4a02 63 ea		dw spi_cartdev 
4a04 62 ea		dw spi_cartdev2 
4a06 64 ea		dw spi_clktime 
4a08 60 ea		dw spi_device 
4a0a 5f ea		dw spi_device_id 
4a0c 61 ea		dw spi_portbyte 
4a0e a7 eb		dw stackstore 
4a10			; 50 
4a10			if STORAGE_SE 
4a10			dw storage_actl 
4a10			dw storage_adata 
4a10			else 
4a10 00 00		dw 0 
4a12 00 00		dw 0 
4a14			endif 
4a14 74 09		dw storage_append 
4a16			if STORAGE_SE 
4a16			dw storage_bctl 
4a16			else 
4a16 00 00		dw 0 
4a18			endif 
4a18 93 eb		dw store_bank_active 
4a1a 67 ea		dw store_filecache 
4a1c 75 ea		dw store_longread 
4a1e 6b ea		dw store_openaddr 
4a20 6a ea		dw store_openext 
4a22 69 ea		dw store_openmaxext 
4a24			; 60 
4a24 7a ea		dw store_page 
4a26 76 ea		dw store_readbuf 
4a28 6d ea		dw store_readcont 
4a2a 78 ea		dw store_readptr 
4a2c 6d ea		dw store_tmpext 
4a2e 6e ea		dw store_tmpid 
4a30 65 ea		dw store_tmppageid 
4a32 cd 11		dw malloc 
4a34 97 12		dw free 
4a36 70 5e		dw cin 
4a38			; 70 
4a38 68 5e		dw cin_wait 
4a3a 79 1b		dw forth_push_numhl 
4a3c e7 1b		dw forth_push_str 
4a3e			 
4a3e			 
4a3e			.ENDCONST: 
4a3e			 
4a3e			; eof 
4a3e			 
4a3e			 
# End of file forth_words_const.asm
4a3e			 
4a3e			if STORAGE_SE 
4a3e			   	include "forth_words_storage.asm" 
4a3e			endif 
4a3e				include "forth_words_device.asm" 
4a3e			; Device related words 
4a3e			 
4a3e			; | ## Device Words 
4a3e			 
4a3e			;if SOUND_ENABLE 
4a3e			;.NOTE: 
4a3e			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4a3e			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
4a3e			;		if DEBUG_FORTH_WORDS_KEY 
4a3e			;			DMARK "NTE" 
4a3e			;			CALLMONITOR 
4a3e			;		endif 
4a3e			; 
4a3e			;	 
4a3e			; 
4a3e			;		NEXTW 
4a3e			;.AFTERSOUND: 
4a3e			;endif 
4a3e			 
4a3e			 
4a3e			USE_GPIO: equ 0 
4a3e			 
4a3e			if USE_GPIO 
4a3e			.GP1: 
4a3e				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4a3e			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
4a3e					NEXTW 
4a3e			.GP2: 
4a3e				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4a3e			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
4a3e			 
4a3e					NEXTW 
4a3e			 
4a3e			.GP3: 
4a3e				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4a3e			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
4a3e			 
4a3e					NEXTW 
4a3e			 
4a3e			.GP4: 
4a3e				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4a3e			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
4a3e			 
4a3e					NEXTW 
4a3e			.SIN: 
4a3e			 
4a3e			 
4a3e			endif 
4a3e			 
4a3e			 
4a3e				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4a3e 33				db WORD_SYS_CORE+31             
4a3f 73 4a			dw .SOUT            
4a41 03				db 2 + 1 
4a42 .. 00			db "IN",0              
4a45				endm 
# End of macro CWHEAD
4a45			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4a45					if DEBUG_FORTH_WORDS_KEY 
4a45						DMARK "IN." 
4a45 f5				push af  
4a46 3a 5a 4a			ld a, (.dmark)  
4a49 32 6b ee			ld (debug_mark),a  
4a4c 3a 5b 4a			ld a, (.dmark+1)  
4a4f 32 6c ee			ld (debug_mark+1),a  
4a52 3a 5c 4a			ld a, (.dmark+2)  
4a55 32 6d ee			ld (debug_mark+2),a  
4a58 18 03			jr .pastdmark  
4a5a ..			.dmark: db "IN."  
4a5d f1			.pastdmark: pop af  
4a5e			endm  
# End of macro DMARK
4a5e						CALLMONITOR 
4a5e cd 6f ee			call debug_vector  
4a61				endm  
# End of macro CALLMONITOR
4a61					endif 
4a61					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a61 cd 7e 1d			call macro_dsp_valuehl 
4a64				endm 
# End of macro FORTH_DSP_VALUEHL
4a64			 
4a64 e5					push hl 
4a65			 
4a65					; destroy value TOS 
4a65			 
4a65					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a65 cd 36 1e			call macro_forth_dsp_pop 
4a68				endm 
# End of macro FORTH_DSP_POP
4a68			 
4a68					; one value on hl get other one back 
4a68			 
4a68 c1					pop bc 
4a69			 
4a69					; do the sub 
4a69			;		ex de, hl 
4a69			 
4a69 ed 68				in l,(c) 
4a6b			 
4a6b					; save it 
4a6b			 
4a6b 26 00				ld h,0 
4a6d			 
4a6d					; TODO push value back onto stack for another op etc 
4a6d			 
4a6d cd 79 1b				call forth_push_numhl 
4a70					NEXTW 
4a70 c3 34 1f			jp macro_next 
4a73				endm 
# End of macro NEXTW
4a73			.SOUT: 
4a73				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4a73 34				db WORD_SYS_CORE+32             
4a74 c6 4a			dw .SPIO            
4a76 04				db 3 + 1 
4a77 .. 00			db "OUT",0              
4a7b				endm 
# End of macro CWHEAD
4a7b			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4a7b					if DEBUG_FORTH_WORDS_KEY 
4a7b						DMARK "OUT" 
4a7b f5				push af  
4a7c 3a 90 4a			ld a, (.dmark)  
4a7f 32 6b ee			ld (debug_mark),a  
4a82 3a 91 4a			ld a, (.dmark+1)  
4a85 32 6c ee			ld (debug_mark+1),a  
4a88 3a 92 4a			ld a, (.dmark+2)  
4a8b 32 6d ee			ld (debug_mark+2),a  
4a8e 18 03			jr .pastdmark  
4a90 ..			.dmark: db "OUT"  
4a93 f1			.pastdmark: pop af  
4a94			endm  
# End of macro DMARK
4a94						CALLMONITOR 
4a94 cd 6f ee			call debug_vector  
4a97				endm  
# End of macro CALLMONITOR
4a97					endif 
4a97			 
4a97					; get port 
4a97			 
4a97					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a97 cd 7e 1d			call macro_dsp_valuehl 
4a9a				endm 
# End of macro FORTH_DSP_VALUEHL
4a9a			 
4a9a e5					push hl 
4a9b			 
4a9b					; destroy value TOS 
4a9b			 
4a9b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a9b cd 36 1e			call macro_forth_dsp_pop 
4a9e				endm 
# End of macro FORTH_DSP_POP
4a9e			 
4a9e					; get byte to send 
4a9e			 
4a9e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a9e cd 7e 1d			call macro_dsp_valuehl 
4aa1				endm 
# End of macro FORTH_DSP_VALUEHL
4aa1			 
4aa1			;		push hl 
4aa1			 
4aa1					; destroy value TOS 
4aa1			 
4aa1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aa1 cd 36 1e			call macro_forth_dsp_pop 
4aa4				endm 
# End of macro FORTH_DSP_POP
4aa4			 
4aa4					; one value on hl get other one back 
4aa4			 
4aa4			;		pop hl 
4aa4			 
4aa4 c1					pop bc 
4aa5			 
4aa5					if DEBUG_FORTH_WORDS 
4aa5						DMARK "OUT" 
4aa5 f5				push af  
4aa6 3a ba 4a			ld a, (.dmark)  
4aa9 32 6b ee			ld (debug_mark),a  
4aac 3a bb 4a			ld a, (.dmark+1)  
4aaf 32 6c ee			ld (debug_mark+1),a  
4ab2 3a bc 4a			ld a, (.dmark+2)  
4ab5 32 6d ee			ld (debug_mark+2),a  
4ab8 18 03			jr .pastdmark  
4aba ..			.dmark: db "OUT"  
4abd f1			.pastdmark: pop af  
4abe			endm  
# End of macro DMARK
4abe						CALLMONITOR 
4abe cd 6f ee			call debug_vector  
4ac1				endm  
# End of macro CALLMONITOR
4ac1					endif 
4ac1			 
4ac1 ed 69				out (c), l 
4ac3			 
4ac3					NEXTW 
4ac3 c3 34 1f			jp macro_next 
4ac6				endm 
# End of macro NEXTW
4ac6			 
4ac6			 
4ac6			.SPIO: 
4ac6			 
4ac6			if STORAGE_SE 
4ac6				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4ac6			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4ac6			 
4ac6					call spi_ce_low 
4ac6			    NEXTW 
4ac6			 
4ac6			.SPICEH: 
4ac6				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4ac6			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4ac6			 
4ac6					call spi_ce_high 
4ac6			    NEXTW 
4ac6			 
4ac6			 
4ac6			.SPIOb: 
4ac6			 
4ac6				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4ac6			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4ac6			 
4ac6					if DEBUG_FORTH_WORDS_KEY 
4ac6						DMARK "SPo" 
4ac6						CALLMONITOR 
4ac6					endif 
4ac6					; get port 
4ac6			 
4ac6			 
4ac6					; get byte to send 
4ac6			 
4ac6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ac6			 
4ac6			;		push hl    ; u1  
4ac6			 
4ac6					; destroy value TOS 
4ac6			 
4ac6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ac6			 
4ac6					; one value on hl get other one back 
4ac6			 
4ac6			;		pop hl   ; u2 - addr 
4ac6			 
4ac6					; TODO Send SPI byte 
4ac6			 
4ac6			;		push hl 
4ac6			;		call spi_ce_low 
4ac6			;		pop hl 
4ac6					ld a, l 
4ac6					call spi_send_byte 
4ac6			;		call spi_ce_high 
4ac6			 
4ac6					NEXTW 
4ac6			 
4ac6			.SPII: 
4ac6				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4ac6			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4ac6					if DEBUG_FORTH_WORDS_KEY 
4ac6						DMARK "SPi" 
4ac6						CALLMONITOR 
4ac6					endif 
4ac6			 
4ac6					; TODO Get SPI byte 
4ac6			 
4ac6					call spi_read_byte 
4ac6			 
4ac6					if DEBUG_FORTH_WORDS 
4ac6						DMARK "Si2" 
4ac6						CALLMONITOR 
4ac6					endif 
4ac6					ld h, 0 
4ac6					ld l, a 
4ac6					if DEBUG_FORTH_WORDS 
4ac6						DMARK "Si3" 
4ac6						CALLMONITOR 
4ac6					endif 
4ac6					call forth_push_numhl 
4ac6			 
4ac6					NEXTW 
4ac6			 
4ac6			 
4ac6			 
4ac6			.SESEL: 
4ac6				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4ac6			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4ac6					if DEBUG_FORTH_WORDS_KEY 
4ac6						DMARK "BNK" 
4ac6						CALLMONITOR 
4ac6					endif 
4ac6			 
4ac6					ld a, 255 
4ac6					ld (spi_cartdev), a 
4ac6			 
4ac6					; get bank 
4ac6			 
4ac6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ac6			 
4ac6			;		push hl 
4ac6			 
4ac6					; destroy value TOS 
4ac6			 
4ac6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ac6			 
4ac6					; one value on hl get other one back 
4ac6			 
4ac6			;		pop hl 
4ac6			 
4ac6			 
4ac6					ld c, SPI_CE_HIGH 
4ac6					ld b, '0'    ; human readable bank number 
4ac6			 
4ac6					ld a, l 
4ac6			 
4ac6					if DEBUG_FORTH_WORDS 
4ac6						DMARK "BNK" 
4ac6						CALLMONITOR 
4ac6					endif 
4ac6			 
4ac6					; active low 
4ac6			 
4ac6					cp 0 
4ac6					jr z, .bset 
4ac6					cp 1 
4ac6					jr nz, .b2 
4ac6					res 0, c 
4ac6					ld b, '1'    ; human readable bank number 
4ac6			.b2:		cp 2 
4ac6					jr nz, .b3 
4ac6					res 1, c 
4ac6					ld b, '2'    ; human readable bank number 
4ac6			.b3:		cp 3 
4ac6					jr nz, .b4 
4ac6					res 2, c 
4ac6					ld b, '3'    ; human readable bank number 
4ac6			.b4:		cp 4 
4ac6					jr nz, .b5 
4ac6					res 3, c 
4ac6					ld b, '4'    ; human readable bank number 
4ac6			.b5:		cp 5 
4ac6					jr nz, .bset 
4ac6					res 4, c 
4ac6					ld b, '5'    ; human readable bank number 
4ac6			 
4ac6			.bset: 
4ac6					ld a, c 
4ac6					ld (spi_device),a 
4ac6					ld a, b 
4ac6					ld (spi_device_id),a 
4ac6					if DEBUG_FORTH_WORDS 
4ac6						DMARK "BN2" 
4ac6						CALLMONITOR 
4ac6					endif 
4ac6			 
4ac6					; set default SPI clk pulse time as disabled for BANK use 
4ac6			 
4ac6					ld a, 0 
4ac6					ld (spi_clktime), a 
4ac6			 
4ac6					NEXTW 
4ac6			 
4ac6			.CARTDEV: 
4ac6				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4ac6			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4ac6					if DEBUG_FORTH_WORDS_KEY 
4ac6						DMARK "CDV" 
4ac6						CALLMONITOR 
4ac6					endif 
4ac6			 
4ac6					; disable se storage bank selection 
4ac6			 
4ac6					ld a, SPI_CE_HIGH		; ce high 
4ac6					ld (spi_device), a 
4ac6			 
4ac6					; get bank 
4ac6			 
4ac6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ac6			 
4ac6			;		push hl 
4ac6			 
4ac6					; destroy value TOS 
4ac6			 
4ac6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ac6			 
4ac6					; one value on hl get other one back 
4ac6			 
4ac6			;		pop hl 
4ac6			 
4ac6					; active low 
4ac6			 
4ac6					ld c, 255 
4ac6			 
4ac6					ld a, l 
4ac6					if DEBUG_FORTH_WORDS 
4ac6						DMARK "CDV" 
4ac6						CALLMONITOR 
4ac6					endif 
4ac6					cp 0 
4ac6					jr z, .cset 
4ac6					cp 1 
4ac6					jr nz, .c2 
4ac6					res 0, c 
4ac6			.c2:		cp 2 
4ac6					jr nz, .c3 
4ac6					res 1, c 
4ac6			.c3:		cp 3 
4ac6					jr nz, .c4 
4ac6					res 2, c 
4ac6			.c4:		cp 4 
4ac6					jr nz, .c5 
4ac6					res 3, c 
4ac6			.c5:		cp 5 
4ac6					jr nz, .c6 
4ac6					res 4, c 
4ac6			.c6:		cp 6 
4ac6					jr nz, .c7 
4ac6					res 5, c 
4ac6			.c7:		cp 7 
4ac6					jr nz, .c8 
4ac6					res 6, c 
4ac6			.c8:		cp 8 
4ac6					jr nz, .cset 
4ac6					res 7, c 
4ac6			.cset:		ld a, c 
4ac6					ld (spi_cartdev),a 
4ac6			 
4ac6					if DEBUG_FORTH_WORDS 
4ac6						DMARK "CD2" 
4ac6						CALLMONITOR 
4ac6					endif 
4ac6			 
4ac6					; set default SPI clk pulse time as 10ms for CARTDEV use 
4ac6			 
4ac6					ld a, $0a 
4ac6					ld (spi_clktime), a 
4ac6					NEXTW 
4ac6			endif 
4ac6			 
4ac6			.ENDDEVICE: 
4ac6			; eof 
4ac6			 
# End of file forth_words_device.asm
4ac6			 
4ac6			; var handler 
4ac6			 
4ac6			 
4ac6			.VARS: 
4ac6				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
4ac6 77				db WORD_SYS_CORE+99             
4ac7 77 4b			dw .V0            
4ac9 04				db 3 + 1 
4aca .. 00			db "VAR",0              
4ace				endm 
# End of macro CWHEAD
4ace			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4ace			;| 
4ace			;| The variable name should consist of a single letter. e.g. "a" 
4ace			;! If a full string is passed then only the first char is looked at 
4ace			;| Any other char could exceed bounds checks!  
4ace			 
4ace					if DEBUG_FORTH_WORDS_KEY 
4ace						DMARK "VAR" 
4ace f5				push af  
4acf 3a e3 4a			ld a, (.dmark)  
4ad2 32 6b ee			ld (debug_mark),a  
4ad5 3a e4 4a			ld a, (.dmark+1)  
4ad8 32 6c ee			ld (debug_mark+1),a  
4adb 3a e5 4a			ld a, (.dmark+2)  
4ade 32 6d ee			ld (debug_mark+2),a  
4ae1 18 03			jr .pastdmark  
4ae3 ..			.dmark: db "VAR"  
4ae6 f1			.pastdmark: pop af  
4ae7			endm  
# End of macro DMARK
4ae7						CALLMONITOR 
4ae7 cd 6f ee			call debug_vector  
4aea				endm  
# End of macro CALLMONITOR
4aea					endif 
4aea			 
4aea					FORTH_DSP_VALUEHL 
4aea cd 7e 1d			call macro_dsp_valuehl 
4aed				endm 
# End of macro FORTH_DSP_VALUEHL
4aed			 
4aed 7e					ld a, (hl)    ; get first char on of the string 
4aee			 
4aee			 
4aee					if DEBUG_FORTH_WORDS 
4aee						DMARK "VR1" 
4aee f5				push af  
4aef 3a 03 4b			ld a, (.dmark)  
4af2 32 6b ee			ld (debug_mark),a  
4af5 3a 04 4b			ld a, (.dmark+1)  
4af8 32 6c ee			ld (debug_mark+1),a  
4afb 3a 05 4b			ld a, (.dmark+2)  
4afe 32 6d ee			ld (debug_mark+2),a  
4b01 18 03			jr .pastdmark  
4b03 ..			.dmark: db "VR1"  
4b06 f1			.pastdmark: pop af  
4b07			endm  
# End of macro DMARK
4b07						CALLMONITOR 
4b07 cd 6f ee			call debug_vector  
4b0a				endm  
# End of macro CALLMONITOR
4b0a					endif 
4b0a					 
4b0a f5					push af	 
4b0b					FORTH_DSP_POP 
4b0b cd 36 1e			call macro_forth_dsp_pop 
4b0e				endm 
# End of macro FORTH_DSP_POP
4b0e f1					pop af 
4b0f			 
4b0f					; convert to upper 
4b0f			 
4b0f cd 67 10				call to_upper 
4b12					if DEBUG_FORTH_WORDS 
4b12						DMARK "Vaa" 
4b12 f5				push af  
4b13 3a 27 4b			ld a, (.dmark)  
4b16 32 6b ee			ld (debug_mark),a  
4b19 3a 28 4b			ld a, (.dmark+1)  
4b1c 32 6c ee			ld (debug_mark+1),a  
4b1f 3a 29 4b			ld a, (.dmark+2)  
4b22 32 6d ee			ld (debug_mark+2),a  
4b25 18 03			jr .pastdmark  
4b27 ..			.dmark: db "Vaa"  
4b2a f1			.pastdmark: pop af  
4b2b			endm  
# End of macro DMARK
4b2b						CALLMONITOR 
4b2b cd 6f ee			call debug_vector  
4b2e				endm  
# End of macro CALLMONITOR
4b2e					endif 
4b2e 06 41				ld b, 'A' 
4b30 90					sub b			; set offset 
4b31					if DEBUG_FORTH_WORDS 
4b31						DMARK "Vbb" 
4b31 f5				push af  
4b32 3a 46 4b			ld a, (.dmark)  
4b35 32 6b ee			ld (debug_mark),a  
4b38 3a 47 4b			ld a, (.dmark+1)  
4b3b 32 6c ee			ld (debug_mark+1),a  
4b3e 3a 48 4b			ld a, (.dmark+2)  
4b41 32 6d ee			ld (debug_mark+2),a  
4b44 18 03			jr .pastdmark  
4b46 ..			.dmark: db "Vbb"  
4b49 f1			.pastdmark: pop af  
4b4a			endm  
# End of macro DMARK
4b4a						CALLMONITOR 
4b4a cd 6f ee			call debug_vector  
4b4d				endm  
# End of macro CALLMONITOR
4b4d					endif 
4b4d cb 27				sla a  
4b4f				 
4b4f					 
4b4f					if DEBUG_FORTH_WORDS 
4b4f						DMARK "VR2" 
4b4f f5				push af  
4b50 3a 64 4b			ld a, (.dmark)  
4b53 32 6b ee			ld (debug_mark),a  
4b56 3a 65 4b			ld a, (.dmark+1)  
4b59 32 6c ee			ld (debug_mark+1),a  
4b5c 3a 66 4b			ld a, (.dmark+2)  
4b5f 32 6d ee			ld (debug_mark+2),a  
4b62 18 03			jr .pastdmark  
4b64 ..			.dmark: db "VR2"  
4b67 f1			.pastdmark: pop af  
4b68			endm  
# End of macro DMARK
4b68						CALLMONITOR 
4b68 cd 6f ee			call debug_vector  
4b6b				endm  
# End of macro CALLMONITOR
4b6b					endif 
4b6b			 
4b6b 21 f4 e9				ld hl, cli_var_array2 
4b6e cd f2 0d				call addatohl 
4b71 cd 79 1b				call forth_push_numhl 
4b74			 
4b74			 
4b74				       NEXTW 
4b74 c3 34 1f			jp macro_next 
4b77				endm 
# End of macro NEXTW
4b77			.V0: 
4b77				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4b77 78				db WORD_SYS_CORE+100             
4b78 8f 4b			dw .V0Q            
4b7a 04				db 3 + 1 
4b7b .. 00			db "V0!",0              
4b7f				endm 
# End of macro CWHEAD
4b7f			;| V0! ( u1 -- )  Store value to v0  | DONE 
4b7f			 
4b7f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b7f cd 7e 1d			call macro_dsp_valuehl 
4b82				endm 
# End of macro FORTH_DSP_VALUEHL
4b82			 
4b82 11 28 ea				ld de, cli_var_array 
4b85			 
4b85 eb					ex de, hl 
4b86 73					ld (hl), e 
4b87 23					inc hl 
4b88 72					ld (hl), d 
4b89			 
4b89					; destroy value TOS 
4b89			 
4b89					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b89 cd 36 1e			call macro_forth_dsp_pop 
4b8c				endm 
# End of macro FORTH_DSP_POP
4b8c			 
4b8c				       NEXTW 
4b8c c3 34 1f			jp macro_next 
4b8f				endm 
# End of macro NEXTW
4b8f			.V0Q: 
4b8f				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4b8f 79				db WORD_SYS_CORE+101             
4b90 a0 4b			dw .V1S            
4b92 04				db 3 + 1 
4b93 .. 00			db "V0@",0              
4b97				endm 
# End of macro CWHEAD
4b97			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4b97 2a 28 ea				ld hl, (cli_var_array) 
4b9a cd 79 1b				call forth_push_numhl 
4b9d			 
4b9d				       NEXTW 
4b9d c3 34 1f			jp macro_next 
4ba0				endm 
# End of macro NEXTW
4ba0			.V1S: 
4ba0				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4ba0 7a				db WORD_SYS_CORE+102             
4ba1 b8 4b			dw .V1Q            
4ba3 04				db 3 + 1 
4ba4 .. 00			db "V1!",0              
4ba8				endm 
# End of macro CWHEAD
4ba8			;| V1! ( u1 -- )  Store value to v1 | DONE 
4ba8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ba8 cd 7e 1d			call macro_dsp_valuehl 
4bab				endm 
# End of macro FORTH_DSP_VALUEHL
4bab			 
4bab 11 2a ea				ld de, cli_var_array+2 
4bae				 
4bae eb					ex de, hl 
4baf 73					ld (hl), e 
4bb0 23					inc hl 
4bb1 72					ld (hl), d 
4bb2			 
4bb2					; destroy value TOS 
4bb2			 
4bb2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bb2 cd 36 1e			call macro_forth_dsp_pop 
4bb5				endm 
# End of macro FORTH_DSP_POP
4bb5				       NEXTW 
4bb5 c3 34 1f			jp macro_next 
4bb8				endm 
# End of macro NEXTW
4bb8			.V1Q: 
4bb8				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4bb8 7b				db WORD_SYS_CORE+103             
4bb9 c9 4b			dw .V2S            
4bbb 04				db 3 + 1 
4bbc .. 00			db "V1@",0              
4bc0				endm 
# End of macro CWHEAD
4bc0			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4bc0 2a 2a ea				ld hl, (cli_var_array+2) 
4bc3 cd 79 1b				call forth_push_numhl 
4bc6				       NEXTW 
4bc6 c3 34 1f			jp macro_next 
4bc9				endm 
# End of macro NEXTW
4bc9			.V2S: 
4bc9				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4bc9 7c				db WORD_SYS_CORE+104             
4bca e1 4b			dw .V2Q            
4bcc 04				db 3 + 1 
4bcd .. 00			db "V2!",0              
4bd1				endm 
# End of macro CWHEAD
4bd1			;| V2! ( u1 -- )  Store value to v2 | DONE 
4bd1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bd1 cd 7e 1d			call macro_dsp_valuehl 
4bd4				endm 
# End of macro FORTH_DSP_VALUEHL
4bd4			 
4bd4 11 2c ea				ld de, cli_var_array+4 
4bd7				 
4bd7 eb					ex de, hl 
4bd8 73					ld (hl), e 
4bd9 23					inc hl 
4bda 72					ld (hl), d 
4bdb			 
4bdb					; destroy value TOS 
4bdb			 
4bdb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bdb cd 36 1e			call macro_forth_dsp_pop 
4bde				endm 
# End of macro FORTH_DSP_POP
4bde				       NEXTW 
4bde c3 34 1f			jp macro_next 
4be1				endm 
# End of macro NEXTW
4be1			.V2Q: 
4be1				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4be1 7d				db WORD_SYS_CORE+105             
4be2 f2 4b			dw .V3S            
4be4 04				db 3 + 1 
4be5 .. 00			db "V2@",0              
4be9				endm 
# End of macro CWHEAD
4be9			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4be9 2a 2c ea				ld hl, (cli_var_array+4) 
4bec cd 79 1b				call forth_push_numhl 
4bef				       NEXTW 
4bef c3 34 1f			jp macro_next 
4bf2				endm 
# End of macro NEXTW
4bf2			.V3S: 
4bf2				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4bf2 7c				db WORD_SYS_CORE+104             
4bf3 0a 4c			dw .V3Q            
4bf5 04				db 3 + 1 
4bf6 .. 00			db "V3!",0              
4bfa				endm 
# End of macro CWHEAD
4bfa			;| V3! ( u1 -- )  Store value to v3 | DONE 
4bfa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bfa cd 7e 1d			call macro_dsp_valuehl 
4bfd				endm 
# End of macro FORTH_DSP_VALUEHL
4bfd			 
4bfd 11 2e ea				ld de, cli_var_array+6 
4c00				 
4c00 eb					ex de, hl 
4c01 73					ld (hl), e 
4c02 23					inc hl 
4c03 72					ld (hl), d 
4c04			 
4c04					; destroy value TOS 
4c04			 
4c04					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c04 cd 36 1e			call macro_forth_dsp_pop 
4c07				endm 
# End of macro FORTH_DSP_POP
4c07				       NEXTW 
4c07 c3 34 1f			jp macro_next 
4c0a				endm 
# End of macro NEXTW
4c0a			.V3Q: 
4c0a				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4c0a 7d				db WORD_SYS_CORE+105             
4c0b 1b 4c			dw .END            
4c0d 04				db 3 + 1 
4c0e .. 00			db "V3@",0              
4c12				endm 
# End of macro CWHEAD
4c12			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4c12 2a 2e ea				ld hl, (cli_var_array+6) 
4c15 cd 79 1b				call forth_push_numhl 
4c18				       NEXTW 
4c18 c3 34 1f			jp macro_next 
4c1b				endm 
# End of macro NEXTW
4c1b			 
4c1b			 
4c1b			 
4c1b			 
4c1b			 
4c1b			; end of dict marker 
4c1b			 
4c1b 00			.END:    db WORD_SYS_END 
4c1c 00 00			dw 0 
4c1e 00				db 0 
4c1f			 
4c1f			; use to jp here for user dict words to save on macro expansion  
4c1f			 
4c1f			user_dict_next: 
4c1f				NEXTW 
4c1f c3 34 1f			jp macro_next 
4c22				endm 
# End of macro NEXTW
4c22			 
4c22			 
4c22			user_exec: 
4c22				;    ld hl, <word code> 
4c22				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4c22				;    call forthexec 
4c22				;    jp user_dict_next   (NEXT) 
4c22			        ;    <word code bytes> 
4c22 eb				ex de, hl 
4c23 2a c2 e5			ld hl,(os_tok_ptr) 
4c26				 
4c26				FORTH_RSP_NEXT 
4c26 cd 20 1b			call macro_forth_rsp_next 
4c29				endm 
# End of macro FORTH_RSP_NEXT
4c29			 
4c29			if DEBUG_FORTH_UWORD 
4c29						DMARK "UEX" 
4c29 f5				push af  
4c2a 3a 3e 4c			ld a, (.dmark)  
4c2d 32 6b ee			ld (debug_mark),a  
4c30 3a 3f 4c			ld a, (.dmark+1)  
4c33 32 6c ee			ld (debug_mark+1),a  
4c36 3a 40 4c			ld a, (.dmark+2)  
4c39 32 6d ee			ld (debug_mark+2),a  
4c3c 18 03			jr .pastdmark  
4c3e ..			.dmark: db "UEX"  
4c41 f1			.pastdmark: pop af  
4c42			endm  
# End of macro DMARK
4c42				CALLMONITOR 
4c42 cd 6f ee			call debug_vector  
4c45				endm  
# End of macro CALLMONITOR
4c45			endif 
4c45			 
4c45			 
4c45			 
4c45 eb				ex de, hl 
4c46 22 c2 e5			ld (os_tok_ptr), hl 
4c49				 
4c49				; Don't use next - Skips the first word in uword. 
4c49			 
4c49 c3 c5 1f			jp exec1 
4c4c			;	NEXT 
4c4c			 
4c4c			 
4c4c			; eof 
# End of file forth_wordsv4.asm
4c4c			endif 
4c4c			;;;;;;;;;;;;;; Debug code 
4c4c			 
4c4c			 
4c4c			;if DEBUG_FORTH_PARSE 
4c4c .. 00		.nowordfound: db "No match",0 
4c55 .. 00		.compword:	db "Comparing word ",0 
4c65 .. 00		.nextwordat:	db "Next word at",0 
4c72 .. 00		.charmatch:	db "Char match",0 
4c7d			;endif 
4c7d			if DEBUG_FORTH_JP 
4c7d			.foundword:	db "Word match. Exec..",0 
4c7d			endif 
4c7d			;if DEBUG_FORTH_PUSH 
4c7d .. 00		.enddict:	db "Dict end. Push.",0 
4c8d .. 00		.push_str:	db "Pushing string",0 
4c9c .. 00		.push_num:	db "Pushing number",0 
4cab .. 00		.data_sp:	db "SP:",0 
4caf .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4cc1 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4cd3 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4ce5			;endif 
4ce5			;if DEBUG_FORTH_MALLOC 
4ce5 .. 00		.push_malloc:	db "Malloc address",0 
4cf4			;endif 
4cf4			 
4cf4			 
4cf4			 
4cf4			; display malloc address and current data stack pointer  
4cf4			 
4cf4			malloc_error: 
4cf4 d5				push de 
4cf5 f5				push af 
4cf6 e5				push hl 
4cf7 cd c5 0b			call clear_display 
4cfa 11 1a 4d			ld de, .mallocerr 
4cfd 3e 00			ld a,0 
4cff			;	ld de,os_word_scratch 
4cff cd d8 0b			call str_at_display 
4d02 3e 11			ld a, display_row_1+17 
4d04 11 6b ee			ld de, debug_mark 
4d07 cd d8 0b			call str_at_display 
4d0a cd e8 0b			call update_display 
4d0d				;call break_point_state 
4d0d cd 68 5e			call cin_wait 
4d10			 
4d10			;	ld a, ' ' 
4d10			;	ld (os_view_disable), a 
4d10 cd fc 14			call bp_on 
4d13 e1				pop hl 
4d14 f1				pop af 
4d15 d1				pop de	 
4d16				CALLMONITOR 
4d16 cd 6f ee			call debug_vector  
4d19				endm  
# End of macro CALLMONITOR
4d19 c9				ret 
4d1a			 
4d1a .. 00		.mallocerr: 	db "Malloc Error",0 
4d27			;if DEBUG_FORTH_PUSH 
4d27			display_data_sp: 
4d27 f5				push af 
4d28			 
4d28				; see if disabled 
4d28			 
4d28			 
4d28 3a 6f ee			ld a, (debug_vector) 
4d2b fe c9			cp $C9  ; RET 
4d2d				;ld a, (os_view_disable) 
4d2d				;cp '*' 
4d2d 28 67			jr z, .skipdsp 
4d2f			 
4d2f e5				push hl 
4d30 e5				push hl 
4d31 e5			push hl 
4d32 cd c5 0b			call clear_display 
4d35 e1			pop hl 
4d36 7c				ld a,h 
4d37 21 c6 e5			ld hl, os_word_scratch 
4d3a cd fb 0f			call hexout 
4d3d e1				pop hl 
4d3e 7d				ld a,l 
4d3f 21 c8 e5			ld hl, os_word_scratch+2 
4d42 cd fb 0f			call hexout 
4d45 21 ca e5			ld hl, os_word_scratch+4 
4d48 3e 00			ld a,0 
4d4a 77				ld (hl),a 
4d4b 11 c6 e5			ld de,os_word_scratch 
4d4e 3e 28				ld a, display_row_2 
4d50 cd d8 0b				call str_at_display 
4d53 11 af 4c			ld de, .wordinhl 
4d56 3e 00			ld a, display_row_1 
4d58			 
4d58 cd d8 0b				call str_at_display 
4d5b 11 6b ee			ld de, debug_mark 
4d5e 3e 11			ld a, display_row_1+17 
4d60			 
4d60 cd d8 0b				call str_at_display 
4d63			 
4d63				; display current data stack pointer 
4d63 11 ab 4c			ld de,.data_sp 
4d66 3e 30				ld a, display_row_2 + 8 
4d68 cd d8 0b				call str_at_display 
4d6b			 
4d6b 2a ee e9			ld hl,(cli_data_sp) 
4d6e e5				push hl 
4d6f 7c				ld a,h 
4d70 21 c6 e5			ld hl, os_word_scratch 
4d73 cd fb 0f			call hexout 
4d76 e1				pop hl 
4d77 7d				ld a,l 
4d78 21 c8 e5			ld hl, os_word_scratch+2 
4d7b cd fb 0f			call hexout 
4d7e 21 ca e5			ld hl, os_word_scratch+4 
4d81 3e 00			ld a,0 
4d83 77				ld (hl),a 
4d84 11 c6 e5			ld de,os_word_scratch 
4d87 3e 33				ld a, display_row_2 + 11 
4d89 cd d8 0b				call str_at_display 
4d8c			 
4d8c			 
4d8c cd e8 0b			call update_display 
4d8f cd fd 0a			call delay1s 
4d92 cd fd 0a			call delay1s 
4d95 e1				pop hl 
4d96			.skipdsp: 
4d96 f1				pop af 
4d97 c9				ret 
4d98			 
4d98			display_data_malloc: 
4d98			 
4d98 f5				push af 
4d99 e5				push hl 
4d9a e5				push hl 
4d9b e5			push hl 
4d9c cd c5 0b			call clear_display 
4d9f e1			pop hl 
4da0 7c				ld a,h 
4da1 21 c6 e5			ld hl, os_word_scratch 
4da4 cd fb 0f			call hexout 
4da7 e1				pop hl 
4da8 7d				ld a,l 
4da9 21 c8 e5			ld hl, os_word_scratch+2 
4dac cd fb 0f			call hexout 
4daf 21 ca e5			ld hl, os_word_scratch+4 
4db2 3e 00			ld a,0 
4db4 77				ld (hl),a 
4db5 11 c6 e5			ld de,os_word_scratch 
4db8 3e 28				ld a, display_row_2 
4dba cd d8 0b				call str_at_display 
4dbd 11 e5 4c			ld de, .push_malloc 
4dc0 3e 00			ld a, display_row_1 
4dc2			 
4dc2 cd d8 0b				call str_at_display 
4dc5			 
4dc5				; display current data stack pointer 
4dc5 11 ab 4c			ld de,.data_sp 
4dc8 3e 30				ld a, display_row_2 + 8 
4dca cd d8 0b				call str_at_display 
4dcd			 
4dcd 2a ee e9			ld hl,(cli_data_sp) 
4dd0 e5				push hl 
4dd1 7c				ld a,h 
4dd2 21 c6 e5			ld hl, os_word_scratch 
4dd5 cd fb 0f			call hexout 
4dd8 e1				pop hl 
4dd9 7d				ld a,l 
4dda 21 c8 e5			ld hl, os_word_scratch+2 
4ddd cd fb 0f			call hexout 
4de0 21 ca e5			ld hl, os_word_scratch+4 
4de3 3e 00			ld a,0 
4de5 77				ld (hl),a 
4de6 11 c6 e5			ld de,os_word_scratch 
4de9 3e 33				ld a, display_row_2 + 11 
4deb cd d8 0b				call str_at_display 
4dee			 
4dee cd e8 0b			call update_display 
4df1 cd fd 0a			call delay1s 
4df4 cd fd 0a			call delay1s 
4df7 e1				pop hl 
4df8 f1				pop af 
4df9 c9				ret 
4dfa			;endif 
4dfa			 
4dfa			include "forth_autostart.asm" 
4dfa			; list of commands to perform at system start up 
4dfa			 
4dfa			startcmds: 
4dfa			;	dw test11 
4dfa			;	dw test12 
4dfa			;	dw test13 
4dfa			;	dw test14 
4dfa			;	dw test15 
4dfa			;	dw test16 
4dfa			;	dw test17 
4dfa			;	dw ifthtest1 
4dfa			;	dw ifthtest2 
4dfa			;	dw ifthtest3 
4dfa			;	dw mmtest1 
4dfa			;	dw mmtest2 
4dfa			;	dw mmtest3 
4dfa			;	dw mmtest4 
4dfa			;	dw mmtest5 
4dfa			;	dw mmtest6 
4dfa			;	dw iftest1 
4dfa			;	dw iftest2 
4dfa			;	dw iftest3 
4dfa			;	dw looptest1 
4dfa			;	dw looptest2 
4dfa			;	dw test1 
4dfa			;	dw test2 
4dfa			;	dw test3 
4dfa			;	dw test4 
4dfa			;	dw game2r 
4dfa			;	dw game2b1 
4dfa			;	dw game2b2 
4dfa			 
4dfa				; start up words that are actually useful 
4dfa			 
4dfa			;    dw spi1 
4dfa			;    dw spi2 
4dfa			;    dw spi3 
4dfa			;    dw spi4 
4dfa			;    dw spi5 
4dfa			;    dw spi6 
4dfa			;    dw spi7 
4dfa			; 
4dfa			;    dw spi8 
4dfa			;    dw spi9 
4dfa			;    dw spi10 
4dfa			 
4dfa			; file editor 
4dfa			;	dw edit1 
4dfa			;	dw edit2 
4dfa			;	dw edit3 
4dfa			 
4dfa			;	dw longread 
4dfa 1a 52			dw clrstack 
4dfc 4e 52			dw type 
4dfe			;	dw stest 
4dfe 73 52			dw strncpy 
4e00			;	dw list 
4e00 d4 52			dw start1 
4e02 e4 52			dw start2 
4e04			;	dw start3 
4e04			;	dw start3b 
4e04			;	dw start3c 
4e04			 
4e04				; (unit) testing words 
4e04			 
4e04			;	dw mtesta 
4e04			;	dw mtestb 
4e04			;	dw mtestc 
4e04			;	dw mtestd 
4e04			;	dw mteste 
4e04			 
4e04				; demo/game words 
4e04			 
4e04			;        dw game3w 
4e04			;        dw game3p 
4e04			;        dw game3sc 
4e04			;        dw game3vsi 
4e04			;        dw game3vs 
4e04				 
4e04			;	dw game2b 
4e04			;	dw game2bf 
4e04			;	dw game2mba 
4e04			;	dw game2mbas 
4e04			;	dw game2mb 
4e04			 
4e04 01 56			dw game1 
4e06 12 56			dw game1a 
4e08 74 56			dw game1b 
4e0a a9 56			dw game1c 
4e0c df 56			dw game1d 
4e0e 10 57			dw game1s 
4e10 24 57			dw game1t 
4e12 39 57			dw game1f 
4e14 6d 57			dw game1z 
4e16 b1 57			dw game1zz 
4e18			 
4e18 3a 54			dw test5 
4e1a 72 54			dw test6 
4e1c aa 54			dw test7 
4e1e be 54			dw test8 
4e20 ea 54			dw test9 
4e22 00 55			dw test10 
4e24				 
4e24 88 58		        dw ssv5 
4e26 6c 58		        dw ssv4 
4e28 50 58		        dw ssv3 
4e2a 1a 58		        dw ssv2 
4e2c a1 58		        dw ssv1 
4e2e e9 58		        dw ssv1cpm 
4e30			;	dw keyup 
4e30			;	dw keydown 
4e30			;	dw keyleft 
4e30			;	dw keyright 
4e30			;	dw 	keyf1 
4e30			;	dw keyf2 
4e30			;	dw keyf3 
4e30			;	dw keyf4 
4e30			;	dw keyf5 
4e30			;	dw keyf6 
4e30			;	dw keyf7 
4e30			;	dw keyf8 
4e30			;	dw keyf9 
4e30			;	dw keyf10 
4e30			;	dw keyf11 
4e30			;	dw keyf12 
4e30			;	dw keytab 
4e30			;	dw keycr 
4e30			;	dw keyhome 
4e30			;	dw keyend 
4e30			;	dw keybs 
4e30 00 00			db 0, 0	 
4e32			 
4e32			 
4e32			; File Editor 
4e32			 
4e32			; ( id - ) use 'e' to edit the displayed line 
4e32 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
4e53 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4e88			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4e88 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
4ec0			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
4ec0			 
4ec0			; SPI Net support words 
4ec0			 
4ec0			; v0! = node to send to 
4ec0			; ( str count - ) 
4ec0 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
4f19			 
4f19			; spiputc ( char node - ) 
4f19 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
4f4d			; spiputc ( u node - ) 
4f4d .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
4f7b			 
4f7b			; spigetc ( - n ) 
4f7b .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
4fa4			 
4fa4			; getnode ( - n ) 
4fa4 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
4fd1			 
4fd1			; ( str node - )  
4fd1 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5037			; store string ( str i - ) 
5037			 
5037			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5037 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
508c			 
508c			; get string ( addr i -  )    TO FIX 
508c			 
508c .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
50e4			 
50e4			 
50e4			; NETCHAT (TODO) 
50e4			; Program to allow two nodes to chat with eachother 
50e4			; 
50e4			; v0 - target node 
50e4			;  
50e4			; accept input at 0,0 
50e4			; if input is string send spitype to target node 
50e4			; starting at row 2,0 , while spigetchr is not zero ->  
50e4			; 
50e4			; 
50e4			; TODO add paging of get request 
50e4			 
50e4			; ( node - ) 
50e4 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
5103 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
515b .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
51d3			 
51d3			 
51d3			; Long read of currently open file 
51d3 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
521a			 
521a			; clear stack  
521a			 
521a .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
524e			 
524e			; type ( addr count - ) 
524e .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
5273			 
5273			; some direct memory words 
5273			; strncpy ( len t f -- t ) 
5273			 
5273 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
52d4			 
52d4 .. 00		start1:     	db ": bpon $00 bp ;",0 
52e4 .. 00		start2:     	db ": bpoff $01 bp ;",0 
52f5 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
5370 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
53d0			 
53d0			 
53d0			; a handy word to list items on the stack 
53d0			 
53d0 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
543a			 
543a			 
543a			; test stack  
543a			; rnd8 stest 
543a			 
543a			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
543a			 
543a			; random malloc and free cycles 
543a			 
543a			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
543a			 
543a			; fixed malloc and free cycles 
543a			 
543a			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
543a			 
543a			; fixed double string push and drop cycle  
543a			 
543a			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
543a			 
543a			; consistent fixed string push and drop cycle  
543a			 
543a			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
543a			 
543a			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
543a			 
543a			;test1:		db ": aa 1 2 3 ;", 0 
543a			;test2:     	db "111 aa 888 999",0 
543a			;test3:     	db ": bb 77 ;",0 
543a			;test4:     	db "$02 $01 do i . loop bb",0 
543a			 
543a .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5472 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
54aa .. 00		test7:     	db ": box hline vline ;",0 
54be .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
54ea .. 00		test9:     	db ": sw $01 adsp world ;",0 
5500 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5525			;test11:     	db "hello create .",0 
5525			;test12:     	db "hello2 create .",0 
5525			 
5525			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5525			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5525			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5525			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5525			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5525			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5525			 
5525			;iftest1:     	db "$0001 IF cls .",0 
5525			;iftest2:     	db "$0000 IF cls .",0 
5525			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5525			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5525			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5525			 
5525			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5525			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5525			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5525			 
5525			 
5525 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
5549 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
5579 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
559e .. 00		sound4: db ": cha $00 ; ",0 
55ab .. 00		sound5: db ": chb $20 ; ",0 
55b8 .. 00		sound6: db ": chc $40 ; ",0 
55c5 .. 00		sound7: db ": chd $60 ; ",0 
55d2 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
55ea .. 00		sound9: db ": cvol $90 + + note ; ", 0 
5601			 
5601			 
5601			 
5601			 
5601			; a small guess the number game 
5601			 
5601 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5612 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5674			 
5674 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
56a9 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
56df .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5710 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5724 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5739 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
576d .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
57b1			 
57b1			; Using 'ga' save a high score across multiple runs using external storage 
57b1			 
57b1 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
581a			 
581a			 
581a			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
581a			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
581a			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
581a			 
581a			; simple screen saver to test code memory reuse to destruction 
581a			 
581a .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5850 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
586c .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5888 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
58a1 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
58e9 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5940			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5940			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5940			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5940			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5940			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5940			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5940			 
5940			 
5940			 
5940			; minesweeper/battleship finding game 
5940			; draws a game board of random ship/mine positions 
5940			; user enters coords to see if it hits on 
5940			; game ends when all are hit 
5940			; when hit or miss says how many may be in the area 
5940			 
5940			; setup the game board and then hide it 
5940			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5940			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5940			;; prompt for where to target 
5940			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5940			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5940			;; TODO see if the entered coords hits or misses pushes char hit of miss 
5940			;game2mbht:      db ": mbckht nop ;",0 
5940			;game2mbms:      db ": mbcms nop ;",0 
5940			; TODO how many might be near by 
5940			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5940			 
5940			; Game 3 
5940			 
5940			; Vert scroller ski game - avoid the trees! 
5940			 
5940			; v0 score (ie turns) 
5940			; v1 player pos 
5940			; v2 left wall 
5940			; v3 right wall 
5940			 
5940			; Draw side walls randomly 
5940			 
5940			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5940			 
5940			; Draw player 
5940			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5940			 
5940			; TODO Get Key 
5940			 
5940			; TODO Move left right 
5940			 
5940			; scroll and move walls a bit 
5940			 
5940			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5940			 
5940			; main game loop 
5940			 
5940			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5940			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5940			 
5940			; key board defs 
5940			 
5940 .. 00		keyup:       db ": keyup $05 ;",0 
594e .. 00		keydown:       db ": keydown $0a ;",0 
595e .. 00		keyleft:       db ": keyleft $0b ;",0 
596e .. 00		keyright:       db ": keyright $0c ;",0 
597f .. 00		keyf1:       db ": keyf1 $10 ;",0 
598d .. 00		keyf2:       db ": keyf2 $11 ;",0 
599b .. 00		keyf3:       db ": keyf3 $12 ;",0 
59a9 .. 00		keyf4:       db ": keyf4 $13 ;",0 
59b7 .. 00		keyf5:       db ": keyf5 $14 ;",0 
59c5 .. 00		keyf6:       db ": keyf6 $15 ;",0 
59d3 .. 00		keyf7:       db ": keyf7 $16 ;",0 
59e1 .. 00		keyf8:       db ": keyf8 $17 ;",0 
59ef .. 00		keyf9:       db ": keyf9 $18 ;",0 
59fd .. 00		keyf10:       db ": keyf10 $19 ;",0 
5a0c .. 00		keyf11:       db ": keyf11 $1a ;",0 
5a1b .. 00		keyf12:       db ": keyf12 $1b ;",0 
5a2a			 
5a2a .. 00		keytab:       db ": keytab $09 ;",0 
5a39 .. 00		keycr:       db ": keycr $0d ;",0 
5a47 .. 00		keyhome:       db ": keyhome $0e ;",0 
5a57 .. 00		keyend:       db ": keyend $0f ;",0 
5a66 .. 00		keybs:       db ": keybs $08 ;",0 
5a74			 
5a74			   
5a74			 
5a74			 
5a74			 
5a74			; eof 
# End of file forth_autostart.asm
5a74			 
5a74			 
5a74			 
5a74			; stack over and underflow checks 
5a74			 
5a74			; init the words to detect the under/overflow 
5a74			 
5a74			chk_stk_init: 
5a74				; a vague random number to check so we dont get any "lucky" hits 
5a74 3e 2d			ld a, 45 
5a76 6f				ld l, a 
5a77 00				nop 
5a78 3e 17			ld a, 23 
5a7a 67				ld h, a 
5a7b			 
5a7b 22 9d e2			ld (chk_word), hl     ; the word we need to check against 
5a7e			 
5a7e			;	ld (chk_stund), hl	; stack points.... 
5a7e 22 00 ef			ld (chk_stovr), hl 
5a81 22 ec e9			ld (chk_ret_und), hl 
5a84 22 aa e9			ld (chk_ret_ovr), hl 
5a87 22 28 e9			ld (chk_loop_ovr), hl 
5a8a 22 26 e8			ld (chk_data_ovr), hl 
5a8d c9				ret 
5a8e				 
5a8e			check_stacks: 
5a8e				; check all stack words 
5a8e			 
5a8e e5				push hl 
5a8f d5				push de 
5a90			 
5a90			;	ld de,(chk_word) 
5a90			;	ld hl, (chk_stund)	; stack points.... 
5a90			;	if DEBUG_STK_FAULT 
5a90			;		DMARK "FAa" 
5a90			;		CALLMONITOR 
5a90			;	endif 
5a90			;	call cmp16 
5a90			;	jp z, .chk_faulta 
5a90			; 
5a90			;	ld de, sfaultsu 
5a90			;	jp .chk_fault 
5a90			 
5a90 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
5a93 ed 5b 9d e2		ld de,(chk_word) 
5a97				if DEBUG_STK_FAULT 
5a97					DMARK "FAb" 
5a97					CALLMONITOR 
5a97				endif 
5a97 cd 10 0e			call cmp16 
5a9a 28 06			jr z, .chk_fault1 
5a9c 11 40 5b			ld de, sfaultso 
5a9f c3 f1 5a			jp .chk_fault 
5aa2			.chk_fault1:  
5aa2 2a ec e9			ld hl, (chk_ret_und) 
5aa5 ed 5b 9d e2		ld de,(chk_word) 
5aa9				if DEBUG_STK_FAULT 
5aa9					DMARK "FAU" 
5aa9					CALLMONITOR 
5aa9				endif 
5aa9 cd 10 0e			call cmp16 
5aac ca b5 5a			jp z, .chk_fault2 
5aaf 11 50 5b			ld de, sfaultru 
5ab2 c3 f1 5a			jp .chk_fault 
5ab5			.chk_fault2:  
5ab5 2a aa e9			ld hl, (chk_ret_ovr) 
5ab8 ed 5b 9d e2		ld de,(chk_word) 
5abc				if DEBUG_STK_FAULT 
5abc					DMARK "FA1" 
5abc					CALLMONITOR 
5abc				endif 
5abc cd 10 0e			call cmp16 
5abf ca c8 5a			jp z, .chk_fault3 
5ac2 11 5e 5b			ld de, sfaultro 
5ac5 c3 f1 5a			jp .chk_fault 
5ac8			.chk_fault3:  
5ac8 2a 28 e9			ld hl, (chk_loop_ovr) 
5acb ed 5b 9d e2		ld de,(chk_word) 
5acf				if DEBUG_STK_FAULT 
5acf					DMARK "FA2" 
5acf					CALLMONITOR 
5acf				endif 
5acf cd 10 0e			call cmp16 
5ad2 ca db 5a			jp z, .chk_fault4 
5ad5 11 78 5b			ld de, sfaultlo 
5ad8 c3 f1 5a			jp .chk_fault 
5adb			.chk_fault4:  
5adb 2a 26 e8			ld hl, (chk_data_ovr) 
5ade ed 5b 9d e2		ld de,(chk_word) 
5ae2				if DEBUG_STK_FAULT 
5ae2					DMARK "FA3" 
5ae2					CALLMONITOR 
5ae2				endif 
5ae2 cd 10 0e			call cmp16 
5ae5 ca ee 5a			jp z, .chk_fault5 
5ae8 11 92 5b			ld de, sfaultdo 
5aeb c3 f1 5a			jp .chk_fault 
5aee			 
5aee			 
5aee			.chk_fault5:  
5aee d1				pop de 
5aef e1				pop hl 
5af0			 
5af0 c9				ret 
5af1			 
5af1 cd c5 0b		.chk_fault: 	call clear_display 
5af4 3e 28				ld a, display_row_2 
5af6 cd d8 0b				call str_at_display 
5af9 11 22 5b				   ld de, .stackfault 
5afc 3e 00				ld a, display_row_1 
5afe cd d8 0b				call str_at_display 
5b01 11 6b ee				    ld de, debug_mark 
5b04 3e 11				ld a, display_row_1+17 
5b06 cd d8 0b				call str_at_display 
5b09 cd e8 0b				call update_display 
5b0c			 
5b0c				; prompt before entering montior for investigating issue 
5b0c			 
5b0c 3e 78			ld a, display_row_4 
5b0e 11 6b 18			ld de, endprog 
5b11			 
5b11 cd e8 0b			call update_display		 
5b14			 
5b14 cd f1 1a			call next_page_prompt 
5b17			 
5b17 d1				pop de 
5b18 e1				pop hl 
5b19 cd bf 18				call monitor 
5b1c cd da 1e				call forth_warmstart 
5b1f c3 bb 17				jp warmstart_afterauto 
5b22					;jp 0 
5b22					;halt 
5b22			 
5b22			 
5b22			 
5b22 .. 00		.stackfault: 	db "Stack fault:",0 
5b2f			 
5b2f .. 00		sfaultsu: 	db	"Stack under flow",0 
5b40 .. 00		sfaultso: 	db	"Stack over flow",0 
5b50 .. 00		sfaultru:	db "RTS underflow",0 
5b5e .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
5b78 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
5b92 .. 00		sfaultdo:	db "DTS overflow", 0 
5b9f			 
5b9f			 
5b9f			fault_dsp_under: 
5b9f 11 b1 5b			ld de, .dsp_under 
5ba2 c3 67 5c			jp .show_fault 
5ba5			 
5ba5			fault_rsp_under: 
5ba5 11 bf 5b			ld de, .rsp_under 
5ba8 c3 67 5c			jp .show_fault 
5bab			fault_loop_under: 
5bab 11 cd 5b			ld de, .loop_under 
5bae c3 67 5c			jp .show_fault 
5bb1			 
5bb1 .. 00		.dsp_under: db "DSP Underflow",0 
5bbf .. 00		.rsp_under: db "RSP Underflow",0 
5bcd .. 00		.loop_under: db "LOOP Underflow",0 
5bdc			 
5bdc			 
5bdc d5			type_faultn: 	push de 
5bdd e5					push hl 
5bde cd c5 0b				call clear_display 
5be1 11 0b 5c				   ld de, .typefaultn 
5be4 3e 00				ld a, display_row_1 
5be6 cd d8 0b				call str_at_display 
5be9 11 6b ee				    ld de, debug_mark 
5bec 3e 11				ld a, display_row_1+17 
5bee cd d8 0b				call str_at_display 
5bf1 cd e8 0b				call update_display 
5bf4			 
5bf4				; prompt before entering montior for investigating issue 
5bf4			 
5bf4 3e 78			ld a, display_row_4 
5bf6 11 6b 18			ld de, endprog 
5bf9			 
5bf9 cd e8 0b			call update_display		 
5bfc			 
5bfc cd f1 1a			call next_page_prompt 
5bff			 
5bff e5					push hl 
5c00 d5					push de 
5c01 cd bf 18				call monitor 
5c04 cd da 1e				call forth_warmstart 
5c07 c3 bb 17				jp warmstart_afterauto 
5c0a 76					halt 
5c0b			 
5c0b			 
5c0b .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
5c22			 
5c22 d5			type_faults: 	push de 
5c23 e5					push hl 
5c24 cd c5 0b				call clear_display 
5c27 11 50 5c				   ld de, .typefaults 
5c2a 3e 00				ld a, display_row_1 
5c2c cd d8 0b				call str_at_display 
5c2f 11 6b ee				    ld de, debug_mark 
5c32 3e 11				ld a, display_row_1+17 
5c34 cd d8 0b				call str_at_display 
5c37 cd e8 0b				call update_display 
5c3a			 
5c3a				; prompt before entering montior for investigating issue 
5c3a			 
5c3a 3e 78			ld a, display_row_4 
5c3c 11 6b 18			ld de, endprog 
5c3f			 
5c3f cd e8 0b			call update_display		 
5c42			 
5c42 cd f1 1a			call next_page_prompt 
5c45			 
5c45 e1					pop hl 
5c46 d1					pop de 
5c47 cd bf 18				call monitor 
5c4a cd da 1e				call forth_warmstart 
5c4d c3 bb 17				jp warmstart_afterauto 
5c50			 
5c50			 
5c50 .. 00		.typefaults: db "STR Type Expected TOS!",0 
5c67			 
5c67			.show_fault: 	 
5c67 d5					push de 
5c68 cd c5 0b				call clear_display 
5c6b d1					pop de 
5c6c 3e 00				ld a, display_row_1 
5c6e cd d8 0b				call str_at_display 
5c71 11 6b ee				    ld de, debug_mark 
5c74 3e 11				ld a, display_row_1+17 
5c76 cd d8 0b				call str_at_display 
5c79 cd e8 0b				call update_display 
5c7c			 
5c7c				; prompt before entering montior for investigating issue 
5c7c			 
5c7c 3e 78			ld a, display_row_4 
5c7e 11 6b 18			ld de, endprog 
5c81			 
5c81 cd e8 0b			call update_display		 
5c84			 
5c84 cd f1 1a			call next_page_prompt 
5c87			 
5c87 e1					pop hl 
5c88 d1					pop de 
5c89 cd bf 18				call monitor 
5c8c			; do a dump to cli and not warmstart so we preserve all of the uwords.  
5c8c			; TODO Make optional fault restart to cli or warm boot? 
5c8c					;jp warmstart 
5c8c c3 ff 17				jp cli 
5c8f 76					halt 
5c90			 
5c90			; handle the auto run of code from files in storage 
5c90			 
5c90			 
5c90			include "forth_startup.asm" 
5c90			; Which startup method to use? 
5c90			; 
5c90			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
5c90			; followed by loading of a list of scripts in eeprom 
5c90			 
5c90			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
5c90			; from eeprom 
5c90			 
5c90			; Select with define in main stubs 
5c90			 
5c90			if STARTUP_V1 
5c90				include "forth_startupv1.asm" 
5c90			; Startup script loading version 1 
5c90			 
5c90			; If SE storage is available first stage is to use the selected file 
5c90			; then go through the eeprom list 
5c90			 
5c90 .. 00		sprompt1: db "Startup load...",0 
5ca0 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5cb6			 
5cb6			 
5cb6			 
5cb6			 
5cb6			forth_startup: 
5cb6 21 fa 4d			ld hl, startcmds 
5cb9 3e 00			ld a, 0 
5cbb 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
5cbe			 
5cbe e5			.start1:	push hl 
5cbf cd c5 0b			call clear_display 
5cc2 11 90 5c			ld de, sprompt1 
5cc5 3e 00		        ld a, display_row_1 
5cc7 cd d8 0b			call str_at_display 
5cca 11 a0 5c			ld de, sprompt2 
5ccd 3e 28		        ld a, display_row_2 
5ccf cd d8 0b			call str_at_display 
5cd2 e1				pop hl 
5cd3 e5				push hl 
5cd4 5e				ld e,(hl) 
5cd5 23				inc hl 
5cd6 56				ld d,(hl) 
5cd7 3e 50		        ld a, display_row_3 
5cd9 cd d8 0b			call str_at_display 
5cdc cd e8 0b			call update_display 
5cdf			 
5cdf			 
5cdf 3a e7 e6			ld a, (os_last_cmd) 
5ce2 fe 00			cp 0 
5ce4 28 05			jr z, .startprompt 
5ce6 cd f1 0a			call delay250ms 
5ce9 18 24			jr .startdo 
5ceb				 
5ceb				 
5ceb			 
5ceb			.startprompt: 
5ceb			 
5ceb 3e 9f			ld a,display_row_4 + display_cols - 1 
5ced 11 ef 1a		        ld de, endprg 
5cf0 cd d8 0b			call str_at_display 
5cf3 cd e8 0b			call update_display 
5cf6 cd fd 0a			call delay1s 
5cf9 cd 68 5e			call cin_wait 
5cfc						 
5cfc fe 2a			cp '*' 
5cfe 28 5e			jr z, .startupend1 
5d00 fe 23			cp '#' 
5d02 20 07			jr nz, .startno 
5d04 3e 01			ld a, 1 
5d06 32 e7 e6			ld (os_last_cmd),a 
5d09 18 04			jr .startdo 
5d0b fe 31		.startno:	cp '1' 
5d0d 28 3a			jr z,.startnxt  
5d0f			 
5d0f				; exec startup line 
5d0f			.startdo:	 
5d0f e1				pop hl 
5d10 e5				push hl 
5d11				 
5d11 5e				ld e,(hl) 
5d12 23				inc hl 
5d13 56				ld d,(hl) 
5d14 eb				ex de,hl 
5d15			 
5d15 e5				push hl 
5d16			 
5d16 3e 00			ld a, 0 
5d18				;ld a, FORTH_END_BUFFER 
5d18 cd 63 11			call strlent 
5d1b 23				inc hl   ; include zero term to copy 
5d1c 06 00			ld b,0 
5d1e 4d				ld c,l 
5d1f e1				pop hl 
5d20 11 c1 e2			ld de, scratch 
5d23 ed b0			ldir 
5d25			 
5d25			 
5d25 21 c1 e2			ld hl, scratch 
5d28 cd 82 1f			call forthparse 
5d2b cd c2 1f			call forthexec 
5d2e cd d4 1e			call forthexec_cleanup 
5d31			 
5d31 3e 78			ld a, display_row_4 
5d33 11 6b 18			ld de, endprog 
5d36			 
5d36 cd e8 0b			call update_display		 
5d39			 
5d39 3a e7 e6			ld a, (os_last_cmd) 
5d3c fe 00			cp 0 
5d3e 20 09			jr nz, .startnxt 
5d40 cd f1 1a			call next_page_prompt 
5d43 cd c5 0b		        call clear_display 
5d46 cd e8 0b			call update_display		 
5d49			 
5d49				; move onto next startup line? 
5d49			.startnxt: 
5d49			 
5d49 cd f1 0a			call delay250ms 
5d4c e1				pop hl 
5d4d			 
5d4d 23				inc hl 
5d4e 23				inc hl 
5d4f			 
5d4f e5				push hl 
5d50 5e				ld e, (hl) 
5d51 23				inc hl 
5d52 56				ld d, (hl) 
5d53 e1				pop hl 
5d54				; TODO replace 0 test 
5d54			 
5d54 eb				ex de, hl 
5d55 cd 1b 0e			call ishlzero 
5d58			;	ld a,e 
5d58			;	add d 
5d58			;	cp 0    ; any left to do? 
5d58 eb				ex de, hl 
5d59 c2 be 5c			jp nz, .start1 
5d5c 18 01			jr .startupend 
5d5e			 
5d5e e1			.startupend1: pop hl 
5d5f			.startupend: 
5d5f			 
5d5f cd c5 0b			call clear_display 
5d62 cd e8 0b			call update_display 
5d65 c9				ret 
5d66			if STORAGE_SE 
5d66			 
5d66			sprompt3: db "Loading from start-up file?:",0 
5d66			sprompt4: db "(Y=Any key/N=No)",0 
5d66			 
5d66			 
5d66			forth_autoload: 
5d66			 
5d66				; load block 0 of store 1 
5d66				 
5d66				ld a, $fe      ; bit 0 clear 
5d66				ld (spi_device), a 
5d66			 
5d66				call storage_get_block_0 
5d66			 
5d66				ld a, (store_page+STORE_0_AUTOFILE) 
5d66			 
5d66				cp 0 
5d66				ret z     ; auto start not enabled 
5d66			 
5d66				call clear_display 
5d66			 
5d66				; set bank 
5d66			 
5d66					ld a, (store_page+STORE_0_BANKRUN) 
5d66					ld (spi_device), a 
5d66			 
5d66				; get file id to load from and get the file name to display 
5d66			 
5d66					ld a, (store_page+STORE_0_FILERUN) 
5d66			 
5d66					ld l, 0 
5d66					ld h, a 
5d66					ld de, store_page 
5d66			 
5d66					if DEBUG_FORTH_WORDS 
5d66						DMARK "ASp" 
5d66						CALLMONITOR 
5d66					endif 
5d66					call storage_read 
5d66			 
5d66					if DEBUG_FORTH_WORDS 
5d66						DMARK "ASr" 
5d66						CALLMONITOR 
5d66					endif 
5d66			 
5d66					call ishlzero 
5d66					ret z             ; file not found 
5d66			 
5d66					ld a, display_row_2 + 10 
5d66					ld de, store_page+3 
5d66					call str_at_display 
5d66				 
5d66			; 
5d66			 
5d66				ld a, display_row_1+5 
5d66				ld de, sprompt3 
5d66				call str_at_display 
5d66				ld a, display_row_3+15 
5d66				ld de, sprompt4 
5d66				call str_at_display 
5d66			 
5d66				call update_display 
5d66			 
5d66				call cin_wait 
5d66				cp 'n' 
5d66				ret z 
5d66				cp 'N' 
5d66				ret z 
5d66			 
5d66				call delay1s 
5d66			 
5d66				ld a, (store_page+2) 
5d66				ld (store_openmaxext), a    ; save count of ext 
5d66				ld a, 1  
5d66				ld (store_openext), a    ; save count of ext 
5d66			 
5d66			.autof:  
5d66				ld l , a 
5d66				 
5d66				ld a, (store_page) 
5d66				ld h, a	 
5d66				ld de, store_page 
5d66					if DEBUG_FORTH_WORDS 
5d66						DMARK "ASl" 
5d66						CALLMONITOR 
5d66					endif 
5d66					call storage_read 
5d66				call ishlzero 
5d66				ret z 
5d66			;	jr z, .autoend 
5d66			 
5d66					if DEBUG_FORTH_WORDS 
5d66						DMARK "ASc" 
5d66						CALLMONITOR 
5d66					endif 
5d66				ld de, store_page+2 
5d66				ld a, display_row_4 
5d66				call str_at_display 
5d66			 
5d66				call update_display 
5d66				call delay250ms 
5d66			 
5d66			 
5d66			 
5d66				ld hl, store_page+2 
5d66				call forthparse 
5d66				call forthexec 
5d66				call forthexec_cleanup 
5d66			 
5d66				 
5d66				ld a, (store_openext) 
5d66				inc a 
5d66				ld (store_openext), a    ; save count of ext 
5d66			 
5d66				jr .autof 
5d66			;.autofdone: 
5d66			; 
5d66			;		if DEBUG_FORTH_WORDS 
5d66			;			DMARK "ASx" 
5d66			;			CALLMONITOR 
5d66			;		endif 
5d66			;;	call clear_display 
5d66			;	ret 
5d66			 
5d66			 
5d66			 
5d66			endif 
# End of file forth_startupv1.asm
5d66			endif 
5d66			if STARTUP_V2 
5d66				include "forth_startupv2.asm" 
5d66			endif 
5d66			 
# End of file forth_startup.asm
5d66			 
5d66			; eof 
# End of file forth_kernel.asm
5d66			;include "nascombasic.asm" 
5d66			 
5d66			 
5d66			; find out where the code ends if loaded into RAM (for SC114) 
5d66			;endofcode:  
5d66			;	nop 
5d66			 
5d66			 
5d66			; jump to nmi vector 
5d66			 
5d66			init_nmi: 
5d66 3e c9			ld a, $c9   ; RET 
5d68 32 72 ee			ld (nmi_vector), a 
5d6b c9				ret 
5d6c			nmi: 
5d6c e5				push hl 
5d6d d5				push de 
5d6e c5				push bc 
5d6f f5				push af 
5d70 cd 72 ee			call nmi_vector 
5d73 f5				push af 
5d74 c5				push bc 
5d75 d5				push de 
5d76 e5				push hl 
5d77 ed 4d			reti 
5d79			 
5d79			 
5d79			; eof 
5d79			 
# End of file main.asm
5d79			;include "firmware_lcd_4x40.asm" 
5d79			;;include "firmware_lcd_4x20.asm" 
5d79			include "firmware_cpm_display.asm" 
5d79			 
5d79			; Serial display interface for SC114 
5d79			 
5d79			 
5d79			display_row_1: equ 0 
5d79			display_row_2: equ display_row_1+display_cols 
5d79			display_row_3: equ display_row_2 + display_cols 
5d79			display_row_4: equ display_row_3 + display_cols 
5d79			 
5d79			kLCDWidth:  EQU display_cols             ;Width in characters 
5d79			kLCD_Line1: EQU 0x00  
5d79			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
5d79			; E1 
5d79			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
5d79			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
5d79			 
5d79			lcd_init: 
5d79				; no init as handled by the SCM bios 
5d79 c9				ret 
5d7a			 
5d7a			 
5d7a			; low level functions for direct screen writes 
5d7a			 
5d7a			; output char at pos? 
5d7a			fLCD_Str: 
5d7a			        ;out (SC114_SIO_1_OUT),a 
5d7a c5				push bc 
5d7b d5				push de 
5d7c 5f				ld e, a 
5d7d			; TODO Replace with CP/M BIOS call 
5d7d 0e 02			ld c, $02 
5d7f cd 05 00			call 5 
5d82 d1				pop de 
5d83 c1				pop bc 
5d84 c9				ret 
5d85			 
5d85			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
5d85			fLCD_Pos: 
5d85				; use ASCII escape to position 
5d85			        ;out (SC114_SIO_1_OUT),a 
5d85 c5				push bc 
5d86 d5				push de 
5d87 5f				ld e, a 
5d88 0e 02			ld c, $02 
5d8a			; TODO Replace with CP/M BIOS call 
5d8a cd 05 00			call 5 
5d8d d1				pop de 
5d8e c1				pop bc 
5d8f			 
5d8f c9				ret 
5d90			 
5d90			; output char at pos 
5d90			fLCD_Data: 
5d90			      ;  out (SC114_SIO_1_OUT),a 
5d90 c5				push bc 
5d91 d5				push de 
5d92 0e 02			ld c, $02 
5d94 5f				ld e, a 
5d95			; TODO Replace with CP/M BIOS call 
5d95 cd 05 00			call 5 
5d98 d1				pop de 
5d99 c1				pop bc 
5d9a			 
5d9a c9				ret 
5d9b			 
5d9b			; ascii cls  
5d9b			 
5d9b 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
5d9f			 
5d9f 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
5db6			;.clscpm: db 3, $3c,"$" 
5db6			 
5db6			; write the frame buffer given in hl to hardware  
5db6			write_display: 
5db6			 
5db6			API: equ 0 
5db6			 
5db6			if API 
5db6				push bc 
5db6				ld b, 4 
5db6			 
5db6			        ld (display_write_tmp), hl 	  
5db6			 
5db6				; clear and home cursor 
5db6			 
5db6				ld c, 9 
5db6				ld de, .cls 
5db6			; TODO Replace with CP/M BIOS call 
5db6				call 5 
5db6			 
5db6			 
5db6			.writeln: 
5db6			 
5db6				ld de, (display_write_tmp) 
5db6				ld c, 6 
5db6			; TODO Replace with CP/M BIOS call 
5db6				rst $30 
5db6				ld c, 7 
5db6				rst $30 
5db6			 
5db6				ld hl, (display_write_tmp) 
5db6				ld de, display_cols 
5db6				add hl,de 
5db6				ld (display_write_tmp),hl 
5db6			 
5db6				djnz  .writeln 
5db6			 
5db6				pop bc 
5db6			 
5db6			 
5db6				ret 
5db6			endif 
5db6 e5				push hl 
5db7 c5				push bc 
5db8 d5				push de 
5db9			 
5db9			;	ld c, 2 
5db9			;	;ld de, .cls 
5db9			;	ld a, 27 
5db9			;	rst $30 
5db9			;	ld c, 2 
5db9			;	;ld de, .cls 
5db9			;	ld a, '[' 
5db9			;	rst $30 
5db9			; 
5db9			;	ld c, 2 
5db9			;	;ld de, .cls 
5db9			;	ld a, 'H' 
5db9			;	rst $30 
5db9			; 
5db9			 
5db9			 
5db9			; lots of CR/LF 
5db9			;	ld c, 9 
5db9			;	ld de, .clscpm 
5db9			;	call 5 
5db9			 
5db9			; xterm cls 
5db9 0e 02			ld c, 2 
5dbb 1e 1b			ld e, 27 
5dbd cd 05 00			call 5 
5dc0			; cls causes too much flicker 
5dc0			;	ld c, 2 
5dc0			;	ld e, 'c' 
5dc0			;	call 5 
5dc0			 
5dc0			; use xterm home instead 
5dc0 0e 02			ld c, 2 
5dc2 1e 5b			ld e, '[' 
5dc4 cd 05 00			call 5 
5dc7 0e 02			ld c, 2 
5dc9 1e 48			ld e, 'H' 
5dcb cd 05 00			call 5 
5dce			LLL: equ 0 
5dce			 
5dce			if LLL 
5dce			 
5dce				ld c, 2 
5dce				;ld de, .cls 
5dce				ld e, 27 
5dce			; TODO Replace with CP/M BIOS call 
5dce				call 5 
5dce			 
5dce			 
5dce				ld c, 2 
5dce				;ld de, .cls 
5dce				ld e, '[' 
5dce			; TODO Replace with CP/M BIOS call 
5dce				call 5 
5dce				ld c, 2 
5dce				;ld de, .cls 
5dce				ld e, '2' 
5dce			; TODO Replace with CP/M BIOS call 
5dce				call 5 
5dce				ld c, 2 
5dce				;ld de, .cls 
5dce				ld e, 'J' 
5dce			; TODO Replace with CP/M BIOS call 
5dce				call 5 
5dce			 
5dce			endif 
5dce			 
5dce d1				pop de 
5dcf c1				pop bc 
5dd0 e1				pop hl 
5dd1			 
5dd1			 
5dd1 22 c9 eb		        ld (display_write_tmp), hl 	  
5dd4 3e 00			ld a, kLCD_Line1 
5dd6			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5dd6 06 28			ld b, display_cols 
5dd8 ed 5b c9 eb		ld de, (display_write_tmp) 
5ddc cd 5f 5e			call write_len_string 
5ddf				 
5ddf			 
5ddf e5			push hl 
5de0 d5			push de 
5de1 c5			push bc 
5de2 0e 02			ld c, 2 
5de4 1e 0a			ld e, 10 
5de6 cd 05 00			call 5 
5de9 0e 02			ld c, 2 
5deb 1e 0d			ld e, 13 
5ded cd 05 00			call 5 
5df0			; TODO Replace with CP/M BIOS call 
5df0				;rst $30 
5df0 c1			pop bc 
5df1 d1			pop de 
5df2 e1			pop hl 
5df3			 
5df3				 
5df3 2a c9 eb			ld hl, (display_write_tmp) 
5df6 11 28 00			ld de, display_cols 
5df9 19				add hl,de 
5dfa 22 c9 eb			ld (display_write_tmp),hl 
5dfd			 
5dfd				 
5dfd 3e 28			ld a, kLCD_Line2 
5dff			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5dff 06 28			ld b, display_cols 
5e01 ed 5b c9 eb		ld de, (display_write_tmp) 
5e05 cd 5f 5e			call write_len_string 
5e08				 
5e08 2a c9 eb			ld hl, (display_write_tmp) 
5e0b 11 28 00			ld de, display_cols 
5e0e 19				add hl,de 
5e0f 22 c9 eb			ld (display_write_tmp),hl 
5e12			 
5e12 e5			push hl 
5e13 d5			push de 
5e14 c5			push bc 
5e15 0e 07			ld c, 7 
5e17			; TODO Replace with CP/M BIOS call 
5e17				;rst $30 
5e17 0e 02			ld c, 2 
5e19 1e 0a			ld e, 10 
5e1b cd 05 00			call 5 
5e1e 0e 02			ld c, 2 
5e20 1e 0d			ld e, 13 
5e22 cd 05 00			call 5 
5e25 c1			pop bc 
5e26 d1			pop de 
5e27 e1			pop hl 
5e28			 
5e28				 
5e28 3e 50			ld a, kLCD_Line3 
5e2a			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
5e2a 06 28			ld b, display_cols 
5e2c ed 5b c9 eb		ld de, (display_write_tmp) 
5e30 cd 5f 5e			call write_len_string 
5e33				 
5e33 2a c9 eb			ld hl, (display_write_tmp) 
5e36 11 28 00			ld de, display_cols 
5e39 19				add hl,de 
5e3a 22 c9 eb			ld (display_write_tmp),hl 
5e3d			 
5e3d e5			push hl 
5e3e d5			push de 
5e3f c5			push bc 
5e40 0e 07			ld c, 7 
5e42			; TODO Replace with CP/M BIOS call 
5e42				;rst $30 
5e42 0e 02			ld c, 2 
5e44 1e 0a			ld e, 10 
5e46 cd 05 00			call 5 
5e49 0e 02			ld c, 2 
5e4b 1e 0d			ld e, 13 
5e4d cd 05 00			call 5 
5e50 c1			pop bc 
5e51 d1			pop de 
5e52 e1			pop hl 
5e53			 
5e53				 
5e53 3e 78			ld a, kLCD_Line4 
5e55			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
5e55 06 28			ld b, display_cols 
5e57 ed 5b c9 eb		ld de, (display_write_tmp) 
5e5b cd 5f 5e			call write_len_string 
5e5e c9					ret 
5e5f			 
5e5f			 
5e5f				; write out a fixed length string given in b from de 
5e5f			 
5e5f 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
5e60 cd 90 5d		            CALL fLCD_Data      ;Write character to display 
5e63 13				inc de 
5e64 10 f9			djnz write_len_string 
5e66 c9				ret 
5e67			 
5e67			 
5e67			; eof 
# End of file firmware_cpm_display.asm
5e67			;include "firmware_key_5x10.asm" 
5e67			;;include "firmware_key_4x10.asm" 
5e67			include "firmware_key_cpm.asm" 
5e67			; Serial keyboard interface for SC114 
5e67			 
5e67			 
5e67			key_init: 
5e67				; no init as handled by the SCM bios 
5e67 c9				ret 
5e68			 
5e68			 
5e68			cin_wait: 
5e68			;	ld a, 0 
5e68			;	ret 
5e68			 
5e68				;in a,(SC114_SIO_1_IN) 
5e68			        ; Use SCM API to get from whatever console device we are using 
5e68			 
5e68			; TODO Replace with CP/M BIOS call 
5e68 c5				push bc 
5e69 0e 01			ld c, $01 
5e6b cd 05 00			call 5 
5e6e c1				pop bc 
5e6f c9				ret 
5e70			 
5e70			cin: 
5e70			 
5e70			 
5e70 c5				push bc 
5e71			 
5e71				; any key waiting to process? 
5e71			; TODO Replace with CP/M BIOS call 
5e71 0e 06			ld c, $06 
5e73 cd 05 00			call 5 
5e76 28 0d			jr z, .cin_skip 
5e78			 
5e78				; yep, get it 
5e78			 
5e78 0e 01			ld c, $01 
5e7a			; TODO Replace with CP/M BIOS call 
5e7a cd 05 00			call 5 
5e7d			 
5e7d fe 7f			cp $7f     ; back space 
5e7f 20 02			jr nz, .skipbs 
5e81 3e 08			ld a, KEY_BS 
5e83			.skipbs: 
5e83			 
5e83 c1				pop bc 
5e84 c9				ret 
5e85			.cin_skip: 
5e85 3e 00			ld a, 0 
5e87 c1				pop bc 
5e88 c9				ret 
5e89			 
5e89			 
5e89			 
5e89			 
# End of file firmware_key_cpm.asm
5e89			endofcode:  
5e89			baseram:  
5e89 00				nop 
5e8a			 
5e8a			heap_start: equ baseram+15  ; Starting address of heap 
5e8a			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
5e8a			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
5e8a			;VDU:  EQU     endofcode           ; BASIC Work space 
5e8a			; eof 
5e8a			 
# End of file os_mega_cpm.asm
5e8a
