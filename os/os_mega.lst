# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 16 1d			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 ..			buildtime: db   "Build: " 
000a					include "romtimestamp.asm" 
000a ..			db '2025-08-07 17:04' 
# End of file romtimestamp.asm
001a 00				   db 0 
001b			 
001b			 
001b			 
001b			;        nop  
001b			;        nop 
001b			;;	org 05h		; null out bdos call 
001b			; 
001b			;        nop  
001b			;        nop  
001b			;        nop 
001b			;;	org 08h 
001b			;;; 
001b			;;	jp cin		; rst 8 - char in 
001b			;;; 
001b			; 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;	org 010h 
001b			;; 
001b			;	jp cout		; rest 010h  - char out 
001b			;; 
001b			;	org 01bh   
001b			; 
001b			;	;jp  		; rst 01bh   - write string to display 
001b			;	jp str_at_display 
001b			; 
001b			; 
001b			;	org 020h 
001b			; 
001b			;	; jp		 ; rst 020h - read char at screen location 
001b			; 
001b			;	org 028h 
001b			 
001b				; jp		 ; rst 028h  - storage i/o 
001b			 
001b			; 	org 030h 
001b			;	jp break_point_state 
001b			  
001b			; $30  
001b			; org 038h 
001b			; $38 
001b			 
001b			; TODO any more important entry points to add to jump table for easier coding use? 
001b			 
001b			if BASE_KEV = 1  
001b			 
001b				; need to be at $66 for nmi support 
001b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0021 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0027 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0033 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0039 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0045 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0051 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0057 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0063 00 ff			db 0,255 
0065 c3 f9 76			jp nmi 
0068			endif 
0068			 
0068			include "firmware.asm" 
0068			  
0068			; main constants (used here and in firmware)  
0068			  
0068			; TODO have page 0 of storage as bios  
0068			  
0068			Device_A: equ 0h  
0068			Device_B: equ 040h          ; Sound  
0068			  
0068			if BASE_KEV  
0068			Device_C: equ 080h          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			if BASE_SC114  
0068			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			if BASE_CPM  
0068			; TODO fixup for CPM  
0068			Device_C: equ 080h          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			Device_D: equ 0c0h             ; Keyboard and LCD  
0068			  
0068			; Odd specific debug points for testing hardware dev  
0068			  
0068			DEBUG_SOUND: equ 0       
0068			DEBUG_STK_FAULT: equ 0  
0068			DEBUG_INPUT: equ 0     ; Debug input entry code  
0068			DEBUG_KEYCINWAIT: equ 0  
0068			DEBUG_KEYCIN: equ 0  
0068			DEBUG_KEY: equ 0  
0068			DEBUG_KEY_MATRIX: equ 0  
0068			DEBUG_STORECF: equ 0  
0068			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0068			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0068			DEBUG_SPI: equ 0    ; low level spi tests  
0068			  
0068			; Enable many break points  
0068			  
0068			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0068			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0068			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0068			DEBUG_FORTH_JP: equ 0    ; 4  
0068			DEBUG_FORTH_MALLOC: equ 0  
0068			DEBUG_FORTH_MALLOC_INT: equ 0  
0068			DEBUG_FORTH_DOT: equ 1  
0068			DEBUG_FORTH_DOT_WAIT: equ 0  
0068			DEBUG_FORTH_MATHS: equ 0  
0068			DEBUG_FORTH_TOK: equ 0    ; 4  
0068			DEBUG_FORTH_PARSE: equ 0    ; 3  
0068			DEBUG_FORTH: equ 0  ;2  
0068			DEBUG_FORTH_WORDS: equ 1   ; 1  
0068			DEBUG_FORTH_PUSH: equ 1   ; 1  
0068			DEBUG_FORTH_UWORD: equ 1   ; 1  
0068			  
0068			; Enable key point breakpoints  
0068			  
0068			DEBUG_FORTH_DOT_KEY: equ 0  
0068			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0068			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0068			  
0068			; Debug stack imbalances  
0068			  
0068			ON: equ 1  
0068			OFF: equ 0  
0068			  
0068			DEBUG_STACK_IMB: equ 0  
0068			STACK_IMB_STORE: equ 20  
0068			  
0068			; House keeping and protections  
0068			  
0068			DEBUG_FORTH_STACK_GUARD: equ 1  
0068			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0068			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0068			FORTH_ENABLE_FREE: equ 0  
0068			FORTH_ENABLE_MALLOCFREE: equ 1  
0068			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0068			FORTH_ENABLE_FLOATMATH: equ 0  
0068			  
0068			  
0068			CALLMONITOR: macro  
0068			;	call break_point_state  
0068			; now use the break point debug vector  
0068				call debug_vector  
0068				endm  
0068			  
0068			MALLOC_1: equ 1        ; from dk88   
0068			MALLOC_2: equ 0           ; broke  
0068			MALLOC_3: equ 0           ; really broke  
0068			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0068			  
0068			if BASE_KEV   
0068			;stacksize: equ 256  
0068			; each stack entry is three bytes (type + word)  
0068			stacksize: equ 3*150  
0068			  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 512  
0068			endif  
0068			if BASE_SC114  
0068			;tos:	equ 0f000h  
0068			stacksize: equ 256  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 256  
0068			endif  
0068			  
0068			if BASE_CPM  
0068			;tos:	equ 0f000h  
0068			stacksize: equ 256  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 256  
0068			endif  
0068			  
0068			;if STORAGE_SE == 0  
0068			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0068			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0068			;endif  
0068			  
0068			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0068			  
0068			STORE_0_AUTORUN: equ $20  
0068			  
0068			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0068			  
0068			STORE_0_AUTOFILE: equ $21  
0068			STORE_0_BANKRUN: equ $23  
0068			STORE_0_FILERUN: equ $24  
0068			  
0068			; Block 0 offsets for settings  
0068			  
0068			; if set then skip prompt for start up and accept all  
0068			  
0068			STORE_0_QUICKSTART: equ $25  
0068			  
0068			; Blocks where directory table is held  
0068			  
0068			; Reducing the number of entries increases the max file size  
0068			  
0068			;STORE_DIR_START: equ 1  
0068			;STORE_DIR_END: equ 33  
0068			  
0068			; Blocks from where file data is stored  
0068			  
0068			;STORE_DATA_START: equ STORE_DIR_END + 1  
0068			  
0068			; Block indicators (<32 are data files)  
0068			  
0068			;STORE_BLOCK_CFG: equ $8f       ; config block  
0068			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0068			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0068			;STORE_BLOCK_FREE: equ $85       ; data block free  
0068			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0068			  
0068			  
0068			  
0068			; Directory entry flags  
0068			  
0068			;STORE_DIR_FREE: equ 0  
0068			;STORE_DIR_FILE:  equ 1  
0068			  
0068			; Structure offsets to directory entries  
0068			;STORE_DE_FLAG: equ 0  
0068			;STORE_DE_MAXEXT: equ 1  
0068			;STORE_DE_FILENAME: equ 2  
0068			  
0068			; Structure offsets to block 0  
0068			  
0068			;STORE_BK0_ISFOR: equ 1  
0068			;STORE_BK0_LABEL: equ 3  
0068			  
0068			; memory allocation   
0068			  
0068			chk_stund: equ tos+2           ; underflow check word  
0068			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0068			  
0068			; keyscan table needs rows x cols buffer  
0068			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0068			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0068			  
0068			keyscan_table_row1: equ chk_stovr -key_cols-1  
0068			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0068			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0068			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0068			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0068			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0068			keyscan_scancol: equ keyscan_table-key_cols  
0068			;keyscan_table_len: equ key_rows*key_cols  
0068			;keybufptr: equ keyscan_table - 2  
0068			;keysymbol: equ keybufptr - 1  
0068			key_held: equ keyscan_scancol-1	; currently held  
0068			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0068			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0068			key_fa: equ key_repeat_ct -1 ;  
0068			key_fb: equ key_fa -1 ;  
0068			key_fc: equ key_fb -1 ;  
0068			key_fd: equ key_fc -1 ;  
0068			key_face_held: equ key_fd - 1   
0068			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0068			  
0068			hardware_config: equ key_face_held - 10  
0068			  
0068			; hardware config switches  
0068			; TODO add bitmasks on includes for hardware  
0068			; high byte for expansion ids  
0068			;     0000 0000  no card inserted  
0068			;     0000 0001  storage card inserted  
0068			;     0000 0010  spi sd card active  
0068			  
0068			;       
0068			; low byte:  
0068			;     0000 0001   4x4 keypad  
0068			;     0000 0010   full keyboard  
0068			;     0000 0011   spi/ext keyboard  
0068			;     0000 0100   20x4 lcd  
0068			;     0000 1000   40x4 lcd  
0068			;     0000 1100   spi/ext display  
0068			;     0001 0000   ide interface available  
0068			  
0068			hardware_word: equ hardware_config - 2  
0068			  
0068			; debug marker - optional display of debug point on the debug screens  
0068			  
0068			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
0068			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
0068			  
0068			debug_mark: equ debug_vector - 4  
0068			  
0068			; input_str vars  
0068			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0068			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0068			input_size: equ input_start -1  ; number of chars  
0068			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0068			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0068			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0068			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0068			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0068			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0068			input_len: equ input_cur_onoff - 5 ; length of current input  
0068			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0068			  
0068			CUR_BLINK_RATE: equ 15  
0068			  
0068			key_actual_pressed: equ input_cursor - 1   
0068			key_symbol: equ key_actual_pressed - 1   
0068			key_shift: equ key_symbol - 1   
0068			  
0068			; Display allocation  
0068			  
0068			;display_rows: equ 4     ; move out to mini and mega files  
0068			;display_cols: equ 20  
0068			  
0068			display_fb_len: equ display_rows*display_cols  
0068			  
0068			; primary frame buffer     
0068			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0068			; working frame buffers  
0068			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0068			display_fb3: equ  display_fb1-display_fb_len - 1  
0068			display_fb2: equ  display_fb3-display_fb_len - 1  
0068			;  
0068			; pointer to active frame buffer  
0068			display_fb_active: equ display_fb2 - 2  
0068			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0068			display_write_tmp: equ display_lcde1e2 - 2  
0068			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
0068			  
0068			;  
0068			  
0068			;; can load into de directory  
0068			cursor_col: equ display_active-1  
0068			cursor_row: equ cursor_col-1  
0068			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0068			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0068			  
0068			; maths vars  
0068			  
0068			LFSRSeed: equ cursor_shape -20   
0068			randData: equ LFSRSeed - 2  
0068			xrandc: equ randData - 2  
0068			stackstore: equ xrandc - 2  
0068			seed1: equ  stackstore -2   
0068			seed2: equ seed1 - 2  
0068			  
0068			; cf storage vars  
0068			  
0068			iErrorNum:  equ seed2-1         ;Error number  
0068			iErrorReg:  equ iErrorNum -1              ;Error register  
0068			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0068			  
0068			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0068			  
0068			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
0068			  
0068			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
0068			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0068			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
0068			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
0068			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
0068			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
0068			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0068			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0068			store_tmpid: equ store_tmp3 - 1		; page temp id  
0068			store_tmpext: equ store_tmpid - 1		; file extent temp  
0068			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
0068			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
0068			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
0068			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0068			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
0068			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0068			;  
0068			; spi vars  
0068			  
0068			  
0068			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
0068			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
0068			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0068			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0068			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0068			spi_device_id: equ spi_device - 1    ; human readable bank number  
0068			  
0068			;;;;; forth cli params  
0068			  
0068			; TODO use a different frame buffer for forth???  
0068			  
0068			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0068			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0068			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0068			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0068			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0068			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0068			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0068			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0068			  
0068			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0068			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0068			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0068			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
0068			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
0068			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0068			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0068			  
0068			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0068			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0068			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0068			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0068			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0068			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0068			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0068			  
0068			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0068			  
0068			; os/forth token vars  
0068			  
0068			os_last_cmd: equ os_var_array-255  
0068			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0068			os_current_i: equ os_cli_cmd-2  
0068			os_cur_ptr: equ os_current_i-2  
0068			os_word_scratch: equ os_cur_ptr-30  
0068			os_tok_len: equ os_word_scratch - 2  
0068			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0068			os_tok_malloc: equ os_tok_ptr - 2  
0068			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0068			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0068			execscratch: equ os_input-255        ; exec cmd eval buffer  
0068			scratch: equ execscratch-255  
0068			  
0068			os_stack_1: equ scratch - 3       ; stack holding area 1  
0068			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
0068			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
0068			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
0068			  
0068			  
0068			; temp locations for new word processing to save on adding more   
0068			  
0068			os_new_malloc: equ os_stack_4-2  
0068			os_new_parse_len: equ os_new_malloc - 2  
0068			os_new_word_len: equ os_new_parse_len - 2  
0068			os_new_work_ptr: equ os_new_word_len - 2  
0068			os_new_src_ptr: equ os_new_work_ptr - 2  
0068			os_new_exec: equ os_new_src_ptr - 2  
0068			os_new_exec_ptr: equ os_new_exec - 2  
0068			  
0068			; resume memory alloocations....  
0068			  
0068			;os_view_disable: equ os_new_exec_ptr - 1  
0068			os_view_af: equ os_new_exec_ptr - 2  
0068			os_view_hl: equ os_view_af -2  
0068			os_view_de: equ os_view_hl - 2  
0068			os_view_bc: equ os_view_de - 2  
0068			  
0068			; stack checksum word  
0068			if DEBUG_STACK_IMB  
0068				curframe: equ  os_view_de - 5  
0068				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0068				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0068			else  
0068				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0068			endif  
0068			  
0068			; with data stack could see memory filled with junk. need some memory management   
0068			; malloc and free entry points added  
0068			  
0068			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0068			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0068			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			;heap_end: equ free_list-1  ; Starting address of heap  
0068			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			  
0068			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			heap_end: equ chk_word-1  ; Starting address of heap  
0068			  
0068			  
0068			;if BASE_KEV   
0068			;heap_start: equ 0800eh  ; Starting address of heap  
0068			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0068			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0068			;endif  
0068			  
0068			;if BASE_SC114  
0068			;heap_start: equ baseram+15  ; Starting address of heap  
0068			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0068			;endif  
0068			  
0068			  
0068			;;;;  
0068			  
0068			  
0068			; change below to point to last memory alloc above  
0068			topusermem:  equ   heap_start  
0068			  
0068			;if BASE_KEV   
0068			;baseusermem: equ 08000h  
0068			;endif  
0068			  
0068			;if BASE_SC114  
0068			;;aseusermem:     equ    12  
0068			;baseusermem:     equ    prompt  
0068			;;baseusermem:     equ    endofcode  
0068			;endif  
0068			  
0068			  
0068			; **********************************************************************  
0068			; **  Constants  
0068			; **********************************************************************  
0068			  
0068			; Constants used by this code module  
0068			kDataReg:   EQU Device_D           ;PIO port A data register  
0068			kContReg:   EQU Device_D+2           ;PIO port A control register  
0068			  
0068			  
0068			portbdata:  equ Device_D+1    ; port b data  
0068			portbctl:   equ Device_D+3    ; port b control  
0068			  
0068			  
0068			;KEY_SHIFT:   equ 5  
0068			;KEY_SYMBOLSHIFT:  equ 6  
0068			  
0068			KEY_SHIFTLOCK: equ 4  
0068			  
0068			  
0068			KEY_UP: equ 5  
0068			KEY_NEXTWORD: equ 6  
0068			KEY_PREVWORD: equ 7  
0068			KEY_BS: equ 8  
0068			KEY_TAB:  equ 9  
0068			KEY_DOWN: equ 10  
0068			KEY_LEFT: equ 11  
0068			KEY_RIGHT: equ 12  
0068			KEY_CR:   equ 13  
0068			KEY_HOME: equ 14  
0068			KEY_END: equ 15  
0068			  
0068			KEY_F1: equ 16  
0068			KEY_F2: equ 17  
0068			KEY_F3: equ 18  
0068			KEY_F4: equ 19  
0068			  
0068			KEY_F5: equ 20  
0068			KEY_F6: equ 21  
0068			KEY_F7: equ 22  
0068			KEY_F8: equ 23  
0068			  
0068			KEY_F9: equ 24  
0068			KEY_F10: equ 25  
0068			KEY_F11: equ 26  
0068			KEY_F12: equ 27  
0068			  
0068			;if DEBUG_KEY  
0068			;	KEY_MATRIX_NO_PRESS: equ '.'  
0068			;	KEY_SHIFT:   equ '.'  
0068			;	KEY_SYMBOLSHIFT:  equ '.'  
0068			;else  
0068				KEY_SHIFT:   equ '~'  
0068				KEY_SYMBOLSHIFT:  equ '~'  
0068				KEY_MATRIX_NO_PRESS: equ '~'  
0068			;endi  
0068			  
0068			  
0068			  
0068			  
0068			; Macro to make adding debug marks easier  
0068			  
0068			DMARK: macro str  
0068				push af  
0068				ld a, (.dmark)  
0068				ld (debug_mark),a  
0068				ld a, (.dmark+1)  
0068				ld (debug_mark+1),a  
0068				ld a, (.dmark+2)  
0068				ld (debug_mark+2),a  
0068				jr .pastdmark  
0068			.dmark: db str  
0068			.pastdmark: pop af  
0068			  
0068			endm  
0068			  
0068			  
0068			; macro to detect for stack imbalances  
0068			  
0068			include "stackimbal.asm"  
0068			; Macro and code to detect stock imbalances 
0068			 
0068			SPPUSH: equ 0 
0068			 
0068			; Add a stack frame which can be checked before return 
0068			 
0068			STACKFRAME: macro onoff frame1 frame2 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						; save current SP 
0068						exx 
0068			 
0068						ld de, frame1 
0068						ld a, d 
0068						ld hl, curframe 
0068						call hexout 
0068						ld a, e 
0068						ld hl, curframe+2 
0068						call hexout 
0068			  
0068						ld hl, frame1 
0068						push hl 
0068						ld hl, frame2 
0068						push hl 
0068						exx 
0068					endif 
0068					 
0068				endif 
0068			endm 
0068			 
0068			STACKFRAMECHK: macro onoff frame1 frame2 
0068			 
0068					 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						exx 
0068						; check stack frame SP 
0068			 
0068						ld hl, frame2 
0068						pop de   ; frame2 
0068			 
0068						call cmp16 
0068						jr nz, .spnosame 
0068						 
0068			 
0068						ld hl, frame1 
0068						pop de   ; frame1 
0068			 
0068						call cmp16 
0068						jr z, .spfrsame 
0068			 
0068						.spnosame: call showsperror 
0068			 
0068						.spfrsame: nop 
0068			 
0068						exx 
0068					endif 
0068					 
0068				endif 
0068			 
0068			 
0068			endm 
0068			 
0068			 
0068			; for a sub routine, wrap SP collection and comparisons 
0068			 
0068			; Usage: 
0068			; 
0068			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0068			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0068			 
0068			SAVESP: macro onoff storeword 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						; save current SP 
0068			 
0068						ld (store_sp+(storeword*4)), sp 
0068			 
0068					endif 
0068					 
0068				endif 
0068			 
0068			endm 
0068			 
0068			CHECKSP: macro onoff storeword 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068			 
0068						; save SP after last save 
0068				 
0068						ld (store_sp+(storeword*4)+2), sp 
0068			 
0068						push hl 
0068						ld hl, store_sp+(storeword*4) 
0068						call check_stack_sp  
0068						pop hl 
0068			 
0068			 
0068					endif 
0068					 
0068				endif 
0068			 
0068			endm 
0068			 
0068			if DEBUG_STACK_IMB 
0068			 
0068			check_stack_sp: 
0068					push de 
0068			 
0068					ld e, (hl) 
0068					inc hl 
0068					ld d, (hl) 
0068					inc hl 
0068			 
0068					push de 
0068			 
0068			 
0068					ld e, (hl) 
0068					inc hl 
0068					ld d, (hl) 
0068					inc hl 
0068			 
0068					pop hl 
0068			 
0068			 
0068					; check to see if the same 
0068			 
0068					call cmp16 
0068					jr z, .spsame 
0068			 
0068					; not same 
0068			 
0068					call showsperror 
0068			.spsame: 
0068			 
0068					pop de 
0068			 
0068					ret 
0068			 
0068			.sperr:  db "Stack imbalance",0 
0068			 
0068			 
0068			showsperror: 
0068			 
0068			 
0068				push hl 
0068				push af 
0068				push de 
0068				call clear_display 
0068				ld de, .sperr 
0068				ld a,0 
0068			;	ld de,os_word_scratch 
0068				call str_at_display 
0068				ld a, display_row_1+17 
0068				ld de, debug_mark 
0068				call str_at_display 
0068				ld a, 0 
0068				ld (curframe+4),a 
0068				ld hl, curframe 
0068				ld de, os_word_scratch 
0068				ld a, display_row_4 
0068				call str_at_display 
0068				call update_display 
0068				;call break_point_state 
0068				call cin_wait 
0068			 
0068			;	ld a, ' ' 
0068			;	ld (os_view_disable), a 
0068				call bp_on 
0068				pop de	 
0068				pop af 
0068				pop hl 
0068				CALLMONITOR 
0068				ret 
0068			 
0068			endif 
0068			 
0068			 
0068			 
0068			; eof 
# End of file stackimbal.asm
0068			  
0068			;TODO macro to calc col and row offset into screen  
0068			  
0068			  
0068			  
0068			hardware_init:  
0068			  
0068				  
0068			  
0068					;ld a, 0  
0068					;ld (hardware_diag), a  
0068			  
0068					; clear all the buffers  
0068			  
0068 21 4b fc				ld hl, display_fb1  
006b 22 07 fb				ld (display_fb_active), hl  
006e			  
006e cd 9b 0d				call clear_display  
0071			  
0071 21 09 fb				ld hl, display_fb2  
0074 22 07 fb				ld (display_fb_active), hl  
0077			  
0077 cd 9b 0d				call clear_display  
007a			  
007a					; init primary frame buffer area  
007a 21 ec fc				ld hl, display_fb0  
007d 22 07 fb				ld (display_fb_active), hl  
0080			  
0080 cd 9b 0d				call clear_display  
0083			  
0083			  
0083 cd 06 77				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0086			  
0086 cd 9d 79			call key_init  
0089 cd 47 02			call storage_init  
008c			  
008c				; setup malloc functions  
008c			  
008c				if MALLOC_1  
008c cd 7e 14				call  heap_init  
008f				endif  
008f				if MALLOC_4  
008f					call  heap_init  
008f				endif  
008f			  
008f				; init sound hardware if present  
008f			  
008f				if SOUND_ENABLE  
008f					call sound_init  
008f				endif  
008f			  
008f				; lcd test sequence  
008f					  
008f cd be 0d			call update_display  
0092 cd de 0c			call delay1s  
0095 3e 2b			ld a,'+'  
0097 cd a0 0d			call fill_display  
009a cd be 0d			call update_display  
009d cd de 0c			call delay1s  
00a0 3e 2a			ld a,'*'  
00a2 cd a0 0d			call fill_display  
00a5 cd be 0d			call update_display  
00a8 cd de 0c			call delay1s  
00ab 3e 2d			ld a,'-'  
00ad cd a0 0d			call fill_display  
00b0 cd be 0d			call update_display  
00b3 cd de 0c			call delay1s  
00b6			  
00b6			; boot splash screen  
00b6			if display_cols == 20	  
00b6			        ld a, display_row_1    
00b6			else  
00b6 3e 0a		        ld a, display_row_1 +10   
00b8			endif  
00b8 11 10 1c			ld de, prom_bootmsg  
00bb cd ae 0d			call str_at_display  
00be cd be 0d			call update_display  
00c1			  
00c1			  
00c1 cd de 0c			call delay1s  
00c4 cd de 0c			call delay1s  
00c7			if display_cols == 20	  
00c7			            LD   A, display_row_3+2  
00c7			else  
00c7 3e 5c		            LD   A, display_row_3+12  
00c9			endif  
00c9 11 25 1c			ld de, prom_bootmsg1  
00cc cd ae 0d			call str_at_display  
00cf cd be 0d			call update_display  
00d2 cd de 0c			call delay1s  
00d5 cd de 0c			call delay1s  
00d8			  
00d8			;	ld a, display_row_4+3  
00d8			;	ld de, bootmsg2  
00d8			;	call str_at_display  
00d8			;	call update_display  
00d8			;	call delay1s  
00d8			;	call delay1s  
00d8			  
00d8			; debug mark setup  
00d8			  
00d8 3e 5f		ld a, '_'  
00da 32 a6 fd		ld (debug_mark),a  
00dd 32 a7 fd		ld (debug_mark+1),a  
00e0 32 a8 fd		ld (debug_mark+2),a  
00e3 3e 00		ld a,0  
00e5 32 a9 fd		ld (debug_mark+3),a  
00e8			  
00e8 c9					ret  
00e9			  
00e9			  
00e9			;bootmsg2:	db "Firmware v0.1",0  
00e9			  
00e9			; a 4x20 lcd  
00e9			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00e9			  
00e9			;if display_cols == 20  
00e9			;	include "firmware_lcd_4x20.asm"  
00e9			;endif  
00e9			  
00e9			;if display_cols == 40  
00e9			;	include "firmware_lcd_4x40.asm"  
00e9			;endif  
00e9			  
00e9			;  
00e9			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00e9			; TODO abstract the bit bang video out interface for dual display  
00e9			; TODO wire video out to tx pin on rc2014 bus  
00e9			  
00e9			; must supply cin, and cin_wait for low level hardware abstraction   
00e9			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00e9			; test scancode  
00e9			  
00e9			;;;;;  
00e9			;;;  
00e9			; Moved out to mini and maxi versions  
00e9			;  
00e9			; include "firmware_key_4x4.asm"  
00e9			; using existing 4 wire x 4 resistor array for input  
00e9			;include "firmware_key_4x10.asm"  
00e9			; need to mod the board for 5 rows due to resistor array  
00e9			;include "firmware_key_5x10.asm"  
00e9			  
00e9			; storage hardware interface  
00e9			  
00e9			; use microchip serial eeprom for storage  
00e9			  
00e9			  
00e9			if STORAGE_SE  
00e9				include "firmware_spi.asm"  
00e9			; my spi protocol (used by storage) 
00e9			 
00e9			; SPI pins 
00e9			 
00e9			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00e9			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00e9			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00e9			 
00e9			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00e9			; chip pin 4 gnd 
00e9			 
00e9			 
00e9			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00e9			SPI_CE1: equ 1      ;    port a1 pin 14  
00e9			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00e9			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00e9			SPI_CE4: equ 4      ; port a4     pin 10 
00e9			 
00e9			; active low AND masks 
00e9			 
00e9			;SPI_CE0_MASK: equ    255-1 
00e9			;SPI_CE1_MASK: equ   255-2 
00e9			;SPI_CE2_MASK: equ   255-4 
00e9			;SPI_CE3_MASK: equ   255-8 
00e9			;SPI_CE4_MASK: equ   255-16 
00e9			SPI_CE_HIGH:  equ 255 
00e9			 
00e9			 
00e9			 
00e9			;  Perform SCLK wait pulse 
00e9			 
00e9			spi_clk: 
00e9 f5				push af 
00ea 3a 9f f9			ld a, (spi_clktime) 
00ed fe 00			cp 0 
00ef 28 03			jr z, .scskip 
00f1 cd c3 0c			call aDelayInMS 
00f4			.scskip: 
00f4 f1				pop af 
00f5 c9				ret 
00f6			 
00f6			 
00f6			 
00f6			; TODO store port id for spi device ie dev c 
00f6			; TODO store pin for SO 
00f6			; TODO store pin for SI 
00f6			; TODO store pin for SCLK 
00f6			 
00f6			; 
00f6			 
00f6			; ensure that spi bus is in a stable state with default pins  
00f6			 
00f6			se_stable_spi:   
00f6			 
00f6				 ; set DI high, CE high , SCLK low 
00f6				;ld a, SPI_DI | SPI_CE0 
00f6 3e 07			ld a, SPI_DI  
00f8 cd 02 02			call spi_ce_high 
00fb d3 80			 out (storage_adata),a 
00fd 32 9c f9			ld (spi_portbyte),a 
0100			 
0100				if DEBUG_SPI 
0100					push hl 
0100					ld l, a 
0100					DMARK "SPI" 
0100					CALLMONITOR 
0100					pop hl 
0100				endif 
0100 c9				ret 
0101			 
0101			; byte to send in a 
0101			 
0101			spi_send_byte: 
0101				; save byte to send for bit mask shift out 
0101 4f			        ld c,a 
0102 3a 9c f9			ld a,(spi_portbyte) 
0105				  
0105				; clock out	each bit of the byte msb first 
0105			 
0105 06 08			ld b, 8 
0107			.ssb1: 
0107				; clear so bit  
0107 cb bf			res SPI_DI, a 
0109 cb 11			rl c 
010b				; if bit 7 is set then carry is set 
010b 30 02			jr nc, .ssb2 
010d cb ff			set SPI_DI,a 
010f			.ssb2:  ; output bit to ensure it is stable 
010f d3 80			out (storage_adata),a 
0111 00				nop 
0112				; clock bit high 
0112 cb ef			set SPI_SCLK,a 
0114 d3 80			out (storage_adata),a 
0116 00				nop 
0117 cd e9 00			call spi_clk 
011a				; then low 
011a cb af			res SPI_SCLK,a 
011c d3 80			out (storage_adata),a 
011e 00				nop 
011f cd e9 00			call spi_clk 
0122 10 e3			djnz .ssb1 
0124			 
0124 32 9c f9			ld (spi_portbyte),a 
0127 c9				ret 
0128			 
0128			; TODO low level get byte into A on spi 
0128			 
0128			spi_read_byte:  
0128			 
0128				; save byte to send for bit mask shift out 
0128 0e 00		    ld c,0 
012a 3a 9c f9			ld a,(spi_portbyte) 
012d				  
012d				; clock out	each bit of the byte msb first 
012d			 
012d			 
012d				; clock bit high 
012d cb ef			set SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132 cd e9 00			call spi_clk 
0135			 
0135			    ; read DO  
0135			 
0135 cb f9		    set 7,c 
0137 db 80			in a,(storage_adata) 
0139 cb 77		    bit SPI_DO,a 
013b 20 02		    jr nz, .b7 
013d cb b9		    res 7,c 
013f			.b7: 
013f				; then low 
013f cb af			res SPI_SCLK,a 
0141 d3 80			out (storage_adata),a 
0143 00				nop 
0144 cd e9 00			call spi_clk 
0147			     
0147			 
0147				; clock bit high 
0147 cb ef			set SPI_SCLK,a 
0149 d3 80			out (storage_adata),a 
014b 00				nop 
014c cd e9 00			call spi_clk 
014f			 
014f			    ; read DO  
014f			 
014f cb f1		    set 6,c 
0151 db 80			in a,(storage_adata) 
0153 cb 77		    bit SPI_DO,a 
0155 20 02		    jr nz, .b6 
0157 cb b1		    res 6,c 
0159			.b6: 
0159				; then low 
0159 cb af			res SPI_SCLK,a 
015b d3 80			out (storage_adata),a 
015d 00				nop 
015e cd e9 00			call spi_clk 
0161			 
0161				; clock bit high 
0161 cb ef			set SPI_SCLK,a 
0163 d3 80			out (storage_adata),a 
0165 00				nop 
0166 cd e9 00			call spi_clk 
0169			 
0169			 
0169			    ; read DO  
0169			 
0169 cb e9		    set 5,c 
016b db 80			in a,(storage_adata) 
016d cb 77		    bit SPI_DO,a 
016f 20 02		    jr nz, .b5 
0171 cb a9		    res 5,c 
0173			.b5: 
0173				; then low 
0173 cb af			res SPI_SCLK,a 
0175 d3 80			out (storage_adata),a 
0177 00				nop 
0178 cd e9 00			call spi_clk 
017b				; clock bit high 
017b cb ef			set SPI_SCLK,a 
017d d3 80			out (storage_adata),a 
017f 00				nop 
0180 cd e9 00			call spi_clk 
0183			 
0183			    ; read DO  
0183			 
0183 cb e1		    set 4,c 
0185 db 80			in a,(storage_adata) 
0187 cb 77		    bit SPI_DO,a 
0189 20 02		    jr nz, .b4 
018b cb a1		    res 4,c 
018d			.b4: 
018d				; then low 
018d cb af			res SPI_SCLK,a 
018f d3 80			out (storage_adata),a 
0191 00				nop 
0192 cd e9 00			call spi_clk 
0195				; clock bit high 
0195 cb ef			set SPI_SCLK,a 
0197 d3 80			out (storage_adata),a 
0199 00				nop 
019a cd e9 00			call spi_clk 
019d			 
019d			    ; read DO  
019d			 
019d cb d9		    set 3,c 
019f db 80			in a,(storage_adata) 
01a1 cb 77		    bit SPI_DO,a 
01a3 20 02		    jr nz, .b3 
01a5 cb 99		    res 3,c 
01a7			.b3: 
01a7				; then low 
01a7 cb af			res SPI_SCLK,a 
01a9 d3 80			out (storage_adata),a 
01ab 00				nop 
01ac cd e9 00			call spi_clk 
01af				; clock bit high 
01af cb ef			set SPI_SCLK,a 
01b1 d3 80			out (storage_adata),a 
01b3 00				nop 
01b4 cd e9 00			call spi_clk 
01b7			 
01b7			    ; read DO  
01b7			 
01b7 cb d1		    set 2,c 
01b9 db 80			in a,(storage_adata) 
01bb cb 77		    bit SPI_DO,a 
01bd 20 02		    jr nz, .b2 
01bf cb 91		    res 2,c 
01c1			.b2: 
01c1				; then low 
01c1 cb af			res SPI_SCLK,a 
01c3 d3 80			out (storage_adata),a 
01c5 00				nop 
01c6 cd e9 00			call spi_clk 
01c9				; clock bit high 
01c9 cb ef			set SPI_SCLK,a 
01cb d3 80			out (storage_adata),a 
01cd 00				nop 
01ce cd e9 00			call spi_clk 
01d1			 
01d1			    ; read DO  
01d1			 
01d1 cb c9		    set 1,c 
01d3 db 80			in a,(storage_adata) 
01d5 cb 77		    bit SPI_DO,a 
01d7 20 02		    jr nz, .b1 
01d9 cb 89		    res 1,c 
01db			.b1: 
01db				; then low 
01db cb af			res SPI_SCLK,a 
01dd d3 80			out (storage_adata),a 
01df 00				nop 
01e0 cd e9 00			call spi_clk 
01e3				; clock bit high 
01e3 cb ef			set SPI_SCLK,a 
01e5 d3 80			out (storage_adata),a 
01e7 00				nop 
01e8 cd e9 00			call spi_clk 
01eb			 
01eb			    ; read DO  
01eb			 
01eb cb c1		    set 0,c 
01ed db 80			in a,(storage_adata) 
01ef cb 77		    bit SPI_DO,a 
01f1 20 02		    jr nz, .b0 
01f3 cb 81		    res 0,c 
01f5			.b0: 
01f5				; then low 
01f5 cb af			res SPI_SCLK,a 
01f7 d3 80			out (storage_adata),a 
01f9 00				nop 
01fa cd e9 00			call spi_clk 
01fd			 
01fd			 
01fd 32 9c f9			ld (spi_portbyte),a 
0200			 
0200			    ; return byte 
0200 79			    ld a,c 
0201			 
0201			 
0201 c9				ret 
0202			 
0202			 
0202			 
0202			spi_ce_high: 
0202			 
0202				if DEBUG_SPI_HARD_CE0 
0202			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0202					ret 
0202			 
0202				endif 
0202			 
0202			 
0202 f5				push af 
0203			 
0203				; send direct ce to port b 
0203 3e ff			ld a, 255 
0205 d3 81			out (storage_bdata), a 
0207			 
0207 f1				pop af 
0208			 
0208				; for port a that shares with spi lines AND the mask 
0208			  
0208				if DEBUG_SPI 
0208					push hl 
0208					ld h, a 
0208				endif 
0208			;	ld c, SPI_CE_HIGH 
0208			;	and c 
0208 cb c7			set SPI_CE0, a 
020a cb cf			set SPI_CE1, a 
020c cb d7			set SPI_CE2, a 
020e cb df			set SPI_CE3, a 
0210 cb e7			set SPI_CE4, a 
0212			 
0212				if DEBUG_SPI 
0212					ld l, a 
0212					DMARK "CEh" 
0212					CALLMONITOR 
0212					pop hl 
0212				endif 
0212 c9				ret 
0213			 
0213			 
0213			spi_ce_low: 
0213			 
0213				if DEBUG_SPI_HARD_CE0 
0213			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0213					ret 
0213			 
0213				endif 
0213			 
0213 c5				push bc 
0214 f5				push af 
0215			 
0215				; send direct ce to port b 
0215 3a 9e f9			ld a, (spi_cartdev) 
0218 d3 81			out (storage_bdata), a 
021a			 
021a			 
021a			 
021a				; for port a that shares with spi lines AND the mask 
021a			 
021a 3a 9b f9			ld a, (spi_device)  
021d 4f				ld c, a 
021e			 
021e f1				pop af 
021f			 
021f				; detect CEx 
021f			 
021f				if DEBUG_SPI 
021f					push hl 
021f					ld h, a 
021f				endif 
021f			 
021f cb 41			bit SPI_CE0, c 
0221 20 04			jr nz, .cel1 
0223 cb 87			res SPI_CE0, a 
0225 18 1e			jr .celn 
0227			.cel1: 
0227 cb 49			bit SPI_CE1, c 
0229 20 04			jr nz, .cel2 
022b cb 8f			res SPI_CE1, a 
022d 18 16			jr .celn 
022f			.cel2: 
022f cb 51			bit SPI_CE2, c 
0231 20 04			jr nz, .cel3 
0233 cb 97			res SPI_CE2, a 
0235 18 0e			jr .celn 
0237			.cel3: 
0237 cb 59			bit SPI_CE3, c 
0239 20 04			jr nz, .cel4 
023b cb 9f			res SPI_CE3, a 
023d 18 06			jr .celn 
023f			.cel4: 
023f cb 61			bit SPI_CE4, c 
0241 20 02			jr nz, .celn 
0243 cb a7			res SPI_CE4, a 
0245			.celn: 
0245			 
0245			 
0245			 
0245			;	add c 
0245			 
0245				if DEBUG_SPI 
0245					ld l, a 
0245					DMARK "CEl" 
0245					CALLMONITOR 
0245					pop hl 
0245				endif 
0245 c1				pop bc 
0246 c9				ret 
0247			 
0247			 
0247			 
0247			; eof 
0247			 
0247			 
0247			 
0247			 
0247			 
# End of file firmware_spi.asm
0247				include "firmware_seeprom.asm"  
0247			; 
0247			; persisent storage interface via microchip serial eeprom 
0247			 
0247			; port a pio 2 
0247			; pa 7 - si 
0247			; pa 6 - sclk  
0247			; pa 5 - so 
0247			; pa 4 - cs 
0247			; pa 3 - cs 
0247			; pa 2 - cs 
0247			; pa 1 - cs 
0247			; pa 0 - cs 
0247			; 
0247			; TODO get block 
0247			; TODO save block 
0247			; TODO load file 
0247			; TODO save file 
0247			; TODO get dir  
0247			 
0247			;  
0247			storage_adata: equ Device_C    ; device c port a - onboard storage 
0247			storage_actl: equ Device_C+2     ; device c port a 
0247			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0247			storage_bctl: equ Device_C+3     ; device c port b 
0247			 
0247			 
0247			; TODO move these to hardware driver file 
0247			 
0247			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0247			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0247			; storage bank file system format 
0247			; 
0247			; first page of bank: 
0247			; 	addr 0 - status check 
0247			;       addr 1 - write protect flag 
0247			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0247			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0247			;         TODO see if scanning whole of for available next file id is fast enough 
0247			;	addr 4 > zero term string of bank label 
0247			; 
0247			;        
0247			;  
0247			; first page of any file: 
0247			;      byte 0 - file id  
0247			;      byte 1-17 - fixed file name  
0247			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0247			; 
0247			; other pages of any file: 
0247			;      byte 0 - file id 
0247			;      byte 1> - file data 
0247			; 
0247			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0247			;  
0247			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0247			 
0247			 
0247			;storage_so_bit: 5 
0247			;storage_si_bit: 7 
0247			;storage_sclk_bit: 6 
0247			  
0247			 
0247			; init storage pio 
0247			 
0247			storage_init: 
0247			 
0247			 
0247					; set default SPI clk pulse time as disabled 
0247			 
0247 3e 00				ld a, 0 
0249 32 9f f9				ld (spi_clktime), a 
024c			 
024c					; init hardware 
024c			 
024c 3e cf		            LD   A, 11001111b 
024e d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0250 3e 00		            LD   A, 00000000b 
0252 cb f7			set SPI_DO,a 
0254			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0254 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0256			 
0256 3e cf		            LD   A, 11001111b 
0258 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
025a 3e 00		            LD   A, 00000000b 
025c d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
025e			 
025e				; set all external spi devices off  
025e 3e ff			ld a, 255 
0260 32 9b f9			ld (spi_device), a 
0263 32 9e f9			ld (spi_cartdev), a 
0266			 
0266					; ensure the spi bus is in a default stable state 
0266 cd f6 00				call se_stable_spi 
0269			 
0269			; TODO scan spi bus and gather which storage banks are present 
0269			 
0269			; populate store_bank_active  
0269			; for each ce line activate and attempt to write first byte of bank and read back 
0269			; if zero is returned then bank is empty 
0269			;   
0269			; 
0269			 
0269					; init file extent cache to save on slow reads 
0269			 
0269			;	ld hl, store_filecache 
0269			;	ld de, 0 
0269			;	ld hl,(de)	 
0269			 
0269			 
0269 c9			    ret 
026a			 
026a			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
026a			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
026a			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
026a			 
026a			; INSTRUCTION SET 
026a			; READ 0000 0011 Read data from memory array beginning at selected address 
026a			; WRITE 0000 0010 Write data to memory array beginning at selected address 
026a			; WREN 0000 0110 Set the write enable latch (enable write operations) 
026a			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
026a			; RDSR 0000 0101 Read STATUS register 
026a			; WRSR 0000 0001 Write STATUS register 
026a			; PE 0100 0010 Page Erase – erase one page in memory array 
026a			; SE 1101 1000 Sector Erase – erase one sector in memory array 
026a			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
026a			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
026a			 
026a			; TODO send byte steam for page without setting the address for every single byte 
026a			; TODO read byte  
026a			 
026a			; byte in a 
026a			; address in hl  
026a			se_writebyte: 
026a			        
026a			    ;   ld c, a 
026a f5			        push af 
026b e5			        push hl 
026c			 
026c			    ; initi write mode 
026c			    ; 
026c			    ;CS low 
026c			 
026c 3a 9c f9		       ld a,(spi_portbyte) 
026f cd 13 02			call spi_ce_low 
0272			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0272 d3 80		       out (storage_adata),a 
0274 32 9c f9		       ld (spi_portbyte), a 
0277			 
0277			    ;clock out wren instruction 
0277			 
0277 3e 06		    ld a, store_wren_ins 
0279 cd 01 01		    call spi_send_byte  
027c			 
027c			    ;cs high to enable write latch 
027c			 
027c 3a 9c f9		       ld a,(spi_portbyte) 
027f cd 02 02			call spi_ce_high 
0282			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0282 d3 80		       out (storage_adata),a 
0284 32 9c f9		       ld (spi_portbyte), a 
0287			 
0287 00				nop 
0288			    ; 
0288			    ; intial write data 
0288			    ; 
0288			    ; cs low 
0288			     
0288 3a 9c f9		       ld a,(spi_portbyte) 
028b cd 13 02			call spi_ce_low 
028e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028e d3 80		       out (storage_adata),a 
0290 32 9c f9		       ld (spi_portbyte), a 
0293			 
0293			    ; clock out write instruction 
0293			     
0293 3e 02		    ld a, store_write_ins  
0295 cd 01 01		    call spi_send_byte  
0298			 
0298			    ; clock out address (depending on address size) 
0298			     
0298 e1			    pop hl 
0299 7c			    ld a,h    ; address out msb first 
029a cd 01 01		    call spi_send_byte  
029d 7d			    ld a,l 
029e cd 01 01		    call spi_send_byte  
02a1			 
02a1			    ; clock out byte(s) for page 
02a1			 
02a1 f1			    pop af 
02a2 cd 01 01		    call spi_send_byte  
02a5			 
02a5			    ; end write with ce high 
02a5 3a 9c f9		       ld a,(spi_portbyte) 
02a8			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02a8 cd 02 02			call spi_ce_high 
02ab d3 80		       out (storage_adata),a 
02ad 32 9c f9		       ld (spi_portbyte), a 
02b0			 
02b0				; pause for internal write cycle 
02b0 3e 0a			ld a, 10 
02b2 cd c3 0c			call aDelayInMS 
02b5 c9			    ret 
02b6			 
02b6			; buffer to write in de 
02b6			; address in hl  
02b6			se_writepage: 
02b6			        
02b6			    ;   ld c, a 
02b6 d5				push de 
02b7 e5			        push hl 
02b8			 
02b8			    ; initi write mode 
02b8			    ; 
02b8			    ;CS low 
02b8			 
02b8 3a 9c f9		       ld a,(spi_portbyte) 
02bb cd 13 02			call spi_ce_low 
02be			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02be d3 80		       out (storage_adata),a 
02c0 32 9c f9		       ld (spi_portbyte), a 
02c3			 
02c3			    ;clock out wren instruction 
02c3			 
02c3 3e 06		    ld a, store_wren_ins 
02c5 cd 01 01		    call spi_send_byte  
02c8			 
02c8			    ;cs high to enable write latch 
02c8			 
02c8 3a 9c f9		       ld a,(spi_portbyte) 
02cb cd 02 02			call spi_ce_high 
02ce			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02ce d3 80		       out (storage_adata),a 
02d0 32 9c f9		       ld (spi_portbyte), a 
02d3			 
02d3 00				nop 
02d4			    ; 
02d4			    ; intial write data 
02d4			    ; 
02d4			    ; cs low 
02d4			     
02d4 3a 9c f9		       ld a,(spi_portbyte) 
02d7			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02d7 cd 13 02			call spi_ce_low 
02da d3 80		       out (storage_adata),a 
02dc 32 9c f9		       ld (spi_portbyte), a 
02df			 
02df			    ; clock out write instruction 
02df			     
02df 3e 02		    ld a, store_write_ins  
02e1 cd 01 01		    call spi_send_byte  
02e4			 
02e4			    ; clock out address (depending on address size) 
02e4			     
02e4 e1			    pop hl 
02e5 7c			    ld a,h    ; address out msb first 
02e6 cd 01 01		    call spi_send_byte  
02e9 7d			    ld a,l 
02ea cd 01 01		    call spi_send_byte  
02ed			 
02ed			    ; clock out byte(s) for page 
02ed			 
02ed e1				pop hl 
02ee 06 40			ld b, STORE_BLOCK_PHY 
02f0			.bytewrite: 
02f0			 
02f0 7e				ld a,(hl) 
02f1 e5			    push hl 
02f2 c5				push bc 
02f3 cd 01 01		    call spi_send_byte  
02f6 c1				pop bc 
02f7 e1				pop hl 
02f8			 
02f8			    ; end write with ce high 
02f8 3a 9c f9		       ld a,(spi_portbyte) 
02fb cd 02 02			call spi_ce_high 
02fe			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02fe d3 80		       out (storage_adata),a 
0300 32 9c f9		       ld (spi_portbyte), a 
0303			 
0303 23				inc hl 
0304 10 ea			djnz .bytewrite 
0306			 
0306				; pause for internal write cycle 
0306 3e 64			ld a, 100 
0308 cd c3 0c			call aDelayInMS 
030b c9			    ret 
030c			; returns byte in a 
030c			; address in hl  
030c			se_readbyte: 
030c d5				push de 
030d c5				push bc 
030e			 
030e			    ;   ld c, a 
030e e5			        push hl 
030f			 
030f			    ; initi write mode 
030f			    ; 
030f			    ;CS low 
030f			 
030f 3a 9c f9		       ld a,(spi_portbyte) 
0312 cd 13 02			call spi_ce_low 
0315			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0315 d3 80		       out (storage_adata),a 
0317 32 9c f9		       ld (spi_portbyte), a 
031a			 
031a			    ;clock out wren instruction 
031a			 
031a 3e 03		    ld a, store_read_ins 
031c cd 01 01		    call spi_send_byte  
031f			 
031f			 
031f			    ; clock out address (depending on address size) 
031f			     
031f e1			    pop hl 
0320 7c			    ld a,h    ; address out msb first 
0321 cd 01 01		    call spi_send_byte  
0324 7d			    ld a,l 
0325 cd 01 01		    call spi_send_byte  
0328			 
0328			    ; clock in byte(s) for page 
0328			 
0328 cd 28 01		    call spi_read_byte  
032b f5				push af 
032c			 
032c			    ; end write with ce high 
032c 3a 9c f9		       ld a,(spi_portbyte) 
032f			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
032f cd 02 02			call spi_ce_high 
0332 d3 80		       out (storage_adata),a 
0334 32 9c f9		       ld (spi_portbyte), a 
0337			 
0337 f1				pop af 
0338			 
0338 c1				pop bc 
0339 d1				pop de 
033a			 
033a c9			    ret 
033b			 
033b			if DEBUG_STORESE 
033b			 
033b			storageput:  
033b			 
033b			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
033b			 
033b 21 fe f0			ld hl,scratch+2 
033e cd 86 13			call get_word_hl 
0341			 
0341				; stuff it here for the moment as it will be overwritten later anyway 
0341			 
0341 22 1f f4			ld (os_cur_ptr),hl	 
0344			 
0344			 
0344			; get pointer to start of string 
0344			 
0344 21 03 f1			ld hl, scratch+7 
0347			 
0347			; loop writing char of string to eeprom 
0347			 
0347 7e			.writestr:	ld a,(hl) 
0348 fe 00				cp 0 
034a 28 12				jr z, .wsdone		; done writing 
034c e5					push hl 
034d 2a 1f f4				ld hl,(os_cur_ptr) 
0350 cd 6a 02				call se_writebyte 
0353			 
0353 2a 1f f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0356 23					inc hl 
0357 22 1f f4				ld (os_cur_ptr),hl 
035a			 
035a					; restore string pointer and get next char 
035a			 
035a e1					pop hl 
035b 23					inc hl 
035c 18 e9				jr .writestr 
035e			 
035e			 
035e			 
035e			.wsdone: 
035e			 
035e			 
035e			; when done load first page into a buffer  
035e			 
035e 21 00 80				ld hl,08000h		; start in ram 
0361 22 1f f4				ld (os_cur_ptr),hl 
0364 21 00 00				ld hl, 0		 ; start of page 
0367 22 24 f1				ld (scratch+40),hl	; hang on to it 
036a			 
036a 06 80				ld b, 128		; actually get more then one page 
036c c5			.wsload:	push bc 
036d 2a 24 f1				ld hl,(scratch+40) 
0370 e5					push hl 
0371 cd 0c 03				call se_readbyte 
0374			 
0374					; a now as the byte 
0374			 
0374 2a 1f f4				ld hl,(os_cur_ptr) 
0377 77					ld (hl),a 
0378					; inc next buffer area 
0378 23					inc hl 
0379 22 1f f4				ld (os_cur_ptr),hl 
037c			 
037c					; get eeprom position, inc and save for next round 
037c e1					pop hl		 
037d 23					inc hl 
037e 22 24 f1				ld (scratch+40),hl 
0381 c1					pop bc 
0382 10 e8				djnz .wsload 
0384			 
0384			; set 'd' pointer to start of buffer 
0384			 
0384 21 00 80				ld hl,08000h 
0387 22 1f f4				ld (os_cur_ptr),hl 
038a			 
038a			 
038a c9			ret 
038b			 
038b			 
038b c9			storageread: ret 
038c			 
038c			 
038c			 
038c			 
038c			 
038c			 
038c			endif 
038c			 
038c			 
038c			 
# End of file firmware_seeprom.asm
038c			else  
038c			   ; create some stubs for the labels  
038c			se_readbyte: ret  
038c			se_writebyte: ret  
038c			storage_init: ret  
038c			  
038c			endif  
038c			  
038c			; use cf card for storage - throwing timeout errors. Hardware or software?????  
038c			;include "firmware_cf.asm"  
038c			  
038c			; load up high level storage hardward abstractions  
038c			include "firmware_storage.asm"  
038c			 
038c			; persisent storage hardware abstraction layer  
038c			 
038c			 
038c			 
038c			; Block 0 on storage is a config state 
038c			 
038c			 
038c			 
038c			; TODO add read phy block and write phy block functions 
038c			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
038c			 
038c			; Abstraction layer  
038c			 
038c			; Logocial block size is same size as physical size - using tape concept 
038c			 
038c			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
038c			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
038c			 
038c			 
038c			 
038c			; Filesystem layout (Logical layout) 
038c			; 
038c			; Block 0 - Bank config  
038c			; 
038c			;      Byte - 0 file id counter 
038c			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
038c			;      Byte - 3-20 zero terminated bank label 
038c			; 
038c			; Block 1 > File storage 
038c			; 
038c			;      Byte 0 file id    - block 0 file details 
038c			;      Byte 1 block id - block 0 is file  
038c			;            Byte 2-15 - File name 
038c			; 
038c			;       - to end of block data 
038c			; 
038c			 
038c			; Get ID for the file named in pointer held HL 
038c			; Returns ID in HL = 255 if no file found 
038c			 
038c			storage_getid: 
038c			 
038c 22 ae f9			ld (store_tmp1), hl 
038f			 
038f				if DEBUG_STORESE 
038f					DMARK "SGI" 
038f f5				push af  
0390 3a a4 03			ld a, (.dmark)  
0393 32 a6 fd			ld (debug_mark),a  
0396 3a a5 03			ld a, (.dmark+1)  
0399 32 a7 fd			ld (debug_mark+1),a  
039c 3a a6 03			ld a, (.dmark+2)  
039f 32 a8 fd			ld (debug_mark+2),a  
03a2 18 03			jr .pastdmark  
03a4 ..			.dmark: db "SGI"  
03a7 f1			.pastdmark: pop af  
03a8			endm  
# End of macro DMARK
03a8					CALLMONITOR 
03a8 cd aa fd			call debug_vector  
03ab				endm  
# End of macro CALLMONITOR
03ab				endif 
03ab				; get block 0 and set counter for number of files to scan 
03ab			 
03ab cd 16 05			call storage_get_block_0 
03ae			 
03ae 3a b5 f9			ld a, (store_page) 
03b1 47				ld b, a 
03b2			 
03b2				; get extent 0 of each file id 
03b2			 
03b2				if DEBUG_STORESE 
03b2					DMARK "SGc" 
03b2 f5				push af  
03b3 3a c7 03			ld a, (.dmark)  
03b6 32 a6 fd			ld (debug_mark),a  
03b9 3a c8 03			ld a, (.dmark+1)  
03bc 32 a7 fd			ld (debug_mark+1),a  
03bf 3a c9 03			ld a, (.dmark+2)  
03c2 32 a8 fd			ld (debug_mark+2),a  
03c5 18 03			jr .pastdmark  
03c7 ..			.dmark: db "SGc"  
03ca f1			.pastdmark: pop af  
03cb			endm  
# End of macro DMARK
03cb					CALLMONITOR 
03cb cd aa fd			call debug_vector  
03ce				endm  
# End of macro CALLMONITOR
03ce				endif 
03ce 60			.getloop:	ld h, b 
03cf 2e 00				ld l, 0 
03d1 c5					push bc 
03d2			 
03d2 11 b5 f9				ld de, store_page 
03d5				if DEBUG_STORESE 
03d5					DMARK "SGr" 
03d5 f5				push af  
03d6 3a ea 03			ld a, (.dmark)  
03d9 32 a6 fd			ld (debug_mark),a  
03dc 3a eb 03			ld a, (.dmark+1)  
03df 32 a7 fd			ld (debug_mark+1),a  
03e2 3a ec 03			ld a, (.dmark+2)  
03e5 32 a8 fd			ld (debug_mark+2),a  
03e8 18 03			jr .pastdmark  
03ea ..			.dmark: db "SGr"  
03ed f1			.pastdmark: pop af  
03ee			endm  
# End of macro DMARK
03ee					CALLMONITOR 
03ee cd aa fd			call debug_vector  
03f1				endm  
# End of macro CALLMONITOR
03f1				endif 
03f1 cd be 09				call storage_read 
03f4 cd f8 0f				call ishlzero 
03f7 28 2d				jr z, .gap 
03f9					 
03f9					; have a file name read. Is it one we want. 
03f9			 
03f9 2a ae f9				ld hl, (store_tmp1) 
03fc 11 b8 f9				ld de, store_page+3   ; file name 
03ff			 
03ff				if DEBUG_STORESE 
03ff					DMARK "SGc" 
03ff f5				push af  
0400 3a 14 04			ld a, (.dmark)  
0403 32 a6 fd			ld (debug_mark),a  
0406 3a 15 04			ld a, (.dmark+1)  
0409 32 a7 fd			ld (debug_mark+1),a  
040c 3a 16 04			ld a, (.dmark+2)  
040f 32 a8 fd			ld (debug_mark+2),a  
0412 18 03			jr .pastdmark  
0414 ..			.dmark: db "SGc"  
0417 f1			.pastdmark: pop af  
0418			endm  
# End of macro DMARK
0418					CALLMONITOR 
0418 cd aa fd			call debug_vector  
041b				endm  
# End of macro CALLMONITOR
041b				endif 
041b cd 65 14				call strcmp 
041e 20 06				jr nz, .gap   ; not this one 
0420			 
0420 c1				        pop bc 
0421			 
0421 26 00				ld h, 0 
0423 68					ld l, b 
0424 18 22				jr .getdone 
0426						 
0426			 
0426			 
0426			 
0426			.gap: 
0426				if DEBUG_STORESE 
0426					DMARK "SGg" 
0426 f5				push af  
0427 3a 3b 04			ld a, (.dmark)  
042a 32 a6 fd			ld (debug_mark),a  
042d 3a 3c 04			ld a, (.dmark+1)  
0430 32 a7 fd			ld (debug_mark+1),a  
0433 3a 3d 04			ld a, (.dmark+2)  
0436 32 a8 fd			ld (debug_mark+2),a  
0439 18 03			jr .pastdmark  
043b ..			.dmark: db "SGg"  
043e f1			.pastdmark: pop af  
043f			endm  
# End of macro DMARK
043f					CALLMONITOR 
043f cd aa fd			call debug_vector  
0442				endm  
# End of macro CALLMONITOR
0442				endif 
0442			 
0442 c1					pop bc 
0443 10 89				djnz .getloop 
0445 21 ff 00				ld hl, 255 
0448			.getdone: 
0448			 
0448				if DEBUG_STORESE 
0448					DMARK "SGe" 
0448 f5				push af  
0449 3a 5d 04			ld a, (.dmark)  
044c 32 a6 fd			ld (debug_mark),a  
044f 3a 5e 04			ld a, (.dmark+1)  
0452 32 a7 fd			ld (debug_mark+1),a  
0455 3a 5f 04			ld a, (.dmark+2)  
0458 32 a8 fd			ld (debug_mark+2),a  
045b 18 03			jr .pastdmark  
045d ..			.dmark: db "SGe"  
0460 f1			.pastdmark: pop af  
0461			endm  
# End of macro DMARK
0461					CALLMONITOR 
0461 cd aa fd			call debug_vector  
0464				endm  
# End of macro CALLMONITOR
0464				endif 
0464			 
0464 c9				ret 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			; Read Block 
0465			; ---------- 
0465			; 
0465			; With current bank 
0465			;  
0465			; Get block number to read 
0465			; Load physical blocks starting at start block into buffer 
0465			 
0465			; de points to buffer to use 
0465			; hl holds logical block number  
0465			 
0465			storage_read_block: 
0465			 
0465				; TODO bank selection 
0465			 
0465				; for each of the physical blocks read it into the buffer 
0465 06 40			ld b, STORE_BLOCK_PHY 
0467			 
0467				if DEBUG_STORESE 
0467 d5					push de 
0468				endif 
0468				 
0468			.rl1:    
0468			 
0468				; read physical block at hl into de 
0468			        ; increment hl and de to next read position on exit 
0468			 
0468 e5				push hl 
0469 d5				push de	 
046a c5				push bc 
046b			;	if DEBUG_STORESE 
046b			;		push af 
046b			;		ld a, 'R' 
046b			;		ld (debug_mark),a 
046b			;		pop af 
046b			;		CALLMONITOR 
046b			;	endif 
046b cd 0c 03			call se_readbyte 
046e			;	if DEBUG_STORESE 
046e			;		ld a,(spi_portbyte) 
046e			;		ld l, a 
046e			;		push af 
046e			;		ld a, '1' 
046e			;		ld (debug_mark),a 
046e			;		pop af 
046e			;		CALLMONITOR 
046e			;	endif 
046e c1				pop bc 
046f d1				pop de 
0470 e1				pop hl 
0471 12				ld (de),a 
0472 23				inc hl 
0473 13				inc de 
0474			 
0474			;	if DEBUG_STORESE 
0474			;		push af 
0474			;		ld a, 'r' 
0474			;		ld (debug_mark),a 
0474			;		pop af 
0474			;		CALLMONITOR 
0474			;	endif 
0474			 
0474 10 f2			djnz .rl1 
0476			 
0476				if DEBUG_STORESE 
0476					DMARK "SRB" 
0476 f5				push af  
0477 3a 8b 04			ld a, (.dmark)  
047a 32 a6 fd			ld (debug_mark),a  
047d 3a 8c 04			ld a, (.dmark+1)  
0480 32 a7 fd			ld (debug_mark+1),a  
0483 3a 8d 04			ld a, (.dmark+2)  
0486 32 a8 fd			ld (debug_mark+2),a  
0489 18 03			jr .pastdmark  
048b ..			.dmark: db "SRB"  
048e f1			.pastdmark: pop af  
048f			endm  
# End of macro DMARK
048f d1					pop de 
0490			; 
0490			;		push af 
0490			;		ld a, 'R' 
0490			;		ld (debug_mark),a 
0490			;		pop af 
0490					CALLMONITOR 
0490 cd aa fd			call debug_vector  
0493				endm  
# End of macro CALLMONITOR
0493				endif 
0493 c9				ret	 
0494				 
0494			 
0494			; File Size 
0494			; --------- 
0494			; 
0494			;   hl file id 
0494			; 
0494			;  returns in hl the number of blocks 
0494			 
0494			storage_file_size: 
0494 5d				ld e, l 
0495 16 00			ld d, 0 
0497 21 40 00			ld hl, STORE_BLOCK_PHY 
049a					if DEBUG_FORTH_WORDS 
049a						DMARK "SIZ" 
049a f5				push af  
049b 3a af 04			ld a, (.dmark)  
049e 32 a6 fd			ld (debug_mark),a  
04a1 3a b0 04			ld a, (.dmark+1)  
04a4 32 a7 fd			ld (debug_mark+1),a  
04a7 3a b1 04			ld a, (.dmark+2)  
04aa 32 a8 fd			ld (debug_mark+2),a  
04ad 18 03			jr .pastdmark  
04af ..			.dmark: db "SIZ"  
04b2 f1			.pastdmark: pop af  
04b3			endm  
# End of macro DMARK
04b3						CALLMONITOR 
04b3 cd aa fd			call debug_vector  
04b6				endm  
# End of macro CALLMONITOR
04b6					endif 
04b6 cd 98 07			call storage_findnextid 
04b9			 
04b9 cd f8 0f			call ishlzero 
04bc			;	ld a, l 
04bc			;	add h 
04bc			;	cp 0 
04bc c8				ret z			; block not found so EOF 
04bd			 
04bd 11 b5 f9			ld de, store_page 
04c0 cd 65 04			call storage_read_block 
04c3			 
04c3 3a b7 f9			ld a, (store_page+2)	 ; get extent count 
04c6 6f				ld l, a 
04c7 26 00			ld h, 0 
04c9 c9			 	ret 
04ca			 
04ca			 
04ca			; Write Block 
04ca			; ----------- 
04ca			; 
04ca			; With current bank 
04ca			;  
04ca			; Get block number to write 
04ca			; Write physical blocks starting at start block from buffer 
04ca			  
04ca			storage_write_block: 
04ca				; TODO bank selection 
04ca			 
04ca				; for each of the physical blocks read it into the buffer 
04ca 06 40			ld b, STORE_BLOCK_PHY 
04cc			 
04cc				if DEBUG_STORESE 
04cc					DMARK "SWB" 
04cc f5				push af  
04cd 3a e1 04			ld a, (.dmark)  
04d0 32 a6 fd			ld (debug_mark),a  
04d3 3a e2 04			ld a, (.dmark+1)  
04d6 32 a7 fd			ld (debug_mark+1),a  
04d9 3a e3 04			ld a, (.dmark+2)  
04dc 32 a8 fd			ld (debug_mark+2),a  
04df 18 03			jr .pastdmark  
04e1 ..			.dmark: db "SWB"  
04e4 f1			.pastdmark: pop af  
04e5			endm  
# End of macro DMARK
04e5			 
04e5					;push af 
04e5					;ld a, 'W' 
04e5					;ld (debug_mark),a 
04e5					;pop af 
04e5					CALLMONITOR 
04e5 cd aa fd			call debug_vector  
04e8				endm  
# End of macro CALLMONITOR
04e8				endif 
04e8			 
04e8			; might not be working 
04e8			;	call se_writepage 
04e8			 
04e8			;	ret 
04e8			; 
04e8			 
04e8			 
04e8			 
04e8			.wl1:    
04e8			 
04e8				; read physical block at hl into de 
04e8			        ; increment hl and de to next read position on exit 
04e8			 
04e8 e5				push hl 
04e9 d5				push de	 
04ea c5				push bc 
04eb 1a				ld a,(de) 
04ec				;if DEBUG_STORESE 
04ec			;		push af 
04ec			;		ld a, 'W' 
04ec			;		ld (debug_mark),a 
04ec			;		pop af 
04ec			;		CALLMONITOR 
04ec			;	endif 
04ec cd 6a 02			call se_writebyte 
04ef			;	call delay250ms 
04ef 00				nop 
04f0 00				nop 
04f1 00				nop 
04f2			;	if DEBUG_STORESE 
04f2			;		push af 
04f2			;		ld a, 'w' 
04f2			;		ld (debug_mark),a 
04f2			;		pop af 
04f2			;		CALLMONITOR 
04f2			;	endif 
04f2 c1				pop bc 
04f3 d1				pop de 
04f4 e1				pop hl 
04f5 23				inc hl 
04f6 13				inc de 
04f7			 
04f7			 
04f7 10 ef			djnz .wl1 
04f9			 
04f9				if DEBUG_STORESE 
04f9					DMARK "SW2" 
04f9 f5				push af  
04fa 3a 0e 05			ld a, (.dmark)  
04fd 32 a6 fd			ld (debug_mark),a  
0500 3a 0f 05			ld a, (.dmark+1)  
0503 32 a7 fd			ld (debug_mark+1),a  
0506 3a 10 05			ld a, (.dmark+2)  
0509 32 a8 fd			ld (debug_mark+2),a  
050c 18 03			jr .pastdmark  
050e ..			.dmark: db "SW2"  
0511 f1			.pastdmark: pop af  
0512			endm  
# End of macro DMARK
0512			 
0512					;push af 
0512					;ld a, 'W' 
0512					;ld (debug_mark),a 
0512					;pop af 
0512					CALLMONITOR 
0512 cd aa fd			call debug_vector  
0515				endm  
# End of macro CALLMONITOR
0515				endif 
0515 c9				ret	 
0516			 
0516			; Init bank 
0516			; --------- 
0516			; 
0516			; With current bank 
0516			; 
0516			; Setup block 0 config 
0516			;     Set 0 file id counter 
0516			;     Set formatted byte pattern 
0516			;     Zero out bank label 
0516			;      
0516			; For every logical block write 0-1 byte as null 
0516			 
0516			storage_get_block_0: 
0516			 
0516				; TODO check presence 
0516			 
0516				; get block 0 config 
0516			 
0516 21 00 00			ld hl, 0 
0519 11 b5 f9			ld de, store_page 
051c cd 65 04			call storage_read_block 
051f			 
051f				if DEBUG_STORESE 
051f					DMARK "SB0" 
051f f5				push af  
0520 3a 34 05			ld a, (.dmark)  
0523 32 a6 fd			ld (debug_mark),a  
0526 3a 35 05			ld a, (.dmark+1)  
0529 32 a7 fd			ld (debug_mark+1),a  
052c 3a 36 05			ld a, (.dmark+2)  
052f 32 a8 fd			ld (debug_mark+2),a  
0532 18 03			jr .pastdmark  
0534 ..			.dmark: db "SB0"  
0537 f1			.pastdmark: pop af  
0538			endm  
# End of macro DMARK
0538 11 b5 f9				ld de, store_page 
053b			;		push af 
053b			;		ld a, 'i' 
053b			;		ld (debug_mark),a 
053b			;		pop af 
053b					CALLMONITOR 
053b cd aa fd			call debug_vector  
053e				endm  
# End of macro CALLMONITOR
053e				endif 
053e			 
053e				; is this area formatted? 
053e			 
053e			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
053e 2a b6 f9			ld hl, (store_page+1) 
0541 3e 80			ld a,0x80 
0543 bd				cp l 
0544 20 22			jr nz, .ininotformatted 
0546				; do a double check 
0546 3e 27			ld a, 0x27 
0548 bc				cp h 
0549 20 1d			jr nz, .ininotformatted 
054b			 
054b				; formatted then 
054b			 
054b				if DEBUG_STORESE 
054b					DMARK "SB1" 
054b f5				push af  
054c 3a 60 05			ld a, (.dmark)  
054f 32 a6 fd			ld (debug_mark),a  
0552 3a 61 05			ld a, (.dmark+1)  
0555 32 a7 fd			ld (debug_mark+1),a  
0558 3a 62 05			ld a, (.dmark+2)  
055b 32 a8 fd			ld (debug_mark+2),a  
055e 18 03			jr .pastdmark  
0560 ..			.dmark: db "SB1"  
0563 f1			.pastdmark: pop af  
0564			endm  
# End of macro DMARK
0564					;push af 
0564					;ld a, 'I' 
0564					;ld (debug_mark),a 
0564					;pop af 
0564					CALLMONITOR 
0564 cd aa fd			call debug_vector  
0567				endm  
# End of macro CALLMONITOR
0567				endif 
0567 c9				ret 
0568			 
0568			.ininotformatted: 
0568				; bank not formatted so poke various bits to make sure 
0568			 
0568				if DEBUG_STORESE 
0568					DMARK "SB2" 
0568 f5				push af  
0569 3a 7d 05			ld a, (.dmark)  
056c 32 a6 fd			ld (debug_mark),a  
056f 3a 7e 05			ld a, (.dmark+1)  
0572 32 a7 fd			ld (debug_mark+1),a  
0575 3a 7f 05			ld a, (.dmark+2)  
0578 32 a8 fd			ld (debug_mark+2),a  
057b 18 03			jr .pastdmark  
057d ..			.dmark: db "SB2"  
0580 f1			.pastdmark: pop af  
0581			endm  
# End of macro DMARK
0581					;push af 
0581					;ld a, 'f' 
0581					;ld (debug_mark),a 
0581					;pop af 
0581					CALLMONITOR 
0581 cd aa fd			call debug_vector  
0584				endm  
# End of macro CALLMONITOR
0584				endif 
0584			 
0584 cd a1 0c			call storage_clear_page 
0587			 
0587 21 b5 f9			ld hl, store_page 
058a 3e 00			ld a, 0 
058c				 
058c 77				ld (hl),a   ; reset file counter 
058d			 
058d 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0590 22 b6 f9		 	ld (store_page+1), hl	 
0593			 
0593				; set default label 
0593			 
0593 21 2f 06			ld hl, .defaultbanklabl 
0596 11 b8 f9		 	ld de, store_page+3 
0599 01 0f 00			ld bc, 15 
059c ed b0			ldir 
059e			 
059e				; Append the current bank id 
059e 21 c1 f9			ld hl, store_page+3+9 
05a1 3a 9a f9			ld a, (spi_device_id) 
05a4 77				ld (hl), a 
05a5			 
05a5				; save default page 0 
05a5			 
05a5 21 00 00			ld hl, 0 
05a8 11 b5 f9			ld de, store_page 
05ab				if DEBUG_STORESE 
05ab					DMARK "SB3" 
05ab f5				push af  
05ac 3a c0 05			ld a, (.dmark)  
05af 32 a6 fd			ld (debug_mark),a  
05b2 3a c1 05			ld a, (.dmark+1)  
05b5 32 a7 fd			ld (debug_mark+1),a  
05b8 3a c2 05			ld a, (.dmark+2)  
05bb 32 a8 fd			ld (debug_mark+2),a  
05be 18 03			jr .pastdmark  
05c0 ..			.dmark: db "SB3"  
05c3 f1			.pastdmark: pop af  
05c4			endm  
# End of macro DMARK
05c4			;		push af 
05c4			;		ld a, 'F' 
05c4			;		ld (debug_mark),a 
05c4			;		pop af 
05c4					CALLMONITOR 
05c4 cd aa fd			call debug_vector  
05c7				endm  
# End of macro CALLMONITOR
05c7				endif 
05c7 cd ca 04			call storage_write_block 
05ca				if DEBUG_STORESE 
05ca					DMARK "SB4" 
05ca f5				push af  
05cb 3a df 05			ld a, (.dmark)  
05ce 32 a6 fd			ld (debug_mark),a  
05d1 3a e0 05			ld a, (.dmark+1)  
05d4 32 a7 fd			ld (debug_mark+1),a  
05d7 3a e1 05			ld a, (.dmark+2)  
05da 32 a8 fd			ld (debug_mark+2),a  
05dd 18 03			jr .pastdmark  
05df ..			.dmark: db "SB4"  
05e2 f1			.pastdmark: pop af  
05e3			endm  
# End of macro DMARK
05e3			;		push af 
05e3			;		ld a, '>' 
05e3			;		ld (debug_mark),a 
05e3			;		pop af 
05e3					CALLMONITOR 
05e3 cd aa fd			call debug_vector  
05e6				endm  
# End of macro CALLMONITOR
05e6				endif 
05e6			 
05e6 00				nop 
05e7 00				nop 
05e8 00				nop 
05e9			 
05e9				; now set 0 in every page to mark as a free block 
05e9			 
05e9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05eb 21 40 00			ld hl, STORE_BLOCK_PHY 
05ee			 
05ee 3e 00		.setmark1:   	ld a,0 
05f0 e5					push hl 
05f1 c5					push bc 
05f2 cd 6a 02				call se_writebyte 
05f5 3e 0a			ld a, 10 
05f7 cd c3 0c			call aDelayInMS 
05fa 23				inc hl 
05fb cd 6a 02				call se_writebyte 
05fe 3e 0a			ld a, 10 
0600 cd c3 0c			call aDelayInMS 
0603 2b				dec hl 
0604 c1					pop bc 
0605 e1					pop hl 
0606 3e 40				ld a, STORE_BLOCK_PHY 
0608 cd cf 0f				call addatohl 
060b 10 e1				djnz .setmark1 
060d			 
060d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
060f 3e 00		.setmark2:   	ld a,0 
0611 e5					push hl 
0612 c5					push bc 
0613 cd 6a 02				call se_writebyte 
0616 3e 0a			ld a, 10 
0618 cd c3 0c			call aDelayInMS 
061b 23				inc hl 
061c cd 6a 02				call se_writebyte 
061f 3e 0a			ld a, 10 
0621 cd c3 0c			call aDelayInMS 
0624 2b				dec hl 
0625 c1					pop bc 
0626 e1					pop hl 
0627 3e 40				ld a, STORE_BLOCK_PHY 
0629 cd cf 0f				call addatohl 
062c 10 e1				djnz .setmark2 
062e			 
062e					 
062e			 
062e			 
062e c9				ret 
062f			 
062f			 
062f			 
062f			 
062f .. 00		.defaultbanklabl:   db "BankLabel_",0 
063a			 
063a			 
063a			 
063a			; Label Bank 
063a			; ---------- 
063a			; 
063a			; With current bank 
063a			; Read block 0 
063a			; Set label 
063a			; Write block 0 
063a			 
063a			; label str pointer in hl 
063a			 
063a			storage_label:     
063a			 
063a				if DEBUG_STORESE 
063a					DMARK "LBL" 
063a f5				push af  
063b 3a 4f 06			ld a, (.dmark)  
063e 32 a6 fd			ld (debug_mark),a  
0641 3a 50 06			ld a, (.dmark+1)  
0644 32 a7 fd			ld (debug_mark+1),a  
0647 3a 51 06			ld a, (.dmark+2)  
064a 32 a8 fd			ld (debug_mark+2),a  
064d 18 03			jr .pastdmark  
064f ..			.dmark: db "LBL"  
0652 f1			.pastdmark: pop af  
0653			endm  
# End of macro DMARK
0653					CALLMONITOR 
0653 cd aa fd			call debug_vector  
0656				endm  
# End of macro CALLMONITOR
0656				endif 
0656			 
0656 e5				push hl 
0657			 
0657 cd 16 05			call storage_get_block_0 
065a			 
065a				; set default label 
065a			 
065a e1				pop hl 
065b			 
065b 11 b8 f9		 	ld de, store_page+3 
065e 01 0f 00			ld bc, 15 
0661				if DEBUG_STORESE 
0661					DMARK "LB3" 
0661 f5				push af  
0662 3a 76 06			ld a, (.dmark)  
0665 32 a6 fd			ld (debug_mark),a  
0668 3a 77 06			ld a, (.dmark+1)  
066b 32 a7 fd			ld (debug_mark+1),a  
066e 3a 78 06			ld a, (.dmark+2)  
0671 32 a8 fd			ld (debug_mark+2),a  
0674 18 03			jr .pastdmark  
0676 ..			.dmark: db "LB3"  
0679 f1			.pastdmark: pop af  
067a			endm  
# End of macro DMARK
067a					CALLMONITOR 
067a cd aa fd			call debug_vector  
067d				endm  
# End of macro CALLMONITOR
067d				endif 
067d ed b0			ldir 
067f				; save default page 0 
067f			 
067f 21 00 00			ld hl, 0 
0682 11 b5 f9			ld de, store_page 
0685				if DEBUG_STORESE 
0685					DMARK "LBW" 
0685 f5				push af  
0686 3a 9a 06			ld a, (.dmark)  
0689 32 a6 fd			ld (debug_mark),a  
068c 3a 9b 06			ld a, (.dmark+1)  
068f 32 a7 fd			ld (debug_mark+1),a  
0692 3a 9c 06			ld a, (.dmark+2)  
0695 32 a8 fd			ld (debug_mark+2),a  
0698 18 03			jr .pastdmark  
069a ..			.dmark: db "LBW"  
069d f1			.pastdmark: pop af  
069e			endm  
# End of macro DMARK
069e					CALLMONITOR 
069e cd aa fd			call debug_vector  
06a1				endm  
# End of macro CALLMONITOR
06a1				endif 
06a1 cd ca 04			call storage_write_block 
06a4			 
06a4 c9				ret 
06a5			 
06a5			 
06a5			 
06a5			; Read Block 0 - Config 
06a5			; --------------------- 
06a5			; 
06a5			; With current bank 
06a5			; Call presence test 
06a5			;    If not present format/init bank  
06a5			; Read block 0  
06a5			;  
06a5			 
06a5			 
06a5			; Dir 
06a5			; --- 
06a5			; 
06a5			; With current bank 
06a5			; Load Block 0 Config 
06a5			; Get max file id number 
06a5			; For each logical block 
06a5			;    Read block read byte 2 
06a5			;      if first block of file 
06a5			;         Display file name 
06a5			;         Display type flags for file 
06a5			;        
06a5			 
06a5			; moving to words as this requires stack control 
06a5			 
06a5			 
06a5			; Delete File 
06a5			; ----------- 
06a5			; 
06a5			; With current bank 
06a5			; 
06a5			; Load Block 0 Config 
06a5			; Get max file id number 
06a5			; For each logical block 
06a5			;    Read block file id 
06a5			;      If first block of file and dont have file id 
06a5			;         if file to delete 
06a5			;         Save file id 
06a5			;         Null file id 
06a5			;         Write this block back 
06a5			;      If file id is one saved 
06a5			;         Null file id 
06a5			;         Write this block back 
06a5			 
06a5			 
06a5			.se_done: 
06a5 e1				pop hl 
06a6 c9				ret 
06a7			 
06a7			storage_erase: 
06a7			 
06a7				; hl contains the file id 
06a7			 
06a7 5d				ld e, l 
06a8 16 00			ld d, 0 
06aa 21 40 00			ld hl, STORE_BLOCK_PHY 
06ad					if DEBUG_FORTH_WORDS 
06ad						DMARK "ERA" 
06ad f5				push af  
06ae 3a c2 06			ld a, (.dmark)  
06b1 32 a6 fd			ld (debug_mark),a  
06b4 3a c3 06			ld a, (.dmark+1)  
06b7 32 a7 fd			ld (debug_mark+1),a  
06ba 3a c4 06			ld a, (.dmark+2)  
06bd 32 a8 fd			ld (debug_mark+2),a  
06c0 18 03			jr .pastdmark  
06c2 ..			.dmark: db "ERA"  
06c5 f1			.pastdmark: pop af  
06c6			endm  
# End of macro DMARK
06c6						CALLMONITOR 
06c6 cd aa fd			call debug_vector  
06c9				endm  
# End of macro CALLMONITOR
06c9					endif 
06c9 cd 98 07			call storage_findnextid 
06cc cd f8 0f			call ishlzero 
06cf c8				ret z 
06d0			 
06d0 e5				push hl 
06d1			 
06d1				; TODO check file not found 
06d1			 
06d1 11 b5 f9			ld de, store_page 
06d4 cd 65 04			call storage_read_block 
06d7			 
06d7 cd f8 0f			call ishlzero 
06da ca a5 06			jp z,.se_done 
06dd			 
06dd					if DEBUG_FORTH_WORDS 
06dd						DMARK "ER1" 
06dd f5				push af  
06de 3a f2 06			ld a, (.dmark)  
06e1 32 a6 fd			ld (debug_mark),a  
06e4 3a f3 06			ld a, (.dmark+1)  
06e7 32 a7 fd			ld (debug_mark+1),a  
06ea 3a f4 06			ld a, (.dmark+2)  
06ed 32 a8 fd			ld (debug_mark+2),a  
06f0 18 03			jr .pastdmark  
06f2 ..			.dmark: db "ER1"  
06f5 f1			.pastdmark: pop af  
06f6			endm  
# End of macro DMARK
06f6						CALLMONITOR 
06f6 cd aa fd			call debug_vector  
06f9				endm  
# End of macro CALLMONITOR
06f9					endif 
06f9 3a b5 f9			ld a, (store_page)	; get file id 
06fc 32 a9 f9			ld (store_tmpid), a 
06ff			 
06ff 3a b7 f9			ld a, (store_page+2)    ; get count of extends 
0702 32 a8 f9			ld (store_tmpext), a 
0705			 
0705				; wipe file header 
0705			 
0705 e1				pop hl 
0706 3e 00			ld a, 0 
0708 32 b5 f9			ld (store_page), a 
070b 32 b6 f9			ld (store_page+1),a 
070e 11 b5 f9			ld de, store_page 
0711					if DEBUG_FORTH_WORDS 
0711						DMARK "ER2" 
0711 f5				push af  
0712 3a 26 07			ld a, (.dmark)  
0715 32 a6 fd			ld (debug_mark),a  
0718 3a 27 07			ld a, (.dmark+1)  
071b 32 a7 fd			ld (debug_mark+1),a  
071e 3a 28 07			ld a, (.dmark+2)  
0721 32 a8 fd			ld (debug_mark+2),a  
0724 18 03			jr .pastdmark  
0726 ..			.dmark: db "ER2"  
0729 f1			.pastdmark: pop af  
072a			endm  
# End of macro DMARK
072a						CALLMONITOR 
072a cd aa fd			call debug_vector  
072d				endm  
# End of macro CALLMONITOR
072d					endif 
072d cd ca 04			call storage_write_block 
0730			 
0730			 
0730				; wipe file extents 
0730			 
0730 3a a8 f9			ld a, (store_tmpext) 
0733 47				ld b, a 
0734			 
0734			.eraext:	  
0734 c5				push bc 
0735			 
0735 21 40 00			ld hl, STORE_BLOCK_PHY 
0738 3a a9 f9			ld a,(store_tmpid) 
073b 5f				ld e, a 
073c 50				ld d, b	 
073d					if DEBUG_FORTH_WORDS 
073d						DMARK "ER3" 
073d f5				push af  
073e 3a 52 07			ld a, (.dmark)  
0741 32 a6 fd			ld (debug_mark),a  
0744 3a 53 07			ld a, (.dmark+1)  
0747 32 a7 fd			ld (debug_mark+1),a  
074a 3a 54 07			ld a, (.dmark+2)  
074d 32 a8 fd			ld (debug_mark+2),a  
0750 18 03			jr .pastdmark  
0752 ..			.dmark: db "ER3"  
0755 f1			.pastdmark: pop af  
0756			endm  
# End of macro DMARK
0756						CALLMONITOR 
0756 cd aa fd			call debug_vector  
0759				endm  
# End of macro CALLMONITOR
0759					endif 
0759 cd 98 07			call storage_findnextid 
075c cd f8 0f			call ishlzero 
075f ca a5 06			jp z,.se_done 
0762			 
0762 e5				push hl 
0763 11 b5 f9			ld de, store_page 
0766 cd 65 04			call storage_read_block 
0769			 
0769				; free block	 
0769			 
0769 3e 00			ld a, 0 
076b 32 b5 f9			ld (store_page), a 
076e 32 b6 f9			ld (store_page+1),a 
0771 11 b5 f9			ld de, store_page 
0774 e1				pop hl 
0775					if DEBUG_FORTH_WORDS 
0775						DMARK "ER4" 
0775 f5				push af  
0776 3a 8a 07			ld a, (.dmark)  
0779 32 a6 fd			ld (debug_mark),a  
077c 3a 8b 07			ld a, (.dmark+1)  
077f 32 a7 fd			ld (debug_mark+1),a  
0782 3a 8c 07			ld a, (.dmark+2)  
0785 32 a8 fd			ld (debug_mark+2),a  
0788 18 03			jr .pastdmark  
078a ..			.dmark: db "ER4"  
078d f1			.pastdmark: pop af  
078e			endm  
# End of macro DMARK
078e						CALLMONITOR 
078e cd aa fd			call debug_vector  
0791				endm  
# End of macro CALLMONITOR
0791					endif 
0791 cd ca 04			call storage_write_block 
0794			 
0794 c1				pop bc 
0795 10 9d			djnz .eraext 
0797			 
0797 c9				ret 
0798			 
0798			 
0798			; Find Free Block 
0798			; --------------- 
0798			; 
0798			; With current bank 
0798			;  
0798			; From given starting logical block 
0798			;    Read block  
0798			;    If no file id 
0798			;         Return block id 
0798			 
0798			 
0798			; hl starting page number 
0798			; hl contains free page number or zero if no pages free 
0798			; e contains the file id to locate 
0798			; d contains the block number 
0798			 
0798			; TODO change to find file id and use zero for free block 
0798			 
0798			storage_findnextid: 
0798			 
0798				; now locate first 0 page to mark as a free block 
0798			 
0798 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
079a			;	ld hl, STORE_BLOCK_PHY 
079a			 
079a					if DEBUG_FORTH_WORDS 
079a					DMARK "FNI" 
079a f5				push af  
079b 3a af 07			ld a, (.dmark)  
079e 32 a6 fd			ld (debug_mark),a  
07a1 3a b0 07			ld a, (.dmark+1)  
07a4 32 a7 fd			ld (debug_mark+1),a  
07a7 3a b1 07			ld a, (.dmark+2)  
07aa 32 a8 fd			ld (debug_mark+2),a  
07ad 18 03			jr .pastdmark  
07af ..			.dmark: db "FNI"  
07b2 f1			.pastdmark: pop af  
07b3			endm  
# End of macro DMARK
07b3						CALLMONITOR 
07b3 cd aa fd			call debug_vector  
07b6				endm  
# End of macro CALLMONITOR
07b6					endif 
07b6			.ff1:   	 
07b6 e5					push hl 
07b7 c5					push bc 
07b8 d5					push de 
07b9 cd 0c 03				call se_readbyte 
07bc 5f					ld e,a 
07bd 23					inc hl 
07be cd 0c 03				call se_readbyte 
07c1 57					ld d, a 
07c2 e1					pop hl 
07c3 e5					push hl 
07c4 cd ed 0f				call cmp16 
07c7 28 49				jr z, .fffound 
07c9			 
07c9 d1					pop de 
07ca c1					pop bc 
07cb e1					pop hl 
07cc			 
07cc					; is found? 
07cc					;cp e 
07cc					;ret z 
07cc			 
07cc 3e 40				ld a, STORE_BLOCK_PHY 
07ce cd cf 0f				call addatohl 
07d1 10 e3				djnz .ff1 
07d3			 
07d3 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07d5			.ff2:   	 
07d5			 
07d5 e5					push hl 
07d6 c5					push bc 
07d7 d5					push de 
07d8 cd 0c 03				call se_readbyte 
07db 5f					ld e,a 
07dc 23					inc hl 
07dd cd 0c 03				call se_readbyte 
07e0 57					ld d, a 
07e1			 
07e1 e1					pop hl 
07e2 e5					push hl 
07e3 cd ed 0f				call cmp16 
07e6 28 2a				jr z, .fffound 
07e8			 
07e8 d1					pop de 
07e9 c1					pop bc 
07ea e1					pop hl 
07eb					; is found? 
07eb					;cp e 
07eb					;ret z 
07eb			 
07eb 3e 40				ld a, STORE_BLOCK_PHY 
07ed cd cf 0f				call addatohl 
07f0 10 e3				djnz .ff2 
07f2			 
07f2			 
07f2					if DEBUG_FORTH_WORDS 
07f2					DMARK "FN-" 
07f2 f5				push af  
07f3 3a 07 08			ld a, (.dmark)  
07f6 32 a6 fd			ld (debug_mark),a  
07f9 3a 08 08			ld a, (.dmark+1)  
07fc 32 a7 fd			ld (debug_mark+1),a  
07ff 3a 09 08			ld a, (.dmark+2)  
0802 32 a8 fd			ld (debug_mark+2),a  
0805 18 03			jr .pastdmark  
0807 ..			.dmark: db "FN-"  
080a f1			.pastdmark: pop af  
080b			endm  
# End of macro DMARK
080b					;	push af 
080b					;	ld a, 'n' 
080b					;	ld (debug_mark),a 
080b					;	pop af 
080b						CALLMONITOR 
080b cd aa fd			call debug_vector  
080e				endm  
# End of macro CALLMONITOR
080e					endif 
080e				; no free marks! 
080e 21 00 00				ld hl, 0 
0811 c9				ret 
0812			.fffound: 
0812				 
0812			 
0812 d1					pop de 
0813 c1					pop bc 
0814 e1					pop hl 
0815					if DEBUG_FORTH_WORDS 
0815					DMARK "FNF" 
0815 f5				push af  
0816 3a 2a 08			ld a, (.dmark)  
0819 32 a6 fd			ld (debug_mark),a  
081c 3a 2b 08			ld a, (.dmark+1)  
081f 32 a7 fd			ld (debug_mark+1),a  
0822 3a 2c 08			ld a, (.dmark+2)  
0825 32 a8 fd			ld (debug_mark+2),a  
0828 18 03			jr .pastdmark  
082a ..			.dmark: db "FNF"  
082d f1			.pastdmark: pop af  
082e			endm  
# End of macro DMARK
082e					;	push af 
082e					;	ld a, 'n' 
082e					;	ld (debug_mark),a 
082e					;	pop af 
082e						CALLMONITOR 
082e cd aa fd			call debug_vector  
0831				endm  
# End of macro CALLMONITOR
0831					endif 
0831 c9				ret 
0832			 
0832			 
0832			 
0832			; Free Space 
0832			; ---------- 
0832			; 
0832			; With current bank 
0832			; 
0832			; Set block count to zero 
0832			; Starting with first logical block 
0832			;      Find free block  
0832			;      If block id given, increment block count 
0832			; 
0832			;  
0832			 
0832			 
0832			; hl contains count of free blocks 
0832			 
0832			storage_freeblocks: 
0832			 
0832				; now locate first 0 page to mark as a free block 
0832			 
0832 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0834 21 40 00			ld hl, STORE_BLOCK_PHY 
0837 11 00 00			ld de, 0 
083a			 
083a			.fb1:   	 
083a e5					push hl 
083b c5					push bc 
083c d5					push de 
083d cd 0c 03				call se_readbyte 
0840 d1					pop de 
0841 c1					pop bc 
0842 e1					pop hl 
0843			 
0843					; is free? 
0843 fe 00				cp 0 
0845 20 01				jr nz, .ff1cont 
0847 13					inc de 
0848			 
0848			.ff1cont: 
0848			 
0848			 
0848 3e 40				ld a, STORE_BLOCK_PHY 
084a cd cf 0f				call addatohl 
084d 10 eb				djnz .fb1 
084f			 
084f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0851			.fb2:   	 
0851 e5					push hl 
0852 c5					push bc 
0853 d5					push de 
0854 cd 0c 03				call se_readbyte 
0857 d1					pop de 
0858 c1					pop bc 
0859 e1					pop hl 
085a			 
085a					; is free? 
085a fe 00				cp 0 
085c 20 01				jr nz, .ff2cont 
085e 13					inc de 
085f			 
085f			.ff2cont: 
085f			 
085f 3e 40				ld a, STORE_BLOCK_PHY 
0861 cd cf 0f				call addatohl 
0864 10 eb				djnz .fb2 
0866			 
0866 eb				ex de, hl 
0867 c9				ret 
0868			 
0868			; Get File ID 
0868			; ----------- 
0868			; 
0868			; With current bank 
0868			;  
0868			; Load Block 0 Config 
0868			; Get max file id number 
0868			; For each logical block 
0868			;    Read block file id 
0868			;      If first block of file and dont have file id 
0868			;         if file get id and exit 
0868			 
0868			 
0868			 
0868			 
0868			; Create File 
0868			; ----------- 
0868			; 
0868			; With current bank  
0868			; Load Block 0 Config 
0868			; Get max file id number 
0868			; Increment file id number 
0868			; Save Config 
0868			; Find free block 
0868			; Set buffer with file name and file id 
0868			; Write buffer to free block  
0868			 
0868			 
0868			; hl point to file name 
0868			; hl returns file id 
0868			 
0868			; file format: 
0868			; byte 0 - file id 
0868			; byte 1 - extent number 
0868			; byte 2-> data 
0868			 
0868			; format for extent number 0: 
0868			; 
0868			; byte 0 - file id 
0868			; byte 1 - extent 0 
0868			; byte 2 - extent count 
0868			; byte 3 -> file name and meta data 
0868			 
0868			 
0868			storage_create: 
0868				if DEBUG_STORESE 
0868					DMARK "SCR" 
0868 f5				push af  
0869 3a 7d 08			ld a, (.dmark)  
086c 32 a6 fd			ld (debug_mark),a  
086f 3a 7e 08			ld a, (.dmark+1)  
0872 32 a7 fd			ld (debug_mark+1),a  
0875 3a 7f 08			ld a, (.dmark+2)  
0878 32 a8 fd			ld (debug_mark+2),a  
087b 18 03			jr .pastdmark  
087d ..			.dmark: db "SCR"  
0880 f1			.pastdmark: pop af  
0881			endm  
# End of macro DMARK
0881					CALLMONITOR 
0881 cd aa fd			call debug_vector  
0884				endm  
# End of macro CALLMONITOR
0884				endif 
0884			 
0884 e5				push hl		; save file name pointer 
0885			 
0885 cd 16 05			call storage_get_block_0 
0888			 
0888 3a b5 f9			ld a,(store_page)	; get current file id 
088b 3c				inc a 
088c 32 b5 f9			ld (store_page),a 
088f				 
088f 32 a9 f9			ld (store_tmpid),a			; save id 
0892			 
0892 21 00 00			ld hl, 0 
0895 11 b5 f9			ld de, store_page 
0898				if DEBUG_STORESE 
0898					DMARK "SCw" 
0898 f5				push af  
0899 3a ad 08			ld a, (.dmark)  
089c 32 a6 fd			ld (debug_mark),a  
089f 3a ae 08			ld a, (.dmark+1)  
08a2 32 a7 fd			ld (debug_mark+1),a  
08a5 3a af 08			ld a, (.dmark+2)  
08a8 32 a8 fd			ld (debug_mark+2),a  
08ab 18 03			jr .pastdmark  
08ad ..			.dmark: db "SCw"  
08b0 f1			.pastdmark: pop af  
08b1			endm  
# End of macro DMARK
08b1					CALLMONITOR 
08b1 cd aa fd			call debug_vector  
08b4				endm  
# End of macro CALLMONITOR
08b4				endif 
08b4 cd ca 04			call storage_write_block	 ; save update 
08b7			 
08b7				if DEBUG_STORESE 
08b7 11 b5 f9				ld de, store_page 
08ba					DMARK "SCC" 
08ba f5				push af  
08bb 3a cf 08			ld a, (.dmark)  
08be 32 a6 fd			ld (debug_mark),a  
08c1 3a d0 08			ld a, (.dmark+1)  
08c4 32 a7 fd			ld (debug_mark+1),a  
08c7 3a d1 08			ld a, (.dmark+2)  
08ca 32 a8 fd			ld (debug_mark+2),a  
08cd 18 03			jr .pastdmark  
08cf ..			.dmark: db "SCC"  
08d2 f1			.pastdmark: pop af  
08d3			endm  
# End of macro DMARK
08d3					CALLMONITOR 
08d3 cd aa fd			call debug_vector  
08d6				endm  
# End of macro CALLMONITOR
08d6				endif 
08d6				;  
08d6				 
08d6 21 40 00			ld hl, STORE_BLOCK_PHY 
08d9 11 00 00			ld de, 0 
08dc cd 98 07			call storage_findnextid 
08df			 
08df 22 a0 f9			ld (store_tmppageid), hl    ; save page to use  
08e2			 
08e2				; TODO detect 0 = no spare blocks 
08e2			 
08e2				; hl now contains the free page to use for the file header page 
08e2			 
08e2				if DEBUG_STORESE 
08e2				DMARK "SCF" 
08e2 f5				push af  
08e3 3a f7 08			ld a, (.dmark)  
08e6 32 a6 fd			ld (debug_mark),a  
08e9 3a f8 08			ld a, (.dmark+1)  
08ec 32 a7 fd			ld (debug_mark+1),a  
08ef 3a f9 08			ld a, (.dmark+2)  
08f2 32 a8 fd			ld (debug_mark+2),a  
08f5 18 03			jr .pastdmark  
08f7 ..			.dmark: db "SCF"  
08fa f1			.pastdmark: pop af  
08fb			endm  
# End of macro DMARK
08fb					CALLMONITOR 
08fb cd aa fd			call debug_vector  
08fe				endm  
# End of macro CALLMONITOR
08fe				endif 
08fe			 
08fe 22 a0 f9			ld (store_tmppageid), hl 
0901				 
0901 3a a9 f9			ld a,(store_tmpid)    ; get file id 
0904			;	ld a, (store_filecache)			; save to cache 
0904			 
0904 32 b5 f9			ld (store_page),a    ; set page id 
0907 3e 00			ld a, 0			 ; extent 0 is file header 
0909 32 b6 f9			ld (store_page+1), a   ; set file extent 
090c			 
090c 32 b7 f9			ld (store_page+2), a   ; extent count for the file 
090f			 
090f			;	inc hl 		; init block 0 of file 
090f			;	inc hl   		; skip file and extent id 
090f			 ;       ld a, 0 
090f			;	ld (hl),a 
090f			;	ld a, (store_filecache+1)  	; save to cache 
090f			 
090f			;	inc hl    ; file name 
090f				 
090f				 
090f 11 b8 f9			ld de, store_page+3    ; get buffer for term string to use as file name 
0912				if DEBUG_STORESE 
0912					DMARK "SCc" 
0912 f5				push af  
0913 3a 27 09			ld a, (.dmark)  
0916 32 a6 fd			ld (debug_mark),a  
0919 3a 28 09			ld a, (.dmark+1)  
091c 32 a7 fd			ld (debug_mark+1),a  
091f 3a 29 09			ld a, (.dmark+2)  
0922 32 a8 fd			ld (debug_mark+2),a  
0925 18 03			jr .pastdmark  
0927 ..			.dmark: db "SCc"  
092a f1			.pastdmark: pop af  
092b			endm  
# End of macro DMARK
092b					CALLMONITOR 
092b cd aa fd			call debug_vector  
092e				endm  
# End of macro CALLMONITOR
092e				endif 
092e e1				pop hl    ; get zero term string 
092f e5				push hl 
0930 3e 00			ld a, 0 
0932 cd 38 14			call strlent 
0935 23				inc hl   ; cover zero term 
0936 06 00			ld b,0 
0938 4d				ld c,l 
0939 e1				pop hl 
093a				;ex de, hl 
093a				if DEBUG_STORESE 
093a					DMARK "SCa" 
093a f5				push af  
093b 3a 4f 09			ld a, (.dmark)  
093e 32 a6 fd			ld (debug_mark),a  
0941 3a 50 09			ld a, (.dmark+1)  
0944 32 a7 fd			ld (debug_mark+1),a  
0947 3a 51 09			ld a, (.dmark+2)  
094a 32 a8 fd			ld (debug_mark+2),a  
094d 18 03			jr .pastdmark  
094f ..			.dmark: db "SCa"  
0952 f1			.pastdmark: pop af  
0953			endm  
# End of macro DMARK
0953					;push af 
0953					;ld a, 'a' 
0953					;ld (debug_mark),a 
0953					;pop af 
0953					CALLMONITOR 
0953 cd aa fd			call debug_vector  
0956				endm  
# End of macro CALLMONITOR
0956				endif 
0956 ed b0			ldir    ; copy zero term string 
0958				if DEBUG_STORESE 
0958					DMARK "SCA" 
0958 f5				push af  
0959 3a 6d 09			ld a, (.dmark)  
095c 32 a6 fd			ld (debug_mark),a  
095f 3a 6e 09			ld a, (.dmark+1)  
0962 32 a7 fd			ld (debug_mark+1),a  
0965 3a 6f 09			ld a, (.dmark+2)  
0968 32 a8 fd			ld (debug_mark+2),a  
096b 18 03			jr .pastdmark  
096d ..			.dmark: db "SCA"  
0970 f1			.pastdmark: pop af  
0971			endm  
# End of macro DMARK
0971					CALLMONITOR 
0971 cd aa fd			call debug_vector  
0974				endm  
# End of macro CALLMONITOR
0974				endif 
0974			 
0974				; write file header page 
0974			 
0974 2a a0 f9			ld hl,(store_tmppageid) 
0977 11 b5 f9			ld de, store_page 
097a				if DEBUG_STORESE 
097a					DMARK "SCb" 
097a f5				push af  
097b 3a 8f 09			ld a, (.dmark)  
097e 32 a6 fd			ld (debug_mark),a  
0981 3a 90 09			ld a, (.dmark+1)  
0984 32 a7 fd			ld (debug_mark+1),a  
0987 3a 91 09			ld a, (.dmark+2)  
098a 32 a8 fd			ld (debug_mark+2),a  
098d 18 03			jr .pastdmark  
098f ..			.dmark: db "SCb"  
0992 f1			.pastdmark: pop af  
0993			endm  
# End of macro DMARK
0993					;push af 
0993					;ld a, 'b' 
0993					;ld (debug_mark),a 
0993					;pop af 
0993					CALLMONITOR 
0993 cd aa fd			call debug_vector  
0996				endm  
# End of macro CALLMONITOR
0996				endif 
0996 cd ca 04			call storage_write_block 
0999			 
0999 3a a9 f9			ld a, (store_tmpid) 
099c 6f				ld l, a 
099d 26 00			ld h,0 
099f				if DEBUG_STORESE 
099f					DMARK "SCz" 
099f f5				push af  
09a0 3a b4 09			ld a, (.dmark)  
09a3 32 a6 fd			ld (debug_mark),a  
09a6 3a b5 09			ld a, (.dmark+1)  
09a9 32 a7 fd			ld (debug_mark+1),a  
09ac 3a b6 09			ld a, (.dmark+2)  
09af 32 a8 fd			ld (debug_mark+2),a  
09b2 18 03			jr .pastdmark  
09b4 ..			.dmark: db "SCz"  
09b7 f1			.pastdmark: pop af  
09b8			endm  
# End of macro DMARK
09b8					CALLMONITOR 
09b8 cd aa fd			call debug_vector  
09bb				endm  
# End of macro CALLMONITOR
09bb				endif 
09bb c9				ret 
09bc				 
09bc			 
09bc			 
09bc			; 
09bc			; Read File 
09bc			; 
09bc			; h - file id to locate 
09bc			; l - extent to locate 
09bc			; de - pointer to string to read into 
09bc			; 
09bc			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09bc			 
09bc			.sr_fail: 
09bc d1				pop de 
09bd c9				ret 
09be			 
09be			storage_read: 
09be			 
09be			 
09be d5				push de 
09bf			 
09bf			; TODO BUG the above push is it popped before the RET Z? 
09bf			 
09bf			; TODO how to handle multiple part blocks 
09bf			 
09bf				; locate file extent to read 
09bf			 
09bf 5c				ld e, h 
09c0 55				ld d, l 
09c1			 
09c1			.srext: 
09c1 22 b3 f9			ld (store_readptr), hl     ; save the current extent to load 
09c4 ed 53 b1 f9		ld (store_readbuf), de     ; save the current buffer to load in to 
09c8			 
09c8 21 40 00			ld hl, STORE_BLOCK_PHY 
09cb				if DEBUG_STORESE 
09cb					DMARK "sre" 
09cb f5				push af  
09cc 3a e0 09			ld a, (.dmark)  
09cf 32 a6 fd			ld (debug_mark),a  
09d2 3a e1 09			ld a, (.dmark+1)  
09d5 32 a7 fd			ld (debug_mark+1),a  
09d8 3a e2 09			ld a, (.dmark+2)  
09db 32 a8 fd			ld (debug_mark+2),a  
09de 18 03			jr .pastdmark  
09e0 ..			.dmark: db "sre"  
09e3 f1			.pastdmark: pop af  
09e4			endm  
# End of macro DMARK
09e4					CALLMONITOR 
09e4 cd aa fd			call debug_vector  
09e7				endm  
# End of macro CALLMONITOR
09e7				endif 
09e7 cd 98 07			call storage_findnextid 
09ea			 
09ea				if DEBUG_STORESE 
09ea					DMARK "srf" 
09ea f5				push af  
09eb 3a ff 09			ld a, (.dmark)  
09ee 32 a6 fd			ld (debug_mark),a  
09f1 3a 00 0a			ld a, (.dmark+1)  
09f4 32 a7 fd			ld (debug_mark+1),a  
09f7 3a 01 0a			ld a, (.dmark+2)  
09fa 32 a8 fd			ld (debug_mark+2),a  
09fd 18 03			jr .pastdmark  
09ff ..			.dmark: db "srf"  
0a02 f1			.pastdmark: pop af  
0a03			endm  
# End of macro DMARK
0a03					CALLMONITOR 
0a03 cd aa fd			call debug_vector  
0a06				endm  
# End of macro CALLMONITOR
0a06				endif 
0a06 cd f8 0f			call ishlzero 
0a09			;	ld a, l 
0a09			;	add h 
0a09			;	cp 0 
0a09 28 b1			jr z,.sr_fail			; block not found so EOF 
0a0b			 
0a0b				; save current address for use by higher level words etc 
0a0b			 
0a0b 22 a6 f9			ld (store_openaddr),hl 
0a0e			 
0a0e			 
0a0e				; hl contains page number to load 
0a0e d1				pop de   ; get storage 
0a0f ed 53 b1 f9		ld (store_readbuf), de     ; current buffer to load in to 
0a13 d5				push de 
0a14				if DEBUG_STORESE 
0a14					DMARK "srg" 
0a14 f5				push af  
0a15 3a 29 0a			ld a, (.dmark)  
0a18 32 a6 fd			ld (debug_mark),a  
0a1b 3a 2a 0a			ld a, (.dmark+1)  
0a1e 32 a7 fd			ld (debug_mark+1),a  
0a21 3a 2b 0a			ld a, (.dmark+2)  
0a24 32 a8 fd			ld (debug_mark+2),a  
0a27 18 03			jr .pastdmark  
0a29 ..			.dmark: db "srg"  
0a2c f1			.pastdmark: pop af  
0a2d			endm  
# End of macro DMARK
0a2d					CALLMONITOR 
0a2d cd aa fd			call debug_vector  
0a30				endm  
# End of macro CALLMONITOR
0a30				endif 
0a30 cd 65 04			call storage_read_block 
0a33			 
0a33				; if this a continuation read??? 
0a33			 
0a33 2a b1 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a36			 
0a36 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a38 cd cf 0f			call addatohl 
0a3b 7e				ld a,(hl) 
0a3c fe 00			cp 0 
0a3e 28 02			jr z, .markiscont 
0a40 3e ff			ld a, 255 
0a42			 
0a42			.markiscont: 
0a42 32 a8 f9			ld (store_readcont), a 
0a45			 
0a45				if DEBUG_STORESE 
0a45					DMARK "srC" 
0a45 f5				push af  
0a46 3a 5a 0a			ld a, (.dmark)  
0a49 32 a6 fd			ld (debug_mark),a  
0a4c 3a 5b 0a			ld a, (.dmark+1)  
0a4f 32 a7 fd			ld (debug_mark+1),a  
0a52 3a 5c 0a			ld a, (.dmark+2)  
0a55 32 a8 fd			ld (debug_mark+2),a  
0a58 18 03			jr .pastdmark  
0a5a ..			.dmark: db "srC"  
0a5d f1			.pastdmark: pop af  
0a5e			endm  
# End of macro DMARK
0a5e					CALLMONITOR 
0a5e cd aa fd			call debug_vector  
0a61				endm  
# End of macro CALLMONITOR
0a61				endif 
0a61				; only short reads enabled 
0a61			 
0a61 3a b0 f9			ld a, (store_longread) 
0a64 fe 00			cp 0 
0a66 ca 33 0b			jp z, .readdone 
0a69			 
0a69			; TODO if block has no zeros then need to read next block  
0a69			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a69			; check last byte of physical block. 
0a69			; if not zero then the next block needs to be loaded 
0a69			 
0a69			 
0a69 2a b1 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a6c			 
0a6c 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a6e cd cf 0f			call addatohl 
0a71				;dec hl 
0a71 7e				ld a,(hl) 
0a72				if DEBUG_STORESE 
0a72					DMARK "sr?" 
0a72 f5				push af  
0a73 3a 87 0a			ld a, (.dmark)  
0a76 32 a6 fd			ld (debug_mark),a  
0a79 3a 88 0a			ld a, (.dmark+1)  
0a7c 32 a7 fd			ld (debug_mark+1),a  
0a7f 3a 89 0a			ld a, (.dmark+2)  
0a82 32 a8 fd			ld (debug_mark+2),a  
0a85 18 03			jr .pastdmark  
0a87 ..			.dmark: db "sr?"  
0a8a f1			.pastdmark: pop af  
0a8b			endm  
# End of macro DMARK
0a8b					CALLMONITOR 
0a8b cd aa fd			call debug_vector  
0a8e				endm  
# End of macro CALLMONITOR
0a8e				endif 
0a8e fe 00			cp 0 
0a90 ca 33 0b			jp z, .readdone 
0a93			 
0a93				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a93			 
0a93 23				inc hl 
0a94			 
0a94 22 b1 f9			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a97			 
0a97 ed 5b b3 f9		ld de, (store_readptr)     ; save the current extent to load 
0a9b			 
0a9b eb				ex de, hl 
0a9c			 
0a9c				; next ext 
0a9c			 
0a9c 23				inc hl 
0a9d 22 b3 f9			ld  (store_readptr), hl     ; save the current extent to load 
0aa0			 
0aa0				if DEBUG_STORESE 
0aa0					DMARK "sF2" 
0aa0 f5				push af  
0aa1 3a b5 0a			ld a, (.dmark)  
0aa4 32 a6 fd			ld (debug_mark),a  
0aa7 3a b6 0a			ld a, (.dmark+1)  
0aaa 32 a7 fd			ld (debug_mark+1),a  
0aad 3a b7 0a			ld a, (.dmark+2)  
0ab0 32 a8 fd			ld (debug_mark+2),a  
0ab3 18 03			jr .pastdmark  
0ab5 ..			.dmark: db "sF2"  
0ab8 f1			.pastdmark: pop af  
0ab9			endm  
# End of macro DMARK
0ab9					CALLMONITOR 
0ab9 cd aa fd			call debug_vector  
0abc				endm  
# End of macro CALLMONITOR
0abc				endif 
0abc			 
0abc				; get and load block 
0abc			 
0abc cd 98 07			call storage_findnextid 
0abf			 
0abf				if DEBUG_STORESE 
0abf					DMARK "sf2" 
0abf f5				push af  
0ac0 3a d4 0a			ld a, (.dmark)  
0ac3 32 a6 fd			ld (debug_mark),a  
0ac6 3a d5 0a			ld a, (.dmark+1)  
0ac9 32 a7 fd			ld (debug_mark+1),a  
0acc 3a d6 0a			ld a, (.dmark+2)  
0acf 32 a8 fd			ld (debug_mark+2),a  
0ad2 18 03			jr .pastdmark  
0ad4 ..			.dmark: db "sf2"  
0ad7 f1			.pastdmark: pop af  
0ad8			endm  
# End of macro DMARK
0ad8					CALLMONITOR 
0ad8 cd aa fd			call debug_vector  
0adb				endm  
# End of macro CALLMONITOR
0adb				endif 
0adb cd f8 0f			call ishlzero 
0ade			;	ld a, l 
0ade			;	add h 
0ade			;	cp 0 
0ade ca bc 09			jp z,.sr_fail			; block not found so EOF 
0ae1				 
0ae1				; save current address for use by higher level words etc 
0ae1			 
0ae1 22 a6 f9			ld (store_openaddr),hl 
0ae4			 
0ae4 cd 65 04			call storage_read_block 
0ae7			 
0ae7				; on a continuation block, we now have the file id and ext in the middle of the block 
0ae7				; we need to pull everything back  
0ae7			 
0ae7 ed 5b b1 f9		ld de, (store_readbuf)     ; current buffer to nudge into 
0aeb 2a b1 f9			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aee 23				inc hl 
0aef 23				inc hl     ; skip id and ext 
0af0 01 40 00			ld bc, STORE_BLOCK_PHY 
0af3				if DEBUG_STORESE 
0af3					DMARK "SR<" 
0af3 f5				push af  
0af4 3a 08 0b			ld a, (.dmark)  
0af7 32 a6 fd			ld (debug_mark),a  
0afa 3a 09 0b			ld a, (.dmark+1)  
0afd 32 a7 fd			ld (debug_mark+1),a  
0b00 3a 0a 0b			ld a, (.dmark+2)  
0b03 32 a8 fd			ld (debug_mark+2),a  
0b06 18 03			jr .pastdmark  
0b08 ..			.dmark: db "SR<"  
0b0b f1			.pastdmark: pop af  
0b0c			endm  
# End of macro DMARK
0b0c					CALLMONITOR 
0b0c cd aa fd			call debug_vector  
0b0f				endm  
# End of macro CALLMONITOR
0b0f				endif 
0b0f ed b0			ldir     ; copy data 
0b11			 
0b11				; move the pointer back and pretend we have a full buffer for next recheck 
0b11			 
0b11 1b				dec de 
0b12 1b				dec de 
0b13			 
0b13			; TODO do pop below now short circuit loop????? 
0b13 c1				pop bc     ; get rid of spare de on stack 
0b14				if DEBUG_STORESE 
0b14					DMARK "SR>" 
0b14 f5				push af  
0b15 3a 29 0b			ld a, (.dmark)  
0b18 32 a6 fd			ld (debug_mark),a  
0b1b 3a 2a 0b			ld a, (.dmark+1)  
0b1e 32 a7 fd			ld (debug_mark+1),a  
0b21 3a 2b 0b			ld a, (.dmark+2)  
0b24 32 a8 fd			ld (debug_mark+2),a  
0b27 18 03			jr .pastdmark  
0b29 ..			.dmark: db "SR>"  
0b2c f1			.pastdmark: pop af  
0b2d			endm  
# End of macro DMARK
0b2d					CALLMONITOR 
0b2d cd aa fd			call debug_vector  
0b30				endm  
# End of macro CALLMONITOR
0b30				endif 
0b30 c3 c1 09			jp .srext 
0b33			 
0b33			 
0b33			 
0b33			 
0b33			 
0b33			.readdone:		 
0b33 e1				pop hl 		 ; return start of data to show as not EOF 
0b34 23				inc hl   ; past file id 
0b35 23				inc hl   ; past ext 
0b36				if DEBUG_STORESE 
0b36					DMARK "SRe" 
0b36 f5				push af  
0b37 3a 4b 0b			ld a, (.dmark)  
0b3a 32 a6 fd			ld (debug_mark),a  
0b3d 3a 4c 0b			ld a, (.dmark+1)  
0b40 32 a7 fd			ld (debug_mark+1),a  
0b43 3a 4d 0b			ld a, (.dmark+2)  
0b46 32 a8 fd			ld (debug_mark+2),a  
0b49 18 03			jr .pastdmark  
0b4b ..			.dmark: db "SRe"  
0b4e f1			.pastdmark: pop af  
0b4f			endm  
# End of macro DMARK
0b4f					CALLMONITOR 
0b4f cd aa fd			call debug_vector  
0b52				endm  
# End of macro CALLMONITOR
0b52				endif 
0b52 c9					ret 
0b53			 
0b53			 
0b53			 
0b53			; 
0b53			; Append File 
0b53			; 
0b53			; hl - file id to locate 
0b53			; de - pointer to (multi block) string to write 
0b53			 
0b53			.sa_notfound: 
0b53 d1				pop de 
0b54 c9				ret 
0b55			 
0b55			 
0b55			storage_append: 
0b55				; hl -  file id to append to 
0b55				; de - string to append 
0b55			 
0b55 d5				push de 
0b56				 
0b56				if DEBUG_STORESE 
0b56					DMARK "AP1" 
0b56 f5				push af  
0b57 3a 6b 0b			ld a, (.dmark)  
0b5a 32 a6 fd			ld (debug_mark),a  
0b5d 3a 6c 0b			ld a, (.dmark+1)  
0b60 32 a7 fd			ld (debug_mark+1),a  
0b63 3a 6d 0b			ld a, (.dmark+2)  
0b66 32 a8 fd			ld (debug_mark+2),a  
0b69 18 03			jr .pastdmark  
0b6b ..			.dmark: db "AP1"  
0b6e f1			.pastdmark: pop af  
0b6f			endm  
# End of macro DMARK
0b6f					CALLMONITOR 
0b6f cd aa fd			call debug_vector  
0b72				endm  
# End of macro CALLMONITOR
0b72				endif 
0b72			 
0b72 7d				ld a, l 
0b73 32 a9 f9			ld (store_tmpid), a 
0b76			 
0b76				; get file header  
0b76			 
0b76 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b78 3a a9 f9			ld a, (store_tmpid) 
0b7b 5f				ld e, a 
0b7c			 
0b7c 21 40 00				ld hl, STORE_BLOCK_PHY 
0b7f cd 98 07				call storage_findnextid 
0b82			 
0b82 cd f8 0f			call ishlzero 
0b85 28 cc			jr z, .sa_notfound 
0b87			 
0b87 22 a0 f9			ld (store_tmppageid), hl 
0b8a			 
0b8a				; TODO handle file id not found 
0b8a			 
0b8a				if DEBUG_STORESE 
0b8a					DMARK "AP2" 
0b8a f5				push af  
0b8b 3a 9f 0b			ld a, (.dmark)  
0b8e 32 a6 fd			ld (debug_mark),a  
0b91 3a a0 0b			ld a, (.dmark+1)  
0b94 32 a7 fd			ld (debug_mark+1),a  
0b97 3a a1 0b			ld a, (.dmark+2)  
0b9a 32 a8 fd			ld (debug_mark+2),a  
0b9d 18 03			jr .pastdmark  
0b9f ..			.dmark: db "AP2"  
0ba2 f1			.pastdmark: pop af  
0ba3			endm  
# End of macro DMARK
0ba3					CALLMONITOR 
0ba3 cd aa fd			call debug_vector  
0ba6				endm  
# End of macro CALLMONITOR
0ba6				endif 
0ba6			 
0ba6				; update file extent count 
0ba6			 
0ba6 11 b5 f9			ld de, store_page 
0ba9			 
0ba9 cd 65 04			call storage_read_block 
0bac			 
0bac				if DEBUG_STORESE 
0bac					DMARK "AP3" 
0bac f5				push af  
0bad 3a c1 0b			ld a, (.dmark)  
0bb0 32 a6 fd			ld (debug_mark),a  
0bb3 3a c2 0b			ld a, (.dmark+1)  
0bb6 32 a7 fd			ld (debug_mark+1),a  
0bb9 3a c3 0b			ld a, (.dmark+2)  
0bbc 32 a8 fd			ld (debug_mark+2),a  
0bbf 18 03			jr .pastdmark  
0bc1 ..			.dmark: db "AP3"  
0bc4 f1			.pastdmark: pop af  
0bc5			endm  
# End of macro DMARK
0bc5					CALLMONITOR 
0bc5 cd aa fd			call debug_vector  
0bc8				endm  
# End of macro CALLMONITOR
0bc8				endif 
0bc8			;	ld (store_tmppageid), hl 
0bc8			 
0bc8 3a b7 f9			ld a, (store_page+2) 
0bcb 3c				inc a 
0bcc 32 b7 f9			ld (store_page+2), a 
0bcf 32 a8 f9			ld (store_tmpext), a 
0bd2				 
0bd2				if DEBUG_STORESE 
0bd2					DMARK "AP3" 
0bd2 f5				push af  
0bd3 3a e7 0b			ld a, (.dmark)  
0bd6 32 a6 fd			ld (debug_mark),a  
0bd9 3a e8 0b			ld a, (.dmark+1)  
0bdc 32 a7 fd			ld (debug_mark+1),a  
0bdf 3a e9 0b			ld a, (.dmark+2)  
0be2 32 a8 fd			ld (debug_mark+2),a  
0be5 18 03			jr .pastdmark  
0be7 ..			.dmark: db "AP3"  
0bea f1			.pastdmark: pop af  
0beb			endm  
# End of macro DMARK
0beb					CALLMONITOR 
0beb cd aa fd			call debug_vector  
0bee				endm  
# End of macro CALLMONITOR
0bee				endif 
0bee 2a a0 f9			ld hl, (store_tmppageid) 
0bf1 11 b5 f9			ld de, store_page 
0bf4 cd ca 04			call storage_write_block 
0bf7			 
0bf7				; find free block 
0bf7			 
0bf7 11 00 00			ld de, 0			 ; file extent to locate 
0bfa			 
0bfa 21 40 00				ld hl, STORE_BLOCK_PHY 
0bfd cd 98 07				call storage_findnextid 
0c00 cd f8 0f			call ishlzero 
0c03 ca 53 0b			jp z, .sa_notfound 
0c06			 
0c06					; TODO handle no space left 
0c06					 
0c06 22 a0 f9				ld (store_tmppageid), hl 
0c09			 
0c09				if DEBUG_STORESE 
0c09					DMARK "AP4" 
0c09 f5				push af  
0c0a 3a 1e 0c			ld a, (.dmark)  
0c0d 32 a6 fd			ld (debug_mark),a  
0c10 3a 1f 0c			ld a, (.dmark+1)  
0c13 32 a7 fd			ld (debug_mark+1),a  
0c16 3a 20 0c			ld a, (.dmark+2)  
0c19 32 a8 fd			ld (debug_mark+2),a  
0c1c 18 03			jr .pastdmark  
0c1e ..			.dmark: db "AP4"  
0c21 f1			.pastdmark: pop af  
0c22			endm  
# End of macro DMARK
0c22					CALLMONITOR 
0c22 cd aa fd			call debug_vector  
0c25				endm  
# End of macro CALLMONITOR
0c25				endif 
0c25					; init the buffer with zeros so we can id if the buffer is full or not 
0c25			 
0c25 e5					push hl 
0c26 c5					push bc 
0c27			 
0c27 21 b5 f9				ld hl, store_page 
0c2a 06 40				ld b, STORE_BLOCK_PHY 
0c2c 3e 00				ld a, 0 
0c2e 77			.zeroblock:	ld (hl), a 
0c2f 23					inc hl 
0c30 10 fc				djnz .zeroblock 
0c32			 
0c32 c1					pop bc 
0c33 e1					pop hl 
0c34			 
0c34					; construct block 
0c34			 
0c34 3a a9 f9				ld a, (store_tmpid) 
0c37 32 b5 f9				ld (store_page), a   ; file id 
0c3a 3a a8 f9				ld a, (store_tmpext)   ; extent for this block 
0c3d 32 b6 f9				ld (store_page+1), a 
0c40			 
0c40 e1					pop hl    ; get string to write 
0c41 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c43 11 b7 f9				ld de, store_page+2 
0c46			 
0c46				if DEBUG_STORESE 
0c46					DMARK "AP5" 
0c46 f5				push af  
0c47 3a 5b 0c			ld a, (.dmark)  
0c4a 32 a6 fd			ld (debug_mark),a  
0c4d 3a 5c 0c			ld a, (.dmark+1)  
0c50 32 a7 fd			ld (debug_mark+1),a  
0c53 3a 5d 0c			ld a, (.dmark+2)  
0c56 32 a8 fd			ld (debug_mark+2),a  
0c59 18 03			jr .pastdmark  
0c5b ..			.dmark: db "AP5"  
0c5e f1			.pastdmark: pop af  
0c5f			endm  
# End of macro DMARK
0c5f					CALLMONITOR 
0c5f cd aa fd			call debug_vector  
0c62				endm  
# End of macro CALLMONITOR
0c62				endif 
0c62			 
0c62			 
0c62			 
0c62					; fill buffer with data until end of string or full block 
0c62			 
0c62 7e			.appd:		ld a, (hl) 
0c63 12					ld (de), a 
0c64 fe 00				cp 0 
0c66 28 04				jr z, .appdone 
0c68 23					inc hl 
0c69 13					inc de 
0c6a 10 f6				djnz .appd 
0c6c			 
0c6c e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c6d f5					push af   		; save last byte dumped 
0c6e			 
0c6e			 
0c6e 2a a0 f9			ld hl, (store_tmppageid) 
0c71 11 b5 f9			ld de, store_page 
0c74				if DEBUG_STORESE 
0c74					DMARK "AP6" 
0c74 f5				push af  
0c75 3a 89 0c			ld a, (.dmark)  
0c78 32 a6 fd			ld (debug_mark),a  
0c7b 3a 8a 0c			ld a, (.dmark+1)  
0c7e 32 a7 fd			ld (debug_mark+1),a  
0c81 3a 8b 0c			ld a, (.dmark+2)  
0c84 32 a8 fd			ld (debug_mark+2),a  
0c87 18 03			jr .pastdmark  
0c89 ..			.dmark: db "AP6"  
0c8c f1			.pastdmark: pop af  
0c8d			endm  
# End of macro DMARK
0c8d					CALLMONITOR 
0c8d cd aa fd			call debug_vector  
0c90				endm  
# End of macro CALLMONITOR
0c90				endif 
0c90 cd ca 04				call storage_write_block 
0c93			 
0c93			 
0c93				; was that a full block of data written? 
0c93				; any more to write out? 
0c93			 
0c93				; if yes then set vars and jump to start of function again 
0c93			 
0c93 f1					pop af 
0c94 d1					pop de 
0c95			 
0c95 fe 00				cp 0		 ; no, string was fully written 
0c97 c8					ret z 
0c98			 
0c98					; setup vars for next cycle 
0c98			 
0c98 3a a9 f9				ld a, (store_tmpid) 
0c9b 6f					ld l, a 
0c9c 26 00				ld h, 0 
0c9e			 
0c9e c3 55 0b			 	jp storage_append	 ; yes, need to write out some more 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			if DEBUG_STORECF 
0ca1			storageput:	 
0ca1					ret 
0ca1			storageread: 
0ca1					ld hl, store_page 
0ca1					ld b, 200 
0ca1					ld a,0 
0ca1			.src:		ld (hl),a 
0ca1					inc hl 
0ca1					djnz .src 
0ca1					 
0ca1			 
0ca1					ld de, 0 
0ca1					ld bc, 1 
0ca1					ld hl, store_page 
0ca1					call cfRead 
0ca1			 
0ca1				call cfGetError 
0ca1				ld hl,scratch 
0ca1				call hexout 
0ca1				ld hl, scratch+2 
0ca1				ld a, 0 
0ca1				ld (hl),a 
0ca1				ld de, scratch 
0ca1				ld a,display_row_1 
0ca1				call str_at_display 
0ca1				call update_display 
0ca1			 
0ca1					ld hl, store_page 
0ca1					ld (os_cur_ptr),hl 
0ca1			 
0ca1					ret 
0ca1			endif 
0ca1			 
0ca1			 
0ca1			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ca1			 
0ca1			storage_clear_page: 
0ca1 e5				push hl 
0ca2 d5				push de 
0ca3 c5				push bc 
0ca4 21 b5 f9			ld hl, store_page 
0ca7 3e 00			ld a, 0 
0ca9 77				ld (hl), a 
0caa			 
0caa 11 b6 f9			ld de, store_page+1 
0cad 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0cb0			 
0cb0 ed b0			ldir 
0cb2				 
0cb2 c1				pop bc 
0cb3 d1				pop de 
0cb4 e1				pop hl 
0cb5 c9				ret 
0cb6			 
0cb6			; eof 
# End of file firmware_storage.asm
0cb6			  
0cb6			; support routines for above hardware abstraction layer  
0cb6			  
0cb6			include "firmware_general.asm"        ; general support functions  
0cb6			 
0cb6			; word look up 
0cb6			 
0cb6			; in 
0cb6			; a is the index 
0cb6			; hl is pointer start of array 
0cb6			; 
0cb6			; returns 
0cb6			; hl to the word 
0cb6			; 
0cb6			 
0cb6			table_lookup:  
0cb6 d5					push de 
0cb7 eb					ex de, hl 
0cb8			 
0cb8 6f					ld l, a 
0cb9 26 00				ld h, 0 
0cbb 29					add hl, hl 
0cbc 19					add hl, de 
0cbd 7e					ld a, (hl) 
0cbe 23					inc hl 
0cbf 66					ld h,(hl) 
0cc0 6f					ld l, a 
0cc1			 
0cc1 d1					pop de 
0cc2 c9					ret 
0cc3			 
0cc3			; Delay loops 
0cc3			 
0cc3			 
0cc3			 
0cc3			aDelayInMS: 
0cc3 c5				push bc 
0cc4 47				ld b,a 
0cc5			msdelay: 
0cc5 c5				push bc 
0cc6				 
0cc6			 
0cc6 01 41 00			ld bc,041h 
0cc9 cd e1 0c			call delayloop 
0ccc c1				pop bc 
0ccd 05				dec b 
0cce 20 f5			jr nz,msdelay 
0cd0			 
0cd0			;if CPU_CLOCK_8MHZ 
0cd0			;msdelay8: 
0cd0			;	push bc 
0cd0			;	 
0cd0			; 
0cd0			;	ld bc,041h 
0cd0			;	call delayloop 
0cd0			;	pop bc 
0cd0			;	dec b 
0cd0			;	jr nz,msdelay8 
0cd0			;endif 
0cd0			 
0cd0			 
0cd0 c1				pop bc 
0cd1 c9				ret 
0cd2			 
0cd2			 
0cd2			delay250ms: 
0cd2				;push de 
0cd2 01 00 40			ld bc, 04000h 
0cd5 c3 e1 0c			jp delayloop 
0cd8			delay500ms: 
0cd8				;push de 
0cd8 01 00 80			ld bc, 08000h 
0cdb c3 e1 0c			jp delayloop 
0cde			delay1s: 
0cde				;push bc 
0cde			   ; Clobbers A, d and e 
0cde 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0ce1			delayloop: 
0ce1 c5			    push bc 
0ce2			 
0ce2			if BASE_CPM 
0ce2				ld bc, CPM_DELAY_TUNE 
0ce2			.cpmloop: 
0ce2				push bc 
0ce2			 
0ce2			endif 
0ce2			 
0ce2			 
0ce2			 
0ce2			delayloopi: 
0ce2			;	push bc 
0ce2			;.dl: 
0ce2 cb 47		    bit     0,a    	; 8 
0ce4 cb 47		    bit     0,a    	; 8 
0ce6 cb 47		    bit     0,a    	; 8 
0ce8 e6 ff		    and     255  	; 7 
0cea 0b			    dec     bc      	; 6 
0ceb 79			    ld      a,c     	; 4 
0cec b0			    or      b     	; 4 
0ced c2 e2 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cf0			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cf0				;pop de 
0cf0			;pop bc 
0cf0			 
0cf0			if BASE_CPM 
0cf0				pop bc 
0cf0				 
0cf0			    dec     bc      	; 6 
0cf0			    ld      a,c     	; 4 
0cf0			    or      b     	; 4 
0cf0			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cf0				 
0cf0			 
0cf0			endif 
0cf0			;if CPU_CLOCK_8MHZ 
0cf0			;    pop bc 
0cf0			;    push bc 
0cf0			;.dl8: 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    and     255  	; 7 
0cf0			;    dec     bc      	; 6 
0cf0			;    ld      a,c     	; 4 
0cf0			;    or      b     	; 4 
0cf0			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf0			;endif 
0cf0			 
0cf0			;if CPU_CLOCK_10MHZ 
0cf0			;    pop bc 
0cf0			;    push bc 
0cf0			;.dl8: 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    and     255  	; 7 
0cf0			;    dec     bc      	; 6 
0cf0			;    ld      a,c     	; 4 
0cf0			;    or      b     	; 4 
0cf0			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf0			;endif 
0cf0 c1			    pop bc 
0cf1			 
0cf1 c9				ret 
0cf2			 
0cf2			 
0cf2			 
0cf2			; eof 
# End of file firmware_general.asm
0cf2			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0cf2			; display routines that use the physical hardware abstraction layer 
0cf2			 
0cf2			 
0cf2			; Display an activity indicator 
0cf2			; Each call returns the new char pointed to in hl 
0cf2			 
0cf2			active: 
0cf2 3a 01 fb			ld a, (display_active) 
0cf5 fe 06			cp 6 
0cf7			 
0cf7 20 02			jr nz, .sne 
0cf9				; gone past the last one reset sequence 
0cf9 3e ff			ld a, 255 
0cfb			 
0cfb			.sne:   
0cfb				; get the next char in seq 
0cfb 3c				inc a 
0cfc 32 01 fb			ld (display_active), a 
0cff			 
0cff				; look up the string in the table 
0cff 21 16 0d			ld hl, actseq 
0d02 cb 27			sla a 
0d04 cd cf 0f			call addatohl 
0d07 cd 32 24			call loadwordinhl 
0d0a			 
0d0a				; forth will write the to string when pushing so move from rom to ram 
0d0a			 
0d0a 11 02 fb			ld de, display_active+1 
0d0d 01 02 00			ld bc, 2 
0d10 ed b0			ldir 
0d12			 
0d12 21 02 fb			ld hl, display_active+1 
0d15 c9				ret 
0d16				 
0d16				 
0d16			 
0d16			 
0d16			;db "|/-\|-\" 
0d16			 
0d16			actseq: 
0d16			 
0d16 24 0d		dw spin0 
0d18 26 0d		dw spin1 
0d1a 28 0d		dw spin2 
0d1c 2a 0d		dw spin3 
0d1e 28 0d		dw spin2 
0d20 26 0d		dw spin1 
0d22 24 0d		dw spin0 
0d24			 
0d24 .. 00		spin0: db " ", 0 
0d26 .. 00		spin1: db "-", 0 
0d28 .. 00		spin2: db "+", 0 
0d2a .. 00		spin3: db "#", 0 
0d2c			 
0d2c			 
0d2c			; information window 
0d2c			 
0d2c			; pass hl with 1st string to display 
0d2c			; pass de with 2nd string to display 
0d2c			 
0d2c			info_panel: 
0d2c e5				push hl 
0d2d			 
0d2d 2a 07 fb			ld hl, (display_fb_active) 
0d30 e5				push hl    ; future de destination 
0d31 21 ec fc				ld hl, display_fb0 
0d34 22 07 fb				ld (display_fb_active), hl 
0d37			 
0d37			;	call clear_display 
0d37			 
0d37				if BASE_CPM 
0d37				ld a, '.' 
0d37				else 
0d37 3e a5			ld a, 165 
0d39				endif 
0d39 cd a0 0d			call fill_display 
0d3c			 
0d3c			 
0d3c 3e 55			ld a, display_row_3 + 5 
0d3e cd ae 0d			call str_at_display 
0d41			 
0d41 e1				pop hl 
0d42 d1				pop de 
0d43			 
0d43 e5				push hl 
0d44			 
0d44			 
0d44 3e 2d			ld a, display_row_2 + 5 
0d46 cd ae 0d			call str_at_display 
0d49			 
0d49			 
0d49 cd be 0d			call update_display 
0d4c cd 7b 20			call next_page_prompt 
0d4f cd 9b 0d			call clear_display 
0d52			 
0d52				 
0d52 21 4b fc				ld hl, display_fb1 
0d55 22 07 fb				ld (display_fb_active), hl 
0d58 cd be 0d			call update_display 
0d5b			 
0d5b e1				pop hl 
0d5c			 
0d5c c9				ret 
0d5d			 
0d5d			 
0d5d			 
0d5d			 
0d5d			; TODO windowing? 
0d5d			 
0d5d			; TODO scroll line up 
0d5d			 
0d5d			scroll_up: 
0d5d			 
0d5d e5				push hl 
0d5e d5				push de 
0d5f c5				push bc 
0d60			 
0d60				; get frame buffer  
0d60			 
0d60 2a 07 fb			ld hl, (display_fb_active) 
0d63 e5				push hl    ; future de destination 
0d64			 
0d64 11 28 00			ld  de, display_cols 
0d67 19				add hl, de 
0d68			 
0d68 d1				pop de 
0d69			 
0d69				;ex de, hl 
0d69 01 9f 00			ld bc, display_fb_len -1  
0d6c			;if DEBUG_FORTH_WORDS 
0d6c			;	DMARK "SCL" 
0d6c			;	CALLMONITOR 
0d6c			;endif	 
0d6c ed b0			ldir 
0d6e			 
0d6e				; wipe bottom row 
0d6e			 
0d6e			 
0d6e 2a 07 fb			ld hl, (display_fb_active) 
0d71 11 a0 00			ld de, display_cols*display_rows 
0d74 19				add hl, de 
0d75 06 28			ld b, display_cols 
0d77 3e 20			ld a, ' ' 
0d79			.scwipe: 
0d79 77				ld (hl), a 
0d7a 2b				dec hl 
0d7b 10 fc			djnz .scwipe 
0d7d			 
0d7d				;pop hl 
0d7d			 
0d7d c1				pop bc 
0d7e d1				pop de 
0d7f e1				pop hl 
0d80			 
0d80 c9				ret 
0d81			 
0d81			 
0d81			;scroll_upo: 
0d81			;	ld de, display_row_1 
0d81			 ;	ld hl, display_row_2 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			;	ld de, display_row_2 
0d81			 ;	ld hl, display_row_3 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			;	ld de, display_row_3 
0d81			 ;	ld hl, display_row_4 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			 
0d81			; TODO clear row 4 
0d81			 
0d81			;	ret 
0d81			 
0d81				 
0d81			scroll_down: 
0d81			 
0d81 e5				push hl 
0d82 d5				push de 
0d83 c5				push bc 
0d84			 
0d84				; get frame buffer  
0d84			 
0d84 2a 07 fb			ld hl, (display_fb_active) 
0d87			 
0d87 11 9f 00			ld de, display_fb_len - 1 
0d8a 19				add hl, de 
0d8b			 
0d8b e5			push hl    ; future de destination 
0d8c			 
0d8c 11 28 00			ld  de, display_cols 
0d8f ed 52			sbc hl, de 
0d91			 
0d91			 
0d91 d1				pop de 
0d92			 
0d92			;	ex de, hl 
0d92 01 9f 00			ld bc, display_fb_len -1  
0d95			 
0d95			 
0d95				 
0d95			 
0d95 ed b0			ldir 
0d97			 
0d97				; wipe bottom row 
0d97			 
0d97			 
0d97			;	ld hl, (display_fb_active) 
0d97			;;	ld de, display_cols*display_rows 
0d97			;;	add hl, de 
0d97			;	ld b, display_cols 
0d97			;	ld a, ' ' 
0d97			;.scwiped: 
0d97			;	ld (hl), a 
0d97			;	dec hl 
0d97			;	djnz .scwiped 
0d97			 
0d97				;pop hl 
0d97			 
0d97 c1				pop bc 
0d98 d1				pop de 
0d99 e1				pop hl 
0d9a			 
0d9a c9				ret 
0d9b			;scroll_down: 
0d9b			;	ld de, display_row_4 
0d9b			;	ld hl, display_row_3 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;	ld de, display_row_3 
0d9b			; 	ld hl, display_row_2 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;	ld de, display_row_2 
0d9b			;	ld hl, display_row_1 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;;; TODO clear row 1 
0d9b			;	ret 
0d9b			 
0d9b			 
0d9b			 
0d9b			 
0d9b			 
0d9b			; clear active frame buffer 
0d9b			 
0d9b			clear_display: 
0d9b 3e 20			ld a, ' ' 
0d9d c3 a0 0d			jp fill_display 
0da0			 
0da0			; fill active frame buffer with a char in A 
0da0			 
0da0			fill_display: 
0da0 06 a0			ld b,display_fb_len 
0da2 2a 07 fb			ld hl, (display_fb_active) 
0da5 77			.fd1:	ld (hl),a 
0da6 23				inc hl 
0da7 10 fc			djnz .fd1 
0da9 23				inc hl 
0daa 3e 00			ld a,0 
0dac 77				ld (hl),a 
0dad			 
0dad			 
0dad c9				ret 
0dae			; Write string (DE) at pos (A) to active frame buffer 
0dae			 
0dae 2a 07 fb		str_at_display:    ld hl,(display_fb_active) 
0db1 06 00					ld b,0 
0db3 4f					ld c,a 
0db4 09					add hl,bc 
0db5 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0db6 b7			            OR   A              ;Null terminator? 
0db7 c8			            RET  Z              ;Yes, so finished 
0db8 77					ld (hl),a 
0db9 23				inc hl 
0dba 13			            INC  DE             ;Point to next character 
0dbb 18 f8		            JR   .sad1     ;Repeat 
0dbd c9					ret 
0dbe			 
0dbe			; using current frame buffer write to physical display 
0dbe			 
0dbe			update_display: 
0dbe e5				push hl 
0dbf 2a 07 fb			ld hl, (display_fb_active) 
0dc2 cd 32 77			call write_display 
0dc5 e1				pop hl 
0dc6 c9				ret 
0dc7			 
0dc7			; TODO scrolling 
0dc7			 
0dc7			 
0dc7			; move cursor right one char 
0dc7			cursor_right: 
0dc7			 
0dc7				; TODO shift right 
0dc7				; TODO if beyond max col 
0dc7				; TODO       cursor_next_line 
0dc7			 
0dc7 c9				ret 
0dc8			 
0dc8			 
0dc8			cursor_next_line: 
0dc8				; TODO first char 
0dc8				; TODO line down 
0dc8				; TODO if past last row 
0dc8				; TODO    scroll up 
0dc8			 
0dc8 c9				ret 
0dc9			 
0dc9			cursor_left: 
0dc9				; TODO shift left 
0dc9				; TODO if beyond left  
0dc9				; TODO     cursor prev line 
0dc9				 
0dc9 c9				ret 
0dca			 
0dca			cursor_prev_line: 
0dca				; TODO last char 
0dca				; TODO line up 
0dca				; TODO if past first row 
0dca				; TODO   scroll down 
0dca			 
0dca c9				ret 
0dcb			 
0dcb			 
0dcb			cout: 
0dcb				; A - char 
0dcb c9				ret 
0dcc			 
0dcc			 
0dcc			; Display a menu and allow item selection (optional toggle items) 
0dcc			; 
0dcc			; format: 
0dcc			; hl pointer to word array with zero term for items 
0dcc			; e.g.    db item1 
0dcc			;         db .... 
0dcc			;         db 0 
0dcc			; 
0dcc			; a = starting menu item  
0dcc			; 
0dcc			; de = pointer item toggle array   (todo) 
0dcc			; 
0dcc			; returns item selected in a 1-... 
0dcc			; returns 0 if back button pressed 
0dcc			; 
0dcc			; NOTE: Uses system frame buffer to display 
0dcc			; 
0dcc			; LEFT, Q = go back 
0dcc			; RIGHT, SPACE, CR = select 
0dcc			; UP, A - Up 
0dcc			; DOWN, Z - Down 
0dcc			 
0dcc			 
0dcc			 
0dcc			 
0dcc			 
0dcc			menu: 
0dcc			 
0dcc					; keep array pointer 
0dcc			 
0dcc 22 ae f9				ld (store_tmp1), hl 
0dcf 32 ac f9				ld (store_tmp2), a 
0dd2			 
0dd2					; check for key bounce 
0dd2			 
0dd2			if BASE_KEV 
0dd2			 
0dd2 cd 7d 7a		.mbounce:	call cin 
0dd5 fe 00				cp 0 
0dd7 20 f9				jr nz, .mbounce 
0dd9			endif 
0dd9					; for ease use ex 
0dd9			 
0dd9					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0dd9 21 ec fc				ld hl, display_fb0 
0ddc 22 07 fb				ld (display_fb_active), hl 
0ddf			 
0ddf cd 9b 0d		.mloop:		call clear_display 
0de2 cd be 0d				call update_display 
0de5			 
0de5					; draw selection id '>' at 1 
0de5			 
0de5					; init start of list display 
0de5			 
0de5 3e 05				ld a, 5 
0de7 32 aa f9				ld (store_tmp3), a   ; display row count 
0dea 3a ac f9				ld a,( store_tmp2) 
0ded 32 ad f9				ld (store_tmp2+1), a   ; display item count 
0df0			 
0df0					 
0df0			.mitem:	 
0df0			 
0df0			 
0df0 3a ad f9				ld a,(store_tmp2+1) 
0df3 6f					ld l, a 
0df4 26 00				ld h, 0 
0df6 29					add hl, hl 
0df7 ed 5b ae f9			ld de, (store_tmp1) 
0dfb 19					add hl, de 
0dfc 7e					ld a, (hl) 
0dfd 23					inc hl 
0dfe 66					ld h,(hl) 
0dff 6f					ld l, a 
0e00			 
0e00 cd f8 0f				call ishlzero 
0e03 28 1a				jr z, .mdone 
0e05			 
0e05 eb					ex de, hl 
0e06 3a aa f9				ld a, (store_tmp3) 
0e09 cd ae 0d				call str_at_display 
0e0c					 
0e0c			 
0e0c					; next item 
0e0c 3a ad f9				ld a, (store_tmp2+1) 
0e0f 3c					inc a 
0e10 32 ad f9				ld (store_tmp2+1), a   ; display item count 
0e13			 
0e13			 		; next row 
0e13			 
0e13 3a aa f9				ld a, (store_tmp3) 
0e16 c6 28				add display_cols 
0e18 32 aa f9				ld (store_tmp3), a 
0e1b			 
0e1b					; at end of screen? 
0e1b			 
0e1b fe 10				cp display_rows*4 
0e1d 20 d1				jr nz, .mitem 
0e1f			 
0e1f			 
0e1f			.mdone: 
0e1f cd f8 0f				call ishlzero 
0e22 28 08				jr z, .nodn 
0e24			 
0e24 3e 78				ld a, display_row_4 
0e26 11 a5 0e				ld de, .mdown 
0e29 cd ae 0d				call str_at_display 
0e2c			 
0e2c					; draw options to fill the screens with active item on line 1 
0e2c					; if current option is 2 or more then display ^ in top 
0e2c			 
0e2c 3a ac f9		.nodn:		ld a, (store_tmp2) 
0e2f fe 00				cp 0 
0e31 28 08				jr z, .noup 
0e33			 
0e33 3e 00				ld a, 0 
0e35 11 a3 0e				ld de, .mup 
0e38 cd ae 0d				call str_at_display 
0e3b			 
0e3b 3e 02		.noup:		ld a, 2 
0e3d 11 a1 0e				ld de, .msel 
0e40 cd ae 0d				call str_at_display 
0e43			 
0e43					; if current option + 1 is not null then display V in bottom 
0e43					; get key 
0e43 cd be 0d				call update_display 
0e46			 
0e46			 
0e46					; handle key 
0e46			 
0e46 cd 6c 7a				call cin_wait 
0e49			 
0e49 fe 05				cp KEY_UP 
0e4b 28 2b				jr z, .mgoup 
0e4d fe 61				cp 'a' 
0e4f 28 27				jr z, .mgoup 
0e51 fe 0a				cp KEY_DOWN 
0e53 28 32				jr z, .mgod 
0e55 fe 7a				cp 'z' 
0e57 28 2e				jr z, .mgod 
0e59 fe 20				cp ' ' 
0e5b 28 34				jr z, .goend 
0e5d fe 0c				cp KEY_RIGHT 
0e5f 28 30				jr z, .goend 
0e61 fe 0d				cp KEY_CR 
0e63 28 2c				jr z, .goend 
0e65 fe 71				cp 'q' 
0e67 28 0b				jr z, .goback 
0e69			 
0e69 fe 0b				cp KEY_LEFT 
0e6b 28 07				jr z, .goback 
0e6d fe 08				cp KEY_BS 
0e6f 28 03				jr z, .goback 
0e71 c3 df 0d				jp .mloop 
0e74			 
0e74			.goback: 
0e74 3e 00			ld a, 0 
0e76 18 1d			jr .goend2 
0e78			 
0e78				; move up one 
0e78			.mgoup: 
0e78 3a ac f9				ld a, (store_tmp2) 
0e7b fe 00				cp 0 
0e7d ca df 0d				jp z, .mloop 
0e80 3d					dec a 
0e81 32 ac f9				ld (store_tmp2), a 
0e84 c3 df 0d				jp .mloop 
0e87			 
0e87				; move down one 
0e87			.mgod: 
0e87 3a ac f9				ld a, (store_tmp2) 
0e8a 3c					inc a 
0e8b 32 ac f9				ld (store_tmp2), a 
0e8e c3 df 0d				jp .mloop 
0e91			 
0e91			 
0e91			.goend: 
0e91					; get selected item number 
0e91			 
0e91 3a ac f9				ld a, (store_tmp2) 
0e94 3c					inc a 
0e95			 
0e95			.goend2: 
0e95 f5					push af 
0e96			 
0e96					; restore active fb 
0e96					; TODO BUG assumes fb1 
0e96			 
0e96 21 4b fc				ld hl, display_fb1 
0e99 22 07 fb				ld (display_fb_active), hl 
0e9c			 
0e9c					; restore main regs 
0e9c			 
0e9c			 
0e9c cd be 0d				call update_display 
0e9f			 
0e9f f1					pop af 
0ea0			 
0ea0 c9				ret 
0ea1			 
0ea1 .. 00		.msel:   db ">",0 
0ea3 .. 00		.mup:   db "^",0 
0ea5 .. 00		.mdown:   db "v",0 
0ea7			 
0ea7			 
0ea7			; eof 
0ea7			 
# End of file firmware_display.asm
0ea7			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ea7			; random number generators 
0ea7			 
0ea7			 
0ea7			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ea7			 
0ea7			 
0ea7			;-----> Generate a random number 
0ea7			; output a=answer 0<=a<=255 
0ea7			; all registers are preserved except: af 
0ea7			random: 
0ea7 e5			        push    hl 
0ea8 d5			        push    de 
0ea9 2a e6 fa		        ld      hl,(randData) 
0eac ed 5f		        ld      a,r 
0eae 57			        ld      d,a 
0eaf 5e			        ld      e,(hl) 
0eb0 19			        add     hl,de 
0eb1 85			        add     a,l 
0eb2 ac			        xor     h 
0eb3 22 e6 fa		        ld      (randData),hl 
0eb6 d1			        pop     de 
0eb7 e1			        pop     hl 
0eb8 c9			        ret 
0eb9			 
0eb9			 
0eb9			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0eb9			 
0eb9			 
0eb9			 
0eb9			;------LFSR------ 
0eb9			;James Montelongo 
0eb9			;optimized by Spencer Putt 
0eb9			;out: 
0eb9			; a = 8 bit random number 
0eb9			RandLFSR: 
0eb9 21 ec fa		        ld hl,LFSRSeed+4 
0ebc 5e			        ld e,(hl) 
0ebd 23			        inc hl 
0ebe 56			        ld d,(hl) 
0ebf 23			        inc hl 
0ec0 4e			        ld c,(hl) 
0ec1 23			        inc hl 
0ec2 7e			        ld a,(hl) 
0ec3 47			        ld b,a 
0ec4 cb 13		        rl e  
0ec6 cb 12			rl d 
0ec8 cb 11		        rl c  
0eca 17				rla 
0ecb cb 13		        rl e  
0ecd cb 12			rl d 
0ecf cb 11		        rl c  
0ed1 17				rla 
0ed2 cb 13		        rl e  
0ed4 cb 12			rl d 
0ed6 cb 11		        rl c  
0ed8 17				rla 
0ed9 67			        ld h,a 
0eda cb 13		        rl e  
0edc cb 12			rl d 
0ede cb 11		        rl c  
0ee0 17				rla 
0ee1 a8			        xor b 
0ee2 cb 13		        rl e  
0ee4 cb 12			rl d 
0ee6 ac			        xor h 
0ee7 a9			        xor c 
0ee8 aa			        xor d 
0ee9 21 ee fa		        ld hl,LFSRSeed+6 
0eec 11 ef fa		        ld de,LFSRSeed+7 
0eef 01 07 00		        ld bc,7 
0ef2 ed b8		        lddr 
0ef4 12			        ld (de),a 
0ef5 c9			        ret 
0ef6			 
0ef6			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ef6			 
0ef6			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ef6			 
0ef6			 
0ef6			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ef6			 
0ef6			prng16: 
0ef6			;Inputs: 
0ef6			;   (seed1) contains a 16-bit seed value 
0ef6			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ef6			;Outputs: 
0ef6			;   HL is the result 
0ef6			;   BC is the result of the LCG, so not that great of quality 
0ef6			;   DE is preserved 
0ef6			;Destroys: 
0ef6			;   AF 
0ef6			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ef6			;160cc 
0ef6			;26 bytes 
0ef6 2a e0 fa		    ld hl,(seed1) 
0ef9 44			    ld b,h 
0efa 4d			    ld c,l 
0efb 29			    add hl,hl 
0efc 29			    add hl,hl 
0efd 2c			    inc l 
0efe 09			    add hl,bc 
0eff 22 e0 fa		    ld (seed1),hl 
0f02 2a de fa		    ld hl,(seed2) 
0f05 29			    add hl,hl 
0f06 9f			    sbc a,a 
0f07 e6 2d		    and %00101101 
0f09 ad			    xor l 
0f0a 6f			    ld l,a 
0f0b 22 de fa		    ld (seed2),hl 
0f0e 09			    add hl,bc 
0f0f c9			    ret 
0f10			 
0f10			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0f10			 
0f10			rand32: 
0f10			;Inputs: 
0f10			;   (seed1_0) holds the lower 16 bits of the first seed 
0f10			;   (seed1_1) holds the upper 16 bits of the first seed 
0f10			;   (seed2_0) holds the lower 16 bits of the second seed 
0f10			;   (seed2_1) holds the upper 16 bits of the second seed 
0f10			;   **NOTE: seed2 must be non-zero 
0f10			;Outputs: 
0f10			;   HL is the result 
0f10			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0f10			;Destroys: 
0f10			;   AF 
0f10			;Tested and passes all CAcert tests 
0f10			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0f10			;it has a period of 18,446,744,069,414,584,320 
0f10			;roughly 18.4 quintillion. 
0f10			;LFSR taps: 0,2,6,7  = 11000101 
0f10			;291cc 
0f10			;seed1_0=$+1 
0f10			;    ld hl,12345 
0f10			;seed1_1=$+1 
0f10			;    ld de,6789 
0f10			;    ld b,h 
0f10			;    ld c,l 
0f10			;    add hl,hl \ rl e \ rl d 
0f10			;    add hl,hl \ rl e \ rl d 
0f10			;    inc l 
0f10			;    add hl,bc 
0f10			;    ld (seed1_0),hl 
0f10			;    ld hl,(seed1_1) 
0f10			;    adc hl,de 
0f10			;    ld (seed1_1),hl 
0f10			;    ex de,hl 
0f10			;seed2_0=$+1 
0f10			;    ld hl,9876 
0f10			;seed2_1=$+1 
0f10			;    ld bc,54321 
0f10			;    add hl,hl \ rl c \ rl b 
0f10			;    ld (seed2_1),bc 
0f10			;    sbc a,a 
0f10			;    and %11000101 
0f10			;    xor l 
0f10			;    ld l,a 
0f10			;    ld (seed2_0),hl 
0f10			;    ex de,hl 
0f10			;    add hl,bc 
0f10			;    ret 
0f10			; 
0f10			 
0f10			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0f10			; 20 bytes, 86 cycles (excluding ret) 
0f10			 
0f10			; returns   hl = pseudorandom number 
0f10			; corrupts   a 
0f10			 
0f10			; generates 16-bit pseudorandom numbers with a period of 65535 
0f10			; using the xorshift method: 
0f10			 
0f10			; hl ^= hl << 7 
0f10			; hl ^= hl >> 9 
0f10			; hl ^= hl << 8 
0f10			 
0f10			; some alternative shift triplets which also perform well are: 
0f10			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0f10			 
0f10			;  org 32768 
0f10			 
0f10			xrnd: 
0f10 2a e4 fa		  ld hl,(xrandc)       ; seed must not be 0 
0f13 3e 00		  ld a,0 
0f15 bd			  cp l 
0f16 20 02		  jr nz, .xrnd1 
0f18 2e 01		  ld l, 1 
0f1a			.xrnd1: 
0f1a			 
0f1a 7c			  ld a,h 
0f1b 1f			  rra 
0f1c 7d			  ld a,l 
0f1d 1f			  rra 
0f1e ac			  xor h 
0f1f 67			  ld h,a 
0f20 7d			  ld a,l 
0f21 1f			  rra 
0f22 7c			  ld a,h 
0f23 1f			  rra 
0f24 ad			  xor l 
0f25 6f			  ld l,a 
0f26 ac			  xor h 
0f27 67			  ld h,a 
0f28			 
0f28 22 e4 fa		  ld (xrandc),hl 
0f2b			 
0f2b c9			  ret 
0f2c			;  
0f2c			 
0f2c			 
0f2c			;;;; int maths 
0f2c			 
0f2c			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f2c			; Divide 16-bit values (with 16-bit result) 
0f2c			; In: Divide BC by divider DE 
0f2c			; Out: BC = result, HL = rest 
0f2c			; 
0f2c			Div16: 
0f2c 21 00 00		    ld hl,0 
0f2f 78			    ld a,b 
0f30 06 08		    ld b,8 
0f32			Div16_Loop1: 
0f32 17			    rla 
0f33 ed 6a		    adc hl,hl 
0f35 ed 52		    sbc hl,de 
0f37 30 01		    jr nc,Div16_NoAdd1 
0f39 19			    add hl,de 
0f3a			Div16_NoAdd1: 
0f3a 10 f6		    djnz Div16_Loop1 
0f3c 17			    rla 
0f3d 2f			    cpl 
0f3e 47			    ld b,a 
0f3f 79			    ld a,c 
0f40 48			    ld c,b 
0f41 06 08		    ld b,8 
0f43			Div16_Loop2: 
0f43 17			    rla 
0f44 ed 6a		    adc hl,hl 
0f46 ed 52		    sbc hl,de 
0f48 30 01		    jr nc,Div16_NoAdd2 
0f4a 19			    add hl,de 
0f4b			Div16_NoAdd2: 
0f4b 10 f6		    djnz Div16_Loop2 
0f4d 17			    rla 
0f4e 2f			    cpl 
0f4f 41			    ld b,c 
0f50 4f			    ld c,a 
0f51 c9			ret 
0f52			 
0f52			 
0f52			;http://z80-heaven.wikidot.com/math 
0f52			; 
0f52			;Inputs: 
0f52			;     DE and A are factors 
0f52			;Outputs: 
0f52			;     A is not changed 
0f52			;     B is 0 
0f52			;     C is not changed 
0f52			;     DE is not changed 
0f52			;     HL is the product 
0f52			;Time: 
0f52			;     342+6x 
0f52			; 
0f52			Mult16: 
0f52			 
0f52 06 08		     ld b,8          ;7           7 
0f54 21 00 00		     ld hl,0         ;10         10 
0f57 29			       add hl,hl     ;11*8       88 
0f58 07			       rlca          ;4*8        32 
0f59 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f5b 19			         add hl,de   ;--         -- 
0f5c 10 f9		       djnz $-5      ;13*7+8     99 
0f5e c9			ret 
0f5f			 
0f5f			; 
0f5f			; Square root of 16-bit value 
0f5f			; In:  HL = value 
0f5f			; Out:  D = result (rounded down) 
0f5f			; 
0f5f			;Sqr16: 
0f5f			;    ld de,#0040 
0f5f			;    ld a,l 
0f5f			;    ld l,h 
0f5f			;    ld h,d 
0f5f			;    or a 
0f5f			;    ld b,8 
0f5f			;Sqr16_Loop: 
0f5f			;    sbc hl,de 
0f5f			;    jr nc,Sqr16_Skip 
0f5f			;    add hl,de 
0f5f			;Sqr16_Skip: 
0f5f			;    ccf 
0f5f			;    rl d 
0f5f			;    add a,a 
0f5f			;    adc hl,hl 
0f5f			;    add a,a 
0f5f			;    adc hl,hl 
0f5f			;    djnz Sqr16_Loop 
0f5f			;    ret 
0f5f			; 
0f5f			; 
0f5f			; Divide 8-bit values 
0f5f			; In: Divide E by divider C 
0f5f			; Out: A = result, B = rest 
0f5f			; 
0f5f			Div8: 
0f5f af			    xor a 
0f60 06 08		    ld b,8 
0f62			Div8_Loop: 
0f62 cb 13		    rl e 
0f64 17			    rla 
0f65 91			    sub c 
0f66 30 01		    jr nc,Div8_NoAdd 
0f68 81			    add a,c 
0f69			Div8_NoAdd: 
0f69 10 f7		    djnz Div8_Loop 
0f6b 47			    ld b,a 
0f6c 7b			    ld a,e 
0f6d 17			    rla 
0f6e 2f			    cpl 
0f6f c9			    ret 
0f70			 
0f70			; 
0f70			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f70			; In: Multiply A with DE 
0f70			; Out: HL = result 
0f70			; 
0f70			Mult12U: 
0f70 2e 00		    ld l,0 
0f72 87			    add a,a 
0f73 30 01		    jr nc,Mult12U_NoAdd0 
0f75 19			    add hl,de 
0f76			Mult12U_NoAdd0: 
0f76 29			    add hl,hl 
0f77 87			    add a,a 
0f78 30 01		    jr nc,Mult12U_NoAdd1 
0f7a 19			    add hl,de 
0f7b			Mult12U_NoAdd1: 
0f7b 29			    add hl,hl 
0f7c 87			    add a,a 
0f7d 30 01		    jr nc,Mult12U_NoAdd2 
0f7f 19			    add hl,de 
0f80			Mult12U_NoAdd2: 
0f80 29			    add hl,hl 
0f81 87			    add a,a 
0f82 30 01		    jr nc,Mult12U_NoAdd3 
0f84 19			    add hl,de 
0f85			Mult12U_NoAdd3: 
0f85 29			    add hl,hl 
0f86 87			    add a,a 
0f87 30 01		    jr nc,Mult12U_NoAdd4 
0f89 19			    add hl,de 
0f8a			Mult12U_NoAdd4: 
0f8a 29			    add hl,hl 
0f8b 87			    add a,a 
0f8c 30 01		    jr nc,Mult12U_NoAdd5 
0f8e 19			    add hl,de 
0f8f			Mult12U_NoAdd5: 
0f8f 29			    add hl,hl 
0f90 87			    add a,a 
0f91 30 01		    jr nc,Mult12U_NoAdd6 
0f93 19			    add hl,de 
0f94			Mult12U_NoAdd6: 
0f94 29			    add hl,hl 
0f95 87			    add a,a 
0f96 d0			    ret nc 
0f97 19			    add hl,de 
0f98 c9			    ret 
0f99			 
0f99			; 
0f99			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f99			; In: Multiply A with DE 
0f99			;      Put lowest value in A for most efficient calculation 
0f99			; Out: HL = result 
0f99			; 
0f99			Mult12R: 
0f99 21 00 00		    ld hl,0 
0f9c			Mult12R_Loop: 
0f9c cb 3f		    srl a 
0f9e 30 01		    jr nc,Mult12R_NoAdd 
0fa0 19			    add hl,de 
0fa1			Mult12R_NoAdd: 
0fa1 cb 23		    sla e 
0fa3 cb 12		    rl d 
0fa5 b7			    or a 
0fa6 c2 9c 0f		    jp nz,Mult12R_Loop 
0fa9 c9			    ret 
0faa			 
0faa			; 
0faa			; Multiply 16-bit values (with 32-bit result) 
0faa			; In: Multiply BC with DE 
0faa			; Out: BCHL = result 
0faa			; 
0faa			Mult32: 
0faa 79			    ld a,c 
0fab 48			    ld c,b 
0fac 21 00 00		    ld hl,0 
0faf 06 10		    ld b,16 
0fb1			Mult32_Loop: 
0fb1 29			    add hl,hl 
0fb2 17			    rla 
0fb3 cb 11		    rl c 
0fb5 30 07		    jr nc,Mult32_NoAdd 
0fb7 19			    add hl,de 
0fb8 ce 00		    adc a,0 
0fba d2 be 0f		    jp nc,Mult32_NoAdd 
0fbd 0c			    inc c 
0fbe			Mult32_NoAdd: 
0fbe 10 f1		    djnz Mult32_Loop 
0fc0 41			    ld b,c 
0fc1 4f			    ld c,a 
0fc2 c9			    ret 
0fc3			 
0fc3			 
0fc3			 
0fc3			; 
0fc3			; Multiply 8-bit values 
0fc3			; In:  Multiply H with E 
0fc3			; Out: HL = result 
0fc3			; 
0fc3			Mult8: 
0fc3 16 00		    ld d,0 
0fc5 6a			    ld l,d 
0fc6 06 08		    ld b,8 
0fc8			Mult8_Loop: 
0fc8 29			    add hl,hl 
0fc9 30 01		    jr nc,Mult8_NoAdd 
0fcb 19			    add hl,de 
0fcc			Mult8_NoAdd: 
0fcc 10 fa		    djnz Mult8_Loop 
0fce c9			    ret 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			;;http://z80-heaven.wikidot.com/math 
0fcf			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fcf			; 
0fcf			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fcf			;     ld a,16        ;7 
0fcf			;     ld hl,0        ;10 
0fcf			;     jp $+5         ;10 
0fcf			;.DivLoop: 
0fcf			;       add hl,bc    ;-- 
0fcf			;       dec a        ;64 
0fcf			;       jr z,.DivLoopEnd        ;86 
0fcf			; 
0fcf			;       sla e        ;128 
0fcf			;       rl d         ;128 
0fcf			;       adc hl,hl    ;240 
0fcf			;       sbc hl,bc    ;240 
0fcf			;       jr nc,.DivLoop ;23|21 
0fcf			;       inc e        ;-- 
0fcf			;       jp .DivLoop+1 
0fcf			; 
0fcf			;.DivLoopEnd: 
0fcf			 
0fcf			;HL_Div_C: 
0fcf			;Inputs: 
0fcf			;     HL is the numerator 
0fcf			;     C is the denominator 
0fcf			;Outputs: 
0fcf			;     A is the remainder 
0fcf			;     B is 0 
0fcf			;     C is not changed 
0fcf			;     DE is not changed 
0fcf			;     HL is the quotient 
0fcf			; 
0fcf			;       ld b,16 
0fcf			;       xor a 
0fcf			;         add hl,hl 
0fcf			;         rla 
0fcf			;         cp c 
0fcf			;         jr c,$+4 
0fcf			;           inc l 
0fcf			;           sub c 
0fcf			;         djnz $-7 
0fcf			 
0fcf			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fcf			 
0fcf			addatohl: 
0fcf 85			    add   a, l    ; A = A+L 
0fd0 6f			    ld    l, a    ; L = A+L 
0fd1 8c			    adc   a, h    ; A = A+L+H+carry 
0fd2 95			    sub   l       ; A = H+carry 
0fd3 67			    ld    h, a    ; H = H+carry 
0fd4 c9			ret 
0fd5			 
0fd5			addatode: 
0fd5 83			    add   a, e    ; A = A+L 
0fd6 5f			    ld    e, a    ; L = A+L 
0fd7 8a			    adc   a, d    ; A = A+L+H+carry 
0fd8 93			    sub   e       ; A = H+carry 
0fd9 57			    ld    d, a    ; H = H+carry 
0fda c9			ret 
0fdb			 
0fdb			 
0fdb			addatobc: 
0fdb 81			    add   a, c    ; A = A+L 
0fdc 4f			    ld    c, a    ; L = A+L 
0fdd 88			    adc   a, b    ; A = A+L+H+carry 
0fde 91			    sub   c       ; A = H+carry 
0fdf 47			    ld    b, a    ; H = H+carry 
0fe0 c9			ret 
0fe1			 
0fe1			subafromhl: 
0fe1			   ; If A=0 do nothing 
0fe1			    ; Otherwise flip A's sign. Since 
0fe1			    ; the upper byte becomes -1, also 
0fe1			    ; substract 1 from H. 
0fe1 ed 44		    neg 
0fe3 ca ec 0f		    jp    z, Skip 
0fe6 25			    dec   h 
0fe7			     
0fe7			    ; Now add the low byte as usual 
0fe7			    ; Two's complement takes care of 
0fe7			    ; ensuring the result is correct 
0fe7 85			    add   a, l 
0fe8 6f			    ld    l, a 
0fe9 8c			    adc   a, h 
0fea 95			    sub   l 
0feb 67			    ld    h, a 
0fec			Skip: 
0fec c9				ret 
0fed			 
0fed			 
0fed			; compare hl and de 
0fed			; returns:  
0fed			; if hl = de, z=1, s=0, c0=0 
0fed			; if hl > de, z=0, s=0, c=0 
0fed			; if hl < de, z=0, s=1, c=1 
0fed			cmp16:	 
0fed b7				or a 
0fee ed 52			sbc hl,de 
0ff0 e0				ret po 
0ff1 7c				ld a,h 
0ff2 1f				rra 
0ff3 ee 40			xor 01000000B 
0ff5 37				scf 
0ff6 8f				adc a,a 
0ff7 c9				ret 
0ff8			 
0ff8			 
0ff8			; test if hl contains zero   - A is destroyed 
0ff8			 
0ff8			ishlzero:    
0ff8 b7				or a     ; reset flags 
0ff9 7c				ld a, h 
0ffa b5				or l        	 
0ffb			 
0ffb c9				ret 
0ffc			 
0ffc			 
0ffc			 
0ffc			 
0ffc			if FORTH_ENABLE_FLOATMATH 
0ffc			;include "float/bbcmath.z80" 
0ffc			include "float/lpfpcalc.asm" 
0ffc			endif 
0ffc			 
0ffc			 
0ffc			; eof 
0ffc			 
# End of file firmware_maths.asm
0ffc			include "firmware_strings.asm"   ; string handling  
0ffc			 
0ffc			 
0ffc			; TODO string len 
0ffc			; input text string, end on cr with zero term 
0ffc			; a offset into frame buffer to start prompt 
0ffc			; d is max length 
0ffc			; e is display size TODO 
0ffc			; c is current cursor position 
0ffc			; hl is ptr to where string will be stored 
0ffc			 
0ffc			 
0ffc			; TODO check limit of buffer for new inserts 
0ffc			; TODO check insert does not push beyond buffer 
0ffc			; TODO scroll in a limited display area 
0ffc			; TODO scroll whole screen on page wrap 
0ffc			 
0ffc			 
0ffc			; TODO handle KEY_PREVWORD 
0ffc			; TODO handle KEY_NEXTWORD 
0ffc			; TODO handle KEY_HOME 
0ffc			; TODO handle KEY_END 
0ffc			; TODO use LCD cursor? 
0ffc			 
0ffc 32 9f fd		input_str:    	ld (input_at_pos),a      ; save display position to start 
0fff 81					add c 
1000 32 9d fd				ld (input_at_cursor),a	; save draw pos of cursor 
1003 22 a2 fd				ld (input_start), hl     ; save ptr to buffer 
1006 79					ld a, c 
1007 cd cf 0f				call addatohl 
100a 22 a4 fd				ld (input_ptr), hl     ; save ptr to point under the cursor 
100d 7a					ld a,d 
100e 32 a1 fd			        ld (input_size), a       ; save length of input area 
1011 79					ld a, c 
1012 32 90 fd				ld (input_cursor),a      ; init cursor start position  
1015 7b					ld a,e 
1016 32 a0 fd			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
1019					 
1019					 
1019			 
1019			;		ld a,(input_ptr) 
1019			;		ld (input_under_cursor),a 	; save what is under the cursor 
1019			 
1019			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
1019					; init cursor shape if not set by the cin routines 
1019 21 fc fa				ld hl, cursor_shape 
101c 3e ff				ld a, 255 
101e 77					ld (hl), a 
101f 23					inc hl 
1020 3e 00				ld a, 0 
1022 77					ld (hl), a 
1023			 
1023 3e 0f				ld a, CUR_BLINK_RATE 
1025 32 9b fd				ld (input_cur_flash), a 
1028 3e 01				ld a, 1 
102a 32 9a fd				ld (input_cur_onoff),a 
102d			 
102d			;	if DEBUG_INPUT 
102d			;		push af 
102d			;		ld a, 'I' 
102d			;		ld (debug_mark),a 
102d			;		pop af 
102d			;		CALLMONITOR 
102d			;	endif 
102d			.is1:		; main entry loop 
102d			 
102d			 
102d			 
102d					; pause 1ms 
102d			 
102d 3e 01				ld a, 1 
102f cd c3 0c				call aDelayInMS 
1032			 
1032					; dec flash counter 
1032 3a 9b fd				ld a, (input_cur_flash) 
1035 3d					dec a 
1036 32 9b fd				ld (input_cur_flash), a 
1039 fe 00				cp 0 
103b 20 0d				jr nz, .nochgstate 
103d			 
103d			 
103d					; change state 
103d 3a 9a fd				ld a,(input_cur_onoff) 
1040 ed 44				neg 
1042 32 9a fd				ld (input_cur_onoff),a 
1045			 
1045			 
1045					; reset on change of state 
1045 3e 0f				ld a, CUR_BLINK_RATE 
1047 32 9b fd				ld (input_cur_flash), a 
104a			 
104a			.nochgstate: 
104a					 
104a					 
104a			 
104a					; display cursor  
104a			 
104a			;		ld hl, (input_start) 
104a			;		ld a, (input_cursor) 
104a			;		call addatohl 
104a			 
104a					; get char under cursor and replace with cursor 
104a 2a a4 fd		ld hl, (input_ptr) 
104d			;		ld a, (hl) 
104d			;		ld (input_under_cursor),a 
104d			;		ld a, '_' 
104d			;		ld (hl), a 
104d			 
104d					; display string 
104d			 
104d ed 5b a2 fd			ld de, (input_start) 
1051 3a 9f fd				ld a, (input_at_pos) 
1054 cd ae 0d				call str_at_display 
1057			;	        call update_display 
1057			 
1057					; find place to put the cursor 
1057			;		add h 
1057			;		ld l, display_row_1 
1057			;		sub l 
1057			; (input_at_pos) 
1057					;ld c, a 
1057			;		ld a, (input_cursor) 
1057			;		ld l, (input_at_pos) 
1057			;		;ld b, h 
1057			;		add l 
1057			;		ld (input_at_cursor),a 
1057					;ld l,h 
1057			 
1057			;		ld h, 0 
1057			;		ld l,(input_at_pos) 
1057			;		ld a, (input_cursor) 
1057			;		call addatohl 
1057			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
1057			;		call subafromhl 
1057			;		ld a,l 
1057			;		ld (input_at_cursor), a 
1057			 
1057				if DEBUG_INPUT 
1057					ld a, (hardware_diag) 
1057					cp 0 
1057					jr z, .skip_input_diag 
1057			 
1057					ld a,(input_at_pos) 
1057					ld hl, LFSRSeed 
1057					call hexout 
1057					ld a, (input_cursor) 
1057					ld hl, LFSRSeed+2 
1057					call hexout 
1057					ld a,(input_at_cursor) 
1057					ld hl, LFSRSeed+4 
1057					call hexout 
1057			 
1057					ld a,(input_cur_onoff) 
1057					ld hl, LFSRSeed+6 
1057					call hexout 
1057			 
1057					ld a,(input_cur_flash) 
1057					ld hl, LFSRSeed+8 
1057					call hexout 
1057			 
1057					ld a,(input_len) 
1057					ld hl, LFSRSeed+10 
1057					call hexout 
1057					ld hl, LFSRSeed+12 
1057					ld a, 0 
1057					ld (hl),a 
1057					ld a, display_row_4 
1057					ld de, LFSRSeed 
1057					call str_at_display 
1057					.skip_input_diag: 
1057				endif 
1057			 
1057					; decide on if we are showing the cursor this time round 
1057			 
1057 3a 9a fd				ld a, (input_cur_onoff) 
105a fe ff				cp 255 
105c 28 13				jr z, .skipcur 
105e			 
105e			 
105e 3a 9d fd				ld a,(input_at_cursor) 
1061 11 fc fa				ld de, cursor_shape 
1064 cd ae 0d				call str_at_display 
1067			 
1067					; save length of current input string 
1067 2a a2 fd				ld hl, (input_start) 
106a cd 2d 14				call strlenz 
106d 7d					ld a,l 
106e 32 95 fd				ld (input_len),a 
1071			 
1071			.skipcur: 
1071			 
1071 cd be 0d			        call update_display 
1074					 
1074			 
1074			 
1074					; wait 
1074				 
1074					; TODO loop without wait to flash the cursor and char under cursor	 
1074 cd 7d 7a				call cin    ; _wait 
1077			 
1077 fe 00				cp 0 
1079 ca 2d 10				jp z, .is1 
107c			 
107c					; get ptr to char to input into 
107c			 
107c 4f					ld c,a 
107d 2a a2 fd				ld hl, (input_start) 
1080 3a 90 fd				ld a, (input_cursor) 
1083 cd cf 0f				call addatohl 
1086 22 a4 fd				ld (input_ptr), hl 
1089 79					ld a,c 
108a			 
108a					; replace char under cursor 
108a			 
108a			;		ld hl, (input_ptr) 
108a			;		ld a, (input_under_cursor) 	; get what is under the cursor 
108a			;		ld (hl), a 
108a			 
108a			;	if DEBUG_INPUT 
108a			;		push af 
108a			;		ld a, 'i' 
108a			;		ld (debug_mark),a 
108a			;		pop af 
108a			;		CALLMONITOR 
108a			;	endif 
108a fe 0e				cp KEY_HOME 
108c 20 0e				jr nz, .iske 
108e			 
108e 3a 9f fd				ld a, (input_at_pos) 
1091 32 9d fd				ld (input_at_cursor),a 
1094 3e 00				ld a, 0 
1096 32 90 fd				ld (input_cursor), a 
1099 c3 2d 10				jp .is1 
109c					 
109c fe 0f		.iske:		cp KEY_END 
109e 20 03				jr nz, .isknw 
10a0 c3 2d 10				jp .is1 
10a3			 
10a3 fe 06		.isknw:		cp KEY_NEXTWORD 
10a5 20 1b				jr nz, .iskpw 
10a7			 
10a7 2a a4 fd		.isknwm:	ld hl, (input_ptr) 
10aa 7e					ld a,(hl)	 
10ab fe 00				cp 0 
10ad ca 2d 10				jp z, .is1    ; end of string 
10b0 fe 20				cp ' ' 
10b2 ca 2d 10				jp z, .is1    ; end of word 
10b5 23					inc hl 
10b6 22 a4 fd				ld (input_ptr), hl 
10b9 3a 9d fd				ld a, (input_at_cursor) 
10bc 3c					inc a 
10bd 32 9d fd				ld (input_at_cursor), a 
10c0 18 e5				jr .isknwm 
10c2			 
10c2 fe 07		.iskpw:		cp KEY_PREVWORD 
10c4 20 1b				jr nz, .iskl 
10c6			.iskpwm:	 
10c6 2a a4 fd				ld hl, (input_ptr) 
10c9 7e					ld a,(hl)	 
10ca fe 00				cp 0  
10cc ca 2d 10				jp z, .is1    ; end of string 
10cf fe 20				cp ' ' 
10d1 ca 2d 10				jp z, .is1    ; end of word 
10d4 2b					dec hl 
10d5 22 a4 fd				ld (input_ptr), hl 
10d8 3a 9d fd				ld a, (input_at_cursor) 
10db 3d					dec a 
10dc 32 9d fd				ld (input_at_cursor), a 
10df 18 e5				jr .iskpwm 
10e1			 
10e1			 
10e1 fe 0b		.iskl:		cp KEY_LEFT 
10e3 20 27				jr nz, .isk1 
10e5			 
10e5 3a 90 fd				ld a, (input_cursor) 
10e8			 
10e8 fe 00				cp 0 
10ea ca 2d 10				jp z, .is1 		; at start of line to ignore  
10ed			 
10ed 3d					dec  a 		; TODO check underflow 
10ee 32 90 fd				ld (input_cursor), a 
10f1			 
10f1 2a a4 fd				ld hl, (input_ptr) 
10f4 2b					dec hl 
10f5 22 a4 fd				ld (input_ptr), hl 
10f8					 
10f8 3a 9d fd				ld a, (input_at_cursor) 
10fb 3d					dec a 
10fc 32 9d fd				ld (input_at_cursor), a 
10ff			 
10ff 3e 01				ld a, 1		; show cursor moving 
1101 32 9a fd				ld (input_cur_onoff),a 
1104 3e 0f				ld a, CUR_BLINK_RATE 
1106 32 9b fd				ld (input_cur_flash), a 
1109			 
1109 c3 2d 10				jp .is1 
110c			 
110c fe 0c		.isk1:		cp KEY_RIGHT 
110e 20 2a				jr nz, .isk2 
1110			 
1110 3a 95 fd				ld a,(input_len)		; TODO BUG why cant i load e direct? 
1113 5f					ld e,a 
1114 3a 90 fd				ld a, (input_cursor) 
1117 bb					cp e 
1118 ca 2d 10				jp z, .is1		; at the end of string so dont go right 
111b			 
111b 3c					inc  a 		; TODO check overflow 
111c 32 90 fd				ld (input_cursor), a 
111f			 
111f 3a 9d fd				ld a, (input_at_cursor) 
1122 3c					inc a 
1123 32 9d fd				ld (input_at_cursor), a 
1126			 
1126 2a a4 fd				ld hl, (input_ptr) 
1129 23					inc hl 
112a 22 a4 fd				ld (input_ptr), hl 
112d			 
112d 3e 01				ld a, 1		; show cursor moving 
112f 32 9a fd				ld (input_cur_onoff),a 
1132 3e 0f				ld a, CUR_BLINK_RATE 
1134 32 9b fd				ld (input_cur_flash), a 
1137			 
1137 c3 2d 10				jp .is1 
113a			 
113a fe 05		.isk2:		cp KEY_UP 
113c			 
113c 20 26				jr nz, .isk3 
113e			 
113e					; swap last command with the current on 
113e			 
113e					; move cursor to start of string 
113e 2a a2 fd				ld hl, (input_start) 
1141 22 a4 fd				ld (input_ptr), hl 
1144			 
1144 3a 9f fd				ld a, (input_at_pos) 
1147 32 9d fd				ld (input_at_cursor), a 
114a			 
114a 3e 00				ld a, 0 
114c 32 90 fd				ld (input_cursor), a 
114f					 
114f					; swap input and last command buffers 
114f			 
114f 21 23 f4				ld hl, os_cli_cmd 
1152 11 22 f5				ld de, os_last_cmd 
1155 06 ff				ld b, 255 
1157 7e			.swap1:		ld a, (hl) 
1158 4f					ld c,a 
1159 1a					ld a, (de) 
115a 77					ld (hl), a 
115b 79					ld a,c 
115c 12					ld (de),a 
115d 23					inc hl 
115e 13					inc de 
115f 10 f6				djnz .swap1 
1161			 
1161			 
1161			 
1161			 
1161			 
1161 c3 2d 10				jp .is1 
1164			 
1164 fe 08		.isk3:		cp KEY_BS 
1166 20 3c				jr nz, .isk4 
1168			 
1168 3a 90 fd				ld a, (input_cursor) 
116b			 
116b fe 00				cp 0 
116d ca 2d 10				jp z, .is1 		; at start of line to ignore  
1170			 
1170 3d					dec  a 		; TODO check underflow 
1171 32 90 fd				ld (input_cursor), a 
1174			 
1174					; hl is source 
1174					; de needs to be source - 1 
1174			 
1174			;		ld a, 0 
1174			;		dec hl 
1174			;		ld (hl), a 
1174			 
1174 2a a4 fd				ld hl, (input_ptr) 
1177 2b					dec hl 
1178 22 a4 fd				ld (input_ptr), hl 
117b			 
117b					; shift all data 
117b			 
117b e5					push hl 
117c 23					inc hl 
117d d1					pop de 
117e 3a 95 fd				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
1181 4f					ld c,a 
1182 06 00				ld b,0 
1184 ed b0				ldir  
1186			 
1186			 
1186			 
1186			 
1186 3a 9d fd				ld a, (input_at_cursor) 
1189 3d					dec a 
118a 32 9d fd				ld (input_at_cursor), a 
118d			 
118d			 
118d 3e 01				ld a, 1		; show cursor moving 
118f 32 9a fd				ld (input_cur_onoff),a 
1192 3e 0f				ld a, CUR_BLINK_RATE 
1194 32 9b fd				ld (input_cur_flash), a 
1197			 
1197					; remove char 
1197 3a 9d fd				ld a, (input_at_cursor) 
119a 3c					inc a 
119b 11 25 12				ld de,.iblank 
119e cd ae 0d				call str_at_display 
11a1			 
11a1 c3 2d 10				jp .is1 
11a4			 
11a4 fe 0d		.isk4:		cp KEY_CR 
11a6 28 6c				jr z, .endinput 
11a8			 
11a8					; else add the key press to the end 
11a8			 
11a8 4f					ld c, a			; save key pressed 
11a9			 
11a9 7e					ld a,(hl)		; get what is currently under char 
11aa			 
11aa fe 00				cp 0			; we are at the end of the string 
11ac 20 2f				jr nz, .onchar 
11ae					 
11ae					; add a char to the end of the string 
11ae				 
11ae 71					ld (hl),c 
11af 23					inc hl 
11b0			;		ld a,' ' 
11b0			;		ld (hl),a 
11b0			;		inc hl 
11b0 3e 00				ld a,0 
11b2 77					ld (hl),a 
11b3 2b					dec hl 
11b4			 
11b4 3a 90 fd				ld a, (input_cursor) 
11b7 3c					inc a				; TODO check max string length and scroll  
11b8 32 90 fd				ld (input_cursor), a		; inc cursor pos 
11bb							 
11bb 3a 9d fd				ld a, (input_at_cursor) 
11be 3c					inc a 
11bf 32 9d fd				ld (input_at_cursor), a 
11c2			 
11c2 2a a4 fd				ld hl, (input_ptr) 
11c5 23					inc hl 
11c6 22 a4 fd				ld (input_ptr), hl 
11c9			 
11c9 2a a4 fd				ld hl, (input_ptr) 
11cc 23					inc hl 
11cd 22 a4 fd				ld (input_ptr), hl 
11d0			;	if DEBUG_INPUT 
11d0			;		push af 
11d0			;		ld a, '+' 
11d0			;		ld (debug_mark),a 
11d0			;		pop af 
11d0			;		CALLMONITOR 
11d0			;	endif 
11d0 3e 01				ld a, 1		; show cursor moving 
11d2 32 9a fd				ld (input_cur_onoff),a 
11d5 3e 0f				ld a, CUR_BLINK_RATE 
11d7 32 9b fd				ld (input_cur_flash), a 
11da c3 2d 10				jp .is1 
11dd					 
11dd			 
11dd			 
11dd					; if on a char then insert 
11dd			.onchar: 
11dd			 
11dd					; TODO over flow check: make sure insert does not blow out buffer 
11dd			 
11dd					; need to do some maths to use lddr 
11dd			 
11dd e5					push hl   ; save char pos 
11de c5					push bc 
11df			 
11df 2a a2 fd				ld hl, (input_start) 
11e2 3a 95 fd				ld a, (input_len) 
11e5 cd cf 0f				call addatohl  		; end of string 
11e8 23					inc hl 
11e9 23					inc hl		; past zero term 
11ea e5					push hl 
11eb 23					inc hl 
11ec e5					push hl  
11ed			 
11ed								; start and end of lddr set, now how much to move? 
11ed			 
11ed							 
11ed 3a 90 fd				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11f0 47					ld b,a 
11f1 3a 95 fd				ld a,(input_len) 
11f4 5f					ld e,a 
11f5 90					sub b 
11f6 3c					inc a		;?? 
11f7 3c					inc a		;?? 
11f8 3c					inc a		;?? 
11f9			 
11f9 06 00				ld b,0 
11fb 4f					ld c,a 
11fc			 
11fc				if DEBUG_INPUT 
11fc					push af 
11fc					ld a, 'i' 
11fc					ld (debug_mark),a 
11fc					pop af 
11fc			;		CALLMONITOR 
11fc				endif 
11fc d1					pop de 
11fd e1					pop hl 
11fe				if DEBUG_INPUT 
11fe					push af 
11fe					ld a, 'I' 
11fe					ld (debug_mark),a 
11fe					pop af 
11fe			;		CALLMONITOR 
11fe				endif 
11fe ed b8				lddr 
1200				 
1200			 
1200			 
1200					; TODO have a key for insert/overwrite mode???? 
1200 c1					pop bc 
1201 e1					pop hl 
1202 71					ld (hl), c		; otherwise overwrite current char 
1203					 
1203			 
1203			 
1203			 
1203 3a 90 fd				ld a, (input_cursor) 
1206 3c					inc  a 		; TODO check overflow 
1207 32 90 fd				ld (input_cursor), a 
120a			 
120a 3a 9d fd				ld a, (input_at_cursor) 
120d 3c					inc a 
120e 32 9d fd				ld (input_at_cursor), a 
1211			 
1211 c3 2d 10				jp .is1 
1214			 
1214			.endinput:	; TODO look for end of string 
1214			 
1214					; add trailing space for end of token 
1214			 
1214 2a a2 fd				ld hl, (input_start) 
1217 3a 95 fd				ld a,(input_len) 
121a cd cf 0f				call addatohl 
121d 3e 20				ld a, ' ' 
121f 77					ld (hl),a 
1220					; TODO eof of parse marker 
1220			 
1220 23					inc hl 
1221 3e 00				ld a, 0 
1223 77					ld (hl),a 
1224			 
1224			 
1224 c9					ret 
1225			 
1225 .. 00		.iblank: db " ",0 
1227			 
1227			 
1227 32 9f fd		input_str_prev:	ld (input_at_pos), a 
122a 22 a2 fd				ld (input_start), hl 
122d 3e 01				ld a,1			; add cursor 
122f 77					ld (hl),a 
1230 23					inc hl 
1231 3e 00				ld a,0 
1233 77					ld (hl),a 
1234 22 a4 fd				ld (input_ptr), hl 
1237 7a					ld a,d 
1238 32 a1 fd				ld (input_size), a 
123b 3e 00				ld a,0 
123d 32 90 fd				ld (input_cursor),a 
1240			.instr1:	 
1240			 
1240					; TODO do block cursor 
1240					; TODO switch cursor depending on the modifer key 
1240			 
1240					; update cursor shape change on key hold 
1240			 
1240 2a a4 fd				ld hl, (input_ptr) 
1243 2b					dec hl 
1244 3a fc fa				ld a,(cursor_shape) 
1247 77					ld (hl), a 
1248			 
1248					; display entered text 
1248 3a 9f fd				ld a,(input_at_pos) 
124b cd 41 78		            	CALL fLCD_Pos       ;Position cursor to location in A 
124e ed 5b a2 fd	            	LD   de, (input_start) 
1252 cd 63 78		            	CALL fLCD_Str       ;Display string pointed to by DE 
1255			 
1255 cd 7d 7a				call cin 
1258 fe 00				cp 0 
125a 28 e4				jr z, .instr1 
125c			 
125c					; proecess keyboard controls first 
125c			 
125c 2a a4 fd				ld hl,(input_ptr) 
125f			 
125f fe 0d				cp KEY_CR	 ; pressing enter ends input 
1261 28 5a				jr z, .instrcr 
1263			 
1263 fe 08				cp KEY_BS 	; back space 
1265 20 0f				jr nz, .instr2 
1267					; process back space 
1267			 
1267					; TODO stop back space if at start of string 
1267 2b					dec hl 
1268 2b					dec hl ; to over write cursor 
1269 3a fc fa				ld a,(cursor_shape) 
126c					;ld a,0 
126c 77					ld (hl),a 
126d 23					inc hl 
126e 3e 20				ld a," " 
1270 77					ld (hl),a 
1271 22 a4 fd				ld (input_ptr),hl 
1274					 
1274			 
1274 18 ca				jr .instr1 
1276			 
1276 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1278 20 06				jr nz, .instr3 
127a 2b					dec hl 
127b 22 a4 fd				ld (input_ptr),hl 
127e 18 c0				jr .instr1 
1280				 
1280 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
1282 20 06				jr nz, .instr4 
1284 23					inc hl 
1285 22 a4 fd				ld (input_ptr),hl 
1288 18 b6				jr .instr1 
128a			 
128a fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
128c 20 06				jr nz, .instr5 
128e 2b					dec hl 
128f 22 a4 fd				ld (input_ptr),hl 
1292 18 ac				jr .instr1 
1294			 
1294 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1296 20 06				jr nz, .instr6 
1298 2b					dec hl 
1299 22 a4 fd				ld (input_ptr),hl 
129c 18 a2				jr .instr1 
129e fe 05		.instr6:        cp KEY_UP      ; recall last command 
12a0 20 0b				jr nz, .instrnew 
12a2			 
12a2 21 fc f0			ld hl, scratch 
12a5 11 22 f5			ld de, os_last_cmd 
12a8 cd c6 12			call strcpy 
12ab 18 93				jr .instr1 
12ad			 
12ad			 
12ad			.instrnew:	; no special key pressed to see if we have room to store it 
12ad			 
12ad					; TODO do string size test 
12ad			 
12ad 2b					dec hl ; to over write cursor 
12ae 77					ld (hl),a 
12af 23					inc hl 
12b0 3a fc fa				ld a,(cursor_shape) 
12b3 77					ld (hl),a 
12b4 23					inc hl 
12b5 3e 00				ld a,0 
12b7 77					ld (hl),a 
12b8			 
12b8 22 a4 fd				ld (input_ptr),hl 
12bb					 
12bb 18 83				jr .instr1 
12bd 2b			.instrcr:	dec hl		; remove cursor 
12be 3e 20				ld a,' '	; TODO add a trailing space for safety 
12c0 77					ld (hl),a 
12c1 23					inc hl 
12c2 3e 00				ld a,0 
12c4 77					ld (hl),a 
12c5			 
12c5			 
12c5					; if at end of line scroll up    
12c5					; TODO detecting only end of line 4 for scroll up  
12c5			 
12c5					;ld   
12c5			 
12c5 c9					ret 
12c6			 
12c6			 
12c6			; strcpy hl = dest, de source 
12c6			 
12c6 1a			strcpy:   LD   A, (DE)        ;Get character from string 
12c7 b7			            OR   A              ;Null terminator? 
12c8 c8			            RET  Z              ;Yes, so finished 
12c9 1a					ld a,(de) 
12ca 77					ld (hl),a 
12cb 13			            INC  DE             ;Point to next character 
12cc 23					inc hl 
12cd 18 f7		            JR   strcpy       ;Repeat 
12cf c9					ret 
12d0			 
12d0			 
12d0			; TODO string_at  
12d0			; pass string which starts with lcd offset address and then null term string 
12d0			 
12d0			; TODO string to dec 
12d0			; TODO string to hex 
12d0			; TODO byte to string hex 
12d0			; TODO byte to string dec 
12d0			 
12d0			 
12d0			 
12d0			; from z80uartmonitor 
12d0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12d0			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
12d0			; pass hl for where to put the text 
12d0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12d0 c5			hexout:	PUSH BC 
12d1 f5					PUSH AF 
12d2 47					LD B, A 
12d3					; Upper nybble 
12d3 cb 3f				SRL A 
12d5 cb 3f				SRL A 
12d7 cb 3f				SRL A 
12d9 cb 3f				SRL A 
12db cd eb 12				CALL tohex 
12de 77					ld (hl),a 
12df 23					inc hl	 
12e0					 
12e0					; Lower nybble 
12e0 78					LD A, B 
12e1 e6 0f				AND 0FH 
12e3 cd eb 12				CALL tohex 
12e6 77					ld (hl),a 
12e7 23					inc hl	 
12e8					 
12e8 f1					POP AF 
12e9 c1					POP BC 
12ea c9					RET 
12eb					 
12eb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12eb			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
12eb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12eb			tohex: 
12eb e5					PUSH HL 
12ec d5					PUSH DE 
12ed 16 00				LD D, 0 
12ef 5f					LD E, A 
12f0 21 f8 12				LD HL, .DATA 
12f3 19					ADD HL, DE 
12f4 7e					LD A, (HL) 
12f5 d1					POP DE 
12f6 e1					POP HL 
12f7 c9					RET 
12f8			 
12f8			.DATA: 
12f8 30					DEFB	30h	; 0 
12f9 31					DEFB	31h	; 1 
12fa 32					DEFB	32h	; 2 
12fb 33					DEFB	33h	; 3 
12fc 34					DEFB	34h	; 4 
12fd 35					DEFB	35h	; 5 
12fe 36					DEFB	36h	; 6 
12ff 37					DEFB	37h	; 7 
1300 38					DEFB	38h	; 8 
1301 39					DEFB	39h	; 9 
1302 41					DEFB	41h	; A 
1303 42					DEFB	42h	; B 
1304 43					DEFB	43h	; C 
1305 44					DEFB	44h	; D 
1306 45					DEFB	45h	; E 
1307 46					DEFB	46h	; F 
1308			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1308			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1308			;;    subtract $30, if result > 9 then subtract $7 more 
1308			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1308			atohex: 
1308 d6 30				SUB $30 
130a fe 0a				CP 10 
130c f8					RET M		; If result negative it was 0-9 so we're done 
130d d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
130f c9					RET		 
1310			 
1310			 
1310			 
1310			 
1310			; Get 2 ASCII characters as hex byte from pointer in hl 
1310			 
1310			BYTERD: 
1310 16 00			LD	D,00h		;Set up 
1312 cd 1a 13			CALL	HEXCON		;Get byte and convert to hex 
1315 87				ADD	A,A		;First nibble so 
1316 87				ADD	A,A		;multiply by 16 
1317 87				ADD	A,A		; 
1318 87				ADD	A,A		; 
1319 57				LD	D,A		;Save hi nibble in D 
131a			HEXCON: 
131a 7e				ld a, (hl)		;Get next chr 
131b 23				inc hl 
131c d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
131e fe 0a			CP	00Ah		;Is it 0-9 ? 
1320 38 02			JR	C,NALPHA	;If so miss next bit 
1322 d6 07			SUB	007h		;Else convert alpha 
1324			NALPHA: 
1324 b2				OR	D		;Add hi nibble back 
1325 c9				RET			; 
1326			 
1326			 
1326			; 
1326			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1326			; Since the routines get_byte and therefore get_nibble are called, only valid 
1326			; characters (0-9a-f) are accepted. 
1326			; 
1326			;get_word        push    af 
1326			;                call    get_byte        ; Get the upper byte 
1326			;                ld      h, a 
1326			;                call    get_byte        ; Get the lower byte 
1326			;                ld      l, a 
1326			;                pop     af 
1326			;                ret 
1326			; 
1326			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1326			; the routine get_nibble is used only valid characters are accepted - the  
1326			; input routine only accepts characters 0-9a-f. 
1326			; 
1326 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1327 7e					ld a,(hl) 
1328 23					inc hl 
1329 cd 4e 13		                call    nibble2val      ; Get upper nibble 
132c cb 07		                rlc     a 
132e cb 07		                rlc     a 
1330 cb 07		                rlc     a 
1332 cb 07		                rlc     a 
1334 47			                ld      b, a            ; Save upper four bits 
1335 7e					ld a,(hl) 
1336 cd 4e 13		                call    nibble2val      ; Get lower nibble 
1339 b0			                or      b               ; Combine both nibbles 
133a c1			                pop     bc              ; Restore B (and C) 
133b c9			                ret 
133c			; 
133c			; Get a hexadecimal digit from the serial line. This routine blocks until 
133c			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
133c			; to the serial line interface. The lower 4 bits of A contain the value of  
133c			; that particular digit. 
133c			; 
133c			;get_nibble      ld a,(hl)           ; Read a character 
133c			;                call    to_upper        ; Convert to upper case 
133c			;                call    is_hex          ; Was it a hex digit? 
133c			;                jr      nc, get_nibble  ; No, get another character 
133c			 ;               call    nibble2val      ; Convert nibble to value 
133c			 ;               call    print_nibble 
133c			 ;               ret 
133c			; 
133c			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
133c			; A valid hexadecimal digit is denoted by a set C flag. 
133c			; 
133c			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
133c			;                ret     nc              ; Yes 
133c			;                cp      '0'             ; Less than '0'? 
133c			;                jr      nc, is_hex_1    ; No, continue 
133c			;                ccf                     ; Complement carry (i.e. clear it) 
133c			;                ret 
133c			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
133c			;                ret     c               ; Yes 
133c			;                cp      'A'             ; Less than 'A'? 
133c			;                jr      nc, is_hex_2    ; No, continue 
133c			;                ccf                     ; Yes - clear carry and return 
133c			;                ret 
133c			;is_hex_2        scf                     ; Set carry 
133c			;                ret 
133c			; 
133c			; Convert a single character contained in A to upper case: 
133c			; 
133c fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
133e d8			                ret     c 
133f fe 7b		                cp      'z' + 1         ; > 'z'? 
1341 d0			                ret     nc              ; Nothing to do, either 
1342 e6 5f		                and     $5f             ; Convert to upper case 
1344 c9			                ret 
1345			 
1345			 
1345			to_lower: 
1345			 
1345			   ; if char is in [A-Z] make it lower case 
1345			 
1345			   ; enter : a = char 
1345			   ; exit  : a = lower case char 
1345			   ; uses  : af 
1345			 
1345 fe 41		   cp 'A' 
1347 d8			   ret c 
1348			    
1348 fe 5b		   cp 'Z'+1 
134a d0			   ret nc 
134b			    
134b f6 20		   or $20 
134d c9			   ret 
134e			 
134e			; 
134e			; Expects a hexadecimal digit (upper case!) in A and returns the 
134e			; corresponding value in A. 
134e			; 
134e fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1350 38 02		                jr      c, nibble2val_1 ; Yes 
1352 d6 07		                sub     7               ; Adjust for A-F 
1354 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1356 e6 0f		                and     $f              ; Only return lower 4 bits 
1358 c9			                ret 
1359			; 
1359			; Print_nibble prints a single hex nibble which is contained in the lower  
1359			; four bits of A: 
1359			; 
1359			;print_nibble    push    af              ; We won't destroy the contents of A 
1359			;                and     $f              ; Just in case... 
1359			;                add     a, '0'             ; If we have a digit we are done here. 
1359			;                cp      '9' + 1         ; Is the result > 9? 
1359			;                jr      c, print_nibble_1 
1359			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1359			;print_nibble_1  call    putc            ; Print the nibble and 
1359			;                pop     af              ; restore the original value of A 
1359			;                ret 
1359			;; 
1359			;; Send a CR/LF pair: 
1359			; 
1359			;crlf            push    af 
1359			;                ld      a, cr 
1359			;                call    putc 
1359			;                ld      a, lf 
1359			;                call    putc 
1359			;                pop     af 
1359			;                ret 
1359			; 
1359			; Print_word prints the four hex digits of a word to the serial line. The  
1359			; word is expected to be in HL. 
1359			; 
1359			;print_word      push    hl 
1359			;                push    af 
1359			;                ld      a, h 
1359			;                call    print_byte 
1359			;                ld      a, l 
1359			;                call    print_byte 
1359			;                pop     af 
1359			;                pop     hl 
1359			;                ret 
1359			; 
1359			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1359			; The byte to be printed is expected to be in A. 
1359			; 
1359			;print_byte      push    af              ; Save the contents of the registers 
1359			;                push    bc 
1359			;                ld      b, a 
1359			;                rrca 
1359			;                rrca 
1359			;                rrca 
1359			;                rrca 
1359			;                call    print_nibble    ; Print high nibble 
1359			;                ld      a, b 
1359			;                call    print_nibble    ; Print low nibble 
1359			;                pop     bc              ; Restore original register contents 
1359			;                pop     af 
1359			;                ret 
1359			 
1359			 
1359			 
1359			 
1359			 
1359			fourehexhl:  
1359 7e				ld a,(hl) 
135a cd 08 13			call atohex 
135d cb 3f				SRL A 
135f cb 3f				SRL A 
1361 cb 3f				SRL A 
1363 cb 3f				SRL A 
1365 47				ld b, a 
1366 23				inc hl 
1367 7e				ld a,(hl) 
1368 23				inc hl 
1369 cd 08 13			call atohex 
136c 80				add b 
136d 57				ld d,a 
136e 7e				ld a,(hl) 
136f cd 08 13			call atohex 
1372 cb 3f				SRL A 
1374 cb 3f				SRL A 
1376 cb 3f				SRL A 
1378 cb 3f				SRL A 
137a 47				ld b, a 
137b 23				inc hl 
137c 7e				ld a,(hl) 
137d 23				inc hl 
137e cd 08 13			call atohex 
1381 80				add b 
1382 5f				ld e, a 
1383 d5				push de 
1384 e1				pop hl 
1385 c9				ret 
1386			 
1386			; pass hl. returns z set if the byte at hl is a digit 
1386			;isdigithl:  
1386			;	push bc 
1386			;	ld a,(hl) 
1386			;	cp ':' 
1386			;	jr nc, .isdf 		; > 
1386			;	cp '0' 
1386			;	jr c, .isdf		; < 
1386			; 
1386			;	; TODO find a better way to set z 
1386			; 
1386			;	ld b,a 
1386			;	cp b 
1386			;	pop bc 
1386			;	ret 
1386			; 
1386			;.isdf:	; not digit so clear z 
1386			; 
1386			;	; TODO find a better way to unset z 
1386			; 
1386			;	ld b,a 
1386			;	inc b 
1386			;	cp b 
1386			; 
1386			;	pop bc 
1386			;	ret 
1386				 
1386				 
1386			 
1386			 
1386			; pass hl as the four byte address to load 
1386			 
1386			get_word_hl:  
1386 e5				push hl 
1387 cd 26 13			call get_byte 
138a				 
138a 47				ld b, a 
138b			 
138b e1				pop hl 
138c 23				inc hl 
138d 23				inc hl 
138e			 
138e			; TODO not able to handle a-f  
138e 7e				ld a,(hl) 
138f			;	;cp ':' 
138f			;	cp 'g' 
138f			;	jr nc, .single_byte_hl 		; > 
138f			;	cp 'G' 
138f			;	jr nc, .single_byte_hl 		; > 
138f			;	cp '0' 
138f			;	jr c, .single_byte_hl		; < 
138f			 
138f				;call isdigithl 
138f fe 00			cp 0 
1391 28 06			jr z, .single_byte_hl 
1393			 
1393			.getwhln:   ; hex word so get next byte 
1393			 
1393 cd 26 13			call get_byte 
1396 6f				ld l, a 
1397 60				ld h,b 
1398 c9				ret 
1399 68			.single_byte_hl:   ld l,b 
139a 26 00				ld h,0 
139c c9					ret 
139d			 
139d			 
139d			 
139d			 
139d 21 f2 1d			ld hl,asc+1 
13a0			;	ld a, (hl) 
13a0			;	call nibble2val 
13a0 cd 26 13			call get_byte 
13a3			 
13a3			;	call fourehexhl 
13a3 32 30 f1			ld (scratch+52),a 
13a6				 
13a6 21 2e f1			ld hl,scratch+50 
13a9 22 1f f4			ld (os_cur_ptr),hl 
13ac			 
13ac c9				ret 
13ad			 
13ad			 
13ad			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
13ad			 
13ad			; Decimal Unsigned Version 
13ad			 
13ad			;Number in a to decimal ASCII 
13ad			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
13ad			;Example: display a=56 as "056" 
13ad			;input: a = number 
13ad			;Output: a=0,value of a in the screen 
13ad			;destroys af,bc (don't know about hl and de) 
13ad			DispAToASCII: 
13ad 0e 9c			ld	c,-100 
13af cd b9 13			call	.Na1 
13b2 0e f6			ld	c,-10 
13b4 cd b9 13			call	.Na1 
13b7 0e ff			ld	c,-1 
13b9 06 2f		.Na1:	ld	b,'0'-1 
13bb 04			.Na2:	inc	b 
13bc 81				add	a,c 
13bd 38 fc			jr	c,.Na2 
13bf 91				sub	c		;works as add 100/10/1 
13c0 f5				push af		;safer than ld c,a 
13c1 78				ld	a,b		;char is in b 
13c2			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
13c2 f1				pop af		;safer than ld a,c 
13c3 c9				ret 
13c4			 
13c4			; Decimal Signed Version 
13c4			 
13c4			; DispA 
13c4			; -------------------------------------------------------------- 
13c4			; Converts a signed integer value to a zero-terminated ASCII 
13c4			; string representative of that value (using radix 10). 
13c4			; -------------------------------------------------------------- 
13c4			; INPUTS: 
13c4			;     HL     Value to convert (two's complement integer). 
13c4			;     DE     Base address of string destination. (pointer). 
13c4			; -------------------------------------------------------------- 
13c4			; OUTPUTS: 
13c4			;     None 
13c4			; -------------------------------------------------------------- 
13c4			; REGISTERS/MEMORY DESTROYED 
13c4			; AF HL 
13c4			; -------------------------------------------------------------- 
13c4			 
13c4			;DispHLToASCII: 
13c4			;   push    de 
13c4			;   push    bc 
13c4			; 
13c4			;; Detect sign of HL. 
13c4			;    bit    7, h 
13c4			;    jr     z, ._DoConvert 
13c4			; 
13c4			;; HL is negative. Output '-' to string and negate HL. 
13c4			;    ld     a, '-' 
13c4			;    ld     (de), a 
13c4			;    inc    de 
13c4			; 
13c4			;; Negate HL (using two's complement) 
13c4			;    xor    a 
13c4			;    sub    l 
13c4			;    ld     l, a 
13c4			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
13c4			;    sbc    a, h 
13c4			;    ld     h, a 
13c4			; 
13c4			;; Convert HL to digit characters 
13c4			;._DoConvert: 
13c4			;    ld     b, 0     ; B will count character length of number 
13c4			;-   ld     a, 10 
13c4			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
13c4			;    push   af 
13c4			;    inc    b 
13c4			;    ld     a, h 
13c4			;    or     l 
13c4			;    jr     nz, - 
13c4			; 
13c4			;; Retrieve digits from stack 
13c4			;-   pop    af 
13c4			;    or     $30 
13c4			;    ld     (de), a 
13c4			;    inc    de 
13c4			;    djnz   - 
13c4			; 
13c4			;; Terminate string with NULL 
13c4			;    xor    a 
13c4			;    ld     (de), a 
13c4			; 
13c4			;    pop    bc 
13c4			;    pop    de 
13c4			;    ret 
13c4			 
13c4			;Comments 
13c4			; 
13c4			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
13c4			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
13c4			;    Note that the output string will not be fixed-width. 
13c4			; 
13c4			;Example Usage 
13c4			; 
13c4			;    ld    hl, -1004 
13c4			;    ld    de, OP1 
13c4			;    call  DispA 
13c4			;    ld    hl, OP1 
13c4			;    syscall  PutS 
13c4			 
13c4			 
13c4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
13c4			 
13c4			 
13c4			;Converts an ASCII string to an unsigned 16-bit integer 
13c4			;Quits when it reaches a non-decimal digit 
13c4			 
13c4			string_to_uint16: 
13c4			atoui_16: 
13c4			;Input: 
13c4			;     DE points to the string 
13c4			;Outputs: 
13c4			;     HL is the result 
13c4			;     A is the 8-bit value of the number 
13c4			;     DE points to the byte after the number 
13c4			;Destroys: 
13c4			;     BC 
13c4			;       if the string is non-empty, BC is HL/10 
13c4			;Size:  24 bytes 
13c4			;Speed: 42+d(104+{0,9}) 
13c4			;       d is the number of digits in the number 
13c4			;       max is 640 cycles for a 5 digit number 
13c4			;Assuming no leading zeros: 
13c4			;1 digit:  146cc 
13c4			;2 digit:  250cc 
13c4			;3 digit:  354cc or 363cc (avg: 354.126cc) 
13c4			;4 digit:  458cc or 467cc (avg: 458.27cc) 
13c4			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
13c4			;avg: 544.81158447265625cc (544+13297/16384) 
13c4			;=============================================================== 
13c4 21 00 00		  ld hl,0 
13c7			.u16a: 
13c7 1a			  ld a,(de) 
13c8 d6 30		  sub 30h 
13ca fe 0a		  cp 10 
13cc d0			  ret nc 
13cd 13			  inc de 
13ce 44			  ld b,h 
13cf 4d			  ld c,l 
13d0 29			  add hl,hl 
13d1 29			  add hl,hl 
13d2 09			  add hl,bc 
13d3 29			  add hl,hl 
13d4 85			  add a,l 
13d5 6f			  ld l,a 
13d6 30 ef		  jr nc,.u16a 
13d8 24			  inc h 
13d9 c3 c7 13		  jp .u16a 
13dc			 
13dc			 
13dc			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
13dc			 
13dc			;written by Zeda 
13dc			;Converts a 16-bit unsigned integer to an ASCII string. 
13dc			 
13dc			uitoa_16: 
13dc			;Input: 
13dc			;   DE is the number to convert 
13dc			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
13dc			;Output: 
13dc			;   HL points to the null-terminated ASCII string 
13dc			;      NOTE: This isn't necessarily the same as the input HL. 
13dc d5			  push de 
13dd c5			  push bc 
13de f5			  push af 
13df eb			  ex de,hl 
13e0			 
13e0 01 f0 d8		  ld bc,-10000 
13e3 3e 2f		  ld a,'0'-1 
13e5 3c			  inc a 
13e6 09			  add hl,bc  
13e7 38 fc		   jr c,$-2 
13e9 12			  ld (de),a 
13ea 13			  inc de 
13eb			 
13eb 01 e8 03		  ld bc,1000 
13ee 3e 3a		  ld a,'9'+1 
13f0 3d			  dec a  
13f1 09			  add hl,bc  
13f2 30 fc		   jr nc,$-2 
13f4 12			  ld (de),a 
13f5 13			  inc de 
13f6			 
13f6 01 9c ff		  ld bc,-100 
13f9 3e 2f		  ld a,'0'-1 
13fb 3c			  inc a  
13fc 09			  add hl,bc  
13fd 38 fc		   jr c,$-2 
13ff 12			  ld (de),a 
1400 13			  inc de 
1401			 
1401 7d			  ld a,l 
1402 26 3a		  ld h,'9'+1 
1404 25			  dec h  
1405 c6 0a		  add a,10  
1407 30 fb		   jr nc,$-3 
1409 c6 30		  add a,'0' 
140b eb			  ex de,hl 
140c 72			  ld (hl),d 
140d 23			  inc hl 
140e 77			  ld (hl),a 
140f 23			  inc hl 
1410 36 00		  ld (hl),0 
1412			 
1412			;Now strip the leading zeros 
1412 0e fa		  ld c,-6 
1414 09			  add hl,bc 
1415 3e 30		  ld a,'0' 
1417 23			  inc hl  
1418 be			  cp (hl)  
1419 28 fc		  jr z,$-2 
141b			 
141b			;Make sure that the string is non-empty! 
141b 7e			  ld a,(hl) 
141c b7			  or a 
141d 20 01		  jr nz,.atoub 
141f 2b			  dec hl 
1420			.atoub: 
1420			 
1420 f1			  pop af 
1421 c1			  pop bc 
1422 d1			  pop de 
1423 c9			  ret 
1424			 
1424			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1424			 
1424			toUpper: 
1424			;A is the char. 
1424			;If A is a lowercase letter, this sets it to the matching uppercase 
1424			;18cc or 30cc or 41cc 
1424			;avg: 26.75cc 
1424 fe 61		  cp 'a' 
1426 d8			  ret c 
1427 fe 7b		  cp 'z'+1 
1429 d0			  ret nc 
142a d6 20		  sub 'a'-'A' 
142c c9			  ret 
142d			 
142d			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
142d			 
142d			; String Length 
142d			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
142d			 
142d			; Get the length of the null-terminated string starting at $8000 hl 
142d			;    LD     HL, $8000 
142d			 
142d			strlenz: 
142d			 
142d af			    XOR    A               ; Zero is the value we are looking for. 
142e 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
142f 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1430			                           ; 65, 536 bytes (the entire addressable memory space). 
1430 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1432			 
1432			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1432 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1433 6f			    LD     L, A             ; number of bytes 
1434 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1436 2b			    DEC    HL              ; Compensate for null. 
1437 c9				ret 
1438			 
1438			; Get the length of the A terminated string starting at $8000 hl 
1438			;    LD     HL, $8000 
1438			 
1438			strlent: 
1438			 
1438			                  ; A is the value we are looking for. 
1438 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
143a 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
143c			                           ; 65, 536 bytes (the entire addressable memory space). 
143c ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
143e			 
143e			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
143e 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1440 2e 00		    LD     L, 0             ; number of bytes 
1442 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1444 2b			    DEC    HL              ; Compensate for null. 
1445 c9				ret 
1446			 
1446			 
1446			;Comparing Strings 
1446			 
1446			;IN    HL     Address of string1. 
1446			;      DE     Address of string2. 
1446			 
1446			; doc given but wrong??? 
1446			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1446			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1446			; tested 
1446			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1446			 
1446			strcmp_old: 
1446 e5			    PUSH   HL 
1447 d5			    PUSH   DE 
1448			 
1448 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1449 be			    CP     (HL)            ; (want to minimize work). 
144a 38 01		    JR     C, Str1IsBigger 
144c 7e			    LD     A, (HL) 
144d			 
144d			Str1IsBigger: 
144d 4f			    LD     C, A             ; Put length in BC 
144e 06 00		    LD     B, 0 
1450 13			    INC    DE              ; Increment pointers to meat of string. 
1451 23			    INC    HL 
1452			 
1452			CmpLoop: 
1452 1a			    LD     A, (DE)          ; Compare bytes. 
1453 ed a1		    CPI 
1455 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1457 13			    INC    DE              ; Update pointer. 
1458 ea 52 14		    JP     PE, CmpLoop 
145b			 
145b d1			    POP    DE 
145c e1			    POP    HL 
145d 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
145e be			    CP     (HL) 
145f c9			    RET 
1460			 
1460			NoMatch: 
1460 2b			    DEC    HL 
1461 be			    CP     (HL)            ; Compare again to affect carry. 
1462 d1			    POP    DE 
1463 e1			    POP    HL 
1464 c9			    RET 
1465			 
1465			;; test strmp 
1465			; 
1465			;ld de, .str1 
1465			;ld hl, .str2 
1465			;call strcmp 
1465			;jr z, .z1 
1465			;;this 
1465			;	if DEBUG_FORTH_WORDS 
1465			;		DMARK "NZ1" 
1465			;		CALLMONITOR 
1465			;	endif 
1465			;.z1: 
1465			; 
1465			;	if DEBUG_FORTH_WORDS 
1465			;		DMARK "ZZ1" 
1465			;		CALLMONITOR 
1465			;	endif 
1465			; 
1465			;ld de, .str1 
1465			;ld hl, .str1 
1465			;call strcmp 
1465			;jr z, .z2 
1465			;;this 
1465			;	if DEBUG_FORTH_WORDS 
1465			;		DMARK "NZ2" 
1465			;		CALLMONITOR 
1465			;	endif 
1465			;.z2: 
1465			; 
1465			;	if DEBUG_FORTH_WORDS 
1465			;		DMARK "ZZ2" 
1465			;		CALLMONITOR 
1465			;	endif 
1465			; 
1465			;ld de, .str1 
1465			;ld hl, .str2 
1465			;call strcmp 
1465			;jr c, .c1 
1465			; 
1465			;	if DEBUG_FORTH_WORDS 
1465			;		DMARK "Nc1" 
1465			;		CALLMONITOR 
1465			;	endif 
1465			;.c1: 
1465			;;this 
1465			;	if DEBUG_FORTH_WORDS 
1465			;		DMARK "cc1" 
1465			;		CALLMONITOR 
1465			;	endif 
1465			; 
1465			;ld de, .str1 
1465			;ld hl, .str1 
1465			;call strcmp 
1465			;jr c, .c2 
1465			;;this 
1465			;	if DEBUG_FORTH_WORDS 
1465			;		DMARK "Nc2" 
1465			;		CALLMONITOR 
1465			;	endif 
1465			;.c2: 
1465			; 
1465			;	if DEBUG_FORTH_WORDS 
1465			;		DMARK "cc2" 
1465			;		CALLMONITOR 
1465			;	endif 
1465			;	NEXTW 
1465			;.str1:   db "string1",0 
1465			;.str2:   db "string2",0 
1465			 
1465			; only care about direct match or not 
1465			; hl and de strings 
1465			; zero set if the same 
1465			 
1465			strcmp: 
1465 1a				ld a, (de) 
1466 be				cp (hl) 
1467 28 02			jr z, .ssame 
1469 b7				or a 
146a c9				ret 
146b			 
146b			.ssame:  
146b fe 00			cp 0 
146d c8				ret z 
146e			 
146e 23				inc hl 
146f 13				inc de 
1470 18 f3			jr strcmp 
1472				 
1472				 
1472			 
1472			;Copyright (c) 2014, Luke Maurits 
1472			;All rights reserved. 
1472			; 
1472			;Redistribution and use in source and binary forms, with or without 
1472			;modification, are permitted provided that the following conditions are met: 
1472			; 
1472			;* Redistributions of source code must retain the above copyright notice, this 
1472			;  list of conditions and the following disclaimer. 
1472			; 
1472			;* Redistributions in binary form must reproduce the above copyright notice, 
1472			;  this list of conditions and the following disclaimer in the documentation 
1472			;  and/or other materials provided with the distribution. 
1472			; 
1472			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
1472			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
1472			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
1472			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
1472			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
1472			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
1472			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
1472			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
1472			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
1472			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
1472			 
1472			; https://github.com/lmaurits/lm512/blob/master/string.z80 
1472			 
1472			StrictStrCmp: 
1472				; Load next chars of each string 
1472 1a				ld a, (de) 
1473 47				ld b, a 
1474 7e				ld a, (hl) 
1475				; Compare 
1475 b8				cp b 
1476				; Return non-zero if chars don't match 
1476 c0				ret nz 
1477				; Check for end of both strings 
1477 fe 00			cp "\0" 
1479				; Return if strings have ended 
1479 c8				ret z 
147a				; Otherwise, advance to next chars 
147a 23				inc hl 
147b 13				inc de 
147c 18 f4			jr StrictStrCmp 
147e			 
147e			;end 
147e			; eof 
147e			 
147e			 
147e			 
147e			 
147e			 
147e			 
# End of file firmware_strings.asm
147e			include "firmware_memory.asm"   ; malloc and free  
147e			 
147e			if DEBUG_FORTH_MALLOC_HIGH 
147e			.mallocsize: db "Wants malloc >256",0 
147e			.mallocasize: db "MALLOC gives >256",0 
147e			.malloczero: db "MALLOC gives zero",0 
147e			 
147e			malloc_guard_zerolen: 
147e				push hl 
147e				push de 
147e				push af 
147e			 
147e				ld de, 0 
147e			        call cmp16 
147e				jr nz, .lowalloz 
147e			 
147e				push hl 
147e				push de 
147e					ld hl, display_fb0 
147e					ld (display_fb_active), hl 
147e				call clear_display 
147e				ld a, 0 
147e				ld de, .malloczero 
147e				call str_at_display 
147e				call update_display 
147e				call delay1s 
147e				call delay1s 
147e				call bp_on 
147e			;	ld a, 0 
147e			;	ld (os_view_disable), a 
147e			 
147e				pop de 
147e				pop hl 
147e			 
147e				 
147e			 
147e				CALLMONITOR 
147e			.lowalloz: 
147e			 
147e			 
147e				pop af 
147e				pop de 
147e				pop hl 
147e			ret 
147e			 
147e			malloc_guard_entry: 
147e				push hl 
147e				push de 
147e				push af 
147e			 
147e			 	or a      ;clear carry flag 
147e				push hl 
147e				ld de, 255 
147e				sbc hl, de 
147e				jr c, .lowalloc 
147e			 
147e				push de 
147e					ld hl, display_fb0 
147e					ld (display_fb_active), hl 
147e				call clear_display 
147e				ld a, 0 
147e				ld de, .mallocsize 
147e				call str_at_display 
147e				call update_display 
147e				call delay1s 
147e				call delay1s 
147e			;	ld a, 0 
147e			;	ld (os_view_disable), a 
147e				call bp_on 
147e			 
147e				pop de 
147e				pop hl 
147e			 
147e				 
147e			 
147e				CALLMONITOR 
147e				jr .lowdone 
147e			.lowalloc: 
147e			 
147e			 
147e				pop hl 
147e			.lowdone:	pop af 
147e				pop de 
147e				pop hl 
147e			ret 
147e			 
147e			malloc_guard_exit: 
147e				push hl 
147e				push de 
147e				push af 
147e			 
147e			 	or a      ;clear carry flag 
147e				push hl 
147e				ld de, 255 
147e				sbc hl, de 
147e				jr c, .lowallocx 
147e			 
147e				push de 
147e					ld hl, display_fb0 
147e					ld (display_fb_active), hl 
147e				call clear_display 
147e				ld a, 0 
147e				ld de, .mallocasize 
147e				call str_at_display 
147e				call update_display 
147e				call delay1s 
147e				call delay1s 
147e			;	ld a, 0 
147e			;	ld (os_view_disable), a 
147e				call bp_on 
147e				pop de 
147e				pop hl 
147e			 
147e				CALLMONITOR 
147e				jr .lowdonex 
147e			.lowallocx: 
147e			 
147e				pop hl 
147e			.lowdonex:	pop af 
147e				pop de 
147e				pop hl 
147e			ret 
147e			endif 
147e			 
147e			if MALLOC_2 
147e			; Z80 Malloc and Free Functions 
147e			 
147e			; Malloc Function: 
147e			; Input: 
147e			;   HL: Size of block to allocate 
147e			; Output: 
147e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
147e			 
147e			malloc: 
147e				 
147e			if DEBUG_FORTH_MALLOC_HIGH 
147e			call malloc_guard_entry 
147e			endif 
147e			 
147e			 
147e			 
147e			 
147e					if DEBUG_FORTH_MALLOC 
147e						DMARK "mal" 
147e						CALLMONITOR 
147e					endif 
147e			    push af            ; Save AF register 
147e			    ld a, l            ; Load low byte of size into A 
147e			    or h               ; Check if size is zero 
147e			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
147e			 
147e			    ; Allocate memory 
147e			    ld hl, (heap_start) ; Load start of heap into HL 
147e					if DEBUG_FORTH_MALLOC 
147e						DMARK "ma1" 
147e						CALLMONITOR 
147e					endif 
147e			    call malloc_internal ; Call internal malloc function 
147e			    pop af             ; Restore AF register 
147e			if DEBUG_FORTH_MALLOC_HIGH 
147e			call malloc_guard_exit 
147e			call malloc_guard_zerolen 
147e			endif 
147e			    ret                ; Return 
147e			 
147e			; Free Function: 
147e			; Input: 
147e			;   HL: Pointer to memory block to free 
147e			; Output: 
147e			;   None 
147e			 
147e			free: 
147e			    push af            ; Save AF register 
147e			    ld a, l            ; Load low byte of pointer into A 
147e			    or h               ; Check if pointer is NULL 
147e			    jp z, free_exit    ; If pointer is NULL, exit 
147e			 
147e			    ; Free memory 
147e			    ld hl, (heap_start) ; Load start of heap into HL 
147e			    call free_internal  ; Call internal free function 
147e			    pop af             ; Restore AF register 
147e			    ret                ; Return 
147e			 
147e			; Internal Malloc Function: 
147e			; Input: 
147e			;   HL: Size of block to allocate 
147e			; Output: 
147e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
147e			 
147e			malloc_internal: 
147e			    ld bc, 2           ; Number of bytes to allocate for management overhead 
147e			    add hl, bc         ; Add management overhead to requested size 
147e			    ex de, hl          ; Save total size in DE, and keep it in HL 
147e					if DEBUG_FORTH_MALLOC 
147e						DMARK "ma2" 
147e						CALLMONITOR 
147e					endif 
147e			 
147e			    ; Search for free memory block 
147e			    ld de, (heap_end)  ; Load end of heap into DE 
147e			    ld bc, 0           ; Initialize counter 
147e			 
147e					if DEBUG_FORTH_MALLOC 
147e						DMARK "ma2" 
147e						CALLMONITOR 
147e					endif 
147e			malloc_search_loop: 
147e			    ; Check if current block is free 
147e			    ld a, (hl)         ; Load current block's status (free or used) 
147e			    cp 0               ; Compare with zero (free) 
147e			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
147e			 
147e			    ; Check if current block is large enough 
147e			    ld a, (hl+1)       ; Load high byte of block size 
147e			    cp l               ; Compare with low byte of requested size 
147e			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
147e			 
147e			    ld a, (hl+2)       ; Load low byte of block size 
147e			    cp h               ; Compare with high byte of requested size 
147e			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
147e			 
147e			    ; Mark block as used 
147e			    ld (hl), 0xFF      ; Set status byte to indicate used block 
147e			 
147e			    ; Calculate remaining space in block 
147e			    ld bc, 0           ; Clear BC 
147e			    add hl, bc         ; Increment HL to point to start of data block 
147e			    add hl, de         ; HL = HL + DE (total size) 
147e			    ld bc, 1           ; Number of bytes to allocate for management overhead 
147e			    add hl, bc         ; Add management overhead to start of data block 
147e			 
147e			    ; Save pointer to allocated block in HL 
147e			if DEBUG_FORTH_MALLOC_HIGH 
147e						DMARK "ma5" 
147e			call malloc_guard_exit 
147e			call malloc_guard_zerolen 
147e			endif 
147e			    ret 
147e			 
147e			malloc_skip_block_check: 
147e			    ; Move to the next block 
147e			    ld bc, 3           ; Size of management overhead 
147e			    add hl, bc         ; Move to the next block 
147e			    inc de             ; Increment counter 
147e			 
147e			    ; Check if we have reached the end of heap 
147e			    ld a, e            ; Load low byte of heap end address 
147e			    cp (hl)            ; Compare with low byte of current address 
147e			    jr nz, malloc_search_loop  ; If not equal, continue searching 
147e			    ld a, d            ; Load high byte of heap end address 
147e			    cp 0               ; Check if it's zero (end of memory) 
147e			    jr nz, malloc_search_loop  ; If not zero, continue searching 
147e			 
147e			    ; If we reached here, allocation failed 
147e			    xor a              ; Set result to NULL 
147e			if DEBUG_FORTH_MALLOC_HIGH 
147e						DMARK "ma6" 
147e			call malloc_guard_exit 
147e			call malloc_guard_zerolen 
147e			endif 
147e			    ret 
147e			malloc_exit: 
147e			if DEBUG_FORTH_MALLOC_HIGH 
147e						DMARK "ma7" 
147e			call malloc_guard_exit 
147e			call malloc_guard_zerolen 
147e			endif 
147e			    ret 
147e			 
147e			; Internal Free Function: 
147e			; Input: 
147e			;   HL: Pointer to memory block to free 
147e			; Output: 
147e			;   None 
147e			 
147e			free_internal: 
147e			    ld de, (heap_start) ; Load start of heap into DE 
147e			    ld bc, 0            ; Initialize counter 
147e			 
147e			free_search_loop: 
147e			    ; Check if current block contains the pointer 
147e			    ld a, l             ; Load low byte of pointer 
147e			    cp (hl+1)           ; Compare with high byte of current block's address 
147e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
147e			    ld a, h             ; Load high byte of pointer 
147e			    cp (hl+2)           ; Compare with low byte of current block's address 
147e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
147e			 
147e			    ; Mark block as free 
147e			    ld (hl), 0          ; Set status byte to indicate free block 
147e			    ret                 ; Return 
147e			 
147e			free_skip_block_check: 
147e			    ; Move to the next block 
147e			    ld bc, 3            ; Size of management overhead 
147e			    add hl, bc          ; Move to the next block 
147e			    inc de              ; Increment counter 
147e			 
147e			    ; Check if we have reached the end of heap 
147e			    ld a, e             ; Load low byte of heap end address 
147e			    cp (hl)             ; Compare with low byte of current address 
147e			    jr nz, free_search_loop  ; If not equal, continue searching 
147e			    ld a, d             ; Load high byte of heap end address 
147e			    cp 0                ; Check if it's zero (end of memory) 
147e			    jr nz, free_search_loop  ; If not zero, continue searching 
147e			 
147e			    ; If we reached here, pointer is not found in heap 
147e			    ret 
147e			 
147e			free_exit: 
147e			    ret                 ; Return 
147e			 
147e			; Define heap start and end addresses 
147e			;heap_start:    .dw 0xC000   ; Start of heap 
147e			;heap_end:      .dw 0xE000   ; End of heap 
147e			 
147e			endif 
147e			 
147e			 
147e			if MALLOC_1 
147e			 
147e			 
147e			 
147e			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
147e			 
147e			;moved to firmware.asm 
147e			;heap_start        .equ  0x9000      ; Starting address of heap 
147e			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
147e			 
147e			;      .org 0 
147e			;      jp    main 
147e			 
147e			 
147e			;      .org  0x100 
147e			;main: 
147e			;      ld    HL, 0x8100 
147e			;      ld    SP, HL 
147e			; 
147e			;      call  heap_init 
147e			; 
147e			;      ; Make some allocations 
147e			;      ld    HL, 12 
147e			;      call  malloc            ; Allocates 0x9004 
147e			; 
147e			;      ld    HL, 12 
147e			;      call  malloc            ; Allocates 0x9014 
147e			; 
147e			;      ld    HL, 12 
147e			;      call  malloc            ; Allocates 0x9024 
147e			; 
147e			;      ; Free some allocations 
147e			;      ld    HL, 0x9014 
147e			;      call  free 
147e			; 
147e			;      ld    HL, 0x9004 
147e			;      call  free 
147e			; 
147e			;      ld    HL, 0x9024 
147e			;      call  free 
147e			; 
147e			; 
147e			;      halt 
147e			 
147e			 
147e			;------------------------------------------------------------------------------ 
147e			;     heap_init                                                               : 
147e			;                                                                             : 
147e			; Description                                                                 : 
147e			;     Initialise the heap and make it ready for malloc and free operations.   : 
147e			;                                                                             : 
147e			;     The heap is maintained as a linked list, starting with an initial       : 
147e			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
147e			;     the first free block in the heap. Each block then points to the next    : 
147e			;     free block within the heap, and the free list ends at the first block   : 
147e			;     with a null pointer to the next free block.                             : 
147e			;                                                                             : 
147e			; Parameters                                                                  : 
147e			;     Inputs are compile-time only. Two defines which specify the starting    : 
147e			;     address of the heap and its size are required, along with a memory      : 
147e			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
147e			;     principally stores a pointer to the first free block in the heap.       : 
147e			;                                                                             : 
147e			; Returns                                                                     : 
147e			;     Nothing                                                                 : 
147e			;------------------------------------------------------------------------------ 
147e			heap_init: 
147e e5			      push  HL 
147f			 
147f			      ; Initialise free list struct 
147f 21 0e 80		      ld    HL, heap_start 
1482 22 0a 80		      ld    (free_list), HL 
1485 21 00 00		      ld    HL, 0 
1488 22 0c 80		      ld    (free_list+2), HL 
148b			 
148b			      ; Insert first free block at bottom of heap, consumes entire heap 
148b 21 d3 f0		      ld    HL, heap_start+heap_size-4 
148e 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1491 21 c5 70		      ld    HL, heap_size-4 
1494 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1497			 
1497			      ; Insert end of free list block at top of heap - two null words will 
1497			      ; terminate the free list 
1497 21 00 00		      ld    HL, 0 
149a 22 d5 f0		      ld    (heap_start+heap_size-2), HL 
149d 22 d3 f0		      ld    (heap_start+heap_size-4), HL 
14a0			 
14a0 e1			      pop   HL 
14a1			 
14a1 c9			      ret 
14a2			 
14a2			 
14a2			;------------------------------------------------------------------------------ 
14a2			;     malloc                                                                  : 
14a2			;                                                                             : 
14a2			; Description                                                                 : 
14a2			;     Allocates the wanted space from the heap and returns the address of the : 
14a2			;     first useable byte of the allocation.                                   : 
14a2			;                                                                             : 
14a2			;     Allocations can happen in one of two ways:                              : 
14a2			;                                                                             : 
14a2			;     1. A free block may be found which is the exact size wanted. In this    : 
14a2			;        case the block is removed from the free list and retuedn to the      : 
14a2			;        caller.                                                              : 
14a2			;     2. A free block may be found which is larger than the size wanted. In   : 
14a2			;        this case, the larger block is split into two. The first portion of  : 
14a2			;        this block will become the requested space by the malloc call and    : 
14a2			;        is returned to the caller. The second portion becomes a new free     : 
14a2			;        block, and the free list is adjusted to maintain continuity via this : 
14a2			;        newly created block.                                                 : 
14a2			;                                                                             : 
14a2			;     malloc does not set any initial value in the allocated space, the       : 
14a2			;     caller is required to do this as required.                              : 
14a2			;                                                                             : 
14a2			;     This implementation of malloc uses the stack exclusively, and is        : 
14a2			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
14a2			;     advisable to disable interrupts before calling malloc, and recommended  : 
14a2			;     to avoid the use of malloc inside ISRs in general.                      : 
14a2			;                                                                             : 
14a2			;     NOTE: heap_init must be called before malloc and free can be used.      : 
14a2			;                                                                             : 
14a2			; Parameters                                                                  : 
14a2			;     HL  Number of bytes wanted                                              : 
14a2			;                                                                             : 
14a2			; Returns                                                                     : 
14a2			;     HL  Address of the first useable byte of the allocation                 : 
14a2			;                                                                             : 
14a2			; Flags                                                                       : 
14a2			;     Z   Set if the allocation did not succeed, clear otherwise              : 
14a2			;                                                                             : 
14a2			; Stack frame                                                                 : 
14a2			;       |             |                                                       : 
14a2			;       +-------------+                                                       : 
14a2			;       |     BC      |                                                       : 
14a2			;       +-------------+                                                       : 
14a2			;       |     DE      |                                                       : 
14a2			;       +-------------+                                                       : 
14a2			;       |     IX      |                                                       : 
14a2			;       +-------------+                                                       : 
14a2			;       |  prev_free  |                                                       : 
14a2			;   +4  +-------------+                                                       : 
14a2			;       |  this_free  |                                                       : 
14a2			;   +2  +-------------+                                                       : 
14a2			;       |  next_free  |                                                       : 
14a2			;   +0  +-------------+                                                       : 
14a2			;       |             |                                                       : 
14a2			;                                                                             : 
14a2			;------------------------------------------------------------------------------ 
14a2			 
14a2			 
14a2			;malloc: 
14a2			; 
14a2			;	SAVESP ON 1 
14a2			; 
14a2			;	call malloc_code 
14a2			; 
14a2			;	CHECKSP ON 1 
14a2			;	ret 
14a2			 
14a2			 
14a2			malloc: 
14a2 c5			      push  BC 
14a3 d5			      push  DE 
14a4 dd e5		      push  IX 
14a6			if DEBUG_FORTH_MALLOC_HIGH 
14a6			call malloc_guard_entry 
14a6			endif 
14a6			 
14a6					if DEBUG_FORTH_MALLOC 
14a6						DMARK "mal" 
14a6						CALLMONITOR 
14a6					endif 
14a6 7c			      ld    A, H                    ; Exit if no space requested 
14a7 b5			      or    L 
14a8 ca 67 15		      jp    Z, malloc_early_exit 
14ab			 
14ab			;inc hl 
14ab			;inc hl 
14ab			;inc hl 
14ab			; 
14ab			;inc hl 
14ab			;inc hl 
14ab			;inc hl 
14ab			;inc hl 
14ab			;inc hl 
14ab			;inc hl 
14ab			;inc hl 
14ab			;inc hl 
14ab			;inc hl 
14ab			 
14ab			 
14ab			 
14ab			 
14ab					if DEBUG_FORTH_MALLOC 
14ab						DMARK "maA" 
14ab						CALLMONITOR 
14ab					endif 
14ab			      ; Set up stack frame 
14ab eb			      ex    DE, HL 
14ac 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
14af 39			      add   HL, SP 
14b0 f9			      ld    SP, HL 
14b1 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14b5 dd 39		      add   IX, SP 
14b7			 
14b7			      ; Setup initial state 
14b7 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
14ba 19			      add   HL, DE 
14bb			 
14bb 44			      ld    B, H                    ; Move want to BC 
14bc 4d			      ld    C, L 
14bd			 
14bd 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
14c0 dd 75 04		      ld    (IX+4), L 
14c3 dd 74 05		      ld    (IX+5), H 
14c6			 
14c6 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
14c7 23			      inc   HL 
14c8 56			      ld    D, (HL) 
14c9 dd 73 02		      ld    (IX+2), E 
14cc dd 72 03		      ld    (IX+3), D 
14cf eb			      ex    DE, HL                  ; this_free ptr into HL 
14d0			 
14d0					if DEBUG_FORTH_MALLOC 
14d0						DMARK "maB" 
14d0						CALLMONITOR 
14d0					endif 
14d0			      ; Loop through free block list to find some space 
14d0			malloc_find_space: 
14d0 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
14d1 23			      inc   HL 
14d2 56			      ld    D, (HL) 
14d3			 
14d3 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
14d4 b3			      or    E 
14d5 ca 61 15		      jp    Z, malloc_no_space 
14d8			 
14d8 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
14db dd 72 01		      ld    (IX+1), D 
14de			 
14de			      ; Does this block have enough space to make the allocation? 
14de 23			      inc   HL                      ; Load free block size into DE 
14df 5e			      ld    E, (HL) 
14e0 23			      inc   HL 
14e1 56			      ld    D, (HL) 
14e2			 
14e2 eb			      ex    DE, HL                  ; Check size of block against want 
14e3 b7			      or    A                       ; Ensure carry flag clear 
14e4 ed 42		      sbc   HL, BC 
14e6 e5			      push  HL                      ; Store the result for later (new block size) 
14e7			 
14e7 ca 36 15		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
14ea 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
14ec			 
14ec			      ; this_free block is not big enough, setup ptrs to test next free block 
14ec e1			      pop   HL                      ; Discard previous result 
14ed			 
14ed dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
14f0 dd 66 03		      ld    H, (IX+3) 
14f3 dd 75 04		      ld    (IX+4), L 
14f6 dd 74 05		      ld    (IX+5), H 
14f9			 
14f9 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
14fc dd 66 01		      ld    H, (IX+1) 
14ff dd 75 02		      ld    (IX+2), L 
1502 dd 74 03		      ld    (IX+3), H 
1505			 
1505					if DEBUG_FORTH_MALLOC 
1505						DMARK "MA>" 
1505						CALLMONITOR 
1505					endif 
1505 18 c9		      jr    malloc_find_space 
1507			 
1507			      ; split a bigger block into two - requested size and remaining size 
1507			malloc_alloc_split: 
1507					if DEBUG_FORTH_MALLOC 
1507						DMARK "MAs" 
1507						CALLMONITOR 
1507					endif 
1507 eb			      ex    DE, HL                  ; Calculate address of new free block 
1508 2b			      dec   HL 
1509 2b			      dec   HL 
150a 2b			      dec   HL 
150b 09			      add   HL, BC 
150c			 
150c			      ; Create a new block and point it at next_free 
150c dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
150f dd 56 01		      ld    D, (IX+1) 
1512			 
1512 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1513 23			      inc   HL 
1514 72			      ld    (HL), D 
1515			 
1515 d1			      pop   DE                      ; Store size of new block into new block 
1516 23			      inc   HL 
1517 73			      ld    (HL), E 
1518 23			      inc   HL 
1519 72			      ld    (HL), D 
151a			 
151a			      ; Update this_free ptr to point to new block 
151a 2b			      dec   HL 
151b 2b			      dec   HL 
151c 2b			      dec   HL 
151d			 
151d dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1520 dd 56 03		      ld    D, (IX+3) 
1523			 
1523 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1526 dd 74 03		      ld    (IX+3), H 
1529			 
1529			      ; Modify this_free block to be allocation 
1529 eb			      ex    DE, HL 
152a af			      xor   A                       ; Null the next block ptr of allocated block 
152b 77			      ld    (HL), A 
152c 23			      inc   HL 
152d 77			      ld    (HL), A 
152e			 
152e 23			      inc   HL                      ; Store want size into allocated block 
152f 71			      ld    (HL), C 
1530 23			      inc   HL 
1531 70			      ld    (HL), B 
1532 23			      inc   HL 
1533 e5			      push  HL                      ; Address of allocation to return 
1534			 
1534 18 19		      jr    malloc_update_links 
1536			 
1536			malloc_alloc_fit: 
1536 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1537			 
1537					if DEBUG_FORTH_MALLOC 
1537						DMARK "MAf" 
1537						CALLMONITOR 
1537					endif 
1537			      ; Modify this_free block to be allocation 
1537 eb			      ex    DE, HL 
1538 2b			      dec   HL 
1539 2b			      dec   HL 
153a 2b			      dec   HL 
153b			 
153b af			      xor   A                       ; Null the next block ptr of allocated block 
153c 77			      ld    (HL), A 
153d 23			      inc   HL 
153e 77			      ld    (HL), A 
153f			 
153f 23			      inc   HL                      ; Store address of allocation to return 
1540 23			      inc   HL 
1541 23			      inc   HL 
1542 e5			      push  HL 
1543			 
1543			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1543 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1546 dd 66 01		      ld    H, (IX+1) 
1549			 
1549 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
154c dd 74 03		      ld    (IX+3), H 
154f			 
154f			 
154f			malloc_update_links: 
154f			      ; Update prev_free ptr to point to this_free 
154f dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1552 dd 66 05		      ld    H, (IX+5) 
1555			 
1555 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1558 dd 56 03		      ld    D, (IX+3) 
155b			 
155b 73			      ld    (HL), E                 ; this_free ptr into prev_free 
155c 23			      inc   HL 
155d 72			      ld    (HL), D 
155e			 
155e					if DEBUG_FORTH_MALLOC 
155e						DMARK "Mul" 
155e						CALLMONITOR 
155e					endif 
155e			      ; Clear the Z flag to indicate successful allocation 
155e 7a			      ld    A, D 
155f b3			      or    E 
1560			 
1560 d1			      pop   DE                      ; Address of allocation 
1561					if DEBUG_FORTH_MALLOC 
1561						DMARK "MAu" 
1561						CALLMONITOR 
1561					endif 
1561			 
1561			malloc_no_space: 
1561 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1564 39			      add   HL, SP 
1565 f9			      ld    SP, HL 
1566			 
1566 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1567					if DEBUG_FORTH_MALLOC 
1567						DMARK "MAN" 
1567						CALLMONITOR 
1567					endif 
1567			 
1567			malloc_early_exit: 
1567					if DEBUG_FORTH_MALLOC 
1567						DMARK "MAx" 
1567						CALLMONITOR 
1567					endif 
1567 dd e1		      pop   IX 
1569 d1			      pop   DE 
156a c1			      pop   BC 
156b			 
156b			if DEBUG_FORTH_MALLOC_HIGH 
156b			call malloc_guard_exit 
156b			call malloc_guard_zerolen 
156b			endif 
156b c9			      ret 
156c			 
156c			 
156c			;------------------------------------------------------------------------------ 
156c			;     free                                                                    : 
156c			;                                                                             : 
156c			; Description                                                                 : 
156c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
156c			;     returned by malloc, otherwise the behaviour is undefined.               : 
156c			;                                                                             : 
156c			;     Where possible, directly adjacent free blocks will be merged together   : 
156c			;     into larger blocks to help ensure that the heap does not become         : 
156c			;     excessively fragmented.                                                 : 
156c			;                                                                             : 
156c			;     free does not clear or set any other value into the freed space, and    : 
156c			;     therefore its contents may be visible through subsequent malloc's. The  : 
156c			;     caller should clear the freed space as required.                        : 
156c			;                                                                             : 
156c			;     This implementation of free uses the stack exclusively, and is          : 
156c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
156c			;     advisable to disable interrupts before calling free, and recommended    : 
156c			;     to avoid the use of free inside ISRs in general.                        : 
156c			;                                                                             : 
156c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
156c			;                                                                             : 
156c			; Parameters                                                                  : 
156c			;     HL  Pointer to address of first byte of allocation to be freed          : 
156c			;                                                                             : 
156c			; Returns                                                                     : 
156c			;     Nothing                                                                 : 
156c			;                                                                             : 
156c			; Stack frame                                                                 : 
156c			;       |             |                                                       : 
156c			;       +-------------+                                                       : 
156c			;       |     BC      |                                                       : 
156c			;       +-------------+                                                       : 
156c			;       |     DE      |                                                       : 
156c			;       +-------------+                                                       : 
156c			;       |     IX      |                                                       : 
156c			;       +-------------+                                                       : 
156c			;       |  prev_free  |                                                       : 
156c			;   +2  +-------------+                                                       : 
156c			;       |  next_free  |                                                       : 
156c			;   +0  +-------------+                                                       : 
156c			;       |             |                                                       : 
156c			;                                                                             : 
156c			;------------------------------------------------------------------------------ 
156c			free: 
156c c5			      push  BC 
156d d5			      push  DE 
156e dd e5		      push  IX 
1570			 
1570 7c			      ld    A, H                    ; Exit if ptr is null 
1571 b5			      or    L 
1572 ca 36 16		      jp    Z, free_early_exit 
1575			 
1575			      ; Set up stack frame 
1575 eb			      ex    DE, HL 
1576 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1579 39			      add   HL, SP 
157a f9			      ld    SP, HL 
157b dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
157f dd 39		      add   IX, SP 
1581			 
1581			      ; The address in HL points to the start of the useable allocated space, 
1581			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1581			      ; address of the block itself. 
1581 eb			      ex    DE, HL 
1582 11 fc ff		      ld    DE, -4 
1585 19			      add   HL, DE 
1586			 
1586			      ; An allocated block must have a null next block pointer in it 
1586 7e			      ld    A, (HL) 
1587 23			      inc   HL 
1588 b6			      or    (HL) 
1589 c2 31 16		      jp    NZ, free_done 
158c			 
158c 2b			      dec   HL 
158d			 
158d 44			      ld    B, H                    ; Copy HL to BC 
158e 4d			      ld    C, L 
158f			 
158f			      ; Loop through the free list to find the first block with an address 
158f			      ; higher than the block being freed 
158f 21 0a 80		      ld    HL, free_list 
1592			 
1592			free_find_higher_block: 
1592 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1593 23			      inc   HL 
1594 56			      ld    D, (HL) 
1595 2b			      dec   HL 
1596			 
1596 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1599 dd 72 01		      ld    (IX+1), D 
159c dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
159f dd 74 03		      ld    (IX+3), H 
15a2			 
15a2 78			      ld    A, B                    ; Check if DE is greater than BC 
15a3 ba			      cp    D                       ; Compare MSB first 
15a4 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
15a6 30 04		      jr    NC, free_find_higher_block_skip 
15a8 79			      ld    A, C 
15a9 bb			      cp    E                       ; Then compare LSB 
15aa 38 08		      jr    C, free_found_higher_block 
15ac			 
15ac			free_find_higher_block_skip: 
15ac 7a			      ld    A, D                    ; Reached the end of the free list? 
15ad b3			      or    E 
15ae ca 31 16		      jp    Z, free_done 
15b1			 
15b1 eb			      ex    DE, HL 
15b2			 
15b2 18 de		      jr    free_find_higher_block 
15b4			 
15b4			free_found_higher_block: 
15b4			      ; Insert freed block between prev and next free blocks 
15b4 71			      ld    (HL), C                 ; Point prev free block to freed block 
15b5 23			      inc   HL 
15b6 70			      ld    (HL), B 
15b7			 
15b7 60			      ld    H, B                    ; Point freed block at next free block 
15b8 69			      ld    L, C 
15b9 73			      ld    (HL), E 
15ba 23			      inc   HL 
15bb 72			      ld    (HL), D 
15bc			 
15bc			      ; Check if the freed block is adjacent to the next free block 
15bc 23			      inc   HL                      ; Load size of freed block into HL 
15bd 5e			      ld    E, (HL) 
15be 23			      inc   HL 
15bf 56			      ld    D, (HL) 
15c0 eb			      ex    DE, HL 
15c1			 
15c1 09			      add   HL, BC                  ; Add addr of freed block and its size 
15c2			 
15c2 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
15c5 dd 56 01		      ld    D, (IX+1) 
15c8			 
15c8 b7			      or    A                       ; Clear the carry flag 
15c9 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15cb 20 22		      jr    NZ, free_check_adjacent_to_prev 
15cd			 
15cd			      ; Freed block is adjacent to next, merge into one bigger block 
15cd eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
15ce 5e			      ld    E, (HL) 
15cf 23			      inc   HL 
15d0 56			      ld    D, (HL) 
15d1 e5			      push  HL                      ; Save ptr to next block for later 
15d2			 
15d2 60			      ld    H, B                    ; Store ptr from next block into freed block 
15d3 69			      ld    L, C 
15d4 73			      ld    (HL), E 
15d5 23			      inc   HL 
15d6 72			      ld    (HL), D 
15d7			 
15d7 e1			      pop   HL                      ; Restore ptr to next block 
15d8 23			      inc   HL                      ; Load size of next block into DE 
15d9 5e			      ld    E, (HL) 
15da 23			      inc   HL 
15db 56			      ld    D, (HL) 
15dc d5			      push  DE                      ; Save next block size for later 
15dd			 
15dd 60			      ld    H, B                    ; Load size of freed block into HL 
15de 69			      ld    L, C 
15df 23			      inc   HL 
15e0 23			      inc   HL 
15e1 5e			      ld    E, (HL) 
15e2 23			      inc   HL 
15e3 56			      ld    D, (HL) 
15e4 eb			      ex    DE, HL 
15e5			 
15e5 d1			      pop   DE                      ; Restore size of next block 
15e6 19			      add   HL, DE                  ; Add sizes of both blocks 
15e7 eb			      ex    DE, HL 
15e8			 
15e8 60			      ld    H, B                    ; Store new bigger size into freed block 
15e9 69			      ld    L, C 
15ea 23			      inc   HL 
15eb 23			      inc   HL 
15ec 73			      ld    (HL), E 
15ed 23			      inc   HL 
15ee 72			      ld    (HL), D 
15ef			 
15ef			free_check_adjacent_to_prev: 
15ef			      ; Check if the freed block is adjacent to the prev free block 
15ef dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
15f2 dd 66 03		      ld    H, (IX+3) 
15f5			 
15f5 23			      inc   HL                      ; Size of prev free block into DE 
15f6 23			      inc   HL 
15f7 5e			      ld    E, (HL) 
15f8 23			      inc   HL 
15f9 56			      ld    D, (HL) 
15fa 2b			      dec   HL 
15fb 2b			      dec   HL 
15fc 2b			      dec   HL 
15fd			 
15fd 19			      add   HL, DE                  ; Add prev block addr and size 
15fe			 
15fe b7			      or    A                       ; Clear the carry flag 
15ff ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1601 20 2e		      jr    NZ, free_done 
1603			 
1603			      ; Freed block is adjacent to prev, merge into one bigger block 
1603 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1604 69			      ld    L, C 
1605 5e			      ld    E, (HL) 
1606 23			      inc   HL 
1607 56			      ld    D, (HL) 
1608 e5			      push  HL                      ; Save freed block ptr for later 
1609			 
1609 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
160c dd 66 03		      ld    H, (IX+3) 
160f 73			      ld    (HL), E 
1610 23			      inc   HL 
1611 72			      ld    (HL), D 
1612			 
1612 e1			      pop   HL                      ; Restore freed block ptr 
1613 23			      inc   HL                      ; Load size of freed block into DE 
1614 5e			      ld    E, (HL) 
1615 23			      inc   HL 
1616 56			      ld    D, (HL) 
1617 d5			      push  DE                      ; Save freed block size for later 
1618			 
1618 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
161b dd 66 03		      ld    H, (IX+3) 
161e 23			      inc   HL 
161f 23			      inc   HL 
1620 5e			      ld    E, (HL) 
1621 23			      inc   HL 
1622 56			      ld    D, (HL) 
1623			 
1623 e1			      pop   HL                      ; Add sizes of both blocks 
1624 19			      add   HL, DE 
1625 eb			      ex    DE, HL 
1626			 
1626 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1629 dd 66 03		      ld    H, (IX+3) 
162c 23			      inc   HL 
162d 23			      inc   HL 
162e 73			      ld    (HL), E 
162f 23			      inc   HL 
1630 72			      ld    (HL), D 
1631			 
1631			free_done: 
1631 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1634 39			      add   HL, SP 
1635 f9			      ld    SP, HL 
1636			 
1636			free_early_exit: 
1636 dd e1		      pop   IX 
1638 d1			      pop   DE 
1639 c1			      pop   BC 
163a			 
163a c9			      ret 
163b			 
163b			; moved to firmware.asm 
163b			; 
163b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
163b			;                  .dw   0 
163b			 
163b			 
163b			endif 
163b			 
163b			 
163b			if MALLOC_3 
163b			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
163b			;heap_start        .equ  0x9000      ; Starting address of heap 
163b			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
163b			; 
163b			 ;     .org 0 
163b			  ;    jp    main 
163b			; 
163b			; 
163b			 ;     .org  0x100 
163b			;main: 
163b			 ;     ld    HL, 0x8100 
163b			  ;    ld    SP, HL 
163b			; 
163b			;      call  heap_init 
163b			 
163b			      ; Make some allocations 
163b			;      ld    HL, 12 
163b			;      call  malloc            ; Allocates 0x9004 
163b			; 
163b			 ;     ld    HL, 12 
163b			;      call  malloc            ; Allocates 0x9014 
163b			 
163b			;      ld    HL, 12 
163b			;      call  malloc            ; Allocates 0x9024 
163b			 
163b			      ; Free some allocations 
163b			;      ld    HL, 0x9014 
163b			;      call  free 
163b			 
163b			;      ld    HL, 0x9004 
163b			;      call  free 
163b			; 
163b			;      ld    HL, 0x9024 
163b			;      call  free 
163b			 
163b			 
163b			 ;     halt 
163b			 
163b			 
163b			;------------------------------------------------------------------------------ 
163b			;     heap_init                                                               : 
163b			;                                                                             : 
163b			; Description                                                                 : 
163b			;     Initialise the heap and make it ready for malloc and free operations.   : 
163b			;                                                                             : 
163b			;     The heap is maintained as a linked list, starting with an initial       : 
163b			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
163b			;     the first free block in the heap. Each block then points to the next    : 
163b			;     free block within the heap, and the free list ends at the first block   : 
163b			;     with a null pointer to the next free block.                             : 
163b			;                                                                             : 
163b			; Parameters                                                                  : 
163b			;     Inputs are compile-time only. Two defines which specify the starting    : 
163b			;     address of the heap and its size are required, along with a memory      : 
163b			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
163b			;     principally stores a pointer to the first free block in the heap.       : 
163b			;                                                                             : 
163b			; Returns                                                                     : 
163b			;     Nothing                                                                 : 
163b			;------------------------------------------------------------------------------ 
163b			heap_init: 
163b			      push  HL 
163b			 
163b			      ; Initialise free list struct 
163b			      ld    HL, heap_start 
163b			      ld    (free_list), HL 
163b			      ld    HL, 0 
163b			      ld    (free_list+2), HL 
163b			 
163b			      ; Insert first free block at bottom of heap, consumes entire heap 
163b			      ld    HL, heap_start+heap_size-4 
163b			      ld    (heap_start), HL        ; Next block (end of free list) 
163b			      ld    HL, heap_size-4 
163b			      ld    (heap_start+2), HL      ; Block size 
163b			 
163b			      ; Insert end of free list block at top of heap - two null words will 
163b			      ; terminate the free list 
163b			      ld    HL, 0 
163b			      ld    (heap_start+heap_size-2), HL 
163b			      ld    (heap_start+heap_size-4), HL 
163b			 
163b			      pop   HL 
163b			 
163b			      ret 
163b			 
163b			 
163b			;------------------------------------------------------------------------------ 
163b			;     malloc                                                                  : 
163b			;                                                                             : 
163b			; Description                                                                 : 
163b			;     Allocates the wanted space from the heap and returns the address of the : 
163b			;     first useable byte of the allocation.                                   : 
163b			;                                                                             : 
163b			;     Allocations can happen in one of two ways:                              : 
163b			;                                                                             : 
163b			;     1. A free block may be found which is the exact size wanted. In this    : 
163b			;        case the block is removed from the free list and retuedn to the      : 
163b			;        caller.                                                              : 
163b			;     2. A free block may be found which is larger than the size wanted. In   : 
163b			;        this case, the larger block is split into two. The first portion of  : 
163b			;        this block will become the requested space by the malloc call and    : 
163b			;        is returned to the caller. The second portion becomes a new free     : 
163b			;        block, and the free list is adjusted to maintain continuity via this : 
163b			;        newly created block.                                                 : 
163b			;                                                                             : 
163b			;     malloc does not set any initial value in the allocated space, the       : 
163b			;     caller is required to do this as required.                              : 
163b			;                                                                             : 
163b			;     This implementation of malloc uses the stack exclusively, and is        : 
163b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
163b			;     advisable to disable interrupts before calling malloc, and recommended  : 
163b			;     to avoid the use of malloc inside ISRs in general.                      : 
163b			;                                                                             : 
163b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
163b			;                                                                             : 
163b			; Parameters                                                                  : 
163b			;     HL  Number of bytes wanted                                              : 
163b			;                                                                             : 
163b			; Returns                                                                     : 
163b			;     HL  Address of the first useable byte of the allocation                 : 
163b			;                                                                             : 
163b			; Flags                                                                       : 
163b			;     Z   Set if the allocation did not succeed, clear otherwise              : 
163b			;                                                                             : 
163b			; Stack frame                                                                 : 
163b			;       |             |                                                       : 
163b			;       +-------------+                                                       : 
163b			;       |     BC      |                                                       : 
163b			;       +-------------+                                                       : 
163b			;       |     DE      |                                                       : 
163b			;       +-------------+                                                       : 
163b			;       |     IX      |                                                       : 
163b			;       +-------------+                                                       : 
163b			;       |  prev_free  |                                                       : 
163b			;   +4  +-------------+                                                       : 
163b			;       |  this_free  |                                                       : 
163b			;   +2  +-------------+                                                       : 
163b			;       |  next_free  |                                                       : 
163b			;   +0  +-------------+                                                       : 
163b			;       |             |                                                       : 
163b			;                                                                             : 
163b			;------------------------------------------------------------------------------ 
163b			malloc: 
163b			      push  BC 
163b			      push  DE 
163b			      push  IX 
163b			 
163b			      ld    A, H                    ; Exit if no space requested 
163b			      or    L 
163b			      jp    Z, malloc_early_exit 
163b			 
163b			      ; Set up stack frame 
163b			      ex    DE, HL 
163b			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
163b			      add   HL, SP 
163b			      ld    SP, HL 
163b			      ld    IX, 0                   ; Use IX as a frame pointer 
163b			      add   IX, SP 
163b			 
163b			      ; Setup initial state 
163b			      ld    HL, 4                   ; want must also include space used by block struct 
163b			      add   HL, DE 
163b			 
163b			      ld    B, H                    ; Move want to BC 
163b			      ld    C, L 
163b			 
163b			      ld    HL, free_list           ; Store prev_free ptr to stack 
163b			      ld    (IX+4), L 
163b			      ld    (IX+5), H 
163b			 
163b			      ld    E, (HL)                 ; Store this_free ptr to stack 
163b			      inc   HL 
163b			      ld    D, (HL) 
163b			      ld    (IX+2), E 
163b			      ld    (IX+3), D 
163b			      ex    DE, HL                  ; this_free ptr into HL 
163b			 
163b			      ; Loop through free block list to find some space 
163b			malloc_find_space: 
163b			      ld    E, (HL)                 ; Load next_free ptr into DE 
163b			      inc   HL 
163b			      ld    D, (HL) 
163b			 
163b			      ld    A, D                    ; Check for null next_free ptr - end of free list 
163b			      or    E 
163b			      jp    Z, malloc_no_space 
163b			 
163b			      ld    (IX+0), E               ; Store next_free ptr to stack 
163b			      ld    (IX+1), D 
163b			 
163b			      ; Does this block have enough space to make the allocation? 
163b			      inc   HL                      ; Load free block size into DE 
163b			      ld    E, (HL) 
163b			      inc   HL 
163b			      ld    D, (HL) 
163b			 
163b			      ex    DE, HL                  ; Check size of block against want 
163b			      or    A                       ; Ensure carry flag clear 
163b			      sbc   HL, BC 
163b			      push  HL                      ; Store the result for later (new block size) 
163b			 
163b			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
163b			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
163b			 
163b			      ; this_free block is not big enough, setup ptrs to test next free block 
163b			      pop   HL                      ; Discard previous result 
163b			 
163b			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
163b			      ld    H, (IX+3) 
163b			      ld    (IX+4), L 
163b			      ld    (IX+5), H 
163b			 
163b			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
163b			      ld    H, (IX+1) 
163b			      ld    (IX+2), L 
163b			      ld    (IX+3), H 
163b			 
163b			      jr    malloc_find_space 
163b			 
163b			      ; split a bigger block into two - requested size and remaining size 
163b			malloc_alloc_split: 
163b			      ex    DE, HL                  ; Calculate address of new free block 
163b			      dec   HL 
163b			      dec   HL 
163b			      dec   HL 
163b			      add   HL, BC 
163b			 
163b			      ; Create a new block and point it at next_free 
163b			      ld    E, (IX+0)               ; Load next_free ptr into DE 
163b			      ld    D, (IX+1) 
163b			 
163b			      ld    (HL), E                 ; Store next_free ptr into new block 
163b			      inc   HL 
163b			      ld    (HL), D 
163b			 
163b			      pop   DE                      ; Store size of new block into new block 
163b			      inc   HL 
163b			      ld    (HL), E 
163b			      inc   HL 
163b			      ld    (HL), D 
163b			 
163b			      ; Update this_free ptr to point to new block 
163b			      dec   HL 
163b			      dec   HL 
163b			      dec   HL 
163b			 
163b			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
163b			      ld    D, (IX+3) 
163b			 
163b			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
163b			      ld    (IX+3), H 
163b			 
163b			      ; Modify this_free block to be allocation 
163b			      ex    DE, HL 
163b			      xor   A                       ; Null the next block ptr of allocated block 
163b			      ld    (HL), A 
163b			      inc   HL 
163b			      ld    (HL), A 
163b			 
163b			      inc   HL                      ; Store want size into allocated block 
163b			      ld    (HL), C 
163b			      inc   HL 
163b			      ld    (HL), B 
163b			      inc   HL 
163b			      push  HL                      ; Address of allocation to return 
163b			 
163b			      jr    malloc_update_links 
163b			 
163b			malloc_alloc_fit: 
163b			      pop   HL                      ; Dont need new block size, want is exact fit 
163b			 
163b			      ; Modify this_free block to be allocation 
163b			      ex    DE, HL 
163b			      dec   HL 
163b			      dec   HL 
163b			      dec   HL 
163b			 
163b			      xor   A                       ; Null the next block ptr of allocated block 
163b			      ld    (HL), A 
163b			      inc   HL 
163b			      ld    (HL), A 
163b			 
163b			      inc   HL                      ; Store address of allocation to return 
163b			      inc   HL 
163b			      inc   HL 
163b			      push  HL 
163b			 
163b			      ; Copy next_free ptr to this_free, remove allocated block from free list 
163b			      ld    L, (IX+0)               ; next_free to HL 
163b			      ld    H, (IX+1) 
163b			 
163b			      ld    (IX+2), L               ; HL to this_free 
163b			      ld    (IX+3), H 
163b			 
163b			 
163b			malloc_update_links: 
163b			      ; Update prev_free ptr to point to this_free 
163b			      ld    L, (IX+4)               ; prev_free ptr to HL 
163b			      ld    H, (IX+5) 
163b			 
163b			      ld    E, (IX+2)               ; this_free ptr to DE 
163b			      ld    D, (IX+3) 
163b			 
163b			      ld    (HL), E                 ; this_free ptr into prev_free 
163b			      inc   HL 
163b			      ld    (HL), D 
163b			 
163b			      ; Clear the Z flag to indicate successful allocation 
163b			      ld    A, D 
163b			      or    E 
163b			 
163b			      pop   DE                      ; Address of allocation 
163b			 
163b			malloc_no_space: 
163b			      ld    HL, 6                   ; Clean up stack frame 
163b			      add   HL, SP 
163b			      ld    SP, HL 
163b			 
163b			      ex    DE, HL                  ; Alloc addr into HL for return 
163b			 
163b			malloc_early_exit: 
163b			      pop   IX 
163b			      pop   DE 
163b			      pop   BC 
163b			 
163b			      ret 
163b			 
163b			 
163b			;------------------------------------------------------------------------------ 
163b			;     free                                                                    : 
163b			;                                                                             : 
163b			; Description                                                                 : 
163b			;     Return the space pointed to by HL to the heap. HL must be an address as : 
163b			;     returned by malloc, otherwise the behaviour is undefined.               : 
163b			;                                                                             : 
163b			;     Where possible, directly adjacent free blocks will be merged together   : 
163b			;     into larger blocks to help ensure that the heap does not become         : 
163b			;     excessively fragmented.                                                 : 
163b			;                                                                             : 
163b			;     free does not clear or set any other value into the freed space, and    : 
163b			;     therefore its contents may be visible through subsequent malloc's. The  : 
163b			;     caller should clear the freed space as required.                        : 
163b			;                                                                             : 
163b			;     This implementation of free uses the stack exclusively, and is          : 
163b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
163b			;     advisable to disable interrupts before calling free, and recommended    : 
163b			;     to avoid the use of free inside ISRs in general.                        : 
163b			;                                                                             : 
163b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
163b			;                                                                             : 
163b			; Parameters                                                                  : 
163b			;     HL  Pointer to address of first byte of allocation to be freed          : 
163b			;                                                                             : 
163b			; Returns                                                                     : 
163b			;     Nothing                                                                 : 
163b			;                                                                             : 
163b			; Stack frame                                                                 : 
163b			;       |             |                                                       : 
163b			;       +-------------+                                                       : 
163b			;       |     BC      |                                                       : 
163b			;       +-------------+                                                       : 
163b			;       |     DE      |                                                       : 
163b			;       +-------------+                                                       : 
163b			;       |     IX      |                                                       : 
163b			;       +-------------+                                                       : 
163b			;       |  prev_free  |                                                       : 
163b			;   +2  +-------------+                                                       : 
163b			;       |  next_free  |                                                       : 
163b			;   +0  +-------------+                                                       : 
163b			;       |             |                                                       : 
163b			;                                                                             : 
163b			;------------------------------------------------------------------------------ 
163b			free: 
163b			      push  BC 
163b			      push  DE 
163b			      push  IX 
163b			 
163b			      ld    A, H                    ; Exit if ptr is null 
163b			      or    L 
163b			      jp    Z, free_early_exit 
163b			 
163b			      ; Set up stack frame 
163b			      ex    DE, HL 
163b			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
163b			      add   HL, SP 
163b			      ld    SP, HL 
163b			      ld    IX, 0                   ; Use IX as a frame pointer 
163b			      add   IX, SP 
163b			 
163b			      ; The address in HL points to the start of the useable allocated space, 
163b			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
163b			      ; address of the block itself. 
163b			      ex    DE, HL 
163b			      ld    DE, -4 
163b			      add   HL, DE 
163b			 
163b			      ; An allocated block must have a null next block pointer in it 
163b			      ld    A, (HL) 
163b			      inc   HL 
163b			      or    (HL) 
163b			      jp    NZ, free_done 
163b			 
163b			      dec   HL 
163b			 
163b			      ld    B, H                    ; Copy HL to BC 
163b			      ld    C, L 
163b			 
163b			      ; Loop through the free list to find the first block with an address 
163b			      ; higher than the block being freed 
163b			      ld    HL, free_list 
163b			 
163b			free_find_higher_block: 
163b			      ld    E, (HL)                 ; Load next ptr from free block 
163b			      inc   HL 
163b			      ld    D, (HL) 
163b			      dec   HL 
163b			 
163b			      ld    (IX+0), E               ; Save ptr to next free block 
163b			      ld    (IX+1), D 
163b			      ld    (IX+2), L               ; Save ptr to prev free block 
163b			      ld    (IX+3), H 
163b			 
163b			      ld    A, B                    ; Check if DE is greater than BC 
163b			      cp    D                       ; Compare MSB first 
163b			      jr    Z, $+4                  ; MSB the same, compare LSB 
163b			      jr    NC, free_find_higher_block_skip 
163b			      ld    A, C 
163b			      cp    E                       ; Then compare LSB 
163b			      jr    C, free_found_higher_block 
163b			 
163b			free_find_higher_block_skip: 
163b			      ld    A, D                    ; Reached the end of the free list? 
163b			      or    E 
163b			      jp    Z, free_done 
163b			 
163b			      ex    DE, HL 
163b			 
163b			      jr    free_find_higher_block 
163b			 
163b			free_found_higher_block: 
163b			      ; Insert freed block between prev and next free blocks 
163b			      ld    (HL), C                 ; Point prev free block to freed block 
163b			      inc   HL 
163b			      ld    (HL), B 
163b			 
163b			      ld    H, B                    ; Point freed block at next free block 
163b			      ld    L, C 
163b			      ld    (HL), E 
163b			      inc   HL 
163b			      ld    (HL), D 
163b			 
163b			      ; Check if the freed block is adjacent to the next free block 
163b			      inc   HL                      ; Load size of freed block into HL 
163b			      ld    E, (HL) 
163b			      inc   HL 
163b			      ld    D, (HL) 
163b			      ex    DE, HL 
163b			 
163b			      add   HL, BC                  ; Add addr of freed block and its size 
163b			 
163b			      ld    E, (IX+0)               ; Load addr of next free block into DE 
163b			      ld    D, (IX+1) 
163b			 
163b			      or    A                       ; Clear the carry flag 
163b			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
163b			      jr    NZ, free_check_adjacent_to_prev 
163b			 
163b			      ; Freed block is adjacent to next, merge into one bigger block 
163b			      ex    DE, HL                  ; Load next ptr from next block into DE 
163b			      ld    E, (HL) 
163b			      inc   HL 
163b			      ld    D, (HL) 
163b			      push  HL                      ; Save ptr to next block for later 
163b			 
163b			      ld    H, B                    ; Store ptr from next block into freed block 
163b			      ld    L, C 
163b			      ld    (HL), E 
163b			      inc   HL 
163b			      ld    (HL), D 
163b			 
163b			      pop   HL                      ; Restore ptr to next block 
163b			      inc   HL                      ; Load size of next block into DE 
163b			      ld    E, (HL) 
163b			      inc   HL 
163b			      ld    D, (HL) 
163b			      push  DE                      ; Save next block size for later 
163b			 
163b			      ld    H, B                    ; Load size of freed block into HL 
163b			      ld    L, C 
163b			      inc   HL 
163b			      inc   HL 
163b			      ld    E, (HL) 
163b			      inc   HL 
163b			      ld    D, (HL) 
163b			      ex    DE, HL 
163b			 
163b			      pop   DE                      ; Restore size of next block 
163b			      add   HL, DE                  ; Add sizes of both blocks 
163b			      ex    DE, HL 
163b			 
163b			      ld    H, B                    ; Store new bigger size into freed block 
163b			      ld    L, C 
163b			      inc   HL 
163b			      inc   HL 
163b			      ld    (HL), E 
163b			      inc   HL 
163b			      ld    (HL), D 
163b			 
163b			free_check_adjacent_to_prev: 
163b			      ; Check if the freed block is adjacent to the prev free block 
163b			      ld    L, (IX+2)               ; Prev free block ptr into HL 
163b			      ld    H, (IX+3) 
163b			 
163b			      inc   HL                      ; Size of prev free block into DE 
163b			      inc   HL 
163b			      ld    E, (HL) 
163b			      inc   HL 
163b			      ld    D, (HL) 
163b			      dec   HL 
163b			      dec   HL 
163b			      dec   HL 
163b			 
163b			      add   HL, DE                  ; Add prev block addr and size 
163b			 
163b			      or    A                       ; Clear the carry flag 
163b			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
163b			      jr    NZ, free_done 
163b			 
163b			      ; Freed block is adjacent to prev, merge into one bigger block 
163b			      ld    H, B                    ; Load next ptr from freed block into DE 
163b			      ld    L, C 
163b			      ld    E, (HL) 
163b			      inc   HL 
163b			      ld    D, (HL) 
163b			      push  HL                      ; Save freed block ptr for later 
163b			 
163b			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
163b			      ld    H, (IX+3) 
163b			      ld    (HL), E 
163b			      inc   HL 
163b			      ld    (HL), D 
163b			 
163b			      pop   HL                      ; Restore freed block ptr 
163b			      inc   HL                      ; Load size of freed block into DE 
163b			      ld    E, (HL) 
163b			      inc   HL 
163b			      ld    D, (HL) 
163b			      push  DE                      ; Save freed block size for later 
163b			 
163b			      ld    L, (IX+2)               ; Load size of prev block into DE 
163b			      ld    H, (IX+3) 
163b			      inc   HL 
163b			      inc   HL 
163b			      ld    E, (HL) 
163b			      inc   HL 
163b			      ld    D, (HL) 
163b			 
163b			      pop   HL                      ; Add sizes of both blocks 
163b			      add   HL, DE 
163b			      ex    DE, HL 
163b			 
163b			      ld    L, (IX+2)               ; Store new bigger size into prev block 
163b			      ld    H, (IX+3) 
163b			      inc   HL 
163b			      inc   HL 
163b			      ld    (HL), E 
163b			      inc   HL 
163b			      ld    (HL), D 
163b			 
163b			free_done: 
163b			      ld    HL, 4                   ; Clean up stack frame 
163b			      add   HL, SP 
163b			      ld    SP, HL 
163b			 
163b			free_early_exit: 
163b			      pop   IX 
163b			      pop   DE 
163b			      pop   BC 
163b			 
163b			      ret 
163b			 
163b			 
163b			;      .org 0x8000 
163b			; 
163b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
163b			 ;                 .dw   0 
163b			 
163b			endif 
163b			 
163b			 
163b			if MALLOC_4 
163b			 
163b			; My memory allocation code. Very very simple.... 
163b			; allocate space under 250 chars 
163b			 
163b			heap_init: 
163b				; init start of heap as zero 
163b				;  
163b			 
163b				ld hl, heap_start 
163b				ld a, 0 
163b				ld (hl), a      ; empty block 
163b				inc hl 
163b				ld a, 0 
163b				ld (hl), a      ; length of block 
163b				; write end of list 
163b				inc hl 
163b				ld a,(hl) 
163b				inc hl 
163b				ld a,(hl) 
163b				 
163b			 
163b				; init some malloc vars 
163b			 
163b				ld hl, 0 
163b				ld (free_list), hl       ; store last malloc location 
163b			 
163b				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
163b				ld a, 0 
163b				ld (hl), a 
163b			 
163b			 
163b				ld hl, heap_start 
163b				;  
163b				  
163b				ret 
163b			 
163b			 
163b			;    free block marker 
163b			;    requested size  
163b			;    pointer to next block 
163b			;    .... 
163b			;    next block marker 
163b			 
163b			 
163b			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
163b			; 
163b			 
163b			 
163b			malloc:  
163b				push de 
163b				push bc 
163b				push af 
163b			 
163b				; hl space required 
163b				 
163b				ld c, l    ; hold space   (TODO only a max of 255) 
163b			 
163b			;	inc c     ; TODO BUG need to fix memory leak on push str 
163b			;	inc c 
163b			;	inc c 
163b			;	inc c 
163b			;	inc c 
163b			;	inc c 
163b			;	inc c 
163b			 
163b			 
163b			 
163b				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
163b			 
163b				ld a, (free_list+3) 
163b				cp 0 
163b				jr z, .contheap 
163b			 
163b				ld hl, (free_list)     ; get last alloc 
163b					if DEBUG_FORTH_MALLOC_INT 
163b						DMARK "mrs" 
163b						CALLMONITOR 
163b					endif 
163b				jr .startalloc 
163b			 
163b			.contheap: 
163b				ld hl, heap_start 
163b			 
163b			.startalloc: 
163b			 
163b					if DEBUG_FORTH_MALLOC_INT 
163b						DMARK "mym" 
163b						CALLMONITOR 
163b					endif 
163b			.findblock: 
163b					if DEBUG_FORTH_MALLOC_INT 
163b						DMARK "mmf" 
163b						CALLMONITOR 
163b					endif 
163b			 
163b				ld a,(hl)  
163b				; if byte is zero then clear to use 
163b			 
163b				cp 0 
163b				jr z, .foundemptyblock 
163b			 
163b				; if byte is not clear 
163b				;     then byte is offset to next block 
163b			 
163b				inc hl 
163b				ld a, (hl) ; get size 
163b			.nextblock:	inc hl 
163b					ld e, (hl) 
163b					inc hl 
163b					ld d, (hl) 
163b					ex de, hl 
163b			;	inc hl  ; move past the store space 
163b			;	inc hl  ; move past zero index  
163b			 
163b				; TODO detect no more space 
163b			 
163b				push hl 
163b				ld de, heap_end 
163b				call cmp16 
163b				pop hl 
163b				jr nc, .nospace 
163b			 
163b				jr .findblock 
163b			 
163b			.nospace: ld hl, 0 
163b				jp .exit 
163b			 
163b			 
163b			.foundemptyblock:	 
163b					if DEBUG_FORTH_MALLOC_INT 
163b						DMARK "mme" 
163b						CALLMONITOR 
163b					endif 
163b			 
163b			; TODO has block enough space if reusing??? 
163b			 
163b				;  
163b			 
163b			; see if this block has been previously used 
163b				inc hl 
163b				ld a, (hl) 
163b				dec hl 
163b				cp 0 
163b				jr z, .newblock 
163b			 
163b					if DEBUG_FORTH_MALLOC_INT 
163b						DMARK "meR" 
163b						CALLMONITOR 
163b					endif 
163b			 
163b			; no reusing previously allocated block 
163b			 
163b			; is it smaller than previously used? 
163b				 
163b				inc hl    ; move to size 
163b				ld a, c 
163b				sub (hl)        ; we want c < (hl) 
163b				dec hl    ; move back to marker 
163b			        jr z, .findblock 
163b			 
163b				; update with the new size which should be lower 
163b			 
163b			        ;inc  hl   ; negate next move. move back to size  
163b			 
163b			.newblock: 
163b				; need to be at marker here 
163b			 
163b					if DEBUG_FORTH_MALLOC_INT 
163b						DMARK "meN" 
163b						CALLMONITOR 
163b					endif 
163b			 
163b			 
163b				ld a, c 
163b			 
163b				ld (free_list+3), a	 ; flag resume from last malloc  
163b				ld (free_list), hl    ; save out last location 
163b			 
163b			 
163b				;inc a     ; space for length byte 
163b				ld (hl), a     ; save block in use marker 
163b			 
163b				inc hl   ; move to space marker 
163b				ld (hl), a    ; save new space 
163b			 
163b				inc hl   ; move to start of allocated area 
163b				 
163b			;	push hl     ; save where we are - 1  
163b			 
163b			;	inc hl  ; move past zero index  
163b				; skip space to set down new marker 
163b			 
163b				; provide some extra space for now 
163b			 
163b				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
163b				inc a 
163b				inc a 
163b			 
163b				push hl   ; save where we are in the node block 
163b			 
163b				call addatohl 
163b			 
163b				; write linked list point 
163b			 
163b				pop de     ; get our node position 
163b				ex de, hl 
163b			 
163b				ld (hl), e 
163b				inc hl 
163b				ld (hl), d 
163b			 
163b				inc hl 
163b			 
163b				; now at start of allocated data so save pointer 
163b			 
163b				push hl 
163b			 
163b				; jump to position of next node and setup empty header in DE 
163b			 
163b				ex de, hl 
163b			 
163b			;	inc hl ; move past end of block 
163b			 
163b				ld a, 0 
163b				ld (hl), a   ; empty marker 
163b				inc hl 
163b				ld (hl), a   ; size 
163b				inc hl  
163b				ld (hl), a   ; ptr 
163b				inc hl 
163b				ld (hl), a   ; ptr 
163b			 
163b			 
163b				pop hl 
163b			 
163b					if DEBUG_FORTH_MALLOC_INT 
163b						DMARK "mmr" 
163b						CALLMONITOR 
163b					endif 
163b			 
163b			.exit: 
163b				pop af 
163b				pop bc 
163b				pop de  
163b				ret 
163b			 
163b			 
163b			 
163b			 
163b			free:  
163b				push hl 
163b				push af 
163b				; get address in hl 
163b			 
163b					if DEBUG_FORTH_MALLOC_INT 
163b						DMARK "fre" 
163b						CALLMONITOR 
163b					endif 
163b				; data is at hl - move to block count 
163b				dec hl 
163b				dec hl    ; get past pointer 
163b				dec hl 
163b			 
163b				ld a, (hl)    ; need this for a validation check 
163b			 
163b				dec hl    ; move to block marker 
163b			 
163b				; now check that the block count and block marker are the same  
163b			        ; this checks that we are on a malloc node and not random memory 
163b			        ; OK a faint chance this could be a problem but rare - famous last words! 
163b			 
163b				ld c, a 
163b				ld a, (hl)    
163b			 
163b				cp c 
163b				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
163b			 
163b				; yes good chance we are on a malloc node 
163b			 
163b				ld a, 0      
163b				ld (hl), a   ; mark as free 
163b			 
163b				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
163b			 
163b			.freeignore:  
163b			 
163b				pop af 
163b				pop hl 
163b			 
163b				ret 
163b			 
163b			 
163b			 
163b			endif 
163b			 
163b			; eof 
# End of file firmware_memory.asm
163b			  
163b			; device C  
163b			; Now handled by SPI  
163b			;if SOUND_ENABLE  
163b			;	include "firmware_sound.asm"  
163b			;endif  
163b			  
163b			include "firmware_diags.asm"  
163b			; Hardware diags menu 
163b			 
163b			 
163b			config: 
163b			 
163b 3e 00			ld a, 0 
163d 21 66 16			ld hl, .configmn 
1640 cd cc 0d			call menu 
1643			 
1643 fe 00			cp 0 
1645 c8				ret z 
1646			 
1646			;	cp 1 
1646			;	call z, .savetostore 
1646			 
1646 fe 01			cp 1 
1648			if STARTUP_V1 
1648				call z, .selautoload 
1648			endif 
1648			 
1648			if STARTUP_V2 
1648 cc 74 16			call z, .enautoload 
164b			endif 
164b fe 02			cp 2 
164d cc 8b 16			call z, .disautoload 
1650			;	cp 3 
1650			;	call z, .selbank 
1650 fe 03			cp 3 
1652 cc f9 18			call z, .debug_tog 
1655 fe 04			cp 4 
1657 cc 47 1a			call z, .bpsgo 
165a fe 05			cp 5 
165c cc 22 19			call z, hardware_diags 
165f			if STARTUP_V2 
165f fe 06			cp 6 
1661 cc b7 16			call z, create_startup 
1664			endif 
1664 18 d5			jr config 
1666			 
1666			.configmn: 
1666			;	dw prom_c3 
1666 35 1c			dw prom_c2 
1668 4b 1c			dw prom_c2a 
166a			;	dw prom_c2b 
166a			;	dw prom_c4 
166a b8 1c			dw prom_m4 
166c d3 1c			dw prom_m4b 
166e db 1c			dw prom_c1 
1670			if STARTUP_V2 
1670 ea 1c			dw prom_c9 
1672			endif 
1672 00 00			dw 0 
1674				 
1674			 
1674			if STARTUP_V2 
1674			.enautoload: 
1674				if STORAGE_SE 
1674 3e fe			ld a, $fe      ; bit 0 clear 
1676 32 9b f9			ld (spi_device), a 
1679			 
1679 cd 16 05			call storage_get_block_0 
167c			 
167c 3e 01			ld a, 1 
167e 32 d6 f9			ld (store_page+STORE_0_AUTOFILE), a 
1681			 
1681 21 00 00				ld hl, 0 
1684 11 b5 f9				ld de, store_page 
1687 cd ca 04			call storage_write_block	 ; save update 
168a				else 
168a			 
168a				ld hl, prom_notav 
168a				ld de, prom_empty 
168a				call info_panel 
168a				endif 
168a			 
168a			 
168a c9				ret 
168b			endif 
168b			 
168b			.disautoload: 
168b				if STORAGE_SE 
168b 3e fe			ld a, $fe      ; bit 0 clear 
168d 32 9b f9			ld (spi_device), a 
1690			 
1690 cd 16 05			call storage_get_block_0 
1693			 
1693 3e 00			ld a, 0 
1695 32 d6 f9			ld (store_page+STORE_0_AUTOFILE), a 
1698			 
1698 21 00 00				ld hl, 0 
169b 11 b5 f9				ld de, store_page 
169e cd ca 04			call storage_write_block	 ; save update 
16a1				else 
16a1			 
16a1				ld hl, prom_notav 
16a1				ld de, prom_empty 
16a1				call info_panel 
16a1				endif 
16a1			 
16a1			 
16a1 c9				ret 
16a2			 
16a2			if STARTUP_V1 
16a2			 
16a2			; Select auto start 
16a2			 
16a2			.selautoload: 
16a2			 
16a2				 
16a2				if STORAGE_SE 
16a2			 
16a2					call config_dir 
16a2				        ld hl, scratch 
16a2					ld a, 0 
16a2					call menu 
16a2			 
16a2					cp 0 
16a2					ret z 
16a2			 
16a2					dec a 
16a2			 
16a2			 
16a2					; locate menu option 
16a2			 
16a2					ld hl, scratch 
16a2					call table_lookup 
16a2			 
16a2					if DEBUG_FORTH_WORDS 
16a2						DMARK "ALl" 
16a2						CALLMONITOR 
16a2					endif 
16a2					; with the pointer to the menu it, the byte following the zero term is the file id 
16a2			 
16a2					ld a, 0 
16a2					ld bc, 50   ; max of bytes to look at 
16a2					cpir  
16a2			 
16a2					if DEBUG_FORTH_WORDS 
16a2						DMARK "ALb" 
16a2						CALLMONITOR 
16a2					endif 
16a2					;inc hl 
16a2			 
16a2					ld a, (hl)   ; file id 
16a2					 
16a2				        ; save bank and file ids 
16a2			 
16a2					push af 
16a2			 
16a2			; TODO need to save to block 0 on bank 1	 
16a2			 
16a2					call storage_get_block_0 
16a2			 
16a2					if DEBUG_FORTH_WORDS 
16a2						DMARK "AL0" 
16a2						CALLMONITOR 
16a2					endif 
16a2					pop af 
16a2			 
16a2					ld (store_page+STORE_0_FILERUN),a 
16a2					 
16a2					; save bank id 
16a2			 
16a2					ld a,(spi_device) 
16a2					ld (store_page+STORE_0_BANKRUN),a 
16a2			 
16a2					; enable auto run of store file 
16a2			 
16a2					ld a, 1 
16a2					ld (store_page+STORE_0_AUTOFILE),a 
16a2			 
16a2					; save buffer 
16a2			 
16a2					ld hl, 0 
16a2					ld de, store_page 
16a2					if DEBUG_FORTH_WORDS 
16a2						DMARK "ALw" 
16a2						CALLMONITOR 
16a2					endif 
16a2				call storage_write_block	 ; save update 
16a2			  
16a2			 
16a2			 
16a2			 
16a2					ld hl, scratch 
16a2					call config_fdir 
16a2			 
16a2				else 
16a2			 
16a2				ld hl, prom_notav 
16a2				ld de, prom_empty 
16a2				call info_panel 
16a2			 
16a2				endif 
16a2				ret 
16a2			endif 
16a2			 
16a2			 
16a2			; Select storage bank 
16a2			 
16a2			.selbank: 
16a2			 
16a2			;	if STORAGE_SE 
16a2			;	else 
16a2			 
16a2 21 ff 1c			ld hl, prom_notav 
16a5 11 15 1d			ld de, prom_empty 
16a8 cd 2c 0d			call info_panel 
16ab			;	endif 
16ab				 
16ab c9				ret 
16ac			 
16ac			if STORAGE_SE 
16ac			 
16ac			.config_ldir:   
16ac				; Load storage bank labels into menu array 
16ac			 
16ac				 
16ac			 
16ac			 
16ac c9				ret 
16ad			 
16ad			 
16ad			endif 
16ad			 
16ad			 
16ad			; Save user words to storage 
16ad			 
16ad			.savetostore: 
16ad			 
16ad			;	if STORAGE_SE 
16ad			; 
16ad			;		call config_dir 
16ad			;	        ld hl, scratch 
16ad			;		ld a, 0 
16ad			;		call menu 
16ad			;		 
16ad			;		ld hl, scratch 
16ad			;		call config_fdir 
16ad			; 
16ad			;	else 
16ad			 
16ad 21 ff 1c			ld hl, prom_notav 
16b0 11 15 1d			ld de, prom_empty 
16b3 cd 2c 0d			call info_panel 
16b6			 
16b6			;	endif 
16b6			 
16b6 c9				ret 
16b7			 
16b7			if STARTUP_V2 
16b7			 
16b7			create_startup: 
16b7			 
16b7 3e 00			ld a, 0 
16b9 21 20 18			ld hl, .crstart 
16bc cd cc 0d			call menu 
16bf			 
16bf fe 00			cp 0 
16c1 c8				ret z 
16c2			 
16c2 fe 01			cp 1 
16c4 cc f1 16			call z, .genlsword 
16c7 fe 02			cp 2 
16c9 cc fb 16			call z, .genedword 
16cc			 
16cc fe 03			cp 3 
16ce cc 05 17			call z, .gendemword 
16d1			 
16d1 fe 04			cp 4 
16d3 cc 0f 17			call z, .genutlword 
16d6 fe 05			cp 5 
16d8 cc 19 17			call z, .genspiword 
16db fe 06			cp 6 
16dd cc 23 17			call z, .genkeyword 
16e0 fe 07			cp 7 
16e2 cc e7 16			call z, .gensoundword 
16e5 18 d0			jr create_startup 
16e7			 
16e7			.gensoundword: 
16e7 21 a3 1c			ld hl, crs_sound 
16ea 11 70 17			ld de, .soundworddef 
16ed cd 2d 17			call .genfile 
16f0 c9				ret 
16f1			.genlsword: 
16f1 21 62 1c			ld hl, crs_s1 
16f4 11 94 17			ld de, .lsworddef 
16f7 cd 2d 17			call .genfile 
16fa c9				ret 
16fb			 
16fb			.genedword: 
16fb 11 98 17			ld de, .edworddef 
16fe 21 6b 1c			ld hl, crs_s2 
1701 cd 2d 17			call .genfile 
1704 c9				ret 
1705			 
1705			.gendemword: 
1705 11 a0 17			ld de, .demoworddef 
1708 21 74 1c			ld hl, crs_s3 
170b cd 2d 17			call .genfile 
170e c9				ret 
170f			 
170f			.genutlword: 
170f 21 83 1c			ld hl, crs_s4 
1712 11 84 17			ld de, .utilwordef 
1715 cd 2d 17			call .genfile 
1718 c9				ret 
1719			.genspiword: 
1719 21 8a 1c			ld hl, crs_s5 
171c 11 e6 17			ld de, .spiworddef 
171f cd 2d 17			call .genfile 
1722 c9				ret 
1723			.genkeyword: 
1723 21 94 1c			ld hl, crs_s6 
1726 11 f4 17			ld de, .keyworddef 
1729 cd 2d 17			call .genfile 
172c c9				ret 
172d			 
172d			; hl - points to file name 
172d			; de - points to strings to add to file 
172d			 
172d			.genfile: 
172d e5				push hl 
172e d5				push de 
172f			 
172f cd 9b 0d			call clear_display 
1732 3e 00			ld a, display_row_1 
1734 11 5f 17			ld de, .genfiletxt 
1737 cd ae 0d			call str_at_display 
173a cd be 0d			call update_display 
173d			 
173d d1				pop de 
173e e1				pop hl 
173f			 
173f			 
173f d5				push de 
1740 cd 68 08			call storage_create 
1743				; id in hl 
1743 d1				pop de   ; table of strings to add 
1744			 
1744			.genloop: 
1744			 
1744 e5				push hl ; save id for next time around 
1745 d5				push de ; save de for next time around 
1746			 
1746 eb				ex de, hl 
1747 cd 32 24			call loadwordinhl 
174a eb				ex de, hl 
174b			 
174b				; need hl to be the id 
174b				; need de to be the string ptr 
174b				 
174b cd 55 0b			call storage_append 
174e			 
174e d1				pop de 
174f e1				pop hl 
1750			 
1750 13				inc de 
1751 13				inc de 
1752			 
1752 1a				ld a,(de) 
1753 fe 00			cp 0 
1755 20 ed			jr nz, .genloop 
1757 13				inc de 
1758 1a				ld a, (de) 
1759 1b				dec de 
175a fe 00			cp 0 
175c 20 e6			jr nz, .genloop	 
175e			 
175e c9				ret 
175f			 
175f .. 00		.genfiletxt:  db "Creating file...",0 
1770			 
1770			.soundworddef: 
1770 bb 6a			dw sound1 
1772 df 6a			dw sound2 
1774 0f 6b			dw sound3 
1776 34 6b			dw sound4 
1778 41 6b			dw sound5 
177a 4e 6b			dw sound6 
177c 5b 6b			dw sound7 
177e 68 6b			dw sound8 
1780 80 6b			dw sound9 
1782 00 00			dw 0 
1784			 
1784			.utilwordef: 
1784 0c 64			dw strncpy 
1786 e7 63			dw type 
1788 b3 63			dw clrstack 
178a 6c 63			dw longread 
178c 6d 64			dw start1 
178e 7d 64			dw start2 
1790			; duplicated 
1790			;	dw start3b 
1790			;	dw start3c 
1790 69 65			dw list 
1792 00 00			dw 0 
1794			 
1794			.lsworddef: 
1794 8e 64			dw start3b 
1796 00 00			dw 0 
1798			 
1798			.edworddef: 
1798 cb 5f			dw edit1 
179a ec 5f			dw edit2 
179c 21 60			dw edit3 
179e 00 00			dw 0 
17a0			 
17a0			.demoworddef: 
17a0 b1 69			dw test5 
17a2 e9 69			dw test6 
17a4 21 6a			dw test7 
17a6 35 6a			dw test8 
17a8 61 6a			dw test9 
17aa 77 6a			dw test10 
17ac 97 6b			dw game1 
17ae a8 6b			dw game1a 
17b0 0a 6c			dw game1b 
17b2 3f 6c			dw game1c 
17b4 75 6c			dw game1d 
17b6 a6 6c			dw game1s 
17b8 ba 6c			dw game1t 
17ba cf 6c			dw game1f 
17bc 03 6d			dw game1z 
17be 47 6d			dw game1zz 
17c0 b0 6d			dw ssv2 
17c2 e6 6d			dw ssv3 
17c4 02 6e			dw ssv4 
17c6 1e 6e			dw ssv5 
17c8 37 6e			dw ssv1 
17ca 7f 6e			dw ssv1cpm	 
17cc d6 6e			dw game2b 
17ce 44 6f			dw game2bf 
17d0 8e 6f			dw game2mba 
17d2 24 70			dw game2mbas	 
17d4 49 70			dw game2mbht 
17d6 58 70			dw game2mbms 
17d8 66 70			dw game2mb 
17da e3 70			dw game3w 
17dc 11 71			dw game3p 
17de 2f 71			dw game3sc 
17e0 60 71			dw game3vsi 
17e2 8c 71			dw game3vs 
17e4 00 00			dw 0 
17e6			 
17e6			 
17e6			.spiworddef: 
17e6			 
17e6 59 60		    dw spi1 
17e8 b2 60		    dw spi2 
17ea e6 60		    dw spi2b 
17ec 6a 61		    dw spi3 
17ee 14 61		    dw spi4 
17f0 3d 61		    dw spi5 
17f2			;    dw spi6 
17f2			;    dw spi7 
17f2			 
17f2			;    dw spi8 
17f2			;    dw spi9 
17f2			;    dw spi10 
17f2 00 00		    dw 0 
17f4			 
17f4			.keyworddef: 
17f4			 
17f4 cb 71			dw keyup 
17f6 d9 71			dw keydown 
17f8 e9 71			dw keyleft 
17fa f9 71			dw keyright 
17fc 0a 72			dw 	keyf1 
17fe 18 72			dw keyf2 
1800 26 72			dw keyf3 
1802 34 72			dw keyf4 
1804 42 72			dw keyf5 
1806 50 72			dw keyf6 
1808 5e 72			dw keyf7 
180a 6c 72			dw keyf8 
180c 7a 72			dw keyf9 
180e 88 72			dw keyf10 
1810 97 72			dw keyf11 
1812 a6 72			dw keyf12 
1814 b5 72			dw keytab 
1816 c4 72			dw keycr 
1818 d2 72			dw keyhome 
181a e2 72			dw keyend 
181c f1 72			dw keybs 
181e 00 00			dw 0 
1820			 
1820			.crstart: 
1820 62 1c			dw crs_s1 
1822 6b 1c			dw crs_s2 
1824 74 1c			dw crs_s3 
1826 83 1c			dw crs_s4 
1828 8a 1c			dw crs_s5 
182a 94 1c			dw crs_s6 
182c a3 1c			dw crs_sound 
182e 00 00			dw 0 
1830			 
1830			endif 
1830			 
1830			 
1830			if STORAGE_SE 
1830			 
1830			config_fdir: 
1830				; using the scratch dir go through and release the memory allocated for each string 
1830				 
1830 21 fc f0			ld hl, scratch 
1833 5e			.cfdir:	ld e,(hl) 
1834 23				inc hl 
1835 56				ld d,(hl) 
1836 23				inc hl 
1837			 
1837 eb				ex de, hl 
1838 cd f8 0f			call ishlzero 
183b c8				ret z     ; return on null pointer 
183c cd 6c 15			call free 
183f eb				ex de, hl 
1840 18 f1			jr .cfdir 
1842			 
1842			 
1842 c9				ret 
1843			 
1843			 
1843			config_dir: 
1843			 
1843				; for the config menus that need to build a directory of storage call this routine 
1843				; it will construct a menu in scratch to pass to menu 
1843			 
1843				; open storage device 
1843			 
1843				; execute DIR to build a list of files and their ids into scratch in menu format 
1843				; once the menu has finished then will need to call config_fdir to release the strings 
1843				 
1843				; c = number items 
1843			 
1843				 
1843 cd 16 05			call storage_get_block_0 
1846			 
1846 21 b5 f9			ld hl, store_page     ; get current id count 
1849 46				ld b, (hl) 
184a 0e 00			ld c, 0    ; count of files   
184c			 
184c			 
184c 21 fc f0			ld hl, scratch 
184f 22 ac f9			ld (store_tmp2), hl    ; location to poke strings 
1852			 
1852				; check for empty drive 
1852			 
1852 3e 00			ld a, 0 
1854 b8				cp b 
1855 ca ef 18			jp z, .dirdone 
1858			 
1858				 
1858					if DEBUG_FORTH_WORDS 
1858						DMARK "Cdc" 
1858 f5				push af  
1859 3a 6d 18			ld a, (.dmark)  
185c 32 a6 fd			ld (debug_mark),a  
185f 3a 6e 18			ld a, (.dmark+1)  
1862 32 a7 fd			ld (debug_mark+1),a  
1865 3a 6f 18			ld a, (.dmark+2)  
1868 32 a8 fd			ld (debug_mark+2),a  
186b 18 03			jr .pastdmark  
186d ..			.dmark: db "Cdc"  
1870 f1			.pastdmark: pop af  
1871			endm  
# End of macro DMARK
1871						CALLMONITOR 
1871 cd aa fd			call debug_vector  
1874				endm  
# End of macro CALLMONITOR
1874					endif 
1874			 
1874			 
1874			.diritem:	 
1874 c5				push bc 
1875				; for each of the current ids do a search for them and if found push to stack 
1875			 
1875 21 40 00				ld hl, STORE_BLOCK_PHY 
1878 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
187a 58					ld e,b 
187b			 
187b cd 98 07				call storage_findnextid 
187e			 
187e			 
187e					; if found hl will be non zero 
187e			 
187e cd f8 0f				call ishlzero 
1881 28 69				jr z, .dirnotfound 
1883			 
1883					; increase count 
1883			 
1883 c1					pop bc	 
1884 0c					inc c 
1885 c5					push bc 
1886					 
1886			 
1886					; get file header and push the file name 
1886			 
1886 11 b5 f9				ld de, store_page 
1889 cd 65 04				call storage_read_block 
188c			 
188c					; push file id to stack 
188c				 
188c 3a b5 f9				ld a, (store_page) 
188f 26 00				ld h, 0 
1891 6f					ld l, a 
1892			 
1892					;call forth_push_numhl 
1892					; TODO store id 
1892			 
1892 e5					push hl 
1893			 
1893					; push extent count to stack  
1893				 
1893 21 b8 f9				ld hl, store_page+3 
1896			 
1896					; get file name length 
1896			 
1896 cd 2d 14				call strlenz   
1899			 
1899 23					inc hl   ; cover zero term 
189a 23					inc hl  ; stick the id at the end of the area 
189b			 
189b e5					push hl 
189c c1					pop bc    ; move length to bc 
189d			 
189d cd a2 14				call malloc 
18a0			 
18a0					; TODO save malloc area to scratch 
18a0			 
18a0 eb					ex de, hl 
18a1 2a ac f9				ld hl, (store_tmp2) 
18a4 73					ld (hl), e 
18a5 23					inc hl 
18a6 72					ld (hl), d 
18a7 23					inc hl 
18a8 22 ac f9				ld (store_tmp2), hl 
18ab			 
18ab					 
18ab			 
18ab					;pop hl   ; get source 
18ab			;		ex de, hl    ; swap aronund	 
18ab			 
18ab 21 b8 f9				ld hl, store_page+3 
18ae					if DEBUG_FORTH_WORDS 
18ae						DMARK "CFd" 
18ae f5				push af  
18af 3a c3 18			ld a, (.dmark)  
18b2 32 a6 fd			ld (debug_mark),a  
18b5 3a c4 18			ld a, (.dmark+1)  
18b8 32 a7 fd			ld (debug_mark+1),a  
18bb 3a c5 18			ld a, (.dmark+2)  
18be 32 a8 fd			ld (debug_mark+2),a  
18c1 18 03			jr .pastdmark  
18c3 ..			.dmark: db "CFd"  
18c6 f1			.pastdmark: pop af  
18c7			endm  
# End of macro DMARK
18c7						CALLMONITOR 
18c7 cd aa fd			call debug_vector  
18ca				endm  
# End of macro CALLMONITOR
18ca					endif 
18ca ed b0				ldir 
18cc			 
18cc					; de is past string, move back one and store id 
18cc					 
18cc 1b					dec de 
18cd			 
18cd					; store file id 
18cd			 
18cd e1					pop hl 
18ce eb					ex de,hl 
18cf 73					ld (hl), e 
18d0			 
18d0					if DEBUG_FORTH_WORDS 
18d0						DMARK "Cdi" 
18d0 f5				push af  
18d1 3a e5 18			ld a, (.dmark)  
18d4 32 a6 fd			ld (debug_mark),a  
18d7 3a e6 18			ld a, (.dmark+1)  
18da 32 a7 fd			ld (debug_mark+1),a  
18dd 3a e7 18			ld a, (.dmark+2)  
18e0 32 a8 fd			ld (debug_mark+2),a  
18e3 18 03			jr .pastdmark  
18e5 ..			.dmark: db "Cdi"  
18e8 f1			.pastdmark: pop af  
18e9			endm  
# End of macro DMARK
18e9						CALLMONITOR 
18e9 cd aa fd			call debug_vector  
18ec				endm  
# End of macro CALLMONITOR
18ec					endif 
18ec					 
18ec			.dirnotfound: 
18ec c1					pop bc     
18ed 10 85				djnz .diritem 
18ef				 
18ef			.dirdone:	 
18ef			 
18ef 3e 00				ld a, 0 
18f1 2a ac f9				ld hl, (store_tmp2) 
18f4 77					ld (hl), a 
18f5 23					inc hl 
18f6 77					ld (hl), a 
18f7 23					inc hl 
18f8					; push a count of the dir items found 
18f8			 
18f8			;		ld h, 0 
18f8			;		ld l, c 
18f8			 
18f8 c9				ret 
18f9			 
18f9			endif 
18f9			 
18f9			 
18f9			; Settings 
18f9			; Run  
18f9			 
18f9			 
18f9			 
18f9			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
18f9			;;hd_menu2:   db "        2: Editor",0   
18f9			;hd_menu2:   db "        2: Editor       6: Menu",0   
18f9			;hd_menu3:   db "        3: Storage",0 
18f9			;hd_menu4:   db "0=quit  4: Debug",0 
18f9			;hd_don:     db "ON",0 
18f9			;hd_doff:     db "OFF",0 
18f9			; 
18f9			; 
18f9			; 
18f9			;hardware_diags_old:       
18f9			; 
18f9			;.diagmenu: 
18f9			;	call clear_display 
18f9			;	ld a, display_row_1 
18f9			;	ld de, hd_menu1 
18f9			;	call str_at_display 
18f9			; 
18f9			;	ld a, display_row_2 
18f9			;	ld de, hd_menu2 
18f9			;	call str_at_display 
18f9			; 
18f9			;	ld a, display_row_3 
18f9			;	ld de, hd_menu3 
18f9			;	call str_at_display 
18f9			; 
18f9			;	ld a,  display_row_4 
18f9			;	ld de, hd_menu4 
18f9			;	call str_at_display 
18f9			; 
18f9			;	; display debug state 
18f9			; 
18f9			;	ld de, hd_don 
18f9			;	ld a, (os_view_disable) 
18f9			;	cp 0 
18f9			;	jr z, .distog 
18f9			;	ld de, hd_doff 
18f9			;.distog: ld a, display_row_4+17 
18f9			;	call str_at_display 
18f9			; 
18f9			;	call update_display 
18f9			; 
18f9			;	call cin_wait 
18f9			; 
18f9			; 
18f9			; 
18f9			;	cp '4' 
18f9			;	jr nz, .diagn1 
18f9			; 
18f9			;	; debug toggle 
18f9			; 
18f9			;	ld a, (os_view_disable) 
18f9			;	ld b, '*' 
18f9			;	cp 0 
18f9			;	jr z, .debtog 
18f9			;	ld b, 0 
18f9			;.debtog:	 
18f9			;	ld a,b 
18f9			;	ld (os_view_disable),a 
18f9			; 
18f9			;.diagn1: cp '0' 
18f9			;	 ret z 
18f9			; 
18f9			;;	cp '1' 
18f9			;;       jp z, matrix	 
18f9			;;   TODO keyboard matrix test 
18f9			; 
18f9			;	cp '2' 
18f9			;	jp z, .diagedit 
18f9			; 
18f9			;;	cp '6' 
18f9			;;	jp z, .menutest 
18f9			;;if ENABLE_BASIC 
18f9			;;	cp '6' 
18f9			;;	jp z, basic 
18f9			;;endif 
18f9			 ; 
18f9			;	jp .diagmenu 
18f9			; 
18f9			; 
18f9			;	ret 
18f9			 
18f9			 
18f9			.debug_tog: 
18f9 21 43 19			ld hl, .menudebug 
18fc				 
18fc			;	ld a, (os_view_disable) 
18fc			;	cp '*' 
18fc 3a aa fd			ld a,(debug_vector) 
18ff fe c9			cp $C9   ; RET 
1901 20 04			jr nz,.tdon  
1903 3e 01			ld a, 1 
1905 18 02			jr .tog1 
1907 3e 00		.tdon: ld a, 0 
1909			 
1909			.tog1: 
1909 cd cc 0d			call menu 
190c fe 00			cp 0 
190e c8				ret z 
190f fe 01			cp 1    ; disable debug 
1911 28 04			jr z, .dtog0 
1913 3e 2a			ld a, '*' 
1915 18 05			jr .dtogset 
1917			.dtog0:  
1917				;ld a, 0 
1917 cd 35 1a			call bp_on 
191a 18 dd			jr .debug_tog 
191c			.dtogset:  
191c				; ld (os_view_disable), a 
191c cd 41 1a			call bp_off 
191f c3 f9 18			jp .debug_tog 
1922			 
1922			 
1922			hardware_diags:       
1922			 
1922			.diagm: 
1922 21 35 19			ld hl, .menuitems 
1925 3e 00			ld a, 0 
1927 cd cc 0d			call menu 
192a			 
192a fe 00		         cp 0 
192c c8				 ret z 
192d			 
192d fe 02			cp 2 
192f ca 8e 19			jp z, .diagedit 
1932			 
1932			;	cp '6' 
1932			;	jp z, .menutest 
1932			;if ENABLE_BASIC 
1932			;	cp '6' 
1932			;	jp z, basic 
1932			;endif 
1932			  
1932 c3 22 19			jp .diagm 
1935			 
1935				 
1935 49 19		.menuitems:   	dw .m1 
1937 54 19				dw .m2 
1939 5b 19				dw .m3 
193b 63 19				dw .m5 
193d 69 19				dw .m5a 
193f 72 19				dw .m5b 
1941 00 00				dw 0 
1943			 
1943			.menudebug: 
1943 7b 19				dw .m6 
1945 84 19				dw .m7 
1947 00 00				dw 0 
1949			 
1949 .. 00		.m1:   db "Key Matrix",0 
1954 .. 00		.m2:   db "Editor",0 
195b .. 00		.m3:   db "Storage",0 
1963 .. 00		.m5:   db "Sound",0 
1969 .. 00		.m5a:  db "RAM Test",0 
1972 .. 00		.m5b:  db "LCD Test",0 
197b			 
197b .. 00		.m6:   db "Debug ON",0 
1984 .. 00		.m7:   db "Debug OFF",0 
198e			 
198e			; debug editor 
198e			 
198e			.diagedit: 
198e			 
198e 21 fc f0			ld hl, scratch 
1991			;	ld bc, 250 
1991			;	ldir 
1991				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1991 3e 00			ld a, 0 
1993 77				ld (hl), a 
1994 23				inc hl 
1995 77				ld (hl), a 
1996 23				inc hl 
1997 77				ld (hl), a 
1998			 
1998 cd 9b 0d		        call clear_display 
199b cd be 0d			call update_display 
199e				;ld a, 1 
199e				;ld (hardware_diag), a 
199e			.diloop: 
199e 3e 00			ld a, display_row_1 
19a0 0e 00			ld c, 0 
19a2 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
19a4 1e 28			ld e, 40 
19a6			 
19a6 21 fc f0			ld hl, scratch	 
19a9 cd fc 0f			call input_str 
19ac			 
19ac 3e 28			ld a, display_row_2 
19ae 11 fc f0			ld de, scratch 
19b1 cd ae 0d			call str_at_display 
19b4 cd be 0d			call update_display 
19b7			 
19b7 c3 9e 19			jp .diloop 
19ba			 
19ba			 
19ba			; pass word in hl 
19ba			; a has display location 
19ba			display_word_at: 
19ba f5				push af 
19bb e5				push hl 
19bc 7c				ld a,h 
19bd 21 01 f4			ld hl, os_word_scratch 
19c0 cd d0 12			call hexout 
19c3 e1				pop hl 
19c4 7d				ld a,l 
19c5 21 03 f4			ld hl, os_word_scratch+2 
19c8 cd d0 12			call hexout 
19cb 21 05 f4			ld hl, os_word_scratch+4 
19ce 3e 00			ld a,0 
19d0 77				ld (hl),a 
19d1 11 01 f4			ld de,os_word_scratch 
19d4 f1				pop af 
19d5 cd ae 0d				call str_at_display 
19d8 c9				ret 
19d9			 
19d9			display_ptr_state: 
19d9			 
19d9				; to restore afterwards 
19d9			 
19d9 d5				push de 
19da c5				push bc 
19db e5				push hl 
19dc f5				push af 
19dd			 
19dd				; for use in here 
19dd			 
19dd			;	push bc 
19dd			;	push de 
19dd			;	push hl 
19dd			;	push af 
19dd			 
19dd cd 9b 0d			call clear_display 
19e0			 
19e0 11 b8 1b			ld de, .ptrstate 
19e3 3e 00			ld a, display_row_1 
19e5 cd ae 0d			call str_at_display 
19e8			 
19e8				; display debug step 
19e8			 
19e8			 
19e8 11 a6 fd			ld de, debug_mark 
19eb 3e 26			ld a, display_row_1+display_cols-2 
19ed cd ae 0d			call str_at_display 
19f0			 
19f0				; display a 
19f0 11 c2 1b			ld de, .ptrcliptr 
19f3 3e 28			ld a, display_row_2 
19f5 cd ae 0d			call str_at_display 
19f8			 
19f8 f1				pop af 
19f9 2a 7b f9			ld hl,(cli_ptr) 
19fc 3e 30			ld a, display_row_2+8 
19fe cd ba 19			call display_word_at 
1a01			 
1a01			 
1a01				; display hl 
1a01			 
1a01			 
1a01 11 ca 1b			ld de, .ptrclioptr 
1a04 3e 32			ld a, display_row_2+10 
1a06 cd ae 0d			call str_at_display 
1a09			; 
1a09			;	pop hl 
1a09 3e 35			ld a, display_row_2+13 
1a0b 2a 79 f9			ld hl,(cli_origptr) 
1a0e cd ba 19			call display_word_at 
1a11			; 
1a11			;	 
1a11			;	; display de 
1a11			 
1a11			;	ld de, .regstatede 
1a11			;	ld a, display_row_3 
1a11			;	call str_at_display 
1a11			 
1a11			;	pop de 
1a11			;	ld h,d 
1a11			;	ld l, e 
1a11			;	ld a, display_row_3+3 
1a11			;	call display_word_at 
1a11			 
1a11			 
1a11				; display bc 
1a11			 
1a11			;	ld de, .regstatebc 
1a11			;	ld a, display_row_3+10 
1a11			;	call str_at_display 
1a11			 
1a11			;	pop bc 
1a11			;	ld h,b 
1a11			;	ld l, c 
1a11			;	ld a, display_row_3+13 
1a11			;	call display_word_at 
1a11			 
1a11			 
1a11				; display dsp 
1a11			 
1a11			;	ld de, .regstatedsp 
1a11			;	ld a, display_row_4 
1a11			;	call str_at_display 
1a11			 
1a11				 
1a11			;	ld hl,(cli_data_sp) 
1a11			;	ld a, display_row_4+4 
1a11			;	call display_word_at 
1a11			 
1a11				; display rsp 
1a11			 
1a11 11 f9 1b			ld de, .regstatersp 
1a14 3e 82			ld a, display_row_4+10 
1a16 cd ae 0d			call str_at_display 
1a19			 
1a19				 
1a19 2a 2d f9			ld hl,(cli_ret_sp) 
1a1c 3e 86			ld a, display_row_4+14 
1a1e cd ba 19			call display_word_at 
1a21			 
1a21 cd be 0d			call update_display 
1a24			 
1a24 cd de 0c			call delay1s 
1a27 cd de 0c			call delay1s 
1a2a cd de 0c			call delay1s 
1a2d			 
1a2d			 
1a2d cd 7b 20			call next_page_prompt 
1a30			 
1a30				; restore  
1a30			 
1a30 f1				pop af 
1a31 e1				pop hl 
1a32 c1				pop bc 
1a33 d1				pop de 
1a34 c9				ret 
1a35			 
1a35			; Update the break point vector so that the user can hook a new routine 
1a35			 
1a35			bp_on: 
1a35 3e c3			ld a, $c3    ; JP 
1a37 32 aa fd			ld (debug_vector), a 
1a3a 21 47 1a			ld hl, break_point_state 
1a3d 22 ab fd			ld (debug_vector+1), hl 
1a40 c9				ret 
1a41			 
1a41			bp_off: 
1a41 3e c9			ld a, $c9    ; RET 
1a43 32 aa fd			ld (debug_vector), a 
1a46 c9				ret 
1a47			 
1a47			 
1a47			break_point_state: 
1a47			;	push af 
1a47			; 
1a47			;	; see if disabled 
1a47			; 
1a47			;	ld a, (os_view_disable) 
1a47			;	cp '*' 
1a47			;	jr nz, .bpsgo 
1a47			;	pop af 
1a47			;	ret 
1a47			 
1a47			.bpsgo: 
1a47			;	pop af 
1a47 f5				push af 
1a48 22 de f0			ld (os_view_hl), hl 
1a4b ed 53 dc f0		ld (os_view_de), de 
1a4f ed 43 da f0		ld (os_view_bc), bc 
1a53 e5				push hl 
1a54 6f				ld l, a 
1a55 26 00			ld h, 0 
1a57 22 e0 f0			ld (os_view_af),hl 
1a5a			 
1a5a 21 ec fc				ld hl, display_fb0 
1a5d 22 07 fb				ld (display_fb_active), hl 
1a60 e1				pop hl	 
1a61			 
1a61 3e 31			ld a, '1' 
1a63 fe 2a		.bps1:  cp '*' 
1a65 cc 41 1a			call z, bp_off 
1a68			;	jr nz, .bps1b 
1a68			;	ld (os_view_disable),a 
1a68 fe 31		.bps1b:  cp '1' 
1a6a 20 14			jr nz, .bps2 
1a6c			 
1a6c				; display reg 
1a6c			 
1a6c				 
1a6c			 
1a6c 3a e0 f0			ld a, (os_view_af) 
1a6f 2a de f0			ld hl, (os_view_hl) 
1a72 ed 5b dc f0		ld de, (os_view_de) 
1a76 ed 4b da f0		ld bc, (os_view_bc) 
1a7a cd 14 1b			call display_reg_state 
1a7d c3 00 1b			jp .bpschk 
1a80			 
1a80 fe 32		.bps2:  cp '2' 
1a82 20 08			jr nz, .bps3 
1a84				 
1a84				; display hl 
1a84 2a de f0			ld hl, (os_view_hl) 
1a87 cd fe 1b			call display_dump_at_hl 
1a8a			 
1a8a 18 74			jr .bpschk 
1a8c			 
1a8c fe 33		.bps3:  cp '3' 
1a8e 20 08			jr nz, .bps4 
1a90			 
1a90			        ; display de 
1a90 2a dc f0			ld hl, (os_view_de) 
1a93 cd fe 1b			call display_dump_at_hl 
1a96			 
1a96 18 68			jr .bpschk 
1a98 fe 34		.bps4:  cp '4' 
1a9a 20 08			jr nz, .bps5 
1a9c			 
1a9c			        ; display bc 
1a9c 2a da f0			ld hl, (os_view_bc) 
1a9f cd fe 1b			call display_dump_at_hl 
1aa2			 
1aa2 18 5c			jr .bpschk 
1aa4 fe 35		.bps5:  cp '5' 
1aa6 20 08		        jr nz, .bps7 
1aa8			 
1aa8				; display cur ptr 
1aa8 2a 7b f9			ld hl, (cli_ptr) 
1aab cd fe 1b			call display_dump_at_hl 
1aae			 
1aae 18 50			jr .bpschk 
1ab0 fe 36		.bps7:  cp '6' 
1ab2 20 08			jr nz, .bps8b 
1ab4				 
1ab4				; display cur orig ptr 
1ab4 2a 79 f9			ld hl, (cli_origptr) 
1ab7 cd fe 1b			call display_dump_at_hl 
1aba 18 44			jr .bpschk 
1abc fe 37		.bps8b:  cp '7' 
1abe 20 08			jr nz, .bps9 
1ac0				 
1ac0				; display dsp 
1ac0 2a 29 f9			ld hl, (cli_data_sp) 
1ac3 cd fe 1b			call display_dump_at_hl 
1ac6			 
1ac6 18 38			jr .bpschk 
1ac8 fe 39		.bps9:  cp '9' 
1aca 20 05			jr nz, .bps8c 
1acc				 
1acc				; display SP 
1acc			;	ld hl, sp 
1acc cd fe 1b			call display_dump_at_hl 
1acf			 
1acf 18 2f			jr .bpschk 
1ad1 fe 38		.bps8c:  cp '8' 
1ad3 20 08			jr nz, .bps8d 
1ad5				 
1ad5				; display rsp 
1ad5 2a 2d f9			ld hl, (cli_ret_sp) 
1ad8 cd fe 1b			call display_dump_at_hl 
1adb			 
1adb 18 23			jr .bpschk 
1add fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1adf 20 05			jr nz, .bps8 
1ae1 cd 49 1e			call monitor 
1ae4			 
1ae4 18 1a			jr .bpschk 
1ae6 fe 30		.bps8:  cp '0' 
1ae8 20 16			jr nz, .bpschk 
1aea			 
1aea 21 4b fc				ld hl, display_fb1 
1aed 22 07 fb				ld (display_fb_active), hl 
1af0 cd be 0d				call update_display 
1af3			 
1af3				;ld a, (os_view_af) 
1af3 2a de f0			ld hl, (os_view_hl) 
1af6 ed 5b dc f0		ld de, (os_view_de) 
1afa ed 4b da f0		ld bc, (os_view_bc) 
1afe f1				pop af 
1aff c9				ret 
1b00			 
1b00			.bpschk:   
1b00 cd de 0c			call delay1s 
1b03 3e 9f		ld a,display_row_4 + display_cols - 1 
1b05 11 79 20		        ld de, endprg 
1b08 cd ae 0d			call str_at_display 
1b0b cd be 0d			call update_display 
1b0e cd 6c 7a			call cin_wait 
1b11			 
1b11 c3 63 1a			jp .bps1 
1b14			 
1b14			 
1b14			display_reg_state: 
1b14			 
1b14				; to restore afterwards 
1b14			 
1b14 d5				push de 
1b15 c5				push bc 
1b16 e5				push hl 
1b17 f5				push af 
1b18			 
1b18				; for use in here 
1b18			 
1b18 c5				push bc 
1b19 d5				push de 
1b1a e5				push hl 
1b1b f5				push af 
1b1c			 
1b1c cd 9b 0d			call clear_display 
1b1f			 
1b1f 11 d4 1b			ld de, .regstate 
1b22 3e 00			ld a, display_row_1 
1b24 cd ae 0d			call str_at_display 
1b27			 
1b27				; display debug step 
1b27			 
1b27			 
1b27 11 a6 fd			ld de, debug_mark 
1b2a 3e 25			ld a, display_row_1+display_cols-3 
1b2c cd ae 0d			call str_at_display 
1b2f			 
1b2f				; display a 
1b2f 11 f0 1b			ld de, .regstatea 
1b32 3e 28			ld a, display_row_2 
1b34 cd ae 0d			call str_at_display 
1b37			 
1b37 e1				pop hl 
1b38			;	ld h,0 
1b38			;	ld l, a 
1b38 3e 2b			ld a, display_row_2+3 
1b3a cd ba 19			call display_word_at 
1b3d			 
1b3d			 
1b3d				; display hl 
1b3d			 
1b3d			 
1b3d 11 e4 1b			ld de, .regstatehl 
1b40 3e 32			ld a, display_row_2+10 
1b42 cd ae 0d			call str_at_display 
1b45			 
1b45 e1				pop hl 
1b46 3e 35			ld a, display_row_2+13 
1b48 cd ba 19			call display_word_at 
1b4b			 
1b4b				 
1b4b				; display de 
1b4b			 
1b4b 11 e8 1b			ld de, .regstatede 
1b4e 3e 50			ld a, display_row_3 
1b50 cd ae 0d			call str_at_display 
1b53			 
1b53 e1				pop hl 
1b54			;	ld h,d 
1b54			;	ld l, e 
1b54 3e 53			ld a, display_row_3+3 
1b56 cd ba 19			call display_word_at 
1b59			 
1b59			 
1b59				; display bc 
1b59			 
1b59 11 ec 1b			ld de, .regstatebc 
1b5c 3e 5a			ld a, display_row_3+10 
1b5e cd ae 0d			call str_at_display 
1b61			 
1b61 e1				pop hl 
1b62			;	ld h,b 
1b62			;	ld l, c 
1b62 3e 5d			ld a, display_row_3+13 
1b64 cd ba 19			call display_word_at 
1b67			 
1b67			 
1b67				; display dsp 
1b67			 
1b67 11 f4 1b			ld de, .regstatedsp 
1b6a 3e 78			ld a, display_row_4 
1b6c cd ae 0d			call str_at_display 
1b6f			 
1b6f				 
1b6f 2a 29 f9			ld hl,(cli_data_sp) 
1b72 3e 7c			ld a, display_row_4+4 
1b74 cd ba 19			call display_word_at 
1b77			 
1b77				; display rsp 
1b77			 
1b77 11 f9 1b			ld de, .regstatersp 
1b7a 3e 82			ld a, display_row_4+10 
1b7c cd ae 0d			call str_at_display 
1b7f			 
1b7f				 
1b7f 2a 2d f9			ld hl,(cli_ret_sp) 
1b82 3e 86			ld a, display_row_4+14 
1b84 cd ba 19			call display_word_at 
1b87			 
1b87 cd be 0d			call update_display 
1b8a			 
1b8a			;	call delay1s 
1b8a			;	call delay1s 
1b8a			;	call delay1s 
1b8a			 
1b8a			 
1b8a			;	call next_page_prompt 
1b8a			 
1b8a				; restore  
1b8a			 
1b8a f1				pop af 
1b8b e1				pop hl 
1b8c c1				pop bc 
1b8d d1				pop de 
1b8e c9				ret 
1b8f			 
1b8f .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1ba3 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1bb8 .. 00		.ptrstate:	db "Ptr State",0 
1bc2 .. 00		.ptrcliptr:     db "cli_ptr",0 
1bca .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1bd4 .. 00		.regstate:	db "Reg State (1/0)",0 
1be4 .. 00		.regstatehl:	db "HL:",0 
1be8 .. 00		.regstatede:	db "DE:",0 
1bec .. 00		.regstatebc:	db "BC:",0 
1bf0 .. 00		.regstatea:	db "A :",0 
1bf4 .. 00		.regstatedsp:	db "DSP:",0 
1bf9 .. 00		.regstatersp:	db "RSP:",0 
1bfe			 
1bfe			display_dump_at_hl: 
1bfe e5				push hl 
1bff d5				push de 
1c00 c5				push bc 
1c01 f5				push af 
1c02			 
1c02 22 1f f4			ld (os_cur_ptr),hl	 
1c05 cd 9b 0d			call clear_display 
1c08 cd 83 1f			call dumpcont 
1c0b			;	call delay1s 
1c0b			;	call next_page_prompt 
1c0b			 
1c0b			 
1c0b f1				pop af 
1c0c c1				pop bc 
1c0d d1				pop de 
1c0e e1				pop hl 
1c0f c9				ret 
1c10			 
1c10			;if ENABLE_BASIC 
1c10			;	include "nascombasic.asm" 
1c10			;	basic: 
1c10			;	include "forth/FORTH.ASM" 
1c10			;endif 
1c10			 
1c10			; eof 
1c10			 
1c10			 
# End of file firmware_diags.asm
1c10			  
1c10			include "firmware_prompts.asm"  
1c10			; Prompts  
1c10			 
1c10			; boot messages 
1c10			 
1c10 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1c25 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1c35			 
1c35			 
1c35			; config menus 
1c35			 
1c35			;prom_c3: db "Add Dictionary To File",0 
1c35			 
1c35			if STARTUP_V1 
1c35			prom_c2: db "Select Autoload File",0 
1c35			prom_c2a: db "Disable Autoload File", 0 
1c35			endif 
1c35			 
1c35			if STARTUP_V2 
1c35 .. 00		prom_c2: db "Enable Autoload Files",0 
1c4b .. 00		prom_c2a: db "Disable Autoload Files", 0 
1c62			 
1c62 .. 00		crs_s1: db "*ls-word", 0 
1c6b .. 00		crs_s2: db "*ed-word", 0 
1c74 .. 00		crs_s3: db "*Demo-Programs", 0 
1c83 .. 00		crs_s4: db "*Utils", 0 
1c8a .. 00		crs_s5: db "*SPI-Util", 0 
1c94 .. 00		crs_s6: db "*Key-constants", 0 
1ca3 .. 00		crs_sound: db "*Sound-Util", 0 
1caf			 
1caf			 
1caf			 
1caf			endif 
1caf			;prom_c2b: db "Select Storage Bank",0 
1caf .. 00		prom_c4: db "Settings",0 
1cb8 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1cd3 .. 00		prom_m4b:   db "Monitor",0 
1cdb .. 00		prom_c1: db "Hardware Diags",0 
1cea			 
1cea			 
1cea			if STARTUP_V2 
1cea .. 00		prom_c9: db "Create Startup Files",0 
1cff			endif 
1cff			 
1cff .. 00		prom_notav:    db "Feature not available",0 
1d15 .. 00		prom_empty:    db "",0 
1d16			 
1d16			; eof 
1d16			 
# End of file firmware_prompts.asm
1d16			  
1d16			  
1d16			; eof  
1d16			  
# End of file firmware.asm
1d16			 
1d16			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1d16			;if BASE_KEV  
1d16			;baseram: equ 08000h 
1d16			;endif 
1d16			 
1d16			;if BASE_SC114 
1d16			;baseram:     equ    endofcode 
1d16			;endif 
1d16			 
1d16			 
1d16			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1d16			 
1d16			; start system 
1d16			 
1d16			coldstart: 
1d16				; set sp 
1d16				; di/ei 
1d16			 
1d16 f3				di 
1d17 31 fd ff			ld sp, tos 
1d1a cd f3 76			call init_nmi 
1d1d			;	ei 
1d1d			 
1d1d				; init spinner 
1d1d 3e 00			ld a,0 
1d1f 32 01 fb			ld (display_active), a 
1d22			 
1d22				; disable breakpoint by default 
1d22			 
1d22				;ld a,'*' 
1d22			;	ld a,' ' 
1d22			;	ld (os_view_disable),a 
1d22			 
1d22				; set break point vector as new break point on or off 
1d22 cd 41 1a			call bp_off 
1d25			 
1d25				; init hardware 
1d25			 
1d25				; init keyboard and screen hardware 
1d25			 
1d25 cd 68 00			call hardware_init 
1d28			 
1d28			 
1d28 cd de 0c			call delay1s 
1d2b 3e 58			ld a, display_row_3+8 
1d2d 11 03 00			ld de, buildtime 
1d30 cd ae 0d			call str_at_display 
1d33 cd be 0d			call update_display 
1d36			 
1d36 cd de 0c			call delay1s 
1d39 cd de 0c			call delay1s 
1d3c cd de 0c			call delay1s 
1d3f			 
1d3f				; detect if any keys are held down to enable breakpoints at start up 
1d3f			 
1d3f cd 7d 7a			call cin  
1d42 fe 00			cp 0 
1d44 28 03			jr z, .nokeys 
1d46			 
1d46				;call hardware_diags 
1d46 cd 3b 16			call config 
1d49			 
1d49			;	ld de, .bpen 
1d49			;	ld a, display_row_4 
1d49			;	call str_at_display 
1d49			;	call update_display 
1d49			; 
1d49			;	ld a,0 
1d49			;	ld (os_view_disable),a 
1d49			; 
1d49			;.bpwait: 
1d49			;	call cin 
1d49			;	cp 0 
1d49			;	jr z, .bpwait 
1d49			;	jr .nokeys 
1d49			; 
1d49			; 
1d49			;.bpen:  db "Break points enabled!",0 
1d49			 
1d49			 
1d49			 
1d49			 
1d49			 
1d49			 
1d49			.nokeys: 
1d49			 
1d49			 
1d49				 
1d49			 
1d49			;jp  testkey 
1d49			 
1d49			;call storage_get_block_0 
1d49			; 
1d49			;ld hl, 0 
1d49			;ld de, store_page 
1d49			;call storage_read_block 
1d49			 
1d49				 
1d49			;ld hl, 10 
1d49			;ld de, store_page 
1d49			;call storage_read_block 
1d49			 
1d49			 
1d49			 
1d49			 
1d49			 
1d49			;stop:	nop 
1d49			;	jp stop 
1d49			 
1d49			 
1d49			 
1d49			main: 
1d49 cd 9b 0d			call clear_display 
1d4c cd be 0d			call update_display 
1d4f			 
1d4f			 
1d4f			 
1d4f			;	call testlcd 
1d4f			 
1d4f			 
1d4f			 
1d4f cd 80 24			call forth_init 
1d52			 
1d52			 
1d52			warmstart: 
1d52 cd 56 24			call forth_warmstart 
1d55			 
1d55				; run startup word load 
1d55			        ; TODO prevent this running at warmstart after crash  
1d55			 
1d55				if STARTUP_ENABLE 
1d55			 
1d55					if STARTUP_V1 
1d55			 
1d55						if STORAGE_SE 
1d55							call forth_autoload 
1d55						endif 
1d55						call forth_startup 
1d55					endif 
1d55			 
1d55					if STARTUP_V2 
1d55			 
1d55						if STORAGE_SE 
1d55 cd 21 75						call forth_autoload 
1d58						else 
1d58							call forth_startup 
1d58						endif 
1d58			 
1d58			 
1d58					endif 
1d58			 
1d58				endif 
1d58			 
1d58				; show free memory after boot 
1d58 11 e4 1d			ld de, freeram 
1d5b 3e 00			ld a, display_row_1 
1d5d cd ae 0d			call str_at_display 
1d60			 
1d60				; get current heap start after loading any uwords 
1d60			 
1d60				;ld de, (os_last_new_uword) 
1d60				;ex de, hl 
1d60			 
1d60			; Or use heap_size word???? 
1d60				;ld hl, heap_end 
1d60				;ld hl, heap_size 
1d60				;ld de, topusermem 
1d60				;ld de, heap_start 
1d60 ed 5b 0a 80			ld de, (free_list )      
1d64 21 d7 f0				ld hl, heap_end 
1d67 ed 52			sbc hl, de 
1d69				;push hl 
1d69				;ld a,h	         	 
1d69				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1d69				;call hexout 
1d69			   	;pop hl 
1d69			; 
1d69			;	ld a,l 
1d69			;	ld hl, os_word_scratch+2 
1d69			;	call hexout 
1d69			;	ld hl, os_word_scratch+4 
1d69			;	ld a, 0 
1d69			;	ld (hl),a 
1d69 eb				ex de, hl 
1d6a 21 01 f4			ld hl, os_word_scratch 
1d6d cd dc 13			call uitoa_16 
1d70			 
1d70			 
1d70 11 01 f4			ld de, os_word_scratch 
1d73 3e 0d			ld a, display_row_1 + 13 
1d75 cd ae 0d			call str_at_display 
1d78 cd be 0d			call update_display 
1d7b			 
1d7b			 
1d7b				;call demo 
1d7b			 
1d7b			 
1d7b				; init scratch input area for cli commands 
1d7b			 
1d7b 21 23 f4			ld hl, os_cli_cmd 
1d7e 3e 00			ld a,0 
1d80 77				ld (hl),a 
1d81 23				inc hl 
1d82 77				ld (hl),a 
1d83			 
1d83 3e 00			ld a,0 
1d85 32 22 f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1d88			 
1d88 32 1f f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1d8b 32 20 f4			ld (os_cur_ptr+1),a	 
1d8e			 
1d8e 32 01 f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1d91 32 02 f4			ld (os_word_scratch+1),a	 
1d94				 
1d94			 
1d94				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d94 21 23 f4			ld hl, os_cli_cmd 
1d97			 
1d97 3e 00			ld a, 0		 ; init cli input 
1d99 77				ld (hl), a 
1d9a 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d9c			cli: 
1d9c				; show cli prompt 
1d9c				;push af 
1d9c				;ld a, 0 
1d9c				;ld de, prompt 
1d9c				;call str_at_display 
1d9c			 
1d9c				;call update_display 
1d9c				;pop af 
1d9c				;inc a 
1d9c				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1d9c 0e 00			ld c, 0 
1d9e 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1da0 1e 28			ld e, 40 
1da2			 
1da2 21 23 f4			ld hl, os_cli_cmd 
1da5			 
1da5				STACKFRAME OFF $fefe $9f9f 
1da5				if DEBUG_STACK_IMB 
1da5					if OFF 
1da5						exx 
1da5						ld de, $fefe 
1da5						ld a, d 
1da5						ld hl, curframe 
1da5						call hexout 
1da5						ld a, e 
1da5						ld hl, curframe+2 
1da5						call hexout 
1da5						ld hl, $fefe 
1da5						push hl 
1da5						ld hl, $9f9f 
1da5						push hl 
1da5						exx 
1da5					endif 
1da5				endif 
1da5			endm 
# End of macro STACKFRAME
1da5			 
1da5 cd fc 0f			call input_str 
1da8			 
1da8				STACKFRAMECHK OFF $fefe $9f9f 
1da8				if DEBUG_STACK_IMB 
1da8					if OFF 
1da8						exx 
1da8						ld hl, $9f9f 
1da8						pop de   ; $9f9f 
1da8						call cmp16 
1da8						jr nz, .spnosame 
1da8						ld hl, $fefe 
1da8						pop de   ; $fefe 
1da8						call cmp16 
1da8						jr z, .spfrsame 
1da8						.spnosame: call showsperror 
1da8						.spfrsame: nop 
1da8						exx 
1da8					endif 
1da8				endif 
1da8			endm 
# End of macro STACKFRAMECHK
1da8			 
1da8				; copy input to last command 
1da8			 
1da8 21 23 f4			ld hl, os_cli_cmd 
1dab 11 22 f5			ld de, os_last_cmd 
1dae 01 ff 00			ld bc, 255 
1db1 ed b0			ldir 
1db3			 
1db3				; wipe current buffer 
1db3			 
1db3			;	ld a, 0 
1db3			;	ld hl, os_cli_cmd 
1db3			;	ld de, os_cli_cmd+1 
1db3			;	ld bc, 254 
1db3			;	ldir 
1db3				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1db3			;	call strcpy 
1db3			;	ld a, 0 
1db3			;	ld (hl), a 
1db3			;	inc hl 
1db3			;	ld (hl), a 
1db3			;	inc hl 
1db3			;	ld (hl), a 
1db3			 
1db3				; switch frame buffer to program  
1db3			 
1db3 21 4b fc				ld hl, display_fb1 
1db6 22 07 fb				ld (display_fb_active), hl 
1db9			 
1db9			;	nop 
1db9				STACKFRAME ON $fbfe $8f9f 
1db9				if DEBUG_STACK_IMB 
1db9					if ON 
1db9						exx 
1db9						ld de, $fbfe 
1db9						ld a, d 
1db9						ld hl, curframe 
1db9						call hexout 
1db9						ld a, e 
1db9						ld hl, curframe+2 
1db9						call hexout 
1db9						ld hl, $fbfe 
1db9						push hl 
1db9						ld hl, $8f9f 
1db9						push hl 
1db9						exx 
1db9					endif 
1db9				endif 
1db9			endm 
# End of macro STACKFRAME
1db9				; first time into the parser so pass over the current scratch pad 
1db9 21 23 f4			ld hl,os_cli_cmd 
1dbc				; tokenise the entered statement(s) in HL 
1dbc cd fe 24			call forthparse 
1dbf			        ; exec forth statements in top of return stack 
1dbf cd 3e 25			call forthexec 
1dc2				;call forthexec_cleanup 
1dc2			;	call parsenext 
1dc2			 
1dc2				STACKFRAMECHK ON $fbfe $8f9f 
1dc2				if DEBUG_STACK_IMB 
1dc2					if ON 
1dc2						exx 
1dc2						ld hl, $8f9f 
1dc2						pop de   ; $8f9f 
1dc2						call cmp16 
1dc2						jr nz, .spnosame 
1dc2						ld hl, $fbfe 
1dc2						pop de   ; $fbfe 
1dc2						call cmp16 
1dc2						jr z, .spfrsame 
1dc2						.spnosame: call showsperror 
1dc2						.spfrsame: nop 
1dc2						exx 
1dc2					endif 
1dc2				endif 
1dc2			endm 
# End of macro STACKFRAMECHK
1dc2				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1dc2			 
1dc2 3e 78			ld a, display_row_4 
1dc4 11 f5 1d			ld de, endprog 
1dc7			 
1dc7 cd be 0d			call update_display		 
1dca			 
1dca cd 7b 20			call next_page_prompt 
1dcd			 
1dcd				; switch frame buffer to cli 
1dcd			 
1dcd 21 ec fc				ld hl, display_fb0 
1dd0 22 07 fb				ld (display_fb_active), hl 
1dd3			 
1dd3			 
1dd3 cd 9b 0d		        call clear_display 
1dd6 cd be 0d			call update_display		 
1dd9			 
1dd9 21 23 f4			ld hl, os_cli_cmd 
1ddc			 
1ddc 3e 00			ld a, 0		 ; init cli input 
1dde 77				ld (hl), a 
1ddf			 
1ddf				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1ddf			 
1ddf				; now on last line 
1ddf			 
1ddf				; TODO scroll screen up 
1ddf			 
1ddf				; TODO instead just clear screen and place at top of screen 
1ddf			 
1ddf			;	ld a, 0 
1ddf			;	ld (f_cursor_ptr),a 
1ddf			 
1ddf				;call clear_display 
1ddf				;call update_display 
1ddf			 
1ddf				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ddf 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1de1 c3 9c 1d			jp cli 
1de4			 
1de4 .. 00		freeram: db "Free bytes: ",0 
1df1 ..			asc: db "1A2F" 
1df5 .. 00		endprog: db "End prog...",0 
1e01			 
1e01			testenter2:   
1e01 21 2e f1			ld hl,scratch+50 
1e04 22 1f f4			ld (os_cur_ptr),hl 
1e07 c3 9c 1d			jp cli 
1e0a			 
1e0a			testenter:  
1e0a			 
1e0a 21 f1 1d			ld hl,asc 
1e0d			;	ld a,(hl) 
1e0d			;	call nibble2val 
1e0d cd 26 13			call get_byte 
1e10			 
1e10			 
1e10			;	ld a,(hl) 
1e10			;	call atohex 
1e10			 
1e10			;	call fourehexhl 
1e10 32 2e f1			ld (scratch+50),a 
1e13			 
1e13			 
1e13			 
1e13 21 f3 1d			ld hl,asc+2 
1e16			;	ld a, (hl) 
1e16			;	call nibble2val 
1e16 cd 26 13			call get_byte 
1e19			 
1e19			;	call fourehexhl 
1e19 32 30 f1			ld (scratch+52),a 
1e1c				 
1e1c 21 2e f1			ld hl,scratch+50 
1e1f 22 1f f4			ld (os_cur_ptr),hl 
1e22 c3 9c 1d			jp cli 
1e25			 
1e25			enter:	 
1e25 3a 00 f1			ld a,(scratch+4) 
1e28 fe 00			cp 0 
1e2a 28 0c			jr z, .entercont 
1e2c				; no, not a null term line so has an address to work out.... 
1e2c			 
1e2c 21 fe f0			ld hl,scratch+2 
1e2f cd 86 13			call get_word_hl 
1e32			 
1e32 22 1f f4			ld (os_cur_ptr),hl	 
1e35 c3 9c 1d			jp cli 
1e38			 
1e38			 
1e38			.entercont:  
1e38			 
1e38 21 fe f0			ld hl, scratch+2 
1e3b cd 26 13			call get_byte 
1e3e			 
1e3e 2a 1f f4		   	ld hl,(os_cur_ptr) 
1e41 77					ld (hl),a 
1e42 23					inc hl 
1e43 22 1f f4				ld (os_cur_ptr),hl 
1e46				 
1e46			; get byte  
1e46			 
1e46			 
1e46 c3 9c 1d			jp cli 
1e49			 
1e49			 
1e49			; basic monitor support 
1e49			 
1e49			monitor: 
1e49				;  
1e49 cd 9b 0d			call clear_display 
1e4c 3e 00			ld a, 0 
1e4e 11 9d 1e			ld de, .monprompt 
1e51 cd ae 0d			call str_at_display 
1e54 cd be 0d			call update_display 
1e57			 
1e57				; get a monitor command 
1e57			 
1e57 0e 00			ld c, 0     ; entry at top left 
1e59 16 64			ld d, 100   ; max buffer size 
1e5b 1e 0f			ld e, 15    ; input scroll area 
1e5d 3e 00			ld a, 0     ; init string 
1e5f 21 fa f2			ld hl, os_input 
1e62 77				ld (hl), a 
1e63 23				inc hl 
1e64 77				ld (hl), a 
1e65 21 fa f2			ld hl, os_input 
1e68 3e 01			ld a, 1     ; init string 
1e6a cd fc 0f			call input_str 
1e6d			 
1e6d cd 9b 0d		        call clear_display 
1e70 cd be 0d			call update_display		 
1e73			 
1e73 3a fa f2			ld a, (os_input) 
1e76 cd 24 14			call toUpper 
1e79 fe 48		        cp 'H' 
1e7b ca 02 1f		        jp z, .monhelp 
1e7e fe 44			cp 'D'		; dump 
1e80 ca 35 1f			jp z, .mondump	 
1e83 fe 43			cp 'C'		; dump 
1e85 ca 4f 1f			jp z, .moncdump	 
1e88 fe 4d			cp 'M'		; dump 
1e8a ca 9f 1e			jp z, .moneditstart 
1e8d fe 55			cp 'U'		; dump 
1e8f ca ab 1e			jp z, .monedit	 
1e92 fe 47			cp 'G'		; dump 
1e94 ca 2b 1f			jp z, .monjump 
1e97 fe 51			cp 'Q'		; dump 
1e99 c8				ret z	 
1e9a			 
1e9a			 
1e9a				; TODO "S" to access symbol by name and not need the address 
1e9a				; TODO "F" to find a string in memory 
1e9a			 
1e9a c3 49 1e			jp monitor 
1e9d			 
1e9d .. 00		.monprompt: db ">", 0 
1e9f			 
1e9f			.moneditstart: 
1e9f				; get starting address 
1e9f			 
1e9f 21 fc f2			ld hl,os_input+2 
1ea2 cd 86 13			call get_word_hl 
1ea5			 
1ea5 22 1f f4			ld (os_cur_ptr),hl	 
1ea8			 
1ea8 c3 49 1e			jp monitor 
1eab			 
1eab			.monedit: 
1eab				; get byte to load 
1eab			 
1eab 21 fc f2			ld hl,os_input+2 
1eae cd 26 13			call get_byte 
1eb1			 
1eb1				; get address to update 
1eb1 2a 1f f4			ld hl, (os_cur_ptr) 
1eb4			 
1eb4				; update byte 
1eb4			 
1eb4 77				ld (hl), a 
1eb5			 
1eb5				; move to next address and save it 
1eb5			 
1eb5 23				inc hl 
1eb6 22 1f f4			ld (os_cur_ptr),hl	 
1eb9			 
1eb9 c3 49 1e			jp monitor 
1ebc			 
1ebc			 
1ebc .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1ed0 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1eec .. 00		.monhelptext3:  db "G-Call address",0 
1efb .. 00		.monhelptext4:  db "Q-Quit",0 
1f02			        
1f02			.monhelp: 
1f02 3e 00			ld a, display_row_1 
1f04 11 bc 1e		        ld de, .monhelptext1 
1f07			 
1f07 cd ae 0d			call str_at_display 
1f0a 3e 28			ld a, display_row_2 
1f0c 11 d0 1e		        ld de, .monhelptext2 
1f0f					 
1f0f cd ae 0d			call str_at_display 
1f12 3e 50			ld a, display_row_3 
1f14 11 ec 1e		        ld de, .monhelptext3 
1f17					 
1f17 cd ae 0d			call str_at_display 
1f1a 3e 78			ld a, display_row_4 
1f1c 11 fb 1e		        ld de, .monhelptext4 
1f1f cd ae 0d			call str_at_display 
1f22			 
1f22 cd be 0d			call update_display		 
1f25			 
1f25 cd 7b 20			call next_page_prompt 
1f28 c3 49 1e			jp monitor 
1f2b			 
1f2b			.monjump:    
1f2b 21 fc f2			ld hl,os_input+2 
1f2e cd 86 13			call get_word_hl 
1f31			 
1f31 e9				jp (hl) 
1f32 c3 49 1e			jp monitor 
1f35			 
1f35			.mondump:    
1f35 21 fc f2			ld hl,os_input+2 
1f38 cd 86 13			call get_word_hl 
1f3b			 
1f3b 22 1f f4			ld (os_cur_ptr),hl	 
1f3e cd 83 1f			call dumpcont 
1f41 3e 78			ld a, display_row_4 
1f43 11 f5 1d			ld de, endprog 
1f46			 
1f46 cd be 0d			call update_display		 
1f49			 
1f49 cd 7b 20			call next_page_prompt 
1f4c c3 49 1e			jp monitor 
1f4f			.moncdump: 
1f4f cd 83 1f			call dumpcont 
1f52 3e 78			ld a, display_row_4 
1f54 11 f5 1d			ld de, endprog 
1f57			 
1f57 cd be 0d			call update_display		 
1f5a			 
1f5a cd 7b 20			call next_page_prompt 
1f5d c3 49 1e			jp monitor 
1f60			 
1f60			 
1f60			; TODO symbol access  
1f60			 
1f60			.symbols:     ;; A list of symbols that can be called up  
1f60 ec fc			dw display_fb0 
1f62 .. 00			db "fb0",0  
1f66 b5 f9		     	dw store_page 
1f68 .. 00			db "store_page",0 
1f73			 
1f73			 
1f73			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1f73			 
1f73 3a fd f0			ld a,(scratch+1) 
1f76 fe 00			cp 0 
1f78 28 09			jr z, dumpcont 
1f7a			 
1f7a				; no, not a null term line so has an address to work out.... 
1f7a			 
1f7a 21 fe f0			ld hl,scratch+2 
1f7d cd 86 13			call get_word_hl 
1f80			 
1f80 22 1f f4			ld (os_cur_ptr),hl	 
1f83			 
1f83			 
1f83			 
1f83			dumpcont: 
1f83			 
1f83				; dump bytes at ptr 
1f83			 
1f83			 
1f83 3e 00			ld a, display_row_1 
1f85 2a 07 fb			ld hl, (display_fb_active) 
1f88 cd cf 0f			call addatohl 
1f8b cd b3 1f			call .dumpbyterow 
1f8e			 
1f8e 3e 28			ld a, display_row_2 
1f90 2a 07 fb			ld hl, (display_fb_active) 
1f93 cd cf 0f			call addatohl 
1f96 cd b3 1f			call .dumpbyterow 
1f99			 
1f99			 
1f99 3e 50			ld a, display_row_3 
1f9b 2a 07 fb			ld hl, (display_fb_active) 
1f9e cd cf 0f			call addatohl 
1fa1 cd b3 1f			call .dumpbyterow 
1fa4			 
1fa4 3e 78			ld a, display_row_4 
1fa6 2a 07 fb			ld hl, (display_fb_active) 
1fa9 cd cf 0f			call addatohl 
1fac cd b3 1f			call .dumpbyterow 
1faf			 
1faf cd be 0d			call update_display 
1fb2			;		jp cli 
1fb2 c9				ret 
1fb3			 
1fb3			.dumpbyterow: 
1fb3			 
1fb3				;push af 
1fb3			 
1fb3 e5				push hl 
1fb4			 
1fb4				; calc where to poke the ascii 
1fb4			if display_cols == 20 
1fb4				ld a, 16 
1fb4			else 
1fb4 3e 1f			ld a, 31 
1fb6			endif 
1fb6			 
1fb6 cd cf 0f			call addatohl 
1fb9 22 01 f4			ld (os_word_scratch),hl  		; save pos for later 
1fbc			 
1fbc			 
1fbc			; display decoding address 
1fbc 2a 1f f4		   	ld hl,(os_cur_ptr) 
1fbf			 
1fbf 7c				ld a,h 
1fc0 e1				pop hl 
1fc1 e5				push hl 
1fc2			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1fc2 cd d0 12			call hexout 
1fc5 2a 1f f4		   	ld hl,(os_cur_ptr) 
1fc8			 
1fc8 7d				ld a,l 
1fc9 e1				pop hl 
1fca 23				inc hl 
1fcb 23				inc hl 
1fcc e5				push hl 
1fcd			;	ld hl, os_word_scratch+2 
1fcd cd d0 12			call hexout 
1fd0 e1				pop hl 
1fd1 23				inc hl 
1fd2 23				inc hl 
1fd3				;ld hl, os_word_scratch+4 
1fd3 3e 3a			ld a, ':' 
1fd5 77				ld (hl),a 
1fd6 23				inc hl 
1fd7				;ld a, 0 
1fd7				;ld (hl),a 
1fd7				;ld de, os_word_scratch 
1fd7				;pop af 
1fd7				;push af 
1fd7			;		ld a, display_row_2 
1fd7			;		call str_at_display 
1fd7			;		call update_display 
1fd7			 
1fd7			 
1fd7			;pop af 
1fd7			;	add 5 
1fd7			 
1fd7			if display_cols == 20 
1fd7				ld b, 4 
1fd7			else 
1fd7 06 08			ld b, 8 
1fd9			endif	 
1fd9			 
1fd9			.dumpbyte: 
1fd9 c5				push bc 
1fda e5				push hl 
1fdb			 
1fdb			 
1fdb 2a 1f f4		   	ld hl,(os_cur_ptr) 
1fde 7e					ld a,(hl) 
1fdf			 
1fdf					; poke the ascii to display 
1fdf 2a 01 f4				ld hl,(os_word_scratch) 
1fe2 77					ld (hl),a 
1fe3 23					inc hl 
1fe4 22 01 f4				ld (os_word_scratch),hl 
1fe7			 
1fe7					 
1fe7			 
1fe7			 
1fe7 e1					pop hl 
1fe8 e5					push hl 
1fe9			 
1fe9 cd d0 12				call hexout 
1fec			 
1fec					 
1fec 2a 1f f4		   	ld hl,(os_cur_ptr) 
1fef 23				inc hl 
1ff0 22 1f f4		   	ld (os_cur_ptr),hl 
1ff3			 
1ff3 e1					pop hl 
1ff4 23					inc hl 
1ff5 23					inc hl 
1ff6 23					inc hl 
1ff7			 
1ff7			 
1ff7			 
1ff7					;ld a,0 
1ff7					;ld (os_word_scratch+2),a 
1ff7					;pop af 
1ff7					;push af 
1ff7			 
1ff7					;ld de, os_word_scratch 
1ff7					;call str_at_display 
1ff7			;		call update_display 
1ff7			;		pop af 
1ff7 c1					pop bc 
1ff8 c6 03				add 3 
1ffa 10 dd			djnz .dumpbyte 
1ffc			 
1ffc				 
1ffc			 
1ffc c9				ret 
1ffd			 
1ffd			jump:	 
1ffd			 
1ffd 21 fe f0			ld hl,scratch+2 
2000 cd 86 13			call get_word_hl 
2003				;ld hl,(scratch+2) 
2003				;call fourehexhl 
2003			 
2003 22 1f f4			ld (os_cur_ptr),hl	 
2006			 
2006 e9				jp (hl) 
2007			 
2007			 
2007			 
2007			; TODO implement a basic monitor mode to start with 
2007			 
2007			 
2007			 
2007			 
2007			 
2007			 
2007			 
2007			 
2007			 
2007			; testing and demo code during development 
2007			 
2007			 
2007 .. 00		str1: db "Enter some text...",0 
201a .. 00		clear: db "                    ",0 
202f			 
202f			demo: 
202f			 
202f			 
202f			 
202f			;	call update_display 
202f			 
202f				; init scratch input area for testing 
202f 21 fc f0			ld hl, scratch	 
2032 3e 00			ld a,0 
2034 77				ld (hl),a 
2035			 
2035			 
2035 3e 28		            LD   A, display_row_2 
2037			;            CALL fLCD_Pos       ;Position cursor to location in A 
2037 11 07 20		            LD   DE, str1 
203a cd ae 0d			call str_at_display 
203d			 
203d			;            CALL fLCD_Str       ;Display string pointed to by DE 
203d			cloop:	 
203d 3e 50		            LD   A, display_row_3 
203f			;            CALL fLCD_Pos       ;Position cursor to location in A 
203f 11 1a 20		            LD   DE, clear 
2042			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
2042 cd ae 0d				call str_at_display 
2045 3e 78			ld a, display_row_4 
2047 11 77 20			ld de, prompt 
204a			 
204a cd ae 0d				call str_at_display 
204d cd be 0d			call update_display 
2050			 
2050 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
2052 16 0a			ld d, 10 
2054 21 fc f0			ld hl, scratch	 
2057 cd fc 0f			call input_str 
205a			 
205a			;	call clear_display 
205a			;'	call update_display 
205a			 
205a 3e 00		            LD   A, display_row_1 
205c			;            CALL fLCD_Pos       ;Position cursor to location in A 
205c 11 1a 20		            LD   DE, clear 
205f cd ae 0d				call str_at_display 
2062			;            CALL fLCD_Str       ;Display string pointed to by DE 
2062 3e 00		            LD   A, display_row_1 
2064			;            CALL fLCD_Pos       ;Position cursor to location in A 
2064 11 fc f0		            LD   DE, scratch 
2067			;            CALL fLCD_Str       ;Display string pointed to by DE 
2067 cd ae 0d				call str_at_display 
206a cd be 0d			call update_display 
206d			 
206d 3e 00				ld a,0 
206f 21 fc f0			ld hl, scratch 
2072 77				ld (hl),a 
2073			 
2073 00				nop 
2074 c3 3d 20			jp cloop 
2077			 
2077			 
2077			 
2077			; OS Prompt 
2077			 
2077 .. 00		prompt: db ">",0 
2079 .. 00		endprg: db "?",0 
207b			 
207b			 
207b			; handy next page prompt 
207b			next_page_prompt: 
207b e5				push hl 
207c d5				push de 
207d f5				push af 
207e c5				push bc 
207f			 
207f 3e 9f			ld a,display_row_4 + display_cols - 1 
2081 11 79 20		        ld de, endprg 
2084 cd ae 0d			call str_at_display 
2087 cd be 0d			call update_display 
208a cd 6c 7a			call cin_wait 
208d c1				pop bc 
208e f1				pop af 
208f d1				pop de 
2090 e1				pop hl 
2091			 
2091			 
2091 c9				ret 
2092			 
2092			 
2092			; forth parser 
2092			 
2092			; My forth kernel 
2092			include "forth_kernel.asm" 
2092			; 
2092			; kernel to the forth OS 
2092			 
2092			DS_TYPE_STR: equ 1     ; string type 
2092			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
2092			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
2092			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
2092			 
2092			FORTH_PARSEV1: equ 0 
2092			FORTH_PARSEV2: equ 0 
2092			FORTH_PARSEV3: equ 0 
2092			FORTH_PARSEV4: equ 0 
2092			FORTH_PARSEV5: equ 1 
2092			 
2092			;if FORTH_PARSEV5 
2092			;	FORTH_END_BUFFER: equ 0 
2092			;else 
2092			FORTH_END_BUFFER: equ 127 
2092			;endif 
2092			 
2092			FORTH_TRUE: equ 1 
2092			FORTH_FALSE: equ 0 
2092			 
2092			if FORTH_PARSEV4 
2092			include "forth_stackops.asm" 
2092			endif 
2092			 
2092			if FORTH_PARSEV5 
2092			include "forth_stackopsv5.asm" 
2092			 
2092			; Stack operations for v5 parser on wards 
2092			; * DATA stack 
2092			; * LOOP stack 
2092			; * RETURN stack 
2092			 
2092			 
2092			 
2092			FORTH_CHK_DSP_UNDER: macro 
2092				push hl 
2092				push de 
2092				ld hl,(cli_data_sp) 
2092				ld de, cli_data_stack 
2092				call cmp16 
2092				jp c, fault_dsp_under 
2092				pop de 
2092				pop hl 
2092				endm 
2092			 
2092			 
2092			FORTH_CHK_RSP_UNDER: macro 
2092				push hl 
2092				push de 
2092				ld hl,(cli_ret_sp) 
2092				ld de, cli_ret_stack 
2092				call cmp16 
2092				jp c, fault_rsp_under 
2092				pop de 
2092				pop hl 
2092				endm 
2092			 
2092			FORTH_CHK_LOOP_UNDER: macro 
2092				push hl 
2092				push de 
2092				ld hl,(cli_loop_sp) 
2092				ld de, cli_loop_stack 
2092				call cmp16 
2092				jp c, fault_loop_under 
2092				pop de 
2092				pop hl 
2092				endm 
2092			 
2092			FORTH_ERR_TOS_NOTSTR: macro 
2092				; TOSO might need more for checks when used 
2092				push af 
2092				ld a,(hl) 
2092				cp DS_TYPE_STR 
2092				jp nz, type_faultn   
2092				pop af 
2092				endm 
2092			 
2092			FORTH_ERR_TOS_NOTNUM: macro 
2092				push af 
2092				ld a,(hl) 
2092				cp DS_TYPE_INUM 
2092				jp nz, type_faultn   
2092				pop af 
2092				endm 
2092			 
2092			 
2092			; increase data stack pointer and save hl to it 
2092				 
2092			FORTH_DSP_NEXT: macro 
2092				call macro_forth_dsp_next 
2092				endm 
2092			 
2092			 
2092			macro_forth_dsp_next: 
2092				if DEBUG_FORTH_STACK_GUARD 
2092 cd 19 73				call check_stacks 
2095				endif 
2095 e5				push hl 
2096 d5				push de 
2097 eb				ex de,hl 
2098 2a 29 f9			ld hl,(cli_data_sp) 
209b 23				inc hl 
209c 23				inc hl 
209d			 
209d			; PARSEV5 
209d 23				inc hl 
209e 22 29 f9			ld (cli_data_sp),hl 
20a1 73				ld (hl), e 
20a2 23				inc hl 
20a3 72				ld (hl), d 
20a4 d1				pop de 
20a5 e1				pop hl 
20a6				if DEBUG_FORTH_STACK_GUARD 
20a6 cd 19 73				call check_stacks 
20a9				endif 
20a9 c9				ret 
20aa			 
20aa			 
20aa			; increase ret stack pointer and save hl to it 
20aa				 
20aa			FORTH_RSP_NEXT: macro 
20aa				call macro_forth_rsp_next 
20aa				endm 
20aa			 
20aa			macro_forth_rsp_next: 
20aa				if DEBUG_FORTH_STACK_GUARD 
20aa cd 19 73				call check_stacks 
20ad				endif 
20ad e5				push hl 
20ae d5				push de 
20af eb				ex de,hl 
20b0 2a 2d f9			ld hl,(cli_ret_sp) 
20b3 23				inc hl 
20b4 23				inc hl 
20b5 22 2d f9			ld (cli_ret_sp),hl 
20b8 73				ld (hl), e 
20b9 23				inc hl 
20ba 72				ld (hl), d 
20bb d1				pop de 
20bc e1				pop hl 
20bd				if DEBUG_FORTH_STACK_GUARD 
20bd cd 19 73				call check_stacks 
20c0				endif 
20c0 c9				ret 
20c1			 
20c1			; get current ret stack pointer and save to hl  
20c1				 
20c1			FORTH_RSP_TOS: macro 
20c1				call macro_forth_rsp_tos 
20c1				endm 
20c1			 
20c1			macro_forth_rsp_tos: 
20c1				;push de 
20c1 2a 2d f9			ld hl,(cli_ret_sp) 
20c4 cd fc 20			call loadhlptrtohl 
20c7				;ld e, (hl) 
20c7				;inc hl 
20c7				;ld d, (hl) 
20c7				;ex de, hl 
20c7					if DEBUG_FORTH_WORDS 
20c7			;			DMARK "RST" 
20c7						CALLMONITOR 
20c7 cd aa fd			call debug_vector  
20ca				endm  
# End of macro CALLMONITOR
20ca					endif 
20ca				;pop de 
20ca c9				ret 
20cb			 
20cb			; pop ret stack pointer 
20cb				 
20cb			FORTH_RSP_POP: macro 
20cb				call macro_forth_rsp_pop 
20cb				endm 
20cb			 
20cb			 
20cb			macro_forth_rsp_pop: 
20cb				if DEBUG_FORTH_STACK_GUARD 
20cb			;		DMARK "RPP" 
20cb cd 19 73				call check_stacks 
20ce					FORTH_CHK_RSP_UNDER 
20ce e5				push hl 
20cf d5				push de 
20d0 2a 2d f9			ld hl,(cli_ret_sp) 
20d3 11 e7 f8			ld de, cli_ret_stack 
20d6 cd ed 0f			call cmp16 
20d9 da 2d 74			jp c, fault_rsp_under 
20dc d1				pop de 
20dd e1				pop hl 
20de				endm 
# End of macro FORTH_CHK_RSP_UNDER
20de				endif 
20de e5				push hl 
20df 2a 2d f9			ld hl,(cli_ret_sp) 
20e2			 
20e2			 
20e2				if FORTH_ENABLE_FREE 
20e2			 
20e2					; get pointer 
20e2			 
20e2					push de 
20e2					push hl 
20e2			 
20e2					ld e, (hl) 
20e2					inc hl 
20e2					ld d, (hl) 
20e2			 
20e2					ex de, hl 
20e2					call free 
20e2			 
20e2					pop hl 
20e2					pop de 
20e2			 
20e2			 
20e2				endif 
20e2			 
20e2			 
20e2 2b				dec hl 
20e3 2b				dec hl 
20e4 22 2d f9			ld (cli_ret_sp), hl 
20e7				; do stack underflow checks 
20e7 e1				pop hl 
20e8				if DEBUG_FORTH_STACK_GUARD 
20e8 cd 19 73				call check_stacks 
20eb					FORTH_CHK_RSP_UNDER 
20eb e5				push hl 
20ec d5				push de 
20ed 2a 2d f9			ld hl,(cli_ret_sp) 
20f0 11 e7 f8			ld de, cli_ret_stack 
20f3 cd ed 0f			call cmp16 
20f6 da 2d 74			jp c, fault_rsp_under 
20f9 d1				pop de 
20fa e1				pop hl 
20fb				endm 
# End of macro FORTH_CHK_RSP_UNDER
20fb				endif 
20fb c9				ret 
20fc			 
20fc			 
20fc			 
20fc			; routine to load word pointed to by hl into hl 
20fc			 
20fc			loadhlptrtohl: 
20fc			 
20fc d5				push de 
20fd 5e				ld e, (hl) 
20fe 23				inc hl 
20ff 56				ld d, (hl) 
2100 eb				ex de, hl 
2101 d1				pop de 
2102			 
2102 c9				ret 
2103			 
2103			 
2103			 
2103			 
2103			 
2103			; push a number held in HL onto the data stack 
2103			; entry point for pushing a value when already in hl used in function above 
2103			 
2103			forth_push_numhl: 
2103			 
2103 e5				push hl    ; save value to push 
2104			 
2104			if DEBUG_FORTH_PUSH 
2104				; see if disabled 
2104			 
2104			 
2104 f5				push af 
2105 3a aa fd			ld a,(debug_vector) 
2108 fe c9			cp $c9   ; ret 
210a			;	ld a, (os_view_disable) 
210a			;	cp '*' 
210a 28 34			jr z, .pskip2 
210c e5				push hl 
210d e5			push hl 
210e cd 9b 0d			call clear_display 
2111 e1			pop hl 
2112 7c				ld a,h 
2113 21 01 f4			ld hl, os_word_scratch 
2116 cd d0 12			call hexout 
2119 e1				pop hl 
211a 7d				ld a,l 
211b 21 03 f4			ld hl, os_word_scratch+2 
211e cd d0 12			call hexout 
2121			 
2121 21 05 f4			ld hl, os_word_scratch+4 
2124 3e 00			ld a,0 
2126 77				ld (hl),a 
2127 11 01 f4			ld de,os_word_scratch 
212a 3e 28				ld a, display_row_2 
212c cd ae 0d				call str_at_display 
212f 11 2b 5e			ld de, .push_num 
2132 3e 00			ld a, display_row_1 
2134			 
2134 cd ae 0d				call str_at_display 
2137			 
2137			 
2137 cd be 0d			call update_display 
213a cd de 0c			call delay1s 
213d cd de 0c			call delay1s 
2140			.pskip2:  
2140			 
2140 f1				pop af 
2141			endif	 
2141			 
2141			 
2141				FORTH_DSP_NEXT 
2141 cd 92 20			call macro_forth_dsp_next 
2144				endm 
# End of macro FORTH_DSP_NEXT
2144			 
2144 2a 29 f9			ld hl, (cli_data_sp) 
2147			 
2147				; save item type 
2147 3e 02			ld a,  DS_TYPE_INUM 
2149 77				ld (hl), a 
214a 23				inc hl 
214b			 
214b				; get word off stack 
214b d1				pop de 
214c 7b				ld a,e 
214d 77				ld (hl), a 
214e 23				inc hl 
214f 7a				ld a,d 
2150 77				ld (hl), a 
2151			 
2151			if DEBUG_FORTH_PUSH 
2151 2b				dec hl 
2152 2b				dec hl 
2153 2b				dec hl 
2154						DMARK "PH5" 
2154 f5				push af  
2155 3a 69 21			ld a, (.dmark)  
2158 32 a6 fd			ld (debug_mark),a  
215b 3a 6a 21			ld a, (.dmark+1)  
215e 32 a7 fd			ld (debug_mark+1),a  
2161 3a 6b 21			ld a, (.dmark+2)  
2164 32 a8 fd			ld (debug_mark+2),a  
2167 18 03			jr .pastdmark  
2169 ..			.dmark: db "PH5"  
216c f1			.pastdmark: pop af  
216d			endm  
# End of macro DMARK
216d				CALLMONITOR 
216d cd aa fd			call debug_vector  
2170				endm  
# End of macro CALLMONITOR
2170			endif	 
2170			 
2170 c9				ret 
2171			 
2171			 
2171			; Push a string to stack pointed to by hl 
2171			 
2171			forth_push_str: 
2171			 
2171			if DEBUG_FORTH_PUSH 
2171						DMARK "PSQ" 
2171 f5				push af  
2172 3a 86 21			ld a, (.dmark)  
2175 32 a6 fd			ld (debug_mark),a  
2178 3a 87 21			ld a, (.dmark+1)  
217b 32 a7 fd			ld (debug_mark+1),a  
217e 3a 88 21			ld a, (.dmark+2)  
2181 32 a8 fd			ld (debug_mark+2),a  
2184 18 03			jr .pastdmark  
2186 ..			.dmark: db "PSQ"  
2189 f1			.pastdmark: pop af  
218a			endm  
# End of macro DMARK
218a				CALLMONITOR 
218a cd aa fd			call debug_vector  
218d				endm  
# End of macro CALLMONITOR
218d			endif	 
218d			    
218d e5				push hl 
218e e5				push hl 
218f			 
218f			;	ld a, 0   ; find end of string 
218f cd 2d 14			call strlenz 
2192			if DEBUG_FORTH_PUSH 
2192						DMARK "PQ2" 
2192 f5				push af  
2193 3a a7 21			ld a, (.dmark)  
2196 32 a6 fd			ld (debug_mark),a  
2199 3a a8 21			ld a, (.dmark+1)  
219c 32 a7 fd			ld (debug_mark+1),a  
219f 3a a9 21			ld a, (.dmark+2)  
21a2 32 a8 fd			ld (debug_mark+2),a  
21a5 18 03			jr .pastdmark  
21a7 ..			.dmark: db "PQ2"  
21aa f1			.pastdmark: pop af  
21ab			endm  
# End of macro DMARK
21ab				CALLMONITOR 
21ab cd aa fd			call debug_vector  
21ae				endm  
# End of macro CALLMONITOR
21ae			endif	 
21ae eb				ex de, hl 
21af e1				pop hl   ; get ptr to start of string 
21b0			if DEBUG_FORTH_PUSH 
21b0						DMARK "PQ3" 
21b0 f5				push af  
21b1 3a c5 21			ld a, (.dmark)  
21b4 32 a6 fd			ld (debug_mark),a  
21b7 3a c6 21			ld a, (.dmark+1)  
21ba 32 a7 fd			ld (debug_mark+1),a  
21bd 3a c7 21			ld a, (.dmark+2)  
21c0 32 a8 fd			ld (debug_mark+2),a  
21c3 18 03			jr .pastdmark  
21c5 ..			.dmark: db "PQ3"  
21c8 f1			.pastdmark: pop af  
21c9			endm  
# End of macro DMARK
21c9				CALLMONITOR 
21c9 cd aa fd			call debug_vector  
21cc				endm  
# End of macro CALLMONITOR
21cc			endif	 
21cc 19				add hl,de 
21cd			if DEBUG_FORTH_PUSH 
21cd						DMARK "PQE" 
21cd f5				push af  
21ce 3a e2 21			ld a, (.dmark)  
21d1 32 a6 fd			ld (debug_mark),a  
21d4 3a e3 21			ld a, (.dmark+1)  
21d7 32 a7 fd			ld (debug_mark+1),a  
21da 3a e4 21			ld a, (.dmark+2)  
21dd 32 a8 fd			ld (debug_mark+2),a  
21e0 18 03			jr .pastdmark  
21e2 ..			.dmark: db "PQE"  
21e5 f1			.pastdmark: pop af  
21e6			endm  
# End of macro DMARK
21e6				CALLMONITOR 
21e6 cd aa fd			call debug_vector  
21e9				endm  
# End of macro CALLMONITOR
21e9			endif	 
21e9			 
21e9 2b				dec hl    ; see if there is an optional trailing double quote 
21ea 7e				ld a,(hl) 
21eb fe 22			cp '"' 
21ed 20 03			jr nz, .strnoq 
21ef 3e 00			ld a, 0      ; get rid of double quote 
21f1 77				ld (hl), a 
21f2 23			.strnoq: inc hl 
21f3			 
21f3 3e 00			ld a, 0 
21f5 77				ld (hl), a     ; add null term and get rid of trailing double quote 
21f6			 
21f6 13				inc de ; add one for the type string 
21f7 13				inc de ; add one for null term??? 
21f8			 
21f8				; tos is get string pointer again 
21f8				; de contains space to allocate 
21f8				 
21f8 d5				push de 
21f9			 
21f9 eb				ex de, hl 
21fa			 
21fa				;push af 
21fa			 
21fa			if DEBUG_FORTH_PUSH 
21fa						DMARK "PHm" 
21fa f5				push af  
21fb 3a 0f 22			ld a, (.dmark)  
21fe 32 a6 fd			ld (debug_mark),a  
2201 3a 10 22			ld a, (.dmark+1)  
2204 32 a7 fd			ld (debug_mark+1),a  
2207 3a 11 22			ld a, (.dmark+2)  
220a 32 a8 fd			ld (debug_mark+2),a  
220d 18 03			jr .pastdmark  
220f ..			.dmark: db "PHm"  
2212 f1			.pastdmark: pop af  
2213			endm  
# End of macro DMARK
2213				CALLMONITOR 
2213 cd aa fd			call debug_vector  
2216				endm  
# End of macro CALLMONITOR
2216			endif	 
2216 cd a2 14			call malloc	; on ret hl now contains allocated memory 
2219				if DEBUG_FORTH_MALLOC_GUARD 
2219 cc 83 5e				call z,malloc_error 
221c				endif 
221c			 
221c				 
221c c1				pop bc    ; get length 
221d d1				pop de   ;  get string start    
221e			 
221e				; hl has destination from malloc 
221e			 
221e eb				ex de, hl    ; prep for ldir 
221f			 
221f d5				push de   ; save malloc area for DSP later 
2220				;push hl   ; save malloc area for DSP later 
2220			 
2220			if DEBUG_FORTH_PUSH 
2220						DMARK "PHc" 
2220 f5				push af  
2221 3a 35 22			ld a, (.dmark)  
2224 32 a6 fd			ld (debug_mark),a  
2227 3a 36 22			ld a, (.dmark+1)  
222a 32 a7 fd			ld (debug_mark+1),a  
222d 3a 37 22			ld a, (.dmark+2)  
2230 32 a8 fd			ld (debug_mark+2),a  
2233 18 03			jr .pastdmark  
2235 ..			.dmark: db "PHc"  
2238 f1			.pastdmark: pop af  
2239			endm  
# End of macro DMARK
2239				CALLMONITOR 
2239 cd aa fd			call debug_vector  
223c				endm  
# End of macro CALLMONITOR
223c			endif	 
223c			 
223c			 
223c ed b0			ldir 
223e			 
223e			 
223e				; push malloc to data stack     macro?????  
223e			 
223e				FORTH_DSP_NEXT 
223e cd 92 20			call macro_forth_dsp_next 
2241				endm 
# End of macro FORTH_DSP_NEXT
2241			 
2241				; save value and type 
2241			 
2241 2a 29 f9			ld hl, (cli_data_sp) 
2244			 
2244				; save item type 
2244 3e 01			ld a,  DS_TYPE_STR 
2246 77				ld (hl), a 
2247 23				inc hl 
2248			 
2248				; get malloc word off stack 
2248 d1				pop de 
2249 73				ld (hl), e 
224a 23				inc hl 
224b 72				ld (hl), d 
224c			 
224c			 
224c			 
224c			if DEBUG_FORTH_PUSH 
224c 2a 29 f9			ld hl, (cli_data_sp) 
224f						DMARK "PHS" 
224f f5				push af  
2250 3a 64 22			ld a, (.dmark)  
2253 32 a6 fd			ld (debug_mark),a  
2256 3a 65 22			ld a, (.dmark+1)  
2259 32 a7 fd			ld (debug_mark+1),a  
225c 3a 66 22			ld a, (.dmark+2)  
225f 32 a8 fd			ld (debug_mark+2),a  
2262 18 03			jr .pastdmark  
2264 ..			.dmark: db "PHS"  
2267 f1			.pastdmark: pop af  
2268			endm  
# End of macro DMARK
2268				CALLMONITOR 
2268 cd aa fd			call debug_vector  
226b				endm  
# End of macro CALLMONITOR
226b			;	ex de,hl 
226b			endif	 
226b				; in case of spaces, skip the ptr past the copied string 
226b				;pop af 
226b				;ld (cli_origptr),hl 
226b			 
226b c9				ret 
226c			 
226c			 
226c			 
226c			; TODO ascii push input onto stack given hl to start of input 
226c			 
226c			; identify type 
226c			; if starts with a " then a string 
226c			; otherwise it is a number 
226c			;  
226c			; if a string 
226c			;     scan for ending " to get length of string to malloc for + 1 
226c			;     malloc 
226c			;     put pointer to string on stack first byte flags as string 
226c			; 
226c			; else a number 
226c			;    look for number format identifier 
226c			;    $xx hex 
226c			;    %xxxxx bin 
226c			;    xxxxx decimal 
226c			;    convert number to 16bit word.  
226c			;    malloc word + 1 with flag to identiy as num 
226c			;    put pointer to number on stack 
226c			;   
226c			;  
226c			  
226c			forth_apush: 
226c				; kernel push 
226c			 
226c			if DEBUG_FORTH_PUSH 
226c						DMARK "PSH" 
226c f5				push af  
226d 3a 81 22			ld a, (.dmark)  
2270 32 a6 fd			ld (debug_mark),a  
2273 3a 82 22			ld a, (.dmark+1)  
2276 32 a7 fd			ld (debug_mark+1),a  
2279 3a 83 22			ld a, (.dmark+2)  
227c 32 a8 fd			ld (debug_mark+2),a  
227f 18 03			jr .pastdmark  
2281 ..			.dmark: db "PSH"  
2284 f1			.pastdmark: pop af  
2285			endm  
# End of macro DMARK
2285				CALLMONITOR 
2285 cd aa fd			call debug_vector  
2288				endm  
# End of macro CALLMONITOR
2288			endif	 
2288				; identify input type 
2288			 
2288 7e				ld a,(hl) 
2289 fe 22			cp '"' 
228b 28 0a			jr z, .fapstr 
228d fe 24			cp '$' 
228f ca b7 22			jp z, .faphex 
2292 fe 25			cp '%' 
2294 ca 9f 22			jp z, .fapbin 
2297			;	cp 'b' 
2297			;	jp z, .fabin 
2297				; else decimal 
2297			 
2297				; TODO do decimal conversion 
2297				; decimal is stored as a 16bit word 
2297			 
2297				; by default everything is a string if type is not detected 
2297			.fapstr: ; 
2297 fe 22			cp '"' 
2299 20 01			jr nz, .strnoqu 
229b 23				inc hl 
229c			.strnoqu: 
229c c3 71 21			jp forth_push_str 
229f			 
229f			 
229f			 
229f			.fapbin:    ; push a binary string.  
229f 11 00 00			ld de, 0   ; hold a 16bit value 
22a2			 
22a2 23			.fapbinshift:	inc hl  
22a3 7e				ld a,(hl) 
22a4 fe 00			cp 0     ; done scanning  
22a6 28 0b			jr z, .fapbdone  	; got it in HL so push  
22a8			 
22a8				; left shift de 
22a8 eb				ex de, hl	 
22a9 29				add hl, hl 
22aa			 
22aa				; is 1 
22aa fe 31			cp '1' 
22ac 20 02			jr nz, .binzero 
22ae cb 4d			bit 1, l 
22b0			.binzero: 
22b0 eb				ex de, hl	 ; save current de 
22b1 18 ef			jr .fapbinshift 
22b3			 
22b3			.fapbdone: 
22b3 eb				ex de, hl 
22b4 c3 03 21			jp forth_push_numhl 
22b7			 
22b7			 
22b7			.faphex:   ; hex is always stored as a 16bit word 
22b7				; skip number prefix 
22b7 23				inc hl 
22b8				; turn ascii into number 
22b8 cd 86 13			call get_word_hl	; ret 16bit word in hl 
22bb			 
22bb c3 03 21			jp forth_push_numhl 
22be			 
22be 00				 nop 
22bf			 
22bf			.fabin:   ; TODO bin conversion 
22bf			 
22bf			 
22bf c9				ret 
22c0			 
22c0			 
22c0			; get either a string ptr or a 16bit word from the data stack 
22c0			 
22c0			FORTH_DSP: macro 
22c0				call macro_forth_dsp 
22c0				endm 
22c0			 
22c0			macro_forth_dsp: 
22c0				; data stack pointer points to current word on tos 
22c0			 
22c0 2a 29 f9			ld hl,(cli_data_sp) 
22c3			 
22c3				if DEBUG_FORTH_PUSH 
22c3						DMARK "DSP" 
22c3 f5				push af  
22c4 3a d8 22			ld a, (.dmark)  
22c7 32 a6 fd			ld (debug_mark),a  
22ca 3a d9 22			ld a, (.dmark+1)  
22cd 32 a7 fd			ld (debug_mark+1),a  
22d0 3a da 22			ld a, (.dmark+2)  
22d3 32 a8 fd			ld (debug_mark+2),a  
22d6 18 03			jr .pastdmark  
22d8 ..			.dmark: db "DSP"  
22db f1			.pastdmark: pop af  
22dc			endm  
# End of macro DMARK
22dc			 
22dc cd b6 5e				call display_data_sp 
22df				;call break_point_state 
22df				;rst 030h 
22df				CALLMONITOR 
22df cd aa fd			call debug_vector  
22e2				endm  
# End of macro CALLMONITOR
22e2				endif 
22e2			 
22e2 c9				ret 
22e3			 
22e3			; return hl to start of value on stack 
22e3			 
22e3			FORTH_DSP_VALUE: macro 
22e3				call macro_forth_dsp_value 
22e3				endm 
22e3			 
22e3			macro_forth_dsp_value: 
22e3			 
22e3				FORTH_DSP 
22e3 cd c0 22			call macro_forth_dsp 
22e6				endm 
# End of macro FORTH_DSP
22e6			 
22e6 d5				push de 
22e7			 
22e7 23				inc hl ; skip type 
22e8			 
22e8 5e				ld e, (hl) 
22e9 23				inc hl 
22ea 56				ld d, (hl) 
22eb eb				ex de,hl  
22ec			 
22ec d1				pop de 
22ed			 
22ed c9				ret 
22ee			 
22ee			; return hl to start of value to second item on stack 
22ee			 
22ee			FORTH_DSP_VALUEM1: macro 
22ee				call macro_forth_dsp_value_m1 
22ee				endm 
22ee			 
22ee			macro_forth_dsp_value_m1: 
22ee			 
22ee				FORTH_DSP 
22ee cd c0 22			call macro_forth_dsp 
22f1				endm 
# End of macro FORTH_DSP
22f1			 
22f1 2b				dec hl 
22f2 2b				dec hl 
22f3			;	dec hl 
22f3			 
22f3 d5				push de 
22f4			 
22f4 5e				ld e, (hl) 
22f5 23				inc hl 
22f6 56				ld d, (hl) 
22f7 eb				ex de,hl  
22f8			 
22f8 d1				pop de 
22f9			 
22f9 c9				ret 
22fa			 
22fa				 
22fa			 
22fa			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
22fa			 
22fa			FORTH_DSP_POP: macro 
22fa				call macro_forth_dsp_pop 
22fa				endm 
22fa			 
22fa			 
22fa			; get the tos data type 
22fa			 
22fa			FORTH_DSP_TYPE:   macro 
22fa			 
22fa				;FORTH_DSP_VALUE 
22fa				FORTH_DSP 
22fa				 
22fa				; hl points to value 
22fa				; check type 
22fa			 
22fa				ld a,(hl) 
22fa			 
22fa				endm 
22fa			 
22fa			; load the tos value into hl 
22fa			 
22fa			 
22fa			FORTH_DSP_VALUEHL:  macro 
22fa				call macro_dsp_valuehl 
22fa				endm 
22fa			 
22fa			 
22fa			 
22fa			macro_dsp_valuehl: 
22fa				FORTH_DSP_VALUE 
22fa cd e3 22			call macro_forth_dsp_value 
22fd				endm 
# End of macro FORTH_DSP_VALUE
22fd			 
22fd				;FORTH_ERR_TOS_NOTNUM 
22fd			 
22fd				;inc hl   ; skip type id 
22fd			 
22fd			;	push de 
22fd			; 
22fd			;	ld e, (hl) 
22fd			;	inc hl 
22fd			;	ld d, (hl) 
22fd			;	ex de,hl  
22fd			 
22fd			;	pop de 
22fd			 
22fd				if DEBUG_FORTH_PUSH 
22fd						DMARK "DVL" 
22fd f5				push af  
22fe 3a 12 23			ld a, (.dmark)  
2301 32 a6 fd			ld (debug_mark),a  
2304 3a 13 23			ld a, (.dmark+1)  
2307 32 a7 fd			ld (debug_mark+1),a  
230a 3a 14 23			ld a, (.dmark+2)  
230d 32 a8 fd			ld (debug_mark+2),a  
2310 18 03			jr .pastdmark  
2312 ..			.dmark: db "DVL"  
2315 f1			.pastdmark: pop af  
2316			endm  
# End of macro DMARK
2316				CALLMONITOR 
2316 cd aa fd			call debug_vector  
2319				endm  
# End of macro CALLMONITOR
2319				endif 
2319 c9				ret 
231a			 
231a			forth_apushstrhl:      
231a				; push of string requires use of cli_origptr 
231a				; bodge use 
231a			 
231a				; get current cli_origptr, save, update with temp pointer  
231a ed 5b 79 f9		ld de, (cli_origptr) 
231e 22 79 f9			ld (cli_origptr), hl 
2321 d5				push de 
2322 cd 6c 22			call forth_apush 
2325 d1				pop de 
2326 ed 53 79 f9		ld (cli_origptr), de 
232a c9			        ret	 
232b			 
232b			 
232b			; increase loop stack pointer and save hl to it 
232b				 
232b			FORTH_LOOP_NEXT: macro 
232b				call macro_forth_loop_next 
232b				;nop 
232b				endm 
232b			 
232b			macro_forth_loop_next: 
232b				if DEBUG_FORTH_STACK_GUARD 
232b cd 19 73				call check_stacks 
232e				endif 
232e e5				push hl 
232f d5				push de 
2330 eb				ex de,hl 
2331 2a 2b f9			ld hl,(cli_loop_sp) 
2334 23				inc hl 
2335 23				inc hl 
2336					if DEBUG_FORTH_WORDS 
2336						DMARK "LNX" 
2336 f5				push af  
2337 3a 4b 23			ld a, (.dmark)  
233a 32 a6 fd			ld (debug_mark),a  
233d 3a 4c 23			ld a, (.dmark+1)  
2340 32 a7 fd			ld (debug_mark+1),a  
2343 3a 4d 23			ld a, (.dmark+2)  
2346 32 a8 fd			ld (debug_mark+2),a  
2349 18 03			jr .pastdmark  
234b ..			.dmark: db "LNX"  
234e f1			.pastdmark: pop af  
234f			endm  
# End of macro DMARK
234f						CALLMONITOR 
234f cd aa fd			call debug_vector  
2352				endm  
# End of macro CALLMONITOR
2352					endif 
2352 22 2b f9			ld (cli_loop_sp),hl 
2355 73				ld (hl), e 
2356 23				inc hl 
2357 72				ld (hl), d 
2358 d1				pop de    ; been reversed so save a swap on restore 
2359 e1				pop hl 
235a				if DEBUG_FORTH_STACK_GUARD 
235a cd 19 73				call check_stacks 
235d				endif 
235d c9				ret 
235e			 
235e			; get current ret stack pointer and save to hl  
235e				 
235e			FORTH_LOOP_TOS: macro 
235e				call macro_forth_loop_tos 
235e				endm 
235e			 
235e			macro_forth_loop_tos: 
235e d5				push de 
235f 2a 2b f9			ld hl,(cli_loop_sp) 
2362 5e				ld e, (hl) 
2363 23				inc hl 
2364 56				ld d, (hl) 
2365 eb				ex de, hl 
2366 d1				pop de 
2367 c9				ret 
2368			 
2368			; pop loop stack pointer 
2368				 
2368			FORTH_LOOP_POP: macro 
2368				call macro_forth_loop_pop 
2368				endm 
2368			 
2368			 
2368			macro_forth_loop_pop: 
2368				if DEBUG_FORTH_STACK_GUARD 
2368					DMARK "LPP" 
2368 f5				push af  
2369 3a 7d 23			ld a, (.dmark)  
236c 32 a6 fd			ld (debug_mark),a  
236f 3a 7e 23			ld a, (.dmark+1)  
2372 32 a7 fd			ld (debug_mark+1),a  
2375 3a 7f 23			ld a, (.dmark+2)  
2378 32 a8 fd			ld (debug_mark+2),a  
237b 18 03			jr .pastdmark  
237d ..			.dmark: db "LPP"  
2380 f1			.pastdmark: pop af  
2381			endm  
# End of macro DMARK
2381 cd 19 73				call check_stacks 
2384					FORTH_CHK_LOOP_UNDER 
2384 e5				push hl 
2385 d5				push de 
2386 2a 2b f9			ld hl,(cli_loop_sp) 
2389 11 65 f8			ld de, cli_loop_stack 
238c cd ed 0f			call cmp16 
238f da 33 74			jp c, fault_loop_under 
2392 d1				pop de 
2393 e1				pop hl 
2394				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2394				endif 
2394 e5				push hl 
2395 2a 2b f9			ld hl,(cli_loop_sp) 
2398 2b				dec hl 
2399 2b				dec hl 
239a 22 2b f9			ld (cli_loop_sp), hl 
239d				; TODO do stack underflow checks 
239d e1				pop hl 
239e				if DEBUG_FORTH_STACK_GUARD 
239e cd 19 73				call check_stacks 
23a1					FORTH_CHK_LOOP_UNDER 
23a1 e5				push hl 
23a2 d5				push de 
23a3 2a 2b f9			ld hl,(cli_loop_sp) 
23a6 11 65 f8			ld de, cli_loop_stack 
23a9 cd ed 0f			call cmp16 
23ac da 33 74			jp c, fault_loop_under 
23af d1				pop de 
23b0 e1				pop hl 
23b1				endm 
# End of macro FORTH_CHK_LOOP_UNDER
23b1				endif 
23b1 c9				ret 
23b2			 
23b2			macro_forth_dsp_pop: 
23b2			 
23b2 e5				push hl 
23b3			 
23b3				; release malloc data 
23b3			 
23b3				if DEBUG_FORTH_STACK_GUARD 
23b3 cd 19 73				call check_stacks 
23b6					FORTH_CHK_DSP_UNDER 
23b6 e5				push hl 
23b7 d5				push de 
23b8 2a 29 f9			ld hl,(cli_data_sp) 
23bb 11 63 f6			ld de, cli_data_stack 
23be cd ed 0f			call cmp16 
23c1 da 27 74			jp c, fault_dsp_under 
23c4 d1				pop de 
23c5 e1				pop hl 
23c6				endm 
# End of macro FORTH_CHK_DSP_UNDER
23c6				endif 
23c6				;ld hl,(cli_data_sp) 
23c6			if DEBUG_FORTH_DOT 
23c6				DMARK "DPP" 
23c6 f5				push af  
23c7 3a db 23			ld a, (.dmark)  
23ca 32 a6 fd			ld (debug_mark),a  
23cd 3a dc 23			ld a, (.dmark+1)  
23d0 32 a7 fd			ld (debug_mark+1),a  
23d3 3a dd 23			ld a, (.dmark+2)  
23d6 32 a8 fd			ld (debug_mark+2),a  
23d9 18 03			jr .pastdmark  
23db ..			.dmark: db "DPP"  
23de f1			.pastdmark: pop af  
23df			endm  
# End of macro DMARK
23df				CALLMONITOR 
23df cd aa fd			call debug_vector  
23e2				endm  
# End of macro CALLMONITOR
23e2			endif	 
23e2			 
23e2			 
23e2			if FORTH_ENABLE_DSPPOPFREE 
23e2			 
23e2				FORTH_DSP 
23e2 cd c0 22			call macro_forth_dsp 
23e5				endm 
# End of macro FORTH_DSP
23e5			 
23e5 7e				ld a, (hl) 
23e6 fe 01			cp DS_TYPE_STR 
23e8 20 23			jr nz, .skippopfree 
23ea			 
23ea				FORTH_DSP_VALUEHL 
23ea cd fa 22			call macro_dsp_valuehl 
23ed				endm 
# End of macro FORTH_DSP_VALUEHL
23ed 00				nop 
23ee			if DEBUG_FORTH_DOT 
23ee				DMARK "DPf" 
23ee f5				push af  
23ef 3a 03 24			ld a, (.dmark)  
23f2 32 a6 fd			ld (debug_mark),a  
23f5 3a 04 24			ld a, (.dmark+1)  
23f8 32 a7 fd			ld (debug_mark+1),a  
23fb 3a 05 24			ld a, (.dmark+2)  
23fe 32 a8 fd			ld (debug_mark+2),a  
2401 18 03			jr .pastdmark  
2403 ..			.dmark: db "DPf"  
2406 f1			.pastdmark: pop af  
2407			endm  
# End of macro DMARK
2407				CALLMONITOR 
2407 cd aa fd			call debug_vector  
240a				endm  
# End of macro CALLMONITOR
240a			endif	 
240a cd 6c 15			call free 
240d			.skippopfree: 
240d				 
240d			 
240d			endif 
240d			 
240d			if DEBUG_FORTH_DOT_KEY 
240d				DMARK "DP2" 
240d				CALLMONITOR 
240d			endif	 
240d			 
240d				; move pointer down 
240d			 
240d 2a 29 f9			ld hl,(cli_data_sp) 
2410 2b				dec hl 
2411 2b				dec hl 
2412			; PARSEV5 
2412 2b				dec hl 
2413 22 29 f9			ld (cli_data_sp), hl 
2416			 
2416				if DEBUG_FORTH_STACK_GUARD 
2416 cd 19 73				call check_stacks 
2419					FORTH_CHK_DSP_UNDER 
2419 e5				push hl 
241a d5				push de 
241b 2a 29 f9			ld hl,(cli_data_sp) 
241e 11 63 f6			ld de, cli_data_stack 
2421 cd ed 0f			call cmp16 
2424 da 27 74			jp c, fault_dsp_under 
2427 d1				pop de 
2428 e1				pop hl 
2429				endm 
# End of macro FORTH_CHK_DSP_UNDER
2429				endif 
2429			 
2429 e1				pop hl 
242a			 
242a c9				ret 
242b			 
242b			getwordathl: 
242b				; hl points to an address 
242b				; load hl with the word at that address 
242b			 
242b d5				push de 
242c			 
242c 5e				ld e, (hl) 
242d 23				inc hl 
242e 56				ld d, (hl) 
242f eb				ex de, hl 
2430			 
2430 d1				pop de 
2431 c9				ret 
2432			 
2432			 
2432			 
2432			 
2432			 
2432			; eof 
2432			 
# End of file forth_stackopsv5.asm
2432			endif 
2432			 
2432			loadwordinhl:	 
2432			 
2432 d5				push de 
2433			 
2433 5e				ld e, (hl) 
2434 23				inc hl 
2435 56				ld d, (hl) 
2436 eb				ex de,hl  
2437			 
2437 d1				pop de 
2438			 
2438 c9				ret 
2439			 
2439			user_word_eol:  
2439				; hl contains the pointer to where to create a linked list item from the end 
2439				; of the user dict to continue on at the system word dict 
2439				 
2439				; poke the stub of the word list linked list to repoint to rom words 
2439			 
2439				; stub format 
2439				; db   word id 
2439				; dw    link to next word 
2439			        ; db char length of token 
2439				; db string + 0 term 
2439				; db exec code....  
2439			 
2439 3e 00			ld a, WORD_SYS_ROOT     ; root word 
243b 77				ld (hl), a		; word id 
243c 23				inc hl 
243d			 
243d 11 08 26			ld de, sysdict 
2440 73				ld (hl), e		; next word link ie system dict 
2441 23				inc hl 
2442 72				ld (hl), d		; next word link ie system dict 
2443 23				inc hl	 
2444			 
2444			;	ld (hl), sysdict		; next word link ie system dict 
2444			;	inc hl 
2444			;	inc hl 
2444			 
2444			;	inc hl 
2444			;	inc hl 
2444			 
2444 3e 02			ld a, 2			; word length is 0 
2446 77				ld (hl), a	 
2447 23				inc hl 
2448			 
2448 3e 7e			ld a, '~'			; word length is 0 
244a 77				ld (hl), a	 
244b 23				inc hl 
244c 3e 00			ld a, 0			; save empty word 
244e 77				ld (hl), a 
244f			 
244f c9				ret 
2450			 
2450				 
2450			 
2450			forthexec_cleanup: 
2450				FORTH_RSP_POP 
2450 cd cb 20			call macro_forth_rsp_pop 
2453				endm 
# End of macro FORTH_RSP_POP
2453 c9				ret 
2454			 
2454			forth_call_hl: 
2454				; taking hl 
2454 e5				push hl 
2455 c9				ret 
2456			 
2456			; this is called to reset Forth system but keep existing uwords etc 
2456			 
2456			forth_warmstart: 
2456				; setup stack over/under flow checks 
2456				if DEBUG_FORTH_STACK_GUARD 
2456 cd ff 72				call chk_stk_init 
2459				endif 
2459			 
2459				; init stack pointers  - * these stacks go upwards *  
2459 21 e7 f8			ld hl, cli_ret_stack 
245c 22 2d f9			ld (cli_ret_sp), hl	 
245f				; set bottom of stack 
245f 3e 00			ld a,0 
2461 77				ld (hl),a 
2462 23				inc hl 
2463 77				ld (hl),a 
2464			 
2464 21 63 f6			ld hl, cli_data_stack 
2467 22 29 f9			ld (cli_data_sp), hl	 
246a				; set bottom of stack 
246a 3e 00			ld a,0 
246c 77				ld (hl),a 
246d 23				inc hl 
246e 77				ld (hl),a 
246f			 
246f 21 65 f8			ld hl, cli_loop_stack 
2472 22 2b f9			ld (cli_loop_sp), hl	 
2475				; set bottom of stack 
2475 3e 00			ld a,0 
2477 77				ld (hl),a 
2478 23				inc hl 
2479 77				ld (hl),a 
247a			 
247a				; init extent of current open file 
247a			 
247a 3e 00			ld a, 0 
247c 32 a5 f9			ld (store_openext), a 
247f			 
247f c9				ret 
2480			 
2480			 
2480			 
2480			; Cold Start - this is called to setup the whole Forth system 
2480			 
2480			forth_init: 
2480			 
2480				; setup stack over/under flow checks 
2480			 
2480			;	if DEBUG_FORTH_STACK_GUARD 
2480			;		call chk_stk_init 
2480			;	endif 
2480			 
2480				; enable auto display updates (slow.....) 
2480			 
2480 3e 01			ld a, 1 
2482 32 77 f9			ld (cli_autodisplay), a 
2485			 
2485				; if storage is in use disable long reads for now 
2485 3e 00			ld a, 0 
2487 32 b0 f9			ld (store_longread), a 
248a			 
248a			 
248a				; show start up screen 
248a			 
248a cd 9b 0d			call clear_display 
248d			 
248d 3e 00			ld a,0 
248f 32 99 f9			ld (f_cursor_ptr), a 
2492			 
2492				; set start of word list in start of ram - for use when creating user words 
2492			 
2492 21 00 80			ld hl, baseram 
2495 22 f9 f3			ld (os_last_new_uword), hl 
2498 cd 39 24			call user_word_eol 
249b				 
249b			;		call display_data_sp 
249b			;		call next_page_prompt 
249b			 
249b			 
249b			 
249b			 
249b c9				ret 
249c			 
249c .. 00		.bootforth: db " Forth Kernel Init ",0 
24b0			 
24b0			; TODO push to stack 
24b0			 
24b0			;  
24b0			 
24b0			if FORTH_PARSEV2 
24b0			 
24b0			 
24b0				include "forth_parserv2.asm" 
24b0			 
24b0			endif 
24b0			 
24b0			 
24b0			; parse cli version 1 
24b0			 
24b0			if FORTH_PARSEV1 
24b0			 
24b0			 
24b0			 
24b0			      include "forth_parserv1.asm" 
24b0			endif 
24b0				 
24b0			if FORTH_PARSEV3 
24b0			 
24b0			 
24b0			 
24b0			      include "forth_parserv3.asm" 
24b0				include "forth_wordsv3.asm" 
24b0			endif 
24b0			 
24b0			if FORTH_PARSEV4 
24b0			 
24b0			 
24b0			 
24b0			      include "forth_parserv4.asm" 
24b0				include "forth_wordsv4.asm" 
24b0			endif 
24b0			 
24b0			if FORTH_PARSEV5 
24b0			 
24b0			 
24b0			 
24b0			      include "forth_parserv5.asm" 
24b0			 
24b0			 
24b0			; A better parser without using malloc and string copies all over the place.  
24b0			; Exec in situ should be faster 
24b0			 
24b0			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
24b0			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
24b0			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
24b0			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
24b0			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
24b0			WORD_SYS_END: equ 0   ; Opcode for all user words 
24b0			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
24b0			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
24b0			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
24b0			 
24b0			; Core word preamble macro 
24b0			 
24b0			CWHEAD:   macro nxtword opcode lit len opflags 
24b0				db WORD_SYS_CORE+opcode             
24b0				; internal op code number 
24b0				dw nxtword            
24b0				; link to next dict word block 
24b0				db len + 1 
24b0				; literal length of dict word inc zero term 
24b0				db lit,0              
24b0				; literal dict word 
24b0			        ; TODO db opflags        
24b0				endm 
24b0			 
24b0			 
24b0			NEXTW: macro  
24b0				jp macro_next 
24b0				endm 
24b0			 
24b0			macro_next: 
24b0			if DEBUG_FORTH_PARSE_KEY 
24b0				DMARK "NXT" 
24b0				CALLMONITOR 
24b0			endif	 
24b0			;	inc hl  ; skip token null term  
24b0 ed 4b 7b f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
24b4 ed 5b 79 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
24b8 2a fd f3			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
24bb			if DEBUG_FORTH_PARSE_KEY 
24bb				DMARK "}AA" 
24bb				CALLMONITOR 
24bb			endif	 
24bb c3 be 25			jp execnext 
24be				;jp exec1 
24be			       
24be			 
24be			 
24be			; Another go at the parser to compile  
24be			 
24be			 
24be			; TODO rework parser to change all of the string words to byte tokens 
24be			; TODO do a search for  
24be			 
24be			; TODO first run normal parser to zero term sections 
24be			; TODO for each word do a token look up to get the op code 
24be			; TODO need some means to flag to the exec that this is a byte code form    
24be			 
24be			 
24be			forthcompile: 
24be			 
24be			; 
24be			; line parse: 
24be			;       parse raw input buffer 
24be			;       tokenise the words 
24be			;       malloc new copy (for looping etc) 
24be			;       copy to malloc + current pc in line to start of string and add line term 
24be			;       save on new rsp 
24be			; 
24be			 
24be			; hl to point to the line to tokenise 
24be			 
24be			;	push hl 
24be 22 fd f3			ld (os_tok_ptr), hl  ; save ptr to string 
24c1			 
24c1			;	ld a,0		; string term on input 
24c1			;	call strlent 
24c1			 
24c1			;	ld (os_tok_len), hl	 ; save string length 
24c1			 
24c1			;if DEBUG_FORTH_TOK 
24c1			;	ex de,hl		 
24c1			;endif 
24c1			 
24c1			;	pop hl 		; get back string pointer 
24c1			 
24c1			if DEBUG_FORTH_TOK 
24c1						DMARK "TOc" 
24c1				CALLMONITOR 
24c1			endif 
24c1 7e			.cptoken2:    ld a,(hl) 
24c2 23				inc hl 
24c3 fe 7f			cp FORTH_END_BUFFER 
24c5 28 29			jr z, .cptokendone2 
24c7 fe 00			cp 0 
24c9 28 25			jr z, .cptokendone2 
24cb fe 22			cp '"' 
24cd 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
24cf fe 20			cp ' ' 
24d1 20 ee			jr nz,  .cptoken2 
24d3			 
24d3			; TODO consume comments held between ( and ) 
24d3			 
24d3				; we have a space so change to zero term for dict match later 
24d3 2b				dec hl 
24d4 3e 00			ld a,0 
24d6 77				ld (hl), a 
24d7 23				inc hl 
24d8 18 e7			jr .cptoken2 
24da				 
24da			 
24da			.cptokenstr2: 
24da				; skip all white space until either eol (because forgot to term) or end double quote 
24da			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
24da				;inc hl ; skip current double quote 
24da 7e				ld a,(hl) 
24db 23				inc hl 
24dc fe 22			cp '"' 
24de 28 e1			jr z, .cptoken2 
24e0 fe 7f			cp FORTH_END_BUFFER 
24e2 28 0c			jr z, .cptokendone2 
24e4 fe 00			cp 0 
24e6 28 08			jr z, .cptokendone2 
24e8 fe 20			cp ' ' 
24ea 28 02			jr z, .cptmp2 
24ec 18 ec			jr .cptokenstr2 
24ee			 
24ee			.cptmp2:	; we have a space so change to zero term for dict match later 
24ee				;dec hl 
24ee				;ld a,"-"	; TODO remove this when working 
24ee				;ld (hl), a 
24ee				;inc hl 
24ee 18 ea			jr .cptokenstr2 
24f0			 
24f0			.cptokendone2: 
24f0				;inc hl 
24f0 3e 7f			ld a, FORTH_END_BUFFER 
24f2 77				ld (hl),a 
24f3 23				inc hl 
24f4 3e 21			ld a, '!' 
24f6 77				ld (hl),a 
24f7			 
24f7 2a fd f3			ld hl,(os_tok_ptr) 
24fa			         
24fa			if DEBUG_FORTH_TOK 
24fa						DMARK "Tc1" 
24fa				CALLMONITOR 
24fa			endif 
24fa			 
24fa				; push exec string to top of return stack 
24fa				FORTH_RSP_NEXT 
24fa cd aa 20			call macro_forth_rsp_next 
24fd				endm 
# End of macro FORTH_RSP_NEXT
24fd c9				ret 
24fe			 
24fe			; Another go at the parser need to simplify the process 
24fe			 
24fe			forthparse: 
24fe			 
24fe			; 
24fe			; line parse: 
24fe			;       parse raw input buffer 
24fe			;       tokenise the words 
24fe			;       malloc new copy (for looping etc) 
24fe			;       copy to malloc + current pc in line to start of string and add line term 
24fe			;       save on new rsp 
24fe			; 
24fe			 
24fe			; hl to point to the line to tokenise 
24fe			 
24fe			;	push hl 
24fe 22 fd f3			ld (os_tok_ptr), hl  ; save ptr to string 
2501			 
2501			;	ld a,0		; string term on input 
2501			;	call strlent 
2501			 
2501			;	ld (os_tok_len), hl	 ; save string length 
2501			 
2501			;if DEBUG_FORTH_TOK 
2501			;	ex de,hl		 
2501			;endif 
2501			 
2501			;	pop hl 		; get back string pointer 
2501			 
2501			if DEBUG_FORTH_TOK 
2501						DMARK "TOK" 
2501				CALLMONITOR 
2501			endif 
2501 7e			.ptoken2:    ld a,(hl) 
2502 23				inc hl 
2503 fe 7f			cp FORTH_END_BUFFER 
2505 28 29			jr z, .ptokendone2 
2507 fe 00			cp 0 
2509 28 25			jr z, .ptokendone2 
250b fe 22			cp '"' 
250d 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
250f fe 20			cp ' ' 
2511 20 ee			jr nz,  .ptoken2 
2513			 
2513			; TODO consume comments held between ( and ) 
2513			 
2513				; we have a space so change to zero term for dict match later 
2513 2b				dec hl 
2514 3e 00			ld a,0 
2516 77				ld (hl), a 
2517 23				inc hl 
2518 18 e7			jr .ptoken2 
251a				 
251a			 
251a			.ptokenstr2: 
251a				; skip all white space until either eol (because forgot to term) or end double quote 
251a			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
251a				;inc hl ; skip current double quote 
251a 7e				ld a,(hl) 
251b 23				inc hl 
251c fe 22			cp '"' 
251e 28 e1			jr z, .ptoken2 
2520 fe 7f			cp FORTH_END_BUFFER 
2522 28 0c			jr z, .ptokendone2 
2524 fe 00			cp 0 
2526 28 08			jr z, .ptokendone2 
2528 fe 20			cp ' ' 
252a 28 02			jr z, .ptmp2 
252c 18 ec			jr .ptokenstr2 
252e			 
252e			.ptmp2:	; we have a space so change to zero term for dict match later 
252e				;dec hl 
252e				;ld a,"-"	; TODO remove this when working 
252e				;ld (hl), a 
252e				;inc hl 
252e 18 ea			jr .ptokenstr2 
2530			 
2530			.ptokendone2: 
2530				;inc hl 
2530 3e 7f			ld a, FORTH_END_BUFFER 
2532 77				ld (hl),a 
2533 23				inc hl 
2534 3e 21			ld a, '!' 
2536 77				ld (hl),a 
2537			 
2537 2a fd f3			ld hl,(os_tok_ptr) 
253a			         
253a			if DEBUG_FORTH_TOK 
253a						DMARK "TK1" 
253a				CALLMONITOR 
253a			endif 
253a			 
253a				; push exec string to top of return stack 
253a				FORTH_RSP_NEXT 
253a cd aa 20			call macro_forth_rsp_next 
253d				endm 
# End of macro FORTH_RSP_NEXT
253d c9				ret 
253e			 
253e			; 
253e			;	; malloc size + buffer pointer + if is loop flag 
253e			;	ld hl,(os_tok_len) 		 ; get string length 
253e			; 
253e			;	ld a,l 
253e			; 
253e			;	cp 0			; we dont want to use a null string 
253e			;	ret z 
253e			; 
253e			;;	add 3    ; prefix malloc with buffer for current word ptr 
253e			; 
253e			;	add 5     ; TODO when certain not over writing memory remove 
253e			; 
253e			;		 
253e			; 
253e			;if DEBUG_FORTH_TOK 
253e			;			DMARK "TKE" 
253e			;	CALLMONITOR 
253e			;endif 
253e			; 
253e			;	ld l,a 
253e			;	ld h,0 
253e			;;	push hl   ; save required space for the copy later 
253e			;	call malloc 
253e			;if DEBUG_FORTH_TOK 
253e			;			DMARK "TKM" 
253e			;	CALLMONITOR 
253e			;endif 
253e			;	if DEBUG_FORTH_MALLOC_GUARD 
253e			;		push af 
253e			;		call ishlzero 
253e			;;		ld a, l 
253e			;;		add h 
253e			;;		cp 0 
253e			;		pop af 
253e			;		 
253e			;		call z,malloc_error 
253e			;	endif 
253e			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
253e			; 
253e			; 
253e			;if DEBUG_FORTH_TOK 
253e			;			DMARK "TKR" 
253e			;	CALLMONITOR 
253e			;endif 
253e			; 
253e			;	FORTH_RSP_NEXT 
253e			; 
253e			;	;inc hl	 ; go past current buffer pointer 
253e			;	;inc hl 
253e			;	;inc hl   ; and past if loop flag 
253e			;		; TODO Need to set flag  
253e			; 
253e			;	 
253e			;	 
253e			;	ex de,hl	; malloc is dest 
253e			;	ld hl, (os_tok_len) 
253e			;;	pop bc 
253e			;	ld c, l                
253e			;	ld b,0 
253e			;	ld hl, (os_tok_ptr) 
253e			; 
253e			;if DEBUG_FORTH_TOK 
253e			;			DMARK "TKT" 
253e			;	CALLMONITOR 
253e			;endif 
253e			; 
253e			;	; do str cpy 
253e			; 
253e			;	ldir      ; copy byte in hl to de 
253e			; 
253e			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
253e			; 
253e			;if DEBUG_FORTH_TOK 
253e			; 
253e			;			DMARK "TKY" 
253e			;	CALLMONITOR 
253e			;endif 
253e			;	;ld a,0 
253e			;	;ld a,FORTH_END_BUFFER 
253e			;	ex de, hl 
253e			;	;dec hl			 ; go back over the space delim at the end of word 
253e			;	;ld (hl),a 
253e			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
253e			;	ld a,FORTH_END_BUFFER 
253e			;	ld (hl),a 
253e			;	inc hl 
253e			;	ld a,FORTH_END_BUFFER 
253e			;	ld (hl),a 
253e			; 
253e			;	; init the malloc area data 
253e			;	; set pc for in current area 
253e			;	;ld hl, (os_tok_malloc) 
253e			;	;inc hl 
253e			;	;inc hl 
253e			;	;inc hl 
253e			;	;ex de,hl 
253e			;	;ld hl, (os_tok_malloc) 
253e			;	;ld (hl),e 
253e			;	;inc hl 
253e			;	;ld (hl),d 
253e			; 
253e			; 
253e			;	ld hl,(os_tok_malloc) 
253e			;if DEBUG_FORTH_PARSE_KEY 
253e			;			DMARK "TKU" 
253e			;	CALLMONITOR 
253e			;endif 
253e			; 
253e			;	ret 
253e			 
253e			forthexec: 
253e			 
253e			; line exec: 
253e			; forth parser 
253e			 
253e			; 
253e			;       get current exec line on rsp 
253e			 
253e				FORTH_RSP_TOS 
253e cd c1 20			call macro_forth_rsp_tos 
2541				endm 
# End of macro FORTH_RSP_TOS
2541			 
2541			;       restore current pc - hl points to malloc of data 
2541			 
2541				;ld e, (hl) 
2541				;inc hl 
2541				;ld d, (hl) 
2541				;ex de,hl 
2541			 
2541			 
2541			exec1: 
2541 22 fd f3			ld (os_tok_ptr), hl 
2544			 
2544				; copy our PC to working vars  
2544 22 7b f9			ld (cli_ptr), hl 
2547 22 79 f9			ld (cli_origptr), hl 
254a			 
254a 7e				ld a,(hl) 
254b fe 7f			cp FORTH_END_BUFFER 
254d c8				ret z 
254e			 
254e				; skip any nulls 
254e			 
254e fe 00			cp 0 
2550 20 03			jr nz, .execword 
2552 23				inc hl 
2553 18 ec			jr exec1 
2555			 
2555			 
2555			.execword: 
2555			 
2555			 
2555			 
2555			if DEBUG_FORTH_PARSE_KEY 
2555						DMARK "KYQ" 
2555				CALLMONITOR 
2555			endif 
2555			;       while at start of word: 
2555			; get start of dict (in user area first) 
2555			 
2555 21 00 80		ld hl, baseram 
2558			;ld hl, sysdict 
2558 22 7d f9		ld (cli_nextword),hl 
255b			;           match word at pc 
255b			;           exec word 
255b			;           or push to dsp 
255b			;           forward to next token 
255b			;           if line term pop rsp and exit 
255b			;        
255b			 
255b			if DEBUG_FORTH_PARSE_KEY 
255b						DMARK "KYq" 
255b				CALLMONITOR 
255b			endif 
255b			 
255b			; 
255b			; word comp 
255b			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
255b			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
255b			;    move to start of word  
255b			;    compare word to cli_token 
255b			 
255b			.execpnword:	; HL at start of a word in the dictionary to check 
255b			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
255b			;	ld (cli_ptr), hl 
255b			 
255b 2a 7d f9			ld hl,(cli_nextword) 
255e			 
255e cd 01 26			call forth_tok_next 
2561			; tok next start here 
2561			;	; TODO skip compiled symbol for now 
2561			;	inc hl 
2561			; 
2561			;	; save pointer to next word 
2561			; 
2561			;	; hl now points to the address of the next word pointer  
2561			;	ld e, (hl) 
2561			;	inc hl 
2561			;	ld d, (hl) 
2561			;	inc l 
2561			; 
2561			;	ex de,hl 
2561			;if DEBUG_FORTH_PARSE_NEXTWORD 
2561			;	push bc 
2561			;	ld bc, (cli_nextword) 
2561			;			DMARK "NXW" 
2561			;	CALLMONITOR 
2561			;	pop bc 
2561			;endif 
2561			; tok next end here 
2561 22 7d f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
2564 eb				ex de, hl 
2565			 
2565			 
2565				; save the pointer of the current token - 1 to check against 
2565				 
2565 22 81 f9			ld (cli_token), hl   
2568				; TODO maybe remove below save if no debug 
2568				; save token string ptr for any debug later 
2568 23				inc hl  
2569 22 83 f9			ld (cli_origtoken), hl 
256c 2b				dec hl 
256d				; save pointer to the start of the next dictionay word 
256d 7e				ld a,(hl)   ; get string length 
256e 47				ld b,a 
256f			.execpnwordinc:  
256f 23				inc hl 
2570 10 fd			djnz .execpnwordinc 
2572 22 7f f9			ld (cli_execword), hl      ; save start of this words code 
2575			 
2575				; now check the word token against the string being parsed 
2575			 
2575 2a 81 f9			ld hl,(cli_token) 
2578 23				inc hl     ; skip string length (use zero term instead to end) 
2579 22 81 f9			ld (cli_token), hl 
257c			 
257c			if DEBUG_FORTH_PARSE_KEY 
257c						DMARK "KY2" 
257c			endif 
257c			if DEBUG_FORTH_PARSE_EXEC 
257c				; see if disabled 
257c			 
257c			;	ld a, (os_view_disable) 
257c			;	cp '*' 
257c				ld a, (debug_vector) 
257c				cp $c9   ; RET  
257c				jr z, .skip 
257c			 
257c				push hl 
257c				push hl 
257c				call clear_display 
257c				ld de, .compword 
257c				ld a, display_row_1 
257c				call str_at_display 
257c				pop de 
257c				ld a, display_row_2 
257c				call str_at_display 
257c				ld hl,(cli_ptr) 
257c				ld a,(hl) 
257c			        ld hl, os_word_scratch 
257c				ld (hl),a 
257c				ld a,0 
257c				inc hl 
257c				ld (hl),a 	 
257c				ld de, os_word_scratch 
257c				ld a, display_row_2+10 
257c				call str_at_display 
257c				call update_display 
257c				ld a, 100 
257c				call aDelayInMS 
257c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
257c				call delay250ms 
257c				endif 
257c				pop hl 
257c			.skip:  
257c			endif	 
257c			.execpnchar:    ; compare char between token and string to parse 
257c			 
257c			if DEBUG_FORTH_PARSE_KEY 
257c						DMARK "Ky3" 
257c			endif 
257c			if DEBUG_FORTH_PARSE_EXEC 
257c				; see if disabled 
257c			 
257c			;	ld a, (os_view_disable) 
257c			;	cp '*' 
257c				ld a, (debug_vector) 
257c				cp $C9  ; RET 
257c				jr z, .skip2 
257c			 
257c			;	call clear_display 
257c			ld hl,(cli_token) 
257c			ld a,(hl) 
257c			ld (os_word_scratch),a 
257c				ld hl,(cli_ptr) 
257c			ld a,(hl) 
257c				ld (os_word_scratch+1),a 
257c				ld a,0 
257c				ld (os_word_scratch+2),a 
257c				ld de,os_word_scratch 
257c				ld a,display_row_4 
257c				call str_at_display 
257c				call update_display 
257c			.skip2:  
257c			endif 
257c 2a 81 f9			ld hl,(cli_token) 
257f 7e				ld a, (hl)	 ; char in word token 
2580 23				inc hl 		; move to next char 
2581 22 81 f9			ld (cli_token), hl ; and save it 
2584 47				ld b,a 
2585			 
2585 2a 7b f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
2588 7e				ld a,(hl) 
2589 23				inc hl 
258a 22 7b f9			ld (cli_ptr), hl		; move to next char 
258d cd 24 14			call toUpper 		; make sure the input string matches case 
2590			 
2590			if DEBUG_FORTH_PARSE 
2590			endif 
2590			 
2590				; input stream end of token is a space so get rid of it 
2590			 
2590			;	cp ' ' 
2590			;	jr nz, .pnskipspace 
2590			; 
2590			;	ld a, 0		; make same term as word token term 
2590			; 
2590			;.pnskipspace: 
2590			 
2590			if DEBUG_FORTH_PARSE_KEY 
2590						DMARK "KY7" 
2590			endif 
2590 b8				cp b 
2591 c2 a7 25			jp nz, .execpnskipword	 ; no match so move to next word 
2594				 
2594			;    if same 
2594			;       scan for string terms 0 for token and 32 for input 
2594			 
2594				 
2594			if DEBUG_FORTH_PARSE_KEY 
2594						DMARK "KY8" 
2594			endif 
2594			 
2594 80				add b			 
2595 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2597							; TODO need to make sure last word in zero term string is accounted for 
2597 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2599			 
2599			 
2599				; at end of both strings so both are exact match 
2599			 
2599			;       skip ptr for next word 
2599			 
2599 2a 7b f9			ld hl,(cli_ptr) 	; at input string term 
259c 23				inc hl			 ; at next char 
259d 22 7b f9			ld (cli_ptr), hl     ; save for next round of the parser 
25a0 22 79 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
25a3				 
25a3				 
25a3			if DEBUG_FORTH_PARSE_KEY 
25a3						DMARK "KY3" 
25a3			endif 
25a3			 
25a3			 
25a3			 
25a3			;       exec code block 
25a3			if DEBUG_FORTH_JP 
25a3				call clear_display 
25a3				call update_display 
25a3				call delay1s 
25a3				ld hl, (cli_execword)     ; save for next check if no match on this word 
25a3				ld a,h 
25a3				ld hl, os_word_scratch 
25a3				call hexout 
25a3				ld hl, (cli_execword)     ; save for next check if no match on this word 
25a3				ld a,l 
25a3				ld hl, os_word_scratch+2 
25a3				call hexout 
25a3				ld hl, os_word_scratch+4 
25a3				ld a,0 
25a3				ld (hl),a 
25a3				ld de,os_word_scratch 
25a3				call str_at_display 
25a3					ld a, display_row_2 
25a3					call str_at_display 
25a3				ld de, (cli_origtoken) 
25a3				ld a, display_row_1+10 
25a3					call str_at_display 
25a3			 
25a3				ld a,display_row_1 
25a3				ld de, .foundword 
25a3				ld a, display_row_3 
25a3				call str_at_display 
25a3				call update_display 
25a3				call delay1s 
25a3				call delay1s 
25a3				call delay1s 
25a3			endif 
25a3			 
25a3			if DEBUG_FORTH_PARSE_KEY 
25a3						DMARK "KYj" 
25a3			endif 
25a3				; TODO save the word pointer in this exec 
25a3			 
25a3 2a 7f f9			ld hl,(cli_execword) 
25a6 e9				jp (hl) 
25a7			 
25a7			 
25a7			;    if not same 
25a7			;	scan for zero term 
25a7			;	get ptr for next word 
25a7			;	goto word comp 
25a7			 
25a7			.execpnskipword:	; get pointer to next word 
25a7 2a 7d f9			ld hl,(cli_nextword) 
25aa			 
25aa 7e				ld a,(hl) 
25ab fe 00			cp WORD_SYS_END 
25ad			;	cp 0 
25ad 28 09			jr z, .execendofdict			 ; at end of words 
25af			 
25af			if DEBUG_FORTH_PARSE_KEY 
25af						DMARK "KY4" 
25af			endif 
25af			if DEBUG_FORTH_PARSE_EXEC 
25af			 
25af				; see if disabled 
25af			 
25af			;	ld a, (os_view_disable) 
25af			;	cp '*' 
25af				ld a,(debug_vector) 
25af				cp $c9   ; RET 
25af				jr z, .noskip 
25af			 
25af			 
25af				ld de, .nowordfound 
25af				ld a, display_row_3 
25af				call str_at_display 
25af				call update_display 
25af				ld a, 100 
25af				call aDelayInMS 
25af				 
25af				if DEBUG_FORTH_PARSE_EXEC_SLOW 
25af					call delay250ms 
25af				endif 
25af			.noskip:  
25af			 
25af			endif	 
25af			 
25af 2a 79 f9			ld hl,(cli_origptr) 
25b2 22 7b f9			ld (cli_ptr),hl 
25b5			 
25b5			if DEBUG_FORTH_PARSE_KEY 
25b5						DMARK "KY5" 
25b5			endif 
25b5 c3 5b 25			jp .execpnword			; else go to next word 
25b8			 
25b8			.execendofdict:  
25b8			 
25b8			if DEBUG_FORTH_PARSE_KEY 
25b8						DMARK "KYe" 
25b8			endif 
25b8			if DEBUG_FORTH_PARSE_EXEC 
25b8				; see if disabled 
25b8			 
25b8			;	ld a, (os_view_disable) 
25b8			;	cp '*' 
25b8				ld a,(debug_vector) 
25b8				cp $c9   ; ret 
25b8				jr z, .ispskip 
25b8			 
25b8				call clear_display 
25b8				call update_display 
25b8				call delay1s 
25b8				ld de, (cli_origptr) 
25b8				ld a, display_row_1 
25b8				call str_at_display 
25b8				 
25b8				ld de, .enddict 
25b8				ld a, display_row_3 
25b8				call str_at_display 
25b8				call update_display 
25b8				ld a, 100 
25b8				call aDelayInMS 
25b8				if DEBUG_FORTH_PARSE_EXEC_SLOW 
25b8				call delay1s 
25b8				call delay1s 
25b8				call delay1s 
25b8				endif 
25b8			.ispskip:  
25b8				 
25b8			endif	 
25b8			 
25b8			 
25b8			 
25b8				; if the word is not a keyword then must be a literal so push it to stack 
25b8			 
25b8			; push token to stack to end of word 
25b8			 
25b8				STACKFRAME ON $1efe $2f9f 
25b8				if DEBUG_STACK_IMB 
25b8					if ON 
25b8						exx 
25b8						ld de, $1efe 
25b8						ld a, d 
25b8						ld hl, curframe 
25b8						call hexout 
25b8						ld a, e 
25b8						ld hl, curframe+2 
25b8						call hexout 
25b8						ld hl, $1efe 
25b8						push hl 
25b8						ld hl, $2f9f 
25b8						push hl 
25b8						exx 
25b8					endif 
25b8				endif 
25b8			endm 
# End of macro STACKFRAME
25b8			 
25b8 2a fd f3		ld hl,(os_tok_ptr) 
25bb cd 6c 22		call forth_apush 
25be			 
25be				STACKFRAMECHK ON $1efe $2f9f 
25be				if DEBUG_STACK_IMB 
25be					if ON 
25be						exx 
25be						ld hl, $2f9f 
25be						pop de   ; $2f9f 
25be						call cmp16 
25be						jr nz, .spnosame 
25be						ld hl, $1efe 
25be						pop de   ; $1efe 
25be						call cmp16 
25be						jr z, .spfrsame 
25be						.spnosame: call showsperror 
25be						.spfrsame: nop 
25be						exx 
25be					endif 
25be				endif 
25be			endm 
# End of macro STACKFRAMECHK
25be			 
25be			execnext: 
25be			 
25be			if DEBUG_FORTH_PARSE_KEY 
25be						DMARK "KY>" 
25be			endif 
25be			; move past token to next word 
25be			 
25be 2a fd f3		ld hl, (os_tok_ptr) 
25c1 3e 00		ld a, 0 
25c3 01 ff 00		ld bc, 255     ; input buffer size 
25c6 ed b1		cpir 
25c8			 
25c8			if DEBUG_FORTH_PARSE_KEY 
25c8						DMARK "KY!" 
25c8				CALLMONITOR 
25c8			endif	 
25c8			; TODO this might place hl on the null, so will need to forward on??? 
25c8			;inc hl   ; see if this gets onto the next item 
25c8			 
25c8			 
25c8			; TODO pass a pointer to the buffer to push 
25c8			; TODO call function to push 
25c8			 
25c8			; look for end of input 
25c8			 
25c8			;inc hl 
25c8			;ld a,(hl) 
25c8			;cp FORTH_END_BUFFER 
25c8			;ret z 
25c8			 
25c8			 
25c8 c3 41 25		jp exec1 
25cb			 
25cb			 
25cb			 
25cb			 
25cb			 
25cb			 
25cb			 
25cb			 
25cb			 
25cb			findnexttok: 
25cb			 
25cb				; hl is pointer to move 
25cb				; de is the token to locate 
25cb			 
25cb					if DEBUG_FORTH 
25cb						DMARK "NTK" 
25cb						CALLMONITOR 
25cb					endif 
25cb d5				push de 
25cc			 
25cc			.fnt1:	 
25cc				; find first char of token to locate 
25cc			 
25cc 1a				ld a, (de) 
25cd 4f				ld c,a 
25ce 7e				ld a,(hl) 
25cf cd 24 14			call toUpper 
25d2					if DEBUG_FORTH 
25d2						DMARK "NT1" 
25d2						CALLMONITOR 
25d2					endif 
25d2 b9				cp c 
25d3			 
25d3 28 03			jr z, .fnt2cmpmorefirst	 
25d5			 
25d5				; first char not found move to next char 
25d5			 
25d5 23				inc hl 
25d6 18 f4			jr .fnt1 
25d8			 
25d8			.fnt2cmpmorefirst:	 
25d8				; first char of token found.  
25d8			 
25d8 e5				push hl     ; save start of token just in case it is the right one 
25d9 d9				exx 
25da e1				pop hl        ; save it to hl' 
25db d9				exx 
25dc			 
25dc			 
25dc			.fnt2cmpmore:	 
25dc				; compare the rest 
25dc				 
25dc 23				inc hl 
25dd 13				inc de 
25de				 
25de 1a				ld a, (de) 
25df 4f				ld c,a 
25e0 7e				ld a,(hl) 
25e1 cd 24 14			call toUpper 
25e4			 
25e4					if DEBUG_FORTH 
25e4						DMARK "NT2" 
25e4						CALLMONITOR 
25e4					endif 
25e4				; c has the token to find char 
25e4				; a has the mem to scan char 
25e4			 
25e4 b9				cp c 
25e5 28 04			jr z,.fntmatch1 
25e7			 
25e7				; they are not the same 
25e7			 
25e7					if DEBUG_FORTH 
25e7						DMARK "NT3" 
25e7						CALLMONITOR 
25e7					endif 
25e7 d1				pop de	; reset de token to look for 
25e8 d5				push de 
25e9 18 e1			jr .fnt1 
25eb				 
25eb			.fntmatch1: 
25eb			 
25eb				; is the same char a null which means we might have a full hit? 
25eb					if DEBUG_FORTH 
25eb						DMARK "NT4" 
25eb						CALLMONITOR 
25eb					endif 
25eb			 
25eb fe 00			cp 0 
25ed 28 0b			jr z, .fntmatchyes 
25ef			 
25ef				; are we at the end of the token to find? 
25ef			 
25ef					if DEBUG_FORTH 
25ef						DMARK "NT5" 
25ef						CALLMONITOR 
25ef					endif 
25ef 3e 00			ld a, 0 
25f1 b9				cp c 
25f2			 
25f2 c2 dc 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
25f5			 
25f5					if DEBUG_FORTH 
25f5						DMARK "NT6" 
25f5						CALLMONITOR 
25f5					endif 
25f5				; token to find is exhusted but no match to stream 
25f5			 
25f5				; restore tok pointer and continue on 
25f5 d1				pop de 
25f6 d5				push de 
25f7 c3 cc 25			jp .fnt1 
25fa			 
25fa			 
25fa			.fntmatchyes: 
25fa			 
25fa				; hl now contains the end of the found token 
25fa			 
25fa				; get rid of saved token pointer to find 
25fa			 
25fa d1				pop de 
25fb			 
25fb					if DEBUG_FORTH 
25fb						DMARK "NT9" 
25fb						CALLMONITOR 
25fb					endif 
25fb			 
25fb				; hl will be on the null term so forward on 
25fb			 
25fb				; get back the saved start of the token 
25fb			 
25fb d9				exx 
25fc e5				push hl     ; save start of token just in case it is the right one 
25fd d9				exx 
25fe e1				pop hl        ; save it to hl 
25ff			 
25ff c9				ret 
2600			 
2600			 
2600			; LIST needs to find a specific token   
2600			; FORGET needs to find a spefici token 
2600			 
2600			; SAVE needs to find all tokens by flag 
2600			; WORDS just needs to scan through all  by flag 
2600			; UWORDS needs to scan through all by flag 
2600			 
2600			 
2600			; given hl as pointer to start of dict look up string 
2600			; return hl as pointer to start of word block 
2600			; or 0 if not found 
2600			 
2600			forth_find_tok: 
2600 c9				ret 
2601			 
2601			; given hl as pointer to dict structure 
2601			; move to the next dict block structure 
2601			 
2601			forth_tok_next: 
2601				; hl now points to the address of the next word pointer  
2601				; TODO skip compiled symbol for now 
2601			;	push de 
2601 23				inc hl 
2602 5e				ld e, (hl) 
2603 23				inc hl 
2604 56				ld d, (hl) 
2605 23				inc hl 
2606			 
2606 eb				ex de,hl 
2607			if DEBUG_FORTH_PARSE_NEXTWORD 
2607				push bc 
2607				ld bc, (cli_nextword) 
2607						DMARK "NXW" 
2607				CALLMONITOR 
2607				pop bc 
2607			endif 
2607			;	pop de	 
2607 c9				ret 
2608			 
2608			 
2608			 
2608			; eof 
# End of file forth_parserv5.asm
2608				include "forth_wordsv4.asm" 
2608			 
2608			; the core word dictionary v4 
2608			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2608			 
2608			; this is a linked list for each of the system words used 
2608			; user defined words will follow the same format but will be in ram 
2608			 
2608			 
2608			; 
2608			; 
2608			; define linked list: 
2608			; 
2608			; 1. compiled byte op code 
2608			; 2. len of text word 
2608			; 3. text word 
2608			; 4. ptr to next dictionary word 
2608			; 5. asm, calls etc for the word 
2608			; 
2608			;  if 1 == 0 then last word in dict  
2608			;   
2608			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2608			;  
2608			;  
2608			; create basic standard set of words 
2608			; 
2608			;  
2608			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2608			; 2DUP 2DROP 2SWAP  
2608			; @ C@ - get byte  
2608			; ! C! - store byte 
2608			; 0< true if less than zero 
2608			; 0= true if zero 
2608			; < >  
2608			; = true if same 
2608			; variables 
2608			 
2608			 
2608			; Hardware specific words I may need 
2608			; 
2608			; IN OUT  
2608			; calls to key util functions 
2608			; calls to hardward abstraction stuff 
2608			; easy control of frame buffers and lcd i/o 
2608			; keyboard  
2608			 
2608			 
2608			;DICT: macro 
2608			; op_code, len, word, next 
2608			;    word: 
2608			;    db op_code 
2608			;    ds word zero term 
2608			;    dw next 
2608			;    endm 
2608			 
2608			 
2608			 
2608			 
2608			; op code 1 is a flag for user define words which are to be handled differently 
2608			 
2608			 
2608			; 
2608			; 
2608			;    TODO on entry to a word this should be the expected environment 
2608			;    hl - tos value if number then held, if string this is the ptr 
2608			;    de -  
2608			 
2608			 
2608			; opcode ranges 
2608			; 0 - end of word dict 
2608			; 255 - user define words 
2608			 
2608			sysdict: 
2608			include "forth_opcodes.asm" 
2608			; op codes for forth keywords 
2608			; free to use code 0  
2608				OPCODE_HEAP: equ  1 
2608				OPCODE_EXEC: equ 2 
2608				OPCODE_DUP: equ 3 
2608				OPCODE_SWAP: equ 4 
2608				OPCODE_COLN: equ 5 
2608				OPCODE_SCOLN: equ 6 
2608				OPCODE_DROP: equ 7 
2608				OPCODE_DUP2: equ 8 
2608				OPCODE_DROP2: equ 9 
2608				OPCODE_SWAP2: equ 10 
2608				OPCODE_AT: equ 11 
2608				OPCODE_CAT: equ 12 
2608				OPCODE_BANG: equ 13 
2608				OPCODE_CBANG: equ 14 
2608				OPCODE_SCALL: equ 15 
2608				OPCODE_DEPTH: equ 16 
2608				OPCODE_OVER: equ 17 
2608				OPCODE_PAUSE: equ 18 
2608				OPCODE_PAUSES: equ 19 
2608				OPCODE_ROT: equ 20 
2608			;free to reuse	OPCODE_WORDS: equ 21 
2608			        OPCODE_NOT: equ 21 
2608				OPCODE_UWORDS: equ 22 
2608				OPCODE_BP: equ 23 
2608				OPCODE_MONITOR: equ 24  
2608				OPCODE_MALLOC: equ 25 
2608				OPCODE_FREE: equ 26 
2608				OPCODE_LIST: equ 27 
2608				OPCODE_FORGET: equ 28 
2608				OPCODE_NOP: equ 29 
2608				OPCODE_COMO: equ 30 
2608				OPCODE_COMC: equ 31 
2608			;free to reuse	OPCODE_ENDCORE: equ 32 
2608				OPCODE_AFTERSOUND: equ 33 
2608				OPCODE_GP2: equ 34 
2608				OPCODE_GP3: equ 35 
2608				OPCODE_GP4: equ 36 
2608				OPCODE_SIN: equ 37 
2608				OPCODE_SOUT: equ 38 
2608				OPCODE_SPIO: equ 39 
2608				OPCODE_SPICEH: equ 40 
2608				OPCODE_SPIOb: equ 41 
2608				OPCODE_SPII: equ 42 
2608				OPCODE_SESEL: equ 43 
2608				OPCODE_CARTDEV: equ 44 
2608			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2608				OPCODE_FB: equ 46 
2608				OPCODE_EMIT: equ 47 
2608				OPCODE_DOTH: equ 48 
2608				OPCODE_DOTF: equ 49 
2608				OPCODE_DOT: equ 50 
2608				OPCODE_CLS: equ 51 
2608				OPCODE_DRAW: equ 52 
2608				OPCODE_DUMP: equ 53 
2608				OPCODE_CDUMP: equ 54 
2608				OPCODE_DAT: equ 55 
2608				OPCODE_HOME: equ 56 
2608				OPCODE_SPACE: equ 57 
2608				OPCODE_SPACES: equ 58 
2608				OPCODE_SCROLL: equ 59 
2608				OPCODE_ATQ: equ 60 
2608				OPCODE_AUTODSP: equ 61 
2608				OPCODE_MENU: equ 62 
2608			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2608				OPCODE_THEN: equ 64 
2608				OPCODE_ELSE: equ 65 
2608				OPCODE_DO: equ 66 
2608				OPCODE_LOOP: equ 67 
2608				OPCODE_I: equ 68 
2608				OPCODE_DLOOP: equ 69  
2608				OPCODE_REPEAT: equ 70  
2608				OPCODE_UNTIL: equ 71 
2608				OPCODE_ENDFLOW: equ 72 
2608				OPCODE_WAITK: equ 73 
2608				OPCODE_ACCEPT: equ 74 
2608				OPCODE_EDIT: equ 75 
2608			;free to reuse	OPCODE_ENDKEY: equ 76 
2608				OPCODE_LZERO: equ 77 
2608				OPCODE_TZERO: equ 78 
2608				OPCODE_LESS: equ 79 
2608				OPCODE_GT: equ 80 
2608				OPCODE_EQUAL: equ 81  
2608			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2608				OPCODE_NEG: equ 83 
2608				OPCODE_DIV: equ 84 
2608				OPCODE_MUL: equ 85 
2608				OPCODE_MIN: equ 86 
2608				OPCODE_MAX: equ 87 
2608				OPCODE_RND16: equ 88 
2608				OPCODE_RND8: equ 89 
2608				OPCODE_RND: equ 90 
2608			;free to reuse	OPCODE_ENDMATHS: equ 91  
2608				OPCODE_BYNAME: equ 92 
2608				OPCODE_DIR: equ 93 
2608				OPCODE_SAVE: equ 94 
2608				OPCODE_LOAD: equ 95 
2608				OPCODE_BSAVE: equ 96 
2608				OPCODE_BLOAD: equ 97 
2608				OPCODE_SEO: equ 98  
2608				OPCODE_SEI: equ 99 
2608				OPCODE_SFREE: equ 100 
2608				OPCODE_SIZE: equ 101 
2608				OPCODE_CREATE: equ 102 
2608				OPCODE_APPEND: equ 103 
2608				OPCODE_SDEL: equ 104 
2608				OPCODE_OPEN: equ 105 
2608				OPCODE_READ: equ 106 
2608				OPCODE_EOF: equ 106 
2608				OPCODE_FORMAT: equ 107 
2608				OPCODE_LABEL: equ 108 
2608				OPCODE_LABELS: equ 109 
2608			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2608				OPCODE_UPPER: equ 111 
2608				OPCODE_LOWER: equ 112 
2608				OPCODE_SUBSTR: equ 113 
2608				OPCODE_LEFT: equ 114 
2608				OPCODE_RIGHT: equ 115 
2608				OPCODE_STR2NUM: equ 116 
2608				OPCODE_NUM2STR: equ 117 
2608				OPCODE_CONCAT: equ 118 
2608				OPCODE_FIND: equ 119 
2608				OPCODE_LEN: equ 120 
2608				OPCODE_CHAR: equ 121 
2608			; free to reuse	OPCODE_STRLEN: equ 122 
2608			; free to reuse	OPCODE_ENDSTR: equ 123 
2608				OPCODE_V0S: equ 124 
2608				OPCODE_V0Q: equ 125 
2608				OPCODE_V1S: equ 126 
2608				OPCODE_V1Q: equ 127 
2608				OPCODE_V2S: equ 128 
2608				OPCODE_V2Q: equ 129 
2608				OPCODE_V3S: equ 130 
2608				OPCODE_V3Q: equ 131 
2608			;free to reuse	OPCODE_END: equ 132 
2608				OPCODE_ZDUP: equ 133 
2608			 
2608			; eof 
# End of file forth_opcodes.asm
2608			 
2608			include "forth_words_core.asm" 
2608			 
2608			; | ## Core Words 
2608			 
2608			;if MALLOC_4 
2608			 
2608			.HEAP: 
2608			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2608 15				db WORD_SYS_CORE+OPCODE_HEAP             
2609 47 26			dw .EXEC            
260b 05				db 4 + 1 
260c .. 00			db "HEAP",0              
2611				endm 
# End of macro CWHEAD
2611			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2611			; | | u1 - Current number of bytes in the heap 
2611			; | | u2 - Remaining bytes left on the heap 
2611			; | |  
2611			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2611			 
2611			 
2611				if DEBUG_FORTH_WORDS_KEY 
2611					DMARK "HEP" 
2611 f5				push af  
2612 3a 26 26			ld a, (.dmark)  
2615 32 a6 fd			ld (debug_mark),a  
2618 3a 27 26			ld a, (.dmark+1)  
261b 32 a7 fd			ld (debug_mark+1),a  
261e 3a 28 26			ld a, (.dmark+2)  
2621 32 a8 fd			ld (debug_mark+2),a  
2624 18 03			jr .pastdmark  
2626 ..			.dmark: db "HEP"  
2629 f1			.pastdmark: pop af  
262a			endm  
# End of macro DMARK
262a					CALLMONITOR 
262a cd aa fd			call debug_vector  
262d				endm  
# End of macro CALLMONITOR
262d				endif 
262d 2a 0a 80			ld hl, (free_list )      
2630 11 0e 80			ld de, heap_start 
2633			 
2633 ed 52			sbc hl, de  
2635			 
2635 cd 03 21			call forth_push_numhl 
2638			 
2638			 
2638 ed 5b 0a 80		ld de, (free_list )      
263c 21 d7 f0			ld hl, heap_end 
263f			 
263f ed 52			sbc hl, de 
2641			 
2641 cd 03 21			call forth_push_numhl 
2644				 
2644			 
2644				 
2644			 
2644			 
2644			 
2644				NEXTW 
2644 c3 b0 24			jp macro_next 
2647				endm 
# End of macro NEXTW
2647			;endif 
2647			 
2647			.EXEC: 
2647			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2647			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2647			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2647			;; > > 
2647			;; > >   
2647			;	STACKFRAME OFF $5efe $5f9f 
2647			; 
2647			;		if DEBUG_FORTH_WORDS_KEY 
2647			;			DMARK "EXE" 
2647			;			CALLMONITOR 
2647			;		endif 
2647			; 
2647			;	FORTH_DSP_VALUEHL 
2647			; 
2647			;	FORTH_DSP_POP 
2647			; 
2647			;		if DEBUG_FORTH_WORDS 
2647			;			DMARK "EX1" 
2647			;			CALLMONITOR 
2647			;		endif 
2647			;;	ld e,(hl) 
2647			;;	inc hl 
2647			;;	ld d,(hl) 
2647			;;	ex de,hl 
2647			; 
2647			;;		if DEBUG_FORTH_WORDS 
2647			;;			DMARK "EX2" 
2647			;;			CALLMONITOR 
2647			;;		endif 
2647			;	push hl 
2647			; 
2647			;	;ld a, 0 
2647			;	;ld a, FORTH_END_BUFFER 
2647			;	call strlenz 
2647			;	inc hl   ; include zero term to copy 
2647			;	inc hl   ; include term 
2647			;	inc hl   ; include term 
2647			;	ld b,0 
2647			;	ld c,l 
2647			;	pop hl 
2647			;	ld de, execscratch 
2647			;		if DEBUG_FORTH_WORDS 
2647			;			DMARK "EX3" 
2647			;			CALLMONITOR 
2647			;		endif 
2647			;	ldir 
2647			; 
2647			; 
2647			;	ld hl, execscratch 
2647			; 
2647			;		if DEBUG_FORTH_WORDS 
2647			;			DMARK "EXe" 
2647			;			CALLMONITOR 
2647			;		endif 
2647			; 
2647			;	call forthparse 
2647			;	call forthexec 
2647			;;	call forthexec_cleanup 
2647			;;	call forthparse 
2647			;;	call forthexec 
2647			; 
2647			;	STACKFRAMECHK OFF $5efe $5f9f 
2647			; 
2647			;	; an immediate word so no need to process any more words 
2647			;	ret 
2647			;	NEXTW 
2647			 
2647			; dead code - old version  
2647			;	FORTH_RSP_NEXT 
2647			 
2647			;  
2647			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2647			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2647			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2647			;	push hl 
2647			;	push de 
2647			;	push bc 
2647			; 
2647			; 
2647			;		if DEBUG_FORTH_WORDS_KEY 
2647			;			DMARK "EXR" 
2647			;			CALLMONITOR 
2647			;		endif 
2647			; 
2647			; 
2647			; 
2647			;	;v5 FORTH_DSP_VALUE 
2647			;	FORTH_DSP_VALUEHL 
2647			; 
2647			;	; TODO do string type checks 
2647			; 
2647			;;v5	inc hl   ; skip type 
2647			; 
2647			;	push hl  ; source code  
2647			;		if DEBUG_FORTH_WORDS 
2647			;			DMARK "EX1" 
2647			;			CALLMONITOR 
2647			;		endif 
2647			;	ld a, 0 
2647			;	call strlent 
2647			; 
2647			;	inc hl 
2647			;	inc hl 
2647			;	inc hl 
2647			;	inc hl 
2647			; 
2647			;	push hl    ; size 
2647			; 
2647			;		if DEBUG_FORTH_WORDS 
2647			;			DMARK "EX2" 
2647			;			CALLMONITOR 
2647			;		endif 
2647			;	call malloc 
2647			; 
2647			;	ex de, hl    ; de now contains malloc area 
2647			;	pop bc   	; get byte count 
2647			;	pop hl      ; get string to copy 
2647			; 
2647			;	push de     ; save malloc for free later 
2647			; 
2647			;		if DEBUG_FORTH_WORDS 
2647			;			DMARK "EX3" 
2647			;			CALLMONITOR 
2647			;		endif 
2647			;	ldir       ; duplicate string 
2647			; 
2647			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2647			;	 
2647			;	; TODO fix the parse would be better than this...  
2647			;	ex de, hl 
2647			;	dec hl 
2647			;	ld a, 0 
2647			;	ld (hl), a 
2647			;	dec hl 
2647			;	ld a, ' ' 
2647			;	ld (hl), a 
2647			;	dec hl 
2647			;	ld (hl), a 
2647			; 
2647			;	dec hl 
2647			;	ld (hl), a 
2647			; 
2647			; 
2647			;	FORTH_DSP_POP  
2647			; 
2647			;	pop hl     
2647			;	push hl    ; save malloc area 
2647			; 
2647			;		if DEBUG_FORTH_WORDS 
2647			;			DMARK "EX4" 
2647			;			CALLMONITOR 
2647			;		endif 
2647			; 
2647			;	call forthparse 
2647			;	call forthexec 
2647			;	 
2647			;	pop hl 
2647			;	if DEBUG_FORTH_WORDS 
2647			;		DMARK "EX5" 
2647			;		CALLMONITOR 
2647			;	endif 
2647			; 
2647			;	if FORTH_ENABLE_FREE 
2647			;	call free 
2647			;	endif 
2647			; 
2647			;	if DEBUG_FORTH_WORDS 
2647			;		DMARK "EX6" 
2647			;		CALLMONITOR 
2647			;	endif 
2647			; 
2647			;	pop bc 
2647			;	pop de 
2647			;	pop hl 
2647			;;	FORTH_RSP_POP	  
2647			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2647			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2647			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2647			; 
2647			;	if DEBUG_FORTH_WORDS 
2647			;		DMARK "EX7" 
2647			;		CALLMONITOR 
2647			;	endif 
2647			;	NEXTW 
2647			 
2647			;.STKEXEC: 
2647			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2647			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2647			; 
2647			; 
2647			;		if DEBUG_FORTH_WORDS_KEY 
2647			;			DMARK "STX" 
2647			;			CALLMONITOR 
2647			;		endif 
2647			; 
2647			;	FORTH_DSP_VALUEHL 
2647			; 
2647			;	ld (store_tmp1), hl    ; count 
2647			; 
2647			;	FORTH_DSP_POP 
2647			;.stkexec1: 
2647			;	ld hl, (store_tmp1)   ; count 
2647			;	ld a, 0 
2647			;	cp l 
2647			;	ret z 
2647			; 
2647			;	dec hl 
2647			;	ld (store_tmp1), hl    ; count 
2647			;	 
2647			;	FORTH_DSP_VALUEHL 
2647			;	push hl 
2647			;	 
2647			;		if DEBUG_FORTH_WORDS 
2647			;			DMARK "EXp" 
2647			;			CALLMONITOR 
2647			;		endif 
2647			;	FORTH_DSP_POP 
2647			; 
2647			;	call strlenz 
2647			;	inc hl   ; include zero term to copy 
2647			;	inc hl   ; include zero term to copy 
2647			;	inc hl   ; include zero term to copy 
2647			;	ld b,0 
2647			;	ld c,l 
2647			;	pop hl 
2647			;	ld de, execscratch 
2647			;		if DEBUG_FORTH_WORDS 
2647			;			DMARK "EX3" 
2647			;			CALLMONITOR 
2647			;		endif 
2647			;	ldir 
2647			; 
2647			; 
2647			;	ld hl, execscratch 
2647			; 
2647			;		if DEBUG_FORTH_WORDS 
2647			;			DMARK "EXP" 
2647			;			CALLMONITOR 
2647			;		endif 
2647			; 
2647			;	call forthparse 
2647			;	ld hl, execscratch 
2647			;		if DEBUG_FORTH_WORDS 
2647			;			DMARK "EXx" 
2647			;			CALLMONITOR 
2647			;		endif 
2647			;	call forthexec 
2647			; 
2647			;	jp .stkexec1 
2647			; 
2647			;	ret 
2647			 
2647			 
2647			.DUP: 
2647			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2647 17				db WORD_SYS_CORE+OPCODE_DUP             
2648 bd 26			dw .ZDUP            
264a 04				db 3 + 1 
264b .. 00			db "DUP",0              
264f				endm 
# End of macro CWHEAD
264f			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
264f			 
264f				if DEBUG_FORTH_WORDS_KEY 
264f					DMARK "DUP" 
264f f5				push af  
2650 3a 64 26			ld a, (.dmark)  
2653 32 a6 fd			ld (debug_mark),a  
2656 3a 65 26			ld a, (.dmark+1)  
2659 32 a7 fd			ld (debug_mark+1),a  
265c 3a 66 26			ld a, (.dmark+2)  
265f 32 a8 fd			ld (debug_mark+2),a  
2662 18 03			jr .pastdmark  
2664 ..			.dmark: db "DUP"  
2667 f1			.pastdmark: pop af  
2668			endm  
# End of macro DMARK
2668					CALLMONITOR 
2668 cd aa fd			call debug_vector  
266b				endm  
# End of macro CALLMONITOR
266b				endif 
266b			 
266b				FORTH_DSP 
266b cd c0 22			call macro_forth_dsp 
266e				endm 
# End of macro FORTH_DSP
266e			 
266e 7e				ld a, (HL) 
266f fe 01			cp DS_TYPE_STR 
2671 20 25			jr nz, .dupinum 
2673			 
2673				; push another string 
2673			 
2673				FORTH_DSP_VALUEHL     		 
2673 cd fa 22			call macro_dsp_valuehl 
2676				endm 
# End of macro FORTH_DSP_VALUEHL
2676			 
2676			if DEBUG_FORTH_WORDS 
2676				DMARK "DUs" 
2676 f5				push af  
2677 3a 8b 26			ld a, (.dmark)  
267a 32 a6 fd			ld (debug_mark),a  
267d 3a 8c 26			ld a, (.dmark+1)  
2680 32 a7 fd			ld (debug_mark+1),a  
2683 3a 8d 26			ld a, (.dmark+2)  
2686 32 a8 fd			ld (debug_mark+2),a  
2689 18 03			jr .pastdmark  
268b ..			.dmark: db "DUs"  
268e f1			.pastdmark: pop af  
268f			endm  
# End of macro DMARK
268f				CALLMONITOR 
268f cd aa fd			call debug_vector  
2692				endm  
# End of macro CALLMONITOR
2692			endif 
2692 cd 71 21			call forth_push_str 
2695			 
2695				NEXTW 
2695 c3 b0 24			jp macro_next 
2698				endm 
# End of macro NEXTW
2698			 
2698			 
2698			.dupinum: 
2698				 
2698			 
2698			 
2698				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2698 cd fa 22			call macro_dsp_valuehl 
269b				endm 
# End of macro FORTH_DSP_VALUEHL
269b			 
269b			; TODO add floating point number detection 
269b			 
269b			if DEBUG_FORTH_WORDS 
269b				DMARK "DUi" 
269b f5				push af  
269c 3a b0 26			ld a, (.dmark)  
269f 32 a6 fd			ld (debug_mark),a  
26a2 3a b1 26			ld a, (.dmark+1)  
26a5 32 a7 fd			ld (debug_mark+1),a  
26a8 3a b2 26			ld a, (.dmark+2)  
26ab 32 a8 fd			ld (debug_mark+2),a  
26ae 18 03			jr .pastdmark  
26b0 ..			.dmark: db "DUi"  
26b3 f1			.pastdmark: pop af  
26b4			endm  
# End of macro DMARK
26b4				CALLMONITOR 
26b4 cd aa fd			call debug_vector  
26b7				endm  
# End of macro CALLMONITOR
26b7			endif 
26b7			 
26b7 cd 03 21			call forth_push_numhl 
26ba				NEXTW 
26ba c3 b0 24			jp macro_next 
26bd				endm 
# End of macro NEXTW
26bd			.ZDUP: 
26bd			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
26bd 99				db WORD_SYS_CORE+OPCODE_ZDUP             
26be f5 26			dw .SWAP            
26c0 05				db 4 + 1 
26c1 .. 00			db "?DUP",0              
26c6				endm 
# End of macro CWHEAD
26c6			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
26c6			 
26c6				if DEBUG_FORTH_WORDS_KEY 
26c6					DMARK "qDU" 
26c6 f5				push af  
26c7 3a db 26			ld a, (.dmark)  
26ca 32 a6 fd			ld (debug_mark),a  
26cd 3a dc 26			ld a, (.dmark+1)  
26d0 32 a7 fd			ld (debug_mark+1),a  
26d3 3a dd 26			ld a, (.dmark+2)  
26d6 32 a8 fd			ld (debug_mark+2),a  
26d9 18 03			jr .pastdmark  
26db ..			.dmark: db "qDU"  
26de f1			.pastdmark: pop af  
26df			endm  
# End of macro DMARK
26df					CALLMONITOR 
26df cd aa fd			call debug_vector  
26e2				endm  
# End of macro CALLMONITOR
26e2				endif 
26e2				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26e2 cd fa 22			call macro_dsp_valuehl 
26e5				endm 
# End of macro FORTH_DSP_VALUEHL
26e5			 
26e5 e5				push hl 
26e6			 
26e6				; is it a zero? 
26e6			 
26e6 3e 00			ld a, 0 
26e8 84				add h 
26e9 85				add l 
26ea			 
26ea e1				pop hl 
26eb			 
26eb fe 00			cp 0 
26ed 28 03			jr z, .dup2orig 
26ef			 
26ef			 
26ef cd 03 21			call forth_push_numhl 
26f2			 
26f2			 
26f2			; TODO add floating point number detection 
26f2			 
26f2			.dup2orig: 
26f2			 
26f2				NEXTW 
26f2 c3 b0 24			jp macro_next 
26f5				endm 
# End of macro NEXTW
26f5			.SWAP: 
26f5			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
26f5 18				db WORD_SYS_CORE+OPCODE_SWAP             
26f6 34 27			dw .COLN            
26f8 05				db 4 + 1 
26f9 .. 00			db "SWAP",0              
26fe				endm 
# End of macro CWHEAD
26fe			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
26fe				if DEBUG_FORTH_WORDS_KEY 
26fe					DMARK "SWP" 
26fe f5				push af  
26ff 3a 13 27			ld a, (.dmark)  
2702 32 a6 fd			ld (debug_mark),a  
2705 3a 14 27			ld a, (.dmark+1)  
2708 32 a7 fd			ld (debug_mark+1),a  
270b 3a 15 27			ld a, (.dmark+2)  
270e 32 a8 fd			ld (debug_mark+2),a  
2711 18 03			jr .pastdmark  
2713 ..			.dmark: db "SWP"  
2716 f1			.pastdmark: pop af  
2717			endm  
# End of macro DMARK
2717					CALLMONITOR 
2717 cd aa fd			call debug_vector  
271a				endm  
# End of macro CALLMONITOR
271a				endif 
271a			 
271a			; TODO Use os stack swap memory 
271a				FORTH_DSP_VALUEHL 
271a cd fa 22			call macro_dsp_valuehl 
271d				endm 
# End of macro FORTH_DSP_VALUEHL
271d e5				push hl     ; w2 
271e			 
271e				FORTH_DSP_POP 
271e cd b2 23			call macro_forth_dsp_pop 
2721				endm 
# End of macro FORTH_DSP_POP
2721			 
2721				FORTH_DSP_VALUEHL 
2721 cd fa 22			call macro_dsp_valuehl 
2724				endm 
# End of macro FORTH_DSP_VALUEHL
2724			 
2724				FORTH_DSP_POP 
2724 cd b2 23			call macro_forth_dsp_pop 
2727				endm 
# End of macro FORTH_DSP_POP
2727			 
2727 d1				pop de     ; w2	, hl = w1 
2728			 
2728 eb				ex de, hl 
2729 d5				push de 
272a			 
272a cd 03 21			call forth_push_numhl 
272d			 
272d e1				pop hl 
272e			 
272e cd 03 21			call forth_push_numhl 
2731				 
2731			 
2731				NEXTW 
2731 c3 b0 24			jp macro_next 
2734				endm 
# End of macro NEXTW
2734			.COLN: 
2734			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2734 19				db WORD_SYS_CORE+OPCODE_COLN             
2735 c0 28			dw .SCOLN            
2737 02				db 1 + 1 
2738 .. 00			db ":",0              
273a				endm 
# End of macro CWHEAD
273a			; | : ( -- )         Create new word | DONE 
273a			 
273a				if DEBUG_FORTH_WORDS_KEY 
273a					DMARK "CLN" 
273a f5				push af  
273b 3a 4f 27			ld a, (.dmark)  
273e 32 a6 fd			ld (debug_mark),a  
2741 3a 50 27			ld a, (.dmark+1)  
2744 32 a7 fd			ld (debug_mark+1),a  
2747 3a 51 27			ld a, (.dmark+2)  
274a 32 a8 fd			ld (debug_mark+2),a  
274d 18 03			jr .pastdmark  
274f ..			.dmark: db "CLN"  
2752 f1			.pastdmark: pop af  
2753			endm  
# End of macro DMARK
2753					CALLMONITOR 
2753 cd aa fd			call debug_vector  
2756				endm  
# End of macro CALLMONITOR
2756				endif 
2756			STACKFRAME OFF $8efe $989f 
2756				if DEBUG_STACK_IMB 
2756					if OFF 
2756						exx 
2756						ld de, $8efe 
2756						ld a, d 
2756						ld hl, curframe 
2756						call hexout 
2756						ld a, e 
2756						ld hl, curframe+2 
2756						call hexout 
2756						ld hl, $8efe 
2756						push hl 
2756						ld hl, $989f 
2756						push hl 
2756						exx 
2756					endif 
2756				endif 
2756			endm 
# End of macro STACKFRAME
2756			; get parser buffer length  of new word 
2756			 
2756			 
2756			 
2756				; move tok past this to start of name defintition 
2756				; TODO get word to define 
2756				; TODO Move past word token 
2756				; TODO get length of string up to the ';' 
2756			 
2756 2a fd f3		ld hl, (os_tok_ptr) 
2759 23			inc hl 
275a 23			inc hl 
275b			 
275b 3e 3b		ld a, ';' 
275d cd 38 14		call strlent 
2760			 
2760 7d			ld a,l 
2761 32 ec f0		ld (os_new_parse_len), a 
2764			 
2764			 
2764			if DEBUG_FORTH_UWORD 
2764 ed 5b fd f3	ld de, (os_tok_ptr) 
2768					DMARK ":01" 
2768 f5				push af  
2769 3a 7d 27			ld a, (.dmark)  
276c 32 a6 fd			ld (debug_mark),a  
276f 3a 7e 27			ld a, (.dmark+1)  
2772 32 a7 fd			ld (debug_mark+1),a  
2775 3a 7f 27			ld a, (.dmark+2)  
2778 32 a8 fd			ld (debug_mark+2),a  
277b 18 03			jr .pastdmark  
277d ..			.dmark: db ":01"  
2780 f1			.pastdmark: pop af  
2781			endm  
# End of macro DMARK
2781			CALLMONITOR 
2781 cd aa fd			call debug_vector  
2784				endm  
# End of macro CALLMONITOR
2784			endif 
2784			 
2784			; 
2784			;  new word memory layout: 
2784			;  
2784			;    : adg 6666 ;  
2784			; 
2784			;    db   1     ; user defined word  
2784 23			inc hl    
2785			;    dw   sysdict 
2785 23			inc hl 
2786 23			inc hl 
2787			;    db <word len>+1 (for null) 
2787 23			inc hl 
2788			;    db .... <word> 
2788			; 
2788			 
2788 23			inc hl    ; some extras for the word preamble before the above 
2789 23			inc hl 
278a 23			inc hl 
278b 23			inc hl 
278c 23			inc hl 
278d 23			inc hl 
278e 23			inc hl  
278f 23			inc hl 
2790 23			inc hl 
2791 23			inc hl 
2792 23			inc hl 
2793 23			inc hl 
2794 23			inc hl 
2795 23			inc hl     ; TODO how many do we really need?     maybe only 6 
2796			;       exec word buffer 
2796			;	<ptr word>   
2796 23			inc hl 
2797 23			inc hl 
2798			;       <word list><null term> 7F final term 
2798			 
2798			 
2798			if DEBUG_FORTH_UWORD 
2798					DMARK ":02" 
2798 f5				push af  
2799 3a ad 27			ld a, (.dmark)  
279c 32 a6 fd			ld (debug_mark),a  
279f 3a ae 27			ld a, (.dmark+1)  
27a2 32 a7 fd			ld (debug_mark+1),a  
27a5 3a af 27			ld a, (.dmark+2)  
27a8 32 a8 fd			ld (debug_mark+2),a  
27ab 18 03			jr .pastdmark  
27ad ..			.dmark: db ":02"  
27b0 f1			.pastdmark: pop af  
27b1			endm  
# End of macro DMARK
27b1			CALLMONITOR 
27b1 cd aa fd			call debug_vector  
27b4				endm  
# End of macro CALLMONITOR
27b4			endif 
27b4			 
27b4			 
27b4				; malloc the size 
27b4			 
27b4 cd a2 14			call malloc 
27b7 22 ee f0			ld (os_new_malloc), hl     ; save malloc start 
27ba			 
27ba			;    db   1     ; user defined word  
27ba 3e 01			ld a, WORD_SYS_UWORD  
27bc 77				ld (hl), a 
27bd			 
27bd 23			inc hl    
27be			;    dw   sysdict 
27be 11 08 26		ld de, sysdict       ; continue on with the scan to the system dict 
27c1 73			ld (hl), e 
27c2 23			inc hl 
27c3 72			ld (hl), d 
27c4 23			inc hl 
27c5			 
27c5			 
27c5			;    Setup dict word 
27c5			 
27c5 23			inc hl 
27c6 22 e8 f0		ld (os_new_work_ptr), hl     ; save start of dict word  
27c9			 
27c9			; 1. get length of dict word 
27c9			 
27c9			 
27c9 2a fd f3		ld hl, (os_tok_ptr) 
27cc 23			inc hl 
27cd 23			inc hl    ; position to start of dict word 
27ce 3e 00		ld a, 0 
27d0 cd 38 14		call strlent 
27d3			 
27d3			 
27d3 23			inc hl    ; to include null??? 
27d4			 
27d4			; write length of dict word 
27d4			 
27d4 ed 5b e8 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
27d8 1b			dec de 
27d9 eb			ex de, hl 
27da 73			ld (hl), e 
27db eb			ex de, hl 
27dc			 
27dc			 
27dc			 
27dc			; copy  
27dc 4d			ld c, l 
27dd 06 00		ld b, 0 
27df ed 5b e8 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
27e3 2a fd f3		ld hl, (os_tok_ptr) 
27e6 23			inc hl 
27e7 23			inc hl    ; position to start of dict word 
27e8			 
27e8			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
27e8			 
27e8			; TODO need to convert word to upper case 
27e8			 
27e8			ucasetok:	 
27e8 7e			ld a,(hl) 
27e9 cd 24 14		call toUpper 
27ec 77			ld (hl),a 
27ed ed a0		ldi 
27ef f2 e8 27		jp p, ucasetok 
27f2			 
27f2			 
27f2			 
27f2			; de now points to start of where the word body code should be placed 
27f2 ed 53 e8 f0	ld (os_new_work_ptr), de 
27f6			; hl now points to the words to throw at forthexec which needs to be copied 
27f6 22 e6 f0		ld (os_new_src_ptr), hl 
27f9			 
27f9			; TODO add 'call to forthexec' 
27f9			 
27f9			if DEBUG_FORTH_UWORD 
27f9 c5			push bc 
27fa ed 4b ee f0	ld bc, (os_new_malloc) 
27fe					DMARK ":0x" 
27fe f5				push af  
27ff 3a 13 28			ld a, (.dmark)  
2802 32 a6 fd			ld (debug_mark),a  
2805 3a 14 28			ld a, (.dmark+1)  
2808 32 a7 fd			ld (debug_mark+1),a  
280b 3a 15 28			ld a, (.dmark+2)  
280e 32 a8 fd			ld (debug_mark+2),a  
2811 18 03			jr .pastdmark  
2813 ..			.dmark: db ":0x"  
2816 f1			.pastdmark: pop af  
2817			endm  
# End of macro DMARK
2817			CALLMONITOR 
2817 cd aa fd			call debug_vector  
281a				endm  
# End of macro CALLMONITOR
281a c1			pop bc 
281b			endif 
281b			 
281b			 
281b			; create word preamble which should be: 
281b			 
281b			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
281b			 
281b			;    ld hl, <word code> 
281b			;    jp user_exec 
281b			;    <word code bytes> 
281b			 
281b			 
281b			;	inc de     ; TODO ??? or are we already past the word's null 
281b eb			ex de, hl 
281c			 
281c 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
281e			 
281e 23			inc hl 
281f 22 e2 f0		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2822 23			inc hl 
2823			 
2823 23			inc hl 
2824 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2826			 
2826 01 b1 5d		ld bc, user_exec 
2829 23			inc hl 
282a 71			ld (hl), c     ; poke address of user_exec 
282b 23			inc hl 
282c 70			ld (hl), b     
282d			; 
282d			;	inc hl 
282d			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
282d			; 
282d			; 
282d			;	ld bc, macro_forth_rsp_next 
282d			;	inc hl 
282d			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
282d			;	inc hl 
282d			;	ld (hl), b     
282d			; 
282d			;	inc hl 
282d			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
282d			; 
282d			; 
282d			;	inc hl 
282d			;	ld bc, forthexec 
282d			;	ld (hl), c     ; poke address of forthexec 
282d			;	inc hl 
282d			;	ld (hl), b      
282d			; 
282d			;	inc hl 
282d			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
282d			; 
282d			;	ld bc, user_dict_next 
282d			;	inc hl 
282d			;	ld (hl), c     ; poke address of forthexec 
282d			;	inc hl 
282d			;	ld (hl), b      
282d			 
282d			; hl is now where we need to copy the word byte data to save this 
282d			 
282d 23			inc hl 
282e 22 e4 f0		ld (os_new_exec), hl 
2831			 
2831			; copy definition 
2831			 
2831 eb			ex de, hl 
2832			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2832			;	inc de    ; skip the PC for this parse 
2832 3a ec f0		ld a, (os_new_parse_len) 
2835 4f			ld c, a 
2836 06 00		ld b, 0 
2838 ed b0		ldir		 ; copy defintion 
283a			 
283a			 
283a			; poke the address of where the new word bytes live for forthexec 
283a			 
283a 2a e2 f0		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
283d			 
283d ed 5b e4 f0	ld de, (os_new_exec)      
2841			 
2841 73			ld (hl), e 
2842 23			inc hl 
2843 72			ld (hl), d 
2844			 
2844				; TODO copy last user dict word next link to this word 
2844				; TODO update last user dict word to point to this word 
2844			; 
2844			; hl f923 de 812a ; bc 811a 
2844			 
2844			if DEBUG_FORTH_UWORD 
2844 c5			push bc 
2845 ed 4b ee f0	ld bc, (os_new_malloc) 
2849					DMARK ":0A" 
2849 f5				push af  
284a 3a 5e 28			ld a, (.dmark)  
284d 32 a6 fd			ld (debug_mark),a  
2850 3a 5f 28			ld a, (.dmark+1)  
2853 32 a7 fd			ld (debug_mark+1),a  
2856 3a 60 28			ld a, (.dmark+2)  
2859 32 a8 fd			ld (debug_mark+2),a  
285c 18 03			jr .pastdmark  
285e ..			.dmark: db ":0A"  
2861 f1			.pastdmark: pop af  
2862			endm  
# End of macro DMARK
2862			CALLMONITOR 
2862 cd aa fd			call debug_vector  
2865				endm  
# End of macro CALLMONITOR
2865 c1			pop bc 
2866			endif 
2866			if DEBUG_FORTH_UWORD 
2866 c5			push bc 
2867 ed 4b ee f0	ld bc, (os_new_malloc) 
286b 03			inc bc 
286c 03			inc bc 
286d 03			inc bc 
286e 03			inc bc 
286f 03			inc bc 
2870 03			inc bc 
2871 03			inc bc 
2872 03			inc bc 
2873			 
2873					DMARK ":0B" 
2873 f5				push af  
2874 3a 88 28			ld a, (.dmark)  
2877 32 a6 fd			ld (debug_mark),a  
287a 3a 89 28			ld a, (.dmark+1)  
287d 32 a7 fd			ld (debug_mark+1),a  
2880 3a 8a 28			ld a, (.dmark+2)  
2883 32 a8 fd			ld (debug_mark+2),a  
2886 18 03			jr .pastdmark  
2888 ..			.dmark: db ":0B"  
288b f1			.pastdmark: pop af  
288c			endm  
# End of macro DMARK
288c			CALLMONITOR 
288c cd aa fd			call debug_vector  
288f				endm  
# End of macro CALLMONITOR
288f c1			pop bc 
2890			endif 
2890			 
2890			; update word dict linked list for new word 
2890			 
2890			 
2890 2a f9 f3		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2893 23			inc hl     ; move to next work linked list ptr 
2894			 
2894 ed 5b ee f0	ld de, (os_new_malloc)		 ; new next word 
2898 73			ld (hl), e 
2899 23			inc hl 
289a 72			ld (hl), d 
289b			 
289b			if DEBUG_FORTH_UWORD 
289b ed 4b f9 f3	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
289f			endif 
289f			 
289f ed 53 f9 f3	ld (os_last_new_uword), de      ; update last new uword ptr 
28a3			 
28a3			 
28a3			if DEBUG_FORTH_UWORD 
28a3					DMARK ":0+" 
28a3 f5				push af  
28a4 3a b8 28			ld a, (.dmark)  
28a7 32 a6 fd			ld (debug_mark),a  
28aa 3a b9 28			ld a, (.dmark+1)  
28ad 32 a7 fd			ld (debug_mark+1),a  
28b0 3a ba 28			ld a, (.dmark+2)  
28b3 32 a8 fd			ld (debug_mark+2),a  
28b6 18 03			jr .pastdmark  
28b8 ..			.dmark: db ":0+"  
28bb f1			.pastdmark: pop af  
28bc			endm  
# End of macro DMARK
28bc			CALLMONITOR 
28bc cd aa fd			call debug_vector  
28bf				endm  
# End of macro CALLMONITOR
28bf			endif 
28bf			 
28bf			STACKFRAMECHK OFF $8efe $989f 
28bf				if DEBUG_STACK_IMB 
28bf					if OFF 
28bf						exx 
28bf						ld hl, $989f 
28bf						pop de   ; $989f 
28bf						call cmp16 
28bf						jr nz, .spnosame 
28bf						ld hl, $8efe 
28bf						pop de   ; $8efe 
28bf						call cmp16 
28bf						jr z, .spfrsame 
28bf						.spnosame: call showsperror 
28bf						.spfrsame: nop 
28bf						exx 
28bf					endif 
28bf				endif 
28bf			endm 
# End of macro STACKFRAMECHK
28bf			 
28bf c9			ret    ; dont process any remaining parser tokens as they form new word 
28c0			 
28c0			 
28c0			 
28c0			 
28c0			;		NEXT 
28c0			.SCOLN: 
28c0			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
28c0 06			db OPCODE_SCOLN 
28c1 0c 29		dw .DROP 
28c3 02			db 2 
28c4 .. 00		db ";",0           
28c6			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
28c6				if DEBUG_FORTH_WORDS_KEY 
28c6					DMARK "SCN" 
28c6 f5				push af  
28c7 3a db 28			ld a, (.dmark)  
28ca 32 a6 fd			ld (debug_mark),a  
28cd 3a dc 28			ld a, (.dmark+1)  
28d0 32 a7 fd			ld (debug_mark+1),a  
28d3 3a dd 28			ld a, (.dmark+2)  
28d6 32 a8 fd			ld (debug_mark+2),a  
28d9 18 03			jr .pastdmark  
28db ..			.dmark: db "SCN"  
28de f1			.pastdmark: pop af  
28df			endm  
# End of macro DMARK
28df					CALLMONITOR 
28df cd aa fd			call debug_vector  
28e2				endm  
# End of macro CALLMONITOR
28e2				endif 
28e2				FORTH_RSP_TOS 
28e2 cd c1 20			call macro_forth_rsp_tos 
28e5				endm 
# End of macro FORTH_RSP_TOS
28e5 e5				push hl 
28e6				FORTH_RSP_POP 
28e6 cd cb 20			call macro_forth_rsp_pop 
28e9				endm 
# End of macro FORTH_RSP_POP
28e9 e1				pop hl 
28ea			;		ex de,hl 
28ea 22 fd f3			ld (os_tok_ptr),hl 
28ed			 
28ed			if DEBUG_FORTH_UWORD 
28ed					DMARK "SCL" 
28ed f5				push af  
28ee 3a 02 29			ld a, (.dmark)  
28f1 32 a6 fd			ld (debug_mark),a  
28f4 3a 03 29			ld a, (.dmark+1)  
28f7 32 a7 fd			ld (debug_mark+1),a  
28fa 3a 04 29			ld a, (.dmark+2)  
28fd 32 a8 fd			ld (debug_mark+2),a  
2900 18 03			jr .pastdmark  
2902 ..			.dmark: db "SCL"  
2905 f1			.pastdmark: pop af  
2906			endm  
# End of macro DMARK
2906			CALLMONITOR 
2906 cd aa fd			call debug_vector  
2909				endm  
# End of macro CALLMONITOR
2909			endif 
2909				NEXTW 
2909 c3 b0 24			jp macro_next 
290c				endm 
# End of macro NEXTW
290c			 
290c			.DROP: 
290c			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
290c 1b				db WORD_SYS_CORE+OPCODE_DROP             
290d 37 29			dw .DUP2            
290f 05				db 4 + 1 
2910 .. 00			db "DROP",0              
2915				endm 
# End of macro CWHEAD
2915			; | DROP ( w -- )   drop the TOS item   | DONE 
2915				if DEBUG_FORTH_WORDS_KEY 
2915					DMARK "DRP" 
2915 f5				push af  
2916 3a 2a 29			ld a, (.dmark)  
2919 32 a6 fd			ld (debug_mark),a  
291c 3a 2b 29			ld a, (.dmark+1)  
291f 32 a7 fd			ld (debug_mark+1),a  
2922 3a 2c 29			ld a, (.dmark+2)  
2925 32 a8 fd			ld (debug_mark+2),a  
2928 18 03			jr .pastdmark  
292a ..			.dmark: db "DRP"  
292d f1			.pastdmark: pop af  
292e			endm  
# End of macro DMARK
292e					CALLMONITOR 
292e cd aa fd			call debug_vector  
2931				endm  
# End of macro CALLMONITOR
2931				endif 
2931				FORTH_DSP_POP 
2931 cd b2 23			call macro_forth_dsp_pop 
2934				endm 
# End of macro FORTH_DSP_POP
2934				NEXTW 
2934 c3 b0 24			jp macro_next 
2937				endm 
# End of macro NEXTW
2937			.DUP2: 
2937			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2937 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2938 7c 29			dw .DROP2            
293a 05				db 4 + 1 
293b .. 00			db "2DUP",0              
2940				endm 
# End of macro CWHEAD
2940			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2940				if DEBUG_FORTH_WORDS_KEY 
2940					DMARK "2DU" 
2940 f5				push af  
2941 3a 55 29			ld a, (.dmark)  
2944 32 a6 fd			ld (debug_mark),a  
2947 3a 56 29			ld a, (.dmark+1)  
294a 32 a7 fd			ld (debug_mark+1),a  
294d 3a 57 29			ld a, (.dmark+2)  
2950 32 a8 fd			ld (debug_mark+2),a  
2953 18 03			jr .pastdmark  
2955 ..			.dmark: db "2DU"  
2958 f1			.pastdmark: pop af  
2959			endm  
# End of macro DMARK
2959					CALLMONITOR 
2959 cd aa fd			call debug_vector  
295c				endm  
# End of macro CALLMONITOR
295c				endif 
295c				FORTH_DSP_VALUEHL 
295c cd fa 22			call macro_dsp_valuehl 
295f				endm 
# End of macro FORTH_DSP_VALUEHL
295f e5				push hl      ; 2 
2960			 
2960				FORTH_DSP_POP 
2960 cd b2 23			call macro_forth_dsp_pop 
2963				endm 
# End of macro FORTH_DSP_POP
2963				 
2963				FORTH_DSP_VALUEHL 
2963 cd fa 22			call macro_dsp_valuehl 
2966				endm 
# End of macro FORTH_DSP_VALUEHL
2966			;		push hl      ; 1 
2966			 
2966				FORTH_DSP_POP 
2966 cd b2 23			call macro_forth_dsp_pop 
2969				endm 
# End of macro FORTH_DSP_POP
2969			 
2969			;		pop hl       ; 1 
2969 d1				pop de       ; 2 
296a			 
296a cd 03 21			call forth_push_numhl 
296d eb				ex de, hl 
296e cd 03 21			call forth_push_numhl 
2971			 
2971				 
2971 eb				ex de, hl 
2972			 
2972 cd 03 21			call forth_push_numhl 
2975 eb				ex de, hl 
2976 cd 03 21			call forth_push_numhl 
2979			 
2979			 
2979				NEXTW 
2979 c3 b0 24			jp macro_next 
297c				endm 
# End of macro NEXTW
297c			.DROP2: 
297c			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
297c 1d				db WORD_SYS_CORE+OPCODE_DROP2             
297d ab 29			dw .SWAP2            
297f 06				db 5 + 1 
2980 .. 00			db "2DROP",0              
2986				endm 
# End of macro CWHEAD
2986			; | 2DROP ( w w -- )    Double drop | DONE 
2986				if DEBUG_FORTH_WORDS_KEY 
2986					DMARK "2DR" 
2986 f5				push af  
2987 3a 9b 29			ld a, (.dmark)  
298a 32 a6 fd			ld (debug_mark),a  
298d 3a 9c 29			ld a, (.dmark+1)  
2990 32 a7 fd			ld (debug_mark+1),a  
2993 3a 9d 29			ld a, (.dmark+2)  
2996 32 a8 fd			ld (debug_mark+2),a  
2999 18 03			jr .pastdmark  
299b ..			.dmark: db "2DR"  
299e f1			.pastdmark: pop af  
299f			endm  
# End of macro DMARK
299f					CALLMONITOR 
299f cd aa fd			call debug_vector  
29a2				endm  
# End of macro CALLMONITOR
29a2				endif 
29a2				FORTH_DSP_POP 
29a2 cd b2 23			call macro_forth_dsp_pop 
29a5				endm 
# End of macro FORTH_DSP_POP
29a5				FORTH_DSP_POP 
29a5 cd b2 23			call macro_forth_dsp_pop 
29a8				endm 
# End of macro FORTH_DSP_POP
29a8				NEXTW 
29a8 c3 b0 24			jp macro_next 
29ab				endm 
# End of macro NEXTW
29ab			.SWAP2: 
29ab			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
29ab 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
29ac d4 29			dw .AT            
29ae 06				db 5 + 1 
29af .. 00			db "2SWAP",0              
29b5				endm 
# End of macro CWHEAD
29b5			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
29b5				if DEBUG_FORTH_WORDS_KEY 
29b5					DMARK "2SW" 
29b5 f5				push af  
29b6 3a ca 29			ld a, (.dmark)  
29b9 32 a6 fd			ld (debug_mark),a  
29bc 3a cb 29			ld a, (.dmark+1)  
29bf 32 a7 fd			ld (debug_mark+1),a  
29c2 3a cc 29			ld a, (.dmark+2)  
29c5 32 a8 fd			ld (debug_mark+2),a  
29c8 18 03			jr .pastdmark  
29ca ..			.dmark: db "2SW"  
29cd f1			.pastdmark: pop af  
29ce			endm  
# End of macro DMARK
29ce					CALLMONITOR 
29ce cd aa fd			call debug_vector  
29d1				endm  
# End of macro CALLMONITOR
29d1				endif 
29d1			; TODO Use os stack swap memory 
29d1				NEXTW 
29d1 c3 b0 24			jp macro_next 
29d4				endm 
# End of macro NEXTW
29d4			.AT: 
29d4			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
29d4 1f				db WORD_SYS_CORE+OPCODE_AT             
29d5 06 2a			dw .CAT            
29d7 02				db 1 + 1 
29d8 .. 00			db "@",0              
29da				endm 
# End of macro CWHEAD
29da			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
29da			 
29da				if DEBUG_FORTH_WORDS_KEY 
29da					DMARK "AT." 
29da f5				push af  
29db 3a ef 29			ld a, (.dmark)  
29de 32 a6 fd			ld (debug_mark),a  
29e1 3a f0 29			ld a, (.dmark+1)  
29e4 32 a7 fd			ld (debug_mark+1),a  
29e7 3a f1 29			ld a, (.dmark+2)  
29ea 32 a8 fd			ld (debug_mark+2),a  
29ed 18 03			jr .pastdmark  
29ef ..			.dmark: db "AT."  
29f2 f1			.pastdmark: pop af  
29f3			endm  
# End of macro DMARK
29f3					CALLMONITOR 
29f3 cd aa fd			call debug_vector  
29f6				endm  
# End of macro CALLMONITOR
29f6				endif 
29f6			.getbyteat:	 
29f6				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29f6 cd fa 22			call macro_dsp_valuehl 
29f9				endm 
# End of macro FORTH_DSP_VALUEHL
29f9				 
29f9			;		push hl 
29f9			 
29f9				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29f9 cd b2 23			call macro_forth_dsp_pop 
29fc				endm 
# End of macro FORTH_DSP_POP
29fc			 
29fc			;		pop hl 
29fc			 
29fc 7e				ld a, (hl) 
29fd			 
29fd 6f				ld l, a 
29fe 26 00			ld h, 0 
2a00 cd 03 21			call forth_push_numhl 
2a03			 
2a03				NEXTW 
2a03 c3 b0 24			jp macro_next 
2a06				endm 
# End of macro NEXTW
2a06			.CAT: 
2a06			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2a06 20				db WORD_SYS_CORE+OPCODE_CAT             
2a07 2f 2a			dw .BANG            
2a09 03				db 2 + 1 
2a0a .. 00			db "C@",0              
2a0d				endm 
# End of macro CWHEAD
2a0d			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2a0d				if DEBUG_FORTH_WORDS_KEY 
2a0d					DMARK "CAA" 
2a0d f5				push af  
2a0e 3a 22 2a			ld a, (.dmark)  
2a11 32 a6 fd			ld (debug_mark),a  
2a14 3a 23 2a			ld a, (.dmark+1)  
2a17 32 a7 fd			ld (debug_mark+1),a  
2a1a 3a 24 2a			ld a, (.dmark+2)  
2a1d 32 a8 fd			ld (debug_mark+2),a  
2a20 18 03			jr .pastdmark  
2a22 ..			.dmark: db "CAA"  
2a25 f1			.pastdmark: pop af  
2a26			endm  
# End of macro DMARK
2a26					CALLMONITOR 
2a26 cd aa fd			call debug_vector  
2a29				endm  
# End of macro CALLMONITOR
2a29				endif 
2a29 c3 f6 29			jp .getbyteat 
2a2c				NEXTW 
2a2c c3 b0 24			jp macro_next 
2a2f				endm 
# End of macro NEXTW
2a2f			.BANG: 
2a2f			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2a2f 21				db WORD_SYS_CORE+OPCODE_BANG             
2a30 65 2a			dw .CBANG            
2a32 02				db 1 + 1 
2a33 .. 00			db "!",0              
2a35				endm 
# End of macro CWHEAD
2a35			; | ! ( x w -- ) Store x at address w      | DONE 
2a35				if DEBUG_FORTH_WORDS_KEY 
2a35					DMARK "BNG" 
2a35 f5				push af  
2a36 3a 4a 2a			ld a, (.dmark)  
2a39 32 a6 fd			ld (debug_mark),a  
2a3c 3a 4b 2a			ld a, (.dmark+1)  
2a3f 32 a7 fd			ld (debug_mark+1),a  
2a42 3a 4c 2a			ld a, (.dmark+2)  
2a45 32 a8 fd			ld (debug_mark+2),a  
2a48 18 03			jr .pastdmark  
2a4a ..			.dmark: db "BNG"  
2a4d f1			.pastdmark: pop af  
2a4e			endm  
# End of macro DMARK
2a4e					CALLMONITOR 
2a4e cd aa fd			call debug_vector  
2a51				endm  
# End of macro CALLMONITOR
2a51				endif 
2a51			 
2a51			.storebyteat:		 
2a51				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a51 cd fa 22			call macro_dsp_valuehl 
2a54				endm 
# End of macro FORTH_DSP_VALUEHL
2a54				 
2a54 e5				push hl 
2a55			 
2a55				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a55 cd b2 23			call macro_forth_dsp_pop 
2a58				endm 
# End of macro FORTH_DSP_POP
2a58			 
2a58				; get byte to poke 
2a58			 
2a58				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a58 cd fa 22			call macro_dsp_valuehl 
2a5b				endm 
# End of macro FORTH_DSP_VALUEHL
2a5b e5				push hl 
2a5c			 
2a5c			 
2a5c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a5c cd b2 23			call macro_forth_dsp_pop 
2a5f				endm 
# End of macro FORTH_DSP_POP
2a5f			 
2a5f			 
2a5f d1				pop de 
2a60 e1				pop hl 
2a61			 
2a61 73				ld (hl),e 
2a62			 
2a62			 
2a62				NEXTW 
2a62 c3 b0 24			jp macro_next 
2a65				endm 
# End of macro NEXTW
2a65			.CBANG: 
2a65			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2a65 22				db WORD_SYS_CORE+OPCODE_CBANG             
2a66 8e 2a			dw .SCALL            
2a68 03				db 2 + 1 
2a69 .. 00			db "C!",0              
2a6c				endm 
# End of macro CWHEAD
2a6c			; | C!  ( x w -- ) Store x at address w  | DONE 
2a6c				if DEBUG_FORTH_WORDS_KEY 
2a6c					DMARK "CBA" 
2a6c f5				push af  
2a6d 3a 81 2a			ld a, (.dmark)  
2a70 32 a6 fd			ld (debug_mark),a  
2a73 3a 82 2a			ld a, (.dmark+1)  
2a76 32 a7 fd			ld (debug_mark+1),a  
2a79 3a 83 2a			ld a, (.dmark+2)  
2a7c 32 a8 fd			ld (debug_mark+2),a  
2a7f 18 03			jr .pastdmark  
2a81 ..			.dmark: db "CBA"  
2a84 f1			.pastdmark: pop af  
2a85			endm  
# End of macro DMARK
2a85					CALLMONITOR 
2a85 cd aa fd			call debug_vector  
2a88				endm  
# End of macro CALLMONITOR
2a88				endif 
2a88 c3 51 2a			jp .storebyteat 
2a8b				NEXTW 
2a8b c3 b0 24			jp macro_next 
2a8e				endm 
# End of macro NEXTW
2a8e			.SCALL: 
2a8e			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2a8e 23				db WORD_SYS_CORE+OPCODE_SCALL             
2a8f c2 2a			dw .DEPTH            
2a91 05				db 4 + 1 
2a92 .. 00			db "CALL",0              
2a97				endm 
# End of macro CWHEAD
2a97			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2a97				if DEBUG_FORTH_WORDS_KEY 
2a97					DMARK "CLL" 
2a97 f5				push af  
2a98 3a ac 2a			ld a, (.dmark)  
2a9b 32 a6 fd			ld (debug_mark),a  
2a9e 3a ad 2a			ld a, (.dmark+1)  
2aa1 32 a7 fd			ld (debug_mark+1),a  
2aa4 3a ae 2a			ld a, (.dmark+2)  
2aa7 32 a8 fd			ld (debug_mark+2),a  
2aaa 18 03			jr .pastdmark  
2aac ..			.dmark: db "CLL"  
2aaf f1			.pastdmark: pop af  
2ab0			endm  
# End of macro DMARK
2ab0					CALLMONITOR 
2ab0 cd aa fd			call debug_vector  
2ab3				endm  
# End of macro CALLMONITOR
2ab3				endif 
2ab3			 
2ab3				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ab3 cd fa 22			call macro_dsp_valuehl 
2ab6				endm 
# End of macro FORTH_DSP_VALUEHL
2ab6			 
2ab6			;		push hl 
2ab6			 
2ab6				; destroy value TOS 
2ab6			 
2ab6				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ab6 cd b2 23			call macro_forth_dsp_pop 
2ab9				endm 
# End of macro FORTH_DSP_POP
2ab9			 
2ab9					 
2ab9			;		pop hl 
2ab9			 
2ab9				; how to do a call with hl???? save SP? 
2ab9 cd 54 24			call forth_call_hl 
2abc			 
2abc			 
2abc				; TODO push value back onto stack for another op etc 
2abc			 
2abc cd 03 21			call forth_push_numhl 
2abf				NEXTW 
2abf c3 b0 24			jp macro_next 
2ac2				endm 
# End of macro NEXTW
2ac2			.DEPTH: 
2ac2			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2ac2 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2ac3 ff 2a			dw .OVER            
2ac5 06				db 5 + 1 
2ac6 .. 00			db "DEPTH",0              
2acc				endm 
# End of macro CWHEAD
2acc			; | DEPTH ( -- u ) Push count of stack | DONE 
2acc				; take current TOS and remove from base value div by two to get count 
2acc				if DEBUG_FORTH_WORDS_KEY 
2acc					DMARK "DEP" 
2acc f5				push af  
2acd 3a e1 2a			ld a, (.dmark)  
2ad0 32 a6 fd			ld (debug_mark),a  
2ad3 3a e2 2a			ld a, (.dmark+1)  
2ad6 32 a7 fd			ld (debug_mark+1),a  
2ad9 3a e3 2a			ld a, (.dmark+2)  
2adc 32 a8 fd			ld (debug_mark+2),a  
2adf 18 03			jr .pastdmark  
2ae1 ..			.dmark: db "DEP"  
2ae4 f1			.pastdmark: pop af  
2ae5			endm  
# End of macro DMARK
2ae5					CALLMONITOR 
2ae5 cd aa fd			call debug_vector  
2ae8				endm  
# End of macro CALLMONITOR
2ae8				endif 
2ae8			 
2ae8			 
2ae8 2a 29 f9		ld hl, (cli_data_sp) 
2aeb 11 63 f6		ld de, cli_data_stack 
2aee ed 52		sbc hl,de 
2af0			 
2af0			; div by size of stack item 
2af0			 
2af0 5d			ld e,l 
2af1 0e 03		ld c, 3 
2af3 cd 5f 0f		call Div8 
2af6			 
2af6 6f			ld l,a 
2af7 26 00		ld h,0 
2af9			 
2af9			;srl h 
2af9			;rr l 
2af9			 
2af9 cd 03 21			call forth_push_numhl 
2afc				NEXTW 
2afc c3 b0 24			jp macro_next 
2aff				endm 
# End of macro NEXTW
2aff			.OVER: 
2aff			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2aff 42				db WORD_SYS_CORE+46             
2b00 46 2b			dw .PAUSE            
2b02 05				db 4 + 1 
2b03 .. 00			db "OVER",0              
2b08				endm 
# End of macro CWHEAD
2b08			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2b08				if DEBUG_FORTH_WORDS_KEY 
2b08					DMARK "OVR" 
2b08 f5				push af  
2b09 3a 1d 2b			ld a, (.dmark)  
2b0c 32 a6 fd			ld (debug_mark),a  
2b0f 3a 1e 2b			ld a, (.dmark+1)  
2b12 32 a7 fd			ld (debug_mark+1),a  
2b15 3a 1f 2b			ld a, (.dmark+2)  
2b18 32 a8 fd			ld (debug_mark+2),a  
2b1b 18 03			jr .pastdmark  
2b1d ..			.dmark: db "OVR"  
2b20 f1			.pastdmark: pop af  
2b21			endm  
# End of macro DMARK
2b21					CALLMONITOR 
2b21 cd aa fd			call debug_vector  
2b24				endm  
# End of macro CALLMONITOR
2b24				endif 
2b24			 
2b24			; TODO Use os stack swap memory 
2b24				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b24 cd fa 22			call macro_dsp_valuehl 
2b27				endm 
# End of macro FORTH_DSP_VALUEHL
2b27 e5				push hl    ; n2 
2b28				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b28 cd b2 23			call macro_forth_dsp_pop 
2b2b				endm 
# End of macro FORTH_DSP_POP
2b2b			 
2b2b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b2b cd fa 22			call macro_dsp_valuehl 
2b2e				endm 
# End of macro FORTH_DSP_VALUEHL
2b2e e5				push hl    ; n1 
2b2f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b2f cd b2 23			call macro_forth_dsp_pop 
2b32				endm 
# End of macro FORTH_DSP_POP
2b32			 
2b32 d1				pop de     ; n1 
2b33 e1				pop hl     ; n2 
2b34			 
2b34 d5				push de 
2b35 e5				push hl 
2b36 d5				push de 
2b37			 
2b37				; push back  
2b37			 
2b37 e1				pop hl 
2b38 cd 03 21			call forth_push_numhl 
2b3b e1				pop hl 
2b3c cd 03 21			call forth_push_numhl 
2b3f e1				pop hl 
2b40 cd 03 21			call forth_push_numhl 
2b43				NEXTW 
2b43 c3 b0 24			jp macro_next 
2b46				endm 
# End of macro NEXTW
2b46			 
2b46			.PAUSE: 
2b46			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2b46 43				db WORD_SYS_CORE+47             
2b47 7b 2b			dw .PAUSES            
2b49 08				db 7 + 1 
2b4a .. 00			db "PAUSEMS",0              
2b52				endm 
# End of macro CWHEAD
2b52			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2b52				if DEBUG_FORTH_WORDS_KEY 
2b52					DMARK "PMS" 
2b52 f5				push af  
2b53 3a 67 2b			ld a, (.dmark)  
2b56 32 a6 fd			ld (debug_mark),a  
2b59 3a 68 2b			ld a, (.dmark+1)  
2b5c 32 a7 fd			ld (debug_mark+1),a  
2b5f 3a 69 2b			ld a, (.dmark+2)  
2b62 32 a8 fd			ld (debug_mark+2),a  
2b65 18 03			jr .pastdmark  
2b67 ..			.dmark: db "PMS"  
2b6a f1			.pastdmark: pop af  
2b6b			endm  
# End of macro DMARK
2b6b					CALLMONITOR 
2b6b cd aa fd			call debug_vector  
2b6e				endm  
# End of macro CALLMONITOR
2b6e				endif 
2b6e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b6e cd fa 22			call macro_dsp_valuehl 
2b71				endm 
# End of macro FORTH_DSP_VALUEHL
2b71			;		push hl    ; n2 
2b71				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b71 cd b2 23			call macro_forth_dsp_pop 
2b74				endm 
# End of macro FORTH_DSP_POP
2b74			;		pop hl 
2b74			 
2b74 7d				ld a, l 
2b75 cd c3 0c			call aDelayInMS 
2b78			       NEXTW 
2b78 c3 b0 24			jp macro_next 
2b7b				endm 
# End of macro NEXTW
2b7b			.PAUSES:  
2b7b			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2b7b 44				db WORD_SYS_CORE+48             
2b7c ea 2b			dw .ROT            
2b7e 06				db 5 + 1 
2b7f .. 00			db "PAUSE",0              
2b85				endm 
# End of macro CWHEAD
2b85			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2b85				if DEBUG_FORTH_WORDS_KEY 
2b85					DMARK "PAU" 
2b85 f5				push af  
2b86 3a 9a 2b			ld a, (.dmark)  
2b89 32 a6 fd			ld (debug_mark),a  
2b8c 3a 9b 2b			ld a, (.dmark+1)  
2b8f 32 a7 fd			ld (debug_mark+1),a  
2b92 3a 9c 2b			ld a, (.dmark+2)  
2b95 32 a8 fd			ld (debug_mark+2),a  
2b98 18 03			jr .pastdmark  
2b9a ..			.dmark: db "PAU"  
2b9d f1			.pastdmark: pop af  
2b9e			endm  
# End of macro DMARK
2b9e					CALLMONITOR 
2b9e cd aa fd			call debug_vector  
2ba1				endm  
# End of macro CALLMONITOR
2ba1				endif 
2ba1				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ba1 cd fa 22			call macro_dsp_valuehl 
2ba4				endm 
# End of macro FORTH_DSP_VALUEHL
2ba4			;		push hl    ; n2 
2ba4				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ba4 cd b2 23			call macro_forth_dsp_pop 
2ba7				endm 
# End of macro FORTH_DSP_POP
2ba7			;		pop hl 
2ba7 45				ld b, l 
2ba8				if DEBUG_FORTH_WORDS 
2ba8					DMARK "PAU" 
2ba8 f5				push af  
2ba9 3a bd 2b			ld a, (.dmark)  
2bac 32 a6 fd			ld (debug_mark),a  
2baf 3a be 2b			ld a, (.dmark+1)  
2bb2 32 a7 fd			ld (debug_mark+1),a  
2bb5 3a bf 2b			ld a, (.dmark+2)  
2bb8 32 a8 fd			ld (debug_mark+2),a  
2bbb 18 03			jr .pastdmark  
2bbd ..			.dmark: db "PAU"  
2bc0 f1			.pastdmark: pop af  
2bc1			endm  
# End of macro DMARK
2bc1					CALLMONITOR 
2bc1 cd aa fd			call debug_vector  
2bc4				endm  
# End of macro CALLMONITOR
2bc4				endif 
2bc4 c5			.pauses1:	push bc 
2bc5 cd de 0c			call delay1s 
2bc8 c1				pop bc 
2bc9				if DEBUG_FORTH_WORDS 
2bc9					DMARK "PA1" 
2bc9 f5				push af  
2bca 3a de 2b			ld a, (.dmark)  
2bcd 32 a6 fd			ld (debug_mark),a  
2bd0 3a df 2b			ld a, (.dmark+1)  
2bd3 32 a7 fd			ld (debug_mark+1),a  
2bd6 3a e0 2b			ld a, (.dmark+2)  
2bd9 32 a8 fd			ld (debug_mark+2),a  
2bdc 18 03			jr .pastdmark  
2bde ..			.dmark: db "PA1"  
2be1 f1			.pastdmark: pop af  
2be2			endm  
# End of macro DMARK
2be2					CALLMONITOR 
2be2 cd aa fd			call debug_vector  
2be5				endm  
# End of macro CALLMONITOR
2be5				endif 
2be5 10 dd			djnz .pauses1 
2be7			 
2be7			       NEXTW 
2be7 c3 b0 24			jp macro_next 
2bea				endm 
# End of macro NEXTW
2bea			.ROT: 
2bea			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2bea 45				db WORD_SYS_CORE+49             
2beb 38 2c			dw .UWORDS            
2bed 04				db 3 + 1 
2bee .. 00			db "ROT",0              
2bf2				endm 
# End of macro CWHEAD
2bf2			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2bf2				if DEBUG_FORTH_WORDS_KEY 
2bf2					DMARK "ROT" 
2bf2 f5				push af  
2bf3 3a 07 2c			ld a, (.dmark)  
2bf6 32 a6 fd			ld (debug_mark),a  
2bf9 3a 08 2c			ld a, (.dmark+1)  
2bfc 32 a7 fd			ld (debug_mark+1),a  
2bff 3a 09 2c			ld a, (.dmark+2)  
2c02 32 a8 fd			ld (debug_mark+2),a  
2c05 18 03			jr .pastdmark  
2c07 ..			.dmark: db "ROT"  
2c0a f1			.pastdmark: pop af  
2c0b			endm  
# End of macro DMARK
2c0b					CALLMONITOR 
2c0b cd aa fd			call debug_vector  
2c0e				endm  
# End of macro CALLMONITOR
2c0e				endif 
2c0e			 
2c0e			; TODO Use os stack swap memory 
2c0e				FORTH_DSP_VALUEHL 
2c0e cd fa 22			call macro_dsp_valuehl 
2c11				endm 
# End of macro FORTH_DSP_VALUEHL
2c11 e5				push hl    ; u3  
2c12			 
2c12				FORTH_DSP_POP 
2c12 cd b2 23			call macro_forth_dsp_pop 
2c15				endm 
# End of macro FORTH_DSP_POP
2c15			 
2c15				FORTH_DSP_VALUEHL 
2c15 cd fa 22			call macro_dsp_valuehl 
2c18				endm 
# End of macro FORTH_DSP_VALUEHL
2c18 e5				push hl     ; u2 
2c19			 
2c19				FORTH_DSP_POP 
2c19 cd b2 23			call macro_forth_dsp_pop 
2c1c				endm 
# End of macro FORTH_DSP_POP
2c1c			 
2c1c				FORTH_DSP_VALUEHL 
2c1c cd fa 22			call macro_dsp_valuehl 
2c1f				endm 
# End of macro FORTH_DSP_VALUEHL
2c1f e5				push hl     ; u1 
2c20			 
2c20				FORTH_DSP_POP 
2c20 cd b2 23			call macro_forth_dsp_pop 
2c23				endm 
# End of macro FORTH_DSP_POP
2c23			 
2c23 c1				pop bc      ; u1 
2c24 e1				pop hl      ; u2 
2c25 d1				pop de      ; u3 
2c26			 
2c26			 
2c26 c5				push bc 
2c27 d5				push de 
2c28 e5				push hl 
2c29			 
2c29			 
2c29 e1				pop hl 
2c2a cd 03 21			call forth_push_numhl 
2c2d			 
2c2d e1				pop hl 
2c2e cd 03 21			call forth_push_numhl 
2c31			 
2c31 e1				pop hl 
2c32 cd 03 21			call forth_push_numhl 
2c35				 
2c35			 
2c35			 
2c35			 
2c35			 
2c35			 
2c35			       NEXTW 
2c35 c3 b0 24			jp macro_next 
2c38				endm 
# End of macro NEXTW
2c38			 
2c38			.UWORDS: 
2c38			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2c38 50				db WORD_SYS_CORE+60             
2c39 fa 2c			dw .BP            
2c3b 07				db 6 + 1 
2c3c .. 00			db "UWORDS",0              
2c43				endm 
# End of macro CWHEAD
2c43			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2c43			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2c43			; | | Following the count are the individual words. 
2c43			; | | 
2c43			; | | e.g. UWORDS 
2c43			; | | BOX DIRLIST 2 
2c43			; | |  
2c43			; | | Can be used to save the words to storage via: 
2c43			; | | UWORDS $01 DO $01 APPEND LOOP 
2c43			if DEBUG_FORTH_WORDS_KEY 
2c43				DMARK "UWR" 
2c43 f5				push af  
2c44 3a 58 2c			ld a, (.dmark)  
2c47 32 a6 fd			ld (debug_mark),a  
2c4a 3a 59 2c			ld a, (.dmark+1)  
2c4d 32 a7 fd			ld (debug_mark+1),a  
2c50 3a 5a 2c			ld a, (.dmark+2)  
2c53 32 a8 fd			ld (debug_mark+2),a  
2c56 18 03			jr .pastdmark  
2c58 ..			.dmark: db "UWR"  
2c5b f1			.pastdmark: pop af  
2c5c			endm  
# End of macro DMARK
2c5c				CALLMONITOR 
2c5c cd aa fd			call debug_vector  
2c5f				endm  
# End of macro CALLMONITOR
2c5f			endif 
2c5f 21 00 80			ld hl, baseram 
2c62				;ld hl, baseusermem 
2c62 01 00 00			ld bc, 0    ; start a counter 
2c65			 
2c65			; skip dict stub 
2c65			 
2c65 cd 01 26			call forth_tok_next 
2c68			 
2c68			 
2c68			; while we have words to look for 
2c68			 
2c68 7e			.douscan:	ld a, (hl)      
2c69			if DEBUG_FORTH_WORDS 
2c69				DMARK "UWs" 
2c69 f5				push af  
2c6a 3a 7e 2c			ld a, (.dmark)  
2c6d 32 a6 fd			ld (debug_mark),a  
2c70 3a 7f 2c			ld a, (.dmark+1)  
2c73 32 a7 fd			ld (debug_mark+1),a  
2c76 3a 80 2c			ld a, (.dmark+2)  
2c79 32 a8 fd			ld (debug_mark+2),a  
2c7c 18 03			jr .pastdmark  
2c7e ..			.dmark: db "UWs"  
2c81 f1			.pastdmark: pop af  
2c82			endm  
# End of macro DMARK
2c82				CALLMONITOR 
2c82 cd aa fd			call debug_vector  
2c85				endm  
# End of macro CALLMONITOR
2c85			endif 
2c85 fe 00			cp WORD_SYS_END 
2c87 28 4d			jr z, .udone 
2c89 fe 01			cp WORD_SYS_UWORD 
2c8b 20 44			jr nz, .nuword 
2c8d			 
2c8d			if DEBUG_FORTH_WORDS 
2c8d				DMARK "UWu" 
2c8d f5				push af  
2c8e 3a a2 2c			ld a, (.dmark)  
2c91 32 a6 fd			ld (debug_mark),a  
2c94 3a a3 2c			ld a, (.dmark+1)  
2c97 32 a7 fd			ld (debug_mark+1),a  
2c9a 3a a4 2c			ld a, (.dmark+2)  
2c9d 32 a8 fd			ld (debug_mark+2),a  
2ca0 18 03			jr .pastdmark  
2ca2 ..			.dmark: db "UWu"  
2ca5 f1			.pastdmark: pop af  
2ca6			endm  
# End of macro DMARK
2ca6				CALLMONITOR 
2ca6 cd aa fd			call debug_vector  
2ca9				endm  
# End of macro CALLMONITOR
2ca9			endif 
2ca9				; we have a uword so push its name to the stack 
2ca9			 
2ca9 e5				push hl  ; save so we can move to next dict block 
2caa			 
2caa				; skip opcode 
2caa 23				inc hl  
2cab				; skip next ptr 
2cab 23				inc hl  
2cac 23				inc hl 
2cad				; skip len 
2cad 23				inc hl 
2cae			if DEBUG_FORTH_WORDS 
2cae				DMARK "UWt" 
2cae f5				push af  
2caf 3a c3 2c			ld a, (.dmark)  
2cb2 32 a6 fd			ld (debug_mark),a  
2cb5 3a c4 2c			ld a, (.dmark+1)  
2cb8 32 a7 fd			ld (debug_mark+1),a  
2cbb 3a c5 2c			ld a, (.dmark+2)  
2cbe 32 a8 fd			ld (debug_mark+2),a  
2cc1 18 03			jr .pastdmark  
2cc3 ..			.dmark: db "UWt"  
2cc6 f1			.pastdmark: pop af  
2cc7			endm  
# End of macro DMARK
2cc7				CALLMONITOR 
2cc7 cd aa fd			call debug_vector  
2cca				endm  
# End of macro CALLMONITOR
2cca			endif 
2cca 03				inc bc 
2ccb			 
2ccb c5				push bc 
2ccc cd 71 21			call forth_push_str 
2ccf c1				pop bc 
2cd0			 
2cd0 e1				pop hl 	 
2cd1			 
2cd1 cd 01 26		.nuword:	call forth_tok_next 
2cd4 18 92			jr .douscan  
2cd6			 
2cd6			.udone:		 ; push count of uwords found 
2cd6 c5				push bc 
2cd7 e1				pop hl 
2cd8			 
2cd8			if DEBUG_FORTH_WORDS 
2cd8				DMARK "UWc" 
2cd8 f5				push af  
2cd9 3a ed 2c			ld a, (.dmark)  
2cdc 32 a6 fd			ld (debug_mark),a  
2cdf 3a ee 2c			ld a, (.dmark+1)  
2ce2 32 a7 fd			ld (debug_mark+1),a  
2ce5 3a ef 2c			ld a, (.dmark+2)  
2ce8 32 a8 fd			ld (debug_mark+2),a  
2ceb 18 03			jr .pastdmark  
2ced ..			.dmark: db "UWc"  
2cf0 f1			.pastdmark: pop af  
2cf1			endm  
# End of macro DMARK
2cf1				CALLMONITOR 
2cf1 cd aa fd			call debug_vector  
2cf4				endm  
# End of macro CALLMONITOR
2cf4			endif 
2cf4 cd 03 21			call forth_push_numhl 
2cf7			 
2cf7			 
2cf7			       NEXTW 
2cf7 c3 b0 24			jp macro_next 
2cfa				endm 
# End of macro NEXTW
2cfa			 
2cfa			.BP: 
2cfa			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2cfa 54				db WORD_SYS_CORE+64             
2cfb 34 2d			dw .MONITOR            
2cfd 03				db 2 + 1 
2cfe .. 00			db "BP",0              
2d01				endm 
# End of macro CWHEAD
2d01			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2d01			; | | $00 Will enable the break points within specific code paths 
2d01			; | | $01 Will disable break points 
2d01			; | |  
2d01			; | | By default break points are off. Either the above can be used to enable them 
2d01			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2d01			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2d01			; | | can disable break points. Exiting will then continue boot process. 
2d01				; get byte count 
2d01				if DEBUG_FORTH_WORDS_KEY 
2d01					DMARK "BP." 
2d01 f5				push af  
2d02 3a 16 2d			ld a, (.dmark)  
2d05 32 a6 fd			ld (debug_mark),a  
2d08 3a 17 2d			ld a, (.dmark+1)  
2d0b 32 a7 fd			ld (debug_mark+1),a  
2d0e 3a 18 2d			ld a, (.dmark+2)  
2d11 32 a8 fd			ld (debug_mark+2),a  
2d14 18 03			jr .pastdmark  
2d16 ..			.dmark: db "BP."  
2d19 f1			.pastdmark: pop af  
2d1a			endm  
# End of macro DMARK
2d1a					CALLMONITOR 
2d1a cd aa fd			call debug_vector  
2d1d				endm  
# End of macro CALLMONITOR
2d1d				endif 
2d1d			 
2d1d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d1d cd fa 22			call macro_dsp_valuehl 
2d20				endm 
# End of macro FORTH_DSP_VALUEHL
2d20			 
2d20			;		push hl 
2d20			 
2d20				; destroy value TOS 
2d20			 
2d20				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d20 cd b2 23			call macro_forth_dsp_pop 
2d23				endm 
# End of macro FORTH_DSP_POP
2d23			 
2d23			;		pop hl 
2d23			 
2d23 3e 00			ld a,0 
2d25 bd				cp l 
2d26 28 06			jr z, .bpset 
2d28			;		ld a, '*' 
2d28 cd 41 1a			call bp_off 
2d2b				NEXTW 
2d2b c3 b0 24			jp macro_next 
2d2e				endm 
# End of macro NEXTW
2d2e			 
2d2e			.bpset:	 
2d2e				;	ld (os_view_disable), a 
2d2e cd 35 1a			call bp_on 
2d31			 
2d31			 
2d31				NEXTW 
2d31 c3 b0 24			jp macro_next 
2d34				endm 
# End of macro NEXTW
2d34			 
2d34			 
2d34			.MONITOR: 
2d34			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2d34 55				db WORD_SYS_CORE+65             
2d35 65 2d			dw .MALLOC            
2d37 08				db 7 + 1 
2d38 .. 00			db "MONITOR",0              
2d40				endm 
# End of macro CWHEAD
2d40			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2d40			; | | At start the current various registers will be displayed with contents. 
2d40			; | | Top right corner will show the most recent debug marker seen. 
2d40			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2d40			; | | and the return stack pointer (RSP). 
2d40			; | | Pressing: 
2d40			; | |    1 - Initial screen 
2d40			; | |    2 - Display a data dump of HL 
2d40			; | |    3 - Display a data dump of DE 
2d40			; | |    4 - Display a data dump of BC 
2d40			; | |    5 - Display a data dump of HL 
2d40			; | |    6 - Display a data dump of DSP 
2d40			; | |    7 - Display a data dump of RSP 
2d40			; | |    8 - Display a data dump of what is at DSP 
2d40			; | |    9 - Display a data dump of what is at RSP 
2d40			; | |    0 - Exit monitor and continue running. This will also enable break points 
2d40			; | |    * - Disable break points 
2d40			; | |    # - Enter traditional monitor mode 
2d40			; | | 
2d40			; | | Monitor Mode 
2d40			; | | ------------ 
2d40			; | | A prompt of '>' will be shown for various commands: 
2d40			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2d40			; | |    C - Continue display a data dump from the last set address 
2d40			; | |    M xxxx - Set start of memory edit at address xx 
2d40			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2d40			; | |    G xxxx - Exec code at specific address 
2d40			; | |    Q - Return to previous 
2d40				if DEBUG_FORTH_WORDS_KEY 
2d40					DMARK "MON" 
2d40 f5				push af  
2d41 3a 55 2d			ld a, (.dmark)  
2d44 32 a6 fd			ld (debug_mark),a  
2d47 3a 56 2d			ld a, (.dmark+1)  
2d4a 32 a7 fd			ld (debug_mark+1),a  
2d4d 3a 57 2d			ld a, (.dmark+2)  
2d50 32 a8 fd			ld (debug_mark+2),a  
2d53 18 03			jr .pastdmark  
2d55 ..			.dmark: db "MON"  
2d58 f1			.pastdmark: pop af  
2d59			endm  
# End of macro DMARK
2d59					CALLMONITOR 
2d59 cd aa fd			call debug_vector  
2d5c				endm  
# End of macro CALLMONITOR
2d5c				endif 
2d5c			;		ld a, 0 
2d5c			;		ld (os_view_disable), a 
2d5c cd 35 1a			call bp_on 
2d5f			 
2d5f				CALLMONITOR 
2d5f cd aa fd			call debug_vector  
2d62				endm  
# End of macro CALLMONITOR
2d62			 
2d62			;	call monitor 
2d62			 
2d62				NEXTW 
2d62 c3 b0 24			jp macro_next 
2d65				endm 
# End of macro NEXTW
2d65			 
2d65			 
2d65			.MALLOC: 
2d65			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2d65 56				db WORD_SYS_CORE+66             
2d66 8e 2d			dw .MALLOC2            
2d68 06				db 5 + 1 
2d69 .. 00			db "ALLOT",0              
2d6f				endm 
# End of macro CWHEAD
2d6f			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d6f				if DEBUG_FORTH_WORDS_KEY 
2d6f					DMARK "ALL" 
2d6f f5				push af  
2d70 3a 84 2d			ld a, (.dmark)  
2d73 32 a6 fd			ld (debug_mark),a  
2d76 3a 85 2d			ld a, (.dmark+1)  
2d79 32 a7 fd			ld (debug_mark+1),a  
2d7c 3a 86 2d			ld a, (.dmark+2)  
2d7f 32 a8 fd			ld (debug_mark+2),a  
2d82 18 03			jr .pastdmark  
2d84 ..			.dmark: db "ALL"  
2d87 f1			.pastdmark: pop af  
2d88			endm  
# End of macro DMARK
2d88					CALLMONITOR 
2d88 cd aa fd			call debug_vector  
2d8b				endm  
# End of macro CALLMONITOR
2d8b				endif 
2d8b c3 b5 2d			jp .mallocc 
2d8e			.MALLOC2: 
2d8e			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2d8e 56				db WORD_SYS_CORE+66             
2d8f cc 2d			dw .FREE            
2d91 07				db 6 + 1 
2d92 .. 00			db "MALLOC",0              
2d99				endm 
# End of macro CWHEAD
2d99			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d99				; get byte count 
2d99				if DEBUG_FORTH_WORDS_KEY 
2d99					DMARK "MAL" 
2d99 f5				push af  
2d9a 3a ae 2d			ld a, (.dmark)  
2d9d 32 a6 fd			ld (debug_mark),a  
2da0 3a af 2d			ld a, (.dmark+1)  
2da3 32 a7 fd			ld (debug_mark+1),a  
2da6 3a b0 2d			ld a, (.dmark+2)  
2da9 32 a8 fd			ld (debug_mark+2),a  
2dac 18 03			jr .pastdmark  
2dae ..			.dmark: db "MAL"  
2db1 f1			.pastdmark: pop af  
2db2			endm  
# End of macro DMARK
2db2					CALLMONITOR 
2db2 cd aa fd			call debug_vector  
2db5				endm  
# End of macro CALLMONITOR
2db5				endif 
2db5			.mallocc: 
2db5				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2db5 cd fa 22			call macro_dsp_valuehl 
2db8				endm 
# End of macro FORTH_DSP_VALUEHL
2db8			 
2db8			;		push hl 
2db8			 
2db8				; destroy value TOS 
2db8			 
2db8				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2db8 cd b2 23			call macro_forth_dsp_pop 
2dbb				endm 
# End of macro FORTH_DSP_POP
2dbb			 
2dbb			;		pop hl 
2dbb cd a2 14			call malloc 
2dbe			if DEBUG_FORTH_MALLOC_GUARD 
2dbe f5				push af 
2dbf cd f8 0f			call ishlzero 
2dc2			;		ld a, l 
2dc2			;		add h 
2dc2			;		cp 0 
2dc2 f1				pop af 
2dc3				 
2dc3 cc 83 5e			call z,malloc_error 
2dc6			endif 
2dc6			 
2dc6 cd 03 21			call forth_push_numhl 
2dc9				NEXTW 
2dc9 c3 b0 24			jp macro_next 
2dcc				endm 
# End of macro NEXTW
2dcc			 
2dcc			.FREE: 
2dcc			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2dcc 57				db WORD_SYS_CORE+67             
2dcd fd 2d			dw .LIST            
2dcf 05				db 4 + 1 
2dd0 .. 00			db "FREE",0              
2dd5				endm 
# End of macro CWHEAD
2dd5			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2dd5				if DEBUG_FORTH_WORDS_KEY 
2dd5					DMARK "FRE" 
2dd5 f5				push af  
2dd6 3a ea 2d			ld a, (.dmark)  
2dd9 32 a6 fd			ld (debug_mark),a  
2ddc 3a eb 2d			ld a, (.dmark+1)  
2ddf 32 a7 fd			ld (debug_mark+1),a  
2de2 3a ec 2d			ld a, (.dmark+2)  
2de5 32 a8 fd			ld (debug_mark+2),a  
2de8 18 03			jr .pastdmark  
2dea ..			.dmark: db "FRE"  
2ded f1			.pastdmark: pop af  
2dee			endm  
# End of macro DMARK
2dee					CALLMONITOR 
2dee cd aa fd			call debug_vector  
2df1				endm  
# End of macro CALLMONITOR
2df1				endif 
2df1				; get address 
2df1			 
2df1				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2df1 cd fa 22			call macro_dsp_valuehl 
2df4				endm 
# End of macro FORTH_DSP_VALUEHL
2df4			 
2df4			;		push hl 
2df4			 
2df4				; destroy value TOS 
2df4			 
2df4				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2df4 cd b2 23			call macro_forth_dsp_pop 
2df7				endm 
# End of macro FORTH_DSP_POP
2df7			 
2df7			;		pop hl 
2df7			if FORTH_ENABLE_MALLOCFREE 
2df7 cd 6c 15			call free 
2dfa			endif 
2dfa				NEXTW 
2dfa c3 b0 24			jp macro_next 
2dfd				endm 
# End of macro NEXTW
2dfd			.LIST: 
2dfd			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2dfd 5c				db WORD_SYS_CORE+72             
2dfe ed 2f			dw .FORGET            
2e00 05				db 4 + 1 
2e01 .. 00			db "LIST",0              
2e06				endm 
# End of macro CWHEAD
2e06			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2e06			; | | The quoted word must be in upper case. 
2e06			if DEBUG_FORTH_WORDS_KEY 
2e06				DMARK "LST" 
2e06 f5				push af  
2e07 3a 1b 2e			ld a, (.dmark)  
2e0a 32 a6 fd			ld (debug_mark),a  
2e0d 3a 1c 2e			ld a, (.dmark+1)  
2e10 32 a7 fd			ld (debug_mark+1),a  
2e13 3a 1d 2e			ld a, (.dmark+2)  
2e16 32 a8 fd			ld (debug_mark+2),a  
2e19 18 03			jr .pastdmark  
2e1b ..			.dmark: db "LST"  
2e1e f1			.pastdmark: pop af  
2e1f			endm  
# End of macro DMARK
2e1f				CALLMONITOR 
2e1f cd aa fd			call debug_vector  
2e22				endm  
# End of macro CALLMONITOR
2e22			endif 
2e22			 
2e22				FORTH_DSP_VALUEHL 
2e22 cd fa 22			call macro_dsp_valuehl 
2e25				endm 
# End of macro FORTH_DSP_VALUEHL
2e25			 
2e25 e5				push hl 
2e26				FORTH_DSP_POP 
2e26 cd b2 23			call macro_forth_dsp_pop 
2e29				endm 
# End of macro FORTH_DSP_POP
2e29 c1				pop bc 
2e2a			 
2e2a			; Start format of scratch string 
2e2a			 
2e2a 21 fc f0			ld hl, scratch 
2e2d			 
2e2d 3e 3a			ld a, ':' 
2e2f 77				ld (hl),a 
2e30 23				inc hl 
2e31 3e 20			ld a, ' ' 
2e33 77				ld (hl), a 
2e34			 
2e34				; Get ptr to the word we need to look up 
2e34			 
2e34			;		FORTH_DSP_VALUEHL 
2e34				;v5 FORTH_DSP_VALUE 
2e34			; TODO type check 
2e34			;		inc hl    ; Skip type check  
2e34			;		push hl 
2e34			;		ex de, hl    ; put into DE 
2e34			 
2e34			 
2e34 21 00 80			ld hl, baseram 
2e37				;ld hl, baseusermem 
2e37			 
2e37 e5			push hl   ; sacreifical push 
2e38			 
2e38			.ldouscanm: 
2e38 e1			pop hl 
2e39			.ldouscan: 
2e39			if DEBUG_FORTH_WORDS 
2e39				DMARK "LSs" 
2e39 f5				push af  
2e3a 3a 4e 2e			ld a, (.dmark)  
2e3d 32 a6 fd			ld (debug_mark),a  
2e40 3a 4f 2e			ld a, (.dmark+1)  
2e43 32 a7 fd			ld (debug_mark+1),a  
2e46 3a 50 2e			ld a, (.dmark+2)  
2e49 32 a8 fd			ld (debug_mark+2),a  
2e4c 18 03			jr .pastdmark  
2e4e ..			.dmark: db "LSs"  
2e51 f1			.pastdmark: pop af  
2e52			endm  
# End of macro DMARK
2e52				CALLMONITOR 
2e52 cd aa fd			call debug_vector  
2e55				endm  
# End of macro CALLMONITOR
2e55			endif 
2e55			; skip dict stub 
2e55 cd 01 26			call forth_tok_next 
2e58			 
2e58			 
2e58			; while we have words to look for 
2e58			 
2e58 7e			ld a, (hl)      
2e59			if DEBUG_FORTH_WORDS 
2e59				DMARK "LSk" 
2e59 f5				push af  
2e5a 3a 6e 2e			ld a, (.dmark)  
2e5d 32 a6 fd			ld (debug_mark),a  
2e60 3a 6f 2e			ld a, (.dmark+1)  
2e63 32 a7 fd			ld (debug_mark+1),a  
2e66 3a 70 2e			ld a, (.dmark+2)  
2e69 32 a8 fd			ld (debug_mark+2),a  
2e6c 18 03			jr .pastdmark  
2e6e ..			.dmark: db "LSk"  
2e71 f1			.pastdmark: pop af  
2e72			endm  
# End of macro DMARK
2e72				CALLMONITOR 
2e72 cd aa fd			call debug_vector  
2e75				endm  
# End of macro CALLMONITOR
2e75			endif 
2e75				;cp WORD_SYS_END 
2e75				;jp z, .lunotfound 
2e75			 
2e75					; if we hit non uwords then gone too far 
2e75 fe 01				cp WORD_SYS_UWORD 
2e77 c2 a9 2f				jp nz, .lunotfound 
2e7a			 
2e7a				if DEBUG_FORTH_WORDS 
2e7a					DMARK "LSu" 
2e7a f5				push af  
2e7b 3a 8f 2e			ld a, (.dmark)  
2e7e 32 a6 fd			ld (debug_mark),a  
2e81 3a 90 2e			ld a, (.dmark+1)  
2e84 32 a7 fd			ld (debug_mark+1),a  
2e87 3a 91 2e			ld a, (.dmark+2)  
2e8a 32 a8 fd			ld (debug_mark+2),a  
2e8d 18 03			jr .pastdmark  
2e8f ..			.dmark: db "LSu"  
2e92 f1			.pastdmark: pop af  
2e93			endm  
# End of macro DMARK
2e93					CALLMONITOR 
2e93 cd aa fd			call debug_vector  
2e96				endm  
# End of macro CALLMONITOR
2e96				endif 
2e96			 
2e96					; found a uword but is it the one we want... 
2e96			 
2e96 c5					push bc     ; uword to find is on bc 
2e97 d1					pop de 
2e98			 
2e98 e5					push hl  ; to save the ptr 
2e99			 
2e99					; skip opcode 
2e99 23					inc hl  
2e9a					; skip next ptr 
2e9a 23					inc hl  
2e9b 23					inc hl 
2e9c					; skip len 
2e9c 23					inc hl 
2e9d			 
2e9d				if DEBUG_FORTH_WORDS 
2e9d					DMARK "LSc" 
2e9d f5				push af  
2e9e 3a b2 2e			ld a, (.dmark)  
2ea1 32 a6 fd			ld (debug_mark),a  
2ea4 3a b3 2e			ld a, (.dmark+1)  
2ea7 32 a7 fd			ld (debug_mark+1),a  
2eaa 3a b4 2e			ld a, (.dmark+2)  
2ead 32 a8 fd			ld (debug_mark+2),a  
2eb0 18 03			jr .pastdmark  
2eb2 ..			.dmark: db "LSc"  
2eb5 f1			.pastdmark: pop af  
2eb6			endm  
# End of macro DMARK
2eb6					CALLMONITOR 
2eb6 cd aa fd			call debug_vector  
2eb9				endm  
# End of macro CALLMONITOR
2eb9				endif 
2eb9			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2eb9			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2eb9			; Nope that has gone the other way. It needs to be exact not on first zero 
2eb9			;		call strcmp 
2eb9 c5					push bc 
2eba cd 72 14				call StrictStrCmp 
2ebd c1					pop bc 
2ebe c2 38 2e				jp nz, .ldouscanm 
2ec1				 
2ec1			 
2ec1			 
2ec1					; we have a uword so push its name to the stack 
2ec1			 
2ec1			;	   	push hl  ; save so we can move to next dict block 
2ec1 e1			pop hl 
2ec2			 
2ec2				if DEBUG_FORTH_WORDS 
2ec2					DMARK "LSm" 
2ec2 f5				push af  
2ec3 3a d7 2e			ld a, (.dmark)  
2ec6 32 a6 fd			ld (debug_mark),a  
2ec9 3a d8 2e			ld a, (.dmark+1)  
2ecc 32 a7 fd			ld (debug_mark+1),a  
2ecf 3a d9 2e			ld a, (.dmark+2)  
2ed2 32 a8 fd			ld (debug_mark+2),a  
2ed5 18 03			jr .pastdmark  
2ed7 ..			.dmark: db "LSm"  
2eda f1			.pastdmark: pop af  
2edb			endm  
# End of macro DMARK
2edb					CALLMONITOR 
2edb cd aa fd			call debug_vector  
2ede				endm  
# End of macro CALLMONITOR
2ede				endif 
2ede			 
2ede					; skip opcode 
2ede 23					inc hl  
2edf					; skip next ptr 
2edf 23					inc hl  
2ee0 23					inc hl 
2ee1					; skip len 
2ee1 7e					ld a, (hl)   ; save length to add 
2ee2				if DEBUG_FORTH_WORDS 
2ee2					DMARK "LS2" 
2ee2 f5				push af  
2ee3 3a f7 2e			ld a, (.dmark)  
2ee6 32 a6 fd			ld (debug_mark),a  
2ee9 3a f8 2e			ld a, (.dmark+1)  
2eec 32 a7 fd			ld (debug_mark+1),a  
2eef 3a f9 2e			ld a, (.dmark+2)  
2ef2 32 a8 fd			ld (debug_mark+2),a  
2ef5 18 03			jr .pastdmark  
2ef7 ..			.dmark: db "LS2"  
2efa f1			.pastdmark: pop af  
2efb			endm  
# End of macro DMARK
2efb					CALLMONITOR 
2efb cd aa fd			call debug_vector  
2efe				endm  
# End of macro CALLMONITOR
2efe				endif 
2efe			 
2efe					; save this location 
2efe				 
2efe e5					push hl 
2eff			 
2eff 23					inc hl 
2f00 11 fe f0				ld de, scratch+2 
2f03 4f					ld c, a 
2f04 06 00				ld b, 0 
2f06			 
2f06				if DEBUG_FORTH_WORDS 
2f06					DMARK "LSn" 
2f06 f5				push af  
2f07 3a 1b 2f			ld a, (.dmark)  
2f0a 32 a6 fd			ld (debug_mark),a  
2f0d 3a 1c 2f			ld a, (.dmark+1)  
2f10 32 a7 fd			ld (debug_mark+1),a  
2f13 3a 1d 2f			ld a, (.dmark+2)  
2f16 32 a8 fd			ld (debug_mark+2),a  
2f19 18 03			jr .pastdmark  
2f1b ..			.dmark: db "LSn"  
2f1e f1			.pastdmark: pop af  
2f1f			endm  
# End of macro DMARK
2f1f					CALLMONITOR 
2f1f cd aa fd			call debug_vector  
2f22				endm  
# End of macro CALLMONITOR
2f22				endif 
2f22			 
2f22					; copy uword name to scratch 
2f22			 
2f22 ed b0				ldir 
2f24			 
2f24 1b					dec de 
2f25 3e 20				ld a, ' '    ; change null to space 
2f27 12					ld (de), a 
2f28			 
2f28 13					inc de 
2f29			 
2f29 d5					push de 
2f2a c1					pop bc     ; move scratch pointer to end of word name and save it 
2f2b			 
2f2b e1					pop hl 
2f2c 7e					ld a, (hl) 
2f2d					;inc hl 
2f2d					; skip word string 
2f2d cd cf 0f				call addatohl 
2f30			 
2f30 23					inc hl 
2f31			 
2f31				if DEBUG_FORTH_WORDS 
2f31					DMARK "LS3" 
2f31 f5				push af  
2f32 3a 46 2f			ld a, (.dmark)  
2f35 32 a6 fd			ld (debug_mark),a  
2f38 3a 47 2f			ld a, (.dmark+1)  
2f3b 32 a7 fd			ld (debug_mark+1),a  
2f3e 3a 48 2f			ld a, (.dmark+2)  
2f41 32 a8 fd			ld (debug_mark+2),a  
2f44 18 03			jr .pastdmark  
2f46 ..			.dmark: db "LS3"  
2f49 f1			.pastdmark: pop af  
2f4a			endm  
# End of macro DMARK
2f4a					CALLMONITOR 
2f4a cd aa fd			call debug_vector  
2f4d				endm  
# End of macro CALLMONITOR
2f4d				endif 
2f4d					; should now be at the start of the machine code to setup the eval of the uword 
2f4d					; now locate the ptr to the string defintion 
2f4d			 
2f4d					; skip ld hl, 
2f4d					; then load the ptr 
2f4d			; TODO use get from hl ptr 
2f4d 23					inc hl 
2f4e 5e					ld e, (hl) 
2f4f 23					inc hl 
2f50 56					ld d, (hl) 
2f51 eb					ex de, hl 
2f52			 
2f52			 
2f52				if DEBUG_FORTH_WORDS 
2f52					DMARK "LSt" 
2f52 f5				push af  
2f53 3a 67 2f			ld a, (.dmark)  
2f56 32 a6 fd			ld (debug_mark),a  
2f59 3a 68 2f			ld a, (.dmark+1)  
2f5c 32 a7 fd			ld (debug_mark+1),a  
2f5f 3a 69 2f			ld a, (.dmark+2)  
2f62 32 a8 fd			ld (debug_mark+2),a  
2f65 18 03			jr .pastdmark  
2f67 ..			.dmark: db "LSt"  
2f6a f1			.pastdmark: pop af  
2f6b			endm  
# End of macro DMARK
2f6b					CALLMONITOR 
2f6b cd aa fd			call debug_vector  
2f6e				endm  
# End of macro CALLMONITOR
2f6e				endif 
2f6e			 
2f6e			; cant push right now due to tokenised strings  
2f6e			 
2f6e			; get the destination of where to copy this definition to. 
2f6e			 
2f6e c5					push bc 
2f6f d1					pop de 
2f70			 
2f70 7e			.listl:         ld a,(hl) 
2f71 fe 00				cp 0 
2f73 28 09				jr z, .lreplsp     ; replace zero with space 
2f75					;cp FORTH_END_BUFFER 
2f75 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2f77 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2f79				 
2f79					; just copy this char as is then 
2f79			 
2f79 12					ld (de), a 
2f7a			 
2f7a 23			.listnxt:	inc hl 
2f7b 13					inc de 
2f7c 18 f2				jr .listl 
2f7e			 
2f7e 3e 20		.lreplsp:	ld a,' ' 
2f80 12					ld (de), a 
2f81 18 f7				jr .listnxt 
2f83			 
2f83			; close up uword def 
2f83			 
2f83			.listdone: 
2f83 12					ld (de), a 
2f84 13					inc de 
2f85 3e 00				ld a, 0 
2f87 12					ld (de), a 
2f88			 
2f88			; now have def so clean up and push to stack 
2f88			 
2f88 21 fc f0				ld hl, scratch 
2f8b				if DEBUG_FORTH_WORDS 
2f8b					DMARK "Ltp" 
2f8b f5				push af  
2f8c 3a a0 2f			ld a, (.dmark)  
2f8f 32 a6 fd			ld (debug_mark),a  
2f92 3a a1 2f			ld a, (.dmark+1)  
2f95 32 a7 fd			ld (debug_mark+1),a  
2f98 3a a2 2f			ld a, (.dmark+2)  
2f9b 32 a8 fd			ld (debug_mark+2),a  
2f9e 18 03			jr .pastdmark  
2fa0 ..			.dmark: db "Ltp"  
2fa3 f1			.pastdmark: pop af  
2fa4			endm  
# End of macro DMARK
2fa4					CALLMONITOR 
2fa4 cd aa fd			call debug_vector  
2fa7				endm  
# End of macro CALLMONITOR
2fa7				endif 
2fa7			 
2fa7 18 1f			jr .listpush 
2fa9			 
2fa9			;.lnuword:	pop hl 
2fa9			;		call forth_tok_next 
2fa9			;		jp .ldouscan  
2fa9			 
2fa9			.lunotfound:		  
2fa9			 
2fa9				if DEBUG_FORTH_WORDS 
2fa9					DMARK "LSn" 
2fa9 f5				push af  
2faa 3a be 2f			ld a, (.dmark)  
2fad 32 a6 fd			ld (debug_mark),a  
2fb0 3a bf 2f			ld a, (.dmark+1)  
2fb3 32 a7 fd			ld (debug_mark+1),a  
2fb6 3a c0 2f			ld a, (.dmark+2)  
2fb9 32 a8 fd			ld (debug_mark+2),a  
2fbc 18 03			jr .pastdmark  
2fbe ..			.dmark: db "LSn"  
2fc1 f1			.pastdmark: pop af  
2fc2			endm  
# End of macro DMARK
2fc2					CALLMONITOR 
2fc2 cd aa fd			call debug_vector  
2fc5				endm  
# End of macro CALLMONITOR
2fc5				endif 
2fc5			 
2fc5					 
2fc5			;		FORTH_DSP_POP 
2fc5			;		ld hl, .luno 
2fc5			 
2fc5					NEXTW			 
2fc5 c3 b0 24			jp macro_next 
2fc8				endm 
# End of macro NEXTW
2fc8			 
2fc8			.listpush: 
2fc8				if DEBUG_FORTH_WORDS 
2fc8					DMARK "LS>" 
2fc8 f5				push af  
2fc9 3a dd 2f			ld a, (.dmark)  
2fcc 32 a6 fd			ld (debug_mark),a  
2fcf 3a de 2f			ld a, (.dmark+1)  
2fd2 32 a7 fd			ld (debug_mark+1),a  
2fd5 3a df 2f			ld a, (.dmark+2)  
2fd8 32 a8 fd			ld (debug_mark+2),a  
2fdb 18 03			jr .pastdmark  
2fdd ..			.dmark: db "LS>"  
2fe0 f1			.pastdmark: pop af  
2fe1			endm  
# End of macro DMARK
2fe1					CALLMONITOR 
2fe1 cd aa fd			call debug_vector  
2fe4				endm  
# End of macro CALLMONITOR
2fe4				endif 
2fe4 cd 71 21				call forth_push_str 
2fe7			 
2fe7			 
2fe7			 
2fe7					NEXTW 
2fe7 c3 b0 24			jp macro_next 
2fea				endm 
# End of macro NEXTW
2fea			 
2fea			;.luno:    db "Word not found",0 
2fea			 
2fea			 
2fea			 
2fea			 
2fea			 
2fea			;		push hl   ; save pointer to start of uword def string 
2fea			; 
2fea			;; look for FORTH_EOL_LINE 
2fea			;		ld a, FORTH_END_BUFFER 
2fea			;		call strlent 
2fea			; 
2fea			;		inc hl		 ; space for coln def 
2fea			;		inc hl 
2fea			;		inc hl          ; space for terms 
2fea			;		inc hl 
2fea			; 
2fea			;		ld a, 20   ; TODO get actual length 
2fea			;		call addatohl    ; include a random amount of room for the uword name 
2fea			; 
2fea			;		 
2fea			;	if DEBUG_FORTH_WORDS 
2fea			;		DMARK "Lt1" 
2fea			;		CALLMONITOR 
2fea			;	endif 
2fea			;		 
2fea			; 
2fea			;; malloc space for the string because we cant change it 
2fea			; 
2fea			;		call malloc 
2fea			;	if DEBUG_FORTH_MALLOC_GUARD 
2fea			;		push af 
2fea			;		call ishlzero 
2fea			;		pop af 
2fea			;		 
2fea			;		call z,malloc_error 
2fea			;	endif 
2fea			; 
2fea			;	if DEBUG_FORTH_WORDS 
2fea			;		DMARK "Lt2" 
2fea			;		CALLMONITOR 
2fea			;	endif 
2fea			;		pop de 
2fea			;		push hl    ; push the malloc to release later 
2fea			;		push hl   ;  push back a copy for the later stack push 
2fea			;		 
2fea			;; copy the string swapping out the zero terms for spaces 
2fea			; 
2fea			;		; de has our source 
2fea			;		; hl has our dest 
2fea			; 
2fea			;; add the coln def 
2fea			; 
2fea			;		ld a, ':' 
2fea			;		ld (hl), a 
2fea			;		inc hl 
2fea			;		ld a, ' ' 
2fea			;		ld (hl), a 
2fea			;		inc hl 
2fea			; 
2fea			;; add the uname word 
2fea			;		push de   ; save our string for now 
2fea			;		ex de, hl 
2fea			; 
2fea			;		FORTH_DSP_VALUE 
2fea			;		;v5 FORTH_DSP_VALUE 
2fea			; 
2fea			;		inc hl   ; skip type but we know by now this is OK 
2fea			; 
2fea			;.luword:	ld a,(hl) 
2fea			;		cp 0 
2fea			;		jr z, .luword2 
2fea			;		ld (de), a 
2fea			;		inc de 
2fea			;		inc hl 
2fea			;		jr .luword 
2fea			; 
2fea			;.luword2:	ld a, ' ' 
2fea			;		ld (de), a 
2fea			;;		inc hl 
2fea			;;		inc de 
2fea			;;		ld (de), a 
2fea			;;		inc hl 
2fea			;		inc de 
2fea			; 
2fea			;		ex de, hl 
2fea			;		pop de 
2fea			;		 
2fea			;		 
2fea			; 
2fea			;; detoken that string and copy it 
2fea			; 
2fea			;	if DEBUG_FORTH_WORDS 
2fea			;		DMARK "Lt2" 
2fea			;		CALLMONITOR 
2fea			;	endif 
2fea			;.ldetok:	ld a, (de) 
2fea			;		cp FORTH_END_BUFFER 
2fea			;		jr z, .ldetokend 
2fea			;		; swap out any zero term for space 
2fea			;		cp 0 
2fea			;		jr nz, .ldetoknext 
2fea			;		ld a, ' ' 
2fea			; 
2fea			;	if DEBUG_FORTH_WORDS 
2fea			;		DMARK "LtS" 
2fea			;		CALLMONITOR 
2fea			;	endif 
2fea			;.ldetoknext:	ld (hl), a 
2fea			;		inc de 
2fea			;		inc hl 
2fea			;		jr .ldetok 
2fea			; 
2fea			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2fea			;		ld (hl), a  
2fea			; 
2fea			;; free that temp malloc 
2fea			; 
2fea			;		pop hl    
2fea			; 
2fea			;	if DEBUG_FORTH_WORDS 
2fea			;		DMARK "Lt4" 
2fea			;		CALLMONITOR 
2fea			;	endif 
2fea			;		call forth_apushstrhl 
2fea			; 
2fea			;		; get rid of temp malloc area 
2fea			; 
2fea			;		pop hl 
2fea			;		call free 
2fea			; 
2fea			;		jr .ludone 
2fea			; 
2fea			;.lnuword:	pop hl 
2fea			;		call forth_tok_next 
2fea			;		jp .ldouscan  
2fea			; 
2fea			;.ludone:		 pop hl 
2fea			; 
2fea					NEXTW 
2fea c3 b0 24			jp macro_next 
2fed				endm 
# End of macro NEXTW
2fed			 
2fed			.FORGET: 
2fed				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2fed 5d				db WORD_SYS_CORE+73             
2fee 66 30			dw .NOP            
2ff0 07				db 6 + 1 
2ff1 .. 00			db "FORGET",0              
2ff8				endm 
# End of macro CWHEAD
2ff8			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2ff8			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2ff8			; | |  
2ff8			; | | e.g. "MORE" forget 
2ff8					if DEBUG_FORTH_WORDS_KEY 
2ff8						DMARK "FRG" 
2ff8 f5				push af  
2ff9 3a 0d 30			ld a, (.dmark)  
2ffc 32 a6 fd			ld (debug_mark),a  
2fff 3a 0e 30			ld a, (.dmark+1)  
3002 32 a7 fd			ld (debug_mark+1),a  
3005 3a 0f 30			ld a, (.dmark+2)  
3008 32 a8 fd			ld (debug_mark+2),a  
300b 18 03			jr .pastdmark  
300d ..			.dmark: db "FRG"  
3010 f1			.pastdmark: pop af  
3011			endm  
# End of macro DMARK
3011						CALLMONITOR 
3011 cd aa fd			call debug_vector  
3014				endm  
# End of macro CALLMONITOR
3014					endif 
3014			 
3014				; find uword 
3014			        ; update start of word with "_" 
3014				; replace uword with deleted flag 
3014			 
3014			 
3014			;	if DEBUG_FORTH_WORDS 
3014			;		DMARK "FOG" 
3014			;		CALLMONITOR 
3014			;	endif 
3014			 
3014			 
3014					; Get ptr to the word we need to look up 
3014			 
3014					FORTH_DSP_VALUEHL 
3014 cd fa 22			call macro_dsp_valuehl 
3017				endm 
# End of macro FORTH_DSP_VALUEHL
3017					;v5 FORTH_DSP_VALUE 
3017				; TODO type check 
3017			;		inc hl    ; Skip type check  
3017 e5					push hl 
3018 c1					pop bc 
3019			;		ex de, hl    ; put into DE 
3019			 
3019			 
3019 21 00 80				ld hl, baseram 
301c					;ld hl, baseusermem 
301c			 
301c				; skip dict stub 
301c			;	call forth_tok_next 
301c e5			push hl   ; sacreifical push 
301d			 
301d			.fldouscanm: 
301d e1				pop hl 
301e			.fldouscan: 
301e			;	if DEBUG_FORTH_WORDS 
301e			;		DMARK "LSs" 
301e			;		CALLMONITOR 
301e			;	endif 
301e				; skip dict stub 
301e cd 01 26				call forth_tok_next 
3021			 
3021			 
3021			; while we have words to look for 
3021			 
3021 7e				ld a, (hl)      
3022			;	if DEBUG_FORTH_WORDS 
3022			;		DMARK "LSk" 
3022			;		CALLMONITOR 
3022			;	endif 
3022 fe 00				cp WORD_SYS_END 
3024 ca 60 30				jp z, .flunotfound 
3027 fe 01				cp WORD_SYS_UWORD 
3029 c2 1e 30				jp nz, .fldouscan 
302c			 
302c			;	if DEBUG_FORTH_WORDS 
302c			;		DMARK "LSu" 
302c			;		CALLMONITOR 
302c			;	endif 
302c			 
302c					; found a uword but is it the one we want... 
302c			 
302c c5					push bc     ; uword to find is on bc 
302d d1					pop de 
302e			 
302e e5					push hl  ; to save the ptr 
302f			 
302f					; skip opcode 
302f 23					inc hl  
3030					; skip next ptr 
3030 23					inc hl  
3031 23					inc hl 
3032					; skip len 
3032 23					inc hl 
3033			 
3033			;	if DEBUG_FORTH_WORDS 
3033			;		DMARK "LSc" 
3033			;		CALLMONITOR 
3033			;	endif 
3033 cd 65 14				call strcmp 
3036 c2 1d 30				jp nz, .fldouscanm 
3039			; 
3039			; 
3039			;; while we have words to look for 
3039			; 
3039			;.fdouscan:	ld a, (hl)      
3039			;	if DEBUG_FORTH_WORDS 
3039			;		DMARK "LSs" 
3039			;		CALLMONITOR 
3039			;	endif 
3039			;		cp WORD_SYS_END 
3039			;		jp z, .fudone 
3039			;		cp WORD_SYS_UWORD 
3039			;		jp nz, .fnuword 
3039			; 
3039			;	if DEBUG_FORTH_WORDS 
3039			;		DMARK "FGu" 
3039			;		CALLMONITOR 
3039			;	endif 
3039			; 
3039			;		; found a uword but is it the one we want... 
3039			; 
3039			; 
3039			;	        pop de   ; get back the dsp name 
3039			;		push de 
3039			; 
3039			;		push hl  ; to save the ptr 
3039			; 
3039			;		; skip opcode 
3039			;		inc hl  
3039			;		; skip next ptr 
3039			;		inc hl  
3039			;		inc hl 
3039			;		; skip len 
3039			;		inc hl 
3039			; 
3039			;	if DEBUG_FORTH_WORDS 
3039			;		DMARK "FGc" 
3039			;		CALLMONITOR 
3039			;	endif 
3039			;		call strcmp 
3039			;		jp nz, .fnuword 
3039			 
3039			 
3039 e1			pop hl 
303a			 
303a				 
303a				if DEBUG_FORTH_WORDS 
303a					DMARK "FGm" 
303a f5				push af  
303b 3a 4f 30			ld a, (.dmark)  
303e 32 a6 fd			ld (debug_mark),a  
3041 3a 50 30			ld a, (.dmark+1)  
3044 32 a7 fd			ld (debug_mark+1),a  
3047 3a 51 30			ld a, (.dmark+2)  
304a 32 a8 fd			ld (debug_mark+2),a  
304d 18 03			jr .pastdmark  
304f ..			.dmark: db "FGm"  
3052 f1			.pastdmark: pop af  
3053			endm  
# End of macro DMARK
3053					CALLMONITOR 
3053 cd aa fd			call debug_vector  
3056				endm  
# End of macro CALLMONITOR
3056				endif 
3056			 
3056			 
3056			 
3056					; we have a uword so push its name to the stack 
3056			 
3056			;	   	push hl  ; save so we can move to next dict block 
3056			;pop hl 
3056			 
3056					; update opcode to deleted 
3056 3e 03				ld a, WORD_SYS_DELETED 
3058 77					ld (hl), a 
3059			 
3059 23					inc hl  
305a					; skip next ptr 
305a 23					inc hl  
305b 23					inc hl 
305c					; skip len 
305c 23					inc hl 
305d			 
305d					; TODO change parser to skip deleted words but for now mark it out 
305d 3e 5f				ld a, "_" 
305f 77					ld  (hl),a 
3060			 
3060			;		jr .fudone 
3060			; 
3060			;.fnuword:	pop hl 
3060			;		call forth_tok_next 
3060			;		jp .fdouscan  
3060			 
3060			.flunotfound:		  
3060			 
3060			 
3060					 
3060					FORTH_DSP_POP 
3060 cd b2 23			call macro_forth_dsp_pop 
3063				endm 
# End of macro FORTH_DSP_POP
3063			;		ld hl, .luno 
3063			;.fudone:		 pop hl 
3063					NEXTW 
3063 c3 b0 24			jp macro_next 
3066				endm 
# End of macro NEXTW
3066			.NOP: 
3066				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
3066 61				db WORD_SYS_CORE+77             
3067 8d 30			dw .COMO            
3069 04				db 3 + 1 
306a .. 00			db "NOP",0              
306e				endm 
# End of macro CWHEAD
306e			; | NOP (  --  ) Do nothing | DONE 
306e					if DEBUG_FORTH_WORDS_KEY 
306e						DMARK "NOP" 
306e f5				push af  
306f 3a 83 30			ld a, (.dmark)  
3072 32 a6 fd			ld (debug_mark),a  
3075 3a 84 30			ld a, (.dmark+1)  
3078 32 a7 fd			ld (debug_mark+1),a  
307b 3a 85 30			ld a, (.dmark+2)  
307e 32 a8 fd			ld (debug_mark+2),a  
3081 18 03			jr .pastdmark  
3083 ..			.dmark: db "NOP"  
3086 f1			.pastdmark: pop af  
3087			endm  
# End of macro DMARK
3087						CALLMONITOR 
3087 cd aa fd			call debug_vector  
308a				endm  
# End of macro CALLMONITOR
308a					endif 
308a				       NEXTW 
308a c3 b0 24			jp macro_next 
308d				endm 
# End of macro NEXTW
308d			.COMO: 
308d				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
308d 6e				db WORD_SYS_CORE+90             
308e df 30			dw .COMC            
3090 02				db 1 + 1 
3091 .. 00			db "(",0              
3093				endm 
# End of macro CWHEAD
3093			; | ( ( -- )  Start of comment | DONE 
3093			 
3093			 
3093 2a fd f3				ld hl, ( os_tok_ptr) 
3096 11 da 30			ld de, .closepar 
3099					 
3099					if DEBUG_FORTH_WORDS 
3099						DMARK ").." 
3099 f5				push af  
309a 3a ae 30			ld a, (.dmark)  
309d 32 a6 fd			ld (debug_mark),a  
30a0 3a af 30			ld a, (.dmark+1)  
30a3 32 a7 fd			ld (debug_mark+1),a  
30a6 3a b0 30			ld a, (.dmark+2)  
30a9 32 a8 fd			ld (debug_mark+2),a  
30ac 18 03			jr .pastdmark  
30ae ..			.dmark: db ").."  
30b1 f1			.pastdmark: pop af  
30b2			endm  
# End of macro DMARK
30b2						CALLMONITOR 
30b2 cd aa fd			call debug_vector  
30b5				endm  
# End of macro CALLMONITOR
30b5					endif 
30b5 cd cb 25			call findnexttok  
30b8			 
30b8					if DEBUG_FORTH_WORDS 
30b8						DMARK "IF5" 
30b8 f5				push af  
30b9 3a cd 30			ld a, (.dmark)  
30bc 32 a6 fd			ld (debug_mark),a  
30bf 3a ce 30			ld a, (.dmark+1)  
30c2 32 a7 fd			ld (debug_mark+1),a  
30c5 3a cf 30			ld a, (.dmark+2)  
30c8 32 a8 fd			ld (debug_mark+2),a  
30cb 18 03			jr .pastdmark  
30cd ..			.dmark: db "IF5"  
30d0 f1			.pastdmark: pop af  
30d1			endm  
# End of macro DMARK
30d1						CALLMONITOR 
30d1 cd aa fd			call debug_vector  
30d4				endm  
# End of macro CALLMONITOR
30d4					endif 
30d4				; replace below with ) exec using tok_ptr 
30d4 22 fd f3			ld (os_tok_ptr), hl 
30d7 c3 41 25			jp exec1 
30da			 
30da .. 00			.closepar:   db ")",0 
30dc			 
30dc				       NEXTW 
30dc c3 b0 24			jp macro_next 
30df				endm 
# End of macro NEXTW
30df			.COMC: 
30df				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
30df 6f				db WORD_SYS_CORE+91             
30e0 e8 30			dw .SCRATCH            
30e2 02				db 1 + 1 
30e3 .. 00			db ")",0              
30e5				endm 
# End of macro CWHEAD
30e5			; | ) ( -- )  End of comment |  DONE  
30e5				       NEXTW 
30e5 c3 b0 24			jp macro_next 
30e8				endm 
# End of macro NEXTW
30e8			 
30e8			.SCRATCH: 
30e8				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
30e8 6f				db WORD_SYS_CORE+91             
30e9 23 31			dw .INC            
30eb 08				db 7 + 1 
30ec .. 00			db "SCRATCH",0              
30f4				endm 
# End of macro CWHEAD
30f4			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
30f4			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
30f4			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
30f4			; | |  
30f4			; | | e.g.    : score $00 scratch ; 
30f4			; | |  
30f4			; | | $00 score ! 
30f4			; | | $01 score +! 
30f4			; | |  
30f4			; | | e.g.   : varword $0a scratch ;  
30f4			; | | 
30f4			; | | $8000 varword ! 
30f4					if DEBUG_FORTH_WORDS_KEY 
30f4						DMARK "SCR" 
30f4 f5				push af  
30f5 3a 09 31			ld a, (.dmark)  
30f8 32 a6 fd			ld (debug_mark),a  
30fb 3a 0a 31			ld a, (.dmark+1)  
30fe 32 a7 fd			ld (debug_mark+1),a  
3101 3a 0b 31			ld a, (.dmark+2)  
3104 32 a8 fd			ld (debug_mark+2),a  
3107 18 03			jr .pastdmark  
3109 ..			.dmark: db "SCR"  
310c f1			.pastdmark: pop af  
310d			endm  
# End of macro DMARK
310d						CALLMONITOR 
310d cd aa fd			call debug_vector  
3110				endm  
# End of macro CALLMONITOR
3110					endif 
3110			 
3110					FORTH_DSP_VALUEHL 
3110 cd fa 22			call macro_dsp_valuehl 
3113				endm 
# End of macro FORTH_DSP_VALUEHL
3113				 
3113					FORTH_DSP_POP 
3113 cd b2 23			call macro_forth_dsp_pop 
3116				endm 
# End of macro FORTH_DSP_POP
3116			 
3116 7d					ld a, l 
3117 21 21 f6				ld hl, os_var_array 
311a cd cf 0f				call addatohl 
311d			 
311d cd 03 21				call forth_push_numhl 
3120			 
3120				       NEXTW 
3120 c3 b0 24			jp macro_next 
3123				endm 
# End of macro NEXTW
3123			 
3123			.INC: 
3123				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
3123 6f				db WORD_SYS_CORE+91             
3124 79 31			dw .DEC            
3126 03				db 2 + 1 
3127 .. 00			db "+!",0              
312a				endm 
# End of macro CWHEAD
312a			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
312a					if DEBUG_FORTH_WORDS_KEY 
312a						DMARK "+s_" 
312a f5				push af  
312b 3a 3f 31			ld a, (.dmark)  
312e 32 a6 fd			ld (debug_mark),a  
3131 3a 40 31			ld a, (.dmark+1)  
3134 32 a7 fd			ld (debug_mark+1),a  
3137 3a 41 31			ld a, (.dmark+2)  
313a 32 a8 fd			ld (debug_mark+2),a  
313d 18 03			jr .pastdmark  
313f ..			.dmark: db "+s_"  
3142 f1			.pastdmark: pop af  
3143			endm  
# End of macro DMARK
3143						CALLMONITOR 
3143 cd aa fd			call debug_vector  
3146				endm  
# End of macro CALLMONITOR
3146					endif 
3146			 
3146					FORTH_DSP_VALUEHL 
3146 cd fa 22			call macro_dsp_valuehl 
3149				endm 
# End of macro FORTH_DSP_VALUEHL
3149			 
3149 e5					push hl   ; save address 
314a			 
314a					FORTH_DSP_POP 
314a cd b2 23			call macro_forth_dsp_pop 
314d				endm 
# End of macro FORTH_DSP_POP
314d			 
314d					FORTH_DSP_VALUEHL 
314d cd fa 22			call macro_dsp_valuehl 
3150				endm 
# End of macro FORTH_DSP_VALUEHL
3150			 
3150 e5					push hl 
3151					FORTH_DSP_POP 
3151 cd b2 23			call macro_forth_dsp_pop 
3154				endm 
# End of macro FORTH_DSP_POP
3154 e1					pop hl 
3155			 
3155					; hl contains value to add to byte at a 
3155				 
3155 eb					ex de, hl 
3156			 
3156 e1					pop hl 
3157			 
3157					if DEBUG_FORTH_WORDS 
3157						DMARK "INC" 
3157 f5				push af  
3158 3a 6c 31			ld a, (.dmark)  
315b 32 a6 fd			ld (debug_mark),a  
315e 3a 6d 31			ld a, (.dmark+1)  
3161 32 a7 fd			ld (debug_mark+1),a  
3164 3a 6e 31			ld a, (.dmark+2)  
3167 32 a8 fd			ld (debug_mark+2),a  
316a 18 03			jr .pastdmark  
316c ..			.dmark: db "INC"  
316f f1			.pastdmark: pop af  
3170			endm  
# End of macro DMARK
3170						CALLMONITOR 
3170 cd aa fd			call debug_vector  
3173				endm  
# End of macro CALLMONITOR
3173					endif 
3173			 
3173 7e					ld a,(hl) 
3174 83					add e 
3175 77					ld (hl),a 
3176			 
3176			 
3176			 
3176				       NEXTW 
3176 c3 b0 24			jp macro_next 
3179				endm 
# End of macro NEXTW
3179			 
3179			.DEC: 
3179				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
3179 6f				db WORD_SYS_CORE+91             
317a cd 31			dw .INC2            
317c 03				db 2 + 1 
317d .. 00			db "-!",0              
3180				endm 
# End of macro CWHEAD
3180			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
3180					if DEBUG_FORTH_WORDS_KEY 
3180						DMARK "-s_" 
3180 f5				push af  
3181 3a 95 31			ld a, (.dmark)  
3184 32 a6 fd			ld (debug_mark),a  
3187 3a 96 31			ld a, (.dmark+1)  
318a 32 a7 fd			ld (debug_mark+1),a  
318d 3a 97 31			ld a, (.dmark+2)  
3190 32 a8 fd			ld (debug_mark+2),a  
3193 18 03			jr .pastdmark  
3195 ..			.dmark: db "-s_"  
3198 f1			.pastdmark: pop af  
3199			endm  
# End of macro DMARK
3199						CALLMONITOR 
3199 cd aa fd			call debug_vector  
319c				endm  
# End of macro CALLMONITOR
319c					endif 
319c			 
319c					FORTH_DSP_VALUEHL 
319c cd fa 22			call macro_dsp_valuehl 
319f				endm 
# End of macro FORTH_DSP_VALUEHL
319f			 
319f e5					push hl   ; save address 
31a0			 
31a0					FORTH_DSP_POP 
31a0 cd b2 23			call macro_forth_dsp_pop 
31a3				endm 
# End of macro FORTH_DSP_POP
31a3			 
31a3					FORTH_DSP_VALUEHL 
31a3 cd fa 22			call macro_dsp_valuehl 
31a6				endm 
# End of macro FORTH_DSP_VALUEHL
31a6			 
31a6					; hl contains value to add to byte at a 
31a6				 
31a6 eb					ex de, hl 
31a7			 
31a7 e1					pop hl 
31a8			 
31a8					if DEBUG_FORTH_WORDS 
31a8						DMARK "DEC" 
31a8 f5				push af  
31a9 3a bd 31			ld a, (.dmark)  
31ac 32 a6 fd			ld (debug_mark),a  
31af 3a be 31			ld a, (.dmark+1)  
31b2 32 a7 fd			ld (debug_mark+1),a  
31b5 3a bf 31			ld a, (.dmark+2)  
31b8 32 a8 fd			ld (debug_mark+2),a  
31bb 18 03			jr .pastdmark  
31bd ..			.dmark: db "DEC"  
31c0 f1			.pastdmark: pop af  
31c1			endm  
# End of macro DMARK
31c1						CALLMONITOR 
31c1 cd aa fd			call debug_vector  
31c4				endm  
# End of macro CALLMONITOR
31c4					endif 
31c4			 
31c4 7e					ld a,(hl) 
31c5 93					sub e 
31c6 77					ld (hl),a 
31c7			 
31c7			 
31c7					FORTH_DSP_POP 
31c7 cd b2 23			call macro_forth_dsp_pop 
31ca				endm 
# End of macro FORTH_DSP_POP
31ca			 
31ca				       NEXTW 
31ca c3 b0 24			jp macro_next 
31cd				endm 
# End of macro NEXTW
31cd			 
31cd			.INC2: 
31cd				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
31cd 6f				db WORD_SYS_CORE+91             
31ce 7a 32			dw .DEC2            
31d0 04				db 3 + 1 
31d1 .. 00			db "+2!",0              
31d5				endm 
# End of macro CWHEAD
31d5			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
31d5			 
31d5					if DEBUG_FORTH_WORDS_KEY 
31d5						DMARK "+2s" 
31d5 f5				push af  
31d6 3a ea 31			ld a, (.dmark)  
31d9 32 a6 fd			ld (debug_mark),a  
31dc 3a eb 31			ld a, (.dmark+1)  
31df 32 a7 fd			ld (debug_mark+1),a  
31e2 3a ec 31			ld a, (.dmark+2)  
31e5 32 a8 fd			ld (debug_mark+2),a  
31e8 18 03			jr .pastdmark  
31ea ..			.dmark: db "+2s"  
31ed f1			.pastdmark: pop af  
31ee			endm  
# End of macro DMARK
31ee						CALLMONITOR 
31ee cd aa fd			call debug_vector  
31f1				endm  
# End of macro CALLMONITOR
31f1					endif 
31f1			 
31f1					; Address 
31f1			 
31f1					FORTH_DSP_VALUEHL 
31f1 cd fa 22			call macro_dsp_valuehl 
31f4				endm 
# End of macro FORTH_DSP_VALUEHL
31f4			 
31f4 e5					push hl    ; save address 
31f5			 
31f5					; load content into de 
31f5			 
31f5 5e					ld e,(hl) 
31f6 23					inc hl 
31f7 56					ld d, (hl) 
31f8			 
31f8					if DEBUG_FORTH_WORDS 
31f8						DMARK "+2a" 
31f8 f5				push af  
31f9 3a 0d 32			ld a, (.dmark)  
31fc 32 a6 fd			ld (debug_mark),a  
31ff 3a 0e 32			ld a, (.dmark+1)  
3202 32 a7 fd			ld (debug_mark+1),a  
3205 3a 0f 32			ld a, (.dmark+2)  
3208 32 a8 fd			ld (debug_mark+2),a  
320b 18 03			jr .pastdmark  
320d ..			.dmark: db "+2a"  
3210 f1			.pastdmark: pop af  
3211			endm  
# End of macro DMARK
3211						CALLMONITOR 
3211 cd aa fd			call debug_vector  
3214				endm  
# End of macro CALLMONITOR
3214					endif 
3214			 
3214					FORTH_DSP_POP 
3214 cd b2 23			call macro_forth_dsp_pop 
3217				endm 
# End of macro FORTH_DSP_POP
3217			 
3217					; Get value to add 
3217			 
3217					FORTH_DSP_VALUE 
3217 cd e3 22			call macro_forth_dsp_value 
321a				endm 
# End of macro FORTH_DSP_VALUE
321a			 
321a					if DEBUG_FORTH_WORDS 
321a						DMARK "+2v" 
321a f5				push af  
321b 3a 2f 32			ld a, (.dmark)  
321e 32 a6 fd			ld (debug_mark),a  
3221 3a 30 32			ld a, (.dmark+1)  
3224 32 a7 fd			ld (debug_mark+1),a  
3227 3a 31 32			ld a, (.dmark+2)  
322a 32 a8 fd			ld (debug_mark+2),a  
322d 18 03			jr .pastdmark  
322f ..			.dmark: db "+2v"  
3232 f1			.pastdmark: pop af  
3233			endm  
# End of macro DMARK
3233						CALLMONITOR 
3233 cd aa fd			call debug_vector  
3236				endm  
# End of macro CALLMONITOR
3236					endif 
3236			 
3236 19					add hl, de 
3237			 
3237					if DEBUG_FORTH_WORDS 
3237						DMARK "+2+" 
3237 f5				push af  
3238 3a 4c 32			ld a, (.dmark)  
323b 32 a6 fd			ld (debug_mark),a  
323e 3a 4d 32			ld a, (.dmark+1)  
3241 32 a7 fd			ld (debug_mark+1),a  
3244 3a 4e 32			ld a, (.dmark+2)  
3247 32 a8 fd			ld (debug_mark+2),a  
324a 18 03			jr .pastdmark  
324c ..			.dmark: db "+2+"  
324f f1			.pastdmark: pop af  
3250			endm  
# End of macro DMARK
3250						CALLMONITOR 
3250 cd aa fd			call debug_vector  
3253				endm  
# End of macro CALLMONITOR
3253					endif 
3253			 
3253					; move result to de 
3253			 
3253 eb					ex de, hl 
3254			 
3254					; Address 
3254			 
3254 e1					pop hl 
3255			 
3255					; save it back 
3255			 
3255 73					ld (hl), e 
3256 23					inc hl 
3257 72					ld (hl), d 
3258			 
3258					if DEBUG_FORTH_WORDS 
3258						DMARK "+2e" 
3258 f5				push af  
3259 3a 6d 32			ld a, (.dmark)  
325c 32 a6 fd			ld (debug_mark),a  
325f 3a 6e 32			ld a, (.dmark+1)  
3262 32 a7 fd			ld (debug_mark+1),a  
3265 3a 6f 32			ld a, (.dmark+2)  
3268 32 a8 fd			ld (debug_mark+2),a  
326b 18 03			jr .pastdmark  
326d ..			.dmark: db "+2e"  
3270 f1			.pastdmark: pop af  
3271			endm  
# End of macro DMARK
3271						CALLMONITOR 
3271 cd aa fd			call debug_vector  
3274				endm  
# End of macro CALLMONITOR
3274					endif 
3274			 
3274			 
3274			 
3274					FORTH_DSP_POP 
3274 cd b2 23			call macro_forth_dsp_pop 
3277				endm 
# End of macro FORTH_DSP_POP
3277			 
3277			 
3277				       NEXTW 
3277 c3 b0 24			jp macro_next 
327a				endm 
# End of macro NEXTW
327a			 
327a			.DEC2: 
327a				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
327a 6f				db WORD_SYS_CORE+91             
327b 29 33			dw .GET2            
327d 04				db 3 + 1 
327e .. 00			db "-2!",0              
3282				endm 
# End of macro CWHEAD
3282			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
3282			 
3282			 
3282					if DEBUG_FORTH_WORDS_KEY 
3282						DMARK "-2s" 
3282 f5				push af  
3283 3a 97 32			ld a, (.dmark)  
3286 32 a6 fd			ld (debug_mark),a  
3289 3a 98 32			ld a, (.dmark+1)  
328c 32 a7 fd			ld (debug_mark+1),a  
328f 3a 99 32			ld a, (.dmark+2)  
3292 32 a8 fd			ld (debug_mark+2),a  
3295 18 03			jr .pastdmark  
3297 ..			.dmark: db "-2s"  
329a f1			.pastdmark: pop af  
329b			endm  
# End of macro DMARK
329b						CALLMONITOR 
329b cd aa fd			call debug_vector  
329e				endm  
# End of macro CALLMONITOR
329e					endif 
329e			 
329e					; Address 
329e			 
329e					FORTH_DSP_VALUEHL 
329e cd fa 22			call macro_dsp_valuehl 
32a1				endm 
# End of macro FORTH_DSP_VALUEHL
32a1			 
32a1 e5					push hl    ; save address 
32a2			 
32a2					; load content into de 
32a2			 
32a2 5e					ld e,(hl) 
32a3 23					inc hl 
32a4 56					ld d, (hl) 
32a5			 
32a5					if DEBUG_FORTH_WORDS 
32a5						DMARK "-2a" 
32a5 f5				push af  
32a6 3a ba 32			ld a, (.dmark)  
32a9 32 a6 fd			ld (debug_mark),a  
32ac 3a bb 32			ld a, (.dmark+1)  
32af 32 a7 fd			ld (debug_mark+1),a  
32b2 3a bc 32			ld a, (.dmark+2)  
32b5 32 a8 fd			ld (debug_mark+2),a  
32b8 18 03			jr .pastdmark  
32ba ..			.dmark: db "-2a"  
32bd f1			.pastdmark: pop af  
32be			endm  
# End of macro DMARK
32be						CALLMONITOR 
32be cd aa fd			call debug_vector  
32c1				endm  
# End of macro CALLMONITOR
32c1					endif 
32c1			 
32c1					FORTH_DSP_POP 
32c1 cd b2 23			call macro_forth_dsp_pop 
32c4				endm 
# End of macro FORTH_DSP_POP
32c4			 
32c4					; Get value to remove 
32c4			 
32c4					FORTH_DSP_VALUE 
32c4 cd e3 22			call macro_forth_dsp_value 
32c7				endm 
# End of macro FORTH_DSP_VALUE
32c7			 
32c7					if DEBUG_FORTH_WORDS 
32c7						DMARK "-2v" 
32c7 f5				push af  
32c8 3a dc 32			ld a, (.dmark)  
32cb 32 a6 fd			ld (debug_mark),a  
32ce 3a dd 32			ld a, (.dmark+1)  
32d1 32 a7 fd			ld (debug_mark+1),a  
32d4 3a de 32			ld a, (.dmark+2)  
32d7 32 a8 fd			ld (debug_mark+2),a  
32da 18 03			jr .pastdmark  
32dc ..			.dmark: db "-2v"  
32df f1			.pastdmark: pop af  
32e0			endm  
# End of macro DMARK
32e0						CALLMONITOR 
32e0 cd aa fd			call debug_vector  
32e3				endm  
# End of macro CALLMONITOR
32e3					endif 
32e3			 
32e3 eb					ex de, hl 
32e4 ed 52				sbc hl, de 
32e6			 
32e6					if DEBUG_FORTH_WORDS 
32e6						DMARK "-2d" 
32e6 f5				push af  
32e7 3a fb 32			ld a, (.dmark)  
32ea 32 a6 fd			ld (debug_mark),a  
32ed 3a fc 32			ld a, (.dmark+1)  
32f0 32 a7 fd			ld (debug_mark+1),a  
32f3 3a fd 32			ld a, (.dmark+2)  
32f6 32 a8 fd			ld (debug_mark+2),a  
32f9 18 03			jr .pastdmark  
32fb ..			.dmark: db "-2d"  
32fe f1			.pastdmark: pop af  
32ff			endm  
# End of macro DMARK
32ff						CALLMONITOR 
32ff cd aa fd			call debug_vector  
3302				endm  
# End of macro CALLMONITOR
3302					endif 
3302			 
3302					; move result to de 
3302			 
3302 eb					ex de, hl 
3303			 
3303					; Address 
3303			 
3303 e1					pop hl 
3304			 
3304					; save it back 
3304			 
3304 73					ld (hl), e 
3305 23					inc hl 
3306 72					ld (hl), d 
3307			 
3307					if DEBUG_FORTH_WORDS 
3307						DMARK "-2e" 
3307 f5				push af  
3308 3a 1c 33			ld a, (.dmark)  
330b 32 a6 fd			ld (debug_mark),a  
330e 3a 1d 33			ld a, (.dmark+1)  
3311 32 a7 fd			ld (debug_mark+1),a  
3314 3a 1e 33			ld a, (.dmark+2)  
3317 32 a8 fd			ld (debug_mark+2),a  
331a 18 03			jr .pastdmark  
331c ..			.dmark: db "-2e"  
331f f1			.pastdmark: pop af  
3320			endm  
# End of macro DMARK
3320						CALLMONITOR 
3320 cd aa fd			call debug_vector  
3323				endm  
# End of macro CALLMONITOR
3323					endif 
3323			 
3323			 
3323					FORTH_DSP_POP 
3323 cd b2 23			call macro_forth_dsp_pop 
3326				endm 
# End of macro FORTH_DSP_POP
3326			 
3326			 
3326			 
3326				       NEXTW 
3326 c3 b0 24			jp macro_next 
3329				endm 
# End of macro NEXTW
3329			.GET2: 
3329				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
3329 6f				db WORD_SYS_CORE+91             
332a 5e 33			dw .BANG2            
332c 03				db 2 + 1 
332d .. 00			db "2@",0              
3330				endm 
# End of macro CWHEAD
3330			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3330					if DEBUG_FORTH_WORDS_KEY 
3330						DMARK "2A_" 
3330 f5				push af  
3331 3a 45 33			ld a, (.dmark)  
3334 32 a6 fd			ld (debug_mark),a  
3337 3a 46 33			ld a, (.dmark+1)  
333a 32 a7 fd			ld (debug_mark+1),a  
333d 3a 47 33			ld a, (.dmark+2)  
3340 32 a8 fd			ld (debug_mark+2),a  
3343 18 03			jr .pastdmark  
3345 ..			.dmark: db "2A_"  
3348 f1			.pastdmark: pop af  
3349			endm  
# End of macro DMARK
3349						CALLMONITOR 
3349 cd aa fd			call debug_vector  
334c				endm  
# End of macro CALLMONITOR
334c					endif 
334c			 
334c					FORTH_DSP_VALUEHL 
334c cd fa 22			call macro_dsp_valuehl 
334f				endm 
# End of macro FORTH_DSP_VALUEHL
334f			 
334f e5					push hl   ; save address 
3350			 
3350					FORTH_DSP_POP 
3350 cd b2 23			call macro_forth_dsp_pop 
3353				endm 
# End of macro FORTH_DSP_POP
3353			 
3353 e1					pop hl 
3354			 
3354 5e					ld e, (hl) 
3355 23					inc hl 
3356 56					ld d, (hl) 
3357			 
3357 eb					ex de, hl 
3358			 
3358 cd 03 21				call forth_push_numhl 
335b			 
335b				       NEXTW 
335b c3 b0 24			jp macro_next 
335e				endm 
# End of macro NEXTW
335e			.BANG2: 
335e				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
335e 6f				db WORD_SYS_CORE+91             
335f 96 33			dw .CONFIG            
3361 03				db 2 + 1 
3362 .. 00			db "2!",0              
3365				endm 
# End of macro CWHEAD
3365			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3365					if DEBUG_FORTH_WORDS_KEY 
3365						DMARK "2S_" 
3365 f5				push af  
3366 3a 7a 33			ld a, (.dmark)  
3369 32 a6 fd			ld (debug_mark),a  
336c 3a 7b 33			ld a, (.dmark+1)  
336f 32 a7 fd			ld (debug_mark+1),a  
3372 3a 7c 33			ld a, (.dmark+2)  
3375 32 a8 fd			ld (debug_mark+2),a  
3378 18 03			jr .pastdmark  
337a ..			.dmark: db "2S_"  
337d f1			.pastdmark: pop af  
337e			endm  
# End of macro DMARK
337e						CALLMONITOR 
337e cd aa fd			call debug_vector  
3381				endm  
# End of macro CALLMONITOR
3381					endif 
3381			 
3381					FORTH_DSP_VALUEHL 
3381 cd fa 22			call macro_dsp_valuehl 
3384				endm 
# End of macro FORTH_DSP_VALUEHL
3384			 
3384 e5					push hl   ; save address 
3385			 
3385			 
3385					FORTH_DSP_POP 
3385 cd b2 23			call macro_forth_dsp_pop 
3388				endm 
# End of macro FORTH_DSP_POP
3388			 
3388					 
3388					FORTH_DSP_VALUEHL 
3388 cd fa 22			call macro_dsp_valuehl 
338b				endm 
# End of macro FORTH_DSP_VALUEHL
338b			 
338b					FORTH_DSP_POP 
338b cd b2 23			call macro_forth_dsp_pop 
338e				endm 
# End of macro FORTH_DSP_POP
338e			 
338e eb					ex de, hl    ; value now in de 
338f			 
338f e1					pop hl 
3390			 
3390 73					ld (hl), e 
3391			 
3391 23					inc hl 
3392			 
3392 72					ld (hl), d 
3393			 
3393			 
3393				       NEXTW 
3393 c3 b0 24			jp macro_next 
3396				endm 
# End of macro NEXTW
3396			.CONFIG: 
3396				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
3396 6f				db WORD_SYS_CORE+91             
3397 a7 33			dw .ADTOS            
3399 07				db 6 + 1 
339a .. 00			db "CONFIG",0              
33a1				endm 
# End of macro CWHEAD
33a1			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
33a1			 
33a1 cd 3b 16				call config 
33a4					NEXTW 
33a4 c3 b0 24			jp macro_next 
33a7				endm 
# End of macro NEXTW
33a7			 
33a7			.ADTOS: 
33a7				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
33a7 6f				db WORD_SYS_CORE+91             
33a8 bd 33			dw .SBTOS            
33aa 03				db 2 + 1 
33ab .. 00			db "1+",0              
33ae				endm 
# End of macro CWHEAD
33ae			; | 1+ ( u -- u )  Increment value on TOS | DONE 
33ae			 
33ae					FORTH_DSP_VALUEHL 
33ae cd fa 22			call macro_dsp_valuehl 
33b1				endm 
# End of macro FORTH_DSP_VALUEHL
33b1 e5					push hl 
33b2			 
33b2					FORTH_DSP_POP 
33b2 cd b2 23			call macro_forth_dsp_pop 
33b5				endm 
# End of macro FORTH_DSP_POP
33b5 e1					pop hl 
33b6			 
33b6 23					inc hl 
33b7 cd 03 21				call forth_push_numhl 
33ba					 
33ba					NEXTW 
33ba c3 b0 24			jp macro_next 
33bd				endm 
# End of macro NEXTW
33bd			.SBTOS: 
33bd				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
33bd 6f				db WORD_SYS_CORE+91             
33be d3 33			dw .ADSTORE            
33c0 03				db 2 + 1 
33c1 .. 00			db "1-",0              
33c4				endm 
# End of macro CWHEAD
33c4			; | 1- ( u -- u )  Decrement value on TOS | DONE 
33c4			 
33c4					FORTH_DSP_VALUEHL 
33c4 cd fa 22			call macro_dsp_valuehl 
33c7				endm 
# End of macro FORTH_DSP_VALUEHL
33c7 e5					push hl 
33c8			 
33c8					FORTH_DSP_POP 
33c8 cd b2 23			call macro_forth_dsp_pop 
33cb				endm 
# End of macro FORTH_DSP_POP
33cb e1					pop hl 
33cc			 
33cc 2b					dec hl 
33cd cd 03 21				call forth_push_numhl 
33d0					 
33d0					NEXTW 
33d0 c3 b0 24			jp macro_next 
33d3				endm 
# End of macro NEXTW
33d3			.ADSTORE: 
33d3				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
33d3 6f				db WORD_SYS_CORE+91             
33d4 e9 33			dw .ADWSTORE            
33d6 04				db 3 + 1 
33d7 .. 00			db "1+!",0              
33db				endm 
# End of macro CWHEAD
33db			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
33db			 
33db					FORTH_DSP_VALUEHL 
33db cd fa 22			call macro_dsp_valuehl 
33de				endm 
# End of macro FORTH_DSP_VALUEHL
33de e5					push hl 
33df			 
33df					FORTH_DSP_POP 
33df cd b2 23			call macro_forth_dsp_pop 
33e2				endm 
# End of macro FORTH_DSP_POP
33e2 e1					pop hl 
33e3			 
33e3 7e					ld a, (hl) 
33e4 3c					inc a 
33e5 77					ld (hl), a 
33e6					 
33e6					NEXTW 
33e6 c3 b0 24			jp macro_next 
33e9				endm 
# End of macro NEXTW
33e9			.ADWSTORE: 
33e9				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
33e9 6f				db WORD_SYS_CORE+91             
33ea 07 34			dw .SBSTORE            
33ec 05				db 4 + 1 
33ed .. 00			db "1+2!",0              
33f2				endm 
# End of macro CWHEAD
33f2			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
33f2			 
33f2					FORTH_DSP_VALUEHL 
33f2 cd fa 22			call macro_dsp_valuehl 
33f5				endm 
# End of macro FORTH_DSP_VALUEHL
33f5 e5					push hl 
33f6			 
33f6					FORTH_DSP_POP 
33f6 cd b2 23			call macro_forth_dsp_pop 
33f9				endm 
# End of macro FORTH_DSP_POP
33f9 e1					pop hl 
33fa			 
33fa e5					push hl 
33fb			 
33fb cd 32 24				call loadwordinhl 
33fe 23					inc hl 
33ff			 
33ff d1					pop de 
3400 eb					ex de, hl 
3401 73					ld (hl), e 
3402 23					inc hl 
3403 72					ld (hl), d 
3404					 
3404					NEXTW 
3404 c3 b0 24			jp macro_next 
3407				endm 
# End of macro NEXTW
3407			.SBSTORE: 
3407				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
3407 6f				db WORD_SYS_CORE+91             
3408 1d 34			dw .SBWSTORE            
340a 04				db 3 + 1 
340b .. 00			db "1-!",0              
340f				endm 
# End of macro CWHEAD
340f			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
340f			 
340f					FORTH_DSP_VALUEHL 
340f cd fa 22			call macro_dsp_valuehl 
3412				endm 
# End of macro FORTH_DSP_VALUEHL
3412 e5					push hl 
3413			 
3413					FORTH_DSP_POP 
3413 cd b2 23			call macro_forth_dsp_pop 
3416				endm 
# End of macro FORTH_DSP_POP
3416 e1					pop hl 
3417			 
3417 7e					ld a, (hl) 
3418 3d					dec a 
3419 77					ld (hl), a 
341a					 
341a					NEXTW 
341a c3 b0 24			jp macro_next 
341d				endm 
# End of macro NEXTW
341d			.SBWSTORE: 
341d				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
341d 6f				db WORD_SYS_CORE+91             
341e 3b 34			dw .ENDCORE            
3420 05				db 4 + 1 
3421 .. 00			db "1-2!",0              
3426				endm 
# End of macro CWHEAD
3426			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
3426			 
3426					FORTH_DSP_VALUEHL 
3426 cd fa 22			call macro_dsp_valuehl 
3429				endm 
# End of macro FORTH_DSP_VALUEHL
3429 e5					push hl 
342a			 
342a					FORTH_DSP_POP 
342a cd b2 23			call macro_forth_dsp_pop 
342d				endm 
# End of macro FORTH_DSP_POP
342d e1					pop hl 
342e			 
342e e5					push hl 
342f			 
342f cd 32 24				call loadwordinhl 
3432 2b					dec hl 
3433			 
3433 d1					pop de 
3434 eb					ex de, hl 
3435 73					ld (hl), e 
3436 23					inc hl 
3437 72					ld (hl), d 
3438					 
3438					NEXTW 
3438 c3 b0 24			jp macro_next 
343b				endm 
# End of macro NEXTW
343b			.ENDCORE: 
343b			 
343b			; eof 
343b			 
343b			 
# End of file forth_words_core.asm
343b			include "forth_words_flow.asm" 
343b			 
343b			; | ## Program Flow Words 
343b			 
343b			.IF: 
343b				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
343b 1e				db WORD_SYS_CORE+10             
343c 30 35			dw .THEN            
343e 03				db 2 + 1 
343f .. 00			db "IF",0              
3442				endm 
# End of macro CWHEAD
3442			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
3442			; 
3442					if DEBUG_FORTH_WORDS_KEY 
3442						DMARK "IF." 
3442 f5				push af  
3443 3a 57 34			ld a, (.dmark)  
3446 32 a6 fd			ld (debug_mark),a  
3449 3a 58 34			ld a, (.dmark+1)  
344c 32 a7 fd			ld (debug_mark+1),a  
344f 3a 59 34			ld a, (.dmark+2)  
3452 32 a8 fd			ld (debug_mark+2),a  
3455 18 03			jr .pastdmark  
3457 ..			.dmark: db "IF."  
345a f1			.pastdmark: pop af  
345b			endm  
# End of macro DMARK
345b						CALLMONITOR 
345b cd aa fd			call debug_vector  
345e				endm  
# End of macro CALLMONITOR
345e					endif 
345e			; eval TOS 
345e			 
345e				FORTH_DSP_VALUEHL 
345e cd fa 22			call macro_dsp_valuehl 
3461				endm 
# End of macro FORTH_DSP_VALUEHL
3461			 
3461			;	push hl 
3461				FORTH_DSP_POP 
3461 cd b2 23			call macro_forth_dsp_pop 
3464				endm 
# End of macro FORTH_DSP_POP
3464			;	pop hl 
3464			 
3464					if DEBUG_FORTH_WORDS 
3464						DMARK "IF1" 
3464 f5				push af  
3465 3a 79 34			ld a, (.dmark)  
3468 32 a6 fd			ld (debug_mark),a  
346b 3a 7a 34			ld a, (.dmark+1)  
346e 32 a7 fd			ld (debug_mark+1),a  
3471 3a 7b 34			ld a, (.dmark+2)  
3474 32 a8 fd			ld (debug_mark+2),a  
3477 18 03			jr .pastdmark  
3479 ..			.dmark: db "IF1"  
347c f1			.pastdmark: pop af  
347d			endm  
# End of macro DMARK
347d						CALLMONITOR 
347d cd aa fd			call debug_vector  
3480				endm  
# End of macro CALLMONITOR
3480					endif 
3480 b7				or a        ; clear carry flag 
3481 11 00 00			ld de, 0 
3484 eb				ex de,hl 
3485 ed 52			sbc hl, de 
3487 c2 11 35			jp nz, .iftrue 
348a			 
348a					if DEBUG_FORTH_WORDS 
348a						DMARK "IF2" 
348a f5				push af  
348b 3a 9f 34			ld a, (.dmark)  
348e 32 a6 fd			ld (debug_mark),a  
3491 3a a0 34			ld a, (.dmark+1)  
3494 32 a7 fd			ld (debug_mark+1),a  
3497 3a a1 34			ld a, (.dmark+2)  
349a 32 a8 fd			ld (debug_mark+2),a  
349d 18 03			jr .pastdmark  
349f ..			.dmark: db "IF2"  
34a2 f1			.pastdmark: pop af  
34a3			endm  
# End of macro DMARK
34a3						CALLMONITOR 
34a3 cd aa fd			call debug_vector  
34a6				endm  
# End of macro CALLMONITOR
34a6					endif 
34a6			 
34a6			; if not true then skip to THEN 
34a6			 
34a6				; TODO get tok_ptr 
34a6				; TODO consume toks until we get to THEN 
34a6			 
34a6 2a fd f3			ld hl, (os_tok_ptr) 
34a9					if DEBUG_FORTH_WORDS 
34a9						DMARK "IF3" 
34a9 f5				push af  
34aa 3a be 34			ld a, (.dmark)  
34ad 32 a6 fd			ld (debug_mark),a  
34b0 3a bf 34			ld a, (.dmark+1)  
34b3 32 a7 fd			ld (debug_mark+1),a  
34b6 3a c0 34			ld a, (.dmark+2)  
34b9 32 a8 fd			ld (debug_mark+2),a  
34bc 18 03			jr .pastdmark  
34be ..			.dmark: db "IF3"  
34c1 f1			.pastdmark: pop af  
34c2			endm  
# End of macro DMARK
34c2						CALLMONITOR 
34c2 cd aa fd			call debug_vector  
34c5				endm  
# End of macro CALLMONITOR
34c5						 
34c5					endif 
34c5 11 0c 35			ld de, .ifthen 
34c8					if DEBUG_FORTH_WORDS 
34c8						DMARK "IF4" 
34c8 f5				push af  
34c9 3a dd 34			ld a, (.dmark)  
34cc 32 a6 fd			ld (debug_mark),a  
34cf 3a de 34			ld a, (.dmark+1)  
34d2 32 a7 fd			ld (debug_mark+1),a  
34d5 3a df 34			ld a, (.dmark+2)  
34d8 32 a8 fd			ld (debug_mark+2),a  
34db 18 03			jr .pastdmark  
34dd ..			.dmark: db "IF4"  
34e0 f1			.pastdmark: pop af  
34e1			endm  
# End of macro DMARK
34e1						CALLMONITOR 
34e1 cd aa fd			call debug_vector  
34e4				endm  
# End of macro CALLMONITOR
34e4					endif 
34e4 cd cb 25			call findnexttok  
34e7			 
34e7					if DEBUG_FORTH_WORDS 
34e7						DMARK "IF5" 
34e7 f5				push af  
34e8 3a fc 34			ld a, (.dmark)  
34eb 32 a6 fd			ld (debug_mark),a  
34ee 3a fd 34			ld a, (.dmark+1)  
34f1 32 a7 fd			ld (debug_mark+1),a  
34f4 3a fe 34			ld a, (.dmark+2)  
34f7 32 a8 fd			ld (debug_mark+2),a  
34fa 18 03			jr .pastdmark  
34fc ..			.dmark: db "IF5"  
34ff f1			.pastdmark: pop af  
3500			endm  
# End of macro DMARK
3500						CALLMONITOR 
3500 cd aa fd			call debug_vector  
3503				endm  
# End of macro CALLMONITOR
3503					endif 
3503				; TODO replace below with ; exec using tok_ptr 
3503 22 fd f3			ld (os_tok_ptr), hl 
3506 c3 41 25			jp exec1 
3509				NEXTW 
3509 c3 b0 24			jp macro_next 
350c				endm 
# End of macro NEXTW
350c			 
350c .. 00		.ifthen:  db "THEN",0 
3511			 
3511			.iftrue:		 
3511				; Exec next words normally 
3511			 
3511				; if true then exec following IF as normal 
3511					if DEBUG_FORTH_WORDS 
3511						DMARK "IFT" 
3511 f5				push af  
3512 3a 26 35			ld a, (.dmark)  
3515 32 a6 fd			ld (debug_mark),a  
3518 3a 27 35			ld a, (.dmark+1)  
351b 32 a7 fd			ld (debug_mark+1),a  
351e 3a 28 35			ld a, (.dmark+2)  
3521 32 a8 fd			ld (debug_mark+2),a  
3524 18 03			jr .pastdmark  
3526 ..			.dmark: db "IFT"  
3529 f1			.pastdmark: pop af  
352a			endm  
# End of macro DMARK
352a						CALLMONITOR 
352a cd aa fd			call debug_vector  
352d				endm  
# End of macro CALLMONITOR
352d					endif 
352d			 
352d					NEXTW 
352d c3 b0 24			jp macro_next 
3530				endm 
# End of macro NEXTW
3530			.THEN: 
3530				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3530 1f				db WORD_SYS_CORE+11             
3531 58 35			dw .ELSE            
3533 05				db 4 + 1 
3534 .. 00			db "THEN",0              
3539				endm 
# End of macro CWHEAD
3539			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3539					if DEBUG_FORTH_WORDS_KEY 
3539						DMARK "THN" 
3539 f5				push af  
353a 3a 4e 35			ld a, (.dmark)  
353d 32 a6 fd			ld (debug_mark),a  
3540 3a 4f 35			ld a, (.dmark+1)  
3543 32 a7 fd			ld (debug_mark+1),a  
3546 3a 50 35			ld a, (.dmark+2)  
3549 32 a8 fd			ld (debug_mark+2),a  
354c 18 03			jr .pastdmark  
354e ..			.dmark: db "THN"  
3551 f1			.pastdmark: pop af  
3552			endm  
# End of macro DMARK
3552						CALLMONITOR 
3552 cd aa fd			call debug_vector  
3555				endm  
# End of macro CALLMONITOR
3555					endif 
3555					NEXTW 
3555 c3 b0 24			jp macro_next 
3558				endm 
# End of macro NEXTW
3558			.ELSE: 
3558				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3558 20				db WORD_SYS_CORE+12             
3559 80 35			dw .DO            
355b 03				db 2 + 1 
355c .. 00			db "ELSE",0              
3561				endm 
# End of macro CWHEAD
3561			; | ELSE ( -- ) Not supported - does nothing | TODO 
3561			 
3561					if DEBUG_FORTH_WORDS_KEY 
3561						DMARK "ELS" 
3561 f5				push af  
3562 3a 76 35			ld a, (.dmark)  
3565 32 a6 fd			ld (debug_mark),a  
3568 3a 77 35			ld a, (.dmark+1)  
356b 32 a7 fd			ld (debug_mark+1),a  
356e 3a 78 35			ld a, (.dmark+2)  
3571 32 a8 fd			ld (debug_mark+2),a  
3574 18 03			jr .pastdmark  
3576 ..			.dmark: db "ELS"  
3579 f1			.pastdmark: pop af  
357a			endm  
# End of macro DMARK
357a						CALLMONITOR 
357a cd aa fd			call debug_vector  
357d				endm  
# End of macro CALLMONITOR
357d					endif 
357d			 
357d			 
357d					NEXTW 
357d c3 b0 24			jp macro_next 
3580				endm 
# End of macro NEXTW
3580			.DO: 
3580				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3580 21				db WORD_SYS_CORE+13             
3581 a7 36			dw .LOOP            
3583 03				db 2 + 1 
3584 .. 00			db "DO",0              
3587				endm 
# End of macro CWHEAD
3587			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3587			 
3587					if DEBUG_FORTH_WORDS_KEY 
3587						DMARK "DO." 
3587 f5				push af  
3588 3a 9c 35			ld a, (.dmark)  
358b 32 a6 fd			ld (debug_mark),a  
358e 3a 9d 35			ld a, (.dmark+1)  
3591 32 a7 fd			ld (debug_mark+1),a  
3594 3a 9e 35			ld a, (.dmark+2)  
3597 32 a8 fd			ld (debug_mark+2),a  
359a 18 03			jr .pastdmark  
359c ..			.dmark: db "DO."  
359f f1			.pastdmark: pop af  
35a0			endm  
# End of macro DMARK
35a0						CALLMONITOR 
35a0 cd aa fd			call debug_vector  
35a3				endm  
# End of macro CALLMONITOR
35a3					endif 
35a3			;  push pc to rsp stack past the DO 
35a3			 
35a3 2a fd f3				ld hl, (os_tok_ptr) 
35a6 23					inc hl   ; D 
35a7 23					inc hl  ; O 
35a8 23					inc hl   ; null 
35a9					if DEBUG_FORTH_WORDS 
35a9						DMARK "DO2" 
35a9 f5				push af  
35aa 3a be 35			ld a, (.dmark)  
35ad 32 a6 fd			ld (debug_mark),a  
35b0 3a bf 35			ld a, (.dmark+1)  
35b3 32 a7 fd			ld (debug_mark+1),a  
35b6 3a c0 35			ld a, (.dmark+2)  
35b9 32 a8 fd			ld (debug_mark+2),a  
35bc 18 03			jr .pastdmark  
35be ..			.dmark: db "DO2"  
35c1 f1			.pastdmark: pop af  
35c2			endm  
# End of macro DMARK
35c2						CALLMONITOR 
35c2 cd aa fd			call debug_vector  
35c5				endm  
# End of macro CALLMONITOR
35c5					endif 
35c5					FORTH_RSP_NEXT 
35c5 cd aa 20			call macro_forth_rsp_next 
35c8				endm 
# End of macro FORTH_RSP_NEXT
35c8					if DEBUG_FORTH_WORDS 
35c8						DMARK "DO3" 
35c8 f5				push af  
35c9 3a dd 35			ld a, (.dmark)  
35cc 32 a6 fd			ld (debug_mark),a  
35cf 3a de 35			ld a, (.dmark+1)  
35d2 32 a7 fd			ld (debug_mark+1),a  
35d5 3a df 35			ld a, (.dmark+2)  
35d8 32 a8 fd			ld (debug_mark+2),a  
35db 18 03			jr .pastdmark  
35dd ..			.dmark: db "DO3"  
35e0 f1			.pastdmark: pop af  
35e1			endm  
# End of macro DMARK
35e1						CALLMONITOR 
35e1 cd aa fd			call debug_vector  
35e4				endm  
# End of macro CALLMONITOR
35e4					endif 
35e4			 
35e4					;if DEBUG_FORTH_WORDS 
35e4				;		push hl 
35e4			;		endif  
35e4			 
35e4			; get counters from data stack 
35e4			 
35e4			 
35e4					FORTH_DSP_VALUEHL 
35e4 cd fa 22			call macro_dsp_valuehl 
35e7				endm 
# End of macro FORTH_DSP_VALUEHL
35e7 e5					push hl		 ; hl now has starting counter which needs to be tos 
35e8			 
35e8					if DEBUG_FORTH_WORDS 
35e8						DMARK "DO4" 
35e8 f5				push af  
35e9 3a fd 35			ld a, (.dmark)  
35ec 32 a6 fd			ld (debug_mark),a  
35ef 3a fe 35			ld a, (.dmark+1)  
35f2 32 a7 fd			ld (debug_mark+1),a  
35f5 3a ff 35			ld a, (.dmark+2)  
35f8 32 a8 fd			ld (debug_mark+2),a  
35fb 18 03			jr .pastdmark  
35fd ..			.dmark: db "DO4"  
3600 f1			.pastdmark: pop af  
3601			endm  
# End of macro DMARK
3601						CALLMONITOR 
3601 cd aa fd			call debug_vector  
3604				endm  
# End of macro CALLMONITOR
3604					endif 
3604					FORTH_DSP_POP 
3604 cd b2 23			call macro_forth_dsp_pop 
3607				endm 
# End of macro FORTH_DSP_POP
3607			 
3607					if DEBUG_FORTH_WORDS 
3607						DMARK "DO5" 
3607 f5				push af  
3608 3a 1c 36			ld a, (.dmark)  
360b 32 a6 fd			ld (debug_mark),a  
360e 3a 1d 36			ld a, (.dmark+1)  
3611 32 a7 fd			ld (debug_mark+1),a  
3614 3a 1e 36			ld a, (.dmark+2)  
3617 32 a8 fd			ld (debug_mark+2),a  
361a 18 03			jr .pastdmark  
361c ..			.dmark: db "DO5"  
361f f1			.pastdmark: pop af  
3620			endm  
# End of macro DMARK
3620						CALLMONITOR 
3620 cd aa fd			call debug_vector  
3623				endm  
# End of macro CALLMONITOR
3623					endif 
3623			 
3623					FORTH_DSP_VALUEHL 
3623 cd fa 22			call macro_dsp_valuehl 
3626				endm 
# End of macro FORTH_DSP_VALUEHL
3626			;		push hl		 ; hl now has starting limit counter 
3626			 
3626					if DEBUG_FORTH_WORDS 
3626						DMARK "DO6" 
3626 f5				push af  
3627 3a 3b 36			ld a, (.dmark)  
362a 32 a6 fd			ld (debug_mark),a  
362d 3a 3c 36			ld a, (.dmark+1)  
3630 32 a7 fd			ld (debug_mark+1),a  
3633 3a 3d 36			ld a, (.dmark+2)  
3636 32 a8 fd			ld (debug_mark+2),a  
3639 18 03			jr .pastdmark  
363b ..			.dmark: db "DO6"  
363e f1			.pastdmark: pop af  
363f			endm  
# End of macro DMARK
363f						CALLMONITOR 
363f cd aa fd			call debug_vector  
3642				endm  
# End of macro CALLMONITOR
3642					endif 
3642					FORTH_DSP_POP 
3642 cd b2 23			call macro_forth_dsp_pop 
3645				endm 
# End of macro FORTH_DSP_POP
3645			 
3645			; put counters on the loop stack 
3645			 
3645			;		pop hl			 ; limit counter 
3645 d1					pop de			; start counter 
3646			 
3646					; push limit counter 
3646			 
3646					if DEBUG_FORTH_WORDS 
3646						DMARK "DO7" 
3646 f5				push af  
3647 3a 5b 36			ld a, (.dmark)  
364a 32 a6 fd			ld (debug_mark),a  
364d 3a 5c 36			ld a, (.dmark+1)  
3650 32 a7 fd			ld (debug_mark+1),a  
3653 3a 5d 36			ld a, (.dmark+2)  
3656 32 a8 fd			ld (debug_mark+2),a  
3659 18 03			jr .pastdmark  
365b ..			.dmark: db "DO7"  
365e f1			.pastdmark: pop af  
365f			endm  
# End of macro DMARK
365f						CALLMONITOR 
365f cd aa fd			call debug_vector  
3662				endm  
# End of macro CALLMONITOR
3662					endif 
3662					FORTH_LOOP_NEXT 
3662 cd 2b 23			call macro_forth_loop_next 
3665				endm 
# End of macro FORTH_LOOP_NEXT
3665			 
3665					; push start counter 
3665			 
3665 eb					ex de, hl 
3666					if DEBUG_FORTH_WORDS 
3666						DMARK "DO7" 
3666 f5				push af  
3667 3a 7b 36			ld a, (.dmark)  
366a 32 a6 fd			ld (debug_mark),a  
366d 3a 7c 36			ld a, (.dmark+1)  
3670 32 a7 fd			ld (debug_mark+1),a  
3673 3a 7d 36			ld a, (.dmark+2)  
3676 32 a8 fd			ld (debug_mark+2),a  
3679 18 03			jr .pastdmark  
367b ..			.dmark: db "DO7"  
367e f1			.pastdmark: pop af  
367f			endm  
# End of macro DMARK
367f						CALLMONITOR 
367f cd aa fd			call debug_vector  
3682				endm  
# End of macro CALLMONITOR
3682					endif 
3682					FORTH_LOOP_NEXT 
3682 cd 2b 23			call macro_forth_loop_next 
3685				endm 
# End of macro FORTH_LOOP_NEXT
3685			 
3685			 
3685					; init first round of I counter 
3685			 
3685 22 21 f4				ld (os_current_i), hl 
3688			 
3688					if DEBUG_FORTH_WORDS 
3688						DMARK "DO8" 
3688 f5				push af  
3689 3a 9d 36			ld a, (.dmark)  
368c 32 a6 fd			ld (debug_mark),a  
368f 3a 9e 36			ld a, (.dmark+1)  
3692 32 a7 fd			ld (debug_mark+1),a  
3695 3a 9f 36			ld a, (.dmark+2)  
3698 32 a8 fd			ld (debug_mark+2),a  
369b 18 03			jr .pastdmark  
369d ..			.dmark: db "DO8"  
36a0 f1			.pastdmark: pop af  
36a1			endm  
# End of macro DMARK
36a1						CALLMONITOR 
36a1 cd aa fd			call debug_vector  
36a4				endm  
# End of macro CALLMONITOR
36a4					endif 
36a4			 
36a4					NEXTW 
36a4 c3 b0 24			jp macro_next 
36a7				endm 
# End of macro NEXTW
36a7			.LOOP: 
36a7				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
36a7 22				db WORD_SYS_CORE+14             
36a8 bf 37			dw .I            
36aa 05				db 4 + 1 
36ab .. 00			db "LOOP",0              
36b0				endm 
# End of macro CWHEAD
36b0			; | LOOP ( -- ) Increment and test loop counter  | DONE 
36b0			 
36b0				; pop tos as current loop count to hl 
36b0			 
36b0				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
36b0			 
36b0				FORTH_LOOP_TOS 
36b0 cd 5e 23			call macro_forth_loop_tos 
36b3				endm 
# End of macro FORTH_LOOP_TOS
36b3 e5				push hl 
36b4			 
36b4					if DEBUG_FORTH_WORDS_KEY 
36b4						DMARK "LOP" 
36b4 f5				push af  
36b5 3a c9 36			ld a, (.dmark)  
36b8 32 a6 fd			ld (debug_mark),a  
36bb 3a ca 36			ld a, (.dmark+1)  
36be 32 a7 fd			ld (debug_mark+1),a  
36c1 3a cb 36			ld a, (.dmark+2)  
36c4 32 a8 fd			ld (debug_mark+2),a  
36c7 18 03			jr .pastdmark  
36c9 ..			.dmark: db "LOP"  
36cc f1			.pastdmark: pop af  
36cd			endm  
# End of macro DMARK
36cd						CALLMONITOR 
36cd cd aa fd			call debug_vector  
36d0				endm  
# End of macro CALLMONITOR
36d0					endif 
36d0				; next item on the stack is the limit. get it 
36d0			 
36d0			 
36d0				FORTH_LOOP_POP 
36d0 cd 68 23			call macro_forth_loop_pop 
36d3				endm 
# End of macro FORTH_LOOP_POP
36d3			 
36d3				FORTH_LOOP_TOS 
36d3 cd 5e 23			call macro_forth_loop_tos 
36d6				endm 
# End of macro FORTH_LOOP_TOS
36d6			 
36d6 d1				pop de		 ; de = i, hl = limit 
36d7			 
36d7					if DEBUG_FORTH_WORDS 
36d7						DMARK "LP1" 
36d7 f5				push af  
36d8 3a ec 36			ld a, (.dmark)  
36db 32 a6 fd			ld (debug_mark),a  
36de 3a ed 36			ld a, (.dmark+1)  
36e1 32 a7 fd			ld (debug_mark+1),a  
36e4 3a ee 36			ld a, (.dmark+2)  
36e7 32 a8 fd			ld (debug_mark+2),a  
36ea 18 03			jr .pastdmark  
36ec ..			.dmark: db "LP1"  
36ef f1			.pastdmark: pop af  
36f0			endm  
# End of macro DMARK
36f0						CALLMONITOR 
36f0 cd aa fd			call debug_vector  
36f3				endm  
# End of macro CALLMONITOR
36f3					endif 
36f3			 
36f3				; go back to previous word 
36f3			 
36f3 d5				push de    ; save I for inc later 
36f4			 
36f4			 
36f4				; get limit 
36f4				;  is I at limit? 
36f4			 
36f4			 
36f4					if DEBUG_FORTH_WORDS 
36f4						DMARK "LP1" 
36f4 f5				push af  
36f5 3a 09 37			ld a, (.dmark)  
36f8 32 a6 fd			ld (debug_mark),a  
36fb 3a 0a 37			ld a, (.dmark+1)  
36fe 32 a7 fd			ld (debug_mark+1),a  
3701 3a 0b 37			ld a, (.dmark+2)  
3704 32 a8 fd			ld (debug_mark+2),a  
3707 18 03			jr .pastdmark  
3709 ..			.dmark: db "LP1"  
370c f1			.pastdmark: pop af  
370d			endm  
# End of macro DMARK
370d						CALLMONITOR 
370d cd aa fd			call debug_vector  
3710				endm  
# End of macro CALLMONITOR
3710					endif 
3710			 
3710 ed 52			sbc hl, de 
3712			 
3712			 
3712				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3712			 
3712 20 26				jr nz, .loopnotdone 
3714			 
3714 e1				pop hl   ; get rid of saved I 
3715				FORTH_LOOP_POP     ; get rid of limit 
3715 cd 68 23			call macro_forth_loop_pop 
3718				endm 
# End of macro FORTH_LOOP_POP
3718			 
3718				FORTH_RSP_POP     ; get rid of DO ptr 
3718 cd cb 20			call macro_forth_rsp_pop 
371b				endm 
# End of macro FORTH_RSP_POP
371b			 
371b			if DEBUG_FORTH_WORDS 
371b						DMARK "LP>" 
371b f5				push af  
371c 3a 30 37			ld a, (.dmark)  
371f 32 a6 fd			ld (debug_mark),a  
3722 3a 31 37			ld a, (.dmark+1)  
3725 32 a7 fd			ld (debug_mark+1),a  
3728 3a 32 37			ld a, (.dmark+2)  
372b 32 a8 fd			ld (debug_mark+2),a  
372e 18 03			jr .pastdmark  
3730 ..			.dmark: db "LP>"  
3733 f1			.pastdmark: pop af  
3734			endm  
# End of macro DMARK
3734				CALLMONITOR 
3734 cd aa fd			call debug_vector  
3737				endm  
# End of macro CALLMONITOR
3737			endif 
3737			 
3737					NEXTW 
3737 c3 b0 24			jp macro_next 
373a				endm 
# End of macro NEXTW
373a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
373a			 
373a			.loopnotdone: 
373a			 
373a e1				pop hl    ; get I 
373b 23				inc hl 
373c			 
373c			   	; save new I 
373c			 
373c			 
373c					; set I counter 
373c			 
373c 22 21 f4				ld (os_current_i), hl 
373f			 
373f					if DEBUG_FORTH_WORDS 
373f						DMARK "LPN" 
373f f5				push af  
3740 3a 54 37			ld a, (.dmark)  
3743 32 a6 fd			ld (debug_mark),a  
3746 3a 55 37			ld a, (.dmark+1)  
3749 32 a7 fd			ld (debug_mark+1),a  
374c 3a 56 37			ld a, (.dmark+2)  
374f 32 a8 fd			ld (debug_mark+2),a  
3752 18 03			jr .pastdmark  
3754 ..			.dmark: db "LPN"  
3757 f1			.pastdmark: pop af  
3758			endm  
# End of macro DMARK
3758					CALLMONITOR 
3758 cd aa fd			call debug_vector  
375b				endm  
# End of macro CALLMONITOR
375b					endif 
375b					 
375b				FORTH_LOOP_NEXT 
375b cd 2b 23			call macro_forth_loop_next 
375e				endm 
# End of macro FORTH_LOOP_NEXT
375e			 
375e			 
375e					if DEBUG_FORTH_WORDS 
375e eb						ex de,hl 
375f					endif 
375f			 
375f			;	; get DO ptr 
375f			; 
375f					if DEBUG_FORTH_WORDS 
375f						DMARK "LP7" 
375f f5				push af  
3760 3a 74 37			ld a, (.dmark)  
3763 32 a6 fd			ld (debug_mark),a  
3766 3a 75 37			ld a, (.dmark+1)  
3769 32 a7 fd			ld (debug_mark+1),a  
376c 3a 76 37			ld a, (.dmark+2)  
376f 32 a8 fd			ld (debug_mark+2),a  
3772 18 03			jr .pastdmark  
3774 ..			.dmark: db "LP7"  
3777 f1			.pastdmark: pop af  
3778			endm  
# End of macro DMARK
3778					CALLMONITOR 
3778 cd aa fd			call debug_vector  
377b				endm  
# End of macro CALLMONITOR
377b					endif 
377b				FORTH_RSP_TOS 
377b cd c1 20			call macro_forth_rsp_tos 
377e				endm 
# End of macro FORTH_RSP_TOS
377e			 
377e					if DEBUG_FORTH_WORDS 
377e						DMARK "LP8" 
377e f5				push af  
377f 3a 93 37			ld a, (.dmark)  
3782 32 a6 fd			ld (debug_mark),a  
3785 3a 94 37			ld a, (.dmark+1)  
3788 32 a7 fd			ld (debug_mark+1),a  
378b 3a 95 37			ld a, (.dmark+2)  
378e 32 a8 fd			ld (debug_mark+2),a  
3791 18 03			jr .pastdmark  
3793 ..			.dmark: db "LP8"  
3796 f1			.pastdmark: pop af  
3797			endm  
# End of macro DMARK
3797					CALLMONITOR 
3797 cd aa fd			call debug_vector  
379a				endm  
# End of macro CALLMONITOR
379a					endif 
379a				;push hl 
379a			 
379a				; not going to DO any more 
379a				; get rid of the RSP pointer as DO will add it back in 
379a				;FORTH_RSP_POP 
379a				;pop hl 
379a			 
379a				;ld hl,(cli_ret_sp) 
379a				;ld e, (hl) 
379a				;inc hl 
379a				;ld d, (hl) 
379a				;ex de,hl 
379a 22 fd f3			ld (os_tok_ptr), hl 
379d					if DEBUG_FORTH_WORDS 
379d						DMARK "LP<" 
379d f5				push af  
379e 3a b2 37			ld a, (.dmark)  
37a1 32 a6 fd			ld (debug_mark),a  
37a4 3a b3 37			ld a, (.dmark+1)  
37a7 32 a7 fd			ld (debug_mark+1),a  
37aa 3a b4 37			ld a, (.dmark+2)  
37ad 32 a8 fd			ld (debug_mark+2),a  
37b0 18 03			jr .pastdmark  
37b2 ..			.dmark: db "LP<"  
37b5 f1			.pastdmark: pop af  
37b6			endm  
# End of macro DMARK
37b6					CALLMONITOR 
37b6 cd aa fd			call debug_vector  
37b9				endm  
# End of macro CALLMONITOR
37b9				endif 
37b9 c3 41 25			jp exec1 
37bc			 
37bc					 
37bc			 
37bc			 
37bc					NEXTW 
37bc c3 b0 24			jp macro_next 
37bf				endm 
# End of macro NEXTW
37bf			.I:  
37bf			 
37bf				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
37bf 5e				db WORD_SYS_CORE+74             
37c0 ea 37			dw .DLOOP            
37c2 02				db 1 + 1 
37c3 .. 00			db "I",0              
37c5				endm 
# End of macro CWHEAD
37c5			; | I ( -- ) Current loop counter | DONE 
37c5					if DEBUG_FORTH_WORDS_KEY 
37c5						DMARK "I.." 
37c5 f5				push af  
37c6 3a da 37			ld a, (.dmark)  
37c9 32 a6 fd			ld (debug_mark),a  
37cc 3a db 37			ld a, (.dmark+1)  
37cf 32 a7 fd			ld (debug_mark+1),a  
37d2 3a dc 37			ld a, (.dmark+2)  
37d5 32 a8 fd			ld (debug_mark+2),a  
37d8 18 03			jr .pastdmark  
37da ..			.dmark: db "I.."  
37dd f1			.pastdmark: pop af  
37de			endm  
# End of macro DMARK
37de						CALLMONITOR 
37de cd aa fd			call debug_vector  
37e1				endm  
# End of macro CALLMONITOR
37e1					endif 
37e1			 
37e1 2a 21 f4				ld hl,(os_current_i) 
37e4 cd 03 21				call forth_push_numhl 
37e7			 
37e7					NEXTW 
37e7 c3 b0 24			jp macro_next 
37ea				endm 
# End of macro NEXTW
37ea			.DLOOP: 
37ea				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
37ea 5f				db WORD_SYS_CORE+75             
37eb cb 38			dw .REPEAT            
37ed 06				db 5 + 1 
37ee .. 00			db "-LOOP",0              
37f4				endm 
# End of macro CWHEAD
37f4			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
37f4				; pop tos as current loop count to hl 
37f4					if DEBUG_FORTH_WORDS_KEY 
37f4						DMARK "-LP" 
37f4 f5				push af  
37f5 3a 09 38			ld a, (.dmark)  
37f8 32 a6 fd			ld (debug_mark),a  
37fb 3a 0a 38			ld a, (.dmark+1)  
37fe 32 a7 fd			ld (debug_mark+1),a  
3801 3a 0b 38			ld a, (.dmark+2)  
3804 32 a8 fd			ld (debug_mark+2),a  
3807 18 03			jr .pastdmark  
3809 ..			.dmark: db "-LP"  
380c f1			.pastdmark: pop af  
380d			endm  
# End of macro DMARK
380d						CALLMONITOR 
380d cd aa fd			call debug_vector  
3810				endm  
# End of macro CALLMONITOR
3810					endif 
3810			 
3810				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3810			 
3810				FORTH_LOOP_TOS 
3810 cd 5e 23			call macro_forth_loop_tos 
3813				endm 
# End of macro FORTH_LOOP_TOS
3813 e5				push hl 
3814			 
3814					if DEBUG_FORTH_WORDS 
3814						DMARK "-LP" 
3814 f5				push af  
3815 3a 29 38			ld a, (.dmark)  
3818 32 a6 fd			ld (debug_mark),a  
381b 3a 2a 38			ld a, (.dmark+1)  
381e 32 a7 fd			ld (debug_mark+1),a  
3821 3a 2b 38			ld a, (.dmark+2)  
3824 32 a8 fd			ld (debug_mark+2),a  
3827 18 03			jr .pastdmark  
3829 ..			.dmark: db "-LP"  
382c f1			.pastdmark: pop af  
382d			endm  
# End of macro DMARK
382d						CALLMONITOR 
382d cd aa fd			call debug_vector  
3830				endm  
# End of macro CALLMONITOR
3830					endif 
3830				; next item on the stack is the limit. get it 
3830			 
3830			 
3830				FORTH_LOOP_POP 
3830 cd 68 23			call macro_forth_loop_pop 
3833				endm 
# End of macro FORTH_LOOP_POP
3833			 
3833				FORTH_LOOP_TOS 
3833 cd 5e 23			call macro_forth_loop_tos 
3836				endm 
# End of macro FORTH_LOOP_TOS
3836			 
3836 d1				pop de		 ; de = i, hl = limit 
3837			 
3837					if DEBUG_FORTH_WORDS 
3837						DMARK "-L1" 
3837 f5				push af  
3838 3a 4c 38			ld a, (.dmark)  
383b 32 a6 fd			ld (debug_mark),a  
383e 3a 4d 38			ld a, (.dmark+1)  
3841 32 a7 fd			ld (debug_mark+1),a  
3844 3a 4e 38			ld a, (.dmark+2)  
3847 32 a8 fd			ld (debug_mark+2),a  
384a 18 03			jr .pastdmark  
384c ..			.dmark: db "-L1"  
384f f1			.pastdmark: pop af  
3850			endm  
# End of macro DMARK
3850						CALLMONITOR 
3850 cd aa fd			call debug_vector  
3853				endm  
# End of macro CALLMONITOR
3853					endif 
3853			 
3853				; go back to previous word 
3853			 
3853 d5				push de    ; save I for inc later 
3854			 
3854			 
3854				; get limit 
3854				;  is I at limit? 
3854			 
3854			 
3854					if DEBUG_FORTH_WORDS 
3854						DMARK "-L1" 
3854 f5				push af  
3855 3a 69 38			ld a, (.dmark)  
3858 32 a6 fd			ld (debug_mark),a  
385b 3a 6a 38			ld a, (.dmark+1)  
385e 32 a7 fd			ld (debug_mark+1),a  
3861 3a 6b 38			ld a, (.dmark+2)  
3864 32 a8 fd			ld (debug_mark+2),a  
3867 18 03			jr .pastdmark  
3869 ..			.dmark: db "-L1"  
386c f1			.pastdmark: pop af  
386d			endm  
# End of macro DMARK
386d						CALLMONITOR 
386d cd aa fd			call debug_vector  
3870				endm  
# End of macro CALLMONITOR
3870					endif 
3870			 
3870 ed 52			sbc hl, de 
3872			 
3872			 
3872				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3872			 
3872 20 26				jr nz, .mloopnotdone 
3874			 
3874 e1				pop hl   ; get rid of saved I 
3875				FORTH_LOOP_POP     ; get rid of limit 
3875 cd 68 23			call macro_forth_loop_pop 
3878				endm 
# End of macro FORTH_LOOP_POP
3878			 
3878				FORTH_RSP_POP     ; get rid of DO ptr 
3878 cd cb 20			call macro_forth_rsp_pop 
387b				endm 
# End of macro FORTH_RSP_POP
387b			 
387b			if DEBUG_FORTH_WORDS 
387b						DMARK "-L>" 
387b f5				push af  
387c 3a 90 38			ld a, (.dmark)  
387f 32 a6 fd			ld (debug_mark),a  
3882 3a 91 38			ld a, (.dmark+1)  
3885 32 a7 fd			ld (debug_mark+1),a  
3888 3a 92 38			ld a, (.dmark+2)  
388b 32 a8 fd			ld (debug_mark+2),a  
388e 18 03			jr .pastdmark  
3890 ..			.dmark: db "-L>"  
3893 f1			.pastdmark: pop af  
3894			endm  
# End of macro DMARK
3894				CALLMONITOR 
3894 cd aa fd			call debug_vector  
3897				endm  
# End of macro CALLMONITOR
3897			endif 
3897			 
3897					NEXTW 
3897 c3 b0 24			jp macro_next 
389a				endm 
# End of macro NEXTW
389a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
389a			 
389a			.mloopnotdone: 
389a			 
389a e1				pop hl    ; get I 
389b 2b				dec hl 
389c			 
389c			   	; save new I 
389c			 
389c			 
389c					; set I counter 
389c			 
389c 22 21 f4				ld (os_current_i), hl 
389f			 
389f					 
389f				FORTH_LOOP_NEXT 
389f cd 2b 23			call macro_forth_loop_next 
38a2				endm 
# End of macro FORTH_LOOP_NEXT
38a2			 
38a2			 
38a2					if DEBUG_FORTH_WORDS 
38a2 eb						ex de,hl 
38a3					endif 
38a3			 
38a3			;	; get DO ptr 
38a3			; 
38a3				FORTH_RSP_TOS 
38a3 cd c1 20			call macro_forth_rsp_tos 
38a6				endm 
# End of macro FORTH_RSP_TOS
38a6			 
38a6				;push hl 
38a6			 
38a6				; not going to DO any more 
38a6				; get rid of the RSP pointer as DO will add it back in 
38a6				;FORTH_RSP_POP 
38a6				;pop hl 
38a6			 
38a6			 
38a6 22 fd f3			ld (os_tok_ptr), hl 
38a9					if DEBUG_FORTH_WORDS 
38a9						DMARK "-L<" 
38a9 f5				push af  
38aa 3a be 38			ld a, (.dmark)  
38ad 32 a6 fd			ld (debug_mark),a  
38b0 3a bf 38			ld a, (.dmark+1)  
38b3 32 a7 fd			ld (debug_mark+1),a  
38b6 3a c0 38			ld a, (.dmark+2)  
38b9 32 a8 fd			ld (debug_mark+2),a  
38bc 18 03			jr .pastdmark  
38be ..			.dmark: db "-L<"  
38c1 f1			.pastdmark: pop af  
38c2			endm  
# End of macro DMARK
38c2					CALLMONITOR 
38c2 cd aa fd			call debug_vector  
38c5				endm  
# End of macro CALLMONITOR
38c5				endif 
38c5 c3 41 25			jp exec1 
38c8			 
38c8					 
38c8			 
38c8			 
38c8			 
38c8				NEXTW 
38c8 c3 b0 24			jp macro_next 
38cb				endm 
# End of macro NEXTW
38cb			 
38cb			 
38cb			 
38cb			 
38cb			.REPEAT: 
38cb				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
38cb 71				db WORD_SYS_CORE+93             
38cc 1e 39			dw .UNTIL            
38ce 06				db 5 + 1 
38cf .. 00			db "REPEAT",0              
38d6				endm 
# End of macro CWHEAD
38d6			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
38d6			;  push pc to rsp stack past the REPEAT 
38d6					if DEBUG_FORTH_WORDS_KEY 
38d6						DMARK "REP" 
38d6 f5				push af  
38d7 3a eb 38			ld a, (.dmark)  
38da 32 a6 fd			ld (debug_mark),a  
38dd 3a ec 38			ld a, (.dmark+1)  
38e0 32 a7 fd			ld (debug_mark+1),a  
38e3 3a ed 38			ld a, (.dmark+2)  
38e6 32 a8 fd			ld (debug_mark+2),a  
38e9 18 03			jr .pastdmark  
38eb ..			.dmark: db "REP"  
38ee f1			.pastdmark: pop af  
38ef			endm  
# End of macro DMARK
38ef						CALLMONITOR 
38ef cd aa fd			call debug_vector  
38f2				endm  
# End of macro CALLMONITOR
38f2					endif 
38f2			 
38f2 2a fd f3				ld hl, (os_tok_ptr) 
38f5 23					inc hl   ; R 
38f6 23					inc hl  ; E 
38f7 23					inc hl   ; P 
38f8 23					inc hl   ; E 
38f9 23					inc hl   ; A 
38fa 23					inc hl   ; T 
38fb 23					inc hl   ; zero 
38fc					FORTH_RSP_NEXT 
38fc cd aa 20			call macro_forth_rsp_next 
38ff				endm 
# End of macro FORTH_RSP_NEXT
38ff			 
38ff			 
38ff					if DEBUG_FORTH_WORDS 
38ff						DMARK "REP" 
38ff f5				push af  
3900 3a 14 39			ld a, (.dmark)  
3903 32 a6 fd			ld (debug_mark),a  
3906 3a 15 39			ld a, (.dmark+1)  
3909 32 a7 fd			ld (debug_mark+1),a  
390c 3a 16 39			ld a, (.dmark+2)  
390f 32 a8 fd			ld (debug_mark+2),a  
3912 18 03			jr .pastdmark  
3914 ..			.dmark: db "REP"  
3917 f1			.pastdmark: pop af  
3918			endm  
# End of macro DMARK
3918						;pop bc    ; TODO BUG ?????? what is this for???? 
3918						CALLMONITOR 
3918 cd aa fd			call debug_vector  
391b				endm  
# End of macro CALLMONITOR
391b					endif 
391b			 
391b					NEXTW 
391b c3 b0 24			jp macro_next 
391e				endm 
# End of macro NEXTW
391e			;	       NEXTW 
391e			 
391e			.UNTIL: 
391e				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
391e 72				db WORD_SYS_CORE+94             
391f b5 39			dw .ENDFLOW            
3921 06				db 5 + 1 
3922 .. 00			db "UNTIL",0              
3928				endm 
# End of macro CWHEAD
3928			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3928			 
3928				; pop tos as check 
3928			 
3928				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3928			 
3928				FORTH_DSP_VALUEHL 
3928 cd fa 22			call macro_dsp_valuehl 
392b				endm 
# End of macro FORTH_DSP_VALUEHL
392b			 
392b					if DEBUG_FORTH_WORDS_KEY 
392b						DMARK "UNT" 
392b f5				push af  
392c 3a 40 39			ld a, (.dmark)  
392f 32 a6 fd			ld (debug_mark),a  
3932 3a 41 39			ld a, (.dmark+1)  
3935 32 a7 fd			ld (debug_mark+1),a  
3938 3a 42 39			ld a, (.dmark+2)  
393b 32 a8 fd			ld (debug_mark+2),a  
393e 18 03			jr .pastdmark  
3940 ..			.dmark: db "UNT"  
3943 f1			.pastdmark: pop af  
3944			endm  
# End of macro DMARK
3944						CALLMONITOR 
3944 cd aa fd			call debug_vector  
3947				endm  
# End of macro CALLMONITOR
3947					endif 
3947			 
3947			;	push hl 
3947				FORTH_DSP_POP 
3947 cd b2 23			call macro_forth_dsp_pop 
394a				endm 
# End of macro FORTH_DSP_POP
394a			 
394a			;	pop hl 
394a			 
394a				; test if true 
394a			 
394a cd f8 0f			call ishlzero 
394d			;	ld a,l 
394d			;	add h 
394d			; 
394d			;	cp 0 
394d			 
394d 20 3e			jr nz, .untilnotdone 
394f			 
394f					if DEBUG_FORTH_WORDS 
394f						DMARK "UNf" 
394f f5				push af  
3950 3a 64 39			ld a, (.dmark)  
3953 32 a6 fd			ld (debug_mark),a  
3956 3a 65 39			ld a, (.dmark+1)  
3959 32 a7 fd			ld (debug_mark+1),a  
395c 3a 66 39			ld a, (.dmark+2)  
395f 32 a8 fd			ld (debug_mark+2),a  
3962 18 03			jr .pastdmark  
3964 ..			.dmark: db "UNf"  
3967 f1			.pastdmark: pop af  
3968			endm  
# End of macro DMARK
3968						CALLMONITOR 
3968 cd aa fd			call debug_vector  
396b				endm  
# End of macro CALLMONITOR
396b					endif 
396b			 
396b			 
396b			 
396b				FORTH_RSP_POP     ; get rid of DO ptr 
396b cd cb 20			call macro_forth_rsp_pop 
396e				endm 
# End of macro FORTH_RSP_POP
396e			 
396e			if DEBUG_FORTH_WORDS 
396e						DMARK "UN>" 
396e f5				push af  
396f 3a 83 39			ld a, (.dmark)  
3972 32 a6 fd			ld (debug_mark),a  
3975 3a 84 39			ld a, (.dmark+1)  
3978 32 a7 fd			ld (debug_mark+1),a  
397b 3a 85 39			ld a, (.dmark+2)  
397e 32 a8 fd			ld (debug_mark+2),a  
3981 18 03			jr .pastdmark  
3983 ..			.dmark: db "UN>"  
3986 f1			.pastdmark: pop af  
3987			endm  
# End of macro DMARK
3987				CALLMONITOR 
3987 cd aa fd			call debug_vector  
398a				endm  
# End of macro CALLMONITOR
398a			endif 
398a			 
398a					NEXTW 
398a c3 b0 24			jp macro_next 
398d				endm 
# End of macro NEXTW
398d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
398d			 
398d			.untilnotdone: 
398d			 
398d			 
398d			;	; get DO ptr 
398d			; 
398d				FORTH_RSP_TOS 
398d cd c1 20			call macro_forth_rsp_tos 
3990				endm 
# End of macro FORTH_RSP_TOS
3990			 
3990				;push hl 
3990			 
3990				; not going to DO any more 
3990				; get rid of the RSP pointer as DO will add it back in 
3990				;FORTH_RSP_POP 
3990				;pop hl 
3990			 
3990			 
3990 22 fd f3			ld (os_tok_ptr), hl 
3993					if DEBUG_FORTH_WORDS 
3993						DMARK "UN<" 
3993 f5				push af  
3994 3a a8 39			ld a, (.dmark)  
3997 32 a6 fd			ld (debug_mark),a  
399a 3a a9 39			ld a, (.dmark+1)  
399d 32 a7 fd			ld (debug_mark+1),a  
39a0 3a aa 39			ld a, (.dmark+2)  
39a3 32 a8 fd			ld (debug_mark+2),a  
39a6 18 03			jr .pastdmark  
39a8 ..			.dmark: db "UN<"  
39ab f1			.pastdmark: pop af  
39ac			endm  
# End of macro DMARK
39ac					CALLMONITOR 
39ac cd aa fd			call debug_vector  
39af				endm  
# End of macro CALLMONITOR
39af				endif 
39af c3 41 25			jp exec1 
39b2			 
39b2					 
39b2			 
39b2			 
39b2					NEXTW 
39b2 c3 b0 24			jp macro_next 
39b5				endm 
# End of macro NEXTW
39b5			 
39b5			 
39b5			.ENDFLOW: 
39b5			 
39b5			; eof 
39b5			 
# End of file forth_words_flow.asm
39b5			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
39b5			include "forth_words_logic.asm" 
39b5			 
39b5			; | ## Logic Words 
39b5			 
39b5			.NOT: 
39b5				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
39b5 2d				db WORD_SYS_CORE+25             
39b6 fd 39			dw .IS            
39b8 04				db 3 + 1 
39b9 .. 00			db "NOT",0              
39bd				endm 
# End of macro CWHEAD
39bd			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
39bd					if DEBUG_FORTH_WORDS_KEY 
39bd						DMARK "NOT" 
39bd f5				push af  
39be 3a d2 39			ld a, (.dmark)  
39c1 32 a6 fd			ld (debug_mark),a  
39c4 3a d3 39			ld a, (.dmark+1)  
39c7 32 a7 fd			ld (debug_mark+1),a  
39ca 3a d4 39			ld a, (.dmark+2)  
39cd 32 a8 fd			ld (debug_mark+2),a  
39d0 18 03			jr .pastdmark  
39d2 ..			.dmark: db "NOT"  
39d5 f1			.pastdmark: pop af  
39d6			endm  
# End of macro DMARK
39d6						CALLMONITOR 
39d6 cd aa fd			call debug_vector  
39d9				endm  
# End of macro CALLMONITOR
39d9					endif 
39d9					FORTH_DSP 
39d9 cd c0 22			call macro_forth_dsp 
39dc				endm 
# End of macro FORTH_DSP
39dc 7e					ld a,(hl)	; get type of value on TOS 
39dd fe 02				cp DS_TYPE_INUM  
39df 28 03				jr z, .noti 
39e1					NEXTW 
39e1 c3 b0 24			jp macro_next 
39e4				endm 
# End of macro NEXTW
39e4			.noti:          FORTH_DSP_VALUEHL 
39e4 cd fa 22			call macro_dsp_valuehl 
39e7				endm 
# End of macro FORTH_DSP_VALUEHL
39e7			;		push hl 
39e7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39e7 cd b2 23			call macro_forth_dsp_pop 
39ea				endm 
# End of macro FORTH_DSP_POP
39ea			;		pop hl 
39ea 3e 00				ld a,0 
39ec bd					cp l 
39ed 28 04				jr z, .not2t 
39ef 2e 00				ld l, 0 
39f1 18 02				jr .notip 
39f3			 
39f3 2e ff		.not2t:		ld l, 255 
39f5			 
39f5 26 00		.notip:		ld h, 0	 
39f7			 
39f7 cd 03 21				call forth_push_numhl 
39fa					NEXTW 
39fa c3 b0 24			jp macro_next 
39fd				endm 
# End of macro NEXTW
39fd			 
39fd			.IS: 
39fd				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
39fd 2d				db WORD_SYS_CORE+25             
39fe 23 3a			dw .LZERO            
3a00 03				db 2 + 1 
3a01 .. 00			db "IS",0              
3a04				endm 
# End of macro CWHEAD
3a04			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3a04					if DEBUG_FORTH_WORDS_KEY 
3a04						DMARK "IS." 
3a04 f5				push af  
3a05 3a 19 3a			ld a, (.dmark)  
3a08 32 a6 fd			ld (debug_mark),a  
3a0b 3a 1a 3a			ld a, (.dmark+1)  
3a0e 32 a7 fd			ld (debug_mark+1),a  
3a11 3a 1b 3a			ld a, (.dmark+2)  
3a14 32 a8 fd			ld (debug_mark+2),a  
3a17 18 03			jr .pastdmark  
3a19 ..			.dmark: db "IS."  
3a1c f1			.pastdmark: pop af  
3a1d			endm  
# End of macro DMARK
3a1d						CALLMONITOR 
3a1d cd aa fd			call debug_vector  
3a20				endm  
# End of macro CALLMONITOR
3a20					endif 
3a20					NEXTW 
3a20 c3 b0 24			jp macro_next 
3a23				endm 
# End of macro NEXTW
3a23			.LZERO: 
3a23				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3a23 2d				db WORD_SYS_CORE+25             
3a24 2d 3a			dw .TZERO            
3a26 03				db 2 + 1 
3a27 .. 00			db "0<",0              
3a2a				endm 
# End of macro CWHEAD
3a2a			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3a2a					NEXTW 
3a2a c3 b0 24			jp macro_next 
3a2d				endm 
# End of macro NEXTW
3a2d			.TZERO: 
3a2d				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3a2d 2e				db WORD_SYS_CORE+26             
3a2e 74 3a			dw .LESS            
3a30 03				db 2 + 1 
3a31 .. 00			db "0=",0              
3a34				endm 
# End of macro CWHEAD
3a34			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3a34				; TODO add floating point number detection 
3a34					;v5 FORTH_DSP_VALUE 
3a34					if DEBUG_FORTH_WORDS_KEY 
3a34						DMARK "0=." 
3a34 f5				push af  
3a35 3a 49 3a			ld a, (.dmark)  
3a38 32 a6 fd			ld (debug_mark),a  
3a3b 3a 4a 3a			ld a, (.dmark+1)  
3a3e 32 a7 fd			ld (debug_mark+1),a  
3a41 3a 4b 3a			ld a, (.dmark+2)  
3a44 32 a8 fd			ld (debug_mark+2),a  
3a47 18 03			jr .pastdmark  
3a49 ..			.dmark: db "0=."  
3a4c f1			.pastdmark: pop af  
3a4d			endm  
# End of macro DMARK
3a4d						CALLMONITOR 
3a4d cd aa fd			call debug_vector  
3a50				endm  
# End of macro CALLMONITOR
3a50					endif 
3a50					FORTH_DSP 
3a50 cd c0 22			call macro_forth_dsp 
3a53				endm 
# End of macro FORTH_DSP
3a53 7e					ld a,(hl)	; get type of value on TOS 
3a54 fe 02				cp DS_TYPE_INUM  
3a56 28 00				jr z, .tz_inum 
3a58			 
3a58				if FORTH_ENABLE_FLOATMATH 
3a58					jr .tz_done 
3a58			 
3a58				endif 
3a58					 
3a58			 
3a58			.tz_inum: 
3a58					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a58 cd fa 22			call macro_dsp_valuehl 
3a5b				endm 
# End of macro FORTH_DSP_VALUEHL
3a5b			 
3a5b			;		push hl 
3a5b			 
3a5b					; destroy value TOS 
3a5b			 
3a5b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a5b cd b2 23			call macro_forth_dsp_pop 
3a5e				endm 
# End of macro FORTH_DSP_POP
3a5e			 
3a5e			;		pop hl 
3a5e			 
3a5e 3e 00				ld a,0 
3a60			 
3a60 bd					cp l 
3a61 20 08				jr nz, .tz_notzero 
3a63			 
3a63 bc					cp h 
3a64			 
3a64 20 05				jr nz, .tz_notzero 
3a66			 
3a66			 
3a66 21 01 00				ld hl, FORTH_TRUE 
3a69 18 03				jr .tz_done 
3a6b			 
3a6b 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3a6e			 
3a6e					; push value back onto stack for another op etc 
3a6e			 
3a6e			.tz_done: 
3a6e cd 03 21				call forth_push_numhl 
3a71			 
3a71					NEXTW 
3a71 c3 b0 24			jp macro_next 
3a74				endm 
# End of macro NEXTW
3a74			.LESS: 
3a74				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3a74 2f				db WORD_SYS_CORE+27             
3a75 dd 3a			dw .GT            
3a77 02				db 1 + 1 
3a78 .. 00			db "<",0              
3a7a				endm 
# End of macro CWHEAD
3a7a			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3a7a				; TODO add floating point number detection 
3a7a					if DEBUG_FORTH_WORDS_KEY 
3a7a						DMARK "LES" 
3a7a f5				push af  
3a7b 3a 8f 3a			ld a, (.dmark)  
3a7e 32 a6 fd			ld (debug_mark),a  
3a81 3a 90 3a			ld a, (.dmark+1)  
3a84 32 a7 fd			ld (debug_mark+1),a  
3a87 3a 91 3a			ld a, (.dmark+2)  
3a8a 32 a8 fd			ld (debug_mark+2),a  
3a8d 18 03			jr .pastdmark  
3a8f ..			.dmark: db "LES"  
3a92 f1			.pastdmark: pop af  
3a93			endm  
# End of macro DMARK
3a93						CALLMONITOR 
3a93 cd aa fd			call debug_vector  
3a96				endm  
# End of macro CALLMONITOR
3a96					endif 
3a96					FORTH_DSP 
3a96 cd c0 22			call macro_forth_dsp 
3a99				endm 
# End of macro FORTH_DSP
3a99					;v5 FORTH_DSP_VALUE 
3a99 7e					ld a,(hl)	; get type of value on TOS 
3a9a fe 02				cp DS_TYPE_INUM  
3a9c 28 00				jr z, .less_inum 
3a9e			 
3a9e				if FORTH_ENABLE_FLOATMATH 
3a9e					jr .less_done 
3a9e			 
3a9e				endif 
3a9e					 
3a9e			 
3a9e			.less_inum: 
3a9e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a9e cd fa 22			call macro_dsp_valuehl 
3aa1				endm 
# End of macro FORTH_DSP_VALUEHL
3aa1			 
3aa1 e5					push hl  ; u2 
3aa2			 
3aa2					; destroy value TOS 
3aa2			 
3aa2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aa2 cd b2 23			call macro_forth_dsp_pop 
3aa5				endm 
# End of macro FORTH_DSP_POP
3aa5			 
3aa5			 
3aa5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3aa5 cd fa 22			call macro_dsp_valuehl 
3aa8				endm 
# End of macro FORTH_DSP_VALUEHL
3aa8			 
3aa8 e5					push hl    ; u1 
3aa9			 
3aa9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aa9 cd b2 23			call macro_forth_dsp_pop 
3aac				endm 
# End of macro FORTH_DSP_POP
3aac			 
3aac			 
3aac b7			 or a      ;clear carry flag 
3aad 01 00 00		 ld bc, FORTH_FALSE 
3ab0 e1			  pop hl    ; u1 
3ab1 d1			  pop de    ; u2 
3ab2 ed 52		  sbc hl,de 
3ab4 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3ab6			 
3ab6 01 01 00		 ld bc, FORTH_TRUE 
3ab9			.lscont:  
3ab9 c5					push bc 
3aba e1					pop hl 
3abb			 
3abb					if DEBUG_FORTH_WORDS 
3abb						DMARK "LT1" 
3abb f5				push af  
3abc 3a d0 3a			ld a, (.dmark)  
3abf 32 a6 fd			ld (debug_mark),a  
3ac2 3a d1 3a			ld a, (.dmark+1)  
3ac5 32 a7 fd			ld (debug_mark+1),a  
3ac8 3a d2 3a			ld a, (.dmark+2)  
3acb 32 a8 fd			ld (debug_mark+2),a  
3ace 18 03			jr .pastdmark  
3ad0 ..			.dmark: db "LT1"  
3ad3 f1			.pastdmark: pop af  
3ad4			endm  
# End of macro DMARK
3ad4						CALLMONITOR 
3ad4 cd aa fd			call debug_vector  
3ad7				endm  
# End of macro CALLMONITOR
3ad7					endif 
3ad7 cd 03 21				call forth_push_numhl 
3ada			 
3ada					NEXTW 
3ada c3 b0 24			jp macro_next 
3add				endm 
# End of macro NEXTW
3add			.GT: 
3add				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3add 30				db WORD_SYS_CORE+28             
3ade 46 3b			dw .EQUAL            
3ae0 02				db 1 + 1 
3ae1 .. 00			db ">",0              
3ae3				endm 
# End of macro CWHEAD
3ae3			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3ae3				; TODO add floating point number detection 
3ae3					if DEBUG_FORTH_WORDS_KEY 
3ae3						DMARK "GRT" 
3ae3 f5				push af  
3ae4 3a f8 3a			ld a, (.dmark)  
3ae7 32 a6 fd			ld (debug_mark),a  
3aea 3a f9 3a			ld a, (.dmark+1)  
3aed 32 a7 fd			ld (debug_mark+1),a  
3af0 3a fa 3a			ld a, (.dmark+2)  
3af3 32 a8 fd			ld (debug_mark+2),a  
3af6 18 03			jr .pastdmark  
3af8 ..			.dmark: db "GRT"  
3afb f1			.pastdmark: pop af  
3afc			endm  
# End of macro DMARK
3afc						CALLMONITOR 
3afc cd aa fd			call debug_vector  
3aff				endm  
# End of macro CALLMONITOR
3aff					endif 
3aff					FORTH_DSP 
3aff cd c0 22			call macro_forth_dsp 
3b02				endm 
# End of macro FORTH_DSP
3b02					;FORTH_DSP_VALUE 
3b02 7e					ld a,(hl)	; get type of value on TOS 
3b03 fe 02				cp DS_TYPE_INUM  
3b05 28 00				jr z, .gt_inum 
3b07			 
3b07				if FORTH_ENABLE_FLOATMATH 
3b07					jr .gt_done 
3b07			 
3b07				endif 
3b07					 
3b07			 
3b07			.gt_inum: 
3b07					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b07 cd fa 22			call macro_dsp_valuehl 
3b0a				endm 
# End of macro FORTH_DSP_VALUEHL
3b0a			 
3b0a e5					push hl  ; u2 
3b0b			 
3b0b					; destroy value TOS 
3b0b			 
3b0b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b0b cd b2 23			call macro_forth_dsp_pop 
3b0e				endm 
# End of macro FORTH_DSP_POP
3b0e			 
3b0e			 
3b0e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b0e cd fa 22			call macro_dsp_valuehl 
3b11				endm 
# End of macro FORTH_DSP_VALUEHL
3b11			 
3b11 e5					push hl    ; u1 
3b12			 
3b12					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b12 cd b2 23			call macro_forth_dsp_pop 
3b15				endm 
# End of macro FORTH_DSP_POP
3b15			 
3b15			 
3b15 b7			 or a      ;clear carry flag 
3b16 01 00 00		 ld bc, FORTH_FALSE 
3b19 e1			  pop hl    ; u1 
3b1a d1			  pop de    ; u2 
3b1b ed 52		  sbc hl,de 
3b1d 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3b1f			 
3b1f 01 01 00		 ld bc, FORTH_TRUE 
3b22			.gtcont:  
3b22 c5					push bc 
3b23 e1					pop hl 
3b24			 
3b24					if DEBUG_FORTH_WORDS 
3b24						DMARK "GT1" 
3b24 f5				push af  
3b25 3a 39 3b			ld a, (.dmark)  
3b28 32 a6 fd			ld (debug_mark),a  
3b2b 3a 3a 3b			ld a, (.dmark+1)  
3b2e 32 a7 fd			ld (debug_mark+1),a  
3b31 3a 3b 3b			ld a, (.dmark+2)  
3b34 32 a8 fd			ld (debug_mark+2),a  
3b37 18 03			jr .pastdmark  
3b39 ..			.dmark: db "GT1"  
3b3c f1			.pastdmark: pop af  
3b3d			endm  
# End of macro DMARK
3b3d						CALLMONITOR 
3b3d cd aa fd			call debug_vector  
3b40				endm  
# End of macro CALLMONITOR
3b40					endif 
3b40 cd 03 21				call forth_push_numhl 
3b43			 
3b43					NEXTW 
3b43 c3 b0 24			jp macro_next 
3b46				endm 
# End of macro NEXTW
3b46			.EQUAL: 
3b46				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3b46 31				db WORD_SYS_CORE+29             
3b47 b1 3b			dw .ENDLOGIC            
3b49 02				db 1 + 1 
3b4a .. 00			db "=",0              
3b4c				endm 
# End of macro CWHEAD
3b4c			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3b4c				; TODO add floating point number detection 
3b4c					if DEBUG_FORTH_WORDS_KEY 
3b4c						DMARK "EQ." 
3b4c f5				push af  
3b4d 3a 61 3b			ld a, (.dmark)  
3b50 32 a6 fd			ld (debug_mark),a  
3b53 3a 62 3b			ld a, (.dmark+1)  
3b56 32 a7 fd			ld (debug_mark+1),a  
3b59 3a 63 3b			ld a, (.dmark+2)  
3b5c 32 a8 fd			ld (debug_mark+2),a  
3b5f 18 03			jr .pastdmark  
3b61 ..			.dmark: db "EQ."  
3b64 f1			.pastdmark: pop af  
3b65			endm  
# End of macro DMARK
3b65						CALLMONITOR 
3b65 cd aa fd			call debug_vector  
3b68				endm  
# End of macro CALLMONITOR
3b68					endif 
3b68					FORTH_DSP 
3b68 cd c0 22			call macro_forth_dsp 
3b6b				endm 
# End of macro FORTH_DSP
3b6b					;v5 FORTH_DSP_VALUE 
3b6b 7e					ld a,(hl)	; get type of value on TOS 
3b6c fe 02				cp DS_TYPE_INUM  
3b6e 28 00				jr z, .eq_inum 
3b70			 
3b70				if FORTH_ENABLE_FLOATMATH 
3b70					jr .eq_done 
3b70			 
3b70				endif 
3b70					 
3b70			 
3b70			.eq_inum: 
3b70					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b70 cd fa 22			call macro_dsp_valuehl 
3b73				endm 
# End of macro FORTH_DSP_VALUEHL
3b73			 
3b73 e5					push hl 
3b74			 
3b74					; destroy value TOS 
3b74			 
3b74					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b74 cd b2 23			call macro_forth_dsp_pop 
3b77				endm 
# End of macro FORTH_DSP_POP
3b77			 
3b77			 
3b77					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b77 cd fa 22			call macro_dsp_valuehl 
3b7a				endm 
# End of macro FORTH_DSP_VALUEHL
3b7a			 
3b7a					; one value on hl get other one back 
3b7a			 
3b7a e5					push hl 
3b7b			 
3b7b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b7b cd b2 23			call macro_forth_dsp_pop 
3b7e				endm 
# End of macro FORTH_DSP_POP
3b7e			 
3b7e 0e 00				ld c, FORTH_FALSE 
3b80			 
3b80 e1					pop hl 
3b81 d1					pop de 
3b82			 
3b82 7b					ld a, e 
3b83 bd					cp l 
3b84			 
3b84 20 06				jr nz, .eq_done 
3b86			 
3b86 7a					ld a, d 
3b87 bc					cp h 
3b88			 
3b88 20 02				jr nz, .eq_done 
3b8a			 
3b8a 0e 01				ld c, FORTH_TRUE 
3b8c					 
3b8c			 
3b8c			 
3b8c			.eq_done: 
3b8c			 
3b8c					; TODO push value back onto stack for another op etc 
3b8c			 
3b8c 26 00				ld h, 0 
3b8e 69					ld l, c 
3b8f					if DEBUG_FORTH_WORDS 
3b8f						DMARK "EQ1" 
3b8f f5				push af  
3b90 3a a4 3b			ld a, (.dmark)  
3b93 32 a6 fd			ld (debug_mark),a  
3b96 3a a5 3b			ld a, (.dmark+1)  
3b99 32 a7 fd			ld (debug_mark+1),a  
3b9c 3a a6 3b			ld a, (.dmark+2)  
3b9f 32 a8 fd			ld (debug_mark+2),a  
3ba2 18 03			jr .pastdmark  
3ba4 ..			.dmark: db "EQ1"  
3ba7 f1			.pastdmark: pop af  
3ba8			endm  
# End of macro DMARK
3ba8						CALLMONITOR 
3ba8 cd aa fd			call debug_vector  
3bab				endm  
# End of macro CALLMONITOR
3bab					endif 
3bab cd 03 21				call forth_push_numhl 
3bae			 
3bae					NEXTW 
3bae c3 b0 24			jp macro_next 
3bb1				endm 
# End of macro NEXTW
3bb1			 
3bb1			 
3bb1			.ENDLOGIC: 
3bb1			; eof 
3bb1			 
3bb1			 
# End of file forth_words_logic.asm
3bb1			include "forth_words_maths.asm" 
3bb1			 
3bb1			; | ## Maths Words 
3bb1			 
3bb1			.PLUS:	 
3bb1				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3bb1 15				db WORD_SYS_CORE+1             
3bb2 0f 3c			dw .NEG            
3bb4 02				db 1 + 1 
3bb5 .. 00			db "+",0              
3bb7				endm 
# End of macro CWHEAD
3bb7			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3bb7					if DEBUG_FORTH_WORDS_KEY 
3bb7						DMARK "PLU" 
3bb7 f5				push af  
3bb8 3a cc 3b			ld a, (.dmark)  
3bbb 32 a6 fd			ld (debug_mark),a  
3bbe 3a cd 3b			ld a, (.dmark+1)  
3bc1 32 a7 fd			ld (debug_mark+1),a  
3bc4 3a ce 3b			ld a, (.dmark+2)  
3bc7 32 a8 fd			ld (debug_mark+2),a  
3bca 18 03			jr .pastdmark  
3bcc ..			.dmark: db "PLU"  
3bcf f1			.pastdmark: pop af  
3bd0			endm  
# End of macro DMARK
3bd0						CALLMONITOR 
3bd0 cd aa fd			call debug_vector  
3bd3				endm  
# End of macro CALLMONITOR
3bd3					endif 
3bd3					; add top two values and push back result 
3bd3			 
3bd3					;for v5 FORTH_DSP_VALUE 
3bd3					FORTH_DSP 
3bd3 cd c0 22			call macro_forth_dsp 
3bd6				endm 
# End of macro FORTH_DSP
3bd6 7e					ld a,(hl)	; get type of value on TOS 
3bd7 fe 02				cp DS_TYPE_INUM  
3bd9 28 03				jr z, .dot_inum 
3bdb			 
3bdb					NEXTW 
3bdb c3 b0 24			jp macro_next 
3bde				endm 
# End of macro NEXTW
3bde			 
3bde			; float maths 
3bde			 
3bde				if FORTH_ENABLE_FLOATMATH 
3bde						inc hl      ; now at start of numeric as string 
3bde			 
3bde					if DEBUG_FORTH_MATHS 
3bde						DMARK "ADD" 
3bde				CALLMONITOR 
3bde					endif 
3bde			 
3bde					;ld ix, hl 
3bde					call CON 
3bde			 
3bde			 
3bde					push hl 
3bde					 
3bde					 
3bde			 
3bde						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3bde			 
3bde					; get next number 
3bde			 
3bde						FORTH_DSP_VALUE 
3bde			 
3bde						inc hl      ; now at start of numeric as string 
3bde			 
3bde					;ld ix, hl 
3bde					call CON 
3bde			 
3bde					push hl 
3bde			 
3bde			 
3bde						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bde			 
3bde						; TODO do add 
3bde			 
3bde						call IADD 
3bde			 
3bde						; TODO get result back as ascii 
3bde			 
3bde						; TODO push result  
3bde			 
3bde			 
3bde			 
3bde						jr .dot_done 
3bde				endif 
3bde			 
3bde			.dot_inum: 
3bde			 
3bde			 
3bde					if DEBUG_FORTH_DOT 
3bde						DMARK "+IT" 
3bde f5				push af  
3bdf 3a f3 3b			ld a, (.dmark)  
3be2 32 a6 fd			ld (debug_mark),a  
3be5 3a f4 3b			ld a, (.dmark+1)  
3be8 32 a7 fd			ld (debug_mark+1),a  
3beb 3a f5 3b			ld a, (.dmark+2)  
3bee 32 a8 fd			ld (debug_mark+2),a  
3bf1 18 03			jr .pastdmark  
3bf3 ..			.dmark: db "+IT"  
3bf6 f1			.pastdmark: pop af  
3bf7			endm  
# End of macro DMARK
3bf7				CALLMONITOR 
3bf7 cd aa fd			call debug_vector  
3bfa				endm  
# End of macro CALLMONITOR
3bfa					endif 
3bfa			 
3bfa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bfa cd fa 22			call macro_dsp_valuehl 
3bfd				endm 
# End of macro FORTH_DSP_VALUEHL
3bfd			 
3bfd				; TODO add floating point number detection 
3bfd			 
3bfd e5					push hl 
3bfe			 
3bfe					; destroy value TOS 
3bfe			 
3bfe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bfe cd b2 23			call macro_forth_dsp_pop 
3c01				endm 
# End of macro FORTH_DSP_POP
3c01			 
3c01			 
3c01					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c01 cd fa 22			call macro_dsp_valuehl 
3c04				endm 
# End of macro FORTH_DSP_VALUEHL
3c04			 
3c04					; one value on hl get other one back 
3c04			 
3c04 d1					pop de 
3c05			 
3c05					; do the add 
3c05			 
3c05 19					add hl,de 
3c06			 
3c06					; save it 
3c06			 
3c06			;		push hl	 
3c06			 
3c06					; 
3c06			 
3c06					; destroy value TOS 
3c06			 
3c06					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c06 cd b2 23			call macro_forth_dsp_pop 
3c09				endm 
# End of macro FORTH_DSP_POP
3c09			 
3c09					; TODO push value back onto stack for another op etc 
3c09			 
3c09			;		pop hl 
3c09			 
3c09			.dot_done: 
3c09 cd 03 21				call forth_push_numhl 
3c0c			 
3c0c					NEXTW 
3c0c c3 b0 24			jp macro_next 
3c0f				endm 
# End of macro NEXTW
3c0f			.NEG: 
3c0f			 
3c0f				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3c0f 17				db WORD_SYS_CORE+3             
3c10 52 3c			dw .DIV            
3c12 02				db 1 + 1 
3c13 .. 00			db "-",0              
3c15				endm 
# End of macro CWHEAD
3c15			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3c15					if DEBUG_FORTH_WORDS_KEY 
3c15						DMARK "SUB" 
3c15 f5				push af  
3c16 3a 2a 3c			ld a, (.dmark)  
3c19 32 a6 fd			ld (debug_mark),a  
3c1c 3a 2b 3c			ld a, (.dmark+1)  
3c1f 32 a7 fd			ld (debug_mark+1),a  
3c22 3a 2c 3c			ld a, (.dmark+2)  
3c25 32 a8 fd			ld (debug_mark+2),a  
3c28 18 03			jr .pastdmark  
3c2a ..			.dmark: db "SUB"  
3c2d f1			.pastdmark: pop af  
3c2e			endm  
# End of macro DMARK
3c2e						CALLMONITOR 
3c2e cd aa fd			call debug_vector  
3c31				endm  
# End of macro CALLMONITOR
3c31					endif 
3c31			 
3c31			 
3c31				; TODO add floating point number detection 
3c31					; v5 FORTH_DSP_VALUE 
3c31					FORTH_DSP 
3c31 cd c0 22			call macro_forth_dsp 
3c34				endm 
# End of macro FORTH_DSP
3c34 7e					ld a,(hl)	; get type of value on TOS 
3c35 fe 02				cp DS_TYPE_INUM  
3c37 28 03				jr z, .neg_inum 
3c39			 
3c39					NEXTW 
3c39 c3 b0 24			jp macro_next 
3c3c				endm 
# End of macro NEXTW
3c3c			 
3c3c			; float maths 
3c3c			 
3c3c				if FORTH_ENABLE_FLOATMATH 
3c3c					jr .neg_done 
3c3c			 
3c3c				endif 
3c3c					 
3c3c			 
3c3c			.neg_inum: 
3c3c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c3c cd fa 22			call macro_dsp_valuehl 
3c3f				endm 
# End of macro FORTH_DSP_VALUEHL
3c3f			 
3c3f e5					push hl 
3c40			 
3c40					; destroy value TOS 
3c40			 
3c40					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c40 cd b2 23			call macro_forth_dsp_pop 
3c43				endm 
# End of macro FORTH_DSP_POP
3c43			 
3c43			 
3c43					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c43 cd fa 22			call macro_dsp_valuehl 
3c46				endm 
# End of macro FORTH_DSP_VALUEHL
3c46			 
3c46					; one value on hl get other one back 
3c46			 
3c46 d1					pop de 
3c47			 
3c47					; do the sub 
3c47			;		ex de, hl 
3c47			 
3c47 ed 52				sbc hl,de 
3c49			 
3c49					; save it 
3c49			 
3c49			;		push hl	 
3c49			 
3c49					; 
3c49			 
3c49					; destroy value TOS 
3c49			 
3c49					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c49 cd b2 23			call macro_forth_dsp_pop 
3c4c				endm 
# End of macro FORTH_DSP_POP
3c4c			 
3c4c					; TODO push value back onto stack for another op etc 
3c4c			 
3c4c			;		pop hl 
3c4c			 
3c4c cd 03 21				call forth_push_numhl 
3c4f			.neg_done: 
3c4f			 
3c4f					NEXTW 
3c4f c3 b0 24			jp macro_next 
3c52				endm 
# End of macro NEXTW
3c52			.DIV: 
3c52				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3c52 18				db WORD_SYS_CORE+4             
3c53 9f 3c			dw .MUL            
3c55 02				db 1 + 1 
3c56 .. 00			db "/",0              
3c58				endm 
# End of macro CWHEAD
3c58			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3c58					if DEBUG_FORTH_WORDS_KEY 
3c58						DMARK "DIV" 
3c58 f5				push af  
3c59 3a 6d 3c			ld a, (.dmark)  
3c5c 32 a6 fd			ld (debug_mark),a  
3c5f 3a 6e 3c			ld a, (.dmark+1)  
3c62 32 a7 fd			ld (debug_mark+1),a  
3c65 3a 6f 3c			ld a, (.dmark+2)  
3c68 32 a8 fd			ld (debug_mark+2),a  
3c6b 18 03			jr .pastdmark  
3c6d ..			.dmark: db "DIV"  
3c70 f1			.pastdmark: pop af  
3c71			endm  
# End of macro DMARK
3c71						CALLMONITOR 
3c71 cd aa fd			call debug_vector  
3c74				endm  
# End of macro CALLMONITOR
3c74					endif 
3c74				; TODO add floating point number detection 
3c74					; v5 FORTH_DSP_VALUE 
3c74					FORTH_DSP 
3c74 cd c0 22			call macro_forth_dsp 
3c77				endm 
# End of macro FORTH_DSP
3c77 7e					ld a,(hl)	; get type of value on TOS 
3c78 fe 02				cp DS_TYPE_INUM  
3c7a 28 03				jr z, .div_inum 
3c7c			 
3c7c				if FORTH_ENABLE_FLOATMATH 
3c7c					jr .div_done 
3c7c			 
3c7c				endif 
3c7c					NEXTW 
3c7c c3 b0 24			jp macro_next 
3c7f				endm 
# End of macro NEXTW
3c7f			.div_inum: 
3c7f			 
3c7f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c7f cd fa 22			call macro_dsp_valuehl 
3c82				endm 
# End of macro FORTH_DSP_VALUEHL
3c82			 
3c82 e5					push hl    ; to go to bc 
3c83			 
3c83					; destroy value TOS 
3c83			 
3c83					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c83 cd b2 23			call macro_forth_dsp_pop 
3c86				endm 
# End of macro FORTH_DSP_POP
3c86			 
3c86			 
3c86					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c86 cd fa 22			call macro_dsp_valuehl 
3c89				endm 
# End of macro FORTH_DSP_VALUEHL
3c89			 
3c89					; hl to go to de 
3c89			 
3c89 e5					push hl 
3c8a			 
3c8a c1					pop bc 
3c8b d1					pop de		 
3c8c			 
3c8c			 
3c8c					if DEBUG_FORTH_MATHS 
3c8c						DMARK "DIV" 
3c8c				CALLMONITOR 
3c8c					endif 
3c8c					; one value on hl but move to a get other one back 
3c8c			 
3c8c			        
3c8c cd 2c 0f			call Div16 
3c8f			 
3c8f			;	push af	 
3c8f e5				push hl 
3c90 c5				push bc 
3c91			 
3c91					if DEBUG_FORTH_MATHS 
3c91						DMARK "DI1" 
3c91				CALLMONITOR 
3c91					endif 
3c91			 
3c91					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c91 cd b2 23			call macro_forth_dsp_pop 
3c94				endm 
# End of macro FORTH_DSP_POP
3c94			 
3c94			 
3c94			 
3c94 e1					pop hl    ; result 
3c95			 
3c95 cd 03 21				call forth_push_numhl 
3c98			 
3c98 e1					pop hl    ; reminder 
3c99			;		ld h,0 
3c99			;		ld l,d 
3c99			 
3c99 cd 03 21				call forth_push_numhl 
3c9c			.div_done: 
3c9c					NEXTW 
3c9c c3 b0 24			jp macro_next 
3c9f				endm 
# End of macro NEXTW
3c9f			.MUL: 
3c9f				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3c9f 19				db WORD_SYS_CORE+5             
3ca0 e4 3c			dw .MIN            
3ca2 02				db 1 + 1 
3ca3 .. 00			db "*",0              
3ca5				endm 
# End of macro CWHEAD
3ca5			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3ca5				; TODO add floating point number detection 
3ca5					if DEBUG_FORTH_WORDS_KEY 
3ca5						DMARK "MUL" 
3ca5 f5				push af  
3ca6 3a ba 3c			ld a, (.dmark)  
3ca9 32 a6 fd			ld (debug_mark),a  
3cac 3a bb 3c			ld a, (.dmark+1)  
3caf 32 a7 fd			ld (debug_mark+1),a  
3cb2 3a bc 3c			ld a, (.dmark+2)  
3cb5 32 a8 fd			ld (debug_mark+2),a  
3cb8 18 03			jr .pastdmark  
3cba ..			.dmark: db "MUL"  
3cbd f1			.pastdmark: pop af  
3cbe			endm  
# End of macro DMARK
3cbe						CALLMONITOR 
3cbe cd aa fd			call debug_vector  
3cc1				endm  
# End of macro CALLMONITOR
3cc1					endif 
3cc1					FORTH_DSP 
3cc1 cd c0 22			call macro_forth_dsp 
3cc4				endm 
# End of macro FORTH_DSP
3cc4					; v5 FORTH_DSP_VALUE 
3cc4 7e					ld a,(hl)	; get type of value on TOS 
3cc5 fe 02				cp DS_TYPE_INUM  
3cc7 28 03				jr z, .mul_inum 
3cc9			 
3cc9				if FORTH_ENABLE_FLOATMATH 
3cc9					jr .mul_done 
3cc9			 
3cc9				endif 
3cc9			 
3cc9					NEXTW 
3cc9 c3 b0 24			jp macro_next 
3ccc				endm 
# End of macro NEXTW
3ccc			.mul_inum:	 
3ccc			 
3ccc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ccc cd fa 22			call macro_dsp_valuehl 
3ccf				endm 
# End of macro FORTH_DSP_VALUEHL
3ccf			 
3ccf e5					push hl 
3cd0			 
3cd0					; destroy value TOS 
3cd0			 
3cd0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cd0 cd b2 23			call macro_forth_dsp_pop 
3cd3				endm 
# End of macro FORTH_DSP_POP
3cd3			 
3cd3			 
3cd3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cd3 cd fa 22			call macro_dsp_valuehl 
3cd6				endm 
# End of macro FORTH_DSP_VALUEHL
3cd6			 
3cd6					; one value on hl but move to a get other one back 
3cd6			 
3cd6 7d					ld a, l 
3cd7			 
3cd7 d1					pop de 
3cd8			 
3cd8					; do the mull 
3cd8			;		ex de, hl 
3cd8			 
3cd8 cd 52 0f				call Mult16 
3cdb					; save it 
3cdb			 
3cdb			;		push hl	 
3cdb			 
3cdb					; 
3cdb			 
3cdb					; destroy value TOS 
3cdb			 
3cdb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cdb cd b2 23			call macro_forth_dsp_pop 
3cde				endm 
# End of macro FORTH_DSP_POP
3cde			 
3cde					; TODO push value back onto stack for another op etc 
3cde			 
3cde			;		pop hl 
3cde			 
3cde cd 03 21				call forth_push_numhl 
3ce1			 
3ce1			.mul_done: 
3ce1					NEXTW 
3ce1 c3 b0 24			jp macro_next 
3ce4				endm 
# End of macro NEXTW
3ce4			 
3ce4			 
3ce4			 
3ce4			 
3ce4			.MIN: 
3ce4				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3ce4 49				db WORD_SYS_CORE+53             
3ce5 65 3d			dw .MAX            
3ce7 04				db 3 + 1 
3ce8 .. 00			db "MIN",0              
3cec				endm 
# End of macro CWHEAD
3cec			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3cec					if DEBUG_FORTH_WORDS_KEY 
3cec						DMARK "MIN" 
3cec f5				push af  
3ced 3a 01 3d			ld a, (.dmark)  
3cf0 32 a6 fd			ld (debug_mark),a  
3cf3 3a 02 3d			ld a, (.dmark+1)  
3cf6 32 a7 fd			ld (debug_mark+1),a  
3cf9 3a 03 3d			ld a, (.dmark+2)  
3cfc 32 a8 fd			ld (debug_mark+2),a  
3cff 18 03			jr .pastdmark  
3d01 ..			.dmark: db "MIN"  
3d04 f1			.pastdmark: pop af  
3d05			endm  
# End of macro DMARK
3d05						CALLMONITOR 
3d05 cd aa fd			call debug_vector  
3d08				endm  
# End of macro CALLMONITOR
3d08					endif 
3d08					; get u2 
3d08			 
3d08					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d08 cd fa 22			call macro_dsp_valuehl 
3d0b				endm 
# End of macro FORTH_DSP_VALUEHL
3d0b			 
3d0b e5					push hl   ; u2 
3d0c			 
3d0c					; destroy value TOS 
3d0c			 
3d0c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d0c cd b2 23			call macro_forth_dsp_pop 
3d0f				endm 
# End of macro FORTH_DSP_POP
3d0f			 
3d0f					; get u1 
3d0f			 
3d0f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d0f cd fa 22			call macro_dsp_valuehl 
3d12				endm 
# End of macro FORTH_DSP_VALUEHL
3d12			 
3d12 e5					push hl  ; u1 
3d13			 
3d13					; destroy value TOS 
3d13			 
3d13					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d13 cd b2 23			call macro_forth_dsp_pop 
3d16				endm 
# End of macro FORTH_DSP_POP
3d16			 
3d16 b7			 or a      ;clear carry flag 
3d17 e1			  pop hl    ; u1 
3d18 d1			  pop de    ; u2 
3d19 e5				push hl   ; saved in case hl is lowest 
3d1a ed 52		  sbc hl,de 
3d1c 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3d1e			 
3d1e e1				pop hl 
3d1f					if DEBUG_FORTH_WORDS 
3d1f						DMARK "MIN" 
3d1f f5				push af  
3d20 3a 34 3d			ld a, (.dmark)  
3d23 32 a6 fd			ld (debug_mark),a  
3d26 3a 35 3d			ld a, (.dmark+1)  
3d29 32 a7 fd			ld (debug_mark+1),a  
3d2c 3a 36 3d			ld a, (.dmark+2)  
3d2f 32 a8 fd			ld (debug_mark+2),a  
3d32 18 03			jr .pastdmark  
3d34 ..			.dmark: db "MIN"  
3d37 f1			.pastdmark: pop af  
3d38			endm  
# End of macro DMARK
3d38						CALLMONITOR 
3d38 cd aa fd			call debug_vector  
3d3b				endm  
# End of macro CALLMONITOR
3d3b					endif 
3d3b cd 03 21				call forth_push_numhl 
3d3e			 
3d3e				       NEXTW 
3d3e c3 b0 24			jp macro_next 
3d41				endm 
# End of macro NEXTW
3d41			 
3d41			.mincont:  
3d41 c1				pop bc   ; tidy up 
3d42 eb				ex de , hl  
3d43					if DEBUG_FORTH_WORDS 
3d43						DMARK "MI1" 
3d43 f5				push af  
3d44 3a 58 3d			ld a, (.dmark)  
3d47 32 a6 fd			ld (debug_mark),a  
3d4a 3a 59 3d			ld a, (.dmark+1)  
3d4d 32 a7 fd			ld (debug_mark+1),a  
3d50 3a 5a 3d			ld a, (.dmark+2)  
3d53 32 a8 fd			ld (debug_mark+2),a  
3d56 18 03			jr .pastdmark  
3d58 ..			.dmark: db "MI1"  
3d5b f1			.pastdmark: pop af  
3d5c			endm  
# End of macro DMARK
3d5c						CALLMONITOR 
3d5c cd aa fd			call debug_vector  
3d5f				endm  
# End of macro CALLMONITOR
3d5f					endif 
3d5f cd 03 21				call forth_push_numhl 
3d62			 
3d62				       NEXTW 
3d62 c3 b0 24			jp macro_next 
3d65				endm 
# End of macro NEXTW
3d65			.MAX: 
3d65				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3d65 4a				db WORD_SYS_CORE+54             
3d66 e6 3d			dw .RND16            
3d68 04				db 3 + 1 
3d69 .. 00			db "MAX",0              
3d6d				endm 
# End of macro CWHEAD
3d6d			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3d6d					if DEBUG_FORTH_WORDS_KEY 
3d6d						DMARK "MAX" 
3d6d f5				push af  
3d6e 3a 82 3d			ld a, (.dmark)  
3d71 32 a6 fd			ld (debug_mark),a  
3d74 3a 83 3d			ld a, (.dmark+1)  
3d77 32 a7 fd			ld (debug_mark+1),a  
3d7a 3a 84 3d			ld a, (.dmark+2)  
3d7d 32 a8 fd			ld (debug_mark+2),a  
3d80 18 03			jr .pastdmark  
3d82 ..			.dmark: db "MAX"  
3d85 f1			.pastdmark: pop af  
3d86			endm  
# End of macro DMARK
3d86						CALLMONITOR 
3d86 cd aa fd			call debug_vector  
3d89				endm  
# End of macro CALLMONITOR
3d89					endif 
3d89					; get u2 
3d89			 
3d89					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d89 cd fa 22			call macro_dsp_valuehl 
3d8c				endm 
# End of macro FORTH_DSP_VALUEHL
3d8c			 
3d8c e5					push hl   ; u2 
3d8d			 
3d8d					; destroy value TOS 
3d8d			 
3d8d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d8d cd b2 23			call macro_forth_dsp_pop 
3d90				endm 
# End of macro FORTH_DSP_POP
3d90			 
3d90					; get u1 
3d90			 
3d90					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d90 cd fa 22			call macro_dsp_valuehl 
3d93				endm 
# End of macro FORTH_DSP_VALUEHL
3d93			 
3d93 e5					push hl  ; u1 
3d94			 
3d94					; destroy value TOS 
3d94			 
3d94					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d94 cd b2 23			call macro_forth_dsp_pop 
3d97				endm 
# End of macro FORTH_DSP_POP
3d97			 
3d97 b7			 or a      ;clear carry flag 
3d98 e1			  pop hl    ; u1 
3d99 d1			  pop de    ; u2 
3d9a e5				push hl   ; saved in case hl is lowest 
3d9b ed 52		  sbc hl,de 
3d9d 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3d9f			 
3d9f e1				pop hl 
3da0					if DEBUG_FORTH_WORDS 
3da0						DMARK "MAX" 
3da0 f5				push af  
3da1 3a b5 3d			ld a, (.dmark)  
3da4 32 a6 fd			ld (debug_mark),a  
3da7 3a b6 3d			ld a, (.dmark+1)  
3daa 32 a7 fd			ld (debug_mark+1),a  
3dad 3a b7 3d			ld a, (.dmark+2)  
3db0 32 a8 fd			ld (debug_mark+2),a  
3db3 18 03			jr .pastdmark  
3db5 ..			.dmark: db "MAX"  
3db8 f1			.pastdmark: pop af  
3db9			endm  
# End of macro DMARK
3db9						CALLMONITOR 
3db9 cd aa fd			call debug_vector  
3dbc				endm  
# End of macro CALLMONITOR
3dbc					endif 
3dbc cd 03 21				call forth_push_numhl 
3dbf			 
3dbf				       NEXTW 
3dbf c3 b0 24			jp macro_next 
3dc2				endm 
# End of macro NEXTW
3dc2			 
3dc2			.maxcont:  
3dc2 c1				pop bc   ; tidy up 
3dc3 eb				ex de , hl  
3dc4					if DEBUG_FORTH_WORDS 
3dc4						DMARK "MA1" 
3dc4 f5				push af  
3dc5 3a d9 3d			ld a, (.dmark)  
3dc8 32 a6 fd			ld (debug_mark),a  
3dcb 3a da 3d			ld a, (.dmark+1)  
3dce 32 a7 fd			ld (debug_mark+1),a  
3dd1 3a db 3d			ld a, (.dmark+2)  
3dd4 32 a8 fd			ld (debug_mark+2),a  
3dd7 18 03			jr .pastdmark  
3dd9 ..			.dmark: db "MA1"  
3ddc f1			.pastdmark: pop af  
3ddd			endm  
# End of macro DMARK
3ddd						CALLMONITOR 
3ddd cd aa fd			call debug_vector  
3de0				endm  
# End of macro CALLMONITOR
3de0					endif 
3de0 cd 03 21				call forth_push_numhl 
3de3				       NEXTW 
3de3 c3 b0 24			jp macro_next 
3de6				endm 
# End of macro NEXTW
3de6			 
3de6			.RND16: 
3de6				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3de6 4e				db WORD_SYS_CORE+58             
3de7 15 3e			dw .RND8            
3de9 06				db 5 + 1 
3dea .. 00			db "RND16",0              
3df0				endm 
# End of macro CWHEAD
3df0			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3df0					if DEBUG_FORTH_WORDS_KEY 
3df0						DMARK "R16" 
3df0 f5				push af  
3df1 3a 05 3e			ld a, (.dmark)  
3df4 32 a6 fd			ld (debug_mark),a  
3df7 3a 06 3e			ld a, (.dmark+1)  
3dfa 32 a7 fd			ld (debug_mark+1),a  
3dfd 3a 07 3e			ld a, (.dmark+2)  
3e00 32 a8 fd			ld (debug_mark+2),a  
3e03 18 03			jr .pastdmark  
3e05 ..			.dmark: db "R16"  
3e08 f1			.pastdmark: pop af  
3e09			endm  
# End of macro DMARK
3e09						CALLMONITOR 
3e09 cd aa fd			call debug_vector  
3e0c				endm  
# End of macro CALLMONITOR
3e0c					endif 
3e0c cd f6 0e				call prng16  
3e0f cd 03 21				call forth_push_numhl 
3e12				       NEXTW 
3e12 c3 b0 24			jp macro_next 
3e15				endm 
# End of macro NEXTW
3e15			.RND8: 
3e15				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3e15 60				db WORD_SYS_CORE+76             
3e16 4a 3e			dw .RND            
3e18 05				db 4 + 1 
3e19 .. 00			db "RND8",0              
3e1e				endm 
# End of macro CWHEAD
3e1e			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3e1e					if DEBUG_FORTH_WORDS_KEY 
3e1e						DMARK "RN8" 
3e1e f5				push af  
3e1f 3a 33 3e			ld a, (.dmark)  
3e22 32 a6 fd			ld (debug_mark),a  
3e25 3a 34 3e			ld a, (.dmark+1)  
3e28 32 a7 fd			ld (debug_mark+1),a  
3e2b 3a 35 3e			ld a, (.dmark+2)  
3e2e 32 a8 fd			ld (debug_mark+2),a  
3e31 18 03			jr .pastdmark  
3e33 ..			.dmark: db "RN8"  
3e36 f1			.pastdmark: pop af  
3e37			endm  
# End of macro DMARK
3e37						CALLMONITOR 
3e37 cd aa fd			call debug_vector  
3e3a				endm  
# End of macro CALLMONITOR
3e3a					endif 
3e3a 2a e4 fa				ld hl,(xrandc) 
3e3d 23					inc hl 
3e3e cd 10 0f				call xrnd 
3e41 6f					ld l,a	 
3e42 26 00				ld h,0 
3e44 cd 03 21				call forth_push_numhl 
3e47				       NEXTW 
3e47 c3 b0 24			jp macro_next 
3e4a				endm 
# End of macro NEXTW
3e4a			.RND: 
3e4a				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3e4a 60				db WORD_SYS_CORE+76             
3e4b 50 3f			dw .ENDMATHS            
3e4d 04				db 3 + 1 
3e4e .. 00			db "RND",0              
3e52				endm 
# End of macro CWHEAD
3e52			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3e52			 
3e52					if DEBUG_FORTH_WORDS_KEY 
3e52						DMARK "RND" 
3e52 f5				push af  
3e53 3a 67 3e			ld a, (.dmark)  
3e56 32 a6 fd			ld (debug_mark),a  
3e59 3a 68 3e			ld a, (.dmark+1)  
3e5c 32 a7 fd			ld (debug_mark+1),a  
3e5f 3a 69 3e			ld a, (.dmark+2)  
3e62 32 a8 fd			ld (debug_mark+2),a  
3e65 18 03			jr .pastdmark  
3e67 ..			.dmark: db "RND"  
3e6a f1			.pastdmark: pop af  
3e6b			endm  
# End of macro DMARK
3e6b						CALLMONITOR 
3e6b cd aa fd			call debug_vector  
3e6e				endm  
# End of macro CALLMONITOR
3e6e					endif 
3e6e					 
3e6e					FORTH_DSP_VALUEHL    ; upper range 
3e6e cd fa 22			call macro_dsp_valuehl 
3e71				endm 
# End of macro FORTH_DSP_VALUEHL
3e71			 
3e71 22 e8 fa				ld (LFSRSeed), hl	 
3e74			 
3e74					if DEBUG_FORTH_WORDS 
3e74						DMARK "RN1" 
3e74 f5				push af  
3e75 3a 89 3e			ld a, (.dmark)  
3e78 32 a6 fd			ld (debug_mark),a  
3e7b 3a 8a 3e			ld a, (.dmark+1)  
3e7e 32 a7 fd			ld (debug_mark+1),a  
3e81 3a 8b 3e			ld a, (.dmark+2)  
3e84 32 a8 fd			ld (debug_mark+2),a  
3e87 18 03			jr .pastdmark  
3e89 ..			.dmark: db "RN1"  
3e8c f1			.pastdmark: pop af  
3e8d			endm  
# End of macro DMARK
3e8d						CALLMONITOR 
3e8d cd aa fd			call debug_vector  
3e90				endm  
# End of macro CALLMONITOR
3e90					endif 
3e90					FORTH_DSP_POP 
3e90 cd b2 23			call macro_forth_dsp_pop 
3e93				endm 
# End of macro FORTH_DSP_POP
3e93			 
3e93					FORTH_DSP_VALUEHL    ; low range 
3e93 cd fa 22			call macro_dsp_valuehl 
3e96				endm 
# End of macro FORTH_DSP_VALUEHL
3e96			 
3e96					if DEBUG_FORTH_WORDS 
3e96						DMARK "RN2" 
3e96 f5				push af  
3e97 3a ab 3e			ld a, (.dmark)  
3e9a 32 a6 fd			ld (debug_mark),a  
3e9d 3a ac 3e			ld a, (.dmark+1)  
3ea0 32 a7 fd			ld (debug_mark+1),a  
3ea3 3a ad 3e			ld a, (.dmark+2)  
3ea6 32 a8 fd			ld (debug_mark+2),a  
3ea9 18 03			jr .pastdmark  
3eab ..			.dmark: db "RN2"  
3eae f1			.pastdmark: pop af  
3eaf			endm  
# End of macro DMARK
3eaf						CALLMONITOR 
3eaf cd aa fd			call debug_vector  
3eb2				endm  
# End of macro CALLMONITOR
3eb2					endif 
3eb2 22 ea fa				ld (LFSRSeed+2), hl 
3eb5			 
3eb5					FORTH_DSP_POP 
3eb5 cd b2 23			call macro_forth_dsp_pop 
3eb8				endm 
# End of macro FORTH_DSP_POP
3eb8			 
3eb8 e5					push hl 
3eb9			 
3eb9 e1			.inrange:	pop hl 
3eba cd f6 0e				call prng16  
3ebd					if DEBUG_FORTH_WORDS 
3ebd						DMARK "RN3" 
3ebd f5				push af  
3ebe 3a d2 3e			ld a, (.dmark)  
3ec1 32 a6 fd			ld (debug_mark),a  
3ec4 3a d3 3e			ld a, (.dmark+1)  
3ec7 32 a7 fd			ld (debug_mark+1),a  
3eca 3a d4 3e			ld a, (.dmark+2)  
3ecd 32 a8 fd			ld (debug_mark+2),a  
3ed0 18 03			jr .pastdmark  
3ed2 ..			.dmark: db "RN3"  
3ed5 f1			.pastdmark: pop af  
3ed6			endm  
# End of macro DMARK
3ed6						CALLMONITOR 
3ed6 cd aa fd			call debug_vector  
3ed9				endm  
# End of macro CALLMONITOR
3ed9					endif 
3ed9					 
3ed9					; if the range is 8bit knock out the high byte 
3ed9			 
3ed9 ed 5b e8 fa			ld de, (LFSRSeed)     ; check high level 
3edd			 
3edd 3e 00				ld a, 0 
3edf ba					cp d  
3ee0 20 1e				jr nz, .hirange 
3ee2 26 00				ld h, 0   ; knock it down to 8bit 
3ee4			 
3ee4					if DEBUG_FORTH_WORDS 
3ee4						DMARK "RNk" 
3ee4 f5				push af  
3ee5 3a f9 3e			ld a, (.dmark)  
3ee8 32 a6 fd			ld (debug_mark),a  
3eeb 3a fa 3e			ld a, (.dmark+1)  
3eee 32 a7 fd			ld (debug_mark+1),a  
3ef1 3a fb 3e			ld a, (.dmark+2)  
3ef4 32 a8 fd			ld (debug_mark+2),a  
3ef7 18 03			jr .pastdmark  
3ef9 ..			.dmark: db "RNk"  
3efc f1			.pastdmark: pop af  
3efd			endm  
# End of macro DMARK
3efd						CALLMONITOR 
3efd cd aa fd			call debug_vector  
3f00				endm  
# End of macro CALLMONITOR
3f00					endif 
3f00			.hirange:   
3f00 e5					push hl  
3f01 b7					or a  
3f02 ed 52		                sbc hl, de 
3f04			 
3f04					;call cmp16 
3f04			 
3f04 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3f06 e1					pop hl 
3f07 e5					push hl 
3f08			 
3f08					if DEBUG_FORTH_WORDS 
3f08						DMARK "RN4" 
3f08 f5				push af  
3f09 3a 1d 3f			ld a, (.dmark)  
3f0c 32 a6 fd			ld (debug_mark),a  
3f0f 3a 1e 3f			ld a, (.dmark+1)  
3f12 32 a7 fd			ld (debug_mark+1),a  
3f15 3a 1f 3f			ld a, (.dmark+2)  
3f18 32 a8 fd			ld (debug_mark+2),a  
3f1b 18 03			jr .pastdmark  
3f1d ..			.dmark: db "RN4"  
3f20 f1			.pastdmark: pop af  
3f21			endm  
# End of macro DMARK
3f21						CALLMONITOR 
3f21 cd aa fd			call debug_vector  
3f24				endm  
# End of macro CALLMONITOR
3f24					endif 
3f24 ed 5b ea fa			ld de, (LFSRSeed+2)   ; check low range 
3f28					;call cmp16 
3f28				 
3f28 b7					or a  
3f29 ed 52		                sbc hl, de 
3f2b 38 8c				jr c, .inrange 
3f2d			 
3f2d e1					pop hl 
3f2e					 
3f2e					if DEBUG_FORTH_WORDS 
3f2e						DMARK "RNd" 
3f2e f5				push af  
3f2f 3a 43 3f			ld a, (.dmark)  
3f32 32 a6 fd			ld (debug_mark),a  
3f35 3a 44 3f			ld a, (.dmark+1)  
3f38 32 a7 fd			ld (debug_mark+1),a  
3f3b 3a 45 3f			ld a, (.dmark+2)  
3f3e 32 a8 fd			ld (debug_mark+2),a  
3f41 18 03			jr .pastdmark  
3f43 ..			.dmark: db "RNd"  
3f46 f1			.pastdmark: pop af  
3f47			endm  
# End of macro DMARK
3f47						CALLMONITOR 
3f47 cd aa fd			call debug_vector  
3f4a				endm  
# End of macro CALLMONITOR
3f4a					endif 
3f4a			 
3f4a			 
3f4a cd 03 21				call forth_push_numhl 
3f4d				       NEXTW 
3f4d c3 b0 24			jp macro_next 
3f50				endm 
# End of macro NEXTW
3f50			 
3f50			.ENDMATHS: 
3f50			 
3f50			; eof 
3f50			 
# End of file forth_words_maths.asm
3f50			include "forth_words_display.asm" 
3f50			 
3f50			; | ## Display Words 
3f50			 
3f50			.ACT: 
3f50			 
3f50				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3f50 62				db WORD_SYS_CORE+78             
3f51 9c 3f			dw .INFO            
3f53 07				db 6 + 1 
3f54 .. 00			db "ACTIVE",0              
3f5b				endm 
# End of macro CWHEAD
3f5b			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3f5b			;  
3f5b			; | | To display a pulsing activity indicator in a processing loop do this... 
3f5b			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
3f5b			 
3f5b					if DEBUG_FORTH_WORDS_KEY 
3f5b						DMARK "ACT" 
3f5b f5				push af  
3f5c 3a 70 3f			ld a, (.dmark)  
3f5f 32 a6 fd			ld (debug_mark),a  
3f62 3a 71 3f			ld a, (.dmark+1)  
3f65 32 a7 fd			ld (debug_mark+1),a  
3f68 3a 72 3f			ld a, (.dmark+2)  
3f6b 32 a8 fd			ld (debug_mark+2),a  
3f6e 18 03			jr .pastdmark  
3f70 ..			.dmark: db "ACT"  
3f73 f1			.pastdmark: pop af  
3f74			endm  
# End of macro DMARK
3f74						CALLMONITOR 
3f74 cd aa fd			call debug_vector  
3f77				endm  
# End of macro CALLMONITOR
3f77					endif 
3f77 cd f2 0c				call active 
3f7a					if DEBUG_FORTH_WORDS 
3f7a						DMARK "ACp" 
3f7a f5				push af  
3f7b 3a 8f 3f			ld a, (.dmark)  
3f7e 32 a6 fd			ld (debug_mark),a  
3f81 3a 90 3f			ld a, (.dmark+1)  
3f84 32 a7 fd			ld (debug_mark+1),a  
3f87 3a 91 3f			ld a, (.dmark+2)  
3f8a 32 a8 fd			ld (debug_mark+2),a  
3f8d 18 03			jr .pastdmark  
3f8f ..			.dmark: db "ACp"  
3f92 f1			.pastdmark: pop af  
3f93			endm  
# End of macro DMARK
3f93						CALLMONITOR 
3f93 cd aa fd			call debug_vector  
3f96				endm  
# End of macro CALLMONITOR
3f96					endif 
3f96 cd 71 21				call forth_push_str 
3f99			 
3f99					NEXTW 
3f99 c3 b0 24			jp macro_next 
3f9c				endm 
# End of macro NEXTW
3f9c			.INFO: 
3f9c			 
3f9c				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3f9c 62				db WORD_SYS_CORE+78             
3f9d b9 3f			dw .ATP            
3f9f 05				db 4 + 1 
3fa0 .. 00			db "INFO",0              
3fa5				endm 
# End of macro CWHEAD
3fa5			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3fa5					FORTH_DSP_VALUEHL 
3fa5 cd fa 22			call macro_dsp_valuehl 
3fa8				endm 
# End of macro FORTH_DSP_VALUEHL
3fa8			 
3fa8					FORTH_DSP_POP 
3fa8 cd b2 23			call macro_forth_dsp_pop 
3fab				endm 
# End of macro FORTH_DSP_POP
3fab			 
3fab e5					push hl 
3fac			 
3fac					FORTH_DSP_VALUEHL 
3fac cd fa 22			call macro_dsp_valuehl 
3faf				endm 
# End of macro FORTH_DSP_VALUEHL
3faf			 
3faf					FORTH_DSP_POP 
3faf cd b2 23			call macro_forth_dsp_pop 
3fb2				endm 
# End of macro FORTH_DSP_POP
3fb2			 
3fb2 d1					pop de 
3fb3			 
3fb3 cd 2c 0d				call info_panel 
3fb6			 
3fb6			 
3fb6					NEXTW 
3fb6 c3 b0 24			jp macro_next 
3fb9				endm 
# End of macro NEXTW
3fb9			.ATP: 
3fb9				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3fb9 62				db WORD_SYS_CORE+78             
3fba 30 40			dw .FB            
3fbc 04				db 3 + 1 
3fbd .. 00			db "AT?",0              
3fc1				endm 
# End of macro CWHEAD
3fc1			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3fc1					if DEBUG_FORTH_WORDS_KEY 
3fc1						DMARK "AT?" 
3fc1 f5				push af  
3fc2 3a d6 3f			ld a, (.dmark)  
3fc5 32 a6 fd			ld (debug_mark),a  
3fc8 3a d7 3f			ld a, (.dmark+1)  
3fcb 32 a7 fd			ld (debug_mark+1),a  
3fce 3a d8 3f			ld a, (.dmark+2)  
3fd1 32 a8 fd			ld (debug_mark+2),a  
3fd4 18 03			jr .pastdmark  
3fd6 ..			.dmark: db "AT?"  
3fd9 f1			.pastdmark: pop af  
3fda			endm  
# End of macro DMARK
3fda						CALLMONITOR 
3fda cd aa fd			call debug_vector  
3fdd				endm  
# End of macro CALLMONITOR
3fdd					endif 
3fdd 3a 99 f9				ld a, (f_cursor_ptr) 
3fe0			 
3fe0			if DEBUG_FORTH_WORDS 
3fe0				DMARK "AT?" 
3fe0 f5				push af  
3fe1 3a f5 3f			ld a, (.dmark)  
3fe4 32 a6 fd			ld (debug_mark),a  
3fe7 3a f6 3f			ld a, (.dmark+1)  
3fea 32 a7 fd			ld (debug_mark+1),a  
3fed 3a f7 3f			ld a, (.dmark+2)  
3ff0 32 a8 fd			ld (debug_mark+2),a  
3ff3 18 03			jr .pastdmark  
3ff5 ..			.dmark: db "AT?"  
3ff8 f1			.pastdmark: pop af  
3ff9			endm  
# End of macro DMARK
3ff9				CALLMONITOR 
3ff9 cd aa fd			call debug_vector  
3ffc				endm  
# End of macro CALLMONITOR
3ffc			endif	 
3ffc					; count the number of rows 
3ffc			 
3ffc 06 00				ld b, 0 
3ffe 4f			.atpr:		ld c, a    ; save in case we go below zero 
3fff d6 28				sub display_cols 
4001 f2 07 40				jp p, .atprunder 
4004 04					inc b 
4005 18 f7				jr .atpr 
4007			.atprunder:	 
4007			if DEBUG_FORTH_WORDS 
4007				DMARK "A?2" 
4007 f5				push af  
4008 3a 1c 40			ld a, (.dmark)  
400b 32 a6 fd			ld (debug_mark),a  
400e 3a 1d 40			ld a, (.dmark+1)  
4011 32 a7 fd			ld (debug_mark+1),a  
4014 3a 1e 40			ld a, (.dmark+2)  
4017 32 a8 fd			ld (debug_mark+2),a  
401a 18 03			jr .pastdmark  
401c ..			.dmark: db "A?2"  
401f f1			.pastdmark: pop af  
4020			endm  
# End of macro DMARK
4020				CALLMONITOR 
4020 cd aa fd			call debug_vector  
4023				endm  
# End of macro CALLMONITOR
4023			endif	 
4023 26 00				ld h, 0 
4025 69					ld l, c 
4026 cd 03 21				call forth_push_numhl 
4029 68					ld l, b  
402a cd 03 21				call forth_push_numhl 
402d			 
402d			 
402d				NEXTW 
402d c3 b0 24			jp macro_next 
4030				endm 
# End of macro NEXTW
4030			 
4030			.FB: 
4030				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
4030 1b				db WORD_SYS_CORE+7             
4031 7e 40			dw .EMIT            
4033 03				db 2 + 1 
4034 .. 00			db "FB",0              
4037				endm 
# End of macro CWHEAD
4037			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
4037			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
4037			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
4037			; | | If automatic display is off then updates will not be shown until DRAW is used. 
4037					if DEBUG_FORTH_WORDS_KEY 
4037						DMARK "FB." 
4037 f5				push af  
4038 3a 4c 40			ld a, (.dmark)  
403b 32 a6 fd			ld (debug_mark),a  
403e 3a 4d 40			ld a, (.dmark+1)  
4041 32 a7 fd			ld (debug_mark+1),a  
4044 3a 4e 40			ld a, (.dmark+2)  
4047 32 a8 fd			ld (debug_mark+2),a  
404a 18 03			jr .pastdmark  
404c ..			.dmark: db "FB."  
404f f1			.pastdmark: pop af  
4050			endm  
# End of macro DMARK
4050						CALLMONITOR 
4050 cd aa fd			call debug_vector  
4053				endm  
# End of macro CALLMONITOR
4053					endif 
4053			 
4053					FORTH_DSP_VALUEHL 
4053 cd fa 22			call macro_dsp_valuehl 
4056				endm 
# End of macro FORTH_DSP_VALUEHL
4056			 
4056 7d					ld a, l 
4057 fe 01				cp 1 
4059 20 05				jr nz, .fbn1 
405b 21 4b fc				ld hl, display_fb1 
405e 18 15				jr .fbset 
4060 fe 02		.fbn1:		cp 2 
4062 20 05				jr nz, .fbn2 
4064 21 09 fb				ld hl, display_fb2 
4067 18 0c				jr .fbset 
4069 fe 03		.fbn2:		cp 3 
406b 20 05				jr nz, .fbn3 
406d 21 aa fb				ld hl, display_fb3 
4070 18 03				jr .fbset 
4072			.fbn3:		 ; if invalid number select first 
4072 21 4b fc				ld hl, display_fb1 
4075 22 07 fb		.fbset:		ld (display_fb_active), hl 
4078			 
4078					FORTH_DSP_POP 
4078 cd b2 23			call macro_forth_dsp_pop 
407b				endm 
# End of macro FORTH_DSP_POP
407b			 
407b					NEXTW 
407b c3 b0 24			jp macro_next 
407e				endm 
# End of macro NEXTW
407e			 
407e			 
407e			.EMIT: 
407e				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
407e 1b				db WORD_SYS_CORE+7             
407f cf 40			dw .DOTH            
4081 05				db 4 + 1 
4082 .. 00			db "EMIT",0              
4087				endm 
# End of macro CWHEAD
4087			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
4087					; get value off TOS and display it 
4087			 
4087					if DEBUG_FORTH_WORDS_KEY 
4087						DMARK "EMT" 
4087 f5				push af  
4088 3a 9c 40			ld a, (.dmark)  
408b 32 a6 fd			ld (debug_mark),a  
408e 3a 9d 40			ld a, (.dmark+1)  
4091 32 a7 fd			ld (debug_mark+1),a  
4094 3a 9e 40			ld a, (.dmark+2)  
4097 32 a8 fd			ld (debug_mark+2),a  
409a 18 03			jr .pastdmark  
409c ..			.dmark: db "EMT"  
409f f1			.pastdmark: pop af  
40a0			endm  
# End of macro DMARK
40a0						CALLMONITOR 
40a0 cd aa fd			call debug_vector  
40a3				endm  
# End of macro CALLMONITOR
40a3					endif 
40a3			 
40a3					FORTH_DSP_VALUEHL 
40a3 cd fa 22			call macro_dsp_valuehl 
40a6				endm 
# End of macro FORTH_DSP_VALUEHL
40a6			 
40a6 7d					ld a,l 
40a7			 
40a7					; TODO write to display 
40a7			 
40a7 32 fa f2				ld (os_input), a 
40aa 3e 00				ld a, 0 
40ac 32 fb f2				ld (os_input+1), a 
40af					 
40af 3a 99 f9				ld a, (f_cursor_ptr) 
40b2 11 fa f2				ld de, os_input 
40b5 cd ae 0d				call str_at_display 
40b8			 
40b8			 
40b8 3a 77 f9				ld a,(cli_autodisplay) 
40bb fe 00				cp 0 
40bd 28 03				jr z, .enoupdate 
40bf cd be 0d						call update_display 
40c2					.enoupdate: 
40c2			 
40c2 3a 99 f9				ld a, (f_cursor_ptr) 
40c5 3c					inc a 
40c6 32 99 f9				ld (f_cursor_ptr), a   ; save new pos 
40c9			 
40c9			 
40c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40c9 cd b2 23			call macro_forth_dsp_pop 
40cc				endm 
# End of macro FORTH_DSP_POP
40cc			  
40cc			 
40cc					NEXTW 
40cc c3 b0 24			jp macro_next 
40cf				endm 
# End of macro NEXTW
40cf			.DOTH: 
40cf				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
40cf 1c				db WORD_SYS_CORE+8             
40d0 ff 40			dw .DOTF            
40d2 03				db 2 + 1 
40d3 .. 00			db ".-",0              
40d6				endm 
# End of macro CWHEAD
40d6			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
40d6					; get value off TOS and display it 
40d6					if DEBUG_FORTH_WORDS_KEY 
40d6						DMARK "DTD" 
40d6 f5				push af  
40d7 3a eb 40			ld a, (.dmark)  
40da 32 a6 fd			ld (debug_mark),a  
40dd 3a ec 40			ld a, (.dmark+1)  
40e0 32 a7 fd			ld (debug_mark+1),a  
40e3 3a ed 40			ld a, (.dmark+2)  
40e6 32 a8 fd			ld (debug_mark+2),a  
40e9 18 03			jr .pastdmark  
40eb ..			.dmark: db "DTD"  
40ee f1			.pastdmark: pop af  
40ef			endm  
# End of macro DMARK
40ef						CALLMONITOR 
40ef cd aa fd			call debug_vector  
40f2				endm  
# End of macro CALLMONITOR
40f2					endif 
40f2 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
40f4 3e 00			ld a, 0 
40f6 32 78 f9			ld (cli_mvdot), a 
40f9 c3 56 41			jp .dotgo 
40fc				NEXTW 
40fc c3 b0 24			jp macro_next 
40ff				endm 
# End of macro NEXTW
40ff			.DOTF: 
40ff				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
40ff 1c				db WORD_SYS_CORE+8             
4100 2d 41			dw .DOT            
4102 03				db 2 + 1 
4103 .. 00			db ".>",0              
4106				endm 
# End of macro CWHEAD
4106			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
4106					; get value off TOS and display it 
4106			        ; TODO BUG adds extra spaces 
4106			        ; TODO BUG handle numerics? 
4106					if DEBUG_FORTH_WORDS_KEY 
4106						DMARK "DTC" 
4106 f5				push af  
4107 3a 1b 41			ld a, (.dmark)  
410a 32 a6 fd			ld (debug_mark),a  
410d 3a 1c 41			ld a, (.dmark+1)  
4110 32 a7 fd			ld (debug_mark+1),a  
4113 3a 1d 41			ld a, (.dmark+2)  
4116 32 a8 fd			ld (debug_mark+2),a  
4119 18 03			jr .pastdmark  
411b ..			.dmark: db "DTC"  
411e f1			.pastdmark: pop af  
411f			endm  
# End of macro DMARK
411f						CALLMONITOR 
411f cd aa fd			call debug_vector  
4122				endm  
# End of macro CALLMONITOR
4122					endif 
4122 3e 01			ld a, 1 
4124 32 78 f9			ld (cli_mvdot), a 
4127 c3 56 41			jp .dotgo 
412a				NEXTW 
412a c3 b0 24			jp macro_next 
412d				endm 
# End of macro NEXTW
412d			 
412d			.DOT: 
412d				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
412d 1c				db WORD_SYS_CORE+8             
412e 09 43			dw .CLS            
4130 02				db 1 + 1 
4131 .. 00			db ".",0              
4133				endm 
# End of macro CWHEAD
4133			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
4133					; get value off TOS and display it 
4133			 
4133					if DEBUG_FORTH_WORDS_KEY 
4133						DMARK "DOT" 
4133 f5				push af  
4134 3a 48 41			ld a, (.dmark)  
4137 32 a6 fd			ld (debug_mark),a  
413a 3a 49 41			ld a, (.dmark+1)  
413d 32 a7 fd			ld (debug_mark+1),a  
4140 3a 4a 41			ld a, (.dmark+2)  
4143 32 a8 fd			ld (debug_mark+2),a  
4146 18 03			jr .pastdmark  
4148 ..			.dmark: db "DOT"  
414b f1			.pastdmark: pop af  
414c			endm  
# End of macro DMARK
414c						CALLMONITOR 
414c cd aa fd			call debug_vector  
414f				endm  
# End of macro CALLMONITOR
414f					endif 
414f 3e 00			ld a, 0 
4151 32 78 f9			ld (cli_mvdot), a 
4154 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
4156				 
4156			 
4156			.dotgo: 
4156			 
4156			; move up type to on stack for parserv5 
4156					FORTH_DSP 
4156 cd c0 22			call macro_forth_dsp 
4159				endm 
# End of macro FORTH_DSP
4159				;FORTH_DSP_VALUE  
4159			 
4159			if DEBUG_FORTH_DOT 
4159				DMARK "DOT" 
4159 f5				push af  
415a 3a 6e 41			ld a, (.dmark)  
415d 32 a6 fd			ld (debug_mark),a  
4160 3a 6f 41			ld a, (.dmark+1)  
4163 32 a7 fd			ld (debug_mark+1),a  
4166 3a 70 41			ld a, (.dmark+2)  
4169 32 a8 fd			ld (debug_mark+2),a  
416c 18 03			jr .pastdmark  
416e ..			.dmark: db "DOT"  
4171 f1			.pastdmark: pop af  
4172			endm  
# End of macro DMARK
4172				CALLMONITOR 
4172 cd aa fd			call debug_vector  
4175				endm  
# End of macro CALLMONITOR
4175			endif	 
4175			;		.print: 
4175			 
4175 7e				ld a,(hl)  ; work out what type of value is on the TOS 
4176 23				inc hl   ; position to the actual value 
4177 fe 01			cp DS_TYPE_STR 
4179 20 06			jr nz, .dotnum1  
417b			 
417b			; display string 
417b				FORTH_DSP_VALUE  
417b cd e3 22			call macro_forth_dsp_value 
417e				endm 
# End of macro FORTH_DSP_VALUE
417e eb				ex de,hl 
417f 18 49			jr .dotwrite 
4181			 
4181			.dotnum1: 
4181 fe 02			cp DS_TYPE_INUM 
4183 20 44			jr nz, .dotflot 
4185			 
4185			 
4185			; display number 
4185			 
4185			;	push hl 
4185			;	call clear_display 
4185			;	pop hl 
4185			 
4185 5e				ld e, (hl) 
4186 23				inc hl 
4187 56				ld d, (hl) 
4188 21 fc f0			ld hl, scratch 
418b			if DEBUG_FORTH_DOT 
418b				DMARK "DT1" 
418b f5				push af  
418c 3a a0 41			ld a, (.dmark)  
418f 32 a6 fd			ld (debug_mark),a  
4192 3a a1 41			ld a, (.dmark+1)  
4195 32 a7 fd			ld (debug_mark+1),a  
4198 3a a2 41			ld a, (.dmark+2)  
419b 32 a8 fd			ld (debug_mark+2),a  
419e 18 03			jr .pastdmark  
41a0 ..			.dmark: db "DT1"  
41a3 f1			.pastdmark: pop af  
41a4			endm  
# End of macro DMARK
41a4				CALLMONITOR 
41a4 cd aa fd			call debug_vector  
41a7				endm  
# End of macro CALLMONITOR
41a7			endif	 
41a7			 
41a7 cd dc 13			call uitoa_16 
41aa eb				ex de,hl 
41ab			 
41ab			if DEBUG_FORTH_DOT 
41ab				DMARK "DT2" 
41ab f5				push af  
41ac 3a c0 41			ld a, (.dmark)  
41af 32 a6 fd			ld (debug_mark),a  
41b2 3a c1 41			ld a, (.dmark+1)  
41b5 32 a7 fd			ld (debug_mark+1),a  
41b8 3a c2 41			ld a, (.dmark+2)  
41bb 32 a8 fd			ld (debug_mark+2),a  
41be 18 03			jr .pastdmark  
41c0 ..			.dmark: db "DT2"  
41c3 f1			.pastdmark: pop af  
41c4			endm  
# End of macro DMARK
41c4				CALLMONITOR 
41c4 cd aa fd			call debug_vector  
41c7				endm  
# End of macro CALLMONITOR
41c7			endif	 
41c7			 
41c7			;	ld de, os_word_scratch 
41c7 18 01			jr .dotwrite 
41c9			 
41c9 00			.dotflot:   nop 
41ca			; TODO print floating point number 
41ca			 
41ca			.dotwrite:		 
41ca			 
41ca					; if c is set then set all '-' to spaces 
41ca					; need to also take into account .>  
41ca			 
41ca 3e 01				ld a, 1 
41cc b9					cp c 
41cd 20 67				jr nz, .nodashswap 
41cf			 
41cf					; DE has the string to write, working with HL 
41cf			 
41cf 06 ff				ld b, 255 
41d1 d5					push de 
41d2 e1					pop hl 
41d3			 
41d3			if DEBUG_FORTH_DOT 
41d3				DMARK "DT-" 
41d3 f5				push af  
41d4 3a e8 41			ld a, (.dmark)  
41d7 32 a6 fd			ld (debug_mark),a  
41da 3a e9 41			ld a, (.dmark+1)  
41dd 32 a7 fd			ld (debug_mark+1),a  
41e0 3a ea 41			ld a, (.dmark+2)  
41e3 32 a8 fd			ld (debug_mark+2),a  
41e6 18 03			jr .pastdmark  
41e8 ..			.dmark: db "DT-"  
41eb f1			.pastdmark: pop af  
41ec			endm  
# End of macro DMARK
41ec				CALLMONITOR 
41ec cd aa fd			call debug_vector  
41ef				endm  
# End of macro CALLMONITOR
41ef			endif	 
41ef 7e			.dashscan:	ld a, (hl) 
41f0 fe 00				cp 0 
41f2 28 42				jr z, .nodashswap 
41f4 fe 2d				cp '-' 
41f6 20 03				jr nz, .dashskip 
41f8 3e 20				ld a, ' ' 
41fa 77					ld (hl), a 
41fb 23			.dashskip:	inc hl 
41fc			if DEBUG_FORTH_DOT 
41fc				DMARK "D-2" 
41fc f5				push af  
41fd 3a 11 42			ld a, (.dmark)  
4200 32 a6 fd			ld (debug_mark),a  
4203 3a 12 42			ld a, (.dmark+1)  
4206 32 a7 fd			ld (debug_mark+1),a  
4209 3a 13 42			ld a, (.dmark+2)  
420c 32 a8 fd			ld (debug_mark+2),a  
420f 18 03			jr .pastdmark  
4211 ..			.dmark: db "D-2"  
4214 f1			.pastdmark: pop af  
4215			endm  
# End of macro DMARK
4215				CALLMONITOR 
4215 cd aa fd			call debug_vector  
4218				endm  
# End of macro CALLMONITOR
4218			endif	 
4218 10 d5				djnz .dashscan 
421a			 
421a			if DEBUG_FORTH_DOT 
421a				DMARK "D-1" 
421a f5				push af  
421b 3a 2f 42			ld a, (.dmark)  
421e 32 a6 fd			ld (debug_mark),a  
4221 3a 30 42			ld a, (.dmark+1)  
4224 32 a7 fd			ld (debug_mark+1),a  
4227 3a 31 42			ld a, (.dmark+2)  
422a 32 a8 fd			ld (debug_mark+2),a  
422d 18 03			jr .pastdmark  
422f ..			.dmark: db "D-1"  
4232 f1			.pastdmark: pop af  
4233			endm  
# End of macro DMARK
4233				CALLMONITOR 
4233 cd aa fd			call debug_vector  
4236				endm  
# End of macro CALLMONITOR
4236			endif	 
4236			 
4236			.nodashswap: 
4236			 
4236			if DEBUG_FORTH_DOT 
4236				DMARK "D-o" 
4236 f5				push af  
4237 3a 4b 42			ld a, (.dmark)  
423a 32 a6 fd			ld (debug_mark),a  
423d 3a 4c 42			ld a, (.dmark+1)  
4240 32 a7 fd			ld (debug_mark+1),a  
4243 3a 4d 42			ld a, (.dmark+2)  
4246 32 a8 fd			ld (debug_mark+2),a  
4249 18 03			jr .pastdmark  
424b ..			.dmark: db "D-o"  
424e f1			.pastdmark: pop af  
424f			endm  
# End of macro DMARK
424f				CALLMONITOR 
424f cd aa fd			call debug_vector  
4252				endm  
# End of macro CALLMONITOR
4252			endif	 
4252			 
4252 d5					push de   ; save string start in case we need to advance print 
4253			 
4253 3a 99 f9				ld a, (f_cursor_ptr) 
4256 cd ae 0d				call str_at_display 
4259 3a 77 f9				ld a,(cli_autodisplay) 
425c fe 00				cp 0 
425e 28 03				jr z, .noupdate 
4260 cd be 0d						call update_display 
4263					.noupdate: 
4263			 
4263			 
4263					; see if we need to advance the print position 
4263			 
4263 e1					pop hl   ; get back string 
4264			;		ex de,hl 
4264			 
4264 3a 78 f9				ld a, (cli_mvdot) 
4267			if DEBUG_FORTH_DOT 
4267			;		ld e,a 
4267				DMARK "D>1" 
4267 f5				push af  
4268 3a 7c 42			ld a, (.dmark)  
426b 32 a6 fd			ld (debug_mark),a  
426e 3a 7d 42			ld a, (.dmark+1)  
4271 32 a7 fd			ld (debug_mark+1),a  
4274 3a 7e 42			ld a, (.dmark+2)  
4277 32 a8 fd			ld (debug_mark+2),a  
427a 18 03			jr .pastdmark  
427c ..			.dmark: db "D>1"  
427f f1			.pastdmark: pop af  
4280			endm  
# End of macro DMARK
4280				CALLMONITOR 
4280 cd aa fd			call debug_vector  
4283				endm  
# End of macro CALLMONITOR
4283			endif	 
4283 fe 00				cp 0 
4285 28 44				jr z, .noadv 
4287					; yes, lets advance the print position 
4287 3e 00				ld a, 0 
4289 cd 38 14				call strlent 
428c			if DEBUG_FORTH_DOT 
428c				DMARK "D-?" 
428c f5				push af  
428d 3a a1 42			ld a, (.dmark)  
4290 32 a6 fd			ld (debug_mark),a  
4293 3a a2 42			ld a, (.dmark+1)  
4296 32 a7 fd			ld (debug_mark+1),a  
4299 3a a3 42			ld a, (.dmark+2)  
429c 32 a8 fd			ld (debug_mark+2),a  
429f 18 03			jr .pastdmark  
42a1 ..			.dmark: db "D-?"  
42a4 f1			.pastdmark: pop af  
42a5			endm  
# End of macro DMARK
42a5				CALLMONITOR 
42a5 cd aa fd			call debug_vector  
42a8				endm  
# End of macro CALLMONITOR
42a8			endif	 
42a8 3a 99 f9				ld a, (f_cursor_ptr) 
42ab 85					add a,l 
42ac					;call addatohl 
42ac					;ld a, l 
42ac 32 99 f9				ld (f_cursor_ptr), a   ; save new pos 
42af			 
42af			if DEBUG_FORTH_DOT 
42af				DMARK "D->" 
42af f5				push af  
42b0 3a c4 42			ld a, (.dmark)  
42b3 32 a6 fd			ld (debug_mark),a  
42b6 3a c5 42			ld a, (.dmark+1)  
42b9 32 a7 fd			ld (debug_mark+1),a  
42bc 3a c6 42			ld a, (.dmark+2)  
42bf 32 a8 fd			ld (debug_mark+2),a  
42c2 18 03			jr .pastdmark  
42c4 ..			.dmark: db "D->"  
42c7 f1			.pastdmark: pop af  
42c8			endm  
# End of macro DMARK
42c8				CALLMONITOR 
42c8 cd aa fd			call debug_vector  
42cb				endm  
# End of macro CALLMONITOR
42cb			endif	 
42cb			 
42cb			.noadv:	 
42cb			 
42cb					if DEBUG_FORTH_DOT_WAIT 
42cb							call next_page_prompt 
42cb					endif	 
42cb			; TODO this pop off the stack causes a crash. i dont know why 
42cb			 
42cb			 
42cb			if DEBUG_FORTH_DOT 
42cb				DMARK "DTh" 
42cb f5				push af  
42cc 3a e0 42			ld a, (.dmark)  
42cf 32 a6 fd			ld (debug_mark),a  
42d2 3a e1 42			ld a, (.dmark+1)  
42d5 32 a7 fd			ld (debug_mark+1),a  
42d8 3a e2 42			ld a, (.dmark+2)  
42db 32 a8 fd			ld (debug_mark+2),a  
42de 18 03			jr .pastdmark  
42e0 ..			.dmark: db "DTh"  
42e3 f1			.pastdmark: pop af  
42e4			endm  
# End of macro DMARK
42e4				CALLMONITOR 
42e4 cd aa fd			call debug_vector  
42e7				endm  
# End of macro CALLMONITOR
42e7			endif	 
42e7			 
42e7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42e7 cd b2 23			call macro_forth_dsp_pop 
42ea				endm 
# End of macro FORTH_DSP_POP
42ea			 
42ea			if DEBUG_FORTH_DOT 
42ea				DMARK "DTi" 
42ea f5				push af  
42eb 3a ff 42			ld a, (.dmark)  
42ee 32 a6 fd			ld (debug_mark),a  
42f1 3a 00 43			ld a, (.dmark+1)  
42f4 32 a7 fd			ld (debug_mark+1),a  
42f7 3a 01 43			ld a, (.dmark+2)  
42fa 32 a8 fd			ld (debug_mark+2),a  
42fd 18 03			jr .pastdmark  
42ff ..			.dmark: db "DTi"  
4302 f1			.pastdmark: pop af  
4303			endm  
# End of macro DMARK
4303				CALLMONITOR 
4303 cd aa fd			call debug_vector  
4306				endm  
# End of macro CALLMONITOR
4306			endif	 
4306			 
4306			 
4306					NEXTW 
4306 c3 b0 24			jp macro_next 
4309				endm 
# End of macro NEXTW
4309			 
4309			.CLS: 
4309				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
4309 35				db WORD_SYS_CORE+33             
430a 36 43			dw .DRAW            
430c 04				db 3 + 1 
430d .. 00			db "CLS",0              
4311				endm 
# End of macro CWHEAD
4311			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4311					if DEBUG_FORTH_WORDS_KEY 
4311						DMARK "CLS" 
4311 f5				push af  
4312 3a 26 43			ld a, (.dmark)  
4315 32 a6 fd			ld (debug_mark),a  
4318 3a 27 43			ld a, (.dmark+1)  
431b 32 a7 fd			ld (debug_mark+1),a  
431e 3a 28 43			ld a, (.dmark+2)  
4321 32 a8 fd			ld (debug_mark+2),a  
4324 18 03			jr .pastdmark  
4326 ..			.dmark: db "CLS"  
4329 f1			.pastdmark: pop af  
432a			endm  
# End of macro DMARK
432a						CALLMONITOR 
432a cd aa fd			call debug_vector  
432d				endm  
# End of macro CALLMONITOR
432d					endif 
432d cd 9b 0d				call clear_display 
4330 c3 44 44				jp .home		; and home cursor 
4333					NEXTW 
4333 c3 b0 24			jp macro_next 
4336				endm 
# End of macro NEXTW
4336			 
4336			.DRAW: 
4336				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
4336 36				db WORD_SYS_CORE+34             
4337 61 43			dw .DUMP            
4339 05				db 4 + 1 
433a .. 00			db "DRAW",0              
433f				endm 
# End of macro CWHEAD
433f			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
433f					if DEBUG_FORTH_WORDS_KEY 
433f						DMARK "DRW" 
433f f5				push af  
4340 3a 54 43			ld a, (.dmark)  
4343 32 a6 fd			ld (debug_mark),a  
4346 3a 55 43			ld a, (.dmark+1)  
4349 32 a7 fd			ld (debug_mark+1),a  
434c 3a 56 43			ld a, (.dmark+2)  
434f 32 a8 fd			ld (debug_mark+2),a  
4352 18 03			jr .pastdmark  
4354 ..			.dmark: db "DRW"  
4357 f1			.pastdmark: pop af  
4358			endm  
# End of macro DMARK
4358						CALLMONITOR 
4358 cd aa fd			call debug_vector  
435b				endm  
# End of macro CALLMONITOR
435b					endif 
435b cd be 0d				call update_display 
435e					NEXTW 
435e c3 b0 24			jp macro_next 
4361				endm 
# End of macro NEXTW
4361			 
4361			.DUMP: 
4361				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
4361 37				db WORD_SYS_CORE+35             
4362 99 43			dw .CDUMP            
4364 05				db 4 + 1 
4365 .. 00			db "DUMP",0              
436a				endm 
# End of macro CWHEAD
436a			; | DUMP ( x -- ) With address x display dump   | DONE 
436a			; TODO pop address to use off of the stack 
436a					if DEBUG_FORTH_WORDS_KEY 
436a						DMARK "DUM" 
436a f5				push af  
436b 3a 7f 43			ld a, (.dmark)  
436e 32 a6 fd			ld (debug_mark),a  
4371 3a 80 43			ld a, (.dmark+1)  
4374 32 a7 fd			ld (debug_mark+1),a  
4377 3a 81 43			ld a, (.dmark+2)  
437a 32 a8 fd			ld (debug_mark+2),a  
437d 18 03			jr .pastdmark  
437f ..			.dmark: db "DUM"  
4382 f1			.pastdmark: pop af  
4383			endm  
# End of macro DMARK
4383						CALLMONITOR 
4383 cd aa fd			call debug_vector  
4386				endm  
# End of macro CALLMONITOR
4386					endif 
4386 cd 9b 0d				call clear_display 
4389			 
4389					; get address 
4389			 
4389					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4389 cd fa 22			call macro_dsp_valuehl 
438c				endm 
# End of macro FORTH_DSP_VALUEHL
438c				 
438c					; save it for cdump 
438c			 
438c 22 1f f4				ld (os_cur_ptr),hl 
438f			 
438f					; destroy value TOS 
438f			 
438f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
438f cd b2 23			call macro_forth_dsp_pop 
4392				endm 
# End of macro FORTH_DSP_POP
4392			 
4392 cd 83 1f				call dumpcont	; skip old style of param parsing	 
4395 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
4396					NEXTW 
4396 c3 b0 24			jp macro_next 
4399				endm 
# End of macro NEXTW
4399			.CDUMP: 
4399				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
4399 38				db WORD_SYS_CORE+36             
439a c9 43			dw .DAT            
439c 06				db 5 + 1 
439d .. 00			db "CDUMP",0              
43a3				endm 
# End of macro CWHEAD
43a3			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
43a3					if DEBUG_FORTH_WORDS_KEY 
43a3						DMARK "CDP" 
43a3 f5				push af  
43a4 3a b8 43			ld a, (.dmark)  
43a7 32 a6 fd			ld (debug_mark),a  
43aa 3a b9 43			ld a, (.dmark+1)  
43ad 32 a7 fd			ld (debug_mark+1),a  
43b0 3a ba 43			ld a, (.dmark+2)  
43b3 32 a8 fd			ld (debug_mark+2),a  
43b6 18 03			jr .pastdmark  
43b8 ..			.dmark: db "CDP"  
43bb f1			.pastdmark: pop af  
43bc			endm  
# End of macro DMARK
43bc						CALLMONITOR 
43bc cd aa fd			call debug_vector  
43bf				endm  
# End of macro CALLMONITOR
43bf					endif 
43bf cd 9b 0d				call clear_display 
43c2 cd 83 1f				call dumpcont	 
43c5 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
43c6					NEXTW 
43c6 c3 b0 24			jp macro_next 
43c9				endm 
# End of macro NEXTW
43c9			 
43c9			 
43c9			 
43c9			 
43c9			.DAT: 
43c9				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
43c9 3d				db WORD_SYS_CORE+41             
43ca 1f 44			dw .HOME            
43cc 03				db 2 + 1 
43cd .. 00			db "AT",0              
43d0				endm 
# End of macro CWHEAD
43d0			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
43d0					if DEBUG_FORTH_WORDS_KEY 
43d0						DMARK "AT." 
43d0 f5				push af  
43d1 3a e5 43			ld a, (.dmark)  
43d4 32 a6 fd			ld (debug_mark),a  
43d7 3a e6 43			ld a, (.dmark+1)  
43da 32 a7 fd			ld (debug_mark+1),a  
43dd 3a e7 43			ld a, (.dmark+2)  
43e0 32 a8 fd			ld (debug_mark+2),a  
43e3 18 03			jr .pastdmark  
43e5 ..			.dmark: db "AT."  
43e8 f1			.pastdmark: pop af  
43e9			endm  
# End of macro DMARK
43e9						CALLMONITOR 
43e9 cd aa fd			call debug_vector  
43ec				endm  
# End of macro CALLMONITOR
43ec					endif 
43ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43ec cd fa 22			call macro_dsp_valuehl 
43ef				endm 
# End of macro FORTH_DSP_VALUEHL
43ef			 
43ef			 
43ef					; TODO save cursor row 
43ef 7d					ld a,l 
43f0 fe 02				cp 2 
43f2 20 04				jr nz, .crow3 
43f4 3e 28				ld a, display_row_2 
43f6 18 12				jr .ccol1 
43f8 fe 03		.crow3:		cp 3 
43fa 20 04				jr nz, .crow4 
43fc 3e 50				ld a, display_row_3 
43fe 18 0a				jr .ccol1 
4400 fe 04		.crow4:		cp 4 
4402 20 04				jr nz, .crow1 
4404 3e 78				ld a, display_row_4 
4406 18 02				jr .ccol1 
4408 3e 00		.crow1:		ld a,display_row_1 
440a f5			.ccol1:		push af			; got row offset 
440b 6f					ld l,a 
440c 26 00				ld h,0 
440e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
440e cd b2 23			call macro_forth_dsp_pop 
4411				endm 
# End of macro FORTH_DSP_POP
4411					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4411 cd fa 22			call macro_dsp_valuehl 
4414				endm 
# End of macro FORTH_DSP_VALUEHL
4414					; TODO save cursor col 
4414 f1					pop af 
4415 85					add l		; add col offset 
4416 32 99 f9				ld (f_cursor_ptr), a 
4419					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4419 cd b2 23			call macro_forth_dsp_pop 
441c				endm 
# End of macro FORTH_DSP_POP
441c			 
441c					; calculate  
441c			 
441c					NEXTW 
441c c3 b0 24			jp macro_next 
441f				endm 
# End of macro NEXTW
441f			 
441f			 
441f			.HOME: 
441f				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
441f 41				db WORD_SYS_CORE+45             
4420 4c 44			dw .CR            
4422 05				db 4 + 1 
4423 .. 00			db "HOME",0              
4428				endm 
# End of macro CWHEAD
4428			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
4428					if DEBUG_FORTH_WORDS_KEY 
4428						DMARK "HOM" 
4428 f5				push af  
4429 3a 3d 44			ld a, (.dmark)  
442c 32 a6 fd			ld (debug_mark),a  
442f 3a 3e 44			ld a, (.dmark+1)  
4432 32 a7 fd			ld (debug_mark+1),a  
4435 3a 3f 44			ld a, (.dmark+2)  
4438 32 a8 fd			ld (debug_mark+2),a  
443b 18 03			jr .pastdmark  
443d ..			.dmark: db "HOM"  
4440 f1			.pastdmark: pop af  
4441			endm  
# End of macro DMARK
4441						CALLMONITOR 
4441 cd aa fd			call debug_vector  
4444				endm  
# End of macro CALLMONITOR
4444					endif 
4444 3e 00		.home:		ld a, 0		; and home cursor 
4446 32 99 f9				ld (f_cursor_ptr), a 
4449					NEXTW 
4449 c3 b0 24			jp macro_next 
444c				endm 
# End of macro NEXTW
444c			 
444c			 
444c			.CR: 
444c				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
444c 46				db WORD_SYS_CORE+50             
444d 87 44			dw .SPACE            
444f 03				db 2 + 1 
4450 .. 00			db "CR",0              
4453				endm 
# End of macro CWHEAD
4453			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
4453					if DEBUG_FORTH_WORDS_KEY 
4453						DMARK "CR." 
4453 f5				push af  
4454 3a 68 44			ld a, (.dmark)  
4457 32 a6 fd			ld (debug_mark),a  
445a 3a 69 44			ld a, (.dmark+1)  
445d 32 a7 fd			ld (debug_mark+1),a  
4460 3a 6a 44			ld a, (.dmark+2)  
4463 32 a8 fd			ld (debug_mark+2),a  
4466 18 03			jr .pastdmark  
4468 ..			.dmark: db "CR."  
446b f1			.pastdmark: pop af  
446c			endm  
# End of macro DMARK
446c						CALLMONITOR 
446c cd aa fd			call debug_vector  
446f				endm  
# End of macro CALLMONITOR
446f					endif 
446f 3e 0d				ld a, 13 
4471 32 fc f0				ld (scratch),a 
4474 3e 0a				ld a, 10 
4476 32 fd f0				ld (scratch+1),a 
4479 3e 00				ld a, 0 
447b 32 fe f0				ld (scratch+2),a 
447e 21 fc f0				ld hl, scratch 
4481 cd 71 21				call forth_push_str 
4484					 
4484				       NEXTW 
4484 c3 b0 24			jp macro_next 
4487				endm 
# End of macro NEXTW
4487			.SPACE: 
4487				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
4487 46				db WORD_SYS_CORE+50             
4488 bd 44			dw .SPACES            
448a 03				db 2 + 1 
448b .. 00			db "BL",0              
448e				endm 
# End of macro CWHEAD
448e			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
448e					if DEBUG_FORTH_WORDS_KEY 
448e						DMARK "BL." 
448e f5				push af  
448f 3a a3 44			ld a, (.dmark)  
4492 32 a6 fd			ld (debug_mark),a  
4495 3a a4 44			ld a, (.dmark+1)  
4498 32 a7 fd			ld (debug_mark+1),a  
449b 3a a5 44			ld a, (.dmark+2)  
449e 32 a8 fd			ld (debug_mark+2),a  
44a1 18 03			jr .pastdmark  
44a3 ..			.dmark: db "BL."  
44a6 f1			.pastdmark: pop af  
44a7			endm  
# End of macro DMARK
44a7						CALLMONITOR 
44a7 cd aa fd			call debug_vector  
44aa				endm  
# End of macro CALLMONITOR
44aa					endif 
44aa 3e 20				ld a, " " 
44ac 32 fc f0				ld (scratch),a 
44af 3e 00				ld a, 0 
44b1 32 fd f0				ld (scratch+1),a 
44b4 21 fc f0				ld hl, scratch 
44b7 cd 71 21				call forth_push_str 
44ba					 
44ba				       NEXTW 
44ba c3 b0 24			jp macro_next 
44bd				endm 
# End of macro NEXTW
44bd			 
44bd			;.blstr: db " ", 0 
44bd			 
44bd			.SPACES: 
44bd				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
44bd 47				db WORD_SYS_CORE+51             
44be 58 45			dw .SCROLL            
44c0 07				db 6 + 1 
44c1 .. 00			db "SPACES",0              
44c8				endm 
# End of macro CWHEAD
44c8			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
44c8					if DEBUG_FORTH_WORDS_KEY 
44c8						DMARK "SPS" 
44c8 f5				push af  
44c9 3a dd 44			ld a, (.dmark)  
44cc 32 a6 fd			ld (debug_mark),a  
44cf 3a de 44			ld a, (.dmark+1)  
44d2 32 a7 fd			ld (debug_mark+1),a  
44d5 3a df 44			ld a, (.dmark+2)  
44d8 32 a8 fd			ld (debug_mark+2),a  
44db 18 03			jr .pastdmark  
44dd ..			.dmark: db "SPS"  
44e0 f1			.pastdmark: pop af  
44e1			endm  
# End of macro DMARK
44e1						CALLMONITOR 
44e1 cd aa fd			call debug_vector  
44e4				endm  
# End of macro CALLMONITOR
44e4					endif 
44e4			 
44e4			 
44e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44e4 cd fa 22			call macro_dsp_valuehl 
44e7				endm 
# End of macro FORTH_DSP_VALUEHL
44e7			 
44e7 e5					push hl    ; u 
44e8					if DEBUG_FORTH_WORDS 
44e8						DMARK "SPA" 
44e8 f5				push af  
44e9 3a fd 44			ld a, (.dmark)  
44ec 32 a6 fd			ld (debug_mark),a  
44ef 3a fe 44			ld a, (.dmark+1)  
44f2 32 a7 fd			ld (debug_mark+1),a  
44f5 3a ff 44			ld a, (.dmark+2)  
44f8 32 a8 fd			ld (debug_mark+2),a  
44fb 18 03			jr .pastdmark  
44fd ..			.dmark: db "SPA"  
4500 f1			.pastdmark: pop af  
4501			endm  
# End of macro DMARK
4501						CALLMONITOR 
4501 cd aa fd			call debug_vector  
4504				endm  
# End of macro CALLMONITOR
4504					endif 
4504			 
4504					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4504 cd b2 23			call macro_forth_dsp_pop 
4507				endm 
# End of macro FORTH_DSP_POP
4507 e1					pop hl 
4508 0e 00				ld c, 0 
450a 45					ld b, l 
450b 21 fc f0				ld hl, scratch  
450e			 
450e					if DEBUG_FORTH_WORDS 
450e						DMARK "SP2" 
450e f5				push af  
450f 3a 23 45			ld a, (.dmark)  
4512 32 a6 fd			ld (debug_mark),a  
4515 3a 24 45			ld a, (.dmark+1)  
4518 32 a7 fd			ld (debug_mark+1),a  
451b 3a 25 45			ld a, (.dmark+2)  
451e 32 a8 fd			ld (debug_mark+2),a  
4521 18 03			jr .pastdmark  
4523 ..			.dmark: db "SP2"  
4526 f1			.pastdmark: pop af  
4527			endm  
# End of macro DMARK
4527						CALLMONITOR 
4527 cd aa fd			call debug_vector  
452a				endm  
# End of macro CALLMONITOR
452a					endif 
452a 3e 20				ld a, ' ' 
452c			.spaces1:	 
452c 77					ld (hl),a 
452d 23					inc hl 
452e					 
452e 10 fc				djnz .spaces1 
4530 3e 00				ld a,0 
4532 77					ld (hl),a 
4533 21 fc f0				ld hl, scratch 
4536					if DEBUG_FORTH_WORDS 
4536						DMARK "SP3" 
4536 f5				push af  
4537 3a 4b 45			ld a, (.dmark)  
453a 32 a6 fd			ld (debug_mark),a  
453d 3a 4c 45			ld a, (.dmark+1)  
4540 32 a7 fd			ld (debug_mark+1),a  
4543 3a 4d 45			ld a, (.dmark+2)  
4546 32 a8 fd			ld (debug_mark+2),a  
4549 18 03			jr .pastdmark  
454b ..			.dmark: db "SP3"  
454e f1			.pastdmark: pop af  
454f			endm  
# End of macro DMARK
454f						CALLMONITOR 
454f cd aa fd			call debug_vector  
4552				endm  
# End of macro CALLMONITOR
4552					endif 
4552 cd 71 21				call forth_push_str 
4555			 
4555				       NEXTW 
4555 c3 b0 24			jp macro_next 
4558				endm 
# End of macro NEXTW
4558			 
4558			 
4558			 
4558			.SCROLL: 
4558				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4558 53				db WORD_SYS_CORE+63             
4559 85 45			dw .SCROLLD            
455b 07				db 6 + 1 
455c .. 00			db "SCROLL",0              
4563				endm 
# End of macro CWHEAD
4563			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4563					if DEBUG_FORTH_WORDS_KEY 
4563						DMARK "SCR" 
4563 f5				push af  
4564 3a 78 45			ld a, (.dmark)  
4567 32 a6 fd			ld (debug_mark),a  
456a 3a 79 45			ld a, (.dmark+1)  
456d 32 a7 fd			ld (debug_mark+1),a  
4570 3a 7a 45			ld a, (.dmark+2)  
4573 32 a8 fd			ld (debug_mark+2),a  
4576 18 03			jr .pastdmark  
4578 ..			.dmark: db "SCR"  
457b f1			.pastdmark: pop af  
457c			endm  
# End of macro DMARK
457c						CALLMONITOR 
457c cd aa fd			call debug_vector  
457f				endm  
# End of macro CALLMONITOR
457f					endif 
457f			 
457f cd 5d 0d			call scroll_up 
4582			;	call update_display 
4582			 
4582					NEXTW 
4582 c3 b0 24			jp macro_next 
4585				endm 
# End of macro NEXTW
4585			 
4585			 
4585			 
4585			;		; get dir 
4585			; 
4585			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4585			; 
4585			;		push hl 
4585			; 
4585			;		; destroy value TOS 
4585			; 
4585			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4585			; 
4585			;		; get count 
4585			; 
4585			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4585			; 
4585			;		push hl 
4585			; 
4585			;		; destroy value TOS 
4585			; 
4585			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4585			; 
4585			;		; one value on hl get other one back 
4585			; 
4585			;		pop bc    ; count 
4585			; 
4585			;		pop de   ; dir 
4585			; 
4585			; 
4585			;		ld b, c 
4585			; 
4585			;.scrolldir:     push bc 
4585			;		push de 
4585			; 
4585			;		ld a, 0 
4585			;		cp e 
4585			;		jr z, .scrollup  
4585			;		call scroll_down 
4585			;		jr .scrollnext 
4585			;.scrollup:	call scroll_up 
4585			; 
4585			;		 
4585			;.scrollnext: 
4585			;		pop de 
4585			;		pop bc 
4585			;		djnz .scrolldir 
4585			; 
4585			; 
4585			; 
4585			; 
4585			; 
4585			;		NEXTW 
4585			 
4585			.SCROLLD: 
4585				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4585 53				db WORD_SYS_CORE+63             
4586 b3 45			dw .ATQ            
4588 08				db 7 + 1 
4589 .. 00			db "SCROLLD",0              
4591				endm 
# End of macro CWHEAD
4591			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4591					if DEBUG_FORTH_WORDS_KEY 
4591						DMARK "SCD" 
4591 f5				push af  
4592 3a a6 45			ld a, (.dmark)  
4595 32 a6 fd			ld (debug_mark),a  
4598 3a a7 45			ld a, (.dmark+1)  
459b 32 a7 fd			ld (debug_mark+1),a  
459e 3a a8 45			ld a, (.dmark+2)  
45a1 32 a8 fd			ld (debug_mark+2),a  
45a4 18 03			jr .pastdmark  
45a6 ..			.dmark: db "SCD"  
45a9 f1			.pastdmark: pop af  
45aa			endm  
# End of macro DMARK
45aa						CALLMONITOR 
45aa cd aa fd			call debug_vector  
45ad				endm  
# End of macro CALLMONITOR
45ad					endif 
45ad			 
45ad cd 81 0d			call scroll_down 
45b0			;	call update_display 
45b0			 
45b0					NEXTW 
45b0 c3 b0 24			jp macro_next 
45b3				endm 
# End of macro NEXTW
45b3			 
45b3			 
45b3			.ATQ: 
45b3				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
45b3 62				db WORD_SYS_CORE+78             
45b4 11 46			dw .AUTODSP            
45b6 04				db 3 + 1 
45b7 .. 00			db "AT@",0              
45bb				endm 
# End of macro CWHEAD
45bb			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
45bb					if DEBUG_FORTH_WORDS_KEY 
45bb						DMARK "ATA" 
45bb f5				push af  
45bc 3a d0 45			ld a, (.dmark)  
45bf 32 a6 fd			ld (debug_mark),a  
45c2 3a d1 45			ld a, (.dmark+1)  
45c5 32 a7 fd			ld (debug_mark+1),a  
45c8 3a d2 45			ld a, (.dmark+2)  
45cb 32 a8 fd			ld (debug_mark+2),a  
45ce 18 03			jr .pastdmark  
45d0 ..			.dmark: db "ATA"  
45d3 f1			.pastdmark: pop af  
45d4			endm  
# End of macro DMARK
45d4						CALLMONITOR 
45d4 cd aa fd			call debug_vector  
45d7				endm  
# End of macro CALLMONITOR
45d7					endif 
45d7			 
45d7			 
45d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45d7 cd fa 22			call macro_dsp_valuehl 
45da				endm 
# End of macro FORTH_DSP_VALUEHL
45da			 
45da					; TODO save cursor row 
45da 7d					ld a,l 
45db fe 02				cp 2 
45dd 20 04				jr nz, .crow3aq 
45df 3e 28				ld a, display_row_2 
45e1 18 12				jr .ccol1aq 
45e3 fe 03		.crow3aq:		cp 3 
45e5 20 04				jr nz, .crow4aq 
45e7 3e 50				ld a, display_row_3 
45e9 18 0a				jr .ccol1aq 
45eb fe 04		.crow4aq:		cp 4 
45ed 20 04				jr nz, .crow1aq 
45ef 3e 78				ld a, display_row_4 
45f1 18 02				jr .ccol1aq 
45f3 3e 00		.crow1aq:		ld a,display_row_1 
45f5 f5			.ccol1aq:		push af			; got row offset 
45f6 6f					ld l,a 
45f7 26 00				ld h,0 
45f9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45f9 cd b2 23			call macro_forth_dsp_pop 
45fc				endm 
# End of macro FORTH_DSP_POP
45fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45fc cd fa 22			call macro_dsp_valuehl 
45ff				endm 
# End of macro FORTH_DSP_VALUEHL
45ff					; TODO save cursor col 
45ff f1					pop af 
4600 85					add l		; add col offset 
4601			 
4601					; add current frame buffer address 
4601 2a 07 fb				ld hl, (display_fb_active) 
4604 cd cf 0f				call addatohl 
4607			 
4607			 
4607			 
4607			 
4607					; get char frame buffer location offset in hl 
4607			 
4607 7e					ld a,(hl) 
4608 26 00				ld h, 0 
460a 6f					ld l, a 
460b			 
460b cd 03 21				call forth_push_numhl 
460e			 
460e			 
460e					NEXTW 
460e c3 b0 24			jp macro_next 
4611				endm 
# End of macro NEXTW
4611			 
4611			.AUTODSP: 
4611				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4611 63				db WORD_SYS_CORE+79             
4612 27 46			dw .MENU            
4614 05				db 4 + 1 
4615 .. 00			db "ADSP",0              
461a				endm 
# End of macro CWHEAD
461a			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
461a			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
461a			 
461a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
461a cd fa 22			call macro_dsp_valuehl 
461d				endm 
# End of macro FORTH_DSP_VALUEHL
461d			 
461d			;		push hl 
461d			 
461d					; destroy value TOS 
461d			 
461d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
461d cd b2 23			call macro_forth_dsp_pop 
4620				endm 
# End of macro FORTH_DSP_POP
4620			 
4620			;		pop hl 
4620			 
4620 7d					ld a,l 
4621 32 77 f9				ld (cli_autodisplay), a 
4624				       NEXTW 
4624 c3 b0 24			jp macro_next 
4627				endm 
# End of macro NEXTW
4627			 
4627			.MENU: 
4627				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4627 70				db WORD_SYS_CORE+92             
4628 d0 46			dw .ENDDISPLAY            
462a 05				db 4 + 1 
462b .. 00			db "MENU",0              
4630				endm 
# End of macro CWHEAD
4630			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
4630			 
4630			;		; get number of items on the stack 
4630			; 
4630				 
4630					FORTH_DSP_VALUEHL 
4630 cd fa 22			call macro_dsp_valuehl 
4633				endm 
# End of macro FORTH_DSP_VALUEHL
4633				 
4633					if DEBUG_FORTH_WORDS_KEY 
4633						DMARK "MNU" 
4633 f5				push af  
4634 3a 48 46			ld a, (.dmark)  
4637 32 a6 fd			ld (debug_mark),a  
463a 3a 49 46			ld a, (.dmark+1)  
463d 32 a7 fd			ld (debug_mark+1),a  
4640 3a 4a 46			ld a, (.dmark+2)  
4643 32 a8 fd			ld (debug_mark+2),a  
4646 18 03			jr .pastdmark  
4648 ..			.dmark: db "MNU"  
464b f1			.pastdmark: pop af  
464c			endm  
# End of macro DMARK
464c						CALLMONITOR 
464c cd aa fd			call debug_vector  
464f				endm  
# End of macro CALLMONITOR
464f					endif 
464f			 
464f 45					ld b, l	 
4650 05					dec b 
4651			 
4651					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4651 cd b2 23			call macro_forth_dsp_pop 
4654				endm 
# End of macro FORTH_DSP_POP
4654			 
4654			 
4654					; go directly through the stack to pluck out the string pointers and build an array 
4654			 
4654			;		FORTH_DSP 
4654			 
4654					; hl contains top most stack item 
4654				 
4654 11 fc f0				ld de, scratch 
4657			 
4657			.mbuild: 
4657			 
4657					FORTH_DSP_VALUEHL 
4657 cd fa 22			call macro_dsp_valuehl 
465a				endm 
# End of macro FORTH_DSP_VALUEHL
465a			 
465a					if DEBUG_FORTH_WORDS 
465a						DMARK "MN3" 
465a f5				push af  
465b 3a 6f 46			ld a, (.dmark)  
465e 32 a6 fd			ld (debug_mark),a  
4661 3a 70 46			ld a, (.dmark+1)  
4664 32 a7 fd			ld (debug_mark+1),a  
4667 3a 71 46			ld a, (.dmark+2)  
466a 32 a8 fd			ld (debug_mark+2),a  
466d 18 03			jr .pastdmark  
466f ..			.dmark: db "MN3"  
4672 f1			.pastdmark: pop af  
4673			endm  
# End of macro DMARK
4673						CALLMONITOR 
4673 cd aa fd			call debug_vector  
4676				endm  
# End of macro CALLMONITOR
4676					endif 
4676 eb					ex de, hl 
4677 73					ld (hl), e 
4678 23					inc hl 
4679 72					ld (hl), d 
467a 23					inc hl 
467b eb					ex de, hl 
467c			 
467c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
467c cd b2 23			call macro_forth_dsp_pop 
467f				endm 
# End of macro FORTH_DSP_POP
467f			 
467f 10 d6				djnz .mbuild 
4681			 
4681					; done add term 
4681			 
4681 eb					ex de, hl 
4682 36 00				ld (hl), 0 
4684 23					inc hl 
4685 36 00				ld (hl), 0 
4687			 
4687				 
4687					 
4687 21 fc f0				ld hl, scratch 
468a			 
468a					if DEBUG_FORTH_WORDS 
468a						DMARK "MNx" 
468a f5				push af  
468b 3a 9f 46			ld a, (.dmark)  
468e 32 a6 fd			ld (debug_mark),a  
4691 3a a0 46			ld a, (.dmark+1)  
4694 32 a7 fd			ld (debug_mark+1),a  
4697 3a a1 46			ld a, (.dmark+2)  
469a 32 a8 fd			ld (debug_mark+2),a  
469d 18 03			jr .pastdmark  
469f ..			.dmark: db "MNx"  
46a2 f1			.pastdmark: pop af  
46a3			endm  
# End of macro DMARK
46a3						CALLMONITOR 
46a3 cd aa fd			call debug_vector  
46a6				endm  
# End of macro CALLMONITOR
46a6					endif 
46a6			 
46a6			 
46a6			 
46a6 3e 00				ld a, 0 
46a8 cd cc 0d				call menu 
46ab			 
46ab			 
46ab 6f					ld l, a 
46ac 26 00				ld h, 0 
46ae			 
46ae					if DEBUG_FORTH_WORDS 
46ae						DMARK "MNr" 
46ae f5				push af  
46af 3a c3 46			ld a, (.dmark)  
46b2 32 a6 fd			ld (debug_mark),a  
46b5 3a c4 46			ld a, (.dmark+1)  
46b8 32 a7 fd			ld (debug_mark+1),a  
46bb 3a c5 46			ld a, (.dmark+2)  
46be 32 a8 fd			ld (debug_mark+2),a  
46c1 18 03			jr .pastdmark  
46c3 ..			.dmark: db "MNr"  
46c6 f1			.pastdmark: pop af  
46c7			endm  
# End of macro DMARK
46c7						CALLMONITOR 
46c7 cd aa fd			call debug_vector  
46ca				endm  
# End of macro CALLMONITOR
46ca					endif 
46ca			 
46ca cd 03 21				call forth_push_numhl 
46cd			 
46cd			 
46cd			 
46cd			 
46cd				       NEXTW 
46cd c3 b0 24			jp macro_next 
46d0				endm 
# End of macro NEXTW
46d0			 
46d0			 
46d0			.ENDDISPLAY: 
46d0			 
46d0			; eof 
# End of file forth_words_display.asm
46d0			include "forth_words_str.asm" 
46d0			 
46d0			; | ## String Words 
46d0			 
46d0			.PTR:   
46d0			 
46d0				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
46d0 48				db WORD_SYS_CORE+52             
46d1 fd 46			dw .STYPE            
46d3 04				db 3 + 1 
46d4 .. 00			db "PTR",0              
46d8				endm 
# End of macro CWHEAD
46d8			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
46d8			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
46d8			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
46d8			 
46d8					if DEBUG_FORTH_WORDS_KEY 
46d8						DMARK "PTR" 
46d8 f5				push af  
46d9 3a ed 46			ld a, (.dmark)  
46dc 32 a6 fd			ld (debug_mark),a  
46df 3a ee 46			ld a, (.dmark+1)  
46e2 32 a7 fd			ld (debug_mark+1),a  
46e5 3a ef 46			ld a, (.dmark+2)  
46e8 32 a8 fd			ld (debug_mark+2),a  
46eb 18 03			jr .pastdmark  
46ed ..			.dmark: db "PTR"  
46f0 f1			.pastdmark: pop af  
46f1			endm  
# End of macro DMARK
46f1						CALLMONITOR 
46f1 cd aa fd			call debug_vector  
46f4				endm  
# End of macro CALLMONITOR
46f4					endif 
46f4					FORTH_DSP_VALUEHL 
46f4 cd fa 22			call macro_dsp_valuehl 
46f7				endm 
# End of macro FORTH_DSP_VALUEHL
46f7 cd 03 21				call forth_push_numhl 
46fa			 
46fa			 
46fa					NEXTW 
46fa c3 b0 24			jp macro_next 
46fd				endm 
# End of macro NEXTW
46fd			.STYPE: 
46fd				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
46fd 48				db WORD_SYS_CORE+52             
46fe 4c 47			dw .UPPER            
4700 06				db 5 + 1 
4701 .. 00			db "STYPE",0              
4707				endm 
# End of macro CWHEAD
4707			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4707					if DEBUG_FORTH_WORDS_KEY 
4707						DMARK "STY" 
4707 f5				push af  
4708 3a 1c 47			ld a, (.dmark)  
470b 32 a6 fd			ld (debug_mark),a  
470e 3a 1d 47			ld a, (.dmark+1)  
4711 32 a7 fd			ld (debug_mark+1),a  
4714 3a 1e 47			ld a, (.dmark+2)  
4717 32 a8 fd			ld (debug_mark+2),a  
471a 18 03			jr .pastdmark  
471c ..			.dmark: db "STY"  
471f f1			.pastdmark: pop af  
4720			endm  
# End of macro DMARK
4720						CALLMONITOR 
4720 cd aa fd			call debug_vector  
4723				endm  
# End of macro CALLMONITOR
4723					endif 
4723					FORTH_DSP 
4723 cd c0 22			call macro_forth_dsp 
4726				endm 
# End of macro FORTH_DSP
4726					;v5 FORTH_DSP_VALUE 
4726			 
4726 7e					ld a, (hl) 
4727			 
4727 f5					push af 
4728			 
4728			; Dont destroy TOS		FORTH_DSP_POP 
4728			 
4728 f1					pop af 
4729			 
4729 fe 01				cp DS_TYPE_STR 
472b 28 09				jr z, .typestr 
472d			 
472d fe 02				cp DS_TYPE_INUM 
472f 28 0a				jr z, .typeinum 
4731			 
4731 21 4a 47				ld hl, .tna 
4734 18 0a				jr .tpush 
4736			 
4736 21 46 47		.typestr:	ld hl, .tstr 
4739 18 05				jr .tpush 
473b 21 48 47		.typeinum:	ld hl, .tinum 
473e 18 00				jr .tpush 
4740			 
4740			.tpush: 
4740			 
4740 cd 71 21				call forth_push_str 
4743			 
4743					NEXTW 
4743 c3 b0 24			jp macro_next 
4746				endm 
# End of macro NEXTW
4746 .. 00		.tstr:	db "s",0 
4748 .. 00		.tinum:  db "i",0 
474a .. 00		.tna:   db "?", 0 
474c			 
474c			 
474c			.UPPER: 
474c				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
474c 48				db WORD_SYS_CORE+52             
474d 87 47			dw .LOWER            
474f 06				db 5 + 1 
4750 .. 00			db "UPPER",0              
4756				endm 
# End of macro CWHEAD
4756			; | UPPER ( s -- s ) Upper case string s  | DONE 
4756					if DEBUG_FORTH_WORDS_KEY 
4756						DMARK "UPR" 
4756 f5				push af  
4757 3a 6b 47			ld a, (.dmark)  
475a 32 a6 fd			ld (debug_mark),a  
475d 3a 6c 47			ld a, (.dmark+1)  
4760 32 a7 fd			ld (debug_mark+1),a  
4763 3a 6d 47			ld a, (.dmark+2)  
4766 32 a8 fd			ld (debug_mark+2),a  
4769 18 03			jr .pastdmark  
476b ..			.dmark: db "UPR"  
476e f1			.pastdmark: pop af  
476f			endm  
# End of macro DMARK
476f						CALLMONITOR 
476f cd aa fd			call debug_vector  
4772				endm  
# End of macro CALLMONITOR
4772					endif 
4772			 
4772					FORTH_DSP 
4772 cd c0 22			call macro_forth_dsp 
4775				endm 
# End of macro FORTH_DSP
4775					 
4775			; TODO check is string type 
4775			 
4775					FORTH_DSP_VALUEHL 
4775 cd fa 22			call macro_dsp_valuehl 
4778				endm 
# End of macro FORTH_DSP_VALUEHL
4778			; get pointer to string in hl 
4778			 
4778 7e			.toup:		ld a, (hl) 
4779 fe 00				cp 0 
477b 28 07				jr z, .toupdone 
477d			 
477d cd 3c 13				call to_upper 
4780			 
4780 77					ld (hl), a 
4781 23					inc hl 
4782 18 f4				jr .toup 
4784			 
4784					 
4784			 
4784			 
4784			; for each char convert to upper 
4784					 
4784			.toupdone: 
4784			 
4784			 
4784					NEXTW 
4784 c3 b0 24			jp macro_next 
4787				endm 
# End of macro NEXTW
4787			.LOWER: 
4787				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4787 48				db WORD_SYS_CORE+52             
4788 c2 47			dw .TCASE            
478a 06				db 5 + 1 
478b .. 00			db "LOWER",0              
4791				endm 
# End of macro CWHEAD
4791			; | LOWER ( s -- s ) Lower case string s  | DONE 
4791					if DEBUG_FORTH_WORDS_KEY 
4791						DMARK "LWR" 
4791 f5				push af  
4792 3a a6 47			ld a, (.dmark)  
4795 32 a6 fd			ld (debug_mark),a  
4798 3a a7 47			ld a, (.dmark+1)  
479b 32 a7 fd			ld (debug_mark+1),a  
479e 3a a8 47			ld a, (.dmark+2)  
47a1 32 a8 fd			ld (debug_mark+2),a  
47a4 18 03			jr .pastdmark  
47a6 ..			.dmark: db "LWR"  
47a9 f1			.pastdmark: pop af  
47aa			endm  
# End of macro DMARK
47aa						CALLMONITOR 
47aa cd aa fd			call debug_vector  
47ad				endm  
# End of macro CALLMONITOR
47ad					endif 
47ad			 
47ad					FORTH_DSP 
47ad cd c0 22			call macro_forth_dsp 
47b0				endm 
# End of macro FORTH_DSP
47b0					 
47b0			; TODO check is string type 
47b0			 
47b0					FORTH_DSP_VALUEHL 
47b0 cd fa 22			call macro_dsp_valuehl 
47b3				endm 
# End of macro FORTH_DSP_VALUEHL
47b3			; get pointer to string in hl 
47b3			 
47b3 7e			.tolow:		ld a, (hl) 
47b4 fe 00				cp 0 
47b6 28 07				jr z, .tolowdone 
47b8			 
47b8 cd 45 13				call to_lower 
47bb			 
47bb 77					ld (hl), a 
47bc 23					inc hl 
47bd 18 f4				jr .tolow 
47bf			 
47bf					 
47bf			 
47bf			 
47bf			; for each char convert to low 
47bf					 
47bf			.tolowdone: 
47bf					NEXTW 
47bf c3 b0 24			jp macro_next 
47c2				endm 
# End of macro NEXTW
47c2			.TCASE: 
47c2				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
47c2 48				db WORD_SYS_CORE+52             
47c3 f8 48			dw .SUBSTR            
47c5 06				db 5 + 1 
47c6 .. 00			db "TCASE",0              
47cc				endm 
# End of macro CWHEAD
47cc			; | TCASE ( s -- s ) Title case string s  | DONE 
47cc					if DEBUG_FORTH_WORDS_KEY 
47cc						DMARK "TCS" 
47cc f5				push af  
47cd 3a e1 47			ld a, (.dmark)  
47d0 32 a6 fd			ld (debug_mark),a  
47d3 3a e2 47			ld a, (.dmark+1)  
47d6 32 a7 fd			ld (debug_mark+1),a  
47d9 3a e3 47			ld a, (.dmark+2)  
47dc 32 a8 fd			ld (debug_mark+2),a  
47df 18 03			jr .pastdmark  
47e1 ..			.dmark: db "TCS"  
47e4 f1			.pastdmark: pop af  
47e5			endm  
# End of macro DMARK
47e5						CALLMONITOR 
47e5 cd aa fd			call debug_vector  
47e8				endm  
# End of macro CALLMONITOR
47e8					endif 
47e8			 
47e8					FORTH_DSP 
47e8 cd c0 22			call macro_forth_dsp 
47eb				endm 
# End of macro FORTH_DSP
47eb					 
47eb			; TODO check is string type 
47eb			 
47eb					FORTH_DSP_VALUEHL 
47eb cd fa 22			call macro_dsp_valuehl 
47ee				endm 
# End of macro FORTH_DSP_VALUEHL
47ee			; get pointer to string in hl 
47ee			 
47ee					if DEBUG_FORTH_WORDS 
47ee						DMARK "TC1" 
47ee f5				push af  
47ef 3a 03 48			ld a, (.dmark)  
47f2 32 a6 fd			ld (debug_mark),a  
47f5 3a 04 48			ld a, (.dmark+1)  
47f8 32 a7 fd			ld (debug_mark+1),a  
47fb 3a 05 48			ld a, (.dmark+2)  
47fe 32 a8 fd			ld (debug_mark+2),a  
4801 18 03			jr .pastdmark  
4803 ..			.dmark: db "TC1"  
4806 f1			.pastdmark: pop af  
4807			endm  
# End of macro DMARK
4807						CALLMONITOR 
4807 cd aa fd			call debug_vector  
480a				endm  
# End of macro CALLMONITOR
480a					endif 
480a			 
480a					; first time in turn to upper case first char 
480a			 
480a 7e					ld a, (hl) 
480b c3 95 48				jp .totsiptou 
480e			 
480e			 
480e 7e			.tot:		ld a, (hl) 
480f fe 00				cp 0 
4811 ca d9 48				jp z, .totdone 
4814			 
4814					if DEBUG_FORTH_WORDS 
4814						DMARK "TC2" 
4814 f5				push af  
4815 3a 29 48			ld a, (.dmark)  
4818 32 a6 fd			ld (debug_mark),a  
481b 3a 2a 48			ld a, (.dmark+1)  
481e 32 a7 fd			ld (debug_mark+1),a  
4821 3a 2b 48			ld a, (.dmark+2)  
4824 32 a8 fd			ld (debug_mark+2),a  
4827 18 03			jr .pastdmark  
4829 ..			.dmark: db "TC2"  
482c f1			.pastdmark: pop af  
482d			endm  
# End of macro DMARK
482d						CALLMONITOR 
482d cd aa fd			call debug_vector  
4830				endm  
# End of macro CALLMONITOR
4830					endif 
4830					; check to see if current char is a space 
4830			 
4830 fe 20				cp ' ' 
4832 28 21				jr z, .totsp 
4834 cd 45 13				call to_lower 
4837					if DEBUG_FORTH_WORDS 
4837						DMARK "TC3" 
4837 f5				push af  
4838 3a 4c 48			ld a, (.dmark)  
483b 32 a6 fd			ld (debug_mark),a  
483e 3a 4d 48			ld a, (.dmark+1)  
4841 32 a7 fd			ld (debug_mark+1),a  
4844 3a 4e 48			ld a, (.dmark+2)  
4847 32 a8 fd			ld (debug_mark+2),a  
484a 18 03			jr .pastdmark  
484c ..			.dmark: db "TC3"  
484f f1			.pastdmark: pop af  
4850			endm  
# End of macro DMARK
4850						CALLMONITOR 
4850 cd aa fd			call debug_vector  
4853				endm  
# End of macro CALLMONITOR
4853					endif 
4853 18 63				jr .totnxt 
4855			 
4855			.totsp:         ; on a space, find next char which should be upper 
4855			 
4855					if DEBUG_FORTH_WORDS 
4855						DMARK "TC4" 
4855 f5				push af  
4856 3a 6a 48			ld a, (.dmark)  
4859 32 a6 fd			ld (debug_mark),a  
485c 3a 6b 48			ld a, (.dmark+1)  
485f 32 a7 fd			ld (debug_mark+1),a  
4862 3a 6c 48			ld a, (.dmark+2)  
4865 32 a8 fd			ld (debug_mark+2),a  
4868 18 03			jr .pastdmark  
486a ..			.dmark: db "TC4"  
486d f1			.pastdmark: pop af  
486e			endm  
# End of macro DMARK
486e						CALLMONITOR 
486e cd aa fd			call debug_vector  
4871				endm  
# End of macro CALLMONITOR
4871					endif 
4871					;; 
4871			 
4871 fe 20				cp ' ' 
4873 20 20				jr nz, .totsiptou 
4875 23					inc hl 
4876 7e					ld a, (hl) 
4877					if DEBUG_FORTH_WORDS 
4877						DMARK "TC5" 
4877 f5				push af  
4878 3a 8c 48			ld a, (.dmark)  
487b 32 a6 fd			ld (debug_mark),a  
487e 3a 8d 48			ld a, (.dmark+1)  
4881 32 a7 fd			ld (debug_mark+1),a  
4884 3a 8e 48			ld a, (.dmark+2)  
4887 32 a8 fd			ld (debug_mark+2),a  
488a 18 03			jr .pastdmark  
488c ..			.dmark: db "TC5"  
488f f1			.pastdmark: pop af  
4890			endm  
# End of macro DMARK
4890						CALLMONITOR 
4890 cd aa fd			call debug_vector  
4893				endm  
# End of macro CALLMONITOR
4893					endif 
4893 18 c0				jr .totsp 
4895 fe 00		.totsiptou:    cp 0 
4897 28 40				jr z, .totdone 
4899					; not space and not zero term so upper case it 
4899 cd 3c 13				call to_upper 
489c			 
489c					if DEBUG_FORTH_WORDS 
489c						DMARK "TC6" 
489c f5				push af  
489d 3a b1 48			ld a, (.dmark)  
48a0 32 a6 fd			ld (debug_mark),a  
48a3 3a b2 48			ld a, (.dmark+1)  
48a6 32 a7 fd			ld (debug_mark+1),a  
48a9 3a b3 48			ld a, (.dmark+2)  
48ac 32 a8 fd			ld (debug_mark+2),a  
48af 18 03			jr .pastdmark  
48b1 ..			.dmark: db "TC6"  
48b4 f1			.pastdmark: pop af  
48b5			endm  
# End of macro DMARK
48b5						CALLMONITOR 
48b5 cd aa fd			call debug_vector  
48b8				endm  
# End of macro CALLMONITOR
48b8					endif 
48b8			 
48b8			 
48b8			.totnxt: 
48b8			 
48b8 77					ld (hl), a 
48b9 23					inc hl 
48ba					if DEBUG_FORTH_WORDS 
48ba						DMARK "TC7" 
48ba f5				push af  
48bb 3a cf 48			ld a, (.dmark)  
48be 32 a6 fd			ld (debug_mark),a  
48c1 3a d0 48			ld a, (.dmark+1)  
48c4 32 a7 fd			ld (debug_mark+1),a  
48c7 3a d1 48			ld a, (.dmark+2)  
48ca 32 a8 fd			ld (debug_mark+2),a  
48cd 18 03			jr .pastdmark  
48cf ..			.dmark: db "TC7"  
48d2 f1			.pastdmark: pop af  
48d3			endm  
# End of macro DMARK
48d3						CALLMONITOR 
48d3 cd aa fd			call debug_vector  
48d6				endm  
# End of macro CALLMONITOR
48d6					endif 
48d6 c3 0e 48				jp .tot 
48d9			 
48d9					 
48d9			 
48d9			 
48d9			; for each char convert to low 
48d9					 
48d9			.totdone: 
48d9					if DEBUG_FORTH_WORDS 
48d9						DMARK "TCd" 
48d9 f5				push af  
48da 3a ee 48			ld a, (.dmark)  
48dd 32 a6 fd			ld (debug_mark),a  
48e0 3a ef 48			ld a, (.dmark+1)  
48e3 32 a7 fd			ld (debug_mark+1),a  
48e6 3a f0 48			ld a, (.dmark+2)  
48e9 32 a8 fd			ld (debug_mark+2),a  
48ec 18 03			jr .pastdmark  
48ee ..			.dmark: db "TCd"  
48f1 f1			.pastdmark: pop af  
48f2			endm  
# End of macro DMARK
48f2						CALLMONITOR 
48f2 cd aa fd			call debug_vector  
48f5				endm  
# End of macro CALLMONITOR
48f5					endif 
48f5					NEXTW 
48f5 c3 b0 24			jp macro_next 
48f8				endm 
# End of macro NEXTW
48f8			 
48f8			.SUBSTR: 
48f8				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
48f8 48				db WORD_SYS_CORE+52             
48f9 56 49			dw .LEFT            
48fb 07				db 6 + 1 
48fc .. 00			db "SUBSTR",0              
4903				endm 
# End of macro CWHEAD
4903			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4903			 
4903					if DEBUG_FORTH_WORDS_KEY 
4903						DMARK "SST" 
4903 f5				push af  
4904 3a 18 49			ld a, (.dmark)  
4907 32 a6 fd			ld (debug_mark),a  
490a 3a 19 49			ld a, (.dmark+1)  
490d 32 a7 fd			ld (debug_mark+1),a  
4910 3a 1a 49			ld a, (.dmark+2)  
4913 32 a8 fd			ld (debug_mark+2),a  
4916 18 03			jr .pastdmark  
4918 ..			.dmark: db "SST"  
491b f1			.pastdmark: pop af  
491c			endm  
# End of macro DMARK
491c						CALLMONITOR 
491c cd aa fd			call debug_vector  
491f				endm  
# End of macro CALLMONITOR
491f					endif 
491f			; TODO check string type 
491f					FORTH_DSP_VALUEHL 
491f cd fa 22			call macro_dsp_valuehl 
4922				endm 
# End of macro FORTH_DSP_VALUEHL
4922			 
4922 e5					push hl      ; string length 
4923			 
4923					FORTH_DSP_POP 
4923 cd b2 23			call macro_forth_dsp_pop 
4926				endm 
# End of macro FORTH_DSP_POP
4926			 
4926					FORTH_DSP_VALUEHL 
4926 cd fa 22			call macro_dsp_valuehl 
4929				endm 
# End of macro FORTH_DSP_VALUEHL
4929			 
4929 e5					push hl     ; start char 
492a			 
492a					FORTH_DSP_POP 
492a cd b2 23			call macro_forth_dsp_pop 
492d				endm 
# End of macro FORTH_DSP_POP
492d			 
492d			 
492d					FORTH_DSP_VALUE 
492d cd e3 22			call macro_forth_dsp_value 
4930				endm 
# End of macro FORTH_DSP_VALUE
4930			 
4930 d1					pop de    ; get start post offset 
4931			 
4931 19					add hl, de    ; starting offset 
4932			 
4932 c1					pop bc 
4933 c5					push bc      ; grab size of string 
4934			 
4934 e5					push hl    ; save string start  
4935			 
4935 26 00				ld h, 0 
4937 69					ld l, c 
4938 23					inc hl 
4939 23					inc hl 
493a			 
493a cd a2 14				call malloc 
493d				if DEBUG_FORTH_MALLOC_GUARD 
493d cc 83 5e				call z,malloc_error 
4940				endif 
4940			 
4940 eb					ex de, hl      ; save malloc area for string copy 
4941 e1					pop hl    ; get back source 
4942 c1					pop bc    ; get length of string back 
4943			 
4943 d5					push de    ; save malloc area for after we push 
4944 ed b0				ldir     ; copy substr 
4946			 
4946			 
4946 eb					ex de, hl 
4947 3e 00				ld a, 0 
4949 77					ld (hl), a   ; term substr 
494a			 
494a					 
494a e1					pop hl    ; get malloc so we can push it 
494b e5					push hl   ; save so we can free it afterwards 
494c			 
494c cd 71 21				call forth_push_str 
494f			 
494f e1					pop hl 
4950 cd 6c 15				call free 
4953			 
4953					 
4953					 
4953			 
4953			 
4953					NEXTW 
4953 c3 b0 24			jp macro_next 
4956				endm 
# End of macro NEXTW
4956			 
4956			.LEFT: 
4956				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4956 48				db WORD_SYS_CORE+52             
4957 7e 49			dw .RIGHT            
4959 05				db 4 + 1 
495a .. 00			db "LEFT",0              
495f				endm 
# End of macro CWHEAD
495f			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
495f					if DEBUG_FORTH_WORDS_KEY 
495f						DMARK "LEF" 
495f f5				push af  
4960 3a 74 49			ld a, (.dmark)  
4963 32 a6 fd			ld (debug_mark),a  
4966 3a 75 49			ld a, (.dmark+1)  
4969 32 a7 fd			ld (debug_mark+1),a  
496c 3a 76 49			ld a, (.dmark+2)  
496f 32 a8 fd			ld (debug_mark+2),a  
4972 18 03			jr .pastdmark  
4974 ..			.dmark: db "LEF"  
4977 f1			.pastdmark: pop af  
4978			endm  
# End of macro DMARK
4978						CALLMONITOR 
4978 cd aa fd			call debug_vector  
497b				endm  
# End of macro CALLMONITOR
497b					endif 
497b			 
497b					NEXTW 
497b c3 b0 24			jp macro_next 
497e				endm 
# End of macro NEXTW
497e			.RIGHT: 
497e				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
497e 48				db WORD_SYS_CORE+52             
497f a7 49			dw .STR2NUM            
4981 06				db 5 + 1 
4982 .. 00			db "RIGHT",0              
4988				endm 
# End of macro CWHEAD
4988			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4988					if DEBUG_FORTH_WORDS_KEY 
4988						DMARK "RIG" 
4988 f5				push af  
4989 3a 9d 49			ld a, (.dmark)  
498c 32 a6 fd			ld (debug_mark),a  
498f 3a 9e 49			ld a, (.dmark+1)  
4992 32 a7 fd			ld (debug_mark+1),a  
4995 3a 9f 49			ld a, (.dmark+2)  
4998 32 a8 fd			ld (debug_mark+2),a  
499b 18 03			jr .pastdmark  
499d ..			.dmark: db "RIG"  
49a0 f1			.pastdmark: pop af  
49a1			endm  
# End of macro DMARK
49a1						CALLMONITOR 
49a1 cd aa fd			call debug_vector  
49a4				endm  
# End of macro CALLMONITOR
49a4					endif 
49a4			 
49a4					NEXTW 
49a4 c3 b0 24			jp macro_next 
49a7				endm 
# End of macro NEXTW
49a7			 
49a7			 
49a7			.STR2NUM: 
49a7				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
49a7 48				db WORD_SYS_CORE+52             
49a8 33 4a			dw .NUM2STR            
49aa 08				db 7 + 1 
49ab .. 00			db "STR2NUM",0              
49b3				endm 
# End of macro CWHEAD
49b3			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
49b3			 
49b3			 
49b3			; TODO STR type check to do 
49b3					if DEBUG_FORTH_WORDS_KEY 
49b3						DMARK "S2N" 
49b3 f5				push af  
49b4 3a c8 49			ld a, (.dmark)  
49b7 32 a6 fd			ld (debug_mark),a  
49ba 3a c9 49			ld a, (.dmark+1)  
49bd 32 a7 fd			ld (debug_mark+1),a  
49c0 3a ca 49			ld a, (.dmark+2)  
49c3 32 a8 fd			ld (debug_mark+2),a  
49c6 18 03			jr .pastdmark  
49c8 ..			.dmark: db "S2N"  
49cb f1			.pastdmark: pop af  
49cc			endm  
# End of macro DMARK
49cc						CALLMONITOR 
49cc cd aa fd			call debug_vector  
49cf				endm  
# End of macro CALLMONITOR
49cf					endif 
49cf			 
49cf					;FORTH_DSP 
49cf					FORTH_DSP_VALUE 
49cf cd e3 22			call macro_forth_dsp_value 
49d2				endm 
# End of macro FORTH_DSP_VALUE
49d2					;inc hl 
49d2			 
49d2 eb					ex de, hl 
49d3					if DEBUG_FORTH_WORDS 
49d3						DMARK "S2a" 
49d3 f5				push af  
49d4 3a e8 49			ld a, (.dmark)  
49d7 32 a6 fd			ld (debug_mark),a  
49da 3a e9 49			ld a, (.dmark+1)  
49dd 32 a7 fd			ld (debug_mark+1),a  
49e0 3a ea 49			ld a, (.dmark+2)  
49e3 32 a8 fd			ld (debug_mark+2),a  
49e6 18 03			jr .pastdmark  
49e8 ..			.dmark: db "S2a"  
49eb f1			.pastdmark: pop af  
49ec			endm  
# End of macro DMARK
49ec						CALLMONITOR 
49ec cd aa fd			call debug_vector  
49ef				endm  
# End of macro CALLMONITOR
49ef					endif 
49ef cd c4 13				call string_to_uint16 
49f2			 
49f2					if DEBUG_FORTH_WORDS 
49f2						DMARK "S2b" 
49f2 f5				push af  
49f3 3a 07 4a			ld a, (.dmark)  
49f6 32 a6 fd			ld (debug_mark),a  
49f9 3a 08 4a			ld a, (.dmark+1)  
49fc 32 a7 fd			ld (debug_mark+1),a  
49ff 3a 09 4a			ld a, (.dmark+2)  
4a02 32 a8 fd			ld (debug_mark+2),a  
4a05 18 03			jr .pastdmark  
4a07 ..			.dmark: db "S2b"  
4a0a f1			.pastdmark: pop af  
4a0b			endm  
# End of macro DMARK
4a0b						CALLMONITOR 
4a0b cd aa fd			call debug_vector  
4a0e				endm  
# End of macro CALLMONITOR
4a0e					endif 
4a0e			;		push hl 
4a0e					FORTH_DSP_POP 
4a0e cd b2 23			call macro_forth_dsp_pop 
4a11				endm 
# End of macro FORTH_DSP_POP
4a11			;		pop hl 
4a11					 
4a11					if DEBUG_FORTH_WORDS 
4a11						DMARK "S2b" 
4a11 f5				push af  
4a12 3a 26 4a			ld a, (.dmark)  
4a15 32 a6 fd			ld (debug_mark),a  
4a18 3a 27 4a			ld a, (.dmark+1)  
4a1b 32 a7 fd			ld (debug_mark+1),a  
4a1e 3a 28 4a			ld a, (.dmark+2)  
4a21 32 a8 fd			ld (debug_mark+2),a  
4a24 18 03			jr .pastdmark  
4a26 ..			.dmark: db "S2b"  
4a29 f1			.pastdmark: pop af  
4a2a			endm  
# End of macro DMARK
4a2a						CALLMONITOR 
4a2a cd aa fd			call debug_vector  
4a2d				endm  
# End of macro CALLMONITOR
4a2d					endif 
4a2d cd 03 21				call forth_push_numhl	 
4a30			 
4a30				 
4a30				       NEXTW 
4a30 c3 b0 24			jp macro_next 
4a33				endm 
# End of macro NEXTW
4a33			.NUM2STR: 
4a33				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4a33 48				db WORD_SYS_CORE+52             
4a34 42 4a			dw .CONCAT            
4a36 08				db 7 + 1 
4a37 .. 00			db "NUM2STR",0              
4a3f				endm 
# End of macro CWHEAD
4a3f			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
4a3f			 
4a3f			;		; malloc a string to target 
4a3f			;		ld hl, 10     ; TODO max string size should be fine 
4a3f			;		call malloc 
4a3f			;		push hl    ; save malloc location 
4a3f			; 
4a3f			; 
4a3f			;; TODO check int type 
4a3f			;		FORTH_DSP_VALUEHL 
4a3f			;		ld a, l 
4a3f			;		call DispAToASCII   
4a3f			;;TODO need to chage above call to dump into string 
4a3f			; 
4a3f			; 
4a3f			 
4a3f				       NEXTW 
4a3f c3 b0 24			jp macro_next 
4a42				endm 
# End of macro NEXTW
4a42			 
4a42			.CONCAT: 
4a42				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4a42 48				db WORD_SYS_CORE+52             
4a43 f5 4a			dw .FIND            
4a45 07				db 6 + 1 
4a46 .. 00			db "CONCAT",0              
4a4d				endm 
# End of macro CWHEAD
4a4d			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4a4d			 
4a4d			; TODO check string type 
4a4d			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4a4d			 
4a4d					if DEBUG_FORTH_WORDS_KEY 
4a4d						DMARK "CON" 
4a4d f5				push af  
4a4e 3a 62 4a			ld a, (.dmark)  
4a51 32 a6 fd			ld (debug_mark),a  
4a54 3a 63 4a			ld a, (.dmark+1)  
4a57 32 a7 fd			ld (debug_mark+1),a  
4a5a 3a 64 4a			ld a, (.dmark+2)  
4a5d 32 a8 fd			ld (debug_mark+2),a  
4a60 18 03			jr .pastdmark  
4a62 ..			.dmark: db "CON"  
4a65 f1			.pastdmark: pop af  
4a66			endm  
# End of macro DMARK
4a66						CALLMONITOR 
4a66 cd aa fd			call debug_vector  
4a69				endm  
# End of macro CALLMONITOR
4a69					endif 
4a69			 
4a69			 
4a69					FORTH_DSP_VALUE 
4a69 cd e3 22			call macro_forth_dsp_value 
4a6c				endm 
# End of macro FORTH_DSP_VALUE
4a6c e5					push hl   ; s2 
4a6d			 
4a6d					FORTH_DSP_POP 
4a6d cd b2 23			call macro_forth_dsp_pop 
4a70				endm 
# End of macro FORTH_DSP_POP
4a70			 
4a70					FORTH_DSP_VALUE 
4a70 cd e3 22			call macro_forth_dsp_value 
4a73				endm 
# End of macro FORTH_DSP_VALUE
4a73			 
4a73 e5					push hl   ; s1 
4a74			 
4a74					FORTH_DSP_POP 
4a74 cd b2 23			call macro_forth_dsp_pop 
4a77				endm 
# End of macro FORTH_DSP_POP
4a77					 
4a77			 
4a77					; copy s1 
4a77			 
4a77				 
4a77					; save ptr 
4a77 e1					pop hl  
4a78 e5					push hl 
4a79 3e 00				ld a, 0 
4a7b cd 38 14				call strlent 
4a7e					;inc hl    ; zer0 
4a7e 06 00				ld b, 0 
4a80 4d					ld c, l 
4a81 e1					pop hl		 
4a82 11 fc f0				ld de, scratch	 
4a85					if DEBUG_FORTH_WORDS 
4a85						DMARK "CO1" 
4a85 f5				push af  
4a86 3a 9a 4a			ld a, (.dmark)  
4a89 32 a6 fd			ld (debug_mark),a  
4a8c 3a 9b 4a			ld a, (.dmark+1)  
4a8f 32 a7 fd			ld (debug_mark+1),a  
4a92 3a 9c 4a			ld a, (.dmark+2)  
4a95 32 a8 fd			ld (debug_mark+2),a  
4a98 18 03			jr .pastdmark  
4a9a ..			.dmark: db "CO1"  
4a9d f1			.pastdmark: pop af  
4a9e			endm  
# End of macro DMARK
4a9e						CALLMONITOR 
4a9e cd aa fd			call debug_vector  
4aa1				endm  
# End of macro CALLMONITOR
4aa1					endif 
4aa1 ed b0				ldir 
4aa3			 
4aa3 e1					pop hl 
4aa4 e5					push hl 
4aa5 d5					push de 
4aa6			 
4aa6			 
4aa6 3e 00				ld a, 0 
4aa8 cd 38 14				call strlent 
4aab 23					inc hl    ; zer0 
4aac 23					inc hl 
4aad 06 00				ld b, 0 
4aaf 4d					ld c, l 
4ab0 d1					pop de 
4ab1 e1					pop hl		 
4ab2					if DEBUG_FORTH_WORDS 
4ab2						DMARK "CO2" 
4ab2 f5				push af  
4ab3 3a c7 4a			ld a, (.dmark)  
4ab6 32 a6 fd			ld (debug_mark),a  
4ab9 3a c8 4a			ld a, (.dmark+1)  
4abc 32 a7 fd			ld (debug_mark+1),a  
4abf 3a c9 4a			ld a, (.dmark+2)  
4ac2 32 a8 fd			ld (debug_mark+2),a  
4ac5 18 03			jr .pastdmark  
4ac7 ..			.dmark: db "CO2"  
4aca f1			.pastdmark: pop af  
4acb			endm  
# End of macro DMARK
4acb						CALLMONITOR 
4acb cd aa fd			call debug_vector  
4ace				endm  
# End of macro CALLMONITOR
4ace					endif 
4ace ed b0				ldir 
4ad0			 
4ad0			 
4ad0			 
4ad0 21 fc f0				ld hl, scratch 
4ad3					if DEBUG_FORTH_WORDS 
4ad3						DMARK "CO5" 
4ad3 f5				push af  
4ad4 3a e8 4a			ld a, (.dmark)  
4ad7 32 a6 fd			ld (debug_mark),a  
4ada 3a e9 4a			ld a, (.dmark+1)  
4add 32 a7 fd			ld (debug_mark+1),a  
4ae0 3a ea 4a			ld a, (.dmark+2)  
4ae3 32 a8 fd			ld (debug_mark+2),a  
4ae6 18 03			jr .pastdmark  
4ae8 ..			.dmark: db "CO5"  
4aeb f1			.pastdmark: pop af  
4aec			endm  
# End of macro DMARK
4aec						CALLMONITOR 
4aec cd aa fd			call debug_vector  
4aef				endm  
# End of macro CALLMONITOR
4aef					endif 
4aef			 
4aef cd 71 21				call forth_push_str 
4af2			 
4af2			 
4af2			 
4af2			 
4af2				       NEXTW 
4af2 c3 b0 24			jp macro_next 
4af5				endm 
# End of macro NEXTW
4af5			 
4af5			 
4af5			.FIND: 
4af5				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4af5 4b				db WORD_SYS_CORE+55             
4af6 b3 4b			dw .LEN            
4af8 05				db 4 + 1 
4af9 .. 00			db "FIND",0              
4afe				endm 
# End of macro CWHEAD
4afe			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4afe			 
4afe					if DEBUG_FORTH_WORDS_KEY 
4afe						DMARK "FND" 
4afe f5				push af  
4aff 3a 13 4b			ld a, (.dmark)  
4b02 32 a6 fd			ld (debug_mark),a  
4b05 3a 14 4b			ld a, (.dmark+1)  
4b08 32 a7 fd			ld (debug_mark+1),a  
4b0b 3a 15 4b			ld a, (.dmark+2)  
4b0e 32 a8 fd			ld (debug_mark+2),a  
4b11 18 03			jr .pastdmark  
4b13 ..			.dmark: db "FND"  
4b16 f1			.pastdmark: pop af  
4b17			endm  
# End of macro DMARK
4b17						CALLMONITOR 
4b17 cd aa fd			call debug_vector  
4b1a				endm  
# End of macro CALLMONITOR
4b1a					endif 
4b1a			 
4b1a			; TODO check string type 
4b1a					FORTH_DSP_VALUE 
4b1a cd e3 22			call macro_forth_dsp_value 
4b1d				endm 
# End of macro FORTH_DSP_VALUE
4b1d			 
4b1d e5					push hl    
4b1e 7e					ld a,(hl)    ; char to find   
4b1f			; TODO change char to substr 
4b1f			 
4b1f f5					push af 
4b20					 
4b20			 
4b20			 
4b20					if DEBUG_FORTH_WORDS 
4b20						DMARK "FN1" 
4b20 f5				push af  
4b21 3a 35 4b			ld a, (.dmark)  
4b24 32 a6 fd			ld (debug_mark),a  
4b27 3a 36 4b			ld a, (.dmark+1)  
4b2a 32 a7 fd			ld (debug_mark+1),a  
4b2d 3a 37 4b			ld a, (.dmark+2)  
4b30 32 a8 fd			ld (debug_mark+2),a  
4b33 18 03			jr .pastdmark  
4b35 ..			.dmark: db "FN1"  
4b38 f1			.pastdmark: pop af  
4b39			endm  
# End of macro DMARK
4b39						CALLMONITOR 
4b39 cd aa fd			call debug_vector  
4b3c				endm  
# End of macro CALLMONITOR
4b3c					endif 
4b3c			 
4b3c					FORTH_DSP_POP 
4b3c cd b2 23			call macro_forth_dsp_pop 
4b3f				endm 
# End of macro FORTH_DSP_POP
4b3f			 
4b3f					; string to search 
4b3f			 
4b3f					FORTH_DSP_VALUE 
4b3f cd e3 22			call macro_forth_dsp_value 
4b42				endm 
# End of macro FORTH_DSP_VALUE
4b42			 
4b42 d1					pop de  ; d is char to find  
4b43			 
4b43					if DEBUG_FORTH_WORDS 
4b43						DMARK "FN2" 
4b43 f5				push af  
4b44 3a 58 4b			ld a, (.dmark)  
4b47 32 a6 fd			ld (debug_mark),a  
4b4a 3a 59 4b			ld a, (.dmark+1)  
4b4d 32 a7 fd			ld (debug_mark+1),a  
4b50 3a 5a 4b			ld a, (.dmark+2)  
4b53 32 a8 fd			ld (debug_mark+2),a  
4b56 18 03			jr .pastdmark  
4b58 ..			.dmark: db "FN2"  
4b5b f1			.pastdmark: pop af  
4b5c			endm  
# End of macro DMARK
4b5c						CALLMONITOR 
4b5c cd aa fd			call debug_vector  
4b5f				endm  
# End of macro CALLMONITOR
4b5f					endif 
4b5f					 
4b5f 01 00 00				ld bc, 0 
4b62 7e			.findchar:      ld a,(hl) 
4b63 fe 00				cp 0   		 
4b65 28 27				jr z, .finddone     
4b67 ba					cp d 
4b68 28 20				jr z, .foundchar 
4b6a 03					inc bc 
4b6b 23					inc hl 
4b6c					if DEBUG_FORTH_WORDS 
4b6c						DMARK "FN3" 
4b6c f5				push af  
4b6d 3a 81 4b			ld a, (.dmark)  
4b70 32 a6 fd			ld (debug_mark),a  
4b73 3a 82 4b			ld a, (.dmark+1)  
4b76 32 a7 fd			ld (debug_mark+1),a  
4b79 3a 83 4b			ld a, (.dmark+2)  
4b7c 32 a8 fd			ld (debug_mark+2),a  
4b7f 18 03			jr .pastdmark  
4b81 ..			.dmark: db "FN3"  
4b84 f1			.pastdmark: pop af  
4b85			endm  
# End of macro DMARK
4b85						CALLMONITOR 
4b85 cd aa fd			call debug_vector  
4b88				endm  
# End of macro CALLMONITOR
4b88					endif 
4b88 18 d8				jr .findchar 
4b8a			 
4b8a			 
4b8a c5			.foundchar:	push bc 
4b8b e1					pop hl 
4b8c 18 03				jr .findexit 
4b8e			 
4b8e			 
4b8e							 
4b8e			 
4b8e			.finddone:     ; got to end of string with no find 
4b8e 21 00 00				ld hl, 0 
4b91			.findexit: 
4b91			 
4b91					if DEBUG_FORTH_WORDS 
4b91						DMARK "FNd" 
4b91 f5				push af  
4b92 3a a6 4b			ld a, (.dmark)  
4b95 32 a6 fd			ld (debug_mark),a  
4b98 3a a7 4b			ld a, (.dmark+1)  
4b9b 32 a7 fd			ld (debug_mark+1),a  
4b9e 3a a8 4b			ld a, (.dmark+2)  
4ba1 32 a8 fd			ld (debug_mark+2),a  
4ba4 18 03			jr .pastdmark  
4ba6 ..			.dmark: db "FNd"  
4ba9 f1			.pastdmark: pop af  
4baa			endm  
# End of macro DMARK
4baa						CALLMONITOR 
4baa cd aa fd			call debug_vector  
4bad				endm  
# End of macro CALLMONITOR
4bad					endif 
4bad cd 03 21			call forth_push_numhl 
4bb0			 
4bb0				       NEXTW 
4bb0 c3 b0 24			jp macro_next 
4bb3				endm 
# End of macro NEXTW
4bb3			 
4bb3			.LEN: 
4bb3				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4bb3 4c				db WORD_SYS_CORE+56             
4bb4 1d 4c			dw .ASC            
4bb6 06				db 5 + 1 
4bb7 .. 00			db "COUNT",0              
4bbd				endm 
# End of macro CWHEAD
4bbd			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4bbd			 
4bbd					if DEBUG_FORTH_WORDS_KEY 
4bbd						DMARK "CNT" 
4bbd f5				push af  
4bbe 3a d2 4b			ld a, (.dmark)  
4bc1 32 a6 fd			ld (debug_mark),a  
4bc4 3a d3 4b			ld a, (.dmark+1)  
4bc7 32 a7 fd			ld (debug_mark+1),a  
4bca 3a d4 4b			ld a, (.dmark+2)  
4bcd 32 a8 fd			ld (debug_mark+2),a  
4bd0 18 03			jr .pastdmark  
4bd2 ..			.dmark: db "CNT"  
4bd5 f1			.pastdmark: pop af  
4bd6			endm  
# End of macro DMARK
4bd6						CALLMONITOR 
4bd6 cd aa fd			call debug_vector  
4bd9				endm  
# End of macro CALLMONITOR
4bd9					endif 
4bd9			; TODO check string type 
4bd9					FORTH_DSP_VALUE 
4bd9 cd e3 22			call macro_forth_dsp_value 
4bdc				endm 
# End of macro FORTH_DSP_VALUE
4bdc			 
4bdc			 
4bdc					if DEBUG_FORTH_WORDS 
4bdc						DMARK "CN?" 
4bdc f5				push af  
4bdd 3a f1 4b			ld a, (.dmark)  
4be0 32 a6 fd			ld (debug_mark),a  
4be3 3a f2 4b			ld a, (.dmark+1)  
4be6 32 a7 fd			ld (debug_mark+1),a  
4be9 3a f3 4b			ld a, (.dmark+2)  
4bec 32 a8 fd			ld (debug_mark+2),a  
4bef 18 03			jr .pastdmark  
4bf1 ..			.dmark: db "CN?"  
4bf4 f1			.pastdmark: pop af  
4bf5			endm  
# End of macro DMARK
4bf5						CALLMONITOR 
4bf5 cd aa fd			call debug_vector  
4bf8				endm  
# End of macro CALLMONITOR
4bf8					endif 
4bf8 cd 2d 14				call strlenz 
4bfb					if DEBUG_FORTH_WORDS 
4bfb						DMARK "CNl" 
4bfb f5				push af  
4bfc 3a 10 4c			ld a, (.dmark)  
4bff 32 a6 fd			ld (debug_mark),a  
4c02 3a 11 4c			ld a, (.dmark+1)  
4c05 32 a7 fd			ld (debug_mark+1),a  
4c08 3a 12 4c			ld a, (.dmark+2)  
4c0b 32 a8 fd			ld (debug_mark+2),a  
4c0e 18 03			jr .pastdmark  
4c10 ..			.dmark: db "CNl"  
4c13 f1			.pastdmark: pop af  
4c14			endm  
# End of macro DMARK
4c14						CALLMONITOR 
4c14 cd aa fd			call debug_vector  
4c17				endm  
# End of macro CALLMONITOR
4c17					endif 
4c17			 
4c17 cd 03 21				call forth_push_numhl 
4c1a			 
4c1a			 
4c1a			 
4c1a				       NEXTW 
4c1a c3 b0 24			jp macro_next 
4c1d				endm 
# End of macro NEXTW
4c1d			.ASC: 
4c1d				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4c1d 4d				db WORD_SYS_CORE+57             
4c1e 8b 4c			dw .CHR            
4c20 04				db 3 + 1 
4c21 .. 00			db "ASC",0              
4c25				endm 
# End of macro CWHEAD
4c25			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4c25					if DEBUG_FORTH_WORDS_KEY 
4c25						DMARK "ASC" 
4c25 f5				push af  
4c26 3a 3a 4c			ld a, (.dmark)  
4c29 32 a6 fd			ld (debug_mark),a  
4c2c 3a 3b 4c			ld a, (.dmark+1)  
4c2f 32 a7 fd			ld (debug_mark+1),a  
4c32 3a 3c 4c			ld a, (.dmark+2)  
4c35 32 a8 fd			ld (debug_mark+2),a  
4c38 18 03			jr .pastdmark  
4c3a ..			.dmark: db "ASC"  
4c3d f1			.pastdmark: pop af  
4c3e			endm  
# End of macro DMARK
4c3e						CALLMONITOR 
4c3e cd aa fd			call debug_vector  
4c41				endm  
# End of macro CALLMONITOR
4c41					endif 
4c41					FORTH_DSP_VALUE 
4c41 cd e3 22			call macro_forth_dsp_value 
4c44				endm 
# End of macro FORTH_DSP_VALUE
4c44					;v5 FORTH_DSP_VALUE 
4c44			;		inc hl      ; now at start of numeric as string 
4c44			 
4c44 e5					push hl 
4c45			 
4c45					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c45 cd b2 23			call macro_forth_dsp_pop 
4c48				endm 
# End of macro FORTH_DSP_POP
4c48			 
4c48 e1					pop hl 
4c49			 
4c49					if DEBUG_FORTH_WORDS 
4c49						DMARK "AS1" 
4c49 f5				push af  
4c4a 3a 5e 4c			ld a, (.dmark)  
4c4d 32 a6 fd			ld (debug_mark),a  
4c50 3a 5f 4c			ld a, (.dmark+1)  
4c53 32 a7 fd			ld (debug_mark+1),a  
4c56 3a 60 4c			ld a, (.dmark+2)  
4c59 32 a8 fd			ld (debug_mark+2),a  
4c5c 18 03			jr .pastdmark  
4c5e ..			.dmark: db "AS1"  
4c61 f1			.pastdmark: pop af  
4c62			endm  
# End of macro DMARK
4c62						CALLMONITOR 
4c62 cd aa fd			call debug_vector  
4c65				endm  
# End of macro CALLMONITOR
4c65					endif 
4c65					; push the content of a onto the stack as a value 
4c65			 
4c65 7e					ld a,(hl)   ; get char 
4c66 26 00				ld h,0 
4c68 6f					ld l,a 
4c69					if DEBUG_FORTH_WORDS 
4c69						DMARK "AS2" 
4c69 f5				push af  
4c6a 3a 7e 4c			ld a, (.dmark)  
4c6d 32 a6 fd			ld (debug_mark),a  
4c70 3a 7f 4c			ld a, (.dmark+1)  
4c73 32 a7 fd			ld (debug_mark+1),a  
4c76 3a 80 4c			ld a, (.dmark+2)  
4c79 32 a8 fd			ld (debug_mark+2),a  
4c7c 18 03			jr .pastdmark  
4c7e ..			.dmark: db "AS2"  
4c81 f1			.pastdmark: pop af  
4c82			endm  
# End of macro DMARK
4c82						CALLMONITOR 
4c82 cd aa fd			call debug_vector  
4c85				endm  
# End of macro CALLMONITOR
4c85					endif 
4c85 cd 03 21				call forth_push_numhl 
4c88			 
4c88				       NEXTW 
4c88 c3 b0 24			jp macro_next 
4c8b				endm 
# End of macro NEXTW
4c8b			 
4c8b			.CHR: 
4c8b				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4c8b 4d				db WORD_SYS_CORE+57             
4c8c c7 4c			dw .ENDSTR            
4c8e 04				db 3 + 1 
4c8f .. 00			db "CHR",0              
4c93				endm 
# End of macro CWHEAD
4c93			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4c93					if DEBUG_FORTH_WORDS_KEY 
4c93						DMARK "CHR" 
4c93 f5				push af  
4c94 3a a8 4c			ld a, (.dmark)  
4c97 32 a6 fd			ld (debug_mark),a  
4c9a 3a a9 4c			ld a, (.dmark+1)  
4c9d 32 a7 fd			ld (debug_mark+1),a  
4ca0 3a aa 4c			ld a, (.dmark+2)  
4ca3 32 a8 fd			ld (debug_mark+2),a  
4ca6 18 03			jr .pastdmark  
4ca8 ..			.dmark: db "CHR"  
4cab f1			.pastdmark: pop af  
4cac			endm  
# End of macro DMARK
4cac						CALLMONITOR 
4cac cd aa fd			call debug_vector  
4caf				endm  
# End of macro CALLMONITOR
4caf					endif 
4caf					FORTH_DSP_VALUEHL 
4caf cd fa 22			call macro_dsp_valuehl 
4cb2				endm 
# End of macro FORTH_DSP_VALUEHL
4cb2			 
4cb2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4cb2 cd b2 23			call macro_forth_dsp_pop 
4cb5				endm 
# End of macro FORTH_DSP_POP
4cb5			 
4cb5					; save asci byte as a zero term string and push string 
4cb5			 
4cb5 7d					ld a,l 
4cb6 32 fc f0				ld (scratch), a 
4cb9			 
4cb9 3e 00				ld a, 0 
4cbb 32 fd f0				ld (scratch+1), a 
4cbe			 
4cbe 21 fc f0				ld hl, scratch 
4cc1 cd 71 21				call forth_push_str 
4cc4			 
4cc4			 
4cc4				       NEXTW 
4cc4 c3 b0 24			jp macro_next 
4cc7				endm 
# End of macro NEXTW
4cc7			 
4cc7			 
4cc7			 
4cc7			 
4cc7			.ENDSTR: 
4cc7			; eof 
4cc7			 
# End of file forth_words_str.asm
4cc7			include "forth_words_key.asm" 
4cc7			 
4cc7			; | ## Keyboard Words 
4cc7			 
4cc7			.KEY: 
4cc7				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4cc7 3e				db WORD_SYS_CORE+42             
4cc8 f7 4c			dw .WAITK            
4cca 04				db 3 + 1 
4ccb .. 00			db "KEY",0              
4ccf				endm 
# End of macro CWHEAD
4ccf			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4ccf			 
4ccf					if DEBUG_FORTH_WORDS_KEY 
4ccf						DMARK "KEY" 
4ccf f5				push af  
4cd0 3a e4 4c			ld a, (.dmark)  
4cd3 32 a6 fd			ld (debug_mark),a  
4cd6 3a e5 4c			ld a, (.dmark+1)  
4cd9 32 a7 fd			ld (debug_mark+1),a  
4cdc 3a e6 4c			ld a, (.dmark+2)  
4cdf 32 a8 fd			ld (debug_mark+2),a  
4ce2 18 03			jr .pastdmark  
4ce4 ..			.dmark: db "KEY"  
4ce7 f1			.pastdmark: pop af  
4ce8			endm  
# End of macro DMARK
4ce8						CALLMONITOR 
4ce8 cd aa fd			call debug_vector  
4ceb				endm  
# End of macro CALLMONITOR
4ceb					endif 
4ceb			; TODO currently waits 
4ceb cd 7d 7a				call cin 
4cee					;call cin_wait 
4cee 6f					ld l, a 
4cef 26 00				ld h, 0 
4cf1 cd 03 21				call forth_push_numhl 
4cf4					NEXTW 
4cf4 c3 b0 24			jp macro_next 
4cf7				endm 
# End of macro NEXTW
4cf7			.WAITK: 
4cf7				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4cf7 3f				db WORD_SYS_CORE+43             
4cf8 29 4d			dw .ACCEPT            
4cfa 06				db 5 + 1 
4cfb .. 00			db "WAITK",0              
4d01				endm 
# End of macro CWHEAD
4d01			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4d01					if DEBUG_FORTH_WORDS_KEY 
4d01						DMARK "WAI" 
4d01 f5				push af  
4d02 3a 16 4d			ld a, (.dmark)  
4d05 32 a6 fd			ld (debug_mark),a  
4d08 3a 17 4d			ld a, (.dmark+1)  
4d0b 32 a7 fd			ld (debug_mark+1),a  
4d0e 3a 18 4d			ld a, (.dmark+2)  
4d11 32 a8 fd			ld (debug_mark+2),a  
4d14 18 03			jr .pastdmark  
4d16 ..			.dmark: db "WAI"  
4d19 f1			.pastdmark: pop af  
4d1a			endm  
# End of macro DMARK
4d1a						CALLMONITOR 
4d1a cd aa fd			call debug_vector  
4d1d				endm  
# End of macro CALLMONITOR
4d1d					endif 
4d1d cd 6c 7a				call cin_wait 
4d20 6f					ld l, a 
4d21 26 00				ld h, 0 
4d23 cd 03 21				call forth_push_numhl 
4d26					NEXTW 
4d26 c3 b0 24			jp macro_next 
4d29				endm 
# End of macro NEXTW
4d29			.ACCEPT: 
4d29				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4d29 40				db WORD_SYS_CORE+44             
4d2a 87 4d			dw .EDIT            
4d2c 07				db 6 + 1 
4d2d .. 00			db "ACCEPT",0              
4d34				endm 
# End of macro CWHEAD
4d34			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4d34					; TODO crashes on push 
4d34					if DEBUG_FORTH_WORDS_KEY 
4d34						DMARK "ACC" 
4d34 f5				push af  
4d35 3a 49 4d			ld a, (.dmark)  
4d38 32 a6 fd			ld (debug_mark),a  
4d3b 3a 4a 4d			ld a, (.dmark+1)  
4d3e 32 a7 fd			ld (debug_mark+1),a  
4d41 3a 4b 4d			ld a, (.dmark+2)  
4d44 32 a8 fd			ld (debug_mark+2),a  
4d47 18 03			jr .pastdmark  
4d49 ..			.dmark: db "ACC"  
4d4c f1			.pastdmark: pop af  
4d4d			endm  
# End of macro DMARK
4d4d						CALLMONITOR 
4d4d cd aa fd			call debug_vector  
4d50				endm  
# End of macro CALLMONITOR
4d50					endif 
4d50 21 fa f2				ld hl, os_input 
4d53 3e 00				ld a, 0 
4d55 77					ld (hl),a 
4d56 3a 99 f9				ld a,(f_cursor_ptr) 
4d59 16 64				ld d, 100 
4d5b 0e 00				ld c, 0 
4d5d 1e 28				ld e, 40 
4d5f cd fc 0f				call input_str 
4d62					; TODO perhaps do a type check and wrap in quotes if not a number 
4d62 21 fa f2				ld hl, os_input 
4d65					if DEBUG_FORTH_WORDS 
4d65						DMARK "AC1" 
4d65 f5				push af  
4d66 3a 7a 4d			ld a, (.dmark)  
4d69 32 a6 fd			ld (debug_mark),a  
4d6c 3a 7b 4d			ld a, (.dmark+1)  
4d6f 32 a7 fd			ld (debug_mark+1),a  
4d72 3a 7c 4d			ld a, (.dmark+2)  
4d75 32 a8 fd			ld (debug_mark+2),a  
4d78 18 03			jr .pastdmark  
4d7a ..			.dmark: db "AC1"  
4d7d f1			.pastdmark: pop af  
4d7e			endm  
# End of macro DMARK
4d7e						CALLMONITOR 
4d7e cd aa fd			call debug_vector  
4d81				endm  
# End of macro CALLMONITOR
4d81					endif 
4d81 cd 71 21				call forth_push_str 
4d84					NEXTW 
4d84 c3 b0 24			jp macro_next 
4d87				endm 
# End of macro NEXTW
4d87			 
4d87			.EDIT: 
4d87				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4d87 40				db WORD_SYS_CORE+44             
4d88 29 4e			dw .DEDIT            
4d8a 05				db 4 + 1 
4d8b .. 00			db "EDIT",0              
4d90				endm 
# End of macro CWHEAD
4d90			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4d90			 
4d90					; TODO does not copy from stack 
4d90					if DEBUG_FORTH_WORDS_KEY 
4d90						DMARK "EDT" 
4d90 f5				push af  
4d91 3a a5 4d			ld a, (.dmark)  
4d94 32 a6 fd			ld (debug_mark),a  
4d97 3a a6 4d			ld a, (.dmark+1)  
4d9a 32 a7 fd			ld (debug_mark+1),a  
4d9d 3a a7 4d			ld a, (.dmark+2)  
4da0 32 a8 fd			ld (debug_mark+2),a  
4da3 18 03			jr .pastdmark  
4da5 ..			.dmark: db "EDT"  
4da8 f1			.pastdmark: pop af  
4da9			endm  
# End of macro DMARK
4da9						CALLMONITOR 
4da9 cd aa fd			call debug_vector  
4dac				endm  
# End of macro CALLMONITOR
4dac					endif 
4dac			 
4dac					;FORTH_DSP 
4dac					FORTH_DSP_VALUEHL 
4dac cd fa 22			call macro_dsp_valuehl 
4daf				endm 
# End of macro FORTH_DSP_VALUEHL
4daf			;		inc hl    ; TODO do type check 
4daf			 
4daf			;		call get_word_hl 
4daf e5					push hl 
4db0					if DEBUG_FORTH_WORDS 
4db0						DMARK "EDp" 
4db0 f5				push af  
4db1 3a c5 4d			ld a, (.dmark)  
4db4 32 a6 fd			ld (debug_mark),a  
4db7 3a c6 4d			ld a, (.dmark+1)  
4dba 32 a7 fd			ld (debug_mark+1),a  
4dbd 3a c7 4d			ld a, (.dmark+2)  
4dc0 32 a8 fd			ld (debug_mark+2),a  
4dc3 18 03			jr .pastdmark  
4dc5 ..			.dmark: db "EDp"  
4dc8 f1			.pastdmark: pop af  
4dc9			endm  
# End of macro DMARK
4dc9						CALLMONITOR 
4dc9 cd aa fd			call debug_vector  
4dcc				endm  
# End of macro CALLMONITOR
4dcc					endif 
4dcc				;	ld a, 0 
4dcc cd 2d 14				call strlenz 
4dcf 23					inc hl 
4dd0			 
4dd0 06 00				ld b, 0 
4dd2 4d					ld c, l 
4dd3			 
4dd3 e1					pop hl 
4dd4 11 fa f2				ld de, os_input 
4dd7					if DEBUG_FORTH_WORDS_KEY 
4dd7						DMARK "EDc" 
4dd7 f5				push af  
4dd8 3a ec 4d			ld a, (.dmark)  
4ddb 32 a6 fd			ld (debug_mark),a  
4dde 3a ed 4d			ld a, (.dmark+1)  
4de1 32 a7 fd			ld (debug_mark+1),a  
4de4 3a ee 4d			ld a, (.dmark+2)  
4de7 32 a8 fd			ld (debug_mark+2),a  
4dea 18 03			jr .pastdmark  
4dec ..			.dmark: db "EDc"  
4def f1			.pastdmark: pop af  
4df0			endm  
# End of macro DMARK
4df0						CALLMONITOR 
4df0 cd aa fd			call debug_vector  
4df3				endm  
# End of macro CALLMONITOR
4df3					endif 
4df3 ed b0				ldir 
4df5			 
4df5			 
4df5 21 fa f2				ld hl, os_input 
4df8					;ld a, 0 
4df8					;ld (hl),a 
4df8 3a 99 f9				ld a,(f_cursor_ptr) 
4dfb 16 64				ld d, 100 
4dfd 0e 00				ld c, 0 
4dff 1e 28				ld e, 40 
4e01 cd fc 0f				call input_str 
4e04					; TODO perhaps do a type check and wrap in quotes if not a number 
4e04 21 fa f2				ld hl, os_input 
4e07					if DEBUG_FORTH_WORDS 
4e07						DMARK "ED1" 
4e07 f5				push af  
4e08 3a 1c 4e			ld a, (.dmark)  
4e0b 32 a6 fd			ld (debug_mark),a  
4e0e 3a 1d 4e			ld a, (.dmark+1)  
4e11 32 a7 fd			ld (debug_mark+1),a  
4e14 3a 1e 4e			ld a, (.dmark+2)  
4e17 32 a8 fd			ld (debug_mark+2),a  
4e1a 18 03			jr .pastdmark  
4e1c ..			.dmark: db "ED1"  
4e1f f1			.pastdmark: pop af  
4e20			endm  
# End of macro DMARK
4e20						CALLMONITOR 
4e20 cd aa fd			call debug_vector  
4e23				endm  
# End of macro CALLMONITOR
4e23					endif 
4e23 cd 71 21				call forth_push_str 
4e26					NEXTW 
4e26 c3 b0 24			jp macro_next 
4e29				endm 
# End of macro NEXTW
4e29			 
4e29			.DEDIT: 
4e29				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4e29 40				db WORD_SYS_CORE+44             
4e2a 8b 4e			dw .ENDKEY            
4e2c 06				db 5 + 1 
4e2d .. 00			db "DEDIT",0              
4e33				endm 
# End of macro CWHEAD
4e33			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4e33			 
4e33					; TODO does not copy from stack 
4e33					if DEBUG_FORTH_WORDS_KEY 
4e33						DMARK "DED" 
4e33 f5				push af  
4e34 3a 48 4e			ld a, (.dmark)  
4e37 32 a6 fd			ld (debug_mark),a  
4e3a 3a 49 4e			ld a, (.dmark+1)  
4e3d 32 a7 fd			ld (debug_mark+1),a  
4e40 3a 4a 4e			ld a, (.dmark+2)  
4e43 32 a8 fd			ld (debug_mark+2),a  
4e46 18 03			jr .pastdmark  
4e48 ..			.dmark: db "DED"  
4e4b f1			.pastdmark: pop af  
4e4c			endm  
# End of macro DMARK
4e4c						CALLMONITOR 
4e4c cd aa fd			call debug_vector  
4e4f				endm  
# End of macro CALLMONITOR
4e4f					endif 
4e4f			 
4e4f					;FORTH_DSP 
4e4f					FORTH_DSP_VALUEHL 
4e4f cd fa 22			call macro_dsp_valuehl 
4e52				endm 
# End of macro FORTH_DSP_VALUEHL
4e52			;		inc hl    ; TODO do type check 
4e52			 
4e52			;		call get_word_hl 
4e52 e5					push hl 
4e53 e5					push hl 
4e54					FORTH_DSP_POP 
4e54 cd b2 23			call macro_forth_dsp_pop 
4e57				endm 
# End of macro FORTH_DSP_POP
4e57 e1					pop hl 
4e58					if DEBUG_FORTH_WORDS 
4e58						DMARK "EDp" 
4e58 f5				push af  
4e59 3a 6d 4e			ld a, (.dmark)  
4e5c 32 a6 fd			ld (debug_mark),a  
4e5f 3a 6e 4e			ld a, (.dmark+1)  
4e62 32 a7 fd			ld (debug_mark+1),a  
4e65 3a 6f 4e			ld a, (.dmark+2)  
4e68 32 a8 fd			ld (debug_mark+2),a  
4e6b 18 03			jr .pastdmark  
4e6d ..			.dmark: db "EDp"  
4e70 f1			.pastdmark: pop af  
4e71			endm  
# End of macro DMARK
4e71						CALLMONITOR 
4e71 cd aa fd			call debug_vector  
4e74				endm  
# End of macro CALLMONITOR
4e74					endif 
4e74				;	ld a, 0 
4e74 cd 2d 14				call strlenz 
4e77 23					inc hl 
4e78			 
4e78 06 00				ld b, 0 
4e7a 4d					ld c, l 
4e7b			 
4e7b e1					pop hl 
4e7c			 
4e7c					;ld a, 0 
4e7c					;ld (hl),a 
4e7c 3a 99 f9				ld a,(f_cursor_ptr) 
4e7f 16 64				ld d, 100 
4e81 0e 00				ld c, 0 
4e83 1e 28				ld e, 40 
4e85 cd fc 0f				call input_str 
4e88					; TODO perhaps do a type check and wrap in quotes if not a number 
4e88					NEXTW 
4e88 c3 b0 24			jp macro_next 
4e8b				endm 
# End of macro NEXTW
4e8b			 
4e8b			 
4e8b			.ENDKEY: 
4e8b			; eof 
4e8b			 
# End of file forth_words_key.asm
4e8b			include "forth_words_const.asm" 
4e8b			 
4e8b			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4e8b			 
4e8b			 
4e8b			.SPITIME: 
4e8b				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4e8b 77				db WORD_SYS_CORE+99             
4e8c a0 4e			dw .VA            
4e8e 08				db 7 + 1 
4e8f .. 00			db "SPITIME",0              
4e97				endm 
# End of macro CWHEAD
4e97			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
4e97			; 
4e97			; | | If using BANK devices then leave as is. 
4e97			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
4e97			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
4e97			 
4e97 21 9f f9				ld hl, spi_clktime  
4e9a cd 03 21				call forth_push_numhl 
4e9d			 
4e9d					NEXTW 
4e9d c3 b0 24			jp macro_next 
4ea0				endm 
# End of macro NEXTW
4ea0			 
4ea0			 
4ea0			.VA: 
4ea0				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4ea0 77				db WORD_SYS_CORE+99             
4ea1 b0 4e			dw .SYMBOL            
4ea3 03				db 2 + 1 
4ea4 .. 00			db "VA",0              
4ea7				endm 
# End of macro CWHEAD
4ea7			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
4ea7 21 63 f9				ld hl, cli_var_array 
4eaa cd 03 21				call forth_push_numhl 
4ead			 
4ead					NEXTW 
4ead c3 b0 24			jp macro_next 
4eb0				endm 
# End of macro NEXTW
4eb0			 
4eb0			.SYMBOL: 
4eb0				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4eb0 77				db WORD_SYS_CORE+99             
4eb1 ba 4f			dw .ENDCONST            
4eb3 07				db 6 + 1 
4eb4 .. 00			db "SYMBOL",0              
4ebb				endm 
# End of macro CWHEAD
4ebb			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4ebb			; | 
4ebb			; | | The value is the number reference and the final address is pushed to stack 
4ebb			 
4ebb			; | | ``` 
4ebb			; | | dw sym_table 
4ebb			; | | dw nmi_vector 
4ebb			; | | dw cli_autodisplay 
4ebb			; | | dw cli_data_sp 
4ebb			; | | dw cli_data_stack 
4ebb			; | | dw cli_loop_sp 
4ebb			; | | dw cli_loop_stack 
4ebb			; | | dw cli_var_array 
4ebb			; | | dw cursor_col 
4ebb			; | | dw cursor_ptr 
4ebb			; | | ; 10 
4ebb			; | | dw cursor_row 
4ebb			; | | dw debug_mark 
4ebb			; | | dw display_fb0 
4ebb			; | | dw display_fb1 
4ebb			; | | dw display_fb2 
4ebb			; | | dw display_fb3 
4ebb			; | | dw display_fb_active 
4ebb			; | | dw execscratch 
4ebb			; | | dw f_cursor_ptr 
4ebb			; | | dw hardware_word 
4ebb			; | | ;20 
4ebb			; | | dw input_at_cursor 
4ebb			; | | dw input_at_pos 
4ebb			; | | dw input_cur_flash 
4ebb			; | | dw input_cur_onoff 
4ebb			; | | dw input_cursor 
4ebb			; | | dw input_display_size 
4ebb			; | | dw input_len 
4ebb			; | | dw input_ptr 
4ebb			; | | dw input_size 
4ebb			; | | dw input_start 
4ebb			; | | ; 30 
4ebb			; | | dw input_str 
4ebb			; | | dw input_under_cursor 
4ebb			; | | dw os_cli_cmd 
4ebb			; | | dw os_cur_ptr 
4ebb			; | | dw os_current_i 
4ebb			; | | dw os_input 
4ebb			; | | dw os_last_cmd 
4ebb			; | | dw os_last_new_uword 
4ebb			; | | dw debug_vector 
4ebb			; | | dw os_view_hl 
4ebb			; | | ;40 
4ebb			; | | dw os_word_scratch 
4ebb			; | | dw portbctl 
4ebb			; | | dw portbdata 
4ebb			; | | dw spi_cartdev 
4ebb			; | | dw spi_cartdev2 
4ebb			; | | dw spi_clktime 
4ebb			; | | dw spi_device 
4ebb			; | | dw spi_device_id 
4ebb			; | | dw spi_portbyte 
4ebb			; | | dw stackstore 
4ebb			; | | ; 50 
4ebb			; | | if STORAGE_SE 
4ebb			; | | dw storage_actl 
4ebb			; | | dw storage_adata 
4ebb			; | | else 
4ebb			; | | dw 0 
4ebb			; | | dw 0 
4ebb			; | | endif 
4ebb			; | | dw storage_append 
4ebb			; | | if STORAGE_SE 
4ebb			; | | dw storage_bctl 
4ebb			; | | else 
4ebb			; | | dw 0 
4ebb			; | | endif 
4ebb			; | | dw store_bank_active 
4ebb			; | | dw store_filecache 
4ebb			; | | dw store_longread 
4ebb			; | | dw store_openaddr 
4ebb			; | | dw store_openext 
4ebb			; | | dw store_openmaxext 
4ebb			; | | ; 60 
4ebb			; | | dw store_page 
4ebb			; | | dw store_readbuf 
4ebb			; | | dw store_readcont 
4ebb			; | | dw store_readptr 
4ebb			; | | dw store_tmpext 
4ebb			; | | dw store_tmpid 
4ebb			; | | dw store_tmppageid 
4ebb			; | | dw malloc 
4ebb			; | | dw free 
4ebb			; | | dw cin 
4ebb			; | | ; 70 
4ebb			; | | dw cin_wait 
4ebb			; | | dw forth_push_numhl 
4ebb			; | | dw forth_push_str 
4ebb			; | | ``` 
4ebb			 
4ebb					if DEBUG_FORTH_WORDS_KEY 
4ebb						DMARK "SYM" 
4ebb f5				push af  
4ebc 3a d0 4e			ld a, (.dmark)  
4ebf 32 a6 fd			ld (debug_mark),a  
4ec2 3a d1 4e			ld a, (.dmark+1)  
4ec5 32 a7 fd			ld (debug_mark+1),a  
4ec8 3a d2 4e			ld a, (.dmark+2)  
4ecb 32 a8 fd			ld (debug_mark+2),a  
4ece 18 03			jr .pastdmark  
4ed0 ..			.dmark: db "SYM"  
4ed3 f1			.pastdmark: pop af  
4ed4			endm  
# End of macro DMARK
4ed4						CALLMONITOR 
4ed4 cd aa fd			call debug_vector  
4ed7				endm  
# End of macro CALLMONITOR
4ed7					endif 
4ed7			 
4ed7					FORTH_DSP_VALUEHL 
4ed7 cd fa 22			call macro_dsp_valuehl 
4eda				endm 
# End of macro FORTH_DSP_VALUEHL
4eda			 
4eda 7d					ld a, l     
4edb			 
4edb			 
4edb					if DEBUG_FORTH_WORDS 
4edb						DMARK "SY1" 
4edb f5				push af  
4edc 3a f0 4e			ld a, (.dmark)  
4edf 32 a6 fd			ld (debug_mark),a  
4ee2 3a f1 4e			ld a, (.dmark+1)  
4ee5 32 a7 fd			ld (debug_mark+1),a  
4ee8 3a f2 4e			ld a, (.dmark+2)  
4eeb 32 a8 fd			ld (debug_mark+2),a  
4eee 18 03			jr .pastdmark  
4ef0 ..			.dmark: db "SY1"  
4ef3 f1			.pastdmark: pop af  
4ef4			endm  
# End of macro DMARK
4ef4						CALLMONITOR 
4ef4 cd aa fd			call debug_vector  
4ef7				endm  
# End of macro CALLMONITOR
4ef7					endif 
4ef7					 
4ef7 f5					push af	 
4ef8					FORTH_DSP_POP 
4ef8 cd b2 23			call macro_forth_dsp_pop 
4efb				endm 
# End of macro FORTH_DSP_POP
4efb f1					pop af 
4efc			 
4efc cb 27				sla a  
4efe				 
4efe					 
4efe					if DEBUG_FORTH_WORDS 
4efe						DMARK "SY" 
4efe f5				push af  
4eff 3a 13 4f			ld a, (.dmark)  
4f02 32 a6 fd			ld (debug_mark),a  
4f05 3a 14 4f			ld a, (.dmark+1)  
4f08 32 a7 fd			ld (debug_mark+1),a  
4f0b 3a 15 4f			ld a, (.dmark+2)  
4f0e 32 a8 fd			ld (debug_mark+2),a  
4f11 18 02			jr .pastdmark  
4f13 ..			.dmark: db "SY"  
4f15 f1			.pastdmark: pop af  
4f16			endm  
# End of macro DMARK
4f16						CALLMONITOR 
4f16 cd aa fd			call debug_vector  
4f19				endm  
# End of macro CALLMONITOR
4f19					endif 
4f19			 
4f19 21 28 4f				ld hl, sym_table 
4f1c cd cf 0f				call addatohl 
4f1f cd 32 24				call loadwordinhl 
4f22 cd 03 21				call forth_push_numhl 
4f25			 
4f25			 
4f25				       NEXTW 
4f25 c3 b0 24			jp macro_next 
4f28				endm 
# End of macro NEXTW
4f28			 
4f28			sym_table: 
4f28			 
4f28			; 0 
4f28 28 4f		dw sym_table 
4f2a ad fd		dw nmi_vector 
4f2c 77 f9		dw cli_autodisplay 
4f2e 29 f9		dw cli_data_sp 
4f30 63 f6		dw cli_data_stack 
4f32 2b f9		dw cli_loop_sp 
4f34 65 f8		dw cli_loop_stack 
4f36 63 f9		dw cli_var_array 
4f38 00 fb		dw cursor_col 
4f3a fe fa		dw cursor_ptr 
4f3c			; 10 
4f3c ff fa		dw cursor_row 
4f3e a6 fd		dw debug_mark 
4f40 ec fc		dw display_fb0 
4f42 4b fc		dw display_fb1 
4f44 09 fb		dw display_fb2 
4f46 aa fb		dw display_fb3 
4f48 07 fb		dw display_fb_active 
4f4a fb f1		dw execscratch 
4f4c 99 f9		dw f_cursor_ptr 
4f4e b0 fd		dw hardware_word 
4f50			;20 
4f50 9d fd		dw input_at_cursor 
4f52 9f fd		dw input_at_pos 
4f54 9b fd		dw input_cur_flash 
4f56 9a fd		dw input_cur_onoff 
4f58 90 fd		dw input_cursor 
4f5a a0 fd		dw input_display_size 
4f5c 95 fd		dw input_len 
4f5e a4 fd		dw input_ptr 
4f60 a1 fd		dw input_size 
4f62 a2 fd		dw input_start 
4f64			; 30 
4f64 fc 0f		dw input_str 
4f66 9e fd		dw input_under_cursor 
4f68 23 f4		dw os_cli_cmd 
4f6a 1f f4		dw os_cur_ptr 
4f6c 21 f4		dw os_current_i 
4f6e fa f2		dw os_input 
4f70 22 f5		dw os_last_cmd 
4f72 f9 f3		dw os_last_new_uword 
4f74 aa fd		dw debug_vector 
4f76 de f0		dw os_view_hl 
4f78			;40 
4f78 01 f4		dw os_word_scratch 
4f7a c3 00		dw portbctl 
4f7c c1 00		dw portbdata 
4f7e 9e f9		dw spi_cartdev 
4f80 9d f9		dw spi_cartdev2 
4f82 9f f9		dw spi_clktime 
4f84 9b f9		dw spi_device 
4f86 9a f9		dw spi_device_id 
4f88 9c f9		dw spi_portbyte 
4f8a e2 fa		dw stackstore 
4f8c			; 50 
4f8c			if STORAGE_SE 
4f8c 82 00		dw storage_actl 
4f8e 80 00		dw storage_adata 
4f90			else 
4f90			dw 0 
4f90			dw 0 
4f90			endif 
4f90 55 0b		dw storage_append 
4f92			if STORAGE_SE 
4f92 83 00		dw storage_bctl 
4f94			else 
4f94			dw 0 
4f94			endif 
4f94 ce fa		dw store_bank_active 
4f96 a2 f9		dw store_filecache 
4f98 b0 f9		dw store_longread 
4f9a a6 f9		dw store_openaddr 
4f9c a5 f9		dw store_openext 
4f9e a4 f9		dw store_openmaxext 
4fa0			; 60 
4fa0 b5 f9		dw store_page 
4fa2 b1 f9		dw store_readbuf 
4fa4 a8 f9		dw store_readcont 
4fa6 b3 f9		dw store_readptr 
4fa8 a8 f9		dw store_tmpext 
4faa a9 f9		dw store_tmpid 
4fac a0 f9		dw store_tmppageid 
4fae a2 14		dw malloc 
4fb0 6c 15		dw free 
4fb2 7d 7a		dw cin 
4fb4			; 70 
4fb4 6c 7a		dw cin_wait 
4fb6 03 21		dw forth_push_numhl 
4fb8 71 21		dw forth_push_str 
4fba			 
4fba			 
4fba			.ENDCONST: 
4fba			 
4fba			; eof 
4fba			 
4fba			 
# End of file forth_words_const.asm
4fba			 
4fba			if STORAGE_SE 
4fba			   	include "forth_words_storage.asm" 
4fba			 
4fba			; | ## Fixed Storage Words 
4fba			 
4fba			.RENAME: 
4fba			  
4fba				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
4fba 3a				db WORD_SYS_CORE+38             
4fbb b0 50			dw .RECORD            
4fbd 07				db 6 + 1 
4fbe .. 00			db "RENAME",0              
4fc5				endm 
# End of macro CWHEAD
4fc5			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
4fc5			; | | > [!NOTE] 
4fc5			; | | > Compatible with PicoSPINet  
4fc5					if DEBUG_FORTH_WORDS_KEY 
4fc5						DMARK "REN" 
4fc5 f5				push af  
4fc6 3a da 4f			ld a, (.dmark)  
4fc9 32 a6 fd			ld (debug_mark),a  
4fcc 3a db 4f			ld a, (.dmark+1)  
4fcf 32 a7 fd			ld (debug_mark+1),a  
4fd2 3a dc 4f			ld a, (.dmark+2)  
4fd5 32 a8 fd			ld (debug_mark+2),a  
4fd8 18 03			jr .pastdmark  
4fda ..			.dmark: db "REN"  
4fdd f1			.pastdmark: pop af  
4fde			endm  
# End of macro DMARK
4fde						CALLMONITOR 
4fde cd aa fd			call debug_vector  
4fe1				endm  
# End of macro CALLMONITOR
4fe1					endif 
4fe1			 
4fe1			 
4fe1					; preserve some internal vars used by other file handing routines 
4fe1			 
4fe1 2a a6 f9				ld hl, (store_openaddr) 
4fe4 e5					push hl 
4fe5 3a a8 f9				ld a, (store_readcont) 
4fe8 f5					push af 
4fe9			 
4fe9					FORTH_DSP_VALUEHL 
4fe9 cd fa 22			call macro_dsp_valuehl 
4fec				endm 
# End of macro FORTH_DSP_VALUEHL
4fec			 
4fec					; move ext and id around for the file header 
4fec			 
4fec 65					ld h, l 
4fed 2e 00				ld l, 0 
4fef			 
4fef e5					push hl    ; id 
4ff0			 
4ff0					FORTH_DSP_POP 
4ff0 cd b2 23			call macro_forth_dsp_pop 
4ff3				endm 
# End of macro FORTH_DSP_POP
4ff3			 
4ff3					; Locate the file header 
4ff3			 
4ff3 e1					pop hl 
4ff4 e5					push hl 
4ff5 11 b5 f9				ld de, store_page      ; get block zero of file 
4ff8					if DEBUG_FORTH_WORDS 
4ff8						DMARK "REr" 
4ff8 f5				push af  
4ff9 3a 0d 50			ld a, (.dmark)  
4ffc 32 a6 fd			ld (debug_mark),a  
4fff 3a 0e 50			ld a, (.dmark+1)  
5002 32 a7 fd			ld (debug_mark+1),a  
5005 3a 0f 50			ld a, (.dmark+2)  
5008 32 a8 fd			ld (debug_mark+2),a  
500b 18 03			jr .pastdmark  
500d ..			.dmark: db "REr"  
5010 f1			.pastdmark: pop af  
5011			endm  
# End of macro DMARK
5011						CALLMONITOR 
5011 cd aa fd			call debug_vector  
5014				endm  
# End of macro CALLMONITOR
5014					endif 
5014 cd be 09				call storage_read 
5017			 
5017 cd f8 0f			call ishlzero 
501a 20 05			jr nz, .rnfound 
501c			 
501c				; file does not exist so indicate with 255 extents in use 
501c			 
501c 3e ff			ld a, 255 
501e e1				pop hl ; clear dup hl 
501f 18 7b			jr .skiprneof 
5021			 
5021			 
5021			.rnfound: 
5021					; file found so rename 
5021			 
5021					FORTH_DSP_VALUEHL 
5021 cd fa 22			call macro_dsp_valuehl 
5024				endm 
# End of macro FORTH_DSP_VALUEHL
5024			 
5024 e5				push hl 
5025 3e 00			ld a, 0 
5027 cd 38 14			call strlent 
502a 23				inc hl   ; cover zero term 
502b 06 00			ld b,0 
502d 4d				ld c,l 
502e e1				pop hl 
502f 11 b8 f9				ld de, store_page + 3 
5032 ed b0				ldir 
5034			 
5034 11 b5 f9				ld de, store_page 
5037					if DEBUG_FORTH_WORDS 
5037						DMARK "RER" 
5037 f5				push af  
5038 3a 4c 50			ld a, (.dmark)  
503b 32 a6 fd			ld (debug_mark),a  
503e 3a 4d 50			ld a, (.dmark+1)  
5041 32 a7 fd			ld (debug_mark+1),a  
5044 3a 4e 50			ld a, (.dmark+2)  
5047 32 a8 fd			ld (debug_mark+2),a  
504a 18 03			jr .pastdmark  
504c ..			.dmark: db "RER"  
504f f1			.pastdmark: pop af  
5050			endm  
# End of macro DMARK
5050						CALLMONITOR 
5050 cd aa fd			call debug_vector  
5053				endm  
# End of macro CALLMONITOR
5053					endif 
5053			 
5053 e1					pop hl    ; get orig file id and mangle it for find id 
5054 55					ld d, l 
5055 5c					ld e, h 
5056			 
5056 21 00 00				ld hl, 0 
5059					if DEBUG_FORTH_WORDS 
5059						DMARK "REf" 
5059 f5				push af  
505a 3a 6e 50			ld a, (.dmark)  
505d 32 a6 fd			ld (debug_mark),a  
5060 3a 6f 50			ld a, (.dmark+1)  
5063 32 a7 fd			ld (debug_mark+1),a  
5066 3a 70 50			ld a, (.dmark+2)  
5069 32 a8 fd			ld (debug_mark+2),a  
506c 18 03			jr .pastdmark  
506e ..			.dmark: db "REf"  
5071 f1			.pastdmark: pop af  
5072			endm  
# End of macro DMARK
5072						CALLMONITOR 
5072 cd aa fd			call debug_vector  
5075				endm  
# End of macro CALLMONITOR
5075					endif 
5075 cd 98 07				call storage_findnextid 
5078 11 b5 f9				ld de, store_page 
507b					if DEBUG_FORTH_WORDS 
507b						DMARK "REw" 
507b f5				push af  
507c 3a 90 50			ld a, (.dmark)  
507f 32 a6 fd			ld (debug_mark),a  
5082 3a 91 50			ld a, (.dmark+1)  
5085 32 a7 fd			ld (debug_mark+1),a  
5088 3a 92 50			ld a, (.dmark+2)  
508b 32 a8 fd			ld (debug_mark+2),a  
508e 18 03			jr .pastdmark  
5090 ..			.dmark: db "REw"  
5093 f1			.pastdmark: pop af  
5094			endm  
# End of macro DMARK
5094						CALLMONITOR 
5094 cd aa fd			call debug_vector  
5097				endm  
# End of macro CALLMONITOR
5097					endif 
5097 cd ca 04				call storage_write_block 
509a			 
509a 3e 00				ld a, 0 
509c			.skiprneof: 
509c					; drop file name 
509c					FORTH_DSP_POP 
509c cd b2 23			call macro_forth_dsp_pop 
509f				endm 
# End of macro FORTH_DSP_POP
509f			 
509f 6f					ld l, a 
50a0 26 00				ld h, 0 
50a2 cd 03 21				call forth_push_numhl 
50a5			 
50a5			 
50a5 f1					pop af 
50a6 32 a8 f9				ld (store_readcont),a 
50a9 e1					pop hl 
50aa 22 a6 f9				ld (store_openaddr), hl 
50ad						 
50ad				NEXTW 
50ad c3 b0 24			jp macro_next 
50b0				endm 
# End of macro NEXTW
50b0			.RECORD: 
50b0			  
50b0				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
50b0 3a				db WORD_SYS_CORE+38             
50b1 54 51			dw .BREAD            
50b3 07				db 6 + 1 
50b4 .. 00			db "RECORD",0              
50bb				endm 
# End of macro CWHEAD
50bb			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
50bb			; | | > [!NOTE] 
50bb			; | | > Compatible with PicoSPINet  
50bb			 
50bb					if DEBUG_FORTH_WORDS_KEY 
50bb						DMARK "REC" 
50bb f5				push af  
50bc 3a d0 50			ld a, (.dmark)  
50bf 32 a6 fd			ld (debug_mark),a  
50c2 3a d1 50			ld a, (.dmark+1)  
50c5 32 a7 fd			ld (debug_mark+1),a  
50c8 3a d2 50			ld a, (.dmark+2)  
50cb 32 a8 fd			ld (debug_mark+2),a  
50ce 18 03			jr .pastdmark  
50d0 ..			.dmark: db "REC"  
50d3 f1			.pastdmark: pop af  
50d4			endm  
# End of macro DMARK
50d4						CALLMONITOR 
50d4 cd aa fd			call debug_vector  
50d7				endm  
# End of macro CALLMONITOR
50d7					endif 
50d7			 
50d7					FORTH_DSP_VALUEHL 
50d7 cd fa 22			call macro_dsp_valuehl 
50da				endm 
# End of macro FORTH_DSP_VALUEHL
50da			 
50da e5					push hl    ; id 
50db			 
50db					FORTH_DSP_POP 
50db cd b2 23			call macro_forth_dsp_pop 
50de				endm 
# End of macro FORTH_DSP_POP
50de			 
50de					FORTH_DSP_VALUEHL 
50de cd fa 22			call macro_dsp_valuehl 
50e1				endm 
# End of macro FORTH_DSP_VALUEHL
50e1			 
50e1					FORTH_DSP_POP 
50e1 cd b2 23			call macro_forth_dsp_pop 
50e4				endm 
# End of macro FORTH_DSP_POP
50e4			 
50e4 d1					pop de     ; get file id 
50e5			 
50e5					; e = file id 
50e5					; l = file extent 
50e5			 
50e5			 
50e5					; construct request to access file extent 
50e5			 
50e5			;		ld a, e 
50e5 63					ld h, e 
50e6					 
50e6					 
50e6					 
50e6			 
50e6					; e has id 
50e6			 
50e6 11 b5 f9			ld de, store_page 
50e9					if DEBUG_FORTH_WORDS 
50e9						DMARK "REr" 
50e9 f5				push af  
50ea 3a fe 50			ld a, (.dmark)  
50ed 32 a6 fd			ld (debug_mark),a  
50f0 3a ff 50			ld a, (.dmark+1)  
50f3 32 a7 fd			ld (debug_mark+1),a  
50f6 3a 00 51			ld a, (.dmark+2)  
50f9 32 a8 fd			ld (debug_mark+2),a  
50fc 18 03			jr .pastdmark  
50fe ..			.dmark: db "REr"  
5101 f1			.pastdmark: pop af  
5102			endm  
# End of macro DMARK
5102						CALLMONITOR 
5102 cd aa fd			call debug_vector  
5105				endm  
# End of macro CALLMONITOR
5105					endif 
5105 cd be 09				call storage_read 
5108 cd f8 0f			call ishlzero 
510b 28 22			jr z, .recnotfound 
510d			 
510d			 
510d					if DEBUG_FORTH_WORDS 
510d						DMARK "REe" 
510d f5				push af  
510e 3a 22 51			ld a, (.dmark)  
5111 32 a6 fd			ld (debug_mark),a  
5114 3a 23 51			ld a, (.dmark+1)  
5117 32 a7 fd			ld (debug_mark+1),a  
511a 3a 24 51			ld a, (.dmark+2)  
511d 32 a8 fd			ld (debug_mark+2),a  
5120 18 03			jr .pastdmark  
5122 ..			.dmark: db "REe"  
5125 f1			.pastdmark: pop af  
5126			endm  
# End of macro DMARK
5126						CALLMONITOR 
5126 cd aa fd			call debug_vector  
5129				endm  
# End of macro CALLMONITOR
5129					endif 
5129 cd 71 21			call forth_push_str 
512c			 
512c					NEXTW 
512c c3 b0 24			jp macro_next 
512f				endm 
# End of macro NEXTW
512f			 
512f			.recnotfound: 
512f					if DEBUG_FORTH_WORDS 
512f						DMARK "REf" 
512f f5				push af  
5130 3a 44 51			ld a, (.dmark)  
5133 32 a6 fd			ld (debug_mark),a  
5136 3a 45 51			ld a, (.dmark+1)  
5139 32 a7 fd			ld (debug_mark+1),a  
513c 3a 46 51			ld a, (.dmark+2)  
513f 32 a8 fd			ld (debug_mark+2),a  
5142 18 03			jr .pastdmark  
5144 ..			.dmark: db "REf"  
5147 f1			.pastdmark: pop af  
5148			endm  
# End of macro DMARK
5148						CALLMONITOR 
5148 cd aa fd			call debug_vector  
514b				endm  
# End of macro CALLMONITOR
514b					endif 
514b 21 ff 00			ld hl, 255 
514e cd 03 21			call forth_push_numhl 
5151				NEXTW 
5151 c3 b0 24			jp macro_next 
5154				endm 
# End of macro NEXTW
5154			 
5154			 
5154			.BREAD: 
5154			  
5154				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
5154 3a				db WORD_SYS_CORE+38             
5155 d7 51			dw .BWRITE            
5157 06				db 5 + 1 
5158 .. 00			db "BREAD",0              
515e				endm 
# End of macro CWHEAD
515e			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
515e			; | | > [!NOTE] 
515e			; | | > Compatible with PicoSPINet  
515e				 
515e					if DEBUG_FORTH_WORDS_KEY 
515e						DMARK "BRD" 
515e f5				push af  
515f 3a 73 51			ld a, (.dmark)  
5162 32 a6 fd			ld (debug_mark),a  
5165 3a 74 51			ld a, (.dmark+1)  
5168 32 a7 fd			ld (debug_mark+1),a  
516b 3a 75 51			ld a, (.dmark+2)  
516e 32 a8 fd			ld (debug_mark+2),a  
5171 18 03			jr .pastdmark  
5173 ..			.dmark: db "BRD"  
5176 f1			.pastdmark: pop af  
5177			endm  
# End of macro DMARK
5177						CALLMONITOR 
5177 cd aa fd			call debug_vector  
517a				endm  
# End of macro CALLMONITOR
517a					endif 
517a			 
517a				FORTH_DSP_VALUEHL 
517a cd fa 22			call macro_dsp_valuehl 
517d				endm 
# End of macro FORTH_DSP_VALUEHL
517d			 
517d				FORTH_DSP_POP 
517d cd b2 23			call macro_forth_dsp_pop 
5180				endm 
# End of macro FORTH_DSP_POP
5180			 
5180				; calc block address 
5180			 
5180 eb				ex de, hl 
5181 3e 40			ld a, STORE_BLOCK_PHY 
5183 cd 52 0f			call Mult16 
5186			 
5186			 
5186 11 b5 f9			ld de, store_page 
5189			 
5189					if DEBUG_FORTH_WORDS 
5189						DMARK "BR1" 
5189 f5				push af  
518a 3a 9e 51			ld a, (.dmark)  
518d 32 a6 fd			ld (debug_mark),a  
5190 3a 9f 51			ld a, (.dmark+1)  
5193 32 a7 fd			ld (debug_mark+1),a  
5196 3a a0 51			ld a, (.dmark+2)  
5199 32 a8 fd			ld (debug_mark+2),a  
519c 18 03			jr .pastdmark  
519e ..			.dmark: db "BR1"  
51a1 f1			.pastdmark: pop af  
51a2			endm  
# End of macro DMARK
51a2						CALLMONITOR 
51a2 cd aa fd			call debug_vector  
51a5				endm  
# End of macro CALLMONITOR
51a5					endif 
51a5			 
51a5 cd 65 04			call storage_read_block 
51a8			 
51a8 cd f8 0f			call ishlzero 
51ab 20 05			jr nz, .brfound 
51ad			 
51ad cd 03 21			call forth_push_numhl 
51b0 18 22			jr .brdone 
51b2			 
51b2			 
51b2			.brfound: 
51b2 21 b7 f9		        ld hl, store_page+2 
51b5			 
51b5					if DEBUG_FORTH_WORDS 
51b5						DMARK "BR2" 
51b5 f5				push af  
51b6 3a ca 51			ld a, (.dmark)  
51b9 32 a6 fd			ld (debug_mark),a  
51bc 3a cb 51			ld a, (.dmark+1)  
51bf 32 a7 fd			ld (debug_mark+1),a  
51c2 3a cc 51			ld a, (.dmark+2)  
51c5 32 a8 fd			ld (debug_mark+2),a  
51c8 18 03			jr .pastdmark  
51ca ..			.dmark: db "BR2"  
51cd f1			.pastdmark: pop af  
51ce			endm  
# End of macro DMARK
51ce						CALLMONITOR 
51ce cd aa fd			call debug_vector  
51d1				endm  
# End of macro CALLMONITOR
51d1					endif 
51d1			 
51d1 cd 71 21			call forth_push_str 
51d4			 
51d4			 
51d4			.brdone: 
51d4			 
51d4					NEXTW 
51d4 c3 b0 24			jp macro_next 
51d7				endm 
# End of macro NEXTW
51d7			.BWRITE: 
51d7				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
51d7 3a				db WORD_SYS_CORE+38             
51d8 6c 52			dw .BUPD            
51da 07				db 6 + 1 
51db .. 00			db "BWRITE",0              
51e2				endm 
# End of macro CWHEAD
51e2			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
51e2			; | | > [!NOTE] 
51e2			; | | > Compatible with PicoSPINet  
51e2			 
51e2					if DEBUG_FORTH_WORDS_KEY 
51e2						DMARK "BWR" 
51e2 f5				push af  
51e3 3a f7 51			ld a, (.dmark)  
51e6 32 a6 fd			ld (debug_mark),a  
51e9 3a f8 51			ld a, (.dmark+1)  
51ec 32 a7 fd			ld (debug_mark+1),a  
51ef 3a f9 51			ld a, (.dmark+2)  
51f2 32 a8 fd			ld (debug_mark+2),a  
51f5 18 03			jr .pastdmark  
51f7 ..			.dmark: db "BWR"  
51fa f1			.pastdmark: pop af  
51fb			endm  
# End of macro DMARK
51fb						CALLMONITOR 
51fb cd aa fd			call debug_vector  
51fe				endm  
# End of macro CALLMONITOR
51fe					endif 
51fe			 
51fe				FORTH_DSP_VALUEHL 
51fe cd fa 22			call macro_dsp_valuehl 
5201				endm 
# End of macro FORTH_DSP_VALUEHL
5201			 
5201				; calc block address 
5201			 
5201 eb				ex de, hl 
5202 3e 40			ld a, STORE_BLOCK_PHY 
5204 cd 52 0f			call Mult16 
5207			 
5207 e5				push hl         ; address 
5208			 
5208				FORTH_DSP_POP 
5208 cd b2 23			call macro_forth_dsp_pop 
520b				endm 
# End of macro FORTH_DSP_POP
520b			 
520b				FORTH_DSP_VALUEHL 
520b cd fa 22			call macro_dsp_valuehl 
520e				endm 
# End of macro FORTH_DSP_VALUEHL
520e			 
520e				FORTH_DSP_POP 
520e cd b2 23			call macro_forth_dsp_pop 
5211				endm 
# End of macro FORTH_DSP_POP
5211			 
5211 cd a1 0c			call storage_clear_page 
5214			 
5214				; copy string to store page 
5214			 
5214 e5				push hl     ; save string address 
5215			 
5215 3e 00			ld a, 0 
5217 cd 38 14			call strlent 
521a			 
521a 23				inc hl 
521b			 
521b 4d				ld c, l 
521c 06 00			ld b, 0 
521e			 
521e e1				pop hl 
521f 11 b7 f9			ld de, store_page + 2 
5222					if DEBUG_FORTH_WORDS 
5222						DMARK "BW1" 
5222 f5				push af  
5223 3a 37 52			ld a, (.dmark)  
5226 32 a6 fd			ld (debug_mark),a  
5229 3a 38 52			ld a, (.dmark+1)  
522c 32 a7 fd			ld (debug_mark+1),a  
522f 3a 39 52			ld a, (.dmark+2)  
5232 32 a8 fd			ld (debug_mark+2),a  
5235 18 03			jr .pastdmark  
5237 ..			.dmark: db "BW1"  
523a f1			.pastdmark: pop af  
523b			endm  
# End of macro DMARK
523b						CALLMONITOR 
523b cd aa fd			call debug_vector  
523e				endm  
# End of macro CALLMONITOR
523e					endif 
523e ed b0			ldir 
5240			 
5240			 
5240				; poke the start of the block with flags to prevent high level file ops hitting the block 
5240			 
5240 21 ff ff			ld hl, $ffff 
5243			 
5243 22 b5 f9			ld (store_page), hl	 
5246				 
5246 e1				pop hl    ; get address 
5247 11 b5 f9			ld de, store_page 
524a			 
524a					if DEBUG_FORTH_WORDS 
524a						DMARK "BW2" 
524a f5				push af  
524b 3a 5f 52			ld a, (.dmark)  
524e 32 a6 fd			ld (debug_mark),a  
5251 3a 60 52			ld a, (.dmark+1)  
5254 32 a7 fd			ld (debug_mark+1),a  
5257 3a 61 52			ld a, (.dmark+2)  
525a 32 a8 fd			ld (debug_mark+2),a  
525d 18 03			jr .pastdmark  
525f ..			.dmark: db "BW2"  
5262 f1			.pastdmark: pop af  
5263			endm  
# End of macro DMARK
5263						CALLMONITOR 
5263 cd aa fd			call debug_vector  
5266				endm  
# End of macro CALLMONITOR
5266					endif 
5266			 
5266 cd ca 04			call storage_write_block 
5269			 
5269					NEXTW 
5269 c3 b0 24			jp macro_next 
526c				endm 
# End of macro NEXTW
526c			 
526c			.BUPD: 
526c				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
526c 3a				db WORD_SYS_CORE+38             
526d c2 52			dw .BYID            
526f 05				db 4 + 1 
5270 .. 00			db "BUPD",0              
5275				endm 
# End of macro CWHEAD
5275			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
5275			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
5275			; | | or completely different file system structure. 
5275			; | | > [!NOTE] 
5275			; | | > Compatible with PicoSPINet  
5275			 
5275					if DEBUG_FORTH_WORDS_KEY 
5275						DMARK "BUD" 
5275 f5				push af  
5276 3a 8a 52			ld a, (.dmark)  
5279 32 a6 fd			ld (debug_mark),a  
527c 3a 8b 52			ld a, (.dmark+1)  
527f 32 a7 fd			ld (debug_mark+1),a  
5282 3a 8c 52			ld a, (.dmark+2)  
5285 32 a8 fd			ld (debug_mark+2),a  
5288 18 03			jr .pastdmark  
528a ..			.dmark: db "BUD"  
528d f1			.pastdmark: pop af  
528e			endm  
# End of macro DMARK
528e						CALLMONITOR 
528e cd aa fd			call debug_vector  
5291				endm  
# End of macro CALLMONITOR
5291					endif 
5291			 
5291				FORTH_DSP_VALUEHL 
5291 cd fa 22			call macro_dsp_valuehl 
5294				endm 
# End of macro FORTH_DSP_VALUEHL
5294			 
5294				; calc block address 
5294			 
5294 eb				ex de, hl 
5295 3e 40			ld a, STORE_BLOCK_PHY 
5297 cd 52 0f			call Mult16 
529a			 
529a				FORTH_DSP_POP 
529a cd b2 23			call macro_forth_dsp_pop 
529d				endm 
# End of macro FORTH_DSP_POP
529d			 
529d			 
529d 11 b5 f9			ld de, store_page 
52a0			 
52a0					if DEBUG_FORTH_WORDS 
52a0						DMARK "BUe" 
52a0 f5				push af  
52a1 3a b5 52			ld a, (.dmark)  
52a4 32 a6 fd			ld (debug_mark),a  
52a7 3a b6 52			ld a, (.dmark+1)  
52aa 32 a7 fd			ld (debug_mark+1),a  
52ad 3a b7 52			ld a, (.dmark+2)  
52b0 32 a8 fd			ld (debug_mark+2),a  
52b3 18 03			jr .pastdmark  
52b5 ..			.dmark: db "BUe"  
52b8 f1			.pastdmark: pop af  
52b9			endm  
# End of macro DMARK
52b9						CALLMONITOR 
52b9 cd aa fd			call debug_vector  
52bc				endm  
# End of macro CALLMONITOR
52bc					endif 
52bc			 
52bc cd ca 04			call storage_write_block 
52bf			 
52bf					NEXTW 
52bf c3 b0 24			jp macro_next 
52c2				endm 
# End of macro NEXTW
52c2			 
52c2			.BYID: 
52c2			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
52c2			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
52c2			; 
52c2			;		 
52c2			;		if DEBUG_FORTH_WORDS_KEY 
52c2			;			DMARK "BYID" 
52c2			;			CALLMONITOR 
52c2			;		endif 
52c2			; 
52c2			;		; get direct address 
52c2			; 
52c2			;		FORTH_DSP_VALUEHL 
52c2			; 
52c2			;		FORTH_DSP_POP 
52c2			; 
52c2			;	; calc block address 
52c2			; 
52c2			;	ex de, hl 
52c2			;	ld a, STORE_BLOCK_PHY 
52c2			;	call Mult16 
52c2			;	;	do BREAD with number as param 
52c2			;	; push the file name	 
52c2			;	ld de, store_page 
52c2			;	call storage_read_block 
52c2			 ;       ld hl, store_page+2 
52c2			; 
52c2			; 
52c2			;		NEXTW 
52c2			;.BYNAME: 
52c2				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
52c2 3a				db WORD_SYS_CORE+38             
52c3 db 52			dw .DIR            
52c5 06				db 5 + 1 
52c6 .. 00			db "GETID",0              
52cc				endm 
# End of macro CWHEAD
52cc			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
52cc			; | | > [!NOTE] 
52cc			; | | > Compatible with PicoSPINet  
52cc			 
52cc					; get pointer to file name to seek 
52cc			 
52cc					FORTH_DSP_VALUEHL 
52cc cd fa 22			call macro_dsp_valuehl 
52cf				endm 
# End of macro FORTH_DSP_VALUEHL
52cf			 
52cf			 
52cf cd 8c 03				call storage_getid  
52d2			 
52d2					FORTH_DSP_POP 
52d2 cd b2 23			call macro_forth_dsp_pop 
52d5				endm 
# End of macro FORTH_DSP_POP
52d5			 
52d5 cd 03 21				call forth_push_numhl 
52d8			 
52d8					NEXTW 
52d8 c3 b0 24			jp macro_next 
52db				endm 
# End of macro NEXTW
52db			; 
52db			.DIR: 
52db				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
52db 3a				db WORD_SYS_CORE+38             
52dc df 53			dw .SAVE            
52de 04				db 3 + 1 
52df .. 00			db "DIR",0              
52e3				endm 
# End of macro CWHEAD
52e3			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
52e3			; | | > [!NOTE] 
52e3			; | | > Compatible with PicoSPINet  
52e3			 
52e3					if DEBUG_FORTH_WORDS_KEY 
52e3						DMARK "DIR" 
52e3 f5				push af  
52e4 3a f8 52			ld a, (.dmark)  
52e7 32 a6 fd			ld (debug_mark),a  
52ea 3a f9 52			ld a, (.dmark+1)  
52ed 32 a7 fd			ld (debug_mark+1),a  
52f0 3a fa 52			ld a, (.dmark+2)  
52f3 32 a8 fd			ld (debug_mark+2),a  
52f6 18 03			jr .pastdmark  
52f8 ..			.dmark: db "DIR"  
52fb f1			.pastdmark: pop af  
52fc			endm  
# End of macro DMARK
52fc						CALLMONITOR 
52fc cd aa fd			call debug_vector  
52ff				endm  
# End of macro CALLMONITOR
52ff					endif 
52ff cd 16 05			call storage_get_block_0 
5302			 
5302 21 b5 f9			ld hl, store_page     ; get current id count 
5305 46				ld b, (hl) 
5306 0e 00			ld c, 0    ; count of files   
5308					if DEBUG_FORTH_WORDS 
5308						DMARK "DI1" 
5308 f5				push af  
5309 3a 1d 53			ld a, (.dmark)  
530c 32 a6 fd			ld (debug_mark),a  
530f 3a 1e 53			ld a, (.dmark+1)  
5312 32 a7 fd			ld (debug_mark+1),a  
5315 3a 1f 53			ld a, (.dmark+2)  
5318 32 a8 fd			ld (debug_mark+2),a  
531b 18 03			jr .pastdmark  
531d ..			.dmark: db "DI1"  
5320 f1			.pastdmark: pop af  
5321			endm  
# End of macro DMARK
5321						CALLMONITOR 
5321 cd aa fd			call debug_vector  
5324				endm  
# End of macro CALLMONITOR
5324					endif 
5324			 
5324				; check for empty drive 
5324			 
5324 3e 00			ld a, 0 
5326 b8				cp b 
5327 ca 95 53			jp z, .dirdone 
532a			 
532a				; for each of the current ids do a search for them and if found push to stack 
532a			 
532a c5			.diritem:	push bc 
532b 21 40 00				ld hl, STORE_BLOCK_PHY 
532e 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
5330 58					ld e,b 
5331			 
5331			;		if DEBUG_FORTH_WORDS 
5331			;			DMARK "DI2" 
5331			;			CALLMONITOR 
5331			;		endif 
5331			 
5331 cd 98 07				call storage_findnextid 
5334			 
5334			;		if DEBUG_FORTH_WORDS 
5334			;			DMARK "DI3" 
5334			;			CALLMONITOR 
5334			;		endif 
5334			 
5334					; if found hl will be non zero 
5334			 
5334 cd f8 0f				call ishlzero 
5337			;		ld a, l 
5337			;		add h 
5337			; 
5337			;		cp 0 
5337 28 59				jr z, .dirnotfound 
5339			 
5339					; increase count 
5339			 
5339 c1					pop bc	 
533a 0c					inc c 
533b c5					push bc 
533c					 
533c			 
533c					; get file header and push the file name 
533c			 
533c 11 b5 f9				ld de, store_page 
533f cd 65 04				call storage_read_block 
5342			 
5342					; push file id to stack 
5342				 
5342 3a b5 f9				ld a, (store_page) 
5345 26 00				ld h, 0 
5347 6f					ld l, a 
5348 cd 03 21				call forth_push_numhl 
534b			 
534b					; push extent count to stack  
534b				 
534b 3a b7 f9				ld a, (store_page+2) 
534e 26 00				ld h, 0 
5350 6f					ld l, a 
5351 cd 03 21				call forth_push_numhl 
5354			 
5354					; push file name 
5354			 
5354 21 b8 f9				ld hl, store_page+3 
5357					if DEBUG_FORTH_WORDS 
5357						DMARK "DI5" 
5357 f5				push af  
5358 3a 6c 53			ld a, (.dmark)  
535b 32 a6 fd			ld (debug_mark),a  
535e 3a 6d 53			ld a, (.dmark+1)  
5361 32 a7 fd			ld (debug_mark+1),a  
5364 3a 6e 53			ld a, (.dmark+2)  
5367 32 a8 fd			ld (debug_mark+2),a  
536a 18 03			jr .pastdmark  
536c ..			.dmark: db "DI5"  
536f f1			.pastdmark: pop af  
5370			endm  
# End of macro DMARK
5370						CALLMONITOR 
5370 cd aa fd			call debug_vector  
5373				endm  
# End of macro CALLMONITOR
5373					endif 
5373 cd 71 21				call forth_push_str 
5376					if DEBUG_FORTH_WORDS 
5376						DMARK "DI6" 
5376 f5				push af  
5377 3a 8b 53			ld a, (.dmark)  
537a 32 a6 fd			ld (debug_mark),a  
537d 3a 8c 53			ld a, (.dmark+1)  
5380 32 a7 fd			ld (debug_mark+1),a  
5383 3a 8d 53			ld a, (.dmark+2)  
5386 32 a8 fd			ld (debug_mark+2),a  
5389 18 03			jr .pastdmark  
538b ..			.dmark: db "DI6"  
538e f1			.pastdmark: pop af  
538f			endm  
# End of macro DMARK
538f						CALLMONITOR 
538f cd aa fd			call debug_vector  
5392				endm  
# End of macro CALLMONITOR
5392					endif 
5392			.dirnotfound: 
5392 c1					pop bc     
5393 10 95				djnz .diritem 
5395				 
5395			.dirdone:	 
5395					if DEBUG_FORTH_WORDS 
5395						DMARK "DI7" 
5395 f5				push af  
5396 3a aa 53			ld a, (.dmark)  
5399 32 a6 fd			ld (debug_mark),a  
539c 3a ab 53			ld a, (.dmark+1)  
539f 32 a7 fd			ld (debug_mark+1),a  
53a2 3a ac 53			ld a, (.dmark+2)  
53a5 32 a8 fd			ld (debug_mark+2),a  
53a8 18 03			jr .pastdmark  
53aa ..			.dmark: db "DI7"  
53ad f1			.pastdmark: pop af  
53ae			endm  
# End of macro DMARK
53ae						CALLMONITOR 
53ae cd aa fd			call debug_vector  
53b1				endm  
# End of macro CALLMONITOR
53b1					endif 
53b1			 
53b1					; push a count of the dir items found 
53b1			 
53b1 26 00				ld h, 0 
53b3 69					ld l, c 
53b4 cd 03 21				call forth_push_numhl 
53b7			 
53b7					; push the bank label 
53b7			 
53b7 cd 16 05				call storage_get_block_0 
53ba			 
53ba				 
53ba 21 b8 f9		 		ld hl, store_page+3 
53bd			 
53bd					if DEBUG_FORTH_WORDS 
53bd						DMARK "DI8" 
53bd f5				push af  
53be 3a d2 53			ld a, (.dmark)  
53c1 32 a6 fd			ld (debug_mark),a  
53c4 3a d3 53			ld a, (.dmark+1)  
53c7 32 a7 fd			ld (debug_mark+1),a  
53ca 3a d4 53			ld a, (.dmark+2)  
53cd 32 a8 fd			ld (debug_mark+2),a  
53d0 18 03			jr .pastdmark  
53d2 ..			.dmark: db "DI8"  
53d5 f1			.pastdmark: pop af  
53d6			endm  
# End of macro DMARK
53d6						CALLMONITOR 
53d6 cd aa fd			call debug_vector  
53d9				endm  
# End of macro CALLMONITOR
53d9					endif 
53d9 cd 71 21				call forth_push_str 
53dc			 
53dc			 
53dc				 
53dc					NEXTW 
53dc c3 b0 24			jp macro_next 
53df				endm 
# End of macro NEXTW
53df			.SAVE: 
53df			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
53df			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
53df			;		NEXTW 
53df			;.LOAD: 
53df			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
53df			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
53df			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
53df			;; > > The LOAD command can not be used in any user words or compound lines. 
53df			; 
53df			;		; store_openext use it. If zero it is EOF 
53df			; 
53df			;		; read block from current stream id 
53df			;		; if the block does not contain zero term keep reading blocks until zero found 
53df			;		; push the block to stack 
53df			;		; save the block id to stream 
53df			; 
53df			; 
53df			;		FORTH_DSP_VALUEHL 
53df			; 
53df			;;		push hl 
53df			; 
53df			;	if DEBUG_STORESE 
53df			;		DMARK "LOA" 
53df			;		CALLMONITOR 
53df			;	endif 
53df			;		FORTH_DSP_POP 
53df			; 
53df			;;		pop hl 
53df			; 
53df			;		ld h, l 
53df			;		ld l, 0 
53df			; 
53df			;		push hl     ; stack holds current file id and extent to work with 
53df			; 
53df			; 
53df			;		ld de, store_page      ; get block zero of file 
53df			;	if DEBUG_STORESE 
53df			;		DMARK "LO0" 
53df			;		CALLMONITOR 
53df			;	endif 
53df			;		call storage_read 
53df			; 
53df			;		ld a, (store_page+2)    ; max extents for this file 
53df			;		ld  (store_openmaxext),a   ; get our limit 
53df			; 
53df			;	if DEBUG_STORESE 
53df			;		DMARK "LOE" 
53df			;		CALLMONITOR 
53df			;	endif 
53df			; 
53df			;; TODO dont know why max extents are not present 
53df			;;		cp 0 
53df			;;		jp z, .loadeof     ; dont read past eof 
53df			; 
53df			;;		ld a, 1   ; start from the head of the file 
53df			; 
53df			;.loadline:	pop hl 
53df			;		inc hl 
53df			;		ld  a, (store_openmaxext)   ; get our limit 
53df			;	if DEBUG_STORESE 
53df			;		DMARK "LOx" 
53df			;		CALLMONITOR 
53df			;	endif 
53df			;		inc a 
53df			;		cp l 
53df			;		jp z, .loadeof 
53df			;		push hl    ; save current extent 
53df			; 
53df			;		ld de, store_page 
53df			; 
53df			;	if DEBUG_STORESE 
53df			;		DMARK "LO1" 
53df			;		CALLMONITOR 
53df			;	endif 
53df			;		call storage_read 
53df			; 
53df			;	if DEBUG_STORESE 
53df			;		DMARK "LO2" 
53df			;		CALLMONITOR 
53df			;	endif 
53df			;	call ishlzero 
53df			;	ld a, l 
53df			;	add h 
53df			;	cp 0 
53df			;	jr z, .loadeof 
53df			; 
53df			;	; not eof so hl should point to data to exec 
53df			; 
53df			;	; will need to add the FORTH_END_BUFFER flag 
53df			 ; 
53df			;	ld hl, store_page+2 
53df			;	ld bc, 255 
53df			;	ld a, 0 
53df			;	cpir 
53df			;	if DEBUG_STORESE 
53df			;		DMARK "LOt" 
53df			;		CALLMONITOR 
53df			;	endif 
53df			;	dec hl 
53df			;	ld a, ' ' 
53df			;	ld (hl), a 
53df			;	inc hl 
53df			;	ld (hl), a 
53df			;	inc hl 
53df			;	ld (hl), a 
53df			;	inc hl 
53df			;	ld a, FORTH_END_BUFFER 
53df			;	ld (hl), a 
53df			; 
53df			;	; TODO handle more than a single block read 
53df			; 
53df			; 
53df			;	ld hl, store_page+2 
53df			; 
53df			;	ld (os_tok_ptr), hl 
53df			; 
53df			;	if DEBUG_STORESE 
53df			;		DMARK "LO3" 
53df			;		CALLMONITOR 
53df			;	endif 
53df			; 
53df			;	call forthparse 
53df			;	call forthexec 
53df			;	call forthexec_cleanup 
53df			; 
53df			;	; go to next extent 
53df			; 
53df			;	; get next block  or mark as eof 
53df			;	jp .loadline 
53df			; 
53df			; 
53df			; 
53df			;	       NEXTW 
53df			;.loadeof:	ld a, 0 
53df			;		ld (store_openext), a 
53df			; 
53df			;	if DEBUG_STORESE 
53df			;		DMARK "LOF" 
53df			;		CALLMONITOR 
53df			;	endif 
53df			;		ret 
53df			;		;NEXTW 
53df			;.BSAVE:   
53df			; 
53df			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
53df			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
53df			;		NEXTW 
53df			;.BLOAD: 
53df			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
53df			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
53df			;		NEXTW 
53df			;;;; counter gap 
53df			 
53df			 
53df			.SEO: 
53df				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
53df 64				db WORD_SYS_CORE+80             
53e0 fe 53			dw .SEI            
53e2 04				db 3 + 1 
53e3 .. 00			db "SEO",0              
53e7				endm 
# End of macro CWHEAD
53e7			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
53e7			 
53e7					; get port 
53e7			 
53e7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
53e7 cd fa 22			call macro_dsp_valuehl 
53ea				endm 
# End of macro FORTH_DSP_VALUEHL
53ea			 
53ea e5					push hl    ; u2 - byte 
53eb			 
53eb					; destroy value TOS 
53eb			 
53eb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
53eb cd b2 23			call macro_forth_dsp_pop 
53ee				endm 
# End of macro FORTH_DSP_POP
53ee			 
53ee					; get byte to send 
53ee			 
53ee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
53ee cd fa 22			call macro_dsp_valuehl 
53f1				endm 
# End of macro FORTH_DSP_VALUEHL
53f1			 
53f1 e5					push hl    ; u1 - addr 
53f2			 
53f2					; destroy value TOS 
53f2			 
53f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
53f2 cd b2 23			call macro_forth_dsp_pop 
53f5				endm 
# End of macro FORTH_DSP_POP
53f5			 
53f5					; one value on hl get other one back 
53f5			 
53f5 d1					pop de   ; u1 - byte 
53f6			 
53f6 e1					pop hl   ; u2 - addr 
53f7			 
53f7					; TODO Send SPI byte 
53f7			 
53f7			 
53f7 7b					ld a, e 
53f8 cd 6a 02				call se_writebyte 
53fb			 
53fb					 
53fb			 
53fb					NEXTW 
53fb c3 b0 24			jp macro_next 
53fe				endm 
# End of macro NEXTW
53fe			 
53fe			.SEI: 
53fe				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
53fe 65				db WORD_SYS_CORE+81             
53ff 18 54			dw .SFREE            
5401 04				db 3 + 1 
5402 .. 00			db "SEI",0              
5406				endm 
# End of macro CWHEAD
5406			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
5406			 
5406					; get port 
5406			 
5406					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5406 cd fa 22			call macro_dsp_valuehl 
5409				endm 
# End of macro FORTH_DSP_VALUEHL
5409			 
5409			;		push hl 
5409			 
5409					; destroy value TOS 
5409			 
5409					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5409 cd b2 23			call macro_forth_dsp_pop 
540c				endm 
# End of macro FORTH_DSP_POP
540c			 
540c					; one value on hl get other one back 
540c			 
540c			;		pop hl 
540c			 
540c			 
540c					; TODO Get SPI byte 
540c			 
540c cd 0c 03				call se_readbyte 
540f			 
540f 26 00				ld h, 0 
5411 6f					ld l, a 
5412 cd 03 21				call forth_push_numhl 
5415			 
5415					NEXTW 
5415 c3 b0 24			jp macro_next 
5418				endm 
# End of macro NEXTW
5418			 
5418			.SFREE: 
5418				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
5418 67				db WORD_SYS_CORE+83             
5419 47 54			dw .SIZE            
541b 06				db 5 + 1 
541c .. 00			db "FFREE",0              
5422				endm 
# End of macro CWHEAD
5422			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
5422			; | | > [!NOTE] 
5422			; | | > Compatible with PicoSPINet  
5422					if DEBUG_FORTH_WORDS_KEY 
5422						DMARK "FFR" 
5422 f5				push af  
5423 3a 37 54			ld a, (.dmark)  
5426 32 a6 fd			ld (debug_mark),a  
5429 3a 38 54			ld a, (.dmark+1)  
542c 32 a7 fd			ld (debug_mark+1),a  
542f 3a 39 54			ld a, (.dmark+2)  
5432 32 a8 fd			ld (debug_mark+2),a  
5435 18 03			jr .pastdmark  
5437 ..			.dmark: db "FFR"  
543a f1			.pastdmark: pop af  
543b			endm  
# End of macro DMARK
543b						CALLMONITOR 
543b cd aa fd			call debug_vector  
543e				endm  
# End of macro CALLMONITOR
543e					endif 
543e			 
543e cd 32 08				call storage_freeblocks 
5441			 
5441 cd 03 21				call forth_push_numhl 
5444			 
5444				       NEXTW 
5444 c3 b0 24			jp macro_next 
5447				endm 
# End of macro NEXTW
5447			.SIZE: 
5447				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
5447 67				db WORD_SYS_CORE+83             
5448 7b 54			dw .CREATE            
544a 05				db 4 + 1 
544b .. 00			db "SIZE",0              
5450				endm 
# End of macro CWHEAD
5450			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
5450			; | | > [!NOTE] 
5450			; | | > Compatible with PicoSPINet  
5450					if DEBUG_FORTH_WORDS_KEY 
5450						DMARK "SIZ" 
5450 f5				push af  
5451 3a 65 54			ld a, (.dmark)  
5454 32 a6 fd			ld (debug_mark),a  
5457 3a 66 54			ld a, (.dmark+1)  
545a 32 a7 fd			ld (debug_mark+1),a  
545d 3a 67 54			ld a, (.dmark+2)  
5460 32 a8 fd			ld (debug_mark+2),a  
5463 18 03			jr .pastdmark  
5465 ..			.dmark: db "SIZ"  
5468 f1			.pastdmark: pop af  
5469			endm  
# End of macro DMARK
5469						CALLMONITOR 
5469 cd aa fd			call debug_vector  
546c				endm  
# End of macro CALLMONITOR
546c					endif 
546c			 
546c					FORTH_DSP_VALUEHL 
546c cd fa 22			call macro_dsp_valuehl 
546f				endm 
# End of macro FORTH_DSP_VALUEHL
546f			;		push hl 
546f					FORTH_DSP_POP 
546f cd b2 23			call macro_forth_dsp_pop 
5472				endm 
# End of macro FORTH_DSP_POP
5472			;		pop hl 
5472 cd 94 04				call storage_file_size 
5475			 
5475 cd 03 21				call forth_push_numhl 
5478			  
5478			 
5478				       NEXTW 
5478 c3 b0 24			jp macro_next 
547b				endm 
# End of macro NEXTW
547b			 
547b			.CREATE: 
547b				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
547b 68				db WORD_SYS_CORE+84             
547c e9 54			dw .APPEND            
547e 07				db 6 + 1 
547f .. 00			db "CREATE",0              
5486				endm 
# End of macro CWHEAD
5486			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
5486			; | | e.g.  
5486			; | | TestProgram CREATE 
5486			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
5486			; | |  
5486			; | | Max file IDs are 255. 
5486			; | |  
5486			; | | > [!NOTE] 
5486			; | | > Compatible with PicoSPINet  
5486					 
5486					if DEBUG_FORTH_WORDS_KEY 
5486						DMARK "CRT" 
5486 f5				push af  
5487 3a 9b 54			ld a, (.dmark)  
548a 32 a6 fd			ld (debug_mark),a  
548d 3a 9c 54			ld a, (.dmark+1)  
5490 32 a7 fd			ld (debug_mark+1),a  
5493 3a 9d 54			ld a, (.dmark+2)  
5496 32 a8 fd			ld (debug_mark+2),a  
5499 18 03			jr .pastdmark  
549b ..			.dmark: db "CRT"  
549e f1			.pastdmark: pop af  
549f			endm  
# End of macro DMARK
549f						CALLMONITOR 
549f cd aa fd			call debug_vector  
54a2				endm  
# End of macro CALLMONITOR
54a2					endif 
54a2			;		call storage_get_block_0 
54a2			 
54a2					; TODO pop hl 
54a2			 
54a2					;v5 FORTH_DSP_VALUE 
54a2					FORTH_DSP_VALUE 
54a2 cd e3 22			call macro_forth_dsp_value 
54a5				endm 
# End of macro FORTH_DSP_VALUE
54a5			 
54a5				if DEBUG_STORESE 
54a5					DMARK "CR1" 
54a5 f5				push af  
54a6 3a ba 54			ld a, (.dmark)  
54a9 32 a6 fd			ld (debug_mark),a  
54ac 3a bb 54			ld a, (.dmark+1)  
54af 32 a7 fd			ld (debug_mark+1),a  
54b2 3a bc 54			ld a, (.dmark+2)  
54b5 32 a8 fd			ld (debug_mark+2),a  
54b8 18 03			jr .pastdmark  
54ba ..			.dmark: db "CR1"  
54bd f1			.pastdmark: pop af  
54be			endm  
# End of macro DMARK
54be					CALLMONITOR 
54be cd aa fd			call debug_vector  
54c1				endm  
# End of macro CALLMONITOR
54c1				endif 
54c1			;		push hl 
54c1			;		FORTH_DSP_POP 
54c1			;		pop hl 
54c1			 
54c1			;		inc hl   ; move past the type marker 
54c1			 
54c1 cd 68 08				call storage_create 
54c4			 
54c4				if DEBUG_STORESE 
54c4					DMARK "CT1" 
54c4 f5				push af  
54c5 3a d9 54			ld a, (.dmark)  
54c8 32 a6 fd			ld (debug_mark),a  
54cb 3a da 54			ld a, (.dmark+1)  
54ce 32 a7 fd			ld (debug_mark+1),a  
54d1 3a db 54			ld a, (.dmark+2)  
54d4 32 a8 fd			ld (debug_mark+2),a  
54d7 18 03			jr .pastdmark  
54d9 ..			.dmark: db "CT1"  
54dc f1			.pastdmark: pop af  
54dd			endm  
# End of macro DMARK
54dd					CALLMONITOR 
54dd cd aa fd			call debug_vector  
54e0				endm  
# End of macro CALLMONITOR
54e0				endif 
54e0			;		push hl 
54e0					FORTH_DSP_POP 
54e0 cd b2 23			call macro_forth_dsp_pop 
54e3				endm 
# End of macro FORTH_DSP_POP
54e3			;		pop hl 
54e3					; push file id to stack 
54e3 cd 03 21				call forth_push_numhl 
54e6			 
54e6			 
54e6			 
54e6				       NEXTW 
54e6 c3 b0 24			jp macro_next 
54e9				endm 
# End of macro NEXTW
54e9			 
54e9			.APPEND: 
54e9				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
54e9 69				db WORD_SYS_CORE+85             
54ea 7a 55			dw .SDEL            
54ec 07				db 6 + 1 
54ed .. 00			db "APPEND",0              
54f4				endm 
# End of macro CWHEAD
54f4			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
54f4			; | | e.g. 
54f4			; | | Test CREATE      -> $01 
54f4			; | | "A string to add to file" $01 APPEND 
54f4			; | |  
54f4			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
54f4			; | | > [!NOTE] 
54f4			; | | > Compatible with PicoSPINet  
54f4					if DEBUG_FORTH_WORDS_KEY 
54f4						DMARK "APP" 
54f4 f5				push af  
54f5 3a 09 55			ld a, (.dmark)  
54f8 32 a6 fd			ld (debug_mark),a  
54fb 3a 0a 55			ld a, (.dmark+1)  
54fe 32 a7 fd			ld (debug_mark+1),a  
5501 3a 0b 55			ld a, (.dmark+2)  
5504 32 a8 fd			ld (debug_mark+2),a  
5507 18 03			jr .pastdmark  
5509 ..			.dmark: db "APP"  
550c f1			.pastdmark: pop af  
550d			endm  
# End of macro DMARK
550d						CALLMONITOR 
550d cd aa fd			call debug_vector  
5510				endm  
# End of macro CALLMONITOR
5510					endif 
5510			 
5510					FORTH_DSP_VALUEHL 
5510 cd fa 22			call macro_dsp_valuehl 
5513				endm 
# End of macro FORTH_DSP_VALUEHL
5513 e5					push hl 	; save file id 
5514			 
5514				if DEBUG_STORESE 
5514					DMARK "AP1" 
5514 f5				push af  
5515 3a 29 55			ld a, (.dmark)  
5518 32 a6 fd			ld (debug_mark),a  
551b 3a 2a 55			ld a, (.dmark+1)  
551e 32 a7 fd			ld (debug_mark+1),a  
5521 3a 2b 55			ld a, (.dmark+2)  
5524 32 a8 fd			ld (debug_mark+2),a  
5527 18 03			jr .pastdmark  
5529 ..			.dmark: db "AP1"  
552c f1			.pastdmark: pop af  
552d			endm  
# End of macro DMARK
552d					CALLMONITOR 
552d cd aa fd			call debug_vector  
5530				endm  
# End of macro CALLMONITOR
5530				endif 
5530					FORTH_DSP_POP 
5530 cd b2 23			call macro_forth_dsp_pop 
5533				endm 
# End of macro FORTH_DSP_POP
5533			 
5533					FORTH_DSP_VALUEHL 
5533 cd fa 22			call macro_dsp_valuehl 
5536				endm 
# End of macro FORTH_DSP_VALUEHL
5536					;v5 FORTH_DSP_VALUE 
5536 e5					push hl 	; save ptr to string to save 
5537			 
5537				if DEBUG_STORESE 
5537					DMARK "AP1" 
5537 f5				push af  
5538 3a 4c 55			ld a, (.dmark)  
553b 32 a6 fd			ld (debug_mark),a  
553e 3a 4d 55			ld a, (.dmark+1)  
5541 32 a7 fd			ld (debug_mark+1),a  
5544 3a 4e 55			ld a, (.dmark+2)  
5547 32 a8 fd			ld (debug_mark+2),a  
554a 18 03			jr .pastdmark  
554c ..			.dmark: db "AP1"  
554f f1			.pastdmark: pop af  
5550			endm  
# End of macro DMARK
5550					CALLMONITOR 
5550 cd aa fd			call debug_vector  
5553				endm  
# End of macro CALLMONITOR
5553				endif 
5553					FORTH_DSP_POP 
5553 cd b2 23			call macro_forth_dsp_pop 
5556				endm 
# End of macro FORTH_DSP_POP
5556			 
5556 d1					pop de 
5557 e1					pop hl 
5558				if DEBUG_STORESE 
5558					DMARK "AP2" 
5558 f5				push af  
5559 3a 6d 55			ld a, (.dmark)  
555c 32 a6 fd			ld (debug_mark),a  
555f 3a 6e 55			ld a, (.dmark+1)  
5562 32 a7 fd			ld (debug_mark+1),a  
5565 3a 6f 55			ld a, (.dmark+2)  
5568 32 a8 fd			ld (debug_mark+2),a  
556b 18 03			jr .pastdmark  
556d ..			.dmark: db "AP2"  
5570 f1			.pastdmark: pop af  
5571			endm  
# End of macro DMARK
5571					CALLMONITOR 
5571 cd aa fd			call debug_vector  
5574				endm  
# End of macro CALLMONITOR
5574				endif 
5574					;inc de ; skip var type indicator 
5574			 
5574					; TODO how to append numerics???? 
5574			 
5574 cd 55 0b				call storage_append		 
5577			 
5577				       NEXTW 
5577 c3 b0 24			jp macro_next 
557a				endm 
# End of macro NEXTW
557a			.SDEL: 
557a				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
557a 6a				db WORD_SYS_CORE+86             
557b c6 55			dw .OPEN            
557d 05				db 4 + 1 
557e .. 00			db "ERA",0              
5582				endm 
# End of macro CWHEAD
5582			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
5582			; | | > [!NOTE] 
5582			; | | > Compatible with PicoSPINet  
5582					FORTH_DSP_VALUEHL 
5582 cd fa 22			call macro_dsp_valuehl 
5585				endm 
# End of macro FORTH_DSP_VALUEHL
5585			;		push hl 	; save file id 
5585			 
5585					if DEBUG_FORTH_WORDS_KEY 
5585						DMARK "ERA" 
5585 f5				push af  
5586 3a 9a 55			ld a, (.dmark)  
5589 32 a6 fd			ld (debug_mark),a  
558c 3a 9b 55			ld a, (.dmark+1)  
558f 32 a7 fd			ld (debug_mark+1),a  
5592 3a 9c 55			ld a, (.dmark+2)  
5595 32 a8 fd			ld (debug_mark+2),a  
5598 18 03			jr .pastdmark  
559a ..			.dmark: db "ERA"  
559d f1			.pastdmark: pop af  
559e			endm  
# End of macro DMARK
559e						CALLMONITOR 
559e cd aa fd			call debug_vector  
55a1				endm  
# End of macro CALLMONITOR
55a1					endif 
55a1				if DEBUG_STORESE 
55a1					DMARK "ER1" 
55a1 f5				push af  
55a2 3a b6 55			ld a, (.dmark)  
55a5 32 a6 fd			ld (debug_mark),a  
55a8 3a b7 55			ld a, (.dmark+1)  
55ab 32 a7 fd			ld (debug_mark+1),a  
55ae 3a b8 55			ld a, (.dmark+2)  
55b1 32 a8 fd			ld (debug_mark+2),a  
55b4 18 03			jr .pastdmark  
55b6 ..			.dmark: db "ER1"  
55b9 f1			.pastdmark: pop af  
55ba			endm  
# End of macro DMARK
55ba					CALLMONITOR 
55ba cd aa fd			call debug_vector  
55bd				endm  
# End of macro CALLMONITOR
55bd				endif 
55bd					FORTH_DSP_POP 
55bd cd b2 23			call macro_forth_dsp_pop 
55c0				endm 
# End of macro FORTH_DSP_POP
55c0			 
55c0			;		pop hl 
55c0			 
55c0 cd a7 06				call storage_erase 
55c3				       NEXTW 
55c3 c3 b0 24			jp macro_next 
55c6				endm 
# End of macro NEXTW
55c6			 
55c6			.OPEN: 
55c6				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
55c6 6b				db WORD_SYS_CORE+87             
55c7 5a 56			dw .READ            
55c9 05				db 4 + 1 
55ca .. 00			db "OPEN",0              
55cf				endm 
# End of macro CWHEAD
55cf			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
55cf			; | | e.g. 
55cf			; | | $01 OPEN $01 DO $01 READ . LOOP 
55cf			; | | 
55cf			; | | Will return with 255 blocks if the file does not exist 
55cf			; | | > [!NOTE] 
55cf			; | | > Compatible with PicoSPINet  
55cf			 
55cf					if DEBUG_FORTH_WORDS_KEY 
55cf						DMARK "OPN" 
55cf f5				push af  
55d0 3a e4 55			ld a, (.dmark)  
55d3 32 a6 fd			ld (debug_mark),a  
55d6 3a e5 55			ld a, (.dmark+1)  
55d9 32 a7 fd			ld (debug_mark+1),a  
55dc 3a e6 55			ld a, (.dmark+2)  
55df 32 a8 fd			ld (debug_mark+2),a  
55e2 18 03			jr .pastdmark  
55e4 ..			.dmark: db "OPN"  
55e7 f1			.pastdmark: pop af  
55e8			endm  
# End of macro DMARK
55e8						CALLMONITOR 
55e8 cd aa fd			call debug_vector  
55eb				endm  
# End of macro CALLMONITOR
55eb					endif 
55eb					; TODO handle multiple file opens 
55eb			 
55eb 3e 01			       	ld a, 1 
55ed 32 a5 f9				ld (store_openext), a 
55f0			 
55f0					; get max extents for this file 
55f0				 
55f0								 
55f0					FORTH_DSP_VALUEHL 
55f0 cd fa 22			call macro_dsp_valuehl 
55f3				endm 
# End of macro FORTH_DSP_VALUEHL
55f3			 
55f3 65					ld h, l 
55f4 2e 00				ld l, 0 
55f6			 
55f6					; store file id 
55f6			 
55f6 7c					ld a, h 
55f7 32 a2 f9				ld (store_filecache), a 
55fa			 
55fa				if DEBUG_STORESE 
55fa					DMARK "OPN" 
55fa f5				push af  
55fb 3a 0f 56			ld a, (.dmark)  
55fe 32 a6 fd			ld (debug_mark),a  
5601 3a 10 56			ld a, (.dmark+1)  
5604 32 a7 fd			ld (debug_mark+1),a  
5607 3a 11 56			ld a, (.dmark+2)  
560a 32 a8 fd			ld (debug_mark+2),a  
560d 18 03			jr .pastdmark  
560f ..			.dmark: db "OPN"  
5612 f1			.pastdmark: pop af  
5613			endm  
# End of macro DMARK
5613					CALLMONITOR 
5613 cd aa fd			call debug_vector  
5616				endm  
# End of macro CALLMONITOR
5616				endif 
5616			;		push hl 
5616					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5616 cd b2 23			call macro_forth_dsp_pop 
5619				endm 
# End of macro FORTH_DSP_POP
5619			;		pop hl 
5619						 
5619 11 b5 f9				ld de, store_page      ; get block zero of file 
561c cd be 09				call storage_read 
561f cd f8 0f			call ishlzero 
5622 20 04			jr nz, .opfound 
5624			 
5624				; file does not exist so indicate with 255 extents in use 
5624			 
5624 3e ff			ld a, 255 
5626 18 29			jr .skipopeneof 
5628			 
5628			 
5628			.opfound: 
5628			 
5628			 
5628 3a b7 f9				ld a, (store_page+2)    ; max extents for this file 
562b 32 a4 f9				ld  (store_openmaxext), a   ; get our limit and push 
562e					 
562e				if DEBUG_STORESE 
562e					DMARK "OPx" 
562e f5				push af  
562f 3a 43 56			ld a, (.dmark)  
5632 32 a6 fd			ld (debug_mark),a  
5635 3a 44 56			ld a, (.dmark+1)  
5638 32 a7 fd			ld (debug_mark+1),a  
563b 3a 45 56			ld a, (.dmark+2)  
563e 32 a8 fd			ld (debug_mark+2),a  
5641 18 03			jr .pastdmark  
5643 ..			.dmark: db "OPx"  
5646 f1			.pastdmark: pop af  
5647			endm  
# End of macro DMARK
5647					CALLMONITOR 
5647 cd aa fd			call debug_vector  
564a				endm  
# End of macro CALLMONITOR
564a				endif 
564a fe 00				cp 0 
564c 20 03				jr nz, .skipopeneof 
564e					; have opened an empty file 
564e					 
564e 32 a5 f9				ld (store_openext), a 
5651			 
5651			.skipopeneof: 
5651			 
5651 6f					ld l, a 
5652 26 00				ld h, 0 
5654 cd 03 21				call forth_push_numhl 
5657			 
5657			 
5657				       NEXTW 
5657 c3 b0 24			jp macro_next 
565a				endm 
# End of macro NEXTW
565a			.READ: 
565a				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
565a 6c				db WORD_SYS_CORE+88             
565b 84 57			dw .EOF            
565d 05				db 4 + 1 
565e .. 00			db "READ",0              
5663				endm 
# End of macro CWHEAD
5663			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
5663			; | | e.g. 
5663			; | | $01 OPEN $01 DO READ . LOOP 
5663			; | | 
5663			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
5663			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
5663			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
5663			; | | two bytes contain the file id and extent. 
5663			; | |  
5663			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
5663			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
5663			; | | > [!NOTE] 
5663			; | | > Compatible with PicoSPINet  
5663			 
5663					if DEBUG_FORTH_WORDS_KEY 
5663						DMARK "REA" 
5663 f5				push af  
5664 3a 78 56			ld a, (.dmark)  
5667 32 a6 fd			ld (debug_mark),a  
566a 3a 79 56			ld a, (.dmark+1)  
566d 32 a7 fd			ld (debug_mark+1),a  
5670 3a 7a 56			ld a, (.dmark+2)  
5673 32 a8 fd			ld (debug_mark+2),a  
5676 18 03			jr .pastdmark  
5678 ..			.dmark: db "REA"  
567b f1			.pastdmark: pop af  
567c			endm  
# End of macro DMARK
567c						CALLMONITOR 
567c cd aa fd			call debug_vector  
567f				endm  
# End of macro CALLMONITOR
567f					endif 
567f					; store_openext use it. If zero it is EOF 
567f			 
567f					; read block from current stream id 
567f					; if the block does not contain zero term keep reading blocks until zero found 
567f					; push the block to stack 
567f					; save the block id to stream 
567f			 
567f			 
567f cd b1 57				call .testeof 
5682 3e 01				ld a, 1 
5684 bd					cp l 
5685 ca 60 57				jp z, .ateof 
5688			 
5688			 
5688			;		FORTH_DSP_VALUEHL 
5688			 
5688			;		push hl 
5688			 
5688			;	if DEBUG_STORESE 
5688			;		DMARK "REA" 
5688			;		CALLMONITOR 
5688			;	endif 
5688			;		FORTH_DSP_POP 
5688			 
5688			;		pop hl 
5688				 
5688 3a a2 f9				ld a, (store_filecache) 
568b 67					ld h,a 
568c			 
568c 3a a5 f9				ld a, (store_openext) 
568f 6f					ld l, a 
5690					 
5690 fe 00				cp 0 
5692 ca 60 57				jp z, .ateof     ; dont read past eof 
5695			 
5695 cd a1 0c				call storage_clear_page 
5698			 
5698 11 b5 f9				ld de, store_page 
569b				if DEBUG_STORESE 
569b					DMARK "RE1" 
569b f5				push af  
569c 3a b0 56			ld a, (.dmark)  
569f 32 a6 fd			ld (debug_mark),a  
56a2 3a b1 56			ld a, (.dmark+1)  
56a5 32 a7 fd			ld (debug_mark+1),a  
56a8 3a b2 56			ld a, (.dmark+2)  
56ab 32 a8 fd			ld (debug_mark+2),a  
56ae 18 03			jr .pastdmark  
56b0 ..			.dmark: db "RE1"  
56b3 f1			.pastdmark: pop af  
56b4			endm  
# End of macro DMARK
56b4					CALLMONITOR 
56b4 cd aa fd			call debug_vector  
56b7				endm  
# End of macro CALLMONITOR
56b7				endif 
56b7 cd be 09				call storage_read 
56ba			 
56ba				if DEBUG_STORESE 
56ba					DMARK "RE2" 
56ba f5				push af  
56bb 3a cf 56			ld a, (.dmark)  
56be 32 a6 fd			ld (debug_mark),a  
56c1 3a d0 56			ld a, (.dmark+1)  
56c4 32 a7 fd			ld (debug_mark+1),a  
56c7 3a d1 56			ld a, (.dmark+2)  
56ca 32 a8 fd			ld (debug_mark+2),a  
56cd 18 03			jr .pastdmark  
56cf ..			.dmark: db "RE2"  
56d2 f1			.pastdmark: pop af  
56d3			endm  
# End of macro DMARK
56d3					CALLMONITOR 
56d3 cd aa fd			call debug_vector  
56d6				endm  
# End of macro CALLMONITOR
56d6				endif 
56d6 cd f8 0f			call ishlzero 
56d9			;	ld a, l 
56d9			;	add h 
56d9			;	cp 0 
56d9 ca 60 57			jp z, .readeof 
56dc			 
56dc				; not eof so hl should point to data to push to stack 
56dc			 
56dc				if DEBUG_STORESE 
56dc					DMARK "RE3" 
56dc f5				push af  
56dd 3a f1 56			ld a, (.dmark)  
56e0 32 a6 fd			ld (debug_mark),a  
56e3 3a f2 56			ld a, (.dmark+1)  
56e6 32 a7 fd			ld (debug_mark+1),a  
56e9 3a f3 56			ld a, (.dmark+2)  
56ec 32 a8 fd			ld (debug_mark+2),a  
56ef 18 03			jr .pastdmark  
56f1 ..			.dmark: db "RE3"  
56f4 f1			.pastdmark: pop af  
56f5			endm  
# End of macro DMARK
56f5					CALLMONITOR 
56f5 cd aa fd			call debug_vector  
56f8				endm  
# End of macro CALLMONITOR
56f8				endif 
56f8 cd 71 21			call forth_push_str 
56fb			 
56fb				if DEBUG_STORESE 
56fb					DMARK "RE4" 
56fb f5				push af  
56fc 3a 10 57			ld a, (.dmark)  
56ff 32 a6 fd			ld (debug_mark),a  
5702 3a 11 57			ld a, (.dmark+1)  
5705 32 a7 fd			ld (debug_mark+1),a  
5708 3a 12 57			ld a, (.dmark+2)  
570b 32 a8 fd			ld (debug_mark+2),a  
570e 18 03			jr .pastdmark  
5710 ..			.dmark: db "RE4"  
5713 f1			.pastdmark: pop af  
5714			endm  
# End of macro DMARK
5714					CALLMONITOR 
5714 cd aa fd			call debug_vector  
5717				endm  
# End of macro CALLMONITOR
5717				endif 
5717				; get next block  or mark as eof 
5717			 
5717 3a a4 f9			ld a, (store_openmaxext)   ; get our limit 
571a 4f				ld c, a	 
571b 3a a5 f9			ld a, (store_openext) 
571e			 
571e				if DEBUG_STORESE 
571e					DMARK "RE5" 
571e f5				push af  
571f 3a 33 57			ld a, (.dmark)  
5722 32 a6 fd			ld (debug_mark),a  
5725 3a 34 57			ld a, (.dmark+1)  
5728 32 a7 fd			ld (debug_mark+1),a  
572b 3a 35 57			ld a, (.dmark+2)  
572e 32 a8 fd			ld (debug_mark+2),a  
5731 18 03			jr .pastdmark  
5733 ..			.dmark: db "RE5"  
5736 f1			.pastdmark: pop af  
5737			endm  
# End of macro DMARK
5737					CALLMONITOR 
5737 cd aa fd			call debug_vector  
573a				endm  
# End of macro CALLMONITOR
573a				endif 
573a b9				cp c 
573b 28 23			jr z, .readeof     ; at last extent 
573d			 
573d 3c					inc a 
573e 32 a5 f9				ld (store_openext), a 
5741			 
5741				if DEBUG_STORESE 
5741					DMARK "RE6" 
5741 f5				push af  
5742 3a 56 57			ld a, (.dmark)  
5745 32 a6 fd			ld (debug_mark),a  
5748 3a 57 57			ld a, (.dmark+1)  
574b 32 a7 fd			ld (debug_mark+1),a  
574e 3a 58 57			ld a, (.dmark+2)  
5751 32 a8 fd			ld (debug_mark+2),a  
5754 18 03			jr .pastdmark  
5756 ..			.dmark: db "RE6"  
5759 f1			.pastdmark: pop af  
575a			endm  
# End of macro DMARK
575a					CALLMONITOR 
575a cd aa fd			call debug_vector  
575d				endm  
# End of macro CALLMONITOR
575d				endif 
575d			 
575d			 
575d				       NEXTW 
575d c3 b0 24			jp macro_next 
5760				endm 
# End of macro NEXTW
5760			.ateof: 
5760				;	ld hl, .showeof 
5760				;	call forth_push_str 
5760 3e 00		.readeof:	ld a, 0 
5762 32 a5 f9				ld (store_openext), a 
5765			 
5765					 
5765				if DEBUG_STORESE 
5765					DMARK "REF" 
5765 f5				push af  
5766 3a 7a 57			ld a, (.dmark)  
5769 32 a6 fd			ld (debug_mark),a  
576c 3a 7b 57			ld a, (.dmark+1)  
576f 32 a7 fd			ld (debug_mark+1),a  
5772 3a 7c 57			ld a, (.dmark+2)  
5775 32 a8 fd			ld (debug_mark+2),a  
5778 18 03			jr .pastdmark  
577a ..			.dmark: db "REF"  
577d f1			.pastdmark: pop af  
577e			endm  
# End of macro DMARK
577e					CALLMONITOR 
577e cd aa fd			call debug_vector  
5781				endm  
# End of macro CALLMONITOR
5781				endif 
5781				       NEXTW 
5781 c3 b0 24			jp macro_next 
5784				endm 
# End of macro NEXTW
5784			 
5784			;.showeof:   db "eof", 0 
5784			 
5784			 
5784			.EOF: 
5784				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
5784 6d				db WORD_SYS_CORE+89             
5785 c6 57			dw .FORMAT            
5787 04				db 3 + 1 
5788 .. 00			db "EOF",0              
578c				endm 
# End of macro CWHEAD
578c			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
578c			; | | e.g. 
578c			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
578c			; | | > [!NOTE] 
578c			; | | > Compatible with PicoSPINet  
578c					; TODO if current block id for stream is zero then push true else false 
578c			 
578c					if DEBUG_FORTH_WORDS_KEY 
578c						DMARK "EOF" 
578c f5				push af  
578d 3a a1 57			ld a, (.dmark)  
5790 32 a6 fd			ld (debug_mark),a  
5793 3a a2 57			ld a, (.dmark+1)  
5796 32 a7 fd			ld (debug_mark+1),a  
5799 3a a3 57			ld a, (.dmark+2)  
579c 32 a8 fd			ld (debug_mark+2),a  
579f 18 03			jr .pastdmark  
57a1 ..			.dmark: db "EOF"  
57a4 f1			.pastdmark: pop af  
57a5			endm  
# End of macro DMARK
57a5						CALLMONITOR 
57a5 cd aa fd			call debug_vector  
57a8				endm  
# End of macro CALLMONITOR
57a8					endif 
57a8			 
57a8					; TODO handlue multiple file streams 
57a8			 
57a8			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
57a8 cd b1 57				call .testeof 
57ab cd 03 21				call forth_push_numhl 
57ae			 
57ae			 
57ae				       NEXTW 
57ae c3 b0 24			jp macro_next 
57b1				endm 
# End of macro NEXTW
57b1			 
57b1			.testeof: 
57b1 2e 01				ld l, 1 
57b3 3a a4 f9				ld a, (store_openmaxext) 
57b6 fe 00				cp 0 
57b8 28 09				jr  z, .eofdone   ; empty file 
57ba 3a a5 f9				ld a, (store_openext) 
57bd fe 00				cp 0 
57bf 28 02				jr  z, .eofdone 
57c1 2e 00				ld l, 0 
57c3 26 00		.eofdone:	ld h, 0 
57c5 c9					ret 
57c6			 
57c6			 
57c6			 
57c6			 
57c6			.FORMAT: 
57c6				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
57c6 6d				db WORD_SYS_CORE+89             
57c7 17 58			dw .LABEL            
57c9 07				db 6 + 1 
57ca .. 00			db "FORMAT",0              
57d1				endm 
# End of macro CWHEAD
57d1			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
57d1			; | | > [!NOTE] 
57d1			; | | > Compatible with PicoSPINet  
57d1					; TODO if current block id for stream is zero then push true else false 
57d1				 
57d1				if DEBUG_STORESE 
57d1					DMARK "FOR" 
57d1 f5				push af  
57d2 3a e6 57			ld a, (.dmark)  
57d5 32 a6 fd			ld (debug_mark),a  
57d8 3a e7 57			ld a, (.dmark+1)  
57db 32 a7 fd			ld (debug_mark+1),a  
57de 3a e8 57			ld a, (.dmark+2)  
57e1 32 a8 fd			ld (debug_mark+2),a  
57e4 18 03			jr .pastdmark  
57e6 ..			.dmark: db "FOR"  
57e9 f1			.pastdmark: pop af  
57ea			endm  
# End of macro DMARK
57ea					CALLMONITOR 
57ea cd aa fd			call debug_vector  
57ed				endm  
# End of macro CALLMONITOR
57ed				endif 
57ed					; Wipes the bank check flags to cause a reformat on next block 0 read 
57ed			 
57ed 21 01 00				ld hl, 1 
57f0 3e 00				ld a, 0 
57f2 cd 6a 02				call se_writebyte 
57f5			 
57f5				if DEBUG_STORESE 
57f5					DMARK "FO0" 
57f5 f5				push af  
57f6 3a 0a 58			ld a, (.dmark)  
57f9 32 a6 fd			ld (debug_mark),a  
57fc 3a 0b 58			ld a, (.dmark+1)  
57ff 32 a7 fd			ld (debug_mark+1),a  
5802 3a 0c 58			ld a, (.dmark+2)  
5805 32 a8 fd			ld (debug_mark+2),a  
5808 18 03			jr .pastdmark  
580a ..			.dmark: db "FO0"  
580d f1			.pastdmark: pop af  
580e			endm  
# End of macro DMARK
580e					CALLMONITOR 
580e cd aa fd			call debug_vector  
5811				endm  
# End of macro CALLMONITOR
5811				endif 
5811					; force bank init 
5811			 
5811 cd 16 05				call storage_get_block_0 
5814					 
5814				       NEXTW 
5814 c3 b0 24			jp macro_next 
5817				endm 
# End of macro NEXTW
5817			.LABEL: 
5817				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5817 6d				db WORD_SYS_CORE+89             
5818 65 58			dw .STOREPAGE            
581a 06				db 5 + 1 
581b .. 00			db "LABEL",0              
5821				endm 
# End of macro CWHEAD
5821			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5821			; | | > [!NOTE] 
5821			; | | > Compatible with PicoSPINet  
5821					; TODO test to see if bank is selected 
5821				 
5821					if DEBUG_FORTH_WORDS_KEY 
5821						DMARK "LBL" 
5821 f5				push af  
5822 3a 36 58			ld a, (.dmark)  
5825 32 a6 fd			ld (debug_mark),a  
5828 3a 37 58			ld a, (.dmark+1)  
582b 32 a7 fd			ld (debug_mark+1),a  
582e 3a 38 58			ld a, (.dmark+2)  
5831 32 a8 fd			ld (debug_mark+2),a  
5834 18 03			jr .pastdmark  
5836 ..			.dmark: db "LBL"  
5839 f1			.pastdmark: pop af  
583a			endm  
# End of macro DMARK
583a						CALLMONITOR 
583a cd aa fd			call debug_vector  
583d				endm  
# End of macro CALLMONITOR
583d					endif 
583d			;	if DEBUG_STORESE 
583d			;		DMARK "LBL" 
583d			;		CALLMONITOR 
583d			;	endif 
583d					FORTH_DSP_VALUEHL 
583d cd fa 22			call macro_dsp_valuehl 
5840				endm 
# End of macro FORTH_DSP_VALUEHL
5840					;v5FORTH_DSP_VALUE 
5840					 
5840			;		push hl 
5840					FORTH_DSP_POP 
5840 cd b2 23			call macro_forth_dsp_pop 
5843				endm 
# End of macro FORTH_DSP_POP
5843			;		pop hl 
5843			 
5843			;v5		inc hl   ; move past the type marker 
5843			 
5843				if DEBUG_STORESE 
5843					DMARK "LBl" 
5843 f5				push af  
5844 3a 58 58			ld a, (.dmark)  
5847 32 a6 fd			ld (debug_mark),a  
584a 3a 59 58			ld a, (.dmark+1)  
584d 32 a7 fd			ld (debug_mark+1),a  
5850 3a 5a 58			ld a, (.dmark+2)  
5853 32 a8 fd			ld (debug_mark+2),a  
5856 18 03			jr .pastdmark  
5858 ..			.dmark: db "LBl"  
585b f1			.pastdmark: pop af  
585c			endm  
# End of macro DMARK
585c					CALLMONITOR 
585c cd aa fd			call debug_vector  
585f				endm  
# End of macro CALLMONITOR
585f				endif 
585f cd 3a 06				call storage_label 
5862			 
5862				       NEXTW 
5862 c3 b0 24			jp macro_next 
5865				endm 
# End of macro NEXTW
5865			.STOREPAGE: 
5865				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
5865 6d				db WORD_SYS_CORE+89             
5866 98 58			dw .LABELS            
5868 0a				db 9 + 1 
5869 .. 00			db "STOREPAGE",0              
5873				endm 
# End of macro CWHEAD
5873			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5873			; | | > [!NOTE] 
5873			; | | > Compatible with PicoSPINet  
5873					; TODO test to see if bank is selected 
5873				 
5873					if DEBUG_FORTH_WORDS_KEY 
5873						DMARK "STP" 
5873 f5				push af  
5874 3a 88 58			ld a, (.dmark)  
5877 32 a6 fd			ld (debug_mark),a  
587a 3a 89 58			ld a, (.dmark+1)  
587d 32 a7 fd			ld (debug_mark+1),a  
5880 3a 8a 58			ld a, (.dmark+2)  
5883 32 a8 fd			ld (debug_mark+2),a  
5886 18 03			jr .pastdmark  
5888 ..			.dmark: db "STP"  
588b f1			.pastdmark: pop af  
588c			endm  
# End of macro DMARK
588c						CALLMONITOR 
588c cd aa fd			call debug_vector  
588f				endm  
# End of macro CALLMONITOR
588f					endif 
588f			;	if DEBUG_STORESE 
588f			;		DMARK "STP" 
588f			;		CALLMONITOR 
588f			;	endif 
588f			 
588f 21 b5 f9			ld hl, store_page 
5892 cd 03 21			call forth_push_numhl 
5895			 
5895			 
5895				       NEXTW 
5895 c3 b0 24			jp macro_next 
5898				endm 
# End of macro NEXTW
5898			.LABELS: 
5898				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
5898 6d				db WORD_SYS_CORE+89             
5899 22 59			dw .SCONST1            
589b 07				db 6 + 1 
589c .. 00			db "LABELS",0              
58a3				endm 
# End of macro CWHEAD
58a3			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | DONE 
58a3			; | | > [!CAUTION] 
58a3			; | | > *NOT* Compatible with PicoSPINet  
58a3					;  
58a3			 
58a3					; save the current device selected to restore afterwards 
58a3				 
58a3 3a 9b f9				ld a, (spi_device) 
58a6 f5					push af 
58a7			 
58a7			 
58a7					; run through each of the banks 
58a7			 
58a7 21 01 00				ld hl, 1 
58aa cd 03 21				call forth_push_numhl 
58ad 3e ff				ld a, SPI_CE_HIGH 
58af cb 87				res SPI_CE0, a 
58b1 32 9b f9				ld (spi_device), a 
58b4 cd 16 05				call storage_get_block_0 
58b7 21 b8 f9				ld hl, store_page+3 
58ba cd 71 21				call forth_push_str 
58bd			 
58bd					 
58bd 21 02 00				ld hl, 2 
58c0 cd 03 21				call forth_push_numhl 
58c3 3e ff				ld a, SPI_CE_HIGH 
58c5 cb 8f				res SPI_CE1, a 
58c7 32 9b f9				ld (spi_device), a 
58ca cd 16 05				call storage_get_block_0 
58cd 21 b8 f9				ld hl, store_page+3 
58d0 cd 71 21				call forth_push_str 
58d3			 
58d3					 
58d3 21 03 00				ld hl, 3 
58d6 cd 03 21				call forth_push_numhl 
58d9 3e ff				ld a, SPI_CE_HIGH 
58db cb 97				res SPI_CE2, a 
58dd 32 9b f9				ld (spi_device), a 
58e0 cd 16 05				call storage_get_block_0 
58e3 21 b8 f9				ld hl, store_page+3 
58e6 cd 71 21				call forth_push_str 
58e9			 
58e9			 
58e9 21 04 00				ld hl, 4 
58ec cd 03 21				call forth_push_numhl 
58ef 3e ff				ld a, SPI_CE_HIGH 
58f1 cb 9f				res SPI_CE3, a 
58f3 32 9b f9				ld (spi_device), a 
58f6 cd 16 05				call storage_get_block_0 
58f9 21 b8 f9				ld hl, store_page+3 
58fc cd 71 21				call forth_push_str 
58ff			 
58ff					 
58ff			 
58ff 21 05 00				ld hl, 5 
5902 cd 03 21				call forth_push_numhl 
5905 3e ff				ld a, SPI_CE_HIGH 
5907 cb a7				res SPI_CE4, a 
5909 32 9b f9				ld (spi_device), a 
590c cd 16 05				call storage_get_block_0 
590f 21 b8 f9				ld hl, store_page+3 
5912 cd 71 21				call forth_push_str 
5915			 
5915					 
5915					; push fixed count of storage devices (on board) for now 
5915			 
5915 21 05 00				ld hl, 5 
5918 cd 03 21				call forth_push_numhl 
591b			 
591b					; restore selected device  
591b				 
591b f1					pop af 
591c 32 9b f9				ld (spi_device), a 
591f			 
591f				       NEXTW 
591f c3 b0 24			jp macro_next 
5922				endm 
# End of macro NEXTW
5922			 
5922			.SCONST1: 
5922				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5922 6d				db WORD_SYS_CORE+89             
5923 39 59			dw .SCONST2            
5925 07				db 6 + 1 
5926 .. 00			db "FILEID",0              
592d				endm 
# End of macro CWHEAD
592d			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
592d			; | | > [!NOTE] 
592d			; | | > Compatible with PicoSPINet  
592d 3a a2 f9				ld a, (store_filecache) 
5930 26 00				ld h, 0 
5932 6f					ld l, a 
5933 cd 03 21				call forth_push_numhl 
5936					NEXTW 
5936 c3 b0 24			jp macro_next 
5939				endm 
# End of macro NEXTW
5939			.SCONST2: 
5939				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5939 6d				db WORD_SYS_CORE+89             
593a 51 59			dw .SCONST3            
593c 08				db 7 + 1 
593d .. 00			db "FILEEXT",0              
5945				endm 
# End of macro CWHEAD
5945			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5945			; | | > [!NOTE] 
5945			; | | > Compatible with PicoSPINet  
5945 3a a5 f9				ld a, (store_openext) 
5948 26 00				ld h, 0 
594a 6f					ld l, a 
594b cd 03 21				call forth_push_numhl 
594e					NEXTW 
594e c3 b0 24			jp macro_next 
5951				endm 
# End of macro NEXTW
5951			.SCONST3: 
5951				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
5951 6d				db WORD_SYS_CORE+89             
5952 69 59			dw .SCONST4            
5954 08				db 7 + 1 
5955 .. 00			db "FILEMAX",0              
595d				endm 
# End of macro CWHEAD
595d			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
595d			; | | > [!NOTE] 
595d			; | | > Compatible with PicoSPINet  
595d 3a a4 f9				ld a, (store_openmaxext) 
5960 26 00				ld h, 0 
5962 6f					ld l, a 
5963 cd 03 21				call forth_push_numhl 
5966					NEXTW 
5966 c3 b0 24			jp macro_next 
5969				endm 
# End of macro NEXTW
5969			.SCONST4: 
5969				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
5969 6d				db WORD_SYS_CORE+89             
596a 7f 59			dw .SCONST5            
596c 09				db 8 + 1 
596d .. 00			db "FILEADDR",0              
5976				endm 
# End of macro CWHEAD
5976			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currently open file to stack | DONE 
5976			; | | > [!NOTE] 
5976			; | | > Compatible with PicoSPINet  
5976 2a a6 f9				ld hl, (store_openaddr) 
5979 cd 03 21				call forth_push_numhl 
597c					NEXTW 
597c c3 b0 24			jp macro_next 
597f				endm 
# End of macro NEXTW
597f			.SCONST5: 
597f				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
597f 6d				db WORD_SYS_CORE+89             
5980 a0 59			dw .SCONST6            
5982 09				db 8 + 1 
5983 .. 00			db "FILEPAGE",0              
598c				endm 
# End of macro CWHEAD
598c			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
598c			; | | > [!NOTE] 
598c			; | | > Compatible with PicoSPINet  
598c 2a a6 f9				ld hl, (store_openaddr) 
598f e5					push hl 
5990 c1					pop bc 
5991 16 00				ld d, 0 
5993 1e 40				ld e, STORE_BLOCK_PHY 
5995 cd 2c 0f				call Div16 
5998 c5					push bc 
5999 e1					pop hl 
599a cd 03 21				call forth_push_numhl 
599d					NEXTW 
599d c3 b0 24			jp macro_next 
59a0				endm 
# End of macro NEXTW
59a0			.SCONST6: 
59a0				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
59a0 6d				db WORD_SYS_CORE+89             
59a1 b9 59			dw .ENDSTORAGE            
59a3 09				db 8 + 1 
59a4 .. 00			db "READCONT",0              
59ad				endm 
# End of macro CWHEAD
59ad			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
59ad			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
59ad			; | | a further read should, if applicable, be CONCAT to the previous read. 
59ad			; | | > [!NOTE] 
59ad			; | | > Compatible with PicoSPINet  
59ad 3a a8 f9				ld a, (store_readcont) 
59b0 26 00				ld h, 0 
59b2 6f					ld l, a 
59b3 cd 03 21				call forth_push_numhl 
59b6					NEXTW 
59b6 c3 b0 24			jp macro_next 
59b9				endm 
# End of macro NEXTW
59b9			.ENDSTORAGE: 
59b9			; eof 
# End of file forth_words_storage.asm
59b9			endif 
59b9				include "forth_words_device.asm" 
59b9			; Device related words 
59b9			 
59b9			; | ## Device Words 
59b9			 
59b9			;if SOUND_ENABLE 
59b9			;.NOTE: 
59b9			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
59b9			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
59b9			;		if DEBUG_FORTH_WORDS_KEY 
59b9			;			DMARK "NTE" 
59b9			;			CALLMONITOR 
59b9			;		endif 
59b9			; 
59b9			;	 
59b9			; 
59b9			;		NEXTW 
59b9			;.AFTERSOUND: 
59b9			;endif 
59b9			 
59b9			 
59b9			USE_GPIO: equ 0 
59b9			 
59b9			if USE_GPIO 
59b9			.GP1: 
59b9				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
59b9			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
59b9					NEXTW 
59b9			.GP2: 
59b9				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
59b9			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
59b9			 
59b9					NEXTW 
59b9			 
59b9			.GP3: 
59b9				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
59b9			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
59b9			 
59b9					NEXTW 
59b9			 
59b9			.GP4: 
59b9				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
59b9			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
59b9			 
59b9					NEXTW 
59b9			.SIN: 
59b9			 
59b9			 
59b9			endif 
59b9			 
59b9			 
59b9				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
59b9 33				db WORD_SYS_CORE+31             
59ba ee 59			dw .SOUT            
59bc 03				db 2 + 1 
59bd .. 00			db "IN",0              
59c0				endm 
# End of macro CWHEAD
59c0			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
59c0					if DEBUG_FORTH_WORDS_KEY 
59c0						DMARK "IN." 
59c0 f5				push af  
59c1 3a d5 59			ld a, (.dmark)  
59c4 32 a6 fd			ld (debug_mark),a  
59c7 3a d6 59			ld a, (.dmark+1)  
59ca 32 a7 fd			ld (debug_mark+1),a  
59cd 3a d7 59			ld a, (.dmark+2)  
59d0 32 a8 fd			ld (debug_mark+2),a  
59d3 18 03			jr .pastdmark  
59d5 ..			.dmark: db "IN."  
59d8 f1			.pastdmark: pop af  
59d9			endm  
# End of macro DMARK
59d9						CALLMONITOR 
59d9 cd aa fd			call debug_vector  
59dc				endm  
# End of macro CALLMONITOR
59dc					endif 
59dc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
59dc cd fa 22			call macro_dsp_valuehl 
59df				endm 
# End of macro FORTH_DSP_VALUEHL
59df			 
59df e5					push hl 
59e0			 
59e0					; destroy value TOS 
59e0			 
59e0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
59e0 cd b2 23			call macro_forth_dsp_pop 
59e3				endm 
# End of macro FORTH_DSP_POP
59e3			 
59e3					; one value on hl get other one back 
59e3			 
59e3 c1					pop bc 
59e4			 
59e4					; do the sub 
59e4			;		ex de, hl 
59e4			 
59e4 ed 68				in l,(c) 
59e6			 
59e6					; save it 
59e6			 
59e6 26 00				ld h,0 
59e8			 
59e8					; TODO push value back onto stack for another op etc 
59e8			 
59e8 cd 03 21				call forth_push_numhl 
59eb					NEXTW 
59eb c3 b0 24			jp macro_next 
59ee				endm 
# End of macro NEXTW
59ee			.SOUT: 
59ee				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
59ee 34				db WORD_SYS_CORE+32             
59ef 41 5a			dw .SPIO            
59f1 04				db 3 + 1 
59f2 .. 00			db "OUT",0              
59f6				endm 
# End of macro CWHEAD
59f6			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
59f6					if DEBUG_FORTH_WORDS_KEY 
59f6						DMARK "OUT" 
59f6 f5				push af  
59f7 3a 0b 5a			ld a, (.dmark)  
59fa 32 a6 fd			ld (debug_mark),a  
59fd 3a 0c 5a			ld a, (.dmark+1)  
5a00 32 a7 fd			ld (debug_mark+1),a  
5a03 3a 0d 5a			ld a, (.dmark+2)  
5a06 32 a8 fd			ld (debug_mark+2),a  
5a09 18 03			jr .pastdmark  
5a0b ..			.dmark: db "OUT"  
5a0e f1			.pastdmark: pop af  
5a0f			endm  
# End of macro DMARK
5a0f						CALLMONITOR 
5a0f cd aa fd			call debug_vector  
5a12				endm  
# End of macro CALLMONITOR
5a12					endif 
5a12			 
5a12					; get port 
5a12			 
5a12					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a12 cd fa 22			call macro_dsp_valuehl 
5a15				endm 
# End of macro FORTH_DSP_VALUEHL
5a15			 
5a15 e5					push hl 
5a16			 
5a16					; destroy value TOS 
5a16			 
5a16					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a16 cd b2 23			call macro_forth_dsp_pop 
5a19				endm 
# End of macro FORTH_DSP_POP
5a19			 
5a19					; get byte to send 
5a19			 
5a19					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a19 cd fa 22			call macro_dsp_valuehl 
5a1c				endm 
# End of macro FORTH_DSP_VALUEHL
5a1c			 
5a1c			;		push hl 
5a1c			 
5a1c					; destroy value TOS 
5a1c			 
5a1c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a1c cd b2 23			call macro_forth_dsp_pop 
5a1f				endm 
# End of macro FORTH_DSP_POP
5a1f			 
5a1f					; one value on hl get other one back 
5a1f			 
5a1f			;		pop hl 
5a1f			 
5a1f c1					pop bc 
5a20			 
5a20					if DEBUG_FORTH_WORDS 
5a20						DMARK "OUT" 
5a20 f5				push af  
5a21 3a 35 5a			ld a, (.dmark)  
5a24 32 a6 fd			ld (debug_mark),a  
5a27 3a 36 5a			ld a, (.dmark+1)  
5a2a 32 a7 fd			ld (debug_mark+1),a  
5a2d 3a 37 5a			ld a, (.dmark+2)  
5a30 32 a8 fd			ld (debug_mark+2),a  
5a33 18 03			jr .pastdmark  
5a35 ..			.dmark: db "OUT"  
5a38 f1			.pastdmark: pop af  
5a39			endm  
# End of macro DMARK
5a39						CALLMONITOR 
5a39 cd aa fd			call debug_vector  
5a3c				endm  
# End of macro CALLMONITOR
5a3c					endif 
5a3c			 
5a3c ed 69				out (c), l 
5a3e			 
5a3e					NEXTW 
5a3e c3 b0 24			jp macro_next 
5a41				endm 
# End of macro NEXTW
5a41			 
5a41			 
5a41			.SPIO: 
5a41			 
5a41			if STORAGE_SE 
5a41				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
5a41 51				db WORD_SYS_CORE+61             
5a42 52 5a			dw .SPICEH            
5a44 07				db 6 + 1 
5a45 .. 00			db "SPICEL",0              
5a4c				endm 
# End of macro CWHEAD
5a4c			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5a4c			 
5a4c cd 13 02				call spi_ce_low 
5a4f			    NEXTW 
5a4f c3 b0 24			jp macro_next 
5a52				endm 
# End of macro NEXTW
5a52			 
5a52			.SPICEH: 
5a52				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5a52 51				db WORD_SYS_CORE+61             
5a53 63 5a			dw .SPIOb            
5a55 07				db 6 + 1 
5a56 .. 00			db "SPICEH",0              
5a5d				endm 
# End of macro CWHEAD
5a5d			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
5a5d			 
5a5d cd 02 02				call spi_ce_high 
5a60			    NEXTW 
5a60 c3 b0 24			jp macro_next 
5a63				endm 
# End of macro NEXTW
5a63			 
5a63			 
5a63			.SPIOb: 
5a63			 
5a63				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
5a63 51				db WORD_SYS_CORE+61             
5a64 95 5a			dw .SPII            
5a66 05				db 4 + 1 
5a67 .. 00			db "SPIO",0              
5a6c				endm 
# End of macro CWHEAD
5a6c			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
5a6c			 
5a6c					if DEBUG_FORTH_WORDS_KEY 
5a6c						DMARK "SPo" 
5a6c f5				push af  
5a6d 3a 81 5a			ld a, (.dmark)  
5a70 32 a6 fd			ld (debug_mark),a  
5a73 3a 82 5a			ld a, (.dmark+1)  
5a76 32 a7 fd			ld (debug_mark+1),a  
5a79 3a 83 5a			ld a, (.dmark+2)  
5a7c 32 a8 fd			ld (debug_mark+2),a  
5a7f 18 03			jr .pastdmark  
5a81 ..			.dmark: db "SPo"  
5a84 f1			.pastdmark: pop af  
5a85			endm  
# End of macro DMARK
5a85						CALLMONITOR 
5a85 cd aa fd			call debug_vector  
5a88				endm  
# End of macro CALLMONITOR
5a88					endif 
5a88					; get port 
5a88			 
5a88			 
5a88					; get byte to send 
5a88			 
5a88					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a88 cd fa 22			call macro_dsp_valuehl 
5a8b				endm 
# End of macro FORTH_DSP_VALUEHL
5a8b			 
5a8b			;		push hl    ; u1  
5a8b			 
5a8b					; destroy value TOS 
5a8b			 
5a8b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a8b cd b2 23			call macro_forth_dsp_pop 
5a8e				endm 
# End of macro FORTH_DSP_POP
5a8e			 
5a8e					; one value on hl get other one back 
5a8e			 
5a8e			;		pop hl   ; u2 - addr 
5a8e			 
5a8e					; TODO Send SPI byte 
5a8e			 
5a8e			;		push hl 
5a8e			;		call spi_ce_low 
5a8e			;		pop hl 
5a8e 7d					ld a, l 
5a8f cd 01 01				call spi_send_byte 
5a92			;		call spi_ce_high 
5a92			 
5a92					NEXTW 
5a92 c3 b0 24			jp macro_next 
5a95				endm 
# End of macro NEXTW
5a95			 
5a95			.SPII: 
5a95				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5a95 52				db WORD_SYS_CORE+62             
5a96 fe 5a			dw .SESEL            
5a98 06				db 5 + 1 
5a99 .. 00			db "SPII",0              
5a9e				endm 
# End of macro CWHEAD
5a9e			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5a9e					if DEBUG_FORTH_WORDS_KEY 
5a9e						DMARK "SPi" 
5a9e f5				push af  
5a9f 3a b3 5a			ld a, (.dmark)  
5aa2 32 a6 fd			ld (debug_mark),a  
5aa5 3a b4 5a			ld a, (.dmark+1)  
5aa8 32 a7 fd			ld (debug_mark+1),a  
5aab 3a b5 5a			ld a, (.dmark+2)  
5aae 32 a8 fd			ld (debug_mark+2),a  
5ab1 18 03			jr .pastdmark  
5ab3 ..			.dmark: db "SPi"  
5ab6 f1			.pastdmark: pop af  
5ab7			endm  
# End of macro DMARK
5ab7						CALLMONITOR 
5ab7 cd aa fd			call debug_vector  
5aba				endm  
# End of macro CALLMONITOR
5aba					endif 
5aba			 
5aba					; TODO Get SPI byte 
5aba			 
5aba cd 28 01				call spi_read_byte 
5abd			 
5abd					if DEBUG_FORTH_WORDS 
5abd						DMARK "Si2" 
5abd f5				push af  
5abe 3a d2 5a			ld a, (.dmark)  
5ac1 32 a6 fd			ld (debug_mark),a  
5ac4 3a d3 5a			ld a, (.dmark+1)  
5ac7 32 a7 fd			ld (debug_mark+1),a  
5aca 3a d4 5a			ld a, (.dmark+2)  
5acd 32 a8 fd			ld (debug_mark+2),a  
5ad0 18 03			jr .pastdmark  
5ad2 ..			.dmark: db "Si2"  
5ad5 f1			.pastdmark: pop af  
5ad6			endm  
# End of macro DMARK
5ad6						CALLMONITOR 
5ad6 cd aa fd			call debug_vector  
5ad9				endm  
# End of macro CALLMONITOR
5ad9					endif 
5ad9 26 00				ld h, 0 
5adb 6f					ld l, a 
5adc					if DEBUG_FORTH_WORDS 
5adc						DMARK "Si3" 
5adc f5				push af  
5add 3a f1 5a			ld a, (.dmark)  
5ae0 32 a6 fd			ld (debug_mark),a  
5ae3 3a f2 5a			ld a, (.dmark+1)  
5ae6 32 a7 fd			ld (debug_mark+1),a  
5ae9 3a f3 5a			ld a, (.dmark+2)  
5aec 32 a8 fd			ld (debug_mark+2),a  
5aef 18 03			jr .pastdmark  
5af1 ..			.dmark: db "Si3"  
5af4 f1			.pastdmark: pop af  
5af5			endm  
# End of macro DMARK
5af5						CALLMONITOR 
5af5 cd aa fd			call debug_vector  
5af8				endm  
# End of macro CALLMONITOR
5af8					endif 
5af8 cd 03 21				call forth_push_numhl 
5afb			 
5afb					NEXTW 
5afb c3 b0 24			jp macro_next 
5afe				endm 
# End of macro NEXTW
5afe			 
5afe			 
5afe			 
5afe			.SESEL: 
5afe				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5afe 66				db WORD_SYS_CORE+82             
5aff a7 5b			dw .CARTDEV            
5b01 05				db 4 + 1 
5b02 .. 00			db "BANK",0              
5b07				endm 
# End of macro CWHEAD
5b07			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5b07					if DEBUG_FORTH_WORDS_KEY 
5b07						DMARK "BNK" 
5b07 f5				push af  
5b08 3a 1c 5b			ld a, (.dmark)  
5b0b 32 a6 fd			ld (debug_mark),a  
5b0e 3a 1d 5b			ld a, (.dmark+1)  
5b11 32 a7 fd			ld (debug_mark+1),a  
5b14 3a 1e 5b			ld a, (.dmark+2)  
5b17 32 a8 fd			ld (debug_mark+2),a  
5b1a 18 03			jr .pastdmark  
5b1c ..			.dmark: db "BNK"  
5b1f f1			.pastdmark: pop af  
5b20			endm  
# End of macro DMARK
5b20						CALLMONITOR 
5b20 cd aa fd			call debug_vector  
5b23				endm  
# End of macro CALLMONITOR
5b23					endif 
5b23			 
5b23 3e ff				ld a, 255 
5b25 32 9e f9				ld (spi_cartdev), a 
5b28			 
5b28					; get bank 
5b28			 
5b28					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b28 cd fa 22			call macro_dsp_valuehl 
5b2b				endm 
# End of macro FORTH_DSP_VALUEHL
5b2b			 
5b2b			;		push hl 
5b2b			 
5b2b					; destroy value TOS 
5b2b			 
5b2b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b2b cd b2 23			call macro_forth_dsp_pop 
5b2e				endm 
# End of macro FORTH_DSP_POP
5b2e			 
5b2e					; one value on hl get other one back 
5b2e			 
5b2e			;		pop hl 
5b2e			 
5b2e			 
5b2e 0e ff				ld c, SPI_CE_HIGH 
5b30 06 30				ld b, '0'    ; human readable bank number 
5b32			 
5b32 7d					ld a, l 
5b33			 
5b33					if DEBUG_FORTH_WORDS 
5b33						DMARK "BNK" 
5b33 f5				push af  
5b34 3a 48 5b			ld a, (.dmark)  
5b37 32 a6 fd			ld (debug_mark),a  
5b3a 3a 49 5b			ld a, (.dmark+1)  
5b3d 32 a7 fd			ld (debug_mark+1),a  
5b40 3a 4a 5b			ld a, (.dmark+2)  
5b43 32 a8 fd			ld (debug_mark+2),a  
5b46 18 03			jr .pastdmark  
5b48 ..			.dmark: db "BNK"  
5b4b f1			.pastdmark: pop af  
5b4c			endm  
# End of macro DMARK
5b4c						CALLMONITOR 
5b4c cd aa fd			call debug_vector  
5b4f				endm  
# End of macro CALLMONITOR
5b4f					endif 
5b4f			 
5b4f					; active low 
5b4f			 
5b4f fe 00				cp 0 
5b51 28 28				jr z, .bset 
5b53 fe 01				cp 1 
5b55 20 04				jr nz, .b2 
5b57 cb 81				res 0, c 
5b59 06 31				ld b, '1'    ; human readable bank number 
5b5b fe 02		.b2:		cp 2 
5b5d 20 04				jr nz, .b3 
5b5f cb 89				res 1, c 
5b61 06 32				ld b, '2'    ; human readable bank number 
5b63 fe 03		.b3:		cp 3 
5b65 20 04				jr nz, .b4 
5b67 cb 91				res 2, c 
5b69 06 33				ld b, '3'    ; human readable bank number 
5b6b fe 04		.b4:		cp 4 
5b6d 20 04				jr nz, .b5 
5b6f cb 99				res 3, c 
5b71 06 34				ld b, '4'    ; human readable bank number 
5b73 fe 05		.b5:		cp 5 
5b75 20 04				jr nz, .bset 
5b77 cb a1				res 4, c 
5b79 06 35				ld b, '5'    ; human readable bank number 
5b7b			 
5b7b			.bset: 
5b7b 79					ld a, c 
5b7c 32 9b f9				ld (spi_device),a 
5b7f 78					ld a, b 
5b80 32 9a f9				ld (spi_device_id),a 
5b83					if DEBUG_FORTH_WORDS 
5b83						DMARK "BN2" 
5b83 f5				push af  
5b84 3a 98 5b			ld a, (.dmark)  
5b87 32 a6 fd			ld (debug_mark),a  
5b8a 3a 99 5b			ld a, (.dmark+1)  
5b8d 32 a7 fd			ld (debug_mark+1),a  
5b90 3a 9a 5b			ld a, (.dmark+2)  
5b93 32 a8 fd			ld (debug_mark+2),a  
5b96 18 03			jr .pastdmark  
5b98 ..			.dmark: db "BN2"  
5b9b f1			.pastdmark: pop af  
5b9c			endm  
# End of macro DMARK
5b9c						CALLMONITOR 
5b9c cd aa fd			call debug_vector  
5b9f				endm  
# End of macro CALLMONITOR
5b9f					endif 
5b9f			 
5b9f					; set default SPI clk pulse time as disabled for BANK use 
5b9f			 
5b9f 3e 00				ld a, 0 
5ba1 32 9f f9				ld (spi_clktime), a 
5ba4			 
5ba4					NEXTW 
5ba4 c3 b0 24			jp macro_next 
5ba7				endm 
# End of macro NEXTW
5ba7			 
5ba7			.CARTDEV: 
5ba7				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5ba7 66				db WORD_SYS_CORE+82             
5ba8 55 5c			dw .ENDDEVICE            
5baa 08				db 7 + 1 
5bab .. 00			db "CARTDEV",0              
5bb3				endm 
# End of macro CWHEAD
5bb3			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5bb3					if DEBUG_FORTH_WORDS_KEY 
5bb3						DMARK "CDV" 
5bb3 f5				push af  
5bb4 3a c8 5b			ld a, (.dmark)  
5bb7 32 a6 fd			ld (debug_mark),a  
5bba 3a c9 5b			ld a, (.dmark+1)  
5bbd 32 a7 fd			ld (debug_mark+1),a  
5bc0 3a ca 5b			ld a, (.dmark+2)  
5bc3 32 a8 fd			ld (debug_mark+2),a  
5bc6 18 03			jr .pastdmark  
5bc8 ..			.dmark: db "CDV"  
5bcb f1			.pastdmark: pop af  
5bcc			endm  
# End of macro DMARK
5bcc						CALLMONITOR 
5bcc cd aa fd			call debug_vector  
5bcf				endm  
# End of macro CALLMONITOR
5bcf					endif 
5bcf			 
5bcf					; disable se storage bank selection 
5bcf			 
5bcf 3e ff				ld a, SPI_CE_HIGH		; ce high 
5bd1 32 9b f9				ld (spi_device), a 
5bd4			 
5bd4					; get bank 
5bd4			 
5bd4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5bd4 cd fa 22			call macro_dsp_valuehl 
5bd7				endm 
# End of macro FORTH_DSP_VALUEHL
5bd7			 
5bd7			;		push hl 
5bd7			 
5bd7					; destroy value TOS 
5bd7			 
5bd7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5bd7 cd b2 23			call macro_forth_dsp_pop 
5bda				endm 
# End of macro FORTH_DSP_POP
5bda			 
5bda					; one value on hl get other one back 
5bda			 
5bda			;		pop hl 
5bda			 
5bda					; active low 
5bda			 
5bda 0e ff				ld c, 255 
5bdc			 
5bdc 7d					ld a, l 
5bdd					if DEBUG_FORTH_WORDS 
5bdd						DMARK "CDV" 
5bdd f5				push af  
5bde 3a f2 5b			ld a, (.dmark)  
5be1 32 a6 fd			ld (debug_mark),a  
5be4 3a f3 5b			ld a, (.dmark+1)  
5be7 32 a7 fd			ld (debug_mark+1),a  
5bea 3a f4 5b			ld a, (.dmark+2)  
5bed 32 a8 fd			ld (debug_mark+2),a  
5bf0 18 03			jr .pastdmark  
5bf2 ..			.dmark: db "CDV"  
5bf5 f1			.pastdmark: pop af  
5bf6			endm  
# End of macro DMARK
5bf6						CALLMONITOR 
5bf6 cd aa fd			call debug_vector  
5bf9				endm  
# End of macro CALLMONITOR
5bf9					endif 
5bf9 fe 00				cp 0 
5bfb 28 30				jr z, .cset 
5bfd fe 01				cp 1 
5bff 20 02				jr nz, .c2 
5c01 cb 81				res 0, c 
5c03 fe 02		.c2:		cp 2 
5c05 20 02				jr nz, .c3 
5c07 cb 89				res 1, c 
5c09 fe 03		.c3:		cp 3 
5c0b 20 02				jr nz, .c4 
5c0d cb 91				res 2, c 
5c0f fe 04		.c4:		cp 4 
5c11 20 02				jr nz, .c5 
5c13 cb 99				res 3, c 
5c15 fe 05		.c5:		cp 5 
5c17 20 02				jr nz, .c6 
5c19 cb a1				res 4, c 
5c1b fe 06		.c6:		cp 6 
5c1d 20 02				jr nz, .c7 
5c1f cb a9				res 5, c 
5c21 fe 07		.c7:		cp 7 
5c23 20 02				jr nz, .c8 
5c25 cb b1				res 6, c 
5c27 fe 08		.c8:		cp 8 
5c29 20 02				jr nz, .cset 
5c2b cb b9				res 7, c 
5c2d 79			.cset:		ld a, c 
5c2e 32 9e f9				ld (spi_cartdev),a 
5c31			 
5c31					if DEBUG_FORTH_WORDS 
5c31						DMARK "CD2" 
5c31 f5				push af  
5c32 3a 46 5c			ld a, (.dmark)  
5c35 32 a6 fd			ld (debug_mark),a  
5c38 3a 47 5c			ld a, (.dmark+1)  
5c3b 32 a7 fd			ld (debug_mark+1),a  
5c3e 3a 48 5c			ld a, (.dmark+2)  
5c41 32 a8 fd			ld (debug_mark+2),a  
5c44 18 03			jr .pastdmark  
5c46 ..			.dmark: db "CD2"  
5c49 f1			.pastdmark: pop af  
5c4a			endm  
# End of macro DMARK
5c4a						CALLMONITOR 
5c4a cd aa fd			call debug_vector  
5c4d				endm  
# End of macro CALLMONITOR
5c4d					endif 
5c4d			 
5c4d					; set default SPI clk pulse time as 10ms for CARTDEV use 
5c4d			 
5c4d 3e 0a				ld a, $0a 
5c4f 32 9f f9				ld (spi_clktime), a 
5c52					NEXTW 
5c52 c3 b0 24			jp macro_next 
5c55				endm 
# End of macro NEXTW
5c55			endif 
5c55			 
5c55			.ENDDEVICE: 
5c55			; eof 
5c55			 
# End of file forth_words_device.asm
5c55			 
5c55			; var handler 
5c55			 
5c55			 
5c55			.VARS: 
5c55				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5c55 77				db WORD_SYS_CORE+99             
5c56 06 5d			dw .V0            
5c58 04				db 3 + 1 
5c59 .. 00			db "VAR",0              
5c5d				endm 
# End of macro CWHEAD
5c5d			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5c5d			;| 
5c5d			;| The variable name should consist of a single letter. e.g. "a" 
5c5d			;! If a full string is passed then only the first char is looked at 
5c5d			;| Any other char could exceed bounds checks!  
5c5d			 
5c5d					if DEBUG_FORTH_WORDS_KEY 
5c5d						DMARK "VAR" 
5c5d f5				push af  
5c5e 3a 72 5c			ld a, (.dmark)  
5c61 32 a6 fd			ld (debug_mark),a  
5c64 3a 73 5c			ld a, (.dmark+1)  
5c67 32 a7 fd			ld (debug_mark+1),a  
5c6a 3a 74 5c			ld a, (.dmark+2)  
5c6d 32 a8 fd			ld (debug_mark+2),a  
5c70 18 03			jr .pastdmark  
5c72 ..			.dmark: db "VAR"  
5c75 f1			.pastdmark: pop af  
5c76			endm  
# End of macro DMARK
5c76						CALLMONITOR 
5c76 cd aa fd			call debug_vector  
5c79				endm  
# End of macro CALLMONITOR
5c79					endif 
5c79			 
5c79					FORTH_DSP_VALUEHL 
5c79 cd fa 22			call macro_dsp_valuehl 
5c7c				endm 
# End of macro FORTH_DSP_VALUEHL
5c7c			 
5c7c 7e					ld a, (hl)    ; get first char on of the string 
5c7d			 
5c7d			 
5c7d					if DEBUG_FORTH_WORDS 
5c7d						DMARK "VR1" 
5c7d f5				push af  
5c7e 3a 92 5c			ld a, (.dmark)  
5c81 32 a6 fd			ld (debug_mark),a  
5c84 3a 93 5c			ld a, (.dmark+1)  
5c87 32 a7 fd			ld (debug_mark+1),a  
5c8a 3a 94 5c			ld a, (.dmark+2)  
5c8d 32 a8 fd			ld (debug_mark+2),a  
5c90 18 03			jr .pastdmark  
5c92 ..			.dmark: db "VR1"  
5c95 f1			.pastdmark: pop af  
5c96			endm  
# End of macro DMARK
5c96						CALLMONITOR 
5c96 cd aa fd			call debug_vector  
5c99				endm  
# End of macro CALLMONITOR
5c99					endif 
5c99					 
5c99 f5					push af	 
5c9a					FORTH_DSP_POP 
5c9a cd b2 23			call macro_forth_dsp_pop 
5c9d				endm 
# End of macro FORTH_DSP_POP
5c9d f1					pop af 
5c9e			 
5c9e					; convert to upper 
5c9e			 
5c9e cd 3c 13				call to_upper 
5ca1					if DEBUG_FORTH_WORDS 
5ca1						DMARK "Vaa" 
5ca1 f5				push af  
5ca2 3a b6 5c			ld a, (.dmark)  
5ca5 32 a6 fd			ld (debug_mark),a  
5ca8 3a b7 5c			ld a, (.dmark+1)  
5cab 32 a7 fd			ld (debug_mark+1),a  
5cae 3a b8 5c			ld a, (.dmark+2)  
5cb1 32 a8 fd			ld (debug_mark+2),a  
5cb4 18 03			jr .pastdmark  
5cb6 ..			.dmark: db "Vaa"  
5cb9 f1			.pastdmark: pop af  
5cba			endm  
# End of macro DMARK
5cba						CALLMONITOR 
5cba cd aa fd			call debug_vector  
5cbd				endm  
# End of macro CALLMONITOR
5cbd					endif 
5cbd 06 41				ld b, 'A' 
5cbf 90					sub b			; set offset 
5cc0					if DEBUG_FORTH_WORDS 
5cc0						DMARK "Vbb" 
5cc0 f5				push af  
5cc1 3a d5 5c			ld a, (.dmark)  
5cc4 32 a6 fd			ld (debug_mark),a  
5cc7 3a d6 5c			ld a, (.dmark+1)  
5cca 32 a7 fd			ld (debug_mark+1),a  
5ccd 3a d7 5c			ld a, (.dmark+2)  
5cd0 32 a8 fd			ld (debug_mark+2),a  
5cd3 18 03			jr .pastdmark  
5cd5 ..			.dmark: db "Vbb"  
5cd8 f1			.pastdmark: pop af  
5cd9			endm  
# End of macro DMARK
5cd9						CALLMONITOR 
5cd9 cd aa fd			call debug_vector  
5cdc				endm  
# End of macro CALLMONITOR
5cdc					endif 
5cdc cb 27				sla a  
5cde				 
5cde					 
5cde					if DEBUG_FORTH_WORDS 
5cde						DMARK "VR2" 
5cde f5				push af  
5cdf 3a f3 5c			ld a, (.dmark)  
5ce2 32 a6 fd			ld (debug_mark),a  
5ce5 3a f4 5c			ld a, (.dmark+1)  
5ce8 32 a7 fd			ld (debug_mark+1),a  
5ceb 3a f5 5c			ld a, (.dmark+2)  
5cee 32 a8 fd			ld (debug_mark+2),a  
5cf1 18 03			jr .pastdmark  
5cf3 ..			.dmark: db "VR2"  
5cf6 f1			.pastdmark: pop af  
5cf7			endm  
# End of macro DMARK
5cf7						CALLMONITOR 
5cf7 cd aa fd			call debug_vector  
5cfa				endm  
# End of macro CALLMONITOR
5cfa					endif 
5cfa			 
5cfa 21 2f f9				ld hl, cli_var_array2 
5cfd cd cf 0f				call addatohl 
5d00 cd 03 21				call forth_push_numhl 
5d03			 
5d03			 
5d03				       NEXTW 
5d03 c3 b0 24			jp macro_next 
5d06				endm 
# End of macro NEXTW
5d06			.V0: 
5d06				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5d06 78				db WORD_SYS_CORE+100             
5d07 1e 5d			dw .V0Q            
5d09 04				db 3 + 1 
5d0a .. 00			db "V0!",0              
5d0e				endm 
# End of macro CWHEAD
5d0e			;| V0! ( u1 -- )  Store value to v0  | DONE 
5d0e			 
5d0e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5d0e cd fa 22			call macro_dsp_valuehl 
5d11				endm 
# End of macro FORTH_DSP_VALUEHL
5d11			 
5d11 11 63 f9				ld de, cli_var_array 
5d14			 
5d14 eb					ex de, hl 
5d15 73					ld (hl), e 
5d16 23					inc hl 
5d17 72					ld (hl), d 
5d18			 
5d18					; destroy value TOS 
5d18			 
5d18					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5d18 cd b2 23			call macro_forth_dsp_pop 
5d1b				endm 
# End of macro FORTH_DSP_POP
5d1b			 
5d1b				       NEXTW 
5d1b c3 b0 24			jp macro_next 
5d1e				endm 
# End of macro NEXTW
5d1e			.V0Q: 
5d1e				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5d1e 79				db WORD_SYS_CORE+101             
5d1f 2f 5d			dw .V1S            
5d21 04				db 3 + 1 
5d22 .. 00			db "V0@",0              
5d26				endm 
# End of macro CWHEAD
5d26			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5d26 2a 63 f9				ld hl, (cli_var_array) 
5d29 cd 03 21				call forth_push_numhl 
5d2c			 
5d2c				       NEXTW 
5d2c c3 b0 24			jp macro_next 
5d2f				endm 
# End of macro NEXTW
5d2f			.V1S: 
5d2f				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5d2f 7a				db WORD_SYS_CORE+102             
5d30 47 5d			dw .V1Q            
5d32 04				db 3 + 1 
5d33 .. 00			db "V1!",0              
5d37				endm 
# End of macro CWHEAD
5d37			;| V1! ( u1 -- )  Store value to v1 | DONE 
5d37					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5d37 cd fa 22			call macro_dsp_valuehl 
5d3a				endm 
# End of macro FORTH_DSP_VALUEHL
5d3a			 
5d3a 11 65 f9				ld de, cli_var_array+2 
5d3d				 
5d3d eb					ex de, hl 
5d3e 73					ld (hl), e 
5d3f 23					inc hl 
5d40 72					ld (hl), d 
5d41			 
5d41					; destroy value TOS 
5d41			 
5d41					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5d41 cd b2 23			call macro_forth_dsp_pop 
5d44				endm 
# End of macro FORTH_DSP_POP
5d44				       NEXTW 
5d44 c3 b0 24			jp macro_next 
5d47				endm 
# End of macro NEXTW
5d47			.V1Q: 
5d47				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5d47 7b				db WORD_SYS_CORE+103             
5d48 58 5d			dw .V2S            
5d4a 04				db 3 + 1 
5d4b .. 00			db "V1@",0              
5d4f				endm 
# End of macro CWHEAD
5d4f			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5d4f 2a 65 f9				ld hl, (cli_var_array+2) 
5d52 cd 03 21				call forth_push_numhl 
5d55				       NEXTW 
5d55 c3 b0 24			jp macro_next 
5d58				endm 
# End of macro NEXTW
5d58			.V2S: 
5d58				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5d58 7c				db WORD_SYS_CORE+104             
5d59 70 5d			dw .V2Q            
5d5b 04				db 3 + 1 
5d5c .. 00			db "V2!",0              
5d60				endm 
# End of macro CWHEAD
5d60			;| V2! ( u1 -- )  Store value to v2 | DONE 
5d60					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5d60 cd fa 22			call macro_dsp_valuehl 
5d63				endm 
# End of macro FORTH_DSP_VALUEHL
5d63			 
5d63 11 67 f9				ld de, cli_var_array+4 
5d66				 
5d66 eb					ex de, hl 
5d67 73					ld (hl), e 
5d68 23					inc hl 
5d69 72					ld (hl), d 
5d6a			 
5d6a					; destroy value TOS 
5d6a			 
5d6a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5d6a cd b2 23			call macro_forth_dsp_pop 
5d6d				endm 
# End of macro FORTH_DSP_POP
5d6d				       NEXTW 
5d6d c3 b0 24			jp macro_next 
5d70				endm 
# End of macro NEXTW
5d70			.V2Q: 
5d70				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5d70 7d				db WORD_SYS_CORE+105             
5d71 81 5d			dw .V3S            
5d73 04				db 3 + 1 
5d74 .. 00			db "V2@",0              
5d78				endm 
# End of macro CWHEAD
5d78			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5d78 2a 67 f9				ld hl, (cli_var_array+4) 
5d7b cd 03 21				call forth_push_numhl 
5d7e				       NEXTW 
5d7e c3 b0 24			jp macro_next 
5d81				endm 
# End of macro NEXTW
5d81			.V3S: 
5d81				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5d81 7c				db WORD_SYS_CORE+104             
5d82 99 5d			dw .V3Q            
5d84 04				db 3 + 1 
5d85 .. 00			db "V3!",0              
5d89				endm 
# End of macro CWHEAD
5d89			;| V3! ( u1 -- )  Store value to v3 | DONE 
5d89					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5d89 cd fa 22			call macro_dsp_valuehl 
5d8c				endm 
# End of macro FORTH_DSP_VALUEHL
5d8c			 
5d8c 11 69 f9				ld de, cli_var_array+6 
5d8f				 
5d8f eb					ex de, hl 
5d90 73					ld (hl), e 
5d91 23					inc hl 
5d92 72					ld (hl), d 
5d93			 
5d93					; destroy value TOS 
5d93			 
5d93					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5d93 cd b2 23			call macro_forth_dsp_pop 
5d96				endm 
# End of macro FORTH_DSP_POP
5d96				       NEXTW 
5d96 c3 b0 24			jp macro_next 
5d99				endm 
# End of macro NEXTW
5d99			.V3Q: 
5d99				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5d99 7d				db WORD_SYS_CORE+105             
5d9a aa 5d			dw .END            
5d9c 04				db 3 + 1 
5d9d .. 00			db "V3@",0              
5da1				endm 
# End of macro CWHEAD
5da1			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5da1 2a 69 f9				ld hl, (cli_var_array+6) 
5da4 cd 03 21				call forth_push_numhl 
5da7				       NEXTW 
5da7 c3 b0 24			jp macro_next 
5daa				endm 
# End of macro NEXTW
5daa			 
5daa			 
5daa			 
5daa			 
5daa			 
5daa			; end of dict marker 
5daa			 
5daa 00			.END:    db WORD_SYS_END 
5dab 00 00			dw 0 
5dad 00				db 0 
5dae			 
5dae			; use to jp here for user dict words to save on macro expansion  
5dae			 
5dae			user_dict_next: 
5dae				NEXTW 
5dae c3 b0 24			jp macro_next 
5db1				endm 
# End of macro NEXTW
5db1			 
5db1			 
5db1			user_exec: 
5db1				;    ld hl, <word code> 
5db1				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5db1				;    call forthexec 
5db1				;    jp user_dict_next   (NEXT) 
5db1			        ;    <word code bytes> 
5db1 eb				ex de, hl 
5db2 2a fd f3			ld hl,(os_tok_ptr) 
5db5				 
5db5				FORTH_RSP_NEXT 
5db5 cd aa 20			call macro_forth_rsp_next 
5db8				endm 
# End of macro FORTH_RSP_NEXT
5db8			 
5db8			if DEBUG_FORTH_UWORD 
5db8						DMARK "UEX" 
5db8 f5				push af  
5db9 3a cd 5d			ld a, (.dmark)  
5dbc 32 a6 fd			ld (debug_mark),a  
5dbf 3a ce 5d			ld a, (.dmark+1)  
5dc2 32 a7 fd			ld (debug_mark+1),a  
5dc5 3a cf 5d			ld a, (.dmark+2)  
5dc8 32 a8 fd			ld (debug_mark+2),a  
5dcb 18 03			jr .pastdmark  
5dcd ..			.dmark: db "UEX"  
5dd0 f1			.pastdmark: pop af  
5dd1			endm  
# End of macro DMARK
5dd1				CALLMONITOR 
5dd1 cd aa fd			call debug_vector  
5dd4				endm  
# End of macro CALLMONITOR
5dd4			endif 
5dd4			 
5dd4			 
5dd4			 
5dd4 eb				ex de, hl 
5dd5 22 fd f3			ld (os_tok_ptr), hl 
5dd8				 
5dd8				; Don't use next - Skips the first word in uword. 
5dd8			 
5dd8 c3 41 25			jp exec1 
5ddb			;	NEXT 
5ddb			 
5ddb			 
5ddb			; eof 
# End of file forth_wordsv4.asm
5ddb			endif 
5ddb			;;;;;;;;;;;;;; Debug code 
5ddb			 
5ddb			 
5ddb			;if DEBUG_FORTH_PARSE 
5ddb .. 00		.nowordfound: db "No match",0 
5de4 .. 00		.compword:	db "Comparing word ",0 
5df4 .. 00		.nextwordat:	db "Next word at",0 
5e01 .. 00		.charmatch:	db "Char match",0 
5e0c			;endif 
5e0c			if DEBUG_FORTH_JP 
5e0c			.foundword:	db "Word match. Exec..",0 
5e0c			endif 
5e0c			;if DEBUG_FORTH_PUSH 
5e0c .. 00		.enddict:	db "Dict end. Push.",0 
5e1c .. 00		.push_str:	db "Pushing string",0 
5e2b .. 00		.push_num:	db "Pushing number",0 
5e3a .. 00		.data_sp:	db "SP:",0 
5e3e .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5e50 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5e62 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5e74			;endif 
5e74			;if DEBUG_FORTH_MALLOC 
5e74 .. 00		.push_malloc:	db "Malloc address",0 
5e83			;endif 
5e83			 
5e83			 
5e83			 
5e83			; display malloc address and current data stack pointer  
5e83			 
5e83			malloc_error: 
5e83 d5				push de 
5e84 f5				push af 
5e85 e5				push hl 
5e86 cd 9b 0d			call clear_display 
5e89 11 a9 5e			ld de, .mallocerr 
5e8c 3e 00			ld a,0 
5e8e			;	ld de,os_word_scratch 
5e8e cd ae 0d			call str_at_display 
5e91 3e 11			ld a, display_row_1+17 
5e93 11 a6 fd			ld de, debug_mark 
5e96 cd ae 0d			call str_at_display 
5e99 cd be 0d			call update_display 
5e9c				;call break_point_state 
5e9c cd 6c 7a			call cin_wait 
5e9f			 
5e9f			;	ld a, ' ' 
5e9f			;	ld (os_view_disable), a 
5e9f cd 35 1a			call bp_on 
5ea2 e1				pop hl 
5ea3 f1				pop af 
5ea4 d1				pop de	 
5ea5				CALLMONITOR 
5ea5 cd aa fd			call debug_vector  
5ea8				endm  
# End of macro CALLMONITOR
5ea8 c9				ret 
5ea9			 
5ea9 .. 00		.mallocerr: 	db "Malloc Error",0 
5eb6			;if DEBUG_FORTH_PUSH 
5eb6			display_data_sp: 
5eb6 f5				push af 
5eb7			 
5eb7				; see if disabled 
5eb7			 
5eb7			 
5eb7 3a aa fd			ld a, (debug_vector) 
5eba fe c9			cp $C9  ; RET 
5ebc				;ld a, (os_view_disable) 
5ebc				;cp '*' 
5ebc 28 67			jr z, .skipdsp 
5ebe			 
5ebe e5				push hl 
5ebf e5				push hl 
5ec0 e5			push hl 
5ec1 cd 9b 0d			call clear_display 
5ec4 e1			pop hl 
5ec5 7c				ld a,h 
5ec6 21 01 f4			ld hl, os_word_scratch 
5ec9 cd d0 12			call hexout 
5ecc e1				pop hl 
5ecd 7d				ld a,l 
5ece 21 03 f4			ld hl, os_word_scratch+2 
5ed1 cd d0 12			call hexout 
5ed4 21 05 f4			ld hl, os_word_scratch+4 
5ed7 3e 00			ld a,0 
5ed9 77				ld (hl),a 
5eda 11 01 f4			ld de,os_word_scratch 
5edd 3e 28				ld a, display_row_2 
5edf cd ae 0d				call str_at_display 
5ee2 11 3e 5e			ld de, .wordinhl 
5ee5 3e 00			ld a, display_row_1 
5ee7			 
5ee7 cd ae 0d				call str_at_display 
5eea 11 a6 fd			ld de, debug_mark 
5eed 3e 11			ld a, display_row_1+17 
5eef			 
5eef cd ae 0d				call str_at_display 
5ef2			 
5ef2				; display current data stack pointer 
5ef2 11 3a 5e			ld de,.data_sp 
5ef5 3e 30				ld a, display_row_2 + 8 
5ef7 cd ae 0d				call str_at_display 
5efa			 
5efa 2a 29 f9			ld hl,(cli_data_sp) 
5efd e5				push hl 
5efe 7c				ld a,h 
5eff 21 01 f4			ld hl, os_word_scratch 
5f02 cd d0 12			call hexout 
5f05 e1				pop hl 
5f06 7d				ld a,l 
5f07 21 03 f4			ld hl, os_word_scratch+2 
5f0a cd d0 12			call hexout 
5f0d 21 05 f4			ld hl, os_word_scratch+4 
5f10 3e 00			ld a,0 
5f12 77				ld (hl),a 
5f13 11 01 f4			ld de,os_word_scratch 
5f16 3e 33				ld a, display_row_2 + 11 
5f18 cd ae 0d				call str_at_display 
5f1b			 
5f1b			 
5f1b cd be 0d			call update_display 
5f1e cd de 0c			call delay1s 
5f21 cd de 0c			call delay1s 
5f24 e1				pop hl 
5f25			.skipdsp: 
5f25 f1				pop af 
5f26 c9				ret 
5f27			 
5f27			display_data_malloc: 
5f27			 
5f27 f5				push af 
5f28 e5				push hl 
5f29 e5				push hl 
5f2a e5			push hl 
5f2b cd 9b 0d			call clear_display 
5f2e e1			pop hl 
5f2f 7c				ld a,h 
5f30 21 01 f4			ld hl, os_word_scratch 
5f33 cd d0 12			call hexout 
5f36 e1				pop hl 
5f37 7d				ld a,l 
5f38 21 03 f4			ld hl, os_word_scratch+2 
5f3b cd d0 12			call hexout 
5f3e 21 05 f4			ld hl, os_word_scratch+4 
5f41 3e 00			ld a,0 
5f43 77				ld (hl),a 
5f44 11 01 f4			ld de,os_word_scratch 
5f47 3e 28				ld a, display_row_2 
5f49 cd ae 0d				call str_at_display 
5f4c 11 74 5e			ld de, .push_malloc 
5f4f 3e 00			ld a, display_row_1 
5f51			 
5f51 cd ae 0d				call str_at_display 
5f54			 
5f54				; display current data stack pointer 
5f54 11 3a 5e			ld de,.data_sp 
5f57 3e 30				ld a, display_row_2 + 8 
5f59 cd ae 0d				call str_at_display 
5f5c			 
5f5c 2a 29 f9			ld hl,(cli_data_sp) 
5f5f e5				push hl 
5f60 7c				ld a,h 
5f61 21 01 f4			ld hl, os_word_scratch 
5f64 cd d0 12			call hexout 
5f67 e1				pop hl 
5f68 7d				ld a,l 
5f69 21 03 f4			ld hl, os_word_scratch+2 
5f6c cd d0 12			call hexout 
5f6f 21 05 f4			ld hl, os_word_scratch+4 
5f72 3e 00			ld a,0 
5f74 77				ld (hl),a 
5f75 11 01 f4			ld de,os_word_scratch 
5f78 3e 33				ld a, display_row_2 + 11 
5f7a cd ae 0d				call str_at_display 
5f7d			 
5f7d cd be 0d			call update_display 
5f80 cd de 0c			call delay1s 
5f83 cd de 0c			call delay1s 
5f86 e1				pop hl 
5f87 f1				pop af 
5f88 c9				ret 
5f89			;endif 
5f89			 
5f89			include "forth_autostart.asm" 
5f89			; list of commands to perform at system start up 
5f89			 
5f89			startcmds: 
5f89			;	dw test11 
5f89			;	dw test12 
5f89			;	dw test13 
5f89			;	dw test14 
5f89			;	dw test15 
5f89			;	dw test16 
5f89			;	dw test17 
5f89			;	dw ifthtest1 
5f89			;	dw ifthtest2 
5f89			;	dw ifthtest3 
5f89			;	dw mmtest1 
5f89			;	dw mmtest2 
5f89			;	dw mmtest3 
5f89			;	dw mmtest4 
5f89			;	dw mmtest5 
5f89			;	dw mmtest6 
5f89			;	dw iftest1 
5f89			;	dw iftest2 
5f89			;	dw iftest3 
5f89			;	dw looptest1 
5f89			;	dw looptest2 
5f89			;	dw test1 
5f89			;	dw test2 
5f89			;	dw test3 
5f89			;	dw test4 
5f89			;	dw game2r 
5f89			;	dw game2b1 
5f89			;	dw game2b2 
5f89			 
5f89				; start up words that are actually useful 
5f89			 
5f89			;    dw spi1 
5f89			;    dw spi2 
5f89			;    dw spi3 
5f89			;    dw spi4 
5f89			;    dw spi5 
5f89			;    dw spi6 
5f89			;    dw spi7 
5f89			; 
5f89			;    dw spi8 
5f89			;    dw spi9 
5f89			;    dw spi10 
5f89			 
5f89			; file editor 
5f89			;	dw edit1 
5f89			;	dw edit2 
5f89			;	dw edit3 
5f89			 
5f89			;	dw longread 
5f89 b3 63			dw clrstack 
5f8b e7 63			dw type 
5f8d			;	dw stest 
5f8d 0c 64			dw strncpy 
5f8f			;	dw list 
5f8f 6d 64			dw start1 
5f91 7d 64			dw start2 
5f93			;	dw start3 
5f93			;	dw start3b 
5f93			;	dw start3c 
5f93			 
5f93				; (unit) testing words 
5f93			 
5f93			;	dw mtesta 
5f93			;	dw mtestb 
5f93			;	dw mtestc 
5f93			;	dw mtestd 
5f93			;	dw mteste 
5f93			 
5f93				; demo/game words 
5f93			 
5f93			;        dw game3w 
5f93			;        dw game3p 
5f93			;        dw game3sc 
5f93			;        dw game3vsi 
5f93			;        dw game3vs 
5f93				 
5f93 d6 6e			dw game2b 
5f95 44 6f			dw game2bf 
5f97 8e 6f			dw game2mba 
5f99 24 70			dw game2mbas 
5f9b 66 70			dw game2mb 
5f9d			 
5f9d 97 6b			dw game1 
5f9f a8 6b			dw game1a 
5fa1 0a 6c			dw game1b 
5fa3 3f 6c			dw game1c 
5fa5 75 6c			dw game1d 
5fa7 a6 6c			dw game1s 
5fa9 ba 6c			dw game1t 
5fab cf 6c			dw game1f 
5fad 03 6d			dw game1z 
5faf 47 6d			dw game1zz 
5fb1			 
5fb1 b1 69			dw test5 
5fb3 e9 69			dw test6 
5fb5 21 6a			dw test7 
5fb7 35 6a			dw test8 
5fb9 61 6a			dw test9 
5fbb 77 6a			dw test10 
5fbd				 
5fbd 1e 6e		        dw ssv5 
5fbf 02 6e		        dw ssv4 
5fc1 e6 6d		        dw ssv3 
5fc3 b0 6d		        dw ssv2 
5fc5 37 6e		        dw ssv1 
5fc7 7f 6e		        dw ssv1cpm 
5fc9			;	dw keyup 
5fc9			;	dw keydown 
5fc9			;	dw keyleft 
5fc9			;	dw keyright 
5fc9			;	dw 	keyf1 
5fc9			;	dw keyf2 
5fc9			;	dw keyf3 
5fc9			;	dw keyf4 
5fc9			;	dw keyf5 
5fc9			;	dw keyf6 
5fc9			;	dw keyf7 
5fc9			;	dw keyf8 
5fc9			;	dw keyf9 
5fc9			;	dw keyf10 
5fc9			;	dw keyf11 
5fc9			;	dw keyf12 
5fc9			;	dw keytab 
5fc9			;	dw keycr 
5fc9			;	dw keyhome 
5fc9			;	dw keyend 
5fc9			;	dw keybs 
5fc9 00 00			db 0, 0	 
5fcb			 
5fcb			 
5fcb			; File Editor 
5fcb			 
5fcb			; ( id - ) use 'e' to edit the displayed line 
5fcb .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5fec .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
6021			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
6021 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
6059			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
6059			 
6059			; SPI Net support words 
6059			 
6059			; v0! = node to send to 
6059			; ( str count - ) 
6059 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
60b2			 
60b2			; spiputc ( char node - ) 
60b2 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
60e6			; spiputc ( u node - ) 
60e6 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
6114			 
6114			; spigetc ( - n ) 
6114 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
613d			 
613d			; getnode ( - n ) 
613d .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
616a			 
616a			; ( str node - )  
616a .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
61d0			; store string ( str i - ) 
61d0			 
61d0			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
61d0 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
6225			 
6225			; get string ( addr i -  )    TO FIX 
6225			 
6225 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
627d			 
627d			 
627d			; NETCHAT (TODO) 
627d			; Program to allow two nodes to chat with eachother 
627d			; 
627d			; v0 - target node 
627d			;  
627d			; accept input at 0,0 
627d			; if input is string send spitype to target node 
627d			; starting at row 2,0 , while spigetchr is not zero ->  
627d			; 
627d			; 
627d			; TODO add paging of get request 
627d			 
627d			; ( node - ) 
627d .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
629c .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
62f4 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
636c			 
636c			 
636c			; Long read of currently open file 
636c .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
63b3			 
63b3			; clear stack  
63b3			 
63b3 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
63e7			 
63e7			; type ( addr count - ) 
63e7 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
640c			 
640c			; some direct memory words 
640c			; strncpy ( len t f -- t ) 
640c			 
640c .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
646d			 
646d .. 00		start1:     	db ": bpon $00 bp ;",0 
647d .. 00		start2:     	db ": bpoff $01 bp ;",0 
648e .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
6509 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
6569			 
6569			 
6569			; a handy word to list items on the stack 
6569			 
6569 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
65d3			 
65d3			 
65d3			; test stack  
65d3			; rnd8 stest 
65d3			 
65d3 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
664a			 
664a			; random malloc and free cycles 
664a			 
664a .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
66ff			 
66ff			; fixed malloc and free cycles 
66ff			 
66ff .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
67a2			 
67a2			; fixed double string push and drop cycle  
67a2			 
67a2 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
6857			 
6857			; consistent fixed string push and drop cycle  
6857			 
6857 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
68fb			 
68fb .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
69b1			 
69b1			;test1:		db ": aa 1 2 3 ;", 0 
69b1			;test2:     	db "111 aa 888 999",0 
69b1			;test3:     	db ": bb 77 ;",0 
69b1			;test4:     	db "$02 $01 do i . loop bb",0 
69b1			 
69b1 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
69e9 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6a21 .. 00		test7:     	db ": box hline vline ;",0 
6a35 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
6a61 .. 00		test9:     	db ": sw $01 adsp world ;",0 
6a77 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
6a9c .. 00		test11:     	db "hello create .",0 
6aab .. 00		test12:     	db "hello2 create .",0 
6abb			 
6abb			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
6abb			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
6abb			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
6abb			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
6abb			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
6abb			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
6abb			 
6abb			;iftest1:     	db "$0001 IF cls .",0 
6abb			;iftest2:     	db "$0000 IF cls .",0 
6abb			;iftest3:     	db "$0002 $0003 - IF cls .",0 
6abb			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
6abb			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
6abb			 
6abb			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6abb			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6abb			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6abb			 
6abb			 
6abb .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
6adf .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
6b0f .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
6b34 .. 00		sound4: db ": cha $00 ; ",0 
6b41 .. 00		sound5: db ": chb $20 ; ",0 
6b4e .. 00		sound6: db ": chc $40 ; ",0 
6b5b .. 00		sound7: db ": chd $60 ; ",0 
6b68 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
6b80 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
6b97			 
6b97			 
6b97			 
6b97			 
6b97			; a small guess the number game 
6b97			 
6b97 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
6ba8 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6c0a			 
6c0a .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6c3f .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6c75 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6ca6 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6cba .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6ccf .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6d03 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6d47			 
6d47			; Using 'ga' save a high score across multiple runs using external storage 
6d47			 
6d47 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6db0			 
6db0			 
6db0			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6db0			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6db0			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6db0			 
6db0			; simple screen saver to test code memory reuse to destruction 
6db0			 
6db0 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6de6 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6e02 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6e1e .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6e37 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6e7f .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6ed6			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6ed6			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6ed6			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6ed6			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6ed6			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6ed6			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6ed6			 
6ed6			 
6ed6			 
6ed6			; minesweeper/battleship finding game 
6ed6			; draws a game board of random ship/mine positions 
6ed6			; user enters coords to see if it hits on 
6ed6			; game ends when all are hit 
6ed6			; when hit or miss says how many may be in the area 
6ed6			 
6ed6			; setup the game board and then hide it 
6ed6 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6f44 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6f8e			; prompt for where to target 
6f8e .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
7024 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
7049			; TODO see if the entered coords hits or misses pushes char hit of miss 
7049 .. 00		game2mbht:      db ": mbckht nop ;",0 
7058 .. 00		game2mbms:      db ": mbcms nop ;",0 
7066			; TODO how many might be near by 
7066 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
70e3			 
70e3			; Game 3 
70e3			 
70e3			; Vert scroller ski game - avoid the trees! 
70e3			 
70e3			; v0 score (ie turns) 
70e3			; v1 player pos 
70e3			; v2 left wall 
70e3			; v3 right wall 
70e3			 
70e3			; Draw side walls randomly 
70e3			 
70e3 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
7111			 
7111			; Draw player 
7111 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
712f			 
712f			; TODO Get Key 
712f			 
712f			; TODO Move left right 
712f			 
712f			; scroll and move walls a bit 
712f			 
712f .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
7160			 
7160			; main game loop 
7160			 
7160 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
718c .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
71cb			 
71cb			; key board defs 
71cb			 
71cb .. 00		keyup:       db ": keyup $05 ;",0 
71d9 .. 00		keydown:       db ": keydown $0a ;",0 
71e9 .. 00		keyleft:       db ": keyleft $0b ;",0 
71f9 .. 00		keyright:       db ": keyright $0c ;",0 
720a .. 00		keyf1:       db ": keyf1 $10 ;",0 
7218 .. 00		keyf2:       db ": keyf2 $11 ;",0 
7226 .. 00		keyf3:       db ": keyf3 $12 ;",0 
7234 .. 00		keyf4:       db ": keyf4 $13 ;",0 
7242 .. 00		keyf5:       db ": keyf5 $14 ;",0 
7250 .. 00		keyf6:       db ": keyf6 $15 ;",0 
725e .. 00		keyf7:       db ": keyf7 $16 ;",0 
726c .. 00		keyf8:       db ": keyf8 $17 ;",0 
727a .. 00		keyf9:       db ": keyf9 $18 ;",0 
7288 .. 00		keyf10:       db ": keyf10 $19 ;",0 
7297 .. 00		keyf11:       db ": keyf11 $1a ;",0 
72a6 .. 00		keyf12:       db ": keyf12 $1b ;",0 
72b5			 
72b5 .. 00		keytab:       db ": keytab $09 ;",0 
72c4 .. 00		keycr:       db ": keycr $0d ;",0 
72d2 .. 00		keyhome:       db ": keyhome $0e ;",0 
72e2 .. 00		keyend:       db ": keyend $0f ;",0 
72f1 .. 00		keybs:       db ": keybs $08 ;",0 
72ff			 
72ff			   
72ff			 
72ff			 
72ff			 
72ff			; eof 
# End of file forth_autostart.asm
72ff			 
72ff			 
72ff			 
72ff			; stack over and underflow checks 
72ff			 
72ff			; init the words to detect the under/overflow 
72ff			 
72ff			chk_stk_init: 
72ff				; a vague random number to check so we dont get any "lucky" hits 
72ff 3e 2d			ld a, 45 
7301 6f				ld l, a 
7302 00				nop 
7303 3e 17			ld a, 23 
7305 67				ld h, a 
7306			 
7306 22 d8 f0			ld (chk_word), hl     ; the word we need to check against 
7309			 
7309			;	ld (chk_stund), hl	; stack points.... 
7309 22 3b fe			ld (chk_stovr), hl 
730c 22 27 f9			ld (chk_ret_und), hl 
730f 22 e5 f8			ld (chk_ret_ovr), hl 
7312 22 63 f8			ld (chk_loop_ovr), hl 
7315 22 61 f6			ld (chk_data_ovr), hl 
7318 c9				ret 
7319				 
7319			check_stacks: 
7319				; check all stack words 
7319			 
7319 e5				push hl 
731a d5				push de 
731b			 
731b			;	ld de,(chk_word) 
731b			;	ld hl, (chk_stund)	; stack points.... 
731b			;	if DEBUG_STK_FAULT 
731b			;		DMARK "FAa" 
731b			;		CALLMONITOR 
731b			;	endif 
731b			;	call cmp16 
731b			;	jp z, .chk_faulta 
731b			; 
731b			;	ld de, sfaultsu 
731b			;	jp .chk_fault 
731b			 
731b 2a 3b fe		.chk_faulta: ld hl, (chk_stovr) 
731e ed 5b d8 f0		ld de,(chk_word) 
7322				if DEBUG_STK_FAULT 
7322					DMARK "FAb" 
7322					CALLMONITOR 
7322				endif 
7322 cd ed 0f			call cmp16 
7325 28 06			jr z, .chk_fault1 
7327 11 c8 73			ld de, sfaultso 
732a c3 7c 73			jp .chk_fault 
732d			.chk_fault1:  
732d 2a 27 f9			ld hl, (chk_ret_und) 
7330 ed 5b d8 f0		ld de,(chk_word) 
7334				if DEBUG_STK_FAULT 
7334					DMARK "FAU" 
7334					CALLMONITOR 
7334				endif 
7334 cd ed 0f			call cmp16 
7337 ca 40 73			jp z, .chk_fault2 
733a 11 d8 73			ld de, sfaultru 
733d c3 7c 73			jp .chk_fault 
7340			.chk_fault2:  
7340 2a e5 f8			ld hl, (chk_ret_ovr) 
7343 ed 5b d8 f0		ld de,(chk_word) 
7347				if DEBUG_STK_FAULT 
7347					DMARK "FA1" 
7347					CALLMONITOR 
7347				endif 
7347 cd ed 0f			call cmp16 
734a ca 53 73			jp z, .chk_fault3 
734d 11 e6 73			ld de, sfaultro 
7350 c3 7c 73			jp .chk_fault 
7353			.chk_fault3:  
7353 2a 63 f8			ld hl, (chk_loop_ovr) 
7356 ed 5b d8 f0		ld de,(chk_word) 
735a				if DEBUG_STK_FAULT 
735a					DMARK "FA2" 
735a					CALLMONITOR 
735a				endif 
735a cd ed 0f			call cmp16 
735d ca 66 73			jp z, .chk_fault4 
7360 11 00 74			ld de, sfaultlo 
7363 c3 7c 73			jp .chk_fault 
7366			.chk_fault4:  
7366 2a 61 f6			ld hl, (chk_data_ovr) 
7369 ed 5b d8 f0		ld de,(chk_word) 
736d				if DEBUG_STK_FAULT 
736d					DMARK "FA3" 
736d					CALLMONITOR 
736d				endif 
736d cd ed 0f			call cmp16 
7370 ca 79 73			jp z, .chk_fault5 
7373 11 1a 74			ld de, sfaultdo 
7376 c3 7c 73			jp .chk_fault 
7379			 
7379			 
7379			.chk_fault5:  
7379 d1				pop de 
737a e1				pop hl 
737b			 
737b c9				ret 
737c			 
737c cd 9b 0d		.chk_fault: 	call clear_display 
737f 3e 28				ld a, display_row_2 
7381 cd ae 0d				call str_at_display 
7384 11 aa 73				   ld de, .stackfault 
7387 3e 00				ld a, display_row_1 
7389 cd ae 0d				call str_at_display 
738c 11 a6 fd				    ld de, debug_mark 
738f 3e 11				ld a, display_row_1+17 
7391 cd ae 0d				call str_at_display 
7394 cd be 0d				call update_display 
7397			 
7397				; prompt before entering montior for investigating issue 
7397			 
7397 3e 78			ld a, display_row_4 
7399 11 f5 1d			ld de, endprog 
739c			 
739c cd be 0d			call update_display		 
739f			 
739f cd 7b 20			call next_page_prompt 
73a2			 
73a2 d1				pop de 
73a3 e1				pop hl 
73a4 cd 49 1e				call monitor 
73a7 c3 52 1d				jp warmstart 
73aa					;jp 0 
73aa					;halt 
73aa			 
73aa			 
73aa			 
73aa .. 00		.stackfault: 	db "Stack fault:",0 
73b7			 
73b7 .. 00		sfaultsu: 	db	"Stack under flow",0 
73c8 .. 00		sfaultso: 	db	"Stack over flow",0 
73d8 .. 00		sfaultru:	db "RTS underflow",0 
73e6 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
7400 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
741a .. 00		sfaultdo:	db "DTS overflow", 0 
7427			 
7427			 
7427			fault_dsp_under: 
7427 11 39 74			ld de, .dsp_under 
742a c3 e9 74			jp .show_fault 
742d			 
742d			fault_rsp_under: 
742d 11 47 74			ld de, .rsp_under 
7430 c3 e9 74			jp .show_fault 
7433			fault_loop_under: 
7433 11 55 74			ld de, .loop_under 
7436 c3 e9 74			jp .show_fault 
7439			 
7439 .. 00		.dsp_under: db "DSP Underflow",0 
7447 .. 00		.rsp_under: db "RSP Underflow",0 
7455 .. 00		.loop_under: db "LOOP Underflow",0 
7464			 
7464			 
7464 d5			type_faultn: 	push de 
7465 e5					push hl 
7466 cd 9b 0d				call clear_display 
7469 11 90 74				   ld de, .typefaultn 
746c 3e 00				ld a, display_row_1 
746e cd ae 0d				call str_at_display 
7471 11 a6 fd				    ld de, debug_mark 
7474 3e 11				ld a, display_row_1+17 
7476 cd ae 0d				call str_at_display 
7479 cd be 0d				call update_display 
747c			 
747c				; prompt before entering montior for investigating issue 
747c			 
747c 3e 78			ld a, display_row_4 
747e 11 f5 1d			ld de, endprog 
7481			 
7481 cd be 0d			call update_display		 
7484			 
7484 cd 7b 20			call next_page_prompt 
7487			 
7487 e5					push hl 
7488 d5					push de 
7489 cd 49 1e				call monitor 
748c c3 52 1d				jp warmstart 
748f 76					halt 
7490			 
7490			 
7490 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
74a7			 
74a7 d5			type_faults: 	push de 
74a8 e5					push hl 
74a9 cd 9b 0d				call clear_display 
74ac 11 d2 74				   ld de, .typefaults 
74af 3e 00				ld a, display_row_1 
74b1 cd ae 0d				call str_at_display 
74b4 11 a6 fd				    ld de, debug_mark 
74b7 3e 11				ld a, display_row_1+17 
74b9 cd ae 0d				call str_at_display 
74bc cd be 0d				call update_display 
74bf			 
74bf				; prompt before entering montior for investigating issue 
74bf			 
74bf 3e 78			ld a, display_row_4 
74c1 11 f5 1d			ld de, endprog 
74c4			 
74c4 cd be 0d			call update_display		 
74c7			 
74c7 cd 7b 20			call next_page_prompt 
74ca			 
74ca e1					pop hl 
74cb d1					pop de 
74cc cd 49 1e				call monitor 
74cf c3 52 1d				jp warmstart 
74d2			 
74d2			 
74d2 .. 00		.typefaults: db "STR Type Expected TOS!",0 
74e9			 
74e9			.show_fault: 	 
74e9 d5					push de 
74ea cd 9b 0d				call clear_display 
74ed d1					pop de 
74ee 3e 00				ld a, display_row_1 
74f0 cd ae 0d				call str_at_display 
74f3 11 a6 fd				    ld de, debug_mark 
74f6 3e 11				ld a, display_row_1+17 
74f8 cd ae 0d				call str_at_display 
74fb cd be 0d				call update_display 
74fe			 
74fe				; prompt before entering montior for investigating issue 
74fe			 
74fe 3e 78			ld a, display_row_4 
7500 11 f5 1d			ld de, endprog 
7503			 
7503 cd be 0d			call update_display		 
7506			 
7506 cd 7b 20			call next_page_prompt 
7509			 
7509 e1					pop hl 
750a d1					pop de 
750b cd 49 1e				call monitor 
750e			; do a dump to cli and not warmstart so we preserve all of the uwords.  
750e			; TODO Make optional fault restart to cli or warm boot? 
750e					;jp warmstart 
750e c3 9c 1d				jp cli 
7511 76					halt 
7512			 
7512			; handle the auto run of code from files in storage 
7512			 
7512			 
7512			include "forth_startup.asm" 
7512			; Which startup method to use? 
7512			; 
7512			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
7512			; followed by loading of a list of scripts in eeprom 
7512			 
7512			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
7512			; from eeprom 
7512			 
7512			; Select with define in main stubs 
7512			 
7512			if STARTUP_V1 
7512				include "forth_startupv1.asm" 
7512			endif 
7512			if STARTUP_V2 
7512				include "forth_startupv2.asm" 
7512			; Version 2 of the startup  
7512			;  
7512			; Auto load any files in bank 1 that start with a '*' 
7512			; If no se storage then revert to using eprom 
7512			 
7512			 
7512			if STORAGE_SE = 0 
7512			 
7512			sprompt1: db "Startup load...",0 
7512			sprompt2: db "Run? 1=No *=End #=All",0 
7512			 
7512			 
7512			 
7512			 
7512			forth_startup: 
7512				ld hl, startcmds 
7512				ld a, 0 
7512				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
7512			 
7512			.start1:	push hl 
7512				call clear_display 
7512				ld de, sprompt1 
7512			        ld a, display_row_1 
7512				call str_at_display 
7512				ld de, sprompt2 
7512			        ld a, display_row_2 
7512				call str_at_display 
7512				pop hl 
7512				push hl 
7512				ld e,(hl) 
7512				inc hl 
7512				ld d,(hl) 
7512			        ld a, display_row_3 
7512				call str_at_display 
7512				call update_display 
7512			 
7512			 
7512				ld a, (os_last_cmd) 
7512				cp 0 
7512				jr z, .startprompt 
7512				call delay250ms 
7512				jr .startdo 
7512				 
7512				 
7512			 
7512			.startprompt: 
7512			 
7512				ld a,display_row_4 + display_cols - 1 
7512			        ld de, endprg 
7512				call str_at_display 
7512				call update_display 
7512				call delay1s 
7512				call cin_wait 
7512						 
7512				cp '*' 
7512				jr z, .startupend1 
7512				cp '#' 
7512				jr nz, .startno 
7512				ld a, 1 
7512				ld (os_last_cmd),a 
7512				jr .startdo 
7512			.startno:	cp '1' 
7512				jr z,.startnxt  
7512			 
7512				; exec startup line 
7512			.startdo:	 
7512				pop hl 
7512				push hl 
7512				 
7512				ld e,(hl) 
7512				inc hl 
7512				ld d,(hl) 
7512				ex de,hl 
7512			 
7512				push hl 
7512			 
7512				ld a, 0 
7512				;ld a, FORTH_END_BUFFER 
7512				call strlent 
7512				inc hl   ; include zero term to copy 
7512				ld b,0 
7512				ld c,l 
7512				pop hl 
7512				ld de, scratch 
7512				ldir 
7512			 
7512			 
7512				ld hl, scratch 
7512				call forthparse 
7512				call forthexec 
7512				call forthexec_cleanup 
7512			 
7512				ld a, display_row_4 
7512				ld de, endprog 
7512			 
7512				call update_display		 
7512			 
7512				ld a, (os_last_cmd) 
7512				cp 0 
7512				jr nz, .startnxt 
7512				call next_page_prompt 
7512			        call clear_display 
7512				call update_display		 
7512			 
7512				; move onto next startup line? 
7512			.startnxt: 
7512			 
7512				call delay250ms 
7512				pop hl 
7512			 
7512				inc hl 
7512				inc hl 
7512			 
7512				push hl 
7512				ld e, (hl) 
7512				inc hl 
7512				ld d, (hl) 
7512				pop hl 
7512				; TODO replace 0 test 
7512			 
7512				ex de, hl 
7512				call ishlzero 
7512			;	ld a,e 
7512			;	add d 
7512			;	cp 0    ; any left to do? 
7512				ex de, hl 
7512				jp nz, .start1 
7512				jr .startupend 
7512			 
7512			.startupend1: pop hl 
7512			.startupend: 
7512			 
7512				call clear_display 
7512				call update_display 
7512				ret 
7512			endif 
7512			 
7512			 
7512			if STORAGE_SE 
7512			 
7512			;sprompt3: db "Loading from start-up file:",0 
7512 .. 00		sprompt3: db "  Searching...",0 
7521			;sprompt4: db "(Any key to stop)",0 
7521			 
7521			 
7521			forth_autoload: 
7521			 
7521				; load block 0 of store 1 
7521				 
7521 3e fe			ld a, $fe      ; bit 0 clear 
7523 32 9b f9			ld (spi_device), a 
7526			 
7526 cd 16 05			call storage_get_block_0 
7529			 
7529 3a d6 f9			ld a, (store_page+STORE_0_AUTOFILE) 
752c			 
752c fe 00			cp 0 
752e c8				ret z     ; auto start not enabled 
752f			 
752f cd 9b 0d			call clear_display 
7532			 
7532				; set bank 
7532			 
7532 3a d8 f9				ld a, (store_page+STORE_0_BANKRUN) 
7535 32 9b f9				ld (spi_device), a 
7538			 
7538			 
7538				; generate a directory of bank 1 and search for flagged files 
7538			 
7538					if DEBUG_FORTH_WORDS_KEY 
7538						DMARK "DIR" 
7538 f5				push af  
7539 3a 4d 75			ld a, (.dmark)  
753c 32 a6 fd			ld (debug_mark),a  
753f 3a 4e 75			ld a, (.dmark+1)  
7542 32 a7 fd			ld (debug_mark+1),a  
7545 3a 4f 75			ld a, (.dmark+2)  
7548 32 a8 fd			ld (debug_mark+2),a  
754b 18 03			jr .pastdmark  
754d ..			.dmark: db "DIR"  
7550 f1			.pastdmark: pop af  
7551			endm  
# End of macro DMARK
7551						CALLMONITOR 
7551 cd aa fd			call debug_vector  
7554				endm  
# End of macro CALLMONITOR
7554					endif 
7554			 
7554 cd 16 05			call storage_get_block_0 
7557			 
7557 21 b5 f9			ld hl, store_page     ; get current id count 
755a 46				ld b, (hl) 
755b 0e 00			ld c, 0    ; count of files   
755d					if DEBUG_FORTH_WORDS 
755d						DMARK "DI1" 
755d f5				push af  
755e 3a 72 75			ld a, (.dmark)  
7561 32 a6 fd			ld (debug_mark),a  
7564 3a 73 75			ld a, (.dmark+1)  
7567 32 a7 fd			ld (debug_mark+1),a  
756a 3a 74 75			ld a, (.dmark+2)  
756d 32 a8 fd			ld (debug_mark+2),a  
7570 18 03			jr .pastdmark  
7572 ..			.dmark: db "DI1"  
7575 f1			.pastdmark: pop af  
7576			endm  
# End of macro DMARK
7576						CALLMONITOR 
7576 cd aa fd			call debug_vector  
7579				endm  
# End of macro CALLMONITOR
7579					endif 
7579			 
7579				; check for empty drive 
7579			 
7579 3e 00			ld a, 0 
757b b8				cp b 
757c ca c9 75			jp z, .dirdone 
757f			 
757f				; for each of the current ids do a search for them and if found push to stack 
757f			 
757f c5			.diritem:	push bc 
7580 21 40 00				ld hl, STORE_BLOCK_PHY 
7583 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
7585 58					ld e,b 
7586			 
7586 d5					push de 
7587 e5					push hl 
7588 cd 9b 0d			call clear_display 
758b 3e 32			ld a, display_row_2 + 10 
758d 11 12 75			ld de, sprompt3 
7590 cd ae 0d			call str_at_display 
7593 cd f2 0c			call active 
7596 eb				ex de, hl 
7597 3e 2f			ld a, display_row_2 + 7 
7599 cd ae 0d			call str_at_display 
759c cd be 0d			call update_display 
759f e1				pop hl 
75a0 d1				pop de 
75a1			 
75a1			;		if DEBUG_FORTH_WORDS 
75a1			;			DMARK "DI2" 
75a1			;			CALLMONITOR 
75a1			;		endif 
75a1			 
75a1 cd 98 07				call storage_findnextid 
75a4			 
75a4			;		if DEBUG_FORTH_WORDS 
75a4			;			DMARK "DI3" 
75a4			;			CALLMONITOR 
75a4			;		endif 
75a4			 
75a4					; if found hl will be non zero 
75a4			 
75a4 cd f8 0f				call ishlzero 
75a7			;		ld a, l 
75a7			;		add h 
75a7			; 
75a7			;		cp 0 
75a7 28 1d				jr z, .dirnotfound 
75a9			 
75a9					; increase count 
75a9			 
75a9 c1					pop bc	 
75aa 0c					inc c 
75ab c5					push bc 
75ac					 
75ac			 
75ac					; get file header and push the file name 
75ac			 
75ac 11 b5 f9				ld de, store_page 
75af cd 65 04				call storage_read_block 
75b2			 
75b2					; push file id to stack 
75b2				 
75b2			 
75b2					; is this a file we want to run? 
75b2			 
75b2 21 b8 f9				ld hl, store_page+3 
75b5 7e					ld a,(hl) 
75b6 fe 2a				cp '*' 
75b8 20 0c				jr nz,  .dirnotfound 
75ba					 
75ba			 
75ba			 
75ba 3a b5 f9				ld a, (store_page) 
75bd d5					push de 
75be e5					push hl 
75bf c5					push bc 
75c0 cd ec 75				call .autorunf 
75c3 c1					pop bc 
75c4 e1					pop hl 
75c5 d1					pop de 
75c6			 
75c6			 
75c6			 
75c6				; save this extent 
75c6			 
75c6					; push file name 
75c6			;display file name to run 
75c6			 
75c6			;		ld hl, store_page+3 
75c6			;		if DEBUG_FORTH_WORDS 
75c6			;			DMARK "DI5" 
75c6			;			CALLMONITOR 
75c6			;		endif 
75c6			; 
75c6			;		 
75c6			; 
75c6			;		call forth_push_str 
75c6			;		if DEBUG_FORTH_WORDS 
75c6			;			DMARK "DI6" 
75c6			;			CALLMONITOR 
75c6			;		endif 
75c6			.dirnotfound: 
75c6 c1					pop bc     
75c7 10 b6				djnz .diritem 
75c9				 
75c9			.dirdone:	 
75c9					if DEBUG_FORTH_WORDS 
75c9						DMARK "DI7" 
75c9 f5				push af  
75ca 3a de 75			ld a, (.dmark)  
75cd 32 a6 fd			ld (debug_mark),a  
75d0 3a df 75			ld a, (.dmark+1)  
75d3 32 a7 fd			ld (debug_mark+1),a  
75d6 3a e0 75			ld a, (.dmark+2)  
75d9 32 a8 fd			ld (debug_mark+2),a  
75dc 18 03			jr .pastdmark  
75de ..			.dmark: db "DI7"  
75e1 f1			.pastdmark: pop af  
75e2			endm  
# End of macro DMARK
75e2						CALLMONITOR 
75e2 cd aa fd			call debug_vector  
75e5				endm  
# End of macro CALLMONITOR
75e5					endif 
75e5			 
75e5 cd 9b 0d				call clear_display 
75e8 cd be 0d				call update_display 
75eb			 
75eb c9					ret 
75ec			 
75ec			 
75ec			 
75ec			 
75ec			 
75ec			.autorunf: 
75ec			 
75ec			 
75ec				; get file id to load from and get the file name to display 
75ec			 
75ec			;		ld a, (store_page+STORE_0_FILERUN) 
75ec			 
75ec 2e 00				ld l, 0 
75ee 67					ld h, a 
75ef 11 b5 f9				ld de, store_page 
75f2			 
75f2					if DEBUG_FORTH_WORDS 
75f2						DMARK "ASp" 
75f2 f5				push af  
75f3 3a 07 76			ld a, (.dmark)  
75f6 32 a6 fd			ld (debug_mark),a  
75f9 3a 08 76			ld a, (.dmark+1)  
75fc 32 a7 fd			ld (debug_mark+1),a  
75ff 3a 09 76			ld a, (.dmark+2)  
7602 32 a8 fd			ld (debug_mark+2),a  
7605 18 03			jr .pastdmark  
7607 ..			.dmark: db "ASp"  
760a f1			.pastdmark: pop af  
760b			endm  
# End of macro DMARK
760b						CALLMONITOR 
760b cd aa fd			call debug_vector  
760e				endm  
# End of macro CALLMONITOR
760e					endif 
760e cd be 09				call storage_read 
7611			 
7611					if DEBUG_FORTH_WORDS 
7611						DMARK "ASr" 
7611 f5				push af  
7612 3a 26 76			ld a, (.dmark)  
7615 32 a6 fd			ld (debug_mark),a  
7618 3a 27 76			ld a, (.dmark+1)  
761b 32 a7 fd			ld (debug_mark+1),a  
761e 3a 28 76			ld a, (.dmark+2)  
7621 32 a8 fd			ld (debug_mark+2),a  
7624 18 03			jr .pastdmark  
7626 ..			.dmark: db "ASr"  
7629 f1			.pastdmark: pop af  
762a			endm  
# End of macro DMARK
762a						CALLMONITOR 
762a cd aa fd			call debug_vector  
762d				endm  
# End of macro CALLMONITOR
762d					endif 
762d			 
762d cd f8 0f				call ishlzero 
7630 c8					ret z             ; file not found 
7631			 
7631					; display file name we are loading 
7631			 
7631 cd 9b 0d				call clear_display 
7634			 
7634 3e 32				ld a, display_row_2 + 10 
7636 11 b8 f9				ld de, store_page+3 
7639 cd ae 0d				call str_at_display 
763c				 
763c			; 
763c			 
763c			;	ld a, display_row_1+5 
763c			;	ld de, sprompt3 
763c			;	call str_at_display 
763c			;	ld a, display_row_2+7 
763c			;	call active 
763c			;	ex de, hl 
763c			;;	ld de, sprompt4 
763c			;	call str_at_display 
763c			; 
763c cd be 0d			call update_display 
763f			 
763f			;	call cin_wait 
763f			;	cp 'n' 
763f			;	ret z 
763f			;	cp 'N' 
763f			;	ret z 
763f			 
763f			;	call delay1s 
763f			 
763f 3a b7 f9			ld a, (store_page+2) 
7642 32 a4 f9			ld (store_openmaxext), a    ; save count of ext 
7645 3e 01			ld a, 1  
7647 32 a5 f9			ld (store_openext), a    ; save count of ext 
764a			 
764a			.autof: 
764a				; begin to read a line from file 
764a			 
764a 21 23 f4			ld hl, os_cli_cmd 
764d 22 21 f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
7650			  
7650			.readext: 
7650 3a a5 f9			ld a, (store_openext) 
7653 6f				ld l , a 
7654				 
7654 3a b5 f9			ld a, (store_page) 
7657 67				ld h, a	 
7658 11 b5 f9			ld de, store_page 
765b					if DEBUG_FORTH_WORDS 
765b						DMARK "ASl" 
765b f5				push af  
765c 3a 70 76			ld a, (.dmark)  
765f 32 a6 fd			ld (debug_mark),a  
7662 3a 71 76			ld a, (.dmark+1)  
7665 32 a7 fd			ld (debug_mark+1),a  
7668 3a 72 76			ld a, (.dmark+2)  
766b 32 a8 fd			ld (debug_mark+2),a  
766e 18 03			jr .pastdmark  
7670 ..			.dmark: db "ASl"  
7673 f1			.pastdmark: pop af  
7674			endm  
# End of macro DMARK
7674						CALLMONITOR 
7674 cd aa fd			call debug_vector  
7677				endm  
# End of macro CALLMONITOR
7677					endif 
7677 cd be 09				call storage_read 
767a cd f8 0f			call ishlzero 
767d c8				ret z 
767e			 
767e			; TODO copy to exec buffer 
767e			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
767e			 
767e				; copy the record buffer to the cli buffer 
767e			 
767e ed 5b 21 f6		ld de, (os_var_array) 
7682 21 b7 f9			ld hl, store_page+2 
7685			;	ex de, hl 
7685 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
7688 ed b0			ldir 
768a ed 53 21 f6		ld (os_var_array), de 
768e				 
768e 3a a5 f9			ld a, (store_openext) 
7691 3c				inc a 
7692 32 a5 f9			ld (store_openext), a    ; save count of ext 
7695			 
7695			 
7695			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
7695				 
7695 3a a8 f9			ld a, (store_readcont) 
7698 fe 00			cp 0 
769a 20 b4			jr nz, .readext 
769c			 
769c			;	jr z, .autoend 
769c			 
769c					if DEBUG_FORTH_WORDS 
769c						DMARK "ASc" 
769c f5				push af  
769d 3a b1 76			ld a, (.dmark)  
76a0 32 a6 fd			ld (debug_mark),a  
76a3 3a b2 76			ld a, (.dmark+1)  
76a6 32 a7 fd			ld (debug_mark+1),a  
76a9 3a b3 76			ld a, (.dmark+2)  
76ac 32 a8 fd			ld (debug_mark+2),a  
76af 18 03			jr .pastdmark  
76b1 ..			.dmark: db "ASc"  
76b4 f1			.pastdmark: pop af  
76b5			endm  
# End of macro DMARK
76b5						CALLMONITOR 
76b5 cd aa fd			call debug_vector  
76b8				endm  
# End of macro CALLMONITOR
76b8					endif 
76b8 e5				push hl	 
76b9 d5				push de 
76ba cd f2 0c			call active 
76bd eb				ex de, hl 
76be 3e 2f			ld a, display_row_2 + 7 
76c0 cd ae 0d			call str_at_display 
76c3			 
76c3 cd be 0d			call update_display 
76c6 d1				pop de  
76c7 e1				pop hl 
76c8			;	call delay250ms 
76c8			 
76c8			 
76c8			 
76c8			 
76c8			.autoexec: 
76c8			 
76c8			 
76c8 21 23 f4			ld hl, os_cli_cmd 
76cb					if DEBUG_FORTH_WORDS 
76cb						DMARK "ASx" 
76cb f5				push af  
76cc 3a e0 76			ld a, (.dmark)  
76cf 32 a6 fd			ld (debug_mark),a  
76d2 3a e1 76			ld a, (.dmark+1)  
76d5 32 a7 fd			ld (debug_mark+1),a  
76d8 3a e2 76			ld a, (.dmark+2)  
76db 32 a8 fd			ld (debug_mark+2),a  
76de 18 03			jr .pastdmark  
76e0 ..			.dmark: db "ASx"  
76e3 f1			.pastdmark: pop af  
76e4			endm  
# End of macro DMARK
76e4						CALLMONITOR 
76e4 cd aa fd			call debug_vector  
76e7				endm  
# End of macro CALLMONITOR
76e7					endif 
76e7 cd fe 24			call forthparse 
76ea cd 3e 25			call forthexec 
76ed cd 50 24			call forthexec_cleanup 
76f0			 
76f0			 
76f0			 
76f0 c3 4a 76			jp .autof 
76f3			;.autofdone: 
76f3			; 
76f3			;		if DEBUG_FORTH_WORDS 
76f3			;			DMARK "ASx" 
76f3			;			CALLMONITOR 
76f3			;		endif 
76f3			;;	call clear_display 
76f3			;	ret 
76f3			 
76f3			 
76f3			 
76f3			endif 
# End of file forth_startupv2.asm
76f3			endif 
76f3			 
# End of file forth_startup.asm
76f3			 
76f3			; eof 
# End of file forth_kernel.asm
76f3			;include "nascombasic.asm" 
76f3			 
76f3			 
76f3			; find out where the code ends if loaded into RAM (for SC114) 
76f3			;endofcode:  
76f3			;	nop 
76f3			 
76f3			 
76f3			; jump to nmi vector 
76f3			 
76f3			init_nmi: 
76f3 3e c9			ld a, $c9   ; RET 
76f5 32 ad fd			ld (nmi_vector), a 
76f8 c9				ret 
76f9			nmi: 
76f9 e5				push hl 
76fa d5				push de 
76fb c5				push bc 
76fc f5				push af 
76fd cd ad fd			call nmi_vector 
7700 f5				push af 
7701 c5				push bc 
7702 d5				push de 
7703 e5				push hl 
7704 ed 4d			reti 
7706			 
7706			 
7706			; eof 
7706			 
# End of file main.asm
7706			include "firmware_lcd_4x40.asm" 
7706			; **********************************************************************  
7706			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
7706			; **********************************************************************  
7706			;  
7706			; **  Written as a Small Computer Monitor App  
7706			; **  www.scc.me.uk  
7706			;  
7706			; History  
7706			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
7706			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
7706			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
7706			;  
7706			; **********************************************************************  
7706			;  
7706			; This program is an example of one of the methods of interfacing an   
7706			; alphanumeric LCD module.   
7706			;  
7706			; In this example the display is connected to either a Z80 PIO or a   
7706			; simple 8-bit output port.   
7706			;  
7706			; This interfacing method uses 4-bit data mode and uses time delays  
7706			; rather than polling the display's ready status. As a result the   
7706			; interface only requires 6 simple output lines:  
7706			;   Output bit 0 = not used  
7706			;   Output bit 1 = not used  
7706			;   Output bit 2 = RS         High = data, Low = instruction  
7706			;   Output bit 3 = E          Active high  
7706			;   Output bit 4 = DB4  
7706			;   Output bit 5 = DB5  
7706			;   Output bit 6 = DB6  
7706			;   Output bit 7 = DB7  
7706			; Display's R/W is connected to 0v so it is always in write mode  
7706			;  
7706			; This set up should work with any system supporting the RC2014 bus  
7706			  
7706			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
7706			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
7706			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
7706			;  
7706			; **********************************************************************  
7706			  
7706			; Additonal for 4x40. E1 and E2 instead of just E   
7706			; TODO swipe vidout signal on port a to activate E2  
7706			  
7706			; **********************************************************************  
7706			; **  Constants  
7706			; **********************************************************************  
7706			; LCD constants required by LCD support module  
7706			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
7706			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
7706			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
7706			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
7706			; TODO Decide which E is being set  
7706			kLCDWidth:  EQU display_cols             ;Width in characters  
7706			  
7706			; **********************************************************************  
7706			; **  Code library usage  
7706			; **********************************************************************  
7706			  
7706			; send character to current cursor position  
7706			; wraps and/or scrolls screen automatically  
7706			  
7706			  
7706			  
7706			lcd_init:  
7706			  
7706			; SCMonAPI functions used  
7706			  
7706			; Alphanumeric LCD functions used  
7706			; no need to specify specific functions for this module  
7706			  
7706 3e cf		            LD   A, 11001111b  
7708 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
770a 3e 00		            LD   A, 00000000b  
770c d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
770e			  
770e			; Initialise alphanumeric LCD module  
770e 3e 00				ld a, 0  
7710 32 06 fb				ld (display_lcde1e2), a  
7713 cd 94 77		            CALL fLCD_Init      ;Initialise LCD module  
7716 3e 01				ld a, 1  
7718 32 06 fb				ld (display_lcde1e2), a  
771b cd 94 77		            CALL fLCD_Init      ;Initialise LCD module  
771e			  
771e c9				ret  
771f			  
771f			;  
771f			;;  
771f			; lcd functions  
771f			;  
771f			;  
771f			  
771f			; what is at cursor position   
771f			  
771f			;get_cursor:	ld de, (cursor_row)   ;  row + col  
771f			;		call curptr  
771f			;		ret  
771f			  
771f			  
771f			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
771f			  
771f			curptr:  
771f c5				push bc  
7720 21 ec fc			ld hl, display_fb0  
7723			cpr:	  
7723				; loop for cursor whole row  
7723 0e 28			ld c, display_cols  
7725 23			cpr1:	inc hl  
7726 0d				dec c  
7727 20 fc			jr nz, cpr1  
7729 05				dec b  
772a 20 f7			jr nz, cpr  
772c			  
772c				; add col	  
772c			  
772c 23			cpr2:	inc hl  
772d 1d				dec e  
772e 20 fc			jr nz, cpr2  
7730			  
7730 c1				pop bc  
7731 c9				ret  
7732				  
7732			  
7732			  
7732			  
7732			  
7732			; write the frame buffer given in hl to hardware   
7732 22 04 fb		write_display: ld (display_write_tmp), hl 	   
7735 3e 00			ld a, kLCD_Line1  
7737 cd 41 78		            CALL fLCD_Pos       ;Position cursor to location in A  
773a 06 28			ld b, display_cols  
773c ed 5b 04 fb		ld de, (display_write_tmp)  
7740 cd 8c 77			call write_len_string  
7743				  
7743				  
7743 2a 04 fb			ld hl, (display_write_tmp)  
7746 11 28 00			ld de, display_cols  
7749 19				add hl,de  
774a 22 04 fb			ld (display_write_tmp),hl  
774d			  
774d				  
774d 3e 28			ld a, kLCD_Line2  
774f cd 41 78		            CALL fLCD_Pos       ;Position cursor to location in A  
7752 06 28			ld b, display_cols  
7754 ed 5b 04 fb		ld de, (display_write_tmp)  
7758 cd 8c 77			call write_len_string  
775b				  
775b 2a 04 fb			ld hl, (display_write_tmp)  
775e 11 28 00			ld de, display_cols  
7761 19				add hl,de  
7762 22 04 fb			ld (display_write_tmp),hl  
7765			  
7765				  
7765 3e 50			ld a, kLCD_Line3  
7767 cd 41 78		            CALL fLCD_Pos       ;Position cursor to location in A  
776a 06 28			ld b, display_cols  
776c ed 5b 04 fb		ld de, (display_write_tmp)  
7770 cd 8c 77			call write_len_string  
7773				  
7773 2a 04 fb			ld hl, (display_write_tmp)  
7776 11 28 00			ld de, display_cols  
7779 19				add hl,de  
777a 22 04 fb			ld (display_write_tmp),hl  
777d			  
777d				  
777d 3e 78			ld a, kLCD_Line4  
777f cd 41 78		            CALL fLCD_Pos       ;Position cursor to location in A  
7782 06 28			ld b, display_cols  
7784 ed 5b 04 fb		ld de, (display_write_tmp)  
7788 cd 8c 77			call write_len_string  
778b c9					ret  
778c				  
778c				; write out a fixed length string given in b from de  
778c			  
778c 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
778d cd f9 77		            CALL fLCD_Data      ;Write character to display  
7790 13				inc de  
7791 10 f9			djnz write_len_string  
7793 c9				ret  
7794			  
7794			; Some other things to do  
7794			;            LD   A, kLCD_Clear ;Display clear  
7794			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
7794			;            LD   A, kLCD_Under ;Display on with underscore cursor  
7794			;            LD   A, kLCD_On     ;Display on with no cursor  
7794			;            ;LD   A, kLCD_Off   ;Display off  
7794			;            CALL fLCD_Inst      ;Send instruction to display  
7794			;  
7794			;  
7794			;            halt  
7794			;  
7794			;  
7794			;MsgHello:   DB  "Hello World!",0  
7794			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
7794			  
7794			; Custom characters 5 pixels wide by 8 pixels high  
7794			; Up to 8 custom characters can be defined  
7794			;BitMaps:      
7794			;; Character 0x00 = Battery icon  
7794			;            DB  01110b  
7794			;            DB  11011b  
7794			;            DB  10001b  
7794			;            DB  10001b  
7794			;            DB  11111b  
7794			;            DB  11111b  
7794			;            DB  11111b  
7794			;            DB  11111b  
7794			;; Character 0x01 = Bluetooth icon  
7794			;            DB  01100b  
7794			;            DB  01010b  
7794			;            DB  11100b  
7794			;            DB  01000b  
7794			;            DB  11100b  
7794			;            DB  01010b  
7794			;            DB  01100b  
7794			;            DB  00000b  
7794			;  
7794			  
7794			  
7794			; **********************************************************************  
7794			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
7794			; **********************************************************************  
7794			;  
7794			; **  Written as a Small Computer Monitor App   
7794			; **  Version 0.1 SCC 2018-05-16  
7794			; **  www.scc.me.uk  
7794			;  
7794			; **********************************************************************  
7794			;  
7794			; This module provides support for alphanumeric LCD modules using with  
7794			; *  HD44780 (or compatible) controller  
7794			; *  5 x 7 pixel fonts  
7794			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
7794			; *  Interface via six digital outputs to the display (see below)  
7794			;  
7794			; LCD module pinout:  
7794			;   1  Vss   0v supply  
7794			;   2  Vdd   5v supply  
7794			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
7794			;   4  RS    High = data, Low = instruction  
7794			;   5  R/W   High = Read, Low = Write  
7794			;   6  E     Enable signal (active high)  
7794			;   7  DB0   Data bit 0  
7794			;   8  DB1   Data bit 1  
7794			;   9  DB2   Data bit 2  
7794			;  10  DB3   Data bit 3  
7794			;  11  DB4   Data bit 4  
7794			;  12  DB5   Data bit 5  
7794			;  13  DB6   Data bit 6  
7794			;  14  DB7   Data bit 7  
7794			;  15  A     Backlight anode (+)  
7794			;  16  K     Backlight cathode (-)  
7794			;  
7794			; This interfacing method uses 4-bit data mode and uses time delays  
7794			; rather than polling the display's ready status. As a result the   
7794			; interface only requires 6 simple output lines:  
7794			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
7794			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
7794			;   LCD DB4 = Microcomputer output port bit 4  
7794			;   LCD DB5 = Microcomputer output port bit 5  
7794			;   LCD DB6 = Microcomputer output port bit 6  
7794			;   LCD DB7 = Microcomputer output port bit 7  
7794			; Display's R/W is connected to 0v so it is always in write mode  
7794			; All 6 connections must be on the same port address <kLCDPrt>  
7794			; This method also allows a decent length of cable from micro to LCD  
7794			;  
7794			; **********************************************************************  
7794			;  
7794			; To include the code for any given function provided by this module,   
7794			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
7794			; the parent source file.  
7794			; For example:  #REQUIRES   uHexPrefix  
7794			;  
7794			; Also #INCLUDE this file at some point after the #REQUIRES statements  
7794			; in the parent source file.  
7794			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
7794			;  
7794			; These are the function names provided by this module:  
7794			; fLCD_Init                     ;Initialise LCD  
7794			; fLCD_Inst                     ;Send instruction to LCD  
7794			; fLCD_Data                     ;Send data byte to LCD  
7794			; fLCD_Pos                      ;Position cursor  
7794			; fLCD_Str                      ;Display string  
7794			; fLCD_Def                      ;Define custom character  
7794			;  
7794			; **********************************************************************  
7794			;  
7794			; Requires SCMonAPI.asm to also be included in the project  
7794			;  
7794			  
7794			  
7794			; **********************************************************************  
7794			; **  Constants  
7794			; **********************************************************************  
7794			  
7794			; Constants that must be defined externally  
7794			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
7794			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
7794			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
7794			;kLCDWidth: EQU 20             ;Width in characters  
7794			  
7794			; general line offsets in any frame buffer  
7794			  
7794			  
7794			display_row_1: equ 0  
7794			display_row_2: equ display_row_1+display_cols  
7794			display_row_3: equ display_row_2 + display_cols  
7794			display_row_4: equ display_row_3 + display_cols  
7794			;display_row_4_eol:   
7794			  
7794			  
7794			; Cursor position values for the start of each line  
7794			  
7794			; E  
7794			kLCD_Line1: EQU 0x00   
7794			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
7794			; E1  
7794			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
7794			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
7794			  
7794			; Instructions to send as A register to fLCD_Inst  
7794			kLCD_Clear: EQU 00000001b     ;LCD clear  
7794			kLCD_Off:   EQU 00001000b     ;LCD off  
7794			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
7794			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
7794			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
7794			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
7794			  
7794			; Constants used by this code module  
7794			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
7794			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
7794			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
7794			  
7794			  
7794			  
7794			; **********************************************************************  
7794			; **  LCD support functions  
7794			; **********************************************************************  
7794			  
7794			; Initialise alphanumeric LCD module  
7794			; LCD control register codes:  
7794			;   DL   0 = 4-bit mode        1 = 8-bit mode  
7794			;   N    0 = 1-line mode       1 = 2-line mode  
7794			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
7794			;   D    0 = Display off       1 = Display on  
7794			;   C    0 = Cursor off        1 = Cursor on  
7794			;   B    0 = Blinking off      1 = Blinking on  
7794			;   ID   0 = Decrement mode    1 = Increment mode  
7794			;   SH   0 = Entire shift off  1 = Entire shift on  
7794 3e 28		fLCD_Init:  LD   A, 40  
7796 cd bb 78		            CALL LCDDelay       ;Delay 40ms after power up  
7799			; For reliable reset set 8-bit mode - 3 times  
7799 cd 8b 78		            CALL WrFn8bit       ;Function = 8-bit mode  
779c cd 8b 78		            CALL WrFn8bit       ;Function = 8-bit mode  
779f cd 8b 78		            CALL WrFn8bit       ;Function = 8-bit mode  
77a2			; Set 4-bit mode  
77a2 cd 87 78		            CALL WrFn4bit       ;Function = 4-bit mode  
77a5 cd b9 78		            CALL LCDDelay1      ;Delay 37 us or more  
77a8			; Function set  
77a8 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
77aa cd bd 77		            CALL fLCD_Inst      ;2 line, display on  
77ad			; Display On/Off control  
77ad 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
77af cd bd 77		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
77b2			; Display Clear  
77b2 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
77b4 cd bd 77		            CALL fLCD_Inst      ;Clear display  
77b7			; Entry mode  
77b7 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
77b9 cd bd 77		            CALL fLCD_Inst      ;Increment mode, shift off  
77bc			; Display module now initialised  
77bc c9			            RET  
77bd			; ok to here  
77bd			  
77bd			; Write instruction to LCD  
77bd			;   On entry: A = Instruction byte to be written  
77bd			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
77bd f5			fLCD_Inst:  PUSH AF  
77be f5			            PUSH AF  
77bf cd d1 77		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
77c2 f1			            POP  AF  
77c3 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
77c4 17			            RLA  
77c5 17			            RLA  
77c6 17			            RLA  
77c7 cd d1 77		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
77ca 3e 02		            LD   A, 2  
77cc cd bb 78		            CALL LCDDelay       ;Delay 2 ms to complete   
77cf f1			            POP  AF  
77d0 c9			            RET  
77d1			Wr4bits:   
77d1 f5					push af  
77d2 3a 06 fb				ld a, (display_lcde1e2)  
77d5 fe 00				cp 0     ; e  
77d7 20 10				jr nz, .wea2	  
77d9 f1					pop af  
77da e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
77dc d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77de cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
77e0 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
77e2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
77e4 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
77e6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77e8 c9			            RET  
77e9 f1			.wea2:		pop af  
77ea e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
77ec d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77ee cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
77f0 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
77f2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
77f4 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
77f6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77f8 c9			            RET  
77f9			  
77f9			  
77f9			; Write data to LCD  
77f9			;   On entry: A = Data byte to be written  
77f9			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
77f9 f5			fLCD_Data:  PUSH AF  
77fa f5			            PUSH AF  
77fb cd 0d 78		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
77fe f1			            POP  AF  
77ff 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7800 17			            RLA  
7801 17			            RLA  
7802 17			            RLA  
7803 cd 0d 78		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
7806 3e 96		            LD   A, 150  
7808 3d			Wait:      DEC  A              ;Wait a while to allow data   
7809 20 fd		            JR   NZ, Wait      ;  write to complete  
780b f1			            POP  AF  
780c c9			            RET  
780d			Wr4bitsa:     
780d f5					push af  
780e 3a 06 fb				ld a, (display_lcde1e2)  
7811 fe 00				cp 0     ; e1  
7813 20 16				jr nz, .we2	  
7815 f1					pop af  
7816 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7818 cb d7		            SET  kLCDBitRS, A  
781a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
781c cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
781e cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
7820 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7822 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
7824 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7826 cb 97		            RES  kLCDBitRS, A  
7828 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
782a c9			            RET  
782b f1			.we2:		pop af  
782c e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
782e cb d7		            SET  kLCDBitRS, A  
7830 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7832 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
7834 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
7836 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7838 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
783a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
783c cb 97		            RES  kLCDBitRS, A  
783e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7840 c9			            RET  
7841			  
7841			  
7841			; Position cursor to specified location  
7841			;   On entry: A = Cursor position  
7841			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7841 f5			fLCD_Pos:   PUSH AF  
7842					; at this point set the E1 or E2 flag depending on position  
7842			  
7842 c5					push bc  
7843			;		push af  
7843 06 00				ld b, 0  
7845 4f					ld c, a  
7846 3e 4f				ld a, kLCD_Line3-1  
7848 b7			 		or a      ;clear carry flag  
7849 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
784a 38 04				jr c, .pe1  
784c			  
784c					; E selection  
784c cb 80				res 0, b         ; bit 0 unset e  
784e			;		pop af    ; before line 3 so recover orig pos  
784e			;		ld c, a    ; save for poking back  
784e 18 06				jr .peset	          
7850			.pe1:          	; E2 selection  
7850 cb c0				set 0, b         ; bit 0 set e1  
7852 79					ld a, c  
7853 de 4f				sbc a, kLCD_Line3-1  
7855 4f					ld c, a	         ; save caculated offset  
7856			;		pop af     ; bin this original value now we have calculated form  
7856			  
7856			.peset:		; set bit  
7856 78					ld a, b  
7857 32 06 fb				ld (display_lcde1e2), a 	  
785a 79					ld a, c  
785b c1					pop bc  
785c			  
785c f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
785e cd bd 77		            CALL fLCD_Inst      ;Write instruction to LCD  
7861 f1			            POP  AF  
7862 c9			            RET  
7863			  
7863			  
7863			; Output text string to LCD  
7863			;   On entry: DE = Pointer to null terminated text string  
7863			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
7863 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
7864 b7			            OR   A              ;Null terminator?  
7865 c8			            RET  Z              ;Yes, so finished  
7866 cd f9 77		            CALL fLCD_Data      ;Write character to display  
7869 13			            INC  DE             ;Point to next character  
786a 18 f7		            JR   fLCD_Str       ;Repeat  
786c c9					ret  
786d			  
786d			; Define custom character  
786d			;   On entry: A = Character number (0 to 7)  
786d			;             DE = Pointer to character bitmap data  
786d			;   On exit:  A = Next character number  
786d			;             DE = Next location following bitmap  
786d			;             BC HL IX IY I AF' BC' DE' HL' preserved  
786d			; Character is   
786d c5			fLCD_Def:   PUSH BC  
786e f5			            PUSH AF  
786f 07			            RLCA                ;Calculate location  
7870 07			            RLCA                ;  for bitmap data  
7871 07			            RLCA                ;  = 8 x CharacterNumber  
7872 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
7874 cd bd 77		            CALL fLCD_Inst      ;Write instruction to LCD  
7877 06 00		            LD   B, 0  
7879 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
787a cd f9 77		            CALL fLCD_Data      ;Write byte to display  
787d 13			            INC  DE             ;Point to next byte  
787e 04			            INC  B              ;Count bytes  
787f cb 58		            BIT  3, B           ;Finish all 8 bytes?  
7881 28 f6		            JR   Z, Loop       ;No, so repeat  
7883 f1			            POP  AF  
7884 3c			            INC  A              ;Increment character number  
7885 c1			            POP  BC  
7886 c9			            RET  
7887			  
7887			  
7887			; **********************************************************************  
7887			; **  Private functions  
7887			; **********************************************************************  
7887			  
7887			; Write function to LCD  
7887			;   On entry: A = Function byte to be written  
7887			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7887 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
7889 18 02		            JR   WrFunc  
788b 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
788d f5			WrFunc:     PUSH AF  
788e f5					push af  
788f 3a 06 fb				ld a, (display_lcde1e2)  
7892 fe 00				cp 0     ; e1  
7894 20 0f				jr nz, .wfea2	  
7896 f1					pop af  
7897 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7899 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
789b cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
789d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
789f cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
78a1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
78a3 18 0d			jr .wfskip  
78a5 f1			.wfea2:		pop af  
78a6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
78a8 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
78aa cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
78ac d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
78ae cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
78b0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
78b2 3e 05		.wfskip:            LD  A, 5  
78b4 cd bb 78		            CALL LCDDelay       ;Delay 5 ms to complete  
78b7 f1			            POP  AF  
78b8 c9			            RET  
78b9			  
78b9			  
78b9			; Delay in milliseconds  
78b9			;   On entry: A = Number of milliseconds delay  
78b9			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
78b9 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
78bb d5			LCDDelay:   PUSH DE  
78bc 5f			            LD   E, A           ;Delay by 'A' ms  
78bd 16 00		            LD   D, 0  
78bf cd c3 0c		            CALL aDelayInMS  
78c2 d1			            POP  DE  
78c3 c9			            RET  
78c4			  
78c4			  
78c4			testlcd:  
78c4 3e 00			ld a, kLCD_Line1  
78c6 cd 41 78			call fLCD_Pos  
78c9 06 28			ld b, 40  
78cb 11 f9 78			ld de, .ttext1  
78ce cd 8c 77			call write_len_string  
78d1			  
78d1 3e 28			ld a, kLCD_Line2  
78d3 cd 41 78			call fLCD_Pos  
78d6 06 28			ld b, 40  
78d8 11 22 79			ld de, .ttext2  
78db cd 8c 77			call write_len_string  
78de 3e 50			ld a, kLCD_Line3  
78e0 cd 41 78			call fLCD_Pos  
78e3 06 28			ld b, 40  
78e5 11 4b 79			ld de, .ttext3  
78e8 cd 8c 77			call write_len_string  
78eb 3e 78			ld a, kLCD_Line4  
78ed cd 41 78			call fLCD_Pos  
78f0 06 28			ld b, 40  
78f2 11 74 79			ld de, .ttext4  
78f5 cd 8c 77			call write_len_string  
78f8			  
78f8 76				halt  
78f9			  
78f9			  
78f9 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
7922 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
794b .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
7974 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
799d			   
799d			  
799d			  
799d			; eof  
799d			  
# End of file firmware_lcd_4x40.asm
799d			;include "firmware_lcd_4x20.asm" 
799d			include "firmware_key_5x10.asm" 
799d			; 5 x 10 decade counter scanner  
799d			  
799d			  
799d			; TODO do cursor shape change for shift keys  
799d			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
799d			  
799d			  
799d			; bit mask for each scan column and row for teing the matrix  
799d			  
799d			  
799d			key_init:  
799d			  
799d			; SCMonAPI functions used  
799d			  
799d			; Alphanumeric LCD functions used  
799d			; no need to specify specific functions for this module  
799d			  
799d			  
799d 3e cf		            LD   A, 11001111b  
799f d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
79a1			;            LD   A, 00000000b  
79a1 3e 1f		            LD   A, 00011111b  
79a3 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
79a5			  
79a5			  
79a5				; TODO Configure cursor shapes  
79a5			  
79a5				; Load cursor shapes   
79a5 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
79a7 11 b7 79		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
79aa 06 02		            LD   B, 2           ;Number of characters to define  
79ac cd 6d 78		.DefLoop:   CALL fLCD_Def       ;Define custom character  
79af 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
79b1			  
79b1 3e 01				ld a, 1  
79b3 32 fc fa			ld (cursor_shape),a  
79b6 c9				ret  
79b7			  
79b7			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
79b7			; Up to 8 custom characters can be defined  
79b7			.cursor_shapes:      
79b7			;; Character 0x00 = Normal  
79b7 1f			            DB  11111b  
79b8 1f			            DB  11111b  
79b9 1f			            DB  11111b  
79ba 1f			            DB  11111b  
79bb 1f			            DB  11111b  
79bc 1f			            DB  11111b  
79bd 1f			            DB  11111b  
79be 1f			            DB  11111b  
79bf			;; Character 0x01 = Modifier  
79bf 1f			            DB  11111b  
79c0 1b			            DB  11011b  
79c1 1b			            DB  11011b  
79c2 1b			            DB  11011b  
79c3 1b			            DB  11011b  
79c4 1f			            DB  11111b  
79c5 1b			            DB  11011b  
79c6 1f			            DB  11111b  
79c7			  
79c7			  
79c7			  
79c7			  
79c7			; Display custom character 0  
79c7			;            LD   A, kLCD_Line1+14  
79c7			;            CALL fLCD_Pos       ;Position cursor to location in A  
79c7			;            LD   A, 0  
79c7			;            CALL fLCD_Data      ;Write character in A at cursor  
79c7			  
79c7			; Display custom character 1  
79c7			;            LD   A, kLCD_Line2+14  
79c7			;            CALL fLCD_Pos      ;Position cursor to location in A  
79c7			;            LD   A, 1  
79c7			;            CALL fLCD_Data     ;Write character in A at cursor  
79c7			  
79c7			; keyboard scanning   
79c7			  
79c7			; character in from keyboard  
79c7			  
79c7			; mapping for the pcb layout  
79c7			  
79c7			.matrix_to_char:  
79c7 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
79d2 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
79dd 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
79e8 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
79f3 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
79fe			.matrix_to_shift:  
79fe			  
79fe .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
7a09 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
7a14 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
7a1f 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
7a2a .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
7a35			  
7a35			.matrix_to_symbolshift:  
7a35			  
7a35 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
7a40 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
7a4b 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
7a56			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
7a56 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
7a61 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
7a6c			  
7a6c			  
7a6c			  
7a6c			; mapping for a simple straight through breadboard layout  
7a6c			  
7a6c			;.matrix_to_char:  
7a6c			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7a6c			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
7a6c			;		db "asdfghjkl",KEY_CR,0  
7a6c			;		db "qwertyuiop",0  
7a6c			;		 db "1234567890",0  
7a6c			;.matrix_to_shift:  
7a6c			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
7a6c			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
7a6c			;		db "ASDFGHJKL",KEY_CR,0  
7a6c			;		db "QWERTYUIOP",0  
7a6c			;		 db "!",'"',"#$%^&*()",0  
7a6c			;.matrix_to_symbolshift:  
7a6c			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7a6c			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
7a6c			;		db "_?*fghjk=",KEY_CR,0  
7a6c			;		db "-/+*[]{}@#",0  
7a6c			;		 db "1234567890",0  
7a6c			  
7a6c			;.matrix_to_char: db "D#0*C987B654A321"  
7a6c			  
7a6c			  
7a6c				  
7a6c			  
7a6c			; add cin and cin_wait  
7a6c			  
7a6c cd 7d 7a		cin_wait: 	call cin  
7a6f						if DEBUG_KEYCINWAIT  
7a6f							push af  
7a6f							  
7a6f							ld hl,key_repeat_ct  
7a6f							ld (hl),a  
7a6f							inc hl  
7a6f							call hexout  
7a6f							ld hl,key_repeat_ct+3  
7a6f							ld a,0  
7a6f							ld (hl),a  
7a6f			  
7a6f							    LD   A, kLCD_Line1+11  
7a6f							    CALL fLCD_Pos       ;Position cursor to location in A  
7a6f							    LD   DE, key_repeat_ct  
7a6f							    ;LD   DE, MsgHello  
7a6f							    CALL fLCD_Str       ;Display string pointed to by DE  
7a6f			  
7a6f			  
7a6f			  
7a6f							pop af  
7a6f						endif  
7a6f fe 00			cp 0  
7a71 28 f9			jr z, cin_wait   ; block until key press  
7a73			  
7a73							if DEBUG_KEYCINWAIT  
7a73								push af  
7a73			  
7a73								ld a, 'A'	  
7a73								ld hl,key_repeat_ct  
7a73								ld (hl),a  
7a73								inc hl  
7a73								ld a,0  
7a73								ld (hl),a  
7a73			  
7a73								    LD   A, kLCD_Line2+11  
7a73								    CALL fLCD_Pos       ;Position cursor to location in A  
7a73								    LD   DE, key_repeat_ct  
7a73								    ;LD   DE, MsgHello  
7a73								    CALL fLCD_Str       ;Display string pointed to by DE  
7a73			  
7a73							call delay500ms  
7a73			  
7a73								pop af  
7a73							endif  
7a73 f5				push af   ; save key pressed  
7a74			  
7a74			.cin_wait1:	  
7a74							if DEBUG_KEYCINWAIT  
7a74								push af  
7a74			  
7a74								ld a, 'b'	  
7a74								ld hl,key_repeat_ct  
7a74								ld (hl),a  
7a74								inc hl  
7a74								ld a,0  
7a74								ld (hl),a  
7a74			  
7a74								    LD   A, kLCD_Line2+11  
7a74								    CALL fLCD_Pos       ;Position cursor to location in A  
7a74								    LD   DE, key_repeat_ct  
7a74								    ;LD   DE, MsgHello  
7a74								    CALL fLCD_Str       ;Display string pointed to by DE  
7a74			  
7a74			  
7a74							call delay500ms  
7a74			  
7a74								pop af  
7a74							endif  
7a74			  
7a74 cd 7d 7a		call cin  
7a77 fe 00			cp 0  
7a79 20 f9			jr nz, .cin_wait1  	; wait for key release  
7a7b			if DEBUG_KEYCINWAIT  
7a7b				push af  
7a7b			  
7a7b				ld a, '3'	  
7a7b				ld hl,key_repeat_ct  
7a7b				ld (hl),a  
7a7b				inc hl  
7a7b				ld a,0  
7a7b				ld (hl),a  
7a7b			  
7a7b			            LD   A, kLCD_Line2+11  
7a7b			            CALL fLCD_Pos       ;Position cursor to location in A  
7a7b			            LD   DE, key_repeat_ct  
7a7b			            ;LD   DE, MsgHello  
7a7b			            CALL fLCD_Str       ;Display string pointed to by DE  
7a7b			  
7a7b			  
7a7b			call delay500ms  
7a7b			  
7a7b				pop af  
7a7b			endif  
7a7b			  
7a7b f1				pop af   ; get key  
7a7c c9				ret  
7a7d			  
7a7d			  
7a7d cd 91 7a		cin: 	call .mtoc  
7a80			  
7a80			if DEBUG_KEYCIN  
7a80				push af  
7a80				  
7a80				ld hl,key_repeat_ct  
7a80				ld (hl),a  
7a80				inc hl  
7a80				call hexout  
7a80				ld hl,key_repeat_ct+3  
7a80				ld a,0  
7a80				ld (hl),a  
7a80			  
7a80			            LD   A, kLCD_Line3+15  
7a80			            CALL fLCD_Pos       ;Position cursor to location in A  
7a80			            LD   DE, key_repeat_ct  
7a80			            ;LD   DE, MsgHello  
7a80			            CALL fLCD_Str       ;Display string pointed to by DE  
7a80			  
7a80			  
7a80			call delay500ms  
7a80			  
7a80				pop af  
7a80			endif  
7a80			  
7a80			  
7a80				; no key held  
7a80 fe 00			cp 0  
7a82 c8				ret z  
7a83			  
7a83			if DEBUG_KEYCIN  
7a83				push af  
7a83			  
7a83				ld a, '1'	  
7a83				ld hl,key_repeat_ct  
7a83				ld (hl),a  
7a83				inc hl  
7a83				ld a,0  
7a83				ld (hl),a  
7a83			  
7a83			            LD   A, kLCD_Line4+15  
7a83			            CALL fLCD_Pos       ;Position cursor to location in A  
7a83			            LD   DE, key_repeat_ct  
7a83			            ;LD   DE, MsgHello  
7a83			            CALL fLCD_Str       ;Display string pointed to by DE  
7a83			  
7a83			  
7a83			call delay500ms  
7a83			  
7a83				pop af  
7a83			endif  
7a83			  
7a83				; stop key bounce  
7a83			  
7a83 32 c6 fd			ld (key_held),a		 ; save it  
7a86 47				ld b, a  
7a87			  
7a87 c5			.cina1:	push bc  
7a88			if DEBUG_KEYCIN  
7a88				push af  
7a88			  
7a88				ld hl,key_repeat_ct  
7a88				inc hl  
7a88				call hexout  
7a88				ld hl,key_repeat_ct+3  
7a88				ld a,0  
7a88				ld (hl),a  
7a88				ld hl,key_repeat_ct  
7a88				ld a, '2'	  
7a88				ld (hl),a  
7a88			  
7a88			            LD   A, kLCD_Line4+15  
7a88			            CALL fLCD_Pos       ;Position cursor to location in A  
7a88			            LD   DE, key_repeat_ct  
7a88			            ;LD   DE, MsgHello  
7a88			            CALL fLCD_Str       ;Display string pointed to by DE  
7a88			  
7a88				pop af  
7a88			endif  
7a88 cd 91 7a			call .mtoc  
7a8b c1				pop bc  
7a8c b8				cp b  
7a8d 28 f8			jr z, .cina1  
7a8f 78				ld a,b		  
7a90			if DEBUG_KEYCIN  
7a90				push af  
7a90			  
7a90				ld hl,key_repeat_ct  
7a90				inc hl  
7a90				call hexout  
7a90				ld hl,key_repeat_ct+3  
7a90				ld a,0  
7a90				ld (hl),a  
7a90				ld hl,key_repeat_ct  
7a90				ld a, '3'	  
7a90				ld (hl),a  
7a90			  
7a90			            LD   A, kLCD_Line4+15  
7a90			            CALL fLCD_Pos       ;Position cursor to location in A  
7a90			            LD   DE, key_repeat_ct  
7a90			            ;LD   DE, MsgHello  
7a90			            CALL fLCD_Str       ;Display string pointed to by DE  
7a90			  
7a90				pop af  
7a90			endif  
7a90 c9				ret  
7a91			  
7a91			; detect keyboard modifier key press and apply new overlay to the face key held  
7a91			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
7a91			  
7a91			;.cin_map_modifier:   
7a91			;	ld a, (hl)  
7a91			;	and 255  
7a91			;	ret NZ		; modifier key not flagged  
7a91			;  
7a91			;	; get key face  
7a91			;  
7a91			;	ld b,(key_face_held)  
7a91			;  
7a91			;	ld b, key_cols * key_rows  
7a91			;  
7a91			;	push de  
7a91			;	pop hl  
7a91			;  
7a91			;.mmod1: ld a,(hl)   ; get map test  
7a91			;	cp b  
7a91			;	jr z, .mmod2  
7a91			;  
7a91			;  
7a91			;  
7a91			;.mmod2: inc hl    ;   
7a91			;  
7a91			;	  
7a91			;  
7a91			;	  
7a91			;  
7a91			;	ld hl,key_actual_pressed  
7a91			;	ld (hl),a,  
7a91			;	ret  
7a91			  
7a91			; map matrix key held to char on face of key  
7a91			  
7a91			.mtoc:  
7a91			  
7a91			; test decade counter strobes  
7a91			  
7a91			;.decadetest1:  
7a91			  
7a91			; reset counter  
7a91			;ld a, 128  
7a91			;out (portbdata),a  
7a91			  
7a91			  
7a91			;ld b, 5  
7a91			;.dec1:  
7a91			;ld a, 0  
7a91			;out (portbdata),a  
7a91			;call delay1s  
7a91			  
7a91			;ld a, 32  
7a91			;out (portbdata),a  
7a91			;call delay1s  
7a91			;call delay1s  
7a91			;call delay1s  
7a91			;  
7a91			;ld a, 64+32  
7a91			;out (portbdata),a  
7a91			;call delay1s  
7a91			;;djnz .dec1  
7a91			;  
7a91			;jp .decadetest1  
7a91			  
7a91			  
7a91			  
7a91			  
7a91			  
7a91			  
7a91			  
7a91			  
7a91			  
7a91			  
7a91				; scan keyboard matrix and generate raw scan map  
7a91 cd 24 7b			call matrix  
7a94			  
7a94				; reuse c bit 0 left modifer button - ie shift  
7a94			        ; reuse c bit 1 for right modifer button - ie symbol shift  
7a94				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
7a94			  
7a94 0e 00			ld c, 0  
7a96			  
7a96				; TODO set flags for modifer key presses   
7a96				; TODO do a search for modifer key...  
7a96			  
7a96				;ld hl,keyscan_table_row4  
7a96 21 25 fe			ld hl,keyscan_table_row2  
7a99			  
7a99 7e				ld a, (hl)  
7a9a fe 23			cp '#'  
7a9c 20 07			jr nz, .nextmodcheck  
7a9e cb c1			set 0, c  
7aa0 21 fe 79			ld hl, .matrix_to_shift  
7aa3 18 21			jr .dokeymap  
7aa5				; TODO for now igonre  
7aa5			.nextmodcheck:  
7aa5 21 1a fe			ld hl,keyscan_table_row3  
7aa8			  
7aa8 7e				ld a, (hl)  
7aa9 fe 23			cp '#'  
7aab 20 07			jr nz, .nextmodcheck2  
7aad cb c9			set 1, c   
7aaf 21 35 7a			ld hl, .matrix_to_symbolshift  
7ab2 18 12			jr .dokeymap  
7ab4			.nextmodcheck2:  
7ab4 21 2e fe			ld hl,keyscan_table_row2+9    ; right shift  
7ab7			  
7ab7 7e				ld a, (hl)  
7ab8 fe 23			cp '#'  
7aba 20 07			jr nz, .donemodcheck  
7abc cb c9			set 1, c   
7abe 21 fe 79			ld hl, .matrix_to_shift  
7ac1 18 03			jr .dokeymap  
7ac3			  
7ac3				; no modifer found so just map to normal keys  
7ac3				; get mtoc map matrix to respective keys  
7ac3			;	ld hl, .matrix_to_char  
7ac3			;	ld hl, .matrix_to_char  
7ac3			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7ac3			;	ld a, KEY_SHIFT  
7ac3			;	call findchar  
7ac3			;  
7ac3			;	; got offset to key modifer in b  
7ac3			;  
7ac3			;	ld hl,keyscan_table_row5  
7ac3			;  
7ac3			;	ld a,b  
7ac3			;	call addatohl  
7ac3			;	ld a,(hl)  
7ac3			;  
7ac3			;	cp '#'  
7ac3			;	jr nz, .nextmodcheck  
7ac3			;	set 0, c  
7ac3			;	ld hl, .matrix_to_char  
7ac3			;	jr .dokeymap  
7ac3			;	; TODO for now igonre  
7ac3			;.nextmodcheck:  
7ac3			;	ld hl, .matrix_to_symbolshift  
7ac3			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7ac3			;	ld a, KEY_SYMBOLSHIFT  
7ac3			;	call findchar  
7ac3			;  
7ac3			;  
7ac3			;	; got offset to key modifer in b  
7ac3			;  
7ac3			;	ld hl,keyscan_table_row5  
7ac3			;  
7ac3			;	ld a,b  
7ac3			;	call addatohl  
7ac3			;	ld a,(hl)  
7ac3			;  
7ac3			;	cp '#'  
7ac3			;	jr nz, .donemodcheck  
7ac3			;	set 1, c   
7ac3			;	ld hl, .matrix_to_symbolshift  
7ac3			;	jr .dokeymap  
7ac3			  
7ac3			  
7ac3			  
7ac3			.donemodcheck:  
7ac3				; no modifer found so just map to normal keys  
7ac3				; get mtoc map matrix to respective keys  
7ac3 21 c7 79			ld hl, .matrix_to_char  
7ac6			  
7ac6			.dokeymap:  
7ac6				;ld (key_fa), c   
7ac6 cd df 7a			call .mapkeys  
7ac9			  
7ac9			  
7ac9			if DEBUG_KEY  
7ac9			  
7ac9			; Display text on first line  
7ac9			            LD   A, kLCD_Line1  
7ac9			            CALL fLCD_Pos       ;Position cursor to location in A  
7ac9			            LD   DE, keyscan_table_row1  
7ac9			            ;LD   DE, MsgHello  
7ac9			            CALL fLCD_Str       ;Display string pointed to by DE  
7ac9			  
7ac9			; Display text on second line  
7ac9			            LD   A, kLCD_Line2  
7ac9			            CALL fLCD_Pos       ;Position cursor to location in A  
7ac9			            LD   DE, keyscan_table_row2  
7ac9			            CALL fLCD_Str       ;Display string pointed to by DE  
7ac9			            LD   A, kLCD_Line3  
7ac9			            CALL fLCD_Pos       ;Position cursor to location in A  
7ac9			            LD   DE, keyscan_table_row3  
7ac9			            CALL fLCD_Str       ;Display string pointed to by DE  
7ac9			            LD   A, kLCD_Line4  
7ac9			            CALL fLCD_Pos       ;Position cursor to location in A  
7ac9			            LD   DE, keyscan_table_row4  
7ac9			            CALL fLCD_Str       ;Display string pointed to by DE  
7ac9			            LD   A, kLCD_Line1+10  
7ac9			            CALL fLCD_Pos       ;Position cursor to location in A  
7ac9			            LD   DE, keyscan_table_row5  
7ac9			            CALL fLCD_Str       ;Display string pointed to by DE  
7ac9			  
7ac9				;call delay250ms  
7ac9			endif  
7ac9			;	jp testkey  
7ac9			  
7ac9			; get first char reported  
7ac9			  
7ac9 21 04 fe			ld hl,keyscan_table_row5  
7acc			  
7acc				;ld b, 46   ; 30 keys to remap + 8 nulls   
7acc 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7ace			.findkey:  
7ace 7e				ld a,(hl)  
7acf fe 00			cp 0  
7ad1 28 04			jr z, .nextkey  
7ad3 fe 7e			cp KEY_MATRIX_NO_PRESS  
7ad5 20 06			jr nz, .foundkey  
7ad7			.nextkey:  
7ad7 23				inc hl  
7ad8 10 f4			djnz .findkey  
7ada 3e 00			ld a,0  
7adc c9				ret  
7add			.foundkey:  
7add 7e				ld a,(hl)  
7ade c9				ret  
7adf				  
7adf			  
7adf			; convert the raw key map given hl for destination key  
7adf			.mapkeys:  
7adf 11 04 fe			ld de,keyscan_table_row5  
7ae2			  
7ae2 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7ae4			.remap:  
7ae4 1a				ld a,(de)  
7ae5 fe 23			cp '#'  
7ae7 20 02			jr nz, .remapnext  
7ae9				;CALLMONITOR  
7ae9 7e				ld a,(hl)  
7aea 12				ld (de),a  
7aeb			  
7aeb			  
7aeb			  
7aeb			.remapnext:  
7aeb 23				inc hl  
7aec 13				inc de  
7aed 10 f5			djnz .remap  
7aef				  
7aef c9				ret  
7af0			  
7af0			  
7af0			  
7af0			.mtocold2:  
7af0			  
7af0			;	; flag if key D is held down and remove from reporting  
7af0			;	ld bc, .key_map_fd    
7af0			;	ld hl, keyscan_table  
7af0			;	ld de, key_fd  
7af0			;	call .key_shift_hold  
7af0			;	cp 255  
7af0			;	jr z, .cinmap  
7af0			;	; flag if key C is held down and remove from reporting  
7af0			;	ld bc, .key_map_fc    
7af0			;	ld hl, keyscan_table+key_cols  
7af0			;	ld de, key_fc  
7af0			;	call .key_shift_hold  
7af0			;	cp 255  
7af0			;	jr z, .cinmap  
7af0			;	; flag if key B is held down and remove from reporting  
7af0			;	ld bc, .key_map_fb    
7af0			;	ld hl, keyscan_table+(key_cols*2)  
7af0			;	ld de, key_fb  
7af0			;	call .key_shift_hold  
7af0			;	cp 255  
7af0			;	jr z, .cinmap  
7af0			;	; flag if key A is held down and remove from reporting  
7af0			;	ld bc, .key_map_fa    
7af0			;	ld hl, keyscan_table+(key_cols*3)  
7af0			;	ld de, key_fa  
7af0			;	call .key_shift_hold  
7af0			;	cp 255  
7af0			;	jr z, .cinmap  
7af0			  
7af0 11 c7 79			ld de, .matrix_to_char  
7af3			  
7af3			  
7af3			.cinmap1:   
7af3				if DEBUG_KEY  
7af3			            LD   A, kLCD_Line4  
7af3			            CALL fLCD_Pos       ;Position cursor to location in A  
7af3					push de  
7af3			            LD   DE, keyscan_table  
7af3			            CALL fLCD_Str       ;Display string pointed to by DE  
7af3					pop de  
7af3				endif  
7af3			  
7af3				; scan key matrix table for any held key  
7af3			  
7af3				; de holds either the default matrix or one selected above  
7af3			  
7af3 21 d1 fd			ld hl, keyscan_table  
7af6 06 32			ld b,key_cols*key_rows  
7af8			  
7af8 7e			.cin11:	ld a,(hl)  
7af9 fe 23			cp '#'  
7afb 28 08			jr z, .cinhit1  
7afd 23				inc hl  
7afe 13				inc de  
7aff 05				dec b  
7b00 20 f6			jr nz, .cin11  
7b02				; no key found held  
7b02 3e 00			ld a,0  
7b04 c9				ret  
7b05 d5			.cinhit1: push de  
7b06 e1				pop hl  
7b07 7e				ld a,(hl)  
7b08 c9				ret  
7b09			  
7b09			; flag a control key is held   
7b09			; hl is key pin, de is flag indicator  
7b09			  
7b09			.key_shift_hold1:  
7b09 c5				push bc  
7b0a 3e 01			ld a, 1  
7b0c 32 fc fa			ld (cursor_shape),a  
7b0f 06 00			ld b, 0  
7b11 7e				ld a, (hl)  
7b12 fe 2e			cp '.'  
7b14 28 0a			jr z, .key_shift11  
7b16 06 ff			ld b, 255  
7b18 3e 2b			ld a, '+'    ; hide key from later scans  
7b1a 77				ld (hl),a  
7b1b 3e 02			ld a, 2  
7b1d 32 fc fa			ld (cursor_shape),a  
7b20			.key_shift11:  
7b20				; write flag indicator  
7b20 78				ld a,b  
7b21 12				ld (de),a  
7b22			  
7b22 d1				pop de    ; de now holds the key map ptr  
7b23 c9				ret  
7b24			  
7b24				  
7b24			  
7b24			; scans keyboard matrix and flags key press in memory array	  
7b24				  
7b24			matrix:  
7b24				;call matrix  
7b24				; TODO optimise the code....  
7b24			  
7b24			  
7b24			;ld hl, keyscan_table_row1  
7b24			;ld de, keyscan_table_row1+1  
7b24			;ld bc,46  
7b24			;ld a,KEY_MATRIX_NO_PRESS  
7b24			;ldir  
7b24			  
7b24			  
7b24			  
7b24			; reset counter  
7b24 3e 80		ld a, 128  
7b26 d3 c1		out (portbdata),a  
7b28			  
7b28 06 0a		ld b, 10  
7b2a 0e 00		ld c, 0       ; current clock toggle  
7b2c			  
7b2c			.colscan:  
7b2c			  
7b2c			; set current column  
7b2c			; disable clock enable and set clock low  
7b2c			  
7b2c			;ld a, 0  
7b2c			;out (portbdata),a  
7b2c			  
7b2c			; For each column scan for switches  
7b2c			  
7b2c c5			push bc  
7b2d 21 c7 fd		ld hl, keyscan_scancol  
7b30 cd 39 7c		call .rowscan  
7b33 c1			pop bc  
7b34			  
7b34			  
7b34			; get back current column  
7b34			  
7b34			; translate the row scan  
7b34			  
7b34			;   
7b34			; row 1  
7b34			  
7b34 78			ld a,b  
7b35			  
7b35 21 3a fe		LD   hl, keyscan_table_row1+10  
7b38			  
7b38 cd e1 0f		call subafromhl  
7b3b			;call addatohl  
7b3b			  
7b3b 11 c7 fd		ld de, keyscan_scancol  
7b3e			  
7b3e 1a			ld a,(de)  
7b3f 77			ld (hl),a  
7b40			  
7b40			  
7b40			  
7b40			  
7b40			; row 2  
7b40			  
7b40 78			ld a,b  
7b41			  
7b41 21 2f fe		LD   hl, keyscan_table_row2+10  
7b44			  
7b44			;call addatohl  
7b44 cd e1 0f		call subafromhl  
7b47			  
7b47			  
7b47 11 c8 fd		ld de, keyscan_scancol+1  
7b4a			  
7b4a 1a			ld a,(de)  
7b4b 77			ld (hl),a  
7b4c			  
7b4c			  
7b4c			; row 3  
7b4c			  
7b4c 78			ld a,b  
7b4d			  
7b4d 21 24 fe		LD   hl, keyscan_table_row3+10  
7b50			  
7b50			;call addatohl  
7b50 cd e1 0f		call subafromhl  
7b53			  
7b53 11 c9 fd		ld de, keyscan_scancol+2  
7b56			  
7b56 1a			ld a,(de)  
7b57 77			ld (hl),a  
7b58			  
7b58			  
7b58			  
7b58			; row 4  
7b58			  
7b58 78			ld a,b  
7b59			  
7b59 21 19 fe		LD   hl, keyscan_table_row4+10  
7b5c			  
7b5c			;call addatohl  
7b5c cd e1 0f		call subafromhl  
7b5f			  
7b5f 11 ca fd		ld de, keyscan_scancol+3  
7b62			  
7b62 1a			ld a,(de)  
7b63 77			ld (hl),a  
7b64			  
7b64			; row 5  
7b64			  
7b64 78			ld a,b  
7b65			  
7b65 21 0e fe		LD   hl, keyscan_table_row5+10  
7b68			  
7b68			;call addatohl  
7b68 cd e1 0f		call subafromhl  
7b6b			  
7b6b 11 cb fd		ld de, keyscan_scancol+4  
7b6e			  
7b6e 1a			ld a,(de)  
7b6f 77			ld (hl),a  
7b70			  
7b70			; handshake next column  
7b70			  
7b70			  
7b70 3e 40		ld a, 64  
7b72 d3 c1		out (portbdata),a  
7b74			  
7b74 3e 00		ld a, 0  
7b76 d3 c1		out (portbdata),a  
7b78			  
7b78			; toggle clk and move to next column  
7b78			;ld a, 64  
7b78			;cp c  
7b78			;  
7b78			;jr z, .coltoglow  
7b78			;ld c, a  
7b78			;jr .coltog  
7b78			;.coltoglow:  
7b78			;ld c, 0  
7b78			;.coltog:  
7b78			;ld a, c  
7b78			;out (portbdata),a  
7b78			  
7b78 10 b2		djnz .colscan  
7b7a			  
7b7a 3e 0a		ld a,10  
7b7c 21 30 fe		LD   hl, keyscan_table_row1  
7b7f cd cf 0f		call addatohl  
7b82 3e 00		ld a, 0  
7b84 77			ld (hl), a  
7b85			  
7b85			  
7b85 3e 0a		ld a,10  
7b87 21 25 fe		LD   hl, keyscan_table_row2  
7b8a cd cf 0f		call addatohl  
7b8d 3e 00		ld a, 0  
7b8f 77			ld (hl), a  
7b90			  
7b90 3e 0a		ld a,10  
7b92 21 1a fe		LD   hl, keyscan_table_row3  
7b95 cd cf 0f		call addatohl  
7b98 3e 00		ld a, 0  
7b9a 77			ld (hl), a  
7b9b			  
7b9b 3e 0a		ld a,10  
7b9d 21 0f fe		LD   hl, keyscan_table_row4  
7ba0 cd cf 0f		call addatohl  
7ba3 3e 00		ld a, 0  
7ba5 77			ld (hl), a  
7ba6			  
7ba6 3e 0a		ld a,10  
7ba8 21 04 fe		LD   hl, keyscan_table_row5  
7bab cd cf 0f		call addatohl  
7bae 3e 00		ld a, 0  
7bb0 77			ld (hl), a  
7bb1			  
7bb1			if DEBUG_KEY_MATRIX  
7bb1			  
7bb1			; Display text on first line  
7bb1			            LD   A, kLCD_Line1  
7bb1			            CALL fLCD_Pos       ;Position cursor to location in A  
7bb1			            LD   DE, keyscan_table_row1  
7bb1			            ;LD   DE, MsgHello  
7bb1			            CALL fLCD_Str       ;Display string pointed to by DE  
7bb1			  
7bb1			; Display text on second line  
7bb1			            LD   A, kLCD_Line2  
7bb1			            CALL fLCD_Pos       ;Position cursor to location in A  
7bb1			            LD   DE, keyscan_table_row2  
7bb1			            CALL fLCD_Str       ;Display string pointed to by DE  
7bb1			            LD   A, kLCD_Line3  
7bb1			            CALL fLCD_Pos       ;Position cursor to location in A  
7bb1			            LD   DE, keyscan_table_row3  
7bb1			            CALL fLCD_Str       ;Display string pointed to by DE  
7bb1			            LD   A, kLCD_Line4  
7bb1			            CALL fLCD_Pos       ;Position cursor to location in A  
7bb1			            LD   DE, keyscan_table_row4  
7bb1			            CALL fLCD_Str       ;Display string pointed to by DE  
7bb1			            LD   A, kLCD_Line4+10  
7bb1			            CALL fLCD_Pos       ;Position cursor to location in A  
7bb1			            LD   DE, keyscan_table_row5  
7bb1			            CALL fLCD_Str       ;Display string pointed to by DE  
7bb1			  
7bb1			;call delay250ms  
7bb1				jp matrix  
7bb1			endif  
7bb1 c9			ret  
7bb2			  
7bb2			; using decade counter....  
7bb2			  
7bb2			  
7bb2			; TODO reset decade counter to start of scan  
7bb2			  
7bb2			; reset 15  
7bb2			; clock 14  
7bb2			; ce 13  
7bb2			  
7bb2			; 1 - q5  
7bb2			; 2 - q1  
7bb2			; 3 - q0  
7bb2			; 4 - q2  
7bb2			; 5 - q6  
7bb2			; 6 - q7  
7bb2			; 7 - q3  
7bb2			; 8 - vss  
7bb2			; 9 - q8  
7bb2			; 10 - q4  
7bb2			; 11 - q9  
7bb2			; 12 - cout  
7bb2			; 16 - vdd  
7bb2			  
7bb2			; clock      ce       reset     output  
7bb2			; 0          x        0         n  
7bb2			; x          1        0         n  
7bb2			; x          x        1         q0  
7bb2			; rising     0        0         n+1  
7bb2			; falling    x        0         n  
7bb2			; x          rising   0         n  
7bb2			; 1          falling  0         x+1  
7bb2			;  
7bb2			; x = dont care, if n < 5 carry = 1 otherwise 0  
7bb2			  
7bb2			;   
7bb2			; reset   
7bb2			; 13=0, 14=0, 15=1 .. 15=0  
7bb2			;  
7bb2			; handshake line  
7bb2			; 14=1.... read line 14=0  
7bb2			  
7bb2			  
7bb2			  
7bb2			  
7bb2			  
7bb2			; TODO hand shake clock for next column scan  
7bb2			; TODO detect each row  
7bb2			  
7bb2			  
7bb2			  
7bb2			  
7bb2			; reset 128  
7bb2			; clock 64  
7bb2			; ce 32  
7bb2			  
7bb2			  
7bb2			.cyclestart:  
7bb2			  
7bb2			; reset counter  
7bb2 3e 80		ld a, 128  
7bb4 d3 c1		out (portbdata),a  
7bb6			  
7bb6			; loop leds  
7bb6 06 0a		ld b,10  
7bb8			  
7bb8			.cycle1:  
7bb8 c5			push bc  
7bb9 3e 00		ld a, 0  
7bbb d3 c1		out (portbdata),a  
7bbd cd d2 0c		call delay250ms  
7bc0			  
7bc0 3e 40		ld a, 64  
7bc2 d3 c1		out (portbdata),a  
7bc4 cd d2 0c		call delay250ms  
7bc7			  
7bc7 3e 00		ld a, 0  
7bc9 d3 c1		out (portbdata),a  
7bcb cd d2 0c		call delay250ms  
7bce			  
7bce c1			pop bc  
7bcf 10 e7		djnz .cycle1  
7bd1			  
7bd1			  
7bd1 18 df		jr .cyclestart  
7bd3			  
7bd3			  
7bd3			  
7bd3			  
7bd3			  
7bd3			  
7bd3			  
7bd3			  
7bd3			  
7bd3			; map matrix key held to char on face of key  
7bd3			  
7bd3			;.mtocold:  
7bd3			;  
7bd3			;  
7bd3			;; reset counter  
7bd3			;ld a, 128  
7bd3			;out (portbdata),a  
7bd3			;  
7bd3			;  
7bd3			;; scan keyboard row 1  
7bd3			;ld a, 0  
7bd3			;out (portbdata),a  
7bd3			;;ld a, 64  
7bd3			;;out (portbdata),a  
7bd3			;  
7bd3			;  
7bd3			;	ld a, 128  
7bd3			;	ld hl, keyscan_table  
7bd3			;	call .rowscan  
7bd3			;  
7bd3			;;ld a, 0  
7bd3			;;out (portbdata),a  
7bd3			;ld a, 64  
7bd3			;out (portbdata),a  
7bd3			;  
7bd3			;	ld a, 64  
7bd3			;	ld hl, keyscan_table+key_cols  
7bd3			;	call .rowscan  
7bd3			;  
7bd3			;ld a, 0  
7bd3			;out (portbdata),a  
7bd3			;;ld a, 64  
7bd3			;;out (portbdata),a  
7bd3			;	ld a, 32  
7bd3			;	ld hl, keyscan_table+(key_cols*2)  
7bd3			;	call .rowscan  
7bd3			;  
7bd3			;  
7bd3			;;ld a, 0  
7bd3			;;out (portbdata),a  
7bd3			;ld a, 64  
7bd3			;out (portbdata),a  
7bd3			;  
7bd3			;	ld a, 16  
7bd3			;	ld hl, keyscan_table+(key_cols*3)  
7bd3			;	call .rowscan  
7bd3			;  
7bd3			;  
7bd3			;	; flag if key D is held down and remove from reporting  
7bd3			;	ld bc, .key_map_fd    
7bd3			;	ld hl, keyscan_table  
7bd3			;	ld de, key_fd  
7bd3			;	call .key_shift_hold  
7bd3			;	cp 255  
7bd3			;	jr z, .cinmap  
7bd3			;	; flag if key C is held down and remove from reporting  
7bd3			;	ld bc, .key_map_fc    
7bd3			;	ld hl, keyscan_table+key_cols  
7bd3			;	ld de, key_fc  
7bd3			;	call .key_shift_hold  
7bd3			;	cp 255  
7bd3			;	jr z, .cinmap  
7bd3			;	; flag if key B is held down and remove from reporting  
7bd3			;	ld bc, .key_map_fb    
7bd3			;	ld hl, keyscan_table+(key_cols*2)  
7bd3			;	ld de, key_fb  
7bd3			;	call .key_shift_hold  
7bd3			;	cp 255  
7bd3			;	jr z, .cinmap  
7bd3			;	; flag if key A is held down and remove from reporting  
7bd3			;	ld bc, .key_map_fa    
7bd3			;	ld hl, keyscan_table+(key_cols*3)  
7bd3			;	ld de, key_fa  
7bd3			;	call .key_shift_hold  
7bd3			;	cp 255  
7bd3			;	jr z, .cinmap  
7bd3			;  
7bd3			;	ld de, .matrix_to_char  
7bd3			;  
7bd3			;  
7bd3			;.cinmap:   
7bd3			;	if DEBUG_KEY  
7bd3			;            LD   A, kLCD_Line4  
7bd3			;            CALL fLCD_Pos       ;Position cursor to location in A  
7bd3			;		push de  
7bd3			;            LD   DE, keyscan_table  
7bd3			;            CALL fLCD_Str       ;Display string pointed to by DE  
7bd3			;		pop de  
7bd3			;	endif  
7bd3			  
7bd3				; scan key matrix table for any held key  
7bd3			  
7bd3				; de holds either the default matrix or one selected above  
7bd3			  
7bd3			;	ld hl, keyscan_table  
7bd3			;	ld b,key_cols*key_rows  
7bd3			;  
7bd3			;.cin1:	ld a,(hl)  
7bd3			;	cp '#'  
7bd3			;	jr z, .cinhit  
7bd3			;	inc hl  
7bd3			;	inc de  
7bd3			;	dec b  
7bd3			;	jr nz, .cin1  
7bd3			;	; no key found held  
7bd3			;	ld a,0  
7bd3			;	ret  
7bd3			;.cinhit: push de  
7bd3			;	pop hl  
7bd3			;	ld a,(hl)  
7bd3			;	ret  
7bd3			  
7bd3			; flag a control key is held   
7bd3			; hl is key pin, de is flag indicator  
7bd3			  
7bd3			;.key_shift_hold:  
7bd3			;	push bc  
7bd3			;	ld a, 1  
7bd3			;	ld (cursor_shape),a  
7bd3			;	ld b, 0  
7bd3			;	ld a, (hl)  
7bd3			;	cp '.'  
7bd3			;	jr z, .key_shift1  
7bd3			;	ld b, 255  
7bd3			;	ld a, '+'    ; hide key from later scans  
7bd3			;	ld (hl),a  
7bd3			;	ld a, 2  
7bd3			;	ld (cursor_shape),a  
7bd3			;.key_shift1:  
7bd3			;	; write flag indicator  
7bd3			;	ld a,b  
7bd3			;	ld (de),a  
7bd3			;  
7bd3			;	pop de    ; de now holds the key map ptr  
7bd3			;	ret  
7bd3			  
7bd3				  
7bd3				  
7bd3			  
7bd3			  
7bd3			  
7bd3			  
7bd3			  
7bd3			  
7bd3			  
7bd3			  
7bd3			  
7bd3			  
7bd3			  
7bd3			;	push hl  
7bd3			;	push de  
7bd3			;	push bc  
7bd3			;	call keyscan  
7bd3			;	; map key matrix to ascii value of key face  
7bd3			;  
7bd3			;	ld hl, key_face_map  
7bd3			;	ld de, keyscan_table  
7bd3			;  
7bd3			;	; get how many keys to look at  
7bd3			;	ld b, keyscan_table_len  
7bd3			;	  
7bd3			;  
7bd3			;	; at this stage fall out on first key hit  
7bd3			;	; TODO handle multiple key press  
7bd3			;  
7bd3			;map1:	ld a,(hl)  
7bd3			;	cp '#'  
7bd3			;	jr z, keyhit  
7bd3			;	inc hl  
7bd3			;	inc de  
7bd3			;	dec b  
7bd3			;	jr nz, map1  
7bd3			;nohit:	ld a, 0  
7bd3			;	jr keydone  
7bd3			;keyhit: push de  
7bd3			;	pop hl  
7bd3			;	ld a,(hl)  
7bd3			;keydone:  
7bd3			;	push bc  
7bd3			;	push de  
7bd3			; 	push hl  
7bd3			;	ret   
7bd3			;  
7bd3			  
7bd3			  
7bd3			  
7bd3			  
7bd3			; scan physical key matrix  
7bd3			  
7bd3			  
7bd3			;keyscan:  
7bd3			;  
7bd3			;; for each key_row use keyscanr bit mask for out  
7bd3			;; then read in for keyscanc bitmask  
7bd3			;; save result of row scan to keyscantable  
7bd3			;  
7bd3			;; scan keyboard row 1  
7bd3			;  
7bd3			;	ld b, key_rows  
7bd3			;	ld hl, key_scanr  
7bd3			;	ld de, keyscan_table  
7bd3			;  
7bd3			;rowloop:  
7bd3			;  
7bd3			;	ld a,(hl)		; out bit mask to energise keyboard row  
7bd3			;	call rowscan  
7bd3			;	inc hl  
7bd3			;	dec b  
7bd3			;	jr nz, rowloop  
7bd3			;  
7bd3			;	ret  
7bd3			;  
7bd3			;  
7bd3			;; pass a out bitmask, b row number  
7bd3			;arowscan:   
7bd3			;	push bc  
7bd3			;  
7bd3			;	ld d, b  
7bd3			;  
7bd3			;	; calculate buffer location for this row  
7bd3			;  
7bd3			;	ld hl, keyscan_table	  
7bd3			;kbufr:  ld e, key_cols  
7bd3			;kbufc:	inc hl  
7bd3			;	dec e  
7bd3			;	jr nz, kbufc  
7bd3			;	dec d  
7bd3			;	jr nz, kbufr  
7bd3			;  
7bd3			;	; energise row and read columns  
7bd3			;  
7bd3			;	out (portbdata),a  
7bd3			;	in a,(portbdata)  
7bd3			;	ld c,a  
7bd3			;  
7bd3			;  
7bd3			;	; save buffer loc  
7bd3			;  
7bd3			;	ld (keybufptr), hl  
7bd3			;  
7bd3			;	ld hl, key_scanc  
7bd3			;	ld d, key_cols  
7bd3			;  
7bd3			;	; for each column check each bit mask  
7bd3			;  
7bd3			;colloop:  
7bd3			;	  
7bd3			;  
7bd3			;	; reset flags for the row   
7bd3			;  
7bd3			;	ld b,'.'  
7bd3			;	and (hl)  
7bd3			;	jr z, maskskip  
7bd3			;	ld b,'#'  
7bd3			;maskskip:  
7bd3			;	; save  key state  
7bd3			;	push hl  
7bd3			;	ld hl, (keybufptr)  
7bd3			;	ld (hl), b  
7bd3			;	inc hl  
7bd3			;	ld (keybufptr), hl  
7bd3			;  
7bd3			;	; move to next bit mask  
7bd3			;	pop hl  
7bd3			;	inc hl  
7bd3			;  
7bd3			;	dec d  
7bd3			;	jr nz, colloop  
7bd3			;  
7bd3			;	ret  
7bd3			;  
7bd3			;  
7bd3			;;  
7bd3			; lcd functions  
7bd3			;  
7bd3			;  
7bd3			  
7bd3			;if DEBUG_KEY_MATRIX  
7bd3			  
7bd3			; test function to display hardware view of matrix state  
7bd3			  
7bd3			matrixold:  
7bd3			  
7bd3			  
7bd3			  
7bd3			; reset counter  
7bd3 3e 80		ld a, 128  
7bd5 d3 c1		out (portbdata),a  
7bd7			; scan keyboard row 1  
7bd7 3e 00		ld a, 0  
7bd9 d3 c1		out (portbdata),a  
7bdb			;ld a, 64  
7bdb			;out (portbdata),a  
7bdb 3e 80			ld a, 128  
7bdd 21 30 fe			ld hl, keyscan_table_row1  
7be0 cd 39 7c			call .rowscan  
7be3			  
7be3			;ld a, 0  
7be3			;out (portbdata),a  
7be3 3e 40		ld a, 64  
7be5 d3 c1		out (portbdata),a  
7be7 3e 40			ld a, 64  
7be9 21 25 fe			ld hl, keyscan_table_row2  
7bec cd 39 7c			call .rowscan  
7bef			  
7bef 3e 00		ld a, 0  
7bf1 d3 c1		out (portbdata),a  
7bf3			;ld a, 64  
7bf3			;out (portbdata),a  
7bf3 3e 20			ld a, 32  
7bf5 21 1a fe			ld hl, keyscan_table_row3  
7bf8 cd 39 7c			call .rowscan  
7bfb			  
7bfb			;ld a, 0  
7bfb			;out (portbdata),a  
7bfb 3e 40		ld a, 64  
7bfd d3 c1		out (portbdata),a  
7bff 3e 10			ld a, 16  
7c01 21 0f fe			ld hl, keyscan_table_row4  
7c04 cd 39 7c			call .rowscan  
7c07			  
7c07			; Display text on first line  
7c07 3e 00		            LD   A, kLCD_Line1  
7c09 cd 41 78		            CALL fLCD_Pos       ;Position cursor to location in A  
7c0c 11 30 fe		            LD   DE, keyscan_table_row1  
7c0f			            ;LD   DE, MsgHello  
7c0f cd 63 78		            CALL fLCD_Str       ;Display string pointed to by DE  
7c12			  
7c12			; Display text on second line  
7c12 3e 28		            LD   A, kLCD_Line2  
7c14 cd 41 78		            CALL fLCD_Pos       ;Position cursor to location in A  
7c17 11 25 fe		            LD   DE, keyscan_table_row2  
7c1a cd 63 78		            CALL fLCD_Str       ;Display string pointed to by DE  
7c1d 3e 50		            LD   A, kLCD_Line3  
7c1f cd 41 78		            CALL fLCD_Pos       ;Position cursor to location in A  
7c22 11 1a fe		            LD   DE, keyscan_table_row3  
7c25 cd 63 78		            CALL fLCD_Str       ;Display string pointed to by DE  
7c28 3e 78		            LD   A, kLCD_Line4  
7c2a cd 41 78		            CALL fLCD_Pos       ;Position cursor to location in A  
7c2d 11 0f fe		            LD   DE, keyscan_table_row4  
7c30 cd 63 78		            CALL fLCD_Str       ;Display string pointed to by DE  
7c33			  
7c33 cd d2 0c			call delay250ms  
7c36 c3 24 7b			jp matrix  
7c39			  
7c39			; pass de as row display flags  
7c39			.rowscan:   
7c39			;	out (portbdata),a  
7c39 db c1			in a,(portbdata)  
7c3b 4f				ld c,a  
7c3c				; reset flags for the row   
7c3c 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7c3e e6 01			and 1  
7c40 28 02			jr z, .p1on  
7c42 06 23			ld b,'#'  
7c44			.p1on:  
7c44 70				ld (hl), b  
7c45 23				inc hl  
7c46			  
7c46 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7c48 79				ld a,c  
7c49 e6 02			and 2  
7c4b			;	bit 0,a  
7c4b 28 02			jr z, .p2on  
7c4d 06 23			ld b,'#'  
7c4f			.p2on:  
7c4f 70				ld (hl), b  
7c50 23				inc hl  
7c51			;  
7c51 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7c53 79				ld a,c  
7c54 e6 04			and 4  
7c56			;;	bit 0,a  
7c56 28 02			jr z, .p3on  
7c58 06 23			ld b,'#'  
7c5a			.p3on:  
7c5a 70				ld (hl), b  
7c5b 23				inc hl  
7c5c			;;  
7c5c 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7c5e			;;	bit 0,a  
7c5e 79				ld a,c  
7c5f e6 08			and 8  
7c61 28 02			jr z, .p4on  
7c63 06 23			ld b,'#'  
7c65			.p4on:  
7c65 70				ld (hl), b  
7c66 23				inc hl  
7c67			  
7c67 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7c69			;;	bit 0,a  
7c69 79				ld a,c  
7c6a e6 10			and 16  
7c6c 28 02			jr z, .p5on  
7c6e 06 23			ld b,'#'  
7c70			.p5on:  
7c70 70				ld (hl), b  
7c71 23				inc hl  
7c72			; zero term  
7c72 06 00			ld b,0  
7c74 70				ld (hl), b  
7c75			  
7c75 c9			.rscandone: ret  
7c76			  
7c76			;addatohl:  
7c76			;  
7c76			 ;add   a, l    ; A = A+L  
7c76			  ;  ld    l, a    ; L = A+L  
7c76			   ; adc   a, h    ; A = A+L+H+carry  
7c76			   ; sub   l       ; A = H+carry  
7c76			   ; ld    h, a    ; H = H+carry  
7c76			  
7c76			;ret  
7c76			; eof  
# End of file firmware_key_5x10.asm
7c76			;include "firmware_key_4x10.asm" 
7c76			 
7c76			heap_size:    equ heap_end - heap_start 
7c76			;eof 
# End of file os_mega.asm
7c76
