# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 3b 18			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $3c holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_AUTOEFILE: equ $21  
0003			STORE_0_BANKRUN: equ $23  
0003			STORE_0_FILERUN: equ $24  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $20  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 c3 fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 02 fb				ld hl, display_fb1  
000b 22 5e fa				ld (display_fb_active), hl  
000e			  
000e cd d2 0a				call clear_display  
0011			  
0011 21 60 fa				ld hl, display_fb2  
0014 22 5e fa				ld (display_fb_active), hl  
0017			  
0017 cd d2 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 53 fb				ld hl, display_fb0  
001d 22 5e fa				ld (display_fb_active), hl  
0020			  
0020 cd d2 0a				call clear_display  
0023			  
0023			  
0023 cd 81 64				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd ca 65			call key_init  
0029 cd c9 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd a9 11				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f					call sound_init  
002f				endif  
002f			  
002f				; lcd test sequence  
002f					  
002f cd f5 0a			call update_display  
0032 cd 52 0a			call delay1s  
0035 3e 2b			ld a,'+'  
0037 cd d7 0a			call fill_display  
003a cd f5 0a			call update_display  
003d cd 52 0a			call delay1s  
0040 3e 2a			ld a,'*'  
0042 cd d7 0a			call fill_display  
0045 cd f5 0a			call update_display  
0048 cd 52 0a			call delay1s  
004b 3e 2d			ld a,'-'  
004d cd d7 0a			call fill_display  
0050 cd f5 0a			call update_display  
0053 cd 52 0a			call delay1s  
0056			  
0056			; boot splash screen  
0056			if display_cols == 20	  
0056 3e 00		        ld a, display_row_1    
0058			else  
0058			        ld a, display_row_1 +10   
0058			endif  
0058 11 89 00			ld de, bootmsg  
005b cd e5 0a			call str_at_display  
005e cd f5 0a			call update_display  
0061			  
0061			  
0061 cd 52 0a			call delay1s  
0064 cd 52 0a			call delay1s  
0067			if display_cols == 20	  
0067 3e 2a		            LD   A, display_row_3+2  
0069			else  
0069			            LD   A, display_row_3+12  
0069			endif  
0069 11 9e 00			ld de, bootmsg1  
006c cd e5 0a			call str_at_display  
006f cd f5 0a			call update_display  
0072 cd 52 0a			call delay1s  
0075 cd 52 0a			call delay1s  
0078			  
0078			;	ld a, display_row_4+3  
0078			;	ld de, bootmsg2  
0078			;	call str_at_display  
0078			;	call update_display  
0078			;	call delay1s  
0078			;	call delay1s  
0078			  
0078			; debug mark setup  
0078			  
0078 3e 5f		ld a, '_'  
007a 32 bd fb		ld (debug_mark),a  
007d 32 be fb		ld (debug_mark+1),a  
0080 32 bf fb		ld (debug_mark+2),a  
0083 3e 00		ld a,0  
0085 32 c0 fb		ld (debug_mark+3),a  
0088			  
0088 c9					ret  
0089			  
0089			  
0089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
009e .. 00		bootmsg1:	db "by Kevin Groves",0  
00ae			;bootmsg2:	db "Firmware v0.1",0  
00ae			  
00ae			; a 4x20 lcd  
00ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00ae			  
00ae			;if display_cols == 20  
00ae			;	include "firmware_lcd_4x20.asm"  
00ae			;endif  
00ae			  
00ae			;if display_cols == 40  
00ae			;	include "firmware_lcd_4x40.asm"  
00ae			;endif  
00ae			  
00ae			;  
00ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00ae			; TODO abstract the bit bang video out interface for dual display  
00ae			; TODO wire video out to tx pin on rc2014 bus  
00ae			  
00ae			; must supply cin, and cin_wait for low level hardware abstraction   
00ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00ae			; test scancode  
00ae			  
00ae			;;;;;  
00ae			;;;  
00ae			; Moved out to mini and maxi versions  
00ae			;  
00ae			; include "firmware_key_4x4.asm"  
00ae			; using existing 4 wire x 4 resistor array for input  
00ae			;include "firmware_key_4x10.asm"  
00ae			; need to mod the board for 5 rows due to resistor array  
00ae			;include "firmware_key_5x10.asm"  
00ae			  
00ae			; storage hardware interface  
00ae			  
00ae			; use microchip serial eeprom for storage  
00ae			  
00ae			  
00ae			if STORAGE_SE  
00ae				include "firmware_spi.asm"  
00ae			; my spi protocol (used by storage) 
00ae			 
00ae			; SPI pins 
00ae			 
00ae			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00ae			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00ae			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00ae			 
00ae			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00ae			; chip pin 4 gnd 
00ae			 
00ae			 
00ae			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00ae			SPI_CE1: equ 1      ;    port a1 pin 14  
00ae			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00ae			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00ae			SPI_CE4: equ 4      ; port a4     pin 10 
00ae			 
00ae			; active low AND masks 
00ae			 
00ae			;SPI_CE0_MASK: equ    255-1 
00ae			;SPI_CE1_MASK: equ   255-2 
00ae			;SPI_CE2_MASK: equ   255-4 
00ae			;SPI_CE3_MASK: equ   255-8 
00ae			;SPI_CE4_MASK: equ   255-16 
00ae			SPI_CE_HIGH:  equ 255 
00ae			 
00ae			 
00ae			 
00ae			 
00ae			; TODO store port id for spi device ie dev c 
00ae			; TODO store pin for SO 
00ae			; TODO store pin for SI 
00ae			; TODO store pin for SCLK 
00ae			 
00ae			; 
00ae			 
00ae			; ensure that spi bus is in a stable state with default pins  
00ae			 
00ae			se_stable_spi:   
00ae			 
00ae				 ; set DI high, CE high , SCLK low 
00ae				;ld a, SPI_DI | SPI_CE0 
00ae 3e 07			ld a, SPI_DI  
00b0 cd 84 01			call spi_ce_high 
00b3 d3 80			 out (storage_adata),a 
00b5 32 cf f9			ld (spi_portbyte),a 
00b8			 
00b8				if DEBUG_SPI 
00b8					push hl 
00b8					ld l, a 
00b8					DMARK "SPI" 
00b8					CALLMONITOR 
00b8					pop hl 
00b8				endif 
00b8 c9				ret 
00b9			 
00b9			; byte to send in a 
00b9			 
00b9			spi_send_byte: 
00b9				; save byte to send for bit mask shift out 
00b9 4f			        ld c,a 
00ba 3a cf f9			ld a,(spi_portbyte) 
00bd				  
00bd				; clock out	each bit of the byte msb first 
00bd			 
00bd 06 08			ld b, 8 
00bf			.ssb1: 
00bf				; clear so bit  
00bf cb bf			res SPI_DI, a 
00c1 cb 11			rl c 
00c3				; if bit 7 is set then carry is set 
00c3 30 02			jr nc, .ssb2 
00c5 cb ff			set SPI_DI,a 
00c7			.ssb2:  ; output bit to ensure it is stable 
00c7 d3 80			out (storage_adata),a 
00c9 00				nop 
00ca				; clock bit high 
00ca cb ef			set SPI_SCLK,a 
00cc d3 80			out (storage_adata),a 
00ce 00				nop 
00cf				; then low 
00cf cb af			res SPI_SCLK,a 
00d1 d3 80			out (storage_adata),a 
00d3 00				nop 
00d4 10 e9			djnz .ssb1 
00d6			 
00d6 32 cf f9			ld (spi_portbyte),a 
00d9 c9				ret 
00da			 
00da			; TODO low level get byte into A on spi 
00da			 
00da			spi_read_byte:  
00da			 
00da				; save byte to send for bit mask shift out 
00da 0e 00		    ld c,0 
00dc 3a cf f9			ld a,(spi_portbyte) 
00df				  
00df				; clock out	each bit of the byte msb first 
00df			 
00df			 
00df				; clock bit high 
00df cb ef			set SPI_SCLK,a 
00e1 d3 80			out (storage_adata),a 
00e3 00				nop 
00e4			 
00e4			    ; read DO  
00e4			 
00e4 cb f9		    set 7,c 
00e6 db 80			in a,(storage_adata) 
00e8 cb 77		    bit SPI_DO,a 
00ea 20 02		    jr nz, .b7 
00ec cb b9		    res 7,c 
00ee			.b7: 
00ee				; then low 
00ee cb af			res SPI_SCLK,a 
00f0 d3 80			out (storage_adata),a 
00f2 00				nop 
00f3			     
00f3			 
00f3				; clock bit high 
00f3 cb ef			set SPI_SCLK,a 
00f5 d3 80			out (storage_adata),a 
00f7 00				nop 
00f8			 
00f8			    ; read DO  
00f8			 
00f8 cb f1		    set 6,c 
00fa db 80			in a,(storage_adata) 
00fc cb 77		    bit SPI_DO,a 
00fe 20 02		    jr nz, .b6 
0100 cb b1		    res 6,c 
0102			.b6: 
0102				; then low 
0102 cb af			res SPI_SCLK,a 
0104 d3 80			out (storage_adata),a 
0106 00				nop 
0107			 
0107				; clock bit high 
0107 cb ef			set SPI_SCLK,a 
0109 d3 80			out (storage_adata),a 
010b 00				nop 
010c			 
010c			 
010c			    ; read DO  
010c			 
010c cb e9		    set 5,c 
010e db 80			in a,(storage_adata) 
0110 cb 77		    bit SPI_DO,a 
0112 20 02		    jr nz, .b5 
0114 cb a9		    res 5,c 
0116			.b5: 
0116				; then low 
0116 cb af			res SPI_SCLK,a 
0118 d3 80			out (storage_adata),a 
011a 00				nop 
011b				; clock bit high 
011b cb ef			set SPI_SCLK,a 
011d d3 80			out (storage_adata),a 
011f 00				nop 
0120			 
0120			    ; read DO  
0120			 
0120 cb e1		    set 4,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b4 
0128 cb a1		    res 4,c 
012a			.b4: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f				; clock bit high 
012f cb ef			set SPI_SCLK,a 
0131 d3 80			out (storage_adata),a 
0133 00				nop 
0134			 
0134			    ; read DO  
0134			 
0134 cb d9		    set 3,c 
0136 db 80			in a,(storage_adata) 
0138 cb 77		    bit SPI_DO,a 
013a 20 02		    jr nz, .b3 
013c cb 99		    res 3,c 
013e			.b3: 
013e				; then low 
013e cb af			res SPI_SCLK,a 
0140 d3 80			out (storage_adata),a 
0142 00				nop 
0143				; clock bit high 
0143 cb ef			set SPI_SCLK,a 
0145 d3 80			out (storage_adata),a 
0147 00				nop 
0148			 
0148			    ; read DO  
0148			 
0148 cb d1		    set 2,c 
014a db 80			in a,(storage_adata) 
014c cb 77		    bit SPI_DO,a 
014e 20 02		    jr nz, .b2 
0150 cb 91		    res 2,c 
0152			.b2: 
0152				; then low 
0152 cb af			res SPI_SCLK,a 
0154 d3 80			out (storage_adata),a 
0156 00				nop 
0157				; clock bit high 
0157 cb ef			set SPI_SCLK,a 
0159 d3 80			out (storage_adata),a 
015b 00				nop 
015c			 
015c			    ; read DO  
015c			 
015c cb c9		    set 1,c 
015e db 80			in a,(storage_adata) 
0160 cb 77		    bit SPI_DO,a 
0162 20 02		    jr nz, .b1 
0164 cb 89		    res 1,c 
0166			.b1: 
0166				; then low 
0166 cb af			res SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b				; clock bit high 
016b cb ef			set SPI_SCLK,a 
016d d3 80			out (storage_adata),a 
016f 00				nop 
0170			 
0170			    ; read DO  
0170			 
0170 cb c1		    set 0,c 
0172 db 80			in a,(storage_adata) 
0174 cb 77		    bit SPI_DO,a 
0176 20 02		    jr nz, .b0 
0178 cb 81		    res 0,c 
017a			.b0: 
017a				; then low 
017a cb af			res SPI_SCLK,a 
017c d3 80			out (storage_adata),a 
017e 00				nop 
017f			 
017f			 
017f 32 cf f9			ld (spi_portbyte),a 
0182			 
0182			    ; return byte 
0182 79			    ld a,c 
0183			 
0183			 
0183 c9				ret 
0184			 
0184			 
0184			 
0184			spi_ce_high: 
0184			 
0184				if DEBUG_SPI_HARD_CE0 
0184			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0184					ret 
0184			 
0184				endif 
0184			 
0184			 
0184 f5				push af 
0185			 
0185				; send direct ce to port b 
0185 3e ff			ld a, 255 
0187 d3 81			out (storage_bdata), a 
0189			 
0189 f1				pop af 
018a			 
018a				; for port a that shares with spi lines AND the mask 
018a			  
018a				if DEBUG_SPI 
018a					push hl 
018a					ld h, a 
018a				endif 
018a			;	ld c, SPI_CE_HIGH 
018a			;	and c 
018a cb c7			set SPI_CE0, a 
018c cb cf			set SPI_CE1, a 
018e cb d7			set SPI_CE2, a 
0190 cb df			set SPI_CE3, a 
0192 cb e7			set SPI_CE4, a 
0194			 
0194				if DEBUG_SPI 
0194					ld l, a 
0194					DMARK "CEh" 
0194					CALLMONITOR 
0194					pop hl 
0194				endif 
0194 c9				ret 
0195			 
0195			 
0195			spi_ce_low: 
0195			 
0195				if DEBUG_SPI_HARD_CE0 
0195			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0195					ret 
0195			 
0195				endif 
0195			 
0195 c5				push bc 
0196 f5				push af 
0197			 
0197				; send direct ce to port b 
0197 3a d1 f9			ld a, (spi_cartdev) 
019a d3 81			out (storage_bdata), a 
019c			 
019c			 
019c			 
019c				; for port a that shares with spi lines AND the mask 
019c			 
019c 3a ce f9			ld a, (spi_device)  
019f 4f				ld c, a 
01a0			 
01a0 f1				pop af 
01a1			 
01a1				; detect CEx 
01a1			 
01a1				if DEBUG_SPI 
01a1					push hl 
01a1					ld h, a 
01a1				endif 
01a1			 
01a1 cb 41			bit SPI_CE0, c 
01a3 20 04			jr nz, .cel1 
01a5 cb 87			res SPI_CE0, a 
01a7 18 1e			jr .celn 
01a9			.cel1: 
01a9 cb 49			bit SPI_CE1, c 
01ab 20 04			jr nz, .cel2 
01ad cb 8f			res SPI_CE1, a 
01af 18 16			jr .celn 
01b1			.cel2: 
01b1 cb 51			bit SPI_CE2, c 
01b3 20 04			jr nz, .cel3 
01b5 cb 97			res SPI_CE2, a 
01b7 18 0e			jr .celn 
01b9			.cel3: 
01b9 cb 59			bit SPI_CE3, c 
01bb 20 04			jr nz, .cel4 
01bd cb 9f			res SPI_CE3, a 
01bf 18 06			jr .celn 
01c1			.cel4: 
01c1 cb 61			bit SPI_CE4, c 
01c3 20 02			jr nz, .celn 
01c5 cb a7			res SPI_CE4, a 
01c7			.celn: 
01c7			 
01c7			 
01c7			 
01c7			;	add c 
01c7			 
01c7				if DEBUG_SPI 
01c7					ld l, a 
01c7					DMARK "CEl" 
01c7					CALLMONITOR 
01c7					pop hl 
01c7				endif 
01c7 c1				pop bc 
01c8 c9				ret 
01c9			 
01c9			 
01c9			 
01c9			; eof 
01c9			 
01c9			 
01c9			 
01c9			 
01c9			 
# End of file firmware_spi.asm
01c9				include "firmware_seeprom.asm"  
01c9			; 
01c9			; persisent storage interface via microchip serial eeprom 
01c9			 
01c9			; port a pio 2 
01c9			; pa 7 - si 
01c9			; pa 6 - sclk  
01c9			; pa 5 - so 
01c9			; pa 4 - cs 
01c9			; pa 3 - cs 
01c9			; pa 2 - cs 
01c9			; pa 1 - cs 
01c9			; pa 0 - cs 
01c9			; 
01c9			; TODO get block 
01c9			; TODO save block 
01c9			; TODO load file 
01c9			; TODO save file 
01c9			; TODO get dir  
01c9			 
01c9			;  
01c9			storage_adata: equ Device_C    ; device c port a - onboard storage 
01c9			storage_actl: equ Device_C+2     ; device c port a 
01c9			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01c9			storage_bctl: equ Device_C+3     ; device c port b 
01c9			 
01c9			 
01c9			; TODO move these to hardware driver file 
01c9			 
01c9			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01c9			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01c9			; storage bank file system format 
01c9			; 
01c9			; first page of bank: 
01c9			; 	addr 0 - status check 
01c9			;       addr 1 - write protect flag 
01c9			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01c9			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01c9			;         TODO see if scanning whole of for available next file id is fast enough 
01c9			;	addr 4 > zero term string of bank label 
01c9			; 
01c9			;        
01c9			;  
01c9			; first page of any file: 
01c9			;      byte 0 - file id  
01c9			;      byte 1-17 - fixed file name  
01c9			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01c9			; 
01c9			; other pages of any file: 
01c9			;      byte 0 - file id 
01c9			;      byte 1> - file data 
01c9			; 
01c9			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01c9			;  
01c9			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01c9			 
01c9			 
01c9			;storage_so_bit: 5 
01c9			;storage_si_bit: 7 
01c9			;storage_sclk_bit: 6 
01c9			  
01c9			 
01c9			; init storage pio 
01c9			 
01c9			storage_init: 
01c9			 
01c9 3e cf		            LD   A, 11001111b 
01cb d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01cd 3e 00		            LD   A, 00000000b 
01cf cb f7			set SPI_DO,a 
01d1			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d1 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d3			 
01d3 3e cf		            LD   A, 11001111b 
01d5 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01d7 3e 00		            LD   A, 00000000b 
01d9 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01db			 
01db				; set all external spi devices off 
01db 3e 00			ld a, 0 
01dd 32 ce f9			ld (spi_device), a 
01e0 32 d1 f9			ld (spi_cartdev), a 
01e3			 
01e3					; ensure the spi bus is in a default stable state 
01e3 cd ae 00				call se_stable_spi 
01e6			 
01e6			; TODO scan spi bus and gather which storage banks are present 
01e6			 
01e6			; populate store_bank_active  
01e6			; for each ce line activate and attempt to write first byte of bank and read back 
01e6			; if zero is returned then bank is empty 
01e6			;   
01e6			; 
01e6			 
01e6					; init file extent cache to save on slow reads 
01e6			 
01e6			;	ld hl, store_filecache 
01e6			;	ld de, 0 
01e6			;	ld hl,(de)	 
01e6			 
01e6			 
01e6 c9			    ret 
01e7			 
01e7			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01e7			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01e7			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01e7			 
01e7			; INSTRUCTION SET 
01e7			; READ 0000 0011 Read data from memory array beginning at selected address 
01e7			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01e7			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01e7			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01e7			; RDSR 0000 0101 Read STATUS register 
01e7			; WRSR 0000 0001 Write STATUS register 
01e7			; PE 0100 0010 Page Erase – erase one page in memory array 
01e7			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01e7			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01e7			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01e7			 
01e7			; TODO send byte steam for page without setting the address for every single byte 
01e7			; TODO read byte  
01e7			 
01e7			; byte in a 
01e7			; address in hl  
01e7			se_writebyte: 
01e7			        
01e7			    ;   ld c, a 
01e7 f5			        push af 
01e8 e5			        push hl 
01e9			 
01e9			    ; initi write mode 
01e9			    ; 
01e9			    ;CS low 
01e9			 
01e9 3a cf f9		       ld a,(spi_portbyte) 
01ec cd 95 01			call spi_ce_low 
01ef			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ef d3 80		       out (storage_adata),a 
01f1 32 cf f9		       ld (spi_portbyte), a 
01f4			 
01f4			    ;clock out wren instruction 
01f4			 
01f4 3e 06		    ld a, store_wren_ins 
01f6 cd b9 00		    call spi_send_byte  
01f9			 
01f9			    ;cs high to enable write latch 
01f9			 
01f9 3a cf f9		       ld a,(spi_portbyte) 
01fc cd 84 01			call spi_ce_high 
01ff			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ff d3 80		       out (storage_adata),a 
0201 32 cf f9		       ld (spi_portbyte), a 
0204			 
0204 00				nop 
0205			    ; 
0205			    ; intial write data 
0205			    ; 
0205			    ; cs low 
0205			     
0205 3a cf f9		       ld a,(spi_portbyte) 
0208 cd 95 01			call spi_ce_low 
020b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020b d3 80		       out (storage_adata),a 
020d 32 cf f9		       ld (spi_portbyte), a 
0210			 
0210			    ; clock out write instruction 
0210			     
0210 3e 02		    ld a, store_write_ins  
0212 cd b9 00		    call spi_send_byte  
0215			 
0215			    ; clock out address (depending on address size) 
0215			     
0215 e1			    pop hl 
0216 7c			    ld a,h    ; address out msb first 
0217 cd b9 00		    call spi_send_byte  
021a 7d			    ld a,l 
021b cd b9 00		    call spi_send_byte  
021e			 
021e			    ; clock out byte(s) for page 
021e			 
021e f1			    pop af 
021f cd b9 00		    call spi_send_byte  
0222			 
0222			    ; end write with ce high 
0222 3a cf f9		       ld a,(spi_portbyte) 
0225			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0225 cd 84 01			call spi_ce_high 
0228 d3 80		       out (storage_adata),a 
022a 32 cf f9		       ld (spi_portbyte), a 
022d			 
022d				; pause for internal write cycle 
022d 3e 0a			ld a, 10 
022f cd 37 0a			call aDelayInMS 
0232 c9			    ret 
0233			 
0233			; buffer to write in de 
0233			; address in hl  
0233			se_writepage: 
0233			        
0233			    ;   ld c, a 
0233 d5				push de 
0234 e5			        push hl 
0235			 
0235			    ; initi write mode 
0235			    ; 
0235			    ;CS low 
0235			 
0235 3a cf f9		       ld a,(spi_portbyte) 
0238 cd 95 01			call spi_ce_low 
023b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023b d3 80		       out (storage_adata),a 
023d 32 cf f9		       ld (spi_portbyte), a 
0240			 
0240			    ;clock out wren instruction 
0240			 
0240 3e 06		    ld a, store_wren_ins 
0242 cd b9 00		    call spi_send_byte  
0245			 
0245			    ;cs high to enable write latch 
0245			 
0245 3a cf f9		       ld a,(spi_portbyte) 
0248 cd 84 01			call spi_ce_high 
024b			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024b d3 80		       out (storage_adata),a 
024d 32 cf f9		       ld (spi_portbyte), a 
0250			 
0250 00				nop 
0251			    ; 
0251			    ; intial write data 
0251			    ; 
0251			    ; cs low 
0251			     
0251 3a cf f9		       ld a,(spi_portbyte) 
0254			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0254 cd 95 01			call spi_ce_low 
0257 d3 80		       out (storage_adata),a 
0259 32 cf f9		       ld (spi_portbyte), a 
025c			 
025c			    ; clock out write instruction 
025c			     
025c 3e 02		    ld a, store_write_ins  
025e cd b9 00		    call spi_send_byte  
0261			 
0261			    ; clock out address (depending on address size) 
0261			     
0261 e1			    pop hl 
0262 7c			    ld a,h    ; address out msb first 
0263 cd b9 00		    call spi_send_byte  
0266 7d			    ld a,l 
0267 cd b9 00		    call spi_send_byte  
026a			 
026a			    ; clock out byte(s) for page 
026a			 
026a e1				pop hl 
026b 06 40			ld b, STORE_BLOCK_PHY 
026d			.bytewrite: 
026d			 
026d 7e				ld a,(hl) 
026e e5			    push hl 
026f c5				push bc 
0270 cd b9 00		    call spi_send_byte  
0273 c1				pop bc 
0274 e1				pop hl 
0275			 
0275			    ; end write with ce high 
0275 3a cf f9		       ld a,(spi_portbyte) 
0278 cd 84 01			call spi_ce_high 
027b			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027b d3 80		       out (storage_adata),a 
027d 32 cf f9		       ld (spi_portbyte), a 
0280			 
0280 23				inc hl 
0281 10 ea			djnz .bytewrite 
0283			 
0283				; pause for internal write cycle 
0283 3e 64			ld a, 100 
0285 cd 37 0a			call aDelayInMS 
0288 c9			    ret 
0289			; returns byte in a 
0289			; address in hl  
0289			se_readbyte: 
0289 d5				push de 
028a c5				push bc 
028b			 
028b			    ;   ld c, a 
028b e5			        push hl 
028c			 
028c			    ; initi write mode 
028c			    ; 
028c			    ;CS low 
028c			 
028c 3a cf f9		       ld a,(spi_portbyte) 
028f cd 95 01			call spi_ce_low 
0292			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0292 d3 80		       out (storage_adata),a 
0294 32 cf f9		       ld (spi_portbyte), a 
0297			 
0297			    ;clock out wren instruction 
0297			 
0297 3e 03		    ld a, store_read_ins 
0299 cd b9 00		    call spi_send_byte  
029c			 
029c			 
029c			    ; clock out address (depending on address size) 
029c			     
029c e1			    pop hl 
029d 7c			    ld a,h    ; address out msb first 
029e cd b9 00		    call spi_send_byte  
02a1 7d			    ld a,l 
02a2 cd b9 00		    call spi_send_byte  
02a5			 
02a5			    ; clock in byte(s) for page 
02a5			 
02a5 cd da 00		    call spi_read_byte  
02a8 f5				push af 
02a9			 
02a9			    ; end write with ce high 
02a9 3a cf f9		       ld a,(spi_portbyte) 
02ac			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02ac cd 84 01			call spi_ce_high 
02af d3 80		       out (storage_adata),a 
02b1 32 cf f9		       ld (spi_portbyte), a 
02b4			 
02b4 f1				pop af 
02b5			 
02b5 c1				pop bc 
02b6 d1				pop de 
02b7			 
02b7 c9			    ret 
02b8			 
02b8			if DEBUG_STORESE 
02b8			 
02b8			storageput:  
02b8			 
02b8			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02b8			 
02b8 21 a5 ef			ld hl,scratch+2 
02bb cd bd 10			call get_word_hl 
02be			 
02be				; stuff it here for the moment as it will be overwritten later anyway 
02be			 
02be 22 c6 f2			ld (os_cur_ptr),hl	 
02c1			 
02c1			 
02c1			; get pointer to start of string 
02c1			 
02c1 21 aa ef			ld hl, scratch+7 
02c4			 
02c4			; loop writing char of string to eeprom 
02c4			 
02c4 7e			.writestr:	ld a,(hl) 
02c5 fe 00				cp 0 
02c7 28 12				jr z, .wsdone		; done writing 
02c9 e5					push hl 
02ca 2a c6 f2				ld hl,(os_cur_ptr) 
02cd cd e7 01				call se_writebyte 
02d0			 
02d0 2a c6 f2				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d3 23					inc hl 
02d4 22 c6 f2				ld (os_cur_ptr),hl 
02d7			 
02d7					; restore string pointer and get next char 
02d7			 
02d7 e1					pop hl 
02d8 23					inc hl 
02d9 18 e9				jr .writestr 
02db			 
02db			 
02db			 
02db			.wsdone: 
02db			 
02db			 
02db			; when done load first page into a buffer  
02db			 
02db 21 00 80				ld hl,08000h		; start in ram 
02de 22 c6 f2				ld (os_cur_ptr),hl 
02e1 21 00 00				ld hl, 0		 ; start of page 
02e4 22 cb ef				ld (scratch+40),hl	; hang on to it 
02e7			 
02e7 06 80				ld b, 128		; actually get more then one page 
02e9 c5			.wsload:	push bc 
02ea 2a cb ef				ld hl,(scratch+40) 
02ed e5					push hl 
02ee cd 89 02				call se_readbyte 
02f1			 
02f1					; a now as the byte 
02f1			 
02f1 2a c6 f2				ld hl,(os_cur_ptr) 
02f4 77					ld (hl),a 
02f5					; inc next buffer area 
02f5 23					inc hl 
02f6 22 c6 f2				ld (os_cur_ptr),hl 
02f9			 
02f9					; get eeprom position, inc and save for next round 
02f9 e1					pop hl		 
02fa 23					inc hl 
02fb 22 cb ef				ld (scratch+40),hl 
02fe c1					pop bc 
02ff 10 e8				djnz .wsload 
0301			 
0301			; set 'd' pointer to start of buffer 
0301			 
0301 21 00 80				ld hl,08000h 
0304 22 c6 f2				ld (os_cur_ptr),hl 
0307			 
0307			 
0307 c9			ret 
0308			 
0308			 
0308 c9			storageread: ret 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			endif 
0309			 
0309			 
0309			 
# End of file firmware_seeprom.asm
0309			else  
0309			   ; create some stubs for the labels  
0309			se_readbyte: ret  
0309			se_writebyte: ret  
0309			storage_init: ret  
0309			  
0309			endif  
0309			  
0309			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0309			;include "firmware_cf.asm"  
0309			  
0309			; load up high level storage hardward abstractions  
0309			include "firmware_storage.asm"  
0309			 
0309			; persisent storage hardware abstraction layer  
0309			 
0309			 
0309			 
0309			; Block 0 on storage is a config state 
0309			 
0309			 
0309			 
0309			; TODO add read phy block and write phy block functions 
0309			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0309			 
0309			; Abstraction layer  
0309			 
0309			; Logocial block size is same size as physical size - using tape concept 
0309			 
0309			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0309			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0309			 
0309			 
0309			 
0309			; Filesystem layout (Logical layout) 
0309			; 
0309			; Block 0 - Bank config  
0309			; 
0309			;      Byte - 0 file id counter 
0309			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0309			;      Byte - 3-20 zero terminated bank label 
0309			; 
0309			; Block 1 > File storage 
0309			; 
0309			;      Byte 0 file id    - block 0 file details 
0309			;      Byte 1 block id - block 0 is file  
0309			;            Byte 2-15 - File name 
0309			; 
0309			;       - to end of block data 
0309			; 
0309			 
0309			 
0309			; Read Block 
0309			; ---------- 
0309			; 
0309			; With current bank 
0309			;  
0309			; Get block number to read 
0309			; Load physical blocks starting at start block into buffer 
0309			 
0309			; de points to buffer to use 
0309			; hl holds logical block number  
0309			 
0309			storage_read_block: 
0309			 
0309				; TODO bank selection 
0309			 
0309				; for each of the physical blocks read it into the buffer 
0309 06 40			ld b, STORE_BLOCK_PHY 
030b			 
030b				if DEBUG_STORESE 
030b d5					push de 
030c				endif 
030c				 
030c			.rl1:    
030c			 
030c				; read physical block at hl into de 
030c			        ; increment hl and de to next read position on exit 
030c			 
030c e5				push hl 
030d d5				push de	 
030e c5				push bc 
030f			;	if DEBUG_STORESE 
030f			;		push af 
030f			;		ld a, 'R' 
030f			;		ld (debug_mark),a 
030f			;		pop af 
030f			;		CALLMONITOR 
030f			;	endif 
030f cd 89 02			call se_readbyte 
0312			;	if DEBUG_STORESE 
0312			;		ld a,(spi_portbyte) 
0312			;		ld l, a 
0312			;		push af 
0312			;		ld a, '1' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 c1				pop bc 
0313 d1				pop de 
0314 e1				pop hl 
0315 12				ld (de),a 
0316 23				inc hl 
0317 13				inc de 
0318			 
0318			;	if DEBUG_STORESE 
0318			;		push af 
0318			;		ld a, 'r' 
0318			;		ld (debug_mark),a 
0318			;		pop af 
0318			;		CALLMONITOR 
0318			;	endif 
0318			 
0318 10 f2			djnz .rl1 
031a			 
031a				if DEBUG_STORESE 
031a					DMARK "SRB" 
031a f5				push af  
031b 3a 2f 03			ld a, (.dmark)  
031e 32 bd fb			ld (debug_mark),a  
0321 3a 30 03			ld a, (.dmark+1)  
0324 32 be fb			ld (debug_mark+1),a  
0327 3a 31 03			ld a, (.dmark+2)  
032a 32 bf fb			ld (debug_mark+2),a  
032d 18 03			jr .pastdmark  
032f ..			.dmark: db "SRB"  
0332 f1			.pastdmark: pop af  
0333			endm  
# End of macro DMARK
0333 d1					pop de 
0334			; 
0334			;		push af 
0334			;		ld a, 'R' 
0334			;		ld (debug_mark),a 
0334			;		pop af 
0334					CALLMONITOR 
0334 cd 65 16			call break_point_state  
0337				endm  
# End of macro CALLMONITOR
0337				endif 
0337 c9				ret	 
0338				 
0338			 
0338			; File Size 
0338			; --------- 
0338			; 
0338			;   hl file id 
0338			; 
0338			;  returns in hl the number of blocks 
0338			 
0338			storage_file_size: 
0338 5d				ld e, l 
0339 16 00			ld d, 0 
033b 21 40 00			ld hl, STORE_BLOCK_PHY 
033e					if DEBUG_FORTH_WORDS 
033e						DMARK "SIZ" 
033e f5				push af  
033f 3a 53 03			ld a, (.dmark)  
0342 32 bd fb			ld (debug_mark),a  
0345 3a 54 03			ld a, (.dmark+1)  
0348 32 be fb			ld (debug_mark+1),a  
034b 3a 55 03			ld a, (.dmark+2)  
034e 32 bf fb			ld (debug_mark+2),a  
0351 18 03			jr .pastdmark  
0353 ..			.dmark: db "SIZ"  
0356 f1			.pastdmark: pop af  
0357			endm  
# End of macro DMARK
0357						CALLMONITOR 
0357 cd 65 16			call break_point_state  
035a				endm  
# End of macro CALLMONITOR
035a					endif 
035a cd 2a 06			call storage_findnextid 
035d			 
035d cd 2f 0d			call ishlzero 
0360			;	ld a, l 
0360			;	add h 
0360			;	cp 0 
0360 c8				ret z			; block not found so EOF 
0361			 
0361 11 e8 f9			ld de, store_page 
0364 cd 09 03			call storage_read_block 
0367			 
0367 3a ea f9			ld a, (store_page+2)	 ; get extent count 
036a 6f				ld l, a 
036b 26 00			ld h, 0 
036d c9			 	ret 
036e			 
036e			 
036e			; Write Block 
036e			; ----------- 
036e			; 
036e			; With current bank 
036e			;  
036e			; Get block number to write 
036e			; Write physical blocks starting at start block from buffer 
036e			  
036e			storage_write_block: 
036e				; TODO bank selection 
036e			 
036e				; for each of the physical blocks read it into the buffer 
036e 06 40			ld b, STORE_BLOCK_PHY 
0370			 
0370				if DEBUG_STORESE 
0370					DMARK "SWB" 
0370 f5				push af  
0371 3a 85 03			ld a, (.dmark)  
0374 32 bd fb			ld (debug_mark),a  
0377 3a 86 03			ld a, (.dmark+1)  
037a 32 be fb			ld (debug_mark+1),a  
037d 3a 87 03			ld a, (.dmark+2)  
0380 32 bf fb			ld (debug_mark+2),a  
0383 18 03			jr .pastdmark  
0385 ..			.dmark: db "SWB"  
0388 f1			.pastdmark: pop af  
0389			endm  
# End of macro DMARK
0389			 
0389					;push af 
0389					;ld a, 'W' 
0389					;ld (debug_mark),a 
0389					;pop af 
0389					CALLMONITOR 
0389 cd 65 16			call break_point_state  
038c				endm  
# End of macro CALLMONITOR
038c				endif 
038c			 
038c			; might not be working 
038c			;	call se_writepage 
038c			 
038c			;	ret 
038c			; 
038c			 
038c			 
038c			 
038c			.wl1:    
038c			 
038c				; read physical block at hl into de 
038c			        ; increment hl and de to next read position on exit 
038c			 
038c e5				push hl 
038d d5				push de	 
038e c5				push bc 
038f 1a				ld a,(de) 
0390				;if DEBUG_STORESE 
0390			;		push af 
0390			;		ld a, 'W' 
0390			;		ld (debug_mark),a 
0390			;		pop af 
0390			;		CALLMONITOR 
0390			;	endif 
0390 cd e7 01			call se_writebyte 
0393			;	call delay250ms 
0393 00				nop 
0394 00				nop 
0395 00				nop 
0396			;	if DEBUG_STORESE 
0396			;		push af 
0396			;		ld a, 'w' 
0396			;		ld (debug_mark),a 
0396			;		pop af 
0396			;		CALLMONITOR 
0396			;	endif 
0396 c1				pop bc 
0397 d1				pop de 
0398 e1				pop hl 
0399 23				inc hl 
039a 13				inc de 
039b			 
039b			 
039b 10 ef			djnz .wl1 
039d			 
039d				if DEBUG_STORESE 
039d					DMARK "SW2" 
039d f5				push af  
039e 3a b2 03			ld a, (.dmark)  
03a1 32 bd fb			ld (debug_mark),a  
03a4 3a b3 03			ld a, (.dmark+1)  
03a7 32 be fb			ld (debug_mark+1),a  
03aa 3a b4 03			ld a, (.dmark+2)  
03ad 32 bf fb			ld (debug_mark+2),a  
03b0 18 03			jr .pastdmark  
03b2 ..			.dmark: db "SW2"  
03b5 f1			.pastdmark: pop af  
03b6			endm  
# End of macro DMARK
03b6			 
03b6					;push af 
03b6					;ld a, 'W' 
03b6					;ld (debug_mark),a 
03b6					;pop af 
03b6					CALLMONITOR 
03b6 cd 65 16			call break_point_state  
03b9				endm  
# End of macro CALLMONITOR
03b9				endif 
03b9 c9				ret	 
03ba			 
03ba			; Init bank 
03ba			; --------- 
03ba			; 
03ba			; With current bank 
03ba			; 
03ba			; Setup block 0 config 
03ba			;     Set 0 file id counter 
03ba			;     Set formatted byte pattern 
03ba			;     Zero out bank label 
03ba			;      
03ba			; For every logical block write 0-1 byte as null 
03ba			 
03ba			storage_get_block_0: 
03ba			 
03ba				; TODO check presence 
03ba			 
03ba				; get block 0 config 
03ba			 
03ba 21 00 00			ld hl, 0 
03bd 11 e8 f9			ld de, store_page 
03c0 cd 09 03			call storage_read_block 
03c3			 
03c3				if DEBUG_STORESE 
03c3					DMARK "SB0" 
03c3 f5				push af  
03c4 3a d8 03			ld a, (.dmark)  
03c7 32 bd fb			ld (debug_mark),a  
03ca 3a d9 03			ld a, (.dmark+1)  
03cd 32 be fb			ld (debug_mark+1),a  
03d0 3a da 03			ld a, (.dmark+2)  
03d3 32 bf fb			ld (debug_mark+2),a  
03d6 18 03			jr .pastdmark  
03d8 ..			.dmark: db "SB0"  
03db f1			.pastdmark: pop af  
03dc			endm  
# End of macro DMARK
03dc 11 e8 f9				ld de, store_page 
03df			;		push af 
03df			;		ld a, 'i' 
03df			;		ld (debug_mark),a 
03df			;		pop af 
03df					CALLMONITOR 
03df cd 65 16			call break_point_state  
03e2				endm  
# End of macro CALLMONITOR
03e2				endif 
03e2			 
03e2				; is this area formatted? 
03e2			 
03e2			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e2 2a e9 f9			ld hl, (store_page+1) 
03e5 3e 80			ld a,0x80 
03e7 bd				cp l 
03e8 20 22			jr nz, .ininotformatted 
03ea				; do a double check 
03ea 3e 27			ld a, 0x27 
03ec bc				cp h 
03ed 20 1d			jr nz, .ininotformatted 
03ef			 
03ef				; formatted then 
03ef			 
03ef				if DEBUG_STORESE 
03ef					DMARK "SB1" 
03ef f5				push af  
03f0 3a 04 04			ld a, (.dmark)  
03f3 32 bd fb			ld (debug_mark),a  
03f6 3a 05 04			ld a, (.dmark+1)  
03f9 32 be fb			ld (debug_mark+1),a  
03fc 3a 06 04			ld a, (.dmark+2)  
03ff 32 bf fb			ld (debug_mark+2),a  
0402 18 03			jr .pastdmark  
0404 ..			.dmark: db "SB1"  
0407 f1			.pastdmark: pop af  
0408			endm  
# End of macro DMARK
0408					;push af 
0408					;ld a, 'I' 
0408					;ld (debug_mark),a 
0408					;pop af 
0408					CALLMONITOR 
0408 cd 65 16			call break_point_state  
040b				endm  
# End of macro CALLMONITOR
040b				endif 
040b c9				ret 
040c			 
040c			.ininotformatted: 
040c				; bank not formatted so poke various bits to make sure 
040c			 
040c				if DEBUG_STORESE 
040c					DMARK "SB2" 
040c f5				push af  
040d 3a 21 04			ld a, (.dmark)  
0410 32 bd fb			ld (debug_mark),a  
0413 3a 22 04			ld a, (.dmark+1)  
0416 32 be fb			ld (debug_mark+1),a  
0419 3a 23 04			ld a, (.dmark+2)  
041c 32 bf fb			ld (debug_mark+2),a  
041f 18 03			jr .pastdmark  
0421 ..			.dmark: db "SB2"  
0424 f1			.pastdmark: pop af  
0425			endm  
# End of macro DMARK
0425					;push af 
0425					;ld a, 'f' 
0425					;ld (debug_mark),a 
0425					;pop af 
0425					CALLMONITOR 
0425 cd 65 16			call break_point_state  
0428				endm  
# End of macro CALLMONITOR
0428				endif 
0428			 
0428 cd 15 0a			call storage_clear_page 
042b			 
042b 21 e8 f9			ld hl, store_page 
042e 3e 00			ld a, 0 
0430				 
0430 77				ld (hl),a   ; reset file counter 
0431			 
0431 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0434 22 e9 f9		 	ld (store_page+1), hl	 
0437			 
0437				; set default label 
0437			 
0437 21 d3 04			ld hl, .defaultbanklabl 
043a 11 eb f9		 	ld de, store_page+3 
043d 01 0f 00			ld bc, 15 
0440 ed b0			ldir 
0442			 
0442				; Append the current bank id 
0442 21 f4 f9			ld hl, store_page+3+9 
0445 3a cd f9			ld a, (spi_device_id) 
0448 77				ld (hl), a 
0449			 
0449				; save default page 0 
0449			 
0449 21 00 00			ld hl, 0 
044c 11 e8 f9			ld de, store_page 
044f				if DEBUG_STORESE 
044f					DMARK "SB3" 
044f f5				push af  
0450 3a 64 04			ld a, (.dmark)  
0453 32 bd fb			ld (debug_mark),a  
0456 3a 65 04			ld a, (.dmark+1)  
0459 32 be fb			ld (debug_mark+1),a  
045c 3a 66 04			ld a, (.dmark+2)  
045f 32 bf fb			ld (debug_mark+2),a  
0462 18 03			jr .pastdmark  
0464 ..			.dmark: db "SB3"  
0467 f1			.pastdmark: pop af  
0468			endm  
# End of macro DMARK
0468			;		push af 
0468			;		ld a, 'F' 
0468			;		ld (debug_mark),a 
0468			;		pop af 
0468					CALLMONITOR 
0468 cd 65 16			call break_point_state  
046b				endm  
# End of macro CALLMONITOR
046b				endif 
046b cd 6e 03			call storage_write_block 
046e				if DEBUG_STORESE 
046e					DMARK "SB4" 
046e f5				push af  
046f 3a 83 04			ld a, (.dmark)  
0472 32 bd fb			ld (debug_mark),a  
0475 3a 84 04			ld a, (.dmark+1)  
0478 32 be fb			ld (debug_mark+1),a  
047b 3a 85 04			ld a, (.dmark+2)  
047e 32 bf fb			ld (debug_mark+2),a  
0481 18 03			jr .pastdmark  
0483 ..			.dmark: db "SB4"  
0486 f1			.pastdmark: pop af  
0487			endm  
# End of macro DMARK
0487			;		push af 
0487			;		ld a, '>' 
0487			;		ld (debug_mark),a 
0487			;		pop af 
0487					CALLMONITOR 
0487 cd 65 16			call break_point_state  
048a				endm  
# End of macro CALLMONITOR
048a				endif 
048a			 
048a 00				nop 
048b 00				nop 
048c 00				nop 
048d			 
048d				; now set 0 in every page to mark as a free block 
048d			 
048d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
048f 21 40 00			ld hl, STORE_BLOCK_PHY 
0492			 
0492 3e 00		.setmark1:   	ld a,0 
0494 e5					push hl 
0495 c5					push bc 
0496 cd e7 01				call se_writebyte 
0499 3e 0a			ld a, 10 
049b cd 37 0a			call aDelayInMS 
049e 23				inc hl 
049f cd e7 01				call se_writebyte 
04a2 3e 0a			ld a, 10 
04a4 cd 37 0a			call aDelayInMS 
04a7 2b				dec hl 
04a8 c1					pop bc 
04a9 e1					pop hl 
04aa 3e 40				ld a, STORE_BLOCK_PHY 
04ac cd 06 0d				call addatohl 
04af 10 e1				djnz .setmark1 
04b1			 
04b1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04b3 3e 00		.setmark2:   	ld a,0 
04b5 e5					push hl 
04b6 c5					push bc 
04b7 cd e7 01				call se_writebyte 
04ba 3e 0a			ld a, 10 
04bc cd 37 0a			call aDelayInMS 
04bf 23				inc hl 
04c0 cd e7 01				call se_writebyte 
04c3 3e 0a			ld a, 10 
04c5 cd 37 0a			call aDelayInMS 
04c8 2b				dec hl 
04c9 c1					pop bc 
04ca e1					pop hl 
04cb 3e 40				ld a, STORE_BLOCK_PHY 
04cd cd 06 0d				call addatohl 
04d0 10 e1				djnz .setmark2 
04d2			 
04d2					 
04d2			 
04d2			 
04d2 c9				ret 
04d3			 
04d3			 
04d3			 
04d3			 
04d3 .. 00		.defaultbanklabl:   db "BankLabel_",0 
04de			 
04de			 
04de			 
04de			; Label Bank 
04de			; ---------- 
04de			; 
04de			; With current bank 
04de			; Read block 0 
04de			; Set label 
04de			; Write block 0 
04de			 
04de			; label str pointer in hl 
04de			 
04de			storage_label:     
04de			 
04de				if DEBUG_STORESE 
04de					DMARK "LBL" 
04de f5				push af  
04df 3a f3 04			ld a, (.dmark)  
04e2 32 bd fb			ld (debug_mark),a  
04e5 3a f4 04			ld a, (.dmark+1)  
04e8 32 be fb			ld (debug_mark+1),a  
04eb 3a f5 04			ld a, (.dmark+2)  
04ee 32 bf fb			ld (debug_mark+2),a  
04f1 18 03			jr .pastdmark  
04f3 ..			.dmark: db "LBL"  
04f6 f1			.pastdmark: pop af  
04f7			endm  
# End of macro DMARK
04f7					CALLMONITOR 
04f7 cd 65 16			call break_point_state  
04fa				endm  
# End of macro CALLMONITOR
04fa				endif 
04fa			 
04fa e5				push hl 
04fb			 
04fb cd ba 03			call storage_get_block_0 
04fe			 
04fe				; set default label 
04fe			 
04fe e1				pop hl 
04ff			 
04ff 11 eb f9		 	ld de, store_page+3 
0502 01 0f 00			ld bc, 15 
0505				if DEBUG_STORESE 
0505					DMARK "LB3" 
0505 f5				push af  
0506 3a 1a 05			ld a, (.dmark)  
0509 32 bd fb			ld (debug_mark),a  
050c 3a 1b 05			ld a, (.dmark+1)  
050f 32 be fb			ld (debug_mark+1),a  
0512 3a 1c 05			ld a, (.dmark+2)  
0515 32 bf fb			ld (debug_mark+2),a  
0518 18 03			jr .pastdmark  
051a ..			.dmark: db "LB3"  
051d f1			.pastdmark: pop af  
051e			endm  
# End of macro DMARK
051e					CALLMONITOR 
051e cd 65 16			call break_point_state  
0521				endm  
# End of macro CALLMONITOR
0521				endif 
0521 ed b0			ldir 
0523				; save default page 0 
0523			 
0523 21 00 00			ld hl, 0 
0526 11 e8 f9			ld de, store_page 
0529				if DEBUG_STORESE 
0529					DMARK "LBW" 
0529 f5				push af  
052a 3a 3e 05			ld a, (.dmark)  
052d 32 bd fb			ld (debug_mark),a  
0530 3a 3f 05			ld a, (.dmark+1)  
0533 32 be fb			ld (debug_mark+1),a  
0536 3a 40 05			ld a, (.dmark+2)  
0539 32 bf fb			ld (debug_mark+2),a  
053c 18 03			jr .pastdmark  
053e ..			.dmark: db "LBW"  
0541 f1			.pastdmark: pop af  
0542			endm  
# End of macro DMARK
0542					CALLMONITOR 
0542 cd 65 16			call break_point_state  
0545				endm  
# End of macro CALLMONITOR
0545				endif 
0545 cd 6e 03			call storage_write_block 
0548			 
0548 c9				ret 
0549			 
0549			 
0549			 
0549			; Read Block 0 - Config 
0549			; --------------------- 
0549			; 
0549			; With current bank 
0549			; Call presence test 
0549			;    If not present format/init bank  
0549			; Read block 0  
0549			;  
0549			 
0549			 
0549			; Dir 
0549			; --- 
0549			; 
0549			; With current bank 
0549			; Load Block 0 Config 
0549			; Get max file id number 
0549			; For each logical block 
0549			;    Read block read byte 2 
0549			;      if first block of file 
0549			;         Display file name 
0549			;         Display type flags for file 
0549			;        
0549			 
0549			; moving to words as this requires stack control 
0549			 
0549			 
0549			; Delete File 
0549			; ----------- 
0549			; 
0549			; With current bank 
0549			; 
0549			; Load Block 0 Config 
0549			; Get max file id number 
0549			; For each logical block 
0549			;    Read block file id 
0549			;      If first block of file and dont have file id 
0549			;         if file to delete 
0549			;         Save file id 
0549			;         Null file id 
0549			;         Write this block back 
0549			;      If file id is one saved 
0549			;         Null file id 
0549			;         Write this block back 
0549			 
0549			storage_erase: 
0549			 
0549				; hl contains the file id 
0549			 
0549 5d				ld e, l 
054a 16 00			ld d, 0 
054c 21 40 00			ld hl, STORE_BLOCK_PHY 
054f					if DEBUG_FORTH_WORDS 
054f						DMARK "ERA" 
054f f5				push af  
0550 3a 64 05			ld a, (.dmark)  
0553 32 bd fb			ld (debug_mark),a  
0556 3a 65 05			ld a, (.dmark+1)  
0559 32 be fb			ld (debug_mark+1),a  
055c 3a 66 05			ld a, (.dmark+2)  
055f 32 bf fb			ld (debug_mark+2),a  
0562 18 03			jr .pastdmark  
0564 ..			.dmark: db "ERA"  
0567 f1			.pastdmark: pop af  
0568			endm  
# End of macro DMARK
0568						CALLMONITOR 
0568 cd 65 16			call break_point_state  
056b				endm  
# End of macro CALLMONITOR
056b					endif 
056b cd 2a 06			call storage_findnextid 
056e			 
056e e5				push hl 
056f			 
056f				; TODO check file not found 
056f			 
056f 11 e8 f9			ld de, store_page 
0572 cd 09 03			call storage_read_block 
0575			 
0575					if DEBUG_FORTH_WORDS 
0575						DMARK "ER1" 
0575 f5				push af  
0576 3a 8a 05			ld a, (.dmark)  
0579 32 bd fb			ld (debug_mark),a  
057c 3a 8b 05			ld a, (.dmark+1)  
057f 32 be fb			ld (debug_mark+1),a  
0582 3a 8c 05			ld a, (.dmark+2)  
0585 32 bf fb			ld (debug_mark+2),a  
0588 18 03			jr .pastdmark  
058a ..			.dmark: db "ER1"  
058d f1			.pastdmark: pop af  
058e			endm  
# End of macro DMARK
058e						CALLMONITOR 
058e cd 65 16			call break_point_state  
0591				endm  
# End of macro CALLMONITOR
0591					endif 
0591 3a e8 f9			ld a, (store_page)	; get file id 
0594 32 e1 f9			ld (store_tmpid), a 
0597			 
0597 3a ea f9			ld a, (store_page+2)    ; get count of extends 
059a 32 e0 f9			ld (store_tmpext), a 
059d			 
059d				; wipe file header 
059d			 
059d e1				pop hl 
059e 3e 00			ld a, 0 
05a0 32 e8 f9			ld (store_page), a 
05a3 32 e9 f9			ld (store_page+1),a 
05a6 11 e8 f9			ld de, store_page 
05a9					if DEBUG_FORTH_WORDS 
05a9						DMARK "ER2" 
05a9 f5				push af  
05aa 3a be 05			ld a, (.dmark)  
05ad 32 bd fb			ld (debug_mark),a  
05b0 3a bf 05			ld a, (.dmark+1)  
05b3 32 be fb			ld (debug_mark+1),a  
05b6 3a c0 05			ld a, (.dmark+2)  
05b9 32 bf fb			ld (debug_mark+2),a  
05bc 18 03			jr .pastdmark  
05be ..			.dmark: db "ER2"  
05c1 f1			.pastdmark: pop af  
05c2			endm  
# End of macro DMARK
05c2						CALLMONITOR 
05c2 cd 65 16			call break_point_state  
05c5				endm  
# End of macro CALLMONITOR
05c5					endif 
05c5 cd 6e 03			call storage_write_block 
05c8			 
05c8			 
05c8				; wipe file extents 
05c8			 
05c8 3a e0 f9			ld a, (store_tmpext) 
05cb 47				ld b, a 
05cc			 
05cc			.eraext:	  
05cc c5				push bc 
05cd			 
05cd 21 40 00			ld hl, STORE_BLOCK_PHY 
05d0 3a e1 f9			ld a,(store_tmpid) 
05d3 5f				ld e, a 
05d4 50				ld d, b	 
05d5					if DEBUG_FORTH_WORDS 
05d5						DMARK "ER3" 
05d5 f5				push af  
05d6 3a ea 05			ld a, (.dmark)  
05d9 32 bd fb			ld (debug_mark),a  
05dc 3a eb 05			ld a, (.dmark+1)  
05df 32 be fb			ld (debug_mark+1),a  
05e2 3a ec 05			ld a, (.dmark+2)  
05e5 32 bf fb			ld (debug_mark+2),a  
05e8 18 03			jr .pastdmark  
05ea ..			.dmark: db "ER3"  
05ed f1			.pastdmark: pop af  
05ee			endm  
# End of macro DMARK
05ee						CALLMONITOR 
05ee cd 65 16			call break_point_state  
05f1				endm  
# End of macro CALLMONITOR
05f1					endif 
05f1 cd 2a 06			call storage_findnextid 
05f4			 
05f4 e5				push hl 
05f5 11 e8 f9			ld de, store_page 
05f8 cd 09 03			call storage_read_block 
05fb			 
05fb				; free block	 
05fb			 
05fb 3e 00			ld a, 0 
05fd 32 e8 f9			ld (store_page), a 
0600 32 e9 f9			ld (store_page+1),a 
0603 11 e8 f9			ld de, store_page 
0606 e1				pop hl 
0607					if DEBUG_FORTH_WORDS 
0607						DMARK "ER4" 
0607 f5				push af  
0608 3a 1c 06			ld a, (.dmark)  
060b 32 bd fb			ld (debug_mark),a  
060e 3a 1d 06			ld a, (.dmark+1)  
0611 32 be fb			ld (debug_mark+1),a  
0614 3a 1e 06			ld a, (.dmark+2)  
0617 32 bf fb			ld (debug_mark+2),a  
061a 18 03			jr .pastdmark  
061c ..			.dmark: db "ER4"  
061f f1			.pastdmark: pop af  
0620			endm  
# End of macro DMARK
0620						CALLMONITOR 
0620 cd 65 16			call break_point_state  
0623				endm  
# End of macro CALLMONITOR
0623					endif 
0623 cd 6e 03			call storage_write_block 
0626			 
0626 c1				pop bc 
0627 10 a3			djnz .eraext 
0629			 
0629 c9				ret 
062a			 
062a			 
062a			; Find Free Block 
062a			; --------------- 
062a			; 
062a			; With current bank 
062a			;  
062a			; From given starting logical block 
062a			;    Read block  
062a			;    If no file id 
062a			;         Return block id 
062a			 
062a			 
062a			; hl starting page number 
062a			; hl contains free page number or zero if no pages free 
062a			; e contains the file id to locate 
062a			; d contains the block number 
062a			 
062a			; TODO change to find file id and use zero for free block 
062a			 
062a			storage_findnextid: 
062a			 
062a				; now locate first 0 page to mark as a free block 
062a			 
062a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
062c			;	ld hl, STORE_BLOCK_PHY 
062c			 
062c					if DEBUG_FORTH_WORDS 
062c					DMARK "FNI" 
062c f5				push af  
062d 3a 41 06			ld a, (.dmark)  
0630 32 bd fb			ld (debug_mark),a  
0633 3a 42 06			ld a, (.dmark+1)  
0636 32 be fb			ld (debug_mark+1),a  
0639 3a 43 06			ld a, (.dmark+2)  
063c 32 bf fb			ld (debug_mark+2),a  
063f 18 03			jr .pastdmark  
0641 ..			.dmark: db "FNI"  
0644 f1			.pastdmark: pop af  
0645			endm  
# End of macro DMARK
0645						CALLMONITOR 
0645 cd 65 16			call break_point_state  
0648				endm  
# End of macro CALLMONITOR
0648					endif 
0648			.ff1:   	 
0648 e5					push hl 
0649 c5					push bc 
064a d5					push de 
064b cd 89 02				call se_readbyte 
064e 5f					ld e,a 
064f 23					inc hl 
0650 cd 89 02				call se_readbyte 
0653 57					ld d, a 
0654 e1					pop hl 
0655 e5					push hl 
0656 cd 24 0d				call cmp16 
0659 28 49				jr z, .fffound 
065b			 
065b d1					pop de 
065c c1					pop bc 
065d e1					pop hl 
065e			 
065e					; is found? 
065e					;cp e 
065e					;ret z 
065e			 
065e 3e 40				ld a, STORE_BLOCK_PHY 
0660 cd 06 0d				call addatohl 
0663 10 e3				djnz .ff1 
0665			 
0665 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0667			.ff2:   	 
0667			 
0667 e5					push hl 
0668 c5					push bc 
0669 d5					push de 
066a cd 89 02				call se_readbyte 
066d 5f					ld e,a 
066e 23					inc hl 
066f cd 89 02				call se_readbyte 
0672 57					ld d, a 
0673			 
0673 e1					pop hl 
0674 e5					push hl 
0675 cd 24 0d				call cmp16 
0678 28 2a				jr z, .fffound 
067a			 
067a d1					pop de 
067b c1					pop bc 
067c e1					pop hl 
067d					; is found? 
067d					;cp e 
067d					;ret z 
067d			 
067d 3e 40				ld a, STORE_BLOCK_PHY 
067f cd 06 0d				call addatohl 
0682 10 e3				djnz .ff2 
0684			 
0684			 
0684					if DEBUG_FORTH_WORDS 
0684					DMARK "FN-" 
0684 f5				push af  
0685 3a 99 06			ld a, (.dmark)  
0688 32 bd fb			ld (debug_mark),a  
068b 3a 9a 06			ld a, (.dmark+1)  
068e 32 be fb			ld (debug_mark+1),a  
0691 3a 9b 06			ld a, (.dmark+2)  
0694 32 bf fb			ld (debug_mark+2),a  
0697 18 03			jr .pastdmark  
0699 ..			.dmark: db "FN-"  
069c f1			.pastdmark: pop af  
069d			endm  
# End of macro DMARK
069d					;	push af 
069d					;	ld a, 'n' 
069d					;	ld (debug_mark),a 
069d					;	pop af 
069d						CALLMONITOR 
069d cd 65 16			call break_point_state  
06a0				endm  
# End of macro CALLMONITOR
06a0					endif 
06a0				; no free marks! 
06a0 21 00 00				ld hl, 0 
06a3 c9				ret 
06a4			.fffound: 
06a4				 
06a4			 
06a4 d1					pop de 
06a5 c1					pop bc 
06a6 e1					pop hl 
06a7					if DEBUG_FORTH_WORDS 
06a7					DMARK "FNF" 
06a7 f5				push af  
06a8 3a bc 06			ld a, (.dmark)  
06ab 32 bd fb			ld (debug_mark),a  
06ae 3a bd 06			ld a, (.dmark+1)  
06b1 32 be fb			ld (debug_mark+1),a  
06b4 3a be 06			ld a, (.dmark+2)  
06b7 32 bf fb			ld (debug_mark+2),a  
06ba 18 03			jr .pastdmark  
06bc ..			.dmark: db "FNF"  
06bf f1			.pastdmark: pop af  
06c0			endm  
# End of macro DMARK
06c0					;	push af 
06c0					;	ld a, 'n' 
06c0					;	ld (debug_mark),a 
06c0					;	pop af 
06c0						CALLMONITOR 
06c0 cd 65 16			call break_point_state  
06c3				endm  
# End of macro CALLMONITOR
06c3					endif 
06c3 c9				ret 
06c4			 
06c4			 
06c4			 
06c4			; Free Space 
06c4			; ---------- 
06c4			; 
06c4			; With current bank 
06c4			; 
06c4			; Set block count to zero 
06c4			; Starting with first logical block 
06c4			;      Find free block  
06c4			;      If block id given, increment block count 
06c4			; 
06c4			;  
06c4			 
06c4			 
06c4			; hl contains count of free blocks 
06c4			 
06c4			storage_freeblocks: 
06c4			 
06c4				; now locate first 0 page to mark as a free block 
06c4			 
06c4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06c6 21 40 00			ld hl, STORE_BLOCK_PHY 
06c9 11 00 00			ld de, 0 
06cc			 
06cc			.fb1:   	 
06cc e5					push hl 
06cd c5					push bc 
06ce d5					push de 
06cf cd 89 02				call se_readbyte 
06d2 d1					pop de 
06d3 c1					pop bc 
06d4 e1					pop hl 
06d5			 
06d5					; is free? 
06d5 fe 00				cp 0 
06d7 20 01				jr nz, .ff1cont 
06d9 13					inc de 
06da			 
06da			.ff1cont: 
06da			 
06da			 
06da 3e 40				ld a, STORE_BLOCK_PHY 
06dc cd 06 0d				call addatohl 
06df 10 eb				djnz .fb1 
06e1			 
06e1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06e3			.fb2:   	 
06e3 e5					push hl 
06e4 c5					push bc 
06e5 d5					push de 
06e6 cd 89 02				call se_readbyte 
06e9 d1					pop de 
06ea c1					pop bc 
06eb e1					pop hl 
06ec			 
06ec					; is free? 
06ec fe 00				cp 0 
06ee 20 01				jr nz, .ff2cont 
06f0 13					inc de 
06f1			 
06f1			.ff2cont: 
06f1			 
06f1 3e 40				ld a, STORE_BLOCK_PHY 
06f3 cd 06 0d				call addatohl 
06f6 10 eb				djnz .fb2 
06f8			 
06f8 eb				ex de, hl 
06f9 c9				ret 
06fa			 
06fa			; Get File ID 
06fa			; ----------- 
06fa			; 
06fa			; With current bank 
06fa			;  
06fa			; Load Block 0 Config 
06fa			; Get max file id number 
06fa			; For each logical block 
06fa			;    Read block file id 
06fa			;      If first block of file and dont have file id 
06fa			;         if file get id and exit 
06fa			 
06fa			 
06fa			 
06fa			 
06fa			; Create File 
06fa			; ----------- 
06fa			; 
06fa			; With current bank  
06fa			; Load Block 0 Config 
06fa			; Get max file id number 
06fa			; Increment file id number 
06fa			; Save Config 
06fa			; Find free block 
06fa			; Set buffer with file name and file id 
06fa			; Write buffer to free block  
06fa			 
06fa			 
06fa			; hl point to file name 
06fa			; hl returns file id 
06fa			 
06fa			; file format: 
06fa			; byte 0 - file id 
06fa			; byte 1 - extent number 
06fa			; byte 2-> data 
06fa			 
06fa			; format for extent number 0: 
06fa			; 
06fa			; byte 0 - file id 
06fa			; byte 1 - extent 0 
06fa			; byte 2 - extent count 
06fa			; byte 3 -> file name and meta data 
06fa			 
06fa			 
06fa			storage_create: 
06fa				if DEBUG_STORESE 
06fa					DMARK "SCR" 
06fa f5				push af  
06fb 3a 0f 07			ld a, (.dmark)  
06fe 32 bd fb			ld (debug_mark),a  
0701 3a 10 07			ld a, (.dmark+1)  
0704 32 be fb			ld (debug_mark+1),a  
0707 3a 11 07			ld a, (.dmark+2)  
070a 32 bf fb			ld (debug_mark+2),a  
070d 18 03			jr .pastdmark  
070f ..			.dmark: db "SCR"  
0712 f1			.pastdmark: pop af  
0713			endm  
# End of macro DMARK
0713					CALLMONITOR 
0713 cd 65 16			call break_point_state  
0716				endm  
# End of macro CALLMONITOR
0716				endif 
0716			 
0716 e5				push hl		; save file name pointer 
0717			 
0717 cd ba 03			call storage_get_block_0 
071a			 
071a 3a e8 f9			ld a,(store_page)	; get current file id 
071d 3c				inc a 
071e 32 e8 f9			ld (store_page),a 
0721				 
0721 32 e1 f9			ld (store_tmpid),a			; save id 
0724			 
0724 21 00 00			ld hl, 0 
0727 11 e8 f9			ld de, store_page 
072a				if DEBUG_STORESE 
072a					DMARK "SCw" 
072a f5				push af  
072b 3a 3f 07			ld a, (.dmark)  
072e 32 bd fb			ld (debug_mark),a  
0731 3a 40 07			ld a, (.dmark+1)  
0734 32 be fb			ld (debug_mark+1),a  
0737 3a 41 07			ld a, (.dmark+2)  
073a 32 bf fb			ld (debug_mark+2),a  
073d 18 03			jr .pastdmark  
073f ..			.dmark: db "SCw"  
0742 f1			.pastdmark: pop af  
0743			endm  
# End of macro DMARK
0743					CALLMONITOR 
0743 cd 65 16			call break_point_state  
0746				endm  
# End of macro CALLMONITOR
0746				endif 
0746 cd 6e 03			call storage_write_block	 ; save update 
0749			 
0749				if DEBUG_STORESE 
0749 11 e8 f9				ld de, store_page 
074c					DMARK "SCC" 
074c f5				push af  
074d 3a 61 07			ld a, (.dmark)  
0750 32 bd fb			ld (debug_mark),a  
0753 3a 62 07			ld a, (.dmark+1)  
0756 32 be fb			ld (debug_mark+1),a  
0759 3a 63 07			ld a, (.dmark+2)  
075c 32 bf fb			ld (debug_mark+2),a  
075f 18 03			jr .pastdmark  
0761 ..			.dmark: db "SCC"  
0764 f1			.pastdmark: pop af  
0765			endm  
# End of macro DMARK
0765					CALLMONITOR 
0765 cd 65 16			call break_point_state  
0768				endm  
# End of macro CALLMONITOR
0768				endif 
0768				;  
0768				 
0768 21 40 00			ld hl, STORE_BLOCK_PHY 
076b 11 00 00			ld de, 0 
076e cd 2a 06			call storage_findnextid 
0771			 
0771 22 d2 f9			ld (store_tmppageid), hl    ; save page to use  
0774			 
0774				; TODO detect 0 = no spare blocks 
0774			 
0774				; hl now contains the free page to use for the file header page 
0774			 
0774				if DEBUG_STORESE 
0774				DMARK "SCF" 
0774 f5				push af  
0775 3a 89 07			ld a, (.dmark)  
0778 32 bd fb			ld (debug_mark),a  
077b 3a 8a 07			ld a, (.dmark+1)  
077e 32 be fb			ld (debug_mark+1),a  
0781 3a 8b 07			ld a, (.dmark+2)  
0784 32 bf fb			ld (debug_mark+2),a  
0787 18 03			jr .pastdmark  
0789 ..			.dmark: db "SCF"  
078c f1			.pastdmark: pop af  
078d			endm  
# End of macro DMARK
078d					CALLMONITOR 
078d cd 65 16			call break_point_state  
0790				endm  
# End of macro CALLMONITOR
0790				endif 
0790			 
0790 22 d2 f9			ld (store_tmppageid), hl 
0793				 
0793 3a e1 f9			ld a,(store_tmpid)    ; get file id 
0796			;	ld a, (store_filecache)			; save to cache 
0796			 
0796 32 e8 f9			ld (store_page),a    ; set page id 
0799 3e 00			ld a, 0			 ; extent 0 is file header 
079b 32 e9 f9			ld (store_page+1), a   ; set file extent 
079e			 
079e 32 ea f9			ld (store_page+2), a   ; extent count for the file 
07a1			 
07a1			;	inc hl 		; init block 0 of file 
07a1			;	inc hl   		; skip file and extent id 
07a1			 ;       ld a, 0 
07a1			;	ld (hl),a 
07a1			;	ld a, (store_filecache+1)  	; save to cache 
07a1			 
07a1			;	inc hl    ; file name 
07a1				 
07a1				 
07a1 11 eb f9			ld de, store_page+3    ; get buffer for term string to use as file name 
07a4				if DEBUG_STORESE 
07a4					DMARK "SCc" 
07a4 f5				push af  
07a5 3a b9 07			ld a, (.dmark)  
07a8 32 bd fb			ld (debug_mark),a  
07ab 3a ba 07			ld a, (.dmark+1)  
07ae 32 be fb			ld (debug_mark+1),a  
07b1 3a bb 07			ld a, (.dmark+2)  
07b4 32 bf fb			ld (debug_mark+2),a  
07b7 18 03			jr .pastdmark  
07b9 ..			.dmark: db "SCc"  
07bc f1			.pastdmark: pop af  
07bd			endm  
# End of macro DMARK
07bd					CALLMONITOR 
07bd cd 65 16			call break_point_state  
07c0				endm  
# End of macro CALLMONITOR
07c0				endif 
07c0 e1				pop hl    ; get zero term string 
07c1 e5				push hl 
07c2 3e 00			ld a, 0 
07c4 cd 6f 11			call strlent 
07c7 23				inc hl   ; cover zero term 
07c8 06 00			ld b,0 
07ca 4d				ld c,l 
07cb e1				pop hl 
07cc				;ex de, hl 
07cc				if DEBUG_STORESE 
07cc					DMARK "SCa" 
07cc f5				push af  
07cd 3a e1 07			ld a, (.dmark)  
07d0 32 bd fb			ld (debug_mark),a  
07d3 3a e2 07			ld a, (.dmark+1)  
07d6 32 be fb			ld (debug_mark+1),a  
07d9 3a e3 07			ld a, (.dmark+2)  
07dc 32 bf fb			ld (debug_mark+2),a  
07df 18 03			jr .pastdmark  
07e1 ..			.dmark: db "SCa"  
07e4 f1			.pastdmark: pop af  
07e5			endm  
# End of macro DMARK
07e5					;push af 
07e5					;ld a, 'a' 
07e5					;ld (debug_mark),a 
07e5					;pop af 
07e5					CALLMONITOR 
07e5 cd 65 16			call break_point_state  
07e8				endm  
# End of macro CALLMONITOR
07e8				endif 
07e8 ed b0			ldir    ; copy zero term string 
07ea				if DEBUG_STORESE 
07ea					DMARK "SCA" 
07ea f5				push af  
07eb 3a ff 07			ld a, (.dmark)  
07ee 32 bd fb			ld (debug_mark),a  
07f1 3a 00 08			ld a, (.dmark+1)  
07f4 32 be fb			ld (debug_mark+1),a  
07f7 3a 01 08			ld a, (.dmark+2)  
07fa 32 bf fb			ld (debug_mark+2),a  
07fd 18 03			jr .pastdmark  
07ff ..			.dmark: db "SCA"  
0802 f1			.pastdmark: pop af  
0803			endm  
# End of macro DMARK
0803					CALLMONITOR 
0803 cd 65 16			call break_point_state  
0806				endm  
# End of macro CALLMONITOR
0806				endif 
0806			 
0806				; write file header page 
0806			 
0806 2a d2 f9			ld hl,(store_tmppageid) 
0809 11 e8 f9			ld de, store_page 
080c				if DEBUG_STORESE 
080c					DMARK "SCb" 
080c f5				push af  
080d 3a 21 08			ld a, (.dmark)  
0810 32 bd fb			ld (debug_mark),a  
0813 3a 22 08			ld a, (.dmark+1)  
0816 32 be fb			ld (debug_mark+1),a  
0819 3a 23 08			ld a, (.dmark+2)  
081c 32 bf fb			ld (debug_mark+2),a  
081f 18 03			jr .pastdmark  
0821 ..			.dmark: db "SCb"  
0824 f1			.pastdmark: pop af  
0825			endm  
# End of macro DMARK
0825					;push af 
0825					;ld a, 'b' 
0825					;ld (debug_mark),a 
0825					;pop af 
0825					CALLMONITOR 
0825 cd 65 16			call break_point_state  
0828				endm  
# End of macro CALLMONITOR
0828				endif 
0828 cd 6e 03			call storage_write_block 
082b			 
082b 3a e1 f9			ld a, (store_tmpid) 
082e 6f				ld l, a 
082f 26 00			ld h,0 
0831				if DEBUG_STORESE 
0831					DMARK "SCz" 
0831 f5				push af  
0832 3a 46 08			ld a, (.dmark)  
0835 32 bd fb			ld (debug_mark),a  
0838 3a 47 08			ld a, (.dmark+1)  
083b 32 be fb			ld (debug_mark+1),a  
083e 3a 48 08			ld a, (.dmark+2)  
0841 32 bf fb			ld (debug_mark+2),a  
0844 18 03			jr .pastdmark  
0846 ..			.dmark: db "SCz"  
0849 f1			.pastdmark: pop af  
084a			endm  
# End of macro DMARK
084a					CALLMONITOR 
084a cd 65 16			call break_point_state  
084d				endm  
# End of macro CALLMONITOR
084d				endif 
084d c9				ret 
084e				 
084e			 
084e			 
084e			; 
084e			; Read File 
084e			; 
084e			; h - file id to locate 
084e			; l - extent to locate 
084e			; de - pointer to string to read into 
084e			; 
084e			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
084e			storage_read: 
084e d5				push de 
084f			 
084f			; TODO BUG the above push is it popped before the RET Z? 
084f			 
084f			; TODO how to handle multiple part blocks 
084f			 
084f				; locate file extent to read 
084f			 
084f 5c				ld e, h 
0850 55				ld d, l 
0851 21 40 00			ld hl, STORE_BLOCK_PHY 
0854				if DEBUG_STORESE 
0854					DMARK "SRE" 
0854 f5				push af  
0855 3a 69 08			ld a, (.dmark)  
0858 32 bd fb			ld (debug_mark),a  
085b 3a 6a 08			ld a, (.dmark+1)  
085e 32 be fb			ld (debug_mark+1),a  
0861 3a 6b 08			ld a, (.dmark+2)  
0864 32 bf fb			ld (debug_mark+2),a  
0867 18 03			jr .pastdmark  
0869 ..			.dmark: db "SRE"  
086c f1			.pastdmark: pop af  
086d			endm  
# End of macro DMARK
086d					CALLMONITOR 
086d cd 65 16			call break_point_state  
0870				endm  
# End of macro CALLMONITOR
0870				endif 
0870 cd 2a 06			call storage_findnextid 
0873			 
0873				if DEBUG_STORESE 
0873					DMARK "SRf" 
0873 f5				push af  
0874 3a 88 08			ld a, (.dmark)  
0877 32 bd fb			ld (debug_mark),a  
087a 3a 89 08			ld a, (.dmark+1)  
087d 32 be fb			ld (debug_mark+1),a  
0880 3a 8a 08			ld a, (.dmark+2)  
0883 32 bf fb			ld (debug_mark+2),a  
0886 18 03			jr .pastdmark  
0888 ..			.dmark: db "SRf"  
088b f1			.pastdmark: pop af  
088c			endm  
# End of macro DMARK
088c					CALLMONITOR 
088c cd 65 16			call break_point_state  
088f				endm  
# End of macro CALLMONITOR
088f				endif 
088f cd 2f 0d			call ishlzero 
0892			;	ld a, l 
0892			;	add h 
0892			;	cp 0 
0892 c8				ret z			; block not found so EOF 
0893			 
0893				; hl contains page number to load 
0893 d1				pop de   ; get storage 
0894 d5				push de 
0895				if DEBUG_STORESE 
0895					DMARK "SRg" 
0895 f5				push af  
0896 3a aa 08			ld a, (.dmark)  
0899 32 bd fb			ld (debug_mark),a  
089c 3a ab 08			ld a, (.dmark+1)  
089f 32 be fb			ld (debug_mark+1),a  
08a2 3a ac 08			ld a, (.dmark+2)  
08a5 32 bf fb			ld (debug_mark+2),a  
08a8 18 03			jr .pastdmark  
08aa ..			.dmark: db "SRg"  
08ad f1			.pastdmark: pop af  
08ae			endm  
# End of macro DMARK
08ae					CALLMONITOR 
08ae cd 65 16			call break_point_state  
08b1				endm  
# End of macro CALLMONITOR
08b1				endif 
08b1 cd 09 03			call storage_read_block 
08b4			 
08b4			 
08b4			; TODO if block has no zeros then need to read next block  
08b4			 
08b4			 
08b4					 
08b4 e1				pop hl 		 ; return start of data to show as not EOF 
08b5 23				inc hl   ; past file id 
08b6 23				inc hl   ; past ext 
08b7				if DEBUG_STORESE 
08b7					DMARK "SRe" 
08b7 f5				push af  
08b8 3a cc 08			ld a, (.dmark)  
08bb 32 bd fb			ld (debug_mark),a  
08be 3a cd 08			ld a, (.dmark+1)  
08c1 32 be fb			ld (debug_mark+1),a  
08c4 3a ce 08			ld a, (.dmark+2)  
08c7 32 bf fb			ld (debug_mark+2),a  
08ca 18 03			jr .pastdmark  
08cc ..			.dmark: db "SRe"  
08cf f1			.pastdmark: pop af  
08d0			endm  
# End of macro DMARK
08d0					CALLMONITOR 
08d0 cd 65 16			call break_point_state  
08d3				endm  
# End of macro CALLMONITOR
08d3				endif 
08d3 c9					ret 
08d4			 
08d4			 
08d4			 
08d4			; 
08d4			; Append File 
08d4			; 
08d4			; hl - file id to locate 
08d4			; de - pointer to (multi block) string to write 
08d4			 
08d4			 
08d4			storage_append: 
08d4				; hl -  file id to append to 
08d4				; de - string to append 
08d4			 
08d4 d5				push de 
08d5				 
08d5				if DEBUG_STORESE 
08d5					DMARK "AP1" 
08d5 f5				push af  
08d6 3a ea 08			ld a, (.dmark)  
08d9 32 bd fb			ld (debug_mark),a  
08dc 3a eb 08			ld a, (.dmark+1)  
08df 32 be fb			ld (debug_mark+1),a  
08e2 3a ec 08			ld a, (.dmark+2)  
08e5 32 bf fb			ld (debug_mark+2),a  
08e8 18 03			jr .pastdmark  
08ea ..			.dmark: db "AP1"  
08ed f1			.pastdmark: pop af  
08ee			endm  
# End of macro DMARK
08ee					CALLMONITOR 
08ee cd 65 16			call break_point_state  
08f1				endm  
# End of macro CALLMONITOR
08f1				endif 
08f1			 
08f1 7d				ld a, l 
08f2 32 e1 f9			ld (store_tmpid), a 
08f5			 
08f5				; get file header  
08f5			 
08f5 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08f7 3a e1 f9			ld a, (store_tmpid) 
08fa 5f				ld e, a 
08fb			 
08fb 21 40 00				ld hl, STORE_BLOCK_PHY 
08fe cd 2a 06				call storage_findnextid 
0901			 
0901 22 d2 f9			ld (store_tmppageid), hl 
0904			 
0904				; TODO handle file id not found 
0904			 
0904				if DEBUG_STORESE 
0904					DMARK "AP2" 
0904 f5				push af  
0905 3a 19 09			ld a, (.dmark)  
0908 32 bd fb			ld (debug_mark),a  
090b 3a 1a 09			ld a, (.dmark+1)  
090e 32 be fb			ld (debug_mark+1),a  
0911 3a 1b 09			ld a, (.dmark+2)  
0914 32 bf fb			ld (debug_mark+2),a  
0917 18 03			jr .pastdmark  
0919 ..			.dmark: db "AP2"  
091c f1			.pastdmark: pop af  
091d			endm  
# End of macro DMARK
091d					CALLMONITOR 
091d cd 65 16			call break_point_state  
0920				endm  
# End of macro CALLMONITOR
0920				endif 
0920			 
0920				; update file extent count 
0920			 
0920 11 e8 f9			ld de, store_page 
0923			 
0923 cd 09 03			call storage_read_block 
0926			 
0926				if DEBUG_STORESE 
0926					DMARK "AP3" 
0926 f5				push af  
0927 3a 3b 09			ld a, (.dmark)  
092a 32 bd fb			ld (debug_mark),a  
092d 3a 3c 09			ld a, (.dmark+1)  
0930 32 be fb			ld (debug_mark+1),a  
0933 3a 3d 09			ld a, (.dmark+2)  
0936 32 bf fb			ld (debug_mark+2),a  
0939 18 03			jr .pastdmark  
093b ..			.dmark: db "AP3"  
093e f1			.pastdmark: pop af  
093f			endm  
# End of macro DMARK
093f					CALLMONITOR 
093f cd 65 16			call break_point_state  
0942				endm  
# End of macro CALLMONITOR
0942				endif 
0942			;	ld (store_tmppageid), hl 
0942			 
0942 3a ea f9			ld a, (store_page+2) 
0945 3c				inc a 
0946 32 ea f9			ld (store_page+2), a 
0949 32 e0 f9			ld (store_tmpext), a 
094c				 
094c				if DEBUG_STORESE 
094c					DMARK "AP3" 
094c f5				push af  
094d 3a 61 09			ld a, (.dmark)  
0950 32 bd fb			ld (debug_mark),a  
0953 3a 62 09			ld a, (.dmark+1)  
0956 32 be fb			ld (debug_mark+1),a  
0959 3a 63 09			ld a, (.dmark+2)  
095c 32 bf fb			ld (debug_mark+2),a  
095f 18 03			jr .pastdmark  
0961 ..			.dmark: db "AP3"  
0964 f1			.pastdmark: pop af  
0965			endm  
# End of macro DMARK
0965					CALLMONITOR 
0965 cd 65 16			call break_point_state  
0968				endm  
# End of macro CALLMONITOR
0968				endif 
0968 2a d2 f9			ld hl, (store_tmppageid) 
096b 11 e8 f9			ld de, store_page 
096e cd 6e 03			call storage_write_block 
0971			 
0971				; find free block 
0971			 
0971 11 00 00			ld de, 0			 ; file extent to locate 
0974			 
0974 21 40 00				ld hl, STORE_BLOCK_PHY 
0977 cd 2a 06				call storage_findnextid 
097a			 
097a					; TODO handle no space left 
097a					 
097a 22 d2 f9				ld (store_tmppageid), hl 
097d			 
097d				if DEBUG_STORESE 
097d					DMARK "AP4" 
097d f5				push af  
097e 3a 92 09			ld a, (.dmark)  
0981 32 bd fb			ld (debug_mark),a  
0984 3a 93 09			ld a, (.dmark+1)  
0987 32 be fb			ld (debug_mark+1),a  
098a 3a 94 09			ld a, (.dmark+2)  
098d 32 bf fb			ld (debug_mark+2),a  
0990 18 03			jr .pastdmark  
0992 ..			.dmark: db "AP4"  
0995 f1			.pastdmark: pop af  
0996			endm  
# End of macro DMARK
0996					CALLMONITOR 
0996 cd 65 16			call break_point_state  
0999				endm  
# End of macro CALLMONITOR
0999				endif 
0999					; init the buffer with zeros so we can id if the buffer is full or not 
0999			 
0999 e5					push hl 
099a c5					push bc 
099b			 
099b 21 e8 f9				ld hl, store_page 
099e 06 40				ld b, STORE_BLOCK_PHY 
09a0 3e 00				ld a, 0 
09a2 77			.zeroblock:	ld (hl), a 
09a3 23					inc hl 
09a4 10 fc				djnz .zeroblock 
09a6			 
09a6 c1					pop bc 
09a7 e1					pop hl 
09a8			 
09a8					; construct block 
09a8			 
09a8 3a e1 f9				ld a, (store_tmpid) 
09ab 32 e8 f9				ld (store_page), a   ; file id 
09ae 3a e0 f9				ld a, (store_tmpext)   ; extent for this block 
09b1 32 e9 f9				ld (store_page+1), a 
09b4			 
09b4 e1					pop hl    ; get string to write 
09b5 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09b7 11 ea f9				ld de, store_page+2 
09ba			 
09ba				if DEBUG_STORESE 
09ba					DMARK "AP5" 
09ba f5				push af  
09bb 3a cf 09			ld a, (.dmark)  
09be 32 bd fb			ld (debug_mark),a  
09c1 3a d0 09			ld a, (.dmark+1)  
09c4 32 be fb			ld (debug_mark+1),a  
09c7 3a d1 09			ld a, (.dmark+2)  
09ca 32 bf fb			ld (debug_mark+2),a  
09cd 18 03			jr .pastdmark  
09cf ..			.dmark: db "AP5"  
09d2 f1			.pastdmark: pop af  
09d3			endm  
# End of macro DMARK
09d3					CALLMONITOR 
09d3 cd 65 16			call break_point_state  
09d6				endm  
# End of macro CALLMONITOR
09d6				endif 
09d6			 
09d6			 
09d6			 
09d6					; fill buffer with data until end of string or full block 
09d6			 
09d6 7e			.appd:		ld a, (hl) 
09d7 12					ld (de), a 
09d8 fe 00				cp 0 
09da 28 04				jr z, .appdone 
09dc 23					inc hl 
09dd 13					inc de 
09de 10 f6				djnz .appd 
09e0			 
09e0 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09e1 f5					push af   		; save last byte dumped 
09e2			 
09e2			 
09e2 2a d2 f9			ld hl, (store_tmppageid) 
09e5 11 e8 f9			ld de, store_page 
09e8				if DEBUG_STORESE 
09e8					DMARK "AP6" 
09e8 f5				push af  
09e9 3a fd 09			ld a, (.dmark)  
09ec 32 bd fb			ld (debug_mark),a  
09ef 3a fe 09			ld a, (.dmark+1)  
09f2 32 be fb			ld (debug_mark+1),a  
09f5 3a ff 09			ld a, (.dmark+2)  
09f8 32 bf fb			ld (debug_mark+2),a  
09fb 18 03			jr .pastdmark  
09fd ..			.dmark: db "AP6"  
0a00 f1			.pastdmark: pop af  
0a01			endm  
# End of macro DMARK
0a01					CALLMONITOR 
0a01 cd 65 16			call break_point_state  
0a04				endm  
# End of macro CALLMONITOR
0a04				endif 
0a04 cd 6e 03				call storage_write_block 
0a07			 
0a07			 
0a07				; was that a full block of data written? 
0a07				; any more to write out? 
0a07			 
0a07				; if yes then set vars and jump to start of function again 
0a07			 
0a07 f1					pop af 
0a08 d1					pop de 
0a09			 
0a09 fe 00				cp 0		 ; no, string was fully written 
0a0b c8					ret z 
0a0c			 
0a0c					; setup vars for next cycle 
0a0c			 
0a0c 3a e1 f9				ld a, (store_tmpid) 
0a0f 6f					ld l, a 
0a10 26 00				ld h, 0 
0a12			 
0a12 c3 d4 08			 	jp storage_append	 ; yes, need to write out some more 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			if DEBUG_STORECF 
0a15			storageput:	 
0a15					ret 
0a15			storageread: 
0a15					ld hl, store_page 
0a15					ld b, 200 
0a15					ld a,0 
0a15			.src:		ld (hl),a 
0a15					inc hl 
0a15					djnz .src 
0a15					 
0a15			 
0a15					ld de, 0 
0a15					ld bc, 1 
0a15					ld hl, store_page 
0a15					call cfRead 
0a15			 
0a15				call cfGetError 
0a15				ld hl,scratch 
0a15				call hexout 
0a15				ld hl, scratch+2 
0a15				ld a, 0 
0a15				ld (hl),a 
0a15				ld de, scratch 
0a15				ld a,display_row_1 
0a15				call str_at_display 
0a15				call update_display 
0a15			 
0a15					ld hl, store_page 
0a15					ld (os_cur_ptr),hl 
0a15			 
0a15					ret 
0a15			endif 
0a15			 
0a15			 
0a15			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a15			 
0a15			storage_clear_page: 
0a15 e5				push hl 
0a16 d5				push de 
0a17 c5				push bc 
0a18 21 e8 f9			ld hl, store_page 
0a1b 3e 00			ld a, 0 
0a1d 77				ld (hl), a 
0a1e			 
0a1e 11 e9 f9			ld de, store_page+1 
0a21 01 40 00			ld bc, STORE_BLOCK_PHY 
0a24			 
0a24 ed b0			ldir 
0a26				 
0a26 c1				pop bc 
0a27 d1				pop de 
0a28 e1				pop hl 
0a29 c9				ret 
0a2a			 
0a2a			; eof 
# End of file firmware_storage.asm
0a2a			  
0a2a			; support routines for above hardware abstraction layer  
0a2a			  
0a2a			include "firmware_general.asm"        ; general support functions  
0a2a			 
0a2a			; word look up 
0a2a			 
0a2a			; in 
0a2a			; a is the index 
0a2a			; hl is pointer start of array 
0a2a			; 
0a2a			; returns 
0a2a			; hl to the word 
0a2a			; 
0a2a			 
0a2a			table_lookup:  
0a2a d5					push de 
0a2b eb					ex de, hl 
0a2c			 
0a2c 6f					ld l, a 
0a2d 26 00				ld h, 0 
0a2f 29					add hl, hl 
0a30 19					add hl, de 
0a31 7e					ld a, (hl) 
0a32 23					inc hl 
0a33 66					ld h,(hl) 
0a34 6f					ld l, a 
0a35			 
0a35 d1					pop de 
0a36 c9					ret 
0a37			 
0a37			; Delay loops 
0a37			 
0a37			 
0a37			 
0a37			aDelayInMS: 
0a37 c5				push bc 
0a38 47				ld b,a 
0a39			msdelay: 
0a39 c5				push bc 
0a3a				 
0a3a			 
0a3a 01 41 00			ld bc,041h 
0a3d cd 55 0a			call delayloop 
0a40 c1				pop bc 
0a41 05				dec b 
0a42 20 f5			jr nz,msdelay 
0a44			 
0a44			;if CPU_CLOCK_8MHZ 
0a44			;msdelay8: 
0a44			;	push bc 
0a44			;	 
0a44			; 
0a44			;	ld bc,041h 
0a44			;	call delayloop 
0a44			;	pop bc 
0a44			;	dec b 
0a44			;	jr nz,msdelay8 
0a44			;endif 
0a44			 
0a44			 
0a44 c1				pop bc 
0a45 c9				ret 
0a46			 
0a46			 
0a46			delay250ms: 
0a46				;push de 
0a46 01 00 40			ld bc, 04000h 
0a49 c3 55 0a			jp delayloop 
0a4c			delay500ms: 
0a4c				;push de 
0a4c 01 00 80			ld bc, 08000h 
0a4f c3 55 0a			jp delayloop 
0a52			delay1s: 
0a52				;push bc 
0a52			   ; Clobbers A, d and e 
0a52 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a55			delayloop: 
0a55 c5			    push bc 
0a56			 
0a56			if BASE_CPM 
0a56				ld bc, CPM_DELAY_TUNE 
0a56			.cpmloop: 
0a56				push bc 
0a56			 
0a56			endif 
0a56			 
0a56			 
0a56			 
0a56			delayloopi: 
0a56			;	push bc 
0a56			;.dl: 
0a56 cb 47		    bit     0,a    	; 8 
0a58 cb 47		    bit     0,a    	; 8 
0a5a cb 47		    bit     0,a    	; 8 
0a5c e6 ff		    and     255  	; 7 
0a5e 0b			    dec     bc      	; 6 
0a5f 79			    ld      a,c     	; 4 
0a60 b0			    or      b     	; 4 
0a61 c2 56 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a64			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a64				;pop de 
0a64			;pop bc 
0a64			 
0a64			if BASE_CPM 
0a64				pop bc 
0a64				 
0a64			    dec     bc      	; 6 
0a64			    ld      a,c     	; 4 
0a64			    or      b     	; 4 
0a64			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a64				 
0a64			 
0a64			endif 
0a64			;if CPU_CLOCK_8MHZ 
0a64			;    pop bc 
0a64			;    push bc 
0a64			;.dl8: 
0a64			;    bit     0,a    	; 8 
0a64			;    bit     0,a    	; 8 
0a64			;    bit     0,a    	; 8 
0a64			;    and     255  	; 7 
0a64			;    dec     bc      	; 6 
0a64			;    ld      a,c     	; 4 
0a64			;    or      b     	; 4 
0a64			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a64			;endif 
0a64			 
0a64			;if CPU_CLOCK_10MHZ 
0a64			;    pop bc 
0a64			;    push bc 
0a64			;.dl8: 
0a64			;    bit     0,a    	; 8 
0a64			;    bit     0,a    	; 8 
0a64			;    bit     0,a    	; 8 
0a64			;    and     255  	; 7 
0a64			;    dec     bc      	; 6 
0a64			;    ld      a,c     	; 4 
0a64			;    or      b     	; 4 
0a64			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a64			;endif 
0a64 c1			    pop bc 
0a65			 
0a65 c9				ret 
0a66			 
0a66			 
0a66			 
0a66			; eof 
# End of file firmware_general.asm
0a66			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a66			; display routines that use the physical hardware abstraction layer 
0a66			 
0a66			 
0a66			; information window 
0a66			 
0a66			; pass hl with 1st string to display 
0a66			; pass de with 2nd string to display 
0a66			 
0a66			info_panel: 
0a66 e5				push hl 
0a67			 
0a67 2a 5e fa			ld hl, (display_fb_active) 
0a6a e5				push hl    ; future de destination 
0a6b 21 53 fb				ld hl, display_fb0 
0a6e 22 5e fa				ld (display_fb_active), hl 
0a71			 
0a71 cd d2 0a			call clear_display 
0a74			 
0a74			 
0a74 3e 2d			ld a, display_row_3 + 5 
0a76 cd e5 0a			call str_at_display 
0a79			 
0a79 e1				pop hl 
0a7a d1				pop de 
0a7b			 
0a7b e5				push hl 
0a7c			 
0a7c			 
0a7c 3e 19			ld a, display_row_2 + 5 
0a7e cd e5 0a			call str_at_display 
0a81			 
0a81			 
0a81 cd f5 0a			call update_display 
0a84 cd 6a 1b			call next_page_prompt 
0a87 cd d2 0a			call clear_display 
0a8a			 
0a8a				 
0a8a 21 02 fb				ld hl, display_fb1 
0a8d 22 5e fa				ld (display_fb_active), hl 
0a90 cd f5 0a			call update_display 
0a93			 
0a93			 
0a93 c9				ret 
0a94			 
0a94			 
0a94			 
0a94			 
0a94			; TODO windowing? 
0a94			 
0a94			; TODO scroll line up 
0a94			 
0a94			scroll_up: 
0a94			 
0a94 e5				push hl 
0a95 d5				push de 
0a96 c5				push bc 
0a97			 
0a97				; get frame buffer  
0a97			 
0a97 2a 5e fa			ld hl, (display_fb_active) 
0a9a e5				push hl    ; future de destination 
0a9b			 
0a9b 11 14 00			ld  de, display_cols 
0a9e 19				add hl, de 
0a9f			 
0a9f d1				pop de 
0aa0			 
0aa0				;ex de, hl 
0aa0 01 4f 00			ld bc, display_fb_len -1  
0aa3			;if DEBUG_FORTH_WORDS 
0aa3			;	DMARK "SCL" 
0aa3			;	CALLMONITOR 
0aa3			;endif	 
0aa3 ed b0			ldir 
0aa5			 
0aa5				; wipe bottom row 
0aa5			 
0aa5			 
0aa5 2a 5e fa			ld hl, (display_fb_active) 
0aa8 11 50 00			ld de, display_cols*display_rows 
0aab 19				add hl, de 
0aac 06 14			ld b, display_cols 
0aae 3e 20			ld a, ' ' 
0ab0			.scwipe: 
0ab0 77				ld (hl), a 
0ab1 2b				dec hl 
0ab2 10 fc			djnz .scwipe 
0ab4			 
0ab4				;pop hl 
0ab4			 
0ab4 c1				pop bc 
0ab5 d1				pop de 
0ab6 e1				pop hl 
0ab7			 
0ab7 c9				ret 
0ab8			 
0ab8			 
0ab8			;scroll_upo: 
0ab8			;	ld de, display_row_1 
0ab8			 ;	ld hl, display_row_2 
0ab8			;	ld bc, display_cols 
0ab8			;	ldir 
0ab8			;	ld de, display_row_2 
0ab8			 ;	ld hl, display_row_3 
0ab8			;	ld bc, display_cols 
0ab8			;	ldir 
0ab8			;	ld de, display_row_3 
0ab8			 ;	ld hl, display_row_4 
0ab8			;	ld bc, display_cols 
0ab8			;	ldir 
0ab8			 
0ab8			; TODO clear row 4 
0ab8			 
0ab8			;	ret 
0ab8			 
0ab8				 
0ab8			scroll_down: 
0ab8			 
0ab8 e5				push hl 
0ab9 d5				push de 
0aba c5				push bc 
0abb			 
0abb				; get frame buffer  
0abb			 
0abb 2a 5e fa			ld hl, (display_fb_active) 
0abe			 
0abe 11 4f 00			ld de, display_fb_len - 1 
0ac1 19				add hl, de 
0ac2			 
0ac2 e5			push hl    ; future de destination 
0ac3			 
0ac3 11 14 00			ld  de, display_cols 
0ac6 ed 52			sbc hl, de 
0ac8			 
0ac8			 
0ac8 d1				pop de 
0ac9			 
0ac9			;	ex de, hl 
0ac9 01 4f 00			ld bc, display_fb_len -1  
0acc			 
0acc			 
0acc				 
0acc			 
0acc ed b0			ldir 
0ace			 
0ace				; wipe bottom row 
0ace			 
0ace			 
0ace			;	ld hl, (display_fb_active) 
0ace			;;	ld de, display_cols*display_rows 
0ace			;;	add hl, de 
0ace			;	ld b, display_cols 
0ace			;	ld a, ' ' 
0ace			;.scwiped: 
0ace			;	ld (hl), a 
0ace			;	dec hl 
0ace			;	djnz .scwiped 
0ace			 
0ace				;pop hl 
0ace			 
0ace c1				pop bc 
0acf d1				pop de 
0ad0 e1				pop hl 
0ad1			 
0ad1 c9				ret 
0ad2			;scroll_down: 
0ad2			;	ld de, display_row_4 
0ad2			;	ld hl, display_row_3 
0ad2			;	ld bc, display_cols 
0ad2			;	ldir 
0ad2			;	ld de, display_row_3 
0ad2			; 	ld hl, display_row_2 
0ad2			;	ld bc, display_cols 
0ad2			;	ldir 
0ad2			;	ld de, display_row_2 
0ad2			;	ld hl, display_row_1 
0ad2			;	ld bc, display_cols 
0ad2			;	ldir 
0ad2			;;; TODO clear row 1 
0ad2			;	ret 
0ad2			 
0ad2			 
0ad2			 
0ad2			 
0ad2			 
0ad2			; clear active frame buffer 
0ad2			 
0ad2			clear_display: 
0ad2 3e 20			ld a, ' ' 
0ad4 c3 d7 0a			jp fill_display 
0ad7			 
0ad7			; fill active frame buffer with a char in A 
0ad7			 
0ad7			fill_display: 
0ad7 06 50			ld b,display_fb_len 
0ad9 2a 5e fa			ld hl, (display_fb_active) 
0adc 77			.fd1:	ld (hl),a 
0add 23				inc hl 
0ade 10 fc			djnz .fd1 
0ae0 23				inc hl 
0ae1 3e 00			ld a,0 
0ae3 77				ld (hl),a 
0ae4			 
0ae4			 
0ae4 c9				ret 
0ae5			; Write string (DE) at pos (A) to active frame buffer 
0ae5			 
0ae5 2a 5e fa		str_at_display:    ld hl,(display_fb_active) 
0ae8 06 00					ld b,0 
0aea 4f					ld c,a 
0aeb 09					add hl,bc 
0aec 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0aed b7			            OR   A              ;Null terminator? 
0aee c8			            RET  Z              ;Yes, so finished 
0aef 77					ld (hl),a 
0af0 23				inc hl 
0af1 13			            INC  DE             ;Point to next character 
0af2 18 f8		            JR   .sad1     ;Repeat 
0af4 c9					ret 
0af5			 
0af5			; using current frame buffer write to physical display 
0af5			 
0af5			update_display: 
0af5 e5				push hl 
0af6 2a 5e fa			ld hl, (display_fb_active) 
0af9 cd a0 64			call write_display 
0afc e1				pop hl 
0afd c9				ret 
0afe			 
0afe			; TODO scrolling 
0afe			 
0afe			 
0afe			; move cursor right one char 
0afe			cursor_right: 
0afe			 
0afe				; TODO shift right 
0afe				; TODO if beyond max col 
0afe				; TODO       cursor_next_line 
0afe			 
0afe c9				ret 
0aff			 
0aff			 
0aff			cursor_next_line: 
0aff				; TODO first char 
0aff				; TODO line down 
0aff				; TODO if past last row 
0aff				; TODO    scroll up 
0aff			 
0aff c9				ret 
0b00			 
0b00			cursor_left: 
0b00				; TODO shift left 
0b00				; TODO if beyond left  
0b00				; TODO     cursor prev line 
0b00				 
0b00 c9				ret 
0b01			 
0b01			cursor_prev_line: 
0b01				; TODO last char 
0b01				; TODO line up 
0b01				; TODO if past first row 
0b01				; TODO   scroll down 
0b01			 
0b01 c9				ret 
0b02			 
0b02			 
0b02			cout: 
0b02				; A - char 
0b02 c9				ret 
0b03			 
0b03			 
0b03			; Display a menu and allow item selection (optional toggle items) 
0b03			; 
0b03			; format: 
0b03			; hl pointer to word array with zero term for items 
0b03			; e.g.    db item1 
0b03			;         db .... 
0b03			;         db 0 
0b03			; 
0b03			; a = starting menu item  
0b03			; 
0b03			; de = pointer item toggle array   (todo) 
0b03			; 
0b03			; returns item selected in a 1-... 
0b03			; returns 0 if back button pressed 
0b03			; 
0b03			; NOTE: Uses system frame buffer to display 
0b03			; 
0b03			; LEFT, Q = go back 
0b03			; RIGHT, SPACE, CR = select 
0b03			; UP, A - Up 
0b03			; DOWN, Z - Down 
0b03			 
0b03			 
0b03			 
0b03			 
0b03			 
0b03			menu: 
0b03			 
0b03					; keep array pointer 
0b03			 
0b03 22 e6 f9				ld (store_tmp1), hl 
0b06 32 e4 f9				ld (store_tmp2), a 
0b09			 
0b09					; check for key bounce 
0b09			 
0b09			if BASE_KEV 
0b09			 
0b09 cd 55 66		.mbounce:	call cin 
0b0c fe 00				cp 0 
0b0e 20 f9				jr nz, .mbounce 
0b10			endif 
0b10					; for ease use ex 
0b10			 
0b10					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0b10 21 53 fb				ld hl, display_fb0 
0b13 22 5e fa				ld (display_fb_active), hl 
0b16			 
0b16 cd d2 0a		.mloop:		call clear_display 
0b19 cd f5 0a				call update_display 
0b1c			 
0b1c					; draw selection id '>' at 1 
0b1c			 
0b1c					; init start of list display 
0b1c			 
0b1c 3e 05				ld a, 5 
0b1e 32 e2 f9				ld (store_tmp3), a   ; display row count 
0b21 3a e4 f9				ld a,( store_tmp2) 
0b24 32 e5 f9				ld (store_tmp2+1), a   ; display item count 
0b27			 
0b27					 
0b27			.mitem:	 
0b27			 
0b27			 
0b27 3a e5 f9				ld a,(store_tmp2+1) 
0b2a 6f					ld l, a 
0b2b 26 00				ld h, 0 
0b2d 29					add hl, hl 
0b2e ed 5b e6 f9			ld de, (store_tmp1) 
0b32 19					add hl, de 
0b33 7e					ld a, (hl) 
0b34 23					inc hl 
0b35 66					ld h,(hl) 
0b36 6f					ld l, a 
0b37			 
0b37 cd 2f 0d				call ishlzero 
0b3a 28 1a				jr z, .mdone 
0b3c			 
0b3c eb					ex de, hl 
0b3d 3a e2 f9				ld a, (store_tmp3) 
0b40 cd e5 0a				call str_at_display 
0b43					 
0b43			 
0b43					; next item 
0b43 3a e5 f9				ld a, (store_tmp2+1) 
0b46 3c					inc a 
0b47 32 e5 f9				ld (store_tmp2+1), a   ; display item count 
0b4a			 
0b4a			 		; next row 
0b4a			 
0b4a 3a e2 f9				ld a, (store_tmp3) 
0b4d c6 14				add display_cols 
0b4f 32 e2 f9				ld (store_tmp3), a 
0b52			 
0b52					; at end of screen? 
0b52			 
0b52 fe 10				cp display_rows*4 
0b54 20 d1				jr nz, .mitem 
0b56			 
0b56			 
0b56			.mdone: 
0b56 cd 2f 0d				call ishlzero 
0b59 28 08				jr z, .nodn 
0b5b			 
0b5b 3e 3c				ld a, display_row_4 
0b5d 11 dc 0b				ld de, .mdown 
0b60 cd e5 0a				call str_at_display 
0b63			 
0b63					; draw options to fill the screens with active item on line 1 
0b63					; if current option is 2 or more then display ^ in top 
0b63			 
0b63 3a e4 f9		.nodn:		ld a, (store_tmp2) 
0b66 fe 00				cp 0 
0b68 28 08				jr z, .noup 
0b6a			 
0b6a 3e 00				ld a, 0 
0b6c 11 da 0b				ld de, .mup 
0b6f cd e5 0a				call str_at_display 
0b72			 
0b72 3e 02		.noup:		ld a, 2 
0b74 11 d8 0b				ld de, .msel 
0b77 cd e5 0a				call str_at_display 
0b7a			 
0b7a					; if current option + 1 is not null then display V in bottom 
0b7a					; get key 
0b7a cd f5 0a				call update_display 
0b7d			 
0b7d			 
0b7d					; handle key 
0b7d			 
0b7d cd 44 66				call cin_wait 
0b80			 
0b80 fe 05				cp KEY_UP 
0b82 28 2b				jr z, .mgoup 
0b84 fe 61				cp 'a' 
0b86 28 27				jr z, .mgoup 
0b88 fe 0a				cp KEY_DOWN 
0b8a 28 32				jr z, .mgod 
0b8c fe 7a				cp 'z' 
0b8e 28 2e				jr z, .mgod 
0b90 fe 20				cp ' ' 
0b92 28 34				jr z, .goend 
0b94 fe 0c				cp KEY_RIGHT 
0b96 28 30				jr z, .goend 
0b98 fe 0d				cp KEY_CR 
0b9a 28 2c				jr z, .goend 
0b9c fe 71				cp 'q' 
0b9e 28 0b				jr z, .goback 
0ba0			 
0ba0 fe 0b				cp KEY_LEFT 
0ba2 28 07				jr z, .goback 
0ba4 fe 08				cp KEY_BS 
0ba6 28 03				jr z, .goback 
0ba8 c3 16 0b				jp .mloop 
0bab			 
0bab			.goback: 
0bab 3e 00			ld a, 0 
0bad 18 1d			jr .goend2 
0baf			 
0baf				; move up one 
0baf			.mgoup: 
0baf 3a e4 f9				ld a, (store_tmp2) 
0bb2 fe 00				cp 0 
0bb4 ca 16 0b				jp z, .mloop 
0bb7 3d					dec a 
0bb8 32 e4 f9				ld (store_tmp2), a 
0bbb c3 16 0b				jp .mloop 
0bbe			 
0bbe				; move down one 
0bbe			.mgod: 
0bbe 3a e4 f9				ld a, (store_tmp2) 
0bc1 3c					inc a 
0bc2 32 e4 f9				ld (store_tmp2), a 
0bc5 c3 16 0b				jp .mloop 
0bc8			 
0bc8			 
0bc8			.goend: 
0bc8					; get selected item number 
0bc8			 
0bc8 3a e4 f9				ld a, (store_tmp2) 
0bcb 3c					inc a 
0bcc			 
0bcc			.goend2: 
0bcc f5					push af 
0bcd			 
0bcd					; restore active fb 
0bcd					; TODO BUG assumes fb1 
0bcd			 
0bcd 21 02 fb				ld hl, display_fb1 
0bd0 22 5e fa				ld (display_fb_active), hl 
0bd3			 
0bd3					; restore main regs 
0bd3			 
0bd3			 
0bd3 cd f5 0a				call update_display 
0bd6			 
0bd6 f1					pop af 
0bd7			 
0bd7 c9				ret 
0bd8			 
0bd8 .. 00		.msel:   db ">",0 
0bda .. 00		.mup:   db "^",0 
0bdc .. 00		.mdown:   db "v",0 
0bde			 
0bde			 
0bde			; eof 
0bde			 
# End of file firmware_display.asm
0bde			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0bde			; random number generators 
0bde			 
0bde			 
0bde			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0bde			 
0bde			 
0bde			;-----> Generate a random number 
0bde			; output a=answer 0<=a<=255 
0bde			; all registers are preserved except: af 
0bde			random: 
0bde e5			        push    hl 
0bdf d5			        push    de 
0be0 2a 40 fa		        ld      hl,(randData) 
0be3 ed 5f		        ld      a,r 
0be5 57			        ld      d,a 
0be6 5e			        ld      e,(hl) 
0be7 19			        add     hl,de 
0be8 85			        add     a,l 
0be9 ac			        xor     h 
0bea 22 40 fa		        ld      (randData),hl 
0bed d1			        pop     de 
0bee e1			        pop     hl 
0bef c9			        ret 
0bf0			 
0bf0			 
0bf0			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0bf0			 
0bf0			 
0bf0			 
0bf0			;------LFSR------ 
0bf0			;James Montelongo 
0bf0			;optimized by Spencer Putt 
0bf0			;out: 
0bf0			; a = 8 bit random number 
0bf0			RandLFSR: 
0bf0 21 46 fa		        ld hl,LFSRSeed+4 
0bf3 5e			        ld e,(hl) 
0bf4 23			        inc hl 
0bf5 56			        ld d,(hl) 
0bf6 23			        inc hl 
0bf7 4e			        ld c,(hl) 
0bf8 23			        inc hl 
0bf9 7e			        ld a,(hl) 
0bfa 47			        ld b,a 
0bfb cb 13		        rl e  
0bfd cb 12			rl d 
0bff cb 11		        rl c  
0c01 17				rla 
0c02 cb 13		        rl e  
0c04 cb 12			rl d 
0c06 cb 11		        rl c  
0c08 17				rla 
0c09 cb 13		        rl e  
0c0b cb 12			rl d 
0c0d cb 11		        rl c  
0c0f 17				rla 
0c10 67			        ld h,a 
0c11 cb 13		        rl e  
0c13 cb 12			rl d 
0c15 cb 11		        rl c  
0c17 17				rla 
0c18 a8			        xor b 
0c19 cb 13		        rl e  
0c1b cb 12			rl d 
0c1d ac			        xor h 
0c1e a9			        xor c 
0c1f aa			        xor d 
0c20 21 48 fa		        ld hl,LFSRSeed+6 
0c23 11 49 fa		        ld de,LFSRSeed+7 
0c26 01 07 00		        ld bc,7 
0c29 ed b8		        lddr 
0c2b 12			        ld (de),a 
0c2c c9			        ret 
0c2d			 
0c2d			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0c2d			 
0c2d			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0c2d			 
0c2d			 
0c2d			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0c2d			 
0c2d			prng16: 
0c2d			;Inputs: 
0c2d			;   (seed1) contains a 16-bit seed value 
0c2d			;   (seed2) contains a NON-ZERO 16-bit seed value 
0c2d			;Outputs: 
0c2d			;   HL is the result 
0c2d			;   BC is the result of the LCG, so not that great of quality 
0c2d			;   DE is preserved 
0c2d			;Destroys: 
0c2d			;   AF 
0c2d			;cycle: 4,294,901,760 (almost 4.3 billion) 
0c2d			;160cc 
0c2d			;26 bytes 
0c2d 2a 3a fa		    ld hl,(seed1) 
0c30 44			    ld b,h 
0c31 4d			    ld c,l 
0c32 29			    add hl,hl 
0c33 29			    add hl,hl 
0c34 2c			    inc l 
0c35 09			    add hl,bc 
0c36 22 3a fa		    ld (seed1),hl 
0c39 2a 38 fa		    ld hl,(seed2) 
0c3c 29			    add hl,hl 
0c3d 9f			    sbc a,a 
0c3e e6 2d		    and %00101101 
0c40 ad			    xor l 
0c41 6f			    ld l,a 
0c42 22 38 fa		    ld (seed2),hl 
0c45 09			    add hl,bc 
0c46 c9			    ret 
0c47			 
0c47			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c47			 
0c47			rand32: 
0c47			;Inputs: 
0c47			;   (seed1_0) holds the lower 16 bits of the first seed 
0c47			;   (seed1_1) holds the upper 16 bits of the first seed 
0c47			;   (seed2_0) holds the lower 16 bits of the second seed 
0c47			;   (seed2_1) holds the upper 16 bits of the second seed 
0c47			;   **NOTE: seed2 must be non-zero 
0c47			;Outputs: 
0c47			;   HL is the result 
0c47			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c47			;Destroys: 
0c47			;   AF 
0c47			;Tested and passes all CAcert tests 
0c47			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c47			;it has a period of 18,446,744,069,414,584,320 
0c47			;roughly 18.4 quintillion. 
0c47			;LFSR taps: 0,2,6,7  = 11000101 
0c47			;291cc 
0c47			;seed1_0=$+1 
0c47			;    ld hl,12345 
0c47			;seed1_1=$+1 
0c47			;    ld de,6789 
0c47			;    ld b,h 
0c47			;    ld c,l 
0c47			;    add hl,hl \ rl e \ rl d 
0c47			;    add hl,hl \ rl e \ rl d 
0c47			;    inc l 
0c47			;    add hl,bc 
0c47			;    ld (seed1_0),hl 
0c47			;    ld hl,(seed1_1) 
0c47			;    adc hl,de 
0c47			;    ld (seed1_1),hl 
0c47			;    ex de,hl 
0c47			;seed2_0=$+1 
0c47			;    ld hl,9876 
0c47			;seed2_1=$+1 
0c47			;    ld bc,54321 
0c47			;    add hl,hl \ rl c \ rl b 
0c47			;    ld (seed2_1),bc 
0c47			;    sbc a,a 
0c47			;    and %11000101 
0c47			;    xor l 
0c47			;    ld l,a 
0c47			;    ld (seed2_0),hl 
0c47			;    ex de,hl 
0c47			;    add hl,bc 
0c47			;    ret 
0c47			; 
0c47			 
0c47			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c47			; 20 bytes, 86 cycles (excluding ret) 
0c47			 
0c47			; returns   hl = pseudorandom number 
0c47			; corrupts   a 
0c47			 
0c47			; generates 16-bit pseudorandom numbers with a period of 65535 
0c47			; using the xorshift method: 
0c47			 
0c47			; hl ^= hl << 7 
0c47			; hl ^= hl >> 9 
0c47			; hl ^= hl << 8 
0c47			 
0c47			; some alternative shift triplets which also perform well are: 
0c47			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c47			 
0c47			;  org 32768 
0c47			 
0c47			xrnd: 
0c47 2a 3e fa		  ld hl,(xrandc)       ; seed must not be 0 
0c4a 3e 00		  ld a,0 
0c4c bd			  cp l 
0c4d 20 02		  jr nz, .xrnd1 
0c4f 2e 01		  ld l, 1 
0c51			.xrnd1: 
0c51			 
0c51 7c			  ld a,h 
0c52 1f			  rra 
0c53 7d			  ld a,l 
0c54 1f			  rra 
0c55 ac			  xor h 
0c56 67			  ld h,a 
0c57 7d			  ld a,l 
0c58 1f			  rra 
0c59 7c			  ld a,h 
0c5a 1f			  rra 
0c5b ad			  xor l 
0c5c 6f			  ld l,a 
0c5d ac			  xor h 
0c5e 67			  ld h,a 
0c5f			 
0c5f 22 3e fa		  ld (xrandc),hl 
0c62			 
0c62 c9			  ret 
0c63			;  
0c63			 
0c63			 
0c63			;;;; int maths 
0c63			 
0c63			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c63			; Divide 16-bit values (with 16-bit result) 
0c63			; In: Divide BC by divider DE 
0c63			; Out: BC = result, HL = rest 
0c63			; 
0c63			Div16: 
0c63 21 00 00		    ld hl,0 
0c66 78			    ld a,b 
0c67 06 08		    ld b,8 
0c69			Div16_Loop1: 
0c69 17			    rla 
0c6a ed 6a		    adc hl,hl 
0c6c ed 52		    sbc hl,de 
0c6e 30 01		    jr nc,Div16_NoAdd1 
0c70 19			    add hl,de 
0c71			Div16_NoAdd1: 
0c71 10 f6		    djnz Div16_Loop1 
0c73 17			    rla 
0c74 2f			    cpl 
0c75 47			    ld b,a 
0c76 79			    ld a,c 
0c77 48			    ld c,b 
0c78 06 08		    ld b,8 
0c7a			Div16_Loop2: 
0c7a 17			    rla 
0c7b ed 6a		    adc hl,hl 
0c7d ed 52		    sbc hl,de 
0c7f 30 01		    jr nc,Div16_NoAdd2 
0c81 19			    add hl,de 
0c82			Div16_NoAdd2: 
0c82 10 f6		    djnz Div16_Loop2 
0c84 17			    rla 
0c85 2f			    cpl 
0c86 41			    ld b,c 
0c87 4f			    ld c,a 
0c88 c9			ret 
0c89			 
0c89			 
0c89			;http://z80-heaven.wikidot.com/math 
0c89			; 
0c89			;Inputs: 
0c89			;     DE and A are factors 
0c89			;Outputs: 
0c89			;     A is not changed 
0c89			;     B is 0 
0c89			;     C is not changed 
0c89			;     DE is not changed 
0c89			;     HL is the product 
0c89			;Time: 
0c89			;     342+6x 
0c89			; 
0c89			Mult16: 
0c89			 
0c89 06 08		     ld b,8          ;7           7 
0c8b 21 00 00		     ld hl,0         ;10         10 
0c8e 29			       add hl,hl     ;11*8       88 
0c8f 07			       rlca          ;4*8        32 
0c90 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0c92 19			         add hl,de   ;--         -- 
0c93 10 f9		       djnz $-5      ;13*7+8     99 
0c95 c9			ret 
0c96			 
0c96			; 
0c96			; Square root of 16-bit value 
0c96			; In:  HL = value 
0c96			; Out:  D = result (rounded down) 
0c96			; 
0c96			;Sqr16: 
0c96			;    ld de,#0040 
0c96			;    ld a,l 
0c96			;    ld l,h 
0c96			;    ld h,d 
0c96			;    or a 
0c96			;    ld b,8 
0c96			;Sqr16_Loop: 
0c96			;    sbc hl,de 
0c96			;    jr nc,Sqr16_Skip 
0c96			;    add hl,de 
0c96			;Sqr16_Skip: 
0c96			;    ccf 
0c96			;    rl d 
0c96			;    add a,a 
0c96			;    adc hl,hl 
0c96			;    add a,a 
0c96			;    adc hl,hl 
0c96			;    djnz Sqr16_Loop 
0c96			;    ret 
0c96			; 
0c96			; 
0c96			; Divide 8-bit values 
0c96			; In: Divide E by divider C 
0c96			; Out: A = result, B = rest 
0c96			; 
0c96			Div8: 
0c96 af			    xor a 
0c97 06 08		    ld b,8 
0c99			Div8_Loop: 
0c99 cb 13		    rl e 
0c9b 17			    rla 
0c9c 91			    sub c 
0c9d 30 01		    jr nc,Div8_NoAdd 
0c9f 81			    add a,c 
0ca0			Div8_NoAdd: 
0ca0 10 f7		    djnz Div8_Loop 
0ca2 47			    ld b,a 
0ca3 7b			    ld a,e 
0ca4 17			    rla 
0ca5 2f			    cpl 
0ca6 c9			    ret 
0ca7			 
0ca7			; 
0ca7			; Multiply 8-bit value with a 16-bit value (unrolled) 
0ca7			; In: Multiply A with DE 
0ca7			; Out: HL = result 
0ca7			; 
0ca7			Mult12U: 
0ca7 2e 00		    ld l,0 
0ca9 87			    add a,a 
0caa 30 01		    jr nc,Mult12U_NoAdd0 
0cac 19			    add hl,de 
0cad			Mult12U_NoAdd0: 
0cad 29			    add hl,hl 
0cae 87			    add a,a 
0caf 30 01		    jr nc,Mult12U_NoAdd1 
0cb1 19			    add hl,de 
0cb2			Mult12U_NoAdd1: 
0cb2 29			    add hl,hl 
0cb3 87			    add a,a 
0cb4 30 01		    jr nc,Mult12U_NoAdd2 
0cb6 19			    add hl,de 
0cb7			Mult12U_NoAdd2: 
0cb7 29			    add hl,hl 
0cb8 87			    add a,a 
0cb9 30 01		    jr nc,Mult12U_NoAdd3 
0cbb 19			    add hl,de 
0cbc			Mult12U_NoAdd3: 
0cbc 29			    add hl,hl 
0cbd 87			    add a,a 
0cbe 30 01		    jr nc,Mult12U_NoAdd4 
0cc0 19			    add hl,de 
0cc1			Mult12U_NoAdd4: 
0cc1 29			    add hl,hl 
0cc2 87			    add a,a 
0cc3 30 01		    jr nc,Mult12U_NoAdd5 
0cc5 19			    add hl,de 
0cc6			Mult12U_NoAdd5: 
0cc6 29			    add hl,hl 
0cc7 87			    add a,a 
0cc8 30 01		    jr nc,Mult12U_NoAdd6 
0cca 19			    add hl,de 
0ccb			Mult12U_NoAdd6: 
0ccb 29			    add hl,hl 
0ccc 87			    add a,a 
0ccd d0			    ret nc 
0cce 19			    add hl,de 
0ccf c9			    ret 
0cd0			 
0cd0			; 
0cd0			; Multiply 8-bit value with a 16-bit value (right rotating) 
0cd0			; In: Multiply A with DE 
0cd0			;      Put lowest value in A for most efficient calculation 
0cd0			; Out: HL = result 
0cd0			; 
0cd0			Mult12R: 
0cd0 21 00 00		    ld hl,0 
0cd3			Mult12R_Loop: 
0cd3 cb 3f		    srl a 
0cd5 30 01		    jr nc,Mult12R_NoAdd 
0cd7 19			    add hl,de 
0cd8			Mult12R_NoAdd: 
0cd8 cb 23		    sla e 
0cda cb 12		    rl d 
0cdc b7			    or a 
0cdd c2 d3 0c		    jp nz,Mult12R_Loop 
0ce0 c9			    ret 
0ce1			 
0ce1			; 
0ce1			; Multiply 16-bit values (with 32-bit result) 
0ce1			; In: Multiply BC with DE 
0ce1			; Out: BCHL = result 
0ce1			; 
0ce1			Mult32: 
0ce1 79			    ld a,c 
0ce2 48			    ld c,b 
0ce3 21 00 00		    ld hl,0 
0ce6 06 10		    ld b,16 
0ce8			Mult32_Loop: 
0ce8 29			    add hl,hl 
0ce9 17			    rla 
0cea cb 11		    rl c 
0cec 30 07		    jr nc,Mult32_NoAdd 
0cee 19			    add hl,de 
0cef ce 00		    adc a,0 
0cf1 d2 f5 0c		    jp nc,Mult32_NoAdd 
0cf4 0c			    inc c 
0cf5			Mult32_NoAdd: 
0cf5 10 f1		    djnz Mult32_Loop 
0cf7 41			    ld b,c 
0cf8 4f			    ld c,a 
0cf9 c9			    ret 
0cfa			 
0cfa			 
0cfa			 
0cfa			; 
0cfa			; Multiply 8-bit values 
0cfa			; In:  Multiply H with E 
0cfa			; Out: HL = result 
0cfa			; 
0cfa			Mult8: 
0cfa 16 00		    ld d,0 
0cfc 6a			    ld l,d 
0cfd 06 08		    ld b,8 
0cff			Mult8_Loop: 
0cff 29			    add hl,hl 
0d00 30 01		    jr nc,Mult8_NoAdd 
0d02 19			    add hl,de 
0d03			Mult8_NoAdd: 
0d03 10 fa		    djnz Mult8_Loop 
0d05 c9			    ret 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			;;http://z80-heaven.wikidot.com/math 
0d06			;;This divides DE by BC, storing the result in DE, remainder in HL 
0d06			; 
0d06			;DE_Div_BC:          ;1281-2x, x is at most 16 
0d06			;     ld a,16        ;7 
0d06			;     ld hl,0        ;10 
0d06			;     jp $+5         ;10 
0d06			;.DivLoop: 
0d06			;       add hl,bc    ;-- 
0d06			;       dec a        ;64 
0d06			;       jr z,.DivLoopEnd        ;86 
0d06			; 
0d06			;       sla e        ;128 
0d06			;       rl d         ;128 
0d06			;       adc hl,hl    ;240 
0d06			;       sbc hl,bc    ;240 
0d06			;       jr nc,.DivLoop ;23|21 
0d06			;       inc e        ;-- 
0d06			;       jp .DivLoop+1 
0d06			; 
0d06			;.DivLoopEnd: 
0d06			 
0d06			;HL_Div_C: 
0d06			;Inputs: 
0d06			;     HL is the numerator 
0d06			;     C is the denominator 
0d06			;Outputs: 
0d06			;     A is the remainder 
0d06			;     B is 0 
0d06			;     C is not changed 
0d06			;     DE is not changed 
0d06			;     HL is the quotient 
0d06			; 
0d06			;       ld b,16 
0d06			;       xor a 
0d06			;         add hl,hl 
0d06			;         rla 
0d06			;         cp c 
0d06			;         jr c,$+4 
0d06			;           inc l 
0d06			;           sub c 
0d06			;         djnz $-7 
0d06			 
0d06			; https://plutiedev.com/z80-add-8bit-to-16bit 
0d06			 
0d06			addatohl: 
0d06 85			    add   a, l    ; A = A+L 
0d07 6f			    ld    l, a    ; L = A+L 
0d08 8c			    adc   a, h    ; A = A+L+H+carry 
0d09 95			    sub   l       ; A = H+carry 
0d0a 67			    ld    h, a    ; H = H+carry 
0d0b c9			ret 
0d0c			 
0d0c			addatode: 
0d0c 83			    add   a, e    ; A = A+L 
0d0d 5f			    ld    e, a    ; L = A+L 
0d0e 8a			    adc   a, d    ; A = A+L+H+carry 
0d0f 93			    sub   e       ; A = H+carry 
0d10 57			    ld    d, a    ; H = H+carry 
0d11 c9			ret 
0d12			 
0d12			 
0d12			addatobc: 
0d12 81			    add   a, c    ; A = A+L 
0d13 4f			    ld    c, a    ; L = A+L 
0d14 88			    adc   a, b    ; A = A+L+H+carry 
0d15 91			    sub   c       ; A = H+carry 
0d16 47			    ld    b, a    ; H = H+carry 
0d17 c9			ret 
0d18			 
0d18			subafromhl: 
0d18			   ; If A=0 do nothing 
0d18			    ; Otherwise flip A's sign. Since 
0d18			    ; the upper byte becomes -1, also 
0d18			    ; substract 1 from H. 
0d18 ed 44		    neg 
0d1a ca 23 0d		    jp    z, Skip 
0d1d 25			    dec   h 
0d1e			     
0d1e			    ; Now add the low byte as usual 
0d1e			    ; Two's complement takes care of 
0d1e			    ; ensuring the result is correct 
0d1e 85			    add   a, l 
0d1f 6f			    ld    l, a 
0d20 8c			    adc   a, h 
0d21 95			    sub   l 
0d22 67			    ld    h, a 
0d23			Skip: 
0d23 c9				ret 
0d24			 
0d24			 
0d24			; compare hl and de 
0d24			; returns:  
0d24			; if hl = de, z=1, s=0, c0=0 
0d24			; if hl > de, z=0, s=0, c=0 
0d24			; if hl < de, z=0, s=1, c=1 
0d24			cmp16:	 
0d24 b7				or a 
0d25 ed 52			sbc hl,de 
0d27 e0				ret po 
0d28 7c				ld a,h 
0d29 1f				rra 
0d2a ee 40			xor 01000000B 
0d2c 37				scf 
0d2d 8f				adc a,a 
0d2e c9				ret 
0d2f			 
0d2f			 
0d2f			; test if hl contains zero   - A is destroyed 
0d2f			 
0d2f			ishlzero:    
0d2f b7				or a     ; reset flags 
0d30 7c				ld a, h 
0d31 b5				or l        	 
0d32			 
0d32 c9				ret 
0d33			 
0d33			 
0d33			 
0d33			 
0d33			if FORTH_ENABLE_FLOATMATH 
0d33			;include "float/bbcmath.z80" 
0d33			include "float/lpfpcalc.asm" 
0d33			endif 
0d33			 
0d33			 
0d33			; eof 
0d33			 
# End of file firmware_maths.asm
0d33			include "firmware_strings.asm"   ; string handling  
0d33			 
0d33			 
0d33			; TODO string len 
0d33			; input text string, end on cr with zero term 
0d33			; a offset into frame buffer to start prompt 
0d33			; d is max length 
0d33			; e is display size TODO 
0d33			; c is current cursor position 
0d33			; hl is ptr to where string will be stored 
0d33			 
0d33			 
0d33			; TODO check limit of buffer for new inserts 
0d33			; TODO check insert does not push beyond buffer 
0d33			; TODO scroll in a limited display area 
0d33			; TODO scroll whole screen on page wrap 
0d33			 
0d33			 
0d33			; TODO handle KEY_PREVWORD 
0d33			; TODO handle KEY_NEXTWORD 
0d33			; TODO handle KEY_HOME 
0d33			; TODO handle KEY_END 
0d33			; TODO use LCD cursor? 
0d33			 
0d33 32 b6 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0d36 81					add c 
0d37 32 b4 fb				ld (input_at_cursor),a	; save draw pos of cursor 
0d3a 22 b9 fb				ld (input_start), hl     ; save ptr to buffer 
0d3d 79					ld a, c 
0d3e cd 06 0d				call addatohl 
0d41 22 bb fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0d44 7a					ld a,d 
0d45 32 b8 fb			        ld (input_size), a       ; save length of input area 
0d48 79					ld a, c 
0d49 32 a7 fb				ld (input_cursor),a      ; init cursor start position  
0d4c 7b					ld a,e 
0d4d 32 b7 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d50					 
0d50					 
0d50			 
0d50			;		ld a,(input_ptr) 
0d50			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d50			 
0d50			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d50					; init cursor shape if not set by the cin routines 
0d50 21 56 fa				ld hl, cursor_shape 
0d53 3e ff				ld a, 255 
0d55 77					ld (hl), a 
0d56 23					inc hl 
0d57 3e 00				ld a, 0 
0d59 77					ld (hl), a 
0d5a			 
0d5a 3e 0f				ld a, CUR_BLINK_RATE 
0d5c 32 b2 fb				ld (input_cur_flash), a 
0d5f 3e 01				ld a, 1 
0d61 32 b1 fb				ld (input_cur_onoff),a 
0d64			 
0d64			;	if DEBUG_INPUT 
0d64			;		push af 
0d64			;		ld a, 'I' 
0d64			;		ld (debug_mark),a 
0d64			;		pop af 
0d64			;		CALLMONITOR 
0d64			;	endif 
0d64			.is1:		; main entry loop 
0d64			 
0d64			 
0d64			 
0d64					; pause 1ms 
0d64			 
0d64 3e 01				ld a, 1 
0d66 cd 37 0a				call aDelayInMS 
0d69			 
0d69					; dec flash counter 
0d69 3a b2 fb				ld a, (input_cur_flash) 
0d6c 3d					dec a 
0d6d 32 b2 fb				ld (input_cur_flash), a 
0d70 fe 00				cp 0 
0d72 20 0d				jr nz, .nochgstate 
0d74			 
0d74			 
0d74					; change state 
0d74 3a b1 fb				ld a,(input_cur_onoff) 
0d77 ed 44				neg 
0d79 32 b1 fb				ld (input_cur_onoff),a 
0d7c			 
0d7c			 
0d7c					; reset on change of state 
0d7c 3e 0f				ld a, CUR_BLINK_RATE 
0d7e 32 b2 fb				ld (input_cur_flash), a 
0d81			 
0d81			.nochgstate: 
0d81					 
0d81					 
0d81			 
0d81					; display cursor  
0d81			 
0d81			;		ld hl, (input_start) 
0d81			;		ld a, (input_cursor) 
0d81			;		call addatohl 
0d81			 
0d81					; get char under cursor and replace with cursor 
0d81 2a bb fb		ld hl, (input_ptr) 
0d84			;		ld a, (hl) 
0d84			;		ld (input_under_cursor),a 
0d84			;		ld a, '_' 
0d84			;		ld (hl), a 
0d84			 
0d84					; display string 
0d84			 
0d84 ed 5b b9 fb			ld de, (input_start) 
0d88 3a b6 fb				ld a, (input_at_pos) 
0d8b cd e5 0a				call str_at_display 
0d8e			;	        call update_display 
0d8e			 
0d8e					; find place to put the cursor 
0d8e			;		add h 
0d8e			;		ld l, display_row_1 
0d8e			;		sub l 
0d8e			; (input_at_pos) 
0d8e					;ld c, a 
0d8e			;		ld a, (input_cursor) 
0d8e			;		ld l, (input_at_pos) 
0d8e			;		;ld b, h 
0d8e			;		add l 
0d8e			;		ld (input_at_cursor),a 
0d8e					;ld l,h 
0d8e			 
0d8e			;		ld h, 0 
0d8e			;		ld l,(input_at_pos) 
0d8e			;		ld a, (input_cursor) 
0d8e			;		call addatohl 
0d8e			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0d8e			;		call subafromhl 
0d8e			;		ld a,l 
0d8e			;		ld (input_at_cursor), a 
0d8e			 
0d8e				if DEBUG_INPUT 
0d8e					ld a, (hardware_diag) 
0d8e					cp 0 
0d8e					jr z, .skip_input_diag 
0d8e			 
0d8e					ld a,(input_at_pos) 
0d8e					ld hl, LFSRSeed 
0d8e					call hexout 
0d8e					ld a, (input_cursor) 
0d8e					ld hl, LFSRSeed+2 
0d8e					call hexout 
0d8e					ld a,(input_at_cursor) 
0d8e					ld hl, LFSRSeed+4 
0d8e					call hexout 
0d8e			 
0d8e					ld a,(input_cur_onoff) 
0d8e					ld hl, LFSRSeed+6 
0d8e					call hexout 
0d8e			 
0d8e					ld a,(input_cur_flash) 
0d8e					ld hl, LFSRSeed+8 
0d8e					call hexout 
0d8e			 
0d8e					ld a,(input_len) 
0d8e					ld hl, LFSRSeed+10 
0d8e					call hexout 
0d8e					ld hl, LFSRSeed+12 
0d8e					ld a, 0 
0d8e					ld (hl),a 
0d8e					ld a, display_row_4 
0d8e					ld de, LFSRSeed 
0d8e					call str_at_display 
0d8e					.skip_input_diag: 
0d8e				endif 
0d8e			 
0d8e					; decide on if we are showing the cursor this time round 
0d8e			 
0d8e 3a b1 fb				ld a, (input_cur_onoff) 
0d91 fe ff				cp 255 
0d93 28 13				jr z, .skipcur 
0d95			 
0d95			 
0d95 3a b4 fb				ld a,(input_at_cursor) 
0d98 11 56 fa				ld de, cursor_shape 
0d9b cd e5 0a				call str_at_display 
0d9e			 
0d9e					; save length of current input string 
0d9e 2a b9 fb				ld hl, (input_start) 
0da1 cd 64 11				call strlenz 
0da4 7d					ld a,l 
0da5 32 ac fb				ld (input_len),a 
0da8			 
0da8			.skipcur: 
0da8			 
0da8 cd f5 0a			        call update_display 
0dab					 
0dab			 
0dab			 
0dab					; wait 
0dab				 
0dab					; TODO loop without wait to flash the cursor and char under cursor	 
0dab cd 55 66				call cin    ; _wait 
0dae			 
0dae fe 00				cp 0 
0db0 ca 64 0d				jp z, .is1 
0db3			 
0db3					; get ptr to char to input into 
0db3			 
0db3 4f					ld c,a 
0db4 2a b9 fb				ld hl, (input_start) 
0db7 3a a7 fb				ld a, (input_cursor) 
0dba cd 06 0d				call addatohl 
0dbd 22 bb fb				ld (input_ptr), hl 
0dc0 79					ld a,c 
0dc1			 
0dc1					; replace char under cursor 
0dc1			 
0dc1			;		ld hl, (input_ptr) 
0dc1			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0dc1			;		ld (hl), a 
0dc1			 
0dc1			;	if DEBUG_INPUT 
0dc1			;		push af 
0dc1			;		ld a, 'i' 
0dc1			;		ld (debug_mark),a 
0dc1			;		pop af 
0dc1			;		CALLMONITOR 
0dc1			;	endif 
0dc1 fe 0e				cp KEY_HOME 
0dc3 20 0e				jr nz, .iske 
0dc5			 
0dc5 3a b6 fb				ld a, (input_at_pos) 
0dc8 32 b4 fb				ld (input_at_cursor),a 
0dcb 3e 00				ld a, 0 
0dcd 32 a7 fb				ld (input_cursor), a 
0dd0 c3 64 0d				jp .is1 
0dd3					 
0dd3 fe 0f		.iske:		cp KEY_END 
0dd5 20 03				jr nz, .isknw 
0dd7 c3 64 0d				jp .is1 
0dda			 
0dda fe 06		.isknw:		cp KEY_NEXTWORD 
0ddc 20 1b				jr nz, .iskpw 
0dde			 
0dde 2a bb fb		.isknwm:	ld hl, (input_ptr) 
0de1 7e					ld a,(hl)	 
0de2 fe 00				cp 0 
0de4 ca 64 0d				jp z, .is1    ; end of string 
0de7 fe 20				cp ' ' 
0de9 ca 64 0d				jp z, .is1    ; end of word 
0dec 23					inc hl 
0ded 22 bb fb				ld (input_ptr), hl 
0df0 3a b4 fb				ld a, (input_at_cursor) 
0df3 3c					inc a 
0df4 32 b4 fb				ld (input_at_cursor), a 
0df7 18 e5				jr .isknwm 
0df9			 
0df9 fe 07		.iskpw:		cp KEY_PREVWORD 
0dfb 20 1b				jr nz, .iskl 
0dfd			.iskpwm:	 
0dfd 2a bb fb				ld hl, (input_ptr) 
0e00 7e					ld a,(hl)	 
0e01 fe 00				cp 0  
0e03 ca 64 0d				jp z, .is1    ; end of string 
0e06 fe 20				cp ' ' 
0e08 ca 64 0d				jp z, .is1    ; end of word 
0e0b 2b					dec hl 
0e0c 22 bb fb				ld (input_ptr), hl 
0e0f 3a b4 fb				ld a, (input_at_cursor) 
0e12 3d					dec a 
0e13 32 b4 fb				ld (input_at_cursor), a 
0e16 18 e5				jr .iskpwm 
0e18			 
0e18			 
0e18 fe 0b		.iskl:		cp KEY_LEFT 
0e1a 20 27				jr nz, .isk1 
0e1c			 
0e1c 3a a7 fb				ld a, (input_cursor) 
0e1f			 
0e1f fe 00				cp 0 
0e21 ca 64 0d				jp z, .is1 		; at start of line to ignore  
0e24			 
0e24 3d					dec  a 		; TODO check underflow 
0e25 32 a7 fb				ld (input_cursor), a 
0e28			 
0e28 2a bb fb				ld hl, (input_ptr) 
0e2b 2b					dec hl 
0e2c 22 bb fb				ld (input_ptr), hl 
0e2f					 
0e2f 3a b4 fb				ld a, (input_at_cursor) 
0e32 3d					dec a 
0e33 32 b4 fb				ld (input_at_cursor), a 
0e36			 
0e36 3e 01				ld a, 1		; show cursor moving 
0e38 32 b1 fb				ld (input_cur_onoff),a 
0e3b 3e 0f				ld a, CUR_BLINK_RATE 
0e3d 32 b2 fb				ld (input_cur_flash), a 
0e40			 
0e40 c3 64 0d				jp .is1 
0e43			 
0e43 fe 0c		.isk1:		cp KEY_RIGHT 
0e45 20 2a				jr nz, .isk2 
0e47			 
0e47 3a ac fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e4a 5f					ld e,a 
0e4b 3a a7 fb				ld a, (input_cursor) 
0e4e bb					cp e 
0e4f ca 64 0d				jp z, .is1		; at the end of string so dont go right 
0e52			 
0e52 3c					inc  a 		; TODO check overflow 
0e53 32 a7 fb				ld (input_cursor), a 
0e56			 
0e56 3a b4 fb				ld a, (input_at_cursor) 
0e59 3c					inc a 
0e5a 32 b4 fb				ld (input_at_cursor), a 
0e5d			 
0e5d 2a bb fb				ld hl, (input_ptr) 
0e60 23					inc hl 
0e61 22 bb fb				ld (input_ptr), hl 
0e64			 
0e64 3e 01				ld a, 1		; show cursor moving 
0e66 32 b1 fb				ld (input_cur_onoff),a 
0e69 3e 0f				ld a, CUR_BLINK_RATE 
0e6b 32 b2 fb				ld (input_cur_flash), a 
0e6e			 
0e6e c3 64 0d				jp .is1 
0e71			 
0e71 fe 05		.isk2:		cp KEY_UP 
0e73			 
0e73 20 26				jr nz, .isk3 
0e75			 
0e75					; swap last command with the current on 
0e75			 
0e75					; move cursor to start of string 
0e75 2a b9 fb				ld hl, (input_start) 
0e78 22 bb fb				ld (input_ptr), hl 
0e7b			 
0e7b 3a b6 fb				ld a, (input_at_pos) 
0e7e 32 b4 fb				ld (input_at_cursor), a 
0e81			 
0e81 3e 00				ld a, 0 
0e83 32 a7 fb				ld (input_cursor), a 
0e86					 
0e86					; swap input and last command buffers 
0e86			 
0e86 21 ca f2				ld hl, os_cli_cmd 
0e89 11 c9 f3				ld de, os_last_cmd 
0e8c 06 ff				ld b, 255 
0e8e 7e			.swap1:		ld a, (hl) 
0e8f 4f					ld c,a 
0e90 1a					ld a, (de) 
0e91 77					ld (hl), a 
0e92 79					ld a,c 
0e93 12					ld (de),a 
0e94 23					inc hl 
0e95 13					inc de 
0e96 10 f6				djnz .swap1 
0e98			 
0e98			 
0e98			 
0e98			 
0e98			 
0e98 c3 64 0d				jp .is1 
0e9b			 
0e9b fe 08		.isk3:		cp KEY_BS 
0e9d 20 3c				jr nz, .isk4 
0e9f			 
0e9f 3a a7 fb				ld a, (input_cursor) 
0ea2			 
0ea2 fe 00				cp 0 
0ea4 ca 64 0d				jp z, .is1 		; at start of line to ignore  
0ea7			 
0ea7 3d					dec  a 		; TODO check underflow 
0ea8 32 a7 fb				ld (input_cursor), a 
0eab			 
0eab					; hl is source 
0eab					; de needs to be source - 1 
0eab			 
0eab			;		ld a, 0 
0eab			;		dec hl 
0eab			;		ld (hl), a 
0eab			 
0eab 2a bb fb				ld hl, (input_ptr) 
0eae 2b					dec hl 
0eaf 22 bb fb				ld (input_ptr), hl 
0eb2			 
0eb2					; shift all data 
0eb2			 
0eb2 e5					push hl 
0eb3 23					inc hl 
0eb4 d1					pop de 
0eb5 3a ac fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0eb8 4f					ld c,a 
0eb9 06 00				ld b,0 
0ebb ed b0				ldir  
0ebd			 
0ebd			 
0ebd			 
0ebd			 
0ebd 3a b4 fb				ld a, (input_at_cursor) 
0ec0 3d					dec a 
0ec1 32 b4 fb				ld (input_at_cursor), a 
0ec4			 
0ec4			 
0ec4 3e 01				ld a, 1		; show cursor moving 
0ec6 32 b1 fb				ld (input_cur_onoff),a 
0ec9 3e 0f				ld a, CUR_BLINK_RATE 
0ecb 32 b2 fb				ld (input_cur_flash), a 
0ece			 
0ece					; remove char 
0ece 3a b4 fb				ld a, (input_at_cursor) 
0ed1 3c					inc a 
0ed2 11 5c 0f				ld de,.iblank 
0ed5 cd e5 0a				call str_at_display 
0ed8			 
0ed8 c3 64 0d				jp .is1 
0edb			 
0edb fe 0d		.isk4:		cp KEY_CR 
0edd 28 6c				jr z, .endinput 
0edf			 
0edf					; else add the key press to the end 
0edf			 
0edf 4f					ld c, a			; save key pressed 
0ee0			 
0ee0 7e					ld a,(hl)		; get what is currently under char 
0ee1			 
0ee1 fe 00				cp 0			; we are at the end of the string 
0ee3 20 2f				jr nz, .onchar 
0ee5					 
0ee5					; add a char to the end of the string 
0ee5				 
0ee5 71					ld (hl),c 
0ee6 23					inc hl 
0ee7			;		ld a,' ' 
0ee7			;		ld (hl),a 
0ee7			;		inc hl 
0ee7 3e 00				ld a,0 
0ee9 77					ld (hl),a 
0eea 2b					dec hl 
0eeb			 
0eeb 3a a7 fb				ld a, (input_cursor) 
0eee 3c					inc a				; TODO check max string length and scroll  
0eef 32 a7 fb				ld (input_cursor), a		; inc cursor pos 
0ef2							 
0ef2 3a b4 fb				ld a, (input_at_cursor) 
0ef5 3c					inc a 
0ef6 32 b4 fb				ld (input_at_cursor), a 
0ef9			 
0ef9 2a bb fb				ld hl, (input_ptr) 
0efc 23					inc hl 
0efd 22 bb fb				ld (input_ptr), hl 
0f00			 
0f00 2a bb fb				ld hl, (input_ptr) 
0f03 23					inc hl 
0f04 22 bb fb				ld (input_ptr), hl 
0f07			;	if DEBUG_INPUT 
0f07			;		push af 
0f07			;		ld a, '+' 
0f07			;		ld (debug_mark),a 
0f07			;		pop af 
0f07			;		CALLMONITOR 
0f07			;	endif 
0f07 3e 01				ld a, 1		; show cursor moving 
0f09 32 b1 fb				ld (input_cur_onoff),a 
0f0c 3e 0f				ld a, CUR_BLINK_RATE 
0f0e 32 b2 fb				ld (input_cur_flash), a 
0f11 c3 64 0d				jp .is1 
0f14					 
0f14			 
0f14			 
0f14					; if on a char then insert 
0f14			.onchar: 
0f14			 
0f14					; TODO over flow check: make sure insert does not blow out buffer 
0f14			 
0f14					; need to do some maths to use lddr 
0f14			 
0f14 e5					push hl   ; save char pos 
0f15 c5					push bc 
0f16			 
0f16 2a b9 fb				ld hl, (input_start) 
0f19 3a ac fb				ld a, (input_len) 
0f1c cd 06 0d				call addatohl  		; end of string 
0f1f 23					inc hl 
0f20 23					inc hl		; past zero term 
0f21 e5					push hl 
0f22 23					inc hl 
0f23 e5					push hl  
0f24			 
0f24								; start and end of lddr set, now how much to move? 
0f24			 
0f24							 
0f24 3a a7 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0f27 47					ld b,a 
0f28 3a ac fb				ld a,(input_len) 
0f2b 5f					ld e,a 
0f2c 90					sub b 
0f2d 3c					inc a		;?? 
0f2e 3c					inc a		;?? 
0f2f 3c					inc a		;?? 
0f30			 
0f30 06 00				ld b,0 
0f32 4f					ld c,a 
0f33			 
0f33				if DEBUG_INPUT 
0f33					push af 
0f33					ld a, 'i' 
0f33					ld (debug_mark),a 
0f33					pop af 
0f33			;		CALLMONITOR 
0f33				endif 
0f33 d1					pop de 
0f34 e1					pop hl 
0f35				if DEBUG_INPUT 
0f35					push af 
0f35					ld a, 'I' 
0f35					ld (debug_mark),a 
0f35					pop af 
0f35			;		CALLMONITOR 
0f35				endif 
0f35 ed b8				lddr 
0f37				 
0f37			 
0f37			 
0f37					; TODO have a key for insert/overwrite mode???? 
0f37 c1					pop bc 
0f38 e1					pop hl 
0f39 71					ld (hl), c		; otherwise overwrite current char 
0f3a					 
0f3a			 
0f3a			 
0f3a			 
0f3a 3a a7 fb				ld a, (input_cursor) 
0f3d 3c					inc  a 		; TODO check overflow 
0f3e 32 a7 fb				ld (input_cursor), a 
0f41			 
0f41 3a b4 fb				ld a, (input_at_cursor) 
0f44 3c					inc a 
0f45 32 b4 fb				ld (input_at_cursor), a 
0f48			 
0f48 c3 64 0d				jp .is1 
0f4b			 
0f4b			.endinput:	; TODO look for end of string 
0f4b			 
0f4b					; add trailing space for end of token 
0f4b			 
0f4b 2a b9 fb				ld hl, (input_start) 
0f4e 3a ac fb				ld a,(input_len) 
0f51 cd 06 0d				call addatohl 
0f54 3e 20				ld a, ' ' 
0f56 77					ld (hl),a 
0f57					; TODO eof of parse marker 
0f57			 
0f57 23					inc hl 
0f58 3e 00				ld a, 0 
0f5a 77					ld (hl),a 
0f5b			 
0f5b			 
0f5b c9					ret 
0f5c			 
0f5c .. 00		.iblank: db " ",0 
0f5e			 
0f5e			 
0f5e 32 b6 fb		input_str_prev:	ld (input_at_pos), a 
0f61 22 b9 fb				ld (input_start), hl 
0f64 3e 01				ld a,1			; add cursor 
0f66 77					ld (hl),a 
0f67 23					inc hl 
0f68 3e 00				ld a,0 
0f6a 77					ld (hl),a 
0f6b 22 bb fb				ld (input_ptr), hl 
0f6e 7a					ld a,d 
0f6f 32 b8 fb				ld (input_size), a 
0f72 3e 00				ld a,0 
0f74 32 a7 fb				ld (input_cursor),a 
0f77			.instr1:	 
0f77			 
0f77					; TODO do block cursor 
0f77					; TODO switch cursor depending on the modifer key 
0f77			 
0f77					; update cursor shape change on key hold 
0f77			 
0f77 2a bb fb				ld hl, (input_ptr) 
0f7a 2b					dec hl 
0f7b 3a 56 fa				ld a,(cursor_shape) 
0f7e 77					ld (hl), a 
0f7f			 
0f7f					; display entered text 
0f7f 3a b6 fb				ld a,(input_at_pos) 
0f82 cd 73 65		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f85 ed 5b b9 fb	            	LD   de, (input_start) 
0f89 cd 7b 65		            	CALL fLCD_Str       ;Display string pointed to by DE 
0f8c			 
0f8c cd 55 66				call cin 
0f8f fe 00				cp 0 
0f91 28 e4				jr z, .instr1 
0f93			 
0f93					; proecess keyboard controls first 
0f93			 
0f93 2a bb fb				ld hl,(input_ptr) 
0f96			 
0f96 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0f98 28 5a				jr z, .instrcr 
0f9a			 
0f9a fe 08				cp KEY_BS 	; back space 
0f9c 20 0f				jr nz, .instr2 
0f9e					; process back space 
0f9e			 
0f9e					; TODO stop back space if at start of string 
0f9e 2b					dec hl 
0f9f 2b					dec hl ; to over write cursor 
0fa0 3a 56 fa				ld a,(cursor_shape) 
0fa3					;ld a,0 
0fa3 77					ld (hl),a 
0fa4 23					inc hl 
0fa5 3e 20				ld a," " 
0fa7 77					ld (hl),a 
0fa8 22 bb fb				ld (input_ptr),hl 
0fab					 
0fab			 
0fab 18 ca				jr .instr1 
0fad			 
0fad fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0faf 20 06				jr nz, .instr3 
0fb1 2b					dec hl 
0fb2 22 bb fb				ld (input_ptr),hl 
0fb5 18 c0				jr .instr1 
0fb7				 
0fb7 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0fb9 20 06				jr nz, .instr4 
0fbb 23					inc hl 
0fbc 22 bb fb				ld (input_ptr),hl 
0fbf 18 b6				jr .instr1 
0fc1			 
0fc1 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0fc3 20 06				jr nz, .instr5 
0fc5 2b					dec hl 
0fc6 22 bb fb				ld (input_ptr),hl 
0fc9 18 ac				jr .instr1 
0fcb			 
0fcb fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0fcd 20 06				jr nz, .instr6 
0fcf 2b					dec hl 
0fd0 22 bb fb				ld (input_ptr),hl 
0fd3 18 a2				jr .instr1 
0fd5 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0fd7 20 0b				jr nz, .instrnew 
0fd9			 
0fd9 21 a3 ef			ld hl, scratch 
0fdc 11 c9 f3			ld de, os_last_cmd 
0fdf cd fd 0f			call strcpy 
0fe2 18 93				jr .instr1 
0fe4			 
0fe4			 
0fe4			.instrnew:	; no special key pressed to see if we have room to store it 
0fe4			 
0fe4					; TODO do string size test 
0fe4			 
0fe4 2b					dec hl ; to over write cursor 
0fe5 77					ld (hl),a 
0fe6 23					inc hl 
0fe7 3a 56 fa				ld a,(cursor_shape) 
0fea 77					ld (hl),a 
0feb 23					inc hl 
0fec 3e 00				ld a,0 
0fee 77					ld (hl),a 
0fef			 
0fef 22 bb fb				ld (input_ptr),hl 
0ff2					 
0ff2 18 83				jr .instr1 
0ff4 2b			.instrcr:	dec hl		; remove cursor 
0ff5 3e 20				ld a,' '	; TODO add a trailing space for safety 
0ff7 77					ld (hl),a 
0ff8 23					inc hl 
0ff9 3e 00				ld a,0 
0ffb 77					ld (hl),a 
0ffc			 
0ffc			 
0ffc					; if at end of line scroll up    
0ffc					; TODO detecting only end of line 4 for scroll up  
0ffc			 
0ffc					;ld   
0ffc			 
0ffc c9					ret 
0ffd			 
0ffd			 
0ffd			; strcpy hl = dest, de source 
0ffd			 
0ffd 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0ffe b7			            OR   A              ;Null terminator? 
0fff c8			            RET  Z              ;Yes, so finished 
1000 1a					ld a,(de) 
1001 77					ld (hl),a 
1002 13			            INC  DE             ;Point to next character 
1003 23					inc hl 
1004 18 f7		            JR   strcpy       ;Repeat 
1006 c9					ret 
1007			 
1007			 
1007			; TODO string_at  
1007			; pass string which starts with lcd offset address and then null term string 
1007			 
1007			; TODO string to dec 
1007			; TODO string to hex 
1007			; TODO byte to string hex 
1007			; TODO byte to string dec 
1007			 
1007			 
1007			 
1007			; from z80uartmonitor 
1007			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1007			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
1007			; pass hl for where to put the text 
1007			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1007 c5			hexout:	PUSH BC 
1008 f5					PUSH AF 
1009 47					LD B, A 
100a					; Upper nybble 
100a cb 3f				SRL A 
100c cb 3f				SRL A 
100e cb 3f				SRL A 
1010 cb 3f				SRL A 
1012 cd 22 10				CALL tohex 
1015 77					ld (hl),a 
1016 23					inc hl	 
1017					 
1017					; Lower nybble 
1017 78					LD A, B 
1018 e6 0f				AND 0FH 
101a cd 22 10				CALL tohex 
101d 77					ld (hl),a 
101e 23					inc hl	 
101f					 
101f f1					POP AF 
1020 c1					POP BC 
1021 c9					RET 
1022					 
1022			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1022			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1022			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1022			tohex: 
1022 e5					PUSH HL 
1023 d5					PUSH DE 
1024 16 00				LD D, 0 
1026 5f					LD E, A 
1027 21 2f 10				LD HL, .DATA 
102a 19					ADD HL, DE 
102b 7e					LD A, (HL) 
102c d1					POP DE 
102d e1					POP HL 
102e c9					RET 
102f			 
102f			.DATA: 
102f 30					DEFB	30h	; 0 
1030 31					DEFB	31h	; 1 
1031 32					DEFB	32h	; 2 
1032 33					DEFB	33h	; 3 
1033 34					DEFB	34h	; 4 
1034 35					DEFB	35h	; 5 
1035 36					DEFB	36h	; 6 
1036 37					DEFB	37h	; 7 
1037 38					DEFB	38h	; 8 
1038 39					DEFB	39h	; 9 
1039 41					DEFB	41h	; A 
103a 42					DEFB	42h	; B 
103b 43					DEFB	43h	; C 
103c 44					DEFB	44h	; D 
103d 45					DEFB	45h	; E 
103e 46					DEFB	46h	; F 
103f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
103f			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
103f			;;    subtract $30, if result > 9 then subtract $7 more 
103f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
103f			atohex: 
103f d6 30				SUB $30 
1041 fe 0a				CP 10 
1043 f8					RET M		; If result negative it was 0-9 so we're done 
1044 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1046 c9					RET		 
1047			 
1047			 
1047			 
1047			 
1047			; Get 2 ASCII characters as hex byte from pointer in hl 
1047			 
1047			BYTERD: 
1047 16 00			LD	D,00h		;Set up 
1049 cd 51 10			CALL	HEXCON		;Get byte and convert to hex 
104c 87				ADD	A,A		;First nibble so 
104d 87				ADD	A,A		;multiply by 16 
104e 87				ADD	A,A		; 
104f 87				ADD	A,A		; 
1050 57				LD	D,A		;Save hi nibble in D 
1051			HEXCON: 
1051 7e				ld a, (hl)		;Get next chr 
1052 23				inc hl 
1053 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1055 fe 0a			CP	00Ah		;Is it 0-9 ? 
1057 38 02			JR	C,NALPHA	;If so miss next bit 
1059 d6 07			SUB	007h		;Else convert alpha 
105b			NALPHA: 
105b b2				OR	D		;Add hi nibble back 
105c c9				RET			; 
105d			 
105d			 
105d			; 
105d			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
105d			; Since the routines get_byte and therefore get_nibble are called, only valid 
105d			; characters (0-9a-f) are accepted. 
105d			; 
105d			;get_word        push    af 
105d			;                call    get_byte        ; Get the upper byte 
105d			;                ld      h, a 
105d			;                call    get_byte        ; Get the lower byte 
105d			;                ld      l, a 
105d			;                pop     af 
105d			;                ret 
105d			; 
105d			; Get a byte in hexadecimal notation. The result is returned in A. Since 
105d			; the routine get_nibble is used only valid characters are accepted - the  
105d			; input routine only accepts characters 0-9a-f. 
105d			; 
105d c5			get_byte:        push    bc              ; Save contents of B (and C) 
105e 7e					ld a,(hl) 
105f 23					inc hl 
1060 cd 85 10		                call    nibble2val      ; Get upper nibble 
1063 cb 07		                rlc     a 
1065 cb 07		                rlc     a 
1067 cb 07		                rlc     a 
1069 cb 07		                rlc     a 
106b 47			                ld      b, a            ; Save upper four bits 
106c 7e					ld a,(hl) 
106d cd 85 10		                call    nibble2val      ; Get lower nibble 
1070 b0			                or      b               ; Combine both nibbles 
1071 c1			                pop     bc              ; Restore B (and C) 
1072 c9			                ret 
1073			; 
1073			; Get a hexadecimal digit from the serial line. This routine blocks until 
1073			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1073			; to the serial line interface. The lower 4 bits of A contain the value of  
1073			; that particular digit. 
1073			; 
1073			;get_nibble      ld a,(hl)           ; Read a character 
1073			;                call    to_upper        ; Convert to upper case 
1073			;                call    is_hex          ; Was it a hex digit? 
1073			;                jr      nc, get_nibble  ; No, get another character 
1073			 ;               call    nibble2val      ; Convert nibble to value 
1073			 ;               call    print_nibble 
1073			 ;               ret 
1073			; 
1073			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1073			; A valid hexadecimal digit is denoted by a set C flag. 
1073			; 
1073			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1073			;                ret     nc              ; Yes 
1073			;                cp      '0'             ; Less than '0'? 
1073			;                jr      nc, is_hex_1    ; No, continue 
1073			;                ccf                     ; Complement carry (i.e. clear it) 
1073			;                ret 
1073			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1073			;                ret     c               ; Yes 
1073			;                cp      'A'             ; Less than 'A'? 
1073			;                jr      nc, is_hex_2    ; No, continue 
1073			;                ccf                     ; Yes - clear carry and return 
1073			;                ret 
1073			;is_hex_2        scf                     ; Set carry 
1073			;                ret 
1073			; 
1073			; Convert a single character contained in A to upper case: 
1073			; 
1073 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1075 d8			                ret     c 
1076 fe 7b		                cp      'z' + 1         ; > 'z'? 
1078 d0			                ret     nc              ; Nothing to do, either 
1079 e6 5f		                and     $5f             ; Convert to upper case 
107b c9			                ret 
107c			 
107c			 
107c			to_lower: 
107c			 
107c			   ; if char is in [A-Z] make it lower case 
107c			 
107c			   ; enter : a = char 
107c			   ; exit  : a = lower case char 
107c			   ; uses  : af 
107c			 
107c fe 41		   cp 'A' 
107e d8			   ret c 
107f			    
107f fe 5b		   cp 'Z'+1 
1081 d0			   ret nc 
1082			    
1082 f6 20		   or $20 
1084 c9			   ret 
1085			 
1085			; 
1085			; Expects a hexadecimal digit (upper case!) in A and returns the 
1085			; corresponding value in A. 
1085			; 
1085 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1087 38 02		                jr      c, nibble2val_1 ; Yes 
1089 d6 07		                sub     7               ; Adjust for A-F 
108b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
108d e6 0f		                and     $f              ; Only return lower 4 bits 
108f c9			                ret 
1090			; 
1090			; Print_nibble prints a single hex nibble which is contained in the lower  
1090			; four bits of A: 
1090			; 
1090			;print_nibble    push    af              ; We won't destroy the contents of A 
1090			;                and     $f              ; Just in case... 
1090			;                add     a, '0'             ; If we have a digit we are done here. 
1090			;                cp      '9' + 1         ; Is the result > 9? 
1090			;                jr      c, print_nibble_1 
1090			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1090			;print_nibble_1  call    putc            ; Print the nibble and 
1090			;                pop     af              ; restore the original value of A 
1090			;                ret 
1090			;; 
1090			;; Send a CR/LF pair: 
1090			; 
1090			;crlf            push    af 
1090			;                ld      a, cr 
1090			;                call    putc 
1090			;                ld      a, lf 
1090			;                call    putc 
1090			;                pop     af 
1090			;                ret 
1090			; 
1090			; Print_word prints the four hex digits of a word to the serial line. The  
1090			; word is expected to be in HL. 
1090			; 
1090			;print_word      push    hl 
1090			;                push    af 
1090			;                ld      a, h 
1090			;                call    print_byte 
1090			;                ld      a, l 
1090			;                call    print_byte 
1090			;                pop     af 
1090			;                pop     hl 
1090			;                ret 
1090			; 
1090			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1090			; The byte to be printed is expected to be in A. 
1090			; 
1090			;print_byte      push    af              ; Save the contents of the registers 
1090			;                push    bc 
1090			;                ld      b, a 
1090			;                rrca 
1090			;                rrca 
1090			;                rrca 
1090			;                rrca 
1090			;                call    print_nibble    ; Print high nibble 
1090			;                ld      a, b 
1090			;                call    print_nibble    ; Print low nibble 
1090			;                pop     bc              ; Restore original register contents 
1090			;                pop     af 
1090			;                ret 
1090			 
1090			 
1090			 
1090			 
1090			 
1090			fourehexhl:  
1090 7e				ld a,(hl) 
1091 cd 3f 10			call atohex 
1094 cb 3f				SRL A 
1096 cb 3f				SRL A 
1098 cb 3f				SRL A 
109a cb 3f				SRL A 
109c 47				ld b, a 
109d 23				inc hl 
109e 7e				ld a,(hl) 
109f 23				inc hl 
10a0 cd 3f 10			call atohex 
10a3 80				add b 
10a4 57				ld d,a 
10a5 7e				ld a,(hl) 
10a6 cd 3f 10			call atohex 
10a9 cb 3f				SRL A 
10ab cb 3f				SRL A 
10ad cb 3f				SRL A 
10af cb 3f				SRL A 
10b1 47				ld b, a 
10b2 23				inc hl 
10b3 7e				ld a,(hl) 
10b4 23				inc hl 
10b5 cd 3f 10			call atohex 
10b8 80				add b 
10b9 5f				ld e, a 
10ba d5				push de 
10bb e1				pop hl 
10bc c9				ret 
10bd			 
10bd			; pass hl. returns z set if the byte at hl is a digit 
10bd			;isdigithl:  
10bd			;	push bc 
10bd			;	ld a,(hl) 
10bd			;	cp ':' 
10bd			;	jr nc, .isdf 		; > 
10bd			;	cp '0' 
10bd			;	jr c, .isdf		; < 
10bd			; 
10bd			;	; TODO find a better way to set z 
10bd			; 
10bd			;	ld b,a 
10bd			;	cp b 
10bd			;	pop bc 
10bd			;	ret 
10bd			; 
10bd			;.isdf:	; not digit so clear z 
10bd			; 
10bd			;	; TODO find a better way to unset z 
10bd			; 
10bd			;	ld b,a 
10bd			;	inc b 
10bd			;	cp b 
10bd			; 
10bd			;	pop bc 
10bd			;	ret 
10bd				 
10bd				 
10bd			 
10bd			 
10bd			; pass hl as the four byte address to load 
10bd			 
10bd			get_word_hl:  
10bd e5				push hl 
10be cd 5d 10			call get_byte 
10c1				 
10c1 47				ld b, a 
10c2			 
10c2 e1				pop hl 
10c3 23				inc hl 
10c4 23				inc hl 
10c5			 
10c5			; TODO not able to handle a-f  
10c5 7e				ld a,(hl) 
10c6			;	;cp ':' 
10c6			;	cp 'g' 
10c6			;	jr nc, .single_byte_hl 		; > 
10c6			;	cp 'G' 
10c6			;	jr nc, .single_byte_hl 		; > 
10c6			;	cp '0' 
10c6			;	jr c, .single_byte_hl		; < 
10c6			 
10c6				;call isdigithl 
10c6 fe 00			cp 0 
10c8 28 06			jr z, .single_byte_hl 
10ca			 
10ca			.getwhln:   ; hex word so get next byte 
10ca			 
10ca cd 5d 10			call get_byte 
10cd 6f				ld l, a 
10ce 60				ld h,b 
10cf c9				ret 
10d0 68			.single_byte_hl:   ld l,b 
10d1 26 00				ld h,0 
10d3 c9					ret 
10d4			 
10d4			 
10d4			 
10d4			 
10d4 21 09 19			ld hl,asc+1 
10d7			;	ld a, (hl) 
10d7			;	call nibble2val 
10d7 cd 5d 10			call get_byte 
10da			 
10da			;	call fourehexhl 
10da 32 d7 ef			ld (scratch+52),a 
10dd				 
10dd 21 d5 ef			ld hl,scratch+50 
10e0 22 c6 f2			ld (os_cur_ptr),hl 
10e3			 
10e3 c9				ret 
10e4			 
10e4			 
10e4			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10e4			 
10e4			; Decimal Unsigned Version 
10e4			 
10e4			;Number in a to decimal ASCII 
10e4			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10e4			;Example: display a=56 as "056" 
10e4			;input: a = number 
10e4			;Output: a=0,value of a in the screen 
10e4			;destroys af,bc (don't know about hl and de) 
10e4			DispAToASCII: 
10e4 0e 9c			ld	c,-100 
10e6 cd f0 10			call	.Na1 
10e9 0e f6			ld	c,-10 
10eb cd f0 10			call	.Na1 
10ee 0e ff			ld	c,-1 
10f0 06 2f		.Na1:	ld	b,'0'-1 
10f2 04			.Na2:	inc	b 
10f3 81				add	a,c 
10f4 38 fc			jr	c,.Na2 
10f6 91				sub	c		;works as add 100/10/1 
10f7 f5				push af		;safer than ld c,a 
10f8 78				ld	a,b		;char is in b 
10f9			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10f9 f1				pop af		;safer than ld a,c 
10fa c9				ret 
10fb			 
10fb			; Decimal Signed Version 
10fb			 
10fb			; DispA 
10fb			; -------------------------------------------------------------- 
10fb			; Converts a signed integer value to a zero-terminated ASCII 
10fb			; string representative of that value (using radix 10). 
10fb			; -------------------------------------------------------------- 
10fb			; INPUTS: 
10fb			;     HL     Value to convert (two's complement integer). 
10fb			;     DE     Base address of string destination. (pointer). 
10fb			; -------------------------------------------------------------- 
10fb			; OUTPUTS: 
10fb			;     None 
10fb			; -------------------------------------------------------------- 
10fb			; REGISTERS/MEMORY DESTROYED 
10fb			; AF HL 
10fb			; -------------------------------------------------------------- 
10fb			 
10fb			;DispHLToASCII: 
10fb			;   push    de 
10fb			;   push    bc 
10fb			; 
10fb			;; Detect sign of HL. 
10fb			;    bit    7, h 
10fb			;    jr     z, ._DoConvert 
10fb			; 
10fb			;; HL is negative. Output '-' to string and negate HL. 
10fb			;    ld     a, '-' 
10fb			;    ld     (de), a 
10fb			;    inc    de 
10fb			; 
10fb			;; Negate HL (using two's complement) 
10fb			;    xor    a 
10fb			;    sub    l 
10fb			;    ld     l, a 
10fb			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10fb			;    sbc    a, h 
10fb			;    ld     h, a 
10fb			; 
10fb			;; Convert HL to digit characters 
10fb			;._DoConvert: 
10fb			;    ld     b, 0     ; B will count character length of number 
10fb			;-   ld     a, 10 
10fb			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10fb			;    push   af 
10fb			;    inc    b 
10fb			;    ld     a, h 
10fb			;    or     l 
10fb			;    jr     nz, - 
10fb			; 
10fb			;; Retrieve digits from stack 
10fb			;-   pop    af 
10fb			;    or     $30 
10fb			;    ld     (de), a 
10fb			;    inc    de 
10fb			;    djnz   - 
10fb			; 
10fb			;; Terminate string with NULL 
10fb			;    xor    a 
10fb			;    ld     (de), a 
10fb			; 
10fb			;    pop    bc 
10fb			;    pop    de 
10fb			;    ret 
10fb			 
10fb			;Comments 
10fb			; 
10fb			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10fb			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10fb			;    Note that the output string will not be fixed-width. 
10fb			; 
10fb			;Example Usage 
10fb			; 
10fb			;    ld    hl, -1004 
10fb			;    ld    de, OP1 
10fb			;    call  DispA 
10fb			;    ld    hl, OP1 
10fb			;    syscall  PutS 
10fb			 
10fb			 
10fb			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10fb			 
10fb			 
10fb			;Converts an ASCII string to an unsigned 16-bit integer 
10fb			;Quits when it reaches a non-decimal digit 
10fb			 
10fb			string_to_uint16: 
10fb			atoui_16: 
10fb			;Input: 
10fb			;     DE points to the string 
10fb			;Outputs: 
10fb			;     HL is the result 
10fb			;     A is the 8-bit value of the number 
10fb			;     DE points to the byte after the number 
10fb			;Destroys: 
10fb			;     BC 
10fb			;       if the string is non-empty, BC is HL/10 
10fb			;Size:  24 bytes 
10fb			;Speed: 42+d(104+{0,9}) 
10fb			;       d is the number of digits in the number 
10fb			;       max is 640 cycles for a 5 digit number 
10fb			;Assuming no leading zeros: 
10fb			;1 digit:  146cc 
10fb			;2 digit:  250cc 
10fb			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10fb			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10fb			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10fb			;avg: 544.81158447265625cc (544+13297/16384) 
10fb			;=============================================================== 
10fb 21 00 00		  ld hl,0 
10fe			.u16a: 
10fe 1a			  ld a,(de) 
10ff d6 30		  sub 30h 
1101 fe 0a		  cp 10 
1103 d0			  ret nc 
1104 13			  inc de 
1105 44			  ld b,h 
1106 4d			  ld c,l 
1107 29			  add hl,hl 
1108 29			  add hl,hl 
1109 09			  add hl,bc 
110a 29			  add hl,hl 
110b 85			  add a,l 
110c 6f			  ld l,a 
110d 30 ef		  jr nc,.u16a 
110f 24			  inc h 
1110 c3 fe 10		  jp .u16a 
1113			 
1113			 
1113			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1113			 
1113			;written by Zeda 
1113			;Converts a 16-bit unsigned integer to an ASCII string. 
1113			 
1113			uitoa_16: 
1113			;Input: 
1113			;   DE is the number to convert 
1113			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1113			;Output: 
1113			;   HL points to the null-terminated ASCII string 
1113			;      NOTE: This isn't necessarily the same as the input HL. 
1113 d5			  push de 
1114 c5			  push bc 
1115 f5			  push af 
1116 eb			  ex de,hl 
1117			 
1117 01 f0 d8		  ld bc,-10000 
111a 3e 2f		  ld a,'0'-1 
111c 3c			  inc a 
111d 09			  add hl,bc  
111e 38 fc		   jr c,$-2 
1120 12			  ld (de),a 
1121 13			  inc de 
1122			 
1122 01 e8 03		  ld bc,1000 
1125 3e 3a		  ld a,'9'+1 
1127 3d			  dec a  
1128 09			  add hl,bc  
1129 30 fc		   jr nc,$-2 
112b 12			  ld (de),a 
112c 13			  inc de 
112d			 
112d 01 9c ff		  ld bc,-100 
1130 3e 2f		  ld a,'0'-1 
1132 3c			  inc a  
1133 09			  add hl,bc  
1134 38 fc		   jr c,$-2 
1136 12			  ld (de),a 
1137 13			  inc de 
1138			 
1138 7d			  ld a,l 
1139 26 3a		  ld h,'9'+1 
113b 25			  dec h  
113c c6 0a		  add a,10  
113e 30 fb		   jr nc,$-3 
1140 c6 30		  add a,'0' 
1142 eb			  ex de,hl 
1143 72			  ld (hl),d 
1144 23			  inc hl 
1145 77			  ld (hl),a 
1146 23			  inc hl 
1147 36 00		  ld (hl),0 
1149			 
1149			;Now strip the leading zeros 
1149 0e fa		  ld c,-6 
114b 09			  add hl,bc 
114c 3e 30		  ld a,'0' 
114e 23			  inc hl  
114f be			  cp (hl)  
1150 28 fc		  jr z,$-2 
1152			 
1152			;Make sure that the string is non-empty! 
1152 7e			  ld a,(hl) 
1153 b7			  or a 
1154 20 01		  jr nz,.atoub 
1156 2b			  dec hl 
1157			.atoub: 
1157			 
1157 f1			  pop af 
1158 c1			  pop bc 
1159 d1			  pop de 
115a c9			  ret 
115b			 
115b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
115b			 
115b			toUpper: 
115b			;A is the char. 
115b			;If A is a lowercase letter, this sets it to the matching uppercase 
115b			;18cc or 30cc or 41cc 
115b			;avg: 26.75cc 
115b fe 61		  cp 'a' 
115d d8			  ret c 
115e fe 7b		  cp 'z'+1 
1160 d0			  ret nc 
1161 d6 20		  sub 'a'-'A' 
1163 c9			  ret 
1164			 
1164			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1164			 
1164			; String Length 
1164			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1164			 
1164			; Get the length of the null-terminated string starting at $8000 hl 
1164			;    LD     HL, $8000 
1164			 
1164			strlenz: 
1164			 
1164 af			    XOR    A               ; Zero is the value we are looking for. 
1165 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1166 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1167			                           ; 65, 536 bytes (the entire addressable memory space). 
1167 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1169			 
1169			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1169 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
116a 6f			    LD     L, A             ; number of bytes 
116b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
116d 2b			    DEC    HL              ; Compensate for null. 
116e c9				ret 
116f			 
116f			; Get the length of the A terminated string starting at $8000 hl 
116f			;    LD     HL, $8000 
116f			 
116f			strlent: 
116f			 
116f			                  ; A is the value we are looking for. 
116f 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1171 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1173			                           ; 65, 536 bytes (the entire addressable memory space). 
1173 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1175			 
1175			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1175 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1177 2e 00		    LD     L, 0             ; number of bytes 
1179 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
117b 2b			    DEC    HL              ; Compensate for null. 
117c c9				ret 
117d			 
117d			 
117d			;Comparing Strings 
117d			 
117d			;IN    HL     Address of string1. 
117d			;      DE     Address of string2. 
117d			 
117d			; doc given but wrong??? 
117d			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
117d			;      carry  Set if string1 > string2, reset if string1 <= string2. 
117d			; tested 
117d			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
117d			 
117d			strcmp_old: 
117d e5			    PUSH   HL 
117e d5			    PUSH   DE 
117f			 
117f 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1180 be			    CP     (HL)            ; (want to minimize work). 
1181 38 01		    JR     C, Str1IsBigger 
1183 7e			    LD     A, (HL) 
1184			 
1184			Str1IsBigger: 
1184 4f			    LD     C, A             ; Put length in BC 
1185 06 00		    LD     B, 0 
1187 13			    INC    DE              ; Increment pointers to meat of string. 
1188 23			    INC    HL 
1189			 
1189			CmpLoop: 
1189 1a			    LD     A, (DE)          ; Compare bytes. 
118a ed a1		    CPI 
118c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
118e 13			    INC    DE              ; Update pointer. 
118f ea 89 11		    JP     PE, CmpLoop 
1192			 
1192 d1			    POP    DE 
1193 e1			    POP    HL 
1194 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1195 be			    CP     (HL) 
1196 c9			    RET 
1197			 
1197			NoMatch: 
1197 2b			    DEC    HL 
1198 be			    CP     (HL)            ; Compare again to affect carry. 
1199 d1			    POP    DE 
119a e1			    POP    HL 
119b c9			    RET 
119c			 
119c			;; test strmp 
119c			; 
119c			;ld de, .str1 
119c			;ld hl, .str2 
119c			;call strcmp 
119c			;jr z, .z1 
119c			;;this 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "NZ1" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;.z1: 
119c			; 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "ZZ1" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			; 
119c			;ld de, .str1 
119c			;ld hl, .str1 
119c			;call strcmp 
119c			;jr z, .z2 
119c			;;this 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "NZ2" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;.z2: 
119c			; 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "ZZ2" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			; 
119c			;ld de, .str1 
119c			;ld hl, .str2 
119c			;call strcmp 
119c			;jr c, .c1 
119c			; 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "Nc1" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;.c1: 
119c			;;this 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "cc1" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			; 
119c			;ld de, .str1 
119c			;ld hl, .str1 
119c			;call strcmp 
119c			;jr c, .c2 
119c			;;this 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "Nc2" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;.c2: 
119c			; 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "cc2" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;	NEXTW 
119c			;.str1:   db "string1",0 
119c			;.str2:   db "string2",0 
119c			 
119c			; only care about direct match or not 
119c			; hl and de strings 
119c			; zero set if the same 
119c			 
119c			strcmp: 
119c 1a				ld a, (de) 
119d be				cp (hl) 
119e 28 02			jr z, .ssame 
11a0 b7				or a 
11a1 c9				ret 
11a2			 
11a2			.ssame:  
11a2 fe 00			cp 0 
11a4 c8				ret z 
11a5			 
11a5 23				inc hl 
11a6 13				inc de 
11a7 18 f3			jr strcmp 
11a9				 
11a9				 
11a9			 
11a9			 
11a9			 
11a9			 
11a9			; eof 
11a9			 
11a9			 
11a9			 
11a9			 
11a9			 
11a9			 
# End of file firmware_strings.asm
11a9			include "firmware_memory.asm"   ; malloc and free  
11a9			 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9			.mallocsize: db "Wants malloc >256",0 
11a9			.mallocasize: db "MALLOC gives >256",0 
11a9			.malloczero: db "MALLOC gives zero",0 
11a9			 
11a9			malloc_guard_zerolen: 
11a9				push hl 
11a9				push de 
11a9				push af 
11a9			 
11a9				ld de, 0 
11a9			        call cmp16 
11a9				jr nz, .lowalloz 
11a9			 
11a9				push hl 
11a9				push de 
11a9					ld hl, display_fb0 
11a9					ld (display_fb_active), hl 
11a9				call clear_display 
11a9				ld a, 0 
11a9				ld de, .malloczero 
11a9				call str_at_display 
11a9				call update_display 
11a9				call delay1s 
11a9				call delay1s 
11a9				ld a, 0 
11a9				ld (os_view_disable), a 
11a9			 
11a9				pop de 
11a9				pop hl 
11a9			 
11a9				 
11a9			 
11a9				CALLMONITOR 
11a9			.lowalloz: 
11a9			 
11a9			 
11a9				pop af 
11a9				pop de 
11a9				pop hl 
11a9			ret 
11a9			 
11a9			malloc_guard_entry: 
11a9				push hl 
11a9				push de 
11a9				push af 
11a9			 
11a9			 	or a      ;clear carry flag 
11a9				push hl 
11a9				ld de, 255 
11a9				sbc hl, de 
11a9				jr c, .lowalloc 
11a9			 
11a9				push de 
11a9					ld hl, display_fb0 
11a9					ld (display_fb_active), hl 
11a9				call clear_display 
11a9				ld a, 0 
11a9				ld de, .mallocsize 
11a9				call str_at_display 
11a9				call update_display 
11a9				call delay1s 
11a9				call delay1s 
11a9				ld a, 0 
11a9				ld (os_view_disable), a 
11a9			 
11a9				pop de 
11a9				pop hl 
11a9			 
11a9				 
11a9			 
11a9				CALLMONITOR 
11a9				jr .lowdone 
11a9			.lowalloc: 
11a9			 
11a9			 
11a9				pop hl 
11a9			.lowdone:	pop af 
11a9				pop de 
11a9				pop hl 
11a9			ret 
11a9			 
11a9			malloc_guard_exit: 
11a9				push hl 
11a9				push de 
11a9				push af 
11a9			 
11a9			 	or a      ;clear carry flag 
11a9				push hl 
11a9				ld de, 255 
11a9				sbc hl, de 
11a9				jr c, .lowallocx 
11a9			 
11a9				push de 
11a9					ld hl, display_fb0 
11a9					ld (display_fb_active), hl 
11a9				call clear_display 
11a9				ld a, 0 
11a9				ld de, .mallocasize 
11a9				call str_at_display 
11a9				call update_display 
11a9				call delay1s 
11a9				call delay1s 
11a9				ld a, 0 
11a9				ld (os_view_disable), a 
11a9				pop de 
11a9				pop hl 
11a9			 
11a9				CALLMONITOR 
11a9				jr .lowdonex 
11a9			.lowallocx: 
11a9			 
11a9				pop hl 
11a9			.lowdonex:	pop af 
11a9				pop de 
11a9				pop hl 
11a9			ret 
11a9			endif 
11a9			 
11a9			if MALLOC_2 
11a9			; Z80 Malloc and Free Functions 
11a9			 
11a9			; Malloc Function: 
11a9			; Input: 
11a9			;   HL: Size of block to allocate 
11a9			; Output: 
11a9			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11a9			 
11a9			malloc: 
11a9				 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9			call malloc_guard_entry 
11a9			endif 
11a9			 
11a9			 
11a9			 
11a9			 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "mal" 
11a9						CALLMONITOR 
11a9					endif 
11a9			    push af            ; Save AF register 
11a9			    ld a, l            ; Load low byte of size into A 
11a9			    or h               ; Check if size is zero 
11a9			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11a9			 
11a9			    ; Allocate memory 
11a9			    ld hl, (heap_start) ; Load start of heap into HL 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "ma1" 
11a9						CALLMONITOR 
11a9					endif 
11a9			    call malloc_internal ; Call internal malloc function 
11a9			    pop af             ; Restore AF register 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret                ; Return 
11a9			 
11a9			; Free Function: 
11a9			; Input: 
11a9			;   HL: Pointer to memory block to free 
11a9			; Output: 
11a9			;   None 
11a9			 
11a9			free: 
11a9			    push af            ; Save AF register 
11a9			    ld a, l            ; Load low byte of pointer into A 
11a9			    or h               ; Check if pointer is NULL 
11a9			    jp z, free_exit    ; If pointer is NULL, exit 
11a9			 
11a9			    ; Free memory 
11a9			    ld hl, (heap_start) ; Load start of heap into HL 
11a9			    call free_internal  ; Call internal free function 
11a9			    pop af             ; Restore AF register 
11a9			    ret                ; Return 
11a9			 
11a9			; Internal Malloc Function: 
11a9			; Input: 
11a9			;   HL: Size of block to allocate 
11a9			; Output: 
11a9			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11a9			 
11a9			malloc_internal: 
11a9			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11a9			    add hl, bc         ; Add management overhead to requested size 
11a9			    ex de, hl          ; Save total size in DE, and keep it in HL 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "ma2" 
11a9						CALLMONITOR 
11a9					endif 
11a9			 
11a9			    ; Search for free memory block 
11a9			    ld de, (heap_end)  ; Load end of heap into DE 
11a9			    ld bc, 0           ; Initialize counter 
11a9			 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "ma2" 
11a9						CALLMONITOR 
11a9					endif 
11a9			malloc_search_loop: 
11a9			    ; Check if current block is free 
11a9			    ld a, (hl)         ; Load current block's status (free or used) 
11a9			    cp 0               ; Compare with zero (free) 
11a9			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11a9			 
11a9			    ; Check if current block is large enough 
11a9			    ld a, (hl+1)       ; Load high byte of block size 
11a9			    cp l               ; Compare with low byte of requested size 
11a9			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11a9			 
11a9			    ld a, (hl+2)       ; Load low byte of block size 
11a9			    cp h               ; Compare with high byte of requested size 
11a9			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11a9			 
11a9			    ; Mark block as used 
11a9			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11a9			 
11a9			    ; Calculate remaining space in block 
11a9			    ld bc, 0           ; Clear BC 
11a9			    add hl, bc         ; Increment HL to point to start of data block 
11a9			    add hl, de         ; HL = HL + DE (total size) 
11a9			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11a9			    add hl, bc         ; Add management overhead to start of data block 
11a9			 
11a9			    ; Save pointer to allocated block in HL 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9						DMARK "ma5" 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret 
11a9			 
11a9			malloc_skip_block_check: 
11a9			    ; Move to the next block 
11a9			    ld bc, 3           ; Size of management overhead 
11a9			    add hl, bc         ; Move to the next block 
11a9			    inc de             ; Increment counter 
11a9			 
11a9			    ; Check if we have reached the end of heap 
11a9			    ld a, e            ; Load low byte of heap end address 
11a9			    cp (hl)            ; Compare with low byte of current address 
11a9			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11a9			    ld a, d            ; Load high byte of heap end address 
11a9			    cp 0               ; Check if it's zero (end of memory) 
11a9			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11a9			 
11a9			    ; If we reached here, allocation failed 
11a9			    xor a              ; Set result to NULL 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9						DMARK "ma6" 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret 
11a9			malloc_exit: 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9						DMARK "ma7" 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret 
11a9			 
11a9			; Internal Free Function: 
11a9			; Input: 
11a9			;   HL: Pointer to memory block to free 
11a9			; Output: 
11a9			;   None 
11a9			 
11a9			free_internal: 
11a9			    ld de, (heap_start) ; Load start of heap into DE 
11a9			    ld bc, 0            ; Initialize counter 
11a9			 
11a9			free_search_loop: 
11a9			    ; Check if current block contains the pointer 
11a9			    ld a, l             ; Load low byte of pointer 
11a9			    cp (hl+1)           ; Compare with high byte of current block's address 
11a9			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11a9			    ld a, h             ; Load high byte of pointer 
11a9			    cp (hl+2)           ; Compare with low byte of current block's address 
11a9			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11a9			 
11a9			    ; Mark block as free 
11a9			    ld (hl), 0          ; Set status byte to indicate free block 
11a9			    ret                 ; Return 
11a9			 
11a9			free_skip_block_check: 
11a9			    ; Move to the next block 
11a9			    ld bc, 3            ; Size of management overhead 
11a9			    add hl, bc          ; Move to the next block 
11a9			    inc de              ; Increment counter 
11a9			 
11a9			    ; Check if we have reached the end of heap 
11a9			    ld a, e             ; Load low byte of heap end address 
11a9			    cp (hl)             ; Compare with low byte of current address 
11a9			    jr nz, free_search_loop  ; If not equal, continue searching 
11a9			    ld a, d             ; Load high byte of heap end address 
11a9			    cp 0                ; Check if it's zero (end of memory) 
11a9			    jr nz, free_search_loop  ; If not zero, continue searching 
11a9			 
11a9			    ; If we reached here, pointer is not found in heap 
11a9			    ret 
11a9			 
11a9			free_exit: 
11a9			    ret                 ; Return 
11a9			 
11a9			; Define heap start and end addresses 
11a9			;heap_start:    .dw 0xC000   ; Start of heap 
11a9			;heap_end:      .dw 0xE000   ; End of heap 
11a9			 
11a9			endif 
11a9			 
11a9			 
11a9			if MALLOC_1 
11a9			 
11a9			 
11a9			 
11a9			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11a9			 
11a9			;moved to firmware.asm 
11a9			;heap_start        .equ  0x9000      ; Starting address of heap 
11a9			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11a9			 
11a9			;      .org 0 
11a9			;      jp    main 
11a9			 
11a9			 
11a9			;      .org  0x100 
11a9			;main: 
11a9			;      ld    HL, 0x8100 
11a9			;      ld    SP, HL 
11a9			; 
11a9			;      call  heap_init 
11a9			; 
11a9			;      ; Make some allocations 
11a9			;      ld    HL, 12 
11a9			;      call  malloc            ; Allocates 0x9004 
11a9			; 
11a9			;      ld    HL, 12 
11a9			;      call  malloc            ; Allocates 0x9014 
11a9			; 
11a9			;      ld    HL, 12 
11a9			;      call  malloc            ; Allocates 0x9024 
11a9			; 
11a9			;      ; Free some allocations 
11a9			;      ld    HL, 0x9014 
11a9			;      call  free 
11a9			; 
11a9			;      ld    HL, 0x9004 
11a9			;      call  free 
11a9			; 
11a9			;      ld    HL, 0x9024 
11a9			;      call  free 
11a9			; 
11a9			; 
11a9			;      halt 
11a9			 
11a9			 
11a9			;------------------------------------------------------------------------------ 
11a9			;     heap_init                                                               : 
11a9			;                                                                             : 
11a9			; Description                                                                 : 
11a9			;     Initialise the heap and make it ready for malloc and free operations.   : 
11a9			;                                                                             : 
11a9			;     The heap is maintained as a linked list, starting with an initial       : 
11a9			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11a9			;     the first free block in the heap. Each block then points to the next    : 
11a9			;     free block within the heap, and the free list ends at the first block   : 
11a9			;     with a null pointer to the next free block.                             : 
11a9			;                                                                             : 
11a9			; Parameters                                                                  : 
11a9			;     Inputs are compile-time only. Two defines which specify the starting    : 
11a9			;     address of the heap and its size are required, along with a memory      : 
11a9			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11a9			;     principally stores a pointer to the first free block in the heap.       : 
11a9			;                                                                             : 
11a9			; Returns                                                                     : 
11a9			;     Nothing                                                                 : 
11a9			;------------------------------------------------------------------------------ 
11a9			heap_init: 
11a9 e5			      push  HL 
11aa			 
11aa			      ; Initialise free list struct 
11aa 21 0e 80		      ld    HL, heap_start 
11ad 22 0a 80		      ld    (free_list), HL 
11b0 21 00 00		      ld    HL, 0 
11b3 22 0c 80		      ld    (free_list+2), HL 
11b6			 
11b6			      ; Insert first free block at bottom of heap, consumes entire heap 
11b6 21 0a 80		      ld    HL, heap_start+heap_size-4 
11b9 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
11bc 21 fc ff		      ld    HL, heap_size-4 
11bf 22 10 80		      ld    (heap_start+2), HL      ; Block size 
11c2			 
11c2			      ; Insert end of free list block at top of heap - two null words will 
11c2			      ; terminate the free list 
11c2 21 00 00		      ld    HL, 0 
11c5 22 0c 80		      ld    (heap_start+heap_size-2), HL 
11c8 22 0a 80		      ld    (heap_start+heap_size-4), HL 
11cb			 
11cb e1			      pop   HL 
11cc			 
11cc c9			      ret 
11cd			 
11cd			 
11cd			;------------------------------------------------------------------------------ 
11cd			;     malloc                                                                  : 
11cd			;                                                                             : 
11cd			; Description                                                                 : 
11cd			;     Allocates the wanted space from the heap and returns the address of the : 
11cd			;     first useable byte of the allocation.                                   : 
11cd			;                                                                             : 
11cd			;     Allocations can happen in one of two ways:                              : 
11cd			;                                                                             : 
11cd			;     1. A free block may be found which is the exact size wanted. In this    : 
11cd			;        case the block is removed from the free list and retuedn to the      : 
11cd			;        caller.                                                              : 
11cd			;     2. A free block may be found which is larger than the size wanted. In   : 
11cd			;        this case, the larger block is split into two. The first portion of  : 
11cd			;        this block will become the requested space by the malloc call and    : 
11cd			;        is returned to the caller. The second portion becomes a new free     : 
11cd			;        block, and the free list is adjusted to maintain continuity via this : 
11cd			;        newly created block.                                                 : 
11cd			;                                                                             : 
11cd			;     malloc does not set any initial value in the allocated space, the       : 
11cd			;     caller is required to do this as required.                              : 
11cd			;                                                                             : 
11cd			;     This implementation of malloc uses the stack exclusively, and is        : 
11cd			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11cd			;     advisable to disable interrupts before calling malloc, and recommended  : 
11cd			;     to avoid the use of malloc inside ISRs in general.                      : 
11cd			;                                                                             : 
11cd			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11cd			;                                                                             : 
11cd			; Parameters                                                                  : 
11cd			;     HL  Number of bytes wanted                                              : 
11cd			;                                                                             : 
11cd			; Returns                                                                     : 
11cd			;     HL  Address of the first useable byte of the allocation                 : 
11cd			;                                                                             : 
11cd			; Flags                                                                       : 
11cd			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11cd			;                                                                             : 
11cd			; Stack frame                                                                 : 
11cd			;       |             |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |     BC      |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |     DE      |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |     IX      |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |  prev_free  |                                                       : 
11cd			;   +4  +-------------+                                                       : 
11cd			;       |  this_free  |                                                       : 
11cd			;   +2  +-------------+                                                       : 
11cd			;       |  next_free  |                                                       : 
11cd			;   +0  +-------------+                                                       : 
11cd			;       |             |                                                       : 
11cd			;                                                                             : 
11cd			;------------------------------------------------------------------------------ 
11cd			 
11cd			 
11cd			;malloc: 
11cd			; 
11cd			;	SAVESP ON 1 
11cd			; 
11cd			;	call malloc_code 
11cd			; 
11cd			;	CHECKSP ON 1 
11cd			;	ret 
11cd			 
11cd			 
11cd			malloc: 
11cd c5			      push  BC 
11ce d5			      push  DE 
11cf dd e5		      push  IX 
11d1			if DEBUG_FORTH_MALLOC_HIGH 
11d1			call malloc_guard_entry 
11d1			endif 
11d1			 
11d1					if DEBUG_FORTH_MALLOC 
11d1						DMARK "mal" 
11d1						CALLMONITOR 
11d1					endif 
11d1 7c			      ld    A, H                    ; Exit if no space requested 
11d2 b5			      or    L 
11d3 ca 92 12		      jp    Z, malloc_early_exit 
11d6			 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			; 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			 
11d6			 
11d6			 
11d6			 
11d6					if DEBUG_FORTH_MALLOC 
11d6						DMARK "maA" 
11d6						CALLMONITOR 
11d6					endif 
11d6			      ; Set up stack frame 
11d6 eb			      ex    DE, HL 
11d7 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11da 39			      add   HL, SP 
11db f9			      ld    SP, HL 
11dc dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11e0 dd 39		      add   IX, SP 
11e2			 
11e2			      ; Setup initial state 
11e2 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11e5 19			      add   HL, DE 
11e6			 
11e6 44			      ld    B, H                    ; Move want to BC 
11e7 4d			      ld    C, L 
11e8			 
11e8 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
11eb dd 75 04		      ld    (IX+4), L 
11ee dd 74 05		      ld    (IX+5), H 
11f1			 
11f1 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11f2 23			      inc   HL 
11f3 56			      ld    D, (HL) 
11f4 dd 73 02		      ld    (IX+2), E 
11f7 dd 72 03		      ld    (IX+3), D 
11fa eb			      ex    DE, HL                  ; this_free ptr into HL 
11fb			 
11fb					if DEBUG_FORTH_MALLOC 
11fb						DMARK "maB" 
11fb						CALLMONITOR 
11fb					endif 
11fb			      ; Loop through free block list to find some space 
11fb			malloc_find_space: 
11fb 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11fc 23			      inc   HL 
11fd 56			      ld    D, (HL) 
11fe			 
11fe 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
11ff b3			      or    E 
1200 ca 8c 12		      jp    Z, malloc_no_space 
1203			 
1203 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1206 dd 72 01		      ld    (IX+1), D 
1209			 
1209			      ; Does this block have enough space to make the allocation? 
1209 23			      inc   HL                      ; Load free block size into DE 
120a 5e			      ld    E, (HL) 
120b 23			      inc   HL 
120c 56			      ld    D, (HL) 
120d			 
120d eb			      ex    DE, HL                  ; Check size of block against want 
120e b7			      or    A                       ; Ensure carry flag clear 
120f ed 42		      sbc   HL, BC 
1211 e5			      push  HL                      ; Store the result for later (new block size) 
1212			 
1212 ca 61 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1215 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1217			 
1217			      ; this_free block is not big enough, setup ptrs to test next free block 
1217 e1			      pop   HL                      ; Discard previous result 
1218			 
1218 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
121b dd 66 03		      ld    H, (IX+3) 
121e dd 75 04		      ld    (IX+4), L 
1221 dd 74 05		      ld    (IX+5), H 
1224			 
1224 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1227 dd 66 01		      ld    H, (IX+1) 
122a dd 75 02		      ld    (IX+2), L 
122d dd 74 03		      ld    (IX+3), H 
1230			 
1230					if DEBUG_FORTH_MALLOC 
1230						DMARK "MA>" 
1230						CALLMONITOR 
1230					endif 
1230 18 c9		      jr    malloc_find_space 
1232			 
1232			      ; split a bigger block into two - requested size and remaining size 
1232			malloc_alloc_split: 
1232					if DEBUG_FORTH_MALLOC 
1232						DMARK "MAs" 
1232						CALLMONITOR 
1232					endif 
1232 eb			      ex    DE, HL                  ; Calculate address of new free block 
1233 2b			      dec   HL 
1234 2b			      dec   HL 
1235 2b			      dec   HL 
1236 09			      add   HL, BC 
1237			 
1237			      ; Create a new block and point it at next_free 
1237 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
123a dd 56 01		      ld    D, (IX+1) 
123d			 
123d 73			      ld    (HL), E                 ; Store next_free ptr into new block 
123e 23			      inc   HL 
123f 72			      ld    (HL), D 
1240			 
1240 d1			      pop   DE                      ; Store size of new block into new block 
1241 23			      inc   HL 
1242 73			      ld    (HL), E 
1243 23			      inc   HL 
1244 72			      ld    (HL), D 
1245			 
1245			      ; Update this_free ptr to point to new block 
1245 2b			      dec   HL 
1246 2b			      dec   HL 
1247 2b			      dec   HL 
1248			 
1248 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
124b dd 56 03		      ld    D, (IX+3) 
124e			 
124e dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1251 dd 74 03		      ld    (IX+3), H 
1254			 
1254			      ; Modify this_free block to be allocation 
1254 eb			      ex    DE, HL 
1255 af			      xor   A                       ; Null the next block ptr of allocated block 
1256 77			      ld    (HL), A 
1257 23			      inc   HL 
1258 77			      ld    (HL), A 
1259			 
1259 23			      inc   HL                      ; Store want size into allocated block 
125a 71			      ld    (HL), C 
125b 23			      inc   HL 
125c 70			      ld    (HL), B 
125d 23			      inc   HL 
125e e5			      push  HL                      ; Address of allocation to return 
125f			 
125f 18 19		      jr    malloc_update_links 
1261			 
1261			malloc_alloc_fit: 
1261 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1262			 
1262					if DEBUG_FORTH_MALLOC 
1262						DMARK "MAf" 
1262						CALLMONITOR 
1262					endif 
1262			      ; Modify this_free block to be allocation 
1262 eb			      ex    DE, HL 
1263 2b			      dec   HL 
1264 2b			      dec   HL 
1265 2b			      dec   HL 
1266			 
1266 af			      xor   A                       ; Null the next block ptr of allocated block 
1267 77			      ld    (HL), A 
1268 23			      inc   HL 
1269 77			      ld    (HL), A 
126a			 
126a 23			      inc   HL                      ; Store address of allocation to return 
126b 23			      inc   HL 
126c 23			      inc   HL 
126d e5			      push  HL 
126e			 
126e			      ; Copy next_free ptr to this_free, remove allocated block from free list 
126e dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1271 dd 66 01		      ld    H, (IX+1) 
1274			 
1274 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1277 dd 74 03		      ld    (IX+3), H 
127a			 
127a			 
127a			malloc_update_links: 
127a			      ; Update prev_free ptr to point to this_free 
127a dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
127d dd 66 05		      ld    H, (IX+5) 
1280			 
1280 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1283 dd 56 03		      ld    D, (IX+3) 
1286			 
1286 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1287 23			      inc   HL 
1288 72			      ld    (HL), D 
1289			 
1289					if DEBUG_FORTH_MALLOC 
1289						DMARK "Mul" 
1289						CALLMONITOR 
1289					endif 
1289			      ; Clear the Z flag to indicate successful allocation 
1289 7a			      ld    A, D 
128a b3			      or    E 
128b			 
128b d1			      pop   DE                      ; Address of allocation 
128c					if DEBUG_FORTH_MALLOC 
128c						DMARK "MAu" 
128c						CALLMONITOR 
128c					endif 
128c			 
128c			malloc_no_space: 
128c 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
128f 39			      add   HL, SP 
1290 f9			      ld    SP, HL 
1291			 
1291 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1292					if DEBUG_FORTH_MALLOC 
1292						DMARK "MAN" 
1292						CALLMONITOR 
1292					endif 
1292			 
1292			malloc_early_exit: 
1292					if DEBUG_FORTH_MALLOC 
1292						DMARK "MAx" 
1292						CALLMONITOR 
1292					endif 
1292 dd e1		      pop   IX 
1294 d1			      pop   DE 
1295 c1			      pop   BC 
1296			 
1296			if DEBUG_FORTH_MALLOC_HIGH 
1296			call malloc_guard_exit 
1296			call malloc_guard_zerolen 
1296			endif 
1296 c9			      ret 
1297			 
1297			 
1297			;------------------------------------------------------------------------------ 
1297			;     free                                                                    : 
1297			;                                                                             : 
1297			; Description                                                                 : 
1297			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1297			;     returned by malloc, otherwise the behaviour is undefined.               : 
1297			;                                                                             : 
1297			;     Where possible, directly adjacent free blocks will be merged together   : 
1297			;     into larger blocks to help ensure that the heap does not become         : 
1297			;     excessively fragmented.                                                 : 
1297			;                                                                             : 
1297			;     free does not clear or set any other value into the freed space, and    : 
1297			;     therefore its contents may be visible through subsequent malloc's. The  : 
1297			;     caller should clear the freed space as required.                        : 
1297			;                                                                             : 
1297			;     This implementation of free uses the stack exclusively, and is          : 
1297			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1297			;     advisable to disable interrupts before calling free, and recommended    : 
1297			;     to avoid the use of free inside ISRs in general.                        : 
1297			;                                                                             : 
1297			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1297			;                                                                             : 
1297			; Parameters                                                                  : 
1297			;     HL  Pointer to address of first byte of allocation to be freed          : 
1297			;                                                                             : 
1297			; Returns                                                                     : 
1297			;     Nothing                                                                 : 
1297			;                                                                             : 
1297			; Stack frame                                                                 : 
1297			;       |             |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |     BC      |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |     DE      |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |     IX      |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |  prev_free  |                                                       : 
1297			;   +2  +-------------+                                                       : 
1297			;       |  next_free  |                                                       : 
1297			;   +0  +-------------+                                                       : 
1297			;       |             |                                                       : 
1297			;                                                                             : 
1297			;------------------------------------------------------------------------------ 
1297			free: 
1297 c5			      push  BC 
1298 d5			      push  DE 
1299 dd e5		      push  IX 
129b			 
129b 7c			      ld    A, H                    ; Exit if ptr is null 
129c b5			      or    L 
129d ca 61 13		      jp    Z, free_early_exit 
12a0			 
12a0			      ; Set up stack frame 
12a0 eb			      ex    DE, HL 
12a1 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12a4 39			      add   HL, SP 
12a5 f9			      ld    SP, HL 
12a6 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12aa dd 39		      add   IX, SP 
12ac			 
12ac			      ; The address in HL points to the start of the useable allocated space, 
12ac			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12ac			      ; address of the block itself. 
12ac eb			      ex    DE, HL 
12ad 11 fc ff		      ld    DE, -4 
12b0 19			      add   HL, DE 
12b1			 
12b1			      ; An allocated block must have a null next block pointer in it 
12b1 7e			      ld    A, (HL) 
12b2 23			      inc   HL 
12b3 b6			      or    (HL) 
12b4 c2 5c 13		      jp    NZ, free_done 
12b7			 
12b7 2b			      dec   HL 
12b8			 
12b8 44			      ld    B, H                    ; Copy HL to BC 
12b9 4d			      ld    C, L 
12ba			 
12ba			      ; Loop through the free list to find the first block with an address 
12ba			      ; higher than the block being freed 
12ba 21 0a 80		      ld    HL, free_list 
12bd			 
12bd			free_find_higher_block: 
12bd 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12be 23			      inc   HL 
12bf 56			      ld    D, (HL) 
12c0 2b			      dec   HL 
12c1			 
12c1 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12c4 dd 72 01		      ld    (IX+1), D 
12c7 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12ca dd 74 03		      ld    (IX+3), H 
12cd			 
12cd 78			      ld    A, B                    ; Check if DE is greater than BC 
12ce ba			      cp    D                       ; Compare MSB first 
12cf 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12d1 30 04		      jr    NC, free_find_higher_block_skip 
12d3 79			      ld    A, C 
12d4 bb			      cp    E                       ; Then compare LSB 
12d5 38 08		      jr    C, free_found_higher_block 
12d7			 
12d7			free_find_higher_block_skip: 
12d7 7a			      ld    A, D                    ; Reached the end of the free list? 
12d8 b3			      or    E 
12d9 ca 5c 13		      jp    Z, free_done 
12dc			 
12dc eb			      ex    DE, HL 
12dd			 
12dd 18 de		      jr    free_find_higher_block 
12df			 
12df			free_found_higher_block: 
12df			      ; Insert freed block between prev and next free blocks 
12df 71			      ld    (HL), C                 ; Point prev free block to freed block 
12e0 23			      inc   HL 
12e1 70			      ld    (HL), B 
12e2			 
12e2 60			      ld    H, B                    ; Point freed block at next free block 
12e3 69			      ld    L, C 
12e4 73			      ld    (HL), E 
12e5 23			      inc   HL 
12e6 72			      ld    (HL), D 
12e7			 
12e7			      ; Check if the freed block is adjacent to the next free block 
12e7 23			      inc   HL                      ; Load size of freed block into HL 
12e8 5e			      ld    E, (HL) 
12e9 23			      inc   HL 
12ea 56			      ld    D, (HL) 
12eb eb			      ex    DE, HL 
12ec			 
12ec 09			      add   HL, BC                  ; Add addr of freed block and its size 
12ed			 
12ed dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12f0 dd 56 01		      ld    D, (IX+1) 
12f3			 
12f3 b7			      or    A                       ; Clear the carry flag 
12f4 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12f6 20 22		      jr    NZ, free_check_adjacent_to_prev 
12f8			 
12f8			      ; Freed block is adjacent to next, merge into one bigger block 
12f8 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12f9 5e			      ld    E, (HL) 
12fa 23			      inc   HL 
12fb 56			      ld    D, (HL) 
12fc e5			      push  HL                      ; Save ptr to next block for later 
12fd			 
12fd 60			      ld    H, B                    ; Store ptr from next block into freed block 
12fe 69			      ld    L, C 
12ff 73			      ld    (HL), E 
1300 23			      inc   HL 
1301 72			      ld    (HL), D 
1302			 
1302 e1			      pop   HL                      ; Restore ptr to next block 
1303 23			      inc   HL                      ; Load size of next block into DE 
1304 5e			      ld    E, (HL) 
1305 23			      inc   HL 
1306 56			      ld    D, (HL) 
1307 d5			      push  DE                      ; Save next block size for later 
1308			 
1308 60			      ld    H, B                    ; Load size of freed block into HL 
1309 69			      ld    L, C 
130a 23			      inc   HL 
130b 23			      inc   HL 
130c 5e			      ld    E, (HL) 
130d 23			      inc   HL 
130e 56			      ld    D, (HL) 
130f eb			      ex    DE, HL 
1310			 
1310 d1			      pop   DE                      ; Restore size of next block 
1311 19			      add   HL, DE                  ; Add sizes of both blocks 
1312 eb			      ex    DE, HL 
1313			 
1313 60			      ld    H, B                    ; Store new bigger size into freed block 
1314 69			      ld    L, C 
1315 23			      inc   HL 
1316 23			      inc   HL 
1317 73			      ld    (HL), E 
1318 23			      inc   HL 
1319 72			      ld    (HL), D 
131a			 
131a			free_check_adjacent_to_prev: 
131a			      ; Check if the freed block is adjacent to the prev free block 
131a dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
131d dd 66 03		      ld    H, (IX+3) 
1320			 
1320 23			      inc   HL                      ; Size of prev free block into DE 
1321 23			      inc   HL 
1322 5e			      ld    E, (HL) 
1323 23			      inc   HL 
1324 56			      ld    D, (HL) 
1325 2b			      dec   HL 
1326 2b			      dec   HL 
1327 2b			      dec   HL 
1328			 
1328 19			      add   HL, DE                  ; Add prev block addr and size 
1329			 
1329 b7			      or    A                       ; Clear the carry flag 
132a ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
132c 20 2e		      jr    NZ, free_done 
132e			 
132e			      ; Freed block is adjacent to prev, merge into one bigger block 
132e 60			      ld    H, B                    ; Load next ptr from freed block into DE 
132f 69			      ld    L, C 
1330 5e			      ld    E, (HL) 
1331 23			      inc   HL 
1332 56			      ld    D, (HL) 
1333 e5			      push  HL                      ; Save freed block ptr for later 
1334			 
1334 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1337 dd 66 03		      ld    H, (IX+3) 
133a 73			      ld    (HL), E 
133b 23			      inc   HL 
133c 72			      ld    (HL), D 
133d			 
133d e1			      pop   HL                      ; Restore freed block ptr 
133e 23			      inc   HL                      ; Load size of freed block into DE 
133f 5e			      ld    E, (HL) 
1340 23			      inc   HL 
1341 56			      ld    D, (HL) 
1342 d5			      push  DE                      ; Save freed block size for later 
1343			 
1343 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1346 dd 66 03		      ld    H, (IX+3) 
1349 23			      inc   HL 
134a 23			      inc   HL 
134b 5e			      ld    E, (HL) 
134c 23			      inc   HL 
134d 56			      ld    D, (HL) 
134e			 
134e e1			      pop   HL                      ; Add sizes of both blocks 
134f 19			      add   HL, DE 
1350 eb			      ex    DE, HL 
1351			 
1351 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1354 dd 66 03		      ld    H, (IX+3) 
1357 23			      inc   HL 
1358 23			      inc   HL 
1359 73			      ld    (HL), E 
135a 23			      inc   HL 
135b 72			      ld    (HL), D 
135c			 
135c			free_done: 
135c 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
135f 39			      add   HL, SP 
1360 f9			      ld    SP, HL 
1361			 
1361			free_early_exit: 
1361 dd e1		      pop   IX 
1363 d1			      pop   DE 
1364 c1			      pop   BC 
1365			 
1365 c9			      ret 
1366			 
1366			; moved to firmware.asm 
1366			; 
1366			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1366			;                  .dw   0 
1366			 
1366			 
1366			endif 
1366			 
1366			 
1366			if MALLOC_3 
1366			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1366			;heap_start        .equ  0x9000      ; Starting address of heap 
1366			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1366			; 
1366			 ;     .org 0 
1366			  ;    jp    main 
1366			; 
1366			; 
1366			 ;     .org  0x100 
1366			;main: 
1366			 ;     ld    HL, 0x8100 
1366			  ;    ld    SP, HL 
1366			; 
1366			;      call  heap_init 
1366			 
1366			      ; Make some allocations 
1366			;      ld    HL, 12 
1366			;      call  malloc            ; Allocates 0x9004 
1366			; 
1366			 ;     ld    HL, 12 
1366			;      call  malloc            ; Allocates 0x9014 
1366			 
1366			;      ld    HL, 12 
1366			;      call  malloc            ; Allocates 0x9024 
1366			 
1366			      ; Free some allocations 
1366			;      ld    HL, 0x9014 
1366			;      call  free 
1366			 
1366			;      ld    HL, 0x9004 
1366			;      call  free 
1366			; 
1366			;      ld    HL, 0x9024 
1366			;      call  free 
1366			 
1366			 
1366			 ;     halt 
1366			 
1366			 
1366			;------------------------------------------------------------------------------ 
1366			;     heap_init                                                               : 
1366			;                                                                             : 
1366			; Description                                                                 : 
1366			;     Initialise the heap and make it ready for malloc and free operations.   : 
1366			;                                                                             : 
1366			;     The heap is maintained as a linked list, starting with an initial       : 
1366			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1366			;     the first free block in the heap. Each block then points to the next    : 
1366			;     free block within the heap, and the free list ends at the first block   : 
1366			;     with a null pointer to the next free block.                             : 
1366			;                                                                             : 
1366			; Parameters                                                                  : 
1366			;     Inputs are compile-time only. Two defines which specify the starting    : 
1366			;     address of the heap and its size are required, along with a memory      : 
1366			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1366			;     principally stores a pointer to the first free block in the heap.       : 
1366			;                                                                             : 
1366			; Returns                                                                     : 
1366			;     Nothing                                                                 : 
1366			;------------------------------------------------------------------------------ 
1366			heap_init: 
1366			      push  HL 
1366			 
1366			      ; Initialise free list struct 
1366			      ld    HL, heap_start 
1366			      ld    (free_list), HL 
1366			      ld    HL, 0 
1366			      ld    (free_list+2), HL 
1366			 
1366			      ; Insert first free block at bottom of heap, consumes entire heap 
1366			      ld    HL, heap_start+heap_size-4 
1366			      ld    (heap_start), HL        ; Next block (end of free list) 
1366			      ld    HL, heap_size-4 
1366			      ld    (heap_start+2), HL      ; Block size 
1366			 
1366			      ; Insert end of free list block at top of heap - two null words will 
1366			      ; terminate the free list 
1366			      ld    HL, 0 
1366			      ld    (heap_start+heap_size-2), HL 
1366			      ld    (heap_start+heap_size-4), HL 
1366			 
1366			      pop   HL 
1366			 
1366			      ret 
1366			 
1366			 
1366			;------------------------------------------------------------------------------ 
1366			;     malloc                                                                  : 
1366			;                                                                             : 
1366			; Description                                                                 : 
1366			;     Allocates the wanted space from the heap and returns the address of the : 
1366			;     first useable byte of the allocation.                                   : 
1366			;                                                                             : 
1366			;     Allocations can happen in one of two ways:                              : 
1366			;                                                                             : 
1366			;     1. A free block may be found which is the exact size wanted. In this    : 
1366			;        case the block is removed from the free list and retuedn to the      : 
1366			;        caller.                                                              : 
1366			;     2. A free block may be found which is larger than the size wanted. In   : 
1366			;        this case, the larger block is split into two. The first portion of  : 
1366			;        this block will become the requested space by the malloc call and    : 
1366			;        is returned to the caller. The second portion becomes a new free     : 
1366			;        block, and the free list is adjusted to maintain continuity via this : 
1366			;        newly created block.                                                 : 
1366			;                                                                             : 
1366			;     malloc does not set any initial value in the allocated space, the       : 
1366			;     caller is required to do this as required.                              : 
1366			;                                                                             : 
1366			;     This implementation of malloc uses the stack exclusively, and is        : 
1366			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1366			;     advisable to disable interrupts before calling malloc, and recommended  : 
1366			;     to avoid the use of malloc inside ISRs in general.                      : 
1366			;                                                                             : 
1366			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1366			;                                                                             : 
1366			; Parameters                                                                  : 
1366			;     HL  Number of bytes wanted                                              : 
1366			;                                                                             : 
1366			; Returns                                                                     : 
1366			;     HL  Address of the first useable byte of the allocation                 : 
1366			;                                                                             : 
1366			; Flags                                                                       : 
1366			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1366			;                                                                             : 
1366			; Stack frame                                                                 : 
1366			;       |             |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     BC      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     DE      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     IX      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |  prev_free  |                                                       : 
1366			;   +4  +-------------+                                                       : 
1366			;       |  this_free  |                                                       : 
1366			;   +2  +-------------+                                                       : 
1366			;       |  next_free  |                                                       : 
1366			;   +0  +-------------+                                                       : 
1366			;       |             |                                                       : 
1366			;                                                                             : 
1366			;------------------------------------------------------------------------------ 
1366			malloc: 
1366			      push  BC 
1366			      push  DE 
1366			      push  IX 
1366			 
1366			      ld    A, H                    ; Exit if no space requested 
1366			      or    L 
1366			      jp    Z, malloc_early_exit 
1366			 
1366			      ; Set up stack frame 
1366			      ex    DE, HL 
1366			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			      ld    IX, 0                   ; Use IX as a frame pointer 
1366			      add   IX, SP 
1366			 
1366			      ; Setup initial state 
1366			      ld    HL, 4                   ; want must also include space used by block struct 
1366			      add   HL, DE 
1366			 
1366			      ld    B, H                    ; Move want to BC 
1366			      ld    C, L 
1366			 
1366			      ld    HL, free_list           ; Store prev_free ptr to stack 
1366			      ld    (IX+4), L 
1366			      ld    (IX+5), H 
1366			 
1366			      ld    E, (HL)                 ; Store this_free ptr to stack 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      ld    (IX+2), E 
1366			      ld    (IX+3), D 
1366			      ex    DE, HL                  ; this_free ptr into HL 
1366			 
1366			      ; Loop through free block list to find some space 
1366			malloc_find_space: 
1366			      ld    E, (HL)                 ; Load next_free ptr into DE 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			 
1366			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1366			      or    E 
1366			      jp    Z, malloc_no_space 
1366			 
1366			      ld    (IX+0), E               ; Store next_free ptr to stack 
1366			      ld    (IX+1), D 
1366			 
1366			      ; Does this block have enough space to make the allocation? 
1366			      inc   HL                      ; Load free block size into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			 
1366			      ex    DE, HL                  ; Check size of block against want 
1366			      or    A                       ; Ensure carry flag clear 
1366			      sbc   HL, BC 
1366			      push  HL                      ; Store the result for later (new block size) 
1366			 
1366			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1366			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1366			 
1366			      ; this_free block is not big enough, setup ptrs to test next free block 
1366			      pop   HL                      ; Discard previous result 
1366			 
1366			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1366			      ld    H, (IX+3) 
1366			      ld    (IX+4), L 
1366			      ld    (IX+5), H 
1366			 
1366			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1366			      ld    H, (IX+1) 
1366			      ld    (IX+2), L 
1366			      ld    (IX+3), H 
1366			 
1366			      jr    malloc_find_space 
1366			 
1366			      ; split a bigger block into two - requested size and remaining size 
1366			malloc_alloc_split: 
1366			      ex    DE, HL                  ; Calculate address of new free block 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			      add   HL, BC 
1366			 
1366			      ; Create a new block and point it at next_free 
1366			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1366			      ld    D, (IX+1) 
1366			 
1366			      ld    (HL), E                 ; Store next_free ptr into new block 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      pop   DE                      ; Store size of new block into new block 
1366			      inc   HL 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      ; Update this_free ptr to point to new block 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			 
1366			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1366			      ld    D, (IX+3) 
1366			 
1366			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1366			      ld    (IX+3), H 
1366			 
1366			      ; Modify this_free block to be allocation 
1366			      ex    DE, HL 
1366			      xor   A                       ; Null the next block ptr of allocated block 
1366			      ld    (HL), A 
1366			      inc   HL 
1366			      ld    (HL), A 
1366			 
1366			      inc   HL                      ; Store want size into allocated block 
1366			      ld    (HL), C 
1366			      inc   HL 
1366			      ld    (HL), B 
1366			      inc   HL 
1366			      push  HL                      ; Address of allocation to return 
1366			 
1366			      jr    malloc_update_links 
1366			 
1366			malloc_alloc_fit: 
1366			      pop   HL                      ; Dont need new block size, want is exact fit 
1366			 
1366			      ; Modify this_free block to be allocation 
1366			      ex    DE, HL 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			 
1366			      xor   A                       ; Null the next block ptr of allocated block 
1366			      ld    (HL), A 
1366			      inc   HL 
1366			      ld    (HL), A 
1366			 
1366			      inc   HL                      ; Store address of allocation to return 
1366			      inc   HL 
1366			      inc   HL 
1366			      push  HL 
1366			 
1366			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1366			      ld    L, (IX+0)               ; next_free to HL 
1366			      ld    H, (IX+1) 
1366			 
1366			      ld    (IX+2), L               ; HL to this_free 
1366			      ld    (IX+3), H 
1366			 
1366			 
1366			malloc_update_links: 
1366			      ; Update prev_free ptr to point to this_free 
1366			      ld    L, (IX+4)               ; prev_free ptr to HL 
1366			      ld    H, (IX+5) 
1366			 
1366			      ld    E, (IX+2)               ; this_free ptr to DE 
1366			      ld    D, (IX+3) 
1366			 
1366			      ld    (HL), E                 ; this_free ptr into prev_free 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      ; Clear the Z flag to indicate successful allocation 
1366			      ld    A, D 
1366			      or    E 
1366			 
1366			      pop   DE                      ; Address of allocation 
1366			 
1366			malloc_no_space: 
1366			      ld    HL, 6                   ; Clean up stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			 
1366			      ex    DE, HL                  ; Alloc addr into HL for return 
1366			 
1366			malloc_early_exit: 
1366			      pop   IX 
1366			      pop   DE 
1366			      pop   BC 
1366			 
1366			      ret 
1366			 
1366			 
1366			;------------------------------------------------------------------------------ 
1366			;     free                                                                    : 
1366			;                                                                             : 
1366			; Description                                                                 : 
1366			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1366			;     returned by malloc, otherwise the behaviour is undefined.               : 
1366			;                                                                             : 
1366			;     Where possible, directly adjacent free blocks will be merged together   : 
1366			;     into larger blocks to help ensure that the heap does not become         : 
1366			;     excessively fragmented.                                                 : 
1366			;                                                                             : 
1366			;     free does not clear or set any other value into the freed space, and    : 
1366			;     therefore its contents may be visible through subsequent malloc's. The  : 
1366			;     caller should clear the freed space as required.                        : 
1366			;                                                                             : 
1366			;     This implementation of free uses the stack exclusively, and is          : 
1366			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1366			;     advisable to disable interrupts before calling free, and recommended    : 
1366			;     to avoid the use of free inside ISRs in general.                        : 
1366			;                                                                             : 
1366			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1366			;                                                                             : 
1366			; Parameters                                                                  : 
1366			;     HL  Pointer to address of first byte of allocation to be freed          : 
1366			;                                                                             : 
1366			; Returns                                                                     : 
1366			;     Nothing                                                                 : 
1366			;                                                                             : 
1366			; Stack frame                                                                 : 
1366			;       |             |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     BC      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     DE      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     IX      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |  prev_free  |                                                       : 
1366			;   +2  +-------------+                                                       : 
1366			;       |  next_free  |                                                       : 
1366			;   +0  +-------------+                                                       : 
1366			;       |             |                                                       : 
1366			;                                                                             : 
1366			;------------------------------------------------------------------------------ 
1366			free: 
1366			      push  BC 
1366			      push  DE 
1366			      push  IX 
1366			 
1366			      ld    A, H                    ; Exit if ptr is null 
1366			      or    L 
1366			      jp    Z, free_early_exit 
1366			 
1366			      ; Set up stack frame 
1366			      ex    DE, HL 
1366			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			      ld    IX, 0                   ; Use IX as a frame pointer 
1366			      add   IX, SP 
1366			 
1366			      ; The address in HL points to the start of the useable allocated space, 
1366			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1366			      ; address of the block itself. 
1366			      ex    DE, HL 
1366			      ld    DE, -4 
1366			      add   HL, DE 
1366			 
1366			      ; An allocated block must have a null next block pointer in it 
1366			      ld    A, (HL) 
1366			      inc   HL 
1366			      or    (HL) 
1366			      jp    NZ, free_done 
1366			 
1366			      dec   HL 
1366			 
1366			      ld    B, H                    ; Copy HL to BC 
1366			      ld    C, L 
1366			 
1366			      ; Loop through the free list to find the first block with an address 
1366			      ; higher than the block being freed 
1366			      ld    HL, free_list 
1366			 
1366			free_find_higher_block: 
1366			      ld    E, (HL)                 ; Load next ptr from free block 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      dec   HL 
1366			 
1366			      ld    (IX+0), E               ; Save ptr to next free block 
1366			      ld    (IX+1), D 
1366			      ld    (IX+2), L               ; Save ptr to prev free block 
1366			      ld    (IX+3), H 
1366			 
1366			      ld    A, B                    ; Check if DE is greater than BC 
1366			      cp    D                       ; Compare MSB first 
1366			      jr    Z, $+4                  ; MSB the same, compare LSB 
1366			      jr    NC, free_find_higher_block_skip 
1366			      ld    A, C 
1366			      cp    E                       ; Then compare LSB 
1366			      jr    C, free_found_higher_block 
1366			 
1366			free_find_higher_block_skip: 
1366			      ld    A, D                    ; Reached the end of the free list? 
1366			      or    E 
1366			      jp    Z, free_done 
1366			 
1366			      ex    DE, HL 
1366			 
1366			      jr    free_find_higher_block 
1366			 
1366			free_found_higher_block: 
1366			      ; Insert freed block between prev and next free blocks 
1366			      ld    (HL), C                 ; Point prev free block to freed block 
1366			      inc   HL 
1366			      ld    (HL), B 
1366			 
1366			      ld    H, B                    ; Point freed block at next free block 
1366			      ld    L, C 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      ; Check if the freed block is adjacent to the next free block 
1366			      inc   HL                      ; Load size of freed block into HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      ex    DE, HL 
1366			 
1366			      add   HL, BC                  ; Add addr of freed block and its size 
1366			 
1366			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1366			      ld    D, (IX+1) 
1366			 
1366			      or    A                       ; Clear the carry flag 
1366			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1366			      jr    NZ, free_check_adjacent_to_prev 
1366			 
1366			      ; Freed block is adjacent to next, merge into one bigger block 
1366			      ex    DE, HL                  ; Load next ptr from next block into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  HL                      ; Save ptr to next block for later 
1366			 
1366			      ld    H, B                    ; Store ptr from next block into freed block 
1366			      ld    L, C 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      pop   HL                      ; Restore ptr to next block 
1366			      inc   HL                      ; Load size of next block into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  DE                      ; Save next block size for later 
1366			 
1366			      ld    H, B                    ; Load size of freed block into HL 
1366			      ld    L, C 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      ex    DE, HL 
1366			 
1366			      pop   DE                      ; Restore size of next block 
1366			      add   HL, DE                  ; Add sizes of both blocks 
1366			      ex    DE, HL 
1366			 
1366			      ld    H, B                    ; Store new bigger size into freed block 
1366			      ld    L, C 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			free_check_adjacent_to_prev: 
1366			      ; Check if the freed block is adjacent to the prev free block 
1366			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1366			      ld    H, (IX+3) 
1366			 
1366			      inc   HL                      ; Size of prev free block into DE 
1366			      inc   HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			 
1366			      add   HL, DE                  ; Add prev block addr and size 
1366			 
1366			      or    A                       ; Clear the carry flag 
1366			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1366			      jr    NZ, free_done 
1366			 
1366			      ; Freed block is adjacent to prev, merge into one bigger block 
1366			      ld    H, B                    ; Load next ptr from freed block into DE 
1366			      ld    L, C 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  HL                      ; Save freed block ptr for later 
1366			 
1366			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1366			      ld    H, (IX+3) 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      pop   HL                      ; Restore freed block ptr 
1366			      inc   HL                      ; Load size of freed block into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  DE                      ; Save freed block size for later 
1366			 
1366			      ld    L, (IX+2)               ; Load size of prev block into DE 
1366			      ld    H, (IX+3) 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			 
1366			      pop   HL                      ; Add sizes of both blocks 
1366			      add   HL, DE 
1366			      ex    DE, HL 
1366			 
1366			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1366			      ld    H, (IX+3) 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			free_done: 
1366			      ld    HL, 4                   ; Clean up stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			 
1366			free_early_exit: 
1366			      pop   IX 
1366			      pop   DE 
1366			      pop   BC 
1366			 
1366			      ret 
1366			 
1366			 
1366			;      .org 0x8000 
1366			; 
1366			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1366			 ;                 .dw   0 
1366			 
1366			endif 
1366			 
1366			 
1366			if MALLOC_4 
1366			 
1366			; My memory allocation code. Very very simple.... 
1366			; allocate space under 250 chars 
1366			 
1366			heap_init: 
1366				; init start of heap as zero 
1366				;  
1366			 
1366				ld hl, heap_start 
1366				ld a, 0 
1366				ld (hl), a      ; empty block 
1366				inc hl 
1366				ld a, 0 
1366				ld (hl), a      ; length of block 
1366				; write end of list 
1366				inc hl 
1366				ld a,(hl) 
1366				inc hl 
1366				ld a,(hl) 
1366				 
1366			 
1366				; init some malloc vars 
1366			 
1366				ld hl, 0 
1366				ld (free_list), hl       ; store last malloc location 
1366			 
1366				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1366				ld a, 0 
1366				ld (hl), a 
1366			 
1366			 
1366				ld hl, heap_start 
1366				;  
1366				  
1366				ret 
1366			 
1366			 
1366			;    free block marker 
1366			;    requested size  
1366			;    pointer to next block 
1366			;    .... 
1366			;    next block marker 
1366			 
1366			 
1366			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1366			; 
1366			 
1366			 
1366			malloc:  
1366				push de 
1366				push bc 
1366				push af 
1366			 
1366				; hl space required 
1366				 
1366				ld c, l    ; hold space   (TODO only a max of 255) 
1366			 
1366			;	inc c     ; TODO BUG need to fix memory leak on push str 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			 
1366			 
1366			 
1366				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1366			 
1366				ld a, (free_list+3) 
1366				cp 0 
1366				jr z, .contheap 
1366			 
1366				ld hl, (free_list)     ; get last alloc 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mrs" 
1366						CALLMONITOR 
1366					endif 
1366				jr .startalloc 
1366			 
1366			.contheap: 
1366				ld hl, heap_start 
1366			 
1366			.startalloc: 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mym" 
1366						CALLMONITOR 
1366					endif 
1366			.findblock: 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mmf" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366				ld a,(hl)  
1366				; if byte is zero then clear to use 
1366			 
1366				cp 0 
1366				jr z, .foundemptyblock 
1366			 
1366				; if byte is not clear 
1366				;     then byte is offset to next block 
1366			 
1366				inc hl 
1366				ld a, (hl) ; get size 
1366			.nextblock:	inc hl 
1366					ld e, (hl) 
1366					inc hl 
1366					ld d, (hl) 
1366					ex de, hl 
1366			;	inc hl  ; move past the store space 
1366			;	inc hl  ; move past zero index  
1366			 
1366				; TODO detect no more space 
1366			 
1366				push hl 
1366				ld de, heap_end 
1366				call cmp16 
1366				pop hl 
1366				jr nc, .nospace 
1366			 
1366				jr .findblock 
1366			 
1366			.nospace: ld hl, 0 
1366				jp .exit 
1366			 
1366			 
1366			.foundemptyblock:	 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mme" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			; TODO has block enough space if reusing??? 
1366			 
1366				;  
1366			 
1366			; see if this block has been previously used 
1366				inc hl 
1366				ld a, (hl) 
1366				dec hl 
1366				cp 0 
1366				jr z, .newblock 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "meR" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			; no reusing previously allocated block 
1366			 
1366			; is it smaller than previously used? 
1366				 
1366				inc hl    ; move to size 
1366				ld a, c 
1366				sub (hl)        ; we want c < (hl) 
1366				dec hl    ; move back to marker 
1366			        jr z, .findblock 
1366			 
1366				; update with the new size which should be lower 
1366			 
1366			        ;inc  hl   ; negate next move. move back to size  
1366			 
1366			.newblock: 
1366				; need to be at marker here 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "meN" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			 
1366				ld a, c 
1366			 
1366				ld (free_list+3), a	 ; flag resume from last malloc  
1366				ld (free_list), hl    ; save out last location 
1366			 
1366			 
1366				;inc a     ; space for length byte 
1366				ld (hl), a     ; save block in use marker 
1366			 
1366				inc hl   ; move to space marker 
1366				ld (hl), a    ; save new space 
1366			 
1366				inc hl   ; move to start of allocated area 
1366				 
1366			;	push hl     ; save where we are - 1  
1366			 
1366			;	inc hl  ; move past zero index  
1366				; skip space to set down new marker 
1366			 
1366				; provide some extra space for now 
1366			 
1366				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1366				inc a 
1366				inc a 
1366			 
1366				push hl   ; save where we are in the node block 
1366			 
1366				call addatohl 
1366			 
1366				; write linked list point 
1366			 
1366				pop de     ; get our node position 
1366				ex de, hl 
1366			 
1366				ld (hl), e 
1366				inc hl 
1366				ld (hl), d 
1366			 
1366				inc hl 
1366			 
1366				; now at start of allocated data so save pointer 
1366			 
1366				push hl 
1366			 
1366				; jump to position of next node and setup empty header in DE 
1366			 
1366				ex de, hl 
1366			 
1366			;	inc hl ; move past end of block 
1366			 
1366				ld a, 0 
1366				ld (hl), a   ; empty marker 
1366				inc hl 
1366				ld (hl), a   ; size 
1366				inc hl  
1366				ld (hl), a   ; ptr 
1366				inc hl 
1366				ld (hl), a   ; ptr 
1366			 
1366			 
1366				pop hl 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mmr" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			.exit: 
1366				pop af 
1366				pop bc 
1366				pop de  
1366				ret 
1366			 
1366			 
1366			 
1366			 
1366			free:  
1366				push hl 
1366				push af 
1366				; get address in hl 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "fre" 
1366						CALLMONITOR 
1366					endif 
1366				; data is at hl - move to block count 
1366				dec hl 
1366				dec hl    ; get past pointer 
1366				dec hl 
1366			 
1366				ld a, (hl)    ; need this for a validation check 
1366			 
1366				dec hl    ; move to block marker 
1366			 
1366				; now check that the block count and block marker are the same  
1366			        ; this checks that we are on a malloc node and not random memory 
1366			        ; OK a faint chance this could be a problem but rare - famous last words! 
1366			 
1366				ld c, a 
1366				ld a, (hl)    
1366			 
1366				cp c 
1366				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1366			 
1366				; yes good chance we are on a malloc node 
1366			 
1366				ld a, 0      
1366				ld (hl), a   ; mark as free 
1366			 
1366				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1366			 
1366			.freeignore:  
1366			 
1366				pop af 
1366				pop hl 
1366			 
1366				ret 
1366			 
1366			 
1366			 
1366			endif 
1366			 
1366			; eof 
# End of file firmware_memory.asm
1366			  
1366			; device C  
1366			if SOUND_ENABLE  
1366				include "firmware_sound.asm"  
1366			endif  
1366			  
1366			include "firmware_diags.asm"  
1366			; Hardware diags menu 
1366			 
1366			 
1366			config: 
1366			 
1366 3e 00			ld a, 0 
1368 21 8c 13			ld hl, .configmn 
136b cd 03 0b			call menu 
136e			 
136e fe 00			cp 0 
1370 c8				ret z 
1371			 
1371 fe 01			cp 1 
1373 cc 4c 14			call z, .savetostore 
1376			 
1376 fe 02			cp 2 
1378 cc 12 14			call z, .selautoload 
137b fe 03			cp 3 
137d cc 4a 14			call z, .selbank 
1380 fe 05			cp 5 
1382 cc 27 15			call z, .debug_tog 
1385 fe 06			cp 6 
1387 cc 4d 15			call z, hardware_diags 
138a			 
138a 18 da			jr config 
138c			 
138c			.configmn: 
138c 9a 13			dw .c3 
138e b6 13			dw .c2 
1390 cb 13			dw .c2b 
1392 df 13			dw .c4 
1394 e8 13			dw .m4 
1396 03 14			dw .c1 
1398 00 00			dw 0 
139a				 
139a			 
139a .. 00		.c3: db "Add User Dictionary To File",0 
13b6 .. 00		.c2: db "Select Autoload File",0 
13cb .. 00		.c2b: db "Select Storage Bank",0 
13df .. 00		.c4: db "Settings",0 
13e8 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
1403 .. 00		.c1: db "Hardware Diags",0 
1412			 
1412			; Select auto start 
1412			 
1412			.selautoload: 
1412			 
1412				 
1412				if STORAGE_SE 
1412			 
1412 cd 71 14				call config_dir 
1415 21 a3 ef			        ld hl, scratch 
1418 3e 00				ld a, 0 
141a cd 03 0b				call menu 
141d			 
141d					; locate menu option 
141d			 
141d 21 a3 ef				ld hl, scratch 
1420 cd 2a 0a				call table_lookup 
1423			 
1423					; with the pointer to the menu it, the byte following the zero term is the file id 
1423			 
1423 3e 00				ld a, 0 
1425 01 32 00				ld bc, 50   ; max of bytes to look at 
1428 ed b1				cpir  
142a			 
142a 23					inc hl 
142b			 
142b 7e					ld a, (hl)   ; file id 
142c					 
142c				        ; save bank and file ids 
142c			 
142c f5					push af 
142d			 
142d cd ba 03				call storage_get_block_0 
1430			 
1430 f1					pop af 
1431			 
1431 32 0c fa				ld (store_page+STORE_0_FILERUN),a 
1434					 
1434					; save bank id 
1434			 
1434 3a ce f9				ld a,(spi_device) 
1437 32 0b fa				ld (store_page+STORE_0_BANKRUN),a 
143a			 
143a					; save buffer 
143a			 
143a 21 00 00				ld hl, 0 
143d 11 e8 f9				ld de, store_page 
1440 cd 6e 03			call storage_write_block	 ; save update 
1443			  
1443			 
1443			 
1443			 
1443 21 a3 ef				ld hl, scratch 
1446 cd 5e 14				call config_fdir 
1449			 
1449			 
1449				endif 
1449 c9				ret 
144a			 
144a			 
144a			 
144a			; Select storage bank 
144a			 
144a			.selbank: 
144a			 
144a				if STORAGE_SE 
144a				endif 
144a				 
144a c9				ret 
144b			 
144b			if STORAGE_SE 
144b			 
144b			.config_ldir:   
144b				; Load storage bank labels into menu array 
144b			 
144b				 
144b			 
144b			 
144b c9				ret 
144c			 
144c			 
144c			endif 
144c			 
144c			 
144c			; Save user words to storage 
144c			 
144c			.savetostore: 
144c			 
144c				if STORAGE_SE 
144c			 
144c cd 71 14				call config_dir 
144f 21 a3 ef			        ld hl, scratch 
1452 3e 00				ld a, 0 
1454 cd 03 0b				call menu 
1457					 
1457 21 a3 ef				ld hl, scratch 
145a cd 5e 14				call config_fdir 
145d			 
145d			 
145d				endif 
145d			 
145d c9				ret 
145e			 
145e			 
145e			 
145e			if STORAGE_SE 
145e			 
145e			config_fdir: 
145e				; using the scratch dir go through and release the memory allocated for each string 
145e				 
145e 21 a3 ef			ld hl, scratch 
1461 5e			.cfdir:	ld e,(hl) 
1462 23				inc hl 
1463 56				ld d,(hl) 
1464 23				inc hl 
1465			 
1465 eb				ex de, hl 
1466 cd 2f 0d			call ishlzero 
1469 c8				ret z     ; return on null pointer 
146a cd 97 12			call free 
146d eb				ex de, hl 
146e 18 f1			jr .cfdir 
1470			 
1470			 
1470 c9				ret 
1471			 
1471			 
1471			config_dir: 
1471			 
1471				; for the config menus that need to build a directory of storage call this routine 
1471				; it will construct a menu in scratch to pass to menu 
1471			 
1471				; open storage device 
1471			 
1471				; execute DIR to build a list of files and their ids into scratch in menu format 
1471				; once the menu has finished then will need to call config_fdir to release the strings 
1471				 
1471				; c = number items 
1471			 
1471				 
1471 cd ba 03			call storage_get_block_0 
1474			 
1474 21 e8 f9			ld hl, store_page     ; get current id count 
1477 46				ld b, (hl) 
1478 0e 00			ld c, 0    ; count of files   
147a			 
147a			 
147a 21 a3 ef			ld hl, scratch 
147d 22 e4 f9			ld (store_tmp2), hl    ; location to poke strings 
1480			 
1480				; check for empty drive 
1480			 
1480 3e 00			ld a, 0 
1482 b8				cp b 
1483 ca 1d 15			jp z, .dirdone 
1486			 
1486				 
1486					if DEBUG_FORTH_WORDS 
1486						DMARK "Cdc" 
1486 f5				push af  
1487 3a 9b 14			ld a, (.dmark)  
148a 32 bd fb			ld (debug_mark),a  
148d 3a 9c 14			ld a, (.dmark+1)  
1490 32 be fb			ld (debug_mark+1),a  
1493 3a 9d 14			ld a, (.dmark+2)  
1496 32 bf fb			ld (debug_mark+2),a  
1499 18 03			jr .pastdmark  
149b ..			.dmark: db "Cdc"  
149e f1			.pastdmark: pop af  
149f			endm  
# End of macro DMARK
149f						CALLMONITOR 
149f cd 65 16			call break_point_state  
14a2				endm  
# End of macro CALLMONITOR
14a2					endif 
14a2			 
14a2			 
14a2			.diritem:	 
14a2 c5				push bc 
14a3				; for each of the current ids do a search for them and if found push to stack 
14a3			 
14a3 21 40 00				ld hl, STORE_BLOCK_PHY 
14a6 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
14a8 58					ld e,b 
14a9			 
14a9 cd 2a 06				call storage_findnextid 
14ac			 
14ac			 
14ac					; if found hl will be non zero 
14ac			 
14ac cd 2f 0d				call ishlzero 
14af 28 69				jr z, .dirnotfound 
14b1			 
14b1					; increase count 
14b1			 
14b1 c1					pop bc	 
14b2 0c					inc c 
14b3 c5					push bc 
14b4					 
14b4			 
14b4					; get file header and push the file name 
14b4			 
14b4 11 e8 f9				ld de, store_page 
14b7 cd 09 03				call storage_read_block 
14ba			 
14ba					; push file id to stack 
14ba				 
14ba 3a e8 f9				ld a, (store_page) 
14bd 26 00				ld h, 0 
14bf 6f					ld l, a 
14c0			 
14c0					;call forth_push_numhl 
14c0					; TODO store id 
14c0			 
14c0 e5					push hl 
14c1			 
14c1					; push extent count to stack  
14c1				 
14c1 21 eb f9				ld hl, store_page+3 
14c4			 
14c4					; get file name length 
14c4			 
14c4 cd 64 11				call strlenz   
14c7			 
14c7 23					inc hl   ; cover zero term 
14c8 23					inc hl  ; stick the id at the end of the area 
14c9			 
14c9 e5					push hl 
14ca c1					pop bc    ; move length to bc 
14cb			 
14cb cd cd 11				call malloc 
14ce			 
14ce					; TODO save malloc area to scratch 
14ce			 
14ce eb					ex de, hl 
14cf 2a e4 f9				ld hl, (store_tmp2) 
14d2 73					ld (hl), e 
14d3 23					inc hl 
14d4 72					ld (hl), d 
14d5 23					inc hl 
14d6 22 e4 f9				ld (store_tmp2), hl 
14d9			 
14d9					 
14d9			 
14d9					;pop hl   ; get source 
14d9			;		ex de, hl    ; swap aronund	 
14d9			 
14d9 21 eb f9				ld hl, store_page+3 
14dc					if DEBUG_FORTH_WORDS 
14dc						DMARK "CFd" 
14dc f5				push af  
14dd 3a f1 14			ld a, (.dmark)  
14e0 32 bd fb			ld (debug_mark),a  
14e3 3a f2 14			ld a, (.dmark+1)  
14e6 32 be fb			ld (debug_mark+1),a  
14e9 3a f3 14			ld a, (.dmark+2)  
14ec 32 bf fb			ld (debug_mark+2),a  
14ef 18 03			jr .pastdmark  
14f1 ..			.dmark: db "CFd"  
14f4 f1			.pastdmark: pop af  
14f5			endm  
# End of macro DMARK
14f5						CALLMONITOR 
14f5 cd 65 16			call break_point_state  
14f8				endm  
# End of macro CALLMONITOR
14f8					endif 
14f8 ed b0				ldir 
14fa			 
14fa					; de is past string, move back one and store id 
14fa					 
14fa 1b					dec de 
14fb			 
14fb					; store file id 
14fb			 
14fb e1					pop hl 
14fc eb					ex de,hl 
14fd 73					ld (hl), e 
14fe			 
14fe					if DEBUG_FORTH_WORDS 
14fe						DMARK "Cdi" 
14fe f5				push af  
14ff 3a 13 15			ld a, (.dmark)  
1502 32 bd fb			ld (debug_mark),a  
1505 3a 14 15			ld a, (.dmark+1)  
1508 32 be fb			ld (debug_mark+1),a  
150b 3a 15 15			ld a, (.dmark+2)  
150e 32 bf fb			ld (debug_mark+2),a  
1511 18 03			jr .pastdmark  
1513 ..			.dmark: db "Cdi"  
1516 f1			.pastdmark: pop af  
1517			endm  
# End of macro DMARK
1517						CALLMONITOR 
1517 cd 65 16			call break_point_state  
151a				endm  
# End of macro CALLMONITOR
151a					endif 
151a					 
151a			.dirnotfound: 
151a c1					pop bc     
151b 10 85				djnz .diritem 
151d				 
151d			.dirdone:	 
151d			 
151d 3e 00				ld a, 0 
151f 2a e4 f9				ld hl, (store_tmp2) 
1522 77					ld (hl), a 
1523 23					inc hl 
1524 77					ld (hl), a 
1525 23					inc hl 
1526					; push a count of the dir items found 
1526			 
1526			;		ld h, 0 
1526			;		ld l, c 
1526			 
1526 c9				ret 
1527			 
1527			endif 
1527			 
1527			 
1527			; Settings 
1527			; Run  
1527			 
1527			 
1527			 
1527			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1527			;;hd_menu2:   db "        2: Editor",0   
1527			;hd_menu2:   db "        2: Editor       6: Menu",0   
1527			;hd_menu3:   db "        3: Storage",0 
1527			;hd_menu4:   db "0=quit  4: Debug",0 
1527			;hd_don:     db "ON",0 
1527			;hd_doff:     db "OFF",0 
1527			; 
1527			; 
1527			; 
1527			;hardware_diags_old:       
1527			; 
1527			;.diagmenu: 
1527			;	call clear_display 
1527			;	ld a, display_row_1 
1527			;	ld de, hd_menu1 
1527			;	call str_at_display 
1527			; 
1527			;	ld a, display_row_2 
1527			;	ld de, hd_menu2 
1527			;	call str_at_display 
1527			; 
1527			;	ld a, display_row_3 
1527			;	ld de, hd_menu3 
1527			;	call str_at_display 
1527			; 
1527			;	ld a,  display_row_4 
1527			;	ld de, hd_menu4 
1527			;	call str_at_display 
1527			; 
1527			;	; display debug state 
1527			; 
1527			;	ld de, hd_don 
1527			;	ld a, (os_view_disable) 
1527			;	cp 0 
1527			;	jr z, .distog 
1527			;	ld de, hd_doff 
1527			;.distog: ld a, display_row_4+17 
1527			;	call str_at_display 
1527			; 
1527			;	call update_display 
1527			; 
1527			;	call cin_wait 
1527			; 
1527			; 
1527			; 
1527			;	cp '4' 
1527			;	jr nz, .diagn1 
1527			; 
1527			;	; debug toggle 
1527			; 
1527			;	ld a, (os_view_disable) 
1527			;	ld b, '*' 
1527			;	cp 0 
1527			;	jr z, .debtog 
1527			;	ld b, 0 
1527			;.debtog:	 
1527			;	ld a,b 
1527			;	ld (os_view_disable),a 
1527			; 
1527			;.diagn1: cp '0' 
1527			;	 ret z 
1527			; 
1527			;;	cp '1' 
1527			;;       jp z, matrix	 
1527			;;   TODO keyboard matrix test 
1527			; 
1527			;	cp '2' 
1527			;	jp z, .diagedit 
1527			; 
1527			;;	cp '6' 
1527			;;	jp z, .menutest 
1527			;;if ENABLE_BASIC 
1527			;;	cp '6' 
1527			;;	jp z, basic 
1527			;;endif 
1527			 ; 
1527			;	jp .diagmenu 
1527			; 
1527			; 
1527			;	ret 
1527			 
1527			 
1527			.debug_tog: 
1527 21 6e 15			ld hl, .menudebug 
152a				 
152a 3a 94 ef			ld a, (os_view_disable) 
152d fe 2a			cp '*' 
152f 20 04			jr nz,.tdon  
1531 3e 01			ld a, 1 
1533 18 02			jr .tog1 
1535 3e 00		.tdon: ld a, 0 
1537			 
1537			.tog1: 
1537 cd 03 0b			call menu 
153a fe 00			cp 0 
153c c8				ret z 
153d fe 01			cp 1    ; disable debug 
153f 28 04			jr z, .dtog0 
1541 3e 2a			ld a, '*' 
1543 18 02			jr .dtogset 
1545 3e 00		.dtog0: ld a, 0 
1547 32 94 ef		.dtogset:  ld (os_view_disable), a 
154a c3 27 15			jp .debug_tog 
154d			 
154d			 
154d			hardware_diags:       
154d			 
154d			.diagm: 
154d 21 60 15			ld hl, .menuitems 
1550 3e 00			ld a, 0 
1552 cd 03 0b			call menu 
1555			 
1555 fe 00		         cp 0 
1557 c8				 ret z 
1558			 
1558 fe 02			cp 2 
155a ca b9 15			jp z, .diagedit 
155d			 
155d			;	cp '6' 
155d			;	jp z, .menutest 
155d			;if ENABLE_BASIC 
155d			;	cp '6' 
155d			;	jp z, basic 
155d			;endif 
155d			  
155d c3 4d 15			jp .diagm 
1560			 
1560				 
1560 74 15		.menuitems:   	dw .m1 
1562 7f 15				dw .m2 
1564 86 15				dw .m3 
1566 8e 15				dw .m5 
1568 94 15				dw .m5a 
156a 9d 15				dw .m5b 
156c 00 00				dw 0 
156e			 
156e			.menudebug: 
156e a6 15				dw .m6 
1570 af 15				dw .m7 
1572 00 00				dw 0 
1574			 
1574 .. 00		.m1:   db "Key Matrix",0 
157f .. 00		.m2:   db "Editor",0 
1586 .. 00		.m3:   db "Storage",0 
158e .. 00		.m5:   db "Sound",0 
1594 .. 00		.m5a:  db "RAM Test",0 
159d .. 00		.m5b:  db "LCD Test",0 
15a6			 
15a6 .. 00		.m6:   db "Debug ON",0 
15af .. 00		.m7:   db "Debug OFF",0 
15b9			 
15b9			; debug editor 
15b9			 
15b9			.diagedit: 
15b9			 
15b9 21 a3 ef			ld hl, scratch 
15bc			;	ld bc, 250 
15bc			;	ldir 
15bc				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
15bc 3e 00			ld a, 0 
15be 77				ld (hl), a 
15bf 23				inc hl 
15c0 77				ld (hl), a 
15c1 23				inc hl 
15c2 77				ld (hl), a 
15c3			 
15c3 cd d2 0a		        call clear_display 
15c6 cd f5 0a			call update_display 
15c9 3e 01			ld a, 1 
15cb 32 c3 fb			ld (hardware_diag), a 
15ce			.diloop: 
15ce 3e 00			ld a, display_row_1 
15d0 0e 00			ld c, 0 
15d2 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
15d4 1e 28			ld e, 40 
15d6			 
15d6 21 a3 ef			ld hl, scratch	 
15d9 cd 33 0d			call input_str 
15dc			 
15dc 3e 14			ld a, display_row_2 
15de 11 a3 ef			ld de, scratch 
15e1 cd e5 0a			call str_at_display 
15e4 cd f5 0a			call update_display 
15e7			 
15e7 c3 ce 15			jp .diloop 
15ea			 
15ea			 
15ea			; pass word in hl 
15ea			; a has display location 
15ea			display_word_at: 
15ea f5				push af 
15eb e5				push hl 
15ec 7c				ld a,h 
15ed 21 a8 f2			ld hl, os_word_scratch 
15f0 cd 07 10			call hexout 
15f3 e1				pop hl 
15f4 7d				ld a,l 
15f5 21 aa f2			ld hl, os_word_scratch+2 
15f8 cd 07 10			call hexout 
15fb 21 ac f2			ld hl, os_word_scratch+4 
15fe 3e 00			ld a,0 
1600 77				ld (hl),a 
1601 11 a8 f2			ld de,os_word_scratch 
1604 f1				pop af 
1605 cd e5 0a				call str_at_display 
1608 c9				ret 
1609			 
1609			display_ptr_state: 
1609			 
1609				; to restore afterwards 
1609			 
1609 d5				push de 
160a c5				push bc 
160b e5				push hl 
160c f5				push af 
160d			 
160d				; for use in here 
160d			 
160d			;	push bc 
160d			;	push de 
160d			;	push hl 
160d			;	push af 
160d			 
160d cd d2 0a			call clear_display 
1610			 
1610 11 e3 17			ld de, .ptrstate 
1613 3e 00			ld a, display_row_1 
1615 cd e5 0a			call str_at_display 
1618			 
1618				; display debug step 
1618			 
1618			 
1618 11 bd fb			ld de, debug_mark 
161b 3e 12			ld a, display_row_1+display_cols-2 
161d cd e5 0a			call str_at_display 
1620			 
1620				; display a 
1620 11 ed 17			ld de, .ptrcliptr 
1623 3e 14			ld a, display_row_2 
1625 cd e5 0a			call str_at_display 
1628			 
1628 f1				pop af 
1629 2a ae f9			ld hl,(cli_ptr) 
162c 3e 1c			ld a, display_row_2+8 
162e cd ea 15			call display_word_at 
1631			 
1631			 
1631				; display hl 
1631			 
1631			 
1631 11 f5 17			ld de, .ptrclioptr 
1634 3e 1e			ld a, display_row_2+10 
1636 cd e5 0a			call str_at_display 
1639			; 
1639			;	pop hl 
1639 3e 21			ld a, display_row_2+13 
163b 2a ac f9			ld hl,(cli_origptr) 
163e cd ea 15			call display_word_at 
1641			; 
1641			;	 
1641			;	; display de 
1641			 
1641			;	ld de, .regstatede 
1641			;	ld a, display_row_3 
1641			;	call str_at_display 
1641			 
1641			;	pop de 
1641			;	ld h,d 
1641			;	ld l, e 
1641			;	ld a, display_row_3+3 
1641			;	call display_word_at 
1641			 
1641			 
1641				; display bc 
1641			 
1641			;	ld de, .regstatebc 
1641			;	ld a, display_row_3+10 
1641			;	call str_at_display 
1641			 
1641			;	pop bc 
1641			;	ld h,b 
1641			;	ld l, c 
1641			;	ld a, display_row_3+13 
1641			;	call display_word_at 
1641			 
1641			 
1641				; display dsp 
1641			 
1641			;	ld de, .regstatedsp 
1641			;	ld a, display_row_4 
1641			;	call str_at_display 
1641			 
1641				 
1641			;	ld hl,(cli_data_sp) 
1641			;	ld a, display_row_4+4 
1641			;	call display_word_at 
1641			 
1641				; display rsp 
1641			 
1641 11 24 18			ld de, .regstatersp 
1644 3e 46			ld a, display_row_4+10 
1646 cd e5 0a			call str_at_display 
1649			 
1649				 
1649 2a 94 f9			ld hl,(cli_ret_sp) 
164c 3e 4a			ld a, display_row_4+14 
164e cd ea 15			call display_word_at 
1651			 
1651 cd f5 0a			call update_display 
1654			 
1654 cd 52 0a			call delay1s 
1657 cd 52 0a			call delay1s 
165a cd 52 0a			call delay1s 
165d			 
165d			 
165d cd 6a 1b			call next_page_prompt 
1660			 
1660				; restore  
1660			 
1660 f1				pop af 
1661 e1				pop hl 
1662 c1				pop bc 
1663 d1				pop de 
1664 c9				ret 
1665			 
1665			break_point_state: 
1665 f5				push af 
1666			 
1666				; see if disabled 
1666			 
1666 3a 94 ef			ld a, (os_view_disable) 
1669 fe 2a			cp '*' 
166b 20 02			jr nz, .bpsgo 
166d f1				pop af 
166e c9				ret 
166f			 
166f			.bpsgo: 
166f f1				pop af 
1670 f5				push af 
1671 22 90 ef			ld (os_view_hl), hl 
1674 ed 53 8e ef		ld (os_view_de), de 
1678 ed 43 8c ef		ld (os_view_bc), bc 
167c e5				push hl 
167d 6f				ld l, a 
167e 26 00			ld h, 0 
1680 22 92 ef			ld (os_view_af),hl 
1683			 
1683 21 53 fb				ld hl, display_fb0 
1686 22 5e fa				ld (display_fb_active), hl 
1689 e1				pop hl	 
168a			 
168a 3e 31			ld a, '1' 
168c fe 2a		.bps1:  cp '*' 
168e 20 03			jr nz, .bps1b 
1690 32 94 ef			ld (os_view_disable),a 
1693 fe 31		.bps1b:  cp '1' 
1695 20 14			jr nz, .bps2 
1697			 
1697				; display reg 
1697			 
1697				 
1697			 
1697 3a 92 ef			ld a, (os_view_af) 
169a 2a 90 ef			ld hl, (os_view_hl) 
169d ed 5b 8e ef		ld de, (os_view_de) 
16a1 ed 4b 8c ef		ld bc, (os_view_bc) 
16a5 cd 3f 17			call display_reg_state 
16a8 c3 2b 17			jp .bpschk 
16ab			 
16ab fe 32		.bps2:  cp '2' 
16ad 20 08			jr nz, .bps3 
16af				 
16af				; display hl 
16af 2a 90 ef			ld hl, (os_view_hl) 
16b2 cd 29 18			call display_dump_at_hl 
16b5			 
16b5 18 74			jr .bpschk 
16b7			 
16b7 fe 33		.bps3:  cp '3' 
16b9 20 08			jr nz, .bps4 
16bb			 
16bb			        ; display de 
16bb 2a 8e ef			ld hl, (os_view_de) 
16be cd 29 18			call display_dump_at_hl 
16c1			 
16c1 18 68			jr .bpschk 
16c3 fe 34		.bps4:  cp '4' 
16c5 20 08			jr nz, .bps5 
16c7			 
16c7			        ; display bc 
16c7 2a 8c ef			ld hl, (os_view_bc) 
16ca cd 29 18			call display_dump_at_hl 
16cd			 
16cd 18 5c			jr .bpschk 
16cf fe 35		.bps5:  cp '5' 
16d1 20 08		        jr nz, .bps7 
16d3			 
16d3				; display cur ptr 
16d3 2a ae f9			ld hl, (cli_ptr) 
16d6 cd 29 18			call display_dump_at_hl 
16d9			 
16d9 18 50			jr .bpschk 
16db fe 36		.bps7:  cp '6' 
16dd 20 08			jr nz, .bps8b 
16df				 
16df				; display cur orig ptr 
16df 2a ac f9			ld hl, (cli_origptr) 
16e2 cd 29 18			call display_dump_at_hl 
16e5 18 44			jr .bpschk 
16e7 fe 37		.bps8b:  cp '7' 
16e9 20 08			jr nz, .bps9 
16eb				 
16eb				; display dsp 
16eb 2a 90 f9			ld hl, (cli_data_sp) 
16ee cd 29 18			call display_dump_at_hl 
16f1			 
16f1 18 38			jr .bpschk 
16f3 fe 39		.bps9:  cp '9' 
16f5 20 05			jr nz, .bps8c 
16f7				 
16f7				; display SP 
16f7			;	ld hl, sp 
16f7 cd 29 18			call display_dump_at_hl 
16fa			 
16fa 18 2f			jr .bpschk 
16fc fe 38		.bps8c:  cp '8' 
16fe 20 08			jr nz, .bps8d 
1700				 
1700				; display rsp 
1700 2a 94 f9			ld hl, (cli_ret_sp) 
1703 cd 29 18			call display_dump_at_hl 
1706			 
1706 18 23			jr .bpschk 
1708 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
170a 20 05			jr nz, .bps8 
170c cd 60 19			call monitor 
170f			 
170f 18 1a			jr .bpschk 
1711 fe 30		.bps8:  cp '0' 
1713 20 16			jr nz, .bpschk 
1715			 
1715 21 02 fb				ld hl, display_fb1 
1718 22 5e fa				ld (display_fb_active), hl 
171b cd f5 0a				call update_display 
171e			 
171e				;ld a, (os_view_af) 
171e 2a 90 ef			ld hl, (os_view_hl) 
1721 ed 5b 8e ef		ld de, (os_view_de) 
1725 ed 4b 8c ef		ld bc, (os_view_bc) 
1729 f1				pop af 
172a c9				ret 
172b			 
172b			.bpschk:   
172b cd 52 0a			call delay1s 
172e 3e 4f		ld a,display_row_4 + display_cols - 1 
1730 11 68 1b		        ld de, endprg 
1733 cd e5 0a			call str_at_display 
1736 cd f5 0a			call update_display 
1739 cd 44 66			call cin_wait 
173c			 
173c c3 8c 16			jp .bps1 
173f			 
173f			 
173f			display_reg_state: 
173f			 
173f				; to restore afterwards 
173f			 
173f d5				push de 
1740 c5				push bc 
1741 e5				push hl 
1742 f5				push af 
1743			 
1743				; for use in here 
1743			 
1743 c5				push bc 
1744 d5				push de 
1745 e5				push hl 
1746 f5				push af 
1747			 
1747 cd d2 0a			call clear_display 
174a			 
174a 11 ff 17			ld de, .regstate 
174d 3e 00			ld a, display_row_1 
174f cd e5 0a			call str_at_display 
1752			 
1752				; display debug step 
1752			 
1752			 
1752 11 bd fb			ld de, debug_mark 
1755 3e 11			ld a, display_row_1+display_cols-3 
1757 cd e5 0a			call str_at_display 
175a			 
175a				; display a 
175a 11 1b 18			ld de, .regstatea 
175d 3e 14			ld a, display_row_2 
175f cd e5 0a			call str_at_display 
1762			 
1762 e1				pop hl 
1763			;	ld h,0 
1763			;	ld l, a 
1763 3e 17			ld a, display_row_2+3 
1765 cd ea 15			call display_word_at 
1768			 
1768			 
1768				; display hl 
1768			 
1768			 
1768 11 0f 18			ld de, .regstatehl 
176b 3e 1e			ld a, display_row_2+10 
176d cd e5 0a			call str_at_display 
1770			 
1770 e1				pop hl 
1771 3e 21			ld a, display_row_2+13 
1773 cd ea 15			call display_word_at 
1776			 
1776				 
1776				; display de 
1776			 
1776 11 13 18			ld de, .regstatede 
1779 3e 28			ld a, display_row_3 
177b cd e5 0a			call str_at_display 
177e			 
177e e1				pop hl 
177f			;	ld h,d 
177f			;	ld l, e 
177f 3e 2b			ld a, display_row_3+3 
1781 cd ea 15			call display_word_at 
1784			 
1784			 
1784				; display bc 
1784			 
1784 11 17 18			ld de, .regstatebc 
1787 3e 32			ld a, display_row_3+10 
1789 cd e5 0a			call str_at_display 
178c			 
178c e1				pop hl 
178d			;	ld h,b 
178d			;	ld l, c 
178d 3e 35			ld a, display_row_3+13 
178f cd ea 15			call display_word_at 
1792			 
1792			 
1792				; display dsp 
1792			 
1792 11 1f 18			ld de, .regstatedsp 
1795 3e 3c			ld a, display_row_4 
1797 cd e5 0a			call str_at_display 
179a			 
179a				 
179a 2a 90 f9			ld hl,(cli_data_sp) 
179d 3e 40			ld a, display_row_4+4 
179f cd ea 15			call display_word_at 
17a2			 
17a2				; display rsp 
17a2			 
17a2 11 24 18			ld de, .regstatersp 
17a5 3e 46			ld a, display_row_4+10 
17a7 cd e5 0a			call str_at_display 
17aa			 
17aa				 
17aa 2a 94 f9			ld hl,(cli_ret_sp) 
17ad 3e 4a			ld a, display_row_4+14 
17af cd ea 15			call display_word_at 
17b2			 
17b2 cd f5 0a			call update_display 
17b5			 
17b5			;	call delay1s 
17b5			;	call delay1s 
17b5			;	call delay1s 
17b5			 
17b5			 
17b5			;	call next_page_prompt 
17b5			 
17b5				; restore  
17b5			 
17b5 f1				pop af 
17b6 e1				pop hl 
17b7 c1				pop bc 
17b8 d1				pop de 
17b9 c9				ret 
17ba			 
17ba .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
17ce .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
17e3 .. 00		.ptrstate:	db "Ptr State",0 
17ed .. 00		.ptrcliptr:     db "cli_ptr",0 
17f5 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
17ff .. 00		.regstate:	db "Reg State (1/0)",0 
180f .. 00		.regstatehl:	db "HL:",0 
1813 .. 00		.regstatede:	db "DE:",0 
1817 .. 00		.regstatebc:	db "BC:",0 
181b .. 00		.regstatea:	db "A :",0 
181f .. 00		.regstatedsp:	db "DSP:",0 
1824 .. 00		.regstatersp:	db "RSP:",0 
1829			 
1829			display_dump_at_hl: 
1829 e5				push hl 
182a d5				push de 
182b c5				push bc 
182c f5				push af 
182d			 
182d 22 c6 f2			ld (os_cur_ptr),hl	 
1830 cd d2 0a			call clear_display 
1833 cd 72 1a			call dumpcont 
1836			;	call delay1s 
1836			;	call next_page_prompt 
1836			 
1836			 
1836 f1				pop af 
1837 c1				pop bc 
1838 d1				pop de 
1839 e1				pop hl 
183a c9				ret 
183b			 
183b			;if ENABLE_BASIC 
183b			;	include "nascombasic.asm" 
183b			;	basic: 
183b			;	include "forth/FORTH.ASM" 
183b			;endif 
183b			 
183b			; eof 
183b			 
183b			 
# End of file firmware_diags.asm
183b			  
183b			  
183b			  
183b			  
183b			; eof  
183b			  
# End of file firmware.asm
183b			 
183b			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
183b			;if BASE_KEV  
183b			;baseram: equ 08000h 
183b			;endif 
183b			 
183b			;if BASE_SC114 
183b			;baseram:     equ    endofcode 
183b			;endif 
183b			 
183b			 
183b			; start system 
183b			 
183b			coldstart: 
183b				; set sp 
183b				; di/ei 
183b			 
183b f3				di 
183c 31 fd ff			ld sp, tos 
183f			;	ei 
183f			 
183f			 
183f				; disable breakpoint by default 
183f			 
183f 3e 2a			ld a,'*' 
1841 32 94 ef			ld (os_view_disable),a 
1844			 
1844				; init hardware 
1844			 
1844				; init keyboard and screen hardware 
1844			 
1844 cd 03 00			call hardware_init 
1847			 
1847			 
1847				; detect if any keys are held down to enable breakpoints at start up 
1847			 
1847 cd 55 66			call cin  
184a fe 00			cp 0 
184c 28 03			jr z, .nokeys 
184e			 
184e				;call hardware_diags 
184e cd 66 13			call config 
1851			 
1851			;	ld de, .bpen 
1851			;	ld a, display_row_4 
1851			;	call str_at_display 
1851			;	call update_display 
1851			; 
1851			;	ld a,0 
1851			;	ld (os_view_disable),a 
1851			; 
1851			;.bpwait: 
1851			;	call cin 
1851			;	cp 0 
1851			;	jr z, .bpwait 
1851			;	jr .nokeys 
1851			; 
1851			; 
1851			;.bpen:  db "Break points enabled!",0 
1851			 
1851			 
1851			 
1851			 
1851			 
1851			 
1851			.nokeys: 
1851			 
1851			 
1851				 
1851			 
1851			;jp  testkey 
1851			 
1851			;call storage_get_block_0 
1851			; 
1851			;ld hl, 0 
1851			;ld de, store_page 
1851			;call storage_read_block 
1851			 
1851				 
1851			;ld hl, 10 
1851			;ld de, store_page 
1851			;call storage_read_block 
1851			 
1851			 
1851			 
1851			 
1851			 
1851			;stop:	nop 
1851			;	jp stop 
1851			 
1851			 
1851			 
1851			main: 
1851 cd d2 0a			call clear_display 
1854 cd f5 0a			call update_display 
1857			 
1857			 
1857			 
1857			;	call testlcd 
1857			 
1857			 
1857			 
1857 cd 30 1f			call forth_init 
185a			 
185a			 
185a			warmstart: 
185a cd 06 1f			call forth_warmstart 
185d			 
185d				; run startup word load 
185d			        ; TODO prevent this running at warmstart after crash  
185d			 
185d				if STARTUP_ENABLE 
185d cd be 61				call forth_startup 
1860				endif 
1860			 
1860				; show free memory after boot 
1860 11 fa 18			ld de, freeram 
1863 3e 00			ld a, display_row_1 
1865 cd e5 0a			call str_at_display 
1868			 
1868			; Or use heap_size word???? 
1868 21 89 ef			ld hl, heap_end 
186b 11 0e 80			ld de, heap_start 
186e ed 52			sbc hl, de 
1870 e5				push hl 
1871 7c				ld a,h	         	 
1872 21 a8 f2			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1875 cd 07 10			call hexout 
1878 e1			   	pop hl 
1879			 
1879 7d				ld a,l 
187a 21 aa f2			ld hl, os_word_scratch+2 
187d cd 07 10			call hexout 
1880 21 ac f2			ld hl, os_word_scratch+4 
1883 3e 00			ld a, 0 
1885 77				ld (hl),a 
1886 11 a8 f2			ld de, os_word_scratch 
1889 3e 0d			ld a, display_row_1 + 13 
188b cd e5 0a			call str_at_display 
188e cd f5 0a			call update_display 
1891			 
1891			 
1891				;call demo 
1891			 
1891			 
1891				; init scratch input area for cli commands 
1891			 
1891 21 ca f2			ld hl, os_cli_cmd 
1894 3e 00			ld a,0 
1896 77				ld (hl),a 
1897 23				inc hl 
1898 77				ld (hl),a 
1899			 
1899 3e 00			ld a,0 
189b 32 c9 f3			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
189e			 
189e 32 c6 f2			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
18a1 32 c7 f2			ld (os_cur_ptr+1),a	 
18a4			 
18a4 32 a8 f2			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
18a7 32 a9 f2			ld (os_word_scratch+1),a	 
18aa				 
18aa			 
18aa				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18aa 21 ca f2			ld hl, os_cli_cmd 
18ad			 
18ad 3e 00			ld a, 0		 ; init cli input 
18af 77				ld (hl), a 
18b0 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18b2			cli: 
18b2				; show cli prompt 
18b2				;push af 
18b2				;ld a, 0 
18b2				;ld de, prompt 
18b2				;call str_at_display 
18b2			 
18b2				;call update_display 
18b2				;pop af 
18b2				;inc a 
18b2				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18b2 0e 00			ld c, 0 
18b4 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18b6 1e 28			ld e, 40 
18b8			 
18b8 21 ca f2			ld hl, os_cli_cmd 
18bb			 
18bb				STACKFRAME OFF $fefe $9f9f 
18bb				if DEBUG_STACK_IMB 
18bb					if OFF 
18bb						exx 
18bb						ld de, $fefe 
18bb						ld a, d 
18bb						ld hl, curframe 
18bb						call hexout 
18bb						ld a, e 
18bb						ld hl, curframe+2 
18bb						call hexout 
18bb						ld hl, $fefe 
18bb						push hl 
18bb						ld hl, $9f9f 
18bb						push hl 
18bb						exx 
18bb					endif 
18bb				endif 
18bb			endm 
# End of macro STACKFRAME
18bb			 
18bb cd 33 0d			call input_str 
18be			 
18be				STACKFRAMECHK OFF $fefe $9f9f 
18be				if DEBUG_STACK_IMB 
18be					if OFF 
18be						exx 
18be						ld hl, $9f9f 
18be						pop de   ; $9f9f 
18be						call cmp16 
18be						jr nz, .spnosame 
18be						ld hl, $fefe 
18be						pop de   ; $fefe 
18be						call cmp16 
18be						jr z, .spfrsame 
18be						.spnosame: call showsperror 
18be						.spfrsame: nop 
18be						exx 
18be					endif 
18be				endif 
18be			endm 
# End of macro STACKFRAMECHK
18be			 
18be				; copy input to last command 
18be			 
18be 21 ca f2			ld hl, os_cli_cmd 
18c1 11 c9 f3			ld de, os_last_cmd 
18c4 01 ff 00			ld bc, 255 
18c7 ed b0			ldir 
18c9			 
18c9				; wipe current buffer 
18c9			 
18c9			;	ld a, 0 
18c9			;	ld hl, os_cli_cmd 
18c9			;	ld de, os_cli_cmd+1 
18c9			;	ld bc, 254 
18c9			;	ldir 
18c9				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18c9			;	call strcpy 
18c9			;	ld a, 0 
18c9			;	ld (hl), a 
18c9			;	inc hl 
18c9			;	ld (hl), a 
18c9			;	inc hl 
18c9			;	ld (hl), a 
18c9			 
18c9				; switch frame buffer to program  
18c9			 
18c9 21 02 fb				ld hl, display_fb1 
18cc 22 5e fa				ld (display_fb_active), hl 
18cf			 
18cf			;	nop 
18cf				STACKFRAME ON $fbfe $8f9f 
18cf				if DEBUG_STACK_IMB 
18cf					if ON 
18cf						exx 
18cf						ld de, $fbfe 
18cf						ld a, d 
18cf						ld hl, curframe 
18cf						call hexout 
18cf						ld a, e 
18cf						ld hl, curframe+2 
18cf						call hexout 
18cf						ld hl, $fbfe 
18cf						push hl 
18cf						ld hl, $8f9f 
18cf						push hl 
18cf						exx 
18cf					endif 
18cf				endif 
18cf			endm 
# End of macro STACKFRAME
18cf				; first time into the parser so pass over the current scratch pad 
18cf 21 ca f2			ld hl,os_cli_cmd 
18d2				; tokenise the entered statement(s) in HL 
18d2 cd a9 1f			call forthparse 
18d5			        ; exec forth statements in top of return stack 
18d5 cd e9 1f			call forthexec 
18d8				;call forthexec_cleanup 
18d8			;	call parsenext 
18d8			 
18d8				STACKFRAMECHK ON $fbfe $8f9f 
18d8				if DEBUG_STACK_IMB 
18d8					if ON 
18d8						exx 
18d8						ld hl, $8f9f 
18d8						pop de   ; $8f9f 
18d8						call cmp16 
18d8						jr nz, .spnosame 
18d8						ld hl, $fbfe 
18d8						pop de   ; $fbfe 
18d8						call cmp16 
18d8						jr z, .spfrsame 
18d8						.spnosame: call showsperror 
18d8						.spfrsame: nop 
18d8						exx 
18d8					endif 
18d8				endif 
18d8			endm 
# End of macro STACKFRAMECHK
18d8				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
18d8			 
18d8 3e 3c			ld a, display_row_4 
18da 11 0c 19			ld de, endprog 
18dd			 
18dd cd f5 0a			call update_display		 
18e0			 
18e0 cd 6a 1b			call next_page_prompt 
18e3			 
18e3				; switch frame buffer to cli 
18e3			 
18e3 21 53 fb				ld hl, display_fb0 
18e6 22 5e fa				ld (display_fb_active), hl 
18e9			 
18e9			 
18e9 cd d2 0a		        call clear_display 
18ec cd f5 0a			call update_display		 
18ef			 
18ef 21 ca f2			ld hl, os_cli_cmd 
18f2			 
18f2 3e 00			ld a, 0		 ; init cli input 
18f4 77				ld (hl), a 
18f5			 
18f5				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
18f5			 
18f5				; now on last line 
18f5			 
18f5				; TODO scroll screen up 
18f5			 
18f5				; TODO instead just clear screen and place at top of screen 
18f5			 
18f5			;	ld a, 0 
18f5			;	ld (f_cursor_ptr),a 
18f5			 
18f5				;call clear_display 
18f5				;call update_display 
18f5			 
18f5				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18f5 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18f7 c3 b2 18			jp cli 
18fa			 
18fa .. 00		freeram: db "Free bytes: $",0 
1908 ..			asc: db "1A2F" 
190c .. 00		endprog: db "End prog...",0 
1918			 
1918			testenter2:   
1918 21 d5 ef			ld hl,scratch+50 
191b 22 c6 f2			ld (os_cur_ptr),hl 
191e c3 b2 18			jp cli 
1921			 
1921			testenter:  
1921			 
1921 21 08 19			ld hl,asc 
1924			;	ld a,(hl) 
1924			;	call nibble2val 
1924 cd 5d 10			call get_byte 
1927			 
1927			 
1927			;	ld a,(hl) 
1927			;	call atohex 
1927			 
1927			;	call fourehexhl 
1927 32 d5 ef			ld (scratch+50),a 
192a			 
192a			 
192a			 
192a 21 0a 19			ld hl,asc+2 
192d			;	ld a, (hl) 
192d			;	call nibble2val 
192d cd 5d 10			call get_byte 
1930			 
1930			;	call fourehexhl 
1930 32 d7 ef			ld (scratch+52),a 
1933				 
1933 21 d5 ef			ld hl,scratch+50 
1936 22 c6 f2			ld (os_cur_ptr),hl 
1939 c3 b2 18			jp cli 
193c			 
193c			enter:	 
193c 3a a7 ef			ld a,(scratch+4) 
193f fe 00			cp 0 
1941 28 0c			jr z, .entercont 
1943				; no, not a null term line so has an address to work out.... 
1943			 
1943 21 a5 ef			ld hl,scratch+2 
1946 cd bd 10			call get_word_hl 
1949			 
1949 22 c6 f2			ld (os_cur_ptr),hl	 
194c c3 b2 18			jp cli 
194f			 
194f			 
194f			.entercont:  
194f			 
194f 21 a5 ef			ld hl, scratch+2 
1952 cd 5d 10			call get_byte 
1955			 
1955 2a c6 f2		   	ld hl,(os_cur_ptr) 
1958 77					ld (hl),a 
1959 23					inc hl 
195a 22 c6 f2				ld (os_cur_ptr),hl 
195d				 
195d			; get byte  
195d			 
195d			 
195d c3 b2 18			jp cli 
1960			 
1960			 
1960			; basic monitor support 
1960			 
1960			monitor: 
1960				;  
1960 cd d2 0a			call clear_display 
1963 3e 00			ld a, 0 
1965 11 ad 19			ld de, .monprompt 
1968 cd e5 0a			call str_at_display 
196b cd f5 0a			call update_display 
196e			 
196e				; get a monitor command 
196e			 
196e 0e 00			ld c, 0     ; entry at top left 
1970 16 64			ld d, 100   ; max buffer size 
1972 1e 0f			ld e, 15    ; input scroll area 
1974 3e 00			ld a, 0     ; init string 
1976 21 a1 f1			ld hl, os_input 
1979 77				ld (hl), a 
197a 23				inc hl 
197b 77				ld (hl), a 
197c 21 a1 f1			ld hl, os_input 
197f 3e 01			ld a, 1     ; init string 
1981 cd 33 0d			call input_str 
1984			 
1984 cd d2 0a		        call clear_display 
1987 cd f5 0a			call update_display		 
198a			 
198a 3a a1 f1			ld a, (os_input) 
198d cd 5b 11			call toUpper 
1990 fe 48		        cp 'H' 
1992 28 6f		        jr z, .monhelp 
1994 fe 44			cp 'D'		; dump 
1996 ca 24 1a			jp z, .mondump	 
1999 fe 43			cp 'C'		; dump 
199b ca 3e 1a			jp z, .moncdump	 
199e fe 4d			cp 'M'		; dump 
19a0 ca af 19			jp z, .moneditstart 
19a3 fe 55			cp 'U'		; dump 
19a5 28 14			jr z, .monedit	 
19a7 fe 51			cp 'Q'		; dump 
19a9 c8				ret z	 
19aa			 
19aa			 
19aa				; TODO "S" to access symbol by name and not need the address 
19aa				; TODO "F" to find a string in memory 
19aa			 
19aa c3 60 19			jp monitor 
19ad			 
19ad .. 00		.monprompt: db ">", 0 
19af			 
19af			.moneditstart: 
19af				; get starting address 
19af			 
19af 21 a3 f1			ld hl,os_input+2 
19b2 cd bd 10			call get_word_hl 
19b5			 
19b5 22 c6 f2			ld (os_cur_ptr),hl	 
19b8			 
19b8 c3 60 19			jp monitor 
19bb			 
19bb			.monedit: 
19bb				; get byte to load 
19bb			 
19bb 21 a3 f1			ld hl,os_input+2 
19be cd 5d 10			call get_byte 
19c1			 
19c1				; get address to update 
19c1 2a c6 f2			ld hl, (os_cur_ptr) 
19c4			 
19c4				; update byte 
19c4			 
19c4 77				ld (hl), a 
19c5			 
19c5				; move to next address and save it 
19c5			 
19c5 23				inc hl 
19c6 22 c6 f2			ld (os_cur_ptr),hl	 
19c9			 
19c9 c3 60 19			jp monitor 
19cc			 
19cc			 
19cc .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
19e0 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
19fc .. 00		.monhelptext3:  db "Q-Quit",0 
1a03			        
1a03			.monhelp: 
1a03 3e 00			ld a, display_row_1 
1a05 11 cc 19		        ld de, .monhelptext1 
1a08			 
1a08 cd e5 0a			call str_at_display 
1a0b 3e 14			ld a, display_row_2 
1a0d 11 e0 19		        ld de, .monhelptext2 
1a10					 
1a10 cd e5 0a			call str_at_display 
1a13 3e 28			ld a, display_row_3 
1a15 11 fc 19		        ld de, .monhelptext3 
1a18					 
1a18 cd e5 0a			call str_at_display 
1a1b cd f5 0a			call update_display		 
1a1e			 
1a1e cd 6a 1b			call next_page_prompt 
1a21 c3 60 19			jp monitor 
1a24			 
1a24			.mondump:    
1a24 21 a3 f1			ld hl,os_input+2 
1a27 cd bd 10			call get_word_hl 
1a2a			 
1a2a 22 c6 f2			ld (os_cur_ptr),hl	 
1a2d cd 72 1a			call dumpcont 
1a30 3e 3c			ld a, display_row_4 
1a32 11 0c 19			ld de, endprog 
1a35			 
1a35 cd f5 0a			call update_display		 
1a38			 
1a38 cd 6a 1b			call next_page_prompt 
1a3b c3 60 19			jp monitor 
1a3e			.moncdump: 
1a3e cd 72 1a			call dumpcont 
1a41 3e 3c			ld a, display_row_4 
1a43 11 0c 19			ld de, endprog 
1a46			 
1a46 cd f5 0a			call update_display		 
1a49			 
1a49 cd 6a 1b			call next_page_prompt 
1a4c c3 60 19			jp monitor 
1a4f			 
1a4f			 
1a4f			; TODO symbol access  
1a4f			 
1a4f			.symbols:     ;; A list of symbols that can be called up  
1a4f 53 fb			dw display_fb0 
1a51 .. 00			db "fb0",0  
1a55 e8 f9		     	dw store_page 
1a57 .. 00			db "store_page",0 
1a62			 
1a62			 
1a62			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1a62			 
1a62 3a a4 ef			ld a,(scratch+1) 
1a65 fe 00			cp 0 
1a67 28 09			jr z, dumpcont 
1a69			 
1a69				; no, not a null term line so has an address to work out.... 
1a69			 
1a69 21 a5 ef			ld hl,scratch+2 
1a6c cd bd 10			call get_word_hl 
1a6f			 
1a6f 22 c6 f2			ld (os_cur_ptr),hl	 
1a72			 
1a72			 
1a72			 
1a72			dumpcont: 
1a72			 
1a72				; dump bytes at ptr 
1a72			 
1a72			 
1a72 3e 00			ld a, display_row_1 
1a74 2a 5e fa			ld hl, (display_fb_active) 
1a77 cd 06 0d			call addatohl 
1a7a cd a2 1a			call .dumpbyterow 
1a7d			 
1a7d 3e 14			ld a, display_row_2 
1a7f 2a 5e fa			ld hl, (display_fb_active) 
1a82 cd 06 0d			call addatohl 
1a85 cd a2 1a			call .dumpbyterow 
1a88			 
1a88			 
1a88 3e 28			ld a, display_row_3 
1a8a 2a 5e fa			ld hl, (display_fb_active) 
1a8d cd 06 0d			call addatohl 
1a90 cd a2 1a			call .dumpbyterow 
1a93			 
1a93 3e 3c			ld a, display_row_4 
1a95 2a 5e fa			ld hl, (display_fb_active) 
1a98 cd 06 0d			call addatohl 
1a9b cd a2 1a			call .dumpbyterow 
1a9e			 
1a9e cd f5 0a			call update_display 
1aa1			;		jp cli 
1aa1 c9				ret 
1aa2			 
1aa2			.dumpbyterow: 
1aa2			 
1aa2				;push af 
1aa2			 
1aa2 e5				push hl 
1aa3			 
1aa3				; calc where to poke the ascii 
1aa3			if display_cols == 20 
1aa3 3e 10			ld a, 16 
1aa5			else 
1aa5				ld a, 31 
1aa5			endif 
1aa5			 
1aa5 cd 06 0d			call addatohl 
1aa8 22 a8 f2			ld (os_word_scratch),hl  		; save pos for later 
1aab			 
1aab			 
1aab			; display decoding address 
1aab 2a c6 f2		   	ld hl,(os_cur_ptr) 
1aae			 
1aae 7c				ld a,h 
1aaf e1				pop hl 
1ab0 e5				push hl 
1ab1			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1ab1 cd 07 10			call hexout 
1ab4 2a c6 f2		   	ld hl,(os_cur_ptr) 
1ab7			 
1ab7 7d				ld a,l 
1ab8 e1				pop hl 
1ab9 23				inc hl 
1aba 23				inc hl 
1abb e5				push hl 
1abc			;	ld hl, os_word_scratch+2 
1abc cd 07 10			call hexout 
1abf e1				pop hl 
1ac0 23				inc hl 
1ac1 23				inc hl 
1ac2				;ld hl, os_word_scratch+4 
1ac2 3e 3a			ld a, ':' 
1ac4 77				ld (hl),a 
1ac5 23				inc hl 
1ac6				;ld a, 0 
1ac6				;ld (hl),a 
1ac6				;ld de, os_word_scratch 
1ac6				;pop af 
1ac6				;push af 
1ac6			;		ld a, display_row_2 
1ac6			;		call str_at_display 
1ac6			;		call update_display 
1ac6			 
1ac6			 
1ac6			;pop af 
1ac6			;	add 5 
1ac6			 
1ac6			if display_cols == 20 
1ac6 06 04			ld b, 4 
1ac8			else 
1ac8				ld b, 8 
1ac8			endif	 
1ac8			 
1ac8			.dumpbyte: 
1ac8 c5				push bc 
1ac9 e5				push hl 
1aca			 
1aca			 
1aca 2a c6 f2		   	ld hl,(os_cur_ptr) 
1acd 7e					ld a,(hl) 
1ace			 
1ace					; poke the ascii to display 
1ace 2a a8 f2				ld hl,(os_word_scratch) 
1ad1 77					ld (hl),a 
1ad2 23					inc hl 
1ad3 22 a8 f2				ld (os_word_scratch),hl 
1ad6			 
1ad6					 
1ad6			 
1ad6			 
1ad6 e1					pop hl 
1ad7 e5					push hl 
1ad8			 
1ad8 cd 07 10				call hexout 
1adb			 
1adb					 
1adb 2a c6 f2		   	ld hl,(os_cur_ptr) 
1ade 23				inc hl 
1adf 22 c6 f2		   	ld (os_cur_ptr),hl 
1ae2			 
1ae2 e1					pop hl 
1ae3 23					inc hl 
1ae4 23					inc hl 
1ae5 23					inc hl 
1ae6			 
1ae6			 
1ae6			 
1ae6					;ld a,0 
1ae6					;ld (os_word_scratch+2),a 
1ae6					;pop af 
1ae6					;push af 
1ae6			 
1ae6					;ld de, os_word_scratch 
1ae6					;call str_at_display 
1ae6			;		call update_display 
1ae6			;		pop af 
1ae6 c1					pop bc 
1ae7 c6 03				add 3 
1ae9 10 dd			djnz .dumpbyte 
1aeb			 
1aeb				 
1aeb			 
1aeb c9				ret 
1aec			 
1aec			jump:	 
1aec			 
1aec 21 a5 ef			ld hl,scratch+2 
1aef cd bd 10			call get_word_hl 
1af2				;ld hl,(scratch+2) 
1af2				;call fourehexhl 
1af2			 
1af2 22 c6 f2			ld (os_cur_ptr),hl	 
1af5			 
1af5 e9				jp (hl) 
1af6			 
1af6			 
1af6			 
1af6			; TODO implement a basic monitor mode to start with 
1af6			 
1af6			 
1af6			 
1af6			 
1af6			 
1af6			 
1af6			 
1af6			 
1af6			 
1af6			; testing and demo code during development 
1af6			 
1af6			 
1af6 .. 00		str1: db "Enter some text...",0 
1b09 .. 00		clear: db "                    ",0 
1b1e			 
1b1e			demo: 
1b1e			 
1b1e			 
1b1e			 
1b1e			;	call update_display 
1b1e			 
1b1e				; init scratch input area for testing 
1b1e 21 a3 ef			ld hl, scratch	 
1b21 3e 00			ld a,0 
1b23 77				ld (hl),a 
1b24			 
1b24			 
1b24 3e 14		            LD   A, display_row_2 
1b26			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b26 11 f6 1a		            LD   DE, str1 
1b29 cd e5 0a			call str_at_display 
1b2c			 
1b2c			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b2c			cloop:	 
1b2c 3e 28		            LD   A, display_row_3 
1b2e			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b2e 11 09 1b		            LD   DE, clear 
1b31			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1b31 cd e5 0a				call str_at_display 
1b34 3e 3c			ld a, display_row_4 
1b36 11 66 1b			ld de, prompt 
1b39			 
1b39 cd e5 0a				call str_at_display 
1b3c cd f5 0a			call update_display 
1b3f			 
1b3f 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1b41 16 0a			ld d, 10 
1b43 21 a3 ef			ld hl, scratch	 
1b46 cd 33 0d			call input_str 
1b49			 
1b49			;	call clear_display 
1b49			;'	call update_display 
1b49			 
1b49 3e 00		            LD   A, display_row_1 
1b4b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b4b 11 09 1b		            LD   DE, clear 
1b4e cd e5 0a				call str_at_display 
1b51			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b51 3e 00		            LD   A, display_row_1 
1b53			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b53 11 a3 ef		            LD   DE, scratch 
1b56			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b56 cd e5 0a				call str_at_display 
1b59 cd f5 0a			call update_display 
1b5c			 
1b5c 3e 00				ld a,0 
1b5e 21 a3 ef			ld hl, scratch 
1b61 77				ld (hl),a 
1b62			 
1b62 00				nop 
1b63 c3 2c 1b			jp cloop 
1b66			 
1b66			 
1b66			 
1b66			; OS Prompt 
1b66			 
1b66 .. 00		prompt: db ">",0 
1b68 .. 00		endprg: db "?",0 
1b6a			 
1b6a			 
1b6a			; handy next page prompt 
1b6a			next_page_prompt: 
1b6a e5				push hl 
1b6b d5				push de 
1b6c f5				push af 
1b6d c5				push bc 
1b6e			 
1b6e 3e 4f			ld a,display_row_4 + display_cols - 1 
1b70 11 68 1b		        ld de, endprg 
1b73 cd e5 0a			call str_at_display 
1b76 cd f5 0a			call update_display 
1b79 cd 44 66			call cin_wait 
1b7c c1				pop bc 
1b7d f1				pop af 
1b7e d1				pop de 
1b7f e1				pop hl 
1b80			 
1b80			 
1b80 c9				ret 
1b81			 
1b81			 
1b81			; forth parser 
1b81			 
1b81			; My forth kernel 
1b81			include "forth_kernel.asm" 
1b81			; 
1b81			; kernel to the forth OS 
1b81			 
1b81			DS_TYPE_STR: equ 1     ; string type 
1b81			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1b81			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1b81			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1b81			 
1b81			FORTH_PARSEV1: equ 0 
1b81			FORTH_PARSEV2: equ 0 
1b81			FORTH_PARSEV3: equ 0 
1b81			FORTH_PARSEV4: equ 0 
1b81			FORTH_PARSEV5: equ 1 
1b81			 
1b81			;if FORTH_PARSEV5 
1b81			;	FORTH_END_BUFFER: equ 0 
1b81			;else 
1b81			FORTH_END_BUFFER: equ 127 
1b81			;endif 
1b81			 
1b81			FORTH_TRUE: equ 1 
1b81			FORTH_FALSE: equ 0 
1b81			 
1b81			if FORTH_PARSEV4 
1b81			include "forth_stackops.asm" 
1b81			endif 
1b81			 
1b81			if FORTH_PARSEV5 
1b81			include "forth_stackopsv5.asm" 
1b81			 
1b81			; Stack operations for v5 parser on wards 
1b81			; * DATA stack 
1b81			; * LOOP stack 
1b81			; * RETURN stack 
1b81			 
1b81			 
1b81			 
1b81			FORTH_CHK_DSP_UNDER: macro 
1b81				push hl 
1b81				push de 
1b81				ld hl,(cli_data_sp) 
1b81				ld de, cli_data_stack 
1b81				call cmp16 
1b81				jp c, fault_dsp_under 
1b81				pop de 
1b81				pop hl 
1b81				endm 
1b81			 
1b81			 
1b81			FORTH_CHK_RSP_UNDER: macro 
1b81				push hl 
1b81				push de 
1b81				ld hl,(cli_ret_sp) 
1b81				ld de, cli_ret_stack 
1b81				call cmp16 
1b81				jp c, fault_rsp_under 
1b81				pop de 
1b81				pop hl 
1b81				endm 
1b81			 
1b81			FORTH_CHK_LOOP_UNDER: macro 
1b81				push hl 
1b81				push de 
1b81				ld hl,(cli_loop_sp) 
1b81				ld de, cli_loop_stack 
1b81				call cmp16 
1b81				jp c, fault_loop_under 
1b81				pop de 
1b81				pop hl 
1b81				endm 
1b81			 
1b81			FORTH_ERR_TOS_NOTSTR: macro 
1b81				; TOSO might need more for checks when used 
1b81				push af 
1b81				ld a,(hl) 
1b81				cp DS_TYPE_STR 
1b81				jp nz, type_faultn   
1b81				pop af 
1b81				endm 
1b81			 
1b81			FORTH_ERR_TOS_NOTNUM: macro 
1b81				push af 
1b81				ld a,(hl) 
1b81				cp DS_TYPE_INUM 
1b81				jp nz, type_faultn   
1b81				pop af 
1b81				endm 
1b81			 
1b81			 
1b81			; increase data stack pointer and save hl to it 
1b81				 
1b81			FORTH_DSP_NEXT: macro 
1b81				call macro_forth_dsp_next 
1b81				endm 
1b81			 
1b81			 
1b81			macro_forth_dsp_next: 
1b81				if DEBUG_FORTH_STACK_GUARD 
1b81 cd 88 62				call check_stacks 
1b84				endif 
1b84 e5				push hl 
1b85 d5				push de 
1b86 eb				ex de,hl 
1b87 2a 90 f9			ld hl,(cli_data_sp) 
1b8a 23				inc hl 
1b8b 23				inc hl 
1b8c			 
1b8c			; PARSEV5 
1b8c 23				inc hl 
1b8d 22 90 f9			ld (cli_data_sp),hl 
1b90 73				ld (hl), e 
1b91 23				inc hl 
1b92 72				ld (hl), d 
1b93 d1				pop de 
1b94 e1				pop hl 
1b95				if DEBUG_FORTH_STACK_GUARD 
1b95 cd 88 62				call check_stacks 
1b98				endif 
1b98 c9				ret 
1b99			 
1b99			 
1b99			; increase ret stack pointer and save hl to it 
1b99				 
1b99			FORTH_RSP_NEXT: macro 
1b99				call macro_forth_rsp_next 
1b99				endm 
1b99			 
1b99			macro_forth_rsp_next: 
1b99				if DEBUG_FORTH_STACK_GUARD 
1b99 cd 88 62				call check_stacks 
1b9c				endif 
1b9c e5				push hl 
1b9d d5				push de 
1b9e eb				ex de,hl 
1b9f 2a 94 f9			ld hl,(cli_ret_sp) 
1ba2 23				inc hl 
1ba3 23				inc hl 
1ba4 22 94 f9			ld (cli_ret_sp),hl 
1ba7 73				ld (hl), e 
1ba8 23				inc hl 
1ba9 72				ld (hl), d 
1baa d1				pop de 
1bab e1				pop hl 
1bac				if DEBUG_FORTH_STACK_GUARD 
1bac cd 88 62				call check_stacks 
1baf				endif 
1baf c9				ret 
1bb0			 
1bb0			; get current ret stack pointer and save to hl  
1bb0				 
1bb0			FORTH_RSP_TOS: macro 
1bb0				call macro_forth_rsp_tos 
1bb0				endm 
1bb0			 
1bb0			macro_forth_rsp_tos: 
1bb0				;push de 
1bb0 2a 94 f9			ld hl,(cli_ret_sp) 
1bb3 cd eb 1b			call loadhlptrtohl 
1bb6				;ld e, (hl) 
1bb6				;inc hl 
1bb6				;ld d, (hl) 
1bb6				;ex de, hl 
1bb6					if DEBUG_FORTH_WORDS 
1bb6			;			DMARK "RST" 
1bb6						CALLMONITOR 
1bb6 cd 65 16			call break_point_state  
1bb9				endm  
# End of macro CALLMONITOR
1bb9					endif 
1bb9				;pop de 
1bb9 c9				ret 
1bba			 
1bba			; pop ret stack pointer 
1bba				 
1bba			FORTH_RSP_POP: macro 
1bba				call macro_forth_rsp_pop 
1bba				endm 
1bba			 
1bba			 
1bba			macro_forth_rsp_pop: 
1bba				if DEBUG_FORTH_STACK_GUARD 
1bba			;		DMARK "RPP" 
1bba cd 88 62				call check_stacks 
1bbd					FORTH_CHK_RSP_UNDER 
1bbd e5				push hl 
1bbe d5				push de 
1bbf 2a 94 f9			ld hl,(cli_ret_sp) 
1bc2 11 0e f9			ld de, cli_ret_stack 
1bc5 cd 24 0d			call cmp16 
1bc8 da 9c 63			jp c, fault_rsp_under 
1bcb d1				pop de 
1bcc e1				pop hl 
1bcd				endm 
# End of macro FORTH_CHK_RSP_UNDER
1bcd				endif 
1bcd e5				push hl 
1bce 2a 94 f9			ld hl,(cli_ret_sp) 
1bd1			 
1bd1			 
1bd1				if FORTH_ENABLE_FREE 
1bd1			 
1bd1					; get pointer 
1bd1			 
1bd1					push de 
1bd1					push hl 
1bd1			 
1bd1					ld e, (hl) 
1bd1					inc hl 
1bd1					ld d, (hl) 
1bd1			 
1bd1					ex de, hl 
1bd1					call free 
1bd1			 
1bd1					pop hl 
1bd1					pop de 
1bd1			 
1bd1			 
1bd1				endif 
1bd1			 
1bd1			 
1bd1 2b				dec hl 
1bd2 2b				dec hl 
1bd3 22 94 f9			ld (cli_ret_sp), hl 
1bd6				; do stack underflow checks 
1bd6 e1				pop hl 
1bd7				if DEBUG_FORTH_STACK_GUARD 
1bd7 cd 88 62				call check_stacks 
1bda					FORTH_CHK_RSP_UNDER 
1bda e5				push hl 
1bdb d5				push de 
1bdc 2a 94 f9			ld hl,(cli_ret_sp) 
1bdf 11 0e f9			ld de, cli_ret_stack 
1be2 cd 24 0d			call cmp16 
1be5 da 9c 63			jp c, fault_rsp_under 
1be8 d1				pop de 
1be9 e1				pop hl 
1bea				endm 
# End of macro FORTH_CHK_RSP_UNDER
1bea				endif 
1bea c9				ret 
1beb			 
1beb			 
1beb			 
1beb			; routine to load word pointed to by hl into hl 
1beb			 
1beb			loadhlptrtohl: 
1beb			 
1beb d5				push de 
1bec 5e				ld e, (hl) 
1bed 23				inc hl 
1bee 56				ld d, (hl) 
1bef eb				ex de, hl 
1bf0 d1				pop de 
1bf1			 
1bf1 c9				ret 
1bf2			 
1bf2			 
1bf2			 
1bf2			 
1bf2			 
1bf2			; push a number held in HL onto the data stack 
1bf2			; entry point for pushing a value when already in hl used in function above 
1bf2			 
1bf2			forth_push_numhl: 
1bf2			 
1bf2 e5				push hl    ; save value to push 
1bf3			 
1bf3			if DEBUG_FORTH_PUSH 
1bf3				; see if disabled 
1bf3			 
1bf3			 
1bf3 f5				push af 
1bf4 3a 94 ef			ld a, (os_view_disable) 
1bf7 fe 2a			cp '*' 
1bf9 28 34			jr z, .pskip2 
1bfb e5				push hl 
1bfc e5			push hl 
1bfd cd d2 0a			call clear_display 
1c00 e1			pop hl 
1c01 7c				ld a,h 
1c02 21 a8 f2			ld hl, os_word_scratch 
1c05 cd 07 10			call hexout 
1c08 e1				pop hl 
1c09 7d				ld a,l 
1c0a 21 aa f2			ld hl, os_word_scratch+2 
1c0d cd 07 10			call hexout 
1c10			 
1c10 21 ac f2			ld hl, os_word_scratch+4 
1c13 3e 00			ld a,0 
1c15 77				ld (hl),a 
1c16 11 a8 f2			ld de,os_word_scratch 
1c19 3e 14				ld a, display_row_2 
1c1b cd e5 0a				call str_at_display 
1c1e 11 96 51			ld de, .push_num 
1c21 3e 00			ld a, display_row_1 
1c23			 
1c23 cd e5 0a				call str_at_display 
1c26			 
1c26			 
1c26 cd f5 0a			call update_display 
1c29 cd 52 0a			call delay1s 
1c2c cd 52 0a			call delay1s 
1c2f			.pskip2:  
1c2f			 
1c2f f1				pop af 
1c30			endif	 
1c30			 
1c30			 
1c30				FORTH_DSP_NEXT 
1c30 cd 81 1b			call macro_forth_dsp_next 
1c33				endm 
# End of macro FORTH_DSP_NEXT
1c33			 
1c33 2a 90 f9			ld hl, (cli_data_sp) 
1c36			 
1c36				; save item type 
1c36 3e 02			ld a,  DS_TYPE_INUM 
1c38 77				ld (hl), a 
1c39 23				inc hl 
1c3a			 
1c3a				; get word off stack 
1c3a d1				pop de 
1c3b 7b				ld a,e 
1c3c 77				ld (hl), a 
1c3d 23				inc hl 
1c3e 7a				ld a,d 
1c3f 77				ld (hl), a 
1c40			 
1c40			if DEBUG_FORTH_PUSH 
1c40 2b				dec hl 
1c41 2b				dec hl 
1c42 2b				dec hl 
1c43						DMARK "PH5" 
1c43 f5				push af  
1c44 3a 58 1c			ld a, (.dmark)  
1c47 32 bd fb			ld (debug_mark),a  
1c4a 3a 59 1c			ld a, (.dmark+1)  
1c4d 32 be fb			ld (debug_mark+1),a  
1c50 3a 5a 1c			ld a, (.dmark+2)  
1c53 32 bf fb			ld (debug_mark+2),a  
1c56 18 03			jr .pastdmark  
1c58 ..			.dmark: db "PH5"  
1c5b f1			.pastdmark: pop af  
1c5c			endm  
# End of macro DMARK
1c5c				CALLMONITOR 
1c5c cd 65 16			call break_point_state  
1c5f				endm  
# End of macro CALLMONITOR
1c5f			endif	 
1c5f			 
1c5f c9				ret 
1c60			 
1c60			 
1c60			; Push a string to stack pointed to by hl 
1c60			 
1c60			forth_push_str: 
1c60			 
1c60			if DEBUG_FORTH_PUSH 
1c60						DMARK "PSQ" 
1c60 f5				push af  
1c61 3a 75 1c			ld a, (.dmark)  
1c64 32 bd fb			ld (debug_mark),a  
1c67 3a 76 1c			ld a, (.dmark+1)  
1c6a 32 be fb			ld (debug_mark+1),a  
1c6d 3a 77 1c			ld a, (.dmark+2)  
1c70 32 bf fb			ld (debug_mark+2),a  
1c73 18 03			jr .pastdmark  
1c75 ..			.dmark: db "PSQ"  
1c78 f1			.pastdmark: pop af  
1c79			endm  
# End of macro DMARK
1c79				CALLMONITOR 
1c79 cd 65 16			call break_point_state  
1c7c				endm  
# End of macro CALLMONITOR
1c7c			endif	 
1c7c			    
1c7c e5				push hl 
1c7d e5				push hl 
1c7e			 
1c7e			;	ld a, 0   ; find end of string 
1c7e cd 64 11			call strlenz 
1c81			if DEBUG_FORTH_PUSH 
1c81						DMARK "PQ2" 
1c81 f5				push af  
1c82 3a 96 1c			ld a, (.dmark)  
1c85 32 bd fb			ld (debug_mark),a  
1c88 3a 97 1c			ld a, (.dmark+1)  
1c8b 32 be fb			ld (debug_mark+1),a  
1c8e 3a 98 1c			ld a, (.dmark+2)  
1c91 32 bf fb			ld (debug_mark+2),a  
1c94 18 03			jr .pastdmark  
1c96 ..			.dmark: db "PQ2"  
1c99 f1			.pastdmark: pop af  
1c9a			endm  
# End of macro DMARK
1c9a				CALLMONITOR 
1c9a cd 65 16			call break_point_state  
1c9d				endm  
# End of macro CALLMONITOR
1c9d			endif	 
1c9d eb				ex de, hl 
1c9e e1				pop hl   ; get ptr to start of string 
1c9f			if DEBUG_FORTH_PUSH 
1c9f						DMARK "PQ3" 
1c9f f5				push af  
1ca0 3a b4 1c			ld a, (.dmark)  
1ca3 32 bd fb			ld (debug_mark),a  
1ca6 3a b5 1c			ld a, (.dmark+1)  
1ca9 32 be fb			ld (debug_mark+1),a  
1cac 3a b6 1c			ld a, (.dmark+2)  
1caf 32 bf fb			ld (debug_mark+2),a  
1cb2 18 03			jr .pastdmark  
1cb4 ..			.dmark: db "PQ3"  
1cb7 f1			.pastdmark: pop af  
1cb8			endm  
# End of macro DMARK
1cb8				CALLMONITOR 
1cb8 cd 65 16			call break_point_state  
1cbb				endm  
# End of macro CALLMONITOR
1cbb			endif	 
1cbb 19				add hl,de 
1cbc			if DEBUG_FORTH_PUSH 
1cbc						DMARK "PQE" 
1cbc f5				push af  
1cbd 3a d1 1c			ld a, (.dmark)  
1cc0 32 bd fb			ld (debug_mark),a  
1cc3 3a d2 1c			ld a, (.dmark+1)  
1cc6 32 be fb			ld (debug_mark+1),a  
1cc9 3a d3 1c			ld a, (.dmark+2)  
1ccc 32 bf fb			ld (debug_mark+2),a  
1ccf 18 03			jr .pastdmark  
1cd1 ..			.dmark: db "PQE"  
1cd4 f1			.pastdmark: pop af  
1cd5			endm  
# End of macro DMARK
1cd5				CALLMONITOR 
1cd5 cd 65 16			call break_point_state  
1cd8				endm  
# End of macro CALLMONITOR
1cd8			endif	 
1cd8			 
1cd8 2b				dec hl    ; see if there is an optional trailing double quote 
1cd9 7e				ld a,(hl) 
1cda fe 22			cp '"' 
1cdc 20 03			jr nz, .strnoq 
1cde 3e 00			ld a, 0      ; get rid of double quote 
1ce0 77				ld (hl), a 
1ce1 23			.strnoq: inc hl 
1ce2			 
1ce2 3e 00			ld a, 0 
1ce4 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1ce5			 
1ce5 13				inc de ; add one for the type string 
1ce6 13				inc de ; add one for null term??? 
1ce7			 
1ce7				; tos is get string pointer again 
1ce7				; de contains space to allocate 
1ce7				 
1ce7 d5				push de 
1ce8			 
1ce8 eb				ex de, hl 
1ce9			 
1ce9				;push af 
1ce9			 
1ce9			if DEBUG_FORTH_PUSH 
1ce9						DMARK "PHm" 
1ce9 f5				push af  
1cea 3a fe 1c			ld a, (.dmark)  
1ced 32 bd fb			ld (debug_mark),a  
1cf0 3a ff 1c			ld a, (.dmark+1)  
1cf3 32 be fb			ld (debug_mark+1),a  
1cf6 3a 00 1d			ld a, (.dmark+2)  
1cf9 32 bf fb			ld (debug_mark+2),a  
1cfc 18 03			jr .pastdmark  
1cfe ..			.dmark: db "PHm"  
1d01 f1			.pastdmark: pop af  
1d02			endm  
# End of macro DMARK
1d02				CALLMONITOR 
1d02 cd 65 16			call break_point_state  
1d05				endm  
# End of macro CALLMONITOR
1d05			endif	 
1d05 cd cd 11			call malloc	; on ret hl now contains allocated memory 
1d08				if DEBUG_FORTH_MALLOC_GUARD 
1d08 cc ee 51				call z,malloc_error 
1d0b				endif 
1d0b			 
1d0b				 
1d0b c1				pop bc    ; get length 
1d0c d1				pop de   ;  get string start    
1d0d			 
1d0d				; hl has destination from malloc 
1d0d			 
1d0d eb				ex de, hl    ; prep for ldir 
1d0e			 
1d0e d5				push de   ; save malloc area for DSP later 
1d0f				;push hl   ; save malloc area for DSP later 
1d0f			 
1d0f			if DEBUG_FORTH_PUSH 
1d0f						DMARK "PHc" 
1d0f f5				push af  
1d10 3a 24 1d			ld a, (.dmark)  
1d13 32 bd fb			ld (debug_mark),a  
1d16 3a 25 1d			ld a, (.dmark+1)  
1d19 32 be fb			ld (debug_mark+1),a  
1d1c 3a 26 1d			ld a, (.dmark+2)  
1d1f 32 bf fb			ld (debug_mark+2),a  
1d22 18 03			jr .pastdmark  
1d24 ..			.dmark: db "PHc"  
1d27 f1			.pastdmark: pop af  
1d28			endm  
# End of macro DMARK
1d28				CALLMONITOR 
1d28 cd 65 16			call break_point_state  
1d2b				endm  
# End of macro CALLMONITOR
1d2b			endif	 
1d2b			 
1d2b			 
1d2b ed b0			ldir 
1d2d			 
1d2d			 
1d2d				; push malloc to data stack     macro?????  
1d2d			 
1d2d				FORTH_DSP_NEXT 
1d2d cd 81 1b			call macro_forth_dsp_next 
1d30				endm 
# End of macro FORTH_DSP_NEXT
1d30			 
1d30				; save value and type 
1d30			 
1d30 2a 90 f9			ld hl, (cli_data_sp) 
1d33			 
1d33				; save item type 
1d33 3e 01			ld a,  DS_TYPE_STR 
1d35 77				ld (hl), a 
1d36 23				inc hl 
1d37			 
1d37				; get malloc word off stack 
1d37 d1				pop de 
1d38 73				ld (hl), e 
1d39 23				inc hl 
1d3a 72				ld (hl), d 
1d3b			 
1d3b			 
1d3b			 
1d3b			if DEBUG_FORTH_PUSH 
1d3b 2a 90 f9			ld hl, (cli_data_sp) 
1d3e						DMARK "PHS" 
1d3e f5				push af  
1d3f 3a 53 1d			ld a, (.dmark)  
1d42 32 bd fb			ld (debug_mark),a  
1d45 3a 54 1d			ld a, (.dmark+1)  
1d48 32 be fb			ld (debug_mark+1),a  
1d4b 3a 55 1d			ld a, (.dmark+2)  
1d4e 32 bf fb			ld (debug_mark+2),a  
1d51 18 03			jr .pastdmark  
1d53 ..			.dmark: db "PHS"  
1d56 f1			.pastdmark: pop af  
1d57			endm  
# End of macro DMARK
1d57				CALLMONITOR 
1d57 cd 65 16			call break_point_state  
1d5a				endm  
# End of macro CALLMONITOR
1d5a			;	ex de,hl 
1d5a			endif	 
1d5a				; in case of spaces, skip the ptr past the copied string 
1d5a				;pop af 
1d5a				;ld (cli_origptr),hl 
1d5a			 
1d5a c9				ret 
1d5b			 
1d5b			 
1d5b			 
1d5b			; TODO ascii push input onto stack given hl to start of input 
1d5b			 
1d5b			; identify type 
1d5b			; if starts with a " then a string 
1d5b			; otherwise it is a number 
1d5b			;  
1d5b			; if a string 
1d5b			;     scan for ending " to get length of string to malloc for + 1 
1d5b			;     malloc 
1d5b			;     put pointer to string on stack first byte flags as string 
1d5b			; 
1d5b			; else a number 
1d5b			;    look for number format identifier 
1d5b			;    $xx hex 
1d5b			;    %xxxxx bin 
1d5b			;    xxxxx decimal 
1d5b			;    convert number to 16bit word.  
1d5b			;    malloc word + 1 with flag to identiy as num 
1d5b			;    put pointer to number on stack 
1d5b			;   
1d5b			;  
1d5b			  
1d5b			forth_apush: 
1d5b				; kernel push 
1d5b			 
1d5b			if DEBUG_FORTH_PUSH 
1d5b						DMARK "PSH" 
1d5b f5				push af  
1d5c 3a 70 1d			ld a, (.dmark)  
1d5f 32 bd fb			ld (debug_mark),a  
1d62 3a 71 1d			ld a, (.dmark+1)  
1d65 32 be fb			ld (debug_mark+1),a  
1d68 3a 72 1d			ld a, (.dmark+2)  
1d6b 32 bf fb			ld (debug_mark+2),a  
1d6e 18 03			jr .pastdmark  
1d70 ..			.dmark: db "PSH"  
1d73 f1			.pastdmark: pop af  
1d74			endm  
# End of macro DMARK
1d74				CALLMONITOR 
1d74 cd 65 16			call break_point_state  
1d77				endm  
# End of macro CALLMONITOR
1d77			endif	 
1d77				; identify input type 
1d77			 
1d77 7e				ld a,(hl) 
1d78 fe 22			cp '"' 
1d7a 28 0a			jr z, .fapstr 
1d7c fe 24			cp '$' 
1d7e ca a6 1d			jp z, .faphex 
1d81 fe 25			cp '%' 
1d83 ca 8e 1d			jp z, .fapbin 
1d86			;	cp 'b' 
1d86			;	jp z, .fabin 
1d86				; else decimal 
1d86			 
1d86				; TODO do decimal conversion 
1d86				; decimal is stored as a 16bit word 
1d86			 
1d86				; by default everything is a string if type is not detected 
1d86			.fapstr: ; 
1d86 fe 22			cp '"' 
1d88 20 01			jr nz, .strnoqu 
1d8a 23				inc hl 
1d8b			.strnoqu: 
1d8b c3 60 1c			jp forth_push_str 
1d8e			 
1d8e			 
1d8e			 
1d8e			.fapbin:    ; push a binary string.  
1d8e 11 00 00			ld de, 0   ; hold a 16bit value 
1d91			 
1d91 23			.fapbinshift:	inc hl  
1d92 7e				ld a,(hl) 
1d93 fe 00			cp 0     ; done scanning  
1d95 28 0b			jr z, .fapbdone  	; got it in HL so push  
1d97			 
1d97				; left shift de 
1d97 eb				ex de, hl	 
1d98 29				add hl, hl 
1d99			 
1d99				; is 1 
1d99 fe 31			cp '1' 
1d9b 20 02			jr nz, .binzero 
1d9d cb 4d			bit 1, l 
1d9f			.binzero: 
1d9f eb				ex de, hl	 ; save current de 
1da0 18 ef			jr .fapbinshift 
1da2			 
1da2			.fapbdone: 
1da2 eb				ex de, hl 
1da3 c3 f2 1b			jp forth_push_numhl 
1da6			 
1da6			 
1da6			.faphex:   ; hex is always stored as a 16bit word 
1da6				; skip number prefix 
1da6 23				inc hl 
1da7				; turn ascii into number 
1da7 cd bd 10			call get_word_hl	; ret 16bit word in hl 
1daa			 
1daa c3 f2 1b			jp forth_push_numhl 
1dad			 
1dad 00				 nop 
1dae			 
1dae			.fabin:   ; TODO bin conversion 
1dae			 
1dae			 
1dae c9				ret 
1daf			 
1daf			 
1daf			; get either a string ptr or a 16bit word from the data stack 
1daf			 
1daf			FORTH_DSP: macro 
1daf				call macro_forth_dsp 
1daf				endm 
1daf			 
1daf			macro_forth_dsp: 
1daf				; data stack pointer points to current word on tos 
1daf			 
1daf 2a 90 f9			ld hl,(cli_data_sp) 
1db2			 
1db2				if DEBUG_FORTH_PUSH 
1db2						DMARK "DSP" 
1db2 f5				push af  
1db3 3a c7 1d			ld a, (.dmark)  
1db6 32 bd fb			ld (debug_mark),a  
1db9 3a c8 1d			ld a, (.dmark+1)  
1dbc 32 be fb			ld (debug_mark+1),a  
1dbf 3a c9 1d			ld a, (.dmark+2)  
1dc2 32 bf fb			ld (debug_mark+2),a  
1dc5 18 03			jr .pastdmark  
1dc7 ..			.dmark: db "DSP"  
1dca f1			.pastdmark: pop af  
1dcb			endm  
# End of macro DMARK
1dcb			 
1dcb cd 23 52				call display_data_sp 
1dce				;call break_point_state 
1dce				;rst 030h 
1dce				CALLMONITOR 
1dce cd 65 16			call break_point_state  
1dd1				endm  
# End of macro CALLMONITOR
1dd1				endif 
1dd1			 
1dd1 c9				ret 
1dd2			 
1dd2			; return hl to start of value on stack 
1dd2			 
1dd2			FORTH_DSP_VALUE: macro 
1dd2				call macro_forth_dsp_value 
1dd2				endm 
1dd2			 
1dd2			macro_forth_dsp_value: 
1dd2			 
1dd2				FORTH_DSP 
1dd2 cd af 1d			call macro_forth_dsp 
1dd5				endm 
# End of macro FORTH_DSP
1dd5			 
1dd5 d5				push de 
1dd6			 
1dd6 23				inc hl ; skip type 
1dd7			 
1dd7 5e				ld e, (hl) 
1dd8 23				inc hl 
1dd9 56				ld d, (hl) 
1dda eb				ex de,hl  
1ddb			 
1ddb d1				pop de 
1ddc			 
1ddc c9				ret 
1ddd			 
1ddd			; return hl to start of value to second item on stack 
1ddd			 
1ddd			FORTH_DSP_VALUEM1: macro 
1ddd				call macro_forth_dsp_value_m1 
1ddd				endm 
1ddd			 
1ddd			macro_forth_dsp_value_m1: 
1ddd			 
1ddd				FORTH_DSP 
1ddd cd af 1d			call macro_forth_dsp 
1de0				endm 
# End of macro FORTH_DSP
1de0			 
1de0 2b				dec hl 
1de1 2b				dec hl 
1de2			;	dec hl 
1de2			 
1de2 d5				push de 
1de3			 
1de3 5e				ld e, (hl) 
1de4 23				inc hl 
1de5 56				ld d, (hl) 
1de6 eb				ex de,hl  
1de7			 
1de7 d1				pop de 
1de8			 
1de8 c9				ret 
1de9			 
1de9				 
1de9			 
1de9			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1de9			 
1de9			FORTH_DSP_POP: macro 
1de9				call macro_forth_dsp_pop 
1de9				endm 
1de9			 
1de9			 
1de9			; get the tos data type 
1de9			 
1de9			FORTH_DSP_TYPE:   macro 
1de9			 
1de9				;FORTH_DSP_VALUE 
1de9				FORTH_DSP 
1de9				 
1de9				; hl points to value 
1de9				; check type 
1de9			 
1de9				ld a,(hl) 
1de9			 
1de9				endm 
1de9			 
1de9			; load the tos value into hl 
1de9			 
1de9			 
1de9			FORTH_DSP_VALUEHL:  macro 
1de9				call macro_dsp_valuehl 
1de9				endm 
1de9			 
1de9			 
1de9			 
1de9			macro_dsp_valuehl: 
1de9				FORTH_DSP_VALUE 
1de9 cd d2 1d			call macro_forth_dsp_value 
1dec				endm 
# End of macro FORTH_DSP_VALUE
1dec			 
1dec				;FORTH_ERR_TOS_NOTNUM 
1dec			 
1dec				;inc hl   ; skip type id 
1dec			 
1dec			;	push de 
1dec			; 
1dec			;	ld e, (hl) 
1dec			;	inc hl 
1dec			;	ld d, (hl) 
1dec			;	ex de,hl  
1dec			 
1dec			;	pop de 
1dec			 
1dec				if DEBUG_FORTH_PUSH 
1dec						DMARK "DVL" 
1dec f5				push af  
1ded 3a 01 1e			ld a, (.dmark)  
1df0 32 bd fb			ld (debug_mark),a  
1df3 3a 02 1e			ld a, (.dmark+1)  
1df6 32 be fb			ld (debug_mark+1),a  
1df9 3a 03 1e			ld a, (.dmark+2)  
1dfc 32 bf fb			ld (debug_mark+2),a  
1dff 18 03			jr .pastdmark  
1e01 ..			.dmark: db "DVL"  
1e04 f1			.pastdmark: pop af  
1e05			endm  
# End of macro DMARK
1e05				CALLMONITOR 
1e05 cd 65 16			call break_point_state  
1e08				endm  
# End of macro CALLMONITOR
1e08				endif 
1e08 c9				ret 
1e09			 
1e09			forth_apushstrhl:      
1e09				; push of string requires use of cli_origptr 
1e09				; bodge use 
1e09			 
1e09				; get current cli_origptr, save, update with temp pointer  
1e09 ed 5b ac f9		ld de, (cli_origptr) 
1e0d 22 ac f9			ld (cli_origptr), hl 
1e10 d5				push de 
1e11 cd 5b 1d			call forth_apush 
1e14 d1				pop de 
1e15 ed 53 ac f9		ld (cli_origptr), de 
1e19 c9			        ret	 
1e1a			 
1e1a			 
1e1a			; increase loop stack pointer and save hl to it 
1e1a				 
1e1a			FORTH_LOOP_NEXT: macro 
1e1a				call macro_forth_loop_next 
1e1a				;nop 
1e1a				endm 
1e1a			 
1e1a			macro_forth_loop_next: 
1e1a				if DEBUG_FORTH_STACK_GUARD 
1e1a cd 88 62				call check_stacks 
1e1d				endif 
1e1d e5				push hl 
1e1e d5				push de 
1e1f eb				ex de,hl 
1e20 2a 92 f9			ld hl,(cli_loop_sp) 
1e23 23				inc hl 
1e24 23				inc hl 
1e25					if DEBUG_FORTH_WORDS 
1e25						DMARK "LNX" 
1e25 f5				push af  
1e26 3a 3a 1e			ld a, (.dmark)  
1e29 32 bd fb			ld (debug_mark),a  
1e2c 3a 3b 1e			ld a, (.dmark+1)  
1e2f 32 be fb			ld (debug_mark+1),a  
1e32 3a 3c 1e			ld a, (.dmark+2)  
1e35 32 bf fb			ld (debug_mark+2),a  
1e38 18 03			jr .pastdmark  
1e3a ..			.dmark: db "LNX"  
1e3d f1			.pastdmark: pop af  
1e3e			endm  
# End of macro DMARK
1e3e						CALLMONITOR 
1e3e cd 65 16			call break_point_state  
1e41				endm  
# End of macro CALLMONITOR
1e41					endif 
1e41 22 92 f9			ld (cli_loop_sp),hl 
1e44 73				ld (hl), e 
1e45 23				inc hl 
1e46 72				ld (hl), d 
1e47 d1				pop de    ; been reversed so save a swap on restore 
1e48 e1				pop hl 
1e49				if DEBUG_FORTH_STACK_GUARD 
1e49 cd 88 62				call check_stacks 
1e4c				endif 
1e4c c9				ret 
1e4d			 
1e4d			; get current ret stack pointer and save to hl  
1e4d				 
1e4d			FORTH_LOOP_TOS: macro 
1e4d				call macro_forth_loop_tos 
1e4d				endm 
1e4d			 
1e4d			macro_forth_loop_tos: 
1e4d d5				push de 
1e4e 2a 92 f9			ld hl,(cli_loop_sp) 
1e51 5e				ld e, (hl) 
1e52 23				inc hl 
1e53 56				ld d, (hl) 
1e54 eb				ex de, hl 
1e55 d1				pop de 
1e56 c9				ret 
1e57			 
1e57			; pop loop stack pointer 
1e57				 
1e57			FORTH_LOOP_POP: macro 
1e57				call macro_forth_loop_pop 
1e57				endm 
1e57			 
1e57			 
1e57			macro_forth_loop_pop: 
1e57				if DEBUG_FORTH_STACK_GUARD 
1e57					DMARK "LPP" 
1e57 f5				push af  
1e58 3a 6c 1e			ld a, (.dmark)  
1e5b 32 bd fb			ld (debug_mark),a  
1e5e 3a 6d 1e			ld a, (.dmark+1)  
1e61 32 be fb			ld (debug_mark+1),a  
1e64 3a 6e 1e			ld a, (.dmark+2)  
1e67 32 bf fb			ld (debug_mark+2),a  
1e6a 18 03			jr .pastdmark  
1e6c ..			.dmark: db "LPP"  
1e6f f1			.pastdmark: pop af  
1e70			endm  
# End of macro DMARK
1e70 cd 88 62				call check_stacks 
1e73					FORTH_CHK_LOOP_UNDER 
1e73 e5				push hl 
1e74 d5				push de 
1e75 2a 92 f9			ld hl,(cli_loop_sp) 
1e78 11 0c f7			ld de, cli_loop_stack 
1e7b cd 24 0d			call cmp16 
1e7e da a2 63			jp c, fault_loop_under 
1e81 d1				pop de 
1e82 e1				pop hl 
1e83				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e83				endif 
1e83 e5				push hl 
1e84 2a 92 f9			ld hl,(cli_loop_sp) 
1e87 2b				dec hl 
1e88 2b				dec hl 
1e89 22 92 f9			ld (cli_loop_sp), hl 
1e8c				; TODO do stack underflow checks 
1e8c e1				pop hl 
1e8d				if DEBUG_FORTH_STACK_GUARD 
1e8d cd 88 62				call check_stacks 
1e90					FORTH_CHK_LOOP_UNDER 
1e90 e5				push hl 
1e91 d5				push de 
1e92 2a 92 f9			ld hl,(cli_loop_sp) 
1e95 11 0c f7			ld de, cli_loop_stack 
1e98 cd 24 0d			call cmp16 
1e9b da a2 63			jp c, fault_loop_under 
1e9e d1				pop de 
1e9f e1				pop hl 
1ea0				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ea0				endif 
1ea0 c9				ret 
1ea1			 
1ea1			macro_forth_dsp_pop: 
1ea1			 
1ea1 e5				push hl 
1ea2			 
1ea2				; release malloc data 
1ea2			 
1ea2				if DEBUG_FORTH_STACK_GUARD 
1ea2 cd 88 62				call check_stacks 
1ea5					FORTH_CHK_DSP_UNDER 
1ea5 e5				push hl 
1ea6 d5				push de 
1ea7 2a 90 f9			ld hl,(cli_data_sp) 
1eaa 11 0a f5			ld de, cli_data_stack 
1ead cd 24 0d			call cmp16 
1eb0 da 96 63			jp c, fault_dsp_under 
1eb3 d1				pop de 
1eb4 e1				pop hl 
1eb5				endm 
# End of macro FORTH_CHK_DSP_UNDER
1eb5				endif 
1eb5				;ld hl,(cli_data_sp) 
1eb5			if DEBUG_FORTH_DOT 
1eb5				DMARK "DPP" 
1eb5				CALLMONITOR 
1eb5			endif	 
1eb5			 
1eb5			 
1eb5			if FORTH_ENABLE_DSPPOPFREE 
1eb5			 
1eb5				FORTH_DSP 
1eb5 cd af 1d			call macro_forth_dsp 
1eb8				endm 
# End of macro FORTH_DSP
1eb8			 
1eb8 7e				ld a, (hl) 
1eb9 fe 01			cp DS_TYPE_STR 
1ebb 20 07			jr nz, .skippopfree 
1ebd			 
1ebd				FORTH_DSP_VALUEHL 
1ebd cd e9 1d			call macro_dsp_valuehl 
1ec0				endm 
# End of macro FORTH_DSP_VALUEHL
1ec0 00				nop 
1ec1			if DEBUG_FORTH_DOT 
1ec1				DMARK "DPf" 
1ec1				CALLMONITOR 
1ec1			endif	 
1ec1 cd 97 12			call free 
1ec4			.skippopfree: 
1ec4				 
1ec4			 
1ec4			endif 
1ec4			 
1ec4			if DEBUG_FORTH_DOT_KEY 
1ec4				DMARK "DP2" 
1ec4				CALLMONITOR 
1ec4			endif	 
1ec4			 
1ec4				; move pointer down 
1ec4			 
1ec4 2a 90 f9			ld hl,(cli_data_sp) 
1ec7 2b				dec hl 
1ec8 2b				dec hl 
1ec9			; PARSEV5 
1ec9 2b				dec hl 
1eca 22 90 f9			ld (cli_data_sp), hl 
1ecd			 
1ecd				if DEBUG_FORTH_STACK_GUARD 
1ecd cd 88 62				call check_stacks 
1ed0					FORTH_CHK_DSP_UNDER 
1ed0 e5				push hl 
1ed1 d5				push de 
1ed2 2a 90 f9			ld hl,(cli_data_sp) 
1ed5 11 0a f5			ld de, cli_data_stack 
1ed8 cd 24 0d			call cmp16 
1edb da 96 63			jp c, fault_dsp_under 
1ede d1				pop de 
1edf e1				pop hl 
1ee0				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ee0				endif 
1ee0			 
1ee0 e1				pop hl 
1ee1			 
1ee1 c9				ret 
1ee2			 
1ee2			getwordathl: 
1ee2				; hl points to an address 
1ee2				; load hl with the word at that address 
1ee2			 
1ee2 d5				push de 
1ee3			 
1ee3 5e				ld e, (hl) 
1ee4 23				inc hl 
1ee5 56				ld d, (hl) 
1ee6 eb				ex de, hl 
1ee7			 
1ee7 d1				pop de 
1ee8 c9				ret 
1ee9			 
1ee9			 
1ee9			 
1ee9			 
1ee9			 
1ee9			; eof 
1ee9			 
# End of file forth_stackopsv5.asm
1ee9			endif 
1ee9			 
1ee9			user_word_eol:  
1ee9				; hl contains the pointer to where to create a linked list item from the end 
1ee9				; of the user dict to continue on at the system word dict 
1ee9				 
1ee9				; poke the stub of the word list linked list to repoint to rom words 
1ee9			 
1ee9				; stub format 
1ee9				; db   word id 
1ee9				; dw    link to next word 
1ee9			        ; db char length of token 
1ee9				; db string + 0 term 
1ee9				; db exec code....  
1ee9			 
1ee9 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1eeb 77				ld (hl), a		; word id 
1eec 23				inc hl 
1eed			 
1eed 11 b3 20			ld de, sysdict 
1ef0 73				ld (hl), e		; next word link ie system dict 
1ef1 23				inc hl 
1ef2 72				ld (hl), d		; next word link ie system dict 
1ef3 23				inc hl	 
1ef4			 
1ef4			;	ld (hl), sysdict		; next word link ie system dict 
1ef4			;	inc hl 
1ef4			;	inc hl 
1ef4			 
1ef4			;	inc hl 
1ef4			;	inc hl 
1ef4			 
1ef4 3e 02			ld a, 2			; word length is 0 
1ef6 77				ld (hl), a	 
1ef7 23				inc hl 
1ef8			 
1ef8 3e 7e			ld a, '~'			; word length is 0 
1efa 77				ld (hl), a	 
1efb 23				inc hl 
1efc 3e 00			ld a, 0			; save empty word 
1efe 77				ld (hl), a 
1eff			 
1eff c9				ret 
1f00			 
1f00				 
1f00			 
1f00			forthexec_cleanup: 
1f00				FORTH_RSP_POP 
1f00 cd ba 1b			call macro_forth_rsp_pop 
1f03				endm 
# End of macro FORTH_RSP_POP
1f03 c9				ret 
1f04			 
1f04			forth_call_hl: 
1f04				; taking hl 
1f04 e5				push hl 
1f05 c9				ret 
1f06			 
1f06			; this is called to reset Forth system but keep existing uwords etc 
1f06			 
1f06			forth_warmstart: 
1f06				; setup stack over/under flow checks 
1f06				if DEBUG_FORTH_STACK_GUARD 
1f06 cd 6e 62				call chk_stk_init 
1f09				endif 
1f09			 
1f09				; init stack pointers  - * these stacks go upwards *  
1f09 21 0e f9			ld hl, cli_ret_stack 
1f0c 22 94 f9			ld (cli_ret_sp), hl	 
1f0f				; set bottom of stack 
1f0f 3e 00			ld a,0 
1f11 77				ld (hl),a 
1f12 23				inc hl 
1f13 77				ld (hl),a 
1f14			 
1f14 21 0a f5			ld hl, cli_data_stack 
1f17 22 90 f9			ld (cli_data_sp), hl	 
1f1a				; set bottom of stack 
1f1a 3e 00			ld a,0 
1f1c 77				ld (hl),a 
1f1d 23				inc hl 
1f1e 77				ld (hl),a 
1f1f			 
1f1f 21 0c f7			ld hl, cli_loop_stack 
1f22 22 92 f9			ld (cli_loop_sp), hl	 
1f25				; set bottom of stack 
1f25 3e 00			ld a,0 
1f27 77				ld (hl),a 
1f28 23				inc hl 
1f29 77				ld (hl),a 
1f2a			 
1f2a				; init extent of current open file 
1f2a			 
1f2a 3e 00			ld a, 0 
1f2c 32 df f9			ld (store_openext), a 
1f2f			 
1f2f c9				ret 
1f30			 
1f30			 
1f30			; Cold Start - this is called to setup the whole Forth system 
1f30			 
1f30			forth_init: 
1f30			 
1f30				; setup stack over/under flow checks 
1f30			 
1f30			;	if DEBUG_FORTH_STACK_GUARD 
1f30			;		call chk_stk_init 
1f30			;	endif 
1f30			 
1f30				; enable auto display updates (slow.....) 
1f30			 
1f30 3e 01			ld a, 1 
1f32 32 aa f9			ld (cli_autodisplay), a 
1f35			 
1f35			 
1f35			 
1f35				; show start up screen 
1f35			 
1f35 cd d2 0a			call clear_display 
1f38			 
1f38 3e 00			ld a,0 
1f3a 32 cc f9			ld (f_cursor_ptr), a 
1f3d			 
1f3d				; set start of word list in start of ram - for use when creating user words 
1f3d			 
1f3d 21 00 80			ld hl, baseram 
1f40 22 a0 f2			ld (os_last_new_uword), hl 
1f43 cd e9 1e			call user_word_eol 
1f46				 
1f46			;		call display_data_sp 
1f46			;		call next_page_prompt 
1f46			 
1f46			 
1f46			 
1f46			 
1f46 c9				ret 
1f47			 
1f47 .. 00		.bootforth: db " Forth Kernel Init ",0 
1f5b			 
1f5b			; TODO push to stack 
1f5b			 
1f5b			;  
1f5b			 
1f5b			if FORTH_PARSEV2 
1f5b			 
1f5b			 
1f5b				include "forth_parserv2.asm" 
1f5b			 
1f5b			endif 
1f5b			 
1f5b			 
1f5b			; parse cli version 1 
1f5b			 
1f5b			if FORTH_PARSEV1 
1f5b			 
1f5b			 
1f5b			 
1f5b			      include "forth_parserv1.asm" 
1f5b			endif 
1f5b				 
1f5b			if FORTH_PARSEV3 
1f5b			 
1f5b			 
1f5b			 
1f5b			      include "forth_parserv3.asm" 
1f5b				include "forth_wordsv3.asm" 
1f5b			endif 
1f5b			 
1f5b			if FORTH_PARSEV4 
1f5b			 
1f5b			 
1f5b			 
1f5b			      include "forth_parserv4.asm" 
1f5b				include "forth_wordsv4.asm" 
1f5b			endif 
1f5b			 
1f5b			if FORTH_PARSEV5 
1f5b			 
1f5b			 
1f5b			 
1f5b			      include "forth_parserv5.asm" 
1f5b			 
1f5b			 
1f5b			; A better parser without using malloc and string copies all over the place.  
1f5b			; Exec in situ should be faster 
1f5b			 
1f5b			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1f5b			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1f5b			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1f5b			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1f5b			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1f5b			WORD_SYS_END: equ 0   ; Opcode for all user words 
1f5b			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1f5b			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1f5b			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1f5b			 
1f5b			; Core word preamble macro 
1f5b			 
1f5b			CWHEAD:   macro nxtword opcode lit len opflags 
1f5b				db WORD_SYS_CORE+opcode             
1f5b				; internal op code number 
1f5b				dw nxtword            
1f5b				; link to next dict word block 
1f5b				db len + 1 
1f5b				; literal length of dict word inc zero term 
1f5b				db lit,0              
1f5b				; literal dict word 
1f5b			        ; TODO db opflags        
1f5b				endm 
1f5b			 
1f5b			 
1f5b			NEXTW: macro  
1f5b				jp macro_next 
1f5b				endm 
1f5b			 
1f5b			macro_next: 
1f5b			if DEBUG_FORTH_PARSE_KEY 
1f5b				DMARK "NXT" 
1f5b				CALLMONITOR 
1f5b			endif	 
1f5b			;	inc hl  ; skip token null term  
1f5b ed 4b ae f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f5f ed 5b ac f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f63 2a a4 f2			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f66			if DEBUG_FORTH_PARSE_KEY 
1f66				DMARK "}AA" 
1f66				CALLMONITOR 
1f66			endif	 
1f66 c3 69 20			jp execnext 
1f69				;jp exec1 
1f69			       
1f69			 
1f69			 
1f69			; Another go at the parser to compile  
1f69			 
1f69			 
1f69			; TODO rework parser to change all of the string words to byte tokens 
1f69			; TODO do a search for  
1f69			 
1f69			; TODO first run normal parser to zero term sections 
1f69			; TODO for each word do a token look up to get the op code 
1f69			; TODO need some means to flag to the exec that this is a byte code form    
1f69			 
1f69			 
1f69			forthcompile: 
1f69			 
1f69			; 
1f69			; line parse: 
1f69			;       parse raw input buffer 
1f69			;       tokenise the words 
1f69			;       malloc new copy (for looping etc) 
1f69			;       copy to malloc + current pc in line to start of string and add line term 
1f69			;       save on new rsp 
1f69			; 
1f69			 
1f69			; hl to point to the line to tokenise 
1f69			 
1f69			;	push hl 
1f69 22 a4 f2			ld (os_tok_ptr), hl  ; save ptr to string 
1f6c			 
1f6c			;	ld a,0		; string term on input 
1f6c			;	call strlent 
1f6c			 
1f6c			;	ld (os_tok_len), hl	 ; save string length 
1f6c			 
1f6c			;if DEBUG_FORTH_TOK 
1f6c			;	ex de,hl		 
1f6c			;endif 
1f6c			 
1f6c			;	pop hl 		; get back string pointer 
1f6c			 
1f6c			if DEBUG_FORTH_TOK 
1f6c						DMARK "TOc" 
1f6c				CALLMONITOR 
1f6c			endif 
1f6c 7e			.cptoken2:    ld a,(hl) 
1f6d 23				inc hl 
1f6e fe 7f			cp FORTH_END_BUFFER 
1f70 28 29			jr z, .cptokendone2 
1f72 fe 00			cp 0 
1f74 28 25			jr z, .cptokendone2 
1f76 fe 22			cp '"' 
1f78 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1f7a fe 20			cp ' ' 
1f7c 20 ee			jr nz,  .cptoken2 
1f7e			 
1f7e			; TODO consume comments held between ( and ) 
1f7e			 
1f7e				; we have a space so change to zero term for dict match later 
1f7e 2b				dec hl 
1f7f 3e 00			ld a,0 
1f81 77				ld (hl), a 
1f82 23				inc hl 
1f83 18 e7			jr .cptoken2 
1f85				 
1f85			 
1f85			.cptokenstr2: 
1f85				; skip all white space until either eol (because forgot to term) or end double quote 
1f85			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f85				;inc hl ; skip current double quote 
1f85 7e				ld a,(hl) 
1f86 23				inc hl 
1f87 fe 22			cp '"' 
1f89 28 e1			jr z, .cptoken2 
1f8b fe 7f			cp FORTH_END_BUFFER 
1f8d 28 0c			jr z, .cptokendone2 
1f8f fe 00			cp 0 
1f91 28 08			jr z, .cptokendone2 
1f93 fe 20			cp ' ' 
1f95 28 02			jr z, .cptmp2 
1f97 18 ec			jr .cptokenstr2 
1f99			 
1f99			.cptmp2:	; we have a space so change to zero term for dict match later 
1f99				;dec hl 
1f99				;ld a,"-"	; TODO remove this when working 
1f99				;ld (hl), a 
1f99				;inc hl 
1f99 18 ea			jr .cptokenstr2 
1f9b			 
1f9b			.cptokendone2: 
1f9b				;inc hl 
1f9b 3e 7f			ld a, FORTH_END_BUFFER 
1f9d 77				ld (hl),a 
1f9e 23				inc hl 
1f9f 3e 21			ld a, '!' 
1fa1 77				ld (hl),a 
1fa2			 
1fa2 2a a4 f2			ld hl,(os_tok_ptr) 
1fa5			         
1fa5			if DEBUG_FORTH_TOK 
1fa5						DMARK "Tc1" 
1fa5				CALLMONITOR 
1fa5			endif 
1fa5			 
1fa5				; push exec string to top of return stack 
1fa5				FORTH_RSP_NEXT 
1fa5 cd 99 1b			call macro_forth_rsp_next 
1fa8				endm 
# End of macro FORTH_RSP_NEXT
1fa8 c9				ret 
1fa9			 
1fa9			; Another go at the parser need to simplify the process 
1fa9			 
1fa9			forthparse: 
1fa9			 
1fa9			; 
1fa9			; line parse: 
1fa9			;       parse raw input buffer 
1fa9			;       tokenise the words 
1fa9			;       malloc new copy (for looping etc) 
1fa9			;       copy to malloc + current pc in line to start of string and add line term 
1fa9			;       save on new rsp 
1fa9			; 
1fa9			 
1fa9			; hl to point to the line to tokenise 
1fa9			 
1fa9			;	push hl 
1fa9 22 a4 f2			ld (os_tok_ptr), hl  ; save ptr to string 
1fac			 
1fac			;	ld a,0		; string term on input 
1fac			;	call strlent 
1fac			 
1fac			;	ld (os_tok_len), hl	 ; save string length 
1fac			 
1fac			;if DEBUG_FORTH_TOK 
1fac			;	ex de,hl		 
1fac			;endif 
1fac			 
1fac			;	pop hl 		; get back string pointer 
1fac			 
1fac			if DEBUG_FORTH_TOK 
1fac						DMARK "TOK" 
1fac				CALLMONITOR 
1fac			endif 
1fac 7e			.ptoken2:    ld a,(hl) 
1fad 23				inc hl 
1fae fe 7f			cp FORTH_END_BUFFER 
1fb0 28 29			jr z, .ptokendone2 
1fb2 fe 00			cp 0 
1fb4 28 25			jr z, .ptokendone2 
1fb6 fe 22			cp '"' 
1fb8 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1fba fe 20			cp ' ' 
1fbc 20 ee			jr nz,  .ptoken2 
1fbe			 
1fbe			; TODO consume comments held between ( and ) 
1fbe			 
1fbe				; we have a space so change to zero term for dict match later 
1fbe 2b				dec hl 
1fbf 3e 00			ld a,0 
1fc1 77				ld (hl), a 
1fc2 23				inc hl 
1fc3 18 e7			jr .ptoken2 
1fc5				 
1fc5			 
1fc5			.ptokenstr2: 
1fc5				; skip all white space until either eol (because forgot to term) or end double quote 
1fc5			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1fc5				;inc hl ; skip current double quote 
1fc5 7e				ld a,(hl) 
1fc6 23				inc hl 
1fc7 fe 22			cp '"' 
1fc9 28 e1			jr z, .ptoken2 
1fcb fe 7f			cp FORTH_END_BUFFER 
1fcd 28 0c			jr z, .ptokendone2 
1fcf fe 00			cp 0 
1fd1 28 08			jr z, .ptokendone2 
1fd3 fe 20			cp ' ' 
1fd5 28 02			jr z, .ptmp2 
1fd7 18 ec			jr .ptokenstr2 
1fd9			 
1fd9			.ptmp2:	; we have a space so change to zero term for dict match later 
1fd9				;dec hl 
1fd9				;ld a,"-"	; TODO remove this when working 
1fd9				;ld (hl), a 
1fd9				;inc hl 
1fd9 18 ea			jr .ptokenstr2 
1fdb			 
1fdb			.ptokendone2: 
1fdb				;inc hl 
1fdb 3e 7f			ld a, FORTH_END_BUFFER 
1fdd 77				ld (hl),a 
1fde 23				inc hl 
1fdf 3e 21			ld a, '!' 
1fe1 77				ld (hl),a 
1fe2			 
1fe2 2a a4 f2			ld hl,(os_tok_ptr) 
1fe5			         
1fe5			if DEBUG_FORTH_TOK 
1fe5						DMARK "TK1" 
1fe5				CALLMONITOR 
1fe5			endif 
1fe5			 
1fe5				; push exec string to top of return stack 
1fe5				FORTH_RSP_NEXT 
1fe5 cd 99 1b			call macro_forth_rsp_next 
1fe8				endm 
# End of macro FORTH_RSP_NEXT
1fe8 c9				ret 
1fe9			 
1fe9			; 
1fe9			;	; malloc size + buffer pointer + if is loop flag 
1fe9			;	ld hl,(os_tok_len) 		 ; get string length 
1fe9			; 
1fe9			;	ld a,l 
1fe9			; 
1fe9			;	cp 0			; we dont want to use a null string 
1fe9			;	ret z 
1fe9			; 
1fe9			;;	add 3    ; prefix malloc with buffer for current word ptr 
1fe9			; 
1fe9			;	add 5     ; TODO when certain not over writing memory remove 
1fe9			; 
1fe9			;		 
1fe9			; 
1fe9			;if DEBUG_FORTH_TOK 
1fe9			;			DMARK "TKE" 
1fe9			;	CALLMONITOR 
1fe9			;endif 
1fe9			; 
1fe9			;	ld l,a 
1fe9			;	ld h,0 
1fe9			;;	push hl   ; save required space for the copy later 
1fe9			;	call malloc 
1fe9			;if DEBUG_FORTH_TOK 
1fe9			;			DMARK "TKM" 
1fe9			;	CALLMONITOR 
1fe9			;endif 
1fe9			;	if DEBUG_FORTH_MALLOC_GUARD 
1fe9			;		push af 
1fe9			;		call ishlzero 
1fe9			;;		ld a, l 
1fe9			;;		add h 
1fe9			;;		cp 0 
1fe9			;		pop af 
1fe9			;		 
1fe9			;		call z,malloc_error 
1fe9			;	endif 
1fe9			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1fe9			; 
1fe9			; 
1fe9			;if DEBUG_FORTH_TOK 
1fe9			;			DMARK "TKR" 
1fe9			;	CALLMONITOR 
1fe9			;endif 
1fe9			; 
1fe9			;	FORTH_RSP_NEXT 
1fe9			; 
1fe9			;	;inc hl	 ; go past current buffer pointer 
1fe9			;	;inc hl 
1fe9			;	;inc hl   ; and past if loop flag 
1fe9			;		; TODO Need to set flag  
1fe9			; 
1fe9			;	 
1fe9			;	 
1fe9			;	ex de,hl	; malloc is dest 
1fe9			;	ld hl, (os_tok_len) 
1fe9			;;	pop bc 
1fe9			;	ld c, l                
1fe9			;	ld b,0 
1fe9			;	ld hl, (os_tok_ptr) 
1fe9			; 
1fe9			;if DEBUG_FORTH_TOK 
1fe9			;			DMARK "TKT" 
1fe9			;	CALLMONITOR 
1fe9			;endif 
1fe9			; 
1fe9			;	; do str cpy 
1fe9			; 
1fe9			;	ldir      ; copy byte in hl to de 
1fe9			; 
1fe9			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1fe9			; 
1fe9			;if DEBUG_FORTH_TOK 
1fe9			; 
1fe9			;			DMARK "TKY" 
1fe9			;	CALLMONITOR 
1fe9			;endif 
1fe9			;	;ld a,0 
1fe9			;	;ld a,FORTH_END_BUFFER 
1fe9			;	ex de, hl 
1fe9			;	;dec hl			 ; go back over the space delim at the end of word 
1fe9			;	;ld (hl),a 
1fe9			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1fe9			;	ld a,FORTH_END_BUFFER 
1fe9			;	ld (hl),a 
1fe9			;	inc hl 
1fe9			;	ld a,FORTH_END_BUFFER 
1fe9			;	ld (hl),a 
1fe9			; 
1fe9			;	; init the malloc area data 
1fe9			;	; set pc for in current area 
1fe9			;	;ld hl, (os_tok_malloc) 
1fe9			;	;inc hl 
1fe9			;	;inc hl 
1fe9			;	;inc hl 
1fe9			;	;ex de,hl 
1fe9			;	;ld hl, (os_tok_malloc) 
1fe9			;	;ld (hl),e 
1fe9			;	;inc hl 
1fe9			;	;ld (hl),d 
1fe9			; 
1fe9			; 
1fe9			;	ld hl,(os_tok_malloc) 
1fe9			;if DEBUG_FORTH_PARSE_KEY 
1fe9			;			DMARK "TKU" 
1fe9			;	CALLMONITOR 
1fe9			;endif 
1fe9			; 
1fe9			;	ret 
1fe9			 
1fe9			forthexec: 
1fe9			 
1fe9			; line exec: 
1fe9			; forth parser 
1fe9			 
1fe9			; 
1fe9			;       get current exec line on rsp 
1fe9			 
1fe9				FORTH_RSP_TOS 
1fe9 cd b0 1b			call macro_forth_rsp_tos 
1fec				endm 
# End of macro FORTH_RSP_TOS
1fec			 
1fec			;       restore current pc - hl points to malloc of data 
1fec			 
1fec				;ld e, (hl) 
1fec				;inc hl 
1fec				;ld d, (hl) 
1fec				;ex de,hl 
1fec			 
1fec			 
1fec			exec1: 
1fec 22 a4 f2			ld (os_tok_ptr), hl 
1fef			 
1fef				; copy our PC to working vars  
1fef 22 ae f9			ld (cli_ptr), hl 
1ff2 22 ac f9			ld (cli_origptr), hl 
1ff5			 
1ff5 7e				ld a,(hl) 
1ff6 fe 7f			cp FORTH_END_BUFFER 
1ff8 c8				ret z 
1ff9			 
1ff9				; skip any nulls 
1ff9			 
1ff9 fe 00			cp 0 
1ffb 20 03			jr nz, .execword 
1ffd 23				inc hl 
1ffe 18 ec			jr exec1 
2000			 
2000			 
2000			.execword: 
2000			 
2000			 
2000			 
2000			if DEBUG_FORTH_PARSE_KEY 
2000						DMARK "KYQ" 
2000				CALLMONITOR 
2000			endif 
2000			;       while at start of word: 
2000			; get start of dict (in user area first) 
2000			 
2000 21 00 80		ld hl, baseram 
2003			;ld hl, sysdict 
2003 22 b0 f9		ld (cli_nextword),hl 
2006			;           match word at pc 
2006			;           exec word 
2006			;           or push to dsp 
2006			;           forward to next token 
2006			;           if line term pop rsp and exit 
2006			;        
2006			 
2006			if DEBUG_FORTH_PARSE_KEY 
2006						DMARK "KYq" 
2006				CALLMONITOR 
2006			endif 
2006			 
2006			; 
2006			; word comp 
2006			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2006			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2006			;    move to start of word  
2006			;    compare word to cli_token 
2006			 
2006			.execpnword:	; HL at start of a word in the dictionary to check 
2006			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2006			;	ld (cli_ptr), hl 
2006			 
2006 2a b0 f9			ld hl,(cli_nextword) 
2009			 
2009 cd ac 20			call forth_tok_next 
200c			; tok next start here 
200c			;	; TODO skip compiled symbol for now 
200c			;	inc hl 
200c			; 
200c			;	; save pointer to next word 
200c			; 
200c			;	; hl now points to the address of the next word pointer  
200c			;	ld e, (hl) 
200c			;	inc hl 
200c			;	ld d, (hl) 
200c			;	inc l 
200c			; 
200c			;	ex de,hl 
200c			;if DEBUG_FORTH_PARSE_NEXTWORD 
200c			;	push bc 
200c			;	ld bc, (cli_nextword) 
200c			;			DMARK "NXW" 
200c			;	CALLMONITOR 
200c			;	pop bc 
200c			;endif 
200c			; tok next end here 
200c 22 b0 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
200f eb				ex de, hl 
2010			 
2010			 
2010				; save the pointer of the current token - 1 to check against 
2010				 
2010 22 b4 f9			ld (cli_token), hl   
2013				; TODO maybe remove below save if no debug 
2013				; save token string ptr for any debug later 
2013 23				inc hl  
2014 22 b6 f9			ld (cli_origtoken), hl 
2017 2b				dec hl 
2018				; save pointer to the start of the next dictionay word 
2018 7e				ld a,(hl)   ; get string length 
2019 47				ld b,a 
201a			.execpnwordinc:  
201a 23				inc hl 
201b 10 fd			djnz .execpnwordinc 
201d 22 b2 f9			ld (cli_execword), hl      ; save start of this words code 
2020			 
2020				; now check the word token against the string being parsed 
2020			 
2020 2a b4 f9			ld hl,(cli_token) 
2023 23				inc hl     ; skip string length (use zero term instead to end) 
2024 22 b4 f9			ld (cli_token), hl 
2027			 
2027			if DEBUG_FORTH_PARSE_KEY 
2027						DMARK "KY2" 
2027			endif 
2027			if DEBUG_FORTH_PARSE_EXEC 
2027				; see if disabled 
2027			 
2027				ld a, (os_view_disable) 
2027				cp '*' 
2027				jr z, .skip 
2027			 
2027				push hl 
2027				push hl 
2027				call clear_display 
2027				ld de, .compword 
2027				ld a, display_row_1 
2027				call str_at_display 
2027				pop de 
2027				ld a, display_row_2 
2027				call str_at_display 
2027				ld hl,(cli_ptr) 
2027				ld a,(hl) 
2027			        ld hl, os_word_scratch 
2027				ld (hl),a 
2027				ld a,0 
2027				inc hl 
2027				ld (hl),a 	 
2027				ld de, os_word_scratch 
2027				ld a, display_row_2+10 
2027				call str_at_display 
2027				call update_display 
2027				ld a, 100 
2027				call aDelayInMS 
2027				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2027				call delay250ms 
2027				endif 
2027				pop hl 
2027			.skip:  
2027			endif	 
2027			.execpnchar:    ; compare char between token and string to parse 
2027			 
2027			if DEBUG_FORTH_PARSE_KEY 
2027						DMARK "Ky3" 
2027			endif 
2027			if DEBUG_FORTH_PARSE_EXEC 
2027				; see if disabled 
2027			 
2027				ld a, (os_view_disable) 
2027				cp '*' 
2027				jr z, .skip2 
2027			 
2027			;	call clear_display 
2027			ld hl,(cli_token) 
2027			ld a,(hl) 
2027			ld (os_word_scratch),a 
2027				ld hl,(cli_ptr) 
2027			ld a,(hl) 
2027				ld (os_word_scratch+1),a 
2027				ld a,0 
2027				ld (os_word_scratch+2),a 
2027				ld de,os_word_scratch 
2027				ld a,display_row_4 
2027				call str_at_display 
2027				call update_display 
2027			.skip2:  
2027			endif 
2027 2a b4 f9			ld hl,(cli_token) 
202a 7e				ld a, (hl)	 ; char in word token 
202b 23				inc hl 		; move to next char 
202c 22 b4 f9			ld (cli_token), hl ; and save it 
202f 47				ld b,a 
2030			 
2030 2a ae f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
2033 7e				ld a,(hl) 
2034 23				inc hl 
2035 22 ae f9			ld (cli_ptr), hl		; move to next char 
2038 cd 5b 11			call toUpper 		; make sure the input string matches case 
203b			 
203b			if DEBUG_FORTH_PARSE 
203b			endif 
203b			 
203b				; input stream end of token is a space so get rid of it 
203b			 
203b			;	cp ' ' 
203b			;	jr nz, .pnskipspace 
203b			; 
203b			;	ld a, 0		; make same term as word token term 
203b			; 
203b			;.pnskipspace: 
203b			 
203b			if DEBUG_FORTH_PARSE_KEY 
203b						DMARK "KY7" 
203b			endif 
203b b8				cp b 
203c c2 52 20			jp nz, .execpnskipword	 ; no match so move to next word 
203f				 
203f			;    if same 
203f			;       scan for string terms 0 for token and 32 for input 
203f			 
203f				 
203f			if DEBUG_FORTH_PARSE_KEY 
203f						DMARK "KY8" 
203f			endif 
203f			 
203f 80				add b			 
2040 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2042							; TODO need to make sure last word in zero term string is accounted for 
2042 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2044			 
2044			 
2044				; at end of both strings so both are exact match 
2044			 
2044			;       skip ptr for next word 
2044			 
2044 2a ae f9			ld hl,(cli_ptr) 	; at input string term 
2047 23				inc hl			 ; at next char 
2048 22 ae f9			ld (cli_ptr), hl     ; save for next round of the parser 
204b 22 ac f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
204e				 
204e				 
204e			if DEBUG_FORTH_PARSE_KEY 
204e						DMARK "KY3" 
204e			endif 
204e			 
204e			 
204e			 
204e			;       exec code block 
204e			if DEBUG_FORTH_JP 
204e				call clear_display 
204e				call update_display 
204e				call delay1s 
204e				ld hl, (cli_execword)     ; save for next check if no match on this word 
204e				ld a,h 
204e				ld hl, os_word_scratch 
204e				call hexout 
204e				ld hl, (cli_execword)     ; save for next check if no match on this word 
204e				ld a,l 
204e				ld hl, os_word_scratch+2 
204e				call hexout 
204e				ld hl, os_word_scratch+4 
204e				ld a,0 
204e				ld (hl),a 
204e				ld de,os_word_scratch 
204e				call str_at_display 
204e					ld a, display_row_2 
204e					call str_at_display 
204e				ld de, (cli_origtoken) 
204e				ld a, display_row_1+10 
204e					call str_at_display 
204e			 
204e				ld a,display_row_1 
204e				ld de, .foundword 
204e				ld a, display_row_3 
204e				call str_at_display 
204e				call update_display 
204e				call delay1s 
204e				call delay1s 
204e				call delay1s 
204e			endif 
204e			 
204e			if DEBUG_FORTH_PARSE_KEY 
204e						DMARK "KYj" 
204e			endif 
204e				; TODO save the word pointer in this exec 
204e			 
204e 2a b2 f9			ld hl,(cli_execword) 
2051 e9				jp (hl) 
2052			 
2052			 
2052			;    if not same 
2052			;	scan for zero term 
2052			;	get ptr for next word 
2052			;	goto word comp 
2052			 
2052			.execpnskipword:	; get pointer to next word 
2052 2a b0 f9			ld hl,(cli_nextword) 
2055			 
2055 7e				ld a,(hl) 
2056 fe 00			cp WORD_SYS_END 
2058			;	cp 0 
2058 28 09			jr z, .execendofdict			 ; at end of words 
205a			 
205a			if DEBUG_FORTH_PARSE_KEY 
205a						DMARK "KY4" 
205a			endif 
205a			if DEBUG_FORTH_PARSE_EXEC 
205a			 
205a				; see if disabled 
205a			 
205a				ld a, (os_view_disable) 
205a				cp '*' 
205a				jr z, .noskip 
205a			 
205a			 
205a				ld de, .nowordfound 
205a				ld a, display_row_3 
205a				call str_at_display 
205a				call update_display 
205a				ld a, 100 
205a				call aDelayInMS 
205a				 
205a				if DEBUG_FORTH_PARSE_EXEC_SLOW 
205a					call delay250ms 
205a				endif 
205a			.noskip:  
205a			 
205a			endif	 
205a			 
205a 2a ac f9			ld hl,(cli_origptr) 
205d 22 ae f9			ld (cli_ptr),hl 
2060			 
2060			if DEBUG_FORTH_PARSE_KEY 
2060						DMARK "KY5" 
2060			endif 
2060 c3 06 20			jp .execpnword			; else go to next word 
2063			 
2063			.execendofdict:  
2063			 
2063			if DEBUG_FORTH_PARSE_KEY 
2063						DMARK "KYe" 
2063			endif 
2063			if DEBUG_FORTH_PARSE_EXEC 
2063				; see if disabled 
2063			 
2063				ld a, (os_view_disable) 
2063				cp '*' 
2063				jr z, .ispskip 
2063			 
2063				call clear_display 
2063				call update_display 
2063				call delay1s 
2063				ld de, (cli_origptr) 
2063				ld a, display_row_1 
2063				call str_at_display 
2063				 
2063				ld de, .enddict 
2063				ld a, display_row_3 
2063				call str_at_display 
2063				call update_display 
2063				ld a, 100 
2063				call aDelayInMS 
2063				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2063				call delay1s 
2063				call delay1s 
2063				call delay1s 
2063				endif 
2063			.ispskip:  
2063				 
2063			endif	 
2063			 
2063			 
2063			 
2063				; if the word is not a keyword then must be a literal so push it to stack 
2063			 
2063			; push token to stack to end of word 
2063			 
2063				STACKFRAME ON $1efe $2f9f 
2063				if DEBUG_STACK_IMB 
2063					if ON 
2063						exx 
2063						ld de, $1efe 
2063						ld a, d 
2063						ld hl, curframe 
2063						call hexout 
2063						ld a, e 
2063						ld hl, curframe+2 
2063						call hexout 
2063						ld hl, $1efe 
2063						push hl 
2063						ld hl, $2f9f 
2063						push hl 
2063						exx 
2063					endif 
2063				endif 
2063			endm 
# End of macro STACKFRAME
2063			 
2063 2a a4 f2		ld hl,(os_tok_ptr) 
2066 cd 5b 1d		call forth_apush 
2069			 
2069				STACKFRAMECHK ON $1efe $2f9f 
2069				if DEBUG_STACK_IMB 
2069					if ON 
2069						exx 
2069						ld hl, $2f9f 
2069						pop de   ; $2f9f 
2069						call cmp16 
2069						jr nz, .spnosame 
2069						ld hl, $1efe 
2069						pop de   ; $1efe 
2069						call cmp16 
2069						jr z, .spfrsame 
2069						.spnosame: call showsperror 
2069						.spfrsame: nop 
2069						exx 
2069					endif 
2069				endif 
2069			endm 
# End of macro STACKFRAMECHK
2069			 
2069			execnext: 
2069			 
2069			if DEBUG_FORTH_PARSE_KEY 
2069						DMARK "KY>" 
2069			endif 
2069			; move past token to next word 
2069			 
2069 2a a4 f2		ld hl, (os_tok_ptr) 
206c 3e 00		ld a, 0 
206e 01 ff 00		ld bc, 255     ; input buffer size 
2071 ed b1		cpir 
2073			 
2073			if DEBUG_FORTH_PARSE_KEY 
2073						DMARK "KY!" 
2073				CALLMONITOR 
2073			endif	 
2073			; TODO this might place hl on the null, so will need to forward on??? 
2073			;inc hl   ; see if this gets onto the next item 
2073			 
2073			 
2073			; TODO pass a pointer to the buffer to push 
2073			; TODO call function to push 
2073			 
2073			; look for end of input 
2073			 
2073			;inc hl 
2073			;ld a,(hl) 
2073			;cp FORTH_END_BUFFER 
2073			;ret z 
2073			 
2073			 
2073 c3 ec 1f		jp exec1 
2076			 
2076			 
2076			 
2076			 
2076			 
2076			 
2076			 
2076			 
2076			 
2076			findnexttok: 
2076			 
2076				; hl is pointer to move 
2076				; de is the token to locate 
2076			 
2076					if DEBUG_FORTH 
2076						DMARK "NTK" 
2076						CALLMONITOR 
2076					endif 
2076 d5				push de 
2077			 
2077			.fnt1:	 
2077				; find first char of token to locate 
2077			 
2077 1a				ld a, (de) 
2078 4f				ld c,a 
2079 7e				ld a,(hl) 
207a cd 5b 11			call toUpper 
207d					if DEBUG_FORTH 
207d						DMARK "NT1" 
207d						CALLMONITOR 
207d					endif 
207d b9				cp c 
207e			 
207e 28 03			jr z, .fnt2cmpmorefirst	 
2080			 
2080				; first char not found move to next char 
2080			 
2080 23				inc hl 
2081 18 f4			jr .fnt1 
2083			 
2083			.fnt2cmpmorefirst:	 
2083				; first char of token found.  
2083			 
2083 e5				push hl     ; save start of token just in case it is the right one 
2084 d9				exx 
2085 e1				pop hl        ; save it to hl' 
2086 d9				exx 
2087			 
2087			 
2087			.fnt2cmpmore:	 
2087				; compare the rest 
2087				 
2087 23				inc hl 
2088 13				inc de 
2089				 
2089 1a				ld a, (de) 
208a 4f				ld c,a 
208b 7e				ld a,(hl) 
208c cd 5b 11			call toUpper 
208f			 
208f					if DEBUG_FORTH 
208f						DMARK "NT2" 
208f						CALLMONITOR 
208f					endif 
208f				; c has the token to find char 
208f				; a has the mem to scan char 
208f			 
208f b9				cp c 
2090 28 04			jr z,.fntmatch1 
2092			 
2092				; they are not the same 
2092			 
2092					if DEBUG_FORTH 
2092						DMARK "NT3" 
2092						CALLMONITOR 
2092					endif 
2092 d1				pop de	; reset de token to look for 
2093 d5				push de 
2094 18 e1			jr .fnt1 
2096				 
2096			.fntmatch1: 
2096			 
2096				; is the same char a null which means we might have a full hit? 
2096					if DEBUG_FORTH 
2096						DMARK "NT4" 
2096						CALLMONITOR 
2096					endif 
2096			 
2096 fe 00			cp 0 
2098 28 0b			jr z, .fntmatchyes 
209a			 
209a				; are we at the end of the token to find? 
209a			 
209a					if DEBUG_FORTH 
209a						DMARK "NT5" 
209a						CALLMONITOR 
209a					endif 
209a 3e 00			ld a, 0 
209c b9				cp c 
209d			 
209d c2 87 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
20a0			 
20a0					if DEBUG_FORTH 
20a0						DMARK "NT6" 
20a0						CALLMONITOR 
20a0					endif 
20a0				; token to find is exhusted but no match to stream 
20a0			 
20a0				; restore tok pointer and continue on 
20a0 d1				pop de 
20a1 d5				push de 
20a2 c3 77 20			jp .fnt1 
20a5			 
20a5			 
20a5			.fntmatchyes: 
20a5			 
20a5				; hl now contains the end of the found token 
20a5			 
20a5				; get rid of saved token pointer to find 
20a5			 
20a5 d1				pop de 
20a6			 
20a6					if DEBUG_FORTH 
20a6						DMARK "NT9" 
20a6						CALLMONITOR 
20a6					endif 
20a6			 
20a6				; hl will be on the null term so forward on 
20a6			 
20a6				; get back the saved start of the token 
20a6			 
20a6 d9				exx 
20a7 e5				push hl     ; save start of token just in case it is the right one 
20a8 d9				exx 
20a9 e1				pop hl        ; save it to hl 
20aa			 
20aa c9				ret 
20ab			 
20ab			 
20ab			; LIST needs to find a specific token   
20ab			; FORGET needs to find a spefici token 
20ab			 
20ab			; SAVE needs to find all tokens by flag 
20ab			; WORDS just needs to scan through all  by flag 
20ab			; UWORDS needs to scan through all by flag 
20ab			 
20ab			 
20ab			; given hl as pointer to start of dict look up string 
20ab			; return hl as pointer to start of word block 
20ab			; or 0 if not found 
20ab			 
20ab			forth_find_tok: 
20ab c9				ret 
20ac			 
20ac			; given hl as pointer to dict structure 
20ac			; move to the next dict block structure 
20ac			 
20ac			forth_tok_next: 
20ac				; hl now points to the address of the next word pointer  
20ac				; TODO skip compiled symbol for now 
20ac			;	push de 
20ac 23				inc hl 
20ad 5e				ld e, (hl) 
20ae 23				inc hl 
20af 56				ld d, (hl) 
20b0 23				inc hl 
20b1			 
20b1 eb				ex de,hl 
20b2			if DEBUG_FORTH_PARSE_NEXTWORD 
20b2				push bc 
20b2				ld bc, (cli_nextword) 
20b2						DMARK "NXW" 
20b2				CALLMONITOR 
20b2				pop bc 
20b2			endif 
20b2			;	pop de	 
20b2 c9				ret 
20b3			 
20b3			 
20b3			 
20b3			; eof 
# End of file forth_parserv5.asm
20b3				include "forth_wordsv4.asm" 
20b3			 
20b3			; the core word dictionary v4 
20b3			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
20b3			 
20b3			; this is a linked list for each of the system words used 
20b3			; user defined words will follow the same format but will be in ram 
20b3			 
20b3			 
20b3			; 
20b3			; 
20b3			; define linked list: 
20b3			; 
20b3			; 1. compiled byte op code 
20b3			; 2. len of text word 
20b3			; 3. text word 
20b3			; 4. ptr to next dictionary word 
20b3			; 5. asm, calls etc for the word 
20b3			; 
20b3			;  if 1 == 0 then last word in dict  
20b3			;   
20b3			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
20b3			;  
20b3			;  
20b3			; create basic standard set of words 
20b3			; 
20b3			;  
20b3			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
20b3			; 2DUP 2DROP 2SWAP  
20b3			; @ C@ - get byte  
20b3			; ! C! - store byte 
20b3			; 0< true if less than zero 
20b3			; 0= true if zero 
20b3			; < >  
20b3			; = true if same 
20b3			; variables 
20b3			 
20b3			 
20b3			; Hardware specific words I may need 
20b3			; 
20b3			; IN OUT  
20b3			; calls to key util functions 
20b3			; calls to hardward abstraction stuff 
20b3			; easy control of frame buffers and lcd i/o 
20b3			; keyboard  
20b3			 
20b3			 
20b3			;DICT: macro 
20b3			; op_code, len, word, next 
20b3			;    word: 
20b3			;    db op_code 
20b3			;    ds word zero term 
20b3			;    dw next 
20b3			;    endm 
20b3			 
20b3			 
20b3			 
20b3			 
20b3			; op code 1 is a flag for user define words which are to be handled differently 
20b3			 
20b3			 
20b3			; 
20b3			; 
20b3			;    TODO on entry to a word this should be the expected environment 
20b3			;    hl - tos value if number then held, if string this is the ptr 
20b3			;    de -  
20b3			 
20b3			 
20b3			; opcode ranges 
20b3			; 0 - end of word dict 
20b3			; 255 - user define words 
20b3			 
20b3			sysdict: 
20b3			include "forth_opcodes.asm" 
20b3			; op codes for forth keywords 
20b3			; free to use code 0  
20b3				OPCODE_HEAP: equ  1 
20b3				OPCODE_EXEC: equ 2 
20b3				OPCODE_DUP: equ 3 
20b3				OPCODE_SWAP: equ 4 
20b3				OPCODE_COLN: equ 5 
20b3				OPCODE_SCOLN: equ 6 
20b3				OPCODE_DROP: equ 7 
20b3				OPCODE_DUP2: equ 8 
20b3				OPCODE_DROP2: equ 9 
20b3				OPCODE_SWAP2: equ 10 
20b3				OPCODE_AT: equ 11 
20b3				OPCODE_CAT: equ 12 
20b3				OPCODE_BANG: equ 13 
20b3				OPCODE_CBANG: equ 14 
20b3				OPCODE_SCALL: equ 15 
20b3				OPCODE_DEPTH: equ 16 
20b3				OPCODE_OVER: equ 17 
20b3				OPCODE_PAUSE: equ 18 
20b3				OPCODE_PAUSES: equ 19 
20b3				OPCODE_ROT: equ 20 
20b3			;free to reuse	OPCODE_WORDS: equ 21 
20b3			        OPCODE_NOT: equ 21 
20b3				OPCODE_UWORDS: equ 22 
20b3				OPCODE_BP: equ 23 
20b3				OPCODE_MONITOR: equ 24  
20b3				OPCODE_MALLOC: equ 25 
20b3				OPCODE_FREE: equ 26 
20b3				OPCODE_LIST: equ 27 
20b3				OPCODE_FORGET: equ 28 
20b3				OPCODE_NOP: equ 29 
20b3				OPCODE_COMO: equ 30 
20b3				OPCODE_COMC: equ 31 
20b3			;free to reuse	OPCODE_ENDCORE: equ 32 
20b3				OPCODE_AFTERSOUND: equ 33 
20b3				OPCODE_GP2: equ 34 
20b3				OPCODE_GP3: equ 35 
20b3				OPCODE_GP4: equ 36 
20b3				OPCODE_SIN: equ 37 
20b3				OPCODE_SOUT: equ 38 
20b3				OPCODE_SPIO: equ 39 
20b3				OPCODE_SPICEH: equ 40 
20b3				OPCODE_SPIOb: equ 41 
20b3				OPCODE_SPII: equ 42 
20b3				OPCODE_SESEL: equ 43 
20b3				OPCODE_CARTDEV: equ 44 
20b3			; free to reuse	OPCODE_ENDDEVICE: equ 45 
20b3				OPCODE_FB: equ 46 
20b3				OPCODE_EMIT: equ 47 
20b3				OPCODE_DOTH: equ 48 
20b3				OPCODE_DOTF: equ 49 
20b3				OPCODE_DOT: equ 50 
20b3				OPCODE_CLS: equ 51 
20b3				OPCODE_DRAW: equ 52 
20b3				OPCODE_DUMP: equ 53 
20b3				OPCODE_CDUMP: equ 54 
20b3				OPCODE_DAT: equ 55 
20b3				OPCODE_HOME: equ 56 
20b3				OPCODE_SPACE: equ 57 
20b3				OPCODE_SPACES: equ 58 
20b3				OPCODE_SCROLL: equ 59 
20b3				OPCODE_ATQ: equ 60 
20b3				OPCODE_AUTODSP: equ 61 
20b3				OPCODE_MENU: equ 62 
20b3			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
20b3				OPCODE_THEN: equ 64 
20b3				OPCODE_ELSE: equ 65 
20b3				OPCODE_DO: equ 66 
20b3				OPCODE_LOOP: equ 67 
20b3				OPCODE_I: equ 68 
20b3				OPCODE_DLOOP: equ 69  
20b3				OPCODE_REPEAT: equ 70  
20b3				OPCODE_UNTIL: equ 71 
20b3				OPCODE_ENDFLOW: equ 72 
20b3				OPCODE_WAITK: equ 73 
20b3				OPCODE_ACCEPT: equ 74 
20b3				OPCODE_EDIT: equ 75 
20b3			;free to reuse	OPCODE_ENDKEY: equ 76 
20b3				OPCODE_LZERO: equ 77 
20b3				OPCODE_TZERO: equ 78 
20b3				OPCODE_LESS: equ 79 
20b3				OPCODE_GT: equ 80 
20b3				OPCODE_EQUAL: equ 81  
20b3			;free to reuse	OPCODE_ENDLOGIC: equ 82 
20b3				OPCODE_NEG: equ 83 
20b3				OPCODE_DIV: equ 84 
20b3				OPCODE_MUL: equ 85 
20b3				OPCODE_MIN: equ 86 
20b3				OPCODE_MAX: equ 87 
20b3				OPCODE_RND16: equ 88 
20b3				OPCODE_RND8: equ 89 
20b3				OPCODE_RND: equ 90 
20b3			;free to reuse	OPCODE_ENDMATHS: equ 91  
20b3				OPCODE_BYNAME: equ 92 
20b3				OPCODE_DIR: equ 93 
20b3				OPCODE_SAVE: equ 94 
20b3				OPCODE_LOAD: equ 95 
20b3				OPCODE_BSAVE: equ 96 
20b3				OPCODE_BLOAD: equ 97 
20b3				OPCODE_SEO: equ 98  
20b3				OPCODE_SEI: equ 99 
20b3				OPCODE_SFREE: equ 100 
20b3				OPCODE_SIZE: equ 101 
20b3				OPCODE_CREATE: equ 102 
20b3				OPCODE_APPEND: equ 103 
20b3				OPCODE_SDEL: equ 104 
20b3				OPCODE_OPEN: equ 105 
20b3				OPCODE_READ: equ 106 
20b3				OPCODE_EOF: equ 106 
20b3				OPCODE_FORMAT: equ 107 
20b3				OPCODE_LABEL: equ 108 
20b3				OPCODE_LABELS: equ 109 
20b3			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
20b3				OPCODE_UPPER: equ 111 
20b3				OPCODE_LOWER: equ 112 
20b3				OPCODE_SUBSTR: equ 113 
20b3				OPCODE_LEFT: equ 114 
20b3				OPCODE_RIGHT: equ 115 
20b3				OPCODE_STR2NUM: equ 116 
20b3				OPCODE_NUM2STR: equ 117 
20b3				OPCODE_CONCAT: equ 118 
20b3				OPCODE_FIND: equ 119 
20b3				OPCODE_LEN: equ 120 
20b3				OPCODE_CHAR: equ 121 
20b3			; free to reuse	OPCODE_STRLEN: equ 122 
20b3			; free to reuse	OPCODE_ENDSTR: equ 123 
20b3				OPCODE_V0S: equ 124 
20b3				OPCODE_V0Q: equ 125 
20b3				OPCODE_V1S: equ 126 
20b3				OPCODE_V1Q: equ 127 
20b3				OPCODE_V2S: equ 128 
20b3				OPCODE_V2Q: equ 129 
20b3				OPCODE_V3S: equ 130 
20b3				OPCODE_V3Q: equ 131 
20b3			;free to reuse	OPCODE_END: equ 132 
20b3				OPCODE_ZDUP: equ 133 
20b3			 
20b3			; eof 
# End of file forth_opcodes.asm
20b3			 
20b3			include "forth_words_core.asm" 
20b3			 
20b3			; | ## Core Words 
20b3			 
20b3			;if MALLOC_4 
20b3			 
20b3			.HEAP: 
20b3				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
20b3 15				db WORD_SYS_CORE+OPCODE_HEAP             
20b4 f2 20			dw .EXEC            
20b6 05				db 4 + 1 
20b7 .. 00			db "HEAP",0              
20bc				endm 
# End of macro CWHEAD
20bc			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
20bc			; | | u1 - Current number of bytes in the heap 
20bc			; | | u2 - Remaining bytes left on the heap 
20bc			; | |  
20bc			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
20bc			 
20bc			 
20bc					if DEBUG_FORTH_WORDS_KEY 
20bc						DMARK "HEP" 
20bc f5				push af  
20bd 3a d1 20			ld a, (.dmark)  
20c0 32 bd fb			ld (debug_mark),a  
20c3 3a d2 20			ld a, (.dmark+1)  
20c6 32 be fb			ld (debug_mark+1),a  
20c9 3a d3 20			ld a, (.dmark+2)  
20cc 32 bf fb			ld (debug_mark+2),a  
20cf 18 03			jr .pastdmark  
20d1 ..			.dmark: db "HEP"  
20d4 f1			.pastdmark: pop af  
20d5			endm  
# End of macro DMARK
20d5						CALLMONITOR 
20d5 cd 65 16			call break_point_state  
20d8				endm  
# End of macro CALLMONITOR
20d8					endif 
20d8 2a 0a 80				ld hl, (free_list )      
20db 11 0e 80				ld de, heap_start 
20de			 
20de ed 52				sbc hl, de  
20e0			 
20e0 cd f2 1b				call forth_push_numhl 
20e3			 
20e3			 
20e3 ed 5b 0a 80			ld de, (free_list )      
20e7 21 89 ef				ld hl, heap_end 
20ea			 
20ea ed 52				sbc hl, de 
20ec			 
20ec cd f2 1b				call forth_push_numhl 
20ef					 
20ef			 
20ef					 
20ef			 
20ef			 
20ef			 
20ef					NEXTW 
20ef c3 5b 1f			jp macro_next 
20f2				endm 
# End of macro NEXTW
20f2			;endif 
20f2			 
20f2			.EXEC: 
20f2				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
20f2 16				db WORD_SYS_CORE+OPCODE_EXEC             
20f3 8e 21			dw .STKEXEC            
20f5 05				db 4 + 1 
20f6 .. 00			db "EXEC",0              
20fb				endm 
# End of macro CWHEAD
20fb			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
20fb			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
20fb			; | | 
20fb			; | |   
20fb				STACKFRAME OFF $5efe $5f9f 
20fb				if DEBUG_STACK_IMB 
20fb					if OFF 
20fb						exx 
20fb						ld de, $5efe 
20fb						ld a, d 
20fb						ld hl, curframe 
20fb						call hexout 
20fb						ld a, e 
20fb						ld hl, curframe+2 
20fb						call hexout 
20fb						ld hl, $5efe 
20fb						push hl 
20fb						ld hl, $5f9f 
20fb						push hl 
20fb						exx 
20fb					endif 
20fb				endif 
20fb			endm 
# End of macro STACKFRAME
20fb			 
20fb					if DEBUG_FORTH_WORDS_KEY 
20fb						DMARK "EXE" 
20fb f5				push af  
20fc 3a 10 21			ld a, (.dmark)  
20ff 32 bd fb			ld (debug_mark),a  
2102 3a 11 21			ld a, (.dmark+1)  
2105 32 be fb			ld (debug_mark+1),a  
2108 3a 12 21			ld a, (.dmark+2)  
210b 32 bf fb			ld (debug_mark+2),a  
210e 18 03			jr .pastdmark  
2110 ..			.dmark: db "EXE"  
2113 f1			.pastdmark: pop af  
2114			endm  
# End of macro DMARK
2114						CALLMONITOR 
2114 cd 65 16			call break_point_state  
2117				endm  
# End of macro CALLMONITOR
2117					endif 
2117			 
2117				FORTH_DSP_VALUEHL 
2117 cd e9 1d			call macro_dsp_valuehl 
211a				endm 
# End of macro FORTH_DSP_VALUEHL
211a			 
211a				FORTH_DSP_POP 
211a cd a1 1e			call macro_forth_dsp_pop 
211d				endm 
# End of macro FORTH_DSP_POP
211d			 
211d					if DEBUG_FORTH_WORDS 
211d						DMARK "EX1" 
211d f5				push af  
211e 3a 32 21			ld a, (.dmark)  
2121 32 bd fb			ld (debug_mark),a  
2124 3a 33 21			ld a, (.dmark+1)  
2127 32 be fb			ld (debug_mark+1),a  
212a 3a 34 21			ld a, (.dmark+2)  
212d 32 bf fb			ld (debug_mark+2),a  
2130 18 03			jr .pastdmark  
2132 ..			.dmark: db "EX1"  
2135 f1			.pastdmark: pop af  
2136			endm  
# End of macro DMARK
2136						CALLMONITOR 
2136 cd 65 16			call break_point_state  
2139				endm  
# End of macro CALLMONITOR
2139					endif 
2139			;	ld e,(hl) 
2139			;	inc hl 
2139			;	ld d,(hl) 
2139			;	ex de,hl 
2139			 
2139			;		if DEBUG_FORTH_WORDS 
2139			;			DMARK "EX2" 
2139			;			CALLMONITOR 
2139			;		endif 
2139 e5				push hl 
213a			 
213a				;ld a, 0 
213a				;ld a, FORTH_END_BUFFER 
213a cd 64 11			call strlenz 
213d 23				inc hl   ; include zero term to copy 
213e 23				inc hl   ; include term 
213f 23				inc hl   ; include term 
2140 06 00			ld b,0 
2142 4d				ld c,l 
2143 e1				pop hl 
2144 11 a2 f0			ld de, execscratch 
2147					if DEBUG_FORTH_WORDS 
2147						DMARK "EX3" 
2147 f5				push af  
2148 3a 5c 21			ld a, (.dmark)  
214b 32 bd fb			ld (debug_mark),a  
214e 3a 5d 21			ld a, (.dmark+1)  
2151 32 be fb			ld (debug_mark+1),a  
2154 3a 5e 21			ld a, (.dmark+2)  
2157 32 bf fb			ld (debug_mark+2),a  
215a 18 03			jr .pastdmark  
215c ..			.dmark: db "EX3"  
215f f1			.pastdmark: pop af  
2160			endm  
# End of macro DMARK
2160						CALLMONITOR 
2160 cd 65 16			call break_point_state  
2163				endm  
# End of macro CALLMONITOR
2163					endif 
2163 ed b0			ldir 
2165			 
2165			 
2165 21 a2 f0			ld hl, execscratch 
2168			 
2168					if DEBUG_FORTH_WORDS 
2168						DMARK "EXe" 
2168 f5				push af  
2169 3a 7d 21			ld a, (.dmark)  
216c 32 bd fb			ld (debug_mark),a  
216f 3a 7e 21			ld a, (.dmark+1)  
2172 32 be fb			ld (debug_mark+1),a  
2175 3a 7f 21			ld a, (.dmark+2)  
2178 32 bf fb			ld (debug_mark+2),a  
217b 18 03			jr .pastdmark  
217d ..			.dmark: db "EXe"  
2180 f1			.pastdmark: pop af  
2181			endm  
# End of macro DMARK
2181						CALLMONITOR 
2181 cd 65 16			call break_point_state  
2184				endm  
# End of macro CALLMONITOR
2184					endif 
2184			 
2184 cd a9 1f			call forthparse 
2187 cd e9 1f			call forthexec 
218a			;	call forthexec_cleanup 
218a			;	call forthparse 
218a			;	call forthexec 
218a			 
218a				STACKFRAMECHK OFF $5efe $5f9f 
218a				if DEBUG_STACK_IMB 
218a					if OFF 
218a						exx 
218a						ld hl, $5f9f 
218a						pop de   ; $5f9f 
218a						call cmp16 
218a						jr nz, .spnosame 
218a						ld hl, $5efe 
218a						pop de   ; $5efe 
218a						call cmp16 
218a						jr z, .spfrsame 
218a						.spnosame: call showsperror 
218a						.spfrsame: nop 
218a						exx 
218a					endif 
218a				endif 
218a			endm 
# End of macro STACKFRAMECHK
218a			 
218a				; an immediate word so no need to process any more words 
218a c9				ret 
218b				NEXTW 
218b c3 5b 1f			jp macro_next 
218e				endm 
# End of macro NEXTW
218e			 
218e			; dead code - old version  
218e			;	FORTH_RSP_NEXT 
218e			 
218e			;  
218e			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
218e			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
218e			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
218e			;	push hl 
218e			;	push de 
218e			;	push bc 
218e			; 
218e			; 
218e			;		if DEBUG_FORTH_WORDS_KEY 
218e			;			DMARK "EXR" 
218e			;			CALLMONITOR 
218e			;		endif 
218e			; 
218e			; 
218e			; 
218e			;	;v5 FORTH_DSP_VALUE 
218e			;	FORTH_DSP_VALUEHL 
218e			; 
218e			;	; TODO do string type checks 
218e			; 
218e			;;v5	inc hl   ; skip type 
218e			; 
218e			;	push hl  ; source code  
218e			;		if DEBUG_FORTH_WORDS 
218e			;			DMARK "EX1" 
218e			;			CALLMONITOR 
218e			;		endif 
218e			;	ld a, 0 
218e			;	call strlent 
218e			; 
218e			;	inc hl 
218e			;	inc hl 
218e			;	inc hl 
218e			;	inc hl 
218e			; 
218e			;	push hl    ; size 
218e			; 
218e			;		if DEBUG_FORTH_WORDS 
218e			;			DMARK "EX2" 
218e			;			CALLMONITOR 
218e			;		endif 
218e			;	call malloc 
218e			; 
218e			;	ex de, hl    ; de now contains malloc area 
218e			;	pop bc   	; get byte count 
218e			;	pop hl      ; get string to copy 
218e			; 
218e			;	push de     ; save malloc for free later 
218e			; 
218e			;		if DEBUG_FORTH_WORDS 
218e			;			DMARK "EX3" 
218e			;			CALLMONITOR 
218e			;		endif 
218e			;	ldir       ; duplicate string 
218e			; 
218e			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
218e			;	 
218e			;	; TODO fix the parse would be better than this...  
218e			;	ex de, hl 
218e			;	dec hl 
218e			;	ld a, 0 
218e			;	ld (hl), a 
218e			;	dec hl 
218e			;	ld a, ' ' 
218e			;	ld (hl), a 
218e			;	dec hl 
218e			;	ld (hl), a 
218e			; 
218e			;	dec hl 
218e			;	ld (hl), a 
218e			; 
218e			; 
218e			;	FORTH_DSP_POP  
218e			; 
218e			;	pop hl     
218e			;	push hl    ; save malloc area 
218e			; 
218e			;		if DEBUG_FORTH_WORDS 
218e			;			DMARK "EX4" 
218e			;			CALLMONITOR 
218e			;		endif 
218e			; 
218e			;	call forthparse 
218e			;	call forthexec 
218e			;	 
218e			;	pop hl 
218e			;	if DEBUG_FORTH_WORDS 
218e			;		DMARK "EX5" 
218e			;		CALLMONITOR 
218e			;	endif 
218e			; 
218e			;	if FORTH_ENABLE_FREE 
218e			;	call free 
218e			;	endif 
218e			; 
218e			;	if DEBUG_FORTH_WORDS 
218e			;		DMARK "EX6" 
218e			;		CALLMONITOR 
218e			;	endif 
218e			; 
218e			;	pop bc 
218e			;	pop de 
218e			;	pop hl 
218e			;;	FORTH_RSP_POP	  
218e			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
218e			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
218e			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
218e			; 
218e			;	if DEBUG_FORTH_WORDS 
218e			;		DMARK "EX7" 
218e			;		CALLMONITOR 
218e			;	endif 
218e			;	NEXTW 
218e			 
218e			.STKEXEC: 
218e				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
218e 3f				db WORD_SYS_CORE+43             
218f d6 22			dw .ZDUP            
2191 08				db 7 + 1 
2192 .. 00			db "STKEXEC",0              
219a				endm 
# End of macro CWHEAD
219a			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
219a			 
219a			 
219a					if DEBUG_FORTH_WORDS_KEY 
219a						DMARK "STX" 
219a f5				push af  
219b 3a af 21			ld a, (.dmark)  
219e 32 bd fb			ld (debug_mark),a  
21a1 3a b0 21			ld a, (.dmark+1)  
21a4 32 be fb			ld (debug_mark+1),a  
21a7 3a b1 21			ld a, (.dmark+2)  
21aa 32 bf fb			ld (debug_mark+2),a  
21ad 18 03			jr .pastdmark  
21af ..			.dmark: db "STX"  
21b2 f1			.pastdmark: pop af  
21b3			endm  
# End of macro DMARK
21b3						CALLMONITOR 
21b3 cd 65 16			call break_point_state  
21b6				endm  
# End of macro CALLMONITOR
21b6					endif 
21b6			 
21b6				FORTH_DSP_VALUEHL 
21b6 cd e9 1d			call macro_dsp_valuehl 
21b9				endm 
# End of macro FORTH_DSP_VALUEHL
21b9			 
21b9 22 e6 f9			ld (store_tmp1), hl    ; count 
21bc			 
21bc				FORTH_DSP_POP 
21bc cd a1 1e			call macro_forth_dsp_pop 
21bf				endm 
# End of macro FORTH_DSP_POP
21bf			.stkexec1: 
21bf 2a e6 f9			ld hl, (store_tmp1)   ; count 
21c2 3e 00			ld a, 0 
21c4 bd				cp l 
21c5 c8				ret z 
21c6			 
21c6 2b				dec hl 
21c7 22 e6 f9			ld (store_tmp1), hl    ; count 
21ca				 
21ca				FORTH_DSP_VALUEHL 
21ca cd e9 1d			call macro_dsp_valuehl 
21cd				endm 
# End of macro FORTH_DSP_VALUEHL
21cd e5				push hl 
21ce				 
21ce					if DEBUG_FORTH_WORDS 
21ce						DMARK "EXp" 
21ce f5				push af  
21cf 3a e3 21			ld a, (.dmark)  
21d2 32 bd fb			ld (debug_mark),a  
21d5 3a e4 21			ld a, (.dmark+1)  
21d8 32 be fb			ld (debug_mark+1),a  
21db 3a e5 21			ld a, (.dmark+2)  
21de 32 bf fb			ld (debug_mark+2),a  
21e1 18 03			jr .pastdmark  
21e3 ..			.dmark: db "EXp"  
21e6 f1			.pastdmark: pop af  
21e7			endm  
# End of macro DMARK
21e7						CALLMONITOR 
21e7 cd 65 16			call break_point_state  
21ea				endm  
# End of macro CALLMONITOR
21ea					endif 
21ea				FORTH_DSP_POP 
21ea cd a1 1e			call macro_forth_dsp_pop 
21ed				endm 
# End of macro FORTH_DSP_POP
21ed			 
21ed cd 64 11			call strlenz 
21f0 23				inc hl   ; include zero term to copy 
21f1 23				inc hl   ; include zero term to copy 
21f2 23				inc hl   ; include zero term to copy 
21f3 06 00			ld b,0 
21f5 4d				ld c,l 
21f6 e1				pop hl 
21f7 11 a2 f0			ld de, execscratch 
21fa					if DEBUG_FORTH_WORDS 
21fa						DMARK "EX3" 
21fa f5				push af  
21fb 3a 0f 22			ld a, (.dmark)  
21fe 32 bd fb			ld (debug_mark),a  
2201 3a 10 22			ld a, (.dmark+1)  
2204 32 be fb			ld (debug_mark+1),a  
2207 3a 11 22			ld a, (.dmark+2)  
220a 32 bf fb			ld (debug_mark+2),a  
220d 18 03			jr .pastdmark  
220f ..			.dmark: db "EX3"  
2212 f1			.pastdmark: pop af  
2213			endm  
# End of macro DMARK
2213						CALLMONITOR 
2213 cd 65 16			call break_point_state  
2216				endm  
# End of macro CALLMONITOR
2216					endif 
2216 ed b0			ldir 
2218			 
2218			 
2218 21 a2 f0			ld hl, execscratch 
221b			 
221b					if DEBUG_FORTH_WORDS 
221b						DMARK "EXP" 
221b f5				push af  
221c 3a 30 22			ld a, (.dmark)  
221f 32 bd fb			ld (debug_mark),a  
2222 3a 31 22			ld a, (.dmark+1)  
2225 32 be fb			ld (debug_mark+1),a  
2228 3a 32 22			ld a, (.dmark+2)  
222b 32 bf fb			ld (debug_mark+2),a  
222e 18 03			jr .pastdmark  
2230 ..			.dmark: db "EXP"  
2233 f1			.pastdmark: pop af  
2234			endm  
# End of macro DMARK
2234						CALLMONITOR 
2234 cd 65 16			call break_point_state  
2237				endm  
# End of macro CALLMONITOR
2237					endif 
2237			 
2237 cd a9 1f			call forthparse 
223a 21 a2 f0			ld hl, execscratch 
223d					if DEBUG_FORTH_WORDS 
223d						DMARK "EXx" 
223d f5				push af  
223e 3a 52 22			ld a, (.dmark)  
2241 32 bd fb			ld (debug_mark),a  
2244 3a 53 22			ld a, (.dmark+1)  
2247 32 be fb			ld (debug_mark+1),a  
224a 3a 54 22			ld a, (.dmark+2)  
224d 32 bf fb			ld (debug_mark+2),a  
2250 18 03			jr .pastdmark  
2252 ..			.dmark: db "EXx"  
2255 f1			.pastdmark: pop af  
2256			endm  
# End of macro DMARK
2256						CALLMONITOR 
2256 cd 65 16			call break_point_state  
2259				endm  
# End of macro CALLMONITOR
2259					endif 
2259 cd e9 1f			call forthexec 
225c			 
225c c3 bf 21			jp .stkexec1 
225f			 
225f c9				ret 
2260			 
2260			 
2260			.DUP: 
2260				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2260 17				db WORD_SYS_CORE+OPCODE_DUP             
2261 d6 22			dw .ZDUP            
2263 04				db 3 + 1 
2264 .. 00			db "DUP",0              
2268				endm 
# End of macro CWHEAD
2268			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2268			 
2268					if DEBUG_FORTH_WORDS_KEY 
2268						DMARK "DUP" 
2268 f5				push af  
2269 3a 7d 22			ld a, (.dmark)  
226c 32 bd fb			ld (debug_mark),a  
226f 3a 7e 22			ld a, (.dmark+1)  
2272 32 be fb			ld (debug_mark+1),a  
2275 3a 7f 22			ld a, (.dmark+2)  
2278 32 bf fb			ld (debug_mark+2),a  
227b 18 03			jr .pastdmark  
227d ..			.dmark: db "DUP"  
2280 f1			.pastdmark: pop af  
2281			endm  
# End of macro DMARK
2281						CALLMONITOR 
2281 cd 65 16			call break_point_state  
2284				endm  
# End of macro CALLMONITOR
2284					endif 
2284			 
2284					FORTH_DSP 
2284 cd af 1d			call macro_forth_dsp 
2287				endm 
# End of macro FORTH_DSP
2287			 
2287 7e					ld a, (HL) 
2288 fe 01				cp DS_TYPE_STR 
228a 20 25				jr nz, .dupinum 
228c			 
228c					; push another string 
228c			 
228c					FORTH_DSP_VALUEHL     		 
228c cd e9 1d			call macro_dsp_valuehl 
228f				endm 
# End of macro FORTH_DSP_VALUEHL
228f			 
228f				if DEBUG_FORTH_WORDS 
228f					DMARK "DUs" 
228f f5				push af  
2290 3a a4 22			ld a, (.dmark)  
2293 32 bd fb			ld (debug_mark),a  
2296 3a a5 22			ld a, (.dmark+1)  
2299 32 be fb			ld (debug_mark+1),a  
229c 3a a6 22			ld a, (.dmark+2)  
229f 32 bf fb			ld (debug_mark+2),a  
22a2 18 03			jr .pastdmark  
22a4 ..			.dmark: db "DUs"  
22a7 f1			.pastdmark: pop af  
22a8			endm  
# End of macro DMARK
22a8					CALLMONITOR 
22a8 cd 65 16			call break_point_state  
22ab				endm  
# End of macro CALLMONITOR
22ab				endif 
22ab cd 60 1c				call forth_push_str 
22ae			 
22ae					NEXTW 
22ae c3 5b 1f			jp macro_next 
22b1				endm 
# End of macro NEXTW
22b1			 
22b1			 
22b1			.dupinum: 
22b1					 
22b1			 
22b1			 
22b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22b1 cd e9 1d			call macro_dsp_valuehl 
22b4				endm 
# End of macro FORTH_DSP_VALUEHL
22b4			 
22b4				; TODO add floating point number detection 
22b4			 
22b4				if DEBUG_FORTH_WORDS 
22b4					DMARK "DUi" 
22b4 f5				push af  
22b5 3a c9 22			ld a, (.dmark)  
22b8 32 bd fb			ld (debug_mark),a  
22bb 3a ca 22			ld a, (.dmark+1)  
22be 32 be fb			ld (debug_mark+1),a  
22c1 3a cb 22			ld a, (.dmark+2)  
22c4 32 bf fb			ld (debug_mark+2),a  
22c7 18 03			jr .pastdmark  
22c9 ..			.dmark: db "DUi"  
22cc f1			.pastdmark: pop af  
22cd			endm  
# End of macro DMARK
22cd					CALLMONITOR 
22cd cd 65 16			call break_point_state  
22d0				endm  
# End of macro CALLMONITOR
22d0				endif 
22d0			 
22d0 cd f2 1b				call forth_push_numhl 
22d3					NEXTW 
22d3 c3 5b 1f			jp macro_next 
22d6				endm 
# End of macro NEXTW
22d6			.ZDUP: 
22d6				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
22d6 99				db WORD_SYS_CORE+OPCODE_ZDUP             
22d7 0e 23			dw .SWAP            
22d9 05				db 4 + 1 
22da .. 00			db "?DUP",0              
22df				endm 
# End of macro CWHEAD
22df			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
22df			 
22df					if DEBUG_FORTH_WORDS_KEY 
22df						DMARK "qDU" 
22df f5				push af  
22e0 3a f4 22			ld a, (.dmark)  
22e3 32 bd fb			ld (debug_mark),a  
22e6 3a f5 22			ld a, (.dmark+1)  
22e9 32 be fb			ld (debug_mark+1),a  
22ec 3a f6 22			ld a, (.dmark+2)  
22ef 32 bf fb			ld (debug_mark+2),a  
22f2 18 03			jr .pastdmark  
22f4 ..			.dmark: db "qDU"  
22f7 f1			.pastdmark: pop af  
22f8			endm  
# End of macro DMARK
22f8						CALLMONITOR 
22f8 cd 65 16			call break_point_state  
22fb				endm  
# End of macro CALLMONITOR
22fb					endif 
22fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22fb cd e9 1d			call macro_dsp_valuehl 
22fe				endm 
# End of macro FORTH_DSP_VALUEHL
22fe			 
22fe e5					push hl 
22ff			 
22ff					; is it a zero? 
22ff			 
22ff 3e 00				ld a, 0 
2301 84					add h 
2302 85					add l 
2303			 
2303 e1					pop hl 
2304			 
2304 fe 00				cp 0 
2306 28 03				jr z, .dup2orig 
2308			 
2308			 
2308 cd f2 1b				call forth_push_numhl 
230b			 
230b			 
230b				; TODO add floating point number detection 
230b			 
230b			.dup2orig: 
230b			 
230b					NEXTW 
230b c3 5b 1f			jp macro_next 
230e				endm 
# End of macro NEXTW
230e			.SWAP: 
230e				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
230e 18				db WORD_SYS_CORE+OPCODE_SWAP             
230f 4d 23			dw .COLN            
2311 05				db 4 + 1 
2312 .. 00			db "SWAP",0              
2317				endm 
# End of macro CWHEAD
2317			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2317					if DEBUG_FORTH_WORDS_KEY 
2317						DMARK "SWP" 
2317 f5				push af  
2318 3a 2c 23			ld a, (.dmark)  
231b 32 bd fb			ld (debug_mark),a  
231e 3a 2d 23			ld a, (.dmark+1)  
2321 32 be fb			ld (debug_mark+1),a  
2324 3a 2e 23			ld a, (.dmark+2)  
2327 32 bf fb			ld (debug_mark+2),a  
232a 18 03			jr .pastdmark  
232c ..			.dmark: db "SWP"  
232f f1			.pastdmark: pop af  
2330			endm  
# End of macro DMARK
2330						CALLMONITOR 
2330 cd 65 16			call break_point_state  
2333				endm  
# End of macro CALLMONITOR
2333					endif 
2333			 
2333					FORTH_DSP_VALUEHL 
2333 cd e9 1d			call macro_dsp_valuehl 
2336				endm 
# End of macro FORTH_DSP_VALUEHL
2336 e5					push hl     ; w2 
2337			 
2337					FORTH_DSP_POP 
2337 cd a1 1e			call macro_forth_dsp_pop 
233a				endm 
# End of macro FORTH_DSP_POP
233a			 
233a					FORTH_DSP_VALUEHL 
233a cd e9 1d			call macro_dsp_valuehl 
233d				endm 
# End of macro FORTH_DSP_VALUEHL
233d			 
233d					FORTH_DSP_POP 
233d cd a1 1e			call macro_forth_dsp_pop 
2340				endm 
# End of macro FORTH_DSP_POP
2340			 
2340 d1					pop de     ; w2	, hl = w1 
2341			 
2341 eb					ex de, hl 
2342 d5					push de 
2343			 
2343 cd f2 1b				call forth_push_numhl 
2346			 
2346 e1					pop hl 
2347			 
2347 cd f2 1b				call forth_push_numhl 
234a					 
234a			 
234a					NEXTW 
234a c3 5b 1f			jp macro_next 
234d				endm 
# End of macro NEXTW
234d			.COLN: 
234d				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
234d 19				db WORD_SYS_CORE+OPCODE_COLN             
234e d9 24			dw .SCOLN            
2350 02				db 1 + 1 
2351 .. 00			db ":",0              
2353				endm 
# End of macro CWHEAD
2353			; | : ( -- )         Create new word | DONE 
2353			 
2353					if DEBUG_FORTH_WORDS_KEY 
2353						DMARK "CLN" 
2353 f5				push af  
2354 3a 68 23			ld a, (.dmark)  
2357 32 bd fb			ld (debug_mark),a  
235a 3a 69 23			ld a, (.dmark+1)  
235d 32 be fb			ld (debug_mark+1),a  
2360 3a 6a 23			ld a, (.dmark+2)  
2363 32 bf fb			ld (debug_mark+2),a  
2366 18 03			jr .pastdmark  
2368 ..			.dmark: db "CLN"  
236b f1			.pastdmark: pop af  
236c			endm  
# End of macro DMARK
236c						CALLMONITOR 
236c cd 65 16			call break_point_state  
236f				endm  
# End of macro CALLMONITOR
236f					endif 
236f				STACKFRAME OFF $8efe $989f 
236f				if DEBUG_STACK_IMB 
236f					if OFF 
236f						exx 
236f						ld de, $8efe 
236f						ld a, d 
236f						ld hl, curframe 
236f						call hexout 
236f						ld a, e 
236f						ld hl, curframe+2 
236f						call hexout 
236f						ld hl, $8efe 
236f						push hl 
236f						ld hl, $989f 
236f						push hl 
236f						exx 
236f					endif 
236f				endif 
236f			endm 
# End of macro STACKFRAME
236f				; get parser buffer length  of new word 
236f			 
236f				 
236f			 
236f					; move tok past this to start of name defintition 
236f					; TODO get word to define 
236f					; TODO Move past word token 
236f					; TODO get length of string up to the ';' 
236f			 
236f 2a a4 f2			ld hl, (os_tok_ptr) 
2372 23				inc hl 
2373 23				inc hl 
2374			 
2374 3e 3b			ld a, ';' 
2376 cd 6f 11			call strlent 
2379			 
2379 7d				ld a,l 
237a 32 9f ef			ld (os_new_parse_len), a 
237d			 
237d			 
237d			if DEBUG_FORTH_UWORD 
237d ed 5b a4 f2		ld de, (os_tok_ptr) 
2381						DMARK ":01" 
2381 f5				push af  
2382 3a 96 23			ld a, (.dmark)  
2385 32 bd fb			ld (debug_mark),a  
2388 3a 97 23			ld a, (.dmark+1)  
238b 32 be fb			ld (debug_mark+1),a  
238e 3a 98 23			ld a, (.dmark+2)  
2391 32 bf fb			ld (debug_mark+2),a  
2394 18 03			jr .pastdmark  
2396 ..			.dmark: db ":01"  
2399 f1			.pastdmark: pop af  
239a			endm  
# End of macro DMARK
239a				CALLMONITOR 
239a cd 65 16			call break_point_state  
239d				endm  
# End of macro CALLMONITOR
239d			endif 
239d			 
239d			; 
239d			;  new word memory layout: 
239d			;  
239d			;    : adg 6666 ;  
239d			; 
239d			;    db   1     ; user defined word  
239d 23				inc hl    
239e			;    dw   sysdict 
239e 23				inc hl 
239f 23				inc hl 
23a0			;    db <word len>+1 (for null) 
23a0 23				inc hl 
23a1			;    db .... <word> 
23a1			; 
23a1			 
23a1 23				inc hl    ; some extras for the word preamble before the above 
23a2 23				inc hl 
23a3 23				inc hl 
23a4 23				inc hl 
23a5 23				inc hl 
23a6 23				inc hl 
23a7 23				inc hl  
23a8 23				inc hl 
23a9 23				inc hl 
23aa 23				inc hl 
23ab 23				inc hl 
23ac 23				inc hl 
23ad 23				inc hl 
23ae 23				inc hl     ; TODO how many do we really need?     maybe only 6 
23af			;       exec word buffer 
23af			;	<ptr word>   
23af 23				inc hl 
23b0 23				inc hl 
23b1			;       <word list><null term> 7F final term 
23b1			 
23b1			 
23b1			if DEBUG_FORTH_UWORD 
23b1						DMARK ":02" 
23b1 f5				push af  
23b2 3a c6 23			ld a, (.dmark)  
23b5 32 bd fb			ld (debug_mark),a  
23b8 3a c7 23			ld a, (.dmark+1)  
23bb 32 be fb			ld (debug_mark+1),a  
23be 3a c8 23			ld a, (.dmark+2)  
23c1 32 bf fb			ld (debug_mark+2),a  
23c4 18 03			jr .pastdmark  
23c6 ..			.dmark: db ":02"  
23c9 f1			.pastdmark: pop af  
23ca			endm  
# End of macro DMARK
23ca				CALLMONITOR 
23ca cd 65 16			call break_point_state  
23cd				endm  
# End of macro CALLMONITOR
23cd			endif 
23cd			 
23cd				 
23cd					; malloc the size 
23cd			 
23cd cd cd 11				call malloc 
23d0 22 a1 ef				ld (os_new_malloc), hl     ; save malloc start 
23d3			 
23d3			;    db   1     ; user defined word  
23d3 3e 01				ld a, WORD_SYS_UWORD  
23d5 77					ld (hl), a 
23d6				 
23d6 23				inc hl    
23d7			;    dw   sysdict 
23d7 11 b3 20			ld de, sysdict       ; continue on with the scan to the system dict 
23da 73				ld (hl), e 
23db 23				inc hl 
23dc 72				ld (hl), d 
23dd 23				inc hl 
23de			 
23de			 
23de			;    Setup dict word 
23de			 
23de 23				inc hl 
23df 22 9b ef			ld (os_new_work_ptr), hl     ; save start of dict word  
23e2			 
23e2				; 1. get length of dict word 
23e2			 
23e2			 
23e2 2a a4 f2			ld hl, (os_tok_ptr) 
23e5 23				inc hl 
23e6 23				inc hl    ; position to start of dict word 
23e7 3e 00			ld a, 0 
23e9 cd 6f 11			call strlent 
23ec			 
23ec			 
23ec 23				inc hl    ; to include null??? 
23ed			 
23ed				; write length of dict word 
23ed			 
23ed ed 5b 9b ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
23f1 1b				dec de 
23f2 eb				ex de, hl 
23f3 73				ld (hl), e 
23f4 eb				ex de, hl 
23f5			 
23f5				 
23f5			 
23f5				; copy  
23f5 4d				ld c, l 
23f6 06 00			ld b, 0 
23f8 ed 5b 9b ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
23fc 2a a4 f2			ld hl, (os_tok_ptr) 
23ff 23				inc hl 
2400 23				inc hl    ; position to start of dict word 
2401				 
2401			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2401				 
2401				; TODO need to convert word to upper case 
2401			 
2401			ucasetok:	 
2401 7e				ld a,(hl) 
2402 cd 5b 11			call toUpper 
2405 77				ld (hl),a 
2406 ed a0			ldi 
2408 f2 01 24		 	jp p, ucasetok 
240b			 
240b			 
240b			 
240b				; de now points to start of where the word body code should be placed 
240b ed 53 9b ef		ld (os_new_work_ptr), de 
240f				; hl now points to the words to throw at forthexec which needs to be copied 
240f 22 99 ef			ld (os_new_src_ptr), hl 
2412			 
2412				; TODO add 'call to forthexec' 
2412			 
2412			if DEBUG_FORTH_UWORD 
2412 c5				push bc 
2413 ed 4b a1 ef		ld bc, (os_new_malloc) 
2417						DMARK ":0x" 
2417 f5				push af  
2418 3a 2c 24			ld a, (.dmark)  
241b 32 bd fb			ld (debug_mark),a  
241e 3a 2d 24			ld a, (.dmark+1)  
2421 32 be fb			ld (debug_mark+1),a  
2424 3a 2e 24			ld a, (.dmark+2)  
2427 32 bf fb			ld (debug_mark+2),a  
242a 18 03			jr .pastdmark  
242c ..			.dmark: db ":0x"  
242f f1			.pastdmark: pop af  
2430			endm  
# End of macro DMARK
2430				CALLMONITOR 
2430 cd 65 16			call break_point_state  
2433				endm  
# End of macro CALLMONITOR
2433 c1				pop bc 
2434			endif 
2434			 
2434			 
2434				; create word preamble which should be: 
2434			 
2434			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2434			 
2434				;    ld hl, <word code> 
2434				;    jp user_exec 
2434			        ;    <word code bytes> 
2434			 
2434			 
2434			;	inc de     ; TODO ??? or are we already past the word's null 
2434 eb				ex de, hl 
2435			 
2435 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2437			 
2437 23				inc hl 
2438 22 95 ef			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
243b 23				inc hl 
243c			 
243c 23				inc hl 
243d 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
243f			 
243f 01 1c 51			ld bc, user_exec 
2442 23				inc hl 
2443 71				ld (hl), c     ; poke address of user_exec 
2444 23				inc hl 
2445 70				ld (hl), b     
2446			 ; 
2446			;	inc hl 
2446			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2446			; 
2446			; 
2446			;	ld bc, macro_forth_rsp_next 
2446			;	inc hl 
2446			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2446			;	inc hl 
2446			;	ld (hl), b     
2446			 ; 
2446			;	inc hl 
2446			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2446			; 
2446			; 
2446			;	inc hl 
2446			;	ld bc, forthexec 
2446			;	ld (hl), c     ; poke address of forthexec 
2446			;	inc hl 
2446			;	ld (hl), b      
2446			; 
2446			;	inc hl 
2446			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2446			; 
2446			;	ld bc, user_dict_next 
2446			;	inc hl 
2446			;	ld (hl), c     ; poke address of forthexec 
2446			;	inc hl 
2446			;	ld (hl), b      
2446			 
2446				; hl is now where we need to copy the word byte data to save this 
2446			 
2446 23				inc hl 
2447 22 97 ef			ld (os_new_exec), hl 
244a				 
244a				; copy definition 
244a			 
244a eb				ex de, hl 
244b			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
244b			;	inc de    ; skip the PC for this parse 
244b 3a 9f ef			ld a, (os_new_parse_len) 
244e 4f				ld c, a 
244f 06 00			ld b, 0 
2451 ed b0			ldir		 ; copy defintion 
2453			 
2453			 
2453				; poke the address of where the new word bytes live for forthexec 
2453			 
2453 2a 95 ef			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2456			 
2456 ed 5b 97 ef		ld de, (os_new_exec)      
245a				 
245a 73				ld (hl), e 
245b 23				inc hl 
245c 72				ld (hl), d 
245d			 
245d					; TODO copy last user dict word next link to this word 
245d					; TODO update last user dict word to point to this word 
245d			; 
245d			; hl f923 de 812a ; bc 811a 
245d			 
245d			if DEBUG_FORTH_UWORD 
245d c5				push bc 
245e ed 4b a1 ef		ld bc, (os_new_malloc) 
2462						DMARK ":0A" 
2462 f5				push af  
2463 3a 77 24			ld a, (.dmark)  
2466 32 bd fb			ld (debug_mark),a  
2469 3a 78 24			ld a, (.dmark+1)  
246c 32 be fb			ld (debug_mark+1),a  
246f 3a 79 24			ld a, (.dmark+2)  
2472 32 bf fb			ld (debug_mark+2),a  
2475 18 03			jr .pastdmark  
2477 ..			.dmark: db ":0A"  
247a f1			.pastdmark: pop af  
247b			endm  
# End of macro DMARK
247b				CALLMONITOR 
247b cd 65 16			call break_point_state  
247e				endm  
# End of macro CALLMONITOR
247e c1				pop bc 
247f			endif 
247f			if DEBUG_FORTH_UWORD 
247f c5				push bc 
2480 ed 4b a1 ef		ld bc, (os_new_malloc) 
2484 03				inc bc 
2485 03				inc bc 
2486 03				inc bc 
2487 03				inc bc 
2488 03				inc bc 
2489 03				inc bc 
248a 03				inc bc 
248b 03				inc bc 
248c			 
248c						DMARK ":0B" 
248c f5				push af  
248d 3a a1 24			ld a, (.dmark)  
2490 32 bd fb			ld (debug_mark),a  
2493 3a a2 24			ld a, (.dmark+1)  
2496 32 be fb			ld (debug_mark+1),a  
2499 3a a3 24			ld a, (.dmark+2)  
249c 32 bf fb			ld (debug_mark+2),a  
249f 18 03			jr .pastdmark  
24a1 ..			.dmark: db ":0B"  
24a4 f1			.pastdmark: pop af  
24a5			endm  
# End of macro DMARK
24a5				CALLMONITOR 
24a5 cd 65 16			call break_point_state  
24a8				endm  
# End of macro CALLMONITOR
24a8 c1				pop bc 
24a9			endif 
24a9			 
24a9			; update word dict linked list for new word 
24a9			 
24a9			 
24a9 2a a0 f2		ld hl, (os_last_new_uword)		; get the start of the last added uword 
24ac 23			inc hl     ; move to next work linked list ptr 
24ad			 
24ad ed 5b a1 ef	ld de, (os_new_malloc)		 ; new next word 
24b1 73			ld (hl), e 
24b2 23			inc hl 
24b3 72			ld (hl), d 
24b4			 
24b4			if DEBUG_FORTH_UWORD 
24b4 ed 4b a0 f2		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
24b8			endif 
24b8			 
24b8 ed 53 a0 f2	ld (os_last_new_uword), de      ; update last new uword ptr 
24bc			 
24bc			 
24bc			if DEBUG_FORTH_UWORD 
24bc						DMARK ":0+" 
24bc f5				push af  
24bd 3a d1 24			ld a, (.dmark)  
24c0 32 bd fb			ld (debug_mark),a  
24c3 3a d2 24			ld a, (.dmark+1)  
24c6 32 be fb			ld (debug_mark+1),a  
24c9 3a d3 24			ld a, (.dmark+2)  
24cc 32 bf fb			ld (debug_mark+2),a  
24cf 18 03			jr .pastdmark  
24d1 ..			.dmark: db ":0+"  
24d4 f1			.pastdmark: pop af  
24d5			endm  
# End of macro DMARK
24d5				CALLMONITOR 
24d5 cd 65 16			call break_point_state  
24d8				endm  
# End of macro CALLMONITOR
24d8			endif 
24d8			 
24d8				STACKFRAMECHK OFF $8efe $989f 
24d8				if DEBUG_STACK_IMB 
24d8					if OFF 
24d8						exx 
24d8						ld hl, $989f 
24d8						pop de   ; $989f 
24d8						call cmp16 
24d8						jr nz, .spnosame 
24d8						ld hl, $8efe 
24d8						pop de   ; $8efe 
24d8						call cmp16 
24d8						jr z, .spfrsame 
24d8						.spnosame: call showsperror 
24d8						.spfrsame: nop 
24d8						exx 
24d8					endif 
24d8				endif 
24d8			endm 
# End of macro STACKFRAMECHK
24d8			 
24d8 c9			ret    ; dont process any remaining parser tokens as they form new word 
24d9			 
24d9			 
24d9			 
24d9			 
24d9			;		NEXT 
24d9			.SCOLN: 
24d9			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
24d9 06				db OPCODE_SCOLN 
24da 25 25			dw .DROP 
24dc 02				db 2 
24dd .. 00			db ";",0           
24df			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
24df					if DEBUG_FORTH_WORDS_KEY 
24df						DMARK "SCN" 
24df f5				push af  
24e0 3a f4 24			ld a, (.dmark)  
24e3 32 bd fb			ld (debug_mark),a  
24e6 3a f5 24			ld a, (.dmark+1)  
24e9 32 be fb			ld (debug_mark+1),a  
24ec 3a f6 24			ld a, (.dmark+2)  
24ef 32 bf fb			ld (debug_mark+2),a  
24f2 18 03			jr .pastdmark  
24f4 ..			.dmark: db "SCN"  
24f7 f1			.pastdmark: pop af  
24f8			endm  
# End of macro DMARK
24f8						CALLMONITOR 
24f8 cd 65 16			call break_point_state  
24fb				endm  
# End of macro CALLMONITOR
24fb					endif 
24fb					FORTH_RSP_TOS 
24fb cd b0 1b			call macro_forth_rsp_tos 
24fe				endm 
# End of macro FORTH_RSP_TOS
24fe e5					push hl 
24ff					FORTH_RSP_POP 
24ff cd ba 1b			call macro_forth_rsp_pop 
2502				endm 
# End of macro FORTH_RSP_POP
2502 e1					pop hl 
2503			;		ex de,hl 
2503 22 a4 f2				ld (os_tok_ptr),hl 
2506			 
2506			if DEBUG_FORTH_UWORD 
2506						DMARK "SCL" 
2506 f5				push af  
2507 3a 1b 25			ld a, (.dmark)  
250a 32 bd fb			ld (debug_mark),a  
250d 3a 1c 25			ld a, (.dmark+1)  
2510 32 be fb			ld (debug_mark+1),a  
2513 3a 1d 25			ld a, (.dmark+2)  
2516 32 bf fb			ld (debug_mark+2),a  
2519 18 03			jr .pastdmark  
251b ..			.dmark: db "SCL"  
251e f1			.pastdmark: pop af  
251f			endm  
# End of macro DMARK
251f				CALLMONITOR 
251f cd 65 16			call break_point_state  
2522				endm  
# End of macro CALLMONITOR
2522			endif 
2522					NEXTW 
2522 c3 5b 1f			jp macro_next 
2525				endm 
# End of macro NEXTW
2525			 
2525			.DROP: 
2525				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2525 1b				db WORD_SYS_CORE+OPCODE_DROP             
2526 50 25			dw .DUP2            
2528 05				db 4 + 1 
2529 .. 00			db "DROP",0              
252e				endm 
# End of macro CWHEAD
252e			; | DROP ( w -- )   drop the TOS item   | DONE 
252e					if DEBUG_FORTH_WORDS_KEY 
252e						DMARK "DRP" 
252e f5				push af  
252f 3a 43 25			ld a, (.dmark)  
2532 32 bd fb			ld (debug_mark),a  
2535 3a 44 25			ld a, (.dmark+1)  
2538 32 be fb			ld (debug_mark+1),a  
253b 3a 45 25			ld a, (.dmark+2)  
253e 32 bf fb			ld (debug_mark+2),a  
2541 18 03			jr .pastdmark  
2543 ..			.dmark: db "DRP"  
2546 f1			.pastdmark: pop af  
2547			endm  
# End of macro DMARK
2547						CALLMONITOR 
2547 cd 65 16			call break_point_state  
254a				endm  
# End of macro CALLMONITOR
254a					endif 
254a					FORTH_DSP_POP 
254a cd a1 1e			call macro_forth_dsp_pop 
254d				endm 
# End of macro FORTH_DSP_POP
254d					NEXTW 
254d c3 5b 1f			jp macro_next 
2550				endm 
# End of macro NEXTW
2550			.DUP2: 
2550				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2550 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2551 95 25			dw .DROP2            
2553 05				db 4 + 1 
2554 .. 00			db "2DUP",0              
2559				endm 
# End of macro CWHEAD
2559			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2559					if DEBUG_FORTH_WORDS_KEY 
2559						DMARK "2DU" 
2559 f5				push af  
255a 3a 6e 25			ld a, (.dmark)  
255d 32 bd fb			ld (debug_mark),a  
2560 3a 6f 25			ld a, (.dmark+1)  
2563 32 be fb			ld (debug_mark+1),a  
2566 3a 70 25			ld a, (.dmark+2)  
2569 32 bf fb			ld (debug_mark+2),a  
256c 18 03			jr .pastdmark  
256e ..			.dmark: db "2DU"  
2571 f1			.pastdmark: pop af  
2572			endm  
# End of macro DMARK
2572						CALLMONITOR 
2572 cd 65 16			call break_point_state  
2575				endm  
# End of macro CALLMONITOR
2575					endif 
2575					FORTH_DSP_VALUEHL 
2575 cd e9 1d			call macro_dsp_valuehl 
2578				endm 
# End of macro FORTH_DSP_VALUEHL
2578 e5					push hl      ; 2 
2579			 
2579					FORTH_DSP_POP 
2579 cd a1 1e			call macro_forth_dsp_pop 
257c				endm 
# End of macro FORTH_DSP_POP
257c					 
257c					FORTH_DSP_VALUEHL 
257c cd e9 1d			call macro_dsp_valuehl 
257f				endm 
# End of macro FORTH_DSP_VALUEHL
257f			;		push hl      ; 1 
257f			 
257f					FORTH_DSP_POP 
257f cd a1 1e			call macro_forth_dsp_pop 
2582				endm 
# End of macro FORTH_DSP_POP
2582			 
2582			;		pop hl       ; 1 
2582 d1					pop de       ; 2 
2583			 
2583 cd f2 1b				call forth_push_numhl 
2586 eb					ex de, hl 
2587 cd f2 1b				call forth_push_numhl 
258a			 
258a					 
258a eb					ex de, hl 
258b			 
258b cd f2 1b				call forth_push_numhl 
258e eb					ex de, hl 
258f cd f2 1b				call forth_push_numhl 
2592			 
2592			 
2592					NEXTW 
2592 c3 5b 1f			jp macro_next 
2595				endm 
# End of macro NEXTW
2595			.DROP2: 
2595				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2595 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2596 c4 25			dw .SWAP2            
2598 06				db 5 + 1 
2599 .. 00			db "2DROP",0              
259f				endm 
# End of macro CWHEAD
259f			; | 2DROP ( w w -- )    Double drop | DONE 
259f					if DEBUG_FORTH_WORDS_KEY 
259f						DMARK "2DR" 
259f f5				push af  
25a0 3a b4 25			ld a, (.dmark)  
25a3 32 bd fb			ld (debug_mark),a  
25a6 3a b5 25			ld a, (.dmark+1)  
25a9 32 be fb			ld (debug_mark+1),a  
25ac 3a b6 25			ld a, (.dmark+2)  
25af 32 bf fb			ld (debug_mark+2),a  
25b2 18 03			jr .pastdmark  
25b4 ..			.dmark: db "2DR"  
25b7 f1			.pastdmark: pop af  
25b8			endm  
# End of macro DMARK
25b8						CALLMONITOR 
25b8 cd 65 16			call break_point_state  
25bb				endm  
# End of macro CALLMONITOR
25bb					endif 
25bb					FORTH_DSP_POP 
25bb cd a1 1e			call macro_forth_dsp_pop 
25be				endm 
# End of macro FORTH_DSP_POP
25be					FORTH_DSP_POP 
25be cd a1 1e			call macro_forth_dsp_pop 
25c1				endm 
# End of macro FORTH_DSP_POP
25c1					NEXTW 
25c1 c3 5b 1f			jp macro_next 
25c4				endm 
# End of macro NEXTW
25c4			.SWAP2: 
25c4				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
25c4 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
25c5 ed 25			dw .AT            
25c7 06				db 5 + 1 
25c8 .. 00			db "2SWAP",0              
25ce				endm 
# End of macro CWHEAD
25ce			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
25ce					if DEBUG_FORTH_WORDS_KEY 
25ce						DMARK "2SW" 
25ce f5				push af  
25cf 3a e3 25			ld a, (.dmark)  
25d2 32 bd fb			ld (debug_mark),a  
25d5 3a e4 25			ld a, (.dmark+1)  
25d8 32 be fb			ld (debug_mark+1),a  
25db 3a e5 25			ld a, (.dmark+2)  
25de 32 bf fb			ld (debug_mark+2),a  
25e1 18 03			jr .pastdmark  
25e3 ..			.dmark: db "2SW"  
25e6 f1			.pastdmark: pop af  
25e7			endm  
# End of macro DMARK
25e7						CALLMONITOR 
25e7 cd 65 16			call break_point_state  
25ea				endm  
# End of macro CALLMONITOR
25ea					endif 
25ea					NEXTW 
25ea c3 5b 1f			jp macro_next 
25ed				endm 
# End of macro NEXTW
25ed			.AT: 
25ed				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
25ed 1f				db WORD_SYS_CORE+OPCODE_AT             
25ee 1f 26			dw .CAT            
25f0 02				db 1 + 1 
25f1 .. 00			db "@",0              
25f3				endm 
# End of macro CWHEAD
25f3			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
25f3			 
25f3					if DEBUG_FORTH_WORDS_KEY 
25f3						DMARK "AT." 
25f3 f5				push af  
25f4 3a 08 26			ld a, (.dmark)  
25f7 32 bd fb			ld (debug_mark),a  
25fa 3a 09 26			ld a, (.dmark+1)  
25fd 32 be fb			ld (debug_mark+1),a  
2600 3a 0a 26			ld a, (.dmark+2)  
2603 32 bf fb			ld (debug_mark+2),a  
2606 18 03			jr .pastdmark  
2608 ..			.dmark: db "AT."  
260b f1			.pastdmark: pop af  
260c			endm  
# End of macro DMARK
260c						CALLMONITOR 
260c cd 65 16			call break_point_state  
260f				endm  
# End of macro CALLMONITOR
260f					endif 
260f			.getbyteat:	 
260f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
260f cd e9 1d			call macro_dsp_valuehl 
2612				endm 
# End of macro FORTH_DSP_VALUEHL
2612					 
2612			;		push hl 
2612				 
2612					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2612 cd a1 1e			call macro_forth_dsp_pop 
2615				endm 
# End of macro FORTH_DSP_POP
2615			 
2615			;		pop hl 
2615			 
2615 7e					ld a, (hl) 
2616			 
2616 6f					ld l, a 
2617 26 00				ld h, 0 
2619 cd f2 1b				call forth_push_numhl 
261c			 
261c					NEXTW 
261c c3 5b 1f			jp macro_next 
261f				endm 
# End of macro NEXTW
261f			.CAT: 
261f				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
261f 20				db WORD_SYS_CORE+OPCODE_CAT             
2620 48 26			dw .BANG            
2622 03				db 2 + 1 
2623 .. 00			db "C@",0              
2626				endm 
# End of macro CWHEAD
2626			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2626					if DEBUG_FORTH_WORDS_KEY 
2626						DMARK "CAA" 
2626 f5				push af  
2627 3a 3b 26			ld a, (.dmark)  
262a 32 bd fb			ld (debug_mark),a  
262d 3a 3c 26			ld a, (.dmark+1)  
2630 32 be fb			ld (debug_mark+1),a  
2633 3a 3d 26			ld a, (.dmark+2)  
2636 32 bf fb			ld (debug_mark+2),a  
2639 18 03			jr .pastdmark  
263b ..			.dmark: db "CAA"  
263e f1			.pastdmark: pop af  
263f			endm  
# End of macro DMARK
263f						CALLMONITOR 
263f cd 65 16			call break_point_state  
2642				endm  
# End of macro CALLMONITOR
2642					endif 
2642 c3 0f 26				jp .getbyteat 
2645					NEXTW 
2645 c3 5b 1f			jp macro_next 
2648				endm 
# End of macro NEXTW
2648			.BANG: 
2648				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2648 21				db WORD_SYS_CORE+OPCODE_BANG             
2649 7e 26			dw .CBANG            
264b 02				db 1 + 1 
264c .. 00			db "!",0              
264e				endm 
# End of macro CWHEAD
264e			; | ! ( x w -- ) Store x at address w      | DONE 
264e					if DEBUG_FORTH_WORDS_KEY 
264e						DMARK "BNG" 
264e f5				push af  
264f 3a 63 26			ld a, (.dmark)  
2652 32 bd fb			ld (debug_mark),a  
2655 3a 64 26			ld a, (.dmark+1)  
2658 32 be fb			ld (debug_mark+1),a  
265b 3a 65 26			ld a, (.dmark+2)  
265e 32 bf fb			ld (debug_mark+2),a  
2661 18 03			jr .pastdmark  
2663 ..			.dmark: db "BNG"  
2666 f1			.pastdmark: pop af  
2667			endm  
# End of macro DMARK
2667						CALLMONITOR 
2667 cd 65 16			call break_point_state  
266a				endm  
# End of macro CALLMONITOR
266a					endif 
266a			 
266a			.storebyteat:		 
266a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
266a cd e9 1d			call macro_dsp_valuehl 
266d				endm 
# End of macro FORTH_DSP_VALUEHL
266d					 
266d e5					push hl 
266e				 
266e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
266e cd a1 1e			call macro_forth_dsp_pop 
2671				endm 
# End of macro FORTH_DSP_POP
2671			 
2671					; get byte to poke 
2671			 
2671					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2671 cd e9 1d			call macro_dsp_valuehl 
2674				endm 
# End of macro FORTH_DSP_VALUEHL
2674 e5					push hl 
2675			 
2675			 
2675					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2675 cd a1 1e			call macro_forth_dsp_pop 
2678				endm 
# End of macro FORTH_DSP_POP
2678			 
2678			 
2678 d1					pop de 
2679 e1					pop hl 
267a			 
267a 73					ld (hl),e 
267b			 
267b			 
267b					NEXTW 
267b c3 5b 1f			jp macro_next 
267e				endm 
# End of macro NEXTW
267e			.CBANG: 
267e				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
267e 22				db WORD_SYS_CORE+OPCODE_CBANG             
267f a7 26			dw .SCALL            
2681 03				db 2 + 1 
2682 .. 00			db "C!",0              
2685				endm 
# End of macro CWHEAD
2685			; | C!  ( x w -- ) Store x at address w  | DONE 
2685					if DEBUG_FORTH_WORDS_KEY 
2685						DMARK "CBA" 
2685 f5				push af  
2686 3a 9a 26			ld a, (.dmark)  
2689 32 bd fb			ld (debug_mark),a  
268c 3a 9b 26			ld a, (.dmark+1)  
268f 32 be fb			ld (debug_mark+1),a  
2692 3a 9c 26			ld a, (.dmark+2)  
2695 32 bf fb			ld (debug_mark+2),a  
2698 18 03			jr .pastdmark  
269a ..			.dmark: db "CBA"  
269d f1			.pastdmark: pop af  
269e			endm  
# End of macro DMARK
269e						CALLMONITOR 
269e cd 65 16			call break_point_state  
26a1				endm  
# End of macro CALLMONITOR
26a1					endif 
26a1 c3 6a 26				jp .storebyteat 
26a4					NEXTW 
26a4 c3 5b 1f			jp macro_next 
26a7				endm 
# End of macro NEXTW
26a7			.SCALL: 
26a7				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
26a7 23				db WORD_SYS_CORE+OPCODE_SCALL             
26a8 db 26			dw .DEPTH            
26aa 05				db 4 + 1 
26ab .. 00			db "CALL",0              
26b0				endm 
# End of macro CWHEAD
26b0			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
26b0					if DEBUG_FORTH_WORDS_KEY 
26b0						DMARK "CLL" 
26b0 f5				push af  
26b1 3a c5 26			ld a, (.dmark)  
26b4 32 bd fb			ld (debug_mark),a  
26b7 3a c6 26			ld a, (.dmark+1)  
26ba 32 be fb			ld (debug_mark+1),a  
26bd 3a c7 26			ld a, (.dmark+2)  
26c0 32 bf fb			ld (debug_mark+2),a  
26c3 18 03			jr .pastdmark  
26c5 ..			.dmark: db "CLL"  
26c8 f1			.pastdmark: pop af  
26c9			endm  
# End of macro DMARK
26c9						CALLMONITOR 
26c9 cd 65 16			call break_point_state  
26cc				endm  
# End of macro CALLMONITOR
26cc					endif 
26cc			 
26cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26cc cd e9 1d			call macro_dsp_valuehl 
26cf				endm 
# End of macro FORTH_DSP_VALUEHL
26cf			 
26cf			;		push hl 
26cf			 
26cf					; destroy value TOS 
26cf			 
26cf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26cf cd a1 1e			call macro_forth_dsp_pop 
26d2				endm 
# End of macro FORTH_DSP_POP
26d2			 
26d2						 
26d2			;		pop hl 
26d2			 
26d2					; how to do a call with hl???? save SP? 
26d2 cd 04 1f				call forth_call_hl 
26d5			 
26d5			 
26d5					; TODO push value back onto stack for another op etc 
26d5			 
26d5 cd f2 1b				call forth_push_numhl 
26d8					NEXTW 
26d8 c3 5b 1f			jp macro_next 
26db				endm 
# End of macro NEXTW
26db			.DEPTH: 
26db				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
26db 24				db WORD_SYS_CORE+OPCODE_DEPTH             
26dc 18 27			dw .OVER            
26de 06				db 5 + 1 
26df .. 00			db "DEPTH",0              
26e5				endm 
# End of macro CWHEAD
26e5			; | DEPTH ( -- u ) Push count of stack | DONE 
26e5					; take current TOS and remove from base value div by two to get count 
26e5					if DEBUG_FORTH_WORDS_KEY 
26e5						DMARK "DEP" 
26e5 f5				push af  
26e6 3a fa 26			ld a, (.dmark)  
26e9 32 bd fb			ld (debug_mark),a  
26ec 3a fb 26			ld a, (.dmark+1)  
26ef 32 be fb			ld (debug_mark+1),a  
26f2 3a fc 26			ld a, (.dmark+2)  
26f5 32 bf fb			ld (debug_mark+2),a  
26f8 18 03			jr .pastdmark  
26fa ..			.dmark: db "DEP"  
26fd f1			.pastdmark: pop af  
26fe			endm  
# End of macro DMARK
26fe						CALLMONITOR 
26fe cd 65 16			call break_point_state  
2701				endm  
# End of macro CALLMONITOR
2701					endif 
2701			 
2701			 
2701 2a 90 f9			ld hl, (cli_data_sp) 
2704 11 0a f5			ld de, cli_data_stack 
2707 ed 52			sbc hl,de 
2709				 
2709				; div by size of stack item 
2709			 
2709 5d				ld e,l 
270a 0e 03			ld c, 3 
270c cd 96 0c			call Div8 
270f			 
270f 6f				ld l,a 
2710 26 00			ld h,0 
2712			 
2712				;srl h 
2712				;rr l 
2712			 
2712 cd f2 1b				call forth_push_numhl 
2715					NEXTW 
2715 c3 5b 1f			jp macro_next 
2718				endm 
# End of macro NEXTW
2718			.OVER: 
2718				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2718 42				db WORD_SYS_CORE+46             
2719 5f 27			dw .PAUSE            
271b 05				db 4 + 1 
271c .. 00			db "OVER",0              
2721				endm 
# End of macro CWHEAD
2721			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2721					if DEBUG_FORTH_WORDS_KEY 
2721						DMARK "OVR" 
2721 f5				push af  
2722 3a 36 27			ld a, (.dmark)  
2725 32 bd fb			ld (debug_mark),a  
2728 3a 37 27			ld a, (.dmark+1)  
272b 32 be fb			ld (debug_mark+1),a  
272e 3a 38 27			ld a, (.dmark+2)  
2731 32 bf fb			ld (debug_mark+2),a  
2734 18 03			jr .pastdmark  
2736 ..			.dmark: db "OVR"  
2739 f1			.pastdmark: pop af  
273a			endm  
# End of macro DMARK
273a						CALLMONITOR 
273a cd 65 16			call break_point_state  
273d				endm  
# End of macro CALLMONITOR
273d					endif 
273d			 
273d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
273d cd e9 1d			call macro_dsp_valuehl 
2740				endm 
# End of macro FORTH_DSP_VALUEHL
2740 e5					push hl    ; n2 
2741					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2741 cd a1 1e			call macro_forth_dsp_pop 
2744				endm 
# End of macro FORTH_DSP_POP
2744			 
2744					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2744 cd e9 1d			call macro_dsp_valuehl 
2747				endm 
# End of macro FORTH_DSP_VALUEHL
2747 e5					push hl    ; n1 
2748					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2748 cd a1 1e			call macro_forth_dsp_pop 
274b				endm 
# End of macro FORTH_DSP_POP
274b			 
274b d1					pop de     ; n1 
274c e1					pop hl     ; n2 
274d			 
274d d5					push de 
274e e5					push hl 
274f d5					push de 
2750			 
2750					; push back  
2750			 
2750 e1					pop hl 
2751 cd f2 1b				call forth_push_numhl 
2754 e1					pop hl 
2755 cd f2 1b				call forth_push_numhl 
2758 e1					pop hl 
2759 cd f2 1b				call forth_push_numhl 
275c					NEXTW 
275c c3 5b 1f			jp macro_next 
275f				endm 
# End of macro NEXTW
275f			 
275f			.PAUSE: 
275f				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
275f 43				db WORD_SYS_CORE+47             
2760 94 27			dw .PAUSES            
2762 08				db 7 + 1 
2763 .. 00			db "PAUSEMS",0              
276b				endm 
# End of macro CWHEAD
276b			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
276b					if DEBUG_FORTH_WORDS_KEY 
276b						DMARK "PMS" 
276b f5				push af  
276c 3a 80 27			ld a, (.dmark)  
276f 32 bd fb			ld (debug_mark),a  
2772 3a 81 27			ld a, (.dmark+1)  
2775 32 be fb			ld (debug_mark+1),a  
2778 3a 82 27			ld a, (.dmark+2)  
277b 32 bf fb			ld (debug_mark+2),a  
277e 18 03			jr .pastdmark  
2780 ..			.dmark: db "PMS"  
2783 f1			.pastdmark: pop af  
2784			endm  
# End of macro DMARK
2784						CALLMONITOR 
2784 cd 65 16			call break_point_state  
2787				endm  
# End of macro CALLMONITOR
2787					endif 
2787					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2787 cd e9 1d			call macro_dsp_valuehl 
278a				endm 
# End of macro FORTH_DSP_VALUEHL
278a			;		push hl    ; n2 
278a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
278a cd a1 1e			call macro_forth_dsp_pop 
278d				endm 
# End of macro FORTH_DSP_POP
278d			;		pop hl 
278d			 
278d 7d					ld a, l 
278e cd 37 0a				call aDelayInMS 
2791				       NEXTW 
2791 c3 5b 1f			jp macro_next 
2794				endm 
# End of macro NEXTW
2794			.PAUSES:  
2794				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2794 44				db WORD_SYS_CORE+48             
2795 03 28			dw .ROT            
2797 06				db 5 + 1 
2798 .. 00			db "PAUSE",0              
279e				endm 
# End of macro CWHEAD
279e			; | PAUSE ( n -- )  Pause for n seconds | DONE 
279e					if DEBUG_FORTH_WORDS_KEY 
279e						DMARK "PAU" 
279e f5				push af  
279f 3a b3 27			ld a, (.dmark)  
27a2 32 bd fb			ld (debug_mark),a  
27a5 3a b4 27			ld a, (.dmark+1)  
27a8 32 be fb			ld (debug_mark+1),a  
27ab 3a b5 27			ld a, (.dmark+2)  
27ae 32 bf fb			ld (debug_mark+2),a  
27b1 18 03			jr .pastdmark  
27b3 ..			.dmark: db "PAU"  
27b6 f1			.pastdmark: pop af  
27b7			endm  
# End of macro DMARK
27b7						CALLMONITOR 
27b7 cd 65 16			call break_point_state  
27ba				endm  
# End of macro CALLMONITOR
27ba					endif 
27ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27ba cd e9 1d			call macro_dsp_valuehl 
27bd				endm 
# End of macro FORTH_DSP_VALUEHL
27bd			;		push hl    ; n2 
27bd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27bd cd a1 1e			call macro_forth_dsp_pop 
27c0				endm 
# End of macro FORTH_DSP_POP
27c0			;		pop hl 
27c0 45					ld b, l 
27c1					if DEBUG_FORTH_WORDS 
27c1						DMARK "PAU" 
27c1 f5				push af  
27c2 3a d6 27			ld a, (.dmark)  
27c5 32 bd fb			ld (debug_mark),a  
27c8 3a d7 27			ld a, (.dmark+1)  
27cb 32 be fb			ld (debug_mark+1),a  
27ce 3a d8 27			ld a, (.dmark+2)  
27d1 32 bf fb			ld (debug_mark+2),a  
27d4 18 03			jr .pastdmark  
27d6 ..			.dmark: db "PAU"  
27d9 f1			.pastdmark: pop af  
27da			endm  
# End of macro DMARK
27da						CALLMONITOR 
27da cd 65 16			call break_point_state  
27dd				endm  
# End of macro CALLMONITOR
27dd					endif 
27dd c5			.pauses1:	push bc 
27de cd 52 0a				call delay1s 
27e1 c1					pop bc 
27e2					if DEBUG_FORTH_WORDS 
27e2						DMARK "PA1" 
27e2 f5				push af  
27e3 3a f7 27			ld a, (.dmark)  
27e6 32 bd fb			ld (debug_mark),a  
27e9 3a f8 27			ld a, (.dmark+1)  
27ec 32 be fb			ld (debug_mark+1),a  
27ef 3a f9 27			ld a, (.dmark+2)  
27f2 32 bf fb			ld (debug_mark+2),a  
27f5 18 03			jr .pastdmark  
27f7 ..			.dmark: db "PA1"  
27fa f1			.pastdmark: pop af  
27fb			endm  
# End of macro DMARK
27fb						CALLMONITOR 
27fb cd 65 16			call break_point_state  
27fe				endm  
# End of macro CALLMONITOR
27fe					endif 
27fe 10 dd				djnz .pauses1 
2800			 
2800				       NEXTW 
2800 c3 5b 1f			jp macro_next 
2803				endm 
# End of macro NEXTW
2803			.ROT: 
2803				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2803 45				db WORD_SYS_CORE+49             
2804 51 28			dw .UWORDS            
2806 04				db 3 + 1 
2807 .. 00			db "ROT",0              
280b				endm 
# End of macro CWHEAD
280b			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
280b					if DEBUG_FORTH_WORDS_KEY 
280b						DMARK "ROT" 
280b f5				push af  
280c 3a 20 28			ld a, (.dmark)  
280f 32 bd fb			ld (debug_mark),a  
2812 3a 21 28			ld a, (.dmark+1)  
2815 32 be fb			ld (debug_mark+1),a  
2818 3a 22 28			ld a, (.dmark+2)  
281b 32 bf fb			ld (debug_mark+2),a  
281e 18 03			jr .pastdmark  
2820 ..			.dmark: db "ROT"  
2823 f1			.pastdmark: pop af  
2824			endm  
# End of macro DMARK
2824						CALLMONITOR 
2824 cd 65 16			call break_point_state  
2827				endm  
# End of macro CALLMONITOR
2827					endif 
2827			 
2827					FORTH_DSP_VALUEHL 
2827 cd e9 1d			call macro_dsp_valuehl 
282a				endm 
# End of macro FORTH_DSP_VALUEHL
282a e5					push hl    ; u3  
282b			 
282b					FORTH_DSP_POP 
282b cd a1 1e			call macro_forth_dsp_pop 
282e				endm 
# End of macro FORTH_DSP_POP
282e			   
282e					FORTH_DSP_VALUEHL 
282e cd e9 1d			call macro_dsp_valuehl 
2831				endm 
# End of macro FORTH_DSP_VALUEHL
2831 e5					push hl     ; u2 
2832			 
2832					FORTH_DSP_POP 
2832 cd a1 1e			call macro_forth_dsp_pop 
2835				endm 
# End of macro FORTH_DSP_POP
2835			 
2835					FORTH_DSP_VALUEHL 
2835 cd e9 1d			call macro_dsp_valuehl 
2838				endm 
# End of macro FORTH_DSP_VALUEHL
2838 e5					push hl     ; u1 
2839			 
2839					FORTH_DSP_POP 
2839 cd a1 1e			call macro_forth_dsp_pop 
283c				endm 
# End of macro FORTH_DSP_POP
283c			 
283c c1					pop bc      ; u1 
283d e1					pop hl      ; u2 
283e d1					pop de      ; u3 
283f			 
283f			 
283f c5					push bc 
2840 d5					push de 
2841 e5					push hl 
2842			 
2842			 
2842 e1					pop hl 
2843 cd f2 1b				call forth_push_numhl 
2846			 
2846 e1					pop hl 
2847 cd f2 1b				call forth_push_numhl 
284a			 
284a e1					pop hl 
284b cd f2 1b				call forth_push_numhl 
284e					 
284e			 
284e			 
284e			 
284e			 
284e			 
284e				       NEXTW 
284e c3 5b 1f			jp macro_next 
2851				endm 
# End of macro NEXTW
2851			 
2851			.UWORDS: 
2851				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2851 50				db WORD_SYS_CORE+60             
2852 13 29			dw .BP            
2854 07				db 6 + 1 
2855 .. 00			db "UWORDS",0              
285c				endm 
# End of macro CWHEAD
285c			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
285c			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
285c			; | | Following the count are the individual words. 
285c			; | | 
285c			; | | e.g. UWORDS 
285c			; | | BOX DIRLIST 2 
285c			; | |  
285c			; | | Can be used to save the words to storage via: 
285c			; | | UWORDS $01 DO $01 APPEND LOOP 
285c				if DEBUG_FORTH_WORDS_KEY 
285c					DMARK "UWR" 
285c f5				push af  
285d 3a 71 28			ld a, (.dmark)  
2860 32 bd fb			ld (debug_mark),a  
2863 3a 72 28			ld a, (.dmark+1)  
2866 32 be fb			ld (debug_mark+1),a  
2869 3a 73 28			ld a, (.dmark+2)  
286c 32 bf fb			ld (debug_mark+2),a  
286f 18 03			jr .pastdmark  
2871 ..			.dmark: db "UWR"  
2874 f1			.pastdmark: pop af  
2875			endm  
# End of macro DMARK
2875					CALLMONITOR 
2875 cd 65 16			call break_point_state  
2878				endm  
# End of macro CALLMONITOR
2878				endif 
2878 21 00 80				ld hl, baseram 
287b					;ld hl, baseusermem 
287b 01 00 00				ld bc, 0    ; start a counter 
287e			 
287e				; skip dict stub 
287e			 
287e cd ac 20				call forth_tok_next 
2881			 
2881			 
2881			; while we have words to look for 
2881			 
2881 7e			.douscan:	ld a, (hl)      
2882				if DEBUG_FORTH_WORDS 
2882					DMARK "UWs" 
2882 f5				push af  
2883 3a 97 28			ld a, (.dmark)  
2886 32 bd fb			ld (debug_mark),a  
2889 3a 98 28			ld a, (.dmark+1)  
288c 32 be fb			ld (debug_mark+1),a  
288f 3a 99 28			ld a, (.dmark+2)  
2892 32 bf fb			ld (debug_mark+2),a  
2895 18 03			jr .pastdmark  
2897 ..			.dmark: db "UWs"  
289a f1			.pastdmark: pop af  
289b			endm  
# End of macro DMARK
289b					CALLMONITOR 
289b cd 65 16			call break_point_state  
289e				endm  
# End of macro CALLMONITOR
289e				endif 
289e fe 00				cp WORD_SYS_END 
28a0 28 4d				jr z, .udone 
28a2 fe 01				cp WORD_SYS_UWORD 
28a4 20 44				jr nz, .nuword 
28a6			 
28a6				if DEBUG_FORTH_WORDS 
28a6					DMARK "UWu" 
28a6 f5				push af  
28a7 3a bb 28			ld a, (.dmark)  
28aa 32 bd fb			ld (debug_mark),a  
28ad 3a bc 28			ld a, (.dmark+1)  
28b0 32 be fb			ld (debug_mark+1),a  
28b3 3a bd 28			ld a, (.dmark+2)  
28b6 32 bf fb			ld (debug_mark+2),a  
28b9 18 03			jr .pastdmark  
28bb ..			.dmark: db "UWu"  
28be f1			.pastdmark: pop af  
28bf			endm  
# End of macro DMARK
28bf					CALLMONITOR 
28bf cd 65 16			call break_point_state  
28c2				endm  
# End of macro CALLMONITOR
28c2				endif 
28c2					; we have a uword so push its name to the stack 
28c2			 
28c2 e5				   	push hl  ; save so we can move to next dict block 
28c3			 
28c3					; skip opcode 
28c3 23					inc hl  
28c4					; skip next ptr 
28c4 23					inc hl  
28c5 23					inc hl 
28c6					; skip len 
28c6 23					inc hl 
28c7				if DEBUG_FORTH_WORDS 
28c7					DMARK "UWt" 
28c7 f5				push af  
28c8 3a dc 28			ld a, (.dmark)  
28cb 32 bd fb			ld (debug_mark),a  
28ce 3a dd 28			ld a, (.dmark+1)  
28d1 32 be fb			ld (debug_mark+1),a  
28d4 3a de 28			ld a, (.dmark+2)  
28d7 32 bf fb			ld (debug_mark+2),a  
28da 18 03			jr .pastdmark  
28dc ..			.dmark: db "UWt"  
28df f1			.pastdmark: pop af  
28e0			endm  
# End of macro DMARK
28e0					CALLMONITOR 
28e0 cd 65 16			call break_point_state  
28e3				endm  
# End of macro CALLMONITOR
28e3				endif 
28e3 03					inc bc 
28e4			 
28e4 c5					push bc 
28e5 cd 60 1c				call forth_push_str 
28e8 c1					pop bc 
28e9			 
28e9 e1					pop hl 	 
28ea			 
28ea cd ac 20		.nuword:	call forth_tok_next 
28ed 18 92				jr .douscan  
28ef			 
28ef			.udone:		 ; push count of uwords found 
28ef c5					push bc 
28f0 e1					pop hl 
28f1			 
28f1				if DEBUG_FORTH_WORDS 
28f1					DMARK "UWc" 
28f1 f5				push af  
28f2 3a 06 29			ld a, (.dmark)  
28f5 32 bd fb			ld (debug_mark),a  
28f8 3a 07 29			ld a, (.dmark+1)  
28fb 32 be fb			ld (debug_mark+1),a  
28fe 3a 08 29			ld a, (.dmark+2)  
2901 32 bf fb			ld (debug_mark+2),a  
2904 18 03			jr .pastdmark  
2906 ..			.dmark: db "UWc"  
2909 f1			.pastdmark: pop af  
290a			endm  
# End of macro DMARK
290a					CALLMONITOR 
290a cd 65 16			call break_point_state  
290d				endm  
# End of macro CALLMONITOR
290d				endif 
290d cd f2 1b				call forth_push_numhl 
2910			 
2910			 
2910				       NEXTW 
2910 c3 5b 1f			jp macro_next 
2913				endm 
# End of macro NEXTW
2913			 
2913			.BP: 
2913				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2913 54				db WORD_SYS_CORE+64             
2914 49 29			dw .MONITOR            
2916 03				db 2 + 1 
2917 .. 00			db "BP",0              
291a				endm 
# End of macro CWHEAD
291a			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
291a			; | | $00 Will enable the break points within specific code paths 
291a			; | | $01 Will disable break points 
291a			; | |  
291a			; | | By default break points are off. Either the above can be used to enable them 
291a			; | | or if a key is held down during start up the spashscreen will appear to freeze 
291a			; | | and on release of the pressed key a message will be disaplayed to notify 
291a			; | | that break points are enabled. Pressing any key will then continue boot process. 
291a					; get byte count 
291a					if DEBUG_FORTH_WORDS_KEY 
291a						DMARK "BP." 
291a f5				push af  
291b 3a 2f 29			ld a, (.dmark)  
291e 32 bd fb			ld (debug_mark),a  
2921 3a 30 29			ld a, (.dmark+1)  
2924 32 be fb			ld (debug_mark+1),a  
2927 3a 31 29			ld a, (.dmark+2)  
292a 32 bf fb			ld (debug_mark+2),a  
292d 18 03			jr .pastdmark  
292f ..			.dmark: db "BP."  
2932 f1			.pastdmark: pop af  
2933			endm  
# End of macro DMARK
2933						CALLMONITOR 
2933 cd 65 16			call break_point_state  
2936				endm  
# End of macro CALLMONITOR
2936					endif 
2936			 
2936					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2936 cd e9 1d			call macro_dsp_valuehl 
2939				endm 
# End of macro FORTH_DSP_VALUEHL
2939			 
2939			;		push hl 
2939			 
2939					; destroy value TOS 
2939			 
2939					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2939 cd a1 1e			call macro_forth_dsp_pop 
293c				endm 
# End of macro FORTH_DSP_POP
293c			 
293c			;		pop hl 
293c			 
293c 3e 00				ld a,0 
293e bd					cp l 
293f 28 02				jr z, .bpset 
2941 3e 2a				ld a, '*' 
2943			 
2943 32 94 ef		.bpset:		ld (os_view_disable), a 
2946			 
2946			 
2946					NEXTW 
2946 c3 5b 1f			jp macro_next 
2949				endm 
# End of macro NEXTW
2949			 
2949			 
2949			.MONITOR: 
2949				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2949 55				db WORD_SYS_CORE+65             
294a 7c 29			dw .MALLOC            
294c 08				db 7 + 1 
294d .. 00			db "MONITOR",0              
2955				endm 
# End of macro CWHEAD
2955			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2955			; | | At start the current various registers will be displayed with contents. 
2955			; | | Top right corner will show the most recent debug marker seen. 
2955			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2955			; | | and the return stack pointer (RSP). 
2955			; | | Pressing: 
2955			; | |    1 - Initial screen 
2955			; | |    2 - Display a data dump of HL 
2955			; | |    3 - Display a data dump of DE 
2955			; | |    4 - Display a data dump of BC 
2955			; | |    5 - Display a data dump of HL 
2955			; | |    6 - Display a data dump of DSP 
2955			; | |    7 - Display a data dump of RSP 
2955			; | |    8 - Display a data dump of what is at DSP 
2955			; | |    9 - Display a data dump of what is at RSP 
2955			; | |    0 - Exit monitor and continue running. This will also enable break points 
2955			; | |    * - Disable break points 
2955			; | |    # - Enter traditional monitor mode 
2955			; | | 
2955			; | | Monitor Mode 
2955			; | | ------------ 
2955			; | | A prompt of '>' will be shown for various commands: 
2955			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2955			; | |    C - Continue display a data dump from the last set address 
2955			; | |    M xxxx - Set start of memory edit at address xx 
2955			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2955			; | |    Q - Return to previous 
2955					if DEBUG_FORTH_WORDS_KEY 
2955						DMARK "MON" 
2955 f5				push af  
2956 3a 6a 29			ld a, (.dmark)  
2959 32 bd fb			ld (debug_mark),a  
295c 3a 6b 29			ld a, (.dmark+1)  
295f 32 be fb			ld (debug_mark+1),a  
2962 3a 6c 29			ld a, (.dmark+2)  
2965 32 bf fb			ld (debug_mark+2),a  
2968 18 03			jr .pastdmark  
296a ..			.dmark: db "MON"  
296d f1			.pastdmark: pop af  
296e			endm  
# End of macro DMARK
296e						CALLMONITOR 
296e cd 65 16			call break_point_state  
2971				endm  
# End of macro CALLMONITOR
2971					endif 
2971 3e 00				ld a, 0 
2973 32 94 ef				ld (os_view_disable), a 
2976			 
2976					CALLMONITOR 
2976 cd 65 16			call break_point_state  
2979				endm  
# End of macro CALLMONITOR
2979			 
2979			;	call monitor 
2979			 
2979					NEXTW 
2979 c3 5b 1f			jp macro_next 
297c				endm 
# End of macro NEXTW
297c			 
297c			 
297c			.MALLOC: 
297c				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
297c 56				db WORD_SYS_CORE+66             
297d a5 29			dw .MALLOC2            
297f 06				db 5 + 1 
2980 .. 00			db "ALLOT",0              
2986				endm 
# End of macro CWHEAD
2986			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2986					if DEBUG_FORTH_WORDS_KEY 
2986						DMARK "ALL" 
2986 f5				push af  
2987 3a 9b 29			ld a, (.dmark)  
298a 32 bd fb			ld (debug_mark),a  
298d 3a 9c 29			ld a, (.dmark+1)  
2990 32 be fb			ld (debug_mark+1),a  
2993 3a 9d 29			ld a, (.dmark+2)  
2996 32 bf fb			ld (debug_mark+2),a  
2999 18 03			jr .pastdmark  
299b ..			.dmark: db "ALL"  
299e f1			.pastdmark: pop af  
299f			endm  
# End of macro DMARK
299f						CALLMONITOR 
299f cd 65 16			call break_point_state  
29a2				endm  
# End of macro CALLMONITOR
29a2					endif 
29a2 c3 cc 29				jp .mallocc 
29a5			.MALLOC2: 
29a5				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
29a5 56				db WORD_SYS_CORE+66             
29a6 e3 29			dw .FREE            
29a8 07				db 6 + 1 
29a9 .. 00			db "MALLOC",0              
29b0				endm 
# End of macro CWHEAD
29b0			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
29b0					; get byte count 
29b0					if DEBUG_FORTH_WORDS_KEY 
29b0						DMARK "MAL" 
29b0 f5				push af  
29b1 3a c5 29			ld a, (.dmark)  
29b4 32 bd fb			ld (debug_mark),a  
29b7 3a c6 29			ld a, (.dmark+1)  
29ba 32 be fb			ld (debug_mark+1),a  
29bd 3a c7 29			ld a, (.dmark+2)  
29c0 32 bf fb			ld (debug_mark+2),a  
29c3 18 03			jr .pastdmark  
29c5 ..			.dmark: db "MAL"  
29c8 f1			.pastdmark: pop af  
29c9			endm  
# End of macro DMARK
29c9						CALLMONITOR 
29c9 cd 65 16			call break_point_state  
29cc				endm  
# End of macro CALLMONITOR
29cc					endif 
29cc			.mallocc: 
29cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29cc cd e9 1d			call macro_dsp_valuehl 
29cf				endm 
# End of macro FORTH_DSP_VALUEHL
29cf			 
29cf			;		push hl 
29cf			 
29cf					; destroy value TOS 
29cf			 
29cf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29cf cd a1 1e			call macro_forth_dsp_pop 
29d2				endm 
# End of macro FORTH_DSP_POP
29d2			 
29d2			;		pop hl 
29d2 cd cd 11				call malloc 
29d5				if DEBUG_FORTH_MALLOC_GUARD 
29d5 f5					push af 
29d6 cd 2f 0d				call ishlzero 
29d9			;		ld a, l 
29d9			;		add h 
29d9			;		cp 0 
29d9 f1					pop af 
29da					 
29da cc ee 51				call z,malloc_error 
29dd				endif 
29dd			 
29dd cd f2 1b				call forth_push_numhl 
29e0					NEXTW 
29e0 c3 5b 1f			jp macro_next 
29e3				endm 
# End of macro NEXTW
29e3			 
29e3			.FREE: 
29e3				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
29e3 57				db WORD_SYS_CORE+67             
29e4 14 2a			dw .LIST            
29e6 05				db 4 + 1 
29e7 .. 00			db "FREE",0              
29ec				endm 
# End of macro CWHEAD
29ec			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
29ec					if DEBUG_FORTH_WORDS_KEY 
29ec						DMARK "FRE" 
29ec f5				push af  
29ed 3a 01 2a			ld a, (.dmark)  
29f0 32 bd fb			ld (debug_mark),a  
29f3 3a 02 2a			ld a, (.dmark+1)  
29f6 32 be fb			ld (debug_mark+1),a  
29f9 3a 03 2a			ld a, (.dmark+2)  
29fc 32 bf fb			ld (debug_mark+2),a  
29ff 18 03			jr .pastdmark  
2a01 ..			.dmark: db "FRE"  
2a04 f1			.pastdmark: pop af  
2a05			endm  
# End of macro DMARK
2a05						CALLMONITOR 
2a05 cd 65 16			call break_point_state  
2a08				endm  
# End of macro CALLMONITOR
2a08					endif 
2a08					; get address 
2a08			 
2a08					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a08 cd e9 1d			call macro_dsp_valuehl 
2a0b				endm 
# End of macro FORTH_DSP_VALUEHL
2a0b			 
2a0b			;		push hl 
2a0b			 
2a0b					; destroy value TOS 
2a0b			 
2a0b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a0b cd a1 1e			call macro_forth_dsp_pop 
2a0e				endm 
# End of macro FORTH_DSP_POP
2a0e			 
2a0e			;		pop hl 
2a0e			if FORTH_ENABLE_MALLOCFREE 
2a0e cd 97 12				call free 
2a11			endif 
2a11					NEXTW 
2a11 c3 5b 1f			jp macro_next 
2a14				endm 
# End of macro NEXTW
2a14			.LIST: 
2a14				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2a14 5c				db WORD_SYS_CORE+72             
2a15 d7 2b			dw .FORGET            
2a17 05				db 4 + 1 
2a18 .. 00			db "LIST",0              
2a1d				endm 
# End of macro CWHEAD
2a1d			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2a1d			; | | The quoted word must be in upper case. 
2a1d				if DEBUG_FORTH_WORDS_KEY 
2a1d					DMARK "LST" 
2a1d f5				push af  
2a1e 3a 32 2a			ld a, (.dmark)  
2a21 32 bd fb			ld (debug_mark),a  
2a24 3a 33 2a			ld a, (.dmark+1)  
2a27 32 be fb			ld (debug_mark+1),a  
2a2a 3a 34 2a			ld a, (.dmark+2)  
2a2d 32 bf fb			ld (debug_mark+2),a  
2a30 18 03			jr .pastdmark  
2a32 ..			.dmark: db "LST"  
2a35 f1			.pastdmark: pop af  
2a36			endm  
# End of macro DMARK
2a36					CALLMONITOR 
2a36 cd 65 16			call break_point_state  
2a39				endm  
# End of macro CALLMONITOR
2a39				endif 
2a39			 
2a39					FORTH_DSP_VALUEHL 
2a39 cd e9 1d			call macro_dsp_valuehl 
2a3c				endm 
# End of macro FORTH_DSP_VALUEHL
2a3c			 
2a3c e5					push hl 
2a3d c1					pop bc 
2a3e			 
2a3e			; Start format of scratch string 
2a3e			 
2a3e 21 a3 ef				ld hl, scratch 
2a41			 
2a41 3e 3a				ld a, ':' 
2a43 77					ld (hl),a 
2a44 23					inc hl 
2a45 3e 20				ld a, ' ' 
2a47 77					ld (hl), a 
2a48			 
2a48					; Get ptr to the word we need to look up 
2a48			 
2a48			;		FORTH_DSP_VALUEHL 
2a48					;v5 FORTH_DSP_VALUE 
2a48				; TODO type check 
2a48			;		inc hl    ; Skip type check  
2a48			;		push hl 
2a48			;		ex de, hl    ; put into DE 
2a48			 
2a48			 
2a48 21 00 80				ld hl, baseram 
2a4b					;ld hl, baseusermem 
2a4b			 
2a4b e5			push hl   ; sacreifical push 
2a4c			 
2a4c			.ldouscanm: 
2a4c e1				pop hl 
2a4d			.ldouscan: 
2a4d				if DEBUG_FORTH_WORDS 
2a4d					DMARK "LSs" 
2a4d f5				push af  
2a4e 3a 62 2a			ld a, (.dmark)  
2a51 32 bd fb			ld (debug_mark),a  
2a54 3a 63 2a			ld a, (.dmark+1)  
2a57 32 be fb			ld (debug_mark+1),a  
2a5a 3a 64 2a			ld a, (.dmark+2)  
2a5d 32 bf fb			ld (debug_mark+2),a  
2a60 18 03			jr .pastdmark  
2a62 ..			.dmark: db "LSs"  
2a65 f1			.pastdmark: pop af  
2a66			endm  
# End of macro DMARK
2a66					CALLMONITOR 
2a66 cd 65 16			call break_point_state  
2a69				endm  
# End of macro CALLMONITOR
2a69				endif 
2a69				; skip dict stub 
2a69 cd ac 20				call forth_tok_next 
2a6c			 
2a6c			 
2a6c			; while we have words to look for 
2a6c			 
2a6c 7e				ld a, (hl)      
2a6d				if DEBUG_FORTH_WORDS 
2a6d					DMARK "LSk" 
2a6d f5				push af  
2a6e 3a 82 2a			ld a, (.dmark)  
2a71 32 bd fb			ld (debug_mark),a  
2a74 3a 83 2a			ld a, (.dmark+1)  
2a77 32 be fb			ld (debug_mark+1),a  
2a7a 3a 84 2a			ld a, (.dmark+2)  
2a7d 32 bf fb			ld (debug_mark+2),a  
2a80 18 03			jr .pastdmark  
2a82 ..			.dmark: db "LSk"  
2a85 f1			.pastdmark: pop af  
2a86			endm  
# End of macro DMARK
2a86					CALLMONITOR 
2a86 cd 65 16			call break_point_state  
2a89				endm  
# End of macro CALLMONITOR
2a89				endif 
2a89 fe 00				cp WORD_SYS_END 
2a8b ca be 2b				jp z, .lunotfound 
2a8e fe 01				cp WORD_SYS_UWORD 
2a90 c2 4d 2a				jp nz, .ldouscan 
2a93			 
2a93				if DEBUG_FORTH_WORDS 
2a93					DMARK "LSu" 
2a93 f5				push af  
2a94 3a a8 2a			ld a, (.dmark)  
2a97 32 bd fb			ld (debug_mark),a  
2a9a 3a a9 2a			ld a, (.dmark+1)  
2a9d 32 be fb			ld (debug_mark+1),a  
2aa0 3a aa 2a			ld a, (.dmark+2)  
2aa3 32 bf fb			ld (debug_mark+2),a  
2aa6 18 03			jr .pastdmark  
2aa8 ..			.dmark: db "LSu"  
2aab f1			.pastdmark: pop af  
2aac			endm  
# End of macro DMARK
2aac					CALLMONITOR 
2aac cd 65 16			call break_point_state  
2aaf				endm  
# End of macro CALLMONITOR
2aaf				endif 
2aaf			 
2aaf					; found a uword but is it the one we want... 
2aaf			 
2aaf c5					push bc     ; uword to find is on bc 
2ab0 d1					pop de 
2ab1			 
2ab1 e5					push hl  ; to save the ptr 
2ab2			 
2ab2					; skip opcode 
2ab2 23					inc hl  
2ab3					; skip next ptr 
2ab3 23					inc hl  
2ab4 23					inc hl 
2ab5					; skip len 
2ab5 23					inc hl 
2ab6			 
2ab6				if DEBUG_FORTH_WORDS 
2ab6					DMARK "LSc" 
2ab6 f5				push af  
2ab7 3a cb 2a			ld a, (.dmark)  
2aba 32 bd fb			ld (debug_mark),a  
2abd 3a cc 2a			ld a, (.dmark+1)  
2ac0 32 be fb			ld (debug_mark+1),a  
2ac3 3a cd 2a			ld a, (.dmark+2)  
2ac6 32 bf fb			ld (debug_mark+2),a  
2ac9 18 03			jr .pastdmark  
2acb ..			.dmark: db "LSc"  
2ace f1			.pastdmark: pop af  
2acf			endm  
# End of macro DMARK
2acf					CALLMONITOR 
2acf cd 65 16			call break_point_state  
2ad2				endm  
# End of macro CALLMONITOR
2ad2				endif 
2ad2 cd 9c 11				call strcmp 
2ad5 c2 4c 2a				jp nz, .ldouscanm 
2ad8				 
2ad8			 
2ad8			 
2ad8					; we have a uword so push its name to the stack 
2ad8			 
2ad8			;	   	push hl  ; save so we can move to next dict block 
2ad8 e1			pop hl 
2ad9			 
2ad9				if DEBUG_FORTH_WORDS 
2ad9					DMARK "LSm" 
2ad9 f5				push af  
2ada 3a ee 2a			ld a, (.dmark)  
2add 32 bd fb			ld (debug_mark),a  
2ae0 3a ef 2a			ld a, (.dmark+1)  
2ae3 32 be fb			ld (debug_mark+1),a  
2ae6 3a f0 2a			ld a, (.dmark+2)  
2ae9 32 bf fb			ld (debug_mark+2),a  
2aec 18 03			jr .pastdmark  
2aee ..			.dmark: db "LSm"  
2af1 f1			.pastdmark: pop af  
2af2			endm  
# End of macro DMARK
2af2					CALLMONITOR 
2af2 cd 65 16			call break_point_state  
2af5				endm  
# End of macro CALLMONITOR
2af5				endif 
2af5			 
2af5					; skip opcode 
2af5 23					inc hl  
2af6					; skip next ptr 
2af6 23					inc hl  
2af7 23					inc hl 
2af8					; skip len 
2af8 7e					ld a, (hl)   ; save length to add 
2af9				if DEBUG_FORTH_WORDS 
2af9					DMARK "LS2" 
2af9 f5				push af  
2afa 3a 0e 2b			ld a, (.dmark)  
2afd 32 bd fb			ld (debug_mark),a  
2b00 3a 0f 2b			ld a, (.dmark+1)  
2b03 32 be fb			ld (debug_mark+1),a  
2b06 3a 10 2b			ld a, (.dmark+2)  
2b09 32 bf fb			ld (debug_mark+2),a  
2b0c 18 03			jr .pastdmark  
2b0e ..			.dmark: db "LS2"  
2b11 f1			.pastdmark: pop af  
2b12			endm  
# End of macro DMARK
2b12					CALLMONITOR 
2b12 cd 65 16			call break_point_state  
2b15				endm  
# End of macro CALLMONITOR
2b15				endif 
2b15			 
2b15					; save this location 
2b15				 
2b15 e5					push hl 
2b16			 
2b16 23					inc hl 
2b17 11 a5 ef				ld de, scratch+2 
2b1a 4f					ld c, a 
2b1b 06 00				ld b, 0 
2b1d			 
2b1d				if DEBUG_FORTH_WORDS 
2b1d					DMARK "LSn" 
2b1d f5				push af  
2b1e 3a 32 2b			ld a, (.dmark)  
2b21 32 bd fb			ld (debug_mark),a  
2b24 3a 33 2b			ld a, (.dmark+1)  
2b27 32 be fb			ld (debug_mark+1),a  
2b2a 3a 34 2b			ld a, (.dmark+2)  
2b2d 32 bf fb			ld (debug_mark+2),a  
2b30 18 03			jr .pastdmark  
2b32 ..			.dmark: db "LSn"  
2b35 f1			.pastdmark: pop af  
2b36			endm  
# End of macro DMARK
2b36					CALLMONITOR 
2b36 cd 65 16			call break_point_state  
2b39				endm  
# End of macro CALLMONITOR
2b39				endif 
2b39			 
2b39					; copy uword name to scratch 
2b39			 
2b39 ed b0				ldir 
2b3b			 
2b3b 1b					dec de 
2b3c 3e 20				ld a, ' '    ; change null to space 
2b3e 12					ld (de), a 
2b3f			 
2b3f 13					inc de 
2b40			 
2b40 d5					push de 
2b41 c1					pop bc     ; move scratch pointer to end of word name and save it 
2b42			 
2b42 e1					pop hl 
2b43 7e					ld a, (hl) 
2b44					;inc hl 
2b44					; skip word string 
2b44 cd 06 0d				call addatohl 
2b47			 
2b47 23					inc hl 
2b48			 
2b48				if DEBUG_FORTH_WORDS 
2b48					DMARK "LS3" 
2b48 f5				push af  
2b49 3a 5d 2b			ld a, (.dmark)  
2b4c 32 bd fb			ld (debug_mark),a  
2b4f 3a 5e 2b			ld a, (.dmark+1)  
2b52 32 be fb			ld (debug_mark+1),a  
2b55 3a 5f 2b			ld a, (.dmark+2)  
2b58 32 bf fb			ld (debug_mark+2),a  
2b5b 18 03			jr .pastdmark  
2b5d ..			.dmark: db "LS3"  
2b60 f1			.pastdmark: pop af  
2b61			endm  
# End of macro DMARK
2b61					CALLMONITOR 
2b61 cd 65 16			call break_point_state  
2b64				endm  
# End of macro CALLMONITOR
2b64				endif 
2b64					; should now be at the start of the machine code to setup the eval of the uword 
2b64					; now locate the ptr to the string defintion 
2b64			 
2b64					; skip ld hl, 
2b64					; then load the ptr 
2b64			 
2b64 23					inc hl 
2b65 5e					ld e, (hl) 
2b66 23					inc hl 
2b67 56					ld d, (hl) 
2b68 eb					ex de, hl 
2b69			 
2b69			 
2b69				if DEBUG_FORTH_WORDS 
2b69					DMARK "LSt" 
2b69 f5				push af  
2b6a 3a 7e 2b			ld a, (.dmark)  
2b6d 32 bd fb			ld (debug_mark),a  
2b70 3a 7f 2b			ld a, (.dmark+1)  
2b73 32 be fb			ld (debug_mark+1),a  
2b76 3a 80 2b			ld a, (.dmark+2)  
2b79 32 bf fb			ld (debug_mark+2),a  
2b7c 18 03			jr .pastdmark  
2b7e ..			.dmark: db "LSt"  
2b81 f1			.pastdmark: pop af  
2b82			endm  
# End of macro DMARK
2b82					CALLMONITOR 
2b82 cd 65 16			call break_point_state  
2b85				endm  
# End of macro CALLMONITOR
2b85				endif 
2b85			 
2b85			; cant push right now due to tokenised strings  
2b85			 
2b85			; get the destination of where to copy this definition to. 
2b85			 
2b85 c5					push bc 
2b86 d1					pop de 
2b87			 
2b87 7e			.listl:         ld a,(hl) 
2b88 fe 00				cp 0 
2b8a 28 09				jr z, .lreplsp     ; replace zero with space 
2b8c fe 7f				cp FORTH_END_BUFFER 
2b8e 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2b90				 
2b90					; just copy this char as is then 
2b90			 
2b90 12					ld (de), a 
2b91			 
2b91 23			.listnxt:	inc hl 
2b92 13					inc de 
2b93 18 f2				jr .listl 
2b95			 
2b95 3e 20		.lreplsp:	ld a,' ' 
2b97 12					ld (de), a 
2b98 18 f7				jr .listnxt 
2b9a			 
2b9a			; close up uword def 
2b9a			 
2b9a			.listdone: 
2b9a 3e 00				ld a, 0 
2b9c 12					ld (de), a 
2b9d			 
2b9d			; now have def so clean up and push to stack 
2b9d			 
2b9d 21 a3 ef				ld hl, scratch 
2ba0				if DEBUG_FORTH_WORDS 
2ba0					DMARK "Ltp" 
2ba0 f5				push af  
2ba1 3a b5 2b			ld a, (.dmark)  
2ba4 32 bd fb			ld (debug_mark),a  
2ba7 3a b6 2b			ld a, (.dmark+1)  
2baa 32 be fb			ld (debug_mark+1),a  
2bad 3a b7 2b			ld a, (.dmark+2)  
2bb0 32 bf fb			ld (debug_mark+2),a  
2bb3 18 03			jr .pastdmark  
2bb5 ..			.dmark: db "Ltp"  
2bb8 f1			.pastdmark: pop af  
2bb9			endm  
# End of macro DMARK
2bb9					CALLMONITOR 
2bb9 cd 65 16			call break_point_state  
2bbc				endm  
# End of macro CALLMONITOR
2bbc				endif 
2bbc			 
2bbc 18 06			jr .listpush 
2bbe			 
2bbe			;.lnuword:	pop hl 
2bbe			;		call forth_tok_next 
2bbe			;		jp .ldouscan  
2bbe			 
2bbe			.lunotfound:		  
2bbe			 
2bbe			 
2bbe					 
2bbe					FORTH_DSP_POP 
2bbe cd a1 1e			call macro_forth_dsp_pop 
2bc1				endm 
# End of macro FORTH_DSP_POP
2bc1 21 ca 2b				ld hl, .luno 
2bc4						 
2bc4			 
2bc4			.listpush: 
2bc4 cd 60 1c				call forth_push_str 
2bc7			 
2bc7			 
2bc7			 
2bc7					NEXTW 
2bc7 c3 5b 1f			jp macro_next 
2bca				endm 
# End of macro NEXTW
2bca			 
2bca .. 00		.luno:    db "Not found",0 
2bd4			 
2bd4			 
2bd4			 
2bd4			 
2bd4			 
2bd4			;		push hl   ; save pointer to start of uword def string 
2bd4			; 
2bd4			;; look for FORTH_EOL_LINE 
2bd4			;		ld a, FORTH_END_BUFFER 
2bd4			;		call strlent 
2bd4			; 
2bd4			;		inc hl		 ; space for coln def 
2bd4			;		inc hl 
2bd4			;		inc hl          ; space for terms 
2bd4			;		inc hl 
2bd4			; 
2bd4			;		ld a, 20   ; TODO get actual length 
2bd4			;		call addatohl    ; include a random amount of room for the uword name 
2bd4			; 
2bd4			;		 
2bd4			;	if DEBUG_FORTH_WORDS 
2bd4			;		DMARK "Lt1" 
2bd4			;		CALLMONITOR 
2bd4			;	endif 
2bd4			;		 
2bd4			; 
2bd4			;; malloc space for the string because we cant change it 
2bd4			; 
2bd4			;		call malloc 
2bd4			;	if DEBUG_FORTH_MALLOC_GUARD 
2bd4			;		push af 
2bd4			;		call ishlzero 
2bd4			;		pop af 
2bd4			;		 
2bd4			;		call z,malloc_error 
2bd4			;	endif 
2bd4			; 
2bd4			;	if DEBUG_FORTH_WORDS 
2bd4			;		DMARK "Lt2" 
2bd4			;		CALLMONITOR 
2bd4			;	endif 
2bd4			;		pop de 
2bd4			;		push hl    ; push the malloc to release later 
2bd4			;		push hl   ;  push back a copy for the later stack push 
2bd4			;		 
2bd4			;; copy the string swapping out the zero terms for spaces 
2bd4			; 
2bd4			;		; de has our source 
2bd4			;		; hl has our dest 
2bd4			; 
2bd4			;; add the coln def 
2bd4			; 
2bd4			;		ld a, ':' 
2bd4			;		ld (hl), a 
2bd4			;		inc hl 
2bd4			;		ld a, ' ' 
2bd4			;		ld (hl), a 
2bd4			;		inc hl 
2bd4			; 
2bd4			;; add the uname word 
2bd4			;		push de   ; save our string for now 
2bd4			;		ex de, hl 
2bd4			; 
2bd4			;		FORTH_DSP_VALUE 
2bd4			;		;v5 FORTH_DSP_VALUE 
2bd4			; 
2bd4			;		inc hl   ; skip type but we know by now this is OK 
2bd4			; 
2bd4			;.luword:	ld a,(hl) 
2bd4			;		cp 0 
2bd4			;		jr z, .luword2 
2bd4			;		ld (de), a 
2bd4			;		inc de 
2bd4			;		inc hl 
2bd4			;		jr .luword 
2bd4			; 
2bd4			;.luword2:	ld a, ' ' 
2bd4			;		ld (de), a 
2bd4			;;		inc hl 
2bd4			;;		inc de 
2bd4			;;		ld (de), a 
2bd4			;;		inc hl 
2bd4			;		inc de 
2bd4			; 
2bd4			;		ex de, hl 
2bd4			;		pop de 
2bd4			;		 
2bd4			;		 
2bd4			; 
2bd4			;; detoken that string and copy it 
2bd4			; 
2bd4			;	if DEBUG_FORTH_WORDS 
2bd4			;		DMARK "Lt2" 
2bd4			;		CALLMONITOR 
2bd4			;	endif 
2bd4			;.ldetok:	ld a, (de) 
2bd4			;		cp FORTH_END_BUFFER 
2bd4			;		jr z, .ldetokend 
2bd4			;		; swap out any zero term for space 
2bd4			;		cp 0 
2bd4			;		jr nz, .ldetoknext 
2bd4			;		ld a, ' ' 
2bd4			; 
2bd4			;	if DEBUG_FORTH_WORDS 
2bd4			;		DMARK "LtS" 
2bd4			;		CALLMONITOR 
2bd4			;	endif 
2bd4			;.ldetoknext:	ld (hl), a 
2bd4			;		inc de 
2bd4			;		inc hl 
2bd4			;		jr .ldetok 
2bd4			; 
2bd4			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2bd4			;		ld (hl), a  
2bd4			; 
2bd4			;; free that temp malloc 
2bd4			; 
2bd4			;		pop hl    
2bd4			; 
2bd4			;	if DEBUG_FORTH_WORDS 
2bd4			;		DMARK "Lt4" 
2bd4			;		CALLMONITOR 
2bd4			;	endif 
2bd4			;		call forth_apushstrhl 
2bd4			; 
2bd4			;		; get rid of temp malloc area 
2bd4			; 
2bd4			;		pop hl 
2bd4			;		call free 
2bd4			; 
2bd4			;		jr .ludone 
2bd4			; 
2bd4			;.lnuword:	pop hl 
2bd4			;		call forth_tok_next 
2bd4			;		jp .ldouscan  
2bd4			; 
2bd4			;.ludone:		 pop hl 
2bd4			; 
2bd4					NEXTW 
2bd4 c3 5b 1f			jp macro_next 
2bd7				endm 
# End of macro NEXTW
2bd7			 
2bd7			.FORGET: 
2bd7				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2bd7 5d				db WORD_SYS_CORE+73             
2bd8 50 2c			dw .NOP            
2bda 07				db 6 + 1 
2bdb .. 00			db "FORGET",0              
2be2				endm 
# End of macro CWHEAD
2be2			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2be2			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2be2			; | |  
2be2			; | | e.g. "MORE" forget 
2be2					if DEBUG_FORTH_WORDS_KEY 
2be2						DMARK "FRG" 
2be2 f5				push af  
2be3 3a f7 2b			ld a, (.dmark)  
2be6 32 bd fb			ld (debug_mark),a  
2be9 3a f8 2b			ld a, (.dmark+1)  
2bec 32 be fb			ld (debug_mark+1),a  
2bef 3a f9 2b			ld a, (.dmark+2)  
2bf2 32 bf fb			ld (debug_mark+2),a  
2bf5 18 03			jr .pastdmark  
2bf7 ..			.dmark: db "FRG"  
2bfa f1			.pastdmark: pop af  
2bfb			endm  
# End of macro DMARK
2bfb						CALLMONITOR 
2bfb cd 65 16			call break_point_state  
2bfe				endm  
# End of macro CALLMONITOR
2bfe					endif 
2bfe			 
2bfe				; find uword 
2bfe			        ; update start of word with "_" 
2bfe				; replace uword with deleted flag 
2bfe			 
2bfe			 
2bfe			;	if DEBUG_FORTH_WORDS 
2bfe			;		DMARK "FOG" 
2bfe			;		CALLMONITOR 
2bfe			;	endif 
2bfe			 
2bfe			 
2bfe					; Get ptr to the word we need to look up 
2bfe			 
2bfe					FORTH_DSP_VALUEHL 
2bfe cd e9 1d			call macro_dsp_valuehl 
2c01				endm 
# End of macro FORTH_DSP_VALUEHL
2c01					;v5 FORTH_DSP_VALUE 
2c01				; TODO type check 
2c01			;		inc hl    ; Skip type check  
2c01 e5					push hl 
2c02 c1					pop bc 
2c03			;		ex de, hl    ; put into DE 
2c03			 
2c03			 
2c03 21 00 80				ld hl, baseram 
2c06					;ld hl, baseusermem 
2c06			 
2c06				; skip dict stub 
2c06			;	call forth_tok_next 
2c06 e5			push hl   ; sacreifical push 
2c07			 
2c07			.fldouscanm: 
2c07 e1				pop hl 
2c08			.fldouscan: 
2c08			;	if DEBUG_FORTH_WORDS 
2c08			;		DMARK "LSs" 
2c08			;		CALLMONITOR 
2c08			;	endif 
2c08				; skip dict stub 
2c08 cd ac 20				call forth_tok_next 
2c0b			 
2c0b			 
2c0b			; while we have words to look for 
2c0b			 
2c0b 7e				ld a, (hl)      
2c0c			;	if DEBUG_FORTH_WORDS 
2c0c			;		DMARK "LSk" 
2c0c			;		CALLMONITOR 
2c0c			;	endif 
2c0c fe 00				cp WORD_SYS_END 
2c0e ca 4a 2c				jp z, .flunotfound 
2c11 fe 01				cp WORD_SYS_UWORD 
2c13 c2 08 2c				jp nz, .fldouscan 
2c16			 
2c16			;	if DEBUG_FORTH_WORDS 
2c16			;		DMARK "LSu" 
2c16			;		CALLMONITOR 
2c16			;	endif 
2c16			 
2c16					; found a uword but is it the one we want... 
2c16			 
2c16 c5					push bc     ; uword to find is on bc 
2c17 d1					pop de 
2c18			 
2c18 e5					push hl  ; to save the ptr 
2c19			 
2c19					; skip opcode 
2c19 23					inc hl  
2c1a					; skip next ptr 
2c1a 23					inc hl  
2c1b 23					inc hl 
2c1c					; skip len 
2c1c 23					inc hl 
2c1d			 
2c1d			;	if DEBUG_FORTH_WORDS 
2c1d			;		DMARK "LSc" 
2c1d			;		CALLMONITOR 
2c1d			;	endif 
2c1d cd 9c 11				call strcmp 
2c20 c2 07 2c				jp nz, .fldouscanm 
2c23			; 
2c23			; 
2c23			;; while we have words to look for 
2c23			; 
2c23			;.fdouscan:	ld a, (hl)      
2c23			;	if DEBUG_FORTH_WORDS 
2c23			;		DMARK "LSs" 
2c23			;		CALLMONITOR 
2c23			;	endif 
2c23			;		cp WORD_SYS_END 
2c23			;		jp z, .fudone 
2c23			;		cp WORD_SYS_UWORD 
2c23			;		jp nz, .fnuword 
2c23			; 
2c23			;	if DEBUG_FORTH_WORDS 
2c23			;		DMARK "FGu" 
2c23			;		CALLMONITOR 
2c23			;	endif 
2c23			; 
2c23			;		; found a uword but is it the one we want... 
2c23			; 
2c23			; 
2c23			;	        pop de   ; get back the dsp name 
2c23			;		push de 
2c23			; 
2c23			;		push hl  ; to save the ptr 
2c23			; 
2c23			;		; skip opcode 
2c23			;		inc hl  
2c23			;		; skip next ptr 
2c23			;		inc hl  
2c23			;		inc hl 
2c23			;		; skip len 
2c23			;		inc hl 
2c23			; 
2c23			;	if DEBUG_FORTH_WORDS 
2c23			;		DMARK "FGc" 
2c23			;		CALLMONITOR 
2c23			;	endif 
2c23			;		call strcmp 
2c23			;		jp nz, .fnuword 
2c23			 
2c23			 
2c23 e1			pop hl 
2c24			 
2c24				 
2c24				if DEBUG_FORTH_WORDS 
2c24					DMARK "FGm" 
2c24 f5				push af  
2c25 3a 39 2c			ld a, (.dmark)  
2c28 32 bd fb			ld (debug_mark),a  
2c2b 3a 3a 2c			ld a, (.dmark+1)  
2c2e 32 be fb			ld (debug_mark+1),a  
2c31 3a 3b 2c			ld a, (.dmark+2)  
2c34 32 bf fb			ld (debug_mark+2),a  
2c37 18 03			jr .pastdmark  
2c39 ..			.dmark: db "FGm"  
2c3c f1			.pastdmark: pop af  
2c3d			endm  
# End of macro DMARK
2c3d					CALLMONITOR 
2c3d cd 65 16			call break_point_state  
2c40				endm  
# End of macro CALLMONITOR
2c40				endif 
2c40			 
2c40			 
2c40			 
2c40					; we have a uword so push its name to the stack 
2c40			 
2c40			;	   	push hl  ; save so we can move to next dict block 
2c40			;pop hl 
2c40			 
2c40					; update opcode to deleted 
2c40 3e 03				ld a, WORD_SYS_DELETED 
2c42 77					ld (hl), a 
2c43			 
2c43 23					inc hl  
2c44					; skip next ptr 
2c44 23					inc hl  
2c45 23					inc hl 
2c46					; skip len 
2c46 23					inc hl 
2c47			 
2c47					; TODO change parser to skip deleted words but for now mark it out 
2c47 3e 5f				ld a, "_" 
2c49 77					ld  (hl),a 
2c4a			 
2c4a			;		jr .fudone 
2c4a			; 
2c4a			;.fnuword:	pop hl 
2c4a			;		call forth_tok_next 
2c4a			;		jp .fdouscan  
2c4a			 
2c4a			.flunotfound:		  
2c4a			 
2c4a			 
2c4a					 
2c4a					FORTH_DSP_POP 
2c4a cd a1 1e			call macro_forth_dsp_pop 
2c4d				endm 
# End of macro FORTH_DSP_POP
2c4d			;		ld hl, .luno 
2c4d			;.fudone:		 pop hl 
2c4d					NEXTW 
2c4d c3 5b 1f			jp macro_next 
2c50				endm 
# End of macro NEXTW
2c50			.NOP: 
2c50				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2c50 61				db WORD_SYS_CORE+77             
2c51 77 2c			dw .COMO            
2c53 04				db 3 + 1 
2c54 .. 00			db "NOP",0              
2c58				endm 
# End of macro CWHEAD
2c58			; | NOP (  --  ) Do nothing | DONE 
2c58					if DEBUG_FORTH_WORDS_KEY 
2c58						DMARK "NOP" 
2c58 f5				push af  
2c59 3a 6d 2c			ld a, (.dmark)  
2c5c 32 bd fb			ld (debug_mark),a  
2c5f 3a 6e 2c			ld a, (.dmark+1)  
2c62 32 be fb			ld (debug_mark+1),a  
2c65 3a 6f 2c			ld a, (.dmark+2)  
2c68 32 bf fb			ld (debug_mark+2),a  
2c6b 18 03			jr .pastdmark  
2c6d ..			.dmark: db "NOP"  
2c70 f1			.pastdmark: pop af  
2c71			endm  
# End of macro DMARK
2c71						CALLMONITOR 
2c71 cd 65 16			call break_point_state  
2c74				endm  
# End of macro CALLMONITOR
2c74					endif 
2c74				       NEXTW 
2c74 c3 5b 1f			jp macro_next 
2c77				endm 
# End of macro NEXTW
2c77			.COMO: 
2c77				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2c77 6e				db WORD_SYS_CORE+90             
2c78 c9 2c			dw .COMC            
2c7a 02				db 1 + 1 
2c7b .. 00			db "(",0              
2c7d				endm 
# End of macro CWHEAD
2c7d			; | ( ( -- )  Start of comment | DONE 
2c7d			 
2c7d			 
2c7d 2a a4 f2				ld hl, ( os_tok_ptr) 
2c80 11 c4 2c			ld de, .closepar 
2c83					 
2c83					if DEBUG_FORTH_WORDS 
2c83						DMARK ").." 
2c83 f5				push af  
2c84 3a 98 2c			ld a, (.dmark)  
2c87 32 bd fb			ld (debug_mark),a  
2c8a 3a 99 2c			ld a, (.dmark+1)  
2c8d 32 be fb			ld (debug_mark+1),a  
2c90 3a 9a 2c			ld a, (.dmark+2)  
2c93 32 bf fb			ld (debug_mark+2),a  
2c96 18 03			jr .pastdmark  
2c98 ..			.dmark: db ").."  
2c9b f1			.pastdmark: pop af  
2c9c			endm  
# End of macro DMARK
2c9c						CALLMONITOR 
2c9c cd 65 16			call break_point_state  
2c9f				endm  
# End of macro CALLMONITOR
2c9f					endif 
2c9f cd 76 20			call findnexttok  
2ca2			 
2ca2					if DEBUG_FORTH_WORDS 
2ca2						DMARK "IF5" 
2ca2 f5				push af  
2ca3 3a b7 2c			ld a, (.dmark)  
2ca6 32 bd fb			ld (debug_mark),a  
2ca9 3a b8 2c			ld a, (.dmark+1)  
2cac 32 be fb			ld (debug_mark+1),a  
2caf 3a b9 2c			ld a, (.dmark+2)  
2cb2 32 bf fb			ld (debug_mark+2),a  
2cb5 18 03			jr .pastdmark  
2cb7 ..			.dmark: db "IF5"  
2cba f1			.pastdmark: pop af  
2cbb			endm  
# End of macro DMARK
2cbb						CALLMONITOR 
2cbb cd 65 16			call break_point_state  
2cbe				endm  
# End of macro CALLMONITOR
2cbe					endif 
2cbe				; replace below with ) exec using tok_ptr 
2cbe 22 a4 f2			ld (os_tok_ptr), hl 
2cc1 c3 ec 1f			jp exec1 
2cc4			 
2cc4 .. 00			.closepar:   db ")",0 
2cc6			 
2cc6				       NEXTW 
2cc6 c3 5b 1f			jp macro_next 
2cc9				endm 
# End of macro NEXTW
2cc9			.COMC: 
2cc9				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2cc9 6f				db WORD_SYS_CORE+91             
2cca d2 2c			dw .SCRATCH            
2ccc 02				db 1 + 1 
2ccd .. 00			db ")",0              
2ccf				endm 
# End of macro CWHEAD
2ccf			; | ) ( -- )  End of comment |  DONE  
2ccf				       NEXTW 
2ccf c3 5b 1f			jp macro_next 
2cd2				endm 
# End of macro NEXTW
2cd2			 
2cd2			.SCRATCH: 
2cd2				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2cd2 6f				db WORD_SYS_CORE+91             
2cd3 0d 2d			dw .INC            
2cd5 08				db 7 + 1 
2cd6 .. 00			db "SCRATCH",0              
2cde				endm 
# End of macro CWHEAD
2cde			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2cde			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2cde			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2cde			; | |  
2cde			; | | e.g.    : score $00 scratch ; 
2cde			; | |  
2cde			; | | $00 score ! 
2cde			; | | $01 score +! 
2cde			; | |  
2cde			; | | e.g.   : varword $0a scratch ;  
2cde			; | | 
2cde			; | | $8000 varword ! 
2cde					if DEBUG_FORTH_WORDS_KEY 
2cde						DMARK "SCR" 
2cde f5				push af  
2cdf 3a f3 2c			ld a, (.dmark)  
2ce2 32 bd fb			ld (debug_mark),a  
2ce5 3a f4 2c			ld a, (.dmark+1)  
2ce8 32 be fb			ld (debug_mark+1),a  
2ceb 3a f5 2c			ld a, (.dmark+2)  
2cee 32 bf fb			ld (debug_mark+2),a  
2cf1 18 03			jr .pastdmark  
2cf3 ..			.dmark: db "SCR"  
2cf6 f1			.pastdmark: pop af  
2cf7			endm  
# End of macro DMARK
2cf7						CALLMONITOR 
2cf7 cd 65 16			call break_point_state  
2cfa				endm  
# End of macro CALLMONITOR
2cfa					endif 
2cfa			 
2cfa					FORTH_DSP_VALUEHL 
2cfa cd e9 1d			call macro_dsp_valuehl 
2cfd				endm 
# End of macro FORTH_DSP_VALUEHL
2cfd				 
2cfd					FORTH_DSP_POP 
2cfd cd a1 1e			call macro_forth_dsp_pop 
2d00				endm 
# End of macro FORTH_DSP_POP
2d00			 
2d00 7d					ld a, l 
2d01 21 c8 f4				ld hl, os_var_array 
2d04 cd 06 0d				call addatohl 
2d07			 
2d07 cd f2 1b				call forth_push_numhl 
2d0a			 
2d0a				       NEXTW 
2d0a c3 5b 1f			jp macro_next 
2d0d				endm 
# End of macro NEXTW
2d0d			 
2d0d			.INC: 
2d0d				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2d0d 6f				db WORD_SYS_CORE+91             
2d0e 61 2d			dw .DEC            
2d10 03				db 2 + 1 
2d11 .. 00			db "+!",0              
2d14				endm 
# End of macro CWHEAD
2d14			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2d14					if DEBUG_FORTH_WORDS_KEY 
2d14						DMARK "+s_" 
2d14 f5				push af  
2d15 3a 29 2d			ld a, (.dmark)  
2d18 32 bd fb			ld (debug_mark),a  
2d1b 3a 2a 2d			ld a, (.dmark+1)  
2d1e 32 be fb			ld (debug_mark+1),a  
2d21 3a 2b 2d			ld a, (.dmark+2)  
2d24 32 bf fb			ld (debug_mark+2),a  
2d27 18 03			jr .pastdmark  
2d29 ..			.dmark: db "+s_"  
2d2c f1			.pastdmark: pop af  
2d2d			endm  
# End of macro DMARK
2d2d						CALLMONITOR 
2d2d cd 65 16			call break_point_state  
2d30				endm  
# End of macro CALLMONITOR
2d30					endif 
2d30			 
2d30					FORTH_DSP_VALUEHL 
2d30 cd e9 1d			call macro_dsp_valuehl 
2d33				endm 
# End of macro FORTH_DSP_VALUEHL
2d33			 
2d33 e5					push hl   ; save address 
2d34			 
2d34					FORTH_DSP_POP 
2d34 cd a1 1e			call macro_forth_dsp_pop 
2d37				endm 
# End of macro FORTH_DSP_POP
2d37			 
2d37					FORTH_DSP_VALUEHL 
2d37 cd e9 1d			call macro_dsp_valuehl 
2d3a				endm 
# End of macro FORTH_DSP_VALUEHL
2d3a			 
2d3a					FORTH_DSP_POP 
2d3a cd a1 1e			call macro_forth_dsp_pop 
2d3d				endm 
# End of macro FORTH_DSP_POP
2d3d			 
2d3d					; hl contains value to add to byte at a 
2d3d				 
2d3d eb					ex de, hl 
2d3e			 
2d3e e1					pop hl 
2d3f			 
2d3f					if DEBUG_FORTH_WORDS 
2d3f						DMARK "INC" 
2d3f f5				push af  
2d40 3a 54 2d			ld a, (.dmark)  
2d43 32 bd fb			ld (debug_mark),a  
2d46 3a 55 2d			ld a, (.dmark+1)  
2d49 32 be fb			ld (debug_mark+1),a  
2d4c 3a 56 2d			ld a, (.dmark+2)  
2d4f 32 bf fb			ld (debug_mark+2),a  
2d52 18 03			jr .pastdmark  
2d54 ..			.dmark: db "INC"  
2d57 f1			.pastdmark: pop af  
2d58			endm  
# End of macro DMARK
2d58						CALLMONITOR 
2d58 cd 65 16			call break_point_state  
2d5b				endm  
# End of macro CALLMONITOR
2d5b					endif 
2d5b			 
2d5b 7e					ld a,(hl) 
2d5c 83					add e 
2d5d 77					ld (hl),a 
2d5e			 
2d5e			 
2d5e			 
2d5e				       NEXTW 
2d5e c3 5b 1f			jp macro_next 
2d61				endm 
# End of macro NEXTW
2d61			 
2d61			.DEC: 
2d61				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2d61 6f				db WORD_SYS_CORE+91             
2d62 b2 2d			dw .INC2            
2d64 03				db 2 + 1 
2d65 .. 00			db "-!",0              
2d68				endm 
# End of macro CWHEAD
2d68			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2d68					if DEBUG_FORTH_WORDS_KEY 
2d68						DMARK "-s_" 
2d68 f5				push af  
2d69 3a 7d 2d			ld a, (.dmark)  
2d6c 32 bd fb			ld (debug_mark),a  
2d6f 3a 7e 2d			ld a, (.dmark+1)  
2d72 32 be fb			ld (debug_mark+1),a  
2d75 3a 7f 2d			ld a, (.dmark+2)  
2d78 32 bf fb			ld (debug_mark+2),a  
2d7b 18 03			jr .pastdmark  
2d7d ..			.dmark: db "-s_"  
2d80 f1			.pastdmark: pop af  
2d81			endm  
# End of macro DMARK
2d81						CALLMONITOR 
2d81 cd 65 16			call break_point_state  
2d84				endm  
# End of macro CALLMONITOR
2d84					endif 
2d84			 
2d84					FORTH_DSP_VALUEHL 
2d84 cd e9 1d			call macro_dsp_valuehl 
2d87				endm 
# End of macro FORTH_DSP_VALUEHL
2d87			 
2d87 e5					push hl   ; save address 
2d88			 
2d88					FORTH_DSP_POP 
2d88 cd a1 1e			call macro_forth_dsp_pop 
2d8b				endm 
# End of macro FORTH_DSP_POP
2d8b			 
2d8b					FORTH_DSP_VALUEHL 
2d8b cd e9 1d			call macro_dsp_valuehl 
2d8e				endm 
# End of macro FORTH_DSP_VALUEHL
2d8e			 
2d8e					; hl contains value to add to byte at a 
2d8e				 
2d8e eb					ex de, hl 
2d8f			 
2d8f e1					pop hl 
2d90			 
2d90					if DEBUG_FORTH_WORDS 
2d90						DMARK "DEC" 
2d90 f5				push af  
2d91 3a a5 2d			ld a, (.dmark)  
2d94 32 bd fb			ld (debug_mark),a  
2d97 3a a6 2d			ld a, (.dmark+1)  
2d9a 32 be fb			ld (debug_mark+1),a  
2d9d 3a a7 2d			ld a, (.dmark+2)  
2da0 32 bf fb			ld (debug_mark+2),a  
2da3 18 03			jr .pastdmark  
2da5 ..			.dmark: db "DEC"  
2da8 f1			.pastdmark: pop af  
2da9			endm  
# End of macro DMARK
2da9						CALLMONITOR 
2da9 cd 65 16			call break_point_state  
2dac				endm  
# End of macro CALLMONITOR
2dac					endif 
2dac			 
2dac 7e					ld a,(hl) 
2dad 93					sub e 
2dae 77					ld (hl),a 
2daf			 
2daf			 
2daf			 
2daf				       NEXTW 
2daf c3 5b 1f			jp macro_next 
2db2				endm 
# End of macro NEXTW
2db2			 
2db2			.INC2: 
2db2				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2db2 6f				db WORD_SYS_CORE+91             
2db3 5c 2e			dw .DEC2            
2db5 04				db 3 + 1 
2db6 .. 00			db "+2!",0              
2dba				endm 
# End of macro CWHEAD
2dba			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2dba			 
2dba					if DEBUG_FORTH_WORDS_KEY 
2dba						DMARK "+2s" 
2dba f5				push af  
2dbb 3a cf 2d			ld a, (.dmark)  
2dbe 32 bd fb			ld (debug_mark),a  
2dc1 3a d0 2d			ld a, (.dmark+1)  
2dc4 32 be fb			ld (debug_mark+1),a  
2dc7 3a d1 2d			ld a, (.dmark+2)  
2dca 32 bf fb			ld (debug_mark+2),a  
2dcd 18 03			jr .pastdmark  
2dcf ..			.dmark: db "+2s"  
2dd2 f1			.pastdmark: pop af  
2dd3			endm  
# End of macro DMARK
2dd3						CALLMONITOR 
2dd3 cd 65 16			call break_point_state  
2dd6				endm  
# End of macro CALLMONITOR
2dd6					endif 
2dd6			 
2dd6					; Address 
2dd6			 
2dd6					FORTH_DSP_VALUEHL 
2dd6 cd e9 1d			call macro_dsp_valuehl 
2dd9				endm 
# End of macro FORTH_DSP_VALUEHL
2dd9			 
2dd9 e5					push hl    ; save address 
2dda			 
2dda					; load content into de 
2dda			 
2dda 5e					ld e,(hl) 
2ddb 23					inc hl 
2ddc 56					ld d, (hl) 
2ddd			 
2ddd					if DEBUG_FORTH_WORDS 
2ddd						DMARK "+2a" 
2ddd f5				push af  
2dde 3a f2 2d			ld a, (.dmark)  
2de1 32 bd fb			ld (debug_mark),a  
2de4 3a f3 2d			ld a, (.dmark+1)  
2de7 32 be fb			ld (debug_mark+1),a  
2dea 3a f4 2d			ld a, (.dmark+2)  
2ded 32 bf fb			ld (debug_mark+2),a  
2df0 18 03			jr .pastdmark  
2df2 ..			.dmark: db "+2a"  
2df5 f1			.pastdmark: pop af  
2df6			endm  
# End of macro DMARK
2df6						CALLMONITOR 
2df6 cd 65 16			call break_point_state  
2df9				endm  
# End of macro CALLMONITOR
2df9					endif 
2df9			 
2df9					FORTH_DSP_POP 
2df9 cd a1 1e			call macro_forth_dsp_pop 
2dfc				endm 
# End of macro FORTH_DSP_POP
2dfc			 
2dfc					; Get value to add 
2dfc			 
2dfc					FORTH_DSP_VALUE 
2dfc cd d2 1d			call macro_forth_dsp_value 
2dff				endm 
# End of macro FORTH_DSP_VALUE
2dff			 
2dff					if DEBUG_FORTH_WORDS 
2dff						DMARK "+2v" 
2dff f5				push af  
2e00 3a 14 2e			ld a, (.dmark)  
2e03 32 bd fb			ld (debug_mark),a  
2e06 3a 15 2e			ld a, (.dmark+1)  
2e09 32 be fb			ld (debug_mark+1),a  
2e0c 3a 16 2e			ld a, (.dmark+2)  
2e0f 32 bf fb			ld (debug_mark+2),a  
2e12 18 03			jr .pastdmark  
2e14 ..			.dmark: db "+2v"  
2e17 f1			.pastdmark: pop af  
2e18			endm  
# End of macro DMARK
2e18						CALLMONITOR 
2e18 cd 65 16			call break_point_state  
2e1b				endm  
# End of macro CALLMONITOR
2e1b					endif 
2e1b			 
2e1b 19					add hl, de 
2e1c			 
2e1c					if DEBUG_FORTH_WORDS 
2e1c						DMARK "+2+" 
2e1c f5				push af  
2e1d 3a 31 2e			ld a, (.dmark)  
2e20 32 bd fb			ld (debug_mark),a  
2e23 3a 32 2e			ld a, (.dmark+1)  
2e26 32 be fb			ld (debug_mark+1),a  
2e29 3a 33 2e			ld a, (.dmark+2)  
2e2c 32 bf fb			ld (debug_mark+2),a  
2e2f 18 03			jr .pastdmark  
2e31 ..			.dmark: db "+2+"  
2e34 f1			.pastdmark: pop af  
2e35			endm  
# End of macro DMARK
2e35						CALLMONITOR 
2e35 cd 65 16			call break_point_state  
2e38				endm  
# End of macro CALLMONITOR
2e38					endif 
2e38			 
2e38					; move result to de 
2e38			 
2e38 eb					ex de, hl 
2e39			 
2e39					; Address 
2e39			 
2e39 e1					pop hl 
2e3a			 
2e3a					; save it back 
2e3a			 
2e3a 73					ld (hl), e 
2e3b 23					inc hl 
2e3c 72					ld (hl), d 
2e3d			 
2e3d					if DEBUG_FORTH_WORDS 
2e3d						DMARK "+2e" 
2e3d f5				push af  
2e3e 3a 52 2e			ld a, (.dmark)  
2e41 32 bd fb			ld (debug_mark),a  
2e44 3a 53 2e			ld a, (.dmark+1)  
2e47 32 be fb			ld (debug_mark+1),a  
2e4a 3a 54 2e			ld a, (.dmark+2)  
2e4d 32 bf fb			ld (debug_mark+2),a  
2e50 18 03			jr .pastdmark  
2e52 ..			.dmark: db "+2e"  
2e55 f1			.pastdmark: pop af  
2e56			endm  
# End of macro DMARK
2e56						CALLMONITOR 
2e56 cd 65 16			call break_point_state  
2e59				endm  
# End of macro CALLMONITOR
2e59					endif 
2e59			 
2e59			 
2e59			 
2e59			 
2e59			 
2e59				       NEXTW 
2e59 c3 5b 1f			jp macro_next 
2e5c				endm 
# End of macro NEXTW
2e5c			 
2e5c			.DEC2: 
2e5c				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2e5c 6f				db WORD_SYS_CORE+91             
2e5d 08 2f			dw .GET2            
2e5f 04				db 3 + 1 
2e60 .. 00			db "-2!",0              
2e64				endm 
# End of macro CWHEAD
2e64			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2e64			 
2e64			 
2e64					if DEBUG_FORTH_WORDS_KEY 
2e64						DMARK "-2s" 
2e64 f5				push af  
2e65 3a 79 2e			ld a, (.dmark)  
2e68 32 bd fb			ld (debug_mark),a  
2e6b 3a 7a 2e			ld a, (.dmark+1)  
2e6e 32 be fb			ld (debug_mark+1),a  
2e71 3a 7b 2e			ld a, (.dmark+2)  
2e74 32 bf fb			ld (debug_mark+2),a  
2e77 18 03			jr .pastdmark  
2e79 ..			.dmark: db "-2s"  
2e7c f1			.pastdmark: pop af  
2e7d			endm  
# End of macro DMARK
2e7d						CALLMONITOR 
2e7d cd 65 16			call break_point_state  
2e80				endm  
# End of macro CALLMONITOR
2e80					endif 
2e80			 
2e80					; Address 
2e80			 
2e80					FORTH_DSP_VALUEHL 
2e80 cd e9 1d			call macro_dsp_valuehl 
2e83				endm 
# End of macro FORTH_DSP_VALUEHL
2e83			 
2e83 e5					push hl    ; save address 
2e84			 
2e84					; load content into de 
2e84			 
2e84 5e					ld e,(hl) 
2e85 23					inc hl 
2e86 56					ld d, (hl) 
2e87			 
2e87					if DEBUG_FORTH_WORDS 
2e87						DMARK "-2a" 
2e87 f5				push af  
2e88 3a 9c 2e			ld a, (.dmark)  
2e8b 32 bd fb			ld (debug_mark),a  
2e8e 3a 9d 2e			ld a, (.dmark+1)  
2e91 32 be fb			ld (debug_mark+1),a  
2e94 3a 9e 2e			ld a, (.dmark+2)  
2e97 32 bf fb			ld (debug_mark+2),a  
2e9a 18 03			jr .pastdmark  
2e9c ..			.dmark: db "-2a"  
2e9f f1			.pastdmark: pop af  
2ea0			endm  
# End of macro DMARK
2ea0						CALLMONITOR 
2ea0 cd 65 16			call break_point_state  
2ea3				endm  
# End of macro CALLMONITOR
2ea3					endif 
2ea3			 
2ea3					FORTH_DSP_POP 
2ea3 cd a1 1e			call macro_forth_dsp_pop 
2ea6				endm 
# End of macro FORTH_DSP_POP
2ea6			 
2ea6					; Get value to remove 
2ea6			 
2ea6					FORTH_DSP_VALUE 
2ea6 cd d2 1d			call macro_forth_dsp_value 
2ea9				endm 
# End of macro FORTH_DSP_VALUE
2ea9			 
2ea9					if DEBUG_FORTH_WORDS 
2ea9						DMARK "-2v" 
2ea9 f5				push af  
2eaa 3a be 2e			ld a, (.dmark)  
2ead 32 bd fb			ld (debug_mark),a  
2eb0 3a bf 2e			ld a, (.dmark+1)  
2eb3 32 be fb			ld (debug_mark+1),a  
2eb6 3a c0 2e			ld a, (.dmark+2)  
2eb9 32 bf fb			ld (debug_mark+2),a  
2ebc 18 03			jr .pastdmark  
2ebe ..			.dmark: db "-2v"  
2ec1 f1			.pastdmark: pop af  
2ec2			endm  
# End of macro DMARK
2ec2						CALLMONITOR 
2ec2 cd 65 16			call break_point_state  
2ec5				endm  
# End of macro CALLMONITOR
2ec5					endif 
2ec5			 
2ec5 eb					ex de, hl 
2ec6 ed 52				sbc hl, de 
2ec8			 
2ec8					if DEBUG_FORTH_WORDS 
2ec8						DMARK "-2d" 
2ec8 f5				push af  
2ec9 3a dd 2e			ld a, (.dmark)  
2ecc 32 bd fb			ld (debug_mark),a  
2ecf 3a de 2e			ld a, (.dmark+1)  
2ed2 32 be fb			ld (debug_mark+1),a  
2ed5 3a df 2e			ld a, (.dmark+2)  
2ed8 32 bf fb			ld (debug_mark+2),a  
2edb 18 03			jr .pastdmark  
2edd ..			.dmark: db "-2d"  
2ee0 f1			.pastdmark: pop af  
2ee1			endm  
# End of macro DMARK
2ee1						CALLMONITOR 
2ee1 cd 65 16			call break_point_state  
2ee4				endm  
# End of macro CALLMONITOR
2ee4					endif 
2ee4			 
2ee4					; move result to de 
2ee4			 
2ee4 eb					ex de, hl 
2ee5			 
2ee5					; Address 
2ee5			 
2ee5 e1					pop hl 
2ee6			 
2ee6					; save it back 
2ee6			 
2ee6 73					ld (hl), e 
2ee7 23					inc hl 
2ee8 72					ld (hl), d 
2ee9			 
2ee9					if DEBUG_FORTH_WORDS 
2ee9						DMARK "-2e" 
2ee9 f5				push af  
2eea 3a fe 2e			ld a, (.dmark)  
2eed 32 bd fb			ld (debug_mark),a  
2ef0 3a ff 2e			ld a, (.dmark+1)  
2ef3 32 be fb			ld (debug_mark+1),a  
2ef6 3a 00 2f			ld a, (.dmark+2)  
2ef9 32 bf fb			ld (debug_mark+2),a  
2efc 18 03			jr .pastdmark  
2efe ..			.dmark: db "-2e"  
2f01 f1			.pastdmark: pop af  
2f02			endm  
# End of macro DMARK
2f02						CALLMONITOR 
2f02 cd 65 16			call break_point_state  
2f05				endm  
# End of macro CALLMONITOR
2f05					endif 
2f05			 
2f05			 
2f05			 
2f05			 
2f05			 
2f05				       NEXTW 
2f05 c3 5b 1f			jp macro_next 
2f08				endm 
# End of macro NEXTW
2f08			.GET2: 
2f08				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2f08 6f				db WORD_SYS_CORE+91             
2f09 38 2f			dw .BANG2            
2f0b 03				db 2 + 1 
2f0c .. 00			db "2@",0              
2f0f				endm 
# End of macro CWHEAD
2f0f			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2f0f					if DEBUG_FORTH_WORDS_KEY 
2f0f						DMARK "2A_" 
2f0f f5				push af  
2f10 3a 24 2f			ld a, (.dmark)  
2f13 32 bd fb			ld (debug_mark),a  
2f16 3a 25 2f			ld a, (.dmark+1)  
2f19 32 be fb			ld (debug_mark+1),a  
2f1c 3a 26 2f			ld a, (.dmark+2)  
2f1f 32 bf fb			ld (debug_mark+2),a  
2f22 18 03			jr .pastdmark  
2f24 ..			.dmark: db "2A_"  
2f27 f1			.pastdmark: pop af  
2f28			endm  
# End of macro DMARK
2f28						CALLMONITOR 
2f28 cd 65 16			call break_point_state  
2f2b				endm  
# End of macro CALLMONITOR
2f2b					endif 
2f2b			 
2f2b					FORTH_DSP_VALUEHL 
2f2b cd e9 1d			call macro_dsp_valuehl 
2f2e				endm 
# End of macro FORTH_DSP_VALUEHL
2f2e			 
2f2e 5e					ld e, (hl) 
2f2f 23					inc hl 
2f30 56					ld d, (hl) 
2f31			 
2f31 eb					ex de, hl 
2f32			 
2f32 cd f2 1b				call forth_push_numhl 
2f35			 
2f35				       NEXTW 
2f35 c3 5b 1f			jp macro_next 
2f38				endm 
# End of macro NEXTW
2f38			.BANG2: 
2f38				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2f38 6f				db WORD_SYS_CORE+91             
2f39 70 2f			dw .CONFIG            
2f3b 03				db 2 + 1 
2f3c .. 00			db "2!",0              
2f3f				endm 
# End of macro CWHEAD
2f3f			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2f3f					if DEBUG_FORTH_WORDS_KEY 
2f3f						DMARK "2S_" 
2f3f f5				push af  
2f40 3a 54 2f			ld a, (.dmark)  
2f43 32 bd fb			ld (debug_mark),a  
2f46 3a 55 2f			ld a, (.dmark+1)  
2f49 32 be fb			ld (debug_mark+1),a  
2f4c 3a 56 2f			ld a, (.dmark+2)  
2f4f 32 bf fb			ld (debug_mark+2),a  
2f52 18 03			jr .pastdmark  
2f54 ..			.dmark: db "2S_"  
2f57 f1			.pastdmark: pop af  
2f58			endm  
# End of macro DMARK
2f58						CALLMONITOR 
2f58 cd 65 16			call break_point_state  
2f5b				endm  
# End of macro CALLMONITOR
2f5b					endif 
2f5b			 
2f5b					FORTH_DSP_VALUEHL 
2f5b cd e9 1d			call macro_dsp_valuehl 
2f5e				endm 
# End of macro FORTH_DSP_VALUEHL
2f5e			 
2f5e e5					push hl   ; save address 
2f5f			 
2f5f			 
2f5f					FORTH_DSP_POP 
2f5f cd a1 1e			call macro_forth_dsp_pop 
2f62				endm 
# End of macro FORTH_DSP_POP
2f62			 
2f62					 
2f62					FORTH_DSP_VALUEHL 
2f62 cd e9 1d			call macro_dsp_valuehl 
2f65				endm 
# End of macro FORTH_DSP_VALUEHL
2f65			 
2f65					FORTH_DSP_POP 
2f65 cd a1 1e			call macro_forth_dsp_pop 
2f68				endm 
# End of macro FORTH_DSP_POP
2f68			 
2f68 eb					ex de, hl    ; value now in de 
2f69			 
2f69 e1					pop hl 
2f6a			 
2f6a 73					ld (hl), e 
2f6b			 
2f6b 23					inc hl 
2f6c			 
2f6c 72					ld (hl), d 
2f6d			 
2f6d			 
2f6d				       NEXTW 
2f6d c3 5b 1f			jp macro_next 
2f70				endm 
# End of macro NEXTW
2f70			.CONFIG: 
2f70				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2f70 6f				db WORD_SYS_CORE+91             
2f71 81 2f			dw .ENDCORE            
2f73 07				db 6 + 1 
2f74 .. 00			db "CONFIG",0              
2f7b				endm 
# End of macro CWHEAD
2f7b			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
2f7b			 
2f7b cd 66 13				call config 
2f7e					NEXTW 
2f7e c3 5b 1f			jp macro_next 
2f81				endm 
# End of macro NEXTW
2f81			.ENDCORE: 
2f81			 
2f81			; eof 
2f81			 
2f81			 
# End of file forth_words_core.asm
2f81			include "forth_words_flow.asm" 
2f81			 
2f81			; | ## Program Flow Words 
2f81			 
2f81			.IF: 
2f81				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f81 1e				db WORD_SYS_CORE+10             
2f82 76 30			dw .THEN            
2f84 03				db 2 + 1 
2f85 .. 00			db "IF",0              
2f88				endm 
# End of macro CWHEAD
2f88			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f88			; 
2f88					if DEBUG_FORTH_WORDS_KEY 
2f88						DMARK "IF." 
2f88 f5				push af  
2f89 3a 9d 2f			ld a, (.dmark)  
2f8c 32 bd fb			ld (debug_mark),a  
2f8f 3a 9e 2f			ld a, (.dmark+1)  
2f92 32 be fb			ld (debug_mark+1),a  
2f95 3a 9f 2f			ld a, (.dmark+2)  
2f98 32 bf fb			ld (debug_mark+2),a  
2f9b 18 03			jr .pastdmark  
2f9d ..			.dmark: db "IF."  
2fa0 f1			.pastdmark: pop af  
2fa1			endm  
# End of macro DMARK
2fa1						CALLMONITOR 
2fa1 cd 65 16			call break_point_state  
2fa4				endm  
# End of macro CALLMONITOR
2fa4					endif 
2fa4			; eval TOS 
2fa4			 
2fa4				FORTH_DSP_VALUEHL 
2fa4 cd e9 1d			call macro_dsp_valuehl 
2fa7				endm 
# End of macro FORTH_DSP_VALUEHL
2fa7			 
2fa7			;	push hl 
2fa7				FORTH_DSP_POP 
2fa7 cd a1 1e			call macro_forth_dsp_pop 
2faa				endm 
# End of macro FORTH_DSP_POP
2faa			;	pop hl 
2faa			 
2faa					if DEBUG_FORTH_WORDS 
2faa						DMARK "IF1" 
2faa f5				push af  
2fab 3a bf 2f			ld a, (.dmark)  
2fae 32 bd fb			ld (debug_mark),a  
2fb1 3a c0 2f			ld a, (.dmark+1)  
2fb4 32 be fb			ld (debug_mark+1),a  
2fb7 3a c1 2f			ld a, (.dmark+2)  
2fba 32 bf fb			ld (debug_mark+2),a  
2fbd 18 03			jr .pastdmark  
2fbf ..			.dmark: db "IF1"  
2fc2 f1			.pastdmark: pop af  
2fc3			endm  
# End of macro DMARK
2fc3						CALLMONITOR 
2fc3 cd 65 16			call break_point_state  
2fc6				endm  
# End of macro CALLMONITOR
2fc6					endif 
2fc6 b7				or a        ; clear carry flag 
2fc7 11 00 00			ld de, 0 
2fca eb				ex de,hl 
2fcb ed 52			sbc hl, de 
2fcd c2 57 30			jp nz, .iftrue 
2fd0			 
2fd0					if DEBUG_FORTH_WORDS 
2fd0						DMARK "IF2" 
2fd0 f5				push af  
2fd1 3a e5 2f			ld a, (.dmark)  
2fd4 32 bd fb			ld (debug_mark),a  
2fd7 3a e6 2f			ld a, (.dmark+1)  
2fda 32 be fb			ld (debug_mark+1),a  
2fdd 3a e7 2f			ld a, (.dmark+2)  
2fe0 32 bf fb			ld (debug_mark+2),a  
2fe3 18 03			jr .pastdmark  
2fe5 ..			.dmark: db "IF2"  
2fe8 f1			.pastdmark: pop af  
2fe9			endm  
# End of macro DMARK
2fe9						CALLMONITOR 
2fe9 cd 65 16			call break_point_state  
2fec				endm  
# End of macro CALLMONITOR
2fec					endif 
2fec			 
2fec			; if not true then skip to THEN 
2fec			 
2fec				; TODO get tok_ptr 
2fec				; TODO consume toks until we get to THEN 
2fec			 
2fec 2a a4 f2			ld hl, (os_tok_ptr) 
2fef					if DEBUG_FORTH_WORDS 
2fef						DMARK "IF3" 
2fef f5				push af  
2ff0 3a 04 30			ld a, (.dmark)  
2ff3 32 bd fb			ld (debug_mark),a  
2ff6 3a 05 30			ld a, (.dmark+1)  
2ff9 32 be fb			ld (debug_mark+1),a  
2ffc 3a 06 30			ld a, (.dmark+2)  
2fff 32 bf fb			ld (debug_mark+2),a  
3002 18 03			jr .pastdmark  
3004 ..			.dmark: db "IF3"  
3007 f1			.pastdmark: pop af  
3008			endm  
# End of macro DMARK
3008						CALLMONITOR 
3008 cd 65 16			call break_point_state  
300b				endm  
# End of macro CALLMONITOR
300b						 
300b					endif 
300b 11 52 30			ld de, .ifthen 
300e					if DEBUG_FORTH_WORDS 
300e						DMARK "IF4" 
300e f5				push af  
300f 3a 23 30			ld a, (.dmark)  
3012 32 bd fb			ld (debug_mark),a  
3015 3a 24 30			ld a, (.dmark+1)  
3018 32 be fb			ld (debug_mark+1),a  
301b 3a 25 30			ld a, (.dmark+2)  
301e 32 bf fb			ld (debug_mark+2),a  
3021 18 03			jr .pastdmark  
3023 ..			.dmark: db "IF4"  
3026 f1			.pastdmark: pop af  
3027			endm  
# End of macro DMARK
3027						CALLMONITOR 
3027 cd 65 16			call break_point_state  
302a				endm  
# End of macro CALLMONITOR
302a					endif 
302a cd 76 20			call findnexttok  
302d			 
302d					if DEBUG_FORTH_WORDS 
302d						DMARK "IF5" 
302d f5				push af  
302e 3a 42 30			ld a, (.dmark)  
3031 32 bd fb			ld (debug_mark),a  
3034 3a 43 30			ld a, (.dmark+1)  
3037 32 be fb			ld (debug_mark+1),a  
303a 3a 44 30			ld a, (.dmark+2)  
303d 32 bf fb			ld (debug_mark+2),a  
3040 18 03			jr .pastdmark  
3042 ..			.dmark: db "IF5"  
3045 f1			.pastdmark: pop af  
3046			endm  
# End of macro DMARK
3046						CALLMONITOR 
3046 cd 65 16			call break_point_state  
3049				endm  
# End of macro CALLMONITOR
3049					endif 
3049				; TODO replace below with ; exec using tok_ptr 
3049 22 a4 f2			ld (os_tok_ptr), hl 
304c c3 ec 1f			jp exec1 
304f				NEXTW 
304f c3 5b 1f			jp macro_next 
3052				endm 
# End of macro NEXTW
3052			 
3052 .. 00		.ifthen:  db "THEN",0 
3057			 
3057			.iftrue:		 
3057				; Exec next words normally 
3057			 
3057				; if true then exec following IF as normal 
3057					if DEBUG_FORTH_WORDS 
3057						DMARK "IFT" 
3057 f5				push af  
3058 3a 6c 30			ld a, (.dmark)  
305b 32 bd fb			ld (debug_mark),a  
305e 3a 6d 30			ld a, (.dmark+1)  
3061 32 be fb			ld (debug_mark+1),a  
3064 3a 6e 30			ld a, (.dmark+2)  
3067 32 bf fb			ld (debug_mark+2),a  
306a 18 03			jr .pastdmark  
306c ..			.dmark: db "IFT"  
306f f1			.pastdmark: pop af  
3070			endm  
# End of macro DMARK
3070						CALLMONITOR 
3070 cd 65 16			call break_point_state  
3073				endm  
# End of macro CALLMONITOR
3073					endif 
3073			 
3073					NEXTW 
3073 c3 5b 1f			jp macro_next 
3076				endm 
# End of macro NEXTW
3076			.THEN: 
3076				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3076 1f				db WORD_SYS_CORE+11             
3077 9e 30			dw .ELSE            
3079 05				db 4 + 1 
307a .. 00			db "THEN",0              
307f				endm 
# End of macro CWHEAD
307f			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
307f					if DEBUG_FORTH_WORDS_KEY 
307f						DMARK "THN" 
307f f5				push af  
3080 3a 94 30			ld a, (.dmark)  
3083 32 bd fb			ld (debug_mark),a  
3086 3a 95 30			ld a, (.dmark+1)  
3089 32 be fb			ld (debug_mark+1),a  
308c 3a 96 30			ld a, (.dmark+2)  
308f 32 bf fb			ld (debug_mark+2),a  
3092 18 03			jr .pastdmark  
3094 ..			.dmark: db "THN"  
3097 f1			.pastdmark: pop af  
3098			endm  
# End of macro DMARK
3098						CALLMONITOR 
3098 cd 65 16			call break_point_state  
309b				endm  
# End of macro CALLMONITOR
309b					endif 
309b					NEXTW 
309b c3 5b 1f			jp macro_next 
309e				endm 
# End of macro NEXTW
309e			.ELSE: 
309e				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
309e 20				db WORD_SYS_CORE+12             
309f c6 30			dw .DO            
30a1 03				db 2 + 1 
30a2 .. 00			db "ELSE",0              
30a7				endm 
# End of macro CWHEAD
30a7			; | ELSE ( -- ) Not supported - does nothing | TODO 
30a7			 
30a7					if DEBUG_FORTH_WORDS_KEY 
30a7						DMARK "ELS" 
30a7 f5				push af  
30a8 3a bc 30			ld a, (.dmark)  
30ab 32 bd fb			ld (debug_mark),a  
30ae 3a bd 30			ld a, (.dmark+1)  
30b1 32 be fb			ld (debug_mark+1),a  
30b4 3a be 30			ld a, (.dmark+2)  
30b7 32 bf fb			ld (debug_mark+2),a  
30ba 18 03			jr .pastdmark  
30bc ..			.dmark: db "ELS"  
30bf f1			.pastdmark: pop af  
30c0			endm  
# End of macro DMARK
30c0						CALLMONITOR 
30c0 cd 65 16			call break_point_state  
30c3				endm  
# End of macro CALLMONITOR
30c3					endif 
30c3			 
30c3			 
30c3					NEXTW 
30c3 c3 5b 1f			jp macro_next 
30c6				endm 
# End of macro NEXTW
30c6			.DO: 
30c6				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
30c6 21				db WORD_SYS_CORE+13             
30c7 ed 31			dw .LOOP            
30c9 03				db 2 + 1 
30ca .. 00			db "DO",0              
30cd				endm 
# End of macro CWHEAD
30cd			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
30cd			 
30cd					if DEBUG_FORTH_WORDS_KEY 
30cd						DMARK "DO." 
30cd f5				push af  
30ce 3a e2 30			ld a, (.dmark)  
30d1 32 bd fb			ld (debug_mark),a  
30d4 3a e3 30			ld a, (.dmark+1)  
30d7 32 be fb			ld (debug_mark+1),a  
30da 3a e4 30			ld a, (.dmark+2)  
30dd 32 bf fb			ld (debug_mark+2),a  
30e0 18 03			jr .pastdmark  
30e2 ..			.dmark: db "DO."  
30e5 f1			.pastdmark: pop af  
30e6			endm  
# End of macro DMARK
30e6						CALLMONITOR 
30e6 cd 65 16			call break_point_state  
30e9				endm  
# End of macro CALLMONITOR
30e9					endif 
30e9			;  push pc to rsp stack past the DO 
30e9			 
30e9 2a a4 f2				ld hl, (os_tok_ptr) 
30ec 23					inc hl   ; D 
30ed 23					inc hl  ; O 
30ee 23					inc hl   ; null 
30ef					if DEBUG_FORTH_WORDS 
30ef						DMARK "DO2" 
30ef f5				push af  
30f0 3a 04 31			ld a, (.dmark)  
30f3 32 bd fb			ld (debug_mark),a  
30f6 3a 05 31			ld a, (.dmark+1)  
30f9 32 be fb			ld (debug_mark+1),a  
30fc 3a 06 31			ld a, (.dmark+2)  
30ff 32 bf fb			ld (debug_mark+2),a  
3102 18 03			jr .pastdmark  
3104 ..			.dmark: db "DO2"  
3107 f1			.pastdmark: pop af  
3108			endm  
# End of macro DMARK
3108						CALLMONITOR 
3108 cd 65 16			call break_point_state  
310b				endm  
# End of macro CALLMONITOR
310b					endif 
310b					FORTH_RSP_NEXT 
310b cd 99 1b			call macro_forth_rsp_next 
310e				endm 
# End of macro FORTH_RSP_NEXT
310e					if DEBUG_FORTH_WORDS 
310e						DMARK "DO3" 
310e f5				push af  
310f 3a 23 31			ld a, (.dmark)  
3112 32 bd fb			ld (debug_mark),a  
3115 3a 24 31			ld a, (.dmark+1)  
3118 32 be fb			ld (debug_mark+1),a  
311b 3a 25 31			ld a, (.dmark+2)  
311e 32 bf fb			ld (debug_mark+2),a  
3121 18 03			jr .pastdmark  
3123 ..			.dmark: db "DO3"  
3126 f1			.pastdmark: pop af  
3127			endm  
# End of macro DMARK
3127						CALLMONITOR 
3127 cd 65 16			call break_point_state  
312a				endm  
# End of macro CALLMONITOR
312a					endif 
312a			 
312a					;if DEBUG_FORTH_WORDS 
312a				;		push hl 
312a			;		endif  
312a			 
312a			; get counters from data stack 
312a			 
312a			 
312a					FORTH_DSP_VALUEHL 
312a cd e9 1d			call macro_dsp_valuehl 
312d				endm 
# End of macro FORTH_DSP_VALUEHL
312d e5					push hl		 ; hl now has starting counter which needs to be tos 
312e			 
312e					if DEBUG_FORTH_WORDS 
312e						DMARK "DO4" 
312e f5				push af  
312f 3a 43 31			ld a, (.dmark)  
3132 32 bd fb			ld (debug_mark),a  
3135 3a 44 31			ld a, (.dmark+1)  
3138 32 be fb			ld (debug_mark+1),a  
313b 3a 45 31			ld a, (.dmark+2)  
313e 32 bf fb			ld (debug_mark+2),a  
3141 18 03			jr .pastdmark  
3143 ..			.dmark: db "DO4"  
3146 f1			.pastdmark: pop af  
3147			endm  
# End of macro DMARK
3147						CALLMONITOR 
3147 cd 65 16			call break_point_state  
314a				endm  
# End of macro CALLMONITOR
314a					endif 
314a					FORTH_DSP_POP 
314a cd a1 1e			call macro_forth_dsp_pop 
314d				endm 
# End of macro FORTH_DSP_POP
314d			 
314d					if DEBUG_FORTH_WORDS 
314d						DMARK "DO5" 
314d f5				push af  
314e 3a 62 31			ld a, (.dmark)  
3151 32 bd fb			ld (debug_mark),a  
3154 3a 63 31			ld a, (.dmark+1)  
3157 32 be fb			ld (debug_mark+1),a  
315a 3a 64 31			ld a, (.dmark+2)  
315d 32 bf fb			ld (debug_mark+2),a  
3160 18 03			jr .pastdmark  
3162 ..			.dmark: db "DO5"  
3165 f1			.pastdmark: pop af  
3166			endm  
# End of macro DMARK
3166						CALLMONITOR 
3166 cd 65 16			call break_point_state  
3169				endm  
# End of macro CALLMONITOR
3169					endif 
3169			 
3169					FORTH_DSP_VALUEHL 
3169 cd e9 1d			call macro_dsp_valuehl 
316c				endm 
# End of macro FORTH_DSP_VALUEHL
316c			;		push hl		 ; hl now has starting limit counter 
316c			 
316c					if DEBUG_FORTH_WORDS 
316c						DMARK "DO6" 
316c f5				push af  
316d 3a 81 31			ld a, (.dmark)  
3170 32 bd fb			ld (debug_mark),a  
3173 3a 82 31			ld a, (.dmark+1)  
3176 32 be fb			ld (debug_mark+1),a  
3179 3a 83 31			ld a, (.dmark+2)  
317c 32 bf fb			ld (debug_mark+2),a  
317f 18 03			jr .pastdmark  
3181 ..			.dmark: db "DO6"  
3184 f1			.pastdmark: pop af  
3185			endm  
# End of macro DMARK
3185						CALLMONITOR 
3185 cd 65 16			call break_point_state  
3188				endm  
# End of macro CALLMONITOR
3188					endif 
3188					FORTH_DSP_POP 
3188 cd a1 1e			call macro_forth_dsp_pop 
318b				endm 
# End of macro FORTH_DSP_POP
318b			 
318b			; put counters on the loop stack 
318b			 
318b			;		pop hl			 ; limit counter 
318b d1					pop de			; start counter 
318c			 
318c					; push limit counter 
318c			 
318c					if DEBUG_FORTH_WORDS 
318c						DMARK "DO7" 
318c f5				push af  
318d 3a a1 31			ld a, (.dmark)  
3190 32 bd fb			ld (debug_mark),a  
3193 3a a2 31			ld a, (.dmark+1)  
3196 32 be fb			ld (debug_mark+1),a  
3199 3a a3 31			ld a, (.dmark+2)  
319c 32 bf fb			ld (debug_mark+2),a  
319f 18 03			jr .pastdmark  
31a1 ..			.dmark: db "DO7"  
31a4 f1			.pastdmark: pop af  
31a5			endm  
# End of macro DMARK
31a5						CALLMONITOR 
31a5 cd 65 16			call break_point_state  
31a8				endm  
# End of macro CALLMONITOR
31a8					endif 
31a8					FORTH_LOOP_NEXT 
31a8 cd 1a 1e			call macro_forth_loop_next 
31ab				endm 
# End of macro FORTH_LOOP_NEXT
31ab			 
31ab					; push start counter 
31ab			 
31ab eb					ex de, hl 
31ac					if DEBUG_FORTH_WORDS 
31ac						DMARK "DO7" 
31ac f5				push af  
31ad 3a c1 31			ld a, (.dmark)  
31b0 32 bd fb			ld (debug_mark),a  
31b3 3a c2 31			ld a, (.dmark+1)  
31b6 32 be fb			ld (debug_mark+1),a  
31b9 3a c3 31			ld a, (.dmark+2)  
31bc 32 bf fb			ld (debug_mark+2),a  
31bf 18 03			jr .pastdmark  
31c1 ..			.dmark: db "DO7"  
31c4 f1			.pastdmark: pop af  
31c5			endm  
# End of macro DMARK
31c5						CALLMONITOR 
31c5 cd 65 16			call break_point_state  
31c8				endm  
# End of macro CALLMONITOR
31c8					endif 
31c8					FORTH_LOOP_NEXT 
31c8 cd 1a 1e			call macro_forth_loop_next 
31cb				endm 
# End of macro FORTH_LOOP_NEXT
31cb			 
31cb			 
31cb					; init first round of I counter 
31cb			 
31cb 22 c8 f2				ld (os_current_i), hl 
31ce			 
31ce					if DEBUG_FORTH_WORDS 
31ce						DMARK "DO8" 
31ce f5				push af  
31cf 3a e3 31			ld a, (.dmark)  
31d2 32 bd fb			ld (debug_mark),a  
31d5 3a e4 31			ld a, (.dmark+1)  
31d8 32 be fb			ld (debug_mark+1),a  
31db 3a e5 31			ld a, (.dmark+2)  
31de 32 bf fb			ld (debug_mark+2),a  
31e1 18 03			jr .pastdmark  
31e3 ..			.dmark: db "DO8"  
31e6 f1			.pastdmark: pop af  
31e7			endm  
# End of macro DMARK
31e7						CALLMONITOR 
31e7 cd 65 16			call break_point_state  
31ea				endm  
# End of macro CALLMONITOR
31ea					endif 
31ea			 
31ea					NEXTW 
31ea c3 5b 1f			jp macro_next 
31ed				endm 
# End of macro NEXTW
31ed			.LOOP: 
31ed				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
31ed 22				db WORD_SYS_CORE+14             
31ee 05 33			dw .I            
31f0 05				db 4 + 1 
31f1 .. 00			db "LOOP",0              
31f6				endm 
# End of macro CWHEAD
31f6			; | LOOP ( -- ) Increment and test loop counter  | DONE 
31f6			 
31f6				; pop tos as current loop count to hl 
31f6			 
31f6				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
31f6			 
31f6				FORTH_LOOP_TOS 
31f6 cd 4d 1e			call macro_forth_loop_tos 
31f9				endm 
# End of macro FORTH_LOOP_TOS
31f9 e5				push hl 
31fa			 
31fa					if DEBUG_FORTH_WORDS_KEY 
31fa						DMARK "LOP" 
31fa f5				push af  
31fb 3a 0f 32			ld a, (.dmark)  
31fe 32 bd fb			ld (debug_mark),a  
3201 3a 10 32			ld a, (.dmark+1)  
3204 32 be fb			ld (debug_mark+1),a  
3207 3a 11 32			ld a, (.dmark+2)  
320a 32 bf fb			ld (debug_mark+2),a  
320d 18 03			jr .pastdmark  
320f ..			.dmark: db "LOP"  
3212 f1			.pastdmark: pop af  
3213			endm  
# End of macro DMARK
3213						CALLMONITOR 
3213 cd 65 16			call break_point_state  
3216				endm  
# End of macro CALLMONITOR
3216					endif 
3216				; next item on the stack is the limit. get it 
3216			 
3216			 
3216				FORTH_LOOP_POP 
3216 cd 57 1e			call macro_forth_loop_pop 
3219				endm 
# End of macro FORTH_LOOP_POP
3219			 
3219				FORTH_LOOP_TOS 
3219 cd 4d 1e			call macro_forth_loop_tos 
321c				endm 
# End of macro FORTH_LOOP_TOS
321c			 
321c d1				pop de		 ; de = i, hl = limit 
321d			 
321d					if DEBUG_FORTH_WORDS 
321d						DMARK "LP1" 
321d f5				push af  
321e 3a 32 32			ld a, (.dmark)  
3221 32 bd fb			ld (debug_mark),a  
3224 3a 33 32			ld a, (.dmark+1)  
3227 32 be fb			ld (debug_mark+1),a  
322a 3a 34 32			ld a, (.dmark+2)  
322d 32 bf fb			ld (debug_mark+2),a  
3230 18 03			jr .pastdmark  
3232 ..			.dmark: db "LP1"  
3235 f1			.pastdmark: pop af  
3236			endm  
# End of macro DMARK
3236						CALLMONITOR 
3236 cd 65 16			call break_point_state  
3239				endm  
# End of macro CALLMONITOR
3239					endif 
3239			 
3239				; go back to previous word 
3239			 
3239 d5				push de    ; save I for inc later 
323a			 
323a			 
323a				; get limit 
323a				;  is I at limit? 
323a			 
323a			 
323a					if DEBUG_FORTH_WORDS 
323a						DMARK "LP1" 
323a f5				push af  
323b 3a 4f 32			ld a, (.dmark)  
323e 32 bd fb			ld (debug_mark),a  
3241 3a 50 32			ld a, (.dmark+1)  
3244 32 be fb			ld (debug_mark+1),a  
3247 3a 51 32			ld a, (.dmark+2)  
324a 32 bf fb			ld (debug_mark+2),a  
324d 18 03			jr .pastdmark  
324f ..			.dmark: db "LP1"  
3252 f1			.pastdmark: pop af  
3253			endm  
# End of macro DMARK
3253						CALLMONITOR 
3253 cd 65 16			call break_point_state  
3256				endm  
# End of macro CALLMONITOR
3256					endif 
3256			 
3256 ed 52			sbc hl, de 
3258			 
3258			 
3258				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3258			 
3258 20 26				jr nz, .loopnotdone 
325a			 
325a e1				pop hl   ; get rid of saved I 
325b				FORTH_LOOP_POP     ; get rid of limit 
325b cd 57 1e			call macro_forth_loop_pop 
325e				endm 
# End of macro FORTH_LOOP_POP
325e			 
325e				FORTH_RSP_POP     ; get rid of DO ptr 
325e cd ba 1b			call macro_forth_rsp_pop 
3261				endm 
# End of macro FORTH_RSP_POP
3261			 
3261			if DEBUG_FORTH_WORDS 
3261						DMARK "LP>" 
3261 f5				push af  
3262 3a 76 32			ld a, (.dmark)  
3265 32 bd fb			ld (debug_mark),a  
3268 3a 77 32			ld a, (.dmark+1)  
326b 32 be fb			ld (debug_mark+1),a  
326e 3a 78 32			ld a, (.dmark+2)  
3271 32 bf fb			ld (debug_mark+2),a  
3274 18 03			jr .pastdmark  
3276 ..			.dmark: db "LP>"  
3279 f1			.pastdmark: pop af  
327a			endm  
# End of macro DMARK
327a				CALLMONITOR 
327a cd 65 16			call break_point_state  
327d				endm  
# End of macro CALLMONITOR
327d			endif 
327d			 
327d					NEXTW 
327d c3 5b 1f			jp macro_next 
3280				endm 
# End of macro NEXTW
3280				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3280			 
3280			.loopnotdone: 
3280			 
3280 e1				pop hl    ; get I 
3281 23				inc hl 
3282			 
3282			   	; save new I 
3282			 
3282			 
3282					; set I counter 
3282			 
3282 22 c8 f2				ld (os_current_i), hl 
3285			 
3285					if DEBUG_FORTH_WORDS 
3285						DMARK "LPN" 
3285 f5				push af  
3286 3a 9a 32			ld a, (.dmark)  
3289 32 bd fb			ld (debug_mark),a  
328c 3a 9b 32			ld a, (.dmark+1)  
328f 32 be fb			ld (debug_mark+1),a  
3292 3a 9c 32			ld a, (.dmark+2)  
3295 32 bf fb			ld (debug_mark+2),a  
3298 18 03			jr .pastdmark  
329a ..			.dmark: db "LPN"  
329d f1			.pastdmark: pop af  
329e			endm  
# End of macro DMARK
329e					CALLMONITOR 
329e cd 65 16			call break_point_state  
32a1				endm  
# End of macro CALLMONITOR
32a1					endif 
32a1					 
32a1				FORTH_LOOP_NEXT 
32a1 cd 1a 1e			call macro_forth_loop_next 
32a4				endm 
# End of macro FORTH_LOOP_NEXT
32a4			 
32a4			 
32a4					if DEBUG_FORTH_WORDS 
32a4 eb						ex de,hl 
32a5					endif 
32a5			 
32a5			;	; get DO ptr 
32a5			; 
32a5					if DEBUG_FORTH_WORDS 
32a5						DMARK "LP7" 
32a5 f5				push af  
32a6 3a ba 32			ld a, (.dmark)  
32a9 32 bd fb			ld (debug_mark),a  
32ac 3a bb 32			ld a, (.dmark+1)  
32af 32 be fb			ld (debug_mark+1),a  
32b2 3a bc 32			ld a, (.dmark+2)  
32b5 32 bf fb			ld (debug_mark+2),a  
32b8 18 03			jr .pastdmark  
32ba ..			.dmark: db "LP7"  
32bd f1			.pastdmark: pop af  
32be			endm  
# End of macro DMARK
32be					CALLMONITOR 
32be cd 65 16			call break_point_state  
32c1				endm  
# End of macro CALLMONITOR
32c1					endif 
32c1				FORTH_RSP_TOS 
32c1 cd b0 1b			call macro_forth_rsp_tos 
32c4				endm 
# End of macro FORTH_RSP_TOS
32c4			 
32c4					if DEBUG_FORTH_WORDS 
32c4						DMARK "LP8" 
32c4 f5				push af  
32c5 3a d9 32			ld a, (.dmark)  
32c8 32 bd fb			ld (debug_mark),a  
32cb 3a da 32			ld a, (.dmark+1)  
32ce 32 be fb			ld (debug_mark+1),a  
32d1 3a db 32			ld a, (.dmark+2)  
32d4 32 bf fb			ld (debug_mark+2),a  
32d7 18 03			jr .pastdmark  
32d9 ..			.dmark: db "LP8"  
32dc f1			.pastdmark: pop af  
32dd			endm  
# End of macro DMARK
32dd					CALLMONITOR 
32dd cd 65 16			call break_point_state  
32e0				endm  
# End of macro CALLMONITOR
32e0					endif 
32e0				;push hl 
32e0			 
32e0				; not going to DO any more 
32e0				; get rid of the RSP pointer as DO will add it back in 
32e0				;FORTH_RSP_POP 
32e0				;pop hl 
32e0			 
32e0				;ld hl,(cli_ret_sp) 
32e0				;ld e, (hl) 
32e0				;inc hl 
32e0				;ld d, (hl) 
32e0				;ex de,hl 
32e0 22 a4 f2			ld (os_tok_ptr), hl 
32e3					if DEBUG_FORTH_WORDS 
32e3						DMARK "LP<" 
32e3 f5				push af  
32e4 3a f8 32			ld a, (.dmark)  
32e7 32 bd fb			ld (debug_mark),a  
32ea 3a f9 32			ld a, (.dmark+1)  
32ed 32 be fb			ld (debug_mark+1),a  
32f0 3a fa 32			ld a, (.dmark+2)  
32f3 32 bf fb			ld (debug_mark+2),a  
32f6 18 03			jr .pastdmark  
32f8 ..			.dmark: db "LP<"  
32fb f1			.pastdmark: pop af  
32fc			endm  
# End of macro DMARK
32fc					CALLMONITOR 
32fc cd 65 16			call break_point_state  
32ff				endm  
# End of macro CALLMONITOR
32ff				endif 
32ff c3 ec 1f			jp exec1 
3302			 
3302					 
3302			 
3302			 
3302					NEXTW 
3302 c3 5b 1f			jp macro_next 
3305				endm 
# End of macro NEXTW
3305			.I:  
3305			 
3305				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3305 5e				db WORD_SYS_CORE+74             
3306 30 33			dw .DLOOP            
3308 02				db 1 + 1 
3309 .. 00			db "I",0              
330b				endm 
# End of macro CWHEAD
330b			; | I ( -- ) Current loop counter | DONE 
330b					if DEBUG_FORTH_WORDS_KEY 
330b						DMARK "I.." 
330b f5				push af  
330c 3a 20 33			ld a, (.dmark)  
330f 32 bd fb			ld (debug_mark),a  
3312 3a 21 33			ld a, (.dmark+1)  
3315 32 be fb			ld (debug_mark+1),a  
3318 3a 22 33			ld a, (.dmark+2)  
331b 32 bf fb			ld (debug_mark+2),a  
331e 18 03			jr .pastdmark  
3320 ..			.dmark: db "I.."  
3323 f1			.pastdmark: pop af  
3324			endm  
# End of macro DMARK
3324						CALLMONITOR 
3324 cd 65 16			call break_point_state  
3327				endm  
# End of macro CALLMONITOR
3327					endif 
3327			 
3327 2a c8 f2				ld hl,(os_current_i) 
332a cd f2 1b				call forth_push_numhl 
332d			 
332d					NEXTW 
332d c3 5b 1f			jp macro_next 
3330				endm 
# End of macro NEXTW
3330			.DLOOP: 
3330				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3330 5f				db WORD_SYS_CORE+75             
3331 11 34			dw .REPEAT            
3333 06				db 5 + 1 
3334 .. 00			db "-LOOP",0              
333a				endm 
# End of macro CWHEAD
333a			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
333a				; pop tos as current loop count to hl 
333a					if DEBUG_FORTH_WORDS_KEY 
333a						DMARK "-LP" 
333a f5				push af  
333b 3a 4f 33			ld a, (.dmark)  
333e 32 bd fb			ld (debug_mark),a  
3341 3a 50 33			ld a, (.dmark+1)  
3344 32 be fb			ld (debug_mark+1),a  
3347 3a 51 33			ld a, (.dmark+2)  
334a 32 bf fb			ld (debug_mark+2),a  
334d 18 03			jr .pastdmark  
334f ..			.dmark: db "-LP"  
3352 f1			.pastdmark: pop af  
3353			endm  
# End of macro DMARK
3353						CALLMONITOR 
3353 cd 65 16			call break_point_state  
3356				endm  
# End of macro CALLMONITOR
3356					endif 
3356			 
3356				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3356			 
3356				FORTH_LOOP_TOS 
3356 cd 4d 1e			call macro_forth_loop_tos 
3359				endm 
# End of macro FORTH_LOOP_TOS
3359 e5				push hl 
335a			 
335a					if DEBUG_FORTH_WORDS 
335a						DMARK "-LP" 
335a f5				push af  
335b 3a 6f 33			ld a, (.dmark)  
335e 32 bd fb			ld (debug_mark),a  
3361 3a 70 33			ld a, (.dmark+1)  
3364 32 be fb			ld (debug_mark+1),a  
3367 3a 71 33			ld a, (.dmark+2)  
336a 32 bf fb			ld (debug_mark+2),a  
336d 18 03			jr .pastdmark  
336f ..			.dmark: db "-LP"  
3372 f1			.pastdmark: pop af  
3373			endm  
# End of macro DMARK
3373						CALLMONITOR 
3373 cd 65 16			call break_point_state  
3376				endm  
# End of macro CALLMONITOR
3376					endif 
3376				; next item on the stack is the limit. get it 
3376			 
3376			 
3376				FORTH_LOOP_POP 
3376 cd 57 1e			call macro_forth_loop_pop 
3379				endm 
# End of macro FORTH_LOOP_POP
3379			 
3379				FORTH_LOOP_TOS 
3379 cd 4d 1e			call macro_forth_loop_tos 
337c				endm 
# End of macro FORTH_LOOP_TOS
337c			 
337c d1				pop de		 ; de = i, hl = limit 
337d			 
337d					if DEBUG_FORTH_WORDS 
337d						DMARK "-L1" 
337d f5				push af  
337e 3a 92 33			ld a, (.dmark)  
3381 32 bd fb			ld (debug_mark),a  
3384 3a 93 33			ld a, (.dmark+1)  
3387 32 be fb			ld (debug_mark+1),a  
338a 3a 94 33			ld a, (.dmark+2)  
338d 32 bf fb			ld (debug_mark+2),a  
3390 18 03			jr .pastdmark  
3392 ..			.dmark: db "-L1"  
3395 f1			.pastdmark: pop af  
3396			endm  
# End of macro DMARK
3396						CALLMONITOR 
3396 cd 65 16			call break_point_state  
3399				endm  
# End of macro CALLMONITOR
3399					endif 
3399			 
3399				; go back to previous word 
3399			 
3399 d5				push de    ; save I for inc later 
339a			 
339a			 
339a				; get limit 
339a				;  is I at limit? 
339a			 
339a			 
339a					if DEBUG_FORTH_WORDS 
339a						DMARK "-L1" 
339a f5				push af  
339b 3a af 33			ld a, (.dmark)  
339e 32 bd fb			ld (debug_mark),a  
33a1 3a b0 33			ld a, (.dmark+1)  
33a4 32 be fb			ld (debug_mark+1),a  
33a7 3a b1 33			ld a, (.dmark+2)  
33aa 32 bf fb			ld (debug_mark+2),a  
33ad 18 03			jr .pastdmark  
33af ..			.dmark: db "-L1"  
33b2 f1			.pastdmark: pop af  
33b3			endm  
# End of macro DMARK
33b3						CALLMONITOR 
33b3 cd 65 16			call break_point_state  
33b6				endm  
# End of macro CALLMONITOR
33b6					endif 
33b6			 
33b6 ed 52			sbc hl, de 
33b8			 
33b8			 
33b8				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
33b8			 
33b8 20 26				jr nz, .mloopnotdone 
33ba			 
33ba e1				pop hl   ; get rid of saved I 
33bb				FORTH_LOOP_POP     ; get rid of limit 
33bb cd 57 1e			call macro_forth_loop_pop 
33be				endm 
# End of macro FORTH_LOOP_POP
33be			 
33be				FORTH_RSP_POP     ; get rid of DO ptr 
33be cd ba 1b			call macro_forth_rsp_pop 
33c1				endm 
# End of macro FORTH_RSP_POP
33c1			 
33c1			if DEBUG_FORTH_WORDS 
33c1						DMARK "-L>" 
33c1 f5				push af  
33c2 3a d6 33			ld a, (.dmark)  
33c5 32 bd fb			ld (debug_mark),a  
33c8 3a d7 33			ld a, (.dmark+1)  
33cb 32 be fb			ld (debug_mark+1),a  
33ce 3a d8 33			ld a, (.dmark+2)  
33d1 32 bf fb			ld (debug_mark+2),a  
33d4 18 03			jr .pastdmark  
33d6 ..			.dmark: db "-L>"  
33d9 f1			.pastdmark: pop af  
33da			endm  
# End of macro DMARK
33da				CALLMONITOR 
33da cd 65 16			call break_point_state  
33dd				endm  
# End of macro CALLMONITOR
33dd			endif 
33dd			 
33dd					NEXTW 
33dd c3 5b 1f			jp macro_next 
33e0				endm 
# End of macro NEXTW
33e0				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
33e0			 
33e0			.mloopnotdone: 
33e0			 
33e0 e1				pop hl    ; get I 
33e1 2b				dec hl 
33e2			 
33e2			   	; save new I 
33e2			 
33e2			 
33e2					; set I counter 
33e2			 
33e2 22 c8 f2				ld (os_current_i), hl 
33e5			 
33e5					 
33e5				FORTH_LOOP_NEXT 
33e5 cd 1a 1e			call macro_forth_loop_next 
33e8				endm 
# End of macro FORTH_LOOP_NEXT
33e8			 
33e8			 
33e8					if DEBUG_FORTH_WORDS 
33e8 eb						ex de,hl 
33e9					endif 
33e9			 
33e9			;	; get DO ptr 
33e9			; 
33e9				FORTH_RSP_TOS 
33e9 cd b0 1b			call macro_forth_rsp_tos 
33ec				endm 
# End of macro FORTH_RSP_TOS
33ec			 
33ec				;push hl 
33ec			 
33ec				; not going to DO any more 
33ec				; get rid of the RSP pointer as DO will add it back in 
33ec				;FORTH_RSP_POP 
33ec				;pop hl 
33ec			 
33ec			 
33ec 22 a4 f2			ld (os_tok_ptr), hl 
33ef					if DEBUG_FORTH_WORDS 
33ef						DMARK "-L<" 
33ef f5				push af  
33f0 3a 04 34			ld a, (.dmark)  
33f3 32 bd fb			ld (debug_mark),a  
33f6 3a 05 34			ld a, (.dmark+1)  
33f9 32 be fb			ld (debug_mark+1),a  
33fc 3a 06 34			ld a, (.dmark+2)  
33ff 32 bf fb			ld (debug_mark+2),a  
3402 18 03			jr .pastdmark  
3404 ..			.dmark: db "-L<"  
3407 f1			.pastdmark: pop af  
3408			endm  
# End of macro DMARK
3408					CALLMONITOR 
3408 cd 65 16			call break_point_state  
340b				endm  
# End of macro CALLMONITOR
340b				endif 
340b c3 ec 1f			jp exec1 
340e			 
340e					 
340e			 
340e			 
340e			 
340e				NEXTW 
340e c3 5b 1f			jp macro_next 
3411				endm 
# End of macro NEXTW
3411			 
3411			 
3411			 
3411			 
3411			.REPEAT: 
3411				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3411 71				db WORD_SYS_CORE+93             
3412 64 34			dw .UNTIL            
3414 06				db 5 + 1 
3415 .. 00			db "REPEAT",0              
341c				endm 
# End of macro CWHEAD
341c			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
341c			;  push pc to rsp stack past the REPEAT 
341c					if DEBUG_FORTH_WORDS_KEY 
341c						DMARK "REP" 
341c f5				push af  
341d 3a 31 34			ld a, (.dmark)  
3420 32 bd fb			ld (debug_mark),a  
3423 3a 32 34			ld a, (.dmark+1)  
3426 32 be fb			ld (debug_mark+1),a  
3429 3a 33 34			ld a, (.dmark+2)  
342c 32 bf fb			ld (debug_mark+2),a  
342f 18 03			jr .pastdmark  
3431 ..			.dmark: db "REP"  
3434 f1			.pastdmark: pop af  
3435			endm  
# End of macro DMARK
3435						CALLMONITOR 
3435 cd 65 16			call break_point_state  
3438				endm  
# End of macro CALLMONITOR
3438					endif 
3438			 
3438 2a a4 f2				ld hl, (os_tok_ptr) 
343b 23					inc hl   ; R 
343c 23					inc hl  ; E 
343d 23					inc hl   ; P 
343e 23					inc hl   ; E 
343f 23					inc hl   ; A 
3440 23					inc hl   ; T 
3441 23					inc hl   ; zero 
3442					FORTH_RSP_NEXT 
3442 cd 99 1b			call macro_forth_rsp_next 
3445				endm 
# End of macro FORTH_RSP_NEXT
3445			 
3445			 
3445					if DEBUG_FORTH_WORDS 
3445						DMARK "REP" 
3445 f5				push af  
3446 3a 5a 34			ld a, (.dmark)  
3449 32 bd fb			ld (debug_mark),a  
344c 3a 5b 34			ld a, (.dmark+1)  
344f 32 be fb			ld (debug_mark+1),a  
3452 3a 5c 34			ld a, (.dmark+2)  
3455 32 bf fb			ld (debug_mark+2),a  
3458 18 03			jr .pastdmark  
345a ..			.dmark: db "REP"  
345d f1			.pastdmark: pop af  
345e			endm  
# End of macro DMARK
345e						;pop bc    ; TODO BUG ?????? what is this for???? 
345e						CALLMONITOR 
345e cd 65 16			call break_point_state  
3461				endm  
# End of macro CALLMONITOR
3461					endif 
3461			 
3461					NEXTW 
3461 c3 5b 1f			jp macro_next 
3464				endm 
# End of macro NEXTW
3464			;	       NEXTW 
3464			 
3464			.UNTIL: 
3464				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3464 72				db WORD_SYS_CORE+94             
3465 fb 34			dw .ENDFLOW            
3467 06				db 5 + 1 
3468 .. 00			db "UNTIL",0              
346e				endm 
# End of macro CWHEAD
346e			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
346e			 
346e				; pop tos as check 
346e			 
346e				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
346e			 
346e				FORTH_DSP_VALUEHL 
346e cd e9 1d			call macro_dsp_valuehl 
3471				endm 
# End of macro FORTH_DSP_VALUEHL
3471			 
3471					if DEBUG_FORTH_WORDS_KEY 
3471						DMARK "UNT" 
3471 f5				push af  
3472 3a 86 34			ld a, (.dmark)  
3475 32 bd fb			ld (debug_mark),a  
3478 3a 87 34			ld a, (.dmark+1)  
347b 32 be fb			ld (debug_mark+1),a  
347e 3a 88 34			ld a, (.dmark+2)  
3481 32 bf fb			ld (debug_mark+2),a  
3484 18 03			jr .pastdmark  
3486 ..			.dmark: db "UNT"  
3489 f1			.pastdmark: pop af  
348a			endm  
# End of macro DMARK
348a						CALLMONITOR 
348a cd 65 16			call break_point_state  
348d				endm  
# End of macro CALLMONITOR
348d					endif 
348d			 
348d			;	push hl 
348d				FORTH_DSP_POP 
348d cd a1 1e			call macro_forth_dsp_pop 
3490				endm 
# End of macro FORTH_DSP_POP
3490			 
3490			;	pop hl 
3490			 
3490				; test if true 
3490			 
3490 cd 2f 0d			call ishlzero 
3493			;	ld a,l 
3493			;	add h 
3493			; 
3493			;	cp 0 
3493			 
3493 20 3e			jr nz, .untilnotdone 
3495			 
3495					if DEBUG_FORTH_WORDS 
3495						DMARK "UNf" 
3495 f5				push af  
3496 3a aa 34			ld a, (.dmark)  
3499 32 bd fb			ld (debug_mark),a  
349c 3a ab 34			ld a, (.dmark+1)  
349f 32 be fb			ld (debug_mark+1),a  
34a2 3a ac 34			ld a, (.dmark+2)  
34a5 32 bf fb			ld (debug_mark+2),a  
34a8 18 03			jr .pastdmark  
34aa ..			.dmark: db "UNf"  
34ad f1			.pastdmark: pop af  
34ae			endm  
# End of macro DMARK
34ae						CALLMONITOR 
34ae cd 65 16			call break_point_state  
34b1				endm  
# End of macro CALLMONITOR
34b1					endif 
34b1			 
34b1			 
34b1			 
34b1				FORTH_RSP_POP     ; get rid of DO ptr 
34b1 cd ba 1b			call macro_forth_rsp_pop 
34b4				endm 
# End of macro FORTH_RSP_POP
34b4			 
34b4			if DEBUG_FORTH_WORDS 
34b4						DMARK "UN>" 
34b4 f5				push af  
34b5 3a c9 34			ld a, (.dmark)  
34b8 32 bd fb			ld (debug_mark),a  
34bb 3a ca 34			ld a, (.dmark+1)  
34be 32 be fb			ld (debug_mark+1),a  
34c1 3a cb 34			ld a, (.dmark+2)  
34c4 32 bf fb			ld (debug_mark+2),a  
34c7 18 03			jr .pastdmark  
34c9 ..			.dmark: db "UN>"  
34cc f1			.pastdmark: pop af  
34cd			endm  
# End of macro DMARK
34cd				CALLMONITOR 
34cd cd 65 16			call break_point_state  
34d0				endm  
# End of macro CALLMONITOR
34d0			endif 
34d0			 
34d0					NEXTW 
34d0 c3 5b 1f			jp macro_next 
34d3				endm 
# End of macro NEXTW
34d3				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34d3			 
34d3			.untilnotdone: 
34d3			 
34d3			 
34d3			;	; get DO ptr 
34d3			; 
34d3				FORTH_RSP_TOS 
34d3 cd b0 1b			call macro_forth_rsp_tos 
34d6				endm 
# End of macro FORTH_RSP_TOS
34d6			 
34d6				;push hl 
34d6			 
34d6				; not going to DO any more 
34d6				; get rid of the RSP pointer as DO will add it back in 
34d6				;FORTH_RSP_POP 
34d6				;pop hl 
34d6			 
34d6			 
34d6 22 a4 f2			ld (os_tok_ptr), hl 
34d9					if DEBUG_FORTH_WORDS 
34d9						DMARK "UN<" 
34d9 f5				push af  
34da 3a ee 34			ld a, (.dmark)  
34dd 32 bd fb			ld (debug_mark),a  
34e0 3a ef 34			ld a, (.dmark+1)  
34e3 32 be fb			ld (debug_mark+1),a  
34e6 3a f0 34			ld a, (.dmark+2)  
34e9 32 bf fb			ld (debug_mark+2),a  
34ec 18 03			jr .pastdmark  
34ee ..			.dmark: db "UN<"  
34f1 f1			.pastdmark: pop af  
34f2			endm  
# End of macro DMARK
34f2					CALLMONITOR 
34f2 cd 65 16			call break_point_state  
34f5				endm  
# End of macro CALLMONITOR
34f5				endif 
34f5 c3 ec 1f			jp exec1 
34f8			 
34f8					 
34f8			 
34f8			 
34f8					NEXTW 
34f8 c3 5b 1f			jp macro_next 
34fb				endm 
# End of macro NEXTW
34fb			 
34fb			 
34fb			.ENDFLOW: 
34fb			 
34fb			; eof 
34fb			 
# End of file forth_words_flow.asm
34fb			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
34fb			include "forth_words_logic.asm" 
34fb			 
34fb			; | ## Logic Words 
34fb			 
34fb			.NOT: 
34fb				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
34fb 2d				db WORD_SYS_CORE+25             
34fc 43 35			dw .IS            
34fe 04				db 3 + 1 
34ff .. 00			db "NOT",0              
3503				endm 
# End of macro CWHEAD
3503			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3503					if DEBUG_FORTH_WORDS_KEY 
3503						DMARK "NOT" 
3503 f5				push af  
3504 3a 18 35			ld a, (.dmark)  
3507 32 bd fb			ld (debug_mark),a  
350a 3a 19 35			ld a, (.dmark+1)  
350d 32 be fb			ld (debug_mark+1),a  
3510 3a 1a 35			ld a, (.dmark+2)  
3513 32 bf fb			ld (debug_mark+2),a  
3516 18 03			jr .pastdmark  
3518 ..			.dmark: db "NOT"  
351b f1			.pastdmark: pop af  
351c			endm  
# End of macro DMARK
351c						CALLMONITOR 
351c cd 65 16			call break_point_state  
351f				endm  
# End of macro CALLMONITOR
351f					endif 
351f					FORTH_DSP 
351f cd af 1d			call macro_forth_dsp 
3522				endm 
# End of macro FORTH_DSP
3522 7e					ld a,(hl)	; get type of value on TOS 
3523 fe 02				cp DS_TYPE_INUM  
3525 28 03				jr z, .noti 
3527					NEXTW 
3527 c3 5b 1f			jp macro_next 
352a				endm 
# End of macro NEXTW
352a			.noti:          FORTH_DSP_VALUEHL 
352a cd e9 1d			call macro_dsp_valuehl 
352d				endm 
# End of macro FORTH_DSP_VALUEHL
352d			;		push hl 
352d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
352d cd a1 1e			call macro_forth_dsp_pop 
3530				endm 
# End of macro FORTH_DSP_POP
3530			;		pop hl 
3530 3e 00				ld a,0 
3532 bd					cp l 
3533 28 04				jr z, .not2t 
3535 2e 00				ld l, 0 
3537 18 02				jr .notip 
3539			 
3539 2e ff		.not2t:		ld l, 255 
353b			 
353b 26 00		.notip:		ld h, 0	 
353d			 
353d cd f2 1b				call forth_push_numhl 
3540					NEXTW 
3540 c3 5b 1f			jp macro_next 
3543				endm 
# End of macro NEXTW
3543			 
3543			.IS: 
3543				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3543 2d				db WORD_SYS_CORE+25             
3544 69 35			dw .LZERO            
3546 03				db 2 + 1 
3547 .. 00			db "IS",0              
354a				endm 
# End of macro CWHEAD
354a			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
354a					if DEBUG_FORTH_WORDS_KEY 
354a						DMARK "IS." 
354a f5				push af  
354b 3a 5f 35			ld a, (.dmark)  
354e 32 bd fb			ld (debug_mark),a  
3551 3a 60 35			ld a, (.dmark+1)  
3554 32 be fb			ld (debug_mark+1),a  
3557 3a 61 35			ld a, (.dmark+2)  
355a 32 bf fb			ld (debug_mark+2),a  
355d 18 03			jr .pastdmark  
355f ..			.dmark: db "IS."  
3562 f1			.pastdmark: pop af  
3563			endm  
# End of macro DMARK
3563						CALLMONITOR 
3563 cd 65 16			call break_point_state  
3566				endm  
# End of macro CALLMONITOR
3566					endif 
3566					NEXTW 
3566 c3 5b 1f			jp macro_next 
3569				endm 
# End of macro NEXTW
3569			.LZERO: 
3569				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3569 2d				db WORD_SYS_CORE+25             
356a 73 35			dw .TZERO            
356c 03				db 2 + 1 
356d .. 00			db "0<",0              
3570				endm 
# End of macro CWHEAD
3570			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3570					NEXTW 
3570 c3 5b 1f			jp macro_next 
3573				endm 
# End of macro NEXTW
3573			.TZERO: 
3573				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3573 2e				db WORD_SYS_CORE+26             
3574 ba 35			dw .LESS            
3576 03				db 2 + 1 
3577 .. 00			db "0=",0              
357a				endm 
# End of macro CWHEAD
357a			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
357a				; TODO add floating point number detection 
357a					;v5 FORTH_DSP_VALUE 
357a					if DEBUG_FORTH_WORDS_KEY 
357a						DMARK "0=." 
357a f5				push af  
357b 3a 8f 35			ld a, (.dmark)  
357e 32 bd fb			ld (debug_mark),a  
3581 3a 90 35			ld a, (.dmark+1)  
3584 32 be fb			ld (debug_mark+1),a  
3587 3a 91 35			ld a, (.dmark+2)  
358a 32 bf fb			ld (debug_mark+2),a  
358d 18 03			jr .pastdmark  
358f ..			.dmark: db "0=."  
3592 f1			.pastdmark: pop af  
3593			endm  
# End of macro DMARK
3593						CALLMONITOR 
3593 cd 65 16			call break_point_state  
3596				endm  
# End of macro CALLMONITOR
3596					endif 
3596					FORTH_DSP 
3596 cd af 1d			call macro_forth_dsp 
3599				endm 
# End of macro FORTH_DSP
3599 7e					ld a,(hl)	; get type of value on TOS 
359a fe 02				cp DS_TYPE_INUM  
359c 28 00				jr z, .tz_inum 
359e			 
359e				if FORTH_ENABLE_FLOATMATH 
359e					jr .tz_done 
359e			 
359e				endif 
359e					 
359e			 
359e			.tz_inum: 
359e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
359e cd e9 1d			call macro_dsp_valuehl 
35a1				endm 
# End of macro FORTH_DSP_VALUEHL
35a1			 
35a1			;		push hl 
35a1			 
35a1					; destroy value TOS 
35a1			 
35a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35a1 cd a1 1e			call macro_forth_dsp_pop 
35a4				endm 
# End of macro FORTH_DSP_POP
35a4			 
35a4			;		pop hl 
35a4			 
35a4 3e 00				ld a,0 
35a6			 
35a6 bd					cp l 
35a7 20 08				jr nz, .tz_notzero 
35a9			 
35a9 bc					cp h 
35aa			 
35aa 20 05				jr nz, .tz_notzero 
35ac			 
35ac			 
35ac 21 01 00				ld hl, FORTH_TRUE 
35af 18 03				jr .tz_done 
35b1			 
35b1 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
35b4			 
35b4					; push value back onto stack for another op etc 
35b4			 
35b4			.tz_done: 
35b4 cd f2 1b				call forth_push_numhl 
35b7			 
35b7					NEXTW 
35b7 c3 5b 1f			jp macro_next 
35ba				endm 
# End of macro NEXTW
35ba			.LESS: 
35ba				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
35ba 2f				db WORD_SYS_CORE+27             
35bb 23 36			dw .GT            
35bd 02				db 1 + 1 
35be .. 00			db "<",0              
35c0				endm 
# End of macro CWHEAD
35c0			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
35c0				; TODO add floating point number detection 
35c0					if DEBUG_FORTH_WORDS_KEY 
35c0						DMARK "LES" 
35c0 f5				push af  
35c1 3a d5 35			ld a, (.dmark)  
35c4 32 bd fb			ld (debug_mark),a  
35c7 3a d6 35			ld a, (.dmark+1)  
35ca 32 be fb			ld (debug_mark+1),a  
35cd 3a d7 35			ld a, (.dmark+2)  
35d0 32 bf fb			ld (debug_mark+2),a  
35d3 18 03			jr .pastdmark  
35d5 ..			.dmark: db "LES"  
35d8 f1			.pastdmark: pop af  
35d9			endm  
# End of macro DMARK
35d9						CALLMONITOR 
35d9 cd 65 16			call break_point_state  
35dc				endm  
# End of macro CALLMONITOR
35dc					endif 
35dc					FORTH_DSP 
35dc cd af 1d			call macro_forth_dsp 
35df				endm 
# End of macro FORTH_DSP
35df					;v5 FORTH_DSP_VALUE 
35df 7e					ld a,(hl)	; get type of value on TOS 
35e0 fe 02				cp DS_TYPE_INUM  
35e2 28 00				jr z, .less_inum 
35e4			 
35e4				if FORTH_ENABLE_FLOATMATH 
35e4					jr .less_done 
35e4			 
35e4				endif 
35e4					 
35e4			 
35e4			.less_inum: 
35e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35e4 cd e9 1d			call macro_dsp_valuehl 
35e7				endm 
# End of macro FORTH_DSP_VALUEHL
35e7			 
35e7 e5					push hl  ; u2 
35e8			 
35e8					; destroy value TOS 
35e8			 
35e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35e8 cd a1 1e			call macro_forth_dsp_pop 
35eb				endm 
# End of macro FORTH_DSP_POP
35eb			 
35eb			 
35eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35eb cd e9 1d			call macro_dsp_valuehl 
35ee				endm 
# End of macro FORTH_DSP_VALUEHL
35ee			 
35ee e5					push hl    ; u1 
35ef			 
35ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35ef cd a1 1e			call macro_forth_dsp_pop 
35f2				endm 
# End of macro FORTH_DSP_POP
35f2			 
35f2			 
35f2 b7			 or a      ;clear carry flag 
35f3 01 00 00		 ld bc, FORTH_FALSE 
35f6 e1			  pop hl    ; u1 
35f7 d1			  pop de    ; u2 
35f8 ed 52		  sbc hl,de 
35fa 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
35fc			 
35fc 01 01 00		 ld bc, FORTH_TRUE 
35ff			.lscont:  
35ff c5					push bc 
3600 e1					pop hl 
3601			 
3601					if DEBUG_FORTH_WORDS 
3601						DMARK "LT1" 
3601 f5				push af  
3602 3a 16 36			ld a, (.dmark)  
3605 32 bd fb			ld (debug_mark),a  
3608 3a 17 36			ld a, (.dmark+1)  
360b 32 be fb			ld (debug_mark+1),a  
360e 3a 18 36			ld a, (.dmark+2)  
3611 32 bf fb			ld (debug_mark+2),a  
3614 18 03			jr .pastdmark  
3616 ..			.dmark: db "LT1"  
3619 f1			.pastdmark: pop af  
361a			endm  
# End of macro DMARK
361a						CALLMONITOR 
361a cd 65 16			call break_point_state  
361d				endm  
# End of macro CALLMONITOR
361d					endif 
361d cd f2 1b				call forth_push_numhl 
3620			 
3620					NEXTW 
3620 c3 5b 1f			jp macro_next 
3623				endm 
# End of macro NEXTW
3623			.GT: 
3623				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3623 30				db WORD_SYS_CORE+28             
3624 8c 36			dw .EQUAL            
3626 02				db 1 + 1 
3627 .. 00			db ">",0              
3629				endm 
# End of macro CWHEAD
3629			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3629				; TODO add floating point number detection 
3629					if DEBUG_FORTH_WORDS_KEY 
3629						DMARK "GRT" 
3629 f5				push af  
362a 3a 3e 36			ld a, (.dmark)  
362d 32 bd fb			ld (debug_mark),a  
3630 3a 3f 36			ld a, (.dmark+1)  
3633 32 be fb			ld (debug_mark+1),a  
3636 3a 40 36			ld a, (.dmark+2)  
3639 32 bf fb			ld (debug_mark+2),a  
363c 18 03			jr .pastdmark  
363e ..			.dmark: db "GRT"  
3641 f1			.pastdmark: pop af  
3642			endm  
# End of macro DMARK
3642						CALLMONITOR 
3642 cd 65 16			call break_point_state  
3645				endm  
# End of macro CALLMONITOR
3645					endif 
3645					FORTH_DSP 
3645 cd af 1d			call macro_forth_dsp 
3648				endm 
# End of macro FORTH_DSP
3648					;FORTH_DSP_VALUE 
3648 7e					ld a,(hl)	; get type of value on TOS 
3649 fe 02				cp DS_TYPE_INUM  
364b 28 00				jr z, .gt_inum 
364d			 
364d				if FORTH_ENABLE_FLOATMATH 
364d					jr .gt_done 
364d			 
364d				endif 
364d					 
364d			 
364d			.gt_inum: 
364d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
364d cd e9 1d			call macro_dsp_valuehl 
3650				endm 
# End of macro FORTH_DSP_VALUEHL
3650			 
3650 e5					push hl  ; u2 
3651			 
3651					; destroy value TOS 
3651			 
3651					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3651 cd a1 1e			call macro_forth_dsp_pop 
3654				endm 
# End of macro FORTH_DSP_POP
3654			 
3654			 
3654					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3654 cd e9 1d			call macro_dsp_valuehl 
3657				endm 
# End of macro FORTH_DSP_VALUEHL
3657			 
3657 e5					push hl    ; u1 
3658			 
3658					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3658 cd a1 1e			call macro_forth_dsp_pop 
365b				endm 
# End of macro FORTH_DSP_POP
365b			 
365b			 
365b b7			 or a      ;clear carry flag 
365c 01 00 00		 ld bc, FORTH_FALSE 
365f e1			  pop hl    ; u1 
3660 d1			  pop de    ; u2 
3661 ed 52		  sbc hl,de 
3663 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3665			 
3665 01 01 00		 ld bc, FORTH_TRUE 
3668			.gtcont:  
3668 c5					push bc 
3669 e1					pop hl 
366a			 
366a					if DEBUG_FORTH_WORDS 
366a						DMARK "GT1" 
366a f5				push af  
366b 3a 7f 36			ld a, (.dmark)  
366e 32 bd fb			ld (debug_mark),a  
3671 3a 80 36			ld a, (.dmark+1)  
3674 32 be fb			ld (debug_mark+1),a  
3677 3a 81 36			ld a, (.dmark+2)  
367a 32 bf fb			ld (debug_mark+2),a  
367d 18 03			jr .pastdmark  
367f ..			.dmark: db "GT1"  
3682 f1			.pastdmark: pop af  
3683			endm  
# End of macro DMARK
3683						CALLMONITOR 
3683 cd 65 16			call break_point_state  
3686				endm  
# End of macro CALLMONITOR
3686					endif 
3686 cd f2 1b				call forth_push_numhl 
3689			 
3689					NEXTW 
3689 c3 5b 1f			jp macro_next 
368c				endm 
# End of macro NEXTW
368c			.EQUAL: 
368c				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
368c 31				db WORD_SYS_CORE+29             
368d f7 36			dw .ENDLOGIC            
368f 02				db 1 + 1 
3690 .. 00			db "=",0              
3692				endm 
# End of macro CWHEAD
3692			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3692				; TODO add floating point number detection 
3692					if DEBUG_FORTH_WORDS_KEY 
3692						DMARK "EQ." 
3692 f5				push af  
3693 3a a7 36			ld a, (.dmark)  
3696 32 bd fb			ld (debug_mark),a  
3699 3a a8 36			ld a, (.dmark+1)  
369c 32 be fb			ld (debug_mark+1),a  
369f 3a a9 36			ld a, (.dmark+2)  
36a2 32 bf fb			ld (debug_mark+2),a  
36a5 18 03			jr .pastdmark  
36a7 ..			.dmark: db "EQ."  
36aa f1			.pastdmark: pop af  
36ab			endm  
# End of macro DMARK
36ab						CALLMONITOR 
36ab cd 65 16			call break_point_state  
36ae				endm  
# End of macro CALLMONITOR
36ae					endif 
36ae					FORTH_DSP 
36ae cd af 1d			call macro_forth_dsp 
36b1				endm 
# End of macro FORTH_DSP
36b1					;v5 FORTH_DSP_VALUE 
36b1 7e					ld a,(hl)	; get type of value on TOS 
36b2 fe 02				cp DS_TYPE_INUM  
36b4 28 00				jr z, .eq_inum 
36b6			 
36b6				if FORTH_ENABLE_FLOATMATH 
36b6					jr .eq_done 
36b6			 
36b6				endif 
36b6					 
36b6			 
36b6			.eq_inum: 
36b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36b6 cd e9 1d			call macro_dsp_valuehl 
36b9				endm 
# End of macro FORTH_DSP_VALUEHL
36b9			 
36b9 e5					push hl 
36ba			 
36ba					; destroy value TOS 
36ba			 
36ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ba cd a1 1e			call macro_forth_dsp_pop 
36bd				endm 
# End of macro FORTH_DSP_POP
36bd			 
36bd			 
36bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36bd cd e9 1d			call macro_dsp_valuehl 
36c0				endm 
# End of macro FORTH_DSP_VALUEHL
36c0			 
36c0					; one value on hl get other one back 
36c0			 
36c0 e5					push hl 
36c1			 
36c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36c1 cd a1 1e			call macro_forth_dsp_pop 
36c4				endm 
# End of macro FORTH_DSP_POP
36c4			 
36c4 0e 00				ld c, FORTH_FALSE 
36c6			 
36c6 e1					pop hl 
36c7 d1					pop de 
36c8			 
36c8 7b					ld a, e 
36c9 bd					cp l 
36ca			 
36ca 20 06				jr nz, .eq_done 
36cc			 
36cc 7a					ld a, d 
36cd bc					cp h 
36ce			 
36ce 20 02				jr nz, .eq_done 
36d0			 
36d0 0e 01				ld c, FORTH_TRUE 
36d2					 
36d2			 
36d2			 
36d2			.eq_done: 
36d2			 
36d2					; TODO push value back onto stack for another op etc 
36d2			 
36d2 26 00				ld h, 0 
36d4 69					ld l, c 
36d5					if DEBUG_FORTH_WORDS 
36d5						DMARK "EQ1" 
36d5 f5				push af  
36d6 3a ea 36			ld a, (.dmark)  
36d9 32 bd fb			ld (debug_mark),a  
36dc 3a eb 36			ld a, (.dmark+1)  
36df 32 be fb			ld (debug_mark+1),a  
36e2 3a ec 36			ld a, (.dmark+2)  
36e5 32 bf fb			ld (debug_mark+2),a  
36e8 18 03			jr .pastdmark  
36ea ..			.dmark: db "EQ1"  
36ed f1			.pastdmark: pop af  
36ee			endm  
# End of macro DMARK
36ee						CALLMONITOR 
36ee cd 65 16			call break_point_state  
36f1				endm  
# End of macro CALLMONITOR
36f1					endif 
36f1 cd f2 1b				call forth_push_numhl 
36f4			 
36f4					NEXTW 
36f4 c3 5b 1f			jp macro_next 
36f7				endm 
# End of macro NEXTW
36f7			 
36f7			 
36f7			.ENDLOGIC: 
36f7			; eof 
36f7			 
36f7			 
# End of file forth_words_logic.asm
36f7			include "forth_words_maths.asm" 
36f7			 
36f7			; | ## Maths Words 
36f7			 
36f7			.PLUS:	 
36f7				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
36f7 15				db WORD_SYS_CORE+1             
36f8 39 37			dw .NEG            
36fa 02				db 1 + 1 
36fb .. 00			db "+",0              
36fd				endm 
# End of macro CWHEAD
36fd			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
36fd					if DEBUG_FORTH_WORDS_KEY 
36fd						DMARK "PLU" 
36fd f5				push af  
36fe 3a 12 37			ld a, (.dmark)  
3701 32 bd fb			ld (debug_mark),a  
3704 3a 13 37			ld a, (.dmark+1)  
3707 32 be fb			ld (debug_mark+1),a  
370a 3a 14 37			ld a, (.dmark+2)  
370d 32 bf fb			ld (debug_mark+2),a  
3710 18 03			jr .pastdmark  
3712 ..			.dmark: db "PLU"  
3715 f1			.pastdmark: pop af  
3716			endm  
# End of macro DMARK
3716						CALLMONITOR 
3716 cd 65 16			call break_point_state  
3719				endm  
# End of macro CALLMONITOR
3719					endif 
3719					; add top two values and push back result 
3719			 
3719					;for v5 FORTH_DSP_VALUE 
3719					FORTH_DSP 
3719 cd af 1d			call macro_forth_dsp 
371c				endm 
# End of macro FORTH_DSP
371c 7e					ld a,(hl)	; get type of value on TOS 
371d fe 02				cp DS_TYPE_INUM  
371f 28 03				jr z, .dot_inum 
3721			 
3721					NEXTW 
3721 c3 5b 1f			jp macro_next 
3724				endm 
# End of macro NEXTW
3724			 
3724			; float maths 
3724			 
3724				if FORTH_ENABLE_FLOATMATH 
3724						inc hl      ; now at start of numeric as string 
3724			 
3724					if DEBUG_FORTH_MATHS 
3724						DMARK "ADD" 
3724				CALLMONITOR 
3724					endif 
3724			 
3724					;ld ix, hl 
3724					call CON 
3724			 
3724			 
3724					push hl 
3724					 
3724					 
3724			 
3724						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3724			 
3724					; get next number 
3724			 
3724						FORTH_DSP_VALUE 
3724			 
3724						inc hl      ; now at start of numeric as string 
3724			 
3724					;ld ix, hl 
3724					call CON 
3724			 
3724					push hl 
3724			 
3724			 
3724						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3724			 
3724						; TODO do add 
3724			 
3724						call IADD 
3724			 
3724						; TODO get result back as ascii 
3724			 
3724						; TODO push result  
3724			 
3724			 
3724			 
3724						jr .dot_done 
3724				endif 
3724			 
3724			.dot_inum: 
3724			 
3724			 
3724					if DEBUG_FORTH_DOT 
3724						DMARK "+IT" 
3724				CALLMONITOR 
3724					endif 
3724			 
3724					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3724 cd e9 1d			call macro_dsp_valuehl 
3727				endm 
# End of macro FORTH_DSP_VALUEHL
3727			 
3727				; TODO add floating point number detection 
3727			 
3727 e5					push hl 
3728			 
3728					; destroy value TOS 
3728			 
3728					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3728 cd a1 1e			call macro_forth_dsp_pop 
372b				endm 
# End of macro FORTH_DSP_POP
372b			 
372b			 
372b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
372b cd e9 1d			call macro_dsp_valuehl 
372e				endm 
# End of macro FORTH_DSP_VALUEHL
372e			 
372e					; one value on hl get other one back 
372e			 
372e d1					pop de 
372f			 
372f					; do the add 
372f			 
372f 19					add hl,de 
3730			 
3730					; save it 
3730			 
3730			;		push hl	 
3730			 
3730					; 
3730			 
3730					; destroy value TOS 
3730			 
3730					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3730 cd a1 1e			call macro_forth_dsp_pop 
3733				endm 
# End of macro FORTH_DSP_POP
3733			 
3733					; TODO push value back onto stack for another op etc 
3733			 
3733			;		pop hl 
3733			 
3733			.dot_done: 
3733 cd f2 1b				call forth_push_numhl 
3736			 
3736					NEXTW 
3736 c3 5b 1f			jp macro_next 
3739				endm 
# End of macro NEXTW
3739			.NEG: 
3739			 
3739				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3739 17				db WORD_SYS_CORE+3             
373a 7c 37			dw .DIV            
373c 02				db 1 + 1 
373d .. 00			db "-",0              
373f				endm 
# End of macro CWHEAD
373f			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
373f					if DEBUG_FORTH_WORDS_KEY 
373f						DMARK "SUB" 
373f f5				push af  
3740 3a 54 37			ld a, (.dmark)  
3743 32 bd fb			ld (debug_mark),a  
3746 3a 55 37			ld a, (.dmark+1)  
3749 32 be fb			ld (debug_mark+1),a  
374c 3a 56 37			ld a, (.dmark+2)  
374f 32 bf fb			ld (debug_mark+2),a  
3752 18 03			jr .pastdmark  
3754 ..			.dmark: db "SUB"  
3757 f1			.pastdmark: pop af  
3758			endm  
# End of macro DMARK
3758						CALLMONITOR 
3758 cd 65 16			call break_point_state  
375b				endm  
# End of macro CALLMONITOR
375b					endif 
375b			 
375b			 
375b				; TODO add floating point number detection 
375b					; v5 FORTH_DSP_VALUE 
375b					FORTH_DSP 
375b cd af 1d			call macro_forth_dsp 
375e				endm 
# End of macro FORTH_DSP
375e 7e					ld a,(hl)	; get type of value on TOS 
375f fe 02				cp DS_TYPE_INUM  
3761 28 03				jr z, .neg_inum 
3763			 
3763					NEXTW 
3763 c3 5b 1f			jp macro_next 
3766				endm 
# End of macro NEXTW
3766			 
3766			; float maths 
3766			 
3766				if FORTH_ENABLE_FLOATMATH 
3766					jr .neg_done 
3766			 
3766				endif 
3766					 
3766			 
3766			.neg_inum: 
3766					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3766 cd e9 1d			call macro_dsp_valuehl 
3769				endm 
# End of macro FORTH_DSP_VALUEHL
3769			 
3769 e5					push hl 
376a			 
376a					; destroy value TOS 
376a			 
376a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
376a cd a1 1e			call macro_forth_dsp_pop 
376d				endm 
# End of macro FORTH_DSP_POP
376d			 
376d			 
376d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
376d cd e9 1d			call macro_dsp_valuehl 
3770				endm 
# End of macro FORTH_DSP_VALUEHL
3770			 
3770					; one value on hl get other one back 
3770			 
3770 d1					pop de 
3771			 
3771					; do the sub 
3771			;		ex de, hl 
3771			 
3771 ed 52				sbc hl,de 
3773			 
3773					; save it 
3773			 
3773			;		push hl	 
3773			 
3773					; 
3773			 
3773					; destroy value TOS 
3773			 
3773					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3773 cd a1 1e			call macro_forth_dsp_pop 
3776				endm 
# End of macro FORTH_DSP_POP
3776			 
3776					; TODO push value back onto stack for another op etc 
3776			 
3776			;		pop hl 
3776			 
3776 cd f2 1b				call forth_push_numhl 
3779			.neg_done: 
3779			 
3779					NEXTW 
3779 c3 5b 1f			jp macro_next 
377c				endm 
# End of macro NEXTW
377c			.DIV: 
377c				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
377c 18				db WORD_SYS_CORE+4             
377d c9 37			dw .MUL            
377f 02				db 1 + 1 
3780 .. 00			db "/",0              
3782				endm 
# End of macro CWHEAD
3782			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3782					if DEBUG_FORTH_WORDS_KEY 
3782						DMARK "DIV" 
3782 f5				push af  
3783 3a 97 37			ld a, (.dmark)  
3786 32 bd fb			ld (debug_mark),a  
3789 3a 98 37			ld a, (.dmark+1)  
378c 32 be fb			ld (debug_mark+1),a  
378f 3a 99 37			ld a, (.dmark+2)  
3792 32 bf fb			ld (debug_mark+2),a  
3795 18 03			jr .pastdmark  
3797 ..			.dmark: db "DIV"  
379a f1			.pastdmark: pop af  
379b			endm  
# End of macro DMARK
379b						CALLMONITOR 
379b cd 65 16			call break_point_state  
379e				endm  
# End of macro CALLMONITOR
379e					endif 
379e				; TODO add floating point number detection 
379e					; v5 FORTH_DSP_VALUE 
379e					FORTH_DSP 
379e cd af 1d			call macro_forth_dsp 
37a1				endm 
# End of macro FORTH_DSP
37a1 7e					ld a,(hl)	; get type of value on TOS 
37a2 fe 02				cp DS_TYPE_INUM  
37a4 28 03				jr z, .div_inum 
37a6			 
37a6				if FORTH_ENABLE_FLOATMATH 
37a6					jr .div_done 
37a6			 
37a6				endif 
37a6					NEXTW 
37a6 c3 5b 1f			jp macro_next 
37a9				endm 
# End of macro NEXTW
37a9			.div_inum: 
37a9			 
37a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37a9 cd e9 1d			call macro_dsp_valuehl 
37ac				endm 
# End of macro FORTH_DSP_VALUEHL
37ac			 
37ac e5					push hl    ; to go to bc 
37ad			 
37ad					; destroy value TOS 
37ad			 
37ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37ad cd a1 1e			call macro_forth_dsp_pop 
37b0				endm 
# End of macro FORTH_DSP_POP
37b0			 
37b0			 
37b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37b0 cd e9 1d			call macro_dsp_valuehl 
37b3				endm 
# End of macro FORTH_DSP_VALUEHL
37b3			 
37b3					; hl to go to de 
37b3			 
37b3 e5					push hl 
37b4			 
37b4 c1					pop bc 
37b5 d1					pop de		 
37b6			 
37b6			 
37b6					if DEBUG_FORTH_MATHS 
37b6						DMARK "DIV" 
37b6				CALLMONITOR 
37b6					endif 
37b6					; one value on hl but move to a get other one back 
37b6			 
37b6			        
37b6 cd 63 0c			call Div16 
37b9			 
37b9			;	push af	 
37b9 e5				push hl 
37ba c5				push bc 
37bb			 
37bb					if DEBUG_FORTH_MATHS 
37bb						DMARK "DI1" 
37bb				CALLMONITOR 
37bb					endif 
37bb			 
37bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37bb cd a1 1e			call macro_forth_dsp_pop 
37be				endm 
# End of macro FORTH_DSP_POP
37be			 
37be			 
37be			 
37be e1					pop hl    ; result 
37bf			 
37bf cd f2 1b				call forth_push_numhl 
37c2			 
37c2 e1					pop hl    ; reminder 
37c3			;		ld h,0 
37c3			;		ld l,d 
37c3			 
37c3 cd f2 1b				call forth_push_numhl 
37c6			.div_done: 
37c6					NEXTW 
37c6 c3 5b 1f			jp macro_next 
37c9				endm 
# End of macro NEXTW
37c9			.MUL: 
37c9				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
37c9 19				db WORD_SYS_CORE+5             
37ca 0e 38			dw .MIN            
37cc 02				db 1 + 1 
37cd .. 00			db "*",0              
37cf				endm 
# End of macro CWHEAD
37cf			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
37cf				; TODO add floating point number detection 
37cf					if DEBUG_FORTH_WORDS_KEY 
37cf						DMARK "MUL" 
37cf f5				push af  
37d0 3a e4 37			ld a, (.dmark)  
37d3 32 bd fb			ld (debug_mark),a  
37d6 3a e5 37			ld a, (.dmark+1)  
37d9 32 be fb			ld (debug_mark+1),a  
37dc 3a e6 37			ld a, (.dmark+2)  
37df 32 bf fb			ld (debug_mark+2),a  
37e2 18 03			jr .pastdmark  
37e4 ..			.dmark: db "MUL"  
37e7 f1			.pastdmark: pop af  
37e8			endm  
# End of macro DMARK
37e8						CALLMONITOR 
37e8 cd 65 16			call break_point_state  
37eb				endm  
# End of macro CALLMONITOR
37eb					endif 
37eb					FORTH_DSP 
37eb cd af 1d			call macro_forth_dsp 
37ee				endm 
# End of macro FORTH_DSP
37ee					; v5 FORTH_DSP_VALUE 
37ee 7e					ld a,(hl)	; get type of value on TOS 
37ef fe 02				cp DS_TYPE_INUM  
37f1 28 03				jr z, .mul_inum 
37f3			 
37f3				if FORTH_ENABLE_FLOATMATH 
37f3					jr .mul_done 
37f3			 
37f3				endif 
37f3			 
37f3					NEXTW 
37f3 c3 5b 1f			jp macro_next 
37f6				endm 
# End of macro NEXTW
37f6			.mul_inum:	 
37f6			 
37f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37f6 cd e9 1d			call macro_dsp_valuehl 
37f9				endm 
# End of macro FORTH_DSP_VALUEHL
37f9			 
37f9 e5					push hl 
37fa			 
37fa					; destroy value TOS 
37fa			 
37fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37fa cd a1 1e			call macro_forth_dsp_pop 
37fd				endm 
# End of macro FORTH_DSP_POP
37fd			 
37fd			 
37fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37fd cd e9 1d			call macro_dsp_valuehl 
3800				endm 
# End of macro FORTH_DSP_VALUEHL
3800			 
3800					; one value on hl but move to a get other one back 
3800			 
3800 7d					ld a, l 
3801			 
3801 d1					pop de 
3802			 
3802					; do the mull 
3802			;		ex de, hl 
3802			 
3802 cd 89 0c				call Mult16 
3805					; save it 
3805			 
3805			;		push hl	 
3805			 
3805					; 
3805			 
3805					; destroy value TOS 
3805			 
3805					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3805 cd a1 1e			call macro_forth_dsp_pop 
3808				endm 
# End of macro FORTH_DSP_POP
3808			 
3808					; TODO push value back onto stack for another op etc 
3808			 
3808			;		pop hl 
3808			 
3808 cd f2 1b				call forth_push_numhl 
380b			 
380b			.mul_done: 
380b					NEXTW 
380b c3 5b 1f			jp macro_next 
380e				endm 
# End of macro NEXTW
380e			 
380e			 
380e			 
380e			 
380e			.MIN: 
380e				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
380e 49				db WORD_SYS_CORE+53             
380f 8f 38			dw .MAX            
3811 04				db 3 + 1 
3812 .. 00			db "MIN",0              
3816				endm 
# End of macro CWHEAD
3816			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3816					if DEBUG_FORTH_WORDS_KEY 
3816						DMARK "MIN" 
3816 f5				push af  
3817 3a 2b 38			ld a, (.dmark)  
381a 32 bd fb			ld (debug_mark),a  
381d 3a 2c 38			ld a, (.dmark+1)  
3820 32 be fb			ld (debug_mark+1),a  
3823 3a 2d 38			ld a, (.dmark+2)  
3826 32 bf fb			ld (debug_mark+2),a  
3829 18 03			jr .pastdmark  
382b ..			.dmark: db "MIN"  
382e f1			.pastdmark: pop af  
382f			endm  
# End of macro DMARK
382f						CALLMONITOR 
382f cd 65 16			call break_point_state  
3832				endm  
# End of macro CALLMONITOR
3832					endif 
3832					; get u2 
3832			 
3832					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3832 cd e9 1d			call macro_dsp_valuehl 
3835				endm 
# End of macro FORTH_DSP_VALUEHL
3835			 
3835 e5					push hl   ; u2 
3836			 
3836					; destroy value TOS 
3836			 
3836					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3836 cd a1 1e			call macro_forth_dsp_pop 
3839				endm 
# End of macro FORTH_DSP_POP
3839			 
3839					; get u1 
3839			 
3839					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3839 cd e9 1d			call macro_dsp_valuehl 
383c				endm 
# End of macro FORTH_DSP_VALUEHL
383c			 
383c e5					push hl  ; u1 
383d			 
383d					; destroy value TOS 
383d			 
383d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
383d cd a1 1e			call macro_forth_dsp_pop 
3840				endm 
# End of macro FORTH_DSP_POP
3840			 
3840 b7			 or a      ;clear carry flag 
3841 e1			  pop hl    ; u1 
3842 d1			  pop de    ; u2 
3843 e5				push hl   ; saved in case hl is lowest 
3844 ed 52		  sbc hl,de 
3846 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3848			 
3848 e1				pop hl 
3849					if DEBUG_FORTH_WORDS 
3849						DMARK "MIN" 
3849 f5				push af  
384a 3a 5e 38			ld a, (.dmark)  
384d 32 bd fb			ld (debug_mark),a  
3850 3a 5f 38			ld a, (.dmark+1)  
3853 32 be fb			ld (debug_mark+1),a  
3856 3a 60 38			ld a, (.dmark+2)  
3859 32 bf fb			ld (debug_mark+2),a  
385c 18 03			jr .pastdmark  
385e ..			.dmark: db "MIN"  
3861 f1			.pastdmark: pop af  
3862			endm  
# End of macro DMARK
3862						CALLMONITOR 
3862 cd 65 16			call break_point_state  
3865				endm  
# End of macro CALLMONITOR
3865					endif 
3865 cd f2 1b				call forth_push_numhl 
3868			 
3868				       NEXTW 
3868 c3 5b 1f			jp macro_next 
386b				endm 
# End of macro NEXTW
386b			 
386b			.mincont:  
386b c1				pop bc   ; tidy up 
386c eb				ex de , hl  
386d					if DEBUG_FORTH_WORDS 
386d						DMARK "MI1" 
386d f5				push af  
386e 3a 82 38			ld a, (.dmark)  
3871 32 bd fb			ld (debug_mark),a  
3874 3a 83 38			ld a, (.dmark+1)  
3877 32 be fb			ld (debug_mark+1),a  
387a 3a 84 38			ld a, (.dmark+2)  
387d 32 bf fb			ld (debug_mark+2),a  
3880 18 03			jr .pastdmark  
3882 ..			.dmark: db "MI1"  
3885 f1			.pastdmark: pop af  
3886			endm  
# End of macro DMARK
3886						CALLMONITOR 
3886 cd 65 16			call break_point_state  
3889				endm  
# End of macro CALLMONITOR
3889					endif 
3889 cd f2 1b				call forth_push_numhl 
388c			 
388c				       NEXTW 
388c c3 5b 1f			jp macro_next 
388f				endm 
# End of macro NEXTW
388f			.MAX: 
388f				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
388f 4a				db WORD_SYS_CORE+54             
3890 10 39			dw .RND16            
3892 04				db 3 + 1 
3893 .. 00			db "MAX",0              
3897				endm 
# End of macro CWHEAD
3897			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3897					if DEBUG_FORTH_WORDS_KEY 
3897						DMARK "MAX" 
3897 f5				push af  
3898 3a ac 38			ld a, (.dmark)  
389b 32 bd fb			ld (debug_mark),a  
389e 3a ad 38			ld a, (.dmark+1)  
38a1 32 be fb			ld (debug_mark+1),a  
38a4 3a ae 38			ld a, (.dmark+2)  
38a7 32 bf fb			ld (debug_mark+2),a  
38aa 18 03			jr .pastdmark  
38ac ..			.dmark: db "MAX"  
38af f1			.pastdmark: pop af  
38b0			endm  
# End of macro DMARK
38b0						CALLMONITOR 
38b0 cd 65 16			call break_point_state  
38b3				endm  
# End of macro CALLMONITOR
38b3					endif 
38b3					; get u2 
38b3			 
38b3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38b3 cd e9 1d			call macro_dsp_valuehl 
38b6				endm 
# End of macro FORTH_DSP_VALUEHL
38b6			 
38b6 e5					push hl   ; u2 
38b7			 
38b7					; destroy value TOS 
38b7			 
38b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38b7 cd a1 1e			call macro_forth_dsp_pop 
38ba				endm 
# End of macro FORTH_DSP_POP
38ba			 
38ba					; get u1 
38ba			 
38ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38ba cd e9 1d			call macro_dsp_valuehl 
38bd				endm 
# End of macro FORTH_DSP_VALUEHL
38bd			 
38bd e5					push hl  ; u1 
38be			 
38be					; destroy value TOS 
38be			 
38be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38be cd a1 1e			call macro_forth_dsp_pop 
38c1				endm 
# End of macro FORTH_DSP_POP
38c1			 
38c1 b7			 or a      ;clear carry flag 
38c2 e1			  pop hl    ; u1 
38c3 d1			  pop de    ; u2 
38c4 e5				push hl   ; saved in case hl is lowest 
38c5 ed 52		  sbc hl,de 
38c7 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
38c9			 
38c9 e1				pop hl 
38ca					if DEBUG_FORTH_WORDS 
38ca						DMARK "MAX" 
38ca f5				push af  
38cb 3a df 38			ld a, (.dmark)  
38ce 32 bd fb			ld (debug_mark),a  
38d1 3a e0 38			ld a, (.dmark+1)  
38d4 32 be fb			ld (debug_mark+1),a  
38d7 3a e1 38			ld a, (.dmark+2)  
38da 32 bf fb			ld (debug_mark+2),a  
38dd 18 03			jr .pastdmark  
38df ..			.dmark: db "MAX"  
38e2 f1			.pastdmark: pop af  
38e3			endm  
# End of macro DMARK
38e3						CALLMONITOR 
38e3 cd 65 16			call break_point_state  
38e6				endm  
# End of macro CALLMONITOR
38e6					endif 
38e6 cd f2 1b				call forth_push_numhl 
38e9			 
38e9				       NEXTW 
38e9 c3 5b 1f			jp macro_next 
38ec				endm 
# End of macro NEXTW
38ec			 
38ec			.maxcont:  
38ec c1				pop bc   ; tidy up 
38ed eb				ex de , hl  
38ee					if DEBUG_FORTH_WORDS 
38ee						DMARK "MA1" 
38ee f5				push af  
38ef 3a 03 39			ld a, (.dmark)  
38f2 32 bd fb			ld (debug_mark),a  
38f5 3a 04 39			ld a, (.dmark+1)  
38f8 32 be fb			ld (debug_mark+1),a  
38fb 3a 05 39			ld a, (.dmark+2)  
38fe 32 bf fb			ld (debug_mark+2),a  
3901 18 03			jr .pastdmark  
3903 ..			.dmark: db "MA1"  
3906 f1			.pastdmark: pop af  
3907			endm  
# End of macro DMARK
3907						CALLMONITOR 
3907 cd 65 16			call break_point_state  
390a				endm  
# End of macro CALLMONITOR
390a					endif 
390a cd f2 1b				call forth_push_numhl 
390d				       NEXTW 
390d c3 5b 1f			jp macro_next 
3910				endm 
# End of macro NEXTW
3910			 
3910			.RND16: 
3910				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3910 4e				db WORD_SYS_CORE+58             
3911 3f 39			dw .RND8            
3913 06				db 5 + 1 
3914 .. 00			db "RND16",0              
391a				endm 
# End of macro CWHEAD
391a			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
391a					if DEBUG_FORTH_WORDS_KEY 
391a						DMARK "R16" 
391a f5				push af  
391b 3a 2f 39			ld a, (.dmark)  
391e 32 bd fb			ld (debug_mark),a  
3921 3a 30 39			ld a, (.dmark+1)  
3924 32 be fb			ld (debug_mark+1),a  
3927 3a 31 39			ld a, (.dmark+2)  
392a 32 bf fb			ld (debug_mark+2),a  
392d 18 03			jr .pastdmark  
392f ..			.dmark: db "R16"  
3932 f1			.pastdmark: pop af  
3933			endm  
# End of macro DMARK
3933						CALLMONITOR 
3933 cd 65 16			call break_point_state  
3936				endm  
# End of macro CALLMONITOR
3936					endif 
3936 cd 2d 0c				call prng16  
3939 cd f2 1b				call forth_push_numhl 
393c				       NEXTW 
393c c3 5b 1f			jp macro_next 
393f				endm 
# End of macro NEXTW
393f			.RND8: 
393f				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
393f 60				db WORD_SYS_CORE+76             
3940 74 39			dw .RND            
3942 05				db 4 + 1 
3943 .. 00			db "RND8",0              
3948				endm 
# End of macro CWHEAD
3948			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3948					if DEBUG_FORTH_WORDS_KEY 
3948						DMARK "RN8" 
3948 f5				push af  
3949 3a 5d 39			ld a, (.dmark)  
394c 32 bd fb			ld (debug_mark),a  
394f 3a 5e 39			ld a, (.dmark+1)  
3952 32 be fb			ld (debug_mark+1),a  
3955 3a 5f 39			ld a, (.dmark+2)  
3958 32 bf fb			ld (debug_mark+2),a  
395b 18 03			jr .pastdmark  
395d ..			.dmark: db "RN8"  
3960 f1			.pastdmark: pop af  
3961			endm  
# End of macro DMARK
3961						CALLMONITOR 
3961 cd 65 16			call break_point_state  
3964				endm  
# End of macro CALLMONITOR
3964					endif 
3964 2a 3e fa				ld hl,(xrandc) 
3967 23					inc hl 
3968 cd 47 0c				call xrnd 
396b 6f					ld l,a	 
396c 26 00				ld h,0 
396e cd f2 1b				call forth_push_numhl 
3971				       NEXTW 
3971 c3 5b 1f			jp macro_next 
3974				endm 
# End of macro NEXTW
3974			.RND: 
3974				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3974 60				db WORD_SYS_CORE+76             
3975 7a 3a			dw .ENDMATHS            
3977 04				db 3 + 1 
3978 .. 00			db "RND",0              
397c				endm 
# End of macro CWHEAD
397c			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
397c			 
397c					if DEBUG_FORTH_WORDS_KEY 
397c						DMARK "RND" 
397c f5				push af  
397d 3a 91 39			ld a, (.dmark)  
3980 32 bd fb			ld (debug_mark),a  
3983 3a 92 39			ld a, (.dmark+1)  
3986 32 be fb			ld (debug_mark+1),a  
3989 3a 93 39			ld a, (.dmark+2)  
398c 32 bf fb			ld (debug_mark+2),a  
398f 18 03			jr .pastdmark  
3991 ..			.dmark: db "RND"  
3994 f1			.pastdmark: pop af  
3995			endm  
# End of macro DMARK
3995						CALLMONITOR 
3995 cd 65 16			call break_point_state  
3998				endm  
# End of macro CALLMONITOR
3998					endif 
3998					 
3998					FORTH_DSP_VALUEHL    ; upper range 
3998 cd e9 1d			call macro_dsp_valuehl 
399b				endm 
# End of macro FORTH_DSP_VALUEHL
399b			 
399b 22 42 fa				ld (LFSRSeed), hl	 
399e			 
399e					if DEBUG_FORTH_WORDS 
399e						DMARK "RN1" 
399e f5				push af  
399f 3a b3 39			ld a, (.dmark)  
39a2 32 bd fb			ld (debug_mark),a  
39a5 3a b4 39			ld a, (.dmark+1)  
39a8 32 be fb			ld (debug_mark+1),a  
39ab 3a b5 39			ld a, (.dmark+2)  
39ae 32 bf fb			ld (debug_mark+2),a  
39b1 18 03			jr .pastdmark  
39b3 ..			.dmark: db "RN1"  
39b6 f1			.pastdmark: pop af  
39b7			endm  
# End of macro DMARK
39b7						CALLMONITOR 
39b7 cd 65 16			call break_point_state  
39ba				endm  
# End of macro CALLMONITOR
39ba					endif 
39ba					FORTH_DSP_POP 
39ba cd a1 1e			call macro_forth_dsp_pop 
39bd				endm 
# End of macro FORTH_DSP_POP
39bd			 
39bd					FORTH_DSP_VALUEHL    ; low range 
39bd cd e9 1d			call macro_dsp_valuehl 
39c0				endm 
# End of macro FORTH_DSP_VALUEHL
39c0			 
39c0					if DEBUG_FORTH_WORDS 
39c0						DMARK "RN2" 
39c0 f5				push af  
39c1 3a d5 39			ld a, (.dmark)  
39c4 32 bd fb			ld (debug_mark),a  
39c7 3a d6 39			ld a, (.dmark+1)  
39ca 32 be fb			ld (debug_mark+1),a  
39cd 3a d7 39			ld a, (.dmark+2)  
39d0 32 bf fb			ld (debug_mark+2),a  
39d3 18 03			jr .pastdmark  
39d5 ..			.dmark: db "RN2"  
39d8 f1			.pastdmark: pop af  
39d9			endm  
# End of macro DMARK
39d9						CALLMONITOR 
39d9 cd 65 16			call break_point_state  
39dc				endm  
# End of macro CALLMONITOR
39dc					endif 
39dc 22 44 fa				ld (LFSRSeed+2), hl 
39df			 
39df					FORTH_DSP_POP 
39df cd a1 1e			call macro_forth_dsp_pop 
39e2				endm 
# End of macro FORTH_DSP_POP
39e2			 
39e2 e5					push hl 
39e3			 
39e3 e1			.inrange:	pop hl 
39e4 cd 2d 0c				call prng16  
39e7					if DEBUG_FORTH_WORDS 
39e7						DMARK "RN3" 
39e7 f5				push af  
39e8 3a fc 39			ld a, (.dmark)  
39eb 32 bd fb			ld (debug_mark),a  
39ee 3a fd 39			ld a, (.dmark+1)  
39f1 32 be fb			ld (debug_mark+1),a  
39f4 3a fe 39			ld a, (.dmark+2)  
39f7 32 bf fb			ld (debug_mark+2),a  
39fa 18 03			jr .pastdmark  
39fc ..			.dmark: db "RN3"  
39ff f1			.pastdmark: pop af  
3a00			endm  
# End of macro DMARK
3a00						CALLMONITOR 
3a00 cd 65 16			call break_point_state  
3a03				endm  
# End of macro CALLMONITOR
3a03					endif 
3a03					 
3a03					; if the range is 8bit knock out the high byte 
3a03			 
3a03 ed 5b 42 fa			ld de, (LFSRSeed)     ; check high level 
3a07			 
3a07 3e 00				ld a, 0 
3a09 ba					cp d  
3a0a 20 1e				jr nz, .hirange 
3a0c 26 00				ld h, 0   ; knock it down to 8bit 
3a0e			 
3a0e					if DEBUG_FORTH_WORDS 
3a0e						DMARK "RNk" 
3a0e f5				push af  
3a0f 3a 23 3a			ld a, (.dmark)  
3a12 32 bd fb			ld (debug_mark),a  
3a15 3a 24 3a			ld a, (.dmark+1)  
3a18 32 be fb			ld (debug_mark+1),a  
3a1b 3a 25 3a			ld a, (.dmark+2)  
3a1e 32 bf fb			ld (debug_mark+2),a  
3a21 18 03			jr .pastdmark  
3a23 ..			.dmark: db "RNk"  
3a26 f1			.pastdmark: pop af  
3a27			endm  
# End of macro DMARK
3a27						CALLMONITOR 
3a27 cd 65 16			call break_point_state  
3a2a				endm  
# End of macro CALLMONITOR
3a2a					endif 
3a2a			.hirange:   
3a2a e5					push hl  
3a2b b7					or a  
3a2c ed 52		                sbc hl, de 
3a2e			 
3a2e					;call cmp16 
3a2e			 
3a2e 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3a30 e1					pop hl 
3a31 e5					push hl 
3a32			 
3a32					if DEBUG_FORTH_WORDS 
3a32						DMARK "RN4" 
3a32 f5				push af  
3a33 3a 47 3a			ld a, (.dmark)  
3a36 32 bd fb			ld (debug_mark),a  
3a39 3a 48 3a			ld a, (.dmark+1)  
3a3c 32 be fb			ld (debug_mark+1),a  
3a3f 3a 49 3a			ld a, (.dmark+2)  
3a42 32 bf fb			ld (debug_mark+2),a  
3a45 18 03			jr .pastdmark  
3a47 ..			.dmark: db "RN4"  
3a4a f1			.pastdmark: pop af  
3a4b			endm  
# End of macro DMARK
3a4b						CALLMONITOR 
3a4b cd 65 16			call break_point_state  
3a4e				endm  
# End of macro CALLMONITOR
3a4e					endif 
3a4e ed 5b 44 fa			ld de, (LFSRSeed+2)   ; check low range 
3a52					;call cmp16 
3a52				 
3a52 b7					or a  
3a53 ed 52		                sbc hl, de 
3a55 38 8c				jr c, .inrange 
3a57			 
3a57 e1					pop hl 
3a58					 
3a58					if DEBUG_FORTH_WORDS 
3a58						DMARK "RNd" 
3a58 f5				push af  
3a59 3a 6d 3a			ld a, (.dmark)  
3a5c 32 bd fb			ld (debug_mark),a  
3a5f 3a 6e 3a			ld a, (.dmark+1)  
3a62 32 be fb			ld (debug_mark+1),a  
3a65 3a 6f 3a			ld a, (.dmark+2)  
3a68 32 bf fb			ld (debug_mark+2),a  
3a6b 18 03			jr .pastdmark  
3a6d ..			.dmark: db "RNd"  
3a70 f1			.pastdmark: pop af  
3a71			endm  
# End of macro DMARK
3a71						CALLMONITOR 
3a71 cd 65 16			call break_point_state  
3a74				endm  
# End of macro CALLMONITOR
3a74					endif 
3a74			 
3a74			 
3a74 cd f2 1b				call forth_push_numhl 
3a77				       NEXTW 
3a77 c3 5b 1f			jp macro_next 
3a7a				endm 
# End of macro NEXTW
3a7a			 
3a7a			.ENDMATHS: 
3a7a			 
3a7a			; eof 
3a7a			 
# End of file forth_words_maths.asm
3a7a			include "forth_words_display.asm" 
3a7a			 
3a7a			; | ## Display Words 
3a7a			 
3a7a			.ATP: 
3a7a				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a7a 62				db WORD_SYS_CORE+78             
3a7b f1 3a			dw .FB            
3a7d 04				db 3 + 1 
3a7e .. 00			db "AT?",0              
3a82				endm 
# End of macro CWHEAD
3a82			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a82					if DEBUG_FORTH_WORDS_KEY 
3a82						DMARK "AT?" 
3a82 f5				push af  
3a83 3a 97 3a			ld a, (.dmark)  
3a86 32 bd fb			ld (debug_mark),a  
3a89 3a 98 3a			ld a, (.dmark+1)  
3a8c 32 be fb			ld (debug_mark+1),a  
3a8f 3a 99 3a			ld a, (.dmark+2)  
3a92 32 bf fb			ld (debug_mark+2),a  
3a95 18 03			jr .pastdmark  
3a97 ..			.dmark: db "AT?"  
3a9a f1			.pastdmark: pop af  
3a9b			endm  
# End of macro DMARK
3a9b						CALLMONITOR 
3a9b cd 65 16			call break_point_state  
3a9e				endm  
# End of macro CALLMONITOR
3a9e					endif 
3a9e 3a cc f9				ld a, (f_cursor_ptr) 
3aa1			 
3aa1			if DEBUG_FORTH_WORDS 
3aa1				DMARK "AT?" 
3aa1 f5				push af  
3aa2 3a b6 3a			ld a, (.dmark)  
3aa5 32 bd fb			ld (debug_mark),a  
3aa8 3a b7 3a			ld a, (.dmark+1)  
3aab 32 be fb			ld (debug_mark+1),a  
3aae 3a b8 3a			ld a, (.dmark+2)  
3ab1 32 bf fb			ld (debug_mark+2),a  
3ab4 18 03			jr .pastdmark  
3ab6 ..			.dmark: db "AT?"  
3ab9 f1			.pastdmark: pop af  
3aba			endm  
# End of macro DMARK
3aba				CALLMONITOR 
3aba cd 65 16			call break_point_state  
3abd				endm  
# End of macro CALLMONITOR
3abd			endif	 
3abd					; count the number of rows 
3abd			 
3abd 06 00				ld b, 0 
3abf 4f			.atpr:		ld c, a    ; save in case we go below zero 
3ac0 d6 14				sub display_cols 
3ac2 f2 c8 3a				jp p, .atprunder 
3ac5 04					inc b 
3ac6 18 f7				jr .atpr 
3ac8			.atprunder:	 
3ac8			if DEBUG_FORTH_WORDS 
3ac8				DMARK "A?2" 
3ac8 f5				push af  
3ac9 3a dd 3a			ld a, (.dmark)  
3acc 32 bd fb			ld (debug_mark),a  
3acf 3a de 3a			ld a, (.dmark+1)  
3ad2 32 be fb			ld (debug_mark+1),a  
3ad5 3a df 3a			ld a, (.dmark+2)  
3ad8 32 bf fb			ld (debug_mark+2),a  
3adb 18 03			jr .pastdmark  
3add ..			.dmark: db "A?2"  
3ae0 f1			.pastdmark: pop af  
3ae1			endm  
# End of macro DMARK
3ae1				CALLMONITOR 
3ae1 cd 65 16			call break_point_state  
3ae4				endm  
# End of macro CALLMONITOR
3ae4			endif	 
3ae4 26 00				ld h, 0 
3ae6 69					ld l, c 
3ae7 cd f2 1b				call forth_push_numhl 
3aea 68					ld l, b  
3aeb cd f2 1b				call forth_push_numhl 
3aee			 
3aee			 
3aee				NEXTW 
3aee c3 5b 1f			jp macro_next 
3af1				endm 
# End of macro NEXTW
3af1			 
3af1			.FB: 
3af1				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3af1 1b				db WORD_SYS_CORE+7             
3af2 3f 3b			dw .EMIT            
3af4 03				db 2 + 1 
3af5 .. 00			db "FB",0              
3af8				endm 
# End of macro CWHEAD
3af8			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3af8			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3af8			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3af8			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3af8					if DEBUG_FORTH_WORDS_KEY 
3af8						DMARK "FB." 
3af8 f5				push af  
3af9 3a 0d 3b			ld a, (.dmark)  
3afc 32 bd fb			ld (debug_mark),a  
3aff 3a 0e 3b			ld a, (.dmark+1)  
3b02 32 be fb			ld (debug_mark+1),a  
3b05 3a 0f 3b			ld a, (.dmark+2)  
3b08 32 bf fb			ld (debug_mark+2),a  
3b0b 18 03			jr .pastdmark  
3b0d ..			.dmark: db "FB."  
3b10 f1			.pastdmark: pop af  
3b11			endm  
# End of macro DMARK
3b11						CALLMONITOR 
3b11 cd 65 16			call break_point_state  
3b14				endm  
# End of macro CALLMONITOR
3b14					endif 
3b14			 
3b14					FORTH_DSP_VALUEHL 
3b14 cd e9 1d			call macro_dsp_valuehl 
3b17				endm 
# End of macro FORTH_DSP_VALUEHL
3b17			 
3b17 7d					ld a, l 
3b18 fe 01				cp 1 
3b1a 20 05				jr nz, .fbn1 
3b1c 21 02 fb				ld hl, display_fb1 
3b1f 18 15				jr .fbset 
3b21 fe 02		.fbn1:		cp 2 
3b23 20 05				jr nz, .fbn2 
3b25 21 60 fa				ld hl, display_fb2 
3b28 18 0c				jr .fbset 
3b2a fe 03		.fbn2:		cp 3 
3b2c 20 05				jr nz, .fbn3 
3b2e 21 b1 fa				ld hl, display_fb3 
3b31 18 03				jr .fbset 
3b33			.fbn3:		 ; if invalid number select first 
3b33 21 02 fb				ld hl, display_fb1 
3b36 22 5e fa		.fbset:		ld (display_fb_active), hl 
3b39			 
3b39					FORTH_DSP_POP 
3b39 cd a1 1e			call macro_forth_dsp_pop 
3b3c				endm 
# End of macro FORTH_DSP_POP
3b3c			 
3b3c					NEXTW 
3b3c c3 5b 1f			jp macro_next 
3b3f				endm 
# End of macro NEXTW
3b3f			 
3b3f			 
3b3f			.EMIT: 
3b3f				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3b3f 1b				db WORD_SYS_CORE+7             
3b40 90 3b			dw .DOTH            
3b42 05				db 4 + 1 
3b43 .. 00			db "EMIT",0              
3b48				endm 
# End of macro CWHEAD
3b48			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b48					; get value off TOS and display it 
3b48			 
3b48					if DEBUG_FORTH_WORDS_KEY 
3b48						DMARK "EMT" 
3b48 f5				push af  
3b49 3a 5d 3b			ld a, (.dmark)  
3b4c 32 bd fb			ld (debug_mark),a  
3b4f 3a 5e 3b			ld a, (.dmark+1)  
3b52 32 be fb			ld (debug_mark+1),a  
3b55 3a 5f 3b			ld a, (.dmark+2)  
3b58 32 bf fb			ld (debug_mark+2),a  
3b5b 18 03			jr .pastdmark  
3b5d ..			.dmark: db "EMT"  
3b60 f1			.pastdmark: pop af  
3b61			endm  
# End of macro DMARK
3b61						CALLMONITOR 
3b61 cd 65 16			call break_point_state  
3b64				endm  
# End of macro CALLMONITOR
3b64					endif 
3b64			 
3b64					FORTH_DSP_VALUEHL 
3b64 cd e9 1d			call macro_dsp_valuehl 
3b67				endm 
# End of macro FORTH_DSP_VALUEHL
3b67			 
3b67 7d					ld a,l 
3b68			 
3b68					; TODO write to display 
3b68			 
3b68 32 a1 f1				ld (os_input), a 
3b6b 3e 00				ld a, 0 
3b6d 32 a2 f1				ld (os_input+1), a 
3b70					 
3b70 3a cc f9				ld a, (f_cursor_ptr) 
3b73 11 a1 f1				ld de, os_input 
3b76 cd e5 0a				call str_at_display 
3b79			 
3b79			 
3b79 3a aa f9				ld a,(cli_autodisplay) 
3b7c fe 00				cp 0 
3b7e 28 03				jr z, .enoupdate 
3b80 cd f5 0a						call update_display 
3b83					.enoupdate: 
3b83			 
3b83 3a cc f9				ld a, (f_cursor_ptr) 
3b86 3c					inc a 
3b87 32 cc f9				ld (f_cursor_ptr), a   ; save new pos 
3b8a			 
3b8a			 
3b8a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b8a cd a1 1e			call macro_forth_dsp_pop 
3b8d				endm 
# End of macro FORTH_DSP_POP
3b8d			  
3b8d			 
3b8d					NEXTW 
3b8d c3 5b 1f			jp macro_next 
3b90				endm 
# End of macro NEXTW
3b90			.DOTH: 
3b90				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b90 1c				db WORD_SYS_CORE+8             
3b91 c0 3b			dw .DOTF            
3b93 03				db 2 + 1 
3b94 .. 00			db ".-",0              
3b97				endm 
# End of macro CWHEAD
3b97			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b97					; get value off TOS and display it 
3b97					if DEBUG_FORTH_WORDS_KEY 
3b97						DMARK "DTD" 
3b97 f5				push af  
3b98 3a ac 3b			ld a, (.dmark)  
3b9b 32 bd fb			ld (debug_mark),a  
3b9e 3a ad 3b			ld a, (.dmark+1)  
3ba1 32 be fb			ld (debug_mark+1),a  
3ba4 3a ae 3b			ld a, (.dmark+2)  
3ba7 32 bf fb			ld (debug_mark+2),a  
3baa 18 03			jr .pastdmark  
3bac ..			.dmark: db "DTD"  
3baf f1			.pastdmark: pop af  
3bb0			endm  
# End of macro DMARK
3bb0						CALLMONITOR 
3bb0 cd 65 16			call break_point_state  
3bb3				endm  
# End of macro CALLMONITOR
3bb3					endif 
3bb3 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3bb5 3e 00			ld a, 0 
3bb7 32 ab f9			ld (cli_mvdot), a 
3bba c3 17 3c			jp .dotgo 
3bbd				NEXTW 
3bbd c3 5b 1f			jp macro_next 
3bc0				endm 
# End of macro NEXTW
3bc0			.DOTF: 
3bc0				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3bc0 1c				db WORD_SYS_CORE+8             
3bc1 ee 3b			dw .DOT            
3bc3 03				db 2 + 1 
3bc4 .. 00			db ".>",0              
3bc7				endm 
# End of macro CWHEAD
3bc7			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3bc7					; get value off TOS and display it 
3bc7			        ; TODO BUG adds extra spaces 
3bc7			        ; TODO BUG handle numerics? 
3bc7					if DEBUG_FORTH_WORDS_KEY 
3bc7						DMARK "DTC" 
3bc7 f5				push af  
3bc8 3a dc 3b			ld a, (.dmark)  
3bcb 32 bd fb			ld (debug_mark),a  
3bce 3a dd 3b			ld a, (.dmark+1)  
3bd1 32 be fb			ld (debug_mark+1),a  
3bd4 3a de 3b			ld a, (.dmark+2)  
3bd7 32 bf fb			ld (debug_mark+2),a  
3bda 18 03			jr .pastdmark  
3bdc ..			.dmark: db "DTC"  
3bdf f1			.pastdmark: pop af  
3be0			endm  
# End of macro DMARK
3be0						CALLMONITOR 
3be0 cd 65 16			call break_point_state  
3be3				endm  
# End of macro CALLMONITOR
3be3					endif 
3be3 3e 01			ld a, 1 
3be5 32 ab f9			ld (cli_mvdot), a 
3be8 c3 17 3c			jp .dotgo 
3beb				NEXTW 
3beb c3 5b 1f			jp macro_next 
3bee				endm 
# End of macro NEXTW
3bee			 
3bee			.DOT: 
3bee				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3bee 1c				db WORD_SYS_CORE+8             
3bef 7a 3c			dw .CLS            
3bf1 02				db 1 + 1 
3bf2 .. 00			db ".",0              
3bf4				endm 
# End of macro CWHEAD
3bf4			        ; | . ( u -- ) Display TOS | DONE 
3bf4					; get value off TOS and display it 
3bf4			 
3bf4					if DEBUG_FORTH_WORDS_KEY 
3bf4						DMARK "DOT" 
3bf4 f5				push af  
3bf5 3a 09 3c			ld a, (.dmark)  
3bf8 32 bd fb			ld (debug_mark),a  
3bfb 3a 0a 3c			ld a, (.dmark+1)  
3bfe 32 be fb			ld (debug_mark+1),a  
3c01 3a 0b 3c			ld a, (.dmark+2)  
3c04 32 bf fb			ld (debug_mark+2),a  
3c07 18 03			jr .pastdmark  
3c09 ..			.dmark: db "DOT"  
3c0c f1			.pastdmark: pop af  
3c0d			endm  
# End of macro DMARK
3c0d						CALLMONITOR 
3c0d cd 65 16			call break_point_state  
3c10				endm  
# End of macro CALLMONITOR
3c10					endif 
3c10 3e 00			ld a, 0 
3c12 32 ab f9			ld (cli_mvdot), a 
3c15 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3c17				 
3c17			 
3c17			.dotgo: 
3c17			 
3c17			; move up type to on stack for parserv5 
3c17					FORTH_DSP 
3c17 cd af 1d			call macro_forth_dsp 
3c1a				endm 
# End of macro FORTH_DSP
3c1a				;FORTH_DSP_VALUE  
3c1a			 
3c1a			if DEBUG_FORTH_DOT 
3c1a				DMARK "DOT" 
3c1a				CALLMONITOR 
3c1a			endif	 
3c1a			;		.print: 
3c1a			 
3c1a 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3c1b 23				inc hl   ; position to the actual value 
3c1c fe 01			cp DS_TYPE_STR 
3c1e 20 06			jr nz, .dotnum1  
3c20			 
3c20			; display string 
3c20				FORTH_DSP_VALUE  
3c20 cd d2 1d			call macro_forth_dsp_value 
3c23				endm 
# End of macro FORTH_DSP_VALUE
3c23 eb				ex de,hl 
3c24 18 11			jr .dotwrite 
3c26			 
3c26			.dotnum1: 
3c26 fe 02			cp DS_TYPE_INUM 
3c28 20 0c			jr nz, .dotflot 
3c2a			 
3c2a			 
3c2a			; display number 
3c2a			 
3c2a			;	push hl 
3c2a			;	call clear_display 
3c2a			;	pop hl 
3c2a			 
3c2a 5e				ld e, (hl) 
3c2b 23				inc hl 
3c2c 56				ld d, (hl) 
3c2d 21 a3 ef			ld hl, scratch 
3c30			if DEBUG_FORTH_DOT 
3c30				DMARK "DT1" 
3c30				CALLMONITOR 
3c30			endif	 
3c30			 
3c30 cd 13 11			call uitoa_16 
3c33 eb				ex de,hl 
3c34			 
3c34			if DEBUG_FORTH_DOT 
3c34				DMARK "DT2" 
3c34				CALLMONITOR 
3c34			endif	 
3c34			 
3c34			;	ld de, os_word_scratch 
3c34 18 01			jr .dotwrite 
3c36			 
3c36 00			.dotflot:   nop 
3c37			; TODO print floating point number 
3c37			 
3c37			.dotwrite:		 
3c37			 
3c37					; if c is set then set all '-' to spaces 
3c37					; need to also take into account .>  
3c37			 
3c37 3e 01				ld a, 1 
3c39 b9					cp c 
3c3a 20 13				jr nz, .nodashswap 
3c3c			 
3c3c					; DE has the string to write, working with HL 
3c3c			 
3c3c 06 ff				ld b, 255 
3c3e d5					push de 
3c3f e1					pop hl 
3c40			 
3c40			if DEBUG_FORTH_DOT 
3c40				DMARK "DT-" 
3c40				CALLMONITOR 
3c40			endif	 
3c40 7e			.dashscan:	ld a, (hl) 
3c41 fe 00				cp 0 
3c43 28 0a				jr z, .nodashswap 
3c45 fe 2d				cp '-' 
3c47 20 03				jr nz, .dashskip 
3c49 3e 20				ld a, ' ' 
3c4b 77					ld (hl), a 
3c4c 23			.dashskip:	inc hl 
3c4d			if DEBUG_FORTH_DOT 
3c4d				DMARK "D-2" 
3c4d				CALLMONITOR 
3c4d			endif	 
3c4d 10 f1				djnz .dashscan 
3c4f			 
3c4f			if DEBUG_FORTH_DOT 
3c4f				DMARK "D-1" 
3c4f				CALLMONITOR 
3c4f			endif	 
3c4f			 
3c4f			.nodashswap: 
3c4f			 
3c4f e5					push hl   ; save string start in case we need to advance print 
3c50			 
3c50 3a cc f9				ld a, (f_cursor_ptr) 
3c53 cd e5 0a				call str_at_display 
3c56 3a aa f9				ld a,(cli_autodisplay) 
3c59 fe 00				cp 0 
3c5b 28 03				jr z, .noupdate 
3c5d cd f5 0a						call update_display 
3c60					.noupdate: 
3c60			 
3c60			 
3c60					; see if we need to advance the print position 
3c60			 
3c60 e1					pop hl   ; get back string 
3c61			 
3c61 3a ab f9				ld a, (cli_mvdot) 
3c64			if DEBUG_FORTH_DOT 
3c64					ld e,a 
3c64				DMARK "D>1" 
3c64				CALLMONITOR 
3c64			endif	 
3c64 fe 00				cp 0 
3c66 28 0c				jr z, .noadv 
3c68					; yes, lets advance the print position 
3c68 3e 00				ld a, 0 
3c6a cd 6f 11				call strlent 
3c6d 3a cc f9				ld a, (f_cursor_ptr) 
3c70 85					add a,l 
3c71					;call addatohl 
3c71					;ld a, l 
3c71 32 cc f9				ld (f_cursor_ptr), a   ; save new pos 
3c74			 
3c74			if DEBUG_FORTH_DOT 
3c74				DMARK "D->" 
3c74				CALLMONITOR 
3c74			endif	 
3c74			 
3c74			.noadv:	 
3c74			 
3c74					if DEBUG_FORTH_DOT_WAIT 
3c74							call next_page_prompt 
3c74					endif	 
3c74			; TODO this pop off the stack causes a crash. i dont know why 
3c74			 
3c74			 
3c74			if DEBUG_FORTH_DOT 
3c74				DMARK "DTh" 
3c74				CALLMONITOR 
3c74			endif	 
3c74			 
3c74					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c74 cd a1 1e			call macro_forth_dsp_pop 
3c77				endm 
# End of macro FORTH_DSP_POP
3c77			 
3c77			if DEBUG_FORTH_DOT 
3c77				DMARK "DTi" 
3c77				CALLMONITOR 
3c77			endif	 
3c77			 
3c77			 
3c77					NEXTW 
3c77 c3 5b 1f			jp macro_next 
3c7a				endm 
# End of macro NEXTW
3c7a			 
3c7a			.CLS: 
3c7a				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3c7a 35				db WORD_SYS_CORE+33             
3c7b a7 3c			dw .DRAW            
3c7d 04				db 3 + 1 
3c7e .. 00			db "CLS",0              
3c82				endm 
# End of macro CWHEAD
3c82			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3c82					if DEBUG_FORTH_WORDS_KEY 
3c82						DMARK "CLS" 
3c82 f5				push af  
3c83 3a 97 3c			ld a, (.dmark)  
3c86 32 bd fb			ld (debug_mark),a  
3c89 3a 98 3c			ld a, (.dmark+1)  
3c8c 32 be fb			ld (debug_mark+1),a  
3c8f 3a 99 3c			ld a, (.dmark+2)  
3c92 32 bf fb			ld (debug_mark+2),a  
3c95 18 03			jr .pastdmark  
3c97 ..			.dmark: db "CLS"  
3c9a f1			.pastdmark: pop af  
3c9b			endm  
# End of macro DMARK
3c9b						CALLMONITOR 
3c9b cd 65 16			call break_point_state  
3c9e				endm  
# End of macro CALLMONITOR
3c9e					endif 
3c9e cd d2 0a				call clear_display 
3ca1 c3 b5 3d				jp .home		; and home cursor 
3ca4					NEXTW 
3ca4 c3 5b 1f			jp macro_next 
3ca7				endm 
# End of macro NEXTW
3ca7			 
3ca7			.DRAW: 
3ca7				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3ca7 36				db WORD_SYS_CORE+34             
3ca8 d2 3c			dw .DUMP            
3caa 05				db 4 + 1 
3cab .. 00			db "DRAW",0              
3cb0				endm 
# End of macro CWHEAD
3cb0			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3cb0					if DEBUG_FORTH_WORDS_KEY 
3cb0						DMARK "DRW" 
3cb0 f5				push af  
3cb1 3a c5 3c			ld a, (.dmark)  
3cb4 32 bd fb			ld (debug_mark),a  
3cb7 3a c6 3c			ld a, (.dmark+1)  
3cba 32 be fb			ld (debug_mark+1),a  
3cbd 3a c7 3c			ld a, (.dmark+2)  
3cc0 32 bf fb			ld (debug_mark+2),a  
3cc3 18 03			jr .pastdmark  
3cc5 ..			.dmark: db "DRW"  
3cc8 f1			.pastdmark: pop af  
3cc9			endm  
# End of macro DMARK
3cc9						CALLMONITOR 
3cc9 cd 65 16			call break_point_state  
3ccc				endm  
# End of macro CALLMONITOR
3ccc					endif 
3ccc cd f5 0a				call update_display 
3ccf					NEXTW 
3ccf c3 5b 1f			jp macro_next 
3cd2				endm 
# End of macro NEXTW
3cd2			 
3cd2			.DUMP: 
3cd2				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3cd2 37				db WORD_SYS_CORE+35             
3cd3 0a 3d			dw .CDUMP            
3cd5 05				db 4 + 1 
3cd6 .. 00			db "DUMP",0              
3cdb				endm 
# End of macro CWHEAD
3cdb			; | DUMP ( x -- ) With address x display dump   | DONE 
3cdb			; TODO pop address to use off of the stack 
3cdb					if DEBUG_FORTH_WORDS_KEY 
3cdb						DMARK "DUM" 
3cdb f5				push af  
3cdc 3a f0 3c			ld a, (.dmark)  
3cdf 32 bd fb			ld (debug_mark),a  
3ce2 3a f1 3c			ld a, (.dmark+1)  
3ce5 32 be fb			ld (debug_mark+1),a  
3ce8 3a f2 3c			ld a, (.dmark+2)  
3ceb 32 bf fb			ld (debug_mark+2),a  
3cee 18 03			jr .pastdmark  
3cf0 ..			.dmark: db "DUM"  
3cf3 f1			.pastdmark: pop af  
3cf4			endm  
# End of macro DMARK
3cf4						CALLMONITOR 
3cf4 cd 65 16			call break_point_state  
3cf7				endm  
# End of macro CALLMONITOR
3cf7					endif 
3cf7 cd d2 0a				call clear_display 
3cfa			 
3cfa					; get address 
3cfa			 
3cfa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cfa cd e9 1d			call macro_dsp_valuehl 
3cfd				endm 
# End of macro FORTH_DSP_VALUEHL
3cfd				 
3cfd					; save it for cdump 
3cfd			 
3cfd 22 c6 f2				ld (os_cur_ptr),hl 
3d00			 
3d00					; destroy value TOS 
3d00			 
3d00					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d00 cd a1 1e			call macro_forth_dsp_pop 
3d03				endm 
# End of macro FORTH_DSP_POP
3d03			 
3d03 cd 72 1a				call dumpcont	; skip old style of param parsing	 
3d06 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3d07					NEXTW 
3d07 c3 5b 1f			jp macro_next 
3d0a				endm 
# End of macro NEXTW
3d0a			.CDUMP: 
3d0a				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3d0a 38				db WORD_SYS_CORE+36             
3d0b 3a 3d			dw .DAT            
3d0d 06				db 5 + 1 
3d0e .. 00			db "CDUMP",0              
3d14				endm 
# End of macro CWHEAD
3d14			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3d14					if DEBUG_FORTH_WORDS_KEY 
3d14						DMARK "CDP" 
3d14 f5				push af  
3d15 3a 29 3d			ld a, (.dmark)  
3d18 32 bd fb			ld (debug_mark),a  
3d1b 3a 2a 3d			ld a, (.dmark+1)  
3d1e 32 be fb			ld (debug_mark+1),a  
3d21 3a 2b 3d			ld a, (.dmark+2)  
3d24 32 bf fb			ld (debug_mark+2),a  
3d27 18 03			jr .pastdmark  
3d29 ..			.dmark: db "CDP"  
3d2c f1			.pastdmark: pop af  
3d2d			endm  
# End of macro DMARK
3d2d						CALLMONITOR 
3d2d cd 65 16			call break_point_state  
3d30				endm  
# End of macro CALLMONITOR
3d30					endif 
3d30 cd d2 0a				call clear_display 
3d33 cd 72 1a				call dumpcont	 
3d36 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3d37					NEXTW 
3d37 c3 5b 1f			jp macro_next 
3d3a				endm 
# End of macro NEXTW
3d3a			 
3d3a			 
3d3a			 
3d3a			 
3d3a			.DAT: 
3d3a				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3d3a 3d				db WORD_SYS_CORE+41             
3d3b 90 3d			dw .HOME            
3d3d 03				db 2 + 1 
3d3e .. 00			db "AT",0              
3d41				endm 
# End of macro CWHEAD
3d41			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3d41					if DEBUG_FORTH_WORDS_KEY 
3d41						DMARK "AT." 
3d41 f5				push af  
3d42 3a 56 3d			ld a, (.dmark)  
3d45 32 bd fb			ld (debug_mark),a  
3d48 3a 57 3d			ld a, (.dmark+1)  
3d4b 32 be fb			ld (debug_mark+1),a  
3d4e 3a 58 3d			ld a, (.dmark+2)  
3d51 32 bf fb			ld (debug_mark+2),a  
3d54 18 03			jr .pastdmark  
3d56 ..			.dmark: db "AT."  
3d59 f1			.pastdmark: pop af  
3d5a			endm  
# End of macro DMARK
3d5a						CALLMONITOR 
3d5a cd 65 16			call break_point_state  
3d5d				endm  
# End of macro CALLMONITOR
3d5d					endif 
3d5d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d5d cd e9 1d			call macro_dsp_valuehl 
3d60				endm 
# End of macro FORTH_DSP_VALUEHL
3d60			 
3d60			 
3d60					; TODO save cursor row 
3d60 7d					ld a,l 
3d61 fe 02				cp 2 
3d63 20 04				jr nz, .crow3 
3d65 3e 14				ld a, display_row_2 
3d67 18 12				jr .ccol1 
3d69 fe 03		.crow3:		cp 3 
3d6b 20 04				jr nz, .crow4 
3d6d 3e 28				ld a, display_row_3 
3d6f 18 0a				jr .ccol1 
3d71 fe 04		.crow4:		cp 4 
3d73 20 04				jr nz, .crow1 
3d75 3e 3c				ld a, display_row_4 
3d77 18 02				jr .ccol1 
3d79 3e 00		.crow1:		ld a,display_row_1 
3d7b f5			.ccol1:		push af			; got row offset 
3d7c 6f					ld l,a 
3d7d 26 00				ld h,0 
3d7f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d7f cd a1 1e			call macro_forth_dsp_pop 
3d82				endm 
# End of macro FORTH_DSP_POP
3d82					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d82 cd e9 1d			call macro_dsp_valuehl 
3d85				endm 
# End of macro FORTH_DSP_VALUEHL
3d85					; TODO save cursor col 
3d85 f1					pop af 
3d86 85					add l		; add col offset 
3d87 32 cc f9				ld (f_cursor_ptr), a 
3d8a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d8a cd a1 1e			call macro_forth_dsp_pop 
3d8d				endm 
# End of macro FORTH_DSP_POP
3d8d			 
3d8d					; calculate  
3d8d			 
3d8d					NEXTW 
3d8d c3 5b 1f			jp macro_next 
3d90				endm 
# End of macro NEXTW
3d90			 
3d90			 
3d90			.HOME: 
3d90				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3d90 41				db WORD_SYS_CORE+45             
3d91 bd 3d			dw .SPACE            
3d93 05				db 4 + 1 
3d94 .. 00			db "HOME",0              
3d99				endm 
# End of macro CWHEAD
3d99			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3d99					if DEBUG_FORTH_WORDS_KEY 
3d99						DMARK "HOM" 
3d99 f5				push af  
3d9a 3a ae 3d			ld a, (.dmark)  
3d9d 32 bd fb			ld (debug_mark),a  
3da0 3a af 3d			ld a, (.dmark+1)  
3da3 32 be fb			ld (debug_mark+1),a  
3da6 3a b0 3d			ld a, (.dmark+2)  
3da9 32 bf fb			ld (debug_mark+2),a  
3dac 18 03			jr .pastdmark  
3dae ..			.dmark: db "HOM"  
3db1 f1			.pastdmark: pop af  
3db2			endm  
# End of macro DMARK
3db2						CALLMONITOR 
3db2 cd 65 16			call break_point_state  
3db5				endm  
# End of macro CALLMONITOR
3db5					endif 
3db5 3e 00		.home:		ld a, 0		; and home cursor 
3db7 32 cc f9				ld (f_cursor_ptr), a 
3dba					NEXTW 
3dba c3 5b 1f			jp macro_next 
3dbd				endm 
# End of macro NEXTW
3dbd			 
3dbd			 
3dbd			.SPACE: 
3dbd				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3dbd 46				db WORD_SYS_CORE+50             
3dbe eb 3d			dw .SPACES            
3dc0 03				db 2 + 1 
3dc1 .. 00			db "BL",0              
3dc4				endm 
# End of macro CWHEAD
3dc4			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3dc4					if DEBUG_FORTH_WORDS_KEY 
3dc4						DMARK "BL." 
3dc4 f5				push af  
3dc5 3a d9 3d			ld a, (.dmark)  
3dc8 32 bd fb			ld (debug_mark),a  
3dcb 3a da 3d			ld a, (.dmark+1)  
3dce 32 be fb			ld (debug_mark+1),a  
3dd1 3a db 3d			ld a, (.dmark+2)  
3dd4 32 bf fb			ld (debug_mark+2),a  
3dd7 18 03			jr .pastdmark  
3dd9 ..			.dmark: db "BL."  
3ddc f1			.pastdmark: pop af  
3ddd			endm  
# End of macro DMARK
3ddd						CALLMONITOR 
3ddd cd 65 16			call break_point_state  
3de0				endm  
# End of macro CALLMONITOR
3de0					endif 
3de0 21 e9 3d				ld hl, .blstr 
3de3 cd 60 1c				call forth_push_str 
3de6					 
3de6				       NEXTW 
3de6 c3 5b 1f			jp macro_next 
3de9				endm 
# End of macro NEXTW
3de9			 
3de9 .. 00		.blstr: db " ", 0 
3deb			 
3deb			.SPACES: 
3deb				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3deb 47				db WORD_SYS_CORE+51             
3dec 86 3e			dw .SCROLL            
3dee 07				db 6 + 1 
3def .. 00			db "SPACES",0              
3df6				endm 
# End of macro CWHEAD
3df6			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3df6					if DEBUG_FORTH_WORDS_KEY 
3df6						DMARK "SPS" 
3df6 f5				push af  
3df7 3a 0b 3e			ld a, (.dmark)  
3dfa 32 bd fb			ld (debug_mark),a  
3dfd 3a 0c 3e			ld a, (.dmark+1)  
3e00 32 be fb			ld (debug_mark+1),a  
3e03 3a 0d 3e			ld a, (.dmark+2)  
3e06 32 bf fb			ld (debug_mark+2),a  
3e09 18 03			jr .pastdmark  
3e0b ..			.dmark: db "SPS"  
3e0e f1			.pastdmark: pop af  
3e0f			endm  
# End of macro DMARK
3e0f						CALLMONITOR 
3e0f cd 65 16			call break_point_state  
3e12				endm  
# End of macro CALLMONITOR
3e12					endif 
3e12			 
3e12			 
3e12					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e12 cd e9 1d			call macro_dsp_valuehl 
3e15				endm 
# End of macro FORTH_DSP_VALUEHL
3e15			 
3e15			;		push hl    ; u 
3e15					if DEBUG_FORTH_WORDS 
3e15						DMARK "SPA" 
3e15 f5				push af  
3e16 3a 2a 3e			ld a, (.dmark)  
3e19 32 bd fb			ld (debug_mark),a  
3e1c 3a 2b 3e			ld a, (.dmark+1)  
3e1f 32 be fb			ld (debug_mark+1),a  
3e22 3a 2c 3e			ld a, (.dmark+2)  
3e25 32 bf fb			ld (debug_mark+2),a  
3e28 18 03			jr .pastdmark  
3e2a ..			.dmark: db "SPA"  
3e2d f1			.pastdmark: pop af  
3e2e			endm  
# End of macro DMARK
3e2e						CALLMONITOR 
3e2e cd 65 16			call break_point_state  
3e31				endm  
# End of macro CALLMONITOR
3e31					endif 
3e31			 
3e31					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e31 cd a1 1e			call macro_forth_dsp_pop 
3e34				endm 
# End of macro FORTH_DSP_POP
3e34			;		pop hl 
3e34 4d					ld c, l 
3e35 06 00				ld b, 0 
3e37 21 a3 ef				ld hl, scratch  
3e3a			 
3e3a					if DEBUG_FORTH_WORDS 
3e3a						DMARK "SP2" 
3e3a f5				push af  
3e3b 3a 4f 3e			ld a, (.dmark)  
3e3e 32 bd fb			ld (debug_mark),a  
3e41 3a 50 3e			ld a, (.dmark+1)  
3e44 32 be fb			ld (debug_mark+1),a  
3e47 3a 51 3e			ld a, (.dmark+2)  
3e4a 32 bf fb			ld (debug_mark+2),a  
3e4d 18 03			jr .pastdmark  
3e4f ..			.dmark: db "SP2"  
3e52 f1			.pastdmark: pop af  
3e53			endm  
# End of macro DMARK
3e53						CALLMONITOR 
3e53 cd 65 16			call break_point_state  
3e56				endm  
# End of macro CALLMONITOR
3e56					endif 
3e56 3e 20				ld a, ' ' 
3e58 c5			.spaces1:	push bc 
3e59 77					ld (hl),a 
3e5a 23					inc hl 
3e5b c1					pop bc 
3e5c 10 fa				djnz .spaces1 
3e5e 3e 00				ld a,0 
3e60 77					ld (hl),a 
3e61 21 a3 ef				ld hl, scratch 
3e64					if DEBUG_FORTH_WORDS 
3e64						DMARK "SP3" 
3e64 f5				push af  
3e65 3a 79 3e			ld a, (.dmark)  
3e68 32 bd fb			ld (debug_mark),a  
3e6b 3a 7a 3e			ld a, (.dmark+1)  
3e6e 32 be fb			ld (debug_mark+1),a  
3e71 3a 7b 3e			ld a, (.dmark+2)  
3e74 32 bf fb			ld (debug_mark+2),a  
3e77 18 03			jr .pastdmark  
3e79 ..			.dmark: db "SP3"  
3e7c f1			.pastdmark: pop af  
3e7d			endm  
# End of macro DMARK
3e7d						CALLMONITOR 
3e7d cd 65 16			call break_point_state  
3e80				endm  
# End of macro CALLMONITOR
3e80					endif 
3e80 cd 5b 1d				call forth_apush 
3e83			 
3e83				       NEXTW 
3e83 c3 5b 1f			jp macro_next 
3e86				endm 
# End of macro NEXTW
3e86			 
3e86			 
3e86			 
3e86			.SCROLL: 
3e86				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3e86 53				db WORD_SYS_CORE+63             
3e87 b3 3e			dw .SCROLLD            
3e89 07				db 6 + 1 
3e8a .. 00			db "SCROLL",0              
3e91				endm 
# End of macro CWHEAD
3e91			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3e91					if DEBUG_FORTH_WORDS_KEY 
3e91						DMARK "SCR" 
3e91 f5				push af  
3e92 3a a6 3e			ld a, (.dmark)  
3e95 32 bd fb			ld (debug_mark),a  
3e98 3a a7 3e			ld a, (.dmark+1)  
3e9b 32 be fb			ld (debug_mark+1),a  
3e9e 3a a8 3e			ld a, (.dmark+2)  
3ea1 32 bf fb			ld (debug_mark+2),a  
3ea4 18 03			jr .pastdmark  
3ea6 ..			.dmark: db "SCR"  
3ea9 f1			.pastdmark: pop af  
3eaa			endm  
# End of macro DMARK
3eaa						CALLMONITOR 
3eaa cd 65 16			call break_point_state  
3ead				endm  
# End of macro CALLMONITOR
3ead					endif 
3ead			 
3ead cd 94 0a			call scroll_up 
3eb0			;	call update_display 
3eb0			 
3eb0					NEXTW 
3eb0 c3 5b 1f			jp macro_next 
3eb3				endm 
# End of macro NEXTW
3eb3			 
3eb3			 
3eb3			 
3eb3			;		; get dir 
3eb3			; 
3eb3			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3eb3			; 
3eb3			;		push hl 
3eb3			; 
3eb3			;		; destroy value TOS 
3eb3			; 
3eb3			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3eb3			; 
3eb3			;		; get count 
3eb3			; 
3eb3			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3eb3			; 
3eb3			;		push hl 
3eb3			; 
3eb3			;		; destroy value TOS 
3eb3			; 
3eb3			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3eb3			; 
3eb3			;		; one value on hl get other one back 
3eb3			; 
3eb3			;		pop bc    ; count 
3eb3			; 
3eb3			;		pop de   ; dir 
3eb3			; 
3eb3			; 
3eb3			;		ld b, c 
3eb3			; 
3eb3			;.scrolldir:     push bc 
3eb3			;		push de 
3eb3			; 
3eb3			;		ld a, 0 
3eb3			;		cp e 
3eb3			;		jr z, .scrollup  
3eb3			;		call scroll_down 
3eb3			;		jr .scrollnext 
3eb3			;.scrollup:	call scroll_up 
3eb3			; 
3eb3			;		 
3eb3			;.scrollnext: 
3eb3			;		pop de 
3eb3			;		pop bc 
3eb3			;		djnz .scrolldir 
3eb3			; 
3eb3			; 
3eb3			; 
3eb3			; 
3eb3			; 
3eb3			;		NEXTW 
3eb3			 
3eb3			.SCROLLD: 
3eb3				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3eb3 53				db WORD_SYS_CORE+63             
3eb4 e1 3e			dw .ATQ            
3eb6 08				db 7 + 1 
3eb7 .. 00			db "SCROLLD",0              
3ebf				endm 
# End of macro CWHEAD
3ebf			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3ebf					if DEBUG_FORTH_WORDS_KEY 
3ebf						DMARK "SCD" 
3ebf f5				push af  
3ec0 3a d4 3e			ld a, (.dmark)  
3ec3 32 bd fb			ld (debug_mark),a  
3ec6 3a d5 3e			ld a, (.dmark+1)  
3ec9 32 be fb			ld (debug_mark+1),a  
3ecc 3a d6 3e			ld a, (.dmark+2)  
3ecf 32 bf fb			ld (debug_mark+2),a  
3ed2 18 03			jr .pastdmark  
3ed4 ..			.dmark: db "SCD"  
3ed7 f1			.pastdmark: pop af  
3ed8			endm  
# End of macro DMARK
3ed8						CALLMONITOR 
3ed8 cd 65 16			call break_point_state  
3edb				endm  
# End of macro CALLMONITOR
3edb					endif 
3edb			 
3edb cd b8 0a			call scroll_down 
3ede			;	call update_display 
3ede			 
3ede					NEXTW 
3ede c3 5b 1f			jp macro_next 
3ee1				endm 
# End of macro NEXTW
3ee1			 
3ee1			 
3ee1			.ATQ: 
3ee1				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3ee1 62				db WORD_SYS_CORE+78             
3ee2 3f 3f			dw .AUTODSP            
3ee4 04				db 3 + 1 
3ee5 .. 00			db "AT@",0              
3ee9				endm 
# End of macro CWHEAD
3ee9			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3ee9					if DEBUG_FORTH_WORDS_KEY 
3ee9						DMARK "ATA" 
3ee9 f5				push af  
3eea 3a fe 3e			ld a, (.dmark)  
3eed 32 bd fb			ld (debug_mark),a  
3ef0 3a ff 3e			ld a, (.dmark+1)  
3ef3 32 be fb			ld (debug_mark+1),a  
3ef6 3a 00 3f			ld a, (.dmark+2)  
3ef9 32 bf fb			ld (debug_mark+2),a  
3efc 18 03			jr .pastdmark  
3efe ..			.dmark: db "ATA"  
3f01 f1			.pastdmark: pop af  
3f02			endm  
# End of macro DMARK
3f02						CALLMONITOR 
3f02 cd 65 16			call break_point_state  
3f05				endm  
# End of macro CALLMONITOR
3f05					endif 
3f05			 
3f05			 
3f05					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f05 cd e9 1d			call macro_dsp_valuehl 
3f08				endm 
# End of macro FORTH_DSP_VALUEHL
3f08			 
3f08					; TODO save cursor row 
3f08 7d					ld a,l 
3f09 fe 02				cp 2 
3f0b 20 04				jr nz, .crow3aq 
3f0d 3e 14				ld a, display_row_2 
3f0f 18 12				jr .ccol1aq 
3f11 fe 03		.crow3aq:		cp 3 
3f13 20 04				jr nz, .crow4aq 
3f15 3e 28				ld a, display_row_3 
3f17 18 0a				jr .ccol1aq 
3f19 fe 04		.crow4aq:		cp 4 
3f1b 20 04				jr nz, .crow1aq 
3f1d 3e 3c				ld a, display_row_4 
3f1f 18 02				jr .ccol1aq 
3f21 3e 00		.crow1aq:		ld a,display_row_1 
3f23 f5			.ccol1aq:		push af			; got row offset 
3f24 6f					ld l,a 
3f25 26 00				ld h,0 
3f27					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f27 cd a1 1e			call macro_forth_dsp_pop 
3f2a				endm 
# End of macro FORTH_DSP_POP
3f2a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f2a cd e9 1d			call macro_dsp_valuehl 
3f2d				endm 
# End of macro FORTH_DSP_VALUEHL
3f2d					; TODO save cursor col 
3f2d f1					pop af 
3f2e 85					add l		; add col offset 
3f2f			 
3f2f					; add current frame buffer address 
3f2f 2a 5e fa				ld hl, (display_fb_active) 
3f32 cd 06 0d				call addatohl 
3f35			 
3f35			 
3f35			 
3f35			 
3f35					; get char frame buffer location offset in hl 
3f35			 
3f35 7e					ld a,(hl) 
3f36 26 00				ld h, 0 
3f38 6f					ld l, a 
3f39			 
3f39 cd f2 1b				call forth_push_numhl 
3f3c			 
3f3c			 
3f3c					NEXTW 
3f3c c3 5b 1f			jp macro_next 
3f3f				endm 
# End of macro NEXTW
3f3f			 
3f3f			.AUTODSP: 
3f3f				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3f3f 63				db WORD_SYS_CORE+79             
3f40 55 3f			dw .MENU            
3f42 05				db 4 + 1 
3f43 .. 00			db "ADSP",0              
3f48				endm 
# End of macro CWHEAD
3f48			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3f48			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3f48			 
3f48					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f48 cd e9 1d			call macro_dsp_valuehl 
3f4b				endm 
# End of macro FORTH_DSP_VALUEHL
3f4b			 
3f4b			;		push hl 
3f4b			 
3f4b					; destroy value TOS 
3f4b			 
3f4b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f4b cd a1 1e			call macro_forth_dsp_pop 
3f4e				endm 
# End of macro FORTH_DSP_POP
3f4e			 
3f4e			;		pop hl 
3f4e			 
3f4e 7d					ld a,l 
3f4f 32 aa f9				ld (cli_autodisplay), a 
3f52				       NEXTW 
3f52 c3 5b 1f			jp macro_next 
3f55				endm 
# End of macro NEXTW
3f55			 
3f55			.MENU: 
3f55				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3f55 70				db WORD_SYS_CORE+92             
3f56 fe 3f			dw .ENDDISPLAY            
3f58 05				db 4 + 1 
3f59 .. 00			db "MENU",0              
3f5e				endm 
# End of macro CWHEAD
3f5e			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3f5e			 
3f5e			;		; get number of items on the stack 
3f5e			; 
3f5e				 
3f5e					FORTH_DSP_VALUEHL 
3f5e cd e9 1d			call macro_dsp_valuehl 
3f61				endm 
# End of macro FORTH_DSP_VALUEHL
3f61				 
3f61					if DEBUG_FORTH_WORDS_KEY 
3f61						DMARK "MNU" 
3f61 f5				push af  
3f62 3a 76 3f			ld a, (.dmark)  
3f65 32 bd fb			ld (debug_mark),a  
3f68 3a 77 3f			ld a, (.dmark+1)  
3f6b 32 be fb			ld (debug_mark+1),a  
3f6e 3a 78 3f			ld a, (.dmark+2)  
3f71 32 bf fb			ld (debug_mark+2),a  
3f74 18 03			jr .pastdmark  
3f76 ..			.dmark: db "MNU"  
3f79 f1			.pastdmark: pop af  
3f7a			endm  
# End of macro DMARK
3f7a						CALLMONITOR 
3f7a cd 65 16			call break_point_state  
3f7d				endm  
# End of macro CALLMONITOR
3f7d					endif 
3f7d			 
3f7d 45					ld b, l	 
3f7e 05					dec b 
3f7f			 
3f7f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f7f cd a1 1e			call macro_forth_dsp_pop 
3f82				endm 
# End of macro FORTH_DSP_POP
3f82			 
3f82			 
3f82					; go directly through the stack to pluck out the string pointers and build an array 
3f82			 
3f82			;		FORTH_DSP 
3f82			 
3f82					; hl contains top most stack item 
3f82				 
3f82 11 a3 ef				ld de, scratch 
3f85			 
3f85			.mbuild: 
3f85			 
3f85					FORTH_DSP_VALUEHL 
3f85 cd e9 1d			call macro_dsp_valuehl 
3f88				endm 
# End of macro FORTH_DSP_VALUEHL
3f88			 
3f88					if DEBUG_FORTH_WORDS 
3f88						DMARK "MN3" 
3f88 f5				push af  
3f89 3a 9d 3f			ld a, (.dmark)  
3f8c 32 bd fb			ld (debug_mark),a  
3f8f 3a 9e 3f			ld a, (.dmark+1)  
3f92 32 be fb			ld (debug_mark+1),a  
3f95 3a 9f 3f			ld a, (.dmark+2)  
3f98 32 bf fb			ld (debug_mark+2),a  
3f9b 18 03			jr .pastdmark  
3f9d ..			.dmark: db "MN3"  
3fa0 f1			.pastdmark: pop af  
3fa1			endm  
# End of macro DMARK
3fa1						CALLMONITOR 
3fa1 cd 65 16			call break_point_state  
3fa4				endm  
# End of macro CALLMONITOR
3fa4					endif 
3fa4 eb					ex de, hl 
3fa5 73					ld (hl), e 
3fa6 23					inc hl 
3fa7 72					ld (hl), d 
3fa8 23					inc hl 
3fa9 eb					ex de, hl 
3faa			 
3faa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3faa cd a1 1e			call macro_forth_dsp_pop 
3fad				endm 
# End of macro FORTH_DSP_POP
3fad			 
3fad 10 d6				djnz .mbuild 
3faf			 
3faf					; done add term 
3faf			 
3faf eb					ex de, hl 
3fb0 36 00				ld (hl), 0 
3fb2 23					inc hl 
3fb3 36 00				ld (hl), 0 
3fb5			 
3fb5				 
3fb5					 
3fb5 21 a3 ef				ld hl, scratch 
3fb8			 
3fb8					if DEBUG_FORTH_WORDS 
3fb8						DMARK "MNx" 
3fb8 f5				push af  
3fb9 3a cd 3f			ld a, (.dmark)  
3fbc 32 bd fb			ld (debug_mark),a  
3fbf 3a ce 3f			ld a, (.dmark+1)  
3fc2 32 be fb			ld (debug_mark+1),a  
3fc5 3a cf 3f			ld a, (.dmark+2)  
3fc8 32 bf fb			ld (debug_mark+2),a  
3fcb 18 03			jr .pastdmark  
3fcd ..			.dmark: db "MNx"  
3fd0 f1			.pastdmark: pop af  
3fd1			endm  
# End of macro DMARK
3fd1						CALLMONITOR 
3fd1 cd 65 16			call break_point_state  
3fd4				endm  
# End of macro CALLMONITOR
3fd4					endif 
3fd4			 
3fd4			 
3fd4			 
3fd4 3e 00				ld a, 0 
3fd6 cd 03 0b				call menu 
3fd9			 
3fd9			 
3fd9 6f					ld l, a 
3fda 26 00				ld h, 0 
3fdc			 
3fdc					if DEBUG_FORTH_WORDS 
3fdc						DMARK "MNr" 
3fdc f5				push af  
3fdd 3a f1 3f			ld a, (.dmark)  
3fe0 32 bd fb			ld (debug_mark),a  
3fe3 3a f2 3f			ld a, (.dmark+1)  
3fe6 32 be fb			ld (debug_mark+1),a  
3fe9 3a f3 3f			ld a, (.dmark+2)  
3fec 32 bf fb			ld (debug_mark+2),a  
3fef 18 03			jr .pastdmark  
3ff1 ..			.dmark: db "MNr"  
3ff4 f1			.pastdmark: pop af  
3ff5			endm  
# End of macro DMARK
3ff5						CALLMONITOR 
3ff5 cd 65 16			call break_point_state  
3ff8				endm  
# End of macro CALLMONITOR
3ff8					endif 
3ff8			 
3ff8 cd f2 1b				call forth_push_numhl 
3ffb			 
3ffb			 
3ffb			 
3ffb			 
3ffb				       NEXTW 
3ffb c3 5b 1f			jp macro_next 
3ffe				endm 
# End of macro NEXTW
3ffe			 
3ffe			 
3ffe			.ENDDISPLAY: 
3ffe			 
3ffe			; eof 
# End of file forth_words_display.asm
3ffe			include "forth_words_str.asm" 
3ffe			 
3ffe			; | ## String Words 
3ffe			 
3ffe			.PTR:   
3ffe			 
3ffe				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3ffe 48				db WORD_SYS_CORE+52             
3fff 2b 40			dw .STYPE            
4001 04				db 3 + 1 
4002 .. 00			db "PTR",0              
4006				endm 
# End of macro CWHEAD
4006			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4006			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4006			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4006			 
4006					if DEBUG_FORTH_WORDS_KEY 
4006						DMARK "PTR" 
4006 f5				push af  
4007 3a 1b 40			ld a, (.dmark)  
400a 32 bd fb			ld (debug_mark),a  
400d 3a 1c 40			ld a, (.dmark+1)  
4010 32 be fb			ld (debug_mark+1),a  
4013 3a 1d 40			ld a, (.dmark+2)  
4016 32 bf fb			ld (debug_mark+2),a  
4019 18 03			jr .pastdmark  
401b ..			.dmark: db "PTR"  
401e f1			.pastdmark: pop af  
401f			endm  
# End of macro DMARK
401f						CALLMONITOR 
401f cd 65 16			call break_point_state  
4022				endm  
# End of macro CALLMONITOR
4022					endif 
4022					FORTH_DSP_VALUEHL 
4022 cd e9 1d			call macro_dsp_valuehl 
4025				endm 
# End of macro FORTH_DSP_VALUEHL
4025 cd f2 1b				call forth_push_numhl 
4028			 
4028			 
4028					NEXTW 
4028 c3 5b 1f			jp macro_next 
402b				endm 
# End of macro NEXTW
402b			.STYPE: 
402b				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
402b 48				db WORD_SYS_CORE+52             
402c 7a 40			dw .UPPER            
402e 06				db 5 + 1 
402f .. 00			db "STYPE",0              
4035				endm 
# End of macro CWHEAD
4035			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4035					if DEBUG_FORTH_WORDS_KEY 
4035						DMARK "STY" 
4035 f5				push af  
4036 3a 4a 40			ld a, (.dmark)  
4039 32 bd fb			ld (debug_mark),a  
403c 3a 4b 40			ld a, (.dmark+1)  
403f 32 be fb			ld (debug_mark+1),a  
4042 3a 4c 40			ld a, (.dmark+2)  
4045 32 bf fb			ld (debug_mark+2),a  
4048 18 03			jr .pastdmark  
404a ..			.dmark: db "STY"  
404d f1			.pastdmark: pop af  
404e			endm  
# End of macro DMARK
404e						CALLMONITOR 
404e cd 65 16			call break_point_state  
4051				endm  
# End of macro CALLMONITOR
4051					endif 
4051					FORTH_DSP 
4051 cd af 1d			call macro_forth_dsp 
4054				endm 
# End of macro FORTH_DSP
4054					;v5 FORTH_DSP_VALUE 
4054			 
4054 7e					ld a, (hl) 
4055			 
4055 f5					push af 
4056			 
4056			; Dont destroy TOS		FORTH_DSP_POP 
4056			 
4056 f1					pop af 
4057			 
4057 fe 01				cp DS_TYPE_STR 
4059 28 09				jr z, .typestr 
405b			 
405b fe 02				cp DS_TYPE_INUM 
405d 28 0a				jr z, .typeinum 
405f			 
405f 21 78 40				ld hl, .tna 
4062 18 0a				jr .tpush 
4064			 
4064 21 74 40		.typestr:	ld hl, .tstr 
4067 18 05				jr .tpush 
4069 21 76 40		.typeinum:	ld hl, .tinum 
406c 18 00				jr .tpush 
406e			 
406e			.tpush: 
406e			 
406e cd 60 1c				call forth_push_str 
4071			 
4071					NEXTW 
4071 c3 5b 1f			jp macro_next 
4074				endm 
# End of macro NEXTW
4074 .. 00		.tstr:	db "s",0 
4076 .. 00		.tinum:  db "i",0 
4078 .. 00		.tna:   db "?", 0 
407a			 
407a			 
407a			.UPPER: 
407a				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
407a 48				db WORD_SYS_CORE+52             
407b b5 40			dw .LOWER            
407d 06				db 5 + 1 
407e .. 00			db "UPPER",0              
4084				endm 
# End of macro CWHEAD
4084			; | UPPER ( s -- s ) Upper case string s  | DONE 
4084					if DEBUG_FORTH_WORDS_KEY 
4084						DMARK "UPR" 
4084 f5				push af  
4085 3a 99 40			ld a, (.dmark)  
4088 32 bd fb			ld (debug_mark),a  
408b 3a 9a 40			ld a, (.dmark+1)  
408e 32 be fb			ld (debug_mark+1),a  
4091 3a 9b 40			ld a, (.dmark+2)  
4094 32 bf fb			ld (debug_mark+2),a  
4097 18 03			jr .pastdmark  
4099 ..			.dmark: db "UPR"  
409c f1			.pastdmark: pop af  
409d			endm  
# End of macro DMARK
409d						CALLMONITOR 
409d cd 65 16			call break_point_state  
40a0				endm  
# End of macro CALLMONITOR
40a0					endif 
40a0			 
40a0					FORTH_DSP 
40a0 cd af 1d			call macro_forth_dsp 
40a3				endm 
# End of macro FORTH_DSP
40a3					 
40a3			; TODO check is string type 
40a3			 
40a3					FORTH_DSP_VALUEHL 
40a3 cd e9 1d			call macro_dsp_valuehl 
40a6				endm 
# End of macro FORTH_DSP_VALUEHL
40a6			; get pointer to string in hl 
40a6			 
40a6 7e			.toup:		ld a, (hl) 
40a7 fe 00				cp 0 
40a9 28 07				jr z, .toupdone 
40ab			 
40ab cd 73 10				call to_upper 
40ae			 
40ae 77					ld (hl), a 
40af 23					inc hl 
40b0 18 f4				jr .toup 
40b2			 
40b2					 
40b2			 
40b2			 
40b2			; for each char convert to upper 
40b2					 
40b2			.toupdone: 
40b2			 
40b2			 
40b2					NEXTW 
40b2 c3 5b 1f			jp macro_next 
40b5				endm 
# End of macro NEXTW
40b5			.LOWER: 
40b5				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
40b5 48				db WORD_SYS_CORE+52             
40b6 f0 40			dw .TCASE            
40b8 06				db 5 + 1 
40b9 .. 00			db "LOWER",0              
40bf				endm 
# End of macro CWHEAD
40bf			; | LOWER ( s -- s ) Lower case string s  | DONE 
40bf					if DEBUG_FORTH_WORDS_KEY 
40bf						DMARK "LWR" 
40bf f5				push af  
40c0 3a d4 40			ld a, (.dmark)  
40c3 32 bd fb			ld (debug_mark),a  
40c6 3a d5 40			ld a, (.dmark+1)  
40c9 32 be fb			ld (debug_mark+1),a  
40cc 3a d6 40			ld a, (.dmark+2)  
40cf 32 bf fb			ld (debug_mark+2),a  
40d2 18 03			jr .pastdmark  
40d4 ..			.dmark: db "LWR"  
40d7 f1			.pastdmark: pop af  
40d8			endm  
# End of macro DMARK
40d8						CALLMONITOR 
40d8 cd 65 16			call break_point_state  
40db				endm  
# End of macro CALLMONITOR
40db					endif 
40db			 
40db					FORTH_DSP 
40db cd af 1d			call macro_forth_dsp 
40de				endm 
# End of macro FORTH_DSP
40de					 
40de			; TODO check is string type 
40de			 
40de					FORTH_DSP_VALUEHL 
40de cd e9 1d			call macro_dsp_valuehl 
40e1				endm 
# End of macro FORTH_DSP_VALUEHL
40e1			; get pointer to string in hl 
40e1			 
40e1 7e			.tolow:		ld a, (hl) 
40e2 fe 00				cp 0 
40e4 28 07				jr z, .tolowdone 
40e6			 
40e6 cd 7c 10				call to_lower 
40e9			 
40e9 77					ld (hl), a 
40ea 23					inc hl 
40eb 18 f4				jr .tolow 
40ed			 
40ed					 
40ed			 
40ed			 
40ed			; for each char convert to low 
40ed					 
40ed			.tolowdone: 
40ed					NEXTW 
40ed c3 5b 1f			jp macro_next 
40f0				endm 
# End of macro NEXTW
40f0			.TCASE: 
40f0				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
40f0 48				db WORD_SYS_CORE+52             
40f1 26 42			dw .SUBSTR            
40f3 06				db 5 + 1 
40f4 .. 00			db "TCASE",0              
40fa				endm 
# End of macro CWHEAD
40fa			; | TCASE ( s -- s ) Title case string s  | DONE 
40fa					if DEBUG_FORTH_WORDS_KEY 
40fa						DMARK "TCS" 
40fa f5				push af  
40fb 3a 0f 41			ld a, (.dmark)  
40fe 32 bd fb			ld (debug_mark),a  
4101 3a 10 41			ld a, (.dmark+1)  
4104 32 be fb			ld (debug_mark+1),a  
4107 3a 11 41			ld a, (.dmark+2)  
410a 32 bf fb			ld (debug_mark+2),a  
410d 18 03			jr .pastdmark  
410f ..			.dmark: db "TCS"  
4112 f1			.pastdmark: pop af  
4113			endm  
# End of macro DMARK
4113						CALLMONITOR 
4113 cd 65 16			call break_point_state  
4116				endm  
# End of macro CALLMONITOR
4116					endif 
4116			 
4116					FORTH_DSP 
4116 cd af 1d			call macro_forth_dsp 
4119				endm 
# End of macro FORTH_DSP
4119					 
4119			; TODO check is string type 
4119			 
4119					FORTH_DSP_VALUEHL 
4119 cd e9 1d			call macro_dsp_valuehl 
411c				endm 
# End of macro FORTH_DSP_VALUEHL
411c			; get pointer to string in hl 
411c			 
411c					if DEBUG_FORTH_WORDS 
411c						DMARK "TC1" 
411c f5				push af  
411d 3a 31 41			ld a, (.dmark)  
4120 32 bd fb			ld (debug_mark),a  
4123 3a 32 41			ld a, (.dmark+1)  
4126 32 be fb			ld (debug_mark+1),a  
4129 3a 33 41			ld a, (.dmark+2)  
412c 32 bf fb			ld (debug_mark+2),a  
412f 18 03			jr .pastdmark  
4131 ..			.dmark: db "TC1"  
4134 f1			.pastdmark: pop af  
4135			endm  
# End of macro DMARK
4135						CALLMONITOR 
4135 cd 65 16			call break_point_state  
4138				endm  
# End of macro CALLMONITOR
4138					endif 
4138			 
4138					; first time in turn to upper case first char 
4138			 
4138 7e					ld a, (hl) 
4139 c3 c3 41				jp .totsiptou 
413c			 
413c			 
413c 7e			.tot:		ld a, (hl) 
413d fe 00				cp 0 
413f ca 07 42				jp z, .totdone 
4142			 
4142					if DEBUG_FORTH_WORDS 
4142						DMARK "TC2" 
4142 f5				push af  
4143 3a 57 41			ld a, (.dmark)  
4146 32 bd fb			ld (debug_mark),a  
4149 3a 58 41			ld a, (.dmark+1)  
414c 32 be fb			ld (debug_mark+1),a  
414f 3a 59 41			ld a, (.dmark+2)  
4152 32 bf fb			ld (debug_mark+2),a  
4155 18 03			jr .pastdmark  
4157 ..			.dmark: db "TC2"  
415a f1			.pastdmark: pop af  
415b			endm  
# End of macro DMARK
415b						CALLMONITOR 
415b cd 65 16			call break_point_state  
415e				endm  
# End of macro CALLMONITOR
415e					endif 
415e					; check to see if current char is a space 
415e			 
415e fe 20				cp ' ' 
4160 28 21				jr z, .totsp 
4162 cd 7c 10				call to_lower 
4165					if DEBUG_FORTH_WORDS 
4165						DMARK "TC3" 
4165 f5				push af  
4166 3a 7a 41			ld a, (.dmark)  
4169 32 bd fb			ld (debug_mark),a  
416c 3a 7b 41			ld a, (.dmark+1)  
416f 32 be fb			ld (debug_mark+1),a  
4172 3a 7c 41			ld a, (.dmark+2)  
4175 32 bf fb			ld (debug_mark+2),a  
4178 18 03			jr .pastdmark  
417a ..			.dmark: db "TC3"  
417d f1			.pastdmark: pop af  
417e			endm  
# End of macro DMARK
417e						CALLMONITOR 
417e cd 65 16			call break_point_state  
4181				endm  
# End of macro CALLMONITOR
4181					endif 
4181 18 63				jr .totnxt 
4183			 
4183			.totsp:         ; on a space, find next char which should be upper 
4183			 
4183					if DEBUG_FORTH_WORDS 
4183						DMARK "TC4" 
4183 f5				push af  
4184 3a 98 41			ld a, (.dmark)  
4187 32 bd fb			ld (debug_mark),a  
418a 3a 99 41			ld a, (.dmark+1)  
418d 32 be fb			ld (debug_mark+1),a  
4190 3a 9a 41			ld a, (.dmark+2)  
4193 32 bf fb			ld (debug_mark+2),a  
4196 18 03			jr .pastdmark  
4198 ..			.dmark: db "TC4"  
419b f1			.pastdmark: pop af  
419c			endm  
# End of macro DMARK
419c						CALLMONITOR 
419c cd 65 16			call break_point_state  
419f				endm  
# End of macro CALLMONITOR
419f					endif 
419f					;; 
419f			 
419f fe 20				cp ' ' 
41a1 20 20				jr nz, .totsiptou 
41a3 23					inc hl 
41a4 7e					ld a, (hl) 
41a5					if DEBUG_FORTH_WORDS 
41a5						DMARK "TC5" 
41a5 f5				push af  
41a6 3a ba 41			ld a, (.dmark)  
41a9 32 bd fb			ld (debug_mark),a  
41ac 3a bb 41			ld a, (.dmark+1)  
41af 32 be fb			ld (debug_mark+1),a  
41b2 3a bc 41			ld a, (.dmark+2)  
41b5 32 bf fb			ld (debug_mark+2),a  
41b8 18 03			jr .pastdmark  
41ba ..			.dmark: db "TC5"  
41bd f1			.pastdmark: pop af  
41be			endm  
# End of macro DMARK
41be						CALLMONITOR 
41be cd 65 16			call break_point_state  
41c1				endm  
# End of macro CALLMONITOR
41c1					endif 
41c1 18 c0				jr .totsp 
41c3 fe 00		.totsiptou:    cp 0 
41c5 28 40				jr z, .totdone 
41c7					; not space and not zero term so upper case it 
41c7 cd 73 10				call to_upper 
41ca			 
41ca					if DEBUG_FORTH_WORDS 
41ca						DMARK "TC6" 
41ca f5				push af  
41cb 3a df 41			ld a, (.dmark)  
41ce 32 bd fb			ld (debug_mark),a  
41d1 3a e0 41			ld a, (.dmark+1)  
41d4 32 be fb			ld (debug_mark+1),a  
41d7 3a e1 41			ld a, (.dmark+2)  
41da 32 bf fb			ld (debug_mark+2),a  
41dd 18 03			jr .pastdmark  
41df ..			.dmark: db "TC6"  
41e2 f1			.pastdmark: pop af  
41e3			endm  
# End of macro DMARK
41e3						CALLMONITOR 
41e3 cd 65 16			call break_point_state  
41e6				endm  
# End of macro CALLMONITOR
41e6					endif 
41e6			 
41e6			 
41e6			.totnxt: 
41e6			 
41e6 77					ld (hl), a 
41e7 23					inc hl 
41e8					if DEBUG_FORTH_WORDS 
41e8						DMARK "TC7" 
41e8 f5				push af  
41e9 3a fd 41			ld a, (.dmark)  
41ec 32 bd fb			ld (debug_mark),a  
41ef 3a fe 41			ld a, (.dmark+1)  
41f2 32 be fb			ld (debug_mark+1),a  
41f5 3a ff 41			ld a, (.dmark+2)  
41f8 32 bf fb			ld (debug_mark+2),a  
41fb 18 03			jr .pastdmark  
41fd ..			.dmark: db "TC7"  
4200 f1			.pastdmark: pop af  
4201			endm  
# End of macro DMARK
4201						CALLMONITOR 
4201 cd 65 16			call break_point_state  
4204				endm  
# End of macro CALLMONITOR
4204					endif 
4204 c3 3c 41				jp .tot 
4207			 
4207					 
4207			 
4207			 
4207			; for each char convert to low 
4207					 
4207			.totdone: 
4207					if DEBUG_FORTH_WORDS 
4207						DMARK "TCd" 
4207 f5				push af  
4208 3a 1c 42			ld a, (.dmark)  
420b 32 bd fb			ld (debug_mark),a  
420e 3a 1d 42			ld a, (.dmark+1)  
4211 32 be fb			ld (debug_mark+1),a  
4214 3a 1e 42			ld a, (.dmark+2)  
4217 32 bf fb			ld (debug_mark+2),a  
421a 18 03			jr .pastdmark  
421c ..			.dmark: db "TCd"  
421f f1			.pastdmark: pop af  
4220			endm  
# End of macro DMARK
4220						CALLMONITOR 
4220 cd 65 16			call break_point_state  
4223				endm  
# End of macro CALLMONITOR
4223					endif 
4223					NEXTW 
4223 c3 5b 1f			jp macro_next 
4226				endm 
# End of macro NEXTW
4226			 
4226			.SUBSTR: 
4226				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4226 48				db WORD_SYS_CORE+52             
4227 84 42			dw .LEFT            
4229 07				db 6 + 1 
422a .. 00			db "SUBSTR",0              
4231				endm 
# End of macro CWHEAD
4231			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4231			 
4231					if DEBUG_FORTH_WORDS_KEY 
4231						DMARK "SST" 
4231 f5				push af  
4232 3a 46 42			ld a, (.dmark)  
4235 32 bd fb			ld (debug_mark),a  
4238 3a 47 42			ld a, (.dmark+1)  
423b 32 be fb			ld (debug_mark+1),a  
423e 3a 48 42			ld a, (.dmark+2)  
4241 32 bf fb			ld (debug_mark+2),a  
4244 18 03			jr .pastdmark  
4246 ..			.dmark: db "SST"  
4249 f1			.pastdmark: pop af  
424a			endm  
# End of macro DMARK
424a						CALLMONITOR 
424a cd 65 16			call break_point_state  
424d				endm  
# End of macro CALLMONITOR
424d					endif 
424d			; TODO check string type 
424d					FORTH_DSP_VALUEHL 
424d cd e9 1d			call macro_dsp_valuehl 
4250				endm 
# End of macro FORTH_DSP_VALUEHL
4250			 
4250 e5					push hl      ; string length 
4251			 
4251					FORTH_DSP_POP 
4251 cd a1 1e			call macro_forth_dsp_pop 
4254				endm 
# End of macro FORTH_DSP_POP
4254			 
4254					FORTH_DSP_VALUEHL 
4254 cd e9 1d			call macro_dsp_valuehl 
4257				endm 
# End of macro FORTH_DSP_VALUEHL
4257			 
4257 e5					push hl     ; start char 
4258			 
4258					FORTH_DSP_POP 
4258 cd a1 1e			call macro_forth_dsp_pop 
425b				endm 
# End of macro FORTH_DSP_POP
425b			 
425b			 
425b					FORTH_DSP_VALUE 
425b cd d2 1d			call macro_forth_dsp_value 
425e				endm 
# End of macro FORTH_DSP_VALUE
425e			 
425e d1					pop de    ; get start post offset 
425f			 
425f 19					add hl, de    ; starting offset 
4260			 
4260 c1					pop bc 
4261 c5					push bc      ; grab size of string 
4262			 
4262 e5					push hl    ; save string start  
4263			 
4263 26 00				ld h, 0 
4265 69					ld l, c 
4266 23					inc hl 
4267 23					inc hl 
4268			 
4268 cd cd 11				call malloc 
426b				if DEBUG_FORTH_MALLOC_GUARD 
426b cc ee 51				call z,malloc_error 
426e				endif 
426e			 
426e eb					ex de, hl      ; save malloc area for string copy 
426f e1					pop hl    ; get back source 
4270 c1					pop bc    ; get length of string back 
4271			 
4271 d5					push de    ; save malloc area for after we push 
4272 ed b0				ldir     ; copy substr 
4274			 
4274			 
4274 eb					ex de, hl 
4275 3e 00				ld a, 0 
4277 77					ld (hl), a   ; term substr 
4278			 
4278					 
4278 e1					pop hl    ; get malloc so we can push it 
4279 e5					push hl   ; save so we can free it afterwards 
427a			 
427a cd 60 1c				call forth_push_str 
427d			 
427d e1					pop hl 
427e cd 97 12				call free 
4281			 
4281					 
4281					 
4281			 
4281			 
4281					NEXTW 
4281 c3 5b 1f			jp macro_next 
4284				endm 
# End of macro NEXTW
4284			 
4284			.LEFT: 
4284				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4284 48				db WORD_SYS_CORE+52             
4285 ac 42			dw .RIGHT            
4287 05				db 4 + 1 
4288 .. 00			db "LEFT",0              
428d				endm 
# End of macro CWHEAD
428d			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
428d					if DEBUG_FORTH_WORDS_KEY 
428d						DMARK "LEF" 
428d f5				push af  
428e 3a a2 42			ld a, (.dmark)  
4291 32 bd fb			ld (debug_mark),a  
4294 3a a3 42			ld a, (.dmark+1)  
4297 32 be fb			ld (debug_mark+1),a  
429a 3a a4 42			ld a, (.dmark+2)  
429d 32 bf fb			ld (debug_mark+2),a  
42a0 18 03			jr .pastdmark  
42a2 ..			.dmark: db "LEF"  
42a5 f1			.pastdmark: pop af  
42a6			endm  
# End of macro DMARK
42a6						CALLMONITOR 
42a6 cd 65 16			call break_point_state  
42a9				endm  
# End of macro CALLMONITOR
42a9					endif 
42a9			 
42a9					NEXTW 
42a9 c3 5b 1f			jp macro_next 
42ac				endm 
# End of macro NEXTW
42ac			.RIGHT: 
42ac				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
42ac 48				db WORD_SYS_CORE+52             
42ad d5 42			dw .STR2NUM            
42af 06				db 5 + 1 
42b0 .. 00			db "RIGHT",0              
42b6				endm 
# End of macro CWHEAD
42b6			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
42b6					if DEBUG_FORTH_WORDS_KEY 
42b6						DMARK "RIG" 
42b6 f5				push af  
42b7 3a cb 42			ld a, (.dmark)  
42ba 32 bd fb			ld (debug_mark),a  
42bd 3a cc 42			ld a, (.dmark+1)  
42c0 32 be fb			ld (debug_mark+1),a  
42c3 3a cd 42			ld a, (.dmark+2)  
42c6 32 bf fb			ld (debug_mark+2),a  
42c9 18 03			jr .pastdmark  
42cb ..			.dmark: db "RIG"  
42ce f1			.pastdmark: pop af  
42cf			endm  
# End of macro DMARK
42cf						CALLMONITOR 
42cf cd 65 16			call break_point_state  
42d2				endm  
# End of macro CALLMONITOR
42d2					endif 
42d2			 
42d2					NEXTW 
42d2 c3 5b 1f			jp macro_next 
42d5				endm 
# End of macro NEXTW
42d5			 
42d5			 
42d5			.STR2NUM: 
42d5				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
42d5 48				db WORD_SYS_CORE+52             
42d6 61 43			dw .NUM2STR            
42d8 08				db 7 + 1 
42d9 .. 00			db "STR2NUM",0              
42e1				endm 
# End of macro CWHEAD
42e1			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
42e1			 
42e1			 
42e1			; TODO STR type check to do 
42e1					if DEBUG_FORTH_WORDS_KEY 
42e1						DMARK "S2N" 
42e1 f5				push af  
42e2 3a f6 42			ld a, (.dmark)  
42e5 32 bd fb			ld (debug_mark),a  
42e8 3a f7 42			ld a, (.dmark+1)  
42eb 32 be fb			ld (debug_mark+1),a  
42ee 3a f8 42			ld a, (.dmark+2)  
42f1 32 bf fb			ld (debug_mark+2),a  
42f4 18 03			jr .pastdmark  
42f6 ..			.dmark: db "S2N"  
42f9 f1			.pastdmark: pop af  
42fa			endm  
# End of macro DMARK
42fa						CALLMONITOR 
42fa cd 65 16			call break_point_state  
42fd				endm  
# End of macro CALLMONITOR
42fd					endif 
42fd			 
42fd					;FORTH_DSP 
42fd					FORTH_DSP_VALUE 
42fd cd d2 1d			call macro_forth_dsp_value 
4300				endm 
# End of macro FORTH_DSP_VALUE
4300					;inc hl 
4300			 
4300 eb					ex de, hl 
4301					if DEBUG_FORTH_WORDS 
4301						DMARK "S2a" 
4301 f5				push af  
4302 3a 16 43			ld a, (.dmark)  
4305 32 bd fb			ld (debug_mark),a  
4308 3a 17 43			ld a, (.dmark+1)  
430b 32 be fb			ld (debug_mark+1),a  
430e 3a 18 43			ld a, (.dmark+2)  
4311 32 bf fb			ld (debug_mark+2),a  
4314 18 03			jr .pastdmark  
4316 ..			.dmark: db "S2a"  
4319 f1			.pastdmark: pop af  
431a			endm  
# End of macro DMARK
431a						CALLMONITOR 
431a cd 65 16			call break_point_state  
431d				endm  
# End of macro CALLMONITOR
431d					endif 
431d cd fb 10				call string_to_uint16 
4320			 
4320					if DEBUG_FORTH_WORDS 
4320						DMARK "S2b" 
4320 f5				push af  
4321 3a 35 43			ld a, (.dmark)  
4324 32 bd fb			ld (debug_mark),a  
4327 3a 36 43			ld a, (.dmark+1)  
432a 32 be fb			ld (debug_mark+1),a  
432d 3a 37 43			ld a, (.dmark+2)  
4330 32 bf fb			ld (debug_mark+2),a  
4333 18 03			jr .pastdmark  
4335 ..			.dmark: db "S2b"  
4338 f1			.pastdmark: pop af  
4339			endm  
# End of macro DMARK
4339						CALLMONITOR 
4339 cd 65 16			call break_point_state  
433c				endm  
# End of macro CALLMONITOR
433c					endif 
433c			;		push hl 
433c					FORTH_DSP_POP 
433c cd a1 1e			call macro_forth_dsp_pop 
433f				endm 
# End of macro FORTH_DSP_POP
433f			;		pop hl 
433f					 
433f					if DEBUG_FORTH_WORDS 
433f						DMARK "S2b" 
433f f5				push af  
4340 3a 54 43			ld a, (.dmark)  
4343 32 bd fb			ld (debug_mark),a  
4346 3a 55 43			ld a, (.dmark+1)  
4349 32 be fb			ld (debug_mark+1),a  
434c 3a 56 43			ld a, (.dmark+2)  
434f 32 bf fb			ld (debug_mark+2),a  
4352 18 03			jr .pastdmark  
4354 ..			.dmark: db "S2b"  
4357 f1			.pastdmark: pop af  
4358			endm  
# End of macro DMARK
4358						CALLMONITOR 
4358 cd 65 16			call break_point_state  
435b				endm  
# End of macro CALLMONITOR
435b					endif 
435b cd f2 1b				call forth_push_numhl	 
435e			 
435e				 
435e				       NEXTW 
435e c3 5b 1f			jp macro_next 
4361				endm 
# End of macro NEXTW
4361			.NUM2STR: 
4361				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4361 48				db WORD_SYS_CORE+52             
4362 70 43			dw .CONCAT            
4364 08				db 7 + 1 
4365 .. 00			db "NUM2STR",0              
436d				endm 
# End of macro CWHEAD
436d			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
436d			 
436d			;		; malloc a string to target 
436d			;		ld hl, 10     ; TODO max string size should be fine 
436d			;		call malloc 
436d			;		push hl    ; save malloc location 
436d			; 
436d			; 
436d			;; TODO check int type 
436d			;		FORTH_DSP_VALUEHL 
436d			;		ld a, l 
436d			;		call DispAToASCII   
436d			;;TODO need to chage above call to dump into string 
436d			; 
436d			; 
436d			 
436d				       NEXTW 
436d c3 5b 1f			jp macro_next 
4370				endm 
# End of macro NEXTW
4370			 
4370			.CONCAT: 
4370				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4370 48				db WORD_SYS_CORE+52             
4371 23 44			dw .FIND            
4373 07				db 6 + 1 
4374 .. 00			db "CONCAT",0              
437b				endm 
# End of macro CWHEAD
437b			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
437b			 
437b			; TODO check string type 
437b			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
437b			 
437b					if DEBUG_FORTH_WORDS_KEY 
437b						DMARK "CON" 
437b f5				push af  
437c 3a 90 43			ld a, (.dmark)  
437f 32 bd fb			ld (debug_mark),a  
4382 3a 91 43			ld a, (.dmark+1)  
4385 32 be fb			ld (debug_mark+1),a  
4388 3a 92 43			ld a, (.dmark+2)  
438b 32 bf fb			ld (debug_mark+2),a  
438e 18 03			jr .pastdmark  
4390 ..			.dmark: db "CON"  
4393 f1			.pastdmark: pop af  
4394			endm  
# End of macro DMARK
4394						CALLMONITOR 
4394 cd 65 16			call break_point_state  
4397				endm  
# End of macro CALLMONITOR
4397					endif 
4397			 
4397			 
4397					FORTH_DSP_VALUE 
4397 cd d2 1d			call macro_forth_dsp_value 
439a				endm 
# End of macro FORTH_DSP_VALUE
439a e5					push hl   ; s2 
439b			 
439b					FORTH_DSP_POP 
439b cd a1 1e			call macro_forth_dsp_pop 
439e				endm 
# End of macro FORTH_DSP_POP
439e			 
439e					FORTH_DSP_VALUE 
439e cd d2 1d			call macro_forth_dsp_value 
43a1				endm 
# End of macro FORTH_DSP_VALUE
43a1			 
43a1 e5					push hl   ; s1 
43a2			 
43a2					FORTH_DSP_POP 
43a2 cd a1 1e			call macro_forth_dsp_pop 
43a5				endm 
# End of macro FORTH_DSP_POP
43a5					 
43a5			 
43a5					; copy s1 
43a5			 
43a5				 
43a5					; save ptr 
43a5 e1					pop hl  
43a6 e5					push hl 
43a7 3e 00				ld a, 0 
43a9 cd 6f 11				call strlent 
43ac					;inc hl    ; zer0 
43ac 06 00				ld b, 0 
43ae 4d					ld c, l 
43af e1					pop hl		 
43b0 11 a3 ef				ld de, scratch	 
43b3					if DEBUG_FORTH_WORDS 
43b3						DMARK "CO1" 
43b3 f5				push af  
43b4 3a c8 43			ld a, (.dmark)  
43b7 32 bd fb			ld (debug_mark),a  
43ba 3a c9 43			ld a, (.dmark+1)  
43bd 32 be fb			ld (debug_mark+1),a  
43c0 3a ca 43			ld a, (.dmark+2)  
43c3 32 bf fb			ld (debug_mark+2),a  
43c6 18 03			jr .pastdmark  
43c8 ..			.dmark: db "CO1"  
43cb f1			.pastdmark: pop af  
43cc			endm  
# End of macro DMARK
43cc						CALLMONITOR 
43cc cd 65 16			call break_point_state  
43cf				endm  
# End of macro CALLMONITOR
43cf					endif 
43cf ed b0				ldir 
43d1			 
43d1 e1					pop hl 
43d2 e5					push hl 
43d3 d5					push de 
43d4			 
43d4			 
43d4 3e 00				ld a, 0 
43d6 cd 6f 11				call strlent 
43d9 23					inc hl    ; zer0 
43da 23					inc hl 
43db 06 00				ld b, 0 
43dd 4d					ld c, l 
43de d1					pop de 
43df e1					pop hl		 
43e0					if DEBUG_FORTH_WORDS 
43e0						DMARK "CO2" 
43e0 f5				push af  
43e1 3a f5 43			ld a, (.dmark)  
43e4 32 bd fb			ld (debug_mark),a  
43e7 3a f6 43			ld a, (.dmark+1)  
43ea 32 be fb			ld (debug_mark+1),a  
43ed 3a f7 43			ld a, (.dmark+2)  
43f0 32 bf fb			ld (debug_mark+2),a  
43f3 18 03			jr .pastdmark  
43f5 ..			.dmark: db "CO2"  
43f8 f1			.pastdmark: pop af  
43f9			endm  
# End of macro DMARK
43f9						CALLMONITOR 
43f9 cd 65 16			call break_point_state  
43fc				endm  
# End of macro CALLMONITOR
43fc					endif 
43fc ed b0				ldir 
43fe			 
43fe			 
43fe			 
43fe 21 a3 ef				ld hl, scratch 
4401					if DEBUG_FORTH_WORDS 
4401						DMARK "CO5" 
4401 f5				push af  
4402 3a 16 44			ld a, (.dmark)  
4405 32 bd fb			ld (debug_mark),a  
4408 3a 17 44			ld a, (.dmark+1)  
440b 32 be fb			ld (debug_mark+1),a  
440e 3a 18 44			ld a, (.dmark+2)  
4411 32 bf fb			ld (debug_mark+2),a  
4414 18 03			jr .pastdmark  
4416 ..			.dmark: db "CO5"  
4419 f1			.pastdmark: pop af  
441a			endm  
# End of macro DMARK
441a						CALLMONITOR 
441a cd 65 16			call break_point_state  
441d				endm  
# End of macro CALLMONITOR
441d					endif 
441d			 
441d cd 60 1c				call forth_push_str 
4420			 
4420			 
4420			 
4420			 
4420				       NEXTW 
4420 c3 5b 1f			jp macro_next 
4423				endm 
# End of macro NEXTW
4423			 
4423			 
4423			.FIND: 
4423				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4423 4b				db WORD_SYS_CORE+55             
4424 e1 44			dw .LEN            
4426 05				db 4 + 1 
4427 .. 00			db "FIND",0              
442c				endm 
# End of macro CWHEAD
442c			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
442c			 
442c					if DEBUG_FORTH_WORDS_KEY 
442c						DMARK "FND" 
442c f5				push af  
442d 3a 41 44			ld a, (.dmark)  
4430 32 bd fb			ld (debug_mark),a  
4433 3a 42 44			ld a, (.dmark+1)  
4436 32 be fb			ld (debug_mark+1),a  
4439 3a 43 44			ld a, (.dmark+2)  
443c 32 bf fb			ld (debug_mark+2),a  
443f 18 03			jr .pastdmark  
4441 ..			.dmark: db "FND"  
4444 f1			.pastdmark: pop af  
4445			endm  
# End of macro DMARK
4445						CALLMONITOR 
4445 cd 65 16			call break_point_state  
4448				endm  
# End of macro CALLMONITOR
4448					endif 
4448			 
4448			; TODO check string type 
4448					FORTH_DSP_VALUE 
4448 cd d2 1d			call macro_forth_dsp_value 
444b				endm 
# End of macro FORTH_DSP_VALUE
444b			 
444b e5					push hl    
444c 7e					ld a,(hl)    ; char to find   
444d			; TODO change char to substr 
444d			 
444d f5					push af 
444e					 
444e			 
444e			 
444e					if DEBUG_FORTH_WORDS 
444e						DMARK "FN1" 
444e f5				push af  
444f 3a 63 44			ld a, (.dmark)  
4452 32 bd fb			ld (debug_mark),a  
4455 3a 64 44			ld a, (.dmark+1)  
4458 32 be fb			ld (debug_mark+1),a  
445b 3a 65 44			ld a, (.dmark+2)  
445e 32 bf fb			ld (debug_mark+2),a  
4461 18 03			jr .pastdmark  
4463 ..			.dmark: db "FN1"  
4466 f1			.pastdmark: pop af  
4467			endm  
# End of macro DMARK
4467						CALLMONITOR 
4467 cd 65 16			call break_point_state  
446a				endm  
# End of macro CALLMONITOR
446a					endif 
446a			 
446a					FORTH_DSP_POP 
446a cd a1 1e			call macro_forth_dsp_pop 
446d				endm 
# End of macro FORTH_DSP_POP
446d			 
446d					; string to search 
446d			 
446d					FORTH_DSP_VALUE 
446d cd d2 1d			call macro_forth_dsp_value 
4470				endm 
# End of macro FORTH_DSP_VALUE
4470			 
4470 d1					pop de  ; d is char to find  
4471			 
4471					if DEBUG_FORTH_WORDS 
4471						DMARK "FN2" 
4471 f5				push af  
4472 3a 86 44			ld a, (.dmark)  
4475 32 bd fb			ld (debug_mark),a  
4478 3a 87 44			ld a, (.dmark+1)  
447b 32 be fb			ld (debug_mark+1),a  
447e 3a 88 44			ld a, (.dmark+2)  
4481 32 bf fb			ld (debug_mark+2),a  
4484 18 03			jr .pastdmark  
4486 ..			.dmark: db "FN2"  
4489 f1			.pastdmark: pop af  
448a			endm  
# End of macro DMARK
448a						CALLMONITOR 
448a cd 65 16			call break_point_state  
448d				endm  
# End of macro CALLMONITOR
448d					endif 
448d					 
448d 01 00 00				ld bc, 0 
4490 7e			.findchar:      ld a,(hl) 
4491 fe 00				cp 0   		 
4493 28 27				jr z, .finddone     
4495 ba					cp d 
4496 28 20				jr z, .foundchar 
4498 03					inc bc 
4499 23					inc hl 
449a					if DEBUG_FORTH_WORDS 
449a						DMARK "FN3" 
449a f5				push af  
449b 3a af 44			ld a, (.dmark)  
449e 32 bd fb			ld (debug_mark),a  
44a1 3a b0 44			ld a, (.dmark+1)  
44a4 32 be fb			ld (debug_mark+1),a  
44a7 3a b1 44			ld a, (.dmark+2)  
44aa 32 bf fb			ld (debug_mark+2),a  
44ad 18 03			jr .pastdmark  
44af ..			.dmark: db "FN3"  
44b2 f1			.pastdmark: pop af  
44b3			endm  
# End of macro DMARK
44b3						CALLMONITOR 
44b3 cd 65 16			call break_point_state  
44b6				endm  
# End of macro CALLMONITOR
44b6					endif 
44b6 18 d8				jr .findchar 
44b8			 
44b8			 
44b8 c5			.foundchar:	push bc 
44b9 e1					pop hl 
44ba 18 03				jr .findexit 
44bc			 
44bc			 
44bc							 
44bc			 
44bc			.finddone:     ; got to end of string with no find 
44bc 21 00 00				ld hl, 0 
44bf			.findexit: 
44bf			 
44bf					if DEBUG_FORTH_WORDS 
44bf						DMARK "FNd" 
44bf f5				push af  
44c0 3a d4 44			ld a, (.dmark)  
44c3 32 bd fb			ld (debug_mark),a  
44c6 3a d5 44			ld a, (.dmark+1)  
44c9 32 be fb			ld (debug_mark+1),a  
44cc 3a d6 44			ld a, (.dmark+2)  
44cf 32 bf fb			ld (debug_mark+2),a  
44d2 18 03			jr .pastdmark  
44d4 ..			.dmark: db "FNd"  
44d7 f1			.pastdmark: pop af  
44d8			endm  
# End of macro DMARK
44d8						CALLMONITOR 
44d8 cd 65 16			call break_point_state  
44db				endm  
# End of macro CALLMONITOR
44db					endif 
44db cd f2 1b			call forth_push_numhl 
44de			 
44de				       NEXTW 
44de c3 5b 1f			jp macro_next 
44e1				endm 
# End of macro NEXTW
44e1			 
44e1			.LEN: 
44e1				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
44e1 4c				db WORD_SYS_CORE+56             
44e2 16 45			dw .CHAR            
44e4 06				db 5 + 1 
44e5 .. 00			db "COUNT",0              
44eb				endm 
# End of macro CWHEAD
44eb			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
44eb			 
44eb					if DEBUG_FORTH_WORDS_KEY 
44eb						DMARK "CNT" 
44eb f5				push af  
44ec 3a 00 45			ld a, (.dmark)  
44ef 32 bd fb			ld (debug_mark),a  
44f2 3a 01 45			ld a, (.dmark+1)  
44f5 32 be fb			ld (debug_mark+1),a  
44f8 3a 02 45			ld a, (.dmark+2)  
44fb 32 bf fb			ld (debug_mark+2),a  
44fe 18 03			jr .pastdmark  
4500 ..			.dmark: db "CNT"  
4503 f1			.pastdmark: pop af  
4504			endm  
# End of macro DMARK
4504						CALLMONITOR 
4504 cd 65 16			call break_point_state  
4507				endm  
# End of macro CALLMONITOR
4507					endif 
4507			; TODO check string type 
4507					FORTH_DSP 
4507 cd af 1d			call macro_forth_dsp 
450a				endm 
# End of macro FORTH_DSP
450a					;v5FORTH_DSP_VALUE 
450a			 
450a 23					inc hl 
450b			 
450b 3e 00				ld a, 0 
450d cd 6f 11				call strlent 
4510			 
4510 cd f2 1b				call forth_push_numhl 
4513			 
4513			 
4513			 
4513				       NEXTW 
4513 c3 5b 1f			jp macro_next 
4516				endm 
# End of macro NEXTW
4516			.CHAR: 
4516				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
4516 4d				db WORD_SYS_CORE+57             
4517 4c 45			dw .ENDSTR            
4519 05				db 4 + 1 
451a .. 00			db "CHAR",0              
451f				endm 
# End of macro CWHEAD
451f			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
451f					if DEBUG_FORTH_WORDS_KEY 
451f						DMARK "CHR" 
451f f5				push af  
4520 3a 34 45			ld a, (.dmark)  
4523 32 bd fb			ld (debug_mark),a  
4526 3a 35 45			ld a, (.dmark+1)  
4529 32 be fb			ld (debug_mark+1),a  
452c 3a 36 45			ld a, (.dmark+2)  
452f 32 bf fb			ld (debug_mark+2),a  
4532 18 03			jr .pastdmark  
4534 ..			.dmark: db "CHR"  
4537 f1			.pastdmark: pop af  
4538			endm  
# End of macro DMARK
4538						CALLMONITOR 
4538 cd 65 16			call break_point_state  
453b				endm  
# End of macro CALLMONITOR
453b					endif 
453b					FORTH_DSP 
453b cd af 1d			call macro_forth_dsp 
453e				endm 
# End of macro FORTH_DSP
453e					;v5 FORTH_DSP_VALUE 
453e 23					inc hl      ; now at start of numeric as string 
453f			 
453f			;		push hl 
453f			 
453f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
453f cd a1 1e			call macro_forth_dsp_pop 
4542				endm 
# End of macro FORTH_DSP_POP
4542			 
4542			;		pop hl 
4542			 
4542					; push the content of a onto the stack as a value 
4542			 
4542 7e					ld a,(hl)   ; get char 
4543 26 00				ld h,0 
4545 6f					ld l,a 
4546 cd f2 1b				call forth_push_numhl 
4549			 
4549				       NEXTW 
4549 c3 5b 1f			jp macro_next 
454c				endm 
# End of macro NEXTW
454c			 
454c			 
454c			 
454c			 
454c			.ENDSTR: 
454c			; eof 
454c			 
# End of file forth_words_str.asm
454c			include "forth_words_key.asm" 
454c			 
454c			; | ## Keyboard Words 
454c			 
454c			.KEY: 
454c				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
454c 3e				db WORD_SYS_CORE+42             
454d 7c 45			dw .WAITK            
454f 04				db 3 + 1 
4550 .. 00			db "KEY",0              
4554				endm 
# End of macro CWHEAD
4554			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4554			 
4554					if DEBUG_FORTH_WORDS_KEY 
4554						DMARK "KEY" 
4554 f5				push af  
4555 3a 69 45			ld a, (.dmark)  
4558 32 bd fb			ld (debug_mark),a  
455b 3a 6a 45			ld a, (.dmark+1)  
455e 32 be fb			ld (debug_mark+1),a  
4561 3a 6b 45			ld a, (.dmark+2)  
4564 32 bf fb			ld (debug_mark+2),a  
4567 18 03			jr .pastdmark  
4569 ..			.dmark: db "KEY"  
456c f1			.pastdmark: pop af  
456d			endm  
# End of macro DMARK
456d						CALLMONITOR 
456d cd 65 16			call break_point_state  
4570				endm  
# End of macro CALLMONITOR
4570					endif 
4570			; TODO currently waits 
4570 cd 55 66				call cin 
4573					;call cin_wait 
4573 6f					ld l, a 
4574 26 00				ld h, 0 
4576 cd f2 1b				call forth_push_numhl 
4579					NEXTW 
4579 c3 5b 1f			jp macro_next 
457c				endm 
# End of macro NEXTW
457c			.WAITK: 
457c				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
457c 3f				db WORD_SYS_CORE+43             
457d ae 45			dw .ACCEPT            
457f 06				db 5 + 1 
4580 .. 00			db "WAITK",0              
4586				endm 
# End of macro CWHEAD
4586			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4586					if DEBUG_FORTH_WORDS_KEY 
4586						DMARK "WAI" 
4586 f5				push af  
4587 3a 9b 45			ld a, (.dmark)  
458a 32 bd fb			ld (debug_mark),a  
458d 3a 9c 45			ld a, (.dmark+1)  
4590 32 be fb			ld (debug_mark+1),a  
4593 3a 9d 45			ld a, (.dmark+2)  
4596 32 bf fb			ld (debug_mark+2),a  
4599 18 03			jr .pastdmark  
459b ..			.dmark: db "WAI"  
459e f1			.pastdmark: pop af  
459f			endm  
# End of macro DMARK
459f						CALLMONITOR 
459f cd 65 16			call break_point_state  
45a2				endm  
# End of macro CALLMONITOR
45a2					endif 
45a2 cd 44 66				call cin_wait 
45a5 6f					ld l, a 
45a6 26 00				ld h, 0 
45a8 cd f2 1b				call forth_push_numhl 
45ab					NEXTW 
45ab c3 5b 1f			jp macro_next 
45ae				endm 
# End of macro NEXTW
45ae			.ACCEPT: 
45ae				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
45ae 40				db WORD_SYS_CORE+44             
45af 0c 46			dw .EDIT            
45b1 07				db 6 + 1 
45b2 .. 00			db "ACCEPT",0              
45b9				endm 
# End of macro CWHEAD
45b9			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
45b9					; TODO crashes on push 
45b9					if DEBUG_FORTH_WORDS_KEY 
45b9						DMARK "ACC" 
45b9 f5				push af  
45ba 3a ce 45			ld a, (.dmark)  
45bd 32 bd fb			ld (debug_mark),a  
45c0 3a cf 45			ld a, (.dmark+1)  
45c3 32 be fb			ld (debug_mark+1),a  
45c6 3a d0 45			ld a, (.dmark+2)  
45c9 32 bf fb			ld (debug_mark+2),a  
45cc 18 03			jr .pastdmark  
45ce ..			.dmark: db "ACC"  
45d1 f1			.pastdmark: pop af  
45d2			endm  
# End of macro DMARK
45d2						CALLMONITOR 
45d2 cd 65 16			call break_point_state  
45d5				endm  
# End of macro CALLMONITOR
45d5					endif 
45d5 21 a1 f1				ld hl, os_input 
45d8 3e 00				ld a, 0 
45da 77					ld (hl),a 
45db 3a cc f9				ld a,(f_cursor_ptr) 
45de 16 64				ld d, 100 
45e0 0e 00				ld c, 0 
45e2 1e 28				ld e, 40 
45e4 cd 33 0d				call input_str 
45e7					; TODO perhaps do a type check and wrap in quotes if not a number 
45e7 21 a1 f1				ld hl, os_input 
45ea					if DEBUG_FORTH_WORDS 
45ea						DMARK "AC1" 
45ea f5				push af  
45eb 3a ff 45			ld a, (.dmark)  
45ee 32 bd fb			ld (debug_mark),a  
45f1 3a 00 46			ld a, (.dmark+1)  
45f4 32 be fb			ld (debug_mark+1),a  
45f7 3a 01 46			ld a, (.dmark+2)  
45fa 32 bf fb			ld (debug_mark+2),a  
45fd 18 03			jr .pastdmark  
45ff ..			.dmark: db "AC1"  
4602 f1			.pastdmark: pop af  
4603			endm  
# End of macro DMARK
4603						CALLMONITOR 
4603 cd 65 16			call break_point_state  
4606				endm  
# End of macro CALLMONITOR
4606					endif 
4606 cd 60 1c				call forth_push_str 
4609					NEXTW 
4609 c3 5b 1f			jp macro_next 
460c				endm 
# End of macro NEXTW
460c			 
460c			.EDIT: 
460c				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
460c 40				db WORD_SYS_CORE+44             
460d 95 46			dw .ENDKEY            
460f 05				db 4 + 1 
4610 .. 00			db "EDIT",0              
4615				endm 
# End of macro CWHEAD
4615			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4615			 
4615					; TODO does not copy from stack 
4615					if DEBUG_FORTH_WORDS_KEY 
4615						DMARK "EDT" 
4615 f5				push af  
4616 3a 2a 46			ld a, (.dmark)  
4619 32 bd fb			ld (debug_mark),a  
461c 3a 2b 46			ld a, (.dmark+1)  
461f 32 be fb			ld (debug_mark+1),a  
4622 3a 2c 46			ld a, (.dmark+2)  
4625 32 bf fb			ld (debug_mark+2),a  
4628 18 03			jr .pastdmark  
462a ..			.dmark: db "EDT"  
462d f1			.pastdmark: pop af  
462e			endm  
# End of macro DMARK
462e						CALLMONITOR 
462e cd 65 16			call break_point_state  
4631				endm  
# End of macro CALLMONITOR
4631					endif 
4631			 
4631					FORTH_DSP 
4631 cd af 1d			call macro_forth_dsp 
4634				endm 
# End of macro FORTH_DSP
4634					;v5 FORTH_DSP_VALUE 
4634 23					inc hl    ; TODO do type check 
4635			 
4635 e5					push hl 
4636 3e 00				ld a, 0 
4638 cd 6f 11				call strlent 
463b 23					inc hl 
463c			 
463c 06 00				ld b, 0 
463e 4d					ld c, l 
463f			 
463f e1					pop hl 
4640 11 a1 f1				ld de, os_input 
4643					if DEBUG_FORTH_WORDS_KEY 
4643						DMARK "EDc" 
4643 f5				push af  
4644 3a 58 46			ld a, (.dmark)  
4647 32 bd fb			ld (debug_mark),a  
464a 3a 59 46			ld a, (.dmark+1)  
464d 32 be fb			ld (debug_mark+1),a  
4650 3a 5a 46			ld a, (.dmark+2)  
4653 32 bf fb			ld (debug_mark+2),a  
4656 18 03			jr .pastdmark  
4658 ..			.dmark: db "EDc"  
465b f1			.pastdmark: pop af  
465c			endm  
# End of macro DMARK
465c						CALLMONITOR 
465c cd 65 16			call break_point_state  
465f				endm  
# End of macro CALLMONITOR
465f					endif 
465f ed b0				ldir 
4661			 
4661			 
4661 21 a1 f1				ld hl, os_input 
4664					;ld a, 0 
4664					;ld (hl),a 
4664 3a cc f9				ld a,(f_cursor_ptr) 
4667 16 64				ld d, 100 
4669 0e 00				ld c, 0 
466b 1e 28				ld e, 40 
466d cd 33 0d				call input_str 
4670					; TODO perhaps do a type check and wrap in quotes if not a number 
4670 21 a1 f1				ld hl, os_input 
4673					if DEBUG_FORTH_WORDS 
4673						DMARK "ED1" 
4673 f5				push af  
4674 3a 88 46			ld a, (.dmark)  
4677 32 bd fb			ld (debug_mark),a  
467a 3a 89 46			ld a, (.dmark+1)  
467d 32 be fb			ld (debug_mark+1),a  
4680 3a 8a 46			ld a, (.dmark+2)  
4683 32 bf fb			ld (debug_mark+2),a  
4686 18 03			jr .pastdmark  
4688 ..			.dmark: db "ED1"  
468b f1			.pastdmark: pop af  
468c			endm  
# End of macro DMARK
468c						CALLMONITOR 
468c cd 65 16			call break_point_state  
468f				endm  
# End of macro CALLMONITOR
468f					endif 
468f cd 60 1c				call forth_push_str 
4692					NEXTW 
4692 c3 5b 1f			jp macro_next 
4695				endm 
# End of macro NEXTW
4695			 
4695			 
4695			 
4695			.ENDKEY: 
4695			; eof 
4695			 
# End of file forth_words_key.asm
4695			 
4695			if STORAGE_SE 
4695			   	include "forth_words_storage.asm" 
4695			 
4695			; | ## Fixed Storage Words 
4695			 
4695			 
4695			.BREAD: 
4695			  
4695				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4695 3a				db WORD_SYS_CORE+38             
4696 0e 47			dw .BWRITE            
4698 06				db 5 + 1 
4699 .. 00			db "BREAD",0              
469f				endm 
# End of macro CWHEAD
469f			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
469f				 
469f					if DEBUG_FORTH_WORDS_KEY 
469f						DMARK "BRD" 
469f f5				push af  
46a0 3a b4 46			ld a, (.dmark)  
46a3 32 bd fb			ld (debug_mark),a  
46a6 3a b5 46			ld a, (.dmark+1)  
46a9 32 be fb			ld (debug_mark+1),a  
46ac 3a b6 46			ld a, (.dmark+2)  
46af 32 bf fb			ld (debug_mark+2),a  
46b2 18 03			jr .pastdmark  
46b4 ..			.dmark: db "BRD"  
46b7 f1			.pastdmark: pop af  
46b8			endm  
# End of macro DMARK
46b8						CALLMONITOR 
46b8 cd 65 16			call break_point_state  
46bb				endm  
# End of macro CALLMONITOR
46bb					endif 
46bb			 
46bb				FORTH_DSP_VALUEHL 
46bb cd e9 1d			call macro_dsp_valuehl 
46be				endm 
# End of macro FORTH_DSP_VALUEHL
46be			 
46be				FORTH_DSP_POP 
46be cd a1 1e			call macro_forth_dsp_pop 
46c1				endm 
# End of macro FORTH_DSP_POP
46c1			 
46c1				; calc block address 
46c1			 
46c1 eb				ex de, hl 
46c2 3e 40			ld a, STORE_BLOCK_PHY 
46c4 cd 89 0c			call Mult16 
46c7			 
46c7			 
46c7 11 e8 f9			ld de, store_page 
46ca			 
46ca					if DEBUG_FORTH_WORDS 
46ca						DMARK "BR1" 
46ca f5				push af  
46cb 3a df 46			ld a, (.dmark)  
46ce 32 bd fb			ld (debug_mark),a  
46d1 3a e0 46			ld a, (.dmark+1)  
46d4 32 be fb			ld (debug_mark+1),a  
46d7 3a e1 46			ld a, (.dmark+2)  
46da 32 bf fb			ld (debug_mark+2),a  
46dd 18 03			jr .pastdmark  
46df ..			.dmark: db "BR1"  
46e2 f1			.pastdmark: pop af  
46e3			endm  
# End of macro DMARK
46e3						CALLMONITOR 
46e3 cd 65 16			call break_point_state  
46e6				endm  
# End of macro CALLMONITOR
46e6					endif 
46e6			 
46e6 cd 09 03			call storage_read_block 
46e9			 
46e9 21 ea f9		        ld hl, store_page+2 
46ec					if DEBUG_FORTH_WORDS 
46ec						DMARK "BR2" 
46ec f5				push af  
46ed 3a 01 47			ld a, (.dmark)  
46f0 32 bd fb			ld (debug_mark),a  
46f3 3a 02 47			ld a, (.dmark+1)  
46f6 32 be fb			ld (debug_mark+1),a  
46f9 3a 03 47			ld a, (.dmark+2)  
46fc 32 bf fb			ld (debug_mark+2),a  
46ff 18 03			jr .pastdmark  
4701 ..			.dmark: db "BR2"  
4704 f1			.pastdmark: pop af  
4705			endm  
# End of macro DMARK
4705						CALLMONITOR 
4705 cd 65 16			call break_point_state  
4708				endm  
# End of macro CALLMONITOR
4708					endif 
4708 cd 60 1c			call forth_push_str 
470b			 
470b			 
470b					NEXTW 
470b c3 5b 1f			jp macro_next 
470e				endm 
# End of macro NEXTW
470e			.BWRITE: 
470e				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
470e 3a				db WORD_SYS_CORE+38             
470f a3 47			dw .BUPD            
4711 07				db 6 + 1 
4712 .. 00			db "BWRITE",0              
4719				endm 
# End of macro CWHEAD
4719			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
4719			 
4719					if DEBUG_FORTH_WORDS_KEY 
4719						DMARK "BWR" 
4719 f5				push af  
471a 3a 2e 47			ld a, (.dmark)  
471d 32 bd fb			ld (debug_mark),a  
4720 3a 2f 47			ld a, (.dmark+1)  
4723 32 be fb			ld (debug_mark+1),a  
4726 3a 30 47			ld a, (.dmark+2)  
4729 32 bf fb			ld (debug_mark+2),a  
472c 18 03			jr .pastdmark  
472e ..			.dmark: db "BWR"  
4731 f1			.pastdmark: pop af  
4732			endm  
# End of macro DMARK
4732						CALLMONITOR 
4732 cd 65 16			call break_point_state  
4735				endm  
# End of macro CALLMONITOR
4735					endif 
4735			 
4735				FORTH_DSP_VALUEHL 
4735 cd e9 1d			call macro_dsp_valuehl 
4738				endm 
# End of macro FORTH_DSP_VALUEHL
4738			 
4738				; calc block address 
4738			 
4738 eb				ex de, hl 
4739 3e 40			ld a, STORE_BLOCK_PHY 
473b cd 89 0c			call Mult16 
473e			 
473e e5				push hl         ; address 
473f			 
473f				FORTH_DSP_POP 
473f cd a1 1e			call macro_forth_dsp_pop 
4742				endm 
# End of macro FORTH_DSP_POP
4742			 
4742				FORTH_DSP_VALUEHL 
4742 cd e9 1d			call macro_dsp_valuehl 
4745				endm 
# End of macro FORTH_DSP_VALUEHL
4745			 
4745				FORTH_DSP_POP 
4745 cd a1 1e			call macro_forth_dsp_pop 
4748				endm 
# End of macro FORTH_DSP_POP
4748			 
4748 cd 15 0a			call storage_clear_page 
474b			 
474b				; copy string to store page 
474b			 
474b e5				push hl     ; save string address 
474c			 
474c 3e 00			ld a, 0 
474e cd 6f 11			call strlent 
4751			 
4751 23				inc hl 
4752			 
4752 4d				ld c, l 
4753 06 00			ld b, 0 
4755			 
4755 e1				pop hl 
4756 11 ea f9			ld de, store_page + 2 
4759					if DEBUG_FORTH_WORDS 
4759						DMARK "BW1" 
4759 f5				push af  
475a 3a 6e 47			ld a, (.dmark)  
475d 32 bd fb			ld (debug_mark),a  
4760 3a 6f 47			ld a, (.dmark+1)  
4763 32 be fb			ld (debug_mark+1),a  
4766 3a 70 47			ld a, (.dmark+2)  
4769 32 bf fb			ld (debug_mark+2),a  
476c 18 03			jr .pastdmark  
476e ..			.dmark: db "BW1"  
4771 f1			.pastdmark: pop af  
4772			endm  
# End of macro DMARK
4772						CALLMONITOR 
4772 cd 65 16			call break_point_state  
4775				endm  
# End of macro CALLMONITOR
4775					endif 
4775 ed b0			ldir 
4777			 
4777			 
4777				; poke the start of the block with flags to prevent high level file ops hitting the block 
4777			 
4777 21 ff ff			ld hl, $ffff 
477a			 
477a 22 e8 f9			ld (store_page), hl	 
477d				 
477d e1				pop hl    ; get address 
477e 11 e8 f9			ld de, store_page 
4781			 
4781					if DEBUG_FORTH_WORDS 
4781						DMARK "BW2" 
4781 f5				push af  
4782 3a 96 47			ld a, (.dmark)  
4785 32 bd fb			ld (debug_mark),a  
4788 3a 97 47			ld a, (.dmark+1)  
478b 32 be fb			ld (debug_mark+1),a  
478e 3a 98 47			ld a, (.dmark+2)  
4791 32 bf fb			ld (debug_mark+2),a  
4794 18 03			jr .pastdmark  
4796 ..			.dmark: db "BW2"  
4799 f1			.pastdmark: pop af  
479a			endm  
# End of macro DMARK
479a						CALLMONITOR 
479a cd 65 16			call break_point_state  
479d				endm  
# End of macro CALLMONITOR
479d					endif 
479d			 
479d cd 6e 03			call storage_write_block 
47a0			 
47a0					NEXTW 
47a0 c3 5b 1f			jp macro_next 
47a3				endm 
# End of macro NEXTW
47a3			 
47a3			.BUPD: 
47a3				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
47a3 3a				db WORD_SYS_CORE+38             
47a4 f9 47			dw .BYID            
47a6 05				db 4 + 1 
47a7 .. 00			db "BUPD",0              
47ac				endm 
# End of macro CWHEAD
47ac			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
47ac			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
47ac			; | | or completely different file system structure. 
47ac			 
47ac					if DEBUG_FORTH_WORDS_KEY 
47ac						DMARK "BUD" 
47ac f5				push af  
47ad 3a c1 47			ld a, (.dmark)  
47b0 32 bd fb			ld (debug_mark),a  
47b3 3a c2 47			ld a, (.dmark+1)  
47b6 32 be fb			ld (debug_mark+1),a  
47b9 3a c3 47			ld a, (.dmark+2)  
47bc 32 bf fb			ld (debug_mark+2),a  
47bf 18 03			jr .pastdmark  
47c1 ..			.dmark: db "BUD"  
47c4 f1			.pastdmark: pop af  
47c5			endm  
# End of macro DMARK
47c5						CALLMONITOR 
47c5 cd 65 16			call break_point_state  
47c8				endm  
# End of macro CALLMONITOR
47c8					endif 
47c8			 
47c8				FORTH_DSP_VALUEHL 
47c8 cd e9 1d			call macro_dsp_valuehl 
47cb				endm 
# End of macro FORTH_DSP_VALUEHL
47cb			 
47cb				; calc block address 
47cb			 
47cb eb				ex de, hl 
47cc 3e 40			ld a, STORE_BLOCK_PHY 
47ce cd 89 0c			call Mult16 
47d1			 
47d1				FORTH_DSP_POP 
47d1 cd a1 1e			call macro_forth_dsp_pop 
47d4				endm 
# End of macro FORTH_DSP_POP
47d4			 
47d4			 
47d4 11 e8 f9			ld de, store_page 
47d7			 
47d7					if DEBUG_FORTH_WORDS 
47d7						DMARK "BUe" 
47d7 f5				push af  
47d8 3a ec 47			ld a, (.dmark)  
47db 32 bd fb			ld (debug_mark),a  
47de 3a ed 47			ld a, (.dmark+1)  
47e1 32 be fb			ld (debug_mark+1),a  
47e4 3a ee 47			ld a, (.dmark+2)  
47e7 32 bf fb			ld (debug_mark+2),a  
47ea 18 03			jr .pastdmark  
47ec ..			.dmark: db "BUe"  
47ef f1			.pastdmark: pop af  
47f0			endm  
# End of macro DMARK
47f0						CALLMONITOR 
47f0 cd 65 16			call break_point_state  
47f3				endm  
# End of macro CALLMONITOR
47f3					endif 
47f3			 
47f3 cd 6e 03			call storage_write_block 
47f6			 
47f6					NEXTW 
47f6 c3 5b 1f			jp macro_next 
47f9				endm 
# End of macro NEXTW
47f9			 
47f9			.BYID: 
47f9			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
47f9			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
47f9			; 
47f9			;		 
47f9			;		if DEBUG_FORTH_WORDS_KEY 
47f9			;			DMARK "BYID" 
47f9			;			CALLMONITOR 
47f9			;		endif 
47f9			; 
47f9			;		; get direct address 
47f9			; 
47f9			;		FORTH_DSP_VALUEHL 
47f9			; 
47f9			;		FORTH_DSP_POP 
47f9			; 
47f9			;	; calc block address 
47f9			; 
47f9			;	ex de, hl 
47f9			;	ld a, STORE_BLOCK_PHY 
47f9			;	call Mult16 
47f9			;	;	do BREAD with number as param 
47f9			;	; push the file name	 
47f9			;	ld de, store_page 
47f9			;	call storage_read_block 
47f9			 ;       ld hl, store_page+2 
47f9			; 
47f9			; 
47f9			;		NEXTW 
47f9			;.BYNAME: 
47f9			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
47f9			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
47f9			;		NEXTW 
47f9			; 
47f9			.DIR: 
47f9				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
47f9 3a				db WORD_SYS_CORE+38             
47fa fd 48			dw .SAVE            
47fc 04				db 3 + 1 
47fd .. 00			db "DIR",0              
4801				endm 
# End of macro CWHEAD
4801			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4801			 
4801					if DEBUG_FORTH_WORDS_KEY 
4801						DMARK "DIR" 
4801 f5				push af  
4802 3a 16 48			ld a, (.dmark)  
4805 32 bd fb			ld (debug_mark),a  
4808 3a 17 48			ld a, (.dmark+1)  
480b 32 be fb			ld (debug_mark+1),a  
480e 3a 18 48			ld a, (.dmark+2)  
4811 32 bf fb			ld (debug_mark+2),a  
4814 18 03			jr .pastdmark  
4816 ..			.dmark: db "DIR"  
4819 f1			.pastdmark: pop af  
481a			endm  
# End of macro DMARK
481a						CALLMONITOR 
481a cd 65 16			call break_point_state  
481d				endm  
# End of macro CALLMONITOR
481d					endif 
481d cd ba 03			call storage_get_block_0 
4820			 
4820 21 e8 f9			ld hl, store_page     ; get current id count 
4823 46				ld b, (hl) 
4824 0e 00			ld c, 0    ; count of files   
4826					if DEBUG_FORTH_WORDS 
4826						DMARK "DI1" 
4826 f5				push af  
4827 3a 3b 48			ld a, (.dmark)  
482a 32 bd fb			ld (debug_mark),a  
482d 3a 3c 48			ld a, (.dmark+1)  
4830 32 be fb			ld (debug_mark+1),a  
4833 3a 3d 48			ld a, (.dmark+2)  
4836 32 bf fb			ld (debug_mark+2),a  
4839 18 03			jr .pastdmark  
483b ..			.dmark: db "DI1"  
483e f1			.pastdmark: pop af  
483f			endm  
# End of macro DMARK
483f						CALLMONITOR 
483f cd 65 16			call break_point_state  
4842				endm  
# End of macro CALLMONITOR
4842					endif 
4842			 
4842				; check for empty drive 
4842			 
4842 3e 00			ld a, 0 
4844 b8				cp b 
4845 ca b3 48			jp z, .dirdone 
4848			 
4848				; for each of the current ids do a search for them and if found push to stack 
4848			 
4848 c5			.diritem:	push bc 
4849 21 40 00				ld hl, STORE_BLOCK_PHY 
484c 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
484e 58					ld e,b 
484f			 
484f			;		if DEBUG_FORTH_WORDS 
484f			;			DMARK "DI2" 
484f			;			CALLMONITOR 
484f			;		endif 
484f			 
484f cd 2a 06				call storage_findnextid 
4852			 
4852			;		if DEBUG_FORTH_WORDS 
4852			;			DMARK "DI3" 
4852			;			CALLMONITOR 
4852			;		endif 
4852			 
4852					; if found hl will be non zero 
4852			 
4852 cd 2f 0d				call ishlzero 
4855			;		ld a, l 
4855			;		add h 
4855			; 
4855			;		cp 0 
4855 28 59				jr z, .dirnotfound 
4857			 
4857					; increase count 
4857			 
4857 c1					pop bc	 
4858 0c					inc c 
4859 c5					push bc 
485a					 
485a			 
485a					; get file header and push the file name 
485a			 
485a 11 e8 f9				ld de, store_page 
485d cd 09 03				call storage_read_block 
4860			 
4860					; push file id to stack 
4860				 
4860 3a e8 f9				ld a, (store_page) 
4863 26 00				ld h, 0 
4865 6f					ld l, a 
4866 cd f2 1b				call forth_push_numhl 
4869			 
4869					; push extent count to stack  
4869				 
4869 3a ea f9				ld a, (store_page+2) 
486c 26 00				ld h, 0 
486e 6f					ld l, a 
486f cd f2 1b				call forth_push_numhl 
4872			 
4872					; push file name 
4872			 
4872 21 eb f9				ld hl, store_page+3 
4875					if DEBUG_FORTH_WORDS 
4875						DMARK "DI5" 
4875 f5				push af  
4876 3a 8a 48			ld a, (.dmark)  
4879 32 bd fb			ld (debug_mark),a  
487c 3a 8b 48			ld a, (.dmark+1)  
487f 32 be fb			ld (debug_mark+1),a  
4882 3a 8c 48			ld a, (.dmark+2)  
4885 32 bf fb			ld (debug_mark+2),a  
4888 18 03			jr .pastdmark  
488a ..			.dmark: db "DI5"  
488d f1			.pastdmark: pop af  
488e			endm  
# End of macro DMARK
488e						CALLMONITOR 
488e cd 65 16			call break_point_state  
4891				endm  
# End of macro CALLMONITOR
4891					endif 
4891 cd 60 1c				call forth_push_str 
4894					if DEBUG_FORTH_WORDS 
4894						DMARK "DI6" 
4894 f5				push af  
4895 3a a9 48			ld a, (.dmark)  
4898 32 bd fb			ld (debug_mark),a  
489b 3a aa 48			ld a, (.dmark+1)  
489e 32 be fb			ld (debug_mark+1),a  
48a1 3a ab 48			ld a, (.dmark+2)  
48a4 32 bf fb			ld (debug_mark+2),a  
48a7 18 03			jr .pastdmark  
48a9 ..			.dmark: db "DI6"  
48ac f1			.pastdmark: pop af  
48ad			endm  
# End of macro DMARK
48ad						CALLMONITOR 
48ad cd 65 16			call break_point_state  
48b0				endm  
# End of macro CALLMONITOR
48b0					endif 
48b0			.dirnotfound: 
48b0 c1					pop bc     
48b1 10 95				djnz .diritem 
48b3				 
48b3			.dirdone:	 
48b3					if DEBUG_FORTH_WORDS 
48b3						DMARK "DI7" 
48b3 f5				push af  
48b4 3a c8 48			ld a, (.dmark)  
48b7 32 bd fb			ld (debug_mark),a  
48ba 3a c9 48			ld a, (.dmark+1)  
48bd 32 be fb			ld (debug_mark+1),a  
48c0 3a ca 48			ld a, (.dmark+2)  
48c3 32 bf fb			ld (debug_mark+2),a  
48c6 18 03			jr .pastdmark  
48c8 ..			.dmark: db "DI7"  
48cb f1			.pastdmark: pop af  
48cc			endm  
# End of macro DMARK
48cc						CALLMONITOR 
48cc cd 65 16			call break_point_state  
48cf				endm  
# End of macro CALLMONITOR
48cf					endif 
48cf			 
48cf					; push a count of the dir items found 
48cf			 
48cf 26 00				ld h, 0 
48d1 69					ld l, c 
48d2 cd f2 1b				call forth_push_numhl 
48d5			 
48d5					; push the bank label 
48d5			 
48d5 cd ba 03				call storage_get_block_0 
48d8			 
48d8				 
48d8 21 eb f9		 		ld hl, store_page+3 
48db			 
48db					if DEBUG_FORTH_WORDS 
48db						DMARK "DI8" 
48db f5				push af  
48dc 3a f0 48			ld a, (.dmark)  
48df 32 bd fb			ld (debug_mark),a  
48e2 3a f1 48			ld a, (.dmark+1)  
48e5 32 be fb			ld (debug_mark+1),a  
48e8 3a f2 48			ld a, (.dmark+2)  
48eb 32 bf fb			ld (debug_mark+2),a  
48ee 18 03			jr .pastdmark  
48f0 ..			.dmark: db "DI8"  
48f3 f1			.pastdmark: pop af  
48f4			endm  
# End of macro DMARK
48f4						CALLMONITOR 
48f4 cd 65 16			call break_point_state  
48f7				endm  
# End of macro CALLMONITOR
48f7					endif 
48f7 cd 60 1c				call forth_push_str 
48fa			 
48fa			 
48fa				 
48fa					NEXTW 
48fa c3 5b 1f			jp macro_next 
48fd				endm 
# End of macro NEXTW
48fd			.SAVE: 
48fd			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
48fd			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
48fd			;		NEXTW 
48fd			;.LOAD: 
48fd			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
48fd			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
48fd			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
48fd			;; > > The LOAD command can not be used in any user words or compound lines. 
48fd			; 
48fd			;		; store_openext use it. If zero it is EOF 
48fd			; 
48fd			;		; read block from current stream id 
48fd			;		; if the block does not contain zero term keep reading blocks until zero found 
48fd			;		; push the block to stack 
48fd			;		; save the block id to stream 
48fd			; 
48fd			; 
48fd			;		FORTH_DSP_VALUEHL 
48fd			; 
48fd			;;		push hl 
48fd			; 
48fd			;	if DEBUG_STORESE 
48fd			;		DMARK "LOA" 
48fd			;		CALLMONITOR 
48fd			;	endif 
48fd			;		FORTH_DSP_POP 
48fd			; 
48fd			;;		pop hl 
48fd			; 
48fd			;		ld h, l 
48fd			;		ld l, 0 
48fd			; 
48fd			;		push hl     ; stack holds current file id and extent to work with 
48fd			; 
48fd			; 
48fd			;		ld de, store_page      ; get block zero of file 
48fd			;	if DEBUG_STORESE 
48fd			;		DMARK "LO0" 
48fd			;		CALLMONITOR 
48fd			;	endif 
48fd			;		call storage_read 
48fd			; 
48fd			;		ld a, (store_page+2)    ; max extents for this file 
48fd			;		ld  (store_openmaxext),a   ; get our limit 
48fd			; 
48fd			;	if DEBUG_STORESE 
48fd			;		DMARK "LOE" 
48fd			;		CALLMONITOR 
48fd			;	endif 
48fd			; 
48fd			;; TODO dont know why max extents are not present 
48fd			;;		cp 0 
48fd			;;		jp z, .loadeof     ; dont read past eof 
48fd			; 
48fd			;;		ld a, 1   ; start from the head of the file 
48fd			; 
48fd			;.loadline:	pop hl 
48fd			;		inc hl 
48fd			;		ld  a, (store_openmaxext)   ; get our limit 
48fd			;	if DEBUG_STORESE 
48fd			;		DMARK "LOx" 
48fd			;		CALLMONITOR 
48fd			;	endif 
48fd			;		inc a 
48fd			;		cp l 
48fd			;		jp z, .loadeof 
48fd			;		push hl    ; save current extent 
48fd			; 
48fd			;		ld de, store_page 
48fd			; 
48fd			;	if DEBUG_STORESE 
48fd			;		DMARK "LO1" 
48fd			;		CALLMONITOR 
48fd			;	endif 
48fd			;		call storage_read 
48fd			; 
48fd			;	if DEBUG_STORESE 
48fd			;		DMARK "LO2" 
48fd			;		CALLMONITOR 
48fd			;	endif 
48fd			;	call ishlzero 
48fd			;	ld a, l 
48fd			;	add h 
48fd			;	cp 0 
48fd			;	jr z, .loadeof 
48fd			; 
48fd			;	; not eof so hl should point to data to exec 
48fd			; 
48fd			;	; will need to add the FORTH_END_BUFFER flag 
48fd			 ; 
48fd			;	ld hl, store_page+2 
48fd			;	ld bc, 255 
48fd			;	ld a, 0 
48fd			;	cpir 
48fd			;	if DEBUG_STORESE 
48fd			;		DMARK "LOt" 
48fd			;		CALLMONITOR 
48fd			;	endif 
48fd			;	dec hl 
48fd			;	ld a, ' ' 
48fd			;	ld (hl), a 
48fd			;	inc hl 
48fd			;	ld (hl), a 
48fd			;	inc hl 
48fd			;	ld (hl), a 
48fd			;	inc hl 
48fd			;	ld a, FORTH_END_BUFFER 
48fd			;	ld (hl), a 
48fd			; 
48fd			;	; TODO handle more than a single block read 
48fd			; 
48fd			; 
48fd			;	ld hl, store_page+2 
48fd			; 
48fd			;	ld (os_tok_ptr), hl 
48fd			; 
48fd			;	if DEBUG_STORESE 
48fd			;		DMARK "LO3" 
48fd			;		CALLMONITOR 
48fd			;	endif 
48fd			; 
48fd			;	call forthparse 
48fd			;	call forthexec 
48fd			;	call forthexec_cleanup 
48fd			; 
48fd			;	; go to next extent 
48fd			; 
48fd			;	; get next block  or mark as eof 
48fd			;	jp .loadline 
48fd			; 
48fd			; 
48fd			; 
48fd			;	       NEXTW 
48fd			;.loadeof:	ld a, 0 
48fd			;		ld (store_openext), a 
48fd			; 
48fd			;	if DEBUG_STORESE 
48fd			;		DMARK "LOF" 
48fd			;		CALLMONITOR 
48fd			;	endif 
48fd			;		ret 
48fd			;		;NEXTW 
48fd			;.BSAVE:   
48fd			; 
48fd			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
48fd			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
48fd			;		NEXTW 
48fd			;.BLOAD: 
48fd			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
48fd			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
48fd			;		NEXTW 
48fd			;;;; counter gap 
48fd			 
48fd			 
48fd			.SEO: 
48fd				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
48fd 64				db WORD_SYS_CORE+80             
48fe 1c 49			dw .SEI            
4900 04				db 3 + 1 
4901 .. 00			db "SEO",0              
4905				endm 
# End of macro CWHEAD
4905			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4905			 
4905					; get port 
4905			 
4905					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4905 cd e9 1d			call macro_dsp_valuehl 
4908				endm 
# End of macro FORTH_DSP_VALUEHL
4908			 
4908 e5					push hl    ; u2 - byte 
4909			 
4909					; destroy value TOS 
4909			 
4909					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4909 cd a1 1e			call macro_forth_dsp_pop 
490c				endm 
# End of macro FORTH_DSP_POP
490c			 
490c					; get byte to send 
490c			 
490c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
490c cd e9 1d			call macro_dsp_valuehl 
490f				endm 
# End of macro FORTH_DSP_VALUEHL
490f			 
490f e5					push hl    ; u1 - addr 
4910			 
4910					; destroy value TOS 
4910			 
4910					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4910 cd a1 1e			call macro_forth_dsp_pop 
4913				endm 
# End of macro FORTH_DSP_POP
4913			 
4913					; one value on hl get other one back 
4913			 
4913 d1					pop de   ; u1 - byte 
4914			 
4914 e1					pop hl   ; u2 - addr 
4915			 
4915					; TODO Send SPI byte 
4915			 
4915			 
4915 7b					ld a, e 
4916 cd e7 01				call se_writebyte 
4919			 
4919					 
4919			 
4919					NEXTW 
4919 c3 5b 1f			jp macro_next 
491c				endm 
# End of macro NEXTW
491c			 
491c			.SEI: 
491c				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
491c 65				db WORD_SYS_CORE+81             
491d 36 49			dw .SFREE            
491f 04				db 3 + 1 
4920 .. 00			db "SEI",0              
4924				endm 
# End of macro CWHEAD
4924			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4924			 
4924					; get port 
4924			 
4924					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4924 cd e9 1d			call macro_dsp_valuehl 
4927				endm 
# End of macro FORTH_DSP_VALUEHL
4927			 
4927			;		push hl 
4927			 
4927					; destroy value TOS 
4927			 
4927					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4927 cd a1 1e			call macro_forth_dsp_pop 
492a				endm 
# End of macro FORTH_DSP_POP
492a			 
492a					; one value on hl get other one back 
492a			 
492a			;		pop hl 
492a			 
492a			 
492a					; TODO Get SPI byte 
492a			 
492a cd 89 02				call se_readbyte 
492d			 
492d 26 00				ld h, 0 
492f 6f					ld l, a 
4930 cd f2 1b				call forth_push_numhl 
4933			 
4933					NEXTW 
4933 c3 5b 1f			jp macro_next 
4936				endm 
# End of macro NEXTW
4936			 
4936			.SFREE: 
4936				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4936 67				db WORD_SYS_CORE+83             
4937 65 49			dw .SIZE            
4939 06				db 5 + 1 
493a .. 00			db "FFREE",0              
4940				endm 
# End of macro CWHEAD
4940			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4940					if DEBUG_FORTH_WORDS_KEY 
4940						DMARK "FFR" 
4940 f5				push af  
4941 3a 55 49			ld a, (.dmark)  
4944 32 bd fb			ld (debug_mark),a  
4947 3a 56 49			ld a, (.dmark+1)  
494a 32 be fb			ld (debug_mark+1),a  
494d 3a 57 49			ld a, (.dmark+2)  
4950 32 bf fb			ld (debug_mark+2),a  
4953 18 03			jr .pastdmark  
4955 ..			.dmark: db "FFR"  
4958 f1			.pastdmark: pop af  
4959			endm  
# End of macro DMARK
4959						CALLMONITOR 
4959 cd 65 16			call break_point_state  
495c				endm  
# End of macro CALLMONITOR
495c					endif 
495c			 
495c cd c4 06				call storage_freeblocks 
495f			 
495f cd f2 1b				call forth_push_numhl 
4962			 
4962				       NEXTW 
4962 c3 5b 1f			jp macro_next 
4965				endm 
# End of macro NEXTW
4965			.SIZE: 
4965				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4965 67				db WORD_SYS_CORE+83             
4966 99 49			dw .CREATE            
4968 05				db 4 + 1 
4969 .. 00			db "SIZE",0              
496e				endm 
# End of macro CWHEAD
496e			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
496e					if DEBUG_FORTH_WORDS_KEY 
496e						DMARK "SIZ" 
496e f5				push af  
496f 3a 83 49			ld a, (.dmark)  
4972 32 bd fb			ld (debug_mark),a  
4975 3a 84 49			ld a, (.dmark+1)  
4978 32 be fb			ld (debug_mark+1),a  
497b 3a 85 49			ld a, (.dmark+2)  
497e 32 bf fb			ld (debug_mark+2),a  
4981 18 03			jr .pastdmark  
4983 ..			.dmark: db "SIZ"  
4986 f1			.pastdmark: pop af  
4987			endm  
# End of macro DMARK
4987						CALLMONITOR 
4987 cd 65 16			call break_point_state  
498a				endm  
# End of macro CALLMONITOR
498a					endif 
498a			 
498a					FORTH_DSP_VALUEHL 
498a cd e9 1d			call macro_dsp_valuehl 
498d				endm 
# End of macro FORTH_DSP_VALUEHL
498d			;		push hl 
498d					FORTH_DSP_POP 
498d cd a1 1e			call macro_forth_dsp_pop 
4990				endm 
# End of macro FORTH_DSP_POP
4990			;		pop hl 
4990 cd 38 03				call storage_file_size 
4993			 
4993 cd f2 1b				call forth_push_numhl 
4996			  
4996			 
4996				       NEXTW 
4996 c3 5b 1f			jp macro_next 
4999				endm 
# End of macro NEXTW
4999			 
4999			.CREATE: 
4999				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4999 68				db WORD_SYS_CORE+84             
499a 07 4a			dw .APPEND            
499c 07				db 6 + 1 
499d .. 00			db "CREATE",0              
49a4				endm 
# End of macro CWHEAD
49a4			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
49a4			; | | e.g.  
49a4			; | | TestProgram CREATE 
49a4			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
49a4			; | |  
49a4			; | | Max file IDs are 255. 
49a4			; | |  
49a4					 
49a4					if DEBUG_FORTH_WORDS_KEY 
49a4						DMARK "CRT" 
49a4 f5				push af  
49a5 3a b9 49			ld a, (.dmark)  
49a8 32 bd fb			ld (debug_mark),a  
49ab 3a ba 49			ld a, (.dmark+1)  
49ae 32 be fb			ld (debug_mark+1),a  
49b1 3a bb 49			ld a, (.dmark+2)  
49b4 32 bf fb			ld (debug_mark+2),a  
49b7 18 03			jr .pastdmark  
49b9 ..			.dmark: db "CRT"  
49bc f1			.pastdmark: pop af  
49bd			endm  
# End of macro DMARK
49bd						CALLMONITOR 
49bd cd 65 16			call break_point_state  
49c0				endm  
# End of macro CALLMONITOR
49c0					endif 
49c0			;		call storage_get_block_0 
49c0			 
49c0					; TODO pop hl 
49c0			 
49c0					;v5 FORTH_DSP_VALUE 
49c0					FORTH_DSP_VALUE 
49c0 cd d2 1d			call macro_forth_dsp_value 
49c3				endm 
# End of macro FORTH_DSP_VALUE
49c3			 
49c3				if DEBUG_STORESE 
49c3					DMARK "CR1" 
49c3 f5				push af  
49c4 3a d8 49			ld a, (.dmark)  
49c7 32 bd fb			ld (debug_mark),a  
49ca 3a d9 49			ld a, (.dmark+1)  
49cd 32 be fb			ld (debug_mark+1),a  
49d0 3a da 49			ld a, (.dmark+2)  
49d3 32 bf fb			ld (debug_mark+2),a  
49d6 18 03			jr .pastdmark  
49d8 ..			.dmark: db "CR1"  
49db f1			.pastdmark: pop af  
49dc			endm  
# End of macro DMARK
49dc					CALLMONITOR 
49dc cd 65 16			call break_point_state  
49df				endm  
# End of macro CALLMONITOR
49df				endif 
49df			;		push hl 
49df			;		FORTH_DSP_POP 
49df			;		pop hl 
49df			 
49df			;		inc hl   ; move past the type marker 
49df			 
49df cd fa 06				call storage_create 
49e2			 
49e2				if DEBUG_STORESE 
49e2					DMARK "CT1" 
49e2 f5				push af  
49e3 3a f7 49			ld a, (.dmark)  
49e6 32 bd fb			ld (debug_mark),a  
49e9 3a f8 49			ld a, (.dmark+1)  
49ec 32 be fb			ld (debug_mark+1),a  
49ef 3a f9 49			ld a, (.dmark+2)  
49f2 32 bf fb			ld (debug_mark+2),a  
49f5 18 03			jr .pastdmark  
49f7 ..			.dmark: db "CT1"  
49fa f1			.pastdmark: pop af  
49fb			endm  
# End of macro DMARK
49fb					CALLMONITOR 
49fb cd 65 16			call break_point_state  
49fe				endm  
# End of macro CALLMONITOR
49fe				endif 
49fe			;		push hl 
49fe					FORTH_DSP_POP 
49fe cd a1 1e			call macro_forth_dsp_pop 
4a01				endm 
# End of macro FORTH_DSP_POP
4a01			;		pop hl 
4a01					; push file id to stack 
4a01 cd f2 1b				call forth_push_numhl 
4a04			 
4a04			 
4a04			 
4a04				       NEXTW 
4a04 c3 5b 1f			jp macro_next 
4a07				endm 
# End of macro NEXTW
4a07			 
4a07			.APPEND: 
4a07				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4a07 69				db WORD_SYS_CORE+85             
4a08 98 4a			dw .SDEL            
4a0a 07				db 6 + 1 
4a0b .. 00			db "APPEND",0              
4a12				endm 
# End of macro CWHEAD
4a12			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4a12			; | | e.g. 
4a12			; | | Test CREATE      -> $01 
4a12			; | | "A string to add to file" $01 APPEND 
4a12			; | |  
4a12			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4a12					if DEBUG_FORTH_WORDS_KEY 
4a12						DMARK "APP" 
4a12 f5				push af  
4a13 3a 27 4a			ld a, (.dmark)  
4a16 32 bd fb			ld (debug_mark),a  
4a19 3a 28 4a			ld a, (.dmark+1)  
4a1c 32 be fb			ld (debug_mark+1),a  
4a1f 3a 29 4a			ld a, (.dmark+2)  
4a22 32 bf fb			ld (debug_mark+2),a  
4a25 18 03			jr .pastdmark  
4a27 ..			.dmark: db "APP"  
4a2a f1			.pastdmark: pop af  
4a2b			endm  
# End of macro DMARK
4a2b						CALLMONITOR 
4a2b cd 65 16			call break_point_state  
4a2e				endm  
# End of macro CALLMONITOR
4a2e					endif 
4a2e			 
4a2e					FORTH_DSP_VALUEHL 
4a2e cd e9 1d			call macro_dsp_valuehl 
4a31				endm 
# End of macro FORTH_DSP_VALUEHL
4a31 e5					push hl 	; save file id 
4a32			 
4a32				if DEBUG_STORESE 
4a32					DMARK "AP1" 
4a32 f5				push af  
4a33 3a 47 4a			ld a, (.dmark)  
4a36 32 bd fb			ld (debug_mark),a  
4a39 3a 48 4a			ld a, (.dmark+1)  
4a3c 32 be fb			ld (debug_mark+1),a  
4a3f 3a 49 4a			ld a, (.dmark+2)  
4a42 32 bf fb			ld (debug_mark+2),a  
4a45 18 03			jr .pastdmark  
4a47 ..			.dmark: db "AP1"  
4a4a f1			.pastdmark: pop af  
4a4b			endm  
# End of macro DMARK
4a4b					CALLMONITOR 
4a4b cd 65 16			call break_point_state  
4a4e				endm  
# End of macro CALLMONITOR
4a4e				endif 
4a4e					FORTH_DSP_POP 
4a4e cd a1 1e			call macro_forth_dsp_pop 
4a51				endm 
# End of macro FORTH_DSP_POP
4a51			 
4a51					FORTH_DSP_VALUEHL 
4a51 cd e9 1d			call macro_dsp_valuehl 
4a54				endm 
# End of macro FORTH_DSP_VALUEHL
4a54					;v5 FORTH_DSP_VALUE 
4a54 e5					push hl 	; save ptr to string to save 
4a55			 
4a55				if DEBUG_STORESE 
4a55					DMARK "AP1" 
4a55 f5				push af  
4a56 3a 6a 4a			ld a, (.dmark)  
4a59 32 bd fb			ld (debug_mark),a  
4a5c 3a 6b 4a			ld a, (.dmark+1)  
4a5f 32 be fb			ld (debug_mark+1),a  
4a62 3a 6c 4a			ld a, (.dmark+2)  
4a65 32 bf fb			ld (debug_mark+2),a  
4a68 18 03			jr .pastdmark  
4a6a ..			.dmark: db "AP1"  
4a6d f1			.pastdmark: pop af  
4a6e			endm  
# End of macro DMARK
4a6e					CALLMONITOR 
4a6e cd 65 16			call break_point_state  
4a71				endm  
# End of macro CALLMONITOR
4a71				endif 
4a71					FORTH_DSP_POP 
4a71 cd a1 1e			call macro_forth_dsp_pop 
4a74				endm 
# End of macro FORTH_DSP_POP
4a74			 
4a74 d1					pop de 
4a75 e1					pop hl 
4a76				if DEBUG_STORESE 
4a76					DMARK "AP2" 
4a76 f5				push af  
4a77 3a 8b 4a			ld a, (.dmark)  
4a7a 32 bd fb			ld (debug_mark),a  
4a7d 3a 8c 4a			ld a, (.dmark+1)  
4a80 32 be fb			ld (debug_mark+1),a  
4a83 3a 8d 4a			ld a, (.dmark+2)  
4a86 32 bf fb			ld (debug_mark+2),a  
4a89 18 03			jr .pastdmark  
4a8b ..			.dmark: db "AP2"  
4a8e f1			.pastdmark: pop af  
4a8f			endm  
# End of macro DMARK
4a8f					CALLMONITOR 
4a8f cd 65 16			call break_point_state  
4a92				endm  
# End of macro CALLMONITOR
4a92				endif 
4a92					;inc de ; skip var type indicator 
4a92			 
4a92					; TODO how to append numerics???? 
4a92			 
4a92 cd d4 08				call storage_append		 
4a95			 
4a95				       NEXTW 
4a95 c3 5b 1f			jp macro_next 
4a98				endm 
# End of macro NEXTW
4a98			.SDEL: 
4a98				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4a98 6a				db WORD_SYS_CORE+86             
4a99 e4 4a			dw .OPEN            
4a9b 05				db 4 + 1 
4a9c .. 00			db "ERA",0              
4aa0				endm 
# End of macro CWHEAD
4aa0			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4aa0					FORTH_DSP_VALUEHL 
4aa0 cd e9 1d			call macro_dsp_valuehl 
4aa3				endm 
# End of macro FORTH_DSP_VALUEHL
4aa3			;		push hl 	; save file id 
4aa3			 
4aa3					if DEBUG_FORTH_WORDS_KEY 
4aa3						DMARK "ERA" 
4aa3 f5				push af  
4aa4 3a b8 4a			ld a, (.dmark)  
4aa7 32 bd fb			ld (debug_mark),a  
4aaa 3a b9 4a			ld a, (.dmark+1)  
4aad 32 be fb			ld (debug_mark+1),a  
4ab0 3a ba 4a			ld a, (.dmark+2)  
4ab3 32 bf fb			ld (debug_mark+2),a  
4ab6 18 03			jr .pastdmark  
4ab8 ..			.dmark: db "ERA"  
4abb f1			.pastdmark: pop af  
4abc			endm  
# End of macro DMARK
4abc						CALLMONITOR 
4abc cd 65 16			call break_point_state  
4abf				endm  
# End of macro CALLMONITOR
4abf					endif 
4abf				if DEBUG_STORESE 
4abf					DMARK "ER1" 
4abf f5				push af  
4ac0 3a d4 4a			ld a, (.dmark)  
4ac3 32 bd fb			ld (debug_mark),a  
4ac6 3a d5 4a			ld a, (.dmark+1)  
4ac9 32 be fb			ld (debug_mark+1),a  
4acc 3a d6 4a			ld a, (.dmark+2)  
4acf 32 bf fb			ld (debug_mark+2),a  
4ad2 18 03			jr .pastdmark  
4ad4 ..			.dmark: db "ER1"  
4ad7 f1			.pastdmark: pop af  
4ad8			endm  
# End of macro DMARK
4ad8					CALLMONITOR 
4ad8 cd 65 16			call break_point_state  
4adb				endm  
# End of macro CALLMONITOR
4adb				endif 
4adb					FORTH_DSP_POP 
4adb cd a1 1e			call macro_forth_dsp_pop 
4ade				endm 
# End of macro FORTH_DSP_POP
4ade			 
4ade			;		pop hl 
4ade			 
4ade cd 49 05				call storage_erase 
4ae1				       NEXTW 
4ae1 c3 5b 1f			jp macro_next 
4ae4				endm 
# End of macro NEXTW
4ae4			 
4ae4			.OPEN: 
4ae4				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4ae4 6b				db WORD_SYS_CORE+87             
4ae5 6b 4b			dw .READ            
4ae7 05				db 4 + 1 
4ae8 .. 00			db "OPEN",0              
4aed				endm 
# End of macro CWHEAD
4aed			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4aed			; | | e.g. 
4aed			; | | $01 OPEN $01 DO $01 READ . LOOP 
4aed			 
4aed					if DEBUG_FORTH_WORDS_KEY 
4aed						DMARK "OPN" 
4aed f5				push af  
4aee 3a 02 4b			ld a, (.dmark)  
4af1 32 bd fb			ld (debug_mark),a  
4af4 3a 03 4b			ld a, (.dmark+1)  
4af7 32 be fb			ld (debug_mark+1),a  
4afa 3a 04 4b			ld a, (.dmark+2)  
4afd 32 bf fb			ld (debug_mark+2),a  
4b00 18 03			jr .pastdmark  
4b02 ..			.dmark: db "OPN"  
4b05 f1			.pastdmark: pop af  
4b06			endm  
# End of macro DMARK
4b06						CALLMONITOR 
4b06 cd 65 16			call break_point_state  
4b09				endm  
# End of macro CALLMONITOR
4b09					endif 
4b09					; TODO handle multiple file opens 
4b09			 
4b09 3e 01			       	ld a, 1 
4b0b 32 df f9				ld (store_openext), a 
4b0e			 
4b0e					; get max extents for this file 
4b0e				 
4b0e								 
4b0e					FORTH_DSP_VALUEHL 
4b0e cd e9 1d			call macro_dsp_valuehl 
4b11				endm 
# End of macro FORTH_DSP_VALUEHL
4b11			 
4b11 65					ld h, l 
4b12 2e 00				ld l, 0 
4b14			 
4b14				if DEBUG_STORESE 
4b14					DMARK "OPN" 
4b14 f5				push af  
4b15 3a 29 4b			ld a, (.dmark)  
4b18 32 bd fb			ld (debug_mark),a  
4b1b 3a 2a 4b			ld a, (.dmark+1)  
4b1e 32 be fb			ld (debug_mark+1),a  
4b21 3a 2b 4b			ld a, (.dmark+2)  
4b24 32 bf fb			ld (debug_mark+2),a  
4b27 18 03			jr .pastdmark  
4b29 ..			.dmark: db "OPN"  
4b2c f1			.pastdmark: pop af  
4b2d			endm  
# End of macro DMARK
4b2d					CALLMONITOR 
4b2d cd 65 16			call break_point_state  
4b30				endm  
# End of macro CALLMONITOR
4b30				endif 
4b30			;		push hl 
4b30					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4b30 cd a1 1e			call macro_forth_dsp_pop 
4b33				endm 
# End of macro FORTH_DSP_POP
4b33			;		pop hl 
4b33						 
4b33 11 e8 f9				ld de, store_page      ; get block zero of file 
4b36 cd 4e 08				call storage_read 
4b39			 
4b39			 
4b39 3a ea f9				ld a, (store_page+2)    ; max extents for this file 
4b3c 32 de f9				ld  (store_openmaxext), a   ; get our limit and push 
4b3f					 
4b3f				if DEBUG_STORESE 
4b3f					DMARK "OPx" 
4b3f f5				push af  
4b40 3a 54 4b			ld a, (.dmark)  
4b43 32 bd fb			ld (debug_mark),a  
4b46 3a 55 4b			ld a, (.dmark+1)  
4b49 32 be fb			ld (debug_mark+1),a  
4b4c 3a 56 4b			ld a, (.dmark+2)  
4b4f 32 bf fb			ld (debug_mark+2),a  
4b52 18 03			jr .pastdmark  
4b54 ..			.dmark: db "OPx"  
4b57 f1			.pastdmark: pop af  
4b58			endm  
# End of macro DMARK
4b58					CALLMONITOR 
4b58 cd 65 16			call break_point_state  
4b5b				endm  
# End of macro CALLMONITOR
4b5b				endif 
4b5b fe 00				cp 0 
4b5d 20 03				jr nz, .skipopeneof 
4b5f					; have opened an empty file 
4b5f					 
4b5f 32 df f9				ld (store_openext), a 
4b62			 
4b62			.skipopeneof: 
4b62			 
4b62 6f					ld l, a 
4b63 26 00				ld h, 0 
4b65 cd f2 1b				call forth_push_numhl 
4b68			 
4b68			 
4b68				       NEXTW 
4b68 c3 5b 1f			jp macro_next 
4b6b				endm 
# End of macro NEXTW
4b6b			.READ: 
4b6b				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4b6b 6c				db WORD_SYS_CORE+88             
4b6c b2 4c			dw .EOF            
4b6e 05				db 4 + 1 
4b6f .. 00			db "READ",0              
4b74				endm 
# End of macro CWHEAD
4b74			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4b74			; | | e.g. 
4b74			; | | $01 OPEN $01 DO $01 READ . LOOP 
4b74			 
4b74					if DEBUG_FORTH_WORDS_KEY 
4b74						DMARK "REA" 
4b74 f5				push af  
4b75 3a 89 4b			ld a, (.dmark)  
4b78 32 bd fb			ld (debug_mark),a  
4b7b 3a 8a 4b			ld a, (.dmark+1)  
4b7e 32 be fb			ld (debug_mark+1),a  
4b81 3a 8b 4b			ld a, (.dmark+2)  
4b84 32 bf fb			ld (debug_mark+2),a  
4b87 18 03			jr .pastdmark  
4b89 ..			.dmark: db "REA"  
4b8c f1			.pastdmark: pop af  
4b8d			endm  
# End of macro DMARK
4b8d						CALLMONITOR 
4b8d cd 65 16			call break_point_state  
4b90				endm  
# End of macro CALLMONITOR
4b90					endif 
4b90					; store_openext use it. If zero it is EOF 
4b90			 
4b90					; read block from current stream id 
4b90					; if the block does not contain zero term keep reading blocks until zero found 
4b90					; push the block to stack 
4b90					; save the block id to stream 
4b90			 
4b90			 
4b90					FORTH_DSP_VALUEHL 
4b90 cd e9 1d			call macro_dsp_valuehl 
4b93				endm 
# End of macro FORTH_DSP_VALUEHL
4b93			 
4b93			;		push hl 
4b93			 
4b93				if DEBUG_STORESE 
4b93					DMARK "REA" 
4b93 f5				push af  
4b94 3a a8 4b			ld a, (.dmark)  
4b97 32 bd fb			ld (debug_mark),a  
4b9a 3a a9 4b			ld a, (.dmark+1)  
4b9d 32 be fb			ld (debug_mark+1),a  
4ba0 3a aa 4b			ld a, (.dmark+2)  
4ba3 32 bf fb			ld (debug_mark+2),a  
4ba6 18 03			jr .pastdmark  
4ba8 ..			.dmark: db "REA"  
4bab f1			.pastdmark: pop af  
4bac			endm  
# End of macro DMARK
4bac					CALLMONITOR 
4bac cd 65 16			call break_point_state  
4baf				endm  
# End of macro CALLMONITOR
4baf				endif 
4baf					FORTH_DSP_POP 
4baf cd a1 1e			call macro_forth_dsp_pop 
4bb2				endm 
# End of macro FORTH_DSP_POP
4bb2			 
4bb2			;		pop hl 
4bb2				 
4bb2 65					ld h,l 
4bb3			 
4bb3 3a df f9				ld a, (store_openext) 
4bb6 6f					ld l, a 
4bb7					 
4bb7 fe 00				cp 0 
4bb9 ca 84 4c				jp z, .ateof     ; dont read past eof 
4bbc			 
4bbc			 
4bbc 11 e8 f9				ld de, store_page 
4bbf				if DEBUG_STORESE 
4bbf					DMARK "RE1" 
4bbf f5				push af  
4bc0 3a d4 4b			ld a, (.dmark)  
4bc3 32 bd fb			ld (debug_mark),a  
4bc6 3a d5 4b			ld a, (.dmark+1)  
4bc9 32 be fb			ld (debug_mark+1),a  
4bcc 3a d6 4b			ld a, (.dmark+2)  
4bcf 32 bf fb			ld (debug_mark+2),a  
4bd2 18 03			jr .pastdmark  
4bd4 ..			.dmark: db "RE1"  
4bd7 f1			.pastdmark: pop af  
4bd8			endm  
# End of macro DMARK
4bd8					CALLMONITOR 
4bd8 cd 65 16			call break_point_state  
4bdb				endm  
# End of macro CALLMONITOR
4bdb				endif 
4bdb cd 4e 08				call storage_read 
4bde			 
4bde				if DEBUG_STORESE 
4bde					DMARK "RE2" 
4bde f5				push af  
4bdf 3a f3 4b			ld a, (.dmark)  
4be2 32 bd fb			ld (debug_mark),a  
4be5 3a f4 4b			ld a, (.dmark+1)  
4be8 32 be fb			ld (debug_mark+1),a  
4beb 3a f5 4b			ld a, (.dmark+2)  
4bee 32 bf fb			ld (debug_mark+2),a  
4bf1 18 03			jr .pastdmark  
4bf3 ..			.dmark: db "RE2"  
4bf6 f1			.pastdmark: pop af  
4bf7			endm  
# End of macro DMARK
4bf7					CALLMONITOR 
4bf7 cd 65 16			call break_point_state  
4bfa				endm  
# End of macro CALLMONITOR
4bfa				endif 
4bfa cd 2f 0d			call ishlzero 
4bfd			;	ld a, l 
4bfd			;	add h 
4bfd			;	cp 0 
4bfd ca 8a 4c			jp z, .readeof 
4c00			 
4c00				; not eof so hl should point to data to push to stack 
4c00			 
4c00				if DEBUG_STORESE 
4c00					DMARK "RE3" 
4c00 f5				push af  
4c01 3a 15 4c			ld a, (.dmark)  
4c04 32 bd fb			ld (debug_mark),a  
4c07 3a 16 4c			ld a, (.dmark+1)  
4c0a 32 be fb			ld (debug_mark+1),a  
4c0d 3a 17 4c			ld a, (.dmark+2)  
4c10 32 bf fb			ld (debug_mark+2),a  
4c13 18 03			jr .pastdmark  
4c15 ..			.dmark: db "RE3"  
4c18 f1			.pastdmark: pop af  
4c19			endm  
# End of macro DMARK
4c19					CALLMONITOR 
4c19 cd 65 16			call break_point_state  
4c1c				endm  
# End of macro CALLMONITOR
4c1c				endif 
4c1c cd 60 1c			call forth_push_str 
4c1f			 
4c1f				if DEBUG_STORESE 
4c1f					DMARK "RE4" 
4c1f f5				push af  
4c20 3a 34 4c			ld a, (.dmark)  
4c23 32 bd fb			ld (debug_mark),a  
4c26 3a 35 4c			ld a, (.dmark+1)  
4c29 32 be fb			ld (debug_mark+1),a  
4c2c 3a 36 4c			ld a, (.dmark+2)  
4c2f 32 bf fb			ld (debug_mark+2),a  
4c32 18 03			jr .pastdmark  
4c34 ..			.dmark: db "RE4"  
4c37 f1			.pastdmark: pop af  
4c38			endm  
# End of macro DMARK
4c38					CALLMONITOR 
4c38 cd 65 16			call break_point_state  
4c3b				endm  
# End of macro CALLMONITOR
4c3b				endif 
4c3b				; get next block  or mark as eof 
4c3b			 
4c3b 3a de f9			ld a, (store_openmaxext)   ; get our limit 
4c3e 4f				ld c, a	 
4c3f 3a df f9			ld a, (store_openext) 
4c42			 
4c42				if DEBUG_STORESE 
4c42					DMARK "RE5" 
4c42 f5				push af  
4c43 3a 57 4c			ld a, (.dmark)  
4c46 32 bd fb			ld (debug_mark),a  
4c49 3a 58 4c			ld a, (.dmark+1)  
4c4c 32 be fb			ld (debug_mark+1),a  
4c4f 3a 59 4c			ld a, (.dmark+2)  
4c52 32 bf fb			ld (debug_mark+2),a  
4c55 18 03			jr .pastdmark  
4c57 ..			.dmark: db "RE5"  
4c5a f1			.pastdmark: pop af  
4c5b			endm  
# End of macro DMARK
4c5b					CALLMONITOR 
4c5b cd 65 16			call break_point_state  
4c5e				endm  
# End of macro CALLMONITOR
4c5e				endif 
4c5e b9				cp c 
4c5f 28 29			jr z, .readeof     ; at last extent 
4c61			 
4c61 3c					inc a 
4c62 32 df f9				ld (store_openext), a 
4c65			 
4c65				if DEBUG_STORESE 
4c65					DMARK "RE6" 
4c65 f5				push af  
4c66 3a 7a 4c			ld a, (.dmark)  
4c69 32 bd fb			ld (debug_mark),a  
4c6c 3a 7b 4c			ld a, (.dmark+1)  
4c6f 32 be fb			ld (debug_mark+1),a  
4c72 3a 7c 4c			ld a, (.dmark+2)  
4c75 32 bf fb			ld (debug_mark+2),a  
4c78 18 03			jr .pastdmark  
4c7a ..			.dmark: db "RE6"  
4c7d f1			.pastdmark: pop af  
4c7e			endm  
# End of macro DMARK
4c7e					CALLMONITOR 
4c7e cd 65 16			call break_point_state  
4c81				endm  
# End of macro CALLMONITOR
4c81				endif 
4c81			 
4c81			 
4c81				       NEXTW 
4c81 c3 5b 1f			jp macro_next 
4c84				endm 
# End of macro NEXTW
4c84			.ateof: 
4c84 21 ae 4c				ld hl, .showeof 
4c87 cd 60 1c				call forth_push_str 
4c8a 3e 00		.readeof:	ld a, 0 
4c8c 32 df f9				ld (store_openext), a 
4c8f			 
4c8f					 
4c8f				if DEBUG_STORESE 
4c8f					DMARK "REF" 
4c8f f5				push af  
4c90 3a a4 4c			ld a, (.dmark)  
4c93 32 bd fb			ld (debug_mark),a  
4c96 3a a5 4c			ld a, (.dmark+1)  
4c99 32 be fb			ld (debug_mark+1),a  
4c9c 3a a6 4c			ld a, (.dmark+2)  
4c9f 32 bf fb			ld (debug_mark+2),a  
4ca2 18 03			jr .pastdmark  
4ca4 ..			.dmark: db "REF"  
4ca7 f1			.pastdmark: pop af  
4ca8			endm  
# End of macro DMARK
4ca8					CALLMONITOR 
4ca8 cd 65 16			call break_point_state  
4cab				endm  
# End of macro CALLMONITOR
4cab				endif 
4cab				       NEXTW 
4cab c3 5b 1f			jp macro_next 
4cae				endm 
# End of macro NEXTW
4cae			 
4cae .. 00		.showeof:   db "eof", 0 
4cb2			 
4cb2			 
4cb2			.EOF: 
4cb2				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4cb2 6d				db WORD_SYS_CORE+89             
4cb3 f3 4c			dw .FORMAT            
4cb5 04				db 3 + 1 
4cb6 .. 00			db "EOF",0              
4cba				endm 
# End of macro CWHEAD
4cba			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4cba			; | | e.g. 
4cba			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4cba					; TODO if current block id for stream is zero then push true else false 
4cba			 
4cba					if DEBUG_FORTH_WORDS_KEY 
4cba						DMARK "EOF" 
4cba f5				push af  
4cbb 3a cf 4c			ld a, (.dmark)  
4cbe 32 bd fb			ld (debug_mark),a  
4cc1 3a d0 4c			ld a, (.dmark+1)  
4cc4 32 be fb			ld (debug_mark+1),a  
4cc7 3a d1 4c			ld a, (.dmark+2)  
4cca 32 bf fb			ld (debug_mark+2),a  
4ccd 18 03			jr .pastdmark  
4ccf ..			.dmark: db "EOF"  
4cd2 f1			.pastdmark: pop af  
4cd3			endm  
# End of macro DMARK
4cd3						CALLMONITOR 
4cd3 cd 65 16			call break_point_state  
4cd6				endm  
# End of macro CALLMONITOR
4cd6					endif 
4cd6			 
4cd6					; TODO handlue multiple file streams 
4cd6			 
4cd6					FORTH_DSP_POP     ; for now just get rid of stream id 
4cd6 cd a1 1e			call macro_forth_dsp_pop 
4cd9				endm 
# End of macro FORTH_DSP_POP
4cd9			 
4cd9 2e 01				ld l, 1 
4cdb 3a de f9				ld a, (store_openmaxext) 
4cde fe 00				cp 0 
4ce0 28 09				jr  z, .eofdone   ; empty file 
4ce2 3a df f9				ld a, (store_openext) 
4ce5 fe 00				cp 0 
4ce7 28 02				jr  z, .eofdone 
4ce9 2e 00				ld l, 0 
4ceb 26 00		.eofdone:	ld h, 0 
4ced cd f2 1b				call forth_push_numhl 
4cf0			 
4cf0			 
4cf0				       NEXTW 
4cf0 c3 5b 1f			jp macro_next 
4cf3				endm 
# End of macro NEXTW
4cf3			 
4cf3			.FORMAT: 
4cf3				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4cf3 6d				db WORD_SYS_CORE+89             
4cf4 44 4d			dw .LABEL            
4cf6 07				db 6 + 1 
4cf7 .. 00			db "FORMAT",0              
4cfe				endm 
# End of macro CWHEAD
4cfe			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4cfe					; TODO if current block id for stream is zero then push true else false 
4cfe				 
4cfe				if DEBUG_STORESE 
4cfe					DMARK "FOR" 
4cfe f5				push af  
4cff 3a 13 4d			ld a, (.dmark)  
4d02 32 bd fb			ld (debug_mark),a  
4d05 3a 14 4d			ld a, (.dmark+1)  
4d08 32 be fb			ld (debug_mark+1),a  
4d0b 3a 15 4d			ld a, (.dmark+2)  
4d0e 32 bf fb			ld (debug_mark+2),a  
4d11 18 03			jr .pastdmark  
4d13 ..			.dmark: db "FOR"  
4d16 f1			.pastdmark: pop af  
4d17			endm  
# End of macro DMARK
4d17					CALLMONITOR 
4d17 cd 65 16			call break_point_state  
4d1a				endm  
# End of macro CALLMONITOR
4d1a				endif 
4d1a					; Wipes the bank check flags to cause a reformat on next block 0 read 
4d1a			 
4d1a 21 01 00				ld hl, 1 
4d1d 3e 00				ld a, 0 
4d1f cd e7 01				call se_writebyte 
4d22			 
4d22				if DEBUG_STORESE 
4d22					DMARK "FO0" 
4d22 f5				push af  
4d23 3a 37 4d			ld a, (.dmark)  
4d26 32 bd fb			ld (debug_mark),a  
4d29 3a 38 4d			ld a, (.dmark+1)  
4d2c 32 be fb			ld (debug_mark+1),a  
4d2f 3a 39 4d			ld a, (.dmark+2)  
4d32 32 bf fb			ld (debug_mark+2),a  
4d35 18 03			jr .pastdmark  
4d37 ..			.dmark: db "FO0"  
4d3a f1			.pastdmark: pop af  
4d3b			endm  
# End of macro DMARK
4d3b					CALLMONITOR 
4d3b cd 65 16			call break_point_state  
4d3e				endm  
# End of macro CALLMONITOR
4d3e				endif 
4d3e					; force bank init 
4d3e			 
4d3e cd ba 03				call storage_get_block_0 
4d41					 
4d41				       NEXTW 
4d41 c3 5b 1f			jp macro_next 
4d44				endm 
# End of macro NEXTW
4d44			.LABEL: 
4d44				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4d44 6d				db WORD_SYS_CORE+89             
4d45 92 4d			dw .STOREPAGE            
4d47 06				db 5 + 1 
4d48 .. 00			db "LABEL",0              
4d4e				endm 
# End of macro CWHEAD
4d4e			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4d4e					; TODO test to see if bank is selected 
4d4e				 
4d4e					if DEBUG_FORTH_WORDS_KEY 
4d4e						DMARK "LBL" 
4d4e f5				push af  
4d4f 3a 63 4d			ld a, (.dmark)  
4d52 32 bd fb			ld (debug_mark),a  
4d55 3a 64 4d			ld a, (.dmark+1)  
4d58 32 be fb			ld (debug_mark+1),a  
4d5b 3a 65 4d			ld a, (.dmark+2)  
4d5e 32 bf fb			ld (debug_mark+2),a  
4d61 18 03			jr .pastdmark  
4d63 ..			.dmark: db "LBL"  
4d66 f1			.pastdmark: pop af  
4d67			endm  
# End of macro DMARK
4d67						CALLMONITOR 
4d67 cd 65 16			call break_point_state  
4d6a				endm  
# End of macro CALLMONITOR
4d6a					endif 
4d6a			;	if DEBUG_STORESE 
4d6a			;		DMARK "LBL" 
4d6a			;		CALLMONITOR 
4d6a			;	endif 
4d6a					FORTH_DSP_VALUEHL 
4d6a cd e9 1d			call macro_dsp_valuehl 
4d6d				endm 
# End of macro FORTH_DSP_VALUEHL
4d6d					;v5FORTH_DSP_VALUE 
4d6d					 
4d6d			;		push hl 
4d6d					FORTH_DSP_POP 
4d6d cd a1 1e			call macro_forth_dsp_pop 
4d70				endm 
# End of macro FORTH_DSP_POP
4d70			;		pop hl 
4d70			 
4d70			;v5		inc hl   ; move past the type marker 
4d70			 
4d70				if DEBUG_STORESE 
4d70					DMARK "LBl" 
4d70 f5				push af  
4d71 3a 85 4d			ld a, (.dmark)  
4d74 32 bd fb			ld (debug_mark),a  
4d77 3a 86 4d			ld a, (.dmark+1)  
4d7a 32 be fb			ld (debug_mark+1),a  
4d7d 3a 87 4d			ld a, (.dmark+2)  
4d80 32 bf fb			ld (debug_mark+2),a  
4d83 18 03			jr .pastdmark  
4d85 ..			.dmark: db "LBl"  
4d88 f1			.pastdmark: pop af  
4d89			endm  
# End of macro DMARK
4d89					CALLMONITOR 
4d89 cd 65 16			call break_point_state  
4d8c				endm  
# End of macro CALLMONITOR
4d8c				endif 
4d8c cd de 04				call storage_label 
4d8f			 
4d8f				       NEXTW 
4d8f c3 5b 1f			jp macro_next 
4d92				endm 
# End of macro NEXTW
4d92			.STOREPAGE: 
4d92				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4d92 6d				db WORD_SYS_CORE+89             
4d93 c5 4d			dw .LABELS            
4d95 0a				db 9 + 1 
4d96 .. 00			db "STOREPAGE",0              
4da0				endm 
# End of macro CWHEAD
4da0			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4da0					; TODO test to see if bank is selected 
4da0				 
4da0					if DEBUG_FORTH_WORDS_KEY 
4da0						DMARK "STP" 
4da0 f5				push af  
4da1 3a b5 4d			ld a, (.dmark)  
4da4 32 bd fb			ld (debug_mark),a  
4da7 3a b6 4d			ld a, (.dmark+1)  
4daa 32 be fb			ld (debug_mark+1),a  
4dad 3a b7 4d			ld a, (.dmark+2)  
4db0 32 bf fb			ld (debug_mark+2),a  
4db3 18 03			jr .pastdmark  
4db5 ..			.dmark: db "STP"  
4db8 f1			.pastdmark: pop af  
4db9			endm  
# End of macro DMARK
4db9						CALLMONITOR 
4db9 cd 65 16			call break_point_state  
4dbc				endm  
# End of macro CALLMONITOR
4dbc					endif 
4dbc			;	if DEBUG_STORESE 
4dbc			;		DMARK "STP" 
4dbc			;		CALLMONITOR 
4dbc			;	endif 
4dbc			 
4dbc 21 e8 f9			ld hl, store_page 
4dbf cd f2 1b			call forth_push_numhl 
4dc2			 
4dc2			 
4dc2				       NEXTW 
4dc2 c3 5b 1f			jp macro_next 
4dc5				endm 
# End of macro NEXTW
4dc5			.LABELS: 
4dc5				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4dc5 6d				db WORD_SYS_CORE+89             
4dc6 4f 4e			dw .ENDSTORAGE            
4dc8 07				db 6 + 1 
4dc9 .. 00			db "LABELS",0              
4dd0				endm 
# End of macro CWHEAD
4dd0			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4dd0					;  
4dd0			 
4dd0					; save the current device selected to restore afterwards 
4dd0				 
4dd0 3a ce f9				ld a, (spi_device) 
4dd3 f5					push af 
4dd4			 
4dd4			 
4dd4					; run through each of the banks 
4dd4			 
4dd4 21 01 00				ld hl, 1 
4dd7 cd f2 1b				call forth_push_numhl 
4dda 3e ff				ld a, SPI_CE_HIGH 
4ddc cb 87				res SPI_CE0, a 
4dde 32 ce f9				ld (spi_device), a 
4de1 cd ba 03				call storage_get_block_0 
4de4 21 eb f9				ld hl, store_page+3 
4de7 cd 60 1c				call forth_push_str 
4dea			 
4dea					 
4dea 21 02 00				ld hl, 2 
4ded cd f2 1b				call forth_push_numhl 
4df0 3e ff				ld a, SPI_CE_HIGH 
4df2 cb 8f				res SPI_CE1, a 
4df4 32 ce f9				ld (spi_device), a 
4df7 cd ba 03				call storage_get_block_0 
4dfa 21 eb f9				ld hl, store_page+3 
4dfd cd 60 1c				call forth_push_str 
4e00			 
4e00					 
4e00 21 03 00				ld hl, 3 
4e03 cd f2 1b				call forth_push_numhl 
4e06 3e ff				ld a, SPI_CE_HIGH 
4e08 cb 97				res SPI_CE2, a 
4e0a 32 ce f9				ld (spi_device), a 
4e0d cd ba 03				call storage_get_block_0 
4e10 21 eb f9				ld hl, store_page+3 
4e13 cd 60 1c				call forth_push_str 
4e16			 
4e16			 
4e16 21 04 00				ld hl, 4 
4e19 cd f2 1b				call forth_push_numhl 
4e1c 3e ff				ld a, SPI_CE_HIGH 
4e1e cb 9f				res SPI_CE3, a 
4e20 32 ce f9				ld (spi_device), a 
4e23 cd ba 03				call storage_get_block_0 
4e26 21 eb f9				ld hl, store_page+3 
4e29 cd 60 1c				call forth_push_str 
4e2c			 
4e2c					 
4e2c			 
4e2c 21 05 00				ld hl, 5 
4e2f cd f2 1b				call forth_push_numhl 
4e32 3e ff				ld a, SPI_CE_HIGH 
4e34 cb a7				res SPI_CE4, a 
4e36 32 ce f9				ld (spi_device), a 
4e39 cd ba 03				call storage_get_block_0 
4e3c 21 eb f9				ld hl, store_page+3 
4e3f cd 60 1c				call forth_push_str 
4e42			 
4e42					 
4e42					; push fixed count of storage devices (on board) for now 
4e42			 
4e42 21 05 00				ld hl, 5 
4e45 cd f2 1b				call forth_push_numhl 
4e48			 
4e48					; restore selected device  
4e48				 
4e48 f1					pop af 
4e49 32 ce f9				ld (spi_device), a 
4e4c			 
4e4c				       NEXTW 
4e4c c3 5b 1f			jp macro_next 
4e4f				endm 
# End of macro NEXTW
4e4f			 
4e4f			.ENDSTORAGE: 
4e4f			; eof 
# End of file forth_words_storage.asm
4e4f			endif 
4e4f				include "forth_words_device.asm" 
4e4f			; Device related words 
4e4f			 
4e4f			; | ## Device Words 
4e4f			 
4e4f			if SOUND_ENABLE 
4e4f			.NOTE: 
4e4f				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4e4f			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4e4f					if DEBUG_FORTH_WORDS_KEY 
4e4f						DMARK "NTE" 
4e4f						CALLMONITOR 
4e4f					endif 
4e4f			 
4e4f				 
4e4f			 
4e4f					NEXTW 
4e4f			.AFTERSOUND: 
4e4f			endif 
4e4f			 
4e4f			 
4e4f			USE_GPIO: equ 0 
4e4f			 
4e4f			if USE_GPIO 
4e4f			.GP1: 
4e4f				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4e4f			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4e4f					NEXTW 
4e4f			.GP2: 
4e4f				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4e4f			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4e4f			 
4e4f					NEXTW 
4e4f			 
4e4f			.GP3: 
4e4f				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4e4f			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4e4f			 
4e4f					NEXTW 
4e4f			 
4e4f			.GP4: 
4e4f				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4e4f			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4e4f			 
4e4f					NEXTW 
4e4f			.SIN: 
4e4f			 
4e4f			 
4e4f			endif 
4e4f			 
4e4f			 
4e4f				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4e4f 33				db WORD_SYS_CORE+31             
4e50 84 4e			dw .SOUT            
4e52 03				db 2 + 1 
4e53 .. 00			db "IN",0              
4e56				endm 
# End of macro CWHEAD
4e56			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4e56					if DEBUG_FORTH_WORDS_KEY 
4e56						DMARK "IN." 
4e56 f5				push af  
4e57 3a 6b 4e			ld a, (.dmark)  
4e5a 32 bd fb			ld (debug_mark),a  
4e5d 3a 6c 4e			ld a, (.dmark+1)  
4e60 32 be fb			ld (debug_mark+1),a  
4e63 3a 6d 4e			ld a, (.dmark+2)  
4e66 32 bf fb			ld (debug_mark+2),a  
4e69 18 03			jr .pastdmark  
4e6b ..			.dmark: db "IN."  
4e6e f1			.pastdmark: pop af  
4e6f			endm  
# End of macro DMARK
4e6f						CALLMONITOR 
4e6f cd 65 16			call break_point_state  
4e72				endm  
# End of macro CALLMONITOR
4e72					endif 
4e72					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e72 cd e9 1d			call macro_dsp_valuehl 
4e75				endm 
# End of macro FORTH_DSP_VALUEHL
4e75			 
4e75 e5					push hl 
4e76			 
4e76					; destroy value TOS 
4e76			 
4e76					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e76 cd a1 1e			call macro_forth_dsp_pop 
4e79				endm 
# End of macro FORTH_DSP_POP
4e79			 
4e79					; one value on hl get other one back 
4e79			 
4e79 c1					pop bc 
4e7a			 
4e7a					; do the sub 
4e7a			;		ex de, hl 
4e7a			 
4e7a ed 68				in l,(c) 
4e7c			 
4e7c					; save it 
4e7c			 
4e7c 26 00				ld h,0 
4e7e			 
4e7e					; TODO push value back onto stack for another op etc 
4e7e			 
4e7e cd f2 1b				call forth_push_numhl 
4e81					NEXTW 
4e81 c3 5b 1f			jp macro_next 
4e84				endm 
# End of macro NEXTW
4e84			.SOUT: 
4e84				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4e84 34				db WORD_SYS_CORE+32             
4e85 d7 4e			dw .SPIO            
4e87 04				db 3 + 1 
4e88 .. 00			db "OUT",0              
4e8c				endm 
# End of macro CWHEAD
4e8c			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4e8c					if DEBUG_FORTH_WORDS_KEY 
4e8c						DMARK "OUT" 
4e8c f5				push af  
4e8d 3a a1 4e			ld a, (.dmark)  
4e90 32 bd fb			ld (debug_mark),a  
4e93 3a a2 4e			ld a, (.dmark+1)  
4e96 32 be fb			ld (debug_mark+1),a  
4e99 3a a3 4e			ld a, (.dmark+2)  
4e9c 32 bf fb			ld (debug_mark+2),a  
4e9f 18 03			jr .pastdmark  
4ea1 ..			.dmark: db "OUT"  
4ea4 f1			.pastdmark: pop af  
4ea5			endm  
# End of macro DMARK
4ea5						CALLMONITOR 
4ea5 cd 65 16			call break_point_state  
4ea8				endm  
# End of macro CALLMONITOR
4ea8					endif 
4ea8			 
4ea8					; get port 
4ea8			 
4ea8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ea8 cd e9 1d			call macro_dsp_valuehl 
4eab				endm 
# End of macro FORTH_DSP_VALUEHL
4eab			 
4eab e5					push hl 
4eac			 
4eac					; destroy value TOS 
4eac			 
4eac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4eac cd a1 1e			call macro_forth_dsp_pop 
4eaf				endm 
# End of macro FORTH_DSP_POP
4eaf			 
4eaf					; get byte to send 
4eaf			 
4eaf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4eaf cd e9 1d			call macro_dsp_valuehl 
4eb2				endm 
# End of macro FORTH_DSP_VALUEHL
4eb2			 
4eb2			;		push hl 
4eb2			 
4eb2					; destroy value TOS 
4eb2			 
4eb2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4eb2 cd a1 1e			call macro_forth_dsp_pop 
4eb5				endm 
# End of macro FORTH_DSP_POP
4eb5			 
4eb5					; one value on hl get other one back 
4eb5			 
4eb5			;		pop hl 
4eb5			 
4eb5 c1					pop bc 
4eb6			 
4eb6					if DEBUG_FORTH_WORDS 
4eb6						DMARK "OUT" 
4eb6 f5				push af  
4eb7 3a cb 4e			ld a, (.dmark)  
4eba 32 bd fb			ld (debug_mark),a  
4ebd 3a cc 4e			ld a, (.dmark+1)  
4ec0 32 be fb			ld (debug_mark+1),a  
4ec3 3a cd 4e			ld a, (.dmark+2)  
4ec6 32 bf fb			ld (debug_mark+2),a  
4ec9 18 03			jr .pastdmark  
4ecb ..			.dmark: db "OUT"  
4ece f1			.pastdmark: pop af  
4ecf			endm  
# End of macro DMARK
4ecf						CALLMONITOR 
4ecf cd 65 16			call break_point_state  
4ed2				endm  
# End of macro CALLMONITOR
4ed2					endif 
4ed2			 
4ed2 ed 69				out (c), l 
4ed4			 
4ed4					NEXTW 
4ed4 c3 5b 1f			jp macro_next 
4ed7				endm 
# End of macro NEXTW
4ed7			 
4ed7			 
4ed7			.SPIO: 
4ed7			 
4ed7			if STORAGE_SE 
4ed7				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4ed7 51				db WORD_SYS_CORE+61             
4ed8 e8 4e			dw .SPICEH            
4eda 07				db 6 + 1 
4edb .. 00			db "SPICEL",0              
4ee2				endm 
# End of macro CWHEAD
4ee2			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4ee2			 
4ee2 cd 95 01				call spi_ce_low 
4ee5			    NEXTW 
4ee5 c3 5b 1f			jp macro_next 
4ee8				endm 
# End of macro NEXTW
4ee8			 
4ee8			.SPICEH: 
4ee8				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4ee8 51				db WORD_SYS_CORE+61             
4ee9 f9 4e			dw .SPIOb            
4eeb 07				db 6 + 1 
4eec .. 00			db "SPICEH",0              
4ef3				endm 
# End of macro CWHEAD
4ef3			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4ef3			 
4ef3 cd 84 01				call spi_ce_high 
4ef6			    NEXTW 
4ef6 c3 5b 1f			jp macro_next 
4ef9				endm 
# End of macro NEXTW
4ef9			 
4ef9			 
4ef9			.SPIOb: 
4ef9			 
4ef9				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4ef9 51				db WORD_SYS_CORE+61             
4efa 0f 4f			dw .SPII            
4efc 05				db 4 + 1 
4efd .. 00			db "SPIO",0              
4f02				endm 
# End of macro CWHEAD
4f02			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4f02			 
4f02					; get port 
4f02			 
4f02			 
4f02					; get byte to send 
4f02			 
4f02					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f02 cd e9 1d			call macro_dsp_valuehl 
4f05				endm 
# End of macro FORTH_DSP_VALUEHL
4f05			 
4f05			;		push hl    ; u1  
4f05			 
4f05					; destroy value TOS 
4f05			 
4f05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f05 cd a1 1e			call macro_forth_dsp_pop 
4f08				endm 
# End of macro FORTH_DSP_POP
4f08			 
4f08					; one value on hl get other one back 
4f08			 
4f08			;		pop hl   ; u2 - addr 
4f08			 
4f08					; TODO Send SPI byte 
4f08			 
4f08 7d					ld a, l 
4f09 cd b9 00				call spi_send_byte 
4f0c			 
4f0c					NEXTW 
4f0c c3 5b 1f			jp macro_next 
4f0f				endm 
# End of macro NEXTW
4f0f			 
4f0f			.SPII: 
4f0f				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4f0f 52				db WORD_SYS_CORE+62             
4f10 24 4f			dw .SESEL            
4f12 06				db 5 + 1 
4f13 .. 00			db "SPII",0              
4f18				endm 
# End of macro CWHEAD
4f18			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4f18			 
4f18					; TODO Get SPI byte 
4f18			 
4f18 cd da 00				call spi_read_byte 
4f1b			 
4f1b 26 00				ld h, 0 
4f1d 6f					ld l, a 
4f1e cd f2 1b				call forth_push_numhl 
4f21			 
4f21					NEXTW 
4f21 c3 5b 1f			jp macro_next 
4f24				endm 
# End of macro NEXTW
4f24			 
4f24			 
4f24			 
4f24			.SESEL: 
4f24				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4f24 66				db WORD_SYS_CORE+82             
4f25 c8 4f			dw .CARTDEV            
4f27 05				db 4 + 1 
4f28 .. 00			db "BANK",0              
4f2d				endm 
# End of macro CWHEAD
4f2d			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4f2d					if DEBUG_FORTH_WORDS_KEY 
4f2d						DMARK "BNK" 
4f2d f5				push af  
4f2e 3a 42 4f			ld a, (.dmark)  
4f31 32 bd fb			ld (debug_mark),a  
4f34 3a 43 4f			ld a, (.dmark+1)  
4f37 32 be fb			ld (debug_mark+1),a  
4f3a 3a 44 4f			ld a, (.dmark+2)  
4f3d 32 bf fb			ld (debug_mark+2),a  
4f40 18 03			jr .pastdmark  
4f42 ..			.dmark: db "BNK"  
4f45 f1			.pastdmark: pop af  
4f46			endm  
# End of macro DMARK
4f46						CALLMONITOR 
4f46 cd 65 16			call break_point_state  
4f49				endm  
# End of macro CALLMONITOR
4f49					endif 
4f49			 
4f49 3e ff				ld a, 255 
4f4b 32 d1 f9				ld (spi_cartdev), a 
4f4e			 
4f4e					; get bank 
4f4e			 
4f4e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f4e cd e9 1d			call macro_dsp_valuehl 
4f51				endm 
# End of macro FORTH_DSP_VALUEHL
4f51			 
4f51			;		push hl 
4f51			 
4f51					; destroy value TOS 
4f51			 
4f51					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f51 cd a1 1e			call macro_forth_dsp_pop 
4f54				endm 
# End of macro FORTH_DSP_POP
4f54			 
4f54					; one value on hl get other one back 
4f54			 
4f54			;		pop hl 
4f54			 
4f54			 
4f54 0e ff				ld c, SPI_CE_HIGH 
4f56 06 30				ld b, '0'    ; human readable bank number 
4f58			 
4f58 7d					ld a, l 
4f59			 
4f59					if DEBUG_FORTH_WORDS 
4f59						DMARK "BNK" 
4f59 f5				push af  
4f5a 3a 6e 4f			ld a, (.dmark)  
4f5d 32 bd fb			ld (debug_mark),a  
4f60 3a 6f 4f			ld a, (.dmark+1)  
4f63 32 be fb			ld (debug_mark+1),a  
4f66 3a 70 4f			ld a, (.dmark+2)  
4f69 32 bf fb			ld (debug_mark+2),a  
4f6c 18 03			jr .pastdmark  
4f6e ..			.dmark: db "BNK"  
4f71 f1			.pastdmark: pop af  
4f72			endm  
# End of macro DMARK
4f72						CALLMONITOR 
4f72 cd 65 16			call break_point_state  
4f75				endm  
# End of macro CALLMONITOR
4f75					endif 
4f75			 
4f75					; active low 
4f75			 
4f75 fe 00				cp 0 
4f77 28 28				jr z, .bset 
4f79 fe 01				cp 1 
4f7b 20 04				jr nz, .b2 
4f7d cb 81				res 0, c 
4f7f 06 31				ld b, '1'    ; human readable bank number 
4f81 fe 02		.b2:		cp 2 
4f83 20 04				jr nz, .b3 
4f85 cb 89				res 1, c 
4f87 06 32				ld b, '2'    ; human readable bank number 
4f89 fe 03		.b3:		cp 3 
4f8b 20 04				jr nz, .b4 
4f8d cb 91				res 2, c 
4f8f 06 33				ld b, '3'    ; human readable bank number 
4f91 fe 04		.b4:		cp 4 
4f93 20 04				jr nz, .b5 
4f95 cb 99				res 3, c 
4f97 06 34				ld b, '4'    ; human readable bank number 
4f99 fe 05		.b5:		cp 5 
4f9b 20 04				jr nz, .bset 
4f9d cb a1				res 4, c 
4f9f 06 35				ld b, '5'    ; human readable bank number 
4fa1			 
4fa1			.bset: 
4fa1 79					ld a, c 
4fa2 32 ce f9				ld (spi_device),a 
4fa5 78					ld a, b 
4fa6 32 cd f9				ld (spi_device_id),a 
4fa9					if DEBUG_FORTH_WORDS 
4fa9						DMARK "BN2" 
4fa9 f5				push af  
4faa 3a be 4f			ld a, (.dmark)  
4fad 32 bd fb			ld (debug_mark),a  
4fb0 3a bf 4f			ld a, (.dmark+1)  
4fb3 32 be fb			ld (debug_mark+1),a  
4fb6 3a c0 4f			ld a, (.dmark+2)  
4fb9 32 bf fb			ld (debug_mark+2),a  
4fbc 18 03			jr .pastdmark  
4fbe ..			.dmark: db "BN2"  
4fc1 f1			.pastdmark: pop af  
4fc2			endm  
# End of macro DMARK
4fc2						CALLMONITOR 
4fc2 cd 65 16			call break_point_state  
4fc5				endm  
# End of macro CALLMONITOR
4fc5					endif 
4fc5			 
4fc5					NEXTW 
4fc5 c3 5b 1f			jp macro_next 
4fc8				endm 
# End of macro NEXTW
4fc8			 
4fc8			.CARTDEV: 
4fc8				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4fc8 66				db WORD_SYS_CORE+82             
4fc9 71 50			dw .ENDDEVICE            
4fcb 08				db 7 + 1 
4fcc .. 00			db "CARTDEV",0              
4fd4				endm 
# End of macro CWHEAD
4fd4			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4fd4					if DEBUG_FORTH_WORDS_KEY 
4fd4						DMARK "CDV" 
4fd4 f5				push af  
4fd5 3a e9 4f			ld a, (.dmark)  
4fd8 32 bd fb			ld (debug_mark),a  
4fdb 3a ea 4f			ld a, (.dmark+1)  
4fde 32 be fb			ld (debug_mark+1),a  
4fe1 3a eb 4f			ld a, (.dmark+2)  
4fe4 32 bf fb			ld (debug_mark+2),a  
4fe7 18 03			jr .pastdmark  
4fe9 ..			.dmark: db "CDV"  
4fec f1			.pastdmark: pop af  
4fed			endm  
# End of macro DMARK
4fed						CALLMONITOR 
4fed cd 65 16			call break_point_state  
4ff0				endm  
# End of macro CALLMONITOR
4ff0					endif 
4ff0			 
4ff0					; disable se storage bank selection 
4ff0			 
4ff0 3e ff				ld a, SPI_CE_HIGH		; ce high 
4ff2 32 ce f9				ld (spi_device), a 
4ff5			 
4ff5					; get bank 
4ff5			 
4ff5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ff5 cd e9 1d			call macro_dsp_valuehl 
4ff8				endm 
# End of macro FORTH_DSP_VALUEHL
4ff8			 
4ff8			;		push hl 
4ff8			 
4ff8					; destroy value TOS 
4ff8			 
4ff8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ff8 cd a1 1e			call macro_forth_dsp_pop 
4ffb				endm 
# End of macro FORTH_DSP_POP
4ffb			 
4ffb					; one value on hl get other one back 
4ffb			 
4ffb			;		pop hl 
4ffb			 
4ffb					; active low 
4ffb			 
4ffb 0e ff				ld c, 255 
4ffd			 
4ffd 7d					ld a, l 
4ffe					if DEBUG_FORTH_WORDS 
4ffe						DMARK "CDV" 
4ffe f5				push af  
4fff 3a 13 50			ld a, (.dmark)  
5002 32 bd fb			ld (debug_mark),a  
5005 3a 14 50			ld a, (.dmark+1)  
5008 32 be fb			ld (debug_mark+1),a  
500b 3a 15 50			ld a, (.dmark+2)  
500e 32 bf fb			ld (debug_mark+2),a  
5011 18 03			jr .pastdmark  
5013 ..			.dmark: db "CDV"  
5016 f1			.pastdmark: pop af  
5017			endm  
# End of macro DMARK
5017						CALLMONITOR 
5017 cd 65 16			call break_point_state  
501a				endm  
# End of macro CALLMONITOR
501a					endif 
501a fe 00				cp 0 
501c 28 30				jr z, .cset 
501e fe 01				cp 1 
5020 20 02				jr nz, .c2 
5022 cb 81				res 0, c 
5024 fe 02		.c2:		cp 2 
5026 20 02				jr nz, .c3 
5028 cb 89				res 1, c 
502a fe 03		.c3:		cp 3 
502c 20 02				jr nz, .c4 
502e cb 91				res 2, c 
5030 fe 04		.c4:		cp 4 
5032 20 02				jr nz, .c5 
5034 cb 99				res 3, c 
5036 fe 05		.c5:		cp 5 
5038 20 02				jr nz, .c6 
503a cb a1				res 4, c 
503c fe 06		.c6:		cp 6 
503e 20 02				jr nz, .c7 
5040 cb a9				res 5, c 
5042 fe 07		.c7:		cp 7 
5044 20 02				jr nz, .c8 
5046 cb b1				res 6, c 
5048 fe 08		.c8:		cp 8 
504a 20 02				jr nz, .cset 
504c cb b9				res 7, c 
504e 79			.cset:		ld a, c 
504f 32 d1 f9				ld (spi_cartdev),a 
5052			 
5052					if DEBUG_FORTH_WORDS 
5052						DMARK "CD2" 
5052 f5				push af  
5053 3a 67 50			ld a, (.dmark)  
5056 32 bd fb			ld (debug_mark),a  
5059 3a 68 50			ld a, (.dmark+1)  
505c 32 be fb			ld (debug_mark+1),a  
505f 3a 69 50			ld a, (.dmark+2)  
5062 32 bf fb			ld (debug_mark+2),a  
5065 18 03			jr .pastdmark  
5067 ..			.dmark: db "CD2"  
506a f1			.pastdmark: pop af  
506b			endm  
# End of macro DMARK
506b						CALLMONITOR 
506b cd 65 16			call break_point_state  
506e				endm  
# End of macro CALLMONITOR
506e					endif 
506e					NEXTW 
506e c3 5b 1f			jp macro_next 
5071				endm 
# End of macro NEXTW
5071			endif 
5071			 
5071			.ENDDEVICE: 
5071			; eof 
5071			 
# End of file forth_words_device.asm
5071			 
5071			; var handler 
5071			 
5071			 
5071			.VARS: 
5071				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5071 78				db WORD_SYS_CORE+100             
5072 89 50			dw .V0Q            
5074 04				db 3 + 1 
5075 .. 00			db "V0!",0              
5079				endm 
# End of macro CWHEAD
5079			;| V0! ( u1 -- )  Store value to v0  | DONE 
5079			 
5079					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5079 cd e9 1d			call macro_dsp_valuehl 
507c				endm 
# End of macro FORTH_DSP_VALUEHL
507c			 
507c 11 96 f9				ld de, cli_var_array 
507f			 
507f eb					ex de, hl 
5080 73					ld (hl), e 
5081 23					inc hl 
5082 72					ld (hl), d 
5083			 
5083					; destroy value TOS 
5083			 
5083					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5083 cd a1 1e			call macro_forth_dsp_pop 
5086				endm 
# End of macro FORTH_DSP_POP
5086			 
5086				       NEXTW 
5086 c3 5b 1f			jp macro_next 
5089				endm 
# End of macro NEXTW
5089			.V0Q: 
5089				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5089 79				db WORD_SYS_CORE+101             
508a 9a 50			dw .V1S            
508c 04				db 3 + 1 
508d .. 00			db "V0@",0              
5091				endm 
# End of macro CWHEAD
5091			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5091 2a 96 f9				ld hl, (cli_var_array) 
5094 cd f2 1b				call forth_push_numhl 
5097			 
5097				       NEXTW 
5097 c3 5b 1f			jp macro_next 
509a				endm 
# End of macro NEXTW
509a			.V1S: 
509a				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
509a 7a				db WORD_SYS_CORE+102             
509b b2 50			dw .V1Q            
509d 04				db 3 + 1 
509e .. 00			db "V1!",0              
50a2				endm 
# End of macro CWHEAD
50a2			;| V1! ( u1 -- )  Store value to v1 | DONE 
50a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50a2 cd e9 1d			call macro_dsp_valuehl 
50a5				endm 
# End of macro FORTH_DSP_VALUEHL
50a5			 
50a5 11 98 f9				ld de, cli_var_array+2 
50a8				 
50a8 eb					ex de, hl 
50a9 73					ld (hl), e 
50aa 23					inc hl 
50ab 72					ld (hl), d 
50ac			 
50ac					; destroy value TOS 
50ac			 
50ac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50ac cd a1 1e			call macro_forth_dsp_pop 
50af				endm 
# End of macro FORTH_DSP_POP
50af				       NEXTW 
50af c3 5b 1f			jp macro_next 
50b2				endm 
# End of macro NEXTW
50b2			.V1Q: 
50b2				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
50b2 7b				db WORD_SYS_CORE+103             
50b3 c3 50			dw .V2S            
50b5 04				db 3 + 1 
50b6 .. 00			db "V1@",0              
50ba				endm 
# End of macro CWHEAD
50ba			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
50ba 2a 98 f9				ld hl, (cli_var_array+2) 
50bd cd f2 1b				call forth_push_numhl 
50c0				       NEXTW 
50c0 c3 5b 1f			jp macro_next 
50c3				endm 
# End of macro NEXTW
50c3			.V2S: 
50c3				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
50c3 7c				db WORD_SYS_CORE+104             
50c4 db 50			dw .V2Q            
50c6 04				db 3 + 1 
50c7 .. 00			db "V2!",0              
50cb				endm 
# End of macro CWHEAD
50cb			;| V2! ( u1 -- )  Store value to v2 | DONE 
50cb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50cb cd e9 1d			call macro_dsp_valuehl 
50ce				endm 
# End of macro FORTH_DSP_VALUEHL
50ce			 
50ce 11 9a f9				ld de, cli_var_array+4 
50d1				 
50d1 eb					ex de, hl 
50d2 73					ld (hl), e 
50d3 23					inc hl 
50d4 72					ld (hl), d 
50d5			 
50d5					; destroy value TOS 
50d5			 
50d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50d5 cd a1 1e			call macro_forth_dsp_pop 
50d8				endm 
# End of macro FORTH_DSP_POP
50d8				       NEXTW 
50d8 c3 5b 1f			jp macro_next 
50db				endm 
# End of macro NEXTW
50db			.V2Q: 
50db				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
50db 7d				db WORD_SYS_CORE+105             
50dc ec 50			dw .V3S            
50de 04				db 3 + 1 
50df .. 00			db "V2@",0              
50e3				endm 
# End of macro CWHEAD
50e3			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
50e3 2a 9a f9				ld hl, (cli_var_array+4) 
50e6 cd f2 1b				call forth_push_numhl 
50e9				       NEXTW 
50e9 c3 5b 1f			jp macro_next 
50ec				endm 
# End of macro NEXTW
50ec			.V3S: 
50ec				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
50ec 7c				db WORD_SYS_CORE+104             
50ed 04 51			dw .V3Q            
50ef 04				db 3 + 1 
50f0 .. 00			db "V3!",0              
50f4				endm 
# End of macro CWHEAD
50f4			;| V3! ( u1 -- )  Store value to v3 | DONE 
50f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50f4 cd e9 1d			call macro_dsp_valuehl 
50f7				endm 
# End of macro FORTH_DSP_VALUEHL
50f7			 
50f7 11 9c f9				ld de, cli_var_array+6 
50fa				 
50fa eb					ex de, hl 
50fb 73					ld (hl), e 
50fc 23					inc hl 
50fd 72					ld (hl), d 
50fe			 
50fe					; destroy value TOS 
50fe			 
50fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50fe cd a1 1e			call macro_forth_dsp_pop 
5101				endm 
# End of macro FORTH_DSP_POP
5101				       NEXTW 
5101 c3 5b 1f			jp macro_next 
5104				endm 
# End of macro NEXTW
5104			.V3Q: 
5104				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5104 7d				db WORD_SYS_CORE+105             
5105 15 51			dw .END            
5107 04				db 3 + 1 
5108 .. 00			db "V3@",0              
510c				endm 
# End of macro CWHEAD
510c			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
510c 2a 9c f9				ld hl, (cli_var_array+6) 
510f cd f2 1b				call forth_push_numhl 
5112				       NEXTW 
5112 c3 5b 1f			jp macro_next 
5115				endm 
# End of macro NEXTW
5115			 
5115			 
5115			 
5115			 
5115			 
5115			; end of dict marker 
5115			 
5115 00			.END:    db WORD_SYS_END 
5116 00 00			dw 0 
5118 00				db 0 
5119			 
5119			; use to jp here for user dict words to save on macro expansion  
5119			 
5119			user_dict_next: 
5119				NEXTW 
5119 c3 5b 1f			jp macro_next 
511c				endm 
# End of macro NEXTW
511c			 
511c			 
511c			user_exec: 
511c				;    ld hl, <word code> 
511c				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
511c				;    call forthexec 
511c				;    jp user_dict_next   (NEXT) 
511c			        ;    <word code bytes> 
511c eb				ex de, hl 
511d 2a a4 f2			ld hl,(os_tok_ptr) 
5120				 
5120				FORTH_RSP_NEXT 
5120 cd 99 1b			call macro_forth_rsp_next 
5123				endm 
# End of macro FORTH_RSP_NEXT
5123			 
5123			if DEBUG_FORTH_UWORD 
5123						DMARK "UEX" 
5123 f5				push af  
5124 3a 38 51			ld a, (.dmark)  
5127 32 bd fb			ld (debug_mark),a  
512a 3a 39 51			ld a, (.dmark+1)  
512d 32 be fb			ld (debug_mark+1),a  
5130 3a 3a 51			ld a, (.dmark+2)  
5133 32 bf fb			ld (debug_mark+2),a  
5136 18 03			jr .pastdmark  
5138 ..			.dmark: db "UEX"  
513b f1			.pastdmark: pop af  
513c			endm  
# End of macro DMARK
513c				CALLMONITOR 
513c cd 65 16			call break_point_state  
513f				endm  
# End of macro CALLMONITOR
513f			endif 
513f			 
513f			 
513f			 
513f eb				ex de, hl 
5140 22 a4 f2			ld (os_tok_ptr), hl 
5143				 
5143				; Don't use next - Skips the first word in uword. 
5143			 
5143 c3 ec 1f			jp exec1 
5146			;	NEXT 
5146			 
5146			 
5146			; eof 
# End of file forth_wordsv4.asm
5146			endif 
5146			;;;;;;;;;;;;;; Debug code 
5146			 
5146			 
5146			;if DEBUG_FORTH_PARSE 
5146 .. 00		.nowordfound: db "No match",0 
514f .. 00		.compword:	db "Comparing word ",0 
515f .. 00		.nextwordat:	db "Next word at",0 
516c .. 00		.charmatch:	db "Char match",0 
5177			;endif 
5177			if DEBUG_FORTH_JP 
5177			.foundword:	db "Word match. Exec..",0 
5177			endif 
5177			;if DEBUG_FORTH_PUSH 
5177 .. 00		.enddict:	db "Dict end. Push.",0 
5187 .. 00		.push_str:	db "Pushing string",0 
5196 .. 00		.push_num:	db "Pushing number",0 
51a5 .. 00		.data_sp:	db "SP:",0 
51a9 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
51bb .. 00		.wordinde:	db "Word in DE (3/0):",0 
51cd .. 00		.wordinbc:	db "Word in BC (4/0):",0 
51df			;endif 
51df			;if DEBUG_FORTH_MALLOC 
51df .. 00		.push_malloc:	db "Malloc address",0 
51ee			;endif 
51ee			 
51ee			 
51ee			 
51ee			; display malloc address and current data stack pointer  
51ee			 
51ee			malloc_error: 
51ee d5				push de 
51ef f5				push af 
51f0 e5				push hl 
51f1 cd d2 0a			call clear_display 
51f4 11 16 52			ld de, .mallocerr 
51f7 3e 00			ld a,0 
51f9			;	ld de,os_word_scratch 
51f9 cd e5 0a			call str_at_display 
51fc 3e 11			ld a, display_row_1+17 
51fe 11 bd fb			ld de, debug_mark 
5201 cd e5 0a			call str_at_display 
5204 cd f5 0a			call update_display 
5207				;call break_point_state 
5207 cd 44 66			call cin_wait 
520a			 
520a 3e 20			ld a, ' ' 
520c 32 94 ef			ld (os_view_disable), a 
520f e1				pop hl 
5210 f1				pop af 
5211 d1				pop de	 
5212				CALLMONITOR 
5212 cd 65 16			call break_point_state  
5215				endm  
# End of macro CALLMONITOR
5215 c9				ret 
5216			 
5216 .. 00		.mallocerr: 	db "Malloc Error",0 
5223			;if DEBUG_FORTH_PUSH 
5223			display_data_sp: 
5223 f5				push af 
5224			 
5224				; see if disabled 
5224			 
5224 3a 94 ef			ld a, (os_view_disable) 
5227 fe 2a			cp '*' 
5229 28 67			jr z, .skipdsp 
522b			 
522b e5				push hl 
522c e5				push hl 
522d e5			push hl 
522e cd d2 0a			call clear_display 
5231 e1			pop hl 
5232 7c				ld a,h 
5233 21 a8 f2			ld hl, os_word_scratch 
5236 cd 07 10			call hexout 
5239 e1				pop hl 
523a 7d				ld a,l 
523b 21 aa f2			ld hl, os_word_scratch+2 
523e cd 07 10			call hexout 
5241 21 ac f2			ld hl, os_word_scratch+4 
5244 3e 00			ld a,0 
5246 77				ld (hl),a 
5247 11 a8 f2			ld de,os_word_scratch 
524a 3e 14				ld a, display_row_2 
524c cd e5 0a				call str_at_display 
524f 11 a9 51			ld de, .wordinhl 
5252 3e 00			ld a, display_row_1 
5254			 
5254 cd e5 0a				call str_at_display 
5257 11 bd fb			ld de, debug_mark 
525a 3e 11			ld a, display_row_1+17 
525c			 
525c cd e5 0a				call str_at_display 
525f			 
525f				; display current data stack pointer 
525f 11 a5 51			ld de,.data_sp 
5262 3e 1c				ld a, display_row_2 + 8 
5264 cd e5 0a				call str_at_display 
5267			 
5267 2a 90 f9			ld hl,(cli_data_sp) 
526a e5				push hl 
526b 7c				ld a,h 
526c 21 a8 f2			ld hl, os_word_scratch 
526f cd 07 10			call hexout 
5272 e1				pop hl 
5273 7d				ld a,l 
5274 21 aa f2			ld hl, os_word_scratch+2 
5277 cd 07 10			call hexout 
527a 21 ac f2			ld hl, os_word_scratch+4 
527d 3e 00			ld a,0 
527f 77				ld (hl),a 
5280 11 a8 f2			ld de,os_word_scratch 
5283 3e 1f				ld a, display_row_2 + 11 
5285 cd e5 0a				call str_at_display 
5288			 
5288			 
5288 cd f5 0a			call update_display 
528b cd 52 0a			call delay1s 
528e cd 52 0a			call delay1s 
5291 e1				pop hl 
5292			.skipdsp: 
5292 f1				pop af 
5293 c9				ret 
5294			 
5294			display_data_malloc: 
5294			 
5294 f5				push af 
5295 e5				push hl 
5296 e5				push hl 
5297 e5			push hl 
5298 cd d2 0a			call clear_display 
529b e1			pop hl 
529c 7c				ld a,h 
529d 21 a8 f2			ld hl, os_word_scratch 
52a0 cd 07 10			call hexout 
52a3 e1				pop hl 
52a4 7d				ld a,l 
52a5 21 aa f2			ld hl, os_word_scratch+2 
52a8 cd 07 10			call hexout 
52ab 21 ac f2			ld hl, os_word_scratch+4 
52ae 3e 00			ld a,0 
52b0 77				ld (hl),a 
52b1 11 a8 f2			ld de,os_word_scratch 
52b4 3e 14				ld a, display_row_2 
52b6 cd e5 0a				call str_at_display 
52b9 11 df 51			ld de, .push_malloc 
52bc 3e 00			ld a, display_row_1 
52be			 
52be cd e5 0a				call str_at_display 
52c1			 
52c1				; display current data stack pointer 
52c1 11 a5 51			ld de,.data_sp 
52c4 3e 1c				ld a, display_row_2 + 8 
52c6 cd e5 0a				call str_at_display 
52c9			 
52c9 2a 90 f9			ld hl,(cli_data_sp) 
52cc e5				push hl 
52cd 7c				ld a,h 
52ce 21 a8 f2			ld hl, os_word_scratch 
52d1 cd 07 10			call hexout 
52d4 e1				pop hl 
52d5 7d				ld a,l 
52d6 21 aa f2			ld hl, os_word_scratch+2 
52d9 cd 07 10			call hexout 
52dc 21 ac f2			ld hl, os_word_scratch+4 
52df 3e 00			ld a,0 
52e1 77				ld (hl),a 
52e2 11 a8 f2			ld de,os_word_scratch 
52e5 3e 1f				ld a, display_row_2 + 11 
52e7 cd e5 0a				call str_at_display 
52ea			 
52ea cd f5 0a			call update_display 
52ed cd 52 0a			call delay1s 
52f0 cd 52 0a			call delay1s 
52f3 e1				pop hl 
52f4 f1				pop af 
52f5 c9				ret 
52f6			;endif 
52f6			 
52f6			include "forth_autostart.asm" 
52f6			; list of commands to perform at system start up 
52f6			 
52f6			startcmds: 
52f6			;	dw test11 
52f6			;	dw test12 
52f6			;	dw test13 
52f6			;	dw test14 
52f6			;	dw test15 
52f6			;	dw test16 
52f6			;	dw test17 
52f6			;	dw ifthtest1 
52f6			;	dw ifthtest2 
52f6			;	dw ifthtest3 
52f6			;	dw mmtest1 
52f6			;	dw mmtest2 
52f6			;	dw mmtest3 
52f6			;	dw mmtest4 
52f6			;	dw mmtest5 
52f6			;	dw mmtest6 
52f6			;	dw iftest1 
52f6			;	dw iftest2 
52f6			;	dw iftest3 
52f6			;	dw looptest1 
52f6			;	dw looptest2 
52f6			;	dw test1 
52f6			;	dw test2 
52f6			;	dw test3 
52f6			;	dw test4 
52f6			;	dw game2r 
52f6			;	dw game2b1 
52f6			;	dw game2b2 
52f6			 
52f6				; start up words that are actually useful 
52f6			 
52f6 54 53			dw clrstack 
52f8 87 53			dw type 
52fa 48 55			dw stest 
52fc ab 53			dw strncpy 
52fe e9 54			dw list 
5300 0c 54			dw start1 
5302 1e 54			dw start2 
5304			;	dw start3 
5304 31 54			dw start3b 
5306 89 54			dw start3c 
5308			 
5308				; (unit) testing words 
5308			 
5308 bf 55			dw mtesta 
530a 74 56			dw mtestb 
530c 17 57			dw mtestc 
530e cc 57			dw mtestd 
5310 70 58			dw mteste 
5312			 
5312				; demo/game words 
5312			 
5312 7c 5f		        dw game3w 
5314 aa 5f		        dw game3p 
5316 c8 5f		        dw game3sc 
5318 f9 5f		        dw game3vsi 
531a 25 60		        dw game3vs 
531c				 
531c 6f 5d			dw game2b 
531e dd 5d			dw game2bf 
5320 27 5e			dw game2mba 
5322 bd 5e			dw game2mbas 
5324 ff 5e			dw game2mb 
5326			 
5326 30 5a			dw game1 
5328 41 5a			dw game1a 
532a a3 5a			dw game1b 
532c d8 5a			dw game1c 
532e 0e 5b			dw game1d 
5330 3f 5b			dw game1s 
5332 53 5b			dw game1t 
5334 68 5b			dw game1f 
5336 9c 5b			dw game1z 
5338 e0 5b			dw game1zz 
533a			 
533a 26 59			dw test5 
533c 5e 59			dw test6 
533e 96 59			dw test7 
5340 aa 59			dw test8 
5342 d6 59			dw test9 
5344 ec 59			dw test10 
5346				 
5346 b7 5c		        dw ssv5 
5348 9b 5c		        dw ssv4 
534a 7f 5c		        dw ssv3 
534c 49 5c		        dw ssv2 
534e d0 5c		        dw ssv1 
5350 18 5d		        dw ssv1cpm 
5352			;	dw keyup 
5352			;	dw keydown 
5352			;	dw keyleft 
5352			;	dw keyright 
5352			;	dw 	keyf1 
5352			;	dw keyf2 
5352			;	dw keyf3 
5352			;	dw keyf4 
5352			;	dw keyf5 
5352			;	dw keyf6 
5352			;	dw keyf7 
5352			;	dw keyf8 
5352			;	dw keyf9 
5352			;	dw keyf10 
5352			;	dw keyf11 
5352			;	dw keyf12 
5352			;	dw keytab 
5352			;	dw keycr 
5352			;	dw keyhome 
5352			;	dw keyend 
5352			;	dw keybs 
5352 00 00			db 0, 0	 
5354			 
5354			 
5354			; clear stack  
5354			 
5354 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5387			 
5387			; type ( addr count - ) 
5387 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
53ab			 
53ab			; some direct memory words 
53ab			; strncpy ( len t f -- t ) 
53ab			 
53ab .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
540c			 
540c .. 00		start1:     	db ": bpon $0000 bp ;",0 
541e .. 00		start2:     	db ": bpoff $0001 bp ;",0 
5431			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
5431 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
5489 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
54e9			 
54e9			 
54e9			; a handy word to list items on the stack 
54e9			 
54e9 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
5548			 
5548			 
5548			; test stack  
5548			; rnd8 stest 
5548			 
5548 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
55bf			 
55bf			; random malloc and free cycles 
55bf			 
55bf .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5674			 
5674			; fixed malloc and free cycles 
5674			 
5674 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5717			 
5717			; fixed double string push and drop cycle  
5717			 
5717 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
57cc			 
57cc			; consistent fixed string push and drop cycle  
57cc			 
57cc .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5870			 
5870 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5926			 
5926			;test1:		db ": aa 1 2 3 ;", 0 
5926			;test2:     	db "111 aa 888 999",0 
5926			;test3:     	db ": bb 77 ;",0 
5926			;test4:     	db "$02 $01 do i . loop bb",0 
5926			 
5926 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
595e .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5996 .. 00		test7:     	db ": box hline vline ;",0 
59aa .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
59d6 .. 00		test9:     	db ": sw $01 adsp world ;",0 
59ec .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5a11 .. 00		test11:     	db "hello create .",0 
5a20 .. 00		test12:     	db "hello2 create .",0 
5a30			 
5a30			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5a30			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5a30			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5a30			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5a30			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5a30			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5a30			 
5a30			;iftest1:     	db "$0001 IF cls .",0 
5a30			;iftest2:     	db "$0000 IF cls .",0 
5a30			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5a30			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5a30			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5a30			 
5a30			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a30			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a30			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a30			 
5a30			 
5a30			 
5a30			; a small guess the number game 
5a30			 
5a30 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5a41 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5aa3			 
5aa3 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5ad8 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5b0e .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5b3f .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5b53 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5b68 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5b9c .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5be0			 
5be0			; Using 'ga' save a high score across multiple runs using external storage 
5be0			 
5be0 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5c49			 
5c49			 
5c49			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5c49			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c49			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c49			 
5c49			; simple screen saver to test code memory reuse to destruction 
5c49			 
5c49 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5c7f .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5c9b .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5cb7 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5cd0 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d18 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5d6f			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d6f			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5d6f			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5d6f			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5d6f			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5d6f			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5d6f			 
5d6f			 
5d6f			 
5d6f			; minesweeper/battleship finding game 
5d6f			; draws a game board of random ship/mine positions 
5d6f			; user enters coords to see if it hits on 
5d6f			; game ends when all are hit 
5d6f			; when hit or miss says how many may be in the area 
5d6f			 
5d6f			; setup the game board and then hide it 
5d6f .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5ddd .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5e27			; prompt for where to target 
5e27 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5ebd .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5ee2			; TODO see if the entered coords hits or misses pushes char hit of miss 
5ee2 .. 00		game2mbht:      db ": mbckht nop ;",0 
5ef1 .. 00		game2mbms:      db ": mbcms nop ;",0 
5eff			; TODO how many might be near by 
5eff .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5f7c			 
5f7c			; Game 3 
5f7c			 
5f7c			; Vert scroller ski game - avoid the trees! 
5f7c			 
5f7c			; v0 score (ie turns) 
5f7c			; v1 player pos 
5f7c			; v2 left wall 
5f7c			; v3 right wall 
5f7c			 
5f7c			; Draw side walls randomly 
5f7c			 
5f7c .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5faa			 
5faa			; Draw player 
5faa .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5fc8			 
5fc8			; TODO Get Key 
5fc8			 
5fc8			; TODO Move left right 
5fc8			 
5fc8			; scroll and move walls a bit 
5fc8			 
5fc8 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5ff9			 
5ff9			; main game loop 
5ff9			 
5ff9 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6025 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6064			 
6064			; key board defs 
6064			 
6064 .. 00		keyup:       db ": keyup $05 ;",0 
6072 .. 00		keydown:       db ": keydown $0a ;",0 
6082 .. 00		keyleft:       db ": keyleft $0b ;",0 
6092 .. 00		keyright:       db ": keyright $0c ;",0 
60a3 .. 00		keyf1:       db ": keyf1 $10 ;",0 
60b1 .. 00		keyf2:       db ": keyf2 $11 ;",0 
60bf .. 00		keyf3:       db ": keyf3 $12 ;",0 
60cd .. 00		keyf4:       db ": keyf4 $13 ;",0 
60db .. 00		keyf5:       db ": keyf5 $14 ;",0 
60e9 .. 00		keyf6:       db ": keyf6 $15 ;",0 
60f7 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6105 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6113 .. 00		keyf9:       db ": keyf9 $18 ;",0 
6121 .. 00		keyf10:       db ": keyf10 $19 ;",0 
6130 .. 00		keyf11:       db ": keyf11 $1a ;",0 
613f .. 00		keyf12:       db ": keyf12 $1b ;",0 
614e			 
614e .. 00		keytab:       db ": keytab $09 ;",0 
615d .. 00		keycr:       db ": keycr $0d ;",0 
616b .. 00		keyhome:       db ": keyhome $0e ;",0 
617b .. 00		keyend:       db ": keyend $0f ;",0 
618a .. 00		keybs:       db ": keybs $08 ;",0 
6198			 
6198			   
6198			 
6198			 
6198			 
6198			; eof 
# End of file forth_autostart.asm
6198			 
6198 .. 00		sprompt1: db "Startup load...",0 
61a8 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
61be			 
61be			forth_startup: 
61be 21 f6 52			ld hl, startcmds 
61c1 3e 00			ld a, 0 
61c3 32 c9 f3			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
61c6			 
61c6 e5			.start1:	push hl 
61c7 cd d2 0a			call clear_display 
61ca 11 98 61			ld de, sprompt1 
61cd 3e 00		        ld a, display_row_1 
61cf cd e5 0a			call str_at_display 
61d2 11 a8 61			ld de, sprompt2 
61d5 3e 14		        ld a, display_row_2 
61d7 cd e5 0a			call str_at_display 
61da e1				pop hl 
61db e5				push hl 
61dc 5e				ld e,(hl) 
61dd 23				inc hl 
61de 56				ld d,(hl) 
61df 3e 28		        ld a, display_row_3 
61e1 cd e5 0a			call str_at_display 
61e4 cd f5 0a			call update_display 
61e7			 
61e7			 
61e7 3a c9 f3			ld a, (os_last_cmd) 
61ea fe 00			cp 0 
61ec 28 05			jr z, .startprompt 
61ee cd 46 0a			call delay250ms 
61f1 18 24			jr .startdo 
61f3				 
61f3				 
61f3			 
61f3			.startprompt: 
61f3			 
61f3 3e 4f			ld a,display_row_4 + display_cols - 1 
61f5 11 68 1b		        ld de, endprg 
61f8 cd e5 0a			call str_at_display 
61fb cd f5 0a			call update_display 
61fe cd 52 0a			call delay1s 
6201 cd 44 66			call cin_wait 
6204						 
6204 fe 2a			cp '*' 
6206 28 5e			jr z, .startupend1 
6208 fe 23			cp '#' 
620a 20 07			jr nz, .startno 
620c 3e 01			ld a, 1 
620e 32 c9 f3			ld (os_last_cmd),a 
6211 18 04			jr .startdo 
6213 fe 31		.startno:	cp '1' 
6215 28 3a			jr z,.startnxt  
6217			 
6217				; exec startup line 
6217			.startdo:	 
6217 e1				pop hl 
6218 e5				push hl 
6219				 
6219 5e				ld e,(hl) 
621a 23				inc hl 
621b 56				ld d,(hl) 
621c eb				ex de,hl 
621d			 
621d e5				push hl 
621e			 
621e 3e 00			ld a, 0 
6220				;ld a, FORTH_END_BUFFER 
6220 cd 6f 11			call strlent 
6223 23				inc hl   ; include zero term to copy 
6224 06 00			ld b,0 
6226 4d				ld c,l 
6227 e1				pop hl 
6228 11 a3 ef			ld de, scratch 
622b ed b0			ldir 
622d			 
622d			 
622d 21 a3 ef			ld hl, scratch 
6230 cd a9 1f			call forthparse 
6233 cd e9 1f			call forthexec 
6236 cd 00 1f			call forthexec_cleanup 
6239			 
6239 3e 3c			ld a, display_row_4 
623b 11 0c 19			ld de, endprog 
623e			 
623e cd f5 0a			call update_display		 
6241			 
6241 3a c9 f3			ld a, (os_last_cmd) 
6244 fe 00			cp 0 
6246 20 09			jr nz, .startnxt 
6248 cd 6a 1b			call next_page_prompt 
624b cd d2 0a		        call clear_display 
624e cd f5 0a			call update_display		 
6251			 
6251				; move onto next startup line? 
6251			.startnxt: 
6251			 
6251 cd 46 0a			call delay250ms 
6254 e1				pop hl 
6255			 
6255 23				inc hl 
6256 23				inc hl 
6257			 
6257 e5				push hl 
6258 5e				ld e, (hl) 
6259 23				inc hl 
625a 56				ld d, (hl) 
625b e1				pop hl 
625c				; TODO replace 0 test 
625c			 
625c eb				ex de, hl 
625d cd 2f 0d			call ishlzero 
6260			;	ld a,e 
6260			;	add d 
6260			;	cp 0    ; any left to do? 
6260 eb				ex de, hl 
6261 c2 c6 61			jp nz, .start1 
6264 18 01			jr .startupend 
6266			 
6266 e1			.startupend1: pop hl 
6267			.startupend: 
6267			 
6267 cd d2 0a			call clear_display 
626a cd f5 0a			call update_display 
626d c9				ret 
626e			 
626e			 
626e			; stack over and underflow checks 
626e			 
626e			; init the words to detect the under/overflow 
626e			 
626e			chk_stk_init: 
626e				; a vague random number to check so we dont get any "lucky" hits 
626e 3e 2d			ld a, 45 
6270 6f				ld l, a 
6271 00				nop 
6272 3e 17			ld a, 23 
6274 67				ld h, a 
6275			 
6275 22 8a ef			ld (chk_word), hl     ; the word we need to check against 
6278			 
6278			;	ld (chk_stund), hl	; stack points.... 
6278 22 fd fb			ld (chk_stovr), hl 
627b 22 8e f9			ld (chk_ret_und), hl 
627e 22 0c f9			ld (chk_ret_ovr), hl 
6281 22 0a f7			ld (chk_loop_ovr), hl 
6284 22 08 f5			ld (chk_data_ovr), hl 
6287 c9				ret 
6288				 
6288			check_stacks: 
6288				; check all stack words 
6288			 
6288 e5				push hl 
6289 d5				push de 
628a			 
628a			;	ld de,(chk_word) 
628a			;	ld hl, (chk_stund)	; stack points.... 
628a			;	if DEBUG_STK_FAULT 
628a			;		DMARK "FAa" 
628a			;		CALLMONITOR 
628a			;	endif 
628a			;	call cmp16 
628a			;	jp z, .chk_faulta 
628a			; 
628a			;	ld de, sfaultsu 
628a			;	jp .chk_fault 
628a			 
628a 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
628d ed 5b 8a ef		ld de,(chk_word) 
6291				if DEBUG_STK_FAULT 
6291					DMARK "FAb" 
6291					CALLMONITOR 
6291				endif 
6291 cd 24 0d			call cmp16 
6294 28 06			jr z, .chk_fault1 
6296 11 37 63			ld de, sfaultso 
6299 c3 eb 62			jp .chk_fault 
629c			.chk_fault1:  
629c 2a 8e f9			ld hl, (chk_ret_und) 
629f ed 5b 8a ef		ld de,(chk_word) 
62a3				if DEBUG_STK_FAULT 
62a3					DMARK "FAU" 
62a3					CALLMONITOR 
62a3				endif 
62a3 cd 24 0d			call cmp16 
62a6 ca af 62			jp z, .chk_fault2 
62a9 11 47 63			ld de, sfaultru 
62ac c3 eb 62			jp .chk_fault 
62af			.chk_fault2:  
62af 2a 0c f9			ld hl, (chk_ret_ovr) 
62b2 ed 5b 8a ef		ld de,(chk_word) 
62b6				if DEBUG_STK_FAULT 
62b6					DMARK "FA1" 
62b6					CALLMONITOR 
62b6				endif 
62b6 cd 24 0d			call cmp16 
62b9 ca c2 62			jp z, .chk_fault3 
62bc 11 55 63			ld de, sfaultro 
62bf c3 eb 62			jp .chk_fault 
62c2			.chk_fault3:  
62c2 2a 0a f7			ld hl, (chk_loop_ovr) 
62c5 ed 5b 8a ef		ld de,(chk_word) 
62c9				if DEBUG_STK_FAULT 
62c9					DMARK "FA2" 
62c9					CALLMONITOR 
62c9				endif 
62c9 cd 24 0d			call cmp16 
62cc ca d5 62			jp z, .chk_fault4 
62cf 11 6f 63			ld de, sfaultlo 
62d2 c3 eb 62			jp .chk_fault 
62d5			.chk_fault4:  
62d5 2a 08 f5			ld hl, (chk_data_ovr) 
62d8 ed 5b 8a ef		ld de,(chk_word) 
62dc				if DEBUG_STK_FAULT 
62dc					DMARK "FA3" 
62dc					CALLMONITOR 
62dc				endif 
62dc cd 24 0d			call cmp16 
62df ca e8 62			jp z, .chk_fault5 
62e2 11 89 63			ld de, sfaultdo 
62e5 c3 eb 62			jp .chk_fault 
62e8			 
62e8			 
62e8			.chk_fault5:  
62e8 d1				pop de 
62e9 e1				pop hl 
62ea			 
62ea c9				ret 
62eb			 
62eb cd d2 0a		.chk_fault: 	call clear_display 
62ee 3e 14				ld a, display_row_2 
62f0 cd e5 0a				call str_at_display 
62f3 11 19 63				   ld de, .stackfault 
62f6 3e 00				ld a, display_row_1 
62f8 cd e5 0a				call str_at_display 
62fb 11 bd fb				    ld de, debug_mark 
62fe 3e 11				ld a, display_row_1+17 
6300 cd e5 0a				call str_at_display 
6303 cd f5 0a				call update_display 
6306			 
6306				; prompt before entering montior for investigating issue 
6306			 
6306 3e 3c			ld a, display_row_4 
6308 11 0c 19			ld de, endprog 
630b			 
630b cd f5 0a			call update_display		 
630e			 
630e cd 6a 1b			call next_page_prompt 
6311			 
6311 d1				pop de 
6312 e1				pop hl 
6313 cd 60 19				call monitor 
6316 c3 5a 18				jp warmstart 
6319					;jp 0 
6319					;halt 
6319			 
6319			 
6319			 
6319 .. 00		.stackfault: 	db "Stack fault:",0 
6326			 
6326 .. 00		sfaultsu: 	db	"Stack under flow",0 
6337 .. 00		sfaultso: 	db	"Stack over flow",0 
6347 .. 00		sfaultru:	db "RTS underflow",0 
6355 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
636f .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6389 .. 00		sfaultdo:	db "DTS overflow", 0 
6396			 
6396			 
6396			fault_dsp_under: 
6396 11 a8 63			ld de, .dsp_under 
6399 c3 58 64			jp .show_fault 
639c			 
639c			fault_rsp_under: 
639c 11 b6 63			ld de, .rsp_under 
639f c3 58 64			jp .show_fault 
63a2			fault_loop_under: 
63a2 11 c4 63			ld de, .loop_under 
63a5 c3 58 64			jp .show_fault 
63a8			 
63a8 .. 00		.dsp_under: db "DSP Underflow",0 
63b6 .. 00		.rsp_under: db "RSP Underflow",0 
63c4 .. 00		.loop_under: db "LOOP Underflow",0 
63d3			 
63d3			 
63d3 d5			type_faultn: 	push de 
63d4 e5					push hl 
63d5 cd d2 0a				call clear_display 
63d8 11 ff 63				   ld de, .typefaultn 
63db 3e 00				ld a, display_row_1 
63dd cd e5 0a				call str_at_display 
63e0 11 bd fb				    ld de, debug_mark 
63e3 3e 11				ld a, display_row_1+17 
63e5 cd e5 0a				call str_at_display 
63e8 cd f5 0a				call update_display 
63eb			 
63eb				; prompt before entering montior for investigating issue 
63eb			 
63eb 3e 3c			ld a, display_row_4 
63ed 11 0c 19			ld de, endprog 
63f0			 
63f0 cd f5 0a			call update_display		 
63f3			 
63f3 cd 6a 1b			call next_page_prompt 
63f6			 
63f6 e5					push hl 
63f7 d5					push de 
63f8 cd 60 19				call monitor 
63fb c3 5a 18				jp warmstart 
63fe 76					halt 
63ff			 
63ff			 
63ff .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6416			 
6416 d5			type_faults: 	push de 
6417 e5					push hl 
6418 cd d2 0a				call clear_display 
641b 11 41 64				   ld de, .typefaults 
641e 3e 00				ld a, display_row_1 
6420 cd e5 0a				call str_at_display 
6423 11 bd fb				    ld de, debug_mark 
6426 3e 11				ld a, display_row_1+17 
6428 cd e5 0a				call str_at_display 
642b cd f5 0a				call update_display 
642e			 
642e				; prompt before entering montior for investigating issue 
642e			 
642e 3e 3c			ld a, display_row_4 
6430 11 0c 19			ld de, endprog 
6433			 
6433 cd f5 0a			call update_display		 
6436			 
6436 cd 6a 1b			call next_page_prompt 
6439			 
6439 e1					pop hl 
643a d1					pop de 
643b cd 60 19				call monitor 
643e c3 5a 18				jp warmstart 
6441			 
6441			 
6441 .. 00		.typefaults: db "STR Type Expected TOS!",0 
6458			 
6458			.show_fault: 	 
6458 d5					push de 
6459 cd d2 0a				call clear_display 
645c d1					pop de 
645d 3e 00				ld a, display_row_1 
645f cd e5 0a				call str_at_display 
6462 11 bd fb				    ld de, debug_mark 
6465 3e 11				ld a, display_row_1+17 
6467 cd e5 0a				call str_at_display 
646a cd f5 0a				call update_display 
646d			 
646d				; prompt before entering montior for investigating issue 
646d			 
646d 3e 3c			ld a, display_row_4 
646f 11 0c 19			ld de, endprog 
6472			 
6472 cd f5 0a			call update_display		 
6475			 
6475 cd 6a 1b			call next_page_prompt 
6478			 
6478 e1					pop hl 
6479 d1					pop de 
647a cd 60 19				call monitor 
647d			; do a dump to cli and not warmstart so we preserve all of the uwords.  
647d			; TODO Make optional fault restart to cli or warm boot? 
647d					;jp warmstart 
647d c3 b2 18				jp cli 
6480 76					halt 
6481			; eof 
# End of file forth_kernel.asm
6481			;include "nascombasic.asm" 
6481			 
6481			 
6481			; find out where the code ends if loaded into RAM (for SC114) 
6481			;endofcode:  
6481			;	nop 
6481			 
6481			 
6481			; eof 
6481			 
# End of file main.asm
6481			include "firmware_lcd_4x20.asm" 
6481			; **********************************************************************  
6481			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6481			; **********************************************************************  
6481			;  
6481			; **  Written as a Small Computer Monitor App  
6481			; **  www.scc.me.uk  
6481			;  
6481			; History  
6481			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6481			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6481			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6481			;  
6481			; **********************************************************************  
6481			;  
6481			; This program is an example of one of the methods of interfacing an   
6481			; alphanumeric LCD module.   
6481			;  
6481			; In this example the display is connected to either a Z80 PIO or a   
6481			; simple 8-bit output port.   
6481			;  
6481			; This interfacing method uses 4-bit data mode and uses time delays  
6481			; rather than polling the display's ready status. As a result the   
6481			; interface only requires 6 simple output lines:  
6481			;   Output bit 0 = not used  
6481			;   Output bit 1 = not used  
6481			;   Output bit 2 = RS         High = data, Low = instruction  
6481			;   Output bit 3 = E          Active high  
6481			;   Output bit 4 = DB4  
6481			;   Output bit 5 = DB5  
6481			;   Output bit 6 = DB6  
6481			;   Output bit 7 = DB7  
6481			; Display's R/W is connected to 0v so it is always in write mode  
6481			;  
6481			; This set up should work with any system supporting the RC2014 bus  
6481			  
6481			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6481			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6481			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6481			;  
6481			; **********************************************************************  
6481			  
6481			; **********************************************************************  
6481			; **  Constants  
6481			; **********************************************************************  
6481			; LCD constants required by LCD support module  
6481			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6481			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6481			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
6481			kLCDWidth:  EQU display_cols             ;Width in characters  
6481			  
6481			; **********************************************************************  
6481			; **  Code library usage  
6481			; **********************************************************************  
6481			  
6481			; send character to current cursor position  
6481			; wraps and/or scrolls screen automatically  
6481			  
6481			  
6481			lcd_init:  
6481			  
6481			; SCMonAPI functions used  
6481			  
6481			; Alphanumeric LCD functions used  
6481			; no need to specify specific functions for this module  
6481			  
6481 3e cf		            LD   A, 11001111b  
6483 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
6485 3e 00		            LD   A, 00000000b  
6487 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6489			  
6489			; Initialise alphanumeric LCD module  
6489 cd 02 65		            CALL fLCD_Init      ;Initialise LCD module  
648c			  
648c c9				ret  
648d			  
648d			;  
648d			;;  
648d			; lcd functions  
648d			;  
648d			;  
648d			  
648d			; what is at cursor position   
648d			  
648d			;get_cursor:	ld de, (cursor_row)   ;  row + col  
648d			;		call curptr  
648d			;		ret  
648d			  
648d			  
648d			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
648d			  
648d			curptr:  
648d c5				push bc  
648e 21 53 fb			ld hl, display_fb0  
6491			cpr:	  
6491				; loop for cursor whole row  
6491 0e 14			ld c, display_cols  
6493 23			cpr1:	inc hl  
6494 0d				dec c  
6495 20 fc			jr nz, cpr1  
6497 05				dec b  
6498 20 f7			jr nz, cpr  
649a			  
649a				; add col	  
649a			  
649a 23			cpr2:	inc hl  
649b 1d				dec e  
649c 20 fc			jr nz, cpr2  
649e			  
649e c1				pop bc  
649f c9				ret  
64a0				  
64a0			  
64a0			  
64a0			  
64a0			  
64a0			; write the frame buffer given in hl to hardware   
64a0 22 5b fa		write_display: ld (display_write_tmp), hl 	   
64a3 3e 00			ld a, kLCD_Line1  
64a5 cd 73 65		            CALL fLCD_Pos       ;Position cursor to location in A  
64a8 06 14			ld b, display_cols  
64aa ed 5b 5b fa		ld de, (display_write_tmp)  
64ae cd fa 64			call write_len_string  
64b1				  
64b1				  
64b1 2a 5b fa			ld hl, (display_write_tmp)  
64b4 11 14 00			ld de, display_cols  
64b7 19				add hl,de  
64b8 22 5b fa			ld (display_write_tmp),hl  
64bb			  
64bb				  
64bb 3e 40			ld a, kLCD_Line2  
64bd cd 73 65		            CALL fLCD_Pos       ;Position cursor to location in A  
64c0 06 14			ld b, display_cols  
64c2 ed 5b 5b fa		ld de, (display_write_tmp)  
64c6 cd fa 64			call write_len_string  
64c9				  
64c9 2a 5b fa			ld hl, (display_write_tmp)  
64cc 11 14 00			ld de, display_cols  
64cf 19				add hl,de  
64d0 22 5b fa			ld (display_write_tmp),hl  
64d3			  
64d3				  
64d3 3e 14			ld a, kLCD_Line3  
64d5 cd 73 65		            CALL fLCD_Pos       ;Position cursor to location in A  
64d8 06 14			ld b, display_cols  
64da ed 5b 5b fa		ld de, (display_write_tmp)  
64de cd fa 64			call write_len_string  
64e1				  
64e1 2a 5b fa			ld hl, (display_write_tmp)  
64e4 11 14 00			ld de, display_cols  
64e7 19				add hl,de  
64e8 22 5b fa			ld (display_write_tmp),hl  
64eb			  
64eb				  
64eb 3e 54			ld a, kLCD_Line4  
64ed cd 73 65		            CALL fLCD_Pos       ;Position cursor to location in A  
64f0 06 14			ld b, display_cols  
64f2 ed 5b 5b fa		ld de, (display_write_tmp)  
64f6 cd fa 64			call write_len_string  
64f9 c9					ret  
64fa				  
64fa				; write out a fixed length string given in b from de  
64fa			  
64fa 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
64fb cd 4c 65		            CALL fLCD_Data      ;Write character to display  
64fe 13				inc de  
64ff 10 f9			djnz write_len_string  
6501 c9				ret  
6502			  
6502			; Some other things to do  
6502			;            LD   A, kLCD_Clear ;Display clear  
6502			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6502			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6502			;            LD   A, kLCD_On     ;Display on with no cursor  
6502			;            ;LD   A, kLCD_Off   ;Display off  
6502			;            CALL fLCD_Inst      ;Send instruction to display  
6502			;  
6502			;  
6502			;            halt  
6502			;  
6502			;  
6502			;MsgHello:   DB  "Hello World!",0  
6502			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6502			  
6502			; Custom characters 5 pixels wide by 8 pixels high  
6502			; Up to 8 custom characters can be defined  
6502			;BitMaps:      
6502			;; Character 0x00 = Battery icon  
6502			;            DB  01110b  
6502			;            DB  11011b  
6502			;            DB  10001b  
6502			;            DB  10001b  
6502			;            DB  11111b  
6502			;            DB  11111b  
6502			;            DB  11111b  
6502			;            DB  11111b  
6502			;; Character 0x01 = Bluetooth icon  
6502			;            DB  01100b  
6502			;            DB  01010b  
6502			;            DB  11100b  
6502			;            DB  01000b  
6502			;            DB  11100b  
6502			;            DB  01010b  
6502			;            DB  01100b  
6502			;            DB  00000b  
6502			;  
6502			  
6502			  
6502			; **********************************************************************  
6502			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6502			; **********************************************************************  
6502			;  
6502			; **  Written as a Small Computer Monitor App   
6502			; **  Version 0.1 SCC 2018-05-16  
6502			; **  www.scc.me.uk  
6502			;  
6502			; **********************************************************************  
6502			;  
6502			; This module provides support for alphanumeric LCD modules using with  
6502			; *  HD44780 (or compatible) controller  
6502			; *  5 x 7 pixel fonts  
6502			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6502			; *  Interface via six digital outputs to the display (see below)  
6502			;  
6502			; LCD module pinout:  
6502			;   1  Vss   0v supply  
6502			;   2  Vdd   5v supply  
6502			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6502			;   4  RS    High = data, Low = instruction  
6502			;   5  R/W   High = Read, Low = Write  
6502			;   6  E     Enable signal (active high)  
6502			;   7  DB0   Data bit 0  
6502			;   8  DB1   Data bit 1  
6502			;   9  DB2   Data bit 2  
6502			;  10  DB3   Data bit 3  
6502			;  11  DB4   Data bit 4  
6502			;  12  DB5   Data bit 5  
6502			;  13  DB6   Data bit 6  
6502			;  14  DB7   Data bit 7  
6502			;  15  A     Backlight anode (+)  
6502			;  16  K     Backlight cathode (-)  
6502			;  
6502			; This interfacing method uses 4-bit data mode and uses time delays  
6502			; rather than polling the display's ready status. As a result the   
6502			; interface only requires 6 simple output lines:  
6502			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6502			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6502			;   LCD DB4 = Microcomputer output port bit 4  
6502			;   LCD DB5 = Microcomputer output port bit 5  
6502			;   LCD DB6 = Microcomputer output port bit 6  
6502			;   LCD DB7 = Microcomputer output port bit 7  
6502			; Display's R/W is connected to 0v so it is always in write mode  
6502			; All 6 connections must be on the same port address <kLCDPrt>  
6502			; This method also allows a decent length of cable from micro to LCD  
6502			;  
6502			; **********************************************************************  
6502			;  
6502			; To include the code for any given function provided by this module,   
6502			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6502			; the parent source file.  
6502			; For example:  #REQUIRES   uHexPrefix  
6502			;  
6502			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6502			; in the parent source file.  
6502			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6502			;  
6502			; These are the function names provided by this module:  
6502			; fLCD_Init                     ;Initialise LCD  
6502			; fLCD_Inst                     ;Send instruction to LCD  
6502			; fLCD_Data                     ;Send data byte to LCD  
6502			; fLCD_Pos                      ;Position cursor  
6502			; fLCD_Str                      ;Display string  
6502			; fLCD_Def                      ;Define custom character  
6502			;  
6502			; **********************************************************************  
6502			;  
6502			; Requires SCMonAPI.asm to also be included in the project  
6502			;  
6502			  
6502			  
6502			; **********************************************************************  
6502			; **  Constants  
6502			; **********************************************************************  
6502			  
6502			; Constants that must be defined externally  
6502			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6502			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6502			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6502			;kLCDWidth: EQU 20             ;Width in characters  
6502			  
6502			; general line offsets in any frame buffer  
6502			  
6502			  
6502			display_row_1: equ 0  
6502			display_row_2: equ display_row_1+display_cols  
6502			display_row_3: equ display_row_2 + display_cols  
6502			display_row_4: equ display_row_3 + display_cols  
6502			;display_row_4_eol:   
6502			  
6502			  
6502			; Cursor position values for the start of each line  
6502			kLCD_Line1: EQU 0x00   
6502			kLCD_Line2: EQU 0x40    
6502			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
6502			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
6502			  
6502			; Instructions to send as A register to fLCD_Inst  
6502			kLCD_Clear: EQU 00000001b     ;LCD clear  
6502			kLCD_Off:   EQU 00001000b     ;LCD off  
6502			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6502			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6502			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6502			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6502			  
6502			; Constants used by this code module  
6502			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6502			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6502			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6502			  
6502			  
6502			  
6502			; **********************************************************************  
6502			; **  LCD support functions  
6502			; **********************************************************************  
6502			  
6502			; Initialise alphanumeric LCD module  
6502			; LCD control register codes:  
6502			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6502			;   N    0 = 1-line mode       1 = 2-line mode  
6502			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6502			;   D    0 = Display off       1 = Display on  
6502			;   C    0 = Cursor off        1 = Cursor on  
6502			;   B    0 = Blinking off      1 = Blinking on  
6502			;   ID   0 = Decrement mode    1 = Increment mode  
6502			;   SH   0 = Entire shift off  1 = Entire shift on  
6502 3e 28		fLCD_Init:  LD   A, 40  
6504 cd b9 65		            CALL LCDDelay       ;Delay 40ms after power up  
6507			; For reliable reset set 8-bit mode - 3 times  
6507 cd a3 65		            CALL WrFn8bit       ;Function = 8-bit mode  
650a cd a3 65		            CALL WrFn8bit       ;Function = 8-bit mode  
650d cd a3 65		            CALL WrFn8bit       ;Function = 8-bit mode  
6510			; Set 4-bit mode  
6510 cd 9f 65		            CALL WrFn4bit       ;Function = 4-bit mode  
6513 cd b7 65		            CALL LCDDelay1      ;Delay 37 us or more  
6516			; Function set  
6516 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6518 cd 2b 65		            CALL fLCD_Inst      ;2 line, display on  
651b			; Display On/Off control  
651b 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
651d cd 2b 65		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6520			; Display Clear  
6520 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6522 cd 2b 65		            CALL fLCD_Inst      ;Clear display  
6525			; Entry mode  
6525 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6527 cd 2b 65		            CALL fLCD_Inst      ;Increment mode, shift off  
652a			; Display module now initialised  
652a c9			            RET  
652b			; ok to here  
652b			  
652b			; Write instruction to LCD  
652b			;   On entry: A = Instruction byte to be written  
652b			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
652b f5			fLCD_Inst:  PUSH AF  
652c f5			            PUSH AF  
652d cd 3f 65		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6530 f1			            POP  AF  
6531 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6532 17			            RLA  
6533 17			            RLA  
6534 17			            RLA  
6535 cd 3f 65		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
6538 3e 02		            LD   A, 2  
653a cd b9 65		            CALL LCDDelay       ;Delay 2 ms to complete   
653d f1			            POP  AF  
653e c9			            RET  
653f e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
6541 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6543 cb df		            SET  kLCDBitE, A  
6545 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6547 cb 9f		            RES  kLCDBitE, A  
6549 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
654b c9			            RET  
654c			  
654c			  
654c			; Write data to LCD  
654c			;   On entry: A = Data byte to be written  
654c			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
654c f5			fLCD_Data:  PUSH AF  
654d f5			            PUSH AF  
654e cd 60 65		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
6551 f1			            POP  AF  
6552 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6553 17			            RLA  
6554 17			            RLA  
6555 17			            RLA  
6556 cd 60 65		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
6559 3e 96		            LD   A, 150  
655b 3d			Wait:      DEC  A              ;Wait a while to allow data   
655c 20 fd		            JR   NZ, Wait      ;  write to complete  
655e f1			            POP  AF  
655f c9			            RET  
6560 e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
6562 cb d7		            SET  kLCDBitRS, A  
6564 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6566 cb df		            SET  kLCDBitE, A  
6568 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
656a cb 9f		            RES  kLCDBitE, A  
656c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
656e cb 97		            RES  kLCDBitRS, A  
6570 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6572 c9			            RET  
6573			  
6573			  
6573			; Position cursor to specified location  
6573			;   On entry: A = Cursor position  
6573			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6573 f5			fLCD_Pos:   PUSH AF  
6574 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
6576 cd 2b 65		            CALL fLCD_Inst      ;Write instruction to LCD  
6579 f1			            POP  AF  
657a c9			            RET  
657b			  
657b			  
657b			; Output text string to LCD  
657b			;   On entry: DE = Pointer to null terminated text string  
657b			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
657b 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
657c b7			            OR   A              ;Null terminator?  
657d c8			            RET  Z              ;Yes, so finished  
657e cd 4c 65		            CALL fLCD_Data      ;Write character to display  
6581 13			            INC  DE             ;Point to next character  
6582 18 f7		            JR   fLCD_Str       ;Repeat  
6584 c9					ret  
6585			  
6585			; Define custom character  
6585			;   On entry: A = Character number (0 to 7)  
6585			;             DE = Pointer to character bitmap data  
6585			;   On exit:  A = Next character number  
6585			;             DE = Next location following bitmap  
6585			;             BC HL IX IY I AF' BC' DE' HL' preserved  
6585			; Character is   
6585 c5			fLCD_Def:   PUSH BC  
6586 f5			            PUSH AF  
6587 07			            RLCA                ;Calculate location  
6588 07			            RLCA                ;  for bitmap data  
6589 07			            RLCA                ;  = 8 x CharacterNumber  
658a f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
658c cd 2b 65		            CALL fLCD_Inst      ;Write instruction to LCD  
658f 06 00		            LD   B, 0  
6591 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
6592 cd 4c 65		            CALL fLCD_Data      ;Write byte to display  
6595 13			            INC  DE             ;Point to next byte  
6596 04			            INC  B              ;Count bytes  
6597 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6599 28 f6		            JR   Z, Loop       ;No, so repeat  
659b f1			            POP  AF  
659c 3c			            INC  A              ;Increment character number  
659d c1			            POP  BC  
659e c9			            RET  
659f			  
659f			  
659f			; **********************************************************************  
659f			; **  Private functions  
659f			; **********************************************************************  
659f			  
659f			; Write function to LCD  
659f			;   On entry: A = Function byte to be written  
659f			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
659f 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
65a1 18 02		            JR   WrFunc  
65a3 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
65a5 f5			WrFunc:     PUSH AF  
65a6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
65a8 cb df		            SET  kLCDBitE, A  
65aa d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
65ac cb 9f		            RES  kLCDBitE, A  
65ae d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
65b0 3e 05		            LD   A, 5  
65b2 cd b9 65		            CALL LCDDelay       ;Delay 5 ms to complete  
65b5 f1			            POP  AF  
65b6 c9			            RET  
65b7			  
65b7			  
65b7			; Delay in milliseconds  
65b7			;   On entry: A = Number of milliseconds delay  
65b7			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
65b7 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
65b9 d5			LCDDelay:   PUSH DE  
65ba 5f			            LD   E, A           ;Delay by 'A' ms  
65bb 16 00		            LD   D, 0  
65bd cd 37 0a		            CALL aDelayInMS  
65c0 d1			            POP  DE  
65c1 c9			            RET  
65c2			  
65c2			  
65c2			  
65c2			  
65c2			; eof  
65c2			  
# End of file firmware_lcd_4x20.asm
65c2			include "firmware_key_4x4.asm" 
65c2			  
65c2			  
65c2			; bit mask for each scan column and row for teing the matrix  
65c2			  
65c2			; out   
65c2 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
65c6			; in  
65c6 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
65ca			  
65ca			; row/col to character map  
65ca			  
65ca			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
65ca			;    
65ca			  
65ca			; physical key matrix map to face of key  
65ca			  
65ca			  
65ca			;      	1	2	3	A  
65ca			;   	abc”	def&	ghi$	s1  
65ca			;			  
65ca			;	4	5	6	B  
65ca			; 	jkl,	mno.	pqr:	s2  
65ca			;			  
65ca			; 	7	8	9	C  
65ca			;	stu;	vwx@	yz?!	s3  
65ca			;			  
65ca			; 	*	0	#	D  
65ca			; 	shift lck '	Space < >	Enter ( )	s4  
65ca			;       tab bs 		  
65ca			  
65ca			  
65ca			  
65ca			  
65ca			key_init:  
65ca			  
65ca			; SCMonAPI functions used  
65ca			  
65ca			; Alphanumeric LCD functions used  
65ca			; no need to specify specific functions for this module  
65ca			  
65ca			  
65ca 3e cf		            LD   A, 11001111b  
65cc d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
65ce			;            LD   A, 00000000b  
65ce 3e 0f		            LD   A, 00001111b  
65d0 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
65d2			  
65d2			  
65d2				; TODO Configure cursor shapes  
65d2			  
65d2				; Load cursor shapes   
65d2 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
65d4 11 e4 65		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
65d7 06 02		            LD   B, 2           ;Number of characters to define  
65d9 cd 85 65		.DefLoop:   CALL fLCD_Def       ;Define custom character  
65dc 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
65de			  
65de 3e 01				ld a, 1  
65e0 32 56 fa			ld (cursor_shape),a  
65e3 c9				ret  
65e4			  
65e4			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
65e4			; Up to 8 custom characters can be defined  
65e4			.cursor_shapes:      
65e4			;; Character 0x00 = Normal  
65e4 1f			            DB  11111b  
65e5 1f			            DB  11111b  
65e6 1f			            DB  11111b  
65e7 1f			            DB  11111b  
65e8 1f			            DB  11111b  
65e9 1f			            DB  11111b  
65ea 1f			            DB  11111b  
65eb 1f			            DB  11111b  
65ec			;; Character 0x01 = Modifier  
65ec 1f			            DB  11111b  
65ed 1b			            DB  11011b  
65ee 1b			            DB  11011b  
65ef 1b			            DB  11011b  
65f0 1b			            DB  11011b  
65f1 1f			            DB  11111b  
65f2 1b			            DB  11011b  
65f3 1f			            DB  11111b  
65f4			  
65f4			  
65f4			  
65f4			  
65f4			; Display custom character 0  
65f4			;            LD   A, kLCD_Line1+14  
65f4			;            CALL fLCD_Pos       ;Position cursor to location in A  
65f4			;            LD   A, 0  
65f4			;            CALL fLCD_Data      ;Write character in A at cursor  
65f4			  
65f4			; Display custom character 1  
65f4			;            LD   A, kLCD_Line2+14  
65f4			;            CALL fLCD_Pos      ;Position cursor to location in A  
65f4			;            LD   A, 1  
65f4			;            CALL fLCD_Data     ;Write character in A at cursor  
65f4			  
65f4			; keyboard scanning   
65f4			  
65f4			  
65f4			; key_rows: equ 4  
65f4			; key_cols: equ 4  
65f4			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
65f4			  
65f4			; key_scanr: equ key_row_bitmask  
65f4			; key_scanc: equ key_col_bitmask  
65f4			  
65f4			; key_char_map: equ key_map  
65f4			  
65f4			  
65f4			  
65f4			; character in from keyboard  
65f4			  
65f4 ..			.matrix_to_char: db "D#0*C987B654A321"  
6604			  
6604			  
6604			; map the physical key to a char dependant on state  
6604			  
6604			.key_map_fa:   
6604			  
6604 ..					db 'D'  
6605 0d					db KEY_CR    ; cr  
6606 ..					db ' '  
6607 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
6608 ..					db 'C'  
6609 ..					db 'y'  
660a ..					db 'v'  
660b ..					db 's'  
660c ..					db 'B'  
660d ..					db 'p'  
660e ..					db 'm'  
660f ..					db 'j'  
6610 ..					db 'A'  
6611 ..					db 'g'  
6612 ..					db 'd'  
6613 ..					db 'a'  
6614			  
6614			.key_map_fb:  
6614			  
6614 ..					db 'A'  
6615 ..					db '+'   
6616 ..					db '<'  
6617 ..					db  "'"    
6618			  
6618 ..					db 'A'  
6619 ..					db 'z'  
661a ..					db 'w'  
661b ..					db 't'  
661c ..					db 'A'  
661d ..					db 'q'  
661e ..					db 'n'  
661f ..					db 'k'  
6620 ..					db 'A'  
6621 ..					db 'h'  
6622 ..					db 'e'  
6623 ..			 		db 'b'  
6624			  
6624			.key_map_fc:   
6624			  
6624			  
6624 ..					db 'A'  
6625 ..					db '-'   
6626 ..					db '>'  
6627 ..					db  '='   	  
6628 ..					db 'A'  
6629 ..					db '?'  
662a ..					db 'x'  
662b ..					db 'u'  
662c ..					db 'A'  
662d ..					db 'r'  
662e ..					db 'o'  
662f ..					db 'l'  
6630 ..					db 'A'  
6631 ..					db 'i'  
6632 ..					db 'f'  
6633 ..					db 'c'  
6634			  
6634				  
6634			.key_map_fd:  
6634			  
6634 ..					db 'A'  
6635 ..					db '/'   
6636 ..					db '%'   
6637 08					db KEY_BS  ; back space  
6638 ..					db 'A'  
6639 ..					db '!'  
663a ..					db '@'  
663b ..					db ';'  
663c ..					db 'A'  
663d ..					db ':'  
663e ..					db '.'  
663f ..					db ','  
6640 ..					db 'A'  
6641 ..					db '$'  
6642 ..					db '&'  
6643 ..				 	db '"'  
6644			  
6644					  
6644				  
6644			  
6644			; add cin and cin_wait  
6644			  
6644 cd 55 66		cin_wait: 	call cin  
6647 fe 00			cp 0  
6649 28 f9			jr z, cin_wait   ; block until key press  
664b			  
664b f5				push af   ; save key pressed  
664c			  
664c cd 55 66		.cin_wait1:	call cin  
664f fe 00			cp 0  
6651 20 f9			jr nz, .cin_wait1  	; wait for key release  
6653			  
6653 f1				pop af   ; get key  
6654 c9				ret  
6655			  
6655			  
6655 cd 66 66		cin: 	call .mtoc  
6658			  
6658				; no key held  
6658 fe 00			cp 0  
665a c8				ret z  
665b			  
665b				; stop key bounce  
665b			  
665b			;	ld (key_held),a		 ; save it  
665b 47				ld b, a  
665c			  
665c c5			.cina1:	push bc  
665d cd 66 66			call .mtoc  
6660 c1				pop bc  
6661 b8				cp b  
6662 28 f8			jr z, .cina1  
6664 78				ld a,b		  
6665 c9				ret  
6666			  
6666			; detect keyboard modifier key press and apply new overlay to the face key held  
6666			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
6666			  
6666			;.cin_map_modifier:   
6666			;	ld a, (hl)  
6666			;	and 255  
6666			;	ret NZ		; modifier key not flagged  
6666			;  
6666			;	; get key face  
6666			;  
6666			;	ld b,(key_face_held)  
6666			;  
6666			;	ld b, key_cols * key_rows  
6666			;  
6666			;	push de  
6666			;	pop hl  
6666			;  
6666			;.mmod1: ld a,(hl)   ; get map test  
6666			;	cp b  
6666			;	jr z, .mmod2  
6666			;  
6666			;  
6666			;  
6666			;.mmod2: inc hl    ;   
6666			;  
6666			;	  
6666			;  
6666			;	  
6666			;  
6666			;	ld hl,key_actual_pressed  
6666			;	ld (hl),a,  
6666			;	ret  
6666			  
6666				  
6666			  
6666			; map matrix key held to char on face of key  
6666			  
6666			.mtoc:  
6666			  
6666			  
6666				; TODO optimise the code....  
6666			  
6666			; scan keyboard row 1  
6666 3e 80			ld a, 128  
6668 21 d3 fb			ld hl, keyscan_table  
666b cd 4d 67			call .rowscan  
666e			  
666e				   
666e			  
666e 3e 40			ld a, 64  
6670 21 d7 fb			ld hl, keyscan_table+key_cols  
6673 cd 4d 67			call .rowscan  
6676			  
6676			  
6676			  
6676			  
6676 3e 20			ld a, 32  
6678 21 db fb			ld hl, keyscan_table+(key_cols*2)  
667b cd 4d 67			call .rowscan  
667e			  
667e			  
667e			  
667e 3e 10			ld a, 16  
6680 21 df fb			ld hl, keyscan_table+(key_cols*3)  
6683 cd 4d 67			call .rowscan  
6686			  
6686			  
6686				; flag if key D is held down and remove from reporting  
6686 01 34 66			ld bc, .key_map_fd    
6689 21 d3 fb			ld hl, keyscan_table  
668c 11 c5 fb			ld de, key_fd  
668f cd df 66			call .key_shift_hold  
6692 fe ff			cp 255  
6694 28 33			jr z, .cinmap  
6696				; flag if key C is held down and remove from reporting  
6696 01 24 66			ld bc, .key_map_fc    
6699 21 d7 fb			ld hl, keyscan_table+key_cols  
669c 11 c6 fb			ld de, key_fc  
669f cd df 66			call .key_shift_hold  
66a2 fe ff			cp 255  
66a4 28 23			jr z, .cinmap  
66a6				; flag if key B is held down and remove from reporting  
66a6 01 14 66			ld bc, .key_map_fb    
66a9 21 db fb			ld hl, keyscan_table+(key_cols*2)  
66ac 11 c7 fb			ld de, key_fb  
66af cd df 66			call .key_shift_hold  
66b2 fe ff			cp 255  
66b4 28 13			jr z, .cinmap  
66b6				; flag if key A is held down and remove from reporting  
66b6 01 04 66			ld bc, .key_map_fa    
66b9 21 df fb			ld hl, keyscan_table+(key_cols*3)  
66bc 11 c8 fb			ld de, key_fa  
66bf cd df 66			call .key_shift_hold  
66c2 fe ff			cp 255  
66c4 28 03			jr z, .cinmap  
66c6			  
66c6 11 f4 65			ld de, .matrix_to_char  
66c9			  
66c9			  
66c9			.cinmap:   
66c9				if DEBUG_KEY  
66c9			            LD   A, kLCD_Line4  
66c9			            CALL fLCD_Pos       ;Position cursor to location in A  
66c9					push de  
66c9			            LD   DE, keyscan_table  
66c9			            CALL fLCD_Str       ;Display string pointed to by DE  
66c9					pop de  
66c9				endif  
66c9			  
66c9				; scan key matrix table for any held key  
66c9			  
66c9				; de holds either the default matrix or one selected above  
66c9			  
66c9 21 d3 fb			ld hl, keyscan_table  
66cc 06 10			ld b,key_cols*key_rows  
66ce			  
66ce 7e			.cin1:	ld a,(hl)  
66cf fe 23			cp '#'  
66d1 28 08			jr z, .cinhit  
66d3 23				inc hl  
66d4 13				inc de  
66d5 05				dec b  
66d6 20 f6			jr nz, .cin1  
66d8				; no key found held  
66d8 3e 00			ld a,0  
66da c9				ret  
66db d5			.cinhit: push de  
66dc e1				pop hl  
66dd 7e				ld a,(hl)  
66de c9				ret  
66df			  
66df			; flag a control key is held   
66df			; hl is key pin, de is flag indicator  
66df			  
66df			.key_shift_hold:  
66df c5				push bc  
66e0 3e 01			ld a, 1  
66e2 32 56 fa			ld (cursor_shape),a  
66e5 06 00			ld b, 0  
66e7 7e				ld a, (hl)  
66e8 fe 2e			cp '.'  
66ea 28 0a			jr z, .key_shift1  
66ec 06 ff			ld b, 255  
66ee 3e 2b			ld a, '+'    ; hide key from later scans  
66f0 77				ld (hl),a  
66f1 3e 02			ld a, 2  
66f3 32 56 fa			ld (cursor_shape),a  
66f6			.key_shift1:  
66f6				; write flag indicator  
66f6 78				ld a,b  
66f7 12				ld (de),a  
66f8			  
66f8 d1				pop de    ; de now holds the key map ptr  
66f9 c9				ret  
66fa			  
66fa				  
66fa				  
66fa			  
66fa			  
66fa			  
66fa			  
66fa			  
66fa			  
66fa			  
66fa			  
66fa			  
66fa			  
66fa c9				ret  
66fb			  
66fb			;	push hl  
66fb			;	push de  
66fb			;	push bc  
66fb			;	call keyscan  
66fb			;	; map key matrix to ascii value of key face  
66fb			;  
66fb			;	ld hl, key_face_map  
66fb			;	ld de, keyscan_table  
66fb			;  
66fb			;	; get how many keys to look at  
66fb			;	ld b, keyscan_table_len  
66fb			;	  
66fb			;  
66fb			;	; at this stage fall out on first key hit  
66fb			;	; TODO handle multiple key press  
66fb			;  
66fb			;map1:	ld a,(hl)  
66fb			;	cp '#'  
66fb			;	jr z, keyhit  
66fb			;	inc hl  
66fb			;	inc de  
66fb			;	dec b  
66fb			;	jr nz, map1  
66fb			;nohit:	ld a, 0  
66fb			;	jr keydone  
66fb			;keyhit: push de  
66fb			;	pop hl  
66fb			;	ld a,(hl)  
66fb			;keydone:  
66fb			;	push bc  
66fb			;	push de  
66fb			; 	push hl  
66fb			;	ret   
66fb			;  
66fb			  
66fb			  
66fb			  
66fb			  
66fb			; scan physical key matrix  
66fb			  
66fb			  
66fb			;keyscan:  
66fb			;  
66fb			;; for each key_row use keyscanr bit mask for out  
66fb			;; then read in for keyscanc bitmask  
66fb			;; save result of row scan to keyscantable  
66fb			;  
66fb			;; scan keyboard row 1  
66fb			;  
66fb			;	ld b, key_rows  
66fb			;	ld hl, key_scanr  
66fb			;	ld de, keyscan_table  
66fb			;  
66fb			;rowloop:  
66fb			;  
66fb			;	ld a,(hl)		; out bit mask to energise keyboard row  
66fb			;	call rowscan  
66fb			;	inc hl  
66fb			;	dec b  
66fb			;	jr nz, rowloop  
66fb			;  
66fb			;	ret  
66fb			;  
66fb			;  
66fb			;; pass a out bitmask, b row number  
66fb			;arowscan:   
66fb			;	push bc  
66fb			;  
66fb			;	ld d, b  
66fb			;  
66fb			;	; calculate buffer location for this row  
66fb			;  
66fb			;	ld hl, keyscan_table	  
66fb			;kbufr:  ld e, key_cols  
66fb			;kbufc:	inc hl  
66fb			;	dec e  
66fb			;	jr nz, kbufc  
66fb			;	dec d  
66fb			;	jr nz, kbufr  
66fb			;  
66fb			;	; energise row and read columns  
66fb			;  
66fb			;	out (portbdata),a  
66fb			;	in a,(portbdata)  
66fb			;	ld c,a  
66fb			;  
66fb			;  
66fb			;	; save buffer loc  
66fb			;  
66fb			;	ld (keybufptr), hl  
66fb			;  
66fb			;	ld hl, key_scanc  
66fb			;	ld d, key_cols  
66fb			;  
66fb			;	; for each column check each bit mask  
66fb			;  
66fb			;colloop:  
66fb			;	  
66fb			;  
66fb			;	; reset flags for the row   
66fb			;  
66fb			;	ld b,'.'  
66fb			;	and (hl)  
66fb			;	jr z, maskskip  
66fb			;	ld b,'#'  
66fb			;maskskip:  
66fb			;	; save  key state  
66fb			;	push hl  
66fb			;	ld hl, (keybufptr)  
66fb			;	ld (hl), b  
66fb			;	inc hl  
66fb			;	ld (keybufptr), hl  
66fb			;  
66fb			;	; move to next bit mask  
66fb			;	pop hl  
66fb			;	inc hl  
66fb			;  
66fb			;	dec d  
66fb			;	jr nz, colloop  
66fb			;  
66fb			;	ret  
66fb			;  
66fb			;  
66fb			;;  
66fb			; lcd functions  
66fb			;  
66fb			;  
66fb			  
66fb			;if DEBUG_KEY_MATRIX  
66fb			  
66fb			; test function to display hardware view of matrix state  
66fb			  
66fb			matrix:  
66fb			  
66fb			  
66fb			  
66fb			; scan keyboard row 1  
66fb 3e 80			ld a, 128  
66fd 21 f8 fb			ld hl, keyscan_table_row1  
6700 cd 4d 67			call .rowscan  
6703			  
6703 3e 40			ld a, 64  
6705 21 f3 fb			ld hl, keyscan_table_row2  
6708 cd 4d 67			call .rowscan  
670b			  
670b 3e 20			ld a, 32  
670d 21 ee fb			ld hl, keyscan_table_row3  
6710 cd 4d 67			call .rowscan  
6713			  
6713 3e 10			ld a, 16  
6715 21 e9 fb			ld hl, keyscan_table_row4  
6718 cd 4d 67			call .rowscan  
671b			  
671b			; Display text on first line  
671b 3e 00		            LD   A, kLCD_Line1  
671d cd 73 65		            CALL fLCD_Pos       ;Position cursor to location in A  
6720 11 f8 fb		            LD   DE, keyscan_table_row1  
6723			            ;LD   DE, MsgHello  
6723 cd 7b 65		            CALL fLCD_Str       ;Display string pointed to by DE  
6726			  
6726			; Display text on second line  
6726 3e 40		            LD   A, kLCD_Line2  
6728 cd 73 65		            CALL fLCD_Pos       ;Position cursor to location in A  
672b 11 f3 fb		            LD   DE, keyscan_table_row2  
672e cd 7b 65		            CALL fLCD_Str       ;Display string pointed to by DE  
6731 3e 14		            LD   A, kLCD_Line3  
6733 cd 73 65		            CALL fLCD_Pos       ;Position cursor to location in A  
6736 11 ee fb		            LD   DE, keyscan_table_row3  
6739 cd 7b 65		            CALL fLCD_Str       ;Display string pointed to by DE  
673c 3e 54		            LD   A, kLCD_Line4  
673e cd 73 65		            CALL fLCD_Pos       ;Position cursor to location in A  
6741 11 e9 fb		            LD   DE, keyscan_table_row4  
6744 cd 7b 65		            CALL fLCD_Str       ;Display string pointed to by DE  
6747			  
6747 cd 46 0a			call delay250ms  
674a c3 fb 66			jp matrix  
674d			  
674d			; pass de as row display flags  
674d			.rowscan:   
674d d3 c1			out (portbdata),a  
674f db c1			in a,(portbdata)  
6751 4f				ld c,a  
6752				; reset flags for the row   
6752 06 2e			ld b,'.'  
6754 e6 01			and 1  
6756 28 02			jr z, .p1on  
6758 06 23			ld b,'#'  
675a			.p1on:  
675a 70				ld (hl), b  
675b 23				inc hl  
675c			  
675c 06 2e			ld b,'.'  
675e 79				ld a,c  
675f e6 02			and 2  
6761			;	bit 0,a  
6761 28 02			jr z, .p2on  
6763 06 23			ld b,'#'  
6765			.p2on:  
6765 70				ld (hl), b  
6766 23				inc hl  
6767			;  
6767 06 2e			ld b,'.'  
6769 79				ld a,c  
676a e6 04			and 4  
676c			;;	bit 0,a  
676c 28 02			jr z, .p3on  
676e 06 23			ld b,'#'  
6770			.p3on:  
6770 70				ld (hl), b  
6771 23				inc hl  
6772			;;  
6772 06 2e			ld b,'.'  
6774			;;	bit 0,a  
6774 79				ld a,c  
6775 e6 08			and 8  
6777 28 02			jr z, .p4on  
6779 06 23			ld b,'#'  
677b			.p4on:  
677b 70				ld (hl), b  
677c 23				inc hl  
677d			  
677d			; zero term  
677d 06 00			ld b,0  
677f 70				ld (hl), b  
6780			  
6780 c9			.rscandone: ret  
6781			  
6781			  
6781			  
6781			;endif  
6781			  
6781			  
6781			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
6781
