# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 6e 96			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 ..			buildtime: db   "Build: " 
800a					include "romtimestamp.asm" 
800a ..			db '2025-08-11 12:11' 
# End of file romtimestamp.asm
801a 00				   db 0 
801b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
801f			 
801f			 
801f			 
801f			;        nop  
801f			;        nop 
801f			;;	org 05h		; null out bdos call 
801f			; 
801f			;        nop  
801f			;        nop  
801f			;        nop 
801f			;;	org 08h 
801f			;;; 
801f			;;	jp cin		; rst 8 - char in 
801f			;;; 
801f			; 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;	org 010h 
801f			;; 
801f			;	jp cout		; rest 010h  - char out 
801f			;; 
801f			;	org 01bh   
801f			; 
801f			;	;jp  		; rst 01bh   - write string to display 
801f			;	jp str_at_display 
801f			; 
801f			; 
801f			;	org 020h 
801f			; 
801f			;	; jp		 ; rst 020h - read char at screen location 
801f			; 
801f			;	org 028h 
801f			 
801f				; jp		 ; rst 028h  - storage i/o 
801f			 
801f			; 	org 030h 
801f			;	jp break_point_state 
801f			  
801f			; $30  
801f			; org 038h 
801f			; $38 
801f			 
801f			; TODO any more important entry points to add to jump table for easier coding use? 
801f			 
801f			if BASE_KEV = 1  
801f			 
801f				; need to be at $66 for nmi support 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255 
801f				jp nmi 
801f			endif 
801f			 
801f			include "firmware.asm" 
801f			  
801f			; main constants (used here and in firmware)  
801f			  
801f			; TODO have page 0 of storage as bios  
801f			  
801f			Device_A: equ 0h  
801f			Device_B: equ 040h          ; Sound  
801f			  
801f			if BASE_KEV  
801f			Device_C: equ 080h          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			if BASE_SC114  
801f			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			if BASE_CPM  
801f			; TODO fixup for CPM  
801f			Device_C: equ 080h          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			Device_D: equ 0c0h             ; Keyboard and LCD  
801f			  
801f			; Odd specific debug points for testing hardware dev  
801f			  
801f			;if DEBUG_LEVEL0  
801f			;	include "debug_level0.asm"  
801f			;endif  
801f			;if DEBUG_LEVEL1  
801f			;	include "debug_level1.asm"  
801f			;endif  
801f			;if DEBUG_LEVEL2  
801f			;	include "debug_level2.asm"  
801f			;endif  
801f			  
801f			  
801f			CALLMONITOR: macro  
801f			;	call break_point_state  
801f			; now use the break point debug vector  
801f				call debug_vector  
801f				endm  
801f			  
801f			MALLOC_1: equ 1        ; from dk88   
801f			MALLOC_2: equ 0           ; broke  
801f			MALLOC_3: equ 0           ; really broke  
801f			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801f			  
801f			if BASE_KEV   
801f			;stacksize: equ 256  
801f			; each stack entry is three bytes (type + word)  
801f			stacksize: equ 3*150  
801f			  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 512  
801f			endif  
801f			if BASE_SC114  
801f			;tos:	equ 0f000h  
801f			stacksize: equ 256  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 256  
801f			endif  
801f			  
801f			if BASE_CPM  
801f			;tos:	equ 0f000h  
801f			stacksize: equ 256  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 256  
801f			endif  
801f			  
801f			;if STORAGE_SE == 0  
801f			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801f			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801f			;endif  
801f			  
801f			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801f			  
801f			STORE_0_AUTORUN: equ $20  
801f			  
801f			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801f			  
801f			STORE_0_AUTOFILE: equ $21  
801f			STORE_0_BANKRUN: equ $23  
801f			STORE_0_FILERUN: equ $24  
801f			  
801f			; Block 0 offsets for settings  
801f			  
801f			; if set then skip prompt for start up and accept all  
801f			  
801f			STORE_0_QUICKSTART: equ $25  
801f			  
801f			; Blocks where directory table is held  
801f			  
801f			; Reducing the number of entries increases the max file size  
801f			  
801f			;STORE_DIR_START: equ 1  
801f			;STORE_DIR_END: equ 33  
801f			  
801f			; Blocks from where file data is stored  
801f			  
801f			;STORE_DATA_START: equ STORE_DIR_END + 1  
801f			  
801f			; Block indicators (<32 are data files)  
801f			  
801f			;STORE_BLOCK_CFG: equ $8f       ; config block  
801f			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801f			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801f			;STORE_BLOCK_FREE: equ $85       ; data block free  
801f			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801f			  
801f			  
801f			  
801f			; Directory entry flags  
801f			  
801f			;STORE_DIR_FREE: equ 0  
801f			;STORE_DIR_FILE:  equ 1  
801f			  
801f			; Structure offsets to directory entries  
801f			;STORE_DE_FLAG: equ 0  
801f			;STORE_DE_MAXEXT: equ 1  
801f			;STORE_DE_FILENAME: equ 2  
801f			  
801f			; Structure offsets to block 0  
801f			  
801f			;STORE_BK0_ISFOR: equ 1  
801f			;STORE_BK0_LABEL: equ 3  
801f			  
801f			; memory allocation   
801f			  
801f			chk_stund: equ tos+2           ; underflow check word  
801f			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801f			  
801f			; keyscan table needs rows x cols buffer  
801f			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801f			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801f			  
801f			keyscan_table_row1: equ chk_stovr -key_cols-1  
801f			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801f			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801f			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801f			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801f			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801f			keyscan_scancol: equ keyscan_table-key_cols  
801f			;keyscan_table_len: equ key_rows*key_cols  
801f			;keybufptr: equ keyscan_table - 2  
801f			;keysymbol: equ keybufptr - 1  
801f			key_held: equ keyscan_scancol-1	; currently held  
801f			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801f			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801f			key_fa: equ key_repeat_ct -1 ;  
801f			key_fb: equ key_fa -1 ;  
801f			key_fc: equ key_fb -1 ;  
801f			key_fd: equ key_fc -1 ;  
801f			key_face_held: equ key_fd - 1   
801f			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801f			  
801f			hardware_config: equ key_face_held - 10  
801f			  
801f			; hardware config switches  
801f			; TODO add bitmasks on includes for hardware  
801f			; high byte for expansion ids  
801f			;     0000 0000  no card inserted  
801f			;     0000 0001  storage card inserted  
801f			;     0000 0010  spi sd card active  
801f			  
801f			;       
801f			; low byte:  
801f			;     0000 0001   4x4 keypad  
801f			;     0000 0010   full keyboard  
801f			;     0000 0011   spi/ext keyboard  
801f			;     0000 0100   20x4 lcd  
801f			;     0000 1000   40x4 lcd  
801f			;     0000 1100   spi/ext display  
801f			;     0001 0000   ide interface available  
801f			  
801f			hardware_word: equ hardware_config - 2  
801f			  
801f			; debug marker - optional display of debug point on the debug screens  
801f			  
801f			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
801f			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
801f			  
801f			debug_mark: equ debug_vector - 4  
801f			  
801f			; input_str vars  
801f			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801f			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801f			input_size: equ input_start -1  ; number of chars  
801f			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801f			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801f			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801f			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801f			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801f			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801f			input_len: equ input_cur_onoff - 5 ; length of current input  
801f			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801f			  
801f			; cursor blink rate  
801f			CUR_BLINK_RATE: equ $09  
801f			;CUR_BLINK_RATE: equ 15  
801f			  
801f			key_actual_pressed: equ input_cursor - 1   
801f			key_symbol: equ key_actual_pressed - 1   
801f			key_shift: equ key_symbol - 1   
801f			  
801f			; Display allocation  
801f			  
801f			;display_rows: equ 4     ; move out to mini and mega files  
801f			;display_cols: equ 20  
801f			  
801f			display_fb_len: equ display_rows*display_cols  
801f			  
801f			; primary frame buffer     
801f			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801f			; working frame buffers  
801f			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801f			display_fb3: equ  display_fb1-display_fb_len - 1  
801f			display_fb2: equ  display_fb3-display_fb_len - 1  
801f			;  
801f			; pointer to active frame buffer  
801f			display_fb_active: equ display_fb2 - 2  
801f			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801f			display_write_tmp: equ display_lcde1e2 - 2  
801f			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801f			  
801f			;  
801f			  
801f			;; can load into de directory  
801f			cursor_col: equ display_active-1  
801f			cursor_row: equ cursor_col-1  
801f			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801f			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801f			  
801f			; maths vars  
801f			  
801f			LFSRSeed: equ cursor_shape -20   
801f			randData: equ LFSRSeed - 2  
801f			xrandc: equ randData - 2  
801f			stackstore: equ xrandc - 2  
801f			seed1: equ  stackstore -2   
801f			seed2: equ seed1 - 2  
801f			  
801f			; cf storage vars  
801f			  
801f			iErrorNum:  equ seed2-1         ;Error number  
801f			iErrorReg:  equ iErrorNum -1              ;Error register  
801f			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801f			  
801f			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801f			  
801f			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801f			  
801f			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801f			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801f			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801f			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801f			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801f			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801f			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801f			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801f			store_tmpid: equ store_tmp3 - 1		; page temp id  
801f			store_tmpext: equ store_tmpid - 1		; file extent temp  
801f			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801f			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801f			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801f			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801f			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801f			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801f			;  
801f			; spi vars  
801f			  
801f			  
801f			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801f			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801f			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801f			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801f			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801f			spi_device_id: equ spi_device - 1    ; human readable bank number  
801f			  
801f			;;;;; forth cli params  
801f			  
801f			; TODO use a different frame buffer for forth???  
801f			  
801f			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801f			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801f			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801f			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801f			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801f			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801f			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801f			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801f			  
801f			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801f			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801f			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801f			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801f			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801f			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801f			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801f			  
801f			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801f			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801f			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801f			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801f			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801f			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801f			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801f			  
801f			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801f			  
801f			; os/forth token vars  
801f			  
801f			os_last_cmd: equ os_var_array-255  
801f			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801f			os_current_i: equ os_cli_cmd-2  
801f			os_cur_ptr: equ os_current_i-2  
801f			os_word_scratch: equ os_cur_ptr-30  
801f			os_tok_len: equ os_word_scratch - 2  
801f			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801f			os_tok_malloc: equ os_tok_ptr - 2  
801f			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801f			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801f			execscratch: equ os_input-255        ; exec cmd eval buffer  
801f			scratch: equ execscratch-255  
801f			  
801f			os_stack_1: equ scratch - 3       ; stack holding area 1  
801f			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
801f			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
801f			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
801f			  
801f			  
801f			; temp locations for new word processing to save on adding more   
801f			  
801f			os_new_malloc: equ os_stack_4-2  
801f			os_new_parse_len: equ os_new_malloc - 2  
801f			os_new_word_len: equ os_new_parse_len - 2  
801f			os_new_work_ptr: equ os_new_word_len - 2  
801f			os_new_src_ptr: equ os_new_work_ptr - 2  
801f			os_new_exec: equ os_new_src_ptr - 2  
801f			os_new_exec_ptr: equ os_new_exec - 2  
801f			  
801f			; resume memory alloocations....  
801f			  
801f			;os_view_disable: equ os_new_exec_ptr - 1  
801f			os_view_af: equ os_new_exec_ptr - 2  
801f			os_view_hl: equ os_view_af -2  
801f			os_view_de: equ os_view_hl - 2  
801f			os_view_bc: equ os_view_de - 2  
801f			  
801f			; stack checksum word  
801f			if DEBUG_STACK_IMB  
801f				curframe: equ  os_view_de - 5  
801f				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801f				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801f			else  
801f				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801f			endif  
801f			  
801f			; with data stack could see memory filled with junk. need some memory management   
801f			; malloc and free entry points added  
801f			  
801f			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801f			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801f			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			;heap_end: equ free_list-1  ; Starting address of heap  
801f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			  
801f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			heap_end: equ chk_word-1  ; Starting address of heap  
801f			  
801f			  
801f			;if BASE_KEV   
801f			;heap_start: equ 0800eh  ; Starting address of heap  
801f			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801f			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801f			;endif  
801f			  
801f			;if BASE_SC114  
801f			;heap_start: equ baseram+15  ; Starting address of heap  
801f			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801f			;endif  
801f			  
801f			  
801f			;;;;  
801f			  
801f			  
801f			; change below to point to last memory alloc above  
801f			topusermem:  equ   heap_start  
801f			  
801f			;if BASE_KEV   
801f			;baseusermem: equ 08000h  
801f			;endif  
801f			  
801f			;if BASE_SC114  
801f			;;aseusermem:     equ    12  
801f			;baseusermem:     equ    prompt  
801f			;;baseusermem:     equ    endofcode  
801f			;endif  
801f			  
801f			  
801f			; **********************************************************************  
801f			; **  Constants  
801f			; **********************************************************************  
801f			  
801f			; Constants used by this code module  
801f			kDataReg:   EQU Device_D           ;PIO port A data register  
801f			kContReg:   EQU Device_D+2           ;PIO port A control register  
801f			  
801f			  
801f			portbdata:  equ Device_D+1    ; port b data  
801f			portbctl:   equ Device_D+3    ; port b control  
801f			  
801f			  
801f			;KEY_SHIFT:   equ 5  
801f			;KEY_SYMBOLSHIFT:  equ 6  
801f			  
801f			KEY_SHIFTLOCK: equ 4  
801f			  
801f			  
801f			KEY_UP: equ 5  
801f			KEY_NEXTWORD: equ 6  
801f			KEY_PREVWORD: equ 7  
801f			KEY_BS: equ 8  
801f			KEY_TAB:  equ 9  
801f			KEY_DOWN: equ 10  
801f			KEY_LEFT: equ 11  
801f			KEY_RIGHT: equ 12  
801f			KEY_CR:   equ 13  
801f			KEY_HOME: equ 14  
801f			KEY_END: equ 15  
801f			  
801f			KEY_F1: equ 16  
801f			KEY_F2: equ 17  
801f			KEY_F3: equ 18  
801f			KEY_F4: equ 19  
801f			  
801f			KEY_F5: equ 20  
801f			KEY_F6: equ 21  
801f			KEY_F7: equ 22  
801f			KEY_F8: equ 23  
801f			  
801f			KEY_F9: equ 24  
801f			KEY_F10: equ 25  
801f			KEY_F11: equ 26  
801f			KEY_F12: equ 27  
801f			  
801f			;if DEBUG_KEY  
801f			;	KEY_MATRIX_NO_PRESS: equ '.'  
801f			;	KEY_SHIFT:   equ '.'  
801f			;	KEY_SYMBOLSHIFT:  equ '.'  
801f			;else  
801f				KEY_SHIFT:   equ '~'  
801f				KEY_SYMBOLSHIFT:  equ '~'  
801f				KEY_MATRIX_NO_PRESS: equ '~'  
801f			;endi  
801f			  
801f			  
801f			  
801f			  
801f			; Macro to make adding debug marks easier  
801f			  
801f			DMARK: macro str  
801f				push af  
801f				ld a, (.dmark)  
801f				ld (debug_mark),a  
801f				ld a, (.dmark+1)  
801f				ld (debug_mark+1),a  
801f				ld a, (.dmark+2)  
801f				ld (debug_mark+2),a  
801f				jr .pastdmark  
801f			.dmark: db str  
801f			.pastdmark: pop af  
801f			  
801f			endm  
801f			  
801f			  
801f			; macro to detect for stack imbalances  
801f			  
801f			include "stackimbal.asm"  
801f			; Macro and code to detect stock imbalances 
801f			 
801f			SPPUSH: equ 0 
801f			 
801f			; Add a stack frame which can be checked before return 
801f			 
801f			STACKFRAME: macro onoff frame1 frame2 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						; save current SP 
801f						exx 
801f			 
801f						ld de, frame1 
801f						ld a, d 
801f						ld hl, curframe 
801f						call hexout 
801f						ld a, e 
801f						ld hl, curframe+2 
801f						call hexout 
801f			  
801f						ld hl, frame1 
801f						push hl 
801f						ld hl, frame2 
801f						push hl 
801f						exx 
801f					endif 
801f					 
801f				endif 
801f			endm 
801f			 
801f			STACKFRAMECHK: macro onoff frame1 frame2 
801f			 
801f					 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						exx 
801f						; check stack frame SP 
801f			 
801f						ld hl, frame2 
801f						pop de   ; frame2 
801f			 
801f						call cmp16 
801f						jr nz, .spnosame 
801f						 
801f			 
801f						ld hl, frame1 
801f						pop de   ; frame1 
801f			 
801f						call cmp16 
801f						jr z, .spfrsame 
801f			 
801f						.spnosame: call showsperror 
801f			 
801f						.spfrsame: nop 
801f			 
801f						exx 
801f					endif 
801f					 
801f				endif 
801f			 
801f			 
801f			endm 
801f			 
801f			 
801f			; for a sub routine, wrap SP collection and comparisons 
801f			 
801f			; Usage: 
801f			; 
801f			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801f			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801f			 
801f			SAVESP: macro onoff storeword 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						; save current SP 
801f			 
801f						ld (store_sp+(storeword*4)), sp 
801f			 
801f					endif 
801f					 
801f				endif 
801f			 
801f			endm 
801f			 
801f			CHECKSP: macro onoff storeword 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f			 
801f						; save SP after last save 
801f				 
801f						ld (store_sp+(storeword*4)+2), sp 
801f			 
801f						push hl 
801f						ld hl, store_sp+(storeword*4) 
801f						call check_stack_sp  
801f						pop hl 
801f			 
801f			 
801f					endif 
801f					 
801f				endif 
801f			 
801f			endm 
801f			 
801f			if DEBUG_STACK_IMB 
801f			 
801f			check_stack_sp: 
801f					push de 
801f			 
801f					ld e, (hl) 
801f					inc hl 
801f					ld d, (hl) 
801f					inc hl 
801f			 
801f					push de 
801f			 
801f			 
801f					ld e, (hl) 
801f					inc hl 
801f					ld d, (hl) 
801f					inc hl 
801f			 
801f					pop hl 
801f			 
801f			 
801f					; check to see if the same 
801f			 
801f					call cmp16 
801f					jr z, .spsame 
801f			 
801f					; not same 
801f			 
801f					call showsperror 
801f			.spsame: 
801f			 
801f					pop de 
801f			 
801f					ret 
801f			 
801f			.sperr:  db "Stack imbalance",0 
801f			 
801f			 
801f			showsperror: 
801f			 
801f			 
801f				push hl 
801f				push af 
801f				push de 
801f				call clear_display 
801f				ld de, .sperr 
801f				ld a,0 
801f			;	ld de,os_word_scratch 
801f				call str_at_display 
801f				ld a, display_row_1+17 
801f				ld de, debug_mark 
801f				call str_at_display 
801f				ld a, 0 
801f				ld (curframe+4),a 
801f				ld hl, curframe 
801f				ld de, os_word_scratch 
801f				ld a, display_row_4 
801f				call str_at_display 
801f				call update_display 
801f				;call break_point_state 
801f				call cin_wait 
801f			 
801f			;	ld a, ' ' 
801f			;	ld (os_view_disable), a 
801f				call bp_on 
801f				pop de	 
801f				pop af 
801f				pop hl 
801f				CALLMONITOR 
801f				ret 
801f			 
801f			endif 
801f			 
801f			 
801f			 
801f			; eof 
# End of file stackimbal.asm
801f			  
801f			;TODO macro to calc col and row offset into screen  
801f			  
801f			  
801f			  
801f			hardware_init:  
801f			  
801f				  
801f			  
801f					;ld a, 0  
801f					;ld (hardware_diag), a  
801f			  
801f					; clear all the buffers  
801f			  
801f 21 10 ed				ld hl, display_fb1  
8022 22 cc eb				ld (display_fb_active), hl  
8025			  
8025 cd ba 8a				call clear_display  
8028			  
8028 21 ce eb				ld hl, display_fb2  
802b 22 cc eb				ld (display_fb_active), hl  
802e			  
802e cd ba 8a				call clear_display  
8031			  
8031					; init primary frame buffer area  
8031 21 b1 ed				ld hl, display_fb0  
8034 22 cc eb				ld (display_fb_active), hl  
8037			  
8037 cd ba 8a				call clear_display  
803a			  
803a			  
803a cd 6e dc				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803d			  
803d cd 10 dd			call key_init  
8040 cd aa 80			call storage_init  
8043			  
8043				; setup malloc functions  
8043			  
8043				if MALLOC_1  
8043 cd 9e 90				call  heap_init  
8046				endif  
8046				if MALLOC_4  
8046					call  heap_init  
8046				endif  
8046			  
8046				; init sound hardware if present  
8046			  
8046				if SOUND_ENABLE  
8046					call sound_init  
8046				endif  
8046			  
8046				; lcd test sequence  
8046					  
8046 cd dd 8a			call update_display  
8049 cd fd 89			call delay1s  
804c 3e 2b			ld a,'+'  
804e cd bf 8a			call fill_display  
8051 cd dd 8a			call update_display  
8054 cd fd 89			call delay1s  
8057 3e 2a			ld a,'*'  
8059 cd bf 8a			call fill_display  
805c cd dd 8a			call update_display  
805f cd fd 89			call delay1s  
8062 3e 2d			ld a,'-'  
8064 cd bf 8a			call fill_display  
8067 cd dd 8a			call update_display  
806a cd fd 89			call delay1s  
806d			  
806d			; boot splash screen  
806d			if display_cols == 20	  
806d			        ld a, display_row_1    
806d			else  
806d 3e 0a		        ld a, display_row_1 +10   
806f			endif  
806f 11 cc 95			ld de, prom_bootmsg  
8072 cd cd 8a			call str_at_display  
8075 cd dd 8a			call update_display  
8078			  
8078			  
8078 cd fd 89			call delay1s  
807b cd fd 89			call delay1s  
807e			if display_cols == 20	  
807e			            LD   A, display_row_3+2  
807e			else  
807e 3e 5c		            LD   A, display_row_3+12  
8080			endif  
8080 11 e1 95			ld de, prom_bootmsg1  
8083 cd cd 8a			call str_at_display  
8086			; display debug level  
8086 3e 78		            LD   A, display_row_4  
8088 11 1b 80			ld de, debuglevel  
808b cd cd 8a			call str_at_display  
808e			  
808e cd dd 8a			call update_display  
8091 cd fd 89			call delay1s  
8094 cd fd 89			call delay1s  
8097			  
8097			;	ld a, display_row_4+3  
8097			;	ld de, bootmsg2  
8097			;	call str_at_display  
8097			;	call update_display  
8097			;	call delay1s  
8097			;	call delay1s  
8097			  
8097			; debug mark setup  
8097			  
8097 3e 5f		ld a, '_'  
8099 32 6b ee		ld (debug_mark),a  
809c 32 6c ee		ld (debug_mark+1),a  
809f 32 6d ee		ld (debug_mark+2),a  
80a2 3e 00		ld a,0  
80a4 32 6e ee		ld (debug_mark+3),a  
80a7			  
80a7 c9					ret  
80a8			  
80a8			  
80a8			;bootmsg2:	db "Firmware v0.1",0  
80a8			  
80a8			; a 4x20 lcd  
80a8			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
80a8			  
80a8			;if display_cols == 20  
80a8			;	include "firmware_lcd_4x20.asm"  
80a8			;endif  
80a8			  
80a8			;if display_cols == 40  
80a8			;	include "firmware_lcd_4x40.asm"  
80a8			;endif  
80a8			  
80a8			;  
80a8			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
80a8			; TODO abstract the bit bang video out interface for dual display  
80a8			; TODO wire video out to tx pin on rc2014 bus  
80a8			  
80a8			; must supply cin, and cin_wait for low level hardware abstraction   
80a8			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
80a8			; test scancode  
80a8			  
80a8			;;;;;  
80a8			;;;  
80a8			; Moved out to mini and maxi versions  
80a8			;  
80a8			; include "firmware_key_4x4.asm"  
80a8			; using existing 4 wire x 4 resistor array for input  
80a8			;include "firmware_key_4x10.asm"  
80a8			; need to mod the board for 5 rows due to resistor array  
80a8			;include "firmware_key_5x10.asm"  
80a8			  
80a8			; storage hardware interface  
80a8			  
80a8			; use microchip serial eeprom for storage  
80a8			  
80a8			  
80a8			if STORAGE_SE  
80a8				include "firmware_spi.asm"  
80a8				include "firmware_seeprom.asm"  
80a8			else  
80a8			   ; create some stubs for the labels  
80a8 c9			se_readbyte: ret  
80a9 c9			se_writebyte: ret  
80aa c9			storage_init: ret  
80ab			  
80ab			endif  
80ab			  
80ab			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80ab			;include "firmware_cf.asm"  
80ab			  
80ab			; load up high level storage hardward abstractions  
80ab			include "firmware_storage.asm"  
80ab			 
80ab			; persisent storage hardware abstraction layer  
80ab			 
80ab			 
80ab			 
80ab			; Block 0 on storage is a config state 
80ab			 
80ab			 
80ab			 
80ab			; TODO add read phy block and write phy block functions 
80ab			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80ab			 
80ab			; Abstraction layer  
80ab			 
80ab			; Logocial block size is same size as physical size - using tape concept 
80ab			 
80ab			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80ab			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80ab			 
80ab			 
80ab			 
80ab			; Filesystem layout (Logical layout) 
80ab			; 
80ab			; Block 0 - Bank config  
80ab			; 
80ab			;      Byte - 0 file id counter 
80ab			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80ab			;      Byte - 3-20 zero terminated bank label 
80ab			; 
80ab			; Block 1 > File storage 
80ab			; 
80ab			;      Byte 0 file id    - block 0 file details 
80ab			;      Byte 1 block id - block 0 is file  
80ab			;            Byte 2-15 - File name 
80ab			; 
80ab			;       - to end of block data 
80ab			; 
80ab			 
80ab			; Get ID for the file named in pointer held HL 
80ab			; Returns ID in HL = 255 if no file found 
80ab			 
80ab			storage_getid: 
80ab			 
80ab 22 73 ea			ld (store_tmp1), hl 
80ae			 
80ae				if DEBUG_STORESE 
80ae					DMARK "SGI" 
80ae f5				push af  
80af 3a c3 80			ld a, (.dmark)  
80b2 32 6b ee			ld (debug_mark),a  
80b5 3a c4 80			ld a, (.dmark+1)  
80b8 32 6c ee			ld (debug_mark+1),a  
80bb 3a c5 80			ld a, (.dmark+2)  
80be 32 6d ee			ld (debug_mark+2),a  
80c1 18 03			jr .pastdmark  
80c3 ..			.dmark: db "SGI"  
80c6 f1			.pastdmark: pop af  
80c7			endm  
# End of macro DMARK
80c7					CALLMONITOR 
80c7 cd 6f ee			call debug_vector  
80ca				endm  
# End of macro CALLMONITOR
80ca				endif 
80ca				; get block 0 and set counter for number of files to scan 
80ca			 
80ca cd 35 82			call storage_get_block_0 
80cd			 
80cd 3a 7a ea			ld a, (store_page) 
80d0 47				ld b, a 
80d1			 
80d1				; get extent 0 of each file id 
80d1			 
80d1				if DEBUG_STORESE 
80d1					DMARK "SGc" 
80d1 f5				push af  
80d2 3a e6 80			ld a, (.dmark)  
80d5 32 6b ee			ld (debug_mark),a  
80d8 3a e7 80			ld a, (.dmark+1)  
80db 32 6c ee			ld (debug_mark+1),a  
80de 3a e8 80			ld a, (.dmark+2)  
80e1 32 6d ee			ld (debug_mark+2),a  
80e4 18 03			jr .pastdmark  
80e6 ..			.dmark: db "SGc"  
80e9 f1			.pastdmark: pop af  
80ea			endm  
# End of macro DMARK
80ea					CALLMONITOR 
80ea cd 6f ee			call debug_vector  
80ed				endm  
# End of macro CALLMONITOR
80ed				endif 
80ed 60			.getloop:	ld h, b 
80ee 2e 00				ld l, 0 
80f0 c5					push bc 
80f1			 
80f1 11 7a ea				ld de, store_page 
80f4				if DEBUG_STORESE 
80f4					DMARK "SGr" 
80f4 f5				push af  
80f5 3a 09 81			ld a, (.dmark)  
80f8 32 6b ee			ld (debug_mark),a  
80fb 3a 0a 81			ld a, (.dmark+1)  
80fe 32 6c ee			ld (debug_mark+1),a  
8101 3a 0b 81			ld a, (.dmark+2)  
8104 32 6d ee			ld (debug_mark+2),a  
8107 18 03			jr .pastdmark  
8109 ..			.dmark: db "SGr"  
810c f1			.pastdmark: pop af  
810d			endm  
# End of macro DMARK
810d					CALLMONITOR 
810d cd 6f ee			call debug_vector  
8110				endm  
# End of macro CALLMONITOR
8110				endif 
8110 cd dd 86				call storage_read 
8113 cd 10 8d				call ishlzero 
8116 28 2d				jr z, .gap 
8118					 
8118					; have a file name read. Is it one we want. 
8118			 
8118 2a 73 ea				ld hl, (store_tmp1) 
811b 11 7d ea				ld de, store_page+3   ; file name 
811e			 
811e				if DEBUG_STORESE 
811e					DMARK "SGc" 
811e f5				push af  
811f 3a 33 81			ld a, (.dmark)  
8122 32 6b ee			ld (debug_mark),a  
8125 3a 34 81			ld a, (.dmark+1)  
8128 32 6c ee			ld (debug_mark+1),a  
812b 3a 35 81			ld a, (.dmark+2)  
812e 32 6d ee			ld (debug_mark+2),a  
8131 18 03			jr .pastdmark  
8133 ..			.dmark: db "SGc"  
8136 f1			.pastdmark: pop af  
8137			endm  
# End of macro DMARK
8137					CALLMONITOR 
8137 cd 6f ee			call debug_vector  
813a				endm  
# End of macro CALLMONITOR
813a				endif 
813a cd 85 90				call strcmp 
813d 20 06				jr nz, .gap   ; not this one 
813f			 
813f c1				        pop bc 
8140			 
8140 26 00				ld h, 0 
8142 68					ld l, b 
8143 18 22				jr .getdone 
8145						 
8145			 
8145			 
8145			 
8145			.gap: 
8145				if DEBUG_STORESE 
8145					DMARK "SGg" 
8145 f5				push af  
8146 3a 5a 81			ld a, (.dmark)  
8149 32 6b ee			ld (debug_mark),a  
814c 3a 5b 81			ld a, (.dmark+1)  
814f 32 6c ee			ld (debug_mark+1),a  
8152 3a 5c 81			ld a, (.dmark+2)  
8155 32 6d ee			ld (debug_mark+2),a  
8158 18 03			jr .pastdmark  
815a ..			.dmark: db "SGg"  
815d f1			.pastdmark: pop af  
815e			endm  
# End of macro DMARK
815e					CALLMONITOR 
815e cd 6f ee			call debug_vector  
8161				endm  
# End of macro CALLMONITOR
8161				endif 
8161			 
8161 c1					pop bc 
8162 10 89				djnz .getloop 
8164 21 ff 00				ld hl, 255 
8167			.getdone: 
8167			 
8167				if DEBUG_STORESE 
8167					DMARK "SGe" 
8167 f5				push af  
8168 3a 7c 81			ld a, (.dmark)  
816b 32 6b ee			ld (debug_mark),a  
816e 3a 7d 81			ld a, (.dmark+1)  
8171 32 6c ee			ld (debug_mark+1),a  
8174 3a 7e 81			ld a, (.dmark+2)  
8177 32 6d ee			ld (debug_mark+2),a  
817a 18 03			jr .pastdmark  
817c ..			.dmark: db "SGe"  
817f f1			.pastdmark: pop af  
8180			endm  
# End of macro DMARK
8180					CALLMONITOR 
8180 cd 6f ee			call debug_vector  
8183				endm  
# End of macro CALLMONITOR
8183				endif 
8183			 
8183 c9				ret 
8184			 
8184			 
8184			 
8184			 
8184			 
8184			 
8184			 
8184			 
8184			; Read Block 
8184			; ---------- 
8184			; 
8184			; With current bank 
8184			;  
8184			; Get block number to read 
8184			; Load physical blocks starting at start block into buffer 
8184			 
8184			; de points to buffer to use 
8184			; hl holds logical block number  
8184			 
8184			storage_read_block: 
8184			 
8184				; TODO bank selection 
8184			 
8184				; for each of the physical blocks read it into the buffer 
8184 06 40			ld b, STORE_BLOCK_PHY 
8186			 
8186				if DEBUG_STORESE 
8186 d5					push de 
8187				endif 
8187				 
8187			.rl1:    
8187			 
8187				; read physical block at hl into de 
8187			        ; increment hl and de to next read position on exit 
8187			 
8187 e5				push hl 
8188 d5				push de	 
8189 c5				push bc 
818a			;	if DEBUG_STORESE 
818a			;		push af 
818a			;		ld a, 'R' 
818a			;		ld (debug_mark),a 
818a			;		pop af 
818a			;		CALLMONITOR 
818a			;	endif 
818a cd a8 80			call se_readbyte 
818d			;	if DEBUG_STORESE 
818d			;		ld a,(spi_portbyte) 
818d			;		ld l, a 
818d			;		push af 
818d			;		ld a, '1' 
818d			;		ld (debug_mark),a 
818d			;		pop af 
818d			;		CALLMONITOR 
818d			;	endif 
818d c1				pop bc 
818e d1				pop de 
818f e1				pop hl 
8190 12				ld (de),a 
8191 23				inc hl 
8192 13				inc de 
8193			 
8193			;	if DEBUG_STORESE 
8193			;		push af 
8193			;		ld a, 'r' 
8193			;		ld (debug_mark),a 
8193			;		pop af 
8193			;		CALLMONITOR 
8193			;	endif 
8193			 
8193 10 f2			djnz .rl1 
8195			 
8195				if DEBUG_STORESE 
8195					DMARK "SRB" 
8195 f5				push af  
8196 3a aa 81			ld a, (.dmark)  
8199 32 6b ee			ld (debug_mark),a  
819c 3a ab 81			ld a, (.dmark+1)  
819f 32 6c ee			ld (debug_mark+1),a  
81a2 3a ac 81			ld a, (.dmark+2)  
81a5 32 6d ee			ld (debug_mark+2),a  
81a8 18 03			jr .pastdmark  
81aa ..			.dmark: db "SRB"  
81ad f1			.pastdmark: pop af  
81ae			endm  
# End of macro DMARK
81ae d1					pop de 
81af			; 
81af			;		push af 
81af			;		ld a, 'R' 
81af			;		ld (debug_mark),a 
81af			;		pop af 
81af					CALLMONITOR 
81af cd 6f ee			call debug_vector  
81b2				endm  
# End of macro CALLMONITOR
81b2				endif 
81b2 c9				ret	 
81b3				 
81b3			 
81b3			; File Size 
81b3			; --------- 
81b3			; 
81b3			;   hl file id 
81b3			; 
81b3			;  returns in hl the number of blocks 
81b3			 
81b3			storage_file_size: 
81b3 5d				ld e, l 
81b4 16 00			ld d, 0 
81b6 21 40 00			ld hl, STORE_BLOCK_PHY 
81b9					if DEBUG_FORTH_WORDS 
81b9						DMARK "SIZ" 
81b9 f5				push af  
81ba 3a ce 81			ld a, (.dmark)  
81bd 32 6b ee			ld (debug_mark),a  
81c0 3a cf 81			ld a, (.dmark+1)  
81c3 32 6c ee			ld (debug_mark+1),a  
81c6 3a d0 81			ld a, (.dmark+2)  
81c9 32 6d ee			ld (debug_mark+2),a  
81cc 18 03			jr .pastdmark  
81ce ..			.dmark: db "SIZ"  
81d1 f1			.pastdmark: pop af  
81d2			endm  
# End of macro DMARK
81d2						CALLMONITOR 
81d2 cd 6f ee			call debug_vector  
81d5				endm  
# End of macro CALLMONITOR
81d5					endif 
81d5 cd b7 84			call storage_findnextid 
81d8			 
81d8 cd 10 8d			call ishlzero 
81db			;	ld a, l 
81db			;	add h 
81db			;	cp 0 
81db c8				ret z			; block not found so EOF 
81dc			 
81dc 11 7a ea			ld de, store_page 
81df cd 84 81			call storage_read_block 
81e2			 
81e2 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
81e5 6f				ld l, a 
81e6 26 00			ld h, 0 
81e8 c9			 	ret 
81e9			 
81e9			 
81e9			; Write Block 
81e9			; ----------- 
81e9			; 
81e9			; With current bank 
81e9			;  
81e9			; Get block number to write 
81e9			; Write physical blocks starting at start block from buffer 
81e9			  
81e9			storage_write_block: 
81e9				; TODO bank selection 
81e9			 
81e9				; for each of the physical blocks read it into the buffer 
81e9 06 40			ld b, STORE_BLOCK_PHY 
81eb			 
81eb				if DEBUG_STORESE 
81eb					DMARK "SWB" 
81eb f5				push af  
81ec 3a 00 82			ld a, (.dmark)  
81ef 32 6b ee			ld (debug_mark),a  
81f2 3a 01 82			ld a, (.dmark+1)  
81f5 32 6c ee			ld (debug_mark+1),a  
81f8 3a 02 82			ld a, (.dmark+2)  
81fb 32 6d ee			ld (debug_mark+2),a  
81fe 18 03			jr .pastdmark  
8200 ..			.dmark: db "SWB"  
8203 f1			.pastdmark: pop af  
8204			endm  
# End of macro DMARK
8204			 
8204					;push af 
8204					;ld a, 'W' 
8204					;ld (debug_mark),a 
8204					;pop af 
8204					CALLMONITOR 
8204 cd 6f ee			call debug_vector  
8207				endm  
# End of macro CALLMONITOR
8207				endif 
8207			 
8207			; might not be working 
8207			;	call se_writepage 
8207			 
8207			;	ret 
8207			; 
8207			 
8207			 
8207			 
8207			.wl1:    
8207			 
8207				; read physical block at hl into de 
8207			        ; increment hl and de to next read position on exit 
8207			 
8207 e5				push hl 
8208 d5				push de	 
8209 c5				push bc 
820a 1a				ld a,(de) 
820b				;if DEBUG_STORESE 
820b			;		push af 
820b			;		ld a, 'W' 
820b			;		ld (debug_mark),a 
820b			;		pop af 
820b			;		CALLMONITOR 
820b			;	endif 
820b cd a9 80			call se_writebyte 
820e			;	call delay250ms 
820e 00				nop 
820f 00				nop 
8210 00				nop 
8211			;	if DEBUG_STORESE 
8211			;		push af 
8211			;		ld a, 'w' 
8211			;		ld (debug_mark),a 
8211			;		pop af 
8211			;		CALLMONITOR 
8211			;	endif 
8211 c1				pop bc 
8212 d1				pop de 
8213 e1				pop hl 
8214 23				inc hl 
8215 13				inc de 
8216			 
8216			 
8216 10 ef			djnz .wl1 
8218			 
8218				if DEBUG_STORESE 
8218					DMARK "SW2" 
8218 f5				push af  
8219 3a 2d 82			ld a, (.dmark)  
821c 32 6b ee			ld (debug_mark),a  
821f 3a 2e 82			ld a, (.dmark+1)  
8222 32 6c ee			ld (debug_mark+1),a  
8225 3a 2f 82			ld a, (.dmark+2)  
8228 32 6d ee			ld (debug_mark+2),a  
822b 18 03			jr .pastdmark  
822d ..			.dmark: db "SW2"  
8230 f1			.pastdmark: pop af  
8231			endm  
# End of macro DMARK
8231			 
8231					;push af 
8231					;ld a, 'W' 
8231					;ld (debug_mark),a 
8231					;pop af 
8231					CALLMONITOR 
8231 cd 6f ee			call debug_vector  
8234				endm  
# End of macro CALLMONITOR
8234				endif 
8234 c9				ret	 
8235			 
8235			; Init bank 
8235			; --------- 
8235			; 
8235			; With current bank 
8235			; 
8235			; Setup block 0 config 
8235			;     Set 0 file id counter 
8235			;     Set formatted byte pattern 
8235			;     Zero out bank label 
8235			;      
8235			; For every logical block write 0-1 byte as null 
8235			 
8235			storage_get_block_0: 
8235			 
8235				; TODO check presence 
8235			 
8235				; get block 0 config 
8235			 
8235 21 00 00			ld hl, 0 
8238 11 7a ea			ld de, store_page 
823b cd 84 81			call storage_read_block 
823e			 
823e				if DEBUG_STORESE 
823e					DMARK "SB0" 
823e f5				push af  
823f 3a 53 82			ld a, (.dmark)  
8242 32 6b ee			ld (debug_mark),a  
8245 3a 54 82			ld a, (.dmark+1)  
8248 32 6c ee			ld (debug_mark+1),a  
824b 3a 55 82			ld a, (.dmark+2)  
824e 32 6d ee			ld (debug_mark+2),a  
8251 18 03			jr .pastdmark  
8253 ..			.dmark: db "SB0"  
8256 f1			.pastdmark: pop af  
8257			endm  
# End of macro DMARK
8257 11 7a ea				ld de, store_page 
825a			;		push af 
825a			;		ld a, 'i' 
825a			;		ld (debug_mark),a 
825a			;		pop af 
825a					CALLMONITOR 
825a cd 6f ee			call debug_vector  
825d				endm  
# End of macro CALLMONITOR
825d				endif 
825d			 
825d				; is this area formatted? 
825d			 
825d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
825d 2a 7b ea			ld hl, (store_page+1) 
8260 3e 80			ld a,0x80 
8262 bd				cp l 
8263 20 22			jr nz, .ininotformatted 
8265				; do a double check 
8265 3e 27			ld a, 0x27 
8267 bc				cp h 
8268 20 1d			jr nz, .ininotformatted 
826a			 
826a				; formatted then 
826a			 
826a				if DEBUG_STORESE 
826a					DMARK "SB1" 
826a f5				push af  
826b 3a 7f 82			ld a, (.dmark)  
826e 32 6b ee			ld (debug_mark),a  
8271 3a 80 82			ld a, (.dmark+1)  
8274 32 6c ee			ld (debug_mark+1),a  
8277 3a 81 82			ld a, (.dmark+2)  
827a 32 6d ee			ld (debug_mark+2),a  
827d 18 03			jr .pastdmark  
827f ..			.dmark: db "SB1"  
8282 f1			.pastdmark: pop af  
8283			endm  
# End of macro DMARK
8283					;push af 
8283					;ld a, 'I' 
8283					;ld (debug_mark),a 
8283					;pop af 
8283					CALLMONITOR 
8283 cd 6f ee			call debug_vector  
8286				endm  
# End of macro CALLMONITOR
8286				endif 
8286 c9				ret 
8287			 
8287			.ininotformatted: 
8287				; bank not formatted so poke various bits to make sure 
8287			 
8287				if DEBUG_STORESE 
8287					DMARK "SB2" 
8287 f5				push af  
8288 3a 9c 82			ld a, (.dmark)  
828b 32 6b ee			ld (debug_mark),a  
828e 3a 9d 82			ld a, (.dmark+1)  
8291 32 6c ee			ld (debug_mark+1),a  
8294 3a 9e 82			ld a, (.dmark+2)  
8297 32 6d ee			ld (debug_mark+2),a  
829a 18 03			jr .pastdmark  
829c ..			.dmark: db "SB2"  
829f f1			.pastdmark: pop af  
82a0			endm  
# End of macro DMARK
82a0					;push af 
82a0					;ld a, 'f' 
82a0					;ld (debug_mark),a 
82a0					;pop af 
82a0					CALLMONITOR 
82a0 cd 6f ee			call debug_vector  
82a3				endm  
# End of macro CALLMONITOR
82a3				endif 
82a3			 
82a3 cd c0 89			call storage_clear_page 
82a6			 
82a6 21 7a ea			ld hl, store_page 
82a9 3e 00			ld a, 0 
82ab				 
82ab 77				ld (hl),a   ; reset file counter 
82ac			 
82ac 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82af 22 7b ea		 	ld (store_page+1), hl	 
82b2			 
82b2				; set default label 
82b2			 
82b2 21 4e 83			ld hl, .defaultbanklabl 
82b5 11 7d ea		 	ld de, store_page+3 
82b8 01 0f 00			ld bc, 15 
82bb ed b0			ldir 
82bd			 
82bd				; Append the current bank id 
82bd 21 86 ea			ld hl, store_page+3+9 
82c0 3a 5f ea			ld a, (spi_device_id) 
82c3 77				ld (hl), a 
82c4			 
82c4				; save default page 0 
82c4			 
82c4 21 00 00			ld hl, 0 
82c7 11 7a ea			ld de, store_page 
82ca				if DEBUG_STORESE 
82ca					DMARK "SB3" 
82ca f5				push af  
82cb 3a df 82			ld a, (.dmark)  
82ce 32 6b ee			ld (debug_mark),a  
82d1 3a e0 82			ld a, (.dmark+1)  
82d4 32 6c ee			ld (debug_mark+1),a  
82d7 3a e1 82			ld a, (.dmark+2)  
82da 32 6d ee			ld (debug_mark+2),a  
82dd 18 03			jr .pastdmark  
82df ..			.dmark: db "SB3"  
82e2 f1			.pastdmark: pop af  
82e3			endm  
# End of macro DMARK
82e3			;		push af 
82e3			;		ld a, 'F' 
82e3			;		ld (debug_mark),a 
82e3			;		pop af 
82e3					CALLMONITOR 
82e3 cd 6f ee			call debug_vector  
82e6				endm  
# End of macro CALLMONITOR
82e6				endif 
82e6 cd e9 81			call storage_write_block 
82e9				if DEBUG_STORESE 
82e9					DMARK "SB4" 
82e9 f5				push af  
82ea 3a fe 82			ld a, (.dmark)  
82ed 32 6b ee			ld (debug_mark),a  
82f0 3a ff 82			ld a, (.dmark+1)  
82f3 32 6c ee			ld (debug_mark+1),a  
82f6 3a 00 83			ld a, (.dmark+2)  
82f9 32 6d ee			ld (debug_mark+2),a  
82fc 18 03			jr .pastdmark  
82fe ..			.dmark: db "SB4"  
8301 f1			.pastdmark: pop af  
8302			endm  
# End of macro DMARK
8302			;		push af 
8302			;		ld a, '>' 
8302			;		ld (debug_mark),a 
8302			;		pop af 
8302					CALLMONITOR 
8302 cd 6f ee			call debug_vector  
8305				endm  
# End of macro CALLMONITOR
8305				endif 
8305			 
8305 00				nop 
8306 00				nop 
8307 00				nop 
8308			 
8308				; now set 0 in every page to mark as a free block 
8308			 
8308 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
830a 21 40 00			ld hl, STORE_BLOCK_PHY 
830d			 
830d 3e 00		.setmark1:   	ld a,0 
830f e5					push hl 
8310 c5					push bc 
8311 cd a9 80				call se_writebyte 
8314 3e 0a			ld a, 10 
8316 cd e2 89			call aDelayInMS 
8319 23				inc hl 
831a cd a9 80				call se_writebyte 
831d 3e 0a			ld a, 10 
831f cd e2 89			call aDelayInMS 
8322 2b				dec hl 
8323 c1					pop bc 
8324 e1					pop hl 
8325 3e 40				ld a, STORE_BLOCK_PHY 
8327 cd e7 8c				call addatohl 
832a 10 e1				djnz .setmark1 
832c			 
832c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
832e 3e 00		.setmark2:   	ld a,0 
8330 e5					push hl 
8331 c5					push bc 
8332 cd a9 80				call se_writebyte 
8335 3e 0a			ld a, 10 
8337 cd e2 89			call aDelayInMS 
833a 23				inc hl 
833b cd a9 80				call se_writebyte 
833e 3e 0a			ld a, 10 
8340 cd e2 89			call aDelayInMS 
8343 2b				dec hl 
8344 c1					pop bc 
8345 e1					pop hl 
8346 3e 40				ld a, STORE_BLOCK_PHY 
8348 cd e7 8c				call addatohl 
834b 10 e1				djnz .setmark2 
834d			 
834d					 
834d			 
834d			 
834d c9				ret 
834e			 
834e			 
834e			 
834e			 
834e .. 00		.defaultbanklabl:   db "BankLabel_",0 
8359			 
8359			 
8359			 
8359			; Label Bank 
8359			; ---------- 
8359			; 
8359			; With current bank 
8359			; Read block 0 
8359			; Set label 
8359			; Write block 0 
8359			 
8359			; label str pointer in hl 
8359			 
8359			storage_label:     
8359			 
8359				if DEBUG_STORESE 
8359					DMARK "LBL" 
8359 f5				push af  
835a 3a 6e 83			ld a, (.dmark)  
835d 32 6b ee			ld (debug_mark),a  
8360 3a 6f 83			ld a, (.dmark+1)  
8363 32 6c ee			ld (debug_mark+1),a  
8366 3a 70 83			ld a, (.dmark+2)  
8369 32 6d ee			ld (debug_mark+2),a  
836c 18 03			jr .pastdmark  
836e ..			.dmark: db "LBL"  
8371 f1			.pastdmark: pop af  
8372			endm  
# End of macro DMARK
8372					CALLMONITOR 
8372 cd 6f ee			call debug_vector  
8375				endm  
# End of macro CALLMONITOR
8375				endif 
8375			 
8375 e5				push hl 
8376			 
8376 cd 35 82			call storage_get_block_0 
8379			 
8379				; set default label 
8379			 
8379 e1				pop hl 
837a			 
837a 11 7d ea		 	ld de, store_page+3 
837d 01 0f 00			ld bc, 15 
8380				if DEBUG_STORESE 
8380					DMARK "LB3" 
8380 f5				push af  
8381 3a 95 83			ld a, (.dmark)  
8384 32 6b ee			ld (debug_mark),a  
8387 3a 96 83			ld a, (.dmark+1)  
838a 32 6c ee			ld (debug_mark+1),a  
838d 3a 97 83			ld a, (.dmark+2)  
8390 32 6d ee			ld (debug_mark+2),a  
8393 18 03			jr .pastdmark  
8395 ..			.dmark: db "LB3"  
8398 f1			.pastdmark: pop af  
8399			endm  
# End of macro DMARK
8399					CALLMONITOR 
8399 cd 6f ee			call debug_vector  
839c				endm  
# End of macro CALLMONITOR
839c				endif 
839c ed b0			ldir 
839e				; save default page 0 
839e			 
839e 21 00 00			ld hl, 0 
83a1 11 7a ea			ld de, store_page 
83a4				if DEBUG_STORESE 
83a4					DMARK "LBW" 
83a4 f5				push af  
83a5 3a b9 83			ld a, (.dmark)  
83a8 32 6b ee			ld (debug_mark),a  
83ab 3a ba 83			ld a, (.dmark+1)  
83ae 32 6c ee			ld (debug_mark+1),a  
83b1 3a bb 83			ld a, (.dmark+2)  
83b4 32 6d ee			ld (debug_mark+2),a  
83b7 18 03			jr .pastdmark  
83b9 ..			.dmark: db "LBW"  
83bc f1			.pastdmark: pop af  
83bd			endm  
# End of macro DMARK
83bd					CALLMONITOR 
83bd cd 6f ee			call debug_vector  
83c0				endm  
# End of macro CALLMONITOR
83c0				endif 
83c0 cd e9 81			call storage_write_block 
83c3			 
83c3 c9				ret 
83c4			 
83c4			 
83c4			 
83c4			; Read Block 0 - Config 
83c4			; --------------------- 
83c4			; 
83c4			; With current bank 
83c4			; Call presence test 
83c4			;    If not present format/init bank  
83c4			; Read block 0  
83c4			;  
83c4			 
83c4			 
83c4			; Dir 
83c4			; --- 
83c4			; 
83c4			; With current bank 
83c4			; Load Block 0 Config 
83c4			; Get max file id number 
83c4			; For each logical block 
83c4			;    Read block read byte 2 
83c4			;      if first block of file 
83c4			;         Display file name 
83c4			;         Display type flags for file 
83c4			;        
83c4			 
83c4			; moving to words as this requires stack control 
83c4			 
83c4			 
83c4			; Delete File 
83c4			; ----------- 
83c4			; 
83c4			; With current bank 
83c4			; 
83c4			; Load Block 0 Config 
83c4			; Get max file id number 
83c4			; For each logical block 
83c4			;    Read block file id 
83c4			;      If first block of file and dont have file id 
83c4			;         if file to delete 
83c4			;         Save file id 
83c4			;         Null file id 
83c4			;         Write this block back 
83c4			;      If file id is one saved 
83c4			;         Null file id 
83c4			;         Write this block back 
83c4			 
83c4			 
83c4			.se_done: 
83c4 e1				pop hl 
83c5 c9				ret 
83c6			 
83c6			storage_erase: 
83c6			 
83c6				; hl contains the file id 
83c6			 
83c6 5d				ld e, l 
83c7 16 00			ld d, 0 
83c9 21 40 00			ld hl, STORE_BLOCK_PHY 
83cc					if DEBUG_FORTH_WORDS 
83cc						DMARK "ERA" 
83cc f5				push af  
83cd 3a e1 83			ld a, (.dmark)  
83d0 32 6b ee			ld (debug_mark),a  
83d3 3a e2 83			ld a, (.dmark+1)  
83d6 32 6c ee			ld (debug_mark+1),a  
83d9 3a e3 83			ld a, (.dmark+2)  
83dc 32 6d ee			ld (debug_mark+2),a  
83df 18 03			jr .pastdmark  
83e1 ..			.dmark: db "ERA"  
83e4 f1			.pastdmark: pop af  
83e5			endm  
# End of macro DMARK
83e5						CALLMONITOR 
83e5 cd 6f ee			call debug_vector  
83e8				endm  
# End of macro CALLMONITOR
83e8					endif 
83e8 cd b7 84			call storage_findnextid 
83eb cd 10 8d			call ishlzero 
83ee c8				ret z 
83ef			 
83ef e5				push hl 
83f0			 
83f0				; TODO check file not found 
83f0			 
83f0 11 7a ea			ld de, store_page 
83f3 cd 84 81			call storage_read_block 
83f6			 
83f6 cd 10 8d			call ishlzero 
83f9 ca c4 83			jp z,.se_done 
83fc			 
83fc					if DEBUG_FORTH_WORDS 
83fc						DMARK "ER1" 
83fc f5				push af  
83fd 3a 11 84			ld a, (.dmark)  
8400 32 6b ee			ld (debug_mark),a  
8403 3a 12 84			ld a, (.dmark+1)  
8406 32 6c ee			ld (debug_mark+1),a  
8409 3a 13 84			ld a, (.dmark+2)  
840c 32 6d ee			ld (debug_mark+2),a  
840f 18 03			jr .pastdmark  
8411 ..			.dmark: db "ER1"  
8414 f1			.pastdmark: pop af  
8415			endm  
# End of macro DMARK
8415						CALLMONITOR 
8415 cd 6f ee			call debug_vector  
8418				endm  
# End of macro CALLMONITOR
8418					endif 
8418 3a 7a ea			ld a, (store_page)	; get file id 
841b 32 6e ea			ld (store_tmpid), a 
841e			 
841e 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
8421 32 6d ea			ld (store_tmpext), a 
8424			 
8424				; wipe file header 
8424			 
8424 e1				pop hl 
8425 3e 00			ld a, 0 
8427 32 7a ea			ld (store_page), a 
842a 32 7b ea			ld (store_page+1),a 
842d 11 7a ea			ld de, store_page 
8430					if DEBUG_FORTH_WORDS 
8430						DMARK "ER2" 
8430 f5				push af  
8431 3a 45 84			ld a, (.dmark)  
8434 32 6b ee			ld (debug_mark),a  
8437 3a 46 84			ld a, (.dmark+1)  
843a 32 6c ee			ld (debug_mark+1),a  
843d 3a 47 84			ld a, (.dmark+2)  
8440 32 6d ee			ld (debug_mark+2),a  
8443 18 03			jr .pastdmark  
8445 ..			.dmark: db "ER2"  
8448 f1			.pastdmark: pop af  
8449			endm  
# End of macro DMARK
8449						CALLMONITOR 
8449 cd 6f ee			call debug_vector  
844c				endm  
# End of macro CALLMONITOR
844c					endif 
844c cd e9 81			call storage_write_block 
844f			 
844f			 
844f				; wipe file extents 
844f			 
844f 3a 6d ea			ld a, (store_tmpext) 
8452 47				ld b, a 
8453			 
8453			.eraext:	  
8453 c5				push bc 
8454			 
8454 21 40 00			ld hl, STORE_BLOCK_PHY 
8457 3a 6e ea			ld a,(store_tmpid) 
845a 5f				ld e, a 
845b 50				ld d, b	 
845c					if DEBUG_FORTH_WORDS 
845c						DMARK "ER3" 
845c f5				push af  
845d 3a 71 84			ld a, (.dmark)  
8460 32 6b ee			ld (debug_mark),a  
8463 3a 72 84			ld a, (.dmark+1)  
8466 32 6c ee			ld (debug_mark+1),a  
8469 3a 73 84			ld a, (.dmark+2)  
846c 32 6d ee			ld (debug_mark+2),a  
846f 18 03			jr .pastdmark  
8471 ..			.dmark: db "ER3"  
8474 f1			.pastdmark: pop af  
8475			endm  
# End of macro DMARK
8475						CALLMONITOR 
8475 cd 6f ee			call debug_vector  
8478				endm  
# End of macro CALLMONITOR
8478					endif 
8478 cd b7 84			call storage_findnextid 
847b cd 10 8d			call ishlzero 
847e ca c4 83			jp z,.se_done 
8481			 
8481 e5				push hl 
8482 11 7a ea			ld de, store_page 
8485 cd 84 81			call storage_read_block 
8488			 
8488				; free block	 
8488			 
8488 3e 00			ld a, 0 
848a 32 7a ea			ld (store_page), a 
848d 32 7b ea			ld (store_page+1),a 
8490 11 7a ea			ld de, store_page 
8493 e1				pop hl 
8494					if DEBUG_FORTH_WORDS 
8494						DMARK "ER4" 
8494 f5				push af  
8495 3a a9 84			ld a, (.dmark)  
8498 32 6b ee			ld (debug_mark),a  
849b 3a aa 84			ld a, (.dmark+1)  
849e 32 6c ee			ld (debug_mark+1),a  
84a1 3a ab 84			ld a, (.dmark+2)  
84a4 32 6d ee			ld (debug_mark+2),a  
84a7 18 03			jr .pastdmark  
84a9 ..			.dmark: db "ER4"  
84ac f1			.pastdmark: pop af  
84ad			endm  
# End of macro DMARK
84ad						CALLMONITOR 
84ad cd 6f ee			call debug_vector  
84b0				endm  
# End of macro CALLMONITOR
84b0					endif 
84b0 cd e9 81			call storage_write_block 
84b3			 
84b3 c1				pop bc 
84b4 10 9d			djnz .eraext 
84b6			 
84b6 c9				ret 
84b7			 
84b7			 
84b7			; Find Free Block 
84b7			; --------------- 
84b7			; 
84b7			; With current bank 
84b7			;  
84b7			; From given starting logical block 
84b7			;    Read block  
84b7			;    If no file id 
84b7			;         Return block id 
84b7			 
84b7			 
84b7			; hl starting page number 
84b7			; hl contains free page number or zero if no pages free 
84b7			; e contains the file id to locate 
84b7			; d contains the block number 
84b7			 
84b7			; TODO change to find file id and use zero for free block 
84b7			 
84b7			storage_findnextid: 
84b7			 
84b7				; now locate first 0 page to mark as a free block 
84b7			 
84b7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84b9			;	ld hl, STORE_BLOCK_PHY 
84b9			 
84b9					if DEBUG_FORTH_WORDS 
84b9					DMARK "FNI" 
84b9 f5				push af  
84ba 3a ce 84			ld a, (.dmark)  
84bd 32 6b ee			ld (debug_mark),a  
84c0 3a cf 84			ld a, (.dmark+1)  
84c3 32 6c ee			ld (debug_mark+1),a  
84c6 3a d0 84			ld a, (.dmark+2)  
84c9 32 6d ee			ld (debug_mark+2),a  
84cc 18 03			jr .pastdmark  
84ce ..			.dmark: db "FNI"  
84d1 f1			.pastdmark: pop af  
84d2			endm  
# End of macro DMARK
84d2						CALLMONITOR 
84d2 cd 6f ee			call debug_vector  
84d5				endm  
# End of macro CALLMONITOR
84d5					endif 
84d5			.ff1:   	 
84d5 e5					push hl 
84d6 c5					push bc 
84d7 d5					push de 
84d8 cd a8 80				call se_readbyte 
84db 5f					ld e,a 
84dc 23					inc hl 
84dd cd a8 80				call se_readbyte 
84e0 57					ld d, a 
84e1 e1					pop hl 
84e2 e5					push hl 
84e3 cd 05 8d				call cmp16 
84e6 28 49				jr z, .fffound 
84e8			 
84e8 d1					pop de 
84e9 c1					pop bc 
84ea e1					pop hl 
84eb			 
84eb					; is found? 
84eb					;cp e 
84eb					;ret z 
84eb			 
84eb 3e 40				ld a, STORE_BLOCK_PHY 
84ed cd e7 8c				call addatohl 
84f0 10 e3				djnz .ff1 
84f2			 
84f2 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84f4			.ff2:   	 
84f4			 
84f4 e5					push hl 
84f5 c5					push bc 
84f6 d5					push de 
84f7 cd a8 80				call se_readbyte 
84fa 5f					ld e,a 
84fb 23					inc hl 
84fc cd a8 80				call se_readbyte 
84ff 57					ld d, a 
8500			 
8500 e1					pop hl 
8501 e5					push hl 
8502 cd 05 8d				call cmp16 
8505 28 2a				jr z, .fffound 
8507			 
8507 d1					pop de 
8508 c1					pop bc 
8509 e1					pop hl 
850a					; is found? 
850a					;cp e 
850a					;ret z 
850a			 
850a 3e 40				ld a, STORE_BLOCK_PHY 
850c cd e7 8c				call addatohl 
850f 10 e3				djnz .ff2 
8511			 
8511			 
8511					if DEBUG_FORTH_WORDS 
8511					DMARK "FN-" 
8511 f5				push af  
8512 3a 26 85			ld a, (.dmark)  
8515 32 6b ee			ld (debug_mark),a  
8518 3a 27 85			ld a, (.dmark+1)  
851b 32 6c ee			ld (debug_mark+1),a  
851e 3a 28 85			ld a, (.dmark+2)  
8521 32 6d ee			ld (debug_mark+2),a  
8524 18 03			jr .pastdmark  
8526 ..			.dmark: db "FN-"  
8529 f1			.pastdmark: pop af  
852a			endm  
# End of macro DMARK
852a					;	push af 
852a					;	ld a, 'n' 
852a					;	ld (debug_mark),a 
852a					;	pop af 
852a						CALLMONITOR 
852a cd 6f ee			call debug_vector  
852d				endm  
# End of macro CALLMONITOR
852d					endif 
852d				; no free marks! 
852d 21 00 00				ld hl, 0 
8530 c9				ret 
8531			.fffound: 
8531				 
8531			 
8531 d1					pop de 
8532 c1					pop bc 
8533 e1					pop hl 
8534					if DEBUG_FORTH_WORDS 
8534					DMARK "FNF" 
8534 f5				push af  
8535 3a 49 85			ld a, (.dmark)  
8538 32 6b ee			ld (debug_mark),a  
853b 3a 4a 85			ld a, (.dmark+1)  
853e 32 6c ee			ld (debug_mark+1),a  
8541 3a 4b 85			ld a, (.dmark+2)  
8544 32 6d ee			ld (debug_mark+2),a  
8547 18 03			jr .pastdmark  
8549 ..			.dmark: db "FNF"  
854c f1			.pastdmark: pop af  
854d			endm  
# End of macro DMARK
854d					;	push af 
854d					;	ld a, 'n' 
854d					;	ld (debug_mark),a 
854d					;	pop af 
854d						CALLMONITOR 
854d cd 6f ee			call debug_vector  
8550				endm  
# End of macro CALLMONITOR
8550					endif 
8550 c9				ret 
8551			 
8551			 
8551			 
8551			; Free Space 
8551			; ---------- 
8551			; 
8551			; With current bank 
8551			; 
8551			; Set block count to zero 
8551			; Starting with first logical block 
8551			;      Find free block  
8551			;      If block id given, increment block count 
8551			; 
8551			;  
8551			 
8551			 
8551			; hl contains count of free blocks 
8551			 
8551			storage_freeblocks: 
8551			 
8551				; now locate first 0 page to mark as a free block 
8551			 
8551 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8553 21 40 00			ld hl, STORE_BLOCK_PHY 
8556 11 00 00			ld de, 0 
8559			 
8559			.fb1:   	 
8559 e5					push hl 
855a c5					push bc 
855b d5					push de 
855c cd a8 80				call se_readbyte 
855f d1					pop de 
8560 c1					pop bc 
8561 e1					pop hl 
8562			 
8562					; is free? 
8562 fe 00				cp 0 
8564 20 01				jr nz, .ff1cont 
8566 13					inc de 
8567			 
8567			.ff1cont: 
8567			 
8567			 
8567 3e 40				ld a, STORE_BLOCK_PHY 
8569 cd e7 8c				call addatohl 
856c 10 eb				djnz .fb1 
856e			 
856e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8570			.fb2:   	 
8570 e5					push hl 
8571 c5					push bc 
8572 d5					push de 
8573 cd a8 80				call se_readbyte 
8576 d1					pop de 
8577 c1					pop bc 
8578 e1					pop hl 
8579			 
8579					; is free? 
8579 fe 00				cp 0 
857b 20 01				jr nz, .ff2cont 
857d 13					inc de 
857e			 
857e			.ff2cont: 
857e			 
857e 3e 40				ld a, STORE_BLOCK_PHY 
8580 cd e7 8c				call addatohl 
8583 10 eb				djnz .fb2 
8585			 
8585 eb				ex de, hl 
8586 c9				ret 
8587			 
8587			; Get File ID 
8587			; ----------- 
8587			; 
8587			; With current bank 
8587			;  
8587			; Load Block 0 Config 
8587			; Get max file id number 
8587			; For each logical block 
8587			;    Read block file id 
8587			;      If first block of file and dont have file id 
8587			;         if file get id and exit 
8587			 
8587			 
8587			 
8587			 
8587			; Create File 
8587			; ----------- 
8587			; 
8587			; With current bank  
8587			; Load Block 0 Config 
8587			; Get max file id number 
8587			; Increment file id number 
8587			; Save Config 
8587			; Find free block 
8587			; Set buffer with file name and file id 
8587			; Write buffer to free block  
8587			 
8587			 
8587			; hl point to file name 
8587			; hl returns file id 
8587			 
8587			; file format: 
8587			; byte 0 - file id 
8587			; byte 1 - extent number 
8587			; byte 2-> data 
8587			 
8587			; format for extent number 0: 
8587			; 
8587			; byte 0 - file id 
8587			; byte 1 - extent 0 
8587			; byte 2 - extent count 
8587			; byte 3 -> file name and meta data 
8587			 
8587			 
8587			storage_create: 
8587				if DEBUG_STORESE 
8587					DMARK "SCR" 
8587 f5				push af  
8588 3a 9c 85			ld a, (.dmark)  
858b 32 6b ee			ld (debug_mark),a  
858e 3a 9d 85			ld a, (.dmark+1)  
8591 32 6c ee			ld (debug_mark+1),a  
8594 3a 9e 85			ld a, (.dmark+2)  
8597 32 6d ee			ld (debug_mark+2),a  
859a 18 03			jr .pastdmark  
859c ..			.dmark: db "SCR"  
859f f1			.pastdmark: pop af  
85a0			endm  
# End of macro DMARK
85a0					CALLMONITOR 
85a0 cd 6f ee			call debug_vector  
85a3				endm  
# End of macro CALLMONITOR
85a3				endif 
85a3			 
85a3 e5				push hl		; save file name pointer 
85a4			 
85a4 cd 35 82			call storage_get_block_0 
85a7			 
85a7 3a 7a ea			ld a,(store_page)	; get current file id 
85aa 3c				inc a 
85ab 32 7a ea			ld (store_page),a 
85ae				 
85ae 32 6e ea			ld (store_tmpid),a			; save id 
85b1			 
85b1 21 00 00			ld hl, 0 
85b4 11 7a ea			ld de, store_page 
85b7				if DEBUG_STORESE 
85b7					DMARK "SCw" 
85b7 f5				push af  
85b8 3a cc 85			ld a, (.dmark)  
85bb 32 6b ee			ld (debug_mark),a  
85be 3a cd 85			ld a, (.dmark+1)  
85c1 32 6c ee			ld (debug_mark+1),a  
85c4 3a ce 85			ld a, (.dmark+2)  
85c7 32 6d ee			ld (debug_mark+2),a  
85ca 18 03			jr .pastdmark  
85cc ..			.dmark: db "SCw"  
85cf f1			.pastdmark: pop af  
85d0			endm  
# End of macro DMARK
85d0					CALLMONITOR 
85d0 cd 6f ee			call debug_vector  
85d3				endm  
# End of macro CALLMONITOR
85d3				endif 
85d3 cd e9 81			call storage_write_block	 ; save update 
85d6			 
85d6				if DEBUG_STORESE 
85d6 11 7a ea				ld de, store_page 
85d9					DMARK "SCC" 
85d9 f5				push af  
85da 3a ee 85			ld a, (.dmark)  
85dd 32 6b ee			ld (debug_mark),a  
85e0 3a ef 85			ld a, (.dmark+1)  
85e3 32 6c ee			ld (debug_mark+1),a  
85e6 3a f0 85			ld a, (.dmark+2)  
85e9 32 6d ee			ld (debug_mark+2),a  
85ec 18 03			jr .pastdmark  
85ee ..			.dmark: db "SCC"  
85f1 f1			.pastdmark: pop af  
85f2			endm  
# End of macro DMARK
85f2					CALLMONITOR 
85f2 cd 6f ee			call debug_vector  
85f5				endm  
# End of macro CALLMONITOR
85f5				endif 
85f5				;  
85f5				 
85f5 21 40 00			ld hl, STORE_BLOCK_PHY 
85f8 11 00 00			ld de, 0 
85fb cd b7 84			call storage_findnextid 
85fe			 
85fe 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
8601			 
8601				; TODO detect 0 = no spare blocks 
8601			 
8601				; hl now contains the free page to use for the file header page 
8601			 
8601				if DEBUG_STORESE 
8601				DMARK "SCF" 
8601 f5				push af  
8602 3a 16 86			ld a, (.dmark)  
8605 32 6b ee			ld (debug_mark),a  
8608 3a 17 86			ld a, (.dmark+1)  
860b 32 6c ee			ld (debug_mark+1),a  
860e 3a 18 86			ld a, (.dmark+2)  
8611 32 6d ee			ld (debug_mark+2),a  
8614 18 03			jr .pastdmark  
8616 ..			.dmark: db "SCF"  
8619 f1			.pastdmark: pop af  
861a			endm  
# End of macro DMARK
861a					CALLMONITOR 
861a cd 6f ee			call debug_vector  
861d				endm  
# End of macro CALLMONITOR
861d				endif 
861d			 
861d 22 65 ea			ld (store_tmppageid), hl 
8620				 
8620 3a 6e ea			ld a,(store_tmpid)    ; get file id 
8623			;	ld a, (store_filecache)			; save to cache 
8623			 
8623 32 7a ea			ld (store_page),a    ; set page id 
8626 3e 00			ld a, 0			 ; extent 0 is file header 
8628 32 7b ea			ld (store_page+1), a   ; set file extent 
862b			 
862b 32 7c ea			ld (store_page+2), a   ; extent count for the file 
862e			 
862e			;	inc hl 		; init block 0 of file 
862e			;	inc hl   		; skip file and extent id 
862e			 ;       ld a, 0 
862e			;	ld (hl),a 
862e			;	ld a, (store_filecache+1)  	; save to cache 
862e			 
862e			;	inc hl    ; file name 
862e				 
862e				 
862e 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8631				if DEBUG_STORESE 
8631					DMARK "SCc" 
8631 f5				push af  
8632 3a 46 86			ld a, (.dmark)  
8635 32 6b ee			ld (debug_mark),a  
8638 3a 47 86			ld a, (.dmark+1)  
863b 32 6c ee			ld (debug_mark+1),a  
863e 3a 48 86			ld a, (.dmark+2)  
8641 32 6d ee			ld (debug_mark+2),a  
8644 18 03			jr .pastdmark  
8646 ..			.dmark: db "SCc"  
8649 f1			.pastdmark: pop af  
864a			endm  
# End of macro DMARK
864a					CALLMONITOR 
864a cd 6f ee			call debug_vector  
864d				endm  
# End of macro CALLMONITOR
864d				endif 
864d e1				pop hl    ; get zero term string 
864e e5				push hl 
864f 3e 00			ld a, 0 
8651 cd 58 90			call strlent 
8654 23				inc hl   ; cover zero term 
8655 06 00			ld b,0 
8657 4d				ld c,l 
8658 e1				pop hl 
8659				;ex de, hl 
8659				if DEBUG_STORESE 
8659					DMARK "SCa" 
8659 f5				push af  
865a 3a 6e 86			ld a, (.dmark)  
865d 32 6b ee			ld (debug_mark),a  
8660 3a 6f 86			ld a, (.dmark+1)  
8663 32 6c ee			ld (debug_mark+1),a  
8666 3a 70 86			ld a, (.dmark+2)  
8669 32 6d ee			ld (debug_mark+2),a  
866c 18 03			jr .pastdmark  
866e ..			.dmark: db "SCa"  
8671 f1			.pastdmark: pop af  
8672			endm  
# End of macro DMARK
8672					;push af 
8672					;ld a, 'a' 
8672					;ld (debug_mark),a 
8672					;pop af 
8672					CALLMONITOR 
8672 cd 6f ee			call debug_vector  
8675				endm  
# End of macro CALLMONITOR
8675				endif 
8675 ed b0			ldir    ; copy zero term string 
8677				if DEBUG_STORESE 
8677					DMARK "SCA" 
8677 f5				push af  
8678 3a 8c 86			ld a, (.dmark)  
867b 32 6b ee			ld (debug_mark),a  
867e 3a 8d 86			ld a, (.dmark+1)  
8681 32 6c ee			ld (debug_mark+1),a  
8684 3a 8e 86			ld a, (.dmark+2)  
8687 32 6d ee			ld (debug_mark+2),a  
868a 18 03			jr .pastdmark  
868c ..			.dmark: db "SCA"  
868f f1			.pastdmark: pop af  
8690			endm  
# End of macro DMARK
8690					CALLMONITOR 
8690 cd 6f ee			call debug_vector  
8693				endm  
# End of macro CALLMONITOR
8693				endif 
8693			 
8693				; write file header page 
8693			 
8693 2a 65 ea			ld hl,(store_tmppageid) 
8696 11 7a ea			ld de, store_page 
8699				if DEBUG_STORESE 
8699					DMARK "SCb" 
8699 f5				push af  
869a 3a ae 86			ld a, (.dmark)  
869d 32 6b ee			ld (debug_mark),a  
86a0 3a af 86			ld a, (.dmark+1)  
86a3 32 6c ee			ld (debug_mark+1),a  
86a6 3a b0 86			ld a, (.dmark+2)  
86a9 32 6d ee			ld (debug_mark+2),a  
86ac 18 03			jr .pastdmark  
86ae ..			.dmark: db "SCb"  
86b1 f1			.pastdmark: pop af  
86b2			endm  
# End of macro DMARK
86b2					;push af 
86b2					;ld a, 'b' 
86b2					;ld (debug_mark),a 
86b2					;pop af 
86b2					CALLMONITOR 
86b2 cd 6f ee			call debug_vector  
86b5				endm  
# End of macro CALLMONITOR
86b5				endif 
86b5 cd e9 81			call storage_write_block 
86b8			 
86b8 3a 6e ea			ld a, (store_tmpid) 
86bb 6f				ld l, a 
86bc 26 00			ld h,0 
86be				if DEBUG_STORESE 
86be					DMARK "SCz" 
86be f5				push af  
86bf 3a d3 86			ld a, (.dmark)  
86c2 32 6b ee			ld (debug_mark),a  
86c5 3a d4 86			ld a, (.dmark+1)  
86c8 32 6c ee			ld (debug_mark+1),a  
86cb 3a d5 86			ld a, (.dmark+2)  
86ce 32 6d ee			ld (debug_mark+2),a  
86d1 18 03			jr .pastdmark  
86d3 ..			.dmark: db "SCz"  
86d6 f1			.pastdmark: pop af  
86d7			endm  
# End of macro DMARK
86d7					CALLMONITOR 
86d7 cd 6f ee			call debug_vector  
86da				endm  
# End of macro CALLMONITOR
86da				endif 
86da c9				ret 
86db				 
86db			 
86db			 
86db			; 
86db			; Read File 
86db			; 
86db			; h - file id to locate 
86db			; l - extent to locate 
86db			; de - pointer to string to read into 
86db			; 
86db			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86db			 
86db			.sr_fail: 
86db d1				pop de 
86dc c9				ret 
86dd			 
86dd			storage_read: 
86dd			 
86dd			 
86dd d5				push de 
86de			 
86de			; TODO BUG the above push is it popped before the RET Z? 
86de			 
86de			; TODO how to handle multiple part blocks 
86de			 
86de				; locate file extent to read 
86de			 
86de 5c				ld e, h 
86df 55				ld d, l 
86e0			 
86e0			.srext: 
86e0 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
86e3 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86e7			 
86e7 21 40 00			ld hl, STORE_BLOCK_PHY 
86ea				if DEBUG_STORESE 
86ea					DMARK "sre" 
86ea f5				push af  
86eb 3a ff 86			ld a, (.dmark)  
86ee 32 6b ee			ld (debug_mark),a  
86f1 3a 00 87			ld a, (.dmark+1)  
86f4 32 6c ee			ld (debug_mark+1),a  
86f7 3a 01 87			ld a, (.dmark+2)  
86fa 32 6d ee			ld (debug_mark+2),a  
86fd 18 03			jr .pastdmark  
86ff ..			.dmark: db "sre"  
8702 f1			.pastdmark: pop af  
8703			endm  
# End of macro DMARK
8703					CALLMONITOR 
8703 cd 6f ee			call debug_vector  
8706				endm  
# End of macro CALLMONITOR
8706				endif 
8706 cd b7 84			call storage_findnextid 
8709			 
8709				if DEBUG_STORESE 
8709					DMARK "srf" 
8709 f5				push af  
870a 3a 1e 87			ld a, (.dmark)  
870d 32 6b ee			ld (debug_mark),a  
8710 3a 1f 87			ld a, (.dmark+1)  
8713 32 6c ee			ld (debug_mark+1),a  
8716 3a 20 87			ld a, (.dmark+2)  
8719 32 6d ee			ld (debug_mark+2),a  
871c 18 03			jr .pastdmark  
871e ..			.dmark: db "srf"  
8721 f1			.pastdmark: pop af  
8722			endm  
# End of macro DMARK
8722					CALLMONITOR 
8722 cd 6f ee			call debug_vector  
8725				endm  
# End of macro CALLMONITOR
8725				endif 
8725 cd 10 8d			call ishlzero 
8728			;	ld a, l 
8728			;	add h 
8728			;	cp 0 
8728 28 b1			jr z,.sr_fail			; block not found so EOF 
872a			 
872a				; save current address for use by higher level words etc 
872a			 
872a 22 6b ea			ld (store_openaddr),hl 
872d			 
872d			 
872d				; hl contains page number to load 
872d d1				pop de   ; get storage 
872e ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
8732 d5				push de 
8733				if DEBUG_STORESE 
8733					DMARK "srg" 
8733 f5				push af  
8734 3a 48 87			ld a, (.dmark)  
8737 32 6b ee			ld (debug_mark),a  
873a 3a 49 87			ld a, (.dmark+1)  
873d 32 6c ee			ld (debug_mark+1),a  
8740 3a 4a 87			ld a, (.dmark+2)  
8743 32 6d ee			ld (debug_mark+2),a  
8746 18 03			jr .pastdmark  
8748 ..			.dmark: db "srg"  
874b f1			.pastdmark: pop af  
874c			endm  
# End of macro DMARK
874c					CALLMONITOR 
874c cd 6f ee			call debug_vector  
874f				endm  
# End of macro CALLMONITOR
874f				endif 
874f cd 84 81			call storage_read_block 
8752			 
8752				; if this a continuation read??? 
8752			 
8752 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8755			 
8755 3e 3f			ld a, STORE_BLOCK_PHY-1 
8757 cd e7 8c			call addatohl 
875a 7e				ld a,(hl) 
875b fe 00			cp 0 
875d 28 02			jr z, .markiscont 
875f 3e ff			ld a, 255 
8761			 
8761			.markiscont: 
8761 32 6d ea			ld (store_readcont), a 
8764			 
8764				if DEBUG_STORESE 
8764					DMARK "srC" 
8764 f5				push af  
8765 3a 79 87			ld a, (.dmark)  
8768 32 6b ee			ld (debug_mark),a  
876b 3a 7a 87			ld a, (.dmark+1)  
876e 32 6c ee			ld (debug_mark+1),a  
8771 3a 7b 87			ld a, (.dmark+2)  
8774 32 6d ee			ld (debug_mark+2),a  
8777 18 03			jr .pastdmark  
8779 ..			.dmark: db "srC"  
877c f1			.pastdmark: pop af  
877d			endm  
# End of macro DMARK
877d					CALLMONITOR 
877d cd 6f ee			call debug_vector  
8780				endm  
# End of macro CALLMONITOR
8780				endif 
8780				; only short reads enabled 
8780			 
8780 3a 75 ea			ld a, (store_longread) 
8783 fe 00			cp 0 
8785 ca 52 88			jp z, .readdone 
8788			 
8788			; TODO if block has no zeros then need to read next block  
8788			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
8788			; check last byte of physical block. 
8788			; if not zero then the next block needs to be loaded 
8788			 
8788			 
8788 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
878b			 
878b 3e 3f			ld a, STORE_BLOCK_PHY-1 
878d cd e7 8c			call addatohl 
8790				;dec hl 
8790 7e				ld a,(hl) 
8791				if DEBUG_STORESE 
8791					DMARK "sr?" 
8791 f5				push af  
8792 3a a6 87			ld a, (.dmark)  
8795 32 6b ee			ld (debug_mark),a  
8798 3a a7 87			ld a, (.dmark+1)  
879b 32 6c ee			ld (debug_mark+1),a  
879e 3a a8 87			ld a, (.dmark+2)  
87a1 32 6d ee			ld (debug_mark+2),a  
87a4 18 03			jr .pastdmark  
87a6 ..			.dmark: db "sr?"  
87a9 f1			.pastdmark: pop af  
87aa			endm  
# End of macro DMARK
87aa					CALLMONITOR 
87aa cd 6f ee			call debug_vector  
87ad				endm  
# End of macro CALLMONITOR
87ad				endif 
87ad fe 00			cp 0 
87af ca 52 88			jp z, .readdone 
87b2			 
87b2				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87b2			 
87b2 23				inc hl 
87b3			 
87b3 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87b6			 
87b6 ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
87ba			 
87ba eb				ex de, hl 
87bb			 
87bb				; next ext 
87bb			 
87bb 23				inc hl 
87bc 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
87bf			 
87bf				if DEBUG_STORESE 
87bf					DMARK "sF2" 
87bf f5				push af  
87c0 3a d4 87			ld a, (.dmark)  
87c3 32 6b ee			ld (debug_mark),a  
87c6 3a d5 87			ld a, (.dmark+1)  
87c9 32 6c ee			ld (debug_mark+1),a  
87cc 3a d6 87			ld a, (.dmark+2)  
87cf 32 6d ee			ld (debug_mark+2),a  
87d2 18 03			jr .pastdmark  
87d4 ..			.dmark: db "sF2"  
87d7 f1			.pastdmark: pop af  
87d8			endm  
# End of macro DMARK
87d8					CALLMONITOR 
87d8 cd 6f ee			call debug_vector  
87db				endm  
# End of macro CALLMONITOR
87db				endif 
87db			 
87db				; get and load block 
87db			 
87db cd b7 84			call storage_findnextid 
87de			 
87de				if DEBUG_STORESE 
87de					DMARK "sf2" 
87de f5				push af  
87df 3a f3 87			ld a, (.dmark)  
87e2 32 6b ee			ld (debug_mark),a  
87e5 3a f4 87			ld a, (.dmark+1)  
87e8 32 6c ee			ld (debug_mark+1),a  
87eb 3a f5 87			ld a, (.dmark+2)  
87ee 32 6d ee			ld (debug_mark+2),a  
87f1 18 03			jr .pastdmark  
87f3 ..			.dmark: db "sf2"  
87f6 f1			.pastdmark: pop af  
87f7			endm  
# End of macro DMARK
87f7					CALLMONITOR 
87f7 cd 6f ee			call debug_vector  
87fa				endm  
# End of macro CALLMONITOR
87fa				endif 
87fa cd 10 8d			call ishlzero 
87fd			;	ld a, l 
87fd			;	add h 
87fd			;	cp 0 
87fd ca db 86			jp z,.sr_fail			; block not found so EOF 
8800				 
8800				; save current address for use by higher level words etc 
8800			 
8800 22 6b ea			ld (store_openaddr),hl 
8803			 
8803 cd 84 81			call storage_read_block 
8806			 
8806				; on a continuation block, we now have the file id and ext in the middle of the block 
8806				; we need to pull everything back  
8806			 
8806 ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
880a 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
880d 23				inc hl 
880e 23				inc hl     ; skip id and ext 
880f 01 40 00			ld bc, STORE_BLOCK_PHY 
8812				if DEBUG_STORESE 
8812					DMARK "SR<" 
8812 f5				push af  
8813 3a 27 88			ld a, (.dmark)  
8816 32 6b ee			ld (debug_mark),a  
8819 3a 28 88			ld a, (.dmark+1)  
881c 32 6c ee			ld (debug_mark+1),a  
881f 3a 29 88			ld a, (.dmark+2)  
8822 32 6d ee			ld (debug_mark+2),a  
8825 18 03			jr .pastdmark  
8827 ..			.dmark: db "SR<"  
882a f1			.pastdmark: pop af  
882b			endm  
# End of macro DMARK
882b					CALLMONITOR 
882b cd 6f ee			call debug_vector  
882e				endm  
# End of macro CALLMONITOR
882e				endif 
882e ed b0			ldir     ; copy data 
8830			 
8830				; move the pointer back and pretend we have a full buffer for next recheck 
8830			 
8830 1b				dec de 
8831 1b				dec de 
8832			 
8832			; TODO do pop below now short circuit loop????? 
8832 c1				pop bc     ; get rid of spare de on stack 
8833				if DEBUG_STORESE 
8833					DMARK "SR>" 
8833 f5				push af  
8834 3a 48 88			ld a, (.dmark)  
8837 32 6b ee			ld (debug_mark),a  
883a 3a 49 88			ld a, (.dmark+1)  
883d 32 6c ee			ld (debug_mark+1),a  
8840 3a 4a 88			ld a, (.dmark+2)  
8843 32 6d ee			ld (debug_mark+2),a  
8846 18 03			jr .pastdmark  
8848 ..			.dmark: db "SR>"  
884b f1			.pastdmark: pop af  
884c			endm  
# End of macro DMARK
884c					CALLMONITOR 
884c cd 6f ee			call debug_vector  
884f				endm  
# End of macro CALLMONITOR
884f				endif 
884f c3 e0 86			jp .srext 
8852			 
8852			 
8852			 
8852			 
8852			 
8852			.readdone:		 
8852 e1				pop hl 		 ; return start of data to show as not EOF 
8853 23				inc hl   ; past file id 
8854 23				inc hl   ; past ext 
8855				if DEBUG_STORESE 
8855					DMARK "SRe" 
8855 f5				push af  
8856 3a 6a 88			ld a, (.dmark)  
8859 32 6b ee			ld (debug_mark),a  
885c 3a 6b 88			ld a, (.dmark+1)  
885f 32 6c ee			ld (debug_mark+1),a  
8862 3a 6c 88			ld a, (.dmark+2)  
8865 32 6d ee			ld (debug_mark+2),a  
8868 18 03			jr .pastdmark  
886a ..			.dmark: db "SRe"  
886d f1			.pastdmark: pop af  
886e			endm  
# End of macro DMARK
886e					CALLMONITOR 
886e cd 6f ee			call debug_vector  
8871				endm  
# End of macro CALLMONITOR
8871				endif 
8871 c9					ret 
8872			 
8872			 
8872			 
8872			; 
8872			; Append File 
8872			; 
8872			; hl - file id to locate 
8872			; de - pointer to (multi block) string to write 
8872			 
8872			.sa_notfound: 
8872 d1				pop de 
8873 c9				ret 
8874			 
8874			 
8874			storage_append: 
8874				; hl -  file id to append to 
8874				; de - string to append 
8874			 
8874 d5				push de 
8875				 
8875				if DEBUG_STORESE 
8875					DMARK "AP1" 
8875 f5				push af  
8876 3a 8a 88			ld a, (.dmark)  
8879 32 6b ee			ld (debug_mark),a  
887c 3a 8b 88			ld a, (.dmark+1)  
887f 32 6c ee			ld (debug_mark+1),a  
8882 3a 8c 88			ld a, (.dmark+2)  
8885 32 6d ee			ld (debug_mark+2),a  
8888 18 03			jr .pastdmark  
888a ..			.dmark: db "AP1"  
888d f1			.pastdmark: pop af  
888e			endm  
# End of macro DMARK
888e					CALLMONITOR 
888e cd 6f ee			call debug_vector  
8891				endm  
# End of macro CALLMONITOR
8891				endif 
8891			 
8891 7d				ld a, l 
8892 32 6e ea			ld (store_tmpid), a 
8895			 
8895				; get file header  
8895			 
8895 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
8897 3a 6e ea			ld a, (store_tmpid) 
889a 5f				ld e, a 
889b			 
889b 21 40 00				ld hl, STORE_BLOCK_PHY 
889e cd b7 84				call storage_findnextid 
88a1			 
88a1 cd 10 8d			call ishlzero 
88a4 28 cc			jr z, .sa_notfound 
88a6			 
88a6 22 65 ea			ld (store_tmppageid), hl 
88a9			 
88a9				; TODO handle file id not found 
88a9			 
88a9				if DEBUG_STORESE 
88a9					DMARK "AP2" 
88a9 f5				push af  
88aa 3a be 88			ld a, (.dmark)  
88ad 32 6b ee			ld (debug_mark),a  
88b0 3a bf 88			ld a, (.dmark+1)  
88b3 32 6c ee			ld (debug_mark+1),a  
88b6 3a c0 88			ld a, (.dmark+2)  
88b9 32 6d ee			ld (debug_mark+2),a  
88bc 18 03			jr .pastdmark  
88be ..			.dmark: db "AP2"  
88c1 f1			.pastdmark: pop af  
88c2			endm  
# End of macro DMARK
88c2					CALLMONITOR 
88c2 cd 6f ee			call debug_vector  
88c5				endm  
# End of macro CALLMONITOR
88c5				endif 
88c5			 
88c5				; update file extent count 
88c5			 
88c5 11 7a ea			ld de, store_page 
88c8			 
88c8 cd 84 81			call storage_read_block 
88cb			 
88cb				if DEBUG_STORESE 
88cb					DMARK "AP3" 
88cb f5				push af  
88cc 3a e0 88			ld a, (.dmark)  
88cf 32 6b ee			ld (debug_mark),a  
88d2 3a e1 88			ld a, (.dmark+1)  
88d5 32 6c ee			ld (debug_mark+1),a  
88d8 3a e2 88			ld a, (.dmark+2)  
88db 32 6d ee			ld (debug_mark+2),a  
88de 18 03			jr .pastdmark  
88e0 ..			.dmark: db "AP3"  
88e3 f1			.pastdmark: pop af  
88e4			endm  
# End of macro DMARK
88e4					CALLMONITOR 
88e4 cd 6f ee			call debug_vector  
88e7				endm  
# End of macro CALLMONITOR
88e7				endif 
88e7			;	ld (store_tmppageid), hl 
88e7			 
88e7 3a 7c ea			ld a, (store_page+2) 
88ea 3c				inc a 
88eb 32 7c ea			ld (store_page+2), a 
88ee 32 6d ea			ld (store_tmpext), a 
88f1				 
88f1				if DEBUG_STORESE 
88f1					DMARK "AP3" 
88f1 f5				push af  
88f2 3a 06 89			ld a, (.dmark)  
88f5 32 6b ee			ld (debug_mark),a  
88f8 3a 07 89			ld a, (.dmark+1)  
88fb 32 6c ee			ld (debug_mark+1),a  
88fe 3a 08 89			ld a, (.dmark+2)  
8901 32 6d ee			ld (debug_mark+2),a  
8904 18 03			jr .pastdmark  
8906 ..			.dmark: db "AP3"  
8909 f1			.pastdmark: pop af  
890a			endm  
# End of macro DMARK
890a					CALLMONITOR 
890a cd 6f ee			call debug_vector  
890d				endm  
# End of macro CALLMONITOR
890d				endif 
890d 2a 65 ea			ld hl, (store_tmppageid) 
8910 11 7a ea			ld de, store_page 
8913 cd e9 81			call storage_write_block 
8916			 
8916				; find free block 
8916			 
8916 11 00 00			ld de, 0			 ; file extent to locate 
8919			 
8919 21 40 00				ld hl, STORE_BLOCK_PHY 
891c cd b7 84				call storage_findnextid 
891f cd 10 8d			call ishlzero 
8922 ca 72 88			jp z, .sa_notfound 
8925			 
8925					; TODO handle no space left 
8925					 
8925 22 65 ea				ld (store_tmppageid), hl 
8928			 
8928				if DEBUG_STORESE 
8928					DMARK "AP4" 
8928 f5				push af  
8929 3a 3d 89			ld a, (.dmark)  
892c 32 6b ee			ld (debug_mark),a  
892f 3a 3e 89			ld a, (.dmark+1)  
8932 32 6c ee			ld (debug_mark+1),a  
8935 3a 3f 89			ld a, (.dmark+2)  
8938 32 6d ee			ld (debug_mark+2),a  
893b 18 03			jr .pastdmark  
893d ..			.dmark: db "AP4"  
8940 f1			.pastdmark: pop af  
8941			endm  
# End of macro DMARK
8941					CALLMONITOR 
8941 cd 6f ee			call debug_vector  
8944				endm  
# End of macro CALLMONITOR
8944				endif 
8944					; init the buffer with zeros so we can id if the buffer is full or not 
8944			 
8944 e5					push hl 
8945 c5					push bc 
8946			 
8946 21 7a ea				ld hl, store_page 
8949 06 40				ld b, STORE_BLOCK_PHY 
894b 3e 00				ld a, 0 
894d 77			.zeroblock:	ld (hl), a 
894e 23					inc hl 
894f 10 fc				djnz .zeroblock 
8951			 
8951 c1					pop bc 
8952 e1					pop hl 
8953			 
8953					; construct block 
8953			 
8953 3a 6e ea				ld a, (store_tmpid) 
8956 32 7a ea				ld (store_page), a   ; file id 
8959 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
895c 32 7b ea				ld (store_page+1), a 
895f			 
895f e1					pop hl    ; get string to write 
8960 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8962 11 7c ea				ld de, store_page+2 
8965			 
8965				if DEBUG_STORESE 
8965					DMARK "AP5" 
8965 f5				push af  
8966 3a 7a 89			ld a, (.dmark)  
8969 32 6b ee			ld (debug_mark),a  
896c 3a 7b 89			ld a, (.dmark+1)  
896f 32 6c ee			ld (debug_mark+1),a  
8972 3a 7c 89			ld a, (.dmark+2)  
8975 32 6d ee			ld (debug_mark+2),a  
8978 18 03			jr .pastdmark  
897a ..			.dmark: db "AP5"  
897d f1			.pastdmark: pop af  
897e			endm  
# End of macro DMARK
897e					CALLMONITOR 
897e cd 6f ee			call debug_vector  
8981				endm  
# End of macro CALLMONITOR
8981				endif 
8981			 
8981			 
8981			 
8981					; fill buffer with data until end of string or full block 
8981			 
8981 7e			.appd:		ld a, (hl) 
8982 12					ld (de), a 
8983 fe 00				cp 0 
8985 28 04				jr z, .appdone 
8987 23					inc hl 
8988 13					inc de 
8989 10 f6				djnz .appd 
898b			 
898b e5			.appdone:	push hl		 	; save current source in case we need to go around again 
898c f5					push af   		; save last byte dumped 
898d			 
898d			 
898d 2a 65 ea			ld hl, (store_tmppageid) 
8990 11 7a ea			ld de, store_page 
8993				if DEBUG_STORESE 
8993					DMARK "AP6" 
8993 f5				push af  
8994 3a a8 89			ld a, (.dmark)  
8997 32 6b ee			ld (debug_mark),a  
899a 3a a9 89			ld a, (.dmark+1)  
899d 32 6c ee			ld (debug_mark+1),a  
89a0 3a aa 89			ld a, (.dmark+2)  
89a3 32 6d ee			ld (debug_mark+2),a  
89a6 18 03			jr .pastdmark  
89a8 ..			.dmark: db "AP6"  
89ab f1			.pastdmark: pop af  
89ac			endm  
# End of macro DMARK
89ac					CALLMONITOR 
89ac cd 6f ee			call debug_vector  
89af				endm  
# End of macro CALLMONITOR
89af				endif 
89af cd e9 81				call storage_write_block 
89b2			 
89b2			 
89b2				; was that a full block of data written? 
89b2				; any more to write out? 
89b2			 
89b2				; if yes then set vars and jump to start of function again 
89b2			 
89b2 f1					pop af 
89b3 d1					pop de 
89b4			 
89b4 fe 00				cp 0		 ; no, string was fully written 
89b6 c8					ret z 
89b7			 
89b7					; setup vars for next cycle 
89b7			 
89b7 3a 6e ea				ld a, (store_tmpid) 
89ba 6f					ld l, a 
89bb 26 00				ld h, 0 
89bd			 
89bd c3 74 88			 	jp storage_append	 ; yes, need to write out some more 
89c0			 
89c0			 
89c0			 
89c0			 
89c0			 
89c0			 
89c0			 
89c0			if DEBUG_STORECF 
89c0			storageput:	 
89c0					ret 
89c0			storageread: 
89c0					ld hl, store_page 
89c0					ld b, 200 
89c0					ld a,0 
89c0			.src:		ld (hl),a 
89c0					inc hl 
89c0					djnz .src 
89c0					 
89c0			 
89c0					ld de, 0 
89c0					ld bc, 1 
89c0					ld hl, store_page 
89c0					call cfRead 
89c0			 
89c0				call cfGetError 
89c0				ld hl,scratch 
89c0				call hexout 
89c0				ld hl, scratch+2 
89c0				ld a, 0 
89c0				ld (hl),a 
89c0				ld de, scratch 
89c0				ld a,display_row_1 
89c0				call str_at_display 
89c0				call update_display 
89c0			 
89c0					ld hl, store_page 
89c0					ld (os_cur_ptr),hl 
89c0			 
89c0					ret 
89c0			endif 
89c0			 
89c0			 
89c0			; Clear out the main buffer store (used to remove junk before writing a new block) 
89c0			 
89c0			storage_clear_page: 
89c0 e5				push hl 
89c1 d5				push de 
89c2 c5				push bc 
89c3 21 7a ea			ld hl, store_page 
89c6 3e 00			ld a, 0 
89c8 77				ld (hl), a 
89c9			 
89c9 11 7b ea			ld de, store_page+1 
89cc 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89cf			 
89cf ed b0			ldir 
89d1				 
89d1 c1				pop bc 
89d2 d1				pop de 
89d3 e1				pop hl 
89d4 c9				ret 
89d5			 
89d5			; eof 
# End of file firmware_storage.asm
89d5			  
89d5			; support routines for above hardware abstraction layer  
89d5			  
89d5			include "firmware_general.asm"        ; general support functions  
89d5			 
89d5			; word look up 
89d5			 
89d5			; in 
89d5			; a is the index 
89d5			; hl is pointer start of array 
89d5			; 
89d5			; returns 
89d5			; hl to the word 
89d5			; 
89d5			 
89d5			table_lookup:  
89d5 d5					push de 
89d6 eb					ex de, hl 
89d7			 
89d7 6f					ld l, a 
89d8 26 00				ld h, 0 
89da 29					add hl, hl 
89db 19					add hl, de 
89dc 7e					ld a, (hl) 
89dd 23					inc hl 
89de 66					ld h,(hl) 
89df 6f					ld l, a 
89e0			 
89e0 d1					pop de 
89e1 c9					ret 
89e2			 
89e2			; Delay loops 
89e2			 
89e2			 
89e2			 
89e2			aDelayInMS: 
89e2 c5				push bc 
89e3 47				ld b,a 
89e4			msdelay: 
89e4 c5				push bc 
89e5				 
89e5			 
89e5 01 41 00			ld bc,041h 
89e8 cd 00 8a			call delayloop 
89eb c1				pop bc 
89ec 05				dec b 
89ed 20 f5			jr nz,msdelay 
89ef			 
89ef			;if CPU_CLOCK_8MHZ 
89ef			;msdelay8: 
89ef			;	push bc 
89ef			;	 
89ef			; 
89ef			;	ld bc,041h 
89ef			;	call delayloop 
89ef			;	pop bc 
89ef			;	dec b 
89ef			;	jr nz,msdelay8 
89ef			;endif 
89ef			 
89ef			 
89ef c1				pop bc 
89f0 c9				ret 
89f1			 
89f1			 
89f1			delay250ms: 
89f1				;push de 
89f1 01 00 40			ld bc, 04000h 
89f4 c3 00 8a			jp delayloop 
89f7			delay500ms: 
89f7				;push de 
89f7 01 00 80			ld bc, 08000h 
89fa c3 00 8a			jp delayloop 
89fd			delay1s: 
89fd				;push bc 
89fd			   ; Clobbers A, d and e 
89fd 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
8a00			delayloop: 
8a00 c5			    push bc 
8a01			 
8a01			if BASE_CPM 
8a01				ld bc, CPM_DELAY_TUNE 
8a01			.cpmloop: 
8a01				push bc 
8a01			 
8a01			endif 
8a01			 
8a01			 
8a01			 
8a01			delayloopi: 
8a01			;	push bc 
8a01			;.dl: 
8a01 cb 47		    bit     0,a    	; 8 
8a03 cb 47		    bit     0,a    	; 8 
8a05 cb 47		    bit     0,a    	; 8 
8a07 e6 ff		    and     255  	; 7 
8a09 0b			    dec     bc      	; 6 
8a0a 79			    ld      a,c     	; 4 
8a0b b0			    or      b     	; 4 
8a0c c2 01 8a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a0f			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a0f				;pop de 
8a0f			;pop bc 
8a0f			 
8a0f			if BASE_CPM 
8a0f				pop bc 
8a0f				 
8a0f			    dec     bc      	; 6 
8a0f			    ld      a,c     	; 4 
8a0f			    or      b     	; 4 
8a0f			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a0f				 
8a0f			 
8a0f			endif 
8a0f			;if CPU_CLOCK_8MHZ 
8a0f			;    pop bc 
8a0f			;    push bc 
8a0f			;.dl8: 
8a0f			;    bit     0,a    	; 8 
8a0f			;    bit     0,a    	; 8 
8a0f			;    bit     0,a    	; 8 
8a0f			;    and     255  	; 7 
8a0f			;    dec     bc      	; 6 
8a0f			;    ld      a,c     	; 4 
8a0f			;    or      b     	; 4 
8a0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a0f			;endif 
8a0f			 
8a0f			;if CPU_CLOCK_10MHZ 
8a0f			;    pop bc 
8a0f			;    push bc 
8a0f			;.dl8: 
8a0f			;    bit     0,a    	; 8 
8a0f			;    bit     0,a    	; 8 
8a0f			;    bit     0,a    	; 8 
8a0f			;    and     255  	; 7 
8a0f			;    dec     bc      	; 6 
8a0f			;    ld      a,c     	; 4 
8a0f			;    or      b     	; 4 
8a0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a0f			;endif 
8a0f c1			    pop bc 
8a10			 
8a10 c9				ret 
8a11			 
8a11			 
8a11			 
8a11			; eof 
# End of file firmware_general.asm
8a11			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a11			; display routines that use the physical hardware abstraction layer 
8a11			 
8a11			 
8a11			; Display an activity indicator 
8a11			; Each call returns the new char pointed to in hl 
8a11			 
8a11			active: 
8a11 3a c6 eb			ld a, (display_active) 
8a14 fe 06			cp 6 
8a16			 
8a16 20 02			jr nz, .sne 
8a18				; gone past the last one reset sequence 
8a18 3e ff			ld a, 255 
8a1a			 
8a1a			.sne:   
8a1a				; get the next char in seq 
8a1a 3c				inc a 
8a1b 32 c6 eb			ld (display_active), a 
8a1e			 
8a1e				; look up the string in the table 
8a1e 21 35 8a			ld hl, actseq 
8a21 cb 27			sla a 
8a23 cd e7 8c			call addatohl 
8a26 cd ab 9d			call loadwordinhl 
8a29			 
8a29				; forth will write the to string when pushing so move from rom to ram 
8a29			 
8a29 11 c7 eb			ld de, display_active+1 
8a2c 01 02 00			ld bc, 2 
8a2f ed b0			ldir 
8a31			 
8a31 21 c7 eb			ld hl, display_active+1 
8a34 c9				ret 
8a35				 
8a35				 
8a35			 
8a35			 
8a35			;db "|/-\|-\" 
8a35			 
8a35			actseq: 
8a35			 
8a35 43 8a		dw spin0 
8a37 45 8a		dw spin1 
8a39 47 8a		dw spin2 
8a3b 49 8a		dw spin3 
8a3d 47 8a		dw spin2 
8a3f 45 8a		dw spin1 
8a41 43 8a		dw spin0 
8a43			 
8a43 .. 00		spin0: db " ", 0 
8a45 .. 00		spin1: db "-", 0 
8a47 .. 00		spin2: db "+", 0 
8a49 .. 00		spin3: db "#", 0 
8a4b			 
8a4b			 
8a4b			; information window 
8a4b			 
8a4b			; pass hl with 1st string to display 
8a4b			; pass de with 2nd string to display 
8a4b			 
8a4b			info_panel: 
8a4b e5				push hl 
8a4c			 
8a4c 2a cc eb			ld hl, (display_fb_active) 
8a4f e5				push hl    ; future de destination 
8a50 21 b1 ed				ld hl, display_fb0 
8a53 22 cc eb				ld (display_fb_active), hl 
8a56			 
8a56			;	call clear_display 
8a56			 
8a56				if BASE_CPM 
8a56				ld a, '.' 
8a56				else 
8a56 3e a5			ld a, 165 
8a58				endif 
8a58 cd bf 8a			call fill_display 
8a5b			 
8a5b			 
8a5b 3e 55			ld a, display_row_3 + 5 
8a5d cd cd 8a			call str_at_display 
8a60			 
8a60 e1				pop hl 
8a61 d1				pop de 
8a62			 
8a62 e5				push hl 
8a63			 
8a63			 
8a63 3e 2d			ld a, display_row_2 + 5 
8a65 cd cd 8a			call str_at_display 
8a68			 
8a68			 
8a68 cd dd 8a			call update_display 
8a6b cd e6 99			call next_page_prompt 
8a6e cd ba 8a			call clear_display 
8a71			 
8a71				 
8a71 21 10 ed				ld hl, display_fb1 
8a74 22 cc eb				ld (display_fb_active), hl 
8a77 cd dd 8a			call update_display 
8a7a			 
8a7a e1				pop hl 
8a7b			 
8a7b c9				ret 
8a7c			 
8a7c			 
8a7c			 
8a7c			 
8a7c			; TODO windowing? 
8a7c			 
8a7c			; TODO scroll line up 
8a7c			 
8a7c			scroll_up: 
8a7c			 
8a7c e5				push hl 
8a7d d5				push de 
8a7e c5				push bc 
8a7f			 
8a7f				; get frame buffer  
8a7f			 
8a7f 2a cc eb			ld hl, (display_fb_active) 
8a82 e5				push hl    ; future de destination 
8a83			 
8a83 11 28 00			ld  de, display_cols 
8a86 19				add hl, de 
8a87			 
8a87 d1				pop de 
8a88			 
8a88				;ex de, hl 
8a88 01 9f 00			ld bc, display_fb_len -1  
8a8b			;if DEBUG_FORTH_WORDS 
8a8b			;	DMARK "SCL" 
8a8b			;	CALLMONITOR 
8a8b			;endif	 
8a8b ed b0			ldir 
8a8d			 
8a8d				; wipe bottom row 
8a8d			 
8a8d			 
8a8d 2a cc eb			ld hl, (display_fb_active) 
8a90 11 a0 00			ld de, display_cols*display_rows 
8a93 19				add hl, de 
8a94 06 28			ld b, display_cols 
8a96 3e 20			ld a, ' ' 
8a98			.scwipe: 
8a98 77				ld (hl), a 
8a99 2b				dec hl 
8a9a 10 fc			djnz .scwipe 
8a9c			 
8a9c				;pop hl 
8a9c			 
8a9c c1				pop bc 
8a9d d1				pop de 
8a9e e1				pop hl 
8a9f			 
8a9f c9				ret 
8aa0			 
8aa0			 
8aa0			;scroll_upo: 
8aa0			;	ld de, display_row_1 
8aa0			 ;	ld hl, display_row_2 
8aa0			;	ld bc, display_cols 
8aa0			;	ldir 
8aa0			;	ld de, display_row_2 
8aa0			 ;	ld hl, display_row_3 
8aa0			;	ld bc, display_cols 
8aa0			;	ldir 
8aa0			;	ld de, display_row_3 
8aa0			 ;	ld hl, display_row_4 
8aa0			;	ld bc, display_cols 
8aa0			;	ldir 
8aa0			 
8aa0			; TODO clear row 4 
8aa0			 
8aa0			;	ret 
8aa0			 
8aa0				 
8aa0			scroll_down: 
8aa0			 
8aa0 e5				push hl 
8aa1 d5				push de 
8aa2 c5				push bc 
8aa3			 
8aa3				; get frame buffer  
8aa3			 
8aa3 2a cc eb			ld hl, (display_fb_active) 
8aa6			 
8aa6 11 9f 00			ld de, display_fb_len - 1 
8aa9 19				add hl, de 
8aaa			 
8aaa e5			push hl    ; future de destination 
8aab			 
8aab 11 28 00			ld  de, display_cols 
8aae ed 52			sbc hl, de 
8ab0			 
8ab0			 
8ab0 d1				pop de 
8ab1			 
8ab1			;	ex de, hl 
8ab1 01 9f 00			ld bc, display_fb_len -1  
8ab4			 
8ab4			 
8ab4				 
8ab4			 
8ab4 ed b0			ldir 
8ab6			 
8ab6				; wipe bottom row 
8ab6			 
8ab6			 
8ab6			;	ld hl, (display_fb_active) 
8ab6			;;	ld de, display_cols*display_rows 
8ab6			;;	add hl, de 
8ab6			;	ld b, display_cols 
8ab6			;	ld a, ' ' 
8ab6			;.scwiped: 
8ab6			;	ld (hl), a 
8ab6			;	dec hl 
8ab6			;	djnz .scwiped 
8ab6			 
8ab6				;pop hl 
8ab6			 
8ab6 c1				pop bc 
8ab7 d1				pop de 
8ab8 e1				pop hl 
8ab9			 
8ab9 c9				ret 
8aba			;scroll_down: 
8aba			;	ld de, display_row_4 
8aba			;	ld hl, display_row_3 
8aba			;	ld bc, display_cols 
8aba			;	ldir 
8aba			;	ld de, display_row_3 
8aba			; 	ld hl, display_row_2 
8aba			;	ld bc, display_cols 
8aba			;	ldir 
8aba			;	ld de, display_row_2 
8aba			;	ld hl, display_row_1 
8aba			;	ld bc, display_cols 
8aba			;	ldir 
8aba			;;; TODO clear row 1 
8aba			;	ret 
8aba			 
8aba			 
8aba			 
8aba			 
8aba			 
8aba			; clear active frame buffer 
8aba			 
8aba			clear_display: 
8aba 3e 20			ld a, ' ' 
8abc c3 bf 8a			jp fill_display 
8abf			 
8abf			; fill active frame buffer with a char in A 
8abf			 
8abf			fill_display: 
8abf 06 a0			ld b,display_fb_len 
8ac1 2a cc eb			ld hl, (display_fb_active) 
8ac4 77			.fd1:	ld (hl),a 
8ac5 23				inc hl 
8ac6 10 fc			djnz .fd1 
8ac8 23				inc hl 
8ac9 3e 00			ld a,0 
8acb 77				ld (hl),a 
8acc			 
8acc			 
8acc c9				ret 
8acd			; Write string (DE) at pos (A) to active frame buffer 
8acd			 
8acd 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
8ad0 06 00					ld b,0 
8ad2 4f					ld c,a 
8ad3 09					add hl,bc 
8ad4 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8ad5 b7			            OR   A              ;Null terminator? 
8ad6 c8			            RET  Z              ;Yes, so finished 
8ad7 77					ld (hl),a 
8ad8 23				inc hl 
8ad9 13			            INC  DE             ;Point to next character 
8ada 18 f8		            JR   .sad1     ;Repeat 
8adc c9					ret 
8add			 
8add			; using current frame buffer write to physical display 
8add			 
8add			update_display: 
8add e5				push hl 
8ade 2a cc eb			ld hl, (display_fb_active) 
8ae1 cd 85 dc			call write_display 
8ae4 e1				pop hl 
8ae5 c9				ret 
8ae6			 
8ae6			; TODO scrolling 
8ae6			 
8ae6			 
8ae6			; move cursor right one char 
8ae6			cursor_right: 
8ae6			 
8ae6				; TODO shift right 
8ae6				; TODO if beyond max col 
8ae6				; TODO       cursor_next_line 
8ae6			 
8ae6 c9				ret 
8ae7			 
8ae7			 
8ae7			cursor_next_line: 
8ae7				; TODO first char 
8ae7				; TODO line down 
8ae7				; TODO if past last row 
8ae7				; TODO    scroll up 
8ae7			 
8ae7 c9				ret 
8ae8			 
8ae8			cursor_left: 
8ae8				; TODO shift left 
8ae8				; TODO if beyond left  
8ae8				; TODO     cursor prev line 
8ae8				 
8ae8 c9				ret 
8ae9			 
8ae9			cursor_prev_line: 
8ae9				; TODO last char 
8ae9				; TODO line up 
8ae9				; TODO if past first row 
8ae9				; TODO   scroll down 
8ae9			 
8ae9 c9				ret 
8aea			 
8aea			 
8aea			cout: 
8aea				; A - char 
8aea c9				ret 
8aeb			 
8aeb			 
8aeb			; Display a menu and allow item selection (optional toggle items) 
8aeb			; 
8aeb			; format: 
8aeb			; hl pointer to word array with zero term for items 
8aeb			; e.g.    db item1 
8aeb			;         db .... 
8aeb			;         db 0 
8aeb			; 
8aeb			; a = starting menu item  
8aeb			; 
8aeb			; de = pointer item toggle array   (todo) 
8aeb			; 
8aeb			; returns item selected in a 1-... 
8aeb			; returns 0 if back button pressed 
8aeb			; 
8aeb			; NOTE: Uses system frame buffer to display 
8aeb			; 
8aeb			; LEFT, Q = go back 
8aeb			; RIGHT, SPACE, CR = select 
8aeb			; UP, A - Up 
8aeb			; DOWN, Z - Down 
8aeb			 
8aeb			 
8aeb			 
8aeb			 
8aeb			 
8aeb			menu: 
8aeb			 
8aeb					; keep array pointer 
8aeb			 
8aeb 22 73 ea				ld (store_tmp1), hl 
8aee 32 71 ea				ld (store_tmp2), a 
8af1			 
8af1					; check for key bounce 
8af1			 
8af1			if BASE_KEV 
8af1			 
8af1			.mbounce:	call cin 
8af1					cp 0 
8af1					jr nz, .mbounce 
8af1			endif 
8af1					; for ease use ex 
8af1			 
8af1					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8af1 21 b1 ed				ld hl, display_fb0 
8af4 22 cc eb				ld (display_fb_active), hl 
8af7			 
8af7 cd ba 8a		.mloop:		call clear_display 
8afa cd dd 8a				call update_display 
8afd			 
8afd					; draw selection id '>' at 1 
8afd			 
8afd					; init start of list display 
8afd			 
8afd 3e 05				ld a, 5 
8aff 32 6f ea				ld (store_tmp3), a   ; display row count 
8b02 3a 71 ea				ld a,( store_tmp2) 
8b05 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8b08			 
8b08					 
8b08			.mitem:	 
8b08			 
8b08			 
8b08 3a 72 ea				ld a,(store_tmp2+1) 
8b0b 6f					ld l, a 
8b0c 26 00				ld h, 0 
8b0e 29					add hl, hl 
8b0f ed 5b 73 ea			ld de, (store_tmp1) 
8b13 19					add hl, de 
8b14 7e					ld a, (hl) 
8b15 23					inc hl 
8b16 66					ld h,(hl) 
8b17 6f					ld l, a 
8b18			 
8b18 cd 10 8d				call ishlzero 
8b1b 28 1a				jr z, .mdone 
8b1d			 
8b1d eb					ex de, hl 
8b1e 3a 6f ea				ld a, (store_tmp3) 
8b21 cd cd 8a				call str_at_display 
8b24					 
8b24			 
8b24					; next item 
8b24 3a 72 ea				ld a, (store_tmp2+1) 
8b27 3c					inc a 
8b28 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8b2b			 
8b2b			 		; next row 
8b2b			 
8b2b 3a 6f ea				ld a, (store_tmp3) 
8b2e c6 28				add display_cols 
8b30 32 6f ea				ld (store_tmp3), a 
8b33			 
8b33					; at end of screen? 
8b33			 
8b33 fe 10				cp display_rows*4 
8b35 20 d1				jr nz, .mitem 
8b37			 
8b37			 
8b37			.mdone: 
8b37 cd 10 8d				call ishlzero 
8b3a 28 08				jr z, .nodn 
8b3c			 
8b3c 3e 78				ld a, display_row_4 
8b3e 11 bd 8b				ld de, .mdown 
8b41 cd cd 8a				call str_at_display 
8b44			 
8b44					; draw options to fill the screens with active item on line 1 
8b44					; if current option is 2 or more then display ^ in top 
8b44			 
8b44 3a 71 ea		.nodn:		ld a, (store_tmp2) 
8b47 fe 00				cp 0 
8b49 28 08				jr z, .noup 
8b4b			 
8b4b 3e 00				ld a, 0 
8b4d 11 bb 8b				ld de, .mup 
8b50 cd cd 8a				call str_at_display 
8b53			 
8b53 3e 02		.noup:		ld a, 2 
8b55 11 b9 8b				ld de, .msel 
8b58 cd cd 8a				call str_at_display 
8b5b			 
8b5b					; if current option + 1 is not null then display V in bottom 
8b5b					; get key 
8b5b cd dd 8a				call update_display 
8b5e			 
8b5e			 
8b5e					; handle key 
8b5e			 
8b5e cd 11 dd				call cin_wait 
8b61			 
8b61 fe 05				cp KEY_UP 
8b63 28 2b				jr z, .mgoup 
8b65 fe 61				cp 'a' 
8b67 28 27				jr z, .mgoup 
8b69 fe 0a				cp KEY_DOWN 
8b6b 28 32				jr z, .mgod 
8b6d fe 7a				cp 'z' 
8b6f 28 2e				jr z, .mgod 
8b71 fe 20				cp ' ' 
8b73 28 34				jr z, .goend 
8b75 fe 0c				cp KEY_RIGHT 
8b77 28 30				jr z, .goend 
8b79 fe 0d				cp KEY_CR 
8b7b 28 2c				jr z, .goend 
8b7d fe 71				cp 'q' 
8b7f 28 0b				jr z, .goback 
8b81			 
8b81 fe 0b				cp KEY_LEFT 
8b83 28 07				jr z, .goback 
8b85 fe 08				cp KEY_BS 
8b87 28 03				jr z, .goback 
8b89 c3 f7 8a				jp .mloop 
8b8c			 
8b8c			.goback: 
8b8c 3e 00			ld a, 0 
8b8e 18 1d			jr .goend2 
8b90			 
8b90				; move up one 
8b90			.mgoup: 
8b90 3a 71 ea				ld a, (store_tmp2) 
8b93 fe 00				cp 0 
8b95 ca f7 8a				jp z, .mloop 
8b98 3d					dec a 
8b99 32 71 ea				ld (store_tmp2), a 
8b9c c3 f7 8a				jp .mloop 
8b9f			 
8b9f				; move down one 
8b9f			.mgod: 
8b9f 3a 71 ea				ld a, (store_tmp2) 
8ba2 3c					inc a 
8ba3 32 71 ea				ld (store_tmp2), a 
8ba6 c3 f7 8a				jp .mloop 
8ba9			 
8ba9			 
8ba9			.goend: 
8ba9					; get selected item number 
8ba9			 
8ba9 3a 71 ea				ld a, (store_tmp2) 
8bac 3c					inc a 
8bad			 
8bad			.goend2: 
8bad f5					push af 
8bae			 
8bae					; restore active fb 
8bae					; TODO BUG assumes fb1 
8bae			 
8bae 21 10 ed				ld hl, display_fb1 
8bb1 22 cc eb				ld (display_fb_active), hl 
8bb4			 
8bb4					; restore main regs 
8bb4			 
8bb4			 
8bb4 cd dd 8a				call update_display 
8bb7			 
8bb7 f1					pop af 
8bb8			 
8bb8 c9				ret 
8bb9			 
8bb9 .. 00		.msel:   db ">",0 
8bbb .. 00		.mup:   db "^",0 
8bbd .. 00		.mdown:   db "v",0 
8bbf			 
8bbf			 
8bbf			; eof 
8bbf			 
# End of file firmware_display.asm
8bbf			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bbf			; random number generators 
8bbf			 
8bbf			 
8bbf			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bbf			 
8bbf			 
8bbf			;-----> Generate a random number 
8bbf			; output a=answer 0<=a<=255 
8bbf			; all registers are preserved except: af 
8bbf			random: 
8bbf e5			        push    hl 
8bc0 d5			        push    de 
8bc1 2a ab eb		        ld      hl,(randData) 
8bc4 ed 5f		        ld      a,r 
8bc6 57			        ld      d,a 
8bc7 5e			        ld      e,(hl) 
8bc8 19			        add     hl,de 
8bc9 85			        add     a,l 
8bca ac			        xor     h 
8bcb 22 ab eb		        ld      (randData),hl 
8bce d1			        pop     de 
8bcf e1			        pop     hl 
8bd0 c9			        ret 
8bd1			 
8bd1			 
8bd1			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bd1			 
8bd1			 
8bd1			 
8bd1			;------LFSR------ 
8bd1			;James Montelongo 
8bd1			;optimized by Spencer Putt 
8bd1			;out: 
8bd1			; a = 8 bit random number 
8bd1			RandLFSR: 
8bd1 21 b1 eb		        ld hl,LFSRSeed+4 
8bd4 5e			        ld e,(hl) 
8bd5 23			        inc hl 
8bd6 56			        ld d,(hl) 
8bd7 23			        inc hl 
8bd8 4e			        ld c,(hl) 
8bd9 23			        inc hl 
8bda 7e			        ld a,(hl) 
8bdb 47			        ld b,a 
8bdc cb 13		        rl e  
8bde cb 12			rl d 
8be0 cb 11		        rl c  
8be2 17				rla 
8be3 cb 13		        rl e  
8be5 cb 12			rl d 
8be7 cb 11		        rl c  
8be9 17				rla 
8bea cb 13		        rl e  
8bec cb 12			rl d 
8bee cb 11		        rl c  
8bf0 17				rla 
8bf1 67			        ld h,a 
8bf2 cb 13		        rl e  
8bf4 cb 12			rl d 
8bf6 cb 11		        rl c  
8bf8 17				rla 
8bf9 a8			        xor b 
8bfa cb 13		        rl e  
8bfc cb 12			rl d 
8bfe ac			        xor h 
8bff a9			        xor c 
8c00 aa			        xor d 
8c01 21 b3 eb		        ld hl,LFSRSeed+6 
8c04 11 b4 eb		        ld de,LFSRSeed+7 
8c07 01 07 00		        ld bc,7 
8c0a ed b8		        lddr 
8c0c 12			        ld (de),a 
8c0d c9			        ret 
8c0e			 
8c0e			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8c0e			 
8c0e			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8c0e			 
8c0e			 
8c0e			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8c0e			 
8c0e			prng16: 
8c0e			;Inputs: 
8c0e			;   (seed1) contains a 16-bit seed value 
8c0e			;   (seed2) contains a NON-ZERO 16-bit seed value 
8c0e			;Outputs: 
8c0e			;   HL is the result 
8c0e			;   BC is the result of the LCG, so not that great of quality 
8c0e			;   DE is preserved 
8c0e			;Destroys: 
8c0e			;   AF 
8c0e			;cycle: 4,294,901,760 (almost 4.3 billion) 
8c0e			;160cc 
8c0e			;26 bytes 
8c0e 2a a5 eb		    ld hl,(seed1) 
8c11 44			    ld b,h 
8c12 4d			    ld c,l 
8c13 29			    add hl,hl 
8c14 29			    add hl,hl 
8c15 2c			    inc l 
8c16 09			    add hl,bc 
8c17 22 a5 eb		    ld (seed1),hl 
8c1a 2a a3 eb		    ld hl,(seed2) 
8c1d 29			    add hl,hl 
8c1e 9f			    sbc a,a 
8c1f e6 2d		    and %00101101 
8c21 ad			    xor l 
8c22 6f			    ld l,a 
8c23 22 a3 eb		    ld (seed2),hl 
8c26 09			    add hl,bc 
8c27 c9			    ret 
8c28			 
8c28			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c28			 
8c28			rand32: 
8c28			;Inputs: 
8c28			;   (seed1_0) holds the lower 16 bits of the first seed 
8c28			;   (seed1_1) holds the upper 16 bits of the first seed 
8c28			;   (seed2_0) holds the lower 16 bits of the second seed 
8c28			;   (seed2_1) holds the upper 16 bits of the second seed 
8c28			;   **NOTE: seed2 must be non-zero 
8c28			;Outputs: 
8c28			;   HL is the result 
8c28			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c28			;Destroys: 
8c28			;   AF 
8c28			;Tested and passes all CAcert tests 
8c28			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c28			;it has a period of 18,446,744,069,414,584,320 
8c28			;roughly 18.4 quintillion. 
8c28			;LFSR taps: 0,2,6,7  = 11000101 
8c28			;291cc 
8c28			;seed1_0=$+1 
8c28			;    ld hl,12345 
8c28			;seed1_1=$+1 
8c28			;    ld de,6789 
8c28			;    ld b,h 
8c28			;    ld c,l 
8c28			;    add hl,hl \ rl e \ rl d 
8c28			;    add hl,hl \ rl e \ rl d 
8c28			;    inc l 
8c28			;    add hl,bc 
8c28			;    ld (seed1_0),hl 
8c28			;    ld hl,(seed1_1) 
8c28			;    adc hl,de 
8c28			;    ld (seed1_1),hl 
8c28			;    ex de,hl 
8c28			;seed2_0=$+1 
8c28			;    ld hl,9876 
8c28			;seed2_1=$+1 
8c28			;    ld bc,54321 
8c28			;    add hl,hl \ rl c \ rl b 
8c28			;    ld (seed2_1),bc 
8c28			;    sbc a,a 
8c28			;    and %11000101 
8c28			;    xor l 
8c28			;    ld l,a 
8c28			;    ld (seed2_0),hl 
8c28			;    ex de,hl 
8c28			;    add hl,bc 
8c28			;    ret 
8c28			; 
8c28			 
8c28			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c28			; 20 bytes, 86 cycles (excluding ret) 
8c28			 
8c28			; returns   hl = pseudorandom number 
8c28			; corrupts   a 
8c28			 
8c28			; generates 16-bit pseudorandom numbers with a period of 65535 
8c28			; using the xorshift method: 
8c28			 
8c28			; hl ^= hl << 7 
8c28			; hl ^= hl >> 9 
8c28			; hl ^= hl << 8 
8c28			 
8c28			; some alternative shift triplets which also perform well are: 
8c28			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c28			 
8c28			;  org 32768 
8c28			 
8c28			xrnd: 
8c28 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
8c2b 3e 00		  ld a,0 
8c2d bd			  cp l 
8c2e 20 02		  jr nz, .xrnd1 
8c30 2e 01		  ld l, 1 
8c32			.xrnd1: 
8c32			 
8c32 7c			  ld a,h 
8c33 1f			  rra 
8c34 7d			  ld a,l 
8c35 1f			  rra 
8c36 ac			  xor h 
8c37 67			  ld h,a 
8c38 7d			  ld a,l 
8c39 1f			  rra 
8c3a 7c			  ld a,h 
8c3b 1f			  rra 
8c3c ad			  xor l 
8c3d 6f			  ld l,a 
8c3e ac			  xor h 
8c3f 67			  ld h,a 
8c40			 
8c40 22 a9 eb		  ld (xrandc),hl 
8c43			 
8c43 c9			  ret 
8c44			;  
8c44			 
8c44			 
8c44			;;;; int maths 
8c44			 
8c44			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c44			; Divide 16-bit values (with 16-bit result) 
8c44			; In: Divide BC by divider DE 
8c44			; Out: BC = result, HL = rest 
8c44			; 
8c44			Div16: 
8c44 21 00 00		    ld hl,0 
8c47 78			    ld a,b 
8c48 06 08		    ld b,8 
8c4a			Div16_Loop1: 
8c4a 17			    rla 
8c4b ed 6a		    adc hl,hl 
8c4d ed 52		    sbc hl,de 
8c4f 30 01		    jr nc,Div16_NoAdd1 
8c51 19			    add hl,de 
8c52			Div16_NoAdd1: 
8c52 10 f6		    djnz Div16_Loop1 
8c54 17			    rla 
8c55 2f			    cpl 
8c56 47			    ld b,a 
8c57 79			    ld a,c 
8c58 48			    ld c,b 
8c59 06 08		    ld b,8 
8c5b			Div16_Loop2: 
8c5b 17			    rla 
8c5c ed 6a		    adc hl,hl 
8c5e ed 52		    sbc hl,de 
8c60 30 01		    jr nc,Div16_NoAdd2 
8c62 19			    add hl,de 
8c63			Div16_NoAdd2: 
8c63 10 f6		    djnz Div16_Loop2 
8c65 17			    rla 
8c66 2f			    cpl 
8c67 41			    ld b,c 
8c68 4f			    ld c,a 
8c69 c9			ret 
8c6a			 
8c6a			 
8c6a			;http://z80-heaven.wikidot.com/math 
8c6a			; 
8c6a			;Inputs: 
8c6a			;     DE and A are factors 
8c6a			;Outputs: 
8c6a			;     A is not changed 
8c6a			;     B is 0 
8c6a			;     C is not changed 
8c6a			;     DE is not changed 
8c6a			;     HL is the product 
8c6a			;Time: 
8c6a			;     342+6x 
8c6a			; 
8c6a			Mult16: 
8c6a			 
8c6a 06 08		     ld b,8          ;7           7 
8c6c 21 00 00		     ld hl,0         ;10         10 
8c6f 29			       add hl,hl     ;11*8       88 
8c70 07			       rlca          ;4*8        32 
8c71 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c73 19			         add hl,de   ;--         -- 
8c74 10 f9		       djnz $-5      ;13*7+8     99 
8c76 c9			ret 
8c77			 
8c77			; 
8c77			; Square root of 16-bit value 
8c77			; In:  HL = value 
8c77			; Out:  D = result (rounded down) 
8c77			; 
8c77			;Sqr16: 
8c77			;    ld de,#0040 
8c77			;    ld a,l 
8c77			;    ld l,h 
8c77			;    ld h,d 
8c77			;    or a 
8c77			;    ld b,8 
8c77			;Sqr16_Loop: 
8c77			;    sbc hl,de 
8c77			;    jr nc,Sqr16_Skip 
8c77			;    add hl,de 
8c77			;Sqr16_Skip: 
8c77			;    ccf 
8c77			;    rl d 
8c77			;    add a,a 
8c77			;    adc hl,hl 
8c77			;    add a,a 
8c77			;    adc hl,hl 
8c77			;    djnz Sqr16_Loop 
8c77			;    ret 
8c77			; 
8c77			; 
8c77			; Divide 8-bit values 
8c77			; In: Divide E by divider C 
8c77			; Out: A = result, B = rest 
8c77			; 
8c77			Div8: 
8c77 af			    xor a 
8c78 06 08		    ld b,8 
8c7a			Div8_Loop: 
8c7a cb 13		    rl e 
8c7c 17			    rla 
8c7d 91			    sub c 
8c7e 30 01		    jr nc,Div8_NoAdd 
8c80 81			    add a,c 
8c81			Div8_NoAdd: 
8c81 10 f7		    djnz Div8_Loop 
8c83 47			    ld b,a 
8c84 7b			    ld a,e 
8c85 17			    rla 
8c86 2f			    cpl 
8c87 c9			    ret 
8c88			 
8c88			; 
8c88			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c88			; In: Multiply A with DE 
8c88			; Out: HL = result 
8c88			; 
8c88			Mult12U: 
8c88 2e 00		    ld l,0 
8c8a 87			    add a,a 
8c8b 30 01		    jr nc,Mult12U_NoAdd0 
8c8d 19			    add hl,de 
8c8e			Mult12U_NoAdd0: 
8c8e 29			    add hl,hl 
8c8f 87			    add a,a 
8c90 30 01		    jr nc,Mult12U_NoAdd1 
8c92 19			    add hl,de 
8c93			Mult12U_NoAdd1: 
8c93 29			    add hl,hl 
8c94 87			    add a,a 
8c95 30 01		    jr nc,Mult12U_NoAdd2 
8c97 19			    add hl,de 
8c98			Mult12U_NoAdd2: 
8c98 29			    add hl,hl 
8c99 87			    add a,a 
8c9a 30 01		    jr nc,Mult12U_NoAdd3 
8c9c 19			    add hl,de 
8c9d			Mult12U_NoAdd3: 
8c9d 29			    add hl,hl 
8c9e 87			    add a,a 
8c9f 30 01		    jr nc,Mult12U_NoAdd4 
8ca1 19			    add hl,de 
8ca2			Mult12U_NoAdd4: 
8ca2 29			    add hl,hl 
8ca3 87			    add a,a 
8ca4 30 01		    jr nc,Mult12U_NoAdd5 
8ca6 19			    add hl,de 
8ca7			Mult12U_NoAdd5: 
8ca7 29			    add hl,hl 
8ca8 87			    add a,a 
8ca9 30 01		    jr nc,Mult12U_NoAdd6 
8cab 19			    add hl,de 
8cac			Mult12U_NoAdd6: 
8cac 29			    add hl,hl 
8cad 87			    add a,a 
8cae d0			    ret nc 
8caf 19			    add hl,de 
8cb0 c9			    ret 
8cb1			 
8cb1			; 
8cb1			; Multiply 8-bit value with a 16-bit value (right rotating) 
8cb1			; In: Multiply A with DE 
8cb1			;      Put lowest value in A for most efficient calculation 
8cb1			; Out: HL = result 
8cb1			; 
8cb1			Mult12R: 
8cb1 21 00 00		    ld hl,0 
8cb4			Mult12R_Loop: 
8cb4 cb 3f		    srl a 
8cb6 30 01		    jr nc,Mult12R_NoAdd 
8cb8 19			    add hl,de 
8cb9			Mult12R_NoAdd: 
8cb9 cb 23		    sla e 
8cbb cb 12		    rl d 
8cbd b7			    or a 
8cbe c2 b4 8c		    jp nz,Mult12R_Loop 
8cc1 c9			    ret 
8cc2			 
8cc2			; 
8cc2			; Multiply 16-bit values (with 32-bit result) 
8cc2			; In: Multiply BC with DE 
8cc2			; Out: BCHL = result 
8cc2			; 
8cc2			Mult32: 
8cc2 79			    ld a,c 
8cc3 48			    ld c,b 
8cc4 21 00 00		    ld hl,0 
8cc7 06 10		    ld b,16 
8cc9			Mult32_Loop: 
8cc9 29			    add hl,hl 
8cca 17			    rla 
8ccb cb 11		    rl c 
8ccd 30 07		    jr nc,Mult32_NoAdd 
8ccf 19			    add hl,de 
8cd0 ce 00		    adc a,0 
8cd2 d2 d6 8c		    jp nc,Mult32_NoAdd 
8cd5 0c			    inc c 
8cd6			Mult32_NoAdd: 
8cd6 10 f1		    djnz Mult32_Loop 
8cd8 41			    ld b,c 
8cd9 4f			    ld c,a 
8cda c9			    ret 
8cdb			 
8cdb			 
8cdb			 
8cdb			; 
8cdb			; Multiply 8-bit values 
8cdb			; In:  Multiply H with E 
8cdb			; Out: HL = result 
8cdb			; 
8cdb			Mult8: 
8cdb 16 00		    ld d,0 
8cdd 6a			    ld l,d 
8cde 06 08		    ld b,8 
8ce0			Mult8_Loop: 
8ce0 29			    add hl,hl 
8ce1 30 01		    jr nc,Mult8_NoAdd 
8ce3 19			    add hl,de 
8ce4			Mult8_NoAdd: 
8ce4 10 fa		    djnz Mult8_Loop 
8ce6 c9			    ret 
8ce7			 
8ce7			 
8ce7			 
8ce7			 
8ce7			 
8ce7			 
8ce7			 
8ce7			 
8ce7			;;http://z80-heaven.wikidot.com/math 
8ce7			;;This divides DE by BC, storing the result in DE, remainder in HL 
8ce7			; 
8ce7			;DE_Div_BC:          ;1281-2x, x is at most 16 
8ce7			;     ld a,16        ;7 
8ce7			;     ld hl,0        ;10 
8ce7			;     jp $+5         ;10 
8ce7			;.DivLoop: 
8ce7			;       add hl,bc    ;-- 
8ce7			;       dec a        ;64 
8ce7			;       jr z,.DivLoopEnd        ;86 
8ce7			; 
8ce7			;       sla e        ;128 
8ce7			;       rl d         ;128 
8ce7			;       adc hl,hl    ;240 
8ce7			;       sbc hl,bc    ;240 
8ce7			;       jr nc,.DivLoop ;23|21 
8ce7			;       inc e        ;-- 
8ce7			;       jp .DivLoop+1 
8ce7			; 
8ce7			;.DivLoopEnd: 
8ce7			 
8ce7			;HL_Div_C: 
8ce7			;Inputs: 
8ce7			;     HL is the numerator 
8ce7			;     C is the denominator 
8ce7			;Outputs: 
8ce7			;     A is the remainder 
8ce7			;     B is 0 
8ce7			;     C is not changed 
8ce7			;     DE is not changed 
8ce7			;     HL is the quotient 
8ce7			; 
8ce7			;       ld b,16 
8ce7			;       xor a 
8ce7			;         add hl,hl 
8ce7			;         rla 
8ce7			;         cp c 
8ce7			;         jr c,$+4 
8ce7			;           inc l 
8ce7			;           sub c 
8ce7			;         djnz $-7 
8ce7			 
8ce7			; https://plutiedev.com/z80-add-8bit-to-16bit 
8ce7			 
8ce7			addatohl: 
8ce7 85			    add   a, l    ; A = A+L 
8ce8 6f			    ld    l, a    ; L = A+L 
8ce9 8c			    adc   a, h    ; A = A+L+H+carry 
8cea 95			    sub   l       ; A = H+carry 
8ceb 67			    ld    h, a    ; H = H+carry 
8cec c9			ret 
8ced			 
8ced			addatode: 
8ced 83			    add   a, e    ; A = A+L 
8cee 5f			    ld    e, a    ; L = A+L 
8cef 8a			    adc   a, d    ; A = A+L+H+carry 
8cf0 93			    sub   e       ; A = H+carry 
8cf1 57			    ld    d, a    ; H = H+carry 
8cf2 c9			ret 
8cf3			 
8cf3			 
8cf3			addatobc: 
8cf3 81			    add   a, c    ; A = A+L 
8cf4 4f			    ld    c, a    ; L = A+L 
8cf5 88			    adc   a, b    ; A = A+L+H+carry 
8cf6 91			    sub   c       ; A = H+carry 
8cf7 47			    ld    b, a    ; H = H+carry 
8cf8 c9			ret 
8cf9			 
8cf9			subafromhl: 
8cf9			   ; If A=0 do nothing 
8cf9			    ; Otherwise flip A's sign. Since 
8cf9			    ; the upper byte becomes -1, also 
8cf9			    ; substract 1 from H. 
8cf9 ed 44		    neg 
8cfb ca 04 8d		    jp    z, Skip 
8cfe 25			    dec   h 
8cff			     
8cff			    ; Now add the low byte as usual 
8cff			    ; Two's complement takes care of 
8cff			    ; ensuring the result is correct 
8cff 85			    add   a, l 
8d00 6f			    ld    l, a 
8d01 8c			    adc   a, h 
8d02 95			    sub   l 
8d03 67			    ld    h, a 
8d04			Skip: 
8d04 c9				ret 
8d05			 
8d05			 
8d05			; compare hl and de 
8d05			; returns:  
8d05			; if hl = de, z=1, s=0, c0=0 
8d05			; if hl > de, z=0, s=0, c=0 
8d05			; if hl < de, z=0, s=1, c=1 
8d05			cmp16:	 
8d05 b7				or a 
8d06 ed 52			sbc hl,de 
8d08 e0				ret po 
8d09 7c				ld a,h 
8d0a 1f				rra 
8d0b ee 40			xor 01000000B 
8d0d 37				scf 
8d0e 8f				adc a,a 
8d0f c9				ret 
8d10			 
8d10			 
8d10			; test if hl contains zero   - A is destroyed 
8d10			 
8d10			ishlzero:    
8d10 b7				or a     ; reset flags 
8d11 7c				ld a, h 
8d12 b5				or l        	 
8d13			 
8d13 c9				ret 
8d14			 
8d14			 
8d14			 
8d14			 
8d14			if FORTH_ENABLE_FLOATMATH 
8d14			;include "float/bbcmath.z80" 
8d14			include "float/lpfpcalc.asm" 
8d14			endif 
8d14			 
8d14			 
8d14			; eof 
8d14			 
# End of file firmware_maths.asm
8d14			include "firmware_strings.asm"   ; string handling  
8d14			 
8d14			 
8d14			; TODO string len 
8d14			; input text string, end on cr with zero term 
8d14			; a offset into frame buffer to start prompt 
8d14			; d is max length 
8d14			; e is display size TODO 
8d14			; c is current cursor position 
8d14			; hl is ptr to where string will be stored and edited directly 
8d14			 
8d14			 
8d14			; TODO check limit of buffer for new inserts 
8d14			; TODO check insert does not push beyond buffer 
8d14			; TODO scroll in a limited display area 
8d14			; TODO scroll whole screen on page wrap 
8d14			 
8d14			 
8d14			; TODO use LCD cursor? 
8d14			 
8d14			EDIT_V1: equ 0 
8d14			EDIT_V2: equ 1 
8d14			 
8d14			 
8d14			 
8d14			if EDIT_V2 
8d14			input_str: 
8d14			 
8d14 32 64 ee			    	ld (input_at_pos),a      ; save display position to start 
8d17			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
8d17 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
8d1a			;		ld a, c 
8d1a			;		call addatohl 
8d1a			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
8d1a 7a					ld a,d 
8d1b 32 66 ee			        ld (input_size), a       ; save length of input area 
8d1e 79					ld a, c 
8d1f 32 55 ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
8d22 7b					ld a,e 
8d23 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d26			 
8d26			 
8d26					; add a trailing space to make screen refresh nicer 
8d26			 
8d26					;ld hl, (input_start) 
8d26					;push hl 
8d26					;ld a, 0 
8d26					;call strlent 
8d26					;ld a, l 
8d26					;pop hl 
8d26					;call addatohl 
8d26					;dec hl 
8d26					;ld a, ' ' 
8d26					;ld (hl), a 
8d26					;inc hl 
8d26					;ld (hl), a 
8d26					;inc hl 
8d26					;ld a, 0 
8d26					;ld (hl), a 
8d26			 
8d26			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d26					; init cursor shape if not set by the cin routines 
8d26 21 c1 eb				ld hl, cursor_shape 
8d29			if BASE_KEV 
8d29					ld a, 255 
8d29			else 
8d29 3e 23				ld a, '#' 
8d2b			endif 
8d2b 77					ld (hl), a 
8d2c 23					inc hl 
8d2d 3e 00				ld a, 0 
8d2f 77					ld (hl), a 
8d30			 
8d30 3e 09				ld a, CUR_BLINK_RATE 
8d32 32 60 ee				ld (input_cur_flash), a 
8d35 3e 01				ld a, 1 
8d37 32 5f ee				ld (input_cur_onoff),a 
8d3a			.inmain:	 
8d3a			 
8d3a cd 62 8e				call input_disp_ref 
8d3d			 
8d3d					; save current length of string 
8d3d			 
8d3d 2a 67 ee				ld hl, (input_start) 
8d40 3e 00				ld a, 0 
8d42 cd 58 90				call strlent 
8d45 7d					ld a,l 
8d46 32 5a ee				ld (input_len), a 
8d49			 
8d49					;call input_disp_oncur 
8d49			 
8d49					; display current state of input buffer 
8d49			 
8d49					; clean any backspace chars 
8d49			 
8d49 3e 20				ld a, " " 
8d4b 32 c1 e2				ld (scratch),a 
8d4e 3e 00				ld a, 0 
8d50 32 c2 e2				ld (scratch+1),a 
8d53 3a 64 ee				ld a,(input_at_pos) 
8d56 85					add l 
8d57 11 c1 e2				ld de, scratch 
8d5a cd cd 8a				call str_at_display 
8d5d			 
8d5d					; pause 1ms 
8d5d			 
8d5d 3e 01				ld a, 1 
8d5f cd e2 89				call aDelayInMS 
8d62			 
8d62			; display cursor if visible on this cycle 
8d62			 
8d62					; dec flash counter 
8d62 3a 60 ee				ld a, (input_cur_flash) 
8d65 3d					dec a 
8d66 32 60 ee				ld (input_cur_flash), a 
8d69 fe 00				cp 0 
8d6b 20 0d				jr nz, .inochgstate 
8d6d			 
8d6d			 
8d6d					; reset on change of state 
8d6d 3e 09				ld a, CUR_BLINK_RATE 
8d6f 32 60 ee				ld (input_cur_flash), a 
8d72			 
8d72					; change state 
8d72 3a 5f ee				ld a,(input_cur_onoff) 
8d75 ed 44				neg 
8d77 32 5f ee				ld (input_cur_onoff),a 
8d7a			 
8d7a			 
8d7a			 
8d7a			 
8d7a					; TODO is cursor visible? 
8d7a					; TODO if so then over write the char at curspos pos with the cursor shape 
8d7a			 
8d7a								 
8d7a			 
8d7a			.inochgstate: 
8d7a 3a 5f ee				ld a,(input_cur_onoff) 
8d7d fe ff				cp 255 
8d7f 28 0e				jr z, .skipcursor 
8d81 3a 64 ee				ld a, (input_at_pos) 
8d84 47					ld b, a 
8d85 3a 55 ee				ld a, (input_cursor) 
8d88 80					add b 
8d89 11 c1 eb				ld de, cursor_shape 
8d8c					 
8d8c cd cd 8a				call str_at_display 
8d8f			 
8d8f			.skipcursor: 
8d8f				if DEBUG_INPUTV2 
8d8f			 
8d8f					ld a,(input_at_pos) 
8d8f					ld hl, LFSRSeed 
8d8f					call hexout 
8d8f					ld a, (input_cursor) 
8d8f					ld hl, LFSRSeed+2 
8d8f					call hexout 
8d8f					ld a,(input_size) 
8d8f					ld hl, LFSRSeed+4 
8d8f					call hexout 
8d8f			 
8d8f					ld a,(input_cur_onoff) 
8d8f					ld hl, LFSRSeed+6 
8d8f					call hexout 
8d8f			 
8d8f					ld a,(input_cur_flash) 
8d8f					ld hl, LFSRSeed+8 
8d8f					call hexout 
8d8f			 
8d8f					ld a,(input_len) 
8d8f					ld hl, LFSRSeed+10 
8d8f					call hexout 
8d8f					ld hl, LFSRSeed+12 
8d8f					ld a, 0 
8d8f					ld (hl),a 
8d8f					ld a, display_row_4 
8d8f					ld de, LFSRSeed 
8d8f					call str_at_display 
8d8f				endif 
8d8f cd dd 8a				call update_display 
8d92			 
8d92					; TODO keyboard processing 
8d92			 
8d92			if BASE_CPM 
8d92					call cin_wait 
8d92			else 
8d92 cd 17 dd				call cin    ; _wait 
8d95			endif 
8d95 fe 00				cp 0 
8d97 ca 3a 8d				jp z, .inmain 
8d9a			 
8d9a fe 0b				cp KEY_LEFT    ; cursor left 
8d9c ca 54 8e				jp z, input_left 
8d9f				 
8d9f fe 0c				cp KEY_RIGHT      ; cursor right 
8da1 ca 5b 8e				jp z, input_right 
8da4			 
8da4 fe 0d				cp KEY_CR 
8da6 c8					ret z 
8da7			 
8da7 fe 08				cp KEY_BS 
8da9 ca c9 8e				jp z, input_delchar 
8dac			 
8dac fe 06				cp KEY_NEXTWORD 
8dae ca d5 8d				jp z, input_nxtword 
8db1			 
8db1 fe 07				cp KEY_PREVWORD 
8db3 ca fc 8d				jp z, input_prvword 
8db6			 
8db6 fe 0e				cp KEY_HOME    ; jump to start of line 
8db8 20 08				jr nz, .ikh 
8dba 3e 00				ld a, 0 
8dbc 32 55 ee				ld (input_cursor), a 
8dbf ca 3a 8d				jp z, .inmain 
8dc2			.ikh: 
8dc2			 
8dc2 fe 0f				cp KEY_END     ; jump to end of line 
8dc4 20 09				jr nz, .ike 
8dc6 3a 5a ee				ld a, (input_len) 
8dc9 32 55 ee				ld (input_cursor),a 
8dcc ca 3a 8d				jp z, .inmain 
8dcf			.ike: 
8dcf fe 05			        cp KEY_UP      ; recall last command 
8dd1 c8					ret z 
8dd2			;jr nz, .irec 
8dd2			; TODO next word 
8dd2			; TODO prev word 
8dd2			;  
8dd2			; 
8dd2			;	ld hl, scratch 
8dd2			;	ld de, os_last_cmd 
8dd2			;	call strcpy 
8dd2			;		jp  .inmain 
8dd2			.irec: 
8dd2			;		jr .instr1 
8dd2			 
8dd2			 
8dd2			 
8dd2					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
8dd2			 
8dd2			; TODO return if any special keys are given 
8dd2			;		ld l, a 
8dd2			;		ld a, 28 ; KEY_F12   ; 27 
8dd2			;		sub l 
8dd2			;		ret m 
8dd2			;		ld a, l 
8dd2					; if no special key then insert as a char 
8dd2			 
8dd2 c3 9b 8e				jp input_inschr 
8dd5			 
8dd5				 
8dd5			input_nxtword: 
8dd5				; jump to start next word after the cursor 
8dd5			 
8dd5			.insknwn:	 
8dd5 cd 91 8e				call input_curptr	 
8dd8 7e					ld a,(hl)	 
8dd9 fe 00				cp 0 
8ddb ca 3a 8d				jp z, .inmain    ; end of string 
8dde			 
8dde			; if we are on a word, then move off of it 
8dde			 
8dde fe 20				cp ' ' 
8de0 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
8de2 21 55 ee				ld hl, input_cursor 
8de5 34					inc (hl) 
8de6 18 ed				jr .insknwn 
8de8			 
8de8			.inspace: 
8de8			 
8de8 cd 91 8e				call input_curptr	 
8deb 7e					ld a,(hl)	 
8dec fe 00				cp 0 
8dee ca 3a 8d				jp z, .inmain    ; end of string 
8df1			 
8df1			; if we are on a word, then move off of it 
8df1			 
8df1 fe 20				cp ' ' 
8df3 c2 3a 8d				jp nz, .inmain     ; we are on non space so at next word 
8df6 21 55 ee				ld hl, input_cursor 
8df9 34					inc (hl) 
8dfa 18 ec				jr .inspace 
8dfc			 
8dfc			 
8dfc			 
8dfc			 
8dfc			input_prvword: 
8dfc				; jump to the start of previous word before the cursor 
8dfc			 
8dfc			; where are we to start with currently? 
8dfc			 
8dfc cd 91 8e				call input_curptr	 
8dff 7e					ld a, (hl) 
8e00 fe 20				cp ' ' 
8e02 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
8e04			 
8e04			 
8e04			 
8e04			.inskpwn:	 
8e04 3a 55 ee				ld a,(input_cursor) 
8e07 fe 00				cp 0 
8e09 ca 3a 8d				jp z, .inmain    ; start of string 
8e0c			 
8e0c			;if we are on a word, then move off of it 
8e0c			 
8e0c cd 91 8e				call input_curptr	 
8e0f 7e					ld a, (hl) 
8e10 fe 20				cp ' ' 
8e12 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
8e14					;jp z, .inmain    ; start of string 
8e14 21 55 ee				ld hl, input_cursor 
8e17 35					dec (hl) 
8e18 18 ea				jr .inskpwn 
8e1a			.iwstart: 
8e1a 21 55 ee				ld hl, input_cursor 
8e1d 34					inc (hl) 
8e1e c3 3a 8d				jp .inmain 
8e21					 
8e21			 
8e21			.inspacep: 
8e21			 
8e21					;jp .inmain    ; start of string 
8e21			 
8e21			 
8e21			 
8e21 3a 55 ee				ld a,(input_cursor) 
8e24 fe 00				cp 0 
8e26 ca 3a 8d				jp z, .inmain    ; start of string 
8e29			 
8e29			; if we are on a word, then move off of it 
8e29			 
8e29 cd 91 8e				call input_curptr	 
8e2c 7e					ld a, (hl) 
8e2d fe 20				cp ' ' 
8e2f c2 38 8e				jp nz, .incharp     ; we are on non space so at end of prev word 
8e32 21 55 ee				ld hl, input_cursor 
8e35 35					dec (hl) 
8e36 18 e9				jr .inspacep 
8e38			 
8e38			 
8e38			.incharp:	 
8e38					; eat the word to get to the start 
8e38 3a 55 ee				ld a,(input_cursor) 
8e3b fe 00				cp 0 
8e3d ca 3a 8d				jp z, .inmain    ; start of string 
8e40			 
8e40			; if we are on a word, then move off of it 
8e40			 
8e40 cd 91 8e				call input_curptr	 
8e43 7e					ld a, (hl) 
8e44 fe 20				cp ' ' 
8e46 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
8e48 21 55 ee				ld hl, input_cursor 
8e4b 35					dec (hl) 
8e4c 18 ea				jr .incharp 
8e4e			.ipwordst: 
8e4e					; at space before the prev word so reposition over it 
8e4e 21 55 ee				ld hl, input_cursor 
8e51 34					inc (hl) 
8e52 18 b0				jr .inskpwn 
8e54					 
8e54			 
8e54			 
8e54			input_left: 
8e54				; move cursor left 
8e54 21 55 ee			ld hl, input_cursor 
8e57 35				dec (hl) 
8e58			;	cp 0 
8e58			;	jp z, .inmain    ; ignore left as at the start of the string 
8e58 c3 3a 8d			jp .inmain 
8e5b			 
8e5b			input_right: 
8e5b				; move cursor right 
8e5b				 
8e5b				;ld a, (input_size) 
8e5b				;ld b, a 
8e5b 21 55 ee			ld hl, input_cursor 
8e5e 34				inc (hl) 
8e5f				;dec b 
8e5f				;cp 0 
8e5f				;jp z, .inmain   ; ignore as at end of the string buffer 
8e5f				;ld a, b 
8e5f				;inc a 
8e5f				;ld (input_cursor), a 
8e5f c3 3a 8d			jp .inmain 
8e62			 
8e62			 
8e62			 
8e62			input_disp_ref: 
8e62				; display the text from start of buffer (ie full refresh) 
8e62 3a 64 ee			ld a, (input_at_pos) 
8e65 2a 67 ee			ld hl,(input_start) 
8e68 eb				ex de, hl 
8e69 cd cd 8a			call str_at_display  
8e6c c9				ret 
8e6d			input_disp_oncur: 
8e6d				; display the text from cursor position to end of buffer 
8e6d				; TODO position start of string at cursor position on screen 
8e6d				; TODO draw from that point on 
8e6d 3a 55 ee			ld a, (input_cursor) 
8e70 47				ld b, a 
8e71 3a 64 ee			ld a, (input_at_pos) 
8e74 80				add b 
8e75 48				ld c, b     ; save a 
8e76 78				ld a, b     ; inc string start for cursor 
8e77 2a 67 ee			ld hl,(input_start) 
8e7a cd e7 8c			call addatohl 
8e7d eb				ex de, hl 
8e7e 79				ld a, c 
8e7f cd cd 8a			call str_at_display  
8e82 c9				ret 
8e83			 
8e83			input_nxtw: 
8e83				; Find next word 
8e83 c9				ret 
8e84			 
8e84			input_prvw: 
8e84				; Find previous word 
8e84 c9				ret 
8e85			 
8e85			input_lenrem:   
8e85				; Calculate the length of string remaining from current cursor 
8e85				; position to end of buffer (exc null term) 
8e85				 
8e85 3a 55 ee			ld a, (input_cursor) 
8e88 4f				ld c, a 
8e89 3a 66 ee			ld a, (input_size) 
8e8c 91				sub c 
8e8d 06 00			ld b, 0 
8e8f 0d				dec c 
8e90 c9				ret	 
8e91			 
8e91			input_curptr: 
8e91				; calc address of the character under the cursor 
8e91				 
8e91 2a 67 ee			ld hl, (input_start) 
8e94 3a 55 ee			ld a, (input_cursor) 
8e97 cd e7 8c			call addatohl 
8e9a c9				ret 
8e9b			 
8e9b			input_inschr: 
8e9b				; Insert char at cursor position 
8e9b f5				push af   ; save char 
8e9c				;call input_lenrem    ; get bc length of remaining string 
8e9c			 
8e9c				 
8e9c cd 91 8e			call input_curptr 
8e9f			;	ld hl, (input_start) 
8e9f			;	ld a, (input_cursor) 
8e9f			;	call addatohl 
8e9f				;push hl   ; save to come back to 
8e9f			 
8e9f				; shift everything up one to end of buffer 
8e9f			 
8e9f				;push hl 
8e9f				;dec de 
8e9f				;inc de 
8e9f			;	ldir 
8e9f				 
8e9f				;pop hl 
8e9f			 
8e9f				; are we adding to the end of line? 
8e9f			 
8e9f 3a 55 ee			ld a, (input_cursor) 
8ea2 47				ld b, a 
8ea3 3a 5a ee			ld a, (input_len) 
8ea6 b8				cp b 
8ea7 20 09			jr nz, .insmid   ; no, insert in middle of text 
8ea9			 
8ea9				; tack on the end of the line 
8ea9 f1				pop af 
8eaa 77				ld (hl), a   ; save new char 
8eab 23				inc hl 
8eac 3e 00			ld a, 0 
8eae 77				ld (hl), a 
8eaf c3 5b 8e			jp input_right 
8eb2				 
8eb2			.insmid: 
8eb2				; hl has insertion point so move everything up one to allow for insertion 
8eb2				;call input_shiftright 
8eb2 f1				pop af 
8eb3			 
8eb3			.shufinsmid: 
8eb3 47				ld b, a     ; b contains new char, c prev char at this position  
8eb4 7e				ld a, (hl) 
8eb5			 
8eb5 fe 00			cp 0    ; at end of string need to then dump new char and add term 
8eb7 28 07			jr z, .endinsmid 
8eb9 4f				ld c, a 
8eba 78				ld a, b 
8ebb 77				ld (hl), a 
8ebc 23				inc hl 
8ebd 79				ld a, c 
8ebe 18 f3			jr .shufinsmid 
8ec0				 
8ec0			 
8ec0			 
8ec0			 
8ec0			.endinsmid: 
8ec0 78				ld a, b 
8ec1 77				ld (hl), a 
8ec2 23				inc hl 
8ec3 3e 00			ld a, 0 
8ec5 77				ld (hl), a 
8ec6			 
8ec6			 
8ec6			;	ld (hl), a   ; save new char 
8ec6			 
8ec6 c3 5b 8e			jp input_right 
8ec9			 
8ec9			;input_shiftright: 
8ec9			;	; shift text right at cursor, hl has shift start 
8ec9			;	push hl 
8ec9			;	push de 
8ec9			;	push bc 
8ec9			; 
8ec9			; 
8ec9			;	; move to end of string past zero term 
8ec9			;	ld hl,(input_start) 
8ec9			;	ld a, (input_len) 
8ec9			;	call addatohl 
8ec9			;	inc hl 
8ec9			;;	inc hl 
8ec9			;;	inc hl 
8ec9			;	ld a, 0 
8ec9			;	ld (hl), a 
8ec9			;;	dec hl 
8ec9			;	 
8ec9			;;	ld (hl), a 
8ec9			;;	dec hl 
8ec9			; 
8ec9			;	push hl 
8ec9			;	pop de 
8ec9			;	inc de 
8ec9			;	 
8ec9			; 
8ec9			;;	ld hl,(input_start) 
8ec9			;;	ld a, (input_cursor) 
8ec9			;;	call addatohl 
8ec9			; 
8ec9			; 
8ec9			;	; calc how many bytes from cursor pos to end of string we need to shift 
8ec9			;	call input_lenrem    ; get bc length of remaining string 
8ec9			;	;ld a, (input_cursor) 
8ec9			;	;ld c, a 
8ec9			;	ld a, (input_len) 
8ec9			;	cp 2 
8ec9			;	jr z, .iskipzero	 
8ec9			;	;sub c 
8ec9			;	;inc a 
8ec9			;	;ld c, a 
8ec9			;	;ld b, 0 
8ec9			;	inc c 
8ec9			;	inc c 
8ec9			;	; move data 
8ec9			;	lddr 
8ec9			;.iskipzero: 
8ec9			; 
8ec9			;	pop bc 
8ec9			;	pop de 
8ec9			;	pop hl 
8ec9			;	ret	 
8ec9			 
8ec9			input_delchar: 
8ec9				; Delete char at cursor position 
8ec9 cd 85 8e			call input_lenrem    ; get bc length of remaining string 
8ecc 2a 67 ee			ld hl, (input_start) 
8ecf 3a 55 ee			ld a, (input_cursor) 
8ed2 cd e7 8c			call addatohl 
8ed5			 
8ed5 e5				push hl 
8ed6 d1				pop de 
8ed7 1b				dec de 
8ed8			 
8ed8			.dl:	 
8ed8 ed a0			ldi  
8eda 7e				ld a, (hl) 
8edb fe 00			cp 0 
8edd 28 02			jr z, .dldone 
8edf 18 f7			jr .dl 
8ee1			.dldone: 
8ee1 ed a0			ldi 
8ee3			 
8ee3 c3 54 8e			jp input_left 
8ee6			 
8ee6			 
8ee6			endif 
8ee6			 
8ee6			 
8ee6			 
8ee6			if EDIT_V1 
8ee6			input_str: 
8ee6			 
8ee6				    	ld (input_at_pos),a      ; save display position to start 
8ee6					add c 
8ee6					ld (input_at_cursor),a	; save draw pos of cursor 
8ee6					ld (input_start), hl     ; save ptr to buffer 
8ee6					ld a, c 
8ee6					call addatohl 
8ee6					ld (input_ptr), hl     ; save ptr to point under the cursor 
8ee6					ld a,d 
8ee6				        ld (input_size), a       ; save length of input area 
8ee6					ld a, c 
8ee6					ld (input_cursor),a      ; init cursor start position  
8ee6					ld a,e 
8ee6				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8ee6					 
8ee6					 
8ee6			 
8ee6			;		ld a,(input_ptr) 
8ee6			;		ld (input_under_cursor),a 	; save what is under the cursor 
8ee6			 
8ee6			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8ee6					; init cursor shape if not set by the cin routines 
8ee6					ld hl, cursor_shape 
8ee6			if BASE_KEV 
8ee6					ld a, 255 
8ee6			else 
8ee6					ld a, '#' 
8ee6			endif 
8ee6					ld (hl), a 
8ee6					inc hl 
8ee6					ld a, 0 
8ee6					ld (hl), a 
8ee6			 
8ee6					ld a, CUR_BLINK_RATE 
8ee6					ld (input_cur_flash), a 
8ee6					ld a, 1 
8ee6					ld (input_cur_onoff),a 
8ee6			 
8ee6			;	if DEBUG_INPUT 
8ee6			;		push af 
8ee6			;		ld a, 'I' 
8ee6			;		ld (debug_mark),a 
8ee6			;		pop af 
8ee6			;		CALLMONITOR 
8ee6			;	endif 
8ee6			.is1:		; main entry loop 
8ee6			 
8ee6			 
8ee6			 
8ee6					; pause 1ms 
8ee6			 
8ee6					ld a, 1 
8ee6					call aDelayInMS 
8ee6			 
8ee6					; dec flash counter 
8ee6					ld a, (input_cur_flash) 
8ee6					dec a 
8ee6					ld (input_cur_flash), a 
8ee6					cp 0 
8ee6					jr nz, .nochgstate 
8ee6			 
8ee6			 
8ee6					; change state 
8ee6					ld a,(input_cur_onoff) 
8ee6					neg 
8ee6					ld (input_cur_onoff),a 
8ee6			 
8ee6			 
8ee6					; reset on change of state 
8ee6					ld a, CUR_BLINK_RATE 
8ee6					ld (input_cur_flash), a 
8ee6			 
8ee6			.nochgstate: 
8ee6					 
8ee6					 
8ee6			 
8ee6					; display cursor  
8ee6			 
8ee6			;		ld hl, (input_start) 
8ee6			;		ld a, (input_cursor) 
8ee6			;		call addatohl 
8ee6			 
8ee6					; get char under cursor and replace with cursor 
8ee6			ld hl, (input_ptr) 
8ee6			;		ld a, (hl) 
8ee6			;		ld (input_under_cursor),a 
8ee6			;		ld a, '_' 
8ee6			;		ld (hl), a 
8ee6			 
8ee6					; display string 
8ee6			 
8ee6					ld de, (input_start) 
8ee6					ld a, (input_at_pos) 
8ee6					call str_at_display 
8ee6			;	        call update_display 
8ee6			 
8ee6					; find place to put the cursor 
8ee6			;		add h 
8ee6			;		ld l, display_row_1 
8ee6			;		sub l 
8ee6			; (input_at_pos) 
8ee6					;ld c, a 
8ee6			;		ld a, (input_cursor) 
8ee6			;		ld l, (input_at_pos) 
8ee6			;		;ld b, h 
8ee6			;		add l 
8ee6			;		ld (input_at_cursor),a 
8ee6					;ld l,h 
8ee6			 
8ee6			;		ld h, 0 
8ee6			;		ld l,(input_at_pos) 
8ee6			;		ld a, (input_cursor) 
8ee6			;		call addatohl 
8ee6			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8ee6			;		call subafromhl 
8ee6			;		ld a,l 
8ee6			;		ld (input_at_cursor), a 
8ee6			 
8ee6				if DEBUG_INPUT 
8ee6					ld a, (hardware_diag) 
8ee6					cp 0 
8ee6					jr z, .skip_input_diag 
8ee6			 
8ee6					ld a,(input_at_pos) 
8ee6					ld hl, LFSRSeed 
8ee6					call hexout 
8ee6					ld a, (input_cursor) 
8ee6					ld hl, LFSRSeed+2 
8ee6					call hexout 
8ee6					ld a,(input_at_cursor) 
8ee6					ld hl, LFSRSeed+4 
8ee6					call hexout 
8ee6			 
8ee6					ld a,(input_cur_onoff) 
8ee6					ld hl, LFSRSeed+6 
8ee6					call hexout 
8ee6			 
8ee6					ld a,(input_cur_flash) 
8ee6					ld hl, LFSRSeed+8 
8ee6					call hexout 
8ee6			 
8ee6					ld a,(input_len) 
8ee6					ld hl, LFSRSeed+10 
8ee6					call hexout 
8ee6					ld hl, LFSRSeed+12 
8ee6					ld a, 0 
8ee6					ld (hl),a 
8ee6					ld a, display_row_4 
8ee6					ld de, LFSRSeed 
8ee6					call str_at_display 
8ee6					.skip_input_diag: 
8ee6				endif 
8ee6			 
8ee6					; decide on if we are showing the cursor this time round 
8ee6			 
8ee6					ld a, (input_cur_onoff) 
8ee6					cp 255 
8ee6					jr z, .skipcur 
8ee6			 
8ee6			 
8ee6					ld a,(input_at_cursor) 
8ee6					ld de, cursor_shape 
8ee6					call str_at_display 
8ee6			 
8ee6					; save length of current input string 
8ee6					ld hl, (input_start) 
8ee6					ld a, 0 
8ee6					call strlent 
8ee6					ld a,l 
8ee6					ld (input_len),a 
8ee6			 
8ee6			.skipcur: 
8ee6			 
8ee6				        call update_display 
8ee6					 
8ee6			 
8ee6			 
8ee6					; wait 
8ee6				 
8ee6					; TODO loop without wait to flash the cursor and char under cursor	 
8ee6					call cin    ; _wait 
8ee6			 
8ee6					cp 0 
8ee6					jp z, .is1 
8ee6			 
8ee6					; get ptr to char to input into 
8ee6			 
8ee6					ld c,a 
8ee6					ld hl, (input_start) 
8ee6					ld a, (input_cursor) 
8ee6					call addatohl 
8ee6					ld (input_ptr), hl 
8ee6					ld a,c 
8ee6			 
8ee6					; replace char under cursor 
8ee6			 
8ee6			;		ld hl, (input_ptr) 
8ee6			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8ee6			;		ld (hl), a 
8ee6			 
8ee6			;	if DEBUG_INPUT 
8ee6			;		push af 
8ee6			;		ld a, 'i' 
8ee6			;		ld (debug_mark),a 
8ee6			;		pop af 
8ee6			;		CALLMONITOR 
8ee6			;	endif 
8ee6					cp KEY_HOME 
8ee6					jr nz, .iske 
8ee6			 
8ee6					ld a, (input_at_pos) 
8ee6					ld (input_at_cursor),a 
8ee6					ld a, 0 
8ee6					ld (input_cursor), a 
8ee6					jp .is1 
8ee6					 
8ee6			.iske:		cp KEY_END 
8ee6					jr nz, .isknw 
8ee6					jp .is1 
8ee6			 
8ee6			.isknw:		cp KEY_NEXTWORD 
8ee6					jr nz, .iskpw 
8ee6			 
8ee6			.isknwm:	ld hl, (input_ptr) 
8ee6					ld a,(hl)	 
8ee6					cp 0 
8ee6					jp z, .is1    ; end of string 
8ee6					cp ' ' 
8ee6					jp z, .is1    ; end of word 
8ee6					inc hl 
8ee6					ld (input_ptr), hl 
8ee6					ld a, (input_at_cursor) 
8ee6					inc a 
8ee6					ld (input_at_cursor), a 
8ee6					jr .isknwm 
8ee6			 
8ee6			.iskpw:		cp KEY_PREVWORD 
8ee6					jr nz, .iskl 
8ee6			.iskpwm:	 
8ee6					ld hl, (input_ptr) 
8ee6					ld a,(hl)	 
8ee6					cp 0  
8ee6					jp z, .is1    ; end of string 
8ee6					cp ' ' 
8ee6					jp z, .is1    ; end of word 
8ee6					dec hl 
8ee6					ld (input_ptr), hl 
8ee6					ld a, (input_at_cursor) 
8ee6					dec a 
8ee6					ld (input_at_cursor), a 
8ee6					jr .iskpwm 
8ee6			 
8ee6			 
8ee6			.iskl:		cp KEY_LEFT 
8ee6					jr nz, .isk1 
8ee6			 
8ee6					ld a, (input_cursor) 
8ee6			 
8ee6					cp 0 
8ee6					jp z, .is1 		; at start of line to ignore  
8ee6			 
8ee6					dec  a 		; TODO check underflow 
8ee6					ld (input_cursor), a 
8ee6			 
8ee6					ld hl, (input_ptr) 
8ee6					dec hl 
8ee6					ld (input_ptr), hl 
8ee6					 
8ee6					ld a, (input_at_cursor) 
8ee6					dec a 
8ee6					ld (input_at_cursor), a 
8ee6			 
8ee6					ld a, 1		; show cursor moving 
8ee6					ld (input_cur_onoff),a 
8ee6					ld a, CUR_BLINK_RATE 
8ee6					ld (input_cur_flash), a 
8ee6			 
8ee6					jp .is1 
8ee6			 
8ee6			.isk1:		cp KEY_RIGHT 
8ee6					jr nz, .isk2 
8ee6			 
8ee6					ld a,(input_len)		; TODO BUG why cant i load e direct? 
8ee6					ld e,a 
8ee6					ld a, (input_cursor) 
8ee6					cp e 
8ee6					jp z, .is1		; at the end of string so dont go right 
8ee6			 
8ee6					inc  a 		; TODO check overflow 
8ee6					ld (input_cursor), a 
8ee6			 
8ee6					ld a, (input_at_cursor) 
8ee6					inc a 
8ee6					ld (input_at_cursor), a 
8ee6			 
8ee6					ld hl, (input_ptr) 
8ee6					inc hl 
8ee6					ld (input_ptr), hl 
8ee6			 
8ee6					ld a, 1		; show cursor moving 
8ee6					ld (input_cur_onoff),a 
8ee6					ld a, CUR_BLINK_RATE 
8ee6					ld (input_cur_flash), a 
8ee6			 
8ee6					jp .is1 
8ee6			 
8ee6			.isk2:		cp KEY_UP 
8ee6			 
8ee6					jr nz, .isk3 
8ee6			 
8ee6					; swap last command with the current on 
8ee6			 
8ee6					; move cursor to start of string 
8ee6					ld hl, (input_start) 
8ee6					ld (input_ptr), hl 
8ee6			 
8ee6					ld a, (input_at_pos) 
8ee6					ld (input_at_cursor), a 
8ee6			 
8ee6					ld a, 0 
8ee6					ld (input_cursor), a 
8ee6					 
8ee6					; swap input and last command buffers 
8ee6			 
8ee6					ld hl, os_cli_cmd 
8ee6					ld de, os_last_cmd 
8ee6					ld b, 255 
8ee6			.swap1:		ld a, (hl) 
8ee6					ld c,a 
8ee6					ld a, (de) 
8ee6					ld (hl), a 
8ee6					ld a,c 
8ee6					ld (de),a 
8ee6					inc hl 
8ee6					inc de 
8ee6					djnz .swap1 
8ee6			 
8ee6			 
8ee6			 
8ee6			 
8ee6			 
8ee6					jp .is1 
8ee6			 
8ee6			.isk3:		cp KEY_BS 
8ee6					jr nz, .isk4 
8ee6			 
8ee6					ld a, (input_cursor) 
8ee6			 
8ee6					cp 0 
8ee6					jp z, .is1 		; at start of line to ignore  
8ee6			 
8ee6					dec  a 		; TODO check underflow 
8ee6					ld (input_cursor), a 
8ee6			 
8ee6					; hl is source 
8ee6					; de needs to be source - 1 
8ee6			 
8ee6			;		ld a, 0 
8ee6			;		dec hl 
8ee6			;		ld (hl), a 
8ee6			 
8ee6					ld hl, (input_ptr) 
8ee6					dec hl 
8ee6					ld (input_ptr), hl 
8ee6			 
8ee6					; shift all data 
8ee6			 
8ee6					push hl 
8ee6					inc hl 
8ee6					pop de 
8ee6					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8ee6					ld c,a 
8ee6					ld b,0 
8ee6					ldir  
8ee6			 
8ee6			 
8ee6			 
8ee6			 
8ee6					ld a, (input_at_cursor) 
8ee6					dec a 
8ee6					ld (input_at_cursor), a 
8ee6			 
8ee6			 
8ee6					ld a, 1		; show cursor moving 
8ee6					ld (input_cur_onoff),a 
8ee6					ld a, CUR_BLINK_RATE 
8ee6					ld (input_cur_flash), a 
8ee6			 
8ee6					; remove char 
8ee6					ld a, (input_at_cursor) 
8ee6					inc a 
8ee6					ld de,.iblank 
8ee6					call str_at_display 
8ee6			 
8ee6					jp .is1 
8ee6			 
8ee6			.isk4:		cp KEY_CR 
8ee6					jr z, .endinput 
8ee6			 
8ee6					; else add the key press to the end 
8ee6			 
8ee6					ld c, a			; save key pressed 
8ee6			 
8ee6					ld a,(hl)		; get what is currently under char 
8ee6			 
8ee6					cp 0			; we are at the end of the string 
8ee6					jr nz, .onchar 
8ee6					 
8ee6					; add a char to the end of the string 
8ee6				 
8ee6					ld (hl),c 
8ee6					inc hl 
8ee6			;		ld a,' ' 
8ee6			;		ld (hl),a 
8ee6			;		inc hl 
8ee6					ld a,0 
8ee6					ld (hl),a 
8ee6					dec hl 
8ee6			 
8ee6					ld a, (input_cursor) 
8ee6					inc a				; TODO check max string length and scroll  
8ee6					ld (input_cursor), a		; inc cursor pos 
8ee6							 
8ee6					ld a, (input_at_cursor) 
8ee6					inc a 
8ee6					ld (input_at_cursor), a 
8ee6			 
8ee6					ld hl, (input_ptr) 
8ee6					inc hl 
8ee6					ld (input_ptr), hl 
8ee6			 
8ee6					ld hl, (input_ptr) 
8ee6					inc hl 
8ee6					ld (input_ptr), hl 
8ee6			;	if DEBUG_INPUT 
8ee6			;		push af 
8ee6			;		ld a, '+' 
8ee6			;		ld (debug_mark),a 
8ee6			;		pop af 
8ee6			;		CALLMONITOR 
8ee6			;	endif 
8ee6					ld a, 1		; show cursor moving 
8ee6					ld (input_cur_onoff),a 
8ee6					ld a, CUR_BLINK_RATE 
8ee6					ld (input_cur_flash), a 
8ee6					jp .is1 
8ee6					 
8ee6			 
8ee6			 
8ee6					; if on a char then insert 
8ee6			.onchar: 
8ee6			 
8ee6					; TODO over flow check: make sure insert does not blow out buffer 
8ee6			 
8ee6					; need to do some maths to use lddr 
8ee6			 
8ee6					push hl   ; save char pos 
8ee6					push bc 
8ee6			 
8ee6					ld hl, (input_start) 
8ee6					ld a, (input_len) 
8ee6					call addatohl  		; end of string 
8ee6					inc hl 
8ee6					inc hl		; past zero term 
8ee6					push hl 
8ee6					inc hl 
8ee6					push hl  
8ee6			 
8ee6								; start and end of lddr set, now how much to move? 
8ee6			 
8ee6							 
8ee6					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8ee6					ld b,a 
8ee6					ld a,(input_len) 
8ee6					ld e,a 
8ee6					sub b 
8ee6					inc a		;?? 
8ee6					inc a		;?? 
8ee6					inc a		;?? 
8ee6			 
8ee6					ld b,0 
8ee6					ld c,a 
8ee6			 
8ee6				if DEBUG_INPUT 
8ee6					push af 
8ee6					ld a, 'i' 
8ee6					ld (debug_mark),a 
8ee6					pop af 
8ee6			;		CALLMONITOR 
8ee6				endif 
8ee6					pop de 
8ee6					pop hl 
8ee6				if DEBUG_INPUT 
8ee6					push af 
8ee6					ld a, 'I' 
8ee6					ld (debug_mark),a 
8ee6					pop af 
8ee6			;		CALLMONITOR 
8ee6				endif 
8ee6					lddr 
8ee6				 
8ee6			 
8ee6			 
8ee6					; TODO have a key for insert/overwrite mode???? 
8ee6					pop bc 
8ee6					pop hl 
8ee6					ld (hl), c		; otherwise overwrite current char 
8ee6					 
8ee6			 
8ee6			 
8ee6			 
8ee6					ld a, (input_cursor) 
8ee6					inc  a 		; TODO check overflow 
8ee6					ld (input_cursor), a 
8ee6			 
8ee6					ld a, (input_at_cursor) 
8ee6					inc a 
8ee6					ld (input_at_cursor), a 
8ee6			 
8ee6					jp .is1 
8ee6			 
8ee6			.endinput:	; TODO look for end of string 
8ee6			 
8ee6					; add trailing space for end of token 
8ee6			 
8ee6					ld hl, (input_start) 
8ee6					ld a,(input_len) 
8ee6					call addatohl 
8ee6					ld a, ' ' 
8ee6					ld (hl),a 
8ee6					; TODO eof of parse marker 
8ee6			 
8ee6					inc hl 
8ee6					ld a, 0 
8ee6					ld (hl),a 
8ee6			 
8ee6			 
8ee6					ret 
8ee6			 
8ee6			.iblank: db " ",0 
8ee6			 
8ee6			 
8ee6			input_str_prev:	ld (input_at_pos), a 
8ee6					ld (input_start), hl 
8ee6					ld a,1			; add cursor 
8ee6					ld (hl),a 
8ee6					inc hl 
8ee6					ld a,0 
8ee6					ld (hl),a 
8ee6					ld (input_ptr), hl 
8ee6					ld a,d 
8ee6					ld (input_size), a 
8ee6					ld a,0 
8ee6					ld (input_cursor),a 
8ee6			.instr1:	 
8ee6			 
8ee6					; TODO do block cursor 
8ee6					; TODO switch cursor depending on the modifer key 
8ee6			 
8ee6					; update cursor shape change on key hold 
8ee6			 
8ee6					ld hl, (input_ptr) 
8ee6					dec hl 
8ee6					ld a,(cursor_shape) 
8ee6					ld (hl), a 
8ee6			 
8ee6					; display entered text 
8ee6					ld a,(input_at_pos) 
8ee6			            	CALL fLCD_Pos       ;Position cursor to location in A 
8ee6			            	LD   de, (input_start) 
8ee6			            	CALL fLCD_Str       ;Display string pointed to by DE 
8ee6			 
8ee6					call cin 
8ee6					cp 0 
8ee6					jr z, .instr1 
8ee6			 
8ee6					; proecess keyboard controls first 
8ee6			 
8ee6					ld hl,(input_ptr) 
8ee6			 
8ee6					cp KEY_CR	 ; pressing enter ends input 
8ee6					jr z, .instrcr 
8ee6			 
8ee6					cp KEY_BS 	; back space 
8ee6					jr nz, .instr2 
8ee6					; process back space 
8ee6			 
8ee6					; TODO stop back space if at start of string 
8ee6					dec hl 
8ee6					dec hl ; to over write cursor 
8ee6					ld a,(cursor_shape) 
8ee6					;ld a,0 
8ee6					ld (hl),a 
8ee6					inc hl 
8ee6					ld a," " 
8ee6					ld (hl),a 
8ee6					ld (input_ptr),hl 
8ee6					 
8ee6			 
8ee6					jr .instr1 
8ee6			 
8ee6			.instr2:	cp KEY_LEFT    ; cursor left 
8ee6					jr nz, .instr3 
8ee6					dec hl 
8ee6					ld (input_ptr),hl 
8ee6					jr .instr1 
8ee6				 
8ee6			.instr3:	cp KEY_RIGHT      ; cursor right 
8ee6					jr nz, .instr4 
8ee6					inc hl 
8ee6					ld (input_ptr),hl 
8ee6					jr .instr1 
8ee6			 
8ee6			.instr4:	cp KEY_HOME    ; jump to start of line 
8ee6					jr nz, .instr5 
8ee6					dec hl 
8ee6					ld (input_ptr),hl 
8ee6					jr .instr1 
8ee6			 
8ee6			.instr5:	cp KEY_END     ; jump to end of line 
8ee6					jr nz, .instr6 
8ee6					dec hl 
8ee6					ld (input_ptr),hl 
8ee6					jr .instr1 
8ee6			.instr6:        cp KEY_UP      ; recall last command 
8ee6					jr nz, .instrnew 
8ee6			 
8ee6				ld hl, scratch 
8ee6				ld de, os_last_cmd 
8ee6				call strcpy 
8ee6					jr .instr1 
8ee6			 
8ee6			 
8ee6			.instrnew:	; no special key pressed to see if we have room to store it 
8ee6			 
8ee6					; TODO do string size test 
8ee6			 
8ee6					dec hl ; to over write cursor 
8ee6					ld (hl),a 
8ee6					inc hl 
8ee6					ld a,(cursor_shape) 
8ee6					ld (hl),a 
8ee6					inc hl 
8ee6					ld a,0 
8ee6					ld (hl),a 
8ee6			 
8ee6					ld (input_ptr),hl 
8ee6					 
8ee6					jr .instr1 
8ee6			.instrcr:	dec hl		; remove cursor 
8ee6					ld a,' '	; TODO add a trailing space for safety 
8ee6					ld (hl),a 
8ee6					inc hl 
8ee6					ld a,0 
8ee6					ld (hl),a 
8ee6			 
8ee6			 
8ee6					; if at end of line scroll up    
8ee6					; TODO detecting only end of line 4 for scroll up  
8ee6			 
8ee6					;ld   
8ee6			 
8ee6					ret 
8ee6			 
8ee6			 
8ee6			endif 
8ee6			; strcpy hl = dest, de source 
8ee6			 
8ee6 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8ee7 b7			            OR   A              ;Null terminator? 
8ee8 c8			            RET  Z              ;Yes, so finished 
8ee9 1a					ld a,(de) 
8eea 77					ld (hl),a 
8eeb 13			            INC  DE             ;Point to next character 
8eec 23					inc hl 
8eed 18 f7		            JR   strcpy       ;Repeat 
8eef c9					ret 
8ef0			 
8ef0			 
8ef0			; TODO string_at  
8ef0			; pass string which starts with lcd offset address and then null term string 
8ef0			 
8ef0			; TODO string to dec 
8ef0			; TODO string to hex 
8ef0			; TODO byte to string hex 
8ef0			; TODO byte to string dec 
8ef0			 
8ef0			 
8ef0			 
8ef0			; from z80uartmonitor 
8ef0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ef0			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8ef0			; pass hl for where to put the text 
8ef0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ef0 c5			hexout:	PUSH BC 
8ef1 f5					PUSH AF 
8ef2 47					LD B, A 
8ef3					; Upper nybble 
8ef3 cb 3f				SRL A 
8ef5 cb 3f				SRL A 
8ef7 cb 3f				SRL A 
8ef9 cb 3f				SRL A 
8efb cd 0b 8f				CALL tohex 
8efe 77					ld (hl),a 
8eff 23					inc hl	 
8f00					 
8f00					; Lower nybble 
8f00 78					LD A, B 
8f01 e6 0f				AND 0FH 
8f03 cd 0b 8f				CALL tohex 
8f06 77					ld (hl),a 
8f07 23					inc hl	 
8f08					 
8f08 f1					POP AF 
8f09 c1					POP BC 
8f0a c9					RET 
8f0b					 
8f0b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f0b			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8f0b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f0b			tohex: 
8f0b e5					PUSH HL 
8f0c d5					PUSH DE 
8f0d 16 00				LD D, 0 
8f0f 5f					LD E, A 
8f10 21 18 8f				LD HL, .DATA 
8f13 19					ADD HL, DE 
8f14 7e					LD A, (HL) 
8f15 d1					POP DE 
8f16 e1					POP HL 
8f17 c9					RET 
8f18			 
8f18			.DATA: 
8f18 30					DEFB	30h	; 0 
8f19 31					DEFB	31h	; 1 
8f1a 32					DEFB	32h	; 2 
8f1b 33					DEFB	33h	; 3 
8f1c 34					DEFB	34h	; 4 
8f1d 35					DEFB	35h	; 5 
8f1e 36					DEFB	36h	; 6 
8f1f 37					DEFB	37h	; 7 
8f20 38					DEFB	38h	; 8 
8f21 39					DEFB	39h	; 9 
8f22 41					DEFB	41h	; A 
8f23 42					DEFB	42h	; B 
8f24 43					DEFB	43h	; C 
8f25 44					DEFB	44h	; D 
8f26 45					DEFB	45h	; E 
8f27 46					DEFB	46h	; F 
8f28			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f28			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8f28			;;    subtract $30, if result > 9 then subtract $7 more 
8f28			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f28			atohex: 
8f28 d6 30				SUB $30 
8f2a fe 0a				CP 10 
8f2c f8					RET M		; If result negative it was 0-9 so we're done 
8f2d d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8f2f c9					RET		 
8f30			 
8f30			 
8f30			 
8f30			 
8f30			; Get 2 ASCII characters as hex byte from pointer in hl 
8f30			 
8f30			BYTERD: 
8f30 16 00			LD	D,00h		;Set up 
8f32 cd 3a 8f			CALL	HEXCON		;Get byte and convert to hex 
8f35 87				ADD	A,A		;First nibble so 
8f36 87				ADD	A,A		;multiply by 16 
8f37 87				ADD	A,A		; 
8f38 87				ADD	A,A		; 
8f39 57				LD	D,A		;Save hi nibble in D 
8f3a			HEXCON: 
8f3a 7e				ld a, (hl)		;Get next chr 
8f3b 23				inc hl 
8f3c d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8f3e fe 0a			CP	00Ah		;Is it 0-9 ? 
8f40 38 02			JR	C,NALPHA	;If so miss next bit 
8f42 d6 07			SUB	007h		;Else convert alpha 
8f44			NALPHA: 
8f44 b2				OR	D		;Add hi nibble back 
8f45 c9				RET			; 
8f46			 
8f46			 
8f46			; 
8f46			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8f46			; Since the routines get_byte and therefore get_nibble are called, only valid 
8f46			; characters (0-9a-f) are accepted. 
8f46			; 
8f46			;get_word        push    af 
8f46			;                call    get_byte        ; Get the upper byte 
8f46			;                ld      h, a 
8f46			;                call    get_byte        ; Get the lower byte 
8f46			;                ld      l, a 
8f46			;                pop     af 
8f46			;                ret 
8f46			; 
8f46			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8f46			; the routine get_nibble is used only valid characters are accepted - the  
8f46			; input routine only accepts characters 0-9a-f. 
8f46			; 
8f46 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8f47 7e					ld a,(hl) 
8f48 23					inc hl 
8f49 cd 6e 8f		                call    nibble2val      ; Get upper nibble 
8f4c cb 07		                rlc     a 
8f4e cb 07		                rlc     a 
8f50 cb 07		                rlc     a 
8f52 cb 07		                rlc     a 
8f54 47			                ld      b, a            ; Save upper four bits 
8f55 7e					ld a,(hl) 
8f56 cd 6e 8f		                call    nibble2val      ; Get lower nibble 
8f59 b0			                or      b               ; Combine both nibbles 
8f5a c1			                pop     bc              ; Restore B (and C) 
8f5b c9			                ret 
8f5c			; 
8f5c			; Get a hexadecimal digit from the serial line. This routine blocks until 
8f5c			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8f5c			; to the serial line interface. The lower 4 bits of A contain the value of  
8f5c			; that particular digit. 
8f5c			; 
8f5c			;get_nibble      ld a,(hl)           ; Read a character 
8f5c			;                call    to_upper        ; Convert to upper case 
8f5c			;                call    is_hex          ; Was it a hex digit? 
8f5c			;                jr      nc, get_nibble  ; No, get another character 
8f5c			 ;               call    nibble2val      ; Convert nibble to value 
8f5c			 ;               call    print_nibble 
8f5c			 ;               ret 
8f5c			; 
8f5c			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8f5c			; A valid hexadecimal digit is denoted by a set C flag. 
8f5c			; 
8f5c			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8f5c			;                ret     nc              ; Yes 
8f5c			;                cp      '0'             ; Less than '0'? 
8f5c			;                jr      nc, is_hex_1    ; No, continue 
8f5c			;                ccf                     ; Complement carry (i.e. clear it) 
8f5c			;                ret 
8f5c			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8f5c			;                ret     c               ; Yes 
8f5c			;                cp      'A'             ; Less than 'A'? 
8f5c			;                jr      nc, is_hex_2    ; No, continue 
8f5c			;                ccf                     ; Yes - clear carry and return 
8f5c			;                ret 
8f5c			;is_hex_2        scf                     ; Set carry 
8f5c			;                ret 
8f5c			; 
8f5c			; Convert a single character contained in A to upper case: 
8f5c			; 
8f5c fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8f5e d8			                ret     c 
8f5f fe 7b		                cp      'z' + 1         ; > 'z'? 
8f61 d0			                ret     nc              ; Nothing to do, either 
8f62 e6 5f		                and     $5f             ; Convert to upper case 
8f64 c9			                ret 
8f65			 
8f65			 
8f65			to_lower: 
8f65			 
8f65			   ; if char is in [A-Z] make it lower case 
8f65			 
8f65			   ; enter : a = char 
8f65			   ; exit  : a = lower case char 
8f65			   ; uses  : af 
8f65			 
8f65 fe 41		   cp 'A' 
8f67 d8			   ret c 
8f68			    
8f68 fe 5b		   cp 'Z'+1 
8f6a d0			   ret nc 
8f6b			    
8f6b f6 20		   or $20 
8f6d c9			   ret 
8f6e			 
8f6e			; 
8f6e			; Expects a hexadecimal digit (upper case!) in A and returns the 
8f6e			; corresponding value in A. 
8f6e			; 
8f6e fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8f70 38 02		                jr      c, nibble2val_1 ; Yes 
8f72 d6 07		                sub     7               ; Adjust for A-F 
8f74 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8f76 e6 0f		                and     $f              ; Only return lower 4 bits 
8f78 c9			                ret 
8f79			; 
8f79			; Print_nibble prints a single hex nibble which is contained in the lower  
8f79			; four bits of A: 
8f79			; 
8f79			;print_nibble    push    af              ; We won't destroy the contents of A 
8f79			;                and     $f              ; Just in case... 
8f79			;                add     a, '0'             ; If we have a digit we are done here. 
8f79			;                cp      '9' + 1         ; Is the result > 9? 
8f79			;                jr      c, print_nibble_1 
8f79			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8f79			;print_nibble_1  call    putc            ; Print the nibble and 
8f79			;                pop     af              ; restore the original value of A 
8f79			;                ret 
8f79			;; 
8f79			;; Send a CR/LF pair: 
8f79			; 
8f79			;crlf            push    af 
8f79			;                ld      a, cr 
8f79			;                call    putc 
8f79			;                ld      a, lf 
8f79			;                call    putc 
8f79			;                pop     af 
8f79			;                ret 
8f79			; 
8f79			; Print_word prints the four hex digits of a word to the serial line. The  
8f79			; word is expected to be in HL. 
8f79			; 
8f79			;print_word      push    hl 
8f79			;                push    af 
8f79			;                ld      a, h 
8f79			;                call    print_byte 
8f79			;                ld      a, l 
8f79			;                call    print_byte 
8f79			;                pop     af 
8f79			;                pop     hl 
8f79			;                ret 
8f79			; 
8f79			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8f79			; The byte to be printed is expected to be in A. 
8f79			; 
8f79			;print_byte      push    af              ; Save the contents of the registers 
8f79			;                push    bc 
8f79			;                ld      b, a 
8f79			;                rrca 
8f79			;                rrca 
8f79			;                rrca 
8f79			;                rrca 
8f79			;                call    print_nibble    ; Print high nibble 
8f79			;                ld      a, b 
8f79			;                call    print_nibble    ; Print low nibble 
8f79			;                pop     bc              ; Restore original register contents 
8f79			;                pop     af 
8f79			;                ret 
8f79			 
8f79			 
8f79			 
8f79			 
8f79			 
8f79			fourehexhl:  
8f79 7e				ld a,(hl) 
8f7a cd 28 8f			call atohex 
8f7d cb 3f				SRL A 
8f7f cb 3f				SRL A 
8f81 cb 3f				SRL A 
8f83 cb 3f				SRL A 
8f85 47				ld b, a 
8f86 23				inc hl 
8f87 7e				ld a,(hl) 
8f88 23				inc hl 
8f89 cd 28 8f			call atohex 
8f8c 80				add b 
8f8d 57				ld d,a 
8f8e 7e				ld a,(hl) 
8f8f cd 28 8f			call atohex 
8f92 cb 3f				SRL A 
8f94 cb 3f				SRL A 
8f96 cb 3f				SRL A 
8f98 cb 3f				SRL A 
8f9a 47				ld b, a 
8f9b 23				inc hl 
8f9c 7e				ld a,(hl) 
8f9d 23				inc hl 
8f9e cd 28 8f			call atohex 
8fa1 80				add b 
8fa2 5f				ld e, a 
8fa3 d5				push de 
8fa4 e1				pop hl 
8fa5 c9				ret 
8fa6			 
8fa6			; pass hl. returns z set if the byte at hl is a digit 
8fa6			;isdigithl:  
8fa6			;	push bc 
8fa6			;	ld a,(hl) 
8fa6			;	cp ':' 
8fa6			;	jr nc, .isdf 		; > 
8fa6			;	cp '0' 
8fa6			;	jr c, .isdf		; < 
8fa6			; 
8fa6			;	; TODO find a better way to set z 
8fa6			; 
8fa6			;	ld b,a 
8fa6			;	cp b 
8fa6			;	pop bc 
8fa6			;	ret 
8fa6			; 
8fa6			;.isdf:	; not digit so clear z 
8fa6			; 
8fa6			;	; TODO find a better way to unset z 
8fa6			; 
8fa6			;	ld b,a 
8fa6			;	inc b 
8fa6			;	cp b 
8fa6			; 
8fa6			;	pop bc 
8fa6			;	ret 
8fa6				 
8fa6				 
8fa6			 
8fa6			 
8fa6			; pass hl as the four byte address to load 
8fa6			 
8fa6			get_word_hl:  
8fa6 e5				push hl 
8fa7 cd 46 8f			call get_byte 
8faa				 
8faa 47				ld b, a 
8fab			 
8fab e1				pop hl 
8fac 23				inc hl 
8fad 23				inc hl 
8fae			 
8fae			; TODO not able to handle a-f  
8fae 7e				ld a,(hl) 
8faf			;	;cp ':' 
8faf			;	cp 'g' 
8faf			;	jr nc, .single_byte_hl 		; > 
8faf			;	cp 'G' 
8faf			;	jr nc, .single_byte_hl 		; > 
8faf			;	cp '0' 
8faf			;	jr c, .single_byte_hl		; < 
8faf			 
8faf				;call isdigithl 
8faf fe 00			cp 0 
8fb1 28 06			jr z, .single_byte_hl 
8fb3			 
8fb3			.getwhln:   ; hex word so get next byte 
8fb3			 
8fb3 cd 46 8f			call get_byte 
8fb6 6f				ld l, a 
8fb7 60				ld h,b 
8fb8 c9				ret 
8fb9 68			.single_byte_hl:   ld l,b 
8fba 26 00				ld h,0 
8fbc c9					ret 
8fbd			 
8fbd			 
8fbd			 
8fbd			 
8fbd 21 5d 97			ld hl,asc+1 
8fc0			;	ld a, (hl) 
8fc0			;	call nibble2val 
8fc0 cd 46 8f			call get_byte 
8fc3			 
8fc3			;	call fourehexhl 
8fc3 32 f5 e2			ld (scratch+52),a 
8fc6				 
8fc6 21 f3 e2			ld hl,scratch+50 
8fc9 22 e4 e5			ld (os_cur_ptr),hl 
8fcc			 
8fcc c9				ret 
8fcd			 
8fcd			 
8fcd			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8fcd			 
8fcd			; Decimal Unsigned Version 
8fcd			 
8fcd			;Number in a to decimal ASCII 
8fcd			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8fcd			;Example: display a=56 as "056" 
8fcd			;input: a = number 
8fcd			;Output: a=0,value of a in the screen 
8fcd			;destroys af,bc (don't know about hl and de) 
8fcd			DispAToASCII: 
8fcd 0e 9c			ld	c,-100 
8fcf cd d9 8f			call	.Na1 
8fd2 0e f6			ld	c,-10 
8fd4 cd d9 8f			call	.Na1 
8fd7 0e ff			ld	c,-1 
8fd9 06 2f		.Na1:	ld	b,'0'-1 
8fdb 04			.Na2:	inc	b 
8fdc 81				add	a,c 
8fdd 38 fc			jr	c,.Na2 
8fdf 91				sub	c		;works as add 100/10/1 
8fe0 f5				push af		;safer than ld c,a 
8fe1 78				ld	a,b		;char is in b 
8fe2			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8fe2 f1				pop af		;safer than ld a,c 
8fe3 c9				ret 
8fe4			 
8fe4			; Decimal Signed Version 
8fe4			 
8fe4			; DispA 
8fe4			; -------------------------------------------------------------- 
8fe4			; Converts a signed integer value to a zero-terminated ASCII 
8fe4			; string representative of that value (using radix 10). 
8fe4			; -------------------------------------------------------------- 
8fe4			; INPUTS: 
8fe4			;     HL     Value to convert (two's complement integer). 
8fe4			;     DE     Base address of string destination. (pointer). 
8fe4			; -------------------------------------------------------------- 
8fe4			; OUTPUTS: 
8fe4			;     None 
8fe4			; -------------------------------------------------------------- 
8fe4			; REGISTERS/MEMORY DESTROYED 
8fe4			; AF HL 
8fe4			; -------------------------------------------------------------- 
8fe4			 
8fe4			;DispHLToASCII: 
8fe4			;   push    de 
8fe4			;   push    bc 
8fe4			; 
8fe4			;; Detect sign of HL. 
8fe4			;    bit    7, h 
8fe4			;    jr     z, ._DoConvert 
8fe4			; 
8fe4			;; HL is negative. Output '-' to string and negate HL. 
8fe4			;    ld     a, '-' 
8fe4			;    ld     (de), a 
8fe4			;    inc    de 
8fe4			; 
8fe4			;; Negate HL (using two's complement) 
8fe4			;    xor    a 
8fe4			;    sub    l 
8fe4			;    ld     l, a 
8fe4			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8fe4			;    sbc    a, h 
8fe4			;    ld     h, a 
8fe4			; 
8fe4			;; Convert HL to digit characters 
8fe4			;._DoConvert: 
8fe4			;    ld     b, 0     ; B will count character length of number 
8fe4			;-   ld     a, 10 
8fe4			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8fe4			;    push   af 
8fe4			;    inc    b 
8fe4			;    ld     a, h 
8fe4			;    or     l 
8fe4			;    jr     nz, - 
8fe4			; 
8fe4			;; Retrieve digits from stack 
8fe4			;-   pop    af 
8fe4			;    or     $30 
8fe4			;    ld     (de), a 
8fe4			;    inc    de 
8fe4			;    djnz   - 
8fe4			; 
8fe4			;; Terminate string with NULL 
8fe4			;    xor    a 
8fe4			;    ld     (de), a 
8fe4			; 
8fe4			;    pop    bc 
8fe4			;    pop    de 
8fe4			;    ret 
8fe4			 
8fe4			;Comments 
8fe4			; 
8fe4			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8fe4			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8fe4			;    Note that the output string will not be fixed-width. 
8fe4			; 
8fe4			;Example Usage 
8fe4			; 
8fe4			;    ld    hl, -1004 
8fe4			;    ld    de, OP1 
8fe4			;    call  DispA 
8fe4			;    ld    hl, OP1 
8fe4			;    syscall  PutS 
8fe4			 
8fe4			 
8fe4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8fe4			 
8fe4			 
8fe4			;Converts an ASCII string to an unsigned 16-bit integer 
8fe4			;Quits when it reaches a non-decimal digit 
8fe4			 
8fe4			string_to_uint16: 
8fe4			atoui_16: 
8fe4			;Input: 
8fe4			;     DE points to the string 
8fe4			;Outputs: 
8fe4			;     HL is the result 
8fe4			;     A is the 8-bit value of the number 
8fe4			;     DE points to the byte after the number 
8fe4			;Destroys: 
8fe4			;     BC 
8fe4			;       if the string is non-empty, BC is HL/10 
8fe4			;Size:  24 bytes 
8fe4			;Speed: 42+d(104+{0,9}) 
8fe4			;       d is the number of digits in the number 
8fe4			;       max is 640 cycles for a 5 digit number 
8fe4			;Assuming no leading zeros: 
8fe4			;1 digit:  146cc 
8fe4			;2 digit:  250cc 
8fe4			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8fe4			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8fe4			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8fe4			;avg: 544.81158447265625cc (544+13297/16384) 
8fe4			;=============================================================== 
8fe4 21 00 00		  ld hl,0 
8fe7			.u16a: 
8fe7 1a			  ld a,(de) 
8fe8 d6 30		  sub 30h 
8fea fe 0a		  cp 10 
8fec d0			  ret nc 
8fed 13			  inc de 
8fee 44			  ld b,h 
8fef 4d			  ld c,l 
8ff0 29			  add hl,hl 
8ff1 29			  add hl,hl 
8ff2 09			  add hl,bc 
8ff3 29			  add hl,hl 
8ff4 85			  add a,l 
8ff5 6f			  ld l,a 
8ff6 30 ef		  jr nc,.u16a 
8ff8 24			  inc h 
8ff9 c3 e7 8f		  jp .u16a 
8ffc			 
8ffc			 
8ffc			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8ffc			 
8ffc			;written by Zeda 
8ffc			;Converts a 16-bit unsigned integer to an ASCII string. 
8ffc			 
8ffc			uitoa_16: 
8ffc			;Input: 
8ffc			;   DE is the number to convert 
8ffc			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8ffc			;Output: 
8ffc			;   HL points to the null-terminated ASCII string 
8ffc			;      NOTE: This isn't necessarily the same as the input HL. 
8ffc d5			  push de 
8ffd c5			  push bc 
8ffe f5			  push af 
8fff eb			  ex de,hl 
9000			 
9000 01 f0 d8		  ld bc,-10000 
9003 3e 2f		  ld a,'0'-1 
9005 3c			  inc a 
9006 09			  add hl,bc  
9007 38 fc		   jr c,$-2 
9009 12			  ld (de),a 
900a 13			  inc de 
900b			 
900b 01 e8 03		  ld bc,1000 
900e 3e 3a		  ld a,'9'+1 
9010 3d			  dec a  
9011 09			  add hl,bc  
9012 30 fc		   jr nc,$-2 
9014 12			  ld (de),a 
9015 13			  inc de 
9016			 
9016 01 9c ff		  ld bc,-100 
9019 3e 2f		  ld a,'0'-1 
901b 3c			  inc a  
901c 09			  add hl,bc  
901d 38 fc		   jr c,$-2 
901f 12			  ld (de),a 
9020 13			  inc de 
9021			 
9021 7d			  ld a,l 
9022 26 3a		  ld h,'9'+1 
9024 25			  dec h  
9025 c6 0a		  add a,10  
9027 30 fb		   jr nc,$-3 
9029 c6 30		  add a,'0' 
902b eb			  ex de,hl 
902c 72			  ld (hl),d 
902d 23			  inc hl 
902e 77			  ld (hl),a 
902f 23			  inc hl 
9030 36 00		  ld (hl),0 
9032			 
9032			;Now strip the leading zeros 
9032 0e fa		  ld c,-6 
9034 09			  add hl,bc 
9035 3e 30		  ld a,'0' 
9037 23			  inc hl  
9038 be			  cp (hl)  
9039 28 fc		  jr z,$-2 
903b			 
903b			;Make sure that the string is non-empty! 
903b 7e			  ld a,(hl) 
903c b7			  or a 
903d 20 01		  jr nz,.atoub 
903f 2b			  dec hl 
9040			.atoub: 
9040			 
9040 f1			  pop af 
9041 c1			  pop bc 
9042 d1			  pop de 
9043 c9			  ret 
9044			 
9044			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
9044			 
9044			toUpper: 
9044			;A is the char. 
9044			;If A is a lowercase letter, this sets it to the matching uppercase 
9044			;18cc or 30cc or 41cc 
9044			;avg: 26.75cc 
9044 fe 61		  cp 'a' 
9046 d8			  ret c 
9047 fe 7b		  cp 'z'+1 
9049 d0			  ret nc 
904a d6 20		  sub 'a'-'A' 
904c c9			  ret 
904d			 
904d			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
904d			 
904d			; String Length 
904d			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
904d			 
904d			; Get the length of the null-terminated string starting at $8000 hl 
904d			;    LD     HL, $8000 
904d			 
904d			strlenz: 
904d			 
904d af			    XOR    A               ; Zero is the value we are looking for. 
904e 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
904f 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
9050			                           ; 65, 536 bytes (the entire addressable memory space). 
9050 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9052			 
9052			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9052 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9053 6f			    LD     L, A             ; number of bytes 
9054 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9056 2b			    DEC    HL              ; Compensate for null. 
9057 c9				ret 
9058			 
9058			; Get the length of the A terminated string starting at $8000 hl 
9058			;    LD     HL, $8000 
9058			 
9058			strlent: 
9058			 
9058			                  ; A is the value we are looking for. 
9058 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
905a 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
905c			                           ; 65, 536 bytes (the entire addressable memory space). 
905c ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
905e			 
905e			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
905e 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
9060 2e 00		    LD     L, 0             ; number of bytes 
9062 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9064 2b			    DEC    HL              ; Compensate for null. 
9065 c9				ret 
9066			 
9066			 
9066			;Comparing Strings 
9066			 
9066			;IN    HL     Address of string1. 
9066			;      DE     Address of string2. 
9066			 
9066			; doc given but wrong??? 
9066			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9066			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9066			; tested 
9066			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9066			 
9066			strcmp_old: 
9066 e5			    PUSH   HL 
9067 d5			    PUSH   DE 
9068			 
9068 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
9069 be			    CP     (HL)            ; (want to minimize work). 
906a 38 01		    JR     C, Str1IsBigger 
906c 7e			    LD     A, (HL) 
906d			 
906d			Str1IsBigger: 
906d 4f			    LD     C, A             ; Put length in BC 
906e 06 00		    LD     B, 0 
9070 13			    INC    DE              ; Increment pointers to meat of string. 
9071 23			    INC    HL 
9072			 
9072			CmpLoop: 
9072 1a			    LD     A, (DE)          ; Compare bytes. 
9073 ed a1		    CPI 
9075 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
9077 13			    INC    DE              ; Update pointer. 
9078 ea 72 90		    JP     PE, CmpLoop 
907b			 
907b d1			    POP    DE 
907c e1			    POP    HL 
907d 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
907e be			    CP     (HL) 
907f c9			    RET 
9080			 
9080			NoMatch: 
9080 2b			    DEC    HL 
9081 be			    CP     (HL)            ; Compare again to affect carry. 
9082 d1			    POP    DE 
9083 e1			    POP    HL 
9084 c9			    RET 
9085			 
9085			;; test strmp 
9085			; 
9085			;ld de, .str1 
9085			;ld hl, .str2 
9085			;call strcmp 
9085			;jr z, .z1 
9085			;;this 
9085			;	if DEBUG_FORTH_WORDS 
9085			;		DMARK "NZ1" 
9085			;		CALLMONITOR 
9085			;	endif 
9085			;.z1: 
9085			; 
9085			;	if DEBUG_FORTH_WORDS 
9085			;		DMARK "ZZ1" 
9085			;		CALLMONITOR 
9085			;	endif 
9085			; 
9085			;ld de, .str1 
9085			;ld hl, .str1 
9085			;call strcmp 
9085			;jr z, .z2 
9085			;;this 
9085			;	if DEBUG_FORTH_WORDS 
9085			;		DMARK "NZ2" 
9085			;		CALLMONITOR 
9085			;	endif 
9085			;.z2: 
9085			; 
9085			;	if DEBUG_FORTH_WORDS 
9085			;		DMARK "ZZ2" 
9085			;		CALLMONITOR 
9085			;	endif 
9085			; 
9085			;ld de, .str1 
9085			;ld hl, .str2 
9085			;call strcmp 
9085			;jr c, .c1 
9085			; 
9085			;	if DEBUG_FORTH_WORDS 
9085			;		DMARK "Nc1" 
9085			;		CALLMONITOR 
9085			;	endif 
9085			;.c1: 
9085			;;this 
9085			;	if DEBUG_FORTH_WORDS 
9085			;		DMARK "cc1" 
9085			;		CALLMONITOR 
9085			;	endif 
9085			; 
9085			;ld de, .str1 
9085			;ld hl, .str1 
9085			;call strcmp 
9085			;jr c, .c2 
9085			;;this 
9085			;	if DEBUG_FORTH_WORDS 
9085			;		DMARK "Nc2" 
9085			;		CALLMONITOR 
9085			;	endif 
9085			;.c2: 
9085			; 
9085			;	if DEBUG_FORTH_WORDS 
9085			;		DMARK "cc2" 
9085			;		CALLMONITOR 
9085			;	endif 
9085			;	NEXTW 
9085			;.str1:   db "string1",0 
9085			;.str2:   db "string2",0 
9085			 
9085			; only care about direct match or not 
9085			; hl and de strings 
9085			; zero set if the same 
9085			 
9085			strcmp: 
9085 1a				ld a, (de) 
9086 be				cp (hl) 
9087 28 02			jr z, .ssame 
9089 b7				or a 
908a c9				ret 
908b			 
908b			.ssame:  
908b fe 00			cp 0 
908d c8				ret z 
908e			 
908e 23				inc hl 
908f 13				inc de 
9090 18 f3			jr strcmp 
9092				 
9092				 
9092			 
9092			;Copyright (c) 2014, Luke Maurits 
9092			;All rights reserved. 
9092			; 
9092			;Redistribution and use in source and binary forms, with or without 
9092			;modification, are permitted provided that the following conditions are met: 
9092			; 
9092			;* Redistributions of source code must retain the above copyright notice, this 
9092			;  list of conditions and the following disclaimer. 
9092			; 
9092			;* Redistributions in binary form must reproduce the above copyright notice, 
9092			;  this list of conditions and the following disclaimer in the documentation 
9092			;  and/or other materials provided with the distribution. 
9092			; 
9092			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
9092			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
9092			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
9092			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
9092			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
9092			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
9092			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
9092			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
9092			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
9092			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
9092			 
9092			; https://github.com/lmaurits/lm512/blob/master/string.z80 
9092			 
9092			StrictStrCmp: 
9092				; Load next chars of each string 
9092 1a				ld a, (de) 
9093 47				ld b, a 
9094 7e				ld a, (hl) 
9095				; Compare 
9095 b8				cp b 
9096				; Return non-zero if chars don't match 
9096 c0				ret nz 
9097				; Check for end of both strings 
9097 fe 00			cp "\0" 
9099				; Return if strings have ended 
9099 c8				ret z 
909a				; Otherwise, advance to next chars 
909a 23				inc hl 
909b 13				inc de 
909c 18 f4			jr StrictStrCmp 
909e			 
909e			;end 
909e			; eof 
909e			 
909e			 
909e			 
909e			 
909e			 
909e			 
# End of file firmware_strings.asm
909e			include "firmware_memory.asm"   ; malloc and free  
909e			 
909e			if DEBUG_FORTH_MALLOC_HIGH 
909e			.mallocsize: db "Wants malloc >256",0 
909e			.mallocasize: db "MALLOC gives >256",0 
909e			.malloczero: db "MALLOC gives zero",0 
909e			 
909e			malloc_guard_zerolen: 
909e				push hl 
909e				push de 
909e				push af 
909e			 
909e				ld de, 0 
909e			        call cmp16 
909e				jr nz, .lowalloz 
909e			 
909e				push hl 
909e				push de 
909e					ld hl, display_fb0 
909e					ld (display_fb_active), hl 
909e				call clear_display 
909e				ld a, 0 
909e				ld de, .malloczero 
909e				call str_at_display 
909e				call update_display 
909e				call delay1s 
909e				call delay1s 
909e				call bp_on 
909e			;	ld a, 0 
909e			;	ld (os_view_disable), a 
909e			 
909e				pop de 
909e				pop hl 
909e			 
909e				 
909e			 
909e				CALLMONITOR 
909e			.lowalloz: 
909e			 
909e			 
909e				pop af 
909e				pop de 
909e				pop hl 
909e			ret 
909e			 
909e			malloc_guard_entry: 
909e				push hl 
909e				push de 
909e				push af 
909e			 
909e			 	or a      ;clear carry flag 
909e				push hl 
909e				ld de, 255 
909e				sbc hl, de 
909e				jr c, .lowalloc 
909e			 
909e				push de 
909e					ld hl, display_fb0 
909e					ld (display_fb_active), hl 
909e				call clear_display 
909e				ld a, 0 
909e				ld de, .mallocsize 
909e				call str_at_display 
909e				call update_display 
909e				call delay1s 
909e				call delay1s 
909e			;	ld a, 0 
909e			;	ld (os_view_disable), a 
909e				call bp_on 
909e			 
909e				pop de 
909e				pop hl 
909e			 
909e				 
909e			 
909e				CALLMONITOR 
909e				jr .lowdone 
909e			.lowalloc: 
909e			 
909e			 
909e				pop hl 
909e			.lowdone:	pop af 
909e				pop de 
909e				pop hl 
909e			ret 
909e			 
909e			malloc_guard_exit: 
909e				push hl 
909e				push de 
909e				push af 
909e			 
909e			 	or a      ;clear carry flag 
909e				push hl 
909e				ld de, 255 
909e				sbc hl, de 
909e				jr c, .lowallocx 
909e			 
909e				push de 
909e					ld hl, display_fb0 
909e					ld (display_fb_active), hl 
909e				call clear_display 
909e				ld a, 0 
909e				ld de, .mallocasize 
909e				call str_at_display 
909e				call update_display 
909e				call delay1s 
909e				call delay1s 
909e			;	ld a, 0 
909e			;	ld (os_view_disable), a 
909e				call bp_on 
909e				pop de 
909e				pop hl 
909e			 
909e				CALLMONITOR 
909e				jr .lowdonex 
909e			.lowallocx: 
909e			 
909e				pop hl 
909e			.lowdonex:	pop af 
909e				pop de 
909e				pop hl 
909e			ret 
909e			endif 
909e			 
909e			if MALLOC_2 
909e			; Z80 Malloc and Free Functions 
909e			 
909e			; Malloc Function: 
909e			; Input: 
909e			;   HL: Size of block to allocate 
909e			; Output: 
909e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
909e			 
909e			malloc: 
909e				 
909e			if DEBUG_FORTH_MALLOC_HIGH 
909e			call malloc_guard_entry 
909e			endif 
909e			 
909e			 
909e			 
909e			 
909e					if DEBUG_FORTH_MALLOC 
909e						DMARK "mal" 
909e						CALLMONITOR 
909e					endif 
909e			    push af            ; Save AF register 
909e			    ld a, l            ; Load low byte of size into A 
909e			    or h               ; Check if size is zero 
909e			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
909e			 
909e			    ; Allocate memory 
909e			    ld hl, (heap_start) ; Load start of heap into HL 
909e					if DEBUG_FORTH_MALLOC 
909e						DMARK "ma1" 
909e						CALLMONITOR 
909e					endif 
909e			    call malloc_internal ; Call internal malloc function 
909e			    pop af             ; Restore AF register 
909e			if DEBUG_FORTH_MALLOC_HIGH 
909e			call malloc_guard_exit 
909e			call malloc_guard_zerolen 
909e			endif 
909e			    ret                ; Return 
909e			 
909e			; Free Function: 
909e			; Input: 
909e			;   HL: Pointer to memory block to free 
909e			; Output: 
909e			;   None 
909e			 
909e			free: 
909e			    push af            ; Save AF register 
909e			    ld a, l            ; Load low byte of pointer into A 
909e			    or h               ; Check if pointer is NULL 
909e			    jp z, free_exit    ; If pointer is NULL, exit 
909e			 
909e			    ; Free memory 
909e			    ld hl, (heap_start) ; Load start of heap into HL 
909e			    call free_internal  ; Call internal free function 
909e			    pop af             ; Restore AF register 
909e			    ret                ; Return 
909e			 
909e			; Internal Malloc Function: 
909e			; Input: 
909e			;   HL: Size of block to allocate 
909e			; Output: 
909e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
909e			 
909e			malloc_internal: 
909e			    ld bc, 2           ; Number of bytes to allocate for management overhead 
909e			    add hl, bc         ; Add management overhead to requested size 
909e			    ex de, hl          ; Save total size in DE, and keep it in HL 
909e					if DEBUG_FORTH_MALLOC 
909e						DMARK "ma2" 
909e						CALLMONITOR 
909e					endif 
909e			 
909e			    ; Search for free memory block 
909e			    ld de, (heap_end)  ; Load end of heap into DE 
909e			    ld bc, 0           ; Initialize counter 
909e			 
909e					if DEBUG_FORTH_MALLOC 
909e						DMARK "ma2" 
909e						CALLMONITOR 
909e					endif 
909e			malloc_search_loop: 
909e			    ; Check if current block is free 
909e			    ld a, (hl)         ; Load current block's status (free or used) 
909e			    cp 0               ; Compare with zero (free) 
909e			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
909e			 
909e			    ; Check if current block is large enough 
909e			    ld a, (hl+1)       ; Load high byte of block size 
909e			    cp l               ; Compare with low byte of requested size 
909e			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
909e			 
909e			    ld a, (hl+2)       ; Load low byte of block size 
909e			    cp h               ; Compare with high byte of requested size 
909e			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
909e			 
909e			    ; Mark block as used 
909e			    ld (hl), 0xFF      ; Set status byte to indicate used block 
909e			 
909e			    ; Calculate remaining space in block 
909e			    ld bc, 0           ; Clear BC 
909e			    add hl, bc         ; Increment HL to point to start of data block 
909e			    add hl, de         ; HL = HL + DE (total size) 
909e			    ld bc, 1           ; Number of bytes to allocate for management overhead 
909e			    add hl, bc         ; Add management overhead to start of data block 
909e			 
909e			    ; Save pointer to allocated block in HL 
909e			if DEBUG_FORTH_MALLOC_HIGH 
909e						DMARK "ma5" 
909e			call malloc_guard_exit 
909e			call malloc_guard_zerolen 
909e			endif 
909e			    ret 
909e			 
909e			malloc_skip_block_check: 
909e			    ; Move to the next block 
909e			    ld bc, 3           ; Size of management overhead 
909e			    add hl, bc         ; Move to the next block 
909e			    inc de             ; Increment counter 
909e			 
909e			    ; Check if we have reached the end of heap 
909e			    ld a, e            ; Load low byte of heap end address 
909e			    cp (hl)            ; Compare with low byte of current address 
909e			    jr nz, malloc_search_loop  ; If not equal, continue searching 
909e			    ld a, d            ; Load high byte of heap end address 
909e			    cp 0               ; Check if it's zero (end of memory) 
909e			    jr nz, malloc_search_loop  ; If not zero, continue searching 
909e			 
909e			    ; If we reached here, allocation failed 
909e			    xor a              ; Set result to NULL 
909e			if DEBUG_FORTH_MALLOC_HIGH 
909e						DMARK "ma6" 
909e			call malloc_guard_exit 
909e			call malloc_guard_zerolen 
909e			endif 
909e			    ret 
909e			malloc_exit: 
909e			if DEBUG_FORTH_MALLOC_HIGH 
909e						DMARK "ma7" 
909e			call malloc_guard_exit 
909e			call malloc_guard_zerolen 
909e			endif 
909e			    ret 
909e			 
909e			; Internal Free Function: 
909e			; Input: 
909e			;   HL: Pointer to memory block to free 
909e			; Output: 
909e			;   None 
909e			 
909e			free_internal: 
909e			    ld de, (heap_start) ; Load start of heap into DE 
909e			    ld bc, 0            ; Initialize counter 
909e			 
909e			free_search_loop: 
909e			    ; Check if current block contains the pointer 
909e			    ld a, l             ; Load low byte of pointer 
909e			    cp (hl+1)           ; Compare with high byte of current block's address 
909e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
909e			    ld a, h             ; Load high byte of pointer 
909e			    cp (hl+2)           ; Compare with low byte of current block's address 
909e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
909e			 
909e			    ; Mark block as free 
909e			    ld (hl), 0          ; Set status byte to indicate free block 
909e			    ret                 ; Return 
909e			 
909e			free_skip_block_check: 
909e			    ; Move to the next block 
909e			    ld bc, 3            ; Size of management overhead 
909e			    add hl, bc          ; Move to the next block 
909e			    inc de              ; Increment counter 
909e			 
909e			    ; Check if we have reached the end of heap 
909e			    ld a, e             ; Load low byte of heap end address 
909e			    cp (hl)             ; Compare with low byte of current address 
909e			    jr nz, free_search_loop  ; If not equal, continue searching 
909e			    ld a, d             ; Load high byte of heap end address 
909e			    cp 0                ; Check if it's zero (end of memory) 
909e			    jr nz, free_search_loop  ; If not zero, continue searching 
909e			 
909e			    ; If we reached here, pointer is not found in heap 
909e			    ret 
909e			 
909e			free_exit: 
909e			    ret                 ; Return 
909e			 
909e			; Define heap start and end addresses 
909e			;heap_start:    .dw 0xC000   ; Start of heap 
909e			;heap_end:      .dw 0xE000   ; End of heap 
909e			 
909e			endif 
909e			 
909e			 
909e			if MALLOC_1 
909e			 
909e			 
909e			 
909e			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
909e			 
909e			;moved to firmware.asm 
909e			;heap_start        .equ  0x9000      ; Starting address of heap 
909e			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
909e			 
909e			;      .org 0 
909e			;      jp    main 
909e			 
909e			 
909e			;      .org  0x100 
909e			;main: 
909e			;      ld    HL, 0x8100 
909e			;      ld    SP, HL 
909e			; 
909e			;      call  heap_init 
909e			; 
909e			;      ; Make some allocations 
909e			;      ld    HL, 12 
909e			;      call  malloc            ; Allocates 0x9004 
909e			; 
909e			;      ld    HL, 12 
909e			;      call  malloc            ; Allocates 0x9014 
909e			; 
909e			;      ld    HL, 12 
909e			;      call  malloc            ; Allocates 0x9024 
909e			; 
909e			;      ; Free some allocations 
909e			;      ld    HL, 0x9014 
909e			;      call  free 
909e			; 
909e			;      ld    HL, 0x9004 
909e			;      call  free 
909e			; 
909e			;      ld    HL, 0x9024 
909e			;      call  free 
909e			; 
909e			; 
909e			;      halt 
909e			 
909e			 
909e			;------------------------------------------------------------------------------ 
909e			;     heap_init                                                               : 
909e			;                                                                             : 
909e			; Description                                                                 : 
909e			;     Initialise the heap and make it ready for malloc and free operations.   : 
909e			;                                                                             : 
909e			;     The heap is maintained as a linked list, starting with an initial       : 
909e			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
909e			;     the first free block in the heap. Each block then points to the next    : 
909e			;     free block within the heap, and the free list ends at the first block   : 
909e			;     with a null pointer to the next free block.                             : 
909e			;                                                                             : 
909e			; Parameters                                                                  : 
909e			;     Inputs are compile-time only. Two defines which specify the starting    : 
909e			;     address of the heap and its size are required, along with a memory      : 
909e			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
909e			;     principally stores a pointer to the first free block in the heap.       : 
909e			;                                                                             : 
909e			; Returns                                                                     : 
909e			;     Nothing                                                                 : 
909e			;------------------------------------------------------------------------------ 
909e			heap_init: 
909e e5			      push  HL 
909f			 
909f			      ; Initialise free list struct 
909f 21 35 dd		      ld    HL, heap_start 
90a2 22 30 dd		      ld    (free_list), HL 
90a5 21 00 00		      ld    HL, 0 
90a8 22 32 dd		      ld    (free_list+2), HL 
90ab			 
90ab			      ; Insert first free block at bottom of heap, consumes entire heap 
90ab 21 98 e2		      ld    HL, heap_start+heap_size-4 
90ae 22 35 dd		      ld    (heap_start), HL        ; Next block (end of free list) 
90b1 21 63 05		      ld    HL, heap_size-4 
90b4 22 37 dd		      ld    (heap_start+2), HL      ; Block size 
90b7			 
90b7			      ; Insert end of free list block at top of heap - two null words will 
90b7			      ; terminate the free list 
90b7 21 00 00		      ld    HL, 0 
90ba 22 9a e2		      ld    (heap_start+heap_size-2), HL 
90bd 22 98 e2		      ld    (heap_start+heap_size-4), HL 
90c0			 
90c0 e1			      pop   HL 
90c1			 
90c1 c9			      ret 
90c2			 
90c2			 
90c2			;------------------------------------------------------------------------------ 
90c2			;     malloc                                                                  : 
90c2			;                                                                             : 
90c2			; Description                                                                 : 
90c2			;     Allocates the wanted space from the heap and returns the address of the : 
90c2			;     first useable byte of the allocation.                                   : 
90c2			;                                                                             : 
90c2			;     Allocations can happen in one of two ways:                              : 
90c2			;                                                                             : 
90c2			;     1. A free block may be found which is the exact size wanted. In this    : 
90c2			;        case the block is removed from the free list and retuedn to the      : 
90c2			;        caller.                                                              : 
90c2			;     2. A free block may be found which is larger than the size wanted. In   : 
90c2			;        this case, the larger block is split into two. The first portion of  : 
90c2			;        this block will become the requested space by the malloc call and    : 
90c2			;        is returned to the caller. The second portion becomes a new free     : 
90c2			;        block, and the free list is adjusted to maintain continuity via this : 
90c2			;        newly created block.                                                 : 
90c2			;                                                                             : 
90c2			;     malloc does not set any initial value in the allocated space, the       : 
90c2			;     caller is required to do this as required.                              : 
90c2			;                                                                             : 
90c2			;     This implementation of malloc uses the stack exclusively, and is        : 
90c2			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
90c2			;     advisable to disable interrupts before calling malloc, and recommended  : 
90c2			;     to avoid the use of malloc inside ISRs in general.                      : 
90c2			;                                                                             : 
90c2			;     NOTE: heap_init must be called before malloc and free can be used.      : 
90c2			;                                                                             : 
90c2			; Parameters                                                                  : 
90c2			;     HL  Number of bytes wanted                                              : 
90c2			;                                                                             : 
90c2			; Returns                                                                     : 
90c2			;     HL  Address of the first useable byte of the allocation                 : 
90c2			;                                                                             : 
90c2			; Flags                                                                       : 
90c2			;     Z   Set if the allocation did not succeed, clear otherwise              : 
90c2			;                                                                             : 
90c2			; Stack frame                                                                 : 
90c2			;       |             |                                                       : 
90c2			;       +-------------+                                                       : 
90c2			;       |     BC      |                                                       : 
90c2			;       +-------------+                                                       : 
90c2			;       |     DE      |                                                       : 
90c2			;       +-------------+                                                       : 
90c2			;       |     IX      |                                                       : 
90c2			;       +-------------+                                                       : 
90c2			;       |  prev_free  |                                                       : 
90c2			;   +4  +-------------+                                                       : 
90c2			;       |  this_free  |                                                       : 
90c2			;   +2  +-------------+                                                       : 
90c2			;       |  next_free  |                                                       : 
90c2			;   +0  +-------------+                                                       : 
90c2			;       |             |                                                       : 
90c2			;                                                                             : 
90c2			;------------------------------------------------------------------------------ 
90c2			 
90c2			 
90c2			;malloc: 
90c2			; 
90c2			;	SAVESP ON 1 
90c2			; 
90c2			;	call malloc_code 
90c2			; 
90c2			;	CHECKSP ON 1 
90c2			;	ret 
90c2			 
90c2			 
90c2			malloc: 
90c2 c5			      push  BC 
90c3 d5			      push  DE 
90c4 dd e5		      push  IX 
90c6			if DEBUG_FORTH_MALLOC_HIGH 
90c6			call malloc_guard_entry 
90c6			endif 
90c6			 
90c6					if DEBUG_FORTH_MALLOC 
90c6						DMARK "mal" 
90c6						CALLMONITOR 
90c6					endif 
90c6 7c			      ld    A, H                    ; Exit if no space requested 
90c7 b5			      or    L 
90c8 ca 87 91		      jp    Z, malloc_early_exit 
90cb			 
90cb			;inc hl 
90cb			;inc hl 
90cb			;inc hl 
90cb			; 
90cb			;inc hl 
90cb			;inc hl 
90cb			;inc hl 
90cb			;inc hl 
90cb			;inc hl 
90cb			;inc hl 
90cb			;inc hl 
90cb			;inc hl 
90cb			;inc hl 
90cb			 
90cb			 
90cb			 
90cb			 
90cb					if DEBUG_FORTH_MALLOC 
90cb						DMARK "maA" 
90cb						CALLMONITOR 
90cb					endif 
90cb			      ; Set up stack frame 
90cb eb			      ex    DE, HL 
90cc 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
90cf 39			      add   HL, SP 
90d0 f9			      ld    SP, HL 
90d1 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
90d5 dd 39		      add   IX, SP 
90d7			 
90d7			      ; Setup initial state 
90d7 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
90da 19			      add   HL, DE 
90db			 
90db 44			      ld    B, H                    ; Move want to BC 
90dc 4d			      ld    C, L 
90dd			 
90dd 21 30 dd		      ld    HL, free_list           ; Store prev_free ptr to stack 
90e0 dd 75 04		      ld    (IX+4), L 
90e3 dd 74 05		      ld    (IX+5), H 
90e6			 
90e6 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
90e7 23			      inc   HL 
90e8 56			      ld    D, (HL) 
90e9 dd 73 02		      ld    (IX+2), E 
90ec dd 72 03		      ld    (IX+3), D 
90ef eb			      ex    DE, HL                  ; this_free ptr into HL 
90f0			 
90f0					if DEBUG_FORTH_MALLOC 
90f0						DMARK "maB" 
90f0						CALLMONITOR 
90f0					endif 
90f0			      ; Loop through free block list to find some space 
90f0			malloc_find_space: 
90f0 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
90f1 23			      inc   HL 
90f2 56			      ld    D, (HL) 
90f3			 
90f3 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
90f4 b3			      or    E 
90f5 ca 81 91		      jp    Z, malloc_no_space 
90f8			 
90f8 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
90fb dd 72 01		      ld    (IX+1), D 
90fe			 
90fe			      ; Does this block have enough space to make the allocation? 
90fe 23			      inc   HL                      ; Load free block size into DE 
90ff 5e			      ld    E, (HL) 
9100 23			      inc   HL 
9101 56			      ld    D, (HL) 
9102			 
9102 eb			      ex    DE, HL                  ; Check size of block against want 
9103 b7			      or    A                       ; Ensure carry flag clear 
9104 ed 42		      sbc   HL, BC 
9106 e5			      push  HL                      ; Store the result for later (new block size) 
9107			 
9107 ca 56 91		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
910a 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
910c			 
910c			      ; this_free block is not big enough, setup ptrs to test next free block 
910c e1			      pop   HL                      ; Discard previous result 
910d			 
910d dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9110 dd 66 03		      ld    H, (IX+3) 
9113 dd 75 04		      ld    (IX+4), L 
9116 dd 74 05		      ld    (IX+5), H 
9119			 
9119 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
911c dd 66 01		      ld    H, (IX+1) 
911f dd 75 02		      ld    (IX+2), L 
9122 dd 74 03		      ld    (IX+3), H 
9125			 
9125					if DEBUG_FORTH_MALLOC 
9125						DMARK "MA>" 
9125						CALLMONITOR 
9125					endif 
9125 18 c9		      jr    malloc_find_space 
9127			 
9127			      ; split a bigger block into two - requested size and remaining size 
9127			malloc_alloc_split: 
9127					if DEBUG_FORTH_MALLOC 
9127						DMARK "MAs" 
9127						CALLMONITOR 
9127					endif 
9127 eb			      ex    DE, HL                  ; Calculate address of new free block 
9128 2b			      dec   HL 
9129 2b			      dec   HL 
912a 2b			      dec   HL 
912b 09			      add   HL, BC 
912c			 
912c			      ; Create a new block and point it at next_free 
912c dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
912f dd 56 01		      ld    D, (IX+1) 
9132			 
9132 73			      ld    (HL), E                 ; Store next_free ptr into new block 
9133 23			      inc   HL 
9134 72			      ld    (HL), D 
9135			 
9135 d1			      pop   DE                      ; Store size of new block into new block 
9136 23			      inc   HL 
9137 73			      ld    (HL), E 
9138 23			      inc   HL 
9139 72			      ld    (HL), D 
913a			 
913a			      ; Update this_free ptr to point to new block 
913a 2b			      dec   HL 
913b 2b			      dec   HL 
913c 2b			      dec   HL 
913d			 
913d dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9140 dd 56 03		      ld    D, (IX+3) 
9143			 
9143 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9146 dd 74 03		      ld    (IX+3), H 
9149			 
9149			      ; Modify this_free block to be allocation 
9149 eb			      ex    DE, HL 
914a af			      xor   A                       ; Null the next block ptr of allocated block 
914b 77			      ld    (HL), A 
914c 23			      inc   HL 
914d 77			      ld    (HL), A 
914e			 
914e 23			      inc   HL                      ; Store want size into allocated block 
914f 71			      ld    (HL), C 
9150 23			      inc   HL 
9151 70			      ld    (HL), B 
9152 23			      inc   HL 
9153 e5			      push  HL                      ; Address of allocation to return 
9154			 
9154 18 19		      jr    malloc_update_links 
9156			 
9156			malloc_alloc_fit: 
9156 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
9157			 
9157					if DEBUG_FORTH_MALLOC 
9157						DMARK "MAf" 
9157						CALLMONITOR 
9157					endif 
9157			      ; Modify this_free block to be allocation 
9157 eb			      ex    DE, HL 
9158 2b			      dec   HL 
9159 2b			      dec   HL 
915a 2b			      dec   HL 
915b			 
915b af			      xor   A                       ; Null the next block ptr of allocated block 
915c 77			      ld    (HL), A 
915d 23			      inc   HL 
915e 77			      ld    (HL), A 
915f			 
915f 23			      inc   HL                      ; Store address of allocation to return 
9160 23			      inc   HL 
9161 23			      inc   HL 
9162 e5			      push  HL 
9163			 
9163			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9163 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9166 dd 66 01		      ld    H, (IX+1) 
9169			 
9169 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
916c dd 74 03		      ld    (IX+3), H 
916f			 
916f			 
916f			malloc_update_links: 
916f			      ; Update prev_free ptr to point to this_free 
916f dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9172 dd 66 05		      ld    H, (IX+5) 
9175			 
9175 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9178 dd 56 03		      ld    D, (IX+3) 
917b			 
917b 73			      ld    (HL), E                 ; this_free ptr into prev_free 
917c 23			      inc   HL 
917d 72			      ld    (HL), D 
917e			 
917e					if DEBUG_FORTH_MALLOC 
917e						DMARK "Mul" 
917e						CALLMONITOR 
917e					endif 
917e			      ; Clear the Z flag to indicate successful allocation 
917e 7a			      ld    A, D 
917f b3			      or    E 
9180			 
9180 d1			      pop   DE                      ; Address of allocation 
9181					if DEBUG_FORTH_MALLOC 
9181						DMARK "MAu" 
9181						CALLMONITOR 
9181					endif 
9181			 
9181			malloc_no_space: 
9181 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9184 39			      add   HL, SP 
9185 f9			      ld    SP, HL 
9186			 
9186 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9187					if DEBUG_FORTH_MALLOC 
9187						DMARK "MAN" 
9187						CALLMONITOR 
9187					endif 
9187			 
9187			malloc_early_exit: 
9187					if DEBUG_FORTH_MALLOC 
9187						DMARK "MAx" 
9187						CALLMONITOR 
9187					endif 
9187 dd e1		      pop   IX 
9189 d1			      pop   DE 
918a c1			      pop   BC 
918b			 
918b			if DEBUG_FORTH_MALLOC_HIGH 
918b			call malloc_guard_exit 
918b			call malloc_guard_zerolen 
918b			endif 
918b c9			      ret 
918c			 
918c			 
918c			;------------------------------------------------------------------------------ 
918c			;     free                                                                    : 
918c			;                                                                             : 
918c			; Description                                                                 : 
918c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
918c			;     returned by malloc, otherwise the behaviour is undefined.               : 
918c			;                                                                             : 
918c			;     Where possible, directly adjacent free blocks will be merged together   : 
918c			;     into larger blocks to help ensure that the heap does not become         : 
918c			;     excessively fragmented.                                                 : 
918c			;                                                                             : 
918c			;     free does not clear or set any other value into the freed space, and    : 
918c			;     therefore its contents may be visible through subsequent malloc's. The  : 
918c			;     caller should clear the freed space as required.                        : 
918c			;                                                                             : 
918c			;     This implementation of free uses the stack exclusively, and is          : 
918c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
918c			;     advisable to disable interrupts before calling free, and recommended    : 
918c			;     to avoid the use of free inside ISRs in general.                        : 
918c			;                                                                             : 
918c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
918c			;                                                                             : 
918c			; Parameters                                                                  : 
918c			;     HL  Pointer to address of first byte of allocation to be freed          : 
918c			;                                                                             : 
918c			; Returns                                                                     : 
918c			;     Nothing                                                                 : 
918c			;                                                                             : 
918c			; Stack frame                                                                 : 
918c			;       |             |                                                       : 
918c			;       +-------------+                                                       : 
918c			;       |     BC      |                                                       : 
918c			;       +-------------+                                                       : 
918c			;       |     DE      |                                                       : 
918c			;       +-------------+                                                       : 
918c			;       |     IX      |                                                       : 
918c			;       +-------------+                                                       : 
918c			;       |  prev_free  |                                                       : 
918c			;   +2  +-------------+                                                       : 
918c			;       |  next_free  |                                                       : 
918c			;   +0  +-------------+                                                       : 
918c			;       |             |                                                       : 
918c			;                                                                             : 
918c			;------------------------------------------------------------------------------ 
918c			free: 
918c c5			      push  BC 
918d d5			      push  DE 
918e dd e5		      push  IX 
9190			 
9190 7c			      ld    A, H                    ; Exit if ptr is null 
9191 b5			      or    L 
9192 ca 56 92		      jp    Z, free_early_exit 
9195			 
9195			      ; Set up stack frame 
9195 eb			      ex    DE, HL 
9196 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9199 39			      add   HL, SP 
919a f9			      ld    SP, HL 
919b dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
919f dd 39		      add   IX, SP 
91a1			 
91a1			      ; The address in HL points to the start of the useable allocated space, 
91a1			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
91a1			      ; address of the block itself. 
91a1 eb			      ex    DE, HL 
91a2 11 fc ff		      ld    DE, -4 
91a5 19			      add   HL, DE 
91a6			 
91a6			      ; An allocated block must have a null next block pointer in it 
91a6 7e			      ld    A, (HL) 
91a7 23			      inc   HL 
91a8 b6			      or    (HL) 
91a9 c2 51 92		      jp    NZ, free_done 
91ac			 
91ac 2b			      dec   HL 
91ad			 
91ad 44			      ld    B, H                    ; Copy HL to BC 
91ae 4d			      ld    C, L 
91af			 
91af			      ; Loop through the free list to find the first block with an address 
91af			      ; higher than the block being freed 
91af 21 30 dd		      ld    HL, free_list 
91b2			 
91b2			free_find_higher_block: 
91b2 5e			      ld    E, (HL)                 ; Load next ptr from free block 
91b3 23			      inc   HL 
91b4 56			      ld    D, (HL) 
91b5 2b			      dec   HL 
91b6			 
91b6 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
91b9 dd 72 01		      ld    (IX+1), D 
91bc dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
91bf dd 74 03		      ld    (IX+3), H 
91c2			 
91c2 78			      ld    A, B                    ; Check if DE is greater than BC 
91c3 ba			      cp    D                       ; Compare MSB first 
91c4 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
91c6 30 04		      jr    NC, free_find_higher_block_skip 
91c8 79			      ld    A, C 
91c9 bb			      cp    E                       ; Then compare LSB 
91ca 38 08		      jr    C, free_found_higher_block 
91cc			 
91cc			free_find_higher_block_skip: 
91cc 7a			      ld    A, D                    ; Reached the end of the free list? 
91cd b3			      or    E 
91ce ca 51 92		      jp    Z, free_done 
91d1			 
91d1 eb			      ex    DE, HL 
91d2			 
91d2 18 de		      jr    free_find_higher_block 
91d4			 
91d4			free_found_higher_block: 
91d4			      ; Insert freed block between prev and next free blocks 
91d4 71			      ld    (HL), C                 ; Point prev free block to freed block 
91d5 23			      inc   HL 
91d6 70			      ld    (HL), B 
91d7			 
91d7 60			      ld    H, B                    ; Point freed block at next free block 
91d8 69			      ld    L, C 
91d9 73			      ld    (HL), E 
91da 23			      inc   HL 
91db 72			      ld    (HL), D 
91dc			 
91dc			      ; Check if the freed block is adjacent to the next free block 
91dc 23			      inc   HL                      ; Load size of freed block into HL 
91dd 5e			      ld    E, (HL) 
91de 23			      inc   HL 
91df 56			      ld    D, (HL) 
91e0 eb			      ex    DE, HL 
91e1			 
91e1 09			      add   HL, BC                  ; Add addr of freed block and its size 
91e2			 
91e2 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
91e5 dd 56 01		      ld    D, (IX+1) 
91e8			 
91e8 b7			      or    A                       ; Clear the carry flag 
91e9 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
91eb 20 22		      jr    NZ, free_check_adjacent_to_prev 
91ed			 
91ed			      ; Freed block is adjacent to next, merge into one bigger block 
91ed eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
91ee 5e			      ld    E, (HL) 
91ef 23			      inc   HL 
91f0 56			      ld    D, (HL) 
91f1 e5			      push  HL                      ; Save ptr to next block for later 
91f2			 
91f2 60			      ld    H, B                    ; Store ptr from next block into freed block 
91f3 69			      ld    L, C 
91f4 73			      ld    (HL), E 
91f5 23			      inc   HL 
91f6 72			      ld    (HL), D 
91f7			 
91f7 e1			      pop   HL                      ; Restore ptr to next block 
91f8 23			      inc   HL                      ; Load size of next block into DE 
91f9 5e			      ld    E, (HL) 
91fa 23			      inc   HL 
91fb 56			      ld    D, (HL) 
91fc d5			      push  DE                      ; Save next block size for later 
91fd			 
91fd 60			      ld    H, B                    ; Load size of freed block into HL 
91fe 69			      ld    L, C 
91ff 23			      inc   HL 
9200 23			      inc   HL 
9201 5e			      ld    E, (HL) 
9202 23			      inc   HL 
9203 56			      ld    D, (HL) 
9204 eb			      ex    DE, HL 
9205			 
9205 d1			      pop   DE                      ; Restore size of next block 
9206 19			      add   HL, DE                  ; Add sizes of both blocks 
9207 eb			      ex    DE, HL 
9208			 
9208 60			      ld    H, B                    ; Store new bigger size into freed block 
9209 69			      ld    L, C 
920a 23			      inc   HL 
920b 23			      inc   HL 
920c 73			      ld    (HL), E 
920d 23			      inc   HL 
920e 72			      ld    (HL), D 
920f			 
920f			free_check_adjacent_to_prev: 
920f			      ; Check if the freed block is adjacent to the prev free block 
920f dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
9212 dd 66 03		      ld    H, (IX+3) 
9215			 
9215 23			      inc   HL                      ; Size of prev free block into DE 
9216 23			      inc   HL 
9217 5e			      ld    E, (HL) 
9218 23			      inc   HL 
9219 56			      ld    D, (HL) 
921a 2b			      dec   HL 
921b 2b			      dec   HL 
921c 2b			      dec   HL 
921d			 
921d 19			      add   HL, DE                  ; Add prev block addr and size 
921e			 
921e b7			      or    A                       ; Clear the carry flag 
921f ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9221 20 2e		      jr    NZ, free_done 
9223			 
9223			      ; Freed block is adjacent to prev, merge into one bigger block 
9223 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9224 69			      ld    L, C 
9225 5e			      ld    E, (HL) 
9226 23			      inc   HL 
9227 56			      ld    D, (HL) 
9228 e5			      push  HL                      ; Save freed block ptr for later 
9229			 
9229 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
922c dd 66 03		      ld    H, (IX+3) 
922f 73			      ld    (HL), E 
9230 23			      inc   HL 
9231 72			      ld    (HL), D 
9232			 
9232 e1			      pop   HL                      ; Restore freed block ptr 
9233 23			      inc   HL                      ; Load size of freed block into DE 
9234 5e			      ld    E, (HL) 
9235 23			      inc   HL 
9236 56			      ld    D, (HL) 
9237 d5			      push  DE                      ; Save freed block size for later 
9238			 
9238 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
923b dd 66 03		      ld    H, (IX+3) 
923e 23			      inc   HL 
923f 23			      inc   HL 
9240 5e			      ld    E, (HL) 
9241 23			      inc   HL 
9242 56			      ld    D, (HL) 
9243			 
9243 e1			      pop   HL                      ; Add sizes of both blocks 
9244 19			      add   HL, DE 
9245 eb			      ex    DE, HL 
9246			 
9246 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
9249 dd 66 03		      ld    H, (IX+3) 
924c 23			      inc   HL 
924d 23			      inc   HL 
924e 73			      ld    (HL), E 
924f 23			      inc   HL 
9250 72			      ld    (HL), D 
9251			 
9251			free_done: 
9251 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9254 39			      add   HL, SP 
9255 f9			      ld    SP, HL 
9256			 
9256			free_early_exit: 
9256 dd e1		      pop   IX 
9258 d1			      pop   DE 
9259 c1			      pop   BC 
925a			 
925a c9			      ret 
925b			 
925b			; moved to firmware.asm 
925b			; 
925b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
925b			;                  .dw   0 
925b			 
925b			 
925b			endif 
925b			 
925b			 
925b			if MALLOC_3 
925b			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
925b			;heap_start        .equ  0x9000      ; Starting address of heap 
925b			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
925b			; 
925b			 ;     .org 0 
925b			  ;    jp    main 
925b			; 
925b			; 
925b			 ;     .org  0x100 
925b			;main: 
925b			 ;     ld    HL, 0x8100 
925b			  ;    ld    SP, HL 
925b			; 
925b			;      call  heap_init 
925b			 
925b			      ; Make some allocations 
925b			;      ld    HL, 12 
925b			;      call  malloc            ; Allocates 0x9004 
925b			; 
925b			 ;     ld    HL, 12 
925b			;      call  malloc            ; Allocates 0x9014 
925b			 
925b			;      ld    HL, 12 
925b			;      call  malloc            ; Allocates 0x9024 
925b			 
925b			      ; Free some allocations 
925b			;      ld    HL, 0x9014 
925b			;      call  free 
925b			 
925b			;      ld    HL, 0x9004 
925b			;      call  free 
925b			; 
925b			;      ld    HL, 0x9024 
925b			;      call  free 
925b			 
925b			 
925b			 ;     halt 
925b			 
925b			 
925b			;------------------------------------------------------------------------------ 
925b			;     heap_init                                                               : 
925b			;                                                                             : 
925b			; Description                                                                 : 
925b			;     Initialise the heap and make it ready for malloc and free operations.   : 
925b			;                                                                             : 
925b			;     The heap is maintained as a linked list, starting with an initial       : 
925b			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
925b			;     the first free block in the heap. Each block then points to the next    : 
925b			;     free block within the heap, and the free list ends at the first block   : 
925b			;     with a null pointer to the next free block.                             : 
925b			;                                                                             : 
925b			; Parameters                                                                  : 
925b			;     Inputs are compile-time only. Two defines which specify the starting    : 
925b			;     address of the heap and its size are required, along with a memory      : 
925b			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
925b			;     principally stores a pointer to the first free block in the heap.       : 
925b			;                                                                             : 
925b			; Returns                                                                     : 
925b			;     Nothing                                                                 : 
925b			;------------------------------------------------------------------------------ 
925b			heap_init: 
925b			      push  HL 
925b			 
925b			      ; Initialise free list struct 
925b			      ld    HL, heap_start 
925b			      ld    (free_list), HL 
925b			      ld    HL, 0 
925b			      ld    (free_list+2), HL 
925b			 
925b			      ; Insert first free block at bottom of heap, consumes entire heap 
925b			      ld    HL, heap_start+heap_size-4 
925b			      ld    (heap_start), HL        ; Next block (end of free list) 
925b			      ld    HL, heap_size-4 
925b			      ld    (heap_start+2), HL      ; Block size 
925b			 
925b			      ; Insert end of free list block at top of heap - two null words will 
925b			      ; terminate the free list 
925b			      ld    HL, 0 
925b			      ld    (heap_start+heap_size-2), HL 
925b			      ld    (heap_start+heap_size-4), HL 
925b			 
925b			      pop   HL 
925b			 
925b			      ret 
925b			 
925b			 
925b			;------------------------------------------------------------------------------ 
925b			;     malloc                                                                  : 
925b			;                                                                             : 
925b			; Description                                                                 : 
925b			;     Allocates the wanted space from the heap and returns the address of the : 
925b			;     first useable byte of the allocation.                                   : 
925b			;                                                                             : 
925b			;     Allocations can happen in one of two ways:                              : 
925b			;                                                                             : 
925b			;     1. A free block may be found which is the exact size wanted. In this    : 
925b			;        case the block is removed from the free list and retuedn to the      : 
925b			;        caller.                                                              : 
925b			;     2. A free block may be found which is larger than the size wanted. In   : 
925b			;        this case, the larger block is split into two. The first portion of  : 
925b			;        this block will become the requested space by the malloc call and    : 
925b			;        is returned to the caller. The second portion becomes a new free     : 
925b			;        block, and the free list is adjusted to maintain continuity via this : 
925b			;        newly created block.                                                 : 
925b			;                                                                             : 
925b			;     malloc does not set any initial value in the allocated space, the       : 
925b			;     caller is required to do this as required.                              : 
925b			;                                                                             : 
925b			;     This implementation of malloc uses the stack exclusively, and is        : 
925b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
925b			;     advisable to disable interrupts before calling malloc, and recommended  : 
925b			;     to avoid the use of malloc inside ISRs in general.                      : 
925b			;                                                                             : 
925b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
925b			;                                                                             : 
925b			; Parameters                                                                  : 
925b			;     HL  Number of bytes wanted                                              : 
925b			;                                                                             : 
925b			; Returns                                                                     : 
925b			;     HL  Address of the first useable byte of the allocation                 : 
925b			;                                                                             : 
925b			; Flags                                                                       : 
925b			;     Z   Set if the allocation did not succeed, clear otherwise              : 
925b			;                                                                             : 
925b			; Stack frame                                                                 : 
925b			;       |             |                                                       : 
925b			;       +-------------+                                                       : 
925b			;       |     BC      |                                                       : 
925b			;       +-------------+                                                       : 
925b			;       |     DE      |                                                       : 
925b			;       +-------------+                                                       : 
925b			;       |     IX      |                                                       : 
925b			;       +-------------+                                                       : 
925b			;       |  prev_free  |                                                       : 
925b			;   +4  +-------------+                                                       : 
925b			;       |  this_free  |                                                       : 
925b			;   +2  +-------------+                                                       : 
925b			;       |  next_free  |                                                       : 
925b			;   +0  +-------------+                                                       : 
925b			;       |             |                                                       : 
925b			;                                                                             : 
925b			;------------------------------------------------------------------------------ 
925b			malloc: 
925b			      push  BC 
925b			      push  DE 
925b			      push  IX 
925b			 
925b			      ld    A, H                    ; Exit if no space requested 
925b			      or    L 
925b			      jp    Z, malloc_early_exit 
925b			 
925b			      ; Set up stack frame 
925b			      ex    DE, HL 
925b			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
925b			      add   HL, SP 
925b			      ld    SP, HL 
925b			      ld    IX, 0                   ; Use IX as a frame pointer 
925b			      add   IX, SP 
925b			 
925b			      ; Setup initial state 
925b			      ld    HL, 4                   ; want must also include space used by block struct 
925b			      add   HL, DE 
925b			 
925b			      ld    B, H                    ; Move want to BC 
925b			      ld    C, L 
925b			 
925b			      ld    HL, free_list           ; Store prev_free ptr to stack 
925b			      ld    (IX+4), L 
925b			      ld    (IX+5), H 
925b			 
925b			      ld    E, (HL)                 ; Store this_free ptr to stack 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			      ld    (IX+2), E 
925b			      ld    (IX+3), D 
925b			      ex    DE, HL                  ; this_free ptr into HL 
925b			 
925b			      ; Loop through free block list to find some space 
925b			malloc_find_space: 
925b			      ld    E, (HL)                 ; Load next_free ptr into DE 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			 
925b			      ld    A, D                    ; Check for null next_free ptr - end of free list 
925b			      or    E 
925b			      jp    Z, malloc_no_space 
925b			 
925b			      ld    (IX+0), E               ; Store next_free ptr to stack 
925b			      ld    (IX+1), D 
925b			 
925b			      ; Does this block have enough space to make the allocation? 
925b			      inc   HL                      ; Load free block size into DE 
925b			      ld    E, (HL) 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			 
925b			      ex    DE, HL                  ; Check size of block against want 
925b			      or    A                       ; Ensure carry flag clear 
925b			      sbc   HL, BC 
925b			      push  HL                      ; Store the result for later (new block size) 
925b			 
925b			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
925b			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
925b			 
925b			      ; this_free block is not big enough, setup ptrs to test next free block 
925b			      pop   HL                      ; Discard previous result 
925b			 
925b			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
925b			      ld    H, (IX+3) 
925b			      ld    (IX+4), L 
925b			      ld    (IX+5), H 
925b			 
925b			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
925b			      ld    H, (IX+1) 
925b			      ld    (IX+2), L 
925b			      ld    (IX+3), H 
925b			 
925b			      jr    malloc_find_space 
925b			 
925b			      ; split a bigger block into two - requested size and remaining size 
925b			malloc_alloc_split: 
925b			      ex    DE, HL                  ; Calculate address of new free block 
925b			      dec   HL 
925b			      dec   HL 
925b			      dec   HL 
925b			      add   HL, BC 
925b			 
925b			      ; Create a new block and point it at next_free 
925b			      ld    E, (IX+0)               ; Load next_free ptr into DE 
925b			      ld    D, (IX+1) 
925b			 
925b			      ld    (HL), E                 ; Store next_free ptr into new block 
925b			      inc   HL 
925b			      ld    (HL), D 
925b			 
925b			      pop   DE                      ; Store size of new block into new block 
925b			      inc   HL 
925b			      ld    (HL), E 
925b			      inc   HL 
925b			      ld    (HL), D 
925b			 
925b			      ; Update this_free ptr to point to new block 
925b			      dec   HL 
925b			      dec   HL 
925b			      dec   HL 
925b			 
925b			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
925b			      ld    D, (IX+3) 
925b			 
925b			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
925b			      ld    (IX+3), H 
925b			 
925b			      ; Modify this_free block to be allocation 
925b			      ex    DE, HL 
925b			      xor   A                       ; Null the next block ptr of allocated block 
925b			      ld    (HL), A 
925b			      inc   HL 
925b			      ld    (HL), A 
925b			 
925b			      inc   HL                      ; Store want size into allocated block 
925b			      ld    (HL), C 
925b			      inc   HL 
925b			      ld    (HL), B 
925b			      inc   HL 
925b			      push  HL                      ; Address of allocation to return 
925b			 
925b			      jr    malloc_update_links 
925b			 
925b			malloc_alloc_fit: 
925b			      pop   HL                      ; Dont need new block size, want is exact fit 
925b			 
925b			      ; Modify this_free block to be allocation 
925b			      ex    DE, HL 
925b			      dec   HL 
925b			      dec   HL 
925b			      dec   HL 
925b			 
925b			      xor   A                       ; Null the next block ptr of allocated block 
925b			      ld    (HL), A 
925b			      inc   HL 
925b			      ld    (HL), A 
925b			 
925b			      inc   HL                      ; Store address of allocation to return 
925b			      inc   HL 
925b			      inc   HL 
925b			      push  HL 
925b			 
925b			      ; Copy next_free ptr to this_free, remove allocated block from free list 
925b			      ld    L, (IX+0)               ; next_free to HL 
925b			      ld    H, (IX+1) 
925b			 
925b			      ld    (IX+2), L               ; HL to this_free 
925b			      ld    (IX+3), H 
925b			 
925b			 
925b			malloc_update_links: 
925b			      ; Update prev_free ptr to point to this_free 
925b			      ld    L, (IX+4)               ; prev_free ptr to HL 
925b			      ld    H, (IX+5) 
925b			 
925b			      ld    E, (IX+2)               ; this_free ptr to DE 
925b			      ld    D, (IX+3) 
925b			 
925b			      ld    (HL), E                 ; this_free ptr into prev_free 
925b			      inc   HL 
925b			      ld    (HL), D 
925b			 
925b			      ; Clear the Z flag to indicate successful allocation 
925b			      ld    A, D 
925b			      or    E 
925b			 
925b			      pop   DE                      ; Address of allocation 
925b			 
925b			malloc_no_space: 
925b			      ld    HL, 6                   ; Clean up stack frame 
925b			      add   HL, SP 
925b			      ld    SP, HL 
925b			 
925b			      ex    DE, HL                  ; Alloc addr into HL for return 
925b			 
925b			malloc_early_exit: 
925b			      pop   IX 
925b			      pop   DE 
925b			      pop   BC 
925b			 
925b			      ret 
925b			 
925b			 
925b			;------------------------------------------------------------------------------ 
925b			;     free                                                                    : 
925b			;                                                                             : 
925b			; Description                                                                 : 
925b			;     Return the space pointed to by HL to the heap. HL must be an address as : 
925b			;     returned by malloc, otherwise the behaviour is undefined.               : 
925b			;                                                                             : 
925b			;     Where possible, directly adjacent free blocks will be merged together   : 
925b			;     into larger blocks to help ensure that the heap does not become         : 
925b			;     excessively fragmented.                                                 : 
925b			;                                                                             : 
925b			;     free does not clear or set any other value into the freed space, and    : 
925b			;     therefore its contents may be visible through subsequent malloc's. The  : 
925b			;     caller should clear the freed space as required.                        : 
925b			;                                                                             : 
925b			;     This implementation of free uses the stack exclusively, and is          : 
925b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
925b			;     advisable to disable interrupts before calling free, and recommended    : 
925b			;     to avoid the use of free inside ISRs in general.                        : 
925b			;                                                                             : 
925b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
925b			;                                                                             : 
925b			; Parameters                                                                  : 
925b			;     HL  Pointer to address of first byte of allocation to be freed          : 
925b			;                                                                             : 
925b			; Returns                                                                     : 
925b			;     Nothing                                                                 : 
925b			;                                                                             : 
925b			; Stack frame                                                                 : 
925b			;       |             |                                                       : 
925b			;       +-------------+                                                       : 
925b			;       |     BC      |                                                       : 
925b			;       +-------------+                                                       : 
925b			;       |     DE      |                                                       : 
925b			;       +-------------+                                                       : 
925b			;       |     IX      |                                                       : 
925b			;       +-------------+                                                       : 
925b			;       |  prev_free  |                                                       : 
925b			;   +2  +-------------+                                                       : 
925b			;       |  next_free  |                                                       : 
925b			;   +0  +-------------+                                                       : 
925b			;       |             |                                                       : 
925b			;                                                                             : 
925b			;------------------------------------------------------------------------------ 
925b			free: 
925b			      push  BC 
925b			      push  DE 
925b			      push  IX 
925b			 
925b			      ld    A, H                    ; Exit if ptr is null 
925b			      or    L 
925b			      jp    Z, free_early_exit 
925b			 
925b			      ; Set up stack frame 
925b			      ex    DE, HL 
925b			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
925b			      add   HL, SP 
925b			      ld    SP, HL 
925b			      ld    IX, 0                   ; Use IX as a frame pointer 
925b			      add   IX, SP 
925b			 
925b			      ; The address in HL points to the start of the useable allocated space, 
925b			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
925b			      ; address of the block itself. 
925b			      ex    DE, HL 
925b			      ld    DE, -4 
925b			      add   HL, DE 
925b			 
925b			      ; An allocated block must have a null next block pointer in it 
925b			      ld    A, (HL) 
925b			      inc   HL 
925b			      or    (HL) 
925b			      jp    NZ, free_done 
925b			 
925b			      dec   HL 
925b			 
925b			      ld    B, H                    ; Copy HL to BC 
925b			      ld    C, L 
925b			 
925b			      ; Loop through the free list to find the first block with an address 
925b			      ; higher than the block being freed 
925b			      ld    HL, free_list 
925b			 
925b			free_find_higher_block: 
925b			      ld    E, (HL)                 ; Load next ptr from free block 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			      dec   HL 
925b			 
925b			      ld    (IX+0), E               ; Save ptr to next free block 
925b			      ld    (IX+1), D 
925b			      ld    (IX+2), L               ; Save ptr to prev free block 
925b			      ld    (IX+3), H 
925b			 
925b			      ld    A, B                    ; Check if DE is greater than BC 
925b			      cp    D                       ; Compare MSB first 
925b			      jr    Z, $+4                  ; MSB the same, compare LSB 
925b			      jr    NC, free_find_higher_block_skip 
925b			      ld    A, C 
925b			      cp    E                       ; Then compare LSB 
925b			      jr    C, free_found_higher_block 
925b			 
925b			free_find_higher_block_skip: 
925b			      ld    A, D                    ; Reached the end of the free list? 
925b			      or    E 
925b			      jp    Z, free_done 
925b			 
925b			      ex    DE, HL 
925b			 
925b			      jr    free_find_higher_block 
925b			 
925b			free_found_higher_block: 
925b			      ; Insert freed block between prev and next free blocks 
925b			      ld    (HL), C                 ; Point prev free block to freed block 
925b			      inc   HL 
925b			      ld    (HL), B 
925b			 
925b			      ld    H, B                    ; Point freed block at next free block 
925b			      ld    L, C 
925b			      ld    (HL), E 
925b			      inc   HL 
925b			      ld    (HL), D 
925b			 
925b			      ; Check if the freed block is adjacent to the next free block 
925b			      inc   HL                      ; Load size of freed block into HL 
925b			      ld    E, (HL) 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			      ex    DE, HL 
925b			 
925b			      add   HL, BC                  ; Add addr of freed block and its size 
925b			 
925b			      ld    E, (IX+0)               ; Load addr of next free block into DE 
925b			      ld    D, (IX+1) 
925b			 
925b			      or    A                       ; Clear the carry flag 
925b			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
925b			      jr    NZ, free_check_adjacent_to_prev 
925b			 
925b			      ; Freed block is adjacent to next, merge into one bigger block 
925b			      ex    DE, HL                  ; Load next ptr from next block into DE 
925b			      ld    E, (HL) 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			      push  HL                      ; Save ptr to next block for later 
925b			 
925b			      ld    H, B                    ; Store ptr from next block into freed block 
925b			      ld    L, C 
925b			      ld    (HL), E 
925b			      inc   HL 
925b			      ld    (HL), D 
925b			 
925b			      pop   HL                      ; Restore ptr to next block 
925b			      inc   HL                      ; Load size of next block into DE 
925b			      ld    E, (HL) 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			      push  DE                      ; Save next block size for later 
925b			 
925b			      ld    H, B                    ; Load size of freed block into HL 
925b			      ld    L, C 
925b			      inc   HL 
925b			      inc   HL 
925b			      ld    E, (HL) 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			      ex    DE, HL 
925b			 
925b			      pop   DE                      ; Restore size of next block 
925b			      add   HL, DE                  ; Add sizes of both blocks 
925b			      ex    DE, HL 
925b			 
925b			      ld    H, B                    ; Store new bigger size into freed block 
925b			      ld    L, C 
925b			      inc   HL 
925b			      inc   HL 
925b			      ld    (HL), E 
925b			      inc   HL 
925b			      ld    (HL), D 
925b			 
925b			free_check_adjacent_to_prev: 
925b			      ; Check if the freed block is adjacent to the prev free block 
925b			      ld    L, (IX+2)               ; Prev free block ptr into HL 
925b			      ld    H, (IX+3) 
925b			 
925b			      inc   HL                      ; Size of prev free block into DE 
925b			      inc   HL 
925b			      ld    E, (HL) 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			      dec   HL 
925b			      dec   HL 
925b			      dec   HL 
925b			 
925b			      add   HL, DE                  ; Add prev block addr and size 
925b			 
925b			      or    A                       ; Clear the carry flag 
925b			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
925b			      jr    NZ, free_done 
925b			 
925b			      ; Freed block is adjacent to prev, merge into one bigger block 
925b			      ld    H, B                    ; Load next ptr from freed block into DE 
925b			      ld    L, C 
925b			      ld    E, (HL) 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			      push  HL                      ; Save freed block ptr for later 
925b			 
925b			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
925b			      ld    H, (IX+3) 
925b			      ld    (HL), E 
925b			      inc   HL 
925b			      ld    (HL), D 
925b			 
925b			      pop   HL                      ; Restore freed block ptr 
925b			      inc   HL                      ; Load size of freed block into DE 
925b			      ld    E, (HL) 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			      push  DE                      ; Save freed block size for later 
925b			 
925b			      ld    L, (IX+2)               ; Load size of prev block into DE 
925b			      ld    H, (IX+3) 
925b			      inc   HL 
925b			      inc   HL 
925b			      ld    E, (HL) 
925b			      inc   HL 
925b			      ld    D, (HL) 
925b			 
925b			      pop   HL                      ; Add sizes of both blocks 
925b			      add   HL, DE 
925b			      ex    DE, HL 
925b			 
925b			      ld    L, (IX+2)               ; Store new bigger size into prev block 
925b			      ld    H, (IX+3) 
925b			      inc   HL 
925b			      inc   HL 
925b			      ld    (HL), E 
925b			      inc   HL 
925b			      ld    (HL), D 
925b			 
925b			free_done: 
925b			      ld    HL, 4                   ; Clean up stack frame 
925b			      add   HL, SP 
925b			      ld    SP, HL 
925b			 
925b			free_early_exit: 
925b			      pop   IX 
925b			      pop   DE 
925b			      pop   BC 
925b			 
925b			      ret 
925b			 
925b			 
925b			;      .org 0x8000 
925b			; 
925b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
925b			 ;                 .dw   0 
925b			 
925b			endif 
925b			 
925b			 
925b			if MALLOC_4 
925b			 
925b			; My memory allocation code. Very very simple.... 
925b			; allocate space under 250 chars 
925b			 
925b			heap_init: 
925b				; init start of heap as zero 
925b				;  
925b			 
925b				ld hl, heap_start 
925b				ld a, 0 
925b				ld (hl), a      ; empty block 
925b				inc hl 
925b				ld a, 0 
925b				ld (hl), a      ; length of block 
925b				; write end of list 
925b				inc hl 
925b				ld a,(hl) 
925b				inc hl 
925b				ld a,(hl) 
925b				 
925b			 
925b				; init some malloc vars 
925b			 
925b				ld hl, 0 
925b				ld (free_list), hl       ; store last malloc location 
925b			 
925b				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
925b				ld a, 0 
925b				ld (hl), a 
925b			 
925b			 
925b				ld hl, heap_start 
925b				;  
925b				  
925b				ret 
925b			 
925b			 
925b			;    free block marker 
925b			;    requested size  
925b			;    pointer to next block 
925b			;    .... 
925b			;    next block marker 
925b			 
925b			 
925b			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
925b			; 
925b			 
925b			 
925b			malloc:  
925b				push de 
925b				push bc 
925b				push af 
925b			 
925b				; hl space required 
925b				 
925b				ld c, l    ; hold space   (TODO only a max of 255) 
925b			 
925b			;	inc c     ; TODO BUG need to fix memory leak on push str 
925b			;	inc c 
925b			;	inc c 
925b			;	inc c 
925b			;	inc c 
925b			;	inc c 
925b			;	inc c 
925b			 
925b			 
925b			 
925b				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
925b			 
925b				ld a, (free_list+3) 
925b				cp 0 
925b				jr z, .contheap 
925b			 
925b				ld hl, (free_list)     ; get last alloc 
925b					if DEBUG_FORTH_MALLOC_INT 
925b						DMARK "mrs" 
925b						CALLMONITOR 
925b					endif 
925b				jr .startalloc 
925b			 
925b			.contheap: 
925b				ld hl, heap_start 
925b			 
925b			.startalloc: 
925b			 
925b					if DEBUG_FORTH_MALLOC_INT 
925b						DMARK "mym" 
925b						CALLMONITOR 
925b					endif 
925b			.findblock: 
925b					if DEBUG_FORTH_MALLOC_INT 
925b						DMARK "mmf" 
925b						CALLMONITOR 
925b					endif 
925b			 
925b				ld a,(hl)  
925b				; if byte is zero then clear to use 
925b			 
925b				cp 0 
925b				jr z, .foundemptyblock 
925b			 
925b				; if byte is not clear 
925b				;     then byte is offset to next block 
925b			 
925b				inc hl 
925b				ld a, (hl) ; get size 
925b			.nextblock:	inc hl 
925b					ld e, (hl) 
925b					inc hl 
925b					ld d, (hl) 
925b					ex de, hl 
925b			;	inc hl  ; move past the store space 
925b			;	inc hl  ; move past zero index  
925b			 
925b				; TODO detect no more space 
925b			 
925b				push hl 
925b				ld de, heap_end 
925b				call cmp16 
925b				pop hl 
925b				jr nc, .nospace 
925b			 
925b				jr .findblock 
925b			 
925b			.nospace: ld hl, 0 
925b				jp .exit 
925b			 
925b			 
925b			.foundemptyblock:	 
925b					if DEBUG_FORTH_MALLOC_INT 
925b						DMARK "mme" 
925b						CALLMONITOR 
925b					endif 
925b			 
925b			; TODO has block enough space if reusing??? 
925b			 
925b				;  
925b			 
925b			; see if this block has been previously used 
925b				inc hl 
925b				ld a, (hl) 
925b				dec hl 
925b				cp 0 
925b				jr z, .newblock 
925b			 
925b					if DEBUG_FORTH_MALLOC_INT 
925b						DMARK "meR" 
925b						CALLMONITOR 
925b					endif 
925b			 
925b			; no reusing previously allocated block 
925b			 
925b			; is it smaller than previously used? 
925b				 
925b				inc hl    ; move to size 
925b				ld a, c 
925b				sub (hl)        ; we want c < (hl) 
925b				dec hl    ; move back to marker 
925b			        jr z, .findblock 
925b			 
925b				; update with the new size which should be lower 
925b			 
925b			        ;inc  hl   ; negate next move. move back to size  
925b			 
925b			.newblock: 
925b				; need to be at marker here 
925b			 
925b					if DEBUG_FORTH_MALLOC_INT 
925b						DMARK "meN" 
925b						CALLMONITOR 
925b					endif 
925b			 
925b			 
925b				ld a, c 
925b			 
925b				ld (free_list+3), a	 ; flag resume from last malloc  
925b				ld (free_list), hl    ; save out last location 
925b			 
925b			 
925b				;inc a     ; space for length byte 
925b				ld (hl), a     ; save block in use marker 
925b			 
925b				inc hl   ; move to space marker 
925b				ld (hl), a    ; save new space 
925b			 
925b				inc hl   ; move to start of allocated area 
925b				 
925b			;	push hl     ; save where we are - 1  
925b			 
925b			;	inc hl  ; move past zero index  
925b				; skip space to set down new marker 
925b			 
925b				; provide some extra space for now 
925b			 
925b				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
925b				inc a 
925b				inc a 
925b			 
925b				push hl   ; save where we are in the node block 
925b			 
925b				call addatohl 
925b			 
925b				; write linked list point 
925b			 
925b				pop de     ; get our node position 
925b				ex de, hl 
925b			 
925b				ld (hl), e 
925b				inc hl 
925b				ld (hl), d 
925b			 
925b				inc hl 
925b			 
925b				; now at start of allocated data so save pointer 
925b			 
925b				push hl 
925b			 
925b				; jump to position of next node and setup empty header in DE 
925b			 
925b				ex de, hl 
925b			 
925b			;	inc hl ; move past end of block 
925b			 
925b				ld a, 0 
925b				ld (hl), a   ; empty marker 
925b				inc hl 
925b				ld (hl), a   ; size 
925b				inc hl  
925b				ld (hl), a   ; ptr 
925b				inc hl 
925b				ld (hl), a   ; ptr 
925b			 
925b			 
925b				pop hl 
925b			 
925b					if DEBUG_FORTH_MALLOC_INT 
925b						DMARK "mmr" 
925b						CALLMONITOR 
925b					endif 
925b			 
925b			.exit: 
925b				pop af 
925b				pop bc 
925b				pop de  
925b				ret 
925b			 
925b			 
925b			 
925b			 
925b			free:  
925b				push hl 
925b				push af 
925b				; get address in hl 
925b			 
925b					if DEBUG_FORTH_MALLOC_INT 
925b						DMARK "fre" 
925b						CALLMONITOR 
925b					endif 
925b				; data is at hl - move to block count 
925b				dec hl 
925b				dec hl    ; get past pointer 
925b				dec hl 
925b			 
925b				ld a, (hl)    ; need this for a validation check 
925b			 
925b				dec hl    ; move to block marker 
925b			 
925b				; now check that the block count and block marker are the same  
925b			        ; this checks that we are on a malloc node and not random memory 
925b			        ; OK a faint chance this could be a problem but rare - famous last words! 
925b			 
925b				ld c, a 
925b				ld a, (hl)    
925b			 
925b				cp c 
925b				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
925b			 
925b				; yes good chance we are on a malloc node 
925b			 
925b				ld a, 0      
925b				ld (hl), a   ; mark as free 
925b			 
925b				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
925b			 
925b			.freeignore:  
925b			 
925b				pop af 
925b				pop hl 
925b			 
925b				ret 
925b			 
925b			 
925b			 
925b			endif 
925b			 
925b			; eof 
# End of file firmware_memory.asm
925b			  
925b			; device C  
925b			; Now handled by SPI  
925b			;if SOUND_ENABLE  
925b			;	include "firmware_sound.asm"  
925b			;endif  
925b			  
925b			include "firmware_diags.asm"  
925b			; Hardware diags menu 
925b			 
925b			 
925b			config: 
925b			 
925b 3e 00			ld a, 0 
925d 21 81 92			ld hl, .configmn 
9260 cd eb 8a			call menu 
9263			 
9263 fe 00			cp 0 
9265 c8				ret z 
9266			 
9266			;	cp 1 
9266			;	call z, .savetostore 
9266			 
9266 fe 01			cp 1 
9268			if STARTUP_V1 
9268 cc 97 92			call z, .selautoload 
926b			endif 
926b			 
926b			if STARTUP_V2 
926b				call z, .enautoload 
926b			endif 
926b fe 02			cp 2 
926d cc 8d 92			call z, .disautoload 
9270			;	cp 3 
9270			;	call z, .selbank 
9270 fe 03			cp 3 
9272 cc b5 92			call z, .debug_tog 
9275 fe 04			cp 4 
9277 cc 03 94			call z, .bpsgo 
927a fe 05			cp 5 
927c cc de 92			call z, hardware_diags 
927f			if STARTUP_V2 
927f				cp 6 
927f				call z, create_startup 
927f			endif 
927f 18 da			jr config 
9281			 
9281			.configmn: 
9281			;	dw prom_c3 
9281 f1 95			dw prom_c2 
9283 06 96			dw prom_c2a 
9285			;	dw prom_c2b 
9285			;	dw prom_c4 
9285 25 96			dw prom_m4 
9287 40 96			dw prom_m4b 
9289 48 96			dw prom_c1 
928b			if STARTUP_V2 
928b				dw prom_c9 
928b			endif 
928b 00 00			dw 0 
928d				 
928d			 
928d			if STARTUP_V2 
928d			.enautoload: 
928d				if STORAGE_SE 
928d				ld a, $fe      ; bit 0 clear 
928d				ld (spi_device), a 
928d			 
928d				call storage_get_block_0 
928d			 
928d				ld a, 1 
928d				ld (store_page+STORE_0_AUTOFILE), a 
928d			 
928d					ld hl, 0 
928d					ld de, store_page 
928d				call storage_write_block	 ; save update 
928d				else 
928d			 
928d				ld hl, prom_notav 
928d				ld de, prom_empty 
928d				call info_panel 
928d				endif 
928d			 
928d			 
928d				ret 
928d			endif 
928d			 
928d			.disautoload: 
928d				if STORAGE_SE 
928d				ld a, $fe      ; bit 0 clear 
928d				ld (spi_device), a 
928d			 
928d				call storage_get_block_0 
928d			 
928d				ld a, 0 
928d				ld (store_page+STORE_0_AUTOFILE), a 
928d			 
928d					ld hl, 0 
928d					ld de, store_page 
928d				call storage_write_block	 ; save update 
928d				else 
928d			 
928d 21 57 96			ld hl, prom_notav 
9290 11 6d 96			ld de, prom_empty 
9293 cd 4b 8a			call info_panel 
9296				endif 
9296			 
9296			 
9296 c9				ret 
9297			 
9297			if STARTUP_V1 
9297			 
9297			; Select auto start 
9297			 
9297			.selautoload: 
9297			 
9297				 
9297				if STORAGE_SE 
9297			 
9297					call config_dir 
9297				        ld hl, scratch 
9297					ld a, 0 
9297					call menu 
9297			 
9297					cp 0 
9297					ret z 
9297			 
9297					dec a 
9297			 
9297			 
9297					; locate menu option 
9297			 
9297					ld hl, scratch 
9297					call table_lookup 
9297			 
9297					if DEBUG_FORTH_WORDS 
9297						DMARK "ALl" 
9297						CALLMONITOR 
9297					endif 
9297					; with the pointer to the menu it, the byte following the zero term is the file id 
9297			 
9297					ld a, 0 
9297					ld bc, 50   ; max of bytes to look at 
9297					cpir  
9297			 
9297					if DEBUG_FORTH_WORDS 
9297						DMARK "ALb" 
9297						CALLMONITOR 
9297					endif 
9297					;inc hl 
9297			 
9297					ld a, (hl)   ; file id 
9297					 
9297				        ; save bank and file ids 
9297			 
9297					push af 
9297			 
9297			; TODO need to save to block 0 on bank 1	 
9297			 
9297					call storage_get_block_0 
9297			 
9297					if DEBUG_FORTH_WORDS 
9297						DMARK "AL0" 
9297						CALLMONITOR 
9297					endif 
9297					pop af 
9297			 
9297					ld (store_page+STORE_0_FILERUN),a 
9297					 
9297					; save bank id 
9297			 
9297					ld a,(spi_device) 
9297					ld (store_page+STORE_0_BANKRUN),a 
9297			 
9297					; enable auto run of store file 
9297			 
9297					ld a, 1 
9297					ld (store_page+STORE_0_AUTOFILE),a 
9297			 
9297					; save buffer 
9297			 
9297					ld hl, 0 
9297					ld de, store_page 
9297					if DEBUG_FORTH_WORDS 
9297						DMARK "ALw" 
9297						CALLMONITOR 
9297					endif 
9297				call storage_write_block	 ; save update 
9297			  
9297			 
9297			 
9297			 
9297					ld hl, scratch 
9297					call config_fdir 
9297			 
9297				else 
9297			 
9297 21 57 96			ld hl, prom_notav 
929a 11 6d 96			ld de, prom_empty 
929d cd 4b 8a			call info_panel 
92a0			 
92a0				endif 
92a0 c9				ret 
92a1			endif 
92a1			 
92a1			 
92a1			; Select storage bank 
92a1			 
92a1			.selbank: 
92a1			 
92a1			;	if STORAGE_SE 
92a1			;	else 
92a1			 
92a1 21 57 96			ld hl, prom_notav 
92a4 11 6d 96			ld de, prom_empty 
92a7 cd 4b 8a			call info_panel 
92aa			;	endif 
92aa				 
92aa c9				ret 
92ab			 
92ab			if STORAGE_SE 
92ab			 
92ab			.config_ldir:   
92ab				; Load storage bank labels into menu array 
92ab			 
92ab				 
92ab			 
92ab			 
92ab				ret 
92ab			 
92ab			 
92ab			endif 
92ab			 
92ab			 
92ab			; Save user words to storage 
92ab			 
92ab			.savetostore: 
92ab			 
92ab			;	if STORAGE_SE 
92ab			; 
92ab			;		call config_dir 
92ab			;	        ld hl, scratch 
92ab			;		ld a, 0 
92ab			;		call menu 
92ab			;		 
92ab			;		ld hl, scratch 
92ab			;		call config_fdir 
92ab			; 
92ab			;	else 
92ab			 
92ab 21 57 96			ld hl, prom_notav 
92ae 11 6d 96			ld de, prom_empty 
92b1 cd 4b 8a			call info_panel 
92b4			 
92b4			;	endif 
92b4			 
92b4 c9				ret 
92b5			 
92b5			if STARTUP_V2 
92b5			 
92b5			create_startup: 
92b5			 
92b5				ld a, 0 
92b5				ld hl, .crstart 
92b5				call menu 
92b5			 
92b5				cp 0 
92b5				ret z 
92b5			 
92b5				cp 1 
92b5				call z, .genlsword 
92b5				cp 2 
92b5				call z, .genedword 
92b5			 
92b5				cp 3 
92b5				call z, .gendemword 
92b5			 
92b5				cp 4 
92b5				call z, .genutlword 
92b5				cp 5 
92b5				call z, .genspiword 
92b5				cp 6 
92b5				call z, .genkeyword 
92b5				cp 7 
92b5				call z, .gensoundword 
92b5				cp 7 
92b5				call z, .genhwword 
92b5				jr create_startup 
92b5			 
92b5			.genhwword: 
92b5				ld hl, crs_hw 
92b5				ld de, .hwworddef 
92b5				call .genfile 
92b5				ret 
92b5			.gensoundword: 
92b5				ld hl, crs_sound 
92b5				ld de, .soundworddef 
92b5				call .genfile 
92b5				ret 
92b5			.genlsword: 
92b5				ld hl, crs_s1 
92b5				ld de, .lsworddef 
92b5				call .genfile 
92b5				ret 
92b5			 
92b5			.genedword: 
92b5				ld de, .edworddef 
92b5				ld hl, crs_s2 
92b5				call .genfile 
92b5				ret 
92b5			 
92b5			.gendemword: 
92b5				ld de, .demoworddef 
92b5				ld hl, crs_s3 
92b5				call .genfile 
92b5				ret 
92b5			 
92b5			.genutlword: 
92b5				ld hl, crs_s4 
92b5				ld de, .utilwordef 
92b5				call .genfile 
92b5				ret 
92b5			.genspiword: 
92b5				ld hl, crs_s5 
92b5				ld de, .spiworddef 
92b5				call .genfile 
92b5				ret 
92b5			.genkeyword: 
92b5				ld hl, crs_s6 
92b5				ld de, .keyworddef 
92b5				call .genfile 
92b5				ret 
92b5			 
92b5			; hl - points to file name 
92b5			; de - points to strings to add to file 
92b5			 
92b5			.genfile: 
92b5				push hl 
92b5				push de 
92b5			 
92b5				call clear_display 
92b5				ld a, display_row_1 
92b5				ld de, .genfiletxt 
92b5				call str_at_display 
92b5				call update_display 
92b5			 
92b5				pop de 
92b5				pop hl 
92b5			 
92b5			 
92b5				push de 
92b5				call storage_create 
92b5				; id in hl 
92b5				pop de   ; table of strings to add 
92b5			 
92b5			.genloop: 
92b5			 
92b5				push hl ; save id for next time around 
92b5				push de ; save de for next time around 
92b5			 
92b5				ex de, hl 
92b5				call loadwordinhl 
92b5				ex de, hl 
92b5			 
92b5				; need hl to be the id 
92b5				; need de to be the string ptr 
92b5				 
92b5				call storage_append 
92b5			 
92b5				pop de 
92b5				pop hl 
92b5			 
92b5				inc de 
92b5				inc de 
92b5			 
92b5				ld a,(de) 
92b5				cp 0 
92b5				jr nz, .genloop 
92b5				inc de 
92b5				ld a, (de) 
92b5				dec de 
92b5				cp 0 
92b5				jr nz, .genloop	 
92b5			 
92b5				ret 
92b5			 
92b5			.genfiletxt:  db "Creating file...",0 
92b5			 
92b5			.hwworddef: 
92b5				dw test5 
92b5				dw test6 
92b5				dw test7 
92b5				dw test8 
92b5				dw test9 
92b5				dw test10 
92b5				dw 0 
92b5			 
92b5			.soundworddef: 
92b5				dw sound1 
92b5				dw sound2 
92b5				dw sound3 
92b5				dw sound4 
92b5				dw sound5 
92b5				dw sound6 
92b5				dw sound7 
92b5				dw sound8 
92b5				dw sound9 
92b5				dw 0 
92b5			 
92b5			.utilwordef: 
92b5				dw strncpy 
92b5				dw type 
92b5				dw clrstack 
92b5				dw longread 
92b5				dw start1 
92b5				dw start2 
92b5			; duplicated 
92b5			;	dw start3b 
92b5			;	dw start3c 
92b5				dw list 
92b5				dw 0 
92b5			 
92b5			.lsworddef: 
92b5				dw start3b 
92b5				dw 0 
92b5			 
92b5			.edworddef: 
92b5				dw edit1 
92b5				dw edit2 
92b5				dw edit3 
92b5				dw 0 
92b5			 
92b5			.demoworddef: 
92b5				dw game1 
92b5				dw game1a 
92b5				dw game1b 
92b5				dw game1c 
92b5				dw game1d 
92b5				dw game1s 
92b5				dw game1t 
92b5				dw game1f 
92b5				dw game1z 
92b5				dw game1zz 
92b5				dw ssv2 
92b5				dw ssv3 
92b5				dw ssv4 
92b5				dw ssv5 
92b5				dw ssv1 
92b5				dw ssv1cpm	 
92b5			;	dw game2b 
92b5			;	dw game2bf 
92b5			;	dw game2mba 
92b5			;	dw game2mbas	 
92b5			;	dw game2mbht 
92b5			;	dw game2mbms 
92b5			;	dw game2mb 
92b5			;	dw game3w 
92b5			;	dw game3p 
92b5			;	dw game3sc 
92b5			;	dw game3vsi 
92b5			;	dw game3vs 
92b5				dw 0 
92b5			 
92b5			 
92b5			.spiworddef: 
92b5			 
92b5			    dw spi1 
92b5			    dw spi2 
92b5			    dw spi2b 
92b5			    dw spi3 
92b5			    dw spi4 
92b5			    dw spi5 
92b5			;    dw spi6 
92b5			;    dw spi7 
92b5			 
92b5			;    dw spi8 
92b5			;    dw spi9 
92b5			;    dw spi10 
92b5			    dw 0 
92b5			 
92b5			.keyworddef: 
92b5			 
92b5				dw keyup 
92b5				dw keydown 
92b5				dw keyleft 
92b5				dw keyright 
92b5				dw 	keyf1 
92b5				dw keyf2 
92b5				dw keyf3 
92b5				dw keyf4 
92b5				dw keyf5 
92b5				dw keyf6 
92b5				dw keyf7 
92b5				dw keyf8 
92b5				dw keyf9 
92b5				dw keyf10 
92b5				dw keyf11 
92b5				dw keyf12 
92b5				dw keytab 
92b5				dw keycr 
92b5				dw keyhome 
92b5				dw keyend 
92b5				dw keybs 
92b5				dw 0 
92b5			 
92b5			.crstart: 
92b5				dw crs_s1 
92b5				dw crs_s2 
92b5				dw crs_s3 
92b5				dw crs_s4 
92b5				dw crs_s5 
92b5				dw crs_s6 
92b5				dw crs_sound 
92b5				dw crs_hw 
92b5				dw 0 
92b5			 
92b5			endif 
92b5			 
92b5			 
92b5			if STORAGE_SE 
92b5			 
92b5			config_fdir: 
92b5				; using the scratch dir go through and release the memory allocated for each string 
92b5				 
92b5				ld hl, scratch 
92b5			.cfdir:	ld e,(hl) 
92b5				inc hl 
92b5				ld d,(hl) 
92b5				inc hl 
92b5			 
92b5				ex de, hl 
92b5				call ishlzero 
92b5				ret z     ; return on null pointer 
92b5				call free 
92b5				ex de, hl 
92b5				jr .cfdir 
92b5			 
92b5			 
92b5				ret 
92b5			 
92b5			 
92b5			config_dir: 
92b5			 
92b5				; for the config menus that need to build a directory of storage call this routine 
92b5				; it will construct a menu in scratch to pass to menu 
92b5			 
92b5				; open storage device 
92b5			 
92b5				; execute DIR to build a list of files and their ids into scratch in menu format 
92b5				; once the menu has finished then will need to call config_fdir to release the strings 
92b5				 
92b5				; c = number items 
92b5			 
92b5				 
92b5				call storage_get_block_0 
92b5			 
92b5				ld hl, store_page     ; get current id count 
92b5				ld b, (hl) 
92b5				ld c, 0    ; count of files   
92b5			 
92b5			 
92b5				ld hl, scratch 
92b5				ld (store_tmp2), hl    ; location to poke strings 
92b5			 
92b5				; check for empty drive 
92b5			 
92b5				ld a, 0 
92b5				cp b 
92b5				jp z, .dirdone 
92b5			 
92b5				 
92b5					if DEBUG_FORTH_WORDS 
92b5						DMARK "Cdc" 
92b5						CALLMONITOR 
92b5					endif 
92b5			 
92b5			 
92b5			.diritem:	 
92b5				push bc 
92b5				; for each of the current ids do a search for them and if found push to stack 
92b5			 
92b5					ld hl, STORE_BLOCK_PHY 
92b5					ld d, 0		 ; look for extent 0 of block id as this contains file name 
92b5					ld e,b 
92b5			 
92b5					call storage_findnextid 
92b5			 
92b5			 
92b5					; if found hl will be non zero 
92b5			 
92b5					call ishlzero 
92b5					jr z, .dirnotfound 
92b5			 
92b5					; increase count 
92b5			 
92b5					pop bc	 
92b5					inc c 
92b5					push bc 
92b5					 
92b5			 
92b5					; get file header and push the file name 
92b5			 
92b5					ld de, store_page 
92b5					call storage_read_block 
92b5			 
92b5					; push file id to stack 
92b5				 
92b5					ld a, (store_page) 
92b5					ld h, 0 
92b5					ld l, a 
92b5			 
92b5					;call forth_push_numhl 
92b5					; TODO store id 
92b5			 
92b5					push hl 
92b5			 
92b5					; push extent count to stack  
92b5				 
92b5					ld hl, store_page+3 
92b5			 
92b5					; get file name length 
92b5			 
92b5					call strlenz   
92b5			 
92b5					inc hl   ; cover zero term 
92b5					inc hl  ; stick the id at the end of the area 
92b5			 
92b5					push hl 
92b5					pop bc    ; move length to bc 
92b5			 
92b5					call malloc 
92b5			 
92b5					; TODO save malloc area to scratch 
92b5			 
92b5					ex de, hl 
92b5					ld hl, (store_tmp2) 
92b5					ld (hl), e 
92b5					inc hl 
92b5					ld (hl), d 
92b5					inc hl 
92b5					ld (store_tmp2), hl 
92b5			 
92b5					 
92b5			 
92b5					;pop hl   ; get source 
92b5			;		ex de, hl    ; swap aronund	 
92b5			 
92b5					ld hl, store_page+3 
92b5					if DEBUG_FORTH_WORDS 
92b5						DMARK "CFd" 
92b5						CALLMONITOR 
92b5					endif 
92b5					ldir 
92b5			 
92b5					; de is past string, move back one and store id 
92b5					 
92b5					dec de 
92b5			 
92b5					; store file id 
92b5			 
92b5					pop hl 
92b5					ex de,hl 
92b5					ld (hl), e 
92b5			 
92b5					if DEBUG_FORTH_WORDS 
92b5						DMARK "Cdi" 
92b5						CALLMONITOR 
92b5					endif 
92b5					 
92b5			.dirnotfound: 
92b5					pop bc     
92b5					djnz .diritem 
92b5				 
92b5			.dirdone:	 
92b5			 
92b5					ld a, 0 
92b5					ld hl, (store_tmp2) 
92b5					ld (hl), a 
92b5					inc hl 
92b5					ld (hl), a 
92b5					inc hl 
92b5					; push a count of the dir items found 
92b5			 
92b5			;		ld h, 0 
92b5			;		ld l, c 
92b5			 
92b5				ret 
92b5			 
92b5			endif 
92b5			 
92b5			 
92b5			; Settings 
92b5			; Run  
92b5			 
92b5			 
92b5			 
92b5			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
92b5			;;hd_menu2:   db "        2: Editor",0   
92b5			;hd_menu2:   db "        2: Editor       6: Menu",0   
92b5			;hd_menu3:   db "        3: Storage",0 
92b5			;hd_menu4:   db "0=quit  4: Debug",0 
92b5			;hd_don:     db "ON",0 
92b5			;hd_doff:     db "OFF",0 
92b5			; 
92b5			; 
92b5			; 
92b5			;hardware_diags_old:       
92b5			; 
92b5			;.diagmenu: 
92b5			;	call clear_display 
92b5			;	ld a, display_row_1 
92b5			;	ld de, hd_menu1 
92b5			;	call str_at_display 
92b5			; 
92b5			;	ld a, display_row_2 
92b5			;	ld de, hd_menu2 
92b5			;	call str_at_display 
92b5			; 
92b5			;	ld a, display_row_3 
92b5			;	ld de, hd_menu3 
92b5			;	call str_at_display 
92b5			; 
92b5			;	ld a,  display_row_4 
92b5			;	ld de, hd_menu4 
92b5			;	call str_at_display 
92b5			; 
92b5			;	; display debug state 
92b5			; 
92b5			;	ld de, hd_don 
92b5			;	ld a, (os_view_disable) 
92b5			;	cp 0 
92b5			;	jr z, .distog 
92b5			;	ld de, hd_doff 
92b5			;.distog: ld a, display_row_4+17 
92b5			;	call str_at_display 
92b5			; 
92b5			;	call update_display 
92b5			; 
92b5			;	call cin_wait 
92b5			; 
92b5			; 
92b5			; 
92b5			;	cp '4' 
92b5			;	jr nz, .diagn1 
92b5			; 
92b5			;	; debug toggle 
92b5			; 
92b5			;	ld a, (os_view_disable) 
92b5			;	ld b, '*' 
92b5			;	cp 0 
92b5			;	jr z, .debtog 
92b5			;	ld b, 0 
92b5			;.debtog:	 
92b5			;	ld a,b 
92b5			;	ld (os_view_disable),a 
92b5			; 
92b5			;.diagn1: cp '0' 
92b5			;	 ret z 
92b5			; 
92b5			;;	cp '1' 
92b5			;;       jp z, matrix	 
92b5			;;   TODO keyboard matrix test 
92b5			; 
92b5			;	cp '2' 
92b5			;	jp z, .diagedit 
92b5			; 
92b5			;;	cp '6' 
92b5			;;	jp z, .menutest 
92b5			;;if ENABLE_BASIC 
92b5			;;	cp '6' 
92b5			;;	jp z, basic 
92b5			;;endif 
92b5			 ; 
92b5			;	jp .diagmenu 
92b5			; 
92b5			; 
92b5			;	ret 
92b5			 
92b5			 
92b5			.debug_tog: 
92b5 21 ff 92			ld hl, .menudebug 
92b8				 
92b8			;	ld a, (os_view_disable) 
92b8			;	cp '*' 
92b8 3a 6f ee			ld a,(debug_vector) 
92bb fe c9			cp $C9   ; RET 
92bd 20 04			jr nz,.tdon  
92bf 3e 01			ld a, 1 
92c1 18 02			jr .tog1 
92c3 3e 00		.tdon: ld a, 0 
92c5			 
92c5			.tog1: 
92c5 cd eb 8a			call menu 
92c8 fe 00			cp 0 
92ca c8				ret z 
92cb fe 01			cp 1    ; disable debug 
92cd 28 04			jr z, .dtog0 
92cf 3e 2a			ld a, '*' 
92d1 18 05			jr .dtogset 
92d3			.dtog0:  
92d3				;ld a, 0 
92d3 cd f1 93			call bp_on 
92d6 18 dd			jr .debug_tog 
92d8			.dtogset:  
92d8				; ld (os_view_disable), a 
92d8 cd fd 93			call bp_off 
92db c3 b5 92			jp .debug_tog 
92de			 
92de			 
92de			hardware_diags:       
92de			 
92de			.diagm: 
92de 21 f1 92			ld hl, .menuitems 
92e1 3e 00			ld a, 0 
92e3 cd eb 8a			call menu 
92e6			 
92e6 fe 00		         cp 0 
92e8 c8				 ret z 
92e9			 
92e9 fe 02			cp 2 
92eb ca 4a 93			jp z, .diagedit 
92ee			 
92ee			;	cp '6' 
92ee			;	jp z, .menutest 
92ee			;if ENABLE_BASIC 
92ee			;	cp '6' 
92ee			;	jp z, basic 
92ee			;endif 
92ee			  
92ee c3 de 92			jp .diagm 
92f1			 
92f1				 
92f1 05 93		.menuitems:   	dw .m1 
92f3 10 93				dw .m2 
92f5 17 93				dw .m3 
92f7 1f 93				dw .m5 
92f9 25 93				dw .m5a 
92fb 2e 93				dw .m5b 
92fd 00 00				dw 0 
92ff			 
92ff			.menudebug: 
92ff 37 93				dw .m6 
9301 40 93				dw .m7 
9303 00 00				dw 0 
9305			 
9305 .. 00		.m1:   db "Key Matrix",0 
9310 .. 00		.m2:   db "Editor",0 
9317 .. 00		.m3:   db "Storage",0 
931f .. 00		.m5:   db "Sound",0 
9325 .. 00		.m5a:  db "RAM Test",0 
932e .. 00		.m5b:  db "LCD Test",0 
9337			 
9337 .. 00		.m6:   db "Debug ON",0 
9340 .. 00		.m7:   db "Debug OFF",0 
934a			 
934a			; debug editor 
934a			 
934a			.diagedit: 
934a			 
934a 21 c1 e2			ld hl, scratch 
934d			;	ld bc, 250 
934d			;	ldir 
934d				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
934d 3e 00			ld a, 0 
934f 77				ld (hl), a 
9350 23				inc hl 
9351 77				ld (hl), a 
9352 23				inc hl 
9353 77				ld (hl), a 
9354			 
9354 cd ba 8a		        call clear_display 
9357 cd dd 8a			call update_display 
935a				;ld a, 1 
935a				;ld (hardware_diag), a 
935a			.diloop: 
935a 3e 00			ld a, display_row_1 
935c 0e 00			ld c, 0 
935e 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9360 1e 28			ld e, 40 
9362			 
9362 21 c1 e2			ld hl, scratch	 
9365 cd 14 8d			call input_str 
9368			 
9368 3e 28			ld a, display_row_2 
936a 11 c1 e2			ld de, scratch 
936d cd cd 8a			call str_at_display 
9370 cd dd 8a			call update_display 
9373			 
9373 c3 5a 93			jp .diloop 
9376			 
9376			 
9376			; pass word in hl 
9376			; a has display location 
9376			display_word_at: 
9376 f5				push af 
9377 e5				push hl 
9378 7c				ld a,h 
9379 21 c6 e5			ld hl, os_word_scratch 
937c cd f0 8e			call hexout 
937f e1				pop hl 
9380 7d				ld a,l 
9381 21 c8 e5			ld hl, os_word_scratch+2 
9384 cd f0 8e			call hexout 
9387 21 ca e5			ld hl, os_word_scratch+4 
938a 3e 00			ld a,0 
938c 77				ld (hl),a 
938d 11 c6 e5			ld de,os_word_scratch 
9390 f1				pop af 
9391 cd cd 8a				call str_at_display 
9394 c9				ret 
9395			 
9395			display_ptr_state: 
9395			 
9395				; to restore afterwards 
9395			 
9395 d5				push de 
9396 c5				push bc 
9397 e5				push hl 
9398 f5				push af 
9399			 
9399				; for use in here 
9399			 
9399			;	push bc 
9399			;	push de 
9399			;	push hl 
9399			;	push af 
9399			 
9399 cd ba 8a			call clear_display 
939c			 
939c 11 74 95			ld de, .ptrstate 
939f 3e 00			ld a, display_row_1 
93a1 cd cd 8a			call str_at_display 
93a4			 
93a4				; display debug step 
93a4			 
93a4			 
93a4 11 6b ee			ld de, debug_mark 
93a7 3e 26			ld a, display_row_1+display_cols-2 
93a9 cd cd 8a			call str_at_display 
93ac			 
93ac				; display a 
93ac 11 7e 95			ld de, .ptrcliptr 
93af 3e 28			ld a, display_row_2 
93b1 cd cd 8a			call str_at_display 
93b4			 
93b4 f1				pop af 
93b5 2a 40 ea			ld hl,(cli_ptr) 
93b8 3e 30			ld a, display_row_2+8 
93ba cd 76 93			call display_word_at 
93bd			 
93bd			 
93bd				; display hl 
93bd			 
93bd			 
93bd 11 86 95			ld de, .ptrclioptr 
93c0 3e 32			ld a, display_row_2+10 
93c2 cd cd 8a			call str_at_display 
93c5			; 
93c5			;	pop hl 
93c5 3e 35			ld a, display_row_2+13 
93c7 2a 3e ea			ld hl,(cli_origptr) 
93ca cd 76 93			call display_word_at 
93cd			; 
93cd			;	 
93cd			;	; display de 
93cd			 
93cd			;	ld de, .regstatede 
93cd			;	ld a, display_row_3 
93cd			;	call str_at_display 
93cd			 
93cd			;	pop de 
93cd			;	ld h,d 
93cd			;	ld l, e 
93cd			;	ld a, display_row_3+3 
93cd			;	call display_word_at 
93cd			 
93cd			 
93cd				; display bc 
93cd			 
93cd			;	ld de, .regstatebc 
93cd			;	ld a, display_row_3+10 
93cd			;	call str_at_display 
93cd			 
93cd			;	pop bc 
93cd			;	ld h,b 
93cd			;	ld l, c 
93cd			;	ld a, display_row_3+13 
93cd			;	call display_word_at 
93cd			 
93cd			 
93cd				; display dsp 
93cd			 
93cd			;	ld de, .regstatedsp 
93cd			;	ld a, display_row_4 
93cd			;	call str_at_display 
93cd			 
93cd				 
93cd			;	ld hl,(cli_data_sp) 
93cd			;	ld a, display_row_4+4 
93cd			;	call display_word_at 
93cd			 
93cd				; display rsp 
93cd			 
93cd 11 b5 95			ld de, .regstatersp 
93d0 3e 82			ld a, display_row_4+10 
93d2 cd cd 8a			call str_at_display 
93d5			 
93d5				 
93d5 2a f2 e9			ld hl,(cli_ret_sp) 
93d8 3e 86			ld a, display_row_4+14 
93da cd 76 93			call display_word_at 
93dd			 
93dd cd dd 8a			call update_display 
93e0			 
93e0 cd fd 89			call delay1s 
93e3 cd fd 89			call delay1s 
93e6 cd fd 89			call delay1s 
93e9			 
93e9			 
93e9 cd e6 99			call next_page_prompt 
93ec			 
93ec				; restore  
93ec			 
93ec f1				pop af 
93ed e1				pop hl 
93ee c1				pop bc 
93ef d1				pop de 
93f0 c9				ret 
93f1			 
93f1			; Update the break point vector so that the user can hook a new routine 
93f1			 
93f1			bp_on: 
93f1 3e c3			ld a, $c3    ; JP 
93f3 32 6f ee			ld (debug_vector), a 
93f6 21 03 94			ld hl, break_point_state 
93f9 22 70 ee			ld (debug_vector+1), hl 
93fc c9				ret 
93fd			 
93fd			bp_off: 
93fd 3e c9			ld a, $c9    ; RET 
93ff 32 6f ee			ld (debug_vector), a 
9402 c9				ret 
9403			 
9403			 
9403			break_point_state: 
9403			;	push af 
9403			; 
9403			;	; see if disabled 
9403			; 
9403			;	ld a, (os_view_disable) 
9403			;	cp '*' 
9403			;	jr nz, .bpsgo 
9403			;	pop af 
9403			;	ret 
9403			 
9403			.bpsgo: 
9403			;	pop af 
9403 f5				push af 
9404 22 a3 e2			ld (os_view_hl), hl 
9407 ed 53 a1 e2		ld (os_view_de), de 
940b ed 43 9f e2		ld (os_view_bc), bc 
940f e5				push hl 
9410 6f				ld l, a 
9411 26 00			ld h, 0 
9413 22 a5 e2			ld (os_view_af),hl 
9416			 
9416 21 b1 ed				ld hl, display_fb0 
9419 22 cc eb				ld (display_fb_active), hl 
941c e1				pop hl	 
941d			 
941d 3e 31			ld a, '1' 
941f fe 2a		.bps1:  cp '*' 
9421 cc fd 93			call z, bp_off 
9424			;	jr nz, .bps1b 
9424			;	ld (os_view_disable),a 
9424 fe 31		.bps1b:  cp '1' 
9426 20 14			jr nz, .bps2 
9428			 
9428				; display reg 
9428			 
9428				 
9428			 
9428 3a a5 e2			ld a, (os_view_af) 
942b 2a a3 e2			ld hl, (os_view_hl) 
942e ed 5b a1 e2		ld de, (os_view_de) 
9432 ed 4b 9f e2		ld bc, (os_view_bc) 
9436 cd d0 94			call display_reg_state 
9439 c3 bc 94			jp .bpschk 
943c			 
943c fe 32		.bps2:  cp '2' 
943e 20 08			jr nz, .bps3 
9440				 
9440				; display hl 
9440 2a a3 e2			ld hl, (os_view_hl) 
9443 cd ba 95			call display_dump_at_hl 
9446			 
9446 18 74			jr .bpschk 
9448			 
9448 fe 33		.bps3:  cp '3' 
944a 20 08			jr nz, .bps4 
944c			 
944c			        ; display de 
944c 2a a1 e2			ld hl, (os_view_de) 
944f cd ba 95			call display_dump_at_hl 
9452			 
9452 18 68			jr .bpschk 
9454 fe 34		.bps4:  cp '4' 
9456 20 08			jr nz, .bps5 
9458			 
9458			        ; display bc 
9458 2a 9f e2			ld hl, (os_view_bc) 
945b cd ba 95			call display_dump_at_hl 
945e			 
945e 18 5c			jr .bpschk 
9460 fe 35		.bps5:  cp '5' 
9462 20 08		        jr nz, .bps7 
9464			 
9464				; display cur ptr 
9464 2a 40 ea			ld hl, (cli_ptr) 
9467 cd ba 95			call display_dump_at_hl 
946a			 
946a 18 50			jr .bpschk 
946c fe 36		.bps7:  cp '6' 
946e 20 08			jr nz, .bps8b 
9470				 
9470				; display cur orig ptr 
9470 2a 3e ea			ld hl, (cli_origptr) 
9473 cd ba 95			call display_dump_at_hl 
9476 18 44			jr .bpschk 
9478 fe 37		.bps8b:  cp '7' 
947a 20 08			jr nz, .bps9 
947c				 
947c				; display dsp 
947c 2a ee e9			ld hl, (cli_data_sp) 
947f cd ba 95			call display_dump_at_hl 
9482			 
9482 18 38			jr .bpschk 
9484 fe 39		.bps9:  cp '9' 
9486 20 05			jr nz, .bps8c 
9488				 
9488				; display SP 
9488			;	ld hl, sp 
9488 cd ba 95			call display_dump_at_hl 
948b			 
948b 18 2f			jr .bpschk 
948d fe 38		.bps8c:  cp '8' 
948f 20 08			jr nz, .bps8d 
9491				 
9491				; display rsp 
9491 2a f2 e9			ld hl, (cli_ret_sp) 
9494 cd ba 95			call display_dump_at_hl 
9497			 
9497 18 23			jr .bpschk 
9499 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
949b 20 05			jr nz, .bps8 
949d cd b4 97			call monitor 
94a0			 
94a0 18 1a			jr .bpschk 
94a2 fe 30		.bps8:  cp '0' 
94a4 20 16			jr nz, .bpschk 
94a6			 
94a6 21 10 ed				ld hl, display_fb1 
94a9 22 cc eb				ld (display_fb_active), hl 
94ac cd dd 8a				call update_display 
94af			 
94af				;ld a, (os_view_af) 
94af 2a a3 e2			ld hl, (os_view_hl) 
94b2 ed 5b a1 e2		ld de, (os_view_de) 
94b6 ed 4b 9f e2		ld bc, (os_view_bc) 
94ba f1				pop af 
94bb c9				ret 
94bc			 
94bc			.bpschk:   
94bc cd fd 89			call delay1s 
94bf 3e 9f		ld a,display_row_4 + display_cols - 1 
94c1 11 e4 99		        ld de, endprg 
94c4 cd cd 8a			call str_at_display 
94c7 cd dd 8a			call update_display 
94ca cd 11 dd			call cin_wait 
94cd			 
94cd c3 1f 94			jp .bps1 
94d0			 
94d0			 
94d0			display_reg_state: 
94d0			 
94d0				; to restore afterwards 
94d0			 
94d0 d5				push de 
94d1 c5				push bc 
94d2 e5				push hl 
94d3 f5				push af 
94d4			 
94d4				; for use in here 
94d4			 
94d4 c5				push bc 
94d5 d5				push de 
94d6 e5				push hl 
94d7 f5				push af 
94d8			 
94d8 cd ba 8a			call clear_display 
94db			 
94db 11 90 95			ld de, .regstate 
94de 3e 00			ld a, display_row_1 
94e0 cd cd 8a			call str_at_display 
94e3			 
94e3				; display debug step 
94e3			 
94e3			 
94e3 11 6b ee			ld de, debug_mark 
94e6 3e 25			ld a, display_row_1+display_cols-3 
94e8 cd cd 8a			call str_at_display 
94eb			 
94eb				; display a 
94eb 11 ac 95			ld de, .regstatea 
94ee 3e 28			ld a, display_row_2 
94f0 cd cd 8a			call str_at_display 
94f3			 
94f3 e1				pop hl 
94f4			;	ld h,0 
94f4			;	ld l, a 
94f4 3e 2b			ld a, display_row_2+3 
94f6 cd 76 93			call display_word_at 
94f9			 
94f9			 
94f9				; display hl 
94f9			 
94f9			 
94f9 11 a0 95			ld de, .regstatehl 
94fc 3e 32			ld a, display_row_2+10 
94fe cd cd 8a			call str_at_display 
9501			 
9501 e1				pop hl 
9502 3e 35			ld a, display_row_2+13 
9504 cd 76 93			call display_word_at 
9507			 
9507				 
9507				; display de 
9507			 
9507 11 a4 95			ld de, .regstatede 
950a 3e 50			ld a, display_row_3 
950c cd cd 8a			call str_at_display 
950f			 
950f e1				pop hl 
9510			;	ld h,d 
9510			;	ld l, e 
9510 3e 53			ld a, display_row_3+3 
9512 cd 76 93			call display_word_at 
9515			 
9515			 
9515				; display bc 
9515			 
9515 11 a8 95			ld de, .regstatebc 
9518 3e 5a			ld a, display_row_3+10 
951a cd cd 8a			call str_at_display 
951d			 
951d e1				pop hl 
951e			;	ld h,b 
951e			;	ld l, c 
951e 3e 5d			ld a, display_row_3+13 
9520 cd 76 93			call display_word_at 
9523			 
9523			 
9523				; display dsp 
9523			 
9523 11 b0 95			ld de, .regstatedsp 
9526 3e 78			ld a, display_row_4 
9528 cd cd 8a			call str_at_display 
952b			 
952b				 
952b 2a ee e9			ld hl,(cli_data_sp) 
952e 3e 7c			ld a, display_row_4+4 
9530 cd 76 93			call display_word_at 
9533			 
9533				; display rsp 
9533			 
9533 11 b5 95			ld de, .regstatersp 
9536 3e 82			ld a, display_row_4+10 
9538 cd cd 8a			call str_at_display 
953b			 
953b				 
953b 2a f2 e9			ld hl,(cli_ret_sp) 
953e 3e 86			ld a, display_row_4+14 
9540 cd 76 93			call display_word_at 
9543			 
9543 cd dd 8a			call update_display 
9546			 
9546			;	call delay1s 
9546			;	call delay1s 
9546			;	call delay1s 
9546			 
9546			 
9546			;	call next_page_prompt 
9546			 
9546				; restore  
9546			 
9546 f1				pop af 
9547 e1				pop hl 
9548 c1				pop bc 
9549 d1				pop de 
954a c9				ret 
954b			 
954b .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
955f .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9574 .. 00		.ptrstate:	db "Ptr State",0 
957e .. 00		.ptrcliptr:     db "cli_ptr",0 
9586 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9590 .. 00		.regstate:	db "Reg State (1/0)",0 
95a0 .. 00		.regstatehl:	db "HL:",0 
95a4 .. 00		.regstatede:	db "DE:",0 
95a8 .. 00		.regstatebc:	db "BC:",0 
95ac .. 00		.regstatea:	db "A :",0 
95b0 .. 00		.regstatedsp:	db "DSP:",0 
95b5 .. 00		.regstatersp:	db "RSP:",0 
95ba			 
95ba			display_dump_at_hl: 
95ba e5				push hl 
95bb d5				push de 
95bc c5				push bc 
95bd f5				push af 
95be			 
95be 22 e4 e5			ld (os_cur_ptr),hl	 
95c1 cd ba 8a			call clear_display 
95c4 cd ee 98			call dumpcont 
95c7			;	call delay1s 
95c7			;	call next_page_prompt 
95c7			 
95c7			 
95c7 f1				pop af 
95c8 c1				pop bc 
95c9 d1				pop de 
95ca e1				pop hl 
95cb c9				ret 
95cc			 
95cc			;if ENABLE_BASIC 
95cc			;	include "nascombasic.asm" 
95cc			;	basic: 
95cc			;	include "forth/FORTH.ASM" 
95cc			;endif 
95cc			 
95cc			; eof 
95cc			 
95cc			 
# End of file firmware_diags.asm
95cc			  
95cc			include "firmware_prompts.asm"  
95cc			; Prompts  
95cc			 
95cc			; boot messages 
95cc			 
95cc .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
95e1 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
95f1			 
95f1			 
95f1			; config menus 
95f1			 
95f1			;prom_c3: db "Add Dictionary To File",0 
95f1			 
95f1			if STARTUP_V1 
95f1 .. 00		prom_c2: db "Select Autoload File",0 
9606 .. 00		prom_c2a: db "Disable Autoload File", 0 
961c			endif 
961c			 
961c			if STARTUP_V2 
961c			prom_c2: db "Enable Autoload Files",0 
961c			prom_c2a: db "Disable Autoload Files", 0 
961c			 
961c			crs_s1: db "*ls-word", 0 
961c			crs_s2: db "*ed-word", 0 
961c			crs_s3: db "*Demo-Games", 0 
961c			crs_s4: db "*Utils", 0 
961c			crs_s5: db "*SPI-Util", 0 
961c			crs_s6: db "*Key-Constants", 0 
961c			crs_sound: db "*Sound-Util", 0 
961c			crs_hw: db "*Hello-World",0 
961c			 
961c			 
961c			 
961c			endif 
961c			;prom_c2b: db "Select Storage Bank",0 
961c .. 00		prom_c4: db "Settings",0 
9625 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9640 .. 00		prom_m4b:   db "Monitor",0 
9648 .. 00		prom_c1: db "Hardware Diags",0 
9657			 
9657			 
9657			if STARTUP_V2 
9657			prom_c9: db "Create Startup Files",0 
9657			endif 
9657			 
9657 .. 00		prom_notav:    db "Feature not available",0 
966d .. 00		prom_empty:    db "",0 
966e			 
966e			; eof 
966e			 
# End of file firmware_prompts.asm
966e			  
966e			  
966e			; eof  
966e			  
# End of file firmware.asm
966e			 
966e			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
966e			;if BASE_KEV  
966e			;baseram: equ 08000h 
966e			;endif 
966e			 
966e			;if BASE_SC114 
966e			;baseram:     equ    endofcode 
966e			;endif 
966e			 
966e			 
966e			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
966e			 
966e			; start system 
966e			 
966e			coldstart: 
966e				; set sp 
966e				; di/ei 
966e			 
966e f3				di 
966f 31 00 f0			ld sp, tos 
9672 cd 5b dc			call init_nmi 
9675			;	ei 
9675			 
9675				; init spinner 
9675 3e 00			ld a,0 
9677 32 c6 eb			ld (display_active), a 
967a			 
967a				; disable breakpoint by default 
967a			 
967a				;ld a,'*' 
967a			;	ld a,' ' 
967a			;	ld (os_view_disable),a 
967a			 
967a				; set break point vector as new break point on or off 
967a cd fd 93			call bp_off 
967d			 
967d				; init hardware 
967d			 
967d				; init keyboard and screen hardware 
967d			 
967d cd 1f 80			call hardware_init 
9680			 
9680			 
9680 cd fd 89			call delay1s 
9683 3e 58			ld a, display_row_3+8 
9685 11 03 80			ld de, buildtime 
9688 cd cd 8a			call str_at_display 
968b cd dd 8a			call update_display 
968e			 
968e cd fd 89			call delay1s 
9691 cd fd 89			call delay1s 
9694 cd fd 89			call delay1s 
9697			 
9697				; detect if any keys are held down to enable breakpoints at start up 
9697			 
9697 cd 17 dd			call cin  
969a fe 00			cp 0 
969c 28 03			jr z, .nokeys 
969e			 
969e				;call hardware_diags 
969e cd 5b 92			call config 
96a1			 
96a1			;	ld de, .bpen 
96a1			;	ld a, display_row_4 
96a1			;	call str_at_display 
96a1			;	call update_display 
96a1			; 
96a1			;	ld a,0 
96a1			;	ld (os_view_disable),a 
96a1			; 
96a1			;.bpwait: 
96a1			;	call cin 
96a1			;	cp 0 
96a1			;	jr z, .bpwait 
96a1			;	jr .nokeys 
96a1			; 
96a1			; 
96a1			;.bpen:  db "Break points enabled!",0 
96a1			 
96a1			 
96a1			 
96a1			 
96a1			 
96a1			 
96a1			.nokeys: 
96a1			 
96a1			 
96a1				 
96a1			 
96a1			;jp  testkey 
96a1			 
96a1			;call storage_get_block_0 
96a1			; 
96a1			;ld hl, 0 
96a1			;ld de, store_page 
96a1			;call storage_read_block 
96a1			 
96a1				 
96a1			;ld hl, 10 
96a1			;ld de, store_page 
96a1			;call storage_read_block 
96a1			 
96a1			 
96a1			 
96a1			 
96a1			 
96a1			;stop:	nop 
96a1			;	jp stop 
96a1			 
96a1			 
96a1			 
96a1			main: 
96a1 cd ba 8a			call clear_display 
96a4 cd dd 8a			call update_display 
96a7			 
96a7			 
96a7			 
96a7			;	call testlcd 
96a7			 
96a7			 
96a7			 
96a7 cd f9 9d			call forth_init 
96aa			 
96aa			 
96aa			warmstart: 
96aa cd cf 9d			call forth_warmstart 
96ad			 
96ad				; run startup word load 
96ad			        ; TODO prevent this running at warmstart after crash  
96ad			 
96ad				if STARTUP_ENABLE 
96ad			 
96ad					if STARTUP_V1 
96ad			 
96ad						if STORAGE_SE 
96ad							call forth_autoload 
96ad						endif 
96ad cd ab db					call forth_startup 
96b0					endif 
96b0			 
96b0					if STARTUP_V2 
96b0			 
96b0						if STORAGE_SE 
96b0							call forth_autoload 
96b0						else 
96b0							call forth_startup 
96b0						endif 
96b0			 
96b0			 
96b0					endif 
96b0			 
96b0				endif 
96b0			 
96b0			warmstart_afterauto: 
96b0			 
96b0				; show free memory after boot 
96b0 11 4f 97			ld de, freeram 
96b3 3e 00			ld a, display_row_1 
96b5 cd cd 8a			call str_at_display 
96b8			 
96b8				; get current heap start after loading any uwords 
96b8			 
96b8				;ld de, (os_last_new_uword) 
96b8				;ex de, hl 
96b8			 
96b8			; Or use heap_size word???? 
96b8				;ld hl, heap_end 
96b8				;ld hl, heap_size 
96b8				;ld de, topusermem 
96b8				;ld de, heap_start 
96b8 ed 5b 30 dd			ld de, (free_list )      
96bc 21 9c e2				ld hl, heap_end 
96bf ed 52			sbc hl, de 
96c1				;push hl 
96c1				;ld a,h	         	 
96c1				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
96c1				;call hexout 
96c1			   	;pop hl 
96c1			; 
96c1			;	ld a,l 
96c1			;	ld hl, os_word_scratch+2 
96c1			;	call hexout 
96c1			;	ld hl, os_word_scratch+4 
96c1			;	ld a, 0 
96c1			;	ld (hl),a 
96c1 eb				ex de, hl 
96c2 21 c6 e5			ld hl, os_word_scratch 
96c5 cd fc 8f			call uitoa_16 
96c8			 
96c8			 
96c8 11 c6 e5			ld de, os_word_scratch 
96cb 3e 0d			ld a, display_row_1 + 13 
96cd cd cd 8a			call str_at_display 
96d0 cd dd 8a			call update_display 
96d3			 
96d3			 
96d3				;call demo 
96d3			 
96d3			 
96d3				; init scratch input area for cli commands 
96d3			 
96d3 21 e8 e5			ld hl, os_cli_cmd 
96d6 3e 00			ld a,0 
96d8 77				ld (hl),a 
96d9 23				inc hl 
96da 77				ld (hl),a 
96db			 
96db 3e 00			ld a,0 
96dd 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
96e0			 
96e0 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
96e3 32 e5 e5			ld (os_cur_ptr+1),a	 
96e6			 
96e6 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
96e9 32 c7 e5			ld (os_word_scratch+1),a	 
96ec				 
96ec			 
96ec				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
96ec 21 e8 e5			ld hl, os_cli_cmd 
96ef			 
96ef 3e 00			ld a, 0		 ; init cli input 
96f1 77				ld (hl), a 
96f2 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
96f4			cli: 
96f4				; show cli prompt 
96f4				;push af 
96f4				;ld a, 0 
96f4				;ld de, prompt 
96f4				;call str_at_display 
96f4			 
96f4				;call update_display 
96f4				;pop af 
96f4				;inc a 
96f4				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
96f4			 
96f4			.lastrecall: 
96f4			 
96f4 0e 00			ld c, 0 
96f6 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
96f8 1e 28			ld e, 40 
96fa			 
96fa 21 e8 e5			ld hl, os_cli_cmd 
96fd			 
96fd				STACKFRAME OFF $fefe $9f9f 
96fd				if DEBUG_STACK_IMB 
96fd					if OFF 
96fd						exx 
96fd						ld de, $fefe 
96fd						ld a, d 
96fd						ld hl, curframe 
96fd						call hexout 
96fd						ld a, e 
96fd						ld hl, curframe+2 
96fd						call hexout 
96fd						ld hl, $fefe 
96fd						push hl 
96fd						ld hl, $9f9f 
96fd						push hl 
96fd						exx 
96fd					endif 
96fd				endif 
96fd			endm 
# End of macro STACKFRAME
96fd			 
96fd cd 14 8d			call input_str 
9700			 
9700				STACKFRAMECHK OFF $fefe $9f9f 
9700				if DEBUG_STACK_IMB 
9700					if OFF 
9700						exx 
9700						ld hl, $9f9f 
9700						pop de   ; $9f9f 
9700						call cmp16 
9700						jr nz, .spnosame 
9700						ld hl, $fefe 
9700						pop de   ; $fefe 
9700						call cmp16 
9700						jr z, .spfrsame 
9700						.spnosame: call showsperror 
9700						.spfrsame: nop 
9700						exx 
9700					endif 
9700				endif 
9700			endm 
# End of macro STACKFRAMECHK
9700			 
9700			 
9700				; check to see if last line recall has been requested 
9700			 
9700			if EDIT_V2 
9700 fe 05			cp KEY_UP 
9702 20 0f			jr nz, .noexecline 
9704			 
9704 11 e8 e5			ld de, os_cli_cmd 
9707 21 e7 e6			ld hl, os_last_cmd 
970a 01 ff 00			ld bc, 255 
970d ed b0			ldir 
970f 3e 00			ld a, 0 
9711 18 e1			jr .lastrecall 
9713			endif 
9713			 
9713			.noexecline: 
9713				; no so exec the line		 
9713			 
9713				; copy input to last command 
9713			 
9713 21 e8 e5			ld hl, os_cli_cmd 
9716 11 e7 e6			ld de, os_last_cmd 
9719 01 ff 00			ld bc, 255 
971c ed b0			ldir 
971e			 
971e				; wipe current buffer 
971e			 
971e			;	ld a, 0 
971e			;	ld hl, os_cli_cmd 
971e			;	ld de, os_cli_cmd+1 
971e			;	ld bc, 254 
971e			;	ldir 
971e				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
971e			;	call strcpy 
971e			;	ld a, 0 
971e			;	ld (hl), a 
971e			;	inc hl 
971e			;	ld (hl), a 
971e			;	inc hl 
971e			;	ld (hl), a 
971e			 
971e				; switch frame buffer to program  
971e			 
971e 21 10 ed				ld hl, display_fb1 
9721 22 cc eb				ld (display_fb_active), hl 
9724			 
9724			;	nop 
9724				STACKFRAME ON $fbfe $8f9f 
9724				if DEBUG_STACK_IMB 
9724					if ON 
9724						exx 
9724						ld de, $fbfe 
9724						ld a, d 
9724						ld hl, curframe 
9724						call hexout 
9724						ld a, e 
9724						ld hl, curframe+2 
9724						call hexout 
9724						ld hl, $fbfe 
9724						push hl 
9724						ld hl, $8f9f 
9724						push hl 
9724						exx 
9724					endif 
9724				endif 
9724			endm 
# End of macro STACKFRAME
9724				; first time into the parser so pass over the current scratch pad 
9724 21 e8 e5			ld hl,os_cli_cmd 
9727				; tokenise the entered statement(s) in HL 
9727 cd 77 9e			call forthparse 
972a			        ; exec forth statements in top of return stack 
972a cd b7 9e			call forthexec 
972d				;call forthexec_cleanup 
972d			;	call parsenext 
972d			 
972d				STACKFRAMECHK ON $fbfe $8f9f 
972d				if DEBUG_STACK_IMB 
972d					if ON 
972d						exx 
972d						ld hl, $8f9f 
972d						pop de   ; $8f9f 
972d						call cmp16 
972d						jr nz, .spnosame 
972d						ld hl, $fbfe 
972d						pop de   ; $fbfe 
972d						call cmp16 
972d						jr z, .spfrsame 
972d						.spnosame: call showsperror 
972d						.spfrsame: nop 
972d						exx 
972d					endif 
972d				endif 
972d			endm 
# End of macro STACKFRAMECHK
972d				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
972d			 
972d 3e 78			ld a, display_row_4 
972f 11 60 97			ld de, endprog 
9732			 
9732 cd dd 8a			call update_display		 
9735			 
9735 cd e6 99			call next_page_prompt 
9738			 
9738				; switch frame buffer to cli 
9738			 
9738 21 b1 ed				ld hl, display_fb0 
973b 22 cc eb				ld (display_fb_active), hl 
973e			 
973e			 
973e cd ba 8a		        call clear_display 
9741 cd dd 8a			call update_display		 
9744			 
9744 21 e8 e5			ld hl, os_cli_cmd 
9747			 
9747 3e 00			ld a, 0		 ; init cli input 
9749 77				ld (hl), a 
974a			 
974a				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
974a			 
974a				; now on last line 
974a			 
974a				; TODO scroll screen up 
974a			 
974a				; TODO instead just clear screen and place at top of screen 
974a			 
974a			;	ld a, 0 
974a			;	ld (f_cursor_ptr),a 
974a			 
974a				;call clear_display 
974a				;call update_display 
974a			 
974a				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
974a 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
974c c3 f4 96			jp cli 
974f			 
974f .. 00		freeram: db "Free bytes: ",0 
975c ..			asc: db "1A2F" 
9760 .. 00		endprog: db "End prog...",0 
976c			 
976c			testenter2:   
976c 21 f3 e2			ld hl,scratch+50 
976f 22 e4 e5			ld (os_cur_ptr),hl 
9772 c3 f4 96			jp cli 
9775			 
9775			testenter:  
9775			 
9775 21 5c 97			ld hl,asc 
9778			;	ld a,(hl) 
9778			;	call nibble2val 
9778 cd 46 8f			call get_byte 
977b			 
977b			 
977b			;	ld a,(hl) 
977b			;	call atohex 
977b			 
977b			;	call fourehexhl 
977b 32 f3 e2			ld (scratch+50),a 
977e			 
977e			 
977e			 
977e 21 5e 97			ld hl,asc+2 
9781			;	ld a, (hl) 
9781			;	call nibble2val 
9781 cd 46 8f			call get_byte 
9784			 
9784			;	call fourehexhl 
9784 32 f5 e2			ld (scratch+52),a 
9787				 
9787 21 f3 e2			ld hl,scratch+50 
978a 22 e4 e5			ld (os_cur_ptr),hl 
978d c3 f4 96			jp cli 
9790			 
9790			enter:	 
9790 3a c5 e2			ld a,(scratch+4) 
9793 fe 00			cp 0 
9795 28 0c			jr z, .entercont 
9797				; no, not a null term line so has an address to work out.... 
9797			 
9797 21 c3 e2			ld hl,scratch+2 
979a cd a6 8f			call get_word_hl 
979d			 
979d 22 e4 e5			ld (os_cur_ptr),hl	 
97a0 c3 f4 96			jp cli 
97a3			 
97a3			 
97a3			.entercont:  
97a3			 
97a3 21 c3 e2			ld hl, scratch+2 
97a6 cd 46 8f			call get_byte 
97a9			 
97a9 2a e4 e5		   	ld hl,(os_cur_ptr) 
97ac 77					ld (hl),a 
97ad 23					inc hl 
97ae 22 e4 e5				ld (os_cur_ptr),hl 
97b1				 
97b1			; get byte  
97b1			 
97b1			 
97b1 c3 f4 96			jp cli 
97b4			 
97b4			 
97b4			; basic monitor support 
97b4			 
97b4			monitor: 
97b4				;  
97b4 cd ba 8a			call clear_display 
97b7 3e 00			ld a, 0 
97b9 11 08 98			ld de, .monprompt 
97bc cd cd 8a			call str_at_display 
97bf cd dd 8a			call update_display 
97c2			 
97c2				; get a monitor command 
97c2			 
97c2 0e 00			ld c, 0     ; entry at top left 
97c4 16 64			ld d, 100   ; max buffer size 
97c6 1e 0f			ld e, 15    ; input scroll area 
97c8 3e 00			ld a, 0     ; init string 
97ca 21 bf e4			ld hl, os_input 
97cd 77				ld (hl), a 
97ce 23				inc hl 
97cf 77				ld (hl), a 
97d0 21 bf e4			ld hl, os_input 
97d3 3e 01			ld a, 1     ; init string 
97d5 cd 14 8d			call input_str 
97d8			 
97d8 cd ba 8a		        call clear_display 
97db cd dd 8a			call update_display		 
97de			 
97de 3a bf e4			ld a, (os_input) 
97e1 cd 44 90			call toUpper 
97e4 fe 48		        cp 'H' 
97e6 ca 6d 98		        jp z, .monhelp 
97e9 fe 44			cp 'D'		; dump 
97eb ca a0 98			jp z, .mondump	 
97ee fe 43			cp 'C'		; dump 
97f0 ca ba 98			jp z, .moncdump	 
97f3 fe 4d			cp 'M'		; dump 
97f5 ca 0a 98			jp z, .moneditstart 
97f8 fe 55			cp 'U'		; dump 
97fa ca 16 98			jp z, .monedit	 
97fd fe 47			cp 'G'		; dump 
97ff ca 96 98			jp z, .monjump 
9802 fe 51			cp 'Q'		; dump 
9804 c8				ret z	 
9805			 
9805			 
9805				; TODO "S" to access symbol by name and not need the address 
9805				; TODO "F" to find a string in memory 
9805			 
9805 c3 b4 97			jp monitor 
9808			 
9808 .. 00		.monprompt: db ">", 0 
980a			 
980a			.moneditstart: 
980a				; get starting address 
980a			 
980a 21 c1 e4			ld hl,os_input+2 
980d cd a6 8f			call get_word_hl 
9810			 
9810 22 e4 e5			ld (os_cur_ptr),hl	 
9813			 
9813 c3 b4 97			jp monitor 
9816			 
9816			.monedit: 
9816				; get byte to load 
9816			 
9816 21 c1 e4			ld hl,os_input+2 
9819 cd 46 8f			call get_byte 
981c			 
981c				; get address to update 
981c 2a e4 e5			ld hl, (os_cur_ptr) 
981f			 
981f				; update byte 
981f			 
981f 77				ld (hl), a 
9820			 
9820				; move to next address and save it 
9820			 
9820 23				inc hl 
9821 22 e4 e5			ld (os_cur_ptr),hl	 
9824			 
9824 c3 b4 97			jp monitor 
9827			 
9827			 
9827 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
983b .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
9857 .. 00		.monhelptext3:  db "G-Call address",0 
9866 .. 00		.monhelptext4:  db "Q-Quit",0 
986d			        
986d			.monhelp: 
986d 3e 00			ld a, display_row_1 
986f 11 27 98		        ld de, .monhelptext1 
9872			 
9872 cd cd 8a			call str_at_display 
9875 3e 28			ld a, display_row_2 
9877 11 3b 98		        ld de, .monhelptext2 
987a					 
987a cd cd 8a			call str_at_display 
987d 3e 50			ld a, display_row_3 
987f 11 57 98		        ld de, .monhelptext3 
9882					 
9882 cd cd 8a			call str_at_display 
9885 3e 78			ld a, display_row_4 
9887 11 66 98		        ld de, .monhelptext4 
988a cd cd 8a			call str_at_display 
988d			 
988d cd dd 8a			call update_display		 
9890			 
9890 cd e6 99			call next_page_prompt 
9893 c3 b4 97			jp monitor 
9896			 
9896			.monjump:    
9896 21 c1 e4			ld hl,os_input+2 
9899 cd a6 8f			call get_word_hl 
989c			 
989c e9				jp (hl) 
989d c3 b4 97			jp monitor 
98a0			 
98a0			.mondump:    
98a0 21 c1 e4			ld hl,os_input+2 
98a3 cd a6 8f			call get_word_hl 
98a6			 
98a6 22 e4 e5			ld (os_cur_ptr),hl	 
98a9 cd ee 98			call dumpcont 
98ac 3e 78			ld a, display_row_4 
98ae 11 60 97			ld de, endprog 
98b1			 
98b1 cd dd 8a			call update_display		 
98b4			 
98b4 cd e6 99			call next_page_prompt 
98b7 c3 b4 97			jp monitor 
98ba			.moncdump: 
98ba cd ee 98			call dumpcont 
98bd 3e 78			ld a, display_row_4 
98bf 11 60 97			ld de, endprog 
98c2			 
98c2 cd dd 8a			call update_display		 
98c5			 
98c5 cd e6 99			call next_page_prompt 
98c8 c3 b4 97			jp monitor 
98cb			 
98cb			 
98cb			; TODO symbol access  
98cb			 
98cb			.symbols:     ;; A list of symbols that can be called up  
98cb b1 ed			dw display_fb0 
98cd .. 00			db "fb0",0  
98d1 7a ea		     	dw store_page 
98d3 .. 00			db "store_page",0 
98de			 
98de			 
98de			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
98de			 
98de 3a c2 e2			ld a,(scratch+1) 
98e1 fe 00			cp 0 
98e3 28 09			jr z, dumpcont 
98e5			 
98e5				; no, not a null term line so has an address to work out.... 
98e5			 
98e5 21 c3 e2			ld hl,scratch+2 
98e8 cd a6 8f			call get_word_hl 
98eb			 
98eb 22 e4 e5			ld (os_cur_ptr),hl	 
98ee			 
98ee			 
98ee			 
98ee			dumpcont: 
98ee			 
98ee				; dump bytes at ptr 
98ee			 
98ee			 
98ee 3e 00			ld a, display_row_1 
98f0 2a cc eb			ld hl, (display_fb_active) 
98f3 cd e7 8c			call addatohl 
98f6 cd 1e 99			call .dumpbyterow 
98f9			 
98f9 3e 28			ld a, display_row_2 
98fb 2a cc eb			ld hl, (display_fb_active) 
98fe cd e7 8c			call addatohl 
9901 cd 1e 99			call .dumpbyterow 
9904			 
9904			 
9904 3e 50			ld a, display_row_3 
9906 2a cc eb			ld hl, (display_fb_active) 
9909 cd e7 8c			call addatohl 
990c cd 1e 99			call .dumpbyterow 
990f			 
990f 3e 78			ld a, display_row_4 
9911 2a cc eb			ld hl, (display_fb_active) 
9914 cd e7 8c			call addatohl 
9917 cd 1e 99			call .dumpbyterow 
991a			 
991a cd dd 8a			call update_display 
991d			;		jp cli 
991d c9				ret 
991e			 
991e			.dumpbyterow: 
991e			 
991e				;push af 
991e			 
991e e5				push hl 
991f			 
991f				; calc where to poke the ascii 
991f			if display_cols == 20 
991f				ld a, 16 
991f			else 
991f 3e 1f			ld a, 31 
9921			endif 
9921			 
9921 cd e7 8c			call addatohl 
9924 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
9927			 
9927			 
9927			; display decoding address 
9927 2a e4 e5		   	ld hl,(os_cur_ptr) 
992a			 
992a 7c				ld a,h 
992b e1				pop hl 
992c e5				push hl 
992d			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
992d cd f0 8e			call hexout 
9930 2a e4 e5		   	ld hl,(os_cur_ptr) 
9933			 
9933 7d				ld a,l 
9934 e1				pop hl 
9935 23				inc hl 
9936 23				inc hl 
9937 e5				push hl 
9938			;	ld hl, os_word_scratch+2 
9938 cd f0 8e			call hexout 
993b e1				pop hl 
993c 23				inc hl 
993d 23				inc hl 
993e				;ld hl, os_word_scratch+4 
993e 3e 3a			ld a, ':' 
9940 77				ld (hl),a 
9941 23				inc hl 
9942				;ld a, 0 
9942				;ld (hl),a 
9942				;ld de, os_word_scratch 
9942				;pop af 
9942				;push af 
9942			;		ld a, display_row_2 
9942			;		call str_at_display 
9942			;		call update_display 
9942			 
9942			 
9942			;pop af 
9942			;	add 5 
9942			 
9942			if display_cols == 20 
9942				ld b, 4 
9942			else 
9942 06 08			ld b, 8 
9944			endif	 
9944			 
9944			.dumpbyte: 
9944 c5				push bc 
9945 e5				push hl 
9946			 
9946			 
9946 2a e4 e5		   	ld hl,(os_cur_ptr) 
9949 7e					ld a,(hl) 
994a			 
994a					; poke the ascii to display 
994a 2a c6 e5				ld hl,(os_word_scratch) 
994d 77					ld (hl),a 
994e 23					inc hl 
994f 22 c6 e5				ld (os_word_scratch),hl 
9952			 
9952					 
9952			 
9952			 
9952 e1					pop hl 
9953 e5					push hl 
9954			 
9954 cd f0 8e				call hexout 
9957			 
9957					 
9957 2a e4 e5		   	ld hl,(os_cur_ptr) 
995a 23				inc hl 
995b 22 e4 e5		   	ld (os_cur_ptr),hl 
995e			 
995e e1					pop hl 
995f 23					inc hl 
9960 23					inc hl 
9961 23					inc hl 
9962			 
9962			 
9962			 
9962					;ld a,0 
9962					;ld (os_word_scratch+2),a 
9962					;pop af 
9962					;push af 
9962			 
9962					;ld de, os_word_scratch 
9962					;call str_at_display 
9962			;		call update_display 
9962			;		pop af 
9962 c1					pop bc 
9963 c6 03				add 3 
9965 10 dd			djnz .dumpbyte 
9967			 
9967				 
9967			 
9967 c9				ret 
9968			 
9968			jump:	 
9968			 
9968 21 c3 e2			ld hl,scratch+2 
996b cd a6 8f			call get_word_hl 
996e				;ld hl,(scratch+2) 
996e				;call fourehexhl 
996e			 
996e 22 e4 e5			ld (os_cur_ptr),hl	 
9971			 
9971 e9				jp (hl) 
9972			 
9972			 
9972			 
9972			; TODO implement a basic monitor mode to start with 
9972			 
9972			 
9972			 
9972			 
9972			 
9972			 
9972			 
9972			 
9972			 
9972			; testing and demo code during development 
9972			 
9972			 
9972 .. 00		str1: db "Enter some text...",0 
9985 .. 00		clear: db "                    ",0 
999a			 
999a			demo: 
999a			 
999a			 
999a			 
999a			;	call update_display 
999a			 
999a				; init scratch input area for testing 
999a 21 c1 e2			ld hl, scratch	 
999d 3e 00			ld a,0 
999f 77				ld (hl),a 
99a0			 
99a0			 
99a0 3e 28		            LD   A, display_row_2 
99a2			;            CALL fLCD_Pos       ;Position cursor to location in A 
99a2 11 72 99		            LD   DE, str1 
99a5 cd cd 8a			call str_at_display 
99a8			 
99a8			;            CALL fLCD_Str       ;Display string pointed to by DE 
99a8			cloop:	 
99a8 3e 50		            LD   A, display_row_3 
99aa			;            CALL fLCD_Pos       ;Position cursor to location in A 
99aa 11 85 99		            LD   DE, clear 
99ad			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
99ad cd cd 8a				call str_at_display 
99b0 3e 78			ld a, display_row_4 
99b2 11 e2 99			ld de, prompt 
99b5			 
99b5 cd cd 8a				call str_at_display 
99b8 cd dd 8a			call update_display 
99bb			 
99bb 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
99bd 16 0a			ld d, 10 
99bf 21 c1 e2			ld hl, scratch	 
99c2 cd 14 8d			call input_str 
99c5			 
99c5			;	call clear_display 
99c5			;'	call update_display 
99c5			 
99c5 3e 00		            LD   A, display_row_1 
99c7			;            CALL fLCD_Pos       ;Position cursor to location in A 
99c7 11 85 99		            LD   DE, clear 
99ca cd cd 8a				call str_at_display 
99cd			;            CALL fLCD_Str       ;Display string pointed to by DE 
99cd 3e 00		            LD   A, display_row_1 
99cf			;            CALL fLCD_Pos       ;Position cursor to location in A 
99cf 11 c1 e2		            LD   DE, scratch 
99d2			;            CALL fLCD_Str       ;Display string pointed to by DE 
99d2 cd cd 8a				call str_at_display 
99d5 cd dd 8a			call update_display 
99d8			 
99d8 3e 00				ld a,0 
99da 21 c1 e2			ld hl, scratch 
99dd 77				ld (hl),a 
99de			 
99de 00				nop 
99df c3 a8 99			jp cloop 
99e2			 
99e2			 
99e2			 
99e2			; OS Prompt 
99e2			 
99e2 .. 00		prompt: db ">",0 
99e4 .. 00		endprg: db "?",0 
99e6			 
99e6			 
99e6			; handy next page prompt 
99e6			next_page_prompt: 
99e6 e5				push hl 
99e7 d5				push de 
99e8 f5				push af 
99e9 c5				push bc 
99ea			 
99ea 3e 9f			ld a,display_row_4 + display_cols - 1 
99ec 11 e4 99		        ld de, endprg 
99ef cd cd 8a			call str_at_display 
99f2 cd dd 8a			call update_display 
99f5 cd 11 dd			call cin_wait 
99f8 c1				pop bc 
99f9 f1				pop af 
99fa d1				pop de 
99fb e1				pop hl 
99fc			 
99fc			 
99fc c9				ret 
99fd			 
99fd			 
99fd			; forth parser 
99fd			 
99fd			; My forth kernel 
99fd			include "forth_kernel.asm" 
99fd			; 
99fd			; kernel to the forth OS 
99fd			 
99fd			DS_TYPE_STR: equ 1     ; string type 
99fd			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
99fd			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
99fd			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
99fd			 
99fd			FORTH_PARSEV1: equ 0 
99fd			FORTH_PARSEV2: equ 0 
99fd			FORTH_PARSEV3: equ 0 
99fd			FORTH_PARSEV4: equ 0 
99fd			FORTH_PARSEV5: equ 1 
99fd			 
99fd			;if FORTH_PARSEV5 
99fd			;	FORTH_END_BUFFER: equ 0 
99fd			;else 
99fd			FORTH_END_BUFFER: equ 127 
99fd			;endif 
99fd			 
99fd			FORTH_TRUE: equ 1 
99fd			FORTH_FALSE: equ 0 
99fd			 
99fd			if FORTH_PARSEV4 
99fd			include "forth_stackops.asm" 
99fd			endif 
99fd			 
99fd			if FORTH_PARSEV5 
99fd			include "forth_stackopsv5.asm" 
99fd			 
99fd			; Stack operations for v5 parser on wards 
99fd			; * DATA stack 
99fd			; * LOOP stack 
99fd			; * RETURN stack 
99fd			 
99fd			 
99fd			 
99fd			FORTH_CHK_DSP_UNDER: macro 
99fd				push hl 
99fd				push de 
99fd				ld hl,(cli_data_sp) 
99fd				ld de, cli_data_stack 
99fd				call cmp16 
99fd				jp c, fault_dsp_under 
99fd				pop de 
99fd				pop hl 
99fd				endm 
99fd			 
99fd			 
99fd			FORTH_CHK_RSP_UNDER: macro 
99fd				push hl 
99fd				push de 
99fd				ld hl,(cli_ret_sp) 
99fd				ld de, cli_ret_stack 
99fd				call cmp16 
99fd				jp c, fault_rsp_under 
99fd				pop de 
99fd				pop hl 
99fd				endm 
99fd			 
99fd			FORTH_CHK_LOOP_UNDER: macro 
99fd				push hl 
99fd				push de 
99fd				ld hl,(cli_loop_sp) 
99fd				ld de, cli_loop_stack 
99fd				call cmp16 
99fd				jp c, fault_loop_under 
99fd				pop de 
99fd				pop hl 
99fd				endm 
99fd			 
99fd			FORTH_ERR_TOS_NOTSTR: macro 
99fd				; TOSO might need more for checks when used 
99fd				push af 
99fd				ld a,(hl) 
99fd				cp DS_TYPE_STR 
99fd				jp nz, type_faultn   
99fd				pop af 
99fd				endm 
99fd			 
99fd			FORTH_ERR_TOS_NOTNUM: macro 
99fd				push af 
99fd				ld a,(hl) 
99fd				cp DS_TYPE_INUM 
99fd				jp nz, type_faultn   
99fd				pop af 
99fd				endm 
99fd			 
99fd			 
99fd			; increase data stack pointer and save hl to it 
99fd				 
99fd			FORTH_DSP_NEXT: macro 
99fd				call macro_forth_dsp_next 
99fd				endm 
99fd			 
99fd			 
99fd			macro_forth_dsp_next: 
99fd				if DEBUG_FORTH_STACK_GUARD 
99fd cd 83 d9				call check_stacks 
9a00				endif 
9a00 e5				push hl 
9a01 d5				push de 
9a02 eb				ex de,hl 
9a03 2a ee e9			ld hl,(cli_data_sp) 
9a06 23				inc hl 
9a07 23				inc hl 
9a08			 
9a08			; PARSEV5 
9a08 23				inc hl 
9a09 22 ee e9			ld (cli_data_sp),hl 
9a0c 73				ld (hl), e 
9a0d 23				inc hl 
9a0e 72				ld (hl), d 
9a0f d1				pop de 
9a10 e1				pop hl 
9a11				if DEBUG_FORTH_STACK_GUARD 
9a11 cd 83 d9				call check_stacks 
9a14				endif 
9a14 c9				ret 
9a15			 
9a15			 
9a15			; increase ret stack pointer and save hl to it 
9a15				 
9a15			FORTH_RSP_NEXT: macro 
9a15				call macro_forth_rsp_next 
9a15				endm 
9a15			 
9a15			macro_forth_rsp_next: 
9a15				if DEBUG_FORTH_STACK_GUARD 
9a15 cd 83 d9				call check_stacks 
9a18				endif 
9a18 e5				push hl 
9a19 d5				push de 
9a1a eb				ex de,hl 
9a1b 2a f2 e9			ld hl,(cli_ret_sp) 
9a1e 23				inc hl 
9a1f 23				inc hl 
9a20 22 f2 e9			ld (cli_ret_sp),hl 
9a23 73				ld (hl), e 
9a24 23				inc hl 
9a25 72				ld (hl), d 
9a26 d1				pop de 
9a27 e1				pop hl 
9a28				if DEBUG_FORTH_STACK_GUARD 
9a28 cd 83 d9				call check_stacks 
9a2b				endif 
9a2b c9				ret 
9a2c			 
9a2c			; get current ret stack pointer and save to hl  
9a2c				 
9a2c			FORTH_RSP_TOS: macro 
9a2c				call macro_forth_rsp_tos 
9a2c				endm 
9a2c			 
9a2c			macro_forth_rsp_tos: 
9a2c				;push de 
9a2c 2a f2 e9			ld hl,(cli_ret_sp) 
9a2f cd 67 9a			call loadhlptrtohl 
9a32				;ld e, (hl) 
9a32				;inc hl 
9a32				;ld d, (hl) 
9a32				;ex de, hl 
9a32					if DEBUG_FORTH_WORDS 
9a32			;			DMARK "RST" 
9a32						CALLMONITOR 
9a32 cd 6f ee			call debug_vector  
9a35				endm  
# End of macro CALLMONITOR
9a35					endif 
9a35				;pop de 
9a35 c9				ret 
9a36			 
9a36			; pop ret stack pointer 
9a36				 
9a36			FORTH_RSP_POP: macro 
9a36				call macro_forth_rsp_pop 
9a36				endm 
9a36			 
9a36			 
9a36			macro_forth_rsp_pop: 
9a36				if DEBUG_FORTH_STACK_GUARD 
9a36			;		DMARK "RPP" 
9a36 cd 83 d9				call check_stacks 
9a39					FORTH_CHK_RSP_UNDER 
9a39 e5				push hl 
9a3a d5				push de 
9a3b 2a f2 e9			ld hl,(cli_ret_sp) 
9a3e 11 ac e9			ld de, cli_ret_stack 
9a41 cd 05 8d			call cmp16 
9a44 da 9a da			jp c, fault_rsp_under 
9a47 d1				pop de 
9a48 e1				pop hl 
9a49				endm 
# End of macro FORTH_CHK_RSP_UNDER
9a49				endif 
9a49 e5				push hl 
9a4a 2a f2 e9			ld hl,(cli_ret_sp) 
9a4d			 
9a4d			 
9a4d				if FORTH_ENABLE_FREE 
9a4d			 
9a4d					; get pointer 
9a4d			 
9a4d					push de 
9a4d					push hl 
9a4d			 
9a4d					ld e, (hl) 
9a4d					inc hl 
9a4d					ld d, (hl) 
9a4d			 
9a4d					ex de, hl 
9a4d					call free 
9a4d			 
9a4d					pop hl 
9a4d					pop de 
9a4d			 
9a4d			 
9a4d				endif 
9a4d			 
9a4d			 
9a4d 2b				dec hl 
9a4e 2b				dec hl 
9a4f 22 f2 e9			ld (cli_ret_sp), hl 
9a52				; do stack underflow checks 
9a52 e1				pop hl 
9a53				if DEBUG_FORTH_STACK_GUARD 
9a53 cd 83 d9				call check_stacks 
9a56					FORTH_CHK_RSP_UNDER 
9a56 e5				push hl 
9a57 d5				push de 
9a58 2a f2 e9			ld hl,(cli_ret_sp) 
9a5b 11 ac e9			ld de, cli_ret_stack 
9a5e cd 05 8d			call cmp16 
9a61 da 9a da			jp c, fault_rsp_under 
9a64 d1				pop de 
9a65 e1				pop hl 
9a66				endm 
# End of macro FORTH_CHK_RSP_UNDER
9a66				endif 
9a66 c9				ret 
9a67			 
9a67			 
9a67			 
9a67			; routine to load word pointed to by hl into hl 
9a67			 
9a67			loadhlptrtohl: 
9a67			 
9a67 d5				push de 
9a68 5e				ld e, (hl) 
9a69 23				inc hl 
9a6a 56				ld d, (hl) 
9a6b eb				ex de, hl 
9a6c d1				pop de 
9a6d			 
9a6d c9				ret 
9a6e			 
9a6e			 
9a6e			 
9a6e			 
9a6e			 
9a6e			; push a number held in HL onto the data stack 
9a6e			; entry point for pushing a value when already in hl used in function above 
9a6e			 
9a6e			forth_push_numhl: 
9a6e			 
9a6e e5				push hl    ; save value to push 
9a6f			 
9a6f			if DEBUG_FORTH_PUSH 
9a6f				; see if disabled 
9a6f			 
9a6f			 
9a6f f5				push af 
9a70 3a 6f ee			ld a,(debug_vector) 
9a73 fe c9			cp $c9   ; ret 
9a75			;	ld a, (os_view_disable) 
9a75			;	cp '*' 
9a75 28 34			jr z, .pskip2 
9a77 e5				push hl 
9a78 e5			push hl 
9a79 cd ba 8a			call clear_display 
9a7c e1			pop hl 
9a7d 7c				ld a,h 
9a7e 21 c6 e5			ld hl, os_word_scratch 
9a81 cd f0 8e			call hexout 
9a84 e1				pop hl 
9a85 7d				ld a,l 
9a86 21 c8 e5			ld hl, os_word_scratch+2 
9a89 cd f0 8e			call hexout 
9a8c			 
9a8c 21 ca e5			ld hl, os_word_scratch+4 
9a8f 3e 00			ld a,0 
9a91 77				ld (hl),a 
9a92 11 c6 e5			ld de,os_word_scratch 
9a95 3e 28				ld a, display_row_2 
9a97 cd cd 8a				call str_at_display 
9a9a 11 91 cb			ld de, .push_num 
9a9d 3e 00			ld a, display_row_1 
9a9f			 
9a9f cd cd 8a				call str_at_display 
9aa2			 
9aa2			 
9aa2 cd dd 8a			call update_display 
9aa5 cd fd 89			call delay1s 
9aa8 cd fd 89			call delay1s 
9aab			.pskip2:  
9aab			 
9aab f1				pop af 
9aac			endif	 
9aac			 
9aac			 
9aac				FORTH_DSP_NEXT 
9aac cd fd 99			call macro_forth_dsp_next 
9aaf				endm 
# End of macro FORTH_DSP_NEXT
9aaf			 
9aaf 2a ee e9			ld hl, (cli_data_sp) 
9ab2			 
9ab2				; save item type 
9ab2 3e 02			ld a,  DS_TYPE_INUM 
9ab4 77				ld (hl), a 
9ab5 23				inc hl 
9ab6			 
9ab6				; get word off stack 
9ab6 d1				pop de 
9ab7 7b				ld a,e 
9ab8 77				ld (hl), a 
9ab9 23				inc hl 
9aba 7a				ld a,d 
9abb 77				ld (hl), a 
9abc			 
9abc			if DEBUG_FORTH_PUSH 
9abc 2b				dec hl 
9abd 2b				dec hl 
9abe 2b				dec hl 
9abf						DMARK "PH5" 
9abf f5				push af  
9ac0 3a d4 9a			ld a, (.dmark)  
9ac3 32 6b ee			ld (debug_mark),a  
9ac6 3a d5 9a			ld a, (.dmark+1)  
9ac9 32 6c ee			ld (debug_mark+1),a  
9acc 3a d6 9a			ld a, (.dmark+2)  
9acf 32 6d ee			ld (debug_mark+2),a  
9ad2 18 03			jr .pastdmark  
9ad4 ..			.dmark: db "PH5"  
9ad7 f1			.pastdmark: pop af  
9ad8			endm  
# End of macro DMARK
9ad8				CALLMONITOR 
9ad8 cd 6f ee			call debug_vector  
9adb				endm  
# End of macro CALLMONITOR
9adb			endif	 
9adb			 
9adb c9				ret 
9adc			 
9adc			 
9adc			; Push a string to stack pointed to by hl 
9adc			 
9adc			forth_push_str: 
9adc			 
9adc			if DEBUG_FORTH_PUSH 
9adc						DMARK "PSQ" 
9adc f5				push af  
9add 3a f1 9a			ld a, (.dmark)  
9ae0 32 6b ee			ld (debug_mark),a  
9ae3 3a f2 9a			ld a, (.dmark+1)  
9ae6 32 6c ee			ld (debug_mark+1),a  
9ae9 3a f3 9a			ld a, (.dmark+2)  
9aec 32 6d ee			ld (debug_mark+2),a  
9aef 18 03			jr .pastdmark  
9af1 ..			.dmark: db "PSQ"  
9af4 f1			.pastdmark: pop af  
9af5			endm  
# End of macro DMARK
9af5				CALLMONITOR 
9af5 cd 6f ee			call debug_vector  
9af8				endm  
# End of macro CALLMONITOR
9af8			endif	 
9af8			 
9af8			 
9af8			    
9af8 e5				push hl 
9af9 e5				push hl 
9afa			 
9afa			;	ld a, 0   ; find end of string 
9afa cd 4d 90			call strlenz 
9afd			if DEBUG_FORTH_PUSH 
9afd						DMARK "PQ2" 
9afd f5				push af  
9afe 3a 12 9b			ld a, (.dmark)  
9b01 32 6b ee			ld (debug_mark),a  
9b04 3a 13 9b			ld a, (.dmark+1)  
9b07 32 6c ee			ld (debug_mark+1),a  
9b0a 3a 14 9b			ld a, (.dmark+2)  
9b0d 32 6d ee			ld (debug_mark+2),a  
9b10 18 03			jr .pastdmark  
9b12 ..			.dmark: db "PQ2"  
9b15 f1			.pastdmark: pop af  
9b16			endm  
# End of macro DMARK
9b16				CALLMONITOR 
9b16 cd 6f ee			call debug_vector  
9b19				endm  
# End of macro CALLMONITOR
9b19			endif	 
9b19 eb				ex de, hl 
9b1a e1				pop hl   ; get ptr to start of string 
9b1b			if DEBUG_FORTH_PUSH 
9b1b						DMARK "PQ3" 
9b1b f5				push af  
9b1c 3a 30 9b			ld a, (.dmark)  
9b1f 32 6b ee			ld (debug_mark),a  
9b22 3a 31 9b			ld a, (.dmark+1)  
9b25 32 6c ee			ld (debug_mark+1),a  
9b28 3a 32 9b			ld a, (.dmark+2)  
9b2b 32 6d ee			ld (debug_mark+2),a  
9b2e 18 03			jr .pastdmark  
9b30 ..			.dmark: db "PQ3"  
9b33 f1			.pastdmark: pop af  
9b34			endm  
# End of macro DMARK
9b34				CALLMONITOR 
9b34 cd 6f ee			call debug_vector  
9b37				endm  
# End of macro CALLMONITOR
9b37			endif	 
9b37 19				add hl,de 
9b38			if DEBUG_FORTH_PUSH 
9b38						DMARK "PQE" 
9b38 f5				push af  
9b39 3a 4d 9b			ld a, (.dmark)  
9b3c 32 6b ee			ld (debug_mark),a  
9b3f 3a 4e 9b			ld a, (.dmark+1)  
9b42 32 6c ee			ld (debug_mark+1),a  
9b45 3a 4f 9b			ld a, (.dmark+2)  
9b48 32 6d ee			ld (debug_mark+2),a  
9b4b 18 03			jr .pastdmark  
9b4d ..			.dmark: db "PQE"  
9b50 f1			.pastdmark: pop af  
9b51			endm  
# End of macro DMARK
9b51				CALLMONITOR 
9b51 cd 6f ee			call debug_vector  
9b54				endm  
# End of macro CALLMONITOR
9b54			endif	 
9b54			 
9b54 2b				dec hl    ; see if there is an optional trailing double quote 
9b55 7e				ld a,(hl) 
9b56 fe 22			cp '"' 
9b58 20 03			jr nz, .strnoq 
9b5a 3e 00			ld a, 0      ; get rid of double quote 
9b5c 77				ld (hl), a 
9b5d 23			.strnoq: inc hl 
9b5e			 
9b5e 3e 00			ld a, 0 
9b60 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9b61			 
9b61 13				inc de ; add one for the type string 
9b62 13				inc de ; add one for null term??? 
9b63			 
9b63				; tos is get string pointer again 
9b63				; de contains space to allocate 
9b63				 
9b63 d5				push de 
9b64			 
9b64 eb				ex de, hl 
9b65			 
9b65				;push af 
9b65			 
9b65			if DEBUG_FORTH_PUSH 
9b65						DMARK "PHm" 
9b65 f5				push af  
9b66 3a 7a 9b			ld a, (.dmark)  
9b69 32 6b ee			ld (debug_mark),a  
9b6c 3a 7b 9b			ld a, (.dmark+1)  
9b6f 32 6c ee			ld (debug_mark+1),a  
9b72 3a 7c 9b			ld a, (.dmark+2)  
9b75 32 6d ee			ld (debug_mark+2),a  
9b78 18 03			jr .pastdmark  
9b7a ..			.dmark: db "PHm"  
9b7d f1			.pastdmark: pop af  
9b7e			endm  
# End of macro DMARK
9b7e				CALLMONITOR 
9b7e cd 6f ee			call debug_vector  
9b81				endm  
# End of macro CALLMONITOR
9b81			endif	 
9b81 cd c2 90			call malloc	; on ret hl now contains allocated memory 
9b84				if DEBUG_FORTH_MALLOC_GUARD 
9b84 cc e9 cb				call z,malloc_error 
9b87				endif 
9b87			 
9b87				 
9b87 c1				pop bc    ; get length 
9b88 d1				pop de   ;  get string start    
9b89			 
9b89				; hl has destination from malloc 
9b89			 
9b89 eb				ex de, hl    ; prep for ldir 
9b8a			 
9b8a d5				push de   ; save malloc area for DSP later 
9b8b				;push hl   ; save malloc area for DSP later 
9b8b			 
9b8b			if DEBUG_FORTH_PUSH 
9b8b						DMARK "PHc" 
9b8b f5				push af  
9b8c 3a a0 9b			ld a, (.dmark)  
9b8f 32 6b ee			ld (debug_mark),a  
9b92 3a a1 9b			ld a, (.dmark+1)  
9b95 32 6c ee			ld (debug_mark+1),a  
9b98 3a a2 9b			ld a, (.dmark+2)  
9b9b 32 6d ee			ld (debug_mark+2),a  
9b9e 18 03			jr .pastdmark  
9ba0 ..			.dmark: db "PHc"  
9ba3 f1			.pastdmark: pop af  
9ba4			endm  
# End of macro DMARK
9ba4				CALLMONITOR 
9ba4 cd 6f ee			call debug_vector  
9ba7				endm  
# End of macro CALLMONITOR
9ba7			endif	 
9ba7			 
9ba7			 
9ba7 ed b0			ldir 
9ba9			 
9ba9			 
9ba9				; push malloc to data stack     macro?????  
9ba9			 
9ba9				FORTH_DSP_NEXT 
9ba9 cd fd 99			call macro_forth_dsp_next 
9bac				endm 
# End of macro FORTH_DSP_NEXT
9bac			 
9bac				; save value and type 
9bac			 
9bac 2a ee e9			ld hl, (cli_data_sp) 
9baf			 
9baf				; save item type 
9baf 3e 01			ld a,  DS_TYPE_STR 
9bb1 77				ld (hl), a 
9bb2 23				inc hl 
9bb3			 
9bb3				; get malloc word off stack 
9bb3 d1				pop de 
9bb4 73				ld (hl), e 
9bb5 23				inc hl 
9bb6 72				ld (hl), d 
9bb7			 
9bb7			 
9bb7			 
9bb7			if DEBUG_FORTH_PUSH 
9bb7 2a ee e9			ld hl, (cli_data_sp) 
9bba						DMARK "PHS" 
9bba f5				push af  
9bbb 3a cf 9b			ld a, (.dmark)  
9bbe 32 6b ee			ld (debug_mark),a  
9bc1 3a d0 9b			ld a, (.dmark+1)  
9bc4 32 6c ee			ld (debug_mark+1),a  
9bc7 3a d1 9b			ld a, (.dmark+2)  
9bca 32 6d ee			ld (debug_mark+2),a  
9bcd 18 03			jr .pastdmark  
9bcf ..			.dmark: db "PHS"  
9bd2 f1			.pastdmark: pop af  
9bd3			endm  
# End of macro DMARK
9bd3				CALLMONITOR 
9bd3 cd 6f ee			call debug_vector  
9bd6				endm  
# End of macro CALLMONITOR
9bd6			;	ex de,hl 
9bd6			endif	 
9bd6				; in case of spaces, skip the ptr past the copied string 
9bd6				;pop af 
9bd6				;ld (cli_origptr),hl 
9bd6			 
9bd6 c9				ret 
9bd7			 
9bd7			 
9bd7			 
9bd7			; TODO ascii push input onto stack given hl to start of input 
9bd7			 
9bd7			; identify type 
9bd7			; if starts with a " then a string 
9bd7			; otherwise it is a number 
9bd7			;  
9bd7			; if a string 
9bd7			;     scan for ending " to get length of string to malloc for + 1 
9bd7			;     malloc 
9bd7			;     put pointer to string on stack first byte flags as string 
9bd7			; 
9bd7			; else a number 
9bd7			;    look for number format identifier 
9bd7			;    $xx hex 
9bd7			;    %xxxxx bin 
9bd7			;    xxxxx decimal 
9bd7			;    convert number to 16bit word.  
9bd7			;    malloc word + 1 with flag to identiy as num 
9bd7			;    put pointer to number on stack 
9bd7			;   
9bd7			;  
9bd7			  
9bd7			forth_apush: 
9bd7				; kernel push 
9bd7			 
9bd7			if DEBUG_FORTH_PUSH 
9bd7						DMARK "PSH" 
9bd7 f5				push af  
9bd8 3a ec 9b			ld a, (.dmark)  
9bdb 32 6b ee			ld (debug_mark),a  
9bde 3a ed 9b			ld a, (.dmark+1)  
9be1 32 6c ee			ld (debug_mark+1),a  
9be4 3a ee 9b			ld a, (.dmark+2)  
9be7 32 6d ee			ld (debug_mark+2),a  
9bea 18 03			jr .pastdmark  
9bec ..			.dmark: db "PSH"  
9bef f1			.pastdmark: pop af  
9bf0			endm  
# End of macro DMARK
9bf0				CALLMONITOR 
9bf0 cd 6f ee			call debug_vector  
9bf3				endm  
# End of macro CALLMONITOR
9bf3			endif	 
9bf3				; identify input type 
9bf3			 
9bf3 7e				ld a,(hl) 
9bf4			 
9bf4 fe 23			cp '#' 
9bf6 ca 30 9c			jp z, .fapdec 
9bf9			 
9bf9			 
9bf9 fe 22			cp '"' 
9bfb 28 0a			jr z, .fapstr 
9bfd fe 24			cp '$' 
9bff ca 27 9c			jp z, .faphex 
9c02 fe 25			cp '%' 
9c04 ca 0f 9c			jp z, .fapbin 
9c07			;	cp 'b' 
9c07			;	jp z, .fabin 
9c07				; else decimal 
9c07			 
9c07				; TODO do decimal conversion 
9c07				; decimal is stored as a 16bit word 
9c07			 
9c07				; by default everything is a string if type is not detected 
9c07			.fapstr: ; 
9c07 fe 22			cp '"' 
9c09 20 01			jr nz, .strnoqu 
9c0b 23				inc hl 
9c0c			.strnoqu: 
9c0c c3 dc 9a			jp forth_push_str 
9c0f			 
9c0f			 
9c0f			 
9c0f			.fapbin:    ; push a binary string.  
9c0f 11 00 00			ld de, 0   ; hold a 16bit value 
9c12			 
9c12 23			.fapbinshift:	inc hl  
9c13 7e				ld a,(hl) 
9c14 fe 00			cp 0     ; done scanning  
9c16 28 0b			jr z, .fapbdone  	; got it in HL so push  
9c18			 
9c18				; left shift de 
9c18 eb				ex de, hl	 
9c19 29				add hl, hl 
9c1a			 
9c1a				; is 1 
9c1a fe 31			cp '1' 
9c1c 20 02			jr nz, .binzero 
9c1e cb 4d			bit 1, l 
9c20			.binzero: 
9c20 eb				ex de, hl	 ; save current de 
9c21 18 ef			jr .fapbinshift 
9c23			 
9c23			.fapbdone: 
9c23 eb				ex de, hl 
9c24 c3 6e 9a			jp forth_push_numhl 
9c27			 
9c27			 
9c27			.faphex:   ; hex is always stored as a 16bit word 
9c27				; skip number prefix 
9c27 23				inc hl 
9c28				; turn ascii into number 
9c28 cd a6 8f			call get_word_hl	; ret 16bit word in hl 
9c2b			 
9c2b c3 6e 9a			jp forth_push_numhl 
9c2e			 
9c2e 00				 nop 
9c2f			 
9c2f			.fabin:   ; TODO bin conversion 
9c2f			 
9c2f			 
9c2f c9				ret 
9c30			.fapdec:	 
9c30				; string to dec conversion 
9c30 23				inc hl 
9c31 eb				ex de, hl 
9c32 cd e4 8f			call string_to_uint16 
9c35 c3 6e 9a			jp forth_push_numhl 
9c38 c9				ret 
9c39				 
9c39			;atoui_16: 
9c39			 
9c39			; get either a string ptr or a 16bit word from the data stack 
9c39			 
9c39			FORTH_DSP: macro 
9c39				call macro_forth_dsp 
9c39				endm 
9c39			 
9c39			macro_forth_dsp: 
9c39				; data stack pointer points to current word on tos 
9c39			 
9c39 2a ee e9			ld hl,(cli_data_sp) 
9c3c			 
9c3c				if DEBUG_FORTH_PUSH 
9c3c						DMARK "DSP" 
9c3c f5				push af  
9c3d 3a 51 9c			ld a, (.dmark)  
9c40 32 6b ee			ld (debug_mark),a  
9c43 3a 52 9c			ld a, (.dmark+1)  
9c46 32 6c ee			ld (debug_mark+1),a  
9c49 3a 53 9c			ld a, (.dmark+2)  
9c4c 32 6d ee			ld (debug_mark+2),a  
9c4f 18 03			jr .pastdmark  
9c51 ..			.dmark: db "DSP"  
9c54 f1			.pastdmark: pop af  
9c55			endm  
# End of macro DMARK
9c55			 
9c55 cd 1c cc				call display_data_sp 
9c58				;call break_point_state 
9c58				;rst 030h 
9c58				CALLMONITOR 
9c58 cd 6f ee			call debug_vector  
9c5b				endm  
# End of macro CALLMONITOR
9c5b				endif 
9c5b			 
9c5b c9				ret 
9c5c			 
9c5c			; return hl to start of value on stack 
9c5c			 
9c5c			FORTH_DSP_VALUE: macro 
9c5c				call macro_forth_dsp_value 
9c5c				endm 
9c5c			 
9c5c			macro_forth_dsp_value: 
9c5c			 
9c5c				FORTH_DSP 
9c5c cd 39 9c			call macro_forth_dsp 
9c5f				endm 
# End of macro FORTH_DSP
9c5f			 
9c5f d5				push de 
9c60			 
9c60 23				inc hl ; skip type 
9c61			 
9c61 5e				ld e, (hl) 
9c62 23				inc hl 
9c63 56				ld d, (hl) 
9c64 eb				ex de,hl  
9c65			 
9c65 d1				pop de 
9c66			 
9c66 c9				ret 
9c67			 
9c67			; return hl to start of value to second item on stack 
9c67			 
9c67			FORTH_DSP_VALUEM1: macro 
9c67				call macro_forth_dsp_value_m1 
9c67				endm 
9c67			 
9c67			macro_forth_dsp_value_m1: 
9c67			 
9c67				FORTH_DSP 
9c67 cd 39 9c			call macro_forth_dsp 
9c6a				endm 
# End of macro FORTH_DSP
9c6a			 
9c6a 2b				dec hl 
9c6b 2b				dec hl 
9c6c			;	dec hl 
9c6c			 
9c6c d5				push de 
9c6d			 
9c6d 5e				ld e, (hl) 
9c6e 23				inc hl 
9c6f 56				ld d, (hl) 
9c70 eb				ex de,hl  
9c71			 
9c71 d1				pop de 
9c72			 
9c72 c9				ret 
9c73			 
9c73				 
9c73			 
9c73			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9c73			 
9c73			FORTH_DSP_POP: macro 
9c73				call macro_forth_dsp_pop 
9c73				endm 
9c73			 
9c73			 
9c73			; get the tos data type 
9c73			 
9c73			FORTH_DSP_TYPE:   macro 
9c73			 
9c73				;FORTH_DSP_VALUE 
9c73				FORTH_DSP 
9c73				 
9c73				; hl points to value 
9c73				; check type 
9c73			 
9c73				ld a,(hl) 
9c73			 
9c73				endm 
9c73			 
9c73			; load the tos value into hl 
9c73			 
9c73			 
9c73			FORTH_DSP_VALUEHL:  macro 
9c73				call macro_dsp_valuehl 
9c73				endm 
9c73			 
9c73			 
9c73			 
9c73			macro_dsp_valuehl: 
9c73				FORTH_DSP_VALUE 
9c73 cd 5c 9c			call macro_forth_dsp_value 
9c76				endm 
# End of macro FORTH_DSP_VALUE
9c76			 
9c76				;FORTH_ERR_TOS_NOTNUM 
9c76			 
9c76				;inc hl   ; skip type id 
9c76			 
9c76			;	push de 
9c76			; 
9c76			;	ld e, (hl) 
9c76			;	inc hl 
9c76			;	ld d, (hl) 
9c76			;	ex de,hl  
9c76			 
9c76			;	pop de 
9c76			 
9c76				if DEBUG_FORTH_PUSH 
9c76						DMARK "DVL" 
9c76 f5				push af  
9c77 3a 8b 9c			ld a, (.dmark)  
9c7a 32 6b ee			ld (debug_mark),a  
9c7d 3a 8c 9c			ld a, (.dmark+1)  
9c80 32 6c ee			ld (debug_mark+1),a  
9c83 3a 8d 9c			ld a, (.dmark+2)  
9c86 32 6d ee			ld (debug_mark+2),a  
9c89 18 03			jr .pastdmark  
9c8b ..			.dmark: db "DVL"  
9c8e f1			.pastdmark: pop af  
9c8f			endm  
# End of macro DMARK
9c8f				CALLMONITOR 
9c8f cd 6f ee			call debug_vector  
9c92				endm  
# End of macro CALLMONITOR
9c92				endif 
9c92 c9				ret 
9c93			 
9c93			forth_apushstrhl:      
9c93				; push of string requires use of cli_origptr 
9c93				; bodge use 
9c93			 
9c93				; get current cli_origptr, save, update with temp pointer  
9c93 ed 5b 3e ea		ld de, (cli_origptr) 
9c97 22 3e ea			ld (cli_origptr), hl 
9c9a d5				push de 
9c9b cd d7 9b			call forth_apush 
9c9e d1				pop de 
9c9f ed 53 3e ea		ld (cli_origptr), de 
9ca3 c9			        ret	 
9ca4			 
9ca4			 
9ca4			; increase loop stack pointer and save hl to it 
9ca4				 
9ca4			FORTH_LOOP_NEXT: macro 
9ca4				call macro_forth_loop_next 
9ca4				;nop 
9ca4				endm 
9ca4			 
9ca4			macro_forth_loop_next: 
9ca4				if DEBUG_FORTH_STACK_GUARD 
9ca4 cd 83 d9				call check_stacks 
9ca7				endif 
9ca7 e5				push hl 
9ca8 d5				push de 
9ca9 eb				ex de,hl 
9caa 2a f0 e9			ld hl,(cli_loop_sp) 
9cad 23				inc hl 
9cae 23				inc hl 
9caf					if DEBUG_FORTH_WORDS 
9caf						DMARK "LNX" 
9caf f5				push af  
9cb0 3a c4 9c			ld a, (.dmark)  
9cb3 32 6b ee			ld (debug_mark),a  
9cb6 3a c5 9c			ld a, (.dmark+1)  
9cb9 32 6c ee			ld (debug_mark+1),a  
9cbc 3a c6 9c			ld a, (.dmark+2)  
9cbf 32 6d ee			ld (debug_mark+2),a  
9cc2 18 03			jr .pastdmark  
9cc4 ..			.dmark: db "LNX"  
9cc7 f1			.pastdmark: pop af  
9cc8			endm  
# End of macro DMARK
9cc8						CALLMONITOR 
9cc8 cd 6f ee			call debug_vector  
9ccb				endm  
# End of macro CALLMONITOR
9ccb					endif 
9ccb 22 f0 e9			ld (cli_loop_sp),hl 
9cce 73				ld (hl), e 
9ccf 23				inc hl 
9cd0 72				ld (hl), d 
9cd1 d1				pop de    ; been reversed so save a swap on restore 
9cd2 e1				pop hl 
9cd3				if DEBUG_FORTH_STACK_GUARD 
9cd3 cd 83 d9				call check_stacks 
9cd6				endif 
9cd6 c9				ret 
9cd7			 
9cd7			; get current ret stack pointer and save to hl  
9cd7				 
9cd7			FORTH_LOOP_TOS: macro 
9cd7				call macro_forth_loop_tos 
9cd7				endm 
9cd7			 
9cd7			macro_forth_loop_tos: 
9cd7 d5				push de 
9cd8 2a f0 e9			ld hl,(cli_loop_sp) 
9cdb 5e				ld e, (hl) 
9cdc 23				inc hl 
9cdd 56				ld d, (hl) 
9cde eb				ex de, hl 
9cdf d1				pop de 
9ce0 c9				ret 
9ce1			 
9ce1			; pop loop stack pointer 
9ce1				 
9ce1			FORTH_LOOP_POP: macro 
9ce1				call macro_forth_loop_pop 
9ce1				endm 
9ce1			 
9ce1			 
9ce1			macro_forth_loop_pop: 
9ce1				if DEBUG_FORTH_STACK_GUARD 
9ce1					DMARK "LPP" 
9ce1 f5				push af  
9ce2 3a f6 9c			ld a, (.dmark)  
9ce5 32 6b ee			ld (debug_mark),a  
9ce8 3a f7 9c			ld a, (.dmark+1)  
9ceb 32 6c ee			ld (debug_mark+1),a  
9cee 3a f8 9c			ld a, (.dmark+2)  
9cf1 32 6d ee			ld (debug_mark+2),a  
9cf4 18 03			jr .pastdmark  
9cf6 ..			.dmark: db "LPP"  
9cf9 f1			.pastdmark: pop af  
9cfa			endm  
# End of macro DMARK
9cfa cd 83 d9				call check_stacks 
9cfd					FORTH_CHK_LOOP_UNDER 
9cfd e5				push hl 
9cfe d5				push de 
9cff 2a f0 e9			ld hl,(cli_loop_sp) 
9d02 11 2a e9			ld de, cli_loop_stack 
9d05 cd 05 8d			call cmp16 
9d08 da a0 da			jp c, fault_loop_under 
9d0b d1				pop de 
9d0c e1				pop hl 
9d0d				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9d0d				endif 
9d0d e5				push hl 
9d0e 2a f0 e9			ld hl,(cli_loop_sp) 
9d11 2b				dec hl 
9d12 2b				dec hl 
9d13 22 f0 e9			ld (cli_loop_sp), hl 
9d16				; TODO do stack underflow checks 
9d16 e1				pop hl 
9d17				if DEBUG_FORTH_STACK_GUARD 
9d17 cd 83 d9				call check_stacks 
9d1a					FORTH_CHK_LOOP_UNDER 
9d1a e5				push hl 
9d1b d5				push de 
9d1c 2a f0 e9			ld hl,(cli_loop_sp) 
9d1f 11 2a e9			ld de, cli_loop_stack 
9d22 cd 05 8d			call cmp16 
9d25 da a0 da			jp c, fault_loop_under 
9d28 d1				pop de 
9d29 e1				pop hl 
9d2a				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9d2a				endif 
9d2a c9				ret 
9d2b			 
9d2b			macro_forth_dsp_pop: 
9d2b			 
9d2b e5				push hl 
9d2c			 
9d2c				; release malloc data 
9d2c			 
9d2c				if DEBUG_FORTH_STACK_GUARD 
9d2c cd 83 d9				call check_stacks 
9d2f					FORTH_CHK_DSP_UNDER 
9d2f e5				push hl 
9d30 d5				push de 
9d31 2a ee e9			ld hl,(cli_data_sp) 
9d34 11 28 e8			ld de, cli_data_stack 
9d37 cd 05 8d			call cmp16 
9d3a da 94 da			jp c, fault_dsp_under 
9d3d d1				pop de 
9d3e e1				pop hl 
9d3f				endm 
# End of macro FORTH_CHK_DSP_UNDER
9d3f				endif 
9d3f				;ld hl,(cli_data_sp) 
9d3f			if DEBUG_FORTH_DOT 
9d3f				DMARK "DPP" 
9d3f f5				push af  
9d40 3a 54 9d			ld a, (.dmark)  
9d43 32 6b ee			ld (debug_mark),a  
9d46 3a 55 9d			ld a, (.dmark+1)  
9d49 32 6c ee			ld (debug_mark+1),a  
9d4c 3a 56 9d			ld a, (.dmark+2)  
9d4f 32 6d ee			ld (debug_mark+2),a  
9d52 18 03			jr .pastdmark  
9d54 ..			.dmark: db "DPP"  
9d57 f1			.pastdmark: pop af  
9d58			endm  
# End of macro DMARK
9d58				CALLMONITOR 
9d58 cd 6f ee			call debug_vector  
9d5b				endm  
# End of macro CALLMONITOR
9d5b			endif	 
9d5b			 
9d5b			 
9d5b			if FORTH_ENABLE_DSPPOPFREE 
9d5b			 
9d5b				FORTH_DSP 
9d5b cd 39 9c			call macro_forth_dsp 
9d5e				endm 
# End of macro FORTH_DSP
9d5e			 
9d5e 7e				ld a, (hl) 
9d5f fe 01			cp DS_TYPE_STR 
9d61 20 23			jr nz, .skippopfree 
9d63			 
9d63				FORTH_DSP_VALUEHL 
9d63 cd 73 9c			call macro_dsp_valuehl 
9d66				endm 
# End of macro FORTH_DSP_VALUEHL
9d66 00				nop 
9d67			if DEBUG_FORTH_DOT 
9d67				DMARK "DPf" 
9d67 f5				push af  
9d68 3a 7c 9d			ld a, (.dmark)  
9d6b 32 6b ee			ld (debug_mark),a  
9d6e 3a 7d 9d			ld a, (.dmark+1)  
9d71 32 6c ee			ld (debug_mark+1),a  
9d74 3a 7e 9d			ld a, (.dmark+2)  
9d77 32 6d ee			ld (debug_mark+2),a  
9d7a 18 03			jr .pastdmark  
9d7c ..			.dmark: db "DPf"  
9d7f f1			.pastdmark: pop af  
9d80			endm  
# End of macro DMARK
9d80				CALLMONITOR 
9d80 cd 6f ee			call debug_vector  
9d83				endm  
# End of macro CALLMONITOR
9d83			endif	 
9d83 cd 8c 91			call free 
9d86			.skippopfree: 
9d86				 
9d86			 
9d86			endif 
9d86			 
9d86			if DEBUG_FORTH_DOT_KEY 
9d86				DMARK "DP2" 
9d86				CALLMONITOR 
9d86			endif	 
9d86			 
9d86				; move pointer down 
9d86			 
9d86 2a ee e9			ld hl,(cli_data_sp) 
9d89 2b				dec hl 
9d8a 2b				dec hl 
9d8b			; PARSEV5 
9d8b 2b				dec hl 
9d8c 22 ee e9			ld (cli_data_sp), hl 
9d8f			 
9d8f				if DEBUG_FORTH_STACK_GUARD 
9d8f cd 83 d9				call check_stacks 
9d92					FORTH_CHK_DSP_UNDER 
9d92 e5				push hl 
9d93 d5				push de 
9d94 2a ee e9			ld hl,(cli_data_sp) 
9d97 11 28 e8			ld de, cli_data_stack 
9d9a cd 05 8d			call cmp16 
9d9d da 94 da			jp c, fault_dsp_under 
9da0 d1				pop de 
9da1 e1				pop hl 
9da2				endm 
# End of macro FORTH_CHK_DSP_UNDER
9da2				endif 
9da2			 
9da2 e1				pop hl 
9da3			 
9da3 c9				ret 
9da4			 
9da4			getwordathl: 
9da4				; hl points to an address 
9da4				; load hl with the word at that address 
9da4			 
9da4 d5				push de 
9da5			 
9da5 5e				ld e, (hl) 
9da6 23				inc hl 
9da7 56				ld d, (hl) 
9da8 eb				ex de, hl 
9da9			 
9da9 d1				pop de 
9daa c9				ret 
9dab			 
9dab			 
9dab			 
9dab			 
9dab			 
9dab			; eof 
9dab			 
# End of file forth_stackopsv5.asm
9dab			endif 
9dab			 
9dab			loadwordinhl:	 
9dab			 
9dab d5				push de 
9dac			 
9dac 5e				ld e, (hl) 
9dad 23				inc hl 
9dae 56				ld d, (hl) 
9daf eb				ex de,hl  
9db0			 
9db0 d1				pop de 
9db1			 
9db1 c9				ret 
9db2			 
9db2			user_word_eol:  
9db2				; hl contains the pointer to where to create a linked list item from the end 
9db2				; of the user dict to continue on at the system word dict 
9db2				 
9db2				; poke the stub of the word list linked list to repoint to rom words 
9db2			 
9db2				; stub format 
9db2				; db   word id 
9db2				; dw    link to next word 
9db2			        ; db char length of token 
9db2				; db string + 0 term 
9db2				; db exec code....  
9db2			 
9db2 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9db4 77				ld (hl), a		; word id 
9db5 23				inc hl 
9db6			 
9db6 11 81 9f			ld de, sysdict 
9db9 73				ld (hl), e		; next word link ie system dict 
9dba 23				inc hl 
9dbb 72				ld (hl), d		; next word link ie system dict 
9dbc 23				inc hl	 
9dbd			 
9dbd			;	ld (hl), sysdict		; next word link ie system dict 
9dbd			;	inc hl 
9dbd			;	inc hl 
9dbd			 
9dbd			;	inc hl 
9dbd			;	inc hl 
9dbd			 
9dbd 3e 02			ld a, 2			; word length is 0 
9dbf 77				ld (hl), a	 
9dc0 23				inc hl 
9dc1			 
9dc1 3e 7e			ld a, '~'			; word length is 0 
9dc3 77				ld (hl), a	 
9dc4 23				inc hl 
9dc5 3e 00			ld a, 0			; save empty word 
9dc7 77				ld (hl), a 
9dc8			 
9dc8 c9				ret 
9dc9			 
9dc9				 
9dc9			 
9dc9			forthexec_cleanup: 
9dc9				FORTH_RSP_POP 
9dc9 cd 36 9a			call macro_forth_rsp_pop 
9dcc				endm 
# End of macro FORTH_RSP_POP
9dcc c9				ret 
9dcd			 
9dcd			forth_call_hl: 
9dcd				; taking hl 
9dcd e5				push hl 
9dce c9				ret 
9dcf			 
9dcf			; this is called to reset Forth system but keep existing uwords etc 
9dcf			 
9dcf			forth_warmstart: 
9dcf				; setup stack over/under flow checks 
9dcf				if DEBUG_FORTH_STACK_GUARD 
9dcf cd 69 d9				call chk_stk_init 
9dd2				endif 
9dd2			 
9dd2				; init stack pointers  - * these stacks go upwards *  
9dd2 21 ac e9			ld hl, cli_ret_stack 
9dd5 22 f2 e9			ld (cli_ret_sp), hl	 
9dd8				; set bottom of stack 
9dd8 3e 00			ld a,0 
9dda 77				ld (hl),a 
9ddb 23				inc hl 
9ddc 77				ld (hl),a 
9ddd			 
9ddd 21 28 e8			ld hl, cli_data_stack 
9de0 22 ee e9			ld (cli_data_sp), hl	 
9de3				; set bottom of stack 
9de3 3e 00			ld a,0 
9de5 77				ld (hl),a 
9de6 23				inc hl 
9de7 77				ld (hl),a 
9de8			 
9de8 21 2a e9			ld hl, cli_loop_stack 
9deb 22 f0 e9			ld (cli_loop_sp), hl	 
9dee				; set bottom of stack 
9dee 3e 00			ld a,0 
9df0 77				ld (hl),a 
9df1 23				inc hl 
9df2 77				ld (hl),a 
9df3			 
9df3				; init extent of current open file 
9df3			 
9df3 3e 00			ld a, 0 
9df5 32 6a ea			ld (store_openext), a 
9df8			 
9df8 c9				ret 
9df9			 
9df9			 
9df9			 
9df9			; Cold Start - this is called to setup the whole Forth system 
9df9			 
9df9			forth_init: 
9df9			 
9df9				; setup stack over/under flow checks 
9df9			 
9df9			;	if DEBUG_FORTH_STACK_GUARD 
9df9			;		call chk_stk_init 
9df9			;	endif 
9df9			 
9df9				; enable auto display updates (slow.....) 
9df9			 
9df9 3e 01			ld a, 1 
9dfb 32 3c ea			ld (cli_autodisplay), a 
9dfe			 
9dfe				; if storage is in use disable long reads for now 
9dfe 3e 00			ld a, 0 
9e00 32 75 ea			ld (store_longread), a 
9e03			 
9e03			 
9e03				; show start up screen 
9e03			 
9e03 cd ba 8a			call clear_display 
9e06			 
9e06 3e 00			ld a,0 
9e08 32 5e ea			ld (f_cursor_ptr), a 
9e0b			 
9e0b				; set start of word list in start of ram - for use when creating user words 
9e0b			 
9e0b 21 26 dd			ld hl, baseram 
9e0e 22 be e5			ld (os_last_new_uword), hl 
9e11 cd b2 9d			call user_word_eol 
9e14				 
9e14			;		call display_data_sp 
9e14			;		call next_page_prompt 
9e14			 
9e14			 
9e14			 
9e14			 
9e14 c9				ret 
9e15			 
9e15 .. 00		.bootforth: db " Forth Kernel Init ",0 
9e29			 
9e29			; TODO push to stack 
9e29			 
9e29			;  
9e29			 
9e29			if FORTH_PARSEV2 
9e29			 
9e29			 
9e29				include "forth_parserv2.asm" 
9e29			 
9e29			endif 
9e29			 
9e29			 
9e29			; parse cli version 1 
9e29			 
9e29			if FORTH_PARSEV1 
9e29			 
9e29			 
9e29			 
9e29			      include "forth_parserv1.asm" 
9e29			endif 
9e29				 
9e29			if FORTH_PARSEV3 
9e29			 
9e29			 
9e29			 
9e29			      include "forth_parserv3.asm" 
9e29				include "forth_wordsv3.asm" 
9e29			endif 
9e29			 
9e29			if FORTH_PARSEV4 
9e29			 
9e29			 
9e29			 
9e29			      include "forth_parserv4.asm" 
9e29				include "forth_wordsv4.asm" 
9e29			endif 
9e29			 
9e29			if FORTH_PARSEV5 
9e29			 
9e29			 
9e29			 
9e29			      include "forth_parserv5.asm" 
9e29			 
9e29			 
9e29			; A better parser without using malloc and string copies all over the place.  
9e29			; Exec in situ should be faster 
9e29			 
9e29			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9e29			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9e29			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9e29			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9e29			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9e29			WORD_SYS_END: equ 0   ; Opcode for all user words 
9e29			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9e29			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9e29			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9e29			 
9e29			; Core word preamble macro 
9e29			 
9e29			CWHEAD:   macro nxtword opcode lit len opflags 
9e29				db WORD_SYS_CORE+opcode             
9e29				; internal op code number 
9e29				dw nxtword            
9e29				; link to next dict word block 
9e29				db len + 1 
9e29				; literal length of dict word inc zero term 
9e29				db lit,0              
9e29				; literal dict word 
9e29			        ; TODO db opflags        
9e29				endm 
9e29			 
9e29			 
9e29			NEXTW: macro  
9e29				jp macro_next 
9e29				endm 
9e29			 
9e29			macro_next: 
9e29			if DEBUG_FORTH_PARSE_KEY 
9e29				DMARK "NXT" 
9e29				CALLMONITOR 
9e29			endif	 
9e29			;	inc hl  ; skip token null term  
9e29 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9e2d ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9e31 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9e34			if DEBUG_FORTH_PARSE_KEY 
9e34				DMARK "}AA" 
9e34				CALLMONITOR 
9e34			endif	 
9e34 c3 37 9f			jp execnext 
9e37				;jp exec1 
9e37			       
9e37			 
9e37			 
9e37			; Another go at the parser to compile  
9e37			 
9e37			 
9e37			; TODO rework parser to change all of the string words to byte tokens 
9e37			; TODO do a search for  
9e37			 
9e37			; TODO first run normal parser to zero term sections 
9e37			; TODO for each word do a token look up to get the op code 
9e37			; TODO need some means to flag to the exec that this is a byte code form    
9e37			 
9e37			 
9e37			forthcompile: 
9e37			 
9e37			; 
9e37			; line parse: 
9e37			;       parse raw input buffer 
9e37			;       tokenise the words 
9e37			;       malloc new copy (for looping etc) 
9e37			;       copy to malloc + current pc in line to start of string and add line term 
9e37			;       save on new rsp 
9e37			; 
9e37			 
9e37			; hl to point to the line to tokenise 
9e37			 
9e37			;	push hl 
9e37 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9e3a			 
9e3a			;	ld a,0		; string term on input 
9e3a			;	call strlent 
9e3a			 
9e3a			;	ld (os_tok_len), hl	 ; save string length 
9e3a			 
9e3a			;if DEBUG_FORTH_TOK 
9e3a			;	ex de,hl		 
9e3a			;endif 
9e3a			 
9e3a			;	pop hl 		; get back string pointer 
9e3a			 
9e3a			if DEBUG_FORTH_TOK 
9e3a						DMARK "TOc" 
9e3a				CALLMONITOR 
9e3a			endif 
9e3a 7e			.cptoken2:    ld a,(hl) 
9e3b 23				inc hl 
9e3c fe 7f			cp FORTH_END_BUFFER 
9e3e 28 29			jr z, .cptokendone2 
9e40 fe 00			cp 0 
9e42 28 25			jr z, .cptokendone2 
9e44 fe 22			cp '"' 
9e46 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9e48 fe 20			cp ' ' 
9e4a 20 ee			jr nz,  .cptoken2 
9e4c			 
9e4c			; TODO consume comments held between ( and ) 
9e4c			 
9e4c				; we have a space so change to zero term for dict match later 
9e4c 2b				dec hl 
9e4d 3e 00			ld a,0 
9e4f 77				ld (hl), a 
9e50 23				inc hl 
9e51 18 e7			jr .cptoken2 
9e53				 
9e53			 
9e53			.cptokenstr2: 
9e53				; skip all white space until either eol (because forgot to term) or end double quote 
9e53			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9e53				;inc hl ; skip current double quote 
9e53 7e				ld a,(hl) 
9e54 23				inc hl 
9e55 fe 22			cp '"' 
9e57 28 e1			jr z, .cptoken2 
9e59 fe 7f			cp FORTH_END_BUFFER 
9e5b 28 0c			jr z, .cptokendone2 
9e5d fe 00			cp 0 
9e5f 28 08			jr z, .cptokendone2 
9e61 fe 20			cp ' ' 
9e63 28 02			jr z, .cptmp2 
9e65 18 ec			jr .cptokenstr2 
9e67			 
9e67			.cptmp2:	; we have a space so change to zero term for dict match later 
9e67				;dec hl 
9e67				;ld a,"-"	; TODO remove this when working 
9e67				;ld (hl), a 
9e67				;inc hl 
9e67 18 ea			jr .cptokenstr2 
9e69			 
9e69			.cptokendone2: 
9e69				;inc hl 
9e69 3e 7f			ld a, FORTH_END_BUFFER 
9e6b 77				ld (hl),a 
9e6c 23				inc hl 
9e6d 3e 21			ld a, '!' 
9e6f 77				ld (hl),a 
9e70			 
9e70 2a c2 e5			ld hl,(os_tok_ptr) 
9e73			         
9e73			if DEBUG_FORTH_TOK 
9e73						DMARK "Tc1" 
9e73				CALLMONITOR 
9e73			endif 
9e73			 
9e73				; push exec string to top of return stack 
9e73				FORTH_RSP_NEXT 
9e73 cd 15 9a			call macro_forth_rsp_next 
9e76				endm 
# End of macro FORTH_RSP_NEXT
9e76 c9				ret 
9e77			 
9e77			; Another go at the parser need to simplify the process 
9e77			 
9e77			forthparse: 
9e77			 
9e77			; 
9e77			; line parse: 
9e77			;       parse raw input buffer 
9e77			;       tokenise the words 
9e77			;       malloc new copy (for looping etc) 
9e77			;       copy to malloc + current pc in line to start of string and add line term 
9e77			;       save on new rsp 
9e77			; 
9e77			 
9e77			; hl to point to the line to tokenise 
9e77			 
9e77			;	push hl 
9e77 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9e7a			 
9e7a			;	ld a,0		; string term on input 
9e7a			;	call strlent 
9e7a			 
9e7a			;	ld (os_tok_len), hl	 ; save string length 
9e7a			 
9e7a			;if DEBUG_FORTH_TOK 
9e7a			;	ex de,hl		 
9e7a			;endif 
9e7a			 
9e7a			;	pop hl 		; get back string pointer 
9e7a			 
9e7a			if DEBUG_FORTH_TOK 
9e7a						DMARK "TOK" 
9e7a				CALLMONITOR 
9e7a			endif 
9e7a 7e			.ptoken2:    ld a,(hl) 
9e7b 23				inc hl 
9e7c fe 7f			cp FORTH_END_BUFFER 
9e7e 28 29			jr z, .ptokendone2 
9e80 fe 00			cp 0 
9e82 28 25			jr z, .ptokendone2 
9e84 fe 22			cp '"' 
9e86 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9e88 fe 20			cp ' ' 
9e8a 20 ee			jr nz,  .ptoken2 
9e8c			 
9e8c			; TODO consume comments held between ( and ) 
9e8c			 
9e8c				; we have a space so change to zero term for dict match later 
9e8c 2b				dec hl 
9e8d 3e 00			ld a,0 
9e8f 77				ld (hl), a 
9e90 23				inc hl 
9e91 18 e7			jr .ptoken2 
9e93				 
9e93			 
9e93			.ptokenstr2: 
9e93				; skip all white space until either eol (because forgot to term) or end double quote 
9e93			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9e93				;inc hl ; skip current double quote 
9e93 7e				ld a,(hl) 
9e94 23				inc hl 
9e95 fe 22			cp '"' 
9e97 28 e1			jr z, .ptoken2 
9e99 fe 7f			cp FORTH_END_BUFFER 
9e9b 28 0c			jr z, .ptokendone2 
9e9d fe 00			cp 0 
9e9f 28 08			jr z, .ptokendone2 
9ea1 fe 20			cp ' ' 
9ea3 28 02			jr z, .ptmp2 
9ea5 18 ec			jr .ptokenstr2 
9ea7			 
9ea7			.ptmp2:	; we have a space so change to zero term for dict match later 
9ea7				;dec hl 
9ea7				;ld a,"-"	; TODO remove this when working 
9ea7				;ld (hl), a 
9ea7				;inc hl 
9ea7 18 ea			jr .ptokenstr2 
9ea9			 
9ea9			.ptokendone2: 
9ea9				;inc hl 
9ea9 3e 7f			ld a, FORTH_END_BUFFER 
9eab 77				ld (hl),a 
9eac 23				inc hl 
9ead 3e 21			ld a, '!' 
9eaf 77				ld (hl),a 
9eb0			 
9eb0 2a c2 e5			ld hl,(os_tok_ptr) 
9eb3			         
9eb3			if DEBUG_FORTH_TOK 
9eb3						DMARK "TK1" 
9eb3				CALLMONITOR 
9eb3			endif 
9eb3			 
9eb3				; push exec string to top of return stack 
9eb3				FORTH_RSP_NEXT 
9eb3 cd 15 9a			call macro_forth_rsp_next 
9eb6				endm 
# End of macro FORTH_RSP_NEXT
9eb6 c9				ret 
9eb7			 
9eb7			; 
9eb7			;	; malloc size + buffer pointer + if is loop flag 
9eb7			;	ld hl,(os_tok_len) 		 ; get string length 
9eb7			; 
9eb7			;	ld a,l 
9eb7			; 
9eb7			;	cp 0			; we dont want to use a null string 
9eb7			;	ret z 
9eb7			; 
9eb7			;;	add 3    ; prefix malloc with buffer for current word ptr 
9eb7			; 
9eb7			;	add 5     ; TODO when certain not over writing memory remove 
9eb7			; 
9eb7			;		 
9eb7			; 
9eb7			;if DEBUG_FORTH_TOK 
9eb7			;			DMARK "TKE" 
9eb7			;	CALLMONITOR 
9eb7			;endif 
9eb7			; 
9eb7			;	ld l,a 
9eb7			;	ld h,0 
9eb7			;;	push hl   ; save required space for the copy later 
9eb7			;	call malloc 
9eb7			;if DEBUG_FORTH_TOK 
9eb7			;			DMARK "TKM" 
9eb7			;	CALLMONITOR 
9eb7			;endif 
9eb7			;	if DEBUG_FORTH_MALLOC_GUARD 
9eb7			;		push af 
9eb7			;		call ishlzero 
9eb7			;;		ld a, l 
9eb7			;;		add h 
9eb7			;;		cp 0 
9eb7			;		pop af 
9eb7			;		 
9eb7			;		call z,malloc_error 
9eb7			;	endif 
9eb7			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9eb7			; 
9eb7			; 
9eb7			;if DEBUG_FORTH_TOK 
9eb7			;			DMARK "TKR" 
9eb7			;	CALLMONITOR 
9eb7			;endif 
9eb7			; 
9eb7			;	FORTH_RSP_NEXT 
9eb7			; 
9eb7			;	;inc hl	 ; go past current buffer pointer 
9eb7			;	;inc hl 
9eb7			;	;inc hl   ; and past if loop flag 
9eb7			;		; TODO Need to set flag  
9eb7			; 
9eb7			;	 
9eb7			;	 
9eb7			;	ex de,hl	; malloc is dest 
9eb7			;	ld hl, (os_tok_len) 
9eb7			;;	pop bc 
9eb7			;	ld c, l                
9eb7			;	ld b,0 
9eb7			;	ld hl, (os_tok_ptr) 
9eb7			; 
9eb7			;if DEBUG_FORTH_TOK 
9eb7			;			DMARK "TKT" 
9eb7			;	CALLMONITOR 
9eb7			;endif 
9eb7			; 
9eb7			;	; do str cpy 
9eb7			; 
9eb7			;	ldir      ; copy byte in hl to de 
9eb7			; 
9eb7			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9eb7			; 
9eb7			;if DEBUG_FORTH_TOK 
9eb7			; 
9eb7			;			DMARK "TKY" 
9eb7			;	CALLMONITOR 
9eb7			;endif 
9eb7			;	;ld a,0 
9eb7			;	;ld a,FORTH_END_BUFFER 
9eb7			;	ex de, hl 
9eb7			;	;dec hl			 ; go back over the space delim at the end of word 
9eb7			;	;ld (hl),a 
9eb7			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9eb7			;	ld a,FORTH_END_BUFFER 
9eb7			;	ld (hl),a 
9eb7			;	inc hl 
9eb7			;	ld a,FORTH_END_BUFFER 
9eb7			;	ld (hl),a 
9eb7			; 
9eb7			;	; init the malloc area data 
9eb7			;	; set pc for in current area 
9eb7			;	;ld hl, (os_tok_malloc) 
9eb7			;	;inc hl 
9eb7			;	;inc hl 
9eb7			;	;inc hl 
9eb7			;	;ex de,hl 
9eb7			;	;ld hl, (os_tok_malloc) 
9eb7			;	;ld (hl),e 
9eb7			;	;inc hl 
9eb7			;	;ld (hl),d 
9eb7			; 
9eb7			; 
9eb7			;	ld hl,(os_tok_malloc) 
9eb7			;if DEBUG_FORTH_PARSE_KEY 
9eb7			;			DMARK "TKU" 
9eb7			;	CALLMONITOR 
9eb7			;endif 
9eb7			; 
9eb7			;	ret 
9eb7			 
9eb7			forthexec: 
9eb7			 
9eb7			; line exec: 
9eb7			; forth parser 
9eb7			 
9eb7			; 
9eb7			;       get current exec line on rsp 
9eb7			 
9eb7				FORTH_RSP_TOS 
9eb7 cd 2c 9a			call macro_forth_rsp_tos 
9eba				endm 
# End of macro FORTH_RSP_TOS
9eba			 
9eba			;       restore current pc - hl points to malloc of data 
9eba			 
9eba				;ld e, (hl) 
9eba				;inc hl 
9eba				;ld d, (hl) 
9eba				;ex de,hl 
9eba			 
9eba			 
9eba			exec1: 
9eba 22 c2 e5			ld (os_tok_ptr), hl 
9ebd			 
9ebd				; copy our PC to working vars  
9ebd 22 40 ea			ld (cli_ptr), hl 
9ec0 22 3e ea			ld (cli_origptr), hl 
9ec3			 
9ec3 7e				ld a,(hl) 
9ec4 fe 7f			cp FORTH_END_BUFFER 
9ec6 c8				ret z 
9ec7			 
9ec7				; skip any nulls 
9ec7			 
9ec7 fe 00			cp 0 
9ec9 20 03			jr nz, .execword 
9ecb 23				inc hl 
9ecc 18 ec			jr exec1 
9ece			 
9ece			 
9ece			.execword: 
9ece			 
9ece			 
9ece			 
9ece			if DEBUG_FORTH_PARSE_KEY 
9ece						DMARK "KYQ" 
9ece				CALLMONITOR 
9ece			endif 
9ece			;       while at start of word: 
9ece			; get start of dict (in user area first) 
9ece			 
9ece 21 26 dd		ld hl, baseram 
9ed1			;ld hl, sysdict 
9ed1 22 42 ea		ld (cli_nextword),hl 
9ed4			;           match word at pc 
9ed4			;           exec word 
9ed4			;           or push to dsp 
9ed4			;           forward to next token 
9ed4			;           if line term pop rsp and exit 
9ed4			;        
9ed4			 
9ed4			if DEBUG_FORTH_PARSE_KEY 
9ed4						DMARK "KYq" 
9ed4				CALLMONITOR 
9ed4			endif 
9ed4			 
9ed4			; 
9ed4			; word comp 
9ed4			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9ed4			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9ed4			;    move to start of word  
9ed4			;    compare word to cli_token 
9ed4			 
9ed4			.execpnword:	; HL at start of a word in the dictionary to check 
9ed4			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9ed4			;	ld (cli_ptr), hl 
9ed4			 
9ed4 2a 42 ea			ld hl,(cli_nextword) 
9ed7			 
9ed7 cd 7a 9f			call forth_tok_next 
9eda			; tok next start here 
9eda			;	; TODO skip compiled symbol for now 
9eda			;	inc hl 
9eda			; 
9eda			;	; save pointer to next word 
9eda			; 
9eda			;	; hl now points to the address of the next word pointer  
9eda			;	ld e, (hl) 
9eda			;	inc hl 
9eda			;	ld d, (hl) 
9eda			;	inc l 
9eda			; 
9eda			;	ex de,hl 
9eda			;if DEBUG_FORTH_PARSE_NEXTWORD 
9eda			;	push bc 
9eda			;	ld bc, (cli_nextword) 
9eda			;			DMARK "NXW" 
9eda			;	CALLMONITOR 
9eda			;	pop bc 
9eda			;endif 
9eda			; tok next end here 
9eda 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9edd eb				ex de, hl 
9ede			 
9ede			 
9ede				; save the pointer of the current token - 1 to check against 
9ede				 
9ede 22 46 ea			ld (cli_token), hl   
9ee1				; TODO maybe remove below save if no debug 
9ee1				; save token string ptr for any debug later 
9ee1 23				inc hl  
9ee2 22 48 ea			ld (cli_origtoken), hl 
9ee5 2b				dec hl 
9ee6				; save pointer to the start of the next dictionay word 
9ee6 7e				ld a,(hl)   ; get string length 
9ee7 47				ld b,a 
9ee8			.execpnwordinc:  
9ee8 23				inc hl 
9ee9 10 fd			djnz .execpnwordinc 
9eeb 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
9eee			 
9eee				; now check the word token against the string being parsed 
9eee			 
9eee 2a 46 ea			ld hl,(cli_token) 
9ef1 23				inc hl     ; skip string length (use zero term instead to end) 
9ef2 22 46 ea			ld (cli_token), hl 
9ef5			 
9ef5			if DEBUG_FORTH_PARSE_KEY 
9ef5						DMARK "KY2" 
9ef5			endif 
9ef5			if DEBUG_FORTH_PARSE_EXEC 
9ef5				; see if disabled 
9ef5			 
9ef5			;	ld a, (os_view_disable) 
9ef5			;	cp '*' 
9ef5				ld a, (debug_vector) 
9ef5				cp $c9   ; RET  
9ef5				jr z, .skip 
9ef5			 
9ef5				push hl 
9ef5				push hl 
9ef5				call clear_display 
9ef5				ld de, .compword 
9ef5				ld a, display_row_1 
9ef5				call str_at_display 
9ef5				pop de 
9ef5				ld a, display_row_2 
9ef5				call str_at_display 
9ef5				ld hl,(cli_ptr) 
9ef5				ld a,(hl) 
9ef5			        ld hl, os_word_scratch 
9ef5				ld (hl),a 
9ef5				ld a,0 
9ef5				inc hl 
9ef5				ld (hl),a 	 
9ef5				ld de, os_word_scratch 
9ef5				ld a, display_row_2+10 
9ef5				call str_at_display 
9ef5				call update_display 
9ef5				ld a, 100 
9ef5				call aDelayInMS 
9ef5				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9ef5				call delay250ms 
9ef5				endif 
9ef5				pop hl 
9ef5			.skip:  
9ef5			endif	 
9ef5			.execpnchar:    ; compare char between token and string to parse 
9ef5			 
9ef5			if DEBUG_FORTH_PARSE_KEY 
9ef5						DMARK "Ky3" 
9ef5			endif 
9ef5			if DEBUG_FORTH_PARSE_EXEC 
9ef5				; see if disabled 
9ef5			 
9ef5			;	ld a, (os_view_disable) 
9ef5			;	cp '*' 
9ef5				ld a, (debug_vector) 
9ef5				cp $C9  ; RET 
9ef5				jr z, .skip2 
9ef5			 
9ef5			;	call clear_display 
9ef5			ld hl,(cli_token) 
9ef5			ld a,(hl) 
9ef5			ld (os_word_scratch),a 
9ef5				ld hl,(cli_ptr) 
9ef5			ld a,(hl) 
9ef5				ld (os_word_scratch+1),a 
9ef5				ld a,0 
9ef5				ld (os_word_scratch+2),a 
9ef5				ld de,os_word_scratch 
9ef5				ld a,display_row_4 
9ef5				call str_at_display 
9ef5				call update_display 
9ef5			.skip2:  
9ef5			endif 
9ef5 2a 46 ea			ld hl,(cli_token) 
9ef8 7e				ld a, (hl)	 ; char in word token 
9ef9 23				inc hl 		; move to next char 
9efa 22 46 ea			ld (cli_token), hl ; and save it 
9efd 47				ld b,a 
9efe			 
9efe 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
9f01 7e				ld a,(hl) 
9f02 23				inc hl 
9f03 22 40 ea			ld (cli_ptr), hl		; move to next char 
9f06 cd 44 90			call toUpper 		; make sure the input string matches case 
9f09			 
9f09			if DEBUG_FORTH_PARSE 
9f09			endif 
9f09			 
9f09				; input stream end of token is a space so get rid of it 
9f09			 
9f09			;	cp ' ' 
9f09			;	jr nz, .pnskipspace 
9f09			; 
9f09			;	ld a, 0		; make same term as word token term 
9f09			; 
9f09			;.pnskipspace: 
9f09			 
9f09			if DEBUG_FORTH_PARSE_KEY 
9f09						DMARK "KY7" 
9f09			endif 
9f09 b8				cp b 
9f0a c2 20 9f			jp nz, .execpnskipword	 ; no match so move to next word 
9f0d				 
9f0d			;    if same 
9f0d			;       scan for string terms 0 for token and 32 for input 
9f0d			 
9f0d				 
9f0d			if DEBUG_FORTH_PARSE_KEY 
9f0d						DMARK "KY8" 
9f0d			endif 
9f0d			 
9f0d 80				add b			 
9f0e fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9f10							; TODO need to make sure last word in zero term string is accounted for 
9f10 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9f12			 
9f12			 
9f12				; at end of both strings so both are exact match 
9f12			 
9f12			;       skip ptr for next word 
9f12			 
9f12 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
9f15 23				inc hl			 ; at next char 
9f16 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
9f19 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9f1c				 
9f1c				 
9f1c			if DEBUG_FORTH_PARSE_KEY 
9f1c						DMARK "KY3" 
9f1c			endif 
9f1c			 
9f1c			 
9f1c			 
9f1c			;       exec code block 
9f1c			if DEBUG_FORTH_JP 
9f1c				call clear_display 
9f1c				call update_display 
9f1c				call delay1s 
9f1c				ld hl, (cli_execword)     ; save for next check if no match on this word 
9f1c				ld a,h 
9f1c				ld hl, os_word_scratch 
9f1c				call hexout 
9f1c				ld hl, (cli_execword)     ; save for next check if no match on this word 
9f1c				ld a,l 
9f1c				ld hl, os_word_scratch+2 
9f1c				call hexout 
9f1c				ld hl, os_word_scratch+4 
9f1c				ld a,0 
9f1c				ld (hl),a 
9f1c				ld de,os_word_scratch 
9f1c				call str_at_display 
9f1c					ld a, display_row_2 
9f1c					call str_at_display 
9f1c				ld de, (cli_origtoken) 
9f1c				ld a, display_row_1+10 
9f1c					call str_at_display 
9f1c			 
9f1c				ld a,display_row_1 
9f1c				ld de, .foundword 
9f1c				ld a, display_row_3 
9f1c				call str_at_display 
9f1c				call update_display 
9f1c				call delay1s 
9f1c				call delay1s 
9f1c				call delay1s 
9f1c			endif 
9f1c			 
9f1c			if DEBUG_FORTH_PARSE_KEY 
9f1c						DMARK "KYj" 
9f1c			endif 
9f1c				; TODO save the word pointer in this exec 
9f1c			 
9f1c 2a 44 ea			ld hl,(cli_execword) 
9f1f e9				jp (hl) 
9f20			 
9f20			 
9f20			;    if not same 
9f20			;	scan for zero term 
9f20			;	get ptr for next word 
9f20			;	goto word comp 
9f20			 
9f20			.execpnskipword:	; get pointer to next word 
9f20 2a 42 ea			ld hl,(cli_nextword) 
9f23			 
9f23 7e				ld a,(hl) 
9f24 fe 00			cp WORD_SYS_END 
9f26			;	cp 0 
9f26 28 09			jr z, .execendofdict			 ; at end of words 
9f28			 
9f28			if DEBUG_FORTH_PARSE_KEY 
9f28						DMARK "KY4" 
9f28			endif 
9f28			if DEBUG_FORTH_PARSE_EXEC 
9f28			 
9f28				; see if disabled 
9f28			 
9f28			;	ld a, (os_view_disable) 
9f28			;	cp '*' 
9f28				ld a,(debug_vector) 
9f28				cp $c9   ; RET 
9f28				jr z, .noskip 
9f28			 
9f28			 
9f28				ld de, .nowordfound 
9f28				ld a, display_row_3 
9f28				call str_at_display 
9f28				call update_display 
9f28				ld a, 100 
9f28				call aDelayInMS 
9f28				 
9f28				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f28					call delay250ms 
9f28				endif 
9f28			.noskip:  
9f28			 
9f28			endif	 
9f28			 
9f28 2a 3e ea			ld hl,(cli_origptr) 
9f2b 22 40 ea			ld (cli_ptr),hl 
9f2e			 
9f2e			if DEBUG_FORTH_PARSE_KEY 
9f2e						DMARK "KY5" 
9f2e			endif 
9f2e c3 d4 9e			jp .execpnword			; else go to next word 
9f31			 
9f31			.execendofdict:  
9f31			 
9f31			if DEBUG_FORTH_PARSE_KEY 
9f31						DMARK "KYe" 
9f31			endif 
9f31			if DEBUG_FORTH_PARSE_EXEC 
9f31				; see if disabled 
9f31			 
9f31			;	ld a, (os_view_disable) 
9f31			;	cp '*' 
9f31				ld a,(debug_vector) 
9f31				cp $c9   ; ret 
9f31				jr z, .ispskip 
9f31			 
9f31				call clear_display 
9f31				call update_display 
9f31				call delay1s 
9f31				ld de, (cli_origptr) 
9f31				ld a, display_row_1 
9f31				call str_at_display 
9f31				 
9f31				ld de, .enddict 
9f31				ld a, display_row_3 
9f31				call str_at_display 
9f31				call update_display 
9f31				ld a, 100 
9f31				call aDelayInMS 
9f31				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f31				call delay1s 
9f31				call delay1s 
9f31				call delay1s 
9f31				endif 
9f31			.ispskip:  
9f31				 
9f31			endif	 
9f31			 
9f31			 
9f31			 
9f31				; if the word is not a keyword then must be a literal so push it to stack 
9f31			 
9f31			; push token to stack to end of word 
9f31			 
9f31				STACKFRAME ON $1efe $2f9f 
9f31				if DEBUG_STACK_IMB 
9f31					if ON 
9f31						exx 
9f31						ld de, $1efe 
9f31						ld a, d 
9f31						ld hl, curframe 
9f31						call hexout 
9f31						ld a, e 
9f31						ld hl, curframe+2 
9f31						call hexout 
9f31						ld hl, $1efe 
9f31						push hl 
9f31						ld hl, $2f9f 
9f31						push hl 
9f31						exx 
9f31					endif 
9f31				endif 
9f31			endm 
# End of macro STACKFRAME
9f31			 
9f31 2a c2 e5		ld hl,(os_tok_ptr) 
9f34 cd d7 9b		call forth_apush 
9f37			 
9f37				STACKFRAMECHK ON $1efe $2f9f 
9f37				if DEBUG_STACK_IMB 
9f37					if ON 
9f37						exx 
9f37						ld hl, $2f9f 
9f37						pop de   ; $2f9f 
9f37						call cmp16 
9f37						jr nz, .spnosame 
9f37						ld hl, $1efe 
9f37						pop de   ; $1efe 
9f37						call cmp16 
9f37						jr z, .spfrsame 
9f37						.spnosame: call showsperror 
9f37						.spfrsame: nop 
9f37						exx 
9f37					endif 
9f37				endif 
9f37			endm 
# End of macro STACKFRAMECHK
9f37			 
9f37			execnext: 
9f37			 
9f37			if DEBUG_FORTH_PARSE_KEY 
9f37						DMARK "KY>" 
9f37			endif 
9f37			; move past token to next word 
9f37			 
9f37 2a c2 e5		ld hl, (os_tok_ptr) 
9f3a 3e 00		ld a, 0 
9f3c 01 ff 00		ld bc, 255     ; input buffer size 
9f3f ed b1		cpir 
9f41			 
9f41			if DEBUG_FORTH_PARSE_KEY 
9f41						DMARK "KY!" 
9f41				CALLMONITOR 
9f41			endif	 
9f41			; TODO this might place hl on the null, so will need to forward on??? 
9f41			;inc hl   ; see if this gets onto the next item 
9f41			 
9f41			 
9f41			; TODO pass a pointer to the buffer to push 
9f41			; TODO call function to push 
9f41			 
9f41			; look for end of input 
9f41			 
9f41			;inc hl 
9f41			;ld a,(hl) 
9f41			;cp FORTH_END_BUFFER 
9f41			;ret z 
9f41			 
9f41			 
9f41 c3 ba 9e		jp exec1 
9f44			 
9f44			 
9f44			 
9f44			 
9f44			 
9f44			 
9f44			 
9f44			 
9f44			 
9f44			findnexttok: 
9f44			 
9f44				; hl is pointer to move 
9f44				; de is the token to locate 
9f44			 
9f44					if DEBUG_FORTH 
9f44						DMARK "NTK" 
9f44						CALLMONITOR 
9f44					endif 
9f44 d5				push de 
9f45			 
9f45			.fnt1:	 
9f45				; find first char of token to locate 
9f45			 
9f45 1a				ld a, (de) 
9f46 4f				ld c,a 
9f47 7e				ld a,(hl) 
9f48 cd 44 90			call toUpper 
9f4b					if DEBUG_FORTH 
9f4b						DMARK "NT1" 
9f4b						CALLMONITOR 
9f4b					endif 
9f4b b9				cp c 
9f4c			 
9f4c 28 03			jr z, .fnt2cmpmorefirst	 
9f4e			 
9f4e				; first char not found move to next char 
9f4e			 
9f4e 23				inc hl 
9f4f 18 f4			jr .fnt1 
9f51			 
9f51			.fnt2cmpmorefirst:	 
9f51				; first char of token found.  
9f51			 
9f51 e5				push hl     ; save start of token just in case it is the right one 
9f52 d9				exx 
9f53 e1				pop hl        ; save it to hl' 
9f54 d9				exx 
9f55			 
9f55			 
9f55			.fnt2cmpmore:	 
9f55				; compare the rest 
9f55				 
9f55 23				inc hl 
9f56 13				inc de 
9f57				 
9f57 1a				ld a, (de) 
9f58 4f				ld c,a 
9f59 7e				ld a,(hl) 
9f5a cd 44 90			call toUpper 
9f5d			 
9f5d					if DEBUG_FORTH 
9f5d						DMARK "NT2" 
9f5d						CALLMONITOR 
9f5d					endif 
9f5d				; c has the token to find char 
9f5d				; a has the mem to scan char 
9f5d			 
9f5d b9				cp c 
9f5e 28 04			jr z,.fntmatch1 
9f60			 
9f60				; they are not the same 
9f60			 
9f60					if DEBUG_FORTH 
9f60						DMARK "NT3" 
9f60						CALLMONITOR 
9f60					endif 
9f60 d1				pop de	; reset de token to look for 
9f61 d5				push de 
9f62 18 e1			jr .fnt1 
9f64				 
9f64			.fntmatch1: 
9f64			 
9f64				; is the same char a null which means we might have a full hit? 
9f64					if DEBUG_FORTH 
9f64						DMARK "NT4" 
9f64						CALLMONITOR 
9f64					endif 
9f64			 
9f64 fe 00			cp 0 
9f66 28 0b			jr z, .fntmatchyes 
9f68			 
9f68				; are we at the end of the token to find? 
9f68			 
9f68					if DEBUG_FORTH 
9f68						DMARK "NT5" 
9f68						CALLMONITOR 
9f68					endif 
9f68 3e 00			ld a, 0 
9f6a b9				cp c 
9f6b			 
9f6b c2 55 9f			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9f6e			 
9f6e					if DEBUG_FORTH 
9f6e						DMARK "NT6" 
9f6e						CALLMONITOR 
9f6e					endif 
9f6e				; token to find is exhusted but no match to stream 
9f6e			 
9f6e				; restore tok pointer and continue on 
9f6e d1				pop de 
9f6f d5				push de 
9f70 c3 45 9f			jp .fnt1 
9f73			 
9f73			 
9f73			.fntmatchyes: 
9f73			 
9f73				; hl now contains the end of the found token 
9f73			 
9f73				; get rid of saved token pointer to find 
9f73			 
9f73 d1				pop de 
9f74			 
9f74					if DEBUG_FORTH 
9f74						DMARK "NT9" 
9f74						CALLMONITOR 
9f74					endif 
9f74			 
9f74				; hl will be on the null term so forward on 
9f74			 
9f74				; get back the saved start of the token 
9f74			 
9f74 d9				exx 
9f75 e5				push hl     ; save start of token just in case it is the right one 
9f76 d9				exx 
9f77 e1				pop hl        ; save it to hl 
9f78			 
9f78 c9				ret 
9f79			 
9f79			 
9f79			; LIST needs to find a specific token   
9f79			; FORGET needs to find a spefici token 
9f79			 
9f79			; SAVE needs to find all tokens by flag 
9f79			; WORDS just needs to scan through all  by flag 
9f79			; UWORDS needs to scan through all by flag 
9f79			 
9f79			 
9f79			; given hl as pointer to start of dict look up string 
9f79			; return hl as pointer to start of word block 
9f79			; or 0 if not found 
9f79			 
9f79			forth_find_tok: 
9f79 c9				ret 
9f7a			 
9f7a			; given hl as pointer to dict structure 
9f7a			; move to the next dict block structure 
9f7a			 
9f7a			forth_tok_next: 
9f7a				; hl now points to the address of the next word pointer  
9f7a				; TODO skip compiled symbol for now 
9f7a			;	push de 
9f7a 23				inc hl 
9f7b 5e				ld e, (hl) 
9f7c 23				inc hl 
9f7d 56				ld d, (hl) 
9f7e 23				inc hl 
9f7f			 
9f7f eb				ex de,hl 
9f80			if DEBUG_FORTH_PARSE_NEXTWORD 
9f80				push bc 
9f80				ld bc, (cli_nextword) 
9f80						DMARK "NXW" 
9f80				CALLMONITOR 
9f80				pop bc 
9f80			endif 
9f80			;	pop de	 
9f80 c9				ret 
9f81			 
9f81			 
9f81			 
9f81			; eof 
# End of file forth_parserv5.asm
9f81				include "forth_wordsv4.asm" 
9f81			 
9f81			; the core word dictionary v4 
9f81			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9f81			 
9f81			; this is a linked list for each of the system words used 
9f81			; user defined words will follow the same format but will be in ram 
9f81			 
9f81			 
9f81			; 
9f81			; 
9f81			; define linked list: 
9f81			; 
9f81			; 1. compiled byte op code 
9f81			; 2. len of text word 
9f81			; 3. text word 
9f81			; 4. ptr to next dictionary word 
9f81			; 5. asm, calls etc for the word 
9f81			; 
9f81			;  if 1 == 0 then last word in dict  
9f81			;   
9f81			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9f81			;  
9f81			;  
9f81			; create basic standard set of words 
9f81			; 
9f81			;  
9f81			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9f81			; 2DUP 2DROP 2SWAP  
9f81			; @ C@ - get byte  
9f81			; ! C! - store byte 
9f81			; 0< true if less than zero 
9f81			; 0= true if zero 
9f81			; < >  
9f81			; = true if same 
9f81			; variables 
9f81			 
9f81			 
9f81			; Hardware specific words I may need 
9f81			; 
9f81			; IN OUT  
9f81			; calls to key util functions 
9f81			; calls to hardward abstraction stuff 
9f81			; easy control of frame buffers and lcd i/o 
9f81			; keyboard  
9f81			 
9f81			 
9f81			;DICT: macro 
9f81			; op_code, len, word, next 
9f81			;    word: 
9f81			;    db op_code 
9f81			;    ds word zero term 
9f81			;    dw next 
9f81			;    endm 
9f81			 
9f81			 
9f81			 
9f81			 
9f81			; op code 1 is a flag for user define words which are to be handled differently 
9f81			 
9f81			 
9f81			; 
9f81			; 
9f81			;    TODO on entry to a word this should be the expected environment 
9f81			;    hl - tos value if number then held, if string this is the ptr 
9f81			;    de -  
9f81			 
9f81			 
9f81			; opcode ranges 
9f81			; 0 - end of word dict 
9f81			; 255 - user define words 
9f81			 
9f81			sysdict: 
9f81			include "forth_opcodes.asm" 
9f81			; op codes for forth keywords 
9f81			; free to use code 0  
9f81				OPCODE_HEAP: equ  1 
9f81				OPCODE_EXEC: equ 2 
9f81				OPCODE_DUP: equ 3 
9f81				OPCODE_SWAP: equ 4 
9f81				OPCODE_COLN: equ 5 
9f81				OPCODE_SCOLN: equ 6 
9f81				OPCODE_DROP: equ 7 
9f81				OPCODE_DUP2: equ 8 
9f81				OPCODE_DROP2: equ 9 
9f81				OPCODE_SWAP2: equ 10 
9f81				OPCODE_AT: equ 11 
9f81				OPCODE_CAT: equ 12 
9f81				OPCODE_BANG: equ 13 
9f81				OPCODE_CBANG: equ 14 
9f81				OPCODE_SCALL: equ 15 
9f81				OPCODE_DEPTH: equ 16 
9f81				OPCODE_OVER: equ 17 
9f81				OPCODE_PAUSE: equ 18 
9f81				OPCODE_PAUSES: equ 19 
9f81				OPCODE_ROT: equ 20 
9f81			;free to reuse	OPCODE_WORDS: equ 21 
9f81			        OPCODE_NOT: equ 21 
9f81				OPCODE_UWORDS: equ 22 
9f81				OPCODE_BP: equ 23 
9f81				OPCODE_MONITOR: equ 24  
9f81				OPCODE_MALLOC: equ 25 
9f81				OPCODE_FREE: equ 26 
9f81				OPCODE_LIST: equ 27 
9f81				OPCODE_FORGET: equ 28 
9f81				OPCODE_NOP: equ 29 
9f81				OPCODE_COMO: equ 30 
9f81				OPCODE_COMC: equ 31 
9f81			;free to reuse	OPCODE_ENDCORE: equ 32 
9f81				OPCODE_AFTERSOUND: equ 33 
9f81				OPCODE_GP2: equ 34 
9f81				OPCODE_GP3: equ 35 
9f81				OPCODE_GP4: equ 36 
9f81				OPCODE_SIN: equ 37 
9f81				OPCODE_SOUT: equ 38 
9f81				OPCODE_SPIO: equ 39 
9f81				OPCODE_SPICEH: equ 40 
9f81				OPCODE_SPIOb: equ 41 
9f81				OPCODE_SPII: equ 42 
9f81				OPCODE_SESEL: equ 43 
9f81				OPCODE_CARTDEV: equ 44 
9f81			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9f81				OPCODE_FB: equ 46 
9f81				OPCODE_EMIT: equ 47 
9f81				OPCODE_DOTH: equ 48 
9f81				OPCODE_DOTF: equ 49 
9f81				OPCODE_DOT: equ 50 
9f81				OPCODE_CLS: equ 51 
9f81				OPCODE_DRAW: equ 52 
9f81				OPCODE_DUMP: equ 53 
9f81				OPCODE_CDUMP: equ 54 
9f81				OPCODE_DAT: equ 55 
9f81				OPCODE_HOME: equ 56 
9f81				OPCODE_SPACE: equ 57 
9f81				OPCODE_SPACES: equ 58 
9f81				OPCODE_SCROLL: equ 59 
9f81				OPCODE_ATQ: equ 60 
9f81				OPCODE_AUTODSP: equ 61 
9f81				OPCODE_MENU: equ 62 
9f81			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9f81				OPCODE_THEN: equ 64 
9f81				OPCODE_ELSE: equ 65 
9f81				OPCODE_DO: equ 66 
9f81				OPCODE_LOOP: equ 67 
9f81				OPCODE_I: equ 68 
9f81				OPCODE_DLOOP: equ 69  
9f81				OPCODE_REPEAT: equ 70  
9f81				OPCODE_UNTIL: equ 71 
9f81				OPCODE_ENDFLOW: equ 72 
9f81				OPCODE_WAITK: equ 73 
9f81				OPCODE_ACCEPT: equ 74 
9f81				OPCODE_EDIT: equ 75 
9f81			;free to reuse	OPCODE_ENDKEY: equ 76 
9f81				OPCODE_LZERO: equ 77 
9f81				OPCODE_TZERO: equ 78 
9f81				OPCODE_LESS: equ 79 
9f81				OPCODE_GT: equ 80 
9f81				OPCODE_EQUAL: equ 81  
9f81			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9f81				OPCODE_NEG: equ 83 
9f81				OPCODE_DIV: equ 84 
9f81				OPCODE_MUL: equ 85 
9f81				OPCODE_MIN: equ 86 
9f81				OPCODE_MAX: equ 87 
9f81				OPCODE_RND16: equ 88 
9f81				OPCODE_RND8: equ 89 
9f81				OPCODE_RND: equ 90 
9f81			;free to reuse	OPCODE_ENDMATHS: equ 91  
9f81				OPCODE_BYNAME: equ 92 
9f81				OPCODE_DIR: equ 93 
9f81				OPCODE_SAVE: equ 94 
9f81				OPCODE_LOAD: equ 95 
9f81				OPCODE_BSAVE: equ 96 
9f81				OPCODE_BLOAD: equ 97 
9f81				OPCODE_SEO: equ 98  
9f81				OPCODE_SEI: equ 99 
9f81				OPCODE_SFREE: equ 100 
9f81				OPCODE_SIZE: equ 101 
9f81				OPCODE_CREATE: equ 102 
9f81				OPCODE_APPEND: equ 103 
9f81				OPCODE_SDEL: equ 104 
9f81				OPCODE_OPEN: equ 105 
9f81				OPCODE_READ: equ 106 
9f81				OPCODE_EOF: equ 106 
9f81				OPCODE_FORMAT: equ 107 
9f81				OPCODE_LABEL: equ 108 
9f81				OPCODE_LABELS: equ 109 
9f81			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9f81				OPCODE_UPPER: equ 111 
9f81				OPCODE_LOWER: equ 112 
9f81				OPCODE_SUBSTR: equ 113 
9f81				OPCODE_LEFT: equ 114 
9f81				OPCODE_RIGHT: equ 115 
9f81				OPCODE_STR2NUM: equ 116 
9f81				OPCODE_NUM2STR: equ 117 
9f81				OPCODE_CONCAT: equ 118 
9f81				OPCODE_FIND: equ 119 
9f81				OPCODE_LEN: equ 120 
9f81				OPCODE_CHAR: equ 121 
9f81			; free to reuse	OPCODE_STRLEN: equ 122 
9f81			; free to reuse	OPCODE_ENDSTR: equ 123 
9f81				OPCODE_V0S: equ 124 
9f81				OPCODE_V0Q: equ 125 
9f81				OPCODE_V1S: equ 126 
9f81				OPCODE_V1Q: equ 127 
9f81				OPCODE_V2S: equ 128 
9f81				OPCODE_V2Q: equ 129 
9f81				OPCODE_V3S: equ 130 
9f81				OPCODE_V3Q: equ 131 
9f81			;free to reuse	OPCODE_END: equ 132 
9f81				OPCODE_ZDUP: equ 133 
9f81			 
9f81			; eof 
# End of file forth_opcodes.asm
9f81			 
9f81			include "forth_words_core.asm" 
9f81			 
9f81			; | ## Core Words 
9f81			 
9f81			;if MALLOC_4 
9f81			 
9f81			.HEAP: 
9f81			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9f81 15				db WORD_SYS_CORE+OPCODE_HEAP             
9f82 c0 9f			dw .EXEC            
9f84 05				db 4 + 1 
9f85 .. 00			db "HEAP",0              
9f8a				endm 
# End of macro CWHEAD
9f8a			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9f8a			; | | u1 - Current number of bytes in the heap 
9f8a			; | | u2 - Remaining bytes left on the heap 
9f8a			; | |  
9f8a			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9f8a			 
9f8a			 
9f8a				if DEBUG_FORTH_WORDS_KEY 
9f8a					DMARK "HEP" 
9f8a f5				push af  
9f8b 3a 9f 9f			ld a, (.dmark)  
9f8e 32 6b ee			ld (debug_mark),a  
9f91 3a a0 9f			ld a, (.dmark+1)  
9f94 32 6c ee			ld (debug_mark+1),a  
9f97 3a a1 9f			ld a, (.dmark+2)  
9f9a 32 6d ee			ld (debug_mark+2),a  
9f9d 18 03			jr .pastdmark  
9f9f ..			.dmark: db "HEP"  
9fa2 f1			.pastdmark: pop af  
9fa3			endm  
# End of macro DMARK
9fa3					CALLMONITOR 
9fa3 cd 6f ee			call debug_vector  
9fa6				endm  
# End of macro CALLMONITOR
9fa6				endif 
9fa6 2a 30 dd			ld hl, (free_list )      
9fa9 11 35 dd			ld de, heap_start 
9fac			 
9fac ed 52			sbc hl, de  
9fae			 
9fae cd 6e 9a			call forth_push_numhl 
9fb1			 
9fb1			 
9fb1 ed 5b 30 dd		ld de, (free_list )      
9fb5 21 9c e2			ld hl, heap_end 
9fb8			 
9fb8 ed 52			sbc hl, de 
9fba			 
9fba cd 6e 9a			call forth_push_numhl 
9fbd				 
9fbd			 
9fbd				 
9fbd			 
9fbd			 
9fbd			 
9fbd				NEXTW 
9fbd c3 29 9e			jp macro_next 
9fc0				endm 
# End of macro NEXTW
9fc0			;endif 
9fc0			 
9fc0			.EXEC: 
9fc0			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9fc0			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
9fc0			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9fc0			;; > > 
9fc0			;; > >   
9fc0			;	STACKFRAME OFF $5efe $5f9f 
9fc0			; 
9fc0			;		if DEBUG_FORTH_WORDS_KEY 
9fc0			;			DMARK "EXE" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			; 
9fc0			;	FORTH_DSP_VALUEHL 
9fc0			; 
9fc0			;	FORTH_DSP_POP 
9fc0			; 
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EX1" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			;;	ld e,(hl) 
9fc0			;;	inc hl 
9fc0			;;	ld d,(hl) 
9fc0			;;	ex de,hl 
9fc0			; 
9fc0			;;		if DEBUG_FORTH_WORDS 
9fc0			;;			DMARK "EX2" 
9fc0			;;			CALLMONITOR 
9fc0			;;		endif 
9fc0			;	push hl 
9fc0			; 
9fc0			;	;ld a, 0 
9fc0			;	;ld a, FORTH_END_BUFFER 
9fc0			;	call strlenz 
9fc0			;	inc hl   ; include zero term to copy 
9fc0			;	inc hl   ; include term 
9fc0			;	inc hl   ; include term 
9fc0			;	ld b,0 
9fc0			;	ld c,l 
9fc0			;	pop hl 
9fc0			;	ld de, execscratch 
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EX3" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			;	ldir 
9fc0			; 
9fc0			; 
9fc0			;	ld hl, execscratch 
9fc0			; 
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EXe" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			; 
9fc0			;	call forthparse 
9fc0			;	call forthexec 
9fc0			;;	call forthexec_cleanup 
9fc0			;;	call forthparse 
9fc0			;;	call forthexec 
9fc0			; 
9fc0			;	STACKFRAMECHK OFF $5efe $5f9f 
9fc0			; 
9fc0			;	; an immediate word so no need to process any more words 
9fc0			;	ret 
9fc0			;	NEXTW 
9fc0			 
9fc0			; dead code - old version  
9fc0			;	FORTH_RSP_NEXT 
9fc0			 
9fc0			;  
9fc0			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9fc0			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9fc0			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9fc0			;	push hl 
9fc0			;	push de 
9fc0			;	push bc 
9fc0			; 
9fc0			; 
9fc0			;		if DEBUG_FORTH_WORDS_KEY 
9fc0			;			DMARK "EXR" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			; 
9fc0			; 
9fc0			; 
9fc0			;	;v5 FORTH_DSP_VALUE 
9fc0			;	FORTH_DSP_VALUEHL 
9fc0			; 
9fc0			;	; TODO do string type checks 
9fc0			; 
9fc0			;;v5	inc hl   ; skip type 
9fc0			; 
9fc0			;	push hl  ; source code  
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EX1" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			;	ld a, 0 
9fc0			;	call strlent 
9fc0			; 
9fc0			;	inc hl 
9fc0			;	inc hl 
9fc0			;	inc hl 
9fc0			;	inc hl 
9fc0			; 
9fc0			;	push hl    ; size 
9fc0			; 
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EX2" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			;	call malloc 
9fc0			; 
9fc0			;	ex de, hl    ; de now contains malloc area 
9fc0			;	pop bc   	; get byte count 
9fc0			;	pop hl      ; get string to copy 
9fc0			; 
9fc0			;	push de     ; save malloc for free later 
9fc0			; 
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EX3" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			;	ldir       ; duplicate string 
9fc0			; 
9fc0			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9fc0			;	 
9fc0			;	; TODO fix the parse would be better than this...  
9fc0			;	ex de, hl 
9fc0			;	dec hl 
9fc0			;	ld a, 0 
9fc0			;	ld (hl), a 
9fc0			;	dec hl 
9fc0			;	ld a, ' ' 
9fc0			;	ld (hl), a 
9fc0			;	dec hl 
9fc0			;	ld (hl), a 
9fc0			; 
9fc0			;	dec hl 
9fc0			;	ld (hl), a 
9fc0			; 
9fc0			; 
9fc0			;	FORTH_DSP_POP  
9fc0			; 
9fc0			;	pop hl     
9fc0			;	push hl    ; save malloc area 
9fc0			; 
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EX4" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			; 
9fc0			;	call forthparse 
9fc0			;	call forthexec 
9fc0			;	 
9fc0			;	pop hl 
9fc0			;	if DEBUG_FORTH_WORDS 
9fc0			;		DMARK "EX5" 
9fc0			;		CALLMONITOR 
9fc0			;	endif 
9fc0			; 
9fc0			;	if FORTH_ENABLE_FREE 
9fc0			;	call free 
9fc0			;	endif 
9fc0			; 
9fc0			;	if DEBUG_FORTH_WORDS 
9fc0			;		DMARK "EX6" 
9fc0			;		CALLMONITOR 
9fc0			;	endif 
9fc0			; 
9fc0			;	pop bc 
9fc0			;	pop de 
9fc0			;	pop hl 
9fc0			;;	FORTH_RSP_POP	  
9fc0			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9fc0			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9fc0			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9fc0			; 
9fc0			;	if DEBUG_FORTH_WORDS 
9fc0			;		DMARK "EX7" 
9fc0			;		CALLMONITOR 
9fc0			;	endif 
9fc0			;	NEXTW 
9fc0			 
9fc0			;.STKEXEC: 
9fc0			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9fc0			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
9fc0			; 
9fc0			; 
9fc0			;		if DEBUG_FORTH_WORDS_KEY 
9fc0			;			DMARK "STX" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			; 
9fc0			;	FORTH_DSP_VALUEHL 
9fc0			; 
9fc0			;	ld (store_tmp1), hl    ; count 
9fc0			; 
9fc0			;	FORTH_DSP_POP 
9fc0			;.stkexec1: 
9fc0			;	ld hl, (store_tmp1)   ; count 
9fc0			;	ld a, 0 
9fc0			;	cp l 
9fc0			;	ret z 
9fc0			; 
9fc0			;	dec hl 
9fc0			;	ld (store_tmp1), hl    ; count 
9fc0			;	 
9fc0			;	FORTH_DSP_VALUEHL 
9fc0			;	push hl 
9fc0			;	 
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EXp" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			;	FORTH_DSP_POP 
9fc0			; 
9fc0			;	call strlenz 
9fc0			;	inc hl   ; include zero term to copy 
9fc0			;	inc hl   ; include zero term to copy 
9fc0			;	inc hl   ; include zero term to copy 
9fc0			;	ld b,0 
9fc0			;	ld c,l 
9fc0			;	pop hl 
9fc0			;	ld de, execscratch 
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EX3" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			;	ldir 
9fc0			; 
9fc0			; 
9fc0			;	ld hl, execscratch 
9fc0			; 
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EXP" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			; 
9fc0			;	call forthparse 
9fc0			;	ld hl, execscratch 
9fc0			;		if DEBUG_FORTH_WORDS 
9fc0			;			DMARK "EXx" 
9fc0			;			CALLMONITOR 
9fc0			;		endif 
9fc0			;	call forthexec 
9fc0			; 
9fc0			;	jp .stkexec1 
9fc0			; 
9fc0			;	ret 
9fc0			 
9fc0			 
9fc0			.DUP: 
9fc0			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9fc0 17				db WORD_SYS_CORE+OPCODE_DUP             
9fc1 36 a0			dw .ZDUP            
9fc3 04				db 3 + 1 
9fc4 .. 00			db "DUP",0              
9fc8				endm 
# End of macro CWHEAD
9fc8			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9fc8			 
9fc8				if DEBUG_FORTH_WORDS_KEY 
9fc8					DMARK "DUP" 
9fc8 f5				push af  
9fc9 3a dd 9f			ld a, (.dmark)  
9fcc 32 6b ee			ld (debug_mark),a  
9fcf 3a de 9f			ld a, (.dmark+1)  
9fd2 32 6c ee			ld (debug_mark+1),a  
9fd5 3a df 9f			ld a, (.dmark+2)  
9fd8 32 6d ee			ld (debug_mark+2),a  
9fdb 18 03			jr .pastdmark  
9fdd ..			.dmark: db "DUP"  
9fe0 f1			.pastdmark: pop af  
9fe1			endm  
# End of macro DMARK
9fe1					CALLMONITOR 
9fe1 cd 6f ee			call debug_vector  
9fe4				endm  
# End of macro CALLMONITOR
9fe4				endif 
9fe4			 
9fe4				FORTH_DSP 
9fe4 cd 39 9c			call macro_forth_dsp 
9fe7				endm 
# End of macro FORTH_DSP
9fe7			 
9fe7 7e				ld a, (HL) 
9fe8 fe 01			cp DS_TYPE_STR 
9fea 20 25			jr nz, .dupinum 
9fec			 
9fec				; push another string 
9fec			 
9fec				FORTH_DSP_VALUEHL     		 
9fec cd 73 9c			call macro_dsp_valuehl 
9fef				endm 
# End of macro FORTH_DSP_VALUEHL
9fef			 
9fef			if DEBUG_FORTH_WORDS 
9fef				DMARK "DUs" 
9fef f5				push af  
9ff0 3a 04 a0			ld a, (.dmark)  
9ff3 32 6b ee			ld (debug_mark),a  
9ff6 3a 05 a0			ld a, (.dmark+1)  
9ff9 32 6c ee			ld (debug_mark+1),a  
9ffc 3a 06 a0			ld a, (.dmark+2)  
9fff 32 6d ee			ld (debug_mark+2),a  
a002 18 03			jr .pastdmark  
a004 ..			.dmark: db "DUs"  
a007 f1			.pastdmark: pop af  
a008			endm  
# End of macro DMARK
a008				CALLMONITOR 
a008 cd 6f ee			call debug_vector  
a00b				endm  
# End of macro CALLMONITOR
a00b			endif 
a00b cd dc 9a			call forth_push_str 
a00e			 
a00e				NEXTW 
a00e c3 29 9e			jp macro_next 
a011				endm 
# End of macro NEXTW
a011			 
a011			 
a011			.dupinum: 
a011				 
a011			 
a011			 
a011				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a011 cd 73 9c			call macro_dsp_valuehl 
a014				endm 
# End of macro FORTH_DSP_VALUEHL
a014			 
a014			; TODO add floating point number detection 
a014			 
a014			if DEBUG_FORTH_WORDS 
a014				DMARK "DUi" 
a014 f5				push af  
a015 3a 29 a0			ld a, (.dmark)  
a018 32 6b ee			ld (debug_mark),a  
a01b 3a 2a a0			ld a, (.dmark+1)  
a01e 32 6c ee			ld (debug_mark+1),a  
a021 3a 2b a0			ld a, (.dmark+2)  
a024 32 6d ee			ld (debug_mark+2),a  
a027 18 03			jr .pastdmark  
a029 ..			.dmark: db "DUi"  
a02c f1			.pastdmark: pop af  
a02d			endm  
# End of macro DMARK
a02d				CALLMONITOR 
a02d cd 6f ee			call debug_vector  
a030				endm  
# End of macro CALLMONITOR
a030			endif 
a030			 
a030 cd 6e 9a			call forth_push_numhl 
a033				NEXTW 
a033 c3 29 9e			jp macro_next 
a036				endm 
# End of macro NEXTW
a036			.ZDUP: 
a036			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a036 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a037 6e a0			dw .SWAP            
a039 05				db 4 + 1 
a03a .. 00			db "?DUP",0              
a03f				endm 
# End of macro CWHEAD
a03f			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a03f			 
a03f				if DEBUG_FORTH_WORDS_KEY 
a03f					DMARK "qDU" 
a03f f5				push af  
a040 3a 54 a0			ld a, (.dmark)  
a043 32 6b ee			ld (debug_mark),a  
a046 3a 55 a0			ld a, (.dmark+1)  
a049 32 6c ee			ld (debug_mark+1),a  
a04c 3a 56 a0			ld a, (.dmark+2)  
a04f 32 6d ee			ld (debug_mark+2),a  
a052 18 03			jr .pastdmark  
a054 ..			.dmark: db "qDU"  
a057 f1			.pastdmark: pop af  
a058			endm  
# End of macro DMARK
a058					CALLMONITOR 
a058 cd 6f ee			call debug_vector  
a05b				endm  
# End of macro CALLMONITOR
a05b				endif 
a05b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a05b cd 73 9c			call macro_dsp_valuehl 
a05e				endm 
# End of macro FORTH_DSP_VALUEHL
a05e			 
a05e e5				push hl 
a05f			 
a05f				; is it a zero? 
a05f			 
a05f 3e 00			ld a, 0 
a061 84				add h 
a062 85				add l 
a063			 
a063 e1				pop hl 
a064			 
a064 fe 00			cp 0 
a066 28 03			jr z, .dup2orig 
a068			 
a068			 
a068 cd 6e 9a			call forth_push_numhl 
a06b			 
a06b			 
a06b			; TODO add floating point number detection 
a06b			 
a06b			.dup2orig: 
a06b			 
a06b				NEXTW 
a06b c3 29 9e			jp macro_next 
a06e				endm 
# End of macro NEXTW
a06e			.SWAP: 
a06e			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a06e 18				db WORD_SYS_CORE+OPCODE_SWAP             
a06f ad a0			dw .COLN            
a071 05				db 4 + 1 
a072 .. 00			db "SWAP",0              
a077				endm 
# End of macro CWHEAD
a077			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a077				if DEBUG_FORTH_WORDS_KEY 
a077					DMARK "SWP" 
a077 f5				push af  
a078 3a 8c a0			ld a, (.dmark)  
a07b 32 6b ee			ld (debug_mark),a  
a07e 3a 8d a0			ld a, (.dmark+1)  
a081 32 6c ee			ld (debug_mark+1),a  
a084 3a 8e a0			ld a, (.dmark+2)  
a087 32 6d ee			ld (debug_mark+2),a  
a08a 18 03			jr .pastdmark  
a08c ..			.dmark: db "SWP"  
a08f f1			.pastdmark: pop af  
a090			endm  
# End of macro DMARK
a090					CALLMONITOR 
a090 cd 6f ee			call debug_vector  
a093				endm  
# End of macro CALLMONITOR
a093				endif 
a093			 
a093			; TODO Use os stack swap memory 
a093				FORTH_DSP_VALUEHL 
a093 cd 73 9c			call macro_dsp_valuehl 
a096				endm 
# End of macro FORTH_DSP_VALUEHL
a096 e5				push hl     ; w2 
a097			 
a097				FORTH_DSP_POP 
a097 cd 2b 9d			call macro_forth_dsp_pop 
a09a				endm 
# End of macro FORTH_DSP_POP
a09a			 
a09a				FORTH_DSP_VALUEHL 
a09a cd 73 9c			call macro_dsp_valuehl 
a09d				endm 
# End of macro FORTH_DSP_VALUEHL
a09d			 
a09d				FORTH_DSP_POP 
a09d cd 2b 9d			call macro_forth_dsp_pop 
a0a0				endm 
# End of macro FORTH_DSP_POP
a0a0			 
a0a0 d1				pop de     ; w2	, hl = w1 
a0a1			 
a0a1 eb				ex de, hl 
a0a2 d5				push de 
a0a3			 
a0a3 cd 6e 9a			call forth_push_numhl 
a0a6			 
a0a6 e1				pop hl 
a0a7			 
a0a7 cd 6e 9a			call forth_push_numhl 
a0aa				 
a0aa			 
a0aa				NEXTW 
a0aa c3 29 9e			jp macro_next 
a0ad				endm 
# End of macro NEXTW
a0ad			.COLN: 
a0ad			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a0ad 19				db WORD_SYS_CORE+OPCODE_COLN             
a0ae 39 a2			dw .SCOLN            
a0b0 02				db 1 + 1 
a0b1 .. 00			db ":",0              
a0b3				endm 
# End of macro CWHEAD
a0b3			; | : ( -- )         Create new word | DONE 
a0b3			 
a0b3				if DEBUG_FORTH_WORDS_KEY 
a0b3					DMARK "CLN" 
a0b3 f5				push af  
a0b4 3a c8 a0			ld a, (.dmark)  
a0b7 32 6b ee			ld (debug_mark),a  
a0ba 3a c9 a0			ld a, (.dmark+1)  
a0bd 32 6c ee			ld (debug_mark+1),a  
a0c0 3a ca a0			ld a, (.dmark+2)  
a0c3 32 6d ee			ld (debug_mark+2),a  
a0c6 18 03			jr .pastdmark  
a0c8 ..			.dmark: db "CLN"  
a0cb f1			.pastdmark: pop af  
a0cc			endm  
# End of macro DMARK
a0cc					CALLMONITOR 
a0cc cd 6f ee			call debug_vector  
a0cf				endm  
# End of macro CALLMONITOR
a0cf				endif 
a0cf			STACKFRAME OFF $8efe $989f 
a0cf				if DEBUG_STACK_IMB 
a0cf					if OFF 
a0cf						exx 
a0cf						ld de, $8efe 
a0cf						ld a, d 
a0cf						ld hl, curframe 
a0cf						call hexout 
a0cf						ld a, e 
a0cf						ld hl, curframe+2 
a0cf						call hexout 
a0cf						ld hl, $8efe 
a0cf						push hl 
a0cf						ld hl, $989f 
a0cf						push hl 
a0cf						exx 
a0cf					endif 
a0cf				endif 
a0cf			endm 
# End of macro STACKFRAME
a0cf			; get parser buffer length  of new word 
a0cf			 
a0cf			 
a0cf			 
a0cf				; move tok past this to start of name defintition 
a0cf				; TODO get word to define 
a0cf				; TODO Move past word token 
a0cf				; TODO get length of string up to the ';' 
a0cf			 
a0cf 2a c2 e5		ld hl, (os_tok_ptr) 
a0d2 23			inc hl 
a0d3 23			inc hl 
a0d4			 
a0d4 3e 3b		ld a, ';' 
a0d6 cd 58 90		call strlent 
a0d9			 
a0d9 7d			ld a,l 
a0da 32 b1 e2		ld (os_new_parse_len), a 
a0dd			 
a0dd			 
a0dd			if DEBUG_FORTH_UWORD 
a0dd ed 5b c2 e5	ld de, (os_tok_ptr) 
a0e1					DMARK ":01" 
a0e1 f5				push af  
a0e2 3a f6 a0			ld a, (.dmark)  
a0e5 32 6b ee			ld (debug_mark),a  
a0e8 3a f7 a0			ld a, (.dmark+1)  
a0eb 32 6c ee			ld (debug_mark+1),a  
a0ee 3a f8 a0			ld a, (.dmark+2)  
a0f1 32 6d ee			ld (debug_mark+2),a  
a0f4 18 03			jr .pastdmark  
a0f6 ..			.dmark: db ":01"  
a0f9 f1			.pastdmark: pop af  
a0fa			endm  
# End of macro DMARK
a0fa			CALLMONITOR 
a0fa cd 6f ee			call debug_vector  
a0fd				endm  
# End of macro CALLMONITOR
a0fd			endif 
a0fd			 
a0fd			; 
a0fd			;  new word memory layout: 
a0fd			;  
a0fd			;    : adg 6666 ;  
a0fd			; 
a0fd			;    db   1     ; user defined word  
a0fd 23			inc hl    
a0fe			;    dw   sysdict 
a0fe 23			inc hl 
a0ff 23			inc hl 
a100			;    db <word len>+1 (for null) 
a100 23			inc hl 
a101			;    db .... <word> 
a101			; 
a101			 
a101 23			inc hl    ; some extras for the word preamble before the above 
a102 23			inc hl 
a103 23			inc hl 
a104 23			inc hl 
a105 23			inc hl 
a106 23			inc hl 
a107 23			inc hl  
a108 23			inc hl 
a109 23			inc hl 
a10a 23			inc hl 
a10b 23			inc hl 
a10c 23			inc hl 
a10d 23			inc hl 
a10e 23			inc hl     ; TODO how many do we really need?     maybe only 6 
a10f			;       exec word buffer 
a10f			;	<ptr word>   
a10f 23			inc hl 
a110 23			inc hl 
a111			;       <word list><null term> 7F final term 
a111			 
a111			 
a111			if DEBUG_FORTH_UWORD 
a111					DMARK ":02" 
a111 f5				push af  
a112 3a 26 a1			ld a, (.dmark)  
a115 32 6b ee			ld (debug_mark),a  
a118 3a 27 a1			ld a, (.dmark+1)  
a11b 32 6c ee			ld (debug_mark+1),a  
a11e 3a 28 a1			ld a, (.dmark+2)  
a121 32 6d ee			ld (debug_mark+2),a  
a124 18 03			jr .pastdmark  
a126 ..			.dmark: db ":02"  
a129 f1			.pastdmark: pop af  
a12a			endm  
# End of macro DMARK
a12a			CALLMONITOR 
a12a cd 6f ee			call debug_vector  
a12d				endm  
# End of macro CALLMONITOR
a12d			endif 
a12d			 
a12d			 
a12d				; malloc the size 
a12d			 
a12d cd c2 90			call malloc 
a130 22 b3 e2			ld (os_new_malloc), hl     ; save malloc start 
a133			 
a133			;    db   1     ; user defined word  
a133 3e 01			ld a, WORD_SYS_UWORD  
a135 77				ld (hl), a 
a136			 
a136 23			inc hl    
a137			;    dw   sysdict 
a137 11 81 9f		ld de, sysdict       ; continue on with the scan to the system dict 
a13a 73			ld (hl), e 
a13b 23			inc hl 
a13c 72			ld (hl), d 
a13d 23			inc hl 
a13e			 
a13e			 
a13e			;    Setup dict word 
a13e			 
a13e 23			inc hl 
a13f 22 ad e2		ld (os_new_work_ptr), hl     ; save start of dict word  
a142			 
a142			; 1. get length of dict word 
a142			 
a142			 
a142 2a c2 e5		ld hl, (os_tok_ptr) 
a145 23			inc hl 
a146 23			inc hl    ; position to start of dict word 
a147 3e 00		ld a, 0 
a149 cd 58 90		call strlent 
a14c			 
a14c			 
a14c 23			inc hl    ; to include null??? 
a14d			 
a14d			; write length of dict word 
a14d			 
a14d ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a151 1b			dec de 
a152 eb			ex de, hl 
a153 73			ld (hl), e 
a154 eb			ex de, hl 
a155			 
a155			 
a155			 
a155			; copy  
a155 4d			ld c, l 
a156 06 00		ld b, 0 
a158 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a15c 2a c2 e5		ld hl, (os_tok_ptr) 
a15f 23			inc hl 
a160 23			inc hl    ; position to start of dict word 
a161			 
a161			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a161			 
a161			; TODO need to convert word to upper case 
a161			 
a161			ucasetok:	 
a161 7e			ld a,(hl) 
a162 cd 44 90		call toUpper 
a165 77			ld (hl),a 
a166 ed a0		ldi 
a168 f2 61 a1		jp p, ucasetok 
a16b			 
a16b			 
a16b			 
a16b			; de now points to start of where the word body code should be placed 
a16b ed 53 ad e2	ld (os_new_work_ptr), de 
a16f			; hl now points to the words to throw at forthexec which needs to be copied 
a16f 22 ab e2		ld (os_new_src_ptr), hl 
a172			 
a172			; TODO add 'call to forthexec' 
a172			 
a172			if DEBUG_FORTH_UWORD 
a172 c5			push bc 
a173 ed 4b b3 e2	ld bc, (os_new_malloc) 
a177					DMARK ":0x" 
a177 f5				push af  
a178 3a 8c a1			ld a, (.dmark)  
a17b 32 6b ee			ld (debug_mark),a  
a17e 3a 8d a1			ld a, (.dmark+1)  
a181 32 6c ee			ld (debug_mark+1),a  
a184 3a 8e a1			ld a, (.dmark+2)  
a187 32 6d ee			ld (debug_mark+2),a  
a18a 18 03			jr .pastdmark  
a18c ..			.dmark: db ":0x"  
a18f f1			.pastdmark: pop af  
a190			endm  
# End of macro DMARK
a190			CALLMONITOR 
a190 cd 6f ee			call debug_vector  
a193				endm  
# End of macro CALLMONITOR
a193 c1			pop bc 
a194			endif 
a194			 
a194			 
a194			; create word preamble which should be: 
a194			 
a194			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a194			 
a194			;    ld hl, <word code> 
a194			;    jp user_exec 
a194			;    <word code bytes> 
a194			 
a194			 
a194			;	inc de     ; TODO ??? or are we already past the word's null 
a194 eb			ex de, hl 
a195			 
a195 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a197			 
a197 23			inc hl 
a198 22 a7 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a19b 23			inc hl 
a19c			 
a19c 23			inc hl 
a19d 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a19f			 
a19f 01 17 cb		ld bc, user_exec 
a1a2 23			inc hl 
a1a3 71			ld (hl), c     ; poke address of user_exec 
a1a4 23			inc hl 
a1a5 70			ld (hl), b     
a1a6			; 
a1a6			;	inc hl 
a1a6			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a1a6			; 
a1a6			; 
a1a6			;	ld bc, macro_forth_rsp_next 
a1a6			;	inc hl 
a1a6			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a1a6			;	inc hl 
a1a6			;	ld (hl), b     
a1a6			; 
a1a6			;	inc hl 
a1a6			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a1a6			; 
a1a6			; 
a1a6			;	inc hl 
a1a6			;	ld bc, forthexec 
a1a6			;	ld (hl), c     ; poke address of forthexec 
a1a6			;	inc hl 
a1a6			;	ld (hl), b      
a1a6			; 
a1a6			;	inc hl 
a1a6			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a1a6			; 
a1a6			;	ld bc, user_dict_next 
a1a6			;	inc hl 
a1a6			;	ld (hl), c     ; poke address of forthexec 
a1a6			;	inc hl 
a1a6			;	ld (hl), b      
a1a6			 
a1a6			; hl is now where we need to copy the word byte data to save this 
a1a6			 
a1a6 23			inc hl 
a1a7 22 a9 e2		ld (os_new_exec), hl 
a1aa			 
a1aa			; copy definition 
a1aa			 
a1aa eb			ex de, hl 
a1ab			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a1ab			;	inc de    ; skip the PC for this parse 
a1ab 3a b1 e2		ld a, (os_new_parse_len) 
a1ae 4f			ld c, a 
a1af 06 00		ld b, 0 
a1b1 ed b0		ldir		 ; copy defintion 
a1b3			 
a1b3			 
a1b3			; poke the address of where the new word bytes live for forthexec 
a1b3			 
a1b3 2a a7 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a1b6			 
a1b6 ed 5b a9 e2	ld de, (os_new_exec)      
a1ba			 
a1ba 73			ld (hl), e 
a1bb 23			inc hl 
a1bc 72			ld (hl), d 
a1bd			 
a1bd				; TODO copy last user dict word next link to this word 
a1bd				; TODO update last user dict word to point to this word 
a1bd			; 
a1bd			; hl f923 de 812a ; bc 811a 
a1bd			 
a1bd			if DEBUG_FORTH_UWORD 
a1bd c5			push bc 
a1be ed 4b b3 e2	ld bc, (os_new_malloc) 
a1c2					DMARK ":0A" 
a1c2 f5				push af  
a1c3 3a d7 a1			ld a, (.dmark)  
a1c6 32 6b ee			ld (debug_mark),a  
a1c9 3a d8 a1			ld a, (.dmark+1)  
a1cc 32 6c ee			ld (debug_mark+1),a  
a1cf 3a d9 a1			ld a, (.dmark+2)  
a1d2 32 6d ee			ld (debug_mark+2),a  
a1d5 18 03			jr .pastdmark  
a1d7 ..			.dmark: db ":0A"  
a1da f1			.pastdmark: pop af  
a1db			endm  
# End of macro DMARK
a1db			CALLMONITOR 
a1db cd 6f ee			call debug_vector  
a1de				endm  
# End of macro CALLMONITOR
a1de c1			pop bc 
a1df			endif 
a1df			if DEBUG_FORTH_UWORD 
a1df c5			push bc 
a1e0 ed 4b b3 e2	ld bc, (os_new_malloc) 
a1e4 03			inc bc 
a1e5 03			inc bc 
a1e6 03			inc bc 
a1e7 03			inc bc 
a1e8 03			inc bc 
a1e9 03			inc bc 
a1ea 03			inc bc 
a1eb 03			inc bc 
a1ec			 
a1ec					DMARK ":0B" 
a1ec f5				push af  
a1ed 3a 01 a2			ld a, (.dmark)  
a1f0 32 6b ee			ld (debug_mark),a  
a1f3 3a 02 a2			ld a, (.dmark+1)  
a1f6 32 6c ee			ld (debug_mark+1),a  
a1f9 3a 03 a2			ld a, (.dmark+2)  
a1fc 32 6d ee			ld (debug_mark+2),a  
a1ff 18 03			jr .pastdmark  
a201 ..			.dmark: db ":0B"  
a204 f1			.pastdmark: pop af  
a205			endm  
# End of macro DMARK
a205			CALLMONITOR 
a205 cd 6f ee			call debug_vector  
a208				endm  
# End of macro CALLMONITOR
a208 c1			pop bc 
a209			endif 
a209			 
a209			; update word dict linked list for new word 
a209			 
a209			 
a209 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a20c 23			inc hl     ; move to next work linked list ptr 
a20d			 
a20d ed 5b b3 e2	ld de, (os_new_malloc)		 ; new next word 
a211 73			ld (hl), e 
a212 23			inc hl 
a213 72			ld (hl), d 
a214			 
a214			if DEBUG_FORTH_UWORD 
a214 ed 4b be e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a218			endif 
a218			 
a218 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a21c			 
a21c			 
a21c			if DEBUG_FORTH_UWORD 
a21c					DMARK ":0+" 
a21c f5				push af  
a21d 3a 31 a2			ld a, (.dmark)  
a220 32 6b ee			ld (debug_mark),a  
a223 3a 32 a2			ld a, (.dmark+1)  
a226 32 6c ee			ld (debug_mark+1),a  
a229 3a 33 a2			ld a, (.dmark+2)  
a22c 32 6d ee			ld (debug_mark+2),a  
a22f 18 03			jr .pastdmark  
a231 ..			.dmark: db ":0+"  
a234 f1			.pastdmark: pop af  
a235			endm  
# End of macro DMARK
a235			CALLMONITOR 
a235 cd 6f ee			call debug_vector  
a238				endm  
# End of macro CALLMONITOR
a238			endif 
a238			 
a238			STACKFRAMECHK OFF $8efe $989f 
a238				if DEBUG_STACK_IMB 
a238					if OFF 
a238						exx 
a238						ld hl, $989f 
a238						pop de   ; $989f 
a238						call cmp16 
a238						jr nz, .spnosame 
a238						ld hl, $8efe 
a238						pop de   ; $8efe 
a238						call cmp16 
a238						jr z, .spfrsame 
a238						.spnosame: call showsperror 
a238						.spfrsame: nop 
a238						exx 
a238					endif 
a238				endif 
a238			endm 
# End of macro STACKFRAMECHK
a238			 
a238 c9			ret    ; dont process any remaining parser tokens as they form new word 
a239			 
a239			 
a239			 
a239			 
a239			;		NEXT 
a239			.SCOLN: 
a239			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a239 06			db OPCODE_SCOLN 
a23a 85 a2		dw .DROP 
a23c 02			db 2 
a23d .. 00		db ";",0           
a23f			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a23f				if DEBUG_FORTH_WORDS_KEY 
a23f					DMARK "SCN" 
a23f f5				push af  
a240 3a 54 a2			ld a, (.dmark)  
a243 32 6b ee			ld (debug_mark),a  
a246 3a 55 a2			ld a, (.dmark+1)  
a249 32 6c ee			ld (debug_mark+1),a  
a24c 3a 56 a2			ld a, (.dmark+2)  
a24f 32 6d ee			ld (debug_mark+2),a  
a252 18 03			jr .pastdmark  
a254 ..			.dmark: db "SCN"  
a257 f1			.pastdmark: pop af  
a258			endm  
# End of macro DMARK
a258					CALLMONITOR 
a258 cd 6f ee			call debug_vector  
a25b				endm  
# End of macro CALLMONITOR
a25b				endif 
a25b				FORTH_RSP_TOS 
a25b cd 2c 9a			call macro_forth_rsp_tos 
a25e				endm 
# End of macro FORTH_RSP_TOS
a25e e5				push hl 
a25f				FORTH_RSP_POP 
a25f cd 36 9a			call macro_forth_rsp_pop 
a262				endm 
# End of macro FORTH_RSP_POP
a262 e1				pop hl 
a263			;		ex de,hl 
a263 22 c2 e5			ld (os_tok_ptr),hl 
a266			 
a266			if DEBUG_FORTH_UWORD 
a266					DMARK "SCL" 
a266 f5				push af  
a267 3a 7b a2			ld a, (.dmark)  
a26a 32 6b ee			ld (debug_mark),a  
a26d 3a 7c a2			ld a, (.dmark+1)  
a270 32 6c ee			ld (debug_mark+1),a  
a273 3a 7d a2			ld a, (.dmark+2)  
a276 32 6d ee			ld (debug_mark+2),a  
a279 18 03			jr .pastdmark  
a27b ..			.dmark: db "SCL"  
a27e f1			.pastdmark: pop af  
a27f			endm  
# End of macro DMARK
a27f			CALLMONITOR 
a27f cd 6f ee			call debug_vector  
a282				endm  
# End of macro CALLMONITOR
a282			endif 
a282				NEXTW 
a282 c3 29 9e			jp macro_next 
a285				endm 
# End of macro NEXTW
a285			 
a285			.DROP: 
a285			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a285 1b				db WORD_SYS_CORE+OPCODE_DROP             
a286 b0 a2			dw .DUP2            
a288 05				db 4 + 1 
a289 .. 00			db "DROP",0              
a28e				endm 
# End of macro CWHEAD
a28e			; | DROP ( w -- )   drop the TOS item   | DONE 
a28e				if DEBUG_FORTH_WORDS_KEY 
a28e					DMARK "DRP" 
a28e f5				push af  
a28f 3a a3 a2			ld a, (.dmark)  
a292 32 6b ee			ld (debug_mark),a  
a295 3a a4 a2			ld a, (.dmark+1)  
a298 32 6c ee			ld (debug_mark+1),a  
a29b 3a a5 a2			ld a, (.dmark+2)  
a29e 32 6d ee			ld (debug_mark+2),a  
a2a1 18 03			jr .pastdmark  
a2a3 ..			.dmark: db "DRP"  
a2a6 f1			.pastdmark: pop af  
a2a7			endm  
# End of macro DMARK
a2a7					CALLMONITOR 
a2a7 cd 6f ee			call debug_vector  
a2aa				endm  
# End of macro CALLMONITOR
a2aa				endif 
a2aa				FORTH_DSP_POP 
a2aa cd 2b 9d			call macro_forth_dsp_pop 
a2ad				endm 
# End of macro FORTH_DSP_POP
a2ad				NEXTW 
a2ad c3 29 9e			jp macro_next 
a2b0				endm 
# End of macro NEXTW
a2b0			.DUP2: 
a2b0			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a2b0 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a2b1 f5 a2			dw .DROP2            
a2b3 05				db 4 + 1 
a2b4 .. 00			db "2DUP",0              
a2b9				endm 
# End of macro CWHEAD
a2b9			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a2b9				if DEBUG_FORTH_WORDS_KEY 
a2b9					DMARK "2DU" 
a2b9 f5				push af  
a2ba 3a ce a2			ld a, (.dmark)  
a2bd 32 6b ee			ld (debug_mark),a  
a2c0 3a cf a2			ld a, (.dmark+1)  
a2c3 32 6c ee			ld (debug_mark+1),a  
a2c6 3a d0 a2			ld a, (.dmark+2)  
a2c9 32 6d ee			ld (debug_mark+2),a  
a2cc 18 03			jr .pastdmark  
a2ce ..			.dmark: db "2DU"  
a2d1 f1			.pastdmark: pop af  
a2d2			endm  
# End of macro DMARK
a2d2					CALLMONITOR 
a2d2 cd 6f ee			call debug_vector  
a2d5				endm  
# End of macro CALLMONITOR
a2d5				endif 
a2d5				FORTH_DSP_VALUEHL 
a2d5 cd 73 9c			call macro_dsp_valuehl 
a2d8				endm 
# End of macro FORTH_DSP_VALUEHL
a2d8 e5				push hl      ; 2 
a2d9			 
a2d9				FORTH_DSP_POP 
a2d9 cd 2b 9d			call macro_forth_dsp_pop 
a2dc				endm 
# End of macro FORTH_DSP_POP
a2dc				 
a2dc				FORTH_DSP_VALUEHL 
a2dc cd 73 9c			call macro_dsp_valuehl 
a2df				endm 
# End of macro FORTH_DSP_VALUEHL
a2df			;		push hl      ; 1 
a2df			 
a2df				FORTH_DSP_POP 
a2df cd 2b 9d			call macro_forth_dsp_pop 
a2e2				endm 
# End of macro FORTH_DSP_POP
a2e2			 
a2e2			;		pop hl       ; 1 
a2e2 d1				pop de       ; 2 
a2e3			 
a2e3 cd 6e 9a			call forth_push_numhl 
a2e6 eb				ex de, hl 
a2e7 cd 6e 9a			call forth_push_numhl 
a2ea			 
a2ea				 
a2ea eb				ex de, hl 
a2eb			 
a2eb cd 6e 9a			call forth_push_numhl 
a2ee eb				ex de, hl 
a2ef cd 6e 9a			call forth_push_numhl 
a2f2			 
a2f2			 
a2f2				NEXTW 
a2f2 c3 29 9e			jp macro_next 
a2f5				endm 
# End of macro NEXTW
a2f5			.DROP2: 
a2f5			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a2f5 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a2f6 24 a3			dw .SWAP2            
a2f8 06				db 5 + 1 
a2f9 .. 00			db "2DROP",0              
a2ff				endm 
# End of macro CWHEAD
a2ff			; | 2DROP ( w w -- )    Double drop | DONE 
a2ff				if DEBUG_FORTH_WORDS_KEY 
a2ff					DMARK "2DR" 
a2ff f5				push af  
a300 3a 14 a3			ld a, (.dmark)  
a303 32 6b ee			ld (debug_mark),a  
a306 3a 15 a3			ld a, (.dmark+1)  
a309 32 6c ee			ld (debug_mark+1),a  
a30c 3a 16 a3			ld a, (.dmark+2)  
a30f 32 6d ee			ld (debug_mark+2),a  
a312 18 03			jr .pastdmark  
a314 ..			.dmark: db "2DR"  
a317 f1			.pastdmark: pop af  
a318			endm  
# End of macro DMARK
a318					CALLMONITOR 
a318 cd 6f ee			call debug_vector  
a31b				endm  
# End of macro CALLMONITOR
a31b				endif 
a31b				FORTH_DSP_POP 
a31b cd 2b 9d			call macro_forth_dsp_pop 
a31e				endm 
# End of macro FORTH_DSP_POP
a31e				FORTH_DSP_POP 
a31e cd 2b 9d			call macro_forth_dsp_pop 
a321				endm 
# End of macro FORTH_DSP_POP
a321				NEXTW 
a321 c3 29 9e			jp macro_next 
a324				endm 
# End of macro NEXTW
a324			.SWAP2: 
a324			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a324 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a325 4d a3			dw .AT            
a327 06				db 5 + 1 
a328 .. 00			db "2SWAP",0              
a32e				endm 
# End of macro CWHEAD
a32e			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a32e				if DEBUG_FORTH_WORDS_KEY 
a32e					DMARK "2SW" 
a32e f5				push af  
a32f 3a 43 a3			ld a, (.dmark)  
a332 32 6b ee			ld (debug_mark),a  
a335 3a 44 a3			ld a, (.dmark+1)  
a338 32 6c ee			ld (debug_mark+1),a  
a33b 3a 45 a3			ld a, (.dmark+2)  
a33e 32 6d ee			ld (debug_mark+2),a  
a341 18 03			jr .pastdmark  
a343 ..			.dmark: db "2SW"  
a346 f1			.pastdmark: pop af  
a347			endm  
# End of macro DMARK
a347					CALLMONITOR 
a347 cd 6f ee			call debug_vector  
a34a				endm  
# End of macro CALLMONITOR
a34a				endif 
a34a			; TODO Use os stack swap memory 
a34a				NEXTW 
a34a c3 29 9e			jp macro_next 
a34d				endm 
# End of macro NEXTW
a34d			.AT: 
a34d			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a34d 1f				db WORD_SYS_CORE+OPCODE_AT             
a34e 7f a3			dw .CAT            
a350 02				db 1 + 1 
a351 .. 00			db "@",0              
a353				endm 
# End of macro CWHEAD
a353			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a353			 
a353				if DEBUG_FORTH_WORDS_KEY 
a353					DMARK "AT." 
a353 f5				push af  
a354 3a 68 a3			ld a, (.dmark)  
a357 32 6b ee			ld (debug_mark),a  
a35a 3a 69 a3			ld a, (.dmark+1)  
a35d 32 6c ee			ld (debug_mark+1),a  
a360 3a 6a a3			ld a, (.dmark+2)  
a363 32 6d ee			ld (debug_mark+2),a  
a366 18 03			jr .pastdmark  
a368 ..			.dmark: db "AT."  
a36b f1			.pastdmark: pop af  
a36c			endm  
# End of macro DMARK
a36c					CALLMONITOR 
a36c cd 6f ee			call debug_vector  
a36f				endm  
# End of macro CALLMONITOR
a36f				endif 
a36f			.getbyteat:	 
a36f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a36f cd 73 9c			call macro_dsp_valuehl 
a372				endm 
# End of macro FORTH_DSP_VALUEHL
a372				 
a372			;		push hl 
a372			 
a372				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a372 cd 2b 9d			call macro_forth_dsp_pop 
a375				endm 
# End of macro FORTH_DSP_POP
a375			 
a375			;		pop hl 
a375			 
a375 7e				ld a, (hl) 
a376			 
a376 6f				ld l, a 
a377 26 00			ld h, 0 
a379 cd 6e 9a			call forth_push_numhl 
a37c			 
a37c				NEXTW 
a37c c3 29 9e			jp macro_next 
a37f				endm 
# End of macro NEXTW
a37f			.CAT: 
a37f			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a37f 20				db WORD_SYS_CORE+OPCODE_CAT             
a380 a8 a3			dw .BANG            
a382 03				db 2 + 1 
a383 .. 00			db "C@",0              
a386				endm 
# End of macro CWHEAD
a386			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a386				if DEBUG_FORTH_WORDS_KEY 
a386					DMARK "CAA" 
a386 f5				push af  
a387 3a 9b a3			ld a, (.dmark)  
a38a 32 6b ee			ld (debug_mark),a  
a38d 3a 9c a3			ld a, (.dmark+1)  
a390 32 6c ee			ld (debug_mark+1),a  
a393 3a 9d a3			ld a, (.dmark+2)  
a396 32 6d ee			ld (debug_mark+2),a  
a399 18 03			jr .pastdmark  
a39b ..			.dmark: db "CAA"  
a39e f1			.pastdmark: pop af  
a39f			endm  
# End of macro DMARK
a39f					CALLMONITOR 
a39f cd 6f ee			call debug_vector  
a3a2				endm  
# End of macro CALLMONITOR
a3a2				endif 
a3a2 c3 6f a3			jp .getbyteat 
a3a5				NEXTW 
a3a5 c3 29 9e			jp macro_next 
a3a8				endm 
# End of macro NEXTW
a3a8			.BANG: 
a3a8			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a3a8 21				db WORD_SYS_CORE+OPCODE_BANG             
a3a9 de a3			dw .CBANG            
a3ab 02				db 1 + 1 
a3ac .. 00			db "!",0              
a3ae				endm 
# End of macro CWHEAD
a3ae			; | ! ( x w -- ) Store x at address w      | DONE 
a3ae				if DEBUG_FORTH_WORDS_KEY 
a3ae					DMARK "BNG" 
a3ae f5				push af  
a3af 3a c3 a3			ld a, (.dmark)  
a3b2 32 6b ee			ld (debug_mark),a  
a3b5 3a c4 a3			ld a, (.dmark+1)  
a3b8 32 6c ee			ld (debug_mark+1),a  
a3bb 3a c5 a3			ld a, (.dmark+2)  
a3be 32 6d ee			ld (debug_mark+2),a  
a3c1 18 03			jr .pastdmark  
a3c3 ..			.dmark: db "BNG"  
a3c6 f1			.pastdmark: pop af  
a3c7			endm  
# End of macro DMARK
a3c7					CALLMONITOR 
a3c7 cd 6f ee			call debug_vector  
a3ca				endm  
# End of macro CALLMONITOR
a3ca				endif 
a3ca			 
a3ca			.storebyteat:		 
a3ca				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3ca cd 73 9c			call macro_dsp_valuehl 
a3cd				endm 
# End of macro FORTH_DSP_VALUEHL
a3cd				 
a3cd e5				push hl 
a3ce			 
a3ce				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3ce cd 2b 9d			call macro_forth_dsp_pop 
a3d1				endm 
# End of macro FORTH_DSP_POP
a3d1			 
a3d1				; get byte to poke 
a3d1			 
a3d1				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3d1 cd 73 9c			call macro_dsp_valuehl 
a3d4				endm 
# End of macro FORTH_DSP_VALUEHL
a3d4 e5				push hl 
a3d5			 
a3d5			 
a3d5				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3d5 cd 2b 9d			call macro_forth_dsp_pop 
a3d8				endm 
# End of macro FORTH_DSP_POP
a3d8			 
a3d8			 
a3d8 d1				pop de 
a3d9 e1				pop hl 
a3da			 
a3da 73				ld (hl),e 
a3db			 
a3db			 
a3db				NEXTW 
a3db c3 29 9e			jp macro_next 
a3de				endm 
# End of macro NEXTW
a3de			.CBANG: 
a3de			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a3de 22				db WORD_SYS_CORE+OPCODE_CBANG             
a3df 07 a4			dw .SCALL            
a3e1 03				db 2 + 1 
a3e2 .. 00			db "C!",0              
a3e5				endm 
# End of macro CWHEAD
a3e5			; | C!  ( x w -- ) Store x at address w  | DONE 
a3e5				if DEBUG_FORTH_WORDS_KEY 
a3e5					DMARK "CBA" 
a3e5 f5				push af  
a3e6 3a fa a3			ld a, (.dmark)  
a3e9 32 6b ee			ld (debug_mark),a  
a3ec 3a fb a3			ld a, (.dmark+1)  
a3ef 32 6c ee			ld (debug_mark+1),a  
a3f2 3a fc a3			ld a, (.dmark+2)  
a3f5 32 6d ee			ld (debug_mark+2),a  
a3f8 18 03			jr .pastdmark  
a3fa ..			.dmark: db "CBA"  
a3fd f1			.pastdmark: pop af  
a3fe			endm  
# End of macro DMARK
a3fe					CALLMONITOR 
a3fe cd 6f ee			call debug_vector  
a401				endm  
# End of macro CALLMONITOR
a401				endif 
a401 c3 ca a3			jp .storebyteat 
a404				NEXTW 
a404 c3 29 9e			jp macro_next 
a407				endm 
# End of macro NEXTW
a407			.SCALL: 
a407			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a407 23				db WORD_SYS_CORE+OPCODE_SCALL             
a408 3b a4			dw .DEPTH            
a40a 05				db 4 + 1 
a40b .. 00			db "CALL",0              
a410				endm 
# End of macro CWHEAD
a410			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a410				if DEBUG_FORTH_WORDS_KEY 
a410					DMARK "CLL" 
a410 f5				push af  
a411 3a 25 a4			ld a, (.dmark)  
a414 32 6b ee			ld (debug_mark),a  
a417 3a 26 a4			ld a, (.dmark+1)  
a41a 32 6c ee			ld (debug_mark+1),a  
a41d 3a 27 a4			ld a, (.dmark+2)  
a420 32 6d ee			ld (debug_mark+2),a  
a423 18 03			jr .pastdmark  
a425 ..			.dmark: db "CLL"  
a428 f1			.pastdmark: pop af  
a429			endm  
# End of macro DMARK
a429					CALLMONITOR 
a429 cd 6f ee			call debug_vector  
a42c				endm  
# End of macro CALLMONITOR
a42c				endif 
a42c			 
a42c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a42c cd 73 9c			call macro_dsp_valuehl 
a42f				endm 
# End of macro FORTH_DSP_VALUEHL
a42f			 
a42f			;		push hl 
a42f			 
a42f				; destroy value TOS 
a42f			 
a42f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a42f cd 2b 9d			call macro_forth_dsp_pop 
a432				endm 
# End of macro FORTH_DSP_POP
a432			 
a432					 
a432			;		pop hl 
a432			 
a432				; how to do a call with hl???? save SP? 
a432 cd cd 9d			call forth_call_hl 
a435			 
a435			 
a435				; TODO push value back onto stack for another op etc 
a435			 
a435 cd 6e 9a			call forth_push_numhl 
a438				NEXTW 
a438 c3 29 9e			jp macro_next 
a43b				endm 
# End of macro NEXTW
a43b			.DEPTH: 
a43b			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a43b 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a43c 78 a4			dw .OVER            
a43e 06				db 5 + 1 
a43f .. 00			db "DEPTH",0              
a445				endm 
# End of macro CWHEAD
a445			; | DEPTH ( -- u ) Push count of stack | DONE 
a445				; take current TOS and remove from base value div by two to get count 
a445				if DEBUG_FORTH_WORDS_KEY 
a445					DMARK "DEP" 
a445 f5				push af  
a446 3a 5a a4			ld a, (.dmark)  
a449 32 6b ee			ld (debug_mark),a  
a44c 3a 5b a4			ld a, (.dmark+1)  
a44f 32 6c ee			ld (debug_mark+1),a  
a452 3a 5c a4			ld a, (.dmark+2)  
a455 32 6d ee			ld (debug_mark+2),a  
a458 18 03			jr .pastdmark  
a45a ..			.dmark: db "DEP"  
a45d f1			.pastdmark: pop af  
a45e			endm  
# End of macro DMARK
a45e					CALLMONITOR 
a45e cd 6f ee			call debug_vector  
a461				endm  
# End of macro CALLMONITOR
a461				endif 
a461			 
a461			 
a461 2a ee e9		ld hl, (cli_data_sp) 
a464 11 28 e8		ld de, cli_data_stack 
a467 ed 52		sbc hl,de 
a469			 
a469			; div by size of stack item 
a469			 
a469 5d			ld e,l 
a46a 0e 03		ld c, 3 
a46c cd 77 8c		call Div8 
a46f			 
a46f 6f			ld l,a 
a470 26 00		ld h,0 
a472			 
a472			;srl h 
a472			;rr l 
a472			 
a472 cd 6e 9a			call forth_push_numhl 
a475				NEXTW 
a475 c3 29 9e			jp macro_next 
a478				endm 
# End of macro NEXTW
a478			.OVER: 
a478			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a478 42				db WORD_SYS_CORE+46             
a479 bf a4			dw .PAUSE            
a47b 05				db 4 + 1 
a47c .. 00			db "OVER",0              
a481				endm 
# End of macro CWHEAD
a481			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a481				if DEBUG_FORTH_WORDS_KEY 
a481					DMARK "OVR" 
a481 f5				push af  
a482 3a 96 a4			ld a, (.dmark)  
a485 32 6b ee			ld (debug_mark),a  
a488 3a 97 a4			ld a, (.dmark+1)  
a48b 32 6c ee			ld (debug_mark+1),a  
a48e 3a 98 a4			ld a, (.dmark+2)  
a491 32 6d ee			ld (debug_mark+2),a  
a494 18 03			jr .pastdmark  
a496 ..			.dmark: db "OVR"  
a499 f1			.pastdmark: pop af  
a49a			endm  
# End of macro DMARK
a49a					CALLMONITOR 
a49a cd 6f ee			call debug_vector  
a49d				endm  
# End of macro CALLMONITOR
a49d				endif 
a49d			 
a49d			; TODO Use os stack swap memory 
a49d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a49d cd 73 9c			call macro_dsp_valuehl 
a4a0				endm 
# End of macro FORTH_DSP_VALUEHL
a4a0 e5				push hl    ; n2 
a4a1				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4a1 cd 2b 9d			call macro_forth_dsp_pop 
a4a4				endm 
# End of macro FORTH_DSP_POP
a4a4			 
a4a4				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4a4 cd 73 9c			call macro_dsp_valuehl 
a4a7				endm 
# End of macro FORTH_DSP_VALUEHL
a4a7 e5				push hl    ; n1 
a4a8				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4a8 cd 2b 9d			call macro_forth_dsp_pop 
a4ab				endm 
# End of macro FORTH_DSP_POP
a4ab			 
a4ab d1				pop de     ; n1 
a4ac e1				pop hl     ; n2 
a4ad			 
a4ad d5				push de 
a4ae e5				push hl 
a4af d5				push de 
a4b0			 
a4b0				; push back  
a4b0			 
a4b0 e1				pop hl 
a4b1 cd 6e 9a			call forth_push_numhl 
a4b4 e1				pop hl 
a4b5 cd 6e 9a			call forth_push_numhl 
a4b8 e1				pop hl 
a4b9 cd 6e 9a			call forth_push_numhl 
a4bc				NEXTW 
a4bc c3 29 9e			jp macro_next 
a4bf				endm 
# End of macro NEXTW
a4bf			 
a4bf			.PAUSE: 
a4bf			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a4bf 43				db WORD_SYS_CORE+47             
a4c0 f4 a4			dw .PAUSES            
a4c2 08				db 7 + 1 
a4c3 .. 00			db "PAUSEMS",0              
a4cb				endm 
# End of macro CWHEAD
a4cb			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a4cb				if DEBUG_FORTH_WORDS_KEY 
a4cb					DMARK "PMS" 
a4cb f5				push af  
a4cc 3a e0 a4			ld a, (.dmark)  
a4cf 32 6b ee			ld (debug_mark),a  
a4d2 3a e1 a4			ld a, (.dmark+1)  
a4d5 32 6c ee			ld (debug_mark+1),a  
a4d8 3a e2 a4			ld a, (.dmark+2)  
a4db 32 6d ee			ld (debug_mark+2),a  
a4de 18 03			jr .pastdmark  
a4e0 ..			.dmark: db "PMS"  
a4e3 f1			.pastdmark: pop af  
a4e4			endm  
# End of macro DMARK
a4e4					CALLMONITOR 
a4e4 cd 6f ee			call debug_vector  
a4e7				endm  
# End of macro CALLMONITOR
a4e7				endif 
a4e7				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4e7 cd 73 9c			call macro_dsp_valuehl 
a4ea				endm 
# End of macro FORTH_DSP_VALUEHL
a4ea			;		push hl    ; n2 
a4ea				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4ea cd 2b 9d			call macro_forth_dsp_pop 
a4ed				endm 
# End of macro FORTH_DSP_POP
a4ed			;		pop hl 
a4ed			 
a4ed 7d				ld a, l 
a4ee cd e2 89			call aDelayInMS 
a4f1			       NEXTW 
a4f1 c3 29 9e			jp macro_next 
a4f4				endm 
# End of macro NEXTW
a4f4			.PAUSES:  
a4f4			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a4f4 44				db WORD_SYS_CORE+48             
a4f5 63 a5			dw .ROT            
a4f7 06				db 5 + 1 
a4f8 .. 00			db "PAUSE",0              
a4fe				endm 
# End of macro CWHEAD
a4fe			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a4fe				if DEBUG_FORTH_WORDS_KEY 
a4fe					DMARK "PAU" 
a4fe f5				push af  
a4ff 3a 13 a5			ld a, (.dmark)  
a502 32 6b ee			ld (debug_mark),a  
a505 3a 14 a5			ld a, (.dmark+1)  
a508 32 6c ee			ld (debug_mark+1),a  
a50b 3a 15 a5			ld a, (.dmark+2)  
a50e 32 6d ee			ld (debug_mark+2),a  
a511 18 03			jr .pastdmark  
a513 ..			.dmark: db "PAU"  
a516 f1			.pastdmark: pop af  
a517			endm  
# End of macro DMARK
a517					CALLMONITOR 
a517 cd 6f ee			call debug_vector  
a51a				endm  
# End of macro CALLMONITOR
a51a				endif 
a51a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a51a cd 73 9c			call macro_dsp_valuehl 
a51d				endm 
# End of macro FORTH_DSP_VALUEHL
a51d			;		push hl    ; n2 
a51d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a51d cd 2b 9d			call macro_forth_dsp_pop 
a520				endm 
# End of macro FORTH_DSP_POP
a520			;		pop hl 
a520 45				ld b, l 
a521				if DEBUG_FORTH_WORDS 
a521					DMARK "PAU" 
a521 f5				push af  
a522 3a 36 a5			ld a, (.dmark)  
a525 32 6b ee			ld (debug_mark),a  
a528 3a 37 a5			ld a, (.dmark+1)  
a52b 32 6c ee			ld (debug_mark+1),a  
a52e 3a 38 a5			ld a, (.dmark+2)  
a531 32 6d ee			ld (debug_mark+2),a  
a534 18 03			jr .pastdmark  
a536 ..			.dmark: db "PAU"  
a539 f1			.pastdmark: pop af  
a53a			endm  
# End of macro DMARK
a53a					CALLMONITOR 
a53a cd 6f ee			call debug_vector  
a53d				endm  
# End of macro CALLMONITOR
a53d				endif 
a53d c5			.pauses1:	push bc 
a53e cd fd 89			call delay1s 
a541 c1				pop bc 
a542				if DEBUG_FORTH_WORDS 
a542					DMARK "PA1" 
a542 f5				push af  
a543 3a 57 a5			ld a, (.dmark)  
a546 32 6b ee			ld (debug_mark),a  
a549 3a 58 a5			ld a, (.dmark+1)  
a54c 32 6c ee			ld (debug_mark+1),a  
a54f 3a 59 a5			ld a, (.dmark+2)  
a552 32 6d ee			ld (debug_mark+2),a  
a555 18 03			jr .pastdmark  
a557 ..			.dmark: db "PA1"  
a55a f1			.pastdmark: pop af  
a55b			endm  
# End of macro DMARK
a55b					CALLMONITOR 
a55b cd 6f ee			call debug_vector  
a55e				endm  
# End of macro CALLMONITOR
a55e				endif 
a55e 10 dd			djnz .pauses1 
a560			 
a560			       NEXTW 
a560 c3 29 9e			jp macro_next 
a563				endm 
# End of macro NEXTW
a563			.ROT: 
a563			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a563 45				db WORD_SYS_CORE+49             
a564 b1 a5			dw .UWORDS            
a566 04				db 3 + 1 
a567 .. 00			db "ROT",0              
a56b				endm 
# End of macro CWHEAD
a56b			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a56b				if DEBUG_FORTH_WORDS_KEY 
a56b					DMARK "ROT" 
a56b f5				push af  
a56c 3a 80 a5			ld a, (.dmark)  
a56f 32 6b ee			ld (debug_mark),a  
a572 3a 81 a5			ld a, (.dmark+1)  
a575 32 6c ee			ld (debug_mark+1),a  
a578 3a 82 a5			ld a, (.dmark+2)  
a57b 32 6d ee			ld (debug_mark+2),a  
a57e 18 03			jr .pastdmark  
a580 ..			.dmark: db "ROT"  
a583 f1			.pastdmark: pop af  
a584			endm  
# End of macro DMARK
a584					CALLMONITOR 
a584 cd 6f ee			call debug_vector  
a587				endm  
# End of macro CALLMONITOR
a587				endif 
a587			 
a587			; TODO Use os stack swap memory 
a587				FORTH_DSP_VALUEHL 
a587 cd 73 9c			call macro_dsp_valuehl 
a58a				endm 
# End of macro FORTH_DSP_VALUEHL
a58a e5				push hl    ; u3  
a58b			 
a58b				FORTH_DSP_POP 
a58b cd 2b 9d			call macro_forth_dsp_pop 
a58e				endm 
# End of macro FORTH_DSP_POP
a58e			 
a58e				FORTH_DSP_VALUEHL 
a58e cd 73 9c			call macro_dsp_valuehl 
a591				endm 
# End of macro FORTH_DSP_VALUEHL
a591 e5				push hl     ; u2 
a592			 
a592				FORTH_DSP_POP 
a592 cd 2b 9d			call macro_forth_dsp_pop 
a595				endm 
# End of macro FORTH_DSP_POP
a595			 
a595				FORTH_DSP_VALUEHL 
a595 cd 73 9c			call macro_dsp_valuehl 
a598				endm 
# End of macro FORTH_DSP_VALUEHL
a598 e5				push hl     ; u1 
a599			 
a599				FORTH_DSP_POP 
a599 cd 2b 9d			call macro_forth_dsp_pop 
a59c				endm 
# End of macro FORTH_DSP_POP
a59c			 
a59c c1				pop bc      ; u1 
a59d e1				pop hl      ; u2 
a59e d1				pop de      ; u3 
a59f			 
a59f			 
a59f c5				push bc 
a5a0 d5				push de 
a5a1 e5				push hl 
a5a2			 
a5a2			 
a5a2 e1				pop hl 
a5a3 cd 6e 9a			call forth_push_numhl 
a5a6			 
a5a6 e1				pop hl 
a5a7 cd 6e 9a			call forth_push_numhl 
a5aa			 
a5aa e1				pop hl 
a5ab cd 6e 9a			call forth_push_numhl 
a5ae				 
a5ae			 
a5ae			 
a5ae			 
a5ae			 
a5ae			 
a5ae			       NEXTW 
a5ae c3 29 9e			jp macro_next 
a5b1				endm 
# End of macro NEXTW
a5b1			 
a5b1			.UWORDS: 
a5b1			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a5b1 50				db WORD_SYS_CORE+60             
a5b2 73 a6			dw .BP            
a5b4 07				db 6 + 1 
a5b5 .. 00			db "UWORDS",0              
a5bc				endm 
# End of macro CWHEAD
a5bc			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a5bc			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a5bc			; | | Following the count are the individual words. 
a5bc			; | | 
a5bc			; | | e.g. UWORDS 
a5bc			; | | BOX DIRLIST 2 
a5bc			; | |  
a5bc			; | | Can be used to save the words to storage via: 
a5bc			; | | UWORDS $01 DO $01 APPEND LOOP 
a5bc			if DEBUG_FORTH_WORDS_KEY 
a5bc				DMARK "UWR" 
a5bc f5				push af  
a5bd 3a d1 a5			ld a, (.dmark)  
a5c0 32 6b ee			ld (debug_mark),a  
a5c3 3a d2 a5			ld a, (.dmark+1)  
a5c6 32 6c ee			ld (debug_mark+1),a  
a5c9 3a d3 a5			ld a, (.dmark+2)  
a5cc 32 6d ee			ld (debug_mark+2),a  
a5cf 18 03			jr .pastdmark  
a5d1 ..			.dmark: db "UWR"  
a5d4 f1			.pastdmark: pop af  
a5d5			endm  
# End of macro DMARK
a5d5				CALLMONITOR 
a5d5 cd 6f ee			call debug_vector  
a5d8				endm  
# End of macro CALLMONITOR
a5d8			endif 
a5d8 21 26 dd			ld hl, baseram 
a5db				;ld hl, baseusermem 
a5db 01 00 00			ld bc, 0    ; start a counter 
a5de			 
a5de			; skip dict stub 
a5de			 
a5de cd 7a 9f			call forth_tok_next 
a5e1			 
a5e1			 
a5e1			; while we have words to look for 
a5e1			 
a5e1 7e			.douscan:	ld a, (hl)      
a5e2			if DEBUG_FORTH_WORDS 
a5e2				DMARK "UWs" 
a5e2 f5				push af  
a5e3 3a f7 a5			ld a, (.dmark)  
a5e6 32 6b ee			ld (debug_mark),a  
a5e9 3a f8 a5			ld a, (.dmark+1)  
a5ec 32 6c ee			ld (debug_mark+1),a  
a5ef 3a f9 a5			ld a, (.dmark+2)  
a5f2 32 6d ee			ld (debug_mark+2),a  
a5f5 18 03			jr .pastdmark  
a5f7 ..			.dmark: db "UWs"  
a5fa f1			.pastdmark: pop af  
a5fb			endm  
# End of macro DMARK
a5fb				CALLMONITOR 
a5fb cd 6f ee			call debug_vector  
a5fe				endm  
# End of macro CALLMONITOR
a5fe			endif 
a5fe fe 00			cp WORD_SYS_END 
a600 28 4d			jr z, .udone 
a602 fe 01			cp WORD_SYS_UWORD 
a604 20 44			jr nz, .nuword 
a606			 
a606			if DEBUG_FORTH_WORDS 
a606				DMARK "UWu" 
a606 f5				push af  
a607 3a 1b a6			ld a, (.dmark)  
a60a 32 6b ee			ld (debug_mark),a  
a60d 3a 1c a6			ld a, (.dmark+1)  
a610 32 6c ee			ld (debug_mark+1),a  
a613 3a 1d a6			ld a, (.dmark+2)  
a616 32 6d ee			ld (debug_mark+2),a  
a619 18 03			jr .pastdmark  
a61b ..			.dmark: db "UWu"  
a61e f1			.pastdmark: pop af  
a61f			endm  
# End of macro DMARK
a61f				CALLMONITOR 
a61f cd 6f ee			call debug_vector  
a622				endm  
# End of macro CALLMONITOR
a622			endif 
a622				; we have a uword so push its name to the stack 
a622			 
a622 e5				push hl  ; save so we can move to next dict block 
a623			 
a623				; skip opcode 
a623 23				inc hl  
a624				; skip next ptr 
a624 23				inc hl  
a625 23				inc hl 
a626				; skip len 
a626 23				inc hl 
a627			if DEBUG_FORTH_WORDS 
a627				DMARK "UWt" 
a627 f5				push af  
a628 3a 3c a6			ld a, (.dmark)  
a62b 32 6b ee			ld (debug_mark),a  
a62e 3a 3d a6			ld a, (.dmark+1)  
a631 32 6c ee			ld (debug_mark+1),a  
a634 3a 3e a6			ld a, (.dmark+2)  
a637 32 6d ee			ld (debug_mark+2),a  
a63a 18 03			jr .pastdmark  
a63c ..			.dmark: db "UWt"  
a63f f1			.pastdmark: pop af  
a640			endm  
# End of macro DMARK
a640				CALLMONITOR 
a640 cd 6f ee			call debug_vector  
a643				endm  
# End of macro CALLMONITOR
a643			endif 
a643 03				inc bc 
a644			 
a644 c5				push bc 
a645 cd dc 9a			call forth_push_str 
a648 c1				pop bc 
a649			 
a649 e1				pop hl 	 
a64a			 
a64a cd 7a 9f		.nuword:	call forth_tok_next 
a64d 18 92			jr .douscan  
a64f			 
a64f			.udone:		 ; push count of uwords found 
a64f c5				push bc 
a650 e1				pop hl 
a651			 
a651			if DEBUG_FORTH_WORDS 
a651				DMARK "UWc" 
a651 f5				push af  
a652 3a 66 a6			ld a, (.dmark)  
a655 32 6b ee			ld (debug_mark),a  
a658 3a 67 a6			ld a, (.dmark+1)  
a65b 32 6c ee			ld (debug_mark+1),a  
a65e 3a 68 a6			ld a, (.dmark+2)  
a661 32 6d ee			ld (debug_mark+2),a  
a664 18 03			jr .pastdmark  
a666 ..			.dmark: db "UWc"  
a669 f1			.pastdmark: pop af  
a66a			endm  
# End of macro DMARK
a66a				CALLMONITOR 
a66a cd 6f ee			call debug_vector  
a66d				endm  
# End of macro CALLMONITOR
a66d			endif 
a66d cd 6e 9a			call forth_push_numhl 
a670			 
a670			 
a670			       NEXTW 
a670 c3 29 9e			jp macro_next 
a673				endm 
# End of macro NEXTW
a673			 
a673			.BP: 
a673			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a673 54				db WORD_SYS_CORE+64             
a674 ad a6			dw .MONITOR            
a676 03				db 2 + 1 
a677 .. 00			db "BP",0              
a67a				endm 
# End of macro CWHEAD
a67a			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a67a			; | | $00 Will enable the break points within specific code paths 
a67a			; | | $01 Will disable break points 
a67a			; | |  
a67a			; | | By default break points are off. Either the above can be used to enable them 
a67a			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a67a			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
a67a			; | | can disable break points. Exiting will then continue boot process. 
a67a				; get byte count 
a67a				if DEBUG_FORTH_WORDS_KEY 
a67a					DMARK "BP." 
a67a f5				push af  
a67b 3a 8f a6			ld a, (.dmark)  
a67e 32 6b ee			ld (debug_mark),a  
a681 3a 90 a6			ld a, (.dmark+1)  
a684 32 6c ee			ld (debug_mark+1),a  
a687 3a 91 a6			ld a, (.dmark+2)  
a68a 32 6d ee			ld (debug_mark+2),a  
a68d 18 03			jr .pastdmark  
a68f ..			.dmark: db "BP."  
a692 f1			.pastdmark: pop af  
a693			endm  
# End of macro DMARK
a693					CALLMONITOR 
a693 cd 6f ee			call debug_vector  
a696				endm  
# End of macro CALLMONITOR
a696				endif 
a696			 
a696				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a696 cd 73 9c			call macro_dsp_valuehl 
a699				endm 
# End of macro FORTH_DSP_VALUEHL
a699			 
a699			;		push hl 
a699			 
a699				; destroy value TOS 
a699			 
a699				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a699 cd 2b 9d			call macro_forth_dsp_pop 
a69c				endm 
# End of macro FORTH_DSP_POP
a69c			 
a69c			;		pop hl 
a69c			 
a69c 3e 00			ld a,0 
a69e bd				cp l 
a69f 28 06			jr z, .bpset 
a6a1			;		ld a, '*' 
a6a1 cd fd 93			call bp_off 
a6a4				NEXTW 
a6a4 c3 29 9e			jp macro_next 
a6a7				endm 
# End of macro NEXTW
a6a7			 
a6a7			.bpset:	 
a6a7				;	ld (os_view_disable), a 
a6a7 cd f1 93			call bp_on 
a6aa			 
a6aa			 
a6aa				NEXTW 
a6aa c3 29 9e			jp macro_next 
a6ad				endm 
# End of macro NEXTW
a6ad			 
a6ad			 
a6ad			.MONITOR: 
a6ad			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a6ad 55				db WORD_SYS_CORE+65             
a6ae de a6			dw .MALLOC            
a6b0 08				db 7 + 1 
a6b1 .. 00			db "MONITOR",0              
a6b9				endm 
# End of macro CWHEAD
a6b9			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a6b9			; | | At start the current various registers will be displayed with contents. 
a6b9			; | | Top right corner will show the most recent debug marker seen. 
a6b9			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a6b9			; | | and the return stack pointer (RSP). 
a6b9			; | | Pressing: 
a6b9			; | |    1 - Initial screen 
a6b9			; | |    2 - Display a data dump of HL 
a6b9			; | |    3 - Display a data dump of DE 
a6b9			; | |    4 - Display a data dump of BC 
a6b9			; | |    5 - Display a data dump of HL 
a6b9			; | |    6 - Display a data dump of DSP 
a6b9			; | |    7 - Display a data dump of RSP 
a6b9			; | |    8 - Display a data dump of what is at DSP 
a6b9			; | |    9 - Display a data dump of what is at RSP 
a6b9			; | |    0 - Exit monitor and continue running. This will also enable break points 
a6b9			; | |    * - Disable break points 
a6b9			; | |    # - Enter traditional monitor mode 
a6b9			; | | 
a6b9			; | | Monitor Mode 
a6b9			; | | ------------ 
a6b9			; | | A prompt of '>' will be shown for various commands: 
a6b9			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a6b9			; | |    C - Continue display a data dump from the last set address 
a6b9			; | |    M xxxx - Set start of memory edit at address xx 
a6b9			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a6b9			; | |    G xxxx - Exec code at specific address 
a6b9			; | |    Q - Return to previous 
a6b9				if DEBUG_FORTH_WORDS_KEY 
a6b9					DMARK "MON" 
a6b9 f5				push af  
a6ba 3a ce a6			ld a, (.dmark)  
a6bd 32 6b ee			ld (debug_mark),a  
a6c0 3a cf a6			ld a, (.dmark+1)  
a6c3 32 6c ee			ld (debug_mark+1),a  
a6c6 3a d0 a6			ld a, (.dmark+2)  
a6c9 32 6d ee			ld (debug_mark+2),a  
a6cc 18 03			jr .pastdmark  
a6ce ..			.dmark: db "MON"  
a6d1 f1			.pastdmark: pop af  
a6d2			endm  
# End of macro DMARK
a6d2					CALLMONITOR 
a6d2 cd 6f ee			call debug_vector  
a6d5				endm  
# End of macro CALLMONITOR
a6d5				endif 
a6d5			;		ld a, 0 
a6d5			;		ld (os_view_disable), a 
a6d5 cd f1 93			call bp_on 
a6d8			 
a6d8				CALLMONITOR 
a6d8 cd 6f ee			call debug_vector  
a6db				endm  
# End of macro CALLMONITOR
a6db			 
a6db			;	call monitor 
a6db			 
a6db				NEXTW 
a6db c3 29 9e			jp macro_next 
a6de				endm 
# End of macro NEXTW
a6de			 
a6de			 
a6de			.MALLOC: 
a6de			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a6de 56				db WORD_SYS_CORE+66             
a6df 07 a7			dw .MALLOC2            
a6e1 06				db 5 + 1 
a6e2 .. 00			db "ALLOT",0              
a6e8				endm 
# End of macro CWHEAD
a6e8			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a6e8				if DEBUG_FORTH_WORDS_KEY 
a6e8					DMARK "ALL" 
a6e8 f5				push af  
a6e9 3a fd a6			ld a, (.dmark)  
a6ec 32 6b ee			ld (debug_mark),a  
a6ef 3a fe a6			ld a, (.dmark+1)  
a6f2 32 6c ee			ld (debug_mark+1),a  
a6f5 3a ff a6			ld a, (.dmark+2)  
a6f8 32 6d ee			ld (debug_mark+2),a  
a6fb 18 03			jr .pastdmark  
a6fd ..			.dmark: db "ALL"  
a700 f1			.pastdmark: pop af  
a701			endm  
# End of macro DMARK
a701					CALLMONITOR 
a701 cd 6f ee			call debug_vector  
a704				endm  
# End of macro CALLMONITOR
a704				endif 
a704 c3 2e a7			jp .mallocc 
a707			.MALLOC2: 
a707			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a707 56				db WORD_SYS_CORE+66             
a708 45 a7			dw .FREE            
a70a 07				db 6 + 1 
a70b .. 00			db "MALLOC",0              
a712				endm 
# End of macro CWHEAD
a712			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a712				; get byte count 
a712				if DEBUG_FORTH_WORDS_KEY 
a712					DMARK "MAL" 
a712 f5				push af  
a713 3a 27 a7			ld a, (.dmark)  
a716 32 6b ee			ld (debug_mark),a  
a719 3a 28 a7			ld a, (.dmark+1)  
a71c 32 6c ee			ld (debug_mark+1),a  
a71f 3a 29 a7			ld a, (.dmark+2)  
a722 32 6d ee			ld (debug_mark+2),a  
a725 18 03			jr .pastdmark  
a727 ..			.dmark: db "MAL"  
a72a f1			.pastdmark: pop af  
a72b			endm  
# End of macro DMARK
a72b					CALLMONITOR 
a72b cd 6f ee			call debug_vector  
a72e				endm  
# End of macro CALLMONITOR
a72e				endif 
a72e			.mallocc: 
a72e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a72e cd 73 9c			call macro_dsp_valuehl 
a731				endm 
# End of macro FORTH_DSP_VALUEHL
a731			 
a731			;		push hl 
a731			 
a731				; destroy value TOS 
a731			 
a731				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a731 cd 2b 9d			call macro_forth_dsp_pop 
a734				endm 
# End of macro FORTH_DSP_POP
a734			 
a734			;		pop hl 
a734 cd c2 90			call malloc 
a737			if DEBUG_FORTH_MALLOC_GUARD 
a737 f5				push af 
a738 cd 10 8d			call ishlzero 
a73b			;		ld a, l 
a73b			;		add h 
a73b			;		cp 0 
a73b f1				pop af 
a73c				 
a73c cc e9 cb			call z,malloc_error 
a73f			endif 
a73f			 
a73f cd 6e 9a			call forth_push_numhl 
a742				NEXTW 
a742 c3 29 9e			jp macro_next 
a745				endm 
# End of macro NEXTW
a745			 
a745			.FREE: 
a745			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a745 57				db WORD_SYS_CORE+67             
a746 76 a7			dw .LIST            
a748 05				db 4 + 1 
a749 .. 00			db "FREE",0              
a74e				endm 
# End of macro CWHEAD
a74e			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a74e				if DEBUG_FORTH_WORDS_KEY 
a74e					DMARK "FRE" 
a74e f5				push af  
a74f 3a 63 a7			ld a, (.dmark)  
a752 32 6b ee			ld (debug_mark),a  
a755 3a 64 a7			ld a, (.dmark+1)  
a758 32 6c ee			ld (debug_mark+1),a  
a75b 3a 65 a7			ld a, (.dmark+2)  
a75e 32 6d ee			ld (debug_mark+2),a  
a761 18 03			jr .pastdmark  
a763 ..			.dmark: db "FRE"  
a766 f1			.pastdmark: pop af  
a767			endm  
# End of macro DMARK
a767					CALLMONITOR 
a767 cd 6f ee			call debug_vector  
a76a				endm  
# End of macro CALLMONITOR
a76a				endif 
a76a				; get address 
a76a			 
a76a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a76a cd 73 9c			call macro_dsp_valuehl 
a76d				endm 
# End of macro FORTH_DSP_VALUEHL
a76d			 
a76d			;		push hl 
a76d			 
a76d				; destroy value TOS 
a76d			 
a76d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a76d cd 2b 9d			call macro_forth_dsp_pop 
a770				endm 
# End of macro FORTH_DSP_POP
a770			 
a770			;		pop hl 
a770			if FORTH_ENABLE_MALLOCFREE 
a770 cd 8c 91			call free 
a773			endif 
a773				NEXTW 
a773 c3 29 9e			jp macro_next 
a776				endm 
# End of macro NEXTW
a776			.LIST: 
a776			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a776 5c				db WORD_SYS_CORE+72             
a777 66 a9			dw .FORGET            
a779 05				db 4 + 1 
a77a .. 00			db "LIST",0              
a77f				endm 
# End of macro CWHEAD
a77f			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a77f			; | | The quoted word must be in upper case. 
a77f			if DEBUG_FORTH_WORDS_KEY 
a77f				DMARK "LST" 
a77f f5				push af  
a780 3a 94 a7			ld a, (.dmark)  
a783 32 6b ee			ld (debug_mark),a  
a786 3a 95 a7			ld a, (.dmark+1)  
a789 32 6c ee			ld (debug_mark+1),a  
a78c 3a 96 a7			ld a, (.dmark+2)  
a78f 32 6d ee			ld (debug_mark+2),a  
a792 18 03			jr .pastdmark  
a794 ..			.dmark: db "LST"  
a797 f1			.pastdmark: pop af  
a798			endm  
# End of macro DMARK
a798				CALLMONITOR 
a798 cd 6f ee			call debug_vector  
a79b				endm  
# End of macro CALLMONITOR
a79b			endif 
a79b			 
a79b				FORTH_DSP_VALUEHL 
a79b cd 73 9c			call macro_dsp_valuehl 
a79e				endm 
# End of macro FORTH_DSP_VALUEHL
a79e			 
a79e e5				push hl 
a79f				FORTH_DSP_POP 
a79f cd 2b 9d			call macro_forth_dsp_pop 
a7a2				endm 
# End of macro FORTH_DSP_POP
a7a2 c1				pop bc 
a7a3			 
a7a3			; Start format of scratch string 
a7a3			 
a7a3 21 c1 e2			ld hl, scratch 
a7a6			 
a7a6 3e 3a			ld a, ':' 
a7a8 77				ld (hl),a 
a7a9 23				inc hl 
a7aa 3e 20			ld a, ' ' 
a7ac 77				ld (hl), a 
a7ad			 
a7ad				; Get ptr to the word we need to look up 
a7ad			 
a7ad			;		FORTH_DSP_VALUEHL 
a7ad				;v5 FORTH_DSP_VALUE 
a7ad			; TODO type check 
a7ad			;		inc hl    ; Skip type check  
a7ad			;		push hl 
a7ad			;		ex de, hl    ; put into DE 
a7ad			 
a7ad			 
a7ad 21 26 dd			ld hl, baseram 
a7b0				;ld hl, baseusermem 
a7b0			 
a7b0 e5			push hl   ; sacreifical push 
a7b1			 
a7b1			.ldouscanm: 
a7b1 e1			pop hl 
a7b2			.ldouscan: 
a7b2			if DEBUG_FORTH_WORDS 
a7b2				DMARK "LSs" 
a7b2 f5				push af  
a7b3 3a c7 a7			ld a, (.dmark)  
a7b6 32 6b ee			ld (debug_mark),a  
a7b9 3a c8 a7			ld a, (.dmark+1)  
a7bc 32 6c ee			ld (debug_mark+1),a  
a7bf 3a c9 a7			ld a, (.dmark+2)  
a7c2 32 6d ee			ld (debug_mark+2),a  
a7c5 18 03			jr .pastdmark  
a7c7 ..			.dmark: db "LSs"  
a7ca f1			.pastdmark: pop af  
a7cb			endm  
# End of macro DMARK
a7cb				CALLMONITOR 
a7cb cd 6f ee			call debug_vector  
a7ce				endm  
# End of macro CALLMONITOR
a7ce			endif 
a7ce			; skip dict stub 
a7ce cd 7a 9f			call forth_tok_next 
a7d1			 
a7d1			 
a7d1			; while we have words to look for 
a7d1			 
a7d1 7e			ld a, (hl)      
a7d2			if DEBUG_FORTH_WORDS 
a7d2				DMARK "LSk" 
a7d2 f5				push af  
a7d3 3a e7 a7			ld a, (.dmark)  
a7d6 32 6b ee			ld (debug_mark),a  
a7d9 3a e8 a7			ld a, (.dmark+1)  
a7dc 32 6c ee			ld (debug_mark+1),a  
a7df 3a e9 a7			ld a, (.dmark+2)  
a7e2 32 6d ee			ld (debug_mark+2),a  
a7e5 18 03			jr .pastdmark  
a7e7 ..			.dmark: db "LSk"  
a7ea f1			.pastdmark: pop af  
a7eb			endm  
# End of macro DMARK
a7eb				CALLMONITOR 
a7eb cd 6f ee			call debug_vector  
a7ee				endm  
# End of macro CALLMONITOR
a7ee			endif 
a7ee				;cp WORD_SYS_END 
a7ee				;jp z, .lunotfound 
a7ee			 
a7ee					; if we hit non uwords then gone too far 
a7ee fe 01				cp WORD_SYS_UWORD 
a7f0 c2 22 a9				jp nz, .lunotfound 
a7f3			 
a7f3				if DEBUG_FORTH_WORDS 
a7f3					DMARK "LSu" 
a7f3 f5				push af  
a7f4 3a 08 a8			ld a, (.dmark)  
a7f7 32 6b ee			ld (debug_mark),a  
a7fa 3a 09 a8			ld a, (.dmark+1)  
a7fd 32 6c ee			ld (debug_mark+1),a  
a800 3a 0a a8			ld a, (.dmark+2)  
a803 32 6d ee			ld (debug_mark+2),a  
a806 18 03			jr .pastdmark  
a808 ..			.dmark: db "LSu"  
a80b f1			.pastdmark: pop af  
a80c			endm  
# End of macro DMARK
a80c					CALLMONITOR 
a80c cd 6f ee			call debug_vector  
a80f				endm  
# End of macro CALLMONITOR
a80f				endif 
a80f			 
a80f					; found a uword but is it the one we want... 
a80f			 
a80f c5					push bc     ; uword to find is on bc 
a810 d1					pop de 
a811			 
a811 e5					push hl  ; to save the ptr 
a812			 
a812					; skip opcode 
a812 23					inc hl  
a813					; skip next ptr 
a813 23					inc hl  
a814 23					inc hl 
a815					; skip len 
a815 23					inc hl 
a816			 
a816				if DEBUG_FORTH_WORDS 
a816					DMARK "LSc" 
a816 f5				push af  
a817 3a 2b a8			ld a, (.dmark)  
a81a 32 6b ee			ld (debug_mark),a  
a81d 3a 2c a8			ld a, (.dmark+1)  
a820 32 6c ee			ld (debug_mark+1),a  
a823 3a 2d a8			ld a, (.dmark+2)  
a826 32 6d ee			ld (debug_mark+2),a  
a829 18 03			jr .pastdmark  
a82b ..			.dmark: db "LSc"  
a82e f1			.pastdmark: pop af  
a82f			endm  
# End of macro DMARK
a82f					CALLMONITOR 
a82f cd 6f ee			call debug_vector  
a832				endm  
# End of macro CALLMONITOR
a832				endif 
a832			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
a832			; ie. If WOO is defined first and then WO. Couldnt list WO. 
a832			; Nope that has gone the other way. It needs to be exact not on first zero 
a832			;		call strcmp 
a832 c5					push bc 
a833 cd 92 90				call StrictStrCmp 
a836 c1					pop bc 
a837 c2 b1 a7				jp nz, .ldouscanm 
a83a				 
a83a			 
a83a			 
a83a					; we have a uword so push its name to the stack 
a83a			 
a83a			;	   	push hl  ; save so we can move to next dict block 
a83a e1			pop hl 
a83b			 
a83b				if DEBUG_FORTH_WORDS 
a83b					DMARK "LSm" 
a83b f5				push af  
a83c 3a 50 a8			ld a, (.dmark)  
a83f 32 6b ee			ld (debug_mark),a  
a842 3a 51 a8			ld a, (.dmark+1)  
a845 32 6c ee			ld (debug_mark+1),a  
a848 3a 52 a8			ld a, (.dmark+2)  
a84b 32 6d ee			ld (debug_mark+2),a  
a84e 18 03			jr .pastdmark  
a850 ..			.dmark: db "LSm"  
a853 f1			.pastdmark: pop af  
a854			endm  
# End of macro DMARK
a854					CALLMONITOR 
a854 cd 6f ee			call debug_vector  
a857				endm  
# End of macro CALLMONITOR
a857				endif 
a857			 
a857					; skip opcode 
a857 23					inc hl  
a858					; skip next ptr 
a858 23					inc hl  
a859 23					inc hl 
a85a					; skip len 
a85a 7e					ld a, (hl)   ; save length to add 
a85b				if DEBUG_FORTH_WORDS 
a85b					DMARK "LS2" 
a85b f5				push af  
a85c 3a 70 a8			ld a, (.dmark)  
a85f 32 6b ee			ld (debug_mark),a  
a862 3a 71 a8			ld a, (.dmark+1)  
a865 32 6c ee			ld (debug_mark+1),a  
a868 3a 72 a8			ld a, (.dmark+2)  
a86b 32 6d ee			ld (debug_mark+2),a  
a86e 18 03			jr .pastdmark  
a870 ..			.dmark: db "LS2"  
a873 f1			.pastdmark: pop af  
a874			endm  
# End of macro DMARK
a874					CALLMONITOR 
a874 cd 6f ee			call debug_vector  
a877				endm  
# End of macro CALLMONITOR
a877				endif 
a877			 
a877					; save this location 
a877				 
a877 e5					push hl 
a878			 
a878 23					inc hl 
a879 11 c3 e2				ld de, scratch+2 
a87c 4f					ld c, a 
a87d 06 00				ld b, 0 
a87f			 
a87f				if DEBUG_FORTH_WORDS 
a87f					DMARK "LSn" 
a87f f5				push af  
a880 3a 94 a8			ld a, (.dmark)  
a883 32 6b ee			ld (debug_mark),a  
a886 3a 95 a8			ld a, (.dmark+1)  
a889 32 6c ee			ld (debug_mark+1),a  
a88c 3a 96 a8			ld a, (.dmark+2)  
a88f 32 6d ee			ld (debug_mark+2),a  
a892 18 03			jr .pastdmark  
a894 ..			.dmark: db "LSn"  
a897 f1			.pastdmark: pop af  
a898			endm  
# End of macro DMARK
a898					CALLMONITOR 
a898 cd 6f ee			call debug_vector  
a89b				endm  
# End of macro CALLMONITOR
a89b				endif 
a89b			 
a89b					; copy uword name to scratch 
a89b			 
a89b ed b0				ldir 
a89d			 
a89d 1b					dec de 
a89e 3e 20				ld a, ' '    ; change null to space 
a8a0 12					ld (de), a 
a8a1			 
a8a1 13					inc de 
a8a2			 
a8a2 d5					push de 
a8a3 c1					pop bc     ; move scratch pointer to end of word name and save it 
a8a4			 
a8a4 e1					pop hl 
a8a5 7e					ld a, (hl) 
a8a6					;inc hl 
a8a6					; skip word string 
a8a6 cd e7 8c				call addatohl 
a8a9			 
a8a9 23					inc hl 
a8aa			 
a8aa				if DEBUG_FORTH_WORDS 
a8aa					DMARK "LS3" 
a8aa f5				push af  
a8ab 3a bf a8			ld a, (.dmark)  
a8ae 32 6b ee			ld (debug_mark),a  
a8b1 3a c0 a8			ld a, (.dmark+1)  
a8b4 32 6c ee			ld (debug_mark+1),a  
a8b7 3a c1 a8			ld a, (.dmark+2)  
a8ba 32 6d ee			ld (debug_mark+2),a  
a8bd 18 03			jr .pastdmark  
a8bf ..			.dmark: db "LS3"  
a8c2 f1			.pastdmark: pop af  
a8c3			endm  
# End of macro DMARK
a8c3					CALLMONITOR 
a8c3 cd 6f ee			call debug_vector  
a8c6				endm  
# End of macro CALLMONITOR
a8c6				endif 
a8c6					; should now be at the start of the machine code to setup the eval of the uword 
a8c6					; now locate the ptr to the string defintion 
a8c6			 
a8c6					; skip ld hl, 
a8c6					; then load the ptr 
a8c6			; TODO use get from hl ptr 
a8c6 23					inc hl 
a8c7 5e					ld e, (hl) 
a8c8 23					inc hl 
a8c9 56					ld d, (hl) 
a8ca eb					ex de, hl 
a8cb			 
a8cb			 
a8cb				if DEBUG_FORTH_WORDS 
a8cb					DMARK "LSt" 
a8cb f5				push af  
a8cc 3a e0 a8			ld a, (.dmark)  
a8cf 32 6b ee			ld (debug_mark),a  
a8d2 3a e1 a8			ld a, (.dmark+1)  
a8d5 32 6c ee			ld (debug_mark+1),a  
a8d8 3a e2 a8			ld a, (.dmark+2)  
a8db 32 6d ee			ld (debug_mark+2),a  
a8de 18 03			jr .pastdmark  
a8e0 ..			.dmark: db "LSt"  
a8e3 f1			.pastdmark: pop af  
a8e4			endm  
# End of macro DMARK
a8e4					CALLMONITOR 
a8e4 cd 6f ee			call debug_vector  
a8e7				endm  
# End of macro CALLMONITOR
a8e7				endif 
a8e7			 
a8e7			; cant push right now due to tokenised strings  
a8e7			 
a8e7			; get the destination of where to copy this definition to. 
a8e7			 
a8e7 c5					push bc 
a8e8 d1					pop de 
a8e9			 
a8e9 7e			.listl:         ld a,(hl) 
a8ea fe 00				cp 0 
a8ec 28 09				jr z, .lreplsp     ; replace zero with space 
a8ee					;cp FORTH_END_BUFFER 
a8ee fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a8f0 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a8f2				 
a8f2					; just copy this char as is then 
a8f2			 
a8f2 12					ld (de), a 
a8f3			 
a8f3 23			.listnxt:	inc hl 
a8f4 13					inc de 
a8f5 18 f2				jr .listl 
a8f7			 
a8f7 3e 20		.lreplsp:	ld a,' ' 
a8f9 12					ld (de), a 
a8fa 18 f7				jr .listnxt 
a8fc			 
a8fc			; close up uword def 
a8fc			 
a8fc			.listdone: 
a8fc 12					ld (de), a 
a8fd 13					inc de 
a8fe 3e 00				ld a, 0 
a900 12					ld (de), a 
a901			 
a901			; now have def so clean up and push to stack 
a901			 
a901 21 c1 e2				ld hl, scratch 
a904				if DEBUG_FORTH_WORDS 
a904					DMARK "Ltp" 
a904 f5				push af  
a905 3a 19 a9			ld a, (.dmark)  
a908 32 6b ee			ld (debug_mark),a  
a90b 3a 1a a9			ld a, (.dmark+1)  
a90e 32 6c ee			ld (debug_mark+1),a  
a911 3a 1b a9			ld a, (.dmark+2)  
a914 32 6d ee			ld (debug_mark+2),a  
a917 18 03			jr .pastdmark  
a919 ..			.dmark: db "Ltp"  
a91c f1			.pastdmark: pop af  
a91d			endm  
# End of macro DMARK
a91d					CALLMONITOR 
a91d cd 6f ee			call debug_vector  
a920				endm  
# End of macro CALLMONITOR
a920				endif 
a920			 
a920 18 1f			jr .listpush 
a922			 
a922			;.lnuword:	pop hl 
a922			;		call forth_tok_next 
a922			;		jp .ldouscan  
a922			 
a922			.lunotfound:		  
a922			 
a922				if DEBUG_FORTH_WORDS 
a922					DMARK "LSn" 
a922 f5				push af  
a923 3a 37 a9			ld a, (.dmark)  
a926 32 6b ee			ld (debug_mark),a  
a929 3a 38 a9			ld a, (.dmark+1)  
a92c 32 6c ee			ld (debug_mark+1),a  
a92f 3a 39 a9			ld a, (.dmark+2)  
a932 32 6d ee			ld (debug_mark+2),a  
a935 18 03			jr .pastdmark  
a937 ..			.dmark: db "LSn"  
a93a f1			.pastdmark: pop af  
a93b			endm  
# End of macro DMARK
a93b					CALLMONITOR 
a93b cd 6f ee			call debug_vector  
a93e				endm  
# End of macro CALLMONITOR
a93e				endif 
a93e			 
a93e					 
a93e			;		FORTH_DSP_POP 
a93e			;		ld hl, .luno 
a93e			 
a93e					NEXTW			 
a93e c3 29 9e			jp macro_next 
a941				endm 
# End of macro NEXTW
a941			 
a941			.listpush: 
a941				if DEBUG_FORTH_WORDS 
a941					DMARK "LS>" 
a941 f5				push af  
a942 3a 56 a9			ld a, (.dmark)  
a945 32 6b ee			ld (debug_mark),a  
a948 3a 57 a9			ld a, (.dmark+1)  
a94b 32 6c ee			ld (debug_mark+1),a  
a94e 3a 58 a9			ld a, (.dmark+2)  
a951 32 6d ee			ld (debug_mark+2),a  
a954 18 03			jr .pastdmark  
a956 ..			.dmark: db "LS>"  
a959 f1			.pastdmark: pop af  
a95a			endm  
# End of macro DMARK
a95a					CALLMONITOR 
a95a cd 6f ee			call debug_vector  
a95d				endm  
# End of macro CALLMONITOR
a95d				endif 
a95d cd dc 9a				call forth_push_str 
a960			 
a960			 
a960			 
a960					NEXTW 
a960 c3 29 9e			jp macro_next 
a963				endm 
# End of macro NEXTW
a963			 
a963			;.luno:    db "Word not found",0 
a963			 
a963			 
a963			 
a963			 
a963			 
a963			;		push hl   ; save pointer to start of uword def string 
a963			; 
a963			;; look for FORTH_EOL_LINE 
a963			;		ld a, FORTH_END_BUFFER 
a963			;		call strlent 
a963			; 
a963			;		inc hl		 ; space for coln def 
a963			;		inc hl 
a963			;		inc hl          ; space for terms 
a963			;		inc hl 
a963			; 
a963			;		ld a, 20   ; TODO get actual length 
a963			;		call addatohl    ; include a random amount of room for the uword name 
a963			; 
a963			;		 
a963			;	if DEBUG_FORTH_WORDS 
a963			;		DMARK "Lt1" 
a963			;		CALLMONITOR 
a963			;	endif 
a963			;		 
a963			; 
a963			;; malloc space for the string because we cant change it 
a963			; 
a963			;		call malloc 
a963			;	if DEBUG_FORTH_MALLOC_GUARD 
a963			;		push af 
a963			;		call ishlzero 
a963			;		pop af 
a963			;		 
a963			;		call z,malloc_error 
a963			;	endif 
a963			; 
a963			;	if DEBUG_FORTH_WORDS 
a963			;		DMARK "Lt2" 
a963			;		CALLMONITOR 
a963			;	endif 
a963			;		pop de 
a963			;		push hl    ; push the malloc to release later 
a963			;		push hl   ;  push back a copy for the later stack push 
a963			;		 
a963			;; copy the string swapping out the zero terms for spaces 
a963			; 
a963			;		; de has our source 
a963			;		; hl has our dest 
a963			; 
a963			;; add the coln def 
a963			; 
a963			;		ld a, ':' 
a963			;		ld (hl), a 
a963			;		inc hl 
a963			;		ld a, ' ' 
a963			;		ld (hl), a 
a963			;		inc hl 
a963			; 
a963			;; add the uname word 
a963			;		push de   ; save our string for now 
a963			;		ex de, hl 
a963			; 
a963			;		FORTH_DSP_VALUE 
a963			;		;v5 FORTH_DSP_VALUE 
a963			; 
a963			;		inc hl   ; skip type but we know by now this is OK 
a963			; 
a963			;.luword:	ld a,(hl) 
a963			;		cp 0 
a963			;		jr z, .luword2 
a963			;		ld (de), a 
a963			;		inc de 
a963			;		inc hl 
a963			;		jr .luword 
a963			; 
a963			;.luword2:	ld a, ' ' 
a963			;		ld (de), a 
a963			;;		inc hl 
a963			;;		inc de 
a963			;;		ld (de), a 
a963			;;		inc hl 
a963			;		inc de 
a963			; 
a963			;		ex de, hl 
a963			;		pop de 
a963			;		 
a963			;		 
a963			; 
a963			;; detoken that string and copy it 
a963			; 
a963			;	if DEBUG_FORTH_WORDS 
a963			;		DMARK "Lt2" 
a963			;		CALLMONITOR 
a963			;	endif 
a963			;.ldetok:	ld a, (de) 
a963			;		cp FORTH_END_BUFFER 
a963			;		jr z, .ldetokend 
a963			;		; swap out any zero term for space 
a963			;		cp 0 
a963			;		jr nz, .ldetoknext 
a963			;		ld a, ' ' 
a963			; 
a963			;	if DEBUG_FORTH_WORDS 
a963			;		DMARK "LtS" 
a963			;		CALLMONITOR 
a963			;	endif 
a963			;.ldetoknext:	ld (hl), a 
a963			;		inc de 
a963			;		inc hl 
a963			;		jr .ldetok 
a963			; 
a963			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a963			;		ld (hl), a  
a963			; 
a963			;; free that temp malloc 
a963			; 
a963			;		pop hl    
a963			; 
a963			;	if DEBUG_FORTH_WORDS 
a963			;		DMARK "Lt4" 
a963			;		CALLMONITOR 
a963			;	endif 
a963			;		call forth_apushstrhl 
a963			; 
a963			;		; get rid of temp malloc area 
a963			; 
a963			;		pop hl 
a963			;		call free 
a963			; 
a963			;		jr .ludone 
a963			; 
a963			;.lnuword:	pop hl 
a963			;		call forth_tok_next 
a963			;		jp .ldouscan  
a963			; 
a963			;.ludone:		 pop hl 
a963			; 
a963					NEXTW 
a963 c3 29 9e			jp macro_next 
a966				endm 
# End of macro NEXTW
a966			 
a966			.FORGET: 
a966				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a966 5d				db WORD_SYS_CORE+73             
a967 df a9			dw .NOP            
a969 07				db 6 + 1 
a96a .. 00			db "FORGET",0              
a971				endm 
# End of macro CWHEAD
a971			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a971			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
a971			; | |  
a971			; | | e.g. "MORE" forget 
a971					if DEBUG_FORTH_WORDS_KEY 
a971						DMARK "FRG" 
a971 f5				push af  
a972 3a 86 a9			ld a, (.dmark)  
a975 32 6b ee			ld (debug_mark),a  
a978 3a 87 a9			ld a, (.dmark+1)  
a97b 32 6c ee			ld (debug_mark+1),a  
a97e 3a 88 a9			ld a, (.dmark+2)  
a981 32 6d ee			ld (debug_mark+2),a  
a984 18 03			jr .pastdmark  
a986 ..			.dmark: db "FRG"  
a989 f1			.pastdmark: pop af  
a98a			endm  
# End of macro DMARK
a98a						CALLMONITOR 
a98a cd 6f ee			call debug_vector  
a98d				endm  
# End of macro CALLMONITOR
a98d					endif 
a98d			 
a98d				; find uword 
a98d			        ; update start of word with "_" 
a98d				; replace uword with deleted flag 
a98d			 
a98d			 
a98d			;	if DEBUG_FORTH_WORDS 
a98d			;		DMARK "FOG" 
a98d			;		CALLMONITOR 
a98d			;	endif 
a98d			 
a98d			 
a98d					; Get ptr to the word we need to look up 
a98d			 
a98d					FORTH_DSP_VALUEHL 
a98d cd 73 9c			call macro_dsp_valuehl 
a990				endm 
# End of macro FORTH_DSP_VALUEHL
a990					;v5 FORTH_DSP_VALUE 
a990				; TODO type check 
a990			;		inc hl    ; Skip type check  
a990 e5					push hl 
a991 c1					pop bc 
a992			;		ex de, hl    ; put into DE 
a992			 
a992			 
a992 21 26 dd				ld hl, baseram 
a995					;ld hl, baseusermem 
a995			 
a995				; skip dict stub 
a995			;	call forth_tok_next 
a995 e5			push hl   ; sacreifical push 
a996			 
a996			.fldouscanm: 
a996 e1				pop hl 
a997			.fldouscan: 
a997			;	if DEBUG_FORTH_WORDS 
a997			;		DMARK "LSs" 
a997			;		CALLMONITOR 
a997			;	endif 
a997				; skip dict stub 
a997 cd 7a 9f				call forth_tok_next 
a99a			 
a99a			 
a99a			; while we have words to look for 
a99a			 
a99a 7e				ld a, (hl)      
a99b			;	if DEBUG_FORTH_WORDS 
a99b			;		DMARK "LSk" 
a99b			;		CALLMONITOR 
a99b			;	endif 
a99b fe 00				cp WORD_SYS_END 
a99d ca d9 a9				jp z, .flunotfound 
a9a0 fe 01				cp WORD_SYS_UWORD 
a9a2 c2 97 a9				jp nz, .fldouscan 
a9a5			 
a9a5			;	if DEBUG_FORTH_WORDS 
a9a5			;		DMARK "LSu" 
a9a5			;		CALLMONITOR 
a9a5			;	endif 
a9a5			 
a9a5					; found a uword but is it the one we want... 
a9a5			 
a9a5 c5					push bc     ; uword to find is on bc 
a9a6 d1					pop de 
a9a7			 
a9a7 e5					push hl  ; to save the ptr 
a9a8			 
a9a8					; skip opcode 
a9a8 23					inc hl  
a9a9					; skip next ptr 
a9a9 23					inc hl  
a9aa 23					inc hl 
a9ab					; skip len 
a9ab 23					inc hl 
a9ac			 
a9ac			;	if DEBUG_FORTH_WORDS 
a9ac			;		DMARK "LSc" 
a9ac			;		CALLMONITOR 
a9ac			;	endif 
a9ac cd 85 90				call strcmp 
a9af c2 96 a9				jp nz, .fldouscanm 
a9b2			; 
a9b2			; 
a9b2			;; while we have words to look for 
a9b2			; 
a9b2			;.fdouscan:	ld a, (hl)      
a9b2			;	if DEBUG_FORTH_WORDS 
a9b2			;		DMARK "LSs" 
a9b2			;		CALLMONITOR 
a9b2			;	endif 
a9b2			;		cp WORD_SYS_END 
a9b2			;		jp z, .fudone 
a9b2			;		cp WORD_SYS_UWORD 
a9b2			;		jp nz, .fnuword 
a9b2			; 
a9b2			;	if DEBUG_FORTH_WORDS 
a9b2			;		DMARK "FGu" 
a9b2			;		CALLMONITOR 
a9b2			;	endif 
a9b2			; 
a9b2			;		; found a uword but is it the one we want... 
a9b2			; 
a9b2			; 
a9b2			;	        pop de   ; get back the dsp name 
a9b2			;		push de 
a9b2			; 
a9b2			;		push hl  ; to save the ptr 
a9b2			; 
a9b2			;		; skip opcode 
a9b2			;		inc hl  
a9b2			;		; skip next ptr 
a9b2			;		inc hl  
a9b2			;		inc hl 
a9b2			;		; skip len 
a9b2			;		inc hl 
a9b2			; 
a9b2			;	if DEBUG_FORTH_WORDS 
a9b2			;		DMARK "FGc" 
a9b2			;		CALLMONITOR 
a9b2			;	endif 
a9b2			;		call strcmp 
a9b2			;		jp nz, .fnuword 
a9b2			 
a9b2			 
a9b2 e1			pop hl 
a9b3			 
a9b3				 
a9b3				if DEBUG_FORTH_WORDS 
a9b3					DMARK "FGm" 
a9b3 f5				push af  
a9b4 3a c8 a9			ld a, (.dmark)  
a9b7 32 6b ee			ld (debug_mark),a  
a9ba 3a c9 a9			ld a, (.dmark+1)  
a9bd 32 6c ee			ld (debug_mark+1),a  
a9c0 3a ca a9			ld a, (.dmark+2)  
a9c3 32 6d ee			ld (debug_mark+2),a  
a9c6 18 03			jr .pastdmark  
a9c8 ..			.dmark: db "FGm"  
a9cb f1			.pastdmark: pop af  
a9cc			endm  
# End of macro DMARK
a9cc					CALLMONITOR 
a9cc cd 6f ee			call debug_vector  
a9cf				endm  
# End of macro CALLMONITOR
a9cf				endif 
a9cf			 
a9cf			 
a9cf			 
a9cf					; we have a uword so push its name to the stack 
a9cf			 
a9cf			;	   	push hl  ; save so we can move to next dict block 
a9cf			;pop hl 
a9cf			 
a9cf					; update opcode to deleted 
a9cf 3e 03				ld a, WORD_SYS_DELETED 
a9d1 77					ld (hl), a 
a9d2			 
a9d2 23					inc hl  
a9d3					; skip next ptr 
a9d3 23					inc hl  
a9d4 23					inc hl 
a9d5					; skip len 
a9d5 23					inc hl 
a9d6			 
a9d6					; TODO change parser to skip deleted words but for now mark it out 
a9d6 3e 5f				ld a, "_" 
a9d8 77					ld  (hl),a 
a9d9			 
a9d9			;		jr .fudone 
a9d9			; 
a9d9			;.fnuword:	pop hl 
a9d9			;		call forth_tok_next 
a9d9			;		jp .fdouscan  
a9d9			 
a9d9			.flunotfound:		  
a9d9			 
a9d9			 
a9d9					 
a9d9					FORTH_DSP_POP 
a9d9 cd 2b 9d			call macro_forth_dsp_pop 
a9dc				endm 
# End of macro FORTH_DSP_POP
a9dc			;		ld hl, .luno 
a9dc			;.fudone:		 pop hl 
a9dc					NEXTW 
a9dc c3 29 9e			jp macro_next 
a9df				endm 
# End of macro NEXTW
a9df			.NOP: 
a9df				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
a9df 61				db WORD_SYS_CORE+77             
a9e0 06 aa			dw .COMO            
a9e2 04				db 3 + 1 
a9e3 .. 00			db "NOP",0              
a9e7				endm 
# End of macro CWHEAD
a9e7			; | NOP (  --  ) Do nothing | DONE 
a9e7					if DEBUG_FORTH_WORDS_KEY 
a9e7						DMARK "NOP" 
a9e7 f5				push af  
a9e8 3a fc a9			ld a, (.dmark)  
a9eb 32 6b ee			ld (debug_mark),a  
a9ee 3a fd a9			ld a, (.dmark+1)  
a9f1 32 6c ee			ld (debug_mark+1),a  
a9f4 3a fe a9			ld a, (.dmark+2)  
a9f7 32 6d ee			ld (debug_mark+2),a  
a9fa 18 03			jr .pastdmark  
a9fc ..			.dmark: db "NOP"  
a9ff f1			.pastdmark: pop af  
aa00			endm  
# End of macro DMARK
aa00						CALLMONITOR 
aa00 cd 6f ee			call debug_vector  
aa03				endm  
# End of macro CALLMONITOR
aa03					endif 
aa03				       NEXTW 
aa03 c3 29 9e			jp macro_next 
aa06				endm 
# End of macro NEXTW
aa06			.COMO: 
aa06				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
aa06 6e				db WORD_SYS_CORE+90             
aa07 58 aa			dw .COMC            
aa09 02				db 1 + 1 
aa0a .. 00			db "(",0              
aa0c				endm 
# End of macro CWHEAD
aa0c			; | ( ( -- )  Start of comment | DONE 
aa0c			 
aa0c			 
aa0c 2a c2 e5				ld hl, ( os_tok_ptr) 
aa0f 11 53 aa			ld de, .closepar 
aa12					 
aa12					if DEBUG_FORTH_WORDS 
aa12						DMARK ").." 
aa12 f5				push af  
aa13 3a 27 aa			ld a, (.dmark)  
aa16 32 6b ee			ld (debug_mark),a  
aa19 3a 28 aa			ld a, (.dmark+1)  
aa1c 32 6c ee			ld (debug_mark+1),a  
aa1f 3a 29 aa			ld a, (.dmark+2)  
aa22 32 6d ee			ld (debug_mark+2),a  
aa25 18 03			jr .pastdmark  
aa27 ..			.dmark: db ").."  
aa2a f1			.pastdmark: pop af  
aa2b			endm  
# End of macro DMARK
aa2b						CALLMONITOR 
aa2b cd 6f ee			call debug_vector  
aa2e				endm  
# End of macro CALLMONITOR
aa2e					endif 
aa2e cd 44 9f			call findnexttok  
aa31			 
aa31					if DEBUG_FORTH_WORDS 
aa31						DMARK "IF5" 
aa31 f5				push af  
aa32 3a 46 aa			ld a, (.dmark)  
aa35 32 6b ee			ld (debug_mark),a  
aa38 3a 47 aa			ld a, (.dmark+1)  
aa3b 32 6c ee			ld (debug_mark+1),a  
aa3e 3a 48 aa			ld a, (.dmark+2)  
aa41 32 6d ee			ld (debug_mark+2),a  
aa44 18 03			jr .pastdmark  
aa46 ..			.dmark: db "IF5"  
aa49 f1			.pastdmark: pop af  
aa4a			endm  
# End of macro DMARK
aa4a						CALLMONITOR 
aa4a cd 6f ee			call debug_vector  
aa4d				endm  
# End of macro CALLMONITOR
aa4d					endif 
aa4d				; replace below with ) exec using tok_ptr 
aa4d 22 c2 e5			ld (os_tok_ptr), hl 
aa50 c3 ba 9e			jp exec1 
aa53			 
aa53 .. 00			.closepar:   db ")",0 
aa55			 
aa55				       NEXTW 
aa55 c3 29 9e			jp macro_next 
aa58				endm 
# End of macro NEXTW
aa58			.COMC: 
aa58				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
aa58 6f				db WORD_SYS_CORE+91             
aa59 61 aa			dw .SCRATCH            
aa5b 02				db 1 + 1 
aa5c .. 00			db ")",0              
aa5e				endm 
# End of macro CWHEAD
aa5e			; | ) ( -- )  End of comment |  DONE  
aa5e				       NEXTW 
aa5e c3 29 9e			jp macro_next 
aa61				endm 
# End of macro NEXTW
aa61			 
aa61			.SCRATCH: 
aa61				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
aa61 6f				db WORD_SYS_CORE+91             
aa62 9c aa			dw .INC            
aa64 08				db 7 + 1 
aa65 .. 00			db "SCRATCH",0              
aa6d				endm 
# End of macro CWHEAD
aa6d			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
aa6d			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
aa6d			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
aa6d			; | |  
aa6d			; | | e.g.    : score $00 scratch ; 
aa6d			; | |  
aa6d			; | | $00 score ! 
aa6d			; | | $01 score +! 
aa6d			; | |  
aa6d			; | | e.g.   : varword $0a scratch ;  
aa6d			; | | 
aa6d			; | | $8000 varword ! 
aa6d					if DEBUG_FORTH_WORDS_KEY 
aa6d						DMARK "SCR" 
aa6d f5				push af  
aa6e 3a 82 aa			ld a, (.dmark)  
aa71 32 6b ee			ld (debug_mark),a  
aa74 3a 83 aa			ld a, (.dmark+1)  
aa77 32 6c ee			ld (debug_mark+1),a  
aa7a 3a 84 aa			ld a, (.dmark+2)  
aa7d 32 6d ee			ld (debug_mark+2),a  
aa80 18 03			jr .pastdmark  
aa82 ..			.dmark: db "SCR"  
aa85 f1			.pastdmark: pop af  
aa86			endm  
# End of macro DMARK
aa86						CALLMONITOR 
aa86 cd 6f ee			call debug_vector  
aa89				endm  
# End of macro CALLMONITOR
aa89					endif 
aa89			 
aa89					FORTH_DSP_VALUEHL 
aa89 cd 73 9c			call macro_dsp_valuehl 
aa8c				endm 
# End of macro FORTH_DSP_VALUEHL
aa8c				 
aa8c					FORTH_DSP_POP 
aa8c cd 2b 9d			call macro_forth_dsp_pop 
aa8f				endm 
# End of macro FORTH_DSP_POP
aa8f			 
aa8f 7d					ld a, l 
aa90 21 e6 e7				ld hl, os_var_array 
aa93 cd e7 8c				call addatohl 
aa96			 
aa96 cd 6e 9a				call forth_push_numhl 
aa99			 
aa99				       NEXTW 
aa99 c3 29 9e			jp macro_next 
aa9c				endm 
# End of macro NEXTW
aa9c			 
aa9c			.INC: 
aa9c				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
aa9c 6f				db WORD_SYS_CORE+91             
aa9d f2 aa			dw .DEC            
aa9f 03				db 2 + 1 
aaa0 .. 00			db "+!",0              
aaa3				endm 
# End of macro CWHEAD
aaa3			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
aaa3					if DEBUG_FORTH_WORDS_KEY 
aaa3						DMARK "+s_" 
aaa3 f5				push af  
aaa4 3a b8 aa			ld a, (.dmark)  
aaa7 32 6b ee			ld (debug_mark),a  
aaaa 3a b9 aa			ld a, (.dmark+1)  
aaad 32 6c ee			ld (debug_mark+1),a  
aab0 3a ba aa			ld a, (.dmark+2)  
aab3 32 6d ee			ld (debug_mark+2),a  
aab6 18 03			jr .pastdmark  
aab8 ..			.dmark: db "+s_"  
aabb f1			.pastdmark: pop af  
aabc			endm  
# End of macro DMARK
aabc						CALLMONITOR 
aabc cd 6f ee			call debug_vector  
aabf				endm  
# End of macro CALLMONITOR
aabf					endif 
aabf			 
aabf					FORTH_DSP_VALUEHL 
aabf cd 73 9c			call macro_dsp_valuehl 
aac2				endm 
# End of macro FORTH_DSP_VALUEHL
aac2			 
aac2 e5					push hl   ; save address 
aac3			 
aac3					FORTH_DSP_POP 
aac3 cd 2b 9d			call macro_forth_dsp_pop 
aac6				endm 
# End of macro FORTH_DSP_POP
aac6			 
aac6					FORTH_DSP_VALUEHL 
aac6 cd 73 9c			call macro_dsp_valuehl 
aac9				endm 
# End of macro FORTH_DSP_VALUEHL
aac9			 
aac9 e5					push hl 
aaca					FORTH_DSP_POP 
aaca cd 2b 9d			call macro_forth_dsp_pop 
aacd				endm 
# End of macro FORTH_DSP_POP
aacd e1					pop hl 
aace			 
aace					; hl contains value to add to byte at a 
aace				 
aace eb					ex de, hl 
aacf			 
aacf e1					pop hl 
aad0			 
aad0					if DEBUG_FORTH_WORDS 
aad0						DMARK "INC" 
aad0 f5				push af  
aad1 3a e5 aa			ld a, (.dmark)  
aad4 32 6b ee			ld (debug_mark),a  
aad7 3a e6 aa			ld a, (.dmark+1)  
aada 32 6c ee			ld (debug_mark+1),a  
aadd 3a e7 aa			ld a, (.dmark+2)  
aae0 32 6d ee			ld (debug_mark+2),a  
aae3 18 03			jr .pastdmark  
aae5 ..			.dmark: db "INC"  
aae8 f1			.pastdmark: pop af  
aae9			endm  
# End of macro DMARK
aae9						CALLMONITOR 
aae9 cd 6f ee			call debug_vector  
aaec				endm  
# End of macro CALLMONITOR
aaec					endif 
aaec			 
aaec 7e					ld a,(hl) 
aaed 83					add e 
aaee 77					ld (hl),a 
aaef			 
aaef			 
aaef			 
aaef				       NEXTW 
aaef c3 29 9e			jp macro_next 
aaf2				endm 
# End of macro NEXTW
aaf2			 
aaf2			.DEC: 
aaf2				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
aaf2 6f				db WORD_SYS_CORE+91             
aaf3 46 ab			dw .INC2            
aaf5 03				db 2 + 1 
aaf6 .. 00			db "-!",0              
aaf9				endm 
# End of macro CWHEAD
aaf9			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
aaf9					if DEBUG_FORTH_WORDS_KEY 
aaf9						DMARK "-s_" 
aaf9 f5				push af  
aafa 3a 0e ab			ld a, (.dmark)  
aafd 32 6b ee			ld (debug_mark),a  
ab00 3a 0f ab			ld a, (.dmark+1)  
ab03 32 6c ee			ld (debug_mark+1),a  
ab06 3a 10 ab			ld a, (.dmark+2)  
ab09 32 6d ee			ld (debug_mark+2),a  
ab0c 18 03			jr .pastdmark  
ab0e ..			.dmark: db "-s_"  
ab11 f1			.pastdmark: pop af  
ab12			endm  
# End of macro DMARK
ab12						CALLMONITOR 
ab12 cd 6f ee			call debug_vector  
ab15				endm  
# End of macro CALLMONITOR
ab15					endif 
ab15			 
ab15					FORTH_DSP_VALUEHL 
ab15 cd 73 9c			call macro_dsp_valuehl 
ab18				endm 
# End of macro FORTH_DSP_VALUEHL
ab18			 
ab18 e5					push hl   ; save address 
ab19			 
ab19					FORTH_DSP_POP 
ab19 cd 2b 9d			call macro_forth_dsp_pop 
ab1c				endm 
# End of macro FORTH_DSP_POP
ab1c			 
ab1c					FORTH_DSP_VALUEHL 
ab1c cd 73 9c			call macro_dsp_valuehl 
ab1f				endm 
# End of macro FORTH_DSP_VALUEHL
ab1f			 
ab1f					; hl contains value to add to byte at a 
ab1f				 
ab1f eb					ex de, hl 
ab20			 
ab20 e1					pop hl 
ab21			 
ab21					if DEBUG_FORTH_WORDS 
ab21						DMARK "DEC" 
ab21 f5				push af  
ab22 3a 36 ab			ld a, (.dmark)  
ab25 32 6b ee			ld (debug_mark),a  
ab28 3a 37 ab			ld a, (.dmark+1)  
ab2b 32 6c ee			ld (debug_mark+1),a  
ab2e 3a 38 ab			ld a, (.dmark+2)  
ab31 32 6d ee			ld (debug_mark+2),a  
ab34 18 03			jr .pastdmark  
ab36 ..			.dmark: db "DEC"  
ab39 f1			.pastdmark: pop af  
ab3a			endm  
# End of macro DMARK
ab3a						CALLMONITOR 
ab3a cd 6f ee			call debug_vector  
ab3d				endm  
# End of macro CALLMONITOR
ab3d					endif 
ab3d			 
ab3d 7e					ld a,(hl) 
ab3e 93					sub e 
ab3f 77					ld (hl),a 
ab40			 
ab40			 
ab40					FORTH_DSP_POP 
ab40 cd 2b 9d			call macro_forth_dsp_pop 
ab43				endm 
# End of macro FORTH_DSP_POP
ab43			 
ab43				       NEXTW 
ab43 c3 29 9e			jp macro_next 
ab46				endm 
# End of macro NEXTW
ab46			 
ab46			.INC2: 
ab46				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
ab46 6f				db WORD_SYS_CORE+91             
ab47 f3 ab			dw .DEC2            
ab49 04				db 3 + 1 
ab4a .. 00			db "+2!",0              
ab4e				endm 
# End of macro CWHEAD
ab4e			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ab4e			 
ab4e					if DEBUG_FORTH_WORDS_KEY 
ab4e						DMARK "+2s" 
ab4e f5				push af  
ab4f 3a 63 ab			ld a, (.dmark)  
ab52 32 6b ee			ld (debug_mark),a  
ab55 3a 64 ab			ld a, (.dmark+1)  
ab58 32 6c ee			ld (debug_mark+1),a  
ab5b 3a 65 ab			ld a, (.dmark+2)  
ab5e 32 6d ee			ld (debug_mark+2),a  
ab61 18 03			jr .pastdmark  
ab63 ..			.dmark: db "+2s"  
ab66 f1			.pastdmark: pop af  
ab67			endm  
# End of macro DMARK
ab67						CALLMONITOR 
ab67 cd 6f ee			call debug_vector  
ab6a				endm  
# End of macro CALLMONITOR
ab6a					endif 
ab6a			 
ab6a					; Address 
ab6a			 
ab6a					FORTH_DSP_VALUEHL 
ab6a cd 73 9c			call macro_dsp_valuehl 
ab6d				endm 
# End of macro FORTH_DSP_VALUEHL
ab6d			 
ab6d e5					push hl    ; save address 
ab6e			 
ab6e					; load content into de 
ab6e			 
ab6e 5e					ld e,(hl) 
ab6f 23					inc hl 
ab70 56					ld d, (hl) 
ab71			 
ab71					if DEBUG_FORTH_WORDS 
ab71						DMARK "+2a" 
ab71 f5				push af  
ab72 3a 86 ab			ld a, (.dmark)  
ab75 32 6b ee			ld (debug_mark),a  
ab78 3a 87 ab			ld a, (.dmark+1)  
ab7b 32 6c ee			ld (debug_mark+1),a  
ab7e 3a 88 ab			ld a, (.dmark+2)  
ab81 32 6d ee			ld (debug_mark+2),a  
ab84 18 03			jr .pastdmark  
ab86 ..			.dmark: db "+2a"  
ab89 f1			.pastdmark: pop af  
ab8a			endm  
# End of macro DMARK
ab8a						CALLMONITOR 
ab8a cd 6f ee			call debug_vector  
ab8d				endm  
# End of macro CALLMONITOR
ab8d					endif 
ab8d			 
ab8d					FORTH_DSP_POP 
ab8d cd 2b 9d			call macro_forth_dsp_pop 
ab90				endm 
# End of macro FORTH_DSP_POP
ab90			 
ab90					; Get value to add 
ab90			 
ab90					FORTH_DSP_VALUE 
ab90 cd 5c 9c			call macro_forth_dsp_value 
ab93				endm 
# End of macro FORTH_DSP_VALUE
ab93			 
ab93					if DEBUG_FORTH_WORDS 
ab93						DMARK "+2v" 
ab93 f5				push af  
ab94 3a a8 ab			ld a, (.dmark)  
ab97 32 6b ee			ld (debug_mark),a  
ab9a 3a a9 ab			ld a, (.dmark+1)  
ab9d 32 6c ee			ld (debug_mark+1),a  
aba0 3a aa ab			ld a, (.dmark+2)  
aba3 32 6d ee			ld (debug_mark+2),a  
aba6 18 03			jr .pastdmark  
aba8 ..			.dmark: db "+2v"  
abab f1			.pastdmark: pop af  
abac			endm  
# End of macro DMARK
abac						CALLMONITOR 
abac cd 6f ee			call debug_vector  
abaf				endm  
# End of macro CALLMONITOR
abaf					endif 
abaf			 
abaf 19					add hl, de 
abb0			 
abb0					if DEBUG_FORTH_WORDS 
abb0						DMARK "+2+" 
abb0 f5				push af  
abb1 3a c5 ab			ld a, (.dmark)  
abb4 32 6b ee			ld (debug_mark),a  
abb7 3a c6 ab			ld a, (.dmark+1)  
abba 32 6c ee			ld (debug_mark+1),a  
abbd 3a c7 ab			ld a, (.dmark+2)  
abc0 32 6d ee			ld (debug_mark+2),a  
abc3 18 03			jr .pastdmark  
abc5 ..			.dmark: db "+2+"  
abc8 f1			.pastdmark: pop af  
abc9			endm  
# End of macro DMARK
abc9						CALLMONITOR 
abc9 cd 6f ee			call debug_vector  
abcc				endm  
# End of macro CALLMONITOR
abcc					endif 
abcc			 
abcc					; move result to de 
abcc			 
abcc eb					ex de, hl 
abcd			 
abcd					; Address 
abcd			 
abcd e1					pop hl 
abce			 
abce					; save it back 
abce			 
abce 73					ld (hl), e 
abcf 23					inc hl 
abd0 72					ld (hl), d 
abd1			 
abd1					if DEBUG_FORTH_WORDS 
abd1						DMARK "+2e" 
abd1 f5				push af  
abd2 3a e6 ab			ld a, (.dmark)  
abd5 32 6b ee			ld (debug_mark),a  
abd8 3a e7 ab			ld a, (.dmark+1)  
abdb 32 6c ee			ld (debug_mark+1),a  
abde 3a e8 ab			ld a, (.dmark+2)  
abe1 32 6d ee			ld (debug_mark+2),a  
abe4 18 03			jr .pastdmark  
abe6 ..			.dmark: db "+2e"  
abe9 f1			.pastdmark: pop af  
abea			endm  
# End of macro DMARK
abea						CALLMONITOR 
abea cd 6f ee			call debug_vector  
abed				endm  
# End of macro CALLMONITOR
abed					endif 
abed			 
abed			 
abed			 
abed					FORTH_DSP_POP 
abed cd 2b 9d			call macro_forth_dsp_pop 
abf0				endm 
# End of macro FORTH_DSP_POP
abf0			 
abf0			 
abf0				       NEXTW 
abf0 c3 29 9e			jp macro_next 
abf3				endm 
# End of macro NEXTW
abf3			 
abf3			.DEC2: 
abf3				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
abf3 6f				db WORD_SYS_CORE+91             
abf4 a2 ac			dw .GET2            
abf6 04				db 3 + 1 
abf7 .. 00			db "-2!",0              
abfb				endm 
# End of macro CWHEAD
abfb			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
abfb			 
abfb			 
abfb					if DEBUG_FORTH_WORDS_KEY 
abfb						DMARK "-2s" 
abfb f5				push af  
abfc 3a 10 ac			ld a, (.dmark)  
abff 32 6b ee			ld (debug_mark),a  
ac02 3a 11 ac			ld a, (.dmark+1)  
ac05 32 6c ee			ld (debug_mark+1),a  
ac08 3a 12 ac			ld a, (.dmark+2)  
ac0b 32 6d ee			ld (debug_mark+2),a  
ac0e 18 03			jr .pastdmark  
ac10 ..			.dmark: db "-2s"  
ac13 f1			.pastdmark: pop af  
ac14			endm  
# End of macro DMARK
ac14						CALLMONITOR 
ac14 cd 6f ee			call debug_vector  
ac17				endm  
# End of macro CALLMONITOR
ac17					endif 
ac17			 
ac17					; Address 
ac17			 
ac17					FORTH_DSP_VALUEHL 
ac17 cd 73 9c			call macro_dsp_valuehl 
ac1a				endm 
# End of macro FORTH_DSP_VALUEHL
ac1a			 
ac1a e5					push hl    ; save address 
ac1b			 
ac1b					; load content into de 
ac1b			 
ac1b 5e					ld e,(hl) 
ac1c 23					inc hl 
ac1d 56					ld d, (hl) 
ac1e			 
ac1e					if DEBUG_FORTH_WORDS 
ac1e						DMARK "-2a" 
ac1e f5				push af  
ac1f 3a 33 ac			ld a, (.dmark)  
ac22 32 6b ee			ld (debug_mark),a  
ac25 3a 34 ac			ld a, (.dmark+1)  
ac28 32 6c ee			ld (debug_mark+1),a  
ac2b 3a 35 ac			ld a, (.dmark+2)  
ac2e 32 6d ee			ld (debug_mark+2),a  
ac31 18 03			jr .pastdmark  
ac33 ..			.dmark: db "-2a"  
ac36 f1			.pastdmark: pop af  
ac37			endm  
# End of macro DMARK
ac37						CALLMONITOR 
ac37 cd 6f ee			call debug_vector  
ac3a				endm  
# End of macro CALLMONITOR
ac3a					endif 
ac3a			 
ac3a					FORTH_DSP_POP 
ac3a cd 2b 9d			call macro_forth_dsp_pop 
ac3d				endm 
# End of macro FORTH_DSP_POP
ac3d			 
ac3d					; Get value to remove 
ac3d			 
ac3d					FORTH_DSP_VALUE 
ac3d cd 5c 9c			call macro_forth_dsp_value 
ac40				endm 
# End of macro FORTH_DSP_VALUE
ac40			 
ac40					if DEBUG_FORTH_WORDS 
ac40						DMARK "-2v" 
ac40 f5				push af  
ac41 3a 55 ac			ld a, (.dmark)  
ac44 32 6b ee			ld (debug_mark),a  
ac47 3a 56 ac			ld a, (.dmark+1)  
ac4a 32 6c ee			ld (debug_mark+1),a  
ac4d 3a 57 ac			ld a, (.dmark+2)  
ac50 32 6d ee			ld (debug_mark+2),a  
ac53 18 03			jr .pastdmark  
ac55 ..			.dmark: db "-2v"  
ac58 f1			.pastdmark: pop af  
ac59			endm  
# End of macro DMARK
ac59						CALLMONITOR 
ac59 cd 6f ee			call debug_vector  
ac5c				endm  
# End of macro CALLMONITOR
ac5c					endif 
ac5c			 
ac5c eb					ex de, hl 
ac5d ed 52				sbc hl, de 
ac5f			 
ac5f					if DEBUG_FORTH_WORDS 
ac5f						DMARK "-2d" 
ac5f f5				push af  
ac60 3a 74 ac			ld a, (.dmark)  
ac63 32 6b ee			ld (debug_mark),a  
ac66 3a 75 ac			ld a, (.dmark+1)  
ac69 32 6c ee			ld (debug_mark+1),a  
ac6c 3a 76 ac			ld a, (.dmark+2)  
ac6f 32 6d ee			ld (debug_mark+2),a  
ac72 18 03			jr .pastdmark  
ac74 ..			.dmark: db "-2d"  
ac77 f1			.pastdmark: pop af  
ac78			endm  
# End of macro DMARK
ac78						CALLMONITOR 
ac78 cd 6f ee			call debug_vector  
ac7b				endm  
# End of macro CALLMONITOR
ac7b					endif 
ac7b			 
ac7b					; move result to de 
ac7b			 
ac7b eb					ex de, hl 
ac7c			 
ac7c					; Address 
ac7c			 
ac7c e1					pop hl 
ac7d			 
ac7d					; save it back 
ac7d			 
ac7d 73					ld (hl), e 
ac7e 23					inc hl 
ac7f 72					ld (hl), d 
ac80			 
ac80					if DEBUG_FORTH_WORDS 
ac80						DMARK "-2e" 
ac80 f5				push af  
ac81 3a 95 ac			ld a, (.dmark)  
ac84 32 6b ee			ld (debug_mark),a  
ac87 3a 96 ac			ld a, (.dmark+1)  
ac8a 32 6c ee			ld (debug_mark+1),a  
ac8d 3a 97 ac			ld a, (.dmark+2)  
ac90 32 6d ee			ld (debug_mark+2),a  
ac93 18 03			jr .pastdmark  
ac95 ..			.dmark: db "-2e"  
ac98 f1			.pastdmark: pop af  
ac99			endm  
# End of macro DMARK
ac99						CALLMONITOR 
ac99 cd 6f ee			call debug_vector  
ac9c				endm  
# End of macro CALLMONITOR
ac9c					endif 
ac9c			 
ac9c			 
ac9c					FORTH_DSP_POP 
ac9c cd 2b 9d			call macro_forth_dsp_pop 
ac9f				endm 
# End of macro FORTH_DSP_POP
ac9f			 
ac9f			 
ac9f			 
ac9f				       NEXTW 
ac9f c3 29 9e			jp macro_next 
aca2				endm 
# End of macro NEXTW
aca2			.GET2: 
aca2				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
aca2 6f				db WORD_SYS_CORE+91             
aca3 d7 ac			dw .BANG2            
aca5 03				db 2 + 1 
aca6 .. 00			db "2@",0              
aca9				endm 
# End of macro CWHEAD
aca9			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
aca9					if DEBUG_FORTH_WORDS_KEY 
aca9						DMARK "2A_" 
aca9 f5				push af  
acaa 3a be ac			ld a, (.dmark)  
acad 32 6b ee			ld (debug_mark),a  
acb0 3a bf ac			ld a, (.dmark+1)  
acb3 32 6c ee			ld (debug_mark+1),a  
acb6 3a c0 ac			ld a, (.dmark+2)  
acb9 32 6d ee			ld (debug_mark+2),a  
acbc 18 03			jr .pastdmark  
acbe ..			.dmark: db "2A_"  
acc1 f1			.pastdmark: pop af  
acc2			endm  
# End of macro DMARK
acc2						CALLMONITOR 
acc2 cd 6f ee			call debug_vector  
acc5				endm  
# End of macro CALLMONITOR
acc5					endif 
acc5			 
acc5					FORTH_DSP_VALUEHL 
acc5 cd 73 9c			call macro_dsp_valuehl 
acc8				endm 
# End of macro FORTH_DSP_VALUEHL
acc8			 
acc8 e5					push hl   ; save address 
acc9			 
acc9					FORTH_DSP_POP 
acc9 cd 2b 9d			call macro_forth_dsp_pop 
accc				endm 
# End of macro FORTH_DSP_POP
accc			 
accc e1					pop hl 
accd			 
accd 5e					ld e, (hl) 
acce 23					inc hl 
accf 56					ld d, (hl) 
acd0			 
acd0 eb					ex de, hl 
acd1			 
acd1 cd 6e 9a				call forth_push_numhl 
acd4			 
acd4				       NEXTW 
acd4 c3 29 9e			jp macro_next 
acd7				endm 
# End of macro NEXTW
acd7			.BANG2: 
acd7				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
acd7 6f				db WORD_SYS_CORE+91             
acd8 0f ad			dw .CONFIG            
acda 03				db 2 + 1 
acdb .. 00			db "2!",0              
acde				endm 
# End of macro CWHEAD
acde			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
acde					if DEBUG_FORTH_WORDS_KEY 
acde						DMARK "2S_" 
acde f5				push af  
acdf 3a f3 ac			ld a, (.dmark)  
ace2 32 6b ee			ld (debug_mark),a  
ace5 3a f4 ac			ld a, (.dmark+1)  
ace8 32 6c ee			ld (debug_mark+1),a  
aceb 3a f5 ac			ld a, (.dmark+2)  
acee 32 6d ee			ld (debug_mark+2),a  
acf1 18 03			jr .pastdmark  
acf3 ..			.dmark: db "2S_"  
acf6 f1			.pastdmark: pop af  
acf7			endm  
# End of macro DMARK
acf7						CALLMONITOR 
acf7 cd 6f ee			call debug_vector  
acfa				endm  
# End of macro CALLMONITOR
acfa					endif 
acfa			 
acfa					FORTH_DSP_VALUEHL 
acfa cd 73 9c			call macro_dsp_valuehl 
acfd				endm 
# End of macro FORTH_DSP_VALUEHL
acfd			 
acfd e5					push hl   ; save address 
acfe			 
acfe			 
acfe					FORTH_DSP_POP 
acfe cd 2b 9d			call macro_forth_dsp_pop 
ad01				endm 
# End of macro FORTH_DSP_POP
ad01			 
ad01					 
ad01					FORTH_DSP_VALUEHL 
ad01 cd 73 9c			call macro_dsp_valuehl 
ad04				endm 
# End of macro FORTH_DSP_VALUEHL
ad04			 
ad04					FORTH_DSP_POP 
ad04 cd 2b 9d			call macro_forth_dsp_pop 
ad07				endm 
# End of macro FORTH_DSP_POP
ad07			 
ad07 eb					ex de, hl    ; value now in de 
ad08			 
ad08 e1					pop hl 
ad09			 
ad09 73					ld (hl), e 
ad0a			 
ad0a 23					inc hl 
ad0b			 
ad0b 72					ld (hl), d 
ad0c			 
ad0c			 
ad0c				       NEXTW 
ad0c c3 29 9e			jp macro_next 
ad0f				endm 
# End of macro NEXTW
ad0f			.CONFIG: 
ad0f				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
ad0f 6f				db WORD_SYS_CORE+91             
ad10 20 ad			dw .ADTOS            
ad12 07				db 6 + 1 
ad13 .. 00			db "CONFIG",0              
ad1a				endm 
# End of macro CWHEAD
ad1a			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
ad1a			 
ad1a cd 5b 92				call config 
ad1d					NEXTW 
ad1d c3 29 9e			jp macro_next 
ad20				endm 
# End of macro NEXTW
ad20			 
ad20			.ADTOS: 
ad20				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
ad20 6f				db WORD_SYS_CORE+91             
ad21 36 ad			dw .SBTOS            
ad23 03				db 2 + 1 
ad24 .. 00			db "1+",0              
ad27				endm 
# End of macro CWHEAD
ad27			; | 1+ ( u -- u )  Increment value on TOS | DONE 
ad27			 
ad27					FORTH_DSP_VALUEHL 
ad27 cd 73 9c			call macro_dsp_valuehl 
ad2a				endm 
# End of macro FORTH_DSP_VALUEHL
ad2a e5					push hl 
ad2b			 
ad2b					FORTH_DSP_POP 
ad2b cd 2b 9d			call macro_forth_dsp_pop 
ad2e				endm 
# End of macro FORTH_DSP_POP
ad2e e1					pop hl 
ad2f			 
ad2f 23					inc hl 
ad30 cd 6e 9a				call forth_push_numhl 
ad33					 
ad33					NEXTW 
ad33 c3 29 9e			jp macro_next 
ad36				endm 
# End of macro NEXTW
ad36			.SBTOS: 
ad36				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
ad36 6f				db WORD_SYS_CORE+91             
ad37 4c ad			dw .ADSTORE            
ad39 03				db 2 + 1 
ad3a .. 00			db "1-",0              
ad3d				endm 
# End of macro CWHEAD
ad3d			; | 1- ( u -- u )  Decrement value on TOS | DONE 
ad3d			 
ad3d					FORTH_DSP_VALUEHL 
ad3d cd 73 9c			call macro_dsp_valuehl 
ad40				endm 
# End of macro FORTH_DSP_VALUEHL
ad40 e5					push hl 
ad41			 
ad41					FORTH_DSP_POP 
ad41 cd 2b 9d			call macro_forth_dsp_pop 
ad44				endm 
# End of macro FORTH_DSP_POP
ad44 e1					pop hl 
ad45			 
ad45 2b					dec hl 
ad46 cd 6e 9a				call forth_push_numhl 
ad49					 
ad49					NEXTW 
ad49 c3 29 9e			jp macro_next 
ad4c				endm 
# End of macro NEXTW
ad4c			.ADSTORE: 
ad4c				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
ad4c 6f				db WORD_SYS_CORE+91             
ad4d 62 ad			dw .ADWSTORE            
ad4f 04				db 3 + 1 
ad50 .. 00			db "1+!",0              
ad54				endm 
# End of macro CWHEAD
ad54			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
ad54			 
ad54					FORTH_DSP_VALUEHL 
ad54 cd 73 9c			call macro_dsp_valuehl 
ad57				endm 
# End of macro FORTH_DSP_VALUEHL
ad57 e5					push hl 
ad58			 
ad58					FORTH_DSP_POP 
ad58 cd 2b 9d			call macro_forth_dsp_pop 
ad5b				endm 
# End of macro FORTH_DSP_POP
ad5b e1					pop hl 
ad5c			 
ad5c 7e					ld a, (hl) 
ad5d 3c					inc a 
ad5e 77					ld (hl), a 
ad5f					 
ad5f					NEXTW 
ad5f c3 29 9e			jp macro_next 
ad62				endm 
# End of macro NEXTW
ad62			.ADWSTORE: 
ad62				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
ad62 6f				db WORD_SYS_CORE+91             
ad63 80 ad			dw .SBSTORE            
ad65 05				db 4 + 1 
ad66 .. 00			db "1+2!",0              
ad6b				endm 
# End of macro CWHEAD
ad6b			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
ad6b			 
ad6b					FORTH_DSP_VALUEHL 
ad6b cd 73 9c			call macro_dsp_valuehl 
ad6e				endm 
# End of macro FORTH_DSP_VALUEHL
ad6e e5					push hl 
ad6f			 
ad6f					FORTH_DSP_POP 
ad6f cd 2b 9d			call macro_forth_dsp_pop 
ad72				endm 
# End of macro FORTH_DSP_POP
ad72 e1					pop hl 
ad73			 
ad73 e5					push hl 
ad74			 
ad74 cd ab 9d				call loadwordinhl 
ad77 23					inc hl 
ad78			 
ad78 d1					pop de 
ad79 eb					ex de, hl 
ad7a 73					ld (hl), e 
ad7b 23					inc hl 
ad7c 72					ld (hl), d 
ad7d					 
ad7d					NEXTW 
ad7d c3 29 9e			jp macro_next 
ad80				endm 
# End of macro NEXTW
ad80			.SBSTORE: 
ad80				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
ad80 6f				db WORD_SYS_CORE+91             
ad81 96 ad			dw .SBWSTORE            
ad83 04				db 3 + 1 
ad84 .. 00			db "1-!",0              
ad88				endm 
# End of macro CWHEAD
ad88			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
ad88			 
ad88					FORTH_DSP_VALUEHL 
ad88 cd 73 9c			call macro_dsp_valuehl 
ad8b				endm 
# End of macro FORTH_DSP_VALUEHL
ad8b e5					push hl 
ad8c			 
ad8c					FORTH_DSP_POP 
ad8c cd 2b 9d			call macro_forth_dsp_pop 
ad8f				endm 
# End of macro FORTH_DSP_POP
ad8f e1					pop hl 
ad90			 
ad90 7e					ld a, (hl) 
ad91 3d					dec a 
ad92 77					ld (hl), a 
ad93					 
ad93					NEXTW 
ad93 c3 29 9e			jp macro_next 
ad96				endm 
# End of macro NEXTW
ad96			.SBWSTORE: 
ad96				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
ad96 6f				db WORD_SYS_CORE+91             
ad97 b4 ad			dw .ENDCORE            
ad99 05				db 4 + 1 
ad9a .. 00			db "1-2!",0              
ad9f				endm 
# End of macro CWHEAD
ad9f			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
ad9f			 
ad9f					FORTH_DSP_VALUEHL 
ad9f cd 73 9c			call macro_dsp_valuehl 
ada2				endm 
# End of macro FORTH_DSP_VALUEHL
ada2 e5					push hl 
ada3			 
ada3					FORTH_DSP_POP 
ada3 cd 2b 9d			call macro_forth_dsp_pop 
ada6				endm 
# End of macro FORTH_DSP_POP
ada6 e1					pop hl 
ada7			 
ada7 e5					push hl 
ada8			 
ada8 cd ab 9d				call loadwordinhl 
adab 2b					dec hl 
adac			 
adac d1					pop de 
adad eb					ex de, hl 
adae 73					ld (hl), e 
adaf 23					inc hl 
adb0 72					ld (hl), d 
adb1					 
adb1					NEXTW 
adb1 c3 29 9e			jp macro_next 
adb4				endm 
# End of macro NEXTW
adb4			.ENDCORE: 
adb4			 
adb4			; eof 
adb4			 
adb4			 
# End of file forth_words_core.asm
adb4			include "forth_words_flow.asm" 
adb4			 
adb4			; | ## Program Flow Words 
adb4			 
adb4			.IF: 
adb4				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
adb4 1e				db WORD_SYS_CORE+10             
adb5 a9 ae			dw .THEN            
adb7 03				db 2 + 1 
adb8 .. 00			db "IF",0              
adbb				endm 
# End of macro CWHEAD
adbb			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
adbb			; 
adbb					if DEBUG_FORTH_WORDS_KEY 
adbb						DMARK "IF." 
adbb f5				push af  
adbc 3a d0 ad			ld a, (.dmark)  
adbf 32 6b ee			ld (debug_mark),a  
adc2 3a d1 ad			ld a, (.dmark+1)  
adc5 32 6c ee			ld (debug_mark+1),a  
adc8 3a d2 ad			ld a, (.dmark+2)  
adcb 32 6d ee			ld (debug_mark+2),a  
adce 18 03			jr .pastdmark  
add0 ..			.dmark: db "IF."  
add3 f1			.pastdmark: pop af  
add4			endm  
# End of macro DMARK
add4						CALLMONITOR 
add4 cd 6f ee			call debug_vector  
add7				endm  
# End of macro CALLMONITOR
add7					endif 
add7			; eval TOS 
add7			 
add7				FORTH_DSP_VALUEHL 
add7 cd 73 9c			call macro_dsp_valuehl 
adda				endm 
# End of macro FORTH_DSP_VALUEHL
adda			 
adda			;	push hl 
adda				FORTH_DSP_POP 
adda cd 2b 9d			call macro_forth_dsp_pop 
addd				endm 
# End of macro FORTH_DSP_POP
addd			;	pop hl 
addd			 
addd					if DEBUG_FORTH_WORDS 
addd						DMARK "IF1" 
addd f5				push af  
adde 3a f2 ad			ld a, (.dmark)  
ade1 32 6b ee			ld (debug_mark),a  
ade4 3a f3 ad			ld a, (.dmark+1)  
ade7 32 6c ee			ld (debug_mark+1),a  
adea 3a f4 ad			ld a, (.dmark+2)  
aded 32 6d ee			ld (debug_mark+2),a  
adf0 18 03			jr .pastdmark  
adf2 ..			.dmark: db "IF1"  
adf5 f1			.pastdmark: pop af  
adf6			endm  
# End of macro DMARK
adf6						CALLMONITOR 
adf6 cd 6f ee			call debug_vector  
adf9				endm  
# End of macro CALLMONITOR
adf9					endif 
adf9 b7				or a        ; clear carry flag 
adfa 11 00 00			ld de, 0 
adfd eb				ex de,hl 
adfe ed 52			sbc hl, de 
ae00 c2 8a ae			jp nz, .iftrue 
ae03			 
ae03					if DEBUG_FORTH_WORDS 
ae03						DMARK "IF2" 
ae03 f5				push af  
ae04 3a 18 ae			ld a, (.dmark)  
ae07 32 6b ee			ld (debug_mark),a  
ae0a 3a 19 ae			ld a, (.dmark+1)  
ae0d 32 6c ee			ld (debug_mark+1),a  
ae10 3a 1a ae			ld a, (.dmark+2)  
ae13 32 6d ee			ld (debug_mark+2),a  
ae16 18 03			jr .pastdmark  
ae18 ..			.dmark: db "IF2"  
ae1b f1			.pastdmark: pop af  
ae1c			endm  
# End of macro DMARK
ae1c						CALLMONITOR 
ae1c cd 6f ee			call debug_vector  
ae1f				endm  
# End of macro CALLMONITOR
ae1f					endif 
ae1f			 
ae1f			; if not true then skip to THEN 
ae1f			 
ae1f				; TODO get tok_ptr 
ae1f				; TODO consume toks until we get to THEN 
ae1f			 
ae1f 2a c2 e5			ld hl, (os_tok_ptr) 
ae22					if DEBUG_FORTH_WORDS 
ae22						DMARK "IF3" 
ae22 f5				push af  
ae23 3a 37 ae			ld a, (.dmark)  
ae26 32 6b ee			ld (debug_mark),a  
ae29 3a 38 ae			ld a, (.dmark+1)  
ae2c 32 6c ee			ld (debug_mark+1),a  
ae2f 3a 39 ae			ld a, (.dmark+2)  
ae32 32 6d ee			ld (debug_mark+2),a  
ae35 18 03			jr .pastdmark  
ae37 ..			.dmark: db "IF3"  
ae3a f1			.pastdmark: pop af  
ae3b			endm  
# End of macro DMARK
ae3b						CALLMONITOR 
ae3b cd 6f ee			call debug_vector  
ae3e				endm  
# End of macro CALLMONITOR
ae3e						 
ae3e					endif 
ae3e 11 85 ae			ld de, .ifthen 
ae41					if DEBUG_FORTH_WORDS 
ae41						DMARK "IF4" 
ae41 f5				push af  
ae42 3a 56 ae			ld a, (.dmark)  
ae45 32 6b ee			ld (debug_mark),a  
ae48 3a 57 ae			ld a, (.dmark+1)  
ae4b 32 6c ee			ld (debug_mark+1),a  
ae4e 3a 58 ae			ld a, (.dmark+2)  
ae51 32 6d ee			ld (debug_mark+2),a  
ae54 18 03			jr .pastdmark  
ae56 ..			.dmark: db "IF4"  
ae59 f1			.pastdmark: pop af  
ae5a			endm  
# End of macro DMARK
ae5a						CALLMONITOR 
ae5a cd 6f ee			call debug_vector  
ae5d				endm  
# End of macro CALLMONITOR
ae5d					endif 
ae5d cd 44 9f			call findnexttok  
ae60			 
ae60					if DEBUG_FORTH_WORDS 
ae60						DMARK "IF5" 
ae60 f5				push af  
ae61 3a 75 ae			ld a, (.dmark)  
ae64 32 6b ee			ld (debug_mark),a  
ae67 3a 76 ae			ld a, (.dmark+1)  
ae6a 32 6c ee			ld (debug_mark+1),a  
ae6d 3a 77 ae			ld a, (.dmark+2)  
ae70 32 6d ee			ld (debug_mark+2),a  
ae73 18 03			jr .pastdmark  
ae75 ..			.dmark: db "IF5"  
ae78 f1			.pastdmark: pop af  
ae79			endm  
# End of macro DMARK
ae79						CALLMONITOR 
ae79 cd 6f ee			call debug_vector  
ae7c				endm  
# End of macro CALLMONITOR
ae7c					endif 
ae7c				; TODO replace below with ; exec using tok_ptr 
ae7c 22 c2 e5			ld (os_tok_ptr), hl 
ae7f c3 ba 9e			jp exec1 
ae82				NEXTW 
ae82 c3 29 9e			jp macro_next 
ae85				endm 
# End of macro NEXTW
ae85			 
ae85 .. 00		.ifthen:  db "THEN",0 
ae8a			 
ae8a			.iftrue:		 
ae8a				; Exec next words normally 
ae8a			 
ae8a				; if true then exec following IF as normal 
ae8a					if DEBUG_FORTH_WORDS 
ae8a						DMARK "IFT" 
ae8a f5				push af  
ae8b 3a 9f ae			ld a, (.dmark)  
ae8e 32 6b ee			ld (debug_mark),a  
ae91 3a a0 ae			ld a, (.dmark+1)  
ae94 32 6c ee			ld (debug_mark+1),a  
ae97 3a a1 ae			ld a, (.dmark+2)  
ae9a 32 6d ee			ld (debug_mark+2),a  
ae9d 18 03			jr .pastdmark  
ae9f ..			.dmark: db "IFT"  
aea2 f1			.pastdmark: pop af  
aea3			endm  
# End of macro DMARK
aea3						CALLMONITOR 
aea3 cd 6f ee			call debug_vector  
aea6				endm  
# End of macro CALLMONITOR
aea6					endif 
aea6			 
aea6					NEXTW 
aea6 c3 29 9e			jp macro_next 
aea9				endm 
# End of macro NEXTW
aea9			.THEN: 
aea9				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
aea9 1f				db WORD_SYS_CORE+11             
aeaa d1 ae			dw .ELSE            
aeac 05				db 4 + 1 
aead .. 00			db "THEN",0              
aeb2				endm 
# End of macro CWHEAD
aeb2			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
aeb2					if DEBUG_FORTH_WORDS_KEY 
aeb2						DMARK "THN" 
aeb2 f5				push af  
aeb3 3a c7 ae			ld a, (.dmark)  
aeb6 32 6b ee			ld (debug_mark),a  
aeb9 3a c8 ae			ld a, (.dmark+1)  
aebc 32 6c ee			ld (debug_mark+1),a  
aebf 3a c9 ae			ld a, (.dmark+2)  
aec2 32 6d ee			ld (debug_mark+2),a  
aec5 18 03			jr .pastdmark  
aec7 ..			.dmark: db "THN"  
aeca f1			.pastdmark: pop af  
aecb			endm  
# End of macro DMARK
aecb						CALLMONITOR 
aecb cd 6f ee			call debug_vector  
aece				endm  
# End of macro CALLMONITOR
aece					endif 
aece					NEXTW 
aece c3 29 9e			jp macro_next 
aed1				endm 
# End of macro NEXTW
aed1			.ELSE: 
aed1				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
aed1 20				db WORD_SYS_CORE+12             
aed2 f9 ae			dw .DO            
aed4 03				db 2 + 1 
aed5 .. 00			db "ELSE",0              
aeda				endm 
# End of macro CWHEAD
aeda			; | ELSE ( -- ) Not supported - does nothing | TODO 
aeda			 
aeda					if DEBUG_FORTH_WORDS_KEY 
aeda						DMARK "ELS" 
aeda f5				push af  
aedb 3a ef ae			ld a, (.dmark)  
aede 32 6b ee			ld (debug_mark),a  
aee1 3a f0 ae			ld a, (.dmark+1)  
aee4 32 6c ee			ld (debug_mark+1),a  
aee7 3a f1 ae			ld a, (.dmark+2)  
aeea 32 6d ee			ld (debug_mark+2),a  
aeed 18 03			jr .pastdmark  
aeef ..			.dmark: db "ELS"  
aef2 f1			.pastdmark: pop af  
aef3			endm  
# End of macro DMARK
aef3						CALLMONITOR 
aef3 cd 6f ee			call debug_vector  
aef6				endm  
# End of macro CALLMONITOR
aef6					endif 
aef6			 
aef6			 
aef6					NEXTW 
aef6 c3 29 9e			jp macro_next 
aef9				endm 
# End of macro NEXTW
aef9			.DO: 
aef9				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
aef9 21				db WORD_SYS_CORE+13             
aefa 20 b0			dw .LOOP            
aefc 03				db 2 + 1 
aefd .. 00			db "DO",0              
af00				endm 
# End of macro CWHEAD
af00			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
af00			 
af00					if DEBUG_FORTH_WORDS_KEY 
af00						DMARK "DO." 
af00 f5				push af  
af01 3a 15 af			ld a, (.dmark)  
af04 32 6b ee			ld (debug_mark),a  
af07 3a 16 af			ld a, (.dmark+1)  
af0a 32 6c ee			ld (debug_mark+1),a  
af0d 3a 17 af			ld a, (.dmark+2)  
af10 32 6d ee			ld (debug_mark+2),a  
af13 18 03			jr .pastdmark  
af15 ..			.dmark: db "DO."  
af18 f1			.pastdmark: pop af  
af19			endm  
# End of macro DMARK
af19						CALLMONITOR 
af19 cd 6f ee			call debug_vector  
af1c				endm  
# End of macro CALLMONITOR
af1c					endif 
af1c			;  push pc to rsp stack past the DO 
af1c			 
af1c 2a c2 e5				ld hl, (os_tok_ptr) 
af1f 23					inc hl   ; D 
af20 23					inc hl  ; O 
af21 23					inc hl   ; null 
af22					if DEBUG_FORTH_WORDS 
af22						DMARK "DO2" 
af22 f5				push af  
af23 3a 37 af			ld a, (.dmark)  
af26 32 6b ee			ld (debug_mark),a  
af29 3a 38 af			ld a, (.dmark+1)  
af2c 32 6c ee			ld (debug_mark+1),a  
af2f 3a 39 af			ld a, (.dmark+2)  
af32 32 6d ee			ld (debug_mark+2),a  
af35 18 03			jr .pastdmark  
af37 ..			.dmark: db "DO2"  
af3a f1			.pastdmark: pop af  
af3b			endm  
# End of macro DMARK
af3b						CALLMONITOR 
af3b cd 6f ee			call debug_vector  
af3e				endm  
# End of macro CALLMONITOR
af3e					endif 
af3e					FORTH_RSP_NEXT 
af3e cd 15 9a			call macro_forth_rsp_next 
af41				endm 
# End of macro FORTH_RSP_NEXT
af41					if DEBUG_FORTH_WORDS 
af41						DMARK "DO3" 
af41 f5				push af  
af42 3a 56 af			ld a, (.dmark)  
af45 32 6b ee			ld (debug_mark),a  
af48 3a 57 af			ld a, (.dmark+1)  
af4b 32 6c ee			ld (debug_mark+1),a  
af4e 3a 58 af			ld a, (.dmark+2)  
af51 32 6d ee			ld (debug_mark+2),a  
af54 18 03			jr .pastdmark  
af56 ..			.dmark: db "DO3"  
af59 f1			.pastdmark: pop af  
af5a			endm  
# End of macro DMARK
af5a						CALLMONITOR 
af5a cd 6f ee			call debug_vector  
af5d				endm  
# End of macro CALLMONITOR
af5d					endif 
af5d			 
af5d					;if DEBUG_FORTH_WORDS 
af5d				;		push hl 
af5d			;		endif  
af5d			 
af5d			; get counters from data stack 
af5d			 
af5d			 
af5d					FORTH_DSP_VALUEHL 
af5d cd 73 9c			call macro_dsp_valuehl 
af60				endm 
# End of macro FORTH_DSP_VALUEHL
af60 e5					push hl		 ; hl now has starting counter which needs to be tos 
af61			 
af61					if DEBUG_FORTH_WORDS 
af61						DMARK "DO4" 
af61 f5				push af  
af62 3a 76 af			ld a, (.dmark)  
af65 32 6b ee			ld (debug_mark),a  
af68 3a 77 af			ld a, (.dmark+1)  
af6b 32 6c ee			ld (debug_mark+1),a  
af6e 3a 78 af			ld a, (.dmark+2)  
af71 32 6d ee			ld (debug_mark+2),a  
af74 18 03			jr .pastdmark  
af76 ..			.dmark: db "DO4"  
af79 f1			.pastdmark: pop af  
af7a			endm  
# End of macro DMARK
af7a						CALLMONITOR 
af7a cd 6f ee			call debug_vector  
af7d				endm  
# End of macro CALLMONITOR
af7d					endif 
af7d					FORTH_DSP_POP 
af7d cd 2b 9d			call macro_forth_dsp_pop 
af80				endm 
# End of macro FORTH_DSP_POP
af80			 
af80					if DEBUG_FORTH_WORDS 
af80						DMARK "DO5" 
af80 f5				push af  
af81 3a 95 af			ld a, (.dmark)  
af84 32 6b ee			ld (debug_mark),a  
af87 3a 96 af			ld a, (.dmark+1)  
af8a 32 6c ee			ld (debug_mark+1),a  
af8d 3a 97 af			ld a, (.dmark+2)  
af90 32 6d ee			ld (debug_mark+2),a  
af93 18 03			jr .pastdmark  
af95 ..			.dmark: db "DO5"  
af98 f1			.pastdmark: pop af  
af99			endm  
# End of macro DMARK
af99						CALLMONITOR 
af99 cd 6f ee			call debug_vector  
af9c				endm  
# End of macro CALLMONITOR
af9c					endif 
af9c			 
af9c					FORTH_DSP_VALUEHL 
af9c cd 73 9c			call macro_dsp_valuehl 
af9f				endm 
# End of macro FORTH_DSP_VALUEHL
af9f			;		push hl		 ; hl now has starting limit counter 
af9f			 
af9f					if DEBUG_FORTH_WORDS 
af9f						DMARK "DO6" 
af9f f5				push af  
afa0 3a b4 af			ld a, (.dmark)  
afa3 32 6b ee			ld (debug_mark),a  
afa6 3a b5 af			ld a, (.dmark+1)  
afa9 32 6c ee			ld (debug_mark+1),a  
afac 3a b6 af			ld a, (.dmark+2)  
afaf 32 6d ee			ld (debug_mark+2),a  
afb2 18 03			jr .pastdmark  
afb4 ..			.dmark: db "DO6"  
afb7 f1			.pastdmark: pop af  
afb8			endm  
# End of macro DMARK
afb8						CALLMONITOR 
afb8 cd 6f ee			call debug_vector  
afbb				endm  
# End of macro CALLMONITOR
afbb					endif 
afbb					FORTH_DSP_POP 
afbb cd 2b 9d			call macro_forth_dsp_pop 
afbe				endm 
# End of macro FORTH_DSP_POP
afbe			 
afbe			; put counters on the loop stack 
afbe			 
afbe			;		pop hl			 ; limit counter 
afbe d1					pop de			; start counter 
afbf			 
afbf					; push limit counter 
afbf			 
afbf					if DEBUG_FORTH_WORDS 
afbf						DMARK "DO7" 
afbf f5				push af  
afc0 3a d4 af			ld a, (.dmark)  
afc3 32 6b ee			ld (debug_mark),a  
afc6 3a d5 af			ld a, (.dmark+1)  
afc9 32 6c ee			ld (debug_mark+1),a  
afcc 3a d6 af			ld a, (.dmark+2)  
afcf 32 6d ee			ld (debug_mark+2),a  
afd2 18 03			jr .pastdmark  
afd4 ..			.dmark: db "DO7"  
afd7 f1			.pastdmark: pop af  
afd8			endm  
# End of macro DMARK
afd8						CALLMONITOR 
afd8 cd 6f ee			call debug_vector  
afdb				endm  
# End of macro CALLMONITOR
afdb					endif 
afdb					FORTH_LOOP_NEXT 
afdb cd a4 9c			call macro_forth_loop_next 
afde				endm 
# End of macro FORTH_LOOP_NEXT
afde			 
afde					; push start counter 
afde			 
afde eb					ex de, hl 
afdf					if DEBUG_FORTH_WORDS 
afdf						DMARK "DO7" 
afdf f5				push af  
afe0 3a f4 af			ld a, (.dmark)  
afe3 32 6b ee			ld (debug_mark),a  
afe6 3a f5 af			ld a, (.dmark+1)  
afe9 32 6c ee			ld (debug_mark+1),a  
afec 3a f6 af			ld a, (.dmark+2)  
afef 32 6d ee			ld (debug_mark+2),a  
aff2 18 03			jr .pastdmark  
aff4 ..			.dmark: db "DO7"  
aff7 f1			.pastdmark: pop af  
aff8			endm  
# End of macro DMARK
aff8						CALLMONITOR 
aff8 cd 6f ee			call debug_vector  
affb				endm  
# End of macro CALLMONITOR
affb					endif 
affb					FORTH_LOOP_NEXT 
affb cd a4 9c			call macro_forth_loop_next 
affe				endm 
# End of macro FORTH_LOOP_NEXT
affe			 
affe			 
affe					; init first round of I counter 
affe			 
affe 22 e6 e5				ld (os_current_i), hl 
b001			 
b001					if DEBUG_FORTH_WORDS 
b001						DMARK "DO8" 
b001 f5				push af  
b002 3a 16 b0			ld a, (.dmark)  
b005 32 6b ee			ld (debug_mark),a  
b008 3a 17 b0			ld a, (.dmark+1)  
b00b 32 6c ee			ld (debug_mark+1),a  
b00e 3a 18 b0			ld a, (.dmark+2)  
b011 32 6d ee			ld (debug_mark+2),a  
b014 18 03			jr .pastdmark  
b016 ..			.dmark: db "DO8"  
b019 f1			.pastdmark: pop af  
b01a			endm  
# End of macro DMARK
b01a						CALLMONITOR 
b01a cd 6f ee			call debug_vector  
b01d				endm  
# End of macro CALLMONITOR
b01d					endif 
b01d			 
b01d					NEXTW 
b01d c3 29 9e			jp macro_next 
b020				endm 
# End of macro NEXTW
b020			.LOOP: 
b020				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b020 22				db WORD_SYS_CORE+14             
b021 38 b1			dw .I            
b023 05				db 4 + 1 
b024 .. 00			db "LOOP",0              
b029				endm 
# End of macro CWHEAD
b029			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b029			 
b029				; pop tos as current loop count to hl 
b029			 
b029				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b029			 
b029				FORTH_LOOP_TOS 
b029 cd d7 9c			call macro_forth_loop_tos 
b02c				endm 
# End of macro FORTH_LOOP_TOS
b02c e5				push hl 
b02d			 
b02d					if DEBUG_FORTH_WORDS_KEY 
b02d						DMARK "LOP" 
b02d f5				push af  
b02e 3a 42 b0			ld a, (.dmark)  
b031 32 6b ee			ld (debug_mark),a  
b034 3a 43 b0			ld a, (.dmark+1)  
b037 32 6c ee			ld (debug_mark+1),a  
b03a 3a 44 b0			ld a, (.dmark+2)  
b03d 32 6d ee			ld (debug_mark+2),a  
b040 18 03			jr .pastdmark  
b042 ..			.dmark: db "LOP"  
b045 f1			.pastdmark: pop af  
b046			endm  
# End of macro DMARK
b046						CALLMONITOR 
b046 cd 6f ee			call debug_vector  
b049				endm  
# End of macro CALLMONITOR
b049					endif 
b049				; next item on the stack is the limit. get it 
b049			 
b049			 
b049				FORTH_LOOP_POP 
b049 cd e1 9c			call macro_forth_loop_pop 
b04c				endm 
# End of macro FORTH_LOOP_POP
b04c			 
b04c				FORTH_LOOP_TOS 
b04c cd d7 9c			call macro_forth_loop_tos 
b04f				endm 
# End of macro FORTH_LOOP_TOS
b04f			 
b04f d1				pop de		 ; de = i, hl = limit 
b050			 
b050					if DEBUG_FORTH_WORDS 
b050						DMARK "LP1" 
b050 f5				push af  
b051 3a 65 b0			ld a, (.dmark)  
b054 32 6b ee			ld (debug_mark),a  
b057 3a 66 b0			ld a, (.dmark+1)  
b05a 32 6c ee			ld (debug_mark+1),a  
b05d 3a 67 b0			ld a, (.dmark+2)  
b060 32 6d ee			ld (debug_mark+2),a  
b063 18 03			jr .pastdmark  
b065 ..			.dmark: db "LP1"  
b068 f1			.pastdmark: pop af  
b069			endm  
# End of macro DMARK
b069						CALLMONITOR 
b069 cd 6f ee			call debug_vector  
b06c				endm  
# End of macro CALLMONITOR
b06c					endif 
b06c			 
b06c				; go back to previous word 
b06c			 
b06c d5				push de    ; save I for inc later 
b06d			 
b06d			 
b06d				; get limit 
b06d				;  is I at limit? 
b06d			 
b06d			 
b06d					if DEBUG_FORTH_WORDS 
b06d						DMARK "LP1" 
b06d f5				push af  
b06e 3a 82 b0			ld a, (.dmark)  
b071 32 6b ee			ld (debug_mark),a  
b074 3a 83 b0			ld a, (.dmark+1)  
b077 32 6c ee			ld (debug_mark+1),a  
b07a 3a 84 b0			ld a, (.dmark+2)  
b07d 32 6d ee			ld (debug_mark+2),a  
b080 18 03			jr .pastdmark  
b082 ..			.dmark: db "LP1"  
b085 f1			.pastdmark: pop af  
b086			endm  
# End of macro DMARK
b086						CALLMONITOR 
b086 cd 6f ee			call debug_vector  
b089				endm  
# End of macro CALLMONITOR
b089					endif 
b089			 
b089 ed 52			sbc hl, de 
b08b			 
b08b			 
b08b				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b08b			 
b08b 20 26				jr nz, .loopnotdone 
b08d			 
b08d e1				pop hl   ; get rid of saved I 
b08e				FORTH_LOOP_POP     ; get rid of limit 
b08e cd e1 9c			call macro_forth_loop_pop 
b091				endm 
# End of macro FORTH_LOOP_POP
b091			 
b091				FORTH_RSP_POP     ; get rid of DO ptr 
b091 cd 36 9a			call macro_forth_rsp_pop 
b094				endm 
# End of macro FORTH_RSP_POP
b094			 
b094			if DEBUG_FORTH_WORDS 
b094						DMARK "LP>" 
b094 f5				push af  
b095 3a a9 b0			ld a, (.dmark)  
b098 32 6b ee			ld (debug_mark),a  
b09b 3a aa b0			ld a, (.dmark+1)  
b09e 32 6c ee			ld (debug_mark+1),a  
b0a1 3a ab b0			ld a, (.dmark+2)  
b0a4 32 6d ee			ld (debug_mark+2),a  
b0a7 18 03			jr .pastdmark  
b0a9 ..			.dmark: db "LP>"  
b0ac f1			.pastdmark: pop af  
b0ad			endm  
# End of macro DMARK
b0ad				CALLMONITOR 
b0ad cd 6f ee			call debug_vector  
b0b0				endm  
# End of macro CALLMONITOR
b0b0			endif 
b0b0			 
b0b0					NEXTW 
b0b0 c3 29 9e			jp macro_next 
b0b3				endm 
# End of macro NEXTW
b0b3				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b0b3			 
b0b3			.loopnotdone: 
b0b3			 
b0b3 e1				pop hl    ; get I 
b0b4 23				inc hl 
b0b5			 
b0b5			   	; save new I 
b0b5			 
b0b5			 
b0b5					; set I counter 
b0b5			 
b0b5 22 e6 e5				ld (os_current_i), hl 
b0b8			 
b0b8					if DEBUG_FORTH_WORDS 
b0b8						DMARK "LPN" 
b0b8 f5				push af  
b0b9 3a cd b0			ld a, (.dmark)  
b0bc 32 6b ee			ld (debug_mark),a  
b0bf 3a ce b0			ld a, (.dmark+1)  
b0c2 32 6c ee			ld (debug_mark+1),a  
b0c5 3a cf b0			ld a, (.dmark+2)  
b0c8 32 6d ee			ld (debug_mark+2),a  
b0cb 18 03			jr .pastdmark  
b0cd ..			.dmark: db "LPN"  
b0d0 f1			.pastdmark: pop af  
b0d1			endm  
# End of macro DMARK
b0d1					CALLMONITOR 
b0d1 cd 6f ee			call debug_vector  
b0d4				endm  
# End of macro CALLMONITOR
b0d4					endif 
b0d4					 
b0d4				FORTH_LOOP_NEXT 
b0d4 cd a4 9c			call macro_forth_loop_next 
b0d7				endm 
# End of macro FORTH_LOOP_NEXT
b0d7			 
b0d7			 
b0d7					if DEBUG_FORTH_WORDS 
b0d7 eb						ex de,hl 
b0d8					endif 
b0d8			 
b0d8			;	; get DO ptr 
b0d8			; 
b0d8					if DEBUG_FORTH_WORDS 
b0d8						DMARK "LP7" 
b0d8 f5				push af  
b0d9 3a ed b0			ld a, (.dmark)  
b0dc 32 6b ee			ld (debug_mark),a  
b0df 3a ee b0			ld a, (.dmark+1)  
b0e2 32 6c ee			ld (debug_mark+1),a  
b0e5 3a ef b0			ld a, (.dmark+2)  
b0e8 32 6d ee			ld (debug_mark+2),a  
b0eb 18 03			jr .pastdmark  
b0ed ..			.dmark: db "LP7"  
b0f0 f1			.pastdmark: pop af  
b0f1			endm  
# End of macro DMARK
b0f1					CALLMONITOR 
b0f1 cd 6f ee			call debug_vector  
b0f4				endm  
# End of macro CALLMONITOR
b0f4					endif 
b0f4				FORTH_RSP_TOS 
b0f4 cd 2c 9a			call macro_forth_rsp_tos 
b0f7				endm 
# End of macro FORTH_RSP_TOS
b0f7			 
b0f7					if DEBUG_FORTH_WORDS 
b0f7						DMARK "LP8" 
b0f7 f5				push af  
b0f8 3a 0c b1			ld a, (.dmark)  
b0fb 32 6b ee			ld (debug_mark),a  
b0fe 3a 0d b1			ld a, (.dmark+1)  
b101 32 6c ee			ld (debug_mark+1),a  
b104 3a 0e b1			ld a, (.dmark+2)  
b107 32 6d ee			ld (debug_mark+2),a  
b10a 18 03			jr .pastdmark  
b10c ..			.dmark: db "LP8"  
b10f f1			.pastdmark: pop af  
b110			endm  
# End of macro DMARK
b110					CALLMONITOR 
b110 cd 6f ee			call debug_vector  
b113				endm  
# End of macro CALLMONITOR
b113					endif 
b113				;push hl 
b113			 
b113				; not going to DO any more 
b113				; get rid of the RSP pointer as DO will add it back in 
b113				;FORTH_RSP_POP 
b113				;pop hl 
b113			 
b113				;ld hl,(cli_ret_sp) 
b113				;ld e, (hl) 
b113				;inc hl 
b113				;ld d, (hl) 
b113				;ex de,hl 
b113 22 c2 e5			ld (os_tok_ptr), hl 
b116					if DEBUG_FORTH_WORDS 
b116						DMARK "LP<" 
b116 f5				push af  
b117 3a 2b b1			ld a, (.dmark)  
b11a 32 6b ee			ld (debug_mark),a  
b11d 3a 2c b1			ld a, (.dmark+1)  
b120 32 6c ee			ld (debug_mark+1),a  
b123 3a 2d b1			ld a, (.dmark+2)  
b126 32 6d ee			ld (debug_mark+2),a  
b129 18 03			jr .pastdmark  
b12b ..			.dmark: db "LP<"  
b12e f1			.pastdmark: pop af  
b12f			endm  
# End of macro DMARK
b12f					CALLMONITOR 
b12f cd 6f ee			call debug_vector  
b132				endm  
# End of macro CALLMONITOR
b132				endif 
b132 c3 ba 9e			jp exec1 
b135			 
b135					 
b135			 
b135			 
b135					NEXTW 
b135 c3 29 9e			jp macro_next 
b138				endm 
# End of macro NEXTW
b138			.I:  
b138			 
b138				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b138 5e				db WORD_SYS_CORE+74             
b139 63 b1			dw .DLOOP            
b13b 02				db 1 + 1 
b13c .. 00			db "I",0              
b13e				endm 
# End of macro CWHEAD
b13e			; | I ( -- ) Current loop counter | DONE 
b13e					if DEBUG_FORTH_WORDS_KEY 
b13e						DMARK "I.." 
b13e f5				push af  
b13f 3a 53 b1			ld a, (.dmark)  
b142 32 6b ee			ld (debug_mark),a  
b145 3a 54 b1			ld a, (.dmark+1)  
b148 32 6c ee			ld (debug_mark+1),a  
b14b 3a 55 b1			ld a, (.dmark+2)  
b14e 32 6d ee			ld (debug_mark+2),a  
b151 18 03			jr .pastdmark  
b153 ..			.dmark: db "I.."  
b156 f1			.pastdmark: pop af  
b157			endm  
# End of macro DMARK
b157						CALLMONITOR 
b157 cd 6f ee			call debug_vector  
b15a				endm  
# End of macro CALLMONITOR
b15a					endif 
b15a			 
b15a 2a e6 e5				ld hl,(os_current_i) 
b15d cd 6e 9a				call forth_push_numhl 
b160			 
b160					NEXTW 
b160 c3 29 9e			jp macro_next 
b163				endm 
# End of macro NEXTW
b163			.DLOOP: 
b163				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b163 5f				db WORD_SYS_CORE+75             
b164 44 b2			dw .REPEAT            
b166 06				db 5 + 1 
b167 .. 00			db "-LOOP",0              
b16d				endm 
# End of macro CWHEAD
b16d			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b16d				; pop tos as current loop count to hl 
b16d					if DEBUG_FORTH_WORDS_KEY 
b16d						DMARK "-LP" 
b16d f5				push af  
b16e 3a 82 b1			ld a, (.dmark)  
b171 32 6b ee			ld (debug_mark),a  
b174 3a 83 b1			ld a, (.dmark+1)  
b177 32 6c ee			ld (debug_mark+1),a  
b17a 3a 84 b1			ld a, (.dmark+2)  
b17d 32 6d ee			ld (debug_mark+2),a  
b180 18 03			jr .pastdmark  
b182 ..			.dmark: db "-LP"  
b185 f1			.pastdmark: pop af  
b186			endm  
# End of macro DMARK
b186						CALLMONITOR 
b186 cd 6f ee			call debug_vector  
b189				endm  
# End of macro CALLMONITOR
b189					endif 
b189			 
b189				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b189			 
b189				FORTH_LOOP_TOS 
b189 cd d7 9c			call macro_forth_loop_tos 
b18c				endm 
# End of macro FORTH_LOOP_TOS
b18c e5				push hl 
b18d			 
b18d					if DEBUG_FORTH_WORDS 
b18d						DMARK "-LP" 
b18d f5				push af  
b18e 3a a2 b1			ld a, (.dmark)  
b191 32 6b ee			ld (debug_mark),a  
b194 3a a3 b1			ld a, (.dmark+1)  
b197 32 6c ee			ld (debug_mark+1),a  
b19a 3a a4 b1			ld a, (.dmark+2)  
b19d 32 6d ee			ld (debug_mark+2),a  
b1a0 18 03			jr .pastdmark  
b1a2 ..			.dmark: db "-LP"  
b1a5 f1			.pastdmark: pop af  
b1a6			endm  
# End of macro DMARK
b1a6						CALLMONITOR 
b1a6 cd 6f ee			call debug_vector  
b1a9				endm  
# End of macro CALLMONITOR
b1a9					endif 
b1a9				; next item on the stack is the limit. get it 
b1a9			 
b1a9			 
b1a9				FORTH_LOOP_POP 
b1a9 cd e1 9c			call macro_forth_loop_pop 
b1ac				endm 
# End of macro FORTH_LOOP_POP
b1ac			 
b1ac				FORTH_LOOP_TOS 
b1ac cd d7 9c			call macro_forth_loop_tos 
b1af				endm 
# End of macro FORTH_LOOP_TOS
b1af			 
b1af d1				pop de		 ; de = i, hl = limit 
b1b0			 
b1b0					if DEBUG_FORTH_WORDS 
b1b0						DMARK "-L1" 
b1b0 f5				push af  
b1b1 3a c5 b1			ld a, (.dmark)  
b1b4 32 6b ee			ld (debug_mark),a  
b1b7 3a c6 b1			ld a, (.dmark+1)  
b1ba 32 6c ee			ld (debug_mark+1),a  
b1bd 3a c7 b1			ld a, (.dmark+2)  
b1c0 32 6d ee			ld (debug_mark+2),a  
b1c3 18 03			jr .pastdmark  
b1c5 ..			.dmark: db "-L1"  
b1c8 f1			.pastdmark: pop af  
b1c9			endm  
# End of macro DMARK
b1c9						CALLMONITOR 
b1c9 cd 6f ee			call debug_vector  
b1cc				endm  
# End of macro CALLMONITOR
b1cc					endif 
b1cc			 
b1cc				; go back to previous word 
b1cc			 
b1cc d5				push de    ; save I for inc later 
b1cd			 
b1cd			 
b1cd				; get limit 
b1cd				;  is I at limit? 
b1cd			 
b1cd			 
b1cd					if DEBUG_FORTH_WORDS 
b1cd						DMARK "-L1" 
b1cd f5				push af  
b1ce 3a e2 b1			ld a, (.dmark)  
b1d1 32 6b ee			ld (debug_mark),a  
b1d4 3a e3 b1			ld a, (.dmark+1)  
b1d7 32 6c ee			ld (debug_mark+1),a  
b1da 3a e4 b1			ld a, (.dmark+2)  
b1dd 32 6d ee			ld (debug_mark+2),a  
b1e0 18 03			jr .pastdmark  
b1e2 ..			.dmark: db "-L1"  
b1e5 f1			.pastdmark: pop af  
b1e6			endm  
# End of macro DMARK
b1e6						CALLMONITOR 
b1e6 cd 6f ee			call debug_vector  
b1e9				endm  
# End of macro CALLMONITOR
b1e9					endif 
b1e9			 
b1e9 ed 52			sbc hl, de 
b1eb			 
b1eb			 
b1eb				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b1eb			 
b1eb 20 26				jr nz, .mloopnotdone 
b1ed			 
b1ed e1				pop hl   ; get rid of saved I 
b1ee				FORTH_LOOP_POP     ; get rid of limit 
b1ee cd e1 9c			call macro_forth_loop_pop 
b1f1				endm 
# End of macro FORTH_LOOP_POP
b1f1			 
b1f1				FORTH_RSP_POP     ; get rid of DO ptr 
b1f1 cd 36 9a			call macro_forth_rsp_pop 
b1f4				endm 
# End of macro FORTH_RSP_POP
b1f4			 
b1f4			if DEBUG_FORTH_WORDS 
b1f4						DMARK "-L>" 
b1f4 f5				push af  
b1f5 3a 09 b2			ld a, (.dmark)  
b1f8 32 6b ee			ld (debug_mark),a  
b1fb 3a 0a b2			ld a, (.dmark+1)  
b1fe 32 6c ee			ld (debug_mark+1),a  
b201 3a 0b b2			ld a, (.dmark+2)  
b204 32 6d ee			ld (debug_mark+2),a  
b207 18 03			jr .pastdmark  
b209 ..			.dmark: db "-L>"  
b20c f1			.pastdmark: pop af  
b20d			endm  
# End of macro DMARK
b20d				CALLMONITOR 
b20d cd 6f ee			call debug_vector  
b210				endm  
# End of macro CALLMONITOR
b210			endif 
b210			 
b210					NEXTW 
b210 c3 29 9e			jp macro_next 
b213				endm 
# End of macro NEXTW
b213				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b213			 
b213			.mloopnotdone: 
b213			 
b213 e1				pop hl    ; get I 
b214 2b				dec hl 
b215			 
b215			   	; save new I 
b215			 
b215			 
b215					; set I counter 
b215			 
b215 22 e6 e5				ld (os_current_i), hl 
b218			 
b218					 
b218				FORTH_LOOP_NEXT 
b218 cd a4 9c			call macro_forth_loop_next 
b21b				endm 
# End of macro FORTH_LOOP_NEXT
b21b			 
b21b			 
b21b					if DEBUG_FORTH_WORDS 
b21b eb						ex de,hl 
b21c					endif 
b21c			 
b21c			;	; get DO ptr 
b21c			; 
b21c				FORTH_RSP_TOS 
b21c cd 2c 9a			call macro_forth_rsp_tos 
b21f				endm 
# End of macro FORTH_RSP_TOS
b21f			 
b21f				;push hl 
b21f			 
b21f				; not going to DO any more 
b21f				; get rid of the RSP pointer as DO will add it back in 
b21f				;FORTH_RSP_POP 
b21f				;pop hl 
b21f			 
b21f			 
b21f 22 c2 e5			ld (os_tok_ptr), hl 
b222					if DEBUG_FORTH_WORDS 
b222						DMARK "-L<" 
b222 f5				push af  
b223 3a 37 b2			ld a, (.dmark)  
b226 32 6b ee			ld (debug_mark),a  
b229 3a 38 b2			ld a, (.dmark+1)  
b22c 32 6c ee			ld (debug_mark+1),a  
b22f 3a 39 b2			ld a, (.dmark+2)  
b232 32 6d ee			ld (debug_mark+2),a  
b235 18 03			jr .pastdmark  
b237 ..			.dmark: db "-L<"  
b23a f1			.pastdmark: pop af  
b23b			endm  
# End of macro DMARK
b23b					CALLMONITOR 
b23b cd 6f ee			call debug_vector  
b23e				endm  
# End of macro CALLMONITOR
b23e				endif 
b23e c3 ba 9e			jp exec1 
b241			 
b241					 
b241			 
b241			 
b241			 
b241				NEXTW 
b241 c3 29 9e			jp macro_next 
b244				endm 
# End of macro NEXTW
b244			 
b244			 
b244			 
b244			 
b244			.REPEAT: 
b244				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b244 71				db WORD_SYS_CORE+93             
b245 97 b2			dw .UNTIL            
b247 06				db 5 + 1 
b248 .. 00			db "REPEAT",0              
b24f				endm 
# End of macro CWHEAD
b24f			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b24f			;  push pc to rsp stack past the REPEAT 
b24f					if DEBUG_FORTH_WORDS_KEY 
b24f						DMARK "REP" 
b24f f5				push af  
b250 3a 64 b2			ld a, (.dmark)  
b253 32 6b ee			ld (debug_mark),a  
b256 3a 65 b2			ld a, (.dmark+1)  
b259 32 6c ee			ld (debug_mark+1),a  
b25c 3a 66 b2			ld a, (.dmark+2)  
b25f 32 6d ee			ld (debug_mark+2),a  
b262 18 03			jr .pastdmark  
b264 ..			.dmark: db "REP"  
b267 f1			.pastdmark: pop af  
b268			endm  
# End of macro DMARK
b268						CALLMONITOR 
b268 cd 6f ee			call debug_vector  
b26b				endm  
# End of macro CALLMONITOR
b26b					endif 
b26b			 
b26b 2a c2 e5				ld hl, (os_tok_ptr) 
b26e 23					inc hl   ; R 
b26f 23					inc hl  ; E 
b270 23					inc hl   ; P 
b271 23					inc hl   ; E 
b272 23					inc hl   ; A 
b273 23					inc hl   ; T 
b274 23					inc hl   ; zero 
b275					FORTH_RSP_NEXT 
b275 cd 15 9a			call macro_forth_rsp_next 
b278				endm 
# End of macro FORTH_RSP_NEXT
b278			 
b278			 
b278					if DEBUG_FORTH_WORDS 
b278						DMARK "REP" 
b278 f5				push af  
b279 3a 8d b2			ld a, (.dmark)  
b27c 32 6b ee			ld (debug_mark),a  
b27f 3a 8e b2			ld a, (.dmark+1)  
b282 32 6c ee			ld (debug_mark+1),a  
b285 3a 8f b2			ld a, (.dmark+2)  
b288 32 6d ee			ld (debug_mark+2),a  
b28b 18 03			jr .pastdmark  
b28d ..			.dmark: db "REP"  
b290 f1			.pastdmark: pop af  
b291			endm  
# End of macro DMARK
b291						;pop bc    ; TODO BUG ?????? what is this for???? 
b291						CALLMONITOR 
b291 cd 6f ee			call debug_vector  
b294				endm  
# End of macro CALLMONITOR
b294					endif 
b294			 
b294					NEXTW 
b294 c3 29 9e			jp macro_next 
b297				endm 
# End of macro NEXTW
b297			;	       NEXTW 
b297			 
b297			.UNTIL: 
b297				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b297 72				db WORD_SYS_CORE+94             
b298 2e b3			dw .ENDFLOW            
b29a 06				db 5 + 1 
b29b .. 00			db "UNTIL",0              
b2a1				endm 
# End of macro CWHEAD
b2a1			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b2a1			 
b2a1				; pop tos as check 
b2a1			 
b2a1				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b2a1			 
b2a1				FORTH_DSP_VALUEHL 
b2a1 cd 73 9c			call macro_dsp_valuehl 
b2a4				endm 
# End of macro FORTH_DSP_VALUEHL
b2a4			 
b2a4					if DEBUG_FORTH_WORDS_KEY 
b2a4						DMARK "UNT" 
b2a4 f5				push af  
b2a5 3a b9 b2			ld a, (.dmark)  
b2a8 32 6b ee			ld (debug_mark),a  
b2ab 3a ba b2			ld a, (.dmark+1)  
b2ae 32 6c ee			ld (debug_mark+1),a  
b2b1 3a bb b2			ld a, (.dmark+2)  
b2b4 32 6d ee			ld (debug_mark+2),a  
b2b7 18 03			jr .pastdmark  
b2b9 ..			.dmark: db "UNT"  
b2bc f1			.pastdmark: pop af  
b2bd			endm  
# End of macro DMARK
b2bd						CALLMONITOR 
b2bd cd 6f ee			call debug_vector  
b2c0				endm  
# End of macro CALLMONITOR
b2c0					endif 
b2c0			 
b2c0			;	push hl 
b2c0				FORTH_DSP_POP 
b2c0 cd 2b 9d			call macro_forth_dsp_pop 
b2c3				endm 
# End of macro FORTH_DSP_POP
b2c3			 
b2c3			;	pop hl 
b2c3			 
b2c3				; test if true 
b2c3			 
b2c3 cd 10 8d			call ishlzero 
b2c6			;	ld a,l 
b2c6			;	add h 
b2c6			; 
b2c6			;	cp 0 
b2c6			 
b2c6 20 3e			jr nz, .untilnotdone 
b2c8			 
b2c8					if DEBUG_FORTH_WORDS 
b2c8						DMARK "UNf" 
b2c8 f5				push af  
b2c9 3a dd b2			ld a, (.dmark)  
b2cc 32 6b ee			ld (debug_mark),a  
b2cf 3a de b2			ld a, (.dmark+1)  
b2d2 32 6c ee			ld (debug_mark+1),a  
b2d5 3a df b2			ld a, (.dmark+2)  
b2d8 32 6d ee			ld (debug_mark+2),a  
b2db 18 03			jr .pastdmark  
b2dd ..			.dmark: db "UNf"  
b2e0 f1			.pastdmark: pop af  
b2e1			endm  
# End of macro DMARK
b2e1						CALLMONITOR 
b2e1 cd 6f ee			call debug_vector  
b2e4				endm  
# End of macro CALLMONITOR
b2e4					endif 
b2e4			 
b2e4			 
b2e4			 
b2e4				FORTH_RSP_POP     ; get rid of DO ptr 
b2e4 cd 36 9a			call macro_forth_rsp_pop 
b2e7				endm 
# End of macro FORTH_RSP_POP
b2e7			 
b2e7			if DEBUG_FORTH_WORDS 
b2e7						DMARK "UN>" 
b2e7 f5				push af  
b2e8 3a fc b2			ld a, (.dmark)  
b2eb 32 6b ee			ld (debug_mark),a  
b2ee 3a fd b2			ld a, (.dmark+1)  
b2f1 32 6c ee			ld (debug_mark+1),a  
b2f4 3a fe b2			ld a, (.dmark+2)  
b2f7 32 6d ee			ld (debug_mark+2),a  
b2fa 18 03			jr .pastdmark  
b2fc ..			.dmark: db "UN>"  
b2ff f1			.pastdmark: pop af  
b300			endm  
# End of macro DMARK
b300				CALLMONITOR 
b300 cd 6f ee			call debug_vector  
b303				endm  
# End of macro CALLMONITOR
b303			endif 
b303			 
b303					NEXTW 
b303 c3 29 9e			jp macro_next 
b306				endm 
# End of macro NEXTW
b306				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b306			 
b306			.untilnotdone: 
b306			 
b306			 
b306			;	; get DO ptr 
b306			; 
b306				FORTH_RSP_TOS 
b306 cd 2c 9a			call macro_forth_rsp_tos 
b309				endm 
# End of macro FORTH_RSP_TOS
b309			 
b309				;push hl 
b309			 
b309				; not going to DO any more 
b309				; get rid of the RSP pointer as DO will add it back in 
b309				;FORTH_RSP_POP 
b309				;pop hl 
b309			 
b309			 
b309 22 c2 e5			ld (os_tok_ptr), hl 
b30c					if DEBUG_FORTH_WORDS 
b30c						DMARK "UN<" 
b30c f5				push af  
b30d 3a 21 b3			ld a, (.dmark)  
b310 32 6b ee			ld (debug_mark),a  
b313 3a 22 b3			ld a, (.dmark+1)  
b316 32 6c ee			ld (debug_mark+1),a  
b319 3a 23 b3			ld a, (.dmark+2)  
b31c 32 6d ee			ld (debug_mark+2),a  
b31f 18 03			jr .pastdmark  
b321 ..			.dmark: db "UN<"  
b324 f1			.pastdmark: pop af  
b325			endm  
# End of macro DMARK
b325					CALLMONITOR 
b325 cd 6f ee			call debug_vector  
b328				endm  
# End of macro CALLMONITOR
b328				endif 
b328 c3 ba 9e			jp exec1 
b32b			 
b32b					 
b32b			 
b32b			 
b32b					NEXTW 
b32b c3 29 9e			jp macro_next 
b32e				endm 
# End of macro NEXTW
b32e			 
b32e			 
b32e			.ENDFLOW: 
b32e			 
b32e			; eof 
b32e			 
# End of file forth_words_flow.asm
b32e			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b32e			include "forth_words_logic.asm" 
b32e			 
b32e			; | ## Logic Words 
b32e			 
b32e			.NOT: 
b32e				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b32e 2d				db WORD_SYS_CORE+25             
b32f 76 b3			dw .IS            
b331 04				db 3 + 1 
b332 .. 00			db "NOT",0              
b336				endm 
# End of macro CWHEAD
b336			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b336					if DEBUG_FORTH_WORDS_KEY 
b336						DMARK "NOT" 
b336 f5				push af  
b337 3a 4b b3			ld a, (.dmark)  
b33a 32 6b ee			ld (debug_mark),a  
b33d 3a 4c b3			ld a, (.dmark+1)  
b340 32 6c ee			ld (debug_mark+1),a  
b343 3a 4d b3			ld a, (.dmark+2)  
b346 32 6d ee			ld (debug_mark+2),a  
b349 18 03			jr .pastdmark  
b34b ..			.dmark: db "NOT"  
b34e f1			.pastdmark: pop af  
b34f			endm  
# End of macro DMARK
b34f						CALLMONITOR 
b34f cd 6f ee			call debug_vector  
b352				endm  
# End of macro CALLMONITOR
b352					endif 
b352					FORTH_DSP 
b352 cd 39 9c			call macro_forth_dsp 
b355				endm 
# End of macro FORTH_DSP
b355 7e					ld a,(hl)	; get type of value on TOS 
b356 fe 02				cp DS_TYPE_INUM  
b358 28 03				jr z, .noti 
b35a					NEXTW 
b35a c3 29 9e			jp macro_next 
b35d				endm 
# End of macro NEXTW
b35d			.noti:          FORTH_DSP_VALUEHL 
b35d cd 73 9c			call macro_dsp_valuehl 
b360				endm 
# End of macro FORTH_DSP_VALUEHL
b360			;		push hl 
b360					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b360 cd 2b 9d			call macro_forth_dsp_pop 
b363				endm 
# End of macro FORTH_DSP_POP
b363			;		pop hl 
b363 3e 00				ld a,0 
b365 bd					cp l 
b366 28 04				jr z, .not2t 
b368 2e 00				ld l, 0 
b36a 18 02				jr .notip 
b36c			 
b36c 2e ff		.not2t:		ld l, 255 
b36e			 
b36e 26 00		.notip:		ld h, 0	 
b370			 
b370 cd 6e 9a				call forth_push_numhl 
b373					NEXTW 
b373 c3 29 9e			jp macro_next 
b376				endm 
# End of macro NEXTW
b376			 
b376			.IS: 
b376				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b376 2d				db WORD_SYS_CORE+25             
b377 9c b3			dw .LZERO            
b379 03				db 2 + 1 
b37a .. 00			db "IS",0              
b37d				endm 
# End of macro CWHEAD
b37d			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b37d					if DEBUG_FORTH_WORDS_KEY 
b37d						DMARK "IS." 
b37d f5				push af  
b37e 3a 92 b3			ld a, (.dmark)  
b381 32 6b ee			ld (debug_mark),a  
b384 3a 93 b3			ld a, (.dmark+1)  
b387 32 6c ee			ld (debug_mark+1),a  
b38a 3a 94 b3			ld a, (.dmark+2)  
b38d 32 6d ee			ld (debug_mark+2),a  
b390 18 03			jr .pastdmark  
b392 ..			.dmark: db "IS."  
b395 f1			.pastdmark: pop af  
b396			endm  
# End of macro DMARK
b396						CALLMONITOR 
b396 cd 6f ee			call debug_vector  
b399				endm  
# End of macro CALLMONITOR
b399					endif 
b399					NEXTW 
b399 c3 29 9e			jp macro_next 
b39c				endm 
# End of macro NEXTW
b39c			.LZERO: 
b39c				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b39c 2d				db WORD_SYS_CORE+25             
b39d a6 b3			dw .TZERO            
b39f 03				db 2 + 1 
b3a0 .. 00			db "0<",0              
b3a3				endm 
# End of macro CWHEAD
b3a3			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b3a3					NEXTW 
b3a3 c3 29 9e			jp macro_next 
b3a6				endm 
# End of macro NEXTW
b3a6			.TZERO: 
b3a6				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b3a6 2e				db WORD_SYS_CORE+26             
b3a7 ed b3			dw .LESS            
b3a9 03				db 2 + 1 
b3aa .. 00			db "0=",0              
b3ad				endm 
# End of macro CWHEAD
b3ad			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
b3ad				; TODO add floating point number detection 
b3ad					;v5 FORTH_DSP_VALUE 
b3ad					if DEBUG_FORTH_WORDS_KEY 
b3ad						DMARK "0=." 
b3ad f5				push af  
b3ae 3a c2 b3			ld a, (.dmark)  
b3b1 32 6b ee			ld (debug_mark),a  
b3b4 3a c3 b3			ld a, (.dmark+1)  
b3b7 32 6c ee			ld (debug_mark+1),a  
b3ba 3a c4 b3			ld a, (.dmark+2)  
b3bd 32 6d ee			ld (debug_mark+2),a  
b3c0 18 03			jr .pastdmark  
b3c2 ..			.dmark: db "0=."  
b3c5 f1			.pastdmark: pop af  
b3c6			endm  
# End of macro DMARK
b3c6						CALLMONITOR 
b3c6 cd 6f ee			call debug_vector  
b3c9				endm  
# End of macro CALLMONITOR
b3c9					endif 
b3c9					FORTH_DSP 
b3c9 cd 39 9c			call macro_forth_dsp 
b3cc				endm 
# End of macro FORTH_DSP
b3cc 7e					ld a,(hl)	; get type of value on TOS 
b3cd fe 02				cp DS_TYPE_INUM  
b3cf 28 00				jr z, .tz_inum 
b3d1			 
b3d1				if FORTH_ENABLE_FLOATMATH 
b3d1					jr .tz_done 
b3d1			 
b3d1				endif 
b3d1					 
b3d1			 
b3d1			.tz_inum: 
b3d1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3d1 cd 73 9c			call macro_dsp_valuehl 
b3d4				endm 
# End of macro FORTH_DSP_VALUEHL
b3d4			 
b3d4			;		push hl 
b3d4			 
b3d4					; destroy value TOS 
b3d4			 
b3d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3d4 cd 2b 9d			call macro_forth_dsp_pop 
b3d7				endm 
# End of macro FORTH_DSP_POP
b3d7			 
b3d7			;		pop hl 
b3d7			 
b3d7 3e 00				ld a,0 
b3d9			 
b3d9 bd					cp l 
b3da 20 08				jr nz, .tz_notzero 
b3dc			 
b3dc bc					cp h 
b3dd			 
b3dd 20 05				jr nz, .tz_notzero 
b3df			 
b3df			 
b3df 21 01 00				ld hl, FORTH_TRUE 
b3e2 18 03				jr .tz_done 
b3e4			 
b3e4 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b3e7			 
b3e7					; push value back onto stack for another op etc 
b3e7			 
b3e7			.tz_done: 
b3e7 cd 6e 9a				call forth_push_numhl 
b3ea			 
b3ea					NEXTW 
b3ea c3 29 9e			jp macro_next 
b3ed				endm 
# End of macro NEXTW
b3ed			.LESS: 
b3ed				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b3ed 2f				db WORD_SYS_CORE+27             
b3ee 56 b4			dw .GT            
b3f0 02				db 1 + 1 
b3f1 .. 00			db "<",0              
b3f3				endm 
# End of macro CWHEAD
b3f3			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b3f3				; TODO add floating point number detection 
b3f3					if DEBUG_FORTH_WORDS_KEY 
b3f3						DMARK "LES" 
b3f3 f5				push af  
b3f4 3a 08 b4			ld a, (.dmark)  
b3f7 32 6b ee			ld (debug_mark),a  
b3fa 3a 09 b4			ld a, (.dmark+1)  
b3fd 32 6c ee			ld (debug_mark+1),a  
b400 3a 0a b4			ld a, (.dmark+2)  
b403 32 6d ee			ld (debug_mark+2),a  
b406 18 03			jr .pastdmark  
b408 ..			.dmark: db "LES"  
b40b f1			.pastdmark: pop af  
b40c			endm  
# End of macro DMARK
b40c						CALLMONITOR 
b40c cd 6f ee			call debug_vector  
b40f				endm  
# End of macro CALLMONITOR
b40f					endif 
b40f					FORTH_DSP 
b40f cd 39 9c			call macro_forth_dsp 
b412				endm 
# End of macro FORTH_DSP
b412					;v5 FORTH_DSP_VALUE 
b412 7e					ld a,(hl)	; get type of value on TOS 
b413 fe 02				cp DS_TYPE_INUM  
b415 28 00				jr z, .less_inum 
b417			 
b417				if FORTH_ENABLE_FLOATMATH 
b417					jr .less_done 
b417			 
b417				endif 
b417					 
b417			 
b417			.less_inum: 
b417					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b417 cd 73 9c			call macro_dsp_valuehl 
b41a				endm 
# End of macro FORTH_DSP_VALUEHL
b41a			 
b41a e5					push hl  ; u2 
b41b			 
b41b					; destroy value TOS 
b41b			 
b41b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b41b cd 2b 9d			call macro_forth_dsp_pop 
b41e				endm 
# End of macro FORTH_DSP_POP
b41e			 
b41e			 
b41e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b41e cd 73 9c			call macro_dsp_valuehl 
b421				endm 
# End of macro FORTH_DSP_VALUEHL
b421			 
b421 e5					push hl    ; u1 
b422			 
b422					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b422 cd 2b 9d			call macro_forth_dsp_pop 
b425				endm 
# End of macro FORTH_DSP_POP
b425			 
b425			 
b425 b7			 or a      ;clear carry flag 
b426 01 00 00		 ld bc, FORTH_FALSE 
b429 e1			  pop hl    ; u1 
b42a d1			  pop de    ; u2 
b42b ed 52		  sbc hl,de 
b42d 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b42f			 
b42f 01 01 00		 ld bc, FORTH_TRUE 
b432			.lscont:  
b432 c5					push bc 
b433 e1					pop hl 
b434			 
b434					if DEBUG_FORTH_WORDS 
b434						DMARK "LT1" 
b434 f5				push af  
b435 3a 49 b4			ld a, (.dmark)  
b438 32 6b ee			ld (debug_mark),a  
b43b 3a 4a b4			ld a, (.dmark+1)  
b43e 32 6c ee			ld (debug_mark+1),a  
b441 3a 4b b4			ld a, (.dmark+2)  
b444 32 6d ee			ld (debug_mark+2),a  
b447 18 03			jr .pastdmark  
b449 ..			.dmark: db "LT1"  
b44c f1			.pastdmark: pop af  
b44d			endm  
# End of macro DMARK
b44d						CALLMONITOR 
b44d cd 6f ee			call debug_vector  
b450				endm  
# End of macro CALLMONITOR
b450					endif 
b450 cd 6e 9a				call forth_push_numhl 
b453			 
b453					NEXTW 
b453 c3 29 9e			jp macro_next 
b456				endm 
# End of macro NEXTW
b456			.GT: 
b456				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b456 30				db WORD_SYS_CORE+28             
b457 bf b4			dw .EQUAL            
b459 02				db 1 + 1 
b45a .. 00			db ">",0              
b45c				endm 
# End of macro CWHEAD
b45c			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b45c				; TODO add floating point number detection 
b45c					if DEBUG_FORTH_WORDS_KEY 
b45c						DMARK "GRT" 
b45c f5				push af  
b45d 3a 71 b4			ld a, (.dmark)  
b460 32 6b ee			ld (debug_mark),a  
b463 3a 72 b4			ld a, (.dmark+1)  
b466 32 6c ee			ld (debug_mark+1),a  
b469 3a 73 b4			ld a, (.dmark+2)  
b46c 32 6d ee			ld (debug_mark+2),a  
b46f 18 03			jr .pastdmark  
b471 ..			.dmark: db "GRT"  
b474 f1			.pastdmark: pop af  
b475			endm  
# End of macro DMARK
b475						CALLMONITOR 
b475 cd 6f ee			call debug_vector  
b478				endm  
# End of macro CALLMONITOR
b478					endif 
b478					FORTH_DSP 
b478 cd 39 9c			call macro_forth_dsp 
b47b				endm 
# End of macro FORTH_DSP
b47b					;FORTH_DSP_VALUE 
b47b 7e					ld a,(hl)	; get type of value on TOS 
b47c fe 02				cp DS_TYPE_INUM  
b47e 28 00				jr z, .gt_inum 
b480			 
b480				if FORTH_ENABLE_FLOATMATH 
b480					jr .gt_done 
b480			 
b480				endif 
b480					 
b480			 
b480			.gt_inum: 
b480					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b480 cd 73 9c			call macro_dsp_valuehl 
b483				endm 
# End of macro FORTH_DSP_VALUEHL
b483			 
b483 e5					push hl  ; u2 
b484			 
b484					; destroy value TOS 
b484			 
b484					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b484 cd 2b 9d			call macro_forth_dsp_pop 
b487				endm 
# End of macro FORTH_DSP_POP
b487			 
b487			 
b487					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b487 cd 73 9c			call macro_dsp_valuehl 
b48a				endm 
# End of macro FORTH_DSP_VALUEHL
b48a			 
b48a e5					push hl    ; u1 
b48b			 
b48b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b48b cd 2b 9d			call macro_forth_dsp_pop 
b48e				endm 
# End of macro FORTH_DSP_POP
b48e			 
b48e			 
b48e b7			 or a      ;clear carry flag 
b48f 01 00 00		 ld bc, FORTH_FALSE 
b492 e1			  pop hl    ; u1 
b493 d1			  pop de    ; u2 
b494 ed 52		  sbc hl,de 
b496 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b498			 
b498 01 01 00		 ld bc, FORTH_TRUE 
b49b			.gtcont:  
b49b c5					push bc 
b49c e1					pop hl 
b49d			 
b49d					if DEBUG_FORTH_WORDS 
b49d						DMARK "GT1" 
b49d f5				push af  
b49e 3a b2 b4			ld a, (.dmark)  
b4a1 32 6b ee			ld (debug_mark),a  
b4a4 3a b3 b4			ld a, (.dmark+1)  
b4a7 32 6c ee			ld (debug_mark+1),a  
b4aa 3a b4 b4			ld a, (.dmark+2)  
b4ad 32 6d ee			ld (debug_mark+2),a  
b4b0 18 03			jr .pastdmark  
b4b2 ..			.dmark: db "GT1"  
b4b5 f1			.pastdmark: pop af  
b4b6			endm  
# End of macro DMARK
b4b6						CALLMONITOR 
b4b6 cd 6f ee			call debug_vector  
b4b9				endm  
# End of macro CALLMONITOR
b4b9					endif 
b4b9 cd 6e 9a				call forth_push_numhl 
b4bc			 
b4bc					NEXTW 
b4bc c3 29 9e			jp macro_next 
b4bf				endm 
# End of macro NEXTW
b4bf			.EQUAL: 
b4bf				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b4bf 31				db WORD_SYS_CORE+29             
b4c0 2a b5			dw .ENDLOGIC            
b4c2 02				db 1 + 1 
b4c3 .. 00			db "=",0              
b4c5				endm 
# End of macro CWHEAD
b4c5			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b4c5				; TODO add floating point number detection 
b4c5					if DEBUG_FORTH_WORDS_KEY 
b4c5						DMARK "EQ." 
b4c5 f5				push af  
b4c6 3a da b4			ld a, (.dmark)  
b4c9 32 6b ee			ld (debug_mark),a  
b4cc 3a db b4			ld a, (.dmark+1)  
b4cf 32 6c ee			ld (debug_mark+1),a  
b4d2 3a dc b4			ld a, (.dmark+2)  
b4d5 32 6d ee			ld (debug_mark+2),a  
b4d8 18 03			jr .pastdmark  
b4da ..			.dmark: db "EQ."  
b4dd f1			.pastdmark: pop af  
b4de			endm  
# End of macro DMARK
b4de						CALLMONITOR 
b4de cd 6f ee			call debug_vector  
b4e1				endm  
# End of macro CALLMONITOR
b4e1					endif 
b4e1					FORTH_DSP 
b4e1 cd 39 9c			call macro_forth_dsp 
b4e4				endm 
# End of macro FORTH_DSP
b4e4					;v5 FORTH_DSP_VALUE 
b4e4 7e					ld a,(hl)	; get type of value on TOS 
b4e5 fe 02				cp DS_TYPE_INUM  
b4e7 28 00				jr z, .eq_inum 
b4e9			 
b4e9				if FORTH_ENABLE_FLOATMATH 
b4e9					jr .eq_done 
b4e9			 
b4e9				endif 
b4e9					 
b4e9			 
b4e9			.eq_inum: 
b4e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4e9 cd 73 9c			call macro_dsp_valuehl 
b4ec				endm 
# End of macro FORTH_DSP_VALUEHL
b4ec			 
b4ec e5					push hl 
b4ed			 
b4ed					; destroy value TOS 
b4ed			 
b4ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4ed cd 2b 9d			call macro_forth_dsp_pop 
b4f0				endm 
# End of macro FORTH_DSP_POP
b4f0			 
b4f0			 
b4f0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4f0 cd 73 9c			call macro_dsp_valuehl 
b4f3				endm 
# End of macro FORTH_DSP_VALUEHL
b4f3			 
b4f3					; one value on hl get other one back 
b4f3			 
b4f3 e5					push hl 
b4f4			 
b4f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4f4 cd 2b 9d			call macro_forth_dsp_pop 
b4f7				endm 
# End of macro FORTH_DSP_POP
b4f7			 
b4f7 0e 00				ld c, FORTH_FALSE 
b4f9			 
b4f9 e1					pop hl 
b4fa d1					pop de 
b4fb			 
b4fb 7b					ld a, e 
b4fc bd					cp l 
b4fd			 
b4fd 20 06				jr nz, .eq_done 
b4ff			 
b4ff 7a					ld a, d 
b500 bc					cp h 
b501			 
b501 20 02				jr nz, .eq_done 
b503			 
b503 0e 01				ld c, FORTH_TRUE 
b505					 
b505			 
b505			 
b505			.eq_done: 
b505			 
b505					; TODO push value back onto stack for another op etc 
b505			 
b505 26 00				ld h, 0 
b507 69					ld l, c 
b508					if DEBUG_FORTH_WORDS 
b508						DMARK "EQ1" 
b508 f5				push af  
b509 3a 1d b5			ld a, (.dmark)  
b50c 32 6b ee			ld (debug_mark),a  
b50f 3a 1e b5			ld a, (.dmark+1)  
b512 32 6c ee			ld (debug_mark+1),a  
b515 3a 1f b5			ld a, (.dmark+2)  
b518 32 6d ee			ld (debug_mark+2),a  
b51b 18 03			jr .pastdmark  
b51d ..			.dmark: db "EQ1"  
b520 f1			.pastdmark: pop af  
b521			endm  
# End of macro DMARK
b521						CALLMONITOR 
b521 cd 6f ee			call debug_vector  
b524				endm  
# End of macro CALLMONITOR
b524					endif 
b524 cd 6e 9a				call forth_push_numhl 
b527			 
b527					NEXTW 
b527 c3 29 9e			jp macro_next 
b52a				endm 
# End of macro NEXTW
b52a			 
b52a			 
b52a			.ENDLOGIC: 
b52a			; eof 
b52a			 
b52a			 
# End of file forth_words_logic.asm
b52a			include "forth_words_maths.asm" 
b52a			 
b52a			; | ## Maths Words 
b52a			 
b52a			.PLUS:	 
b52a				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b52a 15				db WORD_SYS_CORE+1             
b52b 88 b5			dw .NEG            
b52d 02				db 1 + 1 
b52e .. 00			db "+",0              
b530				endm 
# End of macro CWHEAD
b530			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b530					if DEBUG_FORTH_WORDS_KEY 
b530						DMARK "PLU" 
b530 f5				push af  
b531 3a 45 b5			ld a, (.dmark)  
b534 32 6b ee			ld (debug_mark),a  
b537 3a 46 b5			ld a, (.dmark+1)  
b53a 32 6c ee			ld (debug_mark+1),a  
b53d 3a 47 b5			ld a, (.dmark+2)  
b540 32 6d ee			ld (debug_mark+2),a  
b543 18 03			jr .pastdmark  
b545 ..			.dmark: db "PLU"  
b548 f1			.pastdmark: pop af  
b549			endm  
# End of macro DMARK
b549						CALLMONITOR 
b549 cd 6f ee			call debug_vector  
b54c				endm  
# End of macro CALLMONITOR
b54c					endif 
b54c					; add top two values and push back result 
b54c			 
b54c					;for v5 FORTH_DSP_VALUE 
b54c					FORTH_DSP 
b54c cd 39 9c			call macro_forth_dsp 
b54f				endm 
# End of macro FORTH_DSP
b54f 7e					ld a,(hl)	; get type of value on TOS 
b550 fe 02				cp DS_TYPE_INUM  
b552 28 03				jr z, .dot_inum 
b554			 
b554					NEXTW 
b554 c3 29 9e			jp macro_next 
b557				endm 
# End of macro NEXTW
b557			 
b557			; float maths 
b557			 
b557				if FORTH_ENABLE_FLOATMATH 
b557						inc hl      ; now at start of numeric as string 
b557			 
b557					if DEBUG_FORTH_MATHS 
b557						DMARK "ADD" 
b557				CALLMONITOR 
b557					endif 
b557			 
b557					;ld ix, hl 
b557					call CON 
b557			 
b557			 
b557					push hl 
b557					 
b557					 
b557			 
b557						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b557			 
b557					; get next number 
b557			 
b557						FORTH_DSP_VALUE 
b557			 
b557						inc hl      ; now at start of numeric as string 
b557			 
b557					;ld ix, hl 
b557					call CON 
b557			 
b557					push hl 
b557			 
b557			 
b557						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b557			 
b557						; TODO do add 
b557			 
b557						call IADD 
b557			 
b557						; TODO get result back as ascii 
b557			 
b557						; TODO push result  
b557			 
b557			 
b557			 
b557						jr .dot_done 
b557				endif 
b557			 
b557			.dot_inum: 
b557			 
b557			 
b557					if DEBUG_FORTH_DOT 
b557						DMARK "+IT" 
b557 f5				push af  
b558 3a 6c b5			ld a, (.dmark)  
b55b 32 6b ee			ld (debug_mark),a  
b55e 3a 6d b5			ld a, (.dmark+1)  
b561 32 6c ee			ld (debug_mark+1),a  
b564 3a 6e b5			ld a, (.dmark+2)  
b567 32 6d ee			ld (debug_mark+2),a  
b56a 18 03			jr .pastdmark  
b56c ..			.dmark: db "+IT"  
b56f f1			.pastdmark: pop af  
b570			endm  
# End of macro DMARK
b570				CALLMONITOR 
b570 cd 6f ee			call debug_vector  
b573				endm  
# End of macro CALLMONITOR
b573					endif 
b573			 
b573					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b573 cd 73 9c			call macro_dsp_valuehl 
b576				endm 
# End of macro FORTH_DSP_VALUEHL
b576			 
b576				; TODO add floating point number detection 
b576			 
b576 e5					push hl 
b577			 
b577					; destroy value TOS 
b577			 
b577					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b577 cd 2b 9d			call macro_forth_dsp_pop 
b57a				endm 
# End of macro FORTH_DSP_POP
b57a			 
b57a			 
b57a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b57a cd 73 9c			call macro_dsp_valuehl 
b57d				endm 
# End of macro FORTH_DSP_VALUEHL
b57d			 
b57d					; one value on hl get other one back 
b57d			 
b57d d1					pop de 
b57e			 
b57e					; do the add 
b57e			 
b57e 19					add hl,de 
b57f			 
b57f					; save it 
b57f			 
b57f			;		push hl	 
b57f			 
b57f					; 
b57f			 
b57f					; destroy value TOS 
b57f			 
b57f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b57f cd 2b 9d			call macro_forth_dsp_pop 
b582				endm 
# End of macro FORTH_DSP_POP
b582			 
b582					; TODO push value back onto stack for another op etc 
b582			 
b582			;		pop hl 
b582			 
b582			.dot_done: 
b582 cd 6e 9a				call forth_push_numhl 
b585			 
b585					NEXTW 
b585 c3 29 9e			jp macro_next 
b588				endm 
# End of macro NEXTW
b588			.NEG: 
b588			 
b588				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b588 17				db WORD_SYS_CORE+3             
b589 cb b5			dw .DIV            
b58b 02				db 1 + 1 
b58c .. 00			db "-",0              
b58e				endm 
# End of macro CWHEAD
b58e			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b58e					if DEBUG_FORTH_WORDS_KEY 
b58e						DMARK "SUB" 
b58e f5				push af  
b58f 3a a3 b5			ld a, (.dmark)  
b592 32 6b ee			ld (debug_mark),a  
b595 3a a4 b5			ld a, (.dmark+1)  
b598 32 6c ee			ld (debug_mark+1),a  
b59b 3a a5 b5			ld a, (.dmark+2)  
b59e 32 6d ee			ld (debug_mark+2),a  
b5a1 18 03			jr .pastdmark  
b5a3 ..			.dmark: db "SUB"  
b5a6 f1			.pastdmark: pop af  
b5a7			endm  
# End of macro DMARK
b5a7						CALLMONITOR 
b5a7 cd 6f ee			call debug_vector  
b5aa				endm  
# End of macro CALLMONITOR
b5aa					endif 
b5aa			 
b5aa			 
b5aa				; TODO add floating point number detection 
b5aa					; v5 FORTH_DSP_VALUE 
b5aa					FORTH_DSP 
b5aa cd 39 9c			call macro_forth_dsp 
b5ad				endm 
# End of macro FORTH_DSP
b5ad 7e					ld a,(hl)	; get type of value on TOS 
b5ae fe 02				cp DS_TYPE_INUM  
b5b0 28 03				jr z, .neg_inum 
b5b2			 
b5b2					NEXTW 
b5b2 c3 29 9e			jp macro_next 
b5b5				endm 
# End of macro NEXTW
b5b5			 
b5b5			; float maths 
b5b5			 
b5b5				if FORTH_ENABLE_FLOATMATH 
b5b5					jr .neg_done 
b5b5			 
b5b5				endif 
b5b5					 
b5b5			 
b5b5			.neg_inum: 
b5b5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5b5 cd 73 9c			call macro_dsp_valuehl 
b5b8				endm 
# End of macro FORTH_DSP_VALUEHL
b5b8			 
b5b8 e5					push hl 
b5b9			 
b5b9					; destroy value TOS 
b5b9			 
b5b9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5b9 cd 2b 9d			call macro_forth_dsp_pop 
b5bc				endm 
# End of macro FORTH_DSP_POP
b5bc			 
b5bc			 
b5bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5bc cd 73 9c			call macro_dsp_valuehl 
b5bf				endm 
# End of macro FORTH_DSP_VALUEHL
b5bf			 
b5bf					; one value on hl get other one back 
b5bf			 
b5bf d1					pop de 
b5c0			 
b5c0					; do the sub 
b5c0			;		ex de, hl 
b5c0			 
b5c0 ed 52				sbc hl,de 
b5c2			 
b5c2					; save it 
b5c2			 
b5c2			;		push hl	 
b5c2			 
b5c2					; 
b5c2			 
b5c2					; destroy value TOS 
b5c2			 
b5c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5c2 cd 2b 9d			call macro_forth_dsp_pop 
b5c5				endm 
# End of macro FORTH_DSP_POP
b5c5			 
b5c5					; TODO push value back onto stack for another op etc 
b5c5			 
b5c5			;		pop hl 
b5c5			 
b5c5 cd 6e 9a				call forth_push_numhl 
b5c8			.neg_done: 
b5c8			 
b5c8					NEXTW 
b5c8 c3 29 9e			jp macro_next 
b5cb				endm 
# End of macro NEXTW
b5cb			.DIV: 
b5cb				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b5cb 18				db WORD_SYS_CORE+4             
b5cc 18 b6			dw .MUL            
b5ce 02				db 1 + 1 
b5cf .. 00			db "/",0              
b5d1				endm 
# End of macro CWHEAD
b5d1			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b5d1					if DEBUG_FORTH_WORDS_KEY 
b5d1						DMARK "DIV" 
b5d1 f5				push af  
b5d2 3a e6 b5			ld a, (.dmark)  
b5d5 32 6b ee			ld (debug_mark),a  
b5d8 3a e7 b5			ld a, (.dmark+1)  
b5db 32 6c ee			ld (debug_mark+1),a  
b5de 3a e8 b5			ld a, (.dmark+2)  
b5e1 32 6d ee			ld (debug_mark+2),a  
b5e4 18 03			jr .pastdmark  
b5e6 ..			.dmark: db "DIV"  
b5e9 f1			.pastdmark: pop af  
b5ea			endm  
# End of macro DMARK
b5ea						CALLMONITOR 
b5ea cd 6f ee			call debug_vector  
b5ed				endm  
# End of macro CALLMONITOR
b5ed					endif 
b5ed				; TODO add floating point number detection 
b5ed					; v5 FORTH_DSP_VALUE 
b5ed					FORTH_DSP 
b5ed cd 39 9c			call macro_forth_dsp 
b5f0				endm 
# End of macro FORTH_DSP
b5f0 7e					ld a,(hl)	; get type of value on TOS 
b5f1 fe 02				cp DS_TYPE_INUM  
b5f3 28 03				jr z, .div_inum 
b5f5			 
b5f5				if FORTH_ENABLE_FLOATMATH 
b5f5					jr .div_done 
b5f5			 
b5f5				endif 
b5f5					NEXTW 
b5f5 c3 29 9e			jp macro_next 
b5f8				endm 
# End of macro NEXTW
b5f8			.div_inum: 
b5f8			 
b5f8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5f8 cd 73 9c			call macro_dsp_valuehl 
b5fb				endm 
# End of macro FORTH_DSP_VALUEHL
b5fb			 
b5fb e5					push hl    ; to go to bc 
b5fc			 
b5fc					; destroy value TOS 
b5fc			 
b5fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5fc cd 2b 9d			call macro_forth_dsp_pop 
b5ff				endm 
# End of macro FORTH_DSP_POP
b5ff			 
b5ff			 
b5ff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5ff cd 73 9c			call macro_dsp_valuehl 
b602				endm 
# End of macro FORTH_DSP_VALUEHL
b602			 
b602					; hl to go to de 
b602			 
b602 e5					push hl 
b603			 
b603 c1					pop bc 
b604 d1					pop de		 
b605			 
b605			 
b605					if DEBUG_FORTH_MATHS 
b605						DMARK "DIV" 
b605				CALLMONITOR 
b605					endif 
b605					; one value on hl but move to a get other one back 
b605			 
b605			        
b605 cd 44 8c			call Div16 
b608			 
b608			;	push af	 
b608 e5				push hl 
b609 c5				push bc 
b60a			 
b60a					if DEBUG_FORTH_MATHS 
b60a						DMARK "DI1" 
b60a				CALLMONITOR 
b60a					endif 
b60a			 
b60a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b60a cd 2b 9d			call macro_forth_dsp_pop 
b60d				endm 
# End of macro FORTH_DSP_POP
b60d			 
b60d			 
b60d			 
b60d e1					pop hl    ; result 
b60e			 
b60e cd 6e 9a				call forth_push_numhl 
b611			 
b611 e1					pop hl    ; reminder 
b612			;		ld h,0 
b612			;		ld l,d 
b612			 
b612 cd 6e 9a				call forth_push_numhl 
b615			.div_done: 
b615					NEXTW 
b615 c3 29 9e			jp macro_next 
b618				endm 
# End of macro NEXTW
b618			.MUL: 
b618				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b618 19				db WORD_SYS_CORE+5             
b619 5d b6			dw .MIN            
b61b 02				db 1 + 1 
b61c .. 00			db "*",0              
b61e				endm 
# End of macro CWHEAD
b61e			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b61e				; TODO add floating point number detection 
b61e					if DEBUG_FORTH_WORDS_KEY 
b61e						DMARK "MUL" 
b61e f5				push af  
b61f 3a 33 b6			ld a, (.dmark)  
b622 32 6b ee			ld (debug_mark),a  
b625 3a 34 b6			ld a, (.dmark+1)  
b628 32 6c ee			ld (debug_mark+1),a  
b62b 3a 35 b6			ld a, (.dmark+2)  
b62e 32 6d ee			ld (debug_mark+2),a  
b631 18 03			jr .pastdmark  
b633 ..			.dmark: db "MUL"  
b636 f1			.pastdmark: pop af  
b637			endm  
# End of macro DMARK
b637						CALLMONITOR 
b637 cd 6f ee			call debug_vector  
b63a				endm  
# End of macro CALLMONITOR
b63a					endif 
b63a					FORTH_DSP 
b63a cd 39 9c			call macro_forth_dsp 
b63d				endm 
# End of macro FORTH_DSP
b63d					; v5 FORTH_DSP_VALUE 
b63d 7e					ld a,(hl)	; get type of value on TOS 
b63e fe 02				cp DS_TYPE_INUM  
b640 28 03				jr z, .mul_inum 
b642			 
b642				if FORTH_ENABLE_FLOATMATH 
b642					jr .mul_done 
b642			 
b642				endif 
b642			 
b642					NEXTW 
b642 c3 29 9e			jp macro_next 
b645				endm 
# End of macro NEXTW
b645			.mul_inum:	 
b645			 
b645					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b645 cd 73 9c			call macro_dsp_valuehl 
b648				endm 
# End of macro FORTH_DSP_VALUEHL
b648			 
b648 e5					push hl 
b649			 
b649					; destroy value TOS 
b649			 
b649					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b649 cd 2b 9d			call macro_forth_dsp_pop 
b64c				endm 
# End of macro FORTH_DSP_POP
b64c			 
b64c			 
b64c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b64c cd 73 9c			call macro_dsp_valuehl 
b64f				endm 
# End of macro FORTH_DSP_VALUEHL
b64f			 
b64f					; one value on hl but move to a get other one back 
b64f			 
b64f 7d					ld a, l 
b650			 
b650 d1					pop de 
b651			 
b651					; do the mull 
b651			;		ex de, hl 
b651			 
b651 cd 6a 8c				call Mult16 
b654					; save it 
b654			 
b654			;		push hl	 
b654			 
b654					; 
b654			 
b654					; destroy value TOS 
b654			 
b654					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b654 cd 2b 9d			call macro_forth_dsp_pop 
b657				endm 
# End of macro FORTH_DSP_POP
b657			 
b657					; TODO push value back onto stack for another op etc 
b657			 
b657			;		pop hl 
b657			 
b657 cd 6e 9a				call forth_push_numhl 
b65a			 
b65a			.mul_done: 
b65a					NEXTW 
b65a c3 29 9e			jp macro_next 
b65d				endm 
# End of macro NEXTW
b65d			 
b65d			 
b65d			 
b65d			 
b65d			.MIN: 
b65d				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b65d 49				db WORD_SYS_CORE+53             
b65e de b6			dw .MAX            
b660 04				db 3 + 1 
b661 .. 00			db "MIN",0              
b665				endm 
# End of macro CWHEAD
b665			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b665					if DEBUG_FORTH_WORDS_KEY 
b665						DMARK "MIN" 
b665 f5				push af  
b666 3a 7a b6			ld a, (.dmark)  
b669 32 6b ee			ld (debug_mark),a  
b66c 3a 7b b6			ld a, (.dmark+1)  
b66f 32 6c ee			ld (debug_mark+1),a  
b672 3a 7c b6			ld a, (.dmark+2)  
b675 32 6d ee			ld (debug_mark+2),a  
b678 18 03			jr .pastdmark  
b67a ..			.dmark: db "MIN"  
b67d f1			.pastdmark: pop af  
b67e			endm  
# End of macro DMARK
b67e						CALLMONITOR 
b67e cd 6f ee			call debug_vector  
b681				endm  
# End of macro CALLMONITOR
b681					endif 
b681					; get u2 
b681			 
b681					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b681 cd 73 9c			call macro_dsp_valuehl 
b684				endm 
# End of macro FORTH_DSP_VALUEHL
b684			 
b684 e5					push hl   ; u2 
b685			 
b685					; destroy value TOS 
b685			 
b685					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b685 cd 2b 9d			call macro_forth_dsp_pop 
b688				endm 
# End of macro FORTH_DSP_POP
b688			 
b688					; get u1 
b688			 
b688					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b688 cd 73 9c			call macro_dsp_valuehl 
b68b				endm 
# End of macro FORTH_DSP_VALUEHL
b68b			 
b68b e5					push hl  ; u1 
b68c			 
b68c					; destroy value TOS 
b68c			 
b68c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b68c cd 2b 9d			call macro_forth_dsp_pop 
b68f				endm 
# End of macro FORTH_DSP_POP
b68f			 
b68f b7			 or a      ;clear carry flag 
b690 e1			  pop hl    ; u1 
b691 d1			  pop de    ; u2 
b692 e5				push hl   ; saved in case hl is lowest 
b693 ed 52		  sbc hl,de 
b695 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b697			 
b697 e1				pop hl 
b698					if DEBUG_FORTH_WORDS 
b698						DMARK "MIN" 
b698 f5				push af  
b699 3a ad b6			ld a, (.dmark)  
b69c 32 6b ee			ld (debug_mark),a  
b69f 3a ae b6			ld a, (.dmark+1)  
b6a2 32 6c ee			ld (debug_mark+1),a  
b6a5 3a af b6			ld a, (.dmark+2)  
b6a8 32 6d ee			ld (debug_mark+2),a  
b6ab 18 03			jr .pastdmark  
b6ad ..			.dmark: db "MIN"  
b6b0 f1			.pastdmark: pop af  
b6b1			endm  
# End of macro DMARK
b6b1						CALLMONITOR 
b6b1 cd 6f ee			call debug_vector  
b6b4				endm  
# End of macro CALLMONITOR
b6b4					endif 
b6b4 cd 6e 9a				call forth_push_numhl 
b6b7			 
b6b7				       NEXTW 
b6b7 c3 29 9e			jp macro_next 
b6ba				endm 
# End of macro NEXTW
b6ba			 
b6ba			.mincont:  
b6ba c1				pop bc   ; tidy up 
b6bb eb				ex de , hl  
b6bc					if DEBUG_FORTH_WORDS 
b6bc						DMARK "MI1" 
b6bc f5				push af  
b6bd 3a d1 b6			ld a, (.dmark)  
b6c0 32 6b ee			ld (debug_mark),a  
b6c3 3a d2 b6			ld a, (.dmark+1)  
b6c6 32 6c ee			ld (debug_mark+1),a  
b6c9 3a d3 b6			ld a, (.dmark+2)  
b6cc 32 6d ee			ld (debug_mark+2),a  
b6cf 18 03			jr .pastdmark  
b6d1 ..			.dmark: db "MI1"  
b6d4 f1			.pastdmark: pop af  
b6d5			endm  
# End of macro DMARK
b6d5						CALLMONITOR 
b6d5 cd 6f ee			call debug_vector  
b6d8				endm  
# End of macro CALLMONITOR
b6d8					endif 
b6d8 cd 6e 9a				call forth_push_numhl 
b6db			 
b6db				       NEXTW 
b6db c3 29 9e			jp macro_next 
b6de				endm 
# End of macro NEXTW
b6de			.MAX: 
b6de				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b6de 4a				db WORD_SYS_CORE+54             
b6df 5f b7			dw .RND16            
b6e1 04				db 3 + 1 
b6e2 .. 00			db "MAX",0              
b6e6				endm 
# End of macro CWHEAD
b6e6			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b6e6					if DEBUG_FORTH_WORDS_KEY 
b6e6						DMARK "MAX" 
b6e6 f5				push af  
b6e7 3a fb b6			ld a, (.dmark)  
b6ea 32 6b ee			ld (debug_mark),a  
b6ed 3a fc b6			ld a, (.dmark+1)  
b6f0 32 6c ee			ld (debug_mark+1),a  
b6f3 3a fd b6			ld a, (.dmark+2)  
b6f6 32 6d ee			ld (debug_mark+2),a  
b6f9 18 03			jr .pastdmark  
b6fb ..			.dmark: db "MAX"  
b6fe f1			.pastdmark: pop af  
b6ff			endm  
# End of macro DMARK
b6ff						CALLMONITOR 
b6ff cd 6f ee			call debug_vector  
b702				endm  
# End of macro CALLMONITOR
b702					endif 
b702					; get u2 
b702			 
b702					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b702 cd 73 9c			call macro_dsp_valuehl 
b705				endm 
# End of macro FORTH_DSP_VALUEHL
b705			 
b705 e5					push hl   ; u2 
b706			 
b706					; destroy value TOS 
b706			 
b706					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b706 cd 2b 9d			call macro_forth_dsp_pop 
b709				endm 
# End of macro FORTH_DSP_POP
b709			 
b709					; get u1 
b709			 
b709					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b709 cd 73 9c			call macro_dsp_valuehl 
b70c				endm 
# End of macro FORTH_DSP_VALUEHL
b70c			 
b70c e5					push hl  ; u1 
b70d			 
b70d					; destroy value TOS 
b70d			 
b70d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b70d cd 2b 9d			call macro_forth_dsp_pop 
b710				endm 
# End of macro FORTH_DSP_POP
b710			 
b710 b7			 or a      ;clear carry flag 
b711 e1			  pop hl    ; u1 
b712 d1			  pop de    ; u2 
b713 e5				push hl   ; saved in case hl is lowest 
b714 ed 52		  sbc hl,de 
b716 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b718			 
b718 e1				pop hl 
b719					if DEBUG_FORTH_WORDS 
b719						DMARK "MAX" 
b719 f5				push af  
b71a 3a 2e b7			ld a, (.dmark)  
b71d 32 6b ee			ld (debug_mark),a  
b720 3a 2f b7			ld a, (.dmark+1)  
b723 32 6c ee			ld (debug_mark+1),a  
b726 3a 30 b7			ld a, (.dmark+2)  
b729 32 6d ee			ld (debug_mark+2),a  
b72c 18 03			jr .pastdmark  
b72e ..			.dmark: db "MAX"  
b731 f1			.pastdmark: pop af  
b732			endm  
# End of macro DMARK
b732						CALLMONITOR 
b732 cd 6f ee			call debug_vector  
b735				endm  
# End of macro CALLMONITOR
b735					endif 
b735 cd 6e 9a				call forth_push_numhl 
b738			 
b738				       NEXTW 
b738 c3 29 9e			jp macro_next 
b73b				endm 
# End of macro NEXTW
b73b			 
b73b			.maxcont:  
b73b c1				pop bc   ; tidy up 
b73c eb				ex de , hl  
b73d					if DEBUG_FORTH_WORDS 
b73d						DMARK "MA1" 
b73d f5				push af  
b73e 3a 52 b7			ld a, (.dmark)  
b741 32 6b ee			ld (debug_mark),a  
b744 3a 53 b7			ld a, (.dmark+1)  
b747 32 6c ee			ld (debug_mark+1),a  
b74a 3a 54 b7			ld a, (.dmark+2)  
b74d 32 6d ee			ld (debug_mark+2),a  
b750 18 03			jr .pastdmark  
b752 ..			.dmark: db "MA1"  
b755 f1			.pastdmark: pop af  
b756			endm  
# End of macro DMARK
b756						CALLMONITOR 
b756 cd 6f ee			call debug_vector  
b759				endm  
# End of macro CALLMONITOR
b759					endif 
b759 cd 6e 9a				call forth_push_numhl 
b75c				       NEXTW 
b75c c3 29 9e			jp macro_next 
b75f				endm 
# End of macro NEXTW
b75f			 
b75f			.RND16: 
b75f				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b75f 4e				db WORD_SYS_CORE+58             
b760 8e b7			dw .RND8            
b762 06				db 5 + 1 
b763 .. 00			db "RND16",0              
b769				endm 
# End of macro CWHEAD
b769			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b769					if DEBUG_FORTH_WORDS_KEY 
b769						DMARK "R16" 
b769 f5				push af  
b76a 3a 7e b7			ld a, (.dmark)  
b76d 32 6b ee			ld (debug_mark),a  
b770 3a 7f b7			ld a, (.dmark+1)  
b773 32 6c ee			ld (debug_mark+1),a  
b776 3a 80 b7			ld a, (.dmark+2)  
b779 32 6d ee			ld (debug_mark+2),a  
b77c 18 03			jr .pastdmark  
b77e ..			.dmark: db "R16"  
b781 f1			.pastdmark: pop af  
b782			endm  
# End of macro DMARK
b782						CALLMONITOR 
b782 cd 6f ee			call debug_vector  
b785				endm  
# End of macro CALLMONITOR
b785					endif 
b785 cd 0e 8c				call prng16  
b788 cd 6e 9a				call forth_push_numhl 
b78b				       NEXTW 
b78b c3 29 9e			jp macro_next 
b78e				endm 
# End of macro NEXTW
b78e			.RND8: 
b78e				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b78e 60				db WORD_SYS_CORE+76             
b78f c3 b7			dw .RND            
b791 05				db 4 + 1 
b792 .. 00			db "RND8",0              
b797				endm 
# End of macro CWHEAD
b797			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b797					if DEBUG_FORTH_WORDS_KEY 
b797						DMARK "RN8" 
b797 f5				push af  
b798 3a ac b7			ld a, (.dmark)  
b79b 32 6b ee			ld (debug_mark),a  
b79e 3a ad b7			ld a, (.dmark+1)  
b7a1 32 6c ee			ld (debug_mark+1),a  
b7a4 3a ae b7			ld a, (.dmark+2)  
b7a7 32 6d ee			ld (debug_mark+2),a  
b7aa 18 03			jr .pastdmark  
b7ac ..			.dmark: db "RN8"  
b7af f1			.pastdmark: pop af  
b7b0			endm  
# End of macro DMARK
b7b0						CALLMONITOR 
b7b0 cd 6f ee			call debug_vector  
b7b3				endm  
# End of macro CALLMONITOR
b7b3					endif 
b7b3 2a a9 eb				ld hl,(xrandc) 
b7b6 23					inc hl 
b7b7 cd 28 8c				call xrnd 
b7ba 6f					ld l,a	 
b7bb 26 00				ld h,0 
b7bd cd 6e 9a				call forth_push_numhl 
b7c0				       NEXTW 
b7c0 c3 29 9e			jp macro_next 
b7c3				endm 
# End of macro NEXTW
b7c3			.RND: 
b7c3				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b7c3 60				db WORD_SYS_CORE+76             
b7c4 c9 b8			dw .ENDMATHS            
b7c6 04				db 3 + 1 
b7c7 .. 00			db "RND",0              
b7cb				endm 
# End of macro CWHEAD
b7cb			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b7cb			 
b7cb					if DEBUG_FORTH_WORDS_KEY 
b7cb						DMARK "RND" 
b7cb f5				push af  
b7cc 3a e0 b7			ld a, (.dmark)  
b7cf 32 6b ee			ld (debug_mark),a  
b7d2 3a e1 b7			ld a, (.dmark+1)  
b7d5 32 6c ee			ld (debug_mark+1),a  
b7d8 3a e2 b7			ld a, (.dmark+2)  
b7db 32 6d ee			ld (debug_mark+2),a  
b7de 18 03			jr .pastdmark  
b7e0 ..			.dmark: db "RND"  
b7e3 f1			.pastdmark: pop af  
b7e4			endm  
# End of macro DMARK
b7e4						CALLMONITOR 
b7e4 cd 6f ee			call debug_vector  
b7e7				endm  
# End of macro CALLMONITOR
b7e7					endif 
b7e7					 
b7e7					FORTH_DSP_VALUEHL    ; upper range 
b7e7 cd 73 9c			call macro_dsp_valuehl 
b7ea				endm 
# End of macro FORTH_DSP_VALUEHL
b7ea			 
b7ea 22 ad eb				ld (LFSRSeed), hl	 
b7ed			 
b7ed					if DEBUG_FORTH_WORDS 
b7ed						DMARK "RN1" 
b7ed f5				push af  
b7ee 3a 02 b8			ld a, (.dmark)  
b7f1 32 6b ee			ld (debug_mark),a  
b7f4 3a 03 b8			ld a, (.dmark+1)  
b7f7 32 6c ee			ld (debug_mark+1),a  
b7fa 3a 04 b8			ld a, (.dmark+2)  
b7fd 32 6d ee			ld (debug_mark+2),a  
b800 18 03			jr .pastdmark  
b802 ..			.dmark: db "RN1"  
b805 f1			.pastdmark: pop af  
b806			endm  
# End of macro DMARK
b806						CALLMONITOR 
b806 cd 6f ee			call debug_vector  
b809				endm  
# End of macro CALLMONITOR
b809					endif 
b809					FORTH_DSP_POP 
b809 cd 2b 9d			call macro_forth_dsp_pop 
b80c				endm 
# End of macro FORTH_DSP_POP
b80c			 
b80c					FORTH_DSP_VALUEHL    ; low range 
b80c cd 73 9c			call macro_dsp_valuehl 
b80f				endm 
# End of macro FORTH_DSP_VALUEHL
b80f			 
b80f					if DEBUG_FORTH_WORDS 
b80f						DMARK "RN2" 
b80f f5				push af  
b810 3a 24 b8			ld a, (.dmark)  
b813 32 6b ee			ld (debug_mark),a  
b816 3a 25 b8			ld a, (.dmark+1)  
b819 32 6c ee			ld (debug_mark+1),a  
b81c 3a 26 b8			ld a, (.dmark+2)  
b81f 32 6d ee			ld (debug_mark+2),a  
b822 18 03			jr .pastdmark  
b824 ..			.dmark: db "RN2"  
b827 f1			.pastdmark: pop af  
b828			endm  
# End of macro DMARK
b828						CALLMONITOR 
b828 cd 6f ee			call debug_vector  
b82b				endm  
# End of macro CALLMONITOR
b82b					endif 
b82b 22 af eb				ld (LFSRSeed+2), hl 
b82e			 
b82e					FORTH_DSP_POP 
b82e cd 2b 9d			call macro_forth_dsp_pop 
b831				endm 
# End of macro FORTH_DSP_POP
b831			 
b831 e5					push hl 
b832			 
b832 e1			.inrange:	pop hl 
b833 cd 0e 8c				call prng16  
b836					if DEBUG_FORTH_WORDS 
b836						DMARK "RN3" 
b836 f5				push af  
b837 3a 4b b8			ld a, (.dmark)  
b83a 32 6b ee			ld (debug_mark),a  
b83d 3a 4c b8			ld a, (.dmark+1)  
b840 32 6c ee			ld (debug_mark+1),a  
b843 3a 4d b8			ld a, (.dmark+2)  
b846 32 6d ee			ld (debug_mark+2),a  
b849 18 03			jr .pastdmark  
b84b ..			.dmark: db "RN3"  
b84e f1			.pastdmark: pop af  
b84f			endm  
# End of macro DMARK
b84f						CALLMONITOR 
b84f cd 6f ee			call debug_vector  
b852				endm  
# End of macro CALLMONITOR
b852					endif 
b852					 
b852					; if the range is 8bit knock out the high byte 
b852			 
b852 ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
b856			 
b856 3e 00				ld a, 0 
b858 ba					cp d  
b859 20 1e				jr nz, .hirange 
b85b 26 00				ld h, 0   ; knock it down to 8bit 
b85d			 
b85d					if DEBUG_FORTH_WORDS 
b85d						DMARK "RNk" 
b85d f5				push af  
b85e 3a 72 b8			ld a, (.dmark)  
b861 32 6b ee			ld (debug_mark),a  
b864 3a 73 b8			ld a, (.dmark+1)  
b867 32 6c ee			ld (debug_mark+1),a  
b86a 3a 74 b8			ld a, (.dmark+2)  
b86d 32 6d ee			ld (debug_mark+2),a  
b870 18 03			jr .pastdmark  
b872 ..			.dmark: db "RNk"  
b875 f1			.pastdmark: pop af  
b876			endm  
# End of macro DMARK
b876						CALLMONITOR 
b876 cd 6f ee			call debug_vector  
b879				endm  
# End of macro CALLMONITOR
b879					endif 
b879			.hirange:   
b879 e5					push hl  
b87a b7					or a  
b87b ed 52		                sbc hl, de 
b87d			 
b87d					;call cmp16 
b87d			 
b87d 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b87f e1					pop hl 
b880 e5					push hl 
b881			 
b881					if DEBUG_FORTH_WORDS 
b881						DMARK "RN4" 
b881 f5				push af  
b882 3a 96 b8			ld a, (.dmark)  
b885 32 6b ee			ld (debug_mark),a  
b888 3a 97 b8			ld a, (.dmark+1)  
b88b 32 6c ee			ld (debug_mark+1),a  
b88e 3a 98 b8			ld a, (.dmark+2)  
b891 32 6d ee			ld (debug_mark+2),a  
b894 18 03			jr .pastdmark  
b896 ..			.dmark: db "RN4"  
b899 f1			.pastdmark: pop af  
b89a			endm  
# End of macro DMARK
b89a						CALLMONITOR 
b89a cd 6f ee			call debug_vector  
b89d				endm  
# End of macro CALLMONITOR
b89d					endif 
b89d ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
b8a1					;call cmp16 
b8a1				 
b8a1 b7					or a  
b8a2 ed 52		                sbc hl, de 
b8a4 38 8c				jr c, .inrange 
b8a6			 
b8a6 e1					pop hl 
b8a7					 
b8a7					if DEBUG_FORTH_WORDS 
b8a7						DMARK "RNd" 
b8a7 f5				push af  
b8a8 3a bc b8			ld a, (.dmark)  
b8ab 32 6b ee			ld (debug_mark),a  
b8ae 3a bd b8			ld a, (.dmark+1)  
b8b1 32 6c ee			ld (debug_mark+1),a  
b8b4 3a be b8			ld a, (.dmark+2)  
b8b7 32 6d ee			ld (debug_mark+2),a  
b8ba 18 03			jr .pastdmark  
b8bc ..			.dmark: db "RNd"  
b8bf f1			.pastdmark: pop af  
b8c0			endm  
# End of macro DMARK
b8c0						CALLMONITOR 
b8c0 cd 6f ee			call debug_vector  
b8c3				endm  
# End of macro CALLMONITOR
b8c3					endif 
b8c3			 
b8c3			 
b8c3 cd 6e 9a				call forth_push_numhl 
b8c6				       NEXTW 
b8c6 c3 29 9e			jp macro_next 
b8c9				endm 
# End of macro NEXTW
b8c9			 
b8c9			.ENDMATHS: 
b8c9			 
b8c9			; eof 
b8c9			 
# End of file forth_words_maths.asm
b8c9			include "forth_words_display.asm" 
b8c9			 
b8c9			; | ## Display Words 
b8c9			 
b8c9			.ACT: 
b8c9			 
b8c9				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
b8c9 62				db WORD_SYS_CORE+78             
b8ca 15 b9			dw .INFO            
b8cc 07				db 6 + 1 
b8cd .. 00			db "ACTIVE",0              
b8d4				endm 
# End of macro CWHEAD
b8d4			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
b8d4			;  
b8d4			; | | To display a pulsing activity indicator in a processing loop do this... 
b8d4			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
b8d4			 
b8d4					if DEBUG_FORTH_WORDS_KEY 
b8d4						DMARK "ACT" 
b8d4 f5				push af  
b8d5 3a e9 b8			ld a, (.dmark)  
b8d8 32 6b ee			ld (debug_mark),a  
b8db 3a ea b8			ld a, (.dmark+1)  
b8de 32 6c ee			ld (debug_mark+1),a  
b8e1 3a eb b8			ld a, (.dmark+2)  
b8e4 32 6d ee			ld (debug_mark+2),a  
b8e7 18 03			jr .pastdmark  
b8e9 ..			.dmark: db "ACT"  
b8ec f1			.pastdmark: pop af  
b8ed			endm  
# End of macro DMARK
b8ed						CALLMONITOR 
b8ed cd 6f ee			call debug_vector  
b8f0				endm  
# End of macro CALLMONITOR
b8f0					endif 
b8f0 cd 11 8a				call active 
b8f3					if DEBUG_FORTH_WORDS 
b8f3						DMARK "ACp" 
b8f3 f5				push af  
b8f4 3a 08 b9			ld a, (.dmark)  
b8f7 32 6b ee			ld (debug_mark),a  
b8fa 3a 09 b9			ld a, (.dmark+1)  
b8fd 32 6c ee			ld (debug_mark+1),a  
b900 3a 0a b9			ld a, (.dmark+2)  
b903 32 6d ee			ld (debug_mark+2),a  
b906 18 03			jr .pastdmark  
b908 ..			.dmark: db "ACp"  
b90b f1			.pastdmark: pop af  
b90c			endm  
# End of macro DMARK
b90c						CALLMONITOR 
b90c cd 6f ee			call debug_vector  
b90f				endm  
# End of macro CALLMONITOR
b90f					endif 
b90f cd dc 9a				call forth_push_str 
b912			 
b912					NEXTW 
b912 c3 29 9e			jp macro_next 
b915				endm 
# End of macro NEXTW
b915			.INFO: 
b915			 
b915				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b915 62				db WORD_SYS_CORE+78             
b916 32 b9			dw .ATP            
b918 05				db 4 + 1 
b919 .. 00			db "INFO",0              
b91e				endm 
# End of macro CWHEAD
b91e			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b91e					FORTH_DSP_VALUEHL 
b91e cd 73 9c			call macro_dsp_valuehl 
b921				endm 
# End of macro FORTH_DSP_VALUEHL
b921			 
b921					FORTH_DSP_POP 
b921 cd 2b 9d			call macro_forth_dsp_pop 
b924				endm 
# End of macro FORTH_DSP_POP
b924			 
b924 e5					push hl 
b925			 
b925					FORTH_DSP_VALUEHL 
b925 cd 73 9c			call macro_dsp_valuehl 
b928				endm 
# End of macro FORTH_DSP_VALUEHL
b928			 
b928					FORTH_DSP_POP 
b928 cd 2b 9d			call macro_forth_dsp_pop 
b92b				endm 
# End of macro FORTH_DSP_POP
b92b			 
b92b d1					pop de 
b92c			 
b92c cd 4b 8a				call info_panel 
b92f			 
b92f			 
b92f					NEXTW 
b92f c3 29 9e			jp macro_next 
b932				endm 
# End of macro NEXTW
b932			.ATP: 
b932				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b932 62				db WORD_SYS_CORE+78             
b933 a9 b9			dw .FB            
b935 04				db 3 + 1 
b936 .. 00			db "AT?",0              
b93a				endm 
# End of macro CWHEAD
b93a			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b93a					if DEBUG_FORTH_WORDS_KEY 
b93a						DMARK "AT?" 
b93a f5				push af  
b93b 3a 4f b9			ld a, (.dmark)  
b93e 32 6b ee			ld (debug_mark),a  
b941 3a 50 b9			ld a, (.dmark+1)  
b944 32 6c ee			ld (debug_mark+1),a  
b947 3a 51 b9			ld a, (.dmark+2)  
b94a 32 6d ee			ld (debug_mark+2),a  
b94d 18 03			jr .pastdmark  
b94f ..			.dmark: db "AT?"  
b952 f1			.pastdmark: pop af  
b953			endm  
# End of macro DMARK
b953						CALLMONITOR 
b953 cd 6f ee			call debug_vector  
b956				endm  
# End of macro CALLMONITOR
b956					endif 
b956 3a 5e ea				ld a, (f_cursor_ptr) 
b959			 
b959			if DEBUG_FORTH_WORDS 
b959				DMARK "AT?" 
b959 f5				push af  
b95a 3a 6e b9			ld a, (.dmark)  
b95d 32 6b ee			ld (debug_mark),a  
b960 3a 6f b9			ld a, (.dmark+1)  
b963 32 6c ee			ld (debug_mark+1),a  
b966 3a 70 b9			ld a, (.dmark+2)  
b969 32 6d ee			ld (debug_mark+2),a  
b96c 18 03			jr .pastdmark  
b96e ..			.dmark: db "AT?"  
b971 f1			.pastdmark: pop af  
b972			endm  
# End of macro DMARK
b972				CALLMONITOR 
b972 cd 6f ee			call debug_vector  
b975				endm  
# End of macro CALLMONITOR
b975			endif	 
b975					; count the number of rows 
b975			 
b975 06 00				ld b, 0 
b977 4f			.atpr:		ld c, a    ; save in case we go below zero 
b978 d6 28				sub display_cols 
b97a f2 80 b9				jp p, .atprunder 
b97d 04					inc b 
b97e 18 f7				jr .atpr 
b980			.atprunder:	 
b980			if DEBUG_FORTH_WORDS 
b980				DMARK "A?2" 
b980 f5				push af  
b981 3a 95 b9			ld a, (.dmark)  
b984 32 6b ee			ld (debug_mark),a  
b987 3a 96 b9			ld a, (.dmark+1)  
b98a 32 6c ee			ld (debug_mark+1),a  
b98d 3a 97 b9			ld a, (.dmark+2)  
b990 32 6d ee			ld (debug_mark+2),a  
b993 18 03			jr .pastdmark  
b995 ..			.dmark: db "A?2"  
b998 f1			.pastdmark: pop af  
b999			endm  
# End of macro DMARK
b999				CALLMONITOR 
b999 cd 6f ee			call debug_vector  
b99c				endm  
# End of macro CALLMONITOR
b99c			endif	 
b99c 26 00				ld h, 0 
b99e 69					ld l, c 
b99f cd 6e 9a				call forth_push_numhl 
b9a2 68					ld l, b  
b9a3 cd 6e 9a				call forth_push_numhl 
b9a6			 
b9a6			 
b9a6				NEXTW 
b9a6 c3 29 9e			jp macro_next 
b9a9				endm 
# End of macro NEXTW
b9a9			 
b9a9			.FB: 
b9a9				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b9a9 1b				db WORD_SYS_CORE+7             
b9aa f7 b9			dw .EMIT            
b9ac 03				db 2 + 1 
b9ad .. 00			db "FB",0              
b9b0				endm 
# End of macro CWHEAD
b9b0			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b9b0			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b9b0			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b9b0			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b9b0					if DEBUG_FORTH_WORDS_KEY 
b9b0						DMARK "FB." 
b9b0 f5				push af  
b9b1 3a c5 b9			ld a, (.dmark)  
b9b4 32 6b ee			ld (debug_mark),a  
b9b7 3a c6 b9			ld a, (.dmark+1)  
b9ba 32 6c ee			ld (debug_mark+1),a  
b9bd 3a c7 b9			ld a, (.dmark+2)  
b9c0 32 6d ee			ld (debug_mark+2),a  
b9c3 18 03			jr .pastdmark  
b9c5 ..			.dmark: db "FB."  
b9c8 f1			.pastdmark: pop af  
b9c9			endm  
# End of macro DMARK
b9c9						CALLMONITOR 
b9c9 cd 6f ee			call debug_vector  
b9cc				endm  
# End of macro CALLMONITOR
b9cc					endif 
b9cc			 
b9cc					FORTH_DSP_VALUEHL 
b9cc cd 73 9c			call macro_dsp_valuehl 
b9cf				endm 
# End of macro FORTH_DSP_VALUEHL
b9cf			 
b9cf 7d					ld a, l 
b9d0 fe 01				cp 1 
b9d2 20 05				jr nz, .fbn1 
b9d4 21 10 ed				ld hl, display_fb1 
b9d7 18 15				jr .fbset 
b9d9 fe 02		.fbn1:		cp 2 
b9db 20 05				jr nz, .fbn2 
b9dd 21 ce eb				ld hl, display_fb2 
b9e0 18 0c				jr .fbset 
b9e2 fe 03		.fbn2:		cp 3 
b9e4 20 05				jr nz, .fbn3 
b9e6 21 6f ec				ld hl, display_fb3 
b9e9 18 03				jr .fbset 
b9eb			.fbn3:		 ; if invalid number select first 
b9eb 21 10 ed				ld hl, display_fb1 
b9ee 22 cc eb		.fbset:		ld (display_fb_active), hl 
b9f1			 
b9f1					FORTH_DSP_POP 
b9f1 cd 2b 9d			call macro_forth_dsp_pop 
b9f4				endm 
# End of macro FORTH_DSP_POP
b9f4			 
b9f4					NEXTW 
b9f4 c3 29 9e			jp macro_next 
b9f7				endm 
# End of macro NEXTW
b9f7			 
b9f7			 
b9f7			.EMIT: 
b9f7				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b9f7 1b				db WORD_SYS_CORE+7             
b9f8 48 ba			dw .DOTH            
b9fa 05				db 4 + 1 
b9fb .. 00			db "EMIT",0              
ba00				endm 
# End of macro CWHEAD
ba00			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
ba00					; get value off TOS and display it 
ba00			 
ba00					if DEBUG_FORTH_WORDS_KEY 
ba00						DMARK "EMT" 
ba00 f5				push af  
ba01 3a 15 ba			ld a, (.dmark)  
ba04 32 6b ee			ld (debug_mark),a  
ba07 3a 16 ba			ld a, (.dmark+1)  
ba0a 32 6c ee			ld (debug_mark+1),a  
ba0d 3a 17 ba			ld a, (.dmark+2)  
ba10 32 6d ee			ld (debug_mark+2),a  
ba13 18 03			jr .pastdmark  
ba15 ..			.dmark: db "EMT"  
ba18 f1			.pastdmark: pop af  
ba19			endm  
# End of macro DMARK
ba19						CALLMONITOR 
ba19 cd 6f ee			call debug_vector  
ba1c				endm  
# End of macro CALLMONITOR
ba1c					endif 
ba1c			 
ba1c					FORTH_DSP_VALUEHL 
ba1c cd 73 9c			call macro_dsp_valuehl 
ba1f				endm 
# End of macro FORTH_DSP_VALUEHL
ba1f			 
ba1f 7d					ld a,l 
ba20			 
ba20					; TODO write to display 
ba20			 
ba20 32 bf e4				ld (os_input), a 
ba23 3e 00				ld a, 0 
ba25 32 c0 e4				ld (os_input+1), a 
ba28					 
ba28 3a 5e ea				ld a, (f_cursor_ptr) 
ba2b 11 bf e4				ld de, os_input 
ba2e cd cd 8a				call str_at_display 
ba31			 
ba31			 
ba31 3a 3c ea				ld a,(cli_autodisplay) 
ba34 fe 00				cp 0 
ba36 28 03				jr z, .enoupdate 
ba38 cd dd 8a						call update_display 
ba3b					.enoupdate: 
ba3b			 
ba3b 3a 5e ea				ld a, (f_cursor_ptr) 
ba3e 3c					inc a 
ba3f 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
ba42			 
ba42			 
ba42					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba42 cd 2b 9d			call macro_forth_dsp_pop 
ba45				endm 
# End of macro FORTH_DSP_POP
ba45			  
ba45			 
ba45					NEXTW 
ba45 c3 29 9e			jp macro_next 
ba48				endm 
# End of macro NEXTW
ba48			.DOTH: 
ba48				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
ba48 1c				db WORD_SYS_CORE+8             
ba49 78 ba			dw .DOTF            
ba4b 03				db 2 + 1 
ba4c .. 00			db ".-",0              
ba4f				endm 
# End of macro CWHEAD
ba4f			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
ba4f					; get value off TOS and display it 
ba4f					if DEBUG_FORTH_WORDS_KEY 
ba4f						DMARK "DTD" 
ba4f f5				push af  
ba50 3a 64 ba			ld a, (.dmark)  
ba53 32 6b ee			ld (debug_mark),a  
ba56 3a 65 ba			ld a, (.dmark+1)  
ba59 32 6c ee			ld (debug_mark+1),a  
ba5c 3a 66 ba			ld a, (.dmark+2)  
ba5f 32 6d ee			ld (debug_mark+2),a  
ba62 18 03			jr .pastdmark  
ba64 ..			.dmark: db "DTD"  
ba67 f1			.pastdmark: pop af  
ba68			endm  
# End of macro DMARK
ba68						CALLMONITOR 
ba68 cd 6f ee			call debug_vector  
ba6b				endm  
# End of macro CALLMONITOR
ba6b					endif 
ba6b 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
ba6d 3e 00			ld a, 0 
ba6f 32 3d ea			ld (cli_mvdot), a 
ba72 c3 cf ba			jp .dotgo 
ba75				NEXTW 
ba75 c3 29 9e			jp macro_next 
ba78				endm 
# End of macro NEXTW
ba78			.DOTF: 
ba78				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
ba78 1c				db WORD_SYS_CORE+8             
ba79 a6 ba			dw .DOT            
ba7b 03				db 2 + 1 
ba7c .. 00			db ".>",0              
ba7f				endm 
# End of macro CWHEAD
ba7f			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
ba7f					; get value off TOS and display it 
ba7f			        ; TODO BUG adds extra spaces 
ba7f			        ; TODO BUG handle numerics? 
ba7f					if DEBUG_FORTH_WORDS_KEY 
ba7f						DMARK "DTC" 
ba7f f5				push af  
ba80 3a 94 ba			ld a, (.dmark)  
ba83 32 6b ee			ld (debug_mark),a  
ba86 3a 95 ba			ld a, (.dmark+1)  
ba89 32 6c ee			ld (debug_mark+1),a  
ba8c 3a 96 ba			ld a, (.dmark+2)  
ba8f 32 6d ee			ld (debug_mark+2),a  
ba92 18 03			jr .pastdmark  
ba94 ..			.dmark: db "DTC"  
ba97 f1			.pastdmark: pop af  
ba98			endm  
# End of macro DMARK
ba98						CALLMONITOR 
ba98 cd 6f ee			call debug_vector  
ba9b				endm  
# End of macro CALLMONITOR
ba9b					endif 
ba9b 3e 01			ld a, 1 
ba9d 32 3d ea			ld (cli_mvdot), a 
baa0 c3 cf ba			jp .dotgo 
baa3				NEXTW 
baa3 c3 29 9e			jp macro_next 
baa6				endm 
# End of macro NEXTW
baa6			 
baa6			.DOT: 
baa6				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
baa6 1c				db WORD_SYS_CORE+8             
baa7 82 bc			dw .CLS            
baa9 02				db 1 + 1 
baaa .. 00			db ".",0              
baac				endm 
# End of macro CWHEAD
baac			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
baac					; get value off TOS and display it 
baac			 
baac					if DEBUG_FORTH_WORDS_KEY 
baac						DMARK "DOT" 
baac f5				push af  
baad 3a c1 ba			ld a, (.dmark)  
bab0 32 6b ee			ld (debug_mark),a  
bab3 3a c2 ba			ld a, (.dmark+1)  
bab6 32 6c ee			ld (debug_mark+1),a  
bab9 3a c3 ba			ld a, (.dmark+2)  
babc 32 6d ee			ld (debug_mark+2),a  
babf 18 03			jr .pastdmark  
bac1 ..			.dmark: db "DOT"  
bac4 f1			.pastdmark: pop af  
bac5			endm  
# End of macro DMARK
bac5						CALLMONITOR 
bac5 cd 6f ee			call debug_vector  
bac8				endm  
# End of macro CALLMONITOR
bac8					endif 
bac8 3e 00			ld a, 0 
baca 32 3d ea			ld (cli_mvdot), a 
bacd 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
bacf				 
bacf			 
bacf			.dotgo: 
bacf			 
bacf			; move up type to on stack for parserv5 
bacf					FORTH_DSP 
bacf cd 39 9c			call macro_forth_dsp 
bad2				endm 
# End of macro FORTH_DSP
bad2				;FORTH_DSP_VALUE  
bad2			 
bad2			if DEBUG_FORTH_DOT 
bad2				DMARK "DOT" 
bad2 f5				push af  
bad3 3a e7 ba			ld a, (.dmark)  
bad6 32 6b ee			ld (debug_mark),a  
bad9 3a e8 ba			ld a, (.dmark+1)  
badc 32 6c ee			ld (debug_mark+1),a  
badf 3a e9 ba			ld a, (.dmark+2)  
bae2 32 6d ee			ld (debug_mark+2),a  
bae5 18 03			jr .pastdmark  
bae7 ..			.dmark: db "DOT"  
baea f1			.pastdmark: pop af  
baeb			endm  
# End of macro DMARK
baeb				CALLMONITOR 
baeb cd 6f ee			call debug_vector  
baee				endm  
# End of macro CALLMONITOR
baee			endif	 
baee			;		.print: 
baee			 
baee 7e				ld a,(hl)  ; work out what type of value is on the TOS 
baef 23				inc hl   ; position to the actual value 
baf0 fe 01			cp DS_TYPE_STR 
baf2 20 06			jr nz, .dotnum1  
baf4			 
baf4			; display string 
baf4				FORTH_DSP_VALUE  
baf4 cd 5c 9c			call macro_forth_dsp_value 
baf7				endm 
# End of macro FORTH_DSP_VALUE
baf7 eb				ex de,hl 
baf8 18 49			jr .dotwrite 
bafa			 
bafa			.dotnum1: 
bafa fe 02			cp DS_TYPE_INUM 
bafc 20 44			jr nz, .dotflot 
bafe			 
bafe			 
bafe			; display number 
bafe			 
bafe			;	push hl 
bafe			;	call clear_display 
bafe			;	pop hl 
bafe			 
bafe 5e				ld e, (hl) 
baff 23				inc hl 
bb00 56				ld d, (hl) 
bb01 21 c1 e2			ld hl, scratch 
bb04			if DEBUG_FORTH_DOT 
bb04				DMARK "DT1" 
bb04 f5				push af  
bb05 3a 19 bb			ld a, (.dmark)  
bb08 32 6b ee			ld (debug_mark),a  
bb0b 3a 1a bb			ld a, (.dmark+1)  
bb0e 32 6c ee			ld (debug_mark+1),a  
bb11 3a 1b bb			ld a, (.dmark+2)  
bb14 32 6d ee			ld (debug_mark+2),a  
bb17 18 03			jr .pastdmark  
bb19 ..			.dmark: db "DT1"  
bb1c f1			.pastdmark: pop af  
bb1d			endm  
# End of macro DMARK
bb1d				CALLMONITOR 
bb1d cd 6f ee			call debug_vector  
bb20				endm  
# End of macro CALLMONITOR
bb20			endif	 
bb20			 
bb20 cd fc 8f			call uitoa_16 
bb23 eb				ex de,hl 
bb24			 
bb24			if DEBUG_FORTH_DOT 
bb24				DMARK "DT2" 
bb24 f5				push af  
bb25 3a 39 bb			ld a, (.dmark)  
bb28 32 6b ee			ld (debug_mark),a  
bb2b 3a 3a bb			ld a, (.dmark+1)  
bb2e 32 6c ee			ld (debug_mark+1),a  
bb31 3a 3b bb			ld a, (.dmark+2)  
bb34 32 6d ee			ld (debug_mark+2),a  
bb37 18 03			jr .pastdmark  
bb39 ..			.dmark: db "DT2"  
bb3c f1			.pastdmark: pop af  
bb3d			endm  
# End of macro DMARK
bb3d				CALLMONITOR 
bb3d cd 6f ee			call debug_vector  
bb40				endm  
# End of macro CALLMONITOR
bb40			endif	 
bb40			 
bb40			;	ld de, os_word_scratch 
bb40 18 01			jr .dotwrite 
bb42			 
bb42 00			.dotflot:   nop 
bb43			; TODO print floating point number 
bb43			 
bb43			.dotwrite:		 
bb43			 
bb43					; if c is set then set all '-' to spaces 
bb43					; need to also take into account .>  
bb43			 
bb43 3e 01				ld a, 1 
bb45 b9					cp c 
bb46 20 67				jr nz, .nodashswap 
bb48			 
bb48					; DE has the string to write, working with HL 
bb48			 
bb48 06 ff				ld b, 255 
bb4a d5					push de 
bb4b e1					pop hl 
bb4c			 
bb4c			if DEBUG_FORTH_DOT 
bb4c				DMARK "DT-" 
bb4c f5				push af  
bb4d 3a 61 bb			ld a, (.dmark)  
bb50 32 6b ee			ld (debug_mark),a  
bb53 3a 62 bb			ld a, (.dmark+1)  
bb56 32 6c ee			ld (debug_mark+1),a  
bb59 3a 63 bb			ld a, (.dmark+2)  
bb5c 32 6d ee			ld (debug_mark+2),a  
bb5f 18 03			jr .pastdmark  
bb61 ..			.dmark: db "DT-"  
bb64 f1			.pastdmark: pop af  
bb65			endm  
# End of macro DMARK
bb65				CALLMONITOR 
bb65 cd 6f ee			call debug_vector  
bb68				endm  
# End of macro CALLMONITOR
bb68			endif	 
bb68 7e			.dashscan:	ld a, (hl) 
bb69 fe 00				cp 0 
bb6b 28 42				jr z, .nodashswap 
bb6d fe 2d				cp '-' 
bb6f 20 03				jr nz, .dashskip 
bb71 3e 20				ld a, ' ' 
bb73 77					ld (hl), a 
bb74 23			.dashskip:	inc hl 
bb75			if DEBUG_FORTH_DOT 
bb75				DMARK "D-2" 
bb75 f5				push af  
bb76 3a 8a bb			ld a, (.dmark)  
bb79 32 6b ee			ld (debug_mark),a  
bb7c 3a 8b bb			ld a, (.dmark+1)  
bb7f 32 6c ee			ld (debug_mark+1),a  
bb82 3a 8c bb			ld a, (.dmark+2)  
bb85 32 6d ee			ld (debug_mark+2),a  
bb88 18 03			jr .pastdmark  
bb8a ..			.dmark: db "D-2"  
bb8d f1			.pastdmark: pop af  
bb8e			endm  
# End of macro DMARK
bb8e				CALLMONITOR 
bb8e cd 6f ee			call debug_vector  
bb91				endm  
# End of macro CALLMONITOR
bb91			endif	 
bb91 10 d5				djnz .dashscan 
bb93			 
bb93			if DEBUG_FORTH_DOT 
bb93				DMARK "D-1" 
bb93 f5				push af  
bb94 3a a8 bb			ld a, (.dmark)  
bb97 32 6b ee			ld (debug_mark),a  
bb9a 3a a9 bb			ld a, (.dmark+1)  
bb9d 32 6c ee			ld (debug_mark+1),a  
bba0 3a aa bb			ld a, (.dmark+2)  
bba3 32 6d ee			ld (debug_mark+2),a  
bba6 18 03			jr .pastdmark  
bba8 ..			.dmark: db "D-1"  
bbab f1			.pastdmark: pop af  
bbac			endm  
# End of macro DMARK
bbac				CALLMONITOR 
bbac cd 6f ee			call debug_vector  
bbaf				endm  
# End of macro CALLMONITOR
bbaf			endif	 
bbaf			 
bbaf			.nodashswap: 
bbaf			 
bbaf			if DEBUG_FORTH_DOT 
bbaf				DMARK "D-o" 
bbaf f5				push af  
bbb0 3a c4 bb			ld a, (.dmark)  
bbb3 32 6b ee			ld (debug_mark),a  
bbb6 3a c5 bb			ld a, (.dmark+1)  
bbb9 32 6c ee			ld (debug_mark+1),a  
bbbc 3a c6 bb			ld a, (.dmark+2)  
bbbf 32 6d ee			ld (debug_mark+2),a  
bbc2 18 03			jr .pastdmark  
bbc4 ..			.dmark: db "D-o"  
bbc7 f1			.pastdmark: pop af  
bbc8			endm  
# End of macro DMARK
bbc8				CALLMONITOR 
bbc8 cd 6f ee			call debug_vector  
bbcb				endm  
# End of macro CALLMONITOR
bbcb			endif	 
bbcb			 
bbcb d5					push de   ; save string start in case we need to advance print 
bbcc			 
bbcc 3a 5e ea				ld a, (f_cursor_ptr) 
bbcf cd cd 8a				call str_at_display 
bbd2 3a 3c ea				ld a,(cli_autodisplay) 
bbd5 fe 00				cp 0 
bbd7 28 03				jr z, .noupdate 
bbd9 cd dd 8a						call update_display 
bbdc					.noupdate: 
bbdc			 
bbdc			 
bbdc					; see if we need to advance the print position 
bbdc			 
bbdc e1					pop hl   ; get back string 
bbdd			;		ex de,hl 
bbdd			 
bbdd 3a 3d ea				ld a, (cli_mvdot) 
bbe0			if DEBUG_FORTH_DOT 
bbe0			;		ld e,a 
bbe0				DMARK "D>1" 
bbe0 f5				push af  
bbe1 3a f5 bb			ld a, (.dmark)  
bbe4 32 6b ee			ld (debug_mark),a  
bbe7 3a f6 bb			ld a, (.dmark+1)  
bbea 32 6c ee			ld (debug_mark+1),a  
bbed 3a f7 bb			ld a, (.dmark+2)  
bbf0 32 6d ee			ld (debug_mark+2),a  
bbf3 18 03			jr .pastdmark  
bbf5 ..			.dmark: db "D>1"  
bbf8 f1			.pastdmark: pop af  
bbf9			endm  
# End of macro DMARK
bbf9				CALLMONITOR 
bbf9 cd 6f ee			call debug_vector  
bbfc				endm  
# End of macro CALLMONITOR
bbfc			endif	 
bbfc fe 00				cp 0 
bbfe 28 44				jr z, .noadv 
bc00					; yes, lets advance the print position 
bc00 3e 00				ld a, 0 
bc02 cd 58 90				call strlent 
bc05			if DEBUG_FORTH_DOT 
bc05				DMARK "D-?" 
bc05 f5				push af  
bc06 3a 1a bc			ld a, (.dmark)  
bc09 32 6b ee			ld (debug_mark),a  
bc0c 3a 1b bc			ld a, (.dmark+1)  
bc0f 32 6c ee			ld (debug_mark+1),a  
bc12 3a 1c bc			ld a, (.dmark+2)  
bc15 32 6d ee			ld (debug_mark+2),a  
bc18 18 03			jr .pastdmark  
bc1a ..			.dmark: db "D-?"  
bc1d f1			.pastdmark: pop af  
bc1e			endm  
# End of macro DMARK
bc1e				CALLMONITOR 
bc1e cd 6f ee			call debug_vector  
bc21				endm  
# End of macro CALLMONITOR
bc21			endif	 
bc21 3a 5e ea				ld a, (f_cursor_ptr) 
bc24 85					add a,l 
bc25					;call addatohl 
bc25					;ld a, l 
bc25 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
bc28			 
bc28			if DEBUG_FORTH_DOT 
bc28				DMARK "D->" 
bc28 f5				push af  
bc29 3a 3d bc			ld a, (.dmark)  
bc2c 32 6b ee			ld (debug_mark),a  
bc2f 3a 3e bc			ld a, (.dmark+1)  
bc32 32 6c ee			ld (debug_mark+1),a  
bc35 3a 3f bc			ld a, (.dmark+2)  
bc38 32 6d ee			ld (debug_mark+2),a  
bc3b 18 03			jr .pastdmark  
bc3d ..			.dmark: db "D->"  
bc40 f1			.pastdmark: pop af  
bc41			endm  
# End of macro DMARK
bc41				CALLMONITOR 
bc41 cd 6f ee			call debug_vector  
bc44				endm  
# End of macro CALLMONITOR
bc44			endif	 
bc44			 
bc44			.noadv:	 
bc44			 
bc44					if DEBUG_FORTH_DOT_WAIT 
bc44							call next_page_prompt 
bc44					endif	 
bc44			; TODO this pop off the stack causes a crash. i dont know why 
bc44			 
bc44			 
bc44			if DEBUG_FORTH_DOT 
bc44				DMARK "DTh" 
bc44 f5				push af  
bc45 3a 59 bc			ld a, (.dmark)  
bc48 32 6b ee			ld (debug_mark),a  
bc4b 3a 5a bc			ld a, (.dmark+1)  
bc4e 32 6c ee			ld (debug_mark+1),a  
bc51 3a 5b bc			ld a, (.dmark+2)  
bc54 32 6d ee			ld (debug_mark+2),a  
bc57 18 03			jr .pastdmark  
bc59 ..			.dmark: db "DTh"  
bc5c f1			.pastdmark: pop af  
bc5d			endm  
# End of macro DMARK
bc5d				CALLMONITOR 
bc5d cd 6f ee			call debug_vector  
bc60				endm  
# End of macro CALLMONITOR
bc60			endif	 
bc60			 
bc60					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc60 cd 2b 9d			call macro_forth_dsp_pop 
bc63				endm 
# End of macro FORTH_DSP_POP
bc63			 
bc63			if DEBUG_FORTH_DOT 
bc63				DMARK "DTi" 
bc63 f5				push af  
bc64 3a 78 bc			ld a, (.dmark)  
bc67 32 6b ee			ld (debug_mark),a  
bc6a 3a 79 bc			ld a, (.dmark+1)  
bc6d 32 6c ee			ld (debug_mark+1),a  
bc70 3a 7a bc			ld a, (.dmark+2)  
bc73 32 6d ee			ld (debug_mark+2),a  
bc76 18 03			jr .pastdmark  
bc78 ..			.dmark: db "DTi"  
bc7b f1			.pastdmark: pop af  
bc7c			endm  
# End of macro DMARK
bc7c				CALLMONITOR 
bc7c cd 6f ee			call debug_vector  
bc7f				endm  
# End of macro CALLMONITOR
bc7f			endif	 
bc7f			 
bc7f			 
bc7f					NEXTW 
bc7f c3 29 9e			jp macro_next 
bc82				endm 
# End of macro NEXTW
bc82			 
bc82			.CLS: 
bc82				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bc82 35				db WORD_SYS_CORE+33             
bc83 af bc			dw .DRAW            
bc85 04				db 3 + 1 
bc86 .. 00			db "CLS",0              
bc8a				endm 
# End of macro CWHEAD
bc8a			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bc8a					if DEBUG_FORTH_WORDS_KEY 
bc8a						DMARK "CLS" 
bc8a f5				push af  
bc8b 3a 9f bc			ld a, (.dmark)  
bc8e 32 6b ee			ld (debug_mark),a  
bc91 3a a0 bc			ld a, (.dmark+1)  
bc94 32 6c ee			ld (debug_mark+1),a  
bc97 3a a1 bc			ld a, (.dmark+2)  
bc9a 32 6d ee			ld (debug_mark+2),a  
bc9d 18 03			jr .pastdmark  
bc9f ..			.dmark: db "CLS"  
bca2 f1			.pastdmark: pop af  
bca3			endm  
# End of macro DMARK
bca3						CALLMONITOR 
bca3 cd 6f ee			call debug_vector  
bca6				endm  
# End of macro CALLMONITOR
bca6					endif 
bca6 cd ba 8a				call clear_display 
bca9 c3 bd bd				jp .home		; and home cursor 
bcac					NEXTW 
bcac c3 29 9e			jp macro_next 
bcaf				endm 
# End of macro NEXTW
bcaf			 
bcaf			.DRAW: 
bcaf				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
bcaf 36				db WORD_SYS_CORE+34             
bcb0 da bc			dw .DUMP            
bcb2 05				db 4 + 1 
bcb3 .. 00			db "DRAW",0              
bcb8				endm 
# End of macro CWHEAD
bcb8			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bcb8					if DEBUG_FORTH_WORDS_KEY 
bcb8						DMARK "DRW" 
bcb8 f5				push af  
bcb9 3a cd bc			ld a, (.dmark)  
bcbc 32 6b ee			ld (debug_mark),a  
bcbf 3a ce bc			ld a, (.dmark+1)  
bcc2 32 6c ee			ld (debug_mark+1),a  
bcc5 3a cf bc			ld a, (.dmark+2)  
bcc8 32 6d ee			ld (debug_mark+2),a  
bccb 18 03			jr .pastdmark  
bccd ..			.dmark: db "DRW"  
bcd0 f1			.pastdmark: pop af  
bcd1			endm  
# End of macro DMARK
bcd1						CALLMONITOR 
bcd1 cd 6f ee			call debug_vector  
bcd4				endm  
# End of macro CALLMONITOR
bcd4					endif 
bcd4 cd dd 8a				call update_display 
bcd7					NEXTW 
bcd7 c3 29 9e			jp macro_next 
bcda				endm 
# End of macro NEXTW
bcda			 
bcda			.DUMP: 
bcda				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bcda 37				db WORD_SYS_CORE+35             
bcdb 12 bd			dw .CDUMP            
bcdd 05				db 4 + 1 
bcde .. 00			db "DUMP",0              
bce3				endm 
# End of macro CWHEAD
bce3			; | DUMP ( x -- ) With address x display dump   | DONE 
bce3			; TODO pop address to use off of the stack 
bce3					if DEBUG_FORTH_WORDS_KEY 
bce3						DMARK "DUM" 
bce3 f5				push af  
bce4 3a f8 bc			ld a, (.dmark)  
bce7 32 6b ee			ld (debug_mark),a  
bcea 3a f9 bc			ld a, (.dmark+1)  
bced 32 6c ee			ld (debug_mark+1),a  
bcf0 3a fa bc			ld a, (.dmark+2)  
bcf3 32 6d ee			ld (debug_mark+2),a  
bcf6 18 03			jr .pastdmark  
bcf8 ..			.dmark: db "DUM"  
bcfb f1			.pastdmark: pop af  
bcfc			endm  
# End of macro DMARK
bcfc						CALLMONITOR 
bcfc cd 6f ee			call debug_vector  
bcff				endm  
# End of macro CALLMONITOR
bcff					endif 
bcff cd ba 8a				call clear_display 
bd02			 
bd02					; get address 
bd02			 
bd02					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd02 cd 73 9c			call macro_dsp_valuehl 
bd05				endm 
# End of macro FORTH_DSP_VALUEHL
bd05				 
bd05					; save it for cdump 
bd05			 
bd05 22 e4 e5				ld (os_cur_ptr),hl 
bd08			 
bd08					; destroy value TOS 
bd08			 
bd08					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd08 cd 2b 9d			call macro_forth_dsp_pop 
bd0b				endm 
# End of macro FORTH_DSP_POP
bd0b			 
bd0b cd ee 98				call dumpcont	; skip old style of param parsing	 
bd0e c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bd0f					NEXTW 
bd0f c3 29 9e			jp macro_next 
bd12				endm 
# End of macro NEXTW
bd12			.CDUMP: 
bd12				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bd12 38				db WORD_SYS_CORE+36             
bd13 42 bd			dw .DAT            
bd15 06				db 5 + 1 
bd16 .. 00			db "CDUMP",0              
bd1c				endm 
# End of macro CWHEAD
bd1c			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bd1c					if DEBUG_FORTH_WORDS_KEY 
bd1c						DMARK "CDP" 
bd1c f5				push af  
bd1d 3a 31 bd			ld a, (.dmark)  
bd20 32 6b ee			ld (debug_mark),a  
bd23 3a 32 bd			ld a, (.dmark+1)  
bd26 32 6c ee			ld (debug_mark+1),a  
bd29 3a 33 bd			ld a, (.dmark+2)  
bd2c 32 6d ee			ld (debug_mark+2),a  
bd2f 18 03			jr .pastdmark  
bd31 ..			.dmark: db "CDP"  
bd34 f1			.pastdmark: pop af  
bd35			endm  
# End of macro DMARK
bd35						CALLMONITOR 
bd35 cd 6f ee			call debug_vector  
bd38				endm  
# End of macro CALLMONITOR
bd38					endif 
bd38 cd ba 8a				call clear_display 
bd3b cd ee 98				call dumpcont	 
bd3e c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
bd3f					NEXTW 
bd3f c3 29 9e			jp macro_next 
bd42				endm 
# End of macro NEXTW
bd42			 
bd42			 
bd42			 
bd42			 
bd42			.DAT: 
bd42				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
bd42 3d				db WORD_SYS_CORE+41             
bd43 98 bd			dw .HOME            
bd45 03				db 2 + 1 
bd46 .. 00			db "AT",0              
bd49				endm 
# End of macro CWHEAD
bd49			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
bd49					if DEBUG_FORTH_WORDS_KEY 
bd49						DMARK "AT." 
bd49 f5				push af  
bd4a 3a 5e bd			ld a, (.dmark)  
bd4d 32 6b ee			ld (debug_mark),a  
bd50 3a 5f bd			ld a, (.dmark+1)  
bd53 32 6c ee			ld (debug_mark+1),a  
bd56 3a 60 bd			ld a, (.dmark+2)  
bd59 32 6d ee			ld (debug_mark+2),a  
bd5c 18 03			jr .pastdmark  
bd5e ..			.dmark: db "AT."  
bd61 f1			.pastdmark: pop af  
bd62			endm  
# End of macro DMARK
bd62						CALLMONITOR 
bd62 cd 6f ee			call debug_vector  
bd65				endm  
# End of macro CALLMONITOR
bd65					endif 
bd65					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd65 cd 73 9c			call macro_dsp_valuehl 
bd68				endm 
# End of macro FORTH_DSP_VALUEHL
bd68			 
bd68			 
bd68					; TODO save cursor row 
bd68 7d					ld a,l 
bd69 fe 02				cp 2 
bd6b 20 04				jr nz, .crow3 
bd6d 3e 28				ld a, display_row_2 
bd6f 18 12				jr .ccol1 
bd71 fe 03		.crow3:		cp 3 
bd73 20 04				jr nz, .crow4 
bd75 3e 50				ld a, display_row_3 
bd77 18 0a				jr .ccol1 
bd79 fe 04		.crow4:		cp 4 
bd7b 20 04				jr nz, .crow1 
bd7d 3e 78				ld a, display_row_4 
bd7f 18 02				jr .ccol1 
bd81 3e 00		.crow1:		ld a,display_row_1 
bd83 f5			.ccol1:		push af			; got row offset 
bd84 6f					ld l,a 
bd85 26 00				ld h,0 
bd87					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd87 cd 2b 9d			call macro_forth_dsp_pop 
bd8a				endm 
# End of macro FORTH_DSP_POP
bd8a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd8a cd 73 9c			call macro_dsp_valuehl 
bd8d				endm 
# End of macro FORTH_DSP_VALUEHL
bd8d					; TODO save cursor col 
bd8d f1					pop af 
bd8e 85					add l		; add col offset 
bd8f 32 5e ea				ld (f_cursor_ptr), a 
bd92					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd92 cd 2b 9d			call macro_forth_dsp_pop 
bd95				endm 
# End of macro FORTH_DSP_POP
bd95			 
bd95					; calculate  
bd95			 
bd95					NEXTW 
bd95 c3 29 9e			jp macro_next 
bd98				endm 
# End of macro NEXTW
bd98			 
bd98			 
bd98			.HOME: 
bd98				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
bd98 41				db WORD_SYS_CORE+45             
bd99 c5 bd			dw .CR            
bd9b 05				db 4 + 1 
bd9c .. 00			db "HOME",0              
bda1				endm 
# End of macro CWHEAD
bda1			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
bda1					if DEBUG_FORTH_WORDS_KEY 
bda1						DMARK "HOM" 
bda1 f5				push af  
bda2 3a b6 bd			ld a, (.dmark)  
bda5 32 6b ee			ld (debug_mark),a  
bda8 3a b7 bd			ld a, (.dmark+1)  
bdab 32 6c ee			ld (debug_mark+1),a  
bdae 3a b8 bd			ld a, (.dmark+2)  
bdb1 32 6d ee			ld (debug_mark+2),a  
bdb4 18 03			jr .pastdmark  
bdb6 ..			.dmark: db "HOM"  
bdb9 f1			.pastdmark: pop af  
bdba			endm  
# End of macro DMARK
bdba						CALLMONITOR 
bdba cd 6f ee			call debug_vector  
bdbd				endm  
# End of macro CALLMONITOR
bdbd					endif 
bdbd 3e 00		.home:		ld a, 0		; and home cursor 
bdbf 32 5e ea				ld (f_cursor_ptr), a 
bdc2					NEXTW 
bdc2 c3 29 9e			jp macro_next 
bdc5				endm 
# End of macro NEXTW
bdc5			 
bdc5			 
bdc5			.CR: 
bdc5				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
bdc5 46				db WORD_SYS_CORE+50             
bdc6 00 be			dw .SPACE            
bdc8 03				db 2 + 1 
bdc9 .. 00			db "CR",0              
bdcc				endm 
# End of macro CWHEAD
bdcc			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
bdcc					if DEBUG_FORTH_WORDS_KEY 
bdcc						DMARK "CR." 
bdcc f5				push af  
bdcd 3a e1 bd			ld a, (.dmark)  
bdd0 32 6b ee			ld (debug_mark),a  
bdd3 3a e2 bd			ld a, (.dmark+1)  
bdd6 32 6c ee			ld (debug_mark+1),a  
bdd9 3a e3 bd			ld a, (.dmark+2)  
bddc 32 6d ee			ld (debug_mark+2),a  
bddf 18 03			jr .pastdmark  
bde1 ..			.dmark: db "CR."  
bde4 f1			.pastdmark: pop af  
bde5			endm  
# End of macro DMARK
bde5						CALLMONITOR 
bde5 cd 6f ee			call debug_vector  
bde8				endm  
# End of macro CALLMONITOR
bde8					endif 
bde8 3e 0d				ld a, 13 
bdea 32 c1 e2				ld (scratch),a 
bded 3e 0a				ld a, 10 
bdef 32 c2 e2				ld (scratch+1),a 
bdf2 3e 00				ld a, 0 
bdf4 32 c3 e2				ld (scratch+2),a 
bdf7 21 c1 e2				ld hl, scratch 
bdfa cd dc 9a				call forth_push_str 
bdfd					 
bdfd				       NEXTW 
bdfd c3 29 9e			jp macro_next 
be00				endm 
# End of macro NEXTW
be00			.SPACE: 
be00				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
be00 46				db WORD_SYS_CORE+50             
be01 36 be			dw .SPACES            
be03 03				db 2 + 1 
be04 .. 00			db "BL",0              
be07				endm 
# End of macro CWHEAD
be07			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
be07					if DEBUG_FORTH_WORDS_KEY 
be07						DMARK "BL." 
be07 f5				push af  
be08 3a 1c be			ld a, (.dmark)  
be0b 32 6b ee			ld (debug_mark),a  
be0e 3a 1d be			ld a, (.dmark+1)  
be11 32 6c ee			ld (debug_mark+1),a  
be14 3a 1e be			ld a, (.dmark+2)  
be17 32 6d ee			ld (debug_mark+2),a  
be1a 18 03			jr .pastdmark  
be1c ..			.dmark: db "BL."  
be1f f1			.pastdmark: pop af  
be20			endm  
# End of macro DMARK
be20						CALLMONITOR 
be20 cd 6f ee			call debug_vector  
be23				endm  
# End of macro CALLMONITOR
be23					endif 
be23 3e 20				ld a, " " 
be25 32 c1 e2				ld (scratch),a 
be28 3e 00				ld a, 0 
be2a 32 c2 e2				ld (scratch+1),a 
be2d 21 c1 e2				ld hl, scratch 
be30 cd dc 9a				call forth_push_str 
be33					 
be33				       NEXTW 
be33 c3 29 9e			jp macro_next 
be36				endm 
# End of macro NEXTW
be36			 
be36			;.blstr: db " ", 0 
be36			 
be36			.SPACES: 
be36				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
be36 47				db WORD_SYS_CORE+51             
be37 d1 be			dw .SCROLL            
be39 07				db 6 + 1 
be3a .. 00			db "SPACES",0              
be41				endm 
# End of macro CWHEAD
be41			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
be41					if DEBUG_FORTH_WORDS_KEY 
be41						DMARK "SPS" 
be41 f5				push af  
be42 3a 56 be			ld a, (.dmark)  
be45 32 6b ee			ld (debug_mark),a  
be48 3a 57 be			ld a, (.dmark+1)  
be4b 32 6c ee			ld (debug_mark+1),a  
be4e 3a 58 be			ld a, (.dmark+2)  
be51 32 6d ee			ld (debug_mark+2),a  
be54 18 03			jr .pastdmark  
be56 ..			.dmark: db "SPS"  
be59 f1			.pastdmark: pop af  
be5a			endm  
# End of macro DMARK
be5a						CALLMONITOR 
be5a cd 6f ee			call debug_vector  
be5d				endm  
# End of macro CALLMONITOR
be5d					endif 
be5d			 
be5d			 
be5d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be5d cd 73 9c			call macro_dsp_valuehl 
be60				endm 
# End of macro FORTH_DSP_VALUEHL
be60			 
be60 e5					push hl    ; u 
be61					if DEBUG_FORTH_WORDS 
be61						DMARK "SPA" 
be61 f5				push af  
be62 3a 76 be			ld a, (.dmark)  
be65 32 6b ee			ld (debug_mark),a  
be68 3a 77 be			ld a, (.dmark+1)  
be6b 32 6c ee			ld (debug_mark+1),a  
be6e 3a 78 be			ld a, (.dmark+2)  
be71 32 6d ee			ld (debug_mark+2),a  
be74 18 03			jr .pastdmark  
be76 ..			.dmark: db "SPA"  
be79 f1			.pastdmark: pop af  
be7a			endm  
# End of macro DMARK
be7a						CALLMONITOR 
be7a cd 6f ee			call debug_vector  
be7d				endm  
# End of macro CALLMONITOR
be7d					endif 
be7d			 
be7d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be7d cd 2b 9d			call macro_forth_dsp_pop 
be80				endm 
# End of macro FORTH_DSP_POP
be80 e1					pop hl 
be81 0e 00				ld c, 0 
be83 45					ld b, l 
be84 21 c1 e2				ld hl, scratch  
be87			 
be87					if DEBUG_FORTH_WORDS 
be87						DMARK "SP2" 
be87 f5				push af  
be88 3a 9c be			ld a, (.dmark)  
be8b 32 6b ee			ld (debug_mark),a  
be8e 3a 9d be			ld a, (.dmark+1)  
be91 32 6c ee			ld (debug_mark+1),a  
be94 3a 9e be			ld a, (.dmark+2)  
be97 32 6d ee			ld (debug_mark+2),a  
be9a 18 03			jr .pastdmark  
be9c ..			.dmark: db "SP2"  
be9f f1			.pastdmark: pop af  
bea0			endm  
# End of macro DMARK
bea0						CALLMONITOR 
bea0 cd 6f ee			call debug_vector  
bea3				endm  
# End of macro CALLMONITOR
bea3					endif 
bea3 3e 20				ld a, ' ' 
bea5			.spaces1:	 
bea5 77					ld (hl),a 
bea6 23					inc hl 
bea7					 
bea7 10 fc				djnz .spaces1 
bea9 3e 00				ld a,0 
beab 77					ld (hl),a 
beac 21 c1 e2				ld hl, scratch 
beaf					if DEBUG_FORTH_WORDS 
beaf						DMARK "SP3" 
beaf f5				push af  
beb0 3a c4 be			ld a, (.dmark)  
beb3 32 6b ee			ld (debug_mark),a  
beb6 3a c5 be			ld a, (.dmark+1)  
beb9 32 6c ee			ld (debug_mark+1),a  
bebc 3a c6 be			ld a, (.dmark+2)  
bebf 32 6d ee			ld (debug_mark+2),a  
bec2 18 03			jr .pastdmark  
bec4 ..			.dmark: db "SP3"  
bec7 f1			.pastdmark: pop af  
bec8			endm  
# End of macro DMARK
bec8						CALLMONITOR 
bec8 cd 6f ee			call debug_vector  
becb				endm  
# End of macro CALLMONITOR
becb					endif 
becb cd dc 9a				call forth_push_str 
bece			 
bece				       NEXTW 
bece c3 29 9e			jp macro_next 
bed1				endm 
# End of macro NEXTW
bed1			 
bed1			 
bed1			 
bed1			.SCROLL: 
bed1				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
bed1 53				db WORD_SYS_CORE+63             
bed2 fe be			dw .SCROLLD            
bed4 07				db 6 + 1 
bed5 .. 00			db "SCROLL",0              
bedc				endm 
# End of macro CWHEAD
bedc			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
bedc					if DEBUG_FORTH_WORDS_KEY 
bedc						DMARK "SCR" 
bedc f5				push af  
bedd 3a f1 be			ld a, (.dmark)  
bee0 32 6b ee			ld (debug_mark),a  
bee3 3a f2 be			ld a, (.dmark+1)  
bee6 32 6c ee			ld (debug_mark+1),a  
bee9 3a f3 be			ld a, (.dmark+2)  
beec 32 6d ee			ld (debug_mark+2),a  
beef 18 03			jr .pastdmark  
bef1 ..			.dmark: db "SCR"  
bef4 f1			.pastdmark: pop af  
bef5			endm  
# End of macro DMARK
bef5						CALLMONITOR 
bef5 cd 6f ee			call debug_vector  
bef8				endm  
# End of macro CALLMONITOR
bef8					endif 
bef8			 
bef8 cd 7c 8a			call scroll_up 
befb			;	call update_display 
befb			 
befb					NEXTW 
befb c3 29 9e			jp macro_next 
befe				endm 
# End of macro NEXTW
befe			 
befe			 
befe			 
befe			;		; get dir 
befe			; 
befe			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
befe			; 
befe			;		push hl 
befe			; 
befe			;		; destroy value TOS 
befe			; 
befe			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
befe			; 
befe			;		; get count 
befe			; 
befe			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
befe			; 
befe			;		push hl 
befe			; 
befe			;		; destroy value TOS 
befe			; 
befe			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
befe			; 
befe			;		; one value on hl get other one back 
befe			; 
befe			;		pop bc    ; count 
befe			; 
befe			;		pop de   ; dir 
befe			; 
befe			; 
befe			;		ld b, c 
befe			; 
befe			;.scrolldir:     push bc 
befe			;		push de 
befe			; 
befe			;		ld a, 0 
befe			;		cp e 
befe			;		jr z, .scrollup  
befe			;		call scroll_down 
befe			;		jr .scrollnext 
befe			;.scrollup:	call scroll_up 
befe			; 
befe			;		 
befe			;.scrollnext: 
befe			;		pop de 
befe			;		pop bc 
befe			;		djnz .scrolldir 
befe			; 
befe			; 
befe			; 
befe			; 
befe			; 
befe			;		NEXTW 
befe			 
befe			.SCROLLD: 
befe				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
befe 53				db WORD_SYS_CORE+63             
beff 2c bf			dw .ATQ            
bf01 08				db 7 + 1 
bf02 .. 00			db "SCROLLD",0              
bf0a				endm 
# End of macro CWHEAD
bf0a			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
bf0a					if DEBUG_FORTH_WORDS_KEY 
bf0a						DMARK "SCD" 
bf0a f5				push af  
bf0b 3a 1f bf			ld a, (.dmark)  
bf0e 32 6b ee			ld (debug_mark),a  
bf11 3a 20 bf			ld a, (.dmark+1)  
bf14 32 6c ee			ld (debug_mark+1),a  
bf17 3a 21 bf			ld a, (.dmark+2)  
bf1a 32 6d ee			ld (debug_mark+2),a  
bf1d 18 03			jr .pastdmark  
bf1f ..			.dmark: db "SCD"  
bf22 f1			.pastdmark: pop af  
bf23			endm  
# End of macro DMARK
bf23						CALLMONITOR 
bf23 cd 6f ee			call debug_vector  
bf26				endm  
# End of macro CALLMONITOR
bf26					endif 
bf26			 
bf26 cd a0 8a			call scroll_down 
bf29			;	call update_display 
bf29			 
bf29					NEXTW 
bf29 c3 29 9e			jp macro_next 
bf2c				endm 
# End of macro NEXTW
bf2c			 
bf2c			 
bf2c			.ATQ: 
bf2c				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bf2c 62				db WORD_SYS_CORE+78             
bf2d 8a bf			dw .AUTODSP            
bf2f 04				db 3 + 1 
bf30 .. 00			db "AT@",0              
bf34				endm 
# End of macro CWHEAD
bf34			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bf34					if DEBUG_FORTH_WORDS_KEY 
bf34						DMARK "ATA" 
bf34 f5				push af  
bf35 3a 49 bf			ld a, (.dmark)  
bf38 32 6b ee			ld (debug_mark),a  
bf3b 3a 4a bf			ld a, (.dmark+1)  
bf3e 32 6c ee			ld (debug_mark+1),a  
bf41 3a 4b bf			ld a, (.dmark+2)  
bf44 32 6d ee			ld (debug_mark+2),a  
bf47 18 03			jr .pastdmark  
bf49 ..			.dmark: db "ATA"  
bf4c f1			.pastdmark: pop af  
bf4d			endm  
# End of macro DMARK
bf4d						CALLMONITOR 
bf4d cd 6f ee			call debug_vector  
bf50				endm  
# End of macro CALLMONITOR
bf50					endif 
bf50			 
bf50			 
bf50					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf50 cd 73 9c			call macro_dsp_valuehl 
bf53				endm 
# End of macro FORTH_DSP_VALUEHL
bf53			 
bf53					; TODO save cursor row 
bf53 7d					ld a,l 
bf54 fe 02				cp 2 
bf56 20 04				jr nz, .crow3aq 
bf58 3e 28				ld a, display_row_2 
bf5a 18 12				jr .ccol1aq 
bf5c fe 03		.crow3aq:		cp 3 
bf5e 20 04				jr nz, .crow4aq 
bf60 3e 50				ld a, display_row_3 
bf62 18 0a				jr .ccol1aq 
bf64 fe 04		.crow4aq:		cp 4 
bf66 20 04				jr nz, .crow1aq 
bf68 3e 78				ld a, display_row_4 
bf6a 18 02				jr .ccol1aq 
bf6c 3e 00		.crow1aq:		ld a,display_row_1 
bf6e f5			.ccol1aq:		push af			; got row offset 
bf6f 6f					ld l,a 
bf70 26 00				ld h,0 
bf72					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf72 cd 2b 9d			call macro_forth_dsp_pop 
bf75				endm 
# End of macro FORTH_DSP_POP
bf75					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf75 cd 73 9c			call macro_dsp_valuehl 
bf78				endm 
# End of macro FORTH_DSP_VALUEHL
bf78					; TODO save cursor col 
bf78 f1					pop af 
bf79 85					add l		; add col offset 
bf7a			 
bf7a					; add current frame buffer address 
bf7a 2a cc eb				ld hl, (display_fb_active) 
bf7d cd e7 8c				call addatohl 
bf80			 
bf80			 
bf80			 
bf80			 
bf80					; get char frame buffer location offset in hl 
bf80			 
bf80 7e					ld a,(hl) 
bf81 26 00				ld h, 0 
bf83 6f					ld l, a 
bf84			 
bf84 cd 6e 9a				call forth_push_numhl 
bf87			 
bf87			 
bf87					NEXTW 
bf87 c3 29 9e			jp macro_next 
bf8a				endm 
# End of macro NEXTW
bf8a			 
bf8a			.AUTODSP: 
bf8a				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bf8a 63				db WORD_SYS_CORE+79             
bf8b a0 bf			dw .MENU            
bf8d 05				db 4 + 1 
bf8e .. 00			db "ADSP",0              
bf93				endm 
# End of macro CWHEAD
bf93			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bf93			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bf93			 
bf93					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf93 cd 73 9c			call macro_dsp_valuehl 
bf96				endm 
# End of macro FORTH_DSP_VALUEHL
bf96			 
bf96			;		push hl 
bf96			 
bf96					; destroy value TOS 
bf96			 
bf96					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf96 cd 2b 9d			call macro_forth_dsp_pop 
bf99				endm 
# End of macro FORTH_DSP_POP
bf99			 
bf99			;		pop hl 
bf99			 
bf99 7d					ld a,l 
bf9a 32 3c ea				ld (cli_autodisplay), a 
bf9d				       NEXTW 
bf9d c3 29 9e			jp macro_next 
bfa0				endm 
# End of macro NEXTW
bfa0			 
bfa0			.MENU: 
bfa0				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bfa0 70				db WORD_SYS_CORE+92             
bfa1 49 c0			dw .ENDDISPLAY            
bfa3 05				db 4 + 1 
bfa4 .. 00			db "MENU",0              
bfa9				endm 
# End of macro CWHEAD
bfa9			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
bfa9			 
bfa9			;		; get number of items on the stack 
bfa9			; 
bfa9				 
bfa9					FORTH_DSP_VALUEHL 
bfa9 cd 73 9c			call macro_dsp_valuehl 
bfac				endm 
# End of macro FORTH_DSP_VALUEHL
bfac				 
bfac					if DEBUG_FORTH_WORDS_KEY 
bfac						DMARK "MNU" 
bfac f5				push af  
bfad 3a c1 bf			ld a, (.dmark)  
bfb0 32 6b ee			ld (debug_mark),a  
bfb3 3a c2 bf			ld a, (.dmark+1)  
bfb6 32 6c ee			ld (debug_mark+1),a  
bfb9 3a c3 bf			ld a, (.dmark+2)  
bfbc 32 6d ee			ld (debug_mark+2),a  
bfbf 18 03			jr .pastdmark  
bfc1 ..			.dmark: db "MNU"  
bfc4 f1			.pastdmark: pop af  
bfc5			endm  
# End of macro DMARK
bfc5						CALLMONITOR 
bfc5 cd 6f ee			call debug_vector  
bfc8				endm  
# End of macro CALLMONITOR
bfc8					endif 
bfc8			 
bfc8 45					ld b, l	 
bfc9 05					dec b 
bfca			 
bfca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfca cd 2b 9d			call macro_forth_dsp_pop 
bfcd				endm 
# End of macro FORTH_DSP_POP
bfcd			 
bfcd			 
bfcd					; go directly through the stack to pluck out the string pointers and build an array 
bfcd			 
bfcd			;		FORTH_DSP 
bfcd			 
bfcd					; hl contains top most stack item 
bfcd				 
bfcd 11 c1 e2				ld de, scratch 
bfd0			 
bfd0			.mbuild: 
bfd0			 
bfd0					FORTH_DSP_VALUEHL 
bfd0 cd 73 9c			call macro_dsp_valuehl 
bfd3				endm 
# End of macro FORTH_DSP_VALUEHL
bfd3			 
bfd3					if DEBUG_FORTH_WORDS 
bfd3						DMARK "MN3" 
bfd3 f5				push af  
bfd4 3a e8 bf			ld a, (.dmark)  
bfd7 32 6b ee			ld (debug_mark),a  
bfda 3a e9 bf			ld a, (.dmark+1)  
bfdd 32 6c ee			ld (debug_mark+1),a  
bfe0 3a ea bf			ld a, (.dmark+2)  
bfe3 32 6d ee			ld (debug_mark+2),a  
bfe6 18 03			jr .pastdmark  
bfe8 ..			.dmark: db "MN3"  
bfeb f1			.pastdmark: pop af  
bfec			endm  
# End of macro DMARK
bfec						CALLMONITOR 
bfec cd 6f ee			call debug_vector  
bfef				endm  
# End of macro CALLMONITOR
bfef					endif 
bfef eb					ex de, hl 
bff0 73					ld (hl), e 
bff1 23					inc hl 
bff2 72					ld (hl), d 
bff3 23					inc hl 
bff4 eb					ex de, hl 
bff5			 
bff5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bff5 cd 2b 9d			call macro_forth_dsp_pop 
bff8				endm 
# End of macro FORTH_DSP_POP
bff8			 
bff8 10 d6				djnz .mbuild 
bffa			 
bffa					; done add term 
bffa			 
bffa eb					ex de, hl 
bffb 36 00				ld (hl), 0 
bffd 23					inc hl 
bffe 36 00				ld (hl), 0 
c000			 
c000				 
c000					 
c000 21 c1 e2				ld hl, scratch 
c003			 
c003					if DEBUG_FORTH_WORDS 
c003						DMARK "MNx" 
c003 f5				push af  
c004 3a 18 c0			ld a, (.dmark)  
c007 32 6b ee			ld (debug_mark),a  
c00a 3a 19 c0			ld a, (.dmark+1)  
c00d 32 6c ee			ld (debug_mark+1),a  
c010 3a 1a c0			ld a, (.dmark+2)  
c013 32 6d ee			ld (debug_mark+2),a  
c016 18 03			jr .pastdmark  
c018 ..			.dmark: db "MNx"  
c01b f1			.pastdmark: pop af  
c01c			endm  
# End of macro DMARK
c01c						CALLMONITOR 
c01c cd 6f ee			call debug_vector  
c01f				endm  
# End of macro CALLMONITOR
c01f					endif 
c01f			 
c01f			 
c01f			 
c01f 3e 00				ld a, 0 
c021 cd eb 8a				call menu 
c024			 
c024			 
c024 6f					ld l, a 
c025 26 00				ld h, 0 
c027			 
c027					if DEBUG_FORTH_WORDS 
c027						DMARK "MNr" 
c027 f5				push af  
c028 3a 3c c0			ld a, (.dmark)  
c02b 32 6b ee			ld (debug_mark),a  
c02e 3a 3d c0			ld a, (.dmark+1)  
c031 32 6c ee			ld (debug_mark+1),a  
c034 3a 3e c0			ld a, (.dmark+2)  
c037 32 6d ee			ld (debug_mark+2),a  
c03a 18 03			jr .pastdmark  
c03c ..			.dmark: db "MNr"  
c03f f1			.pastdmark: pop af  
c040			endm  
# End of macro DMARK
c040						CALLMONITOR 
c040 cd 6f ee			call debug_vector  
c043				endm  
# End of macro CALLMONITOR
c043					endif 
c043			 
c043 cd 6e 9a				call forth_push_numhl 
c046			 
c046			 
c046			 
c046			 
c046				       NEXTW 
c046 c3 29 9e			jp macro_next 
c049				endm 
# End of macro NEXTW
c049			 
c049			 
c049			.ENDDISPLAY: 
c049			 
c049			; eof 
# End of file forth_words_display.asm
c049			include "forth_words_str.asm" 
c049			 
c049			; | ## String Words 
c049			 
c049			.PTR:   
c049			 
c049				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c049 48				db WORD_SYS_CORE+52             
c04a 76 c0			dw .STYPE            
c04c 04				db 3 + 1 
c04d .. 00			db "PTR",0              
c051				endm 
# End of macro CWHEAD
c051			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c051			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c051			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c051			 
c051					if DEBUG_FORTH_WORDS_KEY 
c051						DMARK "PTR" 
c051 f5				push af  
c052 3a 66 c0			ld a, (.dmark)  
c055 32 6b ee			ld (debug_mark),a  
c058 3a 67 c0			ld a, (.dmark+1)  
c05b 32 6c ee			ld (debug_mark+1),a  
c05e 3a 68 c0			ld a, (.dmark+2)  
c061 32 6d ee			ld (debug_mark+2),a  
c064 18 03			jr .pastdmark  
c066 ..			.dmark: db "PTR"  
c069 f1			.pastdmark: pop af  
c06a			endm  
# End of macro DMARK
c06a						CALLMONITOR 
c06a cd 6f ee			call debug_vector  
c06d				endm  
# End of macro CALLMONITOR
c06d					endif 
c06d					FORTH_DSP_VALUEHL 
c06d cd 73 9c			call macro_dsp_valuehl 
c070				endm 
# End of macro FORTH_DSP_VALUEHL
c070 cd 6e 9a				call forth_push_numhl 
c073			 
c073			 
c073					NEXTW 
c073 c3 29 9e			jp macro_next 
c076				endm 
# End of macro NEXTW
c076			.STYPE: 
c076				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c076 48				db WORD_SYS_CORE+52             
c077 c5 c0			dw .UPPER            
c079 06				db 5 + 1 
c07a .. 00			db "STYPE",0              
c080				endm 
# End of macro CWHEAD
c080			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
c080					if DEBUG_FORTH_WORDS_KEY 
c080						DMARK "STY" 
c080 f5				push af  
c081 3a 95 c0			ld a, (.dmark)  
c084 32 6b ee			ld (debug_mark),a  
c087 3a 96 c0			ld a, (.dmark+1)  
c08a 32 6c ee			ld (debug_mark+1),a  
c08d 3a 97 c0			ld a, (.dmark+2)  
c090 32 6d ee			ld (debug_mark+2),a  
c093 18 03			jr .pastdmark  
c095 ..			.dmark: db "STY"  
c098 f1			.pastdmark: pop af  
c099			endm  
# End of macro DMARK
c099						CALLMONITOR 
c099 cd 6f ee			call debug_vector  
c09c				endm  
# End of macro CALLMONITOR
c09c					endif 
c09c					FORTH_DSP 
c09c cd 39 9c			call macro_forth_dsp 
c09f				endm 
# End of macro FORTH_DSP
c09f					;v5 FORTH_DSP_VALUE 
c09f			 
c09f 7e					ld a, (hl) 
c0a0			 
c0a0 f5					push af 
c0a1			 
c0a1			; Dont destroy TOS		FORTH_DSP_POP 
c0a1			 
c0a1 f1					pop af 
c0a2			 
c0a2 fe 01				cp DS_TYPE_STR 
c0a4 28 09				jr z, .typestr 
c0a6			 
c0a6 fe 02				cp DS_TYPE_INUM 
c0a8 28 0a				jr z, .typeinum 
c0aa			 
c0aa 21 c3 c0				ld hl, .tna 
c0ad 18 0a				jr .tpush 
c0af			 
c0af 21 bf c0		.typestr:	ld hl, .tstr 
c0b2 18 05				jr .tpush 
c0b4 21 c1 c0		.typeinum:	ld hl, .tinum 
c0b7 18 00				jr .tpush 
c0b9			 
c0b9			.tpush: 
c0b9			 
c0b9 cd dc 9a				call forth_push_str 
c0bc			 
c0bc					NEXTW 
c0bc c3 29 9e			jp macro_next 
c0bf				endm 
# End of macro NEXTW
c0bf .. 00		.tstr:	db "s",0 
c0c1 .. 00		.tinum:  db "i",0 
c0c3 .. 00		.tna:   db "?", 0 
c0c5			 
c0c5			 
c0c5			.UPPER: 
c0c5				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c0c5 48				db WORD_SYS_CORE+52             
c0c6 00 c1			dw .LOWER            
c0c8 06				db 5 + 1 
c0c9 .. 00			db "UPPER",0              
c0cf				endm 
# End of macro CWHEAD
c0cf			; | UPPER ( s -- s ) Upper case string s  | DONE 
c0cf					if DEBUG_FORTH_WORDS_KEY 
c0cf						DMARK "UPR" 
c0cf f5				push af  
c0d0 3a e4 c0			ld a, (.dmark)  
c0d3 32 6b ee			ld (debug_mark),a  
c0d6 3a e5 c0			ld a, (.dmark+1)  
c0d9 32 6c ee			ld (debug_mark+1),a  
c0dc 3a e6 c0			ld a, (.dmark+2)  
c0df 32 6d ee			ld (debug_mark+2),a  
c0e2 18 03			jr .pastdmark  
c0e4 ..			.dmark: db "UPR"  
c0e7 f1			.pastdmark: pop af  
c0e8			endm  
# End of macro DMARK
c0e8						CALLMONITOR 
c0e8 cd 6f ee			call debug_vector  
c0eb				endm  
# End of macro CALLMONITOR
c0eb					endif 
c0eb			 
c0eb					FORTH_DSP 
c0eb cd 39 9c			call macro_forth_dsp 
c0ee				endm 
# End of macro FORTH_DSP
c0ee					 
c0ee			; TODO check is string type 
c0ee			 
c0ee					FORTH_DSP_VALUEHL 
c0ee cd 73 9c			call macro_dsp_valuehl 
c0f1				endm 
# End of macro FORTH_DSP_VALUEHL
c0f1			; get pointer to string in hl 
c0f1			 
c0f1 7e			.toup:		ld a, (hl) 
c0f2 fe 00				cp 0 
c0f4 28 07				jr z, .toupdone 
c0f6			 
c0f6 cd 5c 8f				call to_upper 
c0f9			 
c0f9 77					ld (hl), a 
c0fa 23					inc hl 
c0fb 18 f4				jr .toup 
c0fd			 
c0fd					 
c0fd			 
c0fd			 
c0fd			; for each char convert to upper 
c0fd					 
c0fd			.toupdone: 
c0fd			 
c0fd			 
c0fd					NEXTW 
c0fd c3 29 9e			jp macro_next 
c100				endm 
# End of macro NEXTW
c100			.LOWER: 
c100				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c100 48				db WORD_SYS_CORE+52             
c101 3b c1			dw .TCASE            
c103 06				db 5 + 1 
c104 .. 00			db "LOWER",0              
c10a				endm 
# End of macro CWHEAD
c10a			; | LOWER ( s -- s ) Lower case string s  | DONE 
c10a					if DEBUG_FORTH_WORDS_KEY 
c10a						DMARK "LWR" 
c10a f5				push af  
c10b 3a 1f c1			ld a, (.dmark)  
c10e 32 6b ee			ld (debug_mark),a  
c111 3a 20 c1			ld a, (.dmark+1)  
c114 32 6c ee			ld (debug_mark+1),a  
c117 3a 21 c1			ld a, (.dmark+2)  
c11a 32 6d ee			ld (debug_mark+2),a  
c11d 18 03			jr .pastdmark  
c11f ..			.dmark: db "LWR"  
c122 f1			.pastdmark: pop af  
c123			endm  
# End of macro DMARK
c123						CALLMONITOR 
c123 cd 6f ee			call debug_vector  
c126				endm  
# End of macro CALLMONITOR
c126					endif 
c126			 
c126					FORTH_DSP 
c126 cd 39 9c			call macro_forth_dsp 
c129				endm 
# End of macro FORTH_DSP
c129					 
c129			; TODO check is string type 
c129			 
c129					FORTH_DSP_VALUEHL 
c129 cd 73 9c			call macro_dsp_valuehl 
c12c				endm 
# End of macro FORTH_DSP_VALUEHL
c12c			; get pointer to string in hl 
c12c			 
c12c 7e			.tolow:		ld a, (hl) 
c12d fe 00				cp 0 
c12f 28 07				jr z, .tolowdone 
c131			 
c131 cd 65 8f				call to_lower 
c134			 
c134 77					ld (hl), a 
c135 23					inc hl 
c136 18 f4				jr .tolow 
c138			 
c138					 
c138			 
c138			 
c138			; for each char convert to low 
c138					 
c138			.tolowdone: 
c138					NEXTW 
c138 c3 29 9e			jp macro_next 
c13b				endm 
# End of macro NEXTW
c13b			.TCASE: 
c13b				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c13b 48				db WORD_SYS_CORE+52             
c13c 71 c2			dw .SUBSTR            
c13e 06				db 5 + 1 
c13f .. 00			db "TCASE",0              
c145				endm 
# End of macro CWHEAD
c145			; | TCASE ( s -- s ) Title case string s  | DONE 
c145					if DEBUG_FORTH_WORDS_KEY 
c145						DMARK "TCS" 
c145 f5				push af  
c146 3a 5a c1			ld a, (.dmark)  
c149 32 6b ee			ld (debug_mark),a  
c14c 3a 5b c1			ld a, (.dmark+1)  
c14f 32 6c ee			ld (debug_mark+1),a  
c152 3a 5c c1			ld a, (.dmark+2)  
c155 32 6d ee			ld (debug_mark+2),a  
c158 18 03			jr .pastdmark  
c15a ..			.dmark: db "TCS"  
c15d f1			.pastdmark: pop af  
c15e			endm  
# End of macro DMARK
c15e						CALLMONITOR 
c15e cd 6f ee			call debug_vector  
c161				endm  
# End of macro CALLMONITOR
c161					endif 
c161			 
c161					FORTH_DSP 
c161 cd 39 9c			call macro_forth_dsp 
c164				endm 
# End of macro FORTH_DSP
c164					 
c164			; TODO check is string type 
c164			 
c164					FORTH_DSP_VALUEHL 
c164 cd 73 9c			call macro_dsp_valuehl 
c167				endm 
# End of macro FORTH_DSP_VALUEHL
c167			; get pointer to string in hl 
c167			 
c167					if DEBUG_FORTH_WORDS 
c167						DMARK "TC1" 
c167 f5				push af  
c168 3a 7c c1			ld a, (.dmark)  
c16b 32 6b ee			ld (debug_mark),a  
c16e 3a 7d c1			ld a, (.dmark+1)  
c171 32 6c ee			ld (debug_mark+1),a  
c174 3a 7e c1			ld a, (.dmark+2)  
c177 32 6d ee			ld (debug_mark+2),a  
c17a 18 03			jr .pastdmark  
c17c ..			.dmark: db "TC1"  
c17f f1			.pastdmark: pop af  
c180			endm  
# End of macro DMARK
c180						CALLMONITOR 
c180 cd 6f ee			call debug_vector  
c183				endm  
# End of macro CALLMONITOR
c183					endif 
c183			 
c183					; first time in turn to upper case first char 
c183			 
c183 7e					ld a, (hl) 
c184 c3 0e c2				jp .totsiptou 
c187			 
c187			 
c187 7e			.tot:		ld a, (hl) 
c188 fe 00				cp 0 
c18a ca 52 c2				jp z, .totdone 
c18d			 
c18d					if DEBUG_FORTH_WORDS 
c18d						DMARK "TC2" 
c18d f5				push af  
c18e 3a a2 c1			ld a, (.dmark)  
c191 32 6b ee			ld (debug_mark),a  
c194 3a a3 c1			ld a, (.dmark+1)  
c197 32 6c ee			ld (debug_mark+1),a  
c19a 3a a4 c1			ld a, (.dmark+2)  
c19d 32 6d ee			ld (debug_mark+2),a  
c1a0 18 03			jr .pastdmark  
c1a2 ..			.dmark: db "TC2"  
c1a5 f1			.pastdmark: pop af  
c1a6			endm  
# End of macro DMARK
c1a6						CALLMONITOR 
c1a6 cd 6f ee			call debug_vector  
c1a9				endm  
# End of macro CALLMONITOR
c1a9					endif 
c1a9					; check to see if current char is a space 
c1a9			 
c1a9 fe 20				cp ' ' 
c1ab 28 21				jr z, .totsp 
c1ad cd 65 8f				call to_lower 
c1b0					if DEBUG_FORTH_WORDS 
c1b0						DMARK "TC3" 
c1b0 f5				push af  
c1b1 3a c5 c1			ld a, (.dmark)  
c1b4 32 6b ee			ld (debug_mark),a  
c1b7 3a c6 c1			ld a, (.dmark+1)  
c1ba 32 6c ee			ld (debug_mark+1),a  
c1bd 3a c7 c1			ld a, (.dmark+2)  
c1c0 32 6d ee			ld (debug_mark+2),a  
c1c3 18 03			jr .pastdmark  
c1c5 ..			.dmark: db "TC3"  
c1c8 f1			.pastdmark: pop af  
c1c9			endm  
# End of macro DMARK
c1c9						CALLMONITOR 
c1c9 cd 6f ee			call debug_vector  
c1cc				endm  
# End of macro CALLMONITOR
c1cc					endif 
c1cc 18 63				jr .totnxt 
c1ce			 
c1ce			.totsp:         ; on a space, find next char which should be upper 
c1ce			 
c1ce					if DEBUG_FORTH_WORDS 
c1ce						DMARK "TC4" 
c1ce f5				push af  
c1cf 3a e3 c1			ld a, (.dmark)  
c1d2 32 6b ee			ld (debug_mark),a  
c1d5 3a e4 c1			ld a, (.dmark+1)  
c1d8 32 6c ee			ld (debug_mark+1),a  
c1db 3a e5 c1			ld a, (.dmark+2)  
c1de 32 6d ee			ld (debug_mark+2),a  
c1e1 18 03			jr .pastdmark  
c1e3 ..			.dmark: db "TC4"  
c1e6 f1			.pastdmark: pop af  
c1e7			endm  
# End of macro DMARK
c1e7						CALLMONITOR 
c1e7 cd 6f ee			call debug_vector  
c1ea				endm  
# End of macro CALLMONITOR
c1ea					endif 
c1ea					;; 
c1ea			 
c1ea fe 20				cp ' ' 
c1ec 20 20				jr nz, .totsiptou 
c1ee 23					inc hl 
c1ef 7e					ld a, (hl) 
c1f0					if DEBUG_FORTH_WORDS 
c1f0						DMARK "TC5" 
c1f0 f5				push af  
c1f1 3a 05 c2			ld a, (.dmark)  
c1f4 32 6b ee			ld (debug_mark),a  
c1f7 3a 06 c2			ld a, (.dmark+1)  
c1fa 32 6c ee			ld (debug_mark+1),a  
c1fd 3a 07 c2			ld a, (.dmark+2)  
c200 32 6d ee			ld (debug_mark+2),a  
c203 18 03			jr .pastdmark  
c205 ..			.dmark: db "TC5"  
c208 f1			.pastdmark: pop af  
c209			endm  
# End of macro DMARK
c209						CALLMONITOR 
c209 cd 6f ee			call debug_vector  
c20c				endm  
# End of macro CALLMONITOR
c20c					endif 
c20c 18 c0				jr .totsp 
c20e fe 00		.totsiptou:    cp 0 
c210 28 40				jr z, .totdone 
c212					; not space and not zero term so upper case it 
c212 cd 5c 8f				call to_upper 
c215			 
c215					if DEBUG_FORTH_WORDS 
c215						DMARK "TC6" 
c215 f5				push af  
c216 3a 2a c2			ld a, (.dmark)  
c219 32 6b ee			ld (debug_mark),a  
c21c 3a 2b c2			ld a, (.dmark+1)  
c21f 32 6c ee			ld (debug_mark+1),a  
c222 3a 2c c2			ld a, (.dmark+2)  
c225 32 6d ee			ld (debug_mark+2),a  
c228 18 03			jr .pastdmark  
c22a ..			.dmark: db "TC6"  
c22d f1			.pastdmark: pop af  
c22e			endm  
# End of macro DMARK
c22e						CALLMONITOR 
c22e cd 6f ee			call debug_vector  
c231				endm  
# End of macro CALLMONITOR
c231					endif 
c231			 
c231			 
c231			.totnxt: 
c231			 
c231 77					ld (hl), a 
c232 23					inc hl 
c233					if DEBUG_FORTH_WORDS 
c233						DMARK "TC7" 
c233 f5				push af  
c234 3a 48 c2			ld a, (.dmark)  
c237 32 6b ee			ld (debug_mark),a  
c23a 3a 49 c2			ld a, (.dmark+1)  
c23d 32 6c ee			ld (debug_mark+1),a  
c240 3a 4a c2			ld a, (.dmark+2)  
c243 32 6d ee			ld (debug_mark+2),a  
c246 18 03			jr .pastdmark  
c248 ..			.dmark: db "TC7"  
c24b f1			.pastdmark: pop af  
c24c			endm  
# End of macro DMARK
c24c						CALLMONITOR 
c24c cd 6f ee			call debug_vector  
c24f				endm  
# End of macro CALLMONITOR
c24f					endif 
c24f c3 87 c1				jp .tot 
c252			 
c252					 
c252			 
c252			 
c252			; for each char convert to low 
c252					 
c252			.totdone: 
c252					if DEBUG_FORTH_WORDS 
c252						DMARK "TCd" 
c252 f5				push af  
c253 3a 67 c2			ld a, (.dmark)  
c256 32 6b ee			ld (debug_mark),a  
c259 3a 68 c2			ld a, (.dmark+1)  
c25c 32 6c ee			ld (debug_mark+1),a  
c25f 3a 69 c2			ld a, (.dmark+2)  
c262 32 6d ee			ld (debug_mark+2),a  
c265 18 03			jr .pastdmark  
c267 ..			.dmark: db "TCd"  
c26a f1			.pastdmark: pop af  
c26b			endm  
# End of macro DMARK
c26b						CALLMONITOR 
c26b cd 6f ee			call debug_vector  
c26e				endm  
# End of macro CALLMONITOR
c26e					endif 
c26e					NEXTW 
c26e c3 29 9e			jp macro_next 
c271				endm 
# End of macro NEXTW
c271			 
c271			.SUBSTR: 
c271				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c271 48				db WORD_SYS_CORE+52             
c272 cf c2			dw .LEFT            
c274 07				db 6 + 1 
c275 .. 00			db "SUBSTR",0              
c27c				endm 
# End of macro CWHEAD
c27c			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c27c			 
c27c					if DEBUG_FORTH_WORDS_KEY 
c27c						DMARK "SST" 
c27c f5				push af  
c27d 3a 91 c2			ld a, (.dmark)  
c280 32 6b ee			ld (debug_mark),a  
c283 3a 92 c2			ld a, (.dmark+1)  
c286 32 6c ee			ld (debug_mark+1),a  
c289 3a 93 c2			ld a, (.dmark+2)  
c28c 32 6d ee			ld (debug_mark+2),a  
c28f 18 03			jr .pastdmark  
c291 ..			.dmark: db "SST"  
c294 f1			.pastdmark: pop af  
c295			endm  
# End of macro DMARK
c295						CALLMONITOR 
c295 cd 6f ee			call debug_vector  
c298				endm  
# End of macro CALLMONITOR
c298					endif 
c298			; TODO check string type 
c298					FORTH_DSP_VALUEHL 
c298 cd 73 9c			call macro_dsp_valuehl 
c29b				endm 
# End of macro FORTH_DSP_VALUEHL
c29b			 
c29b e5					push hl      ; string length 
c29c			 
c29c					FORTH_DSP_POP 
c29c cd 2b 9d			call macro_forth_dsp_pop 
c29f				endm 
# End of macro FORTH_DSP_POP
c29f			 
c29f					FORTH_DSP_VALUEHL 
c29f cd 73 9c			call macro_dsp_valuehl 
c2a2				endm 
# End of macro FORTH_DSP_VALUEHL
c2a2			 
c2a2 e5					push hl     ; start char 
c2a3			 
c2a3					FORTH_DSP_POP 
c2a3 cd 2b 9d			call macro_forth_dsp_pop 
c2a6				endm 
# End of macro FORTH_DSP_POP
c2a6			 
c2a6			 
c2a6					FORTH_DSP_VALUE 
c2a6 cd 5c 9c			call macro_forth_dsp_value 
c2a9				endm 
# End of macro FORTH_DSP_VALUE
c2a9			 
c2a9 d1					pop de    ; get start post offset 
c2aa			 
c2aa 19					add hl, de    ; starting offset 
c2ab			 
c2ab c1					pop bc 
c2ac c5					push bc      ; grab size of string 
c2ad			 
c2ad e5					push hl    ; save string start  
c2ae			 
c2ae 26 00				ld h, 0 
c2b0 69					ld l, c 
c2b1 23					inc hl 
c2b2 23					inc hl 
c2b3			 
c2b3 cd c2 90				call malloc 
c2b6				if DEBUG_FORTH_MALLOC_GUARD 
c2b6 cc e9 cb				call z,malloc_error 
c2b9				endif 
c2b9			 
c2b9 eb					ex de, hl      ; save malloc area for string copy 
c2ba e1					pop hl    ; get back source 
c2bb c1					pop bc    ; get length of string back 
c2bc			 
c2bc d5					push de    ; save malloc area for after we push 
c2bd ed b0				ldir     ; copy substr 
c2bf			 
c2bf			 
c2bf eb					ex de, hl 
c2c0 3e 00				ld a, 0 
c2c2 77					ld (hl), a   ; term substr 
c2c3			 
c2c3					 
c2c3 e1					pop hl    ; get malloc so we can push it 
c2c4 e5					push hl   ; save so we can free it afterwards 
c2c5			 
c2c5 cd dc 9a				call forth_push_str 
c2c8			 
c2c8 e1					pop hl 
c2c9 cd 8c 91				call free 
c2cc			 
c2cc					 
c2cc					 
c2cc			 
c2cc			 
c2cc					NEXTW 
c2cc c3 29 9e			jp macro_next 
c2cf				endm 
# End of macro NEXTW
c2cf			 
c2cf			.LEFT: 
c2cf				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c2cf 48				db WORD_SYS_CORE+52             
c2d0 f7 c2			dw .RIGHT            
c2d2 05				db 4 + 1 
c2d3 .. 00			db "LEFT",0              
c2d8				endm 
# End of macro CWHEAD
c2d8			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c2d8					if DEBUG_FORTH_WORDS_KEY 
c2d8						DMARK "LEF" 
c2d8 f5				push af  
c2d9 3a ed c2			ld a, (.dmark)  
c2dc 32 6b ee			ld (debug_mark),a  
c2df 3a ee c2			ld a, (.dmark+1)  
c2e2 32 6c ee			ld (debug_mark+1),a  
c2e5 3a ef c2			ld a, (.dmark+2)  
c2e8 32 6d ee			ld (debug_mark+2),a  
c2eb 18 03			jr .pastdmark  
c2ed ..			.dmark: db "LEF"  
c2f0 f1			.pastdmark: pop af  
c2f1			endm  
# End of macro DMARK
c2f1						CALLMONITOR 
c2f1 cd 6f ee			call debug_vector  
c2f4				endm  
# End of macro CALLMONITOR
c2f4					endif 
c2f4			 
c2f4					NEXTW 
c2f4 c3 29 9e			jp macro_next 
c2f7				endm 
# End of macro NEXTW
c2f7			.RIGHT: 
c2f7				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c2f7 48				db WORD_SYS_CORE+52             
c2f8 20 c3			dw .STR2NUM            
c2fa 06				db 5 + 1 
c2fb .. 00			db "RIGHT",0              
c301				endm 
# End of macro CWHEAD
c301			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c301					if DEBUG_FORTH_WORDS_KEY 
c301						DMARK "RIG" 
c301 f5				push af  
c302 3a 16 c3			ld a, (.dmark)  
c305 32 6b ee			ld (debug_mark),a  
c308 3a 17 c3			ld a, (.dmark+1)  
c30b 32 6c ee			ld (debug_mark+1),a  
c30e 3a 18 c3			ld a, (.dmark+2)  
c311 32 6d ee			ld (debug_mark+2),a  
c314 18 03			jr .pastdmark  
c316 ..			.dmark: db "RIG"  
c319 f1			.pastdmark: pop af  
c31a			endm  
# End of macro DMARK
c31a						CALLMONITOR 
c31a cd 6f ee			call debug_vector  
c31d				endm  
# End of macro CALLMONITOR
c31d					endif 
c31d			 
c31d					NEXTW 
c31d c3 29 9e			jp macro_next 
c320				endm 
# End of macro NEXTW
c320			 
c320			 
c320			.STR2NUM: 
c320				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c320 48				db WORD_SYS_CORE+52             
c321 ac c3			dw .NUM2STR            
c323 08				db 7 + 1 
c324 .. 00			db "STR2NUM",0              
c32c				endm 
# End of macro CWHEAD
c32c			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c32c			 
c32c			 
c32c			; TODO STR type check to do 
c32c					if DEBUG_FORTH_WORDS_KEY 
c32c						DMARK "S2N" 
c32c f5				push af  
c32d 3a 41 c3			ld a, (.dmark)  
c330 32 6b ee			ld (debug_mark),a  
c333 3a 42 c3			ld a, (.dmark+1)  
c336 32 6c ee			ld (debug_mark+1),a  
c339 3a 43 c3			ld a, (.dmark+2)  
c33c 32 6d ee			ld (debug_mark+2),a  
c33f 18 03			jr .pastdmark  
c341 ..			.dmark: db "S2N"  
c344 f1			.pastdmark: pop af  
c345			endm  
# End of macro DMARK
c345						CALLMONITOR 
c345 cd 6f ee			call debug_vector  
c348				endm  
# End of macro CALLMONITOR
c348					endif 
c348			 
c348					;FORTH_DSP 
c348					FORTH_DSP_VALUE 
c348 cd 5c 9c			call macro_forth_dsp_value 
c34b				endm 
# End of macro FORTH_DSP_VALUE
c34b					;inc hl 
c34b			 
c34b eb					ex de, hl 
c34c					if DEBUG_FORTH_WORDS 
c34c						DMARK "S2a" 
c34c f5				push af  
c34d 3a 61 c3			ld a, (.dmark)  
c350 32 6b ee			ld (debug_mark),a  
c353 3a 62 c3			ld a, (.dmark+1)  
c356 32 6c ee			ld (debug_mark+1),a  
c359 3a 63 c3			ld a, (.dmark+2)  
c35c 32 6d ee			ld (debug_mark+2),a  
c35f 18 03			jr .pastdmark  
c361 ..			.dmark: db "S2a"  
c364 f1			.pastdmark: pop af  
c365			endm  
# End of macro DMARK
c365						CALLMONITOR 
c365 cd 6f ee			call debug_vector  
c368				endm  
# End of macro CALLMONITOR
c368					endif 
c368 cd e4 8f				call string_to_uint16 
c36b			 
c36b					if DEBUG_FORTH_WORDS 
c36b						DMARK "S2b" 
c36b f5				push af  
c36c 3a 80 c3			ld a, (.dmark)  
c36f 32 6b ee			ld (debug_mark),a  
c372 3a 81 c3			ld a, (.dmark+1)  
c375 32 6c ee			ld (debug_mark+1),a  
c378 3a 82 c3			ld a, (.dmark+2)  
c37b 32 6d ee			ld (debug_mark+2),a  
c37e 18 03			jr .pastdmark  
c380 ..			.dmark: db "S2b"  
c383 f1			.pastdmark: pop af  
c384			endm  
# End of macro DMARK
c384						CALLMONITOR 
c384 cd 6f ee			call debug_vector  
c387				endm  
# End of macro CALLMONITOR
c387					endif 
c387			;		push hl 
c387					FORTH_DSP_POP 
c387 cd 2b 9d			call macro_forth_dsp_pop 
c38a				endm 
# End of macro FORTH_DSP_POP
c38a			;		pop hl 
c38a					 
c38a					if DEBUG_FORTH_WORDS 
c38a						DMARK "S2b" 
c38a f5				push af  
c38b 3a 9f c3			ld a, (.dmark)  
c38e 32 6b ee			ld (debug_mark),a  
c391 3a a0 c3			ld a, (.dmark+1)  
c394 32 6c ee			ld (debug_mark+1),a  
c397 3a a1 c3			ld a, (.dmark+2)  
c39a 32 6d ee			ld (debug_mark+2),a  
c39d 18 03			jr .pastdmark  
c39f ..			.dmark: db "S2b"  
c3a2 f1			.pastdmark: pop af  
c3a3			endm  
# End of macro DMARK
c3a3						CALLMONITOR 
c3a3 cd 6f ee			call debug_vector  
c3a6				endm  
# End of macro CALLMONITOR
c3a6					endif 
c3a6 cd 6e 9a				call forth_push_numhl	 
c3a9			 
c3a9				 
c3a9				       NEXTW 
c3a9 c3 29 9e			jp macro_next 
c3ac				endm 
# End of macro NEXTW
c3ac			.NUM2STR: 
c3ac				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c3ac 48				db WORD_SYS_CORE+52             
c3ad bb c3			dw .CONCAT            
c3af 08				db 7 + 1 
c3b0 .. 00			db "NUM2STR",0              
c3b8				endm 
# End of macro CWHEAD
c3b8			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
c3b8			 
c3b8			;		; malloc a string to target 
c3b8			;		ld hl, 10     ; TODO max string size should be fine 
c3b8			;		call malloc 
c3b8			;		push hl    ; save malloc location 
c3b8			; 
c3b8			; 
c3b8			;; TODO check int type 
c3b8			;		FORTH_DSP_VALUEHL 
c3b8			;		ld a, l 
c3b8			;		call DispAToASCII   
c3b8			;;TODO need to chage above call to dump into string 
c3b8			; 
c3b8			; 
c3b8			 
c3b8				       NEXTW 
c3b8 c3 29 9e			jp macro_next 
c3bb				endm 
# End of macro NEXTW
c3bb			 
c3bb			.CONCAT: 
c3bb				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c3bb 48				db WORD_SYS_CORE+52             
c3bc 6e c4			dw .FIND            
c3be 07				db 6 + 1 
c3bf .. 00			db "CONCAT",0              
c3c6				endm 
# End of macro CWHEAD
c3c6			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c3c6			 
c3c6			; TODO check string type 
c3c6			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c3c6			 
c3c6					if DEBUG_FORTH_WORDS_KEY 
c3c6						DMARK "CON" 
c3c6 f5				push af  
c3c7 3a db c3			ld a, (.dmark)  
c3ca 32 6b ee			ld (debug_mark),a  
c3cd 3a dc c3			ld a, (.dmark+1)  
c3d0 32 6c ee			ld (debug_mark+1),a  
c3d3 3a dd c3			ld a, (.dmark+2)  
c3d6 32 6d ee			ld (debug_mark+2),a  
c3d9 18 03			jr .pastdmark  
c3db ..			.dmark: db "CON"  
c3de f1			.pastdmark: pop af  
c3df			endm  
# End of macro DMARK
c3df						CALLMONITOR 
c3df cd 6f ee			call debug_vector  
c3e2				endm  
# End of macro CALLMONITOR
c3e2					endif 
c3e2			 
c3e2			 
c3e2					FORTH_DSP_VALUE 
c3e2 cd 5c 9c			call macro_forth_dsp_value 
c3e5				endm 
# End of macro FORTH_DSP_VALUE
c3e5 e5					push hl   ; s2 
c3e6			 
c3e6					FORTH_DSP_POP 
c3e6 cd 2b 9d			call macro_forth_dsp_pop 
c3e9				endm 
# End of macro FORTH_DSP_POP
c3e9			 
c3e9					FORTH_DSP_VALUE 
c3e9 cd 5c 9c			call macro_forth_dsp_value 
c3ec				endm 
# End of macro FORTH_DSP_VALUE
c3ec			 
c3ec e5					push hl   ; s1 
c3ed			 
c3ed					FORTH_DSP_POP 
c3ed cd 2b 9d			call macro_forth_dsp_pop 
c3f0				endm 
# End of macro FORTH_DSP_POP
c3f0					 
c3f0			 
c3f0					; copy s1 
c3f0			 
c3f0				 
c3f0					; save ptr 
c3f0 e1					pop hl  
c3f1 e5					push hl 
c3f2 3e 00				ld a, 0 
c3f4 cd 58 90				call strlent 
c3f7					;inc hl    ; zer0 
c3f7 06 00				ld b, 0 
c3f9 4d					ld c, l 
c3fa e1					pop hl		 
c3fb 11 c1 e2				ld de, scratch	 
c3fe					if DEBUG_FORTH_WORDS 
c3fe						DMARK "CO1" 
c3fe f5				push af  
c3ff 3a 13 c4			ld a, (.dmark)  
c402 32 6b ee			ld (debug_mark),a  
c405 3a 14 c4			ld a, (.dmark+1)  
c408 32 6c ee			ld (debug_mark+1),a  
c40b 3a 15 c4			ld a, (.dmark+2)  
c40e 32 6d ee			ld (debug_mark+2),a  
c411 18 03			jr .pastdmark  
c413 ..			.dmark: db "CO1"  
c416 f1			.pastdmark: pop af  
c417			endm  
# End of macro DMARK
c417						CALLMONITOR 
c417 cd 6f ee			call debug_vector  
c41a				endm  
# End of macro CALLMONITOR
c41a					endif 
c41a ed b0				ldir 
c41c			 
c41c e1					pop hl 
c41d e5					push hl 
c41e d5					push de 
c41f			 
c41f			 
c41f 3e 00				ld a, 0 
c421 cd 58 90				call strlent 
c424 23					inc hl    ; zer0 
c425 23					inc hl 
c426 06 00				ld b, 0 
c428 4d					ld c, l 
c429 d1					pop de 
c42a e1					pop hl		 
c42b					if DEBUG_FORTH_WORDS 
c42b						DMARK "CO2" 
c42b f5				push af  
c42c 3a 40 c4			ld a, (.dmark)  
c42f 32 6b ee			ld (debug_mark),a  
c432 3a 41 c4			ld a, (.dmark+1)  
c435 32 6c ee			ld (debug_mark+1),a  
c438 3a 42 c4			ld a, (.dmark+2)  
c43b 32 6d ee			ld (debug_mark+2),a  
c43e 18 03			jr .pastdmark  
c440 ..			.dmark: db "CO2"  
c443 f1			.pastdmark: pop af  
c444			endm  
# End of macro DMARK
c444						CALLMONITOR 
c444 cd 6f ee			call debug_vector  
c447				endm  
# End of macro CALLMONITOR
c447					endif 
c447 ed b0				ldir 
c449			 
c449			 
c449			 
c449 21 c1 e2				ld hl, scratch 
c44c					if DEBUG_FORTH_WORDS 
c44c						DMARK "CO5" 
c44c f5				push af  
c44d 3a 61 c4			ld a, (.dmark)  
c450 32 6b ee			ld (debug_mark),a  
c453 3a 62 c4			ld a, (.dmark+1)  
c456 32 6c ee			ld (debug_mark+1),a  
c459 3a 63 c4			ld a, (.dmark+2)  
c45c 32 6d ee			ld (debug_mark+2),a  
c45f 18 03			jr .pastdmark  
c461 ..			.dmark: db "CO5"  
c464 f1			.pastdmark: pop af  
c465			endm  
# End of macro DMARK
c465						CALLMONITOR 
c465 cd 6f ee			call debug_vector  
c468				endm  
# End of macro CALLMONITOR
c468					endif 
c468			 
c468 cd dc 9a				call forth_push_str 
c46b			 
c46b			 
c46b			 
c46b			 
c46b				       NEXTW 
c46b c3 29 9e			jp macro_next 
c46e				endm 
# End of macro NEXTW
c46e			 
c46e			 
c46e			.FIND: 
c46e				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c46e 4b				db WORD_SYS_CORE+55             
c46f 2c c5			dw .LEN            
c471 05				db 4 + 1 
c472 .. 00			db "FIND",0              
c477				endm 
# End of macro CWHEAD
c477			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c477			 
c477					if DEBUG_FORTH_WORDS_KEY 
c477						DMARK "FND" 
c477 f5				push af  
c478 3a 8c c4			ld a, (.dmark)  
c47b 32 6b ee			ld (debug_mark),a  
c47e 3a 8d c4			ld a, (.dmark+1)  
c481 32 6c ee			ld (debug_mark+1),a  
c484 3a 8e c4			ld a, (.dmark+2)  
c487 32 6d ee			ld (debug_mark+2),a  
c48a 18 03			jr .pastdmark  
c48c ..			.dmark: db "FND"  
c48f f1			.pastdmark: pop af  
c490			endm  
# End of macro DMARK
c490						CALLMONITOR 
c490 cd 6f ee			call debug_vector  
c493				endm  
# End of macro CALLMONITOR
c493					endif 
c493			 
c493			; TODO check string type 
c493					FORTH_DSP_VALUE 
c493 cd 5c 9c			call macro_forth_dsp_value 
c496				endm 
# End of macro FORTH_DSP_VALUE
c496			 
c496 e5					push hl    
c497 7e					ld a,(hl)    ; char to find   
c498			; TODO change char to substr 
c498			 
c498 f5					push af 
c499					 
c499			 
c499			 
c499					if DEBUG_FORTH_WORDS 
c499						DMARK "FN1" 
c499 f5				push af  
c49a 3a ae c4			ld a, (.dmark)  
c49d 32 6b ee			ld (debug_mark),a  
c4a0 3a af c4			ld a, (.dmark+1)  
c4a3 32 6c ee			ld (debug_mark+1),a  
c4a6 3a b0 c4			ld a, (.dmark+2)  
c4a9 32 6d ee			ld (debug_mark+2),a  
c4ac 18 03			jr .pastdmark  
c4ae ..			.dmark: db "FN1"  
c4b1 f1			.pastdmark: pop af  
c4b2			endm  
# End of macro DMARK
c4b2						CALLMONITOR 
c4b2 cd 6f ee			call debug_vector  
c4b5				endm  
# End of macro CALLMONITOR
c4b5					endif 
c4b5			 
c4b5					FORTH_DSP_POP 
c4b5 cd 2b 9d			call macro_forth_dsp_pop 
c4b8				endm 
# End of macro FORTH_DSP_POP
c4b8			 
c4b8					; string to search 
c4b8			 
c4b8					FORTH_DSP_VALUE 
c4b8 cd 5c 9c			call macro_forth_dsp_value 
c4bb				endm 
# End of macro FORTH_DSP_VALUE
c4bb			 
c4bb d1					pop de  ; d is char to find  
c4bc			 
c4bc					if DEBUG_FORTH_WORDS 
c4bc						DMARK "FN2" 
c4bc f5				push af  
c4bd 3a d1 c4			ld a, (.dmark)  
c4c0 32 6b ee			ld (debug_mark),a  
c4c3 3a d2 c4			ld a, (.dmark+1)  
c4c6 32 6c ee			ld (debug_mark+1),a  
c4c9 3a d3 c4			ld a, (.dmark+2)  
c4cc 32 6d ee			ld (debug_mark+2),a  
c4cf 18 03			jr .pastdmark  
c4d1 ..			.dmark: db "FN2"  
c4d4 f1			.pastdmark: pop af  
c4d5			endm  
# End of macro DMARK
c4d5						CALLMONITOR 
c4d5 cd 6f ee			call debug_vector  
c4d8				endm  
# End of macro CALLMONITOR
c4d8					endif 
c4d8					 
c4d8 01 00 00				ld bc, 0 
c4db 7e			.findchar:      ld a,(hl) 
c4dc fe 00				cp 0   		 
c4de 28 27				jr z, .finddone     
c4e0 ba					cp d 
c4e1 28 20				jr z, .foundchar 
c4e3 03					inc bc 
c4e4 23					inc hl 
c4e5					if DEBUG_FORTH_WORDS 
c4e5						DMARK "FN3" 
c4e5 f5				push af  
c4e6 3a fa c4			ld a, (.dmark)  
c4e9 32 6b ee			ld (debug_mark),a  
c4ec 3a fb c4			ld a, (.dmark+1)  
c4ef 32 6c ee			ld (debug_mark+1),a  
c4f2 3a fc c4			ld a, (.dmark+2)  
c4f5 32 6d ee			ld (debug_mark+2),a  
c4f8 18 03			jr .pastdmark  
c4fa ..			.dmark: db "FN3"  
c4fd f1			.pastdmark: pop af  
c4fe			endm  
# End of macro DMARK
c4fe						CALLMONITOR 
c4fe cd 6f ee			call debug_vector  
c501				endm  
# End of macro CALLMONITOR
c501					endif 
c501 18 d8				jr .findchar 
c503			 
c503			 
c503 c5			.foundchar:	push bc 
c504 e1					pop hl 
c505 18 03				jr .findexit 
c507			 
c507			 
c507							 
c507			 
c507			.finddone:     ; got to end of string with no find 
c507 21 00 00				ld hl, 0 
c50a			.findexit: 
c50a			 
c50a					if DEBUG_FORTH_WORDS 
c50a						DMARK "FNd" 
c50a f5				push af  
c50b 3a 1f c5			ld a, (.dmark)  
c50e 32 6b ee			ld (debug_mark),a  
c511 3a 20 c5			ld a, (.dmark+1)  
c514 32 6c ee			ld (debug_mark+1),a  
c517 3a 21 c5			ld a, (.dmark+2)  
c51a 32 6d ee			ld (debug_mark+2),a  
c51d 18 03			jr .pastdmark  
c51f ..			.dmark: db "FNd"  
c522 f1			.pastdmark: pop af  
c523			endm  
# End of macro DMARK
c523						CALLMONITOR 
c523 cd 6f ee			call debug_vector  
c526				endm  
# End of macro CALLMONITOR
c526					endif 
c526 cd 6e 9a			call forth_push_numhl 
c529			 
c529				       NEXTW 
c529 c3 29 9e			jp macro_next 
c52c				endm 
# End of macro NEXTW
c52c			 
c52c			.LEN: 
c52c				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
c52c 4c				db WORD_SYS_CORE+56             
c52d 96 c5			dw .ASC            
c52f 06				db 5 + 1 
c530 .. 00			db "COUNT",0              
c536				endm 
# End of macro CWHEAD
c536			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c536			 
c536					if DEBUG_FORTH_WORDS_KEY 
c536						DMARK "CNT" 
c536 f5				push af  
c537 3a 4b c5			ld a, (.dmark)  
c53a 32 6b ee			ld (debug_mark),a  
c53d 3a 4c c5			ld a, (.dmark+1)  
c540 32 6c ee			ld (debug_mark+1),a  
c543 3a 4d c5			ld a, (.dmark+2)  
c546 32 6d ee			ld (debug_mark+2),a  
c549 18 03			jr .pastdmark  
c54b ..			.dmark: db "CNT"  
c54e f1			.pastdmark: pop af  
c54f			endm  
# End of macro DMARK
c54f						CALLMONITOR 
c54f cd 6f ee			call debug_vector  
c552				endm  
# End of macro CALLMONITOR
c552					endif 
c552			; TODO check string type 
c552					FORTH_DSP_VALUE 
c552 cd 5c 9c			call macro_forth_dsp_value 
c555				endm 
# End of macro FORTH_DSP_VALUE
c555			 
c555			 
c555					if DEBUG_FORTH_WORDS 
c555						DMARK "CN?" 
c555 f5				push af  
c556 3a 6a c5			ld a, (.dmark)  
c559 32 6b ee			ld (debug_mark),a  
c55c 3a 6b c5			ld a, (.dmark+1)  
c55f 32 6c ee			ld (debug_mark+1),a  
c562 3a 6c c5			ld a, (.dmark+2)  
c565 32 6d ee			ld (debug_mark+2),a  
c568 18 03			jr .pastdmark  
c56a ..			.dmark: db "CN?"  
c56d f1			.pastdmark: pop af  
c56e			endm  
# End of macro DMARK
c56e						CALLMONITOR 
c56e cd 6f ee			call debug_vector  
c571				endm  
# End of macro CALLMONITOR
c571					endif 
c571 cd 4d 90				call strlenz 
c574					if DEBUG_FORTH_WORDS 
c574						DMARK "CNl" 
c574 f5				push af  
c575 3a 89 c5			ld a, (.dmark)  
c578 32 6b ee			ld (debug_mark),a  
c57b 3a 8a c5			ld a, (.dmark+1)  
c57e 32 6c ee			ld (debug_mark+1),a  
c581 3a 8b c5			ld a, (.dmark+2)  
c584 32 6d ee			ld (debug_mark+2),a  
c587 18 03			jr .pastdmark  
c589 ..			.dmark: db "CNl"  
c58c f1			.pastdmark: pop af  
c58d			endm  
# End of macro DMARK
c58d						CALLMONITOR 
c58d cd 6f ee			call debug_vector  
c590				endm  
# End of macro CALLMONITOR
c590					endif 
c590			 
c590 cd 6e 9a				call forth_push_numhl 
c593			 
c593			 
c593			 
c593				       NEXTW 
c593 c3 29 9e			jp macro_next 
c596				endm 
# End of macro NEXTW
c596			.ASC: 
c596				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
c596 4d				db WORD_SYS_CORE+57             
c597 04 c6			dw .CHR            
c599 04				db 3 + 1 
c59a .. 00			db "ASC",0              
c59e				endm 
# End of macro CWHEAD
c59e			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
c59e					if DEBUG_FORTH_WORDS_KEY 
c59e						DMARK "ASC" 
c59e f5				push af  
c59f 3a b3 c5			ld a, (.dmark)  
c5a2 32 6b ee			ld (debug_mark),a  
c5a5 3a b4 c5			ld a, (.dmark+1)  
c5a8 32 6c ee			ld (debug_mark+1),a  
c5ab 3a b5 c5			ld a, (.dmark+2)  
c5ae 32 6d ee			ld (debug_mark+2),a  
c5b1 18 03			jr .pastdmark  
c5b3 ..			.dmark: db "ASC"  
c5b6 f1			.pastdmark: pop af  
c5b7			endm  
# End of macro DMARK
c5b7						CALLMONITOR 
c5b7 cd 6f ee			call debug_vector  
c5ba				endm  
# End of macro CALLMONITOR
c5ba					endif 
c5ba					FORTH_DSP_VALUE 
c5ba cd 5c 9c			call macro_forth_dsp_value 
c5bd				endm 
# End of macro FORTH_DSP_VALUE
c5bd					;v5 FORTH_DSP_VALUE 
c5bd			;		inc hl      ; now at start of numeric as string 
c5bd			 
c5bd e5					push hl 
c5be			 
c5be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c5be cd 2b 9d			call macro_forth_dsp_pop 
c5c1				endm 
# End of macro FORTH_DSP_POP
c5c1			 
c5c1 e1					pop hl 
c5c2			 
c5c2					if DEBUG_FORTH_WORDS 
c5c2						DMARK "AS1" 
c5c2 f5				push af  
c5c3 3a d7 c5			ld a, (.dmark)  
c5c6 32 6b ee			ld (debug_mark),a  
c5c9 3a d8 c5			ld a, (.dmark+1)  
c5cc 32 6c ee			ld (debug_mark+1),a  
c5cf 3a d9 c5			ld a, (.dmark+2)  
c5d2 32 6d ee			ld (debug_mark+2),a  
c5d5 18 03			jr .pastdmark  
c5d7 ..			.dmark: db "AS1"  
c5da f1			.pastdmark: pop af  
c5db			endm  
# End of macro DMARK
c5db						CALLMONITOR 
c5db cd 6f ee			call debug_vector  
c5de				endm  
# End of macro CALLMONITOR
c5de					endif 
c5de					; push the content of a onto the stack as a value 
c5de			 
c5de 7e					ld a,(hl)   ; get char 
c5df 26 00				ld h,0 
c5e1 6f					ld l,a 
c5e2					if DEBUG_FORTH_WORDS 
c5e2						DMARK "AS2" 
c5e2 f5				push af  
c5e3 3a f7 c5			ld a, (.dmark)  
c5e6 32 6b ee			ld (debug_mark),a  
c5e9 3a f8 c5			ld a, (.dmark+1)  
c5ec 32 6c ee			ld (debug_mark+1),a  
c5ef 3a f9 c5			ld a, (.dmark+2)  
c5f2 32 6d ee			ld (debug_mark+2),a  
c5f5 18 03			jr .pastdmark  
c5f7 ..			.dmark: db "AS2"  
c5fa f1			.pastdmark: pop af  
c5fb			endm  
# End of macro DMARK
c5fb						CALLMONITOR 
c5fb cd 6f ee			call debug_vector  
c5fe				endm  
# End of macro CALLMONITOR
c5fe					endif 
c5fe cd 6e 9a				call forth_push_numhl 
c601			 
c601				       NEXTW 
c601 c3 29 9e			jp macro_next 
c604				endm 
# End of macro NEXTW
c604			 
c604			.CHR: 
c604				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
c604 4d				db WORD_SYS_CORE+57             
c605 40 c6			dw .ENDSTR            
c607 04				db 3 + 1 
c608 .. 00			db "CHR",0              
c60c				endm 
# End of macro CWHEAD
c60c			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
c60c					if DEBUG_FORTH_WORDS_KEY 
c60c						DMARK "CHR" 
c60c f5				push af  
c60d 3a 21 c6			ld a, (.dmark)  
c610 32 6b ee			ld (debug_mark),a  
c613 3a 22 c6			ld a, (.dmark+1)  
c616 32 6c ee			ld (debug_mark+1),a  
c619 3a 23 c6			ld a, (.dmark+2)  
c61c 32 6d ee			ld (debug_mark+2),a  
c61f 18 03			jr .pastdmark  
c621 ..			.dmark: db "CHR"  
c624 f1			.pastdmark: pop af  
c625			endm  
# End of macro DMARK
c625						CALLMONITOR 
c625 cd 6f ee			call debug_vector  
c628				endm  
# End of macro CALLMONITOR
c628					endif 
c628					FORTH_DSP_VALUEHL 
c628 cd 73 9c			call macro_dsp_valuehl 
c62b				endm 
# End of macro FORTH_DSP_VALUEHL
c62b			 
c62b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c62b cd 2b 9d			call macro_forth_dsp_pop 
c62e				endm 
# End of macro FORTH_DSP_POP
c62e			 
c62e					; save asci byte as a zero term string and push string 
c62e			 
c62e 7d					ld a,l 
c62f 32 c1 e2				ld (scratch), a 
c632			 
c632 3e 00				ld a, 0 
c634 32 c2 e2				ld (scratch+1), a 
c637			 
c637 21 c1 e2				ld hl, scratch 
c63a cd dc 9a				call forth_push_str 
c63d			 
c63d			 
c63d				       NEXTW 
c63d c3 29 9e			jp macro_next 
c640				endm 
# End of macro NEXTW
c640			 
c640			 
c640			 
c640			 
c640			.ENDSTR: 
c640			; eof 
c640			 
# End of file forth_words_str.asm
c640			include "forth_words_key.asm" 
c640			 
c640			; | ## Keyboard Words 
c640			 
c640			.KEY: 
c640				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c640 3e				db WORD_SYS_CORE+42             
c641 70 c6			dw .WAITK            
c643 04				db 3 + 1 
c644 .. 00			db "KEY",0              
c648				endm 
# End of macro CWHEAD
c648			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
c648			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
c648			; | | Can use something like this to process: 
c648			; | | > repeat active . key ?dup if emit then #1 until  
c648			 
c648					if DEBUG_FORTH_WORDS_KEY 
c648						DMARK "KEY" 
c648 f5				push af  
c649 3a 5d c6			ld a, (.dmark)  
c64c 32 6b ee			ld (debug_mark),a  
c64f 3a 5e c6			ld a, (.dmark+1)  
c652 32 6c ee			ld (debug_mark+1),a  
c655 3a 5f c6			ld a, (.dmark+2)  
c658 32 6d ee			ld (debug_mark+2),a  
c65b 18 03			jr .pastdmark  
c65d ..			.dmark: db "KEY"  
c660 f1			.pastdmark: pop af  
c661			endm  
# End of macro DMARK
c661						CALLMONITOR 
c661 cd 6f ee			call debug_vector  
c664				endm  
# End of macro CALLMONITOR
c664					endif 
c664			; TODO currently waits 
c664 cd 17 dd				call cin 
c667					;call cin_wait 
c667 6f					ld l, a 
c668 26 00				ld h, 0 
c66a cd 6e 9a				call forth_push_numhl 
c66d					NEXTW 
c66d c3 29 9e			jp macro_next 
c670				endm 
# End of macro NEXTW
c670			.WAITK: 
c670				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c670 3f				db WORD_SYS_CORE+43             
c671 a2 c6			dw .ACCEPT            
c673 06				db 5 + 1 
c674 .. 00			db "WAITK",0              
c67a				endm 
# End of macro CWHEAD
c67a			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c67a					if DEBUG_FORTH_WORDS_KEY 
c67a						DMARK "WAI" 
c67a f5				push af  
c67b 3a 8f c6			ld a, (.dmark)  
c67e 32 6b ee			ld (debug_mark),a  
c681 3a 90 c6			ld a, (.dmark+1)  
c684 32 6c ee			ld (debug_mark+1),a  
c687 3a 91 c6			ld a, (.dmark+2)  
c68a 32 6d ee			ld (debug_mark+2),a  
c68d 18 03			jr .pastdmark  
c68f ..			.dmark: db "WAI"  
c692 f1			.pastdmark: pop af  
c693			endm  
# End of macro DMARK
c693						CALLMONITOR 
c693 cd 6f ee			call debug_vector  
c696				endm  
# End of macro CALLMONITOR
c696					endif 
c696 cd 11 dd				call cin_wait 
c699 6f					ld l, a 
c69a 26 00				ld h, 0 
c69c cd 6e 9a				call forth_push_numhl 
c69f					NEXTW 
c69f c3 29 9e			jp macro_next 
c6a2				endm 
# End of macro NEXTW
c6a2			.ACCEPT: 
c6a2				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c6a2 40				db WORD_SYS_CORE+44             
c6a3 00 c7			dw .EDIT            
c6a5 07				db 6 + 1 
c6a6 .. 00			db "ACCEPT",0              
c6ad				endm 
# End of macro CWHEAD
c6ad			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c6ad					; TODO crashes on push 
c6ad					if DEBUG_FORTH_WORDS_KEY 
c6ad						DMARK "ACC" 
c6ad f5				push af  
c6ae 3a c2 c6			ld a, (.dmark)  
c6b1 32 6b ee			ld (debug_mark),a  
c6b4 3a c3 c6			ld a, (.dmark+1)  
c6b7 32 6c ee			ld (debug_mark+1),a  
c6ba 3a c4 c6			ld a, (.dmark+2)  
c6bd 32 6d ee			ld (debug_mark+2),a  
c6c0 18 03			jr .pastdmark  
c6c2 ..			.dmark: db "ACC"  
c6c5 f1			.pastdmark: pop af  
c6c6			endm  
# End of macro DMARK
c6c6						CALLMONITOR 
c6c6 cd 6f ee			call debug_vector  
c6c9				endm  
# End of macro CALLMONITOR
c6c9					endif 
c6c9 21 bf e4				ld hl, os_input 
c6cc 3e 00				ld a, 0 
c6ce 77					ld (hl),a 
c6cf 3a 5e ea				ld a,(f_cursor_ptr) 
c6d2 16 64				ld d, 100 
c6d4 0e 00				ld c, 0 
c6d6 1e 28				ld e, 40 
c6d8 cd 14 8d				call input_str 
c6db					; TODO perhaps do a type check and wrap in quotes if not a number 
c6db 21 bf e4				ld hl, os_input 
c6de					if DEBUG_FORTH_WORDS 
c6de						DMARK "AC1" 
c6de f5				push af  
c6df 3a f3 c6			ld a, (.dmark)  
c6e2 32 6b ee			ld (debug_mark),a  
c6e5 3a f4 c6			ld a, (.dmark+1)  
c6e8 32 6c ee			ld (debug_mark+1),a  
c6eb 3a f5 c6			ld a, (.dmark+2)  
c6ee 32 6d ee			ld (debug_mark+2),a  
c6f1 18 03			jr .pastdmark  
c6f3 ..			.dmark: db "AC1"  
c6f6 f1			.pastdmark: pop af  
c6f7			endm  
# End of macro DMARK
c6f7						CALLMONITOR 
c6f7 cd 6f ee			call debug_vector  
c6fa				endm  
# End of macro CALLMONITOR
c6fa					endif 
c6fa cd dc 9a				call forth_push_str 
c6fd					NEXTW 
c6fd c3 29 9e			jp macro_next 
c700				endm 
# End of macro NEXTW
c700			 
c700			.EDIT: 
c700				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
c700 40				db WORD_SYS_CORE+44             
c701 a2 c7			dw .DEDIT            
c703 05				db 4 + 1 
c704 .. 00			db "EDIT",0              
c709				endm 
# End of macro CWHEAD
c709			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c709			 
c709					; TODO does not copy from stack 
c709					if DEBUG_FORTH_WORDS_KEY 
c709						DMARK "EDT" 
c709 f5				push af  
c70a 3a 1e c7			ld a, (.dmark)  
c70d 32 6b ee			ld (debug_mark),a  
c710 3a 1f c7			ld a, (.dmark+1)  
c713 32 6c ee			ld (debug_mark+1),a  
c716 3a 20 c7			ld a, (.dmark+2)  
c719 32 6d ee			ld (debug_mark+2),a  
c71c 18 03			jr .pastdmark  
c71e ..			.dmark: db "EDT"  
c721 f1			.pastdmark: pop af  
c722			endm  
# End of macro DMARK
c722						CALLMONITOR 
c722 cd 6f ee			call debug_vector  
c725				endm  
# End of macro CALLMONITOR
c725					endif 
c725			 
c725					;FORTH_DSP 
c725					FORTH_DSP_VALUEHL 
c725 cd 73 9c			call macro_dsp_valuehl 
c728				endm 
# End of macro FORTH_DSP_VALUEHL
c728			;		inc hl    ; TODO do type check 
c728			 
c728			;		call get_word_hl 
c728 e5					push hl 
c729					if DEBUG_FORTH_WORDS 
c729						DMARK "EDp" 
c729 f5				push af  
c72a 3a 3e c7			ld a, (.dmark)  
c72d 32 6b ee			ld (debug_mark),a  
c730 3a 3f c7			ld a, (.dmark+1)  
c733 32 6c ee			ld (debug_mark+1),a  
c736 3a 40 c7			ld a, (.dmark+2)  
c739 32 6d ee			ld (debug_mark+2),a  
c73c 18 03			jr .pastdmark  
c73e ..			.dmark: db "EDp"  
c741 f1			.pastdmark: pop af  
c742			endm  
# End of macro DMARK
c742						CALLMONITOR 
c742 cd 6f ee			call debug_vector  
c745				endm  
# End of macro CALLMONITOR
c745					endif 
c745				;	ld a, 0 
c745 cd 4d 90				call strlenz 
c748 23					inc hl 
c749			 
c749 06 00				ld b, 0 
c74b 4d					ld c, l 
c74c			 
c74c e1					pop hl 
c74d 11 bf e4				ld de, os_input 
c750					if DEBUG_FORTH_WORDS_KEY 
c750						DMARK "EDc" 
c750 f5				push af  
c751 3a 65 c7			ld a, (.dmark)  
c754 32 6b ee			ld (debug_mark),a  
c757 3a 66 c7			ld a, (.dmark+1)  
c75a 32 6c ee			ld (debug_mark+1),a  
c75d 3a 67 c7			ld a, (.dmark+2)  
c760 32 6d ee			ld (debug_mark+2),a  
c763 18 03			jr .pastdmark  
c765 ..			.dmark: db "EDc"  
c768 f1			.pastdmark: pop af  
c769			endm  
# End of macro DMARK
c769						CALLMONITOR 
c769 cd 6f ee			call debug_vector  
c76c				endm  
# End of macro CALLMONITOR
c76c					endif 
c76c ed b0				ldir 
c76e			 
c76e			 
c76e 21 bf e4				ld hl, os_input 
c771					;ld a, 0 
c771					;ld (hl),a 
c771 3a 5e ea				ld a,(f_cursor_ptr) 
c774 16 64				ld d, 100 
c776 0e 00				ld c, 0 
c778 1e 28				ld e, 40 
c77a cd 14 8d				call input_str 
c77d					; TODO perhaps do a type check and wrap in quotes if not a number 
c77d 21 bf e4				ld hl, os_input 
c780					if DEBUG_FORTH_WORDS 
c780						DMARK "ED1" 
c780 f5				push af  
c781 3a 95 c7			ld a, (.dmark)  
c784 32 6b ee			ld (debug_mark),a  
c787 3a 96 c7			ld a, (.dmark+1)  
c78a 32 6c ee			ld (debug_mark+1),a  
c78d 3a 97 c7			ld a, (.dmark+2)  
c790 32 6d ee			ld (debug_mark+2),a  
c793 18 03			jr .pastdmark  
c795 ..			.dmark: db "ED1"  
c798 f1			.pastdmark: pop af  
c799			endm  
# End of macro DMARK
c799						CALLMONITOR 
c799 cd 6f ee			call debug_vector  
c79c				endm  
# End of macro CALLMONITOR
c79c					endif 
c79c cd dc 9a				call forth_push_str 
c79f					NEXTW 
c79f c3 29 9e			jp macro_next 
c7a2				endm 
# End of macro NEXTW
c7a2			 
c7a2			.DEDIT: 
c7a2				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
c7a2 40				db WORD_SYS_CORE+44             
c7a3 04 c8			dw .ENDKEY            
c7a5 06				db 5 + 1 
c7a6 .. 00			db "DEDIT",0              
c7ac				endm 
# End of macro CWHEAD
c7ac			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
c7ac			 
c7ac					; TODO does not copy from stack 
c7ac					if DEBUG_FORTH_WORDS_KEY 
c7ac						DMARK "DED" 
c7ac f5				push af  
c7ad 3a c1 c7			ld a, (.dmark)  
c7b0 32 6b ee			ld (debug_mark),a  
c7b3 3a c2 c7			ld a, (.dmark+1)  
c7b6 32 6c ee			ld (debug_mark+1),a  
c7b9 3a c3 c7			ld a, (.dmark+2)  
c7bc 32 6d ee			ld (debug_mark+2),a  
c7bf 18 03			jr .pastdmark  
c7c1 ..			.dmark: db "DED"  
c7c4 f1			.pastdmark: pop af  
c7c5			endm  
# End of macro DMARK
c7c5						CALLMONITOR 
c7c5 cd 6f ee			call debug_vector  
c7c8				endm  
# End of macro CALLMONITOR
c7c8					endif 
c7c8			 
c7c8					;FORTH_DSP 
c7c8					FORTH_DSP_VALUEHL 
c7c8 cd 73 9c			call macro_dsp_valuehl 
c7cb				endm 
# End of macro FORTH_DSP_VALUEHL
c7cb			;		inc hl    ; TODO do type check 
c7cb			 
c7cb			;		call get_word_hl 
c7cb e5					push hl 
c7cc e5					push hl 
c7cd					FORTH_DSP_POP 
c7cd cd 2b 9d			call macro_forth_dsp_pop 
c7d0				endm 
# End of macro FORTH_DSP_POP
c7d0 e1					pop hl 
c7d1					if DEBUG_FORTH_WORDS 
c7d1						DMARK "EDp" 
c7d1 f5				push af  
c7d2 3a e6 c7			ld a, (.dmark)  
c7d5 32 6b ee			ld (debug_mark),a  
c7d8 3a e7 c7			ld a, (.dmark+1)  
c7db 32 6c ee			ld (debug_mark+1),a  
c7de 3a e8 c7			ld a, (.dmark+2)  
c7e1 32 6d ee			ld (debug_mark+2),a  
c7e4 18 03			jr .pastdmark  
c7e6 ..			.dmark: db "EDp"  
c7e9 f1			.pastdmark: pop af  
c7ea			endm  
# End of macro DMARK
c7ea						CALLMONITOR 
c7ea cd 6f ee			call debug_vector  
c7ed				endm  
# End of macro CALLMONITOR
c7ed					endif 
c7ed				;	ld a, 0 
c7ed cd 4d 90				call strlenz 
c7f0 23					inc hl 
c7f1			 
c7f1 06 00				ld b, 0 
c7f3 4d					ld c, l 
c7f4			 
c7f4 e1					pop hl 
c7f5			 
c7f5					;ld a, 0 
c7f5					;ld (hl),a 
c7f5 3a 5e ea				ld a,(f_cursor_ptr) 
c7f8 16 64				ld d, 100 
c7fa 0e 00				ld c, 0 
c7fc 1e 28				ld e, 40 
c7fe cd 14 8d				call input_str 
c801					; TODO perhaps do a type check and wrap in quotes if not a number 
c801					NEXTW 
c801 c3 29 9e			jp macro_next 
c804				endm 
# End of macro NEXTW
c804			 
c804			 
c804			.ENDKEY: 
c804			; eof 
c804			 
# End of file forth_words_key.asm
c804			include "forth_words_const.asm" 
c804			 
c804			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
c804			 
c804			 
c804			.SPITIME: 
c804				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
c804 77				db WORD_SYS_CORE+99             
c805 19 c8			dw .VA            
c807 08				db 7 + 1 
c808 .. 00			db "SPITIME",0              
c810				endm 
# End of macro CWHEAD
c810			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
c810			; 
c810			; | | If using BANK devices then leave as is. 
c810			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
c810			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
c810			 
c810 21 64 ea				ld hl, spi_clktime  
c813 cd 6e 9a				call forth_push_numhl 
c816			 
c816					NEXTW 
c816 c3 29 9e			jp macro_next 
c819				endm 
# End of macro NEXTW
c819			 
c819			 
c819			.VA: 
c819				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
c819 77				db WORD_SYS_CORE+99             
c81a 29 c8			dw .SYMBOL            
c81c 03				db 2 + 1 
c81d .. 00			db "VA",0              
c820				endm 
# End of macro CWHEAD
c820			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
c820 21 28 ea				ld hl, cli_var_array 
c823 cd 6e 9a				call forth_push_numhl 
c826			 
c826					NEXTW 
c826 c3 29 9e			jp macro_next 
c829				endm 
# End of macro NEXTW
c829			 
c829			.SYMBOL: 
c829				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
c829 77				db WORD_SYS_CORE+99             
c82a 33 c9			dw .ENDCONST            
c82c 07				db 6 + 1 
c82d .. 00			db "SYMBOL",0              
c834				endm 
# End of macro CWHEAD
c834			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
c834			; | 
c834			; | | The value is the number reference and the final address is pushed to stack 
c834			 
c834			; | | ``` 
c834			; | | dw sym_table 
c834			; | | dw nmi_vector 
c834			; | | dw cli_autodisplay 
c834			; | | dw cli_data_sp 
c834			; | | dw cli_data_stack 
c834			; | | dw cli_loop_sp 
c834			; | | dw cli_loop_stack 
c834			; | | dw cli_var_array 
c834			; | | dw cursor_col 
c834			; | | dw cursor_ptr 
c834			; | | ; 10 
c834			; | | dw cursor_row 
c834			; | | dw debug_mark 
c834			; | | dw display_fb0 
c834			; | | dw display_fb1 
c834			; | | dw display_fb2 
c834			; | | dw display_fb3 
c834			; | | dw display_fb_active 
c834			; | | dw execscratch 
c834			; | | dw f_cursor_ptr 
c834			; | | dw hardware_word 
c834			; | | ;20 
c834			; | | dw input_at_cursor 
c834			; | | dw input_at_pos 
c834			; | | dw input_cur_flash 
c834			; | | dw input_cur_onoff 
c834			; | | dw input_cursor 
c834			; | | dw input_display_size 
c834			; | | dw input_len 
c834			; | | dw input_ptr 
c834			; | | dw input_size 
c834			; | | dw input_start 
c834			; | | ; 30 
c834			; | | dw input_str 
c834			; | | dw input_under_cursor 
c834			; | | dw os_cli_cmd 
c834			; | | dw os_cur_ptr 
c834			; | | dw os_current_i 
c834			; | | dw os_input 
c834			; | | dw os_last_cmd 
c834			; | | dw os_last_new_uword 
c834			; | | dw debug_vector 
c834			; | | dw os_view_hl 
c834			; | | ;40 
c834			; | | dw os_word_scratch 
c834			; | | dw portbctl 
c834			; | | dw portbdata 
c834			; | | dw spi_cartdev 
c834			; | | dw spi_cartdev2 
c834			; | | dw spi_clktime 
c834			; | | dw spi_device 
c834			; | | dw spi_device_id 
c834			; | | dw spi_portbyte 
c834			; | | dw stackstore 
c834			; | | ; 50 
c834			; | | if STORAGE_SE 
c834			; | | dw storage_actl 
c834			; | | dw storage_adata 
c834			; | | else 
c834			; | | dw 0 
c834			; | | dw 0 
c834			; | | endif 
c834			; | | dw storage_append 
c834			; | | if STORAGE_SE 
c834			; | | dw storage_bctl 
c834			; | | else 
c834			; | | dw 0 
c834			; | | endif 
c834			; | | dw store_bank_active 
c834			; | | dw store_filecache 
c834			; | | dw store_longread 
c834			; | | dw store_openaddr 
c834			; | | dw store_openext 
c834			; | | dw store_openmaxext 
c834			; | | ; 60 
c834			; | | dw store_page 
c834			; | | dw store_readbuf 
c834			; | | dw store_readcont 
c834			; | | dw store_readptr 
c834			; | | dw store_tmpext 
c834			; | | dw store_tmpid 
c834			; | | dw store_tmppageid 
c834			; | | dw malloc 
c834			; | | dw free 
c834			; | | dw cin 
c834			; | | ; 70 
c834			; | | dw cin_wait 
c834			; | | dw forth_push_numhl 
c834			; | | dw forth_push_str 
c834			; | | ``` 
c834			 
c834					if DEBUG_FORTH_WORDS_KEY 
c834						DMARK "SYM" 
c834 f5				push af  
c835 3a 49 c8			ld a, (.dmark)  
c838 32 6b ee			ld (debug_mark),a  
c83b 3a 4a c8			ld a, (.dmark+1)  
c83e 32 6c ee			ld (debug_mark+1),a  
c841 3a 4b c8			ld a, (.dmark+2)  
c844 32 6d ee			ld (debug_mark+2),a  
c847 18 03			jr .pastdmark  
c849 ..			.dmark: db "SYM"  
c84c f1			.pastdmark: pop af  
c84d			endm  
# End of macro DMARK
c84d						CALLMONITOR 
c84d cd 6f ee			call debug_vector  
c850				endm  
# End of macro CALLMONITOR
c850					endif 
c850			 
c850					FORTH_DSP_VALUEHL 
c850 cd 73 9c			call macro_dsp_valuehl 
c853				endm 
# End of macro FORTH_DSP_VALUEHL
c853			 
c853 7d					ld a, l     
c854			 
c854			 
c854					if DEBUG_FORTH_WORDS 
c854						DMARK "SY1" 
c854 f5				push af  
c855 3a 69 c8			ld a, (.dmark)  
c858 32 6b ee			ld (debug_mark),a  
c85b 3a 6a c8			ld a, (.dmark+1)  
c85e 32 6c ee			ld (debug_mark+1),a  
c861 3a 6b c8			ld a, (.dmark+2)  
c864 32 6d ee			ld (debug_mark+2),a  
c867 18 03			jr .pastdmark  
c869 ..			.dmark: db "SY1"  
c86c f1			.pastdmark: pop af  
c86d			endm  
# End of macro DMARK
c86d						CALLMONITOR 
c86d cd 6f ee			call debug_vector  
c870				endm  
# End of macro CALLMONITOR
c870					endif 
c870					 
c870 f5					push af	 
c871					FORTH_DSP_POP 
c871 cd 2b 9d			call macro_forth_dsp_pop 
c874				endm 
# End of macro FORTH_DSP_POP
c874 f1					pop af 
c875			 
c875 cb 27				sla a  
c877				 
c877					 
c877					if DEBUG_FORTH_WORDS 
c877						DMARK "SY" 
c877 f5				push af  
c878 3a 8c c8			ld a, (.dmark)  
c87b 32 6b ee			ld (debug_mark),a  
c87e 3a 8d c8			ld a, (.dmark+1)  
c881 32 6c ee			ld (debug_mark+1),a  
c884 3a 8e c8			ld a, (.dmark+2)  
c887 32 6d ee			ld (debug_mark+2),a  
c88a 18 02			jr .pastdmark  
c88c ..			.dmark: db "SY"  
c88e f1			.pastdmark: pop af  
c88f			endm  
# End of macro DMARK
c88f						CALLMONITOR 
c88f cd 6f ee			call debug_vector  
c892				endm  
# End of macro CALLMONITOR
c892					endif 
c892			 
c892 21 a1 c8				ld hl, sym_table 
c895 cd e7 8c				call addatohl 
c898 cd ab 9d				call loadwordinhl 
c89b cd 6e 9a				call forth_push_numhl 
c89e			 
c89e			 
c89e				       NEXTW 
c89e c3 29 9e			jp macro_next 
c8a1				endm 
# End of macro NEXTW
c8a1			 
c8a1			sym_table: 
c8a1			 
c8a1			; 0 
c8a1 a1 c8		dw sym_table 
c8a3 72 ee		dw nmi_vector 
c8a5 3c ea		dw cli_autodisplay 
c8a7 ee e9		dw cli_data_sp 
c8a9 28 e8		dw cli_data_stack 
c8ab f0 e9		dw cli_loop_sp 
c8ad 2a e9		dw cli_loop_stack 
c8af 28 ea		dw cli_var_array 
c8b1 c5 eb		dw cursor_col 
c8b3 c3 eb		dw cursor_ptr 
c8b5			; 10 
c8b5 c4 eb		dw cursor_row 
c8b7 6b ee		dw debug_mark 
c8b9 b1 ed		dw display_fb0 
c8bb 10 ed		dw display_fb1 
c8bd ce eb		dw display_fb2 
c8bf 6f ec		dw display_fb3 
c8c1 cc eb		dw display_fb_active 
c8c3 c0 e3		dw execscratch 
c8c5 5e ea		dw f_cursor_ptr 
c8c7 75 ee		dw hardware_word 
c8c9			;20 
c8c9 62 ee		dw input_at_cursor 
c8cb 64 ee		dw input_at_pos 
c8cd 60 ee		dw input_cur_flash 
c8cf 5f ee		dw input_cur_onoff 
c8d1 55 ee		dw input_cursor 
c8d3 65 ee		dw input_display_size 
c8d5 5a ee		dw input_len 
c8d7 69 ee		dw input_ptr 
c8d9 66 ee		dw input_size 
c8db 67 ee		dw input_start 
c8dd			; 30 
c8dd 14 8d		dw input_str 
c8df 63 ee		dw input_under_cursor 
c8e1 e8 e5		dw os_cli_cmd 
c8e3 e4 e5		dw os_cur_ptr 
c8e5 e6 e5		dw os_current_i 
c8e7 bf e4		dw os_input 
c8e9 e7 e6		dw os_last_cmd 
c8eb be e5		dw os_last_new_uword 
c8ed 6f ee		dw debug_vector 
c8ef a3 e2		dw os_view_hl 
c8f1			;40 
c8f1 c6 e5		dw os_word_scratch 
c8f3 c3 00		dw portbctl 
c8f5 c1 00		dw portbdata 
c8f7 63 ea		dw spi_cartdev 
c8f9 62 ea		dw spi_cartdev2 
c8fb 64 ea		dw spi_clktime 
c8fd 60 ea		dw spi_device 
c8ff 5f ea		dw spi_device_id 
c901 61 ea		dw spi_portbyte 
c903 a7 eb		dw stackstore 
c905			; 50 
c905			if STORAGE_SE 
c905			dw storage_actl 
c905			dw storage_adata 
c905			else 
c905 00 00		dw 0 
c907 00 00		dw 0 
c909			endif 
c909 74 88		dw storage_append 
c90b			if STORAGE_SE 
c90b			dw storage_bctl 
c90b			else 
c90b 00 00		dw 0 
c90d			endif 
c90d 93 eb		dw store_bank_active 
c90f 67 ea		dw store_filecache 
c911 75 ea		dw store_longread 
c913 6b ea		dw store_openaddr 
c915 6a ea		dw store_openext 
c917 69 ea		dw store_openmaxext 
c919			; 60 
c919 7a ea		dw store_page 
c91b 76 ea		dw store_readbuf 
c91d 6d ea		dw store_readcont 
c91f 78 ea		dw store_readptr 
c921 6d ea		dw store_tmpext 
c923 6e ea		dw store_tmpid 
c925 65 ea		dw store_tmppageid 
c927 c2 90		dw malloc 
c929 8c 91		dw free 
c92b 17 dd		dw cin 
c92d			; 70 
c92d 11 dd		dw cin_wait 
c92f 6e 9a		dw forth_push_numhl 
c931 dc 9a		dw forth_push_str 
c933			 
c933			 
c933			.ENDCONST: 
c933			 
c933			; eof 
c933			 
c933			 
# End of file forth_words_const.asm
c933			 
c933			if STORAGE_SE 
c933			   	include "forth_words_storage.asm" 
c933			endif 
c933				include "forth_words_device.asm" 
c933			; Device related words 
c933			 
c933			; | ## Device Words 
c933			 
c933			;if SOUND_ENABLE 
c933			;.NOTE: 
c933			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c933			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
c933			;		if DEBUG_FORTH_WORDS_KEY 
c933			;			DMARK "NTE" 
c933			;			CALLMONITOR 
c933			;		endif 
c933			; 
c933			;	 
c933			; 
c933			;		NEXTW 
c933			;.AFTERSOUND: 
c933			;endif 
c933			 
c933			 
c933			USE_GPIO: equ 0 
c933			 
c933			if USE_GPIO 
c933			.GP1: 
c933				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c933			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
c933					NEXTW 
c933			.GP2: 
c933				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c933			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
c933			 
c933					NEXTW 
c933			 
c933			.GP3: 
c933				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c933			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
c933			 
c933					NEXTW 
c933			 
c933			.GP4: 
c933				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c933			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
c933			 
c933					NEXTW 
c933			.SIN: 
c933			 
c933			 
c933			endif 
c933			 
c933			 
c933				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c933 33				db WORD_SYS_CORE+31             
c934 68 c9			dw .SOUT            
c936 03				db 2 + 1 
c937 .. 00			db "IN",0              
c93a				endm 
# End of macro CWHEAD
c93a			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c93a					if DEBUG_FORTH_WORDS_KEY 
c93a						DMARK "IN." 
c93a f5				push af  
c93b 3a 4f c9			ld a, (.dmark)  
c93e 32 6b ee			ld (debug_mark),a  
c941 3a 50 c9			ld a, (.dmark+1)  
c944 32 6c ee			ld (debug_mark+1),a  
c947 3a 51 c9			ld a, (.dmark+2)  
c94a 32 6d ee			ld (debug_mark+2),a  
c94d 18 03			jr .pastdmark  
c94f ..			.dmark: db "IN."  
c952 f1			.pastdmark: pop af  
c953			endm  
# End of macro DMARK
c953						CALLMONITOR 
c953 cd 6f ee			call debug_vector  
c956				endm  
# End of macro CALLMONITOR
c956					endif 
c956					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c956 cd 73 9c			call macro_dsp_valuehl 
c959				endm 
# End of macro FORTH_DSP_VALUEHL
c959			 
c959 e5					push hl 
c95a			 
c95a					; destroy value TOS 
c95a			 
c95a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c95a cd 2b 9d			call macro_forth_dsp_pop 
c95d				endm 
# End of macro FORTH_DSP_POP
c95d			 
c95d					; one value on hl get other one back 
c95d			 
c95d c1					pop bc 
c95e			 
c95e					; do the sub 
c95e			;		ex de, hl 
c95e			 
c95e ed 68				in l,(c) 
c960			 
c960					; save it 
c960			 
c960 26 00				ld h,0 
c962			 
c962					; TODO push value back onto stack for another op etc 
c962			 
c962 cd 6e 9a				call forth_push_numhl 
c965					NEXTW 
c965 c3 29 9e			jp macro_next 
c968				endm 
# End of macro NEXTW
c968			.SOUT: 
c968				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c968 34				db WORD_SYS_CORE+32             
c969 bb c9			dw .SPIO            
c96b 04				db 3 + 1 
c96c .. 00			db "OUT",0              
c970				endm 
# End of macro CWHEAD
c970			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c970					if DEBUG_FORTH_WORDS_KEY 
c970						DMARK "OUT" 
c970 f5				push af  
c971 3a 85 c9			ld a, (.dmark)  
c974 32 6b ee			ld (debug_mark),a  
c977 3a 86 c9			ld a, (.dmark+1)  
c97a 32 6c ee			ld (debug_mark+1),a  
c97d 3a 87 c9			ld a, (.dmark+2)  
c980 32 6d ee			ld (debug_mark+2),a  
c983 18 03			jr .pastdmark  
c985 ..			.dmark: db "OUT"  
c988 f1			.pastdmark: pop af  
c989			endm  
# End of macro DMARK
c989						CALLMONITOR 
c989 cd 6f ee			call debug_vector  
c98c				endm  
# End of macro CALLMONITOR
c98c					endif 
c98c			 
c98c					; get port 
c98c			 
c98c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c98c cd 73 9c			call macro_dsp_valuehl 
c98f				endm 
# End of macro FORTH_DSP_VALUEHL
c98f			 
c98f e5					push hl 
c990			 
c990					; destroy value TOS 
c990			 
c990					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c990 cd 2b 9d			call macro_forth_dsp_pop 
c993				endm 
# End of macro FORTH_DSP_POP
c993			 
c993					; get byte to send 
c993			 
c993					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c993 cd 73 9c			call macro_dsp_valuehl 
c996				endm 
# End of macro FORTH_DSP_VALUEHL
c996			 
c996			;		push hl 
c996			 
c996					; destroy value TOS 
c996			 
c996					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c996 cd 2b 9d			call macro_forth_dsp_pop 
c999				endm 
# End of macro FORTH_DSP_POP
c999			 
c999					; one value on hl get other one back 
c999			 
c999			;		pop hl 
c999			 
c999 c1					pop bc 
c99a			 
c99a					if DEBUG_FORTH_WORDS 
c99a						DMARK "OUT" 
c99a f5				push af  
c99b 3a af c9			ld a, (.dmark)  
c99e 32 6b ee			ld (debug_mark),a  
c9a1 3a b0 c9			ld a, (.dmark+1)  
c9a4 32 6c ee			ld (debug_mark+1),a  
c9a7 3a b1 c9			ld a, (.dmark+2)  
c9aa 32 6d ee			ld (debug_mark+2),a  
c9ad 18 03			jr .pastdmark  
c9af ..			.dmark: db "OUT"  
c9b2 f1			.pastdmark: pop af  
c9b3			endm  
# End of macro DMARK
c9b3						CALLMONITOR 
c9b3 cd 6f ee			call debug_vector  
c9b6				endm  
# End of macro CALLMONITOR
c9b6					endif 
c9b6			 
c9b6 ed 69				out (c), l 
c9b8			 
c9b8					NEXTW 
c9b8 c3 29 9e			jp macro_next 
c9bb				endm 
# End of macro NEXTW
c9bb			 
c9bb			 
c9bb			.SPIO: 
c9bb			 
c9bb			if STORAGE_SE 
c9bb				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c9bb			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c9bb			 
c9bb					call spi_ce_low 
c9bb			    NEXTW 
c9bb			 
c9bb			.SPICEH: 
c9bb				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c9bb			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c9bb			 
c9bb					call spi_ce_high 
c9bb			    NEXTW 
c9bb			 
c9bb			 
c9bb			.SPIOb: 
c9bb			 
c9bb				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c9bb			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c9bb			 
c9bb					if DEBUG_FORTH_WORDS_KEY 
c9bb						DMARK "SPo" 
c9bb						CALLMONITOR 
c9bb					endif 
c9bb					; get port 
c9bb			 
c9bb			 
c9bb					; get byte to send 
c9bb			 
c9bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9bb			 
c9bb			;		push hl    ; u1  
c9bb			 
c9bb					; destroy value TOS 
c9bb			 
c9bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9bb			 
c9bb					; one value on hl get other one back 
c9bb			 
c9bb			;		pop hl   ; u2 - addr 
c9bb			 
c9bb					; TODO Send SPI byte 
c9bb			 
c9bb			;		push hl 
c9bb			;		call spi_ce_low 
c9bb			;		pop hl 
c9bb					ld a, l 
c9bb					call spi_send_byte 
c9bb			;		call spi_ce_high 
c9bb			 
c9bb					NEXTW 
c9bb			 
c9bb			.SPII: 
c9bb				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c9bb			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c9bb					if DEBUG_FORTH_WORDS_KEY 
c9bb						DMARK "SPi" 
c9bb						CALLMONITOR 
c9bb					endif 
c9bb			 
c9bb					; TODO Get SPI byte 
c9bb			 
c9bb					call spi_read_byte 
c9bb			 
c9bb					if DEBUG_FORTH_WORDS 
c9bb						DMARK "Si2" 
c9bb						CALLMONITOR 
c9bb					endif 
c9bb					ld h, 0 
c9bb					ld l, a 
c9bb					if DEBUG_FORTH_WORDS 
c9bb						DMARK "Si3" 
c9bb						CALLMONITOR 
c9bb					endif 
c9bb					call forth_push_numhl 
c9bb			 
c9bb					NEXTW 
c9bb			 
c9bb			 
c9bb			 
c9bb			.SESEL: 
c9bb				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c9bb			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c9bb					if DEBUG_FORTH_WORDS_KEY 
c9bb						DMARK "BNK" 
c9bb						CALLMONITOR 
c9bb					endif 
c9bb			 
c9bb					ld a, 255 
c9bb					ld (spi_cartdev), a 
c9bb			 
c9bb					; get bank 
c9bb			 
c9bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9bb			 
c9bb			;		push hl 
c9bb			 
c9bb					; destroy value TOS 
c9bb			 
c9bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9bb			 
c9bb					; one value on hl get other one back 
c9bb			 
c9bb			;		pop hl 
c9bb			 
c9bb			 
c9bb					ld c, SPI_CE_HIGH 
c9bb					ld b, '0'    ; human readable bank number 
c9bb			 
c9bb					ld a, l 
c9bb			 
c9bb					if DEBUG_FORTH_WORDS 
c9bb						DMARK "BNK" 
c9bb						CALLMONITOR 
c9bb					endif 
c9bb			 
c9bb					; active low 
c9bb			 
c9bb					cp 0 
c9bb					jr z, .bset 
c9bb					cp 1 
c9bb					jr nz, .b2 
c9bb					res 0, c 
c9bb					ld b, '1'    ; human readable bank number 
c9bb			.b2:		cp 2 
c9bb					jr nz, .b3 
c9bb					res 1, c 
c9bb					ld b, '2'    ; human readable bank number 
c9bb			.b3:		cp 3 
c9bb					jr nz, .b4 
c9bb					res 2, c 
c9bb					ld b, '3'    ; human readable bank number 
c9bb			.b4:		cp 4 
c9bb					jr nz, .b5 
c9bb					res 3, c 
c9bb					ld b, '4'    ; human readable bank number 
c9bb			.b5:		cp 5 
c9bb					jr nz, .bset 
c9bb					res 4, c 
c9bb					ld b, '5'    ; human readable bank number 
c9bb			 
c9bb			.bset: 
c9bb					ld a, c 
c9bb					ld (spi_device),a 
c9bb					ld a, b 
c9bb					ld (spi_device_id),a 
c9bb					if DEBUG_FORTH_WORDS 
c9bb						DMARK "BN2" 
c9bb						CALLMONITOR 
c9bb					endif 
c9bb			 
c9bb					; set default SPI clk pulse time as disabled for BANK use 
c9bb			 
c9bb					ld a, 0 
c9bb					ld (spi_clktime), a 
c9bb			 
c9bb					NEXTW 
c9bb			 
c9bb			.CARTDEV: 
c9bb				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c9bb			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c9bb					if DEBUG_FORTH_WORDS_KEY 
c9bb						DMARK "CDV" 
c9bb						CALLMONITOR 
c9bb					endif 
c9bb			 
c9bb					; disable se storage bank selection 
c9bb			 
c9bb					ld a, SPI_CE_HIGH		; ce high 
c9bb					ld (spi_device), a 
c9bb			 
c9bb					; get bank 
c9bb			 
c9bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9bb			 
c9bb			;		push hl 
c9bb			 
c9bb					; destroy value TOS 
c9bb			 
c9bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9bb			 
c9bb					; one value on hl get other one back 
c9bb			 
c9bb			;		pop hl 
c9bb			 
c9bb					; active low 
c9bb			 
c9bb					ld c, 255 
c9bb			 
c9bb					ld a, l 
c9bb					if DEBUG_FORTH_WORDS 
c9bb						DMARK "CDV" 
c9bb						CALLMONITOR 
c9bb					endif 
c9bb					cp 0 
c9bb					jr z, .cset 
c9bb					cp 1 
c9bb					jr nz, .c2 
c9bb					res 0, c 
c9bb			.c2:		cp 2 
c9bb					jr nz, .c3 
c9bb					res 1, c 
c9bb			.c3:		cp 3 
c9bb					jr nz, .c4 
c9bb					res 2, c 
c9bb			.c4:		cp 4 
c9bb					jr nz, .c5 
c9bb					res 3, c 
c9bb			.c5:		cp 5 
c9bb					jr nz, .c6 
c9bb					res 4, c 
c9bb			.c6:		cp 6 
c9bb					jr nz, .c7 
c9bb					res 5, c 
c9bb			.c7:		cp 7 
c9bb					jr nz, .c8 
c9bb					res 6, c 
c9bb			.c8:		cp 8 
c9bb					jr nz, .cset 
c9bb					res 7, c 
c9bb			.cset:		ld a, c 
c9bb					ld (spi_cartdev),a 
c9bb			 
c9bb					if DEBUG_FORTH_WORDS 
c9bb						DMARK "CD2" 
c9bb						CALLMONITOR 
c9bb					endif 
c9bb			 
c9bb					; set default SPI clk pulse time as 10ms for CARTDEV use 
c9bb			 
c9bb					ld a, $0a 
c9bb					ld (spi_clktime), a 
c9bb					NEXTW 
c9bb			endif 
c9bb			 
c9bb			.ENDDEVICE: 
c9bb			; eof 
c9bb			 
# End of file forth_words_device.asm
c9bb			 
c9bb			; var handler 
c9bb			 
c9bb			 
c9bb			.VARS: 
c9bb				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
c9bb 77				db WORD_SYS_CORE+99             
c9bc 6c ca			dw .V0            
c9be 04				db 3 + 1 
c9bf .. 00			db "VAR",0              
c9c3				endm 
# End of macro CWHEAD
c9c3			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
c9c3			;| 
c9c3			;| The variable name should consist of a single letter. e.g. "a" 
c9c3			;! If a full string is passed then only the first char is looked at 
c9c3			;| Any other char could exceed bounds checks!  
c9c3			 
c9c3					if DEBUG_FORTH_WORDS_KEY 
c9c3						DMARK "VAR" 
c9c3 f5				push af  
c9c4 3a d8 c9			ld a, (.dmark)  
c9c7 32 6b ee			ld (debug_mark),a  
c9ca 3a d9 c9			ld a, (.dmark+1)  
c9cd 32 6c ee			ld (debug_mark+1),a  
c9d0 3a da c9			ld a, (.dmark+2)  
c9d3 32 6d ee			ld (debug_mark+2),a  
c9d6 18 03			jr .pastdmark  
c9d8 ..			.dmark: db "VAR"  
c9db f1			.pastdmark: pop af  
c9dc			endm  
# End of macro DMARK
c9dc						CALLMONITOR 
c9dc cd 6f ee			call debug_vector  
c9df				endm  
# End of macro CALLMONITOR
c9df					endif 
c9df			 
c9df					FORTH_DSP_VALUEHL 
c9df cd 73 9c			call macro_dsp_valuehl 
c9e2				endm 
# End of macro FORTH_DSP_VALUEHL
c9e2			 
c9e2 7e					ld a, (hl)    ; get first char on of the string 
c9e3			 
c9e3			 
c9e3					if DEBUG_FORTH_WORDS 
c9e3						DMARK "VR1" 
c9e3 f5				push af  
c9e4 3a f8 c9			ld a, (.dmark)  
c9e7 32 6b ee			ld (debug_mark),a  
c9ea 3a f9 c9			ld a, (.dmark+1)  
c9ed 32 6c ee			ld (debug_mark+1),a  
c9f0 3a fa c9			ld a, (.dmark+2)  
c9f3 32 6d ee			ld (debug_mark+2),a  
c9f6 18 03			jr .pastdmark  
c9f8 ..			.dmark: db "VR1"  
c9fb f1			.pastdmark: pop af  
c9fc			endm  
# End of macro DMARK
c9fc						CALLMONITOR 
c9fc cd 6f ee			call debug_vector  
c9ff				endm  
# End of macro CALLMONITOR
c9ff					endif 
c9ff					 
c9ff f5					push af	 
ca00					FORTH_DSP_POP 
ca00 cd 2b 9d			call macro_forth_dsp_pop 
ca03				endm 
# End of macro FORTH_DSP_POP
ca03 f1					pop af 
ca04			 
ca04					; convert to upper 
ca04			 
ca04 cd 5c 8f				call to_upper 
ca07					if DEBUG_FORTH_WORDS 
ca07						DMARK "Vaa" 
ca07 f5				push af  
ca08 3a 1c ca			ld a, (.dmark)  
ca0b 32 6b ee			ld (debug_mark),a  
ca0e 3a 1d ca			ld a, (.dmark+1)  
ca11 32 6c ee			ld (debug_mark+1),a  
ca14 3a 1e ca			ld a, (.dmark+2)  
ca17 32 6d ee			ld (debug_mark+2),a  
ca1a 18 03			jr .pastdmark  
ca1c ..			.dmark: db "Vaa"  
ca1f f1			.pastdmark: pop af  
ca20			endm  
# End of macro DMARK
ca20						CALLMONITOR 
ca20 cd 6f ee			call debug_vector  
ca23				endm  
# End of macro CALLMONITOR
ca23					endif 
ca23 06 41				ld b, 'A' 
ca25 90					sub b			; set offset 
ca26					if DEBUG_FORTH_WORDS 
ca26						DMARK "Vbb" 
ca26 f5				push af  
ca27 3a 3b ca			ld a, (.dmark)  
ca2a 32 6b ee			ld (debug_mark),a  
ca2d 3a 3c ca			ld a, (.dmark+1)  
ca30 32 6c ee			ld (debug_mark+1),a  
ca33 3a 3d ca			ld a, (.dmark+2)  
ca36 32 6d ee			ld (debug_mark+2),a  
ca39 18 03			jr .pastdmark  
ca3b ..			.dmark: db "Vbb"  
ca3e f1			.pastdmark: pop af  
ca3f			endm  
# End of macro DMARK
ca3f						CALLMONITOR 
ca3f cd 6f ee			call debug_vector  
ca42				endm  
# End of macro CALLMONITOR
ca42					endif 
ca42 cb 27				sla a  
ca44				 
ca44					 
ca44					if DEBUG_FORTH_WORDS 
ca44						DMARK "VR2" 
ca44 f5				push af  
ca45 3a 59 ca			ld a, (.dmark)  
ca48 32 6b ee			ld (debug_mark),a  
ca4b 3a 5a ca			ld a, (.dmark+1)  
ca4e 32 6c ee			ld (debug_mark+1),a  
ca51 3a 5b ca			ld a, (.dmark+2)  
ca54 32 6d ee			ld (debug_mark+2),a  
ca57 18 03			jr .pastdmark  
ca59 ..			.dmark: db "VR2"  
ca5c f1			.pastdmark: pop af  
ca5d			endm  
# End of macro DMARK
ca5d						CALLMONITOR 
ca5d cd 6f ee			call debug_vector  
ca60				endm  
# End of macro CALLMONITOR
ca60					endif 
ca60			 
ca60 21 f4 e9				ld hl, cli_var_array2 
ca63 cd e7 8c				call addatohl 
ca66 cd 6e 9a				call forth_push_numhl 
ca69			 
ca69			 
ca69				       NEXTW 
ca69 c3 29 9e			jp macro_next 
ca6c				endm 
# End of macro NEXTW
ca6c			.V0: 
ca6c				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
ca6c 78				db WORD_SYS_CORE+100             
ca6d 84 ca			dw .V0Q            
ca6f 04				db 3 + 1 
ca70 .. 00			db "V0!",0              
ca74				endm 
# End of macro CWHEAD
ca74			;| V0! ( u1 -- )  Store value to v0  | DONE 
ca74			 
ca74					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca74 cd 73 9c			call macro_dsp_valuehl 
ca77				endm 
# End of macro FORTH_DSP_VALUEHL
ca77			 
ca77 11 28 ea				ld de, cli_var_array 
ca7a			 
ca7a eb					ex de, hl 
ca7b 73					ld (hl), e 
ca7c 23					inc hl 
ca7d 72					ld (hl), d 
ca7e			 
ca7e					; destroy value TOS 
ca7e			 
ca7e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca7e cd 2b 9d			call macro_forth_dsp_pop 
ca81				endm 
# End of macro FORTH_DSP_POP
ca81			 
ca81				       NEXTW 
ca81 c3 29 9e			jp macro_next 
ca84				endm 
# End of macro NEXTW
ca84			.V0Q: 
ca84				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
ca84 79				db WORD_SYS_CORE+101             
ca85 95 ca			dw .V1S            
ca87 04				db 3 + 1 
ca88 .. 00			db "V0@",0              
ca8c				endm 
# End of macro CWHEAD
ca8c			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
ca8c 2a 28 ea				ld hl, (cli_var_array) 
ca8f cd 6e 9a				call forth_push_numhl 
ca92			 
ca92				       NEXTW 
ca92 c3 29 9e			jp macro_next 
ca95				endm 
# End of macro NEXTW
ca95			.V1S: 
ca95				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
ca95 7a				db WORD_SYS_CORE+102             
ca96 ad ca			dw .V1Q            
ca98 04				db 3 + 1 
ca99 .. 00			db "V1!",0              
ca9d				endm 
# End of macro CWHEAD
ca9d			;| V1! ( u1 -- )  Store value to v1 | DONE 
ca9d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca9d cd 73 9c			call macro_dsp_valuehl 
caa0				endm 
# End of macro FORTH_DSP_VALUEHL
caa0			 
caa0 11 2a ea				ld de, cli_var_array+2 
caa3				 
caa3 eb					ex de, hl 
caa4 73					ld (hl), e 
caa5 23					inc hl 
caa6 72					ld (hl), d 
caa7			 
caa7					; destroy value TOS 
caa7			 
caa7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
caa7 cd 2b 9d			call macro_forth_dsp_pop 
caaa				endm 
# End of macro FORTH_DSP_POP
caaa				       NEXTW 
caaa c3 29 9e			jp macro_next 
caad				endm 
# End of macro NEXTW
caad			.V1Q: 
caad				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
caad 7b				db WORD_SYS_CORE+103             
caae be ca			dw .V2S            
cab0 04				db 3 + 1 
cab1 .. 00			db "V1@",0              
cab5				endm 
# End of macro CWHEAD
cab5			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
cab5 2a 2a ea				ld hl, (cli_var_array+2) 
cab8 cd 6e 9a				call forth_push_numhl 
cabb				       NEXTW 
cabb c3 29 9e			jp macro_next 
cabe				endm 
# End of macro NEXTW
cabe			.V2S: 
cabe				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
cabe 7c				db WORD_SYS_CORE+104             
cabf d6 ca			dw .V2Q            
cac1 04				db 3 + 1 
cac2 .. 00			db "V2!",0              
cac6				endm 
# End of macro CWHEAD
cac6			;| V2! ( u1 -- )  Store value to v2 | DONE 
cac6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cac6 cd 73 9c			call macro_dsp_valuehl 
cac9				endm 
# End of macro FORTH_DSP_VALUEHL
cac9			 
cac9 11 2c ea				ld de, cli_var_array+4 
cacc				 
cacc eb					ex de, hl 
cacd 73					ld (hl), e 
cace 23					inc hl 
cacf 72					ld (hl), d 
cad0			 
cad0					; destroy value TOS 
cad0			 
cad0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cad0 cd 2b 9d			call macro_forth_dsp_pop 
cad3				endm 
# End of macro FORTH_DSP_POP
cad3				       NEXTW 
cad3 c3 29 9e			jp macro_next 
cad6				endm 
# End of macro NEXTW
cad6			.V2Q: 
cad6				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
cad6 7d				db WORD_SYS_CORE+105             
cad7 e7 ca			dw .V3S            
cad9 04				db 3 + 1 
cada .. 00			db "V2@",0              
cade				endm 
# End of macro CWHEAD
cade			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
cade 2a 2c ea				ld hl, (cli_var_array+4) 
cae1 cd 6e 9a				call forth_push_numhl 
cae4				       NEXTW 
cae4 c3 29 9e			jp macro_next 
cae7				endm 
# End of macro NEXTW
cae7			.V3S: 
cae7				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
cae7 7c				db WORD_SYS_CORE+104             
cae8 ff ca			dw .V3Q            
caea 04				db 3 + 1 
caeb .. 00			db "V3!",0              
caef				endm 
# End of macro CWHEAD
caef			;| V3! ( u1 -- )  Store value to v3 | DONE 
caef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
caef cd 73 9c			call macro_dsp_valuehl 
caf2				endm 
# End of macro FORTH_DSP_VALUEHL
caf2			 
caf2 11 2e ea				ld de, cli_var_array+6 
caf5				 
caf5 eb					ex de, hl 
caf6 73					ld (hl), e 
caf7 23					inc hl 
caf8 72					ld (hl), d 
caf9			 
caf9					; destroy value TOS 
caf9			 
caf9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
caf9 cd 2b 9d			call macro_forth_dsp_pop 
cafc				endm 
# End of macro FORTH_DSP_POP
cafc				       NEXTW 
cafc c3 29 9e			jp macro_next 
caff				endm 
# End of macro NEXTW
caff			.V3Q: 
caff				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
caff 7d				db WORD_SYS_CORE+105             
cb00 10 cb			dw .END            
cb02 04				db 3 + 1 
cb03 .. 00			db "V3@",0              
cb07				endm 
# End of macro CWHEAD
cb07			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
cb07 2a 2e ea				ld hl, (cli_var_array+6) 
cb0a cd 6e 9a				call forth_push_numhl 
cb0d				       NEXTW 
cb0d c3 29 9e			jp macro_next 
cb10				endm 
# End of macro NEXTW
cb10			 
cb10			 
cb10			 
cb10			 
cb10			 
cb10			; end of dict marker 
cb10			 
cb10 00			.END:    db WORD_SYS_END 
cb11 00 00			dw 0 
cb13 00				db 0 
cb14			 
cb14			; use to jp here for user dict words to save on macro expansion  
cb14			 
cb14			user_dict_next: 
cb14				NEXTW 
cb14 c3 29 9e			jp macro_next 
cb17				endm 
# End of macro NEXTW
cb17			 
cb17			 
cb17			user_exec: 
cb17				;    ld hl, <word code> 
cb17				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
cb17				;    call forthexec 
cb17				;    jp user_dict_next   (NEXT) 
cb17			        ;    <word code bytes> 
cb17 eb				ex de, hl 
cb18 2a c2 e5			ld hl,(os_tok_ptr) 
cb1b				 
cb1b				FORTH_RSP_NEXT 
cb1b cd 15 9a			call macro_forth_rsp_next 
cb1e				endm 
# End of macro FORTH_RSP_NEXT
cb1e			 
cb1e			if DEBUG_FORTH_UWORD 
cb1e						DMARK "UEX" 
cb1e f5				push af  
cb1f 3a 33 cb			ld a, (.dmark)  
cb22 32 6b ee			ld (debug_mark),a  
cb25 3a 34 cb			ld a, (.dmark+1)  
cb28 32 6c ee			ld (debug_mark+1),a  
cb2b 3a 35 cb			ld a, (.dmark+2)  
cb2e 32 6d ee			ld (debug_mark+2),a  
cb31 18 03			jr .pastdmark  
cb33 ..			.dmark: db "UEX"  
cb36 f1			.pastdmark: pop af  
cb37			endm  
# End of macro DMARK
cb37				CALLMONITOR 
cb37 cd 6f ee			call debug_vector  
cb3a				endm  
# End of macro CALLMONITOR
cb3a			endif 
cb3a			 
cb3a			 
cb3a			 
cb3a eb				ex de, hl 
cb3b 22 c2 e5			ld (os_tok_ptr), hl 
cb3e				 
cb3e				; Don't use next - Skips the first word in uword. 
cb3e			 
cb3e c3 ba 9e			jp exec1 
cb41			;	NEXT 
cb41			 
cb41			 
cb41			; eof 
# End of file forth_wordsv4.asm
cb41			endif 
cb41			;;;;;;;;;;;;;; Debug code 
cb41			 
cb41			 
cb41			;if DEBUG_FORTH_PARSE 
cb41 .. 00		.nowordfound: db "No match",0 
cb4a .. 00		.compword:	db "Comparing word ",0 
cb5a .. 00		.nextwordat:	db "Next word at",0 
cb67 .. 00		.charmatch:	db "Char match",0 
cb72			;endif 
cb72			if DEBUG_FORTH_JP 
cb72			.foundword:	db "Word match. Exec..",0 
cb72			endif 
cb72			;if DEBUG_FORTH_PUSH 
cb72 .. 00		.enddict:	db "Dict end. Push.",0 
cb82 .. 00		.push_str:	db "Pushing string",0 
cb91 .. 00		.push_num:	db "Pushing number",0 
cba0 .. 00		.data_sp:	db "SP:",0 
cba4 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
cbb6 .. 00		.wordinde:	db "Word in DE (3/0):",0 
cbc8 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
cbda			;endif 
cbda			;if DEBUG_FORTH_MALLOC 
cbda .. 00		.push_malloc:	db "Malloc address",0 
cbe9			;endif 
cbe9			 
cbe9			 
cbe9			 
cbe9			; display malloc address and current data stack pointer  
cbe9			 
cbe9			malloc_error: 
cbe9 d5				push de 
cbea f5				push af 
cbeb e5				push hl 
cbec cd ba 8a			call clear_display 
cbef 11 0f cc			ld de, .mallocerr 
cbf2 3e 00			ld a,0 
cbf4			;	ld de,os_word_scratch 
cbf4 cd cd 8a			call str_at_display 
cbf7 3e 11			ld a, display_row_1+17 
cbf9 11 6b ee			ld de, debug_mark 
cbfc cd cd 8a			call str_at_display 
cbff cd dd 8a			call update_display 
cc02				;call break_point_state 
cc02 cd 11 dd			call cin_wait 
cc05			 
cc05			;	ld a, ' ' 
cc05			;	ld (os_view_disable), a 
cc05 cd f1 93			call bp_on 
cc08 e1				pop hl 
cc09 f1				pop af 
cc0a d1				pop de	 
cc0b				CALLMONITOR 
cc0b cd 6f ee			call debug_vector  
cc0e				endm  
# End of macro CALLMONITOR
cc0e c9				ret 
cc0f			 
cc0f .. 00		.mallocerr: 	db "Malloc Error",0 
cc1c			;if DEBUG_FORTH_PUSH 
cc1c			display_data_sp: 
cc1c f5				push af 
cc1d			 
cc1d				; see if disabled 
cc1d			 
cc1d			 
cc1d 3a 6f ee			ld a, (debug_vector) 
cc20 fe c9			cp $C9  ; RET 
cc22				;ld a, (os_view_disable) 
cc22				;cp '*' 
cc22 28 67			jr z, .skipdsp 
cc24			 
cc24 e5				push hl 
cc25 e5				push hl 
cc26 e5			push hl 
cc27 cd ba 8a			call clear_display 
cc2a e1			pop hl 
cc2b 7c				ld a,h 
cc2c 21 c6 e5			ld hl, os_word_scratch 
cc2f cd f0 8e			call hexout 
cc32 e1				pop hl 
cc33 7d				ld a,l 
cc34 21 c8 e5			ld hl, os_word_scratch+2 
cc37 cd f0 8e			call hexout 
cc3a 21 ca e5			ld hl, os_word_scratch+4 
cc3d 3e 00			ld a,0 
cc3f 77				ld (hl),a 
cc40 11 c6 e5			ld de,os_word_scratch 
cc43 3e 28				ld a, display_row_2 
cc45 cd cd 8a				call str_at_display 
cc48 11 a4 cb			ld de, .wordinhl 
cc4b 3e 00			ld a, display_row_1 
cc4d			 
cc4d cd cd 8a				call str_at_display 
cc50 11 6b ee			ld de, debug_mark 
cc53 3e 11			ld a, display_row_1+17 
cc55			 
cc55 cd cd 8a				call str_at_display 
cc58			 
cc58				; display current data stack pointer 
cc58 11 a0 cb			ld de,.data_sp 
cc5b 3e 30				ld a, display_row_2 + 8 
cc5d cd cd 8a				call str_at_display 
cc60			 
cc60 2a ee e9			ld hl,(cli_data_sp) 
cc63 e5				push hl 
cc64 7c				ld a,h 
cc65 21 c6 e5			ld hl, os_word_scratch 
cc68 cd f0 8e			call hexout 
cc6b e1				pop hl 
cc6c 7d				ld a,l 
cc6d 21 c8 e5			ld hl, os_word_scratch+2 
cc70 cd f0 8e			call hexout 
cc73 21 ca e5			ld hl, os_word_scratch+4 
cc76 3e 00			ld a,0 
cc78 77				ld (hl),a 
cc79 11 c6 e5			ld de,os_word_scratch 
cc7c 3e 33				ld a, display_row_2 + 11 
cc7e cd cd 8a				call str_at_display 
cc81			 
cc81			 
cc81 cd dd 8a			call update_display 
cc84 cd fd 89			call delay1s 
cc87 cd fd 89			call delay1s 
cc8a e1				pop hl 
cc8b			.skipdsp: 
cc8b f1				pop af 
cc8c c9				ret 
cc8d			 
cc8d			display_data_malloc: 
cc8d			 
cc8d f5				push af 
cc8e e5				push hl 
cc8f e5				push hl 
cc90 e5			push hl 
cc91 cd ba 8a			call clear_display 
cc94 e1			pop hl 
cc95 7c				ld a,h 
cc96 21 c6 e5			ld hl, os_word_scratch 
cc99 cd f0 8e			call hexout 
cc9c e1				pop hl 
cc9d 7d				ld a,l 
cc9e 21 c8 e5			ld hl, os_word_scratch+2 
cca1 cd f0 8e			call hexout 
cca4 21 ca e5			ld hl, os_word_scratch+4 
cca7 3e 00			ld a,0 
cca9 77				ld (hl),a 
ccaa 11 c6 e5			ld de,os_word_scratch 
ccad 3e 28				ld a, display_row_2 
ccaf cd cd 8a				call str_at_display 
ccb2 11 da cb			ld de, .push_malloc 
ccb5 3e 00			ld a, display_row_1 
ccb7			 
ccb7 cd cd 8a				call str_at_display 
ccba			 
ccba				; display current data stack pointer 
ccba 11 a0 cb			ld de,.data_sp 
ccbd 3e 30				ld a, display_row_2 + 8 
ccbf cd cd 8a				call str_at_display 
ccc2			 
ccc2 2a ee e9			ld hl,(cli_data_sp) 
ccc5 e5				push hl 
ccc6 7c				ld a,h 
ccc7 21 c6 e5			ld hl, os_word_scratch 
ccca cd f0 8e			call hexout 
cccd e1				pop hl 
ccce 7d				ld a,l 
cccf 21 c8 e5			ld hl, os_word_scratch+2 
ccd2 cd f0 8e			call hexout 
ccd5 21 ca e5			ld hl, os_word_scratch+4 
ccd8 3e 00			ld a,0 
ccda 77				ld (hl),a 
ccdb 11 c6 e5			ld de,os_word_scratch 
ccde 3e 33				ld a, display_row_2 + 11 
cce0 cd cd 8a				call str_at_display 
cce3			 
cce3 cd dd 8a			call update_display 
cce6 cd fd 89			call delay1s 
cce9 cd fd 89			call delay1s 
ccec e1				pop hl 
cced f1				pop af 
ccee c9				ret 
ccef			;endif 
ccef			 
ccef			include "forth_autostart.asm" 
ccef			; list of commands to perform at system start up 
ccef			 
ccef			startcmds: 
ccef			;	dw test11 
ccef			;	dw test12 
ccef			;	dw test13 
ccef			;	dw test14 
ccef			;	dw test15 
ccef			;	dw test16 
ccef			;	dw test17 
ccef			;	dw ifthtest1 
ccef			;	dw ifthtest2 
ccef			;	dw ifthtest3 
ccef			;	dw mmtest1 
ccef			;	dw mmtest2 
ccef			;	dw mmtest3 
ccef			;	dw mmtest4 
ccef			;	dw mmtest5 
ccef			;	dw mmtest6 
ccef			;	dw iftest1 
ccef			;	dw iftest2 
ccef			;	dw iftest3 
ccef			;	dw looptest1 
ccef			;	dw looptest2 
ccef			;	dw test1 
ccef			;	dw test2 
ccef			;	dw test3 
ccef			;	dw test4 
ccef			;	dw game2r 
ccef			;	dw game2b1 
ccef			;	dw game2b2 
ccef			 
ccef				; start up words that are actually useful 
ccef			 
ccef			;    dw spi1 
ccef			;    dw spi2 
ccef			;    dw spi3 
ccef			;    dw spi4 
ccef			;    dw spi5 
ccef			;    dw spi6 
ccef			;    dw spi7 
ccef			; 
ccef			;    dw spi8 
ccef			;    dw spi9 
ccef			;    dw spi10 
ccef			 
ccef			; file editor 
ccef			;	dw edit1 
ccef			;	dw edit2 
ccef			;	dw edit3 
ccef			 
ccef			;	dw longread 
ccef 0f d1			dw clrstack 
ccf1 43 d1			dw type 
ccf3			;	dw stest 
ccf3 68 d1			dw strncpy 
ccf5			;	dw list 
ccf5 c9 d1			dw start1 
ccf7 d9 d1			dw start2 
ccf9			;	dw start3 
ccf9			;	dw start3b 
ccf9			;	dw start3c 
ccf9			 
ccf9				; (unit) testing words 
ccf9			 
ccf9			;	dw mtesta 
ccf9			;	dw mtestb 
ccf9			;	dw mtestc 
ccf9			;	dw mtestd 
ccf9			;	dw mteste 
ccf9			 
ccf9				; demo/game words 
ccf9			 
ccf9			;        dw game3w 
ccf9			;        dw game3p 
ccf9			;        dw game3sc 
ccf9			;        dw game3vsi 
ccf9			;        dw game3vs 
ccf9				 
ccf9			;	dw game2b 
ccf9			;	dw game2bf 
ccf9			;	dw game2mba 
ccf9			;	dw game2mbas 
ccf9			;	dw game2mb 
ccf9			 
ccf9 f6 d4			dw game1 
ccfb 07 d5			dw game1a 
ccfd 69 d5			dw game1b 
ccff 9e d5			dw game1c 
cd01 d4 d5			dw game1d 
cd03 05 d6			dw game1s 
cd05 19 d6			dw game1t 
cd07 2e d6			dw game1f 
cd09 62 d6			dw game1z 
cd0b a6 d6			dw game1zz 
cd0d			 
cd0d 2f d3			dw test5 
cd0f 67 d3			dw test6 
cd11 9f d3			dw test7 
cd13 b3 d3			dw test8 
cd15 df d3			dw test9 
cd17 f5 d3			dw test10 
cd19				 
cd19 7d d7		        dw ssv5 
cd1b 61 d7		        dw ssv4 
cd1d 45 d7		        dw ssv3 
cd1f 0f d7		        dw ssv2 
cd21 96 d7		        dw ssv1 
cd23 de d7		        dw ssv1cpm 
cd25			;	dw keyup 
cd25			;	dw keydown 
cd25			;	dw keyleft 
cd25			;	dw keyright 
cd25			;	dw 	keyf1 
cd25			;	dw keyf2 
cd25			;	dw keyf3 
cd25			;	dw keyf4 
cd25			;	dw keyf5 
cd25			;	dw keyf6 
cd25			;	dw keyf7 
cd25			;	dw keyf8 
cd25			;	dw keyf9 
cd25			;	dw keyf10 
cd25			;	dw keyf11 
cd25			;	dw keyf12 
cd25			;	dw keytab 
cd25			;	dw keycr 
cd25			;	dw keyhome 
cd25			;	dw keyend 
cd25			;	dw keybs 
cd25 00 00			db 0, 0	 
cd27			 
cd27			 
cd27			; File Editor 
cd27			 
cd27			; ( id - ) use 'e' to edit the displayed line 
cd27 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
cd48 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cd7d			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cd7d .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
cdb5			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
cdb5			 
cdb5			; SPI Net support words 
cdb5			 
cdb5			; v0! = node to send to 
cdb5			; ( str count - ) 
cdb5 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
ce0e			 
ce0e			; spiputc ( char node - ) 
ce0e .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
ce42			; spiputc ( u node - ) 
ce42 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
ce70			 
ce70			; spigetc ( - n ) 
ce70 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
ce99			 
ce99			; getnode ( - n ) 
ce99 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
cec6			 
cec6			; ( str node - )  
cec6 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
cf2c			; store string ( str i - ) 
cf2c			 
cf2c			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
cf2c .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
cf81			 
cf81			; get string ( addr i -  )    TO FIX 
cf81			 
cf81 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
cfd9			 
cfd9			 
cfd9			; NETCHAT (TODO) 
cfd9			; Program to allow two nodes to chat with eachother 
cfd9			; 
cfd9			; v0 - target node 
cfd9			;  
cfd9			; accept input at 0,0 
cfd9			; if input is string send spitype to target node 
cfd9			; starting at row 2,0 , while spigetchr is not zero ->  
cfd9			; 
cfd9			; 
cfd9			; TODO add paging of get request 
cfd9			 
cfd9			; ( node - ) 
cfd9 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
cff8 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d050 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
d0c8			 
d0c8			 
d0c8			; Long read of currently open file 
d0c8 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d10f			 
d10f			; clear stack  
d10f			 
d10f .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
d143			 
d143			; type ( addr count - ) 
d143 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
d168			 
d168			; some direct memory words 
d168			; strncpy ( len t f -- t ) 
d168			 
d168 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d1c9			 
d1c9 .. 00		start1:     	db ": bpon $00 bp ;",0 
d1d9 .. 00		start2:     	db ": bpoff $01 bp ;",0 
d1ea .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d265 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d2c5			 
d2c5			 
d2c5			; a handy word to list items on the stack 
d2c5			 
d2c5 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d32f			 
d32f			 
d32f			; test stack  
d32f			; rnd8 stest 
d32f			 
d32f			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d32f			 
d32f			; random malloc and free cycles 
d32f			 
d32f			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d32f			 
d32f			; fixed malloc and free cycles 
d32f			 
d32f			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d32f			 
d32f			; fixed double string push and drop cycle  
d32f			 
d32f			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d32f			 
d32f			; consistent fixed string push and drop cycle  
d32f			 
d32f			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d32f			 
d32f			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d32f			 
d32f			;test1:		db ": aa 1 2 3 ;", 0 
d32f			;test2:     	db "111 aa 888 999",0 
d32f			;test3:     	db ": bb 77 ;",0 
d32f			;test4:     	db "$02 $01 do i . loop bb",0 
d32f			 
d32f .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
d367 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
d39f .. 00		test7:     	db ": box hline vline ;",0 
d3b3 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
d3df .. 00		test9:     	db ": sw $01 adsp world ;",0 
d3f5 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
d41a			;test11:     	db "hello create .",0 
d41a			;test12:     	db "hello2 create .",0 
d41a			 
d41a			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
d41a			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
d41a			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
d41a			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
d41a			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
d41a			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
d41a			 
d41a			;iftest1:     	db "$0001 IF cls .",0 
d41a			;iftest2:     	db "$0000 IF cls .",0 
d41a			;iftest3:     	db "$0002 $0003 - IF cls .",0 
d41a			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
d41a			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
d41a			 
d41a			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d41a			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d41a			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d41a			 
d41a			 
d41a .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
d43e .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
d46e .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
d493 .. 00		sound4: db ": cha $00 ; ",0 
d4a0 .. 00		sound5: db ": chb $20 ; ",0 
d4ad .. 00		sound6: db ": chc $40 ; ",0 
d4ba .. 00		sound7: db ": chd $60 ; ",0 
d4c7 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
d4df .. 00		sound9: db ": cvol $90 + + note ; ", 0 
d4f6			 
d4f6			 
d4f6			 
d4f6			 
d4f6			; a small guess the number game 
d4f6			 
d4f6 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
d507 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
d569			 
d569 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
d59e .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
d5d4 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
d605 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
d619 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
d62e .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
d662 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
d6a6			 
d6a6			; Using 'ga' save a high score across multiple runs using external storage 
d6a6			 
d6a6 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
d70f			 
d70f			 
d70f			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
d70f			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
d70f			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
d70f			 
d70f			; simple screen saver to test code memory reuse to destruction 
d70f			 
d70f .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
d745 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
d761 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
d77d .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
d796 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
d7de .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
d835			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
d835			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
d835			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
d835			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
d835			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
d835			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
d835			 
d835			 
d835			 
d835			; minesweeper/battleship finding game 
d835			; draws a game board of random ship/mine positions 
d835			; user enters coords to see if it hits on 
d835			; game ends when all are hit 
d835			; when hit or miss says how many may be in the area 
d835			 
d835			; setup the game board and then hide it 
d835			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
d835			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
d835			;; prompt for where to target 
d835			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
d835			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
d835			;; TODO see if the entered coords hits or misses pushes char hit of miss 
d835			;game2mbht:      db ": mbckht nop ;",0 
d835			;game2mbms:      db ": mbcms nop ;",0 
d835			; TODO how many might be near by 
d835			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
d835			 
d835			; Game 3 
d835			 
d835			; Vert scroller ski game - avoid the trees! 
d835			 
d835			; v0 score (ie turns) 
d835			; v1 player pos 
d835			; v2 left wall 
d835			; v3 right wall 
d835			 
d835			; Draw side walls randomly 
d835			 
d835			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
d835			 
d835			; Draw player 
d835			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
d835			 
d835			; TODO Get Key 
d835			 
d835			; TODO Move left right 
d835			 
d835			; scroll and move walls a bit 
d835			 
d835			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
d835			 
d835			; main game loop 
d835			 
d835			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
d835			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
d835			 
d835			; key board defs 
d835			 
d835 .. 00		keyup:       db ": keyup $05 ;",0 
d843 .. 00		keydown:       db ": keydown $0a ;",0 
d853 .. 00		keyleft:       db ": keyleft $0b ;",0 
d863 .. 00		keyright:       db ": keyright $0c ;",0 
d874 .. 00		keyf1:       db ": keyf1 $10 ;",0 
d882 .. 00		keyf2:       db ": keyf2 $11 ;",0 
d890 .. 00		keyf3:       db ": keyf3 $12 ;",0 
d89e .. 00		keyf4:       db ": keyf4 $13 ;",0 
d8ac .. 00		keyf5:       db ": keyf5 $14 ;",0 
d8ba .. 00		keyf6:       db ": keyf6 $15 ;",0 
d8c8 .. 00		keyf7:       db ": keyf7 $16 ;",0 
d8d6 .. 00		keyf8:       db ": keyf8 $17 ;",0 
d8e4 .. 00		keyf9:       db ": keyf9 $18 ;",0 
d8f2 .. 00		keyf10:       db ": keyf10 $19 ;",0 
d901 .. 00		keyf11:       db ": keyf11 $1a ;",0 
d910 .. 00		keyf12:       db ": keyf12 $1b ;",0 
d91f			 
d91f .. 00		keytab:       db ": keytab $09 ;",0 
d92e .. 00		keycr:       db ": keycr $0d ;",0 
d93c .. 00		keyhome:       db ": keyhome $0e ;",0 
d94c .. 00		keyend:       db ": keyend $0f ;",0 
d95b .. 00		keybs:       db ": keybs $08 ;",0 
d969			 
d969			   
d969			 
d969			 
d969			 
d969			; eof 
# End of file forth_autostart.asm
d969			 
d969			 
d969			 
d969			; stack over and underflow checks 
d969			 
d969			; init the words to detect the under/overflow 
d969			 
d969			chk_stk_init: 
d969				; a vague random number to check so we dont get any "lucky" hits 
d969 3e 2d			ld a, 45 
d96b 6f				ld l, a 
d96c 00				nop 
d96d 3e 17			ld a, 23 
d96f 67				ld h, a 
d970			 
d970 22 9d e2			ld (chk_word), hl     ; the word we need to check against 
d973			 
d973			;	ld (chk_stund), hl	; stack points.... 
d973 22 00 ef			ld (chk_stovr), hl 
d976 22 ec e9			ld (chk_ret_und), hl 
d979 22 aa e9			ld (chk_ret_ovr), hl 
d97c 22 28 e9			ld (chk_loop_ovr), hl 
d97f 22 26 e8			ld (chk_data_ovr), hl 
d982 c9				ret 
d983				 
d983			check_stacks: 
d983				; check all stack words 
d983			 
d983 e5				push hl 
d984 d5				push de 
d985			 
d985			;	ld de,(chk_word) 
d985			;	ld hl, (chk_stund)	; stack points.... 
d985			;	if DEBUG_STK_FAULT 
d985			;		DMARK "FAa" 
d985			;		CALLMONITOR 
d985			;	endif 
d985			;	call cmp16 
d985			;	jp z, .chk_faulta 
d985			; 
d985			;	ld de, sfaultsu 
d985			;	jp .chk_fault 
d985			 
d985 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
d988 ed 5b 9d e2		ld de,(chk_word) 
d98c				if DEBUG_STK_FAULT 
d98c					DMARK "FAb" 
d98c					CALLMONITOR 
d98c				endif 
d98c cd 05 8d			call cmp16 
d98f 28 06			jr z, .chk_fault1 
d991 11 35 da			ld de, sfaultso 
d994 c3 e6 d9			jp .chk_fault 
d997			.chk_fault1:  
d997 2a ec e9			ld hl, (chk_ret_und) 
d99a ed 5b 9d e2		ld de,(chk_word) 
d99e				if DEBUG_STK_FAULT 
d99e					DMARK "FAU" 
d99e					CALLMONITOR 
d99e				endif 
d99e cd 05 8d			call cmp16 
d9a1 ca aa d9			jp z, .chk_fault2 
d9a4 11 45 da			ld de, sfaultru 
d9a7 c3 e6 d9			jp .chk_fault 
d9aa			.chk_fault2:  
d9aa 2a aa e9			ld hl, (chk_ret_ovr) 
d9ad ed 5b 9d e2		ld de,(chk_word) 
d9b1				if DEBUG_STK_FAULT 
d9b1					DMARK "FA1" 
d9b1					CALLMONITOR 
d9b1				endif 
d9b1 cd 05 8d			call cmp16 
d9b4 ca bd d9			jp z, .chk_fault3 
d9b7 11 53 da			ld de, sfaultro 
d9ba c3 e6 d9			jp .chk_fault 
d9bd			.chk_fault3:  
d9bd 2a 28 e9			ld hl, (chk_loop_ovr) 
d9c0 ed 5b 9d e2		ld de,(chk_word) 
d9c4				if DEBUG_STK_FAULT 
d9c4					DMARK "FA2" 
d9c4					CALLMONITOR 
d9c4				endif 
d9c4 cd 05 8d			call cmp16 
d9c7 ca d0 d9			jp z, .chk_fault4 
d9ca 11 6d da			ld de, sfaultlo 
d9cd c3 e6 d9			jp .chk_fault 
d9d0			.chk_fault4:  
d9d0 2a 26 e8			ld hl, (chk_data_ovr) 
d9d3 ed 5b 9d e2		ld de,(chk_word) 
d9d7				if DEBUG_STK_FAULT 
d9d7					DMARK "FA3" 
d9d7					CALLMONITOR 
d9d7				endif 
d9d7 cd 05 8d			call cmp16 
d9da ca e3 d9			jp z, .chk_fault5 
d9dd 11 87 da			ld de, sfaultdo 
d9e0 c3 e6 d9			jp .chk_fault 
d9e3			 
d9e3			 
d9e3			.chk_fault5:  
d9e3 d1				pop de 
d9e4 e1				pop hl 
d9e5			 
d9e5 c9				ret 
d9e6			 
d9e6 cd ba 8a		.chk_fault: 	call clear_display 
d9e9 3e 28				ld a, display_row_2 
d9eb cd cd 8a				call str_at_display 
d9ee 11 17 da				   ld de, .stackfault 
d9f1 3e 00				ld a, display_row_1 
d9f3 cd cd 8a				call str_at_display 
d9f6 11 6b ee				    ld de, debug_mark 
d9f9 3e 11				ld a, display_row_1+17 
d9fb cd cd 8a				call str_at_display 
d9fe cd dd 8a				call update_display 
da01			 
da01				; prompt before entering montior for investigating issue 
da01			 
da01 3e 78			ld a, display_row_4 
da03 11 60 97			ld de, endprog 
da06			 
da06 cd dd 8a			call update_display		 
da09			 
da09 cd e6 99			call next_page_prompt 
da0c			 
da0c d1				pop de 
da0d e1				pop hl 
da0e cd b4 97				call monitor 
da11 cd cf 9d				call forth_warmstart 
da14 c3 b0 96				jp warmstart_afterauto 
da17					;jp 0 
da17					;halt 
da17			 
da17			 
da17			 
da17 .. 00		.stackfault: 	db "Stack fault:",0 
da24			 
da24 .. 00		sfaultsu: 	db	"Stack under flow",0 
da35 .. 00		sfaultso: 	db	"Stack over flow",0 
da45 .. 00		sfaultru:	db "RTS underflow",0 
da53 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
da6d .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
da87 .. 00		sfaultdo:	db "DTS overflow", 0 
da94			 
da94			 
da94			fault_dsp_under: 
da94 11 a6 da			ld de, .dsp_under 
da97 c3 5c db			jp .show_fault 
da9a			 
da9a			fault_rsp_under: 
da9a 11 b4 da			ld de, .rsp_under 
da9d c3 5c db			jp .show_fault 
daa0			fault_loop_under: 
daa0 11 c2 da			ld de, .loop_under 
daa3 c3 5c db			jp .show_fault 
daa6			 
daa6 .. 00		.dsp_under: db "DSP Underflow",0 
dab4 .. 00		.rsp_under: db "RSP Underflow",0 
dac2 .. 00		.loop_under: db "LOOP Underflow",0 
dad1			 
dad1			 
dad1 d5			type_faultn: 	push de 
dad2 e5					push hl 
dad3 cd ba 8a				call clear_display 
dad6 11 00 db				   ld de, .typefaultn 
dad9 3e 00				ld a, display_row_1 
dadb cd cd 8a				call str_at_display 
dade 11 6b ee				    ld de, debug_mark 
dae1 3e 11				ld a, display_row_1+17 
dae3 cd cd 8a				call str_at_display 
dae6 cd dd 8a				call update_display 
dae9			 
dae9				; prompt before entering montior for investigating issue 
dae9			 
dae9 3e 78			ld a, display_row_4 
daeb 11 60 97			ld de, endprog 
daee			 
daee cd dd 8a			call update_display		 
daf1			 
daf1 cd e6 99			call next_page_prompt 
daf4			 
daf4 e5					push hl 
daf5 d5					push de 
daf6 cd b4 97				call monitor 
daf9 cd cf 9d				call forth_warmstart 
dafc c3 b0 96				jp warmstart_afterauto 
daff 76					halt 
db00			 
db00			 
db00 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
db17			 
db17 d5			type_faults: 	push de 
db18 e5					push hl 
db19 cd ba 8a				call clear_display 
db1c 11 45 db				   ld de, .typefaults 
db1f 3e 00				ld a, display_row_1 
db21 cd cd 8a				call str_at_display 
db24 11 6b ee				    ld de, debug_mark 
db27 3e 11				ld a, display_row_1+17 
db29 cd cd 8a				call str_at_display 
db2c cd dd 8a				call update_display 
db2f			 
db2f				; prompt before entering montior for investigating issue 
db2f			 
db2f 3e 78			ld a, display_row_4 
db31 11 60 97			ld de, endprog 
db34			 
db34 cd dd 8a			call update_display		 
db37			 
db37 cd e6 99			call next_page_prompt 
db3a			 
db3a e1					pop hl 
db3b d1					pop de 
db3c cd b4 97				call monitor 
db3f cd cf 9d				call forth_warmstart 
db42 c3 b0 96				jp warmstart_afterauto 
db45			 
db45			 
db45 .. 00		.typefaults: db "STR Type Expected TOS!",0 
db5c			 
db5c			.show_fault: 	 
db5c d5					push de 
db5d cd ba 8a				call clear_display 
db60 d1					pop de 
db61 3e 00				ld a, display_row_1 
db63 cd cd 8a				call str_at_display 
db66 11 6b ee				    ld de, debug_mark 
db69 3e 11				ld a, display_row_1+17 
db6b cd cd 8a				call str_at_display 
db6e cd dd 8a				call update_display 
db71			 
db71				; prompt before entering montior for investigating issue 
db71			 
db71 3e 78			ld a, display_row_4 
db73 11 60 97			ld de, endprog 
db76			 
db76 cd dd 8a			call update_display		 
db79			 
db79 cd e6 99			call next_page_prompt 
db7c			 
db7c e1					pop hl 
db7d d1					pop de 
db7e cd b4 97				call monitor 
db81			; do a dump to cli and not warmstart so we preserve all of the uwords.  
db81			; TODO Make optional fault restart to cli or warm boot? 
db81					;jp warmstart 
db81 c3 f4 96				jp cli 
db84 76					halt 
db85			 
db85			; handle the auto run of code from files in storage 
db85			 
db85			 
db85			include "forth_startup.asm" 
db85			; Which startup method to use? 
db85			; 
db85			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
db85			; followed by loading of a list of scripts in eeprom 
db85			 
db85			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
db85			; from eeprom 
db85			 
db85			; Select with define in main stubs 
db85			 
db85			if STARTUP_V1 
db85				include "forth_startupv1.asm" 
db85			; Startup script loading version 1 
db85			 
db85			; If SE storage is available first stage is to use the selected file 
db85			; then go through the eeprom list 
db85			 
db85 .. 00		sprompt1: db "Startup load...",0 
db95 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
dbab			 
dbab			 
dbab			 
dbab			 
dbab			forth_startup: 
dbab 21 ef cc			ld hl, startcmds 
dbae 3e 00			ld a, 0 
dbb0 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
dbb3			 
dbb3 e5			.start1:	push hl 
dbb4 cd ba 8a			call clear_display 
dbb7 11 85 db			ld de, sprompt1 
dbba 3e 00		        ld a, display_row_1 
dbbc cd cd 8a			call str_at_display 
dbbf 11 95 db			ld de, sprompt2 
dbc2 3e 28		        ld a, display_row_2 
dbc4 cd cd 8a			call str_at_display 
dbc7 e1				pop hl 
dbc8 e5				push hl 
dbc9 5e				ld e,(hl) 
dbca 23				inc hl 
dbcb 56				ld d,(hl) 
dbcc 3e 50		        ld a, display_row_3 
dbce cd cd 8a			call str_at_display 
dbd1 cd dd 8a			call update_display 
dbd4			 
dbd4			 
dbd4 3a e7 e6			ld a, (os_last_cmd) 
dbd7 fe 00			cp 0 
dbd9 28 05			jr z, .startprompt 
dbdb cd f1 89			call delay250ms 
dbde 18 24			jr .startdo 
dbe0				 
dbe0				 
dbe0			 
dbe0			.startprompt: 
dbe0			 
dbe0 3e 9f			ld a,display_row_4 + display_cols - 1 
dbe2 11 e4 99		        ld de, endprg 
dbe5 cd cd 8a			call str_at_display 
dbe8 cd dd 8a			call update_display 
dbeb cd fd 89			call delay1s 
dbee cd 11 dd			call cin_wait 
dbf1						 
dbf1 fe 2a			cp '*' 
dbf3 28 5e			jr z, .startupend1 
dbf5 fe 23			cp '#' 
dbf7 20 07			jr nz, .startno 
dbf9 3e 01			ld a, 1 
dbfb 32 e7 e6			ld (os_last_cmd),a 
dbfe 18 04			jr .startdo 
dc00 fe 31		.startno:	cp '1' 
dc02 28 3a			jr z,.startnxt  
dc04			 
dc04				; exec startup line 
dc04			.startdo:	 
dc04 e1				pop hl 
dc05 e5				push hl 
dc06				 
dc06 5e				ld e,(hl) 
dc07 23				inc hl 
dc08 56				ld d,(hl) 
dc09 eb				ex de,hl 
dc0a			 
dc0a e5				push hl 
dc0b			 
dc0b 3e 00			ld a, 0 
dc0d				;ld a, FORTH_END_BUFFER 
dc0d cd 58 90			call strlent 
dc10 23				inc hl   ; include zero term to copy 
dc11 06 00			ld b,0 
dc13 4d				ld c,l 
dc14 e1				pop hl 
dc15 11 c1 e2			ld de, scratch 
dc18 ed b0			ldir 
dc1a			 
dc1a			 
dc1a 21 c1 e2			ld hl, scratch 
dc1d cd 77 9e			call forthparse 
dc20 cd b7 9e			call forthexec 
dc23 cd c9 9d			call forthexec_cleanup 
dc26			 
dc26 3e 78			ld a, display_row_4 
dc28 11 60 97			ld de, endprog 
dc2b			 
dc2b cd dd 8a			call update_display		 
dc2e			 
dc2e 3a e7 e6			ld a, (os_last_cmd) 
dc31 fe 00			cp 0 
dc33 20 09			jr nz, .startnxt 
dc35 cd e6 99			call next_page_prompt 
dc38 cd ba 8a		        call clear_display 
dc3b cd dd 8a			call update_display		 
dc3e			 
dc3e				; move onto next startup line? 
dc3e			.startnxt: 
dc3e			 
dc3e cd f1 89			call delay250ms 
dc41 e1				pop hl 
dc42			 
dc42 23				inc hl 
dc43 23				inc hl 
dc44			 
dc44 e5				push hl 
dc45 5e				ld e, (hl) 
dc46 23				inc hl 
dc47 56				ld d, (hl) 
dc48 e1				pop hl 
dc49				; TODO replace 0 test 
dc49			 
dc49 eb				ex de, hl 
dc4a cd 10 8d			call ishlzero 
dc4d			;	ld a,e 
dc4d			;	add d 
dc4d			;	cp 0    ; any left to do? 
dc4d eb				ex de, hl 
dc4e c2 b3 db			jp nz, .start1 
dc51 18 01			jr .startupend 
dc53			 
dc53 e1			.startupend1: pop hl 
dc54			.startupend: 
dc54			 
dc54 cd ba 8a			call clear_display 
dc57 cd dd 8a			call update_display 
dc5a c9				ret 
dc5b			if STORAGE_SE 
dc5b			 
dc5b			sprompt3: db "Loading from start-up file?:",0 
dc5b			sprompt4: db "(Y=Any key/N=No)",0 
dc5b			 
dc5b			 
dc5b			forth_autoload: 
dc5b			 
dc5b				; load block 0 of store 1 
dc5b				 
dc5b				ld a, $fe      ; bit 0 clear 
dc5b				ld (spi_device), a 
dc5b			 
dc5b				call storage_get_block_0 
dc5b			 
dc5b				ld a, (store_page+STORE_0_AUTOFILE) 
dc5b			 
dc5b				cp 0 
dc5b				ret z     ; auto start not enabled 
dc5b			 
dc5b				call clear_display 
dc5b			 
dc5b				; set bank 
dc5b			 
dc5b					ld a, (store_page+STORE_0_BANKRUN) 
dc5b					ld (spi_device), a 
dc5b			 
dc5b				; get file id to load from and get the file name to display 
dc5b			 
dc5b					ld a, (store_page+STORE_0_FILERUN) 
dc5b			 
dc5b					ld l, 0 
dc5b					ld h, a 
dc5b					ld de, store_page 
dc5b			 
dc5b					if DEBUG_FORTH_WORDS 
dc5b						DMARK "ASp" 
dc5b						CALLMONITOR 
dc5b					endif 
dc5b					call storage_read 
dc5b			 
dc5b					if DEBUG_FORTH_WORDS 
dc5b						DMARK "ASr" 
dc5b						CALLMONITOR 
dc5b					endif 
dc5b			 
dc5b					call ishlzero 
dc5b					ret z             ; file not found 
dc5b			 
dc5b					ld a, display_row_2 + 10 
dc5b					ld de, store_page+3 
dc5b					call str_at_display 
dc5b				 
dc5b			; 
dc5b			 
dc5b				ld a, display_row_1+5 
dc5b				ld de, sprompt3 
dc5b				call str_at_display 
dc5b				ld a, display_row_3+15 
dc5b				ld de, sprompt4 
dc5b				call str_at_display 
dc5b			 
dc5b				call update_display 
dc5b			 
dc5b				call cin_wait 
dc5b				cp 'n' 
dc5b				ret z 
dc5b				cp 'N' 
dc5b				ret z 
dc5b			 
dc5b				call delay1s 
dc5b			 
dc5b				ld a, (store_page+2) 
dc5b				ld (store_openmaxext), a    ; save count of ext 
dc5b				ld a, 1  
dc5b				ld (store_openext), a    ; save count of ext 
dc5b			 
dc5b			.autof:  
dc5b				ld l , a 
dc5b				 
dc5b				ld a, (store_page) 
dc5b				ld h, a	 
dc5b				ld de, store_page 
dc5b					if DEBUG_FORTH_WORDS 
dc5b						DMARK "ASl" 
dc5b						CALLMONITOR 
dc5b					endif 
dc5b					call storage_read 
dc5b				call ishlzero 
dc5b				ret z 
dc5b			;	jr z, .autoend 
dc5b			 
dc5b					if DEBUG_FORTH_WORDS 
dc5b						DMARK "ASc" 
dc5b						CALLMONITOR 
dc5b					endif 
dc5b				ld de, store_page+2 
dc5b				ld a, display_row_4 
dc5b				call str_at_display 
dc5b			 
dc5b				call update_display 
dc5b				call delay250ms 
dc5b			 
dc5b			 
dc5b			 
dc5b				ld hl, store_page+2 
dc5b				call forthparse 
dc5b				call forthexec 
dc5b				call forthexec_cleanup 
dc5b			 
dc5b				 
dc5b				ld a, (store_openext) 
dc5b				inc a 
dc5b				ld (store_openext), a    ; save count of ext 
dc5b			 
dc5b				jr .autof 
dc5b			;.autofdone: 
dc5b			; 
dc5b			;		if DEBUG_FORTH_WORDS 
dc5b			;			DMARK "ASx" 
dc5b			;			CALLMONITOR 
dc5b			;		endif 
dc5b			;;	call clear_display 
dc5b			;	ret 
dc5b			 
dc5b			 
dc5b			 
dc5b			endif 
# End of file forth_startupv1.asm
dc5b			endif 
dc5b			if STARTUP_V2 
dc5b				include "forth_startupv2.asm" 
dc5b			endif 
dc5b			 
# End of file forth_startup.asm
dc5b			 
dc5b			; eof 
# End of file forth_kernel.asm
dc5b			;include "nascombasic.asm" 
dc5b			 
dc5b			 
dc5b			; find out where the code ends if loaded into RAM (for SC114) 
dc5b			;endofcode:  
dc5b			;	nop 
dc5b			 
dc5b			 
dc5b			; jump to nmi vector 
dc5b			 
dc5b			init_nmi: 
dc5b 3e c9			ld a, $c9   ; RET 
dc5d 32 72 ee			ld (nmi_vector), a 
dc60 c9				ret 
dc61			nmi: 
dc61 e5				push hl 
dc62 d5				push de 
dc63 c5				push bc 
dc64 f5				push af 
dc65 cd 72 ee			call nmi_vector 
dc68 f5				push af 
dc69 c5				push bc 
dc6a d5				push de 
dc6b e5				push hl 
dc6c ed 4d			reti 
dc6e			 
dc6e			 
dc6e			; eof 
dc6e			 
# End of file main.asm
dc6e			;include "firmware_lcd_4x40.asm" 
dc6e			;;include "firmware_lcd_4x20.asm" 
dc6e			include "firmware_serial_display.asm" 
dc6e			 
dc6e			; Serial display interface for SC114 
dc6e			 
dc6e			 
dc6e			display_row_1: equ 0 
dc6e			display_row_2: equ display_row_1+display_cols 
dc6e			display_row_3: equ display_row_2 + display_cols 
dc6e			display_row_4: equ display_row_3 + display_cols 
dc6e			 
dc6e			kLCDWidth:  EQU display_cols             ;Width in characters 
dc6e			kLCD_Line1: EQU 0x00  
dc6e			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
dc6e			; E1 
dc6e			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
dc6e			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
dc6e			 
dc6e			lcd_init: 
dc6e				; no init as handled by the SCM bios 
dc6e c9				ret 
dc6f			 
dc6f			 
dc6f			; low level functions for direct screen writes 
dc6f			 
dc6f			; output char at pos? 
dc6f			fLCD_Str: 
dc6f			        ;out (SC114_SIO_1_OUT),a 
dc6f c5				push bc 
dc70 0e 02			ld c, $02 
dc72 f7				rst $30 
dc73 c1				pop bc 
dc74 c9				ret 
dc75			 
dc75			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
dc75			fLCD_Pos: 
dc75				; use ASCII escape to position 
dc75			        ;out (SC114_SIO_1_OUT),a 
dc75 c5				push bc 
dc76 0e 02			ld c, $02 
dc78 f7				rst $30 
dc79 c1				pop bc 
dc7a			 
dc7a c9				ret 
dc7b			 
dc7b			; output char at pos 
dc7b			fLCD_Data: 
dc7b			      ;  out (SC114_SIO_1_OUT),a 
dc7b c5				push bc 
dc7c 0e 02			ld c, $02 
dc7e f7				rst $30 
dc7f c1				pop bc 
dc80			 
dc80 c9				ret 
dc81			 
dc81			; ascii cls  
dc81			 
dc81 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
dc85			 
dc85			; write the frame buffer given in hl to hardware  
dc85			write_display: 
dc85			 
dc85			API: equ 0 
dc85			 
dc85			if API 
dc85				push bc 
dc85				ld b, 4 
dc85			 
dc85			        ld (display_write_tmp), hl 	  
dc85			 
dc85				; clear and home cursor 
dc85			 
dc85				ld c, 6 
dc85				ld de, .cls 
dc85				rst $30 
dc85			 
dc85			 
dc85			.writeln: 
dc85			 
dc85				ld de, (display_write_tmp) 
dc85				ld c, 6 
dc85				rst $30 
dc85				ld c, 7 
dc85				rst $30 
dc85			 
dc85				ld hl, (display_write_tmp) 
dc85				ld de, display_cols 
dc85				add hl,de 
dc85				ld (display_write_tmp),hl 
dc85			 
dc85				djnz  .writeln 
dc85			 
dc85				pop bc 
dc85			 
dc85			 
dc85				ret 
dc85			endif 
dc85 e5				push hl 
dc86 c5				push bc 
dc87 d5				push de 
dc88			 
dc88			;	ld c, 2 
dc88			;	;ld de, .cls 
dc88			;	ld a, 27 
dc88			;	rst $30 
dc88			;	ld c, 2 
dc88			;	;ld de, .cls 
dc88			;	ld a, '[' 
dc88			;	rst $30 
dc88			; 
dc88			;	ld c, 2 
dc88			;	;ld de, .cls 
dc88			;	ld a, 'H' 
dc88			;	rst $30 
dc88			; 
dc88			 
dc88 0e 02			ld c, 2 
dc8a				;ld de, .cls 
dc8a 3e 1b			ld a, 27 
dc8c f7				rst $30 
dc8d			 
dc8d			 
dc8d 0e 02			ld c, 2 
dc8f				;ld de, .cls 
dc8f 3e 5b			ld a, '[' 
dc91 f7				rst $30 
dc92 0e 02			ld c, 2 
dc94				;ld de, .cls 
dc94 3e 32			ld a, '2' 
dc96 f7				rst $30 
dc97 0e 02			ld c, 2 
dc99				;ld de, .cls 
dc99 3e 4a			ld a, 'J' 
dc9b f7				rst $30 
dc9c d1				pop de 
dc9d c1				pop bc 
dc9e e1				pop hl 
dc9f			 
dc9f			 
dc9f 22 c9 eb		        ld (display_write_tmp), hl 	  
dca2 3e 00			ld a, kLCD_Line1 
dca4			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
dca4 06 28			ld b, display_cols 
dca6 ed 5b c9 eb		ld de, (display_write_tmp) 
dcaa cd 08 dd			call write_len_string 
dcad				 
dcad			 
dcad e5			push hl 
dcae d5			push de 
dcaf c5			push bc 
dcb0 0e 07			ld c, 7 
dcb2 f7				rst $30 
dcb3 c1			pop bc 
dcb4 d1			pop de 
dcb5 e1			pop hl 
dcb6			 
dcb6				 
dcb6 2a c9 eb			ld hl, (display_write_tmp) 
dcb9 11 28 00			ld de, display_cols 
dcbc 19				add hl,de 
dcbd 22 c9 eb			ld (display_write_tmp),hl 
dcc0			 
dcc0				 
dcc0 3e 28			ld a, kLCD_Line2 
dcc2			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
dcc2 06 28			ld b, display_cols 
dcc4 ed 5b c9 eb		ld de, (display_write_tmp) 
dcc8 cd 08 dd			call write_len_string 
dccb				 
dccb 2a c9 eb			ld hl, (display_write_tmp) 
dcce 11 28 00			ld de, display_cols 
dcd1 19				add hl,de 
dcd2 22 c9 eb			ld (display_write_tmp),hl 
dcd5			 
dcd5 e5			push hl 
dcd6 d5			push de 
dcd7 c5			push bc 
dcd8 0e 07			ld c, 7 
dcda f7				rst $30 
dcdb c1			pop bc 
dcdc d1			pop de 
dcdd e1			pop hl 
dcde			 
dcde				 
dcde 3e 50			ld a, kLCD_Line3 
dce0			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
dce0 06 28			ld b, display_cols 
dce2 ed 5b c9 eb		ld de, (display_write_tmp) 
dce6 cd 08 dd			call write_len_string 
dce9				 
dce9 2a c9 eb			ld hl, (display_write_tmp) 
dcec 11 28 00			ld de, display_cols 
dcef 19				add hl,de 
dcf0 22 c9 eb			ld (display_write_tmp),hl 
dcf3			 
dcf3 e5			push hl 
dcf4 d5			push de 
dcf5 c5			push bc 
dcf6 0e 07			ld c, 7 
dcf8 f7				rst $30 
dcf9 c1			pop bc 
dcfa d1			pop de 
dcfb e1			pop hl 
dcfc			 
dcfc				 
dcfc 3e 78			ld a, kLCD_Line4 
dcfe			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
dcfe 06 28			ld b, display_cols 
dd00 ed 5b c9 eb		ld de, (display_write_tmp) 
dd04 cd 08 dd			call write_len_string 
dd07 c9					ret 
dd08			 
dd08			 
dd08				; write out a fixed length string given in b from de 
dd08			 
dd08 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
dd09 cd 7b dc		            CALL fLCD_Data      ;Write character to display 
dd0c 13				inc de 
dd0d 10 f9			djnz write_len_string 
dd0f c9				ret 
dd10			 
dd10			 
dd10			; eof 
# End of file firmware_serial_display.asm
dd10			;include "firmware_key_5x10.asm" 
dd10			;;include "firmware_key_4x10.asm" 
dd10			include "firmware_key_serial.asm" 
dd10			; Serial keyboard interface for SC114 
dd10			 
dd10			key_init: 
dd10				; no init as handled by the SCM bios 
dd10 c9				ret 
dd11			 
dd11			 
dd11			cin_wait: 
dd11			;	ld a, 0 
dd11			;	ret 
dd11			 
dd11				;in a,(SC114_SIO_1_IN) 
dd11			        ; Use SCM API to get from whatever console device we are using 
dd11 c5				push bc 
dd12 0e 01			ld c, $01 
dd14 f7				rst $30 
dd15 c1				pop bc 
dd16 c9				ret 
dd17			 
dd17			cin: 
dd17			 
dd17			 
dd17 c5				push bc 
dd18			 
dd18				; any key waiting to process? 
dd18 0e 03			ld c, $03 
dd1a f7				rst $30 
dd1b 28 05			jr z, .cin_skip 
dd1d			 
dd1d				; yep, get it 
dd1d			 
dd1d 0e 01			ld c, $01 
dd1f f7				rst $30 
dd20 c1				pop bc 
dd21 c9				ret 
dd22			.cin_skip: 
dd22 3e 00			ld a, 0 
dd24 c1				pop bc 
dd25 c9				ret 
dd26			 
dd26			 
dd26			 
dd26			 
# End of file firmware_key_serial.asm
dd26			endofcode:  
dd26			baseram:  
dd26 00				nop 
dd27			 
dd27			heap_start: equ baseram+15  ; Starting address of heap 
dd27			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
dd27			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
dd27			;VDU:  EQU     endofcode           ; BASIC Work space 
dd27			; eof 
dd27			 
# End of file os_mega_sc114.asm
dd27
