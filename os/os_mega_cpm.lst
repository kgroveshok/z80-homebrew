# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 6d 17			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 ..			buildtime: db   "Build: " 
010a					include "romtimestamp.asm" 
010a ..			db '2025-08-09 11:19' 
# End of file romtimestamp.asm
011a 00				   db 0 
011b			 
011b			 
011b			 
011b			;        nop  
011b			;        nop 
011b			;;	org 05h		; null out bdos call 
011b			; 
011b			;        nop  
011b			;        nop  
011b			;        nop 
011b			;;	org 08h 
011b			;;; 
011b			;;	jp cin		; rst 8 - char in 
011b			;;; 
011b			; 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;	org 010h 
011b			;; 
011b			;	jp cout		; rest 010h  - char out 
011b			;; 
011b			;	org 01bh   
011b			; 
011b			;	;jp  		; rst 01bh   - write string to display 
011b			;	jp str_at_display 
011b			; 
011b			; 
011b			;	org 020h 
011b			; 
011b			;	; jp		 ; rst 020h - read char at screen location 
011b			; 
011b			;	org 028h 
011b			 
011b				; jp		 ; rst 028h  - storage i/o 
011b			 
011b			; 	org 030h 
011b			;	jp break_point_state 
011b			  
011b			; $30  
011b			; org 038h 
011b			; $38 
011b			 
011b			; TODO any more important entry points to add to jump table for easier coding use? 
011b			 
011b			if BASE_KEV = 1  
011b			 
011b				; need to be at $66 for nmi support 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255 
011b				jp nmi 
011b			endif 
011b			 
011b			include "firmware.asm" 
011b			  
011b			; main constants (used here and in firmware)  
011b			  
011b			; TODO have page 0 of storage as bios  
011b			  
011b			Device_A: equ 0h  
011b			Device_B: equ 040h          ; Sound  
011b			  
011b			if BASE_KEV  
011b			Device_C: equ 080h          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			if BASE_SC114  
011b			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			if BASE_CPM  
011b			; TODO fixup for CPM  
011b			Device_C: equ 080h          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			Device_D: equ 0c0h             ; Keyboard and LCD  
011b			  
011b			; Odd specific debug points for testing hardware dev  
011b			  
011b			DEBUG_SOUND: equ 0       
011b			DEBUG_STK_FAULT: equ 0  
011b			DEBUG_INPUT: equ 0     ; Debug input entry code  
011b			DEBUG_INPUTV2: equ 0     ; Debug input entry code  
011b			DEBUG_KEYCINWAIT: equ 0  
011b			DEBUG_KEYCIN: equ 0  
011b			DEBUG_KEY: equ 0  
011b			DEBUG_KEY_MATRIX: equ 0  
011b			DEBUG_STORECF: equ 0  
011b			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011b			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011b			DEBUG_SPI: equ 0    ; low level spi tests  
011b			  
011b			; Enable many break points  
011b			  
011b			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011b			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011b			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011b			DEBUG_FORTH_JP: equ 0    ; 4  
011b			DEBUG_FORTH_MALLOC: equ 0  
011b			DEBUG_FORTH_MALLOC_INT: equ 0  
011b			DEBUG_FORTH_DOT: equ 1  
011b			DEBUG_FORTH_DOT_WAIT: equ 0  
011b			DEBUG_FORTH_MATHS: equ 0  
011b			DEBUG_FORTH_TOK: equ 0    ; 4  
011b			DEBUG_FORTH_PARSE: equ 0    ; 3  
011b			DEBUG_FORTH: equ 0  ;2  
011b			DEBUG_FORTH_WORDS: equ 1   ; 1  
011b			DEBUG_FORTH_PUSH: equ 1   ; 1  
011b			DEBUG_FORTH_UWORD: equ 1   ; 1  
011b			  
011b			; Enable key point breakpoints  
011b			  
011b			DEBUG_FORTH_DOT_KEY: equ 0  
011b			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011b			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011b			  
011b			; Debug stack imbalances  
011b			  
011b			ON: equ 1  
011b			OFF: equ 0  
011b			  
011b			DEBUG_STACK_IMB: equ 0  
011b			STACK_IMB_STORE: equ 20  
011b			  
011b			; House keeping and protections  
011b			  
011b			DEBUG_FORTH_STACK_GUARD: equ 1  
011b			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011b			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011b			FORTH_ENABLE_FREE: equ 0  
011b			FORTH_ENABLE_MALLOCFREE: equ 1  
011b			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011b			FORTH_ENABLE_FLOATMATH: equ 0  
011b			  
011b			  
011b			CALLMONITOR: macro  
011b			;	call break_point_state  
011b			; now use the break point debug vector  
011b				call debug_vector  
011b				endm  
011b			  
011b			MALLOC_1: equ 1        ; from dk88   
011b			MALLOC_2: equ 0           ; broke  
011b			MALLOC_3: equ 0           ; really broke  
011b			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011b			  
011b			if BASE_KEV   
011b			;stacksize: equ 256  
011b			; each stack entry is three bytes (type + word)  
011b			stacksize: equ 3*150  
011b			  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 512  
011b			endif  
011b			if BASE_SC114  
011b			;tos:	equ 0f000h  
011b			stacksize: equ 256  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 256  
011b			endif  
011b			  
011b			if BASE_CPM  
011b			;tos:	equ 0f000h  
011b			stacksize: equ 256  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 256  
011b			endif  
011b			  
011b			;if STORAGE_SE == 0  
011b			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011b			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011b			;endif  
011b			  
011b			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011b			  
011b			STORE_0_AUTORUN: equ $20  
011b			  
011b			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011b			  
011b			STORE_0_AUTOFILE: equ $21  
011b			STORE_0_BANKRUN: equ $23  
011b			STORE_0_FILERUN: equ $24  
011b			  
011b			; Block 0 offsets for settings  
011b			  
011b			; if set then skip prompt for start up and accept all  
011b			  
011b			STORE_0_QUICKSTART: equ $25  
011b			  
011b			; Blocks where directory table is held  
011b			  
011b			; Reducing the number of entries increases the max file size  
011b			  
011b			;STORE_DIR_START: equ 1  
011b			;STORE_DIR_END: equ 33  
011b			  
011b			; Blocks from where file data is stored  
011b			  
011b			;STORE_DATA_START: equ STORE_DIR_END + 1  
011b			  
011b			; Block indicators (<32 are data files)  
011b			  
011b			;STORE_BLOCK_CFG: equ $8f       ; config block  
011b			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011b			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011b			;STORE_BLOCK_FREE: equ $85       ; data block free  
011b			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011b			  
011b			  
011b			  
011b			; Directory entry flags  
011b			  
011b			;STORE_DIR_FREE: equ 0  
011b			;STORE_DIR_FILE:  equ 1  
011b			  
011b			; Structure offsets to directory entries  
011b			;STORE_DE_FLAG: equ 0  
011b			;STORE_DE_MAXEXT: equ 1  
011b			;STORE_DE_FILENAME: equ 2  
011b			  
011b			; Structure offsets to block 0  
011b			  
011b			;STORE_BK0_ISFOR: equ 1  
011b			;STORE_BK0_LABEL: equ 3  
011b			  
011b			; memory allocation   
011b			  
011b			chk_stund: equ tos+2           ; underflow check word  
011b			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011b			  
011b			; keyscan table needs rows x cols buffer  
011b			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011b			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011b			  
011b			keyscan_table_row1: equ chk_stovr -key_cols-1  
011b			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011b			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011b			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011b			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011b			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011b			keyscan_scancol: equ keyscan_table-key_cols  
011b			;keyscan_table_len: equ key_rows*key_cols  
011b			;keybufptr: equ keyscan_table - 2  
011b			;keysymbol: equ keybufptr - 1  
011b			key_held: equ keyscan_scancol-1	; currently held  
011b			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011b			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011b			key_fa: equ key_repeat_ct -1 ;  
011b			key_fb: equ key_fa -1 ;  
011b			key_fc: equ key_fb -1 ;  
011b			key_fd: equ key_fc -1 ;  
011b			key_face_held: equ key_fd - 1   
011b			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011b			  
011b			hardware_config: equ key_face_held - 10  
011b			  
011b			; hardware config switches  
011b			; TODO add bitmasks on includes for hardware  
011b			; high byte for expansion ids  
011b			;     0000 0000  no card inserted  
011b			;     0000 0001  storage card inserted  
011b			;     0000 0010  spi sd card active  
011b			  
011b			;       
011b			; low byte:  
011b			;     0000 0001   4x4 keypad  
011b			;     0000 0010   full keyboard  
011b			;     0000 0011   spi/ext keyboard  
011b			;     0000 0100   20x4 lcd  
011b			;     0000 1000   40x4 lcd  
011b			;     0000 1100   spi/ext display  
011b			;     0001 0000   ide interface available  
011b			  
011b			hardware_word: equ hardware_config - 2  
011b			  
011b			; debug marker - optional display of debug point on the debug screens  
011b			  
011b			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011b			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011b			  
011b			debug_mark: equ debug_vector - 4  
011b			  
011b			; input_str vars  
011b			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011b			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011b			input_size: equ input_start -1  ; number of chars  
011b			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011b			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011b			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011b			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011b			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011b			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011b			input_len: equ input_cur_onoff - 5 ; length of current input  
011b			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011b			  
011b			; cursor blink rate  
011b			CUR_BLINK_RATE: equ $09  
011b			;CUR_BLINK_RATE: equ 15  
011b			  
011b			key_actual_pressed: equ input_cursor - 1   
011b			key_symbol: equ key_actual_pressed - 1   
011b			key_shift: equ key_symbol - 1   
011b			  
011b			; Display allocation  
011b			  
011b			;display_rows: equ 4     ; move out to mini and mega files  
011b			;display_cols: equ 20  
011b			  
011b			display_fb_len: equ display_rows*display_cols  
011b			  
011b			; primary frame buffer     
011b			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011b			; working frame buffers  
011b			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011b			display_fb3: equ  display_fb1-display_fb_len - 1  
011b			display_fb2: equ  display_fb3-display_fb_len - 1  
011b			;  
011b			; pointer to active frame buffer  
011b			display_fb_active: equ display_fb2 - 2  
011b			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011b			display_write_tmp: equ display_lcde1e2 - 2  
011b			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011b			  
011b			;  
011b			  
011b			;; can load into de directory  
011b			cursor_col: equ display_active-1  
011b			cursor_row: equ cursor_col-1  
011b			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011b			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011b			  
011b			; maths vars  
011b			  
011b			LFSRSeed: equ cursor_shape -20   
011b			randData: equ LFSRSeed - 2  
011b			xrandc: equ randData - 2  
011b			stackstore: equ xrandc - 2  
011b			seed1: equ  stackstore -2   
011b			seed2: equ seed1 - 2  
011b			  
011b			; cf storage vars  
011b			  
011b			iErrorNum:  equ seed2-1         ;Error number  
011b			iErrorReg:  equ iErrorNum -1              ;Error register  
011b			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011b			  
011b			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011b			  
011b			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011b			  
011b			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011b			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011b			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011b			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011b			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011b			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011b			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011b			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011b			store_tmpid: equ store_tmp3 - 1		; page temp id  
011b			store_tmpext: equ store_tmpid - 1		; file extent temp  
011b			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011b			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011b			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011b			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011b			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011b			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011b			;  
011b			; spi vars  
011b			  
011b			  
011b			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011b			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011b			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011b			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011b			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011b			spi_device_id: equ spi_device - 1    ; human readable bank number  
011b			  
011b			;;;;; forth cli params  
011b			  
011b			; TODO use a different frame buffer for forth???  
011b			  
011b			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011b			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011b			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011b			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011b			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011b			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011b			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011b			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011b			  
011b			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011b			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011b			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011b			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011b			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011b			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011b			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011b			  
011b			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011b			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011b			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011b			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011b			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011b			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011b			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011b			  
011b			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011b			  
011b			; os/forth token vars  
011b			  
011b			os_last_cmd: equ os_var_array-255  
011b			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011b			os_current_i: equ os_cli_cmd-2  
011b			os_cur_ptr: equ os_current_i-2  
011b			os_word_scratch: equ os_cur_ptr-30  
011b			os_tok_len: equ os_word_scratch - 2  
011b			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011b			os_tok_malloc: equ os_tok_ptr - 2  
011b			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011b			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011b			execscratch: equ os_input-255        ; exec cmd eval buffer  
011b			scratch: equ execscratch-255  
011b			  
011b			os_stack_1: equ scratch - 3       ; stack holding area 1  
011b			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
011b			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
011b			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
011b			  
011b			  
011b			; temp locations for new word processing to save on adding more   
011b			  
011b			os_new_malloc: equ os_stack_4-2  
011b			os_new_parse_len: equ os_new_malloc - 2  
011b			os_new_word_len: equ os_new_parse_len - 2  
011b			os_new_work_ptr: equ os_new_word_len - 2  
011b			os_new_src_ptr: equ os_new_work_ptr - 2  
011b			os_new_exec: equ os_new_src_ptr - 2  
011b			os_new_exec_ptr: equ os_new_exec - 2  
011b			  
011b			; resume memory alloocations....  
011b			  
011b			;os_view_disable: equ os_new_exec_ptr - 1  
011b			os_view_af: equ os_new_exec_ptr - 2  
011b			os_view_hl: equ os_view_af -2  
011b			os_view_de: equ os_view_hl - 2  
011b			os_view_bc: equ os_view_de - 2  
011b			  
011b			; stack checksum word  
011b			if DEBUG_STACK_IMB  
011b				curframe: equ  os_view_de - 5  
011b				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011b				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011b			else  
011b				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011b			endif  
011b			  
011b			; with data stack could see memory filled with junk. need some memory management   
011b			; malloc and free entry points added  
011b			  
011b			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011b			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011b			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			;heap_end: equ free_list-1  ; Starting address of heap  
011b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			  
011b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			heap_end: equ chk_word-1  ; Starting address of heap  
011b			  
011b			  
011b			;if BASE_KEV   
011b			;heap_start: equ 0800eh  ; Starting address of heap  
011b			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011b			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011b			;endif  
011b			  
011b			;if BASE_SC114  
011b			;heap_start: equ baseram+15  ; Starting address of heap  
011b			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011b			;endif  
011b			  
011b			  
011b			;;;;  
011b			  
011b			  
011b			; change below to point to last memory alloc above  
011b			topusermem:  equ   heap_start  
011b			  
011b			;if BASE_KEV   
011b			;baseusermem: equ 08000h  
011b			;endif  
011b			  
011b			;if BASE_SC114  
011b			;;aseusermem:     equ    12  
011b			;baseusermem:     equ    prompt  
011b			;;baseusermem:     equ    endofcode  
011b			;endif  
011b			  
011b			  
011b			; **********************************************************************  
011b			; **  Constants  
011b			; **********************************************************************  
011b			  
011b			; Constants used by this code module  
011b			kDataReg:   EQU Device_D           ;PIO port A data register  
011b			kContReg:   EQU Device_D+2           ;PIO port A control register  
011b			  
011b			  
011b			portbdata:  equ Device_D+1    ; port b data  
011b			portbctl:   equ Device_D+3    ; port b control  
011b			  
011b			  
011b			;KEY_SHIFT:   equ 5  
011b			;KEY_SYMBOLSHIFT:  equ 6  
011b			  
011b			KEY_SHIFTLOCK: equ 4  
011b			  
011b			  
011b			KEY_UP: equ 5  
011b			KEY_NEXTWORD: equ 6  
011b			KEY_PREVWORD: equ 7  
011b			KEY_BS: equ 8  
011b			KEY_TAB:  equ 9  
011b			KEY_DOWN: equ 10  
011b			KEY_LEFT: equ 11  
011b			KEY_RIGHT: equ 12  
011b			KEY_CR:   equ 13  
011b			KEY_HOME: equ 14  
011b			KEY_END: equ 15  
011b			  
011b			KEY_F1: equ 16  
011b			KEY_F2: equ 17  
011b			KEY_F3: equ 18  
011b			KEY_F4: equ 19  
011b			  
011b			KEY_F5: equ 20  
011b			KEY_F6: equ 21  
011b			KEY_F7: equ 22  
011b			KEY_F8: equ 23  
011b			  
011b			KEY_F9: equ 24  
011b			KEY_F10: equ 25  
011b			KEY_F11: equ 26  
011b			KEY_F12: equ 27  
011b			  
011b			;if DEBUG_KEY  
011b			;	KEY_MATRIX_NO_PRESS: equ '.'  
011b			;	KEY_SHIFT:   equ '.'  
011b			;	KEY_SYMBOLSHIFT:  equ '.'  
011b			;else  
011b				KEY_SHIFT:   equ '~'  
011b				KEY_SYMBOLSHIFT:  equ '~'  
011b				KEY_MATRIX_NO_PRESS: equ '~'  
011b			;endi  
011b			  
011b			  
011b			  
011b			  
011b			; Macro to make adding debug marks easier  
011b			  
011b			DMARK: macro str  
011b				push af  
011b				ld a, (.dmark)  
011b				ld (debug_mark),a  
011b				ld a, (.dmark+1)  
011b				ld (debug_mark+1),a  
011b				ld a, (.dmark+2)  
011b				ld (debug_mark+2),a  
011b				jr .pastdmark  
011b			.dmark: db str  
011b			.pastdmark: pop af  
011b			  
011b			endm  
011b			  
011b			  
011b			; macro to detect for stack imbalances  
011b			  
011b			include "stackimbal.asm"  
011b			; Macro and code to detect stock imbalances 
011b			 
011b			SPPUSH: equ 0 
011b			 
011b			; Add a stack frame which can be checked before return 
011b			 
011b			STACKFRAME: macro onoff frame1 frame2 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						; save current SP 
011b						exx 
011b			 
011b						ld de, frame1 
011b						ld a, d 
011b						ld hl, curframe 
011b						call hexout 
011b						ld a, e 
011b						ld hl, curframe+2 
011b						call hexout 
011b			  
011b						ld hl, frame1 
011b						push hl 
011b						ld hl, frame2 
011b						push hl 
011b						exx 
011b					endif 
011b					 
011b				endif 
011b			endm 
011b			 
011b			STACKFRAMECHK: macro onoff frame1 frame2 
011b			 
011b					 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						exx 
011b						; check stack frame SP 
011b			 
011b						ld hl, frame2 
011b						pop de   ; frame2 
011b			 
011b						call cmp16 
011b						jr nz, .spnosame 
011b						 
011b			 
011b						ld hl, frame1 
011b						pop de   ; frame1 
011b			 
011b						call cmp16 
011b						jr z, .spfrsame 
011b			 
011b						.spnosame: call showsperror 
011b			 
011b						.spfrsame: nop 
011b			 
011b						exx 
011b					endif 
011b					 
011b				endif 
011b			 
011b			 
011b			endm 
011b			 
011b			 
011b			; for a sub routine, wrap SP collection and comparisons 
011b			 
011b			; Usage: 
011b			; 
011b			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011b			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011b			 
011b			SAVESP: macro onoff storeword 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						; save current SP 
011b			 
011b						ld (store_sp+(storeword*4)), sp 
011b			 
011b					endif 
011b					 
011b				endif 
011b			 
011b			endm 
011b			 
011b			CHECKSP: macro onoff storeword 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b			 
011b						; save SP after last save 
011b				 
011b						ld (store_sp+(storeword*4)+2), sp 
011b			 
011b						push hl 
011b						ld hl, store_sp+(storeword*4) 
011b						call check_stack_sp  
011b						pop hl 
011b			 
011b			 
011b					endif 
011b					 
011b				endif 
011b			 
011b			endm 
011b			 
011b			if DEBUG_STACK_IMB 
011b			 
011b			check_stack_sp: 
011b					push de 
011b			 
011b					ld e, (hl) 
011b					inc hl 
011b					ld d, (hl) 
011b					inc hl 
011b			 
011b					push de 
011b			 
011b			 
011b					ld e, (hl) 
011b					inc hl 
011b					ld d, (hl) 
011b					inc hl 
011b			 
011b					pop hl 
011b			 
011b			 
011b					; check to see if the same 
011b			 
011b					call cmp16 
011b					jr z, .spsame 
011b			 
011b					; not same 
011b			 
011b					call showsperror 
011b			.spsame: 
011b			 
011b					pop de 
011b			 
011b					ret 
011b			 
011b			.sperr:  db "Stack imbalance",0 
011b			 
011b			 
011b			showsperror: 
011b			 
011b			 
011b				push hl 
011b				push af 
011b				push de 
011b				call clear_display 
011b				ld de, .sperr 
011b				ld a,0 
011b			;	ld de,os_word_scratch 
011b				call str_at_display 
011b				ld a, display_row_1+17 
011b				ld de, debug_mark 
011b				call str_at_display 
011b				ld a, 0 
011b				ld (curframe+4),a 
011b				ld hl, curframe 
011b				ld de, os_word_scratch 
011b				ld a, display_row_4 
011b				call str_at_display 
011b				call update_display 
011b				;call break_point_state 
011b				call cin_wait 
011b			 
011b			;	ld a, ' ' 
011b			;	ld (os_view_disable), a 
011b				call bp_on 
011b				pop de	 
011b				pop af 
011b				pop hl 
011b				CALLMONITOR 
011b				ret 
011b			 
011b			endif 
011b			 
011b			 
011b			 
011b			; eof 
# End of file stackimbal.asm
011b			  
011b			;TODO macro to calc col and row offset into screen  
011b			  
011b			  
011b			  
011b			hardware_init:  
011b			  
011b				  
011b			  
011b					;ld a, 0  
011b					;ld (hardware_diag), a  
011b			  
011b					; clear all the buffers  
011b			  
011b 21 10 ed				ld hl, display_fb1  
011e 22 cc eb				ld (display_fb_active), hl  
0121			  
0121 cd b9 0b				call clear_display  
0124			  
0124 21 ce eb				ld hl, display_fb2  
0127 22 cc eb				ld (display_fb_active), hl  
012a			  
012a cd b9 0b				call clear_display  
012d			  
012d					; init primary frame buffer area  
012d 21 b1 ed				ld hl, display_fb0  
0130 22 cc eb				ld (display_fb_active), hl  
0133			  
0133 cd b9 0b				call clear_display  
0136			  
0136			  
0136 cd 56 5d				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0139			  
0139 cd 44 5e			call key_init  
013c cd 9e 01			call storage_init  
013f			  
013f				; setup malloc functions  
013f			  
013f				if MALLOC_1  
013f cd 9d 11				call  heap_init  
0142				endif  
0142				if MALLOC_4  
0142					call  heap_init  
0142				endif  
0142			  
0142				; init sound hardware if present  
0142			  
0142				if SOUND_ENABLE  
0142					call sound_init  
0142				endif  
0142			  
0142				; lcd test sequence  
0142					  
0142 cd dc 0b			call update_display  
0145 cd f1 0a			call delay1s  
0148 3e 2b			ld a,'+'  
014a cd be 0b			call fill_display  
014d cd dc 0b			call update_display  
0150 cd f1 0a			call delay1s  
0153 3e 2a			ld a,'*'  
0155 cd be 0b			call fill_display  
0158 cd dc 0b			call update_display  
015b cd f1 0a			call delay1s  
015e 3e 2d			ld a,'-'  
0160 cd be 0b			call fill_display  
0163 cd dc 0b			call update_display  
0166 cd f1 0a			call delay1s  
0169			  
0169			; boot splash screen  
0169			if display_cols == 20	  
0169			        ld a, display_row_1    
0169			else  
0169 3e 0a		        ld a, display_row_1 +10   
016b			endif  
016b 11 cb 16			ld de, prom_bootmsg  
016e cd cc 0b			call str_at_display  
0171 cd dc 0b			call update_display  
0174			  
0174			  
0174 cd f1 0a			call delay1s  
0177 cd f1 0a			call delay1s  
017a			if display_cols == 20	  
017a			            LD   A, display_row_3+2  
017a			else  
017a 3e 5c		            LD   A, display_row_3+12  
017c			endif  
017c 11 e0 16			ld de, prom_bootmsg1  
017f cd cc 0b			call str_at_display  
0182 cd dc 0b			call update_display  
0185 cd f1 0a			call delay1s  
0188 cd f1 0a			call delay1s  
018b			  
018b			;	ld a, display_row_4+3  
018b			;	ld de, bootmsg2  
018b			;	call str_at_display  
018b			;	call update_display  
018b			;	call delay1s  
018b			;	call delay1s  
018b			  
018b			; debug mark setup  
018b			  
018b 3e 5f		ld a, '_'  
018d 32 6b ee		ld (debug_mark),a  
0190 32 6c ee		ld (debug_mark+1),a  
0193 32 6d ee		ld (debug_mark+2),a  
0196 3e 00		ld a,0  
0198 32 6e ee		ld (debug_mark+3),a  
019b			  
019b c9					ret  
019c			  
019c			  
019c			;bootmsg2:	db "Firmware v0.1",0  
019c			  
019c			; a 4x20 lcd  
019c			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019c			  
019c			;if display_cols == 20  
019c			;	include "firmware_lcd_4x20.asm"  
019c			;endif  
019c			  
019c			;if display_cols == 40  
019c			;	include "firmware_lcd_4x40.asm"  
019c			;endif  
019c			  
019c			;  
019c			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019c			; TODO abstract the bit bang video out interface for dual display  
019c			; TODO wire video out to tx pin on rc2014 bus  
019c			  
019c			; must supply cin, and cin_wait for low level hardware abstraction   
019c			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019c			; test scancode  
019c			  
019c			;;;;;  
019c			;;;  
019c			; Moved out to mini and maxi versions  
019c			;  
019c			; include "firmware_key_4x4.asm"  
019c			; using existing 4 wire x 4 resistor array for input  
019c			;include "firmware_key_4x10.asm"  
019c			; need to mod the board for 5 rows due to resistor array  
019c			;include "firmware_key_5x10.asm"  
019c			  
019c			; storage hardware interface  
019c			  
019c			; use microchip serial eeprom for storage  
019c			  
019c			  
019c			if STORAGE_SE  
019c				include "firmware_spi.asm"  
019c				include "firmware_seeprom.asm"  
019c			else  
019c			   ; create some stubs for the labels  
019c c9			se_readbyte: ret  
019d c9			se_writebyte: ret  
019e c9			storage_init: ret  
019f			  
019f			endif  
019f			  
019f			; use cf card for storage - throwing timeout errors. Hardware or software?????  
019f			;include "firmware_cf.asm"  
019f			  
019f			; load up high level storage hardward abstractions  
019f			include "firmware_storage.asm"  
019f			 
019f			; persisent storage hardware abstraction layer  
019f			 
019f			 
019f			 
019f			; Block 0 on storage is a config state 
019f			 
019f			 
019f			 
019f			; TODO add read phy block and write phy block functions 
019f			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
019f			 
019f			; Abstraction layer  
019f			 
019f			; Logocial block size is same size as physical size - using tape concept 
019f			 
019f			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
019f			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
019f			 
019f			 
019f			 
019f			; Filesystem layout (Logical layout) 
019f			; 
019f			; Block 0 - Bank config  
019f			; 
019f			;      Byte - 0 file id counter 
019f			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
019f			;      Byte - 3-20 zero terminated bank label 
019f			; 
019f			; Block 1 > File storage 
019f			; 
019f			;      Byte 0 file id    - block 0 file details 
019f			;      Byte 1 block id - block 0 is file  
019f			;            Byte 2-15 - File name 
019f			; 
019f			;       - to end of block data 
019f			; 
019f			 
019f			; Get ID for the file named in pointer held HL 
019f			; Returns ID in HL = 255 if no file found 
019f			 
019f			storage_getid: 
019f			 
019f 22 73 ea			ld (store_tmp1), hl 
01a2			 
01a2				if DEBUG_STORESE 
01a2					DMARK "SGI" 
01a2 f5				push af  
01a3 3a b7 01			ld a, (.dmark)  
01a6 32 6b ee			ld (debug_mark),a  
01a9 3a b8 01			ld a, (.dmark+1)  
01ac 32 6c ee			ld (debug_mark+1),a  
01af 3a b9 01			ld a, (.dmark+2)  
01b2 32 6d ee			ld (debug_mark+2),a  
01b5 18 03			jr .pastdmark  
01b7 ..			.dmark: db "SGI"  
01ba f1			.pastdmark: pop af  
01bb			endm  
# End of macro DMARK
01bb					CALLMONITOR 
01bb cd 6f ee			call debug_vector  
01be				endm  
# End of macro CALLMONITOR
01be				endif 
01be				; get block 0 and set counter for number of files to scan 
01be			 
01be cd 29 03			call storage_get_block_0 
01c1			 
01c1 3a 7a ea			ld a, (store_page) 
01c4 47				ld b, a 
01c5			 
01c5				; get extent 0 of each file id 
01c5			 
01c5				if DEBUG_STORESE 
01c5					DMARK "SGc" 
01c5 f5				push af  
01c6 3a da 01			ld a, (.dmark)  
01c9 32 6b ee			ld (debug_mark),a  
01cc 3a db 01			ld a, (.dmark+1)  
01cf 32 6c ee			ld (debug_mark+1),a  
01d2 3a dc 01			ld a, (.dmark+2)  
01d5 32 6d ee			ld (debug_mark+2),a  
01d8 18 03			jr .pastdmark  
01da ..			.dmark: db "SGc"  
01dd f1			.pastdmark: pop af  
01de			endm  
# End of macro DMARK
01de					CALLMONITOR 
01de cd 6f ee			call debug_vector  
01e1				endm  
# End of macro CALLMONITOR
01e1				endif 
01e1 60			.getloop:	ld h, b 
01e2 2e 00				ld l, 0 
01e4 c5					push bc 
01e5			 
01e5 11 7a ea				ld de, store_page 
01e8				if DEBUG_STORESE 
01e8					DMARK "SGr" 
01e8 f5				push af  
01e9 3a fd 01			ld a, (.dmark)  
01ec 32 6b ee			ld (debug_mark),a  
01ef 3a fe 01			ld a, (.dmark+1)  
01f2 32 6c ee			ld (debug_mark+1),a  
01f5 3a ff 01			ld a, (.dmark+2)  
01f8 32 6d ee			ld (debug_mark+2),a  
01fb 18 03			jr .pastdmark  
01fd ..			.dmark: db "SGr"  
0200 f1			.pastdmark: pop af  
0201			endm  
# End of macro DMARK
0201					CALLMONITOR 
0201 cd 6f ee			call debug_vector  
0204				endm  
# End of macro CALLMONITOR
0204				endif 
0204 cd d1 07				call storage_read 
0207 cd 0f 0e				call ishlzero 
020a 28 2d				jr z, .gap 
020c					 
020c					; have a file name read. Is it one we want. 
020c			 
020c 2a 73 ea				ld hl, (store_tmp1) 
020f 11 7d ea				ld de, store_page+3   ; file name 
0212			 
0212				if DEBUG_STORESE 
0212					DMARK "SGc" 
0212 f5				push af  
0213 3a 27 02			ld a, (.dmark)  
0216 32 6b ee			ld (debug_mark),a  
0219 3a 28 02			ld a, (.dmark+1)  
021c 32 6c ee			ld (debug_mark+1),a  
021f 3a 29 02			ld a, (.dmark+2)  
0222 32 6d ee			ld (debug_mark+2),a  
0225 18 03			jr .pastdmark  
0227 ..			.dmark: db "SGc"  
022a f1			.pastdmark: pop af  
022b			endm  
# End of macro DMARK
022b					CALLMONITOR 
022b cd 6f ee			call debug_vector  
022e				endm  
# End of macro CALLMONITOR
022e				endif 
022e cd 84 11				call strcmp 
0231 20 06				jr nz, .gap   ; not this one 
0233			 
0233 c1				        pop bc 
0234			 
0234 26 00				ld h, 0 
0236 68					ld l, b 
0237 18 22				jr .getdone 
0239						 
0239			 
0239			 
0239			 
0239			.gap: 
0239				if DEBUG_STORESE 
0239					DMARK "SGg" 
0239 f5				push af  
023a 3a 4e 02			ld a, (.dmark)  
023d 32 6b ee			ld (debug_mark),a  
0240 3a 4f 02			ld a, (.dmark+1)  
0243 32 6c ee			ld (debug_mark+1),a  
0246 3a 50 02			ld a, (.dmark+2)  
0249 32 6d ee			ld (debug_mark+2),a  
024c 18 03			jr .pastdmark  
024e ..			.dmark: db "SGg"  
0251 f1			.pastdmark: pop af  
0252			endm  
# End of macro DMARK
0252					CALLMONITOR 
0252 cd 6f ee			call debug_vector  
0255				endm  
# End of macro CALLMONITOR
0255				endif 
0255			 
0255 c1					pop bc 
0256 10 89				djnz .getloop 
0258 21 ff 00				ld hl, 255 
025b			.getdone: 
025b			 
025b				if DEBUG_STORESE 
025b					DMARK "SGe" 
025b f5				push af  
025c 3a 70 02			ld a, (.dmark)  
025f 32 6b ee			ld (debug_mark),a  
0262 3a 71 02			ld a, (.dmark+1)  
0265 32 6c ee			ld (debug_mark+1),a  
0268 3a 72 02			ld a, (.dmark+2)  
026b 32 6d ee			ld (debug_mark+2),a  
026e 18 03			jr .pastdmark  
0270 ..			.dmark: db "SGe"  
0273 f1			.pastdmark: pop af  
0274			endm  
# End of macro DMARK
0274					CALLMONITOR 
0274 cd 6f ee			call debug_vector  
0277				endm  
# End of macro CALLMONITOR
0277				endif 
0277			 
0277 c9				ret 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			; Read Block 
0278			; ---------- 
0278			; 
0278			; With current bank 
0278			;  
0278			; Get block number to read 
0278			; Load physical blocks starting at start block into buffer 
0278			 
0278			; de points to buffer to use 
0278			; hl holds logical block number  
0278			 
0278			storage_read_block: 
0278			 
0278				; TODO bank selection 
0278			 
0278				; for each of the physical blocks read it into the buffer 
0278 06 40			ld b, STORE_BLOCK_PHY 
027a			 
027a				if DEBUG_STORESE 
027a d5					push de 
027b				endif 
027b				 
027b			.rl1:    
027b			 
027b				; read physical block at hl into de 
027b			        ; increment hl and de to next read position on exit 
027b			 
027b e5				push hl 
027c d5				push de	 
027d c5				push bc 
027e			;	if DEBUG_STORESE 
027e			;		push af 
027e			;		ld a, 'R' 
027e			;		ld (debug_mark),a 
027e			;		pop af 
027e			;		CALLMONITOR 
027e			;	endif 
027e cd 9c 01			call se_readbyte 
0281			;	if DEBUG_STORESE 
0281			;		ld a,(spi_portbyte) 
0281			;		ld l, a 
0281			;		push af 
0281			;		ld a, '1' 
0281			;		ld (debug_mark),a 
0281			;		pop af 
0281			;		CALLMONITOR 
0281			;	endif 
0281 c1				pop bc 
0282 d1				pop de 
0283 e1				pop hl 
0284 12				ld (de),a 
0285 23				inc hl 
0286 13				inc de 
0287			 
0287			;	if DEBUG_STORESE 
0287			;		push af 
0287			;		ld a, 'r' 
0287			;		ld (debug_mark),a 
0287			;		pop af 
0287			;		CALLMONITOR 
0287			;	endif 
0287			 
0287 10 f2			djnz .rl1 
0289			 
0289				if DEBUG_STORESE 
0289					DMARK "SRB" 
0289 f5				push af  
028a 3a 9e 02			ld a, (.dmark)  
028d 32 6b ee			ld (debug_mark),a  
0290 3a 9f 02			ld a, (.dmark+1)  
0293 32 6c ee			ld (debug_mark+1),a  
0296 3a a0 02			ld a, (.dmark+2)  
0299 32 6d ee			ld (debug_mark+2),a  
029c 18 03			jr .pastdmark  
029e ..			.dmark: db "SRB"  
02a1 f1			.pastdmark: pop af  
02a2			endm  
# End of macro DMARK
02a2 d1					pop de 
02a3			; 
02a3			;		push af 
02a3			;		ld a, 'R' 
02a3			;		ld (debug_mark),a 
02a3			;		pop af 
02a3					CALLMONITOR 
02a3 cd 6f ee			call debug_vector  
02a6				endm  
# End of macro CALLMONITOR
02a6				endif 
02a6 c9				ret	 
02a7				 
02a7			 
02a7			; File Size 
02a7			; --------- 
02a7			; 
02a7			;   hl file id 
02a7			; 
02a7			;  returns in hl the number of blocks 
02a7			 
02a7			storage_file_size: 
02a7 5d				ld e, l 
02a8 16 00			ld d, 0 
02aa 21 40 00			ld hl, STORE_BLOCK_PHY 
02ad					if DEBUG_FORTH_WORDS 
02ad						DMARK "SIZ" 
02ad f5				push af  
02ae 3a c2 02			ld a, (.dmark)  
02b1 32 6b ee			ld (debug_mark),a  
02b4 3a c3 02			ld a, (.dmark+1)  
02b7 32 6c ee			ld (debug_mark+1),a  
02ba 3a c4 02			ld a, (.dmark+2)  
02bd 32 6d ee			ld (debug_mark+2),a  
02c0 18 03			jr .pastdmark  
02c2 ..			.dmark: db "SIZ"  
02c5 f1			.pastdmark: pop af  
02c6			endm  
# End of macro DMARK
02c6						CALLMONITOR 
02c6 cd 6f ee			call debug_vector  
02c9				endm  
# End of macro CALLMONITOR
02c9					endif 
02c9 cd ab 05			call storage_findnextid 
02cc			 
02cc cd 0f 0e			call ishlzero 
02cf			;	ld a, l 
02cf			;	add h 
02cf			;	cp 0 
02cf c8				ret z			; block not found so EOF 
02d0			 
02d0 11 7a ea			ld de, store_page 
02d3 cd 78 02			call storage_read_block 
02d6			 
02d6 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
02d9 6f				ld l, a 
02da 26 00			ld h, 0 
02dc c9			 	ret 
02dd			 
02dd			 
02dd			; Write Block 
02dd			; ----------- 
02dd			; 
02dd			; With current bank 
02dd			;  
02dd			; Get block number to write 
02dd			; Write physical blocks starting at start block from buffer 
02dd			  
02dd			storage_write_block: 
02dd				; TODO bank selection 
02dd			 
02dd				; for each of the physical blocks read it into the buffer 
02dd 06 40			ld b, STORE_BLOCK_PHY 
02df			 
02df				if DEBUG_STORESE 
02df					DMARK "SWB" 
02df f5				push af  
02e0 3a f4 02			ld a, (.dmark)  
02e3 32 6b ee			ld (debug_mark),a  
02e6 3a f5 02			ld a, (.dmark+1)  
02e9 32 6c ee			ld (debug_mark+1),a  
02ec 3a f6 02			ld a, (.dmark+2)  
02ef 32 6d ee			ld (debug_mark+2),a  
02f2 18 03			jr .pastdmark  
02f4 ..			.dmark: db "SWB"  
02f7 f1			.pastdmark: pop af  
02f8			endm  
# End of macro DMARK
02f8			 
02f8					;push af 
02f8					;ld a, 'W' 
02f8					;ld (debug_mark),a 
02f8					;pop af 
02f8					CALLMONITOR 
02f8 cd 6f ee			call debug_vector  
02fb				endm  
# End of macro CALLMONITOR
02fb				endif 
02fb			 
02fb			; might not be working 
02fb			;	call se_writepage 
02fb			 
02fb			;	ret 
02fb			; 
02fb			 
02fb			 
02fb			 
02fb			.wl1:    
02fb			 
02fb				; read physical block at hl into de 
02fb			        ; increment hl and de to next read position on exit 
02fb			 
02fb e5				push hl 
02fc d5				push de	 
02fd c5				push bc 
02fe 1a				ld a,(de) 
02ff				;if DEBUG_STORESE 
02ff			;		push af 
02ff			;		ld a, 'W' 
02ff			;		ld (debug_mark),a 
02ff			;		pop af 
02ff			;		CALLMONITOR 
02ff			;	endif 
02ff cd 9d 01			call se_writebyte 
0302			;	call delay250ms 
0302 00				nop 
0303 00				nop 
0304 00				nop 
0305			;	if DEBUG_STORESE 
0305			;		push af 
0305			;		ld a, 'w' 
0305			;		ld (debug_mark),a 
0305			;		pop af 
0305			;		CALLMONITOR 
0305			;	endif 
0305 c1				pop bc 
0306 d1				pop de 
0307 e1				pop hl 
0308 23				inc hl 
0309 13				inc de 
030a			 
030a			 
030a 10 ef			djnz .wl1 
030c			 
030c				if DEBUG_STORESE 
030c					DMARK "SW2" 
030c f5				push af  
030d 3a 21 03			ld a, (.dmark)  
0310 32 6b ee			ld (debug_mark),a  
0313 3a 22 03			ld a, (.dmark+1)  
0316 32 6c ee			ld (debug_mark+1),a  
0319 3a 23 03			ld a, (.dmark+2)  
031c 32 6d ee			ld (debug_mark+2),a  
031f 18 03			jr .pastdmark  
0321 ..			.dmark: db "SW2"  
0324 f1			.pastdmark: pop af  
0325			endm  
# End of macro DMARK
0325			 
0325					;push af 
0325					;ld a, 'W' 
0325					;ld (debug_mark),a 
0325					;pop af 
0325					CALLMONITOR 
0325 cd 6f ee			call debug_vector  
0328				endm  
# End of macro CALLMONITOR
0328				endif 
0328 c9				ret	 
0329			 
0329			; Init bank 
0329			; --------- 
0329			; 
0329			; With current bank 
0329			; 
0329			; Setup block 0 config 
0329			;     Set 0 file id counter 
0329			;     Set formatted byte pattern 
0329			;     Zero out bank label 
0329			;      
0329			; For every logical block write 0-1 byte as null 
0329			 
0329			storage_get_block_0: 
0329			 
0329				; TODO check presence 
0329			 
0329				; get block 0 config 
0329			 
0329 21 00 00			ld hl, 0 
032c 11 7a ea			ld de, store_page 
032f cd 78 02			call storage_read_block 
0332			 
0332				if DEBUG_STORESE 
0332					DMARK "SB0" 
0332 f5				push af  
0333 3a 47 03			ld a, (.dmark)  
0336 32 6b ee			ld (debug_mark),a  
0339 3a 48 03			ld a, (.dmark+1)  
033c 32 6c ee			ld (debug_mark+1),a  
033f 3a 49 03			ld a, (.dmark+2)  
0342 32 6d ee			ld (debug_mark+2),a  
0345 18 03			jr .pastdmark  
0347 ..			.dmark: db "SB0"  
034a f1			.pastdmark: pop af  
034b			endm  
# End of macro DMARK
034b 11 7a ea				ld de, store_page 
034e			;		push af 
034e			;		ld a, 'i' 
034e			;		ld (debug_mark),a 
034e			;		pop af 
034e					CALLMONITOR 
034e cd 6f ee			call debug_vector  
0351				endm  
# End of macro CALLMONITOR
0351				endif 
0351			 
0351				; is this area formatted? 
0351			 
0351			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0351 2a 7b ea			ld hl, (store_page+1) 
0354 3e 80			ld a,0x80 
0356 bd				cp l 
0357 20 22			jr nz, .ininotformatted 
0359				; do a double check 
0359 3e 27			ld a, 0x27 
035b bc				cp h 
035c 20 1d			jr nz, .ininotformatted 
035e			 
035e				; formatted then 
035e			 
035e				if DEBUG_STORESE 
035e					DMARK "SB1" 
035e f5				push af  
035f 3a 73 03			ld a, (.dmark)  
0362 32 6b ee			ld (debug_mark),a  
0365 3a 74 03			ld a, (.dmark+1)  
0368 32 6c ee			ld (debug_mark+1),a  
036b 3a 75 03			ld a, (.dmark+2)  
036e 32 6d ee			ld (debug_mark+2),a  
0371 18 03			jr .pastdmark  
0373 ..			.dmark: db "SB1"  
0376 f1			.pastdmark: pop af  
0377			endm  
# End of macro DMARK
0377					;push af 
0377					;ld a, 'I' 
0377					;ld (debug_mark),a 
0377					;pop af 
0377					CALLMONITOR 
0377 cd 6f ee			call debug_vector  
037a				endm  
# End of macro CALLMONITOR
037a				endif 
037a c9				ret 
037b			 
037b			.ininotformatted: 
037b				; bank not formatted so poke various bits to make sure 
037b			 
037b				if DEBUG_STORESE 
037b					DMARK "SB2" 
037b f5				push af  
037c 3a 90 03			ld a, (.dmark)  
037f 32 6b ee			ld (debug_mark),a  
0382 3a 91 03			ld a, (.dmark+1)  
0385 32 6c ee			ld (debug_mark+1),a  
0388 3a 92 03			ld a, (.dmark+2)  
038b 32 6d ee			ld (debug_mark+2),a  
038e 18 03			jr .pastdmark  
0390 ..			.dmark: db "SB2"  
0393 f1			.pastdmark: pop af  
0394			endm  
# End of macro DMARK
0394					;push af 
0394					;ld a, 'f' 
0394					;ld (debug_mark),a 
0394					;pop af 
0394					CALLMONITOR 
0394 cd 6f ee			call debug_vector  
0397				endm  
# End of macro CALLMONITOR
0397				endif 
0397			 
0397 cd b4 0a			call storage_clear_page 
039a			 
039a 21 7a ea			ld hl, store_page 
039d 3e 00			ld a, 0 
039f				 
039f 77				ld (hl),a   ; reset file counter 
03a0			 
03a0 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a3 22 7b ea		 	ld (store_page+1), hl	 
03a6			 
03a6				; set default label 
03a6			 
03a6 21 42 04			ld hl, .defaultbanklabl 
03a9 11 7d ea		 	ld de, store_page+3 
03ac 01 0f 00			ld bc, 15 
03af ed b0			ldir 
03b1			 
03b1				; Append the current bank id 
03b1 21 86 ea			ld hl, store_page+3+9 
03b4 3a 5f ea			ld a, (spi_device_id) 
03b7 77				ld (hl), a 
03b8			 
03b8				; save default page 0 
03b8			 
03b8 21 00 00			ld hl, 0 
03bb 11 7a ea			ld de, store_page 
03be				if DEBUG_STORESE 
03be					DMARK "SB3" 
03be f5				push af  
03bf 3a d3 03			ld a, (.dmark)  
03c2 32 6b ee			ld (debug_mark),a  
03c5 3a d4 03			ld a, (.dmark+1)  
03c8 32 6c ee			ld (debug_mark+1),a  
03cb 3a d5 03			ld a, (.dmark+2)  
03ce 32 6d ee			ld (debug_mark+2),a  
03d1 18 03			jr .pastdmark  
03d3 ..			.dmark: db "SB3"  
03d6 f1			.pastdmark: pop af  
03d7			endm  
# End of macro DMARK
03d7			;		push af 
03d7			;		ld a, 'F' 
03d7			;		ld (debug_mark),a 
03d7			;		pop af 
03d7					CALLMONITOR 
03d7 cd 6f ee			call debug_vector  
03da				endm  
# End of macro CALLMONITOR
03da				endif 
03da cd dd 02			call storage_write_block 
03dd				if DEBUG_STORESE 
03dd					DMARK "SB4" 
03dd f5				push af  
03de 3a f2 03			ld a, (.dmark)  
03e1 32 6b ee			ld (debug_mark),a  
03e4 3a f3 03			ld a, (.dmark+1)  
03e7 32 6c ee			ld (debug_mark+1),a  
03ea 3a f4 03			ld a, (.dmark+2)  
03ed 32 6d ee			ld (debug_mark+2),a  
03f0 18 03			jr .pastdmark  
03f2 ..			.dmark: db "SB4"  
03f5 f1			.pastdmark: pop af  
03f6			endm  
# End of macro DMARK
03f6			;		push af 
03f6			;		ld a, '>' 
03f6			;		ld (debug_mark),a 
03f6			;		pop af 
03f6					CALLMONITOR 
03f6 cd 6f ee			call debug_vector  
03f9				endm  
# End of macro CALLMONITOR
03f9				endif 
03f9			 
03f9 00				nop 
03fa 00				nop 
03fb 00				nop 
03fc			 
03fc				; now set 0 in every page to mark as a free block 
03fc			 
03fc 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03fe 21 40 00			ld hl, STORE_BLOCK_PHY 
0401			 
0401 3e 00		.setmark1:   	ld a,0 
0403 e5					push hl 
0404 c5					push bc 
0405 cd 9d 01				call se_writebyte 
0408 3e 0a			ld a, 10 
040a cd d6 0a			call aDelayInMS 
040d 23				inc hl 
040e cd 9d 01				call se_writebyte 
0411 3e 0a			ld a, 10 
0413 cd d6 0a			call aDelayInMS 
0416 2b				dec hl 
0417 c1					pop bc 
0418 e1					pop hl 
0419 3e 40				ld a, STORE_BLOCK_PHY 
041b cd e6 0d				call addatohl 
041e 10 e1				djnz .setmark1 
0420			 
0420 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0422 3e 00		.setmark2:   	ld a,0 
0424 e5					push hl 
0425 c5					push bc 
0426 cd 9d 01				call se_writebyte 
0429 3e 0a			ld a, 10 
042b cd d6 0a			call aDelayInMS 
042e 23				inc hl 
042f cd 9d 01				call se_writebyte 
0432 3e 0a			ld a, 10 
0434 cd d6 0a			call aDelayInMS 
0437 2b				dec hl 
0438 c1					pop bc 
0439 e1					pop hl 
043a 3e 40				ld a, STORE_BLOCK_PHY 
043c cd e6 0d				call addatohl 
043f 10 e1				djnz .setmark2 
0441			 
0441					 
0441			 
0441			 
0441 c9				ret 
0442			 
0442			 
0442			 
0442			 
0442 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044d			 
044d			 
044d			 
044d			; Label Bank 
044d			; ---------- 
044d			; 
044d			; With current bank 
044d			; Read block 0 
044d			; Set label 
044d			; Write block 0 
044d			 
044d			; label str pointer in hl 
044d			 
044d			storage_label:     
044d			 
044d				if DEBUG_STORESE 
044d					DMARK "LBL" 
044d f5				push af  
044e 3a 62 04			ld a, (.dmark)  
0451 32 6b ee			ld (debug_mark),a  
0454 3a 63 04			ld a, (.dmark+1)  
0457 32 6c ee			ld (debug_mark+1),a  
045a 3a 64 04			ld a, (.dmark+2)  
045d 32 6d ee			ld (debug_mark+2),a  
0460 18 03			jr .pastdmark  
0462 ..			.dmark: db "LBL"  
0465 f1			.pastdmark: pop af  
0466			endm  
# End of macro DMARK
0466					CALLMONITOR 
0466 cd 6f ee			call debug_vector  
0469				endm  
# End of macro CALLMONITOR
0469				endif 
0469			 
0469 e5				push hl 
046a			 
046a cd 29 03			call storage_get_block_0 
046d			 
046d				; set default label 
046d			 
046d e1				pop hl 
046e			 
046e 11 7d ea		 	ld de, store_page+3 
0471 01 0f 00			ld bc, 15 
0474				if DEBUG_STORESE 
0474					DMARK "LB3" 
0474 f5				push af  
0475 3a 89 04			ld a, (.dmark)  
0478 32 6b ee			ld (debug_mark),a  
047b 3a 8a 04			ld a, (.dmark+1)  
047e 32 6c ee			ld (debug_mark+1),a  
0481 3a 8b 04			ld a, (.dmark+2)  
0484 32 6d ee			ld (debug_mark+2),a  
0487 18 03			jr .pastdmark  
0489 ..			.dmark: db "LB3"  
048c f1			.pastdmark: pop af  
048d			endm  
# End of macro DMARK
048d					CALLMONITOR 
048d cd 6f ee			call debug_vector  
0490				endm  
# End of macro CALLMONITOR
0490				endif 
0490 ed b0			ldir 
0492				; save default page 0 
0492			 
0492 21 00 00			ld hl, 0 
0495 11 7a ea			ld de, store_page 
0498				if DEBUG_STORESE 
0498					DMARK "LBW" 
0498 f5				push af  
0499 3a ad 04			ld a, (.dmark)  
049c 32 6b ee			ld (debug_mark),a  
049f 3a ae 04			ld a, (.dmark+1)  
04a2 32 6c ee			ld (debug_mark+1),a  
04a5 3a af 04			ld a, (.dmark+2)  
04a8 32 6d ee			ld (debug_mark+2),a  
04ab 18 03			jr .pastdmark  
04ad ..			.dmark: db "LBW"  
04b0 f1			.pastdmark: pop af  
04b1			endm  
# End of macro DMARK
04b1					CALLMONITOR 
04b1 cd 6f ee			call debug_vector  
04b4				endm  
# End of macro CALLMONITOR
04b4				endif 
04b4 cd dd 02			call storage_write_block 
04b7			 
04b7 c9				ret 
04b8			 
04b8			 
04b8			 
04b8			; Read Block 0 - Config 
04b8			; --------------------- 
04b8			; 
04b8			; With current bank 
04b8			; Call presence test 
04b8			;    If not present format/init bank  
04b8			; Read block 0  
04b8			;  
04b8			 
04b8			 
04b8			; Dir 
04b8			; --- 
04b8			; 
04b8			; With current bank 
04b8			; Load Block 0 Config 
04b8			; Get max file id number 
04b8			; For each logical block 
04b8			;    Read block read byte 2 
04b8			;      if first block of file 
04b8			;         Display file name 
04b8			;         Display type flags for file 
04b8			;        
04b8			 
04b8			; moving to words as this requires stack control 
04b8			 
04b8			 
04b8			; Delete File 
04b8			; ----------- 
04b8			; 
04b8			; With current bank 
04b8			; 
04b8			; Load Block 0 Config 
04b8			; Get max file id number 
04b8			; For each logical block 
04b8			;    Read block file id 
04b8			;      If first block of file and dont have file id 
04b8			;         if file to delete 
04b8			;         Save file id 
04b8			;         Null file id 
04b8			;         Write this block back 
04b8			;      If file id is one saved 
04b8			;         Null file id 
04b8			;         Write this block back 
04b8			 
04b8			 
04b8			.se_done: 
04b8 e1				pop hl 
04b9 c9				ret 
04ba			 
04ba			storage_erase: 
04ba			 
04ba				; hl contains the file id 
04ba			 
04ba 5d				ld e, l 
04bb 16 00			ld d, 0 
04bd 21 40 00			ld hl, STORE_BLOCK_PHY 
04c0					if DEBUG_FORTH_WORDS 
04c0						DMARK "ERA" 
04c0 f5				push af  
04c1 3a d5 04			ld a, (.dmark)  
04c4 32 6b ee			ld (debug_mark),a  
04c7 3a d6 04			ld a, (.dmark+1)  
04ca 32 6c ee			ld (debug_mark+1),a  
04cd 3a d7 04			ld a, (.dmark+2)  
04d0 32 6d ee			ld (debug_mark+2),a  
04d3 18 03			jr .pastdmark  
04d5 ..			.dmark: db "ERA"  
04d8 f1			.pastdmark: pop af  
04d9			endm  
# End of macro DMARK
04d9						CALLMONITOR 
04d9 cd 6f ee			call debug_vector  
04dc				endm  
# End of macro CALLMONITOR
04dc					endif 
04dc cd ab 05			call storage_findnextid 
04df cd 0f 0e			call ishlzero 
04e2 c8				ret z 
04e3			 
04e3 e5				push hl 
04e4			 
04e4				; TODO check file not found 
04e4			 
04e4 11 7a ea			ld de, store_page 
04e7 cd 78 02			call storage_read_block 
04ea			 
04ea cd 0f 0e			call ishlzero 
04ed ca b8 04			jp z,.se_done 
04f0			 
04f0					if DEBUG_FORTH_WORDS 
04f0						DMARK "ER1" 
04f0 f5				push af  
04f1 3a 05 05			ld a, (.dmark)  
04f4 32 6b ee			ld (debug_mark),a  
04f7 3a 06 05			ld a, (.dmark+1)  
04fa 32 6c ee			ld (debug_mark+1),a  
04fd 3a 07 05			ld a, (.dmark+2)  
0500 32 6d ee			ld (debug_mark+2),a  
0503 18 03			jr .pastdmark  
0505 ..			.dmark: db "ER1"  
0508 f1			.pastdmark: pop af  
0509			endm  
# End of macro DMARK
0509						CALLMONITOR 
0509 cd 6f ee			call debug_vector  
050c				endm  
# End of macro CALLMONITOR
050c					endif 
050c 3a 7a ea			ld a, (store_page)	; get file id 
050f 32 6e ea			ld (store_tmpid), a 
0512			 
0512 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
0515 32 6d ea			ld (store_tmpext), a 
0518			 
0518				; wipe file header 
0518			 
0518 e1				pop hl 
0519 3e 00			ld a, 0 
051b 32 7a ea			ld (store_page), a 
051e 32 7b ea			ld (store_page+1),a 
0521 11 7a ea			ld de, store_page 
0524					if DEBUG_FORTH_WORDS 
0524						DMARK "ER2" 
0524 f5				push af  
0525 3a 39 05			ld a, (.dmark)  
0528 32 6b ee			ld (debug_mark),a  
052b 3a 3a 05			ld a, (.dmark+1)  
052e 32 6c ee			ld (debug_mark+1),a  
0531 3a 3b 05			ld a, (.dmark+2)  
0534 32 6d ee			ld (debug_mark+2),a  
0537 18 03			jr .pastdmark  
0539 ..			.dmark: db "ER2"  
053c f1			.pastdmark: pop af  
053d			endm  
# End of macro DMARK
053d						CALLMONITOR 
053d cd 6f ee			call debug_vector  
0540				endm  
# End of macro CALLMONITOR
0540					endif 
0540 cd dd 02			call storage_write_block 
0543			 
0543			 
0543				; wipe file extents 
0543			 
0543 3a 6d ea			ld a, (store_tmpext) 
0546 47				ld b, a 
0547			 
0547			.eraext:	  
0547 c5				push bc 
0548			 
0548 21 40 00			ld hl, STORE_BLOCK_PHY 
054b 3a 6e ea			ld a,(store_tmpid) 
054e 5f				ld e, a 
054f 50				ld d, b	 
0550					if DEBUG_FORTH_WORDS 
0550						DMARK "ER3" 
0550 f5				push af  
0551 3a 65 05			ld a, (.dmark)  
0554 32 6b ee			ld (debug_mark),a  
0557 3a 66 05			ld a, (.dmark+1)  
055a 32 6c ee			ld (debug_mark+1),a  
055d 3a 67 05			ld a, (.dmark+2)  
0560 32 6d ee			ld (debug_mark+2),a  
0563 18 03			jr .pastdmark  
0565 ..			.dmark: db "ER3"  
0568 f1			.pastdmark: pop af  
0569			endm  
# End of macro DMARK
0569						CALLMONITOR 
0569 cd 6f ee			call debug_vector  
056c				endm  
# End of macro CALLMONITOR
056c					endif 
056c cd ab 05			call storage_findnextid 
056f cd 0f 0e			call ishlzero 
0572 ca b8 04			jp z,.se_done 
0575			 
0575 e5				push hl 
0576 11 7a ea			ld de, store_page 
0579 cd 78 02			call storage_read_block 
057c			 
057c				; free block	 
057c			 
057c 3e 00			ld a, 0 
057e 32 7a ea			ld (store_page), a 
0581 32 7b ea			ld (store_page+1),a 
0584 11 7a ea			ld de, store_page 
0587 e1				pop hl 
0588					if DEBUG_FORTH_WORDS 
0588						DMARK "ER4" 
0588 f5				push af  
0589 3a 9d 05			ld a, (.dmark)  
058c 32 6b ee			ld (debug_mark),a  
058f 3a 9e 05			ld a, (.dmark+1)  
0592 32 6c ee			ld (debug_mark+1),a  
0595 3a 9f 05			ld a, (.dmark+2)  
0598 32 6d ee			ld (debug_mark+2),a  
059b 18 03			jr .pastdmark  
059d ..			.dmark: db "ER4"  
05a0 f1			.pastdmark: pop af  
05a1			endm  
# End of macro DMARK
05a1						CALLMONITOR 
05a1 cd 6f ee			call debug_vector  
05a4				endm  
# End of macro CALLMONITOR
05a4					endif 
05a4 cd dd 02			call storage_write_block 
05a7			 
05a7 c1				pop bc 
05a8 10 9d			djnz .eraext 
05aa			 
05aa c9				ret 
05ab			 
05ab			 
05ab			; Find Free Block 
05ab			; --------------- 
05ab			; 
05ab			; With current bank 
05ab			;  
05ab			; From given starting logical block 
05ab			;    Read block  
05ab			;    If no file id 
05ab			;         Return block id 
05ab			 
05ab			 
05ab			; hl starting page number 
05ab			; hl contains free page number or zero if no pages free 
05ab			; e contains the file id to locate 
05ab			; d contains the block number 
05ab			 
05ab			; TODO change to find file id and use zero for free block 
05ab			 
05ab			storage_findnextid: 
05ab			 
05ab				; now locate first 0 page to mark as a free block 
05ab			 
05ab 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ad			;	ld hl, STORE_BLOCK_PHY 
05ad			 
05ad					if DEBUG_FORTH_WORDS 
05ad					DMARK "FNI" 
05ad f5				push af  
05ae 3a c2 05			ld a, (.dmark)  
05b1 32 6b ee			ld (debug_mark),a  
05b4 3a c3 05			ld a, (.dmark+1)  
05b7 32 6c ee			ld (debug_mark+1),a  
05ba 3a c4 05			ld a, (.dmark+2)  
05bd 32 6d ee			ld (debug_mark+2),a  
05c0 18 03			jr .pastdmark  
05c2 ..			.dmark: db "FNI"  
05c5 f1			.pastdmark: pop af  
05c6			endm  
# End of macro DMARK
05c6						CALLMONITOR 
05c6 cd 6f ee			call debug_vector  
05c9				endm  
# End of macro CALLMONITOR
05c9					endif 
05c9			.ff1:   	 
05c9 e5					push hl 
05ca c5					push bc 
05cb d5					push de 
05cc cd 9c 01				call se_readbyte 
05cf 5f					ld e,a 
05d0 23					inc hl 
05d1 cd 9c 01				call se_readbyte 
05d4 57					ld d, a 
05d5 e1					pop hl 
05d6 e5					push hl 
05d7 cd 04 0e				call cmp16 
05da 28 49				jr z, .fffound 
05dc			 
05dc d1					pop de 
05dd c1					pop bc 
05de e1					pop hl 
05df			 
05df					; is found? 
05df					;cp e 
05df					;ret z 
05df			 
05df 3e 40				ld a, STORE_BLOCK_PHY 
05e1 cd e6 0d				call addatohl 
05e4 10 e3				djnz .ff1 
05e6			 
05e6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e8			.ff2:   	 
05e8			 
05e8 e5					push hl 
05e9 c5					push bc 
05ea d5					push de 
05eb cd 9c 01				call se_readbyte 
05ee 5f					ld e,a 
05ef 23					inc hl 
05f0 cd 9c 01				call se_readbyte 
05f3 57					ld d, a 
05f4			 
05f4 e1					pop hl 
05f5 e5					push hl 
05f6 cd 04 0e				call cmp16 
05f9 28 2a				jr z, .fffound 
05fb			 
05fb d1					pop de 
05fc c1					pop bc 
05fd e1					pop hl 
05fe					; is found? 
05fe					;cp e 
05fe					;ret z 
05fe			 
05fe 3e 40				ld a, STORE_BLOCK_PHY 
0600 cd e6 0d				call addatohl 
0603 10 e3				djnz .ff2 
0605			 
0605			 
0605					if DEBUG_FORTH_WORDS 
0605					DMARK "FN-" 
0605 f5				push af  
0606 3a 1a 06			ld a, (.dmark)  
0609 32 6b ee			ld (debug_mark),a  
060c 3a 1b 06			ld a, (.dmark+1)  
060f 32 6c ee			ld (debug_mark+1),a  
0612 3a 1c 06			ld a, (.dmark+2)  
0615 32 6d ee			ld (debug_mark+2),a  
0618 18 03			jr .pastdmark  
061a ..			.dmark: db "FN-"  
061d f1			.pastdmark: pop af  
061e			endm  
# End of macro DMARK
061e					;	push af 
061e					;	ld a, 'n' 
061e					;	ld (debug_mark),a 
061e					;	pop af 
061e						CALLMONITOR 
061e cd 6f ee			call debug_vector  
0621				endm  
# End of macro CALLMONITOR
0621					endif 
0621				; no free marks! 
0621 21 00 00				ld hl, 0 
0624 c9				ret 
0625			.fffound: 
0625				 
0625			 
0625 d1					pop de 
0626 c1					pop bc 
0627 e1					pop hl 
0628					if DEBUG_FORTH_WORDS 
0628					DMARK "FNF" 
0628 f5				push af  
0629 3a 3d 06			ld a, (.dmark)  
062c 32 6b ee			ld (debug_mark),a  
062f 3a 3e 06			ld a, (.dmark+1)  
0632 32 6c ee			ld (debug_mark+1),a  
0635 3a 3f 06			ld a, (.dmark+2)  
0638 32 6d ee			ld (debug_mark+2),a  
063b 18 03			jr .pastdmark  
063d ..			.dmark: db "FNF"  
0640 f1			.pastdmark: pop af  
0641			endm  
# End of macro DMARK
0641					;	push af 
0641					;	ld a, 'n' 
0641					;	ld (debug_mark),a 
0641					;	pop af 
0641						CALLMONITOR 
0641 cd 6f ee			call debug_vector  
0644				endm  
# End of macro CALLMONITOR
0644					endif 
0644 c9				ret 
0645			 
0645			 
0645			 
0645			; Free Space 
0645			; ---------- 
0645			; 
0645			; With current bank 
0645			; 
0645			; Set block count to zero 
0645			; Starting with first logical block 
0645			;      Find free block  
0645			;      If block id given, increment block count 
0645			; 
0645			;  
0645			 
0645			 
0645			; hl contains count of free blocks 
0645			 
0645			storage_freeblocks: 
0645			 
0645				; now locate first 0 page to mark as a free block 
0645			 
0645 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0647 21 40 00			ld hl, STORE_BLOCK_PHY 
064a 11 00 00			ld de, 0 
064d			 
064d			.fb1:   	 
064d e5					push hl 
064e c5					push bc 
064f d5					push de 
0650 cd 9c 01				call se_readbyte 
0653 d1					pop de 
0654 c1					pop bc 
0655 e1					pop hl 
0656			 
0656					; is free? 
0656 fe 00				cp 0 
0658 20 01				jr nz, .ff1cont 
065a 13					inc de 
065b			 
065b			.ff1cont: 
065b			 
065b			 
065b 3e 40				ld a, STORE_BLOCK_PHY 
065d cd e6 0d				call addatohl 
0660 10 eb				djnz .fb1 
0662			 
0662 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0664			.fb2:   	 
0664 e5					push hl 
0665 c5					push bc 
0666 d5					push de 
0667 cd 9c 01				call se_readbyte 
066a d1					pop de 
066b c1					pop bc 
066c e1					pop hl 
066d			 
066d					; is free? 
066d fe 00				cp 0 
066f 20 01				jr nz, .ff2cont 
0671 13					inc de 
0672			 
0672			.ff2cont: 
0672			 
0672 3e 40				ld a, STORE_BLOCK_PHY 
0674 cd e6 0d				call addatohl 
0677 10 eb				djnz .fb2 
0679			 
0679 eb				ex de, hl 
067a c9				ret 
067b			 
067b			; Get File ID 
067b			; ----------- 
067b			; 
067b			; With current bank 
067b			;  
067b			; Load Block 0 Config 
067b			; Get max file id number 
067b			; For each logical block 
067b			;    Read block file id 
067b			;      If first block of file and dont have file id 
067b			;         if file get id and exit 
067b			 
067b			 
067b			 
067b			 
067b			; Create File 
067b			; ----------- 
067b			; 
067b			; With current bank  
067b			; Load Block 0 Config 
067b			; Get max file id number 
067b			; Increment file id number 
067b			; Save Config 
067b			; Find free block 
067b			; Set buffer with file name and file id 
067b			; Write buffer to free block  
067b			 
067b			 
067b			; hl point to file name 
067b			; hl returns file id 
067b			 
067b			; file format: 
067b			; byte 0 - file id 
067b			; byte 1 - extent number 
067b			; byte 2-> data 
067b			 
067b			; format for extent number 0: 
067b			; 
067b			; byte 0 - file id 
067b			; byte 1 - extent 0 
067b			; byte 2 - extent count 
067b			; byte 3 -> file name and meta data 
067b			 
067b			 
067b			storage_create: 
067b				if DEBUG_STORESE 
067b					DMARK "SCR" 
067b f5				push af  
067c 3a 90 06			ld a, (.dmark)  
067f 32 6b ee			ld (debug_mark),a  
0682 3a 91 06			ld a, (.dmark+1)  
0685 32 6c ee			ld (debug_mark+1),a  
0688 3a 92 06			ld a, (.dmark+2)  
068b 32 6d ee			ld (debug_mark+2),a  
068e 18 03			jr .pastdmark  
0690 ..			.dmark: db "SCR"  
0693 f1			.pastdmark: pop af  
0694			endm  
# End of macro DMARK
0694					CALLMONITOR 
0694 cd 6f ee			call debug_vector  
0697				endm  
# End of macro CALLMONITOR
0697				endif 
0697			 
0697 e5				push hl		; save file name pointer 
0698			 
0698 cd 29 03			call storage_get_block_0 
069b			 
069b 3a 7a ea			ld a,(store_page)	; get current file id 
069e 3c				inc a 
069f 32 7a ea			ld (store_page),a 
06a2				 
06a2 32 6e ea			ld (store_tmpid),a			; save id 
06a5			 
06a5 21 00 00			ld hl, 0 
06a8 11 7a ea			ld de, store_page 
06ab				if DEBUG_STORESE 
06ab					DMARK "SCw" 
06ab f5				push af  
06ac 3a c0 06			ld a, (.dmark)  
06af 32 6b ee			ld (debug_mark),a  
06b2 3a c1 06			ld a, (.dmark+1)  
06b5 32 6c ee			ld (debug_mark+1),a  
06b8 3a c2 06			ld a, (.dmark+2)  
06bb 32 6d ee			ld (debug_mark+2),a  
06be 18 03			jr .pastdmark  
06c0 ..			.dmark: db "SCw"  
06c3 f1			.pastdmark: pop af  
06c4			endm  
# End of macro DMARK
06c4					CALLMONITOR 
06c4 cd 6f ee			call debug_vector  
06c7				endm  
# End of macro CALLMONITOR
06c7				endif 
06c7 cd dd 02			call storage_write_block	 ; save update 
06ca			 
06ca				if DEBUG_STORESE 
06ca 11 7a ea				ld de, store_page 
06cd					DMARK "SCC" 
06cd f5				push af  
06ce 3a e2 06			ld a, (.dmark)  
06d1 32 6b ee			ld (debug_mark),a  
06d4 3a e3 06			ld a, (.dmark+1)  
06d7 32 6c ee			ld (debug_mark+1),a  
06da 3a e4 06			ld a, (.dmark+2)  
06dd 32 6d ee			ld (debug_mark+2),a  
06e0 18 03			jr .pastdmark  
06e2 ..			.dmark: db "SCC"  
06e5 f1			.pastdmark: pop af  
06e6			endm  
# End of macro DMARK
06e6					CALLMONITOR 
06e6 cd 6f ee			call debug_vector  
06e9				endm  
# End of macro CALLMONITOR
06e9				endif 
06e9				;  
06e9				 
06e9 21 40 00			ld hl, STORE_BLOCK_PHY 
06ec 11 00 00			ld de, 0 
06ef cd ab 05			call storage_findnextid 
06f2			 
06f2 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
06f5			 
06f5				; TODO detect 0 = no spare blocks 
06f5			 
06f5				; hl now contains the free page to use for the file header page 
06f5			 
06f5				if DEBUG_STORESE 
06f5				DMARK "SCF" 
06f5 f5				push af  
06f6 3a 0a 07			ld a, (.dmark)  
06f9 32 6b ee			ld (debug_mark),a  
06fc 3a 0b 07			ld a, (.dmark+1)  
06ff 32 6c ee			ld (debug_mark+1),a  
0702 3a 0c 07			ld a, (.dmark+2)  
0705 32 6d ee			ld (debug_mark+2),a  
0708 18 03			jr .pastdmark  
070a ..			.dmark: db "SCF"  
070d f1			.pastdmark: pop af  
070e			endm  
# End of macro DMARK
070e					CALLMONITOR 
070e cd 6f ee			call debug_vector  
0711				endm  
# End of macro CALLMONITOR
0711				endif 
0711			 
0711 22 65 ea			ld (store_tmppageid), hl 
0714				 
0714 3a 6e ea			ld a,(store_tmpid)    ; get file id 
0717			;	ld a, (store_filecache)			; save to cache 
0717			 
0717 32 7a ea			ld (store_page),a    ; set page id 
071a 3e 00			ld a, 0			 ; extent 0 is file header 
071c 32 7b ea			ld (store_page+1), a   ; set file extent 
071f			 
071f 32 7c ea			ld (store_page+2), a   ; extent count for the file 
0722			 
0722			;	inc hl 		; init block 0 of file 
0722			;	inc hl   		; skip file and extent id 
0722			 ;       ld a, 0 
0722			;	ld (hl),a 
0722			;	ld a, (store_filecache+1)  	; save to cache 
0722			 
0722			;	inc hl    ; file name 
0722				 
0722				 
0722 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0725				if DEBUG_STORESE 
0725					DMARK "SCc" 
0725 f5				push af  
0726 3a 3a 07			ld a, (.dmark)  
0729 32 6b ee			ld (debug_mark),a  
072c 3a 3b 07			ld a, (.dmark+1)  
072f 32 6c ee			ld (debug_mark+1),a  
0732 3a 3c 07			ld a, (.dmark+2)  
0735 32 6d ee			ld (debug_mark+2),a  
0738 18 03			jr .pastdmark  
073a ..			.dmark: db "SCc"  
073d f1			.pastdmark: pop af  
073e			endm  
# End of macro DMARK
073e					CALLMONITOR 
073e cd 6f ee			call debug_vector  
0741				endm  
# End of macro CALLMONITOR
0741				endif 
0741 e1				pop hl    ; get zero term string 
0742 e5				push hl 
0743 3e 00			ld a, 0 
0745 cd 57 11			call strlent 
0748 23				inc hl   ; cover zero term 
0749 06 00			ld b,0 
074b 4d				ld c,l 
074c e1				pop hl 
074d				;ex de, hl 
074d				if DEBUG_STORESE 
074d					DMARK "SCa" 
074d f5				push af  
074e 3a 62 07			ld a, (.dmark)  
0751 32 6b ee			ld (debug_mark),a  
0754 3a 63 07			ld a, (.dmark+1)  
0757 32 6c ee			ld (debug_mark+1),a  
075a 3a 64 07			ld a, (.dmark+2)  
075d 32 6d ee			ld (debug_mark+2),a  
0760 18 03			jr .pastdmark  
0762 ..			.dmark: db "SCa"  
0765 f1			.pastdmark: pop af  
0766			endm  
# End of macro DMARK
0766					;push af 
0766					;ld a, 'a' 
0766					;ld (debug_mark),a 
0766					;pop af 
0766					CALLMONITOR 
0766 cd 6f ee			call debug_vector  
0769				endm  
# End of macro CALLMONITOR
0769				endif 
0769 ed b0			ldir    ; copy zero term string 
076b				if DEBUG_STORESE 
076b					DMARK "SCA" 
076b f5				push af  
076c 3a 80 07			ld a, (.dmark)  
076f 32 6b ee			ld (debug_mark),a  
0772 3a 81 07			ld a, (.dmark+1)  
0775 32 6c ee			ld (debug_mark+1),a  
0778 3a 82 07			ld a, (.dmark+2)  
077b 32 6d ee			ld (debug_mark+2),a  
077e 18 03			jr .pastdmark  
0780 ..			.dmark: db "SCA"  
0783 f1			.pastdmark: pop af  
0784			endm  
# End of macro DMARK
0784					CALLMONITOR 
0784 cd 6f ee			call debug_vector  
0787				endm  
# End of macro CALLMONITOR
0787				endif 
0787			 
0787				; write file header page 
0787			 
0787 2a 65 ea			ld hl,(store_tmppageid) 
078a 11 7a ea			ld de, store_page 
078d				if DEBUG_STORESE 
078d					DMARK "SCb" 
078d f5				push af  
078e 3a a2 07			ld a, (.dmark)  
0791 32 6b ee			ld (debug_mark),a  
0794 3a a3 07			ld a, (.dmark+1)  
0797 32 6c ee			ld (debug_mark+1),a  
079a 3a a4 07			ld a, (.dmark+2)  
079d 32 6d ee			ld (debug_mark+2),a  
07a0 18 03			jr .pastdmark  
07a2 ..			.dmark: db "SCb"  
07a5 f1			.pastdmark: pop af  
07a6			endm  
# End of macro DMARK
07a6					;push af 
07a6					;ld a, 'b' 
07a6					;ld (debug_mark),a 
07a6					;pop af 
07a6					CALLMONITOR 
07a6 cd 6f ee			call debug_vector  
07a9				endm  
# End of macro CALLMONITOR
07a9				endif 
07a9 cd dd 02			call storage_write_block 
07ac			 
07ac 3a 6e ea			ld a, (store_tmpid) 
07af 6f				ld l, a 
07b0 26 00			ld h,0 
07b2				if DEBUG_STORESE 
07b2					DMARK "SCz" 
07b2 f5				push af  
07b3 3a c7 07			ld a, (.dmark)  
07b6 32 6b ee			ld (debug_mark),a  
07b9 3a c8 07			ld a, (.dmark+1)  
07bc 32 6c ee			ld (debug_mark+1),a  
07bf 3a c9 07			ld a, (.dmark+2)  
07c2 32 6d ee			ld (debug_mark+2),a  
07c5 18 03			jr .pastdmark  
07c7 ..			.dmark: db "SCz"  
07ca f1			.pastdmark: pop af  
07cb			endm  
# End of macro DMARK
07cb					CALLMONITOR 
07cb cd 6f ee			call debug_vector  
07ce				endm  
# End of macro CALLMONITOR
07ce				endif 
07ce c9				ret 
07cf				 
07cf			 
07cf			 
07cf			; 
07cf			; Read File 
07cf			; 
07cf			; h - file id to locate 
07cf			; l - extent to locate 
07cf			; de - pointer to string to read into 
07cf			; 
07cf			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07cf			 
07cf			.sr_fail: 
07cf d1				pop de 
07d0 c9				ret 
07d1			 
07d1			storage_read: 
07d1			 
07d1			 
07d1 d5				push de 
07d2			 
07d2			; TODO BUG the above push is it popped before the RET Z? 
07d2			 
07d2			; TODO how to handle multiple part blocks 
07d2			 
07d2				; locate file extent to read 
07d2			 
07d2 5c				ld e, h 
07d3 55				ld d, l 
07d4			 
07d4			.srext: 
07d4 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
07d7 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07db			 
07db 21 40 00			ld hl, STORE_BLOCK_PHY 
07de				if DEBUG_STORESE 
07de					DMARK "sre" 
07de f5				push af  
07df 3a f3 07			ld a, (.dmark)  
07e2 32 6b ee			ld (debug_mark),a  
07e5 3a f4 07			ld a, (.dmark+1)  
07e8 32 6c ee			ld (debug_mark+1),a  
07eb 3a f5 07			ld a, (.dmark+2)  
07ee 32 6d ee			ld (debug_mark+2),a  
07f1 18 03			jr .pastdmark  
07f3 ..			.dmark: db "sre"  
07f6 f1			.pastdmark: pop af  
07f7			endm  
# End of macro DMARK
07f7					CALLMONITOR 
07f7 cd 6f ee			call debug_vector  
07fa				endm  
# End of macro CALLMONITOR
07fa				endif 
07fa cd ab 05			call storage_findnextid 
07fd			 
07fd				if DEBUG_STORESE 
07fd					DMARK "srf" 
07fd f5				push af  
07fe 3a 12 08			ld a, (.dmark)  
0801 32 6b ee			ld (debug_mark),a  
0804 3a 13 08			ld a, (.dmark+1)  
0807 32 6c ee			ld (debug_mark+1),a  
080a 3a 14 08			ld a, (.dmark+2)  
080d 32 6d ee			ld (debug_mark+2),a  
0810 18 03			jr .pastdmark  
0812 ..			.dmark: db "srf"  
0815 f1			.pastdmark: pop af  
0816			endm  
# End of macro DMARK
0816					CALLMONITOR 
0816 cd 6f ee			call debug_vector  
0819				endm  
# End of macro CALLMONITOR
0819				endif 
0819 cd 0f 0e			call ishlzero 
081c			;	ld a, l 
081c			;	add h 
081c			;	cp 0 
081c 28 b1			jr z,.sr_fail			; block not found so EOF 
081e			 
081e				; save current address for use by higher level words etc 
081e			 
081e 22 6b ea			ld (store_openaddr),hl 
0821			 
0821			 
0821				; hl contains page number to load 
0821 d1				pop de   ; get storage 
0822 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
0826 d5				push de 
0827				if DEBUG_STORESE 
0827					DMARK "srg" 
0827 f5				push af  
0828 3a 3c 08			ld a, (.dmark)  
082b 32 6b ee			ld (debug_mark),a  
082e 3a 3d 08			ld a, (.dmark+1)  
0831 32 6c ee			ld (debug_mark+1),a  
0834 3a 3e 08			ld a, (.dmark+2)  
0837 32 6d ee			ld (debug_mark+2),a  
083a 18 03			jr .pastdmark  
083c ..			.dmark: db "srg"  
083f f1			.pastdmark: pop af  
0840			endm  
# End of macro DMARK
0840					CALLMONITOR 
0840 cd 6f ee			call debug_vector  
0843				endm  
# End of macro CALLMONITOR
0843				endif 
0843 cd 78 02			call storage_read_block 
0846			 
0846				; if this a continuation read??? 
0846			 
0846 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0849			 
0849 3e 3f			ld a, STORE_BLOCK_PHY-1 
084b cd e6 0d			call addatohl 
084e 7e				ld a,(hl) 
084f fe 00			cp 0 
0851 28 02			jr z, .markiscont 
0853 3e ff			ld a, 255 
0855			 
0855			.markiscont: 
0855 32 6d ea			ld (store_readcont), a 
0858			 
0858				if DEBUG_STORESE 
0858					DMARK "srC" 
0858 f5				push af  
0859 3a 6d 08			ld a, (.dmark)  
085c 32 6b ee			ld (debug_mark),a  
085f 3a 6e 08			ld a, (.dmark+1)  
0862 32 6c ee			ld (debug_mark+1),a  
0865 3a 6f 08			ld a, (.dmark+2)  
0868 32 6d ee			ld (debug_mark+2),a  
086b 18 03			jr .pastdmark  
086d ..			.dmark: db "srC"  
0870 f1			.pastdmark: pop af  
0871			endm  
# End of macro DMARK
0871					CALLMONITOR 
0871 cd 6f ee			call debug_vector  
0874				endm  
# End of macro CALLMONITOR
0874				endif 
0874				; only short reads enabled 
0874			 
0874 3a 75 ea			ld a, (store_longread) 
0877 fe 00			cp 0 
0879 ca 46 09			jp z, .readdone 
087c			 
087c			; TODO if block has no zeros then need to read next block  
087c			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
087c			; check last byte of physical block. 
087c			; if not zero then the next block needs to be loaded 
087c			 
087c			 
087c 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
087f			 
087f 3e 3f			ld a, STORE_BLOCK_PHY-1 
0881 cd e6 0d			call addatohl 
0884				;dec hl 
0884 7e				ld a,(hl) 
0885				if DEBUG_STORESE 
0885					DMARK "sr?" 
0885 f5				push af  
0886 3a 9a 08			ld a, (.dmark)  
0889 32 6b ee			ld (debug_mark),a  
088c 3a 9b 08			ld a, (.dmark+1)  
088f 32 6c ee			ld (debug_mark+1),a  
0892 3a 9c 08			ld a, (.dmark+2)  
0895 32 6d ee			ld (debug_mark+2),a  
0898 18 03			jr .pastdmark  
089a ..			.dmark: db "sr?"  
089d f1			.pastdmark: pop af  
089e			endm  
# End of macro DMARK
089e					CALLMONITOR 
089e cd 6f ee			call debug_vector  
08a1				endm  
# End of macro CALLMONITOR
08a1				endif 
08a1 fe 00			cp 0 
08a3 ca 46 09			jp z, .readdone 
08a6			 
08a6				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a6			 
08a6 23				inc hl 
08a7			 
08a7 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08aa			 
08aa ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
08ae			 
08ae eb				ex de, hl 
08af			 
08af				; next ext 
08af			 
08af 23				inc hl 
08b0 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
08b3			 
08b3				if DEBUG_STORESE 
08b3					DMARK "sF2" 
08b3 f5				push af  
08b4 3a c8 08			ld a, (.dmark)  
08b7 32 6b ee			ld (debug_mark),a  
08ba 3a c9 08			ld a, (.dmark+1)  
08bd 32 6c ee			ld (debug_mark+1),a  
08c0 3a ca 08			ld a, (.dmark+2)  
08c3 32 6d ee			ld (debug_mark+2),a  
08c6 18 03			jr .pastdmark  
08c8 ..			.dmark: db "sF2"  
08cb f1			.pastdmark: pop af  
08cc			endm  
# End of macro DMARK
08cc					CALLMONITOR 
08cc cd 6f ee			call debug_vector  
08cf				endm  
# End of macro CALLMONITOR
08cf				endif 
08cf			 
08cf				; get and load block 
08cf			 
08cf cd ab 05			call storage_findnextid 
08d2			 
08d2				if DEBUG_STORESE 
08d2					DMARK "sf2" 
08d2 f5				push af  
08d3 3a e7 08			ld a, (.dmark)  
08d6 32 6b ee			ld (debug_mark),a  
08d9 3a e8 08			ld a, (.dmark+1)  
08dc 32 6c ee			ld (debug_mark+1),a  
08df 3a e9 08			ld a, (.dmark+2)  
08e2 32 6d ee			ld (debug_mark+2),a  
08e5 18 03			jr .pastdmark  
08e7 ..			.dmark: db "sf2"  
08ea f1			.pastdmark: pop af  
08eb			endm  
# End of macro DMARK
08eb					CALLMONITOR 
08eb cd 6f ee			call debug_vector  
08ee				endm  
# End of macro CALLMONITOR
08ee				endif 
08ee cd 0f 0e			call ishlzero 
08f1			;	ld a, l 
08f1			;	add h 
08f1			;	cp 0 
08f1 ca cf 07			jp z,.sr_fail			; block not found so EOF 
08f4				 
08f4				; save current address for use by higher level words etc 
08f4			 
08f4 22 6b ea			ld (store_openaddr),hl 
08f7			 
08f7 cd 78 02			call storage_read_block 
08fa			 
08fa				; on a continuation block, we now have the file id and ext in the middle of the block 
08fa				; we need to pull everything back  
08fa			 
08fa ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
08fe 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0901 23				inc hl 
0902 23				inc hl     ; skip id and ext 
0903 01 40 00			ld bc, STORE_BLOCK_PHY 
0906				if DEBUG_STORESE 
0906					DMARK "SR<" 
0906 f5				push af  
0907 3a 1b 09			ld a, (.dmark)  
090a 32 6b ee			ld (debug_mark),a  
090d 3a 1c 09			ld a, (.dmark+1)  
0910 32 6c ee			ld (debug_mark+1),a  
0913 3a 1d 09			ld a, (.dmark+2)  
0916 32 6d ee			ld (debug_mark+2),a  
0919 18 03			jr .pastdmark  
091b ..			.dmark: db "SR<"  
091e f1			.pastdmark: pop af  
091f			endm  
# End of macro DMARK
091f					CALLMONITOR 
091f cd 6f ee			call debug_vector  
0922				endm  
# End of macro CALLMONITOR
0922				endif 
0922 ed b0			ldir     ; copy data 
0924			 
0924				; move the pointer back and pretend we have a full buffer for next recheck 
0924			 
0924 1b				dec de 
0925 1b				dec de 
0926			 
0926			; TODO do pop below now short circuit loop????? 
0926 c1				pop bc     ; get rid of spare de on stack 
0927				if DEBUG_STORESE 
0927					DMARK "SR>" 
0927 f5				push af  
0928 3a 3c 09			ld a, (.dmark)  
092b 32 6b ee			ld (debug_mark),a  
092e 3a 3d 09			ld a, (.dmark+1)  
0931 32 6c ee			ld (debug_mark+1),a  
0934 3a 3e 09			ld a, (.dmark+2)  
0937 32 6d ee			ld (debug_mark+2),a  
093a 18 03			jr .pastdmark  
093c ..			.dmark: db "SR>"  
093f f1			.pastdmark: pop af  
0940			endm  
# End of macro DMARK
0940					CALLMONITOR 
0940 cd 6f ee			call debug_vector  
0943				endm  
# End of macro CALLMONITOR
0943				endif 
0943 c3 d4 07			jp .srext 
0946			 
0946			 
0946			 
0946			 
0946			 
0946			.readdone:		 
0946 e1				pop hl 		 ; return start of data to show as not EOF 
0947 23				inc hl   ; past file id 
0948 23				inc hl   ; past ext 
0949				if DEBUG_STORESE 
0949					DMARK "SRe" 
0949 f5				push af  
094a 3a 5e 09			ld a, (.dmark)  
094d 32 6b ee			ld (debug_mark),a  
0950 3a 5f 09			ld a, (.dmark+1)  
0953 32 6c ee			ld (debug_mark+1),a  
0956 3a 60 09			ld a, (.dmark+2)  
0959 32 6d ee			ld (debug_mark+2),a  
095c 18 03			jr .pastdmark  
095e ..			.dmark: db "SRe"  
0961 f1			.pastdmark: pop af  
0962			endm  
# End of macro DMARK
0962					CALLMONITOR 
0962 cd 6f ee			call debug_vector  
0965				endm  
# End of macro CALLMONITOR
0965				endif 
0965 c9					ret 
0966			 
0966			 
0966			 
0966			; 
0966			; Append File 
0966			; 
0966			; hl - file id to locate 
0966			; de - pointer to (multi block) string to write 
0966			 
0966			.sa_notfound: 
0966 d1				pop de 
0967 c9				ret 
0968			 
0968			 
0968			storage_append: 
0968				; hl -  file id to append to 
0968				; de - string to append 
0968			 
0968 d5				push de 
0969				 
0969				if DEBUG_STORESE 
0969					DMARK "AP1" 
0969 f5				push af  
096a 3a 7e 09			ld a, (.dmark)  
096d 32 6b ee			ld (debug_mark),a  
0970 3a 7f 09			ld a, (.dmark+1)  
0973 32 6c ee			ld (debug_mark+1),a  
0976 3a 80 09			ld a, (.dmark+2)  
0979 32 6d ee			ld (debug_mark+2),a  
097c 18 03			jr .pastdmark  
097e ..			.dmark: db "AP1"  
0981 f1			.pastdmark: pop af  
0982			endm  
# End of macro DMARK
0982					CALLMONITOR 
0982 cd 6f ee			call debug_vector  
0985				endm  
# End of macro CALLMONITOR
0985				endif 
0985			 
0985 7d				ld a, l 
0986 32 6e ea			ld (store_tmpid), a 
0989			 
0989				; get file header  
0989			 
0989 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098b 3a 6e ea			ld a, (store_tmpid) 
098e 5f				ld e, a 
098f			 
098f 21 40 00				ld hl, STORE_BLOCK_PHY 
0992 cd ab 05				call storage_findnextid 
0995			 
0995 cd 0f 0e			call ishlzero 
0998 28 cc			jr z, .sa_notfound 
099a			 
099a 22 65 ea			ld (store_tmppageid), hl 
099d			 
099d				; TODO handle file id not found 
099d			 
099d				if DEBUG_STORESE 
099d					DMARK "AP2" 
099d f5				push af  
099e 3a b2 09			ld a, (.dmark)  
09a1 32 6b ee			ld (debug_mark),a  
09a4 3a b3 09			ld a, (.dmark+1)  
09a7 32 6c ee			ld (debug_mark+1),a  
09aa 3a b4 09			ld a, (.dmark+2)  
09ad 32 6d ee			ld (debug_mark+2),a  
09b0 18 03			jr .pastdmark  
09b2 ..			.dmark: db "AP2"  
09b5 f1			.pastdmark: pop af  
09b6			endm  
# End of macro DMARK
09b6					CALLMONITOR 
09b6 cd 6f ee			call debug_vector  
09b9				endm  
# End of macro CALLMONITOR
09b9				endif 
09b9			 
09b9				; update file extent count 
09b9			 
09b9 11 7a ea			ld de, store_page 
09bc			 
09bc cd 78 02			call storage_read_block 
09bf			 
09bf				if DEBUG_STORESE 
09bf					DMARK "AP3" 
09bf f5				push af  
09c0 3a d4 09			ld a, (.dmark)  
09c3 32 6b ee			ld (debug_mark),a  
09c6 3a d5 09			ld a, (.dmark+1)  
09c9 32 6c ee			ld (debug_mark+1),a  
09cc 3a d6 09			ld a, (.dmark+2)  
09cf 32 6d ee			ld (debug_mark+2),a  
09d2 18 03			jr .pastdmark  
09d4 ..			.dmark: db "AP3"  
09d7 f1			.pastdmark: pop af  
09d8			endm  
# End of macro DMARK
09d8					CALLMONITOR 
09d8 cd 6f ee			call debug_vector  
09db				endm  
# End of macro CALLMONITOR
09db				endif 
09db			;	ld (store_tmppageid), hl 
09db			 
09db 3a 7c ea			ld a, (store_page+2) 
09de 3c				inc a 
09df 32 7c ea			ld (store_page+2), a 
09e2 32 6d ea			ld (store_tmpext), a 
09e5				 
09e5				if DEBUG_STORESE 
09e5					DMARK "AP3" 
09e5 f5				push af  
09e6 3a fa 09			ld a, (.dmark)  
09e9 32 6b ee			ld (debug_mark),a  
09ec 3a fb 09			ld a, (.dmark+1)  
09ef 32 6c ee			ld (debug_mark+1),a  
09f2 3a fc 09			ld a, (.dmark+2)  
09f5 32 6d ee			ld (debug_mark+2),a  
09f8 18 03			jr .pastdmark  
09fa ..			.dmark: db "AP3"  
09fd f1			.pastdmark: pop af  
09fe			endm  
# End of macro DMARK
09fe					CALLMONITOR 
09fe cd 6f ee			call debug_vector  
0a01				endm  
# End of macro CALLMONITOR
0a01				endif 
0a01 2a 65 ea			ld hl, (store_tmppageid) 
0a04 11 7a ea			ld de, store_page 
0a07 cd dd 02			call storage_write_block 
0a0a			 
0a0a				; find free block 
0a0a			 
0a0a 11 00 00			ld de, 0			 ; file extent to locate 
0a0d			 
0a0d 21 40 00				ld hl, STORE_BLOCK_PHY 
0a10 cd ab 05				call storage_findnextid 
0a13 cd 0f 0e			call ishlzero 
0a16 ca 66 09			jp z, .sa_notfound 
0a19			 
0a19					; TODO handle no space left 
0a19					 
0a19 22 65 ea				ld (store_tmppageid), hl 
0a1c			 
0a1c				if DEBUG_STORESE 
0a1c					DMARK "AP4" 
0a1c f5				push af  
0a1d 3a 31 0a			ld a, (.dmark)  
0a20 32 6b ee			ld (debug_mark),a  
0a23 3a 32 0a			ld a, (.dmark+1)  
0a26 32 6c ee			ld (debug_mark+1),a  
0a29 3a 33 0a			ld a, (.dmark+2)  
0a2c 32 6d ee			ld (debug_mark+2),a  
0a2f 18 03			jr .pastdmark  
0a31 ..			.dmark: db "AP4"  
0a34 f1			.pastdmark: pop af  
0a35			endm  
# End of macro DMARK
0a35					CALLMONITOR 
0a35 cd 6f ee			call debug_vector  
0a38				endm  
# End of macro CALLMONITOR
0a38				endif 
0a38					; init the buffer with zeros so we can id if the buffer is full or not 
0a38			 
0a38 e5					push hl 
0a39 c5					push bc 
0a3a			 
0a3a 21 7a ea				ld hl, store_page 
0a3d 06 40				ld b, STORE_BLOCK_PHY 
0a3f 3e 00				ld a, 0 
0a41 77			.zeroblock:	ld (hl), a 
0a42 23					inc hl 
0a43 10 fc				djnz .zeroblock 
0a45			 
0a45 c1					pop bc 
0a46 e1					pop hl 
0a47			 
0a47					; construct block 
0a47			 
0a47 3a 6e ea				ld a, (store_tmpid) 
0a4a 32 7a ea				ld (store_page), a   ; file id 
0a4d 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
0a50 32 7b ea				ld (store_page+1), a 
0a53			 
0a53 e1					pop hl    ; get string to write 
0a54 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a56 11 7c ea				ld de, store_page+2 
0a59			 
0a59				if DEBUG_STORESE 
0a59					DMARK "AP5" 
0a59 f5				push af  
0a5a 3a 6e 0a			ld a, (.dmark)  
0a5d 32 6b ee			ld (debug_mark),a  
0a60 3a 6f 0a			ld a, (.dmark+1)  
0a63 32 6c ee			ld (debug_mark+1),a  
0a66 3a 70 0a			ld a, (.dmark+2)  
0a69 32 6d ee			ld (debug_mark+2),a  
0a6c 18 03			jr .pastdmark  
0a6e ..			.dmark: db "AP5"  
0a71 f1			.pastdmark: pop af  
0a72			endm  
# End of macro DMARK
0a72					CALLMONITOR 
0a72 cd 6f ee			call debug_vector  
0a75				endm  
# End of macro CALLMONITOR
0a75				endif 
0a75			 
0a75			 
0a75			 
0a75					; fill buffer with data until end of string or full block 
0a75			 
0a75 7e			.appd:		ld a, (hl) 
0a76 12					ld (de), a 
0a77 fe 00				cp 0 
0a79 28 04				jr z, .appdone 
0a7b 23					inc hl 
0a7c 13					inc de 
0a7d 10 f6				djnz .appd 
0a7f			 
0a7f e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a80 f5					push af   		; save last byte dumped 
0a81			 
0a81			 
0a81 2a 65 ea			ld hl, (store_tmppageid) 
0a84 11 7a ea			ld de, store_page 
0a87				if DEBUG_STORESE 
0a87					DMARK "AP6" 
0a87 f5				push af  
0a88 3a 9c 0a			ld a, (.dmark)  
0a8b 32 6b ee			ld (debug_mark),a  
0a8e 3a 9d 0a			ld a, (.dmark+1)  
0a91 32 6c ee			ld (debug_mark+1),a  
0a94 3a 9e 0a			ld a, (.dmark+2)  
0a97 32 6d ee			ld (debug_mark+2),a  
0a9a 18 03			jr .pastdmark  
0a9c ..			.dmark: db "AP6"  
0a9f f1			.pastdmark: pop af  
0aa0			endm  
# End of macro DMARK
0aa0					CALLMONITOR 
0aa0 cd 6f ee			call debug_vector  
0aa3				endm  
# End of macro CALLMONITOR
0aa3				endif 
0aa3 cd dd 02				call storage_write_block 
0aa6			 
0aa6			 
0aa6				; was that a full block of data written? 
0aa6				; any more to write out? 
0aa6			 
0aa6				; if yes then set vars and jump to start of function again 
0aa6			 
0aa6 f1					pop af 
0aa7 d1					pop de 
0aa8			 
0aa8 fe 00				cp 0		 ; no, string was fully written 
0aaa c8					ret z 
0aab			 
0aab					; setup vars for next cycle 
0aab			 
0aab 3a 6e ea				ld a, (store_tmpid) 
0aae 6f					ld l, a 
0aaf 26 00				ld h, 0 
0ab1			 
0ab1 c3 68 09			 	jp storage_append	 ; yes, need to write out some more 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			if DEBUG_STORECF 
0ab4			storageput:	 
0ab4					ret 
0ab4			storageread: 
0ab4					ld hl, store_page 
0ab4					ld b, 200 
0ab4					ld a,0 
0ab4			.src:		ld (hl),a 
0ab4					inc hl 
0ab4					djnz .src 
0ab4					 
0ab4			 
0ab4					ld de, 0 
0ab4					ld bc, 1 
0ab4					ld hl, store_page 
0ab4					call cfRead 
0ab4			 
0ab4				call cfGetError 
0ab4				ld hl,scratch 
0ab4				call hexout 
0ab4				ld hl, scratch+2 
0ab4				ld a, 0 
0ab4				ld (hl),a 
0ab4				ld de, scratch 
0ab4				ld a,display_row_1 
0ab4				call str_at_display 
0ab4				call update_display 
0ab4			 
0ab4					ld hl, store_page 
0ab4					ld (os_cur_ptr),hl 
0ab4			 
0ab4					ret 
0ab4			endif 
0ab4			 
0ab4			 
0ab4			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab4			 
0ab4			storage_clear_page: 
0ab4 e5				push hl 
0ab5 d5				push de 
0ab6 c5				push bc 
0ab7 21 7a ea			ld hl, store_page 
0aba 3e 00			ld a, 0 
0abc 77				ld (hl), a 
0abd			 
0abd 11 7b ea			ld de, store_page+1 
0ac0 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ac3			 
0ac3 ed b0			ldir 
0ac5				 
0ac5 c1				pop bc 
0ac6 d1				pop de 
0ac7 e1				pop hl 
0ac8 c9				ret 
0ac9			 
0ac9			; eof 
# End of file firmware_storage.asm
0ac9			  
0ac9			; support routines for above hardware abstraction layer  
0ac9			  
0ac9			include "firmware_general.asm"        ; general support functions  
0ac9			 
0ac9			; word look up 
0ac9			 
0ac9			; in 
0ac9			; a is the index 
0ac9			; hl is pointer start of array 
0ac9			; 
0ac9			; returns 
0ac9			; hl to the word 
0ac9			; 
0ac9			 
0ac9			table_lookup:  
0ac9 d5					push de 
0aca eb					ex de, hl 
0acb			 
0acb 6f					ld l, a 
0acc 26 00				ld h, 0 
0ace 29					add hl, hl 
0acf 19					add hl, de 
0ad0 7e					ld a, (hl) 
0ad1 23					inc hl 
0ad2 66					ld h,(hl) 
0ad3 6f					ld l, a 
0ad4			 
0ad4 d1					pop de 
0ad5 c9					ret 
0ad6			 
0ad6			; Delay loops 
0ad6			 
0ad6			 
0ad6			 
0ad6			aDelayInMS: 
0ad6 c5				push bc 
0ad7 47				ld b,a 
0ad8			msdelay: 
0ad8 c5				push bc 
0ad9				 
0ad9			 
0ad9 01 41 00			ld bc,041h 
0adc cd f4 0a			call delayloop 
0adf c1				pop bc 
0ae0 05				dec b 
0ae1 20 f5			jr nz,msdelay 
0ae3			 
0ae3			;if CPU_CLOCK_8MHZ 
0ae3			;msdelay8: 
0ae3			;	push bc 
0ae3			;	 
0ae3			; 
0ae3			;	ld bc,041h 
0ae3			;	call delayloop 
0ae3			;	pop bc 
0ae3			;	dec b 
0ae3			;	jr nz,msdelay8 
0ae3			;endif 
0ae3			 
0ae3			 
0ae3 c1				pop bc 
0ae4 c9				ret 
0ae5			 
0ae5			 
0ae5			delay250ms: 
0ae5				;push de 
0ae5 01 00 40			ld bc, 04000h 
0ae8 c3 f4 0a			jp delayloop 
0aeb			delay500ms: 
0aeb				;push de 
0aeb 01 00 80			ld bc, 08000h 
0aee c3 f4 0a			jp delayloop 
0af1			delay1s: 
0af1				;push bc 
0af1			   ; Clobbers A, d and e 
0af1 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af4			delayloop: 
0af4 c5			    push bc 
0af5			 
0af5			if BASE_CPM 
0af5 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af8			.cpmloop: 
0af8 c5				push bc 
0af9			 
0af9			endif 
0af9			 
0af9			 
0af9			 
0af9			delayloopi: 
0af9			;	push bc 
0af9			;.dl: 
0af9 cb 47		    bit     0,a    	; 8 
0afb cb 47		    bit     0,a    	; 8 
0afd cb 47		    bit     0,a    	; 8 
0aff e6 ff		    and     255  	; 7 
0b01 0b			    dec     bc      	; 6 
0b02 79			    ld      a,c     	; 4 
0b03 b0			    or      b     	; 4 
0b04 c2 f9 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b07			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b07				;pop de 
0b07			;pop bc 
0b07			 
0b07			if BASE_CPM 
0b07 c1				pop bc 
0b08				 
0b08 0b			    dec     bc      	; 6 
0b09 79			    ld      a,c     	; 4 
0b0a b0			    or      b     	; 4 
0b0b c2 f8 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0e				 
0b0e			 
0b0e			endif 
0b0e			;if CPU_CLOCK_8MHZ 
0b0e			;    pop bc 
0b0e			;    push bc 
0b0e			;.dl8: 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    and     255  	; 7 
0b0e			;    dec     bc      	; 6 
0b0e			;    ld      a,c     	; 4 
0b0e			;    or      b     	; 4 
0b0e			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0e			;endif 
0b0e			 
0b0e			;if CPU_CLOCK_10MHZ 
0b0e			;    pop bc 
0b0e			;    push bc 
0b0e			;.dl8: 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    and     255  	; 7 
0b0e			;    dec     bc      	; 6 
0b0e			;    ld      a,c     	; 4 
0b0e			;    or      b     	; 4 
0b0e			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0e			;endif 
0b0e c1			    pop bc 
0b0f			 
0b0f c9				ret 
0b10			 
0b10			 
0b10			 
0b10			; eof 
# End of file firmware_general.asm
0b10			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b10			; display routines that use the physical hardware abstraction layer 
0b10			 
0b10			 
0b10			; Display an activity indicator 
0b10			; Each call returns the new char pointed to in hl 
0b10			 
0b10			active: 
0b10 3a c6 eb			ld a, (display_active) 
0b13 fe 06			cp 6 
0b15			 
0b15 20 02			jr nz, .sne 
0b17				; gone past the last one reset sequence 
0b17 3e ff			ld a, 255 
0b19			 
0b19			.sne:   
0b19				; get the next char in seq 
0b19 3c				inc a 
0b1a 32 c6 eb			ld (display_active), a 
0b1d			 
0b1d				; look up the string in the table 
0b1d 21 34 0b			ld hl, actseq 
0b20 cb 27			sla a 
0b22 cd e6 0d			call addatohl 
0b25 cd 9c 1e			call loadwordinhl 
0b28			 
0b28				; forth will write the to string when pushing so move from rom to ram 
0b28			 
0b28 11 c7 eb			ld de, display_active+1 
0b2b 01 02 00			ld bc, 2 
0b2e ed b0			ldir 
0b30			 
0b30 21 c7 eb			ld hl, display_active+1 
0b33 c9				ret 
0b34				 
0b34				 
0b34			 
0b34			 
0b34			;db "|/-\|-\" 
0b34			 
0b34			actseq: 
0b34			 
0b34 42 0b		dw spin0 
0b36 44 0b		dw spin1 
0b38 46 0b		dw spin2 
0b3a 48 0b		dw spin3 
0b3c 46 0b		dw spin2 
0b3e 44 0b		dw spin1 
0b40 42 0b		dw spin0 
0b42			 
0b42 .. 00		spin0: db " ", 0 
0b44 .. 00		spin1: db "-", 0 
0b46 .. 00		spin2: db "+", 0 
0b48 .. 00		spin3: db "#", 0 
0b4a			 
0b4a			 
0b4a			; information window 
0b4a			 
0b4a			; pass hl with 1st string to display 
0b4a			; pass de with 2nd string to display 
0b4a			 
0b4a			info_panel: 
0b4a e5				push hl 
0b4b			 
0b4b 2a cc eb			ld hl, (display_fb_active) 
0b4e e5				push hl    ; future de destination 
0b4f 21 b1 ed				ld hl, display_fb0 
0b52 22 cc eb				ld (display_fb_active), hl 
0b55			 
0b55			;	call clear_display 
0b55			 
0b55				if BASE_CPM 
0b55 3e 2e			ld a, '.' 
0b57				else 
0b57				ld a, 165 
0b57				endif 
0b57 cd be 0b			call fill_display 
0b5a			 
0b5a			 
0b5a 3e 55			ld a, display_row_3 + 5 
0b5c cd cc 0b			call str_at_display 
0b5f			 
0b5f e1				pop hl 
0b60 d1				pop de 
0b61			 
0b61 e5				push hl 
0b62			 
0b62			 
0b62 3e 2d			ld a, display_row_2 + 5 
0b64 cd cc 0b			call str_at_display 
0b67			 
0b67			 
0b67 cd dc 0b			call update_display 
0b6a cd e5 1a			call next_page_prompt 
0b6d cd b9 0b			call clear_display 
0b70			 
0b70				 
0b70 21 10 ed				ld hl, display_fb1 
0b73 22 cc eb				ld (display_fb_active), hl 
0b76 cd dc 0b			call update_display 
0b79			 
0b79 e1				pop hl 
0b7a			 
0b7a c9				ret 
0b7b			 
0b7b			 
0b7b			 
0b7b			 
0b7b			; TODO windowing? 
0b7b			 
0b7b			; TODO scroll line up 
0b7b			 
0b7b			scroll_up: 
0b7b			 
0b7b e5				push hl 
0b7c d5				push de 
0b7d c5				push bc 
0b7e			 
0b7e				; get frame buffer  
0b7e			 
0b7e 2a cc eb			ld hl, (display_fb_active) 
0b81 e5				push hl    ; future de destination 
0b82			 
0b82 11 28 00			ld  de, display_cols 
0b85 19				add hl, de 
0b86			 
0b86 d1				pop de 
0b87			 
0b87				;ex de, hl 
0b87 01 9f 00			ld bc, display_fb_len -1  
0b8a			;if DEBUG_FORTH_WORDS 
0b8a			;	DMARK "SCL" 
0b8a			;	CALLMONITOR 
0b8a			;endif	 
0b8a ed b0			ldir 
0b8c			 
0b8c				; wipe bottom row 
0b8c			 
0b8c			 
0b8c 2a cc eb			ld hl, (display_fb_active) 
0b8f 11 a0 00			ld de, display_cols*display_rows 
0b92 19				add hl, de 
0b93 06 28			ld b, display_cols 
0b95 3e 20			ld a, ' ' 
0b97			.scwipe: 
0b97 77				ld (hl), a 
0b98 2b				dec hl 
0b99 10 fc			djnz .scwipe 
0b9b			 
0b9b				;pop hl 
0b9b			 
0b9b c1				pop bc 
0b9c d1				pop de 
0b9d e1				pop hl 
0b9e			 
0b9e c9				ret 
0b9f			 
0b9f			 
0b9f			;scroll_upo: 
0b9f			;	ld de, display_row_1 
0b9f			 ;	ld hl, display_row_2 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			;	ld de, display_row_2 
0b9f			 ;	ld hl, display_row_3 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			;	ld de, display_row_3 
0b9f			 ;	ld hl, display_row_4 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			 
0b9f			; TODO clear row 4 
0b9f			 
0b9f			;	ret 
0b9f			 
0b9f				 
0b9f			scroll_down: 
0b9f			 
0b9f e5				push hl 
0ba0 d5				push de 
0ba1 c5				push bc 
0ba2			 
0ba2				; get frame buffer  
0ba2			 
0ba2 2a cc eb			ld hl, (display_fb_active) 
0ba5			 
0ba5 11 9f 00			ld de, display_fb_len - 1 
0ba8 19				add hl, de 
0ba9			 
0ba9 e5			push hl    ; future de destination 
0baa			 
0baa 11 28 00			ld  de, display_cols 
0bad ed 52			sbc hl, de 
0baf			 
0baf			 
0baf d1				pop de 
0bb0			 
0bb0			;	ex de, hl 
0bb0 01 9f 00			ld bc, display_fb_len -1  
0bb3			 
0bb3			 
0bb3				 
0bb3			 
0bb3 ed b0			ldir 
0bb5			 
0bb5				; wipe bottom row 
0bb5			 
0bb5			 
0bb5			;	ld hl, (display_fb_active) 
0bb5			;;	ld de, display_cols*display_rows 
0bb5			;;	add hl, de 
0bb5			;	ld b, display_cols 
0bb5			;	ld a, ' ' 
0bb5			;.scwiped: 
0bb5			;	ld (hl), a 
0bb5			;	dec hl 
0bb5			;	djnz .scwiped 
0bb5			 
0bb5				;pop hl 
0bb5			 
0bb5 c1				pop bc 
0bb6 d1				pop de 
0bb7 e1				pop hl 
0bb8			 
0bb8 c9				ret 
0bb9			;scroll_down: 
0bb9			;	ld de, display_row_4 
0bb9			;	ld hl, display_row_3 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;	ld de, display_row_3 
0bb9			; 	ld hl, display_row_2 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;	ld de, display_row_2 
0bb9			;	ld hl, display_row_1 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;;; TODO clear row 1 
0bb9			;	ret 
0bb9			 
0bb9			 
0bb9			 
0bb9			 
0bb9			 
0bb9			; clear active frame buffer 
0bb9			 
0bb9			clear_display: 
0bb9 3e 20			ld a, ' ' 
0bbb c3 be 0b			jp fill_display 
0bbe			 
0bbe			; fill active frame buffer with a char in A 
0bbe			 
0bbe			fill_display: 
0bbe 06 a0			ld b,display_fb_len 
0bc0 2a cc eb			ld hl, (display_fb_active) 
0bc3 77			.fd1:	ld (hl),a 
0bc4 23				inc hl 
0bc5 10 fc			djnz .fd1 
0bc7 23				inc hl 
0bc8 3e 00			ld a,0 
0bca 77				ld (hl),a 
0bcb			 
0bcb			 
0bcb c9				ret 
0bcc			; Write string (DE) at pos (A) to active frame buffer 
0bcc			 
0bcc 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
0bcf 06 00					ld b,0 
0bd1 4f					ld c,a 
0bd2 09					add hl,bc 
0bd3 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bd4 b7			            OR   A              ;Null terminator? 
0bd5 c8			            RET  Z              ;Yes, so finished 
0bd6 77					ld (hl),a 
0bd7 23				inc hl 
0bd8 13			            INC  DE             ;Point to next character 
0bd9 18 f8		            JR   .sad1     ;Repeat 
0bdb c9					ret 
0bdc			 
0bdc			; using current frame buffer write to physical display 
0bdc			 
0bdc			update_display: 
0bdc e5				push hl 
0bdd 2a cc eb			ld hl, (display_fb_active) 
0be0 cd 93 5d			call write_display 
0be3 e1				pop hl 
0be4 c9				ret 
0be5			 
0be5			; TODO scrolling 
0be5			 
0be5			 
0be5			; move cursor right one char 
0be5			cursor_right: 
0be5			 
0be5				; TODO shift right 
0be5				; TODO if beyond max col 
0be5				; TODO       cursor_next_line 
0be5			 
0be5 c9				ret 
0be6			 
0be6			 
0be6			cursor_next_line: 
0be6				; TODO first char 
0be6				; TODO line down 
0be6				; TODO if past last row 
0be6				; TODO    scroll up 
0be6			 
0be6 c9				ret 
0be7			 
0be7			cursor_left: 
0be7				; TODO shift left 
0be7				; TODO if beyond left  
0be7				; TODO     cursor prev line 
0be7				 
0be7 c9				ret 
0be8			 
0be8			cursor_prev_line: 
0be8				; TODO last char 
0be8				; TODO line up 
0be8				; TODO if past first row 
0be8				; TODO   scroll down 
0be8			 
0be8 c9				ret 
0be9			 
0be9			 
0be9			cout: 
0be9				; A - char 
0be9 c9				ret 
0bea			 
0bea			 
0bea			; Display a menu and allow item selection (optional toggle items) 
0bea			; 
0bea			; format: 
0bea			; hl pointer to word array with zero term for items 
0bea			; e.g.    db item1 
0bea			;         db .... 
0bea			;         db 0 
0bea			; 
0bea			; a = starting menu item  
0bea			; 
0bea			; de = pointer item toggle array   (todo) 
0bea			; 
0bea			; returns item selected in a 1-... 
0bea			; returns 0 if back button pressed 
0bea			; 
0bea			; NOTE: Uses system frame buffer to display 
0bea			; 
0bea			; LEFT, Q = go back 
0bea			; RIGHT, SPACE, CR = select 
0bea			; UP, A - Up 
0bea			; DOWN, Z - Down 
0bea			 
0bea			 
0bea			 
0bea			 
0bea			 
0bea			menu: 
0bea			 
0bea					; keep array pointer 
0bea			 
0bea 22 73 ea				ld (store_tmp1), hl 
0bed 32 71 ea				ld (store_tmp2), a 
0bf0			 
0bf0					; check for key bounce 
0bf0			 
0bf0			if BASE_KEV 
0bf0			 
0bf0			.mbounce:	call cin 
0bf0					cp 0 
0bf0					jr nz, .mbounce 
0bf0			endif 
0bf0					; for ease use ex 
0bf0			 
0bf0					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bf0 21 b1 ed				ld hl, display_fb0 
0bf3 22 cc eb				ld (display_fb_active), hl 
0bf6			 
0bf6 cd b9 0b		.mloop:		call clear_display 
0bf9 cd dc 0b				call update_display 
0bfc			 
0bfc					; draw selection id '>' at 1 
0bfc			 
0bfc					; init start of list display 
0bfc			 
0bfc 3e 05				ld a, 5 
0bfe 32 6f ea				ld (store_tmp3), a   ; display row count 
0c01 3a 71 ea				ld a,( store_tmp2) 
0c04 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c07			 
0c07					 
0c07			.mitem:	 
0c07			 
0c07			 
0c07 3a 72 ea				ld a,(store_tmp2+1) 
0c0a 6f					ld l, a 
0c0b 26 00				ld h, 0 
0c0d 29					add hl, hl 
0c0e ed 5b 73 ea			ld de, (store_tmp1) 
0c12 19					add hl, de 
0c13 7e					ld a, (hl) 
0c14 23					inc hl 
0c15 66					ld h,(hl) 
0c16 6f					ld l, a 
0c17			 
0c17 cd 0f 0e				call ishlzero 
0c1a 28 1a				jr z, .mdone 
0c1c			 
0c1c eb					ex de, hl 
0c1d 3a 6f ea				ld a, (store_tmp3) 
0c20 cd cc 0b				call str_at_display 
0c23					 
0c23			 
0c23					; next item 
0c23 3a 72 ea				ld a, (store_tmp2+1) 
0c26 3c					inc a 
0c27 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c2a			 
0c2a			 		; next row 
0c2a			 
0c2a 3a 6f ea				ld a, (store_tmp3) 
0c2d c6 28				add display_cols 
0c2f 32 6f ea				ld (store_tmp3), a 
0c32			 
0c32					; at end of screen? 
0c32			 
0c32 fe 10				cp display_rows*4 
0c34 20 d1				jr nz, .mitem 
0c36			 
0c36			 
0c36			.mdone: 
0c36 cd 0f 0e				call ishlzero 
0c39 28 08				jr z, .nodn 
0c3b			 
0c3b 3e 78				ld a, display_row_4 
0c3d 11 bc 0c				ld de, .mdown 
0c40 cd cc 0b				call str_at_display 
0c43			 
0c43					; draw options to fill the screens with active item on line 1 
0c43					; if current option is 2 or more then display ^ in top 
0c43			 
0c43 3a 71 ea		.nodn:		ld a, (store_tmp2) 
0c46 fe 00				cp 0 
0c48 28 08				jr z, .noup 
0c4a			 
0c4a 3e 00				ld a, 0 
0c4c 11 ba 0c				ld de, .mup 
0c4f cd cc 0b				call str_at_display 
0c52			 
0c52 3e 02		.noup:		ld a, 2 
0c54 11 b8 0c				ld de, .msel 
0c57 cd cc 0b				call str_at_display 
0c5a			 
0c5a					; if current option + 1 is not null then display V in bottom 
0c5a					; get key 
0c5a cd dc 0b				call update_display 
0c5d			 
0c5d			 
0c5d					; handle key 
0c5d			 
0c5d cd 45 5e				call cin_wait 
0c60			 
0c60 fe 05				cp KEY_UP 
0c62 28 2b				jr z, .mgoup 
0c64 fe 61				cp 'a' 
0c66 28 27				jr z, .mgoup 
0c68 fe 0a				cp KEY_DOWN 
0c6a 28 32				jr z, .mgod 
0c6c fe 7a				cp 'z' 
0c6e 28 2e				jr z, .mgod 
0c70 fe 20				cp ' ' 
0c72 28 34				jr z, .goend 
0c74 fe 0c				cp KEY_RIGHT 
0c76 28 30				jr z, .goend 
0c78 fe 0d				cp KEY_CR 
0c7a 28 2c				jr z, .goend 
0c7c fe 71				cp 'q' 
0c7e 28 0b				jr z, .goback 
0c80			 
0c80 fe 0b				cp KEY_LEFT 
0c82 28 07				jr z, .goback 
0c84 fe 08				cp KEY_BS 
0c86 28 03				jr z, .goback 
0c88 c3 f6 0b				jp .mloop 
0c8b			 
0c8b			.goback: 
0c8b 3e 00			ld a, 0 
0c8d 18 1d			jr .goend2 
0c8f			 
0c8f				; move up one 
0c8f			.mgoup: 
0c8f 3a 71 ea				ld a, (store_tmp2) 
0c92 fe 00				cp 0 
0c94 ca f6 0b				jp z, .mloop 
0c97 3d					dec a 
0c98 32 71 ea				ld (store_tmp2), a 
0c9b c3 f6 0b				jp .mloop 
0c9e			 
0c9e				; move down one 
0c9e			.mgod: 
0c9e 3a 71 ea				ld a, (store_tmp2) 
0ca1 3c					inc a 
0ca2 32 71 ea				ld (store_tmp2), a 
0ca5 c3 f6 0b				jp .mloop 
0ca8			 
0ca8			 
0ca8			.goend: 
0ca8					; get selected item number 
0ca8			 
0ca8 3a 71 ea				ld a, (store_tmp2) 
0cab 3c					inc a 
0cac			 
0cac			.goend2: 
0cac f5					push af 
0cad			 
0cad					; restore active fb 
0cad					; TODO BUG assumes fb1 
0cad			 
0cad 21 10 ed				ld hl, display_fb1 
0cb0 22 cc eb				ld (display_fb_active), hl 
0cb3			 
0cb3					; restore main regs 
0cb3			 
0cb3			 
0cb3 cd dc 0b				call update_display 
0cb6			 
0cb6 f1					pop af 
0cb7			 
0cb7 c9				ret 
0cb8			 
0cb8 .. 00		.msel:   db ">",0 
0cba .. 00		.mup:   db "^",0 
0cbc .. 00		.mdown:   db "v",0 
0cbe			 
0cbe			 
0cbe			; eof 
0cbe			 
# End of file firmware_display.asm
0cbe			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cbe			; random number generators 
0cbe			 
0cbe			 
0cbe			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cbe			 
0cbe			 
0cbe			;-----> Generate a random number 
0cbe			; output a=answer 0<=a<=255 
0cbe			; all registers are preserved except: af 
0cbe			random: 
0cbe e5			        push    hl 
0cbf d5			        push    de 
0cc0 2a ab eb		        ld      hl,(randData) 
0cc3 ed 5f		        ld      a,r 
0cc5 57			        ld      d,a 
0cc6 5e			        ld      e,(hl) 
0cc7 19			        add     hl,de 
0cc8 85			        add     a,l 
0cc9 ac			        xor     h 
0cca 22 ab eb		        ld      (randData),hl 
0ccd d1			        pop     de 
0cce e1			        pop     hl 
0ccf c9			        ret 
0cd0			 
0cd0			 
0cd0			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cd0			 
0cd0			 
0cd0			 
0cd0			;------LFSR------ 
0cd0			;James Montelongo 
0cd0			;optimized by Spencer Putt 
0cd0			;out: 
0cd0			; a = 8 bit random number 
0cd0			RandLFSR: 
0cd0 21 b1 eb		        ld hl,LFSRSeed+4 
0cd3 5e			        ld e,(hl) 
0cd4 23			        inc hl 
0cd5 56			        ld d,(hl) 
0cd6 23			        inc hl 
0cd7 4e			        ld c,(hl) 
0cd8 23			        inc hl 
0cd9 7e			        ld a,(hl) 
0cda 47			        ld b,a 
0cdb cb 13		        rl e  
0cdd cb 12			rl d 
0cdf cb 11		        rl c  
0ce1 17				rla 
0ce2 cb 13		        rl e  
0ce4 cb 12			rl d 
0ce6 cb 11		        rl c  
0ce8 17				rla 
0ce9 cb 13		        rl e  
0ceb cb 12			rl d 
0ced cb 11		        rl c  
0cef 17				rla 
0cf0 67			        ld h,a 
0cf1 cb 13		        rl e  
0cf3 cb 12			rl d 
0cf5 cb 11		        rl c  
0cf7 17				rla 
0cf8 a8			        xor b 
0cf9 cb 13		        rl e  
0cfb cb 12			rl d 
0cfd ac			        xor h 
0cfe a9			        xor c 
0cff aa			        xor d 
0d00 21 b3 eb		        ld hl,LFSRSeed+6 
0d03 11 b4 eb		        ld de,LFSRSeed+7 
0d06 01 07 00		        ld bc,7 
0d09 ed b8		        lddr 
0d0b 12			        ld (de),a 
0d0c c9			        ret 
0d0d			 
0d0d			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d0d			 
0d0d			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d0d			 
0d0d			 
0d0d			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d0d			 
0d0d			prng16: 
0d0d			;Inputs: 
0d0d			;   (seed1) contains a 16-bit seed value 
0d0d			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d0d			;Outputs: 
0d0d			;   HL is the result 
0d0d			;   BC is the result of the LCG, so not that great of quality 
0d0d			;   DE is preserved 
0d0d			;Destroys: 
0d0d			;   AF 
0d0d			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d0d			;160cc 
0d0d			;26 bytes 
0d0d 2a a5 eb		    ld hl,(seed1) 
0d10 44			    ld b,h 
0d11 4d			    ld c,l 
0d12 29			    add hl,hl 
0d13 29			    add hl,hl 
0d14 2c			    inc l 
0d15 09			    add hl,bc 
0d16 22 a5 eb		    ld (seed1),hl 
0d19 2a a3 eb		    ld hl,(seed2) 
0d1c 29			    add hl,hl 
0d1d 9f			    sbc a,a 
0d1e e6 2d		    and %00101101 
0d20 ad			    xor l 
0d21 6f			    ld l,a 
0d22 22 a3 eb		    ld (seed2),hl 
0d25 09			    add hl,bc 
0d26 c9			    ret 
0d27			 
0d27			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d27			 
0d27			rand32: 
0d27			;Inputs: 
0d27			;   (seed1_0) holds the lower 16 bits of the first seed 
0d27			;   (seed1_1) holds the upper 16 bits of the first seed 
0d27			;   (seed2_0) holds the lower 16 bits of the second seed 
0d27			;   (seed2_1) holds the upper 16 bits of the second seed 
0d27			;   **NOTE: seed2 must be non-zero 
0d27			;Outputs: 
0d27			;   HL is the result 
0d27			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d27			;Destroys: 
0d27			;   AF 
0d27			;Tested and passes all CAcert tests 
0d27			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d27			;it has a period of 18,446,744,069,414,584,320 
0d27			;roughly 18.4 quintillion. 
0d27			;LFSR taps: 0,2,6,7  = 11000101 
0d27			;291cc 
0d27			;seed1_0=$+1 
0d27			;    ld hl,12345 
0d27			;seed1_1=$+1 
0d27			;    ld de,6789 
0d27			;    ld b,h 
0d27			;    ld c,l 
0d27			;    add hl,hl \ rl e \ rl d 
0d27			;    add hl,hl \ rl e \ rl d 
0d27			;    inc l 
0d27			;    add hl,bc 
0d27			;    ld (seed1_0),hl 
0d27			;    ld hl,(seed1_1) 
0d27			;    adc hl,de 
0d27			;    ld (seed1_1),hl 
0d27			;    ex de,hl 
0d27			;seed2_0=$+1 
0d27			;    ld hl,9876 
0d27			;seed2_1=$+1 
0d27			;    ld bc,54321 
0d27			;    add hl,hl \ rl c \ rl b 
0d27			;    ld (seed2_1),bc 
0d27			;    sbc a,a 
0d27			;    and %11000101 
0d27			;    xor l 
0d27			;    ld l,a 
0d27			;    ld (seed2_0),hl 
0d27			;    ex de,hl 
0d27			;    add hl,bc 
0d27			;    ret 
0d27			; 
0d27			 
0d27			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d27			; 20 bytes, 86 cycles (excluding ret) 
0d27			 
0d27			; returns   hl = pseudorandom number 
0d27			; corrupts   a 
0d27			 
0d27			; generates 16-bit pseudorandom numbers with a period of 65535 
0d27			; using the xorshift method: 
0d27			 
0d27			; hl ^= hl << 7 
0d27			; hl ^= hl >> 9 
0d27			; hl ^= hl << 8 
0d27			 
0d27			; some alternative shift triplets which also perform well are: 
0d27			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d27			 
0d27			;  org 32768 
0d27			 
0d27			xrnd: 
0d27 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
0d2a 3e 00		  ld a,0 
0d2c bd			  cp l 
0d2d 20 02		  jr nz, .xrnd1 
0d2f 2e 01		  ld l, 1 
0d31			.xrnd1: 
0d31			 
0d31 7c			  ld a,h 
0d32 1f			  rra 
0d33 7d			  ld a,l 
0d34 1f			  rra 
0d35 ac			  xor h 
0d36 67			  ld h,a 
0d37 7d			  ld a,l 
0d38 1f			  rra 
0d39 7c			  ld a,h 
0d3a 1f			  rra 
0d3b ad			  xor l 
0d3c 6f			  ld l,a 
0d3d ac			  xor h 
0d3e 67			  ld h,a 
0d3f			 
0d3f 22 a9 eb		  ld (xrandc),hl 
0d42			 
0d42 c9			  ret 
0d43			;  
0d43			 
0d43			 
0d43			;;;; int maths 
0d43			 
0d43			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d43			; Divide 16-bit values (with 16-bit result) 
0d43			; In: Divide BC by divider DE 
0d43			; Out: BC = result, HL = rest 
0d43			; 
0d43			Div16: 
0d43 21 00 00		    ld hl,0 
0d46 78			    ld a,b 
0d47 06 08		    ld b,8 
0d49			Div16_Loop1: 
0d49 17			    rla 
0d4a ed 6a		    adc hl,hl 
0d4c ed 52		    sbc hl,de 
0d4e 30 01		    jr nc,Div16_NoAdd1 
0d50 19			    add hl,de 
0d51			Div16_NoAdd1: 
0d51 10 f6		    djnz Div16_Loop1 
0d53 17			    rla 
0d54 2f			    cpl 
0d55 47			    ld b,a 
0d56 79			    ld a,c 
0d57 48			    ld c,b 
0d58 06 08		    ld b,8 
0d5a			Div16_Loop2: 
0d5a 17			    rla 
0d5b ed 6a		    adc hl,hl 
0d5d ed 52		    sbc hl,de 
0d5f 30 01		    jr nc,Div16_NoAdd2 
0d61 19			    add hl,de 
0d62			Div16_NoAdd2: 
0d62 10 f6		    djnz Div16_Loop2 
0d64 17			    rla 
0d65 2f			    cpl 
0d66 41			    ld b,c 
0d67 4f			    ld c,a 
0d68 c9			ret 
0d69			 
0d69			 
0d69			;http://z80-heaven.wikidot.com/math 
0d69			; 
0d69			;Inputs: 
0d69			;     DE and A are factors 
0d69			;Outputs: 
0d69			;     A is not changed 
0d69			;     B is 0 
0d69			;     C is not changed 
0d69			;     DE is not changed 
0d69			;     HL is the product 
0d69			;Time: 
0d69			;     342+6x 
0d69			; 
0d69			Mult16: 
0d69			 
0d69 06 08		     ld b,8          ;7           7 
0d6b 21 00 00		     ld hl,0         ;10         10 
0d6e 29			       add hl,hl     ;11*8       88 
0d6f 07			       rlca          ;4*8        32 
0d70 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d72 19			         add hl,de   ;--         -- 
0d73 10 f9		       djnz $-5      ;13*7+8     99 
0d75 c9			ret 
0d76			 
0d76			; 
0d76			; Square root of 16-bit value 
0d76			; In:  HL = value 
0d76			; Out:  D = result (rounded down) 
0d76			; 
0d76			;Sqr16: 
0d76			;    ld de,#0040 
0d76			;    ld a,l 
0d76			;    ld l,h 
0d76			;    ld h,d 
0d76			;    or a 
0d76			;    ld b,8 
0d76			;Sqr16_Loop: 
0d76			;    sbc hl,de 
0d76			;    jr nc,Sqr16_Skip 
0d76			;    add hl,de 
0d76			;Sqr16_Skip: 
0d76			;    ccf 
0d76			;    rl d 
0d76			;    add a,a 
0d76			;    adc hl,hl 
0d76			;    add a,a 
0d76			;    adc hl,hl 
0d76			;    djnz Sqr16_Loop 
0d76			;    ret 
0d76			; 
0d76			; 
0d76			; Divide 8-bit values 
0d76			; In: Divide E by divider C 
0d76			; Out: A = result, B = rest 
0d76			; 
0d76			Div8: 
0d76 af			    xor a 
0d77 06 08		    ld b,8 
0d79			Div8_Loop: 
0d79 cb 13		    rl e 
0d7b 17			    rla 
0d7c 91			    sub c 
0d7d 30 01		    jr nc,Div8_NoAdd 
0d7f 81			    add a,c 
0d80			Div8_NoAdd: 
0d80 10 f7		    djnz Div8_Loop 
0d82 47			    ld b,a 
0d83 7b			    ld a,e 
0d84 17			    rla 
0d85 2f			    cpl 
0d86 c9			    ret 
0d87			 
0d87			; 
0d87			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d87			; In: Multiply A with DE 
0d87			; Out: HL = result 
0d87			; 
0d87			Mult12U: 
0d87 2e 00		    ld l,0 
0d89 87			    add a,a 
0d8a 30 01		    jr nc,Mult12U_NoAdd0 
0d8c 19			    add hl,de 
0d8d			Mult12U_NoAdd0: 
0d8d 29			    add hl,hl 
0d8e 87			    add a,a 
0d8f 30 01		    jr nc,Mult12U_NoAdd1 
0d91 19			    add hl,de 
0d92			Mult12U_NoAdd1: 
0d92 29			    add hl,hl 
0d93 87			    add a,a 
0d94 30 01		    jr nc,Mult12U_NoAdd2 
0d96 19			    add hl,de 
0d97			Mult12U_NoAdd2: 
0d97 29			    add hl,hl 
0d98 87			    add a,a 
0d99 30 01		    jr nc,Mult12U_NoAdd3 
0d9b 19			    add hl,de 
0d9c			Mult12U_NoAdd3: 
0d9c 29			    add hl,hl 
0d9d 87			    add a,a 
0d9e 30 01		    jr nc,Mult12U_NoAdd4 
0da0 19			    add hl,de 
0da1			Mult12U_NoAdd4: 
0da1 29			    add hl,hl 
0da2 87			    add a,a 
0da3 30 01		    jr nc,Mult12U_NoAdd5 
0da5 19			    add hl,de 
0da6			Mult12U_NoAdd5: 
0da6 29			    add hl,hl 
0da7 87			    add a,a 
0da8 30 01		    jr nc,Mult12U_NoAdd6 
0daa 19			    add hl,de 
0dab			Mult12U_NoAdd6: 
0dab 29			    add hl,hl 
0dac 87			    add a,a 
0dad d0			    ret nc 
0dae 19			    add hl,de 
0daf c9			    ret 
0db0			 
0db0			; 
0db0			; Multiply 8-bit value with a 16-bit value (right rotating) 
0db0			; In: Multiply A with DE 
0db0			;      Put lowest value in A for most efficient calculation 
0db0			; Out: HL = result 
0db0			; 
0db0			Mult12R: 
0db0 21 00 00		    ld hl,0 
0db3			Mult12R_Loop: 
0db3 cb 3f		    srl a 
0db5 30 01		    jr nc,Mult12R_NoAdd 
0db7 19			    add hl,de 
0db8			Mult12R_NoAdd: 
0db8 cb 23		    sla e 
0dba cb 12		    rl d 
0dbc b7			    or a 
0dbd c2 b3 0d		    jp nz,Mult12R_Loop 
0dc0 c9			    ret 
0dc1			 
0dc1			; 
0dc1			; Multiply 16-bit values (with 32-bit result) 
0dc1			; In: Multiply BC with DE 
0dc1			; Out: BCHL = result 
0dc1			; 
0dc1			Mult32: 
0dc1 79			    ld a,c 
0dc2 48			    ld c,b 
0dc3 21 00 00		    ld hl,0 
0dc6 06 10		    ld b,16 
0dc8			Mult32_Loop: 
0dc8 29			    add hl,hl 
0dc9 17			    rla 
0dca cb 11		    rl c 
0dcc 30 07		    jr nc,Mult32_NoAdd 
0dce 19			    add hl,de 
0dcf ce 00		    adc a,0 
0dd1 d2 d5 0d		    jp nc,Mult32_NoAdd 
0dd4 0c			    inc c 
0dd5			Mult32_NoAdd: 
0dd5 10 f1		    djnz Mult32_Loop 
0dd7 41			    ld b,c 
0dd8 4f			    ld c,a 
0dd9 c9			    ret 
0dda			 
0dda			 
0dda			 
0dda			; 
0dda			; Multiply 8-bit values 
0dda			; In:  Multiply H with E 
0dda			; Out: HL = result 
0dda			; 
0dda			Mult8: 
0dda 16 00		    ld d,0 
0ddc 6a			    ld l,d 
0ddd 06 08		    ld b,8 
0ddf			Mult8_Loop: 
0ddf 29			    add hl,hl 
0de0 30 01		    jr nc,Mult8_NoAdd 
0de2 19			    add hl,de 
0de3			Mult8_NoAdd: 
0de3 10 fa		    djnz Mult8_Loop 
0de5 c9			    ret 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			;;http://z80-heaven.wikidot.com/math 
0de6			;;This divides DE by BC, storing the result in DE, remainder in HL 
0de6			; 
0de6			;DE_Div_BC:          ;1281-2x, x is at most 16 
0de6			;     ld a,16        ;7 
0de6			;     ld hl,0        ;10 
0de6			;     jp $+5         ;10 
0de6			;.DivLoop: 
0de6			;       add hl,bc    ;-- 
0de6			;       dec a        ;64 
0de6			;       jr z,.DivLoopEnd        ;86 
0de6			; 
0de6			;       sla e        ;128 
0de6			;       rl d         ;128 
0de6			;       adc hl,hl    ;240 
0de6			;       sbc hl,bc    ;240 
0de6			;       jr nc,.DivLoop ;23|21 
0de6			;       inc e        ;-- 
0de6			;       jp .DivLoop+1 
0de6			; 
0de6			;.DivLoopEnd: 
0de6			 
0de6			;HL_Div_C: 
0de6			;Inputs: 
0de6			;     HL is the numerator 
0de6			;     C is the denominator 
0de6			;Outputs: 
0de6			;     A is the remainder 
0de6			;     B is 0 
0de6			;     C is not changed 
0de6			;     DE is not changed 
0de6			;     HL is the quotient 
0de6			; 
0de6			;       ld b,16 
0de6			;       xor a 
0de6			;         add hl,hl 
0de6			;         rla 
0de6			;         cp c 
0de6			;         jr c,$+4 
0de6			;           inc l 
0de6			;           sub c 
0de6			;         djnz $-7 
0de6			 
0de6			; https://plutiedev.com/z80-add-8bit-to-16bit 
0de6			 
0de6			addatohl: 
0de6 85			    add   a, l    ; A = A+L 
0de7 6f			    ld    l, a    ; L = A+L 
0de8 8c			    adc   a, h    ; A = A+L+H+carry 
0de9 95			    sub   l       ; A = H+carry 
0dea 67			    ld    h, a    ; H = H+carry 
0deb c9			ret 
0dec			 
0dec			addatode: 
0dec 83			    add   a, e    ; A = A+L 
0ded 5f			    ld    e, a    ; L = A+L 
0dee 8a			    adc   a, d    ; A = A+L+H+carry 
0def 93			    sub   e       ; A = H+carry 
0df0 57			    ld    d, a    ; H = H+carry 
0df1 c9			ret 
0df2			 
0df2			 
0df2			addatobc: 
0df2 81			    add   a, c    ; A = A+L 
0df3 4f			    ld    c, a    ; L = A+L 
0df4 88			    adc   a, b    ; A = A+L+H+carry 
0df5 91			    sub   c       ; A = H+carry 
0df6 47			    ld    b, a    ; H = H+carry 
0df7 c9			ret 
0df8			 
0df8			subafromhl: 
0df8			   ; If A=0 do nothing 
0df8			    ; Otherwise flip A's sign. Since 
0df8			    ; the upper byte becomes -1, also 
0df8			    ; substract 1 from H. 
0df8 ed 44		    neg 
0dfa ca 03 0e		    jp    z, Skip 
0dfd 25			    dec   h 
0dfe			     
0dfe			    ; Now add the low byte as usual 
0dfe			    ; Two's complement takes care of 
0dfe			    ; ensuring the result is correct 
0dfe 85			    add   a, l 
0dff 6f			    ld    l, a 
0e00 8c			    adc   a, h 
0e01 95			    sub   l 
0e02 67			    ld    h, a 
0e03			Skip: 
0e03 c9				ret 
0e04			 
0e04			 
0e04			; compare hl and de 
0e04			; returns:  
0e04			; if hl = de, z=1, s=0, c0=0 
0e04			; if hl > de, z=0, s=0, c=0 
0e04			; if hl < de, z=0, s=1, c=1 
0e04			cmp16:	 
0e04 b7				or a 
0e05 ed 52			sbc hl,de 
0e07 e0				ret po 
0e08 7c				ld a,h 
0e09 1f				rra 
0e0a ee 40			xor 01000000B 
0e0c 37				scf 
0e0d 8f				adc a,a 
0e0e c9				ret 
0e0f			 
0e0f			 
0e0f			; test if hl contains zero   - A is destroyed 
0e0f			 
0e0f			ishlzero:    
0e0f b7				or a     ; reset flags 
0e10 7c				ld a, h 
0e11 b5				or l        	 
0e12			 
0e12 c9				ret 
0e13			 
0e13			 
0e13			 
0e13			 
0e13			if FORTH_ENABLE_FLOATMATH 
0e13			;include "float/bbcmath.z80" 
0e13			include "float/lpfpcalc.asm" 
0e13			endif 
0e13			 
0e13			 
0e13			; eof 
0e13			 
# End of file firmware_maths.asm
0e13			include "firmware_strings.asm"   ; string handling  
0e13			 
0e13			 
0e13			; TODO string len 
0e13			; input text string, end on cr with zero term 
0e13			; a offset into frame buffer to start prompt 
0e13			; d is max length 
0e13			; e is display size TODO 
0e13			; c is current cursor position 
0e13			; hl is ptr to where string will be stored and edited directly 
0e13			 
0e13			 
0e13			; TODO check limit of buffer for new inserts 
0e13			; TODO check insert does not push beyond buffer 
0e13			; TODO scroll in a limited display area 
0e13			; TODO scroll whole screen on page wrap 
0e13			 
0e13			 
0e13			; TODO use LCD cursor? 
0e13			 
0e13			EDIT_V1: equ 0 
0e13			EDIT_V2: equ 1 
0e13			 
0e13			 
0e13			 
0e13			if EDIT_V2 
0e13			input_str: 
0e13			 
0e13 32 64 ee			    	ld (input_at_pos),a      ; save display position to start 
0e16			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0e16 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
0e19			;		ld a, c 
0e19			;		call addatohl 
0e19			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
0e19 7a					ld a,d 
0e1a 32 66 ee			        ld (input_size), a       ; save length of input area 
0e1d 79					ld a, c 
0e1e 32 55 ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
0e21 7b					ld a,e 
0e22 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e25			 
0e25			 
0e25					; add a trailing space to make screen refresh nicer 
0e25			 
0e25					;ld hl, (input_start) 
0e25					;push hl 
0e25					;ld a, 0 
0e25					;call strlent 
0e25					;ld a, l 
0e25					;pop hl 
0e25					;call addatohl 
0e25					;dec hl 
0e25					;ld a, ' ' 
0e25					;ld (hl), a 
0e25					;inc hl 
0e25					;ld (hl), a 
0e25					;inc hl 
0e25					;ld a, 0 
0e25					;ld (hl), a 
0e25			 
0e25			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e25					; init cursor shape if not set by the cin routines 
0e25 21 c1 eb				ld hl, cursor_shape 
0e28			if BASE_KEV 
0e28					ld a, 255 
0e28			else 
0e28 3e 23				ld a, '#' 
0e2a			endif 
0e2a 77					ld (hl), a 
0e2b 23					inc hl 
0e2c 3e 00				ld a, 0 
0e2e 77					ld (hl), a 
0e2f			 
0e2f 3e 09				ld a, CUR_BLINK_RATE 
0e31 32 60 ee				ld (input_cur_flash), a 
0e34 3e 01				ld a, 1 
0e36 32 5f ee				ld (input_cur_onoff),a 
0e39			.inmain:	 
0e39			 
0e39 cd 61 0f				call input_disp_ref 
0e3c			 
0e3c					; save current length of string 
0e3c			 
0e3c 2a 67 ee				ld hl, (input_start) 
0e3f 3e 00				ld a, 0 
0e41 cd 57 11				call strlent 
0e44 7d					ld a,l 
0e45 32 5a ee				ld (input_len), a 
0e48			 
0e48					;call input_disp_oncur 
0e48			 
0e48					; display current state of input buffer 
0e48			 
0e48					; clean any backspace chars 
0e48			 
0e48 3e 20				ld a, " " 
0e4a 32 c1 e2				ld (scratch),a 
0e4d 3e 00				ld a, 0 
0e4f 32 c2 e2				ld (scratch+1),a 
0e52 3a 64 ee				ld a,(input_at_pos) 
0e55 85					add l 
0e56 11 c1 e2				ld de, scratch 
0e59 cd cc 0b				call str_at_display 
0e5c			 
0e5c					; pause 1ms 
0e5c			 
0e5c 3e 01				ld a, 1 
0e5e cd d6 0a				call aDelayInMS 
0e61			 
0e61			; display cursor if visible on this cycle 
0e61			 
0e61					; dec flash counter 
0e61 3a 60 ee				ld a, (input_cur_flash) 
0e64 3d					dec a 
0e65 32 60 ee				ld (input_cur_flash), a 
0e68 fe 00				cp 0 
0e6a 20 0d				jr nz, .inochgstate 
0e6c			 
0e6c			 
0e6c					; reset on change of state 
0e6c 3e 09				ld a, CUR_BLINK_RATE 
0e6e 32 60 ee				ld (input_cur_flash), a 
0e71			 
0e71					; change state 
0e71 3a 5f ee				ld a,(input_cur_onoff) 
0e74 ed 44				neg 
0e76 32 5f ee				ld (input_cur_onoff),a 
0e79			 
0e79			 
0e79			 
0e79			 
0e79					; TODO is cursor visible? 
0e79					; TODO if so then over write the char at curspos pos with the cursor shape 
0e79			 
0e79								 
0e79			 
0e79			.inochgstate: 
0e79 3a 5f ee				ld a,(input_cur_onoff) 
0e7c fe ff				cp 255 
0e7e 28 0e				jr z, .skipcursor 
0e80 3a 64 ee				ld a, (input_at_pos) 
0e83 47					ld b, a 
0e84 3a 55 ee				ld a, (input_cursor) 
0e87 80					add b 
0e88 11 c1 eb				ld de, cursor_shape 
0e8b					 
0e8b cd cc 0b				call str_at_display 
0e8e			 
0e8e			.skipcursor: 
0e8e				if DEBUG_INPUTV2 
0e8e			 
0e8e					ld a,(input_at_pos) 
0e8e					ld hl, LFSRSeed 
0e8e					call hexout 
0e8e					ld a, (input_cursor) 
0e8e					ld hl, LFSRSeed+2 
0e8e					call hexout 
0e8e					ld a,(input_size) 
0e8e					ld hl, LFSRSeed+4 
0e8e					call hexout 
0e8e			 
0e8e					ld a,(input_cur_onoff) 
0e8e					ld hl, LFSRSeed+6 
0e8e					call hexout 
0e8e			 
0e8e					ld a,(input_cur_flash) 
0e8e					ld hl, LFSRSeed+8 
0e8e					call hexout 
0e8e			 
0e8e					ld a,(input_len) 
0e8e					ld hl, LFSRSeed+10 
0e8e					call hexout 
0e8e					ld hl, LFSRSeed+12 
0e8e					ld a, 0 
0e8e					ld (hl),a 
0e8e					ld a, display_row_4 
0e8e					ld de, LFSRSeed 
0e8e					call str_at_display 
0e8e				endif 
0e8e cd dc 0b				call update_display 
0e91			 
0e91					; TODO keyboard processing 
0e91			 
0e91			if BASE_CPM 
0e91 cd 45 5e				call cin_wait 
0e94			else 
0e94					call cin    ; _wait 
0e94			endif 
0e94 fe 00				cp 0 
0e96 ca 39 0e				jp z, .inmain 
0e99			 
0e99 fe 0b				cp KEY_LEFT    ; cursor left 
0e9b ca 53 0f				jp z, input_left 
0e9e				 
0e9e fe 0c				cp KEY_RIGHT      ; cursor right 
0ea0 ca 5a 0f				jp z, input_right 
0ea3			 
0ea3 fe 0d				cp KEY_CR 
0ea5 c8					ret z 
0ea6			 
0ea6 fe 08				cp KEY_BS 
0ea8 ca c8 0f				jp z, input_delchar 
0eab			 
0eab fe 06				cp KEY_NEXTWORD 
0ead ca d4 0e				jp z, input_nxtword 
0eb0			 
0eb0 fe 07				cp KEY_PREVWORD 
0eb2 ca fb 0e				jp z, input_prvword 
0eb5			 
0eb5 fe 0e				cp KEY_HOME    ; jump to start of line 
0eb7 20 08				jr nz, .ikh 
0eb9 3e 00				ld a, 0 
0ebb 32 55 ee				ld (input_cursor), a 
0ebe ca 39 0e				jp z, .inmain 
0ec1			.ikh: 
0ec1			 
0ec1 fe 0f				cp KEY_END     ; jump to end of line 
0ec3 20 09				jr nz, .ike 
0ec5 3a 5a ee				ld a, (input_len) 
0ec8 32 55 ee				ld (input_cursor),a 
0ecb ca 39 0e				jp z, .inmain 
0ece			.ike: 
0ece fe 05			        cp KEY_UP      ; recall last command 
0ed0 c8					ret z 
0ed1			;jr nz, .irec 
0ed1			; TODO next word 
0ed1			; TODO prev word 
0ed1			;  
0ed1			; 
0ed1			;	ld hl, scratch 
0ed1			;	ld de, os_last_cmd 
0ed1			;	call strcpy 
0ed1			;		jp  .inmain 
0ed1			.irec: 
0ed1			;		jr .instr1 
0ed1			 
0ed1			 
0ed1			 
0ed1					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
0ed1			 
0ed1			; TODO return if any special keys are given 
0ed1			;		ld l, a 
0ed1			;		ld a, 28 ; KEY_F12   ; 27 
0ed1			;		sub l 
0ed1			;		ret m 
0ed1			;		ld a, l 
0ed1					; if no special key then insert as a char 
0ed1			 
0ed1 c3 9a 0f				jp input_inschr 
0ed4			 
0ed4				 
0ed4			input_nxtword: 
0ed4				; jump to start next word after the cursor 
0ed4			 
0ed4			.insknwn:	 
0ed4 cd 90 0f				call input_curptr	 
0ed7 7e					ld a,(hl)	 
0ed8 fe 00				cp 0 
0eda ca 39 0e				jp z, .inmain    ; end of string 
0edd			 
0edd			; if we are on a word, then move off of it 
0edd			 
0edd fe 20				cp ' ' 
0edf 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
0ee1 21 55 ee				ld hl, input_cursor 
0ee4 34					inc (hl) 
0ee5 18 ed				jr .insknwn 
0ee7			 
0ee7			.inspace: 
0ee7			 
0ee7 cd 90 0f				call input_curptr	 
0eea 7e					ld a,(hl)	 
0eeb fe 00				cp 0 
0eed ca 39 0e				jp z, .inmain    ; end of string 
0ef0			 
0ef0			; if we are on a word, then move off of it 
0ef0			 
0ef0 fe 20				cp ' ' 
0ef2 c2 39 0e				jp nz, .inmain     ; we are on non space so at next word 
0ef5 21 55 ee				ld hl, input_cursor 
0ef8 34					inc (hl) 
0ef9 18 ec				jr .inspace 
0efb			 
0efb			 
0efb			 
0efb			 
0efb			input_prvword: 
0efb				; jump to the start of previous word before the cursor 
0efb			 
0efb			; where are we to start with currently? 
0efb			 
0efb cd 90 0f				call input_curptr	 
0efe 7e					ld a, (hl) 
0eff fe 20				cp ' ' 
0f01 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
0f03			 
0f03			 
0f03			 
0f03			.inskpwn:	 
0f03 3a 55 ee				ld a,(input_cursor) 
0f06 fe 00				cp 0 
0f08 ca 39 0e				jp z, .inmain    ; start of string 
0f0b			 
0f0b			;if we are on a word, then move off of it 
0f0b			 
0f0b cd 90 0f				call input_curptr	 
0f0e 7e					ld a, (hl) 
0f0f fe 20				cp ' ' 
0f11 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
0f13					;jp z, .inmain    ; start of string 
0f13 21 55 ee				ld hl, input_cursor 
0f16 35					dec (hl) 
0f17 18 ea				jr .inskpwn 
0f19			.iwstart: 
0f19 21 55 ee				ld hl, input_cursor 
0f1c 34					inc (hl) 
0f1d c3 39 0e				jp .inmain 
0f20					 
0f20			 
0f20			.inspacep: 
0f20			 
0f20					;jp .inmain    ; start of string 
0f20			 
0f20			 
0f20			 
0f20 3a 55 ee				ld a,(input_cursor) 
0f23 fe 00				cp 0 
0f25 ca 39 0e				jp z, .inmain    ; start of string 
0f28			 
0f28			; if we are on a word, then move off of it 
0f28			 
0f28 cd 90 0f				call input_curptr	 
0f2b 7e					ld a, (hl) 
0f2c fe 20				cp ' ' 
0f2e c2 37 0f				jp nz, .incharp     ; we are on non space so at end of prev word 
0f31 21 55 ee				ld hl, input_cursor 
0f34 35					dec (hl) 
0f35 18 e9				jr .inspacep 
0f37			 
0f37			 
0f37			.incharp:	 
0f37					; eat the word to get to the start 
0f37 3a 55 ee				ld a,(input_cursor) 
0f3a fe 00				cp 0 
0f3c ca 39 0e				jp z, .inmain    ; start of string 
0f3f			 
0f3f			; if we are on a word, then move off of it 
0f3f			 
0f3f cd 90 0f				call input_curptr	 
0f42 7e					ld a, (hl) 
0f43 fe 20				cp ' ' 
0f45 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
0f47 21 55 ee				ld hl, input_cursor 
0f4a 35					dec (hl) 
0f4b 18 ea				jr .incharp 
0f4d			.ipwordst: 
0f4d					; at space before the prev word so reposition over it 
0f4d 21 55 ee				ld hl, input_cursor 
0f50 34					inc (hl) 
0f51 18 b0				jr .inskpwn 
0f53					 
0f53			 
0f53			 
0f53			input_left: 
0f53				; move cursor left 
0f53 21 55 ee			ld hl, input_cursor 
0f56 35				dec (hl) 
0f57			;	cp 0 
0f57			;	jp z, .inmain    ; ignore left as at the start of the string 
0f57 c3 39 0e			jp .inmain 
0f5a			 
0f5a			input_right: 
0f5a				; move cursor right 
0f5a				 
0f5a				;ld a, (input_size) 
0f5a				;ld b, a 
0f5a 21 55 ee			ld hl, input_cursor 
0f5d 34				inc (hl) 
0f5e				;dec b 
0f5e				;cp 0 
0f5e				;jp z, .inmain   ; ignore as at end of the string buffer 
0f5e				;ld a, b 
0f5e				;inc a 
0f5e				;ld (input_cursor), a 
0f5e c3 39 0e			jp .inmain 
0f61			 
0f61			 
0f61			 
0f61			input_disp_ref: 
0f61				; display the text from start of buffer (ie full refresh) 
0f61 3a 64 ee			ld a, (input_at_pos) 
0f64 2a 67 ee			ld hl,(input_start) 
0f67 eb				ex de, hl 
0f68 cd cc 0b			call str_at_display  
0f6b c9				ret 
0f6c			input_disp_oncur: 
0f6c				; display the text from cursor position to end of buffer 
0f6c				; TODO position start of string at cursor position on screen 
0f6c				; TODO draw from that point on 
0f6c 3a 55 ee			ld a, (input_cursor) 
0f6f 47				ld b, a 
0f70 3a 64 ee			ld a, (input_at_pos) 
0f73 80				add b 
0f74 48				ld c, b     ; save a 
0f75 78				ld a, b     ; inc string start for cursor 
0f76 2a 67 ee			ld hl,(input_start) 
0f79 cd e6 0d			call addatohl 
0f7c eb				ex de, hl 
0f7d 79				ld a, c 
0f7e cd cc 0b			call str_at_display  
0f81 c9				ret 
0f82			 
0f82			input_nxtw: 
0f82				; Find next word 
0f82 c9				ret 
0f83			 
0f83			input_prvw: 
0f83				; Find previous word 
0f83 c9				ret 
0f84			 
0f84			input_lenrem:   
0f84				; Calculate the length of string remaining from current cursor 
0f84				; position to end of buffer (exc null term) 
0f84				 
0f84 3a 55 ee			ld a, (input_cursor) 
0f87 4f				ld c, a 
0f88 3a 66 ee			ld a, (input_size) 
0f8b 91				sub c 
0f8c 06 00			ld b, 0 
0f8e 0d				dec c 
0f8f c9				ret	 
0f90			 
0f90			input_curptr: 
0f90				; calc address of the character under the cursor 
0f90				 
0f90 2a 67 ee			ld hl, (input_start) 
0f93 3a 55 ee			ld a, (input_cursor) 
0f96 cd e6 0d			call addatohl 
0f99 c9				ret 
0f9a			 
0f9a			input_inschr: 
0f9a				; Insert char at cursor position 
0f9a f5				push af   ; save char 
0f9b				;call input_lenrem    ; get bc length of remaining string 
0f9b			 
0f9b				 
0f9b cd 90 0f			call input_curptr 
0f9e			;	ld hl, (input_start) 
0f9e			;	ld a, (input_cursor) 
0f9e			;	call addatohl 
0f9e				;push hl   ; save to come back to 
0f9e			 
0f9e				; shift everything up one to end of buffer 
0f9e			 
0f9e				;push hl 
0f9e				;dec de 
0f9e				;inc de 
0f9e			;	ldir 
0f9e				 
0f9e				;pop hl 
0f9e			 
0f9e				; are we adding to the end of line? 
0f9e			 
0f9e 3a 55 ee			ld a, (input_cursor) 
0fa1 47				ld b, a 
0fa2 3a 5a ee			ld a, (input_len) 
0fa5 b8				cp b 
0fa6 20 09			jr nz, .insmid   ; no, insert in middle of text 
0fa8			 
0fa8				; tack on the end of the line 
0fa8 f1				pop af 
0fa9 77				ld (hl), a   ; save new char 
0faa 23				inc hl 
0fab 3e 00			ld a, 0 
0fad 77				ld (hl), a 
0fae c3 5a 0f			jp input_right 
0fb1				 
0fb1			.insmid: 
0fb1				; hl has insertion point so move everything up one to allow for insertion 
0fb1				;call input_shiftright 
0fb1 f1				pop af 
0fb2			 
0fb2			.shufinsmid: 
0fb2 47				ld b, a     ; b contains new char, c prev char at this position  
0fb3 7e				ld a, (hl) 
0fb4			 
0fb4 fe 00			cp 0    ; at end of string need to then dump new char and add term 
0fb6 28 07			jr z, .endinsmid 
0fb8 4f				ld c, a 
0fb9 78				ld a, b 
0fba 77				ld (hl), a 
0fbb 23				inc hl 
0fbc 79				ld a, c 
0fbd 18 f3			jr .shufinsmid 
0fbf				 
0fbf			 
0fbf			 
0fbf			 
0fbf			.endinsmid: 
0fbf 78				ld a, b 
0fc0 77				ld (hl), a 
0fc1 23				inc hl 
0fc2 3e 00			ld a, 0 
0fc4 77				ld (hl), a 
0fc5			 
0fc5			 
0fc5			;	ld (hl), a   ; save new char 
0fc5			 
0fc5 c3 5a 0f			jp input_right 
0fc8			 
0fc8			;input_shiftright: 
0fc8			;	; shift text right at cursor, hl has shift start 
0fc8			;	push hl 
0fc8			;	push de 
0fc8			;	push bc 
0fc8			; 
0fc8			; 
0fc8			;	; move to end of string past zero term 
0fc8			;	ld hl,(input_start) 
0fc8			;	ld a, (input_len) 
0fc8			;	call addatohl 
0fc8			;	inc hl 
0fc8			;;	inc hl 
0fc8			;;	inc hl 
0fc8			;	ld a, 0 
0fc8			;	ld (hl), a 
0fc8			;;	dec hl 
0fc8			;	 
0fc8			;;	ld (hl), a 
0fc8			;;	dec hl 
0fc8			; 
0fc8			;	push hl 
0fc8			;	pop de 
0fc8			;	inc de 
0fc8			;	 
0fc8			; 
0fc8			;;	ld hl,(input_start) 
0fc8			;;	ld a, (input_cursor) 
0fc8			;;	call addatohl 
0fc8			; 
0fc8			; 
0fc8			;	; calc how many bytes from cursor pos to end of string we need to shift 
0fc8			;	call input_lenrem    ; get bc length of remaining string 
0fc8			;	;ld a, (input_cursor) 
0fc8			;	;ld c, a 
0fc8			;	ld a, (input_len) 
0fc8			;	cp 2 
0fc8			;	jr z, .iskipzero	 
0fc8			;	;sub c 
0fc8			;	;inc a 
0fc8			;	;ld c, a 
0fc8			;	;ld b, 0 
0fc8			;	inc c 
0fc8			;	inc c 
0fc8			;	; move data 
0fc8			;	lddr 
0fc8			;.iskipzero: 
0fc8			; 
0fc8			;	pop bc 
0fc8			;	pop de 
0fc8			;	pop hl 
0fc8			;	ret	 
0fc8			 
0fc8			input_delchar: 
0fc8				; Delete char at cursor position 
0fc8 cd 84 0f			call input_lenrem    ; get bc length of remaining string 
0fcb 2a 67 ee			ld hl, (input_start) 
0fce 3a 55 ee			ld a, (input_cursor) 
0fd1 cd e6 0d			call addatohl 
0fd4			 
0fd4 e5				push hl 
0fd5 d1				pop de 
0fd6 1b				dec de 
0fd7			 
0fd7			.dl:	 
0fd7 ed a0			ldi  
0fd9 7e				ld a, (hl) 
0fda fe 00			cp 0 
0fdc 28 02			jr z, .dldone 
0fde 18 f7			jr .dl 
0fe0			.dldone: 
0fe0 ed a0			ldi 
0fe2			 
0fe2 c3 53 0f			jp input_left 
0fe5			 
0fe5			 
0fe5			endif 
0fe5			 
0fe5			 
0fe5			 
0fe5			if EDIT_V1 
0fe5			input_str: 
0fe5			 
0fe5				    	ld (input_at_pos),a      ; save display position to start 
0fe5					add c 
0fe5					ld (input_at_cursor),a	; save draw pos of cursor 
0fe5					ld (input_start), hl     ; save ptr to buffer 
0fe5					ld a, c 
0fe5					call addatohl 
0fe5					ld (input_ptr), hl     ; save ptr to point under the cursor 
0fe5					ld a,d 
0fe5				        ld (input_size), a       ; save length of input area 
0fe5					ld a, c 
0fe5					ld (input_cursor),a      ; init cursor start position  
0fe5					ld a,e 
0fe5				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0fe5					 
0fe5					 
0fe5			 
0fe5			;		ld a,(input_ptr) 
0fe5			;		ld (input_under_cursor),a 	; save what is under the cursor 
0fe5			 
0fe5			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0fe5					; init cursor shape if not set by the cin routines 
0fe5					ld hl, cursor_shape 
0fe5			if BASE_KEV 
0fe5					ld a, 255 
0fe5			else 
0fe5					ld a, '#' 
0fe5			endif 
0fe5					ld (hl), a 
0fe5					inc hl 
0fe5					ld a, 0 
0fe5					ld (hl), a 
0fe5			 
0fe5					ld a, CUR_BLINK_RATE 
0fe5					ld (input_cur_flash), a 
0fe5					ld a, 1 
0fe5					ld (input_cur_onoff),a 
0fe5			 
0fe5			;	if DEBUG_INPUT 
0fe5			;		push af 
0fe5			;		ld a, 'I' 
0fe5			;		ld (debug_mark),a 
0fe5			;		pop af 
0fe5			;		CALLMONITOR 
0fe5			;	endif 
0fe5			.is1:		; main entry loop 
0fe5			 
0fe5			 
0fe5			 
0fe5					; pause 1ms 
0fe5			 
0fe5					ld a, 1 
0fe5					call aDelayInMS 
0fe5			 
0fe5					; dec flash counter 
0fe5					ld a, (input_cur_flash) 
0fe5					dec a 
0fe5					ld (input_cur_flash), a 
0fe5					cp 0 
0fe5					jr nz, .nochgstate 
0fe5			 
0fe5			 
0fe5					; change state 
0fe5					ld a,(input_cur_onoff) 
0fe5					neg 
0fe5					ld (input_cur_onoff),a 
0fe5			 
0fe5			 
0fe5					; reset on change of state 
0fe5					ld a, CUR_BLINK_RATE 
0fe5					ld (input_cur_flash), a 
0fe5			 
0fe5			.nochgstate: 
0fe5					 
0fe5					 
0fe5			 
0fe5					; display cursor  
0fe5			 
0fe5			;		ld hl, (input_start) 
0fe5			;		ld a, (input_cursor) 
0fe5			;		call addatohl 
0fe5			 
0fe5					; get char under cursor and replace with cursor 
0fe5			ld hl, (input_ptr) 
0fe5			;		ld a, (hl) 
0fe5			;		ld (input_under_cursor),a 
0fe5			;		ld a, '_' 
0fe5			;		ld (hl), a 
0fe5			 
0fe5					; display string 
0fe5			 
0fe5					ld de, (input_start) 
0fe5					ld a, (input_at_pos) 
0fe5					call str_at_display 
0fe5			;	        call update_display 
0fe5			 
0fe5					; find place to put the cursor 
0fe5			;		add h 
0fe5			;		ld l, display_row_1 
0fe5			;		sub l 
0fe5			; (input_at_pos) 
0fe5					;ld c, a 
0fe5			;		ld a, (input_cursor) 
0fe5			;		ld l, (input_at_pos) 
0fe5			;		;ld b, h 
0fe5			;		add l 
0fe5			;		ld (input_at_cursor),a 
0fe5					;ld l,h 
0fe5			 
0fe5			;		ld h, 0 
0fe5			;		ld l,(input_at_pos) 
0fe5			;		ld a, (input_cursor) 
0fe5			;		call addatohl 
0fe5			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0fe5			;		call subafromhl 
0fe5			;		ld a,l 
0fe5			;		ld (input_at_cursor), a 
0fe5			 
0fe5				if DEBUG_INPUT 
0fe5					ld a, (hardware_diag) 
0fe5					cp 0 
0fe5					jr z, .skip_input_diag 
0fe5			 
0fe5					ld a,(input_at_pos) 
0fe5					ld hl, LFSRSeed 
0fe5					call hexout 
0fe5					ld a, (input_cursor) 
0fe5					ld hl, LFSRSeed+2 
0fe5					call hexout 
0fe5					ld a,(input_at_cursor) 
0fe5					ld hl, LFSRSeed+4 
0fe5					call hexout 
0fe5			 
0fe5					ld a,(input_cur_onoff) 
0fe5					ld hl, LFSRSeed+6 
0fe5					call hexout 
0fe5			 
0fe5					ld a,(input_cur_flash) 
0fe5					ld hl, LFSRSeed+8 
0fe5					call hexout 
0fe5			 
0fe5					ld a,(input_len) 
0fe5					ld hl, LFSRSeed+10 
0fe5					call hexout 
0fe5					ld hl, LFSRSeed+12 
0fe5					ld a, 0 
0fe5					ld (hl),a 
0fe5					ld a, display_row_4 
0fe5					ld de, LFSRSeed 
0fe5					call str_at_display 
0fe5					.skip_input_diag: 
0fe5				endif 
0fe5			 
0fe5					; decide on if we are showing the cursor this time round 
0fe5			 
0fe5					ld a, (input_cur_onoff) 
0fe5					cp 255 
0fe5					jr z, .skipcur 
0fe5			 
0fe5			 
0fe5					ld a,(input_at_cursor) 
0fe5					ld de, cursor_shape 
0fe5					call str_at_display 
0fe5			 
0fe5					; save length of current input string 
0fe5					ld hl, (input_start) 
0fe5					ld a, 0 
0fe5					call strlent 
0fe5					ld a,l 
0fe5					ld (input_len),a 
0fe5			 
0fe5			.skipcur: 
0fe5			 
0fe5				        call update_display 
0fe5					 
0fe5			 
0fe5			 
0fe5					; wait 
0fe5				 
0fe5					; TODO loop without wait to flash the cursor and char under cursor	 
0fe5					call cin    ; _wait 
0fe5			 
0fe5					cp 0 
0fe5					jp z, .is1 
0fe5			 
0fe5					; get ptr to char to input into 
0fe5			 
0fe5					ld c,a 
0fe5					ld hl, (input_start) 
0fe5					ld a, (input_cursor) 
0fe5					call addatohl 
0fe5					ld (input_ptr), hl 
0fe5					ld a,c 
0fe5			 
0fe5					; replace char under cursor 
0fe5			 
0fe5			;		ld hl, (input_ptr) 
0fe5			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0fe5			;		ld (hl), a 
0fe5			 
0fe5			;	if DEBUG_INPUT 
0fe5			;		push af 
0fe5			;		ld a, 'i' 
0fe5			;		ld (debug_mark),a 
0fe5			;		pop af 
0fe5			;		CALLMONITOR 
0fe5			;	endif 
0fe5					cp KEY_HOME 
0fe5					jr nz, .iske 
0fe5			 
0fe5					ld a, (input_at_pos) 
0fe5					ld (input_at_cursor),a 
0fe5					ld a, 0 
0fe5					ld (input_cursor), a 
0fe5					jp .is1 
0fe5					 
0fe5			.iske:		cp KEY_END 
0fe5					jr nz, .isknw 
0fe5					jp .is1 
0fe5			 
0fe5			.isknw:		cp KEY_NEXTWORD 
0fe5					jr nz, .iskpw 
0fe5			 
0fe5			.isknwm:	ld hl, (input_ptr) 
0fe5					ld a,(hl)	 
0fe5					cp 0 
0fe5					jp z, .is1    ; end of string 
0fe5					cp ' ' 
0fe5					jp z, .is1    ; end of word 
0fe5					inc hl 
0fe5					ld (input_ptr), hl 
0fe5					ld a, (input_at_cursor) 
0fe5					inc a 
0fe5					ld (input_at_cursor), a 
0fe5					jr .isknwm 
0fe5			 
0fe5			.iskpw:		cp KEY_PREVWORD 
0fe5					jr nz, .iskl 
0fe5			.iskpwm:	 
0fe5					ld hl, (input_ptr) 
0fe5					ld a,(hl)	 
0fe5					cp 0  
0fe5					jp z, .is1    ; end of string 
0fe5					cp ' ' 
0fe5					jp z, .is1    ; end of word 
0fe5					dec hl 
0fe5					ld (input_ptr), hl 
0fe5					ld a, (input_at_cursor) 
0fe5					dec a 
0fe5					ld (input_at_cursor), a 
0fe5					jr .iskpwm 
0fe5			 
0fe5			 
0fe5			.iskl:		cp KEY_LEFT 
0fe5					jr nz, .isk1 
0fe5			 
0fe5					ld a, (input_cursor) 
0fe5			 
0fe5					cp 0 
0fe5					jp z, .is1 		; at start of line to ignore  
0fe5			 
0fe5					dec  a 		; TODO check underflow 
0fe5					ld (input_cursor), a 
0fe5			 
0fe5					ld hl, (input_ptr) 
0fe5					dec hl 
0fe5					ld (input_ptr), hl 
0fe5					 
0fe5					ld a, (input_at_cursor) 
0fe5					dec a 
0fe5					ld (input_at_cursor), a 
0fe5			 
0fe5					ld a, 1		; show cursor moving 
0fe5					ld (input_cur_onoff),a 
0fe5					ld a, CUR_BLINK_RATE 
0fe5					ld (input_cur_flash), a 
0fe5			 
0fe5					jp .is1 
0fe5			 
0fe5			.isk1:		cp KEY_RIGHT 
0fe5					jr nz, .isk2 
0fe5			 
0fe5					ld a,(input_len)		; TODO BUG why cant i load e direct? 
0fe5					ld e,a 
0fe5					ld a, (input_cursor) 
0fe5					cp e 
0fe5					jp z, .is1		; at the end of string so dont go right 
0fe5			 
0fe5					inc  a 		; TODO check overflow 
0fe5					ld (input_cursor), a 
0fe5			 
0fe5					ld a, (input_at_cursor) 
0fe5					inc a 
0fe5					ld (input_at_cursor), a 
0fe5			 
0fe5					ld hl, (input_ptr) 
0fe5					inc hl 
0fe5					ld (input_ptr), hl 
0fe5			 
0fe5					ld a, 1		; show cursor moving 
0fe5					ld (input_cur_onoff),a 
0fe5					ld a, CUR_BLINK_RATE 
0fe5					ld (input_cur_flash), a 
0fe5			 
0fe5					jp .is1 
0fe5			 
0fe5			.isk2:		cp KEY_UP 
0fe5			 
0fe5					jr nz, .isk3 
0fe5			 
0fe5					; swap last command with the current on 
0fe5			 
0fe5					; move cursor to start of string 
0fe5					ld hl, (input_start) 
0fe5					ld (input_ptr), hl 
0fe5			 
0fe5					ld a, (input_at_pos) 
0fe5					ld (input_at_cursor), a 
0fe5			 
0fe5					ld a, 0 
0fe5					ld (input_cursor), a 
0fe5					 
0fe5					; swap input and last command buffers 
0fe5			 
0fe5					ld hl, os_cli_cmd 
0fe5					ld de, os_last_cmd 
0fe5					ld b, 255 
0fe5			.swap1:		ld a, (hl) 
0fe5					ld c,a 
0fe5					ld a, (de) 
0fe5					ld (hl), a 
0fe5					ld a,c 
0fe5					ld (de),a 
0fe5					inc hl 
0fe5					inc de 
0fe5					djnz .swap1 
0fe5			 
0fe5			 
0fe5			 
0fe5			 
0fe5			 
0fe5					jp .is1 
0fe5			 
0fe5			.isk3:		cp KEY_BS 
0fe5					jr nz, .isk4 
0fe5			 
0fe5					ld a, (input_cursor) 
0fe5			 
0fe5					cp 0 
0fe5					jp z, .is1 		; at start of line to ignore  
0fe5			 
0fe5					dec  a 		; TODO check underflow 
0fe5					ld (input_cursor), a 
0fe5			 
0fe5					; hl is source 
0fe5					; de needs to be source - 1 
0fe5			 
0fe5			;		ld a, 0 
0fe5			;		dec hl 
0fe5			;		ld (hl), a 
0fe5			 
0fe5					ld hl, (input_ptr) 
0fe5					dec hl 
0fe5					ld (input_ptr), hl 
0fe5			 
0fe5					; shift all data 
0fe5			 
0fe5					push hl 
0fe5					inc hl 
0fe5					pop de 
0fe5					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0fe5					ld c,a 
0fe5					ld b,0 
0fe5					ldir  
0fe5			 
0fe5			 
0fe5			 
0fe5			 
0fe5					ld a, (input_at_cursor) 
0fe5					dec a 
0fe5					ld (input_at_cursor), a 
0fe5			 
0fe5			 
0fe5					ld a, 1		; show cursor moving 
0fe5					ld (input_cur_onoff),a 
0fe5					ld a, CUR_BLINK_RATE 
0fe5					ld (input_cur_flash), a 
0fe5			 
0fe5					; remove char 
0fe5					ld a, (input_at_cursor) 
0fe5					inc a 
0fe5					ld de,.iblank 
0fe5					call str_at_display 
0fe5			 
0fe5					jp .is1 
0fe5			 
0fe5			.isk4:		cp KEY_CR 
0fe5					jr z, .endinput 
0fe5			 
0fe5					; else add the key press to the end 
0fe5			 
0fe5					ld c, a			; save key pressed 
0fe5			 
0fe5					ld a,(hl)		; get what is currently under char 
0fe5			 
0fe5					cp 0			; we are at the end of the string 
0fe5					jr nz, .onchar 
0fe5					 
0fe5					; add a char to the end of the string 
0fe5				 
0fe5					ld (hl),c 
0fe5					inc hl 
0fe5			;		ld a,' ' 
0fe5			;		ld (hl),a 
0fe5			;		inc hl 
0fe5					ld a,0 
0fe5					ld (hl),a 
0fe5					dec hl 
0fe5			 
0fe5					ld a, (input_cursor) 
0fe5					inc a				; TODO check max string length and scroll  
0fe5					ld (input_cursor), a		; inc cursor pos 
0fe5							 
0fe5					ld a, (input_at_cursor) 
0fe5					inc a 
0fe5					ld (input_at_cursor), a 
0fe5			 
0fe5					ld hl, (input_ptr) 
0fe5					inc hl 
0fe5					ld (input_ptr), hl 
0fe5			 
0fe5					ld hl, (input_ptr) 
0fe5					inc hl 
0fe5					ld (input_ptr), hl 
0fe5			;	if DEBUG_INPUT 
0fe5			;		push af 
0fe5			;		ld a, '+' 
0fe5			;		ld (debug_mark),a 
0fe5			;		pop af 
0fe5			;		CALLMONITOR 
0fe5			;	endif 
0fe5					ld a, 1		; show cursor moving 
0fe5					ld (input_cur_onoff),a 
0fe5					ld a, CUR_BLINK_RATE 
0fe5					ld (input_cur_flash), a 
0fe5					jp .is1 
0fe5					 
0fe5			 
0fe5			 
0fe5					; if on a char then insert 
0fe5			.onchar: 
0fe5			 
0fe5					; TODO over flow check: make sure insert does not blow out buffer 
0fe5			 
0fe5					; need to do some maths to use lddr 
0fe5			 
0fe5					push hl   ; save char pos 
0fe5					push bc 
0fe5			 
0fe5					ld hl, (input_start) 
0fe5					ld a, (input_len) 
0fe5					call addatohl  		; end of string 
0fe5					inc hl 
0fe5					inc hl		; past zero term 
0fe5					push hl 
0fe5					inc hl 
0fe5					push hl  
0fe5			 
0fe5								; start and end of lddr set, now how much to move? 
0fe5			 
0fe5							 
0fe5					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0fe5					ld b,a 
0fe5					ld a,(input_len) 
0fe5					ld e,a 
0fe5					sub b 
0fe5					inc a		;?? 
0fe5					inc a		;?? 
0fe5					inc a		;?? 
0fe5			 
0fe5					ld b,0 
0fe5					ld c,a 
0fe5			 
0fe5				if DEBUG_INPUT 
0fe5					push af 
0fe5					ld a, 'i' 
0fe5					ld (debug_mark),a 
0fe5					pop af 
0fe5			;		CALLMONITOR 
0fe5				endif 
0fe5					pop de 
0fe5					pop hl 
0fe5				if DEBUG_INPUT 
0fe5					push af 
0fe5					ld a, 'I' 
0fe5					ld (debug_mark),a 
0fe5					pop af 
0fe5			;		CALLMONITOR 
0fe5				endif 
0fe5					lddr 
0fe5				 
0fe5			 
0fe5			 
0fe5					; TODO have a key for insert/overwrite mode???? 
0fe5					pop bc 
0fe5					pop hl 
0fe5					ld (hl), c		; otherwise overwrite current char 
0fe5					 
0fe5			 
0fe5			 
0fe5			 
0fe5					ld a, (input_cursor) 
0fe5					inc  a 		; TODO check overflow 
0fe5					ld (input_cursor), a 
0fe5			 
0fe5					ld a, (input_at_cursor) 
0fe5					inc a 
0fe5					ld (input_at_cursor), a 
0fe5			 
0fe5					jp .is1 
0fe5			 
0fe5			.endinput:	; TODO look for end of string 
0fe5			 
0fe5					; add trailing space for end of token 
0fe5			 
0fe5					ld hl, (input_start) 
0fe5					ld a,(input_len) 
0fe5					call addatohl 
0fe5					ld a, ' ' 
0fe5					ld (hl),a 
0fe5					; TODO eof of parse marker 
0fe5			 
0fe5					inc hl 
0fe5					ld a, 0 
0fe5					ld (hl),a 
0fe5			 
0fe5			 
0fe5					ret 
0fe5			 
0fe5			.iblank: db " ",0 
0fe5			 
0fe5			 
0fe5			input_str_prev:	ld (input_at_pos), a 
0fe5					ld (input_start), hl 
0fe5					ld a,1			; add cursor 
0fe5					ld (hl),a 
0fe5					inc hl 
0fe5					ld a,0 
0fe5					ld (hl),a 
0fe5					ld (input_ptr), hl 
0fe5					ld a,d 
0fe5					ld (input_size), a 
0fe5					ld a,0 
0fe5					ld (input_cursor),a 
0fe5			.instr1:	 
0fe5			 
0fe5					; TODO do block cursor 
0fe5					; TODO switch cursor depending on the modifer key 
0fe5			 
0fe5					; update cursor shape change on key hold 
0fe5			 
0fe5					ld hl, (input_ptr) 
0fe5					dec hl 
0fe5					ld a,(cursor_shape) 
0fe5					ld (hl), a 
0fe5			 
0fe5					; display entered text 
0fe5					ld a,(input_at_pos) 
0fe5			            	CALL fLCD_Pos       ;Position cursor to location in A 
0fe5			            	LD   de, (input_start) 
0fe5			            	CALL fLCD_Str       ;Display string pointed to by DE 
0fe5			 
0fe5					call cin 
0fe5					cp 0 
0fe5					jr z, .instr1 
0fe5			 
0fe5					; proecess keyboard controls first 
0fe5			 
0fe5					ld hl,(input_ptr) 
0fe5			 
0fe5					cp KEY_CR	 ; pressing enter ends input 
0fe5					jr z, .instrcr 
0fe5			 
0fe5					cp KEY_BS 	; back space 
0fe5					jr nz, .instr2 
0fe5					; process back space 
0fe5			 
0fe5					; TODO stop back space if at start of string 
0fe5					dec hl 
0fe5					dec hl ; to over write cursor 
0fe5					ld a,(cursor_shape) 
0fe5					;ld a,0 
0fe5					ld (hl),a 
0fe5					inc hl 
0fe5					ld a," " 
0fe5					ld (hl),a 
0fe5					ld (input_ptr),hl 
0fe5					 
0fe5			 
0fe5					jr .instr1 
0fe5			 
0fe5			.instr2:	cp KEY_LEFT    ; cursor left 
0fe5					jr nz, .instr3 
0fe5					dec hl 
0fe5					ld (input_ptr),hl 
0fe5					jr .instr1 
0fe5				 
0fe5			.instr3:	cp KEY_RIGHT      ; cursor right 
0fe5					jr nz, .instr4 
0fe5					inc hl 
0fe5					ld (input_ptr),hl 
0fe5					jr .instr1 
0fe5			 
0fe5			.instr4:	cp KEY_HOME    ; jump to start of line 
0fe5					jr nz, .instr5 
0fe5					dec hl 
0fe5					ld (input_ptr),hl 
0fe5					jr .instr1 
0fe5			 
0fe5			.instr5:	cp KEY_END     ; jump to end of line 
0fe5					jr nz, .instr6 
0fe5					dec hl 
0fe5					ld (input_ptr),hl 
0fe5					jr .instr1 
0fe5			.instr6:        cp KEY_UP      ; recall last command 
0fe5					jr nz, .instrnew 
0fe5			 
0fe5				ld hl, scratch 
0fe5				ld de, os_last_cmd 
0fe5				call strcpy 
0fe5					jr .instr1 
0fe5			 
0fe5			 
0fe5			.instrnew:	; no special key pressed to see if we have room to store it 
0fe5			 
0fe5					; TODO do string size test 
0fe5			 
0fe5					dec hl ; to over write cursor 
0fe5					ld (hl),a 
0fe5					inc hl 
0fe5					ld a,(cursor_shape) 
0fe5					ld (hl),a 
0fe5					inc hl 
0fe5					ld a,0 
0fe5					ld (hl),a 
0fe5			 
0fe5					ld (input_ptr),hl 
0fe5					 
0fe5					jr .instr1 
0fe5			.instrcr:	dec hl		; remove cursor 
0fe5					ld a,' '	; TODO add a trailing space for safety 
0fe5					ld (hl),a 
0fe5					inc hl 
0fe5					ld a,0 
0fe5					ld (hl),a 
0fe5			 
0fe5			 
0fe5					; if at end of line scroll up    
0fe5					; TODO detecting only end of line 4 for scroll up  
0fe5			 
0fe5					;ld   
0fe5			 
0fe5					ret 
0fe5			 
0fe5			 
0fe5			endif 
0fe5			; strcpy hl = dest, de source 
0fe5			 
0fe5 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0fe6 b7			            OR   A              ;Null terminator? 
0fe7 c8			            RET  Z              ;Yes, so finished 
0fe8 1a					ld a,(de) 
0fe9 77					ld (hl),a 
0fea 13			            INC  DE             ;Point to next character 
0feb 23					inc hl 
0fec 18 f7		            JR   strcpy       ;Repeat 
0fee c9					ret 
0fef			 
0fef			 
0fef			; TODO string_at  
0fef			; pass string which starts with lcd offset address and then null term string 
0fef			 
0fef			; TODO string to dec 
0fef			; TODO string to hex 
0fef			; TODO byte to string hex 
0fef			; TODO byte to string dec 
0fef			 
0fef			 
0fef			 
0fef			; from z80uartmonitor 
0fef			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fef			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0fef			; pass hl for where to put the text 
0fef			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fef c5			hexout:	PUSH BC 
0ff0 f5					PUSH AF 
0ff1 47					LD B, A 
0ff2					; Upper nybble 
0ff2 cb 3f				SRL A 
0ff4 cb 3f				SRL A 
0ff6 cb 3f				SRL A 
0ff8 cb 3f				SRL A 
0ffa cd 0a 10				CALL tohex 
0ffd 77					ld (hl),a 
0ffe 23					inc hl	 
0fff					 
0fff					; Lower nybble 
0fff 78					LD A, B 
1000 e6 0f				AND 0FH 
1002 cd 0a 10				CALL tohex 
1005 77					ld (hl),a 
1006 23					inc hl	 
1007					 
1007 f1					POP AF 
1008 c1					POP BC 
1009 c9					RET 
100a					 
100a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
100a			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
100a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
100a			tohex: 
100a e5					PUSH HL 
100b d5					PUSH DE 
100c 16 00				LD D, 0 
100e 5f					LD E, A 
100f 21 17 10				LD HL, .DATA 
1012 19					ADD HL, DE 
1013 7e					LD A, (HL) 
1014 d1					POP DE 
1015 e1					POP HL 
1016 c9					RET 
1017			 
1017			.DATA: 
1017 30					DEFB	30h	; 0 
1018 31					DEFB	31h	; 1 
1019 32					DEFB	32h	; 2 
101a 33					DEFB	33h	; 3 
101b 34					DEFB	34h	; 4 
101c 35					DEFB	35h	; 5 
101d 36					DEFB	36h	; 6 
101e 37					DEFB	37h	; 7 
101f 38					DEFB	38h	; 8 
1020 39					DEFB	39h	; 9 
1021 41					DEFB	41h	; A 
1022 42					DEFB	42h	; B 
1023 43					DEFB	43h	; C 
1024 44					DEFB	44h	; D 
1025 45					DEFB	45h	; E 
1026 46					DEFB	46h	; F 
1027			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1027			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1027			;;    subtract $30, if result > 9 then subtract $7 more 
1027			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1027			atohex: 
1027 d6 30				SUB $30 
1029 fe 0a				CP 10 
102b f8					RET M		; If result negative it was 0-9 so we're done 
102c d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
102e c9					RET		 
102f			 
102f			 
102f			 
102f			 
102f			; Get 2 ASCII characters as hex byte from pointer in hl 
102f			 
102f			BYTERD: 
102f 16 00			LD	D,00h		;Set up 
1031 cd 39 10			CALL	HEXCON		;Get byte and convert to hex 
1034 87				ADD	A,A		;First nibble so 
1035 87				ADD	A,A		;multiply by 16 
1036 87				ADD	A,A		; 
1037 87				ADD	A,A		; 
1038 57				LD	D,A		;Save hi nibble in D 
1039			HEXCON: 
1039 7e				ld a, (hl)		;Get next chr 
103a 23				inc hl 
103b d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
103d fe 0a			CP	00Ah		;Is it 0-9 ? 
103f 38 02			JR	C,NALPHA	;If so miss next bit 
1041 d6 07			SUB	007h		;Else convert alpha 
1043			NALPHA: 
1043 b2				OR	D		;Add hi nibble back 
1044 c9				RET			; 
1045			 
1045			 
1045			; 
1045			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1045			; Since the routines get_byte and therefore get_nibble are called, only valid 
1045			; characters (0-9a-f) are accepted. 
1045			; 
1045			;get_word        push    af 
1045			;                call    get_byte        ; Get the upper byte 
1045			;                ld      h, a 
1045			;                call    get_byte        ; Get the lower byte 
1045			;                ld      l, a 
1045			;                pop     af 
1045			;                ret 
1045			; 
1045			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1045			; the routine get_nibble is used only valid characters are accepted - the  
1045			; input routine only accepts characters 0-9a-f. 
1045			; 
1045 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1046 7e					ld a,(hl) 
1047 23					inc hl 
1048 cd 6d 10		                call    nibble2val      ; Get upper nibble 
104b cb 07		                rlc     a 
104d cb 07		                rlc     a 
104f cb 07		                rlc     a 
1051 cb 07		                rlc     a 
1053 47			                ld      b, a            ; Save upper four bits 
1054 7e					ld a,(hl) 
1055 cd 6d 10		                call    nibble2val      ; Get lower nibble 
1058 b0			                or      b               ; Combine both nibbles 
1059 c1			                pop     bc              ; Restore B (and C) 
105a c9			                ret 
105b			; 
105b			; Get a hexadecimal digit from the serial line. This routine blocks until 
105b			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
105b			; to the serial line interface. The lower 4 bits of A contain the value of  
105b			; that particular digit. 
105b			; 
105b			;get_nibble      ld a,(hl)           ; Read a character 
105b			;                call    to_upper        ; Convert to upper case 
105b			;                call    is_hex          ; Was it a hex digit? 
105b			;                jr      nc, get_nibble  ; No, get another character 
105b			 ;               call    nibble2val      ; Convert nibble to value 
105b			 ;               call    print_nibble 
105b			 ;               ret 
105b			; 
105b			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
105b			; A valid hexadecimal digit is denoted by a set C flag. 
105b			; 
105b			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
105b			;                ret     nc              ; Yes 
105b			;                cp      '0'             ; Less than '0'? 
105b			;                jr      nc, is_hex_1    ; No, continue 
105b			;                ccf                     ; Complement carry (i.e. clear it) 
105b			;                ret 
105b			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
105b			;                ret     c               ; Yes 
105b			;                cp      'A'             ; Less than 'A'? 
105b			;                jr      nc, is_hex_2    ; No, continue 
105b			;                ccf                     ; Yes - clear carry and return 
105b			;                ret 
105b			;is_hex_2        scf                     ; Set carry 
105b			;                ret 
105b			; 
105b			; Convert a single character contained in A to upper case: 
105b			; 
105b fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
105d d8			                ret     c 
105e fe 7b		                cp      'z' + 1         ; > 'z'? 
1060 d0			                ret     nc              ; Nothing to do, either 
1061 e6 5f		                and     $5f             ; Convert to upper case 
1063 c9			                ret 
1064			 
1064			 
1064			to_lower: 
1064			 
1064			   ; if char is in [A-Z] make it lower case 
1064			 
1064			   ; enter : a = char 
1064			   ; exit  : a = lower case char 
1064			   ; uses  : af 
1064			 
1064 fe 41		   cp 'A' 
1066 d8			   ret c 
1067			    
1067 fe 5b		   cp 'Z'+1 
1069 d0			   ret nc 
106a			    
106a f6 20		   or $20 
106c c9			   ret 
106d			 
106d			; 
106d			; Expects a hexadecimal digit (upper case!) in A and returns the 
106d			; corresponding value in A. 
106d			; 
106d fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
106f 38 02		                jr      c, nibble2val_1 ; Yes 
1071 d6 07		                sub     7               ; Adjust for A-F 
1073 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1075 e6 0f		                and     $f              ; Only return lower 4 bits 
1077 c9			                ret 
1078			; 
1078			; Print_nibble prints a single hex nibble which is contained in the lower  
1078			; four bits of A: 
1078			; 
1078			;print_nibble    push    af              ; We won't destroy the contents of A 
1078			;                and     $f              ; Just in case... 
1078			;                add     a, '0'             ; If we have a digit we are done here. 
1078			;                cp      '9' + 1         ; Is the result > 9? 
1078			;                jr      c, print_nibble_1 
1078			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1078			;print_nibble_1  call    putc            ; Print the nibble and 
1078			;                pop     af              ; restore the original value of A 
1078			;                ret 
1078			;; 
1078			;; Send a CR/LF pair: 
1078			; 
1078			;crlf            push    af 
1078			;                ld      a, cr 
1078			;                call    putc 
1078			;                ld      a, lf 
1078			;                call    putc 
1078			;                pop     af 
1078			;                ret 
1078			; 
1078			; Print_word prints the four hex digits of a word to the serial line. The  
1078			; word is expected to be in HL. 
1078			; 
1078			;print_word      push    hl 
1078			;                push    af 
1078			;                ld      a, h 
1078			;                call    print_byte 
1078			;                ld      a, l 
1078			;                call    print_byte 
1078			;                pop     af 
1078			;                pop     hl 
1078			;                ret 
1078			; 
1078			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1078			; The byte to be printed is expected to be in A. 
1078			; 
1078			;print_byte      push    af              ; Save the contents of the registers 
1078			;                push    bc 
1078			;                ld      b, a 
1078			;                rrca 
1078			;                rrca 
1078			;                rrca 
1078			;                rrca 
1078			;                call    print_nibble    ; Print high nibble 
1078			;                ld      a, b 
1078			;                call    print_nibble    ; Print low nibble 
1078			;                pop     bc              ; Restore original register contents 
1078			;                pop     af 
1078			;                ret 
1078			 
1078			 
1078			 
1078			 
1078			 
1078			fourehexhl:  
1078 7e				ld a,(hl) 
1079 cd 27 10			call atohex 
107c cb 3f				SRL A 
107e cb 3f				SRL A 
1080 cb 3f				SRL A 
1082 cb 3f				SRL A 
1084 47				ld b, a 
1085 23				inc hl 
1086 7e				ld a,(hl) 
1087 23				inc hl 
1088 cd 27 10			call atohex 
108b 80				add b 
108c 57				ld d,a 
108d 7e				ld a,(hl) 
108e cd 27 10			call atohex 
1091 cb 3f				SRL A 
1093 cb 3f				SRL A 
1095 cb 3f				SRL A 
1097 cb 3f				SRL A 
1099 47				ld b, a 
109a 23				inc hl 
109b 7e				ld a,(hl) 
109c 23				inc hl 
109d cd 27 10			call atohex 
10a0 80				add b 
10a1 5f				ld e, a 
10a2 d5				push de 
10a3 e1				pop hl 
10a4 c9				ret 
10a5			 
10a5			; pass hl. returns z set if the byte at hl is a digit 
10a5			;isdigithl:  
10a5			;	push bc 
10a5			;	ld a,(hl) 
10a5			;	cp ':' 
10a5			;	jr nc, .isdf 		; > 
10a5			;	cp '0' 
10a5			;	jr c, .isdf		; < 
10a5			; 
10a5			;	; TODO find a better way to set z 
10a5			; 
10a5			;	ld b,a 
10a5			;	cp b 
10a5			;	pop bc 
10a5			;	ret 
10a5			; 
10a5			;.isdf:	; not digit so clear z 
10a5			; 
10a5			;	; TODO find a better way to unset z 
10a5			; 
10a5			;	ld b,a 
10a5			;	inc b 
10a5			;	cp b 
10a5			; 
10a5			;	pop bc 
10a5			;	ret 
10a5				 
10a5				 
10a5			 
10a5			 
10a5			; pass hl as the four byte address to load 
10a5			 
10a5			get_word_hl:  
10a5 e5				push hl 
10a6 cd 45 10			call get_byte 
10a9				 
10a9 47				ld b, a 
10aa			 
10aa e1				pop hl 
10ab 23				inc hl 
10ac 23				inc hl 
10ad			 
10ad			; TODO not able to handle a-f  
10ad 7e				ld a,(hl) 
10ae			;	;cp ':' 
10ae			;	cp 'g' 
10ae			;	jr nc, .single_byte_hl 		; > 
10ae			;	cp 'G' 
10ae			;	jr nc, .single_byte_hl 		; > 
10ae			;	cp '0' 
10ae			;	jr c, .single_byte_hl		; < 
10ae			 
10ae				;call isdigithl 
10ae fe 00			cp 0 
10b0 28 06			jr z, .single_byte_hl 
10b2			 
10b2			.getwhln:   ; hex word so get next byte 
10b2			 
10b2 cd 45 10			call get_byte 
10b5 6f				ld l, a 
10b6 60				ld h,b 
10b7 c9				ret 
10b8 68			.single_byte_hl:   ld l,b 
10b9 26 00				ld h,0 
10bb c9					ret 
10bc			 
10bc			 
10bc			 
10bc			 
10bc 21 5c 18			ld hl,asc+1 
10bf			;	ld a, (hl) 
10bf			;	call nibble2val 
10bf cd 45 10			call get_byte 
10c2			 
10c2			;	call fourehexhl 
10c2 32 f5 e2			ld (scratch+52),a 
10c5				 
10c5 21 f3 e2			ld hl,scratch+50 
10c8 22 e4 e5			ld (os_cur_ptr),hl 
10cb			 
10cb c9				ret 
10cc			 
10cc			 
10cc			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10cc			 
10cc			; Decimal Unsigned Version 
10cc			 
10cc			;Number in a to decimal ASCII 
10cc			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10cc			;Example: display a=56 as "056" 
10cc			;input: a = number 
10cc			;Output: a=0,value of a in the screen 
10cc			;destroys af,bc (don't know about hl and de) 
10cc			DispAToASCII: 
10cc 0e 9c			ld	c,-100 
10ce cd d8 10			call	.Na1 
10d1 0e f6			ld	c,-10 
10d3 cd d8 10			call	.Na1 
10d6 0e ff			ld	c,-1 
10d8 06 2f		.Na1:	ld	b,'0'-1 
10da 04			.Na2:	inc	b 
10db 81				add	a,c 
10dc 38 fc			jr	c,.Na2 
10de 91				sub	c		;works as add 100/10/1 
10df f5				push af		;safer than ld c,a 
10e0 78				ld	a,b		;char is in b 
10e1			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10e1 f1				pop af		;safer than ld a,c 
10e2 c9				ret 
10e3			 
10e3			; Decimal Signed Version 
10e3			 
10e3			; DispA 
10e3			; -------------------------------------------------------------- 
10e3			; Converts a signed integer value to a zero-terminated ASCII 
10e3			; string representative of that value (using radix 10). 
10e3			; -------------------------------------------------------------- 
10e3			; INPUTS: 
10e3			;     HL     Value to convert (two's complement integer). 
10e3			;     DE     Base address of string destination. (pointer). 
10e3			; -------------------------------------------------------------- 
10e3			; OUTPUTS: 
10e3			;     None 
10e3			; -------------------------------------------------------------- 
10e3			; REGISTERS/MEMORY DESTROYED 
10e3			; AF HL 
10e3			; -------------------------------------------------------------- 
10e3			 
10e3			;DispHLToASCII: 
10e3			;   push    de 
10e3			;   push    bc 
10e3			; 
10e3			;; Detect sign of HL. 
10e3			;    bit    7, h 
10e3			;    jr     z, ._DoConvert 
10e3			; 
10e3			;; HL is negative. Output '-' to string and negate HL. 
10e3			;    ld     a, '-' 
10e3			;    ld     (de), a 
10e3			;    inc    de 
10e3			; 
10e3			;; Negate HL (using two's complement) 
10e3			;    xor    a 
10e3			;    sub    l 
10e3			;    ld     l, a 
10e3			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10e3			;    sbc    a, h 
10e3			;    ld     h, a 
10e3			; 
10e3			;; Convert HL to digit characters 
10e3			;._DoConvert: 
10e3			;    ld     b, 0     ; B will count character length of number 
10e3			;-   ld     a, 10 
10e3			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10e3			;    push   af 
10e3			;    inc    b 
10e3			;    ld     a, h 
10e3			;    or     l 
10e3			;    jr     nz, - 
10e3			; 
10e3			;; Retrieve digits from stack 
10e3			;-   pop    af 
10e3			;    or     $30 
10e3			;    ld     (de), a 
10e3			;    inc    de 
10e3			;    djnz   - 
10e3			; 
10e3			;; Terminate string with NULL 
10e3			;    xor    a 
10e3			;    ld     (de), a 
10e3			; 
10e3			;    pop    bc 
10e3			;    pop    de 
10e3			;    ret 
10e3			 
10e3			;Comments 
10e3			; 
10e3			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10e3			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10e3			;    Note that the output string will not be fixed-width. 
10e3			; 
10e3			;Example Usage 
10e3			; 
10e3			;    ld    hl, -1004 
10e3			;    ld    de, OP1 
10e3			;    call  DispA 
10e3			;    ld    hl, OP1 
10e3			;    syscall  PutS 
10e3			 
10e3			 
10e3			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10e3			 
10e3			 
10e3			;Converts an ASCII string to an unsigned 16-bit integer 
10e3			;Quits when it reaches a non-decimal digit 
10e3			 
10e3			string_to_uint16: 
10e3			atoui_16: 
10e3			;Input: 
10e3			;     DE points to the string 
10e3			;Outputs: 
10e3			;     HL is the result 
10e3			;     A is the 8-bit value of the number 
10e3			;     DE points to the byte after the number 
10e3			;Destroys: 
10e3			;     BC 
10e3			;       if the string is non-empty, BC is HL/10 
10e3			;Size:  24 bytes 
10e3			;Speed: 42+d(104+{0,9}) 
10e3			;       d is the number of digits in the number 
10e3			;       max is 640 cycles for a 5 digit number 
10e3			;Assuming no leading zeros: 
10e3			;1 digit:  146cc 
10e3			;2 digit:  250cc 
10e3			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10e3			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10e3			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10e3			;avg: 544.81158447265625cc (544+13297/16384) 
10e3			;=============================================================== 
10e3 21 00 00		  ld hl,0 
10e6			.u16a: 
10e6 1a			  ld a,(de) 
10e7 d6 30		  sub 30h 
10e9 fe 0a		  cp 10 
10eb d0			  ret nc 
10ec 13			  inc de 
10ed 44			  ld b,h 
10ee 4d			  ld c,l 
10ef 29			  add hl,hl 
10f0 29			  add hl,hl 
10f1 09			  add hl,bc 
10f2 29			  add hl,hl 
10f3 85			  add a,l 
10f4 6f			  ld l,a 
10f5 30 ef		  jr nc,.u16a 
10f7 24			  inc h 
10f8 c3 e6 10		  jp .u16a 
10fb			 
10fb			 
10fb			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10fb			 
10fb			;written by Zeda 
10fb			;Converts a 16-bit unsigned integer to an ASCII string. 
10fb			 
10fb			uitoa_16: 
10fb			;Input: 
10fb			;   DE is the number to convert 
10fb			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
10fb			;Output: 
10fb			;   HL points to the null-terminated ASCII string 
10fb			;      NOTE: This isn't necessarily the same as the input HL. 
10fb d5			  push de 
10fc c5			  push bc 
10fd f5			  push af 
10fe eb			  ex de,hl 
10ff			 
10ff 01 f0 d8		  ld bc,-10000 
1102 3e 2f		  ld a,'0'-1 
1104 3c			  inc a 
1105 09			  add hl,bc  
1106 38 fc		   jr c,$-2 
1108 12			  ld (de),a 
1109 13			  inc de 
110a			 
110a 01 e8 03		  ld bc,1000 
110d 3e 3a		  ld a,'9'+1 
110f 3d			  dec a  
1110 09			  add hl,bc  
1111 30 fc		   jr nc,$-2 
1113 12			  ld (de),a 
1114 13			  inc de 
1115			 
1115 01 9c ff		  ld bc,-100 
1118 3e 2f		  ld a,'0'-1 
111a 3c			  inc a  
111b 09			  add hl,bc  
111c 38 fc		   jr c,$-2 
111e 12			  ld (de),a 
111f 13			  inc de 
1120			 
1120 7d			  ld a,l 
1121 26 3a		  ld h,'9'+1 
1123 25			  dec h  
1124 c6 0a		  add a,10  
1126 30 fb		   jr nc,$-3 
1128 c6 30		  add a,'0' 
112a eb			  ex de,hl 
112b 72			  ld (hl),d 
112c 23			  inc hl 
112d 77			  ld (hl),a 
112e 23			  inc hl 
112f 36 00		  ld (hl),0 
1131			 
1131			;Now strip the leading zeros 
1131 0e fa		  ld c,-6 
1133 09			  add hl,bc 
1134 3e 30		  ld a,'0' 
1136 23			  inc hl  
1137 be			  cp (hl)  
1138 28 fc		  jr z,$-2 
113a			 
113a			;Make sure that the string is non-empty! 
113a 7e			  ld a,(hl) 
113b b7			  or a 
113c 20 01		  jr nz,.atoub 
113e 2b			  dec hl 
113f			.atoub: 
113f			 
113f f1			  pop af 
1140 c1			  pop bc 
1141 d1			  pop de 
1142 c9			  ret 
1143			 
1143			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1143			 
1143			toUpper: 
1143			;A is the char. 
1143			;If A is a lowercase letter, this sets it to the matching uppercase 
1143			;18cc or 30cc or 41cc 
1143			;avg: 26.75cc 
1143 fe 61		  cp 'a' 
1145 d8			  ret c 
1146 fe 7b		  cp 'z'+1 
1148 d0			  ret nc 
1149 d6 20		  sub 'a'-'A' 
114b c9			  ret 
114c			 
114c			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
114c			 
114c			; String Length 
114c			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
114c			 
114c			; Get the length of the null-terminated string starting at $8000 hl 
114c			;    LD     HL, $8000 
114c			 
114c			strlenz: 
114c			 
114c af			    XOR    A               ; Zero is the value we are looking for. 
114d 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
114e 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
114f			                           ; 65, 536 bytes (the entire addressable memory space). 
114f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1151			 
1151			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1151 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1152 6f			    LD     L, A             ; number of bytes 
1153 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1155 2b			    DEC    HL              ; Compensate for null. 
1156 c9				ret 
1157			 
1157			; Get the length of the A terminated string starting at $8000 hl 
1157			;    LD     HL, $8000 
1157			 
1157			strlent: 
1157			 
1157			                  ; A is the value we are looking for. 
1157 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1159 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
115b			                           ; 65, 536 bytes (the entire addressable memory space). 
115b ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
115d			 
115d			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
115d 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
115f 2e 00		    LD     L, 0             ; number of bytes 
1161 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1163 2b			    DEC    HL              ; Compensate for null. 
1164 c9				ret 
1165			 
1165			 
1165			;Comparing Strings 
1165			 
1165			;IN    HL     Address of string1. 
1165			;      DE     Address of string2. 
1165			 
1165			; doc given but wrong??? 
1165			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1165			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1165			; tested 
1165			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1165			 
1165			strcmp_old: 
1165 e5			    PUSH   HL 
1166 d5			    PUSH   DE 
1167			 
1167 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1168 be			    CP     (HL)            ; (want to minimize work). 
1169 38 01		    JR     C, Str1IsBigger 
116b 7e			    LD     A, (HL) 
116c			 
116c			Str1IsBigger: 
116c 4f			    LD     C, A             ; Put length in BC 
116d 06 00		    LD     B, 0 
116f 13			    INC    DE              ; Increment pointers to meat of string. 
1170 23			    INC    HL 
1171			 
1171			CmpLoop: 
1171 1a			    LD     A, (DE)          ; Compare bytes. 
1172 ed a1		    CPI 
1174 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1176 13			    INC    DE              ; Update pointer. 
1177 ea 71 11		    JP     PE, CmpLoop 
117a			 
117a d1			    POP    DE 
117b e1			    POP    HL 
117c 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
117d be			    CP     (HL) 
117e c9			    RET 
117f			 
117f			NoMatch: 
117f 2b			    DEC    HL 
1180 be			    CP     (HL)            ; Compare again to affect carry. 
1181 d1			    POP    DE 
1182 e1			    POP    HL 
1183 c9			    RET 
1184			 
1184			;; test strmp 
1184			; 
1184			;ld de, .str1 
1184			;ld hl, .str2 
1184			;call strcmp 
1184			;jr z, .z1 
1184			;;this 
1184			;	if DEBUG_FORTH_WORDS 
1184			;		DMARK "NZ1" 
1184			;		CALLMONITOR 
1184			;	endif 
1184			;.z1: 
1184			; 
1184			;	if DEBUG_FORTH_WORDS 
1184			;		DMARK "ZZ1" 
1184			;		CALLMONITOR 
1184			;	endif 
1184			; 
1184			;ld de, .str1 
1184			;ld hl, .str1 
1184			;call strcmp 
1184			;jr z, .z2 
1184			;;this 
1184			;	if DEBUG_FORTH_WORDS 
1184			;		DMARK "NZ2" 
1184			;		CALLMONITOR 
1184			;	endif 
1184			;.z2: 
1184			; 
1184			;	if DEBUG_FORTH_WORDS 
1184			;		DMARK "ZZ2" 
1184			;		CALLMONITOR 
1184			;	endif 
1184			; 
1184			;ld de, .str1 
1184			;ld hl, .str2 
1184			;call strcmp 
1184			;jr c, .c1 
1184			; 
1184			;	if DEBUG_FORTH_WORDS 
1184			;		DMARK "Nc1" 
1184			;		CALLMONITOR 
1184			;	endif 
1184			;.c1: 
1184			;;this 
1184			;	if DEBUG_FORTH_WORDS 
1184			;		DMARK "cc1" 
1184			;		CALLMONITOR 
1184			;	endif 
1184			; 
1184			;ld de, .str1 
1184			;ld hl, .str1 
1184			;call strcmp 
1184			;jr c, .c2 
1184			;;this 
1184			;	if DEBUG_FORTH_WORDS 
1184			;		DMARK "Nc2" 
1184			;		CALLMONITOR 
1184			;	endif 
1184			;.c2: 
1184			; 
1184			;	if DEBUG_FORTH_WORDS 
1184			;		DMARK "cc2" 
1184			;		CALLMONITOR 
1184			;	endif 
1184			;	NEXTW 
1184			;.str1:   db "string1",0 
1184			;.str2:   db "string2",0 
1184			 
1184			; only care about direct match or not 
1184			; hl and de strings 
1184			; zero set if the same 
1184			 
1184			strcmp: 
1184 1a				ld a, (de) 
1185 be				cp (hl) 
1186 28 02			jr z, .ssame 
1188 b7				or a 
1189 c9				ret 
118a			 
118a			.ssame:  
118a fe 00			cp 0 
118c c8				ret z 
118d			 
118d 23				inc hl 
118e 13				inc de 
118f 18 f3			jr strcmp 
1191				 
1191				 
1191			 
1191			;Copyright (c) 2014, Luke Maurits 
1191			;All rights reserved. 
1191			; 
1191			;Redistribution and use in source and binary forms, with or without 
1191			;modification, are permitted provided that the following conditions are met: 
1191			; 
1191			;* Redistributions of source code must retain the above copyright notice, this 
1191			;  list of conditions and the following disclaimer. 
1191			; 
1191			;* Redistributions in binary form must reproduce the above copyright notice, 
1191			;  this list of conditions and the following disclaimer in the documentation 
1191			;  and/or other materials provided with the distribution. 
1191			; 
1191			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
1191			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
1191			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
1191			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
1191			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
1191			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
1191			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
1191			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
1191			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
1191			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
1191			 
1191			; https://github.com/lmaurits/lm512/blob/master/string.z80 
1191			 
1191			StrictStrCmp: 
1191				; Load next chars of each string 
1191 1a				ld a, (de) 
1192 47				ld b, a 
1193 7e				ld a, (hl) 
1194				; Compare 
1194 b8				cp b 
1195				; Return non-zero if chars don't match 
1195 c0				ret nz 
1196				; Check for end of both strings 
1196 fe 00			cp "\0" 
1198				; Return if strings have ended 
1198 c8				ret z 
1199				; Otherwise, advance to next chars 
1199 23				inc hl 
119a 13				inc de 
119b 18 f4			jr StrictStrCmp 
119d			 
119d			;end 
119d			; eof 
119d			 
119d			 
119d			 
119d			 
119d			 
119d			 
# End of file firmware_strings.asm
119d			include "firmware_memory.asm"   ; malloc and free  
119d			 
119d			if DEBUG_FORTH_MALLOC_HIGH 
119d			.mallocsize: db "Wants malloc >256",0 
119d			.mallocasize: db "MALLOC gives >256",0 
119d			.malloczero: db "MALLOC gives zero",0 
119d			 
119d			malloc_guard_zerolen: 
119d				push hl 
119d				push de 
119d				push af 
119d			 
119d				ld de, 0 
119d			        call cmp16 
119d				jr nz, .lowalloz 
119d			 
119d				push hl 
119d				push de 
119d					ld hl, display_fb0 
119d					ld (display_fb_active), hl 
119d				call clear_display 
119d				ld a, 0 
119d				ld de, .malloczero 
119d				call str_at_display 
119d				call update_display 
119d				call delay1s 
119d				call delay1s 
119d				call bp_on 
119d			;	ld a, 0 
119d			;	ld (os_view_disable), a 
119d			 
119d				pop de 
119d				pop hl 
119d			 
119d				 
119d			 
119d				CALLMONITOR 
119d			.lowalloz: 
119d			 
119d			 
119d				pop af 
119d				pop de 
119d				pop hl 
119d			ret 
119d			 
119d			malloc_guard_entry: 
119d				push hl 
119d				push de 
119d				push af 
119d			 
119d			 	or a      ;clear carry flag 
119d				push hl 
119d				ld de, 255 
119d				sbc hl, de 
119d				jr c, .lowalloc 
119d			 
119d				push de 
119d					ld hl, display_fb0 
119d					ld (display_fb_active), hl 
119d				call clear_display 
119d				ld a, 0 
119d				ld de, .mallocsize 
119d				call str_at_display 
119d				call update_display 
119d				call delay1s 
119d				call delay1s 
119d			;	ld a, 0 
119d			;	ld (os_view_disable), a 
119d				call bp_on 
119d			 
119d				pop de 
119d				pop hl 
119d			 
119d				 
119d			 
119d				CALLMONITOR 
119d				jr .lowdone 
119d			.lowalloc: 
119d			 
119d			 
119d				pop hl 
119d			.lowdone:	pop af 
119d				pop de 
119d				pop hl 
119d			ret 
119d			 
119d			malloc_guard_exit: 
119d				push hl 
119d				push de 
119d				push af 
119d			 
119d			 	or a      ;clear carry flag 
119d				push hl 
119d				ld de, 255 
119d				sbc hl, de 
119d				jr c, .lowallocx 
119d			 
119d				push de 
119d					ld hl, display_fb0 
119d					ld (display_fb_active), hl 
119d				call clear_display 
119d				ld a, 0 
119d				ld de, .mallocasize 
119d				call str_at_display 
119d				call update_display 
119d				call delay1s 
119d				call delay1s 
119d			;	ld a, 0 
119d			;	ld (os_view_disable), a 
119d				call bp_on 
119d				pop de 
119d				pop hl 
119d			 
119d				CALLMONITOR 
119d				jr .lowdonex 
119d			.lowallocx: 
119d			 
119d				pop hl 
119d			.lowdonex:	pop af 
119d				pop de 
119d				pop hl 
119d			ret 
119d			endif 
119d			 
119d			if MALLOC_2 
119d			; Z80 Malloc and Free Functions 
119d			 
119d			; Malloc Function: 
119d			; Input: 
119d			;   HL: Size of block to allocate 
119d			; Output: 
119d			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
119d			 
119d			malloc: 
119d				 
119d			if DEBUG_FORTH_MALLOC_HIGH 
119d			call malloc_guard_entry 
119d			endif 
119d			 
119d			 
119d			 
119d			 
119d					if DEBUG_FORTH_MALLOC 
119d						DMARK "mal" 
119d						CALLMONITOR 
119d					endif 
119d			    push af            ; Save AF register 
119d			    ld a, l            ; Load low byte of size into A 
119d			    or h               ; Check if size is zero 
119d			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
119d			 
119d			    ; Allocate memory 
119d			    ld hl, (heap_start) ; Load start of heap into HL 
119d					if DEBUG_FORTH_MALLOC 
119d						DMARK "ma1" 
119d						CALLMONITOR 
119d					endif 
119d			    call malloc_internal ; Call internal malloc function 
119d			    pop af             ; Restore AF register 
119d			if DEBUG_FORTH_MALLOC_HIGH 
119d			call malloc_guard_exit 
119d			call malloc_guard_zerolen 
119d			endif 
119d			    ret                ; Return 
119d			 
119d			; Free Function: 
119d			; Input: 
119d			;   HL: Pointer to memory block to free 
119d			; Output: 
119d			;   None 
119d			 
119d			free: 
119d			    push af            ; Save AF register 
119d			    ld a, l            ; Load low byte of pointer into A 
119d			    or h               ; Check if pointer is NULL 
119d			    jp z, free_exit    ; If pointer is NULL, exit 
119d			 
119d			    ; Free memory 
119d			    ld hl, (heap_start) ; Load start of heap into HL 
119d			    call free_internal  ; Call internal free function 
119d			    pop af             ; Restore AF register 
119d			    ret                ; Return 
119d			 
119d			; Internal Malloc Function: 
119d			; Input: 
119d			;   HL: Size of block to allocate 
119d			; Output: 
119d			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
119d			 
119d			malloc_internal: 
119d			    ld bc, 2           ; Number of bytes to allocate for management overhead 
119d			    add hl, bc         ; Add management overhead to requested size 
119d			    ex de, hl          ; Save total size in DE, and keep it in HL 
119d					if DEBUG_FORTH_MALLOC 
119d						DMARK "ma2" 
119d						CALLMONITOR 
119d					endif 
119d			 
119d			    ; Search for free memory block 
119d			    ld de, (heap_end)  ; Load end of heap into DE 
119d			    ld bc, 0           ; Initialize counter 
119d			 
119d					if DEBUG_FORTH_MALLOC 
119d						DMARK "ma2" 
119d						CALLMONITOR 
119d					endif 
119d			malloc_search_loop: 
119d			    ; Check if current block is free 
119d			    ld a, (hl)         ; Load current block's status (free or used) 
119d			    cp 0               ; Compare with zero (free) 
119d			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
119d			 
119d			    ; Check if current block is large enough 
119d			    ld a, (hl+1)       ; Load high byte of block size 
119d			    cp l               ; Compare with low byte of requested size 
119d			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
119d			 
119d			    ld a, (hl+2)       ; Load low byte of block size 
119d			    cp h               ; Compare with high byte of requested size 
119d			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
119d			 
119d			    ; Mark block as used 
119d			    ld (hl), 0xFF      ; Set status byte to indicate used block 
119d			 
119d			    ; Calculate remaining space in block 
119d			    ld bc, 0           ; Clear BC 
119d			    add hl, bc         ; Increment HL to point to start of data block 
119d			    add hl, de         ; HL = HL + DE (total size) 
119d			    ld bc, 1           ; Number of bytes to allocate for management overhead 
119d			    add hl, bc         ; Add management overhead to start of data block 
119d			 
119d			    ; Save pointer to allocated block in HL 
119d			if DEBUG_FORTH_MALLOC_HIGH 
119d						DMARK "ma5" 
119d			call malloc_guard_exit 
119d			call malloc_guard_zerolen 
119d			endif 
119d			    ret 
119d			 
119d			malloc_skip_block_check: 
119d			    ; Move to the next block 
119d			    ld bc, 3           ; Size of management overhead 
119d			    add hl, bc         ; Move to the next block 
119d			    inc de             ; Increment counter 
119d			 
119d			    ; Check if we have reached the end of heap 
119d			    ld a, e            ; Load low byte of heap end address 
119d			    cp (hl)            ; Compare with low byte of current address 
119d			    jr nz, malloc_search_loop  ; If not equal, continue searching 
119d			    ld a, d            ; Load high byte of heap end address 
119d			    cp 0               ; Check if it's zero (end of memory) 
119d			    jr nz, malloc_search_loop  ; If not zero, continue searching 
119d			 
119d			    ; If we reached here, allocation failed 
119d			    xor a              ; Set result to NULL 
119d			if DEBUG_FORTH_MALLOC_HIGH 
119d						DMARK "ma6" 
119d			call malloc_guard_exit 
119d			call malloc_guard_zerolen 
119d			endif 
119d			    ret 
119d			malloc_exit: 
119d			if DEBUG_FORTH_MALLOC_HIGH 
119d						DMARK "ma7" 
119d			call malloc_guard_exit 
119d			call malloc_guard_zerolen 
119d			endif 
119d			    ret 
119d			 
119d			; Internal Free Function: 
119d			; Input: 
119d			;   HL: Pointer to memory block to free 
119d			; Output: 
119d			;   None 
119d			 
119d			free_internal: 
119d			    ld de, (heap_start) ; Load start of heap into DE 
119d			    ld bc, 0            ; Initialize counter 
119d			 
119d			free_search_loop: 
119d			    ; Check if current block contains the pointer 
119d			    ld a, l             ; Load low byte of pointer 
119d			    cp (hl+1)           ; Compare with high byte of current block's address 
119d			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
119d			    ld a, h             ; Load high byte of pointer 
119d			    cp (hl+2)           ; Compare with low byte of current block's address 
119d			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
119d			 
119d			    ; Mark block as free 
119d			    ld (hl), 0          ; Set status byte to indicate free block 
119d			    ret                 ; Return 
119d			 
119d			free_skip_block_check: 
119d			    ; Move to the next block 
119d			    ld bc, 3            ; Size of management overhead 
119d			    add hl, bc          ; Move to the next block 
119d			    inc de              ; Increment counter 
119d			 
119d			    ; Check if we have reached the end of heap 
119d			    ld a, e             ; Load low byte of heap end address 
119d			    cp (hl)             ; Compare with low byte of current address 
119d			    jr nz, free_search_loop  ; If not equal, continue searching 
119d			    ld a, d             ; Load high byte of heap end address 
119d			    cp 0                ; Check if it's zero (end of memory) 
119d			    jr nz, free_search_loop  ; If not zero, continue searching 
119d			 
119d			    ; If we reached here, pointer is not found in heap 
119d			    ret 
119d			 
119d			free_exit: 
119d			    ret                 ; Return 
119d			 
119d			; Define heap start and end addresses 
119d			;heap_start:    .dw 0xC000   ; Start of heap 
119d			;heap_end:      .dw 0xE000   ; End of heap 
119d			 
119d			endif 
119d			 
119d			 
119d			if MALLOC_1 
119d			 
119d			 
119d			 
119d			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
119d			 
119d			;moved to firmware.asm 
119d			;heap_start        .equ  0x9000      ; Starting address of heap 
119d			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
119d			 
119d			;      .org 0 
119d			;      jp    main 
119d			 
119d			 
119d			;      .org  0x100 
119d			;main: 
119d			;      ld    HL, 0x8100 
119d			;      ld    SP, HL 
119d			; 
119d			;      call  heap_init 
119d			; 
119d			;      ; Make some allocations 
119d			;      ld    HL, 12 
119d			;      call  malloc            ; Allocates 0x9004 
119d			; 
119d			;      ld    HL, 12 
119d			;      call  malloc            ; Allocates 0x9014 
119d			; 
119d			;      ld    HL, 12 
119d			;      call  malloc            ; Allocates 0x9024 
119d			; 
119d			;      ; Free some allocations 
119d			;      ld    HL, 0x9014 
119d			;      call  free 
119d			; 
119d			;      ld    HL, 0x9004 
119d			;      call  free 
119d			; 
119d			;      ld    HL, 0x9024 
119d			;      call  free 
119d			; 
119d			; 
119d			;      halt 
119d			 
119d			 
119d			;------------------------------------------------------------------------------ 
119d			;     heap_init                                                               : 
119d			;                                                                             : 
119d			; Description                                                                 : 
119d			;     Initialise the heap and make it ready for malloc and free operations.   : 
119d			;                                                                             : 
119d			;     The heap is maintained as a linked list, starting with an initial       : 
119d			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
119d			;     the first free block in the heap. Each block then points to the next    : 
119d			;     free block within the heap, and the free list ends at the first block   : 
119d			;     with a null pointer to the next free block.                             : 
119d			;                                                                             : 
119d			; Parameters                                                                  : 
119d			;     Inputs are compile-time only. Two defines which specify the starting    : 
119d			;     address of the heap and its size are required, along with a memory      : 
119d			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
119d			;     principally stores a pointer to the first free block in the heap.       : 
119d			;                                                                             : 
119d			; Returns                                                                     : 
119d			;     Nothing                                                                 : 
119d			;------------------------------------------------------------------------------ 
119d			heap_init: 
119d e5			      push  HL 
119e			 
119e			      ; Initialise free list struct 
119e 21 75 5e		      ld    HL, heap_start 
11a1 22 70 5e		      ld    (free_list), HL 
11a4 21 00 00		      ld    HL, 0 
11a7 22 72 5e		      ld    (free_list+2), HL 
11aa			 
11aa			      ; Insert first free block at bottom of heap, consumes entire heap 
11aa 21 98 e2		      ld    HL, heap_start+heap_size-4 
11ad 22 75 5e		      ld    (heap_start), HL        ; Next block (end of free list) 
11b0 21 23 84		      ld    HL, heap_size-4 
11b3 22 77 5e		      ld    (heap_start+2), HL      ; Block size 
11b6			 
11b6			      ; Insert end of free list block at top of heap - two null words will 
11b6			      ; terminate the free list 
11b6 21 00 00		      ld    HL, 0 
11b9 22 9a e2		      ld    (heap_start+heap_size-2), HL 
11bc 22 98 e2		      ld    (heap_start+heap_size-4), HL 
11bf			 
11bf e1			      pop   HL 
11c0			 
11c0 c9			      ret 
11c1			 
11c1			 
11c1			;------------------------------------------------------------------------------ 
11c1			;     malloc                                                                  : 
11c1			;                                                                             : 
11c1			; Description                                                                 : 
11c1			;     Allocates the wanted space from the heap and returns the address of the : 
11c1			;     first useable byte of the allocation.                                   : 
11c1			;                                                                             : 
11c1			;     Allocations can happen in one of two ways:                              : 
11c1			;                                                                             : 
11c1			;     1. A free block may be found which is the exact size wanted. In this    : 
11c1			;        case the block is removed from the free list and retuedn to the      : 
11c1			;        caller.                                                              : 
11c1			;     2. A free block may be found which is larger than the size wanted. In   : 
11c1			;        this case, the larger block is split into two. The first portion of  : 
11c1			;        this block will become the requested space by the malloc call and    : 
11c1			;        is returned to the caller. The second portion becomes a new free     : 
11c1			;        block, and the free list is adjusted to maintain continuity via this : 
11c1			;        newly created block.                                                 : 
11c1			;                                                                             : 
11c1			;     malloc does not set any initial value in the allocated space, the       : 
11c1			;     caller is required to do this as required.                              : 
11c1			;                                                                             : 
11c1			;     This implementation of malloc uses the stack exclusively, and is        : 
11c1			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11c1			;     advisable to disable interrupts before calling malloc, and recommended  : 
11c1			;     to avoid the use of malloc inside ISRs in general.                      : 
11c1			;                                                                             : 
11c1			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11c1			;                                                                             : 
11c1			; Parameters                                                                  : 
11c1			;     HL  Number of bytes wanted                                              : 
11c1			;                                                                             : 
11c1			; Returns                                                                     : 
11c1			;     HL  Address of the first useable byte of the allocation                 : 
11c1			;                                                                             : 
11c1			; Flags                                                                       : 
11c1			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11c1			;                                                                             : 
11c1			; Stack frame                                                                 : 
11c1			;       |             |                                                       : 
11c1			;       +-------------+                                                       : 
11c1			;       |     BC      |                                                       : 
11c1			;       +-------------+                                                       : 
11c1			;       |     DE      |                                                       : 
11c1			;       +-------------+                                                       : 
11c1			;       |     IX      |                                                       : 
11c1			;       +-------------+                                                       : 
11c1			;       |  prev_free  |                                                       : 
11c1			;   +4  +-------------+                                                       : 
11c1			;       |  this_free  |                                                       : 
11c1			;   +2  +-------------+                                                       : 
11c1			;       |  next_free  |                                                       : 
11c1			;   +0  +-------------+                                                       : 
11c1			;       |             |                                                       : 
11c1			;                                                                             : 
11c1			;------------------------------------------------------------------------------ 
11c1			 
11c1			 
11c1			;malloc: 
11c1			; 
11c1			;	SAVESP ON 1 
11c1			; 
11c1			;	call malloc_code 
11c1			; 
11c1			;	CHECKSP ON 1 
11c1			;	ret 
11c1			 
11c1			 
11c1			malloc: 
11c1 c5			      push  BC 
11c2 d5			      push  DE 
11c3 dd e5		      push  IX 
11c5			if DEBUG_FORTH_MALLOC_HIGH 
11c5			call malloc_guard_entry 
11c5			endif 
11c5			 
11c5					if DEBUG_FORTH_MALLOC 
11c5						DMARK "mal" 
11c5						CALLMONITOR 
11c5					endif 
11c5 7c			      ld    A, H                    ; Exit if no space requested 
11c6 b5			      or    L 
11c7 ca 86 12		      jp    Z, malloc_early_exit 
11ca			 
11ca			;inc hl 
11ca			;inc hl 
11ca			;inc hl 
11ca			; 
11ca			;inc hl 
11ca			;inc hl 
11ca			;inc hl 
11ca			;inc hl 
11ca			;inc hl 
11ca			;inc hl 
11ca			;inc hl 
11ca			;inc hl 
11ca			;inc hl 
11ca			 
11ca			 
11ca			 
11ca			 
11ca					if DEBUG_FORTH_MALLOC 
11ca						DMARK "maA" 
11ca						CALLMONITOR 
11ca					endif 
11ca			      ; Set up stack frame 
11ca eb			      ex    DE, HL 
11cb 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11ce 39			      add   HL, SP 
11cf f9			      ld    SP, HL 
11d0 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11d4 dd 39		      add   IX, SP 
11d6			 
11d6			      ; Setup initial state 
11d6 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11d9 19			      add   HL, DE 
11da			 
11da 44			      ld    B, H                    ; Move want to BC 
11db 4d			      ld    C, L 
11dc			 
11dc 21 70 5e		      ld    HL, free_list           ; Store prev_free ptr to stack 
11df dd 75 04		      ld    (IX+4), L 
11e2 dd 74 05		      ld    (IX+5), H 
11e5			 
11e5 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11e6 23			      inc   HL 
11e7 56			      ld    D, (HL) 
11e8 dd 73 02		      ld    (IX+2), E 
11eb dd 72 03		      ld    (IX+3), D 
11ee eb			      ex    DE, HL                  ; this_free ptr into HL 
11ef			 
11ef					if DEBUG_FORTH_MALLOC 
11ef						DMARK "maB" 
11ef						CALLMONITOR 
11ef					endif 
11ef			      ; Loop through free block list to find some space 
11ef			malloc_find_space: 
11ef 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11f0 23			      inc   HL 
11f1 56			      ld    D, (HL) 
11f2			 
11f2 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
11f3 b3			      or    E 
11f4 ca 80 12		      jp    Z, malloc_no_space 
11f7			 
11f7 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
11fa dd 72 01		      ld    (IX+1), D 
11fd			 
11fd			      ; Does this block have enough space to make the allocation? 
11fd 23			      inc   HL                      ; Load free block size into DE 
11fe 5e			      ld    E, (HL) 
11ff 23			      inc   HL 
1200 56			      ld    D, (HL) 
1201			 
1201 eb			      ex    DE, HL                  ; Check size of block against want 
1202 b7			      or    A                       ; Ensure carry flag clear 
1203 ed 42		      sbc   HL, BC 
1205 e5			      push  HL                      ; Store the result for later (new block size) 
1206			 
1206 ca 55 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1209 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
120b			 
120b			      ; this_free block is not big enough, setup ptrs to test next free block 
120b e1			      pop   HL                      ; Discard previous result 
120c			 
120c dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
120f dd 66 03		      ld    H, (IX+3) 
1212 dd 75 04		      ld    (IX+4), L 
1215 dd 74 05		      ld    (IX+5), H 
1218			 
1218 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
121b dd 66 01		      ld    H, (IX+1) 
121e dd 75 02		      ld    (IX+2), L 
1221 dd 74 03		      ld    (IX+3), H 
1224			 
1224					if DEBUG_FORTH_MALLOC 
1224						DMARK "MA>" 
1224						CALLMONITOR 
1224					endif 
1224 18 c9		      jr    malloc_find_space 
1226			 
1226			      ; split a bigger block into two - requested size and remaining size 
1226			malloc_alloc_split: 
1226					if DEBUG_FORTH_MALLOC 
1226						DMARK "MAs" 
1226						CALLMONITOR 
1226					endif 
1226 eb			      ex    DE, HL                  ; Calculate address of new free block 
1227 2b			      dec   HL 
1228 2b			      dec   HL 
1229 2b			      dec   HL 
122a 09			      add   HL, BC 
122b			 
122b			      ; Create a new block and point it at next_free 
122b dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
122e dd 56 01		      ld    D, (IX+1) 
1231			 
1231 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1232 23			      inc   HL 
1233 72			      ld    (HL), D 
1234			 
1234 d1			      pop   DE                      ; Store size of new block into new block 
1235 23			      inc   HL 
1236 73			      ld    (HL), E 
1237 23			      inc   HL 
1238 72			      ld    (HL), D 
1239			 
1239			      ; Update this_free ptr to point to new block 
1239 2b			      dec   HL 
123a 2b			      dec   HL 
123b 2b			      dec   HL 
123c			 
123c dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
123f dd 56 03		      ld    D, (IX+3) 
1242			 
1242 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1245 dd 74 03		      ld    (IX+3), H 
1248			 
1248			      ; Modify this_free block to be allocation 
1248 eb			      ex    DE, HL 
1249 af			      xor   A                       ; Null the next block ptr of allocated block 
124a 77			      ld    (HL), A 
124b 23			      inc   HL 
124c 77			      ld    (HL), A 
124d			 
124d 23			      inc   HL                      ; Store want size into allocated block 
124e 71			      ld    (HL), C 
124f 23			      inc   HL 
1250 70			      ld    (HL), B 
1251 23			      inc   HL 
1252 e5			      push  HL                      ; Address of allocation to return 
1253			 
1253 18 19		      jr    malloc_update_links 
1255			 
1255			malloc_alloc_fit: 
1255 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1256			 
1256					if DEBUG_FORTH_MALLOC 
1256						DMARK "MAf" 
1256						CALLMONITOR 
1256					endif 
1256			      ; Modify this_free block to be allocation 
1256 eb			      ex    DE, HL 
1257 2b			      dec   HL 
1258 2b			      dec   HL 
1259 2b			      dec   HL 
125a			 
125a af			      xor   A                       ; Null the next block ptr of allocated block 
125b 77			      ld    (HL), A 
125c 23			      inc   HL 
125d 77			      ld    (HL), A 
125e			 
125e 23			      inc   HL                      ; Store address of allocation to return 
125f 23			      inc   HL 
1260 23			      inc   HL 
1261 e5			      push  HL 
1262			 
1262			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1262 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1265 dd 66 01		      ld    H, (IX+1) 
1268			 
1268 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
126b dd 74 03		      ld    (IX+3), H 
126e			 
126e			 
126e			malloc_update_links: 
126e			      ; Update prev_free ptr to point to this_free 
126e dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1271 dd 66 05		      ld    H, (IX+5) 
1274			 
1274 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1277 dd 56 03		      ld    D, (IX+3) 
127a			 
127a 73			      ld    (HL), E                 ; this_free ptr into prev_free 
127b 23			      inc   HL 
127c 72			      ld    (HL), D 
127d			 
127d					if DEBUG_FORTH_MALLOC 
127d						DMARK "Mul" 
127d						CALLMONITOR 
127d					endif 
127d			      ; Clear the Z flag to indicate successful allocation 
127d 7a			      ld    A, D 
127e b3			      or    E 
127f			 
127f d1			      pop   DE                      ; Address of allocation 
1280					if DEBUG_FORTH_MALLOC 
1280						DMARK "MAu" 
1280						CALLMONITOR 
1280					endif 
1280			 
1280			malloc_no_space: 
1280 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1283 39			      add   HL, SP 
1284 f9			      ld    SP, HL 
1285			 
1285 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1286					if DEBUG_FORTH_MALLOC 
1286						DMARK "MAN" 
1286						CALLMONITOR 
1286					endif 
1286			 
1286			malloc_early_exit: 
1286					if DEBUG_FORTH_MALLOC 
1286						DMARK "MAx" 
1286						CALLMONITOR 
1286					endif 
1286 dd e1		      pop   IX 
1288 d1			      pop   DE 
1289 c1			      pop   BC 
128a			 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a c9			      ret 
128b			 
128b			 
128b			;------------------------------------------------------------------------------ 
128b			;     free                                                                    : 
128b			;                                                                             : 
128b			; Description                                                                 : 
128b			;     Return the space pointed to by HL to the heap. HL must be an address as : 
128b			;     returned by malloc, otherwise the behaviour is undefined.               : 
128b			;                                                                             : 
128b			;     Where possible, directly adjacent free blocks will be merged together   : 
128b			;     into larger blocks to help ensure that the heap does not become         : 
128b			;     excessively fragmented.                                                 : 
128b			;                                                                             : 
128b			;     free does not clear or set any other value into the freed space, and    : 
128b			;     therefore its contents may be visible through subsequent malloc's. The  : 
128b			;     caller should clear the freed space as required.                        : 
128b			;                                                                             : 
128b			;     This implementation of free uses the stack exclusively, and is          : 
128b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
128b			;     advisable to disable interrupts before calling free, and recommended    : 
128b			;     to avoid the use of free inside ISRs in general.                        : 
128b			;                                                                             : 
128b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
128b			;                                                                             : 
128b			; Parameters                                                                  : 
128b			;     HL  Pointer to address of first byte of allocation to be freed          : 
128b			;                                                                             : 
128b			; Returns                                                                     : 
128b			;     Nothing                                                                 : 
128b			;                                                                             : 
128b			; Stack frame                                                                 : 
128b			;       |             |                                                       : 
128b			;       +-------------+                                                       : 
128b			;       |     BC      |                                                       : 
128b			;       +-------------+                                                       : 
128b			;       |     DE      |                                                       : 
128b			;       +-------------+                                                       : 
128b			;       |     IX      |                                                       : 
128b			;       +-------------+                                                       : 
128b			;       |  prev_free  |                                                       : 
128b			;   +2  +-------------+                                                       : 
128b			;       |  next_free  |                                                       : 
128b			;   +0  +-------------+                                                       : 
128b			;       |             |                                                       : 
128b			;                                                                             : 
128b			;------------------------------------------------------------------------------ 
128b			free: 
128b c5			      push  BC 
128c d5			      push  DE 
128d dd e5		      push  IX 
128f			 
128f 7c			      ld    A, H                    ; Exit if ptr is null 
1290 b5			      or    L 
1291 ca 55 13		      jp    Z, free_early_exit 
1294			 
1294			      ; Set up stack frame 
1294 eb			      ex    DE, HL 
1295 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1298 39			      add   HL, SP 
1299 f9			      ld    SP, HL 
129a dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
129e dd 39		      add   IX, SP 
12a0			 
12a0			      ; The address in HL points to the start of the useable allocated space, 
12a0			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12a0			      ; address of the block itself. 
12a0 eb			      ex    DE, HL 
12a1 11 fc ff		      ld    DE, -4 
12a4 19			      add   HL, DE 
12a5			 
12a5			      ; An allocated block must have a null next block pointer in it 
12a5 7e			      ld    A, (HL) 
12a6 23			      inc   HL 
12a7 b6			      or    (HL) 
12a8 c2 50 13		      jp    NZ, free_done 
12ab			 
12ab 2b			      dec   HL 
12ac			 
12ac 44			      ld    B, H                    ; Copy HL to BC 
12ad 4d			      ld    C, L 
12ae			 
12ae			      ; Loop through the free list to find the first block with an address 
12ae			      ; higher than the block being freed 
12ae 21 70 5e		      ld    HL, free_list 
12b1			 
12b1			free_find_higher_block: 
12b1 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12b2 23			      inc   HL 
12b3 56			      ld    D, (HL) 
12b4 2b			      dec   HL 
12b5			 
12b5 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12b8 dd 72 01		      ld    (IX+1), D 
12bb dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12be dd 74 03		      ld    (IX+3), H 
12c1			 
12c1 78			      ld    A, B                    ; Check if DE is greater than BC 
12c2 ba			      cp    D                       ; Compare MSB first 
12c3 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12c5 30 04		      jr    NC, free_find_higher_block_skip 
12c7 79			      ld    A, C 
12c8 bb			      cp    E                       ; Then compare LSB 
12c9 38 08		      jr    C, free_found_higher_block 
12cb			 
12cb			free_find_higher_block_skip: 
12cb 7a			      ld    A, D                    ; Reached the end of the free list? 
12cc b3			      or    E 
12cd ca 50 13		      jp    Z, free_done 
12d0			 
12d0 eb			      ex    DE, HL 
12d1			 
12d1 18 de		      jr    free_find_higher_block 
12d3			 
12d3			free_found_higher_block: 
12d3			      ; Insert freed block between prev and next free blocks 
12d3 71			      ld    (HL), C                 ; Point prev free block to freed block 
12d4 23			      inc   HL 
12d5 70			      ld    (HL), B 
12d6			 
12d6 60			      ld    H, B                    ; Point freed block at next free block 
12d7 69			      ld    L, C 
12d8 73			      ld    (HL), E 
12d9 23			      inc   HL 
12da 72			      ld    (HL), D 
12db			 
12db			      ; Check if the freed block is adjacent to the next free block 
12db 23			      inc   HL                      ; Load size of freed block into HL 
12dc 5e			      ld    E, (HL) 
12dd 23			      inc   HL 
12de 56			      ld    D, (HL) 
12df eb			      ex    DE, HL 
12e0			 
12e0 09			      add   HL, BC                  ; Add addr of freed block and its size 
12e1			 
12e1 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12e4 dd 56 01		      ld    D, (IX+1) 
12e7			 
12e7 b7			      or    A                       ; Clear the carry flag 
12e8 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12ea 20 22		      jr    NZ, free_check_adjacent_to_prev 
12ec			 
12ec			      ; Freed block is adjacent to next, merge into one bigger block 
12ec eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12ed 5e			      ld    E, (HL) 
12ee 23			      inc   HL 
12ef 56			      ld    D, (HL) 
12f0 e5			      push  HL                      ; Save ptr to next block for later 
12f1			 
12f1 60			      ld    H, B                    ; Store ptr from next block into freed block 
12f2 69			      ld    L, C 
12f3 73			      ld    (HL), E 
12f4 23			      inc   HL 
12f5 72			      ld    (HL), D 
12f6			 
12f6 e1			      pop   HL                      ; Restore ptr to next block 
12f7 23			      inc   HL                      ; Load size of next block into DE 
12f8 5e			      ld    E, (HL) 
12f9 23			      inc   HL 
12fa 56			      ld    D, (HL) 
12fb d5			      push  DE                      ; Save next block size for later 
12fc			 
12fc 60			      ld    H, B                    ; Load size of freed block into HL 
12fd 69			      ld    L, C 
12fe 23			      inc   HL 
12ff 23			      inc   HL 
1300 5e			      ld    E, (HL) 
1301 23			      inc   HL 
1302 56			      ld    D, (HL) 
1303 eb			      ex    DE, HL 
1304			 
1304 d1			      pop   DE                      ; Restore size of next block 
1305 19			      add   HL, DE                  ; Add sizes of both blocks 
1306 eb			      ex    DE, HL 
1307			 
1307 60			      ld    H, B                    ; Store new bigger size into freed block 
1308 69			      ld    L, C 
1309 23			      inc   HL 
130a 23			      inc   HL 
130b 73			      ld    (HL), E 
130c 23			      inc   HL 
130d 72			      ld    (HL), D 
130e			 
130e			free_check_adjacent_to_prev: 
130e			      ; Check if the freed block is adjacent to the prev free block 
130e dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1311 dd 66 03		      ld    H, (IX+3) 
1314			 
1314 23			      inc   HL                      ; Size of prev free block into DE 
1315 23			      inc   HL 
1316 5e			      ld    E, (HL) 
1317 23			      inc   HL 
1318 56			      ld    D, (HL) 
1319 2b			      dec   HL 
131a 2b			      dec   HL 
131b 2b			      dec   HL 
131c			 
131c 19			      add   HL, DE                  ; Add prev block addr and size 
131d			 
131d b7			      or    A                       ; Clear the carry flag 
131e ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1320 20 2e		      jr    NZ, free_done 
1322			 
1322			      ; Freed block is adjacent to prev, merge into one bigger block 
1322 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1323 69			      ld    L, C 
1324 5e			      ld    E, (HL) 
1325 23			      inc   HL 
1326 56			      ld    D, (HL) 
1327 e5			      push  HL                      ; Save freed block ptr for later 
1328			 
1328 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
132b dd 66 03		      ld    H, (IX+3) 
132e 73			      ld    (HL), E 
132f 23			      inc   HL 
1330 72			      ld    (HL), D 
1331			 
1331 e1			      pop   HL                      ; Restore freed block ptr 
1332 23			      inc   HL                      ; Load size of freed block into DE 
1333 5e			      ld    E, (HL) 
1334 23			      inc   HL 
1335 56			      ld    D, (HL) 
1336 d5			      push  DE                      ; Save freed block size for later 
1337			 
1337 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
133a dd 66 03		      ld    H, (IX+3) 
133d 23			      inc   HL 
133e 23			      inc   HL 
133f 5e			      ld    E, (HL) 
1340 23			      inc   HL 
1341 56			      ld    D, (HL) 
1342			 
1342 e1			      pop   HL                      ; Add sizes of both blocks 
1343 19			      add   HL, DE 
1344 eb			      ex    DE, HL 
1345			 
1345 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1348 dd 66 03		      ld    H, (IX+3) 
134b 23			      inc   HL 
134c 23			      inc   HL 
134d 73			      ld    (HL), E 
134e 23			      inc   HL 
134f 72			      ld    (HL), D 
1350			 
1350			free_done: 
1350 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1353 39			      add   HL, SP 
1354 f9			      ld    SP, HL 
1355			 
1355			free_early_exit: 
1355 dd e1		      pop   IX 
1357 d1			      pop   DE 
1358 c1			      pop   BC 
1359			 
1359 c9			      ret 
135a			 
135a			; moved to firmware.asm 
135a			; 
135a			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
135a			;                  .dw   0 
135a			 
135a			 
135a			endif 
135a			 
135a			 
135a			if MALLOC_3 
135a			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
135a			;heap_start        .equ  0x9000      ; Starting address of heap 
135a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
135a			; 
135a			 ;     .org 0 
135a			  ;    jp    main 
135a			; 
135a			; 
135a			 ;     .org  0x100 
135a			;main: 
135a			 ;     ld    HL, 0x8100 
135a			  ;    ld    SP, HL 
135a			; 
135a			;      call  heap_init 
135a			 
135a			      ; Make some allocations 
135a			;      ld    HL, 12 
135a			;      call  malloc            ; Allocates 0x9004 
135a			; 
135a			 ;     ld    HL, 12 
135a			;      call  malloc            ; Allocates 0x9014 
135a			 
135a			;      ld    HL, 12 
135a			;      call  malloc            ; Allocates 0x9024 
135a			 
135a			      ; Free some allocations 
135a			;      ld    HL, 0x9014 
135a			;      call  free 
135a			 
135a			;      ld    HL, 0x9004 
135a			;      call  free 
135a			; 
135a			;      ld    HL, 0x9024 
135a			;      call  free 
135a			 
135a			 
135a			 ;     halt 
135a			 
135a			 
135a			;------------------------------------------------------------------------------ 
135a			;     heap_init                                                               : 
135a			;                                                                             : 
135a			; Description                                                                 : 
135a			;     Initialise the heap and make it ready for malloc and free operations.   : 
135a			;                                                                             : 
135a			;     The heap is maintained as a linked list, starting with an initial       : 
135a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
135a			;     the first free block in the heap. Each block then points to the next    : 
135a			;     free block within the heap, and the free list ends at the first block   : 
135a			;     with a null pointer to the next free block.                             : 
135a			;                                                                             : 
135a			; Parameters                                                                  : 
135a			;     Inputs are compile-time only. Two defines which specify the starting    : 
135a			;     address of the heap and its size are required, along with a memory      : 
135a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
135a			;     principally stores a pointer to the first free block in the heap.       : 
135a			;                                                                             : 
135a			; Returns                                                                     : 
135a			;     Nothing                                                                 : 
135a			;------------------------------------------------------------------------------ 
135a			heap_init: 
135a			      push  HL 
135a			 
135a			      ; Initialise free list struct 
135a			      ld    HL, heap_start 
135a			      ld    (free_list), HL 
135a			      ld    HL, 0 
135a			      ld    (free_list+2), HL 
135a			 
135a			      ; Insert first free block at bottom of heap, consumes entire heap 
135a			      ld    HL, heap_start+heap_size-4 
135a			      ld    (heap_start), HL        ; Next block (end of free list) 
135a			      ld    HL, heap_size-4 
135a			      ld    (heap_start+2), HL      ; Block size 
135a			 
135a			      ; Insert end of free list block at top of heap - two null words will 
135a			      ; terminate the free list 
135a			      ld    HL, 0 
135a			      ld    (heap_start+heap_size-2), HL 
135a			      ld    (heap_start+heap_size-4), HL 
135a			 
135a			      pop   HL 
135a			 
135a			      ret 
135a			 
135a			 
135a			;------------------------------------------------------------------------------ 
135a			;     malloc                                                                  : 
135a			;                                                                             : 
135a			; Description                                                                 : 
135a			;     Allocates the wanted space from the heap and returns the address of the : 
135a			;     first useable byte of the allocation.                                   : 
135a			;                                                                             : 
135a			;     Allocations can happen in one of two ways:                              : 
135a			;                                                                             : 
135a			;     1. A free block may be found which is the exact size wanted. In this    : 
135a			;        case the block is removed from the free list and retuedn to the      : 
135a			;        caller.                                                              : 
135a			;     2. A free block may be found which is larger than the size wanted. In   : 
135a			;        this case, the larger block is split into two. The first portion of  : 
135a			;        this block will become the requested space by the malloc call and    : 
135a			;        is returned to the caller. The second portion becomes a new free     : 
135a			;        block, and the free list is adjusted to maintain continuity via this : 
135a			;        newly created block.                                                 : 
135a			;                                                                             : 
135a			;     malloc does not set any initial value in the allocated space, the       : 
135a			;     caller is required to do this as required.                              : 
135a			;                                                                             : 
135a			;     This implementation of malloc uses the stack exclusively, and is        : 
135a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
135a			;     advisable to disable interrupts before calling malloc, and recommended  : 
135a			;     to avoid the use of malloc inside ISRs in general.                      : 
135a			;                                                                             : 
135a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
135a			;                                                                             : 
135a			; Parameters                                                                  : 
135a			;     HL  Number of bytes wanted                                              : 
135a			;                                                                             : 
135a			; Returns                                                                     : 
135a			;     HL  Address of the first useable byte of the allocation                 : 
135a			;                                                                             : 
135a			; Flags                                                                       : 
135a			;     Z   Set if the allocation did not succeed, clear otherwise              : 
135a			;                                                                             : 
135a			; Stack frame                                                                 : 
135a			;       |             |                                                       : 
135a			;       +-------------+                                                       : 
135a			;       |     BC      |                                                       : 
135a			;       +-------------+                                                       : 
135a			;       |     DE      |                                                       : 
135a			;       +-------------+                                                       : 
135a			;       |     IX      |                                                       : 
135a			;       +-------------+                                                       : 
135a			;       |  prev_free  |                                                       : 
135a			;   +4  +-------------+                                                       : 
135a			;       |  this_free  |                                                       : 
135a			;   +2  +-------------+                                                       : 
135a			;       |  next_free  |                                                       : 
135a			;   +0  +-------------+                                                       : 
135a			;       |             |                                                       : 
135a			;                                                                             : 
135a			;------------------------------------------------------------------------------ 
135a			malloc: 
135a			      push  BC 
135a			      push  DE 
135a			      push  IX 
135a			 
135a			      ld    A, H                    ; Exit if no space requested 
135a			      or    L 
135a			      jp    Z, malloc_early_exit 
135a			 
135a			      ; Set up stack frame 
135a			      ex    DE, HL 
135a			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
135a			      add   HL, SP 
135a			      ld    SP, HL 
135a			      ld    IX, 0                   ; Use IX as a frame pointer 
135a			      add   IX, SP 
135a			 
135a			      ; Setup initial state 
135a			      ld    HL, 4                   ; want must also include space used by block struct 
135a			      add   HL, DE 
135a			 
135a			      ld    B, H                    ; Move want to BC 
135a			      ld    C, L 
135a			 
135a			      ld    HL, free_list           ; Store prev_free ptr to stack 
135a			      ld    (IX+4), L 
135a			      ld    (IX+5), H 
135a			 
135a			      ld    E, (HL)                 ; Store this_free ptr to stack 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			      ld    (IX+2), E 
135a			      ld    (IX+3), D 
135a			      ex    DE, HL                  ; this_free ptr into HL 
135a			 
135a			      ; Loop through free block list to find some space 
135a			malloc_find_space: 
135a			      ld    E, (HL)                 ; Load next_free ptr into DE 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			 
135a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
135a			      or    E 
135a			      jp    Z, malloc_no_space 
135a			 
135a			      ld    (IX+0), E               ; Store next_free ptr to stack 
135a			      ld    (IX+1), D 
135a			 
135a			      ; Does this block have enough space to make the allocation? 
135a			      inc   HL                      ; Load free block size into DE 
135a			      ld    E, (HL) 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			 
135a			      ex    DE, HL                  ; Check size of block against want 
135a			      or    A                       ; Ensure carry flag clear 
135a			      sbc   HL, BC 
135a			      push  HL                      ; Store the result for later (new block size) 
135a			 
135a			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
135a			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
135a			 
135a			      ; this_free block is not big enough, setup ptrs to test next free block 
135a			      pop   HL                      ; Discard previous result 
135a			 
135a			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
135a			      ld    H, (IX+3) 
135a			      ld    (IX+4), L 
135a			      ld    (IX+5), H 
135a			 
135a			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
135a			      ld    H, (IX+1) 
135a			      ld    (IX+2), L 
135a			      ld    (IX+3), H 
135a			 
135a			      jr    malloc_find_space 
135a			 
135a			      ; split a bigger block into two - requested size and remaining size 
135a			malloc_alloc_split: 
135a			      ex    DE, HL                  ; Calculate address of new free block 
135a			      dec   HL 
135a			      dec   HL 
135a			      dec   HL 
135a			      add   HL, BC 
135a			 
135a			      ; Create a new block and point it at next_free 
135a			      ld    E, (IX+0)               ; Load next_free ptr into DE 
135a			      ld    D, (IX+1) 
135a			 
135a			      ld    (HL), E                 ; Store next_free ptr into new block 
135a			      inc   HL 
135a			      ld    (HL), D 
135a			 
135a			      pop   DE                      ; Store size of new block into new block 
135a			      inc   HL 
135a			      ld    (HL), E 
135a			      inc   HL 
135a			      ld    (HL), D 
135a			 
135a			      ; Update this_free ptr to point to new block 
135a			      dec   HL 
135a			      dec   HL 
135a			      dec   HL 
135a			 
135a			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
135a			      ld    D, (IX+3) 
135a			 
135a			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
135a			      ld    (IX+3), H 
135a			 
135a			      ; Modify this_free block to be allocation 
135a			      ex    DE, HL 
135a			      xor   A                       ; Null the next block ptr of allocated block 
135a			      ld    (HL), A 
135a			      inc   HL 
135a			      ld    (HL), A 
135a			 
135a			      inc   HL                      ; Store want size into allocated block 
135a			      ld    (HL), C 
135a			      inc   HL 
135a			      ld    (HL), B 
135a			      inc   HL 
135a			      push  HL                      ; Address of allocation to return 
135a			 
135a			      jr    malloc_update_links 
135a			 
135a			malloc_alloc_fit: 
135a			      pop   HL                      ; Dont need new block size, want is exact fit 
135a			 
135a			      ; Modify this_free block to be allocation 
135a			      ex    DE, HL 
135a			      dec   HL 
135a			      dec   HL 
135a			      dec   HL 
135a			 
135a			      xor   A                       ; Null the next block ptr of allocated block 
135a			      ld    (HL), A 
135a			      inc   HL 
135a			      ld    (HL), A 
135a			 
135a			      inc   HL                      ; Store address of allocation to return 
135a			      inc   HL 
135a			      inc   HL 
135a			      push  HL 
135a			 
135a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
135a			      ld    L, (IX+0)               ; next_free to HL 
135a			      ld    H, (IX+1) 
135a			 
135a			      ld    (IX+2), L               ; HL to this_free 
135a			      ld    (IX+3), H 
135a			 
135a			 
135a			malloc_update_links: 
135a			      ; Update prev_free ptr to point to this_free 
135a			      ld    L, (IX+4)               ; prev_free ptr to HL 
135a			      ld    H, (IX+5) 
135a			 
135a			      ld    E, (IX+2)               ; this_free ptr to DE 
135a			      ld    D, (IX+3) 
135a			 
135a			      ld    (HL), E                 ; this_free ptr into prev_free 
135a			      inc   HL 
135a			      ld    (HL), D 
135a			 
135a			      ; Clear the Z flag to indicate successful allocation 
135a			      ld    A, D 
135a			      or    E 
135a			 
135a			      pop   DE                      ; Address of allocation 
135a			 
135a			malloc_no_space: 
135a			      ld    HL, 6                   ; Clean up stack frame 
135a			      add   HL, SP 
135a			      ld    SP, HL 
135a			 
135a			      ex    DE, HL                  ; Alloc addr into HL for return 
135a			 
135a			malloc_early_exit: 
135a			      pop   IX 
135a			      pop   DE 
135a			      pop   BC 
135a			 
135a			      ret 
135a			 
135a			 
135a			;------------------------------------------------------------------------------ 
135a			;     free                                                                    : 
135a			;                                                                             : 
135a			; Description                                                                 : 
135a			;     Return the space pointed to by HL to the heap. HL must be an address as : 
135a			;     returned by malloc, otherwise the behaviour is undefined.               : 
135a			;                                                                             : 
135a			;     Where possible, directly adjacent free blocks will be merged together   : 
135a			;     into larger blocks to help ensure that the heap does not become         : 
135a			;     excessively fragmented.                                                 : 
135a			;                                                                             : 
135a			;     free does not clear or set any other value into the freed space, and    : 
135a			;     therefore its contents may be visible through subsequent malloc's. The  : 
135a			;     caller should clear the freed space as required.                        : 
135a			;                                                                             : 
135a			;     This implementation of free uses the stack exclusively, and is          : 
135a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
135a			;     advisable to disable interrupts before calling free, and recommended    : 
135a			;     to avoid the use of free inside ISRs in general.                        : 
135a			;                                                                             : 
135a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
135a			;                                                                             : 
135a			; Parameters                                                                  : 
135a			;     HL  Pointer to address of first byte of allocation to be freed          : 
135a			;                                                                             : 
135a			; Returns                                                                     : 
135a			;     Nothing                                                                 : 
135a			;                                                                             : 
135a			; Stack frame                                                                 : 
135a			;       |             |                                                       : 
135a			;       +-------------+                                                       : 
135a			;       |     BC      |                                                       : 
135a			;       +-------------+                                                       : 
135a			;       |     DE      |                                                       : 
135a			;       +-------------+                                                       : 
135a			;       |     IX      |                                                       : 
135a			;       +-------------+                                                       : 
135a			;       |  prev_free  |                                                       : 
135a			;   +2  +-------------+                                                       : 
135a			;       |  next_free  |                                                       : 
135a			;   +0  +-------------+                                                       : 
135a			;       |             |                                                       : 
135a			;                                                                             : 
135a			;------------------------------------------------------------------------------ 
135a			free: 
135a			      push  BC 
135a			      push  DE 
135a			      push  IX 
135a			 
135a			      ld    A, H                    ; Exit if ptr is null 
135a			      or    L 
135a			      jp    Z, free_early_exit 
135a			 
135a			      ; Set up stack frame 
135a			      ex    DE, HL 
135a			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
135a			      add   HL, SP 
135a			      ld    SP, HL 
135a			      ld    IX, 0                   ; Use IX as a frame pointer 
135a			      add   IX, SP 
135a			 
135a			      ; The address in HL points to the start of the useable allocated space, 
135a			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
135a			      ; address of the block itself. 
135a			      ex    DE, HL 
135a			      ld    DE, -4 
135a			      add   HL, DE 
135a			 
135a			      ; An allocated block must have a null next block pointer in it 
135a			      ld    A, (HL) 
135a			      inc   HL 
135a			      or    (HL) 
135a			      jp    NZ, free_done 
135a			 
135a			      dec   HL 
135a			 
135a			      ld    B, H                    ; Copy HL to BC 
135a			      ld    C, L 
135a			 
135a			      ; Loop through the free list to find the first block with an address 
135a			      ; higher than the block being freed 
135a			      ld    HL, free_list 
135a			 
135a			free_find_higher_block: 
135a			      ld    E, (HL)                 ; Load next ptr from free block 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			      dec   HL 
135a			 
135a			      ld    (IX+0), E               ; Save ptr to next free block 
135a			      ld    (IX+1), D 
135a			      ld    (IX+2), L               ; Save ptr to prev free block 
135a			      ld    (IX+3), H 
135a			 
135a			      ld    A, B                    ; Check if DE is greater than BC 
135a			      cp    D                       ; Compare MSB first 
135a			      jr    Z, $+4                  ; MSB the same, compare LSB 
135a			      jr    NC, free_find_higher_block_skip 
135a			      ld    A, C 
135a			      cp    E                       ; Then compare LSB 
135a			      jr    C, free_found_higher_block 
135a			 
135a			free_find_higher_block_skip: 
135a			      ld    A, D                    ; Reached the end of the free list? 
135a			      or    E 
135a			      jp    Z, free_done 
135a			 
135a			      ex    DE, HL 
135a			 
135a			      jr    free_find_higher_block 
135a			 
135a			free_found_higher_block: 
135a			      ; Insert freed block between prev and next free blocks 
135a			      ld    (HL), C                 ; Point prev free block to freed block 
135a			      inc   HL 
135a			      ld    (HL), B 
135a			 
135a			      ld    H, B                    ; Point freed block at next free block 
135a			      ld    L, C 
135a			      ld    (HL), E 
135a			      inc   HL 
135a			      ld    (HL), D 
135a			 
135a			      ; Check if the freed block is adjacent to the next free block 
135a			      inc   HL                      ; Load size of freed block into HL 
135a			      ld    E, (HL) 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			      ex    DE, HL 
135a			 
135a			      add   HL, BC                  ; Add addr of freed block and its size 
135a			 
135a			      ld    E, (IX+0)               ; Load addr of next free block into DE 
135a			      ld    D, (IX+1) 
135a			 
135a			      or    A                       ; Clear the carry flag 
135a			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
135a			      jr    NZ, free_check_adjacent_to_prev 
135a			 
135a			      ; Freed block is adjacent to next, merge into one bigger block 
135a			      ex    DE, HL                  ; Load next ptr from next block into DE 
135a			      ld    E, (HL) 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			      push  HL                      ; Save ptr to next block for later 
135a			 
135a			      ld    H, B                    ; Store ptr from next block into freed block 
135a			      ld    L, C 
135a			      ld    (HL), E 
135a			      inc   HL 
135a			      ld    (HL), D 
135a			 
135a			      pop   HL                      ; Restore ptr to next block 
135a			      inc   HL                      ; Load size of next block into DE 
135a			      ld    E, (HL) 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			      push  DE                      ; Save next block size for later 
135a			 
135a			      ld    H, B                    ; Load size of freed block into HL 
135a			      ld    L, C 
135a			      inc   HL 
135a			      inc   HL 
135a			      ld    E, (HL) 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			      ex    DE, HL 
135a			 
135a			      pop   DE                      ; Restore size of next block 
135a			      add   HL, DE                  ; Add sizes of both blocks 
135a			      ex    DE, HL 
135a			 
135a			      ld    H, B                    ; Store new bigger size into freed block 
135a			      ld    L, C 
135a			      inc   HL 
135a			      inc   HL 
135a			      ld    (HL), E 
135a			      inc   HL 
135a			      ld    (HL), D 
135a			 
135a			free_check_adjacent_to_prev: 
135a			      ; Check if the freed block is adjacent to the prev free block 
135a			      ld    L, (IX+2)               ; Prev free block ptr into HL 
135a			      ld    H, (IX+3) 
135a			 
135a			      inc   HL                      ; Size of prev free block into DE 
135a			      inc   HL 
135a			      ld    E, (HL) 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			      dec   HL 
135a			      dec   HL 
135a			      dec   HL 
135a			 
135a			      add   HL, DE                  ; Add prev block addr and size 
135a			 
135a			      or    A                       ; Clear the carry flag 
135a			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
135a			      jr    NZ, free_done 
135a			 
135a			      ; Freed block is adjacent to prev, merge into one bigger block 
135a			      ld    H, B                    ; Load next ptr from freed block into DE 
135a			      ld    L, C 
135a			      ld    E, (HL) 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			      push  HL                      ; Save freed block ptr for later 
135a			 
135a			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
135a			      ld    H, (IX+3) 
135a			      ld    (HL), E 
135a			      inc   HL 
135a			      ld    (HL), D 
135a			 
135a			      pop   HL                      ; Restore freed block ptr 
135a			      inc   HL                      ; Load size of freed block into DE 
135a			      ld    E, (HL) 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			      push  DE                      ; Save freed block size for later 
135a			 
135a			      ld    L, (IX+2)               ; Load size of prev block into DE 
135a			      ld    H, (IX+3) 
135a			      inc   HL 
135a			      inc   HL 
135a			      ld    E, (HL) 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			 
135a			      pop   HL                      ; Add sizes of both blocks 
135a			      add   HL, DE 
135a			      ex    DE, HL 
135a			 
135a			      ld    L, (IX+2)               ; Store new bigger size into prev block 
135a			      ld    H, (IX+3) 
135a			      inc   HL 
135a			      inc   HL 
135a			      ld    (HL), E 
135a			      inc   HL 
135a			      ld    (HL), D 
135a			 
135a			free_done: 
135a			      ld    HL, 4                   ; Clean up stack frame 
135a			      add   HL, SP 
135a			      ld    SP, HL 
135a			 
135a			free_early_exit: 
135a			      pop   IX 
135a			      pop   DE 
135a			      pop   BC 
135a			 
135a			      ret 
135a			 
135a			 
135a			;      .org 0x8000 
135a			; 
135a			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
135a			 ;                 .dw   0 
135a			 
135a			endif 
135a			 
135a			 
135a			if MALLOC_4 
135a			 
135a			; My memory allocation code. Very very simple.... 
135a			; allocate space under 250 chars 
135a			 
135a			heap_init: 
135a				; init start of heap as zero 
135a				;  
135a			 
135a				ld hl, heap_start 
135a				ld a, 0 
135a				ld (hl), a      ; empty block 
135a				inc hl 
135a				ld a, 0 
135a				ld (hl), a      ; length of block 
135a				; write end of list 
135a				inc hl 
135a				ld a,(hl) 
135a				inc hl 
135a				ld a,(hl) 
135a				 
135a			 
135a				; init some malloc vars 
135a			 
135a				ld hl, 0 
135a				ld (free_list), hl       ; store last malloc location 
135a			 
135a				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
135a				ld a, 0 
135a				ld (hl), a 
135a			 
135a			 
135a				ld hl, heap_start 
135a				;  
135a				  
135a				ret 
135a			 
135a			 
135a			;    free block marker 
135a			;    requested size  
135a			;    pointer to next block 
135a			;    .... 
135a			;    next block marker 
135a			 
135a			 
135a			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
135a			; 
135a			 
135a			 
135a			malloc:  
135a				push de 
135a				push bc 
135a				push af 
135a			 
135a				; hl space required 
135a				 
135a				ld c, l    ; hold space   (TODO only a max of 255) 
135a			 
135a			;	inc c     ; TODO BUG need to fix memory leak on push str 
135a			;	inc c 
135a			;	inc c 
135a			;	inc c 
135a			;	inc c 
135a			;	inc c 
135a			;	inc c 
135a			 
135a			 
135a			 
135a				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
135a			 
135a				ld a, (free_list+3) 
135a				cp 0 
135a				jr z, .contheap 
135a			 
135a				ld hl, (free_list)     ; get last alloc 
135a					if DEBUG_FORTH_MALLOC_INT 
135a						DMARK "mrs" 
135a						CALLMONITOR 
135a					endif 
135a				jr .startalloc 
135a			 
135a			.contheap: 
135a				ld hl, heap_start 
135a			 
135a			.startalloc: 
135a			 
135a					if DEBUG_FORTH_MALLOC_INT 
135a						DMARK "mym" 
135a						CALLMONITOR 
135a					endif 
135a			.findblock: 
135a					if DEBUG_FORTH_MALLOC_INT 
135a						DMARK "mmf" 
135a						CALLMONITOR 
135a					endif 
135a			 
135a				ld a,(hl)  
135a				; if byte is zero then clear to use 
135a			 
135a				cp 0 
135a				jr z, .foundemptyblock 
135a			 
135a				; if byte is not clear 
135a				;     then byte is offset to next block 
135a			 
135a				inc hl 
135a				ld a, (hl) ; get size 
135a			.nextblock:	inc hl 
135a					ld e, (hl) 
135a					inc hl 
135a					ld d, (hl) 
135a					ex de, hl 
135a			;	inc hl  ; move past the store space 
135a			;	inc hl  ; move past zero index  
135a			 
135a				; TODO detect no more space 
135a			 
135a				push hl 
135a				ld de, heap_end 
135a				call cmp16 
135a				pop hl 
135a				jr nc, .nospace 
135a			 
135a				jr .findblock 
135a			 
135a			.nospace: ld hl, 0 
135a				jp .exit 
135a			 
135a			 
135a			.foundemptyblock:	 
135a					if DEBUG_FORTH_MALLOC_INT 
135a						DMARK "mme" 
135a						CALLMONITOR 
135a					endif 
135a			 
135a			; TODO has block enough space if reusing??? 
135a			 
135a				;  
135a			 
135a			; see if this block has been previously used 
135a				inc hl 
135a				ld a, (hl) 
135a				dec hl 
135a				cp 0 
135a				jr z, .newblock 
135a			 
135a					if DEBUG_FORTH_MALLOC_INT 
135a						DMARK "meR" 
135a						CALLMONITOR 
135a					endif 
135a			 
135a			; no reusing previously allocated block 
135a			 
135a			; is it smaller than previously used? 
135a				 
135a				inc hl    ; move to size 
135a				ld a, c 
135a				sub (hl)        ; we want c < (hl) 
135a				dec hl    ; move back to marker 
135a			        jr z, .findblock 
135a			 
135a				; update with the new size which should be lower 
135a			 
135a			        ;inc  hl   ; negate next move. move back to size  
135a			 
135a			.newblock: 
135a				; need to be at marker here 
135a			 
135a					if DEBUG_FORTH_MALLOC_INT 
135a						DMARK "meN" 
135a						CALLMONITOR 
135a					endif 
135a			 
135a			 
135a				ld a, c 
135a			 
135a				ld (free_list+3), a	 ; flag resume from last malloc  
135a				ld (free_list), hl    ; save out last location 
135a			 
135a			 
135a				;inc a     ; space for length byte 
135a				ld (hl), a     ; save block in use marker 
135a			 
135a				inc hl   ; move to space marker 
135a				ld (hl), a    ; save new space 
135a			 
135a				inc hl   ; move to start of allocated area 
135a				 
135a			;	push hl     ; save where we are - 1  
135a			 
135a			;	inc hl  ; move past zero index  
135a				; skip space to set down new marker 
135a			 
135a				; provide some extra space for now 
135a			 
135a				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
135a				inc a 
135a				inc a 
135a			 
135a				push hl   ; save where we are in the node block 
135a			 
135a				call addatohl 
135a			 
135a				; write linked list point 
135a			 
135a				pop de     ; get our node position 
135a				ex de, hl 
135a			 
135a				ld (hl), e 
135a				inc hl 
135a				ld (hl), d 
135a			 
135a				inc hl 
135a			 
135a				; now at start of allocated data so save pointer 
135a			 
135a				push hl 
135a			 
135a				; jump to position of next node and setup empty header in DE 
135a			 
135a				ex de, hl 
135a			 
135a			;	inc hl ; move past end of block 
135a			 
135a				ld a, 0 
135a				ld (hl), a   ; empty marker 
135a				inc hl 
135a				ld (hl), a   ; size 
135a				inc hl  
135a				ld (hl), a   ; ptr 
135a				inc hl 
135a				ld (hl), a   ; ptr 
135a			 
135a			 
135a				pop hl 
135a			 
135a					if DEBUG_FORTH_MALLOC_INT 
135a						DMARK "mmr" 
135a						CALLMONITOR 
135a					endif 
135a			 
135a			.exit: 
135a				pop af 
135a				pop bc 
135a				pop de  
135a				ret 
135a			 
135a			 
135a			 
135a			 
135a			free:  
135a				push hl 
135a				push af 
135a				; get address in hl 
135a			 
135a					if DEBUG_FORTH_MALLOC_INT 
135a						DMARK "fre" 
135a						CALLMONITOR 
135a					endif 
135a				; data is at hl - move to block count 
135a				dec hl 
135a				dec hl    ; get past pointer 
135a				dec hl 
135a			 
135a				ld a, (hl)    ; need this for a validation check 
135a			 
135a				dec hl    ; move to block marker 
135a			 
135a				; now check that the block count and block marker are the same  
135a			        ; this checks that we are on a malloc node and not random memory 
135a			        ; OK a faint chance this could be a problem but rare - famous last words! 
135a			 
135a				ld c, a 
135a				ld a, (hl)    
135a			 
135a				cp c 
135a				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
135a			 
135a				; yes good chance we are on a malloc node 
135a			 
135a				ld a, 0      
135a				ld (hl), a   ; mark as free 
135a			 
135a				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
135a			 
135a			.freeignore:  
135a			 
135a				pop af 
135a				pop hl 
135a			 
135a				ret 
135a			 
135a			 
135a			 
135a			endif 
135a			 
135a			; eof 
# End of file firmware_memory.asm
135a			  
135a			; device C  
135a			; Now handled by SPI  
135a			;if SOUND_ENABLE  
135a			;	include "firmware_sound.asm"  
135a			;endif  
135a			  
135a			include "firmware_diags.asm"  
135a			; Hardware diags menu 
135a			 
135a			 
135a			config: 
135a			 
135a 3e 00			ld a, 0 
135c 21 80 13			ld hl, .configmn 
135f cd ea 0b			call menu 
1362			 
1362 fe 00			cp 0 
1364 c8				ret z 
1365			 
1365			;	cp 1 
1365			;	call z, .savetostore 
1365			 
1365 fe 01			cp 1 
1367			if STARTUP_V1 
1367 cc 96 13			call z, .selautoload 
136a			endif 
136a			 
136a			if STARTUP_V2 
136a				call z, .enautoload 
136a			endif 
136a fe 02			cp 2 
136c cc 8c 13			call z, .disautoload 
136f			;	cp 3 
136f			;	call z, .selbank 
136f fe 03			cp 3 
1371 cc b4 13			call z, .debug_tog 
1374 fe 04			cp 4 
1376 cc 02 15			call z, .bpsgo 
1379 fe 05			cp 5 
137b cc dd 13			call z, hardware_diags 
137e			if STARTUP_V2 
137e				cp 6 
137e				call z, create_startup 
137e			endif 
137e 18 da			jr config 
1380			 
1380			.configmn: 
1380			;	dw prom_c3 
1380 f0 16			dw prom_c2 
1382 05 17			dw prom_c2a 
1384			;	dw prom_c2b 
1384			;	dw prom_c4 
1384 24 17			dw prom_m4 
1386 3f 17			dw prom_m4b 
1388 47 17			dw prom_c1 
138a			if STARTUP_V2 
138a				dw prom_c9 
138a			endif 
138a 00 00			dw 0 
138c				 
138c			 
138c			if STARTUP_V2 
138c			.enautoload: 
138c				if STORAGE_SE 
138c				ld a, $fe      ; bit 0 clear 
138c				ld (spi_device), a 
138c			 
138c				call storage_get_block_0 
138c			 
138c				ld a, 1 
138c				ld (store_page+STORE_0_AUTOFILE), a 
138c			 
138c					ld hl, 0 
138c					ld de, store_page 
138c				call storage_write_block	 ; save update 
138c				else 
138c			 
138c				ld hl, prom_notav 
138c				ld de, prom_empty 
138c				call info_panel 
138c				endif 
138c			 
138c			 
138c				ret 
138c			endif 
138c			 
138c			.disautoload: 
138c				if STORAGE_SE 
138c				ld a, $fe      ; bit 0 clear 
138c				ld (spi_device), a 
138c			 
138c				call storage_get_block_0 
138c			 
138c				ld a, 0 
138c				ld (store_page+STORE_0_AUTOFILE), a 
138c			 
138c					ld hl, 0 
138c					ld de, store_page 
138c				call storage_write_block	 ; save update 
138c				else 
138c			 
138c 21 56 17			ld hl, prom_notav 
138f 11 6c 17			ld de, prom_empty 
1392 cd 4a 0b			call info_panel 
1395				endif 
1395			 
1395			 
1395 c9				ret 
1396			 
1396			if STARTUP_V1 
1396			 
1396			; Select auto start 
1396			 
1396			.selautoload: 
1396			 
1396				 
1396				if STORAGE_SE 
1396			 
1396					call config_dir 
1396				        ld hl, scratch 
1396					ld a, 0 
1396					call menu 
1396			 
1396					cp 0 
1396					ret z 
1396			 
1396					dec a 
1396			 
1396			 
1396					; locate menu option 
1396			 
1396					ld hl, scratch 
1396					call table_lookup 
1396			 
1396					if DEBUG_FORTH_WORDS 
1396						DMARK "ALl" 
1396						CALLMONITOR 
1396					endif 
1396					; with the pointer to the menu it, the byte following the zero term is the file id 
1396			 
1396					ld a, 0 
1396					ld bc, 50   ; max of bytes to look at 
1396					cpir  
1396			 
1396					if DEBUG_FORTH_WORDS 
1396						DMARK "ALb" 
1396						CALLMONITOR 
1396					endif 
1396					;inc hl 
1396			 
1396					ld a, (hl)   ; file id 
1396					 
1396				        ; save bank and file ids 
1396			 
1396					push af 
1396			 
1396			; TODO need to save to block 0 on bank 1	 
1396			 
1396					call storage_get_block_0 
1396			 
1396					if DEBUG_FORTH_WORDS 
1396						DMARK "AL0" 
1396						CALLMONITOR 
1396					endif 
1396					pop af 
1396			 
1396					ld (store_page+STORE_0_FILERUN),a 
1396					 
1396					; save bank id 
1396			 
1396					ld a,(spi_device) 
1396					ld (store_page+STORE_0_BANKRUN),a 
1396			 
1396					; enable auto run of store file 
1396			 
1396					ld a, 1 
1396					ld (store_page+STORE_0_AUTOFILE),a 
1396			 
1396					; save buffer 
1396			 
1396					ld hl, 0 
1396					ld de, store_page 
1396					if DEBUG_FORTH_WORDS 
1396						DMARK "ALw" 
1396						CALLMONITOR 
1396					endif 
1396				call storage_write_block	 ; save update 
1396			  
1396			 
1396			 
1396			 
1396					ld hl, scratch 
1396					call config_fdir 
1396			 
1396				else 
1396			 
1396 21 56 17			ld hl, prom_notav 
1399 11 6c 17			ld de, prom_empty 
139c cd 4a 0b			call info_panel 
139f			 
139f				endif 
139f c9				ret 
13a0			endif 
13a0			 
13a0			 
13a0			; Select storage bank 
13a0			 
13a0			.selbank: 
13a0			 
13a0			;	if STORAGE_SE 
13a0			;	else 
13a0			 
13a0 21 56 17			ld hl, prom_notav 
13a3 11 6c 17			ld de, prom_empty 
13a6 cd 4a 0b			call info_panel 
13a9			;	endif 
13a9				 
13a9 c9				ret 
13aa			 
13aa			if STORAGE_SE 
13aa			 
13aa			.config_ldir:   
13aa				; Load storage bank labels into menu array 
13aa			 
13aa				 
13aa			 
13aa			 
13aa				ret 
13aa			 
13aa			 
13aa			endif 
13aa			 
13aa			 
13aa			; Save user words to storage 
13aa			 
13aa			.savetostore: 
13aa			 
13aa			;	if STORAGE_SE 
13aa			; 
13aa			;		call config_dir 
13aa			;	        ld hl, scratch 
13aa			;		ld a, 0 
13aa			;		call menu 
13aa			;		 
13aa			;		ld hl, scratch 
13aa			;		call config_fdir 
13aa			; 
13aa			;	else 
13aa			 
13aa 21 56 17			ld hl, prom_notav 
13ad 11 6c 17			ld de, prom_empty 
13b0 cd 4a 0b			call info_panel 
13b3			 
13b3			;	endif 
13b3			 
13b3 c9				ret 
13b4			 
13b4			if STARTUP_V2 
13b4			 
13b4			create_startup: 
13b4			 
13b4				ld a, 0 
13b4				ld hl, .crstart 
13b4				call menu 
13b4			 
13b4				cp 0 
13b4				ret z 
13b4			 
13b4				cp 1 
13b4				call z, .genlsword 
13b4				cp 2 
13b4				call z, .genedword 
13b4			 
13b4				cp 3 
13b4				call z, .gendemword 
13b4			 
13b4				cp 4 
13b4				call z, .genutlword 
13b4				cp 5 
13b4				call z, .genspiword 
13b4				cp 6 
13b4				call z, .genkeyword 
13b4				cp 7 
13b4				call z, .gensoundword 
13b4				cp 7 
13b4				call z, .genhwword 
13b4				jr create_startup 
13b4			 
13b4			.genhwword: 
13b4				ld hl, crs_hw 
13b4				ld de, .hwworddef 
13b4				call .genfile 
13b4				ret 
13b4			.gensoundword: 
13b4				ld hl, crs_sound 
13b4				ld de, .soundworddef 
13b4				call .genfile 
13b4				ret 
13b4			.genlsword: 
13b4				ld hl, crs_s1 
13b4				ld de, .lsworddef 
13b4				call .genfile 
13b4				ret 
13b4			 
13b4			.genedword: 
13b4				ld de, .edworddef 
13b4				ld hl, crs_s2 
13b4				call .genfile 
13b4				ret 
13b4			 
13b4			.gendemword: 
13b4				ld de, .demoworddef 
13b4				ld hl, crs_s3 
13b4				call .genfile 
13b4				ret 
13b4			 
13b4			.genutlword: 
13b4				ld hl, crs_s4 
13b4				ld de, .utilwordef 
13b4				call .genfile 
13b4				ret 
13b4			.genspiword: 
13b4				ld hl, crs_s5 
13b4				ld de, .spiworddef 
13b4				call .genfile 
13b4				ret 
13b4			.genkeyword: 
13b4				ld hl, crs_s6 
13b4				ld de, .keyworddef 
13b4				call .genfile 
13b4				ret 
13b4			 
13b4			; hl - points to file name 
13b4			; de - points to strings to add to file 
13b4			 
13b4			.genfile: 
13b4				push hl 
13b4				push de 
13b4			 
13b4				call clear_display 
13b4				ld a, display_row_1 
13b4				ld de, .genfiletxt 
13b4				call str_at_display 
13b4				call update_display 
13b4			 
13b4				pop de 
13b4				pop hl 
13b4			 
13b4			 
13b4				push de 
13b4				call storage_create 
13b4				; id in hl 
13b4				pop de   ; table of strings to add 
13b4			 
13b4			.genloop: 
13b4			 
13b4				push hl ; save id for next time around 
13b4				push de ; save de for next time around 
13b4			 
13b4				ex de, hl 
13b4				call loadwordinhl 
13b4				ex de, hl 
13b4			 
13b4				; need hl to be the id 
13b4				; need de to be the string ptr 
13b4				 
13b4				call storage_append 
13b4			 
13b4				pop de 
13b4				pop hl 
13b4			 
13b4				inc de 
13b4				inc de 
13b4			 
13b4				ld a,(de) 
13b4				cp 0 
13b4				jr nz, .genloop 
13b4				inc de 
13b4				ld a, (de) 
13b4				dec de 
13b4				cp 0 
13b4				jr nz, .genloop	 
13b4			 
13b4				ret 
13b4			 
13b4			.genfiletxt:  db "Creating file...",0 
13b4			 
13b4			.hwworddef: 
13b4				dw test5 
13b4				dw test6 
13b4				dw test7 
13b4				dw test8 
13b4				dw test9 
13b4				dw test10 
13b4				dw 0 
13b4			 
13b4			.soundworddef: 
13b4				dw sound1 
13b4				dw sound2 
13b4				dw sound3 
13b4				dw sound4 
13b4				dw sound5 
13b4				dw sound6 
13b4				dw sound7 
13b4				dw sound8 
13b4				dw sound9 
13b4				dw 0 
13b4			 
13b4			.utilwordef: 
13b4				dw strncpy 
13b4				dw type 
13b4				dw clrstack 
13b4				dw longread 
13b4				dw start1 
13b4				dw start2 
13b4			; duplicated 
13b4			;	dw start3b 
13b4			;	dw start3c 
13b4				dw list 
13b4				dw 0 
13b4			 
13b4			.lsworddef: 
13b4				dw start3b 
13b4				dw 0 
13b4			 
13b4			.edworddef: 
13b4				dw edit1 
13b4				dw edit2 
13b4				dw edit3 
13b4				dw 0 
13b4			 
13b4			.demoworddef: 
13b4				dw game1 
13b4				dw game1a 
13b4				dw game1b 
13b4				dw game1c 
13b4				dw game1d 
13b4				dw game1s 
13b4				dw game1t 
13b4				dw game1f 
13b4				dw game1z 
13b4				dw game1zz 
13b4				dw ssv2 
13b4				dw ssv3 
13b4				dw ssv4 
13b4				dw ssv5 
13b4				dw ssv1 
13b4				dw ssv1cpm	 
13b4			;	dw game2b 
13b4			;	dw game2bf 
13b4			;	dw game2mba 
13b4			;	dw game2mbas	 
13b4			;	dw game2mbht 
13b4			;	dw game2mbms 
13b4			;	dw game2mb 
13b4			;	dw game3w 
13b4			;	dw game3p 
13b4			;	dw game3sc 
13b4			;	dw game3vsi 
13b4			;	dw game3vs 
13b4				dw 0 
13b4			 
13b4			 
13b4			.spiworddef: 
13b4			 
13b4			    dw spi1 
13b4			    dw spi2 
13b4			    dw spi2b 
13b4			    dw spi3 
13b4			    dw spi4 
13b4			    dw spi5 
13b4			;    dw spi6 
13b4			;    dw spi7 
13b4			 
13b4			;    dw spi8 
13b4			;    dw spi9 
13b4			;    dw spi10 
13b4			    dw 0 
13b4			 
13b4			.keyworddef: 
13b4			 
13b4				dw keyup 
13b4				dw keydown 
13b4				dw keyleft 
13b4				dw keyright 
13b4				dw 	keyf1 
13b4				dw keyf2 
13b4				dw keyf3 
13b4				dw keyf4 
13b4				dw keyf5 
13b4				dw keyf6 
13b4				dw keyf7 
13b4				dw keyf8 
13b4				dw keyf9 
13b4				dw keyf10 
13b4				dw keyf11 
13b4				dw keyf12 
13b4				dw keytab 
13b4				dw keycr 
13b4				dw keyhome 
13b4				dw keyend 
13b4				dw keybs 
13b4				dw 0 
13b4			 
13b4			.crstart: 
13b4				dw crs_s1 
13b4				dw crs_s2 
13b4				dw crs_s3 
13b4				dw crs_s4 
13b4				dw crs_s5 
13b4				dw crs_s6 
13b4				dw crs_sound 
13b4				dw crs_hw 
13b4				dw 0 
13b4			 
13b4			endif 
13b4			 
13b4			 
13b4			if STORAGE_SE 
13b4			 
13b4			config_fdir: 
13b4				; using the scratch dir go through and release the memory allocated for each string 
13b4				 
13b4				ld hl, scratch 
13b4			.cfdir:	ld e,(hl) 
13b4				inc hl 
13b4				ld d,(hl) 
13b4				inc hl 
13b4			 
13b4				ex de, hl 
13b4				call ishlzero 
13b4				ret z     ; return on null pointer 
13b4				call free 
13b4				ex de, hl 
13b4				jr .cfdir 
13b4			 
13b4			 
13b4				ret 
13b4			 
13b4			 
13b4			config_dir: 
13b4			 
13b4				; for the config menus that need to build a directory of storage call this routine 
13b4				; it will construct a menu in scratch to pass to menu 
13b4			 
13b4				; open storage device 
13b4			 
13b4				; execute DIR to build a list of files and their ids into scratch in menu format 
13b4				; once the menu has finished then will need to call config_fdir to release the strings 
13b4				 
13b4				; c = number items 
13b4			 
13b4				 
13b4				call storage_get_block_0 
13b4			 
13b4				ld hl, store_page     ; get current id count 
13b4				ld b, (hl) 
13b4				ld c, 0    ; count of files   
13b4			 
13b4			 
13b4				ld hl, scratch 
13b4				ld (store_tmp2), hl    ; location to poke strings 
13b4			 
13b4				; check for empty drive 
13b4			 
13b4				ld a, 0 
13b4				cp b 
13b4				jp z, .dirdone 
13b4			 
13b4				 
13b4					if DEBUG_FORTH_WORDS 
13b4						DMARK "Cdc" 
13b4						CALLMONITOR 
13b4					endif 
13b4			 
13b4			 
13b4			.diritem:	 
13b4				push bc 
13b4				; for each of the current ids do a search for them and if found push to stack 
13b4			 
13b4					ld hl, STORE_BLOCK_PHY 
13b4					ld d, 0		 ; look for extent 0 of block id as this contains file name 
13b4					ld e,b 
13b4			 
13b4					call storage_findnextid 
13b4			 
13b4			 
13b4					; if found hl will be non zero 
13b4			 
13b4					call ishlzero 
13b4					jr z, .dirnotfound 
13b4			 
13b4					; increase count 
13b4			 
13b4					pop bc	 
13b4					inc c 
13b4					push bc 
13b4					 
13b4			 
13b4					; get file header and push the file name 
13b4			 
13b4					ld de, store_page 
13b4					call storage_read_block 
13b4			 
13b4					; push file id to stack 
13b4				 
13b4					ld a, (store_page) 
13b4					ld h, 0 
13b4					ld l, a 
13b4			 
13b4					;call forth_push_numhl 
13b4					; TODO store id 
13b4			 
13b4					push hl 
13b4			 
13b4					; push extent count to stack  
13b4				 
13b4					ld hl, store_page+3 
13b4			 
13b4					; get file name length 
13b4			 
13b4					call strlenz   
13b4			 
13b4					inc hl   ; cover zero term 
13b4					inc hl  ; stick the id at the end of the area 
13b4			 
13b4					push hl 
13b4					pop bc    ; move length to bc 
13b4			 
13b4					call malloc 
13b4			 
13b4					; TODO save malloc area to scratch 
13b4			 
13b4					ex de, hl 
13b4					ld hl, (store_tmp2) 
13b4					ld (hl), e 
13b4					inc hl 
13b4					ld (hl), d 
13b4					inc hl 
13b4					ld (store_tmp2), hl 
13b4			 
13b4					 
13b4			 
13b4					;pop hl   ; get source 
13b4			;		ex de, hl    ; swap aronund	 
13b4			 
13b4					ld hl, store_page+3 
13b4					if DEBUG_FORTH_WORDS 
13b4						DMARK "CFd" 
13b4						CALLMONITOR 
13b4					endif 
13b4					ldir 
13b4			 
13b4					; de is past string, move back one and store id 
13b4					 
13b4					dec de 
13b4			 
13b4					; store file id 
13b4			 
13b4					pop hl 
13b4					ex de,hl 
13b4					ld (hl), e 
13b4			 
13b4					if DEBUG_FORTH_WORDS 
13b4						DMARK "Cdi" 
13b4						CALLMONITOR 
13b4					endif 
13b4					 
13b4			.dirnotfound: 
13b4					pop bc     
13b4					djnz .diritem 
13b4				 
13b4			.dirdone:	 
13b4			 
13b4					ld a, 0 
13b4					ld hl, (store_tmp2) 
13b4					ld (hl), a 
13b4					inc hl 
13b4					ld (hl), a 
13b4					inc hl 
13b4					; push a count of the dir items found 
13b4			 
13b4			;		ld h, 0 
13b4			;		ld l, c 
13b4			 
13b4				ret 
13b4			 
13b4			endif 
13b4			 
13b4			 
13b4			; Settings 
13b4			; Run  
13b4			 
13b4			 
13b4			 
13b4			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
13b4			;;hd_menu2:   db "        2: Editor",0   
13b4			;hd_menu2:   db "        2: Editor       6: Menu",0   
13b4			;hd_menu3:   db "        3: Storage",0 
13b4			;hd_menu4:   db "0=quit  4: Debug",0 
13b4			;hd_don:     db "ON",0 
13b4			;hd_doff:     db "OFF",0 
13b4			; 
13b4			; 
13b4			; 
13b4			;hardware_diags_old:       
13b4			; 
13b4			;.diagmenu: 
13b4			;	call clear_display 
13b4			;	ld a, display_row_1 
13b4			;	ld de, hd_menu1 
13b4			;	call str_at_display 
13b4			; 
13b4			;	ld a, display_row_2 
13b4			;	ld de, hd_menu2 
13b4			;	call str_at_display 
13b4			; 
13b4			;	ld a, display_row_3 
13b4			;	ld de, hd_menu3 
13b4			;	call str_at_display 
13b4			; 
13b4			;	ld a,  display_row_4 
13b4			;	ld de, hd_menu4 
13b4			;	call str_at_display 
13b4			; 
13b4			;	; display debug state 
13b4			; 
13b4			;	ld de, hd_don 
13b4			;	ld a, (os_view_disable) 
13b4			;	cp 0 
13b4			;	jr z, .distog 
13b4			;	ld de, hd_doff 
13b4			;.distog: ld a, display_row_4+17 
13b4			;	call str_at_display 
13b4			; 
13b4			;	call update_display 
13b4			; 
13b4			;	call cin_wait 
13b4			; 
13b4			; 
13b4			; 
13b4			;	cp '4' 
13b4			;	jr nz, .diagn1 
13b4			; 
13b4			;	; debug toggle 
13b4			; 
13b4			;	ld a, (os_view_disable) 
13b4			;	ld b, '*' 
13b4			;	cp 0 
13b4			;	jr z, .debtog 
13b4			;	ld b, 0 
13b4			;.debtog:	 
13b4			;	ld a,b 
13b4			;	ld (os_view_disable),a 
13b4			; 
13b4			;.diagn1: cp '0' 
13b4			;	 ret z 
13b4			; 
13b4			;;	cp '1' 
13b4			;;       jp z, matrix	 
13b4			;;   TODO keyboard matrix test 
13b4			; 
13b4			;	cp '2' 
13b4			;	jp z, .diagedit 
13b4			; 
13b4			;;	cp '6' 
13b4			;;	jp z, .menutest 
13b4			;;if ENABLE_BASIC 
13b4			;;	cp '6' 
13b4			;;	jp z, basic 
13b4			;;endif 
13b4			 ; 
13b4			;	jp .diagmenu 
13b4			; 
13b4			; 
13b4			;	ret 
13b4			 
13b4			 
13b4			.debug_tog: 
13b4 21 fe 13			ld hl, .menudebug 
13b7				 
13b7			;	ld a, (os_view_disable) 
13b7			;	cp '*' 
13b7 3a 6f ee			ld a,(debug_vector) 
13ba fe c9			cp $C9   ; RET 
13bc 20 04			jr nz,.tdon  
13be 3e 01			ld a, 1 
13c0 18 02			jr .tog1 
13c2 3e 00		.tdon: ld a, 0 
13c4			 
13c4			.tog1: 
13c4 cd ea 0b			call menu 
13c7 fe 00			cp 0 
13c9 c8				ret z 
13ca fe 01			cp 1    ; disable debug 
13cc 28 04			jr z, .dtog0 
13ce 3e 2a			ld a, '*' 
13d0 18 05			jr .dtogset 
13d2			.dtog0:  
13d2				;ld a, 0 
13d2 cd f0 14			call bp_on 
13d5 18 dd			jr .debug_tog 
13d7			.dtogset:  
13d7				; ld (os_view_disable), a 
13d7 cd fc 14			call bp_off 
13da c3 b4 13			jp .debug_tog 
13dd			 
13dd			 
13dd			hardware_diags:       
13dd			 
13dd			.diagm: 
13dd 21 f0 13			ld hl, .menuitems 
13e0 3e 00			ld a, 0 
13e2 cd ea 0b			call menu 
13e5			 
13e5 fe 00		         cp 0 
13e7 c8				 ret z 
13e8			 
13e8 fe 02			cp 2 
13ea ca 49 14			jp z, .diagedit 
13ed			 
13ed			;	cp '6' 
13ed			;	jp z, .menutest 
13ed			;if ENABLE_BASIC 
13ed			;	cp '6' 
13ed			;	jp z, basic 
13ed			;endif 
13ed			  
13ed c3 dd 13			jp .diagm 
13f0			 
13f0				 
13f0 04 14		.menuitems:   	dw .m1 
13f2 0f 14				dw .m2 
13f4 16 14				dw .m3 
13f6 1e 14				dw .m5 
13f8 24 14				dw .m5a 
13fa 2d 14				dw .m5b 
13fc 00 00				dw 0 
13fe			 
13fe			.menudebug: 
13fe 36 14				dw .m6 
1400 3f 14				dw .m7 
1402 00 00				dw 0 
1404			 
1404 .. 00		.m1:   db "Key Matrix",0 
140f .. 00		.m2:   db "Editor",0 
1416 .. 00		.m3:   db "Storage",0 
141e .. 00		.m5:   db "Sound",0 
1424 .. 00		.m5a:  db "RAM Test",0 
142d .. 00		.m5b:  db "LCD Test",0 
1436			 
1436 .. 00		.m6:   db "Debug ON",0 
143f .. 00		.m7:   db "Debug OFF",0 
1449			 
1449			; debug editor 
1449			 
1449			.diagedit: 
1449			 
1449 21 c1 e2			ld hl, scratch 
144c			;	ld bc, 250 
144c			;	ldir 
144c				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
144c 3e 00			ld a, 0 
144e 77				ld (hl), a 
144f 23				inc hl 
1450 77				ld (hl), a 
1451 23				inc hl 
1452 77				ld (hl), a 
1453			 
1453 cd b9 0b		        call clear_display 
1456 cd dc 0b			call update_display 
1459				;ld a, 1 
1459				;ld (hardware_diag), a 
1459			.diloop: 
1459 3e 00			ld a, display_row_1 
145b 0e 00			ld c, 0 
145d 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
145f 1e 28			ld e, 40 
1461			 
1461 21 c1 e2			ld hl, scratch	 
1464 cd 13 0e			call input_str 
1467			 
1467 3e 28			ld a, display_row_2 
1469 11 c1 e2			ld de, scratch 
146c cd cc 0b			call str_at_display 
146f cd dc 0b			call update_display 
1472			 
1472 c3 59 14			jp .diloop 
1475			 
1475			 
1475			; pass word in hl 
1475			; a has display location 
1475			display_word_at: 
1475 f5				push af 
1476 e5				push hl 
1477 7c				ld a,h 
1478 21 c6 e5			ld hl, os_word_scratch 
147b cd ef 0f			call hexout 
147e e1				pop hl 
147f 7d				ld a,l 
1480 21 c8 e5			ld hl, os_word_scratch+2 
1483 cd ef 0f			call hexout 
1486 21 ca e5			ld hl, os_word_scratch+4 
1489 3e 00			ld a,0 
148b 77				ld (hl),a 
148c 11 c6 e5			ld de,os_word_scratch 
148f f1				pop af 
1490 cd cc 0b				call str_at_display 
1493 c9				ret 
1494			 
1494			display_ptr_state: 
1494			 
1494				; to restore afterwards 
1494			 
1494 d5				push de 
1495 c5				push bc 
1496 e5				push hl 
1497 f5				push af 
1498			 
1498				; for use in here 
1498			 
1498			;	push bc 
1498			;	push de 
1498			;	push hl 
1498			;	push af 
1498			 
1498 cd b9 0b			call clear_display 
149b			 
149b 11 73 16			ld de, .ptrstate 
149e 3e 00			ld a, display_row_1 
14a0 cd cc 0b			call str_at_display 
14a3			 
14a3				; display debug step 
14a3			 
14a3			 
14a3 11 6b ee			ld de, debug_mark 
14a6 3e 26			ld a, display_row_1+display_cols-2 
14a8 cd cc 0b			call str_at_display 
14ab			 
14ab				; display a 
14ab 11 7d 16			ld de, .ptrcliptr 
14ae 3e 28			ld a, display_row_2 
14b0 cd cc 0b			call str_at_display 
14b3			 
14b3 f1				pop af 
14b4 2a 40 ea			ld hl,(cli_ptr) 
14b7 3e 30			ld a, display_row_2+8 
14b9 cd 75 14			call display_word_at 
14bc			 
14bc			 
14bc				; display hl 
14bc			 
14bc			 
14bc 11 85 16			ld de, .ptrclioptr 
14bf 3e 32			ld a, display_row_2+10 
14c1 cd cc 0b			call str_at_display 
14c4			; 
14c4			;	pop hl 
14c4 3e 35			ld a, display_row_2+13 
14c6 2a 3e ea			ld hl,(cli_origptr) 
14c9 cd 75 14			call display_word_at 
14cc			; 
14cc			;	 
14cc			;	; display de 
14cc			 
14cc			;	ld de, .regstatede 
14cc			;	ld a, display_row_3 
14cc			;	call str_at_display 
14cc			 
14cc			;	pop de 
14cc			;	ld h,d 
14cc			;	ld l, e 
14cc			;	ld a, display_row_3+3 
14cc			;	call display_word_at 
14cc			 
14cc			 
14cc				; display bc 
14cc			 
14cc			;	ld de, .regstatebc 
14cc			;	ld a, display_row_3+10 
14cc			;	call str_at_display 
14cc			 
14cc			;	pop bc 
14cc			;	ld h,b 
14cc			;	ld l, c 
14cc			;	ld a, display_row_3+13 
14cc			;	call display_word_at 
14cc			 
14cc			 
14cc				; display dsp 
14cc			 
14cc			;	ld de, .regstatedsp 
14cc			;	ld a, display_row_4 
14cc			;	call str_at_display 
14cc			 
14cc				 
14cc			;	ld hl,(cli_data_sp) 
14cc			;	ld a, display_row_4+4 
14cc			;	call display_word_at 
14cc			 
14cc				; display rsp 
14cc			 
14cc 11 b4 16			ld de, .regstatersp 
14cf 3e 82			ld a, display_row_4+10 
14d1 cd cc 0b			call str_at_display 
14d4			 
14d4				 
14d4 2a f2 e9			ld hl,(cli_ret_sp) 
14d7 3e 86			ld a, display_row_4+14 
14d9 cd 75 14			call display_word_at 
14dc			 
14dc cd dc 0b			call update_display 
14df			 
14df cd f1 0a			call delay1s 
14e2 cd f1 0a			call delay1s 
14e5 cd f1 0a			call delay1s 
14e8			 
14e8			 
14e8 cd e5 1a			call next_page_prompt 
14eb			 
14eb				; restore  
14eb			 
14eb f1				pop af 
14ec e1				pop hl 
14ed c1				pop bc 
14ee d1				pop de 
14ef c9				ret 
14f0			 
14f0			; Update the break point vector so that the user can hook a new routine 
14f0			 
14f0			bp_on: 
14f0 3e c3			ld a, $c3    ; JP 
14f2 32 6f ee			ld (debug_vector), a 
14f5 21 02 15			ld hl, break_point_state 
14f8 22 70 ee			ld (debug_vector+1), hl 
14fb c9				ret 
14fc			 
14fc			bp_off: 
14fc 3e c9			ld a, $c9    ; RET 
14fe 32 6f ee			ld (debug_vector), a 
1501 c9				ret 
1502			 
1502			 
1502			break_point_state: 
1502			;	push af 
1502			; 
1502			;	; see if disabled 
1502			; 
1502			;	ld a, (os_view_disable) 
1502			;	cp '*' 
1502			;	jr nz, .bpsgo 
1502			;	pop af 
1502			;	ret 
1502			 
1502			.bpsgo: 
1502			;	pop af 
1502 f5				push af 
1503 22 a3 e2			ld (os_view_hl), hl 
1506 ed 53 a1 e2		ld (os_view_de), de 
150a ed 43 9f e2		ld (os_view_bc), bc 
150e e5				push hl 
150f 6f				ld l, a 
1510 26 00			ld h, 0 
1512 22 a5 e2			ld (os_view_af),hl 
1515			 
1515 21 b1 ed				ld hl, display_fb0 
1518 22 cc eb				ld (display_fb_active), hl 
151b e1				pop hl	 
151c			 
151c 3e 31			ld a, '1' 
151e fe 2a		.bps1:  cp '*' 
1520 cc fc 14			call z, bp_off 
1523			;	jr nz, .bps1b 
1523			;	ld (os_view_disable),a 
1523 fe 31		.bps1b:  cp '1' 
1525 20 14			jr nz, .bps2 
1527			 
1527				; display reg 
1527			 
1527				 
1527			 
1527 3a a5 e2			ld a, (os_view_af) 
152a 2a a3 e2			ld hl, (os_view_hl) 
152d ed 5b a1 e2		ld de, (os_view_de) 
1531 ed 4b 9f e2		ld bc, (os_view_bc) 
1535 cd cf 15			call display_reg_state 
1538 c3 bb 15			jp .bpschk 
153b			 
153b fe 32		.bps2:  cp '2' 
153d 20 08			jr nz, .bps3 
153f				 
153f				; display hl 
153f 2a a3 e2			ld hl, (os_view_hl) 
1542 cd b9 16			call display_dump_at_hl 
1545			 
1545 18 74			jr .bpschk 
1547			 
1547 fe 33		.bps3:  cp '3' 
1549 20 08			jr nz, .bps4 
154b			 
154b			        ; display de 
154b 2a a1 e2			ld hl, (os_view_de) 
154e cd b9 16			call display_dump_at_hl 
1551			 
1551 18 68			jr .bpschk 
1553 fe 34		.bps4:  cp '4' 
1555 20 08			jr nz, .bps5 
1557			 
1557			        ; display bc 
1557 2a 9f e2			ld hl, (os_view_bc) 
155a cd b9 16			call display_dump_at_hl 
155d			 
155d 18 5c			jr .bpschk 
155f fe 35		.bps5:  cp '5' 
1561 20 08		        jr nz, .bps7 
1563			 
1563				; display cur ptr 
1563 2a 40 ea			ld hl, (cli_ptr) 
1566 cd b9 16			call display_dump_at_hl 
1569			 
1569 18 50			jr .bpschk 
156b fe 36		.bps7:  cp '6' 
156d 20 08			jr nz, .bps8b 
156f				 
156f				; display cur orig ptr 
156f 2a 3e ea			ld hl, (cli_origptr) 
1572 cd b9 16			call display_dump_at_hl 
1575 18 44			jr .bpschk 
1577 fe 37		.bps8b:  cp '7' 
1579 20 08			jr nz, .bps9 
157b				 
157b				; display dsp 
157b 2a ee e9			ld hl, (cli_data_sp) 
157e cd b9 16			call display_dump_at_hl 
1581			 
1581 18 38			jr .bpschk 
1583 fe 39		.bps9:  cp '9' 
1585 20 05			jr nz, .bps8c 
1587				 
1587				; display SP 
1587			;	ld hl, sp 
1587 cd b9 16			call display_dump_at_hl 
158a			 
158a 18 2f			jr .bpschk 
158c fe 38		.bps8c:  cp '8' 
158e 20 08			jr nz, .bps8d 
1590				 
1590				; display rsp 
1590 2a f2 e9			ld hl, (cli_ret_sp) 
1593 cd b9 16			call display_dump_at_hl 
1596			 
1596 18 23			jr .bpschk 
1598 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
159a 20 05			jr nz, .bps8 
159c cd b3 18			call monitor 
159f			 
159f 18 1a			jr .bpschk 
15a1 fe 30		.bps8:  cp '0' 
15a3 20 16			jr nz, .bpschk 
15a5			 
15a5 21 10 ed				ld hl, display_fb1 
15a8 22 cc eb				ld (display_fb_active), hl 
15ab cd dc 0b				call update_display 
15ae			 
15ae				;ld a, (os_view_af) 
15ae 2a a3 e2			ld hl, (os_view_hl) 
15b1 ed 5b a1 e2		ld de, (os_view_de) 
15b5 ed 4b 9f e2		ld bc, (os_view_bc) 
15b9 f1				pop af 
15ba c9				ret 
15bb			 
15bb			.bpschk:   
15bb cd f1 0a			call delay1s 
15be 3e 9f		ld a,display_row_4 + display_cols - 1 
15c0 11 e3 1a		        ld de, endprg 
15c3 cd cc 0b			call str_at_display 
15c6 cd dc 0b			call update_display 
15c9 cd 45 5e			call cin_wait 
15cc			 
15cc c3 1e 15			jp .bps1 
15cf			 
15cf			 
15cf			display_reg_state: 
15cf			 
15cf				; to restore afterwards 
15cf			 
15cf d5				push de 
15d0 c5				push bc 
15d1 e5				push hl 
15d2 f5				push af 
15d3			 
15d3				; for use in here 
15d3			 
15d3 c5				push bc 
15d4 d5				push de 
15d5 e5				push hl 
15d6 f5				push af 
15d7			 
15d7 cd b9 0b			call clear_display 
15da			 
15da 11 8f 16			ld de, .regstate 
15dd 3e 00			ld a, display_row_1 
15df cd cc 0b			call str_at_display 
15e2			 
15e2				; display debug step 
15e2			 
15e2			 
15e2 11 6b ee			ld de, debug_mark 
15e5 3e 25			ld a, display_row_1+display_cols-3 
15e7 cd cc 0b			call str_at_display 
15ea			 
15ea				; display a 
15ea 11 ab 16			ld de, .regstatea 
15ed 3e 28			ld a, display_row_2 
15ef cd cc 0b			call str_at_display 
15f2			 
15f2 e1				pop hl 
15f3			;	ld h,0 
15f3			;	ld l, a 
15f3 3e 2b			ld a, display_row_2+3 
15f5 cd 75 14			call display_word_at 
15f8			 
15f8			 
15f8				; display hl 
15f8			 
15f8			 
15f8 11 9f 16			ld de, .regstatehl 
15fb 3e 32			ld a, display_row_2+10 
15fd cd cc 0b			call str_at_display 
1600			 
1600 e1				pop hl 
1601 3e 35			ld a, display_row_2+13 
1603 cd 75 14			call display_word_at 
1606			 
1606				 
1606				; display de 
1606			 
1606 11 a3 16			ld de, .regstatede 
1609 3e 50			ld a, display_row_3 
160b cd cc 0b			call str_at_display 
160e			 
160e e1				pop hl 
160f			;	ld h,d 
160f			;	ld l, e 
160f 3e 53			ld a, display_row_3+3 
1611 cd 75 14			call display_word_at 
1614			 
1614			 
1614				; display bc 
1614			 
1614 11 a7 16			ld de, .regstatebc 
1617 3e 5a			ld a, display_row_3+10 
1619 cd cc 0b			call str_at_display 
161c			 
161c e1				pop hl 
161d			;	ld h,b 
161d			;	ld l, c 
161d 3e 5d			ld a, display_row_3+13 
161f cd 75 14			call display_word_at 
1622			 
1622			 
1622				; display dsp 
1622			 
1622 11 af 16			ld de, .regstatedsp 
1625 3e 78			ld a, display_row_4 
1627 cd cc 0b			call str_at_display 
162a			 
162a				 
162a 2a ee e9			ld hl,(cli_data_sp) 
162d 3e 7c			ld a, display_row_4+4 
162f cd 75 14			call display_word_at 
1632			 
1632				; display rsp 
1632			 
1632 11 b4 16			ld de, .regstatersp 
1635 3e 82			ld a, display_row_4+10 
1637 cd cc 0b			call str_at_display 
163a			 
163a				 
163a 2a f2 e9			ld hl,(cli_ret_sp) 
163d 3e 86			ld a, display_row_4+14 
163f cd 75 14			call display_word_at 
1642			 
1642 cd dc 0b			call update_display 
1645			 
1645			;	call delay1s 
1645			;	call delay1s 
1645			;	call delay1s 
1645			 
1645			 
1645			;	call next_page_prompt 
1645			 
1645				; restore  
1645			 
1645 f1				pop af 
1646 e1				pop hl 
1647 c1				pop bc 
1648 d1				pop de 
1649 c9				ret 
164a			 
164a .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
165e .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1673 .. 00		.ptrstate:	db "Ptr State",0 
167d .. 00		.ptrcliptr:     db "cli_ptr",0 
1685 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
168f .. 00		.regstate:	db "Reg State (1/0)",0 
169f .. 00		.regstatehl:	db "HL:",0 
16a3 .. 00		.regstatede:	db "DE:",0 
16a7 .. 00		.regstatebc:	db "BC:",0 
16ab .. 00		.regstatea:	db "A :",0 
16af .. 00		.regstatedsp:	db "DSP:",0 
16b4 .. 00		.regstatersp:	db "RSP:",0 
16b9			 
16b9			display_dump_at_hl: 
16b9 e5				push hl 
16ba d5				push de 
16bb c5				push bc 
16bc f5				push af 
16bd			 
16bd 22 e4 e5			ld (os_cur_ptr),hl	 
16c0 cd b9 0b			call clear_display 
16c3 cd ed 19			call dumpcont 
16c6			;	call delay1s 
16c6			;	call next_page_prompt 
16c6			 
16c6			 
16c6 f1				pop af 
16c7 c1				pop bc 
16c8 d1				pop de 
16c9 e1				pop hl 
16ca c9				ret 
16cb			 
16cb			;if ENABLE_BASIC 
16cb			;	include "nascombasic.asm" 
16cb			;	basic: 
16cb			;	include "forth/FORTH.ASM" 
16cb			;endif 
16cb			 
16cb			; eof 
16cb			 
16cb			 
# End of file firmware_diags.asm
16cb			  
16cb			include "firmware_prompts.asm"  
16cb			; Prompts  
16cb			 
16cb			; boot messages 
16cb			 
16cb .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
16e0 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
16f0			 
16f0			 
16f0			; config menus 
16f0			 
16f0			;prom_c3: db "Add Dictionary To File",0 
16f0			 
16f0			if STARTUP_V1 
16f0 .. 00		prom_c2: db "Select Autoload File",0 
1705 .. 00		prom_c2a: db "Disable Autoload File", 0 
171b			endif 
171b			 
171b			if STARTUP_V2 
171b			prom_c2: db "Enable Autoload Files",0 
171b			prom_c2a: db "Disable Autoload Files", 0 
171b			 
171b			crs_s1: db "*ls-word", 0 
171b			crs_s2: db "*ed-word", 0 
171b			crs_s3: db "*Demo-Games", 0 
171b			crs_s4: db "*Utils", 0 
171b			crs_s5: db "*SPI-Util", 0 
171b			crs_s6: db "*Key-Constants", 0 
171b			crs_sound: db "*Sound-Util", 0 
171b			crs_hw: db "*Hello-World",0 
171b			 
171b			 
171b			 
171b			endif 
171b			;prom_c2b: db "Select Storage Bank",0 
171b .. 00		prom_c4: db "Settings",0 
1724 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
173f .. 00		prom_m4b:   db "Monitor",0 
1747 .. 00		prom_c1: db "Hardware Diags",0 
1756			 
1756			 
1756			if STARTUP_V2 
1756			prom_c9: db "Create Startup Files",0 
1756			endif 
1756			 
1756 .. 00		prom_notav:    db "Feature not available",0 
176c .. 00		prom_empty:    db "",0 
176d			 
176d			; eof 
176d			 
# End of file firmware_prompts.asm
176d			  
176d			  
176d			; eof  
176d			  
# End of file firmware.asm
176d			 
176d			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
176d			;if BASE_KEV  
176d			;baseram: equ 08000h 
176d			;endif 
176d			 
176d			;if BASE_SC114 
176d			;baseram:     equ    endofcode 
176d			;endif 
176d			 
176d			 
176d			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
176d			 
176d			; start system 
176d			 
176d			coldstart: 
176d				; set sp 
176d				; di/ei 
176d			 
176d f3				di 
176e 31 00 f0			ld sp, tos 
1771 cd 43 5d			call init_nmi 
1774			;	ei 
1774			 
1774				; init spinner 
1774 3e 00			ld a,0 
1776 32 c6 eb			ld (display_active), a 
1779			 
1779				; disable breakpoint by default 
1779			 
1779				;ld a,'*' 
1779			;	ld a,' ' 
1779			;	ld (os_view_disable),a 
1779			 
1779				; set break point vector as new break point on or off 
1779 cd fc 14			call bp_off 
177c			 
177c				; init hardware 
177c			 
177c				; init keyboard and screen hardware 
177c			 
177c cd 1b 01			call hardware_init 
177f			 
177f			 
177f cd f1 0a			call delay1s 
1782 3e 58			ld a, display_row_3+8 
1784 11 03 01			ld de, buildtime 
1787 cd cc 0b			call str_at_display 
178a cd dc 0b			call update_display 
178d			 
178d cd f1 0a			call delay1s 
1790 cd f1 0a			call delay1s 
1793 cd f1 0a			call delay1s 
1796			 
1796				; detect if any keys are held down to enable breakpoints at start up 
1796			 
1796 cd 4d 5e			call cin  
1799 fe 00			cp 0 
179b 28 03			jr z, .nokeys 
179d			 
179d				;call hardware_diags 
179d cd 5a 13			call config 
17a0			 
17a0			;	ld de, .bpen 
17a0			;	ld a, display_row_4 
17a0			;	call str_at_display 
17a0			;	call update_display 
17a0			; 
17a0			;	ld a,0 
17a0			;	ld (os_view_disable),a 
17a0			; 
17a0			;.bpwait: 
17a0			;	call cin 
17a0			;	cp 0 
17a0			;	jr z, .bpwait 
17a0			;	jr .nokeys 
17a0			; 
17a0			; 
17a0			;.bpen:  db "Break points enabled!",0 
17a0			 
17a0			 
17a0			 
17a0			 
17a0			 
17a0			 
17a0			.nokeys: 
17a0			 
17a0			 
17a0				 
17a0			 
17a0			;jp  testkey 
17a0			 
17a0			;call storage_get_block_0 
17a0			; 
17a0			;ld hl, 0 
17a0			;ld de, store_page 
17a0			;call storage_read_block 
17a0			 
17a0				 
17a0			;ld hl, 10 
17a0			;ld de, store_page 
17a0			;call storage_read_block 
17a0			 
17a0			 
17a0			 
17a0			 
17a0			 
17a0			;stop:	nop 
17a0			;	jp stop 
17a0			 
17a0			 
17a0			 
17a0			main: 
17a0 cd b9 0b			call clear_display 
17a3 cd dc 0b			call update_display 
17a6			 
17a6			 
17a6			 
17a6			;	call testlcd 
17a6			 
17a6			 
17a6			 
17a6 cd ea 1e			call forth_init 
17a9			 
17a9			 
17a9			warmstart: 
17a9 cd c0 1e			call forth_warmstart 
17ac			 
17ac				; run startup word load 
17ac			        ; TODO prevent this running at warmstart after crash  
17ac			 
17ac				if STARTUP_ENABLE 
17ac			 
17ac					if STARTUP_V1 
17ac			 
17ac						if STORAGE_SE 
17ac							call forth_autoload 
17ac						endif 
17ac cd 93 5c					call forth_startup 
17af					endif 
17af			 
17af					if STARTUP_V2 
17af			 
17af						if STORAGE_SE 
17af							call forth_autoload 
17af						else 
17af							call forth_startup 
17af						endif 
17af			 
17af			 
17af					endif 
17af			 
17af				endif 
17af			 
17af				; show free memory after boot 
17af 11 4e 18			ld de, freeram 
17b2 3e 00			ld a, display_row_1 
17b4 cd cc 0b			call str_at_display 
17b7			 
17b7				; get current heap start after loading any uwords 
17b7			 
17b7				;ld de, (os_last_new_uword) 
17b7				;ex de, hl 
17b7			 
17b7			; Or use heap_size word???? 
17b7				;ld hl, heap_end 
17b7				;ld hl, heap_size 
17b7				;ld de, topusermem 
17b7				;ld de, heap_start 
17b7 ed 5b 70 5e			ld de, (free_list )      
17bb 21 9c e2				ld hl, heap_end 
17be ed 52			sbc hl, de 
17c0				;push hl 
17c0				;ld a,h	         	 
17c0				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
17c0				;call hexout 
17c0			   	;pop hl 
17c0			; 
17c0			;	ld a,l 
17c0			;	ld hl, os_word_scratch+2 
17c0			;	call hexout 
17c0			;	ld hl, os_word_scratch+4 
17c0			;	ld a, 0 
17c0			;	ld (hl),a 
17c0 eb				ex de, hl 
17c1 21 c6 e5			ld hl, os_word_scratch 
17c4 cd fb 10			call uitoa_16 
17c7			 
17c7			 
17c7 11 c6 e5			ld de, os_word_scratch 
17ca 3e 0d			ld a, display_row_1 + 13 
17cc cd cc 0b			call str_at_display 
17cf cd dc 0b			call update_display 
17d2			 
17d2			 
17d2				;call demo 
17d2			 
17d2			 
17d2				; init scratch input area for cli commands 
17d2			 
17d2 21 e8 e5			ld hl, os_cli_cmd 
17d5 3e 00			ld a,0 
17d7 77				ld (hl),a 
17d8 23				inc hl 
17d9 77				ld (hl),a 
17da			 
17da 3e 00			ld a,0 
17dc 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
17df			 
17df 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
17e2 32 e5 e5			ld (os_cur_ptr+1),a	 
17e5			 
17e5 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
17e8 32 c7 e5			ld (os_word_scratch+1),a	 
17eb				 
17eb			 
17eb				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17eb 21 e8 e5			ld hl, os_cli_cmd 
17ee			 
17ee 3e 00			ld a, 0		 ; init cli input 
17f0 77				ld (hl), a 
17f1 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17f3			cli: 
17f3				; show cli prompt 
17f3				;push af 
17f3				;ld a, 0 
17f3				;ld de, prompt 
17f3				;call str_at_display 
17f3			 
17f3				;call update_display 
17f3				;pop af 
17f3				;inc a 
17f3				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
17f3			 
17f3			.lastrecall: 
17f3			 
17f3 0e 00			ld c, 0 
17f5 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
17f7 1e 28			ld e, 40 
17f9			 
17f9 21 e8 e5			ld hl, os_cli_cmd 
17fc			 
17fc				STACKFRAME OFF $fefe $9f9f 
17fc				if DEBUG_STACK_IMB 
17fc					if OFF 
17fc						exx 
17fc						ld de, $fefe 
17fc						ld a, d 
17fc						ld hl, curframe 
17fc						call hexout 
17fc						ld a, e 
17fc						ld hl, curframe+2 
17fc						call hexout 
17fc						ld hl, $fefe 
17fc						push hl 
17fc						ld hl, $9f9f 
17fc						push hl 
17fc						exx 
17fc					endif 
17fc				endif 
17fc			endm 
# End of macro STACKFRAME
17fc			 
17fc cd 13 0e			call input_str 
17ff			 
17ff				STACKFRAMECHK OFF $fefe $9f9f 
17ff				if DEBUG_STACK_IMB 
17ff					if OFF 
17ff						exx 
17ff						ld hl, $9f9f 
17ff						pop de   ; $9f9f 
17ff						call cmp16 
17ff						jr nz, .spnosame 
17ff						ld hl, $fefe 
17ff						pop de   ; $fefe 
17ff						call cmp16 
17ff						jr z, .spfrsame 
17ff						.spnosame: call showsperror 
17ff						.spfrsame: nop 
17ff						exx 
17ff					endif 
17ff				endif 
17ff			endm 
# End of macro STACKFRAMECHK
17ff			 
17ff			 
17ff				; check to see if last line recall has been requested 
17ff			 
17ff			if EDIT_V2 
17ff fe 05			cp KEY_UP 
1801 20 0f			jr nz, .noexecline 
1803			 
1803 11 e8 e5			ld de, os_cli_cmd 
1806 21 e7 e6			ld hl, os_last_cmd 
1809 01 ff 00			ld bc, 255 
180c ed b0			ldir 
180e 3e 00			ld a, 0 
1810 18 e1			jr .lastrecall 
1812			endif 
1812			 
1812			.noexecline: 
1812				; no so exec the line		 
1812			 
1812				; copy input to last command 
1812			 
1812 21 e8 e5			ld hl, os_cli_cmd 
1815 11 e7 e6			ld de, os_last_cmd 
1818 01 ff 00			ld bc, 255 
181b ed b0			ldir 
181d			 
181d				; wipe current buffer 
181d			 
181d			;	ld a, 0 
181d			;	ld hl, os_cli_cmd 
181d			;	ld de, os_cli_cmd+1 
181d			;	ld bc, 254 
181d			;	ldir 
181d				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
181d			;	call strcpy 
181d			;	ld a, 0 
181d			;	ld (hl), a 
181d			;	inc hl 
181d			;	ld (hl), a 
181d			;	inc hl 
181d			;	ld (hl), a 
181d			 
181d				; switch frame buffer to program  
181d			 
181d 21 10 ed				ld hl, display_fb1 
1820 22 cc eb				ld (display_fb_active), hl 
1823			 
1823			;	nop 
1823				STACKFRAME ON $fbfe $8f9f 
1823				if DEBUG_STACK_IMB 
1823					if ON 
1823						exx 
1823						ld de, $fbfe 
1823						ld a, d 
1823						ld hl, curframe 
1823						call hexout 
1823						ld a, e 
1823						ld hl, curframe+2 
1823						call hexout 
1823						ld hl, $fbfe 
1823						push hl 
1823						ld hl, $8f9f 
1823						push hl 
1823						exx 
1823					endif 
1823				endif 
1823			endm 
# End of macro STACKFRAME
1823				; first time into the parser so pass over the current scratch pad 
1823 21 e8 e5			ld hl,os_cli_cmd 
1826				; tokenise the entered statement(s) in HL 
1826 cd 68 1f			call forthparse 
1829			        ; exec forth statements in top of return stack 
1829 cd a8 1f			call forthexec 
182c				;call forthexec_cleanup 
182c			;	call parsenext 
182c			 
182c				STACKFRAMECHK ON $fbfe $8f9f 
182c				if DEBUG_STACK_IMB 
182c					if ON 
182c						exx 
182c						ld hl, $8f9f 
182c						pop de   ; $8f9f 
182c						call cmp16 
182c						jr nz, .spnosame 
182c						ld hl, $fbfe 
182c						pop de   ; $fbfe 
182c						call cmp16 
182c						jr z, .spfrsame 
182c						.spnosame: call showsperror 
182c						.spfrsame: nop 
182c						exx 
182c					endif 
182c				endif 
182c			endm 
# End of macro STACKFRAMECHK
182c				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
182c			 
182c 3e 78			ld a, display_row_4 
182e 11 5f 18			ld de, endprog 
1831			 
1831 cd dc 0b			call update_display		 
1834			 
1834 cd e5 1a			call next_page_prompt 
1837			 
1837				; switch frame buffer to cli 
1837			 
1837 21 b1 ed				ld hl, display_fb0 
183a 22 cc eb				ld (display_fb_active), hl 
183d			 
183d			 
183d cd b9 0b		        call clear_display 
1840 cd dc 0b			call update_display		 
1843			 
1843 21 e8 e5			ld hl, os_cli_cmd 
1846			 
1846 3e 00			ld a, 0		 ; init cli input 
1848 77				ld (hl), a 
1849			 
1849				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1849			 
1849				; now on last line 
1849			 
1849				; TODO scroll screen up 
1849			 
1849				; TODO instead just clear screen and place at top of screen 
1849			 
1849			;	ld a, 0 
1849			;	ld (f_cursor_ptr),a 
1849			 
1849				;call clear_display 
1849				;call update_display 
1849			 
1849				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1849 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
184b c3 f3 17			jp cli 
184e			 
184e .. 00		freeram: db "Free bytes: ",0 
185b ..			asc: db "1A2F" 
185f .. 00		endprog: db "End prog...",0 
186b			 
186b			testenter2:   
186b 21 f3 e2			ld hl,scratch+50 
186e 22 e4 e5			ld (os_cur_ptr),hl 
1871 c3 f3 17			jp cli 
1874			 
1874			testenter:  
1874			 
1874 21 5b 18			ld hl,asc 
1877			;	ld a,(hl) 
1877			;	call nibble2val 
1877 cd 45 10			call get_byte 
187a			 
187a			 
187a			;	ld a,(hl) 
187a			;	call atohex 
187a			 
187a			;	call fourehexhl 
187a 32 f3 e2			ld (scratch+50),a 
187d			 
187d			 
187d			 
187d 21 5d 18			ld hl,asc+2 
1880			;	ld a, (hl) 
1880			;	call nibble2val 
1880 cd 45 10			call get_byte 
1883			 
1883			;	call fourehexhl 
1883 32 f5 e2			ld (scratch+52),a 
1886				 
1886 21 f3 e2			ld hl,scratch+50 
1889 22 e4 e5			ld (os_cur_ptr),hl 
188c c3 f3 17			jp cli 
188f			 
188f			enter:	 
188f 3a c5 e2			ld a,(scratch+4) 
1892 fe 00			cp 0 
1894 28 0c			jr z, .entercont 
1896				; no, not a null term line so has an address to work out.... 
1896			 
1896 21 c3 e2			ld hl,scratch+2 
1899 cd a5 10			call get_word_hl 
189c			 
189c 22 e4 e5			ld (os_cur_ptr),hl	 
189f c3 f3 17			jp cli 
18a2			 
18a2			 
18a2			.entercont:  
18a2			 
18a2 21 c3 e2			ld hl, scratch+2 
18a5 cd 45 10			call get_byte 
18a8			 
18a8 2a e4 e5		   	ld hl,(os_cur_ptr) 
18ab 77					ld (hl),a 
18ac 23					inc hl 
18ad 22 e4 e5				ld (os_cur_ptr),hl 
18b0				 
18b0			; get byte  
18b0			 
18b0			 
18b0 c3 f3 17			jp cli 
18b3			 
18b3			 
18b3			; basic monitor support 
18b3			 
18b3			monitor: 
18b3				;  
18b3 cd b9 0b			call clear_display 
18b6 3e 00			ld a, 0 
18b8 11 07 19			ld de, .monprompt 
18bb cd cc 0b			call str_at_display 
18be cd dc 0b			call update_display 
18c1			 
18c1				; get a monitor command 
18c1			 
18c1 0e 00			ld c, 0     ; entry at top left 
18c3 16 64			ld d, 100   ; max buffer size 
18c5 1e 0f			ld e, 15    ; input scroll area 
18c7 3e 00			ld a, 0     ; init string 
18c9 21 bf e4			ld hl, os_input 
18cc 77				ld (hl), a 
18cd 23				inc hl 
18ce 77				ld (hl), a 
18cf 21 bf e4			ld hl, os_input 
18d2 3e 01			ld a, 1     ; init string 
18d4 cd 13 0e			call input_str 
18d7			 
18d7 cd b9 0b		        call clear_display 
18da cd dc 0b			call update_display		 
18dd			 
18dd 3a bf e4			ld a, (os_input) 
18e0 cd 43 11			call toUpper 
18e3 fe 48		        cp 'H' 
18e5 ca 6c 19		        jp z, .monhelp 
18e8 fe 44			cp 'D'		; dump 
18ea ca 9f 19			jp z, .mondump	 
18ed fe 43			cp 'C'		; dump 
18ef ca b9 19			jp z, .moncdump	 
18f2 fe 4d			cp 'M'		; dump 
18f4 ca 09 19			jp z, .moneditstart 
18f7 fe 55			cp 'U'		; dump 
18f9 ca 15 19			jp z, .monedit	 
18fc fe 47			cp 'G'		; dump 
18fe ca 95 19			jp z, .monjump 
1901 fe 51			cp 'Q'		; dump 
1903 c8				ret z	 
1904			 
1904			 
1904				; TODO "S" to access symbol by name and not need the address 
1904				; TODO "F" to find a string in memory 
1904			 
1904 c3 b3 18			jp monitor 
1907			 
1907 .. 00		.monprompt: db ">", 0 
1909			 
1909			.moneditstart: 
1909				; get starting address 
1909			 
1909 21 c1 e4			ld hl,os_input+2 
190c cd a5 10			call get_word_hl 
190f			 
190f 22 e4 e5			ld (os_cur_ptr),hl	 
1912			 
1912 c3 b3 18			jp monitor 
1915			 
1915			.monedit: 
1915				; get byte to load 
1915			 
1915 21 c1 e4			ld hl,os_input+2 
1918 cd 45 10			call get_byte 
191b			 
191b				; get address to update 
191b 2a e4 e5			ld hl, (os_cur_ptr) 
191e			 
191e				; update byte 
191e			 
191e 77				ld (hl), a 
191f			 
191f				; move to next address and save it 
191f			 
191f 23				inc hl 
1920 22 e4 e5			ld (os_cur_ptr),hl	 
1923			 
1923 c3 b3 18			jp monitor 
1926			 
1926			 
1926 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
193a .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1956 .. 00		.monhelptext3:  db "G-Call address",0 
1965 .. 00		.monhelptext4:  db "Q-Quit",0 
196c			        
196c			.monhelp: 
196c 3e 00			ld a, display_row_1 
196e 11 26 19		        ld de, .monhelptext1 
1971			 
1971 cd cc 0b			call str_at_display 
1974 3e 28			ld a, display_row_2 
1976 11 3a 19		        ld de, .monhelptext2 
1979					 
1979 cd cc 0b			call str_at_display 
197c 3e 50			ld a, display_row_3 
197e 11 56 19		        ld de, .monhelptext3 
1981					 
1981 cd cc 0b			call str_at_display 
1984 3e 78			ld a, display_row_4 
1986 11 65 19		        ld de, .monhelptext4 
1989 cd cc 0b			call str_at_display 
198c			 
198c cd dc 0b			call update_display		 
198f			 
198f cd e5 1a			call next_page_prompt 
1992 c3 b3 18			jp monitor 
1995			 
1995			.monjump:    
1995 21 c1 e4			ld hl,os_input+2 
1998 cd a5 10			call get_word_hl 
199b			 
199b e9				jp (hl) 
199c c3 b3 18			jp monitor 
199f			 
199f			.mondump:    
199f 21 c1 e4			ld hl,os_input+2 
19a2 cd a5 10			call get_word_hl 
19a5			 
19a5 22 e4 e5			ld (os_cur_ptr),hl	 
19a8 cd ed 19			call dumpcont 
19ab 3e 78			ld a, display_row_4 
19ad 11 5f 18			ld de, endprog 
19b0			 
19b0 cd dc 0b			call update_display		 
19b3			 
19b3 cd e5 1a			call next_page_prompt 
19b6 c3 b3 18			jp monitor 
19b9			.moncdump: 
19b9 cd ed 19			call dumpcont 
19bc 3e 78			ld a, display_row_4 
19be 11 5f 18			ld de, endprog 
19c1			 
19c1 cd dc 0b			call update_display		 
19c4			 
19c4 cd e5 1a			call next_page_prompt 
19c7 c3 b3 18			jp monitor 
19ca			 
19ca			 
19ca			; TODO symbol access  
19ca			 
19ca			.symbols:     ;; A list of symbols that can be called up  
19ca b1 ed			dw display_fb0 
19cc .. 00			db "fb0",0  
19d0 7a ea		     	dw store_page 
19d2 .. 00			db "store_page",0 
19dd			 
19dd			 
19dd			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
19dd			 
19dd 3a c2 e2			ld a,(scratch+1) 
19e0 fe 00			cp 0 
19e2 28 09			jr z, dumpcont 
19e4			 
19e4				; no, not a null term line so has an address to work out.... 
19e4			 
19e4 21 c3 e2			ld hl,scratch+2 
19e7 cd a5 10			call get_word_hl 
19ea			 
19ea 22 e4 e5			ld (os_cur_ptr),hl	 
19ed			 
19ed			 
19ed			 
19ed			dumpcont: 
19ed			 
19ed				; dump bytes at ptr 
19ed			 
19ed			 
19ed 3e 00			ld a, display_row_1 
19ef 2a cc eb			ld hl, (display_fb_active) 
19f2 cd e6 0d			call addatohl 
19f5 cd 1d 1a			call .dumpbyterow 
19f8			 
19f8 3e 28			ld a, display_row_2 
19fa 2a cc eb			ld hl, (display_fb_active) 
19fd cd e6 0d			call addatohl 
1a00 cd 1d 1a			call .dumpbyterow 
1a03			 
1a03			 
1a03 3e 50			ld a, display_row_3 
1a05 2a cc eb			ld hl, (display_fb_active) 
1a08 cd e6 0d			call addatohl 
1a0b cd 1d 1a			call .dumpbyterow 
1a0e			 
1a0e 3e 78			ld a, display_row_4 
1a10 2a cc eb			ld hl, (display_fb_active) 
1a13 cd e6 0d			call addatohl 
1a16 cd 1d 1a			call .dumpbyterow 
1a19			 
1a19 cd dc 0b			call update_display 
1a1c			;		jp cli 
1a1c c9				ret 
1a1d			 
1a1d			.dumpbyterow: 
1a1d			 
1a1d				;push af 
1a1d			 
1a1d e5				push hl 
1a1e			 
1a1e				; calc where to poke the ascii 
1a1e			if display_cols == 20 
1a1e				ld a, 16 
1a1e			else 
1a1e 3e 1f			ld a, 31 
1a20			endif 
1a20			 
1a20 cd e6 0d			call addatohl 
1a23 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
1a26			 
1a26			 
1a26			; display decoding address 
1a26 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a29			 
1a29 7c				ld a,h 
1a2a e1				pop hl 
1a2b e5				push hl 
1a2c			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1a2c cd ef 0f			call hexout 
1a2f 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a32			 
1a32 7d				ld a,l 
1a33 e1				pop hl 
1a34 23				inc hl 
1a35 23				inc hl 
1a36 e5				push hl 
1a37			;	ld hl, os_word_scratch+2 
1a37 cd ef 0f			call hexout 
1a3a e1				pop hl 
1a3b 23				inc hl 
1a3c 23				inc hl 
1a3d				;ld hl, os_word_scratch+4 
1a3d 3e 3a			ld a, ':' 
1a3f 77				ld (hl),a 
1a40 23				inc hl 
1a41				;ld a, 0 
1a41				;ld (hl),a 
1a41				;ld de, os_word_scratch 
1a41				;pop af 
1a41				;push af 
1a41			;		ld a, display_row_2 
1a41			;		call str_at_display 
1a41			;		call update_display 
1a41			 
1a41			 
1a41			;pop af 
1a41			;	add 5 
1a41			 
1a41			if display_cols == 20 
1a41				ld b, 4 
1a41			else 
1a41 06 08			ld b, 8 
1a43			endif	 
1a43			 
1a43			.dumpbyte: 
1a43 c5				push bc 
1a44 e5				push hl 
1a45			 
1a45			 
1a45 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a48 7e					ld a,(hl) 
1a49			 
1a49					; poke the ascii to display 
1a49 2a c6 e5				ld hl,(os_word_scratch) 
1a4c 77					ld (hl),a 
1a4d 23					inc hl 
1a4e 22 c6 e5				ld (os_word_scratch),hl 
1a51			 
1a51					 
1a51			 
1a51			 
1a51 e1					pop hl 
1a52 e5					push hl 
1a53			 
1a53 cd ef 0f				call hexout 
1a56			 
1a56					 
1a56 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a59 23				inc hl 
1a5a 22 e4 e5		   	ld (os_cur_ptr),hl 
1a5d			 
1a5d e1					pop hl 
1a5e 23					inc hl 
1a5f 23					inc hl 
1a60 23					inc hl 
1a61			 
1a61			 
1a61			 
1a61					;ld a,0 
1a61					;ld (os_word_scratch+2),a 
1a61					;pop af 
1a61					;push af 
1a61			 
1a61					;ld de, os_word_scratch 
1a61					;call str_at_display 
1a61			;		call update_display 
1a61			;		pop af 
1a61 c1					pop bc 
1a62 c6 03				add 3 
1a64 10 dd			djnz .dumpbyte 
1a66			 
1a66				 
1a66			 
1a66 c9				ret 
1a67			 
1a67			jump:	 
1a67			 
1a67 21 c3 e2			ld hl,scratch+2 
1a6a cd a5 10			call get_word_hl 
1a6d				;ld hl,(scratch+2) 
1a6d				;call fourehexhl 
1a6d			 
1a6d 22 e4 e5			ld (os_cur_ptr),hl	 
1a70			 
1a70 e9				jp (hl) 
1a71			 
1a71			 
1a71			 
1a71			; TODO implement a basic monitor mode to start with 
1a71			 
1a71			 
1a71			 
1a71			 
1a71			 
1a71			 
1a71			 
1a71			 
1a71			 
1a71			; testing and demo code during development 
1a71			 
1a71			 
1a71 .. 00		str1: db "Enter some text...",0 
1a84 .. 00		clear: db "                    ",0 
1a99			 
1a99			demo: 
1a99			 
1a99			 
1a99			 
1a99			;	call update_display 
1a99			 
1a99				; init scratch input area for testing 
1a99 21 c1 e2			ld hl, scratch	 
1a9c 3e 00			ld a,0 
1a9e 77				ld (hl),a 
1a9f			 
1a9f			 
1a9f 3e 28		            LD   A, display_row_2 
1aa1			;            CALL fLCD_Pos       ;Position cursor to location in A 
1aa1 11 71 1a		            LD   DE, str1 
1aa4 cd cc 0b			call str_at_display 
1aa7			 
1aa7			;            CALL fLCD_Str       ;Display string pointed to by DE 
1aa7			cloop:	 
1aa7 3e 50		            LD   A, display_row_3 
1aa9			;            CALL fLCD_Pos       ;Position cursor to location in A 
1aa9 11 84 1a		            LD   DE, clear 
1aac			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1aac cd cc 0b				call str_at_display 
1aaf 3e 78			ld a, display_row_4 
1ab1 11 e1 1a			ld de, prompt 
1ab4			 
1ab4 cd cc 0b				call str_at_display 
1ab7 cd dc 0b			call update_display 
1aba			 
1aba 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1abc 16 0a			ld d, 10 
1abe 21 c1 e2			ld hl, scratch	 
1ac1 cd 13 0e			call input_str 
1ac4			 
1ac4			;	call clear_display 
1ac4			;'	call update_display 
1ac4			 
1ac4 3e 00		            LD   A, display_row_1 
1ac6			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ac6 11 84 1a		            LD   DE, clear 
1ac9 cd cc 0b				call str_at_display 
1acc			;            CALL fLCD_Str       ;Display string pointed to by DE 
1acc 3e 00		            LD   A, display_row_1 
1ace			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ace 11 c1 e2		            LD   DE, scratch 
1ad1			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ad1 cd cc 0b				call str_at_display 
1ad4 cd dc 0b			call update_display 
1ad7			 
1ad7 3e 00				ld a,0 
1ad9 21 c1 e2			ld hl, scratch 
1adc 77				ld (hl),a 
1add			 
1add 00				nop 
1ade c3 a7 1a			jp cloop 
1ae1			 
1ae1			 
1ae1			 
1ae1			; OS Prompt 
1ae1			 
1ae1 .. 00		prompt: db ">",0 
1ae3 .. 00		endprg: db "?",0 
1ae5			 
1ae5			 
1ae5			; handy next page prompt 
1ae5			next_page_prompt: 
1ae5 e5				push hl 
1ae6 d5				push de 
1ae7 f5				push af 
1ae8 c5				push bc 
1ae9			 
1ae9 3e 9f			ld a,display_row_4 + display_cols - 1 
1aeb 11 e3 1a		        ld de, endprg 
1aee cd cc 0b			call str_at_display 
1af1 cd dc 0b			call update_display 
1af4 cd 45 5e			call cin_wait 
1af7 c1				pop bc 
1af8 f1				pop af 
1af9 d1				pop de 
1afa e1				pop hl 
1afb			 
1afb			 
1afb c9				ret 
1afc			 
1afc			 
1afc			; forth parser 
1afc			 
1afc			; My forth kernel 
1afc			include "forth_kernel.asm" 
1afc			; 
1afc			; kernel to the forth OS 
1afc			 
1afc			DS_TYPE_STR: equ 1     ; string type 
1afc			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1afc			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1afc			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1afc			 
1afc			FORTH_PARSEV1: equ 0 
1afc			FORTH_PARSEV2: equ 0 
1afc			FORTH_PARSEV3: equ 0 
1afc			FORTH_PARSEV4: equ 0 
1afc			FORTH_PARSEV5: equ 1 
1afc			 
1afc			;if FORTH_PARSEV5 
1afc			;	FORTH_END_BUFFER: equ 0 
1afc			;else 
1afc			FORTH_END_BUFFER: equ 127 
1afc			;endif 
1afc			 
1afc			FORTH_TRUE: equ 1 
1afc			FORTH_FALSE: equ 0 
1afc			 
1afc			if FORTH_PARSEV4 
1afc			include "forth_stackops.asm" 
1afc			endif 
1afc			 
1afc			if FORTH_PARSEV5 
1afc			include "forth_stackopsv5.asm" 
1afc			 
1afc			; Stack operations for v5 parser on wards 
1afc			; * DATA stack 
1afc			; * LOOP stack 
1afc			; * RETURN stack 
1afc			 
1afc			 
1afc			 
1afc			FORTH_CHK_DSP_UNDER: macro 
1afc				push hl 
1afc				push de 
1afc				ld hl,(cli_data_sp) 
1afc				ld de, cli_data_stack 
1afc				call cmp16 
1afc				jp c, fault_dsp_under 
1afc				pop de 
1afc				pop hl 
1afc				endm 
1afc			 
1afc			 
1afc			FORTH_CHK_RSP_UNDER: macro 
1afc				push hl 
1afc				push de 
1afc				ld hl,(cli_ret_sp) 
1afc				ld de, cli_ret_stack 
1afc				call cmp16 
1afc				jp c, fault_rsp_under 
1afc				pop de 
1afc				pop hl 
1afc				endm 
1afc			 
1afc			FORTH_CHK_LOOP_UNDER: macro 
1afc				push hl 
1afc				push de 
1afc				ld hl,(cli_loop_sp) 
1afc				ld de, cli_loop_stack 
1afc				call cmp16 
1afc				jp c, fault_loop_under 
1afc				pop de 
1afc				pop hl 
1afc				endm 
1afc			 
1afc			FORTH_ERR_TOS_NOTSTR: macro 
1afc				; TOSO might need more for checks when used 
1afc				push af 
1afc				ld a,(hl) 
1afc				cp DS_TYPE_STR 
1afc				jp nz, type_faultn   
1afc				pop af 
1afc				endm 
1afc			 
1afc			FORTH_ERR_TOS_NOTNUM: macro 
1afc				push af 
1afc				ld a,(hl) 
1afc				cp DS_TYPE_INUM 
1afc				jp nz, type_faultn   
1afc				pop af 
1afc				endm 
1afc			 
1afc			 
1afc			; increase data stack pointer and save hl to it 
1afc				 
1afc			FORTH_DSP_NEXT: macro 
1afc				call macro_forth_dsp_next 
1afc				endm 
1afc			 
1afc			 
1afc			macro_forth_dsp_next: 
1afc				if DEBUG_FORTH_STACK_GUARD 
1afc cd 74 5a				call check_stacks 
1aff				endif 
1aff e5				push hl 
1b00 d5				push de 
1b01 eb				ex de,hl 
1b02 2a ee e9			ld hl,(cli_data_sp) 
1b05 23				inc hl 
1b06 23				inc hl 
1b07			 
1b07			; PARSEV5 
1b07 23				inc hl 
1b08 22 ee e9			ld (cli_data_sp),hl 
1b0b 73				ld (hl), e 
1b0c 23				inc hl 
1b0d 72				ld (hl), d 
1b0e d1				pop de 
1b0f e1				pop hl 
1b10				if DEBUG_FORTH_STACK_GUARD 
1b10 cd 74 5a				call check_stacks 
1b13				endif 
1b13 c9				ret 
1b14			 
1b14			 
1b14			; increase ret stack pointer and save hl to it 
1b14				 
1b14			FORTH_RSP_NEXT: macro 
1b14				call macro_forth_rsp_next 
1b14				endm 
1b14			 
1b14			macro_forth_rsp_next: 
1b14				if DEBUG_FORTH_STACK_GUARD 
1b14 cd 74 5a				call check_stacks 
1b17				endif 
1b17 e5				push hl 
1b18 d5				push de 
1b19 eb				ex de,hl 
1b1a 2a f2 e9			ld hl,(cli_ret_sp) 
1b1d 23				inc hl 
1b1e 23				inc hl 
1b1f 22 f2 e9			ld (cli_ret_sp),hl 
1b22 73				ld (hl), e 
1b23 23				inc hl 
1b24 72				ld (hl), d 
1b25 d1				pop de 
1b26 e1				pop hl 
1b27				if DEBUG_FORTH_STACK_GUARD 
1b27 cd 74 5a				call check_stacks 
1b2a				endif 
1b2a c9				ret 
1b2b			 
1b2b			; get current ret stack pointer and save to hl  
1b2b				 
1b2b			FORTH_RSP_TOS: macro 
1b2b				call macro_forth_rsp_tos 
1b2b				endm 
1b2b			 
1b2b			macro_forth_rsp_tos: 
1b2b				;push de 
1b2b 2a f2 e9			ld hl,(cli_ret_sp) 
1b2e cd 66 1b			call loadhlptrtohl 
1b31				;ld e, (hl) 
1b31				;inc hl 
1b31				;ld d, (hl) 
1b31				;ex de, hl 
1b31					if DEBUG_FORTH_WORDS 
1b31			;			DMARK "RST" 
1b31						CALLMONITOR 
1b31 cd 6f ee			call debug_vector  
1b34				endm  
# End of macro CALLMONITOR
1b34					endif 
1b34				;pop de 
1b34 c9				ret 
1b35			 
1b35			; pop ret stack pointer 
1b35				 
1b35			FORTH_RSP_POP: macro 
1b35				call macro_forth_rsp_pop 
1b35				endm 
1b35			 
1b35			 
1b35			macro_forth_rsp_pop: 
1b35				if DEBUG_FORTH_STACK_GUARD 
1b35			;		DMARK "RPP" 
1b35 cd 74 5a				call check_stacks 
1b38					FORTH_CHK_RSP_UNDER 
1b38 e5				push hl 
1b39 d5				push de 
1b3a 2a f2 e9			ld hl,(cli_ret_sp) 
1b3d 11 ac e9			ld de, cli_ret_stack 
1b40 cd 04 0e			call cmp16 
1b43 da 88 5b			jp c, fault_rsp_under 
1b46 d1				pop de 
1b47 e1				pop hl 
1b48				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b48				endif 
1b48 e5				push hl 
1b49 2a f2 e9			ld hl,(cli_ret_sp) 
1b4c			 
1b4c			 
1b4c				if FORTH_ENABLE_FREE 
1b4c			 
1b4c					; get pointer 
1b4c			 
1b4c					push de 
1b4c					push hl 
1b4c			 
1b4c					ld e, (hl) 
1b4c					inc hl 
1b4c					ld d, (hl) 
1b4c			 
1b4c					ex de, hl 
1b4c					call free 
1b4c			 
1b4c					pop hl 
1b4c					pop de 
1b4c			 
1b4c			 
1b4c				endif 
1b4c			 
1b4c			 
1b4c 2b				dec hl 
1b4d 2b				dec hl 
1b4e 22 f2 e9			ld (cli_ret_sp), hl 
1b51				; do stack underflow checks 
1b51 e1				pop hl 
1b52				if DEBUG_FORTH_STACK_GUARD 
1b52 cd 74 5a				call check_stacks 
1b55					FORTH_CHK_RSP_UNDER 
1b55 e5				push hl 
1b56 d5				push de 
1b57 2a f2 e9			ld hl,(cli_ret_sp) 
1b5a 11 ac e9			ld de, cli_ret_stack 
1b5d cd 04 0e			call cmp16 
1b60 da 88 5b			jp c, fault_rsp_under 
1b63 d1				pop de 
1b64 e1				pop hl 
1b65				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b65				endif 
1b65 c9				ret 
1b66			 
1b66			 
1b66			 
1b66			; routine to load word pointed to by hl into hl 
1b66			 
1b66			loadhlptrtohl: 
1b66			 
1b66 d5				push de 
1b67 5e				ld e, (hl) 
1b68 23				inc hl 
1b69 56				ld d, (hl) 
1b6a eb				ex de, hl 
1b6b d1				pop de 
1b6c			 
1b6c c9				ret 
1b6d			 
1b6d			 
1b6d			 
1b6d			 
1b6d			 
1b6d			; push a number held in HL onto the data stack 
1b6d			; entry point for pushing a value when already in hl used in function above 
1b6d			 
1b6d			forth_push_numhl: 
1b6d			 
1b6d e5				push hl    ; save value to push 
1b6e			 
1b6e			if DEBUG_FORTH_PUSH 
1b6e				; see if disabled 
1b6e			 
1b6e			 
1b6e f5				push af 
1b6f 3a 6f ee			ld a,(debug_vector) 
1b72 fe c9			cp $c9   ; ret 
1b74			;	ld a, (os_view_disable) 
1b74			;	cp '*' 
1b74 28 34			jr z, .pskip2 
1b76 e5				push hl 
1b77 e5			push hl 
1b78 cd b9 0b			call clear_display 
1b7b e1			pop hl 
1b7c 7c				ld a,h 
1b7d 21 c6 e5			ld hl, os_word_scratch 
1b80 cd ef 0f			call hexout 
1b83 e1				pop hl 
1b84 7d				ld a,l 
1b85 21 c8 e5			ld hl, os_word_scratch+2 
1b88 cd ef 0f			call hexout 
1b8b			 
1b8b 21 ca e5			ld hl, os_word_scratch+4 
1b8e 3e 00			ld a,0 
1b90 77				ld (hl),a 
1b91 11 c6 e5			ld de,os_word_scratch 
1b94 3e 28				ld a, display_row_2 
1b96 cd cc 0b				call str_at_display 
1b99 11 82 4c			ld de, .push_num 
1b9c 3e 00			ld a, display_row_1 
1b9e			 
1b9e cd cc 0b				call str_at_display 
1ba1			 
1ba1			 
1ba1 cd dc 0b			call update_display 
1ba4 cd f1 0a			call delay1s 
1ba7 cd f1 0a			call delay1s 
1baa			.pskip2:  
1baa			 
1baa f1				pop af 
1bab			endif	 
1bab			 
1bab			 
1bab				FORTH_DSP_NEXT 
1bab cd fc 1a			call macro_forth_dsp_next 
1bae				endm 
# End of macro FORTH_DSP_NEXT
1bae			 
1bae 2a ee e9			ld hl, (cli_data_sp) 
1bb1			 
1bb1				; save item type 
1bb1 3e 02			ld a,  DS_TYPE_INUM 
1bb3 77				ld (hl), a 
1bb4 23				inc hl 
1bb5			 
1bb5				; get word off stack 
1bb5 d1				pop de 
1bb6 7b				ld a,e 
1bb7 77				ld (hl), a 
1bb8 23				inc hl 
1bb9 7a				ld a,d 
1bba 77				ld (hl), a 
1bbb			 
1bbb			if DEBUG_FORTH_PUSH 
1bbb 2b				dec hl 
1bbc 2b				dec hl 
1bbd 2b				dec hl 
1bbe						DMARK "PH5" 
1bbe f5				push af  
1bbf 3a d3 1b			ld a, (.dmark)  
1bc2 32 6b ee			ld (debug_mark),a  
1bc5 3a d4 1b			ld a, (.dmark+1)  
1bc8 32 6c ee			ld (debug_mark+1),a  
1bcb 3a d5 1b			ld a, (.dmark+2)  
1bce 32 6d ee			ld (debug_mark+2),a  
1bd1 18 03			jr .pastdmark  
1bd3 ..			.dmark: db "PH5"  
1bd6 f1			.pastdmark: pop af  
1bd7			endm  
# End of macro DMARK
1bd7				CALLMONITOR 
1bd7 cd 6f ee			call debug_vector  
1bda				endm  
# End of macro CALLMONITOR
1bda			endif	 
1bda			 
1bda c9				ret 
1bdb			 
1bdb			 
1bdb			; Push a string to stack pointed to by hl 
1bdb			 
1bdb			forth_push_str: 
1bdb			 
1bdb			if DEBUG_FORTH_PUSH 
1bdb						DMARK "PSQ" 
1bdb f5				push af  
1bdc 3a f0 1b			ld a, (.dmark)  
1bdf 32 6b ee			ld (debug_mark),a  
1be2 3a f1 1b			ld a, (.dmark+1)  
1be5 32 6c ee			ld (debug_mark+1),a  
1be8 3a f2 1b			ld a, (.dmark+2)  
1beb 32 6d ee			ld (debug_mark+2),a  
1bee 18 03			jr .pastdmark  
1bf0 ..			.dmark: db "PSQ"  
1bf3 f1			.pastdmark: pop af  
1bf4			endm  
# End of macro DMARK
1bf4				CALLMONITOR 
1bf4 cd 6f ee			call debug_vector  
1bf7				endm  
# End of macro CALLMONITOR
1bf7			endif	 
1bf7			    
1bf7 e5				push hl 
1bf8 e5				push hl 
1bf9			 
1bf9			;	ld a, 0   ; find end of string 
1bf9 cd 4c 11			call strlenz 
1bfc			if DEBUG_FORTH_PUSH 
1bfc						DMARK "PQ2" 
1bfc f5				push af  
1bfd 3a 11 1c			ld a, (.dmark)  
1c00 32 6b ee			ld (debug_mark),a  
1c03 3a 12 1c			ld a, (.dmark+1)  
1c06 32 6c ee			ld (debug_mark+1),a  
1c09 3a 13 1c			ld a, (.dmark+2)  
1c0c 32 6d ee			ld (debug_mark+2),a  
1c0f 18 03			jr .pastdmark  
1c11 ..			.dmark: db "PQ2"  
1c14 f1			.pastdmark: pop af  
1c15			endm  
# End of macro DMARK
1c15				CALLMONITOR 
1c15 cd 6f ee			call debug_vector  
1c18				endm  
# End of macro CALLMONITOR
1c18			endif	 
1c18 eb				ex de, hl 
1c19 e1				pop hl   ; get ptr to start of string 
1c1a			if DEBUG_FORTH_PUSH 
1c1a						DMARK "PQ3" 
1c1a f5				push af  
1c1b 3a 2f 1c			ld a, (.dmark)  
1c1e 32 6b ee			ld (debug_mark),a  
1c21 3a 30 1c			ld a, (.dmark+1)  
1c24 32 6c ee			ld (debug_mark+1),a  
1c27 3a 31 1c			ld a, (.dmark+2)  
1c2a 32 6d ee			ld (debug_mark+2),a  
1c2d 18 03			jr .pastdmark  
1c2f ..			.dmark: db "PQ3"  
1c32 f1			.pastdmark: pop af  
1c33			endm  
# End of macro DMARK
1c33				CALLMONITOR 
1c33 cd 6f ee			call debug_vector  
1c36				endm  
# End of macro CALLMONITOR
1c36			endif	 
1c36 19				add hl,de 
1c37			if DEBUG_FORTH_PUSH 
1c37						DMARK "PQE" 
1c37 f5				push af  
1c38 3a 4c 1c			ld a, (.dmark)  
1c3b 32 6b ee			ld (debug_mark),a  
1c3e 3a 4d 1c			ld a, (.dmark+1)  
1c41 32 6c ee			ld (debug_mark+1),a  
1c44 3a 4e 1c			ld a, (.dmark+2)  
1c47 32 6d ee			ld (debug_mark+2),a  
1c4a 18 03			jr .pastdmark  
1c4c ..			.dmark: db "PQE"  
1c4f f1			.pastdmark: pop af  
1c50			endm  
# End of macro DMARK
1c50				CALLMONITOR 
1c50 cd 6f ee			call debug_vector  
1c53				endm  
# End of macro CALLMONITOR
1c53			endif	 
1c53			 
1c53 2b				dec hl    ; see if there is an optional trailing double quote 
1c54 7e				ld a,(hl) 
1c55 fe 22			cp '"' 
1c57 20 03			jr nz, .strnoq 
1c59 3e 00			ld a, 0      ; get rid of double quote 
1c5b 77				ld (hl), a 
1c5c 23			.strnoq: inc hl 
1c5d			 
1c5d 3e 00			ld a, 0 
1c5f 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1c60			 
1c60 13				inc de ; add one for the type string 
1c61 13				inc de ; add one for null term??? 
1c62			 
1c62				; tos is get string pointer again 
1c62				; de contains space to allocate 
1c62				 
1c62 d5				push de 
1c63			 
1c63 eb				ex de, hl 
1c64			 
1c64				;push af 
1c64			 
1c64			if DEBUG_FORTH_PUSH 
1c64						DMARK "PHm" 
1c64 f5				push af  
1c65 3a 79 1c			ld a, (.dmark)  
1c68 32 6b ee			ld (debug_mark),a  
1c6b 3a 7a 1c			ld a, (.dmark+1)  
1c6e 32 6c ee			ld (debug_mark+1),a  
1c71 3a 7b 1c			ld a, (.dmark+2)  
1c74 32 6d ee			ld (debug_mark+2),a  
1c77 18 03			jr .pastdmark  
1c79 ..			.dmark: db "PHm"  
1c7c f1			.pastdmark: pop af  
1c7d			endm  
# End of macro DMARK
1c7d				CALLMONITOR 
1c7d cd 6f ee			call debug_vector  
1c80				endm  
# End of macro CALLMONITOR
1c80			endif	 
1c80 cd c1 11			call malloc	; on ret hl now contains allocated memory 
1c83				if DEBUG_FORTH_MALLOC_GUARD 
1c83 cc da 4c				call z,malloc_error 
1c86				endif 
1c86			 
1c86				 
1c86 c1				pop bc    ; get length 
1c87 d1				pop de   ;  get string start    
1c88			 
1c88				; hl has destination from malloc 
1c88			 
1c88 eb				ex de, hl    ; prep for ldir 
1c89			 
1c89 d5				push de   ; save malloc area for DSP later 
1c8a				;push hl   ; save malloc area for DSP later 
1c8a			 
1c8a			if DEBUG_FORTH_PUSH 
1c8a						DMARK "PHc" 
1c8a f5				push af  
1c8b 3a 9f 1c			ld a, (.dmark)  
1c8e 32 6b ee			ld (debug_mark),a  
1c91 3a a0 1c			ld a, (.dmark+1)  
1c94 32 6c ee			ld (debug_mark+1),a  
1c97 3a a1 1c			ld a, (.dmark+2)  
1c9a 32 6d ee			ld (debug_mark+2),a  
1c9d 18 03			jr .pastdmark  
1c9f ..			.dmark: db "PHc"  
1ca2 f1			.pastdmark: pop af  
1ca3			endm  
# End of macro DMARK
1ca3				CALLMONITOR 
1ca3 cd 6f ee			call debug_vector  
1ca6				endm  
# End of macro CALLMONITOR
1ca6			endif	 
1ca6			 
1ca6			 
1ca6 ed b0			ldir 
1ca8			 
1ca8			 
1ca8				; push malloc to data stack     macro?????  
1ca8			 
1ca8				FORTH_DSP_NEXT 
1ca8 cd fc 1a			call macro_forth_dsp_next 
1cab				endm 
# End of macro FORTH_DSP_NEXT
1cab			 
1cab				; save value and type 
1cab			 
1cab 2a ee e9			ld hl, (cli_data_sp) 
1cae			 
1cae				; save item type 
1cae 3e 01			ld a,  DS_TYPE_STR 
1cb0 77				ld (hl), a 
1cb1 23				inc hl 
1cb2			 
1cb2				; get malloc word off stack 
1cb2 d1				pop de 
1cb3 73				ld (hl), e 
1cb4 23				inc hl 
1cb5 72				ld (hl), d 
1cb6			 
1cb6			 
1cb6			 
1cb6			if DEBUG_FORTH_PUSH 
1cb6 2a ee e9			ld hl, (cli_data_sp) 
1cb9						DMARK "PHS" 
1cb9 f5				push af  
1cba 3a ce 1c			ld a, (.dmark)  
1cbd 32 6b ee			ld (debug_mark),a  
1cc0 3a cf 1c			ld a, (.dmark+1)  
1cc3 32 6c ee			ld (debug_mark+1),a  
1cc6 3a d0 1c			ld a, (.dmark+2)  
1cc9 32 6d ee			ld (debug_mark+2),a  
1ccc 18 03			jr .pastdmark  
1cce ..			.dmark: db "PHS"  
1cd1 f1			.pastdmark: pop af  
1cd2			endm  
# End of macro DMARK
1cd2				CALLMONITOR 
1cd2 cd 6f ee			call debug_vector  
1cd5				endm  
# End of macro CALLMONITOR
1cd5			;	ex de,hl 
1cd5			endif	 
1cd5				; in case of spaces, skip the ptr past the copied string 
1cd5				;pop af 
1cd5				;ld (cli_origptr),hl 
1cd5			 
1cd5 c9				ret 
1cd6			 
1cd6			 
1cd6			 
1cd6			; TODO ascii push input onto stack given hl to start of input 
1cd6			 
1cd6			; identify type 
1cd6			; if starts with a " then a string 
1cd6			; otherwise it is a number 
1cd6			;  
1cd6			; if a string 
1cd6			;     scan for ending " to get length of string to malloc for + 1 
1cd6			;     malloc 
1cd6			;     put pointer to string on stack first byte flags as string 
1cd6			; 
1cd6			; else a number 
1cd6			;    look for number format identifier 
1cd6			;    $xx hex 
1cd6			;    %xxxxx bin 
1cd6			;    xxxxx decimal 
1cd6			;    convert number to 16bit word.  
1cd6			;    malloc word + 1 with flag to identiy as num 
1cd6			;    put pointer to number on stack 
1cd6			;   
1cd6			;  
1cd6			  
1cd6			forth_apush: 
1cd6				; kernel push 
1cd6			 
1cd6			if DEBUG_FORTH_PUSH 
1cd6						DMARK "PSH" 
1cd6 f5				push af  
1cd7 3a eb 1c			ld a, (.dmark)  
1cda 32 6b ee			ld (debug_mark),a  
1cdd 3a ec 1c			ld a, (.dmark+1)  
1ce0 32 6c ee			ld (debug_mark+1),a  
1ce3 3a ed 1c			ld a, (.dmark+2)  
1ce6 32 6d ee			ld (debug_mark+2),a  
1ce9 18 03			jr .pastdmark  
1ceb ..			.dmark: db "PSH"  
1cee f1			.pastdmark: pop af  
1cef			endm  
# End of macro DMARK
1cef				CALLMONITOR 
1cef cd 6f ee			call debug_vector  
1cf2				endm  
# End of macro CALLMONITOR
1cf2			endif	 
1cf2				; identify input type 
1cf2			 
1cf2 7e				ld a,(hl) 
1cf3 fe 22			cp '"' 
1cf5 28 0a			jr z, .fapstr 
1cf7 fe 24			cp '$' 
1cf9 ca 21 1d			jp z, .faphex 
1cfc fe 25			cp '%' 
1cfe ca 09 1d			jp z, .fapbin 
1d01			;	cp 'b' 
1d01			;	jp z, .fabin 
1d01				; else decimal 
1d01			 
1d01				; TODO do decimal conversion 
1d01				; decimal is stored as a 16bit word 
1d01			 
1d01				; by default everything is a string if type is not detected 
1d01			.fapstr: ; 
1d01 fe 22			cp '"' 
1d03 20 01			jr nz, .strnoqu 
1d05 23				inc hl 
1d06			.strnoqu: 
1d06 c3 db 1b			jp forth_push_str 
1d09			 
1d09			 
1d09			 
1d09			.fapbin:    ; push a binary string.  
1d09 11 00 00			ld de, 0   ; hold a 16bit value 
1d0c			 
1d0c 23			.fapbinshift:	inc hl  
1d0d 7e				ld a,(hl) 
1d0e fe 00			cp 0     ; done scanning  
1d10 28 0b			jr z, .fapbdone  	; got it in HL so push  
1d12			 
1d12				; left shift de 
1d12 eb				ex de, hl	 
1d13 29				add hl, hl 
1d14			 
1d14				; is 1 
1d14 fe 31			cp '1' 
1d16 20 02			jr nz, .binzero 
1d18 cb 4d			bit 1, l 
1d1a			.binzero: 
1d1a eb				ex de, hl	 ; save current de 
1d1b 18 ef			jr .fapbinshift 
1d1d			 
1d1d			.fapbdone: 
1d1d eb				ex de, hl 
1d1e c3 6d 1b			jp forth_push_numhl 
1d21			 
1d21			 
1d21			.faphex:   ; hex is always stored as a 16bit word 
1d21				; skip number prefix 
1d21 23				inc hl 
1d22				; turn ascii into number 
1d22 cd a5 10			call get_word_hl	; ret 16bit word in hl 
1d25			 
1d25 c3 6d 1b			jp forth_push_numhl 
1d28			 
1d28 00				 nop 
1d29			 
1d29			.fabin:   ; TODO bin conversion 
1d29			 
1d29			 
1d29 c9				ret 
1d2a			 
1d2a			 
1d2a			; get either a string ptr or a 16bit word from the data stack 
1d2a			 
1d2a			FORTH_DSP: macro 
1d2a				call macro_forth_dsp 
1d2a				endm 
1d2a			 
1d2a			macro_forth_dsp: 
1d2a				; data stack pointer points to current word on tos 
1d2a			 
1d2a 2a ee e9			ld hl,(cli_data_sp) 
1d2d			 
1d2d				if DEBUG_FORTH_PUSH 
1d2d						DMARK "DSP" 
1d2d f5				push af  
1d2e 3a 42 1d			ld a, (.dmark)  
1d31 32 6b ee			ld (debug_mark),a  
1d34 3a 43 1d			ld a, (.dmark+1)  
1d37 32 6c ee			ld (debug_mark+1),a  
1d3a 3a 44 1d			ld a, (.dmark+2)  
1d3d 32 6d ee			ld (debug_mark+2),a  
1d40 18 03			jr .pastdmark  
1d42 ..			.dmark: db "DSP"  
1d45 f1			.pastdmark: pop af  
1d46			endm  
# End of macro DMARK
1d46			 
1d46 cd 0d 4d				call display_data_sp 
1d49				;call break_point_state 
1d49				;rst 030h 
1d49				CALLMONITOR 
1d49 cd 6f ee			call debug_vector  
1d4c				endm  
# End of macro CALLMONITOR
1d4c				endif 
1d4c			 
1d4c c9				ret 
1d4d			 
1d4d			; return hl to start of value on stack 
1d4d			 
1d4d			FORTH_DSP_VALUE: macro 
1d4d				call macro_forth_dsp_value 
1d4d				endm 
1d4d			 
1d4d			macro_forth_dsp_value: 
1d4d			 
1d4d				FORTH_DSP 
1d4d cd 2a 1d			call macro_forth_dsp 
1d50				endm 
# End of macro FORTH_DSP
1d50			 
1d50 d5				push de 
1d51			 
1d51 23				inc hl ; skip type 
1d52			 
1d52 5e				ld e, (hl) 
1d53 23				inc hl 
1d54 56				ld d, (hl) 
1d55 eb				ex de,hl  
1d56			 
1d56 d1				pop de 
1d57			 
1d57 c9				ret 
1d58			 
1d58			; return hl to start of value to second item on stack 
1d58			 
1d58			FORTH_DSP_VALUEM1: macro 
1d58				call macro_forth_dsp_value_m1 
1d58				endm 
1d58			 
1d58			macro_forth_dsp_value_m1: 
1d58			 
1d58				FORTH_DSP 
1d58 cd 2a 1d			call macro_forth_dsp 
1d5b				endm 
# End of macro FORTH_DSP
1d5b			 
1d5b 2b				dec hl 
1d5c 2b				dec hl 
1d5d			;	dec hl 
1d5d			 
1d5d d5				push de 
1d5e			 
1d5e 5e				ld e, (hl) 
1d5f 23				inc hl 
1d60 56				ld d, (hl) 
1d61 eb				ex de,hl  
1d62			 
1d62 d1				pop de 
1d63			 
1d63 c9				ret 
1d64			 
1d64				 
1d64			 
1d64			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1d64			 
1d64			FORTH_DSP_POP: macro 
1d64				call macro_forth_dsp_pop 
1d64				endm 
1d64			 
1d64			 
1d64			; get the tos data type 
1d64			 
1d64			FORTH_DSP_TYPE:   macro 
1d64			 
1d64				;FORTH_DSP_VALUE 
1d64				FORTH_DSP 
1d64				 
1d64				; hl points to value 
1d64				; check type 
1d64			 
1d64				ld a,(hl) 
1d64			 
1d64				endm 
1d64			 
1d64			; load the tos value into hl 
1d64			 
1d64			 
1d64			FORTH_DSP_VALUEHL:  macro 
1d64				call macro_dsp_valuehl 
1d64				endm 
1d64			 
1d64			 
1d64			 
1d64			macro_dsp_valuehl: 
1d64				FORTH_DSP_VALUE 
1d64 cd 4d 1d			call macro_forth_dsp_value 
1d67				endm 
# End of macro FORTH_DSP_VALUE
1d67			 
1d67				;FORTH_ERR_TOS_NOTNUM 
1d67			 
1d67				;inc hl   ; skip type id 
1d67			 
1d67			;	push de 
1d67			; 
1d67			;	ld e, (hl) 
1d67			;	inc hl 
1d67			;	ld d, (hl) 
1d67			;	ex de,hl  
1d67			 
1d67			;	pop de 
1d67			 
1d67				if DEBUG_FORTH_PUSH 
1d67						DMARK "DVL" 
1d67 f5				push af  
1d68 3a 7c 1d			ld a, (.dmark)  
1d6b 32 6b ee			ld (debug_mark),a  
1d6e 3a 7d 1d			ld a, (.dmark+1)  
1d71 32 6c ee			ld (debug_mark+1),a  
1d74 3a 7e 1d			ld a, (.dmark+2)  
1d77 32 6d ee			ld (debug_mark+2),a  
1d7a 18 03			jr .pastdmark  
1d7c ..			.dmark: db "DVL"  
1d7f f1			.pastdmark: pop af  
1d80			endm  
# End of macro DMARK
1d80				CALLMONITOR 
1d80 cd 6f ee			call debug_vector  
1d83				endm  
# End of macro CALLMONITOR
1d83				endif 
1d83 c9				ret 
1d84			 
1d84			forth_apushstrhl:      
1d84				; push of string requires use of cli_origptr 
1d84				; bodge use 
1d84			 
1d84				; get current cli_origptr, save, update with temp pointer  
1d84 ed 5b 3e ea		ld de, (cli_origptr) 
1d88 22 3e ea			ld (cli_origptr), hl 
1d8b d5				push de 
1d8c cd d6 1c			call forth_apush 
1d8f d1				pop de 
1d90 ed 53 3e ea		ld (cli_origptr), de 
1d94 c9			        ret	 
1d95			 
1d95			 
1d95			; increase loop stack pointer and save hl to it 
1d95				 
1d95			FORTH_LOOP_NEXT: macro 
1d95				call macro_forth_loop_next 
1d95				;nop 
1d95				endm 
1d95			 
1d95			macro_forth_loop_next: 
1d95				if DEBUG_FORTH_STACK_GUARD 
1d95 cd 74 5a				call check_stacks 
1d98				endif 
1d98 e5				push hl 
1d99 d5				push de 
1d9a eb				ex de,hl 
1d9b 2a f0 e9			ld hl,(cli_loop_sp) 
1d9e 23				inc hl 
1d9f 23				inc hl 
1da0					if DEBUG_FORTH_WORDS 
1da0						DMARK "LNX" 
1da0 f5				push af  
1da1 3a b5 1d			ld a, (.dmark)  
1da4 32 6b ee			ld (debug_mark),a  
1da7 3a b6 1d			ld a, (.dmark+1)  
1daa 32 6c ee			ld (debug_mark+1),a  
1dad 3a b7 1d			ld a, (.dmark+2)  
1db0 32 6d ee			ld (debug_mark+2),a  
1db3 18 03			jr .pastdmark  
1db5 ..			.dmark: db "LNX"  
1db8 f1			.pastdmark: pop af  
1db9			endm  
# End of macro DMARK
1db9						CALLMONITOR 
1db9 cd 6f ee			call debug_vector  
1dbc				endm  
# End of macro CALLMONITOR
1dbc					endif 
1dbc 22 f0 e9			ld (cli_loop_sp),hl 
1dbf 73				ld (hl), e 
1dc0 23				inc hl 
1dc1 72				ld (hl), d 
1dc2 d1				pop de    ; been reversed so save a swap on restore 
1dc3 e1				pop hl 
1dc4				if DEBUG_FORTH_STACK_GUARD 
1dc4 cd 74 5a				call check_stacks 
1dc7				endif 
1dc7 c9				ret 
1dc8			 
1dc8			; get current ret stack pointer and save to hl  
1dc8				 
1dc8			FORTH_LOOP_TOS: macro 
1dc8				call macro_forth_loop_tos 
1dc8				endm 
1dc8			 
1dc8			macro_forth_loop_tos: 
1dc8 d5				push de 
1dc9 2a f0 e9			ld hl,(cli_loop_sp) 
1dcc 5e				ld e, (hl) 
1dcd 23				inc hl 
1dce 56				ld d, (hl) 
1dcf eb				ex de, hl 
1dd0 d1				pop de 
1dd1 c9				ret 
1dd2			 
1dd2			; pop loop stack pointer 
1dd2				 
1dd2			FORTH_LOOP_POP: macro 
1dd2				call macro_forth_loop_pop 
1dd2				endm 
1dd2			 
1dd2			 
1dd2			macro_forth_loop_pop: 
1dd2				if DEBUG_FORTH_STACK_GUARD 
1dd2					DMARK "LPP" 
1dd2 f5				push af  
1dd3 3a e7 1d			ld a, (.dmark)  
1dd6 32 6b ee			ld (debug_mark),a  
1dd9 3a e8 1d			ld a, (.dmark+1)  
1ddc 32 6c ee			ld (debug_mark+1),a  
1ddf 3a e9 1d			ld a, (.dmark+2)  
1de2 32 6d ee			ld (debug_mark+2),a  
1de5 18 03			jr .pastdmark  
1de7 ..			.dmark: db "LPP"  
1dea f1			.pastdmark: pop af  
1deb			endm  
# End of macro DMARK
1deb cd 74 5a				call check_stacks 
1dee					FORTH_CHK_LOOP_UNDER 
1dee e5				push hl 
1def d5				push de 
1df0 2a f0 e9			ld hl,(cli_loop_sp) 
1df3 11 2a e9			ld de, cli_loop_stack 
1df6 cd 04 0e			call cmp16 
1df9 da 8e 5b			jp c, fault_loop_under 
1dfc d1				pop de 
1dfd e1				pop hl 
1dfe				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1dfe				endif 
1dfe e5				push hl 
1dff 2a f0 e9			ld hl,(cli_loop_sp) 
1e02 2b				dec hl 
1e03 2b				dec hl 
1e04 22 f0 e9			ld (cli_loop_sp), hl 
1e07				; TODO do stack underflow checks 
1e07 e1				pop hl 
1e08				if DEBUG_FORTH_STACK_GUARD 
1e08 cd 74 5a				call check_stacks 
1e0b					FORTH_CHK_LOOP_UNDER 
1e0b e5				push hl 
1e0c d5				push de 
1e0d 2a f0 e9			ld hl,(cli_loop_sp) 
1e10 11 2a e9			ld de, cli_loop_stack 
1e13 cd 04 0e			call cmp16 
1e16 da 8e 5b			jp c, fault_loop_under 
1e19 d1				pop de 
1e1a e1				pop hl 
1e1b				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e1b				endif 
1e1b c9				ret 
1e1c			 
1e1c			macro_forth_dsp_pop: 
1e1c			 
1e1c e5				push hl 
1e1d			 
1e1d				; release malloc data 
1e1d			 
1e1d				if DEBUG_FORTH_STACK_GUARD 
1e1d cd 74 5a				call check_stacks 
1e20					FORTH_CHK_DSP_UNDER 
1e20 e5				push hl 
1e21 d5				push de 
1e22 2a ee e9			ld hl,(cli_data_sp) 
1e25 11 28 e8			ld de, cli_data_stack 
1e28 cd 04 0e			call cmp16 
1e2b da 82 5b			jp c, fault_dsp_under 
1e2e d1				pop de 
1e2f e1				pop hl 
1e30				endm 
# End of macro FORTH_CHK_DSP_UNDER
1e30				endif 
1e30				;ld hl,(cli_data_sp) 
1e30			if DEBUG_FORTH_DOT 
1e30				DMARK "DPP" 
1e30 f5				push af  
1e31 3a 45 1e			ld a, (.dmark)  
1e34 32 6b ee			ld (debug_mark),a  
1e37 3a 46 1e			ld a, (.dmark+1)  
1e3a 32 6c ee			ld (debug_mark+1),a  
1e3d 3a 47 1e			ld a, (.dmark+2)  
1e40 32 6d ee			ld (debug_mark+2),a  
1e43 18 03			jr .pastdmark  
1e45 ..			.dmark: db "DPP"  
1e48 f1			.pastdmark: pop af  
1e49			endm  
# End of macro DMARK
1e49				CALLMONITOR 
1e49 cd 6f ee			call debug_vector  
1e4c				endm  
# End of macro CALLMONITOR
1e4c			endif	 
1e4c			 
1e4c			 
1e4c			if FORTH_ENABLE_DSPPOPFREE 
1e4c			 
1e4c				FORTH_DSP 
1e4c cd 2a 1d			call macro_forth_dsp 
1e4f				endm 
# End of macro FORTH_DSP
1e4f			 
1e4f 7e				ld a, (hl) 
1e50 fe 01			cp DS_TYPE_STR 
1e52 20 23			jr nz, .skippopfree 
1e54			 
1e54				FORTH_DSP_VALUEHL 
1e54 cd 64 1d			call macro_dsp_valuehl 
1e57				endm 
# End of macro FORTH_DSP_VALUEHL
1e57 00				nop 
1e58			if DEBUG_FORTH_DOT 
1e58				DMARK "DPf" 
1e58 f5				push af  
1e59 3a 6d 1e			ld a, (.dmark)  
1e5c 32 6b ee			ld (debug_mark),a  
1e5f 3a 6e 1e			ld a, (.dmark+1)  
1e62 32 6c ee			ld (debug_mark+1),a  
1e65 3a 6f 1e			ld a, (.dmark+2)  
1e68 32 6d ee			ld (debug_mark+2),a  
1e6b 18 03			jr .pastdmark  
1e6d ..			.dmark: db "DPf"  
1e70 f1			.pastdmark: pop af  
1e71			endm  
# End of macro DMARK
1e71				CALLMONITOR 
1e71 cd 6f ee			call debug_vector  
1e74				endm  
# End of macro CALLMONITOR
1e74			endif	 
1e74 cd 8b 12			call free 
1e77			.skippopfree: 
1e77				 
1e77			 
1e77			endif 
1e77			 
1e77			if DEBUG_FORTH_DOT_KEY 
1e77				DMARK "DP2" 
1e77				CALLMONITOR 
1e77			endif	 
1e77			 
1e77				; move pointer down 
1e77			 
1e77 2a ee e9			ld hl,(cli_data_sp) 
1e7a 2b				dec hl 
1e7b 2b				dec hl 
1e7c			; PARSEV5 
1e7c 2b				dec hl 
1e7d 22 ee e9			ld (cli_data_sp), hl 
1e80			 
1e80				if DEBUG_FORTH_STACK_GUARD 
1e80 cd 74 5a				call check_stacks 
1e83					FORTH_CHK_DSP_UNDER 
1e83 e5				push hl 
1e84 d5				push de 
1e85 2a ee e9			ld hl,(cli_data_sp) 
1e88 11 28 e8			ld de, cli_data_stack 
1e8b cd 04 0e			call cmp16 
1e8e da 82 5b			jp c, fault_dsp_under 
1e91 d1				pop de 
1e92 e1				pop hl 
1e93				endm 
# End of macro FORTH_CHK_DSP_UNDER
1e93				endif 
1e93			 
1e93 e1				pop hl 
1e94			 
1e94 c9				ret 
1e95			 
1e95			getwordathl: 
1e95				; hl points to an address 
1e95				; load hl with the word at that address 
1e95			 
1e95 d5				push de 
1e96			 
1e96 5e				ld e, (hl) 
1e97 23				inc hl 
1e98 56				ld d, (hl) 
1e99 eb				ex de, hl 
1e9a			 
1e9a d1				pop de 
1e9b c9				ret 
1e9c			 
1e9c			 
1e9c			 
1e9c			 
1e9c			 
1e9c			; eof 
1e9c			 
# End of file forth_stackopsv5.asm
1e9c			endif 
1e9c			 
1e9c			loadwordinhl:	 
1e9c			 
1e9c d5				push de 
1e9d			 
1e9d 5e				ld e, (hl) 
1e9e 23				inc hl 
1e9f 56				ld d, (hl) 
1ea0 eb				ex de,hl  
1ea1			 
1ea1 d1				pop de 
1ea2			 
1ea2 c9				ret 
1ea3			 
1ea3			user_word_eol:  
1ea3				; hl contains the pointer to where to create a linked list item from the end 
1ea3				; of the user dict to continue on at the system word dict 
1ea3				 
1ea3				; poke the stub of the word list linked list to repoint to rom words 
1ea3			 
1ea3				; stub format 
1ea3				; db   word id 
1ea3				; dw    link to next word 
1ea3			        ; db char length of token 
1ea3				; db string + 0 term 
1ea3				; db exec code....  
1ea3			 
1ea3 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1ea5 77				ld (hl), a		; word id 
1ea6 23				inc hl 
1ea7			 
1ea7 11 72 20			ld de, sysdict 
1eaa 73				ld (hl), e		; next word link ie system dict 
1eab 23				inc hl 
1eac 72				ld (hl), d		; next word link ie system dict 
1ead 23				inc hl	 
1eae			 
1eae			;	ld (hl), sysdict		; next word link ie system dict 
1eae			;	inc hl 
1eae			;	inc hl 
1eae			 
1eae			;	inc hl 
1eae			;	inc hl 
1eae			 
1eae 3e 02			ld a, 2			; word length is 0 
1eb0 77				ld (hl), a	 
1eb1 23				inc hl 
1eb2			 
1eb2 3e 7e			ld a, '~'			; word length is 0 
1eb4 77				ld (hl), a	 
1eb5 23				inc hl 
1eb6 3e 00			ld a, 0			; save empty word 
1eb8 77				ld (hl), a 
1eb9			 
1eb9 c9				ret 
1eba			 
1eba				 
1eba			 
1eba			forthexec_cleanup: 
1eba				FORTH_RSP_POP 
1eba cd 35 1b			call macro_forth_rsp_pop 
1ebd				endm 
# End of macro FORTH_RSP_POP
1ebd c9				ret 
1ebe			 
1ebe			forth_call_hl: 
1ebe				; taking hl 
1ebe e5				push hl 
1ebf c9				ret 
1ec0			 
1ec0			; this is called to reset Forth system but keep existing uwords etc 
1ec0			 
1ec0			forth_warmstart: 
1ec0				; setup stack over/under flow checks 
1ec0				if DEBUG_FORTH_STACK_GUARD 
1ec0 cd 5a 5a				call chk_stk_init 
1ec3				endif 
1ec3			 
1ec3				; init stack pointers  - * these stacks go upwards *  
1ec3 21 ac e9			ld hl, cli_ret_stack 
1ec6 22 f2 e9			ld (cli_ret_sp), hl	 
1ec9				; set bottom of stack 
1ec9 3e 00			ld a,0 
1ecb 77				ld (hl),a 
1ecc 23				inc hl 
1ecd 77				ld (hl),a 
1ece			 
1ece 21 28 e8			ld hl, cli_data_stack 
1ed1 22 ee e9			ld (cli_data_sp), hl	 
1ed4				; set bottom of stack 
1ed4 3e 00			ld a,0 
1ed6 77				ld (hl),a 
1ed7 23				inc hl 
1ed8 77				ld (hl),a 
1ed9			 
1ed9 21 2a e9			ld hl, cli_loop_stack 
1edc 22 f0 e9			ld (cli_loop_sp), hl	 
1edf				; set bottom of stack 
1edf 3e 00			ld a,0 
1ee1 77				ld (hl),a 
1ee2 23				inc hl 
1ee3 77				ld (hl),a 
1ee4			 
1ee4				; init extent of current open file 
1ee4			 
1ee4 3e 00			ld a, 0 
1ee6 32 6a ea			ld (store_openext), a 
1ee9			 
1ee9 c9				ret 
1eea			 
1eea			 
1eea			 
1eea			; Cold Start - this is called to setup the whole Forth system 
1eea			 
1eea			forth_init: 
1eea			 
1eea				; setup stack over/under flow checks 
1eea			 
1eea			;	if DEBUG_FORTH_STACK_GUARD 
1eea			;		call chk_stk_init 
1eea			;	endif 
1eea			 
1eea				; enable auto display updates (slow.....) 
1eea			 
1eea 3e 01			ld a, 1 
1eec 32 3c ea			ld (cli_autodisplay), a 
1eef			 
1eef				; if storage is in use disable long reads for now 
1eef 3e 00			ld a, 0 
1ef1 32 75 ea			ld (store_longread), a 
1ef4			 
1ef4			 
1ef4				; show start up screen 
1ef4			 
1ef4 cd b9 0b			call clear_display 
1ef7			 
1ef7 3e 00			ld a,0 
1ef9 32 5e ea			ld (f_cursor_ptr), a 
1efc			 
1efc				; set start of word list in start of ram - for use when creating user words 
1efc			 
1efc 21 66 5e			ld hl, baseram 
1eff 22 be e5			ld (os_last_new_uword), hl 
1f02 cd a3 1e			call user_word_eol 
1f05				 
1f05			;		call display_data_sp 
1f05			;		call next_page_prompt 
1f05			 
1f05			 
1f05			 
1f05			 
1f05 c9				ret 
1f06			 
1f06 .. 00		.bootforth: db " Forth Kernel Init ",0 
1f1a			 
1f1a			; TODO push to stack 
1f1a			 
1f1a			;  
1f1a			 
1f1a			if FORTH_PARSEV2 
1f1a			 
1f1a			 
1f1a				include "forth_parserv2.asm" 
1f1a			 
1f1a			endif 
1f1a			 
1f1a			 
1f1a			; parse cli version 1 
1f1a			 
1f1a			if FORTH_PARSEV1 
1f1a			 
1f1a			 
1f1a			 
1f1a			      include "forth_parserv1.asm" 
1f1a			endif 
1f1a				 
1f1a			if FORTH_PARSEV3 
1f1a			 
1f1a			 
1f1a			 
1f1a			      include "forth_parserv3.asm" 
1f1a				include "forth_wordsv3.asm" 
1f1a			endif 
1f1a			 
1f1a			if FORTH_PARSEV4 
1f1a			 
1f1a			 
1f1a			 
1f1a			      include "forth_parserv4.asm" 
1f1a				include "forth_wordsv4.asm" 
1f1a			endif 
1f1a			 
1f1a			if FORTH_PARSEV5 
1f1a			 
1f1a			 
1f1a			 
1f1a			      include "forth_parserv5.asm" 
1f1a			 
1f1a			 
1f1a			; A better parser without using malloc and string copies all over the place.  
1f1a			; Exec in situ should be faster 
1f1a			 
1f1a			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1f1a			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1f1a			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1f1a			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1f1a			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1f1a			WORD_SYS_END: equ 0   ; Opcode for all user words 
1f1a			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1f1a			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1f1a			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1f1a			 
1f1a			; Core word preamble macro 
1f1a			 
1f1a			CWHEAD:   macro nxtword opcode lit len opflags 
1f1a				db WORD_SYS_CORE+opcode             
1f1a				; internal op code number 
1f1a				dw nxtword            
1f1a				; link to next dict word block 
1f1a				db len + 1 
1f1a				; literal length of dict word inc zero term 
1f1a				db lit,0              
1f1a				; literal dict word 
1f1a			        ; TODO db opflags        
1f1a				endm 
1f1a			 
1f1a			 
1f1a			NEXTW: macro  
1f1a				jp macro_next 
1f1a				endm 
1f1a			 
1f1a			macro_next: 
1f1a			if DEBUG_FORTH_PARSE_KEY 
1f1a				DMARK "NXT" 
1f1a				CALLMONITOR 
1f1a			endif	 
1f1a			;	inc hl  ; skip token null term  
1f1a ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f1e ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f22 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f25			if DEBUG_FORTH_PARSE_KEY 
1f25				DMARK "}AA" 
1f25				CALLMONITOR 
1f25			endif	 
1f25 c3 28 20			jp execnext 
1f28				;jp exec1 
1f28			       
1f28			 
1f28			 
1f28			; Another go at the parser to compile  
1f28			 
1f28			 
1f28			; TODO rework parser to change all of the string words to byte tokens 
1f28			; TODO do a search for  
1f28			 
1f28			; TODO first run normal parser to zero term sections 
1f28			; TODO for each word do a token look up to get the op code 
1f28			; TODO need some means to flag to the exec that this is a byte code form    
1f28			 
1f28			 
1f28			forthcompile: 
1f28			 
1f28			; 
1f28			; line parse: 
1f28			;       parse raw input buffer 
1f28			;       tokenise the words 
1f28			;       malloc new copy (for looping etc) 
1f28			;       copy to malloc + current pc in line to start of string and add line term 
1f28			;       save on new rsp 
1f28			; 
1f28			 
1f28			; hl to point to the line to tokenise 
1f28			 
1f28			;	push hl 
1f28 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
1f2b			 
1f2b			;	ld a,0		; string term on input 
1f2b			;	call strlent 
1f2b			 
1f2b			;	ld (os_tok_len), hl	 ; save string length 
1f2b			 
1f2b			;if DEBUG_FORTH_TOK 
1f2b			;	ex de,hl		 
1f2b			;endif 
1f2b			 
1f2b			;	pop hl 		; get back string pointer 
1f2b			 
1f2b			if DEBUG_FORTH_TOK 
1f2b						DMARK "TOc" 
1f2b				CALLMONITOR 
1f2b			endif 
1f2b 7e			.cptoken2:    ld a,(hl) 
1f2c 23				inc hl 
1f2d fe 7f			cp FORTH_END_BUFFER 
1f2f 28 29			jr z, .cptokendone2 
1f31 fe 00			cp 0 
1f33 28 25			jr z, .cptokendone2 
1f35 fe 22			cp '"' 
1f37 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1f39 fe 20			cp ' ' 
1f3b 20 ee			jr nz,  .cptoken2 
1f3d			 
1f3d			; TODO consume comments held between ( and ) 
1f3d			 
1f3d				; we have a space so change to zero term for dict match later 
1f3d 2b				dec hl 
1f3e 3e 00			ld a,0 
1f40 77				ld (hl), a 
1f41 23				inc hl 
1f42 18 e7			jr .cptoken2 
1f44				 
1f44			 
1f44			.cptokenstr2: 
1f44				; skip all white space until either eol (because forgot to term) or end double quote 
1f44			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f44				;inc hl ; skip current double quote 
1f44 7e				ld a,(hl) 
1f45 23				inc hl 
1f46 fe 22			cp '"' 
1f48 28 e1			jr z, .cptoken2 
1f4a fe 7f			cp FORTH_END_BUFFER 
1f4c 28 0c			jr z, .cptokendone2 
1f4e fe 00			cp 0 
1f50 28 08			jr z, .cptokendone2 
1f52 fe 20			cp ' ' 
1f54 28 02			jr z, .cptmp2 
1f56 18 ec			jr .cptokenstr2 
1f58			 
1f58			.cptmp2:	; we have a space so change to zero term for dict match later 
1f58				;dec hl 
1f58				;ld a,"-"	; TODO remove this when working 
1f58				;ld (hl), a 
1f58				;inc hl 
1f58 18 ea			jr .cptokenstr2 
1f5a			 
1f5a			.cptokendone2: 
1f5a				;inc hl 
1f5a 3e 7f			ld a, FORTH_END_BUFFER 
1f5c 77				ld (hl),a 
1f5d 23				inc hl 
1f5e 3e 21			ld a, '!' 
1f60 77				ld (hl),a 
1f61			 
1f61 2a c2 e5			ld hl,(os_tok_ptr) 
1f64			         
1f64			if DEBUG_FORTH_TOK 
1f64						DMARK "Tc1" 
1f64				CALLMONITOR 
1f64			endif 
1f64			 
1f64				; push exec string to top of return stack 
1f64				FORTH_RSP_NEXT 
1f64 cd 14 1b			call macro_forth_rsp_next 
1f67				endm 
# End of macro FORTH_RSP_NEXT
1f67 c9				ret 
1f68			 
1f68			; Another go at the parser need to simplify the process 
1f68			 
1f68			forthparse: 
1f68			 
1f68			; 
1f68			; line parse: 
1f68			;       parse raw input buffer 
1f68			;       tokenise the words 
1f68			;       malloc new copy (for looping etc) 
1f68			;       copy to malloc + current pc in line to start of string and add line term 
1f68			;       save on new rsp 
1f68			; 
1f68			 
1f68			; hl to point to the line to tokenise 
1f68			 
1f68			;	push hl 
1f68 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
1f6b			 
1f6b			;	ld a,0		; string term on input 
1f6b			;	call strlent 
1f6b			 
1f6b			;	ld (os_tok_len), hl	 ; save string length 
1f6b			 
1f6b			;if DEBUG_FORTH_TOK 
1f6b			;	ex de,hl		 
1f6b			;endif 
1f6b			 
1f6b			;	pop hl 		; get back string pointer 
1f6b			 
1f6b			if DEBUG_FORTH_TOK 
1f6b						DMARK "TOK" 
1f6b				CALLMONITOR 
1f6b			endif 
1f6b 7e			.ptoken2:    ld a,(hl) 
1f6c 23				inc hl 
1f6d fe 7f			cp FORTH_END_BUFFER 
1f6f 28 29			jr z, .ptokendone2 
1f71 fe 00			cp 0 
1f73 28 25			jr z, .ptokendone2 
1f75 fe 22			cp '"' 
1f77 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1f79 fe 20			cp ' ' 
1f7b 20 ee			jr nz,  .ptoken2 
1f7d			 
1f7d			; TODO consume comments held between ( and ) 
1f7d			 
1f7d				; we have a space so change to zero term for dict match later 
1f7d 2b				dec hl 
1f7e 3e 00			ld a,0 
1f80 77				ld (hl), a 
1f81 23				inc hl 
1f82 18 e7			jr .ptoken2 
1f84				 
1f84			 
1f84			.ptokenstr2: 
1f84				; skip all white space until either eol (because forgot to term) or end double quote 
1f84			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f84				;inc hl ; skip current double quote 
1f84 7e				ld a,(hl) 
1f85 23				inc hl 
1f86 fe 22			cp '"' 
1f88 28 e1			jr z, .ptoken2 
1f8a fe 7f			cp FORTH_END_BUFFER 
1f8c 28 0c			jr z, .ptokendone2 
1f8e fe 00			cp 0 
1f90 28 08			jr z, .ptokendone2 
1f92 fe 20			cp ' ' 
1f94 28 02			jr z, .ptmp2 
1f96 18 ec			jr .ptokenstr2 
1f98			 
1f98			.ptmp2:	; we have a space so change to zero term for dict match later 
1f98				;dec hl 
1f98				;ld a,"-"	; TODO remove this when working 
1f98				;ld (hl), a 
1f98				;inc hl 
1f98 18 ea			jr .ptokenstr2 
1f9a			 
1f9a			.ptokendone2: 
1f9a				;inc hl 
1f9a 3e 7f			ld a, FORTH_END_BUFFER 
1f9c 77				ld (hl),a 
1f9d 23				inc hl 
1f9e 3e 21			ld a, '!' 
1fa0 77				ld (hl),a 
1fa1			 
1fa1 2a c2 e5			ld hl,(os_tok_ptr) 
1fa4			         
1fa4			if DEBUG_FORTH_TOK 
1fa4						DMARK "TK1" 
1fa4				CALLMONITOR 
1fa4			endif 
1fa4			 
1fa4				; push exec string to top of return stack 
1fa4				FORTH_RSP_NEXT 
1fa4 cd 14 1b			call macro_forth_rsp_next 
1fa7				endm 
# End of macro FORTH_RSP_NEXT
1fa7 c9				ret 
1fa8			 
1fa8			; 
1fa8			;	; malloc size + buffer pointer + if is loop flag 
1fa8			;	ld hl,(os_tok_len) 		 ; get string length 
1fa8			; 
1fa8			;	ld a,l 
1fa8			; 
1fa8			;	cp 0			; we dont want to use a null string 
1fa8			;	ret z 
1fa8			; 
1fa8			;;	add 3    ; prefix malloc with buffer for current word ptr 
1fa8			; 
1fa8			;	add 5     ; TODO when certain not over writing memory remove 
1fa8			; 
1fa8			;		 
1fa8			; 
1fa8			;if DEBUG_FORTH_TOK 
1fa8			;			DMARK "TKE" 
1fa8			;	CALLMONITOR 
1fa8			;endif 
1fa8			; 
1fa8			;	ld l,a 
1fa8			;	ld h,0 
1fa8			;;	push hl   ; save required space for the copy later 
1fa8			;	call malloc 
1fa8			;if DEBUG_FORTH_TOK 
1fa8			;			DMARK "TKM" 
1fa8			;	CALLMONITOR 
1fa8			;endif 
1fa8			;	if DEBUG_FORTH_MALLOC_GUARD 
1fa8			;		push af 
1fa8			;		call ishlzero 
1fa8			;;		ld a, l 
1fa8			;;		add h 
1fa8			;;		cp 0 
1fa8			;		pop af 
1fa8			;		 
1fa8			;		call z,malloc_error 
1fa8			;	endif 
1fa8			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1fa8			; 
1fa8			; 
1fa8			;if DEBUG_FORTH_TOK 
1fa8			;			DMARK "TKR" 
1fa8			;	CALLMONITOR 
1fa8			;endif 
1fa8			; 
1fa8			;	FORTH_RSP_NEXT 
1fa8			; 
1fa8			;	;inc hl	 ; go past current buffer pointer 
1fa8			;	;inc hl 
1fa8			;	;inc hl   ; and past if loop flag 
1fa8			;		; TODO Need to set flag  
1fa8			; 
1fa8			;	 
1fa8			;	 
1fa8			;	ex de,hl	; malloc is dest 
1fa8			;	ld hl, (os_tok_len) 
1fa8			;;	pop bc 
1fa8			;	ld c, l                
1fa8			;	ld b,0 
1fa8			;	ld hl, (os_tok_ptr) 
1fa8			; 
1fa8			;if DEBUG_FORTH_TOK 
1fa8			;			DMARK "TKT" 
1fa8			;	CALLMONITOR 
1fa8			;endif 
1fa8			; 
1fa8			;	; do str cpy 
1fa8			; 
1fa8			;	ldir      ; copy byte in hl to de 
1fa8			; 
1fa8			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1fa8			; 
1fa8			;if DEBUG_FORTH_TOK 
1fa8			; 
1fa8			;			DMARK "TKY" 
1fa8			;	CALLMONITOR 
1fa8			;endif 
1fa8			;	;ld a,0 
1fa8			;	;ld a,FORTH_END_BUFFER 
1fa8			;	ex de, hl 
1fa8			;	;dec hl			 ; go back over the space delim at the end of word 
1fa8			;	;ld (hl),a 
1fa8			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1fa8			;	ld a,FORTH_END_BUFFER 
1fa8			;	ld (hl),a 
1fa8			;	inc hl 
1fa8			;	ld a,FORTH_END_BUFFER 
1fa8			;	ld (hl),a 
1fa8			; 
1fa8			;	; init the malloc area data 
1fa8			;	; set pc for in current area 
1fa8			;	;ld hl, (os_tok_malloc) 
1fa8			;	;inc hl 
1fa8			;	;inc hl 
1fa8			;	;inc hl 
1fa8			;	;ex de,hl 
1fa8			;	;ld hl, (os_tok_malloc) 
1fa8			;	;ld (hl),e 
1fa8			;	;inc hl 
1fa8			;	;ld (hl),d 
1fa8			; 
1fa8			; 
1fa8			;	ld hl,(os_tok_malloc) 
1fa8			;if DEBUG_FORTH_PARSE_KEY 
1fa8			;			DMARK "TKU" 
1fa8			;	CALLMONITOR 
1fa8			;endif 
1fa8			; 
1fa8			;	ret 
1fa8			 
1fa8			forthexec: 
1fa8			 
1fa8			; line exec: 
1fa8			; forth parser 
1fa8			 
1fa8			; 
1fa8			;       get current exec line on rsp 
1fa8			 
1fa8				FORTH_RSP_TOS 
1fa8 cd 2b 1b			call macro_forth_rsp_tos 
1fab				endm 
# End of macro FORTH_RSP_TOS
1fab			 
1fab			;       restore current pc - hl points to malloc of data 
1fab			 
1fab				;ld e, (hl) 
1fab				;inc hl 
1fab				;ld d, (hl) 
1fab				;ex de,hl 
1fab			 
1fab			 
1fab			exec1: 
1fab 22 c2 e5			ld (os_tok_ptr), hl 
1fae			 
1fae				; copy our PC to working vars  
1fae 22 40 ea			ld (cli_ptr), hl 
1fb1 22 3e ea			ld (cli_origptr), hl 
1fb4			 
1fb4 7e				ld a,(hl) 
1fb5 fe 7f			cp FORTH_END_BUFFER 
1fb7 c8				ret z 
1fb8			 
1fb8				; skip any nulls 
1fb8			 
1fb8 fe 00			cp 0 
1fba 20 03			jr nz, .execword 
1fbc 23				inc hl 
1fbd 18 ec			jr exec1 
1fbf			 
1fbf			 
1fbf			.execword: 
1fbf			 
1fbf			 
1fbf			 
1fbf			if DEBUG_FORTH_PARSE_KEY 
1fbf						DMARK "KYQ" 
1fbf				CALLMONITOR 
1fbf			endif 
1fbf			;       while at start of word: 
1fbf			; get start of dict (in user area first) 
1fbf			 
1fbf 21 66 5e		ld hl, baseram 
1fc2			;ld hl, sysdict 
1fc2 22 42 ea		ld (cli_nextword),hl 
1fc5			;           match word at pc 
1fc5			;           exec word 
1fc5			;           or push to dsp 
1fc5			;           forward to next token 
1fc5			;           if line term pop rsp and exit 
1fc5			;        
1fc5			 
1fc5			if DEBUG_FORTH_PARSE_KEY 
1fc5						DMARK "KYq" 
1fc5				CALLMONITOR 
1fc5			endif 
1fc5			 
1fc5			; 
1fc5			; word comp 
1fc5			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1fc5			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1fc5			;    move to start of word  
1fc5			;    compare word to cli_token 
1fc5			 
1fc5			.execpnword:	; HL at start of a word in the dictionary to check 
1fc5			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1fc5			;	ld (cli_ptr), hl 
1fc5			 
1fc5 2a 42 ea			ld hl,(cli_nextword) 
1fc8			 
1fc8 cd 6b 20			call forth_tok_next 
1fcb			; tok next start here 
1fcb			;	; TODO skip compiled symbol for now 
1fcb			;	inc hl 
1fcb			; 
1fcb			;	; save pointer to next word 
1fcb			; 
1fcb			;	; hl now points to the address of the next word pointer  
1fcb			;	ld e, (hl) 
1fcb			;	inc hl 
1fcb			;	ld d, (hl) 
1fcb			;	inc l 
1fcb			; 
1fcb			;	ex de,hl 
1fcb			;if DEBUG_FORTH_PARSE_NEXTWORD 
1fcb			;	push bc 
1fcb			;	ld bc, (cli_nextword) 
1fcb			;			DMARK "NXW" 
1fcb			;	CALLMONITOR 
1fcb			;	pop bc 
1fcb			;endif 
1fcb			; tok next end here 
1fcb 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
1fce eb				ex de, hl 
1fcf			 
1fcf			 
1fcf				; save the pointer of the current token - 1 to check against 
1fcf				 
1fcf 22 46 ea			ld (cli_token), hl   
1fd2				; TODO maybe remove below save if no debug 
1fd2				; save token string ptr for any debug later 
1fd2 23				inc hl  
1fd3 22 48 ea			ld (cli_origtoken), hl 
1fd6 2b				dec hl 
1fd7				; save pointer to the start of the next dictionay word 
1fd7 7e				ld a,(hl)   ; get string length 
1fd8 47				ld b,a 
1fd9			.execpnwordinc:  
1fd9 23				inc hl 
1fda 10 fd			djnz .execpnwordinc 
1fdc 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
1fdf			 
1fdf				; now check the word token against the string being parsed 
1fdf			 
1fdf 2a 46 ea			ld hl,(cli_token) 
1fe2 23				inc hl     ; skip string length (use zero term instead to end) 
1fe3 22 46 ea			ld (cli_token), hl 
1fe6			 
1fe6			if DEBUG_FORTH_PARSE_KEY 
1fe6						DMARK "KY2" 
1fe6			endif 
1fe6			if DEBUG_FORTH_PARSE_EXEC 
1fe6				; see if disabled 
1fe6			 
1fe6			;	ld a, (os_view_disable) 
1fe6			;	cp '*' 
1fe6				ld a, (debug_vector) 
1fe6				cp $c9   ; RET  
1fe6				jr z, .skip 
1fe6			 
1fe6				push hl 
1fe6				push hl 
1fe6				call clear_display 
1fe6				ld de, .compword 
1fe6				ld a, display_row_1 
1fe6				call str_at_display 
1fe6				pop de 
1fe6				ld a, display_row_2 
1fe6				call str_at_display 
1fe6				ld hl,(cli_ptr) 
1fe6				ld a,(hl) 
1fe6			        ld hl, os_word_scratch 
1fe6				ld (hl),a 
1fe6				ld a,0 
1fe6				inc hl 
1fe6				ld (hl),a 	 
1fe6				ld de, os_word_scratch 
1fe6				ld a, display_row_2+10 
1fe6				call str_at_display 
1fe6				call update_display 
1fe6				ld a, 100 
1fe6				call aDelayInMS 
1fe6				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1fe6				call delay250ms 
1fe6				endif 
1fe6				pop hl 
1fe6			.skip:  
1fe6			endif	 
1fe6			.execpnchar:    ; compare char between token and string to parse 
1fe6			 
1fe6			if DEBUG_FORTH_PARSE_KEY 
1fe6						DMARK "Ky3" 
1fe6			endif 
1fe6			if DEBUG_FORTH_PARSE_EXEC 
1fe6				; see if disabled 
1fe6			 
1fe6			;	ld a, (os_view_disable) 
1fe6			;	cp '*' 
1fe6				ld a, (debug_vector) 
1fe6				cp $C9  ; RET 
1fe6				jr z, .skip2 
1fe6			 
1fe6			;	call clear_display 
1fe6			ld hl,(cli_token) 
1fe6			ld a,(hl) 
1fe6			ld (os_word_scratch),a 
1fe6				ld hl,(cli_ptr) 
1fe6			ld a,(hl) 
1fe6				ld (os_word_scratch+1),a 
1fe6				ld a,0 
1fe6				ld (os_word_scratch+2),a 
1fe6				ld de,os_word_scratch 
1fe6				ld a,display_row_4 
1fe6				call str_at_display 
1fe6				call update_display 
1fe6			.skip2:  
1fe6			endif 
1fe6 2a 46 ea			ld hl,(cli_token) 
1fe9 7e				ld a, (hl)	 ; char in word token 
1fea 23				inc hl 		; move to next char 
1feb 22 46 ea			ld (cli_token), hl ; and save it 
1fee 47				ld b,a 
1fef			 
1fef 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
1ff2 7e				ld a,(hl) 
1ff3 23				inc hl 
1ff4 22 40 ea			ld (cli_ptr), hl		; move to next char 
1ff7 cd 43 11			call toUpper 		; make sure the input string matches case 
1ffa			 
1ffa			if DEBUG_FORTH_PARSE 
1ffa			endif 
1ffa			 
1ffa				; input stream end of token is a space so get rid of it 
1ffa			 
1ffa			;	cp ' ' 
1ffa			;	jr nz, .pnskipspace 
1ffa			; 
1ffa			;	ld a, 0		; make same term as word token term 
1ffa			; 
1ffa			;.pnskipspace: 
1ffa			 
1ffa			if DEBUG_FORTH_PARSE_KEY 
1ffa						DMARK "KY7" 
1ffa			endif 
1ffa b8				cp b 
1ffb c2 11 20			jp nz, .execpnskipword	 ; no match so move to next word 
1ffe				 
1ffe			;    if same 
1ffe			;       scan for string terms 0 for token and 32 for input 
1ffe			 
1ffe				 
1ffe			if DEBUG_FORTH_PARSE_KEY 
1ffe						DMARK "KY8" 
1ffe			endif 
1ffe			 
1ffe 80				add b			 
1fff fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2001							; TODO need to make sure last word in zero term string is accounted for 
2001 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2003			 
2003			 
2003				; at end of both strings so both are exact match 
2003			 
2003			;       skip ptr for next word 
2003			 
2003 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
2006 23				inc hl			 ; at next char 
2007 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
200a 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
200d				 
200d				 
200d			if DEBUG_FORTH_PARSE_KEY 
200d						DMARK "KY3" 
200d			endif 
200d			 
200d			 
200d			 
200d			;       exec code block 
200d			if DEBUG_FORTH_JP 
200d				call clear_display 
200d				call update_display 
200d				call delay1s 
200d				ld hl, (cli_execword)     ; save for next check if no match on this word 
200d				ld a,h 
200d				ld hl, os_word_scratch 
200d				call hexout 
200d				ld hl, (cli_execword)     ; save for next check if no match on this word 
200d				ld a,l 
200d				ld hl, os_word_scratch+2 
200d				call hexout 
200d				ld hl, os_word_scratch+4 
200d				ld a,0 
200d				ld (hl),a 
200d				ld de,os_word_scratch 
200d				call str_at_display 
200d					ld a, display_row_2 
200d					call str_at_display 
200d				ld de, (cli_origtoken) 
200d				ld a, display_row_1+10 
200d					call str_at_display 
200d			 
200d				ld a,display_row_1 
200d				ld de, .foundword 
200d				ld a, display_row_3 
200d				call str_at_display 
200d				call update_display 
200d				call delay1s 
200d				call delay1s 
200d				call delay1s 
200d			endif 
200d			 
200d			if DEBUG_FORTH_PARSE_KEY 
200d						DMARK "KYj" 
200d			endif 
200d				; TODO save the word pointer in this exec 
200d			 
200d 2a 44 ea			ld hl,(cli_execword) 
2010 e9				jp (hl) 
2011			 
2011			 
2011			;    if not same 
2011			;	scan for zero term 
2011			;	get ptr for next word 
2011			;	goto word comp 
2011			 
2011			.execpnskipword:	; get pointer to next word 
2011 2a 42 ea			ld hl,(cli_nextword) 
2014			 
2014 7e				ld a,(hl) 
2015 fe 00			cp WORD_SYS_END 
2017			;	cp 0 
2017 28 09			jr z, .execendofdict			 ; at end of words 
2019			 
2019			if DEBUG_FORTH_PARSE_KEY 
2019						DMARK "KY4" 
2019			endif 
2019			if DEBUG_FORTH_PARSE_EXEC 
2019			 
2019				; see if disabled 
2019			 
2019			;	ld a, (os_view_disable) 
2019			;	cp '*' 
2019				ld a,(debug_vector) 
2019				cp $c9   ; RET 
2019				jr z, .noskip 
2019			 
2019			 
2019				ld de, .nowordfound 
2019				ld a, display_row_3 
2019				call str_at_display 
2019				call update_display 
2019				ld a, 100 
2019				call aDelayInMS 
2019				 
2019				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2019					call delay250ms 
2019				endif 
2019			.noskip:  
2019			 
2019			endif	 
2019			 
2019 2a 3e ea			ld hl,(cli_origptr) 
201c 22 40 ea			ld (cli_ptr),hl 
201f			 
201f			if DEBUG_FORTH_PARSE_KEY 
201f						DMARK "KY5" 
201f			endif 
201f c3 c5 1f			jp .execpnword			; else go to next word 
2022			 
2022			.execendofdict:  
2022			 
2022			if DEBUG_FORTH_PARSE_KEY 
2022						DMARK "KYe" 
2022			endif 
2022			if DEBUG_FORTH_PARSE_EXEC 
2022				; see if disabled 
2022			 
2022			;	ld a, (os_view_disable) 
2022			;	cp '*' 
2022				ld a,(debug_vector) 
2022				cp $c9   ; ret 
2022				jr z, .ispskip 
2022			 
2022				call clear_display 
2022				call update_display 
2022				call delay1s 
2022				ld de, (cli_origptr) 
2022				ld a, display_row_1 
2022				call str_at_display 
2022				 
2022				ld de, .enddict 
2022				ld a, display_row_3 
2022				call str_at_display 
2022				call update_display 
2022				ld a, 100 
2022				call aDelayInMS 
2022				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2022				call delay1s 
2022				call delay1s 
2022				call delay1s 
2022				endif 
2022			.ispskip:  
2022				 
2022			endif	 
2022			 
2022			 
2022			 
2022				; if the word is not a keyword then must be a literal so push it to stack 
2022			 
2022			; push token to stack to end of word 
2022			 
2022				STACKFRAME ON $1efe $2f9f 
2022				if DEBUG_STACK_IMB 
2022					if ON 
2022						exx 
2022						ld de, $1efe 
2022						ld a, d 
2022						ld hl, curframe 
2022						call hexout 
2022						ld a, e 
2022						ld hl, curframe+2 
2022						call hexout 
2022						ld hl, $1efe 
2022						push hl 
2022						ld hl, $2f9f 
2022						push hl 
2022						exx 
2022					endif 
2022				endif 
2022			endm 
# End of macro STACKFRAME
2022			 
2022 2a c2 e5		ld hl,(os_tok_ptr) 
2025 cd d6 1c		call forth_apush 
2028			 
2028				STACKFRAMECHK ON $1efe $2f9f 
2028				if DEBUG_STACK_IMB 
2028					if ON 
2028						exx 
2028						ld hl, $2f9f 
2028						pop de   ; $2f9f 
2028						call cmp16 
2028						jr nz, .spnosame 
2028						ld hl, $1efe 
2028						pop de   ; $1efe 
2028						call cmp16 
2028						jr z, .spfrsame 
2028						.spnosame: call showsperror 
2028						.spfrsame: nop 
2028						exx 
2028					endif 
2028				endif 
2028			endm 
# End of macro STACKFRAMECHK
2028			 
2028			execnext: 
2028			 
2028			if DEBUG_FORTH_PARSE_KEY 
2028						DMARK "KY>" 
2028			endif 
2028			; move past token to next word 
2028			 
2028 2a c2 e5		ld hl, (os_tok_ptr) 
202b 3e 00		ld a, 0 
202d 01 ff 00		ld bc, 255     ; input buffer size 
2030 ed b1		cpir 
2032			 
2032			if DEBUG_FORTH_PARSE_KEY 
2032						DMARK "KY!" 
2032				CALLMONITOR 
2032			endif	 
2032			; TODO this might place hl on the null, so will need to forward on??? 
2032			;inc hl   ; see if this gets onto the next item 
2032			 
2032			 
2032			; TODO pass a pointer to the buffer to push 
2032			; TODO call function to push 
2032			 
2032			; look for end of input 
2032			 
2032			;inc hl 
2032			;ld a,(hl) 
2032			;cp FORTH_END_BUFFER 
2032			;ret z 
2032			 
2032			 
2032 c3 ab 1f		jp exec1 
2035			 
2035			 
2035			 
2035			 
2035			 
2035			 
2035			 
2035			 
2035			 
2035			findnexttok: 
2035			 
2035				; hl is pointer to move 
2035				; de is the token to locate 
2035			 
2035					if DEBUG_FORTH 
2035						DMARK "NTK" 
2035						CALLMONITOR 
2035					endif 
2035 d5				push de 
2036			 
2036			.fnt1:	 
2036				; find first char of token to locate 
2036			 
2036 1a				ld a, (de) 
2037 4f				ld c,a 
2038 7e				ld a,(hl) 
2039 cd 43 11			call toUpper 
203c					if DEBUG_FORTH 
203c						DMARK "NT1" 
203c						CALLMONITOR 
203c					endif 
203c b9				cp c 
203d			 
203d 28 03			jr z, .fnt2cmpmorefirst	 
203f			 
203f				; first char not found move to next char 
203f			 
203f 23				inc hl 
2040 18 f4			jr .fnt1 
2042			 
2042			.fnt2cmpmorefirst:	 
2042				; first char of token found.  
2042			 
2042 e5				push hl     ; save start of token just in case it is the right one 
2043 d9				exx 
2044 e1				pop hl        ; save it to hl' 
2045 d9				exx 
2046			 
2046			 
2046			.fnt2cmpmore:	 
2046				; compare the rest 
2046				 
2046 23				inc hl 
2047 13				inc de 
2048				 
2048 1a				ld a, (de) 
2049 4f				ld c,a 
204a 7e				ld a,(hl) 
204b cd 43 11			call toUpper 
204e			 
204e					if DEBUG_FORTH 
204e						DMARK "NT2" 
204e						CALLMONITOR 
204e					endif 
204e				; c has the token to find char 
204e				; a has the mem to scan char 
204e			 
204e b9				cp c 
204f 28 04			jr z,.fntmatch1 
2051			 
2051				; they are not the same 
2051			 
2051					if DEBUG_FORTH 
2051						DMARK "NT3" 
2051						CALLMONITOR 
2051					endif 
2051 d1				pop de	; reset de token to look for 
2052 d5				push de 
2053 18 e1			jr .fnt1 
2055				 
2055			.fntmatch1: 
2055			 
2055				; is the same char a null which means we might have a full hit? 
2055					if DEBUG_FORTH 
2055						DMARK "NT4" 
2055						CALLMONITOR 
2055					endif 
2055			 
2055 fe 00			cp 0 
2057 28 0b			jr z, .fntmatchyes 
2059			 
2059				; are we at the end of the token to find? 
2059			 
2059					if DEBUG_FORTH 
2059						DMARK "NT5" 
2059						CALLMONITOR 
2059					endif 
2059 3e 00			ld a, 0 
205b b9				cp c 
205c			 
205c c2 46 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
205f			 
205f					if DEBUG_FORTH 
205f						DMARK "NT6" 
205f						CALLMONITOR 
205f					endif 
205f				; token to find is exhusted but no match to stream 
205f			 
205f				; restore tok pointer and continue on 
205f d1				pop de 
2060 d5				push de 
2061 c3 36 20			jp .fnt1 
2064			 
2064			 
2064			.fntmatchyes: 
2064			 
2064				; hl now contains the end of the found token 
2064			 
2064				; get rid of saved token pointer to find 
2064			 
2064 d1				pop de 
2065			 
2065					if DEBUG_FORTH 
2065						DMARK "NT9" 
2065						CALLMONITOR 
2065					endif 
2065			 
2065				; hl will be on the null term so forward on 
2065			 
2065				; get back the saved start of the token 
2065			 
2065 d9				exx 
2066 e5				push hl     ; save start of token just in case it is the right one 
2067 d9				exx 
2068 e1				pop hl        ; save it to hl 
2069			 
2069 c9				ret 
206a			 
206a			 
206a			; LIST needs to find a specific token   
206a			; FORGET needs to find a spefici token 
206a			 
206a			; SAVE needs to find all tokens by flag 
206a			; WORDS just needs to scan through all  by flag 
206a			; UWORDS needs to scan through all by flag 
206a			 
206a			 
206a			; given hl as pointer to start of dict look up string 
206a			; return hl as pointer to start of word block 
206a			; or 0 if not found 
206a			 
206a			forth_find_tok: 
206a c9				ret 
206b			 
206b			; given hl as pointer to dict structure 
206b			; move to the next dict block structure 
206b			 
206b			forth_tok_next: 
206b				; hl now points to the address of the next word pointer  
206b				; TODO skip compiled symbol for now 
206b			;	push de 
206b 23				inc hl 
206c 5e				ld e, (hl) 
206d 23				inc hl 
206e 56				ld d, (hl) 
206f 23				inc hl 
2070			 
2070 eb				ex de,hl 
2071			if DEBUG_FORTH_PARSE_NEXTWORD 
2071				push bc 
2071				ld bc, (cli_nextword) 
2071						DMARK "NXW" 
2071				CALLMONITOR 
2071				pop bc 
2071			endif 
2071			;	pop de	 
2071 c9				ret 
2072			 
2072			 
2072			 
2072			; eof 
# End of file forth_parserv5.asm
2072				include "forth_wordsv4.asm" 
2072			 
2072			; the core word dictionary v4 
2072			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2072			 
2072			; this is a linked list for each of the system words used 
2072			; user defined words will follow the same format but will be in ram 
2072			 
2072			 
2072			; 
2072			; 
2072			; define linked list: 
2072			; 
2072			; 1. compiled byte op code 
2072			; 2. len of text word 
2072			; 3. text word 
2072			; 4. ptr to next dictionary word 
2072			; 5. asm, calls etc for the word 
2072			; 
2072			;  if 1 == 0 then last word in dict  
2072			;   
2072			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2072			;  
2072			;  
2072			; create basic standard set of words 
2072			; 
2072			;  
2072			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2072			; 2DUP 2DROP 2SWAP  
2072			; @ C@ - get byte  
2072			; ! C! - store byte 
2072			; 0< true if less than zero 
2072			; 0= true if zero 
2072			; < >  
2072			; = true if same 
2072			; variables 
2072			 
2072			 
2072			; Hardware specific words I may need 
2072			; 
2072			; IN OUT  
2072			; calls to key util functions 
2072			; calls to hardward abstraction stuff 
2072			; easy control of frame buffers and lcd i/o 
2072			; keyboard  
2072			 
2072			 
2072			;DICT: macro 
2072			; op_code, len, word, next 
2072			;    word: 
2072			;    db op_code 
2072			;    ds word zero term 
2072			;    dw next 
2072			;    endm 
2072			 
2072			 
2072			 
2072			 
2072			; op code 1 is a flag for user define words which are to be handled differently 
2072			 
2072			 
2072			; 
2072			; 
2072			;    TODO on entry to a word this should be the expected environment 
2072			;    hl - tos value if number then held, if string this is the ptr 
2072			;    de -  
2072			 
2072			 
2072			; opcode ranges 
2072			; 0 - end of word dict 
2072			; 255 - user define words 
2072			 
2072			sysdict: 
2072			include "forth_opcodes.asm" 
2072			; op codes for forth keywords 
2072			; free to use code 0  
2072				OPCODE_HEAP: equ  1 
2072				OPCODE_EXEC: equ 2 
2072				OPCODE_DUP: equ 3 
2072				OPCODE_SWAP: equ 4 
2072				OPCODE_COLN: equ 5 
2072				OPCODE_SCOLN: equ 6 
2072				OPCODE_DROP: equ 7 
2072				OPCODE_DUP2: equ 8 
2072				OPCODE_DROP2: equ 9 
2072				OPCODE_SWAP2: equ 10 
2072				OPCODE_AT: equ 11 
2072				OPCODE_CAT: equ 12 
2072				OPCODE_BANG: equ 13 
2072				OPCODE_CBANG: equ 14 
2072				OPCODE_SCALL: equ 15 
2072				OPCODE_DEPTH: equ 16 
2072				OPCODE_OVER: equ 17 
2072				OPCODE_PAUSE: equ 18 
2072				OPCODE_PAUSES: equ 19 
2072				OPCODE_ROT: equ 20 
2072			;free to reuse	OPCODE_WORDS: equ 21 
2072			        OPCODE_NOT: equ 21 
2072				OPCODE_UWORDS: equ 22 
2072				OPCODE_BP: equ 23 
2072				OPCODE_MONITOR: equ 24  
2072				OPCODE_MALLOC: equ 25 
2072				OPCODE_FREE: equ 26 
2072				OPCODE_LIST: equ 27 
2072				OPCODE_FORGET: equ 28 
2072				OPCODE_NOP: equ 29 
2072				OPCODE_COMO: equ 30 
2072				OPCODE_COMC: equ 31 
2072			;free to reuse	OPCODE_ENDCORE: equ 32 
2072				OPCODE_AFTERSOUND: equ 33 
2072				OPCODE_GP2: equ 34 
2072				OPCODE_GP3: equ 35 
2072				OPCODE_GP4: equ 36 
2072				OPCODE_SIN: equ 37 
2072				OPCODE_SOUT: equ 38 
2072				OPCODE_SPIO: equ 39 
2072				OPCODE_SPICEH: equ 40 
2072				OPCODE_SPIOb: equ 41 
2072				OPCODE_SPII: equ 42 
2072				OPCODE_SESEL: equ 43 
2072				OPCODE_CARTDEV: equ 44 
2072			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2072				OPCODE_FB: equ 46 
2072				OPCODE_EMIT: equ 47 
2072				OPCODE_DOTH: equ 48 
2072				OPCODE_DOTF: equ 49 
2072				OPCODE_DOT: equ 50 
2072				OPCODE_CLS: equ 51 
2072				OPCODE_DRAW: equ 52 
2072				OPCODE_DUMP: equ 53 
2072				OPCODE_CDUMP: equ 54 
2072				OPCODE_DAT: equ 55 
2072				OPCODE_HOME: equ 56 
2072				OPCODE_SPACE: equ 57 
2072				OPCODE_SPACES: equ 58 
2072				OPCODE_SCROLL: equ 59 
2072				OPCODE_ATQ: equ 60 
2072				OPCODE_AUTODSP: equ 61 
2072				OPCODE_MENU: equ 62 
2072			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2072				OPCODE_THEN: equ 64 
2072				OPCODE_ELSE: equ 65 
2072				OPCODE_DO: equ 66 
2072				OPCODE_LOOP: equ 67 
2072				OPCODE_I: equ 68 
2072				OPCODE_DLOOP: equ 69  
2072				OPCODE_REPEAT: equ 70  
2072				OPCODE_UNTIL: equ 71 
2072				OPCODE_ENDFLOW: equ 72 
2072				OPCODE_WAITK: equ 73 
2072				OPCODE_ACCEPT: equ 74 
2072				OPCODE_EDIT: equ 75 
2072			;free to reuse	OPCODE_ENDKEY: equ 76 
2072				OPCODE_LZERO: equ 77 
2072				OPCODE_TZERO: equ 78 
2072				OPCODE_LESS: equ 79 
2072				OPCODE_GT: equ 80 
2072				OPCODE_EQUAL: equ 81  
2072			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2072				OPCODE_NEG: equ 83 
2072				OPCODE_DIV: equ 84 
2072				OPCODE_MUL: equ 85 
2072				OPCODE_MIN: equ 86 
2072				OPCODE_MAX: equ 87 
2072				OPCODE_RND16: equ 88 
2072				OPCODE_RND8: equ 89 
2072				OPCODE_RND: equ 90 
2072			;free to reuse	OPCODE_ENDMATHS: equ 91  
2072				OPCODE_BYNAME: equ 92 
2072				OPCODE_DIR: equ 93 
2072				OPCODE_SAVE: equ 94 
2072				OPCODE_LOAD: equ 95 
2072				OPCODE_BSAVE: equ 96 
2072				OPCODE_BLOAD: equ 97 
2072				OPCODE_SEO: equ 98  
2072				OPCODE_SEI: equ 99 
2072				OPCODE_SFREE: equ 100 
2072				OPCODE_SIZE: equ 101 
2072				OPCODE_CREATE: equ 102 
2072				OPCODE_APPEND: equ 103 
2072				OPCODE_SDEL: equ 104 
2072				OPCODE_OPEN: equ 105 
2072				OPCODE_READ: equ 106 
2072				OPCODE_EOF: equ 106 
2072				OPCODE_FORMAT: equ 107 
2072				OPCODE_LABEL: equ 108 
2072				OPCODE_LABELS: equ 109 
2072			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2072				OPCODE_UPPER: equ 111 
2072				OPCODE_LOWER: equ 112 
2072				OPCODE_SUBSTR: equ 113 
2072				OPCODE_LEFT: equ 114 
2072				OPCODE_RIGHT: equ 115 
2072				OPCODE_STR2NUM: equ 116 
2072				OPCODE_NUM2STR: equ 117 
2072				OPCODE_CONCAT: equ 118 
2072				OPCODE_FIND: equ 119 
2072				OPCODE_LEN: equ 120 
2072				OPCODE_CHAR: equ 121 
2072			; free to reuse	OPCODE_STRLEN: equ 122 
2072			; free to reuse	OPCODE_ENDSTR: equ 123 
2072				OPCODE_V0S: equ 124 
2072				OPCODE_V0Q: equ 125 
2072				OPCODE_V1S: equ 126 
2072				OPCODE_V1Q: equ 127 
2072				OPCODE_V2S: equ 128 
2072				OPCODE_V2Q: equ 129 
2072				OPCODE_V3S: equ 130 
2072				OPCODE_V3Q: equ 131 
2072			;free to reuse	OPCODE_END: equ 132 
2072				OPCODE_ZDUP: equ 133 
2072			 
2072			; eof 
# End of file forth_opcodes.asm
2072			 
2072			include "forth_words_core.asm" 
2072			 
2072			; | ## Core Words 
2072			 
2072			;if MALLOC_4 
2072			 
2072			.HEAP: 
2072			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2072 15				db WORD_SYS_CORE+OPCODE_HEAP             
2073 b1 20			dw .EXEC            
2075 05				db 4 + 1 
2076 .. 00			db "HEAP",0              
207b				endm 
# End of macro CWHEAD
207b			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
207b			; | | u1 - Current number of bytes in the heap 
207b			; | | u2 - Remaining bytes left on the heap 
207b			; | |  
207b			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
207b			 
207b			 
207b				if DEBUG_FORTH_WORDS_KEY 
207b					DMARK "HEP" 
207b f5				push af  
207c 3a 90 20			ld a, (.dmark)  
207f 32 6b ee			ld (debug_mark),a  
2082 3a 91 20			ld a, (.dmark+1)  
2085 32 6c ee			ld (debug_mark+1),a  
2088 3a 92 20			ld a, (.dmark+2)  
208b 32 6d ee			ld (debug_mark+2),a  
208e 18 03			jr .pastdmark  
2090 ..			.dmark: db "HEP"  
2093 f1			.pastdmark: pop af  
2094			endm  
# End of macro DMARK
2094					CALLMONITOR 
2094 cd 6f ee			call debug_vector  
2097				endm  
# End of macro CALLMONITOR
2097				endif 
2097 2a 70 5e			ld hl, (free_list )      
209a 11 75 5e			ld de, heap_start 
209d			 
209d ed 52			sbc hl, de  
209f			 
209f cd 6d 1b			call forth_push_numhl 
20a2			 
20a2			 
20a2 ed 5b 70 5e		ld de, (free_list )      
20a6 21 9c e2			ld hl, heap_end 
20a9			 
20a9 ed 52			sbc hl, de 
20ab			 
20ab cd 6d 1b			call forth_push_numhl 
20ae				 
20ae			 
20ae				 
20ae			 
20ae			 
20ae			 
20ae				NEXTW 
20ae c3 1a 1f			jp macro_next 
20b1				endm 
# End of macro NEXTW
20b1			;endif 
20b1			 
20b1			.EXEC: 
20b1			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
20b1			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
20b1			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
20b1			;; > > 
20b1			;; > >   
20b1			;	STACKFRAME OFF $5efe $5f9f 
20b1			; 
20b1			;		if DEBUG_FORTH_WORDS_KEY 
20b1			;			DMARK "EXE" 
20b1			;			CALLMONITOR 
20b1			;		endif 
20b1			; 
20b1			;	FORTH_DSP_VALUEHL 
20b1			; 
20b1			;	FORTH_DSP_POP 
20b1			; 
20b1			;		if DEBUG_FORTH_WORDS 
20b1			;			DMARK "EX1" 
20b1			;			CALLMONITOR 
20b1			;		endif 
20b1			;;	ld e,(hl) 
20b1			;;	inc hl 
20b1			;;	ld d,(hl) 
20b1			;;	ex de,hl 
20b1			; 
20b1			;;		if DEBUG_FORTH_WORDS 
20b1			;;			DMARK "EX2" 
20b1			;;			CALLMONITOR 
20b1			;;		endif 
20b1			;	push hl 
20b1			; 
20b1			;	;ld a, 0 
20b1			;	;ld a, FORTH_END_BUFFER 
20b1			;	call strlenz 
20b1			;	inc hl   ; include zero term to copy 
20b1			;	inc hl   ; include term 
20b1			;	inc hl   ; include term 
20b1			;	ld b,0 
20b1			;	ld c,l 
20b1			;	pop hl 
20b1			;	ld de, execscratch 
20b1			;		if DEBUG_FORTH_WORDS 
20b1			;			DMARK "EX3" 
20b1			;			CALLMONITOR 
20b1			;		endif 
20b1			;	ldir 
20b1			; 
20b1			; 
20b1			;	ld hl, execscratch 
20b1			; 
20b1			;		if DEBUG_FORTH_WORDS 
20b1			;			DMARK "EXe" 
20b1			;			CALLMONITOR 
20b1			;		endif 
20b1			; 
20b1			;	call forthparse 
20b1			;	call forthexec 
20b1			;;	call forthexec_cleanup 
20b1			;;	call forthparse 
20b1			;;	call forthexec 
20b1			; 
20b1			;	STACKFRAMECHK OFF $5efe $5f9f 
20b1			; 
20b1			;	; an immediate word so no need to process any more words 
20b1			;	ret 
20b1			;	NEXTW 
20b1			 
20b1			; dead code - old version  
20b1			;	FORTH_RSP_NEXT 
20b1			 
20b1			;  
20b1			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
20b1			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
20b1			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
20b1			;	push hl 
20b1			;	push de 
20b1			;	push bc 
20b1			; 
20b1			; 
20b1			;		if DEBUG_FORTH_WORDS_KEY 
20b1			;			DMARK "EXR" 
20b1			;			CALLMONITOR 
20b1			;		endif 
20b1			; 
20b1			; 
20b1			; 
20b1			;	;v5 FORTH_DSP_VALUE 
20b1			;	FORTH_DSP_VALUEHL 
20b1			; 
20b1			;	; TODO do string type checks 
20b1			; 
20b1			;;v5	inc hl   ; skip type 
20b1			; 
20b1			;	push hl  ; source code  
20b1			;		if DEBUG_FORTH_WORDS 
20b1			;			DMARK "EX1" 
20b1			;			CALLMONITOR 
20b1			;		endif 
20b1			;	ld a, 0 
20b1			;	call strlent 
20b1			; 
20b1			;	inc hl 
20b1			;	inc hl 
20b1			;	inc hl 
20b1			;	inc hl 
20b1			; 
20b1			;	push hl    ; size 
20b1			; 
20b1			;		if DEBUG_FORTH_WORDS 
20b1			;			DMARK "EX2" 
20b1			;			CALLMONITOR 
20b1			;		endif 
20b1			;	call malloc 
20b1			; 
20b1			;	ex de, hl    ; de now contains malloc area 
20b1			;	pop bc   	; get byte count 
20b1			;	pop hl      ; get string to copy 
20b1			; 
20b1			;	push de     ; save malloc for free later 
20b1			; 
20b1			;		if DEBUG_FORTH_WORDS 
20b1			;			DMARK "EX3" 
20b1			;			CALLMONITOR 
20b1			;		endif 
20b1			;	ldir       ; duplicate string 
20b1			; 
20b1			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
20b1			;	 
20b1			;	; TODO fix the parse would be better than this...  
20b1			;	ex de, hl 
20b1			;	dec hl 
20b1			;	ld a, 0 
20b1			;	ld (hl), a 
20b1			;	dec hl 
20b1			;	ld a, ' ' 
20b1			;	ld (hl), a 
20b1			;	dec hl 
20b1			;	ld (hl), a 
20b1			; 
20b1			;	dec hl 
20b1			;	ld (hl), a 
20b1			; 
20b1			; 
20b1			;	FORTH_DSP_POP  
20b1			; 
20b1			;	pop hl     
20b1			;	push hl    ; save malloc area 
20b1			; 
20b1			;		if DEBUG_FORTH_WORDS 
20b1			;			DMARK "EX4" 
20b1			;			CALLMONITOR 
20b1			;		endif 
20b1			; 
20b1			;	call forthparse 
20b1			;	call forthexec 
20b1			;	 
20b1			;	pop hl 
20b1			;	if DEBUG_FORTH_WORDS 
20b1			;		DMARK "EX5" 
20b1			;		CALLMONITOR 
20b1			;	endif 
20b1			; 
20b1			;	if FORTH_ENABLE_FREE 
20b1			;	call free 
20b1			;	endif 
20b1			; 
20b1			;	if DEBUG_FORTH_WORDS 
20b1			;		DMARK "EX6" 
20b1			;		CALLMONITOR 
20b1			;	endif 
20b1			; 
20b1			;	pop bc 
20b1			;	pop de 
20b1			;	pop hl 
20b1			;;	FORTH_RSP_POP	  
20b1			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
20b1			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
20b1			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
20b1			; 
20b1			;	if DEBUG_FORTH_WORDS 
20b1			;		DMARK "EX7" 
20b1			;		CALLMONITOR 
20b1			;	endif 
20b1			;	NEXTW 
20b1			 
20b1			;.STKEXEC: 
20b1			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
20b1			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
20b1			; 
20b1			; 
20b1			;		if DEBUG_FORTH_WORDS_KEY 
20b1			;			DMARK "STX" 
20b1			;			CALLMONITOR 
20b1			;		endif 
20b1			; 
20b1			;	FORTH_DSP_VALUEHL 
20b1			; 
20b1			;	ld (store_tmp1), hl    ; count 
20b1			; 
20b1			;	FORTH_DSP_POP 
20b1			;.stkexec1: 
20b1			;	ld hl, (store_tmp1)   ; count 
20b1			;	ld a, 0 
20b1			;	cp l 
20b1			;	ret z 
20b1			; 
20b1			;	dec hl 
20b1			;	ld (store_tmp1), hl    ; count 
20b1			;	 
20b1			;	FORTH_DSP_VALUEHL 
20b1			;	push hl 
20b1			;	 
20b1			;		if DEBUG_FORTH_WORDS 
20b1			;			DMARK "EXp" 
20b1			;			CALLMONITOR 
20b1			;		endif 
20b1			;	FORTH_DSP_POP 
20b1			; 
20b1			;	call strlenz 
20b1			;	inc hl   ; include zero term to copy 
20b1			;	inc hl   ; include zero term to copy 
20b1			;	inc hl   ; include zero term to copy 
20b1			;	ld b,0 
20b1			;	ld c,l 
20b1			;	pop hl 
20b1			;	ld de, execscratch 
20b1			;		if DEBUG_FORTH_WORDS 
20b1			;			DMARK "EX3" 
20b1			;			CALLMONITOR 
20b1			;		endif 
20b1			;	ldir 
20b1			; 
20b1			; 
20b1			;	ld hl, execscratch 
20b1			; 
20b1			;		if DEBUG_FORTH_WORDS 
20b1			;			DMARK "EXP" 
20b1			;			CALLMONITOR 
20b1			;		endif 
20b1			; 
20b1			;	call forthparse 
20b1			;	ld hl, execscratch 
20b1			;		if DEBUG_FORTH_WORDS 
20b1			;			DMARK "EXx" 
20b1			;			CALLMONITOR 
20b1			;		endif 
20b1			;	call forthexec 
20b1			; 
20b1			;	jp .stkexec1 
20b1			; 
20b1			;	ret 
20b1			 
20b1			 
20b1			.DUP: 
20b1			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
20b1 17				db WORD_SYS_CORE+OPCODE_DUP             
20b2 27 21			dw .ZDUP            
20b4 04				db 3 + 1 
20b5 .. 00			db "DUP",0              
20b9				endm 
# End of macro CWHEAD
20b9			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
20b9			 
20b9				if DEBUG_FORTH_WORDS_KEY 
20b9					DMARK "DUP" 
20b9 f5				push af  
20ba 3a ce 20			ld a, (.dmark)  
20bd 32 6b ee			ld (debug_mark),a  
20c0 3a cf 20			ld a, (.dmark+1)  
20c3 32 6c ee			ld (debug_mark+1),a  
20c6 3a d0 20			ld a, (.dmark+2)  
20c9 32 6d ee			ld (debug_mark+2),a  
20cc 18 03			jr .pastdmark  
20ce ..			.dmark: db "DUP"  
20d1 f1			.pastdmark: pop af  
20d2			endm  
# End of macro DMARK
20d2					CALLMONITOR 
20d2 cd 6f ee			call debug_vector  
20d5				endm  
# End of macro CALLMONITOR
20d5				endif 
20d5			 
20d5				FORTH_DSP 
20d5 cd 2a 1d			call macro_forth_dsp 
20d8				endm 
# End of macro FORTH_DSP
20d8			 
20d8 7e				ld a, (HL) 
20d9 fe 01			cp DS_TYPE_STR 
20db 20 25			jr nz, .dupinum 
20dd			 
20dd				; push another string 
20dd			 
20dd				FORTH_DSP_VALUEHL     		 
20dd cd 64 1d			call macro_dsp_valuehl 
20e0				endm 
# End of macro FORTH_DSP_VALUEHL
20e0			 
20e0			if DEBUG_FORTH_WORDS 
20e0				DMARK "DUs" 
20e0 f5				push af  
20e1 3a f5 20			ld a, (.dmark)  
20e4 32 6b ee			ld (debug_mark),a  
20e7 3a f6 20			ld a, (.dmark+1)  
20ea 32 6c ee			ld (debug_mark+1),a  
20ed 3a f7 20			ld a, (.dmark+2)  
20f0 32 6d ee			ld (debug_mark+2),a  
20f3 18 03			jr .pastdmark  
20f5 ..			.dmark: db "DUs"  
20f8 f1			.pastdmark: pop af  
20f9			endm  
# End of macro DMARK
20f9				CALLMONITOR 
20f9 cd 6f ee			call debug_vector  
20fc				endm  
# End of macro CALLMONITOR
20fc			endif 
20fc cd db 1b			call forth_push_str 
20ff			 
20ff				NEXTW 
20ff c3 1a 1f			jp macro_next 
2102				endm 
# End of macro NEXTW
2102			 
2102			 
2102			.dupinum: 
2102				 
2102			 
2102			 
2102				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2102 cd 64 1d			call macro_dsp_valuehl 
2105				endm 
# End of macro FORTH_DSP_VALUEHL
2105			 
2105			; TODO add floating point number detection 
2105			 
2105			if DEBUG_FORTH_WORDS 
2105				DMARK "DUi" 
2105 f5				push af  
2106 3a 1a 21			ld a, (.dmark)  
2109 32 6b ee			ld (debug_mark),a  
210c 3a 1b 21			ld a, (.dmark+1)  
210f 32 6c ee			ld (debug_mark+1),a  
2112 3a 1c 21			ld a, (.dmark+2)  
2115 32 6d ee			ld (debug_mark+2),a  
2118 18 03			jr .pastdmark  
211a ..			.dmark: db "DUi"  
211d f1			.pastdmark: pop af  
211e			endm  
# End of macro DMARK
211e				CALLMONITOR 
211e cd 6f ee			call debug_vector  
2121				endm  
# End of macro CALLMONITOR
2121			endif 
2121			 
2121 cd 6d 1b			call forth_push_numhl 
2124				NEXTW 
2124 c3 1a 1f			jp macro_next 
2127				endm 
# End of macro NEXTW
2127			.ZDUP: 
2127			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2127 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2128 5f 21			dw .SWAP            
212a 05				db 4 + 1 
212b .. 00			db "?DUP",0              
2130				endm 
# End of macro CWHEAD
2130			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2130			 
2130				if DEBUG_FORTH_WORDS_KEY 
2130					DMARK "qDU" 
2130 f5				push af  
2131 3a 45 21			ld a, (.dmark)  
2134 32 6b ee			ld (debug_mark),a  
2137 3a 46 21			ld a, (.dmark+1)  
213a 32 6c ee			ld (debug_mark+1),a  
213d 3a 47 21			ld a, (.dmark+2)  
2140 32 6d ee			ld (debug_mark+2),a  
2143 18 03			jr .pastdmark  
2145 ..			.dmark: db "qDU"  
2148 f1			.pastdmark: pop af  
2149			endm  
# End of macro DMARK
2149					CALLMONITOR 
2149 cd 6f ee			call debug_vector  
214c				endm  
# End of macro CALLMONITOR
214c				endif 
214c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
214c cd 64 1d			call macro_dsp_valuehl 
214f				endm 
# End of macro FORTH_DSP_VALUEHL
214f			 
214f e5				push hl 
2150			 
2150				; is it a zero? 
2150			 
2150 3e 00			ld a, 0 
2152 84				add h 
2153 85				add l 
2154			 
2154 e1				pop hl 
2155			 
2155 fe 00			cp 0 
2157 28 03			jr z, .dup2orig 
2159			 
2159			 
2159 cd 6d 1b			call forth_push_numhl 
215c			 
215c			 
215c			; TODO add floating point number detection 
215c			 
215c			.dup2orig: 
215c			 
215c				NEXTW 
215c c3 1a 1f			jp macro_next 
215f				endm 
# End of macro NEXTW
215f			.SWAP: 
215f			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
215f 18				db WORD_SYS_CORE+OPCODE_SWAP             
2160 9e 21			dw .COLN            
2162 05				db 4 + 1 
2163 .. 00			db "SWAP",0              
2168				endm 
# End of macro CWHEAD
2168			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2168				if DEBUG_FORTH_WORDS_KEY 
2168					DMARK "SWP" 
2168 f5				push af  
2169 3a 7d 21			ld a, (.dmark)  
216c 32 6b ee			ld (debug_mark),a  
216f 3a 7e 21			ld a, (.dmark+1)  
2172 32 6c ee			ld (debug_mark+1),a  
2175 3a 7f 21			ld a, (.dmark+2)  
2178 32 6d ee			ld (debug_mark+2),a  
217b 18 03			jr .pastdmark  
217d ..			.dmark: db "SWP"  
2180 f1			.pastdmark: pop af  
2181			endm  
# End of macro DMARK
2181					CALLMONITOR 
2181 cd 6f ee			call debug_vector  
2184				endm  
# End of macro CALLMONITOR
2184				endif 
2184			 
2184			; TODO Use os stack swap memory 
2184				FORTH_DSP_VALUEHL 
2184 cd 64 1d			call macro_dsp_valuehl 
2187				endm 
# End of macro FORTH_DSP_VALUEHL
2187 e5				push hl     ; w2 
2188			 
2188				FORTH_DSP_POP 
2188 cd 1c 1e			call macro_forth_dsp_pop 
218b				endm 
# End of macro FORTH_DSP_POP
218b			 
218b				FORTH_DSP_VALUEHL 
218b cd 64 1d			call macro_dsp_valuehl 
218e				endm 
# End of macro FORTH_DSP_VALUEHL
218e			 
218e				FORTH_DSP_POP 
218e cd 1c 1e			call macro_forth_dsp_pop 
2191				endm 
# End of macro FORTH_DSP_POP
2191			 
2191 d1				pop de     ; w2	, hl = w1 
2192			 
2192 eb				ex de, hl 
2193 d5				push de 
2194			 
2194 cd 6d 1b			call forth_push_numhl 
2197			 
2197 e1				pop hl 
2198			 
2198 cd 6d 1b			call forth_push_numhl 
219b				 
219b			 
219b				NEXTW 
219b c3 1a 1f			jp macro_next 
219e				endm 
# End of macro NEXTW
219e			.COLN: 
219e			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
219e 19				db WORD_SYS_CORE+OPCODE_COLN             
219f 2a 23			dw .SCOLN            
21a1 02				db 1 + 1 
21a2 .. 00			db ":",0              
21a4				endm 
# End of macro CWHEAD
21a4			; | : ( -- )         Create new word | DONE 
21a4			 
21a4				if DEBUG_FORTH_WORDS_KEY 
21a4					DMARK "CLN" 
21a4 f5				push af  
21a5 3a b9 21			ld a, (.dmark)  
21a8 32 6b ee			ld (debug_mark),a  
21ab 3a ba 21			ld a, (.dmark+1)  
21ae 32 6c ee			ld (debug_mark+1),a  
21b1 3a bb 21			ld a, (.dmark+2)  
21b4 32 6d ee			ld (debug_mark+2),a  
21b7 18 03			jr .pastdmark  
21b9 ..			.dmark: db "CLN"  
21bc f1			.pastdmark: pop af  
21bd			endm  
# End of macro DMARK
21bd					CALLMONITOR 
21bd cd 6f ee			call debug_vector  
21c0				endm  
# End of macro CALLMONITOR
21c0				endif 
21c0			STACKFRAME OFF $8efe $989f 
21c0				if DEBUG_STACK_IMB 
21c0					if OFF 
21c0						exx 
21c0						ld de, $8efe 
21c0						ld a, d 
21c0						ld hl, curframe 
21c0						call hexout 
21c0						ld a, e 
21c0						ld hl, curframe+2 
21c0						call hexout 
21c0						ld hl, $8efe 
21c0						push hl 
21c0						ld hl, $989f 
21c0						push hl 
21c0						exx 
21c0					endif 
21c0				endif 
21c0			endm 
# End of macro STACKFRAME
21c0			; get parser buffer length  of new word 
21c0			 
21c0			 
21c0			 
21c0				; move tok past this to start of name defintition 
21c0				; TODO get word to define 
21c0				; TODO Move past word token 
21c0				; TODO get length of string up to the ';' 
21c0			 
21c0 2a c2 e5		ld hl, (os_tok_ptr) 
21c3 23			inc hl 
21c4 23			inc hl 
21c5			 
21c5 3e 3b		ld a, ';' 
21c7 cd 57 11		call strlent 
21ca			 
21ca 7d			ld a,l 
21cb 32 b1 e2		ld (os_new_parse_len), a 
21ce			 
21ce			 
21ce			if DEBUG_FORTH_UWORD 
21ce ed 5b c2 e5	ld de, (os_tok_ptr) 
21d2					DMARK ":01" 
21d2 f5				push af  
21d3 3a e7 21			ld a, (.dmark)  
21d6 32 6b ee			ld (debug_mark),a  
21d9 3a e8 21			ld a, (.dmark+1)  
21dc 32 6c ee			ld (debug_mark+1),a  
21df 3a e9 21			ld a, (.dmark+2)  
21e2 32 6d ee			ld (debug_mark+2),a  
21e5 18 03			jr .pastdmark  
21e7 ..			.dmark: db ":01"  
21ea f1			.pastdmark: pop af  
21eb			endm  
# End of macro DMARK
21eb			CALLMONITOR 
21eb cd 6f ee			call debug_vector  
21ee				endm  
# End of macro CALLMONITOR
21ee			endif 
21ee			 
21ee			; 
21ee			;  new word memory layout: 
21ee			;  
21ee			;    : adg 6666 ;  
21ee			; 
21ee			;    db   1     ; user defined word  
21ee 23			inc hl    
21ef			;    dw   sysdict 
21ef 23			inc hl 
21f0 23			inc hl 
21f1			;    db <word len>+1 (for null) 
21f1 23			inc hl 
21f2			;    db .... <word> 
21f2			; 
21f2			 
21f2 23			inc hl    ; some extras for the word preamble before the above 
21f3 23			inc hl 
21f4 23			inc hl 
21f5 23			inc hl 
21f6 23			inc hl 
21f7 23			inc hl 
21f8 23			inc hl  
21f9 23			inc hl 
21fa 23			inc hl 
21fb 23			inc hl 
21fc 23			inc hl 
21fd 23			inc hl 
21fe 23			inc hl 
21ff 23			inc hl     ; TODO how many do we really need?     maybe only 6 
2200			;       exec word buffer 
2200			;	<ptr word>   
2200 23			inc hl 
2201 23			inc hl 
2202			;       <word list><null term> 7F final term 
2202			 
2202			 
2202			if DEBUG_FORTH_UWORD 
2202					DMARK ":02" 
2202 f5				push af  
2203 3a 17 22			ld a, (.dmark)  
2206 32 6b ee			ld (debug_mark),a  
2209 3a 18 22			ld a, (.dmark+1)  
220c 32 6c ee			ld (debug_mark+1),a  
220f 3a 19 22			ld a, (.dmark+2)  
2212 32 6d ee			ld (debug_mark+2),a  
2215 18 03			jr .pastdmark  
2217 ..			.dmark: db ":02"  
221a f1			.pastdmark: pop af  
221b			endm  
# End of macro DMARK
221b			CALLMONITOR 
221b cd 6f ee			call debug_vector  
221e				endm  
# End of macro CALLMONITOR
221e			endif 
221e			 
221e			 
221e				; malloc the size 
221e			 
221e cd c1 11			call malloc 
2221 22 b3 e2			ld (os_new_malloc), hl     ; save malloc start 
2224			 
2224			;    db   1     ; user defined word  
2224 3e 01			ld a, WORD_SYS_UWORD  
2226 77				ld (hl), a 
2227			 
2227 23			inc hl    
2228			;    dw   sysdict 
2228 11 72 20		ld de, sysdict       ; continue on with the scan to the system dict 
222b 73			ld (hl), e 
222c 23			inc hl 
222d 72			ld (hl), d 
222e 23			inc hl 
222f			 
222f			 
222f			;    Setup dict word 
222f			 
222f 23			inc hl 
2230 22 ad e2		ld (os_new_work_ptr), hl     ; save start of dict word  
2233			 
2233			; 1. get length of dict word 
2233			 
2233			 
2233 2a c2 e5		ld hl, (os_tok_ptr) 
2236 23			inc hl 
2237 23			inc hl    ; position to start of dict word 
2238 3e 00		ld a, 0 
223a cd 57 11		call strlent 
223d			 
223d			 
223d 23			inc hl    ; to include null??? 
223e			 
223e			; write length of dict word 
223e			 
223e ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2242 1b			dec de 
2243 eb			ex de, hl 
2244 73			ld (hl), e 
2245 eb			ex de, hl 
2246			 
2246			 
2246			 
2246			; copy  
2246 4d			ld c, l 
2247 06 00		ld b, 0 
2249 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
224d 2a c2 e5		ld hl, (os_tok_ptr) 
2250 23			inc hl 
2251 23			inc hl    ; position to start of dict word 
2252			 
2252			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2252			 
2252			; TODO need to convert word to upper case 
2252			 
2252			ucasetok:	 
2252 7e			ld a,(hl) 
2253 cd 43 11		call toUpper 
2256 77			ld (hl),a 
2257 ed a0		ldi 
2259 f2 52 22		jp p, ucasetok 
225c			 
225c			 
225c			 
225c			; de now points to start of where the word body code should be placed 
225c ed 53 ad e2	ld (os_new_work_ptr), de 
2260			; hl now points to the words to throw at forthexec which needs to be copied 
2260 22 ab e2		ld (os_new_src_ptr), hl 
2263			 
2263			; TODO add 'call to forthexec' 
2263			 
2263			if DEBUG_FORTH_UWORD 
2263 c5			push bc 
2264 ed 4b b3 e2	ld bc, (os_new_malloc) 
2268					DMARK ":0x" 
2268 f5				push af  
2269 3a 7d 22			ld a, (.dmark)  
226c 32 6b ee			ld (debug_mark),a  
226f 3a 7e 22			ld a, (.dmark+1)  
2272 32 6c ee			ld (debug_mark+1),a  
2275 3a 7f 22			ld a, (.dmark+2)  
2278 32 6d ee			ld (debug_mark+2),a  
227b 18 03			jr .pastdmark  
227d ..			.dmark: db ":0x"  
2280 f1			.pastdmark: pop af  
2281			endm  
# End of macro DMARK
2281			CALLMONITOR 
2281 cd 6f ee			call debug_vector  
2284				endm  
# End of macro CALLMONITOR
2284 c1			pop bc 
2285			endif 
2285			 
2285			 
2285			; create word preamble which should be: 
2285			 
2285			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2285			 
2285			;    ld hl, <word code> 
2285			;    jp user_exec 
2285			;    <word code bytes> 
2285			 
2285			 
2285			;	inc de     ; TODO ??? or are we already past the word's null 
2285 eb			ex de, hl 
2286			 
2286 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2288			 
2288 23			inc hl 
2289 22 a7 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
228c 23			inc hl 
228d			 
228d 23			inc hl 
228e 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2290			 
2290 01 08 4c		ld bc, user_exec 
2293 23			inc hl 
2294 71			ld (hl), c     ; poke address of user_exec 
2295 23			inc hl 
2296 70			ld (hl), b     
2297			; 
2297			;	inc hl 
2297			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2297			; 
2297			; 
2297			;	ld bc, macro_forth_rsp_next 
2297			;	inc hl 
2297			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2297			;	inc hl 
2297			;	ld (hl), b     
2297			; 
2297			;	inc hl 
2297			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2297			; 
2297			; 
2297			;	inc hl 
2297			;	ld bc, forthexec 
2297			;	ld (hl), c     ; poke address of forthexec 
2297			;	inc hl 
2297			;	ld (hl), b      
2297			; 
2297			;	inc hl 
2297			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2297			; 
2297			;	ld bc, user_dict_next 
2297			;	inc hl 
2297			;	ld (hl), c     ; poke address of forthexec 
2297			;	inc hl 
2297			;	ld (hl), b      
2297			 
2297			; hl is now where we need to copy the word byte data to save this 
2297			 
2297 23			inc hl 
2298 22 a9 e2		ld (os_new_exec), hl 
229b			 
229b			; copy definition 
229b			 
229b eb			ex de, hl 
229c			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
229c			;	inc de    ; skip the PC for this parse 
229c 3a b1 e2		ld a, (os_new_parse_len) 
229f 4f			ld c, a 
22a0 06 00		ld b, 0 
22a2 ed b0		ldir		 ; copy defintion 
22a4			 
22a4			 
22a4			; poke the address of where the new word bytes live for forthexec 
22a4			 
22a4 2a a7 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
22a7			 
22a7 ed 5b a9 e2	ld de, (os_new_exec)      
22ab			 
22ab 73			ld (hl), e 
22ac 23			inc hl 
22ad 72			ld (hl), d 
22ae			 
22ae				; TODO copy last user dict word next link to this word 
22ae				; TODO update last user dict word to point to this word 
22ae			; 
22ae			; hl f923 de 812a ; bc 811a 
22ae			 
22ae			if DEBUG_FORTH_UWORD 
22ae c5			push bc 
22af ed 4b b3 e2	ld bc, (os_new_malloc) 
22b3					DMARK ":0A" 
22b3 f5				push af  
22b4 3a c8 22			ld a, (.dmark)  
22b7 32 6b ee			ld (debug_mark),a  
22ba 3a c9 22			ld a, (.dmark+1)  
22bd 32 6c ee			ld (debug_mark+1),a  
22c0 3a ca 22			ld a, (.dmark+2)  
22c3 32 6d ee			ld (debug_mark+2),a  
22c6 18 03			jr .pastdmark  
22c8 ..			.dmark: db ":0A"  
22cb f1			.pastdmark: pop af  
22cc			endm  
# End of macro DMARK
22cc			CALLMONITOR 
22cc cd 6f ee			call debug_vector  
22cf				endm  
# End of macro CALLMONITOR
22cf c1			pop bc 
22d0			endif 
22d0			if DEBUG_FORTH_UWORD 
22d0 c5			push bc 
22d1 ed 4b b3 e2	ld bc, (os_new_malloc) 
22d5 03			inc bc 
22d6 03			inc bc 
22d7 03			inc bc 
22d8 03			inc bc 
22d9 03			inc bc 
22da 03			inc bc 
22db 03			inc bc 
22dc 03			inc bc 
22dd			 
22dd					DMARK ":0B" 
22dd f5				push af  
22de 3a f2 22			ld a, (.dmark)  
22e1 32 6b ee			ld (debug_mark),a  
22e4 3a f3 22			ld a, (.dmark+1)  
22e7 32 6c ee			ld (debug_mark+1),a  
22ea 3a f4 22			ld a, (.dmark+2)  
22ed 32 6d ee			ld (debug_mark+2),a  
22f0 18 03			jr .pastdmark  
22f2 ..			.dmark: db ":0B"  
22f5 f1			.pastdmark: pop af  
22f6			endm  
# End of macro DMARK
22f6			CALLMONITOR 
22f6 cd 6f ee			call debug_vector  
22f9				endm  
# End of macro CALLMONITOR
22f9 c1			pop bc 
22fa			endif 
22fa			 
22fa			; update word dict linked list for new word 
22fa			 
22fa			 
22fa 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
22fd 23			inc hl     ; move to next work linked list ptr 
22fe			 
22fe ed 5b b3 e2	ld de, (os_new_malloc)		 ; new next word 
2302 73			ld (hl), e 
2303 23			inc hl 
2304 72			ld (hl), d 
2305			 
2305			if DEBUG_FORTH_UWORD 
2305 ed 4b be e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2309			endif 
2309			 
2309 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
230d			 
230d			 
230d			if DEBUG_FORTH_UWORD 
230d					DMARK ":0+" 
230d f5				push af  
230e 3a 22 23			ld a, (.dmark)  
2311 32 6b ee			ld (debug_mark),a  
2314 3a 23 23			ld a, (.dmark+1)  
2317 32 6c ee			ld (debug_mark+1),a  
231a 3a 24 23			ld a, (.dmark+2)  
231d 32 6d ee			ld (debug_mark+2),a  
2320 18 03			jr .pastdmark  
2322 ..			.dmark: db ":0+"  
2325 f1			.pastdmark: pop af  
2326			endm  
# End of macro DMARK
2326			CALLMONITOR 
2326 cd 6f ee			call debug_vector  
2329				endm  
# End of macro CALLMONITOR
2329			endif 
2329			 
2329			STACKFRAMECHK OFF $8efe $989f 
2329				if DEBUG_STACK_IMB 
2329					if OFF 
2329						exx 
2329						ld hl, $989f 
2329						pop de   ; $989f 
2329						call cmp16 
2329						jr nz, .spnosame 
2329						ld hl, $8efe 
2329						pop de   ; $8efe 
2329						call cmp16 
2329						jr z, .spfrsame 
2329						.spnosame: call showsperror 
2329						.spfrsame: nop 
2329						exx 
2329					endif 
2329				endif 
2329			endm 
# End of macro STACKFRAMECHK
2329			 
2329 c9			ret    ; dont process any remaining parser tokens as they form new word 
232a			 
232a			 
232a			 
232a			 
232a			;		NEXT 
232a			.SCOLN: 
232a			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
232a 06			db OPCODE_SCOLN 
232b 76 23		dw .DROP 
232d 02			db 2 
232e .. 00		db ";",0           
2330			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2330				if DEBUG_FORTH_WORDS_KEY 
2330					DMARK "SCN" 
2330 f5				push af  
2331 3a 45 23			ld a, (.dmark)  
2334 32 6b ee			ld (debug_mark),a  
2337 3a 46 23			ld a, (.dmark+1)  
233a 32 6c ee			ld (debug_mark+1),a  
233d 3a 47 23			ld a, (.dmark+2)  
2340 32 6d ee			ld (debug_mark+2),a  
2343 18 03			jr .pastdmark  
2345 ..			.dmark: db "SCN"  
2348 f1			.pastdmark: pop af  
2349			endm  
# End of macro DMARK
2349					CALLMONITOR 
2349 cd 6f ee			call debug_vector  
234c				endm  
# End of macro CALLMONITOR
234c				endif 
234c				FORTH_RSP_TOS 
234c cd 2b 1b			call macro_forth_rsp_tos 
234f				endm 
# End of macro FORTH_RSP_TOS
234f e5				push hl 
2350				FORTH_RSP_POP 
2350 cd 35 1b			call macro_forth_rsp_pop 
2353				endm 
# End of macro FORTH_RSP_POP
2353 e1				pop hl 
2354			;		ex de,hl 
2354 22 c2 e5			ld (os_tok_ptr),hl 
2357			 
2357			if DEBUG_FORTH_UWORD 
2357					DMARK "SCL" 
2357 f5				push af  
2358 3a 6c 23			ld a, (.dmark)  
235b 32 6b ee			ld (debug_mark),a  
235e 3a 6d 23			ld a, (.dmark+1)  
2361 32 6c ee			ld (debug_mark+1),a  
2364 3a 6e 23			ld a, (.dmark+2)  
2367 32 6d ee			ld (debug_mark+2),a  
236a 18 03			jr .pastdmark  
236c ..			.dmark: db "SCL"  
236f f1			.pastdmark: pop af  
2370			endm  
# End of macro DMARK
2370			CALLMONITOR 
2370 cd 6f ee			call debug_vector  
2373				endm  
# End of macro CALLMONITOR
2373			endif 
2373				NEXTW 
2373 c3 1a 1f			jp macro_next 
2376				endm 
# End of macro NEXTW
2376			 
2376			.DROP: 
2376			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2376 1b				db WORD_SYS_CORE+OPCODE_DROP             
2377 a1 23			dw .DUP2            
2379 05				db 4 + 1 
237a .. 00			db "DROP",0              
237f				endm 
# End of macro CWHEAD
237f			; | DROP ( w -- )   drop the TOS item   | DONE 
237f				if DEBUG_FORTH_WORDS_KEY 
237f					DMARK "DRP" 
237f f5				push af  
2380 3a 94 23			ld a, (.dmark)  
2383 32 6b ee			ld (debug_mark),a  
2386 3a 95 23			ld a, (.dmark+1)  
2389 32 6c ee			ld (debug_mark+1),a  
238c 3a 96 23			ld a, (.dmark+2)  
238f 32 6d ee			ld (debug_mark+2),a  
2392 18 03			jr .pastdmark  
2394 ..			.dmark: db "DRP"  
2397 f1			.pastdmark: pop af  
2398			endm  
# End of macro DMARK
2398					CALLMONITOR 
2398 cd 6f ee			call debug_vector  
239b				endm  
# End of macro CALLMONITOR
239b				endif 
239b				FORTH_DSP_POP 
239b cd 1c 1e			call macro_forth_dsp_pop 
239e				endm 
# End of macro FORTH_DSP_POP
239e				NEXTW 
239e c3 1a 1f			jp macro_next 
23a1				endm 
# End of macro NEXTW
23a1			.DUP2: 
23a1			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
23a1 1c				db WORD_SYS_CORE+OPCODE_DUP2             
23a2 e6 23			dw .DROP2            
23a4 05				db 4 + 1 
23a5 .. 00			db "2DUP",0              
23aa				endm 
# End of macro CWHEAD
23aa			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
23aa				if DEBUG_FORTH_WORDS_KEY 
23aa					DMARK "2DU" 
23aa f5				push af  
23ab 3a bf 23			ld a, (.dmark)  
23ae 32 6b ee			ld (debug_mark),a  
23b1 3a c0 23			ld a, (.dmark+1)  
23b4 32 6c ee			ld (debug_mark+1),a  
23b7 3a c1 23			ld a, (.dmark+2)  
23ba 32 6d ee			ld (debug_mark+2),a  
23bd 18 03			jr .pastdmark  
23bf ..			.dmark: db "2DU"  
23c2 f1			.pastdmark: pop af  
23c3			endm  
# End of macro DMARK
23c3					CALLMONITOR 
23c3 cd 6f ee			call debug_vector  
23c6				endm  
# End of macro CALLMONITOR
23c6				endif 
23c6				FORTH_DSP_VALUEHL 
23c6 cd 64 1d			call macro_dsp_valuehl 
23c9				endm 
# End of macro FORTH_DSP_VALUEHL
23c9 e5				push hl      ; 2 
23ca			 
23ca				FORTH_DSP_POP 
23ca cd 1c 1e			call macro_forth_dsp_pop 
23cd				endm 
# End of macro FORTH_DSP_POP
23cd				 
23cd				FORTH_DSP_VALUEHL 
23cd cd 64 1d			call macro_dsp_valuehl 
23d0				endm 
# End of macro FORTH_DSP_VALUEHL
23d0			;		push hl      ; 1 
23d0			 
23d0				FORTH_DSP_POP 
23d0 cd 1c 1e			call macro_forth_dsp_pop 
23d3				endm 
# End of macro FORTH_DSP_POP
23d3			 
23d3			;		pop hl       ; 1 
23d3 d1				pop de       ; 2 
23d4			 
23d4 cd 6d 1b			call forth_push_numhl 
23d7 eb				ex de, hl 
23d8 cd 6d 1b			call forth_push_numhl 
23db			 
23db				 
23db eb				ex de, hl 
23dc			 
23dc cd 6d 1b			call forth_push_numhl 
23df eb				ex de, hl 
23e0 cd 6d 1b			call forth_push_numhl 
23e3			 
23e3			 
23e3				NEXTW 
23e3 c3 1a 1f			jp macro_next 
23e6				endm 
# End of macro NEXTW
23e6			.DROP2: 
23e6			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
23e6 1d				db WORD_SYS_CORE+OPCODE_DROP2             
23e7 15 24			dw .SWAP2            
23e9 06				db 5 + 1 
23ea .. 00			db "2DROP",0              
23f0				endm 
# End of macro CWHEAD
23f0			; | 2DROP ( w w -- )    Double drop | DONE 
23f0				if DEBUG_FORTH_WORDS_KEY 
23f0					DMARK "2DR" 
23f0 f5				push af  
23f1 3a 05 24			ld a, (.dmark)  
23f4 32 6b ee			ld (debug_mark),a  
23f7 3a 06 24			ld a, (.dmark+1)  
23fa 32 6c ee			ld (debug_mark+1),a  
23fd 3a 07 24			ld a, (.dmark+2)  
2400 32 6d ee			ld (debug_mark+2),a  
2403 18 03			jr .pastdmark  
2405 ..			.dmark: db "2DR"  
2408 f1			.pastdmark: pop af  
2409			endm  
# End of macro DMARK
2409					CALLMONITOR 
2409 cd 6f ee			call debug_vector  
240c				endm  
# End of macro CALLMONITOR
240c				endif 
240c				FORTH_DSP_POP 
240c cd 1c 1e			call macro_forth_dsp_pop 
240f				endm 
# End of macro FORTH_DSP_POP
240f				FORTH_DSP_POP 
240f cd 1c 1e			call macro_forth_dsp_pop 
2412				endm 
# End of macro FORTH_DSP_POP
2412				NEXTW 
2412 c3 1a 1f			jp macro_next 
2415				endm 
# End of macro NEXTW
2415			.SWAP2: 
2415			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2415 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2416 3e 24			dw .AT            
2418 06				db 5 + 1 
2419 .. 00			db "2SWAP",0              
241f				endm 
# End of macro CWHEAD
241f			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
241f				if DEBUG_FORTH_WORDS_KEY 
241f					DMARK "2SW" 
241f f5				push af  
2420 3a 34 24			ld a, (.dmark)  
2423 32 6b ee			ld (debug_mark),a  
2426 3a 35 24			ld a, (.dmark+1)  
2429 32 6c ee			ld (debug_mark+1),a  
242c 3a 36 24			ld a, (.dmark+2)  
242f 32 6d ee			ld (debug_mark+2),a  
2432 18 03			jr .pastdmark  
2434 ..			.dmark: db "2SW"  
2437 f1			.pastdmark: pop af  
2438			endm  
# End of macro DMARK
2438					CALLMONITOR 
2438 cd 6f ee			call debug_vector  
243b				endm  
# End of macro CALLMONITOR
243b				endif 
243b			; TODO Use os stack swap memory 
243b				NEXTW 
243b c3 1a 1f			jp macro_next 
243e				endm 
# End of macro NEXTW
243e			.AT: 
243e			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
243e 1f				db WORD_SYS_CORE+OPCODE_AT             
243f 70 24			dw .CAT            
2441 02				db 1 + 1 
2442 .. 00			db "@",0              
2444				endm 
# End of macro CWHEAD
2444			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2444			 
2444				if DEBUG_FORTH_WORDS_KEY 
2444					DMARK "AT." 
2444 f5				push af  
2445 3a 59 24			ld a, (.dmark)  
2448 32 6b ee			ld (debug_mark),a  
244b 3a 5a 24			ld a, (.dmark+1)  
244e 32 6c ee			ld (debug_mark+1),a  
2451 3a 5b 24			ld a, (.dmark+2)  
2454 32 6d ee			ld (debug_mark+2),a  
2457 18 03			jr .pastdmark  
2459 ..			.dmark: db "AT."  
245c f1			.pastdmark: pop af  
245d			endm  
# End of macro DMARK
245d					CALLMONITOR 
245d cd 6f ee			call debug_vector  
2460				endm  
# End of macro CALLMONITOR
2460				endif 
2460			.getbyteat:	 
2460				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2460 cd 64 1d			call macro_dsp_valuehl 
2463				endm 
# End of macro FORTH_DSP_VALUEHL
2463				 
2463			;		push hl 
2463			 
2463				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2463 cd 1c 1e			call macro_forth_dsp_pop 
2466				endm 
# End of macro FORTH_DSP_POP
2466			 
2466			;		pop hl 
2466			 
2466 7e				ld a, (hl) 
2467			 
2467 6f				ld l, a 
2468 26 00			ld h, 0 
246a cd 6d 1b			call forth_push_numhl 
246d			 
246d				NEXTW 
246d c3 1a 1f			jp macro_next 
2470				endm 
# End of macro NEXTW
2470			.CAT: 
2470			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2470 20				db WORD_SYS_CORE+OPCODE_CAT             
2471 99 24			dw .BANG            
2473 03				db 2 + 1 
2474 .. 00			db "C@",0              
2477				endm 
# End of macro CWHEAD
2477			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2477				if DEBUG_FORTH_WORDS_KEY 
2477					DMARK "CAA" 
2477 f5				push af  
2478 3a 8c 24			ld a, (.dmark)  
247b 32 6b ee			ld (debug_mark),a  
247e 3a 8d 24			ld a, (.dmark+1)  
2481 32 6c ee			ld (debug_mark+1),a  
2484 3a 8e 24			ld a, (.dmark+2)  
2487 32 6d ee			ld (debug_mark+2),a  
248a 18 03			jr .pastdmark  
248c ..			.dmark: db "CAA"  
248f f1			.pastdmark: pop af  
2490			endm  
# End of macro DMARK
2490					CALLMONITOR 
2490 cd 6f ee			call debug_vector  
2493				endm  
# End of macro CALLMONITOR
2493				endif 
2493 c3 60 24			jp .getbyteat 
2496				NEXTW 
2496 c3 1a 1f			jp macro_next 
2499				endm 
# End of macro NEXTW
2499			.BANG: 
2499			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2499 21				db WORD_SYS_CORE+OPCODE_BANG             
249a cf 24			dw .CBANG            
249c 02				db 1 + 1 
249d .. 00			db "!",0              
249f				endm 
# End of macro CWHEAD
249f			; | ! ( x w -- ) Store x at address w      | DONE 
249f				if DEBUG_FORTH_WORDS_KEY 
249f					DMARK "BNG" 
249f f5				push af  
24a0 3a b4 24			ld a, (.dmark)  
24a3 32 6b ee			ld (debug_mark),a  
24a6 3a b5 24			ld a, (.dmark+1)  
24a9 32 6c ee			ld (debug_mark+1),a  
24ac 3a b6 24			ld a, (.dmark+2)  
24af 32 6d ee			ld (debug_mark+2),a  
24b2 18 03			jr .pastdmark  
24b4 ..			.dmark: db "BNG"  
24b7 f1			.pastdmark: pop af  
24b8			endm  
# End of macro DMARK
24b8					CALLMONITOR 
24b8 cd 6f ee			call debug_vector  
24bb				endm  
# End of macro CALLMONITOR
24bb				endif 
24bb			 
24bb			.storebyteat:		 
24bb				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24bb cd 64 1d			call macro_dsp_valuehl 
24be				endm 
# End of macro FORTH_DSP_VALUEHL
24be				 
24be e5				push hl 
24bf			 
24bf				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24bf cd 1c 1e			call macro_forth_dsp_pop 
24c2				endm 
# End of macro FORTH_DSP_POP
24c2			 
24c2				; get byte to poke 
24c2			 
24c2				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24c2 cd 64 1d			call macro_dsp_valuehl 
24c5				endm 
# End of macro FORTH_DSP_VALUEHL
24c5 e5				push hl 
24c6			 
24c6			 
24c6				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24c6 cd 1c 1e			call macro_forth_dsp_pop 
24c9				endm 
# End of macro FORTH_DSP_POP
24c9			 
24c9			 
24c9 d1				pop de 
24ca e1				pop hl 
24cb			 
24cb 73				ld (hl),e 
24cc			 
24cc			 
24cc				NEXTW 
24cc c3 1a 1f			jp macro_next 
24cf				endm 
# End of macro NEXTW
24cf			.CBANG: 
24cf			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
24cf 22				db WORD_SYS_CORE+OPCODE_CBANG             
24d0 f8 24			dw .SCALL            
24d2 03				db 2 + 1 
24d3 .. 00			db "C!",0              
24d6				endm 
# End of macro CWHEAD
24d6			; | C!  ( x w -- ) Store x at address w  | DONE 
24d6				if DEBUG_FORTH_WORDS_KEY 
24d6					DMARK "CBA" 
24d6 f5				push af  
24d7 3a eb 24			ld a, (.dmark)  
24da 32 6b ee			ld (debug_mark),a  
24dd 3a ec 24			ld a, (.dmark+1)  
24e0 32 6c ee			ld (debug_mark+1),a  
24e3 3a ed 24			ld a, (.dmark+2)  
24e6 32 6d ee			ld (debug_mark+2),a  
24e9 18 03			jr .pastdmark  
24eb ..			.dmark: db "CBA"  
24ee f1			.pastdmark: pop af  
24ef			endm  
# End of macro DMARK
24ef					CALLMONITOR 
24ef cd 6f ee			call debug_vector  
24f2				endm  
# End of macro CALLMONITOR
24f2				endif 
24f2 c3 bb 24			jp .storebyteat 
24f5				NEXTW 
24f5 c3 1a 1f			jp macro_next 
24f8				endm 
# End of macro NEXTW
24f8			.SCALL: 
24f8			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
24f8 23				db WORD_SYS_CORE+OPCODE_SCALL             
24f9 2c 25			dw .DEPTH            
24fb 05				db 4 + 1 
24fc .. 00			db "CALL",0              
2501				endm 
# End of macro CWHEAD
2501			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2501				if DEBUG_FORTH_WORDS_KEY 
2501					DMARK "CLL" 
2501 f5				push af  
2502 3a 16 25			ld a, (.dmark)  
2505 32 6b ee			ld (debug_mark),a  
2508 3a 17 25			ld a, (.dmark+1)  
250b 32 6c ee			ld (debug_mark+1),a  
250e 3a 18 25			ld a, (.dmark+2)  
2511 32 6d ee			ld (debug_mark+2),a  
2514 18 03			jr .pastdmark  
2516 ..			.dmark: db "CLL"  
2519 f1			.pastdmark: pop af  
251a			endm  
# End of macro DMARK
251a					CALLMONITOR 
251a cd 6f ee			call debug_vector  
251d				endm  
# End of macro CALLMONITOR
251d				endif 
251d			 
251d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
251d cd 64 1d			call macro_dsp_valuehl 
2520				endm 
# End of macro FORTH_DSP_VALUEHL
2520			 
2520			;		push hl 
2520			 
2520				; destroy value TOS 
2520			 
2520				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2520 cd 1c 1e			call macro_forth_dsp_pop 
2523				endm 
# End of macro FORTH_DSP_POP
2523			 
2523					 
2523			;		pop hl 
2523			 
2523				; how to do a call with hl???? save SP? 
2523 cd be 1e			call forth_call_hl 
2526			 
2526			 
2526				; TODO push value back onto stack for another op etc 
2526			 
2526 cd 6d 1b			call forth_push_numhl 
2529				NEXTW 
2529 c3 1a 1f			jp macro_next 
252c				endm 
# End of macro NEXTW
252c			.DEPTH: 
252c			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
252c 24				db WORD_SYS_CORE+OPCODE_DEPTH             
252d 69 25			dw .OVER            
252f 06				db 5 + 1 
2530 .. 00			db "DEPTH",0              
2536				endm 
# End of macro CWHEAD
2536			; | DEPTH ( -- u ) Push count of stack | DONE 
2536				; take current TOS and remove from base value div by two to get count 
2536				if DEBUG_FORTH_WORDS_KEY 
2536					DMARK "DEP" 
2536 f5				push af  
2537 3a 4b 25			ld a, (.dmark)  
253a 32 6b ee			ld (debug_mark),a  
253d 3a 4c 25			ld a, (.dmark+1)  
2540 32 6c ee			ld (debug_mark+1),a  
2543 3a 4d 25			ld a, (.dmark+2)  
2546 32 6d ee			ld (debug_mark+2),a  
2549 18 03			jr .pastdmark  
254b ..			.dmark: db "DEP"  
254e f1			.pastdmark: pop af  
254f			endm  
# End of macro DMARK
254f					CALLMONITOR 
254f cd 6f ee			call debug_vector  
2552				endm  
# End of macro CALLMONITOR
2552				endif 
2552			 
2552			 
2552 2a ee e9		ld hl, (cli_data_sp) 
2555 11 28 e8		ld de, cli_data_stack 
2558 ed 52		sbc hl,de 
255a			 
255a			; div by size of stack item 
255a			 
255a 5d			ld e,l 
255b 0e 03		ld c, 3 
255d cd 76 0d		call Div8 
2560			 
2560 6f			ld l,a 
2561 26 00		ld h,0 
2563			 
2563			;srl h 
2563			;rr l 
2563			 
2563 cd 6d 1b			call forth_push_numhl 
2566				NEXTW 
2566 c3 1a 1f			jp macro_next 
2569				endm 
# End of macro NEXTW
2569			.OVER: 
2569			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2569 42				db WORD_SYS_CORE+46             
256a b0 25			dw .PAUSE            
256c 05				db 4 + 1 
256d .. 00			db "OVER",0              
2572				endm 
# End of macro CWHEAD
2572			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2572				if DEBUG_FORTH_WORDS_KEY 
2572					DMARK "OVR" 
2572 f5				push af  
2573 3a 87 25			ld a, (.dmark)  
2576 32 6b ee			ld (debug_mark),a  
2579 3a 88 25			ld a, (.dmark+1)  
257c 32 6c ee			ld (debug_mark+1),a  
257f 3a 89 25			ld a, (.dmark+2)  
2582 32 6d ee			ld (debug_mark+2),a  
2585 18 03			jr .pastdmark  
2587 ..			.dmark: db "OVR"  
258a f1			.pastdmark: pop af  
258b			endm  
# End of macro DMARK
258b					CALLMONITOR 
258b cd 6f ee			call debug_vector  
258e				endm  
# End of macro CALLMONITOR
258e				endif 
258e			 
258e			; TODO Use os stack swap memory 
258e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
258e cd 64 1d			call macro_dsp_valuehl 
2591				endm 
# End of macro FORTH_DSP_VALUEHL
2591 e5				push hl    ; n2 
2592				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2592 cd 1c 1e			call macro_forth_dsp_pop 
2595				endm 
# End of macro FORTH_DSP_POP
2595			 
2595				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2595 cd 64 1d			call macro_dsp_valuehl 
2598				endm 
# End of macro FORTH_DSP_VALUEHL
2598 e5				push hl    ; n1 
2599				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2599 cd 1c 1e			call macro_forth_dsp_pop 
259c				endm 
# End of macro FORTH_DSP_POP
259c			 
259c d1				pop de     ; n1 
259d e1				pop hl     ; n2 
259e			 
259e d5				push de 
259f e5				push hl 
25a0 d5				push de 
25a1			 
25a1				; push back  
25a1			 
25a1 e1				pop hl 
25a2 cd 6d 1b			call forth_push_numhl 
25a5 e1				pop hl 
25a6 cd 6d 1b			call forth_push_numhl 
25a9 e1				pop hl 
25aa cd 6d 1b			call forth_push_numhl 
25ad				NEXTW 
25ad c3 1a 1f			jp macro_next 
25b0				endm 
# End of macro NEXTW
25b0			 
25b0			.PAUSE: 
25b0			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
25b0 43				db WORD_SYS_CORE+47             
25b1 e5 25			dw .PAUSES            
25b3 08				db 7 + 1 
25b4 .. 00			db "PAUSEMS",0              
25bc				endm 
# End of macro CWHEAD
25bc			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
25bc				if DEBUG_FORTH_WORDS_KEY 
25bc					DMARK "PMS" 
25bc f5				push af  
25bd 3a d1 25			ld a, (.dmark)  
25c0 32 6b ee			ld (debug_mark),a  
25c3 3a d2 25			ld a, (.dmark+1)  
25c6 32 6c ee			ld (debug_mark+1),a  
25c9 3a d3 25			ld a, (.dmark+2)  
25cc 32 6d ee			ld (debug_mark+2),a  
25cf 18 03			jr .pastdmark  
25d1 ..			.dmark: db "PMS"  
25d4 f1			.pastdmark: pop af  
25d5			endm  
# End of macro DMARK
25d5					CALLMONITOR 
25d5 cd 6f ee			call debug_vector  
25d8				endm  
# End of macro CALLMONITOR
25d8				endif 
25d8				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25d8 cd 64 1d			call macro_dsp_valuehl 
25db				endm 
# End of macro FORTH_DSP_VALUEHL
25db			;		push hl    ; n2 
25db				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25db cd 1c 1e			call macro_forth_dsp_pop 
25de				endm 
# End of macro FORTH_DSP_POP
25de			;		pop hl 
25de			 
25de 7d				ld a, l 
25df cd d6 0a			call aDelayInMS 
25e2			       NEXTW 
25e2 c3 1a 1f			jp macro_next 
25e5				endm 
# End of macro NEXTW
25e5			.PAUSES:  
25e5			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
25e5 44				db WORD_SYS_CORE+48             
25e6 54 26			dw .ROT            
25e8 06				db 5 + 1 
25e9 .. 00			db "PAUSE",0              
25ef				endm 
# End of macro CWHEAD
25ef			; | PAUSE ( n -- )  Pause for n seconds | DONE 
25ef				if DEBUG_FORTH_WORDS_KEY 
25ef					DMARK "PAU" 
25ef f5				push af  
25f0 3a 04 26			ld a, (.dmark)  
25f3 32 6b ee			ld (debug_mark),a  
25f6 3a 05 26			ld a, (.dmark+1)  
25f9 32 6c ee			ld (debug_mark+1),a  
25fc 3a 06 26			ld a, (.dmark+2)  
25ff 32 6d ee			ld (debug_mark+2),a  
2602 18 03			jr .pastdmark  
2604 ..			.dmark: db "PAU"  
2607 f1			.pastdmark: pop af  
2608			endm  
# End of macro DMARK
2608					CALLMONITOR 
2608 cd 6f ee			call debug_vector  
260b				endm  
# End of macro CALLMONITOR
260b				endif 
260b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
260b cd 64 1d			call macro_dsp_valuehl 
260e				endm 
# End of macro FORTH_DSP_VALUEHL
260e			;		push hl    ; n2 
260e				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
260e cd 1c 1e			call macro_forth_dsp_pop 
2611				endm 
# End of macro FORTH_DSP_POP
2611			;		pop hl 
2611 45				ld b, l 
2612				if DEBUG_FORTH_WORDS 
2612					DMARK "PAU" 
2612 f5				push af  
2613 3a 27 26			ld a, (.dmark)  
2616 32 6b ee			ld (debug_mark),a  
2619 3a 28 26			ld a, (.dmark+1)  
261c 32 6c ee			ld (debug_mark+1),a  
261f 3a 29 26			ld a, (.dmark+2)  
2622 32 6d ee			ld (debug_mark+2),a  
2625 18 03			jr .pastdmark  
2627 ..			.dmark: db "PAU"  
262a f1			.pastdmark: pop af  
262b			endm  
# End of macro DMARK
262b					CALLMONITOR 
262b cd 6f ee			call debug_vector  
262e				endm  
# End of macro CALLMONITOR
262e				endif 
262e c5			.pauses1:	push bc 
262f cd f1 0a			call delay1s 
2632 c1				pop bc 
2633				if DEBUG_FORTH_WORDS 
2633					DMARK "PA1" 
2633 f5				push af  
2634 3a 48 26			ld a, (.dmark)  
2637 32 6b ee			ld (debug_mark),a  
263a 3a 49 26			ld a, (.dmark+1)  
263d 32 6c ee			ld (debug_mark+1),a  
2640 3a 4a 26			ld a, (.dmark+2)  
2643 32 6d ee			ld (debug_mark+2),a  
2646 18 03			jr .pastdmark  
2648 ..			.dmark: db "PA1"  
264b f1			.pastdmark: pop af  
264c			endm  
# End of macro DMARK
264c					CALLMONITOR 
264c cd 6f ee			call debug_vector  
264f				endm  
# End of macro CALLMONITOR
264f				endif 
264f 10 dd			djnz .pauses1 
2651			 
2651			       NEXTW 
2651 c3 1a 1f			jp macro_next 
2654				endm 
# End of macro NEXTW
2654			.ROT: 
2654			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2654 45				db WORD_SYS_CORE+49             
2655 a2 26			dw .UWORDS            
2657 04				db 3 + 1 
2658 .. 00			db "ROT",0              
265c				endm 
# End of macro CWHEAD
265c			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
265c				if DEBUG_FORTH_WORDS_KEY 
265c					DMARK "ROT" 
265c f5				push af  
265d 3a 71 26			ld a, (.dmark)  
2660 32 6b ee			ld (debug_mark),a  
2663 3a 72 26			ld a, (.dmark+1)  
2666 32 6c ee			ld (debug_mark+1),a  
2669 3a 73 26			ld a, (.dmark+2)  
266c 32 6d ee			ld (debug_mark+2),a  
266f 18 03			jr .pastdmark  
2671 ..			.dmark: db "ROT"  
2674 f1			.pastdmark: pop af  
2675			endm  
# End of macro DMARK
2675					CALLMONITOR 
2675 cd 6f ee			call debug_vector  
2678				endm  
# End of macro CALLMONITOR
2678				endif 
2678			 
2678			; TODO Use os stack swap memory 
2678				FORTH_DSP_VALUEHL 
2678 cd 64 1d			call macro_dsp_valuehl 
267b				endm 
# End of macro FORTH_DSP_VALUEHL
267b e5				push hl    ; u3  
267c			 
267c				FORTH_DSP_POP 
267c cd 1c 1e			call macro_forth_dsp_pop 
267f				endm 
# End of macro FORTH_DSP_POP
267f			 
267f				FORTH_DSP_VALUEHL 
267f cd 64 1d			call macro_dsp_valuehl 
2682				endm 
# End of macro FORTH_DSP_VALUEHL
2682 e5				push hl     ; u2 
2683			 
2683				FORTH_DSP_POP 
2683 cd 1c 1e			call macro_forth_dsp_pop 
2686				endm 
# End of macro FORTH_DSP_POP
2686			 
2686				FORTH_DSP_VALUEHL 
2686 cd 64 1d			call macro_dsp_valuehl 
2689				endm 
# End of macro FORTH_DSP_VALUEHL
2689 e5				push hl     ; u1 
268a			 
268a				FORTH_DSP_POP 
268a cd 1c 1e			call macro_forth_dsp_pop 
268d				endm 
# End of macro FORTH_DSP_POP
268d			 
268d c1				pop bc      ; u1 
268e e1				pop hl      ; u2 
268f d1				pop de      ; u3 
2690			 
2690			 
2690 c5				push bc 
2691 d5				push de 
2692 e5				push hl 
2693			 
2693			 
2693 e1				pop hl 
2694 cd 6d 1b			call forth_push_numhl 
2697			 
2697 e1				pop hl 
2698 cd 6d 1b			call forth_push_numhl 
269b			 
269b e1				pop hl 
269c cd 6d 1b			call forth_push_numhl 
269f				 
269f			 
269f			 
269f			 
269f			 
269f			 
269f			       NEXTW 
269f c3 1a 1f			jp macro_next 
26a2				endm 
# End of macro NEXTW
26a2			 
26a2			.UWORDS: 
26a2			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
26a2 50				db WORD_SYS_CORE+60             
26a3 64 27			dw .BP            
26a5 07				db 6 + 1 
26a6 .. 00			db "UWORDS",0              
26ad				endm 
# End of macro CWHEAD
26ad			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
26ad			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
26ad			; | | Following the count are the individual words. 
26ad			; | | 
26ad			; | | e.g. UWORDS 
26ad			; | | BOX DIRLIST 2 
26ad			; | |  
26ad			; | | Can be used to save the words to storage via: 
26ad			; | | UWORDS $01 DO $01 APPEND LOOP 
26ad			if DEBUG_FORTH_WORDS_KEY 
26ad				DMARK "UWR" 
26ad f5				push af  
26ae 3a c2 26			ld a, (.dmark)  
26b1 32 6b ee			ld (debug_mark),a  
26b4 3a c3 26			ld a, (.dmark+1)  
26b7 32 6c ee			ld (debug_mark+1),a  
26ba 3a c4 26			ld a, (.dmark+2)  
26bd 32 6d ee			ld (debug_mark+2),a  
26c0 18 03			jr .pastdmark  
26c2 ..			.dmark: db "UWR"  
26c5 f1			.pastdmark: pop af  
26c6			endm  
# End of macro DMARK
26c6				CALLMONITOR 
26c6 cd 6f ee			call debug_vector  
26c9				endm  
# End of macro CALLMONITOR
26c9			endif 
26c9 21 66 5e			ld hl, baseram 
26cc				;ld hl, baseusermem 
26cc 01 00 00			ld bc, 0    ; start a counter 
26cf			 
26cf			; skip dict stub 
26cf			 
26cf cd 6b 20			call forth_tok_next 
26d2			 
26d2			 
26d2			; while we have words to look for 
26d2			 
26d2 7e			.douscan:	ld a, (hl)      
26d3			if DEBUG_FORTH_WORDS 
26d3				DMARK "UWs" 
26d3 f5				push af  
26d4 3a e8 26			ld a, (.dmark)  
26d7 32 6b ee			ld (debug_mark),a  
26da 3a e9 26			ld a, (.dmark+1)  
26dd 32 6c ee			ld (debug_mark+1),a  
26e0 3a ea 26			ld a, (.dmark+2)  
26e3 32 6d ee			ld (debug_mark+2),a  
26e6 18 03			jr .pastdmark  
26e8 ..			.dmark: db "UWs"  
26eb f1			.pastdmark: pop af  
26ec			endm  
# End of macro DMARK
26ec				CALLMONITOR 
26ec cd 6f ee			call debug_vector  
26ef				endm  
# End of macro CALLMONITOR
26ef			endif 
26ef fe 00			cp WORD_SYS_END 
26f1 28 4d			jr z, .udone 
26f3 fe 01			cp WORD_SYS_UWORD 
26f5 20 44			jr nz, .nuword 
26f7			 
26f7			if DEBUG_FORTH_WORDS 
26f7				DMARK "UWu" 
26f7 f5				push af  
26f8 3a 0c 27			ld a, (.dmark)  
26fb 32 6b ee			ld (debug_mark),a  
26fe 3a 0d 27			ld a, (.dmark+1)  
2701 32 6c ee			ld (debug_mark+1),a  
2704 3a 0e 27			ld a, (.dmark+2)  
2707 32 6d ee			ld (debug_mark+2),a  
270a 18 03			jr .pastdmark  
270c ..			.dmark: db "UWu"  
270f f1			.pastdmark: pop af  
2710			endm  
# End of macro DMARK
2710				CALLMONITOR 
2710 cd 6f ee			call debug_vector  
2713				endm  
# End of macro CALLMONITOR
2713			endif 
2713				; we have a uword so push its name to the stack 
2713			 
2713 e5				push hl  ; save so we can move to next dict block 
2714			 
2714				; skip opcode 
2714 23				inc hl  
2715				; skip next ptr 
2715 23				inc hl  
2716 23				inc hl 
2717				; skip len 
2717 23				inc hl 
2718			if DEBUG_FORTH_WORDS 
2718				DMARK "UWt" 
2718 f5				push af  
2719 3a 2d 27			ld a, (.dmark)  
271c 32 6b ee			ld (debug_mark),a  
271f 3a 2e 27			ld a, (.dmark+1)  
2722 32 6c ee			ld (debug_mark+1),a  
2725 3a 2f 27			ld a, (.dmark+2)  
2728 32 6d ee			ld (debug_mark+2),a  
272b 18 03			jr .pastdmark  
272d ..			.dmark: db "UWt"  
2730 f1			.pastdmark: pop af  
2731			endm  
# End of macro DMARK
2731				CALLMONITOR 
2731 cd 6f ee			call debug_vector  
2734				endm  
# End of macro CALLMONITOR
2734			endif 
2734 03				inc bc 
2735			 
2735 c5				push bc 
2736 cd db 1b			call forth_push_str 
2739 c1				pop bc 
273a			 
273a e1				pop hl 	 
273b			 
273b cd 6b 20		.nuword:	call forth_tok_next 
273e 18 92			jr .douscan  
2740			 
2740			.udone:		 ; push count of uwords found 
2740 c5				push bc 
2741 e1				pop hl 
2742			 
2742			if DEBUG_FORTH_WORDS 
2742				DMARK "UWc" 
2742 f5				push af  
2743 3a 57 27			ld a, (.dmark)  
2746 32 6b ee			ld (debug_mark),a  
2749 3a 58 27			ld a, (.dmark+1)  
274c 32 6c ee			ld (debug_mark+1),a  
274f 3a 59 27			ld a, (.dmark+2)  
2752 32 6d ee			ld (debug_mark+2),a  
2755 18 03			jr .pastdmark  
2757 ..			.dmark: db "UWc"  
275a f1			.pastdmark: pop af  
275b			endm  
# End of macro DMARK
275b				CALLMONITOR 
275b cd 6f ee			call debug_vector  
275e				endm  
# End of macro CALLMONITOR
275e			endif 
275e cd 6d 1b			call forth_push_numhl 
2761			 
2761			 
2761			       NEXTW 
2761 c3 1a 1f			jp macro_next 
2764				endm 
# End of macro NEXTW
2764			 
2764			.BP: 
2764			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2764 54				db WORD_SYS_CORE+64             
2765 9e 27			dw .MONITOR            
2767 03				db 2 + 1 
2768 .. 00			db "BP",0              
276b				endm 
# End of macro CWHEAD
276b			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
276b			; | | $00 Will enable the break points within specific code paths 
276b			; | | $01 Will disable break points 
276b			; | |  
276b			; | | By default break points are off. Either the above can be used to enable them 
276b			; | | or if a key is held down during start up the spashscreen will appear to freeze 
276b			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
276b			; | | can disable break points. Exiting will then continue boot process. 
276b				; get byte count 
276b				if DEBUG_FORTH_WORDS_KEY 
276b					DMARK "BP." 
276b f5				push af  
276c 3a 80 27			ld a, (.dmark)  
276f 32 6b ee			ld (debug_mark),a  
2772 3a 81 27			ld a, (.dmark+1)  
2775 32 6c ee			ld (debug_mark+1),a  
2778 3a 82 27			ld a, (.dmark+2)  
277b 32 6d ee			ld (debug_mark+2),a  
277e 18 03			jr .pastdmark  
2780 ..			.dmark: db "BP."  
2783 f1			.pastdmark: pop af  
2784			endm  
# End of macro DMARK
2784					CALLMONITOR 
2784 cd 6f ee			call debug_vector  
2787				endm  
# End of macro CALLMONITOR
2787				endif 
2787			 
2787				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2787 cd 64 1d			call macro_dsp_valuehl 
278a				endm 
# End of macro FORTH_DSP_VALUEHL
278a			 
278a			;		push hl 
278a			 
278a				; destroy value TOS 
278a			 
278a				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
278a cd 1c 1e			call macro_forth_dsp_pop 
278d				endm 
# End of macro FORTH_DSP_POP
278d			 
278d			;		pop hl 
278d			 
278d 3e 00			ld a,0 
278f bd				cp l 
2790 28 06			jr z, .bpset 
2792			;		ld a, '*' 
2792 cd fc 14			call bp_off 
2795				NEXTW 
2795 c3 1a 1f			jp macro_next 
2798				endm 
# End of macro NEXTW
2798			 
2798			.bpset:	 
2798				;	ld (os_view_disable), a 
2798 cd f0 14			call bp_on 
279b			 
279b			 
279b				NEXTW 
279b c3 1a 1f			jp macro_next 
279e				endm 
# End of macro NEXTW
279e			 
279e			 
279e			.MONITOR: 
279e			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
279e 55				db WORD_SYS_CORE+65             
279f cf 27			dw .MALLOC            
27a1 08				db 7 + 1 
27a2 .. 00			db "MONITOR",0              
27aa				endm 
# End of macro CWHEAD
27aa			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
27aa			; | | At start the current various registers will be displayed with contents. 
27aa			; | | Top right corner will show the most recent debug marker seen. 
27aa			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
27aa			; | | and the return stack pointer (RSP). 
27aa			; | | Pressing: 
27aa			; | |    1 - Initial screen 
27aa			; | |    2 - Display a data dump of HL 
27aa			; | |    3 - Display a data dump of DE 
27aa			; | |    4 - Display a data dump of BC 
27aa			; | |    5 - Display a data dump of HL 
27aa			; | |    6 - Display a data dump of DSP 
27aa			; | |    7 - Display a data dump of RSP 
27aa			; | |    8 - Display a data dump of what is at DSP 
27aa			; | |    9 - Display a data dump of what is at RSP 
27aa			; | |    0 - Exit monitor and continue running. This will also enable break points 
27aa			; | |    * - Disable break points 
27aa			; | |    # - Enter traditional monitor mode 
27aa			; | | 
27aa			; | | Monitor Mode 
27aa			; | | ------------ 
27aa			; | | A prompt of '>' will be shown for various commands: 
27aa			; | |    D xxxx - Display a data dump starting from hex address xxxx 
27aa			; | |    C - Continue display a data dump from the last set address 
27aa			; | |    M xxxx - Set start of memory edit at address xx 
27aa			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
27aa			; | |    G xxxx - Exec code at specific address 
27aa			; | |    Q - Return to previous 
27aa				if DEBUG_FORTH_WORDS_KEY 
27aa					DMARK "MON" 
27aa f5				push af  
27ab 3a bf 27			ld a, (.dmark)  
27ae 32 6b ee			ld (debug_mark),a  
27b1 3a c0 27			ld a, (.dmark+1)  
27b4 32 6c ee			ld (debug_mark+1),a  
27b7 3a c1 27			ld a, (.dmark+2)  
27ba 32 6d ee			ld (debug_mark+2),a  
27bd 18 03			jr .pastdmark  
27bf ..			.dmark: db "MON"  
27c2 f1			.pastdmark: pop af  
27c3			endm  
# End of macro DMARK
27c3					CALLMONITOR 
27c3 cd 6f ee			call debug_vector  
27c6				endm  
# End of macro CALLMONITOR
27c6				endif 
27c6			;		ld a, 0 
27c6			;		ld (os_view_disable), a 
27c6 cd f0 14			call bp_on 
27c9			 
27c9				CALLMONITOR 
27c9 cd 6f ee			call debug_vector  
27cc				endm  
# End of macro CALLMONITOR
27cc			 
27cc			;	call monitor 
27cc			 
27cc				NEXTW 
27cc c3 1a 1f			jp macro_next 
27cf				endm 
# End of macro NEXTW
27cf			 
27cf			 
27cf			.MALLOC: 
27cf			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
27cf 56				db WORD_SYS_CORE+66             
27d0 f8 27			dw .MALLOC2            
27d2 06				db 5 + 1 
27d3 .. 00			db "ALLOT",0              
27d9				endm 
# End of macro CWHEAD
27d9			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
27d9				if DEBUG_FORTH_WORDS_KEY 
27d9					DMARK "ALL" 
27d9 f5				push af  
27da 3a ee 27			ld a, (.dmark)  
27dd 32 6b ee			ld (debug_mark),a  
27e0 3a ef 27			ld a, (.dmark+1)  
27e3 32 6c ee			ld (debug_mark+1),a  
27e6 3a f0 27			ld a, (.dmark+2)  
27e9 32 6d ee			ld (debug_mark+2),a  
27ec 18 03			jr .pastdmark  
27ee ..			.dmark: db "ALL"  
27f1 f1			.pastdmark: pop af  
27f2			endm  
# End of macro DMARK
27f2					CALLMONITOR 
27f2 cd 6f ee			call debug_vector  
27f5				endm  
# End of macro CALLMONITOR
27f5				endif 
27f5 c3 1f 28			jp .mallocc 
27f8			.MALLOC2: 
27f8			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
27f8 56				db WORD_SYS_CORE+66             
27f9 36 28			dw .FREE            
27fb 07				db 6 + 1 
27fc .. 00			db "MALLOC",0              
2803				endm 
# End of macro CWHEAD
2803			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2803				; get byte count 
2803				if DEBUG_FORTH_WORDS_KEY 
2803					DMARK "MAL" 
2803 f5				push af  
2804 3a 18 28			ld a, (.dmark)  
2807 32 6b ee			ld (debug_mark),a  
280a 3a 19 28			ld a, (.dmark+1)  
280d 32 6c ee			ld (debug_mark+1),a  
2810 3a 1a 28			ld a, (.dmark+2)  
2813 32 6d ee			ld (debug_mark+2),a  
2816 18 03			jr .pastdmark  
2818 ..			.dmark: db "MAL"  
281b f1			.pastdmark: pop af  
281c			endm  
# End of macro DMARK
281c					CALLMONITOR 
281c cd 6f ee			call debug_vector  
281f				endm  
# End of macro CALLMONITOR
281f				endif 
281f			.mallocc: 
281f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
281f cd 64 1d			call macro_dsp_valuehl 
2822				endm 
# End of macro FORTH_DSP_VALUEHL
2822			 
2822			;		push hl 
2822			 
2822				; destroy value TOS 
2822			 
2822				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2822 cd 1c 1e			call macro_forth_dsp_pop 
2825				endm 
# End of macro FORTH_DSP_POP
2825			 
2825			;		pop hl 
2825 cd c1 11			call malloc 
2828			if DEBUG_FORTH_MALLOC_GUARD 
2828 f5				push af 
2829 cd 0f 0e			call ishlzero 
282c			;		ld a, l 
282c			;		add h 
282c			;		cp 0 
282c f1				pop af 
282d				 
282d cc da 4c			call z,malloc_error 
2830			endif 
2830			 
2830 cd 6d 1b			call forth_push_numhl 
2833				NEXTW 
2833 c3 1a 1f			jp macro_next 
2836				endm 
# End of macro NEXTW
2836			 
2836			.FREE: 
2836			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2836 57				db WORD_SYS_CORE+67             
2837 67 28			dw .LIST            
2839 05				db 4 + 1 
283a .. 00			db "FREE",0              
283f				endm 
# End of macro CWHEAD
283f			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
283f				if DEBUG_FORTH_WORDS_KEY 
283f					DMARK "FRE" 
283f f5				push af  
2840 3a 54 28			ld a, (.dmark)  
2843 32 6b ee			ld (debug_mark),a  
2846 3a 55 28			ld a, (.dmark+1)  
2849 32 6c ee			ld (debug_mark+1),a  
284c 3a 56 28			ld a, (.dmark+2)  
284f 32 6d ee			ld (debug_mark+2),a  
2852 18 03			jr .pastdmark  
2854 ..			.dmark: db "FRE"  
2857 f1			.pastdmark: pop af  
2858			endm  
# End of macro DMARK
2858					CALLMONITOR 
2858 cd 6f ee			call debug_vector  
285b				endm  
# End of macro CALLMONITOR
285b				endif 
285b				; get address 
285b			 
285b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
285b cd 64 1d			call macro_dsp_valuehl 
285e				endm 
# End of macro FORTH_DSP_VALUEHL
285e			 
285e			;		push hl 
285e			 
285e				; destroy value TOS 
285e			 
285e				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
285e cd 1c 1e			call macro_forth_dsp_pop 
2861				endm 
# End of macro FORTH_DSP_POP
2861			 
2861			;		pop hl 
2861			if FORTH_ENABLE_MALLOCFREE 
2861 cd 8b 12			call free 
2864			endif 
2864				NEXTW 
2864 c3 1a 1f			jp macro_next 
2867				endm 
# End of macro NEXTW
2867			.LIST: 
2867			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2867 5c				db WORD_SYS_CORE+72             
2868 57 2a			dw .FORGET            
286a 05				db 4 + 1 
286b .. 00			db "LIST",0              
2870				endm 
# End of macro CWHEAD
2870			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2870			; | | The quoted word must be in upper case. 
2870			if DEBUG_FORTH_WORDS_KEY 
2870				DMARK "LST" 
2870 f5				push af  
2871 3a 85 28			ld a, (.dmark)  
2874 32 6b ee			ld (debug_mark),a  
2877 3a 86 28			ld a, (.dmark+1)  
287a 32 6c ee			ld (debug_mark+1),a  
287d 3a 87 28			ld a, (.dmark+2)  
2880 32 6d ee			ld (debug_mark+2),a  
2883 18 03			jr .pastdmark  
2885 ..			.dmark: db "LST"  
2888 f1			.pastdmark: pop af  
2889			endm  
# End of macro DMARK
2889				CALLMONITOR 
2889 cd 6f ee			call debug_vector  
288c				endm  
# End of macro CALLMONITOR
288c			endif 
288c			 
288c				FORTH_DSP_VALUEHL 
288c cd 64 1d			call macro_dsp_valuehl 
288f				endm 
# End of macro FORTH_DSP_VALUEHL
288f			 
288f e5				push hl 
2890				FORTH_DSP_POP 
2890 cd 1c 1e			call macro_forth_dsp_pop 
2893				endm 
# End of macro FORTH_DSP_POP
2893 c1				pop bc 
2894			 
2894			; Start format of scratch string 
2894			 
2894 21 c1 e2			ld hl, scratch 
2897			 
2897 3e 3a			ld a, ':' 
2899 77				ld (hl),a 
289a 23				inc hl 
289b 3e 20			ld a, ' ' 
289d 77				ld (hl), a 
289e			 
289e				; Get ptr to the word we need to look up 
289e			 
289e			;		FORTH_DSP_VALUEHL 
289e				;v5 FORTH_DSP_VALUE 
289e			; TODO type check 
289e			;		inc hl    ; Skip type check  
289e			;		push hl 
289e			;		ex de, hl    ; put into DE 
289e			 
289e			 
289e 21 66 5e			ld hl, baseram 
28a1				;ld hl, baseusermem 
28a1			 
28a1 e5			push hl   ; sacreifical push 
28a2			 
28a2			.ldouscanm: 
28a2 e1			pop hl 
28a3			.ldouscan: 
28a3			if DEBUG_FORTH_WORDS 
28a3				DMARK "LSs" 
28a3 f5				push af  
28a4 3a b8 28			ld a, (.dmark)  
28a7 32 6b ee			ld (debug_mark),a  
28aa 3a b9 28			ld a, (.dmark+1)  
28ad 32 6c ee			ld (debug_mark+1),a  
28b0 3a ba 28			ld a, (.dmark+2)  
28b3 32 6d ee			ld (debug_mark+2),a  
28b6 18 03			jr .pastdmark  
28b8 ..			.dmark: db "LSs"  
28bb f1			.pastdmark: pop af  
28bc			endm  
# End of macro DMARK
28bc				CALLMONITOR 
28bc cd 6f ee			call debug_vector  
28bf				endm  
# End of macro CALLMONITOR
28bf			endif 
28bf			; skip dict stub 
28bf cd 6b 20			call forth_tok_next 
28c2			 
28c2			 
28c2			; while we have words to look for 
28c2			 
28c2 7e			ld a, (hl)      
28c3			if DEBUG_FORTH_WORDS 
28c3				DMARK "LSk" 
28c3 f5				push af  
28c4 3a d8 28			ld a, (.dmark)  
28c7 32 6b ee			ld (debug_mark),a  
28ca 3a d9 28			ld a, (.dmark+1)  
28cd 32 6c ee			ld (debug_mark+1),a  
28d0 3a da 28			ld a, (.dmark+2)  
28d3 32 6d ee			ld (debug_mark+2),a  
28d6 18 03			jr .pastdmark  
28d8 ..			.dmark: db "LSk"  
28db f1			.pastdmark: pop af  
28dc			endm  
# End of macro DMARK
28dc				CALLMONITOR 
28dc cd 6f ee			call debug_vector  
28df				endm  
# End of macro CALLMONITOR
28df			endif 
28df				;cp WORD_SYS_END 
28df				;jp z, .lunotfound 
28df			 
28df					; if we hit non uwords then gone too far 
28df fe 01				cp WORD_SYS_UWORD 
28e1 c2 13 2a				jp nz, .lunotfound 
28e4			 
28e4				if DEBUG_FORTH_WORDS 
28e4					DMARK "LSu" 
28e4 f5				push af  
28e5 3a f9 28			ld a, (.dmark)  
28e8 32 6b ee			ld (debug_mark),a  
28eb 3a fa 28			ld a, (.dmark+1)  
28ee 32 6c ee			ld (debug_mark+1),a  
28f1 3a fb 28			ld a, (.dmark+2)  
28f4 32 6d ee			ld (debug_mark+2),a  
28f7 18 03			jr .pastdmark  
28f9 ..			.dmark: db "LSu"  
28fc f1			.pastdmark: pop af  
28fd			endm  
# End of macro DMARK
28fd					CALLMONITOR 
28fd cd 6f ee			call debug_vector  
2900				endm  
# End of macro CALLMONITOR
2900				endif 
2900			 
2900					; found a uword but is it the one we want... 
2900			 
2900 c5					push bc     ; uword to find is on bc 
2901 d1					pop de 
2902			 
2902 e5					push hl  ; to save the ptr 
2903			 
2903					; skip opcode 
2903 23					inc hl  
2904					; skip next ptr 
2904 23					inc hl  
2905 23					inc hl 
2906					; skip len 
2906 23					inc hl 
2907			 
2907				if DEBUG_FORTH_WORDS 
2907					DMARK "LSc" 
2907 f5				push af  
2908 3a 1c 29			ld a, (.dmark)  
290b 32 6b ee			ld (debug_mark),a  
290e 3a 1d 29			ld a, (.dmark+1)  
2911 32 6c ee			ld (debug_mark+1),a  
2914 3a 1e 29			ld a, (.dmark+2)  
2917 32 6d ee			ld (debug_mark+2),a  
291a 18 03			jr .pastdmark  
291c ..			.dmark: db "LSc"  
291f f1			.pastdmark: pop af  
2920			endm  
# End of macro DMARK
2920					CALLMONITOR 
2920 cd 6f ee			call debug_vector  
2923				endm  
# End of macro CALLMONITOR
2923				endif 
2923			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2923			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2923			; Nope that has gone the other way. It needs to be exact not on first zero 
2923			;		call strcmp 
2923 c5					push bc 
2924 cd 91 11				call StrictStrCmp 
2927 c1					pop bc 
2928 c2 a2 28				jp nz, .ldouscanm 
292b				 
292b			 
292b			 
292b					; we have a uword so push its name to the stack 
292b			 
292b			;	   	push hl  ; save so we can move to next dict block 
292b e1			pop hl 
292c			 
292c				if DEBUG_FORTH_WORDS 
292c					DMARK "LSm" 
292c f5				push af  
292d 3a 41 29			ld a, (.dmark)  
2930 32 6b ee			ld (debug_mark),a  
2933 3a 42 29			ld a, (.dmark+1)  
2936 32 6c ee			ld (debug_mark+1),a  
2939 3a 43 29			ld a, (.dmark+2)  
293c 32 6d ee			ld (debug_mark+2),a  
293f 18 03			jr .pastdmark  
2941 ..			.dmark: db "LSm"  
2944 f1			.pastdmark: pop af  
2945			endm  
# End of macro DMARK
2945					CALLMONITOR 
2945 cd 6f ee			call debug_vector  
2948				endm  
# End of macro CALLMONITOR
2948				endif 
2948			 
2948					; skip opcode 
2948 23					inc hl  
2949					; skip next ptr 
2949 23					inc hl  
294a 23					inc hl 
294b					; skip len 
294b 7e					ld a, (hl)   ; save length to add 
294c				if DEBUG_FORTH_WORDS 
294c					DMARK "LS2" 
294c f5				push af  
294d 3a 61 29			ld a, (.dmark)  
2950 32 6b ee			ld (debug_mark),a  
2953 3a 62 29			ld a, (.dmark+1)  
2956 32 6c ee			ld (debug_mark+1),a  
2959 3a 63 29			ld a, (.dmark+2)  
295c 32 6d ee			ld (debug_mark+2),a  
295f 18 03			jr .pastdmark  
2961 ..			.dmark: db "LS2"  
2964 f1			.pastdmark: pop af  
2965			endm  
# End of macro DMARK
2965					CALLMONITOR 
2965 cd 6f ee			call debug_vector  
2968				endm  
# End of macro CALLMONITOR
2968				endif 
2968			 
2968					; save this location 
2968				 
2968 e5					push hl 
2969			 
2969 23					inc hl 
296a 11 c3 e2				ld de, scratch+2 
296d 4f					ld c, a 
296e 06 00				ld b, 0 
2970			 
2970				if DEBUG_FORTH_WORDS 
2970					DMARK "LSn" 
2970 f5				push af  
2971 3a 85 29			ld a, (.dmark)  
2974 32 6b ee			ld (debug_mark),a  
2977 3a 86 29			ld a, (.dmark+1)  
297a 32 6c ee			ld (debug_mark+1),a  
297d 3a 87 29			ld a, (.dmark+2)  
2980 32 6d ee			ld (debug_mark+2),a  
2983 18 03			jr .pastdmark  
2985 ..			.dmark: db "LSn"  
2988 f1			.pastdmark: pop af  
2989			endm  
# End of macro DMARK
2989					CALLMONITOR 
2989 cd 6f ee			call debug_vector  
298c				endm  
# End of macro CALLMONITOR
298c				endif 
298c			 
298c					; copy uword name to scratch 
298c			 
298c ed b0				ldir 
298e			 
298e 1b					dec de 
298f 3e 20				ld a, ' '    ; change null to space 
2991 12					ld (de), a 
2992			 
2992 13					inc de 
2993			 
2993 d5					push de 
2994 c1					pop bc     ; move scratch pointer to end of word name and save it 
2995			 
2995 e1					pop hl 
2996 7e					ld a, (hl) 
2997					;inc hl 
2997					; skip word string 
2997 cd e6 0d				call addatohl 
299a			 
299a 23					inc hl 
299b			 
299b				if DEBUG_FORTH_WORDS 
299b					DMARK "LS3" 
299b f5				push af  
299c 3a b0 29			ld a, (.dmark)  
299f 32 6b ee			ld (debug_mark),a  
29a2 3a b1 29			ld a, (.dmark+1)  
29a5 32 6c ee			ld (debug_mark+1),a  
29a8 3a b2 29			ld a, (.dmark+2)  
29ab 32 6d ee			ld (debug_mark+2),a  
29ae 18 03			jr .pastdmark  
29b0 ..			.dmark: db "LS3"  
29b3 f1			.pastdmark: pop af  
29b4			endm  
# End of macro DMARK
29b4					CALLMONITOR 
29b4 cd 6f ee			call debug_vector  
29b7				endm  
# End of macro CALLMONITOR
29b7				endif 
29b7					; should now be at the start of the machine code to setup the eval of the uword 
29b7					; now locate the ptr to the string defintion 
29b7			 
29b7					; skip ld hl, 
29b7					; then load the ptr 
29b7			; TODO use get from hl ptr 
29b7 23					inc hl 
29b8 5e					ld e, (hl) 
29b9 23					inc hl 
29ba 56					ld d, (hl) 
29bb eb					ex de, hl 
29bc			 
29bc			 
29bc				if DEBUG_FORTH_WORDS 
29bc					DMARK "LSt" 
29bc f5				push af  
29bd 3a d1 29			ld a, (.dmark)  
29c0 32 6b ee			ld (debug_mark),a  
29c3 3a d2 29			ld a, (.dmark+1)  
29c6 32 6c ee			ld (debug_mark+1),a  
29c9 3a d3 29			ld a, (.dmark+2)  
29cc 32 6d ee			ld (debug_mark+2),a  
29cf 18 03			jr .pastdmark  
29d1 ..			.dmark: db "LSt"  
29d4 f1			.pastdmark: pop af  
29d5			endm  
# End of macro DMARK
29d5					CALLMONITOR 
29d5 cd 6f ee			call debug_vector  
29d8				endm  
# End of macro CALLMONITOR
29d8				endif 
29d8			 
29d8			; cant push right now due to tokenised strings  
29d8			 
29d8			; get the destination of where to copy this definition to. 
29d8			 
29d8 c5					push bc 
29d9 d1					pop de 
29da			 
29da 7e			.listl:         ld a,(hl) 
29db fe 00				cp 0 
29dd 28 09				jr z, .lreplsp     ; replace zero with space 
29df					;cp FORTH_END_BUFFER 
29df fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
29e1 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
29e3				 
29e3					; just copy this char as is then 
29e3			 
29e3 12					ld (de), a 
29e4			 
29e4 23			.listnxt:	inc hl 
29e5 13					inc de 
29e6 18 f2				jr .listl 
29e8			 
29e8 3e 20		.lreplsp:	ld a,' ' 
29ea 12					ld (de), a 
29eb 18 f7				jr .listnxt 
29ed			 
29ed			; close up uword def 
29ed			 
29ed			.listdone: 
29ed 12					ld (de), a 
29ee 13					inc de 
29ef 3e 00				ld a, 0 
29f1 12					ld (de), a 
29f2			 
29f2			; now have def so clean up and push to stack 
29f2			 
29f2 21 c1 e2				ld hl, scratch 
29f5				if DEBUG_FORTH_WORDS 
29f5					DMARK "Ltp" 
29f5 f5				push af  
29f6 3a 0a 2a			ld a, (.dmark)  
29f9 32 6b ee			ld (debug_mark),a  
29fc 3a 0b 2a			ld a, (.dmark+1)  
29ff 32 6c ee			ld (debug_mark+1),a  
2a02 3a 0c 2a			ld a, (.dmark+2)  
2a05 32 6d ee			ld (debug_mark+2),a  
2a08 18 03			jr .pastdmark  
2a0a ..			.dmark: db "Ltp"  
2a0d f1			.pastdmark: pop af  
2a0e			endm  
# End of macro DMARK
2a0e					CALLMONITOR 
2a0e cd 6f ee			call debug_vector  
2a11				endm  
# End of macro CALLMONITOR
2a11				endif 
2a11			 
2a11 18 1f			jr .listpush 
2a13			 
2a13			;.lnuword:	pop hl 
2a13			;		call forth_tok_next 
2a13			;		jp .ldouscan  
2a13			 
2a13			.lunotfound:		  
2a13			 
2a13				if DEBUG_FORTH_WORDS 
2a13					DMARK "LSn" 
2a13 f5				push af  
2a14 3a 28 2a			ld a, (.dmark)  
2a17 32 6b ee			ld (debug_mark),a  
2a1a 3a 29 2a			ld a, (.dmark+1)  
2a1d 32 6c ee			ld (debug_mark+1),a  
2a20 3a 2a 2a			ld a, (.dmark+2)  
2a23 32 6d ee			ld (debug_mark+2),a  
2a26 18 03			jr .pastdmark  
2a28 ..			.dmark: db "LSn"  
2a2b f1			.pastdmark: pop af  
2a2c			endm  
# End of macro DMARK
2a2c					CALLMONITOR 
2a2c cd 6f ee			call debug_vector  
2a2f				endm  
# End of macro CALLMONITOR
2a2f				endif 
2a2f			 
2a2f					 
2a2f			;		FORTH_DSP_POP 
2a2f			;		ld hl, .luno 
2a2f			 
2a2f					NEXTW			 
2a2f c3 1a 1f			jp macro_next 
2a32				endm 
# End of macro NEXTW
2a32			 
2a32			.listpush: 
2a32				if DEBUG_FORTH_WORDS 
2a32					DMARK "LS>" 
2a32 f5				push af  
2a33 3a 47 2a			ld a, (.dmark)  
2a36 32 6b ee			ld (debug_mark),a  
2a39 3a 48 2a			ld a, (.dmark+1)  
2a3c 32 6c ee			ld (debug_mark+1),a  
2a3f 3a 49 2a			ld a, (.dmark+2)  
2a42 32 6d ee			ld (debug_mark+2),a  
2a45 18 03			jr .pastdmark  
2a47 ..			.dmark: db "LS>"  
2a4a f1			.pastdmark: pop af  
2a4b			endm  
# End of macro DMARK
2a4b					CALLMONITOR 
2a4b cd 6f ee			call debug_vector  
2a4e				endm  
# End of macro CALLMONITOR
2a4e				endif 
2a4e cd db 1b				call forth_push_str 
2a51			 
2a51			 
2a51			 
2a51					NEXTW 
2a51 c3 1a 1f			jp macro_next 
2a54				endm 
# End of macro NEXTW
2a54			 
2a54			;.luno:    db "Word not found",0 
2a54			 
2a54			 
2a54			 
2a54			 
2a54			 
2a54			;		push hl   ; save pointer to start of uword def string 
2a54			; 
2a54			;; look for FORTH_EOL_LINE 
2a54			;		ld a, FORTH_END_BUFFER 
2a54			;		call strlent 
2a54			; 
2a54			;		inc hl		 ; space for coln def 
2a54			;		inc hl 
2a54			;		inc hl          ; space for terms 
2a54			;		inc hl 
2a54			; 
2a54			;		ld a, 20   ; TODO get actual length 
2a54			;		call addatohl    ; include a random amount of room for the uword name 
2a54			; 
2a54			;		 
2a54			;	if DEBUG_FORTH_WORDS 
2a54			;		DMARK "Lt1" 
2a54			;		CALLMONITOR 
2a54			;	endif 
2a54			;		 
2a54			; 
2a54			;; malloc space for the string because we cant change it 
2a54			; 
2a54			;		call malloc 
2a54			;	if DEBUG_FORTH_MALLOC_GUARD 
2a54			;		push af 
2a54			;		call ishlzero 
2a54			;		pop af 
2a54			;		 
2a54			;		call z,malloc_error 
2a54			;	endif 
2a54			; 
2a54			;	if DEBUG_FORTH_WORDS 
2a54			;		DMARK "Lt2" 
2a54			;		CALLMONITOR 
2a54			;	endif 
2a54			;		pop de 
2a54			;		push hl    ; push the malloc to release later 
2a54			;		push hl   ;  push back a copy for the later stack push 
2a54			;		 
2a54			;; copy the string swapping out the zero terms for spaces 
2a54			; 
2a54			;		; de has our source 
2a54			;		; hl has our dest 
2a54			; 
2a54			;; add the coln def 
2a54			; 
2a54			;		ld a, ':' 
2a54			;		ld (hl), a 
2a54			;		inc hl 
2a54			;		ld a, ' ' 
2a54			;		ld (hl), a 
2a54			;		inc hl 
2a54			; 
2a54			;; add the uname word 
2a54			;		push de   ; save our string for now 
2a54			;		ex de, hl 
2a54			; 
2a54			;		FORTH_DSP_VALUE 
2a54			;		;v5 FORTH_DSP_VALUE 
2a54			; 
2a54			;		inc hl   ; skip type but we know by now this is OK 
2a54			; 
2a54			;.luword:	ld a,(hl) 
2a54			;		cp 0 
2a54			;		jr z, .luword2 
2a54			;		ld (de), a 
2a54			;		inc de 
2a54			;		inc hl 
2a54			;		jr .luword 
2a54			; 
2a54			;.luword2:	ld a, ' ' 
2a54			;		ld (de), a 
2a54			;;		inc hl 
2a54			;;		inc de 
2a54			;;		ld (de), a 
2a54			;;		inc hl 
2a54			;		inc de 
2a54			; 
2a54			;		ex de, hl 
2a54			;		pop de 
2a54			;		 
2a54			;		 
2a54			; 
2a54			;; detoken that string and copy it 
2a54			; 
2a54			;	if DEBUG_FORTH_WORDS 
2a54			;		DMARK "Lt2" 
2a54			;		CALLMONITOR 
2a54			;	endif 
2a54			;.ldetok:	ld a, (de) 
2a54			;		cp FORTH_END_BUFFER 
2a54			;		jr z, .ldetokend 
2a54			;		; swap out any zero term for space 
2a54			;		cp 0 
2a54			;		jr nz, .ldetoknext 
2a54			;		ld a, ' ' 
2a54			; 
2a54			;	if DEBUG_FORTH_WORDS 
2a54			;		DMARK "LtS" 
2a54			;		CALLMONITOR 
2a54			;	endif 
2a54			;.ldetoknext:	ld (hl), a 
2a54			;		inc de 
2a54			;		inc hl 
2a54			;		jr .ldetok 
2a54			; 
2a54			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2a54			;		ld (hl), a  
2a54			; 
2a54			;; free that temp malloc 
2a54			; 
2a54			;		pop hl    
2a54			; 
2a54			;	if DEBUG_FORTH_WORDS 
2a54			;		DMARK "Lt4" 
2a54			;		CALLMONITOR 
2a54			;	endif 
2a54			;		call forth_apushstrhl 
2a54			; 
2a54			;		; get rid of temp malloc area 
2a54			; 
2a54			;		pop hl 
2a54			;		call free 
2a54			; 
2a54			;		jr .ludone 
2a54			; 
2a54			;.lnuword:	pop hl 
2a54			;		call forth_tok_next 
2a54			;		jp .ldouscan  
2a54			; 
2a54			;.ludone:		 pop hl 
2a54			; 
2a54					NEXTW 
2a54 c3 1a 1f			jp macro_next 
2a57				endm 
# End of macro NEXTW
2a57			 
2a57			.FORGET: 
2a57				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2a57 5d				db WORD_SYS_CORE+73             
2a58 d0 2a			dw .NOP            
2a5a 07				db 6 + 1 
2a5b .. 00			db "FORGET",0              
2a62				endm 
# End of macro CWHEAD
2a62			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2a62			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2a62			; | |  
2a62			; | | e.g. "MORE" forget 
2a62					if DEBUG_FORTH_WORDS_KEY 
2a62						DMARK "FRG" 
2a62 f5				push af  
2a63 3a 77 2a			ld a, (.dmark)  
2a66 32 6b ee			ld (debug_mark),a  
2a69 3a 78 2a			ld a, (.dmark+1)  
2a6c 32 6c ee			ld (debug_mark+1),a  
2a6f 3a 79 2a			ld a, (.dmark+2)  
2a72 32 6d ee			ld (debug_mark+2),a  
2a75 18 03			jr .pastdmark  
2a77 ..			.dmark: db "FRG"  
2a7a f1			.pastdmark: pop af  
2a7b			endm  
# End of macro DMARK
2a7b						CALLMONITOR 
2a7b cd 6f ee			call debug_vector  
2a7e				endm  
# End of macro CALLMONITOR
2a7e					endif 
2a7e			 
2a7e				; find uword 
2a7e			        ; update start of word with "_" 
2a7e				; replace uword with deleted flag 
2a7e			 
2a7e			 
2a7e			;	if DEBUG_FORTH_WORDS 
2a7e			;		DMARK "FOG" 
2a7e			;		CALLMONITOR 
2a7e			;	endif 
2a7e			 
2a7e			 
2a7e					; Get ptr to the word we need to look up 
2a7e			 
2a7e					FORTH_DSP_VALUEHL 
2a7e cd 64 1d			call macro_dsp_valuehl 
2a81				endm 
# End of macro FORTH_DSP_VALUEHL
2a81					;v5 FORTH_DSP_VALUE 
2a81				; TODO type check 
2a81			;		inc hl    ; Skip type check  
2a81 e5					push hl 
2a82 c1					pop bc 
2a83			;		ex de, hl    ; put into DE 
2a83			 
2a83			 
2a83 21 66 5e				ld hl, baseram 
2a86					;ld hl, baseusermem 
2a86			 
2a86				; skip dict stub 
2a86			;	call forth_tok_next 
2a86 e5			push hl   ; sacreifical push 
2a87			 
2a87			.fldouscanm: 
2a87 e1				pop hl 
2a88			.fldouscan: 
2a88			;	if DEBUG_FORTH_WORDS 
2a88			;		DMARK "LSs" 
2a88			;		CALLMONITOR 
2a88			;	endif 
2a88				; skip dict stub 
2a88 cd 6b 20				call forth_tok_next 
2a8b			 
2a8b			 
2a8b			; while we have words to look for 
2a8b			 
2a8b 7e				ld a, (hl)      
2a8c			;	if DEBUG_FORTH_WORDS 
2a8c			;		DMARK "LSk" 
2a8c			;		CALLMONITOR 
2a8c			;	endif 
2a8c fe 00				cp WORD_SYS_END 
2a8e ca ca 2a				jp z, .flunotfound 
2a91 fe 01				cp WORD_SYS_UWORD 
2a93 c2 88 2a				jp nz, .fldouscan 
2a96			 
2a96			;	if DEBUG_FORTH_WORDS 
2a96			;		DMARK "LSu" 
2a96			;		CALLMONITOR 
2a96			;	endif 
2a96			 
2a96					; found a uword but is it the one we want... 
2a96			 
2a96 c5					push bc     ; uword to find is on bc 
2a97 d1					pop de 
2a98			 
2a98 e5					push hl  ; to save the ptr 
2a99			 
2a99					; skip opcode 
2a99 23					inc hl  
2a9a					; skip next ptr 
2a9a 23					inc hl  
2a9b 23					inc hl 
2a9c					; skip len 
2a9c 23					inc hl 
2a9d			 
2a9d			;	if DEBUG_FORTH_WORDS 
2a9d			;		DMARK "LSc" 
2a9d			;		CALLMONITOR 
2a9d			;	endif 
2a9d cd 84 11				call strcmp 
2aa0 c2 87 2a				jp nz, .fldouscanm 
2aa3			; 
2aa3			; 
2aa3			;; while we have words to look for 
2aa3			; 
2aa3			;.fdouscan:	ld a, (hl)      
2aa3			;	if DEBUG_FORTH_WORDS 
2aa3			;		DMARK "LSs" 
2aa3			;		CALLMONITOR 
2aa3			;	endif 
2aa3			;		cp WORD_SYS_END 
2aa3			;		jp z, .fudone 
2aa3			;		cp WORD_SYS_UWORD 
2aa3			;		jp nz, .fnuword 
2aa3			; 
2aa3			;	if DEBUG_FORTH_WORDS 
2aa3			;		DMARK "FGu" 
2aa3			;		CALLMONITOR 
2aa3			;	endif 
2aa3			; 
2aa3			;		; found a uword but is it the one we want... 
2aa3			; 
2aa3			; 
2aa3			;	        pop de   ; get back the dsp name 
2aa3			;		push de 
2aa3			; 
2aa3			;		push hl  ; to save the ptr 
2aa3			; 
2aa3			;		; skip opcode 
2aa3			;		inc hl  
2aa3			;		; skip next ptr 
2aa3			;		inc hl  
2aa3			;		inc hl 
2aa3			;		; skip len 
2aa3			;		inc hl 
2aa3			; 
2aa3			;	if DEBUG_FORTH_WORDS 
2aa3			;		DMARK "FGc" 
2aa3			;		CALLMONITOR 
2aa3			;	endif 
2aa3			;		call strcmp 
2aa3			;		jp nz, .fnuword 
2aa3			 
2aa3			 
2aa3 e1			pop hl 
2aa4			 
2aa4				 
2aa4				if DEBUG_FORTH_WORDS 
2aa4					DMARK "FGm" 
2aa4 f5				push af  
2aa5 3a b9 2a			ld a, (.dmark)  
2aa8 32 6b ee			ld (debug_mark),a  
2aab 3a ba 2a			ld a, (.dmark+1)  
2aae 32 6c ee			ld (debug_mark+1),a  
2ab1 3a bb 2a			ld a, (.dmark+2)  
2ab4 32 6d ee			ld (debug_mark+2),a  
2ab7 18 03			jr .pastdmark  
2ab9 ..			.dmark: db "FGm"  
2abc f1			.pastdmark: pop af  
2abd			endm  
# End of macro DMARK
2abd					CALLMONITOR 
2abd cd 6f ee			call debug_vector  
2ac0				endm  
# End of macro CALLMONITOR
2ac0				endif 
2ac0			 
2ac0			 
2ac0			 
2ac0					; we have a uword so push its name to the stack 
2ac0			 
2ac0			;	   	push hl  ; save so we can move to next dict block 
2ac0			;pop hl 
2ac0			 
2ac0					; update opcode to deleted 
2ac0 3e 03				ld a, WORD_SYS_DELETED 
2ac2 77					ld (hl), a 
2ac3			 
2ac3 23					inc hl  
2ac4					; skip next ptr 
2ac4 23					inc hl  
2ac5 23					inc hl 
2ac6					; skip len 
2ac6 23					inc hl 
2ac7			 
2ac7					; TODO change parser to skip deleted words but for now mark it out 
2ac7 3e 5f				ld a, "_" 
2ac9 77					ld  (hl),a 
2aca			 
2aca			;		jr .fudone 
2aca			; 
2aca			;.fnuword:	pop hl 
2aca			;		call forth_tok_next 
2aca			;		jp .fdouscan  
2aca			 
2aca			.flunotfound:		  
2aca			 
2aca			 
2aca					 
2aca					FORTH_DSP_POP 
2aca cd 1c 1e			call macro_forth_dsp_pop 
2acd				endm 
# End of macro FORTH_DSP_POP
2acd			;		ld hl, .luno 
2acd			;.fudone:		 pop hl 
2acd					NEXTW 
2acd c3 1a 1f			jp macro_next 
2ad0				endm 
# End of macro NEXTW
2ad0			.NOP: 
2ad0				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2ad0 61				db WORD_SYS_CORE+77             
2ad1 f7 2a			dw .COMO            
2ad3 04				db 3 + 1 
2ad4 .. 00			db "NOP",0              
2ad8				endm 
# End of macro CWHEAD
2ad8			; | NOP (  --  ) Do nothing | DONE 
2ad8					if DEBUG_FORTH_WORDS_KEY 
2ad8						DMARK "NOP" 
2ad8 f5				push af  
2ad9 3a ed 2a			ld a, (.dmark)  
2adc 32 6b ee			ld (debug_mark),a  
2adf 3a ee 2a			ld a, (.dmark+1)  
2ae2 32 6c ee			ld (debug_mark+1),a  
2ae5 3a ef 2a			ld a, (.dmark+2)  
2ae8 32 6d ee			ld (debug_mark+2),a  
2aeb 18 03			jr .pastdmark  
2aed ..			.dmark: db "NOP"  
2af0 f1			.pastdmark: pop af  
2af1			endm  
# End of macro DMARK
2af1						CALLMONITOR 
2af1 cd 6f ee			call debug_vector  
2af4				endm  
# End of macro CALLMONITOR
2af4					endif 
2af4				       NEXTW 
2af4 c3 1a 1f			jp macro_next 
2af7				endm 
# End of macro NEXTW
2af7			.COMO: 
2af7				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2af7 6e				db WORD_SYS_CORE+90             
2af8 49 2b			dw .COMC            
2afa 02				db 1 + 1 
2afb .. 00			db "(",0              
2afd				endm 
# End of macro CWHEAD
2afd			; | ( ( -- )  Start of comment | DONE 
2afd			 
2afd			 
2afd 2a c2 e5				ld hl, ( os_tok_ptr) 
2b00 11 44 2b			ld de, .closepar 
2b03					 
2b03					if DEBUG_FORTH_WORDS 
2b03						DMARK ").." 
2b03 f5				push af  
2b04 3a 18 2b			ld a, (.dmark)  
2b07 32 6b ee			ld (debug_mark),a  
2b0a 3a 19 2b			ld a, (.dmark+1)  
2b0d 32 6c ee			ld (debug_mark+1),a  
2b10 3a 1a 2b			ld a, (.dmark+2)  
2b13 32 6d ee			ld (debug_mark+2),a  
2b16 18 03			jr .pastdmark  
2b18 ..			.dmark: db ").."  
2b1b f1			.pastdmark: pop af  
2b1c			endm  
# End of macro DMARK
2b1c						CALLMONITOR 
2b1c cd 6f ee			call debug_vector  
2b1f				endm  
# End of macro CALLMONITOR
2b1f					endif 
2b1f cd 35 20			call findnexttok  
2b22			 
2b22					if DEBUG_FORTH_WORDS 
2b22						DMARK "IF5" 
2b22 f5				push af  
2b23 3a 37 2b			ld a, (.dmark)  
2b26 32 6b ee			ld (debug_mark),a  
2b29 3a 38 2b			ld a, (.dmark+1)  
2b2c 32 6c ee			ld (debug_mark+1),a  
2b2f 3a 39 2b			ld a, (.dmark+2)  
2b32 32 6d ee			ld (debug_mark+2),a  
2b35 18 03			jr .pastdmark  
2b37 ..			.dmark: db "IF5"  
2b3a f1			.pastdmark: pop af  
2b3b			endm  
# End of macro DMARK
2b3b						CALLMONITOR 
2b3b cd 6f ee			call debug_vector  
2b3e				endm  
# End of macro CALLMONITOR
2b3e					endif 
2b3e				; replace below with ) exec using tok_ptr 
2b3e 22 c2 e5			ld (os_tok_ptr), hl 
2b41 c3 ab 1f			jp exec1 
2b44			 
2b44 .. 00			.closepar:   db ")",0 
2b46			 
2b46				       NEXTW 
2b46 c3 1a 1f			jp macro_next 
2b49				endm 
# End of macro NEXTW
2b49			.COMC: 
2b49				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2b49 6f				db WORD_SYS_CORE+91             
2b4a 52 2b			dw .SCRATCH            
2b4c 02				db 1 + 1 
2b4d .. 00			db ")",0              
2b4f				endm 
# End of macro CWHEAD
2b4f			; | ) ( -- )  End of comment |  DONE  
2b4f				       NEXTW 
2b4f c3 1a 1f			jp macro_next 
2b52				endm 
# End of macro NEXTW
2b52			 
2b52			.SCRATCH: 
2b52				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2b52 6f				db WORD_SYS_CORE+91             
2b53 8d 2b			dw .INC            
2b55 08				db 7 + 1 
2b56 .. 00			db "SCRATCH",0              
2b5e				endm 
# End of macro CWHEAD
2b5e			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2b5e			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2b5e			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2b5e			; | |  
2b5e			; | | e.g.    : score $00 scratch ; 
2b5e			; | |  
2b5e			; | | $00 score ! 
2b5e			; | | $01 score +! 
2b5e			; | |  
2b5e			; | | e.g.   : varword $0a scratch ;  
2b5e			; | | 
2b5e			; | | $8000 varword ! 
2b5e					if DEBUG_FORTH_WORDS_KEY 
2b5e						DMARK "SCR" 
2b5e f5				push af  
2b5f 3a 73 2b			ld a, (.dmark)  
2b62 32 6b ee			ld (debug_mark),a  
2b65 3a 74 2b			ld a, (.dmark+1)  
2b68 32 6c ee			ld (debug_mark+1),a  
2b6b 3a 75 2b			ld a, (.dmark+2)  
2b6e 32 6d ee			ld (debug_mark+2),a  
2b71 18 03			jr .pastdmark  
2b73 ..			.dmark: db "SCR"  
2b76 f1			.pastdmark: pop af  
2b77			endm  
# End of macro DMARK
2b77						CALLMONITOR 
2b77 cd 6f ee			call debug_vector  
2b7a				endm  
# End of macro CALLMONITOR
2b7a					endif 
2b7a			 
2b7a					FORTH_DSP_VALUEHL 
2b7a cd 64 1d			call macro_dsp_valuehl 
2b7d				endm 
# End of macro FORTH_DSP_VALUEHL
2b7d				 
2b7d					FORTH_DSP_POP 
2b7d cd 1c 1e			call macro_forth_dsp_pop 
2b80				endm 
# End of macro FORTH_DSP_POP
2b80			 
2b80 7d					ld a, l 
2b81 21 e6 e7				ld hl, os_var_array 
2b84 cd e6 0d				call addatohl 
2b87			 
2b87 cd 6d 1b				call forth_push_numhl 
2b8a			 
2b8a				       NEXTW 
2b8a c3 1a 1f			jp macro_next 
2b8d				endm 
# End of macro NEXTW
2b8d			 
2b8d			.INC: 
2b8d				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2b8d 6f				db WORD_SYS_CORE+91             
2b8e e3 2b			dw .DEC            
2b90 03				db 2 + 1 
2b91 .. 00			db "+!",0              
2b94				endm 
# End of macro CWHEAD
2b94			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2b94					if DEBUG_FORTH_WORDS_KEY 
2b94						DMARK "+s_" 
2b94 f5				push af  
2b95 3a a9 2b			ld a, (.dmark)  
2b98 32 6b ee			ld (debug_mark),a  
2b9b 3a aa 2b			ld a, (.dmark+1)  
2b9e 32 6c ee			ld (debug_mark+1),a  
2ba1 3a ab 2b			ld a, (.dmark+2)  
2ba4 32 6d ee			ld (debug_mark+2),a  
2ba7 18 03			jr .pastdmark  
2ba9 ..			.dmark: db "+s_"  
2bac f1			.pastdmark: pop af  
2bad			endm  
# End of macro DMARK
2bad						CALLMONITOR 
2bad cd 6f ee			call debug_vector  
2bb0				endm  
# End of macro CALLMONITOR
2bb0					endif 
2bb0			 
2bb0					FORTH_DSP_VALUEHL 
2bb0 cd 64 1d			call macro_dsp_valuehl 
2bb3				endm 
# End of macro FORTH_DSP_VALUEHL
2bb3			 
2bb3 e5					push hl   ; save address 
2bb4			 
2bb4					FORTH_DSP_POP 
2bb4 cd 1c 1e			call macro_forth_dsp_pop 
2bb7				endm 
# End of macro FORTH_DSP_POP
2bb7			 
2bb7					FORTH_DSP_VALUEHL 
2bb7 cd 64 1d			call macro_dsp_valuehl 
2bba				endm 
# End of macro FORTH_DSP_VALUEHL
2bba			 
2bba e5					push hl 
2bbb					FORTH_DSP_POP 
2bbb cd 1c 1e			call macro_forth_dsp_pop 
2bbe				endm 
# End of macro FORTH_DSP_POP
2bbe e1					pop hl 
2bbf			 
2bbf					; hl contains value to add to byte at a 
2bbf				 
2bbf eb					ex de, hl 
2bc0			 
2bc0 e1					pop hl 
2bc1			 
2bc1					if DEBUG_FORTH_WORDS 
2bc1						DMARK "INC" 
2bc1 f5				push af  
2bc2 3a d6 2b			ld a, (.dmark)  
2bc5 32 6b ee			ld (debug_mark),a  
2bc8 3a d7 2b			ld a, (.dmark+1)  
2bcb 32 6c ee			ld (debug_mark+1),a  
2bce 3a d8 2b			ld a, (.dmark+2)  
2bd1 32 6d ee			ld (debug_mark+2),a  
2bd4 18 03			jr .pastdmark  
2bd6 ..			.dmark: db "INC"  
2bd9 f1			.pastdmark: pop af  
2bda			endm  
# End of macro DMARK
2bda						CALLMONITOR 
2bda cd 6f ee			call debug_vector  
2bdd				endm  
# End of macro CALLMONITOR
2bdd					endif 
2bdd			 
2bdd 7e					ld a,(hl) 
2bde 83					add e 
2bdf 77					ld (hl),a 
2be0			 
2be0			 
2be0			 
2be0				       NEXTW 
2be0 c3 1a 1f			jp macro_next 
2be3				endm 
# End of macro NEXTW
2be3			 
2be3			.DEC: 
2be3				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2be3 6f				db WORD_SYS_CORE+91             
2be4 37 2c			dw .INC2            
2be6 03				db 2 + 1 
2be7 .. 00			db "-!",0              
2bea				endm 
# End of macro CWHEAD
2bea			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2bea					if DEBUG_FORTH_WORDS_KEY 
2bea						DMARK "-s_" 
2bea f5				push af  
2beb 3a ff 2b			ld a, (.dmark)  
2bee 32 6b ee			ld (debug_mark),a  
2bf1 3a 00 2c			ld a, (.dmark+1)  
2bf4 32 6c ee			ld (debug_mark+1),a  
2bf7 3a 01 2c			ld a, (.dmark+2)  
2bfa 32 6d ee			ld (debug_mark+2),a  
2bfd 18 03			jr .pastdmark  
2bff ..			.dmark: db "-s_"  
2c02 f1			.pastdmark: pop af  
2c03			endm  
# End of macro DMARK
2c03						CALLMONITOR 
2c03 cd 6f ee			call debug_vector  
2c06				endm  
# End of macro CALLMONITOR
2c06					endif 
2c06			 
2c06					FORTH_DSP_VALUEHL 
2c06 cd 64 1d			call macro_dsp_valuehl 
2c09				endm 
# End of macro FORTH_DSP_VALUEHL
2c09			 
2c09 e5					push hl   ; save address 
2c0a			 
2c0a					FORTH_DSP_POP 
2c0a cd 1c 1e			call macro_forth_dsp_pop 
2c0d				endm 
# End of macro FORTH_DSP_POP
2c0d			 
2c0d					FORTH_DSP_VALUEHL 
2c0d cd 64 1d			call macro_dsp_valuehl 
2c10				endm 
# End of macro FORTH_DSP_VALUEHL
2c10			 
2c10					; hl contains value to add to byte at a 
2c10				 
2c10 eb					ex de, hl 
2c11			 
2c11 e1					pop hl 
2c12			 
2c12					if DEBUG_FORTH_WORDS 
2c12						DMARK "DEC" 
2c12 f5				push af  
2c13 3a 27 2c			ld a, (.dmark)  
2c16 32 6b ee			ld (debug_mark),a  
2c19 3a 28 2c			ld a, (.dmark+1)  
2c1c 32 6c ee			ld (debug_mark+1),a  
2c1f 3a 29 2c			ld a, (.dmark+2)  
2c22 32 6d ee			ld (debug_mark+2),a  
2c25 18 03			jr .pastdmark  
2c27 ..			.dmark: db "DEC"  
2c2a f1			.pastdmark: pop af  
2c2b			endm  
# End of macro DMARK
2c2b						CALLMONITOR 
2c2b cd 6f ee			call debug_vector  
2c2e				endm  
# End of macro CALLMONITOR
2c2e					endif 
2c2e			 
2c2e 7e					ld a,(hl) 
2c2f 93					sub e 
2c30 77					ld (hl),a 
2c31			 
2c31			 
2c31					FORTH_DSP_POP 
2c31 cd 1c 1e			call macro_forth_dsp_pop 
2c34				endm 
# End of macro FORTH_DSP_POP
2c34			 
2c34				       NEXTW 
2c34 c3 1a 1f			jp macro_next 
2c37				endm 
# End of macro NEXTW
2c37			 
2c37			.INC2: 
2c37				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2c37 6f				db WORD_SYS_CORE+91             
2c38 e4 2c			dw .DEC2            
2c3a 04				db 3 + 1 
2c3b .. 00			db "+2!",0              
2c3f				endm 
# End of macro CWHEAD
2c3f			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2c3f			 
2c3f					if DEBUG_FORTH_WORDS_KEY 
2c3f						DMARK "+2s" 
2c3f f5				push af  
2c40 3a 54 2c			ld a, (.dmark)  
2c43 32 6b ee			ld (debug_mark),a  
2c46 3a 55 2c			ld a, (.dmark+1)  
2c49 32 6c ee			ld (debug_mark+1),a  
2c4c 3a 56 2c			ld a, (.dmark+2)  
2c4f 32 6d ee			ld (debug_mark+2),a  
2c52 18 03			jr .pastdmark  
2c54 ..			.dmark: db "+2s"  
2c57 f1			.pastdmark: pop af  
2c58			endm  
# End of macro DMARK
2c58						CALLMONITOR 
2c58 cd 6f ee			call debug_vector  
2c5b				endm  
# End of macro CALLMONITOR
2c5b					endif 
2c5b			 
2c5b					; Address 
2c5b			 
2c5b					FORTH_DSP_VALUEHL 
2c5b cd 64 1d			call macro_dsp_valuehl 
2c5e				endm 
# End of macro FORTH_DSP_VALUEHL
2c5e			 
2c5e e5					push hl    ; save address 
2c5f			 
2c5f					; load content into de 
2c5f			 
2c5f 5e					ld e,(hl) 
2c60 23					inc hl 
2c61 56					ld d, (hl) 
2c62			 
2c62					if DEBUG_FORTH_WORDS 
2c62						DMARK "+2a" 
2c62 f5				push af  
2c63 3a 77 2c			ld a, (.dmark)  
2c66 32 6b ee			ld (debug_mark),a  
2c69 3a 78 2c			ld a, (.dmark+1)  
2c6c 32 6c ee			ld (debug_mark+1),a  
2c6f 3a 79 2c			ld a, (.dmark+2)  
2c72 32 6d ee			ld (debug_mark+2),a  
2c75 18 03			jr .pastdmark  
2c77 ..			.dmark: db "+2a"  
2c7a f1			.pastdmark: pop af  
2c7b			endm  
# End of macro DMARK
2c7b						CALLMONITOR 
2c7b cd 6f ee			call debug_vector  
2c7e				endm  
# End of macro CALLMONITOR
2c7e					endif 
2c7e			 
2c7e					FORTH_DSP_POP 
2c7e cd 1c 1e			call macro_forth_dsp_pop 
2c81				endm 
# End of macro FORTH_DSP_POP
2c81			 
2c81					; Get value to add 
2c81			 
2c81					FORTH_DSP_VALUE 
2c81 cd 4d 1d			call macro_forth_dsp_value 
2c84				endm 
# End of macro FORTH_DSP_VALUE
2c84			 
2c84					if DEBUG_FORTH_WORDS 
2c84						DMARK "+2v" 
2c84 f5				push af  
2c85 3a 99 2c			ld a, (.dmark)  
2c88 32 6b ee			ld (debug_mark),a  
2c8b 3a 9a 2c			ld a, (.dmark+1)  
2c8e 32 6c ee			ld (debug_mark+1),a  
2c91 3a 9b 2c			ld a, (.dmark+2)  
2c94 32 6d ee			ld (debug_mark+2),a  
2c97 18 03			jr .pastdmark  
2c99 ..			.dmark: db "+2v"  
2c9c f1			.pastdmark: pop af  
2c9d			endm  
# End of macro DMARK
2c9d						CALLMONITOR 
2c9d cd 6f ee			call debug_vector  
2ca0				endm  
# End of macro CALLMONITOR
2ca0					endif 
2ca0			 
2ca0 19					add hl, de 
2ca1			 
2ca1					if DEBUG_FORTH_WORDS 
2ca1						DMARK "+2+" 
2ca1 f5				push af  
2ca2 3a b6 2c			ld a, (.dmark)  
2ca5 32 6b ee			ld (debug_mark),a  
2ca8 3a b7 2c			ld a, (.dmark+1)  
2cab 32 6c ee			ld (debug_mark+1),a  
2cae 3a b8 2c			ld a, (.dmark+2)  
2cb1 32 6d ee			ld (debug_mark+2),a  
2cb4 18 03			jr .pastdmark  
2cb6 ..			.dmark: db "+2+"  
2cb9 f1			.pastdmark: pop af  
2cba			endm  
# End of macro DMARK
2cba						CALLMONITOR 
2cba cd 6f ee			call debug_vector  
2cbd				endm  
# End of macro CALLMONITOR
2cbd					endif 
2cbd			 
2cbd					; move result to de 
2cbd			 
2cbd eb					ex de, hl 
2cbe			 
2cbe					; Address 
2cbe			 
2cbe e1					pop hl 
2cbf			 
2cbf					; save it back 
2cbf			 
2cbf 73					ld (hl), e 
2cc0 23					inc hl 
2cc1 72					ld (hl), d 
2cc2			 
2cc2					if DEBUG_FORTH_WORDS 
2cc2						DMARK "+2e" 
2cc2 f5				push af  
2cc3 3a d7 2c			ld a, (.dmark)  
2cc6 32 6b ee			ld (debug_mark),a  
2cc9 3a d8 2c			ld a, (.dmark+1)  
2ccc 32 6c ee			ld (debug_mark+1),a  
2ccf 3a d9 2c			ld a, (.dmark+2)  
2cd2 32 6d ee			ld (debug_mark+2),a  
2cd5 18 03			jr .pastdmark  
2cd7 ..			.dmark: db "+2e"  
2cda f1			.pastdmark: pop af  
2cdb			endm  
# End of macro DMARK
2cdb						CALLMONITOR 
2cdb cd 6f ee			call debug_vector  
2cde				endm  
# End of macro CALLMONITOR
2cde					endif 
2cde			 
2cde			 
2cde			 
2cde					FORTH_DSP_POP 
2cde cd 1c 1e			call macro_forth_dsp_pop 
2ce1				endm 
# End of macro FORTH_DSP_POP
2ce1			 
2ce1			 
2ce1				       NEXTW 
2ce1 c3 1a 1f			jp macro_next 
2ce4				endm 
# End of macro NEXTW
2ce4			 
2ce4			.DEC2: 
2ce4				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2ce4 6f				db WORD_SYS_CORE+91             
2ce5 93 2d			dw .GET2            
2ce7 04				db 3 + 1 
2ce8 .. 00			db "-2!",0              
2cec				endm 
# End of macro CWHEAD
2cec			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2cec			 
2cec			 
2cec					if DEBUG_FORTH_WORDS_KEY 
2cec						DMARK "-2s" 
2cec f5				push af  
2ced 3a 01 2d			ld a, (.dmark)  
2cf0 32 6b ee			ld (debug_mark),a  
2cf3 3a 02 2d			ld a, (.dmark+1)  
2cf6 32 6c ee			ld (debug_mark+1),a  
2cf9 3a 03 2d			ld a, (.dmark+2)  
2cfc 32 6d ee			ld (debug_mark+2),a  
2cff 18 03			jr .pastdmark  
2d01 ..			.dmark: db "-2s"  
2d04 f1			.pastdmark: pop af  
2d05			endm  
# End of macro DMARK
2d05						CALLMONITOR 
2d05 cd 6f ee			call debug_vector  
2d08				endm  
# End of macro CALLMONITOR
2d08					endif 
2d08			 
2d08					; Address 
2d08			 
2d08					FORTH_DSP_VALUEHL 
2d08 cd 64 1d			call macro_dsp_valuehl 
2d0b				endm 
# End of macro FORTH_DSP_VALUEHL
2d0b			 
2d0b e5					push hl    ; save address 
2d0c			 
2d0c					; load content into de 
2d0c			 
2d0c 5e					ld e,(hl) 
2d0d 23					inc hl 
2d0e 56					ld d, (hl) 
2d0f			 
2d0f					if DEBUG_FORTH_WORDS 
2d0f						DMARK "-2a" 
2d0f f5				push af  
2d10 3a 24 2d			ld a, (.dmark)  
2d13 32 6b ee			ld (debug_mark),a  
2d16 3a 25 2d			ld a, (.dmark+1)  
2d19 32 6c ee			ld (debug_mark+1),a  
2d1c 3a 26 2d			ld a, (.dmark+2)  
2d1f 32 6d ee			ld (debug_mark+2),a  
2d22 18 03			jr .pastdmark  
2d24 ..			.dmark: db "-2a"  
2d27 f1			.pastdmark: pop af  
2d28			endm  
# End of macro DMARK
2d28						CALLMONITOR 
2d28 cd 6f ee			call debug_vector  
2d2b				endm  
# End of macro CALLMONITOR
2d2b					endif 
2d2b			 
2d2b					FORTH_DSP_POP 
2d2b cd 1c 1e			call macro_forth_dsp_pop 
2d2e				endm 
# End of macro FORTH_DSP_POP
2d2e			 
2d2e					; Get value to remove 
2d2e			 
2d2e					FORTH_DSP_VALUE 
2d2e cd 4d 1d			call macro_forth_dsp_value 
2d31				endm 
# End of macro FORTH_DSP_VALUE
2d31			 
2d31					if DEBUG_FORTH_WORDS 
2d31						DMARK "-2v" 
2d31 f5				push af  
2d32 3a 46 2d			ld a, (.dmark)  
2d35 32 6b ee			ld (debug_mark),a  
2d38 3a 47 2d			ld a, (.dmark+1)  
2d3b 32 6c ee			ld (debug_mark+1),a  
2d3e 3a 48 2d			ld a, (.dmark+2)  
2d41 32 6d ee			ld (debug_mark+2),a  
2d44 18 03			jr .pastdmark  
2d46 ..			.dmark: db "-2v"  
2d49 f1			.pastdmark: pop af  
2d4a			endm  
# End of macro DMARK
2d4a						CALLMONITOR 
2d4a cd 6f ee			call debug_vector  
2d4d				endm  
# End of macro CALLMONITOR
2d4d					endif 
2d4d			 
2d4d eb					ex de, hl 
2d4e ed 52				sbc hl, de 
2d50			 
2d50					if DEBUG_FORTH_WORDS 
2d50						DMARK "-2d" 
2d50 f5				push af  
2d51 3a 65 2d			ld a, (.dmark)  
2d54 32 6b ee			ld (debug_mark),a  
2d57 3a 66 2d			ld a, (.dmark+1)  
2d5a 32 6c ee			ld (debug_mark+1),a  
2d5d 3a 67 2d			ld a, (.dmark+2)  
2d60 32 6d ee			ld (debug_mark+2),a  
2d63 18 03			jr .pastdmark  
2d65 ..			.dmark: db "-2d"  
2d68 f1			.pastdmark: pop af  
2d69			endm  
# End of macro DMARK
2d69						CALLMONITOR 
2d69 cd 6f ee			call debug_vector  
2d6c				endm  
# End of macro CALLMONITOR
2d6c					endif 
2d6c			 
2d6c					; move result to de 
2d6c			 
2d6c eb					ex de, hl 
2d6d			 
2d6d					; Address 
2d6d			 
2d6d e1					pop hl 
2d6e			 
2d6e					; save it back 
2d6e			 
2d6e 73					ld (hl), e 
2d6f 23					inc hl 
2d70 72					ld (hl), d 
2d71			 
2d71					if DEBUG_FORTH_WORDS 
2d71						DMARK "-2e" 
2d71 f5				push af  
2d72 3a 86 2d			ld a, (.dmark)  
2d75 32 6b ee			ld (debug_mark),a  
2d78 3a 87 2d			ld a, (.dmark+1)  
2d7b 32 6c ee			ld (debug_mark+1),a  
2d7e 3a 88 2d			ld a, (.dmark+2)  
2d81 32 6d ee			ld (debug_mark+2),a  
2d84 18 03			jr .pastdmark  
2d86 ..			.dmark: db "-2e"  
2d89 f1			.pastdmark: pop af  
2d8a			endm  
# End of macro DMARK
2d8a						CALLMONITOR 
2d8a cd 6f ee			call debug_vector  
2d8d				endm  
# End of macro CALLMONITOR
2d8d					endif 
2d8d			 
2d8d			 
2d8d					FORTH_DSP_POP 
2d8d cd 1c 1e			call macro_forth_dsp_pop 
2d90				endm 
# End of macro FORTH_DSP_POP
2d90			 
2d90			 
2d90			 
2d90				       NEXTW 
2d90 c3 1a 1f			jp macro_next 
2d93				endm 
# End of macro NEXTW
2d93			.GET2: 
2d93				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2d93 6f				db WORD_SYS_CORE+91             
2d94 c8 2d			dw .BANG2            
2d96 03				db 2 + 1 
2d97 .. 00			db "2@",0              
2d9a				endm 
# End of macro CWHEAD
2d9a			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2d9a					if DEBUG_FORTH_WORDS_KEY 
2d9a						DMARK "2A_" 
2d9a f5				push af  
2d9b 3a af 2d			ld a, (.dmark)  
2d9e 32 6b ee			ld (debug_mark),a  
2da1 3a b0 2d			ld a, (.dmark+1)  
2da4 32 6c ee			ld (debug_mark+1),a  
2da7 3a b1 2d			ld a, (.dmark+2)  
2daa 32 6d ee			ld (debug_mark+2),a  
2dad 18 03			jr .pastdmark  
2daf ..			.dmark: db "2A_"  
2db2 f1			.pastdmark: pop af  
2db3			endm  
# End of macro DMARK
2db3						CALLMONITOR 
2db3 cd 6f ee			call debug_vector  
2db6				endm  
# End of macro CALLMONITOR
2db6					endif 
2db6			 
2db6					FORTH_DSP_VALUEHL 
2db6 cd 64 1d			call macro_dsp_valuehl 
2db9				endm 
# End of macro FORTH_DSP_VALUEHL
2db9			 
2db9 e5					push hl   ; save address 
2dba			 
2dba					FORTH_DSP_POP 
2dba cd 1c 1e			call macro_forth_dsp_pop 
2dbd				endm 
# End of macro FORTH_DSP_POP
2dbd			 
2dbd e1					pop hl 
2dbe			 
2dbe 5e					ld e, (hl) 
2dbf 23					inc hl 
2dc0 56					ld d, (hl) 
2dc1			 
2dc1 eb					ex de, hl 
2dc2			 
2dc2 cd 6d 1b				call forth_push_numhl 
2dc5			 
2dc5				       NEXTW 
2dc5 c3 1a 1f			jp macro_next 
2dc8				endm 
# End of macro NEXTW
2dc8			.BANG2: 
2dc8				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2dc8 6f				db WORD_SYS_CORE+91             
2dc9 00 2e			dw .CONFIG            
2dcb 03				db 2 + 1 
2dcc .. 00			db "2!",0              
2dcf				endm 
# End of macro CWHEAD
2dcf			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2dcf					if DEBUG_FORTH_WORDS_KEY 
2dcf						DMARK "2S_" 
2dcf f5				push af  
2dd0 3a e4 2d			ld a, (.dmark)  
2dd3 32 6b ee			ld (debug_mark),a  
2dd6 3a e5 2d			ld a, (.dmark+1)  
2dd9 32 6c ee			ld (debug_mark+1),a  
2ddc 3a e6 2d			ld a, (.dmark+2)  
2ddf 32 6d ee			ld (debug_mark+2),a  
2de2 18 03			jr .pastdmark  
2de4 ..			.dmark: db "2S_"  
2de7 f1			.pastdmark: pop af  
2de8			endm  
# End of macro DMARK
2de8						CALLMONITOR 
2de8 cd 6f ee			call debug_vector  
2deb				endm  
# End of macro CALLMONITOR
2deb					endif 
2deb			 
2deb					FORTH_DSP_VALUEHL 
2deb cd 64 1d			call macro_dsp_valuehl 
2dee				endm 
# End of macro FORTH_DSP_VALUEHL
2dee			 
2dee e5					push hl   ; save address 
2def			 
2def			 
2def					FORTH_DSP_POP 
2def cd 1c 1e			call macro_forth_dsp_pop 
2df2				endm 
# End of macro FORTH_DSP_POP
2df2			 
2df2					 
2df2					FORTH_DSP_VALUEHL 
2df2 cd 64 1d			call macro_dsp_valuehl 
2df5				endm 
# End of macro FORTH_DSP_VALUEHL
2df5			 
2df5					FORTH_DSP_POP 
2df5 cd 1c 1e			call macro_forth_dsp_pop 
2df8				endm 
# End of macro FORTH_DSP_POP
2df8			 
2df8 eb					ex de, hl    ; value now in de 
2df9			 
2df9 e1					pop hl 
2dfa			 
2dfa 73					ld (hl), e 
2dfb			 
2dfb 23					inc hl 
2dfc			 
2dfc 72					ld (hl), d 
2dfd			 
2dfd			 
2dfd				       NEXTW 
2dfd c3 1a 1f			jp macro_next 
2e00				endm 
# End of macro NEXTW
2e00			.CONFIG: 
2e00				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
2e00 6f				db WORD_SYS_CORE+91             
2e01 11 2e			dw .ADTOS            
2e03 07				db 6 + 1 
2e04 .. 00			db "CONFIG",0              
2e0b				endm 
# End of macro CWHEAD
2e0b			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2e0b			 
2e0b cd 5a 13				call config 
2e0e					NEXTW 
2e0e c3 1a 1f			jp macro_next 
2e11				endm 
# End of macro NEXTW
2e11			 
2e11			.ADTOS: 
2e11				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
2e11 6f				db WORD_SYS_CORE+91             
2e12 27 2e			dw .SBTOS            
2e14 03				db 2 + 1 
2e15 .. 00			db "1+",0              
2e18				endm 
# End of macro CWHEAD
2e18			; | 1+ ( u -- u )  Increment value on TOS | DONE 
2e18			 
2e18					FORTH_DSP_VALUEHL 
2e18 cd 64 1d			call macro_dsp_valuehl 
2e1b				endm 
# End of macro FORTH_DSP_VALUEHL
2e1b e5					push hl 
2e1c			 
2e1c					FORTH_DSP_POP 
2e1c cd 1c 1e			call macro_forth_dsp_pop 
2e1f				endm 
# End of macro FORTH_DSP_POP
2e1f e1					pop hl 
2e20			 
2e20 23					inc hl 
2e21 cd 6d 1b				call forth_push_numhl 
2e24					 
2e24					NEXTW 
2e24 c3 1a 1f			jp macro_next 
2e27				endm 
# End of macro NEXTW
2e27			.SBTOS: 
2e27				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
2e27 6f				db WORD_SYS_CORE+91             
2e28 3d 2e			dw .ADSTORE            
2e2a 03				db 2 + 1 
2e2b .. 00			db "1-",0              
2e2e				endm 
# End of macro CWHEAD
2e2e			; | 1- ( u -- u )  Decrement value on TOS | DONE 
2e2e			 
2e2e					FORTH_DSP_VALUEHL 
2e2e cd 64 1d			call macro_dsp_valuehl 
2e31				endm 
# End of macro FORTH_DSP_VALUEHL
2e31 e5					push hl 
2e32			 
2e32					FORTH_DSP_POP 
2e32 cd 1c 1e			call macro_forth_dsp_pop 
2e35				endm 
# End of macro FORTH_DSP_POP
2e35 e1					pop hl 
2e36			 
2e36 2b					dec hl 
2e37 cd 6d 1b				call forth_push_numhl 
2e3a					 
2e3a					NEXTW 
2e3a c3 1a 1f			jp macro_next 
2e3d				endm 
# End of macro NEXTW
2e3d			.ADSTORE: 
2e3d				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
2e3d 6f				db WORD_SYS_CORE+91             
2e3e 53 2e			dw .ADWSTORE            
2e40 04				db 3 + 1 
2e41 .. 00			db "1+!",0              
2e45				endm 
# End of macro CWHEAD
2e45			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
2e45			 
2e45					FORTH_DSP_VALUEHL 
2e45 cd 64 1d			call macro_dsp_valuehl 
2e48				endm 
# End of macro FORTH_DSP_VALUEHL
2e48 e5					push hl 
2e49			 
2e49					FORTH_DSP_POP 
2e49 cd 1c 1e			call macro_forth_dsp_pop 
2e4c				endm 
# End of macro FORTH_DSP_POP
2e4c e1					pop hl 
2e4d			 
2e4d 7e					ld a, (hl) 
2e4e 3c					inc a 
2e4f 77					ld (hl), a 
2e50					 
2e50					NEXTW 
2e50 c3 1a 1f			jp macro_next 
2e53				endm 
# End of macro NEXTW
2e53			.ADWSTORE: 
2e53				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
2e53 6f				db WORD_SYS_CORE+91             
2e54 71 2e			dw .SBSTORE            
2e56 05				db 4 + 1 
2e57 .. 00			db "1+2!",0              
2e5c				endm 
# End of macro CWHEAD
2e5c			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
2e5c			 
2e5c					FORTH_DSP_VALUEHL 
2e5c cd 64 1d			call macro_dsp_valuehl 
2e5f				endm 
# End of macro FORTH_DSP_VALUEHL
2e5f e5					push hl 
2e60			 
2e60					FORTH_DSP_POP 
2e60 cd 1c 1e			call macro_forth_dsp_pop 
2e63				endm 
# End of macro FORTH_DSP_POP
2e63 e1					pop hl 
2e64			 
2e64 e5					push hl 
2e65			 
2e65 cd 9c 1e				call loadwordinhl 
2e68 23					inc hl 
2e69			 
2e69 d1					pop de 
2e6a eb					ex de, hl 
2e6b 73					ld (hl), e 
2e6c 23					inc hl 
2e6d 72					ld (hl), d 
2e6e					 
2e6e					NEXTW 
2e6e c3 1a 1f			jp macro_next 
2e71				endm 
# End of macro NEXTW
2e71			.SBSTORE: 
2e71				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
2e71 6f				db WORD_SYS_CORE+91             
2e72 87 2e			dw .SBWSTORE            
2e74 04				db 3 + 1 
2e75 .. 00			db "1-!",0              
2e79				endm 
# End of macro CWHEAD
2e79			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
2e79			 
2e79					FORTH_DSP_VALUEHL 
2e79 cd 64 1d			call macro_dsp_valuehl 
2e7c				endm 
# End of macro FORTH_DSP_VALUEHL
2e7c e5					push hl 
2e7d			 
2e7d					FORTH_DSP_POP 
2e7d cd 1c 1e			call macro_forth_dsp_pop 
2e80				endm 
# End of macro FORTH_DSP_POP
2e80 e1					pop hl 
2e81			 
2e81 7e					ld a, (hl) 
2e82 3d					dec a 
2e83 77					ld (hl), a 
2e84					 
2e84					NEXTW 
2e84 c3 1a 1f			jp macro_next 
2e87				endm 
# End of macro NEXTW
2e87			.SBWSTORE: 
2e87				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
2e87 6f				db WORD_SYS_CORE+91             
2e88 a5 2e			dw .ENDCORE            
2e8a 05				db 4 + 1 
2e8b .. 00			db "1-2!",0              
2e90				endm 
# End of macro CWHEAD
2e90			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
2e90			 
2e90					FORTH_DSP_VALUEHL 
2e90 cd 64 1d			call macro_dsp_valuehl 
2e93				endm 
# End of macro FORTH_DSP_VALUEHL
2e93 e5					push hl 
2e94			 
2e94					FORTH_DSP_POP 
2e94 cd 1c 1e			call macro_forth_dsp_pop 
2e97				endm 
# End of macro FORTH_DSP_POP
2e97 e1					pop hl 
2e98			 
2e98 e5					push hl 
2e99			 
2e99 cd 9c 1e				call loadwordinhl 
2e9c 2b					dec hl 
2e9d			 
2e9d d1					pop de 
2e9e eb					ex de, hl 
2e9f 73					ld (hl), e 
2ea0 23					inc hl 
2ea1 72					ld (hl), d 
2ea2					 
2ea2					NEXTW 
2ea2 c3 1a 1f			jp macro_next 
2ea5				endm 
# End of macro NEXTW
2ea5			.ENDCORE: 
2ea5			 
2ea5			; eof 
2ea5			 
2ea5			 
# End of file forth_words_core.asm
2ea5			include "forth_words_flow.asm" 
2ea5			 
2ea5			; | ## Program Flow Words 
2ea5			 
2ea5			.IF: 
2ea5				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2ea5 1e				db WORD_SYS_CORE+10             
2ea6 9a 2f			dw .THEN            
2ea8 03				db 2 + 1 
2ea9 .. 00			db "IF",0              
2eac				endm 
# End of macro CWHEAD
2eac			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2eac			; 
2eac					if DEBUG_FORTH_WORDS_KEY 
2eac						DMARK "IF." 
2eac f5				push af  
2ead 3a c1 2e			ld a, (.dmark)  
2eb0 32 6b ee			ld (debug_mark),a  
2eb3 3a c2 2e			ld a, (.dmark+1)  
2eb6 32 6c ee			ld (debug_mark+1),a  
2eb9 3a c3 2e			ld a, (.dmark+2)  
2ebc 32 6d ee			ld (debug_mark+2),a  
2ebf 18 03			jr .pastdmark  
2ec1 ..			.dmark: db "IF."  
2ec4 f1			.pastdmark: pop af  
2ec5			endm  
# End of macro DMARK
2ec5						CALLMONITOR 
2ec5 cd 6f ee			call debug_vector  
2ec8				endm  
# End of macro CALLMONITOR
2ec8					endif 
2ec8			; eval TOS 
2ec8			 
2ec8				FORTH_DSP_VALUEHL 
2ec8 cd 64 1d			call macro_dsp_valuehl 
2ecb				endm 
# End of macro FORTH_DSP_VALUEHL
2ecb			 
2ecb			;	push hl 
2ecb				FORTH_DSP_POP 
2ecb cd 1c 1e			call macro_forth_dsp_pop 
2ece				endm 
# End of macro FORTH_DSP_POP
2ece			;	pop hl 
2ece			 
2ece					if DEBUG_FORTH_WORDS 
2ece						DMARK "IF1" 
2ece f5				push af  
2ecf 3a e3 2e			ld a, (.dmark)  
2ed2 32 6b ee			ld (debug_mark),a  
2ed5 3a e4 2e			ld a, (.dmark+1)  
2ed8 32 6c ee			ld (debug_mark+1),a  
2edb 3a e5 2e			ld a, (.dmark+2)  
2ede 32 6d ee			ld (debug_mark+2),a  
2ee1 18 03			jr .pastdmark  
2ee3 ..			.dmark: db "IF1"  
2ee6 f1			.pastdmark: pop af  
2ee7			endm  
# End of macro DMARK
2ee7						CALLMONITOR 
2ee7 cd 6f ee			call debug_vector  
2eea				endm  
# End of macro CALLMONITOR
2eea					endif 
2eea b7				or a        ; clear carry flag 
2eeb 11 00 00			ld de, 0 
2eee eb				ex de,hl 
2eef ed 52			sbc hl, de 
2ef1 c2 7b 2f			jp nz, .iftrue 
2ef4			 
2ef4					if DEBUG_FORTH_WORDS 
2ef4						DMARK "IF2" 
2ef4 f5				push af  
2ef5 3a 09 2f			ld a, (.dmark)  
2ef8 32 6b ee			ld (debug_mark),a  
2efb 3a 0a 2f			ld a, (.dmark+1)  
2efe 32 6c ee			ld (debug_mark+1),a  
2f01 3a 0b 2f			ld a, (.dmark+2)  
2f04 32 6d ee			ld (debug_mark+2),a  
2f07 18 03			jr .pastdmark  
2f09 ..			.dmark: db "IF2"  
2f0c f1			.pastdmark: pop af  
2f0d			endm  
# End of macro DMARK
2f0d						CALLMONITOR 
2f0d cd 6f ee			call debug_vector  
2f10				endm  
# End of macro CALLMONITOR
2f10					endif 
2f10			 
2f10			; if not true then skip to THEN 
2f10			 
2f10				; TODO get tok_ptr 
2f10				; TODO consume toks until we get to THEN 
2f10			 
2f10 2a c2 e5			ld hl, (os_tok_ptr) 
2f13					if DEBUG_FORTH_WORDS 
2f13						DMARK "IF3" 
2f13 f5				push af  
2f14 3a 28 2f			ld a, (.dmark)  
2f17 32 6b ee			ld (debug_mark),a  
2f1a 3a 29 2f			ld a, (.dmark+1)  
2f1d 32 6c ee			ld (debug_mark+1),a  
2f20 3a 2a 2f			ld a, (.dmark+2)  
2f23 32 6d ee			ld (debug_mark+2),a  
2f26 18 03			jr .pastdmark  
2f28 ..			.dmark: db "IF3"  
2f2b f1			.pastdmark: pop af  
2f2c			endm  
# End of macro DMARK
2f2c						CALLMONITOR 
2f2c cd 6f ee			call debug_vector  
2f2f				endm  
# End of macro CALLMONITOR
2f2f						 
2f2f					endif 
2f2f 11 76 2f			ld de, .ifthen 
2f32					if DEBUG_FORTH_WORDS 
2f32						DMARK "IF4" 
2f32 f5				push af  
2f33 3a 47 2f			ld a, (.dmark)  
2f36 32 6b ee			ld (debug_mark),a  
2f39 3a 48 2f			ld a, (.dmark+1)  
2f3c 32 6c ee			ld (debug_mark+1),a  
2f3f 3a 49 2f			ld a, (.dmark+2)  
2f42 32 6d ee			ld (debug_mark+2),a  
2f45 18 03			jr .pastdmark  
2f47 ..			.dmark: db "IF4"  
2f4a f1			.pastdmark: pop af  
2f4b			endm  
# End of macro DMARK
2f4b						CALLMONITOR 
2f4b cd 6f ee			call debug_vector  
2f4e				endm  
# End of macro CALLMONITOR
2f4e					endif 
2f4e cd 35 20			call findnexttok  
2f51			 
2f51					if DEBUG_FORTH_WORDS 
2f51						DMARK "IF5" 
2f51 f5				push af  
2f52 3a 66 2f			ld a, (.dmark)  
2f55 32 6b ee			ld (debug_mark),a  
2f58 3a 67 2f			ld a, (.dmark+1)  
2f5b 32 6c ee			ld (debug_mark+1),a  
2f5e 3a 68 2f			ld a, (.dmark+2)  
2f61 32 6d ee			ld (debug_mark+2),a  
2f64 18 03			jr .pastdmark  
2f66 ..			.dmark: db "IF5"  
2f69 f1			.pastdmark: pop af  
2f6a			endm  
# End of macro DMARK
2f6a						CALLMONITOR 
2f6a cd 6f ee			call debug_vector  
2f6d				endm  
# End of macro CALLMONITOR
2f6d					endif 
2f6d				; TODO replace below with ; exec using tok_ptr 
2f6d 22 c2 e5			ld (os_tok_ptr), hl 
2f70 c3 ab 1f			jp exec1 
2f73				NEXTW 
2f73 c3 1a 1f			jp macro_next 
2f76				endm 
# End of macro NEXTW
2f76			 
2f76 .. 00		.ifthen:  db "THEN",0 
2f7b			 
2f7b			.iftrue:		 
2f7b				; Exec next words normally 
2f7b			 
2f7b				; if true then exec following IF as normal 
2f7b					if DEBUG_FORTH_WORDS 
2f7b						DMARK "IFT" 
2f7b f5				push af  
2f7c 3a 90 2f			ld a, (.dmark)  
2f7f 32 6b ee			ld (debug_mark),a  
2f82 3a 91 2f			ld a, (.dmark+1)  
2f85 32 6c ee			ld (debug_mark+1),a  
2f88 3a 92 2f			ld a, (.dmark+2)  
2f8b 32 6d ee			ld (debug_mark+2),a  
2f8e 18 03			jr .pastdmark  
2f90 ..			.dmark: db "IFT"  
2f93 f1			.pastdmark: pop af  
2f94			endm  
# End of macro DMARK
2f94						CALLMONITOR 
2f94 cd 6f ee			call debug_vector  
2f97				endm  
# End of macro CALLMONITOR
2f97					endif 
2f97			 
2f97					NEXTW 
2f97 c3 1a 1f			jp macro_next 
2f9a				endm 
# End of macro NEXTW
2f9a			.THEN: 
2f9a				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2f9a 1f				db WORD_SYS_CORE+11             
2f9b c2 2f			dw .ELSE            
2f9d 05				db 4 + 1 
2f9e .. 00			db "THEN",0              
2fa3				endm 
# End of macro CWHEAD
2fa3			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2fa3					if DEBUG_FORTH_WORDS_KEY 
2fa3						DMARK "THN" 
2fa3 f5				push af  
2fa4 3a b8 2f			ld a, (.dmark)  
2fa7 32 6b ee			ld (debug_mark),a  
2faa 3a b9 2f			ld a, (.dmark+1)  
2fad 32 6c ee			ld (debug_mark+1),a  
2fb0 3a ba 2f			ld a, (.dmark+2)  
2fb3 32 6d ee			ld (debug_mark+2),a  
2fb6 18 03			jr .pastdmark  
2fb8 ..			.dmark: db "THN"  
2fbb f1			.pastdmark: pop af  
2fbc			endm  
# End of macro DMARK
2fbc						CALLMONITOR 
2fbc cd 6f ee			call debug_vector  
2fbf				endm  
# End of macro CALLMONITOR
2fbf					endif 
2fbf					NEXTW 
2fbf c3 1a 1f			jp macro_next 
2fc2				endm 
# End of macro NEXTW
2fc2			.ELSE: 
2fc2				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2fc2 20				db WORD_SYS_CORE+12             
2fc3 ea 2f			dw .DO            
2fc5 03				db 2 + 1 
2fc6 .. 00			db "ELSE",0              
2fcb				endm 
# End of macro CWHEAD
2fcb			; | ELSE ( -- ) Not supported - does nothing | TODO 
2fcb			 
2fcb					if DEBUG_FORTH_WORDS_KEY 
2fcb						DMARK "ELS" 
2fcb f5				push af  
2fcc 3a e0 2f			ld a, (.dmark)  
2fcf 32 6b ee			ld (debug_mark),a  
2fd2 3a e1 2f			ld a, (.dmark+1)  
2fd5 32 6c ee			ld (debug_mark+1),a  
2fd8 3a e2 2f			ld a, (.dmark+2)  
2fdb 32 6d ee			ld (debug_mark+2),a  
2fde 18 03			jr .pastdmark  
2fe0 ..			.dmark: db "ELS"  
2fe3 f1			.pastdmark: pop af  
2fe4			endm  
# End of macro DMARK
2fe4						CALLMONITOR 
2fe4 cd 6f ee			call debug_vector  
2fe7				endm  
# End of macro CALLMONITOR
2fe7					endif 
2fe7			 
2fe7			 
2fe7					NEXTW 
2fe7 c3 1a 1f			jp macro_next 
2fea				endm 
# End of macro NEXTW
2fea			.DO: 
2fea				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2fea 21				db WORD_SYS_CORE+13             
2feb 11 31			dw .LOOP            
2fed 03				db 2 + 1 
2fee .. 00			db "DO",0              
2ff1				endm 
# End of macro CWHEAD
2ff1			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2ff1			 
2ff1					if DEBUG_FORTH_WORDS_KEY 
2ff1						DMARK "DO." 
2ff1 f5				push af  
2ff2 3a 06 30			ld a, (.dmark)  
2ff5 32 6b ee			ld (debug_mark),a  
2ff8 3a 07 30			ld a, (.dmark+1)  
2ffb 32 6c ee			ld (debug_mark+1),a  
2ffe 3a 08 30			ld a, (.dmark+2)  
3001 32 6d ee			ld (debug_mark+2),a  
3004 18 03			jr .pastdmark  
3006 ..			.dmark: db "DO."  
3009 f1			.pastdmark: pop af  
300a			endm  
# End of macro DMARK
300a						CALLMONITOR 
300a cd 6f ee			call debug_vector  
300d				endm  
# End of macro CALLMONITOR
300d					endif 
300d			;  push pc to rsp stack past the DO 
300d			 
300d 2a c2 e5				ld hl, (os_tok_ptr) 
3010 23					inc hl   ; D 
3011 23					inc hl  ; O 
3012 23					inc hl   ; null 
3013					if DEBUG_FORTH_WORDS 
3013						DMARK "DO2" 
3013 f5				push af  
3014 3a 28 30			ld a, (.dmark)  
3017 32 6b ee			ld (debug_mark),a  
301a 3a 29 30			ld a, (.dmark+1)  
301d 32 6c ee			ld (debug_mark+1),a  
3020 3a 2a 30			ld a, (.dmark+2)  
3023 32 6d ee			ld (debug_mark+2),a  
3026 18 03			jr .pastdmark  
3028 ..			.dmark: db "DO2"  
302b f1			.pastdmark: pop af  
302c			endm  
# End of macro DMARK
302c						CALLMONITOR 
302c cd 6f ee			call debug_vector  
302f				endm  
# End of macro CALLMONITOR
302f					endif 
302f					FORTH_RSP_NEXT 
302f cd 14 1b			call macro_forth_rsp_next 
3032				endm 
# End of macro FORTH_RSP_NEXT
3032					if DEBUG_FORTH_WORDS 
3032						DMARK "DO3" 
3032 f5				push af  
3033 3a 47 30			ld a, (.dmark)  
3036 32 6b ee			ld (debug_mark),a  
3039 3a 48 30			ld a, (.dmark+1)  
303c 32 6c ee			ld (debug_mark+1),a  
303f 3a 49 30			ld a, (.dmark+2)  
3042 32 6d ee			ld (debug_mark+2),a  
3045 18 03			jr .pastdmark  
3047 ..			.dmark: db "DO3"  
304a f1			.pastdmark: pop af  
304b			endm  
# End of macro DMARK
304b						CALLMONITOR 
304b cd 6f ee			call debug_vector  
304e				endm  
# End of macro CALLMONITOR
304e					endif 
304e			 
304e					;if DEBUG_FORTH_WORDS 
304e				;		push hl 
304e			;		endif  
304e			 
304e			; get counters from data stack 
304e			 
304e			 
304e					FORTH_DSP_VALUEHL 
304e cd 64 1d			call macro_dsp_valuehl 
3051				endm 
# End of macro FORTH_DSP_VALUEHL
3051 e5					push hl		 ; hl now has starting counter which needs to be tos 
3052			 
3052					if DEBUG_FORTH_WORDS 
3052						DMARK "DO4" 
3052 f5				push af  
3053 3a 67 30			ld a, (.dmark)  
3056 32 6b ee			ld (debug_mark),a  
3059 3a 68 30			ld a, (.dmark+1)  
305c 32 6c ee			ld (debug_mark+1),a  
305f 3a 69 30			ld a, (.dmark+2)  
3062 32 6d ee			ld (debug_mark+2),a  
3065 18 03			jr .pastdmark  
3067 ..			.dmark: db "DO4"  
306a f1			.pastdmark: pop af  
306b			endm  
# End of macro DMARK
306b						CALLMONITOR 
306b cd 6f ee			call debug_vector  
306e				endm  
# End of macro CALLMONITOR
306e					endif 
306e					FORTH_DSP_POP 
306e cd 1c 1e			call macro_forth_dsp_pop 
3071				endm 
# End of macro FORTH_DSP_POP
3071			 
3071					if DEBUG_FORTH_WORDS 
3071						DMARK "DO5" 
3071 f5				push af  
3072 3a 86 30			ld a, (.dmark)  
3075 32 6b ee			ld (debug_mark),a  
3078 3a 87 30			ld a, (.dmark+1)  
307b 32 6c ee			ld (debug_mark+1),a  
307e 3a 88 30			ld a, (.dmark+2)  
3081 32 6d ee			ld (debug_mark+2),a  
3084 18 03			jr .pastdmark  
3086 ..			.dmark: db "DO5"  
3089 f1			.pastdmark: pop af  
308a			endm  
# End of macro DMARK
308a						CALLMONITOR 
308a cd 6f ee			call debug_vector  
308d				endm  
# End of macro CALLMONITOR
308d					endif 
308d			 
308d					FORTH_DSP_VALUEHL 
308d cd 64 1d			call macro_dsp_valuehl 
3090				endm 
# End of macro FORTH_DSP_VALUEHL
3090			;		push hl		 ; hl now has starting limit counter 
3090			 
3090					if DEBUG_FORTH_WORDS 
3090						DMARK "DO6" 
3090 f5				push af  
3091 3a a5 30			ld a, (.dmark)  
3094 32 6b ee			ld (debug_mark),a  
3097 3a a6 30			ld a, (.dmark+1)  
309a 32 6c ee			ld (debug_mark+1),a  
309d 3a a7 30			ld a, (.dmark+2)  
30a0 32 6d ee			ld (debug_mark+2),a  
30a3 18 03			jr .pastdmark  
30a5 ..			.dmark: db "DO6"  
30a8 f1			.pastdmark: pop af  
30a9			endm  
# End of macro DMARK
30a9						CALLMONITOR 
30a9 cd 6f ee			call debug_vector  
30ac				endm  
# End of macro CALLMONITOR
30ac					endif 
30ac					FORTH_DSP_POP 
30ac cd 1c 1e			call macro_forth_dsp_pop 
30af				endm 
# End of macro FORTH_DSP_POP
30af			 
30af			; put counters on the loop stack 
30af			 
30af			;		pop hl			 ; limit counter 
30af d1					pop de			; start counter 
30b0			 
30b0					; push limit counter 
30b0			 
30b0					if DEBUG_FORTH_WORDS 
30b0						DMARK "DO7" 
30b0 f5				push af  
30b1 3a c5 30			ld a, (.dmark)  
30b4 32 6b ee			ld (debug_mark),a  
30b7 3a c6 30			ld a, (.dmark+1)  
30ba 32 6c ee			ld (debug_mark+1),a  
30bd 3a c7 30			ld a, (.dmark+2)  
30c0 32 6d ee			ld (debug_mark+2),a  
30c3 18 03			jr .pastdmark  
30c5 ..			.dmark: db "DO7"  
30c8 f1			.pastdmark: pop af  
30c9			endm  
# End of macro DMARK
30c9						CALLMONITOR 
30c9 cd 6f ee			call debug_vector  
30cc				endm  
# End of macro CALLMONITOR
30cc					endif 
30cc					FORTH_LOOP_NEXT 
30cc cd 95 1d			call macro_forth_loop_next 
30cf				endm 
# End of macro FORTH_LOOP_NEXT
30cf			 
30cf					; push start counter 
30cf			 
30cf eb					ex de, hl 
30d0					if DEBUG_FORTH_WORDS 
30d0						DMARK "DO7" 
30d0 f5				push af  
30d1 3a e5 30			ld a, (.dmark)  
30d4 32 6b ee			ld (debug_mark),a  
30d7 3a e6 30			ld a, (.dmark+1)  
30da 32 6c ee			ld (debug_mark+1),a  
30dd 3a e7 30			ld a, (.dmark+2)  
30e0 32 6d ee			ld (debug_mark+2),a  
30e3 18 03			jr .pastdmark  
30e5 ..			.dmark: db "DO7"  
30e8 f1			.pastdmark: pop af  
30e9			endm  
# End of macro DMARK
30e9						CALLMONITOR 
30e9 cd 6f ee			call debug_vector  
30ec				endm  
# End of macro CALLMONITOR
30ec					endif 
30ec					FORTH_LOOP_NEXT 
30ec cd 95 1d			call macro_forth_loop_next 
30ef				endm 
# End of macro FORTH_LOOP_NEXT
30ef			 
30ef			 
30ef					; init first round of I counter 
30ef			 
30ef 22 e6 e5				ld (os_current_i), hl 
30f2			 
30f2					if DEBUG_FORTH_WORDS 
30f2						DMARK "DO8" 
30f2 f5				push af  
30f3 3a 07 31			ld a, (.dmark)  
30f6 32 6b ee			ld (debug_mark),a  
30f9 3a 08 31			ld a, (.dmark+1)  
30fc 32 6c ee			ld (debug_mark+1),a  
30ff 3a 09 31			ld a, (.dmark+2)  
3102 32 6d ee			ld (debug_mark+2),a  
3105 18 03			jr .pastdmark  
3107 ..			.dmark: db "DO8"  
310a f1			.pastdmark: pop af  
310b			endm  
# End of macro DMARK
310b						CALLMONITOR 
310b cd 6f ee			call debug_vector  
310e				endm  
# End of macro CALLMONITOR
310e					endif 
310e			 
310e					NEXTW 
310e c3 1a 1f			jp macro_next 
3111				endm 
# End of macro NEXTW
3111			.LOOP: 
3111				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3111 22				db WORD_SYS_CORE+14             
3112 29 32			dw .I            
3114 05				db 4 + 1 
3115 .. 00			db "LOOP",0              
311a				endm 
# End of macro CWHEAD
311a			; | LOOP ( -- ) Increment and test loop counter  | DONE 
311a			 
311a				; pop tos as current loop count to hl 
311a			 
311a				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
311a			 
311a				FORTH_LOOP_TOS 
311a cd c8 1d			call macro_forth_loop_tos 
311d				endm 
# End of macro FORTH_LOOP_TOS
311d e5				push hl 
311e			 
311e					if DEBUG_FORTH_WORDS_KEY 
311e						DMARK "LOP" 
311e f5				push af  
311f 3a 33 31			ld a, (.dmark)  
3122 32 6b ee			ld (debug_mark),a  
3125 3a 34 31			ld a, (.dmark+1)  
3128 32 6c ee			ld (debug_mark+1),a  
312b 3a 35 31			ld a, (.dmark+2)  
312e 32 6d ee			ld (debug_mark+2),a  
3131 18 03			jr .pastdmark  
3133 ..			.dmark: db "LOP"  
3136 f1			.pastdmark: pop af  
3137			endm  
# End of macro DMARK
3137						CALLMONITOR 
3137 cd 6f ee			call debug_vector  
313a				endm  
# End of macro CALLMONITOR
313a					endif 
313a				; next item on the stack is the limit. get it 
313a			 
313a			 
313a				FORTH_LOOP_POP 
313a cd d2 1d			call macro_forth_loop_pop 
313d				endm 
# End of macro FORTH_LOOP_POP
313d			 
313d				FORTH_LOOP_TOS 
313d cd c8 1d			call macro_forth_loop_tos 
3140				endm 
# End of macro FORTH_LOOP_TOS
3140			 
3140 d1				pop de		 ; de = i, hl = limit 
3141			 
3141					if DEBUG_FORTH_WORDS 
3141						DMARK "LP1" 
3141 f5				push af  
3142 3a 56 31			ld a, (.dmark)  
3145 32 6b ee			ld (debug_mark),a  
3148 3a 57 31			ld a, (.dmark+1)  
314b 32 6c ee			ld (debug_mark+1),a  
314e 3a 58 31			ld a, (.dmark+2)  
3151 32 6d ee			ld (debug_mark+2),a  
3154 18 03			jr .pastdmark  
3156 ..			.dmark: db "LP1"  
3159 f1			.pastdmark: pop af  
315a			endm  
# End of macro DMARK
315a						CALLMONITOR 
315a cd 6f ee			call debug_vector  
315d				endm  
# End of macro CALLMONITOR
315d					endif 
315d			 
315d				; go back to previous word 
315d			 
315d d5				push de    ; save I for inc later 
315e			 
315e			 
315e				; get limit 
315e				;  is I at limit? 
315e			 
315e			 
315e					if DEBUG_FORTH_WORDS 
315e						DMARK "LP1" 
315e f5				push af  
315f 3a 73 31			ld a, (.dmark)  
3162 32 6b ee			ld (debug_mark),a  
3165 3a 74 31			ld a, (.dmark+1)  
3168 32 6c ee			ld (debug_mark+1),a  
316b 3a 75 31			ld a, (.dmark+2)  
316e 32 6d ee			ld (debug_mark+2),a  
3171 18 03			jr .pastdmark  
3173 ..			.dmark: db "LP1"  
3176 f1			.pastdmark: pop af  
3177			endm  
# End of macro DMARK
3177						CALLMONITOR 
3177 cd 6f ee			call debug_vector  
317a				endm  
# End of macro CALLMONITOR
317a					endif 
317a			 
317a ed 52			sbc hl, de 
317c			 
317c			 
317c				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
317c			 
317c 20 26				jr nz, .loopnotdone 
317e			 
317e e1				pop hl   ; get rid of saved I 
317f				FORTH_LOOP_POP     ; get rid of limit 
317f cd d2 1d			call macro_forth_loop_pop 
3182				endm 
# End of macro FORTH_LOOP_POP
3182			 
3182				FORTH_RSP_POP     ; get rid of DO ptr 
3182 cd 35 1b			call macro_forth_rsp_pop 
3185				endm 
# End of macro FORTH_RSP_POP
3185			 
3185			if DEBUG_FORTH_WORDS 
3185						DMARK "LP>" 
3185 f5				push af  
3186 3a 9a 31			ld a, (.dmark)  
3189 32 6b ee			ld (debug_mark),a  
318c 3a 9b 31			ld a, (.dmark+1)  
318f 32 6c ee			ld (debug_mark+1),a  
3192 3a 9c 31			ld a, (.dmark+2)  
3195 32 6d ee			ld (debug_mark+2),a  
3198 18 03			jr .pastdmark  
319a ..			.dmark: db "LP>"  
319d f1			.pastdmark: pop af  
319e			endm  
# End of macro DMARK
319e				CALLMONITOR 
319e cd 6f ee			call debug_vector  
31a1				endm  
# End of macro CALLMONITOR
31a1			endif 
31a1			 
31a1					NEXTW 
31a1 c3 1a 1f			jp macro_next 
31a4				endm 
# End of macro NEXTW
31a4				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
31a4			 
31a4			.loopnotdone: 
31a4			 
31a4 e1				pop hl    ; get I 
31a5 23				inc hl 
31a6			 
31a6			   	; save new I 
31a6			 
31a6			 
31a6					; set I counter 
31a6			 
31a6 22 e6 e5				ld (os_current_i), hl 
31a9			 
31a9					if DEBUG_FORTH_WORDS 
31a9						DMARK "LPN" 
31a9 f5				push af  
31aa 3a be 31			ld a, (.dmark)  
31ad 32 6b ee			ld (debug_mark),a  
31b0 3a bf 31			ld a, (.dmark+1)  
31b3 32 6c ee			ld (debug_mark+1),a  
31b6 3a c0 31			ld a, (.dmark+2)  
31b9 32 6d ee			ld (debug_mark+2),a  
31bc 18 03			jr .pastdmark  
31be ..			.dmark: db "LPN"  
31c1 f1			.pastdmark: pop af  
31c2			endm  
# End of macro DMARK
31c2					CALLMONITOR 
31c2 cd 6f ee			call debug_vector  
31c5				endm  
# End of macro CALLMONITOR
31c5					endif 
31c5					 
31c5				FORTH_LOOP_NEXT 
31c5 cd 95 1d			call macro_forth_loop_next 
31c8				endm 
# End of macro FORTH_LOOP_NEXT
31c8			 
31c8			 
31c8					if DEBUG_FORTH_WORDS 
31c8 eb						ex de,hl 
31c9					endif 
31c9			 
31c9			;	; get DO ptr 
31c9			; 
31c9					if DEBUG_FORTH_WORDS 
31c9						DMARK "LP7" 
31c9 f5				push af  
31ca 3a de 31			ld a, (.dmark)  
31cd 32 6b ee			ld (debug_mark),a  
31d0 3a df 31			ld a, (.dmark+1)  
31d3 32 6c ee			ld (debug_mark+1),a  
31d6 3a e0 31			ld a, (.dmark+2)  
31d9 32 6d ee			ld (debug_mark+2),a  
31dc 18 03			jr .pastdmark  
31de ..			.dmark: db "LP7"  
31e1 f1			.pastdmark: pop af  
31e2			endm  
# End of macro DMARK
31e2					CALLMONITOR 
31e2 cd 6f ee			call debug_vector  
31e5				endm  
# End of macro CALLMONITOR
31e5					endif 
31e5				FORTH_RSP_TOS 
31e5 cd 2b 1b			call macro_forth_rsp_tos 
31e8				endm 
# End of macro FORTH_RSP_TOS
31e8			 
31e8					if DEBUG_FORTH_WORDS 
31e8						DMARK "LP8" 
31e8 f5				push af  
31e9 3a fd 31			ld a, (.dmark)  
31ec 32 6b ee			ld (debug_mark),a  
31ef 3a fe 31			ld a, (.dmark+1)  
31f2 32 6c ee			ld (debug_mark+1),a  
31f5 3a ff 31			ld a, (.dmark+2)  
31f8 32 6d ee			ld (debug_mark+2),a  
31fb 18 03			jr .pastdmark  
31fd ..			.dmark: db "LP8"  
3200 f1			.pastdmark: pop af  
3201			endm  
# End of macro DMARK
3201					CALLMONITOR 
3201 cd 6f ee			call debug_vector  
3204				endm  
# End of macro CALLMONITOR
3204					endif 
3204				;push hl 
3204			 
3204				; not going to DO any more 
3204				; get rid of the RSP pointer as DO will add it back in 
3204				;FORTH_RSP_POP 
3204				;pop hl 
3204			 
3204				;ld hl,(cli_ret_sp) 
3204				;ld e, (hl) 
3204				;inc hl 
3204				;ld d, (hl) 
3204				;ex de,hl 
3204 22 c2 e5			ld (os_tok_ptr), hl 
3207					if DEBUG_FORTH_WORDS 
3207						DMARK "LP<" 
3207 f5				push af  
3208 3a 1c 32			ld a, (.dmark)  
320b 32 6b ee			ld (debug_mark),a  
320e 3a 1d 32			ld a, (.dmark+1)  
3211 32 6c ee			ld (debug_mark+1),a  
3214 3a 1e 32			ld a, (.dmark+2)  
3217 32 6d ee			ld (debug_mark+2),a  
321a 18 03			jr .pastdmark  
321c ..			.dmark: db "LP<"  
321f f1			.pastdmark: pop af  
3220			endm  
# End of macro DMARK
3220					CALLMONITOR 
3220 cd 6f ee			call debug_vector  
3223				endm  
# End of macro CALLMONITOR
3223				endif 
3223 c3 ab 1f			jp exec1 
3226			 
3226					 
3226			 
3226			 
3226					NEXTW 
3226 c3 1a 1f			jp macro_next 
3229				endm 
# End of macro NEXTW
3229			.I:  
3229			 
3229				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3229 5e				db WORD_SYS_CORE+74             
322a 54 32			dw .DLOOP            
322c 02				db 1 + 1 
322d .. 00			db "I",0              
322f				endm 
# End of macro CWHEAD
322f			; | I ( -- ) Current loop counter | DONE 
322f					if DEBUG_FORTH_WORDS_KEY 
322f						DMARK "I.." 
322f f5				push af  
3230 3a 44 32			ld a, (.dmark)  
3233 32 6b ee			ld (debug_mark),a  
3236 3a 45 32			ld a, (.dmark+1)  
3239 32 6c ee			ld (debug_mark+1),a  
323c 3a 46 32			ld a, (.dmark+2)  
323f 32 6d ee			ld (debug_mark+2),a  
3242 18 03			jr .pastdmark  
3244 ..			.dmark: db "I.."  
3247 f1			.pastdmark: pop af  
3248			endm  
# End of macro DMARK
3248						CALLMONITOR 
3248 cd 6f ee			call debug_vector  
324b				endm  
# End of macro CALLMONITOR
324b					endif 
324b			 
324b 2a e6 e5				ld hl,(os_current_i) 
324e cd 6d 1b				call forth_push_numhl 
3251			 
3251					NEXTW 
3251 c3 1a 1f			jp macro_next 
3254				endm 
# End of macro NEXTW
3254			.DLOOP: 
3254				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3254 5f				db WORD_SYS_CORE+75             
3255 35 33			dw .REPEAT            
3257 06				db 5 + 1 
3258 .. 00			db "-LOOP",0              
325e				endm 
# End of macro CWHEAD
325e			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
325e				; pop tos as current loop count to hl 
325e					if DEBUG_FORTH_WORDS_KEY 
325e						DMARK "-LP" 
325e f5				push af  
325f 3a 73 32			ld a, (.dmark)  
3262 32 6b ee			ld (debug_mark),a  
3265 3a 74 32			ld a, (.dmark+1)  
3268 32 6c ee			ld (debug_mark+1),a  
326b 3a 75 32			ld a, (.dmark+2)  
326e 32 6d ee			ld (debug_mark+2),a  
3271 18 03			jr .pastdmark  
3273 ..			.dmark: db "-LP"  
3276 f1			.pastdmark: pop af  
3277			endm  
# End of macro DMARK
3277						CALLMONITOR 
3277 cd 6f ee			call debug_vector  
327a				endm  
# End of macro CALLMONITOR
327a					endif 
327a			 
327a				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
327a			 
327a				FORTH_LOOP_TOS 
327a cd c8 1d			call macro_forth_loop_tos 
327d				endm 
# End of macro FORTH_LOOP_TOS
327d e5				push hl 
327e			 
327e					if DEBUG_FORTH_WORDS 
327e						DMARK "-LP" 
327e f5				push af  
327f 3a 93 32			ld a, (.dmark)  
3282 32 6b ee			ld (debug_mark),a  
3285 3a 94 32			ld a, (.dmark+1)  
3288 32 6c ee			ld (debug_mark+1),a  
328b 3a 95 32			ld a, (.dmark+2)  
328e 32 6d ee			ld (debug_mark+2),a  
3291 18 03			jr .pastdmark  
3293 ..			.dmark: db "-LP"  
3296 f1			.pastdmark: pop af  
3297			endm  
# End of macro DMARK
3297						CALLMONITOR 
3297 cd 6f ee			call debug_vector  
329a				endm  
# End of macro CALLMONITOR
329a					endif 
329a				; next item on the stack is the limit. get it 
329a			 
329a			 
329a				FORTH_LOOP_POP 
329a cd d2 1d			call macro_forth_loop_pop 
329d				endm 
# End of macro FORTH_LOOP_POP
329d			 
329d				FORTH_LOOP_TOS 
329d cd c8 1d			call macro_forth_loop_tos 
32a0				endm 
# End of macro FORTH_LOOP_TOS
32a0			 
32a0 d1				pop de		 ; de = i, hl = limit 
32a1			 
32a1					if DEBUG_FORTH_WORDS 
32a1						DMARK "-L1" 
32a1 f5				push af  
32a2 3a b6 32			ld a, (.dmark)  
32a5 32 6b ee			ld (debug_mark),a  
32a8 3a b7 32			ld a, (.dmark+1)  
32ab 32 6c ee			ld (debug_mark+1),a  
32ae 3a b8 32			ld a, (.dmark+2)  
32b1 32 6d ee			ld (debug_mark+2),a  
32b4 18 03			jr .pastdmark  
32b6 ..			.dmark: db "-L1"  
32b9 f1			.pastdmark: pop af  
32ba			endm  
# End of macro DMARK
32ba						CALLMONITOR 
32ba cd 6f ee			call debug_vector  
32bd				endm  
# End of macro CALLMONITOR
32bd					endif 
32bd			 
32bd				; go back to previous word 
32bd			 
32bd d5				push de    ; save I for inc later 
32be			 
32be			 
32be				; get limit 
32be				;  is I at limit? 
32be			 
32be			 
32be					if DEBUG_FORTH_WORDS 
32be						DMARK "-L1" 
32be f5				push af  
32bf 3a d3 32			ld a, (.dmark)  
32c2 32 6b ee			ld (debug_mark),a  
32c5 3a d4 32			ld a, (.dmark+1)  
32c8 32 6c ee			ld (debug_mark+1),a  
32cb 3a d5 32			ld a, (.dmark+2)  
32ce 32 6d ee			ld (debug_mark+2),a  
32d1 18 03			jr .pastdmark  
32d3 ..			.dmark: db "-L1"  
32d6 f1			.pastdmark: pop af  
32d7			endm  
# End of macro DMARK
32d7						CALLMONITOR 
32d7 cd 6f ee			call debug_vector  
32da				endm  
# End of macro CALLMONITOR
32da					endif 
32da			 
32da ed 52			sbc hl, de 
32dc			 
32dc			 
32dc				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
32dc			 
32dc 20 26				jr nz, .mloopnotdone 
32de			 
32de e1				pop hl   ; get rid of saved I 
32df				FORTH_LOOP_POP     ; get rid of limit 
32df cd d2 1d			call macro_forth_loop_pop 
32e2				endm 
# End of macro FORTH_LOOP_POP
32e2			 
32e2				FORTH_RSP_POP     ; get rid of DO ptr 
32e2 cd 35 1b			call macro_forth_rsp_pop 
32e5				endm 
# End of macro FORTH_RSP_POP
32e5			 
32e5			if DEBUG_FORTH_WORDS 
32e5						DMARK "-L>" 
32e5 f5				push af  
32e6 3a fa 32			ld a, (.dmark)  
32e9 32 6b ee			ld (debug_mark),a  
32ec 3a fb 32			ld a, (.dmark+1)  
32ef 32 6c ee			ld (debug_mark+1),a  
32f2 3a fc 32			ld a, (.dmark+2)  
32f5 32 6d ee			ld (debug_mark+2),a  
32f8 18 03			jr .pastdmark  
32fa ..			.dmark: db "-L>"  
32fd f1			.pastdmark: pop af  
32fe			endm  
# End of macro DMARK
32fe				CALLMONITOR 
32fe cd 6f ee			call debug_vector  
3301				endm  
# End of macro CALLMONITOR
3301			endif 
3301			 
3301					NEXTW 
3301 c3 1a 1f			jp macro_next 
3304				endm 
# End of macro NEXTW
3304				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3304			 
3304			.mloopnotdone: 
3304			 
3304 e1				pop hl    ; get I 
3305 2b				dec hl 
3306			 
3306			   	; save new I 
3306			 
3306			 
3306					; set I counter 
3306			 
3306 22 e6 e5				ld (os_current_i), hl 
3309			 
3309					 
3309				FORTH_LOOP_NEXT 
3309 cd 95 1d			call macro_forth_loop_next 
330c				endm 
# End of macro FORTH_LOOP_NEXT
330c			 
330c			 
330c					if DEBUG_FORTH_WORDS 
330c eb						ex de,hl 
330d					endif 
330d			 
330d			;	; get DO ptr 
330d			; 
330d				FORTH_RSP_TOS 
330d cd 2b 1b			call macro_forth_rsp_tos 
3310				endm 
# End of macro FORTH_RSP_TOS
3310			 
3310				;push hl 
3310			 
3310				; not going to DO any more 
3310				; get rid of the RSP pointer as DO will add it back in 
3310				;FORTH_RSP_POP 
3310				;pop hl 
3310			 
3310			 
3310 22 c2 e5			ld (os_tok_ptr), hl 
3313					if DEBUG_FORTH_WORDS 
3313						DMARK "-L<" 
3313 f5				push af  
3314 3a 28 33			ld a, (.dmark)  
3317 32 6b ee			ld (debug_mark),a  
331a 3a 29 33			ld a, (.dmark+1)  
331d 32 6c ee			ld (debug_mark+1),a  
3320 3a 2a 33			ld a, (.dmark+2)  
3323 32 6d ee			ld (debug_mark+2),a  
3326 18 03			jr .pastdmark  
3328 ..			.dmark: db "-L<"  
332b f1			.pastdmark: pop af  
332c			endm  
# End of macro DMARK
332c					CALLMONITOR 
332c cd 6f ee			call debug_vector  
332f				endm  
# End of macro CALLMONITOR
332f				endif 
332f c3 ab 1f			jp exec1 
3332			 
3332					 
3332			 
3332			 
3332			 
3332				NEXTW 
3332 c3 1a 1f			jp macro_next 
3335				endm 
# End of macro NEXTW
3335			 
3335			 
3335			 
3335			 
3335			.REPEAT: 
3335				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3335 71				db WORD_SYS_CORE+93             
3336 88 33			dw .UNTIL            
3338 06				db 5 + 1 
3339 .. 00			db "REPEAT",0              
3340				endm 
# End of macro CWHEAD
3340			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3340			;  push pc to rsp stack past the REPEAT 
3340					if DEBUG_FORTH_WORDS_KEY 
3340						DMARK "REP" 
3340 f5				push af  
3341 3a 55 33			ld a, (.dmark)  
3344 32 6b ee			ld (debug_mark),a  
3347 3a 56 33			ld a, (.dmark+1)  
334a 32 6c ee			ld (debug_mark+1),a  
334d 3a 57 33			ld a, (.dmark+2)  
3350 32 6d ee			ld (debug_mark+2),a  
3353 18 03			jr .pastdmark  
3355 ..			.dmark: db "REP"  
3358 f1			.pastdmark: pop af  
3359			endm  
# End of macro DMARK
3359						CALLMONITOR 
3359 cd 6f ee			call debug_vector  
335c				endm  
# End of macro CALLMONITOR
335c					endif 
335c			 
335c 2a c2 e5				ld hl, (os_tok_ptr) 
335f 23					inc hl   ; R 
3360 23					inc hl  ; E 
3361 23					inc hl   ; P 
3362 23					inc hl   ; E 
3363 23					inc hl   ; A 
3364 23					inc hl   ; T 
3365 23					inc hl   ; zero 
3366					FORTH_RSP_NEXT 
3366 cd 14 1b			call macro_forth_rsp_next 
3369				endm 
# End of macro FORTH_RSP_NEXT
3369			 
3369			 
3369					if DEBUG_FORTH_WORDS 
3369						DMARK "REP" 
3369 f5				push af  
336a 3a 7e 33			ld a, (.dmark)  
336d 32 6b ee			ld (debug_mark),a  
3370 3a 7f 33			ld a, (.dmark+1)  
3373 32 6c ee			ld (debug_mark+1),a  
3376 3a 80 33			ld a, (.dmark+2)  
3379 32 6d ee			ld (debug_mark+2),a  
337c 18 03			jr .pastdmark  
337e ..			.dmark: db "REP"  
3381 f1			.pastdmark: pop af  
3382			endm  
# End of macro DMARK
3382						;pop bc    ; TODO BUG ?????? what is this for???? 
3382						CALLMONITOR 
3382 cd 6f ee			call debug_vector  
3385				endm  
# End of macro CALLMONITOR
3385					endif 
3385			 
3385					NEXTW 
3385 c3 1a 1f			jp macro_next 
3388				endm 
# End of macro NEXTW
3388			;	       NEXTW 
3388			 
3388			.UNTIL: 
3388				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3388 72				db WORD_SYS_CORE+94             
3389 1f 34			dw .ENDFLOW            
338b 06				db 5 + 1 
338c .. 00			db "UNTIL",0              
3392				endm 
# End of macro CWHEAD
3392			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3392			 
3392				; pop tos as check 
3392			 
3392				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3392			 
3392				FORTH_DSP_VALUEHL 
3392 cd 64 1d			call macro_dsp_valuehl 
3395				endm 
# End of macro FORTH_DSP_VALUEHL
3395			 
3395					if DEBUG_FORTH_WORDS_KEY 
3395						DMARK "UNT" 
3395 f5				push af  
3396 3a aa 33			ld a, (.dmark)  
3399 32 6b ee			ld (debug_mark),a  
339c 3a ab 33			ld a, (.dmark+1)  
339f 32 6c ee			ld (debug_mark+1),a  
33a2 3a ac 33			ld a, (.dmark+2)  
33a5 32 6d ee			ld (debug_mark+2),a  
33a8 18 03			jr .pastdmark  
33aa ..			.dmark: db "UNT"  
33ad f1			.pastdmark: pop af  
33ae			endm  
# End of macro DMARK
33ae						CALLMONITOR 
33ae cd 6f ee			call debug_vector  
33b1				endm  
# End of macro CALLMONITOR
33b1					endif 
33b1			 
33b1			;	push hl 
33b1				FORTH_DSP_POP 
33b1 cd 1c 1e			call macro_forth_dsp_pop 
33b4				endm 
# End of macro FORTH_DSP_POP
33b4			 
33b4			;	pop hl 
33b4			 
33b4				; test if true 
33b4			 
33b4 cd 0f 0e			call ishlzero 
33b7			;	ld a,l 
33b7			;	add h 
33b7			; 
33b7			;	cp 0 
33b7			 
33b7 20 3e			jr nz, .untilnotdone 
33b9			 
33b9					if DEBUG_FORTH_WORDS 
33b9						DMARK "UNf" 
33b9 f5				push af  
33ba 3a ce 33			ld a, (.dmark)  
33bd 32 6b ee			ld (debug_mark),a  
33c0 3a cf 33			ld a, (.dmark+1)  
33c3 32 6c ee			ld (debug_mark+1),a  
33c6 3a d0 33			ld a, (.dmark+2)  
33c9 32 6d ee			ld (debug_mark+2),a  
33cc 18 03			jr .pastdmark  
33ce ..			.dmark: db "UNf"  
33d1 f1			.pastdmark: pop af  
33d2			endm  
# End of macro DMARK
33d2						CALLMONITOR 
33d2 cd 6f ee			call debug_vector  
33d5				endm  
# End of macro CALLMONITOR
33d5					endif 
33d5			 
33d5			 
33d5			 
33d5				FORTH_RSP_POP     ; get rid of DO ptr 
33d5 cd 35 1b			call macro_forth_rsp_pop 
33d8				endm 
# End of macro FORTH_RSP_POP
33d8			 
33d8			if DEBUG_FORTH_WORDS 
33d8						DMARK "UN>" 
33d8 f5				push af  
33d9 3a ed 33			ld a, (.dmark)  
33dc 32 6b ee			ld (debug_mark),a  
33df 3a ee 33			ld a, (.dmark+1)  
33e2 32 6c ee			ld (debug_mark+1),a  
33e5 3a ef 33			ld a, (.dmark+2)  
33e8 32 6d ee			ld (debug_mark+2),a  
33eb 18 03			jr .pastdmark  
33ed ..			.dmark: db "UN>"  
33f0 f1			.pastdmark: pop af  
33f1			endm  
# End of macro DMARK
33f1				CALLMONITOR 
33f1 cd 6f ee			call debug_vector  
33f4				endm  
# End of macro CALLMONITOR
33f4			endif 
33f4			 
33f4					NEXTW 
33f4 c3 1a 1f			jp macro_next 
33f7				endm 
# End of macro NEXTW
33f7				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
33f7			 
33f7			.untilnotdone: 
33f7			 
33f7			 
33f7			;	; get DO ptr 
33f7			; 
33f7				FORTH_RSP_TOS 
33f7 cd 2b 1b			call macro_forth_rsp_tos 
33fa				endm 
# End of macro FORTH_RSP_TOS
33fa			 
33fa				;push hl 
33fa			 
33fa				; not going to DO any more 
33fa				; get rid of the RSP pointer as DO will add it back in 
33fa				;FORTH_RSP_POP 
33fa				;pop hl 
33fa			 
33fa			 
33fa 22 c2 e5			ld (os_tok_ptr), hl 
33fd					if DEBUG_FORTH_WORDS 
33fd						DMARK "UN<" 
33fd f5				push af  
33fe 3a 12 34			ld a, (.dmark)  
3401 32 6b ee			ld (debug_mark),a  
3404 3a 13 34			ld a, (.dmark+1)  
3407 32 6c ee			ld (debug_mark+1),a  
340a 3a 14 34			ld a, (.dmark+2)  
340d 32 6d ee			ld (debug_mark+2),a  
3410 18 03			jr .pastdmark  
3412 ..			.dmark: db "UN<"  
3415 f1			.pastdmark: pop af  
3416			endm  
# End of macro DMARK
3416					CALLMONITOR 
3416 cd 6f ee			call debug_vector  
3419				endm  
# End of macro CALLMONITOR
3419				endif 
3419 c3 ab 1f			jp exec1 
341c			 
341c					 
341c			 
341c			 
341c					NEXTW 
341c c3 1a 1f			jp macro_next 
341f				endm 
# End of macro NEXTW
341f			 
341f			 
341f			.ENDFLOW: 
341f			 
341f			; eof 
341f			 
# End of file forth_words_flow.asm
341f			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
341f			include "forth_words_logic.asm" 
341f			 
341f			; | ## Logic Words 
341f			 
341f			.NOT: 
341f				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
341f 2d				db WORD_SYS_CORE+25             
3420 67 34			dw .IS            
3422 04				db 3 + 1 
3423 .. 00			db "NOT",0              
3427				endm 
# End of macro CWHEAD
3427			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3427					if DEBUG_FORTH_WORDS_KEY 
3427						DMARK "NOT" 
3427 f5				push af  
3428 3a 3c 34			ld a, (.dmark)  
342b 32 6b ee			ld (debug_mark),a  
342e 3a 3d 34			ld a, (.dmark+1)  
3431 32 6c ee			ld (debug_mark+1),a  
3434 3a 3e 34			ld a, (.dmark+2)  
3437 32 6d ee			ld (debug_mark+2),a  
343a 18 03			jr .pastdmark  
343c ..			.dmark: db "NOT"  
343f f1			.pastdmark: pop af  
3440			endm  
# End of macro DMARK
3440						CALLMONITOR 
3440 cd 6f ee			call debug_vector  
3443				endm  
# End of macro CALLMONITOR
3443					endif 
3443					FORTH_DSP 
3443 cd 2a 1d			call macro_forth_dsp 
3446				endm 
# End of macro FORTH_DSP
3446 7e					ld a,(hl)	; get type of value on TOS 
3447 fe 02				cp DS_TYPE_INUM  
3449 28 03				jr z, .noti 
344b					NEXTW 
344b c3 1a 1f			jp macro_next 
344e				endm 
# End of macro NEXTW
344e			.noti:          FORTH_DSP_VALUEHL 
344e cd 64 1d			call macro_dsp_valuehl 
3451				endm 
# End of macro FORTH_DSP_VALUEHL
3451			;		push hl 
3451					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3451 cd 1c 1e			call macro_forth_dsp_pop 
3454				endm 
# End of macro FORTH_DSP_POP
3454			;		pop hl 
3454 3e 00				ld a,0 
3456 bd					cp l 
3457 28 04				jr z, .not2t 
3459 2e 00				ld l, 0 
345b 18 02				jr .notip 
345d			 
345d 2e ff		.not2t:		ld l, 255 
345f			 
345f 26 00		.notip:		ld h, 0	 
3461			 
3461 cd 6d 1b				call forth_push_numhl 
3464					NEXTW 
3464 c3 1a 1f			jp macro_next 
3467				endm 
# End of macro NEXTW
3467			 
3467			.IS: 
3467				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3467 2d				db WORD_SYS_CORE+25             
3468 8d 34			dw .LZERO            
346a 03				db 2 + 1 
346b .. 00			db "IS",0              
346e				endm 
# End of macro CWHEAD
346e			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
346e					if DEBUG_FORTH_WORDS_KEY 
346e						DMARK "IS." 
346e f5				push af  
346f 3a 83 34			ld a, (.dmark)  
3472 32 6b ee			ld (debug_mark),a  
3475 3a 84 34			ld a, (.dmark+1)  
3478 32 6c ee			ld (debug_mark+1),a  
347b 3a 85 34			ld a, (.dmark+2)  
347e 32 6d ee			ld (debug_mark+2),a  
3481 18 03			jr .pastdmark  
3483 ..			.dmark: db "IS."  
3486 f1			.pastdmark: pop af  
3487			endm  
# End of macro DMARK
3487						CALLMONITOR 
3487 cd 6f ee			call debug_vector  
348a				endm  
# End of macro CALLMONITOR
348a					endif 
348a					NEXTW 
348a c3 1a 1f			jp macro_next 
348d				endm 
# End of macro NEXTW
348d			.LZERO: 
348d				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
348d 2d				db WORD_SYS_CORE+25             
348e 97 34			dw .TZERO            
3490 03				db 2 + 1 
3491 .. 00			db "0<",0              
3494				endm 
# End of macro CWHEAD
3494			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3494					NEXTW 
3494 c3 1a 1f			jp macro_next 
3497				endm 
# End of macro NEXTW
3497			.TZERO: 
3497				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3497 2e				db WORD_SYS_CORE+26             
3498 de 34			dw .LESS            
349a 03				db 2 + 1 
349b .. 00			db "0=",0              
349e				endm 
# End of macro CWHEAD
349e			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
349e				; TODO add floating point number detection 
349e					;v5 FORTH_DSP_VALUE 
349e					if DEBUG_FORTH_WORDS_KEY 
349e						DMARK "0=." 
349e f5				push af  
349f 3a b3 34			ld a, (.dmark)  
34a2 32 6b ee			ld (debug_mark),a  
34a5 3a b4 34			ld a, (.dmark+1)  
34a8 32 6c ee			ld (debug_mark+1),a  
34ab 3a b5 34			ld a, (.dmark+2)  
34ae 32 6d ee			ld (debug_mark+2),a  
34b1 18 03			jr .pastdmark  
34b3 ..			.dmark: db "0=."  
34b6 f1			.pastdmark: pop af  
34b7			endm  
# End of macro DMARK
34b7						CALLMONITOR 
34b7 cd 6f ee			call debug_vector  
34ba				endm  
# End of macro CALLMONITOR
34ba					endif 
34ba					FORTH_DSP 
34ba cd 2a 1d			call macro_forth_dsp 
34bd				endm 
# End of macro FORTH_DSP
34bd 7e					ld a,(hl)	; get type of value on TOS 
34be fe 02				cp DS_TYPE_INUM  
34c0 28 00				jr z, .tz_inum 
34c2			 
34c2				if FORTH_ENABLE_FLOATMATH 
34c2					jr .tz_done 
34c2			 
34c2				endif 
34c2					 
34c2			 
34c2			.tz_inum: 
34c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34c2 cd 64 1d			call macro_dsp_valuehl 
34c5				endm 
# End of macro FORTH_DSP_VALUEHL
34c5			 
34c5			;		push hl 
34c5			 
34c5					; destroy value TOS 
34c5			 
34c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34c5 cd 1c 1e			call macro_forth_dsp_pop 
34c8				endm 
# End of macro FORTH_DSP_POP
34c8			 
34c8			;		pop hl 
34c8			 
34c8 3e 00				ld a,0 
34ca			 
34ca bd					cp l 
34cb 20 08				jr nz, .tz_notzero 
34cd			 
34cd bc					cp h 
34ce			 
34ce 20 05				jr nz, .tz_notzero 
34d0			 
34d0			 
34d0 21 01 00				ld hl, FORTH_TRUE 
34d3 18 03				jr .tz_done 
34d5			 
34d5 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
34d8			 
34d8					; push value back onto stack for another op etc 
34d8			 
34d8			.tz_done: 
34d8 cd 6d 1b				call forth_push_numhl 
34db			 
34db					NEXTW 
34db c3 1a 1f			jp macro_next 
34de				endm 
# End of macro NEXTW
34de			.LESS: 
34de				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
34de 2f				db WORD_SYS_CORE+27             
34df 47 35			dw .GT            
34e1 02				db 1 + 1 
34e2 .. 00			db "<",0              
34e4				endm 
# End of macro CWHEAD
34e4			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
34e4				; TODO add floating point number detection 
34e4					if DEBUG_FORTH_WORDS_KEY 
34e4						DMARK "LES" 
34e4 f5				push af  
34e5 3a f9 34			ld a, (.dmark)  
34e8 32 6b ee			ld (debug_mark),a  
34eb 3a fa 34			ld a, (.dmark+1)  
34ee 32 6c ee			ld (debug_mark+1),a  
34f1 3a fb 34			ld a, (.dmark+2)  
34f4 32 6d ee			ld (debug_mark+2),a  
34f7 18 03			jr .pastdmark  
34f9 ..			.dmark: db "LES"  
34fc f1			.pastdmark: pop af  
34fd			endm  
# End of macro DMARK
34fd						CALLMONITOR 
34fd cd 6f ee			call debug_vector  
3500				endm  
# End of macro CALLMONITOR
3500					endif 
3500					FORTH_DSP 
3500 cd 2a 1d			call macro_forth_dsp 
3503				endm 
# End of macro FORTH_DSP
3503					;v5 FORTH_DSP_VALUE 
3503 7e					ld a,(hl)	; get type of value on TOS 
3504 fe 02				cp DS_TYPE_INUM  
3506 28 00				jr z, .less_inum 
3508			 
3508				if FORTH_ENABLE_FLOATMATH 
3508					jr .less_done 
3508			 
3508				endif 
3508					 
3508			 
3508			.less_inum: 
3508					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3508 cd 64 1d			call macro_dsp_valuehl 
350b				endm 
# End of macro FORTH_DSP_VALUEHL
350b			 
350b e5					push hl  ; u2 
350c			 
350c					; destroy value TOS 
350c			 
350c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
350c cd 1c 1e			call macro_forth_dsp_pop 
350f				endm 
# End of macro FORTH_DSP_POP
350f			 
350f			 
350f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
350f cd 64 1d			call macro_dsp_valuehl 
3512				endm 
# End of macro FORTH_DSP_VALUEHL
3512			 
3512 e5					push hl    ; u1 
3513			 
3513					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3513 cd 1c 1e			call macro_forth_dsp_pop 
3516				endm 
# End of macro FORTH_DSP_POP
3516			 
3516			 
3516 b7			 or a      ;clear carry flag 
3517 01 00 00		 ld bc, FORTH_FALSE 
351a e1			  pop hl    ; u1 
351b d1			  pop de    ; u2 
351c ed 52		  sbc hl,de 
351e 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3520			 
3520 01 01 00		 ld bc, FORTH_TRUE 
3523			.lscont:  
3523 c5					push bc 
3524 e1					pop hl 
3525			 
3525					if DEBUG_FORTH_WORDS 
3525						DMARK "LT1" 
3525 f5				push af  
3526 3a 3a 35			ld a, (.dmark)  
3529 32 6b ee			ld (debug_mark),a  
352c 3a 3b 35			ld a, (.dmark+1)  
352f 32 6c ee			ld (debug_mark+1),a  
3532 3a 3c 35			ld a, (.dmark+2)  
3535 32 6d ee			ld (debug_mark+2),a  
3538 18 03			jr .pastdmark  
353a ..			.dmark: db "LT1"  
353d f1			.pastdmark: pop af  
353e			endm  
# End of macro DMARK
353e						CALLMONITOR 
353e cd 6f ee			call debug_vector  
3541				endm  
# End of macro CALLMONITOR
3541					endif 
3541 cd 6d 1b				call forth_push_numhl 
3544			 
3544					NEXTW 
3544 c3 1a 1f			jp macro_next 
3547				endm 
# End of macro NEXTW
3547			.GT: 
3547				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3547 30				db WORD_SYS_CORE+28             
3548 b0 35			dw .EQUAL            
354a 02				db 1 + 1 
354b .. 00			db ">",0              
354d				endm 
# End of macro CWHEAD
354d			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
354d				; TODO add floating point number detection 
354d					if DEBUG_FORTH_WORDS_KEY 
354d						DMARK "GRT" 
354d f5				push af  
354e 3a 62 35			ld a, (.dmark)  
3551 32 6b ee			ld (debug_mark),a  
3554 3a 63 35			ld a, (.dmark+1)  
3557 32 6c ee			ld (debug_mark+1),a  
355a 3a 64 35			ld a, (.dmark+2)  
355d 32 6d ee			ld (debug_mark+2),a  
3560 18 03			jr .pastdmark  
3562 ..			.dmark: db "GRT"  
3565 f1			.pastdmark: pop af  
3566			endm  
# End of macro DMARK
3566						CALLMONITOR 
3566 cd 6f ee			call debug_vector  
3569				endm  
# End of macro CALLMONITOR
3569					endif 
3569					FORTH_DSP 
3569 cd 2a 1d			call macro_forth_dsp 
356c				endm 
# End of macro FORTH_DSP
356c					;FORTH_DSP_VALUE 
356c 7e					ld a,(hl)	; get type of value on TOS 
356d fe 02				cp DS_TYPE_INUM  
356f 28 00				jr z, .gt_inum 
3571			 
3571				if FORTH_ENABLE_FLOATMATH 
3571					jr .gt_done 
3571			 
3571				endif 
3571					 
3571			 
3571			.gt_inum: 
3571					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3571 cd 64 1d			call macro_dsp_valuehl 
3574				endm 
# End of macro FORTH_DSP_VALUEHL
3574			 
3574 e5					push hl  ; u2 
3575			 
3575					; destroy value TOS 
3575			 
3575					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3575 cd 1c 1e			call macro_forth_dsp_pop 
3578				endm 
# End of macro FORTH_DSP_POP
3578			 
3578			 
3578					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3578 cd 64 1d			call macro_dsp_valuehl 
357b				endm 
# End of macro FORTH_DSP_VALUEHL
357b			 
357b e5					push hl    ; u1 
357c			 
357c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
357c cd 1c 1e			call macro_forth_dsp_pop 
357f				endm 
# End of macro FORTH_DSP_POP
357f			 
357f			 
357f b7			 or a      ;clear carry flag 
3580 01 00 00		 ld bc, FORTH_FALSE 
3583 e1			  pop hl    ; u1 
3584 d1			  pop de    ; u2 
3585 ed 52		  sbc hl,de 
3587 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3589			 
3589 01 01 00		 ld bc, FORTH_TRUE 
358c			.gtcont:  
358c c5					push bc 
358d e1					pop hl 
358e			 
358e					if DEBUG_FORTH_WORDS 
358e						DMARK "GT1" 
358e f5				push af  
358f 3a a3 35			ld a, (.dmark)  
3592 32 6b ee			ld (debug_mark),a  
3595 3a a4 35			ld a, (.dmark+1)  
3598 32 6c ee			ld (debug_mark+1),a  
359b 3a a5 35			ld a, (.dmark+2)  
359e 32 6d ee			ld (debug_mark+2),a  
35a1 18 03			jr .pastdmark  
35a3 ..			.dmark: db "GT1"  
35a6 f1			.pastdmark: pop af  
35a7			endm  
# End of macro DMARK
35a7						CALLMONITOR 
35a7 cd 6f ee			call debug_vector  
35aa				endm  
# End of macro CALLMONITOR
35aa					endif 
35aa cd 6d 1b				call forth_push_numhl 
35ad			 
35ad					NEXTW 
35ad c3 1a 1f			jp macro_next 
35b0				endm 
# End of macro NEXTW
35b0			.EQUAL: 
35b0				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
35b0 31				db WORD_SYS_CORE+29             
35b1 1b 36			dw .ENDLOGIC            
35b3 02				db 1 + 1 
35b4 .. 00			db "=",0              
35b6				endm 
# End of macro CWHEAD
35b6			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
35b6				; TODO add floating point number detection 
35b6					if DEBUG_FORTH_WORDS_KEY 
35b6						DMARK "EQ." 
35b6 f5				push af  
35b7 3a cb 35			ld a, (.dmark)  
35ba 32 6b ee			ld (debug_mark),a  
35bd 3a cc 35			ld a, (.dmark+1)  
35c0 32 6c ee			ld (debug_mark+1),a  
35c3 3a cd 35			ld a, (.dmark+2)  
35c6 32 6d ee			ld (debug_mark+2),a  
35c9 18 03			jr .pastdmark  
35cb ..			.dmark: db "EQ."  
35ce f1			.pastdmark: pop af  
35cf			endm  
# End of macro DMARK
35cf						CALLMONITOR 
35cf cd 6f ee			call debug_vector  
35d2				endm  
# End of macro CALLMONITOR
35d2					endif 
35d2					FORTH_DSP 
35d2 cd 2a 1d			call macro_forth_dsp 
35d5				endm 
# End of macro FORTH_DSP
35d5					;v5 FORTH_DSP_VALUE 
35d5 7e					ld a,(hl)	; get type of value on TOS 
35d6 fe 02				cp DS_TYPE_INUM  
35d8 28 00				jr z, .eq_inum 
35da			 
35da				if FORTH_ENABLE_FLOATMATH 
35da					jr .eq_done 
35da			 
35da				endif 
35da					 
35da			 
35da			.eq_inum: 
35da					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35da cd 64 1d			call macro_dsp_valuehl 
35dd				endm 
# End of macro FORTH_DSP_VALUEHL
35dd			 
35dd e5					push hl 
35de			 
35de					; destroy value TOS 
35de			 
35de					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35de cd 1c 1e			call macro_forth_dsp_pop 
35e1				endm 
# End of macro FORTH_DSP_POP
35e1			 
35e1			 
35e1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35e1 cd 64 1d			call macro_dsp_valuehl 
35e4				endm 
# End of macro FORTH_DSP_VALUEHL
35e4			 
35e4					; one value on hl get other one back 
35e4			 
35e4 e5					push hl 
35e5			 
35e5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35e5 cd 1c 1e			call macro_forth_dsp_pop 
35e8				endm 
# End of macro FORTH_DSP_POP
35e8			 
35e8 0e 00				ld c, FORTH_FALSE 
35ea			 
35ea e1					pop hl 
35eb d1					pop de 
35ec			 
35ec 7b					ld a, e 
35ed bd					cp l 
35ee			 
35ee 20 06				jr nz, .eq_done 
35f0			 
35f0 7a					ld a, d 
35f1 bc					cp h 
35f2			 
35f2 20 02				jr nz, .eq_done 
35f4			 
35f4 0e 01				ld c, FORTH_TRUE 
35f6					 
35f6			 
35f6			 
35f6			.eq_done: 
35f6			 
35f6					; TODO push value back onto stack for another op etc 
35f6			 
35f6 26 00				ld h, 0 
35f8 69					ld l, c 
35f9					if DEBUG_FORTH_WORDS 
35f9						DMARK "EQ1" 
35f9 f5				push af  
35fa 3a 0e 36			ld a, (.dmark)  
35fd 32 6b ee			ld (debug_mark),a  
3600 3a 0f 36			ld a, (.dmark+1)  
3603 32 6c ee			ld (debug_mark+1),a  
3606 3a 10 36			ld a, (.dmark+2)  
3609 32 6d ee			ld (debug_mark+2),a  
360c 18 03			jr .pastdmark  
360e ..			.dmark: db "EQ1"  
3611 f1			.pastdmark: pop af  
3612			endm  
# End of macro DMARK
3612						CALLMONITOR 
3612 cd 6f ee			call debug_vector  
3615				endm  
# End of macro CALLMONITOR
3615					endif 
3615 cd 6d 1b				call forth_push_numhl 
3618			 
3618					NEXTW 
3618 c3 1a 1f			jp macro_next 
361b				endm 
# End of macro NEXTW
361b			 
361b			 
361b			.ENDLOGIC: 
361b			; eof 
361b			 
361b			 
# End of file forth_words_logic.asm
361b			include "forth_words_maths.asm" 
361b			 
361b			; | ## Maths Words 
361b			 
361b			.PLUS:	 
361b				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
361b 15				db WORD_SYS_CORE+1             
361c 79 36			dw .NEG            
361e 02				db 1 + 1 
361f .. 00			db "+",0              
3621				endm 
# End of macro CWHEAD
3621			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3621					if DEBUG_FORTH_WORDS_KEY 
3621						DMARK "PLU" 
3621 f5				push af  
3622 3a 36 36			ld a, (.dmark)  
3625 32 6b ee			ld (debug_mark),a  
3628 3a 37 36			ld a, (.dmark+1)  
362b 32 6c ee			ld (debug_mark+1),a  
362e 3a 38 36			ld a, (.dmark+2)  
3631 32 6d ee			ld (debug_mark+2),a  
3634 18 03			jr .pastdmark  
3636 ..			.dmark: db "PLU"  
3639 f1			.pastdmark: pop af  
363a			endm  
# End of macro DMARK
363a						CALLMONITOR 
363a cd 6f ee			call debug_vector  
363d				endm  
# End of macro CALLMONITOR
363d					endif 
363d					; add top two values and push back result 
363d			 
363d					;for v5 FORTH_DSP_VALUE 
363d					FORTH_DSP 
363d cd 2a 1d			call macro_forth_dsp 
3640				endm 
# End of macro FORTH_DSP
3640 7e					ld a,(hl)	; get type of value on TOS 
3641 fe 02				cp DS_TYPE_INUM  
3643 28 03				jr z, .dot_inum 
3645			 
3645					NEXTW 
3645 c3 1a 1f			jp macro_next 
3648				endm 
# End of macro NEXTW
3648			 
3648			; float maths 
3648			 
3648				if FORTH_ENABLE_FLOATMATH 
3648						inc hl      ; now at start of numeric as string 
3648			 
3648					if DEBUG_FORTH_MATHS 
3648						DMARK "ADD" 
3648				CALLMONITOR 
3648					endif 
3648			 
3648					;ld ix, hl 
3648					call CON 
3648			 
3648			 
3648					push hl 
3648					 
3648					 
3648			 
3648						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3648			 
3648					; get next number 
3648			 
3648						FORTH_DSP_VALUE 
3648			 
3648						inc hl      ; now at start of numeric as string 
3648			 
3648					;ld ix, hl 
3648					call CON 
3648			 
3648					push hl 
3648			 
3648			 
3648						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3648			 
3648						; TODO do add 
3648			 
3648						call IADD 
3648			 
3648						; TODO get result back as ascii 
3648			 
3648						; TODO push result  
3648			 
3648			 
3648			 
3648						jr .dot_done 
3648				endif 
3648			 
3648			.dot_inum: 
3648			 
3648			 
3648					if DEBUG_FORTH_DOT 
3648						DMARK "+IT" 
3648 f5				push af  
3649 3a 5d 36			ld a, (.dmark)  
364c 32 6b ee			ld (debug_mark),a  
364f 3a 5e 36			ld a, (.dmark+1)  
3652 32 6c ee			ld (debug_mark+1),a  
3655 3a 5f 36			ld a, (.dmark+2)  
3658 32 6d ee			ld (debug_mark+2),a  
365b 18 03			jr .pastdmark  
365d ..			.dmark: db "+IT"  
3660 f1			.pastdmark: pop af  
3661			endm  
# End of macro DMARK
3661				CALLMONITOR 
3661 cd 6f ee			call debug_vector  
3664				endm  
# End of macro CALLMONITOR
3664					endif 
3664			 
3664					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3664 cd 64 1d			call macro_dsp_valuehl 
3667				endm 
# End of macro FORTH_DSP_VALUEHL
3667			 
3667				; TODO add floating point number detection 
3667			 
3667 e5					push hl 
3668			 
3668					; destroy value TOS 
3668			 
3668					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3668 cd 1c 1e			call macro_forth_dsp_pop 
366b				endm 
# End of macro FORTH_DSP_POP
366b			 
366b			 
366b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
366b cd 64 1d			call macro_dsp_valuehl 
366e				endm 
# End of macro FORTH_DSP_VALUEHL
366e			 
366e					; one value on hl get other one back 
366e			 
366e d1					pop de 
366f			 
366f					; do the add 
366f			 
366f 19					add hl,de 
3670			 
3670					; save it 
3670			 
3670			;		push hl	 
3670			 
3670					; 
3670			 
3670					; destroy value TOS 
3670			 
3670					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3670 cd 1c 1e			call macro_forth_dsp_pop 
3673				endm 
# End of macro FORTH_DSP_POP
3673			 
3673					; TODO push value back onto stack for another op etc 
3673			 
3673			;		pop hl 
3673			 
3673			.dot_done: 
3673 cd 6d 1b				call forth_push_numhl 
3676			 
3676					NEXTW 
3676 c3 1a 1f			jp macro_next 
3679				endm 
# End of macro NEXTW
3679			.NEG: 
3679			 
3679				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3679 17				db WORD_SYS_CORE+3             
367a bc 36			dw .DIV            
367c 02				db 1 + 1 
367d .. 00			db "-",0              
367f				endm 
# End of macro CWHEAD
367f			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
367f					if DEBUG_FORTH_WORDS_KEY 
367f						DMARK "SUB" 
367f f5				push af  
3680 3a 94 36			ld a, (.dmark)  
3683 32 6b ee			ld (debug_mark),a  
3686 3a 95 36			ld a, (.dmark+1)  
3689 32 6c ee			ld (debug_mark+1),a  
368c 3a 96 36			ld a, (.dmark+2)  
368f 32 6d ee			ld (debug_mark+2),a  
3692 18 03			jr .pastdmark  
3694 ..			.dmark: db "SUB"  
3697 f1			.pastdmark: pop af  
3698			endm  
# End of macro DMARK
3698						CALLMONITOR 
3698 cd 6f ee			call debug_vector  
369b				endm  
# End of macro CALLMONITOR
369b					endif 
369b			 
369b			 
369b				; TODO add floating point number detection 
369b					; v5 FORTH_DSP_VALUE 
369b					FORTH_DSP 
369b cd 2a 1d			call macro_forth_dsp 
369e				endm 
# End of macro FORTH_DSP
369e 7e					ld a,(hl)	; get type of value on TOS 
369f fe 02				cp DS_TYPE_INUM  
36a1 28 03				jr z, .neg_inum 
36a3			 
36a3					NEXTW 
36a3 c3 1a 1f			jp macro_next 
36a6				endm 
# End of macro NEXTW
36a6			 
36a6			; float maths 
36a6			 
36a6				if FORTH_ENABLE_FLOATMATH 
36a6					jr .neg_done 
36a6			 
36a6				endif 
36a6					 
36a6			 
36a6			.neg_inum: 
36a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36a6 cd 64 1d			call macro_dsp_valuehl 
36a9				endm 
# End of macro FORTH_DSP_VALUEHL
36a9			 
36a9 e5					push hl 
36aa			 
36aa					; destroy value TOS 
36aa			 
36aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36aa cd 1c 1e			call macro_forth_dsp_pop 
36ad				endm 
# End of macro FORTH_DSP_POP
36ad			 
36ad			 
36ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36ad cd 64 1d			call macro_dsp_valuehl 
36b0				endm 
# End of macro FORTH_DSP_VALUEHL
36b0			 
36b0					; one value on hl get other one back 
36b0			 
36b0 d1					pop de 
36b1			 
36b1					; do the sub 
36b1			;		ex de, hl 
36b1			 
36b1 ed 52				sbc hl,de 
36b3			 
36b3					; save it 
36b3			 
36b3			;		push hl	 
36b3			 
36b3					; 
36b3			 
36b3					; destroy value TOS 
36b3			 
36b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36b3 cd 1c 1e			call macro_forth_dsp_pop 
36b6				endm 
# End of macro FORTH_DSP_POP
36b6			 
36b6					; TODO push value back onto stack for another op etc 
36b6			 
36b6			;		pop hl 
36b6			 
36b6 cd 6d 1b				call forth_push_numhl 
36b9			.neg_done: 
36b9			 
36b9					NEXTW 
36b9 c3 1a 1f			jp macro_next 
36bc				endm 
# End of macro NEXTW
36bc			.DIV: 
36bc				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
36bc 18				db WORD_SYS_CORE+4             
36bd 09 37			dw .MUL            
36bf 02				db 1 + 1 
36c0 .. 00			db "/",0              
36c2				endm 
# End of macro CWHEAD
36c2			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
36c2					if DEBUG_FORTH_WORDS_KEY 
36c2						DMARK "DIV" 
36c2 f5				push af  
36c3 3a d7 36			ld a, (.dmark)  
36c6 32 6b ee			ld (debug_mark),a  
36c9 3a d8 36			ld a, (.dmark+1)  
36cc 32 6c ee			ld (debug_mark+1),a  
36cf 3a d9 36			ld a, (.dmark+2)  
36d2 32 6d ee			ld (debug_mark+2),a  
36d5 18 03			jr .pastdmark  
36d7 ..			.dmark: db "DIV"  
36da f1			.pastdmark: pop af  
36db			endm  
# End of macro DMARK
36db						CALLMONITOR 
36db cd 6f ee			call debug_vector  
36de				endm  
# End of macro CALLMONITOR
36de					endif 
36de				; TODO add floating point number detection 
36de					; v5 FORTH_DSP_VALUE 
36de					FORTH_DSP 
36de cd 2a 1d			call macro_forth_dsp 
36e1				endm 
# End of macro FORTH_DSP
36e1 7e					ld a,(hl)	; get type of value on TOS 
36e2 fe 02				cp DS_TYPE_INUM  
36e4 28 03				jr z, .div_inum 
36e6			 
36e6				if FORTH_ENABLE_FLOATMATH 
36e6					jr .div_done 
36e6			 
36e6				endif 
36e6					NEXTW 
36e6 c3 1a 1f			jp macro_next 
36e9				endm 
# End of macro NEXTW
36e9			.div_inum: 
36e9			 
36e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36e9 cd 64 1d			call macro_dsp_valuehl 
36ec				endm 
# End of macro FORTH_DSP_VALUEHL
36ec			 
36ec e5					push hl    ; to go to bc 
36ed			 
36ed					; destroy value TOS 
36ed			 
36ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ed cd 1c 1e			call macro_forth_dsp_pop 
36f0				endm 
# End of macro FORTH_DSP_POP
36f0			 
36f0			 
36f0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36f0 cd 64 1d			call macro_dsp_valuehl 
36f3				endm 
# End of macro FORTH_DSP_VALUEHL
36f3			 
36f3					; hl to go to de 
36f3			 
36f3 e5					push hl 
36f4			 
36f4 c1					pop bc 
36f5 d1					pop de		 
36f6			 
36f6			 
36f6					if DEBUG_FORTH_MATHS 
36f6						DMARK "DIV" 
36f6				CALLMONITOR 
36f6					endif 
36f6					; one value on hl but move to a get other one back 
36f6			 
36f6			        
36f6 cd 43 0d			call Div16 
36f9			 
36f9			;	push af	 
36f9 e5				push hl 
36fa c5				push bc 
36fb			 
36fb					if DEBUG_FORTH_MATHS 
36fb						DMARK "DI1" 
36fb				CALLMONITOR 
36fb					endif 
36fb			 
36fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36fb cd 1c 1e			call macro_forth_dsp_pop 
36fe				endm 
# End of macro FORTH_DSP_POP
36fe			 
36fe			 
36fe			 
36fe e1					pop hl    ; result 
36ff			 
36ff cd 6d 1b				call forth_push_numhl 
3702			 
3702 e1					pop hl    ; reminder 
3703			;		ld h,0 
3703			;		ld l,d 
3703			 
3703 cd 6d 1b				call forth_push_numhl 
3706			.div_done: 
3706					NEXTW 
3706 c3 1a 1f			jp macro_next 
3709				endm 
# End of macro NEXTW
3709			.MUL: 
3709				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3709 19				db WORD_SYS_CORE+5             
370a 4e 37			dw .MIN            
370c 02				db 1 + 1 
370d .. 00			db "*",0              
370f				endm 
# End of macro CWHEAD
370f			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
370f				; TODO add floating point number detection 
370f					if DEBUG_FORTH_WORDS_KEY 
370f						DMARK "MUL" 
370f f5				push af  
3710 3a 24 37			ld a, (.dmark)  
3713 32 6b ee			ld (debug_mark),a  
3716 3a 25 37			ld a, (.dmark+1)  
3719 32 6c ee			ld (debug_mark+1),a  
371c 3a 26 37			ld a, (.dmark+2)  
371f 32 6d ee			ld (debug_mark+2),a  
3722 18 03			jr .pastdmark  
3724 ..			.dmark: db "MUL"  
3727 f1			.pastdmark: pop af  
3728			endm  
# End of macro DMARK
3728						CALLMONITOR 
3728 cd 6f ee			call debug_vector  
372b				endm  
# End of macro CALLMONITOR
372b					endif 
372b					FORTH_DSP 
372b cd 2a 1d			call macro_forth_dsp 
372e				endm 
# End of macro FORTH_DSP
372e					; v5 FORTH_DSP_VALUE 
372e 7e					ld a,(hl)	; get type of value on TOS 
372f fe 02				cp DS_TYPE_INUM  
3731 28 03				jr z, .mul_inum 
3733			 
3733				if FORTH_ENABLE_FLOATMATH 
3733					jr .mul_done 
3733			 
3733				endif 
3733			 
3733					NEXTW 
3733 c3 1a 1f			jp macro_next 
3736				endm 
# End of macro NEXTW
3736			.mul_inum:	 
3736			 
3736					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3736 cd 64 1d			call macro_dsp_valuehl 
3739				endm 
# End of macro FORTH_DSP_VALUEHL
3739			 
3739 e5					push hl 
373a			 
373a					; destroy value TOS 
373a			 
373a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
373a cd 1c 1e			call macro_forth_dsp_pop 
373d				endm 
# End of macro FORTH_DSP_POP
373d			 
373d			 
373d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
373d cd 64 1d			call macro_dsp_valuehl 
3740				endm 
# End of macro FORTH_DSP_VALUEHL
3740			 
3740					; one value on hl but move to a get other one back 
3740			 
3740 7d					ld a, l 
3741			 
3741 d1					pop de 
3742			 
3742					; do the mull 
3742			;		ex de, hl 
3742			 
3742 cd 69 0d				call Mult16 
3745					; save it 
3745			 
3745			;		push hl	 
3745			 
3745					; 
3745			 
3745					; destroy value TOS 
3745			 
3745					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3745 cd 1c 1e			call macro_forth_dsp_pop 
3748				endm 
# End of macro FORTH_DSP_POP
3748			 
3748					; TODO push value back onto stack for another op etc 
3748			 
3748			;		pop hl 
3748			 
3748 cd 6d 1b				call forth_push_numhl 
374b			 
374b			.mul_done: 
374b					NEXTW 
374b c3 1a 1f			jp macro_next 
374e				endm 
# End of macro NEXTW
374e			 
374e			 
374e			 
374e			 
374e			.MIN: 
374e				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
374e 49				db WORD_SYS_CORE+53             
374f cf 37			dw .MAX            
3751 04				db 3 + 1 
3752 .. 00			db "MIN",0              
3756				endm 
# End of macro CWHEAD
3756			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3756					if DEBUG_FORTH_WORDS_KEY 
3756						DMARK "MIN" 
3756 f5				push af  
3757 3a 6b 37			ld a, (.dmark)  
375a 32 6b ee			ld (debug_mark),a  
375d 3a 6c 37			ld a, (.dmark+1)  
3760 32 6c ee			ld (debug_mark+1),a  
3763 3a 6d 37			ld a, (.dmark+2)  
3766 32 6d ee			ld (debug_mark+2),a  
3769 18 03			jr .pastdmark  
376b ..			.dmark: db "MIN"  
376e f1			.pastdmark: pop af  
376f			endm  
# End of macro DMARK
376f						CALLMONITOR 
376f cd 6f ee			call debug_vector  
3772				endm  
# End of macro CALLMONITOR
3772					endif 
3772					; get u2 
3772			 
3772					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3772 cd 64 1d			call macro_dsp_valuehl 
3775				endm 
# End of macro FORTH_DSP_VALUEHL
3775			 
3775 e5					push hl   ; u2 
3776			 
3776					; destroy value TOS 
3776			 
3776					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3776 cd 1c 1e			call macro_forth_dsp_pop 
3779				endm 
# End of macro FORTH_DSP_POP
3779			 
3779					; get u1 
3779			 
3779					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3779 cd 64 1d			call macro_dsp_valuehl 
377c				endm 
# End of macro FORTH_DSP_VALUEHL
377c			 
377c e5					push hl  ; u1 
377d			 
377d					; destroy value TOS 
377d			 
377d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
377d cd 1c 1e			call macro_forth_dsp_pop 
3780				endm 
# End of macro FORTH_DSP_POP
3780			 
3780 b7			 or a      ;clear carry flag 
3781 e1			  pop hl    ; u1 
3782 d1			  pop de    ; u2 
3783 e5				push hl   ; saved in case hl is lowest 
3784 ed 52		  sbc hl,de 
3786 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3788			 
3788 e1				pop hl 
3789					if DEBUG_FORTH_WORDS 
3789						DMARK "MIN" 
3789 f5				push af  
378a 3a 9e 37			ld a, (.dmark)  
378d 32 6b ee			ld (debug_mark),a  
3790 3a 9f 37			ld a, (.dmark+1)  
3793 32 6c ee			ld (debug_mark+1),a  
3796 3a a0 37			ld a, (.dmark+2)  
3799 32 6d ee			ld (debug_mark+2),a  
379c 18 03			jr .pastdmark  
379e ..			.dmark: db "MIN"  
37a1 f1			.pastdmark: pop af  
37a2			endm  
# End of macro DMARK
37a2						CALLMONITOR 
37a2 cd 6f ee			call debug_vector  
37a5				endm  
# End of macro CALLMONITOR
37a5					endif 
37a5 cd 6d 1b				call forth_push_numhl 
37a8			 
37a8				       NEXTW 
37a8 c3 1a 1f			jp macro_next 
37ab				endm 
# End of macro NEXTW
37ab			 
37ab			.mincont:  
37ab c1				pop bc   ; tidy up 
37ac eb				ex de , hl  
37ad					if DEBUG_FORTH_WORDS 
37ad						DMARK "MI1" 
37ad f5				push af  
37ae 3a c2 37			ld a, (.dmark)  
37b1 32 6b ee			ld (debug_mark),a  
37b4 3a c3 37			ld a, (.dmark+1)  
37b7 32 6c ee			ld (debug_mark+1),a  
37ba 3a c4 37			ld a, (.dmark+2)  
37bd 32 6d ee			ld (debug_mark+2),a  
37c0 18 03			jr .pastdmark  
37c2 ..			.dmark: db "MI1"  
37c5 f1			.pastdmark: pop af  
37c6			endm  
# End of macro DMARK
37c6						CALLMONITOR 
37c6 cd 6f ee			call debug_vector  
37c9				endm  
# End of macro CALLMONITOR
37c9					endif 
37c9 cd 6d 1b				call forth_push_numhl 
37cc			 
37cc				       NEXTW 
37cc c3 1a 1f			jp macro_next 
37cf				endm 
# End of macro NEXTW
37cf			.MAX: 
37cf				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
37cf 4a				db WORD_SYS_CORE+54             
37d0 50 38			dw .RND16            
37d2 04				db 3 + 1 
37d3 .. 00			db "MAX",0              
37d7				endm 
# End of macro CWHEAD
37d7			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
37d7					if DEBUG_FORTH_WORDS_KEY 
37d7						DMARK "MAX" 
37d7 f5				push af  
37d8 3a ec 37			ld a, (.dmark)  
37db 32 6b ee			ld (debug_mark),a  
37de 3a ed 37			ld a, (.dmark+1)  
37e1 32 6c ee			ld (debug_mark+1),a  
37e4 3a ee 37			ld a, (.dmark+2)  
37e7 32 6d ee			ld (debug_mark+2),a  
37ea 18 03			jr .pastdmark  
37ec ..			.dmark: db "MAX"  
37ef f1			.pastdmark: pop af  
37f0			endm  
# End of macro DMARK
37f0						CALLMONITOR 
37f0 cd 6f ee			call debug_vector  
37f3				endm  
# End of macro CALLMONITOR
37f3					endif 
37f3					; get u2 
37f3			 
37f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37f3 cd 64 1d			call macro_dsp_valuehl 
37f6				endm 
# End of macro FORTH_DSP_VALUEHL
37f6			 
37f6 e5					push hl   ; u2 
37f7			 
37f7					; destroy value TOS 
37f7			 
37f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37f7 cd 1c 1e			call macro_forth_dsp_pop 
37fa				endm 
# End of macro FORTH_DSP_POP
37fa			 
37fa					; get u1 
37fa			 
37fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37fa cd 64 1d			call macro_dsp_valuehl 
37fd				endm 
# End of macro FORTH_DSP_VALUEHL
37fd			 
37fd e5					push hl  ; u1 
37fe			 
37fe					; destroy value TOS 
37fe			 
37fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37fe cd 1c 1e			call macro_forth_dsp_pop 
3801				endm 
# End of macro FORTH_DSP_POP
3801			 
3801 b7			 or a      ;clear carry flag 
3802 e1			  pop hl    ; u1 
3803 d1			  pop de    ; u2 
3804 e5				push hl   ; saved in case hl is lowest 
3805 ed 52		  sbc hl,de 
3807 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3809			 
3809 e1				pop hl 
380a					if DEBUG_FORTH_WORDS 
380a						DMARK "MAX" 
380a f5				push af  
380b 3a 1f 38			ld a, (.dmark)  
380e 32 6b ee			ld (debug_mark),a  
3811 3a 20 38			ld a, (.dmark+1)  
3814 32 6c ee			ld (debug_mark+1),a  
3817 3a 21 38			ld a, (.dmark+2)  
381a 32 6d ee			ld (debug_mark+2),a  
381d 18 03			jr .pastdmark  
381f ..			.dmark: db "MAX"  
3822 f1			.pastdmark: pop af  
3823			endm  
# End of macro DMARK
3823						CALLMONITOR 
3823 cd 6f ee			call debug_vector  
3826				endm  
# End of macro CALLMONITOR
3826					endif 
3826 cd 6d 1b				call forth_push_numhl 
3829			 
3829				       NEXTW 
3829 c3 1a 1f			jp macro_next 
382c				endm 
# End of macro NEXTW
382c			 
382c			.maxcont:  
382c c1				pop bc   ; tidy up 
382d eb				ex de , hl  
382e					if DEBUG_FORTH_WORDS 
382e						DMARK "MA1" 
382e f5				push af  
382f 3a 43 38			ld a, (.dmark)  
3832 32 6b ee			ld (debug_mark),a  
3835 3a 44 38			ld a, (.dmark+1)  
3838 32 6c ee			ld (debug_mark+1),a  
383b 3a 45 38			ld a, (.dmark+2)  
383e 32 6d ee			ld (debug_mark+2),a  
3841 18 03			jr .pastdmark  
3843 ..			.dmark: db "MA1"  
3846 f1			.pastdmark: pop af  
3847			endm  
# End of macro DMARK
3847						CALLMONITOR 
3847 cd 6f ee			call debug_vector  
384a				endm  
# End of macro CALLMONITOR
384a					endif 
384a cd 6d 1b				call forth_push_numhl 
384d				       NEXTW 
384d c3 1a 1f			jp macro_next 
3850				endm 
# End of macro NEXTW
3850			 
3850			.RND16: 
3850				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3850 4e				db WORD_SYS_CORE+58             
3851 7f 38			dw .RND8            
3853 06				db 5 + 1 
3854 .. 00			db "RND16",0              
385a				endm 
# End of macro CWHEAD
385a			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
385a					if DEBUG_FORTH_WORDS_KEY 
385a						DMARK "R16" 
385a f5				push af  
385b 3a 6f 38			ld a, (.dmark)  
385e 32 6b ee			ld (debug_mark),a  
3861 3a 70 38			ld a, (.dmark+1)  
3864 32 6c ee			ld (debug_mark+1),a  
3867 3a 71 38			ld a, (.dmark+2)  
386a 32 6d ee			ld (debug_mark+2),a  
386d 18 03			jr .pastdmark  
386f ..			.dmark: db "R16"  
3872 f1			.pastdmark: pop af  
3873			endm  
# End of macro DMARK
3873						CALLMONITOR 
3873 cd 6f ee			call debug_vector  
3876				endm  
# End of macro CALLMONITOR
3876					endif 
3876 cd 0d 0d				call prng16  
3879 cd 6d 1b				call forth_push_numhl 
387c				       NEXTW 
387c c3 1a 1f			jp macro_next 
387f				endm 
# End of macro NEXTW
387f			.RND8: 
387f				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
387f 60				db WORD_SYS_CORE+76             
3880 b4 38			dw .RND            
3882 05				db 4 + 1 
3883 .. 00			db "RND8",0              
3888				endm 
# End of macro CWHEAD
3888			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3888					if DEBUG_FORTH_WORDS_KEY 
3888						DMARK "RN8" 
3888 f5				push af  
3889 3a 9d 38			ld a, (.dmark)  
388c 32 6b ee			ld (debug_mark),a  
388f 3a 9e 38			ld a, (.dmark+1)  
3892 32 6c ee			ld (debug_mark+1),a  
3895 3a 9f 38			ld a, (.dmark+2)  
3898 32 6d ee			ld (debug_mark+2),a  
389b 18 03			jr .pastdmark  
389d ..			.dmark: db "RN8"  
38a0 f1			.pastdmark: pop af  
38a1			endm  
# End of macro DMARK
38a1						CALLMONITOR 
38a1 cd 6f ee			call debug_vector  
38a4				endm  
# End of macro CALLMONITOR
38a4					endif 
38a4 2a a9 eb				ld hl,(xrandc) 
38a7 23					inc hl 
38a8 cd 27 0d				call xrnd 
38ab 6f					ld l,a	 
38ac 26 00				ld h,0 
38ae cd 6d 1b				call forth_push_numhl 
38b1				       NEXTW 
38b1 c3 1a 1f			jp macro_next 
38b4				endm 
# End of macro NEXTW
38b4			.RND: 
38b4				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
38b4 60				db WORD_SYS_CORE+76             
38b5 ba 39			dw .ENDMATHS            
38b7 04				db 3 + 1 
38b8 .. 00			db "RND",0              
38bc				endm 
# End of macro CWHEAD
38bc			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
38bc			 
38bc					if DEBUG_FORTH_WORDS_KEY 
38bc						DMARK "RND" 
38bc f5				push af  
38bd 3a d1 38			ld a, (.dmark)  
38c0 32 6b ee			ld (debug_mark),a  
38c3 3a d2 38			ld a, (.dmark+1)  
38c6 32 6c ee			ld (debug_mark+1),a  
38c9 3a d3 38			ld a, (.dmark+2)  
38cc 32 6d ee			ld (debug_mark+2),a  
38cf 18 03			jr .pastdmark  
38d1 ..			.dmark: db "RND"  
38d4 f1			.pastdmark: pop af  
38d5			endm  
# End of macro DMARK
38d5						CALLMONITOR 
38d5 cd 6f ee			call debug_vector  
38d8				endm  
# End of macro CALLMONITOR
38d8					endif 
38d8					 
38d8					FORTH_DSP_VALUEHL    ; upper range 
38d8 cd 64 1d			call macro_dsp_valuehl 
38db				endm 
# End of macro FORTH_DSP_VALUEHL
38db			 
38db 22 ad eb				ld (LFSRSeed), hl	 
38de			 
38de					if DEBUG_FORTH_WORDS 
38de						DMARK "RN1" 
38de f5				push af  
38df 3a f3 38			ld a, (.dmark)  
38e2 32 6b ee			ld (debug_mark),a  
38e5 3a f4 38			ld a, (.dmark+1)  
38e8 32 6c ee			ld (debug_mark+1),a  
38eb 3a f5 38			ld a, (.dmark+2)  
38ee 32 6d ee			ld (debug_mark+2),a  
38f1 18 03			jr .pastdmark  
38f3 ..			.dmark: db "RN1"  
38f6 f1			.pastdmark: pop af  
38f7			endm  
# End of macro DMARK
38f7						CALLMONITOR 
38f7 cd 6f ee			call debug_vector  
38fa				endm  
# End of macro CALLMONITOR
38fa					endif 
38fa					FORTH_DSP_POP 
38fa cd 1c 1e			call macro_forth_dsp_pop 
38fd				endm 
# End of macro FORTH_DSP_POP
38fd			 
38fd					FORTH_DSP_VALUEHL    ; low range 
38fd cd 64 1d			call macro_dsp_valuehl 
3900				endm 
# End of macro FORTH_DSP_VALUEHL
3900			 
3900					if DEBUG_FORTH_WORDS 
3900						DMARK "RN2" 
3900 f5				push af  
3901 3a 15 39			ld a, (.dmark)  
3904 32 6b ee			ld (debug_mark),a  
3907 3a 16 39			ld a, (.dmark+1)  
390a 32 6c ee			ld (debug_mark+1),a  
390d 3a 17 39			ld a, (.dmark+2)  
3910 32 6d ee			ld (debug_mark+2),a  
3913 18 03			jr .pastdmark  
3915 ..			.dmark: db "RN2"  
3918 f1			.pastdmark: pop af  
3919			endm  
# End of macro DMARK
3919						CALLMONITOR 
3919 cd 6f ee			call debug_vector  
391c				endm  
# End of macro CALLMONITOR
391c					endif 
391c 22 af eb				ld (LFSRSeed+2), hl 
391f			 
391f					FORTH_DSP_POP 
391f cd 1c 1e			call macro_forth_dsp_pop 
3922				endm 
# End of macro FORTH_DSP_POP
3922			 
3922 e5					push hl 
3923			 
3923 e1			.inrange:	pop hl 
3924 cd 0d 0d				call prng16  
3927					if DEBUG_FORTH_WORDS 
3927						DMARK "RN3" 
3927 f5				push af  
3928 3a 3c 39			ld a, (.dmark)  
392b 32 6b ee			ld (debug_mark),a  
392e 3a 3d 39			ld a, (.dmark+1)  
3931 32 6c ee			ld (debug_mark+1),a  
3934 3a 3e 39			ld a, (.dmark+2)  
3937 32 6d ee			ld (debug_mark+2),a  
393a 18 03			jr .pastdmark  
393c ..			.dmark: db "RN3"  
393f f1			.pastdmark: pop af  
3940			endm  
# End of macro DMARK
3940						CALLMONITOR 
3940 cd 6f ee			call debug_vector  
3943				endm  
# End of macro CALLMONITOR
3943					endif 
3943					 
3943					; if the range is 8bit knock out the high byte 
3943			 
3943 ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
3947			 
3947 3e 00				ld a, 0 
3949 ba					cp d  
394a 20 1e				jr nz, .hirange 
394c 26 00				ld h, 0   ; knock it down to 8bit 
394e			 
394e					if DEBUG_FORTH_WORDS 
394e						DMARK "RNk" 
394e f5				push af  
394f 3a 63 39			ld a, (.dmark)  
3952 32 6b ee			ld (debug_mark),a  
3955 3a 64 39			ld a, (.dmark+1)  
3958 32 6c ee			ld (debug_mark+1),a  
395b 3a 65 39			ld a, (.dmark+2)  
395e 32 6d ee			ld (debug_mark+2),a  
3961 18 03			jr .pastdmark  
3963 ..			.dmark: db "RNk"  
3966 f1			.pastdmark: pop af  
3967			endm  
# End of macro DMARK
3967						CALLMONITOR 
3967 cd 6f ee			call debug_vector  
396a				endm  
# End of macro CALLMONITOR
396a					endif 
396a			.hirange:   
396a e5					push hl  
396b b7					or a  
396c ed 52		                sbc hl, de 
396e			 
396e					;call cmp16 
396e			 
396e 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3970 e1					pop hl 
3971 e5					push hl 
3972			 
3972					if DEBUG_FORTH_WORDS 
3972						DMARK "RN4" 
3972 f5				push af  
3973 3a 87 39			ld a, (.dmark)  
3976 32 6b ee			ld (debug_mark),a  
3979 3a 88 39			ld a, (.dmark+1)  
397c 32 6c ee			ld (debug_mark+1),a  
397f 3a 89 39			ld a, (.dmark+2)  
3982 32 6d ee			ld (debug_mark+2),a  
3985 18 03			jr .pastdmark  
3987 ..			.dmark: db "RN4"  
398a f1			.pastdmark: pop af  
398b			endm  
# End of macro DMARK
398b						CALLMONITOR 
398b cd 6f ee			call debug_vector  
398e				endm  
# End of macro CALLMONITOR
398e					endif 
398e ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
3992					;call cmp16 
3992				 
3992 b7					or a  
3993 ed 52		                sbc hl, de 
3995 38 8c				jr c, .inrange 
3997			 
3997 e1					pop hl 
3998					 
3998					if DEBUG_FORTH_WORDS 
3998						DMARK "RNd" 
3998 f5				push af  
3999 3a ad 39			ld a, (.dmark)  
399c 32 6b ee			ld (debug_mark),a  
399f 3a ae 39			ld a, (.dmark+1)  
39a2 32 6c ee			ld (debug_mark+1),a  
39a5 3a af 39			ld a, (.dmark+2)  
39a8 32 6d ee			ld (debug_mark+2),a  
39ab 18 03			jr .pastdmark  
39ad ..			.dmark: db "RNd"  
39b0 f1			.pastdmark: pop af  
39b1			endm  
# End of macro DMARK
39b1						CALLMONITOR 
39b1 cd 6f ee			call debug_vector  
39b4				endm  
# End of macro CALLMONITOR
39b4					endif 
39b4			 
39b4			 
39b4 cd 6d 1b				call forth_push_numhl 
39b7				       NEXTW 
39b7 c3 1a 1f			jp macro_next 
39ba				endm 
# End of macro NEXTW
39ba			 
39ba			.ENDMATHS: 
39ba			 
39ba			; eof 
39ba			 
# End of file forth_words_maths.asm
39ba			include "forth_words_display.asm" 
39ba			 
39ba			; | ## Display Words 
39ba			 
39ba			.ACT: 
39ba			 
39ba				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
39ba 62				db WORD_SYS_CORE+78             
39bb 06 3a			dw .INFO            
39bd 07				db 6 + 1 
39be .. 00			db "ACTIVE",0              
39c5				endm 
# End of macro CWHEAD
39c5			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
39c5			;  
39c5			; | | To display a pulsing activity indicator in a processing loop do this... 
39c5			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
39c5			 
39c5					if DEBUG_FORTH_WORDS_KEY 
39c5						DMARK "ACT" 
39c5 f5				push af  
39c6 3a da 39			ld a, (.dmark)  
39c9 32 6b ee			ld (debug_mark),a  
39cc 3a db 39			ld a, (.dmark+1)  
39cf 32 6c ee			ld (debug_mark+1),a  
39d2 3a dc 39			ld a, (.dmark+2)  
39d5 32 6d ee			ld (debug_mark+2),a  
39d8 18 03			jr .pastdmark  
39da ..			.dmark: db "ACT"  
39dd f1			.pastdmark: pop af  
39de			endm  
# End of macro DMARK
39de						CALLMONITOR 
39de cd 6f ee			call debug_vector  
39e1				endm  
# End of macro CALLMONITOR
39e1					endif 
39e1 cd 10 0b				call active 
39e4					if DEBUG_FORTH_WORDS 
39e4						DMARK "ACp" 
39e4 f5				push af  
39e5 3a f9 39			ld a, (.dmark)  
39e8 32 6b ee			ld (debug_mark),a  
39eb 3a fa 39			ld a, (.dmark+1)  
39ee 32 6c ee			ld (debug_mark+1),a  
39f1 3a fb 39			ld a, (.dmark+2)  
39f4 32 6d ee			ld (debug_mark+2),a  
39f7 18 03			jr .pastdmark  
39f9 ..			.dmark: db "ACp"  
39fc f1			.pastdmark: pop af  
39fd			endm  
# End of macro DMARK
39fd						CALLMONITOR 
39fd cd 6f ee			call debug_vector  
3a00				endm  
# End of macro CALLMONITOR
3a00					endif 
3a00 cd db 1b				call forth_push_str 
3a03			 
3a03					NEXTW 
3a03 c3 1a 1f			jp macro_next 
3a06				endm 
# End of macro NEXTW
3a06			.INFO: 
3a06			 
3a06				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3a06 62				db WORD_SYS_CORE+78             
3a07 23 3a			dw .ATP            
3a09 05				db 4 + 1 
3a0a .. 00			db "INFO",0              
3a0f				endm 
# End of macro CWHEAD
3a0f			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3a0f					FORTH_DSP_VALUEHL 
3a0f cd 64 1d			call macro_dsp_valuehl 
3a12				endm 
# End of macro FORTH_DSP_VALUEHL
3a12			 
3a12					FORTH_DSP_POP 
3a12 cd 1c 1e			call macro_forth_dsp_pop 
3a15				endm 
# End of macro FORTH_DSP_POP
3a15			 
3a15 e5					push hl 
3a16			 
3a16					FORTH_DSP_VALUEHL 
3a16 cd 64 1d			call macro_dsp_valuehl 
3a19				endm 
# End of macro FORTH_DSP_VALUEHL
3a19			 
3a19					FORTH_DSP_POP 
3a19 cd 1c 1e			call macro_forth_dsp_pop 
3a1c				endm 
# End of macro FORTH_DSP_POP
3a1c			 
3a1c d1					pop de 
3a1d			 
3a1d cd 4a 0b				call info_panel 
3a20			 
3a20			 
3a20					NEXTW 
3a20 c3 1a 1f			jp macro_next 
3a23				endm 
# End of macro NEXTW
3a23			.ATP: 
3a23				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a23 62				db WORD_SYS_CORE+78             
3a24 9a 3a			dw .FB            
3a26 04				db 3 + 1 
3a27 .. 00			db "AT?",0              
3a2b				endm 
# End of macro CWHEAD
3a2b			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a2b					if DEBUG_FORTH_WORDS_KEY 
3a2b						DMARK "AT?" 
3a2b f5				push af  
3a2c 3a 40 3a			ld a, (.dmark)  
3a2f 32 6b ee			ld (debug_mark),a  
3a32 3a 41 3a			ld a, (.dmark+1)  
3a35 32 6c ee			ld (debug_mark+1),a  
3a38 3a 42 3a			ld a, (.dmark+2)  
3a3b 32 6d ee			ld (debug_mark+2),a  
3a3e 18 03			jr .pastdmark  
3a40 ..			.dmark: db "AT?"  
3a43 f1			.pastdmark: pop af  
3a44			endm  
# End of macro DMARK
3a44						CALLMONITOR 
3a44 cd 6f ee			call debug_vector  
3a47				endm  
# End of macro CALLMONITOR
3a47					endif 
3a47 3a 5e ea				ld a, (f_cursor_ptr) 
3a4a			 
3a4a			if DEBUG_FORTH_WORDS 
3a4a				DMARK "AT?" 
3a4a f5				push af  
3a4b 3a 5f 3a			ld a, (.dmark)  
3a4e 32 6b ee			ld (debug_mark),a  
3a51 3a 60 3a			ld a, (.dmark+1)  
3a54 32 6c ee			ld (debug_mark+1),a  
3a57 3a 61 3a			ld a, (.dmark+2)  
3a5a 32 6d ee			ld (debug_mark+2),a  
3a5d 18 03			jr .pastdmark  
3a5f ..			.dmark: db "AT?"  
3a62 f1			.pastdmark: pop af  
3a63			endm  
# End of macro DMARK
3a63				CALLMONITOR 
3a63 cd 6f ee			call debug_vector  
3a66				endm  
# End of macro CALLMONITOR
3a66			endif	 
3a66					; count the number of rows 
3a66			 
3a66 06 00				ld b, 0 
3a68 4f			.atpr:		ld c, a    ; save in case we go below zero 
3a69 d6 28				sub display_cols 
3a6b f2 71 3a				jp p, .atprunder 
3a6e 04					inc b 
3a6f 18 f7				jr .atpr 
3a71			.atprunder:	 
3a71			if DEBUG_FORTH_WORDS 
3a71				DMARK "A?2" 
3a71 f5				push af  
3a72 3a 86 3a			ld a, (.dmark)  
3a75 32 6b ee			ld (debug_mark),a  
3a78 3a 87 3a			ld a, (.dmark+1)  
3a7b 32 6c ee			ld (debug_mark+1),a  
3a7e 3a 88 3a			ld a, (.dmark+2)  
3a81 32 6d ee			ld (debug_mark+2),a  
3a84 18 03			jr .pastdmark  
3a86 ..			.dmark: db "A?2"  
3a89 f1			.pastdmark: pop af  
3a8a			endm  
# End of macro DMARK
3a8a				CALLMONITOR 
3a8a cd 6f ee			call debug_vector  
3a8d				endm  
# End of macro CALLMONITOR
3a8d			endif	 
3a8d 26 00				ld h, 0 
3a8f 69					ld l, c 
3a90 cd 6d 1b				call forth_push_numhl 
3a93 68					ld l, b  
3a94 cd 6d 1b				call forth_push_numhl 
3a97			 
3a97			 
3a97				NEXTW 
3a97 c3 1a 1f			jp macro_next 
3a9a				endm 
# End of macro NEXTW
3a9a			 
3a9a			.FB: 
3a9a				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3a9a 1b				db WORD_SYS_CORE+7             
3a9b e8 3a			dw .EMIT            
3a9d 03				db 2 + 1 
3a9e .. 00			db "FB",0              
3aa1				endm 
# End of macro CWHEAD
3aa1			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3aa1			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3aa1			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3aa1			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3aa1					if DEBUG_FORTH_WORDS_KEY 
3aa1						DMARK "FB." 
3aa1 f5				push af  
3aa2 3a b6 3a			ld a, (.dmark)  
3aa5 32 6b ee			ld (debug_mark),a  
3aa8 3a b7 3a			ld a, (.dmark+1)  
3aab 32 6c ee			ld (debug_mark+1),a  
3aae 3a b8 3a			ld a, (.dmark+2)  
3ab1 32 6d ee			ld (debug_mark+2),a  
3ab4 18 03			jr .pastdmark  
3ab6 ..			.dmark: db "FB."  
3ab9 f1			.pastdmark: pop af  
3aba			endm  
# End of macro DMARK
3aba						CALLMONITOR 
3aba cd 6f ee			call debug_vector  
3abd				endm  
# End of macro CALLMONITOR
3abd					endif 
3abd			 
3abd					FORTH_DSP_VALUEHL 
3abd cd 64 1d			call macro_dsp_valuehl 
3ac0				endm 
# End of macro FORTH_DSP_VALUEHL
3ac0			 
3ac0 7d					ld a, l 
3ac1 fe 01				cp 1 
3ac3 20 05				jr nz, .fbn1 
3ac5 21 10 ed				ld hl, display_fb1 
3ac8 18 15				jr .fbset 
3aca fe 02		.fbn1:		cp 2 
3acc 20 05				jr nz, .fbn2 
3ace 21 ce eb				ld hl, display_fb2 
3ad1 18 0c				jr .fbset 
3ad3 fe 03		.fbn2:		cp 3 
3ad5 20 05				jr nz, .fbn3 
3ad7 21 6f ec				ld hl, display_fb3 
3ada 18 03				jr .fbset 
3adc			.fbn3:		 ; if invalid number select first 
3adc 21 10 ed				ld hl, display_fb1 
3adf 22 cc eb		.fbset:		ld (display_fb_active), hl 
3ae2			 
3ae2					FORTH_DSP_POP 
3ae2 cd 1c 1e			call macro_forth_dsp_pop 
3ae5				endm 
# End of macro FORTH_DSP_POP
3ae5			 
3ae5					NEXTW 
3ae5 c3 1a 1f			jp macro_next 
3ae8				endm 
# End of macro NEXTW
3ae8			 
3ae8			 
3ae8			.EMIT: 
3ae8				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3ae8 1b				db WORD_SYS_CORE+7             
3ae9 39 3b			dw .DOTH            
3aeb 05				db 4 + 1 
3aec .. 00			db "EMIT",0              
3af1				endm 
# End of macro CWHEAD
3af1			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3af1					; get value off TOS and display it 
3af1			 
3af1					if DEBUG_FORTH_WORDS_KEY 
3af1						DMARK "EMT" 
3af1 f5				push af  
3af2 3a 06 3b			ld a, (.dmark)  
3af5 32 6b ee			ld (debug_mark),a  
3af8 3a 07 3b			ld a, (.dmark+1)  
3afb 32 6c ee			ld (debug_mark+1),a  
3afe 3a 08 3b			ld a, (.dmark+2)  
3b01 32 6d ee			ld (debug_mark+2),a  
3b04 18 03			jr .pastdmark  
3b06 ..			.dmark: db "EMT"  
3b09 f1			.pastdmark: pop af  
3b0a			endm  
# End of macro DMARK
3b0a						CALLMONITOR 
3b0a cd 6f ee			call debug_vector  
3b0d				endm  
# End of macro CALLMONITOR
3b0d					endif 
3b0d			 
3b0d					FORTH_DSP_VALUEHL 
3b0d cd 64 1d			call macro_dsp_valuehl 
3b10				endm 
# End of macro FORTH_DSP_VALUEHL
3b10			 
3b10 7d					ld a,l 
3b11			 
3b11					; TODO write to display 
3b11			 
3b11 32 bf e4				ld (os_input), a 
3b14 3e 00				ld a, 0 
3b16 32 c0 e4				ld (os_input+1), a 
3b19					 
3b19 3a 5e ea				ld a, (f_cursor_ptr) 
3b1c 11 bf e4				ld de, os_input 
3b1f cd cc 0b				call str_at_display 
3b22			 
3b22			 
3b22 3a 3c ea				ld a,(cli_autodisplay) 
3b25 fe 00				cp 0 
3b27 28 03				jr z, .enoupdate 
3b29 cd dc 0b						call update_display 
3b2c					.enoupdate: 
3b2c			 
3b2c 3a 5e ea				ld a, (f_cursor_ptr) 
3b2f 3c					inc a 
3b30 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3b33			 
3b33			 
3b33					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b33 cd 1c 1e			call macro_forth_dsp_pop 
3b36				endm 
# End of macro FORTH_DSP_POP
3b36			  
3b36			 
3b36					NEXTW 
3b36 c3 1a 1f			jp macro_next 
3b39				endm 
# End of macro NEXTW
3b39			.DOTH: 
3b39				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b39 1c				db WORD_SYS_CORE+8             
3b3a 69 3b			dw .DOTF            
3b3c 03				db 2 + 1 
3b3d .. 00			db ".-",0              
3b40				endm 
# End of macro CWHEAD
3b40			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b40					; get value off TOS and display it 
3b40					if DEBUG_FORTH_WORDS_KEY 
3b40						DMARK "DTD" 
3b40 f5				push af  
3b41 3a 55 3b			ld a, (.dmark)  
3b44 32 6b ee			ld (debug_mark),a  
3b47 3a 56 3b			ld a, (.dmark+1)  
3b4a 32 6c ee			ld (debug_mark+1),a  
3b4d 3a 57 3b			ld a, (.dmark+2)  
3b50 32 6d ee			ld (debug_mark+2),a  
3b53 18 03			jr .pastdmark  
3b55 ..			.dmark: db "DTD"  
3b58 f1			.pastdmark: pop af  
3b59			endm  
# End of macro DMARK
3b59						CALLMONITOR 
3b59 cd 6f ee			call debug_vector  
3b5c				endm  
# End of macro CALLMONITOR
3b5c					endif 
3b5c 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3b5e 3e 00			ld a, 0 
3b60 32 3d ea			ld (cli_mvdot), a 
3b63 c3 c0 3b			jp .dotgo 
3b66				NEXTW 
3b66 c3 1a 1f			jp macro_next 
3b69				endm 
# End of macro NEXTW
3b69			.DOTF: 
3b69				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3b69 1c				db WORD_SYS_CORE+8             
3b6a 97 3b			dw .DOT            
3b6c 03				db 2 + 1 
3b6d .. 00			db ".>",0              
3b70				endm 
# End of macro CWHEAD
3b70			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
3b70					; get value off TOS and display it 
3b70			        ; TODO BUG adds extra spaces 
3b70			        ; TODO BUG handle numerics? 
3b70					if DEBUG_FORTH_WORDS_KEY 
3b70						DMARK "DTC" 
3b70 f5				push af  
3b71 3a 85 3b			ld a, (.dmark)  
3b74 32 6b ee			ld (debug_mark),a  
3b77 3a 86 3b			ld a, (.dmark+1)  
3b7a 32 6c ee			ld (debug_mark+1),a  
3b7d 3a 87 3b			ld a, (.dmark+2)  
3b80 32 6d ee			ld (debug_mark+2),a  
3b83 18 03			jr .pastdmark  
3b85 ..			.dmark: db "DTC"  
3b88 f1			.pastdmark: pop af  
3b89			endm  
# End of macro DMARK
3b89						CALLMONITOR 
3b89 cd 6f ee			call debug_vector  
3b8c				endm  
# End of macro CALLMONITOR
3b8c					endif 
3b8c 3e 01			ld a, 1 
3b8e 32 3d ea			ld (cli_mvdot), a 
3b91 c3 c0 3b			jp .dotgo 
3b94				NEXTW 
3b94 c3 1a 1f			jp macro_next 
3b97				endm 
# End of macro NEXTW
3b97			 
3b97			.DOT: 
3b97				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3b97 1c				db WORD_SYS_CORE+8             
3b98 73 3d			dw .CLS            
3b9a 02				db 1 + 1 
3b9b .. 00			db ".",0              
3b9d				endm 
# End of macro CWHEAD
3b9d			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
3b9d					; get value off TOS and display it 
3b9d			 
3b9d					if DEBUG_FORTH_WORDS_KEY 
3b9d						DMARK "DOT" 
3b9d f5				push af  
3b9e 3a b2 3b			ld a, (.dmark)  
3ba1 32 6b ee			ld (debug_mark),a  
3ba4 3a b3 3b			ld a, (.dmark+1)  
3ba7 32 6c ee			ld (debug_mark+1),a  
3baa 3a b4 3b			ld a, (.dmark+2)  
3bad 32 6d ee			ld (debug_mark+2),a  
3bb0 18 03			jr .pastdmark  
3bb2 ..			.dmark: db "DOT"  
3bb5 f1			.pastdmark: pop af  
3bb6			endm  
# End of macro DMARK
3bb6						CALLMONITOR 
3bb6 cd 6f ee			call debug_vector  
3bb9				endm  
# End of macro CALLMONITOR
3bb9					endif 
3bb9 3e 00			ld a, 0 
3bbb 32 3d ea			ld (cli_mvdot), a 
3bbe 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3bc0				 
3bc0			 
3bc0			.dotgo: 
3bc0			 
3bc0			; move up type to on stack for parserv5 
3bc0					FORTH_DSP 
3bc0 cd 2a 1d			call macro_forth_dsp 
3bc3				endm 
# End of macro FORTH_DSP
3bc3				;FORTH_DSP_VALUE  
3bc3			 
3bc3			if DEBUG_FORTH_DOT 
3bc3				DMARK "DOT" 
3bc3 f5				push af  
3bc4 3a d8 3b			ld a, (.dmark)  
3bc7 32 6b ee			ld (debug_mark),a  
3bca 3a d9 3b			ld a, (.dmark+1)  
3bcd 32 6c ee			ld (debug_mark+1),a  
3bd0 3a da 3b			ld a, (.dmark+2)  
3bd3 32 6d ee			ld (debug_mark+2),a  
3bd6 18 03			jr .pastdmark  
3bd8 ..			.dmark: db "DOT"  
3bdb f1			.pastdmark: pop af  
3bdc			endm  
# End of macro DMARK
3bdc				CALLMONITOR 
3bdc cd 6f ee			call debug_vector  
3bdf				endm  
# End of macro CALLMONITOR
3bdf			endif	 
3bdf			;		.print: 
3bdf			 
3bdf 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3be0 23				inc hl   ; position to the actual value 
3be1 fe 01			cp DS_TYPE_STR 
3be3 20 06			jr nz, .dotnum1  
3be5			 
3be5			; display string 
3be5				FORTH_DSP_VALUE  
3be5 cd 4d 1d			call macro_forth_dsp_value 
3be8				endm 
# End of macro FORTH_DSP_VALUE
3be8 eb				ex de,hl 
3be9 18 49			jr .dotwrite 
3beb			 
3beb			.dotnum1: 
3beb fe 02			cp DS_TYPE_INUM 
3bed 20 44			jr nz, .dotflot 
3bef			 
3bef			 
3bef			; display number 
3bef			 
3bef			;	push hl 
3bef			;	call clear_display 
3bef			;	pop hl 
3bef			 
3bef 5e				ld e, (hl) 
3bf0 23				inc hl 
3bf1 56				ld d, (hl) 
3bf2 21 c1 e2			ld hl, scratch 
3bf5			if DEBUG_FORTH_DOT 
3bf5				DMARK "DT1" 
3bf5 f5				push af  
3bf6 3a 0a 3c			ld a, (.dmark)  
3bf9 32 6b ee			ld (debug_mark),a  
3bfc 3a 0b 3c			ld a, (.dmark+1)  
3bff 32 6c ee			ld (debug_mark+1),a  
3c02 3a 0c 3c			ld a, (.dmark+2)  
3c05 32 6d ee			ld (debug_mark+2),a  
3c08 18 03			jr .pastdmark  
3c0a ..			.dmark: db "DT1"  
3c0d f1			.pastdmark: pop af  
3c0e			endm  
# End of macro DMARK
3c0e				CALLMONITOR 
3c0e cd 6f ee			call debug_vector  
3c11				endm  
# End of macro CALLMONITOR
3c11			endif	 
3c11			 
3c11 cd fb 10			call uitoa_16 
3c14 eb				ex de,hl 
3c15			 
3c15			if DEBUG_FORTH_DOT 
3c15				DMARK "DT2" 
3c15 f5				push af  
3c16 3a 2a 3c			ld a, (.dmark)  
3c19 32 6b ee			ld (debug_mark),a  
3c1c 3a 2b 3c			ld a, (.dmark+1)  
3c1f 32 6c ee			ld (debug_mark+1),a  
3c22 3a 2c 3c			ld a, (.dmark+2)  
3c25 32 6d ee			ld (debug_mark+2),a  
3c28 18 03			jr .pastdmark  
3c2a ..			.dmark: db "DT2"  
3c2d f1			.pastdmark: pop af  
3c2e			endm  
# End of macro DMARK
3c2e				CALLMONITOR 
3c2e cd 6f ee			call debug_vector  
3c31				endm  
# End of macro CALLMONITOR
3c31			endif	 
3c31			 
3c31			;	ld de, os_word_scratch 
3c31 18 01			jr .dotwrite 
3c33			 
3c33 00			.dotflot:   nop 
3c34			; TODO print floating point number 
3c34			 
3c34			.dotwrite:		 
3c34			 
3c34					; if c is set then set all '-' to spaces 
3c34					; need to also take into account .>  
3c34			 
3c34 3e 01				ld a, 1 
3c36 b9					cp c 
3c37 20 67				jr nz, .nodashswap 
3c39			 
3c39					; DE has the string to write, working with HL 
3c39			 
3c39 06 ff				ld b, 255 
3c3b d5					push de 
3c3c e1					pop hl 
3c3d			 
3c3d			if DEBUG_FORTH_DOT 
3c3d				DMARK "DT-" 
3c3d f5				push af  
3c3e 3a 52 3c			ld a, (.dmark)  
3c41 32 6b ee			ld (debug_mark),a  
3c44 3a 53 3c			ld a, (.dmark+1)  
3c47 32 6c ee			ld (debug_mark+1),a  
3c4a 3a 54 3c			ld a, (.dmark+2)  
3c4d 32 6d ee			ld (debug_mark+2),a  
3c50 18 03			jr .pastdmark  
3c52 ..			.dmark: db "DT-"  
3c55 f1			.pastdmark: pop af  
3c56			endm  
# End of macro DMARK
3c56				CALLMONITOR 
3c56 cd 6f ee			call debug_vector  
3c59				endm  
# End of macro CALLMONITOR
3c59			endif	 
3c59 7e			.dashscan:	ld a, (hl) 
3c5a fe 00				cp 0 
3c5c 28 42				jr z, .nodashswap 
3c5e fe 2d				cp '-' 
3c60 20 03				jr nz, .dashskip 
3c62 3e 20				ld a, ' ' 
3c64 77					ld (hl), a 
3c65 23			.dashskip:	inc hl 
3c66			if DEBUG_FORTH_DOT 
3c66				DMARK "D-2" 
3c66 f5				push af  
3c67 3a 7b 3c			ld a, (.dmark)  
3c6a 32 6b ee			ld (debug_mark),a  
3c6d 3a 7c 3c			ld a, (.dmark+1)  
3c70 32 6c ee			ld (debug_mark+1),a  
3c73 3a 7d 3c			ld a, (.dmark+2)  
3c76 32 6d ee			ld (debug_mark+2),a  
3c79 18 03			jr .pastdmark  
3c7b ..			.dmark: db "D-2"  
3c7e f1			.pastdmark: pop af  
3c7f			endm  
# End of macro DMARK
3c7f				CALLMONITOR 
3c7f cd 6f ee			call debug_vector  
3c82				endm  
# End of macro CALLMONITOR
3c82			endif	 
3c82 10 d5				djnz .dashscan 
3c84			 
3c84			if DEBUG_FORTH_DOT 
3c84				DMARK "D-1" 
3c84 f5				push af  
3c85 3a 99 3c			ld a, (.dmark)  
3c88 32 6b ee			ld (debug_mark),a  
3c8b 3a 9a 3c			ld a, (.dmark+1)  
3c8e 32 6c ee			ld (debug_mark+1),a  
3c91 3a 9b 3c			ld a, (.dmark+2)  
3c94 32 6d ee			ld (debug_mark+2),a  
3c97 18 03			jr .pastdmark  
3c99 ..			.dmark: db "D-1"  
3c9c f1			.pastdmark: pop af  
3c9d			endm  
# End of macro DMARK
3c9d				CALLMONITOR 
3c9d cd 6f ee			call debug_vector  
3ca0				endm  
# End of macro CALLMONITOR
3ca0			endif	 
3ca0			 
3ca0			.nodashswap: 
3ca0			 
3ca0			if DEBUG_FORTH_DOT 
3ca0				DMARK "D-o" 
3ca0 f5				push af  
3ca1 3a b5 3c			ld a, (.dmark)  
3ca4 32 6b ee			ld (debug_mark),a  
3ca7 3a b6 3c			ld a, (.dmark+1)  
3caa 32 6c ee			ld (debug_mark+1),a  
3cad 3a b7 3c			ld a, (.dmark+2)  
3cb0 32 6d ee			ld (debug_mark+2),a  
3cb3 18 03			jr .pastdmark  
3cb5 ..			.dmark: db "D-o"  
3cb8 f1			.pastdmark: pop af  
3cb9			endm  
# End of macro DMARK
3cb9				CALLMONITOR 
3cb9 cd 6f ee			call debug_vector  
3cbc				endm  
# End of macro CALLMONITOR
3cbc			endif	 
3cbc			 
3cbc d5					push de   ; save string start in case we need to advance print 
3cbd			 
3cbd 3a 5e ea				ld a, (f_cursor_ptr) 
3cc0 cd cc 0b				call str_at_display 
3cc3 3a 3c ea				ld a,(cli_autodisplay) 
3cc6 fe 00				cp 0 
3cc8 28 03				jr z, .noupdate 
3cca cd dc 0b						call update_display 
3ccd					.noupdate: 
3ccd			 
3ccd			 
3ccd					; see if we need to advance the print position 
3ccd			 
3ccd e1					pop hl   ; get back string 
3cce			;		ex de,hl 
3cce			 
3cce 3a 3d ea				ld a, (cli_mvdot) 
3cd1			if DEBUG_FORTH_DOT 
3cd1			;		ld e,a 
3cd1				DMARK "D>1" 
3cd1 f5				push af  
3cd2 3a e6 3c			ld a, (.dmark)  
3cd5 32 6b ee			ld (debug_mark),a  
3cd8 3a e7 3c			ld a, (.dmark+1)  
3cdb 32 6c ee			ld (debug_mark+1),a  
3cde 3a e8 3c			ld a, (.dmark+2)  
3ce1 32 6d ee			ld (debug_mark+2),a  
3ce4 18 03			jr .pastdmark  
3ce6 ..			.dmark: db "D>1"  
3ce9 f1			.pastdmark: pop af  
3cea			endm  
# End of macro DMARK
3cea				CALLMONITOR 
3cea cd 6f ee			call debug_vector  
3ced				endm  
# End of macro CALLMONITOR
3ced			endif	 
3ced fe 00				cp 0 
3cef 28 44				jr z, .noadv 
3cf1					; yes, lets advance the print position 
3cf1 3e 00				ld a, 0 
3cf3 cd 57 11				call strlent 
3cf6			if DEBUG_FORTH_DOT 
3cf6				DMARK "D-?" 
3cf6 f5				push af  
3cf7 3a 0b 3d			ld a, (.dmark)  
3cfa 32 6b ee			ld (debug_mark),a  
3cfd 3a 0c 3d			ld a, (.dmark+1)  
3d00 32 6c ee			ld (debug_mark+1),a  
3d03 3a 0d 3d			ld a, (.dmark+2)  
3d06 32 6d ee			ld (debug_mark+2),a  
3d09 18 03			jr .pastdmark  
3d0b ..			.dmark: db "D-?"  
3d0e f1			.pastdmark: pop af  
3d0f			endm  
# End of macro DMARK
3d0f				CALLMONITOR 
3d0f cd 6f ee			call debug_vector  
3d12				endm  
# End of macro CALLMONITOR
3d12			endif	 
3d12 3a 5e ea				ld a, (f_cursor_ptr) 
3d15 85					add a,l 
3d16					;call addatohl 
3d16					;ld a, l 
3d16 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3d19			 
3d19			if DEBUG_FORTH_DOT 
3d19				DMARK "D->" 
3d19 f5				push af  
3d1a 3a 2e 3d			ld a, (.dmark)  
3d1d 32 6b ee			ld (debug_mark),a  
3d20 3a 2f 3d			ld a, (.dmark+1)  
3d23 32 6c ee			ld (debug_mark+1),a  
3d26 3a 30 3d			ld a, (.dmark+2)  
3d29 32 6d ee			ld (debug_mark+2),a  
3d2c 18 03			jr .pastdmark  
3d2e ..			.dmark: db "D->"  
3d31 f1			.pastdmark: pop af  
3d32			endm  
# End of macro DMARK
3d32				CALLMONITOR 
3d32 cd 6f ee			call debug_vector  
3d35				endm  
# End of macro CALLMONITOR
3d35			endif	 
3d35			 
3d35			.noadv:	 
3d35			 
3d35					if DEBUG_FORTH_DOT_WAIT 
3d35							call next_page_prompt 
3d35					endif	 
3d35			; TODO this pop off the stack causes a crash. i dont know why 
3d35			 
3d35			 
3d35			if DEBUG_FORTH_DOT 
3d35				DMARK "DTh" 
3d35 f5				push af  
3d36 3a 4a 3d			ld a, (.dmark)  
3d39 32 6b ee			ld (debug_mark),a  
3d3c 3a 4b 3d			ld a, (.dmark+1)  
3d3f 32 6c ee			ld (debug_mark+1),a  
3d42 3a 4c 3d			ld a, (.dmark+2)  
3d45 32 6d ee			ld (debug_mark+2),a  
3d48 18 03			jr .pastdmark  
3d4a ..			.dmark: db "DTh"  
3d4d f1			.pastdmark: pop af  
3d4e			endm  
# End of macro DMARK
3d4e				CALLMONITOR 
3d4e cd 6f ee			call debug_vector  
3d51				endm  
# End of macro CALLMONITOR
3d51			endif	 
3d51			 
3d51					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d51 cd 1c 1e			call macro_forth_dsp_pop 
3d54				endm 
# End of macro FORTH_DSP_POP
3d54			 
3d54			if DEBUG_FORTH_DOT 
3d54				DMARK "DTi" 
3d54 f5				push af  
3d55 3a 69 3d			ld a, (.dmark)  
3d58 32 6b ee			ld (debug_mark),a  
3d5b 3a 6a 3d			ld a, (.dmark+1)  
3d5e 32 6c ee			ld (debug_mark+1),a  
3d61 3a 6b 3d			ld a, (.dmark+2)  
3d64 32 6d ee			ld (debug_mark+2),a  
3d67 18 03			jr .pastdmark  
3d69 ..			.dmark: db "DTi"  
3d6c f1			.pastdmark: pop af  
3d6d			endm  
# End of macro DMARK
3d6d				CALLMONITOR 
3d6d cd 6f ee			call debug_vector  
3d70				endm  
# End of macro CALLMONITOR
3d70			endif	 
3d70			 
3d70			 
3d70					NEXTW 
3d70 c3 1a 1f			jp macro_next 
3d73				endm 
# End of macro NEXTW
3d73			 
3d73			.CLS: 
3d73				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3d73 35				db WORD_SYS_CORE+33             
3d74 a0 3d			dw .DRAW            
3d76 04				db 3 + 1 
3d77 .. 00			db "CLS",0              
3d7b				endm 
# End of macro CWHEAD
3d7b			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3d7b					if DEBUG_FORTH_WORDS_KEY 
3d7b						DMARK "CLS" 
3d7b f5				push af  
3d7c 3a 90 3d			ld a, (.dmark)  
3d7f 32 6b ee			ld (debug_mark),a  
3d82 3a 91 3d			ld a, (.dmark+1)  
3d85 32 6c ee			ld (debug_mark+1),a  
3d88 3a 92 3d			ld a, (.dmark+2)  
3d8b 32 6d ee			ld (debug_mark+2),a  
3d8e 18 03			jr .pastdmark  
3d90 ..			.dmark: db "CLS"  
3d93 f1			.pastdmark: pop af  
3d94			endm  
# End of macro DMARK
3d94						CALLMONITOR 
3d94 cd 6f ee			call debug_vector  
3d97				endm  
# End of macro CALLMONITOR
3d97					endif 
3d97 cd b9 0b				call clear_display 
3d9a c3 ae 3e				jp .home		; and home cursor 
3d9d					NEXTW 
3d9d c3 1a 1f			jp macro_next 
3da0				endm 
# End of macro NEXTW
3da0			 
3da0			.DRAW: 
3da0				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3da0 36				db WORD_SYS_CORE+34             
3da1 cb 3d			dw .DUMP            
3da3 05				db 4 + 1 
3da4 .. 00			db "DRAW",0              
3da9				endm 
# End of macro CWHEAD
3da9			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3da9					if DEBUG_FORTH_WORDS_KEY 
3da9						DMARK "DRW" 
3da9 f5				push af  
3daa 3a be 3d			ld a, (.dmark)  
3dad 32 6b ee			ld (debug_mark),a  
3db0 3a bf 3d			ld a, (.dmark+1)  
3db3 32 6c ee			ld (debug_mark+1),a  
3db6 3a c0 3d			ld a, (.dmark+2)  
3db9 32 6d ee			ld (debug_mark+2),a  
3dbc 18 03			jr .pastdmark  
3dbe ..			.dmark: db "DRW"  
3dc1 f1			.pastdmark: pop af  
3dc2			endm  
# End of macro DMARK
3dc2						CALLMONITOR 
3dc2 cd 6f ee			call debug_vector  
3dc5				endm  
# End of macro CALLMONITOR
3dc5					endif 
3dc5 cd dc 0b				call update_display 
3dc8					NEXTW 
3dc8 c3 1a 1f			jp macro_next 
3dcb				endm 
# End of macro NEXTW
3dcb			 
3dcb			.DUMP: 
3dcb				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3dcb 37				db WORD_SYS_CORE+35             
3dcc 03 3e			dw .CDUMP            
3dce 05				db 4 + 1 
3dcf .. 00			db "DUMP",0              
3dd4				endm 
# End of macro CWHEAD
3dd4			; | DUMP ( x -- ) With address x display dump   | DONE 
3dd4			; TODO pop address to use off of the stack 
3dd4					if DEBUG_FORTH_WORDS_KEY 
3dd4						DMARK "DUM" 
3dd4 f5				push af  
3dd5 3a e9 3d			ld a, (.dmark)  
3dd8 32 6b ee			ld (debug_mark),a  
3ddb 3a ea 3d			ld a, (.dmark+1)  
3dde 32 6c ee			ld (debug_mark+1),a  
3de1 3a eb 3d			ld a, (.dmark+2)  
3de4 32 6d ee			ld (debug_mark+2),a  
3de7 18 03			jr .pastdmark  
3de9 ..			.dmark: db "DUM"  
3dec f1			.pastdmark: pop af  
3ded			endm  
# End of macro DMARK
3ded						CALLMONITOR 
3ded cd 6f ee			call debug_vector  
3df0				endm  
# End of macro CALLMONITOR
3df0					endif 
3df0 cd b9 0b				call clear_display 
3df3			 
3df3					; get address 
3df3			 
3df3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3df3 cd 64 1d			call macro_dsp_valuehl 
3df6				endm 
# End of macro FORTH_DSP_VALUEHL
3df6				 
3df6					; save it for cdump 
3df6			 
3df6 22 e4 e5				ld (os_cur_ptr),hl 
3df9			 
3df9					; destroy value TOS 
3df9			 
3df9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3df9 cd 1c 1e			call macro_forth_dsp_pop 
3dfc				endm 
# End of macro FORTH_DSP_POP
3dfc			 
3dfc cd ed 19				call dumpcont	; skip old style of param parsing	 
3dff c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3e00					NEXTW 
3e00 c3 1a 1f			jp macro_next 
3e03				endm 
# End of macro NEXTW
3e03			.CDUMP: 
3e03				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3e03 38				db WORD_SYS_CORE+36             
3e04 33 3e			dw .DAT            
3e06 06				db 5 + 1 
3e07 .. 00			db "CDUMP",0              
3e0d				endm 
# End of macro CWHEAD
3e0d			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3e0d					if DEBUG_FORTH_WORDS_KEY 
3e0d						DMARK "CDP" 
3e0d f5				push af  
3e0e 3a 22 3e			ld a, (.dmark)  
3e11 32 6b ee			ld (debug_mark),a  
3e14 3a 23 3e			ld a, (.dmark+1)  
3e17 32 6c ee			ld (debug_mark+1),a  
3e1a 3a 24 3e			ld a, (.dmark+2)  
3e1d 32 6d ee			ld (debug_mark+2),a  
3e20 18 03			jr .pastdmark  
3e22 ..			.dmark: db "CDP"  
3e25 f1			.pastdmark: pop af  
3e26			endm  
# End of macro DMARK
3e26						CALLMONITOR 
3e26 cd 6f ee			call debug_vector  
3e29				endm  
# End of macro CALLMONITOR
3e29					endif 
3e29 cd b9 0b				call clear_display 
3e2c cd ed 19				call dumpcont	 
3e2f c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3e30					NEXTW 
3e30 c3 1a 1f			jp macro_next 
3e33				endm 
# End of macro NEXTW
3e33			 
3e33			 
3e33			 
3e33			 
3e33			.DAT: 
3e33				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3e33 3d				db WORD_SYS_CORE+41             
3e34 89 3e			dw .HOME            
3e36 03				db 2 + 1 
3e37 .. 00			db "AT",0              
3e3a				endm 
# End of macro CWHEAD
3e3a			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3e3a					if DEBUG_FORTH_WORDS_KEY 
3e3a						DMARK "AT." 
3e3a f5				push af  
3e3b 3a 4f 3e			ld a, (.dmark)  
3e3e 32 6b ee			ld (debug_mark),a  
3e41 3a 50 3e			ld a, (.dmark+1)  
3e44 32 6c ee			ld (debug_mark+1),a  
3e47 3a 51 3e			ld a, (.dmark+2)  
3e4a 32 6d ee			ld (debug_mark+2),a  
3e4d 18 03			jr .pastdmark  
3e4f ..			.dmark: db "AT."  
3e52 f1			.pastdmark: pop af  
3e53			endm  
# End of macro DMARK
3e53						CALLMONITOR 
3e53 cd 6f ee			call debug_vector  
3e56				endm  
# End of macro CALLMONITOR
3e56					endif 
3e56					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e56 cd 64 1d			call macro_dsp_valuehl 
3e59				endm 
# End of macro FORTH_DSP_VALUEHL
3e59			 
3e59			 
3e59					; TODO save cursor row 
3e59 7d					ld a,l 
3e5a fe 02				cp 2 
3e5c 20 04				jr nz, .crow3 
3e5e 3e 28				ld a, display_row_2 
3e60 18 12				jr .ccol1 
3e62 fe 03		.crow3:		cp 3 
3e64 20 04				jr nz, .crow4 
3e66 3e 50				ld a, display_row_3 
3e68 18 0a				jr .ccol1 
3e6a fe 04		.crow4:		cp 4 
3e6c 20 04				jr nz, .crow1 
3e6e 3e 78				ld a, display_row_4 
3e70 18 02				jr .ccol1 
3e72 3e 00		.crow1:		ld a,display_row_1 
3e74 f5			.ccol1:		push af			; got row offset 
3e75 6f					ld l,a 
3e76 26 00				ld h,0 
3e78					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e78 cd 1c 1e			call macro_forth_dsp_pop 
3e7b				endm 
# End of macro FORTH_DSP_POP
3e7b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e7b cd 64 1d			call macro_dsp_valuehl 
3e7e				endm 
# End of macro FORTH_DSP_VALUEHL
3e7e					; TODO save cursor col 
3e7e f1					pop af 
3e7f 85					add l		; add col offset 
3e80 32 5e ea				ld (f_cursor_ptr), a 
3e83					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e83 cd 1c 1e			call macro_forth_dsp_pop 
3e86				endm 
# End of macro FORTH_DSP_POP
3e86			 
3e86					; calculate  
3e86			 
3e86					NEXTW 
3e86 c3 1a 1f			jp macro_next 
3e89				endm 
# End of macro NEXTW
3e89			 
3e89			 
3e89			.HOME: 
3e89				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
3e89 41				db WORD_SYS_CORE+45             
3e8a b6 3e			dw .CR            
3e8c 05				db 4 + 1 
3e8d .. 00			db "HOME",0              
3e92				endm 
# End of macro CWHEAD
3e92			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3e92					if DEBUG_FORTH_WORDS_KEY 
3e92						DMARK "HOM" 
3e92 f5				push af  
3e93 3a a7 3e			ld a, (.dmark)  
3e96 32 6b ee			ld (debug_mark),a  
3e99 3a a8 3e			ld a, (.dmark+1)  
3e9c 32 6c ee			ld (debug_mark+1),a  
3e9f 3a a9 3e			ld a, (.dmark+2)  
3ea2 32 6d ee			ld (debug_mark+2),a  
3ea5 18 03			jr .pastdmark  
3ea7 ..			.dmark: db "HOM"  
3eaa f1			.pastdmark: pop af  
3eab			endm  
# End of macro DMARK
3eab						CALLMONITOR 
3eab cd 6f ee			call debug_vector  
3eae				endm  
# End of macro CALLMONITOR
3eae					endif 
3eae 3e 00		.home:		ld a, 0		; and home cursor 
3eb0 32 5e ea				ld (f_cursor_ptr), a 
3eb3					NEXTW 
3eb3 c3 1a 1f			jp macro_next 
3eb6				endm 
# End of macro NEXTW
3eb6			 
3eb6			 
3eb6			.CR: 
3eb6				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
3eb6 46				db WORD_SYS_CORE+50             
3eb7 f1 3e			dw .SPACE            
3eb9 03				db 2 + 1 
3eba .. 00			db "CR",0              
3ebd				endm 
# End of macro CWHEAD
3ebd			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
3ebd					if DEBUG_FORTH_WORDS_KEY 
3ebd						DMARK "CR." 
3ebd f5				push af  
3ebe 3a d2 3e			ld a, (.dmark)  
3ec1 32 6b ee			ld (debug_mark),a  
3ec4 3a d3 3e			ld a, (.dmark+1)  
3ec7 32 6c ee			ld (debug_mark+1),a  
3eca 3a d4 3e			ld a, (.dmark+2)  
3ecd 32 6d ee			ld (debug_mark+2),a  
3ed0 18 03			jr .pastdmark  
3ed2 ..			.dmark: db "CR."  
3ed5 f1			.pastdmark: pop af  
3ed6			endm  
# End of macro DMARK
3ed6						CALLMONITOR 
3ed6 cd 6f ee			call debug_vector  
3ed9				endm  
# End of macro CALLMONITOR
3ed9					endif 
3ed9 3e 0d				ld a, 13 
3edb 32 c1 e2				ld (scratch),a 
3ede 3e 0a				ld a, 10 
3ee0 32 c2 e2				ld (scratch+1),a 
3ee3 3e 00				ld a, 0 
3ee5 32 c3 e2				ld (scratch+2),a 
3ee8 21 c1 e2				ld hl, scratch 
3eeb cd db 1b				call forth_push_str 
3eee					 
3eee				       NEXTW 
3eee c3 1a 1f			jp macro_next 
3ef1				endm 
# End of macro NEXTW
3ef1			.SPACE: 
3ef1				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3ef1 46				db WORD_SYS_CORE+50             
3ef2 27 3f			dw .SPACES            
3ef4 03				db 2 + 1 
3ef5 .. 00			db "BL",0              
3ef8				endm 
# End of macro CWHEAD
3ef8			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3ef8					if DEBUG_FORTH_WORDS_KEY 
3ef8						DMARK "BL." 
3ef8 f5				push af  
3ef9 3a 0d 3f			ld a, (.dmark)  
3efc 32 6b ee			ld (debug_mark),a  
3eff 3a 0e 3f			ld a, (.dmark+1)  
3f02 32 6c ee			ld (debug_mark+1),a  
3f05 3a 0f 3f			ld a, (.dmark+2)  
3f08 32 6d ee			ld (debug_mark+2),a  
3f0b 18 03			jr .pastdmark  
3f0d ..			.dmark: db "BL."  
3f10 f1			.pastdmark: pop af  
3f11			endm  
# End of macro DMARK
3f11						CALLMONITOR 
3f11 cd 6f ee			call debug_vector  
3f14				endm  
# End of macro CALLMONITOR
3f14					endif 
3f14 3e 20				ld a, " " 
3f16 32 c1 e2				ld (scratch),a 
3f19 3e 00				ld a, 0 
3f1b 32 c2 e2				ld (scratch+1),a 
3f1e 21 c1 e2				ld hl, scratch 
3f21 cd db 1b				call forth_push_str 
3f24					 
3f24				       NEXTW 
3f24 c3 1a 1f			jp macro_next 
3f27				endm 
# End of macro NEXTW
3f27			 
3f27			;.blstr: db " ", 0 
3f27			 
3f27			.SPACES: 
3f27				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3f27 47				db WORD_SYS_CORE+51             
3f28 c2 3f			dw .SCROLL            
3f2a 07				db 6 + 1 
3f2b .. 00			db "SPACES",0              
3f32				endm 
# End of macro CWHEAD
3f32			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
3f32					if DEBUG_FORTH_WORDS_KEY 
3f32						DMARK "SPS" 
3f32 f5				push af  
3f33 3a 47 3f			ld a, (.dmark)  
3f36 32 6b ee			ld (debug_mark),a  
3f39 3a 48 3f			ld a, (.dmark+1)  
3f3c 32 6c ee			ld (debug_mark+1),a  
3f3f 3a 49 3f			ld a, (.dmark+2)  
3f42 32 6d ee			ld (debug_mark+2),a  
3f45 18 03			jr .pastdmark  
3f47 ..			.dmark: db "SPS"  
3f4a f1			.pastdmark: pop af  
3f4b			endm  
# End of macro DMARK
3f4b						CALLMONITOR 
3f4b cd 6f ee			call debug_vector  
3f4e				endm  
# End of macro CALLMONITOR
3f4e					endif 
3f4e			 
3f4e			 
3f4e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f4e cd 64 1d			call macro_dsp_valuehl 
3f51				endm 
# End of macro FORTH_DSP_VALUEHL
3f51			 
3f51 e5					push hl    ; u 
3f52					if DEBUG_FORTH_WORDS 
3f52						DMARK "SPA" 
3f52 f5				push af  
3f53 3a 67 3f			ld a, (.dmark)  
3f56 32 6b ee			ld (debug_mark),a  
3f59 3a 68 3f			ld a, (.dmark+1)  
3f5c 32 6c ee			ld (debug_mark+1),a  
3f5f 3a 69 3f			ld a, (.dmark+2)  
3f62 32 6d ee			ld (debug_mark+2),a  
3f65 18 03			jr .pastdmark  
3f67 ..			.dmark: db "SPA"  
3f6a f1			.pastdmark: pop af  
3f6b			endm  
# End of macro DMARK
3f6b						CALLMONITOR 
3f6b cd 6f ee			call debug_vector  
3f6e				endm  
# End of macro CALLMONITOR
3f6e					endif 
3f6e			 
3f6e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f6e cd 1c 1e			call macro_forth_dsp_pop 
3f71				endm 
# End of macro FORTH_DSP_POP
3f71 e1					pop hl 
3f72 0e 00				ld c, 0 
3f74 45					ld b, l 
3f75 21 c1 e2				ld hl, scratch  
3f78			 
3f78					if DEBUG_FORTH_WORDS 
3f78						DMARK "SP2" 
3f78 f5				push af  
3f79 3a 8d 3f			ld a, (.dmark)  
3f7c 32 6b ee			ld (debug_mark),a  
3f7f 3a 8e 3f			ld a, (.dmark+1)  
3f82 32 6c ee			ld (debug_mark+1),a  
3f85 3a 8f 3f			ld a, (.dmark+2)  
3f88 32 6d ee			ld (debug_mark+2),a  
3f8b 18 03			jr .pastdmark  
3f8d ..			.dmark: db "SP2"  
3f90 f1			.pastdmark: pop af  
3f91			endm  
# End of macro DMARK
3f91						CALLMONITOR 
3f91 cd 6f ee			call debug_vector  
3f94				endm  
# End of macro CALLMONITOR
3f94					endif 
3f94 3e 20				ld a, ' ' 
3f96			.spaces1:	 
3f96 77					ld (hl),a 
3f97 23					inc hl 
3f98					 
3f98 10 fc				djnz .spaces1 
3f9a 3e 00				ld a,0 
3f9c 77					ld (hl),a 
3f9d 21 c1 e2				ld hl, scratch 
3fa0					if DEBUG_FORTH_WORDS 
3fa0						DMARK "SP3" 
3fa0 f5				push af  
3fa1 3a b5 3f			ld a, (.dmark)  
3fa4 32 6b ee			ld (debug_mark),a  
3fa7 3a b6 3f			ld a, (.dmark+1)  
3faa 32 6c ee			ld (debug_mark+1),a  
3fad 3a b7 3f			ld a, (.dmark+2)  
3fb0 32 6d ee			ld (debug_mark+2),a  
3fb3 18 03			jr .pastdmark  
3fb5 ..			.dmark: db "SP3"  
3fb8 f1			.pastdmark: pop af  
3fb9			endm  
# End of macro DMARK
3fb9						CALLMONITOR 
3fb9 cd 6f ee			call debug_vector  
3fbc				endm  
# End of macro CALLMONITOR
3fbc					endif 
3fbc cd db 1b				call forth_push_str 
3fbf			 
3fbf				       NEXTW 
3fbf c3 1a 1f			jp macro_next 
3fc2				endm 
# End of macro NEXTW
3fc2			 
3fc2			 
3fc2			 
3fc2			.SCROLL: 
3fc2				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3fc2 53				db WORD_SYS_CORE+63             
3fc3 ef 3f			dw .SCROLLD            
3fc5 07				db 6 + 1 
3fc6 .. 00			db "SCROLL",0              
3fcd				endm 
# End of macro CWHEAD
3fcd			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3fcd					if DEBUG_FORTH_WORDS_KEY 
3fcd						DMARK "SCR" 
3fcd f5				push af  
3fce 3a e2 3f			ld a, (.dmark)  
3fd1 32 6b ee			ld (debug_mark),a  
3fd4 3a e3 3f			ld a, (.dmark+1)  
3fd7 32 6c ee			ld (debug_mark+1),a  
3fda 3a e4 3f			ld a, (.dmark+2)  
3fdd 32 6d ee			ld (debug_mark+2),a  
3fe0 18 03			jr .pastdmark  
3fe2 ..			.dmark: db "SCR"  
3fe5 f1			.pastdmark: pop af  
3fe6			endm  
# End of macro DMARK
3fe6						CALLMONITOR 
3fe6 cd 6f ee			call debug_vector  
3fe9				endm  
# End of macro CALLMONITOR
3fe9					endif 
3fe9			 
3fe9 cd 7b 0b			call scroll_up 
3fec			;	call update_display 
3fec			 
3fec					NEXTW 
3fec c3 1a 1f			jp macro_next 
3fef				endm 
# End of macro NEXTW
3fef			 
3fef			 
3fef			 
3fef			;		; get dir 
3fef			; 
3fef			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fef			; 
3fef			;		push hl 
3fef			; 
3fef			;		; destroy value TOS 
3fef			; 
3fef			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fef			; 
3fef			;		; get count 
3fef			; 
3fef			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fef			; 
3fef			;		push hl 
3fef			; 
3fef			;		; destroy value TOS 
3fef			; 
3fef			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fef			; 
3fef			;		; one value on hl get other one back 
3fef			; 
3fef			;		pop bc    ; count 
3fef			; 
3fef			;		pop de   ; dir 
3fef			; 
3fef			; 
3fef			;		ld b, c 
3fef			; 
3fef			;.scrolldir:     push bc 
3fef			;		push de 
3fef			; 
3fef			;		ld a, 0 
3fef			;		cp e 
3fef			;		jr z, .scrollup  
3fef			;		call scroll_down 
3fef			;		jr .scrollnext 
3fef			;.scrollup:	call scroll_up 
3fef			; 
3fef			;		 
3fef			;.scrollnext: 
3fef			;		pop de 
3fef			;		pop bc 
3fef			;		djnz .scrolldir 
3fef			; 
3fef			; 
3fef			; 
3fef			; 
3fef			; 
3fef			;		NEXTW 
3fef			 
3fef			.SCROLLD: 
3fef				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3fef 53				db WORD_SYS_CORE+63             
3ff0 1d 40			dw .ATQ            
3ff2 08				db 7 + 1 
3ff3 .. 00			db "SCROLLD",0              
3ffb				endm 
# End of macro CWHEAD
3ffb			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3ffb					if DEBUG_FORTH_WORDS_KEY 
3ffb						DMARK "SCD" 
3ffb f5				push af  
3ffc 3a 10 40			ld a, (.dmark)  
3fff 32 6b ee			ld (debug_mark),a  
4002 3a 11 40			ld a, (.dmark+1)  
4005 32 6c ee			ld (debug_mark+1),a  
4008 3a 12 40			ld a, (.dmark+2)  
400b 32 6d ee			ld (debug_mark+2),a  
400e 18 03			jr .pastdmark  
4010 ..			.dmark: db "SCD"  
4013 f1			.pastdmark: pop af  
4014			endm  
# End of macro DMARK
4014						CALLMONITOR 
4014 cd 6f ee			call debug_vector  
4017				endm  
# End of macro CALLMONITOR
4017					endif 
4017			 
4017 cd 9f 0b			call scroll_down 
401a			;	call update_display 
401a			 
401a					NEXTW 
401a c3 1a 1f			jp macro_next 
401d				endm 
# End of macro NEXTW
401d			 
401d			 
401d			.ATQ: 
401d				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
401d 62				db WORD_SYS_CORE+78             
401e 7b 40			dw .AUTODSP            
4020 04				db 3 + 1 
4021 .. 00			db "AT@",0              
4025				endm 
# End of macro CWHEAD
4025			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
4025					if DEBUG_FORTH_WORDS_KEY 
4025						DMARK "ATA" 
4025 f5				push af  
4026 3a 3a 40			ld a, (.dmark)  
4029 32 6b ee			ld (debug_mark),a  
402c 3a 3b 40			ld a, (.dmark+1)  
402f 32 6c ee			ld (debug_mark+1),a  
4032 3a 3c 40			ld a, (.dmark+2)  
4035 32 6d ee			ld (debug_mark+2),a  
4038 18 03			jr .pastdmark  
403a ..			.dmark: db "ATA"  
403d f1			.pastdmark: pop af  
403e			endm  
# End of macro DMARK
403e						CALLMONITOR 
403e cd 6f ee			call debug_vector  
4041				endm  
# End of macro CALLMONITOR
4041					endif 
4041			 
4041			 
4041					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4041 cd 64 1d			call macro_dsp_valuehl 
4044				endm 
# End of macro FORTH_DSP_VALUEHL
4044			 
4044					; TODO save cursor row 
4044 7d					ld a,l 
4045 fe 02				cp 2 
4047 20 04				jr nz, .crow3aq 
4049 3e 28				ld a, display_row_2 
404b 18 12				jr .ccol1aq 
404d fe 03		.crow3aq:		cp 3 
404f 20 04				jr nz, .crow4aq 
4051 3e 50				ld a, display_row_3 
4053 18 0a				jr .ccol1aq 
4055 fe 04		.crow4aq:		cp 4 
4057 20 04				jr nz, .crow1aq 
4059 3e 78				ld a, display_row_4 
405b 18 02				jr .ccol1aq 
405d 3e 00		.crow1aq:		ld a,display_row_1 
405f f5			.ccol1aq:		push af			; got row offset 
4060 6f					ld l,a 
4061 26 00				ld h,0 
4063					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4063 cd 1c 1e			call macro_forth_dsp_pop 
4066				endm 
# End of macro FORTH_DSP_POP
4066					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4066 cd 64 1d			call macro_dsp_valuehl 
4069				endm 
# End of macro FORTH_DSP_VALUEHL
4069					; TODO save cursor col 
4069 f1					pop af 
406a 85					add l		; add col offset 
406b			 
406b					; add current frame buffer address 
406b 2a cc eb				ld hl, (display_fb_active) 
406e cd e6 0d				call addatohl 
4071			 
4071			 
4071			 
4071			 
4071					; get char frame buffer location offset in hl 
4071			 
4071 7e					ld a,(hl) 
4072 26 00				ld h, 0 
4074 6f					ld l, a 
4075			 
4075 cd 6d 1b				call forth_push_numhl 
4078			 
4078			 
4078					NEXTW 
4078 c3 1a 1f			jp macro_next 
407b				endm 
# End of macro NEXTW
407b			 
407b			.AUTODSP: 
407b				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
407b 63				db WORD_SYS_CORE+79             
407c 91 40			dw .MENU            
407e 05				db 4 + 1 
407f .. 00			db "ADSP",0              
4084				endm 
# End of macro CWHEAD
4084			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4084			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4084			 
4084					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4084 cd 64 1d			call macro_dsp_valuehl 
4087				endm 
# End of macro FORTH_DSP_VALUEHL
4087			 
4087			;		push hl 
4087			 
4087					; destroy value TOS 
4087			 
4087					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4087 cd 1c 1e			call macro_forth_dsp_pop 
408a				endm 
# End of macro FORTH_DSP_POP
408a			 
408a			;		pop hl 
408a			 
408a 7d					ld a,l 
408b 32 3c ea				ld (cli_autodisplay), a 
408e				       NEXTW 
408e c3 1a 1f			jp macro_next 
4091				endm 
# End of macro NEXTW
4091			 
4091			.MENU: 
4091				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4091 70				db WORD_SYS_CORE+92             
4092 3a 41			dw .ENDDISPLAY            
4094 05				db 4 + 1 
4095 .. 00			db "MENU",0              
409a				endm 
# End of macro CWHEAD
409a			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
409a			 
409a			;		; get number of items on the stack 
409a			; 
409a				 
409a					FORTH_DSP_VALUEHL 
409a cd 64 1d			call macro_dsp_valuehl 
409d				endm 
# End of macro FORTH_DSP_VALUEHL
409d				 
409d					if DEBUG_FORTH_WORDS_KEY 
409d						DMARK "MNU" 
409d f5				push af  
409e 3a b2 40			ld a, (.dmark)  
40a1 32 6b ee			ld (debug_mark),a  
40a4 3a b3 40			ld a, (.dmark+1)  
40a7 32 6c ee			ld (debug_mark+1),a  
40aa 3a b4 40			ld a, (.dmark+2)  
40ad 32 6d ee			ld (debug_mark+2),a  
40b0 18 03			jr .pastdmark  
40b2 ..			.dmark: db "MNU"  
40b5 f1			.pastdmark: pop af  
40b6			endm  
# End of macro DMARK
40b6						CALLMONITOR 
40b6 cd 6f ee			call debug_vector  
40b9				endm  
# End of macro CALLMONITOR
40b9					endif 
40b9			 
40b9 45					ld b, l	 
40ba 05					dec b 
40bb			 
40bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40bb cd 1c 1e			call macro_forth_dsp_pop 
40be				endm 
# End of macro FORTH_DSP_POP
40be			 
40be			 
40be					; go directly through the stack to pluck out the string pointers and build an array 
40be			 
40be			;		FORTH_DSP 
40be			 
40be					; hl contains top most stack item 
40be				 
40be 11 c1 e2				ld de, scratch 
40c1			 
40c1			.mbuild: 
40c1			 
40c1					FORTH_DSP_VALUEHL 
40c1 cd 64 1d			call macro_dsp_valuehl 
40c4				endm 
# End of macro FORTH_DSP_VALUEHL
40c4			 
40c4					if DEBUG_FORTH_WORDS 
40c4						DMARK "MN3" 
40c4 f5				push af  
40c5 3a d9 40			ld a, (.dmark)  
40c8 32 6b ee			ld (debug_mark),a  
40cb 3a da 40			ld a, (.dmark+1)  
40ce 32 6c ee			ld (debug_mark+1),a  
40d1 3a db 40			ld a, (.dmark+2)  
40d4 32 6d ee			ld (debug_mark+2),a  
40d7 18 03			jr .pastdmark  
40d9 ..			.dmark: db "MN3"  
40dc f1			.pastdmark: pop af  
40dd			endm  
# End of macro DMARK
40dd						CALLMONITOR 
40dd cd 6f ee			call debug_vector  
40e0				endm  
# End of macro CALLMONITOR
40e0					endif 
40e0 eb					ex de, hl 
40e1 73					ld (hl), e 
40e2 23					inc hl 
40e3 72					ld (hl), d 
40e4 23					inc hl 
40e5 eb					ex de, hl 
40e6			 
40e6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40e6 cd 1c 1e			call macro_forth_dsp_pop 
40e9				endm 
# End of macro FORTH_DSP_POP
40e9			 
40e9 10 d6				djnz .mbuild 
40eb			 
40eb					; done add term 
40eb			 
40eb eb					ex de, hl 
40ec 36 00				ld (hl), 0 
40ee 23					inc hl 
40ef 36 00				ld (hl), 0 
40f1			 
40f1				 
40f1					 
40f1 21 c1 e2				ld hl, scratch 
40f4			 
40f4					if DEBUG_FORTH_WORDS 
40f4						DMARK "MNx" 
40f4 f5				push af  
40f5 3a 09 41			ld a, (.dmark)  
40f8 32 6b ee			ld (debug_mark),a  
40fb 3a 0a 41			ld a, (.dmark+1)  
40fe 32 6c ee			ld (debug_mark+1),a  
4101 3a 0b 41			ld a, (.dmark+2)  
4104 32 6d ee			ld (debug_mark+2),a  
4107 18 03			jr .pastdmark  
4109 ..			.dmark: db "MNx"  
410c f1			.pastdmark: pop af  
410d			endm  
# End of macro DMARK
410d						CALLMONITOR 
410d cd 6f ee			call debug_vector  
4110				endm  
# End of macro CALLMONITOR
4110					endif 
4110			 
4110			 
4110			 
4110 3e 00				ld a, 0 
4112 cd ea 0b				call menu 
4115			 
4115			 
4115 6f					ld l, a 
4116 26 00				ld h, 0 
4118			 
4118					if DEBUG_FORTH_WORDS 
4118						DMARK "MNr" 
4118 f5				push af  
4119 3a 2d 41			ld a, (.dmark)  
411c 32 6b ee			ld (debug_mark),a  
411f 3a 2e 41			ld a, (.dmark+1)  
4122 32 6c ee			ld (debug_mark+1),a  
4125 3a 2f 41			ld a, (.dmark+2)  
4128 32 6d ee			ld (debug_mark+2),a  
412b 18 03			jr .pastdmark  
412d ..			.dmark: db "MNr"  
4130 f1			.pastdmark: pop af  
4131			endm  
# End of macro DMARK
4131						CALLMONITOR 
4131 cd 6f ee			call debug_vector  
4134				endm  
# End of macro CALLMONITOR
4134					endif 
4134			 
4134 cd 6d 1b				call forth_push_numhl 
4137			 
4137			 
4137			 
4137			 
4137				       NEXTW 
4137 c3 1a 1f			jp macro_next 
413a				endm 
# End of macro NEXTW
413a			 
413a			 
413a			.ENDDISPLAY: 
413a			 
413a			; eof 
# End of file forth_words_display.asm
413a			include "forth_words_str.asm" 
413a			 
413a			; | ## String Words 
413a			 
413a			.PTR:   
413a			 
413a				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
413a 48				db WORD_SYS_CORE+52             
413b 67 41			dw .STYPE            
413d 04				db 3 + 1 
413e .. 00			db "PTR",0              
4142				endm 
# End of macro CWHEAD
4142			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4142			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4142			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4142			 
4142					if DEBUG_FORTH_WORDS_KEY 
4142						DMARK "PTR" 
4142 f5				push af  
4143 3a 57 41			ld a, (.dmark)  
4146 32 6b ee			ld (debug_mark),a  
4149 3a 58 41			ld a, (.dmark+1)  
414c 32 6c ee			ld (debug_mark+1),a  
414f 3a 59 41			ld a, (.dmark+2)  
4152 32 6d ee			ld (debug_mark+2),a  
4155 18 03			jr .pastdmark  
4157 ..			.dmark: db "PTR"  
415a f1			.pastdmark: pop af  
415b			endm  
# End of macro DMARK
415b						CALLMONITOR 
415b cd 6f ee			call debug_vector  
415e				endm  
# End of macro CALLMONITOR
415e					endif 
415e					FORTH_DSP_VALUEHL 
415e cd 64 1d			call macro_dsp_valuehl 
4161				endm 
# End of macro FORTH_DSP_VALUEHL
4161 cd 6d 1b				call forth_push_numhl 
4164			 
4164			 
4164					NEXTW 
4164 c3 1a 1f			jp macro_next 
4167				endm 
# End of macro NEXTW
4167			.STYPE: 
4167				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4167 48				db WORD_SYS_CORE+52             
4168 b6 41			dw .UPPER            
416a 06				db 5 + 1 
416b .. 00			db "STYPE",0              
4171				endm 
# End of macro CWHEAD
4171			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4171					if DEBUG_FORTH_WORDS_KEY 
4171						DMARK "STY" 
4171 f5				push af  
4172 3a 86 41			ld a, (.dmark)  
4175 32 6b ee			ld (debug_mark),a  
4178 3a 87 41			ld a, (.dmark+1)  
417b 32 6c ee			ld (debug_mark+1),a  
417e 3a 88 41			ld a, (.dmark+2)  
4181 32 6d ee			ld (debug_mark+2),a  
4184 18 03			jr .pastdmark  
4186 ..			.dmark: db "STY"  
4189 f1			.pastdmark: pop af  
418a			endm  
# End of macro DMARK
418a						CALLMONITOR 
418a cd 6f ee			call debug_vector  
418d				endm  
# End of macro CALLMONITOR
418d					endif 
418d					FORTH_DSP 
418d cd 2a 1d			call macro_forth_dsp 
4190				endm 
# End of macro FORTH_DSP
4190					;v5 FORTH_DSP_VALUE 
4190			 
4190 7e					ld a, (hl) 
4191			 
4191 f5					push af 
4192			 
4192			; Dont destroy TOS		FORTH_DSP_POP 
4192			 
4192 f1					pop af 
4193			 
4193 fe 01				cp DS_TYPE_STR 
4195 28 09				jr z, .typestr 
4197			 
4197 fe 02				cp DS_TYPE_INUM 
4199 28 0a				jr z, .typeinum 
419b			 
419b 21 b4 41				ld hl, .tna 
419e 18 0a				jr .tpush 
41a0			 
41a0 21 b0 41		.typestr:	ld hl, .tstr 
41a3 18 05				jr .tpush 
41a5 21 b2 41		.typeinum:	ld hl, .tinum 
41a8 18 00				jr .tpush 
41aa			 
41aa			.tpush: 
41aa			 
41aa cd db 1b				call forth_push_str 
41ad			 
41ad					NEXTW 
41ad c3 1a 1f			jp macro_next 
41b0				endm 
# End of macro NEXTW
41b0 .. 00		.tstr:	db "s",0 
41b2 .. 00		.tinum:  db "i",0 
41b4 .. 00		.tna:   db "?", 0 
41b6			 
41b6			 
41b6			.UPPER: 
41b6				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
41b6 48				db WORD_SYS_CORE+52             
41b7 f1 41			dw .LOWER            
41b9 06				db 5 + 1 
41ba .. 00			db "UPPER",0              
41c0				endm 
# End of macro CWHEAD
41c0			; | UPPER ( s -- s ) Upper case string s  | DONE 
41c0					if DEBUG_FORTH_WORDS_KEY 
41c0						DMARK "UPR" 
41c0 f5				push af  
41c1 3a d5 41			ld a, (.dmark)  
41c4 32 6b ee			ld (debug_mark),a  
41c7 3a d6 41			ld a, (.dmark+1)  
41ca 32 6c ee			ld (debug_mark+1),a  
41cd 3a d7 41			ld a, (.dmark+2)  
41d0 32 6d ee			ld (debug_mark+2),a  
41d3 18 03			jr .pastdmark  
41d5 ..			.dmark: db "UPR"  
41d8 f1			.pastdmark: pop af  
41d9			endm  
# End of macro DMARK
41d9						CALLMONITOR 
41d9 cd 6f ee			call debug_vector  
41dc				endm  
# End of macro CALLMONITOR
41dc					endif 
41dc			 
41dc					FORTH_DSP 
41dc cd 2a 1d			call macro_forth_dsp 
41df				endm 
# End of macro FORTH_DSP
41df					 
41df			; TODO check is string type 
41df			 
41df					FORTH_DSP_VALUEHL 
41df cd 64 1d			call macro_dsp_valuehl 
41e2				endm 
# End of macro FORTH_DSP_VALUEHL
41e2			; get pointer to string in hl 
41e2			 
41e2 7e			.toup:		ld a, (hl) 
41e3 fe 00				cp 0 
41e5 28 07				jr z, .toupdone 
41e7			 
41e7 cd 5b 10				call to_upper 
41ea			 
41ea 77					ld (hl), a 
41eb 23					inc hl 
41ec 18 f4				jr .toup 
41ee			 
41ee					 
41ee			 
41ee			 
41ee			; for each char convert to upper 
41ee					 
41ee			.toupdone: 
41ee			 
41ee			 
41ee					NEXTW 
41ee c3 1a 1f			jp macro_next 
41f1				endm 
# End of macro NEXTW
41f1			.LOWER: 
41f1				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
41f1 48				db WORD_SYS_CORE+52             
41f2 2c 42			dw .TCASE            
41f4 06				db 5 + 1 
41f5 .. 00			db "LOWER",0              
41fb				endm 
# End of macro CWHEAD
41fb			; | LOWER ( s -- s ) Lower case string s  | DONE 
41fb					if DEBUG_FORTH_WORDS_KEY 
41fb						DMARK "LWR" 
41fb f5				push af  
41fc 3a 10 42			ld a, (.dmark)  
41ff 32 6b ee			ld (debug_mark),a  
4202 3a 11 42			ld a, (.dmark+1)  
4205 32 6c ee			ld (debug_mark+1),a  
4208 3a 12 42			ld a, (.dmark+2)  
420b 32 6d ee			ld (debug_mark+2),a  
420e 18 03			jr .pastdmark  
4210 ..			.dmark: db "LWR"  
4213 f1			.pastdmark: pop af  
4214			endm  
# End of macro DMARK
4214						CALLMONITOR 
4214 cd 6f ee			call debug_vector  
4217				endm  
# End of macro CALLMONITOR
4217					endif 
4217			 
4217					FORTH_DSP 
4217 cd 2a 1d			call macro_forth_dsp 
421a				endm 
# End of macro FORTH_DSP
421a					 
421a			; TODO check is string type 
421a			 
421a					FORTH_DSP_VALUEHL 
421a cd 64 1d			call macro_dsp_valuehl 
421d				endm 
# End of macro FORTH_DSP_VALUEHL
421d			; get pointer to string in hl 
421d			 
421d 7e			.tolow:		ld a, (hl) 
421e fe 00				cp 0 
4220 28 07				jr z, .tolowdone 
4222			 
4222 cd 64 10				call to_lower 
4225			 
4225 77					ld (hl), a 
4226 23					inc hl 
4227 18 f4				jr .tolow 
4229			 
4229					 
4229			 
4229			 
4229			; for each char convert to low 
4229					 
4229			.tolowdone: 
4229					NEXTW 
4229 c3 1a 1f			jp macro_next 
422c				endm 
# End of macro NEXTW
422c			.TCASE: 
422c				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
422c 48				db WORD_SYS_CORE+52             
422d 62 43			dw .SUBSTR            
422f 06				db 5 + 1 
4230 .. 00			db "TCASE",0              
4236				endm 
# End of macro CWHEAD
4236			; | TCASE ( s -- s ) Title case string s  | DONE 
4236					if DEBUG_FORTH_WORDS_KEY 
4236						DMARK "TCS" 
4236 f5				push af  
4237 3a 4b 42			ld a, (.dmark)  
423a 32 6b ee			ld (debug_mark),a  
423d 3a 4c 42			ld a, (.dmark+1)  
4240 32 6c ee			ld (debug_mark+1),a  
4243 3a 4d 42			ld a, (.dmark+2)  
4246 32 6d ee			ld (debug_mark+2),a  
4249 18 03			jr .pastdmark  
424b ..			.dmark: db "TCS"  
424e f1			.pastdmark: pop af  
424f			endm  
# End of macro DMARK
424f						CALLMONITOR 
424f cd 6f ee			call debug_vector  
4252				endm  
# End of macro CALLMONITOR
4252					endif 
4252			 
4252					FORTH_DSP 
4252 cd 2a 1d			call macro_forth_dsp 
4255				endm 
# End of macro FORTH_DSP
4255					 
4255			; TODO check is string type 
4255			 
4255					FORTH_DSP_VALUEHL 
4255 cd 64 1d			call macro_dsp_valuehl 
4258				endm 
# End of macro FORTH_DSP_VALUEHL
4258			; get pointer to string in hl 
4258			 
4258					if DEBUG_FORTH_WORDS 
4258						DMARK "TC1" 
4258 f5				push af  
4259 3a 6d 42			ld a, (.dmark)  
425c 32 6b ee			ld (debug_mark),a  
425f 3a 6e 42			ld a, (.dmark+1)  
4262 32 6c ee			ld (debug_mark+1),a  
4265 3a 6f 42			ld a, (.dmark+2)  
4268 32 6d ee			ld (debug_mark+2),a  
426b 18 03			jr .pastdmark  
426d ..			.dmark: db "TC1"  
4270 f1			.pastdmark: pop af  
4271			endm  
# End of macro DMARK
4271						CALLMONITOR 
4271 cd 6f ee			call debug_vector  
4274				endm  
# End of macro CALLMONITOR
4274					endif 
4274			 
4274					; first time in turn to upper case first char 
4274			 
4274 7e					ld a, (hl) 
4275 c3 ff 42				jp .totsiptou 
4278			 
4278			 
4278 7e			.tot:		ld a, (hl) 
4279 fe 00				cp 0 
427b ca 43 43				jp z, .totdone 
427e			 
427e					if DEBUG_FORTH_WORDS 
427e						DMARK "TC2" 
427e f5				push af  
427f 3a 93 42			ld a, (.dmark)  
4282 32 6b ee			ld (debug_mark),a  
4285 3a 94 42			ld a, (.dmark+1)  
4288 32 6c ee			ld (debug_mark+1),a  
428b 3a 95 42			ld a, (.dmark+2)  
428e 32 6d ee			ld (debug_mark+2),a  
4291 18 03			jr .pastdmark  
4293 ..			.dmark: db "TC2"  
4296 f1			.pastdmark: pop af  
4297			endm  
# End of macro DMARK
4297						CALLMONITOR 
4297 cd 6f ee			call debug_vector  
429a				endm  
# End of macro CALLMONITOR
429a					endif 
429a					; check to see if current char is a space 
429a			 
429a fe 20				cp ' ' 
429c 28 21				jr z, .totsp 
429e cd 64 10				call to_lower 
42a1					if DEBUG_FORTH_WORDS 
42a1						DMARK "TC3" 
42a1 f5				push af  
42a2 3a b6 42			ld a, (.dmark)  
42a5 32 6b ee			ld (debug_mark),a  
42a8 3a b7 42			ld a, (.dmark+1)  
42ab 32 6c ee			ld (debug_mark+1),a  
42ae 3a b8 42			ld a, (.dmark+2)  
42b1 32 6d ee			ld (debug_mark+2),a  
42b4 18 03			jr .pastdmark  
42b6 ..			.dmark: db "TC3"  
42b9 f1			.pastdmark: pop af  
42ba			endm  
# End of macro DMARK
42ba						CALLMONITOR 
42ba cd 6f ee			call debug_vector  
42bd				endm  
# End of macro CALLMONITOR
42bd					endif 
42bd 18 63				jr .totnxt 
42bf			 
42bf			.totsp:         ; on a space, find next char which should be upper 
42bf			 
42bf					if DEBUG_FORTH_WORDS 
42bf						DMARK "TC4" 
42bf f5				push af  
42c0 3a d4 42			ld a, (.dmark)  
42c3 32 6b ee			ld (debug_mark),a  
42c6 3a d5 42			ld a, (.dmark+1)  
42c9 32 6c ee			ld (debug_mark+1),a  
42cc 3a d6 42			ld a, (.dmark+2)  
42cf 32 6d ee			ld (debug_mark+2),a  
42d2 18 03			jr .pastdmark  
42d4 ..			.dmark: db "TC4"  
42d7 f1			.pastdmark: pop af  
42d8			endm  
# End of macro DMARK
42d8						CALLMONITOR 
42d8 cd 6f ee			call debug_vector  
42db				endm  
# End of macro CALLMONITOR
42db					endif 
42db					;; 
42db			 
42db fe 20				cp ' ' 
42dd 20 20				jr nz, .totsiptou 
42df 23					inc hl 
42e0 7e					ld a, (hl) 
42e1					if DEBUG_FORTH_WORDS 
42e1						DMARK "TC5" 
42e1 f5				push af  
42e2 3a f6 42			ld a, (.dmark)  
42e5 32 6b ee			ld (debug_mark),a  
42e8 3a f7 42			ld a, (.dmark+1)  
42eb 32 6c ee			ld (debug_mark+1),a  
42ee 3a f8 42			ld a, (.dmark+2)  
42f1 32 6d ee			ld (debug_mark+2),a  
42f4 18 03			jr .pastdmark  
42f6 ..			.dmark: db "TC5"  
42f9 f1			.pastdmark: pop af  
42fa			endm  
# End of macro DMARK
42fa						CALLMONITOR 
42fa cd 6f ee			call debug_vector  
42fd				endm  
# End of macro CALLMONITOR
42fd					endif 
42fd 18 c0				jr .totsp 
42ff fe 00		.totsiptou:    cp 0 
4301 28 40				jr z, .totdone 
4303					; not space and not zero term so upper case it 
4303 cd 5b 10				call to_upper 
4306			 
4306					if DEBUG_FORTH_WORDS 
4306						DMARK "TC6" 
4306 f5				push af  
4307 3a 1b 43			ld a, (.dmark)  
430a 32 6b ee			ld (debug_mark),a  
430d 3a 1c 43			ld a, (.dmark+1)  
4310 32 6c ee			ld (debug_mark+1),a  
4313 3a 1d 43			ld a, (.dmark+2)  
4316 32 6d ee			ld (debug_mark+2),a  
4319 18 03			jr .pastdmark  
431b ..			.dmark: db "TC6"  
431e f1			.pastdmark: pop af  
431f			endm  
# End of macro DMARK
431f						CALLMONITOR 
431f cd 6f ee			call debug_vector  
4322				endm  
# End of macro CALLMONITOR
4322					endif 
4322			 
4322			 
4322			.totnxt: 
4322			 
4322 77					ld (hl), a 
4323 23					inc hl 
4324					if DEBUG_FORTH_WORDS 
4324						DMARK "TC7" 
4324 f5				push af  
4325 3a 39 43			ld a, (.dmark)  
4328 32 6b ee			ld (debug_mark),a  
432b 3a 3a 43			ld a, (.dmark+1)  
432e 32 6c ee			ld (debug_mark+1),a  
4331 3a 3b 43			ld a, (.dmark+2)  
4334 32 6d ee			ld (debug_mark+2),a  
4337 18 03			jr .pastdmark  
4339 ..			.dmark: db "TC7"  
433c f1			.pastdmark: pop af  
433d			endm  
# End of macro DMARK
433d						CALLMONITOR 
433d cd 6f ee			call debug_vector  
4340				endm  
# End of macro CALLMONITOR
4340					endif 
4340 c3 78 42				jp .tot 
4343			 
4343					 
4343			 
4343			 
4343			; for each char convert to low 
4343					 
4343			.totdone: 
4343					if DEBUG_FORTH_WORDS 
4343						DMARK "TCd" 
4343 f5				push af  
4344 3a 58 43			ld a, (.dmark)  
4347 32 6b ee			ld (debug_mark),a  
434a 3a 59 43			ld a, (.dmark+1)  
434d 32 6c ee			ld (debug_mark+1),a  
4350 3a 5a 43			ld a, (.dmark+2)  
4353 32 6d ee			ld (debug_mark+2),a  
4356 18 03			jr .pastdmark  
4358 ..			.dmark: db "TCd"  
435b f1			.pastdmark: pop af  
435c			endm  
# End of macro DMARK
435c						CALLMONITOR 
435c cd 6f ee			call debug_vector  
435f				endm  
# End of macro CALLMONITOR
435f					endif 
435f					NEXTW 
435f c3 1a 1f			jp macro_next 
4362				endm 
# End of macro NEXTW
4362			 
4362			.SUBSTR: 
4362				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4362 48				db WORD_SYS_CORE+52             
4363 c0 43			dw .LEFT            
4365 07				db 6 + 1 
4366 .. 00			db "SUBSTR",0              
436d				endm 
# End of macro CWHEAD
436d			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
436d			 
436d					if DEBUG_FORTH_WORDS_KEY 
436d						DMARK "SST" 
436d f5				push af  
436e 3a 82 43			ld a, (.dmark)  
4371 32 6b ee			ld (debug_mark),a  
4374 3a 83 43			ld a, (.dmark+1)  
4377 32 6c ee			ld (debug_mark+1),a  
437a 3a 84 43			ld a, (.dmark+2)  
437d 32 6d ee			ld (debug_mark+2),a  
4380 18 03			jr .pastdmark  
4382 ..			.dmark: db "SST"  
4385 f1			.pastdmark: pop af  
4386			endm  
# End of macro DMARK
4386						CALLMONITOR 
4386 cd 6f ee			call debug_vector  
4389				endm  
# End of macro CALLMONITOR
4389					endif 
4389			; TODO check string type 
4389					FORTH_DSP_VALUEHL 
4389 cd 64 1d			call macro_dsp_valuehl 
438c				endm 
# End of macro FORTH_DSP_VALUEHL
438c			 
438c e5					push hl      ; string length 
438d			 
438d					FORTH_DSP_POP 
438d cd 1c 1e			call macro_forth_dsp_pop 
4390				endm 
# End of macro FORTH_DSP_POP
4390			 
4390					FORTH_DSP_VALUEHL 
4390 cd 64 1d			call macro_dsp_valuehl 
4393				endm 
# End of macro FORTH_DSP_VALUEHL
4393			 
4393 e5					push hl     ; start char 
4394			 
4394					FORTH_DSP_POP 
4394 cd 1c 1e			call macro_forth_dsp_pop 
4397				endm 
# End of macro FORTH_DSP_POP
4397			 
4397			 
4397					FORTH_DSP_VALUE 
4397 cd 4d 1d			call macro_forth_dsp_value 
439a				endm 
# End of macro FORTH_DSP_VALUE
439a			 
439a d1					pop de    ; get start post offset 
439b			 
439b 19					add hl, de    ; starting offset 
439c			 
439c c1					pop bc 
439d c5					push bc      ; grab size of string 
439e			 
439e e5					push hl    ; save string start  
439f			 
439f 26 00				ld h, 0 
43a1 69					ld l, c 
43a2 23					inc hl 
43a3 23					inc hl 
43a4			 
43a4 cd c1 11				call malloc 
43a7				if DEBUG_FORTH_MALLOC_GUARD 
43a7 cc da 4c				call z,malloc_error 
43aa				endif 
43aa			 
43aa eb					ex de, hl      ; save malloc area for string copy 
43ab e1					pop hl    ; get back source 
43ac c1					pop bc    ; get length of string back 
43ad			 
43ad d5					push de    ; save malloc area for after we push 
43ae ed b0				ldir     ; copy substr 
43b0			 
43b0			 
43b0 eb					ex de, hl 
43b1 3e 00				ld a, 0 
43b3 77					ld (hl), a   ; term substr 
43b4			 
43b4					 
43b4 e1					pop hl    ; get malloc so we can push it 
43b5 e5					push hl   ; save so we can free it afterwards 
43b6			 
43b6 cd db 1b				call forth_push_str 
43b9			 
43b9 e1					pop hl 
43ba cd 8b 12				call free 
43bd			 
43bd					 
43bd					 
43bd			 
43bd			 
43bd					NEXTW 
43bd c3 1a 1f			jp macro_next 
43c0				endm 
# End of macro NEXTW
43c0			 
43c0			.LEFT: 
43c0				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
43c0 48				db WORD_SYS_CORE+52             
43c1 e8 43			dw .RIGHT            
43c3 05				db 4 + 1 
43c4 .. 00			db "LEFT",0              
43c9				endm 
# End of macro CWHEAD
43c9			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
43c9					if DEBUG_FORTH_WORDS_KEY 
43c9						DMARK "LEF" 
43c9 f5				push af  
43ca 3a de 43			ld a, (.dmark)  
43cd 32 6b ee			ld (debug_mark),a  
43d0 3a df 43			ld a, (.dmark+1)  
43d3 32 6c ee			ld (debug_mark+1),a  
43d6 3a e0 43			ld a, (.dmark+2)  
43d9 32 6d ee			ld (debug_mark+2),a  
43dc 18 03			jr .pastdmark  
43de ..			.dmark: db "LEF"  
43e1 f1			.pastdmark: pop af  
43e2			endm  
# End of macro DMARK
43e2						CALLMONITOR 
43e2 cd 6f ee			call debug_vector  
43e5				endm  
# End of macro CALLMONITOR
43e5					endif 
43e5			 
43e5					NEXTW 
43e5 c3 1a 1f			jp macro_next 
43e8				endm 
# End of macro NEXTW
43e8			.RIGHT: 
43e8				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
43e8 48				db WORD_SYS_CORE+52             
43e9 11 44			dw .STR2NUM            
43eb 06				db 5 + 1 
43ec .. 00			db "RIGHT",0              
43f2				endm 
# End of macro CWHEAD
43f2			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
43f2					if DEBUG_FORTH_WORDS_KEY 
43f2						DMARK "RIG" 
43f2 f5				push af  
43f3 3a 07 44			ld a, (.dmark)  
43f6 32 6b ee			ld (debug_mark),a  
43f9 3a 08 44			ld a, (.dmark+1)  
43fc 32 6c ee			ld (debug_mark+1),a  
43ff 3a 09 44			ld a, (.dmark+2)  
4402 32 6d ee			ld (debug_mark+2),a  
4405 18 03			jr .pastdmark  
4407 ..			.dmark: db "RIG"  
440a f1			.pastdmark: pop af  
440b			endm  
# End of macro DMARK
440b						CALLMONITOR 
440b cd 6f ee			call debug_vector  
440e				endm  
# End of macro CALLMONITOR
440e					endif 
440e			 
440e					NEXTW 
440e c3 1a 1f			jp macro_next 
4411				endm 
# End of macro NEXTW
4411			 
4411			 
4411			.STR2NUM: 
4411				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4411 48				db WORD_SYS_CORE+52             
4412 9d 44			dw .NUM2STR            
4414 08				db 7 + 1 
4415 .. 00			db "STR2NUM",0              
441d				endm 
# End of macro CWHEAD
441d			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
441d			 
441d			 
441d			; TODO STR type check to do 
441d					if DEBUG_FORTH_WORDS_KEY 
441d						DMARK "S2N" 
441d f5				push af  
441e 3a 32 44			ld a, (.dmark)  
4421 32 6b ee			ld (debug_mark),a  
4424 3a 33 44			ld a, (.dmark+1)  
4427 32 6c ee			ld (debug_mark+1),a  
442a 3a 34 44			ld a, (.dmark+2)  
442d 32 6d ee			ld (debug_mark+2),a  
4430 18 03			jr .pastdmark  
4432 ..			.dmark: db "S2N"  
4435 f1			.pastdmark: pop af  
4436			endm  
# End of macro DMARK
4436						CALLMONITOR 
4436 cd 6f ee			call debug_vector  
4439				endm  
# End of macro CALLMONITOR
4439					endif 
4439			 
4439					;FORTH_DSP 
4439					FORTH_DSP_VALUE 
4439 cd 4d 1d			call macro_forth_dsp_value 
443c				endm 
# End of macro FORTH_DSP_VALUE
443c					;inc hl 
443c			 
443c eb					ex de, hl 
443d					if DEBUG_FORTH_WORDS 
443d						DMARK "S2a" 
443d f5				push af  
443e 3a 52 44			ld a, (.dmark)  
4441 32 6b ee			ld (debug_mark),a  
4444 3a 53 44			ld a, (.dmark+1)  
4447 32 6c ee			ld (debug_mark+1),a  
444a 3a 54 44			ld a, (.dmark+2)  
444d 32 6d ee			ld (debug_mark+2),a  
4450 18 03			jr .pastdmark  
4452 ..			.dmark: db "S2a"  
4455 f1			.pastdmark: pop af  
4456			endm  
# End of macro DMARK
4456						CALLMONITOR 
4456 cd 6f ee			call debug_vector  
4459				endm  
# End of macro CALLMONITOR
4459					endif 
4459 cd e3 10				call string_to_uint16 
445c			 
445c					if DEBUG_FORTH_WORDS 
445c						DMARK "S2b" 
445c f5				push af  
445d 3a 71 44			ld a, (.dmark)  
4460 32 6b ee			ld (debug_mark),a  
4463 3a 72 44			ld a, (.dmark+1)  
4466 32 6c ee			ld (debug_mark+1),a  
4469 3a 73 44			ld a, (.dmark+2)  
446c 32 6d ee			ld (debug_mark+2),a  
446f 18 03			jr .pastdmark  
4471 ..			.dmark: db "S2b"  
4474 f1			.pastdmark: pop af  
4475			endm  
# End of macro DMARK
4475						CALLMONITOR 
4475 cd 6f ee			call debug_vector  
4478				endm  
# End of macro CALLMONITOR
4478					endif 
4478			;		push hl 
4478					FORTH_DSP_POP 
4478 cd 1c 1e			call macro_forth_dsp_pop 
447b				endm 
# End of macro FORTH_DSP_POP
447b			;		pop hl 
447b					 
447b					if DEBUG_FORTH_WORDS 
447b						DMARK "S2b" 
447b f5				push af  
447c 3a 90 44			ld a, (.dmark)  
447f 32 6b ee			ld (debug_mark),a  
4482 3a 91 44			ld a, (.dmark+1)  
4485 32 6c ee			ld (debug_mark+1),a  
4488 3a 92 44			ld a, (.dmark+2)  
448b 32 6d ee			ld (debug_mark+2),a  
448e 18 03			jr .pastdmark  
4490 ..			.dmark: db "S2b"  
4493 f1			.pastdmark: pop af  
4494			endm  
# End of macro DMARK
4494						CALLMONITOR 
4494 cd 6f ee			call debug_vector  
4497				endm  
# End of macro CALLMONITOR
4497					endif 
4497 cd 6d 1b				call forth_push_numhl	 
449a			 
449a				 
449a				       NEXTW 
449a c3 1a 1f			jp macro_next 
449d				endm 
# End of macro NEXTW
449d			.NUM2STR: 
449d				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
449d 48				db WORD_SYS_CORE+52             
449e ac 44			dw .CONCAT            
44a0 08				db 7 + 1 
44a1 .. 00			db "NUM2STR",0              
44a9				endm 
# End of macro CWHEAD
44a9			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
44a9			 
44a9			;		; malloc a string to target 
44a9			;		ld hl, 10     ; TODO max string size should be fine 
44a9			;		call malloc 
44a9			;		push hl    ; save malloc location 
44a9			; 
44a9			; 
44a9			;; TODO check int type 
44a9			;		FORTH_DSP_VALUEHL 
44a9			;		ld a, l 
44a9			;		call DispAToASCII   
44a9			;;TODO need to chage above call to dump into string 
44a9			; 
44a9			; 
44a9			 
44a9				       NEXTW 
44a9 c3 1a 1f			jp macro_next 
44ac				endm 
# End of macro NEXTW
44ac			 
44ac			.CONCAT: 
44ac				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
44ac 48				db WORD_SYS_CORE+52             
44ad 5f 45			dw .FIND            
44af 07				db 6 + 1 
44b0 .. 00			db "CONCAT",0              
44b7				endm 
# End of macro CWHEAD
44b7			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
44b7			 
44b7			; TODO check string type 
44b7			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
44b7			 
44b7					if DEBUG_FORTH_WORDS_KEY 
44b7						DMARK "CON" 
44b7 f5				push af  
44b8 3a cc 44			ld a, (.dmark)  
44bb 32 6b ee			ld (debug_mark),a  
44be 3a cd 44			ld a, (.dmark+1)  
44c1 32 6c ee			ld (debug_mark+1),a  
44c4 3a ce 44			ld a, (.dmark+2)  
44c7 32 6d ee			ld (debug_mark+2),a  
44ca 18 03			jr .pastdmark  
44cc ..			.dmark: db "CON"  
44cf f1			.pastdmark: pop af  
44d0			endm  
# End of macro DMARK
44d0						CALLMONITOR 
44d0 cd 6f ee			call debug_vector  
44d3				endm  
# End of macro CALLMONITOR
44d3					endif 
44d3			 
44d3			 
44d3					FORTH_DSP_VALUE 
44d3 cd 4d 1d			call macro_forth_dsp_value 
44d6				endm 
# End of macro FORTH_DSP_VALUE
44d6 e5					push hl   ; s2 
44d7			 
44d7					FORTH_DSP_POP 
44d7 cd 1c 1e			call macro_forth_dsp_pop 
44da				endm 
# End of macro FORTH_DSP_POP
44da			 
44da					FORTH_DSP_VALUE 
44da cd 4d 1d			call macro_forth_dsp_value 
44dd				endm 
# End of macro FORTH_DSP_VALUE
44dd			 
44dd e5					push hl   ; s1 
44de			 
44de					FORTH_DSP_POP 
44de cd 1c 1e			call macro_forth_dsp_pop 
44e1				endm 
# End of macro FORTH_DSP_POP
44e1					 
44e1			 
44e1					; copy s1 
44e1			 
44e1				 
44e1					; save ptr 
44e1 e1					pop hl  
44e2 e5					push hl 
44e3 3e 00				ld a, 0 
44e5 cd 57 11				call strlent 
44e8					;inc hl    ; zer0 
44e8 06 00				ld b, 0 
44ea 4d					ld c, l 
44eb e1					pop hl		 
44ec 11 c1 e2				ld de, scratch	 
44ef					if DEBUG_FORTH_WORDS 
44ef						DMARK "CO1" 
44ef f5				push af  
44f0 3a 04 45			ld a, (.dmark)  
44f3 32 6b ee			ld (debug_mark),a  
44f6 3a 05 45			ld a, (.dmark+1)  
44f9 32 6c ee			ld (debug_mark+1),a  
44fc 3a 06 45			ld a, (.dmark+2)  
44ff 32 6d ee			ld (debug_mark+2),a  
4502 18 03			jr .pastdmark  
4504 ..			.dmark: db "CO1"  
4507 f1			.pastdmark: pop af  
4508			endm  
# End of macro DMARK
4508						CALLMONITOR 
4508 cd 6f ee			call debug_vector  
450b				endm  
# End of macro CALLMONITOR
450b					endif 
450b ed b0				ldir 
450d			 
450d e1					pop hl 
450e e5					push hl 
450f d5					push de 
4510			 
4510			 
4510 3e 00				ld a, 0 
4512 cd 57 11				call strlent 
4515 23					inc hl    ; zer0 
4516 23					inc hl 
4517 06 00				ld b, 0 
4519 4d					ld c, l 
451a d1					pop de 
451b e1					pop hl		 
451c					if DEBUG_FORTH_WORDS 
451c						DMARK "CO2" 
451c f5				push af  
451d 3a 31 45			ld a, (.dmark)  
4520 32 6b ee			ld (debug_mark),a  
4523 3a 32 45			ld a, (.dmark+1)  
4526 32 6c ee			ld (debug_mark+1),a  
4529 3a 33 45			ld a, (.dmark+2)  
452c 32 6d ee			ld (debug_mark+2),a  
452f 18 03			jr .pastdmark  
4531 ..			.dmark: db "CO2"  
4534 f1			.pastdmark: pop af  
4535			endm  
# End of macro DMARK
4535						CALLMONITOR 
4535 cd 6f ee			call debug_vector  
4538				endm  
# End of macro CALLMONITOR
4538					endif 
4538 ed b0				ldir 
453a			 
453a			 
453a			 
453a 21 c1 e2				ld hl, scratch 
453d					if DEBUG_FORTH_WORDS 
453d						DMARK "CO5" 
453d f5				push af  
453e 3a 52 45			ld a, (.dmark)  
4541 32 6b ee			ld (debug_mark),a  
4544 3a 53 45			ld a, (.dmark+1)  
4547 32 6c ee			ld (debug_mark+1),a  
454a 3a 54 45			ld a, (.dmark+2)  
454d 32 6d ee			ld (debug_mark+2),a  
4550 18 03			jr .pastdmark  
4552 ..			.dmark: db "CO5"  
4555 f1			.pastdmark: pop af  
4556			endm  
# End of macro DMARK
4556						CALLMONITOR 
4556 cd 6f ee			call debug_vector  
4559				endm  
# End of macro CALLMONITOR
4559					endif 
4559			 
4559 cd db 1b				call forth_push_str 
455c			 
455c			 
455c			 
455c			 
455c				       NEXTW 
455c c3 1a 1f			jp macro_next 
455f				endm 
# End of macro NEXTW
455f			 
455f			 
455f			.FIND: 
455f				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
455f 4b				db WORD_SYS_CORE+55             
4560 1d 46			dw .LEN            
4562 05				db 4 + 1 
4563 .. 00			db "FIND",0              
4568				endm 
# End of macro CWHEAD
4568			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4568			 
4568					if DEBUG_FORTH_WORDS_KEY 
4568						DMARK "FND" 
4568 f5				push af  
4569 3a 7d 45			ld a, (.dmark)  
456c 32 6b ee			ld (debug_mark),a  
456f 3a 7e 45			ld a, (.dmark+1)  
4572 32 6c ee			ld (debug_mark+1),a  
4575 3a 7f 45			ld a, (.dmark+2)  
4578 32 6d ee			ld (debug_mark+2),a  
457b 18 03			jr .pastdmark  
457d ..			.dmark: db "FND"  
4580 f1			.pastdmark: pop af  
4581			endm  
# End of macro DMARK
4581						CALLMONITOR 
4581 cd 6f ee			call debug_vector  
4584				endm  
# End of macro CALLMONITOR
4584					endif 
4584			 
4584			; TODO check string type 
4584					FORTH_DSP_VALUE 
4584 cd 4d 1d			call macro_forth_dsp_value 
4587				endm 
# End of macro FORTH_DSP_VALUE
4587			 
4587 e5					push hl    
4588 7e					ld a,(hl)    ; char to find   
4589			; TODO change char to substr 
4589			 
4589 f5					push af 
458a					 
458a			 
458a			 
458a					if DEBUG_FORTH_WORDS 
458a						DMARK "FN1" 
458a f5				push af  
458b 3a 9f 45			ld a, (.dmark)  
458e 32 6b ee			ld (debug_mark),a  
4591 3a a0 45			ld a, (.dmark+1)  
4594 32 6c ee			ld (debug_mark+1),a  
4597 3a a1 45			ld a, (.dmark+2)  
459a 32 6d ee			ld (debug_mark+2),a  
459d 18 03			jr .pastdmark  
459f ..			.dmark: db "FN1"  
45a2 f1			.pastdmark: pop af  
45a3			endm  
# End of macro DMARK
45a3						CALLMONITOR 
45a3 cd 6f ee			call debug_vector  
45a6				endm  
# End of macro CALLMONITOR
45a6					endif 
45a6			 
45a6					FORTH_DSP_POP 
45a6 cd 1c 1e			call macro_forth_dsp_pop 
45a9				endm 
# End of macro FORTH_DSP_POP
45a9			 
45a9					; string to search 
45a9			 
45a9					FORTH_DSP_VALUE 
45a9 cd 4d 1d			call macro_forth_dsp_value 
45ac				endm 
# End of macro FORTH_DSP_VALUE
45ac			 
45ac d1					pop de  ; d is char to find  
45ad			 
45ad					if DEBUG_FORTH_WORDS 
45ad						DMARK "FN2" 
45ad f5				push af  
45ae 3a c2 45			ld a, (.dmark)  
45b1 32 6b ee			ld (debug_mark),a  
45b4 3a c3 45			ld a, (.dmark+1)  
45b7 32 6c ee			ld (debug_mark+1),a  
45ba 3a c4 45			ld a, (.dmark+2)  
45bd 32 6d ee			ld (debug_mark+2),a  
45c0 18 03			jr .pastdmark  
45c2 ..			.dmark: db "FN2"  
45c5 f1			.pastdmark: pop af  
45c6			endm  
# End of macro DMARK
45c6						CALLMONITOR 
45c6 cd 6f ee			call debug_vector  
45c9				endm  
# End of macro CALLMONITOR
45c9					endif 
45c9					 
45c9 01 00 00				ld bc, 0 
45cc 7e			.findchar:      ld a,(hl) 
45cd fe 00				cp 0   		 
45cf 28 27				jr z, .finddone     
45d1 ba					cp d 
45d2 28 20				jr z, .foundchar 
45d4 03					inc bc 
45d5 23					inc hl 
45d6					if DEBUG_FORTH_WORDS 
45d6						DMARK "FN3" 
45d6 f5				push af  
45d7 3a eb 45			ld a, (.dmark)  
45da 32 6b ee			ld (debug_mark),a  
45dd 3a ec 45			ld a, (.dmark+1)  
45e0 32 6c ee			ld (debug_mark+1),a  
45e3 3a ed 45			ld a, (.dmark+2)  
45e6 32 6d ee			ld (debug_mark+2),a  
45e9 18 03			jr .pastdmark  
45eb ..			.dmark: db "FN3"  
45ee f1			.pastdmark: pop af  
45ef			endm  
# End of macro DMARK
45ef						CALLMONITOR 
45ef cd 6f ee			call debug_vector  
45f2				endm  
# End of macro CALLMONITOR
45f2					endif 
45f2 18 d8				jr .findchar 
45f4			 
45f4			 
45f4 c5			.foundchar:	push bc 
45f5 e1					pop hl 
45f6 18 03				jr .findexit 
45f8			 
45f8			 
45f8							 
45f8			 
45f8			.finddone:     ; got to end of string with no find 
45f8 21 00 00				ld hl, 0 
45fb			.findexit: 
45fb			 
45fb					if DEBUG_FORTH_WORDS 
45fb						DMARK "FNd" 
45fb f5				push af  
45fc 3a 10 46			ld a, (.dmark)  
45ff 32 6b ee			ld (debug_mark),a  
4602 3a 11 46			ld a, (.dmark+1)  
4605 32 6c ee			ld (debug_mark+1),a  
4608 3a 12 46			ld a, (.dmark+2)  
460b 32 6d ee			ld (debug_mark+2),a  
460e 18 03			jr .pastdmark  
4610 ..			.dmark: db "FNd"  
4613 f1			.pastdmark: pop af  
4614			endm  
# End of macro DMARK
4614						CALLMONITOR 
4614 cd 6f ee			call debug_vector  
4617				endm  
# End of macro CALLMONITOR
4617					endif 
4617 cd 6d 1b			call forth_push_numhl 
461a			 
461a				       NEXTW 
461a c3 1a 1f			jp macro_next 
461d				endm 
# End of macro NEXTW
461d			 
461d			.LEN: 
461d				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
461d 4c				db WORD_SYS_CORE+56             
461e 87 46			dw .ASC            
4620 06				db 5 + 1 
4621 .. 00			db "COUNT",0              
4627				endm 
# End of macro CWHEAD
4627			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4627			 
4627					if DEBUG_FORTH_WORDS_KEY 
4627						DMARK "CNT" 
4627 f5				push af  
4628 3a 3c 46			ld a, (.dmark)  
462b 32 6b ee			ld (debug_mark),a  
462e 3a 3d 46			ld a, (.dmark+1)  
4631 32 6c ee			ld (debug_mark+1),a  
4634 3a 3e 46			ld a, (.dmark+2)  
4637 32 6d ee			ld (debug_mark+2),a  
463a 18 03			jr .pastdmark  
463c ..			.dmark: db "CNT"  
463f f1			.pastdmark: pop af  
4640			endm  
# End of macro DMARK
4640						CALLMONITOR 
4640 cd 6f ee			call debug_vector  
4643				endm  
# End of macro CALLMONITOR
4643					endif 
4643			; TODO check string type 
4643					FORTH_DSP_VALUE 
4643 cd 4d 1d			call macro_forth_dsp_value 
4646				endm 
# End of macro FORTH_DSP_VALUE
4646			 
4646			 
4646					if DEBUG_FORTH_WORDS 
4646						DMARK "CN?" 
4646 f5				push af  
4647 3a 5b 46			ld a, (.dmark)  
464a 32 6b ee			ld (debug_mark),a  
464d 3a 5c 46			ld a, (.dmark+1)  
4650 32 6c ee			ld (debug_mark+1),a  
4653 3a 5d 46			ld a, (.dmark+2)  
4656 32 6d ee			ld (debug_mark+2),a  
4659 18 03			jr .pastdmark  
465b ..			.dmark: db "CN?"  
465e f1			.pastdmark: pop af  
465f			endm  
# End of macro DMARK
465f						CALLMONITOR 
465f cd 6f ee			call debug_vector  
4662				endm  
# End of macro CALLMONITOR
4662					endif 
4662 cd 4c 11				call strlenz 
4665					if DEBUG_FORTH_WORDS 
4665						DMARK "CNl" 
4665 f5				push af  
4666 3a 7a 46			ld a, (.dmark)  
4669 32 6b ee			ld (debug_mark),a  
466c 3a 7b 46			ld a, (.dmark+1)  
466f 32 6c ee			ld (debug_mark+1),a  
4672 3a 7c 46			ld a, (.dmark+2)  
4675 32 6d ee			ld (debug_mark+2),a  
4678 18 03			jr .pastdmark  
467a ..			.dmark: db "CNl"  
467d f1			.pastdmark: pop af  
467e			endm  
# End of macro DMARK
467e						CALLMONITOR 
467e cd 6f ee			call debug_vector  
4681				endm  
# End of macro CALLMONITOR
4681					endif 
4681			 
4681 cd 6d 1b				call forth_push_numhl 
4684			 
4684			 
4684			 
4684				       NEXTW 
4684 c3 1a 1f			jp macro_next 
4687				endm 
# End of macro NEXTW
4687			.ASC: 
4687				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4687 4d				db WORD_SYS_CORE+57             
4688 f5 46			dw .CHR            
468a 04				db 3 + 1 
468b .. 00			db "ASC",0              
468f				endm 
# End of macro CWHEAD
468f			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
468f					if DEBUG_FORTH_WORDS_KEY 
468f						DMARK "ASC" 
468f f5				push af  
4690 3a a4 46			ld a, (.dmark)  
4693 32 6b ee			ld (debug_mark),a  
4696 3a a5 46			ld a, (.dmark+1)  
4699 32 6c ee			ld (debug_mark+1),a  
469c 3a a6 46			ld a, (.dmark+2)  
469f 32 6d ee			ld (debug_mark+2),a  
46a2 18 03			jr .pastdmark  
46a4 ..			.dmark: db "ASC"  
46a7 f1			.pastdmark: pop af  
46a8			endm  
# End of macro DMARK
46a8						CALLMONITOR 
46a8 cd 6f ee			call debug_vector  
46ab				endm  
# End of macro CALLMONITOR
46ab					endif 
46ab					FORTH_DSP_VALUE 
46ab cd 4d 1d			call macro_forth_dsp_value 
46ae				endm 
# End of macro FORTH_DSP_VALUE
46ae					;v5 FORTH_DSP_VALUE 
46ae			;		inc hl      ; now at start of numeric as string 
46ae			 
46ae e5					push hl 
46af			 
46af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46af cd 1c 1e			call macro_forth_dsp_pop 
46b2				endm 
# End of macro FORTH_DSP_POP
46b2			 
46b2 e1					pop hl 
46b3			 
46b3					if DEBUG_FORTH_WORDS 
46b3						DMARK "AS1" 
46b3 f5				push af  
46b4 3a c8 46			ld a, (.dmark)  
46b7 32 6b ee			ld (debug_mark),a  
46ba 3a c9 46			ld a, (.dmark+1)  
46bd 32 6c ee			ld (debug_mark+1),a  
46c0 3a ca 46			ld a, (.dmark+2)  
46c3 32 6d ee			ld (debug_mark+2),a  
46c6 18 03			jr .pastdmark  
46c8 ..			.dmark: db "AS1"  
46cb f1			.pastdmark: pop af  
46cc			endm  
# End of macro DMARK
46cc						CALLMONITOR 
46cc cd 6f ee			call debug_vector  
46cf				endm  
# End of macro CALLMONITOR
46cf					endif 
46cf					; push the content of a onto the stack as a value 
46cf			 
46cf 7e					ld a,(hl)   ; get char 
46d0 26 00				ld h,0 
46d2 6f					ld l,a 
46d3					if DEBUG_FORTH_WORDS 
46d3						DMARK "AS2" 
46d3 f5				push af  
46d4 3a e8 46			ld a, (.dmark)  
46d7 32 6b ee			ld (debug_mark),a  
46da 3a e9 46			ld a, (.dmark+1)  
46dd 32 6c ee			ld (debug_mark+1),a  
46e0 3a ea 46			ld a, (.dmark+2)  
46e3 32 6d ee			ld (debug_mark+2),a  
46e6 18 03			jr .pastdmark  
46e8 ..			.dmark: db "AS2"  
46eb f1			.pastdmark: pop af  
46ec			endm  
# End of macro DMARK
46ec						CALLMONITOR 
46ec cd 6f ee			call debug_vector  
46ef				endm  
# End of macro CALLMONITOR
46ef					endif 
46ef cd 6d 1b				call forth_push_numhl 
46f2			 
46f2				       NEXTW 
46f2 c3 1a 1f			jp macro_next 
46f5				endm 
# End of macro NEXTW
46f5			 
46f5			.CHR: 
46f5				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
46f5 4d				db WORD_SYS_CORE+57             
46f6 31 47			dw .ENDSTR            
46f8 04				db 3 + 1 
46f9 .. 00			db "CHR",0              
46fd				endm 
# End of macro CWHEAD
46fd			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
46fd					if DEBUG_FORTH_WORDS_KEY 
46fd						DMARK "CHR" 
46fd f5				push af  
46fe 3a 12 47			ld a, (.dmark)  
4701 32 6b ee			ld (debug_mark),a  
4704 3a 13 47			ld a, (.dmark+1)  
4707 32 6c ee			ld (debug_mark+1),a  
470a 3a 14 47			ld a, (.dmark+2)  
470d 32 6d ee			ld (debug_mark+2),a  
4710 18 03			jr .pastdmark  
4712 ..			.dmark: db "CHR"  
4715 f1			.pastdmark: pop af  
4716			endm  
# End of macro DMARK
4716						CALLMONITOR 
4716 cd 6f ee			call debug_vector  
4719				endm  
# End of macro CALLMONITOR
4719					endif 
4719					FORTH_DSP_VALUEHL 
4719 cd 64 1d			call macro_dsp_valuehl 
471c				endm 
# End of macro FORTH_DSP_VALUEHL
471c			 
471c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
471c cd 1c 1e			call macro_forth_dsp_pop 
471f				endm 
# End of macro FORTH_DSP_POP
471f			 
471f					; save asci byte as a zero term string and push string 
471f			 
471f 7d					ld a,l 
4720 32 c1 e2				ld (scratch), a 
4723			 
4723 3e 00				ld a, 0 
4725 32 c2 e2				ld (scratch+1), a 
4728			 
4728 21 c1 e2				ld hl, scratch 
472b cd db 1b				call forth_push_str 
472e			 
472e			 
472e				       NEXTW 
472e c3 1a 1f			jp macro_next 
4731				endm 
# End of macro NEXTW
4731			 
4731			 
4731			 
4731			 
4731			.ENDSTR: 
4731			; eof 
4731			 
# End of file forth_words_str.asm
4731			include "forth_words_key.asm" 
4731			 
4731			; | ## Keyboard Words 
4731			 
4731			.KEY: 
4731				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4731 3e				db WORD_SYS_CORE+42             
4732 61 47			dw .WAITK            
4734 04				db 3 + 1 
4735 .. 00			db "KEY",0              
4739				endm 
# End of macro CWHEAD
4739			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4739			 
4739					if DEBUG_FORTH_WORDS_KEY 
4739						DMARK "KEY" 
4739 f5				push af  
473a 3a 4e 47			ld a, (.dmark)  
473d 32 6b ee			ld (debug_mark),a  
4740 3a 4f 47			ld a, (.dmark+1)  
4743 32 6c ee			ld (debug_mark+1),a  
4746 3a 50 47			ld a, (.dmark+2)  
4749 32 6d ee			ld (debug_mark+2),a  
474c 18 03			jr .pastdmark  
474e ..			.dmark: db "KEY"  
4751 f1			.pastdmark: pop af  
4752			endm  
# End of macro DMARK
4752						CALLMONITOR 
4752 cd 6f ee			call debug_vector  
4755				endm  
# End of macro CALLMONITOR
4755					endif 
4755			; TODO currently waits 
4755 cd 4d 5e				call cin 
4758					;call cin_wait 
4758 6f					ld l, a 
4759 26 00				ld h, 0 
475b cd 6d 1b				call forth_push_numhl 
475e					NEXTW 
475e c3 1a 1f			jp macro_next 
4761				endm 
# End of macro NEXTW
4761			.WAITK: 
4761				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4761 3f				db WORD_SYS_CORE+43             
4762 93 47			dw .ACCEPT            
4764 06				db 5 + 1 
4765 .. 00			db "WAITK",0              
476b				endm 
# End of macro CWHEAD
476b			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
476b					if DEBUG_FORTH_WORDS_KEY 
476b						DMARK "WAI" 
476b f5				push af  
476c 3a 80 47			ld a, (.dmark)  
476f 32 6b ee			ld (debug_mark),a  
4772 3a 81 47			ld a, (.dmark+1)  
4775 32 6c ee			ld (debug_mark+1),a  
4778 3a 82 47			ld a, (.dmark+2)  
477b 32 6d ee			ld (debug_mark+2),a  
477e 18 03			jr .pastdmark  
4780 ..			.dmark: db "WAI"  
4783 f1			.pastdmark: pop af  
4784			endm  
# End of macro DMARK
4784						CALLMONITOR 
4784 cd 6f ee			call debug_vector  
4787				endm  
# End of macro CALLMONITOR
4787					endif 
4787 cd 45 5e				call cin_wait 
478a 6f					ld l, a 
478b 26 00				ld h, 0 
478d cd 6d 1b				call forth_push_numhl 
4790					NEXTW 
4790 c3 1a 1f			jp macro_next 
4793				endm 
# End of macro NEXTW
4793			.ACCEPT: 
4793				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4793 40				db WORD_SYS_CORE+44             
4794 f1 47			dw .EDIT            
4796 07				db 6 + 1 
4797 .. 00			db "ACCEPT",0              
479e				endm 
# End of macro CWHEAD
479e			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
479e					; TODO crashes on push 
479e					if DEBUG_FORTH_WORDS_KEY 
479e						DMARK "ACC" 
479e f5				push af  
479f 3a b3 47			ld a, (.dmark)  
47a2 32 6b ee			ld (debug_mark),a  
47a5 3a b4 47			ld a, (.dmark+1)  
47a8 32 6c ee			ld (debug_mark+1),a  
47ab 3a b5 47			ld a, (.dmark+2)  
47ae 32 6d ee			ld (debug_mark+2),a  
47b1 18 03			jr .pastdmark  
47b3 ..			.dmark: db "ACC"  
47b6 f1			.pastdmark: pop af  
47b7			endm  
# End of macro DMARK
47b7						CALLMONITOR 
47b7 cd 6f ee			call debug_vector  
47ba				endm  
# End of macro CALLMONITOR
47ba					endif 
47ba 21 bf e4				ld hl, os_input 
47bd 3e 00				ld a, 0 
47bf 77					ld (hl),a 
47c0 3a 5e ea				ld a,(f_cursor_ptr) 
47c3 16 64				ld d, 100 
47c5 0e 00				ld c, 0 
47c7 1e 28				ld e, 40 
47c9 cd 13 0e				call input_str 
47cc					; TODO perhaps do a type check and wrap in quotes if not a number 
47cc 21 bf e4				ld hl, os_input 
47cf					if DEBUG_FORTH_WORDS 
47cf						DMARK "AC1" 
47cf f5				push af  
47d0 3a e4 47			ld a, (.dmark)  
47d3 32 6b ee			ld (debug_mark),a  
47d6 3a e5 47			ld a, (.dmark+1)  
47d9 32 6c ee			ld (debug_mark+1),a  
47dc 3a e6 47			ld a, (.dmark+2)  
47df 32 6d ee			ld (debug_mark+2),a  
47e2 18 03			jr .pastdmark  
47e4 ..			.dmark: db "AC1"  
47e7 f1			.pastdmark: pop af  
47e8			endm  
# End of macro DMARK
47e8						CALLMONITOR 
47e8 cd 6f ee			call debug_vector  
47eb				endm  
# End of macro CALLMONITOR
47eb					endif 
47eb cd db 1b				call forth_push_str 
47ee					NEXTW 
47ee c3 1a 1f			jp macro_next 
47f1				endm 
# End of macro NEXTW
47f1			 
47f1			.EDIT: 
47f1				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
47f1 40				db WORD_SYS_CORE+44             
47f2 93 48			dw .DEDIT            
47f4 05				db 4 + 1 
47f5 .. 00			db "EDIT",0              
47fa				endm 
# End of macro CWHEAD
47fa			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
47fa			 
47fa					; TODO does not copy from stack 
47fa					if DEBUG_FORTH_WORDS_KEY 
47fa						DMARK "EDT" 
47fa f5				push af  
47fb 3a 0f 48			ld a, (.dmark)  
47fe 32 6b ee			ld (debug_mark),a  
4801 3a 10 48			ld a, (.dmark+1)  
4804 32 6c ee			ld (debug_mark+1),a  
4807 3a 11 48			ld a, (.dmark+2)  
480a 32 6d ee			ld (debug_mark+2),a  
480d 18 03			jr .pastdmark  
480f ..			.dmark: db "EDT"  
4812 f1			.pastdmark: pop af  
4813			endm  
# End of macro DMARK
4813						CALLMONITOR 
4813 cd 6f ee			call debug_vector  
4816				endm  
# End of macro CALLMONITOR
4816					endif 
4816			 
4816					;FORTH_DSP 
4816					FORTH_DSP_VALUEHL 
4816 cd 64 1d			call macro_dsp_valuehl 
4819				endm 
# End of macro FORTH_DSP_VALUEHL
4819			;		inc hl    ; TODO do type check 
4819			 
4819			;		call get_word_hl 
4819 e5					push hl 
481a					if DEBUG_FORTH_WORDS 
481a						DMARK "EDp" 
481a f5				push af  
481b 3a 2f 48			ld a, (.dmark)  
481e 32 6b ee			ld (debug_mark),a  
4821 3a 30 48			ld a, (.dmark+1)  
4824 32 6c ee			ld (debug_mark+1),a  
4827 3a 31 48			ld a, (.dmark+2)  
482a 32 6d ee			ld (debug_mark+2),a  
482d 18 03			jr .pastdmark  
482f ..			.dmark: db "EDp"  
4832 f1			.pastdmark: pop af  
4833			endm  
# End of macro DMARK
4833						CALLMONITOR 
4833 cd 6f ee			call debug_vector  
4836				endm  
# End of macro CALLMONITOR
4836					endif 
4836				;	ld a, 0 
4836 cd 4c 11				call strlenz 
4839 23					inc hl 
483a			 
483a 06 00				ld b, 0 
483c 4d					ld c, l 
483d			 
483d e1					pop hl 
483e 11 bf e4				ld de, os_input 
4841					if DEBUG_FORTH_WORDS_KEY 
4841						DMARK "EDc" 
4841 f5				push af  
4842 3a 56 48			ld a, (.dmark)  
4845 32 6b ee			ld (debug_mark),a  
4848 3a 57 48			ld a, (.dmark+1)  
484b 32 6c ee			ld (debug_mark+1),a  
484e 3a 58 48			ld a, (.dmark+2)  
4851 32 6d ee			ld (debug_mark+2),a  
4854 18 03			jr .pastdmark  
4856 ..			.dmark: db "EDc"  
4859 f1			.pastdmark: pop af  
485a			endm  
# End of macro DMARK
485a						CALLMONITOR 
485a cd 6f ee			call debug_vector  
485d				endm  
# End of macro CALLMONITOR
485d					endif 
485d ed b0				ldir 
485f			 
485f			 
485f 21 bf e4				ld hl, os_input 
4862					;ld a, 0 
4862					;ld (hl),a 
4862 3a 5e ea				ld a,(f_cursor_ptr) 
4865 16 64				ld d, 100 
4867 0e 00				ld c, 0 
4869 1e 28				ld e, 40 
486b cd 13 0e				call input_str 
486e					; TODO perhaps do a type check and wrap in quotes if not a number 
486e 21 bf e4				ld hl, os_input 
4871					if DEBUG_FORTH_WORDS 
4871						DMARK "ED1" 
4871 f5				push af  
4872 3a 86 48			ld a, (.dmark)  
4875 32 6b ee			ld (debug_mark),a  
4878 3a 87 48			ld a, (.dmark+1)  
487b 32 6c ee			ld (debug_mark+1),a  
487e 3a 88 48			ld a, (.dmark+2)  
4881 32 6d ee			ld (debug_mark+2),a  
4884 18 03			jr .pastdmark  
4886 ..			.dmark: db "ED1"  
4889 f1			.pastdmark: pop af  
488a			endm  
# End of macro DMARK
488a						CALLMONITOR 
488a cd 6f ee			call debug_vector  
488d				endm  
# End of macro CALLMONITOR
488d					endif 
488d cd db 1b				call forth_push_str 
4890					NEXTW 
4890 c3 1a 1f			jp macro_next 
4893				endm 
# End of macro NEXTW
4893			 
4893			.DEDIT: 
4893				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4893 40				db WORD_SYS_CORE+44             
4894 f5 48			dw .ENDKEY            
4896 06				db 5 + 1 
4897 .. 00			db "DEDIT",0              
489d				endm 
# End of macro CWHEAD
489d			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
489d			 
489d					; TODO does not copy from stack 
489d					if DEBUG_FORTH_WORDS_KEY 
489d						DMARK "DED" 
489d f5				push af  
489e 3a b2 48			ld a, (.dmark)  
48a1 32 6b ee			ld (debug_mark),a  
48a4 3a b3 48			ld a, (.dmark+1)  
48a7 32 6c ee			ld (debug_mark+1),a  
48aa 3a b4 48			ld a, (.dmark+2)  
48ad 32 6d ee			ld (debug_mark+2),a  
48b0 18 03			jr .pastdmark  
48b2 ..			.dmark: db "DED"  
48b5 f1			.pastdmark: pop af  
48b6			endm  
# End of macro DMARK
48b6						CALLMONITOR 
48b6 cd 6f ee			call debug_vector  
48b9				endm  
# End of macro CALLMONITOR
48b9					endif 
48b9			 
48b9					;FORTH_DSP 
48b9					FORTH_DSP_VALUEHL 
48b9 cd 64 1d			call macro_dsp_valuehl 
48bc				endm 
# End of macro FORTH_DSP_VALUEHL
48bc			;		inc hl    ; TODO do type check 
48bc			 
48bc			;		call get_word_hl 
48bc e5					push hl 
48bd e5					push hl 
48be					FORTH_DSP_POP 
48be cd 1c 1e			call macro_forth_dsp_pop 
48c1				endm 
# End of macro FORTH_DSP_POP
48c1 e1					pop hl 
48c2					if DEBUG_FORTH_WORDS 
48c2						DMARK "EDp" 
48c2 f5				push af  
48c3 3a d7 48			ld a, (.dmark)  
48c6 32 6b ee			ld (debug_mark),a  
48c9 3a d8 48			ld a, (.dmark+1)  
48cc 32 6c ee			ld (debug_mark+1),a  
48cf 3a d9 48			ld a, (.dmark+2)  
48d2 32 6d ee			ld (debug_mark+2),a  
48d5 18 03			jr .pastdmark  
48d7 ..			.dmark: db "EDp"  
48da f1			.pastdmark: pop af  
48db			endm  
# End of macro DMARK
48db						CALLMONITOR 
48db cd 6f ee			call debug_vector  
48de				endm  
# End of macro CALLMONITOR
48de					endif 
48de				;	ld a, 0 
48de cd 4c 11				call strlenz 
48e1 23					inc hl 
48e2			 
48e2 06 00				ld b, 0 
48e4 4d					ld c, l 
48e5			 
48e5 e1					pop hl 
48e6			 
48e6					;ld a, 0 
48e6					;ld (hl),a 
48e6 3a 5e ea				ld a,(f_cursor_ptr) 
48e9 16 64				ld d, 100 
48eb 0e 00				ld c, 0 
48ed 1e 28				ld e, 40 
48ef cd 13 0e				call input_str 
48f2					; TODO perhaps do a type check and wrap in quotes if not a number 
48f2					NEXTW 
48f2 c3 1a 1f			jp macro_next 
48f5				endm 
# End of macro NEXTW
48f5			 
48f5			 
48f5			.ENDKEY: 
48f5			; eof 
48f5			 
# End of file forth_words_key.asm
48f5			include "forth_words_const.asm" 
48f5			 
48f5			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
48f5			 
48f5			 
48f5			.SPITIME: 
48f5				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
48f5 77				db WORD_SYS_CORE+99             
48f6 0a 49			dw .VA            
48f8 08				db 7 + 1 
48f9 .. 00			db "SPITIME",0              
4901				endm 
# End of macro CWHEAD
4901			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
4901			; 
4901			; | | If using BANK devices then leave as is. 
4901			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
4901			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
4901			 
4901 21 64 ea				ld hl, spi_clktime  
4904 cd 6d 1b				call forth_push_numhl 
4907			 
4907					NEXTW 
4907 c3 1a 1f			jp macro_next 
490a				endm 
# End of macro NEXTW
490a			 
490a			 
490a			.VA: 
490a				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
490a 77				db WORD_SYS_CORE+99             
490b 1a 49			dw .SYMBOL            
490d 03				db 2 + 1 
490e .. 00			db "VA",0              
4911				endm 
# End of macro CWHEAD
4911			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
4911 21 28 ea				ld hl, cli_var_array 
4914 cd 6d 1b				call forth_push_numhl 
4917			 
4917					NEXTW 
4917 c3 1a 1f			jp macro_next 
491a				endm 
# End of macro NEXTW
491a			 
491a			.SYMBOL: 
491a				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
491a 77				db WORD_SYS_CORE+99             
491b 24 4a			dw .ENDCONST            
491d 07				db 6 + 1 
491e .. 00			db "SYMBOL",0              
4925				endm 
# End of macro CWHEAD
4925			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4925			; | 
4925			; | | The value is the number reference and the final address is pushed to stack 
4925			 
4925			; | | ``` 
4925			; | | dw sym_table 
4925			; | | dw nmi_vector 
4925			; | | dw cli_autodisplay 
4925			; | | dw cli_data_sp 
4925			; | | dw cli_data_stack 
4925			; | | dw cli_loop_sp 
4925			; | | dw cli_loop_stack 
4925			; | | dw cli_var_array 
4925			; | | dw cursor_col 
4925			; | | dw cursor_ptr 
4925			; | | ; 10 
4925			; | | dw cursor_row 
4925			; | | dw debug_mark 
4925			; | | dw display_fb0 
4925			; | | dw display_fb1 
4925			; | | dw display_fb2 
4925			; | | dw display_fb3 
4925			; | | dw display_fb_active 
4925			; | | dw execscratch 
4925			; | | dw f_cursor_ptr 
4925			; | | dw hardware_word 
4925			; | | ;20 
4925			; | | dw input_at_cursor 
4925			; | | dw input_at_pos 
4925			; | | dw input_cur_flash 
4925			; | | dw input_cur_onoff 
4925			; | | dw input_cursor 
4925			; | | dw input_display_size 
4925			; | | dw input_len 
4925			; | | dw input_ptr 
4925			; | | dw input_size 
4925			; | | dw input_start 
4925			; | | ; 30 
4925			; | | dw input_str 
4925			; | | dw input_under_cursor 
4925			; | | dw os_cli_cmd 
4925			; | | dw os_cur_ptr 
4925			; | | dw os_current_i 
4925			; | | dw os_input 
4925			; | | dw os_last_cmd 
4925			; | | dw os_last_new_uword 
4925			; | | dw debug_vector 
4925			; | | dw os_view_hl 
4925			; | | ;40 
4925			; | | dw os_word_scratch 
4925			; | | dw portbctl 
4925			; | | dw portbdata 
4925			; | | dw spi_cartdev 
4925			; | | dw spi_cartdev2 
4925			; | | dw spi_clktime 
4925			; | | dw spi_device 
4925			; | | dw spi_device_id 
4925			; | | dw spi_portbyte 
4925			; | | dw stackstore 
4925			; | | ; 50 
4925			; | | if STORAGE_SE 
4925			; | | dw storage_actl 
4925			; | | dw storage_adata 
4925			; | | else 
4925			; | | dw 0 
4925			; | | dw 0 
4925			; | | endif 
4925			; | | dw storage_append 
4925			; | | if STORAGE_SE 
4925			; | | dw storage_bctl 
4925			; | | else 
4925			; | | dw 0 
4925			; | | endif 
4925			; | | dw store_bank_active 
4925			; | | dw store_filecache 
4925			; | | dw store_longread 
4925			; | | dw store_openaddr 
4925			; | | dw store_openext 
4925			; | | dw store_openmaxext 
4925			; | | ; 60 
4925			; | | dw store_page 
4925			; | | dw store_readbuf 
4925			; | | dw store_readcont 
4925			; | | dw store_readptr 
4925			; | | dw store_tmpext 
4925			; | | dw store_tmpid 
4925			; | | dw store_tmppageid 
4925			; | | dw malloc 
4925			; | | dw free 
4925			; | | dw cin 
4925			; | | ; 70 
4925			; | | dw cin_wait 
4925			; | | dw forth_push_numhl 
4925			; | | dw forth_push_str 
4925			; | | ``` 
4925			 
4925					if DEBUG_FORTH_WORDS_KEY 
4925						DMARK "SYM" 
4925 f5				push af  
4926 3a 3a 49			ld a, (.dmark)  
4929 32 6b ee			ld (debug_mark),a  
492c 3a 3b 49			ld a, (.dmark+1)  
492f 32 6c ee			ld (debug_mark+1),a  
4932 3a 3c 49			ld a, (.dmark+2)  
4935 32 6d ee			ld (debug_mark+2),a  
4938 18 03			jr .pastdmark  
493a ..			.dmark: db "SYM"  
493d f1			.pastdmark: pop af  
493e			endm  
# End of macro DMARK
493e						CALLMONITOR 
493e cd 6f ee			call debug_vector  
4941				endm  
# End of macro CALLMONITOR
4941					endif 
4941			 
4941					FORTH_DSP_VALUEHL 
4941 cd 64 1d			call macro_dsp_valuehl 
4944				endm 
# End of macro FORTH_DSP_VALUEHL
4944			 
4944 7d					ld a, l     
4945			 
4945			 
4945					if DEBUG_FORTH_WORDS 
4945						DMARK "SY1" 
4945 f5				push af  
4946 3a 5a 49			ld a, (.dmark)  
4949 32 6b ee			ld (debug_mark),a  
494c 3a 5b 49			ld a, (.dmark+1)  
494f 32 6c ee			ld (debug_mark+1),a  
4952 3a 5c 49			ld a, (.dmark+2)  
4955 32 6d ee			ld (debug_mark+2),a  
4958 18 03			jr .pastdmark  
495a ..			.dmark: db "SY1"  
495d f1			.pastdmark: pop af  
495e			endm  
# End of macro DMARK
495e						CALLMONITOR 
495e cd 6f ee			call debug_vector  
4961				endm  
# End of macro CALLMONITOR
4961					endif 
4961					 
4961 f5					push af	 
4962					FORTH_DSP_POP 
4962 cd 1c 1e			call macro_forth_dsp_pop 
4965				endm 
# End of macro FORTH_DSP_POP
4965 f1					pop af 
4966			 
4966 cb 27				sla a  
4968				 
4968					 
4968					if DEBUG_FORTH_WORDS 
4968						DMARK "SY" 
4968 f5				push af  
4969 3a 7d 49			ld a, (.dmark)  
496c 32 6b ee			ld (debug_mark),a  
496f 3a 7e 49			ld a, (.dmark+1)  
4972 32 6c ee			ld (debug_mark+1),a  
4975 3a 7f 49			ld a, (.dmark+2)  
4978 32 6d ee			ld (debug_mark+2),a  
497b 18 02			jr .pastdmark  
497d ..			.dmark: db "SY"  
497f f1			.pastdmark: pop af  
4980			endm  
# End of macro DMARK
4980						CALLMONITOR 
4980 cd 6f ee			call debug_vector  
4983				endm  
# End of macro CALLMONITOR
4983					endif 
4983			 
4983 21 92 49				ld hl, sym_table 
4986 cd e6 0d				call addatohl 
4989 cd 9c 1e				call loadwordinhl 
498c cd 6d 1b				call forth_push_numhl 
498f			 
498f			 
498f				       NEXTW 
498f c3 1a 1f			jp macro_next 
4992				endm 
# End of macro NEXTW
4992			 
4992			sym_table: 
4992			 
4992			; 0 
4992 92 49		dw sym_table 
4994 72 ee		dw nmi_vector 
4996 3c ea		dw cli_autodisplay 
4998 ee e9		dw cli_data_sp 
499a 28 e8		dw cli_data_stack 
499c f0 e9		dw cli_loop_sp 
499e 2a e9		dw cli_loop_stack 
49a0 28 ea		dw cli_var_array 
49a2 c5 eb		dw cursor_col 
49a4 c3 eb		dw cursor_ptr 
49a6			; 10 
49a6 c4 eb		dw cursor_row 
49a8 6b ee		dw debug_mark 
49aa b1 ed		dw display_fb0 
49ac 10 ed		dw display_fb1 
49ae ce eb		dw display_fb2 
49b0 6f ec		dw display_fb3 
49b2 cc eb		dw display_fb_active 
49b4 c0 e3		dw execscratch 
49b6 5e ea		dw f_cursor_ptr 
49b8 75 ee		dw hardware_word 
49ba			;20 
49ba 62 ee		dw input_at_cursor 
49bc 64 ee		dw input_at_pos 
49be 60 ee		dw input_cur_flash 
49c0 5f ee		dw input_cur_onoff 
49c2 55 ee		dw input_cursor 
49c4 65 ee		dw input_display_size 
49c6 5a ee		dw input_len 
49c8 69 ee		dw input_ptr 
49ca 66 ee		dw input_size 
49cc 67 ee		dw input_start 
49ce			; 30 
49ce 13 0e		dw input_str 
49d0 63 ee		dw input_under_cursor 
49d2 e8 e5		dw os_cli_cmd 
49d4 e4 e5		dw os_cur_ptr 
49d6 e6 e5		dw os_current_i 
49d8 bf e4		dw os_input 
49da e7 e6		dw os_last_cmd 
49dc be e5		dw os_last_new_uword 
49de 6f ee		dw debug_vector 
49e0 a3 e2		dw os_view_hl 
49e2			;40 
49e2 c6 e5		dw os_word_scratch 
49e4 c3 00		dw portbctl 
49e6 c1 00		dw portbdata 
49e8 63 ea		dw spi_cartdev 
49ea 62 ea		dw spi_cartdev2 
49ec 64 ea		dw spi_clktime 
49ee 60 ea		dw spi_device 
49f0 5f ea		dw spi_device_id 
49f2 61 ea		dw spi_portbyte 
49f4 a7 eb		dw stackstore 
49f6			; 50 
49f6			if STORAGE_SE 
49f6			dw storage_actl 
49f6			dw storage_adata 
49f6			else 
49f6 00 00		dw 0 
49f8 00 00		dw 0 
49fa			endif 
49fa 68 09		dw storage_append 
49fc			if STORAGE_SE 
49fc			dw storage_bctl 
49fc			else 
49fc 00 00		dw 0 
49fe			endif 
49fe 93 eb		dw store_bank_active 
4a00 67 ea		dw store_filecache 
4a02 75 ea		dw store_longread 
4a04 6b ea		dw store_openaddr 
4a06 6a ea		dw store_openext 
4a08 69 ea		dw store_openmaxext 
4a0a			; 60 
4a0a 7a ea		dw store_page 
4a0c 76 ea		dw store_readbuf 
4a0e 6d ea		dw store_readcont 
4a10 78 ea		dw store_readptr 
4a12 6d ea		dw store_tmpext 
4a14 6e ea		dw store_tmpid 
4a16 65 ea		dw store_tmppageid 
4a18 c1 11		dw malloc 
4a1a 8b 12		dw free 
4a1c 4d 5e		dw cin 
4a1e			; 70 
4a1e 45 5e		dw cin_wait 
4a20 6d 1b		dw forth_push_numhl 
4a22 db 1b		dw forth_push_str 
4a24			 
4a24			 
4a24			.ENDCONST: 
4a24			 
4a24			; eof 
4a24			 
4a24			 
# End of file forth_words_const.asm
4a24			 
4a24			if STORAGE_SE 
4a24			   	include "forth_words_storage.asm" 
4a24			endif 
4a24				include "forth_words_device.asm" 
4a24			; Device related words 
4a24			 
4a24			; | ## Device Words 
4a24			 
4a24			;if SOUND_ENABLE 
4a24			;.NOTE: 
4a24			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4a24			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
4a24			;		if DEBUG_FORTH_WORDS_KEY 
4a24			;			DMARK "NTE" 
4a24			;			CALLMONITOR 
4a24			;		endif 
4a24			; 
4a24			;	 
4a24			; 
4a24			;		NEXTW 
4a24			;.AFTERSOUND: 
4a24			;endif 
4a24			 
4a24			 
4a24			USE_GPIO: equ 0 
4a24			 
4a24			if USE_GPIO 
4a24			.GP1: 
4a24				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4a24			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
4a24					NEXTW 
4a24			.GP2: 
4a24				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4a24			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
4a24			 
4a24					NEXTW 
4a24			 
4a24			.GP3: 
4a24				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4a24			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
4a24			 
4a24					NEXTW 
4a24			 
4a24			.GP4: 
4a24				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4a24			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
4a24			 
4a24					NEXTW 
4a24			.SIN: 
4a24			 
4a24			 
4a24			endif 
4a24			 
4a24			 
4a24				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4a24 33				db WORD_SYS_CORE+31             
4a25 59 4a			dw .SOUT            
4a27 03				db 2 + 1 
4a28 .. 00			db "IN",0              
4a2b				endm 
# End of macro CWHEAD
4a2b			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4a2b					if DEBUG_FORTH_WORDS_KEY 
4a2b						DMARK "IN." 
4a2b f5				push af  
4a2c 3a 40 4a			ld a, (.dmark)  
4a2f 32 6b ee			ld (debug_mark),a  
4a32 3a 41 4a			ld a, (.dmark+1)  
4a35 32 6c ee			ld (debug_mark+1),a  
4a38 3a 42 4a			ld a, (.dmark+2)  
4a3b 32 6d ee			ld (debug_mark+2),a  
4a3e 18 03			jr .pastdmark  
4a40 ..			.dmark: db "IN."  
4a43 f1			.pastdmark: pop af  
4a44			endm  
# End of macro DMARK
4a44						CALLMONITOR 
4a44 cd 6f ee			call debug_vector  
4a47				endm  
# End of macro CALLMONITOR
4a47					endif 
4a47					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a47 cd 64 1d			call macro_dsp_valuehl 
4a4a				endm 
# End of macro FORTH_DSP_VALUEHL
4a4a			 
4a4a e5					push hl 
4a4b			 
4a4b					; destroy value TOS 
4a4b			 
4a4b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a4b cd 1c 1e			call macro_forth_dsp_pop 
4a4e				endm 
# End of macro FORTH_DSP_POP
4a4e			 
4a4e					; one value on hl get other one back 
4a4e			 
4a4e c1					pop bc 
4a4f			 
4a4f					; do the sub 
4a4f			;		ex de, hl 
4a4f			 
4a4f ed 68				in l,(c) 
4a51			 
4a51					; save it 
4a51			 
4a51 26 00				ld h,0 
4a53			 
4a53					; TODO push value back onto stack for another op etc 
4a53			 
4a53 cd 6d 1b				call forth_push_numhl 
4a56					NEXTW 
4a56 c3 1a 1f			jp macro_next 
4a59				endm 
# End of macro NEXTW
4a59			.SOUT: 
4a59				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4a59 34				db WORD_SYS_CORE+32             
4a5a ac 4a			dw .SPIO            
4a5c 04				db 3 + 1 
4a5d .. 00			db "OUT",0              
4a61				endm 
# End of macro CWHEAD
4a61			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4a61					if DEBUG_FORTH_WORDS_KEY 
4a61						DMARK "OUT" 
4a61 f5				push af  
4a62 3a 76 4a			ld a, (.dmark)  
4a65 32 6b ee			ld (debug_mark),a  
4a68 3a 77 4a			ld a, (.dmark+1)  
4a6b 32 6c ee			ld (debug_mark+1),a  
4a6e 3a 78 4a			ld a, (.dmark+2)  
4a71 32 6d ee			ld (debug_mark+2),a  
4a74 18 03			jr .pastdmark  
4a76 ..			.dmark: db "OUT"  
4a79 f1			.pastdmark: pop af  
4a7a			endm  
# End of macro DMARK
4a7a						CALLMONITOR 
4a7a cd 6f ee			call debug_vector  
4a7d				endm  
# End of macro CALLMONITOR
4a7d					endif 
4a7d			 
4a7d					; get port 
4a7d			 
4a7d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a7d cd 64 1d			call macro_dsp_valuehl 
4a80				endm 
# End of macro FORTH_DSP_VALUEHL
4a80			 
4a80 e5					push hl 
4a81			 
4a81					; destroy value TOS 
4a81			 
4a81					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a81 cd 1c 1e			call macro_forth_dsp_pop 
4a84				endm 
# End of macro FORTH_DSP_POP
4a84			 
4a84					; get byte to send 
4a84			 
4a84					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a84 cd 64 1d			call macro_dsp_valuehl 
4a87				endm 
# End of macro FORTH_DSP_VALUEHL
4a87			 
4a87			;		push hl 
4a87			 
4a87					; destroy value TOS 
4a87			 
4a87					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a87 cd 1c 1e			call macro_forth_dsp_pop 
4a8a				endm 
# End of macro FORTH_DSP_POP
4a8a			 
4a8a					; one value on hl get other one back 
4a8a			 
4a8a			;		pop hl 
4a8a			 
4a8a c1					pop bc 
4a8b			 
4a8b					if DEBUG_FORTH_WORDS 
4a8b						DMARK "OUT" 
4a8b f5				push af  
4a8c 3a a0 4a			ld a, (.dmark)  
4a8f 32 6b ee			ld (debug_mark),a  
4a92 3a a1 4a			ld a, (.dmark+1)  
4a95 32 6c ee			ld (debug_mark+1),a  
4a98 3a a2 4a			ld a, (.dmark+2)  
4a9b 32 6d ee			ld (debug_mark+2),a  
4a9e 18 03			jr .pastdmark  
4aa0 ..			.dmark: db "OUT"  
4aa3 f1			.pastdmark: pop af  
4aa4			endm  
# End of macro DMARK
4aa4						CALLMONITOR 
4aa4 cd 6f ee			call debug_vector  
4aa7				endm  
# End of macro CALLMONITOR
4aa7					endif 
4aa7			 
4aa7 ed 69				out (c), l 
4aa9			 
4aa9					NEXTW 
4aa9 c3 1a 1f			jp macro_next 
4aac				endm 
# End of macro NEXTW
4aac			 
4aac			 
4aac			.SPIO: 
4aac			 
4aac			if STORAGE_SE 
4aac				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4aac			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4aac			 
4aac					call spi_ce_low 
4aac			    NEXTW 
4aac			 
4aac			.SPICEH: 
4aac				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4aac			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4aac			 
4aac					call spi_ce_high 
4aac			    NEXTW 
4aac			 
4aac			 
4aac			.SPIOb: 
4aac			 
4aac				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4aac			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4aac			 
4aac					if DEBUG_FORTH_WORDS_KEY 
4aac						DMARK "SPo" 
4aac						CALLMONITOR 
4aac					endif 
4aac					; get port 
4aac			 
4aac			 
4aac					; get byte to send 
4aac			 
4aac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aac			 
4aac			;		push hl    ; u1  
4aac			 
4aac					; destroy value TOS 
4aac			 
4aac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aac			 
4aac					; one value on hl get other one back 
4aac			 
4aac			;		pop hl   ; u2 - addr 
4aac			 
4aac					; TODO Send SPI byte 
4aac			 
4aac			;		push hl 
4aac			;		call spi_ce_low 
4aac			;		pop hl 
4aac					ld a, l 
4aac					call spi_send_byte 
4aac			;		call spi_ce_high 
4aac			 
4aac					NEXTW 
4aac			 
4aac			.SPII: 
4aac				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4aac			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4aac					if DEBUG_FORTH_WORDS_KEY 
4aac						DMARK "SPi" 
4aac						CALLMONITOR 
4aac					endif 
4aac			 
4aac					; TODO Get SPI byte 
4aac			 
4aac					call spi_read_byte 
4aac			 
4aac					if DEBUG_FORTH_WORDS 
4aac						DMARK "Si2" 
4aac						CALLMONITOR 
4aac					endif 
4aac					ld h, 0 
4aac					ld l, a 
4aac					if DEBUG_FORTH_WORDS 
4aac						DMARK "Si3" 
4aac						CALLMONITOR 
4aac					endif 
4aac					call forth_push_numhl 
4aac			 
4aac					NEXTW 
4aac			 
4aac			 
4aac			 
4aac			.SESEL: 
4aac				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4aac			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4aac					if DEBUG_FORTH_WORDS_KEY 
4aac						DMARK "BNK" 
4aac						CALLMONITOR 
4aac					endif 
4aac			 
4aac					ld a, 255 
4aac					ld (spi_cartdev), a 
4aac			 
4aac					; get bank 
4aac			 
4aac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aac			 
4aac			;		push hl 
4aac			 
4aac					; destroy value TOS 
4aac			 
4aac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aac			 
4aac					; one value on hl get other one back 
4aac			 
4aac			;		pop hl 
4aac			 
4aac			 
4aac					ld c, SPI_CE_HIGH 
4aac					ld b, '0'    ; human readable bank number 
4aac			 
4aac					ld a, l 
4aac			 
4aac					if DEBUG_FORTH_WORDS 
4aac						DMARK "BNK" 
4aac						CALLMONITOR 
4aac					endif 
4aac			 
4aac					; active low 
4aac			 
4aac					cp 0 
4aac					jr z, .bset 
4aac					cp 1 
4aac					jr nz, .b2 
4aac					res 0, c 
4aac					ld b, '1'    ; human readable bank number 
4aac			.b2:		cp 2 
4aac					jr nz, .b3 
4aac					res 1, c 
4aac					ld b, '2'    ; human readable bank number 
4aac			.b3:		cp 3 
4aac					jr nz, .b4 
4aac					res 2, c 
4aac					ld b, '3'    ; human readable bank number 
4aac			.b4:		cp 4 
4aac					jr nz, .b5 
4aac					res 3, c 
4aac					ld b, '4'    ; human readable bank number 
4aac			.b5:		cp 5 
4aac					jr nz, .bset 
4aac					res 4, c 
4aac					ld b, '5'    ; human readable bank number 
4aac			 
4aac			.bset: 
4aac					ld a, c 
4aac					ld (spi_device),a 
4aac					ld a, b 
4aac					ld (spi_device_id),a 
4aac					if DEBUG_FORTH_WORDS 
4aac						DMARK "BN2" 
4aac						CALLMONITOR 
4aac					endif 
4aac			 
4aac					; set default SPI clk pulse time as disabled for BANK use 
4aac			 
4aac					ld a, 0 
4aac					ld (spi_clktime), a 
4aac			 
4aac					NEXTW 
4aac			 
4aac			.CARTDEV: 
4aac				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4aac			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4aac					if DEBUG_FORTH_WORDS_KEY 
4aac						DMARK "CDV" 
4aac						CALLMONITOR 
4aac					endif 
4aac			 
4aac					; disable se storage bank selection 
4aac			 
4aac					ld a, SPI_CE_HIGH		; ce high 
4aac					ld (spi_device), a 
4aac			 
4aac					; get bank 
4aac			 
4aac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aac			 
4aac			;		push hl 
4aac			 
4aac					; destroy value TOS 
4aac			 
4aac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aac			 
4aac					; one value on hl get other one back 
4aac			 
4aac			;		pop hl 
4aac			 
4aac					; active low 
4aac			 
4aac					ld c, 255 
4aac			 
4aac					ld a, l 
4aac					if DEBUG_FORTH_WORDS 
4aac						DMARK "CDV" 
4aac						CALLMONITOR 
4aac					endif 
4aac					cp 0 
4aac					jr z, .cset 
4aac					cp 1 
4aac					jr nz, .c2 
4aac					res 0, c 
4aac			.c2:		cp 2 
4aac					jr nz, .c3 
4aac					res 1, c 
4aac			.c3:		cp 3 
4aac					jr nz, .c4 
4aac					res 2, c 
4aac			.c4:		cp 4 
4aac					jr nz, .c5 
4aac					res 3, c 
4aac			.c5:		cp 5 
4aac					jr nz, .c6 
4aac					res 4, c 
4aac			.c6:		cp 6 
4aac					jr nz, .c7 
4aac					res 5, c 
4aac			.c7:		cp 7 
4aac					jr nz, .c8 
4aac					res 6, c 
4aac			.c8:		cp 8 
4aac					jr nz, .cset 
4aac					res 7, c 
4aac			.cset:		ld a, c 
4aac					ld (spi_cartdev),a 
4aac			 
4aac					if DEBUG_FORTH_WORDS 
4aac						DMARK "CD2" 
4aac						CALLMONITOR 
4aac					endif 
4aac			 
4aac					; set default SPI clk pulse time as 10ms for CARTDEV use 
4aac			 
4aac					ld a, $0a 
4aac					ld (spi_clktime), a 
4aac					NEXTW 
4aac			endif 
4aac			 
4aac			.ENDDEVICE: 
4aac			; eof 
4aac			 
# End of file forth_words_device.asm
4aac			 
4aac			; var handler 
4aac			 
4aac			 
4aac			.VARS: 
4aac				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
4aac 77				db WORD_SYS_CORE+99             
4aad 5d 4b			dw .V0            
4aaf 04				db 3 + 1 
4ab0 .. 00			db "VAR",0              
4ab4				endm 
# End of macro CWHEAD
4ab4			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4ab4			;| 
4ab4			;| The variable name should consist of a single letter. e.g. "a" 
4ab4			;! If a full string is passed then only the first char is looked at 
4ab4			;| Any other char could exceed bounds checks!  
4ab4			 
4ab4					if DEBUG_FORTH_WORDS_KEY 
4ab4						DMARK "VAR" 
4ab4 f5				push af  
4ab5 3a c9 4a			ld a, (.dmark)  
4ab8 32 6b ee			ld (debug_mark),a  
4abb 3a ca 4a			ld a, (.dmark+1)  
4abe 32 6c ee			ld (debug_mark+1),a  
4ac1 3a cb 4a			ld a, (.dmark+2)  
4ac4 32 6d ee			ld (debug_mark+2),a  
4ac7 18 03			jr .pastdmark  
4ac9 ..			.dmark: db "VAR"  
4acc f1			.pastdmark: pop af  
4acd			endm  
# End of macro DMARK
4acd						CALLMONITOR 
4acd cd 6f ee			call debug_vector  
4ad0				endm  
# End of macro CALLMONITOR
4ad0					endif 
4ad0			 
4ad0					FORTH_DSP_VALUEHL 
4ad0 cd 64 1d			call macro_dsp_valuehl 
4ad3				endm 
# End of macro FORTH_DSP_VALUEHL
4ad3			 
4ad3 7e					ld a, (hl)    ; get first char on of the string 
4ad4			 
4ad4			 
4ad4					if DEBUG_FORTH_WORDS 
4ad4						DMARK "VR1" 
4ad4 f5				push af  
4ad5 3a e9 4a			ld a, (.dmark)  
4ad8 32 6b ee			ld (debug_mark),a  
4adb 3a ea 4a			ld a, (.dmark+1)  
4ade 32 6c ee			ld (debug_mark+1),a  
4ae1 3a eb 4a			ld a, (.dmark+2)  
4ae4 32 6d ee			ld (debug_mark+2),a  
4ae7 18 03			jr .pastdmark  
4ae9 ..			.dmark: db "VR1"  
4aec f1			.pastdmark: pop af  
4aed			endm  
# End of macro DMARK
4aed						CALLMONITOR 
4aed cd 6f ee			call debug_vector  
4af0				endm  
# End of macro CALLMONITOR
4af0					endif 
4af0					 
4af0 f5					push af	 
4af1					FORTH_DSP_POP 
4af1 cd 1c 1e			call macro_forth_dsp_pop 
4af4				endm 
# End of macro FORTH_DSP_POP
4af4 f1					pop af 
4af5			 
4af5					; convert to upper 
4af5			 
4af5 cd 5b 10				call to_upper 
4af8					if DEBUG_FORTH_WORDS 
4af8						DMARK "Vaa" 
4af8 f5				push af  
4af9 3a 0d 4b			ld a, (.dmark)  
4afc 32 6b ee			ld (debug_mark),a  
4aff 3a 0e 4b			ld a, (.dmark+1)  
4b02 32 6c ee			ld (debug_mark+1),a  
4b05 3a 0f 4b			ld a, (.dmark+2)  
4b08 32 6d ee			ld (debug_mark+2),a  
4b0b 18 03			jr .pastdmark  
4b0d ..			.dmark: db "Vaa"  
4b10 f1			.pastdmark: pop af  
4b11			endm  
# End of macro DMARK
4b11						CALLMONITOR 
4b11 cd 6f ee			call debug_vector  
4b14				endm  
# End of macro CALLMONITOR
4b14					endif 
4b14 06 41				ld b, 'A' 
4b16 90					sub b			; set offset 
4b17					if DEBUG_FORTH_WORDS 
4b17						DMARK "Vbb" 
4b17 f5				push af  
4b18 3a 2c 4b			ld a, (.dmark)  
4b1b 32 6b ee			ld (debug_mark),a  
4b1e 3a 2d 4b			ld a, (.dmark+1)  
4b21 32 6c ee			ld (debug_mark+1),a  
4b24 3a 2e 4b			ld a, (.dmark+2)  
4b27 32 6d ee			ld (debug_mark+2),a  
4b2a 18 03			jr .pastdmark  
4b2c ..			.dmark: db "Vbb"  
4b2f f1			.pastdmark: pop af  
4b30			endm  
# End of macro DMARK
4b30						CALLMONITOR 
4b30 cd 6f ee			call debug_vector  
4b33				endm  
# End of macro CALLMONITOR
4b33					endif 
4b33 cb 27				sla a  
4b35				 
4b35					 
4b35					if DEBUG_FORTH_WORDS 
4b35						DMARK "VR2" 
4b35 f5				push af  
4b36 3a 4a 4b			ld a, (.dmark)  
4b39 32 6b ee			ld (debug_mark),a  
4b3c 3a 4b 4b			ld a, (.dmark+1)  
4b3f 32 6c ee			ld (debug_mark+1),a  
4b42 3a 4c 4b			ld a, (.dmark+2)  
4b45 32 6d ee			ld (debug_mark+2),a  
4b48 18 03			jr .pastdmark  
4b4a ..			.dmark: db "VR2"  
4b4d f1			.pastdmark: pop af  
4b4e			endm  
# End of macro DMARK
4b4e						CALLMONITOR 
4b4e cd 6f ee			call debug_vector  
4b51				endm  
# End of macro CALLMONITOR
4b51					endif 
4b51			 
4b51 21 f4 e9				ld hl, cli_var_array2 
4b54 cd e6 0d				call addatohl 
4b57 cd 6d 1b				call forth_push_numhl 
4b5a			 
4b5a			 
4b5a				       NEXTW 
4b5a c3 1a 1f			jp macro_next 
4b5d				endm 
# End of macro NEXTW
4b5d			.V0: 
4b5d				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4b5d 78				db WORD_SYS_CORE+100             
4b5e 75 4b			dw .V0Q            
4b60 04				db 3 + 1 
4b61 .. 00			db "V0!",0              
4b65				endm 
# End of macro CWHEAD
4b65			;| V0! ( u1 -- )  Store value to v0  | DONE 
4b65			 
4b65					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b65 cd 64 1d			call macro_dsp_valuehl 
4b68				endm 
# End of macro FORTH_DSP_VALUEHL
4b68			 
4b68 11 28 ea				ld de, cli_var_array 
4b6b			 
4b6b eb					ex de, hl 
4b6c 73					ld (hl), e 
4b6d 23					inc hl 
4b6e 72					ld (hl), d 
4b6f			 
4b6f					; destroy value TOS 
4b6f			 
4b6f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b6f cd 1c 1e			call macro_forth_dsp_pop 
4b72				endm 
# End of macro FORTH_DSP_POP
4b72			 
4b72				       NEXTW 
4b72 c3 1a 1f			jp macro_next 
4b75				endm 
# End of macro NEXTW
4b75			.V0Q: 
4b75				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4b75 79				db WORD_SYS_CORE+101             
4b76 86 4b			dw .V1S            
4b78 04				db 3 + 1 
4b79 .. 00			db "V0@",0              
4b7d				endm 
# End of macro CWHEAD
4b7d			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4b7d 2a 28 ea				ld hl, (cli_var_array) 
4b80 cd 6d 1b				call forth_push_numhl 
4b83			 
4b83				       NEXTW 
4b83 c3 1a 1f			jp macro_next 
4b86				endm 
# End of macro NEXTW
4b86			.V1S: 
4b86				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4b86 7a				db WORD_SYS_CORE+102             
4b87 9e 4b			dw .V1Q            
4b89 04				db 3 + 1 
4b8a .. 00			db "V1!",0              
4b8e				endm 
# End of macro CWHEAD
4b8e			;| V1! ( u1 -- )  Store value to v1 | DONE 
4b8e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b8e cd 64 1d			call macro_dsp_valuehl 
4b91				endm 
# End of macro FORTH_DSP_VALUEHL
4b91			 
4b91 11 2a ea				ld de, cli_var_array+2 
4b94				 
4b94 eb					ex de, hl 
4b95 73					ld (hl), e 
4b96 23					inc hl 
4b97 72					ld (hl), d 
4b98			 
4b98					; destroy value TOS 
4b98			 
4b98					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b98 cd 1c 1e			call macro_forth_dsp_pop 
4b9b				endm 
# End of macro FORTH_DSP_POP
4b9b				       NEXTW 
4b9b c3 1a 1f			jp macro_next 
4b9e				endm 
# End of macro NEXTW
4b9e			.V1Q: 
4b9e				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4b9e 7b				db WORD_SYS_CORE+103             
4b9f af 4b			dw .V2S            
4ba1 04				db 3 + 1 
4ba2 .. 00			db "V1@",0              
4ba6				endm 
# End of macro CWHEAD
4ba6			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4ba6 2a 2a ea				ld hl, (cli_var_array+2) 
4ba9 cd 6d 1b				call forth_push_numhl 
4bac				       NEXTW 
4bac c3 1a 1f			jp macro_next 
4baf				endm 
# End of macro NEXTW
4baf			.V2S: 
4baf				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4baf 7c				db WORD_SYS_CORE+104             
4bb0 c7 4b			dw .V2Q            
4bb2 04				db 3 + 1 
4bb3 .. 00			db "V2!",0              
4bb7				endm 
# End of macro CWHEAD
4bb7			;| V2! ( u1 -- )  Store value to v2 | DONE 
4bb7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bb7 cd 64 1d			call macro_dsp_valuehl 
4bba				endm 
# End of macro FORTH_DSP_VALUEHL
4bba			 
4bba 11 2c ea				ld de, cli_var_array+4 
4bbd				 
4bbd eb					ex de, hl 
4bbe 73					ld (hl), e 
4bbf 23					inc hl 
4bc0 72					ld (hl), d 
4bc1			 
4bc1					; destroy value TOS 
4bc1			 
4bc1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bc1 cd 1c 1e			call macro_forth_dsp_pop 
4bc4				endm 
# End of macro FORTH_DSP_POP
4bc4				       NEXTW 
4bc4 c3 1a 1f			jp macro_next 
4bc7				endm 
# End of macro NEXTW
4bc7			.V2Q: 
4bc7				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4bc7 7d				db WORD_SYS_CORE+105             
4bc8 d8 4b			dw .V3S            
4bca 04				db 3 + 1 
4bcb .. 00			db "V2@",0              
4bcf				endm 
# End of macro CWHEAD
4bcf			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4bcf 2a 2c ea				ld hl, (cli_var_array+4) 
4bd2 cd 6d 1b				call forth_push_numhl 
4bd5				       NEXTW 
4bd5 c3 1a 1f			jp macro_next 
4bd8				endm 
# End of macro NEXTW
4bd8			.V3S: 
4bd8				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4bd8 7c				db WORD_SYS_CORE+104             
4bd9 f0 4b			dw .V3Q            
4bdb 04				db 3 + 1 
4bdc .. 00			db "V3!",0              
4be0				endm 
# End of macro CWHEAD
4be0			;| V3! ( u1 -- )  Store value to v3 | DONE 
4be0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4be0 cd 64 1d			call macro_dsp_valuehl 
4be3				endm 
# End of macro FORTH_DSP_VALUEHL
4be3			 
4be3 11 2e ea				ld de, cli_var_array+6 
4be6				 
4be6 eb					ex de, hl 
4be7 73					ld (hl), e 
4be8 23					inc hl 
4be9 72					ld (hl), d 
4bea			 
4bea					; destroy value TOS 
4bea			 
4bea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bea cd 1c 1e			call macro_forth_dsp_pop 
4bed				endm 
# End of macro FORTH_DSP_POP
4bed				       NEXTW 
4bed c3 1a 1f			jp macro_next 
4bf0				endm 
# End of macro NEXTW
4bf0			.V3Q: 
4bf0				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4bf0 7d				db WORD_SYS_CORE+105             
4bf1 01 4c			dw .END            
4bf3 04				db 3 + 1 
4bf4 .. 00			db "V3@",0              
4bf8				endm 
# End of macro CWHEAD
4bf8			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4bf8 2a 2e ea				ld hl, (cli_var_array+6) 
4bfb cd 6d 1b				call forth_push_numhl 
4bfe				       NEXTW 
4bfe c3 1a 1f			jp macro_next 
4c01				endm 
# End of macro NEXTW
4c01			 
4c01			 
4c01			 
4c01			 
4c01			 
4c01			; end of dict marker 
4c01			 
4c01 00			.END:    db WORD_SYS_END 
4c02 00 00			dw 0 
4c04 00				db 0 
4c05			 
4c05			; use to jp here for user dict words to save on macro expansion  
4c05			 
4c05			user_dict_next: 
4c05				NEXTW 
4c05 c3 1a 1f			jp macro_next 
4c08				endm 
# End of macro NEXTW
4c08			 
4c08			 
4c08			user_exec: 
4c08				;    ld hl, <word code> 
4c08				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4c08				;    call forthexec 
4c08				;    jp user_dict_next   (NEXT) 
4c08			        ;    <word code bytes> 
4c08 eb				ex de, hl 
4c09 2a c2 e5			ld hl,(os_tok_ptr) 
4c0c				 
4c0c				FORTH_RSP_NEXT 
4c0c cd 14 1b			call macro_forth_rsp_next 
4c0f				endm 
# End of macro FORTH_RSP_NEXT
4c0f			 
4c0f			if DEBUG_FORTH_UWORD 
4c0f						DMARK "UEX" 
4c0f f5				push af  
4c10 3a 24 4c			ld a, (.dmark)  
4c13 32 6b ee			ld (debug_mark),a  
4c16 3a 25 4c			ld a, (.dmark+1)  
4c19 32 6c ee			ld (debug_mark+1),a  
4c1c 3a 26 4c			ld a, (.dmark+2)  
4c1f 32 6d ee			ld (debug_mark+2),a  
4c22 18 03			jr .pastdmark  
4c24 ..			.dmark: db "UEX"  
4c27 f1			.pastdmark: pop af  
4c28			endm  
# End of macro DMARK
4c28				CALLMONITOR 
4c28 cd 6f ee			call debug_vector  
4c2b				endm  
# End of macro CALLMONITOR
4c2b			endif 
4c2b			 
4c2b			 
4c2b			 
4c2b eb				ex de, hl 
4c2c 22 c2 e5			ld (os_tok_ptr), hl 
4c2f				 
4c2f				; Don't use next - Skips the first word in uword. 
4c2f			 
4c2f c3 ab 1f			jp exec1 
4c32			;	NEXT 
4c32			 
4c32			 
4c32			; eof 
# End of file forth_wordsv4.asm
4c32			endif 
4c32			;;;;;;;;;;;;;; Debug code 
4c32			 
4c32			 
4c32			;if DEBUG_FORTH_PARSE 
4c32 .. 00		.nowordfound: db "No match",0 
4c3b .. 00		.compword:	db "Comparing word ",0 
4c4b .. 00		.nextwordat:	db "Next word at",0 
4c58 .. 00		.charmatch:	db "Char match",0 
4c63			;endif 
4c63			if DEBUG_FORTH_JP 
4c63			.foundword:	db "Word match. Exec..",0 
4c63			endif 
4c63			;if DEBUG_FORTH_PUSH 
4c63 .. 00		.enddict:	db "Dict end. Push.",0 
4c73 .. 00		.push_str:	db "Pushing string",0 
4c82 .. 00		.push_num:	db "Pushing number",0 
4c91 .. 00		.data_sp:	db "SP:",0 
4c95 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4ca7 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4cb9 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4ccb			;endif 
4ccb			;if DEBUG_FORTH_MALLOC 
4ccb .. 00		.push_malloc:	db "Malloc address",0 
4cda			;endif 
4cda			 
4cda			 
4cda			 
4cda			; display malloc address and current data stack pointer  
4cda			 
4cda			malloc_error: 
4cda d5				push de 
4cdb f5				push af 
4cdc e5				push hl 
4cdd cd b9 0b			call clear_display 
4ce0 11 00 4d			ld de, .mallocerr 
4ce3 3e 00			ld a,0 
4ce5			;	ld de,os_word_scratch 
4ce5 cd cc 0b			call str_at_display 
4ce8 3e 11			ld a, display_row_1+17 
4cea 11 6b ee			ld de, debug_mark 
4ced cd cc 0b			call str_at_display 
4cf0 cd dc 0b			call update_display 
4cf3				;call break_point_state 
4cf3 cd 45 5e			call cin_wait 
4cf6			 
4cf6			;	ld a, ' ' 
4cf6			;	ld (os_view_disable), a 
4cf6 cd f0 14			call bp_on 
4cf9 e1				pop hl 
4cfa f1				pop af 
4cfb d1				pop de	 
4cfc				CALLMONITOR 
4cfc cd 6f ee			call debug_vector  
4cff				endm  
# End of macro CALLMONITOR
4cff c9				ret 
4d00			 
4d00 .. 00		.mallocerr: 	db "Malloc Error",0 
4d0d			;if DEBUG_FORTH_PUSH 
4d0d			display_data_sp: 
4d0d f5				push af 
4d0e			 
4d0e				; see if disabled 
4d0e			 
4d0e			 
4d0e 3a 6f ee			ld a, (debug_vector) 
4d11 fe c9			cp $C9  ; RET 
4d13				;ld a, (os_view_disable) 
4d13				;cp '*' 
4d13 28 67			jr z, .skipdsp 
4d15			 
4d15 e5				push hl 
4d16 e5				push hl 
4d17 e5			push hl 
4d18 cd b9 0b			call clear_display 
4d1b e1			pop hl 
4d1c 7c				ld a,h 
4d1d 21 c6 e5			ld hl, os_word_scratch 
4d20 cd ef 0f			call hexout 
4d23 e1				pop hl 
4d24 7d				ld a,l 
4d25 21 c8 e5			ld hl, os_word_scratch+2 
4d28 cd ef 0f			call hexout 
4d2b 21 ca e5			ld hl, os_word_scratch+4 
4d2e 3e 00			ld a,0 
4d30 77				ld (hl),a 
4d31 11 c6 e5			ld de,os_word_scratch 
4d34 3e 28				ld a, display_row_2 
4d36 cd cc 0b				call str_at_display 
4d39 11 95 4c			ld de, .wordinhl 
4d3c 3e 00			ld a, display_row_1 
4d3e			 
4d3e cd cc 0b				call str_at_display 
4d41 11 6b ee			ld de, debug_mark 
4d44 3e 11			ld a, display_row_1+17 
4d46			 
4d46 cd cc 0b				call str_at_display 
4d49			 
4d49				; display current data stack pointer 
4d49 11 91 4c			ld de,.data_sp 
4d4c 3e 30				ld a, display_row_2 + 8 
4d4e cd cc 0b				call str_at_display 
4d51			 
4d51 2a ee e9			ld hl,(cli_data_sp) 
4d54 e5				push hl 
4d55 7c				ld a,h 
4d56 21 c6 e5			ld hl, os_word_scratch 
4d59 cd ef 0f			call hexout 
4d5c e1				pop hl 
4d5d 7d				ld a,l 
4d5e 21 c8 e5			ld hl, os_word_scratch+2 
4d61 cd ef 0f			call hexout 
4d64 21 ca e5			ld hl, os_word_scratch+4 
4d67 3e 00			ld a,0 
4d69 77				ld (hl),a 
4d6a 11 c6 e5			ld de,os_word_scratch 
4d6d 3e 33				ld a, display_row_2 + 11 
4d6f cd cc 0b				call str_at_display 
4d72			 
4d72			 
4d72 cd dc 0b			call update_display 
4d75 cd f1 0a			call delay1s 
4d78 cd f1 0a			call delay1s 
4d7b e1				pop hl 
4d7c			.skipdsp: 
4d7c f1				pop af 
4d7d c9				ret 
4d7e			 
4d7e			display_data_malloc: 
4d7e			 
4d7e f5				push af 
4d7f e5				push hl 
4d80 e5				push hl 
4d81 e5			push hl 
4d82 cd b9 0b			call clear_display 
4d85 e1			pop hl 
4d86 7c				ld a,h 
4d87 21 c6 e5			ld hl, os_word_scratch 
4d8a cd ef 0f			call hexout 
4d8d e1				pop hl 
4d8e 7d				ld a,l 
4d8f 21 c8 e5			ld hl, os_word_scratch+2 
4d92 cd ef 0f			call hexout 
4d95 21 ca e5			ld hl, os_word_scratch+4 
4d98 3e 00			ld a,0 
4d9a 77				ld (hl),a 
4d9b 11 c6 e5			ld de,os_word_scratch 
4d9e 3e 28				ld a, display_row_2 
4da0 cd cc 0b				call str_at_display 
4da3 11 cb 4c			ld de, .push_malloc 
4da6 3e 00			ld a, display_row_1 
4da8			 
4da8 cd cc 0b				call str_at_display 
4dab			 
4dab				; display current data stack pointer 
4dab 11 91 4c			ld de,.data_sp 
4dae 3e 30				ld a, display_row_2 + 8 
4db0 cd cc 0b				call str_at_display 
4db3			 
4db3 2a ee e9			ld hl,(cli_data_sp) 
4db6 e5				push hl 
4db7 7c				ld a,h 
4db8 21 c6 e5			ld hl, os_word_scratch 
4dbb cd ef 0f			call hexout 
4dbe e1				pop hl 
4dbf 7d				ld a,l 
4dc0 21 c8 e5			ld hl, os_word_scratch+2 
4dc3 cd ef 0f			call hexout 
4dc6 21 ca e5			ld hl, os_word_scratch+4 
4dc9 3e 00			ld a,0 
4dcb 77				ld (hl),a 
4dcc 11 c6 e5			ld de,os_word_scratch 
4dcf 3e 33				ld a, display_row_2 + 11 
4dd1 cd cc 0b				call str_at_display 
4dd4			 
4dd4 cd dc 0b			call update_display 
4dd7 cd f1 0a			call delay1s 
4dda cd f1 0a			call delay1s 
4ddd e1				pop hl 
4dde f1				pop af 
4ddf c9				ret 
4de0			;endif 
4de0			 
4de0			include "forth_autostart.asm" 
4de0			; list of commands to perform at system start up 
4de0			 
4de0			startcmds: 
4de0			;	dw test11 
4de0			;	dw test12 
4de0			;	dw test13 
4de0			;	dw test14 
4de0			;	dw test15 
4de0			;	dw test16 
4de0			;	dw test17 
4de0			;	dw ifthtest1 
4de0			;	dw ifthtest2 
4de0			;	dw ifthtest3 
4de0			;	dw mmtest1 
4de0			;	dw mmtest2 
4de0			;	dw mmtest3 
4de0			;	dw mmtest4 
4de0			;	dw mmtest5 
4de0			;	dw mmtest6 
4de0			;	dw iftest1 
4de0			;	dw iftest2 
4de0			;	dw iftest3 
4de0			;	dw looptest1 
4de0			;	dw looptest2 
4de0			;	dw test1 
4de0			;	dw test2 
4de0			;	dw test3 
4de0			;	dw test4 
4de0			;	dw game2r 
4de0			;	dw game2b1 
4de0			;	dw game2b2 
4de0			 
4de0				; start up words that are actually useful 
4de0			 
4de0			;    dw spi1 
4de0			;    dw spi2 
4de0			;    dw spi3 
4de0			;    dw spi4 
4de0			;    dw spi5 
4de0			;    dw spi6 
4de0			;    dw spi7 
4de0			; 
4de0			;    dw spi8 
4de0			;    dw spi9 
4de0			;    dw spi10 
4de0			 
4de0			; file editor 
4de0			;	dw edit1 
4de0			;	dw edit2 
4de0			;	dw edit3 
4de0			 
4de0			;	dw longread 
4de0 00 52			dw clrstack 
4de2 34 52			dw type 
4de4			;	dw stest 
4de4 59 52			dw strncpy 
4de6			;	dw list 
4de6 ba 52			dw start1 
4de8 ca 52			dw start2 
4dea			;	dw start3 
4dea			;	dw start3b 
4dea			;	dw start3c 
4dea			 
4dea				; (unit) testing words 
4dea			 
4dea			;	dw mtesta 
4dea			;	dw mtestb 
4dea			;	dw mtestc 
4dea			;	dw mtestd 
4dea			;	dw mteste 
4dea			 
4dea				; demo/game words 
4dea			 
4dea			;        dw game3w 
4dea			;        dw game3p 
4dea			;        dw game3sc 
4dea			;        dw game3vsi 
4dea			;        dw game3vs 
4dea				 
4dea			;	dw game2b 
4dea			;	dw game2bf 
4dea			;	dw game2mba 
4dea			;	dw game2mbas 
4dea			;	dw game2mb 
4dea			 
4dea e7 55			dw game1 
4dec f8 55			dw game1a 
4dee 5a 56			dw game1b 
4df0 8f 56			dw game1c 
4df2 c5 56			dw game1d 
4df4 f6 56			dw game1s 
4df6 0a 57			dw game1t 
4df8 1f 57			dw game1f 
4dfa 53 57			dw game1z 
4dfc 97 57			dw game1zz 
4dfe			 
4dfe 20 54			dw test5 
4e00 58 54			dw test6 
4e02 90 54			dw test7 
4e04 a4 54			dw test8 
4e06 d0 54			dw test9 
4e08 e6 54			dw test10 
4e0a				 
4e0a 6e 58		        dw ssv5 
4e0c 52 58		        dw ssv4 
4e0e 36 58		        dw ssv3 
4e10 00 58		        dw ssv2 
4e12 87 58		        dw ssv1 
4e14 cf 58		        dw ssv1cpm 
4e16			;	dw keyup 
4e16			;	dw keydown 
4e16			;	dw keyleft 
4e16			;	dw keyright 
4e16			;	dw 	keyf1 
4e16			;	dw keyf2 
4e16			;	dw keyf3 
4e16			;	dw keyf4 
4e16			;	dw keyf5 
4e16			;	dw keyf6 
4e16			;	dw keyf7 
4e16			;	dw keyf8 
4e16			;	dw keyf9 
4e16			;	dw keyf10 
4e16			;	dw keyf11 
4e16			;	dw keyf12 
4e16			;	dw keytab 
4e16			;	dw keycr 
4e16			;	dw keyhome 
4e16			;	dw keyend 
4e16			;	dw keybs 
4e16 00 00			db 0, 0	 
4e18			 
4e18			 
4e18			; File Editor 
4e18			 
4e18			; ( id - ) use 'e' to edit the displayed line 
4e18 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
4e39 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4e6e			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4e6e .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
4ea6			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
4ea6			 
4ea6			; SPI Net support words 
4ea6			 
4ea6			; v0! = node to send to 
4ea6			; ( str count - ) 
4ea6 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
4eff			 
4eff			; spiputc ( char node - ) 
4eff .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
4f33			; spiputc ( u node - ) 
4f33 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
4f61			 
4f61			; spigetc ( - n ) 
4f61 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
4f8a			 
4f8a			; getnode ( - n ) 
4f8a .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
4fb7			 
4fb7			; ( str node - )  
4fb7 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
501d			; store string ( str i - ) 
501d			 
501d			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
501d .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
5072			 
5072			; get string ( addr i -  )    TO FIX 
5072			 
5072 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
50ca			 
50ca			 
50ca			; NETCHAT (TODO) 
50ca			; Program to allow two nodes to chat with eachother 
50ca			; 
50ca			; v0 - target node 
50ca			;  
50ca			; accept input at 0,0 
50ca			; if input is string send spitype to target node 
50ca			; starting at row 2,0 , while spigetchr is not zero ->  
50ca			; 
50ca			; 
50ca			; TODO add paging of get request 
50ca			 
50ca			; ( node - ) 
50ca .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
50e9 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5141 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
51b9			 
51b9			 
51b9			; Long read of currently open file 
51b9 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5200			 
5200			; clear stack  
5200			 
5200 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
5234			 
5234			; type ( addr count - ) 
5234 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
5259			 
5259			; some direct memory words 
5259			; strncpy ( len t f -- t ) 
5259			 
5259 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
52ba			 
52ba .. 00		start1:     	db ": bpon $00 bp ;",0 
52ca .. 00		start2:     	db ": bpoff $01 bp ;",0 
52db .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
5356 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
53b6			 
53b6			 
53b6			; a handy word to list items on the stack 
53b6			 
53b6 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5420			 
5420			 
5420			; test stack  
5420			; rnd8 stest 
5420			 
5420			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5420			 
5420			; random malloc and free cycles 
5420			 
5420			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5420			 
5420			; fixed malloc and free cycles 
5420			 
5420			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5420			 
5420			; fixed double string push and drop cycle  
5420			 
5420			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5420			 
5420			; consistent fixed string push and drop cycle  
5420			 
5420			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5420			 
5420			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5420			 
5420			;test1:		db ": aa 1 2 3 ;", 0 
5420			;test2:     	db "111 aa 888 999",0 
5420			;test3:     	db ": bb 77 ;",0 
5420			;test4:     	db "$02 $01 do i . loop bb",0 
5420			 
5420 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5458 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5490 .. 00		test7:     	db ": box hline vline ;",0 
54a4 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
54d0 .. 00		test9:     	db ": sw $01 adsp world ;",0 
54e6 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
550b			;test11:     	db "hello create .",0 
550b			;test12:     	db "hello2 create .",0 
550b			 
550b			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
550b			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
550b			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
550b			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
550b			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
550b			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
550b			 
550b			;iftest1:     	db "$0001 IF cls .",0 
550b			;iftest2:     	db "$0000 IF cls .",0 
550b			;iftest3:     	db "$0002 $0003 - IF cls .",0 
550b			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
550b			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
550b			 
550b			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
550b			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
550b			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
550b			 
550b			 
550b .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
552f .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
555f .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
5584 .. 00		sound4: db ": cha $00 ; ",0 
5591 .. 00		sound5: db ": chb $20 ; ",0 
559e .. 00		sound6: db ": chc $40 ; ",0 
55ab .. 00		sound7: db ": chd $60 ; ",0 
55b8 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
55d0 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
55e7			 
55e7			 
55e7			 
55e7			 
55e7			; a small guess the number game 
55e7			 
55e7 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
55f8 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
565a			 
565a .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
568f .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
56c5 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
56f6 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
570a .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
571f .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5753 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5797			 
5797			; Using 'ga' save a high score across multiple runs using external storage 
5797			 
5797 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5800			 
5800			 
5800			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5800			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5800			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5800			 
5800			; simple screen saver to test code memory reuse to destruction 
5800			 
5800 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5836 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5852 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
586e .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5887 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
58cf .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5926			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5926			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5926			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5926			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5926			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5926			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5926			 
5926			 
5926			 
5926			; minesweeper/battleship finding game 
5926			; draws a game board of random ship/mine positions 
5926			; user enters coords to see if it hits on 
5926			; game ends when all are hit 
5926			; when hit or miss says how many may be in the area 
5926			 
5926			; setup the game board and then hide it 
5926			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5926			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5926			;; prompt for where to target 
5926			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5926			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5926			;; TODO see if the entered coords hits or misses pushes char hit of miss 
5926			;game2mbht:      db ": mbckht nop ;",0 
5926			;game2mbms:      db ": mbcms nop ;",0 
5926			; TODO how many might be near by 
5926			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5926			 
5926			; Game 3 
5926			 
5926			; Vert scroller ski game - avoid the trees! 
5926			 
5926			; v0 score (ie turns) 
5926			; v1 player pos 
5926			; v2 left wall 
5926			; v3 right wall 
5926			 
5926			; Draw side walls randomly 
5926			 
5926			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5926			 
5926			; Draw player 
5926			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5926			 
5926			; TODO Get Key 
5926			 
5926			; TODO Move left right 
5926			 
5926			; scroll and move walls a bit 
5926			 
5926			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5926			 
5926			; main game loop 
5926			 
5926			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5926			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5926			 
5926			; key board defs 
5926			 
5926 .. 00		keyup:       db ": keyup $05 ;",0 
5934 .. 00		keydown:       db ": keydown $0a ;",0 
5944 .. 00		keyleft:       db ": keyleft $0b ;",0 
5954 .. 00		keyright:       db ": keyright $0c ;",0 
5965 .. 00		keyf1:       db ": keyf1 $10 ;",0 
5973 .. 00		keyf2:       db ": keyf2 $11 ;",0 
5981 .. 00		keyf3:       db ": keyf3 $12 ;",0 
598f .. 00		keyf4:       db ": keyf4 $13 ;",0 
599d .. 00		keyf5:       db ": keyf5 $14 ;",0 
59ab .. 00		keyf6:       db ": keyf6 $15 ;",0 
59b9 .. 00		keyf7:       db ": keyf7 $16 ;",0 
59c7 .. 00		keyf8:       db ": keyf8 $17 ;",0 
59d5 .. 00		keyf9:       db ": keyf9 $18 ;",0 
59e3 .. 00		keyf10:       db ": keyf10 $19 ;",0 
59f2 .. 00		keyf11:       db ": keyf11 $1a ;",0 
5a01 .. 00		keyf12:       db ": keyf12 $1b ;",0 
5a10			 
5a10 .. 00		keytab:       db ": keytab $09 ;",0 
5a1f .. 00		keycr:       db ": keycr $0d ;",0 
5a2d .. 00		keyhome:       db ": keyhome $0e ;",0 
5a3d .. 00		keyend:       db ": keyend $0f ;",0 
5a4c .. 00		keybs:       db ": keybs $08 ;",0 
5a5a			 
5a5a			   
5a5a			 
5a5a			 
5a5a			 
5a5a			; eof 
# End of file forth_autostart.asm
5a5a			 
5a5a			 
5a5a			 
5a5a			; stack over and underflow checks 
5a5a			 
5a5a			; init the words to detect the under/overflow 
5a5a			 
5a5a			chk_stk_init: 
5a5a				; a vague random number to check so we dont get any "lucky" hits 
5a5a 3e 2d			ld a, 45 
5a5c 6f				ld l, a 
5a5d 00				nop 
5a5e 3e 17			ld a, 23 
5a60 67				ld h, a 
5a61			 
5a61 22 9d e2			ld (chk_word), hl     ; the word we need to check against 
5a64			 
5a64			;	ld (chk_stund), hl	; stack points.... 
5a64 22 00 ef			ld (chk_stovr), hl 
5a67 22 ec e9			ld (chk_ret_und), hl 
5a6a 22 aa e9			ld (chk_ret_ovr), hl 
5a6d 22 28 e9			ld (chk_loop_ovr), hl 
5a70 22 26 e8			ld (chk_data_ovr), hl 
5a73 c9				ret 
5a74				 
5a74			check_stacks: 
5a74				; check all stack words 
5a74			 
5a74 e5				push hl 
5a75 d5				push de 
5a76			 
5a76			;	ld de,(chk_word) 
5a76			;	ld hl, (chk_stund)	; stack points.... 
5a76			;	if DEBUG_STK_FAULT 
5a76			;		DMARK "FAa" 
5a76			;		CALLMONITOR 
5a76			;	endif 
5a76			;	call cmp16 
5a76			;	jp z, .chk_faulta 
5a76			; 
5a76			;	ld de, sfaultsu 
5a76			;	jp .chk_fault 
5a76			 
5a76 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
5a79 ed 5b 9d e2		ld de,(chk_word) 
5a7d				if DEBUG_STK_FAULT 
5a7d					DMARK "FAb" 
5a7d					CALLMONITOR 
5a7d				endif 
5a7d cd 04 0e			call cmp16 
5a80 28 06			jr z, .chk_fault1 
5a82 11 23 5b			ld de, sfaultso 
5a85 c3 d7 5a			jp .chk_fault 
5a88			.chk_fault1:  
5a88 2a ec e9			ld hl, (chk_ret_und) 
5a8b ed 5b 9d e2		ld de,(chk_word) 
5a8f				if DEBUG_STK_FAULT 
5a8f					DMARK "FAU" 
5a8f					CALLMONITOR 
5a8f				endif 
5a8f cd 04 0e			call cmp16 
5a92 ca 9b 5a			jp z, .chk_fault2 
5a95 11 33 5b			ld de, sfaultru 
5a98 c3 d7 5a			jp .chk_fault 
5a9b			.chk_fault2:  
5a9b 2a aa e9			ld hl, (chk_ret_ovr) 
5a9e ed 5b 9d e2		ld de,(chk_word) 
5aa2				if DEBUG_STK_FAULT 
5aa2					DMARK "FA1" 
5aa2					CALLMONITOR 
5aa2				endif 
5aa2 cd 04 0e			call cmp16 
5aa5 ca ae 5a			jp z, .chk_fault3 
5aa8 11 41 5b			ld de, sfaultro 
5aab c3 d7 5a			jp .chk_fault 
5aae			.chk_fault3:  
5aae 2a 28 e9			ld hl, (chk_loop_ovr) 
5ab1 ed 5b 9d e2		ld de,(chk_word) 
5ab5				if DEBUG_STK_FAULT 
5ab5					DMARK "FA2" 
5ab5					CALLMONITOR 
5ab5				endif 
5ab5 cd 04 0e			call cmp16 
5ab8 ca c1 5a			jp z, .chk_fault4 
5abb 11 5b 5b			ld de, sfaultlo 
5abe c3 d7 5a			jp .chk_fault 
5ac1			.chk_fault4:  
5ac1 2a 26 e8			ld hl, (chk_data_ovr) 
5ac4 ed 5b 9d e2		ld de,(chk_word) 
5ac8				if DEBUG_STK_FAULT 
5ac8					DMARK "FA3" 
5ac8					CALLMONITOR 
5ac8				endif 
5ac8 cd 04 0e			call cmp16 
5acb ca d4 5a			jp z, .chk_fault5 
5ace 11 75 5b			ld de, sfaultdo 
5ad1 c3 d7 5a			jp .chk_fault 
5ad4			 
5ad4			 
5ad4			.chk_fault5:  
5ad4 d1				pop de 
5ad5 e1				pop hl 
5ad6			 
5ad6 c9				ret 
5ad7			 
5ad7 cd b9 0b		.chk_fault: 	call clear_display 
5ada 3e 28				ld a, display_row_2 
5adc cd cc 0b				call str_at_display 
5adf 11 05 5b				   ld de, .stackfault 
5ae2 3e 00				ld a, display_row_1 
5ae4 cd cc 0b				call str_at_display 
5ae7 11 6b ee				    ld de, debug_mark 
5aea 3e 11				ld a, display_row_1+17 
5aec cd cc 0b				call str_at_display 
5aef cd dc 0b				call update_display 
5af2			 
5af2				; prompt before entering montior for investigating issue 
5af2			 
5af2 3e 78			ld a, display_row_4 
5af4 11 5f 18			ld de, endprog 
5af7			 
5af7 cd dc 0b			call update_display		 
5afa			 
5afa cd e5 1a			call next_page_prompt 
5afd			 
5afd d1				pop de 
5afe e1				pop hl 
5aff cd b3 18				call monitor 
5b02 c3 a9 17				jp warmstart 
5b05					;jp 0 
5b05					;halt 
5b05			 
5b05			 
5b05			 
5b05 .. 00		.stackfault: 	db "Stack fault:",0 
5b12			 
5b12 .. 00		sfaultsu: 	db	"Stack under flow",0 
5b23 .. 00		sfaultso: 	db	"Stack over flow",0 
5b33 .. 00		sfaultru:	db "RTS underflow",0 
5b41 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
5b5b .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
5b75 .. 00		sfaultdo:	db "DTS overflow", 0 
5b82			 
5b82			 
5b82			fault_dsp_under: 
5b82 11 94 5b			ld de, .dsp_under 
5b85 c3 44 5c			jp .show_fault 
5b88			 
5b88			fault_rsp_under: 
5b88 11 a2 5b			ld de, .rsp_under 
5b8b c3 44 5c			jp .show_fault 
5b8e			fault_loop_under: 
5b8e 11 b0 5b			ld de, .loop_under 
5b91 c3 44 5c			jp .show_fault 
5b94			 
5b94 .. 00		.dsp_under: db "DSP Underflow",0 
5ba2 .. 00		.rsp_under: db "RSP Underflow",0 
5bb0 .. 00		.loop_under: db "LOOP Underflow",0 
5bbf			 
5bbf			 
5bbf d5			type_faultn: 	push de 
5bc0 e5					push hl 
5bc1 cd b9 0b				call clear_display 
5bc4 11 eb 5b				   ld de, .typefaultn 
5bc7 3e 00				ld a, display_row_1 
5bc9 cd cc 0b				call str_at_display 
5bcc 11 6b ee				    ld de, debug_mark 
5bcf 3e 11				ld a, display_row_1+17 
5bd1 cd cc 0b				call str_at_display 
5bd4 cd dc 0b				call update_display 
5bd7			 
5bd7				; prompt before entering montior for investigating issue 
5bd7			 
5bd7 3e 78			ld a, display_row_4 
5bd9 11 5f 18			ld de, endprog 
5bdc			 
5bdc cd dc 0b			call update_display		 
5bdf			 
5bdf cd e5 1a			call next_page_prompt 
5be2			 
5be2 e5					push hl 
5be3 d5					push de 
5be4 cd b3 18				call monitor 
5be7 c3 a9 17				jp warmstart 
5bea 76					halt 
5beb			 
5beb			 
5beb .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
5c02			 
5c02 d5			type_faults: 	push de 
5c03 e5					push hl 
5c04 cd b9 0b				call clear_display 
5c07 11 2d 5c				   ld de, .typefaults 
5c0a 3e 00				ld a, display_row_1 
5c0c cd cc 0b				call str_at_display 
5c0f 11 6b ee				    ld de, debug_mark 
5c12 3e 11				ld a, display_row_1+17 
5c14 cd cc 0b				call str_at_display 
5c17 cd dc 0b				call update_display 
5c1a			 
5c1a				; prompt before entering montior for investigating issue 
5c1a			 
5c1a 3e 78			ld a, display_row_4 
5c1c 11 5f 18			ld de, endprog 
5c1f			 
5c1f cd dc 0b			call update_display		 
5c22			 
5c22 cd e5 1a			call next_page_prompt 
5c25			 
5c25 e1					pop hl 
5c26 d1					pop de 
5c27 cd b3 18				call monitor 
5c2a c3 a9 17				jp warmstart 
5c2d			 
5c2d			 
5c2d .. 00		.typefaults: db "STR Type Expected TOS!",0 
5c44			 
5c44			.show_fault: 	 
5c44 d5					push de 
5c45 cd b9 0b				call clear_display 
5c48 d1					pop de 
5c49 3e 00				ld a, display_row_1 
5c4b cd cc 0b				call str_at_display 
5c4e 11 6b ee				    ld de, debug_mark 
5c51 3e 11				ld a, display_row_1+17 
5c53 cd cc 0b				call str_at_display 
5c56 cd dc 0b				call update_display 
5c59			 
5c59				; prompt before entering montior for investigating issue 
5c59			 
5c59 3e 78			ld a, display_row_4 
5c5b 11 5f 18			ld de, endprog 
5c5e			 
5c5e cd dc 0b			call update_display		 
5c61			 
5c61 cd e5 1a			call next_page_prompt 
5c64			 
5c64 e1					pop hl 
5c65 d1					pop de 
5c66 cd b3 18				call monitor 
5c69			; do a dump to cli and not warmstart so we preserve all of the uwords.  
5c69			; TODO Make optional fault restart to cli or warm boot? 
5c69					;jp warmstart 
5c69 c3 f3 17				jp cli 
5c6c 76					halt 
5c6d			 
5c6d			; handle the auto run of code from files in storage 
5c6d			 
5c6d			 
5c6d			include "forth_startup.asm" 
5c6d			; Which startup method to use? 
5c6d			; 
5c6d			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
5c6d			; followed by loading of a list of scripts in eeprom 
5c6d			 
5c6d			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
5c6d			; from eeprom 
5c6d			 
5c6d			; Select with define in main stubs 
5c6d			 
5c6d			if STARTUP_V1 
5c6d				include "forth_startupv1.asm" 
5c6d			; Startup script loading version 1 
5c6d			 
5c6d			; If SE storage is available first stage is to use the selected file 
5c6d			; then go through the eeprom list 
5c6d			 
5c6d .. 00		sprompt1: db "Startup load...",0 
5c7d .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5c93			 
5c93			 
5c93			 
5c93			 
5c93			forth_startup: 
5c93 21 e0 4d			ld hl, startcmds 
5c96 3e 00			ld a, 0 
5c98 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
5c9b			 
5c9b e5			.start1:	push hl 
5c9c cd b9 0b			call clear_display 
5c9f 11 6d 5c			ld de, sprompt1 
5ca2 3e 00		        ld a, display_row_1 
5ca4 cd cc 0b			call str_at_display 
5ca7 11 7d 5c			ld de, sprompt2 
5caa 3e 28		        ld a, display_row_2 
5cac cd cc 0b			call str_at_display 
5caf e1				pop hl 
5cb0 e5				push hl 
5cb1 5e				ld e,(hl) 
5cb2 23				inc hl 
5cb3 56				ld d,(hl) 
5cb4 3e 50		        ld a, display_row_3 
5cb6 cd cc 0b			call str_at_display 
5cb9 cd dc 0b			call update_display 
5cbc			 
5cbc			 
5cbc 3a e7 e6			ld a, (os_last_cmd) 
5cbf fe 00			cp 0 
5cc1 28 05			jr z, .startprompt 
5cc3 cd e5 0a			call delay250ms 
5cc6 18 24			jr .startdo 
5cc8				 
5cc8				 
5cc8			 
5cc8			.startprompt: 
5cc8			 
5cc8 3e 9f			ld a,display_row_4 + display_cols - 1 
5cca 11 e3 1a		        ld de, endprg 
5ccd cd cc 0b			call str_at_display 
5cd0 cd dc 0b			call update_display 
5cd3 cd f1 0a			call delay1s 
5cd6 cd 45 5e			call cin_wait 
5cd9						 
5cd9 fe 2a			cp '*' 
5cdb 28 5e			jr z, .startupend1 
5cdd fe 23			cp '#' 
5cdf 20 07			jr nz, .startno 
5ce1 3e 01			ld a, 1 
5ce3 32 e7 e6			ld (os_last_cmd),a 
5ce6 18 04			jr .startdo 
5ce8 fe 31		.startno:	cp '1' 
5cea 28 3a			jr z,.startnxt  
5cec			 
5cec				; exec startup line 
5cec			.startdo:	 
5cec e1				pop hl 
5ced e5				push hl 
5cee				 
5cee 5e				ld e,(hl) 
5cef 23				inc hl 
5cf0 56				ld d,(hl) 
5cf1 eb				ex de,hl 
5cf2			 
5cf2 e5				push hl 
5cf3			 
5cf3 3e 00			ld a, 0 
5cf5				;ld a, FORTH_END_BUFFER 
5cf5 cd 57 11			call strlent 
5cf8 23				inc hl   ; include zero term to copy 
5cf9 06 00			ld b,0 
5cfb 4d				ld c,l 
5cfc e1				pop hl 
5cfd 11 c1 e2			ld de, scratch 
5d00 ed b0			ldir 
5d02			 
5d02			 
5d02 21 c1 e2			ld hl, scratch 
5d05 cd 68 1f			call forthparse 
5d08 cd a8 1f			call forthexec 
5d0b cd ba 1e			call forthexec_cleanup 
5d0e			 
5d0e 3e 78			ld a, display_row_4 
5d10 11 5f 18			ld de, endprog 
5d13			 
5d13 cd dc 0b			call update_display		 
5d16			 
5d16 3a e7 e6			ld a, (os_last_cmd) 
5d19 fe 00			cp 0 
5d1b 20 09			jr nz, .startnxt 
5d1d cd e5 1a			call next_page_prompt 
5d20 cd b9 0b		        call clear_display 
5d23 cd dc 0b			call update_display		 
5d26			 
5d26				; move onto next startup line? 
5d26			.startnxt: 
5d26			 
5d26 cd e5 0a			call delay250ms 
5d29 e1				pop hl 
5d2a			 
5d2a 23				inc hl 
5d2b 23				inc hl 
5d2c			 
5d2c e5				push hl 
5d2d 5e				ld e, (hl) 
5d2e 23				inc hl 
5d2f 56				ld d, (hl) 
5d30 e1				pop hl 
5d31				; TODO replace 0 test 
5d31			 
5d31 eb				ex de, hl 
5d32 cd 0f 0e			call ishlzero 
5d35			;	ld a,e 
5d35			;	add d 
5d35			;	cp 0    ; any left to do? 
5d35 eb				ex de, hl 
5d36 c2 9b 5c			jp nz, .start1 
5d39 18 01			jr .startupend 
5d3b			 
5d3b e1			.startupend1: pop hl 
5d3c			.startupend: 
5d3c			 
5d3c cd b9 0b			call clear_display 
5d3f cd dc 0b			call update_display 
5d42 c9				ret 
5d43			if STORAGE_SE 
5d43			 
5d43			sprompt3: db "Loading from start-up file?:",0 
5d43			sprompt4: db "(Y=Any key/N=No)",0 
5d43			 
5d43			 
5d43			forth_autoload: 
5d43			 
5d43				; load block 0 of store 1 
5d43				 
5d43				ld a, $fe      ; bit 0 clear 
5d43				ld (spi_device), a 
5d43			 
5d43				call storage_get_block_0 
5d43			 
5d43				ld a, (store_page+STORE_0_AUTOFILE) 
5d43			 
5d43				cp 0 
5d43				ret z     ; auto start not enabled 
5d43			 
5d43				call clear_display 
5d43			 
5d43				; set bank 
5d43			 
5d43					ld a, (store_page+STORE_0_BANKRUN) 
5d43					ld (spi_device), a 
5d43			 
5d43				; get file id to load from and get the file name to display 
5d43			 
5d43					ld a, (store_page+STORE_0_FILERUN) 
5d43			 
5d43					ld l, 0 
5d43					ld h, a 
5d43					ld de, store_page 
5d43			 
5d43					if DEBUG_FORTH_WORDS 
5d43						DMARK "ASp" 
5d43						CALLMONITOR 
5d43					endif 
5d43					call storage_read 
5d43			 
5d43					if DEBUG_FORTH_WORDS 
5d43						DMARK "ASr" 
5d43						CALLMONITOR 
5d43					endif 
5d43			 
5d43					call ishlzero 
5d43					ret z             ; file not found 
5d43			 
5d43					ld a, display_row_2 + 10 
5d43					ld de, store_page+3 
5d43					call str_at_display 
5d43				 
5d43			; 
5d43			 
5d43				ld a, display_row_1+5 
5d43				ld de, sprompt3 
5d43				call str_at_display 
5d43				ld a, display_row_3+15 
5d43				ld de, sprompt4 
5d43				call str_at_display 
5d43			 
5d43				call update_display 
5d43			 
5d43				call cin_wait 
5d43				cp 'n' 
5d43				ret z 
5d43				cp 'N' 
5d43				ret z 
5d43			 
5d43				call delay1s 
5d43			 
5d43				ld a, (store_page+2) 
5d43				ld (store_openmaxext), a    ; save count of ext 
5d43				ld a, 1  
5d43				ld (store_openext), a    ; save count of ext 
5d43			 
5d43			.autof:  
5d43				ld l , a 
5d43				 
5d43				ld a, (store_page) 
5d43				ld h, a	 
5d43				ld de, store_page 
5d43					if DEBUG_FORTH_WORDS 
5d43						DMARK "ASl" 
5d43						CALLMONITOR 
5d43					endif 
5d43					call storage_read 
5d43				call ishlzero 
5d43				ret z 
5d43			;	jr z, .autoend 
5d43			 
5d43					if DEBUG_FORTH_WORDS 
5d43						DMARK "ASc" 
5d43						CALLMONITOR 
5d43					endif 
5d43				ld de, store_page+2 
5d43				ld a, display_row_4 
5d43				call str_at_display 
5d43			 
5d43				call update_display 
5d43				call delay250ms 
5d43			 
5d43			 
5d43			 
5d43				ld hl, store_page+2 
5d43				call forthparse 
5d43				call forthexec 
5d43				call forthexec_cleanup 
5d43			 
5d43				 
5d43				ld a, (store_openext) 
5d43				inc a 
5d43				ld (store_openext), a    ; save count of ext 
5d43			 
5d43				jr .autof 
5d43			;.autofdone: 
5d43			; 
5d43			;		if DEBUG_FORTH_WORDS 
5d43			;			DMARK "ASx" 
5d43			;			CALLMONITOR 
5d43			;		endif 
5d43			;;	call clear_display 
5d43			;	ret 
5d43			 
5d43			 
5d43			 
5d43			endif 
# End of file forth_startupv1.asm
5d43			endif 
5d43			if STARTUP_V2 
5d43				include "forth_startupv2.asm" 
5d43			endif 
5d43			 
# End of file forth_startup.asm
5d43			 
5d43			; eof 
# End of file forth_kernel.asm
5d43			;include "nascombasic.asm" 
5d43			 
5d43			 
5d43			; find out where the code ends if loaded into RAM (for SC114) 
5d43			;endofcode:  
5d43			;	nop 
5d43			 
5d43			 
5d43			; jump to nmi vector 
5d43			 
5d43			init_nmi: 
5d43 3e c9			ld a, $c9   ; RET 
5d45 32 72 ee			ld (nmi_vector), a 
5d48 c9				ret 
5d49			nmi: 
5d49 e5				push hl 
5d4a d5				push de 
5d4b c5				push bc 
5d4c f5				push af 
5d4d cd 72 ee			call nmi_vector 
5d50 f5				push af 
5d51 c5				push bc 
5d52 d5				push de 
5d53 e5				push hl 
5d54 ed 4d			reti 
5d56			 
5d56			 
5d56			; eof 
5d56			 
# End of file main.asm
5d56			;include "firmware_lcd_4x40.asm" 
5d56			;;include "firmware_lcd_4x20.asm" 
5d56			include "firmware_cpm_display.asm" 
5d56			 
5d56			; Serial display interface for SC114 
5d56			 
5d56			 
5d56			display_row_1: equ 0 
5d56			display_row_2: equ display_row_1+display_cols 
5d56			display_row_3: equ display_row_2 + display_cols 
5d56			display_row_4: equ display_row_3 + display_cols 
5d56			 
5d56			kLCDWidth:  EQU display_cols             ;Width in characters 
5d56			kLCD_Line1: EQU 0x00  
5d56			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
5d56			; E1 
5d56			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
5d56			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
5d56			 
5d56			lcd_init: 
5d56				; no init as handled by the SCM bios 
5d56 c9				ret 
5d57			 
5d57			 
5d57			; low level functions for direct screen writes 
5d57			 
5d57			; output char at pos? 
5d57			fLCD_Str: 
5d57			        ;out (SC114_SIO_1_OUT),a 
5d57 c5				push bc 
5d58 d5				push de 
5d59 5f				ld e, a 
5d5a			; TODO Replace with CP/M BIOS call 
5d5a 0e 02			ld c, $02 
5d5c cd 05 00			call 5 
5d5f d1				pop de 
5d60 c1				pop bc 
5d61 c9				ret 
5d62			 
5d62			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
5d62			fLCD_Pos: 
5d62				; use ASCII escape to position 
5d62			        ;out (SC114_SIO_1_OUT),a 
5d62 c5				push bc 
5d63 d5				push de 
5d64 5f				ld e, a 
5d65 0e 02			ld c, $02 
5d67			; TODO Replace with CP/M BIOS call 
5d67 cd 05 00			call 5 
5d6a d1				pop de 
5d6b c1				pop bc 
5d6c			 
5d6c c9				ret 
5d6d			 
5d6d			; output char at pos 
5d6d			fLCD_Data: 
5d6d			      ;  out (SC114_SIO_1_OUT),a 
5d6d c5				push bc 
5d6e d5				push de 
5d6f 0e 02			ld c, $02 
5d71 5f				ld e, a 
5d72			; TODO Replace with CP/M BIOS call 
5d72 cd 05 00			call 5 
5d75 d1				pop de 
5d76 c1				pop bc 
5d77			 
5d77 c9				ret 
5d78			 
5d78			; ascii cls  
5d78			 
5d78 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
5d7c			 
5d7c 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
5d93			;.clscpm: db 3, $3c,"$" 
5d93			 
5d93			; write the frame buffer given in hl to hardware  
5d93			write_display: 
5d93			 
5d93			API: equ 0 
5d93			 
5d93			if API 
5d93				push bc 
5d93				ld b, 4 
5d93			 
5d93			        ld (display_write_tmp), hl 	  
5d93			 
5d93				; clear and home cursor 
5d93			 
5d93				ld c, 9 
5d93				ld de, .cls 
5d93			; TODO Replace with CP/M BIOS call 
5d93				call 5 
5d93			 
5d93			 
5d93			.writeln: 
5d93			 
5d93				ld de, (display_write_tmp) 
5d93				ld c, 6 
5d93			; TODO Replace with CP/M BIOS call 
5d93				rst $30 
5d93				ld c, 7 
5d93				rst $30 
5d93			 
5d93				ld hl, (display_write_tmp) 
5d93				ld de, display_cols 
5d93				add hl,de 
5d93				ld (display_write_tmp),hl 
5d93			 
5d93				djnz  .writeln 
5d93			 
5d93				pop bc 
5d93			 
5d93			 
5d93				ret 
5d93			endif 
5d93 e5				push hl 
5d94 c5				push bc 
5d95 d5				push de 
5d96			 
5d96			;	ld c, 2 
5d96			;	;ld de, .cls 
5d96			;	ld a, 27 
5d96			;	rst $30 
5d96			;	ld c, 2 
5d96			;	;ld de, .cls 
5d96			;	ld a, '[' 
5d96			;	rst $30 
5d96			; 
5d96			;	ld c, 2 
5d96			;	;ld de, .cls 
5d96			;	ld a, 'H' 
5d96			;	rst $30 
5d96			; 
5d96			 
5d96			 
5d96			; lots of CR/LF 
5d96			;	ld c, 9 
5d96			;	ld de, .clscpm 
5d96			;	call 5 
5d96			 
5d96			; xterm cls 
5d96 0e 02			ld c, 2 
5d98 1e 1b			ld e, 27 
5d9a cd 05 00			call 5 
5d9d			; cls causes too much flicker 
5d9d			;	ld c, 2 
5d9d			;	ld e, 'c' 
5d9d			;	call 5 
5d9d			 
5d9d			; use xterm home instead 
5d9d 0e 02			ld c, 2 
5d9f 1e 5b			ld e, '[' 
5da1 cd 05 00			call 5 
5da4 0e 02			ld c, 2 
5da6 1e 48			ld e, 'H' 
5da8 cd 05 00			call 5 
5dab			LLL: equ 0 
5dab			 
5dab			if LLL 
5dab			 
5dab				ld c, 2 
5dab				;ld de, .cls 
5dab				ld e, 27 
5dab			; TODO Replace with CP/M BIOS call 
5dab				call 5 
5dab			 
5dab			 
5dab				ld c, 2 
5dab				;ld de, .cls 
5dab				ld e, '[' 
5dab			; TODO Replace with CP/M BIOS call 
5dab				call 5 
5dab				ld c, 2 
5dab				;ld de, .cls 
5dab				ld e, '2' 
5dab			; TODO Replace with CP/M BIOS call 
5dab				call 5 
5dab				ld c, 2 
5dab				;ld de, .cls 
5dab				ld e, 'J' 
5dab			; TODO Replace with CP/M BIOS call 
5dab				call 5 
5dab			 
5dab			endif 
5dab			 
5dab d1				pop de 
5dac c1				pop bc 
5dad e1				pop hl 
5dae			 
5dae			 
5dae 22 c9 eb		        ld (display_write_tmp), hl 	  
5db1 3e 00			ld a, kLCD_Line1 
5db3			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5db3 06 28			ld b, display_cols 
5db5 ed 5b c9 eb		ld de, (display_write_tmp) 
5db9 cd 3c 5e			call write_len_string 
5dbc				 
5dbc			 
5dbc e5			push hl 
5dbd d5			push de 
5dbe c5			push bc 
5dbf 0e 02			ld c, 2 
5dc1 1e 0a			ld e, 10 
5dc3 cd 05 00			call 5 
5dc6 0e 02			ld c, 2 
5dc8 1e 0d			ld e, 13 
5dca cd 05 00			call 5 
5dcd			; TODO Replace with CP/M BIOS call 
5dcd				;rst $30 
5dcd c1			pop bc 
5dce d1			pop de 
5dcf e1			pop hl 
5dd0			 
5dd0				 
5dd0 2a c9 eb			ld hl, (display_write_tmp) 
5dd3 11 28 00			ld de, display_cols 
5dd6 19				add hl,de 
5dd7 22 c9 eb			ld (display_write_tmp),hl 
5dda			 
5dda				 
5dda 3e 28			ld a, kLCD_Line2 
5ddc			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5ddc 06 28			ld b, display_cols 
5dde ed 5b c9 eb		ld de, (display_write_tmp) 
5de2 cd 3c 5e			call write_len_string 
5de5				 
5de5 2a c9 eb			ld hl, (display_write_tmp) 
5de8 11 28 00			ld de, display_cols 
5deb 19				add hl,de 
5dec 22 c9 eb			ld (display_write_tmp),hl 
5def			 
5def e5			push hl 
5df0 d5			push de 
5df1 c5			push bc 
5df2 0e 07			ld c, 7 
5df4			; TODO Replace with CP/M BIOS call 
5df4				;rst $30 
5df4 0e 02			ld c, 2 
5df6 1e 0a			ld e, 10 
5df8 cd 05 00			call 5 
5dfb 0e 02			ld c, 2 
5dfd 1e 0d			ld e, 13 
5dff cd 05 00			call 5 
5e02 c1			pop bc 
5e03 d1			pop de 
5e04 e1			pop hl 
5e05			 
5e05				 
5e05 3e 50			ld a, kLCD_Line3 
5e07			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
5e07 06 28			ld b, display_cols 
5e09 ed 5b c9 eb		ld de, (display_write_tmp) 
5e0d cd 3c 5e			call write_len_string 
5e10				 
5e10 2a c9 eb			ld hl, (display_write_tmp) 
5e13 11 28 00			ld de, display_cols 
5e16 19				add hl,de 
5e17 22 c9 eb			ld (display_write_tmp),hl 
5e1a			 
5e1a e5			push hl 
5e1b d5			push de 
5e1c c5			push bc 
5e1d 0e 07			ld c, 7 
5e1f			; TODO Replace with CP/M BIOS call 
5e1f				;rst $30 
5e1f 0e 02			ld c, 2 
5e21 1e 0a			ld e, 10 
5e23 cd 05 00			call 5 
5e26 0e 02			ld c, 2 
5e28 1e 0d			ld e, 13 
5e2a cd 05 00			call 5 
5e2d c1			pop bc 
5e2e d1			pop de 
5e2f e1			pop hl 
5e30			 
5e30				 
5e30 3e 78			ld a, kLCD_Line4 
5e32			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
5e32 06 28			ld b, display_cols 
5e34 ed 5b c9 eb		ld de, (display_write_tmp) 
5e38 cd 3c 5e			call write_len_string 
5e3b c9					ret 
5e3c			 
5e3c			 
5e3c				; write out a fixed length string given in b from de 
5e3c			 
5e3c 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
5e3d cd 6d 5d		            CALL fLCD_Data      ;Write character to display 
5e40 13				inc de 
5e41 10 f9			djnz write_len_string 
5e43 c9				ret 
5e44			 
5e44			 
5e44			; eof 
# End of file firmware_cpm_display.asm
5e44			;include "firmware_key_5x10.asm" 
5e44			;;include "firmware_key_4x10.asm" 
5e44			include "firmware_key_cpm.asm" 
5e44			; Serial keyboard interface for SC114 
5e44			 
5e44			 
5e44			key_init: 
5e44				; no init as handled by the SCM bios 
5e44 c9				ret 
5e45			 
5e45			 
5e45			cin_wait: 
5e45			;	ld a, 0 
5e45			;	ret 
5e45			 
5e45				;in a,(SC114_SIO_1_IN) 
5e45			        ; Use SCM API to get from whatever console device we are using 
5e45			 
5e45			; TODO Replace with CP/M BIOS call 
5e45 c5				push bc 
5e46 0e 01			ld c, $01 
5e48 cd 05 00			call 5 
5e4b c1				pop bc 
5e4c c9				ret 
5e4d			 
5e4d			cin: 
5e4d			 
5e4d			 
5e4d c5				push bc 
5e4e			 
5e4e				; any key waiting to process? 
5e4e			; TODO Replace with CP/M BIOS call 
5e4e 0e 06			ld c, $06 
5e50 cd 05 00			call 5 
5e53 28 0d			jr z, .cin_skip 
5e55			 
5e55				; yep, get it 
5e55			 
5e55 0e 01			ld c, $01 
5e57			; TODO Replace with CP/M BIOS call 
5e57 cd 05 00			call 5 
5e5a			 
5e5a fe 7f			cp $7f     ; back space 
5e5c 20 02			jr nz, .skipbs 
5e5e 3e 08			ld a, KEY_BS 
5e60			.skipbs: 
5e60			 
5e60 c1				pop bc 
5e61 c9				ret 
5e62			.cin_skip: 
5e62 3e 00			ld a, 0 
5e64 c1				pop bc 
5e65 c9				ret 
5e66			 
5e66			 
5e66			 
5e66			 
# End of file firmware_key_cpm.asm
5e66			endofcode:  
5e66			baseram:  
5e66 00				nop 
5e67			 
5e67			heap_start: equ baseram+15  ; Starting address of heap 
5e67			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
5e67			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
5e67			;VDU:  EQU     endofcode           ; BASIC Work space 
5e67			; eof 
5e67			 
# End of file os_mega_cpm.asm
5e67
