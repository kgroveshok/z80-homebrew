# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 f8 1c			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			 
001c			include "firmware.asm" 
001c			  
001c			; main constants (used here and in firmware)  
001c			  
001c			; TODO have page 0 of storage as bios  
001c			  
001c			Device_A: equ 0h  
001c			Device_B: equ 040h          ; Sound  
001c			  
001c			if BASE_KEV  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_SC114  
001c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			; TODO fixup for CPM  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			Device_D: equ 0c0h             ; Keyboard and LCD  
001c			  
001c			; Odd specific debug points for testing hardware dev  
001c			  
001c			DEBUG_SOUND: equ 1  
001c			DEBUG_STK_FAULT: equ 0  
001c			DEBUG_INPUT: equ 0     ; Debug input entry code  
001c			DEBUG_KEYCINWAIT: equ 0  
001c			DEBUG_KEYCIN: equ 0  
001c			DEBUG_KEY: equ 0  
001c			DEBUG_KEY_MATRIX: equ 0  
001c			DEBUG_STORECF: equ 0  
001c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
001c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
001c			DEBUG_SPI: equ 0    ; low level spi tests  
001c			  
001c			; Enable many break points  
001c			  
001c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
001c			DEBUG_FORTH_JP: equ 0    ; 4  
001c			DEBUG_FORTH_MALLOC: equ 0  
001c			DEBUG_FORTH_MALLOC_INT: equ 0  
001c			DEBUG_FORTH_DOT: equ 1  
001c			DEBUG_FORTH_DOT_WAIT: equ 0  
001c			DEBUG_FORTH_MATHS: equ 0  
001c			DEBUG_FORTH_TOK: equ 0    ; 4  
001c			DEBUG_FORTH_PARSE: equ 0    ; 3  
001c			DEBUG_FORTH: equ 0  ;2  
001c			DEBUG_FORTH_WORDS: equ 1   ; 1  
001c			DEBUG_FORTH_PUSH: equ 1   ; 1  
001c			DEBUG_FORTH_UWORD: equ 1   ; 1  
001c			  
001c			; Enable key point breakpoints  
001c			  
001c			DEBUG_FORTH_DOT_KEY: equ 0  
001c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
001c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
001c			  
001c			; Debug stack imbalances  
001c			  
001c			ON: equ 1  
001c			OFF: equ 0  
001c			  
001c			DEBUG_STACK_IMB: equ 0  
001c			STACK_IMB_STORE: equ 20  
001c			  
001c			; House keeping and protections  
001c			  
001c			DEBUG_FORTH_STACK_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
001c			FORTH_ENABLE_FREE: equ 0  
001c			FORTH_ENABLE_MALLOCFREE: equ 1  
001c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
001c			FORTH_ENABLE_FLOATMATH: equ 0  
001c			  
001c			  
001c			CALLMONITOR: macro  
001c				call break_point_state  
001c				endm  
001c			  
001c			MALLOC_1: equ 1        ; from dk88   
001c			MALLOC_2: equ 0           ; broke  
001c			MALLOC_3: equ 0           ; really broke  
001c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
001c			  
001c			if BASE_KEV   
001c			stacksize: equ 256  
001c			  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 512  
001c			endif  
001c			if BASE_SC114  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			;if STORAGE_SE == 0  
001c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
001c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
001c			;endif  
001c			  
001c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
001c			  
001c			STORE_0_AUTORUN: equ $20  
001c			  
001c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
001c			  
001c			STORE_0_AUTOFILE: equ $21  
001c			STORE_0_BANKRUN: equ $23  
001c			STORE_0_FILERUN: equ $24  
001c			  
001c			; Block 0 offsets for settings  
001c			  
001c			; if set then skip prompt for start up and accept all  
001c			  
001c			STORE_0_QUICKSTART: equ $25  
001c			  
001c			; Blocks where directory table is held  
001c			  
001c			; Reducing the number of entries increases the max file size  
001c			  
001c			;STORE_DIR_START: equ 1  
001c			;STORE_DIR_END: equ 33  
001c			  
001c			; Blocks from where file data is stored  
001c			  
001c			;STORE_DATA_START: equ STORE_DIR_END + 1  
001c			  
001c			; Block indicators (<32 are data files)  
001c			  
001c			;STORE_BLOCK_CFG: equ $8f       ; config block  
001c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
001c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
001c			;STORE_BLOCK_FREE: equ $85       ; data block free  
001c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
001c			  
001c			  
001c			  
001c			; Directory entry flags  
001c			  
001c			;STORE_DIR_FREE: equ 0  
001c			;STORE_DIR_FILE:  equ 1  
001c			  
001c			; Structure offsets to directory entries  
001c			;STORE_DE_FLAG: equ 0  
001c			;STORE_DE_MAXEXT: equ 1  
001c			;STORE_DE_FILENAME: equ 2  
001c			  
001c			; Structure offsets to block 0  
001c			  
001c			;STORE_BK0_ISFOR: equ 1  
001c			;STORE_BK0_LABEL: equ 3  
001c			  
001c			; memory allocation   
001c			  
001c			chk_stund: equ tos+2           ; underflow check word  
001c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
001c			  
001c			; keyscan table needs rows x cols buffer  
001c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
001c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
001c			  
001c			keyscan_table_row1: equ chk_stovr -key_cols-1  
001c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
001c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
001c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
001c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
001c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
001c			keyscan_scancol: equ keyscan_table-key_cols  
001c			;keyscan_table_len: equ key_rows*key_cols  
001c			;keybufptr: equ keyscan_table - 2  
001c			;keysymbol: equ keybufptr - 1  
001c			key_held: equ keyscan_scancol-1	; currently held  
001c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
001c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
001c			key_fa: equ key_repeat_ct -1 ;  
001c			key_fb: equ key_fa -1 ;  
001c			key_fc: equ key_fb -1 ;  
001c			key_fd: equ key_fc -1 ;  
001c			key_face_held: equ key_fd - 1   
001c			  
001c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
001c			  
001c			hardware_config: equ key_face_held - 10  
001c			  
001c			; hardware config switches  
001c			; TODO add bitmasks on includes for hardware  
001c			; high byte for expansion ids  
001c			;     0000 0000  no card inserted  
001c			;     0000 0001  storage card inserted  
001c			;     0000 0010  spi sd card active  
001c			  
001c			;       
001c			; low byte:  
001c			;     0000 0001   4x4 keypad  
001c			;     0000 0010   full keyboard  
001c			;     0000 0011   spi/ext keyboard  
001c			;     0000 0100   20x4 lcd  
001c			;     0000 1000   40x4 lcd  
001c			;     0000 1100   spi/ext display  
001c			;     0001 0000   ide interface available  
001c			  
001c			hardware_word: equ hardware_config - 2  
001c			  
001c			; debug marker - optional display of debug point on the debug screens  
001c			  
001c			debug_mark: equ hardware_word - 4  
001c			  
001c			; input_str vars  
001c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
001c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
001c			input_size: equ input_start -1  ; number of chars  
001c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
001c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
001c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
001c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
001c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
001c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
001c			input_len: equ input_cur_onoff - 5 ; length of current input  
001c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
001c			  
001c			CUR_BLINK_RATE: equ 15  
001c			  
001c			key_actual_pressed: equ input_cursor - 1   
001c			key_symbol: equ key_actual_pressed - 1   
001c			key_shift: equ key_symbol - 1   
001c			  
001c			; Display allocation  
001c			  
001c			;display_rows: equ 4     ; move out to mini and mega files  
001c			;display_cols: equ 20  
001c			  
001c			display_fb_len: equ display_rows*display_cols  
001c			  
001c			; primary frame buffer     
001c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
001c			; working frame buffers  
001c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
001c			display_fb3: equ  display_fb1-display_fb_len - 1  
001c			display_fb2: equ  display_fb3-display_fb_len - 1  
001c			;  
001c			; pointer to active frame buffer  
001c			display_fb_active: equ display_fb2 - 2  
001c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
001c			display_write_tmp: equ display_lcde1e2 - 2  
001c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
001c			  
001c			;  
001c			  
001c			;; can load into de directory  
001c			cursor_col: equ display_active-1  
001c			cursor_row: equ cursor_col-1  
001c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
001c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
001c			  
001c			; maths vars  
001c			  
001c			LFSRSeed: equ cursor_shape -20   
001c			randData: equ LFSRSeed - 2  
001c			xrandc: equ randData - 2  
001c			stackstore: equ xrandc - 2  
001c			seed1: equ  stackstore -2   
001c			seed2: equ seed1 - 2  
001c			  
001c			; cf storage vars  
001c			  
001c			iErrorNum:  equ seed2-1         ;Error number  
001c			iErrorReg:  equ iErrorNum -1              ;Error register  
001c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
001c			  
001c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
001c			  
001c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
001c			  
001c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
001c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
001c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
001c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
001c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
001c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
001c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
001c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
001c			store_tmpid: equ store_tmp3 - 1		; page temp id  
001c			store_tmpext: equ store_tmpid - 1		; file extent temp  
001c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
001c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
001c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
001c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
001c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
001c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
001c			;  
001c			; spi vars  
001c			  
001c			  
001c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
001c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
001c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
001c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
001c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
001c			spi_device_id: equ spi_device - 1    ; human readable bank number  
001c			  
001c			;;;;; forth cli params  
001c			  
001c			; TODO use a different frame buffer for forth???  
001c			  
001c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
001c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
001c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
001c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
001c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
001c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
001c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
001c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
001c			  
001c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
001c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
001c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
001c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
001c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
001c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
001c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
001c			  
001c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
001c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
001c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
001c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
001c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
001c			  
001c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
001c			  
001c			; os/forth token vars  
001c			  
001c			os_last_cmd: equ os_var_array-255  
001c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
001c			os_current_i: equ os_cli_cmd-2  
001c			os_cur_ptr: equ os_current_i-2  
001c			os_word_scratch: equ os_cur_ptr-30  
001c			os_tok_len: equ os_word_scratch - 2  
001c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
001c			os_tok_malloc: equ os_tok_ptr - 2  
001c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
001c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
001c			execscratch: equ os_input-255        ; exec cmd eval buffer  
001c			scratch: equ execscratch-255  
001c			  
001c			  
001c			; temp locations for new word processing to save on adding more   
001c			  
001c			os_new_malloc: equ scratch-2  
001c			os_new_parse_len: equ os_new_malloc - 2  
001c			os_new_word_len: equ os_new_parse_len - 2  
001c			os_new_work_ptr: equ os_new_word_len - 2  
001c			os_new_src_ptr: equ os_new_work_ptr - 2  
001c			os_new_exec: equ os_new_src_ptr - 2  
001c			os_new_exec_ptr: equ os_new_exec - 2  
001c			  
001c			; resume memory alloocations....  
001c			  
001c			os_view_disable: equ os_new_exec_ptr - 1  
001c			os_view_af: equ os_view_disable - 2  
001c			os_view_hl: equ os_view_af -2  
001c			os_view_de: equ os_view_hl - 2  
001c			os_view_bc: equ os_view_de - 2  
001c			  
001c			; stack checksum word  
001c			if DEBUG_STACK_IMB  
001c				curframe: equ  os_view_de - 5  
001c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
001c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			else  
001c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			endif  
001c			  
001c			; with data stack could see memory filled with junk. need some memory management   
001c			; malloc and free entry points added  
001c			  
001c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
001c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			;heap_end: equ free_list-1  ; Starting address of heap  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			heap_end: equ chk_word-1  ; Starting address of heap  
001c			  
001c			  
001c			;if BASE_KEV   
001c			;heap_start: equ 0800eh  ; Starting address of heap  
001c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;heap_start: equ baseram+15  ; Starting address of heap  
001c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;endif  
001c			  
001c			  
001c			;;;;  
001c			  
001c			  
001c			; change below to point to last memory alloc above  
001c			topusermem:  equ   heap_start  
001c			  
001c			;if BASE_KEV   
001c			;baseusermem: equ 08000h  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;;aseusermem:     equ    12  
001c			;baseusermem:     equ    prompt  
001c			;;baseusermem:     equ    endofcode  
001c			;endif  
001c			  
001c			  
001c			; **********************************************************************  
001c			; **  Constants  
001c			; **********************************************************************  
001c			  
001c			; Constants used by this code module  
001c			kDataReg:   EQU Device_D           ;PIO port A data register  
001c			kContReg:   EQU Device_D+2           ;PIO port A control register  
001c			  
001c			  
001c			portbdata:  equ Device_D+1    ; port b data  
001c			portbctl:   equ Device_D+3    ; port b control  
001c			  
001c			  
001c			;KEY_SHIFT:   equ 5  
001c			;KEY_SYMBOLSHIFT:  equ 6  
001c			  
001c			KEY_SHIFTLOCK: equ 4  
001c			  
001c			  
001c			KEY_UP: equ 5  
001c			KEY_NEXTWORD: equ 6  
001c			KEY_PREVWORD: equ 7  
001c			KEY_BS: equ 8  
001c			KEY_TAB:  equ 9  
001c			KEY_DOWN: equ 10  
001c			KEY_LEFT: equ 11  
001c			KEY_RIGHT: equ 12  
001c			KEY_CR:   equ 13  
001c			KEY_HOME: equ 14  
001c			KEY_END: equ 15  
001c			  
001c			KEY_F1: equ 16  
001c			KEY_F2: equ 17  
001c			KEY_F3: equ 18  
001c			KEY_F4: equ 19  
001c			  
001c			KEY_F5: equ 20  
001c			KEY_F6: equ 21  
001c			KEY_F7: equ 22  
001c			KEY_F8: equ 23  
001c			  
001c			KEY_F9: equ 24  
001c			KEY_F10: equ 25  
001c			KEY_F11: equ 26  
001c			KEY_F12: equ 27  
001c			  
001c			;if DEBUG_KEY  
001c			;	KEY_MATRIX_NO_PRESS: equ '.'  
001c			;	KEY_SHIFT:   equ '.'  
001c			;	KEY_SYMBOLSHIFT:  equ '.'  
001c			;else  
001c				KEY_SHIFT:   equ '~'  
001c				KEY_SYMBOLSHIFT:  equ '~'  
001c				KEY_MATRIX_NO_PRESS: equ '~'  
001c			;endi  
001c			  
001c			  
001c			  
001c			  
001c			; Macro to make adding debug marks easier  
001c			  
001c			DMARK: macro str  
001c				push af  
001c				ld a, (.dmark)  
001c				ld (debug_mark),a  
001c				ld a, (.dmark+1)  
001c				ld (debug_mark+1),a  
001c				ld a, (.dmark+2)  
001c				ld (debug_mark+2),a  
001c				jr .pastdmark  
001c			.dmark: db str  
001c			.pastdmark: pop af  
001c			  
001c			endm  
001c			  
001c			  
001c			; macro to detect for stack imbalances  
001c			  
001c			include "stackimbal.asm"  
001c			; Macro and code to detect stock imbalances 
001c			 
001c			SPPUSH: equ 0 
001c			 
001c			; Add a stack frame which can be checked before return 
001c			 
001c			STACKFRAME: macro onoff frame1 frame2 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c						exx 
001c			 
001c						ld de, frame1 
001c						ld a, d 
001c						ld hl, curframe 
001c						call hexout 
001c						ld a, e 
001c						ld hl, curframe+2 
001c						call hexout 
001c			  
001c						ld hl, frame1 
001c						push hl 
001c						ld hl, frame2 
001c						push hl 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			endm 
001c			 
001c			STACKFRAMECHK: macro onoff frame1 frame2 
001c			 
001c					 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						exx 
001c						; check stack frame SP 
001c			 
001c						ld hl, frame2 
001c						pop de   ; frame2 
001c			 
001c						call cmp16 
001c						jr nz, .spnosame 
001c						 
001c			 
001c						ld hl, frame1 
001c						pop de   ; frame1 
001c			 
001c						call cmp16 
001c						jr z, .spfrsame 
001c			 
001c						.spnosame: call showsperror 
001c			 
001c						.spfrsame: nop 
001c			 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			 
001c			 
001c			endm 
001c			 
001c			 
001c			; for a sub routine, wrap SP collection and comparisons 
001c			 
001c			; Usage: 
001c			; 
001c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
001c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
001c			 
001c			SAVESP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c			 
001c						ld (store_sp+(storeword*4)), sp 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			CHECKSP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c			 
001c						; save SP after last save 
001c				 
001c						ld (store_sp+(storeword*4)+2), sp 
001c			 
001c						push hl 
001c						ld hl, store_sp+(storeword*4) 
001c						call check_stack_sp  
001c						pop hl 
001c			 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			if DEBUG_STACK_IMB 
001c			 
001c			check_stack_sp: 
001c					push de 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					push de 
001c			 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					pop hl 
001c			 
001c			 
001c					; check to see if the same 
001c			 
001c					call cmp16 
001c					jr z, .spsame 
001c			 
001c					; not same 
001c			 
001c					call showsperror 
001c			.spsame: 
001c			 
001c					pop de 
001c			 
001c					ret 
001c			 
001c			.sperr:  db "Stack imbalance",0 
001c			 
001c			 
001c			showsperror: 
001c			 
001c			 
001c				push hl 
001c				push af 
001c				push de 
001c				call clear_display 
001c				ld de, .sperr 
001c				ld a,0 
001c			;	ld de,os_word_scratch 
001c				call str_at_display 
001c				ld a, display_row_1+17 
001c				ld de, debug_mark 
001c				call str_at_display 
001c				ld a, 0 
001c				ld (curframe+4),a 
001c				ld hl, curframe 
001c				ld de, os_word_scratch 
001c				ld a, display_row_4 
001c				call str_at_display 
001c				call update_display 
001c				;call break_point_state 
001c				call cin_wait 
001c			 
001c				ld a, ' ' 
001c				ld (os_view_disable), a 
001c				pop de	 
001c				pop af 
001c				pop hl 
001c				CALLMONITOR 
001c				ret 
001c			 
001c			endif 
001c			 
001c			 
001c			 
001c			; eof 
# End of file stackimbal.asm
001c			  
001c			;TODO macro to calc col and row offset into screen  
001c			  
001c			  
001c			  
001c			hardware_init:  
001c			  
001c				  
001c			  
001c					;ld a, 0  
001c					;ld (hardware_diag), a  
001c			  
001c					; clear all the buffers  
001c			  
001c 21 13 fd				ld hl, display_fb1  
001f 22 cf fb				ld (display_fb_active), hl  
0022			  
0022 cd 52 0d				call clear_display  
0025			  
0025 21 d1 fb				ld hl, display_fb2  
0028 22 cf fb				ld (display_fb_active), hl  
002b			  
002b cd 52 0d				call clear_display  
002e			  
002e					; init primary frame buffer area  
002e 21 b4 fd				ld hl, display_fb0  
0031 22 cf fb				ld (display_fb_active), hl  
0034			  
0034 cd 52 0d				call clear_display  
0037			  
0037			  
0037 cd 5b 75				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
003a			  
003a cd f2 77			call key_init  
003d cd fe 01			call storage_init  
0040			  
0040				; setup malloc functions  
0040			  
0040				if MALLOC_1  
0040 cd 29 14				call  heap_init  
0043				endif  
0043				if MALLOC_4  
0043					call  heap_init  
0043				endif  
0043			  
0043				; init sound hardware if present  
0043			  
0043				if SOUND_ENABLE  
0043 cd e6 15				call sound_init  
0046				endif  
0046			  
0046				; lcd test sequence  
0046					  
0046 cd 75 0d			call update_display  
0049 cd 95 0c			call delay1s  
004c 3e 2b			ld a,'+'  
004e cd 57 0d			call fill_display  
0051 cd 75 0d			call update_display  
0054 cd 95 0c			call delay1s  
0057 3e 2a			ld a,'*'  
0059 cd 57 0d			call fill_display  
005c cd 75 0d			call update_display  
005f cd 95 0c			call delay1s  
0062 3e 2d			ld a,'-'  
0064 cd 57 0d			call fill_display  
0067 cd 75 0d			call update_display  
006a cd 95 0c			call delay1s  
006d			  
006d			; boot splash screen  
006d			if display_cols == 20	  
006d			        ld a, display_row_1    
006d			else  
006d 3e 0a		        ld a, display_row_1 +10   
006f			endif  
006f 11 d1 1b			ld de, prom_bootmsg  
0072 cd 65 0d			call str_at_display  
0075 cd 75 0d			call update_display  
0078			  
0078			  
0078 cd 95 0c			call delay1s  
007b cd 95 0c			call delay1s  
007e			if display_cols == 20	  
007e			            LD   A, display_row_3+2  
007e			else  
007e 3e 5c		            LD   A, display_row_3+12  
0080			endif  
0080 11 e6 1b			ld de, prom_bootmsg1  
0083 cd 65 0d			call str_at_display  
0086 cd 75 0d			call update_display  
0089 cd 95 0c			call delay1s  
008c cd 95 0c			call delay1s  
008f			  
008f			;	ld a, display_row_4+3  
008f			;	ld de, bootmsg2  
008f			;	call str_at_display  
008f			;	call update_display  
008f			;	call delay1s  
008f			;	call delay1s  
008f			  
008f			; debug mark setup  
008f			  
008f 3e 5f		ld a, '_'  
0091 32 6e fe		ld (debug_mark),a  
0094 32 6f fe		ld (debug_mark+1),a  
0097 32 70 fe		ld (debug_mark+2),a  
009a 3e 00		ld a,0  
009c 32 71 fe		ld (debug_mark+3),a  
009f			  
009f c9					ret  
00a0			  
00a0			  
00a0			;bootmsg2:	db "Firmware v0.1",0  
00a0			  
00a0			; a 4x20 lcd  
00a0			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00a0			  
00a0			;if display_cols == 20  
00a0			;	include "firmware_lcd_4x20.asm"  
00a0			;endif  
00a0			  
00a0			;if display_cols == 40  
00a0			;	include "firmware_lcd_4x40.asm"  
00a0			;endif  
00a0			  
00a0			;  
00a0			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00a0			; TODO abstract the bit bang video out interface for dual display  
00a0			; TODO wire video out to tx pin on rc2014 bus  
00a0			  
00a0			; must supply cin, and cin_wait for low level hardware abstraction   
00a0			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00a0			; test scancode  
00a0			  
00a0			;;;;;  
00a0			;;;  
00a0			; Moved out to mini and maxi versions  
00a0			;  
00a0			; include "firmware_key_4x4.asm"  
00a0			; using existing 4 wire x 4 resistor array for input  
00a0			;include "firmware_key_4x10.asm"  
00a0			; need to mod the board for 5 rows due to resistor array  
00a0			;include "firmware_key_5x10.asm"  
00a0			  
00a0			; storage hardware interface  
00a0			  
00a0			; use microchip serial eeprom for storage  
00a0			  
00a0			  
00a0			if STORAGE_SE  
00a0				include "firmware_spi.asm"  
00a0			; my spi protocol (used by storage) 
00a0			 
00a0			; SPI pins 
00a0			 
00a0			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00a0			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00a0			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00a0			 
00a0			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00a0			; chip pin 4 gnd 
00a0			 
00a0			 
00a0			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00a0			SPI_CE1: equ 1      ;    port a1 pin 14  
00a0			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00a0			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00a0			SPI_CE4: equ 4      ; port a4     pin 10 
00a0			 
00a0			; active low AND masks 
00a0			 
00a0			;SPI_CE0_MASK: equ    255-1 
00a0			;SPI_CE1_MASK: equ   255-2 
00a0			;SPI_CE2_MASK: equ   255-4 
00a0			;SPI_CE3_MASK: equ   255-8 
00a0			;SPI_CE4_MASK: equ   255-16 
00a0			SPI_CE_HIGH:  equ 255 
00a0			 
00a0			 
00a0			 
00a0			;  Perform SCLK wait pulse 
00a0			 
00a0			spi_clk: 
00a0 f5				push af 
00a1 3a 67 fa			ld a, (spi_clktime) 
00a4 fe 00			cp 0 
00a6 28 03			jr z, .scskip 
00a8 cd 7a 0c			call aDelayInMS 
00ab			.scskip: 
00ab f1				pop af 
00ac c9				ret 
00ad			 
00ad			 
00ad			 
00ad			; TODO store port id for spi device ie dev c 
00ad			; TODO store pin for SO 
00ad			; TODO store pin for SI 
00ad			; TODO store pin for SCLK 
00ad			 
00ad			; 
00ad			 
00ad			; ensure that spi bus is in a stable state with default pins  
00ad			 
00ad			se_stable_spi:   
00ad			 
00ad				 ; set DI high, CE high , SCLK low 
00ad				;ld a, SPI_DI | SPI_CE0 
00ad 3e 07			ld a, SPI_DI  
00af cd b9 01			call spi_ce_high 
00b2 d3 80			 out (storage_adata),a 
00b4 32 64 fa			ld (spi_portbyte),a 
00b7			 
00b7				if DEBUG_SPI 
00b7					push hl 
00b7					ld l, a 
00b7					DMARK "SPI" 
00b7					CALLMONITOR 
00b7					pop hl 
00b7				endif 
00b7 c9				ret 
00b8			 
00b8			; byte to send in a 
00b8			 
00b8			spi_send_byte: 
00b8				; save byte to send for bit mask shift out 
00b8 4f			        ld c,a 
00b9 3a 64 fa			ld a,(spi_portbyte) 
00bc				  
00bc				; clock out	each bit of the byte msb first 
00bc			 
00bc 06 08			ld b, 8 
00be			.ssb1: 
00be				; clear so bit  
00be cb bf			res SPI_DI, a 
00c0 cb 11			rl c 
00c2				; if bit 7 is set then carry is set 
00c2 30 02			jr nc, .ssb2 
00c4 cb ff			set SPI_DI,a 
00c6			.ssb2:  ; output bit to ensure it is stable 
00c6 d3 80			out (storage_adata),a 
00c8 00				nop 
00c9				; clock bit high 
00c9 cb ef			set SPI_SCLK,a 
00cb d3 80			out (storage_adata),a 
00cd 00				nop 
00ce cd a0 00			call spi_clk 
00d1				; then low 
00d1 cb af			res SPI_SCLK,a 
00d3 d3 80			out (storage_adata),a 
00d5 00				nop 
00d6 cd a0 00			call spi_clk 
00d9 10 e3			djnz .ssb1 
00db			 
00db 32 64 fa			ld (spi_portbyte),a 
00de c9				ret 
00df			 
00df			; TODO low level get byte into A on spi 
00df			 
00df			spi_read_byte:  
00df			 
00df				; save byte to send for bit mask shift out 
00df 0e 00		    ld c,0 
00e1 3a 64 fa			ld a,(spi_portbyte) 
00e4				  
00e4				; clock out	each bit of the byte msb first 
00e4			 
00e4			 
00e4				; clock bit high 
00e4 cb ef			set SPI_SCLK,a 
00e6 d3 80			out (storage_adata),a 
00e8 00				nop 
00e9 cd a0 00			call spi_clk 
00ec			 
00ec			    ; read DO  
00ec			 
00ec cb f9		    set 7,c 
00ee db 80			in a,(storage_adata) 
00f0 cb 77		    bit SPI_DO,a 
00f2 20 02		    jr nz, .b7 
00f4 cb b9		    res 7,c 
00f6			.b7: 
00f6				; then low 
00f6 cb af			res SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb cd a0 00			call spi_clk 
00fe			     
00fe			 
00fe				; clock bit high 
00fe cb ef			set SPI_SCLK,a 
0100 d3 80			out (storage_adata),a 
0102 00				nop 
0103 cd a0 00			call spi_clk 
0106			 
0106			    ; read DO  
0106			 
0106 cb f1		    set 6,c 
0108 db 80			in a,(storage_adata) 
010a cb 77		    bit SPI_DO,a 
010c 20 02		    jr nz, .b6 
010e cb b1		    res 6,c 
0110			.b6: 
0110				; then low 
0110 cb af			res SPI_SCLK,a 
0112 d3 80			out (storage_adata),a 
0114 00				nop 
0115 cd a0 00			call spi_clk 
0118			 
0118				; clock bit high 
0118 cb ef			set SPI_SCLK,a 
011a d3 80			out (storage_adata),a 
011c 00				nop 
011d cd a0 00			call spi_clk 
0120			 
0120			 
0120			    ; read DO  
0120			 
0120 cb e9		    set 5,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b5 
0128 cb a9		    res 5,c 
012a			.b5: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f cd a0 00			call spi_clk 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137 cd a0 00			call spi_clk 
013a			 
013a			    ; read DO  
013a			 
013a cb e1		    set 4,c 
013c db 80			in a,(storage_adata) 
013e cb 77		    bit SPI_DO,a 
0140 20 02		    jr nz, .b4 
0142 cb a1		    res 4,c 
0144			.b4: 
0144				; then low 
0144 cb af			res SPI_SCLK,a 
0146 d3 80			out (storage_adata),a 
0148 00				nop 
0149 cd a0 00			call spi_clk 
014c				; clock bit high 
014c cb ef			set SPI_SCLK,a 
014e d3 80			out (storage_adata),a 
0150 00				nop 
0151 cd a0 00			call spi_clk 
0154			 
0154			    ; read DO  
0154			 
0154 cb d9		    set 3,c 
0156 db 80			in a,(storage_adata) 
0158 cb 77		    bit SPI_DO,a 
015a 20 02		    jr nz, .b3 
015c cb 99		    res 3,c 
015e			.b3: 
015e				; then low 
015e cb af			res SPI_SCLK,a 
0160 d3 80			out (storage_adata),a 
0162 00				nop 
0163 cd a0 00			call spi_clk 
0166				; clock bit high 
0166 cb ef			set SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b cd a0 00			call spi_clk 
016e			 
016e			    ; read DO  
016e			 
016e cb d1		    set 2,c 
0170 db 80			in a,(storage_adata) 
0172 cb 77		    bit SPI_DO,a 
0174 20 02		    jr nz, .b2 
0176 cb 91		    res 2,c 
0178			.b2: 
0178				; then low 
0178 cb af			res SPI_SCLK,a 
017a d3 80			out (storage_adata),a 
017c 00				nop 
017d cd a0 00			call spi_clk 
0180				; clock bit high 
0180 cb ef			set SPI_SCLK,a 
0182 d3 80			out (storage_adata),a 
0184 00				nop 
0185 cd a0 00			call spi_clk 
0188			 
0188			    ; read DO  
0188			 
0188 cb c9		    set 1,c 
018a db 80			in a,(storage_adata) 
018c cb 77		    bit SPI_DO,a 
018e 20 02		    jr nz, .b1 
0190 cb 89		    res 1,c 
0192			.b1: 
0192				; then low 
0192 cb af			res SPI_SCLK,a 
0194 d3 80			out (storage_adata),a 
0196 00				nop 
0197 cd a0 00			call spi_clk 
019a				; clock bit high 
019a cb ef			set SPI_SCLK,a 
019c d3 80			out (storage_adata),a 
019e 00				nop 
019f cd a0 00			call spi_clk 
01a2			 
01a2			    ; read DO  
01a2			 
01a2 cb c1		    set 0,c 
01a4 db 80			in a,(storage_adata) 
01a6 cb 77		    bit SPI_DO,a 
01a8 20 02		    jr nz, .b0 
01aa cb 81		    res 0,c 
01ac			.b0: 
01ac				; then low 
01ac cb af			res SPI_SCLK,a 
01ae d3 80			out (storage_adata),a 
01b0 00				nop 
01b1 cd a0 00			call spi_clk 
01b4			 
01b4			 
01b4 32 64 fa			ld (spi_portbyte),a 
01b7			 
01b7			    ; return byte 
01b7 79			    ld a,c 
01b8			 
01b8			 
01b8 c9				ret 
01b9			 
01b9			 
01b9			 
01b9			spi_ce_high: 
01b9			 
01b9				if DEBUG_SPI_HARD_CE0 
01b9			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01b9					ret 
01b9			 
01b9				endif 
01b9			 
01b9			 
01b9 f5				push af 
01ba			 
01ba				; send direct ce to port b 
01ba 3e ff			ld a, 255 
01bc d3 81			out (storage_bdata), a 
01be			 
01be f1				pop af 
01bf			 
01bf				; for port a that shares with spi lines AND the mask 
01bf			  
01bf				if DEBUG_SPI 
01bf					push hl 
01bf					ld h, a 
01bf				endif 
01bf			;	ld c, SPI_CE_HIGH 
01bf			;	and c 
01bf cb c7			set SPI_CE0, a 
01c1 cb cf			set SPI_CE1, a 
01c3 cb d7			set SPI_CE2, a 
01c5 cb df			set SPI_CE3, a 
01c7 cb e7			set SPI_CE4, a 
01c9			 
01c9				if DEBUG_SPI 
01c9					ld l, a 
01c9					DMARK "CEh" 
01c9					CALLMONITOR 
01c9					pop hl 
01c9				endif 
01c9 c9				ret 
01ca			 
01ca			 
01ca			spi_ce_low: 
01ca			 
01ca				if DEBUG_SPI_HARD_CE0 
01ca			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ca					ret 
01ca			 
01ca				endif 
01ca			 
01ca c5				push bc 
01cb f5				push af 
01cc			 
01cc				; send direct ce to port b 
01cc 3a 66 fa			ld a, (spi_cartdev) 
01cf d3 81			out (storage_bdata), a 
01d1			 
01d1			 
01d1			 
01d1				; for port a that shares with spi lines AND the mask 
01d1			 
01d1 3a 63 fa			ld a, (spi_device)  
01d4 4f				ld c, a 
01d5			 
01d5 f1				pop af 
01d6			 
01d6				; detect CEx 
01d6			 
01d6				if DEBUG_SPI 
01d6					push hl 
01d6					ld h, a 
01d6				endif 
01d6			 
01d6 cb 41			bit SPI_CE0, c 
01d8 20 04			jr nz, .cel1 
01da cb 87			res SPI_CE0, a 
01dc 18 1e			jr .celn 
01de			.cel1: 
01de cb 49			bit SPI_CE1, c 
01e0 20 04			jr nz, .cel2 
01e2 cb 8f			res SPI_CE1, a 
01e4 18 16			jr .celn 
01e6			.cel2: 
01e6 cb 51			bit SPI_CE2, c 
01e8 20 04			jr nz, .cel3 
01ea cb 97			res SPI_CE2, a 
01ec 18 0e			jr .celn 
01ee			.cel3: 
01ee cb 59			bit SPI_CE3, c 
01f0 20 04			jr nz, .cel4 
01f2 cb 9f			res SPI_CE3, a 
01f4 18 06			jr .celn 
01f6			.cel4: 
01f6 cb 61			bit SPI_CE4, c 
01f8 20 02			jr nz, .celn 
01fa cb a7			res SPI_CE4, a 
01fc			.celn: 
01fc			 
01fc			 
01fc			 
01fc			;	add c 
01fc			 
01fc				if DEBUG_SPI 
01fc					ld l, a 
01fc					DMARK "CEl" 
01fc					CALLMONITOR 
01fc					pop hl 
01fc				endif 
01fc c1				pop bc 
01fd c9				ret 
01fe			 
01fe			 
01fe			 
01fe			; eof 
01fe			 
01fe			 
01fe			 
01fe			 
01fe			 
# End of file firmware_spi.asm
01fe				include "firmware_seeprom.asm"  
01fe			; 
01fe			; persisent storage interface via microchip serial eeprom 
01fe			 
01fe			; port a pio 2 
01fe			; pa 7 - si 
01fe			; pa 6 - sclk  
01fe			; pa 5 - so 
01fe			; pa 4 - cs 
01fe			; pa 3 - cs 
01fe			; pa 2 - cs 
01fe			; pa 1 - cs 
01fe			; pa 0 - cs 
01fe			; 
01fe			; TODO get block 
01fe			; TODO save block 
01fe			; TODO load file 
01fe			; TODO save file 
01fe			; TODO get dir  
01fe			 
01fe			;  
01fe			storage_adata: equ Device_C    ; device c port a - onboard storage 
01fe			storage_actl: equ Device_C+2     ; device c port a 
01fe			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01fe			storage_bctl: equ Device_C+3     ; device c port b 
01fe			 
01fe			 
01fe			; TODO move these to hardware driver file 
01fe			 
01fe			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01fe			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01fe			; storage bank file system format 
01fe			; 
01fe			; first page of bank: 
01fe			; 	addr 0 - status check 
01fe			;       addr 1 - write protect flag 
01fe			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01fe			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01fe			;         TODO see if scanning whole of for available next file id is fast enough 
01fe			;	addr 4 > zero term string of bank label 
01fe			; 
01fe			;        
01fe			;  
01fe			; first page of any file: 
01fe			;      byte 0 - file id  
01fe			;      byte 1-17 - fixed file name  
01fe			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01fe			; 
01fe			; other pages of any file: 
01fe			;      byte 0 - file id 
01fe			;      byte 1> - file data 
01fe			; 
01fe			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01fe			;  
01fe			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01fe			 
01fe			 
01fe			;storage_so_bit: 5 
01fe			;storage_si_bit: 7 
01fe			;storage_sclk_bit: 6 
01fe			  
01fe			 
01fe			; init storage pio 
01fe			 
01fe			storage_init: 
01fe			 
01fe			 
01fe					; set default SPI clk pulse time as disabled 
01fe			 
01fe 3e 00				ld a, 0 
0200 32 67 fa				ld (spi_clktime), a 
0203			 
0203					; init hardware 
0203			 
0203 3e cf		            LD   A, 11001111b 
0205 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0207 3e 00		            LD   A, 00000000b 
0209 cb f7			set SPI_DO,a 
020b			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
020b d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
020d			 
020d 3e cf		            LD   A, 11001111b 
020f d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
0211 3e 00		            LD   A, 00000000b 
0213 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
0215			 
0215				; set all external spi devices off  
0215 3e ff			ld a, 255 
0217 32 63 fa			ld (spi_device), a 
021a 32 66 fa			ld (spi_cartdev), a 
021d			 
021d					; ensure the spi bus is in a default stable state 
021d cd ad 00				call se_stable_spi 
0220			 
0220			; TODO scan spi bus and gather which storage banks are present 
0220			 
0220			; populate store_bank_active  
0220			; for each ce line activate and attempt to write first byte of bank and read back 
0220			; if zero is returned then bank is empty 
0220			;   
0220			; 
0220			 
0220					; init file extent cache to save on slow reads 
0220			 
0220			;	ld hl, store_filecache 
0220			;	ld de, 0 
0220			;	ld hl,(de)	 
0220			 
0220			 
0220 c9			    ret 
0221			 
0221			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
0221			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
0221			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
0221			 
0221			; INSTRUCTION SET 
0221			; READ 0000 0011 Read data from memory array beginning at selected address 
0221			; WRITE 0000 0010 Write data to memory array beginning at selected address 
0221			; WREN 0000 0110 Set the write enable latch (enable write operations) 
0221			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
0221			; RDSR 0000 0101 Read STATUS register 
0221			; WRSR 0000 0001 Write STATUS register 
0221			; PE 0100 0010 Page Erase – erase one page in memory array 
0221			; SE 1101 1000 Sector Erase – erase one sector in memory array 
0221			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
0221			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
0221			 
0221			; TODO send byte steam for page without setting the address for every single byte 
0221			; TODO read byte  
0221			 
0221			; byte in a 
0221			; address in hl  
0221			se_writebyte: 
0221			        
0221			    ;   ld c, a 
0221 f5			        push af 
0222 e5			        push hl 
0223			 
0223			    ; initi write mode 
0223			    ; 
0223			    ;CS low 
0223			 
0223 3a 64 fa		       ld a,(spi_portbyte) 
0226 cd ca 01			call spi_ce_low 
0229			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0229 d3 80		       out (storage_adata),a 
022b 32 64 fa		       ld (spi_portbyte), a 
022e			 
022e			    ;clock out wren instruction 
022e			 
022e 3e 06		    ld a, store_wren_ins 
0230 cd b8 00		    call spi_send_byte  
0233			 
0233			    ;cs high to enable write latch 
0233			 
0233 3a 64 fa		       ld a,(spi_portbyte) 
0236 cd b9 01			call spi_ce_high 
0239			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0239 d3 80		       out (storage_adata),a 
023b 32 64 fa		       ld (spi_portbyte), a 
023e			 
023e 00				nop 
023f			    ; 
023f			    ; intial write data 
023f			    ; 
023f			    ; cs low 
023f			     
023f 3a 64 fa		       ld a,(spi_portbyte) 
0242 cd ca 01			call spi_ce_low 
0245			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0245 d3 80		       out (storage_adata),a 
0247 32 64 fa		       ld (spi_portbyte), a 
024a			 
024a			    ; clock out write instruction 
024a			     
024a 3e 02		    ld a, store_write_ins  
024c cd b8 00		    call spi_send_byte  
024f			 
024f			    ; clock out address (depending on address size) 
024f			     
024f e1			    pop hl 
0250 7c			    ld a,h    ; address out msb first 
0251 cd b8 00		    call spi_send_byte  
0254 7d			    ld a,l 
0255 cd b8 00		    call spi_send_byte  
0258			 
0258			    ; clock out byte(s) for page 
0258			 
0258 f1			    pop af 
0259 cd b8 00		    call spi_send_byte  
025c			 
025c			    ; end write with ce high 
025c 3a 64 fa		       ld a,(spi_portbyte) 
025f			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
025f cd b9 01			call spi_ce_high 
0262 d3 80		       out (storage_adata),a 
0264 32 64 fa		       ld (spi_portbyte), a 
0267			 
0267				; pause for internal write cycle 
0267 3e 0a			ld a, 10 
0269 cd 7a 0c			call aDelayInMS 
026c c9			    ret 
026d			 
026d			; buffer to write in de 
026d			; address in hl  
026d			se_writepage: 
026d			        
026d			    ;   ld c, a 
026d d5				push de 
026e e5			        push hl 
026f			 
026f			    ; initi write mode 
026f			    ; 
026f			    ;CS low 
026f			 
026f 3a 64 fa		       ld a,(spi_portbyte) 
0272 cd ca 01			call spi_ce_low 
0275			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0275 d3 80		       out (storage_adata),a 
0277 32 64 fa		       ld (spi_portbyte), a 
027a			 
027a			    ;clock out wren instruction 
027a			 
027a 3e 06		    ld a, store_wren_ins 
027c cd b8 00		    call spi_send_byte  
027f			 
027f			    ;cs high to enable write latch 
027f			 
027f 3a 64 fa		       ld a,(spi_portbyte) 
0282 cd b9 01			call spi_ce_high 
0285			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0285 d3 80		       out (storage_adata),a 
0287 32 64 fa		       ld (spi_portbyte), a 
028a			 
028a 00				nop 
028b			    ; 
028b			    ; intial write data 
028b			    ; 
028b			    ; cs low 
028b			     
028b 3a 64 fa		       ld a,(spi_portbyte) 
028e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028e cd ca 01			call spi_ce_low 
0291 d3 80		       out (storage_adata),a 
0293 32 64 fa		       ld (spi_portbyte), a 
0296			 
0296			    ; clock out write instruction 
0296			     
0296 3e 02		    ld a, store_write_ins  
0298 cd b8 00		    call spi_send_byte  
029b			 
029b			    ; clock out address (depending on address size) 
029b			     
029b e1			    pop hl 
029c 7c			    ld a,h    ; address out msb first 
029d cd b8 00		    call spi_send_byte  
02a0 7d			    ld a,l 
02a1 cd b8 00		    call spi_send_byte  
02a4			 
02a4			    ; clock out byte(s) for page 
02a4			 
02a4 e1				pop hl 
02a5 06 40			ld b, STORE_BLOCK_PHY 
02a7			.bytewrite: 
02a7			 
02a7 7e				ld a,(hl) 
02a8 e5			    push hl 
02a9 c5				push bc 
02aa cd b8 00		    call spi_send_byte  
02ad c1				pop bc 
02ae e1				pop hl 
02af			 
02af			    ; end write with ce high 
02af 3a 64 fa		       ld a,(spi_portbyte) 
02b2 cd b9 01			call spi_ce_high 
02b5			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02b5 d3 80		       out (storage_adata),a 
02b7 32 64 fa		       ld (spi_portbyte), a 
02ba			 
02ba 23				inc hl 
02bb 10 ea			djnz .bytewrite 
02bd			 
02bd				; pause for internal write cycle 
02bd 3e 64			ld a, 100 
02bf cd 7a 0c			call aDelayInMS 
02c2 c9			    ret 
02c3			; returns byte in a 
02c3			; address in hl  
02c3			se_readbyte: 
02c3 d5				push de 
02c4 c5				push bc 
02c5			 
02c5			    ;   ld c, a 
02c5 e5			        push hl 
02c6			 
02c6			    ; initi write mode 
02c6			    ; 
02c6			    ;CS low 
02c6			 
02c6 3a 64 fa		       ld a,(spi_portbyte) 
02c9 cd ca 01			call spi_ce_low 
02cc			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02cc d3 80		       out (storage_adata),a 
02ce 32 64 fa		       ld (spi_portbyte), a 
02d1			 
02d1			    ;clock out wren instruction 
02d1			 
02d1 3e 03		    ld a, store_read_ins 
02d3 cd b8 00		    call spi_send_byte  
02d6			 
02d6			 
02d6			    ; clock out address (depending on address size) 
02d6			     
02d6 e1			    pop hl 
02d7 7c			    ld a,h    ; address out msb first 
02d8 cd b8 00		    call spi_send_byte  
02db 7d			    ld a,l 
02dc cd b8 00		    call spi_send_byte  
02df			 
02df			    ; clock in byte(s) for page 
02df			 
02df cd df 00		    call spi_read_byte  
02e2 f5				push af 
02e3			 
02e3			    ; end write with ce high 
02e3 3a 64 fa		       ld a,(spi_portbyte) 
02e6			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02e6 cd b9 01			call spi_ce_high 
02e9 d3 80		       out (storage_adata),a 
02eb 32 64 fa		       ld (spi_portbyte), a 
02ee			 
02ee f1				pop af 
02ef			 
02ef c1				pop bc 
02f0 d1				pop de 
02f1			 
02f1 c9			    ret 
02f2			 
02f2			if DEBUG_STORESE 
02f2			 
02f2			storageput:  
02f2			 
02f2			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02f2			 
02f2 21 c6 f1			ld hl,scratch+2 
02f5 cd 3d 13			call get_word_hl 
02f8			 
02f8				; stuff it here for the moment as it will be overwritten later anyway 
02f8			 
02f8 22 e7 f4			ld (os_cur_ptr),hl	 
02fb			 
02fb			 
02fb			; get pointer to start of string 
02fb			 
02fb 21 cb f1			ld hl, scratch+7 
02fe			 
02fe			; loop writing char of string to eeprom 
02fe			 
02fe 7e			.writestr:	ld a,(hl) 
02ff fe 00				cp 0 
0301 28 12				jr z, .wsdone		; done writing 
0303 e5					push hl 
0304 2a e7 f4				ld hl,(os_cur_ptr) 
0307 cd 21 02				call se_writebyte 
030a			 
030a 2a e7 f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
030d 23					inc hl 
030e 22 e7 f4				ld (os_cur_ptr),hl 
0311			 
0311					; restore string pointer and get next char 
0311			 
0311 e1					pop hl 
0312 23					inc hl 
0313 18 e9				jr .writestr 
0315			 
0315			 
0315			 
0315			.wsdone: 
0315			 
0315			 
0315			; when done load first page into a buffer  
0315			 
0315 21 00 80				ld hl,08000h		; start in ram 
0318 22 e7 f4				ld (os_cur_ptr),hl 
031b 21 00 00				ld hl, 0		 ; start of page 
031e 22 ec f1				ld (scratch+40),hl	; hang on to it 
0321			 
0321 06 80				ld b, 128		; actually get more then one page 
0323 c5			.wsload:	push bc 
0324 2a ec f1				ld hl,(scratch+40) 
0327 e5					push hl 
0328 cd c3 02				call se_readbyte 
032b			 
032b					; a now as the byte 
032b			 
032b 2a e7 f4				ld hl,(os_cur_ptr) 
032e 77					ld (hl),a 
032f					; inc next buffer area 
032f 23					inc hl 
0330 22 e7 f4				ld (os_cur_ptr),hl 
0333			 
0333					; get eeprom position, inc and save for next round 
0333 e1					pop hl		 
0334 23					inc hl 
0335 22 ec f1				ld (scratch+40),hl 
0338 c1					pop bc 
0339 10 e8				djnz .wsload 
033b			 
033b			; set 'd' pointer to start of buffer 
033b			 
033b 21 00 80				ld hl,08000h 
033e 22 e7 f4				ld (os_cur_ptr),hl 
0341			 
0341			 
0341 c9			ret 
0342			 
0342			 
0342 c9			storageread: ret 
0343			 
0343			 
0343			 
0343			 
0343			 
0343			 
0343			endif 
0343			 
0343			 
0343			 
# End of file firmware_seeprom.asm
0343			else  
0343			   ; create some stubs for the labels  
0343			se_readbyte: ret  
0343			se_writebyte: ret  
0343			storage_init: ret  
0343			  
0343			endif  
0343			  
0343			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0343			;include "firmware_cf.asm"  
0343			  
0343			; load up high level storage hardward abstractions  
0343			include "firmware_storage.asm"  
0343			 
0343			; persisent storage hardware abstraction layer  
0343			 
0343			 
0343			 
0343			; Block 0 on storage is a config state 
0343			 
0343			 
0343			 
0343			; TODO add read phy block and write phy block functions 
0343			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0343			 
0343			; Abstraction layer  
0343			 
0343			; Logocial block size is same size as physical size - using tape concept 
0343			 
0343			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0343			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0343			 
0343			 
0343			 
0343			; Filesystem layout (Logical layout) 
0343			; 
0343			; Block 0 - Bank config  
0343			; 
0343			;      Byte - 0 file id counter 
0343			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0343			;      Byte - 3-20 zero terminated bank label 
0343			; 
0343			; Block 1 > File storage 
0343			; 
0343			;      Byte 0 file id    - block 0 file details 
0343			;      Byte 1 block id - block 0 is file  
0343			;            Byte 2-15 - File name 
0343			; 
0343			;       - to end of block data 
0343			; 
0343			 
0343			; Get ID for the file named in pointer held HL 
0343			; Returns ID in HL = 255 if no file found 
0343			 
0343			storage_getid: 
0343			 
0343 22 76 fa			ld (store_tmp1), hl 
0346			 
0346				if DEBUG_STORESE 
0346					DMARK "SGI" 
0346 f5				push af  
0347 3a 5b 03			ld a, (.dmark)  
034a 32 6e fe			ld (debug_mark),a  
034d 3a 5c 03			ld a, (.dmark+1)  
0350 32 6f fe			ld (debug_mark+1),a  
0353 3a 5d 03			ld a, (.dmark+2)  
0356 32 70 fe			ld (debug_mark+2),a  
0359 18 03			jr .pastdmark  
035b ..			.dmark: db "SGI"  
035e f1			.pastdmark: pop af  
035f			endm  
# End of macro DMARK
035f					CALLMONITOR 
035f cd fb 19			call break_point_state  
0362				endm  
# End of macro CALLMONITOR
0362				endif 
0362				; get block 0 and set counter for number of files to scan 
0362			 
0362 cd cd 04			call storage_get_block_0 
0365			 
0365 3a 7d fa			ld a, (store_page) 
0368 47				ld b, a 
0369			 
0369				; get extent 0 of each file id 
0369			 
0369				if DEBUG_STORESE 
0369					DMARK "SGc" 
0369 f5				push af  
036a 3a 7e 03			ld a, (.dmark)  
036d 32 6e fe			ld (debug_mark),a  
0370 3a 7f 03			ld a, (.dmark+1)  
0373 32 6f fe			ld (debug_mark+1),a  
0376 3a 80 03			ld a, (.dmark+2)  
0379 32 70 fe			ld (debug_mark+2),a  
037c 18 03			jr .pastdmark  
037e ..			.dmark: db "SGc"  
0381 f1			.pastdmark: pop af  
0382			endm  
# End of macro DMARK
0382					CALLMONITOR 
0382 cd fb 19			call break_point_state  
0385				endm  
# End of macro CALLMONITOR
0385				endif 
0385 60			.getloop:	ld h, b 
0386 2e 00				ld l, 0 
0388 c5					push bc 
0389			 
0389 11 7d fa				ld de, store_page 
038c				if DEBUG_STORESE 
038c					DMARK "SGr" 
038c f5				push af  
038d 3a a1 03			ld a, (.dmark)  
0390 32 6e fe			ld (debug_mark),a  
0393 3a a2 03			ld a, (.dmark+1)  
0396 32 6f fe			ld (debug_mark+1),a  
0399 3a a3 03			ld a, (.dmark+2)  
039c 32 70 fe			ld (debug_mark+2),a  
039f 18 03			jr .pastdmark  
03a1 ..			.dmark: db "SGr"  
03a4 f1			.pastdmark: pop af  
03a5			endm  
# End of macro DMARK
03a5					CALLMONITOR 
03a5 cd fb 19			call break_point_state  
03a8				endm  
# End of macro CALLMONITOR
03a8				endif 
03a8 cd 75 09				call storage_read 
03ab cd af 0f				call ishlzero 
03ae 28 2d				jr z, .gap 
03b0					 
03b0					; have a file name read. Is it one we want. 
03b0			 
03b0 2a 76 fa				ld hl, (store_tmp1) 
03b3 11 80 fa				ld de, store_page+3   ; file name 
03b6			 
03b6				if DEBUG_STORESE 
03b6					DMARK "SGc" 
03b6 f5				push af  
03b7 3a cb 03			ld a, (.dmark)  
03ba 32 6e fe			ld (debug_mark),a  
03bd 3a cc 03			ld a, (.dmark+1)  
03c0 32 6f fe			ld (debug_mark+1),a  
03c3 3a cd 03			ld a, (.dmark+2)  
03c6 32 70 fe			ld (debug_mark+2),a  
03c9 18 03			jr .pastdmark  
03cb ..			.dmark: db "SGc"  
03ce f1			.pastdmark: pop af  
03cf			endm  
# End of macro DMARK
03cf					CALLMONITOR 
03cf cd fb 19			call break_point_state  
03d2				endm  
# End of macro CALLMONITOR
03d2				endif 
03d2 cd 1c 14				call strcmp 
03d5 20 06				jr nz, .gap   ; not this one 
03d7			 
03d7 c1				        pop bc 
03d8			 
03d8 26 00				ld h, 0 
03da 68					ld l, b 
03db 18 22				jr .getdone 
03dd						 
03dd			 
03dd			 
03dd			 
03dd			.gap: 
03dd				if DEBUG_STORESE 
03dd					DMARK "SGg" 
03dd f5				push af  
03de 3a f2 03			ld a, (.dmark)  
03e1 32 6e fe			ld (debug_mark),a  
03e4 3a f3 03			ld a, (.dmark+1)  
03e7 32 6f fe			ld (debug_mark+1),a  
03ea 3a f4 03			ld a, (.dmark+2)  
03ed 32 70 fe			ld (debug_mark+2),a  
03f0 18 03			jr .pastdmark  
03f2 ..			.dmark: db "SGg"  
03f5 f1			.pastdmark: pop af  
03f6			endm  
# End of macro DMARK
03f6					CALLMONITOR 
03f6 cd fb 19			call break_point_state  
03f9				endm  
# End of macro CALLMONITOR
03f9				endif 
03f9			 
03f9 c1					pop bc 
03fa 10 89				djnz .getloop 
03fc 21 ff 00				ld hl, 255 
03ff			.getdone: 
03ff			 
03ff				if DEBUG_STORESE 
03ff					DMARK "SGe" 
03ff f5				push af  
0400 3a 14 04			ld a, (.dmark)  
0403 32 6e fe			ld (debug_mark),a  
0406 3a 15 04			ld a, (.dmark+1)  
0409 32 6f fe			ld (debug_mark+1),a  
040c 3a 16 04			ld a, (.dmark+2)  
040f 32 70 fe			ld (debug_mark+2),a  
0412 18 03			jr .pastdmark  
0414 ..			.dmark: db "SGe"  
0417 f1			.pastdmark: pop af  
0418			endm  
# End of macro DMARK
0418					CALLMONITOR 
0418 cd fb 19			call break_point_state  
041b				endm  
# End of macro CALLMONITOR
041b				endif 
041b			 
041b c9				ret 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			; Read Block 
041c			; ---------- 
041c			; 
041c			; With current bank 
041c			;  
041c			; Get block number to read 
041c			; Load physical blocks starting at start block into buffer 
041c			 
041c			; de points to buffer to use 
041c			; hl holds logical block number  
041c			 
041c			storage_read_block: 
041c			 
041c				; TODO bank selection 
041c			 
041c				; for each of the physical blocks read it into the buffer 
041c 06 40			ld b, STORE_BLOCK_PHY 
041e			 
041e				if DEBUG_STORESE 
041e d5					push de 
041f				endif 
041f				 
041f			.rl1:    
041f			 
041f				; read physical block at hl into de 
041f			        ; increment hl and de to next read position on exit 
041f			 
041f e5				push hl 
0420 d5				push de	 
0421 c5				push bc 
0422			;	if DEBUG_STORESE 
0422			;		push af 
0422			;		ld a, 'R' 
0422			;		ld (debug_mark),a 
0422			;		pop af 
0422			;		CALLMONITOR 
0422			;	endif 
0422 cd c3 02			call se_readbyte 
0425			;	if DEBUG_STORESE 
0425			;		ld a,(spi_portbyte) 
0425			;		ld l, a 
0425			;		push af 
0425			;		ld a, '1' 
0425			;		ld (debug_mark),a 
0425			;		pop af 
0425			;		CALLMONITOR 
0425			;	endif 
0425 c1				pop bc 
0426 d1				pop de 
0427 e1				pop hl 
0428 12				ld (de),a 
0429 23				inc hl 
042a 13				inc de 
042b			 
042b			;	if DEBUG_STORESE 
042b			;		push af 
042b			;		ld a, 'r' 
042b			;		ld (debug_mark),a 
042b			;		pop af 
042b			;		CALLMONITOR 
042b			;	endif 
042b			 
042b 10 f2			djnz .rl1 
042d			 
042d				if DEBUG_STORESE 
042d					DMARK "SRB" 
042d f5				push af  
042e 3a 42 04			ld a, (.dmark)  
0431 32 6e fe			ld (debug_mark),a  
0434 3a 43 04			ld a, (.dmark+1)  
0437 32 6f fe			ld (debug_mark+1),a  
043a 3a 44 04			ld a, (.dmark+2)  
043d 32 70 fe			ld (debug_mark+2),a  
0440 18 03			jr .pastdmark  
0442 ..			.dmark: db "SRB"  
0445 f1			.pastdmark: pop af  
0446			endm  
# End of macro DMARK
0446 d1					pop de 
0447			; 
0447			;		push af 
0447			;		ld a, 'R' 
0447			;		ld (debug_mark),a 
0447			;		pop af 
0447					CALLMONITOR 
0447 cd fb 19			call break_point_state  
044a				endm  
# End of macro CALLMONITOR
044a				endif 
044a c9				ret	 
044b				 
044b			 
044b			; File Size 
044b			; --------- 
044b			; 
044b			;   hl file id 
044b			; 
044b			;  returns in hl the number of blocks 
044b			 
044b			storage_file_size: 
044b 5d				ld e, l 
044c 16 00			ld d, 0 
044e 21 40 00			ld hl, STORE_BLOCK_PHY 
0451					if DEBUG_FORTH_WORDS 
0451						DMARK "SIZ" 
0451 f5				push af  
0452 3a 66 04			ld a, (.dmark)  
0455 32 6e fe			ld (debug_mark),a  
0458 3a 67 04			ld a, (.dmark+1)  
045b 32 6f fe			ld (debug_mark+1),a  
045e 3a 68 04			ld a, (.dmark+2)  
0461 32 70 fe			ld (debug_mark+2),a  
0464 18 03			jr .pastdmark  
0466 ..			.dmark: db "SIZ"  
0469 f1			.pastdmark: pop af  
046a			endm  
# End of macro DMARK
046a						CALLMONITOR 
046a cd fb 19			call break_point_state  
046d				endm  
# End of macro CALLMONITOR
046d					endif 
046d cd 4f 07			call storage_findnextid 
0470			 
0470 cd af 0f			call ishlzero 
0473			;	ld a, l 
0473			;	add h 
0473			;	cp 0 
0473 c8				ret z			; block not found so EOF 
0474			 
0474 11 7d fa			ld de, store_page 
0477 cd 1c 04			call storage_read_block 
047a			 
047a 3a 7f fa			ld a, (store_page+2)	 ; get extent count 
047d 6f				ld l, a 
047e 26 00			ld h, 0 
0480 c9			 	ret 
0481			 
0481			 
0481			; Write Block 
0481			; ----------- 
0481			; 
0481			; With current bank 
0481			;  
0481			; Get block number to write 
0481			; Write physical blocks starting at start block from buffer 
0481			  
0481			storage_write_block: 
0481				; TODO bank selection 
0481			 
0481				; for each of the physical blocks read it into the buffer 
0481 06 40			ld b, STORE_BLOCK_PHY 
0483			 
0483				if DEBUG_STORESE 
0483					DMARK "SWB" 
0483 f5				push af  
0484 3a 98 04			ld a, (.dmark)  
0487 32 6e fe			ld (debug_mark),a  
048a 3a 99 04			ld a, (.dmark+1)  
048d 32 6f fe			ld (debug_mark+1),a  
0490 3a 9a 04			ld a, (.dmark+2)  
0493 32 70 fe			ld (debug_mark+2),a  
0496 18 03			jr .pastdmark  
0498 ..			.dmark: db "SWB"  
049b f1			.pastdmark: pop af  
049c			endm  
# End of macro DMARK
049c			 
049c					;push af 
049c					;ld a, 'W' 
049c					;ld (debug_mark),a 
049c					;pop af 
049c					CALLMONITOR 
049c cd fb 19			call break_point_state  
049f				endm  
# End of macro CALLMONITOR
049f				endif 
049f			 
049f			; might not be working 
049f			;	call se_writepage 
049f			 
049f			;	ret 
049f			; 
049f			 
049f			 
049f			 
049f			.wl1:    
049f			 
049f				; read physical block at hl into de 
049f			        ; increment hl and de to next read position on exit 
049f			 
049f e5				push hl 
04a0 d5				push de	 
04a1 c5				push bc 
04a2 1a				ld a,(de) 
04a3				;if DEBUG_STORESE 
04a3			;		push af 
04a3			;		ld a, 'W' 
04a3			;		ld (debug_mark),a 
04a3			;		pop af 
04a3			;		CALLMONITOR 
04a3			;	endif 
04a3 cd 21 02			call se_writebyte 
04a6			;	call delay250ms 
04a6 00				nop 
04a7 00				nop 
04a8 00				nop 
04a9			;	if DEBUG_STORESE 
04a9			;		push af 
04a9			;		ld a, 'w' 
04a9			;		ld (debug_mark),a 
04a9			;		pop af 
04a9			;		CALLMONITOR 
04a9			;	endif 
04a9 c1				pop bc 
04aa d1				pop de 
04ab e1				pop hl 
04ac 23				inc hl 
04ad 13				inc de 
04ae			 
04ae			 
04ae 10 ef			djnz .wl1 
04b0			 
04b0				if DEBUG_STORESE 
04b0					DMARK "SW2" 
04b0 f5				push af  
04b1 3a c5 04			ld a, (.dmark)  
04b4 32 6e fe			ld (debug_mark),a  
04b7 3a c6 04			ld a, (.dmark+1)  
04ba 32 6f fe			ld (debug_mark+1),a  
04bd 3a c7 04			ld a, (.dmark+2)  
04c0 32 70 fe			ld (debug_mark+2),a  
04c3 18 03			jr .pastdmark  
04c5 ..			.dmark: db "SW2"  
04c8 f1			.pastdmark: pop af  
04c9			endm  
# End of macro DMARK
04c9			 
04c9					;push af 
04c9					;ld a, 'W' 
04c9					;ld (debug_mark),a 
04c9					;pop af 
04c9					CALLMONITOR 
04c9 cd fb 19			call break_point_state  
04cc				endm  
# End of macro CALLMONITOR
04cc				endif 
04cc c9				ret	 
04cd			 
04cd			; Init bank 
04cd			; --------- 
04cd			; 
04cd			; With current bank 
04cd			; 
04cd			; Setup block 0 config 
04cd			;     Set 0 file id counter 
04cd			;     Set formatted byte pattern 
04cd			;     Zero out bank label 
04cd			;      
04cd			; For every logical block write 0-1 byte as null 
04cd			 
04cd			storage_get_block_0: 
04cd			 
04cd				; TODO check presence 
04cd			 
04cd				; get block 0 config 
04cd			 
04cd 21 00 00			ld hl, 0 
04d0 11 7d fa			ld de, store_page 
04d3 cd 1c 04			call storage_read_block 
04d6			 
04d6				if DEBUG_STORESE 
04d6					DMARK "SB0" 
04d6 f5				push af  
04d7 3a eb 04			ld a, (.dmark)  
04da 32 6e fe			ld (debug_mark),a  
04dd 3a ec 04			ld a, (.dmark+1)  
04e0 32 6f fe			ld (debug_mark+1),a  
04e3 3a ed 04			ld a, (.dmark+2)  
04e6 32 70 fe			ld (debug_mark+2),a  
04e9 18 03			jr .pastdmark  
04eb ..			.dmark: db "SB0"  
04ee f1			.pastdmark: pop af  
04ef			endm  
# End of macro DMARK
04ef 11 7d fa				ld de, store_page 
04f2			;		push af 
04f2			;		ld a, 'i' 
04f2			;		ld (debug_mark),a 
04f2			;		pop af 
04f2					CALLMONITOR 
04f2 cd fb 19			call break_point_state  
04f5				endm  
# End of macro CALLMONITOR
04f5				endif 
04f5			 
04f5				; is this area formatted? 
04f5			 
04f5			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04f5 2a 7e fa			ld hl, (store_page+1) 
04f8 3e 80			ld a,0x80 
04fa bd				cp l 
04fb 20 22			jr nz, .ininotformatted 
04fd				; do a double check 
04fd 3e 27			ld a, 0x27 
04ff bc				cp h 
0500 20 1d			jr nz, .ininotformatted 
0502			 
0502				; formatted then 
0502			 
0502				if DEBUG_STORESE 
0502					DMARK "SB1" 
0502 f5				push af  
0503 3a 17 05			ld a, (.dmark)  
0506 32 6e fe			ld (debug_mark),a  
0509 3a 18 05			ld a, (.dmark+1)  
050c 32 6f fe			ld (debug_mark+1),a  
050f 3a 19 05			ld a, (.dmark+2)  
0512 32 70 fe			ld (debug_mark+2),a  
0515 18 03			jr .pastdmark  
0517 ..			.dmark: db "SB1"  
051a f1			.pastdmark: pop af  
051b			endm  
# End of macro DMARK
051b					;push af 
051b					;ld a, 'I' 
051b					;ld (debug_mark),a 
051b					;pop af 
051b					CALLMONITOR 
051b cd fb 19			call break_point_state  
051e				endm  
# End of macro CALLMONITOR
051e				endif 
051e c9				ret 
051f			 
051f			.ininotformatted: 
051f				; bank not formatted so poke various bits to make sure 
051f			 
051f				if DEBUG_STORESE 
051f					DMARK "SB2" 
051f f5				push af  
0520 3a 34 05			ld a, (.dmark)  
0523 32 6e fe			ld (debug_mark),a  
0526 3a 35 05			ld a, (.dmark+1)  
0529 32 6f fe			ld (debug_mark+1),a  
052c 3a 36 05			ld a, (.dmark+2)  
052f 32 70 fe			ld (debug_mark+2),a  
0532 18 03			jr .pastdmark  
0534 ..			.dmark: db "SB2"  
0537 f1			.pastdmark: pop af  
0538			endm  
# End of macro DMARK
0538					;push af 
0538					;ld a, 'f' 
0538					;ld (debug_mark),a 
0538					;pop af 
0538					CALLMONITOR 
0538 cd fb 19			call break_point_state  
053b				endm  
# End of macro CALLMONITOR
053b				endif 
053b			 
053b cd 58 0c			call storage_clear_page 
053e			 
053e 21 7d fa			ld hl, store_page 
0541 3e 00			ld a, 0 
0543				 
0543 77				ld (hl),a   ; reset file counter 
0544			 
0544 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0547 22 7e fa		 	ld (store_page+1), hl	 
054a			 
054a				; set default label 
054a			 
054a 21 e6 05			ld hl, .defaultbanklabl 
054d 11 80 fa		 	ld de, store_page+3 
0550 01 0f 00			ld bc, 15 
0553 ed b0			ldir 
0555			 
0555				; Append the current bank id 
0555 21 89 fa			ld hl, store_page+3+9 
0558 3a 62 fa			ld a, (spi_device_id) 
055b 77				ld (hl), a 
055c			 
055c				; save default page 0 
055c			 
055c 21 00 00			ld hl, 0 
055f 11 7d fa			ld de, store_page 
0562				if DEBUG_STORESE 
0562					DMARK "SB3" 
0562 f5				push af  
0563 3a 77 05			ld a, (.dmark)  
0566 32 6e fe			ld (debug_mark),a  
0569 3a 78 05			ld a, (.dmark+1)  
056c 32 6f fe			ld (debug_mark+1),a  
056f 3a 79 05			ld a, (.dmark+2)  
0572 32 70 fe			ld (debug_mark+2),a  
0575 18 03			jr .pastdmark  
0577 ..			.dmark: db "SB3"  
057a f1			.pastdmark: pop af  
057b			endm  
# End of macro DMARK
057b			;		push af 
057b			;		ld a, 'F' 
057b			;		ld (debug_mark),a 
057b			;		pop af 
057b					CALLMONITOR 
057b cd fb 19			call break_point_state  
057e				endm  
# End of macro CALLMONITOR
057e				endif 
057e cd 81 04			call storage_write_block 
0581				if DEBUG_STORESE 
0581					DMARK "SB4" 
0581 f5				push af  
0582 3a 96 05			ld a, (.dmark)  
0585 32 6e fe			ld (debug_mark),a  
0588 3a 97 05			ld a, (.dmark+1)  
058b 32 6f fe			ld (debug_mark+1),a  
058e 3a 98 05			ld a, (.dmark+2)  
0591 32 70 fe			ld (debug_mark+2),a  
0594 18 03			jr .pastdmark  
0596 ..			.dmark: db "SB4"  
0599 f1			.pastdmark: pop af  
059a			endm  
# End of macro DMARK
059a			;		push af 
059a			;		ld a, '>' 
059a			;		ld (debug_mark),a 
059a			;		pop af 
059a					CALLMONITOR 
059a cd fb 19			call break_point_state  
059d				endm  
# End of macro CALLMONITOR
059d				endif 
059d			 
059d 00				nop 
059e 00				nop 
059f 00				nop 
05a0			 
05a0				; now set 0 in every page to mark as a free block 
05a0			 
05a0 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05a2 21 40 00			ld hl, STORE_BLOCK_PHY 
05a5			 
05a5 3e 00		.setmark1:   	ld a,0 
05a7 e5					push hl 
05a8 c5					push bc 
05a9 cd 21 02				call se_writebyte 
05ac 3e 0a			ld a, 10 
05ae cd 7a 0c			call aDelayInMS 
05b1 23				inc hl 
05b2 cd 21 02				call se_writebyte 
05b5 3e 0a			ld a, 10 
05b7 cd 7a 0c			call aDelayInMS 
05ba 2b				dec hl 
05bb c1					pop bc 
05bc e1					pop hl 
05bd 3e 40				ld a, STORE_BLOCK_PHY 
05bf cd 86 0f				call addatohl 
05c2 10 e1				djnz .setmark1 
05c4			 
05c4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05c6 3e 00		.setmark2:   	ld a,0 
05c8 e5					push hl 
05c9 c5					push bc 
05ca cd 21 02				call se_writebyte 
05cd 3e 0a			ld a, 10 
05cf cd 7a 0c			call aDelayInMS 
05d2 23				inc hl 
05d3 cd 21 02				call se_writebyte 
05d6 3e 0a			ld a, 10 
05d8 cd 7a 0c			call aDelayInMS 
05db 2b				dec hl 
05dc c1					pop bc 
05dd e1					pop hl 
05de 3e 40				ld a, STORE_BLOCK_PHY 
05e0 cd 86 0f				call addatohl 
05e3 10 e1				djnz .setmark2 
05e5			 
05e5					 
05e5			 
05e5			 
05e5 c9				ret 
05e6			 
05e6			 
05e6			 
05e6			 
05e6 .. 00		.defaultbanklabl:   db "BankLabel_",0 
05f1			 
05f1			 
05f1			 
05f1			; Label Bank 
05f1			; ---------- 
05f1			; 
05f1			; With current bank 
05f1			; Read block 0 
05f1			; Set label 
05f1			; Write block 0 
05f1			 
05f1			; label str pointer in hl 
05f1			 
05f1			storage_label:     
05f1			 
05f1				if DEBUG_STORESE 
05f1					DMARK "LBL" 
05f1 f5				push af  
05f2 3a 06 06			ld a, (.dmark)  
05f5 32 6e fe			ld (debug_mark),a  
05f8 3a 07 06			ld a, (.dmark+1)  
05fb 32 6f fe			ld (debug_mark+1),a  
05fe 3a 08 06			ld a, (.dmark+2)  
0601 32 70 fe			ld (debug_mark+2),a  
0604 18 03			jr .pastdmark  
0606 ..			.dmark: db "LBL"  
0609 f1			.pastdmark: pop af  
060a			endm  
# End of macro DMARK
060a					CALLMONITOR 
060a cd fb 19			call break_point_state  
060d				endm  
# End of macro CALLMONITOR
060d				endif 
060d			 
060d e5				push hl 
060e			 
060e cd cd 04			call storage_get_block_0 
0611			 
0611				; set default label 
0611			 
0611 e1				pop hl 
0612			 
0612 11 80 fa		 	ld de, store_page+3 
0615 01 0f 00			ld bc, 15 
0618				if DEBUG_STORESE 
0618					DMARK "LB3" 
0618 f5				push af  
0619 3a 2d 06			ld a, (.dmark)  
061c 32 6e fe			ld (debug_mark),a  
061f 3a 2e 06			ld a, (.dmark+1)  
0622 32 6f fe			ld (debug_mark+1),a  
0625 3a 2f 06			ld a, (.dmark+2)  
0628 32 70 fe			ld (debug_mark+2),a  
062b 18 03			jr .pastdmark  
062d ..			.dmark: db "LB3"  
0630 f1			.pastdmark: pop af  
0631			endm  
# End of macro DMARK
0631					CALLMONITOR 
0631 cd fb 19			call break_point_state  
0634				endm  
# End of macro CALLMONITOR
0634				endif 
0634 ed b0			ldir 
0636				; save default page 0 
0636			 
0636 21 00 00			ld hl, 0 
0639 11 7d fa			ld de, store_page 
063c				if DEBUG_STORESE 
063c					DMARK "LBW" 
063c f5				push af  
063d 3a 51 06			ld a, (.dmark)  
0640 32 6e fe			ld (debug_mark),a  
0643 3a 52 06			ld a, (.dmark+1)  
0646 32 6f fe			ld (debug_mark+1),a  
0649 3a 53 06			ld a, (.dmark+2)  
064c 32 70 fe			ld (debug_mark+2),a  
064f 18 03			jr .pastdmark  
0651 ..			.dmark: db "LBW"  
0654 f1			.pastdmark: pop af  
0655			endm  
# End of macro DMARK
0655					CALLMONITOR 
0655 cd fb 19			call break_point_state  
0658				endm  
# End of macro CALLMONITOR
0658				endif 
0658 cd 81 04			call storage_write_block 
065b			 
065b c9				ret 
065c			 
065c			 
065c			 
065c			; Read Block 0 - Config 
065c			; --------------------- 
065c			; 
065c			; With current bank 
065c			; Call presence test 
065c			;    If not present format/init bank  
065c			; Read block 0  
065c			;  
065c			 
065c			 
065c			; Dir 
065c			; --- 
065c			; 
065c			; With current bank 
065c			; Load Block 0 Config 
065c			; Get max file id number 
065c			; For each logical block 
065c			;    Read block read byte 2 
065c			;      if first block of file 
065c			;         Display file name 
065c			;         Display type flags for file 
065c			;        
065c			 
065c			; moving to words as this requires stack control 
065c			 
065c			 
065c			; Delete File 
065c			; ----------- 
065c			; 
065c			; With current bank 
065c			; 
065c			; Load Block 0 Config 
065c			; Get max file id number 
065c			; For each logical block 
065c			;    Read block file id 
065c			;      If first block of file and dont have file id 
065c			;         if file to delete 
065c			;         Save file id 
065c			;         Null file id 
065c			;         Write this block back 
065c			;      If file id is one saved 
065c			;         Null file id 
065c			;         Write this block back 
065c			 
065c			 
065c			.se_done: 
065c e1				pop hl 
065d c9				ret 
065e			 
065e			storage_erase: 
065e			 
065e				; hl contains the file id 
065e			 
065e 5d				ld e, l 
065f 16 00			ld d, 0 
0661 21 40 00			ld hl, STORE_BLOCK_PHY 
0664					if DEBUG_FORTH_WORDS 
0664						DMARK "ERA" 
0664 f5				push af  
0665 3a 79 06			ld a, (.dmark)  
0668 32 6e fe			ld (debug_mark),a  
066b 3a 7a 06			ld a, (.dmark+1)  
066e 32 6f fe			ld (debug_mark+1),a  
0671 3a 7b 06			ld a, (.dmark+2)  
0674 32 70 fe			ld (debug_mark+2),a  
0677 18 03			jr .pastdmark  
0679 ..			.dmark: db "ERA"  
067c f1			.pastdmark: pop af  
067d			endm  
# End of macro DMARK
067d						CALLMONITOR 
067d cd fb 19			call break_point_state  
0680				endm  
# End of macro CALLMONITOR
0680					endif 
0680 cd 4f 07			call storage_findnextid 
0683 cd af 0f			call ishlzero 
0686 c8				ret z 
0687			 
0687 e5				push hl 
0688			 
0688				; TODO check file not found 
0688			 
0688 11 7d fa			ld de, store_page 
068b cd 1c 04			call storage_read_block 
068e			 
068e cd af 0f			call ishlzero 
0691 ca 5c 06			jp z,.se_done 
0694			 
0694					if DEBUG_FORTH_WORDS 
0694						DMARK "ER1" 
0694 f5				push af  
0695 3a a9 06			ld a, (.dmark)  
0698 32 6e fe			ld (debug_mark),a  
069b 3a aa 06			ld a, (.dmark+1)  
069e 32 6f fe			ld (debug_mark+1),a  
06a1 3a ab 06			ld a, (.dmark+2)  
06a4 32 70 fe			ld (debug_mark+2),a  
06a7 18 03			jr .pastdmark  
06a9 ..			.dmark: db "ER1"  
06ac f1			.pastdmark: pop af  
06ad			endm  
# End of macro DMARK
06ad						CALLMONITOR 
06ad cd fb 19			call break_point_state  
06b0				endm  
# End of macro CALLMONITOR
06b0					endif 
06b0 3a 7d fa			ld a, (store_page)	; get file id 
06b3 32 71 fa			ld (store_tmpid), a 
06b6			 
06b6 3a 7f fa			ld a, (store_page+2)    ; get count of extends 
06b9 32 70 fa			ld (store_tmpext), a 
06bc			 
06bc				; wipe file header 
06bc			 
06bc e1				pop hl 
06bd 3e 00			ld a, 0 
06bf 32 7d fa			ld (store_page), a 
06c2 32 7e fa			ld (store_page+1),a 
06c5 11 7d fa			ld de, store_page 
06c8					if DEBUG_FORTH_WORDS 
06c8						DMARK "ER2" 
06c8 f5				push af  
06c9 3a dd 06			ld a, (.dmark)  
06cc 32 6e fe			ld (debug_mark),a  
06cf 3a de 06			ld a, (.dmark+1)  
06d2 32 6f fe			ld (debug_mark+1),a  
06d5 3a df 06			ld a, (.dmark+2)  
06d8 32 70 fe			ld (debug_mark+2),a  
06db 18 03			jr .pastdmark  
06dd ..			.dmark: db "ER2"  
06e0 f1			.pastdmark: pop af  
06e1			endm  
# End of macro DMARK
06e1						CALLMONITOR 
06e1 cd fb 19			call break_point_state  
06e4				endm  
# End of macro CALLMONITOR
06e4					endif 
06e4 cd 81 04			call storage_write_block 
06e7			 
06e7			 
06e7				; wipe file extents 
06e7			 
06e7 3a 70 fa			ld a, (store_tmpext) 
06ea 47				ld b, a 
06eb			 
06eb			.eraext:	  
06eb c5				push bc 
06ec			 
06ec 21 40 00			ld hl, STORE_BLOCK_PHY 
06ef 3a 71 fa			ld a,(store_tmpid) 
06f2 5f				ld e, a 
06f3 50				ld d, b	 
06f4					if DEBUG_FORTH_WORDS 
06f4						DMARK "ER3" 
06f4 f5				push af  
06f5 3a 09 07			ld a, (.dmark)  
06f8 32 6e fe			ld (debug_mark),a  
06fb 3a 0a 07			ld a, (.dmark+1)  
06fe 32 6f fe			ld (debug_mark+1),a  
0701 3a 0b 07			ld a, (.dmark+2)  
0704 32 70 fe			ld (debug_mark+2),a  
0707 18 03			jr .pastdmark  
0709 ..			.dmark: db "ER3"  
070c f1			.pastdmark: pop af  
070d			endm  
# End of macro DMARK
070d						CALLMONITOR 
070d cd fb 19			call break_point_state  
0710				endm  
# End of macro CALLMONITOR
0710					endif 
0710 cd 4f 07			call storage_findnextid 
0713 cd af 0f			call ishlzero 
0716 ca 5c 06			jp z,.se_done 
0719			 
0719 e5				push hl 
071a 11 7d fa			ld de, store_page 
071d cd 1c 04			call storage_read_block 
0720			 
0720				; free block	 
0720			 
0720 3e 00			ld a, 0 
0722 32 7d fa			ld (store_page), a 
0725 32 7e fa			ld (store_page+1),a 
0728 11 7d fa			ld de, store_page 
072b e1				pop hl 
072c					if DEBUG_FORTH_WORDS 
072c						DMARK "ER4" 
072c f5				push af  
072d 3a 41 07			ld a, (.dmark)  
0730 32 6e fe			ld (debug_mark),a  
0733 3a 42 07			ld a, (.dmark+1)  
0736 32 6f fe			ld (debug_mark+1),a  
0739 3a 43 07			ld a, (.dmark+2)  
073c 32 70 fe			ld (debug_mark+2),a  
073f 18 03			jr .pastdmark  
0741 ..			.dmark: db "ER4"  
0744 f1			.pastdmark: pop af  
0745			endm  
# End of macro DMARK
0745						CALLMONITOR 
0745 cd fb 19			call break_point_state  
0748				endm  
# End of macro CALLMONITOR
0748					endif 
0748 cd 81 04			call storage_write_block 
074b			 
074b c1				pop bc 
074c 10 9d			djnz .eraext 
074e			 
074e c9				ret 
074f			 
074f			 
074f			; Find Free Block 
074f			; --------------- 
074f			; 
074f			; With current bank 
074f			;  
074f			; From given starting logical block 
074f			;    Read block  
074f			;    If no file id 
074f			;         Return block id 
074f			 
074f			 
074f			; hl starting page number 
074f			; hl contains free page number or zero if no pages free 
074f			; e contains the file id to locate 
074f			; d contains the block number 
074f			 
074f			; TODO change to find file id and use zero for free block 
074f			 
074f			storage_findnextid: 
074f			 
074f				; now locate first 0 page to mark as a free block 
074f			 
074f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0751			;	ld hl, STORE_BLOCK_PHY 
0751			 
0751					if DEBUG_FORTH_WORDS 
0751					DMARK "FNI" 
0751 f5				push af  
0752 3a 66 07			ld a, (.dmark)  
0755 32 6e fe			ld (debug_mark),a  
0758 3a 67 07			ld a, (.dmark+1)  
075b 32 6f fe			ld (debug_mark+1),a  
075e 3a 68 07			ld a, (.dmark+2)  
0761 32 70 fe			ld (debug_mark+2),a  
0764 18 03			jr .pastdmark  
0766 ..			.dmark: db "FNI"  
0769 f1			.pastdmark: pop af  
076a			endm  
# End of macro DMARK
076a						CALLMONITOR 
076a cd fb 19			call break_point_state  
076d				endm  
# End of macro CALLMONITOR
076d					endif 
076d			.ff1:   	 
076d e5					push hl 
076e c5					push bc 
076f d5					push de 
0770 cd c3 02				call se_readbyte 
0773 5f					ld e,a 
0774 23					inc hl 
0775 cd c3 02				call se_readbyte 
0778 57					ld d, a 
0779 e1					pop hl 
077a e5					push hl 
077b cd a4 0f				call cmp16 
077e 28 49				jr z, .fffound 
0780			 
0780 d1					pop de 
0781 c1					pop bc 
0782 e1					pop hl 
0783			 
0783					; is found? 
0783					;cp e 
0783					;ret z 
0783			 
0783 3e 40				ld a, STORE_BLOCK_PHY 
0785 cd 86 0f				call addatohl 
0788 10 e3				djnz .ff1 
078a			 
078a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
078c			.ff2:   	 
078c			 
078c e5					push hl 
078d c5					push bc 
078e d5					push de 
078f cd c3 02				call se_readbyte 
0792 5f					ld e,a 
0793 23					inc hl 
0794 cd c3 02				call se_readbyte 
0797 57					ld d, a 
0798			 
0798 e1					pop hl 
0799 e5					push hl 
079a cd a4 0f				call cmp16 
079d 28 2a				jr z, .fffound 
079f			 
079f d1					pop de 
07a0 c1					pop bc 
07a1 e1					pop hl 
07a2					; is found? 
07a2					;cp e 
07a2					;ret z 
07a2			 
07a2 3e 40				ld a, STORE_BLOCK_PHY 
07a4 cd 86 0f				call addatohl 
07a7 10 e3				djnz .ff2 
07a9			 
07a9			 
07a9					if DEBUG_FORTH_WORDS 
07a9					DMARK "FN-" 
07a9 f5				push af  
07aa 3a be 07			ld a, (.dmark)  
07ad 32 6e fe			ld (debug_mark),a  
07b0 3a bf 07			ld a, (.dmark+1)  
07b3 32 6f fe			ld (debug_mark+1),a  
07b6 3a c0 07			ld a, (.dmark+2)  
07b9 32 70 fe			ld (debug_mark+2),a  
07bc 18 03			jr .pastdmark  
07be ..			.dmark: db "FN-"  
07c1 f1			.pastdmark: pop af  
07c2			endm  
# End of macro DMARK
07c2					;	push af 
07c2					;	ld a, 'n' 
07c2					;	ld (debug_mark),a 
07c2					;	pop af 
07c2						CALLMONITOR 
07c2 cd fb 19			call break_point_state  
07c5				endm  
# End of macro CALLMONITOR
07c5					endif 
07c5				; no free marks! 
07c5 21 00 00				ld hl, 0 
07c8 c9				ret 
07c9			.fffound: 
07c9				 
07c9			 
07c9 d1					pop de 
07ca c1					pop bc 
07cb e1					pop hl 
07cc					if DEBUG_FORTH_WORDS 
07cc					DMARK "FNF" 
07cc f5				push af  
07cd 3a e1 07			ld a, (.dmark)  
07d0 32 6e fe			ld (debug_mark),a  
07d3 3a e2 07			ld a, (.dmark+1)  
07d6 32 6f fe			ld (debug_mark+1),a  
07d9 3a e3 07			ld a, (.dmark+2)  
07dc 32 70 fe			ld (debug_mark+2),a  
07df 18 03			jr .pastdmark  
07e1 ..			.dmark: db "FNF"  
07e4 f1			.pastdmark: pop af  
07e5			endm  
# End of macro DMARK
07e5					;	push af 
07e5					;	ld a, 'n' 
07e5					;	ld (debug_mark),a 
07e5					;	pop af 
07e5						CALLMONITOR 
07e5 cd fb 19			call break_point_state  
07e8				endm  
# End of macro CALLMONITOR
07e8					endif 
07e8 c9				ret 
07e9			 
07e9			 
07e9			 
07e9			; Free Space 
07e9			; ---------- 
07e9			; 
07e9			; With current bank 
07e9			; 
07e9			; Set block count to zero 
07e9			; Starting with first logical block 
07e9			;      Find free block  
07e9			;      If block id given, increment block count 
07e9			; 
07e9			;  
07e9			 
07e9			 
07e9			; hl contains count of free blocks 
07e9			 
07e9			storage_freeblocks: 
07e9			 
07e9				; now locate first 0 page to mark as a free block 
07e9			 
07e9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07eb 21 40 00			ld hl, STORE_BLOCK_PHY 
07ee 11 00 00			ld de, 0 
07f1			 
07f1			.fb1:   	 
07f1 e5					push hl 
07f2 c5					push bc 
07f3 d5					push de 
07f4 cd c3 02				call se_readbyte 
07f7 d1					pop de 
07f8 c1					pop bc 
07f9 e1					pop hl 
07fa			 
07fa					; is free? 
07fa fe 00				cp 0 
07fc 20 01				jr nz, .ff1cont 
07fe 13					inc de 
07ff			 
07ff			.ff1cont: 
07ff			 
07ff			 
07ff 3e 40				ld a, STORE_BLOCK_PHY 
0801 cd 86 0f				call addatohl 
0804 10 eb				djnz .fb1 
0806			 
0806 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0808			.fb2:   	 
0808 e5					push hl 
0809 c5					push bc 
080a d5					push de 
080b cd c3 02				call se_readbyte 
080e d1					pop de 
080f c1					pop bc 
0810 e1					pop hl 
0811			 
0811					; is free? 
0811 fe 00				cp 0 
0813 20 01				jr nz, .ff2cont 
0815 13					inc de 
0816			 
0816			.ff2cont: 
0816			 
0816 3e 40				ld a, STORE_BLOCK_PHY 
0818 cd 86 0f				call addatohl 
081b 10 eb				djnz .fb2 
081d			 
081d eb				ex de, hl 
081e c9				ret 
081f			 
081f			; Get File ID 
081f			; ----------- 
081f			; 
081f			; With current bank 
081f			;  
081f			; Load Block 0 Config 
081f			; Get max file id number 
081f			; For each logical block 
081f			;    Read block file id 
081f			;      If first block of file and dont have file id 
081f			;         if file get id and exit 
081f			 
081f			 
081f			 
081f			 
081f			; Create File 
081f			; ----------- 
081f			; 
081f			; With current bank  
081f			; Load Block 0 Config 
081f			; Get max file id number 
081f			; Increment file id number 
081f			; Save Config 
081f			; Find free block 
081f			; Set buffer with file name and file id 
081f			; Write buffer to free block  
081f			 
081f			 
081f			; hl point to file name 
081f			; hl returns file id 
081f			 
081f			; file format: 
081f			; byte 0 - file id 
081f			; byte 1 - extent number 
081f			; byte 2-> data 
081f			 
081f			; format for extent number 0: 
081f			; 
081f			; byte 0 - file id 
081f			; byte 1 - extent 0 
081f			; byte 2 - extent count 
081f			; byte 3 -> file name and meta data 
081f			 
081f			 
081f			storage_create: 
081f				if DEBUG_STORESE 
081f					DMARK "SCR" 
081f f5				push af  
0820 3a 34 08			ld a, (.dmark)  
0823 32 6e fe			ld (debug_mark),a  
0826 3a 35 08			ld a, (.dmark+1)  
0829 32 6f fe			ld (debug_mark+1),a  
082c 3a 36 08			ld a, (.dmark+2)  
082f 32 70 fe			ld (debug_mark+2),a  
0832 18 03			jr .pastdmark  
0834 ..			.dmark: db "SCR"  
0837 f1			.pastdmark: pop af  
0838			endm  
# End of macro DMARK
0838					CALLMONITOR 
0838 cd fb 19			call break_point_state  
083b				endm  
# End of macro CALLMONITOR
083b				endif 
083b			 
083b e5				push hl		; save file name pointer 
083c			 
083c cd cd 04			call storage_get_block_0 
083f			 
083f 3a 7d fa			ld a,(store_page)	; get current file id 
0842 3c				inc a 
0843 32 7d fa			ld (store_page),a 
0846				 
0846 32 71 fa			ld (store_tmpid),a			; save id 
0849			 
0849 21 00 00			ld hl, 0 
084c 11 7d fa			ld de, store_page 
084f				if DEBUG_STORESE 
084f					DMARK "SCw" 
084f f5				push af  
0850 3a 64 08			ld a, (.dmark)  
0853 32 6e fe			ld (debug_mark),a  
0856 3a 65 08			ld a, (.dmark+1)  
0859 32 6f fe			ld (debug_mark+1),a  
085c 3a 66 08			ld a, (.dmark+2)  
085f 32 70 fe			ld (debug_mark+2),a  
0862 18 03			jr .pastdmark  
0864 ..			.dmark: db "SCw"  
0867 f1			.pastdmark: pop af  
0868			endm  
# End of macro DMARK
0868					CALLMONITOR 
0868 cd fb 19			call break_point_state  
086b				endm  
# End of macro CALLMONITOR
086b				endif 
086b cd 81 04			call storage_write_block	 ; save update 
086e			 
086e				if DEBUG_STORESE 
086e 11 7d fa				ld de, store_page 
0871					DMARK "SCC" 
0871 f5				push af  
0872 3a 86 08			ld a, (.dmark)  
0875 32 6e fe			ld (debug_mark),a  
0878 3a 87 08			ld a, (.dmark+1)  
087b 32 6f fe			ld (debug_mark+1),a  
087e 3a 88 08			ld a, (.dmark+2)  
0881 32 70 fe			ld (debug_mark+2),a  
0884 18 03			jr .pastdmark  
0886 ..			.dmark: db "SCC"  
0889 f1			.pastdmark: pop af  
088a			endm  
# End of macro DMARK
088a					CALLMONITOR 
088a cd fb 19			call break_point_state  
088d				endm  
# End of macro CALLMONITOR
088d				endif 
088d				;  
088d				 
088d 21 40 00			ld hl, STORE_BLOCK_PHY 
0890 11 00 00			ld de, 0 
0893 cd 4f 07			call storage_findnextid 
0896			 
0896 22 68 fa			ld (store_tmppageid), hl    ; save page to use  
0899			 
0899				; TODO detect 0 = no spare blocks 
0899			 
0899				; hl now contains the free page to use for the file header page 
0899			 
0899				if DEBUG_STORESE 
0899				DMARK "SCF" 
0899 f5				push af  
089a 3a ae 08			ld a, (.dmark)  
089d 32 6e fe			ld (debug_mark),a  
08a0 3a af 08			ld a, (.dmark+1)  
08a3 32 6f fe			ld (debug_mark+1),a  
08a6 3a b0 08			ld a, (.dmark+2)  
08a9 32 70 fe			ld (debug_mark+2),a  
08ac 18 03			jr .pastdmark  
08ae ..			.dmark: db "SCF"  
08b1 f1			.pastdmark: pop af  
08b2			endm  
# End of macro DMARK
08b2					CALLMONITOR 
08b2 cd fb 19			call break_point_state  
08b5				endm  
# End of macro CALLMONITOR
08b5				endif 
08b5			 
08b5 22 68 fa			ld (store_tmppageid), hl 
08b8				 
08b8 3a 71 fa			ld a,(store_tmpid)    ; get file id 
08bb			;	ld a, (store_filecache)			; save to cache 
08bb			 
08bb 32 7d fa			ld (store_page),a    ; set page id 
08be 3e 00			ld a, 0			 ; extent 0 is file header 
08c0 32 7e fa			ld (store_page+1), a   ; set file extent 
08c3			 
08c3 32 7f fa			ld (store_page+2), a   ; extent count for the file 
08c6			 
08c6			;	inc hl 		; init block 0 of file 
08c6			;	inc hl   		; skip file and extent id 
08c6			 ;       ld a, 0 
08c6			;	ld (hl),a 
08c6			;	ld a, (store_filecache+1)  	; save to cache 
08c6			 
08c6			;	inc hl    ; file name 
08c6				 
08c6				 
08c6 11 80 fa			ld de, store_page+3    ; get buffer for term string to use as file name 
08c9				if DEBUG_STORESE 
08c9					DMARK "SCc" 
08c9 f5				push af  
08ca 3a de 08			ld a, (.dmark)  
08cd 32 6e fe			ld (debug_mark),a  
08d0 3a df 08			ld a, (.dmark+1)  
08d3 32 6f fe			ld (debug_mark+1),a  
08d6 3a e0 08			ld a, (.dmark+2)  
08d9 32 70 fe			ld (debug_mark+2),a  
08dc 18 03			jr .pastdmark  
08de ..			.dmark: db "SCc"  
08e1 f1			.pastdmark: pop af  
08e2			endm  
# End of macro DMARK
08e2					CALLMONITOR 
08e2 cd fb 19			call break_point_state  
08e5				endm  
# End of macro CALLMONITOR
08e5				endif 
08e5 e1				pop hl    ; get zero term string 
08e6 e5				push hl 
08e7 3e 00			ld a, 0 
08e9 cd ef 13			call strlent 
08ec 23				inc hl   ; cover zero term 
08ed 06 00			ld b,0 
08ef 4d				ld c,l 
08f0 e1				pop hl 
08f1				;ex de, hl 
08f1				if DEBUG_STORESE 
08f1					DMARK "SCa" 
08f1 f5				push af  
08f2 3a 06 09			ld a, (.dmark)  
08f5 32 6e fe			ld (debug_mark),a  
08f8 3a 07 09			ld a, (.dmark+1)  
08fb 32 6f fe			ld (debug_mark+1),a  
08fe 3a 08 09			ld a, (.dmark+2)  
0901 32 70 fe			ld (debug_mark+2),a  
0904 18 03			jr .pastdmark  
0906 ..			.dmark: db "SCa"  
0909 f1			.pastdmark: pop af  
090a			endm  
# End of macro DMARK
090a					;push af 
090a					;ld a, 'a' 
090a					;ld (debug_mark),a 
090a					;pop af 
090a					CALLMONITOR 
090a cd fb 19			call break_point_state  
090d				endm  
# End of macro CALLMONITOR
090d				endif 
090d ed b0			ldir    ; copy zero term string 
090f				if DEBUG_STORESE 
090f					DMARK "SCA" 
090f f5				push af  
0910 3a 24 09			ld a, (.dmark)  
0913 32 6e fe			ld (debug_mark),a  
0916 3a 25 09			ld a, (.dmark+1)  
0919 32 6f fe			ld (debug_mark+1),a  
091c 3a 26 09			ld a, (.dmark+2)  
091f 32 70 fe			ld (debug_mark+2),a  
0922 18 03			jr .pastdmark  
0924 ..			.dmark: db "SCA"  
0927 f1			.pastdmark: pop af  
0928			endm  
# End of macro DMARK
0928					CALLMONITOR 
0928 cd fb 19			call break_point_state  
092b				endm  
# End of macro CALLMONITOR
092b				endif 
092b			 
092b				; write file header page 
092b			 
092b 2a 68 fa			ld hl,(store_tmppageid) 
092e 11 7d fa			ld de, store_page 
0931				if DEBUG_STORESE 
0931					DMARK "SCb" 
0931 f5				push af  
0932 3a 46 09			ld a, (.dmark)  
0935 32 6e fe			ld (debug_mark),a  
0938 3a 47 09			ld a, (.dmark+1)  
093b 32 6f fe			ld (debug_mark+1),a  
093e 3a 48 09			ld a, (.dmark+2)  
0941 32 70 fe			ld (debug_mark+2),a  
0944 18 03			jr .pastdmark  
0946 ..			.dmark: db "SCb"  
0949 f1			.pastdmark: pop af  
094a			endm  
# End of macro DMARK
094a					;push af 
094a					;ld a, 'b' 
094a					;ld (debug_mark),a 
094a					;pop af 
094a					CALLMONITOR 
094a cd fb 19			call break_point_state  
094d				endm  
# End of macro CALLMONITOR
094d				endif 
094d cd 81 04			call storage_write_block 
0950			 
0950 3a 71 fa			ld a, (store_tmpid) 
0953 6f				ld l, a 
0954 26 00			ld h,0 
0956				if DEBUG_STORESE 
0956					DMARK "SCz" 
0956 f5				push af  
0957 3a 6b 09			ld a, (.dmark)  
095a 32 6e fe			ld (debug_mark),a  
095d 3a 6c 09			ld a, (.dmark+1)  
0960 32 6f fe			ld (debug_mark+1),a  
0963 3a 6d 09			ld a, (.dmark+2)  
0966 32 70 fe			ld (debug_mark+2),a  
0969 18 03			jr .pastdmark  
096b ..			.dmark: db "SCz"  
096e f1			.pastdmark: pop af  
096f			endm  
# End of macro DMARK
096f					CALLMONITOR 
096f cd fb 19			call break_point_state  
0972				endm  
# End of macro CALLMONITOR
0972				endif 
0972 c9				ret 
0973				 
0973			 
0973			 
0973			; 
0973			; Read File 
0973			; 
0973			; h - file id to locate 
0973			; l - extent to locate 
0973			; de - pointer to string to read into 
0973			; 
0973			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0973			 
0973			.sr_fail: 
0973 d1				pop de 
0974 c9				ret 
0975			 
0975			storage_read: 
0975			 
0975			 
0975 d5				push de 
0976			 
0976			; TODO BUG the above push is it popped before the RET Z? 
0976			 
0976			; TODO how to handle multiple part blocks 
0976			 
0976				; locate file extent to read 
0976			 
0976 5c				ld e, h 
0977 55				ld d, l 
0978			 
0978			.srext: 
0978 22 7b fa			ld (store_readptr), hl     ; save the current extent to load 
097b ed 53 79 fa		ld (store_readbuf), de     ; save the current buffer to load in to 
097f			 
097f 21 40 00			ld hl, STORE_BLOCK_PHY 
0982				if DEBUG_STORESE 
0982					DMARK "sre" 
0982 f5				push af  
0983 3a 97 09			ld a, (.dmark)  
0986 32 6e fe			ld (debug_mark),a  
0989 3a 98 09			ld a, (.dmark+1)  
098c 32 6f fe			ld (debug_mark+1),a  
098f 3a 99 09			ld a, (.dmark+2)  
0992 32 70 fe			ld (debug_mark+2),a  
0995 18 03			jr .pastdmark  
0997 ..			.dmark: db "sre"  
099a f1			.pastdmark: pop af  
099b			endm  
# End of macro DMARK
099b					CALLMONITOR 
099b cd fb 19			call break_point_state  
099e				endm  
# End of macro CALLMONITOR
099e				endif 
099e cd 4f 07			call storage_findnextid 
09a1			 
09a1				if DEBUG_STORESE 
09a1					DMARK "srf" 
09a1 f5				push af  
09a2 3a b6 09			ld a, (.dmark)  
09a5 32 6e fe			ld (debug_mark),a  
09a8 3a b7 09			ld a, (.dmark+1)  
09ab 32 6f fe			ld (debug_mark+1),a  
09ae 3a b8 09			ld a, (.dmark+2)  
09b1 32 70 fe			ld (debug_mark+2),a  
09b4 18 03			jr .pastdmark  
09b6 ..			.dmark: db "srf"  
09b9 f1			.pastdmark: pop af  
09ba			endm  
# End of macro DMARK
09ba					CALLMONITOR 
09ba cd fb 19			call break_point_state  
09bd				endm  
# End of macro CALLMONITOR
09bd				endif 
09bd cd af 0f			call ishlzero 
09c0			;	ld a, l 
09c0			;	add h 
09c0			;	cp 0 
09c0 28 b1			jr z,.sr_fail			; block not found so EOF 
09c2			 
09c2				; save current address for use by higher level words etc 
09c2			 
09c2 22 6e fa			ld (store_openaddr),hl 
09c5			 
09c5			 
09c5				; hl contains page number to load 
09c5 d1				pop de   ; get storage 
09c6 ed 53 79 fa		ld (store_readbuf), de     ; current buffer to load in to 
09ca d5				push de 
09cb				if DEBUG_STORESE 
09cb					DMARK "srg" 
09cb f5				push af  
09cc 3a e0 09			ld a, (.dmark)  
09cf 32 6e fe			ld (debug_mark),a  
09d2 3a e1 09			ld a, (.dmark+1)  
09d5 32 6f fe			ld (debug_mark+1),a  
09d8 3a e2 09			ld a, (.dmark+2)  
09db 32 70 fe			ld (debug_mark+2),a  
09de 18 03			jr .pastdmark  
09e0 ..			.dmark: db "srg"  
09e3 f1			.pastdmark: pop af  
09e4			endm  
# End of macro DMARK
09e4					CALLMONITOR 
09e4 cd fb 19			call break_point_state  
09e7				endm  
# End of macro CALLMONITOR
09e7				endif 
09e7 cd 1c 04			call storage_read_block 
09ea			 
09ea				; if this a continuation read??? 
09ea			 
09ea 2a 79 fa			ld hl, (store_readbuf)     ; current buffer to load in to 
09ed			 
09ed 3e 3f			ld a, STORE_BLOCK_PHY-1 
09ef cd 86 0f			call addatohl 
09f2 7e				ld a,(hl) 
09f3 fe 00			cp 0 
09f5 28 02			jr z, .markiscont 
09f7 3e ff			ld a, 255 
09f9			 
09f9			.markiscont: 
09f9 32 70 fa			ld (store_readcont), a 
09fc			 
09fc				if DEBUG_STORESE 
09fc					DMARK "srC" 
09fc f5				push af  
09fd 3a 11 0a			ld a, (.dmark)  
0a00 32 6e fe			ld (debug_mark),a  
0a03 3a 12 0a			ld a, (.dmark+1)  
0a06 32 6f fe			ld (debug_mark+1),a  
0a09 3a 13 0a			ld a, (.dmark+2)  
0a0c 32 70 fe			ld (debug_mark+2),a  
0a0f 18 03			jr .pastdmark  
0a11 ..			.dmark: db "srC"  
0a14 f1			.pastdmark: pop af  
0a15			endm  
# End of macro DMARK
0a15					CALLMONITOR 
0a15 cd fb 19			call break_point_state  
0a18				endm  
# End of macro CALLMONITOR
0a18				endif 
0a18				; only short reads enabled 
0a18			 
0a18 3a 78 fa			ld a, (store_longread) 
0a1b fe 00			cp 0 
0a1d ca ea 0a			jp z, .readdone 
0a20			 
0a20			; TODO if block has no zeros then need to read next block  
0a20			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a20			; check last byte of physical block. 
0a20			; if not zero then the next block needs to be loaded 
0a20			 
0a20			 
0a20 2a 79 fa			ld hl, (store_readbuf)     ; current buffer to load in to 
0a23			 
0a23 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a25 cd 86 0f			call addatohl 
0a28				;dec hl 
0a28 7e				ld a,(hl) 
0a29				if DEBUG_STORESE 
0a29					DMARK "sr?" 
0a29 f5				push af  
0a2a 3a 3e 0a			ld a, (.dmark)  
0a2d 32 6e fe			ld (debug_mark),a  
0a30 3a 3f 0a			ld a, (.dmark+1)  
0a33 32 6f fe			ld (debug_mark+1),a  
0a36 3a 40 0a			ld a, (.dmark+2)  
0a39 32 70 fe			ld (debug_mark+2),a  
0a3c 18 03			jr .pastdmark  
0a3e ..			.dmark: db "sr?"  
0a41 f1			.pastdmark: pop af  
0a42			endm  
# End of macro DMARK
0a42					CALLMONITOR 
0a42 cd fb 19			call break_point_state  
0a45				endm  
# End of macro CALLMONITOR
0a45				endif 
0a45 fe 00			cp 0 
0a47 ca ea 0a			jp z, .readdone 
0a4a			 
0a4a				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a4a			 
0a4a 23				inc hl 
0a4b			 
0a4b 22 79 fa			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a4e			 
0a4e ed 5b 7b fa		ld de, (store_readptr)     ; save the current extent to load 
0a52			 
0a52 eb				ex de, hl 
0a53			 
0a53				; next ext 
0a53			 
0a53 23				inc hl 
0a54 22 7b fa			ld  (store_readptr), hl     ; save the current extent to load 
0a57			 
0a57				if DEBUG_STORESE 
0a57					DMARK "sF2" 
0a57 f5				push af  
0a58 3a 6c 0a			ld a, (.dmark)  
0a5b 32 6e fe			ld (debug_mark),a  
0a5e 3a 6d 0a			ld a, (.dmark+1)  
0a61 32 6f fe			ld (debug_mark+1),a  
0a64 3a 6e 0a			ld a, (.dmark+2)  
0a67 32 70 fe			ld (debug_mark+2),a  
0a6a 18 03			jr .pastdmark  
0a6c ..			.dmark: db "sF2"  
0a6f f1			.pastdmark: pop af  
0a70			endm  
# End of macro DMARK
0a70					CALLMONITOR 
0a70 cd fb 19			call break_point_state  
0a73				endm  
# End of macro CALLMONITOR
0a73				endif 
0a73			 
0a73				; get and load block 
0a73			 
0a73 cd 4f 07			call storage_findnextid 
0a76			 
0a76				if DEBUG_STORESE 
0a76					DMARK "sf2" 
0a76 f5				push af  
0a77 3a 8b 0a			ld a, (.dmark)  
0a7a 32 6e fe			ld (debug_mark),a  
0a7d 3a 8c 0a			ld a, (.dmark+1)  
0a80 32 6f fe			ld (debug_mark+1),a  
0a83 3a 8d 0a			ld a, (.dmark+2)  
0a86 32 70 fe			ld (debug_mark+2),a  
0a89 18 03			jr .pastdmark  
0a8b ..			.dmark: db "sf2"  
0a8e f1			.pastdmark: pop af  
0a8f			endm  
# End of macro DMARK
0a8f					CALLMONITOR 
0a8f cd fb 19			call break_point_state  
0a92				endm  
# End of macro CALLMONITOR
0a92				endif 
0a92 cd af 0f			call ishlzero 
0a95			;	ld a, l 
0a95			;	add h 
0a95			;	cp 0 
0a95 ca 73 09			jp z,.sr_fail			; block not found so EOF 
0a98				 
0a98				; save current address for use by higher level words etc 
0a98			 
0a98 22 6e fa			ld (store_openaddr),hl 
0a9b			 
0a9b cd 1c 04			call storage_read_block 
0a9e			 
0a9e				; on a continuation block, we now have the file id and ext in the middle of the block 
0a9e				; we need to pull everything back  
0a9e			 
0a9e ed 5b 79 fa		ld de, (store_readbuf)     ; current buffer to nudge into 
0aa2 2a 79 fa			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aa5 23				inc hl 
0aa6 23				inc hl     ; skip id and ext 
0aa7 01 40 00			ld bc, STORE_BLOCK_PHY 
0aaa				if DEBUG_STORESE 
0aaa					DMARK "SR<" 
0aaa f5				push af  
0aab 3a bf 0a			ld a, (.dmark)  
0aae 32 6e fe			ld (debug_mark),a  
0ab1 3a c0 0a			ld a, (.dmark+1)  
0ab4 32 6f fe			ld (debug_mark+1),a  
0ab7 3a c1 0a			ld a, (.dmark+2)  
0aba 32 70 fe			ld (debug_mark+2),a  
0abd 18 03			jr .pastdmark  
0abf ..			.dmark: db "SR<"  
0ac2 f1			.pastdmark: pop af  
0ac3			endm  
# End of macro DMARK
0ac3					CALLMONITOR 
0ac3 cd fb 19			call break_point_state  
0ac6				endm  
# End of macro CALLMONITOR
0ac6				endif 
0ac6 ed b0			ldir     ; copy data 
0ac8			 
0ac8				; move the pointer back and pretend we have a full buffer for next recheck 
0ac8			 
0ac8 1b				dec de 
0ac9 1b				dec de 
0aca			 
0aca			; TODO do pop below now short circuit loop????? 
0aca c1				pop bc     ; get rid of spare de on stack 
0acb				if DEBUG_STORESE 
0acb					DMARK "SR>" 
0acb f5				push af  
0acc 3a e0 0a			ld a, (.dmark)  
0acf 32 6e fe			ld (debug_mark),a  
0ad2 3a e1 0a			ld a, (.dmark+1)  
0ad5 32 6f fe			ld (debug_mark+1),a  
0ad8 3a e2 0a			ld a, (.dmark+2)  
0adb 32 70 fe			ld (debug_mark+2),a  
0ade 18 03			jr .pastdmark  
0ae0 ..			.dmark: db "SR>"  
0ae3 f1			.pastdmark: pop af  
0ae4			endm  
# End of macro DMARK
0ae4					CALLMONITOR 
0ae4 cd fb 19			call break_point_state  
0ae7				endm  
# End of macro CALLMONITOR
0ae7				endif 
0ae7 c3 78 09			jp .srext 
0aea			 
0aea			 
0aea			 
0aea			 
0aea			 
0aea			.readdone:		 
0aea e1				pop hl 		 ; return start of data to show as not EOF 
0aeb 23				inc hl   ; past file id 
0aec 23				inc hl   ; past ext 
0aed				if DEBUG_STORESE 
0aed					DMARK "SRe" 
0aed f5				push af  
0aee 3a 02 0b			ld a, (.dmark)  
0af1 32 6e fe			ld (debug_mark),a  
0af4 3a 03 0b			ld a, (.dmark+1)  
0af7 32 6f fe			ld (debug_mark+1),a  
0afa 3a 04 0b			ld a, (.dmark+2)  
0afd 32 70 fe			ld (debug_mark+2),a  
0b00 18 03			jr .pastdmark  
0b02 ..			.dmark: db "SRe"  
0b05 f1			.pastdmark: pop af  
0b06			endm  
# End of macro DMARK
0b06					CALLMONITOR 
0b06 cd fb 19			call break_point_state  
0b09				endm  
# End of macro CALLMONITOR
0b09				endif 
0b09 c9					ret 
0b0a			 
0b0a			 
0b0a			 
0b0a			; 
0b0a			; Append File 
0b0a			; 
0b0a			; hl - file id to locate 
0b0a			; de - pointer to (multi block) string to write 
0b0a			 
0b0a			.sa_notfound: 
0b0a d1				pop de 
0b0b c9				ret 
0b0c			 
0b0c			 
0b0c			storage_append: 
0b0c				; hl -  file id to append to 
0b0c				; de - string to append 
0b0c			 
0b0c d5				push de 
0b0d				 
0b0d				if DEBUG_STORESE 
0b0d					DMARK "AP1" 
0b0d f5				push af  
0b0e 3a 22 0b			ld a, (.dmark)  
0b11 32 6e fe			ld (debug_mark),a  
0b14 3a 23 0b			ld a, (.dmark+1)  
0b17 32 6f fe			ld (debug_mark+1),a  
0b1a 3a 24 0b			ld a, (.dmark+2)  
0b1d 32 70 fe			ld (debug_mark+2),a  
0b20 18 03			jr .pastdmark  
0b22 ..			.dmark: db "AP1"  
0b25 f1			.pastdmark: pop af  
0b26			endm  
# End of macro DMARK
0b26					CALLMONITOR 
0b26 cd fb 19			call break_point_state  
0b29				endm  
# End of macro CALLMONITOR
0b29				endif 
0b29			 
0b29 7d				ld a, l 
0b2a 32 71 fa			ld (store_tmpid), a 
0b2d			 
0b2d				; get file header  
0b2d			 
0b2d 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b2f 3a 71 fa			ld a, (store_tmpid) 
0b32 5f				ld e, a 
0b33			 
0b33 21 40 00				ld hl, STORE_BLOCK_PHY 
0b36 cd 4f 07				call storage_findnextid 
0b39			 
0b39 cd af 0f			call ishlzero 
0b3c 28 cc			jr z, .sa_notfound 
0b3e			 
0b3e 22 68 fa			ld (store_tmppageid), hl 
0b41			 
0b41				; TODO handle file id not found 
0b41			 
0b41				if DEBUG_STORESE 
0b41					DMARK "AP2" 
0b41 f5				push af  
0b42 3a 56 0b			ld a, (.dmark)  
0b45 32 6e fe			ld (debug_mark),a  
0b48 3a 57 0b			ld a, (.dmark+1)  
0b4b 32 6f fe			ld (debug_mark+1),a  
0b4e 3a 58 0b			ld a, (.dmark+2)  
0b51 32 70 fe			ld (debug_mark+2),a  
0b54 18 03			jr .pastdmark  
0b56 ..			.dmark: db "AP2"  
0b59 f1			.pastdmark: pop af  
0b5a			endm  
# End of macro DMARK
0b5a					CALLMONITOR 
0b5a cd fb 19			call break_point_state  
0b5d				endm  
# End of macro CALLMONITOR
0b5d				endif 
0b5d			 
0b5d				; update file extent count 
0b5d			 
0b5d 11 7d fa			ld de, store_page 
0b60			 
0b60 cd 1c 04			call storage_read_block 
0b63			 
0b63				if DEBUG_STORESE 
0b63					DMARK "AP3" 
0b63 f5				push af  
0b64 3a 78 0b			ld a, (.dmark)  
0b67 32 6e fe			ld (debug_mark),a  
0b6a 3a 79 0b			ld a, (.dmark+1)  
0b6d 32 6f fe			ld (debug_mark+1),a  
0b70 3a 7a 0b			ld a, (.dmark+2)  
0b73 32 70 fe			ld (debug_mark+2),a  
0b76 18 03			jr .pastdmark  
0b78 ..			.dmark: db "AP3"  
0b7b f1			.pastdmark: pop af  
0b7c			endm  
# End of macro DMARK
0b7c					CALLMONITOR 
0b7c cd fb 19			call break_point_state  
0b7f				endm  
# End of macro CALLMONITOR
0b7f				endif 
0b7f			;	ld (store_tmppageid), hl 
0b7f			 
0b7f 3a 7f fa			ld a, (store_page+2) 
0b82 3c				inc a 
0b83 32 7f fa			ld (store_page+2), a 
0b86 32 70 fa			ld (store_tmpext), a 
0b89				 
0b89				if DEBUG_STORESE 
0b89					DMARK "AP3" 
0b89 f5				push af  
0b8a 3a 9e 0b			ld a, (.dmark)  
0b8d 32 6e fe			ld (debug_mark),a  
0b90 3a 9f 0b			ld a, (.dmark+1)  
0b93 32 6f fe			ld (debug_mark+1),a  
0b96 3a a0 0b			ld a, (.dmark+2)  
0b99 32 70 fe			ld (debug_mark+2),a  
0b9c 18 03			jr .pastdmark  
0b9e ..			.dmark: db "AP3"  
0ba1 f1			.pastdmark: pop af  
0ba2			endm  
# End of macro DMARK
0ba2					CALLMONITOR 
0ba2 cd fb 19			call break_point_state  
0ba5				endm  
# End of macro CALLMONITOR
0ba5				endif 
0ba5 2a 68 fa			ld hl, (store_tmppageid) 
0ba8 11 7d fa			ld de, store_page 
0bab cd 81 04			call storage_write_block 
0bae			 
0bae				; find free block 
0bae			 
0bae 11 00 00			ld de, 0			 ; file extent to locate 
0bb1			 
0bb1 21 40 00				ld hl, STORE_BLOCK_PHY 
0bb4 cd 4f 07				call storage_findnextid 
0bb7 cd af 0f			call ishlzero 
0bba ca 0a 0b			jp z, .sa_notfound 
0bbd			 
0bbd					; TODO handle no space left 
0bbd					 
0bbd 22 68 fa				ld (store_tmppageid), hl 
0bc0			 
0bc0				if DEBUG_STORESE 
0bc0					DMARK "AP4" 
0bc0 f5				push af  
0bc1 3a d5 0b			ld a, (.dmark)  
0bc4 32 6e fe			ld (debug_mark),a  
0bc7 3a d6 0b			ld a, (.dmark+1)  
0bca 32 6f fe			ld (debug_mark+1),a  
0bcd 3a d7 0b			ld a, (.dmark+2)  
0bd0 32 70 fe			ld (debug_mark+2),a  
0bd3 18 03			jr .pastdmark  
0bd5 ..			.dmark: db "AP4"  
0bd8 f1			.pastdmark: pop af  
0bd9			endm  
# End of macro DMARK
0bd9					CALLMONITOR 
0bd9 cd fb 19			call break_point_state  
0bdc				endm  
# End of macro CALLMONITOR
0bdc				endif 
0bdc					; init the buffer with zeros so we can id if the buffer is full or not 
0bdc			 
0bdc e5					push hl 
0bdd c5					push bc 
0bde			 
0bde 21 7d fa				ld hl, store_page 
0be1 06 40				ld b, STORE_BLOCK_PHY 
0be3 3e 00				ld a, 0 
0be5 77			.zeroblock:	ld (hl), a 
0be6 23					inc hl 
0be7 10 fc				djnz .zeroblock 
0be9			 
0be9 c1					pop bc 
0bea e1					pop hl 
0beb			 
0beb					; construct block 
0beb			 
0beb 3a 71 fa				ld a, (store_tmpid) 
0bee 32 7d fa				ld (store_page), a   ; file id 
0bf1 3a 70 fa				ld a, (store_tmpext)   ; extent for this block 
0bf4 32 7e fa				ld (store_page+1), a 
0bf7			 
0bf7 e1					pop hl    ; get string to write 
0bf8 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0bfa 11 7f fa				ld de, store_page+2 
0bfd			 
0bfd				if DEBUG_STORESE 
0bfd					DMARK "AP5" 
0bfd f5				push af  
0bfe 3a 12 0c			ld a, (.dmark)  
0c01 32 6e fe			ld (debug_mark),a  
0c04 3a 13 0c			ld a, (.dmark+1)  
0c07 32 6f fe			ld (debug_mark+1),a  
0c0a 3a 14 0c			ld a, (.dmark+2)  
0c0d 32 70 fe			ld (debug_mark+2),a  
0c10 18 03			jr .pastdmark  
0c12 ..			.dmark: db "AP5"  
0c15 f1			.pastdmark: pop af  
0c16			endm  
# End of macro DMARK
0c16					CALLMONITOR 
0c16 cd fb 19			call break_point_state  
0c19				endm  
# End of macro CALLMONITOR
0c19				endif 
0c19			 
0c19			 
0c19			 
0c19					; fill buffer with data until end of string or full block 
0c19			 
0c19 7e			.appd:		ld a, (hl) 
0c1a 12					ld (de), a 
0c1b fe 00				cp 0 
0c1d 28 04				jr z, .appdone 
0c1f 23					inc hl 
0c20 13					inc de 
0c21 10 f6				djnz .appd 
0c23			 
0c23 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c24 f5					push af   		; save last byte dumped 
0c25			 
0c25			 
0c25 2a 68 fa			ld hl, (store_tmppageid) 
0c28 11 7d fa			ld de, store_page 
0c2b				if DEBUG_STORESE 
0c2b					DMARK "AP6" 
0c2b f5				push af  
0c2c 3a 40 0c			ld a, (.dmark)  
0c2f 32 6e fe			ld (debug_mark),a  
0c32 3a 41 0c			ld a, (.dmark+1)  
0c35 32 6f fe			ld (debug_mark+1),a  
0c38 3a 42 0c			ld a, (.dmark+2)  
0c3b 32 70 fe			ld (debug_mark+2),a  
0c3e 18 03			jr .pastdmark  
0c40 ..			.dmark: db "AP6"  
0c43 f1			.pastdmark: pop af  
0c44			endm  
# End of macro DMARK
0c44					CALLMONITOR 
0c44 cd fb 19			call break_point_state  
0c47				endm  
# End of macro CALLMONITOR
0c47				endif 
0c47 cd 81 04				call storage_write_block 
0c4a			 
0c4a			 
0c4a				; was that a full block of data written? 
0c4a				; any more to write out? 
0c4a			 
0c4a				; if yes then set vars and jump to start of function again 
0c4a			 
0c4a f1					pop af 
0c4b d1					pop de 
0c4c			 
0c4c fe 00				cp 0		 ; no, string was fully written 
0c4e c8					ret z 
0c4f			 
0c4f					; setup vars for next cycle 
0c4f			 
0c4f 3a 71 fa				ld a, (store_tmpid) 
0c52 6f					ld l, a 
0c53 26 00				ld h, 0 
0c55			 
0c55 c3 0c 0b			 	jp storage_append	 ; yes, need to write out some more 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			if DEBUG_STORECF 
0c58			storageput:	 
0c58					ret 
0c58			storageread: 
0c58					ld hl, store_page 
0c58					ld b, 200 
0c58					ld a,0 
0c58			.src:		ld (hl),a 
0c58					inc hl 
0c58					djnz .src 
0c58					 
0c58			 
0c58					ld de, 0 
0c58					ld bc, 1 
0c58					ld hl, store_page 
0c58					call cfRead 
0c58			 
0c58				call cfGetError 
0c58				ld hl,scratch 
0c58				call hexout 
0c58				ld hl, scratch+2 
0c58				ld a, 0 
0c58				ld (hl),a 
0c58				ld de, scratch 
0c58				ld a,display_row_1 
0c58				call str_at_display 
0c58				call update_display 
0c58			 
0c58					ld hl, store_page 
0c58					ld (os_cur_ptr),hl 
0c58			 
0c58					ret 
0c58			endif 
0c58			 
0c58			 
0c58			; Clear out the main buffer store (used to remove junk before writing a new block) 
0c58			 
0c58			storage_clear_page: 
0c58 e5				push hl 
0c59 d5				push de 
0c5a c5				push bc 
0c5b 21 7d fa			ld hl, store_page 
0c5e 3e 00			ld a, 0 
0c60 77				ld (hl), a 
0c61			 
0c61 11 7e fa			ld de, store_page+1 
0c64 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0c67			 
0c67 ed b0			ldir 
0c69				 
0c69 c1				pop bc 
0c6a d1				pop de 
0c6b e1				pop hl 
0c6c c9				ret 
0c6d			 
0c6d			; eof 
# End of file firmware_storage.asm
0c6d			  
0c6d			; support routines for above hardware abstraction layer  
0c6d			  
0c6d			include "firmware_general.asm"        ; general support functions  
0c6d			 
0c6d			; word look up 
0c6d			 
0c6d			; in 
0c6d			; a is the index 
0c6d			; hl is pointer start of array 
0c6d			; 
0c6d			; returns 
0c6d			; hl to the word 
0c6d			; 
0c6d			 
0c6d			table_lookup:  
0c6d d5					push de 
0c6e eb					ex de, hl 
0c6f			 
0c6f 6f					ld l, a 
0c70 26 00				ld h, 0 
0c72 29					add hl, hl 
0c73 19					add hl, de 
0c74 7e					ld a, (hl) 
0c75 23					inc hl 
0c76 66					ld h,(hl) 
0c77 6f					ld l, a 
0c78			 
0c78 d1					pop de 
0c79 c9					ret 
0c7a			 
0c7a			; Delay loops 
0c7a			 
0c7a			 
0c7a			 
0c7a			aDelayInMS: 
0c7a c5				push bc 
0c7b 47				ld b,a 
0c7c			msdelay: 
0c7c c5				push bc 
0c7d				 
0c7d			 
0c7d 01 41 00			ld bc,041h 
0c80 cd 98 0c			call delayloop 
0c83 c1				pop bc 
0c84 05				dec b 
0c85 20 f5			jr nz,msdelay 
0c87			 
0c87			;if CPU_CLOCK_8MHZ 
0c87			;msdelay8: 
0c87			;	push bc 
0c87			;	 
0c87			; 
0c87			;	ld bc,041h 
0c87			;	call delayloop 
0c87			;	pop bc 
0c87			;	dec b 
0c87			;	jr nz,msdelay8 
0c87			;endif 
0c87			 
0c87			 
0c87 c1				pop bc 
0c88 c9				ret 
0c89			 
0c89			 
0c89			delay250ms: 
0c89				;push de 
0c89 01 00 40			ld bc, 04000h 
0c8c c3 98 0c			jp delayloop 
0c8f			delay500ms: 
0c8f				;push de 
0c8f 01 00 80			ld bc, 08000h 
0c92 c3 98 0c			jp delayloop 
0c95			delay1s: 
0c95				;push bc 
0c95			   ; Clobbers A, d and e 
0c95 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0c98			delayloop: 
0c98 c5			    push bc 
0c99			 
0c99			if BASE_CPM 
0c99				ld bc, CPM_DELAY_TUNE 
0c99			.cpmloop: 
0c99				push bc 
0c99			 
0c99			endif 
0c99			 
0c99			 
0c99			 
0c99			delayloopi: 
0c99			;	push bc 
0c99			;.dl: 
0c99 cb 47		    bit     0,a    	; 8 
0c9b cb 47		    bit     0,a    	; 8 
0c9d cb 47		    bit     0,a    	; 8 
0c9f e6 ff		    and     255  	; 7 
0ca1 0b			    dec     bc      	; 6 
0ca2 79			    ld      a,c     	; 4 
0ca3 b0			    or      b     	; 4 
0ca4 c2 99 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0ca7			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0ca7				;pop de 
0ca7			;pop bc 
0ca7			 
0ca7			if BASE_CPM 
0ca7				pop bc 
0ca7				 
0ca7			    dec     bc      	; 6 
0ca7			    ld      a,c     	; 4 
0ca7			    or      b     	; 4 
0ca7			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0ca7				 
0ca7			 
0ca7			endif 
0ca7			;if CPU_CLOCK_8MHZ 
0ca7			;    pop bc 
0ca7			;    push bc 
0ca7			;.dl8: 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    and     255  	; 7 
0ca7			;    dec     bc      	; 6 
0ca7			;    ld      a,c     	; 4 
0ca7			;    or      b     	; 4 
0ca7			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca7			;endif 
0ca7			 
0ca7			;if CPU_CLOCK_10MHZ 
0ca7			;    pop bc 
0ca7			;    push bc 
0ca7			;.dl8: 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    and     255  	; 7 
0ca7			;    dec     bc      	; 6 
0ca7			;    ld      a,c     	; 4 
0ca7			;    or      b     	; 4 
0ca7			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca7			;endif 
0ca7 c1			    pop bc 
0ca8			 
0ca8 c9				ret 
0ca9			 
0ca9			 
0ca9			 
0ca9			; eof 
# End of file firmware_general.asm
0ca9			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0ca9			; display routines that use the physical hardware abstraction layer 
0ca9			 
0ca9			 
0ca9			; Display an activity indicator 
0ca9			; Each call returns the new char pointed to in hl 
0ca9			 
0ca9			active: 
0ca9 3a c9 fb			ld a, (display_active) 
0cac fe 06			cp 6 
0cae			 
0cae 20 02			jr nz, .sne 
0cb0				; gone past the last one reset sequence 
0cb0 3e ff			ld a, 255 
0cb2			 
0cb2			.sne:   
0cb2				; get the next char in seq 
0cb2 3c				inc a 
0cb3 32 c9 fb			ld (display_active), a 
0cb6			 
0cb6				; look up the string in the table 
0cb6 21 cd 0c			ld hl, actseq 
0cb9 cb 27			sla a 
0cbb cd 86 0f			call addatohl 
0cbe cd 22 24			call loadwordinhl 
0cc1			 
0cc1				; forth will write the to string when pushing so move from rom to ram 
0cc1			 
0cc1 11 ca fb			ld de, display_active+1 
0cc4 01 02 00			ld bc, 2 
0cc7 ed b0			ldir 
0cc9			 
0cc9 21 ca fb			ld hl, display_active+1 
0ccc c9				ret 
0ccd				 
0ccd				 
0ccd			 
0ccd			 
0ccd			;db "|/-\|-\" 
0ccd			 
0ccd			actseq: 
0ccd			 
0ccd db 0c		dw spin0 
0ccf dd 0c		dw spin1 
0cd1 df 0c		dw spin2 
0cd3 e1 0c		dw spin3 
0cd5 df 0c		dw spin2 
0cd7 dd 0c		dw spin1 
0cd9 db 0c		dw spin0 
0cdb			 
0cdb .. 00		spin0: db " ", 0 
0cdd .. 00		spin1: db "-", 0 
0cdf .. 00		spin2: db "+", 0 
0ce1 .. 00		spin3: db "#", 0 
0ce3			 
0ce3			 
0ce3			; information window 
0ce3			 
0ce3			; pass hl with 1st string to display 
0ce3			; pass de with 2nd string to display 
0ce3			 
0ce3			info_panel: 
0ce3 e5				push hl 
0ce4			 
0ce4 2a cf fb			ld hl, (display_fb_active) 
0ce7 e5				push hl    ; future de destination 
0ce8 21 b4 fd				ld hl, display_fb0 
0ceb 22 cf fb				ld (display_fb_active), hl 
0cee			 
0cee			;	call clear_display 
0cee			 
0cee				if BASE_CPM 
0cee				ld a, '.' 
0cee				else 
0cee 3e a5			ld a, 165 
0cf0				endif 
0cf0 cd 57 0d			call fill_display 
0cf3			 
0cf3			 
0cf3 3e 55			ld a, display_row_3 + 5 
0cf5 cd 65 0d			call str_at_display 
0cf8			 
0cf8 e1				pop hl 
0cf9 d1				pop de 
0cfa			 
0cfa e5				push hl 
0cfb			 
0cfb			 
0cfb 3e 2d			ld a, display_row_2 + 5 
0cfd cd 65 0d			call str_at_display 
0d00			 
0d00			 
0d00 cd 75 0d			call update_display 
0d03 cd 6b 20			call next_page_prompt 
0d06 cd 52 0d			call clear_display 
0d09			 
0d09				 
0d09 21 13 fd				ld hl, display_fb1 
0d0c 22 cf fb				ld (display_fb_active), hl 
0d0f cd 75 0d			call update_display 
0d12			 
0d12 e1				pop hl 
0d13			 
0d13 c9				ret 
0d14			 
0d14			 
0d14			 
0d14			 
0d14			; TODO windowing? 
0d14			 
0d14			; TODO scroll line up 
0d14			 
0d14			scroll_up: 
0d14			 
0d14 e5				push hl 
0d15 d5				push de 
0d16 c5				push bc 
0d17			 
0d17				; get frame buffer  
0d17			 
0d17 2a cf fb			ld hl, (display_fb_active) 
0d1a e5				push hl    ; future de destination 
0d1b			 
0d1b 11 28 00			ld  de, display_cols 
0d1e 19				add hl, de 
0d1f			 
0d1f d1				pop de 
0d20			 
0d20				;ex de, hl 
0d20 01 9f 00			ld bc, display_fb_len -1  
0d23			;if DEBUG_FORTH_WORDS 
0d23			;	DMARK "SCL" 
0d23			;	CALLMONITOR 
0d23			;endif	 
0d23 ed b0			ldir 
0d25			 
0d25				; wipe bottom row 
0d25			 
0d25			 
0d25 2a cf fb			ld hl, (display_fb_active) 
0d28 11 a0 00			ld de, display_cols*display_rows 
0d2b 19				add hl, de 
0d2c 06 28			ld b, display_cols 
0d2e 3e 20			ld a, ' ' 
0d30			.scwipe: 
0d30 77				ld (hl), a 
0d31 2b				dec hl 
0d32 10 fc			djnz .scwipe 
0d34			 
0d34				;pop hl 
0d34			 
0d34 c1				pop bc 
0d35 d1				pop de 
0d36 e1				pop hl 
0d37			 
0d37 c9				ret 
0d38			 
0d38			 
0d38			;scroll_upo: 
0d38			;	ld de, display_row_1 
0d38			 ;	ld hl, display_row_2 
0d38			;	ld bc, display_cols 
0d38			;	ldir 
0d38			;	ld de, display_row_2 
0d38			 ;	ld hl, display_row_3 
0d38			;	ld bc, display_cols 
0d38			;	ldir 
0d38			;	ld de, display_row_3 
0d38			 ;	ld hl, display_row_4 
0d38			;	ld bc, display_cols 
0d38			;	ldir 
0d38			 
0d38			; TODO clear row 4 
0d38			 
0d38			;	ret 
0d38			 
0d38				 
0d38			scroll_down: 
0d38			 
0d38 e5				push hl 
0d39 d5				push de 
0d3a c5				push bc 
0d3b			 
0d3b				; get frame buffer  
0d3b			 
0d3b 2a cf fb			ld hl, (display_fb_active) 
0d3e			 
0d3e 11 9f 00			ld de, display_fb_len - 1 
0d41 19				add hl, de 
0d42			 
0d42 e5			push hl    ; future de destination 
0d43			 
0d43 11 28 00			ld  de, display_cols 
0d46 ed 52			sbc hl, de 
0d48			 
0d48			 
0d48 d1				pop de 
0d49			 
0d49			;	ex de, hl 
0d49 01 9f 00			ld bc, display_fb_len -1  
0d4c			 
0d4c			 
0d4c				 
0d4c			 
0d4c ed b0			ldir 
0d4e			 
0d4e				; wipe bottom row 
0d4e			 
0d4e			 
0d4e			;	ld hl, (display_fb_active) 
0d4e			;;	ld de, display_cols*display_rows 
0d4e			;;	add hl, de 
0d4e			;	ld b, display_cols 
0d4e			;	ld a, ' ' 
0d4e			;.scwiped: 
0d4e			;	ld (hl), a 
0d4e			;	dec hl 
0d4e			;	djnz .scwiped 
0d4e			 
0d4e				;pop hl 
0d4e			 
0d4e c1				pop bc 
0d4f d1				pop de 
0d50 e1				pop hl 
0d51			 
0d51 c9				ret 
0d52			;scroll_down: 
0d52			;	ld de, display_row_4 
0d52			;	ld hl, display_row_3 
0d52			;	ld bc, display_cols 
0d52			;	ldir 
0d52			;	ld de, display_row_3 
0d52			; 	ld hl, display_row_2 
0d52			;	ld bc, display_cols 
0d52			;	ldir 
0d52			;	ld de, display_row_2 
0d52			;	ld hl, display_row_1 
0d52			;	ld bc, display_cols 
0d52			;	ldir 
0d52			;;; TODO clear row 1 
0d52			;	ret 
0d52			 
0d52			 
0d52			 
0d52			 
0d52			 
0d52			; clear active frame buffer 
0d52			 
0d52			clear_display: 
0d52 3e 20			ld a, ' ' 
0d54 c3 57 0d			jp fill_display 
0d57			 
0d57			; fill active frame buffer with a char in A 
0d57			 
0d57			fill_display: 
0d57 06 a0			ld b,display_fb_len 
0d59 2a cf fb			ld hl, (display_fb_active) 
0d5c 77			.fd1:	ld (hl),a 
0d5d 23				inc hl 
0d5e 10 fc			djnz .fd1 
0d60 23				inc hl 
0d61 3e 00			ld a,0 
0d63 77				ld (hl),a 
0d64			 
0d64			 
0d64 c9				ret 
0d65			; Write string (DE) at pos (A) to active frame buffer 
0d65			 
0d65 2a cf fb		str_at_display:    ld hl,(display_fb_active) 
0d68 06 00					ld b,0 
0d6a 4f					ld c,a 
0d6b 09					add hl,bc 
0d6c 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0d6d b7			            OR   A              ;Null terminator? 
0d6e c8			            RET  Z              ;Yes, so finished 
0d6f 77					ld (hl),a 
0d70 23				inc hl 
0d71 13			            INC  DE             ;Point to next character 
0d72 18 f8		            JR   .sad1     ;Repeat 
0d74 c9					ret 
0d75			 
0d75			; using current frame buffer write to physical display 
0d75			 
0d75			update_display: 
0d75 e5				push hl 
0d76 2a cf fb			ld hl, (display_fb_active) 
0d79 cd 87 75			call write_display 
0d7c e1				pop hl 
0d7d c9				ret 
0d7e			 
0d7e			; TODO scrolling 
0d7e			 
0d7e			 
0d7e			; move cursor right one char 
0d7e			cursor_right: 
0d7e			 
0d7e				; TODO shift right 
0d7e				; TODO if beyond max col 
0d7e				; TODO       cursor_next_line 
0d7e			 
0d7e c9				ret 
0d7f			 
0d7f			 
0d7f			cursor_next_line: 
0d7f				; TODO first char 
0d7f				; TODO line down 
0d7f				; TODO if past last row 
0d7f				; TODO    scroll up 
0d7f			 
0d7f c9				ret 
0d80			 
0d80			cursor_left: 
0d80				; TODO shift left 
0d80				; TODO if beyond left  
0d80				; TODO     cursor prev line 
0d80				 
0d80 c9				ret 
0d81			 
0d81			cursor_prev_line: 
0d81				; TODO last char 
0d81				; TODO line up 
0d81				; TODO if past first row 
0d81				; TODO   scroll down 
0d81			 
0d81 c9				ret 
0d82			 
0d82			 
0d82			cout: 
0d82				; A - char 
0d82 c9				ret 
0d83			 
0d83			 
0d83			; Display a menu and allow item selection (optional toggle items) 
0d83			; 
0d83			; format: 
0d83			; hl pointer to word array with zero term for items 
0d83			; e.g.    db item1 
0d83			;         db .... 
0d83			;         db 0 
0d83			; 
0d83			; a = starting menu item  
0d83			; 
0d83			; de = pointer item toggle array   (todo) 
0d83			; 
0d83			; returns item selected in a 1-... 
0d83			; returns 0 if back button pressed 
0d83			; 
0d83			; NOTE: Uses system frame buffer to display 
0d83			; 
0d83			; LEFT, Q = go back 
0d83			; RIGHT, SPACE, CR = select 
0d83			; UP, A - Up 
0d83			; DOWN, Z - Down 
0d83			 
0d83			 
0d83			 
0d83			 
0d83			 
0d83			menu: 
0d83			 
0d83					; keep array pointer 
0d83			 
0d83 22 76 fa				ld (store_tmp1), hl 
0d86 32 74 fa				ld (store_tmp2), a 
0d89			 
0d89					; check for key bounce 
0d89			 
0d89			if BASE_KEV 
0d89			 
0d89 cd d2 78		.mbounce:	call cin 
0d8c fe 00				cp 0 
0d8e 20 f9				jr nz, .mbounce 
0d90			endif 
0d90					; for ease use ex 
0d90			 
0d90					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0d90 21 b4 fd				ld hl, display_fb0 
0d93 22 cf fb				ld (display_fb_active), hl 
0d96			 
0d96 cd 52 0d		.mloop:		call clear_display 
0d99 cd 75 0d				call update_display 
0d9c			 
0d9c					; draw selection id '>' at 1 
0d9c			 
0d9c					; init start of list display 
0d9c			 
0d9c 3e 05				ld a, 5 
0d9e 32 72 fa				ld (store_tmp3), a   ; display row count 
0da1 3a 74 fa				ld a,( store_tmp2) 
0da4 32 75 fa				ld (store_tmp2+1), a   ; display item count 
0da7			 
0da7					 
0da7			.mitem:	 
0da7			 
0da7			 
0da7 3a 75 fa				ld a,(store_tmp2+1) 
0daa 6f					ld l, a 
0dab 26 00				ld h, 0 
0dad 29					add hl, hl 
0dae ed 5b 76 fa			ld de, (store_tmp1) 
0db2 19					add hl, de 
0db3 7e					ld a, (hl) 
0db4 23					inc hl 
0db5 66					ld h,(hl) 
0db6 6f					ld l, a 
0db7			 
0db7 cd af 0f				call ishlzero 
0dba 28 1a				jr z, .mdone 
0dbc			 
0dbc eb					ex de, hl 
0dbd 3a 72 fa				ld a, (store_tmp3) 
0dc0 cd 65 0d				call str_at_display 
0dc3					 
0dc3			 
0dc3					; next item 
0dc3 3a 75 fa				ld a, (store_tmp2+1) 
0dc6 3c					inc a 
0dc7 32 75 fa				ld (store_tmp2+1), a   ; display item count 
0dca			 
0dca			 		; next row 
0dca			 
0dca 3a 72 fa				ld a, (store_tmp3) 
0dcd c6 28				add display_cols 
0dcf 32 72 fa				ld (store_tmp3), a 
0dd2			 
0dd2					; at end of screen? 
0dd2			 
0dd2 fe 10				cp display_rows*4 
0dd4 20 d1				jr nz, .mitem 
0dd6			 
0dd6			 
0dd6			.mdone: 
0dd6 cd af 0f				call ishlzero 
0dd9 28 08				jr z, .nodn 
0ddb			 
0ddb 3e 78				ld a, display_row_4 
0ddd 11 5c 0e				ld de, .mdown 
0de0 cd 65 0d				call str_at_display 
0de3			 
0de3					; draw options to fill the screens with active item on line 1 
0de3					; if current option is 2 or more then display ^ in top 
0de3			 
0de3 3a 74 fa		.nodn:		ld a, (store_tmp2) 
0de6 fe 00				cp 0 
0de8 28 08				jr z, .noup 
0dea			 
0dea 3e 00				ld a, 0 
0dec 11 5a 0e				ld de, .mup 
0def cd 65 0d				call str_at_display 
0df2			 
0df2 3e 02		.noup:		ld a, 2 
0df4 11 58 0e				ld de, .msel 
0df7 cd 65 0d				call str_at_display 
0dfa			 
0dfa					; if current option + 1 is not null then display V in bottom 
0dfa					; get key 
0dfa cd 75 0d				call update_display 
0dfd			 
0dfd			 
0dfd					; handle key 
0dfd			 
0dfd cd c1 78				call cin_wait 
0e00			 
0e00 fe 05				cp KEY_UP 
0e02 28 2b				jr z, .mgoup 
0e04 fe 61				cp 'a' 
0e06 28 27				jr z, .mgoup 
0e08 fe 0a				cp KEY_DOWN 
0e0a 28 32				jr z, .mgod 
0e0c fe 7a				cp 'z' 
0e0e 28 2e				jr z, .mgod 
0e10 fe 20				cp ' ' 
0e12 28 34				jr z, .goend 
0e14 fe 0c				cp KEY_RIGHT 
0e16 28 30				jr z, .goend 
0e18 fe 0d				cp KEY_CR 
0e1a 28 2c				jr z, .goend 
0e1c fe 71				cp 'q' 
0e1e 28 0b				jr z, .goback 
0e20			 
0e20 fe 0b				cp KEY_LEFT 
0e22 28 07				jr z, .goback 
0e24 fe 08				cp KEY_BS 
0e26 28 03				jr z, .goback 
0e28 c3 96 0d				jp .mloop 
0e2b			 
0e2b			.goback: 
0e2b 3e 00			ld a, 0 
0e2d 18 1d			jr .goend2 
0e2f			 
0e2f				; move up one 
0e2f			.mgoup: 
0e2f 3a 74 fa				ld a, (store_tmp2) 
0e32 fe 00				cp 0 
0e34 ca 96 0d				jp z, .mloop 
0e37 3d					dec a 
0e38 32 74 fa				ld (store_tmp2), a 
0e3b c3 96 0d				jp .mloop 
0e3e			 
0e3e				; move down one 
0e3e			.mgod: 
0e3e 3a 74 fa				ld a, (store_tmp2) 
0e41 3c					inc a 
0e42 32 74 fa				ld (store_tmp2), a 
0e45 c3 96 0d				jp .mloop 
0e48			 
0e48			 
0e48			.goend: 
0e48					; get selected item number 
0e48			 
0e48 3a 74 fa				ld a, (store_tmp2) 
0e4b 3c					inc a 
0e4c			 
0e4c			.goend2: 
0e4c f5					push af 
0e4d			 
0e4d					; restore active fb 
0e4d					; TODO BUG assumes fb1 
0e4d			 
0e4d 21 13 fd				ld hl, display_fb1 
0e50 22 cf fb				ld (display_fb_active), hl 
0e53			 
0e53					; restore main regs 
0e53			 
0e53			 
0e53 cd 75 0d				call update_display 
0e56			 
0e56 f1					pop af 
0e57			 
0e57 c9				ret 
0e58			 
0e58 .. 00		.msel:   db ">",0 
0e5a .. 00		.mup:   db "^",0 
0e5c .. 00		.mdown:   db "v",0 
0e5e			 
0e5e			 
0e5e			; eof 
0e5e			 
# End of file firmware_display.asm
0e5e			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0e5e			; random number generators 
0e5e			 
0e5e			 
0e5e			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0e5e			 
0e5e			 
0e5e			;-----> Generate a random number 
0e5e			; output a=answer 0<=a<=255 
0e5e			; all registers are preserved except: af 
0e5e			random: 
0e5e e5			        push    hl 
0e5f d5			        push    de 
0e60 2a ae fb		        ld      hl,(randData) 
0e63 ed 5f		        ld      a,r 
0e65 57			        ld      d,a 
0e66 5e			        ld      e,(hl) 
0e67 19			        add     hl,de 
0e68 85			        add     a,l 
0e69 ac			        xor     h 
0e6a 22 ae fb		        ld      (randData),hl 
0e6d d1			        pop     de 
0e6e e1			        pop     hl 
0e6f c9			        ret 
0e70			 
0e70			 
0e70			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0e70			 
0e70			 
0e70			 
0e70			;------LFSR------ 
0e70			;James Montelongo 
0e70			;optimized by Spencer Putt 
0e70			;out: 
0e70			; a = 8 bit random number 
0e70			RandLFSR: 
0e70 21 b4 fb		        ld hl,LFSRSeed+4 
0e73 5e			        ld e,(hl) 
0e74 23			        inc hl 
0e75 56			        ld d,(hl) 
0e76 23			        inc hl 
0e77 4e			        ld c,(hl) 
0e78 23			        inc hl 
0e79 7e			        ld a,(hl) 
0e7a 47			        ld b,a 
0e7b cb 13		        rl e  
0e7d cb 12			rl d 
0e7f cb 11		        rl c  
0e81 17				rla 
0e82 cb 13		        rl e  
0e84 cb 12			rl d 
0e86 cb 11		        rl c  
0e88 17				rla 
0e89 cb 13		        rl e  
0e8b cb 12			rl d 
0e8d cb 11		        rl c  
0e8f 17				rla 
0e90 67			        ld h,a 
0e91 cb 13		        rl e  
0e93 cb 12			rl d 
0e95 cb 11		        rl c  
0e97 17				rla 
0e98 a8			        xor b 
0e99 cb 13		        rl e  
0e9b cb 12			rl d 
0e9d ac			        xor h 
0e9e a9			        xor c 
0e9f aa			        xor d 
0ea0 21 b6 fb		        ld hl,LFSRSeed+6 
0ea3 11 b7 fb		        ld de,LFSRSeed+7 
0ea6 01 07 00		        ld bc,7 
0ea9 ed b8		        lddr 
0eab 12			        ld (de),a 
0eac c9			        ret 
0ead			 
0ead			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ead			 
0ead			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ead			 
0ead			 
0ead			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ead			 
0ead			prng16: 
0ead			;Inputs: 
0ead			;   (seed1) contains a 16-bit seed value 
0ead			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ead			;Outputs: 
0ead			;   HL is the result 
0ead			;   BC is the result of the LCG, so not that great of quality 
0ead			;   DE is preserved 
0ead			;Destroys: 
0ead			;   AF 
0ead			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ead			;160cc 
0ead			;26 bytes 
0ead 2a a8 fb		    ld hl,(seed1) 
0eb0 44			    ld b,h 
0eb1 4d			    ld c,l 
0eb2 29			    add hl,hl 
0eb3 29			    add hl,hl 
0eb4 2c			    inc l 
0eb5 09			    add hl,bc 
0eb6 22 a8 fb		    ld (seed1),hl 
0eb9 2a a6 fb		    ld hl,(seed2) 
0ebc 29			    add hl,hl 
0ebd 9f			    sbc a,a 
0ebe e6 2d		    and %00101101 
0ec0 ad			    xor l 
0ec1 6f			    ld l,a 
0ec2 22 a6 fb		    ld (seed2),hl 
0ec5 09			    add hl,bc 
0ec6 c9			    ret 
0ec7			 
0ec7			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0ec7			 
0ec7			rand32: 
0ec7			;Inputs: 
0ec7			;   (seed1_0) holds the lower 16 bits of the first seed 
0ec7			;   (seed1_1) holds the upper 16 bits of the first seed 
0ec7			;   (seed2_0) holds the lower 16 bits of the second seed 
0ec7			;   (seed2_1) holds the upper 16 bits of the second seed 
0ec7			;   **NOTE: seed2 must be non-zero 
0ec7			;Outputs: 
0ec7			;   HL is the result 
0ec7			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0ec7			;Destroys: 
0ec7			;   AF 
0ec7			;Tested and passes all CAcert tests 
0ec7			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0ec7			;it has a period of 18,446,744,069,414,584,320 
0ec7			;roughly 18.4 quintillion. 
0ec7			;LFSR taps: 0,2,6,7  = 11000101 
0ec7			;291cc 
0ec7			;seed1_0=$+1 
0ec7			;    ld hl,12345 
0ec7			;seed1_1=$+1 
0ec7			;    ld de,6789 
0ec7			;    ld b,h 
0ec7			;    ld c,l 
0ec7			;    add hl,hl \ rl e \ rl d 
0ec7			;    add hl,hl \ rl e \ rl d 
0ec7			;    inc l 
0ec7			;    add hl,bc 
0ec7			;    ld (seed1_0),hl 
0ec7			;    ld hl,(seed1_1) 
0ec7			;    adc hl,de 
0ec7			;    ld (seed1_1),hl 
0ec7			;    ex de,hl 
0ec7			;seed2_0=$+1 
0ec7			;    ld hl,9876 
0ec7			;seed2_1=$+1 
0ec7			;    ld bc,54321 
0ec7			;    add hl,hl \ rl c \ rl b 
0ec7			;    ld (seed2_1),bc 
0ec7			;    sbc a,a 
0ec7			;    and %11000101 
0ec7			;    xor l 
0ec7			;    ld l,a 
0ec7			;    ld (seed2_0),hl 
0ec7			;    ex de,hl 
0ec7			;    add hl,bc 
0ec7			;    ret 
0ec7			; 
0ec7			 
0ec7			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0ec7			; 20 bytes, 86 cycles (excluding ret) 
0ec7			 
0ec7			; returns   hl = pseudorandom number 
0ec7			; corrupts   a 
0ec7			 
0ec7			; generates 16-bit pseudorandom numbers with a period of 65535 
0ec7			; using the xorshift method: 
0ec7			 
0ec7			; hl ^= hl << 7 
0ec7			; hl ^= hl >> 9 
0ec7			; hl ^= hl << 8 
0ec7			 
0ec7			; some alternative shift triplets which also perform well are: 
0ec7			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0ec7			 
0ec7			;  org 32768 
0ec7			 
0ec7			xrnd: 
0ec7 2a ac fb		  ld hl,(xrandc)       ; seed must not be 0 
0eca 3e 00		  ld a,0 
0ecc bd			  cp l 
0ecd 20 02		  jr nz, .xrnd1 
0ecf 2e 01		  ld l, 1 
0ed1			.xrnd1: 
0ed1			 
0ed1 7c			  ld a,h 
0ed2 1f			  rra 
0ed3 7d			  ld a,l 
0ed4 1f			  rra 
0ed5 ac			  xor h 
0ed6 67			  ld h,a 
0ed7 7d			  ld a,l 
0ed8 1f			  rra 
0ed9 7c			  ld a,h 
0eda 1f			  rra 
0edb ad			  xor l 
0edc 6f			  ld l,a 
0edd ac			  xor h 
0ede 67			  ld h,a 
0edf			 
0edf 22 ac fb		  ld (xrandc),hl 
0ee2			 
0ee2 c9			  ret 
0ee3			;  
0ee3			 
0ee3			 
0ee3			;;;; int maths 
0ee3			 
0ee3			; https://map.grauw.nl/articles/mult_div_shifts.php 
0ee3			; Divide 16-bit values (with 16-bit result) 
0ee3			; In: Divide BC by divider DE 
0ee3			; Out: BC = result, HL = rest 
0ee3			; 
0ee3			Div16: 
0ee3 21 00 00		    ld hl,0 
0ee6 78			    ld a,b 
0ee7 06 08		    ld b,8 
0ee9			Div16_Loop1: 
0ee9 17			    rla 
0eea ed 6a		    adc hl,hl 
0eec ed 52		    sbc hl,de 
0eee 30 01		    jr nc,Div16_NoAdd1 
0ef0 19			    add hl,de 
0ef1			Div16_NoAdd1: 
0ef1 10 f6		    djnz Div16_Loop1 
0ef3 17			    rla 
0ef4 2f			    cpl 
0ef5 47			    ld b,a 
0ef6 79			    ld a,c 
0ef7 48			    ld c,b 
0ef8 06 08		    ld b,8 
0efa			Div16_Loop2: 
0efa 17			    rla 
0efb ed 6a		    adc hl,hl 
0efd ed 52		    sbc hl,de 
0eff 30 01		    jr nc,Div16_NoAdd2 
0f01 19			    add hl,de 
0f02			Div16_NoAdd2: 
0f02 10 f6		    djnz Div16_Loop2 
0f04 17			    rla 
0f05 2f			    cpl 
0f06 41			    ld b,c 
0f07 4f			    ld c,a 
0f08 c9			ret 
0f09			 
0f09			 
0f09			;http://z80-heaven.wikidot.com/math 
0f09			; 
0f09			;Inputs: 
0f09			;     DE and A are factors 
0f09			;Outputs: 
0f09			;     A is not changed 
0f09			;     B is 0 
0f09			;     C is not changed 
0f09			;     DE is not changed 
0f09			;     HL is the product 
0f09			;Time: 
0f09			;     342+6x 
0f09			; 
0f09			Mult16: 
0f09			 
0f09 06 08		     ld b,8          ;7           7 
0f0b 21 00 00		     ld hl,0         ;10         10 
0f0e 29			       add hl,hl     ;11*8       88 
0f0f 07			       rlca          ;4*8        32 
0f10 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f12 19			         add hl,de   ;--         -- 
0f13 10 f9		       djnz $-5      ;13*7+8     99 
0f15 c9			ret 
0f16			 
0f16			; 
0f16			; Square root of 16-bit value 
0f16			; In:  HL = value 
0f16			; Out:  D = result (rounded down) 
0f16			; 
0f16			;Sqr16: 
0f16			;    ld de,#0040 
0f16			;    ld a,l 
0f16			;    ld l,h 
0f16			;    ld h,d 
0f16			;    or a 
0f16			;    ld b,8 
0f16			;Sqr16_Loop: 
0f16			;    sbc hl,de 
0f16			;    jr nc,Sqr16_Skip 
0f16			;    add hl,de 
0f16			;Sqr16_Skip: 
0f16			;    ccf 
0f16			;    rl d 
0f16			;    add a,a 
0f16			;    adc hl,hl 
0f16			;    add a,a 
0f16			;    adc hl,hl 
0f16			;    djnz Sqr16_Loop 
0f16			;    ret 
0f16			; 
0f16			; 
0f16			; Divide 8-bit values 
0f16			; In: Divide E by divider C 
0f16			; Out: A = result, B = rest 
0f16			; 
0f16			Div8: 
0f16 af			    xor a 
0f17 06 08		    ld b,8 
0f19			Div8_Loop: 
0f19 cb 13		    rl e 
0f1b 17			    rla 
0f1c 91			    sub c 
0f1d 30 01		    jr nc,Div8_NoAdd 
0f1f 81			    add a,c 
0f20			Div8_NoAdd: 
0f20 10 f7		    djnz Div8_Loop 
0f22 47			    ld b,a 
0f23 7b			    ld a,e 
0f24 17			    rla 
0f25 2f			    cpl 
0f26 c9			    ret 
0f27			 
0f27			; 
0f27			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f27			; In: Multiply A with DE 
0f27			; Out: HL = result 
0f27			; 
0f27			Mult12U: 
0f27 2e 00		    ld l,0 
0f29 87			    add a,a 
0f2a 30 01		    jr nc,Mult12U_NoAdd0 
0f2c 19			    add hl,de 
0f2d			Mult12U_NoAdd0: 
0f2d 29			    add hl,hl 
0f2e 87			    add a,a 
0f2f 30 01		    jr nc,Mult12U_NoAdd1 
0f31 19			    add hl,de 
0f32			Mult12U_NoAdd1: 
0f32 29			    add hl,hl 
0f33 87			    add a,a 
0f34 30 01		    jr nc,Mult12U_NoAdd2 
0f36 19			    add hl,de 
0f37			Mult12U_NoAdd2: 
0f37 29			    add hl,hl 
0f38 87			    add a,a 
0f39 30 01		    jr nc,Mult12U_NoAdd3 
0f3b 19			    add hl,de 
0f3c			Mult12U_NoAdd3: 
0f3c 29			    add hl,hl 
0f3d 87			    add a,a 
0f3e 30 01		    jr nc,Mult12U_NoAdd4 
0f40 19			    add hl,de 
0f41			Mult12U_NoAdd4: 
0f41 29			    add hl,hl 
0f42 87			    add a,a 
0f43 30 01		    jr nc,Mult12U_NoAdd5 
0f45 19			    add hl,de 
0f46			Mult12U_NoAdd5: 
0f46 29			    add hl,hl 
0f47 87			    add a,a 
0f48 30 01		    jr nc,Mult12U_NoAdd6 
0f4a 19			    add hl,de 
0f4b			Mult12U_NoAdd6: 
0f4b 29			    add hl,hl 
0f4c 87			    add a,a 
0f4d d0			    ret nc 
0f4e 19			    add hl,de 
0f4f c9			    ret 
0f50			 
0f50			; 
0f50			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f50			; In: Multiply A with DE 
0f50			;      Put lowest value in A for most efficient calculation 
0f50			; Out: HL = result 
0f50			; 
0f50			Mult12R: 
0f50 21 00 00		    ld hl,0 
0f53			Mult12R_Loop: 
0f53 cb 3f		    srl a 
0f55 30 01		    jr nc,Mult12R_NoAdd 
0f57 19			    add hl,de 
0f58			Mult12R_NoAdd: 
0f58 cb 23		    sla e 
0f5a cb 12		    rl d 
0f5c b7			    or a 
0f5d c2 53 0f		    jp nz,Mult12R_Loop 
0f60 c9			    ret 
0f61			 
0f61			; 
0f61			; Multiply 16-bit values (with 32-bit result) 
0f61			; In: Multiply BC with DE 
0f61			; Out: BCHL = result 
0f61			; 
0f61			Mult32: 
0f61 79			    ld a,c 
0f62 48			    ld c,b 
0f63 21 00 00		    ld hl,0 
0f66 06 10		    ld b,16 
0f68			Mult32_Loop: 
0f68 29			    add hl,hl 
0f69 17			    rla 
0f6a cb 11		    rl c 
0f6c 30 07		    jr nc,Mult32_NoAdd 
0f6e 19			    add hl,de 
0f6f ce 00		    adc a,0 
0f71 d2 75 0f		    jp nc,Mult32_NoAdd 
0f74 0c			    inc c 
0f75			Mult32_NoAdd: 
0f75 10 f1		    djnz Mult32_Loop 
0f77 41			    ld b,c 
0f78 4f			    ld c,a 
0f79 c9			    ret 
0f7a			 
0f7a			 
0f7a			 
0f7a			; 
0f7a			; Multiply 8-bit values 
0f7a			; In:  Multiply H with E 
0f7a			; Out: HL = result 
0f7a			; 
0f7a			Mult8: 
0f7a 16 00		    ld d,0 
0f7c 6a			    ld l,d 
0f7d 06 08		    ld b,8 
0f7f			Mult8_Loop: 
0f7f 29			    add hl,hl 
0f80 30 01		    jr nc,Mult8_NoAdd 
0f82 19			    add hl,de 
0f83			Mult8_NoAdd: 
0f83 10 fa		    djnz Mult8_Loop 
0f85 c9			    ret 
0f86			 
0f86			 
0f86			 
0f86			 
0f86			 
0f86			 
0f86			 
0f86			 
0f86			;;http://z80-heaven.wikidot.com/math 
0f86			;;This divides DE by BC, storing the result in DE, remainder in HL 
0f86			; 
0f86			;DE_Div_BC:          ;1281-2x, x is at most 16 
0f86			;     ld a,16        ;7 
0f86			;     ld hl,0        ;10 
0f86			;     jp $+5         ;10 
0f86			;.DivLoop: 
0f86			;       add hl,bc    ;-- 
0f86			;       dec a        ;64 
0f86			;       jr z,.DivLoopEnd        ;86 
0f86			; 
0f86			;       sla e        ;128 
0f86			;       rl d         ;128 
0f86			;       adc hl,hl    ;240 
0f86			;       sbc hl,bc    ;240 
0f86			;       jr nc,.DivLoop ;23|21 
0f86			;       inc e        ;-- 
0f86			;       jp .DivLoop+1 
0f86			; 
0f86			;.DivLoopEnd: 
0f86			 
0f86			;HL_Div_C: 
0f86			;Inputs: 
0f86			;     HL is the numerator 
0f86			;     C is the denominator 
0f86			;Outputs: 
0f86			;     A is the remainder 
0f86			;     B is 0 
0f86			;     C is not changed 
0f86			;     DE is not changed 
0f86			;     HL is the quotient 
0f86			; 
0f86			;       ld b,16 
0f86			;       xor a 
0f86			;         add hl,hl 
0f86			;         rla 
0f86			;         cp c 
0f86			;         jr c,$+4 
0f86			;           inc l 
0f86			;           sub c 
0f86			;         djnz $-7 
0f86			 
0f86			; https://plutiedev.com/z80-add-8bit-to-16bit 
0f86			 
0f86			addatohl: 
0f86 85			    add   a, l    ; A = A+L 
0f87 6f			    ld    l, a    ; L = A+L 
0f88 8c			    adc   a, h    ; A = A+L+H+carry 
0f89 95			    sub   l       ; A = H+carry 
0f8a 67			    ld    h, a    ; H = H+carry 
0f8b c9			ret 
0f8c			 
0f8c			addatode: 
0f8c 83			    add   a, e    ; A = A+L 
0f8d 5f			    ld    e, a    ; L = A+L 
0f8e 8a			    adc   a, d    ; A = A+L+H+carry 
0f8f 93			    sub   e       ; A = H+carry 
0f90 57			    ld    d, a    ; H = H+carry 
0f91 c9			ret 
0f92			 
0f92			 
0f92			addatobc: 
0f92 81			    add   a, c    ; A = A+L 
0f93 4f			    ld    c, a    ; L = A+L 
0f94 88			    adc   a, b    ; A = A+L+H+carry 
0f95 91			    sub   c       ; A = H+carry 
0f96 47			    ld    b, a    ; H = H+carry 
0f97 c9			ret 
0f98			 
0f98			subafromhl: 
0f98			   ; If A=0 do nothing 
0f98			    ; Otherwise flip A's sign. Since 
0f98			    ; the upper byte becomes -1, also 
0f98			    ; substract 1 from H. 
0f98 ed 44		    neg 
0f9a ca a3 0f		    jp    z, Skip 
0f9d 25			    dec   h 
0f9e			     
0f9e			    ; Now add the low byte as usual 
0f9e			    ; Two's complement takes care of 
0f9e			    ; ensuring the result is correct 
0f9e 85			    add   a, l 
0f9f 6f			    ld    l, a 
0fa0 8c			    adc   a, h 
0fa1 95			    sub   l 
0fa2 67			    ld    h, a 
0fa3			Skip: 
0fa3 c9				ret 
0fa4			 
0fa4			 
0fa4			; compare hl and de 
0fa4			; returns:  
0fa4			; if hl = de, z=1, s=0, c0=0 
0fa4			; if hl > de, z=0, s=0, c=0 
0fa4			; if hl < de, z=0, s=1, c=1 
0fa4			cmp16:	 
0fa4 b7				or a 
0fa5 ed 52			sbc hl,de 
0fa7 e0				ret po 
0fa8 7c				ld a,h 
0fa9 1f				rra 
0faa ee 40			xor 01000000B 
0fac 37				scf 
0fad 8f				adc a,a 
0fae c9				ret 
0faf			 
0faf			 
0faf			; test if hl contains zero   - A is destroyed 
0faf			 
0faf			ishlzero:    
0faf b7				or a     ; reset flags 
0fb0 7c				ld a, h 
0fb1 b5				or l        	 
0fb2			 
0fb2 c9				ret 
0fb3			 
0fb3			 
0fb3			 
0fb3			 
0fb3			if FORTH_ENABLE_FLOATMATH 
0fb3			;include "float/bbcmath.z80" 
0fb3			include "float/lpfpcalc.asm" 
0fb3			endif 
0fb3			 
0fb3			 
0fb3			; eof 
0fb3			 
# End of file firmware_maths.asm
0fb3			include "firmware_strings.asm"   ; string handling  
0fb3			 
0fb3			 
0fb3			; TODO string len 
0fb3			; input text string, end on cr with zero term 
0fb3			; a offset into frame buffer to start prompt 
0fb3			; d is max length 
0fb3			; e is display size TODO 
0fb3			; c is current cursor position 
0fb3			; hl is ptr to where string will be stored 
0fb3			 
0fb3			 
0fb3			; TODO check limit of buffer for new inserts 
0fb3			; TODO check insert does not push beyond buffer 
0fb3			; TODO scroll in a limited display area 
0fb3			; TODO scroll whole screen on page wrap 
0fb3			 
0fb3			 
0fb3			; TODO handle KEY_PREVWORD 
0fb3			; TODO handle KEY_NEXTWORD 
0fb3			; TODO handle KEY_HOME 
0fb3			; TODO handle KEY_END 
0fb3			; TODO use LCD cursor? 
0fb3			 
0fb3 32 67 fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0fb6 81					add c 
0fb7 32 65 fe				ld (input_at_cursor),a	; save draw pos of cursor 
0fba 22 6a fe				ld (input_start), hl     ; save ptr to buffer 
0fbd 79					ld a, c 
0fbe cd 86 0f				call addatohl 
0fc1 22 6c fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0fc4 7a					ld a,d 
0fc5 32 69 fe			        ld (input_size), a       ; save length of input area 
0fc8 79					ld a, c 
0fc9 32 58 fe				ld (input_cursor),a      ; init cursor start position  
0fcc 7b					ld a,e 
0fcd 32 68 fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0fd0					 
0fd0					 
0fd0			 
0fd0			;		ld a,(input_ptr) 
0fd0			;		ld (input_under_cursor),a 	; save what is under the cursor 
0fd0			 
0fd0			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0fd0					; init cursor shape if not set by the cin routines 
0fd0 21 c4 fb				ld hl, cursor_shape 
0fd3 3e ff				ld a, 255 
0fd5 77					ld (hl), a 
0fd6 23					inc hl 
0fd7 3e 00				ld a, 0 
0fd9 77					ld (hl), a 
0fda			 
0fda 3e 0f				ld a, CUR_BLINK_RATE 
0fdc 32 63 fe				ld (input_cur_flash), a 
0fdf 3e 01				ld a, 1 
0fe1 32 62 fe				ld (input_cur_onoff),a 
0fe4			 
0fe4			;	if DEBUG_INPUT 
0fe4			;		push af 
0fe4			;		ld a, 'I' 
0fe4			;		ld (debug_mark),a 
0fe4			;		pop af 
0fe4			;		CALLMONITOR 
0fe4			;	endif 
0fe4			.is1:		; main entry loop 
0fe4			 
0fe4			 
0fe4			 
0fe4					; pause 1ms 
0fe4			 
0fe4 3e 01				ld a, 1 
0fe6 cd 7a 0c				call aDelayInMS 
0fe9			 
0fe9					; dec flash counter 
0fe9 3a 63 fe				ld a, (input_cur_flash) 
0fec 3d					dec a 
0fed 32 63 fe				ld (input_cur_flash), a 
0ff0 fe 00				cp 0 
0ff2 20 0d				jr nz, .nochgstate 
0ff4			 
0ff4			 
0ff4					; change state 
0ff4 3a 62 fe				ld a,(input_cur_onoff) 
0ff7 ed 44				neg 
0ff9 32 62 fe				ld (input_cur_onoff),a 
0ffc			 
0ffc			 
0ffc					; reset on change of state 
0ffc 3e 0f				ld a, CUR_BLINK_RATE 
0ffe 32 63 fe				ld (input_cur_flash), a 
1001			 
1001			.nochgstate: 
1001					 
1001					 
1001			 
1001					; display cursor  
1001			 
1001			;		ld hl, (input_start) 
1001			;		ld a, (input_cursor) 
1001			;		call addatohl 
1001			 
1001					; get char under cursor and replace with cursor 
1001 2a 6c fe		ld hl, (input_ptr) 
1004			;		ld a, (hl) 
1004			;		ld (input_under_cursor),a 
1004			;		ld a, '_' 
1004			;		ld (hl), a 
1004			 
1004					; display string 
1004			 
1004 ed 5b 6a fe			ld de, (input_start) 
1008 3a 67 fe				ld a, (input_at_pos) 
100b cd 65 0d				call str_at_display 
100e			;	        call update_display 
100e			 
100e					; find place to put the cursor 
100e			;		add h 
100e			;		ld l, display_row_1 
100e			;		sub l 
100e			; (input_at_pos) 
100e					;ld c, a 
100e			;		ld a, (input_cursor) 
100e			;		ld l, (input_at_pos) 
100e			;		;ld b, h 
100e			;		add l 
100e			;		ld (input_at_cursor),a 
100e					;ld l,h 
100e			 
100e			;		ld h, 0 
100e			;		ld l,(input_at_pos) 
100e			;		ld a, (input_cursor) 
100e			;		call addatohl 
100e			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
100e			;		call subafromhl 
100e			;		ld a,l 
100e			;		ld (input_at_cursor), a 
100e			 
100e				if DEBUG_INPUT 
100e					ld a, (hardware_diag) 
100e					cp 0 
100e					jr z, .skip_input_diag 
100e			 
100e					ld a,(input_at_pos) 
100e					ld hl, LFSRSeed 
100e					call hexout 
100e					ld a, (input_cursor) 
100e					ld hl, LFSRSeed+2 
100e					call hexout 
100e					ld a,(input_at_cursor) 
100e					ld hl, LFSRSeed+4 
100e					call hexout 
100e			 
100e					ld a,(input_cur_onoff) 
100e					ld hl, LFSRSeed+6 
100e					call hexout 
100e			 
100e					ld a,(input_cur_flash) 
100e					ld hl, LFSRSeed+8 
100e					call hexout 
100e			 
100e					ld a,(input_len) 
100e					ld hl, LFSRSeed+10 
100e					call hexout 
100e					ld hl, LFSRSeed+12 
100e					ld a, 0 
100e					ld (hl),a 
100e					ld a, display_row_4 
100e					ld de, LFSRSeed 
100e					call str_at_display 
100e					.skip_input_diag: 
100e				endif 
100e			 
100e					; decide on if we are showing the cursor this time round 
100e			 
100e 3a 62 fe				ld a, (input_cur_onoff) 
1011 fe ff				cp 255 
1013 28 13				jr z, .skipcur 
1015			 
1015			 
1015 3a 65 fe				ld a,(input_at_cursor) 
1018 11 c4 fb				ld de, cursor_shape 
101b cd 65 0d				call str_at_display 
101e			 
101e					; save length of current input string 
101e 2a 6a fe				ld hl, (input_start) 
1021 cd e4 13				call strlenz 
1024 7d					ld a,l 
1025 32 5d fe				ld (input_len),a 
1028			 
1028			.skipcur: 
1028			 
1028 cd 75 0d			        call update_display 
102b					 
102b			 
102b			 
102b					; wait 
102b				 
102b					; TODO loop without wait to flash the cursor and char under cursor	 
102b cd d2 78				call cin    ; _wait 
102e			 
102e fe 00				cp 0 
1030 ca e4 0f				jp z, .is1 
1033			 
1033					; get ptr to char to input into 
1033			 
1033 4f					ld c,a 
1034 2a 6a fe				ld hl, (input_start) 
1037 3a 58 fe				ld a, (input_cursor) 
103a cd 86 0f				call addatohl 
103d 22 6c fe				ld (input_ptr), hl 
1040 79					ld a,c 
1041			 
1041					; replace char under cursor 
1041			 
1041			;		ld hl, (input_ptr) 
1041			;		ld a, (input_under_cursor) 	; get what is under the cursor 
1041			;		ld (hl), a 
1041			 
1041			;	if DEBUG_INPUT 
1041			;		push af 
1041			;		ld a, 'i' 
1041			;		ld (debug_mark),a 
1041			;		pop af 
1041			;		CALLMONITOR 
1041			;	endif 
1041 fe 0e				cp KEY_HOME 
1043 20 0e				jr nz, .iske 
1045			 
1045 3a 67 fe				ld a, (input_at_pos) 
1048 32 65 fe				ld (input_at_cursor),a 
104b 3e 00				ld a, 0 
104d 32 58 fe				ld (input_cursor), a 
1050 c3 e4 0f				jp .is1 
1053					 
1053 fe 0f		.iske:		cp KEY_END 
1055 20 03				jr nz, .isknw 
1057 c3 e4 0f				jp .is1 
105a			 
105a fe 06		.isknw:		cp KEY_NEXTWORD 
105c 20 1b				jr nz, .iskpw 
105e			 
105e 2a 6c fe		.isknwm:	ld hl, (input_ptr) 
1061 7e					ld a,(hl)	 
1062 fe 00				cp 0 
1064 ca e4 0f				jp z, .is1    ; end of string 
1067 fe 20				cp ' ' 
1069 ca e4 0f				jp z, .is1    ; end of word 
106c 23					inc hl 
106d 22 6c fe				ld (input_ptr), hl 
1070 3a 65 fe				ld a, (input_at_cursor) 
1073 3c					inc a 
1074 32 65 fe				ld (input_at_cursor), a 
1077 18 e5				jr .isknwm 
1079			 
1079 fe 07		.iskpw:		cp KEY_PREVWORD 
107b 20 1b				jr nz, .iskl 
107d			.iskpwm:	 
107d 2a 6c fe				ld hl, (input_ptr) 
1080 7e					ld a,(hl)	 
1081 fe 00				cp 0  
1083 ca e4 0f				jp z, .is1    ; end of string 
1086 fe 20				cp ' ' 
1088 ca e4 0f				jp z, .is1    ; end of word 
108b 2b					dec hl 
108c 22 6c fe				ld (input_ptr), hl 
108f 3a 65 fe				ld a, (input_at_cursor) 
1092 3d					dec a 
1093 32 65 fe				ld (input_at_cursor), a 
1096 18 e5				jr .iskpwm 
1098			 
1098			 
1098 fe 0b		.iskl:		cp KEY_LEFT 
109a 20 27				jr nz, .isk1 
109c			 
109c 3a 58 fe				ld a, (input_cursor) 
109f			 
109f fe 00				cp 0 
10a1 ca e4 0f				jp z, .is1 		; at start of line to ignore  
10a4			 
10a4 3d					dec  a 		; TODO check underflow 
10a5 32 58 fe				ld (input_cursor), a 
10a8			 
10a8 2a 6c fe				ld hl, (input_ptr) 
10ab 2b					dec hl 
10ac 22 6c fe				ld (input_ptr), hl 
10af					 
10af 3a 65 fe				ld a, (input_at_cursor) 
10b2 3d					dec a 
10b3 32 65 fe				ld (input_at_cursor), a 
10b6			 
10b6 3e 01				ld a, 1		; show cursor moving 
10b8 32 62 fe				ld (input_cur_onoff),a 
10bb 3e 0f				ld a, CUR_BLINK_RATE 
10bd 32 63 fe				ld (input_cur_flash), a 
10c0			 
10c0 c3 e4 0f				jp .is1 
10c3			 
10c3 fe 0c		.isk1:		cp KEY_RIGHT 
10c5 20 2a				jr nz, .isk2 
10c7			 
10c7 3a 5d fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
10ca 5f					ld e,a 
10cb 3a 58 fe				ld a, (input_cursor) 
10ce bb					cp e 
10cf ca e4 0f				jp z, .is1		; at the end of string so dont go right 
10d2			 
10d2 3c					inc  a 		; TODO check overflow 
10d3 32 58 fe				ld (input_cursor), a 
10d6			 
10d6 3a 65 fe				ld a, (input_at_cursor) 
10d9 3c					inc a 
10da 32 65 fe				ld (input_at_cursor), a 
10dd			 
10dd 2a 6c fe				ld hl, (input_ptr) 
10e0 23					inc hl 
10e1 22 6c fe				ld (input_ptr), hl 
10e4			 
10e4 3e 01				ld a, 1		; show cursor moving 
10e6 32 62 fe				ld (input_cur_onoff),a 
10e9 3e 0f				ld a, CUR_BLINK_RATE 
10eb 32 63 fe				ld (input_cur_flash), a 
10ee			 
10ee c3 e4 0f				jp .is1 
10f1			 
10f1 fe 05		.isk2:		cp KEY_UP 
10f3			 
10f3 20 26				jr nz, .isk3 
10f5			 
10f5					; swap last command with the current on 
10f5			 
10f5					; move cursor to start of string 
10f5 2a 6a fe				ld hl, (input_start) 
10f8 22 6c fe				ld (input_ptr), hl 
10fb			 
10fb 3a 67 fe				ld a, (input_at_pos) 
10fe 32 65 fe				ld (input_at_cursor), a 
1101			 
1101 3e 00				ld a, 0 
1103 32 58 fe				ld (input_cursor), a 
1106					 
1106					; swap input and last command buffers 
1106			 
1106 21 eb f4				ld hl, os_cli_cmd 
1109 11 ea f5				ld de, os_last_cmd 
110c 06 ff				ld b, 255 
110e 7e			.swap1:		ld a, (hl) 
110f 4f					ld c,a 
1110 1a					ld a, (de) 
1111 77					ld (hl), a 
1112 79					ld a,c 
1113 12					ld (de),a 
1114 23					inc hl 
1115 13					inc de 
1116 10 f6				djnz .swap1 
1118			 
1118			 
1118			 
1118			 
1118			 
1118 c3 e4 0f				jp .is1 
111b			 
111b fe 08		.isk3:		cp KEY_BS 
111d 20 3c				jr nz, .isk4 
111f			 
111f 3a 58 fe				ld a, (input_cursor) 
1122			 
1122 fe 00				cp 0 
1124 ca e4 0f				jp z, .is1 		; at start of line to ignore  
1127			 
1127 3d					dec  a 		; TODO check underflow 
1128 32 58 fe				ld (input_cursor), a 
112b			 
112b					; hl is source 
112b					; de needs to be source - 1 
112b			 
112b			;		ld a, 0 
112b			;		dec hl 
112b			;		ld (hl), a 
112b			 
112b 2a 6c fe				ld hl, (input_ptr) 
112e 2b					dec hl 
112f 22 6c fe				ld (input_ptr), hl 
1132			 
1132					; shift all data 
1132			 
1132 e5					push hl 
1133 23					inc hl 
1134 d1					pop de 
1135 3a 5d fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
1138 4f					ld c,a 
1139 06 00				ld b,0 
113b ed b0				ldir  
113d			 
113d			 
113d			 
113d			 
113d 3a 65 fe				ld a, (input_at_cursor) 
1140 3d					dec a 
1141 32 65 fe				ld (input_at_cursor), a 
1144			 
1144			 
1144 3e 01				ld a, 1		; show cursor moving 
1146 32 62 fe				ld (input_cur_onoff),a 
1149 3e 0f				ld a, CUR_BLINK_RATE 
114b 32 63 fe				ld (input_cur_flash), a 
114e			 
114e					; remove char 
114e 3a 65 fe				ld a, (input_at_cursor) 
1151 3c					inc a 
1152 11 dc 11				ld de,.iblank 
1155 cd 65 0d				call str_at_display 
1158			 
1158 c3 e4 0f				jp .is1 
115b			 
115b fe 0d		.isk4:		cp KEY_CR 
115d 28 6c				jr z, .endinput 
115f			 
115f					; else add the key press to the end 
115f			 
115f 4f					ld c, a			; save key pressed 
1160			 
1160 7e					ld a,(hl)		; get what is currently under char 
1161			 
1161 fe 00				cp 0			; we are at the end of the string 
1163 20 2f				jr nz, .onchar 
1165					 
1165					; add a char to the end of the string 
1165				 
1165 71					ld (hl),c 
1166 23					inc hl 
1167			;		ld a,' ' 
1167			;		ld (hl),a 
1167			;		inc hl 
1167 3e 00				ld a,0 
1169 77					ld (hl),a 
116a 2b					dec hl 
116b			 
116b 3a 58 fe				ld a, (input_cursor) 
116e 3c					inc a				; TODO check max string length and scroll  
116f 32 58 fe				ld (input_cursor), a		; inc cursor pos 
1172							 
1172 3a 65 fe				ld a, (input_at_cursor) 
1175 3c					inc a 
1176 32 65 fe				ld (input_at_cursor), a 
1179			 
1179 2a 6c fe				ld hl, (input_ptr) 
117c 23					inc hl 
117d 22 6c fe				ld (input_ptr), hl 
1180			 
1180 2a 6c fe				ld hl, (input_ptr) 
1183 23					inc hl 
1184 22 6c fe				ld (input_ptr), hl 
1187			;	if DEBUG_INPUT 
1187			;		push af 
1187			;		ld a, '+' 
1187			;		ld (debug_mark),a 
1187			;		pop af 
1187			;		CALLMONITOR 
1187			;	endif 
1187 3e 01				ld a, 1		; show cursor moving 
1189 32 62 fe				ld (input_cur_onoff),a 
118c 3e 0f				ld a, CUR_BLINK_RATE 
118e 32 63 fe				ld (input_cur_flash), a 
1191 c3 e4 0f				jp .is1 
1194					 
1194			 
1194			 
1194					; if on a char then insert 
1194			.onchar: 
1194			 
1194					; TODO over flow check: make sure insert does not blow out buffer 
1194			 
1194					; need to do some maths to use lddr 
1194			 
1194 e5					push hl   ; save char pos 
1195 c5					push bc 
1196			 
1196 2a 6a fe				ld hl, (input_start) 
1199 3a 5d fe				ld a, (input_len) 
119c cd 86 0f				call addatohl  		; end of string 
119f 23					inc hl 
11a0 23					inc hl		; past zero term 
11a1 e5					push hl 
11a2 23					inc hl 
11a3 e5					push hl  
11a4			 
11a4								; start and end of lddr set, now how much to move? 
11a4			 
11a4							 
11a4 3a 58 fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11a7 47					ld b,a 
11a8 3a 5d fe				ld a,(input_len) 
11ab 5f					ld e,a 
11ac 90					sub b 
11ad 3c					inc a		;?? 
11ae 3c					inc a		;?? 
11af 3c					inc a		;?? 
11b0			 
11b0 06 00				ld b,0 
11b2 4f					ld c,a 
11b3			 
11b3				if DEBUG_INPUT 
11b3					push af 
11b3					ld a, 'i' 
11b3					ld (debug_mark),a 
11b3					pop af 
11b3			;		CALLMONITOR 
11b3				endif 
11b3 d1					pop de 
11b4 e1					pop hl 
11b5				if DEBUG_INPUT 
11b5					push af 
11b5					ld a, 'I' 
11b5					ld (debug_mark),a 
11b5					pop af 
11b5			;		CALLMONITOR 
11b5				endif 
11b5 ed b8				lddr 
11b7				 
11b7			 
11b7			 
11b7					; TODO have a key for insert/overwrite mode???? 
11b7 c1					pop bc 
11b8 e1					pop hl 
11b9 71					ld (hl), c		; otherwise overwrite current char 
11ba					 
11ba			 
11ba			 
11ba			 
11ba 3a 58 fe				ld a, (input_cursor) 
11bd 3c					inc  a 		; TODO check overflow 
11be 32 58 fe				ld (input_cursor), a 
11c1			 
11c1 3a 65 fe				ld a, (input_at_cursor) 
11c4 3c					inc a 
11c5 32 65 fe				ld (input_at_cursor), a 
11c8			 
11c8 c3 e4 0f				jp .is1 
11cb			 
11cb			.endinput:	; TODO look for end of string 
11cb			 
11cb					; add trailing space for end of token 
11cb			 
11cb 2a 6a fe				ld hl, (input_start) 
11ce 3a 5d fe				ld a,(input_len) 
11d1 cd 86 0f				call addatohl 
11d4 3e 20				ld a, ' ' 
11d6 77					ld (hl),a 
11d7					; TODO eof of parse marker 
11d7			 
11d7 23					inc hl 
11d8 3e 00				ld a, 0 
11da 77					ld (hl),a 
11db			 
11db			 
11db c9					ret 
11dc			 
11dc .. 00		.iblank: db " ",0 
11de			 
11de			 
11de 32 67 fe		input_str_prev:	ld (input_at_pos), a 
11e1 22 6a fe				ld (input_start), hl 
11e4 3e 01				ld a,1			; add cursor 
11e6 77					ld (hl),a 
11e7 23					inc hl 
11e8 3e 00				ld a,0 
11ea 77					ld (hl),a 
11eb 22 6c fe				ld (input_ptr), hl 
11ee 7a					ld a,d 
11ef 32 69 fe				ld (input_size), a 
11f2 3e 00				ld a,0 
11f4 32 58 fe				ld (input_cursor),a 
11f7			.instr1:	 
11f7			 
11f7					; TODO do block cursor 
11f7					; TODO switch cursor depending on the modifer key 
11f7			 
11f7					; update cursor shape change on key hold 
11f7			 
11f7 2a 6c fe				ld hl, (input_ptr) 
11fa 2b					dec hl 
11fb 3a c4 fb				ld a,(cursor_shape) 
11fe 77					ld (hl), a 
11ff			 
11ff					; display entered text 
11ff 3a 67 fe				ld a,(input_at_pos) 
1202 cd 96 76		            	CALL fLCD_Pos       ;Position cursor to location in A 
1205 ed 5b 6a fe	            	LD   de, (input_start) 
1209 cd b8 76		            	CALL fLCD_Str       ;Display string pointed to by DE 
120c			 
120c cd d2 78				call cin 
120f fe 00				cp 0 
1211 28 e4				jr z, .instr1 
1213			 
1213					; proecess keyboard controls first 
1213			 
1213 2a 6c fe				ld hl,(input_ptr) 
1216			 
1216 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1218 28 5a				jr z, .instrcr 
121a			 
121a fe 08				cp KEY_BS 	; back space 
121c 20 0f				jr nz, .instr2 
121e					; process back space 
121e			 
121e					; TODO stop back space if at start of string 
121e 2b					dec hl 
121f 2b					dec hl ; to over write cursor 
1220 3a c4 fb				ld a,(cursor_shape) 
1223					;ld a,0 
1223 77					ld (hl),a 
1224 23					inc hl 
1225 3e 20				ld a," " 
1227 77					ld (hl),a 
1228 22 6c fe				ld (input_ptr),hl 
122b					 
122b			 
122b 18 ca				jr .instr1 
122d			 
122d fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
122f 20 06				jr nz, .instr3 
1231 2b					dec hl 
1232 22 6c fe				ld (input_ptr),hl 
1235 18 c0				jr .instr1 
1237				 
1237 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
1239 20 06				jr nz, .instr4 
123b 23					inc hl 
123c 22 6c fe				ld (input_ptr),hl 
123f 18 b6				jr .instr1 
1241			 
1241 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
1243 20 06				jr nz, .instr5 
1245 2b					dec hl 
1246 22 6c fe				ld (input_ptr),hl 
1249 18 ac				jr .instr1 
124b			 
124b fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
124d 20 06				jr nz, .instr6 
124f 2b					dec hl 
1250 22 6c fe				ld (input_ptr),hl 
1253 18 a2				jr .instr1 
1255 fe 05		.instr6:        cp KEY_UP      ; recall last command 
1257 20 0b				jr nz, .instrnew 
1259			 
1259 21 c4 f1			ld hl, scratch 
125c 11 ea f5			ld de, os_last_cmd 
125f cd 7d 12			call strcpy 
1262 18 93				jr .instr1 
1264			 
1264			 
1264			.instrnew:	; no special key pressed to see if we have room to store it 
1264			 
1264					; TODO do string size test 
1264			 
1264 2b					dec hl ; to over write cursor 
1265 77					ld (hl),a 
1266 23					inc hl 
1267 3a c4 fb				ld a,(cursor_shape) 
126a 77					ld (hl),a 
126b 23					inc hl 
126c 3e 00				ld a,0 
126e 77					ld (hl),a 
126f			 
126f 22 6c fe				ld (input_ptr),hl 
1272					 
1272 18 83				jr .instr1 
1274 2b			.instrcr:	dec hl		; remove cursor 
1275 3e 20				ld a,' '	; TODO add a trailing space for safety 
1277 77					ld (hl),a 
1278 23					inc hl 
1279 3e 00				ld a,0 
127b 77					ld (hl),a 
127c			 
127c			 
127c					; if at end of line scroll up    
127c					; TODO detecting only end of line 4 for scroll up  
127c			 
127c					;ld   
127c			 
127c c9					ret 
127d			 
127d			 
127d			; strcpy hl = dest, de source 
127d			 
127d 1a			strcpy:   LD   A, (DE)        ;Get character from string 
127e b7			            OR   A              ;Null terminator? 
127f c8			            RET  Z              ;Yes, so finished 
1280 1a					ld a,(de) 
1281 77					ld (hl),a 
1282 13			            INC  DE             ;Point to next character 
1283 23					inc hl 
1284 18 f7		            JR   strcpy       ;Repeat 
1286 c9					ret 
1287			 
1287			 
1287			; TODO string_at  
1287			; pass string which starts with lcd offset address and then null term string 
1287			 
1287			; TODO string to dec 
1287			; TODO string to hex 
1287			; TODO byte to string hex 
1287			; TODO byte to string dec 
1287			 
1287			 
1287			 
1287			; from z80uartmonitor 
1287			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1287			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
1287			; pass hl for where to put the text 
1287			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1287 c5			hexout:	PUSH BC 
1288 f5					PUSH AF 
1289 47					LD B, A 
128a					; Upper nybble 
128a cb 3f				SRL A 
128c cb 3f				SRL A 
128e cb 3f				SRL A 
1290 cb 3f				SRL A 
1292 cd a2 12				CALL tohex 
1295 77					ld (hl),a 
1296 23					inc hl	 
1297					 
1297					; Lower nybble 
1297 78					LD A, B 
1298 e6 0f				AND 0FH 
129a cd a2 12				CALL tohex 
129d 77					ld (hl),a 
129e 23					inc hl	 
129f					 
129f f1					POP AF 
12a0 c1					POP BC 
12a1 c9					RET 
12a2					 
12a2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12a2			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
12a2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12a2			tohex: 
12a2 e5					PUSH HL 
12a3 d5					PUSH DE 
12a4 16 00				LD D, 0 
12a6 5f					LD E, A 
12a7 21 af 12				LD HL, .DATA 
12aa 19					ADD HL, DE 
12ab 7e					LD A, (HL) 
12ac d1					POP DE 
12ad e1					POP HL 
12ae c9					RET 
12af			 
12af			.DATA: 
12af 30					DEFB	30h	; 0 
12b0 31					DEFB	31h	; 1 
12b1 32					DEFB	32h	; 2 
12b2 33					DEFB	33h	; 3 
12b3 34					DEFB	34h	; 4 
12b4 35					DEFB	35h	; 5 
12b5 36					DEFB	36h	; 6 
12b6 37					DEFB	37h	; 7 
12b7 38					DEFB	38h	; 8 
12b8 39					DEFB	39h	; 9 
12b9 41					DEFB	41h	; A 
12ba 42					DEFB	42h	; B 
12bb 43					DEFB	43h	; C 
12bc 44					DEFB	44h	; D 
12bd 45					DEFB	45h	; E 
12be 46					DEFB	46h	; F 
12bf			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
12bf			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
12bf			;;    subtract $30, if result > 9 then subtract $7 more 
12bf			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
12bf			atohex: 
12bf d6 30				SUB $30 
12c1 fe 0a				CP 10 
12c3 f8					RET M		; If result negative it was 0-9 so we're done 
12c4 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
12c6 c9					RET		 
12c7			 
12c7			 
12c7			 
12c7			 
12c7			; Get 2 ASCII characters as hex byte from pointer in hl 
12c7			 
12c7			BYTERD: 
12c7 16 00			LD	D,00h		;Set up 
12c9 cd d1 12			CALL	HEXCON		;Get byte and convert to hex 
12cc 87				ADD	A,A		;First nibble so 
12cd 87				ADD	A,A		;multiply by 16 
12ce 87				ADD	A,A		; 
12cf 87				ADD	A,A		; 
12d0 57				LD	D,A		;Save hi nibble in D 
12d1			HEXCON: 
12d1 7e				ld a, (hl)		;Get next chr 
12d2 23				inc hl 
12d3 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
12d5 fe 0a			CP	00Ah		;Is it 0-9 ? 
12d7 38 02			JR	C,NALPHA	;If so miss next bit 
12d9 d6 07			SUB	007h		;Else convert alpha 
12db			NALPHA: 
12db b2				OR	D		;Add hi nibble back 
12dc c9				RET			; 
12dd			 
12dd			 
12dd			; 
12dd			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
12dd			; Since the routines get_byte and therefore get_nibble are called, only valid 
12dd			; characters (0-9a-f) are accepted. 
12dd			; 
12dd			;get_word        push    af 
12dd			;                call    get_byte        ; Get the upper byte 
12dd			;                ld      h, a 
12dd			;                call    get_byte        ; Get the lower byte 
12dd			;                ld      l, a 
12dd			;                pop     af 
12dd			;                ret 
12dd			; 
12dd			; Get a byte in hexadecimal notation. The result is returned in A. Since 
12dd			; the routine get_nibble is used only valid characters are accepted - the  
12dd			; input routine only accepts characters 0-9a-f. 
12dd			; 
12dd c5			get_byte:        push    bc              ; Save contents of B (and C) 
12de 7e					ld a,(hl) 
12df 23					inc hl 
12e0 cd 05 13		                call    nibble2val      ; Get upper nibble 
12e3 cb 07		                rlc     a 
12e5 cb 07		                rlc     a 
12e7 cb 07		                rlc     a 
12e9 cb 07		                rlc     a 
12eb 47			                ld      b, a            ; Save upper four bits 
12ec 7e					ld a,(hl) 
12ed cd 05 13		                call    nibble2val      ; Get lower nibble 
12f0 b0			                or      b               ; Combine both nibbles 
12f1 c1			                pop     bc              ; Restore B (and C) 
12f2 c9			                ret 
12f3			; 
12f3			; Get a hexadecimal digit from the serial line. This routine blocks until 
12f3			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
12f3			; to the serial line interface. The lower 4 bits of A contain the value of  
12f3			; that particular digit. 
12f3			; 
12f3			;get_nibble      ld a,(hl)           ; Read a character 
12f3			;                call    to_upper        ; Convert to upper case 
12f3			;                call    is_hex          ; Was it a hex digit? 
12f3			;                jr      nc, get_nibble  ; No, get another character 
12f3			 ;               call    nibble2val      ; Convert nibble to value 
12f3			 ;               call    print_nibble 
12f3			 ;               ret 
12f3			; 
12f3			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
12f3			; A valid hexadecimal digit is denoted by a set C flag. 
12f3			; 
12f3			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
12f3			;                ret     nc              ; Yes 
12f3			;                cp      '0'             ; Less than '0'? 
12f3			;                jr      nc, is_hex_1    ; No, continue 
12f3			;                ccf                     ; Complement carry (i.e. clear it) 
12f3			;                ret 
12f3			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
12f3			;                ret     c               ; Yes 
12f3			;                cp      'A'             ; Less than 'A'? 
12f3			;                jr      nc, is_hex_2    ; No, continue 
12f3			;                ccf                     ; Yes - clear carry and return 
12f3			;                ret 
12f3			;is_hex_2        scf                     ; Set carry 
12f3			;                ret 
12f3			; 
12f3			; Convert a single character contained in A to upper case: 
12f3			; 
12f3 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
12f5 d8			                ret     c 
12f6 fe 7b		                cp      'z' + 1         ; > 'z'? 
12f8 d0			                ret     nc              ; Nothing to do, either 
12f9 e6 5f		                and     $5f             ; Convert to upper case 
12fb c9			                ret 
12fc			 
12fc			 
12fc			to_lower: 
12fc			 
12fc			   ; if char is in [A-Z] make it lower case 
12fc			 
12fc			   ; enter : a = char 
12fc			   ; exit  : a = lower case char 
12fc			   ; uses  : af 
12fc			 
12fc fe 41		   cp 'A' 
12fe d8			   ret c 
12ff			    
12ff fe 5b		   cp 'Z'+1 
1301 d0			   ret nc 
1302			    
1302 f6 20		   or $20 
1304 c9			   ret 
1305			 
1305			; 
1305			; Expects a hexadecimal digit (upper case!) in A and returns the 
1305			; corresponding value in A. 
1305			; 
1305 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1307 38 02		                jr      c, nibble2val_1 ; Yes 
1309 d6 07		                sub     7               ; Adjust for A-F 
130b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
130d e6 0f		                and     $f              ; Only return lower 4 bits 
130f c9			                ret 
1310			; 
1310			; Print_nibble prints a single hex nibble which is contained in the lower  
1310			; four bits of A: 
1310			; 
1310			;print_nibble    push    af              ; We won't destroy the contents of A 
1310			;                and     $f              ; Just in case... 
1310			;                add     a, '0'             ; If we have a digit we are done here. 
1310			;                cp      '9' + 1         ; Is the result > 9? 
1310			;                jr      c, print_nibble_1 
1310			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1310			;print_nibble_1  call    putc            ; Print the nibble and 
1310			;                pop     af              ; restore the original value of A 
1310			;                ret 
1310			;; 
1310			;; Send a CR/LF pair: 
1310			; 
1310			;crlf            push    af 
1310			;                ld      a, cr 
1310			;                call    putc 
1310			;                ld      a, lf 
1310			;                call    putc 
1310			;                pop     af 
1310			;                ret 
1310			; 
1310			; Print_word prints the four hex digits of a word to the serial line. The  
1310			; word is expected to be in HL. 
1310			; 
1310			;print_word      push    hl 
1310			;                push    af 
1310			;                ld      a, h 
1310			;                call    print_byte 
1310			;                ld      a, l 
1310			;                call    print_byte 
1310			;                pop     af 
1310			;                pop     hl 
1310			;                ret 
1310			; 
1310			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1310			; The byte to be printed is expected to be in A. 
1310			; 
1310			;print_byte      push    af              ; Save the contents of the registers 
1310			;                push    bc 
1310			;                ld      b, a 
1310			;                rrca 
1310			;                rrca 
1310			;                rrca 
1310			;                rrca 
1310			;                call    print_nibble    ; Print high nibble 
1310			;                ld      a, b 
1310			;                call    print_nibble    ; Print low nibble 
1310			;                pop     bc              ; Restore original register contents 
1310			;                pop     af 
1310			;                ret 
1310			 
1310			 
1310			 
1310			 
1310			 
1310			fourehexhl:  
1310 7e				ld a,(hl) 
1311 cd bf 12			call atohex 
1314 cb 3f				SRL A 
1316 cb 3f				SRL A 
1318 cb 3f				SRL A 
131a cb 3f				SRL A 
131c 47				ld b, a 
131d 23				inc hl 
131e 7e				ld a,(hl) 
131f 23				inc hl 
1320 cd bf 12			call atohex 
1323 80				add b 
1324 57				ld d,a 
1325 7e				ld a,(hl) 
1326 cd bf 12			call atohex 
1329 cb 3f				SRL A 
132b cb 3f				SRL A 
132d cb 3f				SRL A 
132f cb 3f				SRL A 
1331 47				ld b, a 
1332 23				inc hl 
1333 7e				ld a,(hl) 
1334 23				inc hl 
1335 cd bf 12			call atohex 
1338 80				add b 
1339 5f				ld e, a 
133a d5				push de 
133b e1				pop hl 
133c c9				ret 
133d			 
133d			; pass hl. returns z set if the byte at hl is a digit 
133d			;isdigithl:  
133d			;	push bc 
133d			;	ld a,(hl) 
133d			;	cp ':' 
133d			;	jr nc, .isdf 		; > 
133d			;	cp '0' 
133d			;	jr c, .isdf		; < 
133d			; 
133d			;	; TODO find a better way to set z 
133d			; 
133d			;	ld b,a 
133d			;	cp b 
133d			;	pop bc 
133d			;	ret 
133d			; 
133d			;.isdf:	; not digit so clear z 
133d			; 
133d			;	; TODO find a better way to unset z 
133d			; 
133d			;	ld b,a 
133d			;	inc b 
133d			;	cp b 
133d			; 
133d			;	pop bc 
133d			;	ret 
133d				 
133d				 
133d			 
133d			 
133d			; pass hl as the four byte address to load 
133d			 
133d			get_word_hl:  
133d e5				push hl 
133e cd dd 12			call get_byte 
1341				 
1341 47				ld b, a 
1342			 
1342 e1				pop hl 
1343 23				inc hl 
1344 23				inc hl 
1345			 
1345			; TODO not able to handle a-f  
1345 7e				ld a,(hl) 
1346			;	;cp ':' 
1346			;	cp 'g' 
1346			;	jr nc, .single_byte_hl 		; > 
1346			;	cp 'G' 
1346			;	jr nc, .single_byte_hl 		; > 
1346			;	cp '0' 
1346			;	jr c, .single_byte_hl		; < 
1346			 
1346				;call isdigithl 
1346 fe 00			cp 0 
1348 28 06			jr z, .single_byte_hl 
134a			 
134a			.getwhln:   ; hex word so get next byte 
134a			 
134a cd dd 12			call get_byte 
134d 6f				ld l, a 
134e 60				ld h,b 
134f c9				ret 
1350 68			.single_byte_hl:   ld l,b 
1351 26 00				ld h,0 
1353 c9					ret 
1354			 
1354			 
1354			 
1354			 
1354 21 e2 1d			ld hl,asc+1 
1357			;	ld a, (hl) 
1357			;	call nibble2val 
1357 cd dd 12			call get_byte 
135a			 
135a			;	call fourehexhl 
135a 32 f8 f1			ld (scratch+52),a 
135d				 
135d 21 f6 f1			ld hl,scratch+50 
1360 22 e7 f4			ld (os_cur_ptr),hl 
1363			 
1363 c9				ret 
1364			 
1364			 
1364			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
1364			 
1364			; Decimal Unsigned Version 
1364			 
1364			;Number in a to decimal ASCII 
1364			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
1364			;Example: display a=56 as "056" 
1364			;input: a = number 
1364			;Output: a=0,value of a in the screen 
1364			;destroys af,bc (don't know about hl and de) 
1364			DispAToASCII: 
1364 0e 9c			ld	c,-100 
1366 cd 70 13			call	.Na1 
1369 0e f6			ld	c,-10 
136b cd 70 13			call	.Na1 
136e 0e ff			ld	c,-1 
1370 06 2f		.Na1:	ld	b,'0'-1 
1372 04			.Na2:	inc	b 
1373 81				add	a,c 
1374 38 fc			jr	c,.Na2 
1376 91				sub	c		;works as add 100/10/1 
1377 f5				push af		;safer than ld c,a 
1378 78				ld	a,b		;char is in b 
1379			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
1379 f1				pop af		;safer than ld a,c 
137a c9				ret 
137b			 
137b			; Decimal Signed Version 
137b			 
137b			; DispA 
137b			; -------------------------------------------------------------- 
137b			; Converts a signed integer value to a zero-terminated ASCII 
137b			; string representative of that value (using radix 10). 
137b			; -------------------------------------------------------------- 
137b			; INPUTS: 
137b			;     HL     Value to convert (two's complement integer). 
137b			;     DE     Base address of string destination. (pointer). 
137b			; -------------------------------------------------------------- 
137b			; OUTPUTS: 
137b			;     None 
137b			; -------------------------------------------------------------- 
137b			; REGISTERS/MEMORY DESTROYED 
137b			; AF HL 
137b			; -------------------------------------------------------------- 
137b			 
137b			;DispHLToASCII: 
137b			;   push    de 
137b			;   push    bc 
137b			; 
137b			;; Detect sign of HL. 
137b			;    bit    7, h 
137b			;    jr     z, ._DoConvert 
137b			; 
137b			;; HL is negative. Output '-' to string and negate HL. 
137b			;    ld     a, '-' 
137b			;    ld     (de), a 
137b			;    inc    de 
137b			; 
137b			;; Negate HL (using two's complement) 
137b			;    xor    a 
137b			;    sub    l 
137b			;    ld     l, a 
137b			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
137b			;    sbc    a, h 
137b			;    ld     h, a 
137b			; 
137b			;; Convert HL to digit characters 
137b			;._DoConvert: 
137b			;    ld     b, 0     ; B will count character length of number 
137b			;-   ld     a, 10 
137b			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
137b			;    push   af 
137b			;    inc    b 
137b			;    ld     a, h 
137b			;    or     l 
137b			;    jr     nz, - 
137b			; 
137b			;; Retrieve digits from stack 
137b			;-   pop    af 
137b			;    or     $30 
137b			;    ld     (de), a 
137b			;    inc    de 
137b			;    djnz   - 
137b			; 
137b			;; Terminate string with NULL 
137b			;    xor    a 
137b			;    ld     (de), a 
137b			; 
137b			;    pop    bc 
137b			;    pop    de 
137b			;    ret 
137b			 
137b			;Comments 
137b			; 
137b			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
137b			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
137b			;    Note that the output string will not be fixed-width. 
137b			; 
137b			;Example Usage 
137b			; 
137b			;    ld    hl, -1004 
137b			;    ld    de, OP1 
137b			;    call  DispA 
137b			;    ld    hl, OP1 
137b			;    syscall  PutS 
137b			 
137b			 
137b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
137b			 
137b			 
137b			;Converts an ASCII string to an unsigned 16-bit integer 
137b			;Quits when it reaches a non-decimal digit 
137b			 
137b			string_to_uint16: 
137b			atoui_16: 
137b			;Input: 
137b			;     DE points to the string 
137b			;Outputs: 
137b			;     HL is the result 
137b			;     A is the 8-bit value of the number 
137b			;     DE points to the byte after the number 
137b			;Destroys: 
137b			;     BC 
137b			;       if the string is non-empty, BC is HL/10 
137b			;Size:  24 bytes 
137b			;Speed: 42+d(104+{0,9}) 
137b			;       d is the number of digits in the number 
137b			;       max is 640 cycles for a 5 digit number 
137b			;Assuming no leading zeros: 
137b			;1 digit:  146cc 
137b			;2 digit:  250cc 
137b			;3 digit:  354cc or 363cc (avg: 354.126cc) 
137b			;4 digit:  458cc or 467cc (avg: 458.27cc) 
137b			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
137b			;avg: 544.81158447265625cc (544+13297/16384) 
137b			;=============================================================== 
137b 21 00 00		  ld hl,0 
137e			.u16a: 
137e 1a			  ld a,(de) 
137f d6 30		  sub 30h 
1381 fe 0a		  cp 10 
1383 d0			  ret nc 
1384 13			  inc de 
1385 44			  ld b,h 
1386 4d			  ld c,l 
1387 29			  add hl,hl 
1388 29			  add hl,hl 
1389 09			  add hl,bc 
138a 29			  add hl,hl 
138b 85			  add a,l 
138c 6f			  ld l,a 
138d 30 ef		  jr nc,.u16a 
138f 24			  inc h 
1390 c3 7e 13		  jp .u16a 
1393			 
1393			 
1393			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1393			 
1393			;written by Zeda 
1393			;Converts a 16-bit unsigned integer to an ASCII string. 
1393			 
1393			uitoa_16: 
1393			;Input: 
1393			;   DE is the number to convert 
1393			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1393			;Output: 
1393			;   HL points to the null-terminated ASCII string 
1393			;      NOTE: This isn't necessarily the same as the input HL. 
1393 d5			  push de 
1394 c5			  push bc 
1395 f5			  push af 
1396 eb			  ex de,hl 
1397			 
1397 01 f0 d8		  ld bc,-10000 
139a 3e 2f		  ld a,'0'-1 
139c 3c			  inc a 
139d 09			  add hl,bc  
139e 38 fc		   jr c,$-2 
13a0 12			  ld (de),a 
13a1 13			  inc de 
13a2			 
13a2 01 e8 03		  ld bc,1000 
13a5 3e 3a		  ld a,'9'+1 
13a7 3d			  dec a  
13a8 09			  add hl,bc  
13a9 30 fc		   jr nc,$-2 
13ab 12			  ld (de),a 
13ac 13			  inc de 
13ad			 
13ad 01 9c ff		  ld bc,-100 
13b0 3e 2f		  ld a,'0'-1 
13b2 3c			  inc a  
13b3 09			  add hl,bc  
13b4 38 fc		   jr c,$-2 
13b6 12			  ld (de),a 
13b7 13			  inc de 
13b8			 
13b8 7d			  ld a,l 
13b9 26 3a		  ld h,'9'+1 
13bb 25			  dec h  
13bc c6 0a		  add a,10  
13be 30 fb		   jr nc,$-3 
13c0 c6 30		  add a,'0' 
13c2 eb			  ex de,hl 
13c3 72			  ld (hl),d 
13c4 23			  inc hl 
13c5 77			  ld (hl),a 
13c6 23			  inc hl 
13c7 36 00		  ld (hl),0 
13c9			 
13c9			;Now strip the leading zeros 
13c9 0e fa		  ld c,-6 
13cb 09			  add hl,bc 
13cc 3e 30		  ld a,'0' 
13ce 23			  inc hl  
13cf be			  cp (hl)  
13d0 28 fc		  jr z,$-2 
13d2			 
13d2			;Make sure that the string is non-empty! 
13d2 7e			  ld a,(hl) 
13d3 b7			  or a 
13d4 20 01		  jr nz,.atoub 
13d6 2b			  dec hl 
13d7			.atoub: 
13d7			 
13d7 f1			  pop af 
13d8 c1			  pop bc 
13d9 d1			  pop de 
13da c9			  ret 
13db			 
13db			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
13db			 
13db			toUpper: 
13db			;A is the char. 
13db			;If A is a lowercase letter, this sets it to the matching uppercase 
13db			;18cc or 30cc or 41cc 
13db			;avg: 26.75cc 
13db fe 61		  cp 'a' 
13dd d8			  ret c 
13de fe 7b		  cp 'z'+1 
13e0 d0			  ret nc 
13e1 d6 20		  sub 'a'-'A' 
13e3 c9			  ret 
13e4			 
13e4			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
13e4			 
13e4			; String Length 
13e4			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
13e4			 
13e4			; Get the length of the null-terminated string starting at $8000 hl 
13e4			;    LD     HL, $8000 
13e4			 
13e4			strlenz: 
13e4			 
13e4 af			    XOR    A               ; Zero is the value we are looking for. 
13e5 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
13e6 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
13e7			                           ; 65, 536 bytes (the entire addressable memory space). 
13e7 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13e9			 
13e9			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13e9 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
13ea 6f			    LD     L, A             ; number of bytes 
13eb ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13ed 2b			    DEC    HL              ; Compensate for null. 
13ee c9				ret 
13ef			 
13ef			; Get the length of the A terminated string starting at $8000 hl 
13ef			;    LD     HL, $8000 
13ef			 
13ef			strlent: 
13ef			 
13ef			                  ; A is the value we are looking for. 
13ef 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
13f1 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
13f3			                           ; 65, 536 bytes (the entire addressable memory space). 
13f3 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13f5			 
13f5			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13f5 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
13f7 2e 00		    LD     L, 0             ; number of bytes 
13f9 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13fb 2b			    DEC    HL              ; Compensate for null. 
13fc c9				ret 
13fd			 
13fd			 
13fd			;Comparing Strings 
13fd			 
13fd			;IN    HL     Address of string1. 
13fd			;      DE     Address of string2. 
13fd			 
13fd			; doc given but wrong??? 
13fd			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
13fd			;      carry  Set if string1 > string2, reset if string1 <= string2. 
13fd			; tested 
13fd			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
13fd			 
13fd			strcmp_old: 
13fd e5			    PUSH   HL 
13fe d5			    PUSH   DE 
13ff			 
13ff 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1400 be			    CP     (HL)            ; (want to minimize work). 
1401 38 01		    JR     C, Str1IsBigger 
1403 7e			    LD     A, (HL) 
1404			 
1404			Str1IsBigger: 
1404 4f			    LD     C, A             ; Put length in BC 
1405 06 00		    LD     B, 0 
1407 13			    INC    DE              ; Increment pointers to meat of string. 
1408 23			    INC    HL 
1409			 
1409			CmpLoop: 
1409 1a			    LD     A, (DE)          ; Compare bytes. 
140a ed a1		    CPI 
140c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
140e 13			    INC    DE              ; Update pointer. 
140f ea 09 14		    JP     PE, CmpLoop 
1412			 
1412 d1			    POP    DE 
1413 e1			    POP    HL 
1414 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1415 be			    CP     (HL) 
1416 c9			    RET 
1417			 
1417			NoMatch: 
1417 2b			    DEC    HL 
1418 be			    CP     (HL)            ; Compare again to affect carry. 
1419 d1			    POP    DE 
141a e1			    POP    HL 
141b c9			    RET 
141c			 
141c			;; test strmp 
141c			; 
141c			;ld de, .str1 
141c			;ld hl, .str2 
141c			;call strcmp 
141c			;jr z, .z1 
141c			;;this 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "NZ1" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			;.z1: 
141c			; 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "ZZ1" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			; 
141c			;ld de, .str1 
141c			;ld hl, .str1 
141c			;call strcmp 
141c			;jr z, .z2 
141c			;;this 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "NZ2" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			;.z2: 
141c			; 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "ZZ2" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			; 
141c			;ld de, .str1 
141c			;ld hl, .str2 
141c			;call strcmp 
141c			;jr c, .c1 
141c			; 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "Nc1" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			;.c1: 
141c			;;this 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "cc1" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			; 
141c			;ld de, .str1 
141c			;ld hl, .str1 
141c			;call strcmp 
141c			;jr c, .c2 
141c			;;this 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "Nc2" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			;.c2: 
141c			; 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "cc2" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			;	NEXTW 
141c			;.str1:   db "string1",0 
141c			;.str2:   db "string2",0 
141c			 
141c			; only care about direct match or not 
141c			; hl and de strings 
141c			; zero set if the same 
141c			 
141c			strcmp: 
141c 1a				ld a, (de) 
141d be				cp (hl) 
141e 28 02			jr z, .ssame 
1420 b7				or a 
1421 c9				ret 
1422			 
1422			.ssame:  
1422 fe 00			cp 0 
1424 c8				ret z 
1425			 
1425 23				inc hl 
1426 13				inc de 
1427 18 f3			jr strcmp 
1429				 
1429				 
1429			 
1429			 
1429			 
1429			 
1429			; eof 
1429			 
1429			 
1429			 
1429			 
1429			 
1429			 
# End of file firmware_strings.asm
1429			include "firmware_memory.asm"   ; malloc and free  
1429			 
1429			if DEBUG_FORTH_MALLOC_HIGH 
1429			.mallocsize: db "Wants malloc >256",0 
1429			.mallocasize: db "MALLOC gives >256",0 
1429			.malloczero: db "MALLOC gives zero",0 
1429			 
1429			malloc_guard_zerolen: 
1429				push hl 
1429				push de 
1429				push af 
1429			 
1429				ld de, 0 
1429			        call cmp16 
1429				jr nz, .lowalloz 
1429			 
1429				push hl 
1429				push de 
1429					ld hl, display_fb0 
1429					ld (display_fb_active), hl 
1429				call clear_display 
1429				ld a, 0 
1429				ld de, .malloczero 
1429				call str_at_display 
1429				call update_display 
1429				call delay1s 
1429				call delay1s 
1429				ld a, 0 
1429				ld (os_view_disable), a 
1429			 
1429				pop de 
1429				pop hl 
1429			 
1429				 
1429			 
1429				CALLMONITOR 
1429			.lowalloz: 
1429			 
1429			 
1429				pop af 
1429				pop de 
1429				pop hl 
1429			ret 
1429			 
1429			malloc_guard_entry: 
1429				push hl 
1429				push de 
1429				push af 
1429			 
1429			 	or a      ;clear carry flag 
1429				push hl 
1429				ld de, 255 
1429				sbc hl, de 
1429				jr c, .lowalloc 
1429			 
1429				push de 
1429					ld hl, display_fb0 
1429					ld (display_fb_active), hl 
1429				call clear_display 
1429				ld a, 0 
1429				ld de, .mallocsize 
1429				call str_at_display 
1429				call update_display 
1429				call delay1s 
1429				call delay1s 
1429				ld a, 0 
1429				ld (os_view_disable), a 
1429			 
1429				pop de 
1429				pop hl 
1429			 
1429				 
1429			 
1429				CALLMONITOR 
1429				jr .lowdone 
1429			.lowalloc: 
1429			 
1429			 
1429				pop hl 
1429			.lowdone:	pop af 
1429				pop de 
1429				pop hl 
1429			ret 
1429			 
1429			malloc_guard_exit: 
1429				push hl 
1429				push de 
1429				push af 
1429			 
1429			 	or a      ;clear carry flag 
1429				push hl 
1429				ld de, 255 
1429				sbc hl, de 
1429				jr c, .lowallocx 
1429			 
1429				push de 
1429					ld hl, display_fb0 
1429					ld (display_fb_active), hl 
1429				call clear_display 
1429				ld a, 0 
1429				ld de, .mallocasize 
1429				call str_at_display 
1429				call update_display 
1429				call delay1s 
1429				call delay1s 
1429				ld a, 0 
1429				ld (os_view_disable), a 
1429				pop de 
1429				pop hl 
1429			 
1429				CALLMONITOR 
1429				jr .lowdonex 
1429			.lowallocx: 
1429			 
1429				pop hl 
1429			.lowdonex:	pop af 
1429				pop de 
1429				pop hl 
1429			ret 
1429			endif 
1429			 
1429			if MALLOC_2 
1429			; Z80 Malloc and Free Functions 
1429			 
1429			; Malloc Function: 
1429			; Input: 
1429			;   HL: Size of block to allocate 
1429			; Output: 
1429			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1429			 
1429			malloc: 
1429				 
1429			if DEBUG_FORTH_MALLOC_HIGH 
1429			call malloc_guard_entry 
1429			endif 
1429			 
1429			 
1429			 
1429			 
1429					if DEBUG_FORTH_MALLOC 
1429						DMARK "mal" 
1429						CALLMONITOR 
1429					endif 
1429			    push af            ; Save AF register 
1429			    ld a, l            ; Load low byte of size into A 
1429			    or h               ; Check if size is zero 
1429			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1429			 
1429			    ; Allocate memory 
1429			    ld hl, (heap_start) ; Load start of heap into HL 
1429					if DEBUG_FORTH_MALLOC 
1429						DMARK "ma1" 
1429						CALLMONITOR 
1429					endif 
1429			    call malloc_internal ; Call internal malloc function 
1429			    pop af             ; Restore AF register 
1429			if DEBUG_FORTH_MALLOC_HIGH 
1429			call malloc_guard_exit 
1429			call malloc_guard_zerolen 
1429			endif 
1429			    ret                ; Return 
1429			 
1429			; Free Function: 
1429			; Input: 
1429			;   HL: Pointer to memory block to free 
1429			; Output: 
1429			;   None 
1429			 
1429			free: 
1429			    push af            ; Save AF register 
1429			    ld a, l            ; Load low byte of pointer into A 
1429			    or h               ; Check if pointer is NULL 
1429			    jp z, free_exit    ; If pointer is NULL, exit 
1429			 
1429			    ; Free memory 
1429			    ld hl, (heap_start) ; Load start of heap into HL 
1429			    call free_internal  ; Call internal free function 
1429			    pop af             ; Restore AF register 
1429			    ret                ; Return 
1429			 
1429			; Internal Malloc Function: 
1429			; Input: 
1429			;   HL: Size of block to allocate 
1429			; Output: 
1429			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1429			 
1429			malloc_internal: 
1429			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1429			    add hl, bc         ; Add management overhead to requested size 
1429			    ex de, hl          ; Save total size in DE, and keep it in HL 
1429					if DEBUG_FORTH_MALLOC 
1429						DMARK "ma2" 
1429						CALLMONITOR 
1429					endif 
1429			 
1429			    ; Search for free memory block 
1429			    ld de, (heap_end)  ; Load end of heap into DE 
1429			    ld bc, 0           ; Initialize counter 
1429			 
1429					if DEBUG_FORTH_MALLOC 
1429						DMARK "ma2" 
1429						CALLMONITOR 
1429					endif 
1429			malloc_search_loop: 
1429			    ; Check if current block is free 
1429			    ld a, (hl)         ; Load current block's status (free or used) 
1429			    cp 0               ; Compare with zero (free) 
1429			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1429			 
1429			    ; Check if current block is large enough 
1429			    ld a, (hl+1)       ; Load high byte of block size 
1429			    cp l               ; Compare with low byte of requested size 
1429			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1429			 
1429			    ld a, (hl+2)       ; Load low byte of block size 
1429			    cp h               ; Compare with high byte of requested size 
1429			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1429			 
1429			    ; Mark block as used 
1429			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1429			 
1429			    ; Calculate remaining space in block 
1429			    ld bc, 0           ; Clear BC 
1429			    add hl, bc         ; Increment HL to point to start of data block 
1429			    add hl, de         ; HL = HL + DE (total size) 
1429			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1429			    add hl, bc         ; Add management overhead to start of data block 
1429			 
1429			    ; Save pointer to allocated block in HL 
1429			if DEBUG_FORTH_MALLOC_HIGH 
1429						DMARK "ma5" 
1429			call malloc_guard_exit 
1429			call malloc_guard_zerolen 
1429			endif 
1429			    ret 
1429			 
1429			malloc_skip_block_check: 
1429			    ; Move to the next block 
1429			    ld bc, 3           ; Size of management overhead 
1429			    add hl, bc         ; Move to the next block 
1429			    inc de             ; Increment counter 
1429			 
1429			    ; Check if we have reached the end of heap 
1429			    ld a, e            ; Load low byte of heap end address 
1429			    cp (hl)            ; Compare with low byte of current address 
1429			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1429			    ld a, d            ; Load high byte of heap end address 
1429			    cp 0               ; Check if it's zero (end of memory) 
1429			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1429			 
1429			    ; If we reached here, allocation failed 
1429			    xor a              ; Set result to NULL 
1429			if DEBUG_FORTH_MALLOC_HIGH 
1429						DMARK "ma6" 
1429			call malloc_guard_exit 
1429			call malloc_guard_zerolen 
1429			endif 
1429			    ret 
1429			malloc_exit: 
1429			if DEBUG_FORTH_MALLOC_HIGH 
1429						DMARK "ma7" 
1429			call malloc_guard_exit 
1429			call malloc_guard_zerolen 
1429			endif 
1429			    ret 
1429			 
1429			; Internal Free Function: 
1429			; Input: 
1429			;   HL: Pointer to memory block to free 
1429			; Output: 
1429			;   None 
1429			 
1429			free_internal: 
1429			    ld de, (heap_start) ; Load start of heap into DE 
1429			    ld bc, 0            ; Initialize counter 
1429			 
1429			free_search_loop: 
1429			    ; Check if current block contains the pointer 
1429			    ld a, l             ; Load low byte of pointer 
1429			    cp (hl+1)           ; Compare with high byte of current block's address 
1429			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1429			    ld a, h             ; Load high byte of pointer 
1429			    cp (hl+2)           ; Compare with low byte of current block's address 
1429			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1429			 
1429			    ; Mark block as free 
1429			    ld (hl), 0          ; Set status byte to indicate free block 
1429			    ret                 ; Return 
1429			 
1429			free_skip_block_check: 
1429			    ; Move to the next block 
1429			    ld bc, 3            ; Size of management overhead 
1429			    add hl, bc          ; Move to the next block 
1429			    inc de              ; Increment counter 
1429			 
1429			    ; Check if we have reached the end of heap 
1429			    ld a, e             ; Load low byte of heap end address 
1429			    cp (hl)             ; Compare with low byte of current address 
1429			    jr nz, free_search_loop  ; If not equal, continue searching 
1429			    ld a, d             ; Load high byte of heap end address 
1429			    cp 0                ; Check if it's zero (end of memory) 
1429			    jr nz, free_search_loop  ; If not zero, continue searching 
1429			 
1429			    ; If we reached here, pointer is not found in heap 
1429			    ret 
1429			 
1429			free_exit: 
1429			    ret                 ; Return 
1429			 
1429			; Define heap start and end addresses 
1429			;heap_start:    .dw 0xC000   ; Start of heap 
1429			;heap_end:      .dw 0xE000   ; End of heap 
1429			 
1429			endif 
1429			 
1429			 
1429			if MALLOC_1 
1429			 
1429			 
1429			 
1429			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1429			 
1429			;moved to firmware.asm 
1429			;heap_start        .equ  0x9000      ; Starting address of heap 
1429			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1429			 
1429			;      .org 0 
1429			;      jp    main 
1429			 
1429			 
1429			;      .org  0x100 
1429			;main: 
1429			;      ld    HL, 0x8100 
1429			;      ld    SP, HL 
1429			; 
1429			;      call  heap_init 
1429			; 
1429			;      ; Make some allocations 
1429			;      ld    HL, 12 
1429			;      call  malloc            ; Allocates 0x9004 
1429			; 
1429			;      ld    HL, 12 
1429			;      call  malloc            ; Allocates 0x9014 
1429			; 
1429			;      ld    HL, 12 
1429			;      call  malloc            ; Allocates 0x9024 
1429			; 
1429			;      ; Free some allocations 
1429			;      ld    HL, 0x9014 
1429			;      call  free 
1429			; 
1429			;      ld    HL, 0x9004 
1429			;      call  free 
1429			; 
1429			;      ld    HL, 0x9024 
1429			;      call  free 
1429			; 
1429			; 
1429			;      halt 
1429			 
1429			 
1429			;------------------------------------------------------------------------------ 
1429			;     heap_init                                                               : 
1429			;                                                                             : 
1429			; Description                                                                 : 
1429			;     Initialise the heap and make it ready for malloc and free operations.   : 
1429			;                                                                             : 
1429			;     The heap is maintained as a linked list, starting with an initial       : 
1429			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1429			;     the first free block in the heap. Each block then points to the next    : 
1429			;     free block within the heap, and the free list ends at the first block   : 
1429			;     with a null pointer to the next free block.                             : 
1429			;                                                                             : 
1429			; Parameters                                                                  : 
1429			;     Inputs are compile-time only. Two defines which specify the starting    : 
1429			;     address of the heap and its size are required, along with a memory      : 
1429			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1429			;     principally stores a pointer to the first free block in the heap.       : 
1429			;                                                                             : 
1429			; Returns                                                                     : 
1429			;     Nothing                                                                 : 
1429			;------------------------------------------------------------------------------ 
1429			heap_init: 
1429 e5			      push  HL 
142a			 
142a			      ; Initialise free list struct 
142a 21 0e 80		      ld    HL, heap_start 
142d 22 0a 80		      ld    (free_list), HL 
1430 21 00 00		      ld    HL, 0 
1433 22 0c 80		      ld    (free_list+2), HL 
1436			 
1436			      ; Insert first free block at bottom of heap, consumes entire heap 
1436 21 a6 f1		      ld    HL, heap_start+heap_size-4 
1439 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
143c 21 98 71		      ld    HL, heap_size-4 
143f 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1442			 
1442			      ; Insert end of free list block at top of heap - two null words will 
1442			      ; terminate the free list 
1442 21 00 00		      ld    HL, 0 
1445 22 a8 f1		      ld    (heap_start+heap_size-2), HL 
1448 22 a6 f1		      ld    (heap_start+heap_size-4), HL 
144b			 
144b e1			      pop   HL 
144c			 
144c c9			      ret 
144d			 
144d			 
144d			;------------------------------------------------------------------------------ 
144d			;     malloc                                                                  : 
144d			;                                                                             : 
144d			; Description                                                                 : 
144d			;     Allocates the wanted space from the heap and returns the address of the : 
144d			;     first useable byte of the allocation.                                   : 
144d			;                                                                             : 
144d			;     Allocations can happen in one of two ways:                              : 
144d			;                                                                             : 
144d			;     1. A free block may be found which is the exact size wanted. In this    : 
144d			;        case the block is removed from the free list and retuedn to the      : 
144d			;        caller.                                                              : 
144d			;     2. A free block may be found which is larger than the size wanted. In   : 
144d			;        this case, the larger block is split into two. The first portion of  : 
144d			;        this block will become the requested space by the malloc call and    : 
144d			;        is returned to the caller. The second portion becomes a new free     : 
144d			;        block, and the free list is adjusted to maintain continuity via this : 
144d			;        newly created block.                                                 : 
144d			;                                                                             : 
144d			;     malloc does not set any initial value in the allocated space, the       : 
144d			;     caller is required to do this as required.                              : 
144d			;                                                                             : 
144d			;     This implementation of malloc uses the stack exclusively, and is        : 
144d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
144d			;     advisable to disable interrupts before calling malloc, and recommended  : 
144d			;     to avoid the use of malloc inside ISRs in general.                      : 
144d			;                                                                             : 
144d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
144d			;                                                                             : 
144d			; Parameters                                                                  : 
144d			;     HL  Number of bytes wanted                                              : 
144d			;                                                                             : 
144d			; Returns                                                                     : 
144d			;     HL  Address of the first useable byte of the allocation                 : 
144d			;                                                                             : 
144d			; Flags                                                                       : 
144d			;     Z   Set if the allocation did not succeed, clear otherwise              : 
144d			;                                                                             : 
144d			; Stack frame                                                                 : 
144d			;       |             |                                                       : 
144d			;       +-------------+                                                       : 
144d			;       |     BC      |                                                       : 
144d			;       +-------------+                                                       : 
144d			;       |     DE      |                                                       : 
144d			;       +-------------+                                                       : 
144d			;       |     IX      |                                                       : 
144d			;       +-------------+                                                       : 
144d			;       |  prev_free  |                                                       : 
144d			;   +4  +-------------+                                                       : 
144d			;       |  this_free  |                                                       : 
144d			;   +2  +-------------+                                                       : 
144d			;       |  next_free  |                                                       : 
144d			;   +0  +-------------+                                                       : 
144d			;       |             |                                                       : 
144d			;                                                                             : 
144d			;------------------------------------------------------------------------------ 
144d			 
144d			 
144d			;malloc: 
144d			; 
144d			;	SAVESP ON 1 
144d			; 
144d			;	call malloc_code 
144d			; 
144d			;	CHECKSP ON 1 
144d			;	ret 
144d			 
144d			 
144d			malloc: 
144d c5			      push  BC 
144e d5			      push  DE 
144f dd e5		      push  IX 
1451			if DEBUG_FORTH_MALLOC_HIGH 
1451			call malloc_guard_entry 
1451			endif 
1451			 
1451					if DEBUG_FORTH_MALLOC 
1451						DMARK "mal" 
1451						CALLMONITOR 
1451					endif 
1451 7c			      ld    A, H                    ; Exit if no space requested 
1452 b5			      or    L 
1453 ca 12 15		      jp    Z, malloc_early_exit 
1456			 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			; 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			 
1456			 
1456			 
1456			 
1456					if DEBUG_FORTH_MALLOC 
1456						DMARK "maA" 
1456						CALLMONITOR 
1456					endif 
1456			      ; Set up stack frame 
1456 eb			      ex    DE, HL 
1457 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
145a 39			      add   HL, SP 
145b f9			      ld    SP, HL 
145c dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1460 dd 39		      add   IX, SP 
1462			 
1462			      ; Setup initial state 
1462 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1465 19			      add   HL, DE 
1466			 
1466 44			      ld    B, H                    ; Move want to BC 
1467 4d			      ld    C, L 
1468			 
1468 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
146b dd 75 04		      ld    (IX+4), L 
146e dd 74 05		      ld    (IX+5), H 
1471			 
1471 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1472 23			      inc   HL 
1473 56			      ld    D, (HL) 
1474 dd 73 02		      ld    (IX+2), E 
1477 dd 72 03		      ld    (IX+3), D 
147a eb			      ex    DE, HL                  ; this_free ptr into HL 
147b			 
147b					if DEBUG_FORTH_MALLOC 
147b						DMARK "maB" 
147b						CALLMONITOR 
147b					endif 
147b			      ; Loop through free block list to find some space 
147b			malloc_find_space: 
147b 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
147c 23			      inc   HL 
147d 56			      ld    D, (HL) 
147e			 
147e 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
147f b3			      or    E 
1480 ca 0c 15		      jp    Z, malloc_no_space 
1483			 
1483 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1486 dd 72 01		      ld    (IX+1), D 
1489			 
1489			      ; Does this block have enough space to make the allocation? 
1489 23			      inc   HL                      ; Load free block size into DE 
148a 5e			      ld    E, (HL) 
148b 23			      inc   HL 
148c 56			      ld    D, (HL) 
148d			 
148d eb			      ex    DE, HL                  ; Check size of block against want 
148e b7			      or    A                       ; Ensure carry flag clear 
148f ed 42		      sbc   HL, BC 
1491 e5			      push  HL                      ; Store the result for later (new block size) 
1492			 
1492 ca e1 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1495 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1497			 
1497			      ; this_free block is not big enough, setup ptrs to test next free block 
1497 e1			      pop   HL                      ; Discard previous result 
1498			 
1498 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
149b dd 66 03		      ld    H, (IX+3) 
149e dd 75 04		      ld    (IX+4), L 
14a1 dd 74 05		      ld    (IX+5), H 
14a4			 
14a4 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
14a7 dd 66 01		      ld    H, (IX+1) 
14aa dd 75 02		      ld    (IX+2), L 
14ad dd 74 03		      ld    (IX+3), H 
14b0			 
14b0					if DEBUG_FORTH_MALLOC 
14b0						DMARK "MA>" 
14b0						CALLMONITOR 
14b0					endif 
14b0 18 c9		      jr    malloc_find_space 
14b2			 
14b2			      ; split a bigger block into two - requested size and remaining size 
14b2			malloc_alloc_split: 
14b2					if DEBUG_FORTH_MALLOC 
14b2						DMARK "MAs" 
14b2						CALLMONITOR 
14b2					endif 
14b2 eb			      ex    DE, HL                  ; Calculate address of new free block 
14b3 2b			      dec   HL 
14b4 2b			      dec   HL 
14b5 2b			      dec   HL 
14b6 09			      add   HL, BC 
14b7			 
14b7			      ; Create a new block and point it at next_free 
14b7 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
14ba dd 56 01		      ld    D, (IX+1) 
14bd			 
14bd 73			      ld    (HL), E                 ; Store next_free ptr into new block 
14be 23			      inc   HL 
14bf 72			      ld    (HL), D 
14c0			 
14c0 d1			      pop   DE                      ; Store size of new block into new block 
14c1 23			      inc   HL 
14c2 73			      ld    (HL), E 
14c3 23			      inc   HL 
14c4 72			      ld    (HL), D 
14c5			 
14c5			      ; Update this_free ptr to point to new block 
14c5 2b			      dec   HL 
14c6 2b			      dec   HL 
14c7 2b			      dec   HL 
14c8			 
14c8 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
14cb dd 56 03		      ld    D, (IX+3) 
14ce			 
14ce dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
14d1 dd 74 03		      ld    (IX+3), H 
14d4			 
14d4			      ; Modify this_free block to be allocation 
14d4 eb			      ex    DE, HL 
14d5 af			      xor   A                       ; Null the next block ptr of allocated block 
14d6 77			      ld    (HL), A 
14d7 23			      inc   HL 
14d8 77			      ld    (HL), A 
14d9			 
14d9 23			      inc   HL                      ; Store want size into allocated block 
14da 71			      ld    (HL), C 
14db 23			      inc   HL 
14dc 70			      ld    (HL), B 
14dd 23			      inc   HL 
14de e5			      push  HL                      ; Address of allocation to return 
14df			 
14df 18 19		      jr    malloc_update_links 
14e1			 
14e1			malloc_alloc_fit: 
14e1 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
14e2			 
14e2					if DEBUG_FORTH_MALLOC 
14e2						DMARK "MAf" 
14e2						CALLMONITOR 
14e2					endif 
14e2			      ; Modify this_free block to be allocation 
14e2 eb			      ex    DE, HL 
14e3 2b			      dec   HL 
14e4 2b			      dec   HL 
14e5 2b			      dec   HL 
14e6			 
14e6 af			      xor   A                       ; Null the next block ptr of allocated block 
14e7 77			      ld    (HL), A 
14e8 23			      inc   HL 
14e9 77			      ld    (HL), A 
14ea			 
14ea 23			      inc   HL                      ; Store address of allocation to return 
14eb 23			      inc   HL 
14ec 23			      inc   HL 
14ed e5			      push  HL 
14ee			 
14ee			      ; Copy next_free ptr to this_free, remove allocated block from free list 
14ee dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
14f1 dd 66 01		      ld    H, (IX+1) 
14f4			 
14f4 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
14f7 dd 74 03		      ld    (IX+3), H 
14fa			 
14fa			 
14fa			malloc_update_links: 
14fa			      ; Update prev_free ptr to point to this_free 
14fa dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
14fd dd 66 05		      ld    H, (IX+5) 
1500			 
1500 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1503 dd 56 03		      ld    D, (IX+3) 
1506			 
1506 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1507 23			      inc   HL 
1508 72			      ld    (HL), D 
1509			 
1509					if DEBUG_FORTH_MALLOC 
1509						DMARK "Mul" 
1509						CALLMONITOR 
1509					endif 
1509			      ; Clear the Z flag to indicate successful allocation 
1509 7a			      ld    A, D 
150a b3			      or    E 
150b			 
150b d1			      pop   DE                      ; Address of allocation 
150c					if DEBUG_FORTH_MALLOC 
150c						DMARK "MAu" 
150c						CALLMONITOR 
150c					endif 
150c			 
150c			malloc_no_space: 
150c 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
150f 39			      add   HL, SP 
1510 f9			      ld    SP, HL 
1511			 
1511 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1512					if DEBUG_FORTH_MALLOC 
1512						DMARK "MAN" 
1512						CALLMONITOR 
1512					endif 
1512			 
1512			malloc_early_exit: 
1512					if DEBUG_FORTH_MALLOC 
1512						DMARK "MAx" 
1512						CALLMONITOR 
1512					endif 
1512 dd e1		      pop   IX 
1514 d1			      pop   DE 
1515 c1			      pop   BC 
1516			 
1516			if DEBUG_FORTH_MALLOC_HIGH 
1516			call malloc_guard_exit 
1516			call malloc_guard_zerolen 
1516			endif 
1516 c9			      ret 
1517			 
1517			 
1517			;------------------------------------------------------------------------------ 
1517			;     free                                                                    : 
1517			;                                                                             : 
1517			; Description                                                                 : 
1517			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1517			;     returned by malloc, otherwise the behaviour is undefined.               : 
1517			;                                                                             : 
1517			;     Where possible, directly adjacent free blocks will be merged together   : 
1517			;     into larger blocks to help ensure that the heap does not become         : 
1517			;     excessively fragmented.                                                 : 
1517			;                                                                             : 
1517			;     free does not clear or set any other value into the freed space, and    : 
1517			;     therefore its contents may be visible through subsequent malloc's. The  : 
1517			;     caller should clear the freed space as required.                        : 
1517			;                                                                             : 
1517			;     This implementation of free uses the stack exclusively, and is          : 
1517			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1517			;     advisable to disable interrupts before calling free, and recommended    : 
1517			;     to avoid the use of free inside ISRs in general.                        : 
1517			;                                                                             : 
1517			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1517			;                                                                             : 
1517			; Parameters                                                                  : 
1517			;     HL  Pointer to address of first byte of allocation to be freed          : 
1517			;                                                                             : 
1517			; Returns                                                                     : 
1517			;     Nothing                                                                 : 
1517			;                                                                             : 
1517			; Stack frame                                                                 : 
1517			;       |             |                                                       : 
1517			;       +-------------+                                                       : 
1517			;       |     BC      |                                                       : 
1517			;       +-------------+                                                       : 
1517			;       |     DE      |                                                       : 
1517			;       +-------------+                                                       : 
1517			;       |     IX      |                                                       : 
1517			;       +-------------+                                                       : 
1517			;       |  prev_free  |                                                       : 
1517			;   +2  +-------------+                                                       : 
1517			;       |  next_free  |                                                       : 
1517			;   +0  +-------------+                                                       : 
1517			;       |             |                                                       : 
1517			;                                                                             : 
1517			;------------------------------------------------------------------------------ 
1517			free: 
1517 c5			      push  BC 
1518 d5			      push  DE 
1519 dd e5		      push  IX 
151b			 
151b 7c			      ld    A, H                    ; Exit if ptr is null 
151c b5			      or    L 
151d ca e1 15		      jp    Z, free_early_exit 
1520			 
1520			      ; Set up stack frame 
1520 eb			      ex    DE, HL 
1521 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1524 39			      add   HL, SP 
1525 f9			      ld    SP, HL 
1526 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
152a dd 39		      add   IX, SP 
152c			 
152c			      ; The address in HL points to the start of the useable allocated space, 
152c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
152c			      ; address of the block itself. 
152c eb			      ex    DE, HL 
152d 11 fc ff		      ld    DE, -4 
1530 19			      add   HL, DE 
1531			 
1531			      ; An allocated block must have a null next block pointer in it 
1531 7e			      ld    A, (HL) 
1532 23			      inc   HL 
1533 b6			      or    (HL) 
1534 c2 dc 15		      jp    NZ, free_done 
1537			 
1537 2b			      dec   HL 
1538			 
1538 44			      ld    B, H                    ; Copy HL to BC 
1539 4d			      ld    C, L 
153a			 
153a			      ; Loop through the free list to find the first block with an address 
153a			      ; higher than the block being freed 
153a 21 0a 80		      ld    HL, free_list 
153d			 
153d			free_find_higher_block: 
153d 5e			      ld    E, (HL)                 ; Load next ptr from free block 
153e 23			      inc   HL 
153f 56			      ld    D, (HL) 
1540 2b			      dec   HL 
1541			 
1541 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1544 dd 72 01		      ld    (IX+1), D 
1547 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
154a dd 74 03		      ld    (IX+3), H 
154d			 
154d 78			      ld    A, B                    ; Check if DE is greater than BC 
154e ba			      cp    D                       ; Compare MSB first 
154f 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1551 30 04		      jr    NC, free_find_higher_block_skip 
1553 79			      ld    A, C 
1554 bb			      cp    E                       ; Then compare LSB 
1555 38 08		      jr    C, free_found_higher_block 
1557			 
1557			free_find_higher_block_skip: 
1557 7a			      ld    A, D                    ; Reached the end of the free list? 
1558 b3			      or    E 
1559 ca dc 15		      jp    Z, free_done 
155c			 
155c eb			      ex    DE, HL 
155d			 
155d 18 de		      jr    free_find_higher_block 
155f			 
155f			free_found_higher_block: 
155f			      ; Insert freed block between prev and next free blocks 
155f 71			      ld    (HL), C                 ; Point prev free block to freed block 
1560 23			      inc   HL 
1561 70			      ld    (HL), B 
1562			 
1562 60			      ld    H, B                    ; Point freed block at next free block 
1563 69			      ld    L, C 
1564 73			      ld    (HL), E 
1565 23			      inc   HL 
1566 72			      ld    (HL), D 
1567			 
1567			      ; Check if the freed block is adjacent to the next free block 
1567 23			      inc   HL                      ; Load size of freed block into HL 
1568 5e			      ld    E, (HL) 
1569 23			      inc   HL 
156a 56			      ld    D, (HL) 
156b eb			      ex    DE, HL 
156c			 
156c 09			      add   HL, BC                  ; Add addr of freed block and its size 
156d			 
156d dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1570 dd 56 01		      ld    D, (IX+1) 
1573			 
1573 b7			      or    A                       ; Clear the carry flag 
1574 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1576 20 22		      jr    NZ, free_check_adjacent_to_prev 
1578			 
1578			      ; Freed block is adjacent to next, merge into one bigger block 
1578 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
1579 5e			      ld    E, (HL) 
157a 23			      inc   HL 
157b 56			      ld    D, (HL) 
157c e5			      push  HL                      ; Save ptr to next block for later 
157d			 
157d 60			      ld    H, B                    ; Store ptr from next block into freed block 
157e 69			      ld    L, C 
157f 73			      ld    (HL), E 
1580 23			      inc   HL 
1581 72			      ld    (HL), D 
1582			 
1582 e1			      pop   HL                      ; Restore ptr to next block 
1583 23			      inc   HL                      ; Load size of next block into DE 
1584 5e			      ld    E, (HL) 
1585 23			      inc   HL 
1586 56			      ld    D, (HL) 
1587 d5			      push  DE                      ; Save next block size for later 
1588			 
1588 60			      ld    H, B                    ; Load size of freed block into HL 
1589 69			      ld    L, C 
158a 23			      inc   HL 
158b 23			      inc   HL 
158c 5e			      ld    E, (HL) 
158d 23			      inc   HL 
158e 56			      ld    D, (HL) 
158f eb			      ex    DE, HL 
1590			 
1590 d1			      pop   DE                      ; Restore size of next block 
1591 19			      add   HL, DE                  ; Add sizes of both blocks 
1592 eb			      ex    DE, HL 
1593			 
1593 60			      ld    H, B                    ; Store new bigger size into freed block 
1594 69			      ld    L, C 
1595 23			      inc   HL 
1596 23			      inc   HL 
1597 73			      ld    (HL), E 
1598 23			      inc   HL 
1599 72			      ld    (HL), D 
159a			 
159a			free_check_adjacent_to_prev: 
159a			      ; Check if the freed block is adjacent to the prev free block 
159a dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
159d dd 66 03		      ld    H, (IX+3) 
15a0			 
15a0 23			      inc   HL                      ; Size of prev free block into DE 
15a1 23			      inc   HL 
15a2 5e			      ld    E, (HL) 
15a3 23			      inc   HL 
15a4 56			      ld    D, (HL) 
15a5 2b			      dec   HL 
15a6 2b			      dec   HL 
15a7 2b			      dec   HL 
15a8			 
15a8 19			      add   HL, DE                  ; Add prev block addr and size 
15a9			 
15a9 b7			      or    A                       ; Clear the carry flag 
15aa ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15ac 20 2e		      jr    NZ, free_done 
15ae			 
15ae			      ; Freed block is adjacent to prev, merge into one bigger block 
15ae 60			      ld    H, B                    ; Load next ptr from freed block into DE 
15af 69			      ld    L, C 
15b0 5e			      ld    E, (HL) 
15b1 23			      inc   HL 
15b2 56			      ld    D, (HL) 
15b3 e5			      push  HL                      ; Save freed block ptr for later 
15b4			 
15b4 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
15b7 dd 66 03		      ld    H, (IX+3) 
15ba 73			      ld    (HL), E 
15bb 23			      inc   HL 
15bc 72			      ld    (HL), D 
15bd			 
15bd e1			      pop   HL                      ; Restore freed block ptr 
15be 23			      inc   HL                      ; Load size of freed block into DE 
15bf 5e			      ld    E, (HL) 
15c0 23			      inc   HL 
15c1 56			      ld    D, (HL) 
15c2 d5			      push  DE                      ; Save freed block size for later 
15c3			 
15c3 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
15c6 dd 66 03		      ld    H, (IX+3) 
15c9 23			      inc   HL 
15ca 23			      inc   HL 
15cb 5e			      ld    E, (HL) 
15cc 23			      inc   HL 
15cd 56			      ld    D, (HL) 
15ce			 
15ce e1			      pop   HL                      ; Add sizes of both blocks 
15cf 19			      add   HL, DE 
15d0 eb			      ex    DE, HL 
15d1			 
15d1 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
15d4 dd 66 03		      ld    H, (IX+3) 
15d7 23			      inc   HL 
15d8 23			      inc   HL 
15d9 73			      ld    (HL), E 
15da 23			      inc   HL 
15db 72			      ld    (HL), D 
15dc			 
15dc			free_done: 
15dc 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
15df 39			      add   HL, SP 
15e0 f9			      ld    SP, HL 
15e1			 
15e1			free_early_exit: 
15e1 dd e1		      pop   IX 
15e3 d1			      pop   DE 
15e4 c1			      pop   BC 
15e5			 
15e5 c9			      ret 
15e6			 
15e6			; moved to firmware.asm 
15e6			; 
15e6			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15e6			;                  .dw   0 
15e6			 
15e6			 
15e6			endif 
15e6			 
15e6			 
15e6			if MALLOC_3 
15e6			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
15e6			;heap_start        .equ  0x9000      ; Starting address of heap 
15e6			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
15e6			; 
15e6			 ;     .org 0 
15e6			  ;    jp    main 
15e6			; 
15e6			; 
15e6			 ;     .org  0x100 
15e6			;main: 
15e6			 ;     ld    HL, 0x8100 
15e6			  ;    ld    SP, HL 
15e6			; 
15e6			;      call  heap_init 
15e6			 
15e6			      ; Make some allocations 
15e6			;      ld    HL, 12 
15e6			;      call  malloc            ; Allocates 0x9004 
15e6			; 
15e6			 ;     ld    HL, 12 
15e6			;      call  malloc            ; Allocates 0x9014 
15e6			 
15e6			;      ld    HL, 12 
15e6			;      call  malloc            ; Allocates 0x9024 
15e6			 
15e6			      ; Free some allocations 
15e6			;      ld    HL, 0x9014 
15e6			;      call  free 
15e6			 
15e6			;      ld    HL, 0x9004 
15e6			;      call  free 
15e6			; 
15e6			;      ld    HL, 0x9024 
15e6			;      call  free 
15e6			 
15e6			 
15e6			 ;     halt 
15e6			 
15e6			 
15e6			;------------------------------------------------------------------------------ 
15e6			;     heap_init                                                               : 
15e6			;                                                                             : 
15e6			; Description                                                                 : 
15e6			;     Initialise the heap and make it ready for malloc and free operations.   : 
15e6			;                                                                             : 
15e6			;     The heap is maintained as a linked list, starting with an initial       : 
15e6			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
15e6			;     the first free block in the heap. Each block then points to the next    : 
15e6			;     free block within the heap, and the free list ends at the first block   : 
15e6			;     with a null pointer to the next free block.                             : 
15e6			;                                                                             : 
15e6			; Parameters                                                                  : 
15e6			;     Inputs are compile-time only. Two defines which specify the starting    : 
15e6			;     address of the heap and its size are required, along with a memory      : 
15e6			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
15e6			;     principally stores a pointer to the first free block in the heap.       : 
15e6			;                                                                             : 
15e6			; Returns                                                                     : 
15e6			;     Nothing                                                                 : 
15e6			;------------------------------------------------------------------------------ 
15e6			heap_init: 
15e6			      push  HL 
15e6			 
15e6			      ; Initialise free list struct 
15e6			      ld    HL, heap_start 
15e6			      ld    (free_list), HL 
15e6			      ld    HL, 0 
15e6			      ld    (free_list+2), HL 
15e6			 
15e6			      ; Insert first free block at bottom of heap, consumes entire heap 
15e6			      ld    HL, heap_start+heap_size-4 
15e6			      ld    (heap_start), HL        ; Next block (end of free list) 
15e6			      ld    HL, heap_size-4 
15e6			      ld    (heap_start+2), HL      ; Block size 
15e6			 
15e6			      ; Insert end of free list block at top of heap - two null words will 
15e6			      ; terminate the free list 
15e6			      ld    HL, 0 
15e6			      ld    (heap_start+heap_size-2), HL 
15e6			      ld    (heap_start+heap_size-4), HL 
15e6			 
15e6			      pop   HL 
15e6			 
15e6			      ret 
15e6			 
15e6			 
15e6			;------------------------------------------------------------------------------ 
15e6			;     malloc                                                                  : 
15e6			;                                                                             : 
15e6			; Description                                                                 : 
15e6			;     Allocates the wanted space from the heap and returns the address of the : 
15e6			;     first useable byte of the allocation.                                   : 
15e6			;                                                                             : 
15e6			;     Allocations can happen in one of two ways:                              : 
15e6			;                                                                             : 
15e6			;     1. A free block may be found which is the exact size wanted. In this    : 
15e6			;        case the block is removed from the free list and retuedn to the      : 
15e6			;        caller.                                                              : 
15e6			;     2. A free block may be found which is larger than the size wanted. In   : 
15e6			;        this case, the larger block is split into two. The first portion of  : 
15e6			;        this block will become the requested space by the malloc call and    : 
15e6			;        is returned to the caller. The second portion becomes a new free     : 
15e6			;        block, and the free list is adjusted to maintain continuity via this : 
15e6			;        newly created block.                                                 : 
15e6			;                                                                             : 
15e6			;     malloc does not set any initial value in the allocated space, the       : 
15e6			;     caller is required to do this as required.                              : 
15e6			;                                                                             : 
15e6			;     This implementation of malloc uses the stack exclusively, and is        : 
15e6			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15e6			;     advisable to disable interrupts before calling malloc, and recommended  : 
15e6			;     to avoid the use of malloc inside ISRs in general.                      : 
15e6			;                                                                             : 
15e6			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15e6			;                                                                             : 
15e6			; Parameters                                                                  : 
15e6			;     HL  Number of bytes wanted                                              : 
15e6			;                                                                             : 
15e6			; Returns                                                                     : 
15e6			;     HL  Address of the first useable byte of the allocation                 : 
15e6			;                                                                             : 
15e6			; Flags                                                                       : 
15e6			;     Z   Set if the allocation did not succeed, clear otherwise              : 
15e6			;                                                                             : 
15e6			; Stack frame                                                                 : 
15e6			;       |             |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |     BC      |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |     DE      |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |     IX      |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |  prev_free  |                                                       : 
15e6			;   +4  +-------------+                                                       : 
15e6			;       |  this_free  |                                                       : 
15e6			;   +2  +-------------+                                                       : 
15e6			;       |  next_free  |                                                       : 
15e6			;   +0  +-------------+                                                       : 
15e6			;       |             |                                                       : 
15e6			;                                                                             : 
15e6			;------------------------------------------------------------------------------ 
15e6			malloc: 
15e6			      push  BC 
15e6			      push  DE 
15e6			      push  IX 
15e6			 
15e6			      ld    A, H                    ; Exit if no space requested 
15e6			      or    L 
15e6			      jp    Z, malloc_early_exit 
15e6			 
15e6			      ; Set up stack frame 
15e6			      ex    DE, HL 
15e6			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
15e6			      add   HL, SP 
15e6			      ld    SP, HL 
15e6			      ld    IX, 0                   ; Use IX as a frame pointer 
15e6			      add   IX, SP 
15e6			 
15e6			      ; Setup initial state 
15e6			      ld    HL, 4                   ; want must also include space used by block struct 
15e6			      add   HL, DE 
15e6			 
15e6			      ld    B, H                    ; Move want to BC 
15e6			      ld    C, L 
15e6			 
15e6			      ld    HL, free_list           ; Store prev_free ptr to stack 
15e6			      ld    (IX+4), L 
15e6			      ld    (IX+5), H 
15e6			 
15e6			      ld    E, (HL)                 ; Store this_free ptr to stack 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      ld    (IX+2), E 
15e6			      ld    (IX+3), D 
15e6			      ex    DE, HL                  ; this_free ptr into HL 
15e6			 
15e6			      ; Loop through free block list to find some space 
15e6			malloc_find_space: 
15e6			      ld    E, (HL)                 ; Load next_free ptr into DE 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			 
15e6			      ld    A, D                    ; Check for null next_free ptr - end of free list 
15e6			      or    E 
15e6			      jp    Z, malloc_no_space 
15e6			 
15e6			      ld    (IX+0), E               ; Store next_free ptr to stack 
15e6			      ld    (IX+1), D 
15e6			 
15e6			      ; Does this block have enough space to make the allocation? 
15e6			      inc   HL                      ; Load free block size into DE 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			 
15e6			      ex    DE, HL                  ; Check size of block against want 
15e6			      or    A                       ; Ensure carry flag clear 
15e6			      sbc   HL, BC 
15e6			      push  HL                      ; Store the result for later (new block size) 
15e6			 
15e6			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
15e6			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
15e6			 
15e6			      ; this_free block is not big enough, setup ptrs to test next free block 
15e6			      pop   HL                      ; Discard previous result 
15e6			 
15e6			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
15e6			      ld    H, (IX+3) 
15e6			      ld    (IX+4), L 
15e6			      ld    (IX+5), H 
15e6			 
15e6			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
15e6			      ld    H, (IX+1) 
15e6			      ld    (IX+2), L 
15e6			      ld    (IX+3), H 
15e6			 
15e6			      jr    malloc_find_space 
15e6			 
15e6			      ; split a bigger block into two - requested size and remaining size 
15e6			malloc_alloc_split: 
15e6			      ex    DE, HL                  ; Calculate address of new free block 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			      add   HL, BC 
15e6			 
15e6			      ; Create a new block and point it at next_free 
15e6			      ld    E, (IX+0)               ; Load next_free ptr into DE 
15e6			      ld    D, (IX+1) 
15e6			 
15e6			      ld    (HL), E                 ; Store next_free ptr into new block 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			      pop   DE                      ; Store size of new block into new block 
15e6			      inc   HL 
15e6			      ld    (HL), E 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			      ; Update this_free ptr to point to new block 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			 
15e6			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
15e6			      ld    D, (IX+3) 
15e6			 
15e6			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
15e6			      ld    (IX+3), H 
15e6			 
15e6			      ; Modify this_free block to be allocation 
15e6			      ex    DE, HL 
15e6			      xor   A                       ; Null the next block ptr of allocated block 
15e6			      ld    (HL), A 
15e6			      inc   HL 
15e6			      ld    (HL), A 
15e6			 
15e6			      inc   HL                      ; Store want size into allocated block 
15e6			      ld    (HL), C 
15e6			      inc   HL 
15e6			      ld    (HL), B 
15e6			      inc   HL 
15e6			      push  HL                      ; Address of allocation to return 
15e6			 
15e6			      jr    malloc_update_links 
15e6			 
15e6			malloc_alloc_fit: 
15e6			      pop   HL                      ; Dont need new block size, want is exact fit 
15e6			 
15e6			      ; Modify this_free block to be allocation 
15e6			      ex    DE, HL 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			 
15e6			      xor   A                       ; Null the next block ptr of allocated block 
15e6			      ld    (HL), A 
15e6			      inc   HL 
15e6			      ld    (HL), A 
15e6			 
15e6			      inc   HL                      ; Store address of allocation to return 
15e6			      inc   HL 
15e6			      inc   HL 
15e6			      push  HL 
15e6			 
15e6			      ; Copy next_free ptr to this_free, remove allocated block from free list 
15e6			      ld    L, (IX+0)               ; next_free to HL 
15e6			      ld    H, (IX+1) 
15e6			 
15e6			      ld    (IX+2), L               ; HL to this_free 
15e6			      ld    (IX+3), H 
15e6			 
15e6			 
15e6			malloc_update_links: 
15e6			      ; Update prev_free ptr to point to this_free 
15e6			      ld    L, (IX+4)               ; prev_free ptr to HL 
15e6			      ld    H, (IX+5) 
15e6			 
15e6			      ld    E, (IX+2)               ; this_free ptr to DE 
15e6			      ld    D, (IX+3) 
15e6			 
15e6			      ld    (HL), E                 ; this_free ptr into prev_free 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			      ; Clear the Z flag to indicate successful allocation 
15e6			      ld    A, D 
15e6			      or    E 
15e6			 
15e6			      pop   DE                      ; Address of allocation 
15e6			 
15e6			malloc_no_space: 
15e6			      ld    HL, 6                   ; Clean up stack frame 
15e6			      add   HL, SP 
15e6			      ld    SP, HL 
15e6			 
15e6			      ex    DE, HL                  ; Alloc addr into HL for return 
15e6			 
15e6			malloc_early_exit: 
15e6			      pop   IX 
15e6			      pop   DE 
15e6			      pop   BC 
15e6			 
15e6			      ret 
15e6			 
15e6			 
15e6			;------------------------------------------------------------------------------ 
15e6			;     free                                                                    : 
15e6			;                                                                             : 
15e6			; Description                                                                 : 
15e6			;     Return the space pointed to by HL to the heap. HL must be an address as : 
15e6			;     returned by malloc, otherwise the behaviour is undefined.               : 
15e6			;                                                                             : 
15e6			;     Where possible, directly adjacent free blocks will be merged together   : 
15e6			;     into larger blocks to help ensure that the heap does not become         : 
15e6			;     excessively fragmented.                                                 : 
15e6			;                                                                             : 
15e6			;     free does not clear or set any other value into the freed space, and    : 
15e6			;     therefore its contents may be visible through subsequent malloc's. The  : 
15e6			;     caller should clear the freed space as required.                        : 
15e6			;                                                                             : 
15e6			;     This implementation of free uses the stack exclusively, and is          : 
15e6			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15e6			;     advisable to disable interrupts before calling free, and recommended    : 
15e6			;     to avoid the use of free inside ISRs in general.                        : 
15e6			;                                                                             : 
15e6			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15e6			;                                                                             : 
15e6			; Parameters                                                                  : 
15e6			;     HL  Pointer to address of first byte of allocation to be freed          : 
15e6			;                                                                             : 
15e6			; Returns                                                                     : 
15e6			;     Nothing                                                                 : 
15e6			;                                                                             : 
15e6			; Stack frame                                                                 : 
15e6			;       |             |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |     BC      |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |     DE      |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |     IX      |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |  prev_free  |                                                       : 
15e6			;   +2  +-------------+                                                       : 
15e6			;       |  next_free  |                                                       : 
15e6			;   +0  +-------------+                                                       : 
15e6			;       |             |                                                       : 
15e6			;                                                                             : 
15e6			;------------------------------------------------------------------------------ 
15e6			free: 
15e6			      push  BC 
15e6			      push  DE 
15e6			      push  IX 
15e6			 
15e6			      ld    A, H                    ; Exit if ptr is null 
15e6			      or    L 
15e6			      jp    Z, free_early_exit 
15e6			 
15e6			      ; Set up stack frame 
15e6			      ex    DE, HL 
15e6			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
15e6			      add   HL, SP 
15e6			      ld    SP, HL 
15e6			      ld    IX, 0                   ; Use IX as a frame pointer 
15e6			      add   IX, SP 
15e6			 
15e6			      ; The address in HL points to the start of the useable allocated space, 
15e6			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
15e6			      ; address of the block itself. 
15e6			      ex    DE, HL 
15e6			      ld    DE, -4 
15e6			      add   HL, DE 
15e6			 
15e6			      ; An allocated block must have a null next block pointer in it 
15e6			      ld    A, (HL) 
15e6			      inc   HL 
15e6			      or    (HL) 
15e6			      jp    NZ, free_done 
15e6			 
15e6			      dec   HL 
15e6			 
15e6			      ld    B, H                    ; Copy HL to BC 
15e6			      ld    C, L 
15e6			 
15e6			      ; Loop through the free list to find the first block with an address 
15e6			      ; higher than the block being freed 
15e6			      ld    HL, free_list 
15e6			 
15e6			free_find_higher_block: 
15e6			      ld    E, (HL)                 ; Load next ptr from free block 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      dec   HL 
15e6			 
15e6			      ld    (IX+0), E               ; Save ptr to next free block 
15e6			      ld    (IX+1), D 
15e6			      ld    (IX+2), L               ; Save ptr to prev free block 
15e6			      ld    (IX+3), H 
15e6			 
15e6			      ld    A, B                    ; Check if DE is greater than BC 
15e6			      cp    D                       ; Compare MSB first 
15e6			      jr    Z, $+4                  ; MSB the same, compare LSB 
15e6			      jr    NC, free_find_higher_block_skip 
15e6			      ld    A, C 
15e6			      cp    E                       ; Then compare LSB 
15e6			      jr    C, free_found_higher_block 
15e6			 
15e6			free_find_higher_block_skip: 
15e6			      ld    A, D                    ; Reached the end of the free list? 
15e6			      or    E 
15e6			      jp    Z, free_done 
15e6			 
15e6			      ex    DE, HL 
15e6			 
15e6			      jr    free_find_higher_block 
15e6			 
15e6			free_found_higher_block: 
15e6			      ; Insert freed block between prev and next free blocks 
15e6			      ld    (HL), C                 ; Point prev free block to freed block 
15e6			      inc   HL 
15e6			      ld    (HL), B 
15e6			 
15e6			      ld    H, B                    ; Point freed block at next free block 
15e6			      ld    L, C 
15e6			      ld    (HL), E 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			      ; Check if the freed block is adjacent to the next free block 
15e6			      inc   HL                      ; Load size of freed block into HL 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      ex    DE, HL 
15e6			 
15e6			      add   HL, BC                  ; Add addr of freed block and its size 
15e6			 
15e6			      ld    E, (IX+0)               ; Load addr of next free block into DE 
15e6			      ld    D, (IX+1) 
15e6			 
15e6			      or    A                       ; Clear the carry flag 
15e6			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15e6			      jr    NZ, free_check_adjacent_to_prev 
15e6			 
15e6			      ; Freed block is adjacent to next, merge into one bigger block 
15e6			      ex    DE, HL                  ; Load next ptr from next block into DE 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      push  HL                      ; Save ptr to next block for later 
15e6			 
15e6			      ld    H, B                    ; Store ptr from next block into freed block 
15e6			      ld    L, C 
15e6			      ld    (HL), E 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			      pop   HL                      ; Restore ptr to next block 
15e6			      inc   HL                      ; Load size of next block into DE 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      push  DE                      ; Save next block size for later 
15e6			 
15e6			      ld    H, B                    ; Load size of freed block into HL 
15e6			      ld    L, C 
15e6			      inc   HL 
15e6			      inc   HL 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      ex    DE, HL 
15e6			 
15e6			      pop   DE                      ; Restore size of next block 
15e6			      add   HL, DE                  ; Add sizes of both blocks 
15e6			      ex    DE, HL 
15e6			 
15e6			      ld    H, B                    ; Store new bigger size into freed block 
15e6			      ld    L, C 
15e6			      inc   HL 
15e6			      inc   HL 
15e6			      ld    (HL), E 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			free_check_adjacent_to_prev: 
15e6			      ; Check if the freed block is adjacent to the prev free block 
15e6			      ld    L, (IX+2)               ; Prev free block ptr into HL 
15e6			      ld    H, (IX+3) 
15e6			 
15e6			      inc   HL                      ; Size of prev free block into DE 
15e6			      inc   HL 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			 
15e6			      add   HL, DE                  ; Add prev block addr and size 
15e6			 
15e6			      or    A                       ; Clear the carry flag 
15e6			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15e6			      jr    NZ, free_done 
15e6			 
15e6			      ; Freed block is adjacent to prev, merge into one bigger block 
15e6			      ld    H, B                    ; Load next ptr from freed block into DE 
15e6			      ld    L, C 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      push  HL                      ; Save freed block ptr for later 
15e6			 
15e6			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
15e6			      ld    H, (IX+3) 
15e6			      ld    (HL), E 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			      pop   HL                      ; Restore freed block ptr 
15e6			      inc   HL                      ; Load size of freed block into DE 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      push  DE                      ; Save freed block size for later 
15e6			 
15e6			      ld    L, (IX+2)               ; Load size of prev block into DE 
15e6			      ld    H, (IX+3) 
15e6			      inc   HL 
15e6			      inc   HL 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			 
15e6			      pop   HL                      ; Add sizes of both blocks 
15e6			      add   HL, DE 
15e6			      ex    DE, HL 
15e6			 
15e6			      ld    L, (IX+2)               ; Store new bigger size into prev block 
15e6			      ld    H, (IX+3) 
15e6			      inc   HL 
15e6			      inc   HL 
15e6			      ld    (HL), E 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			free_done: 
15e6			      ld    HL, 4                   ; Clean up stack frame 
15e6			      add   HL, SP 
15e6			      ld    SP, HL 
15e6			 
15e6			free_early_exit: 
15e6			      pop   IX 
15e6			      pop   DE 
15e6			      pop   BC 
15e6			 
15e6			      ret 
15e6			 
15e6			 
15e6			;      .org 0x8000 
15e6			; 
15e6			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15e6			 ;                 .dw   0 
15e6			 
15e6			endif 
15e6			 
15e6			 
15e6			if MALLOC_4 
15e6			 
15e6			; My memory allocation code. Very very simple.... 
15e6			; allocate space under 250 chars 
15e6			 
15e6			heap_init: 
15e6				; init start of heap as zero 
15e6				;  
15e6			 
15e6				ld hl, heap_start 
15e6				ld a, 0 
15e6				ld (hl), a      ; empty block 
15e6				inc hl 
15e6				ld a, 0 
15e6				ld (hl), a      ; length of block 
15e6				; write end of list 
15e6				inc hl 
15e6				ld a,(hl) 
15e6				inc hl 
15e6				ld a,(hl) 
15e6				 
15e6			 
15e6				; init some malloc vars 
15e6			 
15e6				ld hl, 0 
15e6				ld (free_list), hl       ; store last malloc location 
15e6			 
15e6				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
15e6				ld a, 0 
15e6				ld (hl), a 
15e6			 
15e6			 
15e6				ld hl, heap_start 
15e6				;  
15e6				  
15e6				ret 
15e6			 
15e6			 
15e6			;    free block marker 
15e6			;    requested size  
15e6			;    pointer to next block 
15e6			;    .... 
15e6			;    next block marker 
15e6			 
15e6			 
15e6			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
15e6			; 
15e6			 
15e6			 
15e6			malloc:  
15e6				push de 
15e6				push bc 
15e6				push af 
15e6			 
15e6				; hl space required 
15e6				 
15e6				ld c, l    ; hold space   (TODO only a max of 255) 
15e6			 
15e6			;	inc c     ; TODO BUG need to fix memory leak on push str 
15e6			;	inc c 
15e6			;	inc c 
15e6			;	inc c 
15e6			;	inc c 
15e6			;	inc c 
15e6			;	inc c 
15e6			 
15e6			 
15e6			 
15e6				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
15e6			 
15e6				ld a, (free_list+3) 
15e6				cp 0 
15e6				jr z, .contheap 
15e6			 
15e6				ld hl, (free_list)     ; get last alloc 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "mrs" 
15e6						CALLMONITOR 
15e6					endif 
15e6				jr .startalloc 
15e6			 
15e6			.contheap: 
15e6				ld hl, heap_start 
15e6			 
15e6			.startalloc: 
15e6			 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "mym" 
15e6						CALLMONITOR 
15e6					endif 
15e6			.findblock: 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "mmf" 
15e6						CALLMONITOR 
15e6					endif 
15e6			 
15e6				ld a,(hl)  
15e6				; if byte is zero then clear to use 
15e6			 
15e6				cp 0 
15e6				jr z, .foundemptyblock 
15e6			 
15e6				; if byte is not clear 
15e6				;     then byte is offset to next block 
15e6			 
15e6				inc hl 
15e6				ld a, (hl) ; get size 
15e6			.nextblock:	inc hl 
15e6					ld e, (hl) 
15e6					inc hl 
15e6					ld d, (hl) 
15e6					ex de, hl 
15e6			;	inc hl  ; move past the store space 
15e6			;	inc hl  ; move past zero index  
15e6			 
15e6				; TODO detect no more space 
15e6			 
15e6				push hl 
15e6				ld de, heap_end 
15e6				call cmp16 
15e6				pop hl 
15e6				jr nc, .nospace 
15e6			 
15e6				jr .findblock 
15e6			 
15e6			.nospace: ld hl, 0 
15e6				jp .exit 
15e6			 
15e6			 
15e6			.foundemptyblock:	 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "mme" 
15e6						CALLMONITOR 
15e6					endif 
15e6			 
15e6			; TODO has block enough space if reusing??? 
15e6			 
15e6				;  
15e6			 
15e6			; see if this block has been previously used 
15e6				inc hl 
15e6				ld a, (hl) 
15e6				dec hl 
15e6				cp 0 
15e6				jr z, .newblock 
15e6			 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "meR" 
15e6						CALLMONITOR 
15e6					endif 
15e6			 
15e6			; no reusing previously allocated block 
15e6			 
15e6			; is it smaller than previously used? 
15e6				 
15e6				inc hl    ; move to size 
15e6				ld a, c 
15e6				sub (hl)        ; we want c < (hl) 
15e6				dec hl    ; move back to marker 
15e6			        jr z, .findblock 
15e6			 
15e6				; update with the new size which should be lower 
15e6			 
15e6			        ;inc  hl   ; negate next move. move back to size  
15e6			 
15e6			.newblock: 
15e6				; need to be at marker here 
15e6			 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "meN" 
15e6						CALLMONITOR 
15e6					endif 
15e6			 
15e6			 
15e6				ld a, c 
15e6			 
15e6				ld (free_list+3), a	 ; flag resume from last malloc  
15e6				ld (free_list), hl    ; save out last location 
15e6			 
15e6			 
15e6				;inc a     ; space for length byte 
15e6				ld (hl), a     ; save block in use marker 
15e6			 
15e6				inc hl   ; move to space marker 
15e6				ld (hl), a    ; save new space 
15e6			 
15e6				inc hl   ; move to start of allocated area 
15e6				 
15e6			;	push hl     ; save where we are - 1  
15e6			 
15e6			;	inc hl  ; move past zero index  
15e6				; skip space to set down new marker 
15e6			 
15e6				; provide some extra space for now 
15e6			 
15e6				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
15e6				inc a 
15e6				inc a 
15e6			 
15e6				push hl   ; save where we are in the node block 
15e6			 
15e6				call addatohl 
15e6			 
15e6				; write linked list point 
15e6			 
15e6				pop de     ; get our node position 
15e6				ex de, hl 
15e6			 
15e6				ld (hl), e 
15e6				inc hl 
15e6				ld (hl), d 
15e6			 
15e6				inc hl 
15e6			 
15e6				; now at start of allocated data so save pointer 
15e6			 
15e6				push hl 
15e6			 
15e6				; jump to position of next node and setup empty header in DE 
15e6			 
15e6				ex de, hl 
15e6			 
15e6			;	inc hl ; move past end of block 
15e6			 
15e6				ld a, 0 
15e6				ld (hl), a   ; empty marker 
15e6				inc hl 
15e6				ld (hl), a   ; size 
15e6				inc hl  
15e6				ld (hl), a   ; ptr 
15e6				inc hl 
15e6				ld (hl), a   ; ptr 
15e6			 
15e6			 
15e6				pop hl 
15e6			 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "mmr" 
15e6						CALLMONITOR 
15e6					endif 
15e6			 
15e6			.exit: 
15e6				pop af 
15e6				pop bc 
15e6				pop de  
15e6				ret 
15e6			 
15e6			 
15e6			 
15e6			 
15e6			free:  
15e6				push hl 
15e6				push af 
15e6				; get address in hl 
15e6			 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "fre" 
15e6						CALLMONITOR 
15e6					endif 
15e6				; data is at hl - move to block count 
15e6				dec hl 
15e6				dec hl    ; get past pointer 
15e6				dec hl 
15e6			 
15e6				ld a, (hl)    ; need this for a validation check 
15e6			 
15e6				dec hl    ; move to block marker 
15e6			 
15e6				; now check that the block count and block marker are the same  
15e6			        ; this checks that we are on a malloc node and not random memory 
15e6			        ; OK a faint chance this could be a problem but rare - famous last words! 
15e6			 
15e6				ld c, a 
15e6				ld a, (hl)    
15e6			 
15e6				cp c 
15e6				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
15e6			 
15e6				; yes good chance we are on a malloc node 
15e6			 
15e6				ld a, 0      
15e6				ld (hl), a   ; mark as free 
15e6			 
15e6				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
15e6			 
15e6			.freeignore:  
15e6			 
15e6				pop af 
15e6				pop hl 
15e6			 
15e6				ret 
15e6			 
15e6			 
15e6			 
15e6			endif 
15e6			 
15e6			; eof 
# End of file firmware_memory.asm
15e6			  
15e6			; device C  
15e6			if SOUND_ENABLE  
15e6				include "firmware_sound.asm"  
15e6			; Sound abstraction layer 
15e6			 
15e6			; support different sound chips through common interface 
15e6			 
15e6			SOUND_DEVICE_AY: equ 0 
15e6			 
15e6			SOUND_DEVICE: equ Device_A 
15e6			 
15e6			 
15e6			 
15e6			if SOUND_DEVICE_AY 
15e6				include "firmware_sound_ay38910.asm" 
15e6			else 
15e6				include "firmware_sound_sn76489an.asm" 
15e6			 
15e6			; Device support for SN76489AN sound chip 
15e6			 
15e6			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
15e6			; http://danceswithferrets.org/geekblog/?p=93 
15e6			; https://www.smspower.org/Development/SN76489 
15e6			 
15e6			; D0 [ 3] 
15e6			; D1 [ 2] 
15e6			; D2 [ 1] 
15e6			; D3 [15] 
15e6			; D4 [13] 
15e6			; D5 [12] 
15e6			; D6 [11] 
15e6			; D7 [10] 
15e6			; /WE [ 5] 
15e6			; CLK [14] 
15e6			; /OE [ 6] 
15e6			; AUDIO [ 7] 
15e6			; GND 8 
15e6			; +5 16 
15e6			; 
15e6			 
15e6			; Write sequence: 
15e6			; CE low 
15e6			; Data bus 
15e6			; WE low then high 
15e6			; 32 clock cycles / 8ns write time at 4mhz 
15e6			; 
15e6			; https://github.com/jblang/SN76489 
15e6			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
15e6			; Tried: 
15e6			; 
15e6			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
15e6			; 
15e6			; Connected WE to OR too 
15e6			;  
15e6			; That enabled the clock when required 
15e6			; However still random bus corruption. Need further investigation 
15e6			 
15e6			 
15e6			SOUND_LATCH: equ 10000000B 
15e6			SOUND_DATA: equ 0B 
15e6			SOUND_CH0:  equ 0B    ; Tone 
15e6			SOUND_CH1: equ 0100000B        ; Tone 
15e6			SOUND_CH2: equ 1000000B   ; Tone 
15e6			SOUND_CH3: equ 1100000B    ; Noise 
15e6			SOUND_VOL: equ 10000B 
15e6			SOUND_TONE: equ 0B 
15e6			 
15e6			 
15e6			sound_init: 
15e6 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
15e8 cd fd 15			call note_send_byte 
15eb 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
15ed cd fd 15			call note_send_byte 
15f0 cd 89 0c			call delay250ms 
15f3 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
15f5 cd fd 15			call note_send_byte 
15f8 cd 89 0c			call delay250ms 
15fb c9				ret 
15fc			 
15fc			; Play a note 
15fc			; h = note 
15fc			; l = duration 
15fc			; a = channel 
15fc			 
15fc			 
15fc			;  frequ = clock / ( 2 x reg valu x 32 )  
15fc			 
15fc			note:  
15fc				 
15fc			 
15fc c9				ret 
15fd			 
15fd			note_send_byte: 
15fd				; byte in a 
15fd			 
15fd				; we high 
15fd d3 40			out (Device_B), a 
15ff			;	ld a, 1 
15ff			;	call aDelayInMS 
15ff 00				nop  
1600 00				nop  
1601 00				nop  
1602 00				nop  
1603				; we low 
1603 d3 40			out (Device_B), a 
1605			;	ld a, 1 
1605			;	call aDelayInMS 
1605 00				nop  
1606 00				nop  
1607 00				nop  
1608 00				nop  
1609				; we high 
1609 d3 40			out (Device_B), a 
160b			;	ld a, 1 
160b			;	call aDelayInMS 
160b 00				nop  
160c 00				nop  
160d 00				nop  
160e 00				nop  
160f			 
160f			 
160f c9				ret 
1610			 
1610			;void SilenceAllChannels() 
1610			;{ 
1610			;  SendByte(0x9f); 
1610			;  SendByte(0xbf); 
1610			;  SendByte(0xdf); 
1610			;  SendByte(0xff); 
1610			;} 
1610			 
1610			 
1610			; eof 
1610			 
# End of file firmware_sound_sn76489an.asm
1610			endif 
1610			 
1610			 
1610			; Abstraction entry points 
1610			 
1610			; init  
1610			 
1610			; sound_init in specific hardware files 
1610			 
1610			; Play a note 
1610			; h = note 
1610			; l = duration 
1610			; a = channel 
1610			 
1610			;note:     
1610			;	ret 
1610			 
1610			 
1610			 
1610			 
1610			; eof 
1610			 
# End of file firmware_sound.asm
1610			endif  
1610			  
1610			include "firmware_diags.asm"  
1610			; Hardware diags menu 
1610			 
1610			 
1610			config: 
1610			 
1610 3e 00			ld a, 0 
1612 21 45 16			ld hl, .configmn 
1615 cd 83 0d			call menu 
1618			 
1618 fe 00			cp 0 
161a c8				ret z 
161b			 
161b fe 01			cp 1 
161d cc 87 16			call z, .savetostore 
1620			 
1620 fe 02			cp 2 
1622			if STARTUP_V1 
1622				call z, .selautoload 
1622			endif 
1622			 
1622			if STARTUP_V2 
1622 cc 57 16			call z, .enautoload 
1625			endif 
1625 fe 03			cp 3 
1627 cc 6e 16			call z, .disautoload 
162a fe 04			cp 4 
162c cc 85 16			call z, .selbank 
162f fe 05			cp 5 
1631 cc c2 18			call z, .debug_tog 
1634 fe 06			cp 6 
1636 cc 05 1a			call z, .bpsgo 
1639 fe 07			cp 7 
163b cc e8 18			call z, hardware_diags 
163e			if STARTUP_V2 
163e fe 08			cp 8 
1640 cc 99 16			call z, create_startup 
1643			endif 
1643 18 cb			jr config 
1645			 
1645			.configmn: 
1645 f6 1b			dw prom_c3 
1647 0d 1c			dw prom_c2 
1649 23 1c			dw prom_c2a 
164b 7d 1c			dw prom_c2b 
164d			;	dw prom_c4 
164d 9a 1c			dw prom_m4 
164f b5 1c			dw prom_m4b 
1651 bd 1c			dw prom_c1 
1653			if STARTUP_V2 
1653 cc 1c			dw prom_c9 
1655			endif 
1655 00 00			dw 0 
1657				 
1657			 
1657			if STARTUP_V2 
1657			.enautoload: 
1657				if STORAGE_SE 
1657 3e fe			ld a, $fe      ; bit 0 clear 
1659 32 63 fa			ld (spi_device), a 
165c			 
165c cd cd 04			call storage_get_block_0 
165f			 
165f 3e 01			ld a, 1 
1661 32 9e fa			ld (store_page+STORE_0_AUTOFILE), a 
1664			 
1664 21 00 00				ld hl, 0 
1667 11 7d fa				ld de, store_page 
166a cd 81 04			call storage_write_block	 ; save update 
166d				else 
166d			 
166d				ld hl, prom_notav 
166d				ld de, prom_empty 
166d				call info_panel 
166d				endif 
166d			 
166d			 
166d c9				ret 
166e			endif 
166e			 
166e			.disautoload: 
166e				if STORAGE_SE 
166e 3e fe			ld a, $fe      ; bit 0 clear 
1670 32 63 fa			ld (spi_device), a 
1673			 
1673 cd cd 04			call storage_get_block_0 
1676			 
1676 3e 00			ld a, 0 
1678 32 9e fa			ld (store_page+STORE_0_AUTOFILE), a 
167b			 
167b 21 00 00				ld hl, 0 
167e 11 7d fa				ld de, store_page 
1681 cd 81 04			call storage_write_block	 ; save update 
1684				else 
1684			 
1684				ld hl, prom_notav 
1684				ld de, prom_empty 
1684				call info_panel 
1684				endif 
1684			 
1684			 
1684 c9				ret 
1685			 
1685			if STARTUP_V1 
1685			 
1685			; Select auto start 
1685			 
1685			.selautoload: 
1685			 
1685				 
1685				if STORAGE_SE 
1685			 
1685					call config_dir 
1685				        ld hl, scratch 
1685					ld a, 0 
1685					call menu 
1685			 
1685					cp 0 
1685					ret z 
1685			 
1685					dec a 
1685			 
1685			 
1685					; locate menu option 
1685			 
1685					ld hl, scratch 
1685					call table_lookup 
1685			 
1685					if DEBUG_FORTH_WORDS 
1685						DMARK "ALl" 
1685						CALLMONITOR 
1685					endif 
1685					; with the pointer to the menu it, the byte following the zero term is the file id 
1685			 
1685					ld a, 0 
1685					ld bc, 50   ; max of bytes to look at 
1685					cpir  
1685			 
1685					if DEBUG_FORTH_WORDS 
1685						DMARK "ALb" 
1685						CALLMONITOR 
1685					endif 
1685					;inc hl 
1685			 
1685					ld a, (hl)   ; file id 
1685					 
1685				        ; save bank and file ids 
1685			 
1685					push af 
1685			 
1685			; TODO need to save to block 0 on bank 1	 
1685			 
1685					call storage_get_block_0 
1685			 
1685					if DEBUG_FORTH_WORDS 
1685						DMARK "AL0" 
1685						CALLMONITOR 
1685					endif 
1685					pop af 
1685			 
1685					ld (store_page+STORE_0_FILERUN),a 
1685					 
1685					; save bank id 
1685			 
1685					ld a,(spi_device) 
1685					ld (store_page+STORE_0_BANKRUN),a 
1685			 
1685					; enable auto run of store file 
1685			 
1685					ld a, 1 
1685					ld (store_page+STORE_0_AUTOFILE),a 
1685			 
1685					; save buffer 
1685			 
1685					ld hl, 0 
1685					ld de, store_page 
1685					if DEBUG_FORTH_WORDS 
1685						DMARK "ALw" 
1685						CALLMONITOR 
1685					endif 
1685				call storage_write_block	 ; save update 
1685			  
1685			 
1685			 
1685			 
1685					ld hl, scratch 
1685					call config_fdir 
1685			 
1685				else 
1685			 
1685				ld hl, prom_notav 
1685				ld de, prom_empty 
1685				call info_panel 
1685			 
1685				endif 
1685				ret 
1685			endif 
1685			 
1685			 
1685			; Select storage bank 
1685			 
1685			.selbank: 
1685			 
1685				if STORAGE_SE 
1685				else 
1685			 
1685				ld hl, prom_notav 
1685				ld de, prom_empty 
1685				call info_panel 
1685				endif 
1685				 
1685 c9				ret 
1686			 
1686			if STORAGE_SE 
1686			 
1686			.config_ldir:   
1686				; Load storage bank labels into menu array 
1686			 
1686				 
1686			 
1686			 
1686 c9				ret 
1687			 
1687			 
1687			endif 
1687			 
1687			 
1687			; Save user words to storage 
1687			 
1687			.savetostore: 
1687			 
1687				if STORAGE_SE 
1687			 
1687 cd 0c 18				call config_dir 
168a 21 c4 f1			        ld hl, scratch 
168d 3e 00				ld a, 0 
168f cd 83 0d				call menu 
1692					 
1692 21 c4 f1				ld hl, scratch 
1695 cd f9 17				call config_fdir 
1698			 
1698				else 
1698			 
1698				ld hl, prom_notav 
1698				ld de, prom_empty 
1698				call info_panel 
1698			 
1698				endif 
1698			 
1698 c9				ret 
1699			 
1699			if STARTUP_V2 
1699			 
1699			create_startup: 
1699			 
1699 3e 00			ld a, 0 
169b 21 eb 17			ld hl, .crstart 
169e cd 83 0d			call menu 
16a1			 
16a1 fe 00			cp 0 
16a3 c8				ret z 
16a4			 
16a4 fe 01			cp 1 
16a6 cc c4 16			call z, .genlsword 
16a9 fe 02			cp 2 
16ab cc ce 16			call z, .genedword 
16ae			 
16ae fe 03			cp 3 
16b0 cc d8 16			call z, .gendemword 
16b3			 
16b3 fe 04			cp 4 
16b5 cc e2 16			call z, .genutlword 
16b8 fe 05			cp 5 
16ba cc ec 16			call z, .genspiword 
16bd fe 06			cp 6 
16bf cc f6 16			call z, .genkeyword 
16c2 18 d5			jr create_startup 
16c4			 
16c4			.genlsword: 
16c4 21 3a 1c			ld hl, crs_s1 
16c7 11 57 17			ld de, .lsworddef 
16ca cd 00 17			call .genfile 
16cd c9				ret 
16ce			 
16ce			.genedword: 
16ce 11 5b 17			ld de, .edworddef 
16d1 21 43 1c			ld hl, crs_s2 
16d4 cd 00 17			call .genfile 
16d7 c9				ret 
16d8			 
16d8			.gendemword: 
16d8 11 63 17			ld de, .demoworddef 
16db 21 4c 1c			ld hl, crs_s3 
16de cd 00 17			call .genfile 
16e1 c9				ret 
16e2			 
16e2			.genutlword: 
16e2 21 5b 1c			ld hl, crs_s4 
16e5 11 43 17			ld de, .utilwordef 
16e8 cd 00 17			call .genfile 
16eb c9				ret 
16ec			.genspiword: 
16ec 21 62 1c			ld hl, crs_s5 
16ef 11 a9 17			ld de, .spiworddef 
16f2 cd 00 17			call .genfile 
16f5 c9				ret 
16f6			.genkeyword: 
16f6 21 6e 1c			ld hl, crs_s6 
16f9 11 bf 17			ld de, .keyworddef 
16fc cd 00 17			call .genfile 
16ff c9				ret 
1700			 
1700			; hl - points to file name 
1700			; de - points to strings to add to file 
1700			 
1700			.genfile: 
1700 e5				push hl 
1701 d5				push de 
1702			 
1702 cd 52 0d			call clear_display 
1705 3e 00			ld a, display_row_1 
1707 11 32 17			ld de, .genfiletxt 
170a cd 65 0d			call str_at_display 
170d cd 75 0d			call update_display 
1710			 
1710 d1				pop de 
1711 e1				pop hl 
1712			 
1712			 
1712 d5				push de 
1713 cd 1f 08			call storage_create 
1716				; id in hl 
1716 d1				pop de   ; table of strings to add 
1717			 
1717			.genloop: 
1717			 
1717 e5				push hl ; save id for next time around 
1718 d5				push de ; save de for next time around 
1719			 
1719 eb				ex de, hl 
171a cd 22 24			call loadwordinhl 
171d eb				ex de, hl 
171e			 
171e				; need hl to be the id 
171e				; need de to be the string ptr 
171e				 
171e cd 0c 0b			call storage_append 
1721			 
1721 d1				pop de 
1722 e1				pop hl 
1723			 
1723 13				inc de 
1724 13				inc de 
1725			 
1725 1a				ld a,(de) 
1726 fe 00			cp 0 
1728 20 ed			jr nz, .genloop 
172a 13				inc de 
172b 1a				ld a, (de) 
172c 1b				dec de 
172d fe 00			cp 0 
172f 20 e6			jr nz, .genloop	 
1731			 
1731 c9				ret 
1732			 
1732 .. 00		.genfiletxt:  db "Creating file...",0 
1743			 
1743			.utilwordef: 
1743 50 63			dw strncpy 
1745 2c 63			dw type 
1747 f9 62			dw clrstack 
1749 b2 62			dw longread 
174b b1 63			dw start1 
174d c1 63			dw start2 
174f d2 63			dw start3b 
1751 4d 64			dw start3c 
1753 ad 64			dw list 
1755 00 00			dw 0 
1757			 
1757			.lsworddef: 
1757 d2 63			dw start3b 
1759 00 00			dw 0 
175b			 
175b			.edworddef: 
175b 40 5f			dw edit1 
175d 61 5f			dw edit2 
175f 96 5f			dw edit3 
1761 00 00			dw 0 
1763			 
1763			.demoworddef: 
1763 f5 68			dw test5 
1765 2d 69			dw test6 
1767 65 69			dw test7 
1769 79 69			dw test8 
176b a5 69			dw test9 
176d bb 69			dw test10 
176f ff 69			dw game1 
1771 10 6a			dw game1a 
1773 72 6a			dw game1b 
1775 a7 6a			dw game1c 
1777 dd 6a			dw game1d 
1779 0e 6b			dw game1s 
177b 22 6b			dw game1t 
177d 37 6b			dw game1f 
177f 6b 6b			dw game1z 
1781 af 6b			dw game1zz 
1783 18 6c			dw ssv2 
1785 4e 6c			dw ssv3 
1787 6a 6c			dw ssv4 
1789 86 6c			dw ssv5 
178b 9f 6c			dw ssv1 
178d e7 6c			dw ssv1cpm	 
178f 3e 6d			dw game2b 
1791 ac 6d			dw game2bf 
1793 f6 6d			dw game2mba 
1795 8c 6e			dw game2mbas	 
1797 b1 6e			dw game2mbht 
1799 c0 6e			dw game2mbms 
179b ce 6e			dw game2mb 
179d 4b 6f			dw game3w 
179f 79 6f			dw game3p 
17a1 97 6f			dw game3sc 
17a3 c8 6f			dw game3vsi 
17a5 f4 6f			dw game3vs 
17a7 00 00			dw 0 
17a9			 
17a9			 
17a9			.spiworddef: 
17a9			 
17a9 ce 5f		    dw spi1 
17ab 27 60		    dw spi2 
17ad b5 60		    dw spi3 
17af 5d 60		    dw spi4 
17b1 88 60		    dw spi5 
17b3 1b 61		    dw spi6 
17b5 70 61		    dw spi7 
17b7			 
17b7 c8 61		    dw spi8 
17b9 e7 61		    dw spi9 
17bb 3f 62		    dw spi10 
17bd 00 00		    dw 0 
17bf			 
17bf			.keyworddef: 
17bf			 
17bf 33 70			dw keyup 
17c1 41 70			dw keydown 
17c3 51 70			dw keyleft 
17c5 61 70			dw keyright 
17c7 72 70			dw 	keyf1 
17c9 80 70			dw keyf2 
17cb 8e 70			dw keyf3 
17cd 9c 70			dw keyf4 
17cf aa 70			dw keyf5 
17d1 b8 70			dw keyf6 
17d3 c6 70			dw keyf7 
17d5 d4 70			dw keyf8 
17d7 e2 70			dw keyf9 
17d9 f0 70			dw keyf10 
17db ff 70			dw keyf11 
17dd 0e 71			dw keyf12 
17df 1d 71			dw keytab 
17e1 2c 71			dw keycr 
17e3 3a 71			dw keyhome 
17e5 4a 71			dw keyend 
17e7 59 71			dw keybs 
17e9 00 00			dw 0 
17eb			 
17eb			.crstart: 
17eb 3a 1c			dw crs_s1 
17ed 43 1c			dw crs_s2 
17ef 4c 1c			dw crs_s3 
17f1 5b 1c			dw crs_s4 
17f3 62 1c			dw crs_s5 
17f5 6e 1c			dw crs_s6 
17f7 00 00			dw 0 
17f9			 
17f9			endif 
17f9			 
17f9			 
17f9			if STORAGE_SE 
17f9			 
17f9			config_fdir: 
17f9				; using the scratch dir go through and release the memory allocated for each string 
17f9				 
17f9 21 c4 f1			ld hl, scratch 
17fc 5e			.cfdir:	ld e,(hl) 
17fd 23				inc hl 
17fe 56				ld d,(hl) 
17ff 23				inc hl 
1800			 
1800 eb				ex de, hl 
1801 cd af 0f			call ishlzero 
1804 c8				ret z     ; return on null pointer 
1805 cd 17 15			call free 
1808 eb				ex de, hl 
1809 18 f1			jr .cfdir 
180b			 
180b			 
180b c9				ret 
180c			 
180c			 
180c			config_dir: 
180c			 
180c				; for the config menus that need to build a directory of storage call this routine 
180c				; it will construct a menu in scratch to pass to menu 
180c			 
180c				; open storage device 
180c			 
180c				; execute DIR to build a list of files and their ids into scratch in menu format 
180c				; once the menu has finished then will need to call config_fdir to release the strings 
180c				 
180c				; c = number items 
180c			 
180c				 
180c cd cd 04			call storage_get_block_0 
180f			 
180f 21 7d fa			ld hl, store_page     ; get current id count 
1812 46				ld b, (hl) 
1813 0e 00			ld c, 0    ; count of files   
1815			 
1815			 
1815 21 c4 f1			ld hl, scratch 
1818 22 74 fa			ld (store_tmp2), hl    ; location to poke strings 
181b			 
181b				; check for empty drive 
181b			 
181b 3e 00			ld a, 0 
181d b8				cp b 
181e ca b8 18			jp z, .dirdone 
1821			 
1821				 
1821					if DEBUG_FORTH_WORDS 
1821						DMARK "Cdc" 
1821 f5				push af  
1822 3a 36 18			ld a, (.dmark)  
1825 32 6e fe			ld (debug_mark),a  
1828 3a 37 18			ld a, (.dmark+1)  
182b 32 6f fe			ld (debug_mark+1),a  
182e 3a 38 18			ld a, (.dmark+2)  
1831 32 70 fe			ld (debug_mark+2),a  
1834 18 03			jr .pastdmark  
1836 ..			.dmark: db "Cdc"  
1839 f1			.pastdmark: pop af  
183a			endm  
# End of macro DMARK
183a						CALLMONITOR 
183a cd fb 19			call break_point_state  
183d				endm  
# End of macro CALLMONITOR
183d					endif 
183d			 
183d			 
183d			.diritem:	 
183d c5				push bc 
183e				; for each of the current ids do a search for them and if found push to stack 
183e			 
183e 21 40 00				ld hl, STORE_BLOCK_PHY 
1841 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
1843 58					ld e,b 
1844			 
1844 cd 4f 07				call storage_findnextid 
1847			 
1847			 
1847					; if found hl will be non zero 
1847			 
1847 cd af 0f				call ishlzero 
184a 28 69				jr z, .dirnotfound 
184c			 
184c					; increase count 
184c			 
184c c1					pop bc	 
184d 0c					inc c 
184e c5					push bc 
184f					 
184f			 
184f					; get file header and push the file name 
184f			 
184f 11 7d fa				ld de, store_page 
1852 cd 1c 04				call storage_read_block 
1855			 
1855					; push file id to stack 
1855				 
1855 3a 7d fa				ld a, (store_page) 
1858 26 00				ld h, 0 
185a 6f					ld l, a 
185b			 
185b					;call forth_push_numhl 
185b					; TODO store id 
185b			 
185b e5					push hl 
185c			 
185c					; push extent count to stack  
185c				 
185c 21 80 fa				ld hl, store_page+3 
185f			 
185f					; get file name length 
185f			 
185f cd e4 13				call strlenz   
1862			 
1862 23					inc hl   ; cover zero term 
1863 23					inc hl  ; stick the id at the end of the area 
1864			 
1864 e5					push hl 
1865 c1					pop bc    ; move length to bc 
1866			 
1866 cd 4d 14				call malloc 
1869			 
1869					; TODO save malloc area to scratch 
1869			 
1869 eb					ex de, hl 
186a 2a 74 fa				ld hl, (store_tmp2) 
186d 73					ld (hl), e 
186e 23					inc hl 
186f 72					ld (hl), d 
1870 23					inc hl 
1871 22 74 fa				ld (store_tmp2), hl 
1874			 
1874					 
1874			 
1874					;pop hl   ; get source 
1874			;		ex de, hl    ; swap aronund	 
1874			 
1874 21 80 fa				ld hl, store_page+3 
1877					if DEBUG_FORTH_WORDS 
1877						DMARK "CFd" 
1877 f5				push af  
1878 3a 8c 18			ld a, (.dmark)  
187b 32 6e fe			ld (debug_mark),a  
187e 3a 8d 18			ld a, (.dmark+1)  
1881 32 6f fe			ld (debug_mark+1),a  
1884 3a 8e 18			ld a, (.dmark+2)  
1887 32 70 fe			ld (debug_mark+2),a  
188a 18 03			jr .pastdmark  
188c ..			.dmark: db "CFd"  
188f f1			.pastdmark: pop af  
1890			endm  
# End of macro DMARK
1890						CALLMONITOR 
1890 cd fb 19			call break_point_state  
1893				endm  
# End of macro CALLMONITOR
1893					endif 
1893 ed b0				ldir 
1895			 
1895					; de is past string, move back one and store id 
1895					 
1895 1b					dec de 
1896			 
1896					; store file id 
1896			 
1896 e1					pop hl 
1897 eb					ex de,hl 
1898 73					ld (hl), e 
1899			 
1899					if DEBUG_FORTH_WORDS 
1899						DMARK "Cdi" 
1899 f5				push af  
189a 3a ae 18			ld a, (.dmark)  
189d 32 6e fe			ld (debug_mark),a  
18a0 3a af 18			ld a, (.dmark+1)  
18a3 32 6f fe			ld (debug_mark+1),a  
18a6 3a b0 18			ld a, (.dmark+2)  
18a9 32 70 fe			ld (debug_mark+2),a  
18ac 18 03			jr .pastdmark  
18ae ..			.dmark: db "Cdi"  
18b1 f1			.pastdmark: pop af  
18b2			endm  
# End of macro DMARK
18b2						CALLMONITOR 
18b2 cd fb 19			call break_point_state  
18b5				endm  
# End of macro CALLMONITOR
18b5					endif 
18b5					 
18b5			.dirnotfound: 
18b5 c1					pop bc     
18b6 10 85				djnz .diritem 
18b8				 
18b8			.dirdone:	 
18b8			 
18b8 3e 00				ld a, 0 
18ba 2a 74 fa				ld hl, (store_tmp2) 
18bd 77					ld (hl), a 
18be 23					inc hl 
18bf 77					ld (hl), a 
18c0 23					inc hl 
18c1					; push a count of the dir items found 
18c1			 
18c1			;		ld h, 0 
18c1			;		ld l, c 
18c1			 
18c1 c9				ret 
18c2			 
18c2			endif 
18c2			 
18c2			 
18c2			; Settings 
18c2			; Run  
18c2			 
18c2			 
18c2			 
18c2			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
18c2			;;hd_menu2:   db "        2: Editor",0   
18c2			;hd_menu2:   db "        2: Editor       6: Menu",0   
18c2			;hd_menu3:   db "        3: Storage",0 
18c2			;hd_menu4:   db "0=quit  4: Debug",0 
18c2			;hd_don:     db "ON",0 
18c2			;hd_doff:     db "OFF",0 
18c2			; 
18c2			; 
18c2			; 
18c2			;hardware_diags_old:       
18c2			; 
18c2			;.diagmenu: 
18c2			;	call clear_display 
18c2			;	ld a, display_row_1 
18c2			;	ld de, hd_menu1 
18c2			;	call str_at_display 
18c2			; 
18c2			;	ld a, display_row_2 
18c2			;	ld de, hd_menu2 
18c2			;	call str_at_display 
18c2			; 
18c2			;	ld a, display_row_3 
18c2			;	ld de, hd_menu3 
18c2			;	call str_at_display 
18c2			; 
18c2			;	ld a,  display_row_4 
18c2			;	ld de, hd_menu4 
18c2			;	call str_at_display 
18c2			; 
18c2			;	; display debug state 
18c2			; 
18c2			;	ld de, hd_don 
18c2			;	ld a, (os_view_disable) 
18c2			;	cp 0 
18c2			;	jr z, .distog 
18c2			;	ld de, hd_doff 
18c2			;.distog: ld a, display_row_4+17 
18c2			;	call str_at_display 
18c2			; 
18c2			;	call update_display 
18c2			; 
18c2			;	call cin_wait 
18c2			; 
18c2			; 
18c2			; 
18c2			;	cp '4' 
18c2			;	jr nz, .diagn1 
18c2			; 
18c2			;	; debug toggle 
18c2			; 
18c2			;	ld a, (os_view_disable) 
18c2			;	ld b, '*' 
18c2			;	cp 0 
18c2			;	jr z, .debtog 
18c2			;	ld b, 0 
18c2			;.debtog:	 
18c2			;	ld a,b 
18c2			;	ld (os_view_disable),a 
18c2			; 
18c2			;.diagn1: cp '0' 
18c2			;	 ret z 
18c2			; 
18c2			;;	cp '1' 
18c2			;;       jp z, matrix	 
18c2			;;   TODO keyboard matrix test 
18c2			; 
18c2			;	cp '2' 
18c2			;	jp z, .diagedit 
18c2			; 
18c2			;;	cp '6' 
18c2			;;	jp z, .menutest 
18c2			;;if ENABLE_BASIC 
18c2			;;	cp '6' 
18c2			;;	jp z, basic 
18c2			;;endif 
18c2			 ; 
18c2			;	jp .diagmenu 
18c2			; 
18c2			; 
18c2			;	ret 
18c2			 
18c2			 
18c2			.debug_tog: 
18c2 21 09 19			ld hl, .menudebug 
18c5				 
18c5 3a b5 f1			ld a, (os_view_disable) 
18c8 fe 2a			cp '*' 
18ca 20 04			jr nz,.tdon  
18cc 3e 01			ld a, 1 
18ce 18 02			jr .tog1 
18d0 3e 00		.tdon: ld a, 0 
18d2			 
18d2			.tog1: 
18d2 cd 83 0d			call menu 
18d5 fe 00			cp 0 
18d7 c8				ret z 
18d8 fe 01			cp 1    ; disable debug 
18da 28 04			jr z, .dtog0 
18dc 3e 2a			ld a, '*' 
18de 18 02			jr .dtogset 
18e0 3e 00		.dtog0: ld a, 0 
18e2 32 b5 f1		.dtogset:  ld (os_view_disable), a 
18e5 c3 c2 18			jp .debug_tog 
18e8			 
18e8			 
18e8			hardware_diags:       
18e8			 
18e8			.diagm: 
18e8 21 fb 18			ld hl, .menuitems 
18eb 3e 00			ld a, 0 
18ed cd 83 0d			call menu 
18f0			 
18f0 fe 00		         cp 0 
18f2 c8				 ret z 
18f3			 
18f3 fe 02			cp 2 
18f5 ca 54 19			jp z, .diagedit 
18f8			 
18f8			;	cp '6' 
18f8			;	jp z, .menutest 
18f8			;if ENABLE_BASIC 
18f8			;	cp '6' 
18f8			;	jp z, basic 
18f8			;endif 
18f8			  
18f8 c3 e8 18			jp .diagm 
18fb			 
18fb				 
18fb 0f 19		.menuitems:   	dw .m1 
18fd 1a 19				dw .m2 
18ff 21 19				dw .m3 
1901 29 19				dw .m5 
1903 2f 19				dw .m5a 
1905 38 19				dw .m5b 
1907 00 00				dw 0 
1909			 
1909			.menudebug: 
1909 41 19				dw .m6 
190b 4a 19				dw .m7 
190d 00 00				dw 0 
190f			 
190f .. 00		.m1:   db "Key Matrix",0 
191a .. 00		.m2:   db "Editor",0 
1921 .. 00		.m3:   db "Storage",0 
1929 .. 00		.m5:   db "Sound",0 
192f .. 00		.m5a:  db "RAM Test",0 
1938 .. 00		.m5b:  db "LCD Test",0 
1941			 
1941 .. 00		.m6:   db "Debug ON",0 
194a .. 00		.m7:   db "Debug OFF",0 
1954			 
1954			; debug editor 
1954			 
1954			.diagedit: 
1954			 
1954 21 c4 f1			ld hl, scratch 
1957			;	ld bc, 250 
1957			;	ldir 
1957				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1957 3e 00			ld a, 0 
1959 77				ld (hl), a 
195a 23				inc hl 
195b 77				ld (hl), a 
195c 23				inc hl 
195d 77				ld (hl), a 
195e			 
195e cd 52 0d		        call clear_display 
1961 cd 75 0d			call update_display 
1964				;ld a, 1 
1964				;ld (hardware_diag), a 
1964			.diloop: 
1964 3e 00			ld a, display_row_1 
1966 0e 00			ld c, 0 
1968 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
196a 1e 28			ld e, 40 
196c			 
196c 21 c4 f1			ld hl, scratch	 
196f cd b3 0f			call input_str 
1972			 
1972 3e 28			ld a, display_row_2 
1974 11 c4 f1			ld de, scratch 
1977 cd 65 0d			call str_at_display 
197a cd 75 0d			call update_display 
197d			 
197d c3 64 19			jp .diloop 
1980			 
1980			 
1980			; pass word in hl 
1980			; a has display location 
1980			display_word_at: 
1980 f5				push af 
1981 e5				push hl 
1982 7c				ld a,h 
1983 21 c9 f4			ld hl, os_word_scratch 
1986 cd 87 12			call hexout 
1989 e1				pop hl 
198a 7d				ld a,l 
198b 21 cb f4			ld hl, os_word_scratch+2 
198e cd 87 12			call hexout 
1991 21 cd f4			ld hl, os_word_scratch+4 
1994 3e 00			ld a,0 
1996 77				ld (hl),a 
1997 11 c9 f4			ld de,os_word_scratch 
199a f1				pop af 
199b cd 65 0d				call str_at_display 
199e c9				ret 
199f			 
199f			display_ptr_state: 
199f			 
199f				; to restore afterwards 
199f			 
199f d5				push de 
19a0 c5				push bc 
19a1 e5				push hl 
19a2 f5				push af 
19a3			 
19a3				; for use in here 
19a3			 
19a3			;	push bc 
19a3			;	push de 
19a3			;	push hl 
19a3			;	push af 
19a3			 
19a3 cd 52 0d			call clear_display 
19a6			 
19a6 11 79 1b			ld de, .ptrstate 
19a9 3e 00			ld a, display_row_1 
19ab cd 65 0d			call str_at_display 
19ae			 
19ae				; display debug step 
19ae			 
19ae			 
19ae 11 6e fe			ld de, debug_mark 
19b1 3e 26			ld a, display_row_1+display_cols-2 
19b3 cd 65 0d			call str_at_display 
19b6			 
19b6				; display a 
19b6 11 83 1b			ld de, .ptrcliptr 
19b9 3e 28			ld a, display_row_2 
19bb cd 65 0d			call str_at_display 
19be			 
19be f1				pop af 
19bf 2a 43 fa			ld hl,(cli_ptr) 
19c2 3e 30			ld a, display_row_2+8 
19c4 cd 80 19			call display_word_at 
19c7			 
19c7			 
19c7				; display hl 
19c7			 
19c7			 
19c7 11 8b 1b			ld de, .ptrclioptr 
19ca 3e 32			ld a, display_row_2+10 
19cc cd 65 0d			call str_at_display 
19cf			; 
19cf			;	pop hl 
19cf 3e 35			ld a, display_row_2+13 
19d1 2a 41 fa			ld hl,(cli_origptr) 
19d4 cd 80 19			call display_word_at 
19d7			; 
19d7			;	 
19d7			;	; display de 
19d7			 
19d7			;	ld de, .regstatede 
19d7			;	ld a, display_row_3 
19d7			;	call str_at_display 
19d7			 
19d7			;	pop de 
19d7			;	ld h,d 
19d7			;	ld l, e 
19d7			;	ld a, display_row_3+3 
19d7			;	call display_word_at 
19d7			 
19d7			 
19d7				; display bc 
19d7			 
19d7			;	ld de, .regstatebc 
19d7			;	ld a, display_row_3+10 
19d7			;	call str_at_display 
19d7			 
19d7			;	pop bc 
19d7			;	ld h,b 
19d7			;	ld l, c 
19d7			;	ld a, display_row_3+13 
19d7			;	call display_word_at 
19d7			 
19d7			 
19d7				; display dsp 
19d7			 
19d7			;	ld de, .regstatedsp 
19d7			;	ld a, display_row_4 
19d7			;	call str_at_display 
19d7			 
19d7				 
19d7			;	ld hl,(cli_data_sp) 
19d7			;	ld a, display_row_4+4 
19d7			;	call display_word_at 
19d7			 
19d7				; display rsp 
19d7			 
19d7 11 ba 1b			ld de, .regstatersp 
19da 3e 82			ld a, display_row_4+10 
19dc cd 65 0d			call str_at_display 
19df			 
19df				 
19df 2a f5 f9			ld hl,(cli_ret_sp) 
19e2 3e 86			ld a, display_row_4+14 
19e4 cd 80 19			call display_word_at 
19e7			 
19e7 cd 75 0d			call update_display 
19ea			 
19ea cd 95 0c			call delay1s 
19ed cd 95 0c			call delay1s 
19f0 cd 95 0c			call delay1s 
19f3			 
19f3			 
19f3 cd 6b 20			call next_page_prompt 
19f6			 
19f6				; restore  
19f6			 
19f6 f1				pop af 
19f7 e1				pop hl 
19f8 c1				pop bc 
19f9 d1				pop de 
19fa c9				ret 
19fb			 
19fb			break_point_state: 
19fb f5				push af 
19fc			 
19fc				; see if disabled 
19fc			 
19fc 3a b5 f1			ld a, (os_view_disable) 
19ff fe 2a			cp '*' 
1a01 20 02			jr nz, .bpsgo 
1a03 f1				pop af 
1a04 c9				ret 
1a05			 
1a05			.bpsgo: 
1a05 f1				pop af 
1a06 f5				push af 
1a07 22 b1 f1			ld (os_view_hl), hl 
1a0a ed 53 af f1		ld (os_view_de), de 
1a0e ed 43 ad f1		ld (os_view_bc), bc 
1a12 e5				push hl 
1a13 6f				ld l, a 
1a14 26 00			ld h, 0 
1a16 22 b3 f1			ld (os_view_af),hl 
1a19			 
1a19 21 b4 fd				ld hl, display_fb0 
1a1c 22 cf fb				ld (display_fb_active), hl 
1a1f e1				pop hl	 
1a20			 
1a20 3e 31			ld a, '1' 
1a22 fe 2a		.bps1:  cp '*' 
1a24 20 03			jr nz, .bps1b 
1a26 32 b5 f1			ld (os_view_disable),a 
1a29 fe 31		.bps1b:  cp '1' 
1a2b 20 14			jr nz, .bps2 
1a2d			 
1a2d				; display reg 
1a2d			 
1a2d				 
1a2d			 
1a2d 3a b3 f1			ld a, (os_view_af) 
1a30 2a b1 f1			ld hl, (os_view_hl) 
1a33 ed 5b af f1		ld de, (os_view_de) 
1a37 ed 4b ad f1		ld bc, (os_view_bc) 
1a3b cd d5 1a			call display_reg_state 
1a3e c3 c1 1a			jp .bpschk 
1a41			 
1a41 fe 32		.bps2:  cp '2' 
1a43 20 08			jr nz, .bps3 
1a45				 
1a45				; display hl 
1a45 2a b1 f1			ld hl, (os_view_hl) 
1a48 cd bf 1b			call display_dump_at_hl 
1a4b			 
1a4b 18 74			jr .bpschk 
1a4d			 
1a4d fe 33		.bps3:  cp '3' 
1a4f 20 08			jr nz, .bps4 
1a51			 
1a51			        ; display de 
1a51 2a af f1			ld hl, (os_view_de) 
1a54 cd bf 1b			call display_dump_at_hl 
1a57			 
1a57 18 68			jr .bpschk 
1a59 fe 34		.bps4:  cp '4' 
1a5b 20 08			jr nz, .bps5 
1a5d			 
1a5d			        ; display bc 
1a5d 2a ad f1			ld hl, (os_view_bc) 
1a60 cd bf 1b			call display_dump_at_hl 
1a63			 
1a63 18 5c			jr .bpschk 
1a65 fe 35		.bps5:  cp '5' 
1a67 20 08		        jr nz, .bps7 
1a69			 
1a69				; display cur ptr 
1a69 2a 43 fa			ld hl, (cli_ptr) 
1a6c cd bf 1b			call display_dump_at_hl 
1a6f			 
1a6f 18 50			jr .bpschk 
1a71 fe 36		.bps7:  cp '6' 
1a73 20 08			jr nz, .bps8b 
1a75				 
1a75				; display cur orig ptr 
1a75 2a 41 fa			ld hl, (cli_origptr) 
1a78 cd bf 1b			call display_dump_at_hl 
1a7b 18 44			jr .bpschk 
1a7d fe 37		.bps8b:  cp '7' 
1a7f 20 08			jr nz, .bps9 
1a81				 
1a81				; display dsp 
1a81 2a f1 f9			ld hl, (cli_data_sp) 
1a84 cd bf 1b			call display_dump_at_hl 
1a87			 
1a87 18 38			jr .bpschk 
1a89 fe 39		.bps9:  cp '9' 
1a8b 20 05			jr nz, .bps8c 
1a8d				 
1a8d				; display SP 
1a8d			;	ld hl, sp 
1a8d cd bf 1b			call display_dump_at_hl 
1a90			 
1a90 18 2f			jr .bpschk 
1a92 fe 38		.bps8c:  cp '8' 
1a94 20 08			jr nz, .bps8d 
1a96				 
1a96				; display rsp 
1a96 2a f5 f9			ld hl, (cli_ret_sp) 
1a99 cd bf 1b			call display_dump_at_hl 
1a9c			 
1a9c 18 23			jr .bpschk 
1a9e fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1aa0 20 05			jr nz, .bps8 
1aa2 cd 39 1e			call monitor 
1aa5			 
1aa5 18 1a			jr .bpschk 
1aa7 fe 30		.bps8:  cp '0' 
1aa9 20 16			jr nz, .bpschk 
1aab			 
1aab 21 13 fd				ld hl, display_fb1 
1aae 22 cf fb				ld (display_fb_active), hl 
1ab1 cd 75 0d				call update_display 
1ab4			 
1ab4				;ld a, (os_view_af) 
1ab4 2a b1 f1			ld hl, (os_view_hl) 
1ab7 ed 5b af f1		ld de, (os_view_de) 
1abb ed 4b ad f1		ld bc, (os_view_bc) 
1abf f1				pop af 
1ac0 c9				ret 
1ac1			 
1ac1			.bpschk:   
1ac1 cd 95 0c			call delay1s 
1ac4 3e 9f		ld a,display_row_4 + display_cols - 1 
1ac6 11 69 20		        ld de, endprg 
1ac9 cd 65 0d			call str_at_display 
1acc cd 75 0d			call update_display 
1acf cd c1 78			call cin_wait 
1ad2			 
1ad2 c3 22 1a			jp .bps1 
1ad5			 
1ad5			 
1ad5			display_reg_state: 
1ad5			 
1ad5				; to restore afterwards 
1ad5			 
1ad5 d5				push de 
1ad6 c5				push bc 
1ad7 e5				push hl 
1ad8 f5				push af 
1ad9			 
1ad9				; for use in here 
1ad9			 
1ad9 c5				push bc 
1ada d5				push de 
1adb e5				push hl 
1adc f5				push af 
1add			 
1add cd 52 0d			call clear_display 
1ae0			 
1ae0 11 95 1b			ld de, .regstate 
1ae3 3e 00			ld a, display_row_1 
1ae5 cd 65 0d			call str_at_display 
1ae8			 
1ae8				; display debug step 
1ae8			 
1ae8			 
1ae8 11 6e fe			ld de, debug_mark 
1aeb 3e 25			ld a, display_row_1+display_cols-3 
1aed cd 65 0d			call str_at_display 
1af0			 
1af0				; display a 
1af0 11 b1 1b			ld de, .regstatea 
1af3 3e 28			ld a, display_row_2 
1af5 cd 65 0d			call str_at_display 
1af8			 
1af8 e1				pop hl 
1af9			;	ld h,0 
1af9			;	ld l, a 
1af9 3e 2b			ld a, display_row_2+3 
1afb cd 80 19			call display_word_at 
1afe			 
1afe			 
1afe				; display hl 
1afe			 
1afe			 
1afe 11 a5 1b			ld de, .regstatehl 
1b01 3e 32			ld a, display_row_2+10 
1b03 cd 65 0d			call str_at_display 
1b06			 
1b06 e1				pop hl 
1b07 3e 35			ld a, display_row_2+13 
1b09 cd 80 19			call display_word_at 
1b0c			 
1b0c				 
1b0c				; display de 
1b0c			 
1b0c 11 a9 1b			ld de, .regstatede 
1b0f 3e 50			ld a, display_row_3 
1b11 cd 65 0d			call str_at_display 
1b14			 
1b14 e1				pop hl 
1b15			;	ld h,d 
1b15			;	ld l, e 
1b15 3e 53			ld a, display_row_3+3 
1b17 cd 80 19			call display_word_at 
1b1a			 
1b1a			 
1b1a				; display bc 
1b1a			 
1b1a 11 ad 1b			ld de, .regstatebc 
1b1d 3e 5a			ld a, display_row_3+10 
1b1f cd 65 0d			call str_at_display 
1b22			 
1b22 e1				pop hl 
1b23			;	ld h,b 
1b23			;	ld l, c 
1b23 3e 5d			ld a, display_row_3+13 
1b25 cd 80 19			call display_word_at 
1b28			 
1b28			 
1b28				; display dsp 
1b28			 
1b28 11 b5 1b			ld de, .regstatedsp 
1b2b 3e 78			ld a, display_row_4 
1b2d cd 65 0d			call str_at_display 
1b30			 
1b30				 
1b30 2a f1 f9			ld hl,(cli_data_sp) 
1b33 3e 7c			ld a, display_row_4+4 
1b35 cd 80 19			call display_word_at 
1b38			 
1b38				; display rsp 
1b38			 
1b38 11 ba 1b			ld de, .regstatersp 
1b3b 3e 82			ld a, display_row_4+10 
1b3d cd 65 0d			call str_at_display 
1b40			 
1b40				 
1b40 2a f5 f9			ld hl,(cli_ret_sp) 
1b43 3e 86			ld a, display_row_4+14 
1b45 cd 80 19			call display_word_at 
1b48			 
1b48 cd 75 0d			call update_display 
1b4b			 
1b4b			;	call delay1s 
1b4b			;	call delay1s 
1b4b			;	call delay1s 
1b4b			 
1b4b			 
1b4b			;	call next_page_prompt 
1b4b			 
1b4b				; restore  
1b4b			 
1b4b f1				pop af 
1b4c e1				pop hl 
1b4d c1				pop bc 
1b4e d1				pop de 
1b4f c9				ret 
1b50			 
1b50 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1b64 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1b79 .. 00		.ptrstate:	db "Ptr State",0 
1b83 .. 00		.ptrcliptr:     db "cli_ptr",0 
1b8b .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1b95 .. 00		.regstate:	db "Reg State (1/0)",0 
1ba5 .. 00		.regstatehl:	db "HL:",0 
1ba9 .. 00		.regstatede:	db "DE:",0 
1bad .. 00		.regstatebc:	db "BC:",0 
1bb1 .. 00		.regstatea:	db "A :",0 
1bb5 .. 00		.regstatedsp:	db "DSP:",0 
1bba .. 00		.regstatersp:	db "RSP:",0 
1bbf			 
1bbf			display_dump_at_hl: 
1bbf e5				push hl 
1bc0 d5				push de 
1bc1 c5				push bc 
1bc2 f5				push af 
1bc3			 
1bc3 22 e7 f4			ld (os_cur_ptr),hl	 
1bc6 cd 52 0d			call clear_display 
1bc9 cd 73 1f			call dumpcont 
1bcc			;	call delay1s 
1bcc			;	call next_page_prompt 
1bcc			 
1bcc			 
1bcc f1				pop af 
1bcd c1				pop bc 
1bce d1				pop de 
1bcf e1				pop hl 
1bd0 c9				ret 
1bd1			 
1bd1			;if ENABLE_BASIC 
1bd1			;	include "nascombasic.asm" 
1bd1			;	basic: 
1bd1			;	include "forth/FORTH.ASM" 
1bd1			;endif 
1bd1			 
1bd1			; eof 
1bd1			 
1bd1			 
# End of file firmware_diags.asm
1bd1			  
1bd1			include "firmware_prompts.asm"  
1bd1			; Prompts  
1bd1			 
1bd1			; boot messages 
1bd1			 
1bd1 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1be6 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1bf6			 
1bf6			 
1bf6			; config menus 
1bf6			 
1bf6 .. 00		prom_c3: db "Add Dictionary To File",0 
1c0d			 
1c0d			if STARTUP_V1 
1c0d			prom_c2: db "Select Autoload File",0 
1c0d			prom_c2a: db "Disable Autoload File", 0 
1c0d			endif 
1c0d			 
1c0d			if STARTUP_V2 
1c0d .. 00		prom_c2: db "Enable Autoload Files",0 
1c23 .. 00		prom_c2a: db "Disable Autoload Files", 0 
1c3a			 
1c3a .. 00		crs_s1: db "*ls-word", 0 
1c43 .. 00		crs_s2: db "*ed-word", 0 
1c4c .. 00		crs_s3: db "*Demo-Programs", 0 
1c5b .. 00		crs_s4: db "*Utils", 0 
1c62 .. 00		crs_s5: db "*SPI-Addons", 0 
1c6e .. 00		crs_s6: db "*Key-constants", 0 
1c7d			 
1c7d			 
1c7d			 
1c7d			endif 
1c7d .. 00		prom_c2b: db "Select Storage Bank",0 
1c91 .. 00		prom_c4: db "Settings",0 
1c9a .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1cb5 .. 00		prom_m4b:   db "Monitor",0 
1cbd .. 00		prom_c1: db "Hardware Diags",0 
1ccc			 
1ccc			 
1ccc			if STARTUP_V2 
1ccc .. 00		prom_c9: db "Create Startup Files",0 
1ce1			endif 
1ce1			 
1ce1 .. 00		prom_notav:    db "Feature not available",0 
1cf7 .. 00		prom_empty:    db "",0 
1cf8			 
1cf8			; eof 
1cf8			 
# End of file firmware_prompts.asm
1cf8			  
1cf8			  
1cf8			; eof  
1cf8			  
# End of file firmware.asm
1cf8			 
1cf8			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1cf8			;if BASE_KEV  
1cf8			;baseram: equ 08000h 
1cf8			;endif 
1cf8			 
1cf8			;if BASE_SC114 
1cf8			;baseram:     equ    endofcode 
1cf8			;endif 
1cf8			 
1cf8			 
1cf8			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1cf8			 
1cf8			; start system 
1cf8			 
1cf8			coldstart: 
1cf8				; set sp 
1cf8				; di/ei 
1cf8			 
1cf8 f3				di 
1cf9 31 fd ff			ld sp, tos 
1cfc			;	ei 
1cfc			 
1cfc				; init spinner 
1cfc 3e 00			ld a,0 
1cfe 32 c9 fb			ld (display_active), a 
1d01			 
1d01				; disable breakpoint by default 
1d01			 
1d01 3e 2a			ld a,'*' 
1d03 32 b5 f1			ld (os_view_disable),a 
1d06			 
1d06				; init hardware 
1d06			 
1d06				; init keyboard and screen hardware 
1d06			 
1d06 cd 1c 00			call hardware_init 
1d09			 
1d09			 
1d09 cd 95 0c			call delay1s 
1d0c 3e 58			ld a, display_row_3+8 
1d0e 11 03 00			ld de, buildtime 
1d11 cd 65 0d			call str_at_display 
1d14 cd 75 0d			call update_display 
1d17			 
1d17 cd 95 0c			call delay1s 
1d1a cd 95 0c			call delay1s 
1d1d cd 95 0c			call delay1s 
1d20			 
1d20				; detect if any keys are held down to enable breakpoints at start up 
1d20			 
1d20 cd d2 78			call cin  
1d23 fe 00			cp 0 
1d25 28 03			jr z, .nokeys 
1d27			 
1d27				;call hardware_diags 
1d27 cd 10 16			call config 
1d2a			 
1d2a			;	ld de, .bpen 
1d2a			;	ld a, display_row_4 
1d2a			;	call str_at_display 
1d2a			;	call update_display 
1d2a			; 
1d2a			;	ld a,0 
1d2a			;	ld (os_view_disable),a 
1d2a			; 
1d2a			;.bpwait: 
1d2a			;	call cin 
1d2a			;	cp 0 
1d2a			;	jr z, .bpwait 
1d2a			;	jr .nokeys 
1d2a			; 
1d2a			; 
1d2a			;.bpen:  db "Break points enabled!",0 
1d2a			 
1d2a			 
1d2a			 
1d2a			 
1d2a			 
1d2a			 
1d2a			.nokeys: 
1d2a			 
1d2a			 
1d2a				 
1d2a			 
1d2a			;jp  testkey 
1d2a			 
1d2a			;call storage_get_block_0 
1d2a			; 
1d2a			;ld hl, 0 
1d2a			;ld de, store_page 
1d2a			;call storage_read_block 
1d2a			 
1d2a				 
1d2a			;ld hl, 10 
1d2a			;ld de, store_page 
1d2a			;call storage_read_block 
1d2a			 
1d2a			 
1d2a			 
1d2a			 
1d2a			 
1d2a			;stop:	nop 
1d2a			;	jp stop 
1d2a			 
1d2a			 
1d2a			 
1d2a			main: 
1d2a cd 52 0d			call clear_display 
1d2d cd 75 0d			call update_display 
1d30			 
1d30			 
1d30			 
1d30			;	call testlcd 
1d30			 
1d30			 
1d30			 
1d30 cd 70 24			call forth_init 
1d33			 
1d33			 
1d33			warmstart: 
1d33 cd 46 24			call forth_warmstart 
1d36			 
1d36				; run startup word load 
1d36			        ; TODO prevent this running at warmstart after crash  
1d36			 
1d36				if STARTUP_ENABLE 
1d36			 
1d36					if STARTUP_V1 
1d36			 
1d36						if STORAGE_SE 
1d36							call forth_autoload 
1d36						endif 
1d36						call forth_startup 
1d36					endif 
1d36			 
1d36					if STARTUP_V2 
1d36			 
1d36						if STORAGE_SE 
1d36 cd 89 73						call forth_autoload 
1d39						else 
1d39							call forth_startup 
1d39						endif 
1d39			 
1d39			 
1d39					endif 
1d39			 
1d39				endif 
1d39			 
1d39				; show free memory after boot 
1d39 11 d3 1d			ld de, freeram 
1d3c 3e 00			ld a, display_row_1 
1d3e cd 65 0d			call str_at_display 
1d41			 
1d41			; Or use heap_size word???? 
1d41 21 aa f1			ld hl, heap_end 
1d44 11 0e 80			ld de, heap_start 
1d47 ed 52			sbc hl, de 
1d49 e5				push hl 
1d4a 7c				ld a,h	         	 
1d4b 21 c9 f4			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1d4e cd 87 12			call hexout 
1d51 e1			   	pop hl 
1d52			 
1d52 7d				ld a,l 
1d53 21 cb f4			ld hl, os_word_scratch+2 
1d56 cd 87 12			call hexout 
1d59 21 cd f4			ld hl, os_word_scratch+4 
1d5c 3e 00			ld a, 0 
1d5e 77				ld (hl),a 
1d5f 11 c9 f4			ld de, os_word_scratch 
1d62 3e 0d			ld a, display_row_1 + 13 
1d64 cd 65 0d			call str_at_display 
1d67 cd 75 0d			call update_display 
1d6a			 
1d6a			 
1d6a				;call demo 
1d6a			 
1d6a			 
1d6a				; init scratch input area for cli commands 
1d6a			 
1d6a 21 eb f4			ld hl, os_cli_cmd 
1d6d 3e 00			ld a,0 
1d6f 77				ld (hl),a 
1d70 23				inc hl 
1d71 77				ld (hl),a 
1d72			 
1d72 3e 00			ld a,0 
1d74 32 ea f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1d77			 
1d77 32 e7 f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1d7a 32 e8 f4			ld (os_cur_ptr+1),a	 
1d7d			 
1d7d 32 c9 f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1d80 32 ca f4			ld (os_word_scratch+1),a	 
1d83				 
1d83			 
1d83				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d83 21 eb f4			ld hl, os_cli_cmd 
1d86			 
1d86 3e 00			ld a, 0		 ; init cli input 
1d88 77				ld (hl), a 
1d89 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d8b			cli: 
1d8b				; show cli prompt 
1d8b				;push af 
1d8b				;ld a, 0 
1d8b				;ld de, prompt 
1d8b				;call str_at_display 
1d8b			 
1d8b				;call update_display 
1d8b				;pop af 
1d8b				;inc a 
1d8b				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1d8b 0e 00			ld c, 0 
1d8d 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1d8f 1e 28			ld e, 40 
1d91			 
1d91 21 eb f4			ld hl, os_cli_cmd 
1d94			 
1d94				STACKFRAME OFF $fefe $9f9f 
1d94				if DEBUG_STACK_IMB 
1d94					if OFF 
1d94						exx 
1d94						ld de, $fefe 
1d94						ld a, d 
1d94						ld hl, curframe 
1d94						call hexout 
1d94						ld a, e 
1d94						ld hl, curframe+2 
1d94						call hexout 
1d94						ld hl, $fefe 
1d94						push hl 
1d94						ld hl, $9f9f 
1d94						push hl 
1d94						exx 
1d94					endif 
1d94				endif 
1d94			endm 
# End of macro STACKFRAME
1d94			 
1d94 cd b3 0f			call input_str 
1d97			 
1d97				STACKFRAMECHK OFF $fefe $9f9f 
1d97				if DEBUG_STACK_IMB 
1d97					if OFF 
1d97						exx 
1d97						ld hl, $9f9f 
1d97						pop de   ; $9f9f 
1d97						call cmp16 
1d97						jr nz, .spnosame 
1d97						ld hl, $fefe 
1d97						pop de   ; $fefe 
1d97						call cmp16 
1d97						jr z, .spfrsame 
1d97						.spnosame: call showsperror 
1d97						.spfrsame: nop 
1d97						exx 
1d97					endif 
1d97				endif 
1d97			endm 
# End of macro STACKFRAMECHK
1d97			 
1d97				; copy input to last command 
1d97			 
1d97 21 eb f4			ld hl, os_cli_cmd 
1d9a 11 ea f5			ld de, os_last_cmd 
1d9d 01 ff 00			ld bc, 255 
1da0 ed b0			ldir 
1da2			 
1da2				; wipe current buffer 
1da2			 
1da2			;	ld a, 0 
1da2			;	ld hl, os_cli_cmd 
1da2			;	ld de, os_cli_cmd+1 
1da2			;	ld bc, 254 
1da2			;	ldir 
1da2				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1da2			;	call strcpy 
1da2			;	ld a, 0 
1da2			;	ld (hl), a 
1da2			;	inc hl 
1da2			;	ld (hl), a 
1da2			;	inc hl 
1da2			;	ld (hl), a 
1da2			 
1da2				; switch frame buffer to program  
1da2			 
1da2 21 13 fd				ld hl, display_fb1 
1da5 22 cf fb				ld (display_fb_active), hl 
1da8			 
1da8			;	nop 
1da8				STACKFRAME ON $fbfe $8f9f 
1da8				if DEBUG_STACK_IMB 
1da8					if ON 
1da8						exx 
1da8						ld de, $fbfe 
1da8						ld a, d 
1da8						ld hl, curframe 
1da8						call hexout 
1da8						ld a, e 
1da8						ld hl, curframe+2 
1da8						call hexout 
1da8						ld hl, $fbfe 
1da8						push hl 
1da8						ld hl, $8f9f 
1da8						push hl 
1da8						exx 
1da8					endif 
1da8				endif 
1da8			endm 
# End of macro STACKFRAME
1da8				; first time into the parser so pass over the current scratch pad 
1da8 21 eb f4			ld hl,os_cli_cmd 
1dab				; tokenise the entered statement(s) in HL 
1dab cd ee 24			call forthparse 
1dae			        ; exec forth statements in top of return stack 
1dae cd 2e 25			call forthexec 
1db1				;call forthexec_cleanup 
1db1			;	call parsenext 
1db1			 
1db1				STACKFRAMECHK ON $fbfe $8f9f 
1db1				if DEBUG_STACK_IMB 
1db1					if ON 
1db1						exx 
1db1						ld hl, $8f9f 
1db1						pop de   ; $8f9f 
1db1						call cmp16 
1db1						jr nz, .spnosame 
1db1						ld hl, $fbfe 
1db1						pop de   ; $fbfe 
1db1						call cmp16 
1db1						jr z, .spfrsame 
1db1						.spnosame: call showsperror 
1db1						.spfrsame: nop 
1db1						exx 
1db1					endif 
1db1				endif 
1db1			endm 
# End of macro STACKFRAMECHK
1db1				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1db1			 
1db1 3e 78			ld a, display_row_4 
1db3 11 e5 1d			ld de, endprog 
1db6			 
1db6 cd 75 0d			call update_display		 
1db9			 
1db9 cd 6b 20			call next_page_prompt 
1dbc			 
1dbc				; switch frame buffer to cli 
1dbc			 
1dbc 21 b4 fd				ld hl, display_fb0 
1dbf 22 cf fb				ld (display_fb_active), hl 
1dc2			 
1dc2			 
1dc2 cd 52 0d		        call clear_display 
1dc5 cd 75 0d			call update_display		 
1dc8			 
1dc8 21 eb f4			ld hl, os_cli_cmd 
1dcb			 
1dcb 3e 00			ld a, 0		 ; init cli input 
1dcd 77				ld (hl), a 
1dce			 
1dce				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1dce			 
1dce				; now on last line 
1dce			 
1dce				; TODO scroll screen up 
1dce			 
1dce				; TODO instead just clear screen and place at top of screen 
1dce			 
1dce			;	ld a, 0 
1dce			;	ld (f_cursor_ptr),a 
1dce			 
1dce				;call clear_display 
1dce				;call update_display 
1dce			 
1dce				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1dce 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1dd0 c3 8b 1d			jp cli 
1dd3			 
1dd3 .. 00		freeram: db "Free bytes: $",0 
1de1 ..			asc: db "1A2F" 
1de5 .. 00		endprog: db "End prog...",0 
1df1			 
1df1			testenter2:   
1df1 21 f6 f1			ld hl,scratch+50 
1df4 22 e7 f4			ld (os_cur_ptr),hl 
1df7 c3 8b 1d			jp cli 
1dfa			 
1dfa			testenter:  
1dfa			 
1dfa 21 e1 1d			ld hl,asc 
1dfd			;	ld a,(hl) 
1dfd			;	call nibble2val 
1dfd cd dd 12			call get_byte 
1e00			 
1e00			 
1e00			;	ld a,(hl) 
1e00			;	call atohex 
1e00			 
1e00			;	call fourehexhl 
1e00 32 f6 f1			ld (scratch+50),a 
1e03			 
1e03			 
1e03			 
1e03 21 e3 1d			ld hl,asc+2 
1e06			;	ld a, (hl) 
1e06			;	call nibble2val 
1e06 cd dd 12			call get_byte 
1e09			 
1e09			;	call fourehexhl 
1e09 32 f8 f1			ld (scratch+52),a 
1e0c				 
1e0c 21 f6 f1			ld hl,scratch+50 
1e0f 22 e7 f4			ld (os_cur_ptr),hl 
1e12 c3 8b 1d			jp cli 
1e15			 
1e15			enter:	 
1e15 3a c8 f1			ld a,(scratch+4) 
1e18 fe 00			cp 0 
1e1a 28 0c			jr z, .entercont 
1e1c				; no, not a null term line so has an address to work out.... 
1e1c			 
1e1c 21 c6 f1			ld hl,scratch+2 
1e1f cd 3d 13			call get_word_hl 
1e22			 
1e22 22 e7 f4			ld (os_cur_ptr),hl	 
1e25 c3 8b 1d			jp cli 
1e28			 
1e28			 
1e28			.entercont:  
1e28			 
1e28 21 c6 f1			ld hl, scratch+2 
1e2b cd dd 12			call get_byte 
1e2e			 
1e2e 2a e7 f4		   	ld hl,(os_cur_ptr) 
1e31 77					ld (hl),a 
1e32 23					inc hl 
1e33 22 e7 f4				ld (os_cur_ptr),hl 
1e36				 
1e36			; get byte  
1e36			 
1e36			 
1e36 c3 8b 1d			jp cli 
1e39			 
1e39			 
1e39			; basic monitor support 
1e39			 
1e39			monitor: 
1e39				;  
1e39 cd 52 0d			call clear_display 
1e3c 3e 00			ld a, 0 
1e3e 11 8d 1e			ld de, .monprompt 
1e41 cd 65 0d			call str_at_display 
1e44 cd 75 0d			call update_display 
1e47			 
1e47				; get a monitor command 
1e47			 
1e47 0e 00			ld c, 0     ; entry at top left 
1e49 16 64			ld d, 100   ; max buffer size 
1e4b 1e 0f			ld e, 15    ; input scroll area 
1e4d 3e 00			ld a, 0     ; init string 
1e4f 21 c2 f3			ld hl, os_input 
1e52 77				ld (hl), a 
1e53 23				inc hl 
1e54 77				ld (hl), a 
1e55 21 c2 f3			ld hl, os_input 
1e58 3e 01			ld a, 1     ; init string 
1e5a cd b3 0f			call input_str 
1e5d			 
1e5d cd 52 0d		        call clear_display 
1e60 cd 75 0d			call update_display		 
1e63			 
1e63 3a c2 f3			ld a, (os_input) 
1e66 cd db 13			call toUpper 
1e69 fe 48		        cp 'H' 
1e6b ca f2 1e		        jp z, .monhelp 
1e6e fe 44			cp 'D'		; dump 
1e70 ca 25 1f			jp z, .mondump	 
1e73 fe 43			cp 'C'		; dump 
1e75 ca 3f 1f			jp z, .moncdump	 
1e78 fe 4d			cp 'M'		; dump 
1e7a ca 8f 1e			jp z, .moneditstart 
1e7d fe 55			cp 'U'		; dump 
1e7f ca 9b 1e			jp z, .monedit	 
1e82 fe 47			cp 'G'		; dump 
1e84 ca 1b 1f			jp z, .monjump 
1e87 fe 51			cp 'Q'		; dump 
1e89 c8				ret z	 
1e8a			 
1e8a			 
1e8a				; TODO "S" to access symbol by name and not need the address 
1e8a				; TODO "F" to find a string in memory 
1e8a			 
1e8a c3 39 1e			jp monitor 
1e8d			 
1e8d .. 00		.monprompt: db ">", 0 
1e8f			 
1e8f			.moneditstart: 
1e8f				; get starting address 
1e8f			 
1e8f 21 c4 f3			ld hl,os_input+2 
1e92 cd 3d 13			call get_word_hl 
1e95			 
1e95 22 e7 f4			ld (os_cur_ptr),hl	 
1e98			 
1e98 c3 39 1e			jp monitor 
1e9b			 
1e9b			.monedit: 
1e9b				; get byte to load 
1e9b			 
1e9b 21 c4 f3			ld hl,os_input+2 
1e9e cd dd 12			call get_byte 
1ea1			 
1ea1				; get address to update 
1ea1 2a e7 f4			ld hl, (os_cur_ptr) 
1ea4			 
1ea4				; update byte 
1ea4			 
1ea4 77				ld (hl), a 
1ea5			 
1ea5				; move to next address and save it 
1ea5			 
1ea5 23				inc hl 
1ea6 22 e7 f4			ld (os_cur_ptr),hl	 
1ea9			 
1ea9 c3 39 1e			jp monitor 
1eac			 
1eac			 
1eac .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1ec0 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1edc .. 00		.monhelptext3:  db "G-Call address",0 
1eeb .. 00		.monhelptext4:  db "Q-Quit",0 
1ef2			        
1ef2			.monhelp: 
1ef2 3e 00			ld a, display_row_1 
1ef4 11 ac 1e		        ld de, .monhelptext1 
1ef7			 
1ef7 cd 65 0d			call str_at_display 
1efa 3e 28			ld a, display_row_2 
1efc 11 c0 1e		        ld de, .monhelptext2 
1eff					 
1eff cd 65 0d			call str_at_display 
1f02 3e 50			ld a, display_row_3 
1f04 11 dc 1e		        ld de, .monhelptext3 
1f07					 
1f07 cd 65 0d			call str_at_display 
1f0a 3e 78			ld a, display_row_4 
1f0c 11 eb 1e		        ld de, .monhelptext4 
1f0f cd 65 0d			call str_at_display 
1f12			 
1f12 cd 75 0d			call update_display		 
1f15			 
1f15 cd 6b 20			call next_page_prompt 
1f18 c3 39 1e			jp monitor 
1f1b			 
1f1b			.monjump:    
1f1b 21 c4 f3			ld hl,os_input+2 
1f1e cd 3d 13			call get_word_hl 
1f21			 
1f21 e9				jp (hl) 
1f22 c3 39 1e			jp monitor 
1f25			 
1f25			.mondump:    
1f25 21 c4 f3			ld hl,os_input+2 
1f28 cd 3d 13			call get_word_hl 
1f2b			 
1f2b 22 e7 f4			ld (os_cur_ptr),hl	 
1f2e cd 73 1f			call dumpcont 
1f31 3e 78			ld a, display_row_4 
1f33 11 e5 1d			ld de, endprog 
1f36			 
1f36 cd 75 0d			call update_display		 
1f39			 
1f39 cd 6b 20			call next_page_prompt 
1f3c c3 39 1e			jp monitor 
1f3f			.moncdump: 
1f3f cd 73 1f			call dumpcont 
1f42 3e 78			ld a, display_row_4 
1f44 11 e5 1d			ld de, endprog 
1f47			 
1f47 cd 75 0d			call update_display		 
1f4a			 
1f4a cd 6b 20			call next_page_prompt 
1f4d c3 39 1e			jp monitor 
1f50			 
1f50			 
1f50			; TODO symbol access  
1f50			 
1f50			.symbols:     ;; A list of symbols that can be called up  
1f50 b4 fd			dw display_fb0 
1f52 .. 00			db "fb0",0  
1f56 7d fa		     	dw store_page 
1f58 .. 00			db "store_page",0 
1f63			 
1f63			 
1f63			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1f63			 
1f63 3a c5 f1			ld a,(scratch+1) 
1f66 fe 00			cp 0 
1f68 28 09			jr z, dumpcont 
1f6a			 
1f6a				; no, not a null term line so has an address to work out.... 
1f6a			 
1f6a 21 c6 f1			ld hl,scratch+2 
1f6d cd 3d 13			call get_word_hl 
1f70			 
1f70 22 e7 f4			ld (os_cur_ptr),hl	 
1f73			 
1f73			 
1f73			 
1f73			dumpcont: 
1f73			 
1f73				; dump bytes at ptr 
1f73			 
1f73			 
1f73 3e 00			ld a, display_row_1 
1f75 2a cf fb			ld hl, (display_fb_active) 
1f78 cd 86 0f			call addatohl 
1f7b cd a3 1f			call .dumpbyterow 
1f7e			 
1f7e 3e 28			ld a, display_row_2 
1f80 2a cf fb			ld hl, (display_fb_active) 
1f83 cd 86 0f			call addatohl 
1f86 cd a3 1f			call .dumpbyterow 
1f89			 
1f89			 
1f89 3e 50			ld a, display_row_3 
1f8b 2a cf fb			ld hl, (display_fb_active) 
1f8e cd 86 0f			call addatohl 
1f91 cd a3 1f			call .dumpbyterow 
1f94			 
1f94 3e 78			ld a, display_row_4 
1f96 2a cf fb			ld hl, (display_fb_active) 
1f99 cd 86 0f			call addatohl 
1f9c cd a3 1f			call .dumpbyterow 
1f9f			 
1f9f cd 75 0d			call update_display 
1fa2			;		jp cli 
1fa2 c9				ret 
1fa3			 
1fa3			.dumpbyterow: 
1fa3			 
1fa3				;push af 
1fa3			 
1fa3 e5				push hl 
1fa4			 
1fa4				; calc where to poke the ascii 
1fa4			if display_cols == 20 
1fa4				ld a, 16 
1fa4			else 
1fa4 3e 1f			ld a, 31 
1fa6			endif 
1fa6			 
1fa6 cd 86 0f			call addatohl 
1fa9 22 c9 f4			ld (os_word_scratch),hl  		; save pos for later 
1fac			 
1fac			 
1fac			; display decoding address 
1fac 2a e7 f4		   	ld hl,(os_cur_ptr) 
1faf			 
1faf 7c				ld a,h 
1fb0 e1				pop hl 
1fb1 e5				push hl 
1fb2			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1fb2 cd 87 12			call hexout 
1fb5 2a e7 f4		   	ld hl,(os_cur_ptr) 
1fb8			 
1fb8 7d				ld a,l 
1fb9 e1				pop hl 
1fba 23				inc hl 
1fbb 23				inc hl 
1fbc e5				push hl 
1fbd			;	ld hl, os_word_scratch+2 
1fbd cd 87 12			call hexout 
1fc0 e1				pop hl 
1fc1 23				inc hl 
1fc2 23				inc hl 
1fc3				;ld hl, os_word_scratch+4 
1fc3 3e 3a			ld a, ':' 
1fc5 77				ld (hl),a 
1fc6 23				inc hl 
1fc7				;ld a, 0 
1fc7				;ld (hl),a 
1fc7				;ld de, os_word_scratch 
1fc7				;pop af 
1fc7				;push af 
1fc7			;		ld a, display_row_2 
1fc7			;		call str_at_display 
1fc7			;		call update_display 
1fc7			 
1fc7			 
1fc7			;pop af 
1fc7			;	add 5 
1fc7			 
1fc7			if display_cols == 20 
1fc7				ld b, 4 
1fc7			else 
1fc7 06 08			ld b, 8 
1fc9			endif	 
1fc9			 
1fc9			.dumpbyte: 
1fc9 c5				push bc 
1fca e5				push hl 
1fcb			 
1fcb			 
1fcb 2a e7 f4		   	ld hl,(os_cur_ptr) 
1fce 7e					ld a,(hl) 
1fcf			 
1fcf					; poke the ascii to display 
1fcf 2a c9 f4				ld hl,(os_word_scratch) 
1fd2 77					ld (hl),a 
1fd3 23					inc hl 
1fd4 22 c9 f4				ld (os_word_scratch),hl 
1fd7			 
1fd7					 
1fd7			 
1fd7			 
1fd7 e1					pop hl 
1fd8 e5					push hl 
1fd9			 
1fd9 cd 87 12				call hexout 
1fdc			 
1fdc					 
1fdc 2a e7 f4		   	ld hl,(os_cur_ptr) 
1fdf 23				inc hl 
1fe0 22 e7 f4		   	ld (os_cur_ptr),hl 
1fe3			 
1fe3 e1					pop hl 
1fe4 23					inc hl 
1fe5 23					inc hl 
1fe6 23					inc hl 
1fe7			 
1fe7			 
1fe7			 
1fe7					;ld a,0 
1fe7					;ld (os_word_scratch+2),a 
1fe7					;pop af 
1fe7					;push af 
1fe7			 
1fe7					;ld de, os_word_scratch 
1fe7					;call str_at_display 
1fe7			;		call update_display 
1fe7			;		pop af 
1fe7 c1					pop bc 
1fe8 c6 03				add 3 
1fea 10 dd			djnz .dumpbyte 
1fec			 
1fec				 
1fec			 
1fec c9				ret 
1fed			 
1fed			jump:	 
1fed			 
1fed 21 c6 f1			ld hl,scratch+2 
1ff0 cd 3d 13			call get_word_hl 
1ff3				;ld hl,(scratch+2) 
1ff3				;call fourehexhl 
1ff3			 
1ff3 22 e7 f4			ld (os_cur_ptr),hl	 
1ff6			 
1ff6 e9				jp (hl) 
1ff7			 
1ff7			 
1ff7			 
1ff7			; TODO implement a basic monitor mode to start with 
1ff7			 
1ff7			 
1ff7			 
1ff7			 
1ff7			 
1ff7			 
1ff7			 
1ff7			 
1ff7			 
1ff7			; testing and demo code during development 
1ff7			 
1ff7			 
1ff7 .. 00		str1: db "Enter some text...",0 
200a .. 00		clear: db "                    ",0 
201f			 
201f			demo: 
201f			 
201f			 
201f			 
201f			;	call update_display 
201f			 
201f				; init scratch input area for testing 
201f 21 c4 f1			ld hl, scratch	 
2022 3e 00			ld a,0 
2024 77				ld (hl),a 
2025			 
2025			 
2025 3e 28		            LD   A, display_row_2 
2027			;            CALL fLCD_Pos       ;Position cursor to location in A 
2027 11 f7 1f		            LD   DE, str1 
202a cd 65 0d			call str_at_display 
202d			 
202d			;            CALL fLCD_Str       ;Display string pointed to by DE 
202d			cloop:	 
202d 3e 50		            LD   A, display_row_3 
202f			;            CALL fLCD_Pos       ;Position cursor to location in A 
202f 11 0a 20		            LD   DE, clear 
2032			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
2032 cd 65 0d				call str_at_display 
2035 3e 78			ld a, display_row_4 
2037 11 67 20			ld de, prompt 
203a			 
203a cd 65 0d				call str_at_display 
203d cd 75 0d			call update_display 
2040			 
2040 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
2042 16 0a			ld d, 10 
2044 21 c4 f1			ld hl, scratch	 
2047 cd b3 0f			call input_str 
204a			 
204a			;	call clear_display 
204a			;'	call update_display 
204a			 
204a 3e 00		            LD   A, display_row_1 
204c			;            CALL fLCD_Pos       ;Position cursor to location in A 
204c 11 0a 20		            LD   DE, clear 
204f cd 65 0d				call str_at_display 
2052			;            CALL fLCD_Str       ;Display string pointed to by DE 
2052 3e 00		            LD   A, display_row_1 
2054			;            CALL fLCD_Pos       ;Position cursor to location in A 
2054 11 c4 f1		            LD   DE, scratch 
2057			;            CALL fLCD_Str       ;Display string pointed to by DE 
2057 cd 65 0d				call str_at_display 
205a cd 75 0d			call update_display 
205d			 
205d 3e 00				ld a,0 
205f 21 c4 f1			ld hl, scratch 
2062 77				ld (hl),a 
2063			 
2063 00				nop 
2064 c3 2d 20			jp cloop 
2067			 
2067			 
2067			 
2067			; OS Prompt 
2067			 
2067 .. 00		prompt: db ">",0 
2069 .. 00		endprg: db "?",0 
206b			 
206b			 
206b			; handy next page prompt 
206b			next_page_prompt: 
206b e5				push hl 
206c d5				push de 
206d f5				push af 
206e c5				push bc 
206f			 
206f 3e 9f			ld a,display_row_4 + display_cols - 1 
2071 11 69 20		        ld de, endprg 
2074 cd 65 0d			call str_at_display 
2077 cd 75 0d			call update_display 
207a cd c1 78			call cin_wait 
207d c1				pop bc 
207e f1				pop af 
207f d1				pop de 
2080 e1				pop hl 
2081			 
2081			 
2081 c9				ret 
2082			 
2082			 
2082			; forth parser 
2082			 
2082			; My forth kernel 
2082			include "forth_kernel.asm" 
2082			; 
2082			; kernel to the forth OS 
2082			 
2082			DS_TYPE_STR: equ 1     ; string type 
2082			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
2082			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
2082			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
2082			 
2082			FORTH_PARSEV1: equ 0 
2082			FORTH_PARSEV2: equ 0 
2082			FORTH_PARSEV3: equ 0 
2082			FORTH_PARSEV4: equ 0 
2082			FORTH_PARSEV5: equ 1 
2082			 
2082			;if FORTH_PARSEV5 
2082			;	FORTH_END_BUFFER: equ 0 
2082			;else 
2082			FORTH_END_BUFFER: equ 127 
2082			;endif 
2082			 
2082			FORTH_TRUE: equ 1 
2082			FORTH_FALSE: equ 0 
2082			 
2082			if FORTH_PARSEV4 
2082			include "forth_stackops.asm" 
2082			endif 
2082			 
2082			if FORTH_PARSEV5 
2082			include "forth_stackopsv5.asm" 
2082			 
2082			; Stack operations for v5 parser on wards 
2082			; * DATA stack 
2082			; * LOOP stack 
2082			; * RETURN stack 
2082			 
2082			 
2082			 
2082			FORTH_CHK_DSP_UNDER: macro 
2082				push hl 
2082				push de 
2082				ld hl,(cli_data_sp) 
2082				ld de, cli_data_stack 
2082				call cmp16 
2082				jp c, fault_dsp_under 
2082				pop de 
2082				pop hl 
2082				endm 
2082			 
2082			 
2082			FORTH_CHK_RSP_UNDER: macro 
2082				push hl 
2082				push de 
2082				ld hl,(cli_ret_sp) 
2082				ld de, cli_ret_stack 
2082				call cmp16 
2082				jp c, fault_rsp_under 
2082				pop de 
2082				pop hl 
2082				endm 
2082			 
2082			FORTH_CHK_LOOP_UNDER: macro 
2082				push hl 
2082				push de 
2082				ld hl,(cli_loop_sp) 
2082				ld de, cli_loop_stack 
2082				call cmp16 
2082				jp c, fault_loop_under 
2082				pop de 
2082				pop hl 
2082				endm 
2082			 
2082			FORTH_ERR_TOS_NOTSTR: macro 
2082				; TOSO might need more for checks when used 
2082				push af 
2082				ld a,(hl) 
2082				cp DS_TYPE_STR 
2082				jp nz, type_faultn   
2082				pop af 
2082				endm 
2082			 
2082			FORTH_ERR_TOS_NOTNUM: macro 
2082				push af 
2082				ld a,(hl) 
2082				cp DS_TYPE_INUM 
2082				jp nz, type_faultn   
2082				pop af 
2082				endm 
2082			 
2082			 
2082			; increase data stack pointer and save hl to it 
2082				 
2082			FORTH_DSP_NEXT: macro 
2082				call macro_forth_dsp_next 
2082				endm 
2082			 
2082			 
2082			macro_forth_dsp_next: 
2082				if DEBUG_FORTH_STACK_GUARD 
2082 cd 81 71				call check_stacks 
2085				endif 
2085 e5				push hl 
2086 d5				push de 
2087 eb				ex de,hl 
2088 2a f1 f9			ld hl,(cli_data_sp) 
208b 23				inc hl 
208c 23				inc hl 
208d			 
208d			; PARSEV5 
208d 23				inc hl 
208e 22 f1 f9			ld (cli_data_sp),hl 
2091 73				ld (hl), e 
2092 23				inc hl 
2093 72				ld (hl), d 
2094 d1				pop de 
2095 e1				pop hl 
2096				if DEBUG_FORTH_STACK_GUARD 
2096 cd 81 71				call check_stacks 
2099				endif 
2099 c9				ret 
209a			 
209a			 
209a			; increase ret stack pointer and save hl to it 
209a				 
209a			FORTH_RSP_NEXT: macro 
209a				call macro_forth_rsp_next 
209a				endm 
209a			 
209a			macro_forth_rsp_next: 
209a				if DEBUG_FORTH_STACK_GUARD 
209a cd 81 71				call check_stacks 
209d				endif 
209d e5				push hl 
209e d5				push de 
209f eb				ex de,hl 
20a0 2a f5 f9			ld hl,(cli_ret_sp) 
20a3 23				inc hl 
20a4 23				inc hl 
20a5 22 f5 f9			ld (cli_ret_sp),hl 
20a8 73				ld (hl), e 
20a9 23				inc hl 
20aa 72				ld (hl), d 
20ab d1				pop de 
20ac e1				pop hl 
20ad				if DEBUG_FORTH_STACK_GUARD 
20ad cd 81 71				call check_stacks 
20b0				endif 
20b0 c9				ret 
20b1			 
20b1			; get current ret stack pointer and save to hl  
20b1				 
20b1			FORTH_RSP_TOS: macro 
20b1				call macro_forth_rsp_tos 
20b1				endm 
20b1			 
20b1			macro_forth_rsp_tos: 
20b1				;push de 
20b1 2a f5 f9			ld hl,(cli_ret_sp) 
20b4 cd ec 20			call loadhlptrtohl 
20b7				;ld e, (hl) 
20b7				;inc hl 
20b7				;ld d, (hl) 
20b7				;ex de, hl 
20b7					if DEBUG_FORTH_WORDS 
20b7			;			DMARK "RST" 
20b7						CALLMONITOR 
20b7 cd fb 19			call break_point_state  
20ba				endm  
# End of macro CALLMONITOR
20ba					endif 
20ba				;pop de 
20ba c9				ret 
20bb			 
20bb			; pop ret stack pointer 
20bb				 
20bb			FORTH_RSP_POP: macro 
20bb				call macro_forth_rsp_pop 
20bb				endm 
20bb			 
20bb			 
20bb			macro_forth_rsp_pop: 
20bb				if DEBUG_FORTH_STACK_GUARD 
20bb			;		DMARK "RPP" 
20bb cd 81 71				call check_stacks 
20be					FORTH_CHK_RSP_UNDER 
20be e5				push hl 
20bf d5				push de 
20c0 2a f5 f9			ld hl,(cli_ret_sp) 
20c3 11 af f9			ld de, cli_ret_stack 
20c6 cd a4 0f			call cmp16 
20c9 da 95 72			jp c, fault_rsp_under 
20cc d1				pop de 
20cd e1				pop hl 
20ce				endm 
# End of macro FORTH_CHK_RSP_UNDER
20ce				endif 
20ce e5				push hl 
20cf 2a f5 f9			ld hl,(cli_ret_sp) 
20d2			 
20d2			 
20d2				if FORTH_ENABLE_FREE 
20d2			 
20d2					; get pointer 
20d2			 
20d2					push de 
20d2					push hl 
20d2			 
20d2					ld e, (hl) 
20d2					inc hl 
20d2					ld d, (hl) 
20d2			 
20d2					ex de, hl 
20d2					call free 
20d2			 
20d2					pop hl 
20d2					pop de 
20d2			 
20d2			 
20d2				endif 
20d2			 
20d2			 
20d2 2b				dec hl 
20d3 2b				dec hl 
20d4 22 f5 f9			ld (cli_ret_sp), hl 
20d7				; do stack underflow checks 
20d7 e1				pop hl 
20d8				if DEBUG_FORTH_STACK_GUARD 
20d8 cd 81 71				call check_stacks 
20db					FORTH_CHK_RSP_UNDER 
20db e5				push hl 
20dc d5				push de 
20dd 2a f5 f9			ld hl,(cli_ret_sp) 
20e0 11 af f9			ld de, cli_ret_stack 
20e3 cd a4 0f			call cmp16 
20e6 da 95 72			jp c, fault_rsp_under 
20e9 d1				pop de 
20ea e1				pop hl 
20eb				endm 
# End of macro FORTH_CHK_RSP_UNDER
20eb				endif 
20eb c9				ret 
20ec			 
20ec			 
20ec			 
20ec			; routine to load word pointed to by hl into hl 
20ec			 
20ec			loadhlptrtohl: 
20ec			 
20ec d5				push de 
20ed 5e				ld e, (hl) 
20ee 23				inc hl 
20ef 56				ld d, (hl) 
20f0 eb				ex de, hl 
20f1 d1				pop de 
20f2			 
20f2 c9				ret 
20f3			 
20f3			 
20f3			 
20f3			 
20f3			 
20f3			; push a number held in HL onto the data stack 
20f3			; entry point for pushing a value when already in hl used in function above 
20f3			 
20f3			forth_push_numhl: 
20f3			 
20f3 e5				push hl    ; save value to push 
20f4			 
20f4			if DEBUG_FORTH_PUSH 
20f4				; see if disabled 
20f4			 
20f4			 
20f4 f5				push af 
20f5 3a b5 f1			ld a, (os_view_disable) 
20f8 fe 2a			cp '*' 
20fa 28 34			jr z, .pskip2 
20fc e5				push hl 
20fd e5			push hl 
20fe cd 52 0d			call clear_display 
2101 e1			pop hl 
2102 7c				ld a,h 
2103 21 c9 f4			ld hl, os_word_scratch 
2106 cd 87 12			call hexout 
2109 e1				pop hl 
210a 7d				ld a,l 
210b 21 cb f4			ld hl, os_word_scratch+2 
210e cd 87 12			call hexout 
2111			 
2111 21 cd f4			ld hl, os_word_scratch+4 
2114 3e 00			ld a,0 
2116 77				ld (hl),a 
2117 11 c9 f4			ld de,os_word_scratch 
211a 3e 28				ld a, display_row_2 
211c cd 65 0d				call str_at_display 
211f 11 66 5d			ld de, .push_num 
2122 3e 00			ld a, display_row_1 
2124			 
2124 cd 65 0d				call str_at_display 
2127			 
2127			 
2127 cd 75 0d			call update_display 
212a cd 95 0c			call delay1s 
212d cd 95 0c			call delay1s 
2130			.pskip2:  
2130			 
2130 f1				pop af 
2131			endif	 
2131			 
2131			 
2131				FORTH_DSP_NEXT 
2131 cd 82 20			call macro_forth_dsp_next 
2134				endm 
# End of macro FORTH_DSP_NEXT
2134			 
2134 2a f1 f9			ld hl, (cli_data_sp) 
2137			 
2137				; save item type 
2137 3e 02			ld a,  DS_TYPE_INUM 
2139 77				ld (hl), a 
213a 23				inc hl 
213b			 
213b				; get word off stack 
213b d1				pop de 
213c 7b				ld a,e 
213d 77				ld (hl), a 
213e 23				inc hl 
213f 7a				ld a,d 
2140 77				ld (hl), a 
2141			 
2141			if DEBUG_FORTH_PUSH 
2141 2b				dec hl 
2142 2b				dec hl 
2143 2b				dec hl 
2144						DMARK "PH5" 
2144 f5				push af  
2145 3a 59 21			ld a, (.dmark)  
2148 32 6e fe			ld (debug_mark),a  
214b 3a 5a 21			ld a, (.dmark+1)  
214e 32 6f fe			ld (debug_mark+1),a  
2151 3a 5b 21			ld a, (.dmark+2)  
2154 32 70 fe			ld (debug_mark+2),a  
2157 18 03			jr .pastdmark  
2159 ..			.dmark: db "PH5"  
215c f1			.pastdmark: pop af  
215d			endm  
# End of macro DMARK
215d				CALLMONITOR 
215d cd fb 19			call break_point_state  
2160				endm  
# End of macro CALLMONITOR
2160			endif	 
2160			 
2160 c9				ret 
2161			 
2161			 
2161			; Push a string to stack pointed to by hl 
2161			 
2161			forth_push_str: 
2161			 
2161			if DEBUG_FORTH_PUSH 
2161						DMARK "PSQ" 
2161 f5				push af  
2162 3a 76 21			ld a, (.dmark)  
2165 32 6e fe			ld (debug_mark),a  
2168 3a 77 21			ld a, (.dmark+1)  
216b 32 6f fe			ld (debug_mark+1),a  
216e 3a 78 21			ld a, (.dmark+2)  
2171 32 70 fe			ld (debug_mark+2),a  
2174 18 03			jr .pastdmark  
2176 ..			.dmark: db "PSQ"  
2179 f1			.pastdmark: pop af  
217a			endm  
# End of macro DMARK
217a				CALLMONITOR 
217a cd fb 19			call break_point_state  
217d				endm  
# End of macro CALLMONITOR
217d			endif	 
217d			    
217d e5				push hl 
217e e5				push hl 
217f			 
217f			;	ld a, 0   ; find end of string 
217f cd e4 13			call strlenz 
2182			if DEBUG_FORTH_PUSH 
2182						DMARK "PQ2" 
2182 f5				push af  
2183 3a 97 21			ld a, (.dmark)  
2186 32 6e fe			ld (debug_mark),a  
2189 3a 98 21			ld a, (.dmark+1)  
218c 32 6f fe			ld (debug_mark+1),a  
218f 3a 99 21			ld a, (.dmark+2)  
2192 32 70 fe			ld (debug_mark+2),a  
2195 18 03			jr .pastdmark  
2197 ..			.dmark: db "PQ2"  
219a f1			.pastdmark: pop af  
219b			endm  
# End of macro DMARK
219b				CALLMONITOR 
219b cd fb 19			call break_point_state  
219e				endm  
# End of macro CALLMONITOR
219e			endif	 
219e eb				ex de, hl 
219f e1				pop hl   ; get ptr to start of string 
21a0			if DEBUG_FORTH_PUSH 
21a0						DMARK "PQ3" 
21a0 f5				push af  
21a1 3a b5 21			ld a, (.dmark)  
21a4 32 6e fe			ld (debug_mark),a  
21a7 3a b6 21			ld a, (.dmark+1)  
21aa 32 6f fe			ld (debug_mark+1),a  
21ad 3a b7 21			ld a, (.dmark+2)  
21b0 32 70 fe			ld (debug_mark+2),a  
21b3 18 03			jr .pastdmark  
21b5 ..			.dmark: db "PQ3"  
21b8 f1			.pastdmark: pop af  
21b9			endm  
# End of macro DMARK
21b9				CALLMONITOR 
21b9 cd fb 19			call break_point_state  
21bc				endm  
# End of macro CALLMONITOR
21bc			endif	 
21bc 19				add hl,de 
21bd			if DEBUG_FORTH_PUSH 
21bd						DMARK "PQE" 
21bd f5				push af  
21be 3a d2 21			ld a, (.dmark)  
21c1 32 6e fe			ld (debug_mark),a  
21c4 3a d3 21			ld a, (.dmark+1)  
21c7 32 6f fe			ld (debug_mark+1),a  
21ca 3a d4 21			ld a, (.dmark+2)  
21cd 32 70 fe			ld (debug_mark+2),a  
21d0 18 03			jr .pastdmark  
21d2 ..			.dmark: db "PQE"  
21d5 f1			.pastdmark: pop af  
21d6			endm  
# End of macro DMARK
21d6				CALLMONITOR 
21d6 cd fb 19			call break_point_state  
21d9				endm  
# End of macro CALLMONITOR
21d9			endif	 
21d9			 
21d9 2b				dec hl    ; see if there is an optional trailing double quote 
21da 7e				ld a,(hl) 
21db fe 22			cp '"' 
21dd 20 03			jr nz, .strnoq 
21df 3e 00			ld a, 0      ; get rid of double quote 
21e1 77				ld (hl), a 
21e2 23			.strnoq: inc hl 
21e3			 
21e3 3e 00			ld a, 0 
21e5 77				ld (hl), a     ; add null term and get rid of trailing double quote 
21e6			 
21e6 13				inc de ; add one for the type string 
21e7 13				inc de ; add one for null term??? 
21e8			 
21e8				; tos is get string pointer again 
21e8				; de contains space to allocate 
21e8				 
21e8 d5				push de 
21e9			 
21e9 eb				ex de, hl 
21ea			 
21ea				;push af 
21ea			 
21ea			if DEBUG_FORTH_PUSH 
21ea						DMARK "PHm" 
21ea f5				push af  
21eb 3a ff 21			ld a, (.dmark)  
21ee 32 6e fe			ld (debug_mark),a  
21f1 3a 00 22			ld a, (.dmark+1)  
21f4 32 6f fe			ld (debug_mark+1),a  
21f7 3a 01 22			ld a, (.dmark+2)  
21fa 32 70 fe			ld (debug_mark+2),a  
21fd 18 03			jr .pastdmark  
21ff ..			.dmark: db "PHm"  
2202 f1			.pastdmark: pop af  
2203			endm  
# End of macro DMARK
2203				CALLMONITOR 
2203 cd fb 19			call break_point_state  
2206				endm  
# End of macro CALLMONITOR
2206			endif	 
2206 cd 4d 14			call malloc	; on ret hl now contains allocated memory 
2209				if DEBUG_FORTH_MALLOC_GUARD 
2209 cc be 5d				call z,malloc_error 
220c				endif 
220c			 
220c				 
220c c1				pop bc    ; get length 
220d d1				pop de   ;  get string start    
220e			 
220e				; hl has destination from malloc 
220e			 
220e eb				ex de, hl    ; prep for ldir 
220f			 
220f d5				push de   ; save malloc area for DSP later 
2210				;push hl   ; save malloc area for DSP later 
2210			 
2210			if DEBUG_FORTH_PUSH 
2210						DMARK "PHc" 
2210 f5				push af  
2211 3a 25 22			ld a, (.dmark)  
2214 32 6e fe			ld (debug_mark),a  
2217 3a 26 22			ld a, (.dmark+1)  
221a 32 6f fe			ld (debug_mark+1),a  
221d 3a 27 22			ld a, (.dmark+2)  
2220 32 70 fe			ld (debug_mark+2),a  
2223 18 03			jr .pastdmark  
2225 ..			.dmark: db "PHc"  
2228 f1			.pastdmark: pop af  
2229			endm  
# End of macro DMARK
2229				CALLMONITOR 
2229 cd fb 19			call break_point_state  
222c				endm  
# End of macro CALLMONITOR
222c			endif	 
222c			 
222c			 
222c ed b0			ldir 
222e			 
222e			 
222e				; push malloc to data stack     macro?????  
222e			 
222e				FORTH_DSP_NEXT 
222e cd 82 20			call macro_forth_dsp_next 
2231				endm 
# End of macro FORTH_DSP_NEXT
2231			 
2231				; save value and type 
2231			 
2231 2a f1 f9			ld hl, (cli_data_sp) 
2234			 
2234				; save item type 
2234 3e 01			ld a,  DS_TYPE_STR 
2236 77				ld (hl), a 
2237 23				inc hl 
2238			 
2238				; get malloc word off stack 
2238 d1				pop de 
2239 73				ld (hl), e 
223a 23				inc hl 
223b 72				ld (hl), d 
223c			 
223c			 
223c			 
223c			if DEBUG_FORTH_PUSH 
223c 2a f1 f9			ld hl, (cli_data_sp) 
223f						DMARK "PHS" 
223f f5				push af  
2240 3a 54 22			ld a, (.dmark)  
2243 32 6e fe			ld (debug_mark),a  
2246 3a 55 22			ld a, (.dmark+1)  
2249 32 6f fe			ld (debug_mark+1),a  
224c 3a 56 22			ld a, (.dmark+2)  
224f 32 70 fe			ld (debug_mark+2),a  
2252 18 03			jr .pastdmark  
2254 ..			.dmark: db "PHS"  
2257 f1			.pastdmark: pop af  
2258			endm  
# End of macro DMARK
2258				CALLMONITOR 
2258 cd fb 19			call break_point_state  
225b				endm  
# End of macro CALLMONITOR
225b			;	ex de,hl 
225b			endif	 
225b				; in case of spaces, skip the ptr past the copied string 
225b				;pop af 
225b				;ld (cli_origptr),hl 
225b			 
225b c9				ret 
225c			 
225c			 
225c			 
225c			; TODO ascii push input onto stack given hl to start of input 
225c			 
225c			; identify type 
225c			; if starts with a " then a string 
225c			; otherwise it is a number 
225c			;  
225c			; if a string 
225c			;     scan for ending " to get length of string to malloc for + 1 
225c			;     malloc 
225c			;     put pointer to string on stack first byte flags as string 
225c			; 
225c			; else a number 
225c			;    look for number format identifier 
225c			;    $xx hex 
225c			;    %xxxxx bin 
225c			;    xxxxx decimal 
225c			;    convert number to 16bit word.  
225c			;    malloc word + 1 with flag to identiy as num 
225c			;    put pointer to number on stack 
225c			;   
225c			;  
225c			  
225c			forth_apush: 
225c				; kernel push 
225c			 
225c			if DEBUG_FORTH_PUSH 
225c						DMARK "PSH" 
225c f5				push af  
225d 3a 71 22			ld a, (.dmark)  
2260 32 6e fe			ld (debug_mark),a  
2263 3a 72 22			ld a, (.dmark+1)  
2266 32 6f fe			ld (debug_mark+1),a  
2269 3a 73 22			ld a, (.dmark+2)  
226c 32 70 fe			ld (debug_mark+2),a  
226f 18 03			jr .pastdmark  
2271 ..			.dmark: db "PSH"  
2274 f1			.pastdmark: pop af  
2275			endm  
# End of macro DMARK
2275				CALLMONITOR 
2275 cd fb 19			call break_point_state  
2278				endm  
# End of macro CALLMONITOR
2278			endif	 
2278				; identify input type 
2278			 
2278 7e				ld a,(hl) 
2279 fe 22			cp '"' 
227b 28 0a			jr z, .fapstr 
227d fe 24			cp '$' 
227f ca a7 22			jp z, .faphex 
2282 fe 25			cp '%' 
2284 ca 8f 22			jp z, .fapbin 
2287			;	cp 'b' 
2287			;	jp z, .fabin 
2287				; else decimal 
2287			 
2287				; TODO do decimal conversion 
2287				; decimal is stored as a 16bit word 
2287			 
2287				; by default everything is a string if type is not detected 
2287			.fapstr: ; 
2287 fe 22			cp '"' 
2289 20 01			jr nz, .strnoqu 
228b 23				inc hl 
228c			.strnoqu: 
228c c3 61 21			jp forth_push_str 
228f			 
228f			 
228f			 
228f			.fapbin:    ; push a binary string.  
228f 11 00 00			ld de, 0   ; hold a 16bit value 
2292			 
2292 23			.fapbinshift:	inc hl  
2293 7e				ld a,(hl) 
2294 fe 00			cp 0     ; done scanning  
2296 28 0b			jr z, .fapbdone  	; got it in HL so push  
2298			 
2298				; left shift de 
2298 eb				ex de, hl	 
2299 29				add hl, hl 
229a			 
229a				; is 1 
229a fe 31			cp '1' 
229c 20 02			jr nz, .binzero 
229e cb 4d			bit 1, l 
22a0			.binzero: 
22a0 eb				ex de, hl	 ; save current de 
22a1 18 ef			jr .fapbinshift 
22a3			 
22a3			.fapbdone: 
22a3 eb				ex de, hl 
22a4 c3 f3 20			jp forth_push_numhl 
22a7			 
22a7			 
22a7			.faphex:   ; hex is always stored as a 16bit word 
22a7				; skip number prefix 
22a7 23				inc hl 
22a8				; turn ascii into number 
22a8 cd 3d 13			call get_word_hl	; ret 16bit word in hl 
22ab			 
22ab c3 f3 20			jp forth_push_numhl 
22ae			 
22ae 00				 nop 
22af			 
22af			.fabin:   ; TODO bin conversion 
22af			 
22af			 
22af c9				ret 
22b0			 
22b0			 
22b0			; get either a string ptr or a 16bit word from the data stack 
22b0			 
22b0			FORTH_DSP: macro 
22b0				call macro_forth_dsp 
22b0				endm 
22b0			 
22b0			macro_forth_dsp: 
22b0				; data stack pointer points to current word on tos 
22b0			 
22b0 2a f1 f9			ld hl,(cli_data_sp) 
22b3			 
22b3				if DEBUG_FORTH_PUSH 
22b3						DMARK "DSP" 
22b3 f5				push af  
22b4 3a c8 22			ld a, (.dmark)  
22b7 32 6e fe			ld (debug_mark),a  
22ba 3a c9 22			ld a, (.dmark+1)  
22bd 32 6f fe			ld (debug_mark+1),a  
22c0 3a ca 22			ld a, (.dmark+2)  
22c3 32 70 fe			ld (debug_mark+2),a  
22c6 18 03			jr .pastdmark  
22c8 ..			.dmark: db "DSP"  
22cb f1			.pastdmark: pop af  
22cc			endm  
# End of macro DMARK
22cc			 
22cc cd f3 5d				call display_data_sp 
22cf				;call break_point_state 
22cf				;rst 030h 
22cf				CALLMONITOR 
22cf cd fb 19			call break_point_state  
22d2				endm  
# End of macro CALLMONITOR
22d2				endif 
22d2			 
22d2 c9				ret 
22d3			 
22d3			; return hl to start of value on stack 
22d3			 
22d3			FORTH_DSP_VALUE: macro 
22d3				call macro_forth_dsp_value 
22d3				endm 
22d3			 
22d3			macro_forth_dsp_value: 
22d3			 
22d3				FORTH_DSP 
22d3 cd b0 22			call macro_forth_dsp 
22d6				endm 
# End of macro FORTH_DSP
22d6			 
22d6 d5				push de 
22d7			 
22d7 23				inc hl ; skip type 
22d8			 
22d8 5e				ld e, (hl) 
22d9 23				inc hl 
22da 56				ld d, (hl) 
22db eb				ex de,hl  
22dc			 
22dc d1				pop de 
22dd			 
22dd c9				ret 
22de			 
22de			; return hl to start of value to second item on stack 
22de			 
22de			FORTH_DSP_VALUEM1: macro 
22de				call macro_forth_dsp_value_m1 
22de				endm 
22de			 
22de			macro_forth_dsp_value_m1: 
22de			 
22de				FORTH_DSP 
22de cd b0 22			call macro_forth_dsp 
22e1				endm 
# End of macro FORTH_DSP
22e1			 
22e1 2b				dec hl 
22e2 2b				dec hl 
22e3			;	dec hl 
22e3			 
22e3 d5				push de 
22e4			 
22e4 5e				ld e, (hl) 
22e5 23				inc hl 
22e6 56				ld d, (hl) 
22e7 eb				ex de,hl  
22e8			 
22e8 d1				pop de 
22e9			 
22e9 c9				ret 
22ea			 
22ea				 
22ea			 
22ea			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
22ea			 
22ea			FORTH_DSP_POP: macro 
22ea				call macro_forth_dsp_pop 
22ea				endm 
22ea			 
22ea			 
22ea			; get the tos data type 
22ea			 
22ea			FORTH_DSP_TYPE:   macro 
22ea			 
22ea				;FORTH_DSP_VALUE 
22ea				FORTH_DSP 
22ea				 
22ea				; hl points to value 
22ea				; check type 
22ea			 
22ea				ld a,(hl) 
22ea			 
22ea				endm 
22ea			 
22ea			; load the tos value into hl 
22ea			 
22ea			 
22ea			FORTH_DSP_VALUEHL:  macro 
22ea				call macro_dsp_valuehl 
22ea				endm 
22ea			 
22ea			 
22ea			 
22ea			macro_dsp_valuehl: 
22ea				FORTH_DSP_VALUE 
22ea cd d3 22			call macro_forth_dsp_value 
22ed				endm 
# End of macro FORTH_DSP_VALUE
22ed			 
22ed				;FORTH_ERR_TOS_NOTNUM 
22ed			 
22ed				;inc hl   ; skip type id 
22ed			 
22ed			;	push de 
22ed			; 
22ed			;	ld e, (hl) 
22ed			;	inc hl 
22ed			;	ld d, (hl) 
22ed			;	ex de,hl  
22ed			 
22ed			;	pop de 
22ed			 
22ed				if DEBUG_FORTH_PUSH 
22ed						DMARK "DVL" 
22ed f5				push af  
22ee 3a 02 23			ld a, (.dmark)  
22f1 32 6e fe			ld (debug_mark),a  
22f4 3a 03 23			ld a, (.dmark+1)  
22f7 32 6f fe			ld (debug_mark+1),a  
22fa 3a 04 23			ld a, (.dmark+2)  
22fd 32 70 fe			ld (debug_mark+2),a  
2300 18 03			jr .pastdmark  
2302 ..			.dmark: db "DVL"  
2305 f1			.pastdmark: pop af  
2306			endm  
# End of macro DMARK
2306				CALLMONITOR 
2306 cd fb 19			call break_point_state  
2309				endm  
# End of macro CALLMONITOR
2309				endif 
2309 c9				ret 
230a			 
230a			forth_apushstrhl:      
230a				; push of string requires use of cli_origptr 
230a				; bodge use 
230a			 
230a				; get current cli_origptr, save, update with temp pointer  
230a ed 5b 41 fa		ld de, (cli_origptr) 
230e 22 41 fa			ld (cli_origptr), hl 
2311 d5				push de 
2312 cd 5c 22			call forth_apush 
2315 d1				pop de 
2316 ed 53 41 fa		ld (cli_origptr), de 
231a c9			        ret	 
231b			 
231b			 
231b			; increase loop stack pointer and save hl to it 
231b				 
231b			FORTH_LOOP_NEXT: macro 
231b				call macro_forth_loop_next 
231b				;nop 
231b				endm 
231b			 
231b			macro_forth_loop_next: 
231b				if DEBUG_FORTH_STACK_GUARD 
231b cd 81 71				call check_stacks 
231e				endif 
231e e5				push hl 
231f d5				push de 
2320 eb				ex de,hl 
2321 2a f3 f9			ld hl,(cli_loop_sp) 
2324 23				inc hl 
2325 23				inc hl 
2326					if DEBUG_FORTH_WORDS 
2326						DMARK "LNX" 
2326 f5				push af  
2327 3a 3b 23			ld a, (.dmark)  
232a 32 6e fe			ld (debug_mark),a  
232d 3a 3c 23			ld a, (.dmark+1)  
2330 32 6f fe			ld (debug_mark+1),a  
2333 3a 3d 23			ld a, (.dmark+2)  
2336 32 70 fe			ld (debug_mark+2),a  
2339 18 03			jr .pastdmark  
233b ..			.dmark: db "LNX"  
233e f1			.pastdmark: pop af  
233f			endm  
# End of macro DMARK
233f						CALLMONITOR 
233f cd fb 19			call break_point_state  
2342				endm  
# End of macro CALLMONITOR
2342					endif 
2342 22 f3 f9			ld (cli_loop_sp),hl 
2345 73				ld (hl), e 
2346 23				inc hl 
2347 72				ld (hl), d 
2348 d1				pop de    ; been reversed so save a swap on restore 
2349 e1				pop hl 
234a				if DEBUG_FORTH_STACK_GUARD 
234a cd 81 71				call check_stacks 
234d				endif 
234d c9				ret 
234e			 
234e			; get current ret stack pointer and save to hl  
234e				 
234e			FORTH_LOOP_TOS: macro 
234e				call macro_forth_loop_tos 
234e				endm 
234e			 
234e			macro_forth_loop_tos: 
234e d5				push de 
234f 2a f3 f9			ld hl,(cli_loop_sp) 
2352 5e				ld e, (hl) 
2353 23				inc hl 
2354 56				ld d, (hl) 
2355 eb				ex de, hl 
2356 d1				pop de 
2357 c9				ret 
2358			 
2358			; pop loop stack pointer 
2358				 
2358			FORTH_LOOP_POP: macro 
2358				call macro_forth_loop_pop 
2358				endm 
2358			 
2358			 
2358			macro_forth_loop_pop: 
2358				if DEBUG_FORTH_STACK_GUARD 
2358					DMARK "LPP" 
2358 f5				push af  
2359 3a 6d 23			ld a, (.dmark)  
235c 32 6e fe			ld (debug_mark),a  
235f 3a 6e 23			ld a, (.dmark+1)  
2362 32 6f fe			ld (debug_mark+1),a  
2365 3a 6f 23			ld a, (.dmark+2)  
2368 32 70 fe			ld (debug_mark+2),a  
236b 18 03			jr .pastdmark  
236d ..			.dmark: db "LPP"  
2370 f1			.pastdmark: pop af  
2371			endm  
# End of macro DMARK
2371 cd 81 71				call check_stacks 
2374					FORTH_CHK_LOOP_UNDER 
2374 e5				push hl 
2375 d5				push de 
2376 2a f3 f9			ld hl,(cli_loop_sp) 
2379 11 2d f9			ld de, cli_loop_stack 
237c cd a4 0f			call cmp16 
237f da 9b 72			jp c, fault_loop_under 
2382 d1				pop de 
2383 e1				pop hl 
2384				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2384				endif 
2384 e5				push hl 
2385 2a f3 f9			ld hl,(cli_loop_sp) 
2388 2b				dec hl 
2389 2b				dec hl 
238a 22 f3 f9			ld (cli_loop_sp), hl 
238d				; TODO do stack underflow checks 
238d e1				pop hl 
238e				if DEBUG_FORTH_STACK_GUARD 
238e cd 81 71				call check_stacks 
2391					FORTH_CHK_LOOP_UNDER 
2391 e5				push hl 
2392 d5				push de 
2393 2a f3 f9			ld hl,(cli_loop_sp) 
2396 11 2d f9			ld de, cli_loop_stack 
2399 cd a4 0f			call cmp16 
239c da 9b 72			jp c, fault_loop_under 
239f d1				pop de 
23a0 e1				pop hl 
23a1				endm 
# End of macro FORTH_CHK_LOOP_UNDER
23a1				endif 
23a1 c9				ret 
23a2			 
23a2			macro_forth_dsp_pop: 
23a2			 
23a2 e5				push hl 
23a3			 
23a3				; release malloc data 
23a3			 
23a3				if DEBUG_FORTH_STACK_GUARD 
23a3 cd 81 71				call check_stacks 
23a6					FORTH_CHK_DSP_UNDER 
23a6 e5				push hl 
23a7 d5				push de 
23a8 2a f1 f9			ld hl,(cli_data_sp) 
23ab 11 2b f7			ld de, cli_data_stack 
23ae cd a4 0f			call cmp16 
23b1 da 8f 72			jp c, fault_dsp_under 
23b4 d1				pop de 
23b5 e1				pop hl 
23b6				endm 
# End of macro FORTH_CHK_DSP_UNDER
23b6				endif 
23b6				;ld hl,(cli_data_sp) 
23b6			if DEBUG_FORTH_DOT 
23b6				DMARK "DPP" 
23b6 f5				push af  
23b7 3a cb 23			ld a, (.dmark)  
23ba 32 6e fe			ld (debug_mark),a  
23bd 3a cc 23			ld a, (.dmark+1)  
23c0 32 6f fe			ld (debug_mark+1),a  
23c3 3a cd 23			ld a, (.dmark+2)  
23c6 32 70 fe			ld (debug_mark+2),a  
23c9 18 03			jr .pastdmark  
23cb ..			.dmark: db "DPP"  
23ce f1			.pastdmark: pop af  
23cf			endm  
# End of macro DMARK
23cf				CALLMONITOR 
23cf cd fb 19			call break_point_state  
23d2				endm  
# End of macro CALLMONITOR
23d2			endif	 
23d2			 
23d2			 
23d2			if FORTH_ENABLE_DSPPOPFREE 
23d2			 
23d2				FORTH_DSP 
23d2 cd b0 22			call macro_forth_dsp 
23d5				endm 
# End of macro FORTH_DSP
23d5			 
23d5 7e				ld a, (hl) 
23d6 fe 01			cp DS_TYPE_STR 
23d8 20 23			jr nz, .skippopfree 
23da			 
23da				FORTH_DSP_VALUEHL 
23da cd ea 22			call macro_dsp_valuehl 
23dd				endm 
# End of macro FORTH_DSP_VALUEHL
23dd 00				nop 
23de			if DEBUG_FORTH_DOT 
23de				DMARK "DPf" 
23de f5				push af  
23df 3a f3 23			ld a, (.dmark)  
23e2 32 6e fe			ld (debug_mark),a  
23e5 3a f4 23			ld a, (.dmark+1)  
23e8 32 6f fe			ld (debug_mark+1),a  
23eb 3a f5 23			ld a, (.dmark+2)  
23ee 32 70 fe			ld (debug_mark+2),a  
23f1 18 03			jr .pastdmark  
23f3 ..			.dmark: db "DPf"  
23f6 f1			.pastdmark: pop af  
23f7			endm  
# End of macro DMARK
23f7				CALLMONITOR 
23f7 cd fb 19			call break_point_state  
23fa				endm  
# End of macro CALLMONITOR
23fa			endif	 
23fa cd 17 15			call free 
23fd			.skippopfree: 
23fd				 
23fd			 
23fd			endif 
23fd			 
23fd			if DEBUG_FORTH_DOT_KEY 
23fd				DMARK "DP2" 
23fd				CALLMONITOR 
23fd			endif	 
23fd			 
23fd				; move pointer down 
23fd			 
23fd 2a f1 f9			ld hl,(cli_data_sp) 
2400 2b				dec hl 
2401 2b				dec hl 
2402			; PARSEV5 
2402 2b				dec hl 
2403 22 f1 f9			ld (cli_data_sp), hl 
2406			 
2406				if DEBUG_FORTH_STACK_GUARD 
2406 cd 81 71				call check_stacks 
2409					FORTH_CHK_DSP_UNDER 
2409 e5				push hl 
240a d5				push de 
240b 2a f1 f9			ld hl,(cli_data_sp) 
240e 11 2b f7			ld de, cli_data_stack 
2411 cd a4 0f			call cmp16 
2414 da 8f 72			jp c, fault_dsp_under 
2417 d1				pop de 
2418 e1				pop hl 
2419				endm 
# End of macro FORTH_CHK_DSP_UNDER
2419				endif 
2419			 
2419 e1				pop hl 
241a			 
241a c9				ret 
241b			 
241b			getwordathl: 
241b				; hl points to an address 
241b				; load hl with the word at that address 
241b			 
241b d5				push de 
241c			 
241c 5e				ld e, (hl) 
241d 23				inc hl 
241e 56				ld d, (hl) 
241f eb				ex de, hl 
2420			 
2420 d1				pop de 
2421 c9				ret 
2422			 
2422			 
2422			 
2422			 
2422			 
2422			; eof 
2422			 
# End of file forth_stackopsv5.asm
2422			endif 
2422			 
2422			loadwordinhl:	 
2422			 
2422 d5				push de 
2423			 
2423 5e				ld e, (hl) 
2424 23				inc hl 
2425 56				ld d, (hl) 
2426 eb				ex de,hl  
2427			 
2427 d1				pop de 
2428			 
2428 c9				ret 
2429			 
2429			user_word_eol:  
2429				; hl contains the pointer to where to create a linked list item from the end 
2429				; of the user dict to continue on at the system word dict 
2429				 
2429				; poke the stub of the word list linked list to repoint to rom words 
2429			 
2429				; stub format 
2429				; db   word id 
2429				; dw    link to next word 
2429			        ; db char length of token 
2429				; db string + 0 term 
2429				; db exec code....  
2429			 
2429 3e 00			ld a, WORD_SYS_ROOT     ; root word 
242b 77				ld (hl), a		; word id 
242c 23				inc hl 
242d			 
242d 11 f8 25			ld de, sysdict 
2430 73				ld (hl), e		; next word link ie system dict 
2431 23				inc hl 
2432 72				ld (hl), d		; next word link ie system dict 
2433 23				inc hl	 
2434			 
2434			;	ld (hl), sysdict		; next word link ie system dict 
2434			;	inc hl 
2434			;	inc hl 
2434			 
2434			;	inc hl 
2434			;	inc hl 
2434			 
2434 3e 02			ld a, 2			; word length is 0 
2436 77				ld (hl), a	 
2437 23				inc hl 
2438			 
2438 3e 7e			ld a, '~'			; word length is 0 
243a 77				ld (hl), a	 
243b 23				inc hl 
243c 3e 00			ld a, 0			; save empty word 
243e 77				ld (hl), a 
243f			 
243f c9				ret 
2440			 
2440				 
2440			 
2440			forthexec_cleanup: 
2440				FORTH_RSP_POP 
2440 cd bb 20			call macro_forth_rsp_pop 
2443				endm 
# End of macro FORTH_RSP_POP
2443 c9				ret 
2444			 
2444			forth_call_hl: 
2444				; taking hl 
2444 e5				push hl 
2445 c9				ret 
2446			 
2446			; this is called to reset Forth system but keep existing uwords etc 
2446			 
2446			forth_warmstart: 
2446				; setup stack over/under flow checks 
2446				if DEBUG_FORTH_STACK_GUARD 
2446 cd 67 71				call chk_stk_init 
2449				endif 
2449			 
2449				; init stack pointers  - * these stacks go upwards *  
2449 21 af f9			ld hl, cli_ret_stack 
244c 22 f5 f9			ld (cli_ret_sp), hl	 
244f				; set bottom of stack 
244f 3e 00			ld a,0 
2451 77				ld (hl),a 
2452 23				inc hl 
2453 77				ld (hl),a 
2454			 
2454 21 2b f7			ld hl, cli_data_stack 
2457 22 f1 f9			ld (cli_data_sp), hl	 
245a				; set bottom of stack 
245a 3e 00			ld a,0 
245c 77				ld (hl),a 
245d 23				inc hl 
245e 77				ld (hl),a 
245f			 
245f 21 2d f9			ld hl, cli_loop_stack 
2462 22 f3 f9			ld (cli_loop_sp), hl	 
2465				; set bottom of stack 
2465 3e 00			ld a,0 
2467 77				ld (hl),a 
2468 23				inc hl 
2469 77				ld (hl),a 
246a			 
246a				; init extent of current open file 
246a			 
246a 3e 00			ld a, 0 
246c 32 6d fa			ld (store_openext), a 
246f			 
246f c9				ret 
2470			 
2470			 
2470			; Cold Start - this is called to setup the whole Forth system 
2470			 
2470			forth_init: 
2470			 
2470				; setup stack over/under flow checks 
2470			 
2470			;	if DEBUG_FORTH_STACK_GUARD 
2470			;		call chk_stk_init 
2470			;	endif 
2470			 
2470				; enable auto display updates (slow.....) 
2470			 
2470 3e 01			ld a, 1 
2472 32 3f fa			ld (cli_autodisplay), a 
2475			 
2475				; if storage is in use disable long reads for now 
2475 3e 00			ld a, 0 
2477 32 78 fa			ld (store_longread), a 
247a			 
247a			 
247a				; show start up screen 
247a			 
247a cd 52 0d			call clear_display 
247d			 
247d 3e 00			ld a,0 
247f 32 61 fa			ld (f_cursor_ptr), a 
2482			 
2482				; set start of word list in start of ram - for use when creating user words 
2482			 
2482 21 00 80			ld hl, baseram 
2485 22 c1 f4			ld (os_last_new_uword), hl 
2488 cd 29 24			call user_word_eol 
248b				 
248b			;		call display_data_sp 
248b			;		call next_page_prompt 
248b			 
248b			 
248b			 
248b			 
248b c9				ret 
248c			 
248c .. 00		.bootforth: db " Forth Kernel Init ",0 
24a0			 
24a0			; TODO push to stack 
24a0			 
24a0			;  
24a0			 
24a0			if FORTH_PARSEV2 
24a0			 
24a0			 
24a0				include "forth_parserv2.asm" 
24a0			 
24a0			endif 
24a0			 
24a0			 
24a0			; parse cli version 1 
24a0			 
24a0			if FORTH_PARSEV1 
24a0			 
24a0			 
24a0			 
24a0			      include "forth_parserv1.asm" 
24a0			endif 
24a0				 
24a0			if FORTH_PARSEV3 
24a0			 
24a0			 
24a0			 
24a0			      include "forth_parserv3.asm" 
24a0				include "forth_wordsv3.asm" 
24a0			endif 
24a0			 
24a0			if FORTH_PARSEV4 
24a0			 
24a0			 
24a0			 
24a0			      include "forth_parserv4.asm" 
24a0				include "forth_wordsv4.asm" 
24a0			endif 
24a0			 
24a0			if FORTH_PARSEV5 
24a0			 
24a0			 
24a0			 
24a0			      include "forth_parserv5.asm" 
24a0			 
24a0			 
24a0			; A better parser without using malloc and string copies all over the place.  
24a0			; Exec in situ should be faster 
24a0			 
24a0			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
24a0			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
24a0			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
24a0			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
24a0			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
24a0			WORD_SYS_END: equ 0   ; Opcode for all user words 
24a0			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
24a0			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
24a0			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
24a0			 
24a0			; Core word preamble macro 
24a0			 
24a0			CWHEAD:   macro nxtword opcode lit len opflags 
24a0				db WORD_SYS_CORE+opcode             
24a0				; internal op code number 
24a0				dw nxtword            
24a0				; link to next dict word block 
24a0				db len + 1 
24a0				; literal length of dict word inc zero term 
24a0				db lit,0              
24a0				; literal dict word 
24a0			        ; TODO db opflags        
24a0				endm 
24a0			 
24a0			 
24a0			NEXTW: macro  
24a0				jp macro_next 
24a0				endm 
24a0			 
24a0			macro_next: 
24a0			if DEBUG_FORTH_PARSE_KEY 
24a0				DMARK "NXT" 
24a0				CALLMONITOR 
24a0			endif	 
24a0			;	inc hl  ; skip token null term  
24a0 ed 4b 43 fa		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
24a4 ed 5b 41 fa		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
24a8 2a c5 f4			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
24ab			if DEBUG_FORTH_PARSE_KEY 
24ab				DMARK "}AA" 
24ab				CALLMONITOR 
24ab			endif	 
24ab c3 ae 25			jp execnext 
24ae				;jp exec1 
24ae			       
24ae			 
24ae			 
24ae			; Another go at the parser to compile  
24ae			 
24ae			 
24ae			; TODO rework parser to change all of the string words to byte tokens 
24ae			; TODO do a search for  
24ae			 
24ae			; TODO first run normal parser to zero term sections 
24ae			; TODO for each word do a token look up to get the op code 
24ae			; TODO need some means to flag to the exec that this is a byte code form    
24ae			 
24ae			 
24ae			forthcompile: 
24ae			 
24ae			; 
24ae			; line parse: 
24ae			;       parse raw input buffer 
24ae			;       tokenise the words 
24ae			;       malloc new copy (for looping etc) 
24ae			;       copy to malloc + current pc in line to start of string and add line term 
24ae			;       save on new rsp 
24ae			; 
24ae			 
24ae			; hl to point to the line to tokenise 
24ae			 
24ae			;	push hl 
24ae 22 c5 f4			ld (os_tok_ptr), hl  ; save ptr to string 
24b1			 
24b1			;	ld a,0		; string term on input 
24b1			;	call strlent 
24b1			 
24b1			;	ld (os_tok_len), hl	 ; save string length 
24b1			 
24b1			;if DEBUG_FORTH_TOK 
24b1			;	ex de,hl		 
24b1			;endif 
24b1			 
24b1			;	pop hl 		; get back string pointer 
24b1			 
24b1			if DEBUG_FORTH_TOK 
24b1						DMARK "TOc" 
24b1				CALLMONITOR 
24b1			endif 
24b1 7e			.cptoken2:    ld a,(hl) 
24b2 23				inc hl 
24b3 fe 7f			cp FORTH_END_BUFFER 
24b5 28 29			jr z, .cptokendone2 
24b7 fe 00			cp 0 
24b9 28 25			jr z, .cptokendone2 
24bb fe 22			cp '"' 
24bd 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
24bf fe 20			cp ' ' 
24c1 20 ee			jr nz,  .cptoken2 
24c3			 
24c3			; TODO consume comments held between ( and ) 
24c3			 
24c3				; we have a space so change to zero term for dict match later 
24c3 2b				dec hl 
24c4 3e 00			ld a,0 
24c6 77				ld (hl), a 
24c7 23				inc hl 
24c8 18 e7			jr .cptoken2 
24ca				 
24ca			 
24ca			.cptokenstr2: 
24ca				; skip all white space until either eol (because forgot to term) or end double quote 
24ca			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
24ca				;inc hl ; skip current double quote 
24ca 7e				ld a,(hl) 
24cb 23				inc hl 
24cc fe 22			cp '"' 
24ce 28 e1			jr z, .cptoken2 
24d0 fe 7f			cp FORTH_END_BUFFER 
24d2 28 0c			jr z, .cptokendone2 
24d4 fe 00			cp 0 
24d6 28 08			jr z, .cptokendone2 
24d8 fe 20			cp ' ' 
24da 28 02			jr z, .cptmp2 
24dc 18 ec			jr .cptokenstr2 
24de			 
24de			.cptmp2:	; we have a space so change to zero term for dict match later 
24de				;dec hl 
24de				;ld a,"-"	; TODO remove this when working 
24de				;ld (hl), a 
24de				;inc hl 
24de 18 ea			jr .cptokenstr2 
24e0			 
24e0			.cptokendone2: 
24e0				;inc hl 
24e0 3e 7f			ld a, FORTH_END_BUFFER 
24e2 77				ld (hl),a 
24e3 23				inc hl 
24e4 3e 21			ld a, '!' 
24e6 77				ld (hl),a 
24e7			 
24e7 2a c5 f4			ld hl,(os_tok_ptr) 
24ea			         
24ea			if DEBUG_FORTH_TOK 
24ea						DMARK "Tc1" 
24ea				CALLMONITOR 
24ea			endif 
24ea			 
24ea				; push exec string to top of return stack 
24ea				FORTH_RSP_NEXT 
24ea cd 9a 20			call macro_forth_rsp_next 
24ed				endm 
# End of macro FORTH_RSP_NEXT
24ed c9				ret 
24ee			 
24ee			; Another go at the parser need to simplify the process 
24ee			 
24ee			forthparse: 
24ee			 
24ee			; 
24ee			; line parse: 
24ee			;       parse raw input buffer 
24ee			;       tokenise the words 
24ee			;       malloc new copy (for looping etc) 
24ee			;       copy to malloc + current pc in line to start of string and add line term 
24ee			;       save on new rsp 
24ee			; 
24ee			 
24ee			; hl to point to the line to tokenise 
24ee			 
24ee			;	push hl 
24ee 22 c5 f4			ld (os_tok_ptr), hl  ; save ptr to string 
24f1			 
24f1			;	ld a,0		; string term on input 
24f1			;	call strlent 
24f1			 
24f1			;	ld (os_tok_len), hl	 ; save string length 
24f1			 
24f1			;if DEBUG_FORTH_TOK 
24f1			;	ex de,hl		 
24f1			;endif 
24f1			 
24f1			;	pop hl 		; get back string pointer 
24f1			 
24f1			if DEBUG_FORTH_TOK 
24f1						DMARK "TOK" 
24f1				CALLMONITOR 
24f1			endif 
24f1 7e			.ptoken2:    ld a,(hl) 
24f2 23				inc hl 
24f3 fe 7f			cp FORTH_END_BUFFER 
24f5 28 29			jr z, .ptokendone2 
24f7 fe 00			cp 0 
24f9 28 25			jr z, .ptokendone2 
24fb fe 22			cp '"' 
24fd 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
24ff fe 20			cp ' ' 
2501 20 ee			jr nz,  .ptoken2 
2503			 
2503			; TODO consume comments held between ( and ) 
2503			 
2503				; we have a space so change to zero term for dict match later 
2503 2b				dec hl 
2504 3e 00			ld a,0 
2506 77				ld (hl), a 
2507 23				inc hl 
2508 18 e7			jr .ptoken2 
250a				 
250a			 
250a			.ptokenstr2: 
250a				; skip all white space until either eol (because forgot to term) or end double quote 
250a			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
250a				;inc hl ; skip current double quote 
250a 7e				ld a,(hl) 
250b 23				inc hl 
250c fe 22			cp '"' 
250e 28 e1			jr z, .ptoken2 
2510 fe 7f			cp FORTH_END_BUFFER 
2512 28 0c			jr z, .ptokendone2 
2514 fe 00			cp 0 
2516 28 08			jr z, .ptokendone2 
2518 fe 20			cp ' ' 
251a 28 02			jr z, .ptmp2 
251c 18 ec			jr .ptokenstr2 
251e			 
251e			.ptmp2:	; we have a space so change to zero term for dict match later 
251e				;dec hl 
251e				;ld a,"-"	; TODO remove this when working 
251e				;ld (hl), a 
251e				;inc hl 
251e 18 ea			jr .ptokenstr2 
2520			 
2520			.ptokendone2: 
2520				;inc hl 
2520 3e 7f			ld a, FORTH_END_BUFFER 
2522 77				ld (hl),a 
2523 23				inc hl 
2524 3e 21			ld a, '!' 
2526 77				ld (hl),a 
2527			 
2527 2a c5 f4			ld hl,(os_tok_ptr) 
252a			         
252a			if DEBUG_FORTH_TOK 
252a						DMARK "TK1" 
252a				CALLMONITOR 
252a			endif 
252a			 
252a				; push exec string to top of return stack 
252a				FORTH_RSP_NEXT 
252a cd 9a 20			call macro_forth_rsp_next 
252d				endm 
# End of macro FORTH_RSP_NEXT
252d c9				ret 
252e			 
252e			; 
252e			;	; malloc size + buffer pointer + if is loop flag 
252e			;	ld hl,(os_tok_len) 		 ; get string length 
252e			; 
252e			;	ld a,l 
252e			; 
252e			;	cp 0			; we dont want to use a null string 
252e			;	ret z 
252e			; 
252e			;;	add 3    ; prefix malloc with buffer for current word ptr 
252e			; 
252e			;	add 5     ; TODO when certain not over writing memory remove 
252e			; 
252e			;		 
252e			; 
252e			;if DEBUG_FORTH_TOK 
252e			;			DMARK "TKE" 
252e			;	CALLMONITOR 
252e			;endif 
252e			; 
252e			;	ld l,a 
252e			;	ld h,0 
252e			;;	push hl   ; save required space for the copy later 
252e			;	call malloc 
252e			;if DEBUG_FORTH_TOK 
252e			;			DMARK "TKM" 
252e			;	CALLMONITOR 
252e			;endif 
252e			;	if DEBUG_FORTH_MALLOC_GUARD 
252e			;		push af 
252e			;		call ishlzero 
252e			;;		ld a, l 
252e			;;		add h 
252e			;;		cp 0 
252e			;		pop af 
252e			;		 
252e			;		call z,malloc_error 
252e			;	endif 
252e			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
252e			; 
252e			; 
252e			;if DEBUG_FORTH_TOK 
252e			;			DMARK "TKR" 
252e			;	CALLMONITOR 
252e			;endif 
252e			; 
252e			;	FORTH_RSP_NEXT 
252e			; 
252e			;	;inc hl	 ; go past current buffer pointer 
252e			;	;inc hl 
252e			;	;inc hl   ; and past if loop flag 
252e			;		; TODO Need to set flag  
252e			; 
252e			;	 
252e			;	 
252e			;	ex de,hl	; malloc is dest 
252e			;	ld hl, (os_tok_len) 
252e			;;	pop bc 
252e			;	ld c, l                
252e			;	ld b,0 
252e			;	ld hl, (os_tok_ptr) 
252e			; 
252e			;if DEBUG_FORTH_TOK 
252e			;			DMARK "TKT" 
252e			;	CALLMONITOR 
252e			;endif 
252e			; 
252e			;	; do str cpy 
252e			; 
252e			;	ldir      ; copy byte in hl to de 
252e			; 
252e			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
252e			; 
252e			;if DEBUG_FORTH_TOK 
252e			; 
252e			;			DMARK "TKY" 
252e			;	CALLMONITOR 
252e			;endif 
252e			;	;ld a,0 
252e			;	;ld a,FORTH_END_BUFFER 
252e			;	ex de, hl 
252e			;	;dec hl			 ; go back over the space delim at the end of word 
252e			;	;ld (hl),a 
252e			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
252e			;	ld a,FORTH_END_BUFFER 
252e			;	ld (hl),a 
252e			;	inc hl 
252e			;	ld a,FORTH_END_BUFFER 
252e			;	ld (hl),a 
252e			; 
252e			;	; init the malloc area data 
252e			;	; set pc for in current area 
252e			;	;ld hl, (os_tok_malloc) 
252e			;	;inc hl 
252e			;	;inc hl 
252e			;	;inc hl 
252e			;	;ex de,hl 
252e			;	;ld hl, (os_tok_malloc) 
252e			;	;ld (hl),e 
252e			;	;inc hl 
252e			;	;ld (hl),d 
252e			; 
252e			; 
252e			;	ld hl,(os_tok_malloc) 
252e			;if DEBUG_FORTH_PARSE_KEY 
252e			;			DMARK "TKU" 
252e			;	CALLMONITOR 
252e			;endif 
252e			; 
252e			;	ret 
252e			 
252e			forthexec: 
252e			 
252e			; line exec: 
252e			; forth parser 
252e			 
252e			; 
252e			;       get current exec line on rsp 
252e			 
252e				FORTH_RSP_TOS 
252e cd b1 20			call macro_forth_rsp_tos 
2531				endm 
# End of macro FORTH_RSP_TOS
2531			 
2531			;       restore current pc - hl points to malloc of data 
2531			 
2531				;ld e, (hl) 
2531				;inc hl 
2531				;ld d, (hl) 
2531				;ex de,hl 
2531			 
2531			 
2531			exec1: 
2531 22 c5 f4			ld (os_tok_ptr), hl 
2534			 
2534				; copy our PC to working vars  
2534 22 43 fa			ld (cli_ptr), hl 
2537 22 41 fa			ld (cli_origptr), hl 
253a			 
253a 7e				ld a,(hl) 
253b fe 7f			cp FORTH_END_BUFFER 
253d c8				ret z 
253e			 
253e				; skip any nulls 
253e			 
253e fe 00			cp 0 
2540 20 03			jr nz, .execword 
2542 23				inc hl 
2543 18 ec			jr exec1 
2545			 
2545			 
2545			.execword: 
2545			 
2545			 
2545			 
2545			if DEBUG_FORTH_PARSE_KEY 
2545						DMARK "KYQ" 
2545				CALLMONITOR 
2545			endif 
2545			;       while at start of word: 
2545			; get start of dict (in user area first) 
2545			 
2545 21 00 80		ld hl, baseram 
2548			;ld hl, sysdict 
2548 22 45 fa		ld (cli_nextword),hl 
254b			;           match word at pc 
254b			;           exec word 
254b			;           or push to dsp 
254b			;           forward to next token 
254b			;           if line term pop rsp and exit 
254b			;        
254b			 
254b			if DEBUG_FORTH_PARSE_KEY 
254b						DMARK "KYq" 
254b				CALLMONITOR 
254b			endif 
254b			 
254b			; 
254b			; word comp 
254b			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
254b			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
254b			;    move to start of word  
254b			;    compare word to cli_token 
254b			 
254b			.execpnword:	; HL at start of a word in the dictionary to check 
254b			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
254b			;	ld (cli_ptr), hl 
254b			 
254b 2a 45 fa			ld hl,(cli_nextword) 
254e			 
254e cd f1 25			call forth_tok_next 
2551			; tok next start here 
2551			;	; TODO skip compiled symbol for now 
2551			;	inc hl 
2551			; 
2551			;	; save pointer to next word 
2551			; 
2551			;	; hl now points to the address of the next word pointer  
2551			;	ld e, (hl) 
2551			;	inc hl 
2551			;	ld d, (hl) 
2551			;	inc l 
2551			; 
2551			;	ex de,hl 
2551			;if DEBUG_FORTH_PARSE_NEXTWORD 
2551			;	push bc 
2551			;	ld bc, (cli_nextword) 
2551			;			DMARK "NXW" 
2551			;	CALLMONITOR 
2551			;	pop bc 
2551			;endif 
2551			; tok next end here 
2551 22 45 fa			ld (cli_nextword), hl     ; save for next check if no match on this word 
2554 eb				ex de, hl 
2555			 
2555			 
2555				; save the pointer of the current token - 1 to check against 
2555				 
2555 22 49 fa			ld (cli_token), hl   
2558				; TODO maybe remove below save if no debug 
2558				; save token string ptr for any debug later 
2558 23				inc hl  
2559 22 4b fa			ld (cli_origtoken), hl 
255c 2b				dec hl 
255d				; save pointer to the start of the next dictionay word 
255d 7e				ld a,(hl)   ; get string length 
255e 47				ld b,a 
255f			.execpnwordinc:  
255f 23				inc hl 
2560 10 fd			djnz .execpnwordinc 
2562 22 47 fa			ld (cli_execword), hl      ; save start of this words code 
2565			 
2565				; now check the word token against the string being parsed 
2565			 
2565 2a 49 fa			ld hl,(cli_token) 
2568 23				inc hl     ; skip string length (use zero term instead to end) 
2569 22 49 fa			ld (cli_token), hl 
256c			 
256c			if DEBUG_FORTH_PARSE_KEY 
256c						DMARK "KY2" 
256c			endif 
256c			if DEBUG_FORTH_PARSE_EXEC 
256c				; see if disabled 
256c			 
256c				ld a, (os_view_disable) 
256c				cp '*' 
256c				jr z, .skip 
256c			 
256c				push hl 
256c				push hl 
256c				call clear_display 
256c				ld de, .compword 
256c				ld a, display_row_1 
256c				call str_at_display 
256c				pop de 
256c				ld a, display_row_2 
256c				call str_at_display 
256c				ld hl,(cli_ptr) 
256c				ld a,(hl) 
256c			        ld hl, os_word_scratch 
256c				ld (hl),a 
256c				ld a,0 
256c				inc hl 
256c				ld (hl),a 	 
256c				ld de, os_word_scratch 
256c				ld a, display_row_2+10 
256c				call str_at_display 
256c				call update_display 
256c				ld a, 100 
256c				call aDelayInMS 
256c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
256c				call delay250ms 
256c				endif 
256c				pop hl 
256c			.skip:  
256c			endif	 
256c			.execpnchar:    ; compare char between token and string to parse 
256c			 
256c			if DEBUG_FORTH_PARSE_KEY 
256c						DMARK "Ky3" 
256c			endif 
256c			if DEBUG_FORTH_PARSE_EXEC 
256c				; see if disabled 
256c			 
256c				ld a, (os_view_disable) 
256c				cp '*' 
256c				jr z, .skip2 
256c			 
256c			;	call clear_display 
256c			ld hl,(cli_token) 
256c			ld a,(hl) 
256c			ld (os_word_scratch),a 
256c				ld hl,(cli_ptr) 
256c			ld a,(hl) 
256c				ld (os_word_scratch+1),a 
256c				ld a,0 
256c				ld (os_word_scratch+2),a 
256c				ld de,os_word_scratch 
256c				ld a,display_row_4 
256c				call str_at_display 
256c				call update_display 
256c			.skip2:  
256c			endif 
256c 2a 49 fa			ld hl,(cli_token) 
256f 7e				ld a, (hl)	 ; char in word token 
2570 23				inc hl 		; move to next char 
2571 22 49 fa			ld (cli_token), hl ; and save it 
2574 47				ld b,a 
2575			 
2575 2a 43 fa			ld hl,(cli_ptr) ;	get the char from the string to parse 
2578 7e				ld a,(hl) 
2579 23				inc hl 
257a 22 43 fa			ld (cli_ptr), hl		; move to next char 
257d cd db 13			call toUpper 		; make sure the input string matches case 
2580			 
2580			if DEBUG_FORTH_PARSE 
2580			endif 
2580			 
2580				; input stream end of token is a space so get rid of it 
2580			 
2580			;	cp ' ' 
2580			;	jr nz, .pnskipspace 
2580			; 
2580			;	ld a, 0		; make same term as word token term 
2580			; 
2580			;.pnskipspace: 
2580			 
2580			if DEBUG_FORTH_PARSE_KEY 
2580						DMARK "KY7" 
2580			endif 
2580 b8				cp b 
2581 c2 97 25			jp nz, .execpnskipword	 ; no match so move to next word 
2584				 
2584			;    if same 
2584			;       scan for string terms 0 for token and 32 for input 
2584			 
2584				 
2584			if DEBUG_FORTH_PARSE_KEY 
2584						DMARK "KY8" 
2584			endif 
2584			 
2584 80				add b			 
2585 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2587							; TODO need to make sure last word in zero term string is accounted for 
2587 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2589			 
2589			 
2589				; at end of both strings so both are exact match 
2589			 
2589			;       skip ptr for next word 
2589			 
2589 2a 43 fa			ld hl,(cli_ptr) 	; at input string term 
258c 23				inc hl			 ; at next char 
258d 22 43 fa			ld (cli_ptr), hl     ; save for next round of the parser 
2590 22 41 fa			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2593				 
2593				 
2593			if DEBUG_FORTH_PARSE_KEY 
2593						DMARK "KY3" 
2593			endif 
2593			 
2593			 
2593			 
2593			;       exec code block 
2593			if DEBUG_FORTH_JP 
2593				call clear_display 
2593				call update_display 
2593				call delay1s 
2593				ld hl, (cli_execword)     ; save for next check if no match on this word 
2593				ld a,h 
2593				ld hl, os_word_scratch 
2593				call hexout 
2593				ld hl, (cli_execword)     ; save for next check if no match on this word 
2593				ld a,l 
2593				ld hl, os_word_scratch+2 
2593				call hexout 
2593				ld hl, os_word_scratch+4 
2593				ld a,0 
2593				ld (hl),a 
2593				ld de,os_word_scratch 
2593				call str_at_display 
2593					ld a, display_row_2 
2593					call str_at_display 
2593				ld de, (cli_origtoken) 
2593				ld a, display_row_1+10 
2593					call str_at_display 
2593			 
2593				ld a,display_row_1 
2593				ld de, .foundword 
2593				ld a, display_row_3 
2593				call str_at_display 
2593				call update_display 
2593				call delay1s 
2593				call delay1s 
2593				call delay1s 
2593			endif 
2593			 
2593			if DEBUG_FORTH_PARSE_KEY 
2593						DMARK "KYj" 
2593			endif 
2593				; TODO save the word pointer in this exec 
2593			 
2593 2a 47 fa			ld hl,(cli_execword) 
2596 e9				jp (hl) 
2597			 
2597			 
2597			;    if not same 
2597			;	scan for zero term 
2597			;	get ptr for next word 
2597			;	goto word comp 
2597			 
2597			.execpnskipword:	; get pointer to next word 
2597 2a 45 fa			ld hl,(cli_nextword) 
259a			 
259a 7e				ld a,(hl) 
259b fe 00			cp WORD_SYS_END 
259d			;	cp 0 
259d 28 09			jr z, .execendofdict			 ; at end of words 
259f			 
259f			if DEBUG_FORTH_PARSE_KEY 
259f						DMARK "KY4" 
259f			endif 
259f			if DEBUG_FORTH_PARSE_EXEC 
259f			 
259f				; see if disabled 
259f			 
259f				ld a, (os_view_disable) 
259f				cp '*' 
259f				jr z, .noskip 
259f			 
259f			 
259f				ld de, .nowordfound 
259f				ld a, display_row_3 
259f				call str_at_display 
259f				call update_display 
259f				ld a, 100 
259f				call aDelayInMS 
259f				 
259f				if DEBUG_FORTH_PARSE_EXEC_SLOW 
259f					call delay250ms 
259f				endif 
259f			.noskip:  
259f			 
259f			endif	 
259f			 
259f 2a 41 fa			ld hl,(cli_origptr) 
25a2 22 43 fa			ld (cli_ptr),hl 
25a5			 
25a5			if DEBUG_FORTH_PARSE_KEY 
25a5						DMARK "KY5" 
25a5			endif 
25a5 c3 4b 25			jp .execpnword			; else go to next word 
25a8			 
25a8			.execendofdict:  
25a8			 
25a8			if DEBUG_FORTH_PARSE_KEY 
25a8						DMARK "KYe" 
25a8			endif 
25a8			if DEBUG_FORTH_PARSE_EXEC 
25a8				; see if disabled 
25a8			 
25a8				ld a, (os_view_disable) 
25a8				cp '*' 
25a8				jr z, .ispskip 
25a8			 
25a8				call clear_display 
25a8				call update_display 
25a8				call delay1s 
25a8				ld de, (cli_origptr) 
25a8				ld a, display_row_1 
25a8				call str_at_display 
25a8				 
25a8				ld de, .enddict 
25a8				ld a, display_row_3 
25a8				call str_at_display 
25a8				call update_display 
25a8				ld a, 100 
25a8				call aDelayInMS 
25a8				if DEBUG_FORTH_PARSE_EXEC_SLOW 
25a8				call delay1s 
25a8				call delay1s 
25a8				call delay1s 
25a8				endif 
25a8			.ispskip:  
25a8				 
25a8			endif	 
25a8			 
25a8			 
25a8			 
25a8				; if the word is not a keyword then must be a literal so push it to stack 
25a8			 
25a8			; push token to stack to end of word 
25a8			 
25a8				STACKFRAME ON $1efe $2f9f 
25a8				if DEBUG_STACK_IMB 
25a8					if ON 
25a8						exx 
25a8						ld de, $1efe 
25a8						ld a, d 
25a8						ld hl, curframe 
25a8						call hexout 
25a8						ld a, e 
25a8						ld hl, curframe+2 
25a8						call hexout 
25a8						ld hl, $1efe 
25a8						push hl 
25a8						ld hl, $2f9f 
25a8						push hl 
25a8						exx 
25a8					endif 
25a8				endif 
25a8			endm 
# End of macro STACKFRAME
25a8			 
25a8 2a c5 f4		ld hl,(os_tok_ptr) 
25ab cd 5c 22		call forth_apush 
25ae			 
25ae				STACKFRAMECHK ON $1efe $2f9f 
25ae				if DEBUG_STACK_IMB 
25ae					if ON 
25ae						exx 
25ae						ld hl, $2f9f 
25ae						pop de   ; $2f9f 
25ae						call cmp16 
25ae						jr nz, .spnosame 
25ae						ld hl, $1efe 
25ae						pop de   ; $1efe 
25ae						call cmp16 
25ae						jr z, .spfrsame 
25ae						.spnosame: call showsperror 
25ae						.spfrsame: nop 
25ae						exx 
25ae					endif 
25ae				endif 
25ae			endm 
# End of macro STACKFRAMECHK
25ae			 
25ae			execnext: 
25ae			 
25ae			if DEBUG_FORTH_PARSE_KEY 
25ae						DMARK "KY>" 
25ae			endif 
25ae			; move past token to next word 
25ae			 
25ae 2a c5 f4		ld hl, (os_tok_ptr) 
25b1 3e 00		ld a, 0 
25b3 01 ff 00		ld bc, 255     ; input buffer size 
25b6 ed b1		cpir 
25b8			 
25b8			if DEBUG_FORTH_PARSE_KEY 
25b8						DMARK "KY!" 
25b8				CALLMONITOR 
25b8			endif	 
25b8			; TODO this might place hl on the null, so will need to forward on??? 
25b8			;inc hl   ; see if this gets onto the next item 
25b8			 
25b8			 
25b8			; TODO pass a pointer to the buffer to push 
25b8			; TODO call function to push 
25b8			 
25b8			; look for end of input 
25b8			 
25b8			;inc hl 
25b8			;ld a,(hl) 
25b8			;cp FORTH_END_BUFFER 
25b8			;ret z 
25b8			 
25b8			 
25b8 c3 31 25		jp exec1 
25bb			 
25bb			 
25bb			 
25bb			 
25bb			 
25bb			 
25bb			 
25bb			 
25bb			 
25bb			findnexttok: 
25bb			 
25bb				; hl is pointer to move 
25bb				; de is the token to locate 
25bb			 
25bb					if DEBUG_FORTH 
25bb						DMARK "NTK" 
25bb						CALLMONITOR 
25bb					endif 
25bb d5				push de 
25bc			 
25bc			.fnt1:	 
25bc				; find first char of token to locate 
25bc			 
25bc 1a				ld a, (de) 
25bd 4f				ld c,a 
25be 7e				ld a,(hl) 
25bf cd db 13			call toUpper 
25c2					if DEBUG_FORTH 
25c2						DMARK "NT1" 
25c2						CALLMONITOR 
25c2					endif 
25c2 b9				cp c 
25c3			 
25c3 28 03			jr z, .fnt2cmpmorefirst	 
25c5			 
25c5				; first char not found move to next char 
25c5			 
25c5 23				inc hl 
25c6 18 f4			jr .fnt1 
25c8			 
25c8			.fnt2cmpmorefirst:	 
25c8				; first char of token found.  
25c8			 
25c8 e5				push hl     ; save start of token just in case it is the right one 
25c9 d9				exx 
25ca e1				pop hl        ; save it to hl' 
25cb d9				exx 
25cc			 
25cc			 
25cc			.fnt2cmpmore:	 
25cc				; compare the rest 
25cc				 
25cc 23				inc hl 
25cd 13				inc de 
25ce				 
25ce 1a				ld a, (de) 
25cf 4f				ld c,a 
25d0 7e				ld a,(hl) 
25d1 cd db 13			call toUpper 
25d4			 
25d4					if DEBUG_FORTH 
25d4						DMARK "NT2" 
25d4						CALLMONITOR 
25d4					endif 
25d4				; c has the token to find char 
25d4				; a has the mem to scan char 
25d4			 
25d4 b9				cp c 
25d5 28 04			jr z,.fntmatch1 
25d7			 
25d7				; they are not the same 
25d7			 
25d7					if DEBUG_FORTH 
25d7						DMARK "NT3" 
25d7						CALLMONITOR 
25d7					endif 
25d7 d1				pop de	; reset de token to look for 
25d8 d5				push de 
25d9 18 e1			jr .fnt1 
25db				 
25db			.fntmatch1: 
25db			 
25db				; is the same char a null which means we might have a full hit? 
25db					if DEBUG_FORTH 
25db						DMARK "NT4" 
25db						CALLMONITOR 
25db					endif 
25db			 
25db fe 00			cp 0 
25dd 28 0b			jr z, .fntmatchyes 
25df			 
25df				; are we at the end of the token to find? 
25df			 
25df					if DEBUG_FORTH 
25df						DMARK "NT5" 
25df						CALLMONITOR 
25df					endif 
25df 3e 00			ld a, 0 
25e1 b9				cp c 
25e2			 
25e2 c2 cc 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
25e5			 
25e5					if DEBUG_FORTH 
25e5						DMARK "NT6" 
25e5						CALLMONITOR 
25e5					endif 
25e5				; token to find is exhusted but no match to stream 
25e5			 
25e5				; restore tok pointer and continue on 
25e5 d1				pop de 
25e6 d5				push de 
25e7 c3 bc 25			jp .fnt1 
25ea			 
25ea			 
25ea			.fntmatchyes: 
25ea			 
25ea				; hl now contains the end of the found token 
25ea			 
25ea				; get rid of saved token pointer to find 
25ea			 
25ea d1				pop de 
25eb			 
25eb					if DEBUG_FORTH 
25eb						DMARK "NT9" 
25eb						CALLMONITOR 
25eb					endif 
25eb			 
25eb				; hl will be on the null term so forward on 
25eb			 
25eb				; get back the saved start of the token 
25eb			 
25eb d9				exx 
25ec e5				push hl     ; save start of token just in case it is the right one 
25ed d9				exx 
25ee e1				pop hl        ; save it to hl 
25ef			 
25ef c9				ret 
25f0			 
25f0			 
25f0			; LIST needs to find a specific token   
25f0			; FORGET needs to find a spefici token 
25f0			 
25f0			; SAVE needs to find all tokens by flag 
25f0			; WORDS just needs to scan through all  by flag 
25f0			; UWORDS needs to scan through all by flag 
25f0			 
25f0			 
25f0			; given hl as pointer to start of dict look up string 
25f0			; return hl as pointer to start of word block 
25f0			; or 0 if not found 
25f0			 
25f0			forth_find_tok: 
25f0 c9				ret 
25f1			 
25f1			; given hl as pointer to dict structure 
25f1			; move to the next dict block structure 
25f1			 
25f1			forth_tok_next: 
25f1				; hl now points to the address of the next word pointer  
25f1				; TODO skip compiled symbol for now 
25f1			;	push de 
25f1 23				inc hl 
25f2 5e				ld e, (hl) 
25f3 23				inc hl 
25f4 56				ld d, (hl) 
25f5 23				inc hl 
25f6			 
25f6 eb				ex de,hl 
25f7			if DEBUG_FORTH_PARSE_NEXTWORD 
25f7				push bc 
25f7				ld bc, (cli_nextword) 
25f7						DMARK "NXW" 
25f7				CALLMONITOR 
25f7				pop bc 
25f7			endif 
25f7			;	pop de	 
25f7 c9				ret 
25f8			 
25f8			 
25f8			 
25f8			; eof 
# End of file forth_parserv5.asm
25f8				include "forth_wordsv4.asm" 
25f8			 
25f8			; the core word dictionary v4 
25f8			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
25f8			 
25f8			; this is a linked list for each of the system words used 
25f8			; user defined words will follow the same format but will be in ram 
25f8			 
25f8			 
25f8			; 
25f8			; 
25f8			; define linked list: 
25f8			; 
25f8			; 1. compiled byte op code 
25f8			; 2. len of text word 
25f8			; 3. text word 
25f8			; 4. ptr to next dictionary word 
25f8			; 5. asm, calls etc for the word 
25f8			; 
25f8			;  if 1 == 0 then last word in dict  
25f8			;   
25f8			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
25f8			;  
25f8			;  
25f8			; create basic standard set of words 
25f8			; 
25f8			;  
25f8			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
25f8			; 2DUP 2DROP 2SWAP  
25f8			; @ C@ - get byte  
25f8			; ! C! - store byte 
25f8			; 0< true if less than zero 
25f8			; 0= true if zero 
25f8			; < >  
25f8			; = true if same 
25f8			; variables 
25f8			 
25f8			 
25f8			; Hardware specific words I may need 
25f8			; 
25f8			; IN OUT  
25f8			; calls to key util functions 
25f8			; calls to hardward abstraction stuff 
25f8			; easy control of frame buffers and lcd i/o 
25f8			; keyboard  
25f8			 
25f8			 
25f8			;DICT: macro 
25f8			; op_code, len, word, next 
25f8			;    word: 
25f8			;    db op_code 
25f8			;    ds word zero term 
25f8			;    dw next 
25f8			;    endm 
25f8			 
25f8			 
25f8			 
25f8			 
25f8			; op code 1 is a flag for user define words which are to be handled differently 
25f8			 
25f8			 
25f8			; 
25f8			; 
25f8			;    TODO on entry to a word this should be the expected environment 
25f8			;    hl - tos value if number then held, if string this is the ptr 
25f8			;    de -  
25f8			 
25f8			 
25f8			; opcode ranges 
25f8			; 0 - end of word dict 
25f8			; 255 - user define words 
25f8			 
25f8			sysdict: 
25f8			include "forth_opcodes.asm" 
25f8			; op codes for forth keywords 
25f8			; free to use code 0  
25f8				OPCODE_HEAP: equ  1 
25f8				OPCODE_EXEC: equ 2 
25f8				OPCODE_DUP: equ 3 
25f8				OPCODE_SWAP: equ 4 
25f8				OPCODE_COLN: equ 5 
25f8				OPCODE_SCOLN: equ 6 
25f8				OPCODE_DROP: equ 7 
25f8				OPCODE_DUP2: equ 8 
25f8				OPCODE_DROP2: equ 9 
25f8				OPCODE_SWAP2: equ 10 
25f8				OPCODE_AT: equ 11 
25f8				OPCODE_CAT: equ 12 
25f8				OPCODE_BANG: equ 13 
25f8				OPCODE_CBANG: equ 14 
25f8				OPCODE_SCALL: equ 15 
25f8				OPCODE_DEPTH: equ 16 
25f8				OPCODE_OVER: equ 17 
25f8				OPCODE_PAUSE: equ 18 
25f8				OPCODE_PAUSES: equ 19 
25f8				OPCODE_ROT: equ 20 
25f8			;free to reuse	OPCODE_WORDS: equ 21 
25f8			        OPCODE_NOT: equ 21 
25f8				OPCODE_UWORDS: equ 22 
25f8				OPCODE_BP: equ 23 
25f8				OPCODE_MONITOR: equ 24  
25f8				OPCODE_MALLOC: equ 25 
25f8				OPCODE_FREE: equ 26 
25f8				OPCODE_LIST: equ 27 
25f8				OPCODE_FORGET: equ 28 
25f8				OPCODE_NOP: equ 29 
25f8				OPCODE_COMO: equ 30 
25f8				OPCODE_COMC: equ 31 
25f8			;free to reuse	OPCODE_ENDCORE: equ 32 
25f8				OPCODE_AFTERSOUND: equ 33 
25f8				OPCODE_GP2: equ 34 
25f8				OPCODE_GP3: equ 35 
25f8				OPCODE_GP4: equ 36 
25f8				OPCODE_SIN: equ 37 
25f8				OPCODE_SOUT: equ 38 
25f8				OPCODE_SPIO: equ 39 
25f8				OPCODE_SPICEH: equ 40 
25f8				OPCODE_SPIOb: equ 41 
25f8				OPCODE_SPII: equ 42 
25f8				OPCODE_SESEL: equ 43 
25f8				OPCODE_CARTDEV: equ 44 
25f8			; free to reuse	OPCODE_ENDDEVICE: equ 45 
25f8				OPCODE_FB: equ 46 
25f8				OPCODE_EMIT: equ 47 
25f8				OPCODE_DOTH: equ 48 
25f8				OPCODE_DOTF: equ 49 
25f8				OPCODE_DOT: equ 50 
25f8				OPCODE_CLS: equ 51 
25f8				OPCODE_DRAW: equ 52 
25f8				OPCODE_DUMP: equ 53 
25f8				OPCODE_CDUMP: equ 54 
25f8				OPCODE_DAT: equ 55 
25f8				OPCODE_HOME: equ 56 
25f8				OPCODE_SPACE: equ 57 
25f8				OPCODE_SPACES: equ 58 
25f8				OPCODE_SCROLL: equ 59 
25f8				OPCODE_ATQ: equ 60 
25f8				OPCODE_AUTODSP: equ 61 
25f8				OPCODE_MENU: equ 62 
25f8			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
25f8				OPCODE_THEN: equ 64 
25f8				OPCODE_ELSE: equ 65 
25f8				OPCODE_DO: equ 66 
25f8				OPCODE_LOOP: equ 67 
25f8				OPCODE_I: equ 68 
25f8				OPCODE_DLOOP: equ 69  
25f8				OPCODE_REPEAT: equ 70  
25f8				OPCODE_UNTIL: equ 71 
25f8				OPCODE_ENDFLOW: equ 72 
25f8				OPCODE_WAITK: equ 73 
25f8				OPCODE_ACCEPT: equ 74 
25f8				OPCODE_EDIT: equ 75 
25f8			;free to reuse	OPCODE_ENDKEY: equ 76 
25f8				OPCODE_LZERO: equ 77 
25f8				OPCODE_TZERO: equ 78 
25f8				OPCODE_LESS: equ 79 
25f8				OPCODE_GT: equ 80 
25f8				OPCODE_EQUAL: equ 81  
25f8			;free to reuse	OPCODE_ENDLOGIC: equ 82 
25f8				OPCODE_NEG: equ 83 
25f8				OPCODE_DIV: equ 84 
25f8				OPCODE_MUL: equ 85 
25f8				OPCODE_MIN: equ 86 
25f8				OPCODE_MAX: equ 87 
25f8				OPCODE_RND16: equ 88 
25f8				OPCODE_RND8: equ 89 
25f8				OPCODE_RND: equ 90 
25f8			;free to reuse	OPCODE_ENDMATHS: equ 91  
25f8				OPCODE_BYNAME: equ 92 
25f8				OPCODE_DIR: equ 93 
25f8				OPCODE_SAVE: equ 94 
25f8				OPCODE_LOAD: equ 95 
25f8				OPCODE_BSAVE: equ 96 
25f8				OPCODE_BLOAD: equ 97 
25f8				OPCODE_SEO: equ 98  
25f8				OPCODE_SEI: equ 99 
25f8				OPCODE_SFREE: equ 100 
25f8				OPCODE_SIZE: equ 101 
25f8				OPCODE_CREATE: equ 102 
25f8				OPCODE_APPEND: equ 103 
25f8				OPCODE_SDEL: equ 104 
25f8				OPCODE_OPEN: equ 105 
25f8				OPCODE_READ: equ 106 
25f8				OPCODE_EOF: equ 106 
25f8				OPCODE_FORMAT: equ 107 
25f8				OPCODE_LABEL: equ 108 
25f8				OPCODE_LABELS: equ 109 
25f8			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
25f8				OPCODE_UPPER: equ 111 
25f8				OPCODE_LOWER: equ 112 
25f8				OPCODE_SUBSTR: equ 113 
25f8				OPCODE_LEFT: equ 114 
25f8				OPCODE_RIGHT: equ 115 
25f8				OPCODE_STR2NUM: equ 116 
25f8				OPCODE_NUM2STR: equ 117 
25f8				OPCODE_CONCAT: equ 118 
25f8				OPCODE_FIND: equ 119 
25f8				OPCODE_LEN: equ 120 
25f8				OPCODE_CHAR: equ 121 
25f8			; free to reuse	OPCODE_STRLEN: equ 122 
25f8			; free to reuse	OPCODE_ENDSTR: equ 123 
25f8				OPCODE_V0S: equ 124 
25f8				OPCODE_V0Q: equ 125 
25f8				OPCODE_V1S: equ 126 
25f8				OPCODE_V1Q: equ 127 
25f8				OPCODE_V2S: equ 128 
25f8				OPCODE_V2Q: equ 129 
25f8				OPCODE_V3S: equ 130 
25f8				OPCODE_V3Q: equ 131 
25f8			;free to reuse	OPCODE_END: equ 132 
25f8				OPCODE_ZDUP: equ 133 
25f8			 
25f8			; eof 
# End of file forth_opcodes.asm
25f8			 
25f8			include "forth_words_core.asm" 
25f8			 
25f8			; | ## Core Words 
25f8			 
25f8			;if MALLOC_4 
25f8			 
25f8			.HEAP: 
25f8				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
25f8 15				db WORD_SYS_CORE+OPCODE_HEAP             
25f9 37 26			dw .EXEC            
25fb 05				db 4 + 1 
25fc .. 00			db "HEAP",0              
2601				endm 
# End of macro CWHEAD
2601			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2601			; | | u1 - Current number of bytes in the heap 
2601			; | | u2 - Remaining bytes left on the heap 
2601			; | |  
2601			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2601			 
2601			 
2601					if DEBUG_FORTH_WORDS_KEY 
2601						DMARK "HEP" 
2601 f5				push af  
2602 3a 16 26			ld a, (.dmark)  
2605 32 6e fe			ld (debug_mark),a  
2608 3a 17 26			ld a, (.dmark+1)  
260b 32 6f fe			ld (debug_mark+1),a  
260e 3a 18 26			ld a, (.dmark+2)  
2611 32 70 fe			ld (debug_mark+2),a  
2614 18 03			jr .pastdmark  
2616 ..			.dmark: db "HEP"  
2619 f1			.pastdmark: pop af  
261a			endm  
# End of macro DMARK
261a						CALLMONITOR 
261a cd fb 19			call break_point_state  
261d				endm  
# End of macro CALLMONITOR
261d					endif 
261d 2a 0a 80				ld hl, (free_list )      
2620 11 0e 80				ld de, heap_start 
2623			 
2623 ed 52				sbc hl, de  
2625			 
2625 cd f3 20				call forth_push_numhl 
2628			 
2628			 
2628 ed 5b 0a 80			ld de, (free_list )      
262c 21 aa f1				ld hl, heap_end 
262f			 
262f ed 52				sbc hl, de 
2631			 
2631 cd f3 20				call forth_push_numhl 
2634					 
2634			 
2634					 
2634			 
2634			 
2634			 
2634					NEXTW 
2634 c3 a0 24			jp macro_next 
2637				endm 
# End of macro NEXTW
2637			;endif 
2637			 
2637			.EXEC: 
2637			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2637			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2637			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2637			;; > > 
2637			;; > >   
2637			;	STACKFRAME OFF $5efe $5f9f 
2637			; 
2637			;		if DEBUG_FORTH_WORDS_KEY 
2637			;			DMARK "EXE" 
2637			;			CALLMONITOR 
2637			;		endif 
2637			; 
2637			;	FORTH_DSP_VALUEHL 
2637			; 
2637			;	FORTH_DSP_POP 
2637			; 
2637			;		if DEBUG_FORTH_WORDS 
2637			;			DMARK "EX1" 
2637			;			CALLMONITOR 
2637			;		endif 
2637			;;	ld e,(hl) 
2637			;;	inc hl 
2637			;;	ld d,(hl) 
2637			;;	ex de,hl 
2637			; 
2637			;;		if DEBUG_FORTH_WORDS 
2637			;;			DMARK "EX2" 
2637			;;			CALLMONITOR 
2637			;;		endif 
2637			;	push hl 
2637			; 
2637			;	;ld a, 0 
2637			;	;ld a, FORTH_END_BUFFER 
2637			;	call strlenz 
2637			;	inc hl   ; include zero term to copy 
2637			;	inc hl   ; include term 
2637			;	inc hl   ; include term 
2637			;	ld b,0 
2637			;	ld c,l 
2637			;	pop hl 
2637			;	ld de, execscratch 
2637			;		if DEBUG_FORTH_WORDS 
2637			;			DMARK "EX3" 
2637			;			CALLMONITOR 
2637			;		endif 
2637			;	ldir 
2637			; 
2637			; 
2637			;	ld hl, execscratch 
2637			; 
2637			;		if DEBUG_FORTH_WORDS 
2637			;			DMARK "EXe" 
2637			;			CALLMONITOR 
2637			;		endif 
2637			; 
2637			;	call forthparse 
2637			;	call forthexec 
2637			;;	call forthexec_cleanup 
2637			;;	call forthparse 
2637			;;	call forthexec 
2637			; 
2637			;	STACKFRAMECHK OFF $5efe $5f9f 
2637			; 
2637			;	; an immediate word so no need to process any more words 
2637			;	ret 
2637			;	NEXTW 
2637			 
2637			; dead code - old version  
2637			;	FORTH_RSP_NEXT 
2637			 
2637			;  
2637			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2637			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2637			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2637			;	push hl 
2637			;	push de 
2637			;	push bc 
2637			; 
2637			; 
2637			;		if DEBUG_FORTH_WORDS_KEY 
2637			;			DMARK "EXR" 
2637			;			CALLMONITOR 
2637			;		endif 
2637			; 
2637			; 
2637			; 
2637			;	;v5 FORTH_DSP_VALUE 
2637			;	FORTH_DSP_VALUEHL 
2637			; 
2637			;	; TODO do string type checks 
2637			; 
2637			;;v5	inc hl   ; skip type 
2637			; 
2637			;	push hl  ; source code  
2637			;		if DEBUG_FORTH_WORDS 
2637			;			DMARK "EX1" 
2637			;			CALLMONITOR 
2637			;		endif 
2637			;	ld a, 0 
2637			;	call strlent 
2637			; 
2637			;	inc hl 
2637			;	inc hl 
2637			;	inc hl 
2637			;	inc hl 
2637			; 
2637			;	push hl    ; size 
2637			; 
2637			;		if DEBUG_FORTH_WORDS 
2637			;			DMARK "EX2" 
2637			;			CALLMONITOR 
2637			;		endif 
2637			;	call malloc 
2637			; 
2637			;	ex de, hl    ; de now contains malloc area 
2637			;	pop bc   	; get byte count 
2637			;	pop hl      ; get string to copy 
2637			; 
2637			;	push de     ; save malloc for free later 
2637			; 
2637			;		if DEBUG_FORTH_WORDS 
2637			;			DMARK "EX3" 
2637			;			CALLMONITOR 
2637			;		endif 
2637			;	ldir       ; duplicate string 
2637			; 
2637			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2637			;	 
2637			;	; TODO fix the parse would be better than this...  
2637			;	ex de, hl 
2637			;	dec hl 
2637			;	ld a, 0 
2637			;	ld (hl), a 
2637			;	dec hl 
2637			;	ld a, ' ' 
2637			;	ld (hl), a 
2637			;	dec hl 
2637			;	ld (hl), a 
2637			; 
2637			;	dec hl 
2637			;	ld (hl), a 
2637			; 
2637			; 
2637			;	FORTH_DSP_POP  
2637			; 
2637			;	pop hl     
2637			;	push hl    ; save malloc area 
2637			; 
2637			;		if DEBUG_FORTH_WORDS 
2637			;			DMARK "EX4" 
2637			;			CALLMONITOR 
2637			;		endif 
2637			; 
2637			;	call forthparse 
2637			;	call forthexec 
2637			;	 
2637			;	pop hl 
2637			;	if DEBUG_FORTH_WORDS 
2637			;		DMARK "EX5" 
2637			;		CALLMONITOR 
2637			;	endif 
2637			; 
2637			;	if FORTH_ENABLE_FREE 
2637			;	call free 
2637			;	endif 
2637			; 
2637			;	if DEBUG_FORTH_WORDS 
2637			;		DMARK "EX6" 
2637			;		CALLMONITOR 
2637			;	endif 
2637			; 
2637			;	pop bc 
2637			;	pop de 
2637			;	pop hl 
2637			;;	FORTH_RSP_POP	  
2637			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2637			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2637			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2637			; 
2637			;	if DEBUG_FORTH_WORDS 
2637			;		DMARK "EX7" 
2637			;		CALLMONITOR 
2637			;	endif 
2637			;	NEXTW 
2637			 
2637			;.STKEXEC: 
2637			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2637			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2637			; 
2637			; 
2637			;		if DEBUG_FORTH_WORDS_KEY 
2637			;			DMARK "STX" 
2637			;			CALLMONITOR 
2637			;		endif 
2637			; 
2637			;	FORTH_DSP_VALUEHL 
2637			; 
2637			;	ld (store_tmp1), hl    ; count 
2637			; 
2637			;	FORTH_DSP_POP 
2637			;.stkexec1: 
2637			;	ld hl, (store_tmp1)   ; count 
2637			;	ld a, 0 
2637			;	cp l 
2637			;	ret z 
2637			; 
2637			;	dec hl 
2637			;	ld (store_tmp1), hl    ; count 
2637			;	 
2637			;	FORTH_DSP_VALUEHL 
2637			;	push hl 
2637			;	 
2637			;		if DEBUG_FORTH_WORDS 
2637			;			DMARK "EXp" 
2637			;			CALLMONITOR 
2637			;		endif 
2637			;	FORTH_DSP_POP 
2637			; 
2637			;	call strlenz 
2637			;	inc hl   ; include zero term to copy 
2637			;	inc hl   ; include zero term to copy 
2637			;	inc hl   ; include zero term to copy 
2637			;	ld b,0 
2637			;	ld c,l 
2637			;	pop hl 
2637			;	ld de, execscratch 
2637			;		if DEBUG_FORTH_WORDS 
2637			;			DMARK "EX3" 
2637			;			CALLMONITOR 
2637			;		endif 
2637			;	ldir 
2637			; 
2637			; 
2637			;	ld hl, execscratch 
2637			; 
2637			;		if DEBUG_FORTH_WORDS 
2637			;			DMARK "EXP" 
2637			;			CALLMONITOR 
2637			;		endif 
2637			; 
2637			;	call forthparse 
2637			;	ld hl, execscratch 
2637			;		if DEBUG_FORTH_WORDS 
2637			;			DMARK "EXx" 
2637			;			CALLMONITOR 
2637			;		endif 
2637			;	call forthexec 
2637			; 
2637			;	jp .stkexec1 
2637			; 
2637			;	ret 
2637			 
2637			 
2637			.DUP: 
2637				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2637 17				db WORD_SYS_CORE+OPCODE_DUP             
2638 ad 26			dw .ZDUP            
263a 04				db 3 + 1 
263b .. 00			db "DUP",0              
263f				endm 
# End of macro CWHEAD
263f			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
263f			 
263f					if DEBUG_FORTH_WORDS_KEY 
263f						DMARK "DUP" 
263f f5				push af  
2640 3a 54 26			ld a, (.dmark)  
2643 32 6e fe			ld (debug_mark),a  
2646 3a 55 26			ld a, (.dmark+1)  
2649 32 6f fe			ld (debug_mark+1),a  
264c 3a 56 26			ld a, (.dmark+2)  
264f 32 70 fe			ld (debug_mark+2),a  
2652 18 03			jr .pastdmark  
2654 ..			.dmark: db "DUP"  
2657 f1			.pastdmark: pop af  
2658			endm  
# End of macro DMARK
2658						CALLMONITOR 
2658 cd fb 19			call break_point_state  
265b				endm  
# End of macro CALLMONITOR
265b					endif 
265b			 
265b					FORTH_DSP 
265b cd b0 22			call macro_forth_dsp 
265e				endm 
# End of macro FORTH_DSP
265e			 
265e 7e					ld a, (HL) 
265f fe 01				cp DS_TYPE_STR 
2661 20 25				jr nz, .dupinum 
2663			 
2663					; push another string 
2663			 
2663					FORTH_DSP_VALUEHL     		 
2663 cd ea 22			call macro_dsp_valuehl 
2666				endm 
# End of macro FORTH_DSP_VALUEHL
2666			 
2666				if DEBUG_FORTH_WORDS 
2666					DMARK "DUs" 
2666 f5				push af  
2667 3a 7b 26			ld a, (.dmark)  
266a 32 6e fe			ld (debug_mark),a  
266d 3a 7c 26			ld a, (.dmark+1)  
2670 32 6f fe			ld (debug_mark+1),a  
2673 3a 7d 26			ld a, (.dmark+2)  
2676 32 70 fe			ld (debug_mark+2),a  
2679 18 03			jr .pastdmark  
267b ..			.dmark: db "DUs"  
267e f1			.pastdmark: pop af  
267f			endm  
# End of macro DMARK
267f					CALLMONITOR 
267f cd fb 19			call break_point_state  
2682				endm  
# End of macro CALLMONITOR
2682				endif 
2682 cd 61 21				call forth_push_str 
2685			 
2685					NEXTW 
2685 c3 a0 24			jp macro_next 
2688				endm 
# End of macro NEXTW
2688			 
2688			 
2688			.dupinum: 
2688					 
2688			 
2688			 
2688					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2688 cd ea 22			call macro_dsp_valuehl 
268b				endm 
# End of macro FORTH_DSP_VALUEHL
268b			 
268b				; TODO add floating point number detection 
268b			 
268b				if DEBUG_FORTH_WORDS 
268b					DMARK "DUi" 
268b f5				push af  
268c 3a a0 26			ld a, (.dmark)  
268f 32 6e fe			ld (debug_mark),a  
2692 3a a1 26			ld a, (.dmark+1)  
2695 32 6f fe			ld (debug_mark+1),a  
2698 3a a2 26			ld a, (.dmark+2)  
269b 32 70 fe			ld (debug_mark+2),a  
269e 18 03			jr .pastdmark  
26a0 ..			.dmark: db "DUi"  
26a3 f1			.pastdmark: pop af  
26a4			endm  
# End of macro DMARK
26a4					CALLMONITOR 
26a4 cd fb 19			call break_point_state  
26a7				endm  
# End of macro CALLMONITOR
26a7				endif 
26a7			 
26a7 cd f3 20				call forth_push_numhl 
26aa					NEXTW 
26aa c3 a0 24			jp macro_next 
26ad				endm 
# End of macro NEXTW
26ad			.ZDUP: 
26ad				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
26ad 99				db WORD_SYS_CORE+OPCODE_ZDUP             
26ae e5 26			dw .SWAP            
26b0 05				db 4 + 1 
26b1 .. 00			db "?DUP",0              
26b6				endm 
# End of macro CWHEAD
26b6			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
26b6			 
26b6					if DEBUG_FORTH_WORDS_KEY 
26b6						DMARK "qDU" 
26b6 f5				push af  
26b7 3a cb 26			ld a, (.dmark)  
26ba 32 6e fe			ld (debug_mark),a  
26bd 3a cc 26			ld a, (.dmark+1)  
26c0 32 6f fe			ld (debug_mark+1),a  
26c3 3a cd 26			ld a, (.dmark+2)  
26c6 32 70 fe			ld (debug_mark+2),a  
26c9 18 03			jr .pastdmark  
26cb ..			.dmark: db "qDU"  
26ce f1			.pastdmark: pop af  
26cf			endm  
# End of macro DMARK
26cf						CALLMONITOR 
26cf cd fb 19			call break_point_state  
26d2				endm  
# End of macro CALLMONITOR
26d2					endif 
26d2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26d2 cd ea 22			call macro_dsp_valuehl 
26d5				endm 
# End of macro FORTH_DSP_VALUEHL
26d5			 
26d5 e5					push hl 
26d6			 
26d6					; is it a zero? 
26d6			 
26d6 3e 00				ld a, 0 
26d8 84					add h 
26d9 85					add l 
26da			 
26da e1					pop hl 
26db			 
26db fe 00				cp 0 
26dd 28 03				jr z, .dup2orig 
26df			 
26df			 
26df cd f3 20				call forth_push_numhl 
26e2			 
26e2			 
26e2				; TODO add floating point number detection 
26e2			 
26e2			.dup2orig: 
26e2			 
26e2					NEXTW 
26e2 c3 a0 24			jp macro_next 
26e5				endm 
# End of macro NEXTW
26e5			.SWAP: 
26e5				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
26e5 18				db WORD_SYS_CORE+OPCODE_SWAP             
26e6 24 27			dw .COLN            
26e8 05				db 4 + 1 
26e9 .. 00			db "SWAP",0              
26ee				endm 
# End of macro CWHEAD
26ee			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
26ee					if DEBUG_FORTH_WORDS_KEY 
26ee						DMARK "SWP" 
26ee f5				push af  
26ef 3a 03 27			ld a, (.dmark)  
26f2 32 6e fe			ld (debug_mark),a  
26f5 3a 04 27			ld a, (.dmark+1)  
26f8 32 6f fe			ld (debug_mark+1),a  
26fb 3a 05 27			ld a, (.dmark+2)  
26fe 32 70 fe			ld (debug_mark+2),a  
2701 18 03			jr .pastdmark  
2703 ..			.dmark: db "SWP"  
2706 f1			.pastdmark: pop af  
2707			endm  
# End of macro DMARK
2707						CALLMONITOR 
2707 cd fb 19			call break_point_state  
270a				endm  
# End of macro CALLMONITOR
270a					endif 
270a			 
270a					FORTH_DSP_VALUEHL 
270a cd ea 22			call macro_dsp_valuehl 
270d				endm 
# End of macro FORTH_DSP_VALUEHL
270d e5					push hl     ; w2 
270e			 
270e					FORTH_DSP_POP 
270e cd a2 23			call macro_forth_dsp_pop 
2711				endm 
# End of macro FORTH_DSP_POP
2711			 
2711					FORTH_DSP_VALUEHL 
2711 cd ea 22			call macro_dsp_valuehl 
2714				endm 
# End of macro FORTH_DSP_VALUEHL
2714			 
2714					FORTH_DSP_POP 
2714 cd a2 23			call macro_forth_dsp_pop 
2717				endm 
# End of macro FORTH_DSP_POP
2717			 
2717 d1					pop de     ; w2	, hl = w1 
2718			 
2718 eb					ex de, hl 
2719 d5					push de 
271a			 
271a cd f3 20				call forth_push_numhl 
271d			 
271d e1					pop hl 
271e			 
271e cd f3 20				call forth_push_numhl 
2721					 
2721			 
2721					NEXTW 
2721 c3 a0 24			jp macro_next 
2724				endm 
# End of macro NEXTW
2724			.COLN: 
2724				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2724 19				db WORD_SYS_CORE+OPCODE_COLN             
2725 b0 28			dw .SCOLN            
2727 02				db 1 + 1 
2728 .. 00			db ":",0              
272a				endm 
# End of macro CWHEAD
272a			; | : ( -- )         Create new word | DONE 
272a			 
272a					if DEBUG_FORTH_WORDS_KEY 
272a						DMARK "CLN" 
272a f5				push af  
272b 3a 3f 27			ld a, (.dmark)  
272e 32 6e fe			ld (debug_mark),a  
2731 3a 40 27			ld a, (.dmark+1)  
2734 32 6f fe			ld (debug_mark+1),a  
2737 3a 41 27			ld a, (.dmark+2)  
273a 32 70 fe			ld (debug_mark+2),a  
273d 18 03			jr .pastdmark  
273f ..			.dmark: db "CLN"  
2742 f1			.pastdmark: pop af  
2743			endm  
# End of macro DMARK
2743						CALLMONITOR 
2743 cd fb 19			call break_point_state  
2746				endm  
# End of macro CALLMONITOR
2746					endif 
2746				STACKFRAME OFF $8efe $989f 
2746				if DEBUG_STACK_IMB 
2746					if OFF 
2746						exx 
2746						ld de, $8efe 
2746						ld a, d 
2746						ld hl, curframe 
2746						call hexout 
2746						ld a, e 
2746						ld hl, curframe+2 
2746						call hexout 
2746						ld hl, $8efe 
2746						push hl 
2746						ld hl, $989f 
2746						push hl 
2746						exx 
2746					endif 
2746				endif 
2746			endm 
# End of macro STACKFRAME
2746				; get parser buffer length  of new word 
2746			 
2746				 
2746			 
2746					; move tok past this to start of name defintition 
2746					; TODO get word to define 
2746					; TODO Move past word token 
2746					; TODO get length of string up to the ';' 
2746			 
2746 2a c5 f4			ld hl, (os_tok_ptr) 
2749 23				inc hl 
274a 23				inc hl 
274b			 
274b 3e 3b			ld a, ';' 
274d cd ef 13			call strlent 
2750			 
2750 7d				ld a,l 
2751 32 c0 f1			ld (os_new_parse_len), a 
2754			 
2754			 
2754			if DEBUG_FORTH_UWORD 
2754 ed 5b c5 f4		ld de, (os_tok_ptr) 
2758						DMARK ":01" 
2758 f5				push af  
2759 3a 6d 27			ld a, (.dmark)  
275c 32 6e fe			ld (debug_mark),a  
275f 3a 6e 27			ld a, (.dmark+1)  
2762 32 6f fe			ld (debug_mark+1),a  
2765 3a 6f 27			ld a, (.dmark+2)  
2768 32 70 fe			ld (debug_mark+2),a  
276b 18 03			jr .pastdmark  
276d ..			.dmark: db ":01"  
2770 f1			.pastdmark: pop af  
2771			endm  
# End of macro DMARK
2771				CALLMONITOR 
2771 cd fb 19			call break_point_state  
2774				endm  
# End of macro CALLMONITOR
2774			endif 
2774			 
2774			; 
2774			;  new word memory layout: 
2774			;  
2774			;    : adg 6666 ;  
2774			; 
2774			;    db   1     ; user defined word  
2774 23				inc hl    
2775			;    dw   sysdict 
2775 23				inc hl 
2776 23				inc hl 
2777			;    db <word len>+1 (for null) 
2777 23				inc hl 
2778			;    db .... <word> 
2778			; 
2778			 
2778 23				inc hl    ; some extras for the word preamble before the above 
2779 23				inc hl 
277a 23				inc hl 
277b 23				inc hl 
277c 23				inc hl 
277d 23				inc hl 
277e 23				inc hl  
277f 23				inc hl 
2780 23				inc hl 
2781 23				inc hl 
2782 23				inc hl 
2783 23				inc hl 
2784 23				inc hl 
2785 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2786			;       exec word buffer 
2786			;	<ptr word>   
2786 23				inc hl 
2787 23				inc hl 
2788			;       <word list><null term> 7F final term 
2788			 
2788			 
2788			if DEBUG_FORTH_UWORD 
2788						DMARK ":02" 
2788 f5				push af  
2789 3a 9d 27			ld a, (.dmark)  
278c 32 6e fe			ld (debug_mark),a  
278f 3a 9e 27			ld a, (.dmark+1)  
2792 32 6f fe			ld (debug_mark+1),a  
2795 3a 9f 27			ld a, (.dmark+2)  
2798 32 70 fe			ld (debug_mark+2),a  
279b 18 03			jr .pastdmark  
279d ..			.dmark: db ":02"  
27a0 f1			.pastdmark: pop af  
27a1			endm  
# End of macro DMARK
27a1				CALLMONITOR 
27a1 cd fb 19			call break_point_state  
27a4				endm  
# End of macro CALLMONITOR
27a4			endif 
27a4			 
27a4				 
27a4					; malloc the size 
27a4			 
27a4 cd 4d 14				call malloc 
27a7 22 c2 f1				ld (os_new_malloc), hl     ; save malloc start 
27aa			 
27aa			;    db   1     ; user defined word  
27aa 3e 01				ld a, WORD_SYS_UWORD  
27ac 77					ld (hl), a 
27ad				 
27ad 23				inc hl    
27ae			;    dw   sysdict 
27ae 11 f8 25			ld de, sysdict       ; continue on with the scan to the system dict 
27b1 73				ld (hl), e 
27b2 23				inc hl 
27b3 72				ld (hl), d 
27b4 23				inc hl 
27b5			 
27b5			 
27b5			;    Setup dict word 
27b5			 
27b5 23				inc hl 
27b6 22 bc f1			ld (os_new_work_ptr), hl     ; save start of dict word  
27b9			 
27b9				; 1. get length of dict word 
27b9			 
27b9			 
27b9 2a c5 f4			ld hl, (os_tok_ptr) 
27bc 23				inc hl 
27bd 23				inc hl    ; position to start of dict word 
27be 3e 00			ld a, 0 
27c0 cd ef 13			call strlent 
27c3			 
27c3			 
27c3 23				inc hl    ; to include null??? 
27c4			 
27c4				; write length of dict word 
27c4			 
27c4 ed 5b bc f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
27c8 1b				dec de 
27c9 eb				ex de, hl 
27ca 73				ld (hl), e 
27cb eb				ex de, hl 
27cc			 
27cc				 
27cc			 
27cc				; copy  
27cc 4d				ld c, l 
27cd 06 00			ld b, 0 
27cf ed 5b bc f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
27d3 2a c5 f4			ld hl, (os_tok_ptr) 
27d6 23				inc hl 
27d7 23				inc hl    ; position to start of dict word 
27d8				 
27d8			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
27d8				 
27d8				; TODO need to convert word to upper case 
27d8			 
27d8			ucasetok:	 
27d8 7e				ld a,(hl) 
27d9 cd db 13			call toUpper 
27dc 77				ld (hl),a 
27dd ed a0			ldi 
27df f2 d8 27		 	jp p, ucasetok 
27e2			 
27e2			 
27e2			 
27e2				; de now points to start of where the word body code should be placed 
27e2 ed 53 bc f1		ld (os_new_work_ptr), de 
27e6				; hl now points to the words to throw at forthexec which needs to be copied 
27e6 22 ba f1			ld (os_new_src_ptr), hl 
27e9			 
27e9				; TODO add 'call to forthexec' 
27e9			 
27e9			if DEBUG_FORTH_UWORD 
27e9 c5				push bc 
27ea ed 4b c2 f1		ld bc, (os_new_malloc) 
27ee						DMARK ":0x" 
27ee f5				push af  
27ef 3a 03 28			ld a, (.dmark)  
27f2 32 6e fe			ld (debug_mark),a  
27f5 3a 04 28			ld a, (.dmark+1)  
27f8 32 6f fe			ld (debug_mark+1),a  
27fb 3a 05 28			ld a, (.dmark+2)  
27fe 32 70 fe			ld (debug_mark+2),a  
2801 18 03			jr .pastdmark  
2803 ..			.dmark: db ":0x"  
2806 f1			.pastdmark: pop af  
2807			endm  
# End of macro DMARK
2807				CALLMONITOR 
2807 cd fb 19			call break_point_state  
280a				endm  
# End of macro CALLMONITOR
280a c1				pop bc 
280b			endif 
280b			 
280b			 
280b				; create word preamble which should be: 
280b			 
280b			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
280b			 
280b				;    ld hl, <word code> 
280b				;    jp user_exec 
280b			        ;    <word code bytes> 
280b			 
280b			 
280b			;	inc de     ; TODO ??? or are we already past the word's null 
280b eb				ex de, hl 
280c			 
280c 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
280e			 
280e 23				inc hl 
280f 22 b6 f1			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2812 23				inc hl 
2813			 
2813 23				inc hl 
2814 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2816			 
2816 01 ec 5c			ld bc, user_exec 
2819 23				inc hl 
281a 71				ld (hl), c     ; poke address of user_exec 
281b 23				inc hl 
281c 70				ld (hl), b     
281d			 ; 
281d			;	inc hl 
281d			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
281d			; 
281d			; 
281d			;	ld bc, macro_forth_rsp_next 
281d			;	inc hl 
281d			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
281d			;	inc hl 
281d			;	ld (hl), b     
281d			 ; 
281d			;	inc hl 
281d			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
281d			; 
281d			; 
281d			;	inc hl 
281d			;	ld bc, forthexec 
281d			;	ld (hl), c     ; poke address of forthexec 
281d			;	inc hl 
281d			;	ld (hl), b      
281d			; 
281d			;	inc hl 
281d			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
281d			; 
281d			;	ld bc, user_dict_next 
281d			;	inc hl 
281d			;	ld (hl), c     ; poke address of forthexec 
281d			;	inc hl 
281d			;	ld (hl), b      
281d			 
281d				; hl is now where we need to copy the word byte data to save this 
281d			 
281d 23				inc hl 
281e 22 b8 f1			ld (os_new_exec), hl 
2821				 
2821				; copy definition 
2821			 
2821 eb				ex de, hl 
2822			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2822			;	inc de    ; skip the PC for this parse 
2822 3a c0 f1			ld a, (os_new_parse_len) 
2825 4f				ld c, a 
2826 06 00			ld b, 0 
2828 ed b0			ldir		 ; copy defintion 
282a			 
282a			 
282a				; poke the address of where the new word bytes live for forthexec 
282a			 
282a 2a b6 f1			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
282d			 
282d ed 5b b8 f1		ld de, (os_new_exec)      
2831				 
2831 73				ld (hl), e 
2832 23				inc hl 
2833 72				ld (hl), d 
2834			 
2834					; TODO copy last user dict word next link to this word 
2834					; TODO update last user dict word to point to this word 
2834			; 
2834			; hl f923 de 812a ; bc 811a 
2834			 
2834			if DEBUG_FORTH_UWORD 
2834 c5				push bc 
2835 ed 4b c2 f1		ld bc, (os_new_malloc) 
2839						DMARK ":0A" 
2839 f5				push af  
283a 3a 4e 28			ld a, (.dmark)  
283d 32 6e fe			ld (debug_mark),a  
2840 3a 4f 28			ld a, (.dmark+1)  
2843 32 6f fe			ld (debug_mark+1),a  
2846 3a 50 28			ld a, (.dmark+2)  
2849 32 70 fe			ld (debug_mark+2),a  
284c 18 03			jr .pastdmark  
284e ..			.dmark: db ":0A"  
2851 f1			.pastdmark: pop af  
2852			endm  
# End of macro DMARK
2852				CALLMONITOR 
2852 cd fb 19			call break_point_state  
2855				endm  
# End of macro CALLMONITOR
2855 c1				pop bc 
2856			endif 
2856			if DEBUG_FORTH_UWORD 
2856 c5				push bc 
2857 ed 4b c2 f1		ld bc, (os_new_malloc) 
285b 03				inc bc 
285c 03				inc bc 
285d 03				inc bc 
285e 03				inc bc 
285f 03				inc bc 
2860 03				inc bc 
2861 03				inc bc 
2862 03				inc bc 
2863			 
2863						DMARK ":0B" 
2863 f5				push af  
2864 3a 78 28			ld a, (.dmark)  
2867 32 6e fe			ld (debug_mark),a  
286a 3a 79 28			ld a, (.dmark+1)  
286d 32 6f fe			ld (debug_mark+1),a  
2870 3a 7a 28			ld a, (.dmark+2)  
2873 32 70 fe			ld (debug_mark+2),a  
2876 18 03			jr .pastdmark  
2878 ..			.dmark: db ":0B"  
287b f1			.pastdmark: pop af  
287c			endm  
# End of macro DMARK
287c				CALLMONITOR 
287c cd fb 19			call break_point_state  
287f				endm  
# End of macro CALLMONITOR
287f c1				pop bc 
2880			endif 
2880			 
2880			; update word dict linked list for new word 
2880			 
2880			 
2880 2a c1 f4		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2883 23			inc hl     ; move to next work linked list ptr 
2884			 
2884 ed 5b c2 f1	ld de, (os_new_malloc)		 ; new next word 
2888 73			ld (hl), e 
2889 23			inc hl 
288a 72			ld (hl), d 
288b			 
288b			if DEBUG_FORTH_UWORD 
288b ed 4b c1 f4		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
288f			endif 
288f			 
288f ed 53 c1 f4	ld (os_last_new_uword), de      ; update last new uword ptr 
2893			 
2893			 
2893			if DEBUG_FORTH_UWORD 
2893						DMARK ":0+" 
2893 f5				push af  
2894 3a a8 28			ld a, (.dmark)  
2897 32 6e fe			ld (debug_mark),a  
289a 3a a9 28			ld a, (.dmark+1)  
289d 32 6f fe			ld (debug_mark+1),a  
28a0 3a aa 28			ld a, (.dmark+2)  
28a3 32 70 fe			ld (debug_mark+2),a  
28a6 18 03			jr .pastdmark  
28a8 ..			.dmark: db ":0+"  
28ab f1			.pastdmark: pop af  
28ac			endm  
# End of macro DMARK
28ac				CALLMONITOR 
28ac cd fb 19			call break_point_state  
28af				endm  
# End of macro CALLMONITOR
28af			endif 
28af			 
28af				STACKFRAMECHK OFF $8efe $989f 
28af				if DEBUG_STACK_IMB 
28af					if OFF 
28af						exx 
28af						ld hl, $989f 
28af						pop de   ; $989f 
28af						call cmp16 
28af						jr nz, .spnosame 
28af						ld hl, $8efe 
28af						pop de   ; $8efe 
28af						call cmp16 
28af						jr z, .spfrsame 
28af						.spnosame: call showsperror 
28af						.spfrsame: nop 
28af						exx 
28af					endif 
28af				endif 
28af			endm 
# End of macro STACKFRAMECHK
28af			 
28af c9			ret    ; dont process any remaining parser tokens as they form new word 
28b0			 
28b0			 
28b0			 
28b0			 
28b0			;		NEXT 
28b0			.SCOLN: 
28b0			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
28b0 06				db OPCODE_SCOLN 
28b1 fc 28			dw .DROP 
28b3 02				db 2 
28b4 .. 00			db ";",0           
28b6			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
28b6					if DEBUG_FORTH_WORDS_KEY 
28b6						DMARK "SCN" 
28b6 f5				push af  
28b7 3a cb 28			ld a, (.dmark)  
28ba 32 6e fe			ld (debug_mark),a  
28bd 3a cc 28			ld a, (.dmark+1)  
28c0 32 6f fe			ld (debug_mark+1),a  
28c3 3a cd 28			ld a, (.dmark+2)  
28c6 32 70 fe			ld (debug_mark+2),a  
28c9 18 03			jr .pastdmark  
28cb ..			.dmark: db "SCN"  
28ce f1			.pastdmark: pop af  
28cf			endm  
# End of macro DMARK
28cf						CALLMONITOR 
28cf cd fb 19			call break_point_state  
28d2				endm  
# End of macro CALLMONITOR
28d2					endif 
28d2					FORTH_RSP_TOS 
28d2 cd b1 20			call macro_forth_rsp_tos 
28d5				endm 
# End of macro FORTH_RSP_TOS
28d5 e5					push hl 
28d6					FORTH_RSP_POP 
28d6 cd bb 20			call macro_forth_rsp_pop 
28d9				endm 
# End of macro FORTH_RSP_POP
28d9 e1					pop hl 
28da			;		ex de,hl 
28da 22 c5 f4				ld (os_tok_ptr),hl 
28dd			 
28dd			if DEBUG_FORTH_UWORD 
28dd						DMARK "SCL" 
28dd f5				push af  
28de 3a f2 28			ld a, (.dmark)  
28e1 32 6e fe			ld (debug_mark),a  
28e4 3a f3 28			ld a, (.dmark+1)  
28e7 32 6f fe			ld (debug_mark+1),a  
28ea 3a f4 28			ld a, (.dmark+2)  
28ed 32 70 fe			ld (debug_mark+2),a  
28f0 18 03			jr .pastdmark  
28f2 ..			.dmark: db "SCL"  
28f5 f1			.pastdmark: pop af  
28f6			endm  
# End of macro DMARK
28f6				CALLMONITOR 
28f6 cd fb 19			call break_point_state  
28f9				endm  
# End of macro CALLMONITOR
28f9			endif 
28f9					NEXTW 
28f9 c3 a0 24			jp macro_next 
28fc				endm 
# End of macro NEXTW
28fc			 
28fc			.DROP: 
28fc				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
28fc 1b				db WORD_SYS_CORE+OPCODE_DROP             
28fd 27 29			dw .DUP2            
28ff 05				db 4 + 1 
2900 .. 00			db "DROP",0              
2905				endm 
# End of macro CWHEAD
2905			; | DROP ( w -- )   drop the TOS item   | DONE 
2905					if DEBUG_FORTH_WORDS_KEY 
2905						DMARK "DRP" 
2905 f5				push af  
2906 3a 1a 29			ld a, (.dmark)  
2909 32 6e fe			ld (debug_mark),a  
290c 3a 1b 29			ld a, (.dmark+1)  
290f 32 6f fe			ld (debug_mark+1),a  
2912 3a 1c 29			ld a, (.dmark+2)  
2915 32 70 fe			ld (debug_mark+2),a  
2918 18 03			jr .pastdmark  
291a ..			.dmark: db "DRP"  
291d f1			.pastdmark: pop af  
291e			endm  
# End of macro DMARK
291e						CALLMONITOR 
291e cd fb 19			call break_point_state  
2921				endm  
# End of macro CALLMONITOR
2921					endif 
2921					FORTH_DSP_POP 
2921 cd a2 23			call macro_forth_dsp_pop 
2924				endm 
# End of macro FORTH_DSP_POP
2924					NEXTW 
2924 c3 a0 24			jp macro_next 
2927				endm 
# End of macro NEXTW
2927			.DUP2: 
2927				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2927 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2928 6c 29			dw .DROP2            
292a 05				db 4 + 1 
292b .. 00			db "2DUP",0              
2930				endm 
# End of macro CWHEAD
2930			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2930					if DEBUG_FORTH_WORDS_KEY 
2930						DMARK "2DU" 
2930 f5				push af  
2931 3a 45 29			ld a, (.dmark)  
2934 32 6e fe			ld (debug_mark),a  
2937 3a 46 29			ld a, (.dmark+1)  
293a 32 6f fe			ld (debug_mark+1),a  
293d 3a 47 29			ld a, (.dmark+2)  
2940 32 70 fe			ld (debug_mark+2),a  
2943 18 03			jr .pastdmark  
2945 ..			.dmark: db "2DU"  
2948 f1			.pastdmark: pop af  
2949			endm  
# End of macro DMARK
2949						CALLMONITOR 
2949 cd fb 19			call break_point_state  
294c				endm  
# End of macro CALLMONITOR
294c					endif 
294c					FORTH_DSP_VALUEHL 
294c cd ea 22			call macro_dsp_valuehl 
294f				endm 
# End of macro FORTH_DSP_VALUEHL
294f e5					push hl      ; 2 
2950			 
2950					FORTH_DSP_POP 
2950 cd a2 23			call macro_forth_dsp_pop 
2953				endm 
# End of macro FORTH_DSP_POP
2953					 
2953					FORTH_DSP_VALUEHL 
2953 cd ea 22			call macro_dsp_valuehl 
2956				endm 
# End of macro FORTH_DSP_VALUEHL
2956			;		push hl      ; 1 
2956			 
2956					FORTH_DSP_POP 
2956 cd a2 23			call macro_forth_dsp_pop 
2959				endm 
# End of macro FORTH_DSP_POP
2959			 
2959			;		pop hl       ; 1 
2959 d1					pop de       ; 2 
295a			 
295a cd f3 20				call forth_push_numhl 
295d eb					ex de, hl 
295e cd f3 20				call forth_push_numhl 
2961			 
2961					 
2961 eb					ex de, hl 
2962			 
2962 cd f3 20				call forth_push_numhl 
2965 eb					ex de, hl 
2966 cd f3 20				call forth_push_numhl 
2969			 
2969			 
2969					NEXTW 
2969 c3 a0 24			jp macro_next 
296c				endm 
# End of macro NEXTW
296c			.DROP2: 
296c				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
296c 1d				db WORD_SYS_CORE+OPCODE_DROP2             
296d 9b 29			dw .SWAP2            
296f 06				db 5 + 1 
2970 .. 00			db "2DROP",0              
2976				endm 
# End of macro CWHEAD
2976			; | 2DROP ( w w -- )    Double drop | DONE 
2976					if DEBUG_FORTH_WORDS_KEY 
2976						DMARK "2DR" 
2976 f5				push af  
2977 3a 8b 29			ld a, (.dmark)  
297a 32 6e fe			ld (debug_mark),a  
297d 3a 8c 29			ld a, (.dmark+1)  
2980 32 6f fe			ld (debug_mark+1),a  
2983 3a 8d 29			ld a, (.dmark+2)  
2986 32 70 fe			ld (debug_mark+2),a  
2989 18 03			jr .pastdmark  
298b ..			.dmark: db "2DR"  
298e f1			.pastdmark: pop af  
298f			endm  
# End of macro DMARK
298f						CALLMONITOR 
298f cd fb 19			call break_point_state  
2992				endm  
# End of macro CALLMONITOR
2992					endif 
2992					FORTH_DSP_POP 
2992 cd a2 23			call macro_forth_dsp_pop 
2995				endm 
# End of macro FORTH_DSP_POP
2995					FORTH_DSP_POP 
2995 cd a2 23			call macro_forth_dsp_pop 
2998				endm 
# End of macro FORTH_DSP_POP
2998					NEXTW 
2998 c3 a0 24			jp macro_next 
299b				endm 
# End of macro NEXTW
299b			.SWAP2: 
299b				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
299b 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
299c c4 29			dw .AT            
299e 06				db 5 + 1 
299f .. 00			db "2SWAP",0              
29a5				endm 
# End of macro CWHEAD
29a5			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
29a5					if DEBUG_FORTH_WORDS_KEY 
29a5						DMARK "2SW" 
29a5 f5				push af  
29a6 3a ba 29			ld a, (.dmark)  
29a9 32 6e fe			ld (debug_mark),a  
29ac 3a bb 29			ld a, (.dmark+1)  
29af 32 6f fe			ld (debug_mark+1),a  
29b2 3a bc 29			ld a, (.dmark+2)  
29b5 32 70 fe			ld (debug_mark+2),a  
29b8 18 03			jr .pastdmark  
29ba ..			.dmark: db "2SW"  
29bd f1			.pastdmark: pop af  
29be			endm  
# End of macro DMARK
29be						CALLMONITOR 
29be cd fb 19			call break_point_state  
29c1				endm  
# End of macro CALLMONITOR
29c1					endif 
29c1					NEXTW 
29c1 c3 a0 24			jp macro_next 
29c4				endm 
# End of macro NEXTW
29c4			.AT: 
29c4				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
29c4 1f				db WORD_SYS_CORE+OPCODE_AT             
29c5 f6 29			dw .CAT            
29c7 02				db 1 + 1 
29c8 .. 00			db "@",0              
29ca				endm 
# End of macro CWHEAD
29ca			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
29ca			 
29ca					if DEBUG_FORTH_WORDS_KEY 
29ca						DMARK "AT." 
29ca f5				push af  
29cb 3a df 29			ld a, (.dmark)  
29ce 32 6e fe			ld (debug_mark),a  
29d1 3a e0 29			ld a, (.dmark+1)  
29d4 32 6f fe			ld (debug_mark+1),a  
29d7 3a e1 29			ld a, (.dmark+2)  
29da 32 70 fe			ld (debug_mark+2),a  
29dd 18 03			jr .pastdmark  
29df ..			.dmark: db "AT."  
29e2 f1			.pastdmark: pop af  
29e3			endm  
# End of macro DMARK
29e3						CALLMONITOR 
29e3 cd fb 19			call break_point_state  
29e6				endm  
# End of macro CALLMONITOR
29e6					endif 
29e6			.getbyteat:	 
29e6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29e6 cd ea 22			call macro_dsp_valuehl 
29e9				endm 
# End of macro FORTH_DSP_VALUEHL
29e9					 
29e9			;		push hl 
29e9				 
29e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29e9 cd a2 23			call macro_forth_dsp_pop 
29ec				endm 
# End of macro FORTH_DSP_POP
29ec			 
29ec			;		pop hl 
29ec			 
29ec 7e					ld a, (hl) 
29ed			 
29ed 6f					ld l, a 
29ee 26 00				ld h, 0 
29f0 cd f3 20				call forth_push_numhl 
29f3			 
29f3					NEXTW 
29f3 c3 a0 24			jp macro_next 
29f6				endm 
# End of macro NEXTW
29f6			.CAT: 
29f6				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
29f6 20				db WORD_SYS_CORE+OPCODE_CAT             
29f7 1f 2a			dw .BANG            
29f9 03				db 2 + 1 
29fa .. 00			db "C@",0              
29fd				endm 
# End of macro CWHEAD
29fd			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
29fd					if DEBUG_FORTH_WORDS_KEY 
29fd						DMARK "CAA" 
29fd f5				push af  
29fe 3a 12 2a			ld a, (.dmark)  
2a01 32 6e fe			ld (debug_mark),a  
2a04 3a 13 2a			ld a, (.dmark+1)  
2a07 32 6f fe			ld (debug_mark+1),a  
2a0a 3a 14 2a			ld a, (.dmark+2)  
2a0d 32 70 fe			ld (debug_mark+2),a  
2a10 18 03			jr .pastdmark  
2a12 ..			.dmark: db "CAA"  
2a15 f1			.pastdmark: pop af  
2a16			endm  
# End of macro DMARK
2a16						CALLMONITOR 
2a16 cd fb 19			call break_point_state  
2a19				endm  
# End of macro CALLMONITOR
2a19					endif 
2a19 c3 e6 29				jp .getbyteat 
2a1c					NEXTW 
2a1c c3 a0 24			jp macro_next 
2a1f				endm 
# End of macro NEXTW
2a1f			.BANG: 
2a1f				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2a1f 21				db WORD_SYS_CORE+OPCODE_BANG             
2a20 55 2a			dw .CBANG            
2a22 02				db 1 + 1 
2a23 .. 00			db "!",0              
2a25				endm 
# End of macro CWHEAD
2a25			; | ! ( x w -- ) Store x at address w      | DONE 
2a25					if DEBUG_FORTH_WORDS_KEY 
2a25						DMARK "BNG" 
2a25 f5				push af  
2a26 3a 3a 2a			ld a, (.dmark)  
2a29 32 6e fe			ld (debug_mark),a  
2a2c 3a 3b 2a			ld a, (.dmark+1)  
2a2f 32 6f fe			ld (debug_mark+1),a  
2a32 3a 3c 2a			ld a, (.dmark+2)  
2a35 32 70 fe			ld (debug_mark+2),a  
2a38 18 03			jr .pastdmark  
2a3a ..			.dmark: db "BNG"  
2a3d f1			.pastdmark: pop af  
2a3e			endm  
# End of macro DMARK
2a3e						CALLMONITOR 
2a3e cd fb 19			call break_point_state  
2a41				endm  
# End of macro CALLMONITOR
2a41					endif 
2a41			 
2a41			.storebyteat:		 
2a41					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a41 cd ea 22			call macro_dsp_valuehl 
2a44				endm 
# End of macro FORTH_DSP_VALUEHL
2a44					 
2a44 e5					push hl 
2a45				 
2a45					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a45 cd a2 23			call macro_forth_dsp_pop 
2a48				endm 
# End of macro FORTH_DSP_POP
2a48			 
2a48					; get byte to poke 
2a48			 
2a48					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a48 cd ea 22			call macro_dsp_valuehl 
2a4b				endm 
# End of macro FORTH_DSP_VALUEHL
2a4b e5					push hl 
2a4c			 
2a4c			 
2a4c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a4c cd a2 23			call macro_forth_dsp_pop 
2a4f				endm 
# End of macro FORTH_DSP_POP
2a4f			 
2a4f			 
2a4f d1					pop de 
2a50 e1					pop hl 
2a51			 
2a51 73					ld (hl),e 
2a52			 
2a52			 
2a52					NEXTW 
2a52 c3 a0 24			jp macro_next 
2a55				endm 
# End of macro NEXTW
2a55			.CBANG: 
2a55				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2a55 22				db WORD_SYS_CORE+OPCODE_CBANG             
2a56 7e 2a			dw .SCALL            
2a58 03				db 2 + 1 
2a59 .. 00			db "C!",0              
2a5c				endm 
# End of macro CWHEAD
2a5c			; | C!  ( x w -- ) Store x at address w  | DONE 
2a5c					if DEBUG_FORTH_WORDS_KEY 
2a5c						DMARK "CBA" 
2a5c f5				push af  
2a5d 3a 71 2a			ld a, (.dmark)  
2a60 32 6e fe			ld (debug_mark),a  
2a63 3a 72 2a			ld a, (.dmark+1)  
2a66 32 6f fe			ld (debug_mark+1),a  
2a69 3a 73 2a			ld a, (.dmark+2)  
2a6c 32 70 fe			ld (debug_mark+2),a  
2a6f 18 03			jr .pastdmark  
2a71 ..			.dmark: db "CBA"  
2a74 f1			.pastdmark: pop af  
2a75			endm  
# End of macro DMARK
2a75						CALLMONITOR 
2a75 cd fb 19			call break_point_state  
2a78				endm  
# End of macro CALLMONITOR
2a78					endif 
2a78 c3 41 2a				jp .storebyteat 
2a7b					NEXTW 
2a7b c3 a0 24			jp macro_next 
2a7e				endm 
# End of macro NEXTW
2a7e			.SCALL: 
2a7e				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2a7e 23				db WORD_SYS_CORE+OPCODE_SCALL             
2a7f b2 2a			dw .DEPTH            
2a81 05				db 4 + 1 
2a82 .. 00			db "CALL",0              
2a87				endm 
# End of macro CWHEAD
2a87			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2a87					if DEBUG_FORTH_WORDS_KEY 
2a87						DMARK "CLL" 
2a87 f5				push af  
2a88 3a 9c 2a			ld a, (.dmark)  
2a8b 32 6e fe			ld (debug_mark),a  
2a8e 3a 9d 2a			ld a, (.dmark+1)  
2a91 32 6f fe			ld (debug_mark+1),a  
2a94 3a 9e 2a			ld a, (.dmark+2)  
2a97 32 70 fe			ld (debug_mark+2),a  
2a9a 18 03			jr .pastdmark  
2a9c ..			.dmark: db "CLL"  
2a9f f1			.pastdmark: pop af  
2aa0			endm  
# End of macro DMARK
2aa0						CALLMONITOR 
2aa0 cd fb 19			call break_point_state  
2aa3				endm  
# End of macro CALLMONITOR
2aa3					endif 
2aa3			 
2aa3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2aa3 cd ea 22			call macro_dsp_valuehl 
2aa6				endm 
# End of macro FORTH_DSP_VALUEHL
2aa6			 
2aa6			;		push hl 
2aa6			 
2aa6					; destroy value TOS 
2aa6			 
2aa6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2aa6 cd a2 23			call macro_forth_dsp_pop 
2aa9				endm 
# End of macro FORTH_DSP_POP
2aa9			 
2aa9						 
2aa9			;		pop hl 
2aa9			 
2aa9					; how to do a call with hl???? save SP? 
2aa9 cd 44 24				call forth_call_hl 
2aac			 
2aac			 
2aac					; TODO push value back onto stack for another op etc 
2aac			 
2aac cd f3 20				call forth_push_numhl 
2aaf					NEXTW 
2aaf c3 a0 24			jp macro_next 
2ab2				endm 
# End of macro NEXTW
2ab2			.DEPTH: 
2ab2				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2ab2 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2ab3 ef 2a			dw .OVER            
2ab5 06				db 5 + 1 
2ab6 .. 00			db "DEPTH",0              
2abc				endm 
# End of macro CWHEAD
2abc			; | DEPTH ( -- u ) Push count of stack | DONE 
2abc					; take current TOS and remove from base value div by two to get count 
2abc					if DEBUG_FORTH_WORDS_KEY 
2abc						DMARK "DEP" 
2abc f5				push af  
2abd 3a d1 2a			ld a, (.dmark)  
2ac0 32 6e fe			ld (debug_mark),a  
2ac3 3a d2 2a			ld a, (.dmark+1)  
2ac6 32 6f fe			ld (debug_mark+1),a  
2ac9 3a d3 2a			ld a, (.dmark+2)  
2acc 32 70 fe			ld (debug_mark+2),a  
2acf 18 03			jr .pastdmark  
2ad1 ..			.dmark: db "DEP"  
2ad4 f1			.pastdmark: pop af  
2ad5			endm  
# End of macro DMARK
2ad5						CALLMONITOR 
2ad5 cd fb 19			call break_point_state  
2ad8				endm  
# End of macro CALLMONITOR
2ad8					endif 
2ad8			 
2ad8			 
2ad8 2a f1 f9			ld hl, (cli_data_sp) 
2adb 11 2b f7			ld de, cli_data_stack 
2ade ed 52			sbc hl,de 
2ae0				 
2ae0				; div by size of stack item 
2ae0			 
2ae0 5d				ld e,l 
2ae1 0e 03			ld c, 3 
2ae3 cd 16 0f			call Div8 
2ae6			 
2ae6 6f				ld l,a 
2ae7 26 00			ld h,0 
2ae9			 
2ae9				;srl h 
2ae9				;rr l 
2ae9			 
2ae9 cd f3 20				call forth_push_numhl 
2aec					NEXTW 
2aec c3 a0 24			jp macro_next 
2aef				endm 
# End of macro NEXTW
2aef			.OVER: 
2aef				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2aef 42				db WORD_SYS_CORE+46             
2af0 36 2b			dw .PAUSE            
2af2 05				db 4 + 1 
2af3 .. 00			db "OVER",0              
2af8				endm 
# End of macro CWHEAD
2af8			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2af8					if DEBUG_FORTH_WORDS_KEY 
2af8						DMARK "OVR" 
2af8 f5				push af  
2af9 3a 0d 2b			ld a, (.dmark)  
2afc 32 6e fe			ld (debug_mark),a  
2aff 3a 0e 2b			ld a, (.dmark+1)  
2b02 32 6f fe			ld (debug_mark+1),a  
2b05 3a 0f 2b			ld a, (.dmark+2)  
2b08 32 70 fe			ld (debug_mark+2),a  
2b0b 18 03			jr .pastdmark  
2b0d ..			.dmark: db "OVR"  
2b10 f1			.pastdmark: pop af  
2b11			endm  
# End of macro DMARK
2b11						CALLMONITOR 
2b11 cd fb 19			call break_point_state  
2b14				endm  
# End of macro CALLMONITOR
2b14					endif 
2b14			 
2b14					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b14 cd ea 22			call macro_dsp_valuehl 
2b17				endm 
# End of macro FORTH_DSP_VALUEHL
2b17 e5					push hl    ; n2 
2b18					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b18 cd a2 23			call macro_forth_dsp_pop 
2b1b				endm 
# End of macro FORTH_DSP_POP
2b1b			 
2b1b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b1b cd ea 22			call macro_dsp_valuehl 
2b1e				endm 
# End of macro FORTH_DSP_VALUEHL
2b1e e5					push hl    ; n1 
2b1f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b1f cd a2 23			call macro_forth_dsp_pop 
2b22				endm 
# End of macro FORTH_DSP_POP
2b22			 
2b22 d1					pop de     ; n1 
2b23 e1					pop hl     ; n2 
2b24			 
2b24 d5					push de 
2b25 e5					push hl 
2b26 d5					push de 
2b27			 
2b27					; push back  
2b27			 
2b27 e1					pop hl 
2b28 cd f3 20				call forth_push_numhl 
2b2b e1					pop hl 
2b2c cd f3 20				call forth_push_numhl 
2b2f e1					pop hl 
2b30 cd f3 20				call forth_push_numhl 
2b33					NEXTW 
2b33 c3 a0 24			jp macro_next 
2b36				endm 
# End of macro NEXTW
2b36			 
2b36			.PAUSE: 
2b36				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2b36 43				db WORD_SYS_CORE+47             
2b37 6b 2b			dw .PAUSES            
2b39 08				db 7 + 1 
2b3a .. 00			db "PAUSEMS",0              
2b42				endm 
# End of macro CWHEAD
2b42			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2b42					if DEBUG_FORTH_WORDS_KEY 
2b42						DMARK "PMS" 
2b42 f5				push af  
2b43 3a 57 2b			ld a, (.dmark)  
2b46 32 6e fe			ld (debug_mark),a  
2b49 3a 58 2b			ld a, (.dmark+1)  
2b4c 32 6f fe			ld (debug_mark+1),a  
2b4f 3a 59 2b			ld a, (.dmark+2)  
2b52 32 70 fe			ld (debug_mark+2),a  
2b55 18 03			jr .pastdmark  
2b57 ..			.dmark: db "PMS"  
2b5a f1			.pastdmark: pop af  
2b5b			endm  
# End of macro DMARK
2b5b						CALLMONITOR 
2b5b cd fb 19			call break_point_state  
2b5e				endm  
# End of macro CALLMONITOR
2b5e					endif 
2b5e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b5e cd ea 22			call macro_dsp_valuehl 
2b61				endm 
# End of macro FORTH_DSP_VALUEHL
2b61			;		push hl    ; n2 
2b61					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b61 cd a2 23			call macro_forth_dsp_pop 
2b64				endm 
# End of macro FORTH_DSP_POP
2b64			;		pop hl 
2b64			 
2b64 7d					ld a, l 
2b65 cd 7a 0c				call aDelayInMS 
2b68				       NEXTW 
2b68 c3 a0 24			jp macro_next 
2b6b				endm 
# End of macro NEXTW
2b6b			.PAUSES:  
2b6b				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2b6b 44				db WORD_SYS_CORE+48             
2b6c da 2b			dw .ROT            
2b6e 06				db 5 + 1 
2b6f .. 00			db "PAUSE",0              
2b75				endm 
# End of macro CWHEAD
2b75			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2b75					if DEBUG_FORTH_WORDS_KEY 
2b75						DMARK "PAU" 
2b75 f5				push af  
2b76 3a 8a 2b			ld a, (.dmark)  
2b79 32 6e fe			ld (debug_mark),a  
2b7c 3a 8b 2b			ld a, (.dmark+1)  
2b7f 32 6f fe			ld (debug_mark+1),a  
2b82 3a 8c 2b			ld a, (.dmark+2)  
2b85 32 70 fe			ld (debug_mark+2),a  
2b88 18 03			jr .pastdmark  
2b8a ..			.dmark: db "PAU"  
2b8d f1			.pastdmark: pop af  
2b8e			endm  
# End of macro DMARK
2b8e						CALLMONITOR 
2b8e cd fb 19			call break_point_state  
2b91				endm  
# End of macro CALLMONITOR
2b91					endif 
2b91					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b91 cd ea 22			call macro_dsp_valuehl 
2b94				endm 
# End of macro FORTH_DSP_VALUEHL
2b94			;		push hl    ; n2 
2b94					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b94 cd a2 23			call macro_forth_dsp_pop 
2b97				endm 
# End of macro FORTH_DSP_POP
2b97			;		pop hl 
2b97 45					ld b, l 
2b98					if DEBUG_FORTH_WORDS 
2b98						DMARK "PAU" 
2b98 f5				push af  
2b99 3a ad 2b			ld a, (.dmark)  
2b9c 32 6e fe			ld (debug_mark),a  
2b9f 3a ae 2b			ld a, (.dmark+1)  
2ba2 32 6f fe			ld (debug_mark+1),a  
2ba5 3a af 2b			ld a, (.dmark+2)  
2ba8 32 70 fe			ld (debug_mark+2),a  
2bab 18 03			jr .pastdmark  
2bad ..			.dmark: db "PAU"  
2bb0 f1			.pastdmark: pop af  
2bb1			endm  
# End of macro DMARK
2bb1						CALLMONITOR 
2bb1 cd fb 19			call break_point_state  
2bb4				endm  
# End of macro CALLMONITOR
2bb4					endif 
2bb4 c5			.pauses1:	push bc 
2bb5 cd 95 0c				call delay1s 
2bb8 c1					pop bc 
2bb9					if DEBUG_FORTH_WORDS 
2bb9						DMARK "PA1" 
2bb9 f5				push af  
2bba 3a ce 2b			ld a, (.dmark)  
2bbd 32 6e fe			ld (debug_mark),a  
2bc0 3a cf 2b			ld a, (.dmark+1)  
2bc3 32 6f fe			ld (debug_mark+1),a  
2bc6 3a d0 2b			ld a, (.dmark+2)  
2bc9 32 70 fe			ld (debug_mark+2),a  
2bcc 18 03			jr .pastdmark  
2bce ..			.dmark: db "PA1"  
2bd1 f1			.pastdmark: pop af  
2bd2			endm  
# End of macro DMARK
2bd2						CALLMONITOR 
2bd2 cd fb 19			call break_point_state  
2bd5				endm  
# End of macro CALLMONITOR
2bd5					endif 
2bd5 10 dd				djnz .pauses1 
2bd7			 
2bd7				       NEXTW 
2bd7 c3 a0 24			jp macro_next 
2bda				endm 
# End of macro NEXTW
2bda			.ROT: 
2bda				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2bda 45				db WORD_SYS_CORE+49             
2bdb 28 2c			dw .UWORDS            
2bdd 04				db 3 + 1 
2bde .. 00			db "ROT",0              
2be2				endm 
# End of macro CWHEAD
2be2			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2be2					if DEBUG_FORTH_WORDS_KEY 
2be2						DMARK "ROT" 
2be2 f5				push af  
2be3 3a f7 2b			ld a, (.dmark)  
2be6 32 6e fe			ld (debug_mark),a  
2be9 3a f8 2b			ld a, (.dmark+1)  
2bec 32 6f fe			ld (debug_mark+1),a  
2bef 3a f9 2b			ld a, (.dmark+2)  
2bf2 32 70 fe			ld (debug_mark+2),a  
2bf5 18 03			jr .pastdmark  
2bf7 ..			.dmark: db "ROT"  
2bfa f1			.pastdmark: pop af  
2bfb			endm  
# End of macro DMARK
2bfb						CALLMONITOR 
2bfb cd fb 19			call break_point_state  
2bfe				endm  
# End of macro CALLMONITOR
2bfe					endif 
2bfe			 
2bfe					FORTH_DSP_VALUEHL 
2bfe cd ea 22			call macro_dsp_valuehl 
2c01				endm 
# End of macro FORTH_DSP_VALUEHL
2c01 e5					push hl    ; u3  
2c02			 
2c02					FORTH_DSP_POP 
2c02 cd a2 23			call macro_forth_dsp_pop 
2c05				endm 
# End of macro FORTH_DSP_POP
2c05			   
2c05					FORTH_DSP_VALUEHL 
2c05 cd ea 22			call macro_dsp_valuehl 
2c08				endm 
# End of macro FORTH_DSP_VALUEHL
2c08 e5					push hl     ; u2 
2c09			 
2c09					FORTH_DSP_POP 
2c09 cd a2 23			call macro_forth_dsp_pop 
2c0c				endm 
# End of macro FORTH_DSP_POP
2c0c			 
2c0c					FORTH_DSP_VALUEHL 
2c0c cd ea 22			call macro_dsp_valuehl 
2c0f				endm 
# End of macro FORTH_DSP_VALUEHL
2c0f e5					push hl     ; u1 
2c10			 
2c10					FORTH_DSP_POP 
2c10 cd a2 23			call macro_forth_dsp_pop 
2c13				endm 
# End of macro FORTH_DSP_POP
2c13			 
2c13 c1					pop bc      ; u1 
2c14 e1					pop hl      ; u2 
2c15 d1					pop de      ; u3 
2c16			 
2c16			 
2c16 c5					push bc 
2c17 d5					push de 
2c18 e5					push hl 
2c19			 
2c19			 
2c19 e1					pop hl 
2c1a cd f3 20				call forth_push_numhl 
2c1d			 
2c1d e1					pop hl 
2c1e cd f3 20				call forth_push_numhl 
2c21			 
2c21 e1					pop hl 
2c22 cd f3 20				call forth_push_numhl 
2c25					 
2c25			 
2c25			 
2c25			 
2c25			 
2c25			 
2c25				       NEXTW 
2c25 c3 a0 24			jp macro_next 
2c28				endm 
# End of macro NEXTW
2c28			 
2c28			.UWORDS: 
2c28				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2c28 50				db WORD_SYS_CORE+60             
2c29 ea 2c			dw .BP            
2c2b 07				db 6 + 1 
2c2c .. 00			db "UWORDS",0              
2c33				endm 
# End of macro CWHEAD
2c33			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2c33			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2c33			; | | Following the count are the individual words. 
2c33			; | | 
2c33			; | | e.g. UWORDS 
2c33			; | | BOX DIRLIST 2 
2c33			; | |  
2c33			; | | Can be used to save the words to storage via: 
2c33			; | | UWORDS $01 DO $01 APPEND LOOP 
2c33				if DEBUG_FORTH_WORDS_KEY 
2c33					DMARK "UWR" 
2c33 f5				push af  
2c34 3a 48 2c			ld a, (.dmark)  
2c37 32 6e fe			ld (debug_mark),a  
2c3a 3a 49 2c			ld a, (.dmark+1)  
2c3d 32 6f fe			ld (debug_mark+1),a  
2c40 3a 4a 2c			ld a, (.dmark+2)  
2c43 32 70 fe			ld (debug_mark+2),a  
2c46 18 03			jr .pastdmark  
2c48 ..			.dmark: db "UWR"  
2c4b f1			.pastdmark: pop af  
2c4c			endm  
# End of macro DMARK
2c4c					CALLMONITOR 
2c4c cd fb 19			call break_point_state  
2c4f				endm  
# End of macro CALLMONITOR
2c4f				endif 
2c4f 21 00 80				ld hl, baseram 
2c52					;ld hl, baseusermem 
2c52 01 00 00				ld bc, 0    ; start a counter 
2c55			 
2c55				; skip dict stub 
2c55			 
2c55 cd f1 25				call forth_tok_next 
2c58			 
2c58			 
2c58			; while we have words to look for 
2c58			 
2c58 7e			.douscan:	ld a, (hl)      
2c59				if DEBUG_FORTH_WORDS 
2c59					DMARK "UWs" 
2c59 f5				push af  
2c5a 3a 6e 2c			ld a, (.dmark)  
2c5d 32 6e fe			ld (debug_mark),a  
2c60 3a 6f 2c			ld a, (.dmark+1)  
2c63 32 6f fe			ld (debug_mark+1),a  
2c66 3a 70 2c			ld a, (.dmark+2)  
2c69 32 70 fe			ld (debug_mark+2),a  
2c6c 18 03			jr .pastdmark  
2c6e ..			.dmark: db "UWs"  
2c71 f1			.pastdmark: pop af  
2c72			endm  
# End of macro DMARK
2c72					CALLMONITOR 
2c72 cd fb 19			call break_point_state  
2c75				endm  
# End of macro CALLMONITOR
2c75				endif 
2c75 fe 00				cp WORD_SYS_END 
2c77 28 4d				jr z, .udone 
2c79 fe 01				cp WORD_SYS_UWORD 
2c7b 20 44				jr nz, .nuword 
2c7d			 
2c7d				if DEBUG_FORTH_WORDS 
2c7d					DMARK "UWu" 
2c7d f5				push af  
2c7e 3a 92 2c			ld a, (.dmark)  
2c81 32 6e fe			ld (debug_mark),a  
2c84 3a 93 2c			ld a, (.dmark+1)  
2c87 32 6f fe			ld (debug_mark+1),a  
2c8a 3a 94 2c			ld a, (.dmark+2)  
2c8d 32 70 fe			ld (debug_mark+2),a  
2c90 18 03			jr .pastdmark  
2c92 ..			.dmark: db "UWu"  
2c95 f1			.pastdmark: pop af  
2c96			endm  
# End of macro DMARK
2c96					CALLMONITOR 
2c96 cd fb 19			call break_point_state  
2c99				endm  
# End of macro CALLMONITOR
2c99				endif 
2c99					; we have a uword so push its name to the stack 
2c99			 
2c99 e5				   	push hl  ; save so we can move to next dict block 
2c9a			 
2c9a					; skip opcode 
2c9a 23					inc hl  
2c9b					; skip next ptr 
2c9b 23					inc hl  
2c9c 23					inc hl 
2c9d					; skip len 
2c9d 23					inc hl 
2c9e				if DEBUG_FORTH_WORDS 
2c9e					DMARK "UWt" 
2c9e f5				push af  
2c9f 3a b3 2c			ld a, (.dmark)  
2ca2 32 6e fe			ld (debug_mark),a  
2ca5 3a b4 2c			ld a, (.dmark+1)  
2ca8 32 6f fe			ld (debug_mark+1),a  
2cab 3a b5 2c			ld a, (.dmark+2)  
2cae 32 70 fe			ld (debug_mark+2),a  
2cb1 18 03			jr .pastdmark  
2cb3 ..			.dmark: db "UWt"  
2cb6 f1			.pastdmark: pop af  
2cb7			endm  
# End of macro DMARK
2cb7					CALLMONITOR 
2cb7 cd fb 19			call break_point_state  
2cba				endm  
# End of macro CALLMONITOR
2cba				endif 
2cba 03					inc bc 
2cbb			 
2cbb c5					push bc 
2cbc cd 61 21				call forth_push_str 
2cbf c1					pop bc 
2cc0			 
2cc0 e1					pop hl 	 
2cc1			 
2cc1 cd f1 25		.nuword:	call forth_tok_next 
2cc4 18 92				jr .douscan  
2cc6			 
2cc6			.udone:		 ; push count of uwords found 
2cc6 c5					push bc 
2cc7 e1					pop hl 
2cc8			 
2cc8				if DEBUG_FORTH_WORDS 
2cc8					DMARK "UWc" 
2cc8 f5				push af  
2cc9 3a dd 2c			ld a, (.dmark)  
2ccc 32 6e fe			ld (debug_mark),a  
2ccf 3a de 2c			ld a, (.dmark+1)  
2cd2 32 6f fe			ld (debug_mark+1),a  
2cd5 3a df 2c			ld a, (.dmark+2)  
2cd8 32 70 fe			ld (debug_mark+2),a  
2cdb 18 03			jr .pastdmark  
2cdd ..			.dmark: db "UWc"  
2ce0 f1			.pastdmark: pop af  
2ce1			endm  
# End of macro DMARK
2ce1					CALLMONITOR 
2ce1 cd fb 19			call break_point_state  
2ce4				endm  
# End of macro CALLMONITOR
2ce4				endif 
2ce4 cd f3 20				call forth_push_numhl 
2ce7			 
2ce7			 
2ce7				       NEXTW 
2ce7 c3 a0 24			jp macro_next 
2cea				endm 
# End of macro NEXTW
2cea			 
2cea			.BP: 
2cea				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2cea 54				db WORD_SYS_CORE+64             
2ceb 20 2d			dw .MONITOR            
2ced 03				db 2 + 1 
2cee .. 00			db "BP",0              
2cf1				endm 
# End of macro CWHEAD
2cf1			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2cf1			; | | $00 Will enable the break points within specific code paths 
2cf1			; | | $01 Will disable break points 
2cf1			; | |  
2cf1			; | | By default break points are off. Either the above can be used to enable them 
2cf1			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2cf1			; | | and on release of the pressed key a message will be disaplayed to notify 
2cf1			; | | that break points are enabled. Pressing any key will then continue boot process. 
2cf1					; get byte count 
2cf1					if DEBUG_FORTH_WORDS_KEY 
2cf1						DMARK "BP." 
2cf1 f5				push af  
2cf2 3a 06 2d			ld a, (.dmark)  
2cf5 32 6e fe			ld (debug_mark),a  
2cf8 3a 07 2d			ld a, (.dmark+1)  
2cfb 32 6f fe			ld (debug_mark+1),a  
2cfe 3a 08 2d			ld a, (.dmark+2)  
2d01 32 70 fe			ld (debug_mark+2),a  
2d04 18 03			jr .pastdmark  
2d06 ..			.dmark: db "BP."  
2d09 f1			.pastdmark: pop af  
2d0a			endm  
# End of macro DMARK
2d0a						CALLMONITOR 
2d0a cd fb 19			call break_point_state  
2d0d				endm  
# End of macro CALLMONITOR
2d0d					endif 
2d0d			 
2d0d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d0d cd ea 22			call macro_dsp_valuehl 
2d10				endm 
# End of macro FORTH_DSP_VALUEHL
2d10			 
2d10			;		push hl 
2d10			 
2d10					; destroy value TOS 
2d10			 
2d10					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d10 cd a2 23			call macro_forth_dsp_pop 
2d13				endm 
# End of macro FORTH_DSP_POP
2d13			 
2d13			;		pop hl 
2d13			 
2d13 3e 00				ld a,0 
2d15 bd					cp l 
2d16 28 02				jr z, .bpset 
2d18 3e 2a				ld a, '*' 
2d1a			 
2d1a 32 b5 f1		.bpset:		ld (os_view_disable), a 
2d1d			 
2d1d			 
2d1d					NEXTW 
2d1d c3 a0 24			jp macro_next 
2d20				endm 
# End of macro NEXTW
2d20			 
2d20			 
2d20			.MONITOR: 
2d20				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2d20 55				db WORD_SYS_CORE+65             
2d21 53 2d			dw .MALLOC            
2d23 08				db 7 + 1 
2d24 .. 00			db "MONITOR",0              
2d2c				endm 
# End of macro CWHEAD
2d2c			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2d2c			; | | At start the current various registers will be displayed with contents. 
2d2c			; | | Top right corner will show the most recent debug marker seen. 
2d2c			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2d2c			; | | and the return stack pointer (RSP). 
2d2c			; | | Pressing: 
2d2c			; | |    1 - Initial screen 
2d2c			; | |    2 - Display a data dump of HL 
2d2c			; | |    3 - Display a data dump of DE 
2d2c			; | |    4 - Display a data dump of BC 
2d2c			; | |    5 - Display a data dump of HL 
2d2c			; | |    6 - Display a data dump of DSP 
2d2c			; | |    7 - Display a data dump of RSP 
2d2c			; | |    8 - Display a data dump of what is at DSP 
2d2c			; | |    9 - Display a data dump of what is at RSP 
2d2c			; | |    0 - Exit monitor and continue running. This will also enable break points 
2d2c			; | |    * - Disable break points 
2d2c			; | |    # - Enter traditional monitor mode 
2d2c			; | | 
2d2c			; | | Monitor Mode 
2d2c			; | | ------------ 
2d2c			; | | A prompt of '>' will be shown for various commands: 
2d2c			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2d2c			; | |    C - Continue display a data dump from the last set address 
2d2c			; | |    M xxxx - Set start of memory edit at address xx 
2d2c			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2d2c			; | |    Q - Return to previous 
2d2c					if DEBUG_FORTH_WORDS_KEY 
2d2c						DMARK "MON" 
2d2c f5				push af  
2d2d 3a 41 2d			ld a, (.dmark)  
2d30 32 6e fe			ld (debug_mark),a  
2d33 3a 42 2d			ld a, (.dmark+1)  
2d36 32 6f fe			ld (debug_mark+1),a  
2d39 3a 43 2d			ld a, (.dmark+2)  
2d3c 32 70 fe			ld (debug_mark+2),a  
2d3f 18 03			jr .pastdmark  
2d41 ..			.dmark: db "MON"  
2d44 f1			.pastdmark: pop af  
2d45			endm  
# End of macro DMARK
2d45						CALLMONITOR 
2d45 cd fb 19			call break_point_state  
2d48				endm  
# End of macro CALLMONITOR
2d48					endif 
2d48 3e 00				ld a, 0 
2d4a 32 b5 f1				ld (os_view_disable), a 
2d4d			 
2d4d					CALLMONITOR 
2d4d cd fb 19			call break_point_state  
2d50				endm  
# End of macro CALLMONITOR
2d50			 
2d50			;	call monitor 
2d50			 
2d50					NEXTW 
2d50 c3 a0 24			jp macro_next 
2d53				endm 
# End of macro NEXTW
2d53			 
2d53			 
2d53			.MALLOC: 
2d53				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2d53 56				db WORD_SYS_CORE+66             
2d54 7c 2d			dw .MALLOC2            
2d56 06				db 5 + 1 
2d57 .. 00			db "ALLOT",0              
2d5d				endm 
# End of macro CWHEAD
2d5d			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d5d					if DEBUG_FORTH_WORDS_KEY 
2d5d						DMARK "ALL" 
2d5d f5				push af  
2d5e 3a 72 2d			ld a, (.dmark)  
2d61 32 6e fe			ld (debug_mark),a  
2d64 3a 73 2d			ld a, (.dmark+1)  
2d67 32 6f fe			ld (debug_mark+1),a  
2d6a 3a 74 2d			ld a, (.dmark+2)  
2d6d 32 70 fe			ld (debug_mark+2),a  
2d70 18 03			jr .pastdmark  
2d72 ..			.dmark: db "ALL"  
2d75 f1			.pastdmark: pop af  
2d76			endm  
# End of macro DMARK
2d76						CALLMONITOR 
2d76 cd fb 19			call break_point_state  
2d79				endm  
# End of macro CALLMONITOR
2d79					endif 
2d79 c3 a3 2d				jp .mallocc 
2d7c			.MALLOC2: 
2d7c				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2d7c 56				db WORD_SYS_CORE+66             
2d7d ba 2d			dw .FREE            
2d7f 07				db 6 + 1 
2d80 .. 00			db "MALLOC",0              
2d87				endm 
# End of macro CWHEAD
2d87			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d87					; get byte count 
2d87					if DEBUG_FORTH_WORDS_KEY 
2d87						DMARK "MAL" 
2d87 f5				push af  
2d88 3a 9c 2d			ld a, (.dmark)  
2d8b 32 6e fe			ld (debug_mark),a  
2d8e 3a 9d 2d			ld a, (.dmark+1)  
2d91 32 6f fe			ld (debug_mark+1),a  
2d94 3a 9e 2d			ld a, (.dmark+2)  
2d97 32 70 fe			ld (debug_mark+2),a  
2d9a 18 03			jr .pastdmark  
2d9c ..			.dmark: db "MAL"  
2d9f f1			.pastdmark: pop af  
2da0			endm  
# End of macro DMARK
2da0						CALLMONITOR 
2da0 cd fb 19			call break_point_state  
2da3				endm  
# End of macro CALLMONITOR
2da3					endif 
2da3			.mallocc: 
2da3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2da3 cd ea 22			call macro_dsp_valuehl 
2da6				endm 
# End of macro FORTH_DSP_VALUEHL
2da6			 
2da6			;		push hl 
2da6			 
2da6					; destroy value TOS 
2da6			 
2da6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2da6 cd a2 23			call macro_forth_dsp_pop 
2da9				endm 
# End of macro FORTH_DSP_POP
2da9			 
2da9			;		pop hl 
2da9 cd 4d 14				call malloc 
2dac				if DEBUG_FORTH_MALLOC_GUARD 
2dac f5					push af 
2dad cd af 0f				call ishlzero 
2db0			;		ld a, l 
2db0			;		add h 
2db0			;		cp 0 
2db0 f1					pop af 
2db1					 
2db1 cc be 5d				call z,malloc_error 
2db4				endif 
2db4			 
2db4 cd f3 20				call forth_push_numhl 
2db7					NEXTW 
2db7 c3 a0 24			jp macro_next 
2dba				endm 
# End of macro NEXTW
2dba			 
2dba			.FREE: 
2dba				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2dba 57				db WORD_SYS_CORE+67             
2dbb eb 2d			dw .LIST            
2dbd 05				db 4 + 1 
2dbe .. 00			db "FREE",0              
2dc3				endm 
# End of macro CWHEAD
2dc3			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2dc3					if DEBUG_FORTH_WORDS_KEY 
2dc3						DMARK "FRE" 
2dc3 f5				push af  
2dc4 3a d8 2d			ld a, (.dmark)  
2dc7 32 6e fe			ld (debug_mark),a  
2dca 3a d9 2d			ld a, (.dmark+1)  
2dcd 32 6f fe			ld (debug_mark+1),a  
2dd0 3a da 2d			ld a, (.dmark+2)  
2dd3 32 70 fe			ld (debug_mark+2),a  
2dd6 18 03			jr .pastdmark  
2dd8 ..			.dmark: db "FRE"  
2ddb f1			.pastdmark: pop af  
2ddc			endm  
# End of macro DMARK
2ddc						CALLMONITOR 
2ddc cd fb 19			call break_point_state  
2ddf				endm  
# End of macro CALLMONITOR
2ddf					endif 
2ddf					; get address 
2ddf			 
2ddf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ddf cd ea 22			call macro_dsp_valuehl 
2de2				endm 
# End of macro FORTH_DSP_VALUEHL
2de2			 
2de2			;		push hl 
2de2			 
2de2					; destroy value TOS 
2de2			 
2de2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2de2 cd a2 23			call macro_forth_dsp_pop 
2de5				endm 
# End of macro FORTH_DSP_POP
2de5			 
2de5			;		pop hl 
2de5			if FORTH_ENABLE_MALLOCFREE 
2de5 cd 17 15				call free 
2de8			endif 
2de8					NEXTW 
2de8 c3 a0 24			jp macro_next 
2deb				endm 
# End of macro NEXTW
2deb			.LIST: 
2deb				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2deb 5c				db WORD_SYS_CORE+72             
2dec d9 2f			dw .FORGET            
2dee 05				db 4 + 1 
2def .. 00			db "LIST",0              
2df4				endm 
# End of macro CWHEAD
2df4			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2df4			; | | The quoted word must be in upper case. 
2df4				if DEBUG_FORTH_WORDS_KEY 
2df4					DMARK "LST" 
2df4 f5				push af  
2df5 3a 09 2e			ld a, (.dmark)  
2df8 32 6e fe			ld (debug_mark),a  
2dfb 3a 0a 2e			ld a, (.dmark+1)  
2dfe 32 6f fe			ld (debug_mark+1),a  
2e01 3a 0b 2e			ld a, (.dmark+2)  
2e04 32 70 fe			ld (debug_mark+2),a  
2e07 18 03			jr .pastdmark  
2e09 ..			.dmark: db "LST"  
2e0c f1			.pastdmark: pop af  
2e0d			endm  
# End of macro DMARK
2e0d					CALLMONITOR 
2e0d cd fb 19			call break_point_state  
2e10				endm  
# End of macro CALLMONITOR
2e10				endif 
2e10			 
2e10					FORTH_DSP_VALUEHL 
2e10 cd ea 22			call macro_dsp_valuehl 
2e13				endm 
# End of macro FORTH_DSP_VALUEHL
2e13			 
2e13 e5					push hl 
2e14					FORTH_DSP_POP 
2e14 cd a2 23			call macro_forth_dsp_pop 
2e17				endm 
# End of macro FORTH_DSP_POP
2e17 c1					pop bc 
2e18			 
2e18			; Start format of scratch string 
2e18			 
2e18 21 c4 f1				ld hl, scratch 
2e1b			 
2e1b 3e 3a				ld a, ':' 
2e1d 77					ld (hl),a 
2e1e 23					inc hl 
2e1f 3e 20				ld a, ' ' 
2e21 77					ld (hl), a 
2e22			 
2e22					; Get ptr to the word we need to look up 
2e22			 
2e22			;		FORTH_DSP_VALUEHL 
2e22					;v5 FORTH_DSP_VALUE 
2e22				; TODO type check 
2e22			;		inc hl    ; Skip type check  
2e22			;		push hl 
2e22			;		ex de, hl    ; put into DE 
2e22			 
2e22			 
2e22 21 00 80				ld hl, baseram 
2e25					;ld hl, baseusermem 
2e25			 
2e25 e5			push hl   ; sacreifical push 
2e26			 
2e26			.ldouscanm: 
2e26 e1				pop hl 
2e27			.ldouscan: 
2e27				if DEBUG_FORTH_WORDS 
2e27					DMARK "LSs" 
2e27 f5				push af  
2e28 3a 3c 2e			ld a, (.dmark)  
2e2b 32 6e fe			ld (debug_mark),a  
2e2e 3a 3d 2e			ld a, (.dmark+1)  
2e31 32 6f fe			ld (debug_mark+1),a  
2e34 3a 3e 2e			ld a, (.dmark+2)  
2e37 32 70 fe			ld (debug_mark+2),a  
2e3a 18 03			jr .pastdmark  
2e3c ..			.dmark: db "LSs"  
2e3f f1			.pastdmark: pop af  
2e40			endm  
# End of macro DMARK
2e40					CALLMONITOR 
2e40 cd fb 19			call break_point_state  
2e43				endm  
# End of macro CALLMONITOR
2e43				endif 
2e43				; skip dict stub 
2e43 cd f1 25				call forth_tok_next 
2e46			 
2e46			 
2e46			; while we have words to look for 
2e46			 
2e46 7e				ld a, (hl)      
2e47				if DEBUG_FORTH_WORDS 
2e47					DMARK "LSk" 
2e47 f5				push af  
2e48 3a 5c 2e			ld a, (.dmark)  
2e4b 32 6e fe			ld (debug_mark),a  
2e4e 3a 5d 2e			ld a, (.dmark+1)  
2e51 32 6f fe			ld (debug_mark+1),a  
2e54 3a 5e 2e			ld a, (.dmark+2)  
2e57 32 70 fe			ld (debug_mark+2),a  
2e5a 18 03			jr .pastdmark  
2e5c ..			.dmark: db "LSk"  
2e5f f1			.pastdmark: pop af  
2e60			endm  
# End of macro DMARK
2e60					CALLMONITOR 
2e60 cd fb 19			call break_point_state  
2e63				endm  
# End of macro CALLMONITOR
2e63				endif 
2e63					;cp WORD_SYS_END 
2e63					;jp z, .lunotfound 
2e63			 
2e63					; if we hit non uwords then gone too far 
2e63 fe 01				cp WORD_SYS_UWORD 
2e65 c2 95 2f				jp nz, .lunotfound 
2e68			 
2e68				if DEBUG_FORTH_WORDS 
2e68					DMARK "LSu" 
2e68 f5				push af  
2e69 3a 7d 2e			ld a, (.dmark)  
2e6c 32 6e fe			ld (debug_mark),a  
2e6f 3a 7e 2e			ld a, (.dmark+1)  
2e72 32 6f fe			ld (debug_mark+1),a  
2e75 3a 7f 2e			ld a, (.dmark+2)  
2e78 32 70 fe			ld (debug_mark+2),a  
2e7b 18 03			jr .pastdmark  
2e7d ..			.dmark: db "LSu"  
2e80 f1			.pastdmark: pop af  
2e81			endm  
# End of macro DMARK
2e81					CALLMONITOR 
2e81 cd fb 19			call break_point_state  
2e84				endm  
# End of macro CALLMONITOR
2e84				endif 
2e84			 
2e84					; found a uword but is it the one we want... 
2e84			 
2e84 c5					push bc     ; uword to find is on bc 
2e85 d1					pop de 
2e86			 
2e86 e5					push hl  ; to save the ptr 
2e87			 
2e87					; skip opcode 
2e87 23					inc hl  
2e88					; skip next ptr 
2e88 23					inc hl  
2e89 23					inc hl 
2e8a					; skip len 
2e8a 23					inc hl 
2e8b			 
2e8b				if DEBUG_FORTH_WORDS 
2e8b					DMARK "LSc" 
2e8b f5				push af  
2e8c 3a a0 2e			ld a, (.dmark)  
2e8f 32 6e fe			ld (debug_mark),a  
2e92 3a a1 2e			ld a, (.dmark+1)  
2e95 32 6f fe			ld (debug_mark+1),a  
2e98 3a a2 2e			ld a, (.dmark+2)  
2e9b 32 70 fe			ld (debug_mark+2),a  
2e9e 18 03			jr .pastdmark  
2ea0 ..			.dmark: db "LSc"  
2ea3 f1			.pastdmark: pop af  
2ea4			endm  
# End of macro DMARK
2ea4					CALLMONITOR 
2ea4 cd fb 19			call break_point_state  
2ea7				endm  
# End of macro CALLMONITOR
2ea7				endif 
2ea7 cd 1c 14				call strcmp 
2eaa c2 26 2e				jp nz, .ldouscanm 
2ead				 
2ead			 
2ead			 
2ead					; we have a uword so push its name to the stack 
2ead			 
2ead			;	   	push hl  ; save so we can move to next dict block 
2ead e1			pop hl 
2eae			 
2eae				if DEBUG_FORTH_WORDS 
2eae					DMARK "LSm" 
2eae f5				push af  
2eaf 3a c3 2e			ld a, (.dmark)  
2eb2 32 6e fe			ld (debug_mark),a  
2eb5 3a c4 2e			ld a, (.dmark+1)  
2eb8 32 6f fe			ld (debug_mark+1),a  
2ebb 3a c5 2e			ld a, (.dmark+2)  
2ebe 32 70 fe			ld (debug_mark+2),a  
2ec1 18 03			jr .pastdmark  
2ec3 ..			.dmark: db "LSm"  
2ec6 f1			.pastdmark: pop af  
2ec7			endm  
# End of macro DMARK
2ec7					CALLMONITOR 
2ec7 cd fb 19			call break_point_state  
2eca				endm  
# End of macro CALLMONITOR
2eca				endif 
2eca			 
2eca					; skip opcode 
2eca 23					inc hl  
2ecb					; skip next ptr 
2ecb 23					inc hl  
2ecc 23					inc hl 
2ecd					; skip len 
2ecd 7e					ld a, (hl)   ; save length to add 
2ece				if DEBUG_FORTH_WORDS 
2ece					DMARK "LS2" 
2ece f5				push af  
2ecf 3a e3 2e			ld a, (.dmark)  
2ed2 32 6e fe			ld (debug_mark),a  
2ed5 3a e4 2e			ld a, (.dmark+1)  
2ed8 32 6f fe			ld (debug_mark+1),a  
2edb 3a e5 2e			ld a, (.dmark+2)  
2ede 32 70 fe			ld (debug_mark+2),a  
2ee1 18 03			jr .pastdmark  
2ee3 ..			.dmark: db "LS2"  
2ee6 f1			.pastdmark: pop af  
2ee7			endm  
# End of macro DMARK
2ee7					CALLMONITOR 
2ee7 cd fb 19			call break_point_state  
2eea				endm  
# End of macro CALLMONITOR
2eea				endif 
2eea			 
2eea					; save this location 
2eea				 
2eea e5					push hl 
2eeb			 
2eeb 23					inc hl 
2eec 11 c6 f1				ld de, scratch+2 
2eef 4f					ld c, a 
2ef0 06 00				ld b, 0 
2ef2			 
2ef2				if DEBUG_FORTH_WORDS 
2ef2					DMARK "LSn" 
2ef2 f5				push af  
2ef3 3a 07 2f			ld a, (.dmark)  
2ef6 32 6e fe			ld (debug_mark),a  
2ef9 3a 08 2f			ld a, (.dmark+1)  
2efc 32 6f fe			ld (debug_mark+1),a  
2eff 3a 09 2f			ld a, (.dmark+2)  
2f02 32 70 fe			ld (debug_mark+2),a  
2f05 18 03			jr .pastdmark  
2f07 ..			.dmark: db "LSn"  
2f0a f1			.pastdmark: pop af  
2f0b			endm  
# End of macro DMARK
2f0b					CALLMONITOR 
2f0b cd fb 19			call break_point_state  
2f0e				endm  
# End of macro CALLMONITOR
2f0e				endif 
2f0e			 
2f0e					; copy uword name to scratch 
2f0e			 
2f0e ed b0				ldir 
2f10			 
2f10 1b					dec de 
2f11 3e 20				ld a, ' '    ; change null to space 
2f13 12					ld (de), a 
2f14			 
2f14 13					inc de 
2f15			 
2f15 d5					push de 
2f16 c1					pop bc     ; move scratch pointer to end of word name and save it 
2f17			 
2f17 e1					pop hl 
2f18 7e					ld a, (hl) 
2f19					;inc hl 
2f19					; skip word string 
2f19 cd 86 0f				call addatohl 
2f1c			 
2f1c 23					inc hl 
2f1d			 
2f1d				if DEBUG_FORTH_WORDS 
2f1d					DMARK "LS3" 
2f1d f5				push af  
2f1e 3a 32 2f			ld a, (.dmark)  
2f21 32 6e fe			ld (debug_mark),a  
2f24 3a 33 2f			ld a, (.dmark+1)  
2f27 32 6f fe			ld (debug_mark+1),a  
2f2a 3a 34 2f			ld a, (.dmark+2)  
2f2d 32 70 fe			ld (debug_mark+2),a  
2f30 18 03			jr .pastdmark  
2f32 ..			.dmark: db "LS3"  
2f35 f1			.pastdmark: pop af  
2f36			endm  
# End of macro DMARK
2f36					CALLMONITOR 
2f36 cd fb 19			call break_point_state  
2f39				endm  
# End of macro CALLMONITOR
2f39				endif 
2f39					; should now be at the start of the machine code to setup the eval of the uword 
2f39					; now locate the ptr to the string defintion 
2f39			 
2f39					; skip ld hl, 
2f39					; then load the ptr 
2f39			; TODO use get from hl ptr 
2f39 23					inc hl 
2f3a 5e					ld e, (hl) 
2f3b 23					inc hl 
2f3c 56					ld d, (hl) 
2f3d eb					ex de, hl 
2f3e			 
2f3e			 
2f3e				if DEBUG_FORTH_WORDS 
2f3e					DMARK "LSt" 
2f3e f5				push af  
2f3f 3a 53 2f			ld a, (.dmark)  
2f42 32 6e fe			ld (debug_mark),a  
2f45 3a 54 2f			ld a, (.dmark+1)  
2f48 32 6f fe			ld (debug_mark+1),a  
2f4b 3a 55 2f			ld a, (.dmark+2)  
2f4e 32 70 fe			ld (debug_mark+2),a  
2f51 18 03			jr .pastdmark  
2f53 ..			.dmark: db "LSt"  
2f56 f1			.pastdmark: pop af  
2f57			endm  
# End of macro DMARK
2f57					CALLMONITOR 
2f57 cd fb 19			call break_point_state  
2f5a				endm  
# End of macro CALLMONITOR
2f5a				endif 
2f5a			 
2f5a			; cant push right now due to tokenised strings  
2f5a			 
2f5a			; get the destination of where to copy this definition to. 
2f5a			 
2f5a c5					push bc 
2f5b d1					pop de 
2f5c			 
2f5c 7e			.listl:         ld a,(hl) 
2f5d fe 00				cp 0 
2f5f 28 09				jr z, .lreplsp     ; replace zero with space 
2f61					;cp FORTH_END_BUFFER 
2f61 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2f63 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2f65				 
2f65					; just copy this char as is then 
2f65			 
2f65 12					ld (de), a 
2f66			 
2f66 23			.listnxt:	inc hl 
2f67 13					inc de 
2f68 18 f2				jr .listl 
2f6a			 
2f6a 3e 20		.lreplsp:	ld a,' ' 
2f6c 12					ld (de), a 
2f6d 18 f7				jr .listnxt 
2f6f			 
2f6f			; close up uword def 
2f6f			 
2f6f			.listdone: 
2f6f 12					ld (de), a 
2f70 13					inc de 
2f71 3e 00				ld a, 0 
2f73 12					ld (de), a 
2f74			 
2f74			; now have def so clean up and push to stack 
2f74			 
2f74 21 c4 f1				ld hl, scratch 
2f77				if DEBUG_FORTH_WORDS 
2f77					DMARK "Ltp" 
2f77 f5				push af  
2f78 3a 8c 2f			ld a, (.dmark)  
2f7b 32 6e fe			ld (debug_mark),a  
2f7e 3a 8d 2f			ld a, (.dmark+1)  
2f81 32 6f fe			ld (debug_mark+1),a  
2f84 3a 8e 2f			ld a, (.dmark+2)  
2f87 32 70 fe			ld (debug_mark+2),a  
2f8a 18 03			jr .pastdmark  
2f8c ..			.dmark: db "Ltp"  
2f8f f1			.pastdmark: pop af  
2f90			endm  
# End of macro DMARK
2f90					CALLMONITOR 
2f90 cd fb 19			call break_point_state  
2f93				endm  
# End of macro CALLMONITOR
2f93				endif 
2f93			 
2f93 18 1f			jr .listpush 
2f95			 
2f95			;.lnuword:	pop hl 
2f95			;		call forth_tok_next 
2f95			;		jp .ldouscan  
2f95			 
2f95			.lunotfound:		  
2f95			 
2f95				if DEBUG_FORTH_WORDS 
2f95					DMARK "LSn" 
2f95 f5				push af  
2f96 3a aa 2f			ld a, (.dmark)  
2f99 32 6e fe			ld (debug_mark),a  
2f9c 3a ab 2f			ld a, (.dmark+1)  
2f9f 32 6f fe			ld (debug_mark+1),a  
2fa2 3a ac 2f			ld a, (.dmark+2)  
2fa5 32 70 fe			ld (debug_mark+2),a  
2fa8 18 03			jr .pastdmark  
2faa ..			.dmark: db "LSn"  
2fad f1			.pastdmark: pop af  
2fae			endm  
# End of macro DMARK
2fae					CALLMONITOR 
2fae cd fb 19			call break_point_state  
2fb1				endm  
# End of macro CALLMONITOR
2fb1				endif 
2fb1			 
2fb1					 
2fb1			;		FORTH_DSP_POP 
2fb1			;		ld hl, .luno 
2fb1			 
2fb1					NEXTW			 
2fb1 c3 a0 24			jp macro_next 
2fb4				endm 
# End of macro NEXTW
2fb4			 
2fb4			.listpush: 
2fb4				if DEBUG_FORTH_WORDS 
2fb4					DMARK "LS>" 
2fb4 f5				push af  
2fb5 3a c9 2f			ld a, (.dmark)  
2fb8 32 6e fe			ld (debug_mark),a  
2fbb 3a ca 2f			ld a, (.dmark+1)  
2fbe 32 6f fe			ld (debug_mark+1),a  
2fc1 3a cb 2f			ld a, (.dmark+2)  
2fc4 32 70 fe			ld (debug_mark+2),a  
2fc7 18 03			jr .pastdmark  
2fc9 ..			.dmark: db "LS>"  
2fcc f1			.pastdmark: pop af  
2fcd			endm  
# End of macro DMARK
2fcd					CALLMONITOR 
2fcd cd fb 19			call break_point_state  
2fd0				endm  
# End of macro CALLMONITOR
2fd0				endif 
2fd0 cd 61 21				call forth_push_str 
2fd3			 
2fd3			 
2fd3			 
2fd3					NEXTW 
2fd3 c3 a0 24			jp macro_next 
2fd6				endm 
# End of macro NEXTW
2fd6			 
2fd6			;.luno:    db "Word not found",0 
2fd6			 
2fd6			 
2fd6			 
2fd6			 
2fd6			 
2fd6			;		push hl   ; save pointer to start of uword def string 
2fd6			; 
2fd6			;; look for FORTH_EOL_LINE 
2fd6			;		ld a, FORTH_END_BUFFER 
2fd6			;		call strlent 
2fd6			; 
2fd6			;		inc hl		 ; space for coln def 
2fd6			;		inc hl 
2fd6			;		inc hl          ; space for terms 
2fd6			;		inc hl 
2fd6			; 
2fd6			;		ld a, 20   ; TODO get actual length 
2fd6			;		call addatohl    ; include a random amount of room for the uword name 
2fd6			; 
2fd6			;		 
2fd6			;	if DEBUG_FORTH_WORDS 
2fd6			;		DMARK "Lt1" 
2fd6			;		CALLMONITOR 
2fd6			;	endif 
2fd6			;		 
2fd6			; 
2fd6			;; malloc space for the string because we cant change it 
2fd6			; 
2fd6			;		call malloc 
2fd6			;	if DEBUG_FORTH_MALLOC_GUARD 
2fd6			;		push af 
2fd6			;		call ishlzero 
2fd6			;		pop af 
2fd6			;		 
2fd6			;		call z,malloc_error 
2fd6			;	endif 
2fd6			; 
2fd6			;	if DEBUG_FORTH_WORDS 
2fd6			;		DMARK "Lt2" 
2fd6			;		CALLMONITOR 
2fd6			;	endif 
2fd6			;		pop de 
2fd6			;		push hl    ; push the malloc to release later 
2fd6			;		push hl   ;  push back a copy for the later stack push 
2fd6			;		 
2fd6			;; copy the string swapping out the zero terms for spaces 
2fd6			; 
2fd6			;		; de has our source 
2fd6			;		; hl has our dest 
2fd6			; 
2fd6			;; add the coln def 
2fd6			; 
2fd6			;		ld a, ':' 
2fd6			;		ld (hl), a 
2fd6			;		inc hl 
2fd6			;		ld a, ' ' 
2fd6			;		ld (hl), a 
2fd6			;		inc hl 
2fd6			; 
2fd6			;; add the uname word 
2fd6			;		push de   ; save our string for now 
2fd6			;		ex de, hl 
2fd6			; 
2fd6			;		FORTH_DSP_VALUE 
2fd6			;		;v5 FORTH_DSP_VALUE 
2fd6			; 
2fd6			;		inc hl   ; skip type but we know by now this is OK 
2fd6			; 
2fd6			;.luword:	ld a,(hl) 
2fd6			;		cp 0 
2fd6			;		jr z, .luword2 
2fd6			;		ld (de), a 
2fd6			;		inc de 
2fd6			;		inc hl 
2fd6			;		jr .luword 
2fd6			; 
2fd6			;.luword2:	ld a, ' ' 
2fd6			;		ld (de), a 
2fd6			;;		inc hl 
2fd6			;;		inc de 
2fd6			;;		ld (de), a 
2fd6			;;		inc hl 
2fd6			;		inc de 
2fd6			; 
2fd6			;		ex de, hl 
2fd6			;		pop de 
2fd6			;		 
2fd6			;		 
2fd6			; 
2fd6			;; detoken that string and copy it 
2fd6			; 
2fd6			;	if DEBUG_FORTH_WORDS 
2fd6			;		DMARK "Lt2" 
2fd6			;		CALLMONITOR 
2fd6			;	endif 
2fd6			;.ldetok:	ld a, (de) 
2fd6			;		cp FORTH_END_BUFFER 
2fd6			;		jr z, .ldetokend 
2fd6			;		; swap out any zero term for space 
2fd6			;		cp 0 
2fd6			;		jr nz, .ldetoknext 
2fd6			;		ld a, ' ' 
2fd6			; 
2fd6			;	if DEBUG_FORTH_WORDS 
2fd6			;		DMARK "LtS" 
2fd6			;		CALLMONITOR 
2fd6			;	endif 
2fd6			;.ldetoknext:	ld (hl), a 
2fd6			;		inc de 
2fd6			;		inc hl 
2fd6			;		jr .ldetok 
2fd6			; 
2fd6			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2fd6			;		ld (hl), a  
2fd6			; 
2fd6			;; free that temp malloc 
2fd6			; 
2fd6			;		pop hl    
2fd6			; 
2fd6			;	if DEBUG_FORTH_WORDS 
2fd6			;		DMARK "Lt4" 
2fd6			;		CALLMONITOR 
2fd6			;	endif 
2fd6			;		call forth_apushstrhl 
2fd6			; 
2fd6			;		; get rid of temp malloc area 
2fd6			; 
2fd6			;		pop hl 
2fd6			;		call free 
2fd6			; 
2fd6			;		jr .ludone 
2fd6			; 
2fd6			;.lnuword:	pop hl 
2fd6			;		call forth_tok_next 
2fd6			;		jp .ldouscan  
2fd6			; 
2fd6			;.ludone:		 pop hl 
2fd6			; 
2fd6					NEXTW 
2fd6 c3 a0 24			jp macro_next 
2fd9				endm 
# End of macro NEXTW
2fd9			 
2fd9			.FORGET: 
2fd9				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2fd9 5d				db WORD_SYS_CORE+73             
2fda 52 30			dw .NOP            
2fdc 07				db 6 + 1 
2fdd .. 00			db "FORGET",0              
2fe4				endm 
# End of macro CWHEAD
2fe4			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2fe4			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2fe4			; | |  
2fe4			; | | e.g. "MORE" forget 
2fe4					if DEBUG_FORTH_WORDS_KEY 
2fe4						DMARK "FRG" 
2fe4 f5				push af  
2fe5 3a f9 2f			ld a, (.dmark)  
2fe8 32 6e fe			ld (debug_mark),a  
2feb 3a fa 2f			ld a, (.dmark+1)  
2fee 32 6f fe			ld (debug_mark+1),a  
2ff1 3a fb 2f			ld a, (.dmark+2)  
2ff4 32 70 fe			ld (debug_mark+2),a  
2ff7 18 03			jr .pastdmark  
2ff9 ..			.dmark: db "FRG"  
2ffc f1			.pastdmark: pop af  
2ffd			endm  
# End of macro DMARK
2ffd						CALLMONITOR 
2ffd cd fb 19			call break_point_state  
3000				endm  
# End of macro CALLMONITOR
3000					endif 
3000			 
3000				; find uword 
3000			        ; update start of word with "_" 
3000				; replace uword with deleted flag 
3000			 
3000			 
3000			;	if DEBUG_FORTH_WORDS 
3000			;		DMARK "FOG" 
3000			;		CALLMONITOR 
3000			;	endif 
3000			 
3000			 
3000					; Get ptr to the word we need to look up 
3000			 
3000					FORTH_DSP_VALUEHL 
3000 cd ea 22			call macro_dsp_valuehl 
3003				endm 
# End of macro FORTH_DSP_VALUEHL
3003					;v5 FORTH_DSP_VALUE 
3003				; TODO type check 
3003			;		inc hl    ; Skip type check  
3003 e5					push hl 
3004 c1					pop bc 
3005			;		ex de, hl    ; put into DE 
3005			 
3005			 
3005 21 00 80				ld hl, baseram 
3008					;ld hl, baseusermem 
3008			 
3008				; skip dict stub 
3008			;	call forth_tok_next 
3008 e5			push hl   ; sacreifical push 
3009			 
3009			.fldouscanm: 
3009 e1				pop hl 
300a			.fldouscan: 
300a			;	if DEBUG_FORTH_WORDS 
300a			;		DMARK "LSs" 
300a			;		CALLMONITOR 
300a			;	endif 
300a				; skip dict stub 
300a cd f1 25				call forth_tok_next 
300d			 
300d			 
300d			; while we have words to look for 
300d			 
300d 7e				ld a, (hl)      
300e			;	if DEBUG_FORTH_WORDS 
300e			;		DMARK "LSk" 
300e			;		CALLMONITOR 
300e			;	endif 
300e fe 00				cp WORD_SYS_END 
3010 ca 4c 30				jp z, .flunotfound 
3013 fe 01				cp WORD_SYS_UWORD 
3015 c2 0a 30				jp nz, .fldouscan 
3018			 
3018			;	if DEBUG_FORTH_WORDS 
3018			;		DMARK "LSu" 
3018			;		CALLMONITOR 
3018			;	endif 
3018			 
3018					; found a uword but is it the one we want... 
3018			 
3018 c5					push bc     ; uword to find is on bc 
3019 d1					pop de 
301a			 
301a e5					push hl  ; to save the ptr 
301b			 
301b					; skip opcode 
301b 23					inc hl  
301c					; skip next ptr 
301c 23					inc hl  
301d 23					inc hl 
301e					; skip len 
301e 23					inc hl 
301f			 
301f			;	if DEBUG_FORTH_WORDS 
301f			;		DMARK "LSc" 
301f			;		CALLMONITOR 
301f			;	endif 
301f cd 1c 14				call strcmp 
3022 c2 09 30				jp nz, .fldouscanm 
3025			; 
3025			; 
3025			;; while we have words to look for 
3025			; 
3025			;.fdouscan:	ld a, (hl)      
3025			;	if DEBUG_FORTH_WORDS 
3025			;		DMARK "LSs" 
3025			;		CALLMONITOR 
3025			;	endif 
3025			;		cp WORD_SYS_END 
3025			;		jp z, .fudone 
3025			;		cp WORD_SYS_UWORD 
3025			;		jp nz, .fnuword 
3025			; 
3025			;	if DEBUG_FORTH_WORDS 
3025			;		DMARK "FGu" 
3025			;		CALLMONITOR 
3025			;	endif 
3025			; 
3025			;		; found a uword but is it the one we want... 
3025			; 
3025			; 
3025			;	        pop de   ; get back the dsp name 
3025			;		push de 
3025			; 
3025			;		push hl  ; to save the ptr 
3025			; 
3025			;		; skip opcode 
3025			;		inc hl  
3025			;		; skip next ptr 
3025			;		inc hl  
3025			;		inc hl 
3025			;		; skip len 
3025			;		inc hl 
3025			; 
3025			;	if DEBUG_FORTH_WORDS 
3025			;		DMARK "FGc" 
3025			;		CALLMONITOR 
3025			;	endif 
3025			;		call strcmp 
3025			;		jp nz, .fnuword 
3025			 
3025			 
3025 e1			pop hl 
3026			 
3026				 
3026				if DEBUG_FORTH_WORDS 
3026					DMARK "FGm" 
3026 f5				push af  
3027 3a 3b 30			ld a, (.dmark)  
302a 32 6e fe			ld (debug_mark),a  
302d 3a 3c 30			ld a, (.dmark+1)  
3030 32 6f fe			ld (debug_mark+1),a  
3033 3a 3d 30			ld a, (.dmark+2)  
3036 32 70 fe			ld (debug_mark+2),a  
3039 18 03			jr .pastdmark  
303b ..			.dmark: db "FGm"  
303e f1			.pastdmark: pop af  
303f			endm  
# End of macro DMARK
303f					CALLMONITOR 
303f cd fb 19			call break_point_state  
3042				endm  
# End of macro CALLMONITOR
3042				endif 
3042			 
3042			 
3042			 
3042					; we have a uword so push its name to the stack 
3042			 
3042			;	   	push hl  ; save so we can move to next dict block 
3042			;pop hl 
3042			 
3042					; update opcode to deleted 
3042 3e 03				ld a, WORD_SYS_DELETED 
3044 77					ld (hl), a 
3045			 
3045 23					inc hl  
3046					; skip next ptr 
3046 23					inc hl  
3047 23					inc hl 
3048					; skip len 
3048 23					inc hl 
3049			 
3049					; TODO change parser to skip deleted words but for now mark it out 
3049 3e 5f				ld a, "_" 
304b 77					ld  (hl),a 
304c			 
304c			;		jr .fudone 
304c			; 
304c			;.fnuword:	pop hl 
304c			;		call forth_tok_next 
304c			;		jp .fdouscan  
304c			 
304c			.flunotfound:		  
304c			 
304c			 
304c					 
304c					FORTH_DSP_POP 
304c cd a2 23			call macro_forth_dsp_pop 
304f				endm 
# End of macro FORTH_DSP_POP
304f			;		ld hl, .luno 
304f			;.fudone:		 pop hl 
304f					NEXTW 
304f c3 a0 24			jp macro_next 
3052				endm 
# End of macro NEXTW
3052			.NOP: 
3052				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
3052 61				db WORD_SYS_CORE+77             
3053 79 30			dw .COMO            
3055 04				db 3 + 1 
3056 .. 00			db "NOP",0              
305a				endm 
# End of macro CWHEAD
305a			; | NOP (  --  ) Do nothing | DONE 
305a					if DEBUG_FORTH_WORDS_KEY 
305a						DMARK "NOP" 
305a f5				push af  
305b 3a 6f 30			ld a, (.dmark)  
305e 32 6e fe			ld (debug_mark),a  
3061 3a 70 30			ld a, (.dmark+1)  
3064 32 6f fe			ld (debug_mark+1),a  
3067 3a 71 30			ld a, (.dmark+2)  
306a 32 70 fe			ld (debug_mark+2),a  
306d 18 03			jr .pastdmark  
306f ..			.dmark: db "NOP"  
3072 f1			.pastdmark: pop af  
3073			endm  
# End of macro DMARK
3073						CALLMONITOR 
3073 cd fb 19			call break_point_state  
3076				endm  
# End of macro CALLMONITOR
3076					endif 
3076				       NEXTW 
3076 c3 a0 24			jp macro_next 
3079				endm 
# End of macro NEXTW
3079			.COMO: 
3079				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
3079 6e				db WORD_SYS_CORE+90             
307a cb 30			dw .COMC            
307c 02				db 1 + 1 
307d .. 00			db "(",0              
307f				endm 
# End of macro CWHEAD
307f			; | ( ( -- )  Start of comment | DONE 
307f			 
307f			 
307f 2a c5 f4				ld hl, ( os_tok_ptr) 
3082 11 c6 30			ld de, .closepar 
3085					 
3085					if DEBUG_FORTH_WORDS 
3085						DMARK ").." 
3085 f5				push af  
3086 3a 9a 30			ld a, (.dmark)  
3089 32 6e fe			ld (debug_mark),a  
308c 3a 9b 30			ld a, (.dmark+1)  
308f 32 6f fe			ld (debug_mark+1),a  
3092 3a 9c 30			ld a, (.dmark+2)  
3095 32 70 fe			ld (debug_mark+2),a  
3098 18 03			jr .pastdmark  
309a ..			.dmark: db ").."  
309d f1			.pastdmark: pop af  
309e			endm  
# End of macro DMARK
309e						CALLMONITOR 
309e cd fb 19			call break_point_state  
30a1				endm  
# End of macro CALLMONITOR
30a1					endif 
30a1 cd bb 25			call findnexttok  
30a4			 
30a4					if DEBUG_FORTH_WORDS 
30a4						DMARK "IF5" 
30a4 f5				push af  
30a5 3a b9 30			ld a, (.dmark)  
30a8 32 6e fe			ld (debug_mark),a  
30ab 3a ba 30			ld a, (.dmark+1)  
30ae 32 6f fe			ld (debug_mark+1),a  
30b1 3a bb 30			ld a, (.dmark+2)  
30b4 32 70 fe			ld (debug_mark+2),a  
30b7 18 03			jr .pastdmark  
30b9 ..			.dmark: db "IF5"  
30bc f1			.pastdmark: pop af  
30bd			endm  
# End of macro DMARK
30bd						CALLMONITOR 
30bd cd fb 19			call break_point_state  
30c0				endm  
# End of macro CALLMONITOR
30c0					endif 
30c0				; replace below with ) exec using tok_ptr 
30c0 22 c5 f4			ld (os_tok_ptr), hl 
30c3 c3 31 25			jp exec1 
30c6			 
30c6 .. 00			.closepar:   db ")",0 
30c8			 
30c8				       NEXTW 
30c8 c3 a0 24			jp macro_next 
30cb				endm 
# End of macro NEXTW
30cb			.COMC: 
30cb				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
30cb 6f				db WORD_SYS_CORE+91             
30cc d4 30			dw .SCRATCH            
30ce 02				db 1 + 1 
30cf .. 00			db ")",0              
30d1				endm 
# End of macro CWHEAD
30d1			; | ) ( -- )  End of comment |  DONE  
30d1				       NEXTW 
30d1 c3 a0 24			jp macro_next 
30d4				endm 
# End of macro NEXTW
30d4			 
30d4			.SCRATCH: 
30d4				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
30d4 6f				db WORD_SYS_CORE+91             
30d5 0f 31			dw .INC            
30d7 08				db 7 + 1 
30d8 .. 00			db "SCRATCH",0              
30e0				endm 
# End of macro CWHEAD
30e0			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
30e0			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
30e0			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
30e0			; | |  
30e0			; | | e.g.    : score $00 scratch ; 
30e0			; | |  
30e0			; | | $00 score ! 
30e0			; | | $01 score +! 
30e0			; | |  
30e0			; | | e.g.   : varword $0a scratch ;  
30e0			; | | 
30e0			; | | $8000 varword ! 
30e0					if DEBUG_FORTH_WORDS_KEY 
30e0						DMARK "SCR" 
30e0 f5				push af  
30e1 3a f5 30			ld a, (.dmark)  
30e4 32 6e fe			ld (debug_mark),a  
30e7 3a f6 30			ld a, (.dmark+1)  
30ea 32 6f fe			ld (debug_mark+1),a  
30ed 3a f7 30			ld a, (.dmark+2)  
30f0 32 70 fe			ld (debug_mark+2),a  
30f3 18 03			jr .pastdmark  
30f5 ..			.dmark: db "SCR"  
30f8 f1			.pastdmark: pop af  
30f9			endm  
# End of macro DMARK
30f9						CALLMONITOR 
30f9 cd fb 19			call break_point_state  
30fc				endm  
# End of macro CALLMONITOR
30fc					endif 
30fc			 
30fc					FORTH_DSP_VALUEHL 
30fc cd ea 22			call macro_dsp_valuehl 
30ff				endm 
# End of macro FORTH_DSP_VALUEHL
30ff				 
30ff					FORTH_DSP_POP 
30ff cd a2 23			call macro_forth_dsp_pop 
3102				endm 
# End of macro FORTH_DSP_POP
3102			 
3102 7d					ld a, l 
3103 21 e9 f6				ld hl, os_var_array 
3106 cd 86 0f				call addatohl 
3109			 
3109 cd f3 20				call forth_push_numhl 
310c			 
310c				       NEXTW 
310c c3 a0 24			jp macro_next 
310f				endm 
# End of macro NEXTW
310f			 
310f			.INC: 
310f				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
310f 6f				db WORD_SYS_CORE+91             
3110 63 31			dw .DEC            
3112 03				db 2 + 1 
3113 .. 00			db "+!",0              
3116				endm 
# End of macro CWHEAD
3116			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
3116					if DEBUG_FORTH_WORDS_KEY 
3116						DMARK "+s_" 
3116 f5				push af  
3117 3a 2b 31			ld a, (.dmark)  
311a 32 6e fe			ld (debug_mark),a  
311d 3a 2c 31			ld a, (.dmark+1)  
3120 32 6f fe			ld (debug_mark+1),a  
3123 3a 2d 31			ld a, (.dmark+2)  
3126 32 70 fe			ld (debug_mark+2),a  
3129 18 03			jr .pastdmark  
312b ..			.dmark: db "+s_"  
312e f1			.pastdmark: pop af  
312f			endm  
# End of macro DMARK
312f						CALLMONITOR 
312f cd fb 19			call break_point_state  
3132				endm  
# End of macro CALLMONITOR
3132					endif 
3132			 
3132					FORTH_DSP_VALUEHL 
3132 cd ea 22			call macro_dsp_valuehl 
3135				endm 
# End of macro FORTH_DSP_VALUEHL
3135			 
3135 e5					push hl   ; save address 
3136			 
3136					FORTH_DSP_POP 
3136 cd a2 23			call macro_forth_dsp_pop 
3139				endm 
# End of macro FORTH_DSP_POP
3139			 
3139					FORTH_DSP_VALUEHL 
3139 cd ea 22			call macro_dsp_valuehl 
313c				endm 
# End of macro FORTH_DSP_VALUEHL
313c			 
313c					FORTH_DSP_POP 
313c cd a2 23			call macro_forth_dsp_pop 
313f				endm 
# End of macro FORTH_DSP_POP
313f			 
313f					; hl contains value to add to byte at a 
313f				 
313f eb					ex de, hl 
3140			 
3140 e1					pop hl 
3141			 
3141					if DEBUG_FORTH_WORDS 
3141						DMARK "INC" 
3141 f5				push af  
3142 3a 56 31			ld a, (.dmark)  
3145 32 6e fe			ld (debug_mark),a  
3148 3a 57 31			ld a, (.dmark+1)  
314b 32 6f fe			ld (debug_mark+1),a  
314e 3a 58 31			ld a, (.dmark+2)  
3151 32 70 fe			ld (debug_mark+2),a  
3154 18 03			jr .pastdmark  
3156 ..			.dmark: db "INC"  
3159 f1			.pastdmark: pop af  
315a			endm  
# End of macro DMARK
315a						CALLMONITOR 
315a cd fb 19			call break_point_state  
315d				endm  
# End of macro CALLMONITOR
315d					endif 
315d			 
315d 7e					ld a,(hl) 
315e 83					add e 
315f 77					ld (hl),a 
3160			 
3160			 
3160			 
3160				       NEXTW 
3160 c3 a0 24			jp macro_next 
3163				endm 
# End of macro NEXTW
3163			 
3163			.DEC: 
3163				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
3163 6f				db WORD_SYS_CORE+91             
3164 b4 31			dw .INC2            
3166 03				db 2 + 1 
3167 .. 00			db "-!",0              
316a				endm 
# End of macro CWHEAD
316a			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
316a					if DEBUG_FORTH_WORDS_KEY 
316a						DMARK "-s_" 
316a f5				push af  
316b 3a 7f 31			ld a, (.dmark)  
316e 32 6e fe			ld (debug_mark),a  
3171 3a 80 31			ld a, (.dmark+1)  
3174 32 6f fe			ld (debug_mark+1),a  
3177 3a 81 31			ld a, (.dmark+2)  
317a 32 70 fe			ld (debug_mark+2),a  
317d 18 03			jr .pastdmark  
317f ..			.dmark: db "-s_"  
3182 f1			.pastdmark: pop af  
3183			endm  
# End of macro DMARK
3183						CALLMONITOR 
3183 cd fb 19			call break_point_state  
3186				endm  
# End of macro CALLMONITOR
3186					endif 
3186			 
3186					FORTH_DSP_VALUEHL 
3186 cd ea 22			call macro_dsp_valuehl 
3189				endm 
# End of macro FORTH_DSP_VALUEHL
3189			 
3189 e5					push hl   ; save address 
318a			 
318a					FORTH_DSP_POP 
318a cd a2 23			call macro_forth_dsp_pop 
318d				endm 
# End of macro FORTH_DSP_POP
318d			 
318d					FORTH_DSP_VALUEHL 
318d cd ea 22			call macro_dsp_valuehl 
3190				endm 
# End of macro FORTH_DSP_VALUEHL
3190			 
3190					; hl contains value to add to byte at a 
3190				 
3190 eb					ex de, hl 
3191			 
3191 e1					pop hl 
3192			 
3192					if DEBUG_FORTH_WORDS 
3192						DMARK "DEC" 
3192 f5				push af  
3193 3a a7 31			ld a, (.dmark)  
3196 32 6e fe			ld (debug_mark),a  
3199 3a a8 31			ld a, (.dmark+1)  
319c 32 6f fe			ld (debug_mark+1),a  
319f 3a a9 31			ld a, (.dmark+2)  
31a2 32 70 fe			ld (debug_mark+2),a  
31a5 18 03			jr .pastdmark  
31a7 ..			.dmark: db "DEC"  
31aa f1			.pastdmark: pop af  
31ab			endm  
# End of macro DMARK
31ab						CALLMONITOR 
31ab cd fb 19			call break_point_state  
31ae				endm  
# End of macro CALLMONITOR
31ae					endif 
31ae			 
31ae 7e					ld a,(hl) 
31af 93					sub e 
31b0 77					ld (hl),a 
31b1			 
31b1			 
31b1			 
31b1				       NEXTW 
31b1 c3 a0 24			jp macro_next 
31b4				endm 
# End of macro NEXTW
31b4			 
31b4			.INC2: 
31b4				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
31b4 6f				db WORD_SYS_CORE+91             
31b5 5e 32			dw .DEC2            
31b7 04				db 3 + 1 
31b8 .. 00			db "+2!",0              
31bc				endm 
# End of macro CWHEAD
31bc			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
31bc			 
31bc					if DEBUG_FORTH_WORDS_KEY 
31bc						DMARK "+2s" 
31bc f5				push af  
31bd 3a d1 31			ld a, (.dmark)  
31c0 32 6e fe			ld (debug_mark),a  
31c3 3a d2 31			ld a, (.dmark+1)  
31c6 32 6f fe			ld (debug_mark+1),a  
31c9 3a d3 31			ld a, (.dmark+2)  
31cc 32 70 fe			ld (debug_mark+2),a  
31cf 18 03			jr .pastdmark  
31d1 ..			.dmark: db "+2s"  
31d4 f1			.pastdmark: pop af  
31d5			endm  
# End of macro DMARK
31d5						CALLMONITOR 
31d5 cd fb 19			call break_point_state  
31d8				endm  
# End of macro CALLMONITOR
31d8					endif 
31d8			 
31d8					; Address 
31d8			 
31d8					FORTH_DSP_VALUEHL 
31d8 cd ea 22			call macro_dsp_valuehl 
31db				endm 
# End of macro FORTH_DSP_VALUEHL
31db			 
31db e5					push hl    ; save address 
31dc			 
31dc					; load content into de 
31dc			 
31dc 5e					ld e,(hl) 
31dd 23					inc hl 
31de 56					ld d, (hl) 
31df			 
31df					if DEBUG_FORTH_WORDS 
31df						DMARK "+2a" 
31df f5				push af  
31e0 3a f4 31			ld a, (.dmark)  
31e3 32 6e fe			ld (debug_mark),a  
31e6 3a f5 31			ld a, (.dmark+1)  
31e9 32 6f fe			ld (debug_mark+1),a  
31ec 3a f6 31			ld a, (.dmark+2)  
31ef 32 70 fe			ld (debug_mark+2),a  
31f2 18 03			jr .pastdmark  
31f4 ..			.dmark: db "+2a"  
31f7 f1			.pastdmark: pop af  
31f8			endm  
# End of macro DMARK
31f8						CALLMONITOR 
31f8 cd fb 19			call break_point_state  
31fb				endm  
# End of macro CALLMONITOR
31fb					endif 
31fb			 
31fb					FORTH_DSP_POP 
31fb cd a2 23			call macro_forth_dsp_pop 
31fe				endm 
# End of macro FORTH_DSP_POP
31fe			 
31fe					; Get value to add 
31fe			 
31fe					FORTH_DSP_VALUE 
31fe cd d3 22			call macro_forth_dsp_value 
3201				endm 
# End of macro FORTH_DSP_VALUE
3201			 
3201					if DEBUG_FORTH_WORDS 
3201						DMARK "+2v" 
3201 f5				push af  
3202 3a 16 32			ld a, (.dmark)  
3205 32 6e fe			ld (debug_mark),a  
3208 3a 17 32			ld a, (.dmark+1)  
320b 32 6f fe			ld (debug_mark+1),a  
320e 3a 18 32			ld a, (.dmark+2)  
3211 32 70 fe			ld (debug_mark+2),a  
3214 18 03			jr .pastdmark  
3216 ..			.dmark: db "+2v"  
3219 f1			.pastdmark: pop af  
321a			endm  
# End of macro DMARK
321a						CALLMONITOR 
321a cd fb 19			call break_point_state  
321d				endm  
# End of macro CALLMONITOR
321d					endif 
321d			 
321d 19					add hl, de 
321e			 
321e					if DEBUG_FORTH_WORDS 
321e						DMARK "+2+" 
321e f5				push af  
321f 3a 33 32			ld a, (.dmark)  
3222 32 6e fe			ld (debug_mark),a  
3225 3a 34 32			ld a, (.dmark+1)  
3228 32 6f fe			ld (debug_mark+1),a  
322b 3a 35 32			ld a, (.dmark+2)  
322e 32 70 fe			ld (debug_mark+2),a  
3231 18 03			jr .pastdmark  
3233 ..			.dmark: db "+2+"  
3236 f1			.pastdmark: pop af  
3237			endm  
# End of macro DMARK
3237						CALLMONITOR 
3237 cd fb 19			call break_point_state  
323a				endm  
# End of macro CALLMONITOR
323a					endif 
323a			 
323a					; move result to de 
323a			 
323a eb					ex de, hl 
323b			 
323b					; Address 
323b			 
323b e1					pop hl 
323c			 
323c					; save it back 
323c			 
323c 73					ld (hl), e 
323d 23					inc hl 
323e 72					ld (hl), d 
323f			 
323f					if DEBUG_FORTH_WORDS 
323f						DMARK "+2e" 
323f f5				push af  
3240 3a 54 32			ld a, (.dmark)  
3243 32 6e fe			ld (debug_mark),a  
3246 3a 55 32			ld a, (.dmark+1)  
3249 32 6f fe			ld (debug_mark+1),a  
324c 3a 56 32			ld a, (.dmark+2)  
324f 32 70 fe			ld (debug_mark+2),a  
3252 18 03			jr .pastdmark  
3254 ..			.dmark: db "+2e"  
3257 f1			.pastdmark: pop af  
3258			endm  
# End of macro DMARK
3258						CALLMONITOR 
3258 cd fb 19			call break_point_state  
325b				endm  
# End of macro CALLMONITOR
325b					endif 
325b			 
325b			 
325b			 
325b			 
325b			 
325b				       NEXTW 
325b c3 a0 24			jp macro_next 
325e				endm 
# End of macro NEXTW
325e			 
325e			.DEC2: 
325e				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
325e 6f				db WORD_SYS_CORE+91             
325f 0a 33			dw .GET2            
3261 04				db 3 + 1 
3262 .. 00			db "-2!",0              
3266				endm 
# End of macro CWHEAD
3266			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
3266			 
3266			 
3266					if DEBUG_FORTH_WORDS_KEY 
3266						DMARK "-2s" 
3266 f5				push af  
3267 3a 7b 32			ld a, (.dmark)  
326a 32 6e fe			ld (debug_mark),a  
326d 3a 7c 32			ld a, (.dmark+1)  
3270 32 6f fe			ld (debug_mark+1),a  
3273 3a 7d 32			ld a, (.dmark+2)  
3276 32 70 fe			ld (debug_mark+2),a  
3279 18 03			jr .pastdmark  
327b ..			.dmark: db "-2s"  
327e f1			.pastdmark: pop af  
327f			endm  
# End of macro DMARK
327f						CALLMONITOR 
327f cd fb 19			call break_point_state  
3282				endm  
# End of macro CALLMONITOR
3282					endif 
3282			 
3282					; Address 
3282			 
3282					FORTH_DSP_VALUEHL 
3282 cd ea 22			call macro_dsp_valuehl 
3285				endm 
# End of macro FORTH_DSP_VALUEHL
3285			 
3285 e5					push hl    ; save address 
3286			 
3286					; load content into de 
3286			 
3286 5e					ld e,(hl) 
3287 23					inc hl 
3288 56					ld d, (hl) 
3289			 
3289					if DEBUG_FORTH_WORDS 
3289						DMARK "-2a" 
3289 f5				push af  
328a 3a 9e 32			ld a, (.dmark)  
328d 32 6e fe			ld (debug_mark),a  
3290 3a 9f 32			ld a, (.dmark+1)  
3293 32 6f fe			ld (debug_mark+1),a  
3296 3a a0 32			ld a, (.dmark+2)  
3299 32 70 fe			ld (debug_mark+2),a  
329c 18 03			jr .pastdmark  
329e ..			.dmark: db "-2a"  
32a1 f1			.pastdmark: pop af  
32a2			endm  
# End of macro DMARK
32a2						CALLMONITOR 
32a2 cd fb 19			call break_point_state  
32a5				endm  
# End of macro CALLMONITOR
32a5					endif 
32a5			 
32a5					FORTH_DSP_POP 
32a5 cd a2 23			call macro_forth_dsp_pop 
32a8				endm 
# End of macro FORTH_DSP_POP
32a8			 
32a8					; Get value to remove 
32a8			 
32a8					FORTH_DSP_VALUE 
32a8 cd d3 22			call macro_forth_dsp_value 
32ab				endm 
# End of macro FORTH_DSP_VALUE
32ab			 
32ab					if DEBUG_FORTH_WORDS 
32ab						DMARK "-2v" 
32ab f5				push af  
32ac 3a c0 32			ld a, (.dmark)  
32af 32 6e fe			ld (debug_mark),a  
32b2 3a c1 32			ld a, (.dmark+1)  
32b5 32 6f fe			ld (debug_mark+1),a  
32b8 3a c2 32			ld a, (.dmark+2)  
32bb 32 70 fe			ld (debug_mark+2),a  
32be 18 03			jr .pastdmark  
32c0 ..			.dmark: db "-2v"  
32c3 f1			.pastdmark: pop af  
32c4			endm  
# End of macro DMARK
32c4						CALLMONITOR 
32c4 cd fb 19			call break_point_state  
32c7				endm  
# End of macro CALLMONITOR
32c7					endif 
32c7			 
32c7 eb					ex de, hl 
32c8 ed 52				sbc hl, de 
32ca			 
32ca					if DEBUG_FORTH_WORDS 
32ca						DMARK "-2d" 
32ca f5				push af  
32cb 3a df 32			ld a, (.dmark)  
32ce 32 6e fe			ld (debug_mark),a  
32d1 3a e0 32			ld a, (.dmark+1)  
32d4 32 6f fe			ld (debug_mark+1),a  
32d7 3a e1 32			ld a, (.dmark+2)  
32da 32 70 fe			ld (debug_mark+2),a  
32dd 18 03			jr .pastdmark  
32df ..			.dmark: db "-2d"  
32e2 f1			.pastdmark: pop af  
32e3			endm  
# End of macro DMARK
32e3						CALLMONITOR 
32e3 cd fb 19			call break_point_state  
32e6				endm  
# End of macro CALLMONITOR
32e6					endif 
32e6			 
32e6					; move result to de 
32e6			 
32e6 eb					ex de, hl 
32e7			 
32e7					; Address 
32e7			 
32e7 e1					pop hl 
32e8			 
32e8					; save it back 
32e8			 
32e8 73					ld (hl), e 
32e9 23					inc hl 
32ea 72					ld (hl), d 
32eb			 
32eb					if DEBUG_FORTH_WORDS 
32eb						DMARK "-2e" 
32eb f5				push af  
32ec 3a 00 33			ld a, (.dmark)  
32ef 32 6e fe			ld (debug_mark),a  
32f2 3a 01 33			ld a, (.dmark+1)  
32f5 32 6f fe			ld (debug_mark+1),a  
32f8 3a 02 33			ld a, (.dmark+2)  
32fb 32 70 fe			ld (debug_mark+2),a  
32fe 18 03			jr .pastdmark  
3300 ..			.dmark: db "-2e"  
3303 f1			.pastdmark: pop af  
3304			endm  
# End of macro DMARK
3304						CALLMONITOR 
3304 cd fb 19			call break_point_state  
3307				endm  
# End of macro CALLMONITOR
3307					endif 
3307			 
3307			 
3307			 
3307			 
3307			 
3307				       NEXTW 
3307 c3 a0 24			jp macro_next 
330a				endm 
# End of macro NEXTW
330a			.GET2: 
330a				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
330a 6f				db WORD_SYS_CORE+91             
330b 3a 33			dw .BANG2            
330d 03				db 2 + 1 
330e .. 00			db "2@",0              
3311				endm 
# End of macro CWHEAD
3311			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3311					if DEBUG_FORTH_WORDS_KEY 
3311						DMARK "2A_" 
3311 f5				push af  
3312 3a 26 33			ld a, (.dmark)  
3315 32 6e fe			ld (debug_mark),a  
3318 3a 27 33			ld a, (.dmark+1)  
331b 32 6f fe			ld (debug_mark+1),a  
331e 3a 28 33			ld a, (.dmark+2)  
3321 32 70 fe			ld (debug_mark+2),a  
3324 18 03			jr .pastdmark  
3326 ..			.dmark: db "2A_"  
3329 f1			.pastdmark: pop af  
332a			endm  
# End of macro DMARK
332a						CALLMONITOR 
332a cd fb 19			call break_point_state  
332d				endm  
# End of macro CALLMONITOR
332d					endif 
332d			 
332d					FORTH_DSP_VALUEHL 
332d cd ea 22			call macro_dsp_valuehl 
3330				endm 
# End of macro FORTH_DSP_VALUEHL
3330			 
3330 5e					ld e, (hl) 
3331 23					inc hl 
3332 56					ld d, (hl) 
3333			 
3333 eb					ex de, hl 
3334			 
3334 cd f3 20				call forth_push_numhl 
3337			 
3337				       NEXTW 
3337 c3 a0 24			jp macro_next 
333a				endm 
# End of macro NEXTW
333a			.BANG2: 
333a				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
333a 6f				db WORD_SYS_CORE+91             
333b 72 33			dw .CONFIG            
333d 03				db 2 + 1 
333e .. 00			db "2!",0              
3341				endm 
# End of macro CWHEAD
3341			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3341					if DEBUG_FORTH_WORDS_KEY 
3341						DMARK "2S_" 
3341 f5				push af  
3342 3a 56 33			ld a, (.dmark)  
3345 32 6e fe			ld (debug_mark),a  
3348 3a 57 33			ld a, (.dmark+1)  
334b 32 6f fe			ld (debug_mark+1),a  
334e 3a 58 33			ld a, (.dmark+2)  
3351 32 70 fe			ld (debug_mark+2),a  
3354 18 03			jr .pastdmark  
3356 ..			.dmark: db "2S_"  
3359 f1			.pastdmark: pop af  
335a			endm  
# End of macro DMARK
335a						CALLMONITOR 
335a cd fb 19			call break_point_state  
335d				endm  
# End of macro CALLMONITOR
335d					endif 
335d			 
335d					FORTH_DSP_VALUEHL 
335d cd ea 22			call macro_dsp_valuehl 
3360				endm 
# End of macro FORTH_DSP_VALUEHL
3360			 
3360 e5					push hl   ; save address 
3361			 
3361			 
3361					FORTH_DSP_POP 
3361 cd a2 23			call macro_forth_dsp_pop 
3364				endm 
# End of macro FORTH_DSP_POP
3364			 
3364					 
3364					FORTH_DSP_VALUEHL 
3364 cd ea 22			call macro_dsp_valuehl 
3367				endm 
# End of macro FORTH_DSP_VALUEHL
3367			 
3367					FORTH_DSP_POP 
3367 cd a2 23			call macro_forth_dsp_pop 
336a				endm 
# End of macro FORTH_DSP_POP
336a			 
336a eb					ex de, hl    ; value now in de 
336b			 
336b e1					pop hl 
336c			 
336c 73					ld (hl), e 
336d			 
336d 23					inc hl 
336e			 
336e 72					ld (hl), d 
336f			 
336f			 
336f				       NEXTW 
336f c3 a0 24			jp macro_next 
3372				endm 
# End of macro NEXTW
3372			.CONFIG: 
3372				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
3372 6f				db WORD_SYS_CORE+91             
3373 83 33			dw .ENDCORE            
3375 07				db 6 + 1 
3376 .. 00			db "CONFIG",0              
337d				endm 
# End of macro CWHEAD
337d			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
337d			 
337d cd 10 16				call config 
3380					NEXTW 
3380 c3 a0 24			jp macro_next 
3383				endm 
# End of macro NEXTW
3383			.ENDCORE: 
3383			 
3383			; eof 
3383			 
3383			 
# End of file forth_words_core.asm
3383			include "forth_words_flow.asm" 
3383			 
3383			; | ## Program Flow Words 
3383			 
3383			.IF: 
3383				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
3383 1e				db WORD_SYS_CORE+10             
3384 78 34			dw .THEN            
3386 03				db 2 + 1 
3387 .. 00			db "IF",0              
338a				endm 
# End of macro CWHEAD
338a			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
338a			; 
338a					if DEBUG_FORTH_WORDS_KEY 
338a						DMARK "IF." 
338a f5				push af  
338b 3a 9f 33			ld a, (.dmark)  
338e 32 6e fe			ld (debug_mark),a  
3391 3a a0 33			ld a, (.dmark+1)  
3394 32 6f fe			ld (debug_mark+1),a  
3397 3a a1 33			ld a, (.dmark+2)  
339a 32 70 fe			ld (debug_mark+2),a  
339d 18 03			jr .pastdmark  
339f ..			.dmark: db "IF."  
33a2 f1			.pastdmark: pop af  
33a3			endm  
# End of macro DMARK
33a3						CALLMONITOR 
33a3 cd fb 19			call break_point_state  
33a6				endm  
# End of macro CALLMONITOR
33a6					endif 
33a6			; eval TOS 
33a6			 
33a6				FORTH_DSP_VALUEHL 
33a6 cd ea 22			call macro_dsp_valuehl 
33a9				endm 
# End of macro FORTH_DSP_VALUEHL
33a9			 
33a9			;	push hl 
33a9				FORTH_DSP_POP 
33a9 cd a2 23			call macro_forth_dsp_pop 
33ac				endm 
# End of macro FORTH_DSP_POP
33ac			;	pop hl 
33ac			 
33ac					if DEBUG_FORTH_WORDS 
33ac						DMARK "IF1" 
33ac f5				push af  
33ad 3a c1 33			ld a, (.dmark)  
33b0 32 6e fe			ld (debug_mark),a  
33b3 3a c2 33			ld a, (.dmark+1)  
33b6 32 6f fe			ld (debug_mark+1),a  
33b9 3a c3 33			ld a, (.dmark+2)  
33bc 32 70 fe			ld (debug_mark+2),a  
33bf 18 03			jr .pastdmark  
33c1 ..			.dmark: db "IF1"  
33c4 f1			.pastdmark: pop af  
33c5			endm  
# End of macro DMARK
33c5						CALLMONITOR 
33c5 cd fb 19			call break_point_state  
33c8				endm  
# End of macro CALLMONITOR
33c8					endif 
33c8 b7				or a        ; clear carry flag 
33c9 11 00 00			ld de, 0 
33cc eb				ex de,hl 
33cd ed 52			sbc hl, de 
33cf c2 59 34			jp nz, .iftrue 
33d2			 
33d2					if DEBUG_FORTH_WORDS 
33d2						DMARK "IF2" 
33d2 f5				push af  
33d3 3a e7 33			ld a, (.dmark)  
33d6 32 6e fe			ld (debug_mark),a  
33d9 3a e8 33			ld a, (.dmark+1)  
33dc 32 6f fe			ld (debug_mark+1),a  
33df 3a e9 33			ld a, (.dmark+2)  
33e2 32 70 fe			ld (debug_mark+2),a  
33e5 18 03			jr .pastdmark  
33e7 ..			.dmark: db "IF2"  
33ea f1			.pastdmark: pop af  
33eb			endm  
# End of macro DMARK
33eb						CALLMONITOR 
33eb cd fb 19			call break_point_state  
33ee				endm  
# End of macro CALLMONITOR
33ee					endif 
33ee			 
33ee			; if not true then skip to THEN 
33ee			 
33ee				; TODO get tok_ptr 
33ee				; TODO consume toks until we get to THEN 
33ee			 
33ee 2a c5 f4			ld hl, (os_tok_ptr) 
33f1					if DEBUG_FORTH_WORDS 
33f1						DMARK "IF3" 
33f1 f5				push af  
33f2 3a 06 34			ld a, (.dmark)  
33f5 32 6e fe			ld (debug_mark),a  
33f8 3a 07 34			ld a, (.dmark+1)  
33fb 32 6f fe			ld (debug_mark+1),a  
33fe 3a 08 34			ld a, (.dmark+2)  
3401 32 70 fe			ld (debug_mark+2),a  
3404 18 03			jr .pastdmark  
3406 ..			.dmark: db "IF3"  
3409 f1			.pastdmark: pop af  
340a			endm  
# End of macro DMARK
340a						CALLMONITOR 
340a cd fb 19			call break_point_state  
340d				endm  
# End of macro CALLMONITOR
340d						 
340d					endif 
340d 11 54 34			ld de, .ifthen 
3410					if DEBUG_FORTH_WORDS 
3410						DMARK "IF4" 
3410 f5				push af  
3411 3a 25 34			ld a, (.dmark)  
3414 32 6e fe			ld (debug_mark),a  
3417 3a 26 34			ld a, (.dmark+1)  
341a 32 6f fe			ld (debug_mark+1),a  
341d 3a 27 34			ld a, (.dmark+2)  
3420 32 70 fe			ld (debug_mark+2),a  
3423 18 03			jr .pastdmark  
3425 ..			.dmark: db "IF4"  
3428 f1			.pastdmark: pop af  
3429			endm  
# End of macro DMARK
3429						CALLMONITOR 
3429 cd fb 19			call break_point_state  
342c				endm  
# End of macro CALLMONITOR
342c					endif 
342c cd bb 25			call findnexttok  
342f			 
342f					if DEBUG_FORTH_WORDS 
342f						DMARK "IF5" 
342f f5				push af  
3430 3a 44 34			ld a, (.dmark)  
3433 32 6e fe			ld (debug_mark),a  
3436 3a 45 34			ld a, (.dmark+1)  
3439 32 6f fe			ld (debug_mark+1),a  
343c 3a 46 34			ld a, (.dmark+2)  
343f 32 70 fe			ld (debug_mark+2),a  
3442 18 03			jr .pastdmark  
3444 ..			.dmark: db "IF5"  
3447 f1			.pastdmark: pop af  
3448			endm  
# End of macro DMARK
3448						CALLMONITOR 
3448 cd fb 19			call break_point_state  
344b				endm  
# End of macro CALLMONITOR
344b					endif 
344b				; TODO replace below with ; exec using tok_ptr 
344b 22 c5 f4			ld (os_tok_ptr), hl 
344e c3 31 25			jp exec1 
3451				NEXTW 
3451 c3 a0 24			jp macro_next 
3454				endm 
# End of macro NEXTW
3454			 
3454 .. 00		.ifthen:  db "THEN",0 
3459			 
3459			.iftrue:		 
3459				; Exec next words normally 
3459			 
3459				; if true then exec following IF as normal 
3459					if DEBUG_FORTH_WORDS 
3459						DMARK "IFT" 
3459 f5				push af  
345a 3a 6e 34			ld a, (.dmark)  
345d 32 6e fe			ld (debug_mark),a  
3460 3a 6f 34			ld a, (.dmark+1)  
3463 32 6f fe			ld (debug_mark+1),a  
3466 3a 70 34			ld a, (.dmark+2)  
3469 32 70 fe			ld (debug_mark+2),a  
346c 18 03			jr .pastdmark  
346e ..			.dmark: db "IFT"  
3471 f1			.pastdmark: pop af  
3472			endm  
# End of macro DMARK
3472						CALLMONITOR 
3472 cd fb 19			call break_point_state  
3475				endm  
# End of macro CALLMONITOR
3475					endif 
3475			 
3475					NEXTW 
3475 c3 a0 24			jp macro_next 
3478				endm 
# End of macro NEXTW
3478			.THEN: 
3478				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3478 1f				db WORD_SYS_CORE+11             
3479 a0 34			dw .ELSE            
347b 05				db 4 + 1 
347c .. 00			db "THEN",0              
3481				endm 
# End of macro CWHEAD
3481			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3481					if DEBUG_FORTH_WORDS_KEY 
3481						DMARK "THN" 
3481 f5				push af  
3482 3a 96 34			ld a, (.dmark)  
3485 32 6e fe			ld (debug_mark),a  
3488 3a 97 34			ld a, (.dmark+1)  
348b 32 6f fe			ld (debug_mark+1),a  
348e 3a 98 34			ld a, (.dmark+2)  
3491 32 70 fe			ld (debug_mark+2),a  
3494 18 03			jr .pastdmark  
3496 ..			.dmark: db "THN"  
3499 f1			.pastdmark: pop af  
349a			endm  
# End of macro DMARK
349a						CALLMONITOR 
349a cd fb 19			call break_point_state  
349d				endm  
# End of macro CALLMONITOR
349d					endif 
349d					NEXTW 
349d c3 a0 24			jp macro_next 
34a0				endm 
# End of macro NEXTW
34a0			.ELSE: 
34a0				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
34a0 20				db WORD_SYS_CORE+12             
34a1 c8 34			dw .DO            
34a3 03				db 2 + 1 
34a4 .. 00			db "ELSE",0              
34a9				endm 
# End of macro CWHEAD
34a9			; | ELSE ( -- ) Not supported - does nothing | TODO 
34a9			 
34a9					if DEBUG_FORTH_WORDS_KEY 
34a9						DMARK "ELS" 
34a9 f5				push af  
34aa 3a be 34			ld a, (.dmark)  
34ad 32 6e fe			ld (debug_mark),a  
34b0 3a bf 34			ld a, (.dmark+1)  
34b3 32 6f fe			ld (debug_mark+1),a  
34b6 3a c0 34			ld a, (.dmark+2)  
34b9 32 70 fe			ld (debug_mark+2),a  
34bc 18 03			jr .pastdmark  
34be ..			.dmark: db "ELS"  
34c1 f1			.pastdmark: pop af  
34c2			endm  
# End of macro DMARK
34c2						CALLMONITOR 
34c2 cd fb 19			call break_point_state  
34c5				endm  
# End of macro CALLMONITOR
34c5					endif 
34c5			 
34c5			 
34c5					NEXTW 
34c5 c3 a0 24			jp macro_next 
34c8				endm 
# End of macro NEXTW
34c8			.DO: 
34c8				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
34c8 21				db WORD_SYS_CORE+13             
34c9 ef 35			dw .LOOP            
34cb 03				db 2 + 1 
34cc .. 00			db "DO",0              
34cf				endm 
# End of macro CWHEAD
34cf			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
34cf			 
34cf					if DEBUG_FORTH_WORDS_KEY 
34cf						DMARK "DO." 
34cf f5				push af  
34d0 3a e4 34			ld a, (.dmark)  
34d3 32 6e fe			ld (debug_mark),a  
34d6 3a e5 34			ld a, (.dmark+1)  
34d9 32 6f fe			ld (debug_mark+1),a  
34dc 3a e6 34			ld a, (.dmark+2)  
34df 32 70 fe			ld (debug_mark+2),a  
34e2 18 03			jr .pastdmark  
34e4 ..			.dmark: db "DO."  
34e7 f1			.pastdmark: pop af  
34e8			endm  
# End of macro DMARK
34e8						CALLMONITOR 
34e8 cd fb 19			call break_point_state  
34eb				endm  
# End of macro CALLMONITOR
34eb					endif 
34eb			;  push pc to rsp stack past the DO 
34eb			 
34eb 2a c5 f4				ld hl, (os_tok_ptr) 
34ee 23					inc hl   ; D 
34ef 23					inc hl  ; O 
34f0 23					inc hl   ; null 
34f1					if DEBUG_FORTH_WORDS 
34f1						DMARK "DO2" 
34f1 f5				push af  
34f2 3a 06 35			ld a, (.dmark)  
34f5 32 6e fe			ld (debug_mark),a  
34f8 3a 07 35			ld a, (.dmark+1)  
34fb 32 6f fe			ld (debug_mark+1),a  
34fe 3a 08 35			ld a, (.dmark+2)  
3501 32 70 fe			ld (debug_mark+2),a  
3504 18 03			jr .pastdmark  
3506 ..			.dmark: db "DO2"  
3509 f1			.pastdmark: pop af  
350a			endm  
# End of macro DMARK
350a						CALLMONITOR 
350a cd fb 19			call break_point_state  
350d				endm  
# End of macro CALLMONITOR
350d					endif 
350d					FORTH_RSP_NEXT 
350d cd 9a 20			call macro_forth_rsp_next 
3510				endm 
# End of macro FORTH_RSP_NEXT
3510					if DEBUG_FORTH_WORDS 
3510						DMARK "DO3" 
3510 f5				push af  
3511 3a 25 35			ld a, (.dmark)  
3514 32 6e fe			ld (debug_mark),a  
3517 3a 26 35			ld a, (.dmark+1)  
351a 32 6f fe			ld (debug_mark+1),a  
351d 3a 27 35			ld a, (.dmark+2)  
3520 32 70 fe			ld (debug_mark+2),a  
3523 18 03			jr .pastdmark  
3525 ..			.dmark: db "DO3"  
3528 f1			.pastdmark: pop af  
3529			endm  
# End of macro DMARK
3529						CALLMONITOR 
3529 cd fb 19			call break_point_state  
352c				endm  
# End of macro CALLMONITOR
352c					endif 
352c			 
352c					;if DEBUG_FORTH_WORDS 
352c				;		push hl 
352c			;		endif  
352c			 
352c			; get counters from data stack 
352c			 
352c			 
352c					FORTH_DSP_VALUEHL 
352c cd ea 22			call macro_dsp_valuehl 
352f				endm 
# End of macro FORTH_DSP_VALUEHL
352f e5					push hl		 ; hl now has starting counter which needs to be tos 
3530			 
3530					if DEBUG_FORTH_WORDS 
3530						DMARK "DO4" 
3530 f5				push af  
3531 3a 45 35			ld a, (.dmark)  
3534 32 6e fe			ld (debug_mark),a  
3537 3a 46 35			ld a, (.dmark+1)  
353a 32 6f fe			ld (debug_mark+1),a  
353d 3a 47 35			ld a, (.dmark+2)  
3540 32 70 fe			ld (debug_mark+2),a  
3543 18 03			jr .pastdmark  
3545 ..			.dmark: db "DO4"  
3548 f1			.pastdmark: pop af  
3549			endm  
# End of macro DMARK
3549						CALLMONITOR 
3549 cd fb 19			call break_point_state  
354c				endm  
# End of macro CALLMONITOR
354c					endif 
354c					FORTH_DSP_POP 
354c cd a2 23			call macro_forth_dsp_pop 
354f				endm 
# End of macro FORTH_DSP_POP
354f			 
354f					if DEBUG_FORTH_WORDS 
354f						DMARK "DO5" 
354f f5				push af  
3550 3a 64 35			ld a, (.dmark)  
3553 32 6e fe			ld (debug_mark),a  
3556 3a 65 35			ld a, (.dmark+1)  
3559 32 6f fe			ld (debug_mark+1),a  
355c 3a 66 35			ld a, (.dmark+2)  
355f 32 70 fe			ld (debug_mark+2),a  
3562 18 03			jr .pastdmark  
3564 ..			.dmark: db "DO5"  
3567 f1			.pastdmark: pop af  
3568			endm  
# End of macro DMARK
3568						CALLMONITOR 
3568 cd fb 19			call break_point_state  
356b				endm  
# End of macro CALLMONITOR
356b					endif 
356b			 
356b					FORTH_DSP_VALUEHL 
356b cd ea 22			call macro_dsp_valuehl 
356e				endm 
# End of macro FORTH_DSP_VALUEHL
356e			;		push hl		 ; hl now has starting limit counter 
356e			 
356e					if DEBUG_FORTH_WORDS 
356e						DMARK "DO6" 
356e f5				push af  
356f 3a 83 35			ld a, (.dmark)  
3572 32 6e fe			ld (debug_mark),a  
3575 3a 84 35			ld a, (.dmark+1)  
3578 32 6f fe			ld (debug_mark+1),a  
357b 3a 85 35			ld a, (.dmark+2)  
357e 32 70 fe			ld (debug_mark+2),a  
3581 18 03			jr .pastdmark  
3583 ..			.dmark: db "DO6"  
3586 f1			.pastdmark: pop af  
3587			endm  
# End of macro DMARK
3587						CALLMONITOR 
3587 cd fb 19			call break_point_state  
358a				endm  
# End of macro CALLMONITOR
358a					endif 
358a					FORTH_DSP_POP 
358a cd a2 23			call macro_forth_dsp_pop 
358d				endm 
# End of macro FORTH_DSP_POP
358d			 
358d			; put counters on the loop stack 
358d			 
358d			;		pop hl			 ; limit counter 
358d d1					pop de			; start counter 
358e			 
358e					; push limit counter 
358e			 
358e					if DEBUG_FORTH_WORDS 
358e						DMARK "DO7" 
358e f5				push af  
358f 3a a3 35			ld a, (.dmark)  
3592 32 6e fe			ld (debug_mark),a  
3595 3a a4 35			ld a, (.dmark+1)  
3598 32 6f fe			ld (debug_mark+1),a  
359b 3a a5 35			ld a, (.dmark+2)  
359e 32 70 fe			ld (debug_mark+2),a  
35a1 18 03			jr .pastdmark  
35a3 ..			.dmark: db "DO7"  
35a6 f1			.pastdmark: pop af  
35a7			endm  
# End of macro DMARK
35a7						CALLMONITOR 
35a7 cd fb 19			call break_point_state  
35aa				endm  
# End of macro CALLMONITOR
35aa					endif 
35aa					FORTH_LOOP_NEXT 
35aa cd 1b 23			call macro_forth_loop_next 
35ad				endm 
# End of macro FORTH_LOOP_NEXT
35ad			 
35ad					; push start counter 
35ad			 
35ad eb					ex de, hl 
35ae					if DEBUG_FORTH_WORDS 
35ae						DMARK "DO7" 
35ae f5				push af  
35af 3a c3 35			ld a, (.dmark)  
35b2 32 6e fe			ld (debug_mark),a  
35b5 3a c4 35			ld a, (.dmark+1)  
35b8 32 6f fe			ld (debug_mark+1),a  
35bb 3a c5 35			ld a, (.dmark+2)  
35be 32 70 fe			ld (debug_mark+2),a  
35c1 18 03			jr .pastdmark  
35c3 ..			.dmark: db "DO7"  
35c6 f1			.pastdmark: pop af  
35c7			endm  
# End of macro DMARK
35c7						CALLMONITOR 
35c7 cd fb 19			call break_point_state  
35ca				endm  
# End of macro CALLMONITOR
35ca					endif 
35ca					FORTH_LOOP_NEXT 
35ca cd 1b 23			call macro_forth_loop_next 
35cd				endm 
# End of macro FORTH_LOOP_NEXT
35cd			 
35cd			 
35cd					; init first round of I counter 
35cd			 
35cd 22 e9 f4				ld (os_current_i), hl 
35d0			 
35d0					if DEBUG_FORTH_WORDS 
35d0						DMARK "DO8" 
35d0 f5				push af  
35d1 3a e5 35			ld a, (.dmark)  
35d4 32 6e fe			ld (debug_mark),a  
35d7 3a e6 35			ld a, (.dmark+1)  
35da 32 6f fe			ld (debug_mark+1),a  
35dd 3a e7 35			ld a, (.dmark+2)  
35e0 32 70 fe			ld (debug_mark+2),a  
35e3 18 03			jr .pastdmark  
35e5 ..			.dmark: db "DO8"  
35e8 f1			.pastdmark: pop af  
35e9			endm  
# End of macro DMARK
35e9						CALLMONITOR 
35e9 cd fb 19			call break_point_state  
35ec				endm  
# End of macro CALLMONITOR
35ec					endif 
35ec			 
35ec					NEXTW 
35ec c3 a0 24			jp macro_next 
35ef				endm 
# End of macro NEXTW
35ef			.LOOP: 
35ef				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
35ef 22				db WORD_SYS_CORE+14             
35f0 07 37			dw .I            
35f2 05				db 4 + 1 
35f3 .. 00			db "LOOP",0              
35f8				endm 
# End of macro CWHEAD
35f8			; | LOOP ( -- ) Increment and test loop counter  | DONE 
35f8			 
35f8				; pop tos as current loop count to hl 
35f8			 
35f8				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
35f8			 
35f8				FORTH_LOOP_TOS 
35f8 cd 4e 23			call macro_forth_loop_tos 
35fb				endm 
# End of macro FORTH_LOOP_TOS
35fb e5				push hl 
35fc			 
35fc					if DEBUG_FORTH_WORDS_KEY 
35fc						DMARK "LOP" 
35fc f5				push af  
35fd 3a 11 36			ld a, (.dmark)  
3600 32 6e fe			ld (debug_mark),a  
3603 3a 12 36			ld a, (.dmark+1)  
3606 32 6f fe			ld (debug_mark+1),a  
3609 3a 13 36			ld a, (.dmark+2)  
360c 32 70 fe			ld (debug_mark+2),a  
360f 18 03			jr .pastdmark  
3611 ..			.dmark: db "LOP"  
3614 f1			.pastdmark: pop af  
3615			endm  
# End of macro DMARK
3615						CALLMONITOR 
3615 cd fb 19			call break_point_state  
3618				endm  
# End of macro CALLMONITOR
3618					endif 
3618				; next item on the stack is the limit. get it 
3618			 
3618			 
3618				FORTH_LOOP_POP 
3618 cd 58 23			call macro_forth_loop_pop 
361b				endm 
# End of macro FORTH_LOOP_POP
361b			 
361b				FORTH_LOOP_TOS 
361b cd 4e 23			call macro_forth_loop_tos 
361e				endm 
# End of macro FORTH_LOOP_TOS
361e			 
361e d1				pop de		 ; de = i, hl = limit 
361f			 
361f					if DEBUG_FORTH_WORDS 
361f						DMARK "LP1" 
361f f5				push af  
3620 3a 34 36			ld a, (.dmark)  
3623 32 6e fe			ld (debug_mark),a  
3626 3a 35 36			ld a, (.dmark+1)  
3629 32 6f fe			ld (debug_mark+1),a  
362c 3a 36 36			ld a, (.dmark+2)  
362f 32 70 fe			ld (debug_mark+2),a  
3632 18 03			jr .pastdmark  
3634 ..			.dmark: db "LP1"  
3637 f1			.pastdmark: pop af  
3638			endm  
# End of macro DMARK
3638						CALLMONITOR 
3638 cd fb 19			call break_point_state  
363b				endm  
# End of macro CALLMONITOR
363b					endif 
363b			 
363b				; go back to previous word 
363b			 
363b d5				push de    ; save I for inc later 
363c			 
363c			 
363c				; get limit 
363c				;  is I at limit? 
363c			 
363c			 
363c					if DEBUG_FORTH_WORDS 
363c						DMARK "LP1" 
363c f5				push af  
363d 3a 51 36			ld a, (.dmark)  
3640 32 6e fe			ld (debug_mark),a  
3643 3a 52 36			ld a, (.dmark+1)  
3646 32 6f fe			ld (debug_mark+1),a  
3649 3a 53 36			ld a, (.dmark+2)  
364c 32 70 fe			ld (debug_mark+2),a  
364f 18 03			jr .pastdmark  
3651 ..			.dmark: db "LP1"  
3654 f1			.pastdmark: pop af  
3655			endm  
# End of macro DMARK
3655						CALLMONITOR 
3655 cd fb 19			call break_point_state  
3658				endm  
# End of macro CALLMONITOR
3658					endif 
3658			 
3658 ed 52			sbc hl, de 
365a			 
365a			 
365a				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
365a			 
365a 20 26				jr nz, .loopnotdone 
365c			 
365c e1				pop hl   ; get rid of saved I 
365d				FORTH_LOOP_POP     ; get rid of limit 
365d cd 58 23			call macro_forth_loop_pop 
3660				endm 
# End of macro FORTH_LOOP_POP
3660			 
3660				FORTH_RSP_POP     ; get rid of DO ptr 
3660 cd bb 20			call macro_forth_rsp_pop 
3663				endm 
# End of macro FORTH_RSP_POP
3663			 
3663			if DEBUG_FORTH_WORDS 
3663						DMARK "LP>" 
3663 f5				push af  
3664 3a 78 36			ld a, (.dmark)  
3667 32 6e fe			ld (debug_mark),a  
366a 3a 79 36			ld a, (.dmark+1)  
366d 32 6f fe			ld (debug_mark+1),a  
3670 3a 7a 36			ld a, (.dmark+2)  
3673 32 70 fe			ld (debug_mark+2),a  
3676 18 03			jr .pastdmark  
3678 ..			.dmark: db "LP>"  
367b f1			.pastdmark: pop af  
367c			endm  
# End of macro DMARK
367c				CALLMONITOR 
367c cd fb 19			call break_point_state  
367f				endm  
# End of macro CALLMONITOR
367f			endif 
367f			 
367f					NEXTW 
367f c3 a0 24			jp macro_next 
3682				endm 
# End of macro NEXTW
3682				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3682			 
3682			.loopnotdone: 
3682			 
3682 e1				pop hl    ; get I 
3683 23				inc hl 
3684			 
3684			   	; save new I 
3684			 
3684			 
3684					; set I counter 
3684			 
3684 22 e9 f4				ld (os_current_i), hl 
3687			 
3687					if DEBUG_FORTH_WORDS 
3687						DMARK "LPN" 
3687 f5				push af  
3688 3a 9c 36			ld a, (.dmark)  
368b 32 6e fe			ld (debug_mark),a  
368e 3a 9d 36			ld a, (.dmark+1)  
3691 32 6f fe			ld (debug_mark+1),a  
3694 3a 9e 36			ld a, (.dmark+2)  
3697 32 70 fe			ld (debug_mark+2),a  
369a 18 03			jr .pastdmark  
369c ..			.dmark: db "LPN"  
369f f1			.pastdmark: pop af  
36a0			endm  
# End of macro DMARK
36a0					CALLMONITOR 
36a0 cd fb 19			call break_point_state  
36a3				endm  
# End of macro CALLMONITOR
36a3					endif 
36a3					 
36a3				FORTH_LOOP_NEXT 
36a3 cd 1b 23			call macro_forth_loop_next 
36a6				endm 
# End of macro FORTH_LOOP_NEXT
36a6			 
36a6			 
36a6					if DEBUG_FORTH_WORDS 
36a6 eb						ex de,hl 
36a7					endif 
36a7			 
36a7			;	; get DO ptr 
36a7			; 
36a7					if DEBUG_FORTH_WORDS 
36a7						DMARK "LP7" 
36a7 f5				push af  
36a8 3a bc 36			ld a, (.dmark)  
36ab 32 6e fe			ld (debug_mark),a  
36ae 3a bd 36			ld a, (.dmark+1)  
36b1 32 6f fe			ld (debug_mark+1),a  
36b4 3a be 36			ld a, (.dmark+2)  
36b7 32 70 fe			ld (debug_mark+2),a  
36ba 18 03			jr .pastdmark  
36bc ..			.dmark: db "LP7"  
36bf f1			.pastdmark: pop af  
36c0			endm  
# End of macro DMARK
36c0					CALLMONITOR 
36c0 cd fb 19			call break_point_state  
36c3				endm  
# End of macro CALLMONITOR
36c3					endif 
36c3				FORTH_RSP_TOS 
36c3 cd b1 20			call macro_forth_rsp_tos 
36c6				endm 
# End of macro FORTH_RSP_TOS
36c6			 
36c6					if DEBUG_FORTH_WORDS 
36c6						DMARK "LP8" 
36c6 f5				push af  
36c7 3a db 36			ld a, (.dmark)  
36ca 32 6e fe			ld (debug_mark),a  
36cd 3a dc 36			ld a, (.dmark+1)  
36d0 32 6f fe			ld (debug_mark+1),a  
36d3 3a dd 36			ld a, (.dmark+2)  
36d6 32 70 fe			ld (debug_mark+2),a  
36d9 18 03			jr .pastdmark  
36db ..			.dmark: db "LP8"  
36de f1			.pastdmark: pop af  
36df			endm  
# End of macro DMARK
36df					CALLMONITOR 
36df cd fb 19			call break_point_state  
36e2				endm  
# End of macro CALLMONITOR
36e2					endif 
36e2				;push hl 
36e2			 
36e2				; not going to DO any more 
36e2				; get rid of the RSP pointer as DO will add it back in 
36e2				;FORTH_RSP_POP 
36e2				;pop hl 
36e2			 
36e2				;ld hl,(cli_ret_sp) 
36e2				;ld e, (hl) 
36e2				;inc hl 
36e2				;ld d, (hl) 
36e2				;ex de,hl 
36e2 22 c5 f4			ld (os_tok_ptr), hl 
36e5					if DEBUG_FORTH_WORDS 
36e5						DMARK "LP<" 
36e5 f5				push af  
36e6 3a fa 36			ld a, (.dmark)  
36e9 32 6e fe			ld (debug_mark),a  
36ec 3a fb 36			ld a, (.dmark+1)  
36ef 32 6f fe			ld (debug_mark+1),a  
36f2 3a fc 36			ld a, (.dmark+2)  
36f5 32 70 fe			ld (debug_mark+2),a  
36f8 18 03			jr .pastdmark  
36fa ..			.dmark: db "LP<"  
36fd f1			.pastdmark: pop af  
36fe			endm  
# End of macro DMARK
36fe					CALLMONITOR 
36fe cd fb 19			call break_point_state  
3701				endm  
# End of macro CALLMONITOR
3701				endif 
3701 c3 31 25			jp exec1 
3704			 
3704					 
3704			 
3704			 
3704					NEXTW 
3704 c3 a0 24			jp macro_next 
3707				endm 
# End of macro NEXTW
3707			.I:  
3707			 
3707				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3707 5e				db WORD_SYS_CORE+74             
3708 32 37			dw .DLOOP            
370a 02				db 1 + 1 
370b .. 00			db "I",0              
370d				endm 
# End of macro CWHEAD
370d			; | I ( -- ) Current loop counter | DONE 
370d					if DEBUG_FORTH_WORDS_KEY 
370d						DMARK "I.." 
370d f5				push af  
370e 3a 22 37			ld a, (.dmark)  
3711 32 6e fe			ld (debug_mark),a  
3714 3a 23 37			ld a, (.dmark+1)  
3717 32 6f fe			ld (debug_mark+1),a  
371a 3a 24 37			ld a, (.dmark+2)  
371d 32 70 fe			ld (debug_mark+2),a  
3720 18 03			jr .pastdmark  
3722 ..			.dmark: db "I.."  
3725 f1			.pastdmark: pop af  
3726			endm  
# End of macro DMARK
3726						CALLMONITOR 
3726 cd fb 19			call break_point_state  
3729				endm  
# End of macro CALLMONITOR
3729					endif 
3729			 
3729 2a e9 f4				ld hl,(os_current_i) 
372c cd f3 20				call forth_push_numhl 
372f			 
372f					NEXTW 
372f c3 a0 24			jp macro_next 
3732				endm 
# End of macro NEXTW
3732			.DLOOP: 
3732				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3732 5f				db WORD_SYS_CORE+75             
3733 13 38			dw .REPEAT            
3735 06				db 5 + 1 
3736 .. 00			db "-LOOP",0              
373c				endm 
# End of macro CWHEAD
373c			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
373c				; pop tos as current loop count to hl 
373c					if DEBUG_FORTH_WORDS_KEY 
373c						DMARK "-LP" 
373c f5				push af  
373d 3a 51 37			ld a, (.dmark)  
3740 32 6e fe			ld (debug_mark),a  
3743 3a 52 37			ld a, (.dmark+1)  
3746 32 6f fe			ld (debug_mark+1),a  
3749 3a 53 37			ld a, (.dmark+2)  
374c 32 70 fe			ld (debug_mark+2),a  
374f 18 03			jr .pastdmark  
3751 ..			.dmark: db "-LP"  
3754 f1			.pastdmark: pop af  
3755			endm  
# End of macro DMARK
3755						CALLMONITOR 
3755 cd fb 19			call break_point_state  
3758				endm  
# End of macro CALLMONITOR
3758					endif 
3758			 
3758				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3758			 
3758				FORTH_LOOP_TOS 
3758 cd 4e 23			call macro_forth_loop_tos 
375b				endm 
# End of macro FORTH_LOOP_TOS
375b e5				push hl 
375c			 
375c					if DEBUG_FORTH_WORDS 
375c						DMARK "-LP" 
375c f5				push af  
375d 3a 71 37			ld a, (.dmark)  
3760 32 6e fe			ld (debug_mark),a  
3763 3a 72 37			ld a, (.dmark+1)  
3766 32 6f fe			ld (debug_mark+1),a  
3769 3a 73 37			ld a, (.dmark+2)  
376c 32 70 fe			ld (debug_mark+2),a  
376f 18 03			jr .pastdmark  
3771 ..			.dmark: db "-LP"  
3774 f1			.pastdmark: pop af  
3775			endm  
# End of macro DMARK
3775						CALLMONITOR 
3775 cd fb 19			call break_point_state  
3778				endm  
# End of macro CALLMONITOR
3778					endif 
3778				; next item on the stack is the limit. get it 
3778			 
3778			 
3778				FORTH_LOOP_POP 
3778 cd 58 23			call macro_forth_loop_pop 
377b				endm 
# End of macro FORTH_LOOP_POP
377b			 
377b				FORTH_LOOP_TOS 
377b cd 4e 23			call macro_forth_loop_tos 
377e				endm 
# End of macro FORTH_LOOP_TOS
377e			 
377e d1				pop de		 ; de = i, hl = limit 
377f			 
377f					if DEBUG_FORTH_WORDS 
377f						DMARK "-L1" 
377f f5				push af  
3780 3a 94 37			ld a, (.dmark)  
3783 32 6e fe			ld (debug_mark),a  
3786 3a 95 37			ld a, (.dmark+1)  
3789 32 6f fe			ld (debug_mark+1),a  
378c 3a 96 37			ld a, (.dmark+2)  
378f 32 70 fe			ld (debug_mark+2),a  
3792 18 03			jr .pastdmark  
3794 ..			.dmark: db "-L1"  
3797 f1			.pastdmark: pop af  
3798			endm  
# End of macro DMARK
3798						CALLMONITOR 
3798 cd fb 19			call break_point_state  
379b				endm  
# End of macro CALLMONITOR
379b					endif 
379b			 
379b				; go back to previous word 
379b			 
379b d5				push de    ; save I for inc later 
379c			 
379c			 
379c				; get limit 
379c				;  is I at limit? 
379c			 
379c			 
379c					if DEBUG_FORTH_WORDS 
379c						DMARK "-L1" 
379c f5				push af  
379d 3a b1 37			ld a, (.dmark)  
37a0 32 6e fe			ld (debug_mark),a  
37a3 3a b2 37			ld a, (.dmark+1)  
37a6 32 6f fe			ld (debug_mark+1),a  
37a9 3a b3 37			ld a, (.dmark+2)  
37ac 32 70 fe			ld (debug_mark+2),a  
37af 18 03			jr .pastdmark  
37b1 ..			.dmark: db "-L1"  
37b4 f1			.pastdmark: pop af  
37b5			endm  
# End of macro DMARK
37b5						CALLMONITOR 
37b5 cd fb 19			call break_point_state  
37b8				endm  
# End of macro CALLMONITOR
37b8					endif 
37b8			 
37b8 ed 52			sbc hl, de 
37ba			 
37ba			 
37ba				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
37ba			 
37ba 20 26				jr nz, .mloopnotdone 
37bc			 
37bc e1				pop hl   ; get rid of saved I 
37bd				FORTH_LOOP_POP     ; get rid of limit 
37bd cd 58 23			call macro_forth_loop_pop 
37c0				endm 
# End of macro FORTH_LOOP_POP
37c0			 
37c0				FORTH_RSP_POP     ; get rid of DO ptr 
37c0 cd bb 20			call macro_forth_rsp_pop 
37c3				endm 
# End of macro FORTH_RSP_POP
37c3			 
37c3			if DEBUG_FORTH_WORDS 
37c3						DMARK "-L>" 
37c3 f5				push af  
37c4 3a d8 37			ld a, (.dmark)  
37c7 32 6e fe			ld (debug_mark),a  
37ca 3a d9 37			ld a, (.dmark+1)  
37cd 32 6f fe			ld (debug_mark+1),a  
37d0 3a da 37			ld a, (.dmark+2)  
37d3 32 70 fe			ld (debug_mark+2),a  
37d6 18 03			jr .pastdmark  
37d8 ..			.dmark: db "-L>"  
37db f1			.pastdmark: pop af  
37dc			endm  
# End of macro DMARK
37dc				CALLMONITOR 
37dc cd fb 19			call break_point_state  
37df				endm  
# End of macro CALLMONITOR
37df			endif 
37df			 
37df					NEXTW 
37df c3 a0 24			jp macro_next 
37e2				endm 
# End of macro NEXTW
37e2				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
37e2			 
37e2			.mloopnotdone: 
37e2			 
37e2 e1				pop hl    ; get I 
37e3 2b				dec hl 
37e4			 
37e4			   	; save new I 
37e4			 
37e4			 
37e4					; set I counter 
37e4			 
37e4 22 e9 f4				ld (os_current_i), hl 
37e7			 
37e7					 
37e7				FORTH_LOOP_NEXT 
37e7 cd 1b 23			call macro_forth_loop_next 
37ea				endm 
# End of macro FORTH_LOOP_NEXT
37ea			 
37ea			 
37ea					if DEBUG_FORTH_WORDS 
37ea eb						ex de,hl 
37eb					endif 
37eb			 
37eb			;	; get DO ptr 
37eb			; 
37eb				FORTH_RSP_TOS 
37eb cd b1 20			call macro_forth_rsp_tos 
37ee				endm 
# End of macro FORTH_RSP_TOS
37ee			 
37ee				;push hl 
37ee			 
37ee				; not going to DO any more 
37ee				; get rid of the RSP pointer as DO will add it back in 
37ee				;FORTH_RSP_POP 
37ee				;pop hl 
37ee			 
37ee			 
37ee 22 c5 f4			ld (os_tok_ptr), hl 
37f1					if DEBUG_FORTH_WORDS 
37f1						DMARK "-L<" 
37f1 f5				push af  
37f2 3a 06 38			ld a, (.dmark)  
37f5 32 6e fe			ld (debug_mark),a  
37f8 3a 07 38			ld a, (.dmark+1)  
37fb 32 6f fe			ld (debug_mark+1),a  
37fe 3a 08 38			ld a, (.dmark+2)  
3801 32 70 fe			ld (debug_mark+2),a  
3804 18 03			jr .pastdmark  
3806 ..			.dmark: db "-L<"  
3809 f1			.pastdmark: pop af  
380a			endm  
# End of macro DMARK
380a					CALLMONITOR 
380a cd fb 19			call break_point_state  
380d				endm  
# End of macro CALLMONITOR
380d				endif 
380d c3 31 25			jp exec1 
3810			 
3810					 
3810			 
3810			 
3810			 
3810				NEXTW 
3810 c3 a0 24			jp macro_next 
3813				endm 
# End of macro NEXTW
3813			 
3813			 
3813			 
3813			 
3813			.REPEAT: 
3813				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3813 71				db WORD_SYS_CORE+93             
3814 66 38			dw .UNTIL            
3816 06				db 5 + 1 
3817 .. 00			db "REPEAT",0              
381e				endm 
# End of macro CWHEAD
381e			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
381e			;  push pc to rsp stack past the REPEAT 
381e					if DEBUG_FORTH_WORDS_KEY 
381e						DMARK "REP" 
381e f5				push af  
381f 3a 33 38			ld a, (.dmark)  
3822 32 6e fe			ld (debug_mark),a  
3825 3a 34 38			ld a, (.dmark+1)  
3828 32 6f fe			ld (debug_mark+1),a  
382b 3a 35 38			ld a, (.dmark+2)  
382e 32 70 fe			ld (debug_mark+2),a  
3831 18 03			jr .pastdmark  
3833 ..			.dmark: db "REP"  
3836 f1			.pastdmark: pop af  
3837			endm  
# End of macro DMARK
3837						CALLMONITOR 
3837 cd fb 19			call break_point_state  
383a				endm  
# End of macro CALLMONITOR
383a					endif 
383a			 
383a 2a c5 f4				ld hl, (os_tok_ptr) 
383d 23					inc hl   ; R 
383e 23					inc hl  ; E 
383f 23					inc hl   ; P 
3840 23					inc hl   ; E 
3841 23					inc hl   ; A 
3842 23					inc hl   ; T 
3843 23					inc hl   ; zero 
3844					FORTH_RSP_NEXT 
3844 cd 9a 20			call macro_forth_rsp_next 
3847				endm 
# End of macro FORTH_RSP_NEXT
3847			 
3847			 
3847					if DEBUG_FORTH_WORDS 
3847						DMARK "REP" 
3847 f5				push af  
3848 3a 5c 38			ld a, (.dmark)  
384b 32 6e fe			ld (debug_mark),a  
384e 3a 5d 38			ld a, (.dmark+1)  
3851 32 6f fe			ld (debug_mark+1),a  
3854 3a 5e 38			ld a, (.dmark+2)  
3857 32 70 fe			ld (debug_mark+2),a  
385a 18 03			jr .pastdmark  
385c ..			.dmark: db "REP"  
385f f1			.pastdmark: pop af  
3860			endm  
# End of macro DMARK
3860						;pop bc    ; TODO BUG ?????? what is this for???? 
3860						CALLMONITOR 
3860 cd fb 19			call break_point_state  
3863				endm  
# End of macro CALLMONITOR
3863					endif 
3863			 
3863					NEXTW 
3863 c3 a0 24			jp macro_next 
3866				endm 
# End of macro NEXTW
3866			;	       NEXTW 
3866			 
3866			.UNTIL: 
3866				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3866 72				db WORD_SYS_CORE+94             
3867 fd 38			dw .ENDFLOW            
3869 06				db 5 + 1 
386a .. 00			db "UNTIL",0              
3870				endm 
# End of macro CWHEAD
3870			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3870			 
3870				; pop tos as check 
3870			 
3870				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3870			 
3870				FORTH_DSP_VALUEHL 
3870 cd ea 22			call macro_dsp_valuehl 
3873				endm 
# End of macro FORTH_DSP_VALUEHL
3873			 
3873					if DEBUG_FORTH_WORDS_KEY 
3873						DMARK "UNT" 
3873 f5				push af  
3874 3a 88 38			ld a, (.dmark)  
3877 32 6e fe			ld (debug_mark),a  
387a 3a 89 38			ld a, (.dmark+1)  
387d 32 6f fe			ld (debug_mark+1),a  
3880 3a 8a 38			ld a, (.dmark+2)  
3883 32 70 fe			ld (debug_mark+2),a  
3886 18 03			jr .pastdmark  
3888 ..			.dmark: db "UNT"  
388b f1			.pastdmark: pop af  
388c			endm  
# End of macro DMARK
388c						CALLMONITOR 
388c cd fb 19			call break_point_state  
388f				endm  
# End of macro CALLMONITOR
388f					endif 
388f			 
388f			;	push hl 
388f				FORTH_DSP_POP 
388f cd a2 23			call macro_forth_dsp_pop 
3892				endm 
# End of macro FORTH_DSP_POP
3892			 
3892			;	pop hl 
3892			 
3892				; test if true 
3892			 
3892 cd af 0f			call ishlzero 
3895			;	ld a,l 
3895			;	add h 
3895			; 
3895			;	cp 0 
3895			 
3895 20 3e			jr nz, .untilnotdone 
3897			 
3897					if DEBUG_FORTH_WORDS 
3897						DMARK "UNf" 
3897 f5				push af  
3898 3a ac 38			ld a, (.dmark)  
389b 32 6e fe			ld (debug_mark),a  
389e 3a ad 38			ld a, (.dmark+1)  
38a1 32 6f fe			ld (debug_mark+1),a  
38a4 3a ae 38			ld a, (.dmark+2)  
38a7 32 70 fe			ld (debug_mark+2),a  
38aa 18 03			jr .pastdmark  
38ac ..			.dmark: db "UNf"  
38af f1			.pastdmark: pop af  
38b0			endm  
# End of macro DMARK
38b0						CALLMONITOR 
38b0 cd fb 19			call break_point_state  
38b3				endm  
# End of macro CALLMONITOR
38b3					endif 
38b3			 
38b3			 
38b3			 
38b3				FORTH_RSP_POP     ; get rid of DO ptr 
38b3 cd bb 20			call macro_forth_rsp_pop 
38b6				endm 
# End of macro FORTH_RSP_POP
38b6			 
38b6			if DEBUG_FORTH_WORDS 
38b6						DMARK "UN>" 
38b6 f5				push af  
38b7 3a cb 38			ld a, (.dmark)  
38ba 32 6e fe			ld (debug_mark),a  
38bd 3a cc 38			ld a, (.dmark+1)  
38c0 32 6f fe			ld (debug_mark+1),a  
38c3 3a cd 38			ld a, (.dmark+2)  
38c6 32 70 fe			ld (debug_mark+2),a  
38c9 18 03			jr .pastdmark  
38cb ..			.dmark: db "UN>"  
38ce f1			.pastdmark: pop af  
38cf			endm  
# End of macro DMARK
38cf				CALLMONITOR 
38cf cd fb 19			call break_point_state  
38d2				endm  
# End of macro CALLMONITOR
38d2			endif 
38d2			 
38d2					NEXTW 
38d2 c3 a0 24			jp macro_next 
38d5				endm 
# End of macro NEXTW
38d5				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
38d5			 
38d5			.untilnotdone: 
38d5			 
38d5			 
38d5			;	; get DO ptr 
38d5			; 
38d5				FORTH_RSP_TOS 
38d5 cd b1 20			call macro_forth_rsp_tos 
38d8				endm 
# End of macro FORTH_RSP_TOS
38d8			 
38d8				;push hl 
38d8			 
38d8				; not going to DO any more 
38d8				; get rid of the RSP pointer as DO will add it back in 
38d8				;FORTH_RSP_POP 
38d8				;pop hl 
38d8			 
38d8			 
38d8 22 c5 f4			ld (os_tok_ptr), hl 
38db					if DEBUG_FORTH_WORDS 
38db						DMARK "UN<" 
38db f5				push af  
38dc 3a f0 38			ld a, (.dmark)  
38df 32 6e fe			ld (debug_mark),a  
38e2 3a f1 38			ld a, (.dmark+1)  
38e5 32 6f fe			ld (debug_mark+1),a  
38e8 3a f2 38			ld a, (.dmark+2)  
38eb 32 70 fe			ld (debug_mark+2),a  
38ee 18 03			jr .pastdmark  
38f0 ..			.dmark: db "UN<"  
38f3 f1			.pastdmark: pop af  
38f4			endm  
# End of macro DMARK
38f4					CALLMONITOR 
38f4 cd fb 19			call break_point_state  
38f7				endm  
# End of macro CALLMONITOR
38f7				endif 
38f7 c3 31 25			jp exec1 
38fa			 
38fa					 
38fa			 
38fa			 
38fa					NEXTW 
38fa c3 a0 24			jp macro_next 
38fd				endm 
# End of macro NEXTW
38fd			 
38fd			 
38fd			.ENDFLOW: 
38fd			 
38fd			; eof 
38fd			 
# End of file forth_words_flow.asm
38fd			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
38fd			include "forth_words_logic.asm" 
38fd			 
38fd			; | ## Logic Words 
38fd			 
38fd			.NOT: 
38fd				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
38fd 2d				db WORD_SYS_CORE+25             
38fe 45 39			dw .IS            
3900 04				db 3 + 1 
3901 .. 00			db "NOT",0              
3905				endm 
# End of macro CWHEAD
3905			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3905					if DEBUG_FORTH_WORDS_KEY 
3905						DMARK "NOT" 
3905 f5				push af  
3906 3a 1a 39			ld a, (.dmark)  
3909 32 6e fe			ld (debug_mark),a  
390c 3a 1b 39			ld a, (.dmark+1)  
390f 32 6f fe			ld (debug_mark+1),a  
3912 3a 1c 39			ld a, (.dmark+2)  
3915 32 70 fe			ld (debug_mark+2),a  
3918 18 03			jr .pastdmark  
391a ..			.dmark: db "NOT"  
391d f1			.pastdmark: pop af  
391e			endm  
# End of macro DMARK
391e						CALLMONITOR 
391e cd fb 19			call break_point_state  
3921				endm  
# End of macro CALLMONITOR
3921					endif 
3921					FORTH_DSP 
3921 cd b0 22			call macro_forth_dsp 
3924				endm 
# End of macro FORTH_DSP
3924 7e					ld a,(hl)	; get type of value on TOS 
3925 fe 02				cp DS_TYPE_INUM  
3927 28 03				jr z, .noti 
3929					NEXTW 
3929 c3 a0 24			jp macro_next 
392c				endm 
# End of macro NEXTW
392c			.noti:          FORTH_DSP_VALUEHL 
392c cd ea 22			call macro_dsp_valuehl 
392f				endm 
# End of macro FORTH_DSP_VALUEHL
392f			;		push hl 
392f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
392f cd a2 23			call macro_forth_dsp_pop 
3932				endm 
# End of macro FORTH_DSP_POP
3932			;		pop hl 
3932 3e 00				ld a,0 
3934 bd					cp l 
3935 28 04				jr z, .not2t 
3937 2e 00				ld l, 0 
3939 18 02				jr .notip 
393b			 
393b 2e ff		.not2t:		ld l, 255 
393d			 
393d 26 00		.notip:		ld h, 0	 
393f			 
393f cd f3 20				call forth_push_numhl 
3942					NEXTW 
3942 c3 a0 24			jp macro_next 
3945				endm 
# End of macro NEXTW
3945			 
3945			.IS: 
3945				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3945 2d				db WORD_SYS_CORE+25             
3946 6b 39			dw .LZERO            
3948 03				db 2 + 1 
3949 .. 00			db "IS",0              
394c				endm 
# End of macro CWHEAD
394c			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
394c					if DEBUG_FORTH_WORDS_KEY 
394c						DMARK "IS." 
394c f5				push af  
394d 3a 61 39			ld a, (.dmark)  
3950 32 6e fe			ld (debug_mark),a  
3953 3a 62 39			ld a, (.dmark+1)  
3956 32 6f fe			ld (debug_mark+1),a  
3959 3a 63 39			ld a, (.dmark+2)  
395c 32 70 fe			ld (debug_mark+2),a  
395f 18 03			jr .pastdmark  
3961 ..			.dmark: db "IS."  
3964 f1			.pastdmark: pop af  
3965			endm  
# End of macro DMARK
3965						CALLMONITOR 
3965 cd fb 19			call break_point_state  
3968				endm  
# End of macro CALLMONITOR
3968					endif 
3968					NEXTW 
3968 c3 a0 24			jp macro_next 
396b				endm 
# End of macro NEXTW
396b			.LZERO: 
396b				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
396b 2d				db WORD_SYS_CORE+25             
396c 75 39			dw .TZERO            
396e 03				db 2 + 1 
396f .. 00			db "0<",0              
3972				endm 
# End of macro CWHEAD
3972			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3972					NEXTW 
3972 c3 a0 24			jp macro_next 
3975				endm 
# End of macro NEXTW
3975			.TZERO: 
3975				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3975 2e				db WORD_SYS_CORE+26             
3976 bc 39			dw .LESS            
3978 03				db 2 + 1 
3979 .. 00			db "0=",0              
397c				endm 
# End of macro CWHEAD
397c			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
397c				; TODO add floating point number detection 
397c					;v5 FORTH_DSP_VALUE 
397c					if DEBUG_FORTH_WORDS_KEY 
397c						DMARK "0=." 
397c f5				push af  
397d 3a 91 39			ld a, (.dmark)  
3980 32 6e fe			ld (debug_mark),a  
3983 3a 92 39			ld a, (.dmark+1)  
3986 32 6f fe			ld (debug_mark+1),a  
3989 3a 93 39			ld a, (.dmark+2)  
398c 32 70 fe			ld (debug_mark+2),a  
398f 18 03			jr .pastdmark  
3991 ..			.dmark: db "0=."  
3994 f1			.pastdmark: pop af  
3995			endm  
# End of macro DMARK
3995						CALLMONITOR 
3995 cd fb 19			call break_point_state  
3998				endm  
# End of macro CALLMONITOR
3998					endif 
3998					FORTH_DSP 
3998 cd b0 22			call macro_forth_dsp 
399b				endm 
# End of macro FORTH_DSP
399b 7e					ld a,(hl)	; get type of value on TOS 
399c fe 02				cp DS_TYPE_INUM  
399e 28 00				jr z, .tz_inum 
39a0			 
39a0				if FORTH_ENABLE_FLOATMATH 
39a0					jr .tz_done 
39a0			 
39a0				endif 
39a0					 
39a0			 
39a0			.tz_inum: 
39a0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39a0 cd ea 22			call macro_dsp_valuehl 
39a3				endm 
# End of macro FORTH_DSP_VALUEHL
39a3			 
39a3			;		push hl 
39a3			 
39a3					; destroy value TOS 
39a3			 
39a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39a3 cd a2 23			call macro_forth_dsp_pop 
39a6				endm 
# End of macro FORTH_DSP_POP
39a6			 
39a6			;		pop hl 
39a6			 
39a6 3e 00				ld a,0 
39a8			 
39a8 bd					cp l 
39a9 20 08				jr nz, .tz_notzero 
39ab			 
39ab bc					cp h 
39ac			 
39ac 20 05				jr nz, .tz_notzero 
39ae			 
39ae			 
39ae 21 01 00				ld hl, FORTH_TRUE 
39b1 18 03				jr .tz_done 
39b3			 
39b3 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
39b6			 
39b6					; push value back onto stack for another op etc 
39b6			 
39b6			.tz_done: 
39b6 cd f3 20				call forth_push_numhl 
39b9			 
39b9					NEXTW 
39b9 c3 a0 24			jp macro_next 
39bc				endm 
# End of macro NEXTW
39bc			.LESS: 
39bc				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
39bc 2f				db WORD_SYS_CORE+27             
39bd 25 3a			dw .GT            
39bf 02				db 1 + 1 
39c0 .. 00			db "<",0              
39c2				endm 
# End of macro CWHEAD
39c2			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
39c2				; TODO add floating point number detection 
39c2					if DEBUG_FORTH_WORDS_KEY 
39c2						DMARK "LES" 
39c2 f5				push af  
39c3 3a d7 39			ld a, (.dmark)  
39c6 32 6e fe			ld (debug_mark),a  
39c9 3a d8 39			ld a, (.dmark+1)  
39cc 32 6f fe			ld (debug_mark+1),a  
39cf 3a d9 39			ld a, (.dmark+2)  
39d2 32 70 fe			ld (debug_mark+2),a  
39d5 18 03			jr .pastdmark  
39d7 ..			.dmark: db "LES"  
39da f1			.pastdmark: pop af  
39db			endm  
# End of macro DMARK
39db						CALLMONITOR 
39db cd fb 19			call break_point_state  
39de				endm  
# End of macro CALLMONITOR
39de					endif 
39de					FORTH_DSP 
39de cd b0 22			call macro_forth_dsp 
39e1				endm 
# End of macro FORTH_DSP
39e1					;v5 FORTH_DSP_VALUE 
39e1 7e					ld a,(hl)	; get type of value on TOS 
39e2 fe 02				cp DS_TYPE_INUM  
39e4 28 00				jr z, .less_inum 
39e6			 
39e6				if FORTH_ENABLE_FLOATMATH 
39e6					jr .less_done 
39e6			 
39e6				endif 
39e6					 
39e6			 
39e6			.less_inum: 
39e6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39e6 cd ea 22			call macro_dsp_valuehl 
39e9				endm 
# End of macro FORTH_DSP_VALUEHL
39e9			 
39e9 e5					push hl  ; u2 
39ea			 
39ea					; destroy value TOS 
39ea			 
39ea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39ea cd a2 23			call macro_forth_dsp_pop 
39ed				endm 
# End of macro FORTH_DSP_POP
39ed			 
39ed			 
39ed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39ed cd ea 22			call macro_dsp_valuehl 
39f0				endm 
# End of macro FORTH_DSP_VALUEHL
39f0			 
39f0 e5					push hl    ; u1 
39f1			 
39f1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39f1 cd a2 23			call macro_forth_dsp_pop 
39f4				endm 
# End of macro FORTH_DSP_POP
39f4			 
39f4			 
39f4 b7			 or a      ;clear carry flag 
39f5 01 00 00		 ld bc, FORTH_FALSE 
39f8 e1			  pop hl    ; u1 
39f9 d1			  pop de    ; u2 
39fa ed 52		  sbc hl,de 
39fc 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
39fe			 
39fe 01 01 00		 ld bc, FORTH_TRUE 
3a01			.lscont:  
3a01 c5					push bc 
3a02 e1					pop hl 
3a03			 
3a03					if DEBUG_FORTH_WORDS 
3a03						DMARK "LT1" 
3a03 f5				push af  
3a04 3a 18 3a			ld a, (.dmark)  
3a07 32 6e fe			ld (debug_mark),a  
3a0a 3a 19 3a			ld a, (.dmark+1)  
3a0d 32 6f fe			ld (debug_mark+1),a  
3a10 3a 1a 3a			ld a, (.dmark+2)  
3a13 32 70 fe			ld (debug_mark+2),a  
3a16 18 03			jr .pastdmark  
3a18 ..			.dmark: db "LT1"  
3a1b f1			.pastdmark: pop af  
3a1c			endm  
# End of macro DMARK
3a1c						CALLMONITOR 
3a1c cd fb 19			call break_point_state  
3a1f				endm  
# End of macro CALLMONITOR
3a1f					endif 
3a1f cd f3 20				call forth_push_numhl 
3a22			 
3a22					NEXTW 
3a22 c3 a0 24			jp macro_next 
3a25				endm 
# End of macro NEXTW
3a25			.GT: 
3a25				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3a25 30				db WORD_SYS_CORE+28             
3a26 8e 3a			dw .EQUAL            
3a28 02				db 1 + 1 
3a29 .. 00			db ">",0              
3a2b				endm 
# End of macro CWHEAD
3a2b			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3a2b				; TODO add floating point number detection 
3a2b					if DEBUG_FORTH_WORDS_KEY 
3a2b						DMARK "GRT" 
3a2b f5				push af  
3a2c 3a 40 3a			ld a, (.dmark)  
3a2f 32 6e fe			ld (debug_mark),a  
3a32 3a 41 3a			ld a, (.dmark+1)  
3a35 32 6f fe			ld (debug_mark+1),a  
3a38 3a 42 3a			ld a, (.dmark+2)  
3a3b 32 70 fe			ld (debug_mark+2),a  
3a3e 18 03			jr .pastdmark  
3a40 ..			.dmark: db "GRT"  
3a43 f1			.pastdmark: pop af  
3a44			endm  
# End of macro DMARK
3a44						CALLMONITOR 
3a44 cd fb 19			call break_point_state  
3a47				endm  
# End of macro CALLMONITOR
3a47					endif 
3a47					FORTH_DSP 
3a47 cd b0 22			call macro_forth_dsp 
3a4a				endm 
# End of macro FORTH_DSP
3a4a					;FORTH_DSP_VALUE 
3a4a 7e					ld a,(hl)	; get type of value on TOS 
3a4b fe 02				cp DS_TYPE_INUM  
3a4d 28 00				jr z, .gt_inum 
3a4f			 
3a4f				if FORTH_ENABLE_FLOATMATH 
3a4f					jr .gt_done 
3a4f			 
3a4f				endif 
3a4f					 
3a4f			 
3a4f			.gt_inum: 
3a4f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a4f cd ea 22			call macro_dsp_valuehl 
3a52				endm 
# End of macro FORTH_DSP_VALUEHL
3a52			 
3a52 e5					push hl  ; u2 
3a53			 
3a53					; destroy value TOS 
3a53			 
3a53					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a53 cd a2 23			call macro_forth_dsp_pop 
3a56				endm 
# End of macro FORTH_DSP_POP
3a56			 
3a56			 
3a56					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a56 cd ea 22			call macro_dsp_valuehl 
3a59				endm 
# End of macro FORTH_DSP_VALUEHL
3a59			 
3a59 e5					push hl    ; u1 
3a5a			 
3a5a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a5a cd a2 23			call macro_forth_dsp_pop 
3a5d				endm 
# End of macro FORTH_DSP_POP
3a5d			 
3a5d			 
3a5d b7			 or a      ;clear carry flag 
3a5e 01 00 00		 ld bc, FORTH_FALSE 
3a61 e1			  pop hl    ; u1 
3a62 d1			  pop de    ; u2 
3a63 ed 52		  sbc hl,de 
3a65 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3a67			 
3a67 01 01 00		 ld bc, FORTH_TRUE 
3a6a			.gtcont:  
3a6a c5					push bc 
3a6b e1					pop hl 
3a6c			 
3a6c					if DEBUG_FORTH_WORDS 
3a6c						DMARK "GT1" 
3a6c f5				push af  
3a6d 3a 81 3a			ld a, (.dmark)  
3a70 32 6e fe			ld (debug_mark),a  
3a73 3a 82 3a			ld a, (.dmark+1)  
3a76 32 6f fe			ld (debug_mark+1),a  
3a79 3a 83 3a			ld a, (.dmark+2)  
3a7c 32 70 fe			ld (debug_mark+2),a  
3a7f 18 03			jr .pastdmark  
3a81 ..			.dmark: db "GT1"  
3a84 f1			.pastdmark: pop af  
3a85			endm  
# End of macro DMARK
3a85						CALLMONITOR 
3a85 cd fb 19			call break_point_state  
3a88				endm  
# End of macro CALLMONITOR
3a88					endif 
3a88 cd f3 20				call forth_push_numhl 
3a8b			 
3a8b					NEXTW 
3a8b c3 a0 24			jp macro_next 
3a8e				endm 
# End of macro NEXTW
3a8e			.EQUAL: 
3a8e				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3a8e 31				db WORD_SYS_CORE+29             
3a8f f9 3a			dw .ENDLOGIC            
3a91 02				db 1 + 1 
3a92 .. 00			db "=",0              
3a94				endm 
# End of macro CWHEAD
3a94			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3a94				; TODO add floating point number detection 
3a94					if DEBUG_FORTH_WORDS_KEY 
3a94						DMARK "EQ." 
3a94 f5				push af  
3a95 3a a9 3a			ld a, (.dmark)  
3a98 32 6e fe			ld (debug_mark),a  
3a9b 3a aa 3a			ld a, (.dmark+1)  
3a9e 32 6f fe			ld (debug_mark+1),a  
3aa1 3a ab 3a			ld a, (.dmark+2)  
3aa4 32 70 fe			ld (debug_mark+2),a  
3aa7 18 03			jr .pastdmark  
3aa9 ..			.dmark: db "EQ."  
3aac f1			.pastdmark: pop af  
3aad			endm  
# End of macro DMARK
3aad						CALLMONITOR 
3aad cd fb 19			call break_point_state  
3ab0				endm  
# End of macro CALLMONITOR
3ab0					endif 
3ab0					FORTH_DSP 
3ab0 cd b0 22			call macro_forth_dsp 
3ab3				endm 
# End of macro FORTH_DSP
3ab3					;v5 FORTH_DSP_VALUE 
3ab3 7e					ld a,(hl)	; get type of value on TOS 
3ab4 fe 02				cp DS_TYPE_INUM  
3ab6 28 00				jr z, .eq_inum 
3ab8			 
3ab8				if FORTH_ENABLE_FLOATMATH 
3ab8					jr .eq_done 
3ab8			 
3ab8				endif 
3ab8					 
3ab8			 
3ab8			.eq_inum: 
3ab8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ab8 cd ea 22			call macro_dsp_valuehl 
3abb				endm 
# End of macro FORTH_DSP_VALUEHL
3abb			 
3abb e5					push hl 
3abc			 
3abc					; destroy value TOS 
3abc			 
3abc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3abc cd a2 23			call macro_forth_dsp_pop 
3abf				endm 
# End of macro FORTH_DSP_POP
3abf			 
3abf			 
3abf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3abf cd ea 22			call macro_dsp_valuehl 
3ac2				endm 
# End of macro FORTH_DSP_VALUEHL
3ac2			 
3ac2					; one value on hl get other one back 
3ac2			 
3ac2 e5					push hl 
3ac3			 
3ac3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ac3 cd a2 23			call macro_forth_dsp_pop 
3ac6				endm 
# End of macro FORTH_DSP_POP
3ac6			 
3ac6 0e 00				ld c, FORTH_FALSE 
3ac8			 
3ac8 e1					pop hl 
3ac9 d1					pop de 
3aca			 
3aca 7b					ld a, e 
3acb bd					cp l 
3acc			 
3acc 20 06				jr nz, .eq_done 
3ace			 
3ace 7a					ld a, d 
3acf bc					cp h 
3ad0			 
3ad0 20 02				jr nz, .eq_done 
3ad2			 
3ad2 0e 01				ld c, FORTH_TRUE 
3ad4					 
3ad4			 
3ad4			 
3ad4			.eq_done: 
3ad4			 
3ad4					; TODO push value back onto stack for another op etc 
3ad4			 
3ad4 26 00				ld h, 0 
3ad6 69					ld l, c 
3ad7					if DEBUG_FORTH_WORDS 
3ad7						DMARK "EQ1" 
3ad7 f5				push af  
3ad8 3a ec 3a			ld a, (.dmark)  
3adb 32 6e fe			ld (debug_mark),a  
3ade 3a ed 3a			ld a, (.dmark+1)  
3ae1 32 6f fe			ld (debug_mark+1),a  
3ae4 3a ee 3a			ld a, (.dmark+2)  
3ae7 32 70 fe			ld (debug_mark+2),a  
3aea 18 03			jr .pastdmark  
3aec ..			.dmark: db "EQ1"  
3aef f1			.pastdmark: pop af  
3af0			endm  
# End of macro DMARK
3af0						CALLMONITOR 
3af0 cd fb 19			call break_point_state  
3af3				endm  
# End of macro CALLMONITOR
3af3					endif 
3af3 cd f3 20				call forth_push_numhl 
3af6			 
3af6					NEXTW 
3af6 c3 a0 24			jp macro_next 
3af9				endm 
# End of macro NEXTW
3af9			 
3af9			 
3af9			.ENDLOGIC: 
3af9			; eof 
3af9			 
3af9			 
# End of file forth_words_logic.asm
3af9			include "forth_words_maths.asm" 
3af9			 
3af9			; | ## Maths Words 
3af9			 
3af9			.PLUS:	 
3af9				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3af9 15				db WORD_SYS_CORE+1             
3afa 57 3b			dw .NEG            
3afc 02				db 1 + 1 
3afd .. 00			db "+",0              
3aff				endm 
# End of macro CWHEAD
3aff			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3aff					if DEBUG_FORTH_WORDS_KEY 
3aff						DMARK "PLU" 
3aff f5				push af  
3b00 3a 14 3b			ld a, (.dmark)  
3b03 32 6e fe			ld (debug_mark),a  
3b06 3a 15 3b			ld a, (.dmark+1)  
3b09 32 6f fe			ld (debug_mark+1),a  
3b0c 3a 16 3b			ld a, (.dmark+2)  
3b0f 32 70 fe			ld (debug_mark+2),a  
3b12 18 03			jr .pastdmark  
3b14 ..			.dmark: db "PLU"  
3b17 f1			.pastdmark: pop af  
3b18			endm  
# End of macro DMARK
3b18						CALLMONITOR 
3b18 cd fb 19			call break_point_state  
3b1b				endm  
# End of macro CALLMONITOR
3b1b					endif 
3b1b					; add top two values and push back result 
3b1b			 
3b1b					;for v5 FORTH_DSP_VALUE 
3b1b					FORTH_DSP 
3b1b cd b0 22			call macro_forth_dsp 
3b1e				endm 
# End of macro FORTH_DSP
3b1e 7e					ld a,(hl)	; get type of value on TOS 
3b1f fe 02				cp DS_TYPE_INUM  
3b21 28 03				jr z, .dot_inum 
3b23			 
3b23					NEXTW 
3b23 c3 a0 24			jp macro_next 
3b26				endm 
# End of macro NEXTW
3b26			 
3b26			; float maths 
3b26			 
3b26				if FORTH_ENABLE_FLOATMATH 
3b26						inc hl      ; now at start of numeric as string 
3b26			 
3b26					if DEBUG_FORTH_MATHS 
3b26						DMARK "ADD" 
3b26				CALLMONITOR 
3b26					endif 
3b26			 
3b26					;ld ix, hl 
3b26					call CON 
3b26			 
3b26			 
3b26					push hl 
3b26					 
3b26					 
3b26			 
3b26						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3b26			 
3b26					; get next number 
3b26			 
3b26						FORTH_DSP_VALUE 
3b26			 
3b26						inc hl      ; now at start of numeric as string 
3b26			 
3b26					;ld ix, hl 
3b26					call CON 
3b26			 
3b26					push hl 
3b26			 
3b26			 
3b26						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b26			 
3b26						; TODO do add 
3b26			 
3b26						call IADD 
3b26			 
3b26						; TODO get result back as ascii 
3b26			 
3b26						; TODO push result  
3b26			 
3b26			 
3b26			 
3b26						jr .dot_done 
3b26				endif 
3b26			 
3b26			.dot_inum: 
3b26			 
3b26			 
3b26					if DEBUG_FORTH_DOT 
3b26						DMARK "+IT" 
3b26 f5				push af  
3b27 3a 3b 3b			ld a, (.dmark)  
3b2a 32 6e fe			ld (debug_mark),a  
3b2d 3a 3c 3b			ld a, (.dmark+1)  
3b30 32 6f fe			ld (debug_mark+1),a  
3b33 3a 3d 3b			ld a, (.dmark+2)  
3b36 32 70 fe			ld (debug_mark+2),a  
3b39 18 03			jr .pastdmark  
3b3b ..			.dmark: db "+IT"  
3b3e f1			.pastdmark: pop af  
3b3f			endm  
# End of macro DMARK
3b3f				CALLMONITOR 
3b3f cd fb 19			call break_point_state  
3b42				endm  
# End of macro CALLMONITOR
3b42					endif 
3b42			 
3b42					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b42 cd ea 22			call macro_dsp_valuehl 
3b45				endm 
# End of macro FORTH_DSP_VALUEHL
3b45			 
3b45				; TODO add floating point number detection 
3b45			 
3b45 e5					push hl 
3b46			 
3b46					; destroy value TOS 
3b46			 
3b46					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b46 cd a2 23			call macro_forth_dsp_pop 
3b49				endm 
# End of macro FORTH_DSP_POP
3b49			 
3b49			 
3b49					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b49 cd ea 22			call macro_dsp_valuehl 
3b4c				endm 
# End of macro FORTH_DSP_VALUEHL
3b4c			 
3b4c					; one value on hl get other one back 
3b4c			 
3b4c d1					pop de 
3b4d			 
3b4d					; do the add 
3b4d			 
3b4d 19					add hl,de 
3b4e			 
3b4e					; save it 
3b4e			 
3b4e			;		push hl	 
3b4e			 
3b4e					; 
3b4e			 
3b4e					; destroy value TOS 
3b4e			 
3b4e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b4e cd a2 23			call macro_forth_dsp_pop 
3b51				endm 
# End of macro FORTH_DSP_POP
3b51			 
3b51					; TODO push value back onto stack for another op etc 
3b51			 
3b51			;		pop hl 
3b51			 
3b51			.dot_done: 
3b51 cd f3 20				call forth_push_numhl 
3b54			 
3b54					NEXTW 
3b54 c3 a0 24			jp macro_next 
3b57				endm 
# End of macro NEXTW
3b57			.NEG: 
3b57			 
3b57				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3b57 17				db WORD_SYS_CORE+3             
3b58 9a 3b			dw .DIV            
3b5a 02				db 1 + 1 
3b5b .. 00			db "-",0              
3b5d				endm 
# End of macro CWHEAD
3b5d			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3b5d					if DEBUG_FORTH_WORDS_KEY 
3b5d						DMARK "SUB" 
3b5d f5				push af  
3b5e 3a 72 3b			ld a, (.dmark)  
3b61 32 6e fe			ld (debug_mark),a  
3b64 3a 73 3b			ld a, (.dmark+1)  
3b67 32 6f fe			ld (debug_mark+1),a  
3b6a 3a 74 3b			ld a, (.dmark+2)  
3b6d 32 70 fe			ld (debug_mark+2),a  
3b70 18 03			jr .pastdmark  
3b72 ..			.dmark: db "SUB"  
3b75 f1			.pastdmark: pop af  
3b76			endm  
# End of macro DMARK
3b76						CALLMONITOR 
3b76 cd fb 19			call break_point_state  
3b79				endm  
# End of macro CALLMONITOR
3b79					endif 
3b79			 
3b79			 
3b79				; TODO add floating point number detection 
3b79					; v5 FORTH_DSP_VALUE 
3b79					FORTH_DSP 
3b79 cd b0 22			call macro_forth_dsp 
3b7c				endm 
# End of macro FORTH_DSP
3b7c 7e					ld a,(hl)	; get type of value on TOS 
3b7d fe 02				cp DS_TYPE_INUM  
3b7f 28 03				jr z, .neg_inum 
3b81			 
3b81					NEXTW 
3b81 c3 a0 24			jp macro_next 
3b84				endm 
# End of macro NEXTW
3b84			 
3b84			; float maths 
3b84			 
3b84				if FORTH_ENABLE_FLOATMATH 
3b84					jr .neg_done 
3b84			 
3b84				endif 
3b84					 
3b84			 
3b84			.neg_inum: 
3b84					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b84 cd ea 22			call macro_dsp_valuehl 
3b87				endm 
# End of macro FORTH_DSP_VALUEHL
3b87			 
3b87 e5					push hl 
3b88			 
3b88					; destroy value TOS 
3b88			 
3b88					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b88 cd a2 23			call macro_forth_dsp_pop 
3b8b				endm 
# End of macro FORTH_DSP_POP
3b8b			 
3b8b			 
3b8b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b8b cd ea 22			call macro_dsp_valuehl 
3b8e				endm 
# End of macro FORTH_DSP_VALUEHL
3b8e			 
3b8e					; one value on hl get other one back 
3b8e			 
3b8e d1					pop de 
3b8f			 
3b8f					; do the sub 
3b8f			;		ex de, hl 
3b8f			 
3b8f ed 52				sbc hl,de 
3b91			 
3b91					; save it 
3b91			 
3b91			;		push hl	 
3b91			 
3b91					; 
3b91			 
3b91					; destroy value TOS 
3b91			 
3b91					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b91 cd a2 23			call macro_forth_dsp_pop 
3b94				endm 
# End of macro FORTH_DSP_POP
3b94			 
3b94					; TODO push value back onto stack for another op etc 
3b94			 
3b94			;		pop hl 
3b94			 
3b94 cd f3 20				call forth_push_numhl 
3b97			.neg_done: 
3b97			 
3b97					NEXTW 
3b97 c3 a0 24			jp macro_next 
3b9a				endm 
# End of macro NEXTW
3b9a			.DIV: 
3b9a				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3b9a 18				db WORD_SYS_CORE+4             
3b9b e7 3b			dw .MUL            
3b9d 02				db 1 + 1 
3b9e .. 00			db "/",0              
3ba0				endm 
# End of macro CWHEAD
3ba0			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3ba0					if DEBUG_FORTH_WORDS_KEY 
3ba0						DMARK "DIV" 
3ba0 f5				push af  
3ba1 3a b5 3b			ld a, (.dmark)  
3ba4 32 6e fe			ld (debug_mark),a  
3ba7 3a b6 3b			ld a, (.dmark+1)  
3baa 32 6f fe			ld (debug_mark+1),a  
3bad 3a b7 3b			ld a, (.dmark+2)  
3bb0 32 70 fe			ld (debug_mark+2),a  
3bb3 18 03			jr .pastdmark  
3bb5 ..			.dmark: db "DIV"  
3bb8 f1			.pastdmark: pop af  
3bb9			endm  
# End of macro DMARK
3bb9						CALLMONITOR 
3bb9 cd fb 19			call break_point_state  
3bbc				endm  
# End of macro CALLMONITOR
3bbc					endif 
3bbc				; TODO add floating point number detection 
3bbc					; v5 FORTH_DSP_VALUE 
3bbc					FORTH_DSP 
3bbc cd b0 22			call macro_forth_dsp 
3bbf				endm 
# End of macro FORTH_DSP
3bbf 7e					ld a,(hl)	; get type of value on TOS 
3bc0 fe 02				cp DS_TYPE_INUM  
3bc2 28 03				jr z, .div_inum 
3bc4			 
3bc4				if FORTH_ENABLE_FLOATMATH 
3bc4					jr .div_done 
3bc4			 
3bc4				endif 
3bc4					NEXTW 
3bc4 c3 a0 24			jp macro_next 
3bc7				endm 
# End of macro NEXTW
3bc7			.div_inum: 
3bc7			 
3bc7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bc7 cd ea 22			call macro_dsp_valuehl 
3bca				endm 
# End of macro FORTH_DSP_VALUEHL
3bca			 
3bca e5					push hl    ; to go to bc 
3bcb			 
3bcb					; destroy value TOS 
3bcb			 
3bcb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bcb cd a2 23			call macro_forth_dsp_pop 
3bce				endm 
# End of macro FORTH_DSP_POP
3bce			 
3bce			 
3bce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bce cd ea 22			call macro_dsp_valuehl 
3bd1				endm 
# End of macro FORTH_DSP_VALUEHL
3bd1			 
3bd1					; hl to go to de 
3bd1			 
3bd1 e5					push hl 
3bd2			 
3bd2 c1					pop bc 
3bd3 d1					pop de		 
3bd4			 
3bd4			 
3bd4					if DEBUG_FORTH_MATHS 
3bd4						DMARK "DIV" 
3bd4				CALLMONITOR 
3bd4					endif 
3bd4					; one value on hl but move to a get other one back 
3bd4			 
3bd4			        
3bd4 cd e3 0e			call Div16 
3bd7			 
3bd7			;	push af	 
3bd7 e5				push hl 
3bd8 c5				push bc 
3bd9			 
3bd9					if DEBUG_FORTH_MATHS 
3bd9						DMARK "DI1" 
3bd9				CALLMONITOR 
3bd9					endif 
3bd9			 
3bd9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bd9 cd a2 23			call macro_forth_dsp_pop 
3bdc				endm 
# End of macro FORTH_DSP_POP
3bdc			 
3bdc			 
3bdc			 
3bdc e1					pop hl    ; result 
3bdd			 
3bdd cd f3 20				call forth_push_numhl 
3be0			 
3be0 e1					pop hl    ; reminder 
3be1			;		ld h,0 
3be1			;		ld l,d 
3be1			 
3be1 cd f3 20				call forth_push_numhl 
3be4			.div_done: 
3be4					NEXTW 
3be4 c3 a0 24			jp macro_next 
3be7				endm 
# End of macro NEXTW
3be7			.MUL: 
3be7				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3be7 19				db WORD_SYS_CORE+5             
3be8 2c 3c			dw .MIN            
3bea 02				db 1 + 1 
3beb .. 00			db "*",0              
3bed				endm 
# End of macro CWHEAD
3bed			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3bed				; TODO add floating point number detection 
3bed					if DEBUG_FORTH_WORDS_KEY 
3bed						DMARK "MUL" 
3bed f5				push af  
3bee 3a 02 3c			ld a, (.dmark)  
3bf1 32 6e fe			ld (debug_mark),a  
3bf4 3a 03 3c			ld a, (.dmark+1)  
3bf7 32 6f fe			ld (debug_mark+1),a  
3bfa 3a 04 3c			ld a, (.dmark+2)  
3bfd 32 70 fe			ld (debug_mark+2),a  
3c00 18 03			jr .pastdmark  
3c02 ..			.dmark: db "MUL"  
3c05 f1			.pastdmark: pop af  
3c06			endm  
# End of macro DMARK
3c06						CALLMONITOR 
3c06 cd fb 19			call break_point_state  
3c09				endm  
# End of macro CALLMONITOR
3c09					endif 
3c09					FORTH_DSP 
3c09 cd b0 22			call macro_forth_dsp 
3c0c				endm 
# End of macro FORTH_DSP
3c0c					; v5 FORTH_DSP_VALUE 
3c0c 7e					ld a,(hl)	; get type of value on TOS 
3c0d fe 02				cp DS_TYPE_INUM  
3c0f 28 03				jr z, .mul_inum 
3c11			 
3c11				if FORTH_ENABLE_FLOATMATH 
3c11					jr .mul_done 
3c11			 
3c11				endif 
3c11			 
3c11					NEXTW 
3c11 c3 a0 24			jp macro_next 
3c14				endm 
# End of macro NEXTW
3c14			.mul_inum:	 
3c14			 
3c14					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c14 cd ea 22			call macro_dsp_valuehl 
3c17				endm 
# End of macro FORTH_DSP_VALUEHL
3c17			 
3c17 e5					push hl 
3c18			 
3c18					; destroy value TOS 
3c18			 
3c18					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c18 cd a2 23			call macro_forth_dsp_pop 
3c1b				endm 
# End of macro FORTH_DSP_POP
3c1b			 
3c1b			 
3c1b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c1b cd ea 22			call macro_dsp_valuehl 
3c1e				endm 
# End of macro FORTH_DSP_VALUEHL
3c1e			 
3c1e					; one value on hl but move to a get other one back 
3c1e			 
3c1e 7d					ld a, l 
3c1f			 
3c1f d1					pop de 
3c20			 
3c20					; do the mull 
3c20			;		ex de, hl 
3c20			 
3c20 cd 09 0f				call Mult16 
3c23					; save it 
3c23			 
3c23			;		push hl	 
3c23			 
3c23					; 
3c23			 
3c23					; destroy value TOS 
3c23			 
3c23					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c23 cd a2 23			call macro_forth_dsp_pop 
3c26				endm 
# End of macro FORTH_DSP_POP
3c26			 
3c26					; TODO push value back onto stack for another op etc 
3c26			 
3c26			;		pop hl 
3c26			 
3c26 cd f3 20				call forth_push_numhl 
3c29			 
3c29			.mul_done: 
3c29					NEXTW 
3c29 c3 a0 24			jp macro_next 
3c2c				endm 
# End of macro NEXTW
3c2c			 
3c2c			 
3c2c			 
3c2c			 
3c2c			.MIN: 
3c2c				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3c2c 49				db WORD_SYS_CORE+53             
3c2d ad 3c			dw .MAX            
3c2f 04				db 3 + 1 
3c30 .. 00			db "MIN",0              
3c34				endm 
# End of macro CWHEAD
3c34			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3c34					if DEBUG_FORTH_WORDS_KEY 
3c34						DMARK "MIN" 
3c34 f5				push af  
3c35 3a 49 3c			ld a, (.dmark)  
3c38 32 6e fe			ld (debug_mark),a  
3c3b 3a 4a 3c			ld a, (.dmark+1)  
3c3e 32 6f fe			ld (debug_mark+1),a  
3c41 3a 4b 3c			ld a, (.dmark+2)  
3c44 32 70 fe			ld (debug_mark+2),a  
3c47 18 03			jr .pastdmark  
3c49 ..			.dmark: db "MIN"  
3c4c f1			.pastdmark: pop af  
3c4d			endm  
# End of macro DMARK
3c4d						CALLMONITOR 
3c4d cd fb 19			call break_point_state  
3c50				endm  
# End of macro CALLMONITOR
3c50					endif 
3c50					; get u2 
3c50			 
3c50					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c50 cd ea 22			call macro_dsp_valuehl 
3c53				endm 
# End of macro FORTH_DSP_VALUEHL
3c53			 
3c53 e5					push hl   ; u2 
3c54			 
3c54					; destroy value TOS 
3c54			 
3c54					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c54 cd a2 23			call macro_forth_dsp_pop 
3c57				endm 
# End of macro FORTH_DSP_POP
3c57			 
3c57					; get u1 
3c57			 
3c57					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c57 cd ea 22			call macro_dsp_valuehl 
3c5a				endm 
# End of macro FORTH_DSP_VALUEHL
3c5a			 
3c5a e5					push hl  ; u1 
3c5b			 
3c5b					; destroy value TOS 
3c5b			 
3c5b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c5b cd a2 23			call macro_forth_dsp_pop 
3c5e				endm 
# End of macro FORTH_DSP_POP
3c5e			 
3c5e b7			 or a      ;clear carry flag 
3c5f e1			  pop hl    ; u1 
3c60 d1			  pop de    ; u2 
3c61 e5				push hl   ; saved in case hl is lowest 
3c62 ed 52		  sbc hl,de 
3c64 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3c66			 
3c66 e1				pop hl 
3c67					if DEBUG_FORTH_WORDS 
3c67						DMARK "MIN" 
3c67 f5				push af  
3c68 3a 7c 3c			ld a, (.dmark)  
3c6b 32 6e fe			ld (debug_mark),a  
3c6e 3a 7d 3c			ld a, (.dmark+1)  
3c71 32 6f fe			ld (debug_mark+1),a  
3c74 3a 7e 3c			ld a, (.dmark+2)  
3c77 32 70 fe			ld (debug_mark+2),a  
3c7a 18 03			jr .pastdmark  
3c7c ..			.dmark: db "MIN"  
3c7f f1			.pastdmark: pop af  
3c80			endm  
# End of macro DMARK
3c80						CALLMONITOR 
3c80 cd fb 19			call break_point_state  
3c83				endm  
# End of macro CALLMONITOR
3c83					endif 
3c83 cd f3 20				call forth_push_numhl 
3c86			 
3c86				       NEXTW 
3c86 c3 a0 24			jp macro_next 
3c89				endm 
# End of macro NEXTW
3c89			 
3c89			.mincont:  
3c89 c1				pop bc   ; tidy up 
3c8a eb				ex de , hl  
3c8b					if DEBUG_FORTH_WORDS 
3c8b						DMARK "MI1" 
3c8b f5				push af  
3c8c 3a a0 3c			ld a, (.dmark)  
3c8f 32 6e fe			ld (debug_mark),a  
3c92 3a a1 3c			ld a, (.dmark+1)  
3c95 32 6f fe			ld (debug_mark+1),a  
3c98 3a a2 3c			ld a, (.dmark+2)  
3c9b 32 70 fe			ld (debug_mark+2),a  
3c9e 18 03			jr .pastdmark  
3ca0 ..			.dmark: db "MI1"  
3ca3 f1			.pastdmark: pop af  
3ca4			endm  
# End of macro DMARK
3ca4						CALLMONITOR 
3ca4 cd fb 19			call break_point_state  
3ca7				endm  
# End of macro CALLMONITOR
3ca7					endif 
3ca7 cd f3 20				call forth_push_numhl 
3caa			 
3caa				       NEXTW 
3caa c3 a0 24			jp macro_next 
3cad				endm 
# End of macro NEXTW
3cad			.MAX: 
3cad				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3cad 4a				db WORD_SYS_CORE+54             
3cae 2e 3d			dw .RND16            
3cb0 04				db 3 + 1 
3cb1 .. 00			db "MAX",0              
3cb5				endm 
# End of macro CWHEAD
3cb5			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3cb5					if DEBUG_FORTH_WORDS_KEY 
3cb5						DMARK "MAX" 
3cb5 f5				push af  
3cb6 3a ca 3c			ld a, (.dmark)  
3cb9 32 6e fe			ld (debug_mark),a  
3cbc 3a cb 3c			ld a, (.dmark+1)  
3cbf 32 6f fe			ld (debug_mark+1),a  
3cc2 3a cc 3c			ld a, (.dmark+2)  
3cc5 32 70 fe			ld (debug_mark+2),a  
3cc8 18 03			jr .pastdmark  
3cca ..			.dmark: db "MAX"  
3ccd f1			.pastdmark: pop af  
3cce			endm  
# End of macro DMARK
3cce						CALLMONITOR 
3cce cd fb 19			call break_point_state  
3cd1				endm  
# End of macro CALLMONITOR
3cd1					endif 
3cd1					; get u2 
3cd1			 
3cd1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cd1 cd ea 22			call macro_dsp_valuehl 
3cd4				endm 
# End of macro FORTH_DSP_VALUEHL
3cd4			 
3cd4 e5					push hl   ; u2 
3cd5			 
3cd5					; destroy value TOS 
3cd5			 
3cd5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cd5 cd a2 23			call macro_forth_dsp_pop 
3cd8				endm 
# End of macro FORTH_DSP_POP
3cd8			 
3cd8					; get u1 
3cd8			 
3cd8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cd8 cd ea 22			call macro_dsp_valuehl 
3cdb				endm 
# End of macro FORTH_DSP_VALUEHL
3cdb			 
3cdb e5					push hl  ; u1 
3cdc			 
3cdc					; destroy value TOS 
3cdc			 
3cdc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cdc cd a2 23			call macro_forth_dsp_pop 
3cdf				endm 
# End of macro FORTH_DSP_POP
3cdf			 
3cdf b7			 or a      ;clear carry flag 
3ce0 e1			  pop hl    ; u1 
3ce1 d1			  pop de    ; u2 
3ce2 e5				push hl   ; saved in case hl is lowest 
3ce3 ed 52		  sbc hl,de 
3ce5 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3ce7			 
3ce7 e1				pop hl 
3ce8					if DEBUG_FORTH_WORDS 
3ce8						DMARK "MAX" 
3ce8 f5				push af  
3ce9 3a fd 3c			ld a, (.dmark)  
3cec 32 6e fe			ld (debug_mark),a  
3cef 3a fe 3c			ld a, (.dmark+1)  
3cf2 32 6f fe			ld (debug_mark+1),a  
3cf5 3a ff 3c			ld a, (.dmark+2)  
3cf8 32 70 fe			ld (debug_mark+2),a  
3cfb 18 03			jr .pastdmark  
3cfd ..			.dmark: db "MAX"  
3d00 f1			.pastdmark: pop af  
3d01			endm  
# End of macro DMARK
3d01						CALLMONITOR 
3d01 cd fb 19			call break_point_state  
3d04				endm  
# End of macro CALLMONITOR
3d04					endif 
3d04 cd f3 20				call forth_push_numhl 
3d07			 
3d07				       NEXTW 
3d07 c3 a0 24			jp macro_next 
3d0a				endm 
# End of macro NEXTW
3d0a			 
3d0a			.maxcont:  
3d0a c1				pop bc   ; tidy up 
3d0b eb				ex de , hl  
3d0c					if DEBUG_FORTH_WORDS 
3d0c						DMARK "MA1" 
3d0c f5				push af  
3d0d 3a 21 3d			ld a, (.dmark)  
3d10 32 6e fe			ld (debug_mark),a  
3d13 3a 22 3d			ld a, (.dmark+1)  
3d16 32 6f fe			ld (debug_mark+1),a  
3d19 3a 23 3d			ld a, (.dmark+2)  
3d1c 32 70 fe			ld (debug_mark+2),a  
3d1f 18 03			jr .pastdmark  
3d21 ..			.dmark: db "MA1"  
3d24 f1			.pastdmark: pop af  
3d25			endm  
# End of macro DMARK
3d25						CALLMONITOR 
3d25 cd fb 19			call break_point_state  
3d28				endm  
# End of macro CALLMONITOR
3d28					endif 
3d28 cd f3 20				call forth_push_numhl 
3d2b				       NEXTW 
3d2b c3 a0 24			jp macro_next 
3d2e				endm 
# End of macro NEXTW
3d2e			 
3d2e			.RND16: 
3d2e				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3d2e 4e				db WORD_SYS_CORE+58             
3d2f 5d 3d			dw .RND8            
3d31 06				db 5 + 1 
3d32 .. 00			db "RND16",0              
3d38				endm 
# End of macro CWHEAD
3d38			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3d38					if DEBUG_FORTH_WORDS_KEY 
3d38						DMARK "R16" 
3d38 f5				push af  
3d39 3a 4d 3d			ld a, (.dmark)  
3d3c 32 6e fe			ld (debug_mark),a  
3d3f 3a 4e 3d			ld a, (.dmark+1)  
3d42 32 6f fe			ld (debug_mark+1),a  
3d45 3a 4f 3d			ld a, (.dmark+2)  
3d48 32 70 fe			ld (debug_mark+2),a  
3d4b 18 03			jr .pastdmark  
3d4d ..			.dmark: db "R16"  
3d50 f1			.pastdmark: pop af  
3d51			endm  
# End of macro DMARK
3d51						CALLMONITOR 
3d51 cd fb 19			call break_point_state  
3d54				endm  
# End of macro CALLMONITOR
3d54					endif 
3d54 cd ad 0e				call prng16  
3d57 cd f3 20				call forth_push_numhl 
3d5a				       NEXTW 
3d5a c3 a0 24			jp macro_next 
3d5d				endm 
# End of macro NEXTW
3d5d			.RND8: 
3d5d				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3d5d 60				db WORD_SYS_CORE+76             
3d5e 92 3d			dw .RND            
3d60 05				db 4 + 1 
3d61 .. 00			db "RND8",0              
3d66				endm 
# End of macro CWHEAD
3d66			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3d66					if DEBUG_FORTH_WORDS_KEY 
3d66						DMARK "RN8" 
3d66 f5				push af  
3d67 3a 7b 3d			ld a, (.dmark)  
3d6a 32 6e fe			ld (debug_mark),a  
3d6d 3a 7c 3d			ld a, (.dmark+1)  
3d70 32 6f fe			ld (debug_mark+1),a  
3d73 3a 7d 3d			ld a, (.dmark+2)  
3d76 32 70 fe			ld (debug_mark+2),a  
3d79 18 03			jr .pastdmark  
3d7b ..			.dmark: db "RN8"  
3d7e f1			.pastdmark: pop af  
3d7f			endm  
# End of macro DMARK
3d7f						CALLMONITOR 
3d7f cd fb 19			call break_point_state  
3d82				endm  
# End of macro CALLMONITOR
3d82					endif 
3d82 2a ac fb				ld hl,(xrandc) 
3d85 23					inc hl 
3d86 cd c7 0e				call xrnd 
3d89 6f					ld l,a	 
3d8a 26 00				ld h,0 
3d8c cd f3 20				call forth_push_numhl 
3d8f				       NEXTW 
3d8f c3 a0 24			jp macro_next 
3d92				endm 
# End of macro NEXTW
3d92			.RND: 
3d92				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3d92 60				db WORD_SYS_CORE+76             
3d93 98 3e			dw .ENDMATHS            
3d95 04				db 3 + 1 
3d96 .. 00			db "RND",0              
3d9a				endm 
# End of macro CWHEAD
3d9a			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3d9a			 
3d9a					if DEBUG_FORTH_WORDS_KEY 
3d9a						DMARK "RND" 
3d9a f5				push af  
3d9b 3a af 3d			ld a, (.dmark)  
3d9e 32 6e fe			ld (debug_mark),a  
3da1 3a b0 3d			ld a, (.dmark+1)  
3da4 32 6f fe			ld (debug_mark+1),a  
3da7 3a b1 3d			ld a, (.dmark+2)  
3daa 32 70 fe			ld (debug_mark+2),a  
3dad 18 03			jr .pastdmark  
3daf ..			.dmark: db "RND"  
3db2 f1			.pastdmark: pop af  
3db3			endm  
# End of macro DMARK
3db3						CALLMONITOR 
3db3 cd fb 19			call break_point_state  
3db6				endm  
# End of macro CALLMONITOR
3db6					endif 
3db6					 
3db6					FORTH_DSP_VALUEHL    ; upper range 
3db6 cd ea 22			call macro_dsp_valuehl 
3db9				endm 
# End of macro FORTH_DSP_VALUEHL
3db9			 
3db9 22 b0 fb				ld (LFSRSeed), hl	 
3dbc			 
3dbc					if DEBUG_FORTH_WORDS 
3dbc						DMARK "RN1" 
3dbc f5				push af  
3dbd 3a d1 3d			ld a, (.dmark)  
3dc0 32 6e fe			ld (debug_mark),a  
3dc3 3a d2 3d			ld a, (.dmark+1)  
3dc6 32 6f fe			ld (debug_mark+1),a  
3dc9 3a d3 3d			ld a, (.dmark+2)  
3dcc 32 70 fe			ld (debug_mark+2),a  
3dcf 18 03			jr .pastdmark  
3dd1 ..			.dmark: db "RN1"  
3dd4 f1			.pastdmark: pop af  
3dd5			endm  
# End of macro DMARK
3dd5						CALLMONITOR 
3dd5 cd fb 19			call break_point_state  
3dd8				endm  
# End of macro CALLMONITOR
3dd8					endif 
3dd8					FORTH_DSP_POP 
3dd8 cd a2 23			call macro_forth_dsp_pop 
3ddb				endm 
# End of macro FORTH_DSP_POP
3ddb			 
3ddb					FORTH_DSP_VALUEHL    ; low range 
3ddb cd ea 22			call macro_dsp_valuehl 
3dde				endm 
# End of macro FORTH_DSP_VALUEHL
3dde			 
3dde					if DEBUG_FORTH_WORDS 
3dde						DMARK "RN2" 
3dde f5				push af  
3ddf 3a f3 3d			ld a, (.dmark)  
3de2 32 6e fe			ld (debug_mark),a  
3de5 3a f4 3d			ld a, (.dmark+1)  
3de8 32 6f fe			ld (debug_mark+1),a  
3deb 3a f5 3d			ld a, (.dmark+2)  
3dee 32 70 fe			ld (debug_mark+2),a  
3df1 18 03			jr .pastdmark  
3df3 ..			.dmark: db "RN2"  
3df6 f1			.pastdmark: pop af  
3df7			endm  
# End of macro DMARK
3df7						CALLMONITOR 
3df7 cd fb 19			call break_point_state  
3dfa				endm  
# End of macro CALLMONITOR
3dfa					endif 
3dfa 22 b2 fb				ld (LFSRSeed+2), hl 
3dfd			 
3dfd					FORTH_DSP_POP 
3dfd cd a2 23			call macro_forth_dsp_pop 
3e00				endm 
# End of macro FORTH_DSP_POP
3e00			 
3e00 e5					push hl 
3e01			 
3e01 e1			.inrange:	pop hl 
3e02 cd ad 0e				call prng16  
3e05					if DEBUG_FORTH_WORDS 
3e05						DMARK "RN3" 
3e05 f5				push af  
3e06 3a 1a 3e			ld a, (.dmark)  
3e09 32 6e fe			ld (debug_mark),a  
3e0c 3a 1b 3e			ld a, (.dmark+1)  
3e0f 32 6f fe			ld (debug_mark+1),a  
3e12 3a 1c 3e			ld a, (.dmark+2)  
3e15 32 70 fe			ld (debug_mark+2),a  
3e18 18 03			jr .pastdmark  
3e1a ..			.dmark: db "RN3"  
3e1d f1			.pastdmark: pop af  
3e1e			endm  
# End of macro DMARK
3e1e						CALLMONITOR 
3e1e cd fb 19			call break_point_state  
3e21				endm  
# End of macro CALLMONITOR
3e21					endif 
3e21					 
3e21					; if the range is 8bit knock out the high byte 
3e21			 
3e21 ed 5b b0 fb			ld de, (LFSRSeed)     ; check high level 
3e25			 
3e25 3e 00				ld a, 0 
3e27 ba					cp d  
3e28 20 1e				jr nz, .hirange 
3e2a 26 00				ld h, 0   ; knock it down to 8bit 
3e2c			 
3e2c					if DEBUG_FORTH_WORDS 
3e2c						DMARK "RNk" 
3e2c f5				push af  
3e2d 3a 41 3e			ld a, (.dmark)  
3e30 32 6e fe			ld (debug_mark),a  
3e33 3a 42 3e			ld a, (.dmark+1)  
3e36 32 6f fe			ld (debug_mark+1),a  
3e39 3a 43 3e			ld a, (.dmark+2)  
3e3c 32 70 fe			ld (debug_mark+2),a  
3e3f 18 03			jr .pastdmark  
3e41 ..			.dmark: db "RNk"  
3e44 f1			.pastdmark: pop af  
3e45			endm  
# End of macro DMARK
3e45						CALLMONITOR 
3e45 cd fb 19			call break_point_state  
3e48				endm  
# End of macro CALLMONITOR
3e48					endif 
3e48			.hirange:   
3e48 e5					push hl  
3e49 b7					or a  
3e4a ed 52		                sbc hl, de 
3e4c			 
3e4c					;call cmp16 
3e4c			 
3e4c 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3e4e e1					pop hl 
3e4f e5					push hl 
3e50			 
3e50					if DEBUG_FORTH_WORDS 
3e50						DMARK "RN4" 
3e50 f5				push af  
3e51 3a 65 3e			ld a, (.dmark)  
3e54 32 6e fe			ld (debug_mark),a  
3e57 3a 66 3e			ld a, (.dmark+1)  
3e5a 32 6f fe			ld (debug_mark+1),a  
3e5d 3a 67 3e			ld a, (.dmark+2)  
3e60 32 70 fe			ld (debug_mark+2),a  
3e63 18 03			jr .pastdmark  
3e65 ..			.dmark: db "RN4"  
3e68 f1			.pastdmark: pop af  
3e69			endm  
# End of macro DMARK
3e69						CALLMONITOR 
3e69 cd fb 19			call break_point_state  
3e6c				endm  
# End of macro CALLMONITOR
3e6c					endif 
3e6c ed 5b b2 fb			ld de, (LFSRSeed+2)   ; check low range 
3e70					;call cmp16 
3e70				 
3e70 b7					or a  
3e71 ed 52		                sbc hl, de 
3e73 38 8c				jr c, .inrange 
3e75			 
3e75 e1					pop hl 
3e76					 
3e76					if DEBUG_FORTH_WORDS 
3e76						DMARK "RNd" 
3e76 f5				push af  
3e77 3a 8b 3e			ld a, (.dmark)  
3e7a 32 6e fe			ld (debug_mark),a  
3e7d 3a 8c 3e			ld a, (.dmark+1)  
3e80 32 6f fe			ld (debug_mark+1),a  
3e83 3a 8d 3e			ld a, (.dmark+2)  
3e86 32 70 fe			ld (debug_mark+2),a  
3e89 18 03			jr .pastdmark  
3e8b ..			.dmark: db "RNd"  
3e8e f1			.pastdmark: pop af  
3e8f			endm  
# End of macro DMARK
3e8f						CALLMONITOR 
3e8f cd fb 19			call break_point_state  
3e92				endm  
# End of macro CALLMONITOR
3e92					endif 
3e92			 
3e92			 
3e92 cd f3 20				call forth_push_numhl 
3e95				       NEXTW 
3e95 c3 a0 24			jp macro_next 
3e98				endm 
# End of macro NEXTW
3e98			 
3e98			.ENDMATHS: 
3e98			 
3e98			; eof 
3e98			 
# End of file forth_words_maths.asm
3e98			include "forth_words_display.asm" 
3e98			 
3e98			; | ## Display Words 
3e98			 
3e98			.ACT: 
3e98			 
3e98				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3e98 62				db WORD_SYS_CORE+78             
3e99 e4 3e			dw .INFO            
3e9b 07				db 6 + 1 
3e9c .. 00			db "ACTIVE",0              
3ea3				endm 
# End of macro CWHEAD
3ea3			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3ea3			;  
3ea3			; | | e.g. $ff $00 do active . $01 pause loop 
3ea3			 
3ea3					if DEBUG_FORTH_WORDS_KEY 
3ea3						DMARK "ACT" 
3ea3 f5				push af  
3ea4 3a b8 3e			ld a, (.dmark)  
3ea7 32 6e fe			ld (debug_mark),a  
3eaa 3a b9 3e			ld a, (.dmark+1)  
3ead 32 6f fe			ld (debug_mark+1),a  
3eb0 3a ba 3e			ld a, (.dmark+2)  
3eb3 32 70 fe			ld (debug_mark+2),a  
3eb6 18 03			jr .pastdmark  
3eb8 ..			.dmark: db "ACT"  
3ebb f1			.pastdmark: pop af  
3ebc			endm  
# End of macro DMARK
3ebc						CALLMONITOR 
3ebc cd fb 19			call break_point_state  
3ebf				endm  
# End of macro CALLMONITOR
3ebf					endif 
3ebf cd a9 0c				call active 
3ec2					if DEBUG_FORTH_WORDS 
3ec2						DMARK "ACp" 
3ec2 f5				push af  
3ec3 3a d7 3e			ld a, (.dmark)  
3ec6 32 6e fe			ld (debug_mark),a  
3ec9 3a d8 3e			ld a, (.dmark+1)  
3ecc 32 6f fe			ld (debug_mark+1),a  
3ecf 3a d9 3e			ld a, (.dmark+2)  
3ed2 32 70 fe			ld (debug_mark+2),a  
3ed5 18 03			jr .pastdmark  
3ed7 ..			.dmark: db "ACp"  
3eda f1			.pastdmark: pop af  
3edb			endm  
# End of macro DMARK
3edb						CALLMONITOR 
3edb cd fb 19			call break_point_state  
3ede				endm  
# End of macro CALLMONITOR
3ede					endif 
3ede cd 61 21				call forth_push_str 
3ee1			 
3ee1					NEXTW 
3ee1 c3 a0 24			jp macro_next 
3ee4				endm 
# End of macro NEXTW
3ee4			.INFO: 
3ee4			 
3ee4				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3ee4 62				db WORD_SYS_CORE+78             
3ee5 01 3f			dw .ATP            
3ee7 05				db 4 + 1 
3ee8 .. 00			db "INFO",0              
3eed				endm 
# End of macro CWHEAD
3eed			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3eed					FORTH_DSP_VALUEHL 
3eed cd ea 22			call macro_dsp_valuehl 
3ef0				endm 
# End of macro FORTH_DSP_VALUEHL
3ef0			 
3ef0					FORTH_DSP_POP 
3ef0 cd a2 23			call macro_forth_dsp_pop 
3ef3				endm 
# End of macro FORTH_DSP_POP
3ef3			 
3ef3 e5					push hl 
3ef4			 
3ef4					FORTH_DSP_VALUEHL 
3ef4 cd ea 22			call macro_dsp_valuehl 
3ef7				endm 
# End of macro FORTH_DSP_VALUEHL
3ef7			 
3ef7					FORTH_DSP_POP 
3ef7 cd a2 23			call macro_forth_dsp_pop 
3efa				endm 
# End of macro FORTH_DSP_POP
3efa			 
3efa d1					pop de 
3efb			 
3efb cd e3 0c				call info_panel 
3efe			 
3efe			 
3efe					NEXTW 
3efe c3 a0 24			jp macro_next 
3f01				endm 
# End of macro NEXTW
3f01			.ATP: 
3f01				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3f01 62				db WORD_SYS_CORE+78             
3f02 78 3f			dw .FB            
3f04 04				db 3 + 1 
3f05 .. 00			db "AT?",0              
3f09				endm 
# End of macro CWHEAD
3f09			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3f09					if DEBUG_FORTH_WORDS_KEY 
3f09						DMARK "AT?" 
3f09 f5				push af  
3f0a 3a 1e 3f			ld a, (.dmark)  
3f0d 32 6e fe			ld (debug_mark),a  
3f10 3a 1f 3f			ld a, (.dmark+1)  
3f13 32 6f fe			ld (debug_mark+1),a  
3f16 3a 20 3f			ld a, (.dmark+2)  
3f19 32 70 fe			ld (debug_mark+2),a  
3f1c 18 03			jr .pastdmark  
3f1e ..			.dmark: db "AT?"  
3f21 f1			.pastdmark: pop af  
3f22			endm  
# End of macro DMARK
3f22						CALLMONITOR 
3f22 cd fb 19			call break_point_state  
3f25				endm  
# End of macro CALLMONITOR
3f25					endif 
3f25 3a 61 fa				ld a, (f_cursor_ptr) 
3f28			 
3f28			if DEBUG_FORTH_WORDS 
3f28				DMARK "AT?" 
3f28 f5				push af  
3f29 3a 3d 3f			ld a, (.dmark)  
3f2c 32 6e fe			ld (debug_mark),a  
3f2f 3a 3e 3f			ld a, (.dmark+1)  
3f32 32 6f fe			ld (debug_mark+1),a  
3f35 3a 3f 3f			ld a, (.dmark+2)  
3f38 32 70 fe			ld (debug_mark+2),a  
3f3b 18 03			jr .pastdmark  
3f3d ..			.dmark: db "AT?"  
3f40 f1			.pastdmark: pop af  
3f41			endm  
# End of macro DMARK
3f41				CALLMONITOR 
3f41 cd fb 19			call break_point_state  
3f44				endm  
# End of macro CALLMONITOR
3f44			endif	 
3f44					; count the number of rows 
3f44			 
3f44 06 00				ld b, 0 
3f46 4f			.atpr:		ld c, a    ; save in case we go below zero 
3f47 d6 28				sub display_cols 
3f49 f2 4f 3f				jp p, .atprunder 
3f4c 04					inc b 
3f4d 18 f7				jr .atpr 
3f4f			.atprunder:	 
3f4f			if DEBUG_FORTH_WORDS 
3f4f				DMARK "A?2" 
3f4f f5				push af  
3f50 3a 64 3f			ld a, (.dmark)  
3f53 32 6e fe			ld (debug_mark),a  
3f56 3a 65 3f			ld a, (.dmark+1)  
3f59 32 6f fe			ld (debug_mark+1),a  
3f5c 3a 66 3f			ld a, (.dmark+2)  
3f5f 32 70 fe			ld (debug_mark+2),a  
3f62 18 03			jr .pastdmark  
3f64 ..			.dmark: db "A?2"  
3f67 f1			.pastdmark: pop af  
3f68			endm  
# End of macro DMARK
3f68				CALLMONITOR 
3f68 cd fb 19			call break_point_state  
3f6b				endm  
# End of macro CALLMONITOR
3f6b			endif	 
3f6b 26 00				ld h, 0 
3f6d 69					ld l, c 
3f6e cd f3 20				call forth_push_numhl 
3f71 68					ld l, b  
3f72 cd f3 20				call forth_push_numhl 
3f75			 
3f75			 
3f75				NEXTW 
3f75 c3 a0 24			jp macro_next 
3f78				endm 
# End of macro NEXTW
3f78			 
3f78			.FB: 
3f78				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3f78 1b				db WORD_SYS_CORE+7             
3f79 c6 3f			dw .EMIT            
3f7b 03				db 2 + 1 
3f7c .. 00			db "FB",0              
3f7f				endm 
# End of macro CWHEAD
3f7f			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3f7f			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3f7f			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3f7f			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3f7f					if DEBUG_FORTH_WORDS_KEY 
3f7f						DMARK "FB." 
3f7f f5				push af  
3f80 3a 94 3f			ld a, (.dmark)  
3f83 32 6e fe			ld (debug_mark),a  
3f86 3a 95 3f			ld a, (.dmark+1)  
3f89 32 6f fe			ld (debug_mark+1),a  
3f8c 3a 96 3f			ld a, (.dmark+2)  
3f8f 32 70 fe			ld (debug_mark+2),a  
3f92 18 03			jr .pastdmark  
3f94 ..			.dmark: db "FB."  
3f97 f1			.pastdmark: pop af  
3f98			endm  
# End of macro DMARK
3f98						CALLMONITOR 
3f98 cd fb 19			call break_point_state  
3f9b				endm  
# End of macro CALLMONITOR
3f9b					endif 
3f9b			 
3f9b					FORTH_DSP_VALUEHL 
3f9b cd ea 22			call macro_dsp_valuehl 
3f9e				endm 
# End of macro FORTH_DSP_VALUEHL
3f9e			 
3f9e 7d					ld a, l 
3f9f fe 01				cp 1 
3fa1 20 05				jr nz, .fbn1 
3fa3 21 13 fd				ld hl, display_fb1 
3fa6 18 15				jr .fbset 
3fa8 fe 02		.fbn1:		cp 2 
3faa 20 05				jr nz, .fbn2 
3fac 21 d1 fb				ld hl, display_fb2 
3faf 18 0c				jr .fbset 
3fb1 fe 03		.fbn2:		cp 3 
3fb3 20 05				jr nz, .fbn3 
3fb5 21 72 fc				ld hl, display_fb3 
3fb8 18 03				jr .fbset 
3fba			.fbn3:		 ; if invalid number select first 
3fba 21 13 fd				ld hl, display_fb1 
3fbd 22 cf fb		.fbset:		ld (display_fb_active), hl 
3fc0			 
3fc0					FORTH_DSP_POP 
3fc0 cd a2 23			call macro_forth_dsp_pop 
3fc3				endm 
# End of macro FORTH_DSP_POP
3fc3			 
3fc3					NEXTW 
3fc3 c3 a0 24			jp macro_next 
3fc6				endm 
# End of macro NEXTW
3fc6			 
3fc6			 
3fc6			.EMIT: 
3fc6				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3fc6 1b				db WORD_SYS_CORE+7             
3fc7 17 40			dw .DOTH            
3fc9 05				db 4 + 1 
3fca .. 00			db "EMIT",0              
3fcf				endm 
# End of macro CWHEAD
3fcf			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3fcf					; get value off TOS and display it 
3fcf			 
3fcf					if DEBUG_FORTH_WORDS_KEY 
3fcf						DMARK "EMT" 
3fcf f5				push af  
3fd0 3a e4 3f			ld a, (.dmark)  
3fd3 32 6e fe			ld (debug_mark),a  
3fd6 3a e5 3f			ld a, (.dmark+1)  
3fd9 32 6f fe			ld (debug_mark+1),a  
3fdc 3a e6 3f			ld a, (.dmark+2)  
3fdf 32 70 fe			ld (debug_mark+2),a  
3fe2 18 03			jr .pastdmark  
3fe4 ..			.dmark: db "EMT"  
3fe7 f1			.pastdmark: pop af  
3fe8			endm  
# End of macro DMARK
3fe8						CALLMONITOR 
3fe8 cd fb 19			call break_point_state  
3feb				endm  
# End of macro CALLMONITOR
3feb					endif 
3feb			 
3feb					FORTH_DSP_VALUEHL 
3feb cd ea 22			call macro_dsp_valuehl 
3fee				endm 
# End of macro FORTH_DSP_VALUEHL
3fee			 
3fee 7d					ld a,l 
3fef			 
3fef					; TODO write to display 
3fef			 
3fef 32 c2 f3				ld (os_input), a 
3ff2 3e 00				ld a, 0 
3ff4 32 c3 f3				ld (os_input+1), a 
3ff7					 
3ff7 3a 61 fa				ld a, (f_cursor_ptr) 
3ffa 11 c2 f3				ld de, os_input 
3ffd cd 65 0d				call str_at_display 
4000			 
4000			 
4000 3a 3f fa				ld a,(cli_autodisplay) 
4003 fe 00				cp 0 
4005 28 03				jr z, .enoupdate 
4007 cd 75 0d						call update_display 
400a					.enoupdate: 
400a			 
400a 3a 61 fa				ld a, (f_cursor_ptr) 
400d 3c					inc a 
400e 32 61 fa				ld (f_cursor_ptr), a   ; save new pos 
4011			 
4011			 
4011					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4011 cd a2 23			call macro_forth_dsp_pop 
4014				endm 
# End of macro FORTH_DSP_POP
4014			  
4014			 
4014					NEXTW 
4014 c3 a0 24			jp macro_next 
4017				endm 
# End of macro NEXTW
4017			.DOTH: 
4017				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
4017 1c				db WORD_SYS_CORE+8             
4018 47 40			dw .DOTF            
401a 03				db 2 + 1 
401b .. 00			db ".-",0              
401e				endm 
# End of macro CWHEAD
401e			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
401e					; get value off TOS and display it 
401e					if DEBUG_FORTH_WORDS_KEY 
401e						DMARK "DTD" 
401e f5				push af  
401f 3a 33 40			ld a, (.dmark)  
4022 32 6e fe			ld (debug_mark),a  
4025 3a 34 40			ld a, (.dmark+1)  
4028 32 6f fe			ld (debug_mark+1),a  
402b 3a 35 40			ld a, (.dmark+2)  
402e 32 70 fe			ld (debug_mark+2),a  
4031 18 03			jr .pastdmark  
4033 ..			.dmark: db "DTD"  
4036 f1			.pastdmark: pop af  
4037			endm  
# End of macro DMARK
4037						CALLMONITOR 
4037 cd fb 19			call break_point_state  
403a				endm  
# End of macro CALLMONITOR
403a					endif 
403a 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
403c 3e 00			ld a, 0 
403e 32 40 fa			ld (cli_mvdot), a 
4041 c3 9e 40			jp .dotgo 
4044				NEXTW 
4044 c3 a0 24			jp macro_next 
4047				endm 
# End of macro NEXTW
4047			.DOTF: 
4047				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
4047 1c				db WORD_SYS_CORE+8             
4048 75 40			dw .DOT            
404a 03				db 2 + 1 
404b .. 00			db ".>",0              
404e				endm 
# End of macro CWHEAD
404e			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
404e					; get value off TOS and display it 
404e			        ; TODO BUG adds extra spaces 
404e			        ; TODO BUG handle numerics? 
404e					if DEBUG_FORTH_WORDS_KEY 
404e						DMARK "DTC" 
404e f5				push af  
404f 3a 63 40			ld a, (.dmark)  
4052 32 6e fe			ld (debug_mark),a  
4055 3a 64 40			ld a, (.dmark+1)  
4058 32 6f fe			ld (debug_mark+1),a  
405b 3a 65 40			ld a, (.dmark+2)  
405e 32 70 fe			ld (debug_mark+2),a  
4061 18 03			jr .pastdmark  
4063 ..			.dmark: db "DTC"  
4066 f1			.pastdmark: pop af  
4067			endm  
# End of macro DMARK
4067						CALLMONITOR 
4067 cd fb 19			call break_point_state  
406a				endm  
# End of macro CALLMONITOR
406a					endif 
406a 3e 01			ld a, 1 
406c 32 40 fa			ld (cli_mvdot), a 
406f c3 9e 40			jp .dotgo 
4072				NEXTW 
4072 c3 a0 24			jp macro_next 
4075				endm 
# End of macro NEXTW
4075			 
4075			.DOT: 
4075				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
4075 1c				db WORD_SYS_CORE+8             
4076 51 42			dw .CLS            
4078 02				db 1 + 1 
4079 .. 00			db ".",0              
407b				endm 
# End of macro CWHEAD
407b			        ; | . ( u -- ) Display TOS | DONE 
407b					; get value off TOS and display it 
407b			 
407b					if DEBUG_FORTH_WORDS_KEY 
407b						DMARK "DOT" 
407b f5				push af  
407c 3a 90 40			ld a, (.dmark)  
407f 32 6e fe			ld (debug_mark),a  
4082 3a 91 40			ld a, (.dmark+1)  
4085 32 6f fe			ld (debug_mark+1),a  
4088 3a 92 40			ld a, (.dmark+2)  
408b 32 70 fe			ld (debug_mark+2),a  
408e 18 03			jr .pastdmark  
4090 ..			.dmark: db "DOT"  
4093 f1			.pastdmark: pop af  
4094			endm  
# End of macro DMARK
4094						CALLMONITOR 
4094 cd fb 19			call break_point_state  
4097				endm  
# End of macro CALLMONITOR
4097					endif 
4097 3e 00			ld a, 0 
4099 32 40 fa			ld (cli_mvdot), a 
409c 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
409e				 
409e			 
409e			.dotgo: 
409e			 
409e			; move up type to on stack for parserv5 
409e					FORTH_DSP 
409e cd b0 22			call macro_forth_dsp 
40a1				endm 
# End of macro FORTH_DSP
40a1				;FORTH_DSP_VALUE  
40a1			 
40a1			if DEBUG_FORTH_DOT 
40a1				DMARK "DOT" 
40a1 f5				push af  
40a2 3a b6 40			ld a, (.dmark)  
40a5 32 6e fe			ld (debug_mark),a  
40a8 3a b7 40			ld a, (.dmark+1)  
40ab 32 6f fe			ld (debug_mark+1),a  
40ae 3a b8 40			ld a, (.dmark+2)  
40b1 32 70 fe			ld (debug_mark+2),a  
40b4 18 03			jr .pastdmark  
40b6 ..			.dmark: db "DOT"  
40b9 f1			.pastdmark: pop af  
40ba			endm  
# End of macro DMARK
40ba				CALLMONITOR 
40ba cd fb 19			call break_point_state  
40bd				endm  
# End of macro CALLMONITOR
40bd			endif	 
40bd			;		.print: 
40bd			 
40bd 7e				ld a,(hl)  ; work out what type of value is on the TOS 
40be 23				inc hl   ; position to the actual value 
40bf fe 01			cp DS_TYPE_STR 
40c1 20 06			jr nz, .dotnum1  
40c3			 
40c3			; display string 
40c3				FORTH_DSP_VALUE  
40c3 cd d3 22			call macro_forth_dsp_value 
40c6				endm 
# End of macro FORTH_DSP_VALUE
40c6 eb				ex de,hl 
40c7 18 49			jr .dotwrite 
40c9			 
40c9			.dotnum1: 
40c9 fe 02			cp DS_TYPE_INUM 
40cb 20 44			jr nz, .dotflot 
40cd			 
40cd			 
40cd			; display number 
40cd			 
40cd			;	push hl 
40cd			;	call clear_display 
40cd			;	pop hl 
40cd			 
40cd 5e				ld e, (hl) 
40ce 23				inc hl 
40cf 56				ld d, (hl) 
40d0 21 c4 f1			ld hl, scratch 
40d3			if DEBUG_FORTH_DOT 
40d3				DMARK "DT1" 
40d3 f5				push af  
40d4 3a e8 40			ld a, (.dmark)  
40d7 32 6e fe			ld (debug_mark),a  
40da 3a e9 40			ld a, (.dmark+1)  
40dd 32 6f fe			ld (debug_mark+1),a  
40e0 3a ea 40			ld a, (.dmark+2)  
40e3 32 70 fe			ld (debug_mark+2),a  
40e6 18 03			jr .pastdmark  
40e8 ..			.dmark: db "DT1"  
40eb f1			.pastdmark: pop af  
40ec			endm  
# End of macro DMARK
40ec				CALLMONITOR 
40ec cd fb 19			call break_point_state  
40ef				endm  
# End of macro CALLMONITOR
40ef			endif	 
40ef			 
40ef cd 93 13			call uitoa_16 
40f2 eb				ex de,hl 
40f3			 
40f3			if DEBUG_FORTH_DOT 
40f3				DMARK "DT2" 
40f3 f5				push af  
40f4 3a 08 41			ld a, (.dmark)  
40f7 32 6e fe			ld (debug_mark),a  
40fa 3a 09 41			ld a, (.dmark+1)  
40fd 32 6f fe			ld (debug_mark+1),a  
4100 3a 0a 41			ld a, (.dmark+2)  
4103 32 70 fe			ld (debug_mark+2),a  
4106 18 03			jr .pastdmark  
4108 ..			.dmark: db "DT2"  
410b f1			.pastdmark: pop af  
410c			endm  
# End of macro DMARK
410c				CALLMONITOR 
410c cd fb 19			call break_point_state  
410f				endm  
# End of macro CALLMONITOR
410f			endif	 
410f			 
410f			;	ld de, os_word_scratch 
410f 18 01			jr .dotwrite 
4111			 
4111 00			.dotflot:   nop 
4112			; TODO print floating point number 
4112			 
4112			.dotwrite:		 
4112			 
4112					; if c is set then set all '-' to spaces 
4112					; need to also take into account .>  
4112			 
4112 3e 01				ld a, 1 
4114 b9					cp c 
4115 20 67				jr nz, .nodashswap 
4117			 
4117					; DE has the string to write, working with HL 
4117			 
4117 06 ff				ld b, 255 
4119 d5					push de 
411a e1					pop hl 
411b			 
411b			if DEBUG_FORTH_DOT 
411b				DMARK "DT-" 
411b f5				push af  
411c 3a 30 41			ld a, (.dmark)  
411f 32 6e fe			ld (debug_mark),a  
4122 3a 31 41			ld a, (.dmark+1)  
4125 32 6f fe			ld (debug_mark+1),a  
4128 3a 32 41			ld a, (.dmark+2)  
412b 32 70 fe			ld (debug_mark+2),a  
412e 18 03			jr .pastdmark  
4130 ..			.dmark: db "DT-"  
4133 f1			.pastdmark: pop af  
4134			endm  
# End of macro DMARK
4134				CALLMONITOR 
4134 cd fb 19			call break_point_state  
4137				endm  
# End of macro CALLMONITOR
4137			endif	 
4137 7e			.dashscan:	ld a, (hl) 
4138 fe 00				cp 0 
413a 28 42				jr z, .nodashswap 
413c fe 2d				cp '-' 
413e 20 03				jr nz, .dashskip 
4140 3e 20				ld a, ' ' 
4142 77					ld (hl), a 
4143 23			.dashskip:	inc hl 
4144			if DEBUG_FORTH_DOT 
4144				DMARK "D-2" 
4144 f5				push af  
4145 3a 59 41			ld a, (.dmark)  
4148 32 6e fe			ld (debug_mark),a  
414b 3a 5a 41			ld a, (.dmark+1)  
414e 32 6f fe			ld (debug_mark+1),a  
4151 3a 5b 41			ld a, (.dmark+2)  
4154 32 70 fe			ld (debug_mark+2),a  
4157 18 03			jr .pastdmark  
4159 ..			.dmark: db "D-2"  
415c f1			.pastdmark: pop af  
415d			endm  
# End of macro DMARK
415d				CALLMONITOR 
415d cd fb 19			call break_point_state  
4160				endm  
# End of macro CALLMONITOR
4160			endif	 
4160 10 d5				djnz .dashscan 
4162			 
4162			if DEBUG_FORTH_DOT 
4162				DMARK "D-1" 
4162 f5				push af  
4163 3a 77 41			ld a, (.dmark)  
4166 32 6e fe			ld (debug_mark),a  
4169 3a 78 41			ld a, (.dmark+1)  
416c 32 6f fe			ld (debug_mark+1),a  
416f 3a 79 41			ld a, (.dmark+2)  
4172 32 70 fe			ld (debug_mark+2),a  
4175 18 03			jr .pastdmark  
4177 ..			.dmark: db "D-1"  
417a f1			.pastdmark: pop af  
417b			endm  
# End of macro DMARK
417b				CALLMONITOR 
417b cd fb 19			call break_point_state  
417e				endm  
# End of macro CALLMONITOR
417e			endif	 
417e			 
417e			.nodashswap: 
417e			 
417e			if DEBUG_FORTH_DOT 
417e				DMARK "D-o" 
417e f5				push af  
417f 3a 93 41			ld a, (.dmark)  
4182 32 6e fe			ld (debug_mark),a  
4185 3a 94 41			ld a, (.dmark+1)  
4188 32 6f fe			ld (debug_mark+1),a  
418b 3a 95 41			ld a, (.dmark+2)  
418e 32 70 fe			ld (debug_mark+2),a  
4191 18 03			jr .pastdmark  
4193 ..			.dmark: db "D-o"  
4196 f1			.pastdmark: pop af  
4197			endm  
# End of macro DMARK
4197				CALLMONITOR 
4197 cd fb 19			call break_point_state  
419a				endm  
# End of macro CALLMONITOR
419a			endif	 
419a			 
419a d5					push de   ; save string start in case we need to advance print 
419b			 
419b 3a 61 fa				ld a, (f_cursor_ptr) 
419e cd 65 0d				call str_at_display 
41a1 3a 3f fa				ld a,(cli_autodisplay) 
41a4 fe 00				cp 0 
41a6 28 03				jr z, .noupdate 
41a8 cd 75 0d						call update_display 
41ab					.noupdate: 
41ab			 
41ab			 
41ab					; see if we need to advance the print position 
41ab			 
41ab e1					pop hl   ; get back string 
41ac			;		ex de,hl 
41ac			 
41ac 3a 40 fa				ld a, (cli_mvdot) 
41af			if DEBUG_FORTH_DOT 
41af			;		ld e,a 
41af				DMARK "D>1" 
41af f5				push af  
41b0 3a c4 41			ld a, (.dmark)  
41b3 32 6e fe			ld (debug_mark),a  
41b6 3a c5 41			ld a, (.dmark+1)  
41b9 32 6f fe			ld (debug_mark+1),a  
41bc 3a c6 41			ld a, (.dmark+2)  
41bf 32 70 fe			ld (debug_mark+2),a  
41c2 18 03			jr .pastdmark  
41c4 ..			.dmark: db "D>1"  
41c7 f1			.pastdmark: pop af  
41c8			endm  
# End of macro DMARK
41c8				CALLMONITOR 
41c8 cd fb 19			call break_point_state  
41cb				endm  
# End of macro CALLMONITOR
41cb			endif	 
41cb fe 00				cp 0 
41cd 28 44				jr z, .noadv 
41cf					; yes, lets advance the print position 
41cf 3e 00				ld a, 0 
41d1 cd ef 13				call strlent 
41d4			if DEBUG_FORTH_DOT 
41d4				DMARK "D-?" 
41d4 f5				push af  
41d5 3a e9 41			ld a, (.dmark)  
41d8 32 6e fe			ld (debug_mark),a  
41db 3a ea 41			ld a, (.dmark+1)  
41de 32 6f fe			ld (debug_mark+1),a  
41e1 3a eb 41			ld a, (.dmark+2)  
41e4 32 70 fe			ld (debug_mark+2),a  
41e7 18 03			jr .pastdmark  
41e9 ..			.dmark: db "D-?"  
41ec f1			.pastdmark: pop af  
41ed			endm  
# End of macro DMARK
41ed				CALLMONITOR 
41ed cd fb 19			call break_point_state  
41f0				endm  
# End of macro CALLMONITOR
41f0			endif	 
41f0 3a 61 fa				ld a, (f_cursor_ptr) 
41f3 85					add a,l 
41f4					;call addatohl 
41f4					;ld a, l 
41f4 32 61 fa				ld (f_cursor_ptr), a   ; save new pos 
41f7			 
41f7			if DEBUG_FORTH_DOT 
41f7				DMARK "D->" 
41f7 f5				push af  
41f8 3a 0c 42			ld a, (.dmark)  
41fb 32 6e fe			ld (debug_mark),a  
41fe 3a 0d 42			ld a, (.dmark+1)  
4201 32 6f fe			ld (debug_mark+1),a  
4204 3a 0e 42			ld a, (.dmark+2)  
4207 32 70 fe			ld (debug_mark+2),a  
420a 18 03			jr .pastdmark  
420c ..			.dmark: db "D->"  
420f f1			.pastdmark: pop af  
4210			endm  
# End of macro DMARK
4210				CALLMONITOR 
4210 cd fb 19			call break_point_state  
4213				endm  
# End of macro CALLMONITOR
4213			endif	 
4213			 
4213			.noadv:	 
4213			 
4213					if DEBUG_FORTH_DOT_WAIT 
4213							call next_page_prompt 
4213					endif	 
4213			; TODO this pop off the stack causes a crash. i dont know why 
4213			 
4213			 
4213			if DEBUG_FORTH_DOT 
4213				DMARK "DTh" 
4213 f5				push af  
4214 3a 28 42			ld a, (.dmark)  
4217 32 6e fe			ld (debug_mark),a  
421a 3a 29 42			ld a, (.dmark+1)  
421d 32 6f fe			ld (debug_mark+1),a  
4220 3a 2a 42			ld a, (.dmark+2)  
4223 32 70 fe			ld (debug_mark+2),a  
4226 18 03			jr .pastdmark  
4228 ..			.dmark: db "DTh"  
422b f1			.pastdmark: pop af  
422c			endm  
# End of macro DMARK
422c				CALLMONITOR 
422c cd fb 19			call break_point_state  
422f				endm  
# End of macro CALLMONITOR
422f			endif	 
422f			 
422f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
422f cd a2 23			call macro_forth_dsp_pop 
4232				endm 
# End of macro FORTH_DSP_POP
4232			 
4232			if DEBUG_FORTH_DOT 
4232				DMARK "DTi" 
4232 f5				push af  
4233 3a 47 42			ld a, (.dmark)  
4236 32 6e fe			ld (debug_mark),a  
4239 3a 48 42			ld a, (.dmark+1)  
423c 32 6f fe			ld (debug_mark+1),a  
423f 3a 49 42			ld a, (.dmark+2)  
4242 32 70 fe			ld (debug_mark+2),a  
4245 18 03			jr .pastdmark  
4247 ..			.dmark: db "DTi"  
424a f1			.pastdmark: pop af  
424b			endm  
# End of macro DMARK
424b				CALLMONITOR 
424b cd fb 19			call break_point_state  
424e				endm  
# End of macro CALLMONITOR
424e			endif	 
424e			 
424e			 
424e					NEXTW 
424e c3 a0 24			jp macro_next 
4251				endm 
# End of macro NEXTW
4251			 
4251			.CLS: 
4251				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
4251 35				db WORD_SYS_CORE+33             
4252 7e 42			dw .DRAW            
4254 04				db 3 + 1 
4255 .. 00			db "CLS",0              
4259				endm 
# End of macro CWHEAD
4259			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4259					if DEBUG_FORTH_WORDS_KEY 
4259						DMARK "CLS" 
4259 f5				push af  
425a 3a 6e 42			ld a, (.dmark)  
425d 32 6e fe			ld (debug_mark),a  
4260 3a 6f 42			ld a, (.dmark+1)  
4263 32 6f fe			ld (debug_mark+1),a  
4266 3a 70 42			ld a, (.dmark+2)  
4269 32 70 fe			ld (debug_mark+2),a  
426c 18 03			jr .pastdmark  
426e ..			.dmark: db "CLS"  
4271 f1			.pastdmark: pop af  
4272			endm  
# End of macro DMARK
4272						CALLMONITOR 
4272 cd fb 19			call break_point_state  
4275				endm  
# End of macro CALLMONITOR
4275					endif 
4275 cd 52 0d				call clear_display 
4278 c3 8c 43				jp .home		; and home cursor 
427b					NEXTW 
427b c3 a0 24			jp macro_next 
427e				endm 
# End of macro NEXTW
427e			 
427e			.DRAW: 
427e				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
427e 36				db WORD_SYS_CORE+34             
427f a9 42			dw .DUMP            
4281 05				db 4 + 1 
4282 .. 00			db "DRAW",0              
4287				endm 
# End of macro CWHEAD
4287			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
4287					if DEBUG_FORTH_WORDS_KEY 
4287						DMARK "DRW" 
4287 f5				push af  
4288 3a 9c 42			ld a, (.dmark)  
428b 32 6e fe			ld (debug_mark),a  
428e 3a 9d 42			ld a, (.dmark+1)  
4291 32 6f fe			ld (debug_mark+1),a  
4294 3a 9e 42			ld a, (.dmark+2)  
4297 32 70 fe			ld (debug_mark+2),a  
429a 18 03			jr .pastdmark  
429c ..			.dmark: db "DRW"  
429f f1			.pastdmark: pop af  
42a0			endm  
# End of macro DMARK
42a0						CALLMONITOR 
42a0 cd fb 19			call break_point_state  
42a3				endm  
# End of macro CALLMONITOR
42a3					endif 
42a3 cd 75 0d				call update_display 
42a6					NEXTW 
42a6 c3 a0 24			jp macro_next 
42a9				endm 
# End of macro NEXTW
42a9			 
42a9			.DUMP: 
42a9				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
42a9 37				db WORD_SYS_CORE+35             
42aa e1 42			dw .CDUMP            
42ac 05				db 4 + 1 
42ad .. 00			db "DUMP",0              
42b2				endm 
# End of macro CWHEAD
42b2			; | DUMP ( x -- ) With address x display dump   | DONE 
42b2			; TODO pop address to use off of the stack 
42b2					if DEBUG_FORTH_WORDS_KEY 
42b2						DMARK "DUM" 
42b2 f5				push af  
42b3 3a c7 42			ld a, (.dmark)  
42b6 32 6e fe			ld (debug_mark),a  
42b9 3a c8 42			ld a, (.dmark+1)  
42bc 32 6f fe			ld (debug_mark+1),a  
42bf 3a c9 42			ld a, (.dmark+2)  
42c2 32 70 fe			ld (debug_mark+2),a  
42c5 18 03			jr .pastdmark  
42c7 ..			.dmark: db "DUM"  
42ca f1			.pastdmark: pop af  
42cb			endm  
# End of macro DMARK
42cb						CALLMONITOR 
42cb cd fb 19			call break_point_state  
42ce				endm  
# End of macro CALLMONITOR
42ce					endif 
42ce cd 52 0d				call clear_display 
42d1			 
42d1					; get address 
42d1			 
42d1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42d1 cd ea 22			call macro_dsp_valuehl 
42d4				endm 
# End of macro FORTH_DSP_VALUEHL
42d4				 
42d4					; save it for cdump 
42d4			 
42d4 22 e7 f4				ld (os_cur_ptr),hl 
42d7			 
42d7					; destroy value TOS 
42d7			 
42d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42d7 cd a2 23			call macro_forth_dsp_pop 
42da				endm 
# End of macro FORTH_DSP_POP
42da			 
42da cd 73 1f				call dumpcont	; skip old style of param parsing	 
42dd c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
42de					NEXTW 
42de c3 a0 24			jp macro_next 
42e1				endm 
# End of macro NEXTW
42e1			.CDUMP: 
42e1				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
42e1 38				db WORD_SYS_CORE+36             
42e2 11 43			dw .DAT            
42e4 06				db 5 + 1 
42e5 .. 00			db "CDUMP",0              
42eb				endm 
# End of macro CWHEAD
42eb			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
42eb					if DEBUG_FORTH_WORDS_KEY 
42eb						DMARK "CDP" 
42eb f5				push af  
42ec 3a 00 43			ld a, (.dmark)  
42ef 32 6e fe			ld (debug_mark),a  
42f2 3a 01 43			ld a, (.dmark+1)  
42f5 32 6f fe			ld (debug_mark+1),a  
42f8 3a 02 43			ld a, (.dmark+2)  
42fb 32 70 fe			ld (debug_mark+2),a  
42fe 18 03			jr .pastdmark  
4300 ..			.dmark: db "CDP"  
4303 f1			.pastdmark: pop af  
4304			endm  
# End of macro DMARK
4304						CALLMONITOR 
4304 cd fb 19			call break_point_state  
4307				endm  
# End of macro CALLMONITOR
4307					endif 
4307 cd 52 0d				call clear_display 
430a cd 73 1f				call dumpcont	 
430d c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
430e					NEXTW 
430e c3 a0 24			jp macro_next 
4311				endm 
# End of macro NEXTW
4311			 
4311			 
4311			 
4311			 
4311			.DAT: 
4311				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
4311 3d				db WORD_SYS_CORE+41             
4312 67 43			dw .HOME            
4314 03				db 2 + 1 
4315 .. 00			db "AT",0              
4318				endm 
# End of macro CWHEAD
4318			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
4318					if DEBUG_FORTH_WORDS_KEY 
4318						DMARK "AT." 
4318 f5				push af  
4319 3a 2d 43			ld a, (.dmark)  
431c 32 6e fe			ld (debug_mark),a  
431f 3a 2e 43			ld a, (.dmark+1)  
4322 32 6f fe			ld (debug_mark+1),a  
4325 3a 2f 43			ld a, (.dmark+2)  
4328 32 70 fe			ld (debug_mark+2),a  
432b 18 03			jr .pastdmark  
432d ..			.dmark: db "AT."  
4330 f1			.pastdmark: pop af  
4331			endm  
# End of macro DMARK
4331						CALLMONITOR 
4331 cd fb 19			call break_point_state  
4334				endm  
# End of macro CALLMONITOR
4334					endif 
4334					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4334 cd ea 22			call macro_dsp_valuehl 
4337				endm 
# End of macro FORTH_DSP_VALUEHL
4337			 
4337			 
4337					; TODO save cursor row 
4337 7d					ld a,l 
4338 fe 02				cp 2 
433a 20 04				jr nz, .crow3 
433c 3e 28				ld a, display_row_2 
433e 18 12				jr .ccol1 
4340 fe 03		.crow3:		cp 3 
4342 20 04				jr nz, .crow4 
4344 3e 50				ld a, display_row_3 
4346 18 0a				jr .ccol1 
4348 fe 04		.crow4:		cp 4 
434a 20 04				jr nz, .crow1 
434c 3e 78				ld a, display_row_4 
434e 18 02				jr .ccol1 
4350 3e 00		.crow1:		ld a,display_row_1 
4352 f5			.ccol1:		push af			; got row offset 
4353 6f					ld l,a 
4354 26 00				ld h,0 
4356					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4356 cd a2 23			call macro_forth_dsp_pop 
4359				endm 
# End of macro FORTH_DSP_POP
4359					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4359 cd ea 22			call macro_dsp_valuehl 
435c				endm 
# End of macro FORTH_DSP_VALUEHL
435c					; TODO save cursor col 
435c f1					pop af 
435d 85					add l		; add col offset 
435e 32 61 fa				ld (f_cursor_ptr), a 
4361					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4361 cd a2 23			call macro_forth_dsp_pop 
4364				endm 
# End of macro FORTH_DSP_POP
4364			 
4364					; calculate  
4364			 
4364					NEXTW 
4364 c3 a0 24			jp macro_next 
4367				endm 
# End of macro NEXTW
4367			 
4367			 
4367			.HOME: 
4367				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
4367 41				db WORD_SYS_CORE+45             
4368 94 43			dw .SPACE            
436a 05				db 4 + 1 
436b .. 00			db "HOME",0              
4370				endm 
# End of macro CWHEAD
4370			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
4370					if DEBUG_FORTH_WORDS_KEY 
4370						DMARK "HOM" 
4370 f5				push af  
4371 3a 85 43			ld a, (.dmark)  
4374 32 6e fe			ld (debug_mark),a  
4377 3a 86 43			ld a, (.dmark+1)  
437a 32 6f fe			ld (debug_mark+1),a  
437d 3a 87 43			ld a, (.dmark+2)  
4380 32 70 fe			ld (debug_mark+2),a  
4383 18 03			jr .pastdmark  
4385 ..			.dmark: db "HOM"  
4388 f1			.pastdmark: pop af  
4389			endm  
# End of macro DMARK
4389						CALLMONITOR 
4389 cd fb 19			call break_point_state  
438c				endm  
# End of macro CALLMONITOR
438c					endif 
438c 3e 00		.home:		ld a, 0		; and home cursor 
438e 32 61 fa				ld (f_cursor_ptr), a 
4391					NEXTW 
4391 c3 a0 24			jp macro_next 
4394				endm 
# End of macro NEXTW
4394			 
4394			 
4394			.SPACE: 
4394				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
4394 46				db WORD_SYS_CORE+50             
4395 ca 43			dw .SPACES            
4397 03				db 2 + 1 
4398 .. 00			db "BL",0              
439b				endm 
# End of macro CWHEAD
439b			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
439b					if DEBUG_FORTH_WORDS_KEY 
439b						DMARK "BL." 
439b f5				push af  
439c 3a b0 43			ld a, (.dmark)  
439f 32 6e fe			ld (debug_mark),a  
43a2 3a b1 43			ld a, (.dmark+1)  
43a5 32 6f fe			ld (debug_mark+1),a  
43a8 3a b2 43			ld a, (.dmark+2)  
43ab 32 70 fe			ld (debug_mark+2),a  
43ae 18 03			jr .pastdmark  
43b0 ..			.dmark: db "BL."  
43b3 f1			.pastdmark: pop af  
43b4			endm  
# End of macro DMARK
43b4						CALLMONITOR 
43b4 cd fb 19			call break_point_state  
43b7				endm  
# End of macro CALLMONITOR
43b7					endif 
43b7 3e 20				ld a, " " 
43b9 32 c4 f1				ld (scratch),a 
43bc 3e 00				ld a, 0 
43be 32 c5 f1				ld (scratch+1),a 
43c1 21 c4 f1				ld hl, scratch 
43c4 cd 61 21				call forth_push_str 
43c7					 
43c7				       NEXTW 
43c7 c3 a0 24			jp macro_next 
43ca				endm 
# End of macro NEXTW
43ca			 
43ca			;.blstr: db " ", 0 
43ca			 
43ca			.SPACES: 
43ca				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
43ca 47				db WORD_SYS_CORE+51             
43cb 65 44			dw .SCROLL            
43cd 07				db 6 + 1 
43ce .. 00			db "SPACES",0              
43d5				endm 
# End of macro CWHEAD
43d5			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
43d5					if DEBUG_FORTH_WORDS_KEY 
43d5						DMARK "SPS" 
43d5 f5				push af  
43d6 3a ea 43			ld a, (.dmark)  
43d9 32 6e fe			ld (debug_mark),a  
43dc 3a eb 43			ld a, (.dmark+1)  
43df 32 6f fe			ld (debug_mark+1),a  
43e2 3a ec 43			ld a, (.dmark+2)  
43e5 32 70 fe			ld (debug_mark+2),a  
43e8 18 03			jr .pastdmark  
43ea ..			.dmark: db "SPS"  
43ed f1			.pastdmark: pop af  
43ee			endm  
# End of macro DMARK
43ee						CALLMONITOR 
43ee cd fb 19			call break_point_state  
43f1				endm  
# End of macro CALLMONITOR
43f1					endif 
43f1			 
43f1			 
43f1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43f1 cd ea 22			call macro_dsp_valuehl 
43f4				endm 
# End of macro FORTH_DSP_VALUEHL
43f4			 
43f4 e5					push hl    ; u 
43f5					if DEBUG_FORTH_WORDS 
43f5						DMARK "SPA" 
43f5 f5				push af  
43f6 3a 0a 44			ld a, (.dmark)  
43f9 32 6e fe			ld (debug_mark),a  
43fc 3a 0b 44			ld a, (.dmark+1)  
43ff 32 6f fe			ld (debug_mark+1),a  
4402 3a 0c 44			ld a, (.dmark+2)  
4405 32 70 fe			ld (debug_mark+2),a  
4408 18 03			jr .pastdmark  
440a ..			.dmark: db "SPA"  
440d f1			.pastdmark: pop af  
440e			endm  
# End of macro DMARK
440e						CALLMONITOR 
440e cd fb 19			call break_point_state  
4411				endm  
# End of macro CALLMONITOR
4411					endif 
4411			 
4411					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4411 cd a2 23			call macro_forth_dsp_pop 
4414				endm 
# End of macro FORTH_DSP_POP
4414 e1					pop hl 
4415 0e 00				ld c, 0 
4417 45					ld b, l 
4418 21 c4 f1				ld hl, scratch  
441b			 
441b					if DEBUG_FORTH_WORDS 
441b						DMARK "SP2" 
441b f5				push af  
441c 3a 30 44			ld a, (.dmark)  
441f 32 6e fe			ld (debug_mark),a  
4422 3a 31 44			ld a, (.dmark+1)  
4425 32 6f fe			ld (debug_mark+1),a  
4428 3a 32 44			ld a, (.dmark+2)  
442b 32 70 fe			ld (debug_mark+2),a  
442e 18 03			jr .pastdmark  
4430 ..			.dmark: db "SP2"  
4433 f1			.pastdmark: pop af  
4434			endm  
# End of macro DMARK
4434						CALLMONITOR 
4434 cd fb 19			call break_point_state  
4437				endm  
# End of macro CALLMONITOR
4437					endif 
4437 3e 20				ld a, ' ' 
4439			.spaces1:	 
4439 77					ld (hl),a 
443a 23					inc hl 
443b					 
443b 10 fc				djnz .spaces1 
443d 3e 00				ld a,0 
443f 77					ld (hl),a 
4440 21 c4 f1				ld hl, scratch 
4443					if DEBUG_FORTH_WORDS 
4443						DMARK "SP3" 
4443 f5				push af  
4444 3a 58 44			ld a, (.dmark)  
4447 32 6e fe			ld (debug_mark),a  
444a 3a 59 44			ld a, (.dmark+1)  
444d 32 6f fe			ld (debug_mark+1),a  
4450 3a 5a 44			ld a, (.dmark+2)  
4453 32 70 fe			ld (debug_mark+2),a  
4456 18 03			jr .pastdmark  
4458 ..			.dmark: db "SP3"  
445b f1			.pastdmark: pop af  
445c			endm  
# End of macro DMARK
445c						CALLMONITOR 
445c cd fb 19			call break_point_state  
445f				endm  
# End of macro CALLMONITOR
445f					endif 
445f cd 61 21				call forth_push_str 
4462			 
4462				       NEXTW 
4462 c3 a0 24			jp macro_next 
4465				endm 
# End of macro NEXTW
4465			 
4465			 
4465			 
4465			.SCROLL: 
4465				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4465 53				db WORD_SYS_CORE+63             
4466 92 44			dw .SCROLLD            
4468 07				db 6 + 1 
4469 .. 00			db "SCROLL",0              
4470				endm 
# End of macro CWHEAD
4470			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4470					if DEBUG_FORTH_WORDS_KEY 
4470						DMARK "SCR" 
4470 f5				push af  
4471 3a 85 44			ld a, (.dmark)  
4474 32 6e fe			ld (debug_mark),a  
4477 3a 86 44			ld a, (.dmark+1)  
447a 32 6f fe			ld (debug_mark+1),a  
447d 3a 87 44			ld a, (.dmark+2)  
4480 32 70 fe			ld (debug_mark+2),a  
4483 18 03			jr .pastdmark  
4485 ..			.dmark: db "SCR"  
4488 f1			.pastdmark: pop af  
4489			endm  
# End of macro DMARK
4489						CALLMONITOR 
4489 cd fb 19			call break_point_state  
448c				endm  
# End of macro CALLMONITOR
448c					endif 
448c			 
448c cd 14 0d			call scroll_up 
448f			;	call update_display 
448f			 
448f					NEXTW 
448f c3 a0 24			jp macro_next 
4492				endm 
# End of macro NEXTW
4492			 
4492			 
4492			 
4492			;		; get dir 
4492			; 
4492			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4492			; 
4492			;		push hl 
4492			; 
4492			;		; destroy value TOS 
4492			; 
4492			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4492			; 
4492			;		; get count 
4492			; 
4492			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4492			; 
4492			;		push hl 
4492			; 
4492			;		; destroy value TOS 
4492			; 
4492			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4492			; 
4492			;		; one value on hl get other one back 
4492			; 
4492			;		pop bc    ; count 
4492			; 
4492			;		pop de   ; dir 
4492			; 
4492			; 
4492			;		ld b, c 
4492			; 
4492			;.scrolldir:     push bc 
4492			;		push de 
4492			; 
4492			;		ld a, 0 
4492			;		cp e 
4492			;		jr z, .scrollup  
4492			;		call scroll_down 
4492			;		jr .scrollnext 
4492			;.scrollup:	call scroll_up 
4492			; 
4492			;		 
4492			;.scrollnext: 
4492			;		pop de 
4492			;		pop bc 
4492			;		djnz .scrolldir 
4492			; 
4492			; 
4492			; 
4492			; 
4492			; 
4492			;		NEXTW 
4492			 
4492			.SCROLLD: 
4492				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4492 53				db WORD_SYS_CORE+63             
4493 c0 44			dw .ATQ            
4495 08				db 7 + 1 
4496 .. 00			db "SCROLLD",0              
449e				endm 
# End of macro CWHEAD
449e			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
449e					if DEBUG_FORTH_WORDS_KEY 
449e						DMARK "SCD" 
449e f5				push af  
449f 3a b3 44			ld a, (.dmark)  
44a2 32 6e fe			ld (debug_mark),a  
44a5 3a b4 44			ld a, (.dmark+1)  
44a8 32 6f fe			ld (debug_mark+1),a  
44ab 3a b5 44			ld a, (.dmark+2)  
44ae 32 70 fe			ld (debug_mark+2),a  
44b1 18 03			jr .pastdmark  
44b3 ..			.dmark: db "SCD"  
44b6 f1			.pastdmark: pop af  
44b7			endm  
# End of macro DMARK
44b7						CALLMONITOR 
44b7 cd fb 19			call break_point_state  
44ba				endm  
# End of macro CALLMONITOR
44ba					endif 
44ba			 
44ba cd 38 0d			call scroll_down 
44bd			;	call update_display 
44bd			 
44bd					NEXTW 
44bd c3 a0 24			jp macro_next 
44c0				endm 
# End of macro NEXTW
44c0			 
44c0			 
44c0			.ATQ: 
44c0				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
44c0 62				db WORD_SYS_CORE+78             
44c1 1e 45			dw .AUTODSP            
44c3 04				db 3 + 1 
44c4 .. 00			db "AT@",0              
44c8				endm 
# End of macro CWHEAD
44c8			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
44c8					if DEBUG_FORTH_WORDS_KEY 
44c8						DMARK "ATA" 
44c8 f5				push af  
44c9 3a dd 44			ld a, (.dmark)  
44cc 32 6e fe			ld (debug_mark),a  
44cf 3a de 44			ld a, (.dmark+1)  
44d2 32 6f fe			ld (debug_mark+1),a  
44d5 3a df 44			ld a, (.dmark+2)  
44d8 32 70 fe			ld (debug_mark+2),a  
44db 18 03			jr .pastdmark  
44dd ..			.dmark: db "ATA"  
44e0 f1			.pastdmark: pop af  
44e1			endm  
# End of macro DMARK
44e1						CALLMONITOR 
44e1 cd fb 19			call break_point_state  
44e4				endm  
# End of macro CALLMONITOR
44e4					endif 
44e4			 
44e4			 
44e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44e4 cd ea 22			call macro_dsp_valuehl 
44e7				endm 
# End of macro FORTH_DSP_VALUEHL
44e7			 
44e7					; TODO save cursor row 
44e7 7d					ld a,l 
44e8 fe 02				cp 2 
44ea 20 04				jr nz, .crow3aq 
44ec 3e 28				ld a, display_row_2 
44ee 18 12				jr .ccol1aq 
44f0 fe 03		.crow3aq:		cp 3 
44f2 20 04				jr nz, .crow4aq 
44f4 3e 50				ld a, display_row_3 
44f6 18 0a				jr .ccol1aq 
44f8 fe 04		.crow4aq:		cp 4 
44fa 20 04				jr nz, .crow1aq 
44fc 3e 78				ld a, display_row_4 
44fe 18 02				jr .ccol1aq 
4500 3e 00		.crow1aq:		ld a,display_row_1 
4502 f5			.ccol1aq:		push af			; got row offset 
4503 6f					ld l,a 
4504 26 00				ld h,0 
4506					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4506 cd a2 23			call macro_forth_dsp_pop 
4509				endm 
# End of macro FORTH_DSP_POP
4509					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4509 cd ea 22			call macro_dsp_valuehl 
450c				endm 
# End of macro FORTH_DSP_VALUEHL
450c					; TODO save cursor col 
450c f1					pop af 
450d 85					add l		; add col offset 
450e			 
450e					; add current frame buffer address 
450e 2a cf fb				ld hl, (display_fb_active) 
4511 cd 86 0f				call addatohl 
4514			 
4514			 
4514			 
4514			 
4514					; get char frame buffer location offset in hl 
4514			 
4514 7e					ld a,(hl) 
4515 26 00				ld h, 0 
4517 6f					ld l, a 
4518			 
4518 cd f3 20				call forth_push_numhl 
451b			 
451b			 
451b					NEXTW 
451b c3 a0 24			jp macro_next 
451e				endm 
# End of macro NEXTW
451e			 
451e			.AUTODSP: 
451e				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
451e 63				db WORD_SYS_CORE+79             
451f 34 45			dw .MENU            
4521 05				db 4 + 1 
4522 .. 00			db "ADSP",0              
4527				endm 
# End of macro CWHEAD
4527			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4527			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4527			 
4527					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4527 cd ea 22			call macro_dsp_valuehl 
452a				endm 
# End of macro FORTH_DSP_VALUEHL
452a			 
452a			;		push hl 
452a			 
452a					; destroy value TOS 
452a			 
452a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
452a cd a2 23			call macro_forth_dsp_pop 
452d				endm 
# End of macro FORTH_DSP_POP
452d			 
452d			;		pop hl 
452d			 
452d 7d					ld a,l 
452e 32 3f fa				ld (cli_autodisplay), a 
4531				       NEXTW 
4531 c3 a0 24			jp macro_next 
4534				endm 
# End of macro NEXTW
4534			 
4534			.MENU: 
4534				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4534 70				db WORD_SYS_CORE+92             
4535 dd 45			dw .ENDDISPLAY            
4537 05				db 4 + 1 
4538 .. 00			db "MENU",0              
453d				endm 
# End of macro CWHEAD
453d			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
453d			 
453d			;		; get number of items on the stack 
453d			; 
453d				 
453d					FORTH_DSP_VALUEHL 
453d cd ea 22			call macro_dsp_valuehl 
4540				endm 
# End of macro FORTH_DSP_VALUEHL
4540				 
4540					if DEBUG_FORTH_WORDS_KEY 
4540						DMARK "MNU" 
4540 f5				push af  
4541 3a 55 45			ld a, (.dmark)  
4544 32 6e fe			ld (debug_mark),a  
4547 3a 56 45			ld a, (.dmark+1)  
454a 32 6f fe			ld (debug_mark+1),a  
454d 3a 57 45			ld a, (.dmark+2)  
4550 32 70 fe			ld (debug_mark+2),a  
4553 18 03			jr .pastdmark  
4555 ..			.dmark: db "MNU"  
4558 f1			.pastdmark: pop af  
4559			endm  
# End of macro DMARK
4559						CALLMONITOR 
4559 cd fb 19			call break_point_state  
455c				endm  
# End of macro CALLMONITOR
455c					endif 
455c			 
455c 45					ld b, l	 
455d 05					dec b 
455e			 
455e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
455e cd a2 23			call macro_forth_dsp_pop 
4561				endm 
# End of macro FORTH_DSP_POP
4561			 
4561			 
4561					; go directly through the stack to pluck out the string pointers and build an array 
4561			 
4561			;		FORTH_DSP 
4561			 
4561					; hl contains top most stack item 
4561				 
4561 11 c4 f1				ld de, scratch 
4564			 
4564			.mbuild: 
4564			 
4564					FORTH_DSP_VALUEHL 
4564 cd ea 22			call macro_dsp_valuehl 
4567				endm 
# End of macro FORTH_DSP_VALUEHL
4567			 
4567					if DEBUG_FORTH_WORDS 
4567						DMARK "MN3" 
4567 f5				push af  
4568 3a 7c 45			ld a, (.dmark)  
456b 32 6e fe			ld (debug_mark),a  
456e 3a 7d 45			ld a, (.dmark+1)  
4571 32 6f fe			ld (debug_mark+1),a  
4574 3a 7e 45			ld a, (.dmark+2)  
4577 32 70 fe			ld (debug_mark+2),a  
457a 18 03			jr .pastdmark  
457c ..			.dmark: db "MN3"  
457f f1			.pastdmark: pop af  
4580			endm  
# End of macro DMARK
4580						CALLMONITOR 
4580 cd fb 19			call break_point_state  
4583				endm  
# End of macro CALLMONITOR
4583					endif 
4583 eb					ex de, hl 
4584 73					ld (hl), e 
4585 23					inc hl 
4586 72					ld (hl), d 
4587 23					inc hl 
4588 eb					ex de, hl 
4589			 
4589					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4589 cd a2 23			call macro_forth_dsp_pop 
458c				endm 
# End of macro FORTH_DSP_POP
458c			 
458c 10 d6				djnz .mbuild 
458e			 
458e					; done add term 
458e			 
458e eb					ex de, hl 
458f 36 00				ld (hl), 0 
4591 23					inc hl 
4592 36 00				ld (hl), 0 
4594			 
4594				 
4594					 
4594 21 c4 f1				ld hl, scratch 
4597			 
4597					if DEBUG_FORTH_WORDS 
4597						DMARK "MNx" 
4597 f5				push af  
4598 3a ac 45			ld a, (.dmark)  
459b 32 6e fe			ld (debug_mark),a  
459e 3a ad 45			ld a, (.dmark+1)  
45a1 32 6f fe			ld (debug_mark+1),a  
45a4 3a ae 45			ld a, (.dmark+2)  
45a7 32 70 fe			ld (debug_mark+2),a  
45aa 18 03			jr .pastdmark  
45ac ..			.dmark: db "MNx"  
45af f1			.pastdmark: pop af  
45b0			endm  
# End of macro DMARK
45b0						CALLMONITOR 
45b0 cd fb 19			call break_point_state  
45b3				endm  
# End of macro CALLMONITOR
45b3					endif 
45b3			 
45b3			 
45b3			 
45b3 3e 00				ld a, 0 
45b5 cd 83 0d				call menu 
45b8			 
45b8			 
45b8 6f					ld l, a 
45b9 26 00				ld h, 0 
45bb			 
45bb					if DEBUG_FORTH_WORDS 
45bb						DMARK "MNr" 
45bb f5				push af  
45bc 3a d0 45			ld a, (.dmark)  
45bf 32 6e fe			ld (debug_mark),a  
45c2 3a d1 45			ld a, (.dmark+1)  
45c5 32 6f fe			ld (debug_mark+1),a  
45c8 3a d2 45			ld a, (.dmark+2)  
45cb 32 70 fe			ld (debug_mark+2),a  
45ce 18 03			jr .pastdmark  
45d0 ..			.dmark: db "MNr"  
45d3 f1			.pastdmark: pop af  
45d4			endm  
# End of macro DMARK
45d4						CALLMONITOR 
45d4 cd fb 19			call break_point_state  
45d7				endm  
# End of macro CALLMONITOR
45d7					endif 
45d7			 
45d7 cd f3 20				call forth_push_numhl 
45da			 
45da			 
45da			 
45da			 
45da				       NEXTW 
45da c3 a0 24			jp macro_next 
45dd				endm 
# End of macro NEXTW
45dd			 
45dd			 
45dd			.ENDDISPLAY: 
45dd			 
45dd			; eof 
# End of file forth_words_display.asm
45dd			include "forth_words_str.asm" 
45dd			 
45dd			; | ## String Words 
45dd			 
45dd			.PTR:   
45dd			 
45dd				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
45dd 48				db WORD_SYS_CORE+52             
45de 0a 46			dw .STYPE            
45e0 04				db 3 + 1 
45e1 .. 00			db "PTR",0              
45e5				endm 
# End of macro CWHEAD
45e5			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
45e5			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
45e5			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
45e5			 
45e5					if DEBUG_FORTH_WORDS_KEY 
45e5						DMARK "PTR" 
45e5 f5				push af  
45e6 3a fa 45			ld a, (.dmark)  
45e9 32 6e fe			ld (debug_mark),a  
45ec 3a fb 45			ld a, (.dmark+1)  
45ef 32 6f fe			ld (debug_mark+1),a  
45f2 3a fc 45			ld a, (.dmark+2)  
45f5 32 70 fe			ld (debug_mark+2),a  
45f8 18 03			jr .pastdmark  
45fa ..			.dmark: db "PTR"  
45fd f1			.pastdmark: pop af  
45fe			endm  
# End of macro DMARK
45fe						CALLMONITOR 
45fe cd fb 19			call break_point_state  
4601				endm  
# End of macro CALLMONITOR
4601					endif 
4601					FORTH_DSP_VALUEHL 
4601 cd ea 22			call macro_dsp_valuehl 
4604				endm 
# End of macro FORTH_DSP_VALUEHL
4604 cd f3 20				call forth_push_numhl 
4607			 
4607			 
4607					NEXTW 
4607 c3 a0 24			jp macro_next 
460a				endm 
# End of macro NEXTW
460a			.STYPE: 
460a				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
460a 48				db WORD_SYS_CORE+52             
460b 59 46			dw .UPPER            
460d 06				db 5 + 1 
460e .. 00			db "STYPE",0              
4614				endm 
# End of macro CWHEAD
4614			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4614					if DEBUG_FORTH_WORDS_KEY 
4614						DMARK "STY" 
4614 f5				push af  
4615 3a 29 46			ld a, (.dmark)  
4618 32 6e fe			ld (debug_mark),a  
461b 3a 2a 46			ld a, (.dmark+1)  
461e 32 6f fe			ld (debug_mark+1),a  
4621 3a 2b 46			ld a, (.dmark+2)  
4624 32 70 fe			ld (debug_mark+2),a  
4627 18 03			jr .pastdmark  
4629 ..			.dmark: db "STY"  
462c f1			.pastdmark: pop af  
462d			endm  
# End of macro DMARK
462d						CALLMONITOR 
462d cd fb 19			call break_point_state  
4630				endm  
# End of macro CALLMONITOR
4630					endif 
4630					FORTH_DSP 
4630 cd b0 22			call macro_forth_dsp 
4633				endm 
# End of macro FORTH_DSP
4633					;v5 FORTH_DSP_VALUE 
4633			 
4633 7e					ld a, (hl) 
4634			 
4634 f5					push af 
4635			 
4635			; Dont destroy TOS		FORTH_DSP_POP 
4635			 
4635 f1					pop af 
4636			 
4636 fe 01				cp DS_TYPE_STR 
4638 28 09				jr z, .typestr 
463a			 
463a fe 02				cp DS_TYPE_INUM 
463c 28 0a				jr z, .typeinum 
463e			 
463e 21 57 46				ld hl, .tna 
4641 18 0a				jr .tpush 
4643			 
4643 21 53 46		.typestr:	ld hl, .tstr 
4646 18 05				jr .tpush 
4648 21 55 46		.typeinum:	ld hl, .tinum 
464b 18 00				jr .tpush 
464d			 
464d			.tpush: 
464d			 
464d cd 61 21				call forth_push_str 
4650			 
4650					NEXTW 
4650 c3 a0 24			jp macro_next 
4653				endm 
# End of macro NEXTW
4653 .. 00		.tstr:	db "s",0 
4655 .. 00		.tinum:  db "i",0 
4657 .. 00		.tna:   db "?", 0 
4659			 
4659			 
4659			.UPPER: 
4659				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4659 48				db WORD_SYS_CORE+52             
465a 94 46			dw .LOWER            
465c 06				db 5 + 1 
465d .. 00			db "UPPER",0              
4663				endm 
# End of macro CWHEAD
4663			; | UPPER ( s -- s ) Upper case string s  | DONE 
4663					if DEBUG_FORTH_WORDS_KEY 
4663						DMARK "UPR" 
4663 f5				push af  
4664 3a 78 46			ld a, (.dmark)  
4667 32 6e fe			ld (debug_mark),a  
466a 3a 79 46			ld a, (.dmark+1)  
466d 32 6f fe			ld (debug_mark+1),a  
4670 3a 7a 46			ld a, (.dmark+2)  
4673 32 70 fe			ld (debug_mark+2),a  
4676 18 03			jr .pastdmark  
4678 ..			.dmark: db "UPR"  
467b f1			.pastdmark: pop af  
467c			endm  
# End of macro DMARK
467c						CALLMONITOR 
467c cd fb 19			call break_point_state  
467f				endm  
# End of macro CALLMONITOR
467f					endif 
467f			 
467f					FORTH_DSP 
467f cd b0 22			call macro_forth_dsp 
4682				endm 
# End of macro FORTH_DSP
4682					 
4682			; TODO check is string type 
4682			 
4682					FORTH_DSP_VALUEHL 
4682 cd ea 22			call macro_dsp_valuehl 
4685				endm 
# End of macro FORTH_DSP_VALUEHL
4685			; get pointer to string in hl 
4685			 
4685 7e			.toup:		ld a, (hl) 
4686 fe 00				cp 0 
4688 28 07				jr z, .toupdone 
468a			 
468a cd f3 12				call to_upper 
468d			 
468d 77					ld (hl), a 
468e 23					inc hl 
468f 18 f4				jr .toup 
4691			 
4691					 
4691			 
4691			 
4691			; for each char convert to upper 
4691					 
4691			.toupdone: 
4691			 
4691			 
4691					NEXTW 
4691 c3 a0 24			jp macro_next 
4694				endm 
# End of macro NEXTW
4694			.LOWER: 
4694				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4694 48				db WORD_SYS_CORE+52             
4695 cf 46			dw .TCASE            
4697 06				db 5 + 1 
4698 .. 00			db "LOWER",0              
469e				endm 
# End of macro CWHEAD
469e			; | LOWER ( s -- s ) Lower case string s  | DONE 
469e					if DEBUG_FORTH_WORDS_KEY 
469e						DMARK "LWR" 
469e f5				push af  
469f 3a b3 46			ld a, (.dmark)  
46a2 32 6e fe			ld (debug_mark),a  
46a5 3a b4 46			ld a, (.dmark+1)  
46a8 32 6f fe			ld (debug_mark+1),a  
46ab 3a b5 46			ld a, (.dmark+2)  
46ae 32 70 fe			ld (debug_mark+2),a  
46b1 18 03			jr .pastdmark  
46b3 ..			.dmark: db "LWR"  
46b6 f1			.pastdmark: pop af  
46b7			endm  
# End of macro DMARK
46b7						CALLMONITOR 
46b7 cd fb 19			call break_point_state  
46ba				endm  
# End of macro CALLMONITOR
46ba					endif 
46ba			 
46ba					FORTH_DSP 
46ba cd b0 22			call macro_forth_dsp 
46bd				endm 
# End of macro FORTH_DSP
46bd					 
46bd			; TODO check is string type 
46bd			 
46bd					FORTH_DSP_VALUEHL 
46bd cd ea 22			call macro_dsp_valuehl 
46c0				endm 
# End of macro FORTH_DSP_VALUEHL
46c0			; get pointer to string in hl 
46c0			 
46c0 7e			.tolow:		ld a, (hl) 
46c1 fe 00				cp 0 
46c3 28 07				jr z, .tolowdone 
46c5			 
46c5 cd fc 12				call to_lower 
46c8			 
46c8 77					ld (hl), a 
46c9 23					inc hl 
46ca 18 f4				jr .tolow 
46cc			 
46cc					 
46cc			 
46cc			 
46cc			; for each char convert to low 
46cc					 
46cc			.tolowdone: 
46cc					NEXTW 
46cc c3 a0 24			jp macro_next 
46cf				endm 
# End of macro NEXTW
46cf			.TCASE: 
46cf				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
46cf 48				db WORD_SYS_CORE+52             
46d0 05 48			dw .SUBSTR            
46d2 06				db 5 + 1 
46d3 .. 00			db "TCASE",0              
46d9				endm 
# End of macro CWHEAD
46d9			; | TCASE ( s -- s ) Title case string s  | DONE 
46d9					if DEBUG_FORTH_WORDS_KEY 
46d9						DMARK "TCS" 
46d9 f5				push af  
46da 3a ee 46			ld a, (.dmark)  
46dd 32 6e fe			ld (debug_mark),a  
46e0 3a ef 46			ld a, (.dmark+1)  
46e3 32 6f fe			ld (debug_mark+1),a  
46e6 3a f0 46			ld a, (.dmark+2)  
46e9 32 70 fe			ld (debug_mark+2),a  
46ec 18 03			jr .pastdmark  
46ee ..			.dmark: db "TCS"  
46f1 f1			.pastdmark: pop af  
46f2			endm  
# End of macro DMARK
46f2						CALLMONITOR 
46f2 cd fb 19			call break_point_state  
46f5				endm  
# End of macro CALLMONITOR
46f5					endif 
46f5			 
46f5					FORTH_DSP 
46f5 cd b0 22			call macro_forth_dsp 
46f8				endm 
# End of macro FORTH_DSP
46f8					 
46f8			; TODO check is string type 
46f8			 
46f8					FORTH_DSP_VALUEHL 
46f8 cd ea 22			call macro_dsp_valuehl 
46fb				endm 
# End of macro FORTH_DSP_VALUEHL
46fb			; get pointer to string in hl 
46fb			 
46fb					if DEBUG_FORTH_WORDS 
46fb						DMARK "TC1" 
46fb f5				push af  
46fc 3a 10 47			ld a, (.dmark)  
46ff 32 6e fe			ld (debug_mark),a  
4702 3a 11 47			ld a, (.dmark+1)  
4705 32 6f fe			ld (debug_mark+1),a  
4708 3a 12 47			ld a, (.dmark+2)  
470b 32 70 fe			ld (debug_mark+2),a  
470e 18 03			jr .pastdmark  
4710 ..			.dmark: db "TC1"  
4713 f1			.pastdmark: pop af  
4714			endm  
# End of macro DMARK
4714						CALLMONITOR 
4714 cd fb 19			call break_point_state  
4717				endm  
# End of macro CALLMONITOR
4717					endif 
4717			 
4717					; first time in turn to upper case first char 
4717			 
4717 7e					ld a, (hl) 
4718 c3 a2 47				jp .totsiptou 
471b			 
471b			 
471b 7e			.tot:		ld a, (hl) 
471c fe 00				cp 0 
471e ca e6 47				jp z, .totdone 
4721			 
4721					if DEBUG_FORTH_WORDS 
4721						DMARK "TC2" 
4721 f5				push af  
4722 3a 36 47			ld a, (.dmark)  
4725 32 6e fe			ld (debug_mark),a  
4728 3a 37 47			ld a, (.dmark+1)  
472b 32 6f fe			ld (debug_mark+1),a  
472e 3a 38 47			ld a, (.dmark+2)  
4731 32 70 fe			ld (debug_mark+2),a  
4734 18 03			jr .pastdmark  
4736 ..			.dmark: db "TC2"  
4739 f1			.pastdmark: pop af  
473a			endm  
# End of macro DMARK
473a						CALLMONITOR 
473a cd fb 19			call break_point_state  
473d				endm  
# End of macro CALLMONITOR
473d					endif 
473d					; check to see if current char is a space 
473d			 
473d fe 20				cp ' ' 
473f 28 21				jr z, .totsp 
4741 cd fc 12				call to_lower 
4744					if DEBUG_FORTH_WORDS 
4744						DMARK "TC3" 
4744 f5				push af  
4745 3a 59 47			ld a, (.dmark)  
4748 32 6e fe			ld (debug_mark),a  
474b 3a 5a 47			ld a, (.dmark+1)  
474e 32 6f fe			ld (debug_mark+1),a  
4751 3a 5b 47			ld a, (.dmark+2)  
4754 32 70 fe			ld (debug_mark+2),a  
4757 18 03			jr .pastdmark  
4759 ..			.dmark: db "TC3"  
475c f1			.pastdmark: pop af  
475d			endm  
# End of macro DMARK
475d						CALLMONITOR 
475d cd fb 19			call break_point_state  
4760				endm  
# End of macro CALLMONITOR
4760					endif 
4760 18 63				jr .totnxt 
4762			 
4762			.totsp:         ; on a space, find next char which should be upper 
4762			 
4762					if DEBUG_FORTH_WORDS 
4762						DMARK "TC4" 
4762 f5				push af  
4763 3a 77 47			ld a, (.dmark)  
4766 32 6e fe			ld (debug_mark),a  
4769 3a 78 47			ld a, (.dmark+1)  
476c 32 6f fe			ld (debug_mark+1),a  
476f 3a 79 47			ld a, (.dmark+2)  
4772 32 70 fe			ld (debug_mark+2),a  
4775 18 03			jr .pastdmark  
4777 ..			.dmark: db "TC4"  
477a f1			.pastdmark: pop af  
477b			endm  
# End of macro DMARK
477b						CALLMONITOR 
477b cd fb 19			call break_point_state  
477e				endm  
# End of macro CALLMONITOR
477e					endif 
477e					;; 
477e			 
477e fe 20				cp ' ' 
4780 20 20				jr nz, .totsiptou 
4782 23					inc hl 
4783 7e					ld a, (hl) 
4784					if DEBUG_FORTH_WORDS 
4784						DMARK "TC5" 
4784 f5				push af  
4785 3a 99 47			ld a, (.dmark)  
4788 32 6e fe			ld (debug_mark),a  
478b 3a 9a 47			ld a, (.dmark+1)  
478e 32 6f fe			ld (debug_mark+1),a  
4791 3a 9b 47			ld a, (.dmark+2)  
4794 32 70 fe			ld (debug_mark+2),a  
4797 18 03			jr .pastdmark  
4799 ..			.dmark: db "TC5"  
479c f1			.pastdmark: pop af  
479d			endm  
# End of macro DMARK
479d						CALLMONITOR 
479d cd fb 19			call break_point_state  
47a0				endm  
# End of macro CALLMONITOR
47a0					endif 
47a0 18 c0				jr .totsp 
47a2 fe 00		.totsiptou:    cp 0 
47a4 28 40				jr z, .totdone 
47a6					; not space and not zero term so upper case it 
47a6 cd f3 12				call to_upper 
47a9			 
47a9					if DEBUG_FORTH_WORDS 
47a9						DMARK "TC6" 
47a9 f5				push af  
47aa 3a be 47			ld a, (.dmark)  
47ad 32 6e fe			ld (debug_mark),a  
47b0 3a bf 47			ld a, (.dmark+1)  
47b3 32 6f fe			ld (debug_mark+1),a  
47b6 3a c0 47			ld a, (.dmark+2)  
47b9 32 70 fe			ld (debug_mark+2),a  
47bc 18 03			jr .pastdmark  
47be ..			.dmark: db "TC6"  
47c1 f1			.pastdmark: pop af  
47c2			endm  
# End of macro DMARK
47c2						CALLMONITOR 
47c2 cd fb 19			call break_point_state  
47c5				endm  
# End of macro CALLMONITOR
47c5					endif 
47c5			 
47c5			 
47c5			.totnxt: 
47c5			 
47c5 77					ld (hl), a 
47c6 23					inc hl 
47c7					if DEBUG_FORTH_WORDS 
47c7						DMARK "TC7" 
47c7 f5				push af  
47c8 3a dc 47			ld a, (.dmark)  
47cb 32 6e fe			ld (debug_mark),a  
47ce 3a dd 47			ld a, (.dmark+1)  
47d1 32 6f fe			ld (debug_mark+1),a  
47d4 3a de 47			ld a, (.dmark+2)  
47d7 32 70 fe			ld (debug_mark+2),a  
47da 18 03			jr .pastdmark  
47dc ..			.dmark: db "TC7"  
47df f1			.pastdmark: pop af  
47e0			endm  
# End of macro DMARK
47e0						CALLMONITOR 
47e0 cd fb 19			call break_point_state  
47e3				endm  
# End of macro CALLMONITOR
47e3					endif 
47e3 c3 1b 47				jp .tot 
47e6			 
47e6					 
47e6			 
47e6			 
47e6			; for each char convert to low 
47e6					 
47e6			.totdone: 
47e6					if DEBUG_FORTH_WORDS 
47e6						DMARK "TCd" 
47e6 f5				push af  
47e7 3a fb 47			ld a, (.dmark)  
47ea 32 6e fe			ld (debug_mark),a  
47ed 3a fc 47			ld a, (.dmark+1)  
47f0 32 6f fe			ld (debug_mark+1),a  
47f3 3a fd 47			ld a, (.dmark+2)  
47f6 32 70 fe			ld (debug_mark+2),a  
47f9 18 03			jr .pastdmark  
47fb ..			.dmark: db "TCd"  
47fe f1			.pastdmark: pop af  
47ff			endm  
# End of macro DMARK
47ff						CALLMONITOR 
47ff cd fb 19			call break_point_state  
4802				endm  
# End of macro CALLMONITOR
4802					endif 
4802					NEXTW 
4802 c3 a0 24			jp macro_next 
4805				endm 
# End of macro NEXTW
4805			 
4805			.SUBSTR: 
4805				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4805 48				db WORD_SYS_CORE+52             
4806 63 48			dw .LEFT            
4808 07				db 6 + 1 
4809 .. 00			db "SUBSTR",0              
4810				endm 
# End of macro CWHEAD
4810			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4810			 
4810					if DEBUG_FORTH_WORDS_KEY 
4810						DMARK "SST" 
4810 f5				push af  
4811 3a 25 48			ld a, (.dmark)  
4814 32 6e fe			ld (debug_mark),a  
4817 3a 26 48			ld a, (.dmark+1)  
481a 32 6f fe			ld (debug_mark+1),a  
481d 3a 27 48			ld a, (.dmark+2)  
4820 32 70 fe			ld (debug_mark+2),a  
4823 18 03			jr .pastdmark  
4825 ..			.dmark: db "SST"  
4828 f1			.pastdmark: pop af  
4829			endm  
# End of macro DMARK
4829						CALLMONITOR 
4829 cd fb 19			call break_point_state  
482c				endm  
# End of macro CALLMONITOR
482c					endif 
482c			; TODO check string type 
482c					FORTH_DSP_VALUEHL 
482c cd ea 22			call macro_dsp_valuehl 
482f				endm 
# End of macro FORTH_DSP_VALUEHL
482f			 
482f e5					push hl      ; string length 
4830			 
4830					FORTH_DSP_POP 
4830 cd a2 23			call macro_forth_dsp_pop 
4833				endm 
# End of macro FORTH_DSP_POP
4833			 
4833					FORTH_DSP_VALUEHL 
4833 cd ea 22			call macro_dsp_valuehl 
4836				endm 
# End of macro FORTH_DSP_VALUEHL
4836			 
4836 e5					push hl     ; start char 
4837			 
4837					FORTH_DSP_POP 
4837 cd a2 23			call macro_forth_dsp_pop 
483a				endm 
# End of macro FORTH_DSP_POP
483a			 
483a			 
483a					FORTH_DSP_VALUE 
483a cd d3 22			call macro_forth_dsp_value 
483d				endm 
# End of macro FORTH_DSP_VALUE
483d			 
483d d1					pop de    ; get start post offset 
483e			 
483e 19					add hl, de    ; starting offset 
483f			 
483f c1					pop bc 
4840 c5					push bc      ; grab size of string 
4841			 
4841 e5					push hl    ; save string start  
4842			 
4842 26 00				ld h, 0 
4844 69					ld l, c 
4845 23					inc hl 
4846 23					inc hl 
4847			 
4847 cd 4d 14				call malloc 
484a				if DEBUG_FORTH_MALLOC_GUARD 
484a cc be 5d				call z,malloc_error 
484d				endif 
484d			 
484d eb					ex de, hl      ; save malloc area for string copy 
484e e1					pop hl    ; get back source 
484f c1					pop bc    ; get length of string back 
4850			 
4850 d5					push de    ; save malloc area for after we push 
4851 ed b0				ldir     ; copy substr 
4853			 
4853			 
4853 eb					ex de, hl 
4854 3e 00				ld a, 0 
4856 77					ld (hl), a   ; term substr 
4857			 
4857					 
4857 e1					pop hl    ; get malloc so we can push it 
4858 e5					push hl   ; save so we can free it afterwards 
4859			 
4859 cd 61 21				call forth_push_str 
485c			 
485c e1					pop hl 
485d cd 17 15				call free 
4860			 
4860					 
4860					 
4860			 
4860			 
4860					NEXTW 
4860 c3 a0 24			jp macro_next 
4863				endm 
# End of macro NEXTW
4863			 
4863			.LEFT: 
4863				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4863 48				db WORD_SYS_CORE+52             
4864 8b 48			dw .RIGHT            
4866 05				db 4 + 1 
4867 .. 00			db "LEFT",0              
486c				endm 
# End of macro CWHEAD
486c			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
486c					if DEBUG_FORTH_WORDS_KEY 
486c						DMARK "LEF" 
486c f5				push af  
486d 3a 81 48			ld a, (.dmark)  
4870 32 6e fe			ld (debug_mark),a  
4873 3a 82 48			ld a, (.dmark+1)  
4876 32 6f fe			ld (debug_mark+1),a  
4879 3a 83 48			ld a, (.dmark+2)  
487c 32 70 fe			ld (debug_mark+2),a  
487f 18 03			jr .pastdmark  
4881 ..			.dmark: db "LEF"  
4884 f1			.pastdmark: pop af  
4885			endm  
# End of macro DMARK
4885						CALLMONITOR 
4885 cd fb 19			call break_point_state  
4888				endm  
# End of macro CALLMONITOR
4888					endif 
4888			 
4888					NEXTW 
4888 c3 a0 24			jp macro_next 
488b				endm 
# End of macro NEXTW
488b			.RIGHT: 
488b				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
488b 48				db WORD_SYS_CORE+52             
488c b4 48			dw .STR2NUM            
488e 06				db 5 + 1 
488f .. 00			db "RIGHT",0              
4895				endm 
# End of macro CWHEAD
4895			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4895					if DEBUG_FORTH_WORDS_KEY 
4895						DMARK "RIG" 
4895 f5				push af  
4896 3a aa 48			ld a, (.dmark)  
4899 32 6e fe			ld (debug_mark),a  
489c 3a ab 48			ld a, (.dmark+1)  
489f 32 6f fe			ld (debug_mark+1),a  
48a2 3a ac 48			ld a, (.dmark+2)  
48a5 32 70 fe			ld (debug_mark+2),a  
48a8 18 03			jr .pastdmark  
48aa ..			.dmark: db "RIG"  
48ad f1			.pastdmark: pop af  
48ae			endm  
# End of macro DMARK
48ae						CALLMONITOR 
48ae cd fb 19			call break_point_state  
48b1				endm  
# End of macro CALLMONITOR
48b1					endif 
48b1			 
48b1					NEXTW 
48b1 c3 a0 24			jp macro_next 
48b4				endm 
# End of macro NEXTW
48b4			 
48b4			 
48b4			.STR2NUM: 
48b4				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
48b4 48				db WORD_SYS_CORE+52             
48b5 40 49			dw .NUM2STR            
48b7 08				db 7 + 1 
48b8 .. 00			db "STR2NUM",0              
48c0				endm 
# End of macro CWHEAD
48c0			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
48c0			 
48c0			 
48c0			; TODO STR type check to do 
48c0					if DEBUG_FORTH_WORDS_KEY 
48c0						DMARK "S2N" 
48c0 f5				push af  
48c1 3a d5 48			ld a, (.dmark)  
48c4 32 6e fe			ld (debug_mark),a  
48c7 3a d6 48			ld a, (.dmark+1)  
48ca 32 6f fe			ld (debug_mark+1),a  
48cd 3a d7 48			ld a, (.dmark+2)  
48d0 32 70 fe			ld (debug_mark+2),a  
48d3 18 03			jr .pastdmark  
48d5 ..			.dmark: db "S2N"  
48d8 f1			.pastdmark: pop af  
48d9			endm  
# End of macro DMARK
48d9						CALLMONITOR 
48d9 cd fb 19			call break_point_state  
48dc				endm  
# End of macro CALLMONITOR
48dc					endif 
48dc			 
48dc					;FORTH_DSP 
48dc					FORTH_DSP_VALUE 
48dc cd d3 22			call macro_forth_dsp_value 
48df				endm 
# End of macro FORTH_DSP_VALUE
48df					;inc hl 
48df			 
48df eb					ex de, hl 
48e0					if DEBUG_FORTH_WORDS 
48e0						DMARK "S2a" 
48e0 f5				push af  
48e1 3a f5 48			ld a, (.dmark)  
48e4 32 6e fe			ld (debug_mark),a  
48e7 3a f6 48			ld a, (.dmark+1)  
48ea 32 6f fe			ld (debug_mark+1),a  
48ed 3a f7 48			ld a, (.dmark+2)  
48f0 32 70 fe			ld (debug_mark+2),a  
48f3 18 03			jr .pastdmark  
48f5 ..			.dmark: db "S2a"  
48f8 f1			.pastdmark: pop af  
48f9			endm  
# End of macro DMARK
48f9						CALLMONITOR 
48f9 cd fb 19			call break_point_state  
48fc				endm  
# End of macro CALLMONITOR
48fc					endif 
48fc cd 7b 13				call string_to_uint16 
48ff			 
48ff					if DEBUG_FORTH_WORDS 
48ff						DMARK "S2b" 
48ff f5				push af  
4900 3a 14 49			ld a, (.dmark)  
4903 32 6e fe			ld (debug_mark),a  
4906 3a 15 49			ld a, (.dmark+1)  
4909 32 6f fe			ld (debug_mark+1),a  
490c 3a 16 49			ld a, (.dmark+2)  
490f 32 70 fe			ld (debug_mark+2),a  
4912 18 03			jr .pastdmark  
4914 ..			.dmark: db "S2b"  
4917 f1			.pastdmark: pop af  
4918			endm  
# End of macro DMARK
4918						CALLMONITOR 
4918 cd fb 19			call break_point_state  
491b				endm  
# End of macro CALLMONITOR
491b					endif 
491b			;		push hl 
491b					FORTH_DSP_POP 
491b cd a2 23			call macro_forth_dsp_pop 
491e				endm 
# End of macro FORTH_DSP_POP
491e			;		pop hl 
491e					 
491e					if DEBUG_FORTH_WORDS 
491e						DMARK "S2b" 
491e f5				push af  
491f 3a 33 49			ld a, (.dmark)  
4922 32 6e fe			ld (debug_mark),a  
4925 3a 34 49			ld a, (.dmark+1)  
4928 32 6f fe			ld (debug_mark+1),a  
492b 3a 35 49			ld a, (.dmark+2)  
492e 32 70 fe			ld (debug_mark+2),a  
4931 18 03			jr .pastdmark  
4933 ..			.dmark: db "S2b"  
4936 f1			.pastdmark: pop af  
4937			endm  
# End of macro DMARK
4937						CALLMONITOR 
4937 cd fb 19			call break_point_state  
493a				endm  
# End of macro CALLMONITOR
493a					endif 
493a cd f3 20				call forth_push_numhl	 
493d			 
493d				 
493d				       NEXTW 
493d c3 a0 24			jp macro_next 
4940				endm 
# End of macro NEXTW
4940			.NUM2STR: 
4940				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4940 48				db WORD_SYS_CORE+52             
4941 4f 49			dw .CONCAT            
4943 08				db 7 + 1 
4944 .. 00			db "NUM2STR",0              
494c				endm 
# End of macro CWHEAD
494c			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
494c			 
494c			;		; malloc a string to target 
494c			;		ld hl, 10     ; TODO max string size should be fine 
494c			;		call malloc 
494c			;		push hl    ; save malloc location 
494c			; 
494c			; 
494c			;; TODO check int type 
494c			;		FORTH_DSP_VALUEHL 
494c			;		ld a, l 
494c			;		call DispAToASCII   
494c			;;TODO need to chage above call to dump into string 
494c			; 
494c			; 
494c			 
494c				       NEXTW 
494c c3 a0 24			jp macro_next 
494f				endm 
# End of macro NEXTW
494f			 
494f			.CONCAT: 
494f				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
494f 48				db WORD_SYS_CORE+52             
4950 02 4a			dw .FIND            
4952 07				db 6 + 1 
4953 .. 00			db "CONCAT",0              
495a				endm 
# End of macro CWHEAD
495a			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
495a			 
495a			; TODO check string type 
495a			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
495a			 
495a					if DEBUG_FORTH_WORDS_KEY 
495a						DMARK "CON" 
495a f5				push af  
495b 3a 6f 49			ld a, (.dmark)  
495e 32 6e fe			ld (debug_mark),a  
4961 3a 70 49			ld a, (.dmark+1)  
4964 32 6f fe			ld (debug_mark+1),a  
4967 3a 71 49			ld a, (.dmark+2)  
496a 32 70 fe			ld (debug_mark+2),a  
496d 18 03			jr .pastdmark  
496f ..			.dmark: db "CON"  
4972 f1			.pastdmark: pop af  
4973			endm  
# End of macro DMARK
4973						CALLMONITOR 
4973 cd fb 19			call break_point_state  
4976				endm  
# End of macro CALLMONITOR
4976					endif 
4976			 
4976			 
4976					FORTH_DSP_VALUE 
4976 cd d3 22			call macro_forth_dsp_value 
4979				endm 
# End of macro FORTH_DSP_VALUE
4979 e5					push hl   ; s2 
497a			 
497a					FORTH_DSP_POP 
497a cd a2 23			call macro_forth_dsp_pop 
497d				endm 
# End of macro FORTH_DSP_POP
497d			 
497d					FORTH_DSP_VALUE 
497d cd d3 22			call macro_forth_dsp_value 
4980				endm 
# End of macro FORTH_DSP_VALUE
4980			 
4980 e5					push hl   ; s1 
4981			 
4981					FORTH_DSP_POP 
4981 cd a2 23			call macro_forth_dsp_pop 
4984				endm 
# End of macro FORTH_DSP_POP
4984					 
4984			 
4984					; copy s1 
4984			 
4984				 
4984					; save ptr 
4984 e1					pop hl  
4985 e5					push hl 
4986 3e 00				ld a, 0 
4988 cd ef 13				call strlent 
498b					;inc hl    ; zer0 
498b 06 00				ld b, 0 
498d 4d					ld c, l 
498e e1					pop hl		 
498f 11 c4 f1				ld de, scratch	 
4992					if DEBUG_FORTH_WORDS 
4992						DMARK "CO1" 
4992 f5				push af  
4993 3a a7 49			ld a, (.dmark)  
4996 32 6e fe			ld (debug_mark),a  
4999 3a a8 49			ld a, (.dmark+1)  
499c 32 6f fe			ld (debug_mark+1),a  
499f 3a a9 49			ld a, (.dmark+2)  
49a2 32 70 fe			ld (debug_mark+2),a  
49a5 18 03			jr .pastdmark  
49a7 ..			.dmark: db "CO1"  
49aa f1			.pastdmark: pop af  
49ab			endm  
# End of macro DMARK
49ab						CALLMONITOR 
49ab cd fb 19			call break_point_state  
49ae				endm  
# End of macro CALLMONITOR
49ae					endif 
49ae ed b0				ldir 
49b0			 
49b0 e1					pop hl 
49b1 e5					push hl 
49b2 d5					push de 
49b3			 
49b3			 
49b3 3e 00				ld a, 0 
49b5 cd ef 13				call strlent 
49b8 23					inc hl    ; zer0 
49b9 23					inc hl 
49ba 06 00				ld b, 0 
49bc 4d					ld c, l 
49bd d1					pop de 
49be e1					pop hl		 
49bf					if DEBUG_FORTH_WORDS 
49bf						DMARK "CO2" 
49bf f5				push af  
49c0 3a d4 49			ld a, (.dmark)  
49c3 32 6e fe			ld (debug_mark),a  
49c6 3a d5 49			ld a, (.dmark+1)  
49c9 32 6f fe			ld (debug_mark+1),a  
49cc 3a d6 49			ld a, (.dmark+2)  
49cf 32 70 fe			ld (debug_mark+2),a  
49d2 18 03			jr .pastdmark  
49d4 ..			.dmark: db "CO2"  
49d7 f1			.pastdmark: pop af  
49d8			endm  
# End of macro DMARK
49d8						CALLMONITOR 
49d8 cd fb 19			call break_point_state  
49db				endm  
# End of macro CALLMONITOR
49db					endif 
49db ed b0				ldir 
49dd			 
49dd			 
49dd			 
49dd 21 c4 f1				ld hl, scratch 
49e0					if DEBUG_FORTH_WORDS 
49e0						DMARK "CO5" 
49e0 f5				push af  
49e1 3a f5 49			ld a, (.dmark)  
49e4 32 6e fe			ld (debug_mark),a  
49e7 3a f6 49			ld a, (.dmark+1)  
49ea 32 6f fe			ld (debug_mark+1),a  
49ed 3a f7 49			ld a, (.dmark+2)  
49f0 32 70 fe			ld (debug_mark+2),a  
49f3 18 03			jr .pastdmark  
49f5 ..			.dmark: db "CO5"  
49f8 f1			.pastdmark: pop af  
49f9			endm  
# End of macro DMARK
49f9						CALLMONITOR 
49f9 cd fb 19			call break_point_state  
49fc				endm  
# End of macro CALLMONITOR
49fc					endif 
49fc			 
49fc cd 61 21				call forth_push_str 
49ff			 
49ff			 
49ff			 
49ff			 
49ff				       NEXTW 
49ff c3 a0 24			jp macro_next 
4a02				endm 
# End of macro NEXTW
4a02			 
4a02			 
4a02			.FIND: 
4a02				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4a02 4b				db WORD_SYS_CORE+55             
4a03 c0 4a			dw .LEN            
4a05 05				db 4 + 1 
4a06 .. 00			db "FIND",0              
4a0b				endm 
# End of macro CWHEAD
4a0b			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4a0b			 
4a0b					if DEBUG_FORTH_WORDS_KEY 
4a0b						DMARK "FND" 
4a0b f5				push af  
4a0c 3a 20 4a			ld a, (.dmark)  
4a0f 32 6e fe			ld (debug_mark),a  
4a12 3a 21 4a			ld a, (.dmark+1)  
4a15 32 6f fe			ld (debug_mark+1),a  
4a18 3a 22 4a			ld a, (.dmark+2)  
4a1b 32 70 fe			ld (debug_mark+2),a  
4a1e 18 03			jr .pastdmark  
4a20 ..			.dmark: db "FND"  
4a23 f1			.pastdmark: pop af  
4a24			endm  
# End of macro DMARK
4a24						CALLMONITOR 
4a24 cd fb 19			call break_point_state  
4a27				endm  
# End of macro CALLMONITOR
4a27					endif 
4a27			 
4a27			; TODO check string type 
4a27					FORTH_DSP_VALUE 
4a27 cd d3 22			call macro_forth_dsp_value 
4a2a				endm 
# End of macro FORTH_DSP_VALUE
4a2a			 
4a2a e5					push hl    
4a2b 7e					ld a,(hl)    ; char to find   
4a2c			; TODO change char to substr 
4a2c			 
4a2c f5					push af 
4a2d					 
4a2d			 
4a2d			 
4a2d					if DEBUG_FORTH_WORDS 
4a2d						DMARK "FN1" 
4a2d f5				push af  
4a2e 3a 42 4a			ld a, (.dmark)  
4a31 32 6e fe			ld (debug_mark),a  
4a34 3a 43 4a			ld a, (.dmark+1)  
4a37 32 6f fe			ld (debug_mark+1),a  
4a3a 3a 44 4a			ld a, (.dmark+2)  
4a3d 32 70 fe			ld (debug_mark+2),a  
4a40 18 03			jr .pastdmark  
4a42 ..			.dmark: db "FN1"  
4a45 f1			.pastdmark: pop af  
4a46			endm  
# End of macro DMARK
4a46						CALLMONITOR 
4a46 cd fb 19			call break_point_state  
4a49				endm  
# End of macro CALLMONITOR
4a49					endif 
4a49			 
4a49					FORTH_DSP_POP 
4a49 cd a2 23			call macro_forth_dsp_pop 
4a4c				endm 
# End of macro FORTH_DSP_POP
4a4c			 
4a4c					; string to search 
4a4c			 
4a4c					FORTH_DSP_VALUE 
4a4c cd d3 22			call macro_forth_dsp_value 
4a4f				endm 
# End of macro FORTH_DSP_VALUE
4a4f			 
4a4f d1					pop de  ; d is char to find  
4a50			 
4a50					if DEBUG_FORTH_WORDS 
4a50						DMARK "FN2" 
4a50 f5				push af  
4a51 3a 65 4a			ld a, (.dmark)  
4a54 32 6e fe			ld (debug_mark),a  
4a57 3a 66 4a			ld a, (.dmark+1)  
4a5a 32 6f fe			ld (debug_mark+1),a  
4a5d 3a 67 4a			ld a, (.dmark+2)  
4a60 32 70 fe			ld (debug_mark+2),a  
4a63 18 03			jr .pastdmark  
4a65 ..			.dmark: db "FN2"  
4a68 f1			.pastdmark: pop af  
4a69			endm  
# End of macro DMARK
4a69						CALLMONITOR 
4a69 cd fb 19			call break_point_state  
4a6c				endm  
# End of macro CALLMONITOR
4a6c					endif 
4a6c					 
4a6c 01 00 00				ld bc, 0 
4a6f 7e			.findchar:      ld a,(hl) 
4a70 fe 00				cp 0   		 
4a72 28 27				jr z, .finddone     
4a74 ba					cp d 
4a75 28 20				jr z, .foundchar 
4a77 03					inc bc 
4a78 23					inc hl 
4a79					if DEBUG_FORTH_WORDS 
4a79						DMARK "FN3" 
4a79 f5				push af  
4a7a 3a 8e 4a			ld a, (.dmark)  
4a7d 32 6e fe			ld (debug_mark),a  
4a80 3a 8f 4a			ld a, (.dmark+1)  
4a83 32 6f fe			ld (debug_mark+1),a  
4a86 3a 90 4a			ld a, (.dmark+2)  
4a89 32 70 fe			ld (debug_mark+2),a  
4a8c 18 03			jr .pastdmark  
4a8e ..			.dmark: db "FN3"  
4a91 f1			.pastdmark: pop af  
4a92			endm  
# End of macro DMARK
4a92						CALLMONITOR 
4a92 cd fb 19			call break_point_state  
4a95				endm  
# End of macro CALLMONITOR
4a95					endif 
4a95 18 d8				jr .findchar 
4a97			 
4a97			 
4a97 c5			.foundchar:	push bc 
4a98 e1					pop hl 
4a99 18 03				jr .findexit 
4a9b			 
4a9b			 
4a9b							 
4a9b			 
4a9b			.finddone:     ; got to end of string with no find 
4a9b 21 00 00				ld hl, 0 
4a9e			.findexit: 
4a9e			 
4a9e					if DEBUG_FORTH_WORDS 
4a9e						DMARK "FNd" 
4a9e f5				push af  
4a9f 3a b3 4a			ld a, (.dmark)  
4aa2 32 6e fe			ld (debug_mark),a  
4aa5 3a b4 4a			ld a, (.dmark+1)  
4aa8 32 6f fe			ld (debug_mark+1),a  
4aab 3a b5 4a			ld a, (.dmark+2)  
4aae 32 70 fe			ld (debug_mark+2),a  
4ab1 18 03			jr .pastdmark  
4ab3 ..			.dmark: db "FNd"  
4ab6 f1			.pastdmark: pop af  
4ab7			endm  
# End of macro DMARK
4ab7						CALLMONITOR 
4ab7 cd fb 19			call break_point_state  
4aba				endm  
# End of macro CALLMONITOR
4aba					endif 
4aba cd f3 20			call forth_push_numhl 
4abd			 
4abd				       NEXTW 
4abd c3 a0 24			jp macro_next 
4ac0				endm 
# End of macro NEXTW
4ac0			 
4ac0			.LEN: 
4ac0				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4ac0 4c				db WORD_SYS_CORE+56             
4ac1 2a 4b			dw .ASC            
4ac3 06				db 5 + 1 
4ac4 .. 00			db "COUNT",0              
4aca				endm 
# End of macro CWHEAD
4aca			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4aca			 
4aca					if DEBUG_FORTH_WORDS_KEY 
4aca						DMARK "CNT" 
4aca f5				push af  
4acb 3a df 4a			ld a, (.dmark)  
4ace 32 6e fe			ld (debug_mark),a  
4ad1 3a e0 4a			ld a, (.dmark+1)  
4ad4 32 6f fe			ld (debug_mark+1),a  
4ad7 3a e1 4a			ld a, (.dmark+2)  
4ada 32 70 fe			ld (debug_mark+2),a  
4add 18 03			jr .pastdmark  
4adf ..			.dmark: db "CNT"  
4ae2 f1			.pastdmark: pop af  
4ae3			endm  
# End of macro DMARK
4ae3						CALLMONITOR 
4ae3 cd fb 19			call break_point_state  
4ae6				endm  
# End of macro CALLMONITOR
4ae6					endif 
4ae6			; TODO check string type 
4ae6					FORTH_DSP_VALUE 
4ae6 cd d3 22			call macro_forth_dsp_value 
4ae9				endm 
# End of macro FORTH_DSP_VALUE
4ae9			 
4ae9			 
4ae9					if DEBUG_FORTH_WORDS 
4ae9						DMARK "CN?" 
4ae9 f5				push af  
4aea 3a fe 4a			ld a, (.dmark)  
4aed 32 6e fe			ld (debug_mark),a  
4af0 3a ff 4a			ld a, (.dmark+1)  
4af3 32 6f fe			ld (debug_mark+1),a  
4af6 3a 00 4b			ld a, (.dmark+2)  
4af9 32 70 fe			ld (debug_mark+2),a  
4afc 18 03			jr .pastdmark  
4afe ..			.dmark: db "CN?"  
4b01 f1			.pastdmark: pop af  
4b02			endm  
# End of macro DMARK
4b02						CALLMONITOR 
4b02 cd fb 19			call break_point_state  
4b05				endm  
# End of macro CALLMONITOR
4b05					endif 
4b05 cd e4 13				call strlenz 
4b08					if DEBUG_FORTH_WORDS 
4b08						DMARK "CNl" 
4b08 f5				push af  
4b09 3a 1d 4b			ld a, (.dmark)  
4b0c 32 6e fe			ld (debug_mark),a  
4b0f 3a 1e 4b			ld a, (.dmark+1)  
4b12 32 6f fe			ld (debug_mark+1),a  
4b15 3a 1f 4b			ld a, (.dmark+2)  
4b18 32 70 fe			ld (debug_mark+2),a  
4b1b 18 03			jr .pastdmark  
4b1d ..			.dmark: db "CNl"  
4b20 f1			.pastdmark: pop af  
4b21			endm  
# End of macro DMARK
4b21						CALLMONITOR 
4b21 cd fb 19			call break_point_state  
4b24				endm  
# End of macro CALLMONITOR
4b24					endif 
4b24			 
4b24 cd f3 20				call forth_push_numhl 
4b27			 
4b27			 
4b27			 
4b27				       NEXTW 
4b27 c3 a0 24			jp macro_next 
4b2a				endm 
# End of macro NEXTW
4b2a			.ASC: 
4b2a				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4b2a 4d				db WORD_SYS_CORE+57             
4b2b 98 4b			dw .CHR            
4b2d 04				db 3 + 1 
4b2e .. 00			db "ASC",0              
4b32				endm 
# End of macro CWHEAD
4b32			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4b32					if DEBUG_FORTH_WORDS_KEY 
4b32						DMARK "ASC" 
4b32 f5				push af  
4b33 3a 47 4b			ld a, (.dmark)  
4b36 32 6e fe			ld (debug_mark),a  
4b39 3a 48 4b			ld a, (.dmark+1)  
4b3c 32 6f fe			ld (debug_mark+1),a  
4b3f 3a 49 4b			ld a, (.dmark+2)  
4b42 32 70 fe			ld (debug_mark+2),a  
4b45 18 03			jr .pastdmark  
4b47 ..			.dmark: db "ASC"  
4b4a f1			.pastdmark: pop af  
4b4b			endm  
# End of macro DMARK
4b4b						CALLMONITOR 
4b4b cd fb 19			call break_point_state  
4b4e				endm  
# End of macro CALLMONITOR
4b4e					endif 
4b4e					FORTH_DSP_VALUE 
4b4e cd d3 22			call macro_forth_dsp_value 
4b51				endm 
# End of macro FORTH_DSP_VALUE
4b51					;v5 FORTH_DSP_VALUE 
4b51			;		inc hl      ; now at start of numeric as string 
4b51			 
4b51 e5					push hl 
4b52			 
4b52					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b52 cd a2 23			call macro_forth_dsp_pop 
4b55				endm 
# End of macro FORTH_DSP_POP
4b55			 
4b55 e1					pop hl 
4b56			 
4b56					if DEBUG_FORTH_WORDS 
4b56						DMARK "AS1" 
4b56 f5				push af  
4b57 3a 6b 4b			ld a, (.dmark)  
4b5a 32 6e fe			ld (debug_mark),a  
4b5d 3a 6c 4b			ld a, (.dmark+1)  
4b60 32 6f fe			ld (debug_mark+1),a  
4b63 3a 6d 4b			ld a, (.dmark+2)  
4b66 32 70 fe			ld (debug_mark+2),a  
4b69 18 03			jr .pastdmark  
4b6b ..			.dmark: db "AS1"  
4b6e f1			.pastdmark: pop af  
4b6f			endm  
# End of macro DMARK
4b6f						CALLMONITOR 
4b6f cd fb 19			call break_point_state  
4b72				endm  
# End of macro CALLMONITOR
4b72					endif 
4b72					; push the content of a onto the stack as a value 
4b72			 
4b72 7e					ld a,(hl)   ; get char 
4b73 26 00				ld h,0 
4b75 6f					ld l,a 
4b76					if DEBUG_FORTH_WORDS 
4b76						DMARK "AS2" 
4b76 f5				push af  
4b77 3a 8b 4b			ld a, (.dmark)  
4b7a 32 6e fe			ld (debug_mark),a  
4b7d 3a 8c 4b			ld a, (.dmark+1)  
4b80 32 6f fe			ld (debug_mark+1),a  
4b83 3a 8d 4b			ld a, (.dmark+2)  
4b86 32 70 fe			ld (debug_mark+2),a  
4b89 18 03			jr .pastdmark  
4b8b ..			.dmark: db "AS2"  
4b8e f1			.pastdmark: pop af  
4b8f			endm  
# End of macro DMARK
4b8f						CALLMONITOR 
4b8f cd fb 19			call break_point_state  
4b92				endm  
# End of macro CALLMONITOR
4b92					endif 
4b92 cd f3 20				call forth_push_numhl 
4b95			 
4b95				       NEXTW 
4b95 c3 a0 24			jp macro_next 
4b98				endm 
# End of macro NEXTW
4b98			 
4b98			.CHR: 
4b98				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4b98 4d				db WORD_SYS_CORE+57             
4b99 d4 4b			dw .ENDSTR            
4b9b 04				db 3 + 1 
4b9c .. 00			db "CHR",0              
4ba0				endm 
# End of macro CWHEAD
4ba0			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4ba0					if DEBUG_FORTH_WORDS_KEY 
4ba0						DMARK "CHR" 
4ba0 f5				push af  
4ba1 3a b5 4b			ld a, (.dmark)  
4ba4 32 6e fe			ld (debug_mark),a  
4ba7 3a b6 4b			ld a, (.dmark+1)  
4baa 32 6f fe			ld (debug_mark+1),a  
4bad 3a b7 4b			ld a, (.dmark+2)  
4bb0 32 70 fe			ld (debug_mark+2),a  
4bb3 18 03			jr .pastdmark  
4bb5 ..			.dmark: db "CHR"  
4bb8 f1			.pastdmark: pop af  
4bb9			endm  
# End of macro DMARK
4bb9						CALLMONITOR 
4bb9 cd fb 19			call break_point_state  
4bbc				endm  
# End of macro CALLMONITOR
4bbc					endif 
4bbc					FORTH_DSP_VALUEHL 
4bbc cd ea 22			call macro_dsp_valuehl 
4bbf				endm 
# End of macro FORTH_DSP_VALUEHL
4bbf			 
4bbf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bbf cd a2 23			call macro_forth_dsp_pop 
4bc2				endm 
# End of macro FORTH_DSP_POP
4bc2			 
4bc2					; save asci byte as a zero term string and push string 
4bc2			 
4bc2 7d					ld a,l 
4bc3 32 c4 f1				ld (scratch), a 
4bc6			 
4bc6 3e 00				ld a, 0 
4bc8 32 c5 f1				ld (scratch+1), a 
4bcb			 
4bcb 21 c4 f1				ld hl, scratch 
4bce cd 61 21				call forth_push_str 
4bd1			 
4bd1			 
4bd1				       NEXTW 
4bd1 c3 a0 24			jp macro_next 
4bd4				endm 
# End of macro NEXTW
4bd4			 
4bd4			 
4bd4			 
4bd4			 
4bd4			.ENDSTR: 
4bd4			; eof 
4bd4			 
# End of file forth_words_str.asm
4bd4			include "forth_words_key.asm" 
4bd4			 
4bd4			; | ## Keyboard Words 
4bd4			 
4bd4			.KEY: 
4bd4				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4bd4 3e				db WORD_SYS_CORE+42             
4bd5 04 4c			dw .WAITK            
4bd7 04				db 3 + 1 
4bd8 .. 00			db "KEY",0              
4bdc				endm 
# End of macro CWHEAD
4bdc			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4bdc			 
4bdc					if DEBUG_FORTH_WORDS_KEY 
4bdc						DMARK "KEY" 
4bdc f5				push af  
4bdd 3a f1 4b			ld a, (.dmark)  
4be0 32 6e fe			ld (debug_mark),a  
4be3 3a f2 4b			ld a, (.dmark+1)  
4be6 32 6f fe			ld (debug_mark+1),a  
4be9 3a f3 4b			ld a, (.dmark+2)  
4bec 32 70 fe			ld (debug_mark+2),a  
4bef 18 03			jr .pastdmark  
4bf1 ..			.dmark: db "KEY"  
4bf4 f1			.pastdmark: pop af  
4bf5			endm  
# End of macro DMARK
4bf5						CALLMONITOR 
4bf5 cd fb 19			call break_point_state  
4bf8				endm  
# End of macro CALLMONITOR
4bf8					endif 
4bf8			; TODO currently waits 
4bf8 cd d2 78				call cin 
4bfb					;call cin_wait 
4bfb 6f					ld l, a 
4bfc 26 00				ld h, 0 
4bfe cd f3 20				call forth_push_numhl 
4c01					NEXTW 
4c01 c3 a0 24			jp macro_next 
4c04				endm 
# End of macro NEXTW
4c04			.WAITK: 
4c04				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4c04 3f				db WORD_SYS_CORE+43             
4c05 36 4c			dw .ACCEPT            
4c07 06				db 5 + 1 
4c08 .. 00			db "WAITK",0              
4c0e				endm 
# End of macro CWHEAD
4c0e			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4c0e					if DEBUG_FORTH_WORDS_KEY 
4c0e						DMARK "WAI" 
4c0e f5				push af  
4c0f 3a 23 4c			ld a, (.dmark)  
4c12 32 6e fe			ld (debug_mark),a  
4c15 3a 24 4c			ld a, (.dmark+1)  
4c18 32 6f fe			ld (debug_mark+1),a  
4c1b 3a 25 4c			ld a, (.dmark+2)  
4c1e 32 70 fe			ld (debug_mark+2),a  
4c21 18 03			jr .pastdmark  
4c23 ..			.dmark: db "WAI"  
4c26 f1			.pastdmark: pop af  
4c27			endm  
# End of macro DMARK
4c27						CALLMONITOR 
4c27 cd fb 19			call break_point_state  
4c2a				endm  
# End of macro CALLMONITOR
4c2a					endif 
4c2a cd c1 78				call cin_wait 
4c2d 6f					ld l, a 
4c2e 26 00				ld h, 0 
4c30 cd f3 20				call forth_push_numhl 
4c33					NEXTW 
4c33 c3 a0 24			jp macro_next 
4c36				endm 
# End of macro NEXTW
4c36			.ACCEPT: 
4c36				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4c36 40				db WORD_SYS_CORE+44             
4c37 94 4c			dw .EDIT            
4c39 07				db 6 + 1 
4c3a .. 00			db "ACCEPT",0              
4c41				endm 
# End of macro CWHEAD
4c41			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4c41					; TODO crashes on push 
4c41					if DEBUG_FORTH_WORDS_KEY 
4c41						DMARK "ACC" 
4c41 f5				push af  
4c42 3a 56 4c			ld a, (.dmark)  
4c45 32 6e fe			ld (debug_mark),a  
4c48 3a 57 4c			ld a, (.dmark+1)  
4c4b 32 6f fe			ld (debug_mark+1),a  
4c4e 3a 58 4c			ld a, (.dmark+2)  
4c51 32 70 fe			ld (debug_mark+2),a  
4c54 18 03			jr .pastdmark  
4c56 ..			.dmark: db "ACC"  
4c59 f1			.pastdmark: pop af  
4c5a			endm  
# End of macro DMARK
4c5a						CALLMONITOR 
4c5a cd fb 19			call break_point_state  
4c5d				endm  
# End of macro CALLMONITOR
4c5d					endif 
4c5d 21 c2 f3				ld hl, os_input 
4c60 3e 00				ld a, 0 
4c62 77					ld (hl),a 
4c63 3a 61 fa				ld a,(f_cursor_ptr) 
4c66 16 64				ld d, 100 
4c68 0e 00				ld c, 0 
4c6a 1e 28				ld e, 40 
4c6c cd b3 0f				call input_str 
4c6f					; TODO perhaps do a type check and wrap in quotes if not a number 
4c6f 21 c2 f3				ld hl, os_input 
4c72					if DEBUG_FORTH_WORDS 
4c72						DMARK "AC1" 
4c72 f5				push af  
4c73 3a 87 4c			ld a, (.dmark)  
4c76 32 6e fe			ld (debug_mark),a  
4c79 3a 88 4c			ld a, (.dmark+1)  
4c7c 32 6f fe			ld (debug_mark+1),a  
4c7f 3a 89 4c			ld a, (.dmark+2)  
4c82 32 70 fe			ld (debug_mark+2),a  
4c85 18 03			jr .pastdmark  
4c87 ..			.dmark: db "AC1"  
4c8a f1			.pastdmark: pop af  
4c8b			endm  
# End of macro DMARK
4c8b						CALLMONITOR 
4c8b cd fb 19			call break_point_state  
4c8e				endm  
# End of macro CALLMONITOR
4c8e					endif 
4c8e cd 61 21				call forth_push_str 
4c91					NEXTW 
4c91 c3 a0 24			jp macro_next 
4c94				endm 
# End of macro NEXTW
4c94			 
4c94			.EDIT: 
4c94				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4c94 40				db WORD_SYS_CORE+44             
4c95 36 4d			dw .DEDIT            
4c97 05				db 4 + 1 
4c98 .. 00			db "EDIT",0              
4c9d				endm 
# End of macro CWHEAD
4c9d			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4c9d			 
4c9d					; TODO does not copy from stack 
4c9d					if DEBUG_FORTH_WORDS_KEY 
4c9d						DMARK "EDT" 
4c9d f5				push af  
4c9e 3a b2 4c			ld a, (.dmark)  
4ca1 32 6e fe			ld (debug_mark),a  
4ca4 3a b3 4c			ld a, (.dmark+1)  
4ca7 32 6f fe			ld (debug_mark+1),a  
4caa 3a b4 4c			ld a, (.dmark+2)  
4cad 32 70 fe			ld (debug_mark+2),a  
4cb0 18 03			jr .pastdmark  
4cb2 ..			.dmark: db "EDT"  
4cb5 f1			.pastdmark: pop af  
4cb6			endm  
# End of macro DMARK
4cb6						CALLMONITOR 
4cb6 cd fb 19			call break_point_state  
4cb9				endm  
# End of macro CALLMONITOR
4cb9					endif 
4cb9			 
4cb9					;FORTH_DSP 
4cb9					FORTH_DSP_VALUEHL 
4cb9 cd ea 22			call macro_dsp_valuehl 
4cbc				endm 
# End of macro FORTH_DSP_VALUEHL
4cbc			;		inc hl    ; TODO do type check 
4cbc			 
4cbc			;		call get_word_hl 
4cbc e5					push hl 
4cbd					if DEBUG_FORTH_WORDS 
4cbd						DMARK "EDp" 
4cbd f5				push af  
4cbe 3a d2 4c			ld a, (.dmark)  
4cc1 32 6e fe			ld (debug_mark),a  
4cc4 3a d3 4c			ld a, (.dmark+1)  
4cc7 32 6f fe			ld (debug_mark+1),a  
4cca 3a d4 4c			ld a, (.dmark+2)  
4ccd 32 70 fe			ld (debug_mark+2),a  
4cd0 18 03			jr .pastdmark  
4cd2 ..			.dmark: db "EDp"  
4cd5 f1			.pastdmark: pop af  
4cd6			endm  
# End of macro DMARK
4cd6						CALLMONITOR 
4cd6 cd fb 19			call break_point_state  
4cd9				endm  
# End of macro CALLMONITOR
4cd9					endif 
4cd9				;	ld a, 0 
4cd9 cd e4 13				call strlenz 
4cdc 23					inc hl 
4cdd			 
4cdd 06 00				ld b, 0 
4cdf 4d					ld c, l 
4ce0			 
4ce0 e1					pop hl 
4ce1 11 c2 f3				ld de, os_input 
4ce4					if DEBUG_FORTH_WORDS_KEY 
4ce4						DMARK "EDc" 
4ce4 f5				push af  
4ce5 3a f9 4c			ld a, (.dmark)  
4ce8 32 6e fe			ld (debug_mark),a  
4ceb 3a fa 4c			ld a, (.dmark+1)  
4cee 32 6f fe			ld (debug_mark+1),a  
4cf1 3a fb 4c			ld a, (.dmark+2)  
4cf4 32 70 fe			ld (debug_mark+2),a  
4cf7 18 03			jr .pastdmark  
4cf9 ..			.dmark: db "EDc"  
4cfc f1			.pastdmark: pop af  
4cfd			endm  
# End of macro DMARK
4cfd						CALLMONITOR 
4cfd cd fb 19			call break_point_state  
4d00				endm  
# End of macro CALLMONITOR
4d00					endif 
4d00 ed b0				ldir 
4d02			 
4d02			 
4d02 21 c2 f3				ld hl, os_input 
4d05					;ld a, 0 
4d05					;ld (hl),a 
4d05 3a 61 fa				ld a,(f_cursor_ptr) 
4d08 16 64				ld d, 100 
4d0a 0e 00				ld c, 0 
4d0c 1e 28				ld e, 40 
4d0e cd b3 0f				call input_str 
4d11					; TODO perhaps do a type check and wrap in quotes if not a number 
4d11 21 c2 f3				ld hl, os_input 
4d14					if DEBUG_FORTH_WORDS 
4d14						DMARK "ED1" 
4d14 f5				push af  
4d15 3a 29 4d			ld a, (.dmark)  
4d18 32 6e fe			ld (debug_mark),a  
4d1b 3a 2a 4d			ld a, (.dmark+1)  
4d1e 32 6f fe			ld (debug_mark+1),a  
4d21 3a 2b 4d			ld a, (.dmark+2)  
4d24 32 70 fe			ld (debug_mark+2),a  
4d27 18 03			jr .pastdmark  
4d29 ..			.dmark: db "ED1"  
4d2c f1			.pastdmark: pop af  
4d2d			endm  
# End of macro DMARK
4d2d						CALLMONITOR 
4d2d cd fb 19			call break_point_state  
4d30				endm  
# End of macro CALLMONITOR
4d30					endif 
4d30 cd 61 21				call forth_push_str 
4d33					NEXTW 
4d33 c3 a0 24			jp macro_next 
4d36				endm 
# End of macro NEXTW
4d36			 
4d36			.DEDIT: 
4d36				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4d36 40				db WORD_SYS_CORE+44             
4d37 98 4d			dw .ENDKEY            
4d39 06				db 5 + 1 
4d3a .. 00			db "DEDIT",0              
4d40				endm 
# End of macro CWHEAD
4d40			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4d40			 
4d40					; TODO does not copy from stack 
4d40					if DEBUG_FORTH_WORDS_KEY 
4d40						DMARK "DED" 
4d40 f5				push af  
4d41 3a 55 4d			ld a, (.dmark)  
4d44 32 6e fe			ld (debug_mark),a  
4d47 3a 56 4d			ld a, (.dmark+1)  
4d4a 32 6f fe			ld (debug_mark+1),a  
4d4d 3a 57 4d			ld a, (.dmark+2)  
4d50 32 70 fe			ld (debug_mark+2),a  
4d53 18 03			jr .pastdmark  
4d55 ..			.dmark: db "DED"  
4d58 f1			.pastdmark: pop af  
4d59			endm  
# End of macro DMARK
4d59						CALLMONITOR 
4d59 cd fb 19			call break_point_state  
4d5c				endm  
# End of macro CALLMONITOR
4d5c					endif 
4d5c			 
4d5c					;FORTH_DSP 
4d5c					FORTH_DSP_VALUEHL 
4d5c cd ea 22			call macro_dsp_valuehl 
4d5f				endm 
# End of macro FORTH_DSP_VALUEHL
4d5f			;		inc hl    ; TODO do type check 
4d5f			 
4d5f			;		call get_word_hl 
4d5f e5					push hl 
4d60 e5					push hl 
4d61					FORTH_DSP_POP 
4d61 cd a2 23			call macro_forth_dsp_pop 
4d64				endm 
# End of macro FORTH_DSP_POP
4d64 e1					pop hl 
4d65					if DEBUG_FORTH_WORDS 
4d65						DMARK "EDp" 
4d65 f5				push af  
4d66 3a 7a 4d			ld a, (.dmark)  
4d69 32 6e fe			ld (debug_mark),a  
4d6c 3a 7b 4d			ld a, (.dmark+1)  
4d6f 32 6f fe			ld (debug_mark+1),a  
4d72 3a 7c 4d			ld a, (.dmark+2)  
4d75 32 70 fe			ld (debug_mark+2),a  
4d78 18 03			jr .pastdmark  
4d7a ..			.dmark: db "EDp"  
4d7d f1			.pastdmark: pop af  
4d7e			endm  
# End of macro DMARK
4d7e						CALLMONITOR 
4d7e cd fb 19			call break_point_state  
4d81				endm  
# End of macro CALLMONITOR
4d81					endif 
4d81				;	ld a, 0 
4d81 cd e4 13				call strlenz 
4d84 23					inc hl 
4d85			 
4d85 06 00				ld b, 0 
4d87 4d					ld c, l 
4d88			 
4d88 e1					pop hl 
4d89			 
4d89					;ld a, 0 
4d89					;ld (hl),a 
4d89 3a 61 fa				ld a,(f_cursor_ptr) 
4d8c 16 64				ld d, 100 
4d8e 0e 00				ld c, 0 
4d90 1e 28				ld e, 40 
4d92 cd b3 0f				call input_str 
4d95					; TODO perhaps do a type check and wrap in quotes if not a number 
4d95					NEXTW 
4d95 c3 a0 24			jp macro_next 
4d98				endm 
# End of macro NEXTW
4d98			 
4d98			 
4d98			.ENDKEY: 
4d98			; eof 
4d98			 
# End of file forth_words_key.asm
4d98			include "forth_words_const.asm" 
4d98			 
4d98			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4d98			 
4d98			 
4d98			.SPITIME: 
4d98				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4d98 77				db WORD_SYS_CORE+99             
4d99 ad 4d			dw .VA            
4d9b 08				db 7 + 1 
4d9c .. 00			db "SPITIME",0              
4da4				endm 
# End of macro CWHEAD
4da4			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4da4			; 
4da4			; | If using BANK devices then leave as is. 
4da4			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4da4			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4da4			 
4da4 21 67 fa				ld hl, spi_clktime  
4da7 cd f3 20				call forth_push_numhl 
4daa			 
4daa					NEXTW 
4daa c3 a0 24			jp macro_next 
4dad				endm 
# End of macro NEXTW
4dad			 
4dad			 
4dad			.VA: 
4dad				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4dad 77				db WORD_SYS_CORE+99             
4dae bd 4d			dw .SYMBOL            
4db0 03				db 2 + 1 
4db1 .. 00			db "VA",0              
4db4				endm 
# End of macro CWHEAD
4db4			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4db4 21 2b fa				ld hl, cli_var_array 
4db7 cd f3 20				call forth_push_numhl 
4dba			 
4dba					NEXTW 
4dba c3 a0 24			jp macro_next 
4dbd				endm 
# End of macro NEXTW
4dbd			 
4dbd			.SYMBOL: 
4dbd				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4dbd 77				db WORD_SYS_CORE+99             
4dbe f5 4e			dw .ENDCONST            
4dc0 07				db 6 + 1 
4dc1 .. 00			db "SYMBOL",0              
4dc8				endm 
# End of macro CWHEAD
4dc8			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4dc8			; | 
4dc8			; | The value is the number reference and the final address is pushed to stack 
4dc8			 
4dc8					if DEBUG_FORTH_WORDS_KEY 
4dc8						DMARK "SYM" 
4dc8 f5				push af  
4dc9 3a dd 4d			ld a, (.dmark)  
4dcc 32 6e fe			ld (debug_mark),a  
4dcf 3a de 4d			ld a, (.dmark+1)  
4dd2 32 6f fe			ld (debug_mark+1),a  
4dd5 3a df 4d			ld a, (.dmark+2)  
4dd8 32 70 fe			ld (debug_mark+2),a  
4ddb 18 03			jr .pastdmark  
4ddd ..			.dmark: db "SYM"  
4de0 f1			.pastdmark: pop af  
4de1			endm  
# End of macro DMARK
4de1						CALLMONITOR 
4de1 cd fb 19			call break_point_state  
4de4				endm  
# End of macro CALLMONITOR
4de4					endif 
4de4			 
4de4					FORTH_DSP_VALUEHL 
4de4 cd ea 22			call macro_dsp_valuehl 
4de7				endm 
# End of macro FORTH_DSP_VALUEHL
4de7			 
4de7 7d					ld a, l     
4de8			 
4de8			 
4de8					if DEBUG_FORTH_WORDS 
4de8						DMARK "SY1" 
4de8 f5				push af  
4de9 3a fd 4d			ld a, (.dmark)  
4dec 32 6e fe			ld (debug_mark),a  
4def 3a fe 4d			ld a, (.dmark+1)  
4df2 32 6f fe			ld (debug_mark+1),a  
4df5 3a ff 4d			ld a, (.dmark+2)  
4df8 32 70 fe			ld (debug_mark+2),a  
4dfb 18 03			jr .pastdmark  
4dfd ..			.dmark: db "SY1"  
4e00 f1			.pastdmark: pop af  
4e01			endm  
# End of macro DMARK
4e01						CALLMONITOR 
4e01 cd fb 19			call break_point_state  
4e04				endm  
# End of macro CALLMONITOR
4e04					endif 
4e04					 
4e04 f5					push af	 
4e05					FORTH_DSP_POP 
4e05 cd a2 23			call macro_forth_dsp_pop 
4e08				endm 
# End of macro FORTH_DSP_POP
4e08 f1					pop af 
4e09			 
4e09 cb 27				sla a  
4e0b				 
4e0b					 
4e0b					if DEBUG_FORTH_WORDS 
4e0b						DMARK "SY" 
4e0b f5				push af  
4e0c 3a 20 4e			ld a, (.dmark)  
4e0f 32 6e fe			ld (debug_mark),a  
4e12 3a 21 4e			ld a, (.dmark+1)  
4e15 32 6f fe			ld (debug_mark+1),a  
4e18 3a 22 4e			ld a, (.dmark+2)  
4e1b 32 70 fe			ld (debug_mark+2),a  
4e1e 18 02			jr .pastdmark  
4e20 ..			.dmark: db "SY"  
4e22 f1			.pastdmark: pop af  
4e23			endm  
# End of macro DMARK
4e23						CALLMONITOR 
4e23 cd fb 19			call break_point_state  
4e26				endm  
# End of macro CALLMONITOR
4e26					endif 
4e26			 
4e26 21 35 4e				ld hl, sym_table 
4e29 cd 86 0f				call addatohl 
4e2c cd 22 24				call loadwordinhl 
4e2f cd f3 20				call forth_push_numhl 
4e32			 
4e32			 
4e32				       NEXTW 
4e32 c3 a0 24			jp macro_next 
4e35				endm 
# End of macro NEXTW
4e35			 
4e35			sym_table: 
4e35			 
4e35			; 0 
4e35 3f fa		dw cli_autodisplay 
4e37 4d fa		dw cli_buffer 
4e39 f1 f9		dw cli_data_sp 
4e3b 2b f7		dw cli_data_stack 
4e3d 47 fa		dw cli_execword 
4e3f f3 f9		dw cli_loop_sp 
4e41 2d f9		dw cli_loop_stack 
4e43 40 fa		dw cli_mvdot 
4e45 45 fa		dw cli_nextword 
4e47 41 fa		dw cli_origptr 
4e49 4b fa		dw cli_origtoken 
4e4b			; 11 
4e4b 43 fa		dw cli_ptr 
4e4d f5 f9		dw cli_ret_sp 
4e4f af f9		dw cli_ret_stack 
4e51 49 fa		dw cli_token 
4e53 2b fa		dw cli_var_array 
4e55 c8 fb		dw cursor_col 
4e57 c6 fb		dw cursor_ptr 
4e59 c7 fb		dw cursor_row 
4e5b c4 fb		dw cursor_shape 
4e5d 6e fe		dw debug_mark 
4e5f			; 21 
4e5f b4 fd		dw display_fb0 
4e61 13 fd		dw display_fb1 
4e63 d1 fb		dw display_fb2 
4e65 72 fc		dw display_fb3 
4e67 cf fb		dw display_fb_active 
4e69 c3 f2		dw execscratch 
4e6b 61 fa		dw f_cursor_ptr 
4e6d 72 fe		dw hardware_word 
4e6f 65 fe		dw input_at_cursor 
4e71 67 fe		dw input_at_pos 
4e73			; 31 
4e73 63 fe		dw input_cur_flash 
4e75 62 fe		dw input_cur_onoff 
4e77 58 fe		dw input_cursor 
4e79 68 fe		dw input_display_size 
4e7b 5d fe		dw input_len 
4e7d 6c fe		dw input_ptr 
4e7f 69 fe		dw input_size 
4e81 6a fe		dw input_start 
4e83 b3 0f		dw input_str 
4e85 66 fe		dw input_under_cursor 
4e87			; 41 
4e87 57 fe		dw key_actual_pressed 
4e89 82 fe		dw key_fa 
4e8b 7e fe		dw key_face_held 
4e8d 81 fe		dw key_fb 
4e8f 80 fe		dw key_fc 
4e91 7f fe		dw key_fd 
4e93 88 fe		dw key_held 
4e95 87 fe		dw key_held_prev 
4e97 f2 77		dw key_init 
4e99 83 fe		dw key_repeat_ct 
4e9b			; 51 
4e9b 05 00		dw key_rows 
4e9d 55 fe		dw key_shift 
4e9f 56 fe		dw key_symbol 
4ea1 89 fe		dw keyscan_scancol 
4ea3 93 fe		dw keyscan_table 
4ea5 f2 fe		dw keyscan_table_row1 
4ea7 e7 fe		dw keyscan_table_row2 
4ea9 dc fe		dw keyscan_table_row3 
4eab d1 fe		dw keyscan_table_row4 
4ead c6 fe		dw keyscan_table_row5 
4eaf			; 61 
4eaf eb f4		dw os_cli_cmd 
4eb1 e7 f4		dw os_cur_ptr 
4eb3 e9 f4		dw os_current_i 
4eb5 c2 f3		dw os_input 
4eb7 ea f5		dw os_last_cmd 
4eb9 c1 f4		dw os_last_new_uword 
4ebb b5 f1		dw os_view_disable 
4ebd b1 f1		dw os_view_hl 
4ebf c9 f4		dw os_word_scratch 
4ec1 c3 00		dw portbctl 
4ec3			; 71 
4ec3 c1 00		dw portbdata 
4ec5 66 fa		dw spi_cartdev 
4ec7 65 fa		dw spi_cartdev2 
4ec9 67 fa		dw spi_clktime 
4ecb 63 fa		dw spi_device 
4ecd 62 fa		dw spi_device_id 
4ecf 64 fa		dw spi_portbyte 
4ed1 aa fb		dw stackstore 
4ed3			if STORAGE_SE 
4ed3 82 00		dw storage_actl 
4ed5 80 00		dw storage_adata 
4ed7			else 
4ed7			dw 0 
4ed7			dw 0 
4ed7			endif 
4ed7			; 81 
4ed7 0c 0b		dw storage_append 
4ed9			if STORAGE_SE 
4ed9 83 00		dw storage_bctl 
4edb			else 
4edb			dw 0 
4edb			endif 
4edb 96 fb		dw store_bank_active 
4edd 6a fa		dw store_filecache 
4edf 78 fa		dw store_longread 
4ee1 6e fa		dw store_openaddr 
4ee3 6d fa		dw store_openext 
4ee5 6c fa		dw store_openmaxext 
4ee7 7d fa		dw store_page 
4ee9 79 fa		dw store_readbuf 
4eeb			; 91 
4eeb 70 fa		dw store_readcont 
4eed 7b fa		dw store_readptr 
4eef 70 fa		dw store_tmpext 
4ef1 71 fa		dw store_tmpid 
4ef3 68 fa		dw store_tmppageid 
4ef5			 
4ef5			 
4ef5			.ENDCONST: 
4ef5			 
4ef5			; eof 
4ef5			 
4ef5			 
# End of file forth_words_const.asm
4ef5			 
4ef5			if STORAGE_SE 
4ef5			   	include "forth_words_storage.asm" 
4ef5			 
4ef5			; | ## Fixed Storage Words 
4ef5			 
4ef5			.RENAME: 
4ef5			  
4ef5				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
4ef5 3a				db WORD_SYS_CORE+38             
4ef6 eb 4f			dw .RECORD            
4ef8 07				db 6 + 1 
4ef9 .. 00			db "RENAME",0              
4f00				endm 
# End of macro CWHEAD
4f00			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
4f00			; | | Compatible with PicoSPINet  
4f00					if DEBUG_FORTH_WORDS_KEY 
4f00						DMARK "REN" 
4f00 f5				push af  
4f01 3a 15 4f			ld a, (.dmark)  
4f04 32 6e fe			ld (debug_mark),a  
4f07 3a 16 4f			ld a, (.dmark+1)  
4f0a 32 6f fe			ld (debug_mark+1),a  
4f0d 3a 17 4f			ld a, (.dmark+2)  
4f10 32 70 fe			ld (debug_mark+2),a  
4f13 18 03			jr .pastdmark  
4f15 ..			.dmark: db "REN"  
4f18 f1			.pastdmark: pop af  
4f19			endm  
# End of macro DMARK
4f19						CALLMONITOR 
4f19 cd fb 19			call break_point_state  
4f1c				endm  
# End of macro CALLMONITOR
4f1c					endif 
4f1c			 
4f1c			 
4f1c					; preserve some internal vars used by other file handing routines 
4f1c			 
4f1c 2a 6e fa				ld hl, (store_openaddr) 
4f1f e5					push hl 
4f20 3a 70 fa				ld a, (store_readcont) 
4f23 f5					push af 
4f24			 
4f24					FORTH_DSP_VALUEHL 
4f24 cd ea 22			call macro_dsp_valuehl 
4f27				endm 
# End of macro FORTH_DSP_VALUEHL
4f27			 
4f27					; move ext and id around for the file header 
4f27			 
4f27 65					ld h, l 
4f28 2e 00				ld l, 0 
4f2a			 
4f2a e5					push hl    ; id 
4f2b			 
4f2b					FORTH_DSP_POP 
4f2b cd a2 23			call macro_forth_dsp_pop 
4f2e				endm 
# End of macro FORTH_DSP_POP
4f2e			 
4f2e					; Locate the file header 
4f2e			 
4f2e e1					pop hl 
4f2f e5					push hl 
4f30 11 7d fa				ld de, store_page      ; get block zero of file 
4f33					if DEBUG_FORTH_WORDS 
4f33						DMARK "REr" 
4f33 f5				push af  
4f34 3a 48 4f			ld a, (.dmark)  
4f37 32 6e fe			ld (debug_mark),a  
4f3a 3a 49 4f			ld a, (.dmark+1)  
4f3d 32 6f fe			ld (debug_mark+1),a  
4f40 3a 4a 4f			ld a, (.dmark+2)  
4f43 32 70 fe			ld (debug_mark+2),a  
4f46 18 03			jr .pastdmark  
4f48 ..			.dmark: db "REr"  
4f4b f1			.pastdmark: pop af  
4f4c			endm  
# End of macro DMARK
4f4c						CALLMONITOR 
4f4c cd fb 19			call break_point_state  
4f4f				endm  
# End of macro CALLMONITOR
4f4f					endif 
4f4f cd 75 09				call storage_read 
4f52			 
4f52 cd af 0f			call ishlzero 
4f55 20 05			jr nz, .rnfound 
4f57			 
4f57				; file does not exist so indicate with 255 extents in use 
4f57			 
4f57 3e ff			ld a, 255 
4f59 e1				pop hl ; clear dup hl 
4f5a 18 7b			jr .skiprneof 
4f5c			 
4f5c			 
4f5c			.rnfound: 
4f5c					; file found so rename 
4f5c			 
4f5c					FORTH_DSP_VALUEHL 
4f5c cd ea 22			call macro_dsp_valuehl 
4f5f				endm 
# End of macro FORTH_DSP_VALUEHL
4f5f			 
4f5f e5				push hl 
4f60 3e 00			ld a, 0 
4f62 cd ef 13			call strlent 
4f65 23				inc hl   ; cover zero term 
4f66 06 00			ld b,0 
4f68 4d				ld c,l 
4f69 e1				pop hl 
4f6a 11 80 fa				ld de, store_page + 3 
4f6d ed b0				ldir 
4f6f			 
4f6f 11 7d fa				ld de, store_page 
4f72					if DEBUG_FORTH_WORDS 
4f72						DMARK "RER" 
4f72 f5				push af  
4f73 3a 87 4f			ld a, (.dmark)  
4f76 32 6e fe			ld (debug_mark),a  
4f79 3a 88 4f			ld a, (.dmark+1)  
4f7c 32 6f fe			ld (debug_mark+1),a  
4f7f 3a 89 4f			ld a, (.dmark+2)  
4f82 32 70 fe			ld (debug_mark+2),a  
4f85 18 03			jr .pastdmark  
4f87 ..			.dmark: db "RER"  
4f8a f1			.pastdmark: pop af  
4f8b			endm  
# End of macro DMARK
4f8b						CALLMONITOR 
4f8b cd fb 19			call break_point_state  
4f8e				endm  
# End of macro CALLMONITOR
4f8e					endif 
4f8e			 
4f8e e1					pop hl    ; get orig file id and mangle it for find id 
4f8f 55					ld d, l 
4f90 5c					ld e, h 
4f91			 
4f91 21 00 00				ld hl, 0 
4f94					if DEBUG_FORTH_WORDS 
4f94						DMARK "REf" 
4f94 f5				push af  
4f95 3a a9 4f			ld a, (.dmark)  
4f98 32 6e fe			ld (debug_mark),a  
4f9b 3a aa 4f			ld a, (.dmark+1)  
4f9e 32 6f fe			ld (debug_mark+1),a  
4fa1 3a ab 4f			ld a, (.dmark+2)  
4fa4 32 70 fe			ld (debug_mark+2),a  
4fa7 18 03			jr .pastdmark  
4fa9 ..			.dmark: db "REf"  
4fac f1			.pastdmark: pop af  
4fad			endm  
# End of macro DMARK
4fad						CALLMONITOR 
4fad cd fb 19			call break_point_state  
4fb0				endm  
# End of macro CALLMONITOR
4fb0					endif 
4fb0 cd 4f 07				call storage_findnextid 
4fb3 11 7d fa				ld de, store_page 
4fb6					if DEBUG_FORTH_WORDS 
4fb6						DMARK "REw" 
4fb6 f5				push af  
4fb7 3a cb 4f			ld a, (.dmark)  
4fba 32 6e fe			ld (debug_mark),a  
4fbd 3a cc 4f			ld a, (.dmark+1)  
4fc0 32 6f fe			ld (debug_mark+1),a  
4fc3 3a cd 4f			ld a, (.dmark+2)  
4fc6 32 70 fe			ld (debug_mark+2),a  
4fc9 18 03			jr .pastdmark  
4fcb ..			.dmark: db "REw"  
4fce f1			.pastdmark: pop af  
4fcf			endm  
# End of macro DMARK
4fcf						CALLMONITOR 
4fcf cd fb 19			call break_point_state  
4fd2				endm  
# End of macro CALLMONITOR
4fd2					endif 
4fd2 cd 81 04				call storage_write_block 
4fd5			 
4fd5 3e 00				ld a, 0 
4fd7			.skiprneof: 
4fd7					; drop file name 
4fd7					FORTH_DSP_POP 
4fd7 cd a2 23			call macro_forth_dsp_pop 
4fda				endm 
# End of macro FORTH_DSP_POP
4fda			 
4fda 6f					ld l, a 
4fdb 26 00				ld h, 0 
4fdd cd f3 20				call forth_push_numhl 
4fe0			 
4fe0			 
4fe0 f1					pop af 
4fe1 32 70 fa				ld (store_readcont),a 
4fe4 e1					pop hl 
4fe5 22 6e fa				ld (store_openaddr), hl 
4fe8						 
4fe8				NEXTW 
4fe8 c3 a0 24			jp macro_next 
4feb				endm 
# End of macro NEXTW
4feb			.RECORD: 
4feb			  
4feb				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
4feb 3a				db WORD_SYS_CORE+38             
4fec 8f 50			dw .BREAD            
4fee 07				db 6 + 1 
4fef .. 00			db "RECORD",0              
4ff6				endm 
# End of macro CWHEAD
4ff6			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
4ff6			; | | Compatible with PicoSPINet  
4ff6			 
4ff6					if DEBUG_FORTH_WORDS_KEY 
4ff6						DMARK "REC" 
4ff6 f5				push af  
4ff7 3a 0b 50			ld a, (.dmark)  
4ffa 32 6e fe			ld (debug_mark),a  
4ffd 3a 0c 50			ld a, (.dmark+1)  
5000 32 6f fe			ld (debug_mark+1),a  
5003 3a 0d 50			ld a, (.dmark+2)  
5006 32 70 fe			ld (debug_mark+2),a  
5009 18 03			jr .pastdmark  
500b ..			.dmark: db "REC"  
500e f1			.pastdmark: pop af  
500f			endm  
# End of macro DMARK
500f						CALLMONITOR 
500f cd fb 19			call break_point_state  
5012				endm  
# End of macro CALLMONITOR
5012					endif 
5012			 
5012					FORTH_DSP_VALUEHL 
5012 cd ea 22			call macro_dsp_valuehl 
5015				endm 
# End of macro FORTH_DSP_VALUEHL
5015			 
5015 e5					push hl    ; id 
5016			 
5016					FORTH_DSP_POP 
5016 cd a2 23			call macro_forth_dsp_pop 
5019				endm 
# End of macro FORTH_DSP_POP
5019			 
5019					FORTH_DSP_VALUEHL 
5019 cd ea 22			call macro_dsp_valuehl 
501c				endm 
# End of macro FORTH_DSP_VALUEHL
501c			 
501c					FORTH_DSP_POP 
501c cd a2 23			call macro_forth_dsp_pop 
501f				endm 
# End of macro FORTH_DSP_POP
501f			 
501f d1					pop de     ; get file id 
5020			 
5020					; e = file id 
5020					; l = file extent 
5020			 
5020			 
5020					; construct request to access file extent 
5020			 
5020			;		ld a, e 
5020 63					ld h, e 
5021					 
5021					 
5021					 
5021			 
5021					; e has id 
5021			 
5021 11 7d fa			ld de, store_page 
5024					if DEBUG_FORTH_WORDS 
5024						DMARK "REr" 
5024 f5				push af  
5025 3a 39 50			ld a, (.dmark)  
5028 32 6e fe			ld (debug_mark),a  
502b 3a 3a 50			ld a, (.dmark+1)  
502e 32 6f fe			ld (debug_mark+1),a  
5031 3a 3b 50			ld a, (.dmark+2)  
5034 32 70 fe			ld (debug_mark+2),a  
5037 18 03			jr .pastdmark  
5039 ..			.dmark: db "REr"  
503c f1			.pastdmark: pop af  
503d			endm  
# End of macro DMARK
503d						CALLMONITOR 
503d cd fb 19			call break_point_state  
5040				endm  
# End of macro CALLMONITOR
5040					endif 
5040 cd 75 09				call storage_read 
5043 cd af 0f			call ishlzero 
5046 28 22			jr z, .recnotfound 
5048			 
5048			 
5048					if DEBUG_FORTH_WORDS 
5048						DMARK "REe" 
5048 f5				push af  
5049 3a 5d 50			ld a, (.dmark)  
504c 32 6e fe			ld (debug_mark),a  
504f 3a 5e 50			ld a, (.dmark+1)  
5052 32 6f fe			ld (debug_mark+1),a  
5055 3a 5f 50			ld a, (.dmark+2)  
5058 32 70 fe			ld (debug_mark+2),a  
505b 18 03			jr .pastdmark  
505d ..			.dmark: db "REe"  
5060 f1			.pastdmark: pop af  
5061			endm  
# End of macro DMARK
5061						CALLMONITOR 
5061 cd fb 19			call break_point_state  
5064				endm  
# End of macro CALLMONITOR
5064					endif 
5064 cd 61 21			call forth_push_str 
5067			 
5067					NEXTW 
5067 c3 a0 24			jp macro_next 
506a				endm 
# End of macro NEXTW
506a			 
506a			.recnotfound: 
506a					if DEBUG_FORTH_WORDS 
506a						DMARK "REf" 
506a f5				push af  
506b 3a 7f 50			ld a, (.dmark)  
506e 32 6e fe			ld (debug_mark),a  
5071 3a 80 50			ld a, (.dmark+1)  
5074 32 6f fe			ld (debug_mark+1),a  
5077 3a 81 50			ld a, (.dmark+2)  
507a 32 70 fe			ld (debug_mark+2),a  
507d 18 03			jr .pastdmark  
507f ..			.dmark: db "REf"  
5082 f1			.pastdmark: pop af  
5083			endm  
# End of macro DMARK
5083						CALLMONITOR 
5083 cd fb 19			call break_point_state  
5086				endm  
# End of macro CALLMONITOR
5086					endif 
5086 21 ff 00			ld hl, 255 
5089 cd f3 20			call forth_push_numhl 
508c				NEXTW 
508c c3 a0 24			jp macro_next 
508f				endm 
# End of macro NEXTW
508f			 
508f			 
508f			.BREAD: 
508f			  
508f				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
508f 3a				db WORD_SYS_CORE+38             
5090 12 51			dw .BWRITE            
5092 06				db 5 + 1 
5093 .. 00			db "BREAD",0              
5099				endm 
# End of macro CWHEAD
5099			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
5099			; | | Compatible with PicoSPINet  
5099				 
5099					if DEBUG_FORTH_WORDS_KEY 
5099						DMARK "BRD" 
5099 f5				push af  
509a 3a ae 50			ld a, (.dmark)  
509d 32 6e fe			ld (debug_mark),a  
50a0 3a af 50			ld a, (.dmark+1)  
50a3 32 6f fe			ld (debug_mark+1),a  
50a6 3a b0 50			ld a, (.dmark+2)  
50a9 32 70 fe			ld (debug_mark+2),a  
50ac 18 03			jr .pastdmark  
50ae ..			.dmark: db "BRD"  
50b1 f1			.pastdmark: pop af  
50b2			endm  
# End of macro DMARK
50b2						CALLMONITOR 
50b2 cd fb 19			call break_point_state  
50b5				endm  
# End of macro CALLMONITOR
50b5					endif 
50b5			 
50b5				FORTH_DSP_VALUEHL 
50b5 cd ea 22			call macro_dsp_valuehl 
50b8				endm 
# End of macro FORTH_DSP_VALUEHL
50b8			 
50b8				FORTH_DSP_POP 
50b8 cd a2 23			call macro_forth_dsp_pop 
50bb				endm 
# End of macro FORTH_DSP_POP
50bb			 
50bb				; calc block address 
50bb			 
50bb eb				ex de, hl 
50bc 3e 40			ld a, STORE_BLOCK_PHY 
50be cd 09 0f			call Mult16 
50c1			 
50c1			 
50c1 11 7d fa			ld de, store_page 
50c4			 
50c4					if DEBUG_FORTH_WORDS 
50c4						DMARK "BR1" 
50c4 f5				push af  
50c5 3a d9 50			ld a, (.dmark)  
50c8 32 6e fe			ld (debug_mark),a  
50cb 3a da 50			ld a, (.dmark+1)  
50ce 32 6f fe			ld (debug_mark+1),a  
50d1 3a db 50			ld a, (.dmark+2)  
50d4 32 70 fe			ld (debug_mark+2),a  
50d7 18 03			jr .pastdmark  
50d9 ..			.dmark: db "BR1"  
50dc f1			.pastdmark: pop af  
50dd			endm  
# End of macro DMARK
50dd						CALLMONITOR 
50dd cd fb 19			call break_point_state  
50e0				endm  
# End of macro CALLMONITOR
50e0					endif 
50e0			 
50e0 cd 1c 04			call storage_read_block 
50e3			 
50e3 cd af 0f			call ishlzero 
50e6 20 05			jr nz, .brfound 
50e8			 
50e8 cd f3 20			call forth_push_numhl 
50eb 18 22			jr .brdone 
50ed			 
50ed			 
50ed			.brfound: 
50ed 21 7f fa		        ld hl, store_page+2 
50f0			 
50f0					if DEBUG_FORTH_WORDS 
50f0						DMARK "BR2" 
50f0 f5				push af  
50f1 3a 05 51			ld a, (.dmark)  
50f4 32 6e fe			ld (debug_mark),a  
50f7 3a 06 51			ld a, (.dmark+1)  
50fa 32 6f fe			ld (debug_mark+1),a  
50fd 3a 07 51			ld a, (.dmark+2)  
5100 32 70 fe			ld (debug_mark+2),a  
5103 18 03			jr .pastdmark  
5105 ..			.dmark: db "BR2"  
5108 f1			.pastdmark: pop af  
5109			endm  
# End of macro DMARK
5109						CALLMONITOR 
5109 cd fb 19			call break_point_state  
510c				endm  
# End of macro CALLMONITOR
510c					endif 
510c			 
510c cd 61 21			call forth_push_str 
510f			 
510f			 
510f			.brdone: 
510f			 
510f					NEXTW 
510f c3 a0 24			jp macro_next 
5112				endm 
# End of macro NEXTW
5112			.BWRITE: 
5112				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
5112 3a				db WORD_SYS_CORE+38             
5113 a7 51			dw .BUPD            
5115 07				db 6 + 1 
5116 .. 00			db "BWRITE",0              
511d				endm 
# End of macro CWHEAD
511d			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
511d			; | | Compatible with PicoSPINet  
511d			 
511d					if DEBUG_FORTH_WORDS_KEY 
511d						DMARK "BWR" 
511d f5				push af  
511e 3a 32 51			ld a, (.dmark)  
5121 32 6e fe			ld (debug_mark),a  
5124 3a 33 51			ld a, (.dmark+1)  
5127 32 6f fe			ld (debug_mark+1),a  
512a 3a 34 51			ld a, (.dmark+2)  
512d 32 70 fe			ld (debug_mark+2),a  
5130 18 03			jr .pastdmark  
5132 ..			.dmark: db "BWR"  
5135 f1			.pastdmark: pop af  
5136			endm  
# End of macro DMARK
5136						CALLMONITOR 
5136 cd fb 19			call break_point_state  
5139				endm  
# End of macro CALLMONITOR
5139					endif 
5139			 
5139				FORTH_DSP_VALUEHL 
5139 cd ea 22			call macro_dsp_valuehl 
513c				endm 
# End of macro FORTH_DSP_VALUEHL
513c			 
513c				; calc block address 
513c			 
513c eb				ex de, hl 
513d 3e 40			ld a, STORE_BLOCK_PHY 
513f cd 09 0f			call Mult16 
5142			 
5142 e5				push hl         ; address 
5143			 
5143				FORTH_DSP_POP 
5143 cd a2 23			call macro_forth_dsp_pop 
5146				endm 
# End of macro FORTH_DSP_POP
5146			 
5146				FORTH_DSP_VALUEHL 
5146 cd ea 22			call macro_dsp_valuehl 
5149				endm 
# End of macro FORTH_DSP_VALUEHL
5149			 
5149				FORTH_DSP_POP 
5149 cd a2 23			call macro_forth_dsp_pop 
514c				endm 
# End of macro FORTH_DSP_POP
514c			 
514c cd 58 0c			call storage_clear_page 
514f			 
514f				; copy string to store page 
514f			 
514f e5				push hl     ; save string address 
5150			 
5150 3e 00			ld a, 0 
5152 cd ef 13			call strlent 
5155			 
5155 23				inc hl 
5156			 
5156 4d				ld c, l 
5157 06 00			ld b, 0 
5159			 
5159 e1				pop hl 
515a 11 7f fa			ld de, store_page + 2 
515d					if DEBUG_FORTH_WORDS 
515d						DMARK "BW1" 
515d f5				push af  
515e 3a 72 51			ld a, (.dmark)  
5161 32 6e fe			ld (debug_mark),a  
5164 3a 73 51			ld a, (.dmark+1)  
5167 32 6f fe			ld (debug_mark+1),a  
516a 3a 74 51			ld a, (.dmark+2)  
516d 32 70 fe			ld (debug_mark+2),a  
5170 18 03			jr .pastdmark  
5172 ..			.dmark: db "BW1"  
5175 f1			.pastdmark: pop af  
5176			endm  
# End of macro DMARK
5176						CALLMONITOR 
5176 cd fb 19			call break_point_state  
5179				endm  
# End of macro CALLMONITOR
5179					endif 
5179 ed b0			ldir 
517b			 
517b			 
517b				; poke the start of the block with flags to prevent high level file ops hitting the block 
517b			 
517b 21 ff ff			ld hl, $ffff 
517e			 
517e 22 7d fa			ld (store_page), hl	 
5181				 
5181 e1				pop hl    ; get address 
5182 11 7d fa			ld de, store_page 
5185			 
5185					if DEBUG_FORTH_WORDS 
5185						DMARK "BW2" 
5185 f5				push af  
5186 3a 9a 51			ld a, (.dmark)  
5189 32 6e fe			ld (debug_mark),a  
518c 3a 9b 51			ld a, (.dmark+1)  
518f 32 6f fe			ld (debug_mark+1),a  
5192 3a 9c 51			ld a, (.dmark+2)  
5195 32 70 fe			ld (debug_mark+2),a  
5198 18 03			jr .pastdmark  
519a ..			.dmark: db "BW2"  
519d f1			.pastdmark: pop af  
519e			endm  
# End of macro DMARK
519e						CALLMONITOR 
519e cd fb 19			call break_point_state  
51a1				endm  
# End of macro CALLMONITOR
51a1					endif 
51a1			 
51a1 cd 81 04			call storage_write_block 
51a4			 
51a4					NEXTW 
51a4 c3 a0 24			jp macro_next 
51a7				endm 
# End of macro NEXTW
51a7			 
51a7			.BUPD: 
51a7				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
51a7 3a				db WORD_SYS_CORE+38             
51a8 fd 51			dw .BYID            
51aa 05				db 4 + 1 
51ab .. 00			db "BUPD",0              
51b0				endm 
# End of macro CWHEAD
51b0			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
51b0			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
51b0			; | | or completely different file system structure. 
51b0			; | | Compatible with PicoSPINet  
51b0			 
51b0					if DEBUG_FORTH_WORDS_KEY 
51b0						DMARK "BUD" 
51b0 f5				push af  
51b1 3a c5 51			ld a, (.dmark)  
51b4 32 6e fe			ld (debug_mark),a  
51b7 3a c6 51			ld a, (.dmark+1)  
51ba 32 6f fe			ld (debug_mark+1),a  
51bd 3a c7 51			ld a, (.dmark+2)  
51c0 32 70 fe			ld (debug_mark+2),a  
51c3 18 03			jr .pastdmark  
51c5 ..			.dmark: db "BUD"  
51c8 f1			.pastdmark: pop af  
51c9			endm  
# End of macro DMARK
51c9						CALLMONITOR 
51c9 cd fb 19			call break_point_state  
51cc				endm  
# End of macro CALLMONITOR
51cc					endif 
51cc			 
51cc				FORTH_DSP_VALUEHL 
51cc cd ea 22			call macro_dsp_valuehl 
51cf				endm 
# End of macro FORTH_DSP_VALUEHL
51cf			 
51cf				; calc block address 
51cf			 
51cf eb				ex de, hl 
51d0 3e 40			ld a, STORE_BLOCK_PHY 
51d2 cd 09 0f			call Mult16 
51d5			 
51d5				FORTH_DSP_POP 
51d5 cd a2 23			call macro_forth_dsp_pop 
51d8				endm 
# End of macro FORTH_DSP_POP
51d8			 
51d8			 
51d8 11 7d fa			ld de, store_page 
51db			 
51db					if DEBUG_FORTH_WORDS 
51db						DMARK "BUe" 
51db f5				push af  
51dc 3a f0 51			ld a, (.dmark)  
51df 32 6e fe			ld (debug_mark),a  
51e2 3a f1 51			ld a, (.dmark+1)  
51e5 32 6f fe			ld (debug_mark+1),a  
51e8 3a f2 51			ld a, (.dmark+2)  
51eb 32 70 fe			ld (debug_mark+2),a  
51ee 18 03			jr .pastdmark  
51f0 ..			.dmark: db "BUe"  
51f3 f1			.pastdmark: pop af  
51f4			endm  
# End of macro DMARK
51f4						CALLMONITOR 
51f4 cd fb 19			call break_point_state  
51f7				endm  
# End of macro CALLMONITOR
51f7					endif 
51f7			 
51f7 cd 81 04			call storage_write_block 
51fa			 
51fa					NEXTW 
51fa c3 a0 24			jp macro_next 
51fd				endm 
# End of macro NEXTW
51fd			 
51fd			.BYID: 
51fd			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
51fd			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
51fd			; 
51fd			;		 
51fd			;		if DEBUG_FORTH_WORDS_KEY 
51fd			;			DMARK "BYID" 
51fd			;			CALLMONITOR 
51fd			;		endif 
51fd			; 
51fd			;		; get direct address 
51fd			; 
51fd			;		FORTH_DSP_VALUEHL 
51fd			; 
51fd			;		FORTH_DSP_POP 
51fd			; 
51fd			;	; calc block address 
51fd			; 
51fd			;	ex de, hl 
51fd			;	ld a, STORE_BLOCK_PHY 
51fd			;	call Mult16 
51fd			;	;	do BREAD with number as param 
51fd			;	; push the file name	 
51fd			;	ld de, store_page 
51fd			;	call storage_read_block 
51fd			 ;       ld hl, store_page+2 
51fd			; 
51fd			; 
51fd			;		NEXTW 
51fd			;.BYNAME: 
51fd				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
51fd 3a				db WORD_SYS_CORE+38             
51fe 16 52			dw .DIR            
5200 06				db 5 + 1 
5201 .. 00			db "GETID",0              
5207				endm 
# End of macro CWHEAD
5207			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
5207			; | | Compatible with PicoSPINet  
5207			 
5207					; get pointer to file name to seek 
5207			 
5207					FORTH_DSP_VALUEHL 
5207 cd ea 22			call macro_dsp_valuehl 
520a				endm 
# End of macro FORTH_DSP_VALUEHL
520a			 
520a			 
520a cd 43 03				call storage_getid  
520d			 
520d					FORTH_DSP_POP 
520d cd a2 23			call macro_forth_dsp_pop 
5210				endm 
# End of macro FORTH_DSP_POP
5210			 
5210 cd f3 20				call forth_push_numhl 
5213			 
5213					NEXTW 
5213 c3 a0 24			jp macro_next 
5216				endm 
# End of macro NEXTW
5216			; 
5216			.DIR: 
5216				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
5216 3a				db WORD_SYS_CORE+38             
5217 1a 53			dw .SAVE            
5219 04				db 3 + 1 
521a .. 00			db "DIR",0              
521e				endm 
# End of macro CWHEAD
521e			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
521e			; | | Compatible with PicoSPINet  
521e			 
521e					if DEBUG_FORTH_WORDS_KEY 
521e						DMARK "DIR" 
521e f5				push af  
521f 3a 33 52			ld a, (.dmark)  
5222 32 6e fe			ld (debug_mark),a  
5225 3a 34 52			ld a, (.dmark+1)  
5228 32 6f fe			ld (debug_mark+1),a  
522b 3a 35 52			ld a, (.dmark+2)  
522e 32 70 fe			ld (debug_mark+2),a  
5231 18 03			jr .pastdmark  
5233 ..			.dmark: db "DIR"  
5236 f1			.pastdmark: pop af  
5237			endm  
# End of macro DMARK
5237						CALLMONITOR 
5237 cd fb 19			call break_point_state  
523a				endm  
# End of macro CALLMONITOR
523a					endif 
523a cd cd 04			call storage_get_block_0 
523d			 
523d 21 7d fa			ld hl, store_page     ; get current id count 
5240 46				ld b, (hl) 
5241 0e 00			ld c, 0    ; count of files   
5243					if DEBUG_FORTH_WORDS 
5243						DMARK "DI1" 
5243 f5				push af  
5244 3a 58 52			ld a, (.dmark)  
5247 32 6e fe			ld (debug_mark),a  
524a 3a 59 52			ld a, (.dmark+1)  
524d 32 6f fe			ld (debug_mark+1),a  
5250 3a 5a 52			ld a, (.dmark+2)  
5253 32 70 fe			ld (debug_mark+2),a  
5256 18 03			jr .pastdmark  
5258 ..			.dmark: db "DI1"  
525b f1			.pastdmark: pop af  
525c			endm  
# End of macro DMARK
525c						CALLMONITOR 
525c cd fb 19			call break_point_state  
525f				endm  
# End of macro CALLMONITOR
525f					endif 
525f			 
525f				; check for empty drive 
525f			 
525f 3e 00			ld a, 0 
5261 b8				cp b 
5262 ca d0 52			jp z, .dirdone 
5265			 
5265				; for each of the current ids do a search for them and if found push to stack 
5265			 
5265 c5			.diritem:	push bc 
5266 21 40 00				ld hl, STORE_BLOCK_PHY 
5269 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
526b 58					ld e,b 
526c			 
526c			;		if DEBUG_FORTH_WORDS 
526c			;			DMARK "DI2" 
526c			;			CALLMONITOR 
526c			;		endif 
526c			 
526c cd 4f 07				call storage_findnextid 
526f			 
526f			;		if DEBUG_FORTH_WORDS 
526f			;			DMARK "DI3" 
526f			;			CALLMONITOR 
526f			;		endif 
526f			 
526f					; if found hl will be non zero 
526f			 
526f cd af 0f				call ishlzero 
5272			;		ld a, l 
5272			;		add h 
5272			; 
5272			;		cp 0 
5272 28 59				jr z, .dirnotfound 
5274			 
5274					; increase count 
5274			 
5274 c1					pop bc	 
5275 0c					inc c 
5276 c5					push bc 
5277					 
5277			 
5277					; get file header and push the file name 
5277			 
5277 11 7d fa				ld de, store_page 
527a cd 1c 04				call storage_read_block 
527d			 
527d					; push file id to stack 
527d				 
527d 3a 7d fa				ld a, (store_page) 
5280 26 00				ld h, 0 
5282 6f					ld l, a 
5283 cd f3 20				call forth_push_numhl 
5286			 
5286					; push extent count to stack  
5286				 
5286 3a 7f fa				ld a, (store_page+2) 
5289 26 00				ld h, 0 
528b 6f					ld l, a 
528c cd f3 20				call forth_push_numhl 
528f			 
528f					; push file name 
528f			 
528f 21 80 fa				ld hl, store_page+3 
5292					if DEBUG_FORTH_WORDS 
5292						DMARK "DI5" 
5292 f5				push af  
5293 3a a7 52			ld a, (.dmark)  
5296 32 6e fe			ld (debug_mark),a  
5299 3a a8 52			ld a, (.dmark+1)  
529c 32 6f fe			ld (debug_mark+1),a  
529f 3a a9 52			ld a, (.dmark+2)  
52a2 32 70 fe			ld (debug_mark+2),a  
52a5 18 03			jr .pastdmark  
52a7 ..			.dmark: db "DI5"  
52aa f1			.pastdmark: pop af  
52ab			endm  
# End of macro DMARK
52ab						CALLMONITOR 
52ab cd fb 19			call break_point_state  
52ae				endm  
# End of macro CALLMONITOR
52ae					endif 
52ae cd 61 21				call forth_push_str 
52b1					if DEBUG_FORTH_WORDS 
52b1						DMARK "DI6" 
52b1 f5				push af  
52b2 3a c6 52			ld a, (.dmark)  
52b5 32 6e fe			ld (debug_mark),a  
52b8 3a c7 52			ld a, (.dmark+1)  
52bb 32 6f fe			ld (debug_mark+1),a  
52be 3a c8 52			ld a, (.dmark+2)  
52c1 32 70 fe			ld (debug_mark+2),a  
52c4 18 03			jr .pastdmark  
52c6 ..			.dmark: db "DI6"  
52c9 f1			.pastdmark: pop af  
52ca			endm  
# End of macro DMARK
52ca						CALLMONITOR 
52ca cd fb 19			call break_point_state  
52cd				endm  
# End of macro CALLMONITOR
52cd					endif 
52cd			.dirnotfound: 
52cd c1					pop bc     
52ce 10 95				djnz .diritem 
52d0				 
52d0			.dirdone:	 
52d0					if DEBUG_FORTH_WORDS 
52d0						DMARK "DI7" 
52d0 f5				push af  
52d1 3a e5 52			ld a, (.dmark)  
52d4 32 6e fe			ld (debug_mark),a  
52d7 3a e6 52			ld a, (.dmark+1)  
52da 32 6f fe			ld (debug_mark+1),a  
52dd 3a e7 52			ld a, (.dmark+2)  
52e0 32 70 fe			ld (debug_mark+2),a  
52e3 18 03			jr .pastdmark  
52e5 ..			.dmark: db "DI7"  
52e8 f1			.pastdmark: pop af  
52e9			endm  
# End of macro DMARK
52e9						CALLMONITOR 
52e9 cd fb 19			call break_point_state  
52ec				endm  
# End of macro CALLMONITOR
52ec					endif 
52ec			 
52ec					; push a count of the dir items found 
52ec			 
52ec 26 00				ld h, 0 
52ee 69					ld l, c 
52ef cd f3 20				call forth_push_numhl 
52f2			 
52f2					; push the bank label 
52f2			 
52f2 cd cd 04				call storage_get_block_0 
52f5			 
52f5				 
52f5 21 80 fa		 		ld hl, store_page+3 
52f8			 
52f8					if DEBUG_FORTH_WORDS 
52f8						DMARK "DI8" 
52f8 f5				push af  
52f9 3a 0d 53			ld a, (.dmark)  
52fc 32 6e fe			ld (debug_mark),a  
52ff 3a 0e 53			ld a, (.dmark+1)  
5302 32 6f fe			ld (debug_mark+1),a  
5305 3a 0f 53			ld a, (.dmark+2)  
5308 32 70 fe			ld (debug_mark+2),a  
530b 18 03			jr .pastdmark  
530d ..			.dmark: db "DI8"  
5310 f1			.pastdmark: pop af  
5311			endm  
# End of macro DMARK
5311						CALLMONITOR 
5311 cd fb 19			call break_point_state  
5314				endm  
# End of macro CALLMONITOR
5314					endif 
5314 cd 61 21				call forth_push_str 
5317			 
5317			 
5317				 
5317					NEXTW 
5317 c3 a0 24			jp macro_next 
531a				endm 
# End of macro NEXTW
531a			.SAVE: 
531a			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
531a			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
531a			;		NEXTW 
531a			;.LOAD: 
531a			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
531a			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
531a			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
531a			;; > > The LOAD command can not be used in any user words or compound lines. 
531a			; 
531a			;		; store_openext use it. If zero it is EOF 
531a			; 
531a			;		; read block from current stream id 
531a			;		; if the block does not contain zero term keep reading blocks until zero found 
531a			;		; push the block to stack 
531a			;		; save the block id to stream 
531a			; 
531a			; 
531a			;		FORTH_DSP_VALUEHL 
531a			; 
531a			;;		push hl 
531a			; 
531a			;	if DEBUG_STORESE 
531a			;		DMARK "LOA" 
531a			;		CALLMONITOR 
531a			;	endif 
531a			;		FORTH_DSP_POP 
531a			; 
531a			;;		pop hl 
531a			; 
531a			;		ld h, l 
531a			;		ld l, 0 
531a			; 
531a			;		push hl     ; stack holds current file id and extent to work with 
531a			; 
531a			; 
531a			;		ld de, store_page      ; get block zero of file 
531a			;	if DEBUG_STORESE 
531a			;		DMARK "LO0" 
531a			;		CALLMONITOR 
531a			;	endif 
531a			;		call storage_read 
531a			; 
531a			;		ld a, (store_page+2)    ; max extents for this file 
531a			;		ld  (store_openmaxext),a   ; get our limit 
531a			; 
531a			;	if DEBUG_STORESE 
531a			;		DMARK "LOE" 
531a			;		CALLMONITOR 
531a			;	endif 
531a			; 
531a			;; TODO dont know why max extents are not present 
531a			;;		cp 0 
531a			;;		jp z, .loadeof     ; dont read past eof 
531a			; 
531a			;;		ld a, 1   ; start from the head of the file 
531a			; 
531a			;.loadline:	pop hl 
531a			;		inc hl 
531a			;		ld  a, (store_openmaxext)   ; get our limit 
531a			;	if DEBUG_STORESE 
531a			;		DMARK "LOx" 
531a			;		CALLMONITOR 
531a			;	endif 
531a			;		inc a 
531a			;		cp l 
531a			;		jp z, .loadeof 
531a			;		push hl    ; save current extent 
531a			; 
531a			;		ld de, store_page 
531a			; 
531a			;	if DEBUG_STORESE 
531a			;		DMARK "LO1" 
531a			;		CALLMONITOR 
531a			;	endif 
531a			;		call storage_read 
531a			; 
531a			;	if DEBUG_STORESE 
531a			;		DMARK "LO2" 
531a			;		CALLMONITOR 
531a			;	endif 
531a			;	call ishlzero 
531a			;	ld a, l 
531a			;	add h 
531a			;	cp 0 
531a			;	jr z, .loadeof 
531a			; 
531a			;	; not eof so hl should point to data to exec 
531a			; 
531a			;	; will need to add the FORTH_END_BUFFER flag 
531a			 ; 
531a			;	ld hl, store_page+2 
531a			;	ld bc, 255 
531a			;	ld a, 0 
531a			;	cpir 
531a			;	if DEBUG_STORESE 
531a			;		DMARK "LOt" 
531a			;		CALLMONITOR 
531a			;	endif 
531a			;	dec hl 
531a			;	ld a, ' ' 
531a			;	ld (hl), a 
531a			;	inc hl 
531a			;	ld (hl), a 
531a			;	inc hl 
531a			;	ld (hl), a 
531a			;	inc hl 
531a			;	ld a, FORTH_END_BUFFER 
531a			;	ld (hl), a 
531a			; 
531a			;	; TODO handle more than a single block read 
531a			; 
531a			; 
531a			;	ld hl, store_page+2 
531a			; 
531a			;	ld (os_tok_ptr), hl 
531a			; 
531a			;	if DEBUG_STORESE 
531a			;		DMARK "LO3" 
531a			;		CALLMONITOR 
531a			;	endif 
531a			; 
531a			;	call forthparse 
531a			;	call forthexec 
531a			;	call forthexec_cleanup 
531a			; 
531a			;	; go to next extent 
531a			; 
531a			;	; get next block  or mark as eof 
531a			;	jp .loadline 
531a			; 
531a			; 
531a			; 
531a			;	       NEXTW 
531a			;.loadeof:	ld a, 0 
531a			;		ld (store_openext), a 
531a			; 
531a			;	if DEBUG_STORESE 
531a			;		DMARK "LOF" 
531a			;		CALLMONITOR 
531a			;	endif 
531a			;		ret 
531a			;		;NEXTW 
531a			;.BSAVE:   
531a			; 
531a			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
531a			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
531a			;		NEXTW 
531a			;.BLOAD: 
531a			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
531a			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
531a			;		NEXTW 
531a			;;;; counter gap 
531a			 
531a			 
531a			.SEO: 
531a				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
531a 64				db WORD_SYS_CORE+80             
531b 39 53			dw .SEI            
531d 04				db 3 + 1 
531e .. 00			db "SEO",0              
5322				endm 
# End of macro CWHEAD
5322			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
5322			 
5322					; get port 
5322			 
5322					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5322 cd ea 22			call macro_dsp_valuehl 
5325				endm 
# End of macro FORTH_DSP_VALUEHL
5325			 
5325 e5					push hl    ; u2 - byte 
5326			 
5326					; destroy value TOS 
5326			 
5326					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5326 cd a2 23			call macro_forth_dsp_pop 
5329				endm 
# End of macro FORTH_DSP_POP
5329			 
5329					; get byte to send 
5329			 
5329					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5329 cd ea 22			call macro_dsp_valuehl 
532c				endm 
# End of macro FORTH_DSP_VALUEHL
532c			 
532c e5					push hl    ; u1 - addr 
532d			 
532d					; destroy value TOS 
532d			 
532d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
532d cd a2 23			call macro_forth_dsp_pop 
5330				endm 
# End of macro FORTH_DSP_POP
5330			 
5330					; one value on hl get other one back 
5330			 
5330 d1					pop de   ; u1 - byte 
5331			 
5331 e1					pop hl   ; u2 - addr 
5332			 
5332					; TODO Send SPI byte 
5332			 
5332			 
5332 7b					ld a, e 
5333 cd 21 02				call se_writebyte 
5336			 
5336					 
5336			 
5336					NEXTW 
5336 c3 a0 24			jp macro_next 
5339				endm 
# End of macro NEXTW
5339			 
5339			.SEI: 
5339				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
5339 65				db WORD_SYS_CORE+81             
533a 53 53			dw .SFREE            
533c 04				db 3 + 1 
533d .. 00			db "SEI",0              
5341				endm 
# End of macro CWHEAD
5341			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
5341			 
5341					; get port 
5341			 
5341					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5341 cd ea 22			call macro_dsp_valuehl 
5344				endm 
# End of macro FORTH_DSP_VALUEHL
5344			 
5344			;		push hl 
5344			 
5344					; destroy value TOS 
5344			 
5344					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5344 cd a2 23			call macro_forth_dsp_pop 
5347				endm 
# End of macro FORTH_DSP_POP
5347			 
5347					; one value on hl get other one back 
5347			 
5347			;		pop hl 
5347			 
5347			 
5347					; TODO Get SPI byte 
5347			 
5347 cd c3 02				call se_readbyte 
534a			 
534a 26 00				ld h, 0 
534c 6f					ld l, a 
534d cd f3 20				call forth_push_numhl 
5350			 
5350					NEXTW 
5350 c3 a0 24			jp macro_next 
5353				endm 
# End of macro NEXTW
5353			 
5353			.SFREE: 
5353				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
5353 67				db WORD_SYS_CORE+83             
5354 82 53			dw .SIZE            
5356 06				db 5 + 1 
5357 .. 00			db "FFREE",0              
535d				endm 
# End of macro CWHEAD
535d			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
535d			; | | Compatible with PicoSPINet  
535d					if DEBUG_FORTH_WORDS_KEY 
535d						DMARK "FFR" 
535d f5				push af  
535e 3a 72 53			ld a, (.dmark)  
5361 32 6e fe			ld (debug_mark),a  
5364 3a 73 53			ld a, (.dmark+1)  
5367 32 6f fe			ld (debug_mark+1),a  
536a 3a 74 53			ld a, (.dmark+2)  
536d 32 70 fe			ld (debug_mark+2),a  
5370 18 03			jr .pastdmark  
5372 ..			.dmark: db "FFR"  
5375 f1			.pastdmark: pop af  
5376			endm  
# End of macro DMARK
5376						CALLMONITOR 
5376 cd fb 19			call break_point_state  
5379				endm  
# End of macro CALLMONITOR
5379					endif 
5379			 
5379 cd e9 07				call storage_freeblocks 
537c			 
537c cd f3 20				call forth_push_numhl 
537f			 
537f				       NEXTW 
537f c3 a0 24			jp macro_next 
5382				endm 
# End of macro NEXTW
5382			.SIZE: 
5382				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
5382 67				db WORD_SYS_CORE+83             
5383 b6 53			dw .CREATE            
5385 05				db 4 + 1 
5386 .. 00			db "SIZE",0              
538b				endm 
# End of macro CWHEAD
538b			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
538b			; | | Compatible with PicoSPINet  
538b					if DEBUG_FORTH_WORDS_KEY 
538b						DMARK "SIZ" 
538b f5				push af  
538c 3a a0 53			ld a, (.dmark)  
538f 32 6e fe			ld (debug_mark),a  
5392 3a a1 53			ld a, (.dmark+1)  
5395 32 6f fe			ld (debug_mark+1),a  
5398 3a a2 53			ld a, (.dmark+2)  
539b 32 70 fe			ld (debug_mark+2),a  
539e 18 03			jr .pastdmark  
53a0 ..			.dmark: db "SIZ"  
53a3 f1			.pastdmark: pop af  
53a4			endm  
# End of macro DMARK
53a4						CALLMONITOR 
53a4 cd fb 19			call break_point_state  
53a7				endm  
# End of macro CALLMONITOR
53a7					endif 
53a7			 
53a7					FORTH_DSP_VALUEHL 
53a7 cd ea 22			call macro_dsp_valuehl 
53aa				endm 
# End of macro FORTH_DSP_VALUEHL
53aa			;		push hl 
53aa					FORTH_DSP_POP 
53aa cd a2 23			call macro_forth_dsp_pop 
53ad				endm 
# End of macro FORTH_DSP_POP
53ad			;		pop hl 
53ad cd 4b 04				call storage_file_size 
53b0			 
53b0 cd f3 20				call forth_push_numhl 
53b3			  
53b3			 
53b3				       NEXTW 
53b3 c3 a0 24			jp macro_next 
53b6				endm 
# End of macro NEXTW
53b6			 
53b6			.CREATE: 
53b6				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
53b6 68				db WORD_SYS_CORE+84             
53b7 24 54			dw .APPEND            
53b9 07				db 6 + 1 
53ba .. 00			db "CREATE",0              
53c1				endm 
# End of macro CWHEAD
53c1			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
53c1			; | | e.g.  
53c1			; | | TestProgram CREATE 
53c1			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
53c1			; | |  
53c1			; | | Max file IDs are 255. 
53c1			; | |  
53c1			; | | Compatible with PicoSPINet  
53c1					 
53c1					if DEBUG_FORTH_WORDS_KEY 
53c1						DMARK "CRT" 
53c1 f5				push af  
53c2 3a d6 53			ld a, (.dmark)  
53c5 32 6e fe			ld (debug_mark),a  
53c8 3a d7 53			ld a, (.dmark+1)  
53cb 32 6f fe			ld (debug_mark+1),a  
53ce 3a d8 53			ld a, (.dmark+2)  
53d1 32 70 fe			ld (debug_mark+2),a  
53d4 18 03			jr .pastdmark  
53d6 ..			.dmark: db "CRT"  
53d9 f1			.pastdmark: pop af  
53da			endm  
# End of macro DMARK
53da						CALLMONITOR 
53da cd fb 19			call break_point_state  
53dd				endm  
# End of macro CALLMONITOR
53dd					endif 
53dd			;		call storage_get_block_0 
53dd			 
53dd					; TODO pop hl 
53dd			 
53dd					;v5 FORTH_DSP_VALUE 
53dd					FORTH_DSP_VALUE 
53dd cd d3 22			call macro_forth_dsp_value 
53e0				endm 
# End of macro FORTH_DSP_VALUE
53e0			 
53e0				if DEBUG_STORESE 
53e0					DMARK "CR1" 
53e0 f5				push af  
53e1 3a f5 53			ld a, (.dmark)  
53e4 32 6e fe			ld (debug_mark),a  
53e7 3a f6 53			ld a, (.dmark+1)  
53ea 32 6f fe			ld (debug_mark+1),a  
53ed 3a f7 53			ld a, (.dmark+2)  
53f0 32 70 fe			ld (debug_mark+2),a  
53f3 18 03			jr .pastdmark  
53f5 ..			.dmark: db "CR1"  
53f8 f1			.pastdmark: pop af  
53f9			endm  
# End of macro DMARK
53f9					CALLMONITOR 
53f9 cd fb 19			call break_point_state  
53fc				endm  
# End of macro CALLMONITOR
53fc				endif 
53fc			;		push hl 
53fc			;		FORTH_DSP_POP 
53fc			;		pop hl 
53fc			 
53fc			;		inc hl   ; move past the type marker 
53fc			 
53fc cd 1f 08				call storage_create 
53ff			 
53ff				if DEBUG_STORESE 
53ff					DMARK "CT1" 
53ff f5				push af  
5400 3a 14 54			ld a, (.dmark)  
5403 32 6e fe			ld (debug_mark),a  
5406 3a 15 54			ld a, (.dmark+1)  
5409 32 6f fe			ld (debug_mark+1),a  
540c 3a 16 54			ld a, (.dmark+2)  
540f 32 70 fe			ld (debug_mark+2),a  
5412 18 03			jr .pastdmark  
5414 ..			.dmark: db "CT1"  
5417 f1			.pastdmark: pop af  
5418			endm  
# End of macro DMARK
5418					CALLMONITOR 
5418 cd fb 19			call break_point_state  
541b				endm  
# End of macro CALLMONITOR
541b				endif 
541b			;		push hl 
541b					FORTH_DSP_POP 
541b cd a2 23			call macro_forth_dsp_pop 
541e				endm 
# End of macro FORTH_DSP_POP
541e			;		pop hl 
541e					; push file id to stack 
541e cd f3 20				call forth_push_numhl 
5421			 
5421			 
5421			 
5421				       NEXTW 
5421 c3 a0 24			jp macro_next 
5424				endm 
# End of macro NEXTW
5424			 
5424			.APPEND: 
5424				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
5424 69				db WORD_SYS_CORE+85             
5425 b5 54			dw .SDEL            
5427 07				db 6 + 1 
5428 .. 00			db "APPEND",0              
542f				endm 
# End of macro CWHEAD
542f			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
542f			; | | e.g. 
542f			; | | Test CREATE      -> $01 
542f			; | | "A string to add to file" $01 APPEND 
542f			; | |  
542f			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
542f			; | | Compatible with PicoSPINet  
542f					if DEBUG_FORTH_WORDS_KEY 
542f						DMARK "APP" 
542f f5				push af  
5430 3a 44 54			ld a, (.dmark)  
5433 32 6e fe			ld (debug_mark),a  
5436 3a 45 54			ld a, (.dmark+1)  
5439 32 6f fe			ld (debug_mark+1),a  
543c 3a 46 54			ld a, (.dmark+2)  
543f 32 70 fe			ld (debug_mark+2),a  
5442 18 03			jr .pastdmark  
5444 ..			.dmark: db "APP"  
5447 f1			.pastdmark: pop af  
5448			endm  
# End of macro DMARK
5448						CALLMONITOR 
5448 cd fb 19			call break_point_state  
544b				endm  
# End of macro CALLMONITOR
544b					endif 
544b			 
544b					FORTH_DSP_VALUEHL 
544b cd ea 22			call macro_dsp_valuehl 
544e				endm 
# End of macro FORTH_DSP_VALUEHL
544e e5					push hl 	; save file id 
544f			 
544f				if DEBUG_STORESE 
544f					DMARK "AP1" 
544f f5				push af  
5450 3a 64 54			ld a, (.dmark)  
5453 32 6e fe			ld (debug_mark),a  
5456 3a 65 54			ld a, (.dmark+1)  
5459 32 6f fe			ld (debug_mark+1),a  
545c 3a 66 54			ld a, (.dmark+2)  
545f 32 70 fe			ld (debug_mark+2),a  
5462 18 03			jr .pastdmark  
5464 ..			.dmark: db "AP1"  
5467 f1			.pastdmark: pop af  
5468			endm  
# End of macro DMARK
5468					CALLMONITOR 
5468 cd fb 19			call break_point_state  
546b				endm  
# End of macro CALLMONITOR
546b				endif 
546b					FORTH_DSP_POP 
546b cd a2 23			call macro_forth_dsp_pop 
546e				endm 
# End of macro FORTH_DSP_POP
546e			 
546e					FORTH_DSP_VALUEHL 
546e cd ea 22			call macro_dsp_valuehl 
5471				endm 
# End of macro FORTH_DSP_VALUEHL
5471					;v5 FORTH_DSP_VALUE 
5471 e5					push hl 	; save ptr to string to save 
5472			 
5472				if DEBUG_STORESE 
5472					DMARK "AP1" 
5472 f5				push af  
5473 3a 87 54			ld a, (.dmark)  
5476 32 6e fe			ld (debug_mark),a  
5479 3a 88 54			ld a, (.dmark+1)  
547c 32 6f fe			ld (debug_mark+1),a  
547f 3a 89 54			ld a, (.dmark+2)  
5482 32 70 fe			ld (debug_mark+2),a  
5485 18 03			jr .pastdmark  
5487 ..			.dmark: db "AP1"  
548a f1			.pastdmark: pop af  
548b			endm  
# End of macro DMARK
548b					CALLMONITOR 
548b cd fb 19			call break_point_state  
548e				endm  
# End of macro CALLMONITOR
548e				endif 
548e					FORTH_DSP_POP 
548e cd a2 23			call macro_forth_dsp_pop 
5491				endm 
# End of macro FORTH_DSP_POP
5491			 
5491 d1					pop de 
5492 e1					pop hl 
5493				if DEBUG_STORESE 
5493					DMARK "AP2" 
5493 f5				push af  
5494 3a a8 54			ld a, (.dmark)  
5497 32 6e fe			ld (debug_mark),a  
549a 3a a9 54			ld a, (.dmark+1)  
549d 32 6f fe			ld (debug_mark+1),a  
54a0 3a aa 54			ld a, (.dmark+2)  
54a3 32 70 fe			ld (debug_mark+2),a  
54a6 18 03			jr .pastdmark  
54a8 ..			.dmark: db "AP2"  
54ab f1			.pastdmark: pop af  
54ac			endm  
# End of macro DMARK
54ac					CALLMONITOR 
54ac cd fb 19			call break_point_state  
54af				endm  
# End of macro CALLMONITOR
54af				endif 
54af					;inc de ; skip var type indicator 
54af			 
54af					; TODO how to append numerics???? 
54af			 
54af cd 0c 0b				call storage_append		 
54b2			 
54b2				       NEXTW 
54b2 c3 a0 24			jp macro_next 
54b5				endm 
# End of macro NEXTW
54b5			.SDEL: 
54b5				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
54b5 6a				db WORD_SYS_CORE+86             
54b6 01 55			dw .OPEN            
54b8 05				db 4 + 1 
54b9 .. 00			db "ERA",0              
54bd				endm 
# End of macro CWHEAD
54bd			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
54bd			; | | Compatible with PicoSPINet  
54bd					FORTH_DSP_VALUEHL 
54bd cd ea 22			call macro_dsp_valuehl 
54c0				endm 
# End of macro FORTH_DSP_VALUEHL
54c0			;		push hl 	; save file id 
54c0			 
54c0					if DEBUG_FORTH_WORDS_KEY 
54c0						DMARK "ERA" 
54c0 f5				push af  
54c1 3a d5 54			ld a, (.dmark)  
54c4 32 6e fe			ld (debug_mark),a  
54c7 3a d6 54			ld a, (.dmark+1)  
54ca 32 6f fe			ld (debug_mark+1),a  
54cd 3a d7 54			ld a, (.dmark+2)  
54d0 32 70 fe			ld (debug_mark+2),a  
54d3 18 03			jr .pastdmark  
54d5 ..			.dmark: db "ERA"  
54d8 f1			.pastdmark: pop af  
54d9			endm  
# End of macro DMARK
54d9						CALLMONITOR 
54d9 cd fb 19			call break_point_state  
54dc				endm  
# End of macro CALLMONITOR
54dc					endif 
54dc				if DEBUG_STORESE 
54dc					DMARK "ER1" 
54dc f5				push af  
54dd 3a f1 54			ld a, (.dmark)  
54e0 32 6e fe			ld (debug_mark),a  
54e3 3a f2 54			ld a, (.dmark+1)  
54e6 32 6f fe			ld (debug_mark+1),a  
54e9 3a f3 54			ld a, (.dmark+2)  
54ec 32 70 fe			ld (debug_mark+2),a  
54ef 18 03			jr .pastdmark  
54f1 ..			.dmark: db "ER1"  
54f4 f1			.pastdmark: pop af  
54f5			endm  
# End of macro DMARK
54f5					CALLMONITOR 
54f5 cd fb 19			call break_point_state  
54f8				endm  
# End of macro CALLMONITOR
54f8				endif 
54f8					FORTH_DSP_POP 
54f8 cd a2 23			call macro_forth_dsp_pop 
54fb				endm 
# End of macro FORTH_DSP_POP
54fb			 
54fb			;		pop hl 
54fb			 
54fb cd 5e 06				call storage_erase 
54fe				       NEXTW 
54fe c3 a0 24			jp macro_next 
5501				endm 
# End of macro NEXTW
5501			 
5501			.OPEN: 
5501				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
5501 6b				db WORD_SYS_CORE+87             
5502 95 55			dw .READ            
5504 05				db 4 + 1 
5505 .. 00			db "OPEN",0              
550a				endm 
# End of macro CWHEAD
550a			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
550a			; | | e.g. 
550a			; | | $01 OPEN $01 DO $01 READ . LOOP 
550a			; | | 
550a			; | | Will return with 255 blocks if the file does not exist 
550a			; | | Compatible with PicoSPINet  
550a			 
550a					if DEBUG_FORTH_WORDS_KEY 
550a						DMARK "OPN" 
550a f5				push af  
550b 3a 1f 55			ld a, (.dmark)  
550e 32 6e fe			ld (debug_mark),a  
5511 3a 20 55			ld a, (.dmark+1)  
5514 32 6f fe			ld (debug_mark+1),a  
5517 3a 21 55			ld a, (.dmark+2)  
551a 32 70 fe			ld (debug_mark+2),a  
551d 18 03			jr .pastdmark  
551f ..			.dmark: db "OPN"  
5522 f1			.pastdmark: pop af  
5523			endm  
# End of macro DMARK
5523						CALLMONITOR 
5523 cd fb 19			call break_point_state  
5526				endm  
# End of macro CALLMONITOR
5526					endif 
5526					; TODO handle multiple file opens 
5526			 
5526 3e 01			       	ld a, 1 
5528 32 6d fa				ld (store_openext), a 
552b			 
552b					; get max extents for this file 
552b				 
552b								 
552b					FORTH_DSP_VALUEHL 
552b cd ea 22			call macro_dsp_valuehl 
552e				endm 
# End of macro FORTH_DSP_VALUEHL
552e			 
552e 65					ld h, l 
552f 2e 00				ld l, 0 
5531			 
5531					; store file id 
5531			 
5531 7c					ld a, h 
5532 32 6a fa				ld (store_filecache), a 
5535			 
5535				if DEBUG_STORESE 
5535					DMARK "OPN" 
5535 f5				push af  
5536 3a 4a 55			ld a, (.dmark)  
5539 32 6e fe			ld (debug_mark),a  
553c 3a 4b 55			ld a, (.dmark+1)  
553f 32 6f fe			ld (debug_mark+1),a  
5542 3a 4c 55			ld a, (.dmark+2)  
5545 32 70 fe			ld (debug_mark+2),a  
5548 18 03			jr .pastdmark  
554a ..			.dmark: db "OPN"  
554d f1			.pastdmark: pop af  
554e			endm  
# End of macro DMARK
554e					CALLMONITOR 
554e cd fb 19			call break_point_state  
5551				endm  
# End of macro CALLMONITOR
5551				endif 
5551			;		push hl 
5551					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5551 cd a2 23			call macro_forth_dsp_pop 
5554				endm 
# End of macro FORTH_DSP_POP
5554			;		pop hl 
5554						 
5554 11 7d fa				ld de, store_page      ; get block zero of file 
5557 cd 75 09				call storage_read 
555a cd af 0f			call ishlzero 
555d 20 04			jr nz, .opfound 
555f			 
555f				; file does not exist so indicate with 255 extents in use 
555f			 
555f 3e ff			ld a, 255 
5561 18 29			jr .skipopeneof 
5563			 
5563			 
5563			.opfound: 
5563			 
5563			 
5563 3a 7f fa				ld a, (store_page+2)    ; max extents for this file 
5566 32 6c fa				ld  (store_openmaxext), a   ; get our limit and push 
5569					 
5569				if DEBUG_STORESE 
5569					DMARK "OPx" 
5569 f5				push af  
556a 3a 7e 55			ld a, (.dmark)  
556d 32 6e fe			ld (debug_mark),a  
5570 3a 7f 55			ld a, (.dmark+1)  
5573 32 6f fe			ld (debug_mark+1),a  
5576 3a 80 55			ld a, (.dmark+2)  
5579 32 70 fe			ld (debug_mark+2),a  
557c 18 03			jr .pastdmark  
557e ..			.dmark: db "OPx"  
5581 f1			.pastdmark: pop af  
5582			endm  
# End of macro DMARK
5582					CALLMONITOR 
5582 cd fb 19			call break_point_state  
5585				endm  
# End of macro CALLMONITOR
5585				endif 
5585 fe 00				cp 0 
5587 20 03				jr nz, .skipopeneof 
5589					; have opened an empty file 
5589					 
5589 32 6d fa				ld (store_openext), a 
558c			 
558c			.skipopeneof: 
558c			 
558c 6f					ld l, a 
558d 26 00				ld h, 0 
558f cd f3 20				call forth_push_numhl 
5592			 
5592			 
5592				       NEXTW 
5592 c3 a0 24			jp macro_next 
5595				endm 
# End of macro NEXTW
5595			.READ: 
5595				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
5595 6c				db WORD_SYS_CORE+88             
5596 bf 56			dw .EOF            
5598 05				db 4 + 1 
5599 .. 00			db "READ",0              
559e				endm 
# End of macro CWHEAD
559e			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
559e			; | | e.g. 
559e			; | | $01 OPEN $01 DO READ . LOOP 
559e			; | | 
559e			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
559e			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
559e			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
559e			; | | two bytes contain the file id and extent. 
559e			; | |  
559e			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
559e			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
559e			; | | Compatible with PicoSPINet  
559e			 
559e					if DEBUG_FORTH_WORDS_KEY 
559e						DMARK "REA" 
559e f5				push af  
559f 3a b3 55			ld a, (.dmark)  
55a2 32 6e fe			ld (debug_mark),a  
55a5 3a b4 55			ld a, (.dmark+1)  
55a8 32 6f fe			ld (debug_mark+1),a  
55ab 3a b5 55			ld a, (.dmark+2)  
55ae 32 70 fe			ld (debug_mark+2),a  
55b1 18 03			jr .pastdmark  
55b3 ..			.dmark: db "REA"  
55b6 f1			.pastdmark: pop af  
55b7			endm  
# End of macro DMARK
55b7						CALLMONITOR 
55b7 cd fb 19			call break_point_state  
55ba				endm  
# End of macro CALLMONITOR
55ba					endif 
55ba					; store_openext use it. If zero it is EOF 
55ba			 
55ba					; read block from current stream id 
55ba					; if the block does not contain zero term keep reading blocks until zero found 
55ba					; push the block to stack 
55ba					; save the block id to stream 
55ba			 
55ba			 
55ba cd ec 56				call .testeof 
55bd 3e 01				ld a, 1 
55bf bd					cp l 
55c0 ca 9b 56				jp z, .ateof 
55c3			 
55c3			 
55c3			;		FORTH_DSP_VALUEHL 
55c3			 
55c3			;		push hl 
55c3			 
55c3			;	if DEBUG_STORESE 
55c3			;		DMARK "REA" 
55c3			;		CALLMONITOR 
55c3			;	endif 
55c3			;		FORTH_DSP_POP 
55c3			 
55c3			;		pop hl 
55c3				 
55c3 3a 6a fa				ld a, (store_filecache) 
55c6 67					ld h,a 
55c7			 
55c7 3a 6d fa				ld a, (store_openext) 
55ca 6f					ld l, a 
55cb					 
55cb fe 00				cp 0 
55cd ca 9b 56				jp z, .ateof     ; dont read past eof 
55d0			 
55d0 cd 58 0c				call storage_clear_page 
55d3			 
55d3 11 7d fa				ld de, store_page 
55d6				if DEBUG_STORESE 
55d6					DMARK "RE1" 
55d6 f5				push af  
55d7 3a eb 55			ld a, (.dmark)  
55da 32 6e fe			ld (debug_mark),a  
55dd 3a ec 55			ld a, (.dmark+1)  
55e0 32 6f fe			ld (debug_mark+1),a  
55e3 3a ed 55			ld a, (.dmark+2)  
55e6 32 70 fe			ld (debug_mark+2),a  
55e9 18 03			jr .pastdmark  
55eb ..			.dmark: db "RE1"  
55ee f1			.pastdmark: pop af  
55ef			endm  
# End of macro DMARK
55ef					CALLMONITOR 
55ef cd fb 19			call break_point_state  
55f2				endm  
# End of macro CALLMONITOR
55f2				endif 
55f2 cd 75 09				call storage_read 
55f5			 
55f5				if DEBUG_STORESE 
55f5					DMARK "RE2" 
55f5 f5				push af  
55f6 3a 0a 56			ld a, (.dmark)  
55f9 32 6e fe			ld (debug_mark),a  
55fc 3a 0b 56			ld a, (.dmark+1)  
55ff 32 6f fe			ld (debug_mark+1),a  
5602 3a 0c 56			ld a, (.dmark+2)  
5605 32 70 fe			ld (debug_mark+2),a  
5608 18 03			jr .pastdmark  
560a ..			.dmark: db "RE2"  
560d f1			.pastdmark: pop af  
560e			endm  
# End of macro DMARK
560e					CALLMONITOR 
560e cd fb 19			call break_point_state  
5611				endm  
# End of macro CALLMONITOR
5611				endif 
5611 cd af 0f			call ishlzero 
5614			;	ld a, l 
5614			;	add h 
5614			;	cp 0 
5614 ca 9b 56			jp z, .readeof 
5617			 
5617				; not eof so hl should point to data to push to stack 
5617			 
5617				if DEBUG_STORESE 
5617					DMARK "RE3" 
5617 f5				push af  
5618 3a 2c 56			ld a, (.dmark)  
561b 32 6e fe			ld (debug_mark),a  
561e 3a 2d 56			ld a, (.dmark+1)  
5621 32 6f fe			ld (debug_mark+1),a  
5624 3a 2e 56			ld a, (.dmark+2)  
5627 32 70 fe			ld (debug_mark+2),a  
562a 18 03			jr .pastdmark  
562c ..			.dmark: db "RE3"  
562f f1			.pastdmark: pop af  
5630			endm  
# End of macro DMARK
5630					CALLMONITOR 
5630 cd fb 19			call break_point_state  
5633				endm  
# End of macro CALLMONITOR
5633				endif 
5633 cd 61 21			call forth_push_str 
5636			 
5636				if DEBUG_STORESE 
5636					DMARK "RE4" 
5636 f5				push af  
5637 3a 4b 56			ld a, (.dmark)  
563a 32 6e fe			ld (debug_mark),a  
563d 3a 4c 56			ld a, (.dmark+1)  
5640 32 6f fe			ld (debug_mark+1),a  
5643 3a 4d 56			ld a, (.dmark+2)  
5646 32 70 fe			ld (debug_mark+2),a  
5649 18 03			jr .pastdmark  
564b ..			.dmark: db "RE4"  
564e f1			.pastdmark: pop af  
564f			endm  
# End of macro DMARK
564f					CALLMONITOR 
564f cd fb 19			call break_point_state  
5652				endm  
# End of macro CALLMONITOR
5652				endif 
5652				; get next block  or mark as eof 
5652			 
5652 3a 6c fa			ld a, (store_openmaxext)   ; get our limit 
5655 4f				ld c, a	 
5656 3a 6d fa			ld a, (store_openext) 
5659			 
5659				if DEBUG_STORESE 
5659					DMARK "RE5" 
5659 f5				push af  
565a 3a 6e 56			ld a, (.dmark)  
565d 32 6e fe			ld (debug_mark),a  
5660 3a 6f 56			ld a, (.dmark+1)  
5663 32 6f fe			ld (debug_mark+1),a  
5666 3a 70 56			ld a, (.dmark+2)  
5669 32 70 fe			ld (debug_mark+2),a  
566c 18 03			jr .pastdmark  
566e ..			.dmark: db "RE5"  
5671 f1			.pastdmark: pop af  
5672			endm  
# End of macro DMARK
5672					CALLMONITOR 
5672 cd fb 19			call break_point_state  
5675				endm  
# End of macro CALLMONITOR
5675				endif 
5675 b9				cp c 
5676 28 23			jr z, .readeof     ; at last extent 
5678			 
5678 3c					inc a 
5679 32 6d fa				ld (store_openext), a 
567c			 
567c				if DEBUG_STORESE 
567c					DMARK "RE6" 
567c f5				push af  
567d 3a 91 56			ld a, (.dmark)  
5680 32 6e fe			ld (debug_mark),a  
5683 3a 92 56			ld a, (.dmark+1)  
5686 32 6f fe			ld (debug_mark+1),a  
5689 3a 93 56			ld a, (.dmark+2)  
568c 32 70 fe			ld (debug_mark+2),a  
568f 18 03			jr .pastdmark  
5691 ..			.dmark: db "RE6"  
5694 f1			.pastdmark: pop af  
5695			endm  
# End of macro DMARK
5695					CALLMONITOR 
5695 cd fb 19			call break_point_state  
5698				endm  
# End of macro CALLMONITOR
5698				endif 
5698			 
5698			 
5698				       NEXTW 
5698 c3 a0 24			jp macro_next 
569b				endm 
# End of macro NEXTW
569b			.ateof: 
569b				;	ld hl, .showeof 
569b				;	call forth_push_str 
569b 3e 00		.readeof:	ld a, 0 
569d 32 6d fa				ld (store_openext), a 
56a0			 
56a0					 
56a0				if DEBUG_STORESE 
56a0					DMARK "REF" 
56a0 f5				push af  
56a1 3a b5 56			ld a, (.dmark)  
56a4 32 6e fe			ld (debug_mark),a  
56a7 3a b6 56			ld a, (.dmark+1)  
56aa 32 6f fe			ld (debug_mark+1),a  
56ad 3a b7 56			ld a, (.dmark+2)  
56b0 32 70 fe			ld (debug_mark+2),a  
56b3 18 03			jr .pastdmark  
56b5 ..			.dmark: db "REF"  
56b8 f1			.pastdmark: pop af  
56b9			endm  
# End of macro DMARK
56b9					CALLMONITOR 
56b9 cd fb 19			call break_point_state  
56bc				endm  
# End of macro CALLMONITOR
56bc				endif 
56bc				       NEXTW 
56bc c3 a0 24			jp macro_next 
56bf				endm 
# End of macro NEXTW
56bf			 
56bf			;.showeof:   db "eof", 0 
56bf			 
56bf			 
56bf			.EOF: 
56bf				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
56bf 6d				db WORD_SYS_CORE+89             
56c0 01 57			dw .FORMAT            
56c2 04				db 3 + 1 
56c3 .. 00			db "EOF",0              
56c7				endm 
# End of macro CWHEAD
56c7			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
56c7			; | | e.g. 
56c7			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
56c7			; | | Compatible with PicoSPINet  
56c7					; TODO if current block id for stream is zero then push true else false 
56c7			 
56c7					if DEBUG_FORTH_WORDS_KEY 
56c7						DMARK "EOF" 
56c7 f5				push af  
56c8 3a dc 56			ld a, (.dmark)  
56cb 32 6e fe			ld (debug_mark),a  
56ce 3a dd 56			ld a, (.dmark+1)  
56d1 32 6f fe			ld (debug_mark+1),a  
56d4 3a de 56			ld a, (.dmark+2)  
56d7 32 70 fe			ld (debug_mark+2),a  
56da 18 03			jr .pastdmark  
56dc ..			.dmark: db "EOF"  
56df f1			.pastdmark: pop af  
56e0			endm  
# End of macro DMARK
56e0						CALLMONITOR 
56e0 cd fb 19			call break_point_state  
56e3				endm  
# End of macro CALLMONITOR
56e3					endif 
56e3			 
56e3					; TODO handlue multiple file streams 
56e3			 
56e3			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
56e3 cd ec 56				call .testeof 
56e6 cd f3 20				call forth_push_numhl 
56e9			 
56e9			 
56e9				       NEXTW 
56e9 c3 a0 24			jp macro_next 
56ec				endm 
# End of macro NEXTW
56ec			 
56ec			.testeof: 
56ec 2e 01				ld l, 1 
56ee 3a 6c fa				ld a, (store_openmaxext) 
56f1 fe 00				cp 0 
56f3 28 09				jr  z, .eofdone   ; empty file 
56f5 3a 6d fa				ld a, (store_openext) 
56f8 fe 00				cp 0 
56fa 28 02				jr  z, .eofdone 
56fc 2e 00				ld l, 0 
56fe 26 00		.eofdone:	ld h, 0 
5700 c9					ret 
5701			 
5701			 
5701			 
5701			 
5701			.FORMAT: 
5701				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
5701 6d				db WORD_SYS_CORE+89             
5702 52 57			dw .LABEL            
5704 07				db 6 + 1 
5705 .. 00			db "FORMAT",0              
570c				endm 
# End of macro CWHEAD
570c			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
570c			; | | Compatible with PicoSPINet  
570c					; TODO if current block id for stream is zero then push true else false 
570c				 
570c				if DEBUG_STORESE 
570c					DMARK "FOR" 
570c f5				push af  
570d 3a 21 57			ld a, (.dmark)  
5710 32 6e fe			ld (debug_mark),a  
5713 3a 22 57			ld a, (.dmark+1)  
5716 32 6f fe			ld (debug_mark+1),a  
5719 3a 23 57			ld a, (.dmark+2)  
571c 32 70 fe			ld (debug_mark+2),a  
571f 18 03			jr .pastdmark  
5721 ..			.dmark: db "FOR"  
5724 f1			.pastdmark: pop af  
5725			endm  
# End of macro DMARK
5725					CALLMONITOR 
5725 cd fb 19			call break_point_state  
5728				endm  
# End of macro CALLMONITOR
5728				endif 
5728					; Wipes the bank check flags to cause a reformat on next block 0 read 
5728			 
5728 21 01 00				ld hl, 1 
572b 3e 00				ld a, 0 
572d cd 21 02				call se_writebyte 
5730			 
5730				if DEBUG_STORESE 
5730					DMARK "FO0" 
5730 f5				push af  
5731 3a 45 57			ld a, (.dmark)  
5734 32 6e fe			ld (debug_mark),a  
5737 3a 46 57			ld a, (.dmark+1)  
573a 32 6f fe			ld (debug_mark+1),a  
573d 3a 47 57			ld a, (.dmark+2)  
5740 32 70 fe			ld (debug_mark+2),a  
5743 18 03			jr .pastdmark  
5745 ..			.dmark: db "FO0"  
5748 f1			.pastdmark: pop af  
5749			endm  
# End of macro DMARK
5749					CALLMONITOR 
5749 cd fb 19			call break_point_state  
574c				endm  
# End of macro CALLMONITOR
574c				endif 
574c					; force bank init 
574c			 
574c cd cd 04				call storage_get_block_0 
574f					 
574f				       NEXTW 
574f c3 a0 24			jp macro_next 
5752				endm 
# End of macro NEXTW
5752			.LABEL: 
5752				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5752 6d				db WORD_SYS_CORE+89             
5753 a0 57			dw .STOREPAGE            
5755 06				db 5 + 1 
5756 .. 00			db "LABEL",0              
575c				endm 
# End of macro CWHEAD
575c			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
575c			; | | Compatible with PicoSPINet  
575c					; TODO test to see if bank is selected 
575c				 
575c					if DEBUG_FORTH_WORDS_KEY 
575c						DMARK "LBL" 
575c f5				push af  
575d 3a 71 57			ld a, (.dmark)  
5760 32 6e fe			ld (debug_mark),a  
5763 3a 72 57			ld a, (.dmark+1)  
5766 32 6f fe			ld (debug_mark+1),a  
5769 3a 73 57			ld a, (.dmark+2)  
576c 32 70 fe			ld (debug_mark+2),a  
576f 18 03			jr .pastdmark  
5771 ..			.dmark: db "LBL"  
5774 f1			.pastdmark: pop af  
5775			endm  
# End of macro DMARK
5775						CALLMONITOR 
5775 cd fb 19			call break_point_state  
5778				endm  
# End of macro CALLMONITOR
5778					endif 
5778			;	if DEBUG_STORESE 
5778			;		DMARK "LBL" 
5778			;		CALLMONITOR 
5778			;	endif 
5778					FORTH_DSP_VALUEHL 
5778 cd ea 22			call macro_dsp_valuehl 
577b				endm 
# End of macro FORTH_DSP_VALUEHL
577b					;v5FORTH_DSP_VALUE 
577b					 
577b			;		push hl 
577b					FORTH_DSP_POP 
577b cd a2 23			call macro_forth_dsp_pop 
577e				endm 
# End of macro FORTH_DSP_POP
577e			;		pop hl 
577e			 
577e			;v5		inc hl   ; move past the type marker 
577e			 
577e				if DEBUG_STORESE 
577e					DMARK "LBl" 
577e f5				push af  
577f 3a 93 57			ld a, (.dmark)  
5782 32 6e fe			ld (debug_mark),a  
5785 3a 94 57			ld a, (.dmark+1)  
5788 32 6f fe			ld (debug_mark+1),a  
578b 3a 95 57			ld a, (.dmark+2)  
578e 32 70 fe			ld (debug_mark+2),a  
5791 18 03			jr .pastdmark  
5793 ..			.dmark: db "LBl"  
5796 f1			.pastdmark: pop af  
5797			endm  
# End of macro DMARK
5797					CALLMONITOR 
5797 cd fb 19			call break_point_state  
579a				endm  
# End of macro CALLMONITOR
579a				endif 
579a cd f1 05				call storage_label 
579d			 
579d				       NEXTW 
579d c3 a0 24			jp macro_next 
57a0				endm 
# End of macro NEXTW
57a0			.STOREPAGE: 
57a0				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
57a0 6d				db WORD_SYS_CORE+89             
57a1 d3 57			dw .LABELS            
57a3 0a				db 9 + 1 
57a4 .. 00			db "STOREPAGE",0              
57ae				endm 
# End of macro CWHEAD
57ae			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
57ae			; | | Compatible with PicoSPINet  
57ae					; TODO test to see if bank is selected 
57ae				 
57ae					if DEBUG_FORTH_WORDS_KEY 
57ae						DMARK "STP" 
57ae f5				push af  
57af 3a c3 57			ld a, (.dmark)  
57b2 32 6e fe			ld (debug_mark),a  
57b5 3a c4 57			ld a, (.dmark+1)  
57b8 32 6f fe			ld (debug_mark+1),a  
57bb 3a c5 57			ld a, (.dmark+2)  
57be 32 70 fe			ld (debug_mark+2),a  
57c1 18 03			jr .pastdmark  
57c3 ..			.dmark: db "STP"  
57c6 f1			.pastdmark: pop af  
57c7			endm  
# End of macro DMARK
57c7						CALLMONITOR 
57c7 cd fb 19			call break_point_state  
57ca				endm  
# End of macro CALLMONITOR
57ca					endif 
57ca			;	if DEBUG_STORESE 
57ca			;		DMARK "STP" 
57ca			;		CALLMONITOR 
57ca			;	endif 
57ca			 
57ca 21 7d fa			ld hl, store_page 
57cd cd f3 20			call forth_push_numhl 
57d0			 
57d0			 
57d0				       NEXTW 
57d0 c3 a0 24			jp macro_next 
57d3				endm 
# End of macro NEXTW
57d3			.LABELS: 
57d3				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
57d3 6d				db WORD_SYS_CORE+89             
57d4 5d 58			dw .SCONST1            
57d6 07				db 6 + 1 
57d7 .. 00			db "LABELS",0              
57de				endm 
# End of macro CWHEAD
57de			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
57de			; | | *NOT* Compatible with PicoSPINet  
57de					;  
57de			 
57de					; save the current device selected to restore afterwards 
57de				 
57de 3a 63 fa				ld a, (spi_device) 
57e1 f5					push af 
57e2			 
57e2			 
57e2					; run through each of the banks 
57e2			 
57e2 21 01 00				ld hl, 1 
57e5 cd f3 20				call forth_push_numhl 
57e8 3e ff				ld a, SPI_CE_HIGH 
57ea cb 87				res SPI_CE0, a 
57ec 32 63 fa				ld (spi_device), a 
57ef cd cd 04				call storage_get_block_0 
57f2 21 80 fa				ld hl, store_page+3 
57f5 cd 61 21				call forth_push_str 
57f8			 
57f8					 
57f8 21 02 00				ld hl, 2 
57fb cd f3 20				call forth_push_numhl 
57fe 3e ff				ld a, SPI_CE_HIGH 
5800 cb 8f				res SPI_CE1, a 
5802 32 63 fa				ld (spi_device), a 
5805 cd cd 04				call storage_get_block_0 
5808 21 80 fa				ld hl, store_page+3 
580b cd 61 21				call forth_push_str 
580e			 
580e					 
580e 21 03 00				ld hl, 3 
5811 cd f3 20				call forth_push_numhl 
5814 3e ff				ld a, SPI_CE_HIGH 
5816 cb 97				res SPI_CE2, a 
5818 32 63 fa				ld (spi_device), a 
581b cd cd 04				call storage_get_block_0 
581e 21 80 fa				ld hl, store_page+3 
5821 cd 61 21				call forth_push_str 
5824			 
5824			 
5824 21 04 00				ld hl, 4 
5827 cd f3 20				call forth_push_numhl 
582a 3e ff				ld a, SPI_CE_HIGH 
582c cb 9f				res SPI_CE3, a 
582e 32 63 fa				ld (spi_device), a 
5831 cd cd 04				call storage_get_block_0 
5834 21 80 fa				ld hl, store_page+3 
5837 cd 61 21				call forth_push_str 
583a			 
583a					 
583a			 
583a 21 05 00				ld hl, 5 
583d cd f3 20				call forth_push_numhl 
5840 3e ff				ld a, SPI_CE_HIGH 
5842 cb a7				res SPI_CE4, a 
5844 32 63 fa				ld (spi_device), a 
5847 cd cd 04				call storage_get_block_0 
584a 21 80 fa				ld hl, store_page+3 
584d cd 61 21				call forth_push_str 
5850			 
5850					 
5850					; push fixed count of storage devices (on board) for now 
5850			 
5850 21 05 00				ld hl, 5 
5853 cd f3 20				call forth_push_numhl 
5856			 
5856					; restore selected device  
5856				 
5856 f1					pop af 
5857 32 63 fa				ld (spi_device), a 
585a			 
585a				       NEXTW 
585a c3 a0 24			jp macro_next 
585d				endm 
# End of macro NEXTW
585d			 
585d			.SCONST1: 
585d				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
585d 6d				db WORD_SYS_CORE+89             
585e 74 58			dw .SCONST2            
5860 07				db 6 + 1 
5861 .. 00			db "FILEID",0              
5868				endm 
# End of macro CWHEAD
5868			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
5868			; | | Compatible with PicoSPINet  
5868 3a 6a fa				ld a, (store_filecache) 
586b 26 00				ld h, 0 
586d 6f					ld l, a 
586e cd f3 20				call forth_push_numhl 
5871					NEXTW 
5871 c3 a0 24			jp macro_next 
5874				endm 
# End of macro NEXTW
5874			.SCONST2: 
5874				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5874 6d				db WORD_SYS_CORE+89             
5875 8c 58			dw .SCONST3            
5877 08				db 7 + 1 
5878 .. 00			db "FILEEXT",0              
5880				endm 
# End of macro CWHEAD
5880			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5880			; | | Compatible with PicoSPINet  
5880 3a 6d fa				ld a, (store_openext) 
5883 26 00				ld h, 0 
5885 6f					ld l, a 
5886 cd f3 20				call forth_push_numhl 
5889					NEXTW 
5889 c3 a0 24			jp macro_next 
588c				endm 
# End of macro NEXTW
588c			.SCONST3: 
588c				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
588c 6d				db WORD_SYS_CORE+89             
588d a4 58			dw .SCONST4            
588f 08				db 7 + 1 
5890 .. 00			db "FILEMAX",0              
5898				endm 
# End of macro CWHEAD
5898			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
5898			; | | Compatible with PicoSPINet  
5898 3a 6c fa				ld a, (store_openmaxext) 
589b 26 00				ld h, 0 
589d 6f					ld l, a 
589e cd f3 20				call forth_push_numhl 
58a1					NEXTW 
58a1 c3 a0 24			jp macro_next 
58a4				endm 
# End of macro NEXTW
58a4			.SCONST4: 
58a4				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
58a4 6d				db WORD_SYS_CORE+89             
58a5 ba 58			dw .SCONST5            
58a7 09				db 8 + 1 
58a8 .. 00			db "FILEADDR",0              
58b1				endm 
# End of macro CWHEAD
58b1			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currenlty open file to stack | DONE 
58b1			; | | Compatible with PicoSPINet  
58b1 2a 6e fa				ld hl, (store_openaddr) 
58b4 cd f3 20				call forth_push_numhl 
58b7					NEXTW 
58b7 c3 a0 24			jp macro_next 
58ba				endm 
# End of macro NEXTW
58ba			.SCONST5: 
58ba				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
58ba 6d				db WORD_SYS_CORE+89             
58bb db 58			dw .SCONST6            
58bd 09				db 8 + 1 
58be .. 00			db "FILEPAGE",0              
58c7				endm 
# End of macro CWHEAD
58c7			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
58c7			; | | Compatible with PicoSPINet  
58c7 2a 6e fa				ld hl, (store_openaddr) 
58ca e5					push hl 
58cb c1					pop bc 
58cc 16 00				ld d, 0 
58ce 1e 40				ld e, STORE_BLOCK_PHY 
58d0 cd e3 0e				call Div16 
58d3 c5					push bc 
58d4 e1					pop hl 
58d5 cd f3 20				call forth_push_numhl 
58d8					NEXTW 
58d8 c3 a0 24			jp macro_next 
58db				endm 
# End of macro NEXTW
58db			.SCONST6: 
58db				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
58db 6d				db WORD_SYS_CORE+89             
58dc f4 58			dw .ENDSTORAGE            
58de 09				db 8 + 1 
58df .. 00			db "READCONT",0              
58e8				endm 
# End of macro CWHEAD
58e8			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
58e8			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
58e8			; | | a further read should, if applicable, be CONCAT to the previous read. 
58e8			; | | Compatible with PicoSPINet  
58e8 3a 70 fa				ld a, (store_readcont) 
58eb 26 00				ld h, 0 
58ed 6f					ld l, a 
58ee cd f3 20				call forth_push_numhl 
58f1					NEXTW 
58f1 c3 a0 24			jp macro_next 
58f4				endm 
# End of macro NEXTW
58f4			.ENDSTORAGE: 
58f4			; eof 
# End of file forth_words_storage.asm
58f4			endif 
58f4				include "forth_words_device.asm" 
58f4			; Device related words 
58f4			 
58f4			; | ## Device Words 
58f4			 
58f4			;if SOUND_ENABLE 
58f4			;.NOTE: 
58f4			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
58f4			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
58f4			;		if DEBUG_FORTH_WORDS_KEY 
58f4			;			DMARK "NTE" 
58f4			;			CALLMONITOR 
58f4			;		endif 
58f4			; 
58f4			;	 
58f4			; 
58f4			;		NEXTW 
58f4			;.AFTERSOUND: 
58f4			;endif 
58f4			 
58f4			 
58f4			USE_GPIO: equ 0 
58f4			 
58f4			if USE_GPIO 
58f4			.GP1: 
58f4				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
58f4			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
58f4					NEXTW 
58f4			.GP2: 
58f4				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
58f4			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
58f4			 
58f4					NEXTW 
58f4			 
58f4			.GP3: 
58f4				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
58f4			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
58f4			 
58f4					NEXTW 
58f4			 
58f4			.GP4: 
58f4				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
58f4			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
58f4			 
58f4					NEXTW 
58f4			.SIN: 
58f4			 
58f4			 
58f4			endif 
58f4			 
58f4			 
58f4				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
58f4 33				db WORD_SYS_CORE+31             
58f5 29 59			dw .SOUT            
58f7 03				db 2 + 1 
58f8 .. 00			db "IN",0              
58fb				endm 
# End of macro CWHEAD
58fb			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
58fb					if DEBUG_FORTH_WORDS_KEY 
58fb						DMARK "IN." 
58fb f5				push af  
58fc 3a 10 59			ld a, (.dmark)  
58ff 32 6e fe			ld (debug_mark),a  
5902 3a 11 59			ld a, (.dmark+1)  
5905 32 6f fe			ld (debug_mark+1),a  
5908 3a 12 59			ld a, (.dmark+2)  
590b 32 70 fe			ld (debug_mark+2),a  
590e 18 03			jr .pastdmark  
5910 ..			.dmark: db "IN."  
5913 f1			.pastdmark: pop af  
5914			endm  
# End of macro DMARK
5914						CALLMONITOR 
5914 cd fb 19			call break_point_state  
5917				endm  
# End of macro CALLMONITOR
5917					endif 
5917					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5917 cd ea 22			call macro_dsp_valuehl 
591a				endm 
# End of macro FORTH_DSP_VALUEHL
591a			 
591a e5					push hl 
591b			 
591b					; destroy value TOS 
591b			 
591b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
591b cd a2 23			call macro_forth_dsp_pop 
591e				endm 
# End of macro FORTH_DSP_POP
591e			 
591e					; one value on hl get other one back 
591e			 
591e c1					pop bc 
591f			 
591f					; do the sub 
591f			;		ex de, hl 
591f			 
591f ed 68				in l,(c) 
5921			 
5921					; save it 
5921			 
5921 26 00				ld h,0 
5923			 
5923					; TODO push value back onto stack for another op etc 
5923			 
5923 cd f3 20				call forth_push_numhl 
5926					NEXTW 
5926 c3 a0 24			jp macro_next 
5929				endm 
# End of macro NEXTW
5929			.SOUT: 
5929				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5929 34				db WORD_SYS_CORE+32             
592a 7c 59			dw .SPIO            
592c 04				db 3 + 1 
592d .. 00			db "OUT",0              
5931				endm 
# End of macro CWHEAD
5931			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5931					if DEBUG_FORTH_WORDS_KEY 
5931						DMARK "OUT" 
5931 f5				push af  
5932 3a 46 59			ld a, (.dmark)  
5935 32 6e fe			ld (debug_mark),a  
5938 3a 47 59			ld a, (.dmark+1)  
593b 32 6f fe			ld (debug_mark+1),a  
593e 3a 48 59			ld a, (.dmark+2)  
5941 32 70 fe			ld (debug_mark+2),a  
5944 18 03			jr .pastdmark  
5946 ..			.dmark: db "OUT"  
5949 f1			.pastdmark: pop af  
594a			endm  
# End of macro DMARK
594a						CALLMONITOR 
594a cd fb 19			call break_point_state  
594d				endm  
# End of macro CALLMONITOR
594d					endif 
594d			 
594d					; get port 
594d			 
594d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
594d cd ea 22			call macro_dsp_valuehl 
5950				endm 
# End of macro FORTH_DSP_VALUEHL
5950			 
5950 e5					push hl 
5951			 
5951					; destroy value TOS 
5951			 
5951					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5951 cd a2 23			call macro_forth_dsp_pop 
5954				endm 
# End of macro FORTH_DSP_POP
5954			 
5954					; get byte to send 
5954			 
5954					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5954 cd ea 22			call macro_dsp_valuehl 
5957				endm 
# End of macro FORTH_DSP_VALUEHL
5957			 
5957			;		push hl 
5957			 
5957					; destroy value TOS 
5957			 
5957					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5957 cd a2 23			call macro_forth_dsp_pop 
595a				endm 
# End of macro FORTH_DSP_POP
595a			 
595a					; one value on hl get other one back 
595a			 
595a			;		pop hl 
595a			 
595a c1					pop bc 
595b			 
595b					if DEBUG_FORTH_WORDS 
595b						DMARK "OUT" 
595b f5				push af  
595c 3a 70 59			ld a, (.dmark)  
595f 32 6e fe			ld (debug_mark),a  
5962 3a 71 59			ld a, (.dmark+1)  
5965 32 6f fe			ld (debug_mark+1),a  
5968 3a 72 59			ld a, (.dmark+2)  
596b 32 70 fe			ld (debug_mark+2),a  
596e 18 03			jr .pastdmark  
5970 ..			.dmark: db "OUT"  
5973 f1			.pastdmark: pop af  
5974			endm  
# End of macro DMARK
5974						CALLMONITOR 
5974 cd fb 19			call break_point_state  
5977				endm  
# End of macro CALLMONITOR
5977					endif 
5977			 
5977 ed 69				out (c), l 
5979			 
5979					NEXTW 
5979 c3 a0 24			jp macro_next 
597c				endm 
# End of macro NEXTW
597c			 
597c			 
597c			.SPIO: 
597c			 
597c			if STORAGE_SE 
597c				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
597c 51				db WORD_SYS_CORE+61             
597d 8d 59			dw .SPICEH            
597f 07				db 6 + 1 
5980 .. 00			db "SPICEL",0              
5987				endm 
# End of macro CWHEAD
5987			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5987			 
5987 cd ca 01				call spi_ce_low 
598a			    NEXTW 
598a c3 a0 24			jp macro_next 
598d				endm 
# End of macro NEXTW
598d			 
598d			.SPICEH: 
598d				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
598d 51				db WORD_SYS_CORE+61             
598e 9e 59			dw .SPIOb            
5990 07				db 6 + 1 
5991 .. 00			db "SPICEH",0              
5998				endm 
# End of macro CWHEAD
5998			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
5998			 
5998 cd b9 01				call spi_ce_high 
599b			    NEXTW 
599b c3 a0 24			jp macro_next 
599e				endm 
# End of macro NEXTW
599e			 
599e			 
599e			.SPIOb: 
599e			 
599e				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
599e 51				db WORD_SYS_CORE+61             
599f d0 59			dw .SPII            
59a1 05				db 4 + 1 
59a2 .. 00			db "SPIO",0              
59a7				endm 
# End of macro CWHEAD
59a7			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
59a7			 
59a7					if DEBUG_FORTH_WORDS_KEY 
59a7						DMARK "SPo" 
59a7 f5				push af  
59a8 3a bc 59			ld a, (.dmark)  
59ab 32 6e fe			ld (debug_mark),a  
59ae 3a bd 59			ld a, (.dmark+1)  
59b1 32 6f fe			ld (debug_mark+1),a  
59b4 3a be 59			ld a, (.dmark+2)  
59b7 32 70 fe			ld (debug_mark+2),a  
59ba 18 03			jr .pastdmark  
59bc ..			.dmark: db "SPo"  
59bf f1			.pastdmark: pop af  
59c0			endm  
# End of macro DMARK
59c0						CALLMONITOR 
59c0 cd fb 19			call break_point_state  
59c3				endm  
# End of macro CALLMONITOR
59c3					endif 
59c3					; get port 
59c3			 
59c3			 
59c3					; get byte to send 
59c3			 
59c3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
59c3 cd ea 22			call macro_dsp_valuehl 
59c6				endm 
# End of macro FORTH_DSP_VALUEHL
59c6			 
59c6			;		push hl    ; u1  
59c6			 
59c6					; destroy value TOS 
59c6			 
59c6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
59c6 cd a2 23			call macro_forth_dsp_pop 
59c9				endm 
# End of macro FORTH_DSP_POP
59c9			 
59c9					; one value on hl get other one back 
59c9			 
59c9			;		pop hl   ; u2 - addr 
59c9			 
59c9					; TODO Send SPI byte 
59c9			 
59c9			;		push hl 
59c9			;		call spi_ce_low 
59c9			;		pop hl 
59c9 7d					ld a, l 
59ca cd b8 00				call spi_send_byte 
59cd			;		call spi_ce_high 
59cd			 
59cd					NEXTW 
59cd c3 a0 24			jp macro_next 
59d0				endm 
# End of macro NEXTW
59d0			 
59d0			.SPII: 
59d0				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
59d0 52				db WORD_SYS_CORE+62             
59d1 39 5a			dw .SESEL            
59d3 06				db 5 + 1 
59d4 .. 00			db "SPII",0              
59d9				endm 
# End of macro CWHEAD
59d9			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
59d9					if DEBUG_FORTH_WORDS_KEY 
59d9						DMARK "SPi" 
59d9 f5				push af  
59da 3a ee 59			ld a, (.dmark)  
59dd 32 6e fe			ld (debug_mark),a  
59e0 3a ef 59			ld a, (.dmark+1)  
59e3 32 6f fe			ld (debug_mark+1),a  
59e6 3a f0 59			ld a, (.dmark+2)  
59e9 32 70 fe			ld (debug_mark+2),a  
59ec 18 03			jr .pastdmark  
59ee ..			.dmark: db "SPi"  
59f1 f1			.pastdmark: pop af  
59f2			endm  
# End of macro DMARK
59f2						CALLMONITOR 
59f2 cd fb 19			call break_point_state  
59f5				endm  
# End of macro CALLMONITOR
59f5					endif 
59f5			 
59f5					; TODO Get SPI byte 
59f5			 
59f5 cd df 00				call spi_read_byte 
59f8			 
59f8					if DEBUG_FORTH_WORDS 
59f8						DMARK "Si2" 
59f8 f5				push af  
59f9 3a 0d 5a			ld a, (.dmark)  
59fc 32 6e fe			ld (debug_mark),a  
59ff 3a 0e 5a			ld a, (.dmark+1)  
5a02 32 6f fe			ld (debug_mark+1),a  
5a05 3a 0f 5a			ld a, (.dmark+2)  
5a08 32 70 fe			ld (debug_mark+2),a  
5a0b 18 03			jr .pastdmark  
5a0d ..			.dmark: db "Si2"  
5a10 f1			.pastdmark: pop af  
5a11			endm  
# End of macro DMARK
5a11						CALLMONITOR 
5a11 cd fb 19			call break_point_state  
5a14				endm  
# End of macro CALLMONITOR
5a14					endif 
5a14 26 00				ld h, 0 
5a16 6f					ld l, a 
5a17					if DEBUG_FORTH_WORDS 
5a17						DMARK "Si3" 
5a17 f5				push af  
5a18 3a 2c 5a			ld a, (.dmark)  
5a1b 32 6e fe			ld (debug_mark),a  
5a1e 3a 2d 5a			ld a, (.dmark+1)  
5a21 32 6f fe			ld (debug_mark+1),a  
5a24 3a 2e 5a			ld a, (.dmark+2)  
5a27 32 70 fe			ld (debug_mark+2),a  
5a2a 18 03			jr .pastdmark  
5a2c ..			.dmark: db "Si3"  
5a2f f1			.pastdmark: pop af  
5a30			endm  
# End of macro DMARK
5a30						CALLMONITOR 
5a30 cd fb 19			call break_point_state  
5a33				endm  
# End of macro CALLMONITOR
5a33					endif 
5a33 cd f3 20				call forth_push_numhl 
5a36			 
5a36					NEXTW 
5a36 c3 a0 24			jp macro_next 
5a39				endm 
# End of macro NEXTW
5a39			 
5a39			 
5a39			 
5a39			.SESEL: 
5a39				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5a39 66				db WORD_SYS_CORE+82             
5a3a e2 5a			dw .CARTDEV            
5a3c 05				db 4 + 1 
5a3d .. 00			db "BANK",0              
5a42				endm 
# End of macro CWHEAD
5a42			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5a42					if DEBUG_FORTH_WORDS_KEY 
5a42						DMARK "BNK" 
5a42 f5				push af  
5a43 3a 57 5a			ld a, (.dmark)  
5a46 32 6e fe			ld (debug_mark),a  
5a49 3a 58 5a			ld a, (.dmark+1)  
5a4c 32 6f fe			ld (debug_mark+1),a  
5a4f 3a 59 5a			ld a, (.dmark+2)  
5a52 32 70 fe			ld (debug_mark+2),a  
5a55 18 03			jr .pastdmark  
5a57 ..			.dmark: db "BNK"  
5a5a f1			.pastdmark: pop af  
5a5b			endm  
# End of macro DMARK
5a5b						CALLMONITOR 
5a5b cd fb 19			call break_point_state  
5a5e				endm  
# End of macro CALLMONITOR
5a5e					endif 
5a5e			 
5a5e 3e ff				ld a, 255 
5a60 32 66 fa				ld (spi_cartdev), a 
5a63			 
5a63					; get bank 
5a63			 
5a63					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a63 cd ea 22			call macro_dsp_valuehl 
5a66				endm 
# End of macro FORTH_DSP_VALUEHL
5a66			 
5a66			;		push hl 
5a66			 
5a66					; destroy value TOS 
5a66			 
5a66					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a66 cd a2 23			call macro_forth_dsp_pop 
5a69				endm 
# End of macro FORTH_DSP_POP
5a69			 
5a69					; one value on hl get other one back 
5a69			 
5a69			;		pop hl 
5a69			 
5a69			 
5a69 0e ff				ld c, SPI_CE_HIGH 
5a6b 06 30				ld b, '0'    ; human readable bank number 
5a6d			 
5a6d 7d					ld a, l 
5a6e			 
5a6e					if DEBUG_FORTH_WORDS 
5a6e						DMARK "BNK" 
5a6e f5				push af  
5a6f 3a 83 5a			ld a, (.dmark)  
5a72 32 6e fe			ld (debug_mark),a  
5a75 3a 84 5a			ld a, (.dmark+1)  
5a78 32 6f fe			ld (debug_mark+1),a  
5a7b 3a 85 5a			ld a, (.dmark+2)  
5a7e 32 70 fe			ld (debug_mark+2),a  
5a81 18 03			jr .pastdmark  
5a83 ..			.dmark: db "BNK"  
5a86 f1			.pastdmark: pop af  
5a87			endm  
# End of macro DMARK
5a87						CALLMONITOR 
5a87 cd fb 19			call break_point_state  
5a8a				endm  
# End of macro CALLMONITOR
5a8a					endif 
5a8a			 
5a8a					; active low 
5a8a			 
5a8a fe 00				cp 0 
5a8c 28 28				jr z, .bset 
5a8e fe 01				cp 1 
5a90 20 04				jr nz, .b2 
5a92 cb 81				res 0, c 
5a94 06 31				ld b, '1'    ; human readable bank number 
5a96 fe 02		.b2:		cp 2 
5a98 20 04				jr nz, .b3 
5a9a cb 89				res 1, c 
5a9c 06 32				ld b, '2'    ; human readable bank number 
5a9e fe 03		.b3:		cp 3 
5aa0 20 04				jr nz, .b4 
5aa2 cb 91				res 2, c 
5aa4 06 33				ld b, '3'    ; human readable bank number 
5aa6 fe 04		.b4:		cp 4 
5aa8 20 04				jr nz, .b5 
5aaa cb 99				res 3, c 
5aac 06 34				ld b, '4'    ; human readable bank number 
5aae fe 05		.b5:		cp 5 
5ab0 20 04				jr nz, .bset 
5ab2 cb a1				res 4, c 
5ab4 06 35				ld b, '5'    ; human readable bank number 
5ab6			 
5ab6			.bset: 
5ab6 79					ld a, c 
5ab7 32 63 fa				ld (spi_device),a 
5aba 78					ld a, b 
5abb 32 62 fa				ld (spi_device_id),a 
5abe					if DEBUG_FORTH_WORDS 
5abe						DMARK "BN2" 
5abe f5				push af  
5abf 3a d3 5a			ld a, (.dmark)  
5ac2 32 6e fe			ld (debug_mark),a  
5ac5 3a d4 5a			ld a, (.dmark+1)  
5ac8 32 6f fe			ld (debug_mark+1),a  
5acb 3a d5 5a			ld a, (.dmark+2)  
5ace 32 70 fe			ld (debug_mark+2),a  
5ad1 18 03			jr .pastdmark  
5ad3 ..			.dmark: db "BN2"  
5ad6 f1			.pastdmark: pop af  
5ad7			endm  
# End of macro DMARK
5ad7						CALLMONITOR 
5ad7 cd fb 19			call break_point_state  
5ada				endm  
# End of macro CALLMONITOR
5ada					endif 
5ada			 
5ada					; set default SPI clk pulse time as disabled for BANK use 
5ada			 
5ada 3e 00				ld a, 0 
5adc 32 67 fa				ld (spi_clktime), a 
5adf			 
5adf					NEXTW 
5adf c3 a0 24			jp macro_next 
5ae2				endm 
# End of macro NEXTW
5ae2			 
5ae2			.CARTDEV: 
5ae2				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5ae2 66				db WORD_SYS_CORE+82             
5ae3 90 5b			dw .ENDDEVICE            
5ae5 08				db 7 + 1 
5ae6 .. 00			db "CARTDEV",0              
5aee				endm 
# End of macro CWHEAD
5aee			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5aee					if DEBUG_FORTH_WORDS_KEY 
5aee						DMARK "CDV" 
5aee f5				push af  
5aef 3a 03 5b			ld a, (.dmark)  
5af2 32 6e fe			ld (debug_mark),a  
5af5 3a 04 5b			ld a, (.dmark+1)  
5af8 32 6f fe			ld (debug_mark+1),a  
5afb 3a 05 5b			ld a, (.dmark+2)  
5afe 32 70 fe			ld (debug_mark+2),a  
5b01 18 03			jr .pastdmark  
5b03 ..			.dmark: db "CDV"  
5b06 f1			.pastdmark: pop af  
5b07			endm  
# End of macro DMARK
5b07						CALLMONITOR 
5b07 cd fb 19			call break_point_state  
5b0a				endm  
# End of macro CALLMONITOR
5b0a					endif 
5b0a			 
5b0a					; disable se storage bank selection 
5b0a			 
5b0a 3e ff				ld a, SPI_CE_HIGH		; ce high 
5b0c 32 63 fa				ld (spi_device), a 
5b0f			 
5b0f					; get bank 
5b0f			 
5b0f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b0f cd ea 22			call macro_dsp_valuehl 
5b12				endm 
# End of macro FORTH_DSP_VALUEHL
5b12			 
5b12			;		push hl 
5b12			 
5b12					; destroy value TOS 
5b12			 
5b12					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b12 cd a2 23			call macro_forth_dsp_pop 
5b15				endm 
# End of macro FORTH_DSP_POP
5b15			 
5b15					; one value on hl get other one back 
5b15			 
5b15			;		pop hl 
5b15			 
5b15					; active low 
5b15			 
5b15 0e ff				ld c, 255 
5b17			 
5b17 7d					ld a, l 
5b18					if DEBUG_FORTH_WORDS 
5b18						DMARK "CDV" 
5b18 f5				push af  
5b19 3a 2d 5b			ld a, (.dmark)  
5b1c 32 6e fe			ld (debug_mark),a  
5b1f 3a 2e 5b			ld a, (.dmark+1)  
5b22 32 6f fe			ld (debug_mark+1),a  
5b25 3a 2f 5b			ld a, (.dmark+2)  
5b28 32 70 fe			ld (debug_mark+2),a  
5b2b 18 03			jr .pastdmark  
5b2d ..			.dmark: db "CDV"  
5b30 f1			.pastdmark: pop af  
5b31			endm  
# End of macro DMARK
5b31						CALLMONITOR 
5b31 cd fb 19			call break_point_state  
5b34				endm  
# End of macro CALLMONITOR
5b34					endif 
5b34 fe 00				cp 0 
5b36 28 30				jr z, .cset 
5b38 fe 01				cp 1 
5b3a 20 02				jr nz, .c2 
5b3c cb 81				res 0, c 
5b3e fe 02		.c2:		cp 2 
5b40 20 02				jr nz, .c3 
5b42 cb 89				res 1, c 
5b44 fe 03		.c3:		cp 3 
5b46 20 02				jr nz, .c4 
5b48 cb 91				res 2, c 
5b4a fe 04		.c4:		cp 4 
5b4c 20 02				jr nz, .c5 
5b4e cb 99				res 3, c 
5b50 fe 05		.c5:		cp 5 
5b52 20 02				jr nz, .c6 
5b54 cb a1				res 4, c 
5b56 fe 06		.c6:		cp 6 
5b58 20 02				jr nz, .c7 
5b5a cb a9				res 5, c 
5b5c fe 07		.c7:		cp 7 
5b5e 20 02				jr nz, .c8 
5b60 cb b1				res 6, c 
5b62 fe 08		.c8:		cp 8 
5b64 20 02				jr nz, .cset 
5b66 cb b9				res 7, c 
5b68 79			.cset:		ld a, c 
5b69 32 66 fa				ld (spi_cartdev),a 
5b6c			 
5b6c					if DEBUG_FORTH_WORDS 
5b6c						DMARK "CD2" 
5b6c f5				push af  
5b6d 3a 81 5b			ld a, (.dmark)  
5b70 32 6e fe			ld (debug_mark),a  
5b73 3a 82 5b			ld a, (.dmark+1)  
5b76 32 6f fe			ld (debug_mark+1),a  
5b79 3a 83 5b			ld a, (.dmark+2)  
5b7c 32 70 fe			ld (debug_mark+2),a  
5b7f 18 03			jr .pastdmark  
5b81 ..			.dmark: db "CD2"  
5b84 f1			.pastdmark: pop af  
5b85			endm  
# End of macro DMARK
5b85						CALLMONITOR 
5b85 cd fb 19			call break_point_state  
5b88				endm  
# End of macro CALLMONITOR
5b88					endif 
5b88			 
5b88					; set default SPI clk pulse time as 10ms for CARTDEV use 
5b88			 
5b88 3e 0a				ld a, $0a 
5b8a 32 67 fa				ld (spi_clktime), a 
5b8d					NEXTW 
5b8d c3 a0 24			jp macro_next 
5b90				endm 
# End of macro NEXTW
5b90			endif 
5b90			 
5b90			.ENDDEVICE: 
5b90			; eof 
5b90			 
# End of file forth_words_device.asm
5b90			 
5b90			; var handler 
5b90			 
5b90			 
5b90			.VARS: 
5b90				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5b90 77				db WORD_SYS_CORE+99             
5b91 41 5c			dw .V0            
5b93 04				db 3 + 1 
5b94 .. 00			db "VAR",0              
5b98				endm 
# End of macro CWHEAD
5b98			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5b98			;| 
5b98			;| The variable name should consist of a single letter. e.g. "a" 
5b98			;! If a full string is passed then only the first char is looked at 
5b98			;| Any other char could exceed bounds checks!  
5b98			 
5b98					if DEBUG_FORTH_WORDS_KEY 
5b98						DMARK "VAR" 
5b98 f5				push af  
5b99 3a ad 5b			ld a, (.dmark)  
5b9c 32 6e fe			ld (debug_mark),a  
5b9f 3a ae 5b			ld a, (.dmark+1)  
5ba2 32 6f fe			ld (debug_mark+1),a  
5ba5 3a af 5b			ld a, (.dmark+2)  
5ba8 32 70 fe			ld (debug_mark+2),a  
5bab 18 03			jr .pastdmark  
5bad ..			.dmark: db "VAR"  
5bb0 f1			.pastdmark: pop af  
5bb1			endm  
# End of macro DMARK
5bb1						CALLMONITOR 
5bb1 cd fb 19			call break_point_state  
5bb4				endm  
# End of macro CALLMONITOR
5bb4					endif 
5bb4			 
5bb4					FORTH_DSP_VALUEHL 
5bb4 cd ea 22			call macro_dsp_valuehl 
5bb7				endm 
# End of macro FORTH_DSP_VALUEHL
5bb7			 
5bb7 7e					ld a, (hl)    ; get first char on of the string 
5bb8			 
5bb8			 
5bb8					if DEBUG_FORTH_WORDS 
5bb8						DMARK "VR1" 
5bb8 f5				push af  
5bb9 3a cd 5b			ld a, (.dmark)  
5bbc 32 6e fe			ld (debug_mark),a  
5bbf 3a ce 5b			ld a, (.dmark+1)  
5bc2 32 6f fe			ld (debug_mark+1),a  
5bc5 3a cf 5b			ld a, (.dmark+2)  
5bc8 32 70 fe			ld (debug_mark+2),a  
5bcb 18 03			jr .pastdmark  
5bcd ..			.dmark: db "VR1"  
5bd0 f1			.pastdmark: pop af  
5bd1			endm  
# End of macro DMARK
5bd1						CALLMONITOR 
5bd1 cd fb 19			call break_point_state  
5bd4				endm  
# End of macro CALLMONITOR
5bd4					endif 
5bd4					 
5bd4 f5					push af	 
5bd5					FORTH_DSP_POP 
5bd5 cd a2 23			call macro_forth_dsp_pop 
5bd8				endm 
# End of macro FORTH_DSP_POP
5bd8 f1					pop af 
5bd9			 
5bd9					; convert to upper 
5bd9			 
5bd9 cd f3 12				call to_upper 
5bdc					if DEBUG_FORTH_WORDS 
5bdc						DMARK "Vaa" 
5bdc f5				push af  
5bdd 3a f1 5b			ld a, (.dmark)  
5be0 32 6e fe			ld (debug_mark),a  
5be3 3a f2 5b			ld a, (.dmark+1)  
5be6 32 6f fe			ld (debug_mark+1),a  
5be9 3a f3 5b			ld a, (.dmark+2)  
5bec 32 70 fe			ld (debug_mark+2),a  
5bef 18 03			jr .pastdmark  
5bf1 ..			.dmark: db "Vaa"  
5bf4 f1			.pastdmark: pop af  
5bf5			endm  
# End of macro DMARK
5bf5						CALLMONITOR 
5bf5 cd fb 19			call break_point_state  
5bf8				endm  
# End of macro CALLMONITOR
5bf8					endif 
5bf8 06 41				ld b, 'A' 
5bfa 90					sub b			; set offset 
5bfb					if DEBUG_FORTH_WORDS 
5bfb						DMARK "Vbb" 
5bfb f5				push af  
5bfc 3a 10 5c			ld a, (.dmark)  
5bff 32 6e fe			ld (debug_mark),a  
5c02 3a 11 5c			ld a, (.dmark+1)  
5c05 32 6f fe			ld (debug_mark+1),a  
5c08 3a 12 5c			ld a, (.dmark+2)  
5c0b 32 70 fe			ld (debug_mark+2),a  
5c0e 18 03			jr .pastdmark  
5c10 ..			.dmark: db "Vbb"  
5c13 f1			.pastdmark: pop af  
5c14			endm  
# End of macro DMARK
5c14						CALLMONITOR 
5c14 cd fb 19			call break_point_state  
5c17				endm  
# End of macro CALLMONITOR
5c17					endif 
5c17 cb 27				sla a  
5c19				 
5c19					 
5c19					if DEBUG_FORTH_WORDS 
5c19						DMARK "VR2" 
5c19 f5				push af  
5c1a 3a 2e 5c			ld a, (.dmark)  
5c1d 32 6e fe			ld (debug_mark),a  
5c20 3a 2f 5c			ld a, (.dmark+1)  
5c23 32 6f fe			ld (debug_mark+1),a  
5c26 3a 30 5c			ld a, (.dmark+2)  
5c29 32 70 fe			ld (debug_mark+2),a  
5c2c 18 03			jr .pastdmark  
5c2e ..			.dmark: db "VR2"  
5c31 f1			.pastdmark: pop af  
5c32			endm  
# End of macro DMARK
5c32						CALLMONITOR 
5c32 cd fb 19			call break_point_state  
5c35				endm  
# End of macro CALLMONITOR
5c35					endif 
5c35			 
5c35 21 f7 f9				ld hl, cli_var_array2 
5c38 cd 86 0f				call addatohl 
5c3b cd f3 20				call forth_push_numhl 
5c3e			 
5c3e			 
5c3e				       NEXTW 
5c3e c3 a0 24			jp macro_next 
5c41				endm 
# End of macro NEXTW
5c41			.V0: 
5c41				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5c41 78				db WORD_SYS_CORE+100             
5c42 59 5c			dw .V0Q            
5c44 04				db 3 + 1 
5c45 .. 00			db "V0!",0              
5c49				endm 
# End of macro CWHEAD
5c49			;| V0! ( u1 -- )  Store value to v0  | DONE 
5c49			 
5c49					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c49 cd ea 22			call macro_dsp_valuehl 
5c4c				endm 
# End of macro FORTH_DSP_VALUEHL
5c4c			 
5c4c 11 2b fa				ld de, cli_var_array 
5c4f			 
5c4f eb					ex de, hl 
5c50 73					ld (hl), e 
5c51 23					inc hl 
5c52 72					ld (hl), d 
5c53			 
5c53					; destroy value TOS 
5c53			 
5c53					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c53 cd a2 23			call macro_forth_dsp_pop 
5c56				endm 
# End of macro FORTH_DSP_POP
5c56			 
5c56				       NEXTW 
5c56 c3 a0 24			jp macro_next 
5c59				endm 
# End of macro NEXTW
5c59			.V0Q: 
5c59				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5c59 79				db WORD_SYS_CORE+101             
5c5a 6a 5c			dw .V1S            
5c5c 04				db 3 + 1 
5c5d .. 00			db "V0@",0              
5c61				endm 
# End of macro CWHEAD
5c61			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5c61 2a 2b fa				ld hl, (cli_var_array) 
5c64 cd f3 20				call forth_push_numhl 
5c67			 
5c67				       NEXTW 
5c67 c3 a0 24			jp macro_next 
5c6a				endm 
# End of macro NEXTW
5c6a			.V1S: 
5c6a				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5c6a 7a				db WORD_SYS_CORE+102             
5c6b 82 5c			dw .V1Q            
5c6d 04				db 3 + 1 
5c6e .. 00			db "V1!",0              
5c72				endm 
# End of macro CWHEAD
5c72			;| V1! ( u1 -- )  Store value to v1 | DONE 
5c72					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c72 cd ea 22			call macro_dsp_valuehl 
5c75				endm 
# End of macro FORTH_DSP_VALUEHL
5c75			 
5c75 11 2d fa				ld de, cli_var_array+2 
5c78				 
5c78 eb					ex de, hl 
5c79 73					ld (hl), e 
5c7a 23					inc hl 
5c7b 72					ld (hl), d 
5c7c			 
5c7c					; destroy value TOS 
5c7c			 
5c7c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c7c cd a2 23			call macro_forth_dsp_pop 
5c7f				endm 
# End of macro FORTH_DSP_POP
5c7f				       NEXTW 
5c7f c3 a0 24			jp macro_next 
5c82				endm 
# End of macro NEXTW
5c82			.V1Q: 
5c82				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5c82 7b				db WORD_SYS_CORE+103             
5c83 93 5c			dw .V2S            
5c85 04				db 3 + 1 
5c86 .. 00			db "V1@",0              
5c8a				endm 
# End of macro CWHEAD
5c8a			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5c8a 2a 2d fa				ld hl, (cli_var_array+2) 
5c8d cd f3 20				call forth_push_numhl 
5c90				       NEXTW 
5c90 c3 a0 24			jp macro_next 
5c93				endm 
# End of macro NEXTW
5c93			.V2S: 
5c93				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5c93 7c				db WORD_SYS_CORE+104             
5c94 ab 5c			dw .V2Q            
5c96 04				db 3 + 1 
5c97 .. 00			db "V2!",0              
5c9b				endm 
# End of macro CWHEAD
5c9b			;| V2! ( u1 -- )  Store value to v2 | DONE 
5c9b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c9b cd ea 22			call macro_dsp_valuehl 
5c9e				endm 
# End of macro FORTH_DSP_VALUEHL
5c9e			 
5c9e 11 2f fa				ld de, cli_var_array+4 
5ca1				 
5ca1 eb					ex de, hl 
5ca2 73					ld (hl), e 
5ca3 23					inc hl 
5ca4 72					ld (hl), d 
5ca5			 
5ca5					; destroy value TOS 
5ca5			 
5ca5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ca5 cd a2 23			call macro_forth_dsp_pop 
5ca8				endm 
# End of macro FORTH_DSP_POP
5ca8				       NEXTW 
5ca8 c3 a0 24			jp macro_next 
5cab				endm 
# End of macro NEXTW
5cab			.V2Q: 
5cab				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5cab 7d				db WORD_SYS_CORE+105             
5cac bc 5c			dw .V3S            
5cae 04				db 3 + 1 
5caf .. 00			db "V2@",0              
5cb3				endm 
# End of macro CWHEAD
5cb3			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5cb3 2a 2f fa				ld hl, (cli_var_array+4) 
5cb6 cd f3 20				call forth_push_numhl 
5cb9				       NEXTW 
5cb9 c3 a0 24			jp macro_next 
5cbc				endm 
# End of macro NEXTW
5cbc			.V3S: 
5cbc				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5cbc 7c				db WORD_SYS_CORE+104             
5cbd d4 5c			dw .V3Q            
5cbf 04				db 3 + 1 
5cc0 .. 00			db "V3!",0              
5cc4				endm 
# End of macro CWHEAD
5cc4			;| V3! ( u1 -- )  Store value to v3 | DONE 
5cc4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5cc4 cd ea 22			call macro_dsp_valuehl 
5cc7				endm 
# End of macro FORTH_DSP_VALUEHL
5cc7			 
5cc7 11 31 fa				ld de, cli_var_array+6 
5cca				 
5cca eb					ex de, hl 
5ccb 73					ld (hl), e 
5ccc 23					inc hl 
5ccd 72					ld (hl), d 
5cce			 
5cce					; destroy value TOS 
5cce			 
5cce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5cce cd a2 23			call macro_forth_dsp_pop 
5cd1				endm 
# End of macro FORTH_DSP_POP
5cd1				       NEXTW 
5cd1 c3 a0 24			jp macro_next 
5cd4				endm 
# End of macro NEXTW
5cd4			.V3Q: 
5cd4				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5cd4 7d				db WORD_SYS_CORE+105             
5cd5 e5 5c			dw .END            
5cd7 04				db 3 + 1 
5cd8 .. 00			db "V3@",0              
5cdc				endm 
# End of macro CWHEAD
5cdc			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5cdc 2a 31 fa				ld hl, (cli_var_array+6) 
5cdf cd f3 20				call forth_push_numhl 
5ce2				       NEXTW 
5ce2 c3 a0 24			jp macro_next 
5ce5				endm 
# End of macro NEXTW
5ce5			 
5ce5			 
5ce5			 
5ce5			 
5ce5			 
5ce5			; end of dict marker 
5ce5			 
5ce5 00			.END:    db WORD_SYS_END 
5ce6 00 00			dw 0 
5ce8 00				db 0 
5ce9			 
5ce9			; use to jp here for user dict words to save on macro expansion  
5ce9			 
5ce9			user_dict_next: 
5ce9				NEXTW 
5ce9 c3 a0 24			jp macro_next 
5cec				endm 
# End of macro NEXTW
5cec			 
5cec			 
5cec			user_exec: 
5cec				;    ld hl, <word code> 
5cec				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5cec				;    call forthexec 
5cec				;    jp user_dict_next   (NEXT) 
5cec			        ;    <word code bytes> 
5cec eb				ex de, hl 
5ced 2a c5 f4			ld hl,(os_tok_ptr) 
5cf0				 
5cf0				FORTH_RSP_NEXT 
5cf0 cd 9a 20			call macro_forth_rsp_next 
5cf3				endm 
# End of macro FORTH_RSP_NEXT
5cf3			 
5cf3			if DEBUG_FORTH_UWORD 
5cf3						DMARK "UEX" 
5cf3 f5				push af  
5cf4 3a 08 5d			ld a, (.dmark)  
5cf7 32 6e fe			ld (debug_mark),a  
5cfa 3a 09 5d			ld a, (.dmark+1)  
5cfd 32 6f fe			ld (debug_mark+1),a  
5d00 3a 0a 5d			ld a, (.dmark+2)  
5d03 32 70 fe			ld (debug_mark+2),a  
5d06 18 03			jr .pastdmark  
5d08 ..			.dmark: db "UEX"  
5d0b f1			.pastdmark: pop af  
5d0c			endm  
# End of macro DMARK
5d0c				CALLMONITOR 
5d0c cd fb 19			call break_point_state  
5d0f				endm  
# End of macro CALLMONITOR
5d0f			endif 
5d0f			 
5d0f			 
5d0f			 
5d0f eb				ex de, hl 
5d10 22 c5 f4			ld (os_tok_ptr), hl 
5d13				 
5d13				; Don't use next - Skips the first word in uword. 
5d13			 
5d13 c3 31 25			jp exec1 
5d16			;	NEXT 
5d16			 
5d16			 
5d16			; eof 
# End of file forth_wordsv4.asm
5d16			endif 
5d16			;;;;;;;;;;;;;; Debug code 
5d16			 
5d16			 
5d16			;if DEBUG_FORTH_PARSE 
5d16 .. 00		.nowordfound: db "No match",0 
5d1f .. 00		.compword:	db "Comparing word ",0 
5d2f .. 00		.nextwordat:	db "Next word at",0 
5d3c .. 00		.charmatch:	db "Char match",0 
5d47			;endif 
5d47			if DEBUG_FORTH_JP 
5d47			.foundword:	db "Word match. Exec..",0 
5d47			endif 
5d47			;if DEBUG_FORTH_PUSH 
5d47 .. 00		.enddict:	db "Dict end. Push.",0 
5d57 .. 00		.push_str:	db "Pushing string",0 
5d66 .. 00		.push_num:	db "Pushing number",0 
5d75 .. 00		.data_sp:	db "SP:",0 
5d79 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5d8b .. 00		.wordinde:	db "Word in DE (3/0):",0 
5d9d .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5daf			;endif 
5daf			;if DEBUG_FORTH_MALLOC 
5daf .. 00		.push_malloc:	db "Malloc address",0 
5dbe			;endif 
5dbe			 
5dbe			 
5dbe			 
5dbe			; display malloc address and current data stack pointer  
5dbe			 
5dbe			malloc_error: 
5dbe d5				push de 
5dbf f5				push af 
5dc0 e5				push hl 
5dc1 cd 52 0d			call clear_display 
5dc4 11 e6 5d			ld de, .mallocerr 
5dc7 3e 00			ld a,0 
5dc9			;	ld de,os_word_scratch 
5dc9 cd 65 0d			call str_at_display 
5dcc 3e 11			ld a, display_row_1+17 
5dce 11 6e fe			ld de, debug_mark 
5dd1 cd 65 0d			call str_at_display 
5dd4 cd 75 0d			call update_display 
5dd7				;call break_point_state 
5dd7 cd c1 78			call cin_wait 
5dda			 
5dda 3e 20			ld a, ' ' 
5ddc 32 b5 f1			ld (os_view_disable), a 
5ddf e1				pop hl 
5de0 f1				pop af 
5de1 d1				pop de	 
5de2				CALLMONITOR 
5de2 cd fb 19			call break_point_state  
5de5				endm  
# End of macro CALLMONITOR
5de5 c9				ret 
5de6			 
5de6 .. 00		.mallocerr: 	db "Malloc Error",0 
5df3			;if DEBUG_FORTH_PUSH 
5df3			display_data_sp: 
5df3 f5				push af 
5df4			 
5df4				; see if disabled 
5df4			 
5df4 3a b5 f1			ld a, (os_view_disable) 
5df7 fe 2a			cp '*' 
5df9 28 67			jr z, .skipdsp 
5dfb			 
5dfb e5				push hl 
5dfc e5				push hl 
5dfd e5			push hl 
5dfe cd 52 0d			call clear_display 
5e01 e1			pop hl 
5e02 7c				ld a,h 
5e03 21 c9 f4			ld hl, os_word_scratch 
5e06 cd 87 12			call hexout 
5e09 e1				pop hl 
5e0a 7d				ld a,l 
5e0b 21 cb f4			ld hl, os_word_scratch+2 
5e0e cd 87 12			call hexout 
5e11 21 cd f4			ld hl, os_word_scratch+4 
5e14 3e 00			ld a,0 
5e16 77				ld (hl),a 
5e17 11 c9 f4			ld de,os_word_scratch 
5e1a 3e 28				ld a, display_row_2 
5e1c cd 65 0d				call str_at_display 
5e1f 11 79 5d			ld de, .wordinhl 
5e22 3e 00			ld a, display_row_1 
5e24			 
5e24 cd 65 0d				call str_at_display 
5e27 11 6e fe			ld de, debug_mark 
5e2a 3e 11			ld a, display_row_1+17 
5e2c			 
5e2c cd 65 0d				call str_at_display 
5e2f			 
5e2f				; display current data stack pointer 
5e2f 11 75 5d			ld de,.data_sp 
5e32 3e 30				ld a, display_row_2 + 8 
5e34 cd 65 0d				call str_at_display 
5e37			 
5e37 2a f1 f9			ld hl,(cli_data_sp) 
5e3a e5				push hl 
5e3b 7c				ld a,h 
5e3c 21 c9 f4			ld hl, os_word_scratch 
5e3f cd 87 12			call hexout 
5e42 e1				pop hl 
5e43 7d				ld a,l 
5e44 21 cb f4			ld hl, os_word_scratch+2 
5e47 cd 87 12			call hexout 
5e4a 21 cd f4			ld hl, os_word_scratch+4 
5e4d 3e 00			ld a,0 
5e4f 77				ld (hl),a 
5e50 11 c9 f4			ld de,os_word_scratch 
5e53 3e 33				ld a, display_row_2 + 11 
5e55 cd 65 0d				call str_at_display 
5e58			 
5e58			 
5e58 cd 75 0d			call update_display 
5e5b cd 95 0c			call delay1s 
5e5e cd 95 0c			call delay1s 
5e61 e1				pop hl 
5e62			.skipdsp: 
5e62 f1				pop af 
5e63 c9				ret 
5e64			 
5e64			display_data_malloc: 
5e64			 
5e64 f5				push af 
5e65 e5				push hl 
5e66 e5				push hl 
5e67 e5			push hl 
5e68 cd 52 0d			call clear_display 
5e6b e1			pop hl 
5e6c 7c				ld a,h 
5e6d 21 c9 f4			ld hl, os_word_scratch 
5e70 cd 87 12			call hexout 
5e73 e1				pop hl 
5e74 7d				ld a,l 
5e75 21 cb f4			ld hl, os_word_scratch+2 
5e78 cd 87 12			call hexout 
5e7b 21 cd f4			ld hl, os_word_scratch+4 
5e7e 3e 00			ld a,0 
5e80 77				ld (hl),a 
5e81 11 c9 f4			ld de,os_word_scratch 
5e84 3e 28				ld a, display_row_2 
5e86 cd 65 0d				call str_at_display 
5e89 11 af 5d			ld de, .push_malloc 
5e8c 3e 00			ld a, display_row_1 
5e8e			 
5e8e cd 65 0d				call str_at_display 
5e91			 
5e91				; display current data stack pointer 
5e91 11 75 5d			ld de,.data_sp 
5e94 3e 30				ld a, display_row_2 + 8 
5e96 cd 65 0d				call str_at_display 
5e99			 
5e99 2a f1 f9			ld hl,(cli_data_sp) 
5e9c e5				push hl 
5e9d 7c				ld a,h 
5e9e 21 c9 f4			ld hl, os_word_scratch 
5ea1 cd 87 12			call hexout 
5ea4 e1				pop hl 
5ea5 7d				ld a,l 
5ea6 21 cb f4			ld hl, os_word_scratch+2 
5ea9 cd 87 12			call hexout 
5eac 21 cd f4			ld hl, os_word_scratch+4 
5eaf 3e 00			ld a,0 
5eb1 77				ld (hl),a 
5eb2 11 c9 f4			ld de,os_word_scratch 
5eb5 3e 33				ld a, display_row_2 + 11 
5eb7 cd 65 0d				call str_at_display 
5eba			 
5eba cd 75 0d			call update_display 
5ebd cd 95 0c			call delay1s 
5ec0 cd 95 0c			call delay1s 
5ec3 e1				pop hl 
5ec4 f1				pop af 
5ec5 c9				ret 
5ec6			;endif 
5ec6			 
5ec6			include "forth_autostart.asm" 
5ec6			; list of commands to perform at system start up 
5ec6			 
5ec6			startcmds: 
5ec6			;	dw test11 
5ec6			;	dw test12 
5ec6			;	dw test13 
5ec6			;	dw test14 
5ec6			;	dw test15 
5ec6			;	dw test16 
5ec6			;	dw test17 
5ec6			;	dw ifthtest1 
5ec6			;	dw ifthtest2 
5ec6			;	dw ifthtest3 
5ec6			;	dw mmtest1 
5ec6			;	dw mmtest2 
5ec6			;	dw mmtest3 
5ec6			;	dw mmtest4 
5ec6			;	dw mmtest5 
5ec6			;	dw mmtest6 
5ec6			;	dw iftest1 
5ec6			;	dw iftest2 
5ec6			;	dw iftest3 
5ec6			;	dw looptest1 
5ec6			;	dw looptest2 
5ec6			;	dw test1 
5ec6			;	dw test2 
5ec6			;	dw test3 
5ec6			;	dw test4 
5ec6			;	dw game2r 
5ec6			;	dw game2b1 
5ec6			;	dw game2b2 
5ec6			 
5ec6				; start up words that are actually useful 
5ec6			 
5ec6 ce 5f		    dw spi1 
5ec8 27 60		    dw spi2 
5eca b5 60		    dw spi3 
5ecc 5d 60		    dw spi4 
5ece 88 60		    dw spi5 
5ed0 1b 61		    dw spi6 
5ed2 70 61		    dw spi7 
5ed4			 
5ed4 c8 61		    dw spi8 
5ed6 e7 61		    dw spi9 
5ed8 3f 62		    dw spi10 
5eda			 
5eda			; file editor 
5eda 40 5f			dw edit1 
5edc 61 5f			dw edit2 
5ede 96 5f			dw edit3 
5ee0			 
5ee0 b2 62			dw longread 
5ee2 f9 62			dw clrstack 
5ee4 2c 63			dw type 
5ee6 17 65			dw stest 
5ee8 50 63			dw strncpy 
5eea ad 64			dw list 
5eec b1 63			dw start1 
5eee c1 63			dw start2 
5ef0			;	dw start3 
5ef0 d2 63			dw start3b 
5ef2 4d 64			dw start3c 
5ef4			 
5ef4				; (unit) testing words 
5ef4			 
5ef4 8e 65			dw mtesta 
5ef6 43 66			dw mtestb 
5ef8 e6 66			dw mtestc 
5efa 9b 67			dw mtestd 
5efc 3f 68			dw mteste 
5efe			 
5efe				; demo/game words 
5efe			 
5efe 4b 6f		        dw game3w 
5f00 79 6f		        dw game3p 
5f02 97 6f		        dw game3sc 
5f04 c8 6f		        dw game3vsi 
5f06 f4 6f		        dw game3vs 
5f08				 
5f08 3e 6d			dw game2b 
5f0a ac 6d			dw game2bf 
5f0c f6 6d			dw game2mba 
5f0e 8c 6e			dw game2mbas 
5f10 ce 6e			dw game2mb 
5f12			 
5f12 ff 69			dw game1 
5f14 10 6a			dw game1a 
5f16 72 6a			dw game1b 
5f18 a7 6a			dw game1c 
5f1a dd 6a			dw game1d 
5f1c 0e 6b			dw game1s 
5f1e 22 6b			dw game1t 
5f20 37 6b			dw game1f 
5f22 6b 6b			dw game1z 
5f24 af 6b			dw game1zz 
5f26			 
5f26 f5 68			dw test5 
5f28 2d 69			dw test6 
5f2a 65 69			dw test7 
5f2c 79 69			dw test8 
5f2e a5 69			dw test9 
5f30 bb 69			dw test10 
5f32				 
5f32 86 6c		        dw ssv5 
5f34 6a 6c		        dw ssv4 
5f36 4e 6c		        dw ssv3 
5f38 18 6c		        dw ssv2 
5f3a 9f 6c		        dw ssv1 
5f3c e7 6c		        dw ssv1cpm 
5f3e			;	dw keyup 
5f3e			;	dw keydown 
5f3e			;	dw keyleft 
5f3e			;	dw keyright 
5f3e			;	dw 	keyf1 
5f3e			;	dw keyf2 
5f3e			;	dw keyf3 
5f3e			;	dw keyf4 
5f3e			;	dw keyf5 
5f3e			;	dw keyf6 
5f3e			;	dw keyf7 
5f3e			;	dw keyf8 
5f3e			;	dw keyf9 
5f3e			;	dw keyf10 
5f3e			;	dw keyf11 
5f3e			;	dw keyf12 
5f3e			;	dw keytab 
5f3e			;	dw keycr 
5f3e			;	dw keyhome 
5f3e			;	dw keyend 
5f3e			;	dw keybs 
5f3e 00 00			db 0, 0	 
5f40			 
5f40			 
5f40			; File Editor 
5f40			 
5f40			; ( id - ) use 'e' to edit the displayed line 
5f40 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5f61 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5f96			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5f96 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
5fce			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
5fce			 
5fce			; SPI Net support words 
5fce			 
5fce			; v0! = node to send to 
5fce			; ( str count - ) 
5fce .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
6027			 
6027			; spiputchr ( char node - ) 
6027 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
605d			 
605d			; spigetchr ( - n ) 
605d .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
6088			 
6088			; getnode ( - n ) 
6088 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
60b5			 
60b5			; ( str node - )  
60b5 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
611b			; store string ( str i - ) 
611b			 
611b			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
611b .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
6170			 
6170			; get string ( addr i -  )    TO FIX 
6170			 
6170 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
61c8			 
61c8			 
61c8			; NETCHAT (TODO) 
61c8			; Program to allow two nodes to chat with eachother 
61c8			; 
61c8			; v0 - target node 
61c8			;  
61c8			; accept input at 0,0 
61c8			; if input is string send spitype to target node 
61c8			; starting at row 2,0 , while spigetchr is not zero ->  
61c8			; 
61c8			; 
61c8			; TODO add paging of get request 
61c8			 
61c8			; ( node - ) 
61c8 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
61e7 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
623f .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
62b2			 
62b2			 
62b2			; Long read of currently open file 
62b2 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
62f9			 
62f9			; clear stack  
62f9			 
62f9 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
632c			 
632c			; type ( addr count - ) 
632c .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
6350			 
6350			; some direct memory words 
6350			; strncpy ( len t f -- t ) 
6350			 
6350 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
63b1			 
63b1 .. 00		start1:     	db ": bpon $00 bp ;",0 
63c1 .. 00		start2:     	db ": bpoff $01 bp ;",0 
63d2 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
644d .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
64ad			 
64ad			 
64ad			; a handy word to list items on the stack 
64ad			 
64ad .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
6517			 
6517			 
6517			; test stack  
6517			; rnd8 stest 
6517			 
6517 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
658e			 
658e			; random malloc and free cycles 
658e			 
658e .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6643			 
6643			; fixed malloc and free cycles 
6643			 
6643 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
66e6			 
66e6			; fixed double string push and drop cycle  
66e6			 
66e6 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
679b			 
679b			; consistent fixed string push and drop cycle  
679b			 
679b .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
683f			 
683f .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
68f5			 
68f5			;test1:		db ": aa 1 2 3 ;", 0 
68f5			;test2:     	db "111 aa 888 999",0 
68f5			;test3:     	db ": bb 77 ;",0 
68f5			;test4:     	db "$02 $01 do i . loop bb",0 
68f5			 
68f5 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
692d .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6965 .. 00		test7:     	db ": box hline vline ;",0 
6979 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
69a5 .. 00		test9:     	db ": sw $01 adsp world ;",0 
69bb .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
69e0 .. 00		test11:     	db "hello create .",0 
69ef .. 00		test12:     	db "hello2 create .",0 
69ff			 
69ff			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
69ff			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
69ff			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
69ff			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
69ff			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
69ff			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
69ff			 
69ff			;iftest1:     	db "$0001 IF cls .",0 
69ff			;iftest2:     	db "$0000 IF cls .",0 
69ff			;iftest3:     	db "$0002 $0003 - IF cls .",0 
69ff			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
69ff			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
69ff			 
69ff			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
69ff			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
69ff			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
69ff			 
69ff			 
69ff			 
69ff			; a small guess the number game 
69ff			 
69ff .. 00		game1:          db ": gsn rnd8 v1! ;",0 
6a10 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6a72			 
6a72 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6aa7 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6add .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6b0e .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6b22 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6b37 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6b6b .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6baf			 
6baf			; Using 'ga' save a high score across multiple runs using external storage 
6baf			 
6baf .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6c18			 
6c18			 
6c18			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6c18			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6c18			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6c18			 
6c18			; simple screen saver to test code memory reuse to destruction 
6c18			 
6c18 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6c4e .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6c6a .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6c86 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6c9f .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6ce7 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6d3e			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6d3e			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6d3e			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6d3e			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6d3e			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6d3e			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6d3e			 
6d3e			 
6d3e			 
6d3e			; minesweeper/battleship finding game 
6d3e			; draws a game board of random ship/mine positions 
6d3e			; user enters coords to see if it hits on 
6d3e			; game ends when all are hit 
6d3e			; when hit or miss says how many may be in the area 
6d3e			 
6d3e			; setup the game board and then hide it 
6d3e .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6dac .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6df6			; prompt for where to target 
6df6 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6e8c .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6eb1			; TODO see if the entered coords hits or misses pushes char hit of miss 
6eb1 .. 00		game2mbht:      db ": mbckht nop ;",0 
6ec0 .. 00		game2mbms:      db ": mbcms nop ;",0 
6ece			; TODO how many might be near by 
6ece .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6f4b			 
6f4b			; Game 3 
6f4b			 
6f4b			; Vert scroller ski game - avoid the trees! 
6f4b			 
6f4b			; v0 score (ie turns) 
6f4b			; v1 player pos 
6f4b			; v2 left wall 
6f4b			; v3 right wall 
6f4b			 
6f4b			; Draw side walls randomly 
6f4b			 
6f4b .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6f79			 
6f79			; Draw player 
6f79 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6f97			 
6f97			; TODO Get Key 
6f97			 
6f97			; TODO Move left right 
6f97			 
6f97			; scroll and move walls a bit 
6f97			 
6f97 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6fc8			 
6fc8			; main game loop 
6fc8			 
6fc8 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6ff4 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
7033			 
7033			; key board defs 
7033			 
7033 .. 00		keyup:       db ": keyup $05 ;",0 
7041 .. 00		keydown:       db ": keydown $0a ;",0 
7051 .. 00		keyleft:       db ": keyleft $0b ;",0 
7061 .. 00		keyright:       db ": keyright $0c ;",0 
7072 .. 00		keyf1:       db ": keyf1 $10 ;",0 
7080 .. 00		keyf2:       db ": keyf2 $11 ;",0 
708e .. 00		keyf3:       db ": keyf3 $12 ;",0 
709c .. 00		keyf4:       db ": keyf4 $13 ;",0 
70aa .. 00		keyf5:       db ": keyf5 $14 ;",0 
70b8 .. 00		keyf6:       db ": keyf6 $15 ;",0 
70c6 .. 00		keyf7:       db ": keyf7 $16 ;",0 
70d4 .. 00		keyf8:       db ": keyf8 $17 ;",0 
70e2 .. 00		keyf9:       db ": keyf9 $18 ;",0 
70f0 .. 00		keyf10:       db ": keyf10 $19 ;",0 
70ff .. 00		keyf11:       db ": keyf11 $1a ;",0 
710e .. 00		keyf12:       db ": keyf12 $1b ;",0 
711d			 
711d .. 00		keytab:       db ": keytab $09 ;",0 
712c .. 00		keycr:       db ": keycr $0d ;",0 
713a .. 00		keyhome:       db ": keyhome $0e ;",0 
714a .. 00		keyend:       db ": keyend $0f ;",0 
7159 .. 00		keybs:       db ": keybs $08 ;",0 
7167			 
7167			   
7167			 
7167			 
7167			 
7167			; eof 
# End of file forth_autostart.asm
7167			 
7167			 
7167			 
7167			; stack over and underflow checks 
7167			 
7167			; init the words to detect the under/overflow 
7167			 
7167			chk_stk_init: 
7167				; a vague random number to check so we dont get any "lucky" hits 
7167 3e 2d			ld a, 45 
7169 6f				ld l, a 
716a 00				nop 
716b 3e 17			ld a, 23 
716d 67				ld h, a 
716e			 
716e 22 ab f1			ld (chk_word), hl     ; the word we need to check against 
7171			 
7171			;	ld (chk_stund), hl	; stack points.... 
7171 22 fd fe			ld (chk_stovr), hl 
7174 22 ef f9			ld (chk_ret_und), hl 
7177 22 ad f9			ld (chk_ret_ovr), hl 
717a 22 2b f9			ld (chk_loop_ovr), hl 
717d 22 29 f7			ld (chk_data_ovr), hl 
7180 c9				ret 
7181				 
7181			check_stacks: 
7181				; check all stack words 
7181			 
7181 e5				push hl 
7182 d5				push de 
7183			 
7183			;	ld de,(chk_word) 
7183			;	ld hl, (chk_stund)	; stack points.... 
7183			;	if DEBUG_STK_FAULT 
7183			;		DMARK "FAa" 
7183			;		CALLMONITOR 
7183			;	endif 
7183			;	call cmp16 
7183			;	jp z, .chk_faulta 
7183			; 
7183			;	ld de, sfaultsu 
7183			;	jp .chk_fault 
7183			 
7183 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
7186 ed 5b ab f1		ld de,(chk_word) 
718a				if DEBUG_STK_FAULT 
718a					DMARK "FAb" 
718a					CALLMONITOR 
718a				endif 
718a cd a4 0f			call cmp16 
718d 28 06			jr z, .chk_fault1 
718f 11 30 72			ld de, sfaultso 
7192 c3 e4 71			jp .chk_fault 
7195			.chk_fault1:  
7195 2a ef f9			ld hl, (chk_ret_und) 
7198 ed 5b ab f1		ld de,(chk_word) 
719c				if DEBUG_STK_FAULT 
719c					DMARK "FAU" 
719c					CALLMONITOR 
719c				endif 
719c cd a4 0f			call cmp16 
719f ca a8 71			jp z, .chk_fault2 
71a2 11 40 72			ld de, sfaultru 
71a5 c3 e4 71			jp .chk_fault 
71a8			.chk_fault2:  
71a8 2a ad f9			ld hl, (chk_ret_ovr) 
71ab ed 5b ab f1		ld de,(chk_word) 
71af				if DEBUG_STK_FAULT 
71af					DMARK "FA1" 
71af					CALLMONITOR 
71af				endif 
71af cd a4 0f			call cmp16 
71b2 ca bb 71			jp z, .chk_fault3 
71b5 11 4e 72			ld de, sfaultro 
71b8 c3 e4 71			jp .chk_fault 
71bb			.chk_fault3:  
71bb 2a 2b f9			ld hl, (chk_loop_ovr) 
71be ed 5b ab f1		ld de,(chk_word) 
71c2				if DEBUG_STK_FAULT 
71c2					DMARK "FA2" 
71c2					CALLMONITOR 
71c2				endif 
71c2 cd a4 0f			call cmp16 
71c5 ca ce 71			jp z, .chk_fault4 
71c8 11 68 72			ld de, sfaultlo 
71cb c3 e4 71			jp .chk_fault 
71ce			.chk_fault4:  
71ce 2a 29 f7			ld hl, (chk_data_ovr) 
71d1 ed 5b ab f1		ld de,(chk_word) 
71d5				if DEBUG_STK_FAULT 
71d5					DMARK "FA3" 
71d5					CALLMONITOR 
71d5				endif 
71d5 cd a4 0f			call cmp16 
71d8 ca e1 71			jp z, .chk_fault5 
71db 11 82 72			ld de, sfaultdo 
71de c3 e4 71			jp .chk_fault 
71e1			 
71e1			 
71e1			.chk_fault5:  
71e1 d1				pop de 
71e2 e1				pop hl 
71e3			 
71e3 c9				ret 
71e4			 
71e4 cd 52 0d		.chk_fault: 	call clear_display 
71e7 3e 28				ld a, display_row_2 
71e9 cd 65 0d				call str_at_display 
71ec 11 12 72				   ld de, .stackfault 
71ef 3e 00				ld a, display_row_1 
71f1 cd 65 0d				call str_at_display 
71f4 11 6e fe				    ld de, debug_mark 
71f7 3e 11				ld a, display_row_1+17 
71f9 cd 65 0d				call str_at_display 
71fc cd 75 0d				call update_display 
71ff			 
71ff				; prompt before entering montior for investigating issue 
71ff			 
71ff 3e 78			ld a, display_row_4 
7201 11 e5 1d			ld de, endprog 
7204			 
7204 cd 75 0d			call update_display		 
7207			 
7207 cd 6b 20			call next_page_prompt 
720a			 
720a d1				pop de 
720b e1				pop hl 
720c cd 39 1e				call monitor 
720f c3 33 1d				jp warmstart 
7212					;jp 0 
7212					;halt 
7212			 
7212			 
7212			 
7212 .. 00		.stackfault: 	db "Stack fault:",0 
721f			 
721f .. 00		sfaultsu: 	db	"Stack under flow",0 
7230 .. 00		sfaultso: 	db	"Stack over flow",0 
7240 .. 00		sfaultru:	db "RTS underflow",0 
724e .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
7268 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
7282 .. 00		sfaultdo:	db "DTS overflow", 0 
728f			 
728f			 
728f			fault_dsp_under: 
728f 11 a1 72			ld de, .dsp_under 
7292 c3 51 73			jp .show_fault 
7295			 
7295			fault_rsp_under: 
7295 11 af 72			ld de, .rsp_under 
7298 c3 51 73			jp .show_fault 
729b			fault_loop_under: 
729b 11 bd 72			ld de, .loop_under 
729e c3 51 73			jp .show_fault 
72a1			 
72a1 .. 00		.dsp_under: db "DSP Underflow",0 
72af .. 00		.rsp_under: db "RSP Underflow",0 
72bd .. 00		.loop_under: db "LOOP Underflow",0 
72cc			 
72cc			 
72cc d5			type_faultn: 	push de 
72cd e5					push hl 
72ce cd 52 0d				call clear_display 
72d1 11 f8 72				   ld de, .typefaultn 
72d4 3e 00				ld a, display_row_1 
72d6 cd 65 0d				call str_at_display 
72d9 11 6e fe				    ld de, debug_mark 
72dc 3e 11				ld a, display_row_1+17 
72de cd 65 0d				call str_at_display 
72e1 cd 75 0d				call update_display 
72e4			 
72e4				; prompt before entering montior for investigating issue 
72e4			 
72e4 3e 78			ld a, display_row_4 
72e6 11 e5 1d			ld de, endprog 
72e9			 
72e9 cd 75 0d			call update_display		 
72ec			 
72ec cd 6b 20			call next_page_prompt 
72ef			 
72ef e5					push hl 
72f0 d5					push de 
72f1 cd 39 1e				call monitor 
72f4 c3 33 1d				jp warmstart 
72f7 76					halt 
72f8			 
72f8			 
72f8 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
730f			 
730f d5			type_faults: 	push de 
7310 e5					push hl 
7311 cd 52 0d				call clear_display 
7314 11 3a 73				   ld de, .typefaults 
7317 3e 00				ld a, display_row_1 
7319 cd 65 0d				call str_at_display 
731c 11 6e fe				    ld de, debug_mark 
731f 3e 11				ld a, display_row_1+17 
7321 cd 65 0d				call str_at_display 
7324 cd 75 0d				call update_display 
7327			 
7327				; prompt before entering montior for investigating issue 
7327			 
7327 3e 78			ld a, display_row_4 
7329 11 e5 1d			ld de, endprog 
732c			 
732c cd 75 0d			call update_display		 
732f			 
732f cd 6b 20			call next_page_prompt 
7332			 
7332 e1					pop hl 
7333 d1					pop de 
7334 cd 39 1e				call monitor 
7337 c3 33 1d				jp warmstart 
733a			 
733a			 
733a .. 00		.typefaults: db "STR Type Expected TOS!",0 
7351			 
7351			.show_fault: 	 
7351 d5					push de 
7352 cd 52 0d				call clear_display 
7355 d1					pop de 
7356 3e 00				ld a, display_row_1 
7358 cd 65 0d				call str_at_display 
735b 11 6e fe				    ld de, debug_mark 
735e 3e 11				ld a, display_row_1+17 
7360 cd 65 0d				call str_at_display 
7363 cd 75 0d				call update_display 
7366			 
7366				; prompt before entering montior for investigating issue 
7366			 
7366 3e 78			ld a, display_row_4 
7368 11 e5 1d			ld de, endprog 
736b			 
736b cd 75 0d			call update_display		 
736e			 
736e cd 6b 20			call next_page_prompt 
7371			 
7371 e1					pop hl 
7372 d1					pop de 
7373 cd 39 1e				call monitor 
7376			; do a dump to cli and not warmstart so we preserve all of the uwords.  
7376			; TODO Make optional fault restart to cli or warm boot? 
7376					;jp warmstart 
7376 c3 8b 1d				jp cli 
7379 76					halt 
737a			 
737a			; handle the auto run of code from files in storage 
737a			 
737a			 
737a			include "forth_startup.asm" 
737a			; Which startup method to use? 
737a			; 
737a			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
737a			; followed by loading of a list of scripts in eeprom 
737a			 
737a			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
737a			; from eeprom 
737a			 
737a			; Select with define in main stubs 
737a			 
737a			if STARTUP_V1 
737a				include "forth_startupv1.asm" 
737a			endif 
737a			if STARTUP_V2 
737a				include "forth_startupv2.asm" 
737a			; Version 2 of the startup  
737a			;  
737a			; Auto load any files in bank 1 that start with a '*' 
737a			; If no se storage then revert to using eprom 
737a			 
737a			 
737a			if STORAGE_SE = 0 
737a			 
737a			sprompt1: db "Startup load...",0 
737a			sprompt2: db "Run? 1=No *=End #=All",0 
737a			 
737a			 
737a			 
737a			 
737a			forth_startup: 
737a				ld hl, startcmds 
737a				ld a, 0 
737a				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
737a			 
737a			.start1:	push hl 
737a				call clear_display 
737a				ld de, sprompt1 
737a			        ld a, display_row_1 
737a				call str_at_display 
737a				ld de, sprompt2 
737a			        ld a, display_row_2 
737a				call str_at_display 
737a				pop hl 
737a				push hl 
737a				ld e,(hl) 
737a				inc hl 
737a				ld d,(hl) 
737a			        ld a, display_row_3 
737a				call str_at_display 
737a				call update_display 
737a			 
737a			 
737a				ld a, (os_last_cmd) 
737a				cp 0 
737a				jr z, .startprompt 
737a				call delay250ms 
737a				jr .startdo 
737a				 
737a				 
737a			 
737a			.startprompt: 
737a			 
737a				ld a,display_row_4 + display_cols - 1 
737a			        ld de, endprg 
737a				call str_at_display 
737a				call update_display 
737a				call delay1s 
737a				call cin_wait 
737a						 
737a				cp '*' 
737a				jr z, .startupend1 
737a				cp '#' 
737a				jr nz, .startno 
737a				ld a, 1 
737a				ld (os_last_cmd),a 
737a				jr .startdo 
737a			.startno:	cp '1' 
737a				jr z,.startnxt  
737a			 
737a				; exec startup line 
737a			.startdo:	 
737a				pop hl 
737a				push hl 
737a				 
737a				ld e,(hl) 
737a				inc hl 
737a				ld d,(hl) 
737a				ex de,hl 
737a			 
737a				push hl 
737a			 
737a				ld a, 0 
737a				;ld a, FORTH_END_BUFFER 
737a				call strlent 
737a				inc hl   ; include zero term to copy 
737a				ld b,0 
737a				ld c,l 
737a				pop hl 
737a				ld de, scratch 
737a				ldir 
737a			 
737a			 
737a				ld hl, scratch 
737a				call forthparse 
737a				call forthexec 
737a				call forthexec_cleanup 
737a			 
737a				ld a, display_row_4 
737a				ld de, endprog 
737a			 
737a				call update_display		 
737a			 
737a				ld a, (os_last_cmd) 
737a				cp 0 
737a				jr nz, .startnxt 
737a				call next_page_prompt 
737a			        call clear_display 
737a				call update_display		 
737a			 
737a				; move onto next startup line? 
737a			.startnxt: 
737a			 
737a				call delay250ms 
737a				pop hl 
737a			 
737a				inc hl 
737a				inc hl 
737a			 
737a				push hl 
737a				ld e, (hl) 
737a				inc hl 
737a				ld d, (hl) 
737a				pop hl 
737a				; TODO replace 0 test 
737a			 
737a				ex de, hl 
737a				call ishlzero 
737a			;	ld a,e 
737a			;	add d 
737a			;	cp 0    ; any left to do? 
737a				ex de, hl 
737a				jp nz, .start1 
737a				jr .startupend 
737a			 
737a			.startupend1: pop hl 
737a			.startupend: 
737a			 
737a				call clear_display 
737a				call update_display 
737a				ret 
737a			endif 
737a			 
737a			 
737a			if STORAGE_SE 
737a			 
737a			;sprompt3: db "Loading from start-up file:",0 
737a .. 00		sprompt3: db "  Searching...",0 
7389			;sprompt4: db "(Any key to stop)",0 
7389			 
7389			 
7389			forth_autoload: 
7389			 
7389				; load block 0 of store 1 
7389				 
7389 3e fe			ld a, $fe      ; bit 0 clear 
738b 32 63 fa			ld (spi_device), a 
738e			 
738e cd cd 04			call storage_get_block_0 
7391			 
7391 3a 9e fa			ld a, (store_page+STORE_0_AUTOFILE) 
7394			 
7394 fe 00			cp 0 
7396 c8				ret z     ; auto start not enabled 
7397			 
7397 cd 52 0d			call clear_display 
739a			 
739a				; set bank 
739a			 
739a 3a a0 fa				ld a, (store_page+STORE_0_BANKRUN) 
739d 32 63 fa				ld (spi_device), a 
73a0			 
73a0			 
73a0				; generate a directory of bank 1 and search for flagged files 
73a0			 
73a0					if DEBUG_FORTH_WORDS_KEY 
73a0						DMARK "DIR" 
73a0 f5				push af  
73a1 3a b5 73			ld a, (.dmark)  
73a4 32 6e fe			ld (debug_mark),a  
73a7 3a b6 73			ld a, (.dmark+1)  
73aa 32 6f fe			ld (debug_mark+1),a  
73ad 3a b7 73			ld a, (.dmark+2)  
73b0 32 70 fe			ld (debug_mark+2),a  
73b3 18 03			jr .pastdmark  
73b5 ..			.dmark: db "DIR"  
73b8 f1			.pastdmark: pop af  
73b9			endm  
# End of macro DMARK
73b9						CALLMONITOR 
73b9 cd fb 19			call break_point_state  
73bc				endm  
# End of macro CALLMONITOR
73bc					endif 
73bc			 
73bc cd cd 04			call storage_get_block_0 
73bf			 
73bf 21 7d fa			ld hl, store_page     ; get current id count 
73c2 46				ld b, (hl) 
73c3 0e 00			ld c, 0    ; count of files   
73c5					if DEBUG_FORTH_WORDS 
73c5						DMARK "DI1" 
73c5 f5				push af  
73c6 3a da 73			ld a, (.dmark)  
73c9 32 6e fe			ld (debug_mark),a  
73cc 3a db 73			ld a, (.dmark+1)  
73cf 32 6f fe			ld (debug_mark+1),a  
73d2 3a dc 73			ld a, (.dmark+2)  
73d5 32 70 fe			ld (debug_mark+2),a  
73d8 18 03			jr .pastdmark  
73da ..			.dmark: db "DI1"  
73dd f1			.pastdmark: pop af  
73de			endm  
# End of macro DMARK
73de						CALLMONITOR 
73de cd fb 19			call break_point_state  
73e1				endm  
# End of macro CALLMONITOR
73e1					endif 
73e1			 
73e1				; check for empty drive 
73e1			 
73e1 3e 00			ld a, 0 
73e3 b8				cp b 
73e4 ca 31 74			jp z, .dirdone 
73e7			 
73e7				; for each of the current ids do a search for them and if found push to stack 
73e7			 
73e7 c5			.diritem:	push bc 
73e8 21 40 00				ld hl, STORE_BLOCK_PHY 
73eb 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
73ed 58					ld e,b 
73ee			 
73ee d5					push de 
73ef e5					push hl 
73f0 cd 52 0d			call clear_display 
73f3 3e 32			ld a, display_row_2 + 10 
73f5 11 7a 73			ld de, sprompt3 
73f8 cd 65 0d			call str_at_display 
73fb cd a9 0c			call active 
73fe eb				ex de, hl 
73ff 3e 2f			ld a, display_row_2 + 7 
7401 cd 65 0d			call str_at_display 
7404 cd 75 0d			call update_display 
7407 e1				pop hl 
7408 d1				pop de 
7409			 
7409			;		if DEBUG_FORTH_WORDS 
7409			;			DMARK "DI2" 
7409			;			CALLMONITOR 
7409			;		endif 
7409			 
7409 cd 4f 07				call storage_findnextid 
740c			 
740c			;		if DEBUG_FORTH_WORDS 
740c			;			DMARK "DI3" 
740c			;			CALLMONITOR 
740c			;		endif 
740c			 
740c					; if found hl will be non zero 
740c			 
740c cd af 0f				call ishlzero 
740f			;		ld a, l 
740f			;		add h 
740f			; 
740f			;		cp 0 
740f 28 1d				jr z, .dirnotfound 
7411			 
7411					; increase count 
7411			 
7411 c1					pop bc	 
7412 0c					inc c 
7413 c5					push bc 
7414					 
7414			 
7414					; get file header and push the file name 
7414			 
7414 11 7d fa				ld de, store_page 
7417 cd 1c 04				call storage_read_block 
741a			 
741a					; push file id to stack 
741a				 
741a			 
741a					; is this a file we want to run? 
741a			 
741a 21 80 fa				ld hl, store_page+3 
741d 7e					ld a,(hl) 
741e fe 2a				cp '*' 
7420 20 0c				jr nz,  .dirnotfound 
7422					 
7422			 
7422			 
7422 3a 7d fa				ld a, (store_page) 
7425 d5					push de 
7426 e5					push hl 
7427 c5					push bc 
7428 cd 54 74				call .autorunf 
742b c1					pop bc 
742c e1					pop hl 
742d d1					pop de 
742e			 
742e			 
742e			 
742e				; save this extent 
742e			 
742e					; push file name 
742e			;display file name to run 
742e			 
742e			;		ld hl, store_page+3 
742e			;		if DEBUG_FORTH_WORDS 
742e			;			DMARK "DI5" 
742e			;			CALLMONITOR 
742e			;		endif 
742e			; 
742e			;		 
742e			; 
742e			;		call forth_push_str 
742e			;		if DEBUG_FORTH_WORDS 
742e			;			DMARK "DI6" 
742e			;			CALLMONITOR 
742e			;		endif 
742e			.dirnotfound: 
742e c1					pop bc     
742f 10 b6				djnz .diritem 
7431				 
7431			.dirdone:	 
7431					if DEBUG_FORTH_WORDS 
7431						DMARK "DI7" 
7431 f5				push af  
7432 3a 46 74			ld a, (.dmark)  
7435 32 6e fe			ld (debug_mark),a  
7438 3a 47 74			ld a, (.dmark+1)  
743b 32 6f fe			ld (debug_mark+1),a  
743e 3a 48 74			ld a, (.dmark+2)  
7441 32 70 fe			ld (debug_mark+2),a  
7444 18 03			jr .pastdmark  
7446 ..			.dmark: db "DI7"  
7449 f1			.pastdmark: pop af  
744a			endm  
# End of macro DMARK
744a						CALLMONITOR 
744a cd fb 19			call break_point_state  
744d				endm  
# End of macro CALLMONITOR
744d					endif 
744d			 
744d cd 52 0d				call clear_display 
7450 cd 75 0d				call update_display 
7453			 
7453 c9					ret 
7454			 
7454			 
7454			 
7454			 
7454			 
7454			.autorunf: 
7454			 
7454			 
7454				; get file id to load from and get the file name to display 
7454			 
7454			;		ld a, (store_page+STORE_0_FILERUN) 
7454			 
7454 2e 00				ld l, 0 
7456 67					ld h, a 
7457 11 7d fa				ld de, store_page 
745a			 
745a					if DEBUG_FORTH_WORDS 
745a						DMARK "ASp" 
745a f5				push af  
745b 3a 6f 74			ld a, (.dmark)  
745e 32 6e fe			ld (debug_mark),a  
7461 3a 70 74			ld a, (.dmark+1)  
7464 32 6f fe			ld (debug_mark+1),a  
7467 3a 71 74			ld a, (.dmark+2)  
746a 32 70 fe			ld (debug_mark+2),a  
746d 18 03			jr .pastdmark  
746f ..			.dmark: db "ASp"  
7472 f1			.pastdmark: pop af  
7473			endm  
# End of macro DMARK
7473						CALLMONITOR 
7473 cd fb 19			call break_point_state  
7476				endm  
# End of macro CALLMONITOR
7476					endif 
7476 cd 75 09				call storage_read 
7479			 
7479					if DEBUG_FORTH_WORDS 
7479						DMARK "ASr" 
7479 f5				push af  
747a 3a 8e 74			ld a, (.dmark)  
747d 32 6e fe			ld (debug_mark),a  
7480 3a 8f 74			ld a, (.dmark+1)  
7483 32 6f fe			ld (debug_mark+1),a  
7486 3a 90 74			ld a, (.dmark+2)  
7489 32 70 fe			ld (debug_mark+2),a  
748c 18 03			jr .pastdmark  
748e ..			.dmark: db "ASr"  
7491 f1			.pastdmark: pop af  
7492			endm  
# End of macro DMARK
7492						CALLMONITOR 
7492 cd fb 19			call break_point_state  
7495				endm  
# End of macro CALLMONITOR
7495					endif 
7495			 
7495 cd af 0f				call ishlzero 
7498 c8					ret z             ; file not found 
7499			 
7499					; display file name we are loading 
7499			 
7499 cd 52 0d				call clear_display 
749c			 
749c 3e 32				ld a, display_row_2 + 10 
749e 11 80 fa				ld de, store_page+3 
74a1 cd 65 0d				call str_at_display 
74a4				 
74a4			; 
74a4			 
74a4			;	ld a, display_row_1+5 
74a4			;	ld de, sprompt3 
74a4			;	call str_at_display 
74a4			;	ld a, display_row_2+7 
74a4			;	call active 
74a4			;	ex de, hl 
74a4			;;	ld de, sprompt4 
74a4			;	call str_at_display 
74a4			; 
74a4 cd 75 0d			call update_display 
74a7			 
74a7			;	call cin_wait 
74a7			;	cp 'n' 
74a7			;	ret z 
74a7			;	cp 'N' 
74a7			;	ret z 
74a7			 
74a7			;	call delay1s 
74a7			 
74a7 3a 7f fa			ld a, (store_page+2) 
74aa 32 6c fa			ld (store_openmaxext), a    ; save count of ext 
74ad 3e 01			ld a, 1  
74af 32 6d fa			ld (store_openext), a    ; save count of ext 
74b2			 
74b2			.autof: 
74b2				; begin to read a line from file 
74b2			 
74b2 21 eb f4			ld hl, os_cli_cmd 
74b5 22 e9 f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
74b8			  
74b8			.readext: 
74b8 3a 6d fa			ld a, (store_openext) 
74bb 6f				ld l , a 
74bc				 
74bc 3a 7d fa			ld a, (store_page) 
74bf 67				ld h, a	 
74c0 11 7d fa			ld de, store_page 
74c3					if DEBUG_FORTH_WORDS 
74c3						DMARK "ASl" 
74c3 f5				push af  
74c4 3a d8 74			ld a, (.dmark)  
74c7 32 6e fe			ld (debug_mark),a  
74ca 3a d9 74			ld a, (.dmark+1)  
74cd 32 6f fe			ld (debug_mark+1),a  
74d0 3a da 74			ld a, (.dmark+2)  
74d3 32 70 fe			ld (debug_mark+2),a  
74d6 18 03			jr .pastdmark  
74d8 ..			.dmark: db "ASl"  
74db f1			.pastdmark: pop af  
74dc			endm  
# End of macro DMARK
74dc						CALLMONITOR 
74dc cd fb 19			call break_point_state  
74df				endm  
# End of macro CALLMONITOR
74df					endif 
74df cd 75 09				call storage_read 
74e2 cd af 0f			call ishlzero 
74e5 c8				ret z 
74e6			 
74e6			; TODO copy to exec buffer 
74e6			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
74e6			 
74e6				; copy the record buffer to the cli buffer 
74e6			 
74e6 ed 5b e9 f6		ld de, (os_var_array) 
74ea 21 7f fa			ld hl, store_page+2 
74ed			;	ex de, hl 
74ed 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
74f0 ed b0			ldir 
74f2 ed 53 e9 f6		ld (os_var_array), de 
74f6				 
74f6 3a 6d fa			ld a, (store_openext) 
74f9 3c				inc a 
74fa 32 6d fa			ld (store_openext), a    ; save count of ext 
74fd			 
74fd			 
74fd			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
74fd				 
74fd 3a 70 fa			ld a, (store_readcont) 
7500 fe 00			cp 0 
7502 20 b4			jr nz, .readext 
7504			 
7504			;	jr z, .autoend 
7504			 
7504					if DEBUG_FORTH_WORDS 
7504						DMARK "ASc" 
7504 f5				push af  
7505 3a 19 75			ld a, (.dmark)  
7508 32 6e fe			ld (debug_mark),a  
750b 3a 1a 75			ld a, (.dmark+1)  
750e 32 6f fe			ld (debug_mark+1),a  
7511 3a 1b 75			ld a, (.dmark+2)  
7514 32 70 fe			ld (debug_mark+2),a  
7517 18 03			jr .pastdmark  
7519 ..			.dmark: db "ASc"  
751c f1			.pastdmark: pop af  
751d			endm  
# End of macro DMARK
751d						CALLMONITOR 
751d cd fb 19			call break_point_state  
7520				endm  
# End of macro CALLMONITOR
7520					endif 
7520 e5				push hl	 
7521 d5				push de 
7522 cd a9 0c			call active 
7525 eb				ex de, hl 
7526 3e 2f			ld a, display_row_2 + 7 
7528 cd 65 0d			call str_at_display 
752b			 
752b cd 75 0d			call update_display 
752e d1				pop de  
752f e1				pop hl 
7530			;	call delay250ms 
7530			 
7530			 
7530			 
7530			 
7530			.autoexec: 
7530			 
7530			 
7530 21 eb f4			ld hl, os_cli_cmd 
7533					if DEBUG_FORTH_WORDS 
7533						DMARK "ASx" 
7533 f5				push af  
7534 3a 48 75			ld a, (.dmark)  
7537 32 6e fe			ld (debug_mark),a  
753a 3a 49 75			ld a, (.dmark+1)  
753d 32 6f fe			ld (debug_mark+1),a  
7540 3a 4a 75			ld a, (.dmark+2)  
7543 32 70 fe			ld (debug_mark+2),a  
7546 18 03			jr .pastdmark  
7548 ..			.dmark: db "ASx"  
754b f1			.pastdmark: pop af  
754c			endm  
# End of macro DMARK
754c						CALLMONITOR 
754c cd fb 19			call break_point_state  
754f				endm  
# End of macro CALLMONITOR
754f					endif 
754f cd ee 24			call forthparse 
7552 cd 2e 25			call forthexec 
7555 cd 40 24			call forthexec_cleanup 
7558			 
7558			 
7558			 
7558 c3 b2 74			jp .autof 
755b			;.autofdone: 
755b			; 
755b			;		if DEBUG_FORTH_WORDS 
755b			;			DMARK "ASx" 
755b			;			CALLMONITOR 
755b			;		endif 
755b			;;	call clear_display 
755b			;	ret 
755b			 
755b			 
755b			 
755b			endif 
# End of file forth_startupv2.asm
755b			endif 
755b			 
# End of file forth_startup.asm
755b			 
755b			; eof 
# End of file forth_kernel.asm
755b			;include "nascombasic.asm" 
755b			 
755b			 
755b			; find out where the code ends if loaded into RAM (for SC114) 
755b			;endofcode:  
755b			;	nop 
755b			 
755b			 
755b			; eof 
755b			 
# End of file main.asm
755b			include "firmware_lcd_4x40.asm" 
755b			; **********************************************************************  
755b			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
755b			; **********************************************************************  
755b			;  
755b			; **  Written as a Small Computer Monitor App  
755b			; **  www.scc.me.uk  
755b			;  
755b			; History  
755b			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
755b			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
755b			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
755b			;  
755b			; **********************************************************************  
755b			;  
755b			; This program is an example of one of the methods of interfacing an   
755b			; alphanumeric LCD module.   
755b			;  
755b			; In this example the display is connected to either a Z80 PIO or a   
755b			; simple 8-bit output port.   
755b			;  
755b			; This interfacing method uses 4-bit data mode and uses time delays  
755b			; rather than polling the display's ready status. As a result the   
755b			; interface only requires 6 simple output lines:  
755b			;   Output bit 0 = not used  
755b			;   Output bit 1 = not used  
755b			;   Output bit 2 = RS         High = data, Low = instruction  
755b			;   Output bit 3 = E          Active high  
755b			;   Output bit 4 = DB4  
755b			;   Output bit 5 = DB5  
755b			;   Output bit 6 = DB6  
755b			;   Output bit 7 = DB7  
755b			; Display's R/W is connected to 0v so it is always in write mode  
755b			;  
755b			; This set up should work with any system supporting the RC2014 bus  
755b			  
755b			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
755b			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
755b			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
755b			;  
755b			; **********************************************************************  
755b			  
755b			; Additonal for 4x40. E1 and E2 instead of just E   
755b			; TODO swipe vidout signal on port a to activate E2  
755b			  
755b			; **********************************************************************  
755b			; **  Constants  
755b			; **********************************************************************  
755b			; LCD constants required by LCD support module  
755b			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
755b			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
755b			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
755b			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
755b			; TODO Decide which E is being set  
755b			kLCDWidth:  EQU display_cols             ;Width in characters  
755b			  
755b			; **********************************************************************  
755b			; **  Code library usage  
755b			; **********************************************************************  
755b			  
755b			; send character to current cursor position  
755b			; wraps and/or scrolls screen automatically  
755b			  
755b			  
755b			  
755b			lcd_init:  
755b			  
755b			; SCMonAPI functions used  
755b			  
755b			; Alphanumeric LCD functions used  
755b			; no need to specify specific functions for this module  
755b			  
755b 3e cf		            LD   A, 11001111b  
755d d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
755f 3e 00		            LD   A, 00000000b  
7561 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
7563			  
7563			; Initialise alphanumeric LCD module  
7563 3e 00				ld a, 0  
7565 32 ce fb				ld (display_lcde1e2), a  
7568 cd e9 75		            CALL fLCD_Init      ;Initialise LCD module  
756b 3e 01				ld a, 1  
756d 32 ce fb				ld (display_lcde1e2), a  
7570 cd e9 75		            CALL fLCD_Init      ;Initialise LCD module  
7573			  
7573 c9				ret  
7574			  
7574			;  
7574			;;  
7574			; lcd functions  
7574			;  
7574			;  
7574			  
7574			; what is at cursor position   
7574			  
7574			;get_cursor:	ld de, (cursor_row)   ;  row + col  
7574			;		call curptr  
7574			;		ret  
7574			  
7574			  
7574			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
7574			  
7574			curptr:  
7574 c5				push bc  
7575 21 b4 fd			ld hl, display_fb0  
7578			cpr:	  
7578				; loop for cursor whole row  
7578 0e 28			ld c, display_cols  
757a 23			cpr1:	inc hl  
757b 0d				dec c  
757c 20 fc			jr nz, cpr1  
757e 05				dec b  
757f 20 f7			jr nz, cpr  
7581			  
7581				; add col	  
7581			  
7581 23			cpr2:	inc hl  
7582 1d				dec e  
7583 20 fc			jr nz, cpr2  
7585			  
7585 c1				pop bc  
7586 c9				ret  
7587				  
7587			  
7587			  
7587			  
7587			  
7587			; write the frame buffer given in hl to hardware   
7587 22 cc fb		write_display: ld (display_write_tmp), hl 	   
758a 3e 00			ld a, kLCD_Line1  
758c cd 96 76		            CALL fLCD_Pos       ;Position cursor to location in A  
758f 06 28			ld b, display_cols  
7591 ed 5b cc fb		ld de, (display_write_tmp)  
7595 cd e1 75			call write_len_string  
7598				  
7598				  
7598 2a cc fb			ld hl, (display_write_tmp)  
759b 11 28 00			ld de, display_cols  
759e 19				add hl,de  
759f 22 cc fb			ld (display_write_tmp),hl  
75a2			  
75a2				  
75a2 3e 28			ld a, kLCD_Line2  
75a4 cd 96 76		            CALL fLCD_Pos       ;Position cursor to location in A  
75a7 06 28			ld b, display_cols  
75a9 ed 5b cc fb		ld de, (display_write_tmp)  
75ad cd e1 75			call write_len_string  
75b0				  
75b0 2a cc fb			ld hl, (display_write_tmp)  
75b3 11 28 00			ld de, display_cols  
75b6 19				add hl,de  
75b7 22 cc fb			ld (display_write_tmp),hl  
75ba			  
75ba				  
75ba 3e 50			ld a, kLCD_Line3  
75bc cd 96 76		            CALL fLCD_Pos       ;Position cursor to location in A  
75bf 06 28			ld b, display_cols  
75c1 ed 5b cc fb		ld de, (display_write_tmp)  
75c5 cd e1 75			call write_len_string  
75c8				  
75c8 2a cc fb			ld hl, (display_write_tmp)  
75cb 11 28 00			ld de, display_cols  
75ce 19				add hl,de  
75cf 22 cc fb			ld (display_write_tmp),hl  
75d2			  
75d2				  
75d2 3e 78			ld a, kLCD_Line4  
75d4 cd 96 76		            CALL fLCD_Pos       ;Position cursor to location in A  
75d7 06 28			ld b, display_cols  
75d9 ed 5b cc fb		ld de, (display_write_tmp)  
75dd cd e1 75			call write_len_string  
75e0 c9					ret  
75e1				  
75e1				; write out a fixed length string given in b from de  
75e1			  
75e1 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
75e2 cd 4e 76		            CALL fLCD_Data      ;Write character to display  
75e5 13				inc de  
75e6 10 f9			djnz write_len_string  
75e8 c9				ret  
75e9			  
75e9			; Some other things to do  
75e9			;            LD   A, kLCD_Clear ;Display clear  
75e9			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
75e9			;            LD   A, kLCD_Under ;Display on with underscore cursor  
75e9			;            LD   A, kLCD_On     ;Display on with no cursor  
75e9			;            ;LD   A, kLCD_Off   ;Display off  
75e9			;            CALL fLCD_Inst      ;Send instruction to display  
75e9			;  
75e9			;  
75e9			;            halt  
75e9			;  
75e9			;  
75e9			;MsgHello:   DB  "Hello World!",0  
75e9			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
75e9			  
75e9			; Custom characters 5 pixels wide by 8 pixels high  
75e9			; Up to 8 custom characters can be defined  
75e9			;BitMaps:      
75e9			;; Character 0x00 = Battery icon  
75e9			;            DB  01110b  
75e9			;            DB  11011b  
75e9			;            DB  10001b  
75e9			;            DB  10001b  
75e9			;            DB  11111b  
75e9			;            DB  11111b  
75e9			;            DB  11111b  
75e9			;            DB  11111b  
75e9			;; Character 0x01 = Bluetooth icon  
75e9			;            DB  01100b  
75e9			;            DB  01010b  
75e9			;            DB  11100b  
75e9			;            DB  01000b  
75e9			;            DB  11100b  
75e9			;            DB  01010b  
75e9			;            DB  01100b  
75e9			;            DB  00000b  
75e9			;  
75e9			  
75e9			  
75e9			; **********************************************************************  
75e9			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
75e9			; **********************************************************************  
75e9			;  
75e9			; **  Written as a Small Computer Monitor App   
75e9			; **  Version 0.1 SCC 2018-05-16  
75e9			; **  www.scc.me.uk  
75e9			;  
75e9			; **********************************************************************  
75e9			;  
75e9			; This module provides support for alphanumeric LCD modules using with  
75e9			; *  HD44780 (or compatible) controller  
75e9			; *  5 x 7 pixel fonts  
75e9			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
75e9			; *  Interface via six digital outputs to the display (see below)  
75e9			;  
75e9			; LCD module pinout:  
75e9			;   1  Vss   0v supply  
75e9			;   2  Vdd   5v supply  
75e9			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
75e9			;   4  RS    High = data, Low = instruction  
75e9			;   5  R/W   High = Read, Low = Write  
75e9			;   6  E     Enable signal (active high)  
75e9			;   7  DB0   Data bit 0  
75e9			;   8  DB1   Data bit 1  
75e9			;   9  DB2   Data bit 2  
75e9			;  10  DB3   Data bit 3  
75e9			;  11  DB4   Data bit 4  
75e9			;  12  DB5   Data bit 5  
75e9			;  13  DB6   Data bit 6  
75e9			;  14  DB7   Data bit 7  
75e9			;  15  A     Backlight anode (+)  
75e9			;  16  K     Backlight cathode (-)  
75e9			;  
75e9			; This interfacing method uses 4-bit data mode and uses time delays  
75e9			; rather than polling the display's ready status. As a result the   
75e9			; interface only requires 6 simple output lines:  
75e9			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
75e9			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
75e9			;   LCD DB4 = Microcomputer output port bit 4  
75e9			;   LCD DB5 = Microcomputer output port bit 5  
75e9			;   LCD DB6 = Microcomputer output port bit 6  
75e9			;   LCD DB7 = Microcomputer output port bit 7  
75e9			; Display's R/W is connected to 0v so it is always in write mode  
75e9			; All 6 connections must be on the same port address <kLCDPrt>  
75e9			; This method also allows a decent length of cable from micro to LCD  
75e9			;  
75e9			; **********************************************************************  
75e9			;  
75e9			; To include the code for any given function provided by this module,   
75e9			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
75e9			; the parent source file.  
75e9			; For example:  #REQUIRES   uHexPrefix  
75e9			;  
75e9			; Also #INCLUDE this file at some point after the #REQUIRES statements  
75e9			; in the parent source file.  
75e9			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
75e9			;  
75e9			; These are the function names provided by this module:  
75e9			; fLCD_Init                     ;Initialise LCD  
75e9			; fLCD_Inst                     ;Send instruction to LCD  
75e9			; fLCD_Data                     ;Send data byte to LCD  
75e9			; fLCD_Pos                      ;Position cursor  
75e9			; fLCD_Str                      ;Display string  
75e9			; fLCD_Def                      ;Define custom character  
75e9			;  
75e9			; **********************************************************************  
75e9			;  
75e9			; Requires SCMonAPI.asm to also be included in the project  
75e9			;  
75e9			  
75e9			  
75e9			; **********************************************************************  
75e9			; **  Constants  
75e9			; **********************************************************************  
75e9			  
75e9			; Constants that must be defined externally  
75e9			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
75e9			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
75e9			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
75e9			;kLCDWidth: EQU 20             ;Width in characters  
75e9			  
75e9			; general line offsets in any frame buffer  
75e9			  
75e9			  
75e9			display_row_1: equ 0  
75e9			display_row_2: equ display_row_1+display_cols  
75e9			display_row_3: equ display_row_2 + display_cols  
75e9			display_row_4: equ display_row_3 + display_cols  
75e9			;display_row_4_eol:   
75e9			  
75e9			  
75e9			; Cursor position values for the start of each line  
75e9			  
75e9			; E  
75e9			kLCD_Line1: EQU 0x00   
75e9			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
75e9			; E1  
75e9			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
75e9			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
75e9			  
75e9			; Instructions to send as A register to fLCD_Inst  
75e9			kLCD_Clear: EQU 00000001b     ;LCD clear  
75e9			kLCD_Off:   EQU 00001000b     ;LCD off  
75e9			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
75e9			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
75e9			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
75e9			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
75e9			  
75e9			; Constants used by this code module  
75e9			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
75e9			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
75e9			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
75e9			  
75e9			  
75e9			  
75e9			; **********************************************************************  
75e9			; **  LCD support functions  
75e9			; **********************************************************************  
75e9			  
75e9			; Initialise alphanumeric LCD module  
75e9			; LCD control register codes:  
75e9			;   DL   0 = 4-bit mode        1 = 8-bit mode  
75e9			;   N    0 = 1-line mode       1 = 2-line mode  
75e9			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
75e9			;   D    0 = Display off       1 = Display on  
75e9			;   C    0 = Cursor off        1 = Cursor on  
75e9			;   B    0 = Blinking off      1 = Blinking on  
75e9			;   ID   0 = Decrement mode    1 = Increment mode  
75e9			;   SH   0 = Entire shift off  1 = Entire shift on  
75e9 3e 28		fLCD_Init:  LD   A, 40  
75eb cd 10 77		            CALL LCDDelay       ;Delay 40ms after power up  
75ee			; For reliable reset set 8-bit mode - 3 times  
75ee cd e0 76		            CALL WrFn8bit       ;Function = 8-bit mode  
75f1 cd e0 76		            CALL WrFn8bit       ;Function = 8-bit mode  
75f4 cd e0 76		            CALL WrFn8bit       ;Function = 8-bit mode  
75f7			; Set 4-bit mode  
75f7 cd dc 76		            CALL WrFn4bit       ;Function = 4-bit mode  
75fa cd 0e 77		            CALL LCDDelay1      ;Delay 37 us or more  
75fd			; Function set  
75fd 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
75ff cd 12 76		            CALL fLCD_Inst      ;2 line, display on  
7602			; Display On/Off control  
7602 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
7604 cd 12 76		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
7607			; Display Clear  
7607 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
7609 cd 12 76		            CALL fLCD_Inst      ;Clear display  
760c			; Entry mode  
760c 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
760e cd 12 76		            CALL fLCD_Inst      ;Increment mode, shift off  
7611			; Display module now initialised  
7611 c9			            RET  
7612			; ok to here  
7612			  
7612			; Write instruction to LCD  
7612			;   On entry: A = Instruction byte to be written  
7612			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7612 f5			fLCD_Inst:  PUSH AF  
7613 f5			            PUSH AF  
7614 cd 26 76		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
7617 f1			            POP  AF  
7618 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7619 17			            RLA  
761a 17			            RLA  
761b 17			            RLA  
761c cd 26 76		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
761f 3e 02		            LD   A, 2  
7621 cd 10 77		            CALL LCDDelay       ;Delay 2 ms to complete   
7624 f1			            POP  AF  
7625 c9			            RET  
7626			Wr4bits:   
7626 f5					push af  
7627 3a ce fb				ld a, (display_lcde1e2)  
762a fe 00				cp 0     ; e  
762c 20 10				jr nz, .wea2	  
762e f1					pop af  
762f e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7631 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7633 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
7635 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
7637 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7639 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
763b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
763d c9			            RET  
763e f1			.wea2:		pop af  
763f e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7641 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7643 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
7645 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
7647 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7649 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
764b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
764d c9			            RET  
764e			  
764e			  
764e			; Write data to LCD  
764e			;   On entry: A = Data byte to be written  
764e			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
764e f5			fLCD_Data:  PUSH AF  
764f f5			            PUSH AF  
7650 cd 62 76		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
7653 f1			            POP  AF  
7654 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7655 17			            RLA  
7656 17			            RLA  
7657 17			            RLA  
7658 cd 62 76		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
765b 3e 96		            LD   A, 150  
765d 3d			Wait:      DEC  A              ;Wait a while to allow data   
765e 20 fd		            JR   NZ, Wait      ;  write to complete  
7660 f1			            POP  AF  
7661 c9			            RET  
7662			Wr4bitsa:     
7662 f5					push af  
7663 3a ce fb				ld a, (display_lcde1e2)  
7666 fe 00				cp 0     ; e1  
7668 20 16				jr nz, .we2	  
766a f1					pop af  
766b e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
766d cb d7		            SET  kLCDBitRS, A  
766f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7671 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
7673 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
7675 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7677 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
7679 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
767b cb 97		            RES  kLCDBitRS, A  
767d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
767f c9			            RET  
7680 f1			.we2:		pop af  
7681 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7683 cb d7		            SET  kLCDBitRS, A  
7685 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7687 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
7689 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
768b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
768d cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
768f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7691 cb 97		            RES  kLCDBitRS, A  
7693 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7695 c9			            RET  
7696			  
7696			  
7696			; Position cursor to specified location  
7696			;   On entry: A = Cursor position  
7696			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7696 f5			fLCD_Pos:   PUSH AF  
7697					; at this point set the E1 or E2 flag depending on position  
7697			  
7697 c5					push bc  
7698			;		push af  
7698 06 00				ld b, 0  
769a 4f					ld c, a  
769b 3e 4f				ld a, kLCD_Line3-1  
769d b7			 		or a      ;clear carry flag  
769e 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
769f 38 04				jr c, .pe1  
76a1			  
76a1					; E selection  
76a1 cb 80				res 0, b         ; bit 0 unset e  
76a3			;		pop af    ; before line 3 so recover orig pos  
76a3			;		ld c, a    ; save for poking back  
76a3 18 06				jr .peset	          
76a5			.pe1:          	; E2 selection  
76a5 cb c0				set 0, b         ; bit 0 set e1  
76a7 79					ld a, c  
76a8 de 4f				sbc a, kLCD_Line3-1  
76aa 4f					ld c, a	         ; save caculated offset  
76ab			;		pop af     ; bin this original value now we have calculated form  
76ab			  
76ab			.peset:		; set bit  
76ab 78					ld a, b  
76ac 32 ce fb				ld (display_lcde1e2), a 	  
76af 79					ld a, c  
76b0 c1					pop bc  
76b1			  
76b1 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
76b3 cd 12 76		            CALL fLCD_Inst      ;Write instruction to LCD  
76b6 f1			            POP  AF  
76b7 c9			            RET  
76b8			  
76b8			  
76b8			; Output text string to LCD  
76b8			;   On entry: DE = Pointer to null terminated text string  
76b8			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
76b8 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
76b9 b7			            OR   A              ;Null terminator?  
76ba c8			            RET  Z              ;Yes, so finished  
76bb cd 4e 76		            CALL fLCD_Data      ;Write character to display  
76be 13			            INC  DE             ;Point to next character  
76bf 18 f7		            JR   fLCD_Str       ;Repeat  
76c1 c9					ret  
76c2			  
76c2			; Define custom character  
76c2			;   On entry: A = Character number (0 to 7)  
76c2			;             DE = Pointer to character bitmap data  
76c2			;   On exit:  A = Next character number  
76c2			;             DE = Next location following bitmap  
76c2			;             BC HL IX IY I AF' BC' DE' HL' preserved  
76c2			; Character is   
76c2 c5			fLCD_Def:   PUSH BC  
76c3 f5			            PUSH AF  
76c4 07			            RLCA                ;Calculate location  
76c5 07			            RLCA                ;  for bitmap data  
76c6 07			            RLCA                ;  = 8 x CharacterNumber  
76c7 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
76c9 cd 12 76		            CALL fLCD_Inst      ;Write instruction to LCD  
76cc 06 00		            LD   B, 0  
76ce 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
76cf cd 4e 76		            CALL fLCD_Data      ;Write byte to display  
76d2 13			            INC  DE             ;Point to next byte  
76d3 04			            INC  B              ;Count bytes  
76d4 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
76d6 28 f6		            JR   Z, Loop       ;No, so repeat  
76d8 f1			            POP  AF  
76d9 3c			            INC  A              ;Increment character number  
76da c1			            POP  BC  
76db c9			            RET  
76dc			  
76dc			  
76dc			; **********************************************************************  
76dc			; **  Private functions  
76dc			; **********************************************************************  
76dc			  
76dc			; Write function to LCD  
76dc			;   On entry: A = Function byte to be written  
76dc			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
76dc 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
76de 18 02		            JR   WrFunc  
76e0 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
76e2 f5			WrFunc:     PUSH AF  
76e3 f5					push af  
76e4 3a ce fb				ld a, (display_lcde1e2)  
76e7 fe 00				cp 0     ; e1  
76e9 20 0f				jr nz, .wfea2	  
76eb f1					pop af  
76ec d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
76ee cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
76f0 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
76f2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
76f4 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
76f6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
76f8 18 0d			jr .wfskip  
76fa f1			.wfea2:		pop af  
76fb d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
76fd cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
76ff cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7701 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7703 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7705 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7707 3e 05		.wfskip:            LD  A, 5  
7709 cd 10 77		            CALL LCDDelay       ;Delay 5 ms to complete  
770c f1			            POP  AF  
770d c9			            RET  
770e			  
770e			  
770e			; Delay in milliseconds  
770e			;   On entry: A = Number of milliseconds delay  
770e			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
770e 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
7710 d5			LCDDelay:   PUSH DE  
7711 5f			            LD   E, A           ;Delay by 'A' ms  
7712 16 00		            LD   D, 0  
7714 cd 7a 0c		            CALL aDelayInMS  
7717 d1			            POP  DE  
7718 c9			            RET  
7719			  
7719			  
7719			testlcd:  
7719 3e 00			ld a, kLCD_Line1  
771b cd 96 76			call fLCD_Pos  
771e 06 28			ld b, 40  
7720 11 4e 77			ld de, .ttext1  
7723 cd e1 75			call write_len_string  
7726			  
7726 3e 28			ld a, kLCD_Line2  
7728 cd 96 76			call fLCD_Pos  
772b 06 28			ld b, 40  
772d 11 77 77			ld de, .ttext2  
7730 cd e1 75			call write_len_string  
7733 3e 50			ld a, kLCD_Line3  
7735 cd 96 76			call fLCD_Pos  
7738 06 28			ld b, 40  
773a 11 a0 77			ld de, .ttext3  
773d cd e1 75			call write_len_string  
7740 3e 78			ld a, kLCD_Line4  
7742 cd 96 76			call fLCD_Pos  
7745 06 28			ld b, 40  
7747 11 c9 77			ld de, .ttext4  
774a cd e1 75			call write_len_string  
774d			  
774d 76				halt  
774e			  
774e			  
774e .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
7777 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
77a0 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
77c9 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
77f2			   
77f2			  
77f2			  
77f2			; eof  
77f2			  
# End of file firmware_lcd_4x40.asm
77f2			;include "firmware_lcd_4x20.asm" 
77f2			include "firmware_key_5x10.asm" 
77f2			; 5 x 10 decade counter scanner  
77f2			  
77f2			  
77f2			; TODO do cursor shape change for shift keys  
77f2			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
77f2			  
77f2			  
77f2			; bit mask for each scan column and row for teing the matrix  
77f2			  
77f2			  
77f2			key_init:  
77f2			  
77f2			; SCMonAPI functions used  
77f2			  
77f2			; Alphanumeric LCD functions used  
77f2			; no need to specify specific functions for this module  
77f2			  
77f2			  
77f2 3e cf		            LD   A, 11001111b  
77f4 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
77f6			;            LD   A, 00000000b  
77f6 3e 1f		            LD   A, 00011111b  
77f8 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
77fa			  
77fa			  
77fa				; TODO Configure cursor shapes  
77fa			  
77fa				; Load cursor shapes   
77fa 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
77fc 11 0c 78		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
77ff 06 02		            LD   B, 2           ;Number of characters to define  
7801 cd c2 76		.DefLoop:   CALL fLCD_Def       ;Define custom character  
7804 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
7806			  
7806 3e 01				ld a, 1  
7808 32 c4 fb			ld (cursor_shape),a  
780b c9				ret  
780c			  
780c			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
780c			; Up to 8 custom characters can be defined  
780c			.cursor_shapes:      
780c			;; Character 0x00 = Normal  
780c 1f			            DB  11111b  
780d 1f			            DB  11111b  
780e 1f			            DB  11111b  
780f 1f			            DB  11111b  
7810 1f			            DB  11111b  
7811 1f			            DB  11111b  
7812 1f			            DB  11111b  
7813 1f			            DB  11111b  
7814			;; Character 0x01 = Modifier  
7814 1f			            DB  11111b  
7815 1b			            DB  11011b  
7816 1b			            DB  11011b  
7817 1b			            DB  11011b  
7818 1b			            DB  11011b  
7819 1f			            DB  11111b  
781a 1b			            DB  11011b  
781b 1f			            DB  11111b  
781c			  
781c			  
781c			  
781c			  
781c			; Display custom character 0  
781c			;            LD   A, kLCD_Line1+14  
781c			;            CALL fLCD_Pos       ;Position cursor to location in A  
781c			;            LD   A, 0  
781c			;            CALL fLCD_Data      ;Write character in A at cursor  
781c			  
781c			; Display custom character 1  
781c			;            LD   A, kLCD_Line2+14  
781c			;            CALL fLCD_Pos      ;Position cursor to location in A  
781c			;            LD   A, 1  
781c			;            CALL fLCD_Data     ;Write character in A at cursor  
781c			  
781c			; keyboard scanning   
781c			  
781c			; character in from keyboard  
781c			  
781c			; mapping for the pcb layout  
781c			  
781c			.matrix_to_char:  
781c .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
7827 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
7832 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
783d 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
7848 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
7853			.matrix_to_shift:  
7853			  
7853 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
785e .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
7869 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
7874 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
787f .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
788a			  
788a			.matrix_to_symbolshift:  
788a			  
788a fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
7895 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
78a0 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
78ab			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
78ab 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
78b6 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
78c1			  
78c1			  
78c1			  
78c1			; mapping for a simple straight through breadboard layout  
78c1			  
78c1			;.matrix_to_char:  
78c1			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
78c1			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
78c1			;		db "asdfghjkl",KEY_CR,0  
78c1			;		db "qwertyuiop",0  
78c1			;		 db "1234567890",0  
78c1			;.matrix_to_shift:  
78c1			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
78c1			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
78c1			;		db "ASDFGHJKL",KEY_CR,0  
78c1			;		db "QWERTYUIOP",0  
78c1			;		 db "!",'"',"#$%^&*()",0  
78c1			;.matrix_to_symbolshift:  
78c1			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
78c1			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
78c1			;		db "_?*fghjk=",KEY_CR,0  
78c1			;		db "-/+*[]{}@#",0  
78c1			;		 db "1234567890",0  
78c1			  
78c1			;.matrix_to_char: db "D#0*C987B654A321"  
78c1			  
78c1			  
78c1				  
78c1			  
78c1			; add cin and cin_wait  
78c1			  
78c1 cd d2 78		cin_wait: 	call cin  
78c4						if DEBUG_KEYCINWAIT  
78c4							push af  
78c4							  
78c4							ld hl,key_repeat_ct  
78c4							ld (hl),a  
78c4							inc hl  
78c4							call hexout  
78c4							ld hl,key_repeat_ct+3  
78c4							ld a,0  
78c4							ld (hl),a  
78c4			  
78c4							    LD   A, kLCD_Line1+11  
78c4							    CALL fLCD_Pos       ;Position cursor to location in A  
78c4							    LD   DE, key_repeat_ct  
78c4							    ;LD   DE, MsgHello  
78c4							    CALL fLCD_Str       ;Display string pointed to by DE  
78c4			  
78c4			  
78c4			  
78c4							pop af  
78c4						endif  
78c4 fe 00			cp 0  
78c6 28 f9			jr z, cin_wait   ; block until key press  
78c8			  
78c8							if DEBUG_KEYCINWAIT  
78c8								push af  
78c8			  
78c8								ld a, 'A'	  
78c8								ld hl,key_repeat_ct  
78c8								ld (hl),a  
78c8								inc hl  
78c8								ld a,0  
78c8								ld (hl),a  
78c8			  
78c8								    LD   A, kLCD_Line2+11  
78c8								    CALL fLCD_Pos       ;Position cursor to location in A  
78c8								    LD   DE, key_repeat_ct  
78c8								    ;LD   DE, MsgHello  
78c8								    CALL fLCD_Str       ;Display string pointed to by DE  
78c8			  
78c8							call delay500ms  
78c8			  
78c8								pop af  
78c8							endif  
78c8 f5				push af   ; save key pressed  
78c9			  
78c9			.cin_wait1:	  
78c9							if DEBUG_KEYCINWAIT  
78c9								push af  
78c9			  
78c9								ld a, 'b'	  
78c9								ld hl,key_repeat_ct  
78c9								ld (hl),a  
78c9								inc hl  
78c9								ld a,0  
78c9								ld (hl),a  
78c9			  
78c9								    LD   A, kLCD_Line2+11  
78c9								    CALL fLCD_Pos       ;Position cursor to location in A  
78c9								    LD   DE, key_repeat_ct  
78c9								    ;LD   DE, MsgHello  
78c9								    CALL fLCD_Str       ;Display string pointed to by DE  
78c9			  
78c9			  
78c9							call delay500ms  
78c9			  
78c9								pop af  
78c9							endif  
78c9			  
78c9 cd d2 78		call cin  
78cc fe 00			cp 0  
78ce 20 f9			jr nz, .cin_wait1  	; wait for key release  
78d0			if DEBUG_KEYCINWAIT  
78d0				push af  
78d0			  
78d0				ld a, '3'	  
78d0				ld hl,key_repeat_ct  
78d0				ld (hl),a  
78d0				inc hl  
78d0				ld a,0  
78d0				ld (hl),a  
78d0			  
78d0			            LD   A, kLCD_Line2+11  
78d0			            CALL fLCD_Pos       ;Position cursor to location in A  
78d0			            LD   DE, key_repeat_ct  
78d0			            ;LD   DE, MsgHello  
78d0			            CALL fLCD_Str       ;Display string pointed to by DE  
78d0			  
78d0			  
78d0			call delay500ms  
78d0			  
78d0				pop af  
78d0			endif  
78d0			  
78d0 f1				pop af   ; get key  
78d1 c9				ret  
78d2			  
78d2			  
78d2 cd e6 78		cin: 	call .mtoc  
78d5			  
78d5			if DEBUG_KEYCIN  
78d5				push af  
78d5				  
78d5				ld hl,key_repeat_ct  
78d5				ld (hl),a  
78d5				inc hl  
78d5				call hexout  
78d5				ld hl,key_repeat_ct+3  
78d5				ld a,0  
78d5				ld (hl),a  
78d5			  
78d5			            LD   A, kLCD_Line3+15  
78d5			            CALL fLCD_Pos       ;Position cursor to location in A  
78d5			            LD   DE, key_repeat_ct  
78d5			            ;LD   DE, MsgHello  
78d5			            CALL fLCD_Str       ;Display string pointed to by DE  
78d5			  
78d5			  
78d5			call delay500ms  
78d5			  
78d5				pop af  
78d5			endif  
78d5			  
78d5			  
78d5				; no key held  
78d5 fe 00			cp 0  
78d7 c8				ret z  
78d8			  
78d8			if DEBUG_KEYCIN  
78d8				push af  
78d8			  
78d8				ld a, '1'	  
78d8				ld hl,key_repeat_ct  
78d8				ld (hl),a  
78d8				inc hl  
78d8				ld a,0  
78d8				ld (hl),a  
78d8			  
78d8			            LD   A, kLCD_Line4+15  
78d8			            CALL fLCD_Pos       ;Position cursor to location in A  
78d8			            LD   DE, key_repeat_ct  
78d8			            ;LD   DE, MsgHello  
78d8			            CALL fLCD_Str       ;Display string pointed to by DE  
78d8			  
78d8			  
78d8			call delay500ms  
78d8			  
78d8				pop af  
78d8			endif  
78d8			  
78d8				; stop key bounce  
78d8			  
78d8 32 88 fe			ld (key_held),a		 ; save it  
78db 47				ld b, a  
78dc			  
78dc c5			.cina1:	push bc  
78dd			if DEBUG_KEYCIN  
78dd				push af  
78dd			  
78dd				ld hl,key_repeat_ct  
78dd				inc hl  
78dd				call hexout  
78dd				ld hl,key_repeat_ct+3  
78dd				ld a,0  
78dd				ld (hl),a  
78dd				ld hl,key_repeat_ct  
78dd				ld a, '2'	  
78dd				ld (hl),a  
78dd			  
78dd			            LD   A, kLCD_Line4+15  
78dd			            CALL fLCD_Pos       ;Position cursor to location in A  
78dd			            LD   DE, key_repeat_ct  
78dd			            ;LD   DE, MsgHello  
78dd			            CALL fLCD_Str       ;Display string pointed to by DE  
78dd			  
78dd				pop af  
78dd			endif  
78dd cd e6 78			call .mtoc  
78e0 c1				pop bc  
78e1 b8				cp b  
78e2 28 f8			jr z, .cina1  
78e4 78				ld a,b		  
78e5			if DEBUG_KEYCIN  
78e5				push af  
78e5			  
78e5				ld hl,key_repeat_ct  
78e5				inc hl  
78e5				call hexout  
78e5				ld hl,key_repeat_ct+3  
78e5				ld a,0  
78e5				ld (hl),a  
78e5				ld hl,key_repeat_ct  
78e5				ld a, '3'	  
78e5				ld (hl),a  
78e5			  
78e5			            LD   A, kLCD_Line4+15  
78e5			            CALL fLCD_Pos       ;Position cursor to location in A  
78e5			            LD   DE, key_repeat_ct  
78e5			            ;LD   DE, MsgHello  
78e5			            CALL fLCD_Str       ;Display string pointed to by DE  
78e5			  
78e5				pop af  
78e5			endif  
78e5 c9				ret  
78e6			  
78e6			; detect keyboard modifier key press and apply new overlay to the face key held  
78e6			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
78e6			  
78e6			;.cin_map_modifier:   
78e6			;	ld a, (hl)  
78e6			;	and 255  
78e6			;	ret NZ		; modifier key not flagged  
78e6			;  
78e6			;	; get key face  
78e6			;  
78e6			;	ld b,(key_face_held)  
78e6			;  
78e6			;	ld b, key_cols * key_rows  
78e6			;  
78e6			;	push de  
78e6			;	pop hl  
78e6			;  
78e6			;.mmod1: ld a,(hl)   ; get map test  
78e6			;	cp b  
78e6			;	jr z, .mmod2  
78e6			;  
78e6			;  
78e6			;  
78e6			;.mmod2: inc hl    ;   
78e6			;  
78e6			;	  
78e6			;  
78e6			;	  
78e6			;  
78e6			;	ld hl,key_actual_pressed  
78e6			;	ld (hl),a,  
78e6			;	ret  
78e6			  
78e6			; map matrix key held to char on face of key  
78e6			  
78e6			.mtoc:  
78e6			  
78e6			; test decade counter strobes  
78e6			  
78e6			;.decadetest1:  
78e6			  
78e6			; reset counter  
78e6			;ld a, 128  
78e6			;out (portbdata),a  
78e6			  
78e6			  
78e6			;ld b, 5  
78e6			;.dec1:  
78e6			;ld a, 0  
78e6			;out (portbdata),a  
78e6			;call delay1s  
78e6			  
78e6			;ld a, 32  
78e6			;out (portbdata),a  
78e6			;call delay1s  
78e6			;call delay1s  
78e6			;call delay1s  
78e6			;  
78e6			;ld a, 64+32  
78e6			;out (portbdata),a  
78e6			;call delay1s  
78e6			;;djnz .dec1  
78e6			;  
78e6			;jp .decadetest1  
78e6			  
78e6			  
78e6			  
78e6			  
78e6			  
78e6			  
78e6			  
78e6			  
78e6			  
78e6			  
78e6				; scan keyboard matrix and generate raw scan map  
78e6 cd 79 79			call matrix  
78e9			  
78e9				; reuse c bit 0 left modifer button - ie shift  
78e9			        ; reuse c bit 1 for right modifer button - ie symbol shift  
78e9				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
78e9			  
78e9 0e 00			ld c, 0  
78eb			  
78eb				; TODO set flags for modifer key presses   
78eb				; TODO do a search for modifer key...  
78eb			  
78eb				;ld hl,keyscan_table_row4  
78eb 21 e7 fe			ld hl,keyscan_table_row2  
78ee			  
78ee 7e				ld a, (hl)  
78ef fe 23			cp '#'  
78f1 20 07			jr nz, .nextmodcheck  
78f3 cb c1			set 0, c  
78f5 21 53 78			ld hl, .matrix_to_shift  
78f8 18 21			jr .dokeymap  
78fa				; TODO for now igonre  
78fa			.nextmodcheck:  
78fa 21 dc fe			ld hl,keyscan_table_row3  
78fd			  
78fd 7e				ld a, (hl)  
78fe fe 23			cp '#'  
7900 20 07			jr nz, .nextmodcheck2  
7902 cb c9			set 1, c   
7904 21 8a 78			ld hl, .matrix_to_symbolshift  
7907 18 12			jr .dokeymap  
7909			.nextmodcheck2:  
7909 21 f0 fe			ld hl,keyscan_table_row2+9    ; right shift  
790c			  
790c 7e				ld a, (hl)  
790d fe 23			cp '#'  
790f 20 07			jr nz, .donemodcheck  
7911 cb c9			set 1, c   
7913 21 53 78			ld hl, .matrix_to_shift  
7916 18 03			jr .dokeymap  
7918			  
7918				; no modifer found so just map to normal keys  
7918				; get mtoc map matrix to respective keys  
7918			;	ld hl, .matrix_to_char  
7918			;	ld hl, .matrix_to_char  
7918			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7918			;	ld a, KEY_SHIFT  
7918			;	call findchar  
7918			;  
7918			;	; got offset to key modifer in b  
7918			;  
7918			;	ld hl,keyscan_table_row5  
7918			;  
7918			;	ld a,b  
7918			;	call addatohl  
7918			;	ld a,(hl)  
7918			;  
7918			;	cp '#'  
7918			;	jr nz, .nextmodcheck  
7918			;	set 0, c  
7918			;	ld hl, .matrix_to_char  
7918			;	jr .dokeymap  
7918			;	; TODO for now igonre  
7918			;.nextmodcheck:  
7918			;	ld hl, .matrix_to_symbolshift  
7918			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7918			;	ld a, KEY_SYMBOLSHIFT  
7918			;	call findchar  
7918			;  
7918			;  
7918			;	; got offset to key modifer in b  
7918			;  
7918			;	ld hl,keyscan_table_row5  
7918			;  
7918			;	ld a,b  
7918			;	call addatohl  
7918			;	ld a,(hl)  
7918			;  
7918			;	cp '#'  
7918			;	jr nz, .donemodcheck  
7918			;	set 1, c   
7918			;	ld hl, .matrix_to_symbolshift  
7918			;	jr .dokeymap  
7918			  
7918			  
7918			  
7918			.donemodcheck:  
7918				; no modifer found so just map to normal keys  
7918				; get mtoc map matrix to respective keys  
7918 21 1c 78			ld hl, .matrix_to_char  
791b			  
791b			.dokeymap:  
791b				;ld (key_fa), c   
791b cd 34 79			call .mapkeys  
791e			  
791e			  
791e			if DEBUG_KEY  
791e			  
791e			; Display text on first line  
791e			            LD   A, kLCD_Line1  
791e			            CALL fLCD_Pos       ;Position cursor to location in A  
791e			            LD   DE, keyscan_table_row1  
791e			            ;LD   DE, MsgHello  
791e			            CALL fLCD_Str       ;Display string pointed to by DE  
791e			  
791e			; Display text on second line  
791e			            LD   A, kLCD_Line2  
791e			            CALL fLCD_Pos       ;Position cursor to location in A  
791e			            LD   DE, keyscan_table_row2  
791e			            CALL fLCD_Str       ;Display string pointed to by DE  
791e			            LD   A, kLCD_Line3  
791e			            CALL fLCD_Pos       ;Position cursor to location in A  
791e			            LD   DE, keyscan_table_row3  
791e			            CALL fLCD_Str       ;Display string pointed to by DE  
791e			            LD   A, kLCD_Line4  
791e			            CALL fLCD_Pos       ;Position cursor to location in A  
791e			            LD   DE, keyscan_table_row4  
791e			            CALL fLCD_Str       ;Display string pointed to by DE  
791e			            LD   A, kLCD_Line1+10  
791e			            CALL fLCD_Pos       ;Position cursor to location in A  
791e			            LD   DE, keyscan_table_row5  
791e			            CALL fLCD_Str       ;Display string pointed to by DE  
791e			  
791e				;call delay250ms  
791e			endif  
791e			;	jp testkey  
791e			  
791e			; get first char reported  
791e			  
791e 21 c6 fe			ld hl,keyscan_table_row5  
7921			  
7921				;ld b, 46   ; 30 keys to remap + 8 nulls   
7921 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7923			.findkey:  
7923 7e				ld a,(hl)  
7924 fe 00			cp 0  
7926 28 04			jr z, .nextkey  
7928 fe 7e			cp KEY_MATRIX_NO_PRESS  
792a 20 06			jr nz, .foundkey  
792c			.nextkey:  
792c 23				inc hl  
792d 10 f4			djnz .findkey  
792f 3e 00			ld a,0  
7931 c9				ret  
7932			.foundkey:  
7932 7e				ld a,(hl)  
7933 c9				ret  
7934				  
7934			  
7934			; convert the raw key map given hl for destination key  
7934			.mapkeys:  
7934 11 c6 fe			ld de,keyscan_table_row5  
7937			  
7937 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7939			.remap:  
7939 1a				ld a,(de)  
793a fe 23			cp '#'  
793c 20 02			jr nz, .remapnext  
793e				;CALLMONITOR  
793e 7e				ld a,(hl)  
793f 12				ld (de),a  
7940			  
7940			  
7940			  
7940			.remapnext:  
7940 23				inc hl  
7941 13				inc de  
7942 10 f5			djnz .remap  
7944				  
7944 c9				ret  
7945			  
7945			  
7945			  
7945			.mtocold2:  
7945			  
7945			;	; flag if key D is held down and remove from reporting  
7945			;	ld bc, .key_map_fd    
7945			;	ld hl, keyscan_table  
7945			;	ld de, key_fd  
7945			;	call .key_shift_hold  
7945			;	cp 255  
7945			;	jr z, .cinmap  
7945			;	; flag if key C is held down and remove from reporting  
7945			;	ld bc, .key_map_fc    
7945			;	ld hl, keyscan_table+key_cols  
7945			;	ld de, key_fc  
7945			;	call .key_shift_hold  
7945			;	cp 255  
7945			;	jr z, .cinmap  
7945			;	; flag if key B is held down and remove from reporting  
7945			;	ld bc, .key_map_fb    
7945			;	ld hl, keyscan_table+(key_cols*2)  
7945			;	ld de, key_fb  
7945			;	call .key_shift_hold  
7945			;	cp 255  
7945			;	jr z, .cinmap  
7945			;	; flag if key A is held down and remove from reporting  
7945			;	ld bc, .key_map_fa    
7945			;	ld hl, keyscan_table+(key_cols*3)  
7945			;	ld de, key_fa  
7945			;	call .key_shift_hold  
7945			;	cp 255  
7945			;	jr z, .cinmap  
7945			  
7945 11 1c 78			ld de, .matrix_to_char  
7948			  
7948			  
7948			.cinmap1:   
7948				if DEBUG_KEY  
7948			            LD   A, kLCD_Line4  
7948			            CALL fLCD_Pos       ;Position cursor to location in A  
7948					push de  
7948			            LD   DE, keyscan_table  
7948			            CALL fLCD_Str       ;Display string pointed to by DE  
7948					pop de  
7948				endif  
7948			  
7948				; scan key matrix table for any held key  
7948			  
7948				; de holds either the default matrix or one selected above  
7948			  
7948 21 93 fe			ld hl, keyscan_table  
794b 06 32			ld b,key_cols*key_rows  
794d			  
794d 7e			.cin11:	ld a,(hl)  
794e fe 23			cp '#'  
7950 28 08			jr z, .cinhit1  
7952 23				inc hl  
7953 13				inc de  
7954 05				dec b  
7955 20 f6			jr nz, .cin11  
7957				; no key found held  
7957 3e 00			ld a,0  
7959 c9				ret  
795a d5			.cinhit1: push de  
795b e1				pop hl  
795c 7e				ld a,(hl)  
795d c9				ret  
795e			  
795e			; flag a control key is held   
795e			; hl is key pin, de is flag indicator  
795e			  
795e			.key_shift_hold1:  
795e c5				push bc  
795f 3e 01			ld a, 1  
7961 32 c4 fb			ld (cursor_shape),a  
7964 06 00			ld b, 0  
7966 7e				ld a, (hl)  
7967 fe 2e			cp '.'  
7969 28 0a			jr z, .key_shift11  
796b 06 ff			ld b, 255  
796d 3e 2b			ld a, '+'    ; hide key from later scans  
796f 77				ld (hl),a  
7970 3e 02			ld a, 2  
7972 32 c4 fb			ld (cursor_shape),a  
7975			.key_shift11:  
7975				; write flag indicator  
7975 78				ld a,b  
7976 12				ld (de),a  
7977			  
7977 d1				pop de    ; de now holds the key map ptr  
7978 c9				ret  
7979			  
7979				  
7979			  
7979			; scans keyboard matrix and flags key press in memory array	  
7979				  
7979			matrix:  
7979				;call matrix  
7979				; TODO optimise the code....  
7979			  
7979			  
7979			;ld hl, keyscan_table_row1  
7979			;ld de, keyscan_table_row1+1  
7979			;ld bc,46  
7979			;ld a,KEY_MATRIX_NO_PRESS  
7979			;ldir  
7979			  
7979			  
7979			  
7979			; reset counter  
7979 3e 80		ld a, 128  
797b d3 c1		out (portbdata),a  
797d			  
797d 06 0a		ld b, 10  
797f 0e 00		ld c, 0       ; current clock toggle  
7981			  
7981			.colscan:  
7981			  
7981			; set current column  
7981			; disable clock enable and set clock low  
7981			  
7981			;ld a, 0  
7981			;out (portbdata),a  
7981			  
7981			; For each column scan for switches  
7981			  
7981 c5			push bc  
7982 21 89 fe		ld hl, keyscan_scancol  
7985 cd 8e 7a		call .rowscan  
7988 c1			pop bc  
7989			  
7989			  
7989			; get back current column  
7989			  
7989			; translate the row scan  
7989			  
7989			;   
7989			; row 1  
7989			  
7989 78			ld a,b  
798a			  
798a 21 fc fe		LD   hl, keyscan_table_row1+10  
798d			  
798d cd 98 0f		call subafromhl  
7990			;call addatohl  
7990			  
7990 11 89 fe		ld de, keyscan_scancol  
7993			  
7993 1a			ld a,(de)  
7994 77			ld (hl),a  
7995			  
7995			  
7995			  
7995			  
7995			; row 2  
7995			  
7995 78			ld a,b  
7996			  
7996 21 f1 fe		LD   hl, keyscan_table_row2+10  
7999			  
7999			;call addatohl  
7999 cd 98 0f		call subafromhl  
799c			  
799c			  
799c 11 8a fe		ld de, keyscan_scancol+1  
799f			  
799f 1a			ld a,(de)  
79a0 77			ld (hl),a  
79a1			  
79a1			  
79a1			; row 3  
79a1			  
79a1 78			ld a,b  
79a2			  
79a2 21 e6 fe		LD   hl, keyscan_table_row3+10  
79a5			  
79a5			;call addatohl  
79a5 cd 98 0f		call subafromhl  
79a8			  
79a8 11 8b fe		ld de, keyscan_scancol+2  
79ab			  
79ab 1a			ld a,(de)  
79ac 77			ld (hl),a  
79ad			  
79ad			  
79ad			  
79ad			; row 4  
79ad			  
79ad 78			ld a,b  
79ae			  
79ae 21 db fe		LD   hl, keyscan_table_row4+10  
79b1			  
79b1			;call addatohl  
79b1 cd 98 0f		call subafromhl  
79b4			  
79b4 11 8c fe		ld de, keyscan_scancol+3  
79b7			  
79b7 1a			ld a,(de)  
79b8 77			ld (hl),a  
79b9			  
79b9			; row 5  
79b9			  
79b9 78			ld a,b  
79ba			  
79ba 21 d0 fe		LD   hl, keyscan_table_row5+10  
79bd			  
79bd			;call addatohl  
79bd cd 98 0f		call subafromhl  
79c0			  
79c0 11 8d fe		ld de, keyscan_scancol+4  
79c3			  
79c3 1a			ld a,(de)  
79c4 77			ld (hl),a  
79c5			  
79c5			; handshake next column  
79c5			  
79c5			  
79c5 3e 40		ld a, 64  
79c7 d3 c1		out (portbdata),a  
79c9			  
79c9 3e 00		ld a, 0  
79cb d3 c1		out (portbdata),a  
79cd			  
79cd			; toggle clk and move to next column  
79cd			;ld a, 64  
79cd			;cp c  
79cd			;  
79cd			;jr z, .coltoglow  
79cd			;ld c, a  
79cd			;jr .coltog  
79cd			;.coltoglow:  
79cd			;ld c, 0  
79cd			;.coltog:  
79cd			;ld a, c  
79cd			;out (portbdata),a  
79cd			  
79cd 10 b2		djnz .colscan  
79cf			  
79cf 3e 0a		ld a,10  
79d1 21 f2 fe		LD   hl, keyscan_table_row1  
79d4 cd 86 0f		call addatohl  
79d7 3e 00		ld a, 0  
79d9 77			ld (hl), a  
79da			  
79da			  
79da 3e 0a		ld a,10  
79dc 21 e7 fe		LD   hl, keyscan_table_row2  
79df cd 86 0f		call addatohl  
79e2 3e 00		ld a, 0  
79e4 77			ld (hl), a  
79e5			  
79e5 3e 0a		ld a,10  
79e7 21 dc fe		LD   hl, keyscan_table_row3  
79ea cd 86 0f		call addatohl  
79ed 3e 00		ld a, 0  
79ef 77			ld (hl), a  
79f0			  
79f0 3e 0a		ld a,10  
79f2 21 d1 fe		LD   hl, keyscan_table_row4  
79f5 cd 86 0f		call addatohl  
79f8 3e 00		ld a, 0  
79fa 77			ld (hl), a  
79fb			  
79fb 3e 0a		ld a,10  
79fd 21 c6 fe		LD   hl, keyscan_table_row5  
7a00 cd 86 0f		call addatohl  
7a03 3e 00		ld a, 0  
7a05 77			ld (hl), a  
7a06			  
7a06			if DEBUG_KEY_MATRIX  
7a06			  
7a06			; Display text on first line  
7a06			            LD   A, kLCD_Line1  
7a06			            CALL fLCD_Pos       ;Position cursor to location in A  
7a06			            LD   DE, keyscan_table_row1  
7a06			            ;LD   DE, MsgHello  
7a06			            CALL fLCD_Str       ;Display string pointed to by DE  
7a06			  
7a06			; Display text on second line  
7a06			            LD   A, kLCD_Line2  
7a06			            CALL fLCD_Pos       ;Position cursor to location in A  
7a06			            LD   DE, keyscan_table_row2  
7a06			            CALL fLCD_Str       ;Display string pointed to by DE  
7a06			            LD   A, kLCD_Line3  
7a06			            CALL fLCD_Pos       ;Position cursor to location in A  
7a06			            LD   DE, keyscan_table_row3  
7a06			            CALL fLCD_Str       ;Display string pointed to by DE  
7a06			            LD   A, kLCD_Line4  
7a06			            CALL fLCD_Pos       ;Position cursor to location in A  
7a06			            LD   DE, keyscan_table_row4  
7a06			            CALL fLCD_Str       ;Display string pointed to by DE  
7a06			            LD   A, kLCD_Line4+10  
7a06			            CALL fLCD_Pos       ;Position cursor to location in A  
7a06			            LD   DE, keyscan_table_row5  
7a06			            CALL fLCD_Str       ;Display string pointed to by DE  
7a06			  
7a06			;call delay250ms  
7a06				jp matrix  
7a06			endif  
7a06 c9			ret  
7a07			  
7a07			; using decade counter....  
7a07			  
7a07			  
7a07			; TODO reset decade counter to start of scan  
7a07			  
7a07			; reset 15  
7a07			; clock 14  
7a07			; ce 13  
7a07			  
7a07			; 1 - q5  
7a07			; 2 - q1  
7a07			; 3 - q0  
7a07			; 4 - q2  
7a07			; 5 - q6  
7a07			; 6 - q7  
7a07			; 7 - q3  
7a07			; 8 - vss  
7a07			; 9 - q8  
7a07			; 10 - q4  
7a07			; 11 - q9  
7a07			; 12 - cout  
7a07			; 16 - vdd  
7a07			  
7a07			; clock      ce       reset     output  
7a07			; 0          x        0         n  
7a07			; x          1        0         n  
7a07			; x          x        1         q0  
7a07			; rising     0        0         n+1  
7a07			; falling    x        0         n  
7a07			; x          rising   0         n  
7a07			; 1          falling  0         x+1  
7a07			;  
7a07			; x = dont care, if n < 5 carry = 1 otherwise 0  
7a07			  
7a07			;   
7a07			; reset   
7a07			; 13=0, 14=0, 15=1 .. 15=0  
7a07			;  
7a07			; handshake line  
7a07			; 14=1.... read line 14=0  
7a07			  
7a07			  
7a07			  
7a07			  
7a07			  
7a07			; TODO hand shake clock for next column scan  
7a07			; TODO detect each row  
7a07			  
7a07			  
7a07			  
7a07			  
7a07			; reset 128  
7a07			; clock 64  
7a07			; ce 32  
7a07			  
7a07			  
7a07			.cyclestart:  
7a07			  
7a07			; reset counter  
7a07 3e 80		ld a, 128  
7a09 d3 c1		out (portbdata),a  
7a0b			  
7a0b			; loop leds  
7a0b 06 0a		ld b,10  
7a0d			  
7a0d			.cycle1:  
7a0d c5			push bc  
7a0e 3e 00		ld a, 0  
7a10 d3 c1		out (portbdata),a  
7a12 cd 89 0c		call delay250ms  
7a15			  
7a15 3e 40		ld a, 64  
7a17 d3 c1		out (portbdata),a  
7a19 cd 89 0c		call delay250ms  
7a1c			  
7a1c 3e 00		ld a, 0  
7a1e d3 c1		out (portbdata),a  
7a20 cd 89 0c		call delay250ms  
7a23			  
7a23 c1			pop bc  
7a24 10 e7		djnz .cycle1  
7a26			  
7a26			  
7a26 18 df		jr .cyclestart  
7a28			  
7a28			  
7a28			  
7a28			  
7a28			  
7a28			  
7a28			  
7a28			  
7a28			  
7a28			; map matrix key held to char on face of key  
7a28			  
7a28			;.mtocold:  
7a28			;  
7a28			;  
7a28			;; reset counter  
7a28			;ld a, 128  
7a28			;out (portbdata),a  
7a28			;  
7a28			;  
7a28			;; scan keyboard row 1  
7a28			;ld a, 0  
7a28			;out (portbdata),a  
7a28			;;ld a, 64  
7a28			;;out (portbdata),a  
7a28			;  
7a28			;  
7a28			;	ld a, 128  
7a28			;	ld hl, keyscan_table  
7a28			;	call .rowscan  
7a28			;  
7a28			;;ld a, 0  
7a28			;;out (portbdata),a  
7a28			;ld a, 64  
7a28			;out (portbdata),a  
7a28			;  
7a28			;	ld a, 64  
7a28			;	ld hl, keyscan_table+key_cols  
7a28			;	call .rowscan  
7a28			;  
7a28			;ld a, 0  
7a28			;out (portbdata),a  
7a28			;;ld a, 64  
7a28			;;out (portbdata),a  
7a28			;	ld a, 32  
7a28			;	ld hl, keyscan_table+(key_cols*2)  
7a28			;	call .rowscan  
7a28			;  
7a28			;  
7a28			;;ld a, 0  
7a28			;;out (portbdata),a  
7a28			;ld a, 64  
7a28			;out (portbdata),a  
7a28			;  
7a28			;	ld a, 16  
7a28			;	ld hl, keyscan_table+(key_cols*3)  
7a28			;	call .rowscan  
7a28			;  
7a28			;  
7a28			;	; flag if key D is held down and remove from reporting  
7a28			;	ld bc, .key_map_fd    
7a28			;	ld hl, keyscan_table  
7a28			;	ld de, key_fd  
7a28			;	call .key_shift_hold  
7a28			;	cp 255  
7a28			;	jr z, .cinmap  
7a28			;	; flag if key C is held down and remove from reporting  
7a28			;	ld bc, .key_map_fc    
7a28			;	ld hl, keyscan_table+key_cols  
7a28			;	ld de, key_fc  
7a28			;	call .key_shift_hold  
7a28			;	cp 255  
7a28			;	jr z, .cinmap  
7a28			;	; flag if key B is held down and remove from reporting  
7a28			;	ld bc, .key_map_fb    
7a28			;	ld hl, keyscan_table+(key_cols*2)  
7a28			;	ld de, key_fb  
7a28			;	call .key_shift_hold  
7a28			;	cp 255  
7a28			;	jr z, .cinmap  
7a28			;	; flag if key A is held down and remove from reporting  
7a28			;	ld bc, .key_map_fa    
7a28			;	ld hl, keyscan_table+(key_cols*3)  
7a28			;	ld de, key_fa  
7a28			;	call .key_shift_hold  
7a28			;	cp 255  
7a28			;	jr z, .cinmap  
7a28			;  
7a28			;	ld de, .matrix_to_char  
7a28			;  
7a28			;  
7a28			;.cinmap:   
7a28			;	if DEBUG_KEY  
7a28			;            LD   A, kLCD_Line4  
7a28			;            CALL fLCD_Pos       ;Position cursor to location in A  
7a28			;		push de  
7a28			;            LD   DE, keyscan_table  
7a28			;            CALL fLCD_Str       ;Display string pointed to by DE  
7a28			;		pop de  
7a28			;	endif  
7a28			  
7a28				; scan key matrix table for any held key  
7a28			  
7a28				; de holds either the default matrix or one selected above  
7a28			  
7a28			;	ld hl, keyscan_table  
7a28			;	ld b,key_cols*key_rows  
7a28			;  
7a28			;.cin1:	ld a,(hl)  
7a28			;	cp '#'  
7a28			;	jr z, .cinhit  
7a28			;	inc hl  
7a28			;	inc de  
7a28			;	dec b  
7a28			;	jr nz, .cin1  
7a28			;	; no key found held  
7a28			;	ld a,0  
7a28			;	ret  
7a28			;.cinhit: push de  
7a28			;	pop hl  
7a28			;	ld a,(hl)  
7a28			;	ret  
7a28			  
7a28			; flag a control key is held   
7a28			; hl is key pin, de is flag indicator  
7a28			  
7a28			;.key_shift_hold:  
7a28			;	push bc  
7a28			;	ld a, 1  
7a28			;	ld (cursor_shape),a  
7a28			;	ld b, 0  
7a28			;	ld a, (hl)  
7a28			;	cp '.'  
7a28			;	jr z, .key_shift1  
7a28			;	ld b, 255  
7a28			;	ld a, '+'    ; hide key from later scans  
7a28			;	ld (hl),a  
7a28			;	ld a, 2  
7a28			;	ld (cursor_shape),a  
7a28			;.key_shift1:  
7a28			;	; write flag indicator  
7a28			;	ld a,b  
7a28			;	ld (de),a  
7a28			;  
7a28			;	pop de    ; de now holds the key map ptr  
7a28			;	ret  
7a28			  
7a28				  
7a28				  
7a28			  
7a28			  
7a28			  
7a28			  
7a28			  
7a28			  
7a28			  
7a28			  
7a28			  
7a28			  
7a28			  
7a28			;	push hl  
7a28			;	push de  
7a28			;	push bc  
7a28			;	call keyscan  
7a28			;	; map key matrix to ascii value of key face  
7a28			;  
7a28			;	ld hl, key_face_map  
7a28			;	ld de, keyscan_table  
7a28			;  
7a28			;	; get how many keys to look at  
7a28			;	ld b, keyscan_table_len  
7a28			;	  
7a28			;  
7a28			;	; at this stage fall out on first key hit  
7a28			;	; TODO handle multiple key press  
7a28			;  
7a28			;map1:	ld a,(hl)  
7a28			;	cp '#'  
7a28			;	jr z, keyhit  
7a28			;	inc hl  
7a28			;	inc de  
7a28			;	dec b  
7a28			;	jr nz, map1  
7a28			;nohit:	ld a, 0  
7a28			;	jr keydone  
7a28			;keyhit: push de  
7a28			;	pop hl  
7a28			;	ld a,(hl)  
7a28			;keydone:  
7a28			;	push bc  
7a28			;	push de  
7a28			; 	push hl  
7a28			;	ret   
7a28			;  
7a28			  
7a28			  
7a28			  
7a28			  
7a28			; scan physical key matrix  
7a28			  
7a28			  
7a28			;keyscan:  
7a28			;  
7a28			;; for each key_row use keyscanr bit mask for out  
7a28			;; then read in for keyscanc bitmask  
7a28			;; save result of row scan to keyscantable  
7a28			;  
7a28			;; scan keyboard row 1  
7a28			;  
7a28			;	ld b, key_rows  
7a28			;	ld hl, key_scanr  
7a28			;	ld de, keyscan_table  
7a28			;  
7a28			;rowloop:  
7a28			;  
7a28			;	ld a,(hl)		; out bit mask to energise keyboard row  
7a28			;	call rowscan  
7a28			;	inc hl  
7a28			;	dec b  
7a28			;	jr nz, rowloop  
7a28			;  
7a28			;	ret  
7a28			;  
7a28			;  
7a28			;; pass a out bitmask, b row number  
7a28			;arowscan:   
7a28			;	push bc  
7a28			;  
7a28			;	ld d, b  
7a28			;  
7a28			;	; calculate buffer location for this row  
7a28			;  
7a28			;	ld hl, keyscan_table	  
7a28			;kbufr:  ld e, key_cols  
7a28			;kbufc:	inc hl  
7a28			;	dec e  
7a28			;	jr nz, kbufc  
7a28			;	dec d  
7a28			;	jr nz, kbufr  
7a28			;  
7a28			;	; energise row and read columns  
7a28			;  
7a28			;	out (portbdata),a  
7a28			;	in a,(portbdata)  
7a28			;	ld c,a  
7a28			;  
7a28			;  
7a28			;	; save buffer loc  
7a28			;  
7a28			;	ld (keybufptr), hl  
7a28			;  
7a28			;	ld hl, key_scanc  
7a28			;	ld d, key_cols  
7a28			;  
7a28			;	; for each column check each bit mask  
7a28			;  
7a28			;colloop:  
7a28			;	  
7a28			;  
7a28			;	; reset flags for the row   
7a28			;  
7a28			;	ld b,'.'  
7a28			;	and (hl)  
7a28			;	jr z, maskskip  
7a28			;	ld b,'#'  
7a28			;maskskip:  
7a28			;	; save  key state  
7a28			;	push hl  
7a28			;	ld hl, (keybufptr)  
7a28			;	ld (hl), b  
7a28			;	inc hl  
7a28			;	ld (keybufptr), hl  
7a28			;  
7a28			;	; move to next bit mask  
7a28			;	pop hl  
7a28			;	inc hl  
7a28			;  
7a28			;	dec d  
7a28			;	jr nz, colloop  
7a28			;  
7a28			;	ret  
7a28			;  
7a28			;  
7a28			;;  
7a28			; lcd functions  
7a28			;  
7a28			;  
7a28			  
7a28			;if DEBUG_KEY_MATRIX  
7a28			  
7a28			; test function to display hardware view of matrix state  
7a28			  
7a28			matrixold:  
7a28			  
7a28			  
7a28			  
7a28			; reset counter  
7a28 3e 80		ld a, 128  
7a2a d3 c1		out (portbdata),a  
7a2c			; scan keyboard row 1  
7a2c 3e 00		ld a, 0  
7a2e d3 c1		out (portbdata),a  
7a30			;ld a, 64  
7a30			;out (portbdata),a  
7a30 3e 80			ld a, 128  
7a32 21 f2 fe			ld hl, keyscan_table_row1  
7a35 cd 8e 7a			call .rowscan  
7a38			  
7a38			;ld a, 0  
7a38			;out (portbdata),a  
7a38 3e 40		ld a, 64  
7a3a d3 c1		out (portbdata),a  
7a3c 3e 40			ld a, 64  
7a3e 21 e7 fe			ld hl, keyscan_table_row2  
7a41 cd 8e 7a			call .rowscan  
7a44			  
7a44 3e 00		ld a, 0  
7a46 d3 c1		out (portbdata),a  
7a48			;ld a, 64  
7a48			;out (portbdata),a  
7a48 3e 20			ld a, 32  
7a4a 21 dc fe			ld hl, keyscan_table_row3  
7a4d cd 8e 7a			call .rowscan  
7a50			  
7a50			;ld a, 0  
7a50			;out (portbdata),a  
7a50 3e 40		ld a, 64  
7a52 d3 c1		out (portbdata),a  
7a54 3e 10			ld a, 16  
7a56 21 d1 fe			ld hl, keyscan_table_row4  
7a59 cd 8e 7a			call .rowscan  
7a5c			  
7a5c			; Display text on first line  
7a5c 3e 00		            LD   A, kLCD_Line1  
7a5e cd 96 76		            CALL fLCD_Pos       ;Position cursor to location in A  
7a61 11 f2 fe		            LD   DE, keyscan_table_row1  
7a64			            ;LD   DE, MsgHello  
7a64 cd b8 76		            CALL fLCD_Str       ;Display string pointed to by DE  
7a67			  
7a67			; Display text on second line  
7a67 3e 28		            LD   A, kLCD_Line2  
7a69 cd 96 76		            CALL fLCD_Pos       ;Position cursor to location in A  
7a6c 11 e7 fe		            LD   DE, keyscan_table_row2  
7a6f cd b8 76		            CALL fLCD_Str       ;Display string pointed to by DE  
7a72 3e 50		            LD   A, kLCD_Line3  
7a74 cd 96 76		            CALL fLCD_Pos       ;Position cursor to location in A  
7a77 11 dc fe		            LD   DE, keyscan_table_row3  
7a7a cd b8 76		            CALL fLCD_Str       ;Display string pointed to by DE  
7a7d 3e 78		            LD   A, kLCD_Line4  
7a7f cd 96 76		            CALL fLCD_Pos       ;Position cursor to location in A  
7a82 11 d1 fe		            LD   DE, keyscan_table_row4  
7a85 cd b8 76		            CALL fLCD_Str       ;Display string pointed to by DE  
7a88			  
7a88 cd 89 0c			call delay250ms  
7a8b c3 79 79			jp matrix  
7a8e			  
7a8e			; pass de as row display flags  
7a8e			.rowscan:   
7a8e			;	out (portbdata),a  
7a8e db c1			in a,(portbdata)  
7a90 4f				ld c,a  
7a91				; reset flags for the row   
7a91 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7a93 e6 01			and 1  
7a95 28 02			jr z, .p1on  
7a97 06 23			ld b,'#'  
7a99			.p1on:  
7a99 70				ld (hl), b  
7a9a 23				inc hl  
7a9b			  
7a9b 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7a9d 79				ld a,c  
7a9e e6 02			and 2  
7aa0			;	bit 0,a  
7aa0 28 02			jr z, .p2on  
7aa2 06 23			ld b,'#'  
7aa4			.p2on:  
7aa4 70				ld (hl), b  
7aa5 23				inc hl  
7aa6			;  
7aa6 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7aa8 79				ld a,c  
7aa9 e6 04			and 4  
7aab			;;	bit 0,a  
7aab 28 02			jr z, .p3on  
7aad 06 23			ld b,'#'  
7aaf			.p3on:  
7aaf 70				ld (hl), b  
7ab0 23				inc hl  
7ab1			;;  
7ab1 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7ab3			;;	bit 0,a  
7ab3 79				ld a,c  
7ab4 e6 08			and 8  
7ab6 28 02			jr z, .p4on  
7ab8 06 23			ld b,'#'  
7aba			.p4on:  
7aba 70				ld (hl), b  
7abb 23				inc hl  
7abc			  
7abc 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7abe			;;	bit 0,a  
7abe 79				ld a,c  
7abf e6 10			and 16  
7ac1 28 02			jr z, .p5on  
7ac3 06 23			ld b,'#'  
7ac5			.p5on:  
7ac5 70				ld (hl), b  
7ac6 23				inc hl  
7ac7			; zero term  
7ac7 06 00			ld b,0  
7ac9 70				ld (hl), b  
7aca			  
7aca c9			.rscandone: ret  
7acb			  
7acb			;addatohl:  
7acb			;  
7acb			 ;add   a, l    ; A = A+L  
7acb			  ;  ld    l, a    ; L = A+L  
7acb			   ; adc   a, h    ; A = A+L+H+carry  
7acb			   ; sub   l       ; A = H+carry  
7acb			   ; ld    h, a    ; H = H+carry  
7acb			  
7acb			;ret  
7acb			; eof  
# End of file firmware_key_5x10.asm
7acb			;include "firmware_key_4x10.asm" 
7acb			 
7acb			heap_size:    equ heap_end - heap_start 
7acb			;eof 
# End of file os_mega.asm
7acb
